void t4vf_os_link_changed(struct adapter *adapter, int pidx, int link_ok)\r\n{\r\nstruct net_device *dev = adapter->port[pidx];\r\nif (!netif_running(dev) || link_ok == netif_carrier_ok(dev))\r\nreturn;\r\nif (link_ok) {\r\nconst char *s;\r\nconst char *fc;\r\nconst struct port_info *pi = netdev_priv(dev);\r\nnetif_carrier_on(dev);\r\nswitch (pi->link_cfg.speed) {\r\ncase 100:\r\ns = "100Mbps";\r\nbreak;\r\ncase 1000:\r\ns = "1Gbps";\r\nbreak;\r\ncase 10000:\r\ns = "10Gbps";\r\nbreak;\r\ncase 25000:\r\ns = "25Gbps";\r\nbreak;\r\ncase 40000:\r\ns = "40Gbps";\r\nbreak;\r\ncase 100000:\r\ns = "100Gbps";\r\nbreak;\r\ndefault:\r\ns = "unknown";\r\nbreak;\r\n}\r\nswitch (pi->link_cfg.fc) {\r\ncase PAUSE_RX:\r\nfc = "RX";\r\nbreak;\r\ncase PAUSE_TX:\r\nfc = "TX";\r\nbreak;\r\ncase PAUSE_RX|PAUSE_TX:\r\nfc = "RX/TX";\r\nbreak;\r\ndefault:\r\nfc = "no";\r\nbreak;\r\n}\r\nnetdev_info(dev, "link up, %s, full-duplex, %s PAUSE\n", s, fc);\r\n} else {\r\nnetif_carrier_off(dev);\r\nnetdev_info(dev, "link down\n");\r\n}\r\n}\r\nvoid t4vf_os_portmod_changed(struct adapter *adapter, int pidx)\r\n{\r\nstatic const char * const mod_str[] = {\r\nNULL, "LR", "SR", "ER", "passive DA", "active DA", "LRM"\r\n};\r\nconst struct net_device *dev = adapter->port[pidx];\r\nconst struct port_info *pi = netdev_priv(dev);\r\nif (pi->mod_type == FW_PORT_MOD_TYPE_NONE)\r\ndev_info(adapter->pdev_dev, "%s: port module unplugged\n",\r\ndev->name);\r\nelse if (pi->mod_type < ARRAY_SIZE(mod_str))\r\ndev_info(adapter->pdev_dev, "%s: %s port module inserted\n",\r\ndev->name, mod_str[pi->mod_type]);\r\nelse if (pi->mod_type == FW_PORT_MOD_TYPE_NOTSUPPORTED)\r\ndev_info(adapter->pdev_dev, "%s: unsupported optical port "\r\n"module inserted\n", dev->name);\r\nelse if (pi->mod_type == FW_PORT_MOD_TYPE_UNKNOWN)\r\ndev_info(adapter->pdev_dev, "%s: unknown port module inserted,"\r\n"forcing TWINAX\n", dev->name);\r\nelse if (pi->mod_type == FW_PORT_MOD_TYPE_ERROR)\r\ndev_info(adapter->pdev_dev, "%s: transceiver module error\n",\r\ndev->name);\r\nelse\r\ndev_info(adapter->pdev_dev, "%s: unknown module type %d "\r\n"inserted\n", dev->name, pi->mod_type);\r\n}\r\nstatic int link_start(struct net_device *dev)\r\n{\r\nint ret;\r\nstruct port_info *pi = netdev_priv(dev);\r\nret = t4vf_set_rxmode(pi->adapter, pi->viid, dev->mtu, -1, -1, -1, 1,\r\ntrue);\r\nif (ret == 0) {\r\nret = t4vf_change_mac(pi->adapter, pi->viid,\r\npi->xact_addr_filt, dev->dev_addr, true);\r\nif (ret >= 0) {\r\npi->xact_addr_filt = ret;\r\nret = 0;\r\n}\r\n}\r\nif (ret == 0)\r\nret = t4vf_enable_vi(pi->adapter, pi->viid, true, true);\r\nreturn ret;\r\n}\r\nstatic void name_msix_vecs(struct adapter *adapter)\r\n{\r\nint namelen = sizeof(adapter->msix_info[0].desc) - 1;\r\nint pidx;\r\nsnprintf(adapter->msix_info[MSIX_FW].desc, namelen,\r\n"%s-FWeventq", adapter->name);\r\nadapter->msix_info[MSIX_FW].desc[namelen] = 0;\r\nfor_each_port(adapter, pidx) {\r\nstruct net_device *dev = adapter->port[pidx];\r\nconst struct port_info *pi = netdev_priv(dev);\r\nint qs, msi;\r\nfor (qs = 0, msi = MSIX_IQFLINT; qs < pi->nqsets; qs++, msi++) {\r\nsnprintf(adapter->msix_info[msi].desc, namelen,\r\n"%s-%d", dev->name, qs);\r\nadapter->msix_info[msi].desc[namelen] = 0;\r\n}\r\n}\r\n}\r\nstatic int request_msix_queue_irqs(struct adapter *adapter)\r\n{\r\nstruct sge *s = &adapter->sge;\r\nint rxq, msi, err;\r\nerr = request_irq(adapter->msix_info[MSIX_FW].vec, t4vf_sge_intr_msix,\r\n0, adapter->msix_info[MSIX_FW].desc, &s->fw_evtq);\r\nif (err)\r\nreturn err;\r\nmsi = MSIX_IQFLINT;\r\nfor_each_ethrxq(s, rxq) {\r\nerr = request_irq(adapter->msix_info[msi].vec,\r\nt4vf_sge_intr_msix, 0,\r\nadapter->msix_info[msi].desc,\r\n&s->ethrxq[rxq].rspq);\r\nif (err)\r\ngoto err_free_irqs;\r\nmsi++;\r\n}\r\nreturn 0;\r\nerr_free_irqs:\r\nwhile (--rxq >= 0)\r\nfree_irq(adapter->msix_info[--msi].vec, &s->ethrxq[rxq].rspq);\r\nfree_irq(adapter->msix_info[MSIX_FW].vec, &s->fw_evtq);\r\nreturn err;\r\n}\r\nstatic void free_msix_queue_irqs(struct adapter *adapter)\r\n{\r\nstruct sge *s = &adapter->sge;\r\nint rxq, msi;\r\nfree_irq(adapter->msix_info[MSIX_FW].vec, &s->fw_evtq);\r\nmsi = MSIX_IQFLINT;\r\nfor_each_ethrxq(s, rxq)\r\nfree_irq(adapter->msix_info[msi++].vec,\r\n&s->ethrxq[rxq].rspq);\r\n}\r\nstatic void qenable(struct sge_rspq *rspq)\r\n{\r\nnapi_enable(&rspq->napi);\r\nt4_write_reg(rspq->adapter, T4VF_SGE_BASE_ADDR + SGE_VF_GTS,\r\nCIDXINC_V(0) |\r\nSEINTARM_V(rspq->intr_params) |\r\nINGRESSQID_V(rspq->cntxt_id));\r\n}\r\nstatic void enable_rx(struct adapter *adapter)\r\n{\r\nint rxq;\r\nstruct sge *s = &adapter->sge;\r\nfor_each_ethrxq(s, rxq)\r\nqenable(&s->ethrxq[rxq].rspq);\r\nqenable(&s->fw_evtq);\r\nif (adapter->flags & USING_MSI)\r\nt4_write_reg(adapter, T4VF_SGE_BASE_ADDR + SGE_VF_GTS,\r\nCIDXINC_V(0) |\r\nSEINTARM_V(s->intrq.intr_params) |\r\nINGRESSQID_V(s->intrq.cntxt_id));\r\n}\r\nstatic void quiesce_rx(struct adapter *adapter)\r\n{\r\nstruct sge *s = &adapter->sge;\r\nint rxq;\r\nfor_each_ethrxq(s, rxq)\r\nnapi_disable(&s->ethrxq[rxq].rspq.napi);\r\nnapi_disable(&s->fw_evtq.napi);\r\n}\r\nstatic int fwevtq_handler(struct sge_rspq *rspq, const __be64 *rsp,\r\nconst struct pkt_gl *gl)\r\n{\r\nstruct adapter *adapter = rspq->adapter;\r\nu8 opcode = ((const struct rss_header *)rsp)->opcode;\r\nvoid *cpl = (void *)(rsp + 1);\r\nswitch (opcode) {\r\ncase CPL_FW6_MSG: {\r\nconst struct cpl_fw6_msg *fw_msg = cpl;\r\nif (fw_msg->type == FW6_TYPE_CMD_RPL)\r\nt4vf_handle_fw_rpl(adapter, fw_msg->data);\r\nbreak;\r\n}\r\ncase CPL_FW4_MSG: {\r\nconst struct cpl_sge_egr_update *p = (void *)(rsp + 3);\r\nopcode = CPL_OPCODE_G(ntohl(p->opcode_qid));\r\nif (opcode != CPL_SGE_EGR_UPDATE) {\r\ndev_err(adapter->pdev_dev, "unexpected FW4/CPL %#x on FW event queue\n"\r\n, opcode);\r\nbreak;\r\n}\r\ncpl = (void *)p;\r\n}\r\ncase CPL_SGE_EGR_UPDATE: {\r\nconst struct cpl_sge_egr_update *p = cpl;\r\nunsigned int qid = EGR_QID_G(be32_to_cpu(p->opcode_qid));\r\nstruct sge *s = &adapter->sge;\r\nstruct sge_txq *tq;\r\nstruct sge_eth_txq *txq;\r\nunsigned int eq_idx;\r\neq_idx = EQ_IDX(s, qid);\r\nif (unlikely(eq_idx >= MAX_EGRQ)) {\r\ndev_err(adapter->pdev_dev,\r\n"Egress Update QID %d out of range\n", qid);\r\nbreak;\r\n}\r\ntq = s->egr_map[eq_idx];\r\nif (unlikely(tq == NULL)) {\r\ndev_err(adapter->pdev_dev,\r\n"Egress Update QID %d TXQ=NULL\n", qid);\r\nbreak;\r\n}\r\ntxq = container_of(tq, struct sge_eth_txq, q);\r\nif (unlikely(tq->abs_id != qid)) {\r\ndev_err(adapter->pdev_dev,\r\n"Egress Update QID %d refers to TXQ %d\n",\r\nqid, tq->abs_id);\r\nbreak;\r\n}\r\ntxq->q.restarts++;\r\nnetif_tx_wake_queue(txq->txq);\r\nbreak;\r\n}\r\ndefault:\r\ndev_err(adapter->pdev_dev,\r\n"unexpected CPL %#x on FW event queue\n", opcode);\r\n}\r\nreturn 0;\r\n}\r\nstatic int setup_sge_queues(struct adapter *adapter)\r\n{\r\nstruct sge *s = &adapter->sge;\r\nint err, pidx, msix;\r\nbitmap_zero(s->starving_fl, MAX_EGRQ);\r\nif (adapter->flags & USING_MSI) {\r\nerr = t4vf_sge_alloc_rxq(adapter, &s->intrq, false,\r\nadapter->port[0], 0, NULL, NULL);\r\nif (err)\r\ngoto err_free_queues;\r\n}\r\nerr = t4vf_sge_alloc_rxq(adapter, &s->fw_evtq, true, adapter->port[0],\r\nMSIX_FW, NULL, fwevtq_handler);\r\nif (err)\r\ngoto err_free_queues;\r\nmsix = MSIX_IQFLINT;\r\nfor_each_port(adapter, pidx) {\r\nstruct net_device *dev = adapter->port[pidx];\r\nstruct port_info *pi = netdev_priv(dev);\r\nstruct sge_eth_rxq *rxq = &s->ethrxq[pi->first_qset];\r\nstruct sge_eth_txq *txq = &s->ethtxq[pi->first_qset];\r\nint qs;\r\nfor (qs = 0; qs < pi->nqsets; qs++, rxq++, txq++) {\r\nerr = t4vf_sge_alloc_rxq(adapter, &rxq->rspq, false,\r\ndev, msix++,\r\n&rxq->fl, t4vf_ethrx_handler);\r\nif (err)\r\ngoto err_free_queues;\r\nerr = t4vf_sge_alloc_eth_txq(adapter, txq, dev,\r\nnetdev_get_tx_queue(dev, qs),\r\ns->fw_evtq.cntxt_id);\r\nif (err)\r\ngoto err_free_queues;\r\nrxq->rspq.idx = qs;\r\nmemset(&rxq->stats, 0, sizeof(rxq->stats));\r\n}\r\n}\r\ns->egr_base = s->ethtxq[0].q.abs_id - s->ethtxq[0].q.cntxt_id;\r\ns->ingr_base = s->ethrxq[0].rspq.abs_id - s->ethrxq[0].rspq.cntxt_id;\r\nIQ_MAP(s, s->fw_evtq.abs_id) = &s->fw_evtq;\r\nfor_each_port(adapter, pidx) {\r\nstruct net_device *dev = adapter->port[pidx];\r\nstruct port_info *pi = netdev_priv(dev);\r\nstruct sge_eth_rxq *rxq = &s->ethrxq[pi->first_qset];\r\nstruct sge_eth_txq *txq = &s->ethtxq[pi->first_qset];\r\nint qs;\r\nfor (qs = 0; qs < pi->nqsets; qs++, rxq++, txq++) {\r\nIQ_MAP(s, rxq->rspq.abs_id) = &rxq->rspq;\r\nEQ_MAP(s, txq->q.abs_id) = &txq->q;\r\nrxq->fl.abs_id = rxq->fl.cntxt_id + s->egr_base;\r\nEQ_MAP(s, rxq->fl.abs_id) = &rxq->fl;\r\n}\r\n}\r\nreturn 0;\r\nerr_free_queues:\r\nt4vf_free_sge_resources(adapter);\r\nreturn err;\r\n}\r\nstatic int setup_rss(struct adapter *adapter)\r\n{\r\nint pidx;\r\nfor_each_port(adapter, pidx) {\r\nstruct port_info *pi = adap2pinfo(adapter, pidx);\r\nstruct sge_eth_rxq *rxq = &adapter->sge.ethrxq[pi->first_qset];\r\nu16 rss[MAX_PORT_QSETS];\r\nint qs, err;\r\nfor (qs = 0; qs < pi->nqsets; qs++)\r\nrss[qs] = rxq[qs].rspq.abs_id;\r\nerr = t4vf_config_rss_range(adapter, pi->viid,\r\n0, pi->rss_size, rss, pi->nqsets);\r\nif (err)\r\nreturn err;\r\nswitch (adapter->params.rss.mode) {\r\ncase FW_RSS_GLB_CONFIG_CMD_MODE_BASICVIRTUAL:\r\nif (!adapter->params.rss.u.basicvirtual.tnlalllookup) {\r\nunion rss_vi_config config;\r\nerr = t4vf_read_rss_vi_config(adapter,\r\npi->viid,\r\n&config);\r\nif (err)\r\nreturn err;\r\nconfig.basicvirtual.defaultq =\r\nrxq[0].rspq.abs_id;\r\nerr = t4vf_write_rss_vi_config(adapter,\r\npi->viid,\r\n&config);\r\nif (err)\r\nreturn err;\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int adapter_up(struct adapter *adapter)\r\n{\r\nint err;\r\nif ((adapter->flags & FULL_INIT_DONE) == 0) {\r\nerr = setup_sge_queues(adapter);\r\nif (err)\r\nreturn err;\r\nerr = setup_rss(adapter);\r\nif (err) {\r\nt4vf_free_sge_resources(adapter);\r\nreturn err;\r\n}\r\nif (adapter->flags & USING_MSIX)\r\nname_msix_vecs(adapter);\r\nadapter->flags |= FULL_INIT_DONE;\r\n}\r\nBUG_ON((adapter->flags & (USING_MSIX|USING_MSI)) == 0);\r\nif (adapter->flags & USING_MSIX)\r\nerr = request_msix_queue_irqs(adapter);\r\nelse\r\nerr = request_irq(adapter->pdev->irq,\r\nt4vf_intr_handler(adapter), 0,\r\nadapter->name, adapter);\r\nif (err) {\r\ndev_err(adapter->pdev_dev, "request_irq failed, err %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nenable_rx(adapter);\r\nt4vf_sge_start(adapter);\r\nINIT_LIST_HEAD(&adapter->mac_hlist);\r\nreturn 0;\r\n}\r\nstatic void adapter_down(struct adapter *adapter)\r\n{\r\nif (adapter->flags & USING_MSIX)\r\nfree_msix_queue_irqs(adapter);\r\nelse\r\nfree_irq(adapter->pdev->irq, adapter);\r\nquiesce_rx(adapter);\r\n}\r\nstatic int cxgb4vf_open(struct net_device *dev)\r\n{\r\nint err;\r\nstruct port_info *pi = netdev_priv(dev);\r\nstruct adapter *adapter = pi->adapter;\r\nif (adapter->open_device_map == 0) {\r\nerr = adapter_up(adapter);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = link_start(dev);\r\nif (err)\r\ngoto err_unwind;\r\nnetif_tx_start_all_queues(dev);\r\nset_bit(pi->port_id, &adapter->open_device_map);\r\nreturn 0;\r\nerr_unwind:\r\nif (adapter->open_device_map == 0)\r\nadapter_down(adapter);\r\nreturn err;\r\n}\r\nstatic int cxgb4vf_stop(struct net_device *dev)\r\n{\r\nstruct port_info *pi = netdev_priv(dev);\r\nstruct adapter *adapter = pi->adapter;\r\nnetif_tx_stop_all_queues(dev);\r\nnetif_carrier_off(dev);\r\nt4vf_enable_vi(adapter, pi->viid, false, false);\r\npi->link_cfg.link_ok = 0;\r\nclear_bit(pi->port_id, &adapter->open_device_map);\r\nif (adapter->open_device_map == 0)\r\nadapter_down(adapter);\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *cxgb4vf_get_stats(struct net_device *dev)\r\n{\r\nstruct t4vf_port_stats stats;\r\nstruct port_info *pi = netdev2pinfo(dev);\r\nstruct adapter *adapter = pi->adapter;\r\nstruct net_device_stats *ns = &dev->stats;\r\nint err;\r\nspin_lock(&adapter->stats_lock);\r\nerr = t4vf_get_port_stats(adapter, pi->pidx, &stats);\r\nspin_unlock(&adapter->stats_lock);\r\nmemset(ns, 0, sizeof(*ns));\r\nif (err)\r\nreturn ns;\r\nns->tx_bytes = (stats.tx_bcast_bytes + stats.tx_mcast_bytes +\r\nstats.tx_ucast_bytes + stats.tx_offload_bytes);\r\nns->tx_packets = (stats.tx_bcast_frames + stats.tx_mcast_frames +\r\nstats.tx_ucast_frames + stats.tx_offload_frames);\r\nns->rx_bytes = (stats.rx_bcast_bytes + stats.rx_mcast_bytes +\r\nstats.rx_ucast_bytes);\r\nns->rx_packets = (stats.rx_bcast_frames + stats.rx_mcast_frames +\r\nstats.rx_ucast_frames);\r\nns->multicast = stats.rx_mcast_frames;\r\nns->tx_errors = stats.tx_drop_frames;\r\nns->rx_errors = stats.rx_err_frames;\r\nreturn ns;\r\n}\r\nstatic inline int cxgb4vf_set_addr_hash(struct port_info *pi)\r\n{\r\nstruct adapter *adapter = pi->adapter;\r\nu64 vec = 0;\r\nbool ucast = false;\r\nstruct hash_mac_addr *entry;\r\nlist_for_each_entry(entry, &adapter->mac_hlist, list) {\r\nucast |= is_unicast_ether_addr(entry->addr);\r\nvec |= (1ULL << hash_mac_addr(entry->addr));\r\n}\r\nreturn t4vf_set_addr_hash(adapter, pi->viid, ucast, vec, false);\r\n}\r\nstatic int cxgb4vf_mac_sync(struct net_device *netdev, const u8 *mac_addr)\r\n{\r\nstruct port_info *pi = netdev_priv(netdev);\r\nstruct adapter *adapter = pi->adapter;\r\nint ret;\r\nu64 mhash = 0;\r\nu64 uhash = 0;\r\nbool free = false;\r\nbool ucast = is_unicast_ether_addr(mac_addr);\r\nconst u8 *maclist[1] = {mac_addr};\r\nstruct hash_mac_addr *new_entry;\r\nret = t4vf_alloc_mac_filt(adapter, pi->viid, free, 1, maclist,\r\nNULL, ucast ? &uhash : &mhash, false);\r\nif (ret < 0)\r\ngoto out;\r\nif (uhash || mhash) {\r\nnew_entry = kzalloc(sizeof(*new_entry), GFP_ATOMIC);\r\nif (!new_entry)\r\nreturn -ENOMEM;\r\nether_addr_copy(new_entry->addr, mac_addr);\r\nlist_add_tail(&new_entry->list, &adapter->mac_hlist);\r\nret = cxgb4vf_set_addr_hash(pi);\r\n}\r\nout:\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nstatic int cxgb4vf_mac_unsync(struct net_device *netdev, const u8 *mac_addr)\r\n{\r\nstruct port_info *pi = netdev_priv(netdev);\r\nstruct adapter *adapter = pi->adapter;\r\nint ret;\r\nconst u8 *maclist[1] = {mac_addr};\r\nstruct hash_mac_addr *entry, *tmp;\r\nlist_for_each_entry_safe(entry, tmp, &adapter->mac_hlist, list) {\r\nif (ether_addr_equal(entry->addr, mac_addr)) {\r\nlist_del(&entry->list);\r\nkfree(entry);\r\nreturn cxgb4vf_set_addr_hash(pi);\r\n}\r\n}\r\nret = t4vf_free_mac_filt(adapter, pi->viid, 1, maclist, false);\r\nreturn ret < 0 ? -EINVAL : 0;\r\n}\r\nstatic int set_rxmode(struct net_device *dev, int mtu, bool sleep_ok)\r\n{\r\nstruct port_info *pi = netdev_priv(dev);\r\n__dev_uc_sync(dev, cxgb4vf_mac_sync, cxgb4vf_mac_unsync);\r\n__dev_mc_sync(dev, cxgb4vf_mac_sync, cxgb4vf_mac_unsync);\r\nreturn t4vf_set_rxmode(pi->adapter, pi->viid, -1,\r\n(dev->flags & IFF_PROMISC) != 0,\r\n(dev->flags & IFF_ALLMULTI) != 0,\r\n1, -1, sleep_ok);\r\n}\r\nstatic void cxgb4vf_set_rxmode(struct net_device *dev)\r\n{\r\nset_rxmode(dev, -1, false);\r\n}\r\nstatic int closest_timer(const struct sge *s, int us)\r\n{\r\nint i, timer_idx = 0, min_delta = INT_MAX;\r\nfor (i = 0; i < ARRAY_SIZE(s->timer_val); i++) {\r\nint delta = us - s->timer_val[i];\r\nif (delta < 0)\r\ndelta = -delta;\r\nif (delta < min_delta) {\r\nmin_delta = delta;\r\ntimer_idx = i;\r\n}\r\n}\r\nreturn timer_idx;\r\n}\r\nstatic int closest_thres(const struct sge *s, int thres)\r\n{\r\nint i, delta, pktcnt_idx = 0, min_delta = INT_MAX;\r\nfor (i = 0; i < ARRAY_SIZE(s->counter_val); i++) {\r\ndelta = thres - s->counter_val[i];\r\nif (delta < 0)\r\ndelta = -delta;\r\nif (delta < min_delta) {\r\nmin_delta = delta;\r\npktcnt_idx = i;\r\n}\r\n}\r\nreturn pktcnt_idx;\r\n}\r\nstatic unsigned int qtimer_val(const struct adapter *adapter,\r\nconst struct sge_rspq *rspq)\r\n{\r\nunsigned int timer_idx = QINTR_TIMER_IDX_G(rspq->intr_params);\r\nreturn timer_idx < SGE_NTIMERS\r\n? adapter->sge.timer_val[timer_idx]\r\n: 0;\r\n}\r\nstatic int set_rxq_intr_params(struct adapter *adapter, struct sge_rspq *rspq,\r\nunsigned int us, unsigned int cnt)\r\n{\r\nunsigned int timer_idx;\r\nif ((us | cnt) == 0)\r\ncnt = 1;\r\nif (cnt) {\r\nint err;\r\nu32 v, pktcnt_idx;\r\npktcnt_idx = closest_thres(&adapter->sge, cnt);\r\nif (rspq->desc && rspq->pktcnt_idx != pktcnt_idx) {\r\nv = FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DMAQ) |\r\nFW_PARAMS_PARAM_X_V(\r\nFW_PARAMS_PARAM_DMAQ_IQ_INTCNTTHRESH) |\r\nFW_PARAMS_PARAM_YZ_V(rspq->cntxt_id);\r\nerr = t4vf_set_params(adapter, 1, &v, &pktcnt_idx);\r\nif (err)\r\nreturn err;\r\n}\r\nrspq->pktcnt_idx = pktcnt_idx;\r\n}\r\ntimer_idx = (us == 0\r\n? SGE_TIMER_RSTRT_CNTR\r\n: closest_timer(&adapter->sge, us));\r\nrspq->intr_params = (QINTR_TIMER_IDX_V(timer_idx) |\r\nQINTR_CNT_EN_V(cnt > 0));\r\nreturn 0;\r\n}\r\nstatic inline unsigned int mk_adap_vers(const struct adapter *adapter)\r\n{\r\nreturn CHELSIO_CHIP_VERSION(adapter->params.chip) | (0x3f << 10);\r\n}\r\nstatic int cxgb4vf_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nint ret = 0;\r\nswitch (cmd) {\r\ndefault:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cxgb4vf_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nint ret;\r\nstruct port_info *pi = netdev_priv(dev);\r\nret = t4vf_set_rxmode(pi->adapter, pi->viid, new_mtu,\r\n-1, -1, -1, -1, true);\r\nif (!ret)\r\ndev->mtu = new_mtu;\r\nreturn ret;\r\n}\r\nstatic netdev_features_t cxgb4vf_fix_features(struct net_device *dev,\r\nnetdev_features_t features)\r\n{\r\nif (features & NETIF_F_HW_VLAN_CTAG_RX)\r\nfeatures |= NETIF_F_HW_VLAN_CTAG_TX;\r\nelse\r\nfeatures &= ~NETIF_F_HW_VLAN_CTAG_TX;\r\nreturn features;\r\n}\r\nstatic int cxgb4vf_set_features(struct net_device *dev,\r\nnetdev_features_t features)\r\n{\r\nstruct port_info *pi = netdev_priv(dev);\r\nnetdev_features_t changed = dev->features ^ features;\r\nif (changed & NETIF_F_HW_VLAN_CTAG_RX)\r\nt4vf_set_rxmode(pi->adapter, pi->viid, -1, -1, -1, -1,\r\nfeatures & NETIF_F_HW_VLAN_CTAG_TX, 0);\r\nreturn 0;\r\n}\r\nstatic int cxgb4vf_set_mac_addr(struct net_device *dev, void *_addr)\r\n{\r\nint ret;\r\nstruct sockaddr *addr = _addr;\r\nstruct port_info *pi = netdev_priv(dev);\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nret = t4vf_change_mac(pi->adapter, pi->viid, pi->xact_addr_filt,\r\naddr->sa_data, true);\r\nif (ret < 0)\r\nreturn ret;\r\nmemcpy(dev->dev_addr, addr->sa_data, dev->addr_len);\r\npi->xact_addr_filt = ret;\r\nreturn 0;\r\n}\r\nstatic void cxgb4vf_poll_controller(struct net_device *dev)\r\n{\r\nstruct port_info *pi = netdev_priv(dev);\r\nstruct adapter *adapter = pi->adapter;\r\nif (adapter->flags & USING_MSIX) {\r\nstruct sge_eth_rxq *rxq;\r\nint nqsets;\r\nrxq = &adapter->sge.ethrxq[pi->first_qset];\r\nfor (nqsets = pi->nqsets; nqsets; nqsets--) {\r\nt4vf_sge_intr_msix(0, &rxq->rspq);\r\nrxq++;\r\n}\r\n} else\r\nt4vf_intr_handler(adapter)(0, adapter);\r\n}\r\nstatic int from_fw_port_mod_type(enum fw_port_type port_type,\r\nenum fw_port_module_type mod_type)\r\n{\r\nif (port_type == FW_PORT_TYPE_BT_SGMII ||\r\nport_type == FW_PORT_TYPE_BT_XFI ||\r\nport_type == FW_PORT_TYPE_BT_XAUI) {\r\nreturn PORT_TP;\r\n} else if (port_type == FW_PORT_TYPE_FIBER_XFI ||\r\nport_type == FW_PORT_TYPE_FIBER_XAUI) {\r\nreturn PORT_FIBRE;\r\n} else if (port_type == FW_PORT_TYPE_SFP ||\r\nport_type == FW_PORT_TYPE_QSFP_10G ||\r\nport_type == FW_PORT_TYPE_QSA ||\r\nport_type == FW_PORT_TYPE_QSFP) {\r\nif (mod_type == FW_PORT_MOD_TYPE_LR ||\r\nmod_type == FW_PORT_MOD_TYPE_SR ||\r\nmod_type == FW_PORT_MOD_TYPE_ER ||\r\nmod_type == FW_PORT_MOD_TYPE_LRM)\r\nreturn PORT_FIBRE;\r\nelse if (mod_type == FW_PORT_MOD_TYPE_TWINAX_PASSIVE ||\r\nmod_type == FW_PORT_MOD_TYPE_TWINAX_ACTIVE)\r\nreturn PORT_DA;\r\nelse\r\nreturn PORT_OTHER;\r\n}\r\nreturn PORT_OTHER;\r\n}\r\nstatic void fw_caps_to_lmm(enum fw_port_type port_type,\r\nunsigned int fw_caps,\r\nunsigned long *link_mode_mask)\r\n{\r\n#define SET_LMM(__lmm_name) __set_bit(ETHTOOL_LINK_MODE_ ## __lmm_name\\r\n## _BIT, link_mode_mask)\r\n#define FW_CAPS_TO_LMM(__fw_name, __lmm_name) \\r\ndo { \\r\nif (fw_caps & FW_PORT_CAP_ ## __fw_name) \\r\nSET_LMM(__lmm_name); \\r\n} while (0)\r\nswitch (port_type) {\r\ncase FW_PORT_TYPE_BT_SGMII:\r\ncase FW_PORT_TYPE_BT_XFI:\r\ncase FW_PORT_TYPE_BT_XAUI:\r\nSET_LMM(TP);\r\nFW_CAPS_TO_LMM(SPEED_100M, 100baseT_Full);\r\nFW_CAPS_TO_LMM(SPEED_1G, 1000baseT_Full);\r\nFW_CAPS_TO_LMM(SPEED_10G, 10000baseT_Full);\r\nbreak;\r\ncase FW_PORT_TYPE_KX4:\r\ncase FW_PORT_TYPE_KX:\r\nSET_LMM(Backplane);\r\nFW_CAPS_TO_LMM(SPEED_1G, 1000baseKX_Full);\r\nFW_CAPS_TO_LMM(SPEED_10G, 10000baseKX4_Full);\r\nbreak;\r\ncase FW_PORT_TYPE_KR:\r\nSET_LMM(Backplane);\r\nSET_LMM(10000baseKR_Full);\r\nbreak;\r\ncase FW_PORT_TYPE_BP_AP:\r\nSET_LMM(Backplane);\r\nSET_LMM(10000baseR_FEC);\r\nSET_LMM(10000baseKR_Full);\r\nSET_LMM(1000baseKX_Full);\r\nbreak;\r\ncase FW_PORT_TYPE_BP4_AP:\r\nSET_LMM(Backplane);\r\nSET_LMM(10000baseR_FEC);\r\nSET_LMM(10000baseKR_Full);\r\nSET_LMM(1000baseKX_Full);\r\nSET_LMM(10000baseKX4_Full);\r\nbreak;\r\ncase FW_PORT_TYPE_FIBER_XFI:\r\ncase FW_PORT_TYPE_FIBER_XAUI:\r\ncase FW_PORT_TYPE_SFP:\r\ncase FW_PORT_TYPE_QSFP_10G:\r\ncase FW_PORT_TYPE_QSA:\r\nSET_LMM(FIBRE);\r\nFW_CAPS_TO_LMM(SPEED_1G, 1000baseT_Full);\r\nFW_CAPS_TO_LMM(SPEED_10G, 10000baseT_Full);\r\nbreak;\r\ncase FW_PORT_TYPE_BP40_BA:\r\ncase FW_PORT_TYPE_QSFP:\r\nSET_LMM(FIBRE);\r\nSET_LMM(40000baseSR4_Full);\r\nbreak;\r\ncase FW_PORT_TYPE_CR_QSFP:\r\ncase FW_PORT_TYPE_SFP28:\r\nSET_LMM(FIBRE);\r\nSET_LMM(25000baseCR_Full);\r\nbreak;\r\ncase FW_PORT_TYPE_KR4_100G:\r\ncase FW_PORT_TYPE_CR4_QSFP:\r\nSET_LMM(FIBRE);\r\nSET_LMM(100000baseCR4_Full);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nFW_CAPS_TO_LMM(ANEG, Autoneg);\r\nFW_CAPS_TO_LMM(802_3_PAUSE, Pause);\r\nFW_CAPS_TO_LMM(802_3_ASM_DIR, Asym_Pause);\r\n#undef FW_CAPS_TO_LMM\r\n#undef SET_LMM\r\n}\r\nstatic int cxgb4vf_get_link_ksettings(struct net_device *dev,\r\nstruct ethtool_link_ksettings\r\n*link_ksettings)\r\n{\r\nconst struct port_info *pi = netdev_priv(dev);\r\nstruct ethtool_link_settings *base = &link_ksettings->base;\r\nethtool_link_ksettings_zero_link_mode(link_ksettings, supported);\r\nethtool_link_ksettings_zero_link_mode(link_ksettings, advertising);\r\nethtool_link_ksettings_zero_link_mode(link_ksettings, lp_advertising);\r\nbase->port = from_fw_port_mod_type(pi->port_type, pi->mod_type);\r\nif (pi->mdio_addr >= 0) {\r\nbase->phy_address = pi->mdio_addr;\r\nbase->mdio_support = (pi->port_type == FW_PORT_TYPE_BT_SGMII\r\n? ETH_MDIO_SUPPORTS_C22\r\n: ETH_MDIO_SUPPORTS_C45);\r\n} else {\r\nbase->phy_address = 255;\r\nbase->mdio_support = 0;\r\n}\r\nfw_caps_to_lmm(pi->port_type, pi->link_cfg.supported,\r\nlink_ksettings->link_modes.supported);\r\nfw_caps_to_lmm(pi->port_type, pi->link_cfg.advertising,\r\nlink_ksettings->link_modes.advertising);\r\nfw_caps_to_lmm(pi->port_type, pi->link_cfg.lp_advertising,\r\nlink_ksettings->link_modes.lp_advertising);\r\nif (netif_carrier_ok(dev)) {\r\nbase->speed = pi->link_cfg.speed;\r\nbase->duplex = DUPLEX_FULL;\r\n} else {\r\nbase->speed = SPEED_UNKNOWN;\r\nbase->duplex = DUPLEX_UNKNOWN;\r\n}\r\nbase->autoneg = pi->link_cfg.autoneg;\r\nif (pi->link_cfg.supported & FW_PORT_CAP_ANEG)\r\nethtool_link_ksettings_add_link_mode(link_ksettings,\r\nsupported, Autoneg);\r\nif (pi->link_cfg.autoneg)\r\nethtool_link_ksettings_add_link_mode(link_ksettings,\r\nadvertising, Autoneg);\r\nreturn 0;\r\n}\r\nstatic void cxgb4vf_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *drvinfo)\r\n{\r\nstruct adapter *adapter = netdev2adap(dev);\r\nstrlcpy(drvinfo->driver, KBUILD_MODNAME, sizeof(drvinfo->driver));\r\nstrlcpy(drvinfo->version, DRV_VERSION, sizeof(drvinfo->version));\r\nstrlcpy(drvinfo->bus_info, pci_name(to_pci_dev(dev->dev.parent)),\r\nsizeof(drvinfo->bus_info));\r\nsnprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version),\r\n"%u.%u.%u.%u, TP %u.%u.%u.%u",\r\nFW_HDR_FW_VER_MAJOR_G(adapter->params.dev.fwrev),\r\nFW_HDR_FW_VER_MINOR_G(adapter->params.dev.fwrev),\r\nFW_HDR_FW_VER_MICRO_G(adapter->params.dev.fwrev),\r\nFW_HDR_FW_VER_BUILD_G(adapter->params.dev.fwrev),\r\nFW_HDR_FW_VER_MAJOR_G(adapter->params.dev.tprev),\r\nFW_HDR_FW_VER_MINOR_G(adapter->params.dev.tprev),\r\nFW_HDR_FW_VER_MICRO_G(adapter->params.dev.tprev),\r\nFW_HDR_FW_VER_BUILD_G(adapter->params.dev.tprev));\r\n}\r\nstatic u32 cxgb4vf_get_msglevel(struct net_device *dev)\r\n{\r\nreturn netdev2adap(dev)->msg_enable;\r\n}\r\nstatic void cxgb4vf_set_msglevel(struct net_device *dev, u32 msglevel)\r\n{\r\nnetdev2adap(dev)->msg_enable = msglevel;\r\n}\r\nstatic void cxgb4vf_get_ringparam(struct net_device *dev,\r\nstruct ethtool_ringparam *rp)\r\n{\r\nconst struct port_info *pi = netdev_priv(dev);\r\nconst struct sge *s = &pi->adapter->sge;\r\nrp->rx_max_pending = MAX_RX_BUFFERS;\r\nrp->rx_mini_max_pending = MAX_RSPQ_ENTRIES;\r\nrp->rx_jumbo_max_pending = 0;\r\nrp->tx_max_pending = MAX_TXQ_ENTRIES;\r\nrp->rx_pending = s->ethrxq[pi->first_qset].fl.size - MIN_FL_RESID;\r\nrp->rx_mini_pending = s->ethrxq[pi->first_qset].rspq.size;\r\nrp->rx_jumbo_pending = 0;\r\nrp->tx_pending = s->ethtxq[pi->first_qset].q.size;\r\n}\r\nstatic int cxgb4vf_set_ringparam(struct net_device *dev,\r\nstruct ethtool_ringparam *rp)\r\n{\r\nconst struct port_info *pi = netdev_priv(dev);\r\nstruct adapter *adapter = pi->adapter;\r\nstruct sge *s = &adapter->sge;\r\nint qs;\r\nif (rp->rx_pending > MAX_RX_BUFFERS ||\r\nrp->rx_jumbo_pending ||\r\nrp->tx_pending > MAX_TXQ_ENTRIES ||\r\nrp->rx_mini_pending > MAX_RSPQ_ENTRIES ||\r\nrp->rx_mini_pending < MIN_RSPQ_ENTRIES ||\r\nrp->rx_pending < MIN_FL_ENTRIES ||\r\nrp->tx_pending < MIN_TXQ_ENTRIES)\r\nreturn -EINVAL;\r\nif (adapter->flags & FULL_INIT_DONE)\r\nreturn -EBUSY;\r\nfor (qs = pi->first_qset; qs < pi->first_qset + pi->nqsets; qs++) {\r\ns->ethrxq[qs].fl.size = rp->rx_pending + MIN_FL_RESID;\r\ns->ethrxq[qs].rspq.size = rp->rx_mini_pending;\r\ns->ethtxq[qs].q.size = rp->tx_pending;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cxgb4vf_get_coalesce(struct net_device *dev,\r\nstruct ethtool_coalesce *coalesce)\r\n{\r\nconst struct port_info *pi = netdev_priv(dev);\r\nconst struct adapter *adapter = pi->adapter;\r\nconst struct sge_rspq *rspq = &adapter->sge.ethrxq[pi->first_qset].rspq;\r\ncoalesce->rx_coalesce_usecs = qtimer_val(adapter, rspq);\r\ncoalesce->rx_max_coalesced_frames =\r\n((rspq->intr_params & QINTR_CNT_EN_F)\r\n? adapter->sge.counter_val[rspq->pktcnt_idx]\r\n: 0);\r\nreturn 0;\r\n}\r\nstatic int cxgb4vf_set_coalesce(struct net_device *dev,\r\nstruct ethtool_coalesce *coalesce)\r\n{\r\nconst struct port_info *pi = netdev_priv(dev);\r\nstruct adapter *adapter = pi->adapter;\r\nreturn set_rxq_intr_params(adapter,\r\n&adapter->sge.ethrxq[pi->first_qset].rspq,\r\ncoalesce->rx_coalesce_usecs,\r\ncoalesce->rx_max_coalesced_frames);\r\n}\r\nstatic void cxgb4vf_get_pauseparam(struct net_device *dev,\r\nstruct ethtool_pauseparam *pauseparam)\r\n{\r\nstruct port_info *pi = netdev_priv(dev);\r\npauseparam->autoneg = (pi->link_cfg.requested_fc & PAUSE_AUTONEG) != 0;\r\npauseparam->rx_pause = (pi->link_cfg.fc & PAUSE_RX) != 0;\r\npauseparam->tx_pause = (pi->link_cfg.fc & PAUSE_TX) != 0;\r\n}\r\nstatic int cxgb4vf_phys_id(struct net_device *dev,\r\nenum ethtool_phys_id_state state)\r\n{\r\nunsigned int val;\r\nstruct port_info *pi = netdev_priv(dev);\r\nif (state == ETHTOOL_ID_ACTIVE)\r\nval = 0xffff;\r\nelse if (state == ETHTOOL_ID_INACTIVE)\r\nval = 0;\r\nelse\r\nreturn -EINVAL;\r\nreturn t4vf_identify_port(pi->adapter, pi->viid, val);\r\n}\r\nstatic int cxgb4vf_get_sset_count(struct net_device *dev, int sset)\r\n{\r\nswitch (sset) {\r\ncase ETH_SS_STATS:\r\nreturn ARRAY_SIZE(stats_strings);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void cxgb4vf_get_strings(struct net_device *dev,\r\nu32 sset,\r\nu8 *data)\r\n{\r\nswitch (sset) {\r\ncase ETH_SS_STATS:\r\nmemcpy(data, stats_strings, sizeof(stats_strings));\r\nbreak;\r\n}\r\n}\r\nstatic void collect_sge_port_stats(const struct adapter *adapter,\r\nconst struct port_info *pi,\r\nstruct queue_port_stats *stats)\r\n{\r\nconst struct sge_eth_txq *txq = &adapter->sge.ethtxq[pi->first_qset];\r\nconst struct sge_eth_rxq *rxq = &adapter->sge.ethrxq[pi->first_qset];\r\nint qs;\r\nmemset(stats, 0, sizeof(*stats));\r\nfor (qs = 0; qs < pi->nqsets; qs++, rxq++, txq++) {\r\nstats->tso += txq->tso;\r\nstats->tx_csum += txq->tx_cso;\r\nstats->rx_csum += rxq->stats.rx_cso;\r\nstats->vlan_ex += rxq->stats.vlan_ex;\r\nstats->vlan_ins += txq->vlan_ins;\r\nstats->lro_pkts += rxq->stats.lro_pkts;\r\nstats->lro_merged += rxq->stats.lro_merged;\r\n}\r\n}\r\nstatic void cxgb4vf_get_ethtool_stats(struct net_device *dev,\r\nstruct ethtool_stats *stats,\r\nu64 *data)\r\n{\r\nstruct port_info *pi = netdev2pinfo(dev);\r\nstruct adapter *adapter = pi->adapter;\r\nint err = t4vf_get_port_stats(adapter, pi->pidx,\r\n(struct t4vf_port_stats *)data);\r\nif (err)\r\nmemset(data, 0, sizeof(struct t4vf_port_stats));\r\ndata += sizeof(struct t4vf_port_stats) / sizeof(u64);\r\ncollect_sge_port_stats(adapter, pi, (struct queue_port_stats *)data);\r\n}\r\nstatic int cxgb4vf_get_regs_len(struct net_device *dev)\r\n{\r\nreturn T4VF_REGMAP_SIZE;\r\n}\r\nstatic void reg_block_dump(struct adapter *adapter, void *regbuf,\r\nunsigned int start, unsigned int end)\r\n{\r\nu32 *bp = regbuf + start - T4VF_REGMAP_START;\r\nfor ( ; start <= end; start += sizeof(u32)) {\r\nif (start == T4VF_CIM_BASE_ADDR + CIM_VF_EXT_MAILBOX_CTRL)\r\n*bp++ = 0xffff;\r\nelse\r\n*bp++ = t4_read_reg(adapter, start);\r\n}\r\n}\r\nstatic void cxgb4vf_get_regs(struct net_device *dev,\r\nstruct ethtool_regs *regs,\r\nvoid *regbuf)\r\n{\r\nstruct adapter *adapter = netdev2adap(dev);\r\nregs->version = mk_adap_vers(adapter);\r\nmemset(regbuf, 0, T4VF_REGMAP_SIZE);\r\nreg_block_dump(adapter, regbuf,\r\nT4VF_SGE_BASE_ADDR + T4VF_MOD_MAP_SGE_FIRST,\r\nT4VF_SGE_BASE_ADDR + T4VF_MOD_MAP_SGE_LAST);\r\nreg_block_dump(adapter, regbuf,\r\nT4VF_MPS_BASE_ADDR + T4VF_MOD_MAP_MPS_FIRST,\r\nT4VF_MPS_BASE_ADDR + T4VF_MOD_MAP_MPS_LAST);\r\nreg_block_dump(adapter, regbuf,\r\nT4VF_PL_BASE_ADDR + T4VF_MOD_MAP_PL_FIRST,\r\nT4VF_PL_BASE_ADDR + (is_t4(adapter->params.chip)\r\n? PL_VF_WHOAMI_A : PL_VF_REVISION_A));\r\nreg_block_dump(adapter, regbuf,\r\nT4VF_CIM_BASE_ADDR + T4VF_MOD_MAP_CIM_FIRST,\r\nT4VF_CIM_BASE_ADDR + T4VF_MOD_MAP_CIM_LAST);\r\nreg_block_dump(adapter, regbuf,\r\nT4VF_MBDATA_BASE_ADDR + T4VF_MBDATA_FIRST,\r\nT4VF_MBDATA_BASE_ADDR + T4VF_MBDATA_LAST);\r\n}\r\nstatic void cxgb4vf_get_wol(struct net_device *dev,\r\nstruct ethtool_wolinfo *wol)\r\n{\r\nwol->supported = 0;\r\nwol->wolopts = 0;\r\nmemset(&wol->sopass, 0, sizeof(wol->sopass));\r\n}\r\nstatic int mboxlog_show(struct seq_file *seq, void *v)\r\n{\r\nstruct adapter *adapter = seq->private;\r\nstruct mbox_cmd_log *log = adapter->mbox_log;\r\nstruct mbox_cmd *entry;\r\nint entry_idx, i;\r\nif (v == SEQ_START_TOKEN) {\r\nseq_printf(seq,\r\n"%10s %15s %5s %5s %s\n",\r\n"Seq#", "Tstamp", "Atime", "Etime",\r\n"Command/Reply");\r\nreturn 0;\r\n}\r\nentry_idx = log->cursor + ((uintptr_t)v - 2);\r\nif (entry_idx >= log->size)\r\nentry_idx -= log->size;\r\nentry = mbox_cmd_log_entry(log, entry_idx);\r\nif (entry->timestamp == 0)\r\nreturn 0;\r\nseq_printf(seq, "%10u %15llu %5d %5d",\r\nentry->seqno, entry->timestamp,\r\nentry->access, entry->execute);\r\nfor (i = 0; i < MBOX_LEN / 8; i++) {\r\nu64 flit = entry->cmd[i];\r\nu32 hi = (u32)(flit >> 32);\r\nu32 lo = (u32)flit;\r\nseq_printf(seq, " %08x %08x", hi, lo);\r\n}\r\nseq_puts(seq, "\n");\r\nreturn 0;\r\n}\r\nstatic inline void *mboxlog_get_idx(struct seq_file *seq, loff_t pos)\r\n{\r\nstruct adapter *adapter = seq->private;\r\nstruct mbox_cmd_log *log = adapter->mbox_log;\r\nreturn ((pos <= log->size) ? (void *)(uintptr_t)(pos + 1) : NULL);\r\n}\r\nstatic void *mboxlog_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nreturn *pos ? mboxlog_get_idx(seq, *pos) : SEQ_START_TOKEN;\r\n}\r\nstatic void *mboxlog_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\n++*pos;\r\nreturn mboxlog_get_idx(seq, *pos);\r\n}\r\nstatic void mboxlog_stop(struct seq_file *seq, void *v)\r\n{\r\n}\r\nstatic int mboxlog_open(struct inode *inode, struct file *file)\r\n{\r\nint res = seq_open(file, &mboxlog_seq_ops);\r\nif (!res) {\r\nstruct seq_file *seq = file->private_data;\r\nseq->private = inode->i_private;\r\n}\r\nreturn res;\r\n}\r\nstatic int sge_qinfo_show(struct seq_file *seq, void *v)\r\n{\r\nstruct adapter *adapter = seq->private;\r\nint eth_entries = DIV_ROUND_UP(adapter->sge.ethqsets, QPL);\r\nint qs, r = (uintptr_t)v - 1;\r\nif (r)\r\nseq_putc(seq, '\n');\r\n#define S3(fmt_spec, s, v) \\r\ndo {\\r\nseq_printf(seq, "%-12s", s); \\r\nfor (qs = 0; qs < n; ++qs) \\r\nseq_printf(seq, " %16" fmt_spec, v); \\r\nseq_putc(seq, '\n'); \\r\n} while (0)\r\n#define S(s, v) S3("s", s, v)\r\n#define T(s, v) S3("u", s, txq[qs].v)\r\n#define R(s, v) S3("u", s, rxq[qs].v)\r\nif (r < eth_entries) {\r\nconst struct sge_eth_rxq *rxq = &adapter->sge.ethrxq[r * QPL];\r\nconst struct sge_eth_txq *txq = &adapter->sge.ethtxq[r * QPL];\r\nint n = min(QPL, adapter->sge.ethqsets - QPL * r);\r\nS("QType:", "Ethernet");\r\nS("Interface:",\r\n(rxq[qs].rspq.netdev\r\n? rxq[qs].rspq.netdev->name\r\n: "N/A"));\r\nS3("d", "Port:",\r\n(rxq[qs].rspq.netdev\r\n? ((struct port_info *)\r\nnetdev_priv(rxq[qs].rspq.netdev))->port_id\r\n: -1));\r\nT("TxQ ID:", q.abs_id);\r\nT("TxQ size:", q.size);\r\nT("TxQ inuse:", q.in_use);\r\nT("TxQ PIdx:", q.pidx);\r\nT("TxQ CIdx:", q.cidx);\r\nR("RspQ ID:", rspq.abs_id);\r\nR("RspQ size:", rspq.size);\r\nR("RspQE size:", rspq.iqe_len);\r\nS3("u", "Intr delay:", qtimer_val(adapter, &rxq[qs].rspq));\r\nS3("u", "Intr pktcnt:",\r\nadapter->sge.counter_val[rxq[qs].rspq.pktcnt_idx]);\r\nR("RspQ CIdx:", rspq.cidx);\r\nR("RspQ Gen:", rspq.gen);\r\nR("FL ID:", fl.abs_id);\r\nR("FL size:", fl.size - MIN_FL_RESID);\r\nR("FL avail:", fl.avail);\r\nR("FL PIdx:", fl.pidx);\r\nR("FL CIdx:", fl.cidx);\r\nreturn 0;\r\n}\r\nr -= eth_entries;\r\nif (r == 0) {\r\nconst struct sge_rspq *evtq = &adapter->sge.fw_evtq;\r\nseq_printf(seq, "%-12s %16s\n", "QType:", "FW event queue");\r\nseq_printf(seq, "%-12s %16u\n", "RspQ ID:", evtq->abs_id);\r\nseq_printf(seq, "%-12s %16u\n", "Intr delay:",\r\nqtimer_val(adapter, evtq));\r\nseq_printf(seq, "%-12s %16u\n", "Intr pktcnt:",\r\nadapter->sge.counter_val[evtq->pktcnt_idx]);\r\nseq_printf(seq, "%-12s %16u\n", "RspQ Cidx:", evtq->cidx);\r\nseq_printf(seq, "%-12s %16u\n", "RspQ Gen:", evtq->gen);\r\n} else if (r == 1) {\r\nconst struct sge_rspq *intrq = &adapter->sge.intrq;\r\nseq_printf(seq, "%-12s %16s\n", "QType:", "Interrupt Queue");\r\nseq_printf(seq, "%-12s %16u\n", "RspQ ID:", intrq->abs_id);\r\nseq_printf(seq, "%-12s %16u\n", "Intr delay:",\r\nqtimer_val(adapter, intrq));\r\nseq_printf(seq, "%-12s %16u\n", "Intr pktcnt:",\r\nadapter->sge.counter_val[intrq->pktcnt_idx]);\r\nseq_printf(seq, "%-12s %16u\n", "RspQ Cidx:", intrq->cidx);\r\nseq_printf(seq, "%-12s %16u\n", "RspQ Gen:", intrq->gen);\r\n}\r\n#undef R\r\n#undef T\r\n#undef S\r\n#undef S3\r\nreturn 0;\r\n}\r\nstatic int sge_queue_entries(const struct adapter *adapter)\r\n{\r\nreturn DIV_ROUND_UP(adapter->sge.ethqsets, QPL) + 1 +\r\n((adapter->flags & USING_MSI) != 0);\r\n}\r\nstatic void *sge_queue_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nint entries = sge_queue_entries(seq->private);\r\nreturn *pos < entries ? (void *)((uintptr_t)*pos + 1) : NULL;\r\n}\r\nstatic void sge_queue_stop(struct seq_file *seq, void *v)\r\n{\r\n}\r\nstatic void *sge_queue_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nint entries = sge_queue_entries(seq->private);\r\n++*pos;\r\nreturn *pos < entries ? (void *)((uintptr_t)*pos + 1) : NULL;\r\n}\r\nstatic int sge_qinfo_open(struct inode *inode, struct file *file)\r\n{\r\nint res = seq_open(file, &sge_qinfo_seq_ops);\r\nif (!res) {\r\nstruct seq_file *seq = file->private_data;\r\nseq->private = inode->i_private;\r\n}\r\nreturn res;\r\n}\r\nstatic int sge_qstats_show(struct seq_file *seq, void *v)\r\n{\r\nstruct adapter *adapter = seq->private;\r\nint eth_entries = DIV_ROUND_UP(adapter->sge.ethqsets, QPL);\r\nint qs, r = (uintptr_t)v - 1;\r\nif (r)\r\nseq_putc(seq, '\n');\r\n#define S3(fmt, s, v) \\r\ndo { \\r\nseq_printf(seq, "%-16s", s); \\r\nfor (qs = 0; qs < n; ++qs) \\r\nseq_printf(seq, " %8" fmt, v); \\r\nseq_putc(seq, '\n'); \\r\n} while (0)\r\n#define S(s, v) S3("s", s, v)\r\n#define T3(fmt, s, v) S3(fmt, s, txq[qs].v)\r\n#define T(s, v) T3("lu", s, v)\r\n#define R3(fmt, s, v) S3(fmt, s, rxq[qs].v)\r\n#define R(s, v) R3("lu", s, v)\r\nif (r < eth_entries) {\r\nconst struct sge_eth_rxq *rxq = &adapter->sge.ethrxq[r * QPL];\r\nconst struct sge_eth_txq *txq = &adapter->sge.ethtxq[r * QPL];\r\nint n = min(QPL, adapter->sge.ethqsets - QPL * r);\r\nS("QType:", "Ethernet");\r\nS("Interface:",\r\n(rxq[qs].rspq.netdev\r\n? rxq[qs].rspq.netdev->name\r\n: "N/A"));\r\nR3("u", "RspQNullInts:", rspq.unhandled_irqs);\r\nR("RxPackets:", stats.pkts);\r\nR("RxCSO:", stats.rx_cso);\r\nR("VLANxtract:", stats.vlan_ex);\r\nR("LROmerged:", stats.lro_merged);\r\nR("LROpackets:", stats.lro_pkts);\r\nR("RxDrops:", stats.rx_drops);\r\nT("TSO:", tso);\r\nT("TxCSO:", tx_cso);\r\nT("VLANins:", vlan_ins);\r\nT("TxQFull:", q.stops);\r\nT("TxQRestarts:", q.restarts);\r\nT("TxMapErr:", mapping_err);\r\nR("FLAllocErr:", fl.alloc_failed);\r\nR("FLLrgAlcErr:", fl.large_alloc_failed);\r\nR("FLStarving:", fl.starving);\r\nreturn 0;\r\n}\r\nr -= eth_entries;\r\nif (r == 0) {\r\nconst struct sge_rspq *evtq = &adapter->sge.fw_evtq;\r\nseq_printf(seq, "%-8s %16s\n", "QType:", "FW event queue");\r\nseq_printf(seq, "%-16s %8u\n", "RspQNullInts:",\r\nevtq->unhandled_irqs);\r\nseq_printf(seq, "%-16s %8u\n", "RspQ CIdx:", evtq->cidx);\r\nseq_printf(seq, "%-16s %8u\n", "RspQ Gen:", evtq->gen);\r\n} else if (r == 1) {\r\nconst struct sge_rspq *intrq = &adapter->sge.intrq;\r\nseq_printf(seq, "%-8s %16s\n", "QType:", "Interrupt Queue");\r\nseq_printf(seq, "%-16s %8u\n", "RspQNullInts:",\r\nintrq->unhandled_irqs);\r\nseq_printf(seq, "%-16s %8u\n", "RspQ CIdx:", intrq->cidx);\r\nseq_printf(seq, "%-16s %8u\n", "RspQ Gen:", intrq->gen);\r\n}\r\n#undef R\r\n#undef T\r\n#undef S\r\n#undef R3\r\n#undef T3\r\n#undef S3\r\nreturn 0;\r\n}\r\nstatic int sge_qstats_entries(const struct adapter *adapter)\r\n{\r\nreturn DIV_ROUND_UP(adapter->sge.ethqsets, QPL) + 1 +\r\n((adapter->flags & USING_MSI) != 0);\r\n}\r\nstatic void *sge_qstats_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nint entries = sge_qstats_entries(seq->private);\r\nreturn *pos < entries ? (void *)((uintptr_t)*pos + 1) : NULL;\r\n}\r\nstatic void sge_qstats_stop(struct seq_file *seq, void *v)\r\n{\r\n}\r\nstatic void *sge_qstats_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nint entries = sge_qstats_entries(seq->private);\r\n(*pos)++;\r\nreturn *pos < entries ? (void *)((uintptr_t)*pos + 1) : NULL;\r\n}\r\nstatic int sge_qstats_open(struct inode *inode, struct file *file)\r\n{\r\nint res = seq_open(file, &sge_qstats_seq_ops);\r\nif (res == 0) {\r\nstruct seq_file *seq = file->private_data;\r\nseq->private = inode->i_private;\r\n}\r\nreturn res;\r\n}\r\nstatic int resources_show(struct seq_file *seq, void *v)\r\n{\r\nstruct adapter *adapter = seq->private;\r\nstruct vf_resources *vfres = &adapter->params.vfres;\r\n#define S(desc, fmt, var) \\r\nseq_printf(seq, "%-60s " fmt "\n", \\r\ndesc " (" #var "):", vfres->var)\r\nS("Virtual Interfaces", "%d", nvi);\r\nS("Egress Queues", "%d", neq);\r\nS("Ethernet Control", "%d", nethctrl);\r\nS("Ingress Queues/w Free Lists/Interrupts", "%d", niqflint);\r\nS("Ingress Queues", "%d", niq);\r\nS("Traffic Class", "%d", tc);\r\nS("Port Access Rights Mask", "%#x", pmask);\r\nS("MAC Address Filters", "%d", nexactf);\r\nS("Firmware Command Read Capabilities", "%#x", r_caps);\r\nS("Firmware Command Write/Execute Capabilities", "%#x", wx_caps);\r\n#undef S\r\nreturn 0;\r\n}\r\nstatic int resources_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, resources_show, inode->i_private);\r\n}\r\nstatic int interfaces_show(struct seq_file *seq, void *v)\r\n{\r\nif (v == SEQ_START_TOKEN) {\r\nseq_puts(seq, "Interface Port VIID\n");\r\n} else {\r\nstruct adapter *adapter = seq->private;\r\nint pidx = (uintptr_t)v - 2;\r\nstruct net_device *dev = adapter->port[pidx];\r\nstruct port_info *pi = netdev_priv(dev);\r\nseq_printf(seq, "%9s %4d %#5x\n",\r\ndev->name, pi->port_id, pi->viid);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void *interfaces_get_idx(struct adapter *adapter, loff_t pos)\r\n{\r\nreturn pos <= adapter->params.nports\r\n? (void *)(uintptr_t)(pos + 1)\r\n: NULL;\r\n}\r\nstatic void *interfaces_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nreturn *pos\r\n? interfaces_get_idx(seq->private, *pos)\r\n: SEQ_START_TOKEN;\r\n}\r\nstatic void *interfaces_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\n(*pos)++;\r\nreturn interfaces_get_idx(seq->private, *pos);\r\n}\r\nstatic void interfaces_stop(struct seq_file *seq, void *v)\r\n{\r\n}\r\nstatic int interfaces_open(struct inode *inode, struct file *file)\r\n{\r\nint res = seq_open(file, &interfaces_seq_ops);\r\nif (res == 0) {\r\nstruct seq_file *seq = file->private_data;\r\nseq->private = inode->i_private;\r\n}\r\nreturn res;\r\n}\r\nstatic int setup_debugfs(struct adapter *adapter)\r\n{\r\nint i;\r\nBUG_ON(IS_ERR_OR_NULL(adapter->debugfs_root));\r\nfor (i = 0; i < ARRAY_SIZE(debugfs_files); i++)\r\n(void)debugfs_create_file(debugfs_files[i].name,\r\ndebugfs_files[i].mode,\r\nadapter->debugfs_root,\r\n(void *)adapter,\r\ndebugfs_files[i].fops);\r\nreturn 0;\r\n}\r\nstatic void cleanup_debugfs(struct adapter *adapter)\r\n{\r\nBUG_ON(IS_ERR_OR_NULL(adapter->debugfs_root));\r\n}\r\nstatic void size_nports_qsets(struct adapter *adapter)\r\n{\r\nstruct vf_resources *vfres = &adapter->params.vfres;\r\nunsigned int ethqsets, pmask_nports;\r\nadapter->params.nports = vfres->nvi;\r\nif (adapter->params.nports > MAX_NPORTS) {\r\ndev_warn(adapter->pdev_dev, "only using %d of %d maximum"\r\n" allowed virtual interfaces\n", MAX_NPORTS,\r\nadapter->params.nports);\r\nadapter->params.nports = MAX_NPORTS;\r\n}\r\npmask_nports = hweight32(adapter->params.vfres.pmask);\r\nif (pmask_nports < adapter->params.nports) {\r\ndev_warn(adapter->pdev_dev, "only using %d of %d provisioned"\r\n" virtual interfaces; limited by Port Access Rights"\r\n" mask %#x\n", pmask_nports, adapter->params.nports,\r\nadapter->params.vfres.pmask);\r\nadapter->params.nports = pmask_nports;\r\n}\r\nethqsets = vfres->niqflint - 1 - (msi == MSI_MSI);\r\nif (vfres->nethctrl != ethqsets)\r\nethqsets = min(vfres->nethctrl, ethqsets);\r\nif (vfres->neq < ethqsets*2)\r\nethqsets = vfres->neq/2;\r\nif (ethqsets > MAX_ETH_QSETS)\r\nethqsets = MAX_ETH_QSETS;\r\nadapter->sge.max_ethqsets = ethqsets;\r\nif (adapter->sge.max_ethqsets < adapter->params.nports) {\r\ndev_warn(adapter->pdev_dev, "only using %d of %d available"\r\n" virtual interfaces (too few Queue Sets)\n",\r\nadapter->sge.max_ethqsets, adapter->params.nports);\r\nadapter->params.nports = adapter->sge.max_ethqsets;\r\n}\r\n}\r\nstatic int adap_init0(struct adapter *adapter)\r\n{\r\nstruct sge_params *sge_params = &adapter->params.sge;\r\nstruct sge *s = &adapter->sge;\r\nint err;\r\nu32 param, val = 0;\r\nerr = t4vf_fw_reset(adapter);\r\nif (err < 0) {\r\ndev_err(adapter->pdev_dev, "FW reset failed: err=%d\n", err);\r\nreturn err;\r\n}\r\nerr = t4vf_get_dev_params(adapter);\r\nif (err) {\r\ndev_err(adapter->pdev_dev, "unable to retrieve adapter"\r\n" device parameters: err=%d\n", err);\r\nreturn err;\r\n}\r\nerr = t4vf_get_vpd_params(adapter);\r\nif (err) {\r\ndev_err(adapter->pdev_dev, "unable to retrieve adapter"\r\n" VPD parameters: err=%d\n", err);\r\nreturn err;\r\n}\r\nerr = t4vf_get_sge_params(adapter);\r\nif (err) {\r\ndev_err(adapter->pdev_dev, "unable to retrieve adapter"\r\n" SGE parameters: err=%d\n", err);\r\nreturn err;\r\n}\r\nerr = t4vf_get_rss_glb_config(adapter);\r\nif (err) {\r\ndev_err(adapter->pdev_dev, "unable to retrieve adapter"\r\n" RSS parameters: err=%d\n", err);\r\nreturn err;\r\n}\r\nif (adapter->params.rss.mode !=\r\nFW_RSS_GLB_CONFIG_CMD_MODE_BASICVIRTUAL) {\r\ndev_err(adapter->pdev_dev, "unable to operate with global RSS"\r\n" mode %d\n", adapter->params.rss.mode);\r\nreturn -EINVAL;\r\n}\r\nerr = t4vf_sge_init(adapter);\r\nif (err) {\r\ndev_err(adapter->pdev_dev, "unable to use adapter parameters:"\r\n" err=%d\n", err);\r\nreturn err;\r\n}\r\nparam = FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_PFVF) |\r\nFW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_PFVF_CPLFW4MSG_ENCAP);\r\nval = 1;\r\n(void) t4vf_set_params(adapter, 1, &param, &val);\r\ns->timer_val[0] = core_ticks_to_us(adapter,\r\nTIMERVALUE0_G(sge_params->sge_timer_value_0_and_1));\r\ns->timer_val[1] = core_ticks_to_us(adapter,\r\nTIMERVALUE1_G(sge_params->sge_timer_value_0_and_1));\r\ns->timer_val[2] = core_ticks_to_us(adapter,\r\nTIMERVALUE0_G(sge_params->sge_timer_value_2_and_3));\r\ns->timer_val[3] = core_ticks_to_us(adapter,\r\nTIMERVALUE1_G(sge_params->sge_timer_value_2_and_3));\r\ns->timer_val[4] = core_ticks_to_us(adapter,\r\nTIMERVALUE0_G(sge_params->sge_timer_value_4_and_5));\r\ns->timer_val[5] = core_ticks_to_us(adapter,\r\nTIMERVALUE1_G(sge_params->sge_timer_value_4_and_5));\r\ns->counter_val[0] = THRESHOLD_0_G(sge_params->sge_ingress_rx_threshold);\r\ns->counter_val[1] = THRESHOLD_1_G(sge_params->sge_ingress_rx_threshold);\r\ns->counter_val[2] = THRESHOLD_2_G(sge_params->sge_ingress_rx_threshold);\r\ns->counter_val[3] = THRESHOLD_3_G(sge_params->sge_ingress_rx_threshold);\r\nerr = t4vf_get_vfres(adapter);\r\nif (err) {\r\ndev_err(adapter->pdev_dev, "unable to get virtual interface"\r\n" resources: err=%d\n", err);\r\nreturn err;\r\n}\r\nif (adapter->params.vfres.pmask == 0) {\r\ndev_err(adapter->pdev_dev, "no port access configured\n"\r\n"usable!\n");\r\nreturn -EINVAL;\r\n}\r\nif (adapter->params.vfres.nvi == 0) {\r\ndev_err(adapter->pdev_dev, "no virtual interfaces configured/"\r\n"usable!\n");\r\nreturn -EINVAL;\r\n}\r\nsize_nports_qsets(adapter);\r\nreturn 0;\r\n}\r\nstatic inline void init_rspq(struct sge_rspq *rspq, u8 timer_idx,\r\nu8 pkt_cnt_idx, unsigned int size,\r\nunsigned int iqe_size)\r\n{\r\nrspq->intr_params = (QINTR_TIMER_IDX_V(timer_idx) |\r\n(pkt_cnt_idx < SGE_NCOUNTERS ?\r\nQINTR_CNT_EN_F : 0));\r\nrspq->pktcnt_idx = (pkt_cnt_idx < SGE_NCOUNTERS\r\n? pkt_cnt_idx\r\n: 0);\r\nrspq->iqe_len = iqe_size;\r\nrspq->size = size;\r\n}\r\nstatic void cfg_queues(struct adapter *adapter)\r\n{\r\nstruct sge *s = &adapter->sge;\r\nint q10g, n10g, qidx, pidx, qs;\r\nsize_t iqe_size;\r\nBUG_ON((adapter->flags & (USING_MSIX|USING_MSI)) == 0);\r\nn10g = 0;\r\nfor_each_port(adapter, pidx)\r\nn10g += is_x_10g_port(&adap2pinfo(adapter, pidx)->link_cfg);\r\nif (n10g == 0)\r\nq10g = 0;\r\nelse {\r\nint n1g = (adapter->params.nports - n10g);\r\nq10g = (adapter->sge.max_ethqsets - n1g) / n10g;\r\nif (q10g > num_online_cpus())\r\nq10g = num_online_cpus();\r\n}\r\nqidx = 0;\r\nfor_each_port(adapter, pidx) {\r\nstruct port_info *pi = adap2pinfo(adapter, pidx);\r\npi->first_qset = qidx;\r\npi->nqsets = is_x_10g_port(&pi->link_cfg) ? q10g : 1;\r\nqidx += pi->nqsets;\r\n}\r\ns->ethqsets = qidx;\r\niqe_size = 64;\r\nfor (qs = 0; qs < s->max_ethqsets; qs++) {\r\nstruct sge_eth_rxq *rxq = &s->ethrxq[qs];\r\nstruct sge_eth_txq *txq = &s->ethtxq[qs];\r\ninit_rspq(&rxq->rspq, 0, 0, 1024, iqe_size);\r\nrxq->fl.size = 72;\r\ntxq->q.size = 1024;\r\n}\r\ninit_rspq(&s->fw_evtq, SGE_TIMER_RSTRT_CNTR, 0, 512, iqe_size);\r\ninit_rspq(&s->intrq, SGE_TIMER_RSTRT_CNTR, 0, MSIX_ENTRIES + 1,\r\niqe_size);\r\n}\r\nstatic void reduce_ethqs(struct adapter *adapter, int n)\r\n{\r\nint i;\r\nstruct port_info *pi;\r\nBUG_ON(n < adapter->params.nports);\r\nwhile (n < adapter->sge.ethqsets)\r\nfor_each_port(adapter, i) {\r\npi = adap2pinfo(adapter, i);\r\nif (pi->nqsets > 1) {\r\npi->nqsets--;\r\nadapter->sge.ethqsets--;\r\nif (adapter->sge.ethqsets <= n)\r\nbreak;\r\n}\r\n}\r\nn = 0;\r\nfor_each_port(adapter, i) {\r\npi = adap2pinfo(adapter, i);\r\npi->first_qset = n;\r\nn += pi->nqsets;\r\n}\r\n}\r\nstatic int enable_msix(struct adapter *adapter)\r\n{\r\nint i, want, need, nqsets;\r\nstruct msix_entry entries[MSIX_ENTRIES];\r\nstruct sge *s = &adapter->sge;\r\nfor (i = 0; i < MSIX_ENTRIES; ++i)\r\nentries[i].entry = i;\r\nwant = s->max_ethqsets + MSIX_EXTRAS;\r\nneed = adapter->params.nports + MSIX_EXTRAS;\r\nwant = pci_enable_msix_range(adapter->pdev, entries, need, want);\r\nif (want < 0)\r\nreturn want;\r\nnqsets = want - MSIX_EXTRAS;\r\nif (nqsets < s->max_ethqsets) {\r\ndev_warn(adapter->pdev_dev, "only enough MSI-X vectors"\r\n" for %d Queue Sets\n", nqsets);\r\ns->max_ethqsets = nqsets;\r\nif (nqsets < s->ethqsets)\r\nreduce_ethqs(adapter, nqsets);\r\n}\r\nfor (i = 0; i < want; ++i)\r\nadapter->msix_info[i].vec = entries[i].vector;\r\nreturn 0;\r\n}\r\nstatic int cxgb4vf_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nint pci_using_dac;\r\nint err, pidx;\r\nunsigned int pmask;\r\nstruct adapter *adapter;\r\nstruct port_info *pi;\r\nstruct net_device *netdev;\r\nunsigned int pf;\r\npr_info_once("%s - version %s\n", DRV_DESC, DRV_VERSION);\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "cannot enable PCI device\n");\r\nreturn err;\r\n}\r\nerr = pci_request_regions(pdev, KBUILD_MODNAME);\r\nif (err) {\r\ndev_err(&pdev->dev, "cannot obtain PCI resources\n");\r\ngoto err_disable_device;\r\n}\r\nerr = pci_set_dma_mask(pdev, DMA_BIT_MASK(64));\r\nif (err == 0) {\r\nerr = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64));\r\nif (err) {\r\ndev_err(&pdev->dev, "unable to obtain 64-bit DMA for"\r\n" coherent allocations\n");\r\ngoto err_release_regions;\r\n}\r\npci_using_dac = 1;\r\n} else {\r\nerr = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (err != 0) {\r\ndev_err(&pdev->dev, "no usable DMA configuration\n");\r\ngoto err_release_regions;\r\n}\r\npci_using_dac = 0;\r\n}\r\npci_set_master(pdev);\r\nadapter = kzalloc(sizeof(*adapter), GFP_KERNEL);\r\nif (!adapter) {\r\nerr = -ENOMEM;\r\ngoto err_release_regions;\r\n}\r\npci_set_drvdata(pdev, adapter);\r\nadapter->pdev = pdev;\r\nadapter->pdev_dev = &pdev->dev;\r\nadapter->mbox_log = kzalloc(sizeof(*adapter->mbox_log) +\r\n(sizeof(struct mbox_cmd) *\r\nT4VF_OS_LOG_MBOX_CMDS),\r\nGFP_KERNEL);\r\nif (!adapter->mbox_log) {\r\nerr = -ENOMEM;\r\ngoto err_free_adapter;\r\n}\r\nadapter->mbox_log->size = T4VF_OS_LOG_MBOX_CMDS;\r\nspin_lock_init(&adapter->stats_lock);\r\nspin_lock_init(&adapter->mbox_lock);\r\nINIT_LIST_HEAD(&adapter->mlist.list);\r\nadapter->regs = pci_ioremap_bar(pdev, 0);\r\nif (!adapter->regs) {\r\ndev_err(&pdev->dev, "cannot map device registers\n");\r\nerr = -ENOMEM;\r\ngoto err_free_adapter;\r\n}\r\nerr = t4vf_prep_adapter(adapter);\r\nif (err) {\r\ndev_err(adapter->pdev_dev, "device didn't become ready:"\r\n" err=%d\n", err);\r\ngoto err_unmap_bar0;\r\n}\r\nif (!is_t4(adapter->params.chip)) {\r\nadapter->bar2 = ioremap_wc(pci_resource_start(pdev, 2),\r\npci_resource_len(pdev, 2));\r\nif (!adapter->bar2) {\r\ndev_err(adapter->pdev_dev, "cannot map BAR2 doorbells\n");\r\nerr = -ENOMEM;\r\ngoto err_unmap_bar0;\r\n}\r\n}\r\nadapter->name = pci_name(pdev);\r\nadapter->msg_enable = DFLT_MSG_ENABLE;\r\nerr = adap_init0(adapter);\r\nif (err)\r\ngoto err_unmap_bar;\r\npmask = adapter->params.vfres.pmask;\r\npf = t4vf_get_pf_from_vf(adapter);\r\nfor_each_port(adapter, pidx) {\r\nint port_id, viid;\r\nu8 mac[ETH_ALEN];\r\nunsigned int naddr = 1;\r\nif (pmask == 0)\r\nbreak;\r\nport_id = ffs(pmask) - 1;\r\npmask &= ~(1 << port_id);\r\nviid = t4vf_alloc_vi(adapter, port_id);\r\nif (viid < 0) {\r\ndev_err(&pdev->dev, "cannot allocate VI for port %d:"\r\n" err=%d\n", port_id, viid);\r\nerr = viid;\r\ngoto err_free_dev;\r\n}\r\nnetdev = alloc_etherdev_mq(sizeof(struct port_info),\r\nMAX_PORT_QSETS);\r\nif (netdev == NULL) {\r\nt4vf_free_vi(adapter, viid);\r\nerr = -ENOMEM;\r\ngoto err_free_dev;\r\n}\r\nadapter->port[pidx] = netdev;\r\nSET_NETDEV_DEV(netdev, &pdev->dev);\r\npi = netdev_priv(netdev);\r\npi->adapter = adapter;\r\npi->pidx = pidx;\r\npi->port_id = port_id;\r\npi->viid = viid;\r\npi->xact_addr_filt = -1;\r\nnetif_carrier_off(netdev);\r\nnetdev->irq = pdev->irq;\r\nnetdev->hw_features = NETIF_F_SG | TSO_FLAGS |\r\nNETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |\r\nNETIF_F_HW_VLAN_CTAG_RX | NETIF_F_RXCSUM;\r\nnetdev->vlan_features = NETIF_F_SG | TSO_FLAGS |\r\nNETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |\r\nNETIF_F_HIGHDMA;\r\nnetdev->features = netdev->hw_features |\r\nNETIF_F_HW_VLAN_CTAG_TX;\r\nif (pci_using_dac)\r\nnetdev->features |= NETIF_F_HIGHDMA;\r\nnetdev->priv_flags |= IFF_UNICAST_FLT;\r\nnetdev->min_mtu = 81;\r\nnetdev->max_mtu = ETH_MAX_MTU;\r\nnetdev->netdev_ops = &cxgb4vf_netdev_ops;\r\nnetdev->ethtool_ops = &cxgb4vf_ethtool_ops;\r\nnetdev->dev_port = pi->port_id;\r\nerr = t4vf_port_init(adapter, pidx);\r\nif (err) {\r\ndev_err(&pdev->dev, "cannot initialize port %d\n",\r\npidx);\r\ngoto err_free_dev;\r\n}\r\nerr = t4vf_get_vf_mac_acl(adapter, pf, &naddr, mac);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"unable to determine MAC ACL address, "\r\n"continuing anyway.. (status %d)\n", err);\r\n} else if (naddr && adapter->params.vfres.nvi == 1) {\r\nstruct sockaddr addr;\r\nether_addr_copy(addr.sa_data, mac);\r\nerr = cxgb4vf_set_mac_addr(netdev, &addr);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"unable to set MAC address %pM\n",\r\nmac);\r\ngoto err_free_dev;\r\n}\r\ndev_info(&pdev->dev,\r\n"Using assigned MAC ACL: %pM\n", mac);\r\n}\r\n}\r\nif (msi == MSI_MSIX && enable_msix(adapter) == 0)\r\nadapter->flags |= USING_MSIX;\r\nelse {\r\nif (msi == MSI_MSIX) {\r\ndev_info(adapter->pdev_dev,\r\n"Unable to use MSI-X Interrupts; falling "\r\n"back to MSI Interrupts\n");\r\nmsi = MSI_MSI;\r\nsize_nports_qsets(adapter);\r\n}\r\nerr = pci_enable_msi(pdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "Unable to allocate MSI Interrupts;"\r\n" err=%d\n", err);\r\ngoto err_free_dev;\r\n}\r\nadapter->flags |= USING_MSI;\r\n}\r\ncfg_queues(adapter);\r\nfor_each_port(adapter, pidx) {\r\nstruct port_info *pi = netdev_priv(adapter->port[pidx]);\r\nnetdev = adapter->port[pidx];\r\nif (netdev == NULL)\r\ncontinue;\r\nnetif_set_real_num_tx_queues(netdev, pi->nqsets);\r\nnetif_set_real_num_rx_queues(netdev, pi->nqsets);\r\nerr = register_netdev(netdev);\r\nif (err) {\r\ndev_warn(&pdev->dev, "cannot register net device %s,"\r\n" skipping\n", netdev->name);\r\ncontinue;\r\n}\r\nset_bit(pidx, &adapter->registered_device_map);\r\n}\r\nif (adapter->registered_device_map == 0) {\r\ndev_err(&pdev->dev, "could not register any net devices\n");\r\ngoto err_disable_interrupts;\r\n}\r\nif (!IS_ERR_OR_NULL(cxgb4vf_debugfs_root)) {\r\nadapter->debugfs_root =\r\ndebugfs_create_dir(pci_name(pdev),\r\ncxgb4vf_debugfs_root);\r\nif (IS_ERR_OR_NULL(adapter->debugfs_root))\r\ndev_warn(&pdev->dev, "could not create debugfs"\r\n" directory");\r\nelse\r\nsetup_debugfs(adapter);\r\n}\r\nfor_each_port(adapter, pidx) {\r\ndev_info(adapter->pdev_dev, "%s: Chelsio VF NIC PCIe %s\n",\r\nadapter->port[pidx]->name,\r\n(adapter->flags & USING_MSIX) ? "MSI-X" :\r\n(adapter->flags & USING_MSI) ? "MSI" : "");\r\n}\r\nreturn 0;\r\nerr_disable_interrupts:\r\nif (adapter->flags & USING_MSIX) {\r\npci_disable_msix(adapter->pdev);\r\nadapter->flags &= ~USING_MSIX;\r\n} else if (adapter->flags & USING_MSI) {\r\npci_disable_msi(adapter->pdev);\r\nadapter->flags &= ~USING_MSI;\r\n}\r\nerr_free_dev:\r\nfor_each_port(adapter, pidx) {\r\nnetdev = adapter->port[pidx];\r\nif (netdev == NULL)\r\ncontinue;\r\npi = netdev_priv(netdev);\r\nt4vf_free_vi(adapter, pi->viid);\r\nif (test_bit(pidx, &adapter->registered_device_map))\r\nunregister_netdev(netdev);\r\nfree_netdev(netdev);\r\n}\r\nerr_unmap_bar:\r\nif (!is_t4(adapter->params.chip))\r\niounmap(adapter->bar2);\r\nerr_unmap_bar0:\r\niounmap(adapter->regs);\r\nerr_free_adapter:\r\nkfree(adapter->mbox_log);\r\nkfree(adapter);\r\nerr_release_regions:\r\npci_release_regions(pdev);\r\npci_clear_master(pdev);\r\nerr_disable_device:\r\npci_disable_device(pdev);\r\nreturn err;\r\n}\r\nstatic void cxgb4vf_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct adapter *adapter = pci_get_drvdata(pdev);\r\nif (adapter) {\r\nint pidx;\r\nfor_each_port(adapter, pidx)\r\nif (test_bit(pidx, &adapter->registered_device_map))\r\nunregister_netdev(adapter->port[pidx]);\r\nt4vf_sge_stop(adapter);\r\nif (adapter->flags & USING_MSIX) {\r\npci_disable_msix(adapter->pdev);\r\nadapter->flags &= ~USING_MSIX;\r\n} else if (adapter->flags & USING_MSI) {\r\npci_disable_msi(adapter->pdev);\r\nadapter->flags &= ~USING_MSI;\r\n}\r\nif (!IS_ERR_OR_NULL(adapter->debugfs_root)) {\r\ncleanup_debugfs(adapter);\r\ndebugfs_remove_recursive(adapter->debugfs_root);\r\n}\r\nt4vf_free_sge_resources(adapter);\r\nfor_each_port(adapter, pidx) {\r\nstruct net_device *netdev = adapter->port[pidx];\r\nstruct port_info *pi;\r\nif (netdev == NULL)\r\ncontinue;\r\npi = netdev_priv(netdev);\r\nt4vf_free_vi(adapter, pi->viid);\r\nfree_netdev(netdev);\r\n}\r\niounmap(adapter->regs);\r\nif (!is_t4(adapter->params.chip))\r\niounmap(adapter->bar2);\r\nkfree(adapter->mbox_log);\r\nkfree(adapter);\r\n}\r\npci_disable_device(pdev);\r\npci_clear_master(pdev);\r\npci_release_regions(pdev);\r\n}\r\nstatic void cxgb4vf_pci_shutdown(struct pci_dev *pdev)\r\n{\r\nstruct adapter *adapter;\r\nint pidx;\r\nadapter = pci_get_drvdata(pdev);\r\nif (!adapter)\r\nreturn;\r\nfor_each_port(adapter, pidx)\r\nif (test_bit(pidx, &adapter->registered_device_map))\r\nunregister_netdev(adapter->port[pidx]);\r\nt4vf_sge_stop(adapter);\r\nif (adapter->flags & USING_MSIX) {\r\npci_disable_msix(adapter->pdev);\r\nadapter->flags &= ~USING_MSIX;\r\n} else if (adapter->flags & USING_MSI) {\r\npci_disable_msi(adapter->pdev);\r\nadapter->flags &= ~USING_MSI;\r\n}\r\nt4vf_free_sge_resources(adapter);\r\npci_set_drvdata(pdev, NULL);\r\n}\r\nstatic int __init cxgb4vf_module_init(void)\r\n{\r\nint ret;\r\nif (msi != MSI_MSIX && msi != MSI_MSI) {\r\npr_warn("bad module parameter msi=%d; must be %d (MSI-X or MSI) or %d (MSI)\n",\r\nmsi, MSI_MSIX, MSI_MSI);\r\nreturn -EINVAL;\r\n}\r\ncxgb4vf_debugfs_root = debugfs_create_dir(KBUILD_MODNAME, NULL);\r\nif (IS_ERR_OR_NULL(cxgb4vf_debugfs_root))\r\npr_warn("could not create debugfs entry, continuing\n");\r\nret = pci_register_driver(&cxgb4vf_driver);\r\nif (ret < 0 && !IS_ERR_OR_NULL(cxgb4vf_debugfs_root))\r\ndebugfs_remove(cxgb4vf_debugfs_root);\r\nreturn ret;\r\n}\r\nstatic void __exit cxgb4vf_module_exit(void)\r\n{\r\npci_unregister_driver(&cxgb4vf_driver);\r\ndebugfs_remove(cxgb4vf_debugfs_root);\r\n}
