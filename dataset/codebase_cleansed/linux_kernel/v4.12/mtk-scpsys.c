static int scpsys_domain_is_on(struct scp_domain *scpd)\r\n{\r\nstruct scp *scp = scpd->scp;\r\nu32 status = readl(scp->base + SPM_PWR_STATUS) & scpd->data->sta_mask;\r\nu32 status2 = readl(scp->base + SPM_PWR_STATUS_2ND) &\r\nscpd->data->sta_mask;\r\nif (status && status2)\r\nreturn true;\r\nif (!status && !status2)\r\nreturn false;\r\nreturn -EINVAL;\r\n}\r\nstatic int scpsys_power_on(struct generic_pm_domain *genpd)\r\n{\r\nstruct scp_domain *scpd = container_of(genpd, struct scp_domain, genpd);\r\nstruct scp *scp = scpd->scp;\r\nunsigned long timeout;\r\nbool expired;\r\nvoid __iomem *ctl_addr = scp->base + scpd->data->ctl_offs;\r\nu32 sram_pdn_ack = scpd->data->sram_pdn_ack_bits;\r\nu32 val;\r\nint ret;\r\nint i;\r\nif (scpd->supply) {\r\nret = regulator_enable(scpd->supply);\r\nif (ret)\r\nreturn ret;\r\n}\r\nfor (i = 0; i < MAX_CLKS && scpd->clk[i]; i++) {\r\nret = clk_prepare_enable(scpd->clk[i]);\r\nif (ret) {\r\nfor (--i; i >= 0; i--)\r\nclk_disable_unprepare(scpd->clk[i]);\r\ngoto err_clk;\r\n}\r\n}\r\nval = readl(ctl_addr);\r\nval |= PWR_ON_BIT;\r\nwritel(val, ctl_addr);\r\nval |= PWR_ON_2ND_BIT;\r\nwritel(val, ctl_addr);\r\ntimeout = jiffies + HZ;\r\nexpired = false;\r\nwhile (1) {\r\nret = scpsys_domain_is_on(scpd);\r\nif (ret > 0)\r\nbreak;\r\nif (expired) {\r\nret = -ETIMEDOUT;\r\ngoto err_pwr_ack;\r\n}\r\ncpu_relax();\r\nif (time_after(jiffies, timeout))\r\nexpired = true;\r\n}\r\nval &= ~PWR_CLK_DIS_BIT;\r\nwritel(val, ctl_addr);\r\nval &= ~PWR_ISO_BIT;\r\nwritel(val, ctl_addr);\r\nval |= PWR_RST_B_BIT;\r\nwritel(val, ctl_addr);\r\nval &= ~scpd->data->sram_pdn_bits;\r\nwritel(val, ctl_addr);\r\ntimeout = jiffies + HZ;\r\nexpired = false;\r\nwhile (sram_pdn_ack && (readl(ctl_addr) & sram_pdn_ack)) {\r\nif (expired) {\r\nret = -ETIMEDOUT;\r\ngoto err_pwr_ack;\r\n}\r\ncpu_relax();\r\nif (time_after(jiffies, timeout))\r\nexpired = true;\r\n}\r\nif (scpd->data->bus_prot_mask) {\r\nret = mtk_infracfg_clear_bus_protection(scp->infracfg,\r\nscpd->data->bus_prot_mask);\r\nif (ret)\r\ngoto err_pwr_ack;\r\n}\r\nreturn 0;\r\nerr_pwr_ack:\r\nfor (i = MAX_CLKS - 1; i >= 0; i--) {\r\nif (scpd->clk[i])\r\nclk_disable_unprepare(scpd->clk[i]);\r\n}\r\nerr_clk:\r\nif (scpd->supply)\r\nregulator_disable(scpd->supply);\r\ndev_err(scp->dev, "Failed to power on domain %s\n", genpd->name);\r\nreturn ret;\r\n}\r\nstatic int scpsys_power_off(struct generic_pm_domain *genpd)\r\n{\r\nstruct scp_domain *scpd = container_of(genpd, struct scp_domain, genpd);\r\nstruct scp *scp = scpd->scp;\r\nunsigned long timeout;\r\nbool expired;\r\nvoid __iomem *ctl_addr = scp->base + scpd->data->ctl_offs;\r\nu32 pdn_ack = scpd->data->sram_pdn_ack_bits;\r\nu32 val;\r\nint ret;\r\nint i;\r\nif (scpd->data->bus_prot_mask) {\r\nret = mtk_infracfg_set_bus_protection(scp->infracfg,\r\nscpd->data->bus_prot_mask);\r\nif (ret)\r\ngoto out;\r\n}\r\nval = readl(ctl_addr);\r\nval |= scpd->data->sram_pdn_bits;\r\nwritel(val, ctl_addr);\r\ntimeout = jiffies + HZ;\r\nexpired = false;\r\nwhile (pdn_ack && (readl(ctl_addr) & pdn_ack) != pdn_ack) {\r\nif (expired) {\r\nret = -ETIMEDOUT;\r\ngoto out;\r\n}\r\ncpu_relax();\r\nif (time_after(jiffies, timeout))\r\nexpired = true;\r\n}\r\nval |= PWR_ISO_BIT;\r\nwritel(val, ctl_addr);\r\nval &= ~PWR_RST_B_BIT;\r\nwritel(val, ctl_addr);\r\nval |= PWR_CLK_DIS_BIT;\r\nwritel(val, ctl_addr);\r\nval &= ~PWR_ON_BIT;\r\nwritel(val, ctl_addr);\r\nval &= ~PWR_ON_2ND_BIT;\r\nwritel(val, ctl_addr);\r\ntimeout = jiffies + HZ;\r\nexpired = false;\r\nwhile (1) {\r\nret = scpsys_domain_is_on(scpd);\r\nif (ret == 0)\r\nbreak;\r\nif (expired) {\r\nret = -ETIMEDOUT;\r\ngoto out;\r\n}\r\ncpu_relax();\r\nif (time_after(jiffies, timeout))\r\nexpired = true;\r\n}\r\nfor (i = 0; i < MAX_CLKS && scpd->clk[i]; i++)\r\nclk_disable_unprepare(scpd->clk[i]);\r\nif (scpd->supply)\r\nregulator_disable(scpd->supply);\r\nreturn 0;\r\nout:\r\ndev_err(scp->dev, "Failed to power off domain %s\n", genpd->name);\r\nreturn ret;\r\n}\r\nstatic bool scpsys_active_wakeup(struct device *dev)\r\n{\r\nstruct generic_pm_domain *genpd;\r\nstruct scp_domain *scpd;\r\ngenpd = pd_to_genpd(dev->pm_domain);\r\nscpd = container_of(genpd, struct scp_domain, genpd);\r\nreturn scpd->data->active_wakeup;\r\n}\r\nstatic void init_clks(struct platform_device *pdev, struct clk **clk)\r\n{\r\nint i;\r\nfor (i = CLK_NONE + 1; i < CLK_MAX; i++)\r\nclk[i] = devm_clk_get(&pdev->dev, clk_names[i]);\r\n}\r\nstatic struct scp *init_scp(struct platform_device *pdev,\r\nconst struct scp_domain_data *scp_domain_data, int num)\r\n{\r\nstruct genpd_onecell_data *pd_data;\r\nstruct resource *res;\r\nint i, j;\r\nstruct scp *scp;\r\nstruct clk *clk[CLK_MAX];\r\nscp = devm_kzalloc(&pdev->dev, sizeof(*scp), GFP_KERNEL);\r\nif (!scp)\r\nreturn ERR_PTR(-ENOMEM);\r\nscp->dev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nscp->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(scp->base))\r\nreturn ERR_CAST(scp->base);\r\nscp->domains = devm_kzalloc(&pdev->dev,\r\nsizeof(*scp->domains) * num, GFP_KERNEL);\r\nif (!scp->domains)\r\nreturn ERR_PTR(-ENOMEM);\r\npd_data = &scp->pd_data;\r\npd_data->domains = devm_kzalloc(&pdev->dev,\r\nsizeof(*pd_data->domains) * num, GFP_KERNEL);\r\nif (!pd_data->domains)\r\nreturn ERR_PTR(-ENOMEM);\r\nscp->infracfg = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\r\n"infracfg");\r\nif (IS_ERR(scp->infracfg)) {\r\ndev_err(&pdev->dev, "Cannot find infracfg controller: %ld\n",\r\nPTR_ERR(scp->infracfg));\r\nreturn ERR_CAST(scp->infracfg);\r\n}\r\nfor (i = 0; i < num; i++) {\r\nstruct scp_domain *scpd = &scp->domains[i];\r\nconst struct scp_domain_data *data = &scp_domain_data[i];\r\nscpd->supply = devm_regulator_get_optional(&pdev->dev, data->name);\r\nif (IS_ERR(scpd->supply)) {\r\nif (PTR_ERR(scpd->supply) == -ENODEV)\r\nscpd->supply = NULL;\r\nelse\r\nreturn ERR_CAST(scpd->supply);\r\n}\r\n}\r\npd_data->num_domains = num;\r\ninit_clks(pdev, clk);\r\nfor (i = 0; i < num; i++) {\r\nstruct scp_domain *scpd = &scp->domains[i];\r\nstruct generic_pm_domain *genpd = &scpd->genpd;\r\nconst struct scp_domain_data *data = &scp_domain_data[i];\r\npd_data->domains[i] = genpd;\r\nscpd->scp = scp;\r\nscpd->data = data;\r\nfor (j = 0; j < MAX_CLKS && data->clk_id[j]; j++) {\r\nstruct clk *c = clk[data->clk_id[j]];\r\nif (IS_ERR(c)) {\r\ndev_err(&pdev->dev, "%s: clk unavailable\n",\r\ndata->name);\r\nreturn ERR_CAST(c);\r\n}\r\nscpd->clk[j] = c;\r\n}\r\ngenpd->name = data->name;\r\ngenpd->power_off = scpsys_power_off;\r\ngenpd->power_on = scpsys_power_on;\r\ngenpd->dev_ops.active_wakeup = scpsys_active_wakeup;\r\n}\r\nreturn scp;\r\n}\r\nstatic void mtk_register_power_domains(struct platform_device *pdev,\r\nstruct scp *scp, int num)\r\n{\r\nstruct genpd_onecell_data *pd_data;\r\nint i, ret;\r\nfor (i = 0; i < num; i++) {\r\nstruct scp_domain *scpd = &scp->domains[i];\r\nstruct generic_pm_domain *genpd = &scpd->genpd;\r\ngenpd->power_on(genpd);\r\npm_genpd_init(genpd, NULL, false);\r\n}\r\npd_data = &scp->pd_data;\r\nret = of_genpd_add_provider_onecell(pdev->dev.of_node, pd_data);\r\nif (ret)\r\ndev_err(&pdev->dev, "Failed to add OF provider: %d\n", ret);\r\n}\r\nstatic int __init scpsys_probe_mt2701(struct platform_device *pdev)\r\n{\r\nstruct scp *scp;\r\nscp = init_scp(pdev, scp_domain_data_mt2701, NUM_DOMAINS_MT2701);\r\nif (IS_ERR(scp))\r\nreturn PTR_ERR(scp);\r\nmtk_register_power_domains(pdev, scp, NUM_DOMAINS_MT2701);\r\nreturn 0;\r\n}\r\nstatic int __init scpsys_probe_mt8173(struct platform_device *pdev)\r\n{\r\nstruct scp *scp;\r\nstruct genpd_onecell_data *pd_data;\r\nint ret;\r\nscp = init_scp(pdev, scp_domain_data_mt8173, NUM_DOMAINS_MT8173);\r\nif (IS_ERR(scp))\r\nreturn PTR_ERR(scp);\r\nmtk_register_power_domains(pdev, scp, NUM_DOMAINS_MT8173);\r\npd_data = &scp->pd_data;\r\nret = pm_genpd_add_subdomain(pd_data->domains[MT8173_POWER_DOMAIN_MFG_ASYNC],\r\npd_data->domains[MT8173_POWER_DOMAIN_MFG_2D]);\r\nif (ret && IS_ENABLED(CONFIG_PM))\r\ndev_err(&pdev->dev, "Failed to add subdomain: %d\n", ret);\r\nret = pm_genpd_add_subdomain(pd_data->domains[MT8173_POWER_DOMAIN_MFG_2D],\r\npd_data->domains[MT8173_POWER_DOMAIN_MFG]);\r\nif (ret && IS_ENABLED(CONFIG_PM))\r\ndev_err(&pdev->dev, "Failed to add subdomain: %d\n", ret);\r\nreturn 0;\r\n}\r\nstatic int scpsys_probe(struct platform_device *pdev)\r\n{\r\nint (*probe)(struct platform_device *);\r\nconst struct of_device_id *of_id;\r\nof_id = of_match_node(of_scpsys_match_tbl, pdev->dev.of_node);\r\nif (!of_id || !of_id->data)\r\nreturn -EINVAL;\r\nprobe = of_id->data;\r\nreturn probe(pdev);\r\n}
