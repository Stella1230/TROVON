static int configure_channel(struct most_interface *most_iface,\r\nint ch_idx,\r\nstruct most_channel_config *channel_config)\r\n{\r\nstruct hdm_i2c *dev = to_hdm(most_iface);\r\nBUG_ON(ch_idx < 0 || ch_idx >= NUM_CHANNELS);\r\nBUG_ON(dev->is_open[ch_idx]);\r\nif (channel_config->data_type != MOST_CH_CONTROL) {\r\npr_err("bad data type for channel %d\n", ch_idx);\r\nreturn -EPERM;\r\n}\r\nif (channel_config->direction != dev->capabilities[ch_idx].direction) {\r\npr_err("bad direction for channel %d\n", ch_idx);\r\nreturn -EPERM;\r\n}\r\nif ((channel_config->direction == MOST_CH_RX) && (dev->polling_mode)) {\r\nschedule_delayed_work(&dev->rx.dwork,\r\nmsecs_to_jiffies(MSEC_PER_SEC / 4));\r\n}\r\ndev->is_open[ch_idx] = true;\r\nreturn 0;\r\n}\r\nstatic int enqueue(struct most_interface *most_iface,\r\nint ch_idx, struct mbo *mbo)\r\n{\r\nstruct hdm_i2c *dev = to_hdm(most_iface);\r\nint ret;\r\nBUG_ON(ch_idx < 0 || ch_idx >= NUM_CHANNELS);\r\nBUG_ON(!dev->is_open[ch_idx]);\r\nif (ch_idx == CH_RX) {\r\nmutex_lock(&dev->rx.list_mutex);\r\nlist_add_tail(&mbo->list, &dev->rx.list);\r\nmutex_unlock(&dev->rx.list_mutex);\r\nwake_up_interruptible(&dev->rx.waitq);\r\n} else {\r\nret = i2c_master_send(dev->client, mbo->virt_address,\r\nmbo->buffer_length);\r\nif (ret <= 0) {\r\nmbo->processed_length = 0;\r\nmbo->status = MBO_E_INVAL;\r\n} else {\r\nmbo->processed_length = mbo->buffer_length;\r\nmbo->status = MBO_SUCCESS;\r\n}\r\nmbo->complete(mbo);\r\n}\r\nreturn 0;\r\n}\r\nstatic int poison_channel(struct most_interface *most_iface,\r\nint ch_idx)\r\n{\r\nstruct hdm_i2c *dev = to_hdm(most_iface);\r\nstruct mbo *mbo;\r\nBUG_ON(ch_idx < 0 || ch_idx >= NUM_CHANNELS);\r\nBUG_ON(!dev->is_open[ch_idx]);\r\ndev->is_open[ch_idx] = false;\r\nif (ch_idx == CH_RX) {\r\nmutex_lock(&dev->rx.list_mutex);\r\nwhile (!list_empty(&dev->rx.list)) {\r\nmbo = list_first_mbo(&dev->rx.list);\r\nlist_del(&mbo->list);\r\nmutex_unlock(&dev->rx.list_mutex);\r\nmbo->processed_length = 0;\r\nmbo->status = MBO_E_CLOSE;\r\nmbo->complete(mbo);\r\nmutex_lock(&dev->rx.list_mutex);\r\n}\r\nmutex_unlock(&dev->rx.list_mutex);\r\nwake_up_interruptible(&dev->rx.waitq);\r\n}\r\nreturn 0;\r\n}\r\nstatic void request_netinfo(struct most_interface *most_iface,\r\nint ch_idx)\r\n{\r\npr_info("request_netinfo()\n");\r\n}\r\nstatic void do_rx_work(struct hdm_i2c *dev)\r\n{\r\nstruct mbo *mbo;\r\nunsigned char msg[MAX_BUF_SIZE_CONTROL];\r\nint ret, ch_idx = CH_RX;\r\nu16 pml, data_size;\r\nret = i2c_master_recv(dev->client, msg, 2);\r\nif (ret <= 0) {\r\npr_err("Failed to receive PML\n");\r\nreturn;\r\n}\r\npml = (msg[0] << 8) | msg[1];\r\nif (!pml)\r\nreturn;\r\ndata_size = pml + 2;\r\nret = i2c_master_recv(dev->client, msg, data_size);\r\nif (ret <= 0) {\r\npr_err("Failed to receive a Port Message\n");\r\nreturn;\r\n}\r\nfor (;;) {\r\nif (wait_event_interruptible(dev->rx.waitq,\r\n!dev->is_open[ch_idx] ||\r\n!list_empty(&dev->rx.list))) {\r\npr_err("wait_event_interruptible() failed\n");\r\nreturn;\r\n}\r\nif (!dev->is_open[ch_idx])\r\nreturn;\r\nmutex_lock(&dev->rx.list_mutex);\r\nif (!list_empty(&dev->rx.list))\r\nbreak;\r\nmutex_unlock(&dev->rx.list_mutex);\r\n}\r\nmbo = list_first_mbo(&dev->rx.list);\r\nlist_del(&mbo->list);\r\nmutex_unlock(&dev->rx.list_mutex);\r\nmbo->processed_length = min(data_size, mbo->buffer_length);\r\nmemcpy(mbo->virt_address, msg, mbo->processed_length);\r\nmbo->status = MBO_SUCCESS;\r\nmbo->complete(mbo);\r\n}\r\nstatic void pending_rx_work(struct work_struct *work)\r\n{\r\nstruct hdm_i2c *dev = container_of(work, struct hdm_i2c, rx.dwork.work);\r\ndo_rx_work(dev);\r\nif (dev->polling_mode) {\r\nif (dev->is_open[CH_RX])\r\nschedule_delayed_work(&dev->rx.dwork,\r\nmsecs_to_jiffies(MSEC_PER_SEC\r\n/ scan_rate));\r\n} else {\r\nenable_irq(dev->client->irq);\r\n}\r\n}\r\nstatic irqreturn_t most_irq_handler(int irq, void *_dev)\r\n{\r\nstruct hdm_i2c *dev = _dev;\r\ndisable_irq_nosync(irq);\r\nschedule_delayed_work(&dev->rx.dwork, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nstruct hdm_i2c *dev;\r\nint ret, i;\r\nstruct kobject *kobj;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nsnprintf(dev->name, sizeof(dev->name), "i2c-%d-%04x",\r\nclient->adapter->nr, client->addr);\r\nfor (i = 0; i < NUM_CHANNELS; i++) {\r\ndev->is_open[i] = false;\r\ndev->capabilities[i].data_type = MOST_CH_CONTROL;\r\ndev->capabilities[i].num_buffers_packet = MAX_BUFFERS_CONTROL;\r\ndev->capabilities[i].buffer_size_packet = MAX_BUF_SIZE_CONTROL;\r\n}\r\ndev->capabilities[CH_RX].direction = MOST_CH_RX;\r\ndev->capabilities[CH_RX].name_suffix = "rx";\r\ndev->capabilities[CH_TX].direction = MOST_CH_TX;\r\ndev->capabilities[CH_TX].name_suffix = "tx";\r\ndev->most_iface.interface = ITYPE_I2C;\r\ndev->most_iface.description = dev->name;\r\ndev->most_iface.num_channels = NUM_CHANNELS;\r\ndev->most_iface.channel_vector = dev->capabilities;\r\ndev->most_iface.configure = configure_channel;\r\ndev->most_iface.enqueue = enqueue;\r\ndev->most_iface.poison_channel = poison_channel;\r\ndev->most_iface.request_netinfo = request_netinfo;\r\nINIT_LIST_HEAD(&dev->rx.list);\r\nmutex_init(&dev->rx.list_mutex);\r\ninit_waitqueue_head(&dev->rx.waitq);\r\nINIT_DELAYED_WORK(&dev->rx.dwork, pending_rx_work);\r\ndev->client = client;\r\ni2c_set_clientdata(client, dev);\r\nkobj = most_register_interface(&dev->most_iface);\r\nif (IS_ERR(kobj)) {\r\npr_err("Failed to register i2c as a MOST interface\n");\r\nkfree(dev);\r\nreturn PTR_ERR(kobj);\r\n}\r\ndev->polling_mode = polling_req || client->irq <= 0;\r\nif (!dev->polling_mode) {\r\npr_info("Requesting IRQ: %d\n", client->irq);\r\nret = request_irq(client->irq, most_irq_handler, 0,\r\nclient->name, dev);\r\nif (ret) {\r\npr_info("IRQ request failed: %d, falling back to polling\n",\r\nret);\r\ndev->polling_mode = true;\r\n}\r\n}\r\nif (dev->polling_mode)\r\npr_info("Using polling at rate: %d times/sec\n", scan_rate);\r\nreturn 0;\r\n}\r\nstatic int i2c_remove(struct i2c_client *client)\r\n{\r\nstruct hdm_i2c *dev = i2c_get_clientdata(client);\r\nint i;\r\nif (!dev->polling_mode)\r\nfree_irq(client->irq, dev);\r\nmost_deregister_interface(&dev->most_iface);\r\nfor (i = 0 ; i < NUM_CHANNELS; i++)\r\nif (dev->is_open[i])\r\npoison_channel(&dev->most_iface, i);\r\ncancel_delayed_work_sync(&dev->rx.dwork);\r\nkfree(dev);\r\nreturn 0;\r\n}
