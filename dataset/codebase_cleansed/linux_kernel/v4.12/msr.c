static ssize_t msr_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nu32 __user *tmp = (u32 __user *) buf;\r\nu32 data[2];\r\nu32 reg = *ppos;\r\nint cpu = iminor(file_inode(file));\r\nint err = 0;\r\nssize_t bytes = 0;\r\nif (count % 8)\r\nreturn -EINVAL;\r\nfor (; count; count -= 8) {\r\nerr = rdmsr_safe_on_cpu(cpu, reg, &data[0], &data[1]);\r\nif (err)\r\nbreak;\r\nif (copy_to_user(tmp, &data, 8)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\ntmp += 2;\r\nbytes += 8;\r\n}\r\nreturn bytes ? bytes : err;\r\n}\r\nstatic ssize_t msr_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nconst u32 __user *tmp = (const u32 __user *)buf;\r\nu32 data[2];\r\nu32 reg = *ppos;\r\nint cpu = iminor(file_inode(file));\r\nint err = 0;\r\nssize_t bytes = 0;\r\nif (count % 8)\r\nreturn -EINVAL;\r\nfor (; count; count -= 8) {\r\nif (copy_from_user(&data, tmp, 8)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nerr = wrmsr_safe_on_cpu(cpu, reg, data[0], data[1]);\r\nif (err)\r\nbreak;\r\ntmp += 2;\r\nbytes += 8;\r\n}\r\nreturn bytes ? bytes : err;\r\n}\r\nstatic long msr_ioctl(struct file *file, unsigned int ioc, unsigned long arg)\r\n{\r\nu32 __user *uregs = (u32 __user *)arg;\r\nu32 regs[8];\r\nint cpu = iminor(file_inode(file));\r\nint err;\r\nswitch (ioc) {\r\ncase X86_IOC_RDMSR_REGS:\r\nif (!(file->f_mode & FMODE_READ)) {\r\nerr = -EBADF;\r\nbreak;\r\n}\r\nif (copy_from_user(&regs, uregs, sizeof regs)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nerr = rdmsr_safe_regs_on_cpu(cpu, regs);\r\nif (err)\r\nbreak;\r\nif (copy_to_user(uregs, &regs, sizeof regs))\r\nerr = -EFAULT;\r\nbreak;\r\ncase X86_IOC_WRMSR_REGS:\r\nif (!(file->f_mode & FMODE_WRITE)) {\r\nerr = -EBADF;\r\nbreak;\r\n}\r\nif (copy_from_user(&regs, uregs, sizeof regs)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nerr = wrmsr_safe_regs_on_cpu(cpu, regs);\r\nif (err)\r\nbreak;\r\nif (copy_to_user(uregs, &regs, sizeof regs))\r\nerr = -EFAULT;\r\nbreak;\r\ndefault:\r\nerr = -ENOTTY;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int msr_open(struct inode *inode, struct file *file)\r\n{\r\nunsigned int cpu = iminor(file_inode(file));\r\nstruct cpuinfo_x86 *c;\r\nif (!capable(CAP_SYS_RAWIO))\r\nreturn -EPERM;\r\nif (cpu >= nr_cpu_ids || !cpu_online(cpu))\r\nreturn -ENXIO;\r\nc = &cpu_data(cpu);\r\nif (!cpu_has(c, X86_FEATURE_MSR))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int msr_device_create(unsigned int cpu)\r\n{\r\nstruct device *dev;\r\ndev = device_create(msr_class, NULL, MKDEV(MSR_MAJOR, cpu), NULL,\r\n"msr%d", cpu);\r\nreturn PTR_ERR_OR_ZERO(dev);\r\n}\r\nstatic int msr_device_destroy(unsigned int cpu)\r\n{\r\ndevice_destroy(msr_class, MKDEV(MSR_MAJOR, cpu));\r\nreturn 0;\r\n}\r\nstatic char *msr_devnode(struct device *dev, umode_t *mode)\r\n{\r\nreturn kasprintf(GFP_KERNEL, "cpu/%u/msr", MINOR(dev->devt));\r\n}\r\nstatic int __init msr_init(void)\r\n{\r\nint err;\r\nif (__register_chrdev(MSR_MAJOR, 0, NR_CPUS, "cpu/msr", &msr_fops)) {\r\npr_err("unable to get major %d for msr\n", MSR_MAJOR);\r\nreturn -EBUSY;\r\n}\r\nmsr_class = class_create(THIS_MODULE, "msr");\r\nif (IS_ERR(msr_class)) {\r\nerr = PTR_ERR(msr_class);\r\ngoto out_chrdev;\r\n}\r\nmsr_class->devnode = msr_devnode;\r\nerr = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, "x86/msr:online",\r\nmsr_device_create, msr_device_destroy);\r\nif (err < 0)\r\ngoto out_class;\r\ncpuhp_msr_state = err;\r\nreturn 0;\r\nout_class:\r\nclass_destroy(msr_class);\r\nout_chrdev:\r\n__unregister_chrdev(MSR_MAJOR, 0, NR_CPUS, "cpu/msr");\r\nreturn err;\r\n}\r\nstatic void __exit msr_exit(void)\r\n{\r\ncpuhp_remove_state(cpuhp_msr_state);\r\nclass_destroy(msr_class);\r\n__unregister_chrdev(MSR_MAJOR, 0, NR_CPUS, "cpu/msr");\r\n}
