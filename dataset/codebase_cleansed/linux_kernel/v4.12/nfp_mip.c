static int\r\nnfp_mip_try_read(struct nfp_cpp *cpp, u32 cpp_id, u64 addr, struct nfp_mip *mip)\r\n{\r\nint ret;\r\nret = nfp_cpp_read(cpp, cpp_id, addr, mip, sizeof(*mip));\r\nif (ret != sizeof(*mip)) {\r\nnfp_err(cpp, "Failed to read MIP data (%d, %zu)\n",\r\nret, sizeof(*mip));\r\nreturn -EIO;\r\n}\r\nif (mip->signature != NFP_MIP_SIGNATURE) {\r\nnfp_warn(cpp, "Incorrect MIP signature (0x%08x)\n",\r\nle32_to_cpu(mip->signature));\r\nreturn -EINVAL;\r\n}\r\nif (mip->mip_version != NFP_MIP_VERSION) {\r\nnfp_warn(cpp, "Unsupported MIP version (%d)\n",\r\nle32_to_cpu(mip->mip_version));\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nfp_mip_read_resource(struct nfp_cpp *cpp, struct nfp_mip *mip)\r\n{\r\nstruct nfp_nffw_info *nffw_info;\r\nu32 cpp_id;\r\nu64 addr;\r\nint err;\r\nnffw_info = nfp_nffw_info_open(cpp);\r\nif (IS_ERR(nffw_info))\r\nreturn PTR_ERR(nffw_info);\r\nerr = nfp_nffw_info_mip_first(nffw_info, &cpp_id, &addr);\r\nif (err)\r\ngoto exit_close_nffw;\r\nerr = nfp_mip_try_read(cpp, cpp_id, addr, mip);\r\nexit_close_nffw:\r\nnfp_nffw_info_close(nffw_info);\r\nreturn err;\r\n}\r\nconst struct nfp_mip *nfp_mip_open(struct nfp_cpp *cpp)\r\n{\r\nstruct nfp_mip *mip;\r\nint err;\r\nmip = kmalloc(sizeof(*mip), GFP_KERNEL);\r\nif (!mip)\r\nreturn NULL;\r\nerr = nfp_mip_read_resource(cpp, mip);\r\nif (err) {\r\nkfree(mip);\r\nreturn NULL;\r\n}\r\nreturn mip;\r\n}\r\nvoid nfp_mip_close(const struct nfp_mip *mip)\r\n{\r\nkfree(mip);\r\n}\r\nvoid nfp_mip_symtab(const struct nfp_mip *mip, u32 *addr, u32 *size)\r\n{\r\n*addr = le32_to_cpu(mip->symtab_addr);\r\n*size = le32_to_cpu(mip->symtab_size);\r\n}\r\nvoid nfp_mip_strtab(const struct nfp_mip *mip, u32 *addr, u32 *size)\r\n{\r\n*addr = le32_to_cpu(mip->strtab_addr);\r\n*size = le32_to_cpu(mip->strtab_size);\r\n}
