static inline void stm32f4_i2c_set_bits(void __iomem *reg, u32 mask)\r\n{\r\nwritel_relaxed(readl_relaxed(reg) | mask, reg);\r\n}\r\nstatic inline void stm32f4_i2c_clr_bits(void __iomem *reg, u32 mask)\r\n{\r\nwritel_relaxed(readl_relaxed(reg) & ~mask, reg);\r\n}\r\nstatic void stm32f4_i2c_disable_irq(struct stm32f4_i2c_dev *i2c_dev)\r\n{\r\nvoid __iomem *reg = i2c_dev->base + STM32F4_I2C_CR2;\r\nstm32f4_i2c_clr_bits(reg, STM32F4_I2C_CR2_IRQ_MASK);\r\n}\r\nstatic int stm32f4_i2c_set_periph_clk_freq(struct stm32f4_i2c_dev *i2c_dev)\r\n{\r\nu32 freq;\r\nu32 cr2 = 0;\r\ni2c_dev->parent_rate = clk_get_rate(i2c_dev->clk);\r\nfreq = DIV_ROUND_UP(i2c_dev->parent_rate, HZ_TO_MHZ);\r\nif (i2c_dev->speed == STM32F4_I2C_SPEED_STANDARD) {\r\nif (freq < STM32F4_I2C_MIN_STANDARD_FREQ ||\r\nfreq > STM32F4_I2C_MAX_FREQ) {\r\ndev_err(i2c_dev->dev,\r\n"bad parent clk freq for standard mode\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nif (freq < STM32F4_I2C_MIN_FAST_FREQ ||\r\nfreq > STM32F4_I2C_MAX_FREQ) {\r\ndev_err(i2c_dev->dev,\r\n"bad parent clk freq for fast mode\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\ncr2 |= STM32F4_I2C_CR2_FREQ(freq);\r\nwritel_relaxed(cr2, i2c_dev->base + STM32F4_I2C_CR2);\r\nreturn 0;\r\n}\r\nstatic void stm32f4_i2c_set_rise_time(struct stm32f4_i2c_dev *i2c_dev)\r\n{\r\nu32 freq = DIV_ROUND_UP(i2c_dev->parent_rate, HZ_TO_MHZ);\r\nu32 trise;\r\nif (i2c_dev->speed == STM32F4_I2C_SPEED_STANDARD)\r\ntrise = freq + 1;\r\nelse\r\ntrise = freq * 3 / 10 + 1;\r\nwritel_relaxed(STM32F4_I2C_TRISE_VALUE(trise),\r\ni2c_dev->base + STM32F4_I2C_TRISE);\r\n}\r\nstatic void stm32f4_i2c_set_speed_mode(struct stm32f4_i2c_dev *i2c_dev)\r\n{\r\nu32 val;\r\nu32 ccr = 0;\r\nif (i2c_dev->speed == STM32F4_I2C_SPEED_STANDARD) {\r\nval = i2c_dev->parent_rate / (100000 << 1);\r\n} else {\r\nval = DIV_ROUND_UP(i2c_dev->parent_rate, 400000 * 3);\r\nccr |= STM32F4_I2C_CCR_FS;\r\n}\r\nccr |= STM32F4_I2C_CCR_CCR(val);\r\nwritel_relaxed(ccr, i2c_dev->base + STM32F4_I2C_CCR);\r\n}\r\nstatic int stm32f4_i2c_hw_config(struct stm32f4_i2c_dev *i2c_dev)\r\n{\r\nint ret;\r\nret = stm32f4_i2c_set_periph_clk_freq(i2c_dev);\r\nif (ret)\r\nreturn ret;\r\nstm32f4_i2c_set_rise_time(i2c_dev);\r\nstm32f4_i2c_set_speed_mode(i2c_dev);\r\nwritel_relaxed(STM32F4_I2C_CR1_PE, i2c_dev->base + STM32F4_I2C_CR1);\r\nreturn 0;\r\n}\r\nstatic int stm32f4_i2c_wait_free_bus(struct stm32f4_i2c_dev *i2c_dev)\r\n{\r\nu32 status;\r\nint ret;\r\nret = readl_relaxed_poll_timeout(i2c_dev->base + STM32F4_I2C_SR2,\r\nstatus,\r\n!(status & STM32F4_I2C_SR2_BUSY),\r\n10, 1000);\r\nif (ret) {\r\ndev_dbg(i2c_dev->dev, "bus not free\n");\r\nret = -EBUSY;\r\n}\r\nreturn ret;\r\n}\r\nstatic void stm32f4_i2c_write_byte(struct stm32f4_i2c_dev *i2c_dev, u8 byte)\r\n{\r\nwritel_relaxed(byte, i2c_dev->base + STM32F4_I2C_DR);\r\n}\r\nstatic void stm32f4_i2c_write_msg(struct stm32f4_i2c_dev *i2c_dev)\r\n{\r\nstruct stm32f4_i2c_msg *msg = &i2c_dev->msg;\r\nstm32f4_i2c_write_byte(i2c_dev, *msg->buf++);\r\nmsg->count--;\r\n}\r\nstatic void stm32f4_i2c_read_msg(struct stm32f4_i2c_dev *i2c_dev)\r\n{\r\nstruct stm32f4_i2c_msg *msg = &i2c_dev->msg;\r\nu32 rbuf;\r\nrbuf = readl_relaxed(i2c_dev->base + STM32F4_I2C_DR);\r\n*msg->buf++ = rbuf;\r\nmsg->count--;\r\n}\r\nstatic void stm32f4_i2c_terminate_xfer(struct stm32f4_i2c_dev *i2c_dev)\r\n{\r\nstruct stm32f4_i2c_msg *msg = &i2c_dev->msg;\r\nvoid __iomem *reg = i2c_dev->base + STM32F4_I2C_CR2;\r\nstm32f4_i2c_disable_irq(i2c_dev);\r\nreg = i2c_dev->base + STM32F4_I2C_CR1;\r\nif (msg->stop)\r\nstm32f4_i2c_set_bits(reg, STM32F4_I2C_CR1_STOP);\r\nelse\r\nstm32f4_i2c_set_bits(reg, STM32F4_I2C_CR1_START);\r\ncomplete(&i2c_dev->complete);\r\n}\r\nstatic void stm32f4_i2c_handle_write(struct stm32f4_i2c_dev *i2c_dev)\r\n{\r\nstruct stm32f4_i2c_msg *msg = &i2c_dev->msg;\r\nvoid __iomem *reg = i2c_dev->base + STM32F4_I2C_CR2;\r\nif (msg->count) {\r\nstm32f4_i2c_write_msg(i2c_dev);\r\nif (!msg->count) {\r\nstm32f4_i2c_clr_bits(reg, STM32F4_I2C_CR2_ITBUFEN);\r\n}\r\n} else {\r\nstm32f4_i2c_terminate_xfer(i2c_dev);\r\n}\r\n}\r\nstatic void stm32f4_i2c_handle_read(struct stm32f4_i2c_dev *i2c_dev)\r\n{\r\nstruct stm32f4_i2c_msg *msg = &i2c_dev->msg;\r\nvoid __iomem *reg = i2c_dev->base + STM32F4_I2C_CR2;\r\nswitch (msg->count) {\r\ncase 1:\r\nstm32f4_i2c_disable_irq(i2c_dev);\r\nstm32f4_i2c_read_msg(i2c_dev);\r\ncomplete(&i2c_dev->complete);\r\nbreak;\r\ncase 2:\r\ncase 3:\r\nstm32f4_i2c_clr_bits(reg, STM32F4_I2C_CR2_ITBUFEN);\r\nbreak;\r\ndefault:\r\nstm32f4_i2c_read_msg(i2c_dev);\r\n}\r\n}\r\nstatic void stm32f4_i2c_handle_rx_done(struct stm32f4_i2c_dev *i2c_dev)\r\n{\r\nstruct stm32f4_i2c_msg *msg = &i2c_dev->msg;\r\nvoid __iomem *reg;\r\nu32 mask;\r\nint i;\r\nswitch (msg->count) {\r\ncase 2:\r\nreg = i2c_dev->base + STM32F4_I2C_CR1;\r\nif (msg->stop)\r\nstm32f4_i2c_set_bits(reg, STM32F4_I2C_CR1_STOP);\r\nelse\r\nstm32f4_i2c_set_bits(reg, STM32F4_I2C_CR1_START);\r\nfor (i = 2; i > 0; i--)\r\nstm32f4_i2c_read_msg(i2c_dev);\r\nreg = i2c_dev->base + STM32F4_I2C_CR2;\r\nmask = STM32F4_I2C_CR2_ITEVTEN | STM32F4_I2C_CR2_ITERREN;\r\nstm32f4_i2c_clr_bits(reg, mask);\r\ncomplete(&i2c_dev->complete);\r\nbreak;\r\ncase 3:\r\nreg = i2c_dev->base + STM32F4_I2C_CR1;\r\nstm32f4_i2c_clr_bits(reg, STM32F4_I2C_CR1_ACK);\r\nstm32f4_i2c_read_msg(i2c_dev);\r\nbreak;\r\ndefault:\r\nstm32f4_i2c_read_msg(i2c_dev);\r\n}\r\n}\r\nstatic void stm32f4_i2c_handle_rx_addr(struct stm32f4_i2c_dev *i2c_dev)\r\n{\r\nstruct stm32f4_i2c_msg *msg = &i2c_dev->msg;\r\nu32 cr1;\r\nswitch (msg->count) {\r\ncase 0:\r\nstm32f4_i2c_terminate_xfer(i2c_dev);\r\nreadl_relaxed(i2c_dev->base + STM32F4_I2C_SR2);\r\nbreak;\r\ncase 1:\r\ncr1 = readl_relaxed(i2c_dev->base + STM32F4_I2C_CR1);\r\ncr1 &= ~(STM32F4_I2C_CR1_ACK | STM32F4_I2C_CR1_POS);\r\nwritel_relaxed(cr1, i2c_dev->base + STM32F4_I2C_CR1);\r\nreadl_relaxed(i2c_dev->base + STM32F4_I2C_SR2);\r\nif (msg->stop)\r\ncr1 |= STM32F4_I2C_CR1_STOP;\r\nelse\r\ncr1 |= STM32F4_I2C_CR1_START;\r\nwritel_relaxed(cr1, i2c_dev->base + STM32F4_I2C_CR1);\r\nbreak;\r\ncase 2:\r\ncr1 = readl_relaxed(i2c_dev->base + STM32F4_I2C_CR1);\r\ncr1 &= ~STM32F4_I2C_CR1_ACK;\r\ncr1 |= STM32F4_I2C_CR1_POS;\r\nwritel_relaxed(cr1, i2c_dev->base + STM32F4_I2C_CR1);\r\nreadl_relaxed(i2c_dev->base + STM32F4_I2C_SR2);\r\nbreak;\r\ndefault:\r\ncr1 = readl_relaxed(i2c_dev->base + STM32F4_I2C_CR1);\r\ncr1 |= STM32F4_I2C_CR1_ACK;\r\ncr1 &= ~STM32F4_I2C_CR1_POS;\r\nwritel_relaxed(cr1, i2c_dev->base + STM32F4_I2C_CR1);\r\nreadl_relaxed(i2c_dev->base + STM32F4_I2C_SR2);\r\nbreak;\r\n}\r\n}\r\nstatic irqreturn_t stm32f4_i2c_isr_event(int irq, void *data)\r\n{\r\nstruct stm32f4_i2c_dev *i2c_dev = data;\r\nstruct stm32f4_i2c_msg *msg = &i2c_dev->msg;\r\nu32 possible_status = STM32F4_I2C_SR1_ITEVTEN_MASK;\r\nu32 status, ien, event, cr2;\r\ncr2 = readl_relaxed(i2c_dev->base + STM32F4_I2C_CR2);\r\nien = cr2 & STM32F4_I2C_CR2_IRQ_MASK;\r\nif (ien & STM32F4_I2C_CR2_ITBUFEN)\r\npossible_status |= STM32F4_I2C_SR1_ITBUFEN_MASK;\r\nstatus = readl_relaxed(i2c_dev->base + STM32F4_I2C_SR1);\r\nevent = status & possible_status;\r\nif (!event) {\r\ndev_dbg(i2c_dev->dev,\r\n"spurious evt irq (status=0x%08x, ien=0x%08x)\n",\r\nstatus, ien);\r\nreturn IRQ_NONE;\r\n}\r\nif (event & STM32F4_I2C_SR1_SB)\r\nstm32f4_i2c_write_byte(i2c_dev, msg->addr);\r\nif (event & STM32F4_I2C_SR1_ADDR) {\r\nif (msg->addr & I2C_M_RD)\r\nstm32f4_i2c_handle_rx_addr(i2c_dev);\r\nelse\r\nreadl_relaxed(i2c_dev->base + STM32F4_I2C_SR2);\r\ncr2 |= STM32F4_I2C_CR2_ITBUFEN;\r\nwritel_relaxed(cr2, i2c_dev->base + STM32F4_I2C_CR2);\r\n}\r\nif ((event & STM32F4_I2C_SR1_TXE) && !(msg->addr & I2C_M_RD))\r\nstm32f4_i2c_handle_write(i2c_dev);\r\nif ((event & STM32F4_I2C_SR1_RXNE) && (msg->addr & I2C_M_RD))\r\nstm32f4_i2c_handle_read(i2c_dev);\r\nif (event & STM32F4_I2C_SR1_BTF) {\r\nif (msg->addr & I2C_M_RD)\r\nstm32f4_i2c_handle_rx_done(i2c_dev);\r\nelse\r\nstm32f4_i2c_handle_write(i2c_dev);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t stm32f4_i2c_isr_error(int irq, void *data)\r\n{\r\nstruct stm32f4_i2c_dev *i2c_dev = data;\r\nstruct stm32f4_i2c_msg *msg = &i2c_dev->msg;\r\nvoid __iomem *reg;\r\nu32 status;\r\nstatus = readl_relaxed(i2c_dev->base + STM32F4_I2C_SR1);\r\nif (status & STM32F4_I2C_SR1_ARLO) {\r\nstatus &= ~STM32F4_I2C_SR1_ARLO;\r\nwritel_relaxed(status, i2c_dev->base + STM32F4_I2C_SR1);\r\nmsg->result = -EAGAIN;\r\n}\r\nif (status & STM32F4_I2C_SR1_AF) {\r\nif (!(msg->addr & I2C_M_RD)) {\r\nreg = i2c_dev->base + STM32F4_I2C_CR1;\r\nstm32f4_i2c_set_bits(reg, STM32F4_I2C_CR1_STOP);\r\n}\r\nstatus &= ~STM32F4_I2C_SR1_AF;\r\nwritel_relaxed(status, i2c_dev->base + STM32F4_I2C_SR1);\r\nmsg->result = -EIO;\r\n}\r\nif (status & STM32F4_I2C_SR1_BERR) {\r\nstatus &= ~STM32F4_I2C_SR1_BERR;\r\nwritel_relaxed(status, i2c_dev->base + STM32F4_I2C_SR1);\r\nmsg->result = -EIO;\r\n}\r\nstm32f4_i2c_disable_irq(i2c_dev);\r\ncomplete(&i2c_dev->complete);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int stm32f4_i2c_xfer_msg(struct stm32f4_i2c_dev *i2c_dev,\r\nstruct i2c_msg *msg, bool is_first,\r\nbool is_last)\r\n{\r\nstruct stm32f4_i2c_msg *f4_msg = &i2c_dev->msg;\r\nvoid __iomem *reg = i2c_dev->base + STM32F4_I2C_CR1;\r\nunsigned long timeout;\r\nu32 mask;\r\nint ret;\r\nf4_msg->addr = i2c_8bit_addr_from_msg(msg);\r\nf4_msg->buf = msg->buf;\r\nf4_msg->count = msg->len;\r\nf4_msg->result = 0;\r\nf4_msg->stop = is_last;\r\nreinit_completion(&i2c_dev->complete);\r\nmask = STM32F4_I2C_CR2_ITEVTEN | STM32F4_I2C_CR2_ITERREN;\r\nstm32f4_i2c_set_bits(i2c_dev->base + STM32F4_I2C_CR2, mask);\r\nif (is_first) {\r\nret = stm32f4_i2c_wait_free_bus(i2c_dev);\r\nif (ret)\r\nreturn ret;\r\nstm32f4_i2c_set_bits(reg, STM32F4_I2C_CR1_START);\r\n}\r\ntimeout = wait_for_completion_timeout(&i2c_dev->complete,\r\ni2c_dev->adap.timeout);\r\nret = f4_msg->result;\r\nif (!timeout)\r\nret = -ETIMEDOUT;\r\nreturn ret;\r\n}\r\nstatic int stm32f4_i2c_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msgs[],\r\nint num)\r\n{\r\nstruct stm32f4_i2c_dev *i2c_dev = i2c_get_adapdata(i2c_adap);\r\nint ret, i;\r\nret = clk_enable(i2c_dev->clk);\r\nif (ret) {\r\ndev_err(i2c_dev->dev, "Failed to enable clock\n");\r\nreturn ret;\r\n}\r\nfor (i = 0; i < num && !ret; i++)\r\nret = stm32f4_i2c_xfer_msg(i2c_dev, &msgs[i], i == 0,\r\ni == num - 1);\r\nclk_disable(i2c_dev->clk);\r\nreturn (ret < 0) ? ret : num;\r\n}\r\nstatic u32 stm32f4_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic int stm32f4_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct stm32f4_i2c_dev *i2c_dev;\r\nstruct resource *res;\r\nu32 irq_event, irq_error, clk_rate;\r\nstruct i2c_adapter *adap;\r\nstruct reset_control *rst;\r\nint ret;\r\ni2c_dev = devm_kzalloc(&pdev->dev, sizeof(*i2c_dev), GFP_KERNEL);\r\nif (!i2c_dev)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ni2c_dev->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(i2c_dev->base))\r\nreturn PTR_ERR(i2c_dev->base);\r\nirq_event = irq_of_parse_and_map(np, 0);\r\nif (!irq_event) {\r\ndev_err(&pdev->dev, "IRQ event missing or invalid\n");\r\nreturn -EINVAL;\r\n}\r\nirq_error = irq_of_parse_and_map(np, 1);\r\nif (!irq_error) {\r\ndev_err(&pdev->dev, "IRQ error missing or invalid\n");\r\nreturn -EINVAL;\r\n}\r\ni2c_dev->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(i2c_dev->clk)) {\r\ndev_err(&pdev->dev, "Error: Missing controller clock\n");\r\nreturn PTR_ERR(i2c_dev->clk);\r\n}\r\nret = clk_prepare_enable(i2c_dev->clk);\r\nif (ret) {\r\ndev_err(i2c_dev->dev, "Failed to prepare_enable clock\n");\r\nreturn ret;\r\n}\r\nrst = devm_reset_control_get(&pdev->dev, NULL);\r\nif (IS_ERR(rst)) {\r\ndev_err(&pdev->dev, "Error: Missing controller reset\n");\r\nret = PTR_ERR(rst);\r\ngoto clk_free;\r\n}\r\nreset_control_assert(rst);\r\nudelay(2);\r\nreset_control_deassert(rst);\r\ni2c_dev->speed = STM32F4_I2C_SPEED_STANDARD;\r\nret = of_property_read_u32(np, "clock-frequency", &clk_rate);\r\nif (!ret && clk_rate >= 400000)\r\ni2c_dev->speed = STM32F4_I2C_SPEED_FAST;\r\ni2c_dev->dev = &pdev->dev;\r\nret = devm_request_irq(&pdev->dev, irq_event, stm32f4_i2c_isr_event, 0,\r\npdev->name, i2c_dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to request irq event %i\n",\r\nirq_event);\r\ngoto clk_free;\r\n}\r\nret = devm_request_irq(&pdev->dev, irq_error, stm32f4_i2c_isr_error, 0,\r\npdev->name, i2c_dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to request irq error %i\n",\r\nirq_error);\r\ngoto clk_free;\r\n}\r\nret = stm32f4_i2c_hw_config(i2c_dev);\r\nif (ret)\r\ngoto clk_free;\r\nadap = &i2c_dev->adap;\r\ni2c_set_adapdata(adap, i2c_dev);\r\nsnprintf(adap->name, sizeof(adap->name), "STM32 I2C(%pa)", &res->start);\r\nadap->owner = THIS_MODULE;\r\nadap->timeout = 2 * HZ;\r\nadap->retries = 0;\r\nadap->algo = &stm32f4_i2c_algo;\r\nadap->dev.parent = &pdev->dev;\r\nadap->dev.of_node = pdev->dev.of_node;\r\ninit_completion(&i2c_dev->complete);\r\nret = i2c_add_adapter(adap);\r\nif (ret)\r\ngoto clk_free;\r\nplatform_set_drvdata(pdev, i2c_dev);\r\nclk_disable(i2c_dev->clk);\r\ndev_info(i2c_dev->dev, "STM32F4 I2C driver registered\n");\r\nreturn 0;\r\nclk_free:\r\nclk_disable_unprepare(i2c_dev->clk);\r\nreturn ret;\r\n}\r\nstatic int stm32f4_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct stm32f4_i2c_dev *i2c_dev = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&i2c_dev->adap);\r\nclk_unprepare(i2c_dev->clk);\r\nreturn 0;\r\n}
