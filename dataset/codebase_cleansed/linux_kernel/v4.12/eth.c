int eth_header(struct sk_buff *skb, struct net_device *dev,\r\nunsigned short type,\r\nconst void *daddr, const void *saddr, unsigned int len)\r\n{\r\nstruct ethhdr *eth = (struct ethhdr *)skb_push(skb, ETH_HLEN);\r\nif (type != ETH_P_802_3 && type != ETH_P_802_2)\r\neth->h_proto = htons(type);\r\nelse\r\neth->h_proto = htons(len);\r\nif (!saddr)\r\nsaddr = dev->dev_addr;\r\nmemcpy(eth->h_source, saddr, ETH_ALEN);\r\nif (daddr) {\r\nmemcpy(eth->h_dest, daddr, ETH_ALEN);\r\nreturn ETH_HLEN;\r\n}\r\nif (dev->flags & (IFF_LOOPBACK | IFF_NOARP)) {\r\neth_zero_addr(eth->h_dest);\r\nreturn ETH_HLEN;\r\n}\r\nreturn -ETH_HLEN;\r\n}\r\nu32 eth_get_headlen(void *data, unsigned int len)\r\n{\r\nconst unsigned int flags = FLOW_DISSECTOR_F_PARSE_1ST_FRAG;\r\nconst struct ethhdr *eth = (const struct ethhdr *)data;\r\nstruct flow_keys keys;\r\nif (unlikely(len < sizeof(*eth)))\r\nreturn len;\r\nif (!skb_flow_dissect_flow_keys_buf(&keys, data, eth->h_proto,\r\nsizeof(*eth), len, flags))\r\nreturn max_t(u32, keys.control.thoff, sizeof(*eth));\r\nreturn min_t(u32, __skb_get_poff(NULL, data, &keys, len), len);\r\n}\r\n__be16 eth_type_trans(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nunsigned short _service_access_point;\r\nconst unsigned short *sap;\r\nconst struct ethhdr *eth;\r\nskb->dev = dev;\r\nskb_reset_mac_header(skb);\r\neth = (struct ethhdr *)skb->data;\r\nskb_pull_inline(skb, ETH_HLEN);\r\nif (unlikely(is_multicast_ether_addr_64bits(eth->h_dest))) {\r\nif (ether_addr_equal_64bits(eth->h_dest, dev->broadcast))\r\nskb->pkt_type = PACKET_BROADCAST;\r\nelse\r\nskb->pkt_type = PACKET_MULTICAST;\r\n}\r\nelse if (unlikely(!ether_addr_equal_64bits(eth->h_dest,\r\ndev->dev_addr)))\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nif (unlikely(netdev_uses_dsa(dev)))\r\nreturn htons(ETH_P_XDSA);\r\nif (likely(eth_proto_is_802_3(eth->h_proto)))\r\nreturn eth->h_proto;\r\nsap = skb_header_pointer(skb, 0, sizeof(*sap), &_service_access_point);\r\nif (sap && *sap == 0xFFFF)\r\nreturn htons(ETH_P_802_3);\r\nreturn htons(ETH_P_802_2);\r\n}\r\nint eth_header_parse(const struct sk_buff *skb, unsigned char *haddr)\r\n{\r\nconst struct ethhdr *eth = eth_hdr(skb);\r\nmemcpy(haddr, eth->h_source, ETH_ALEN);\r\nreturn ETH_ALEN;\r\n}\r\nint eth_header_cache(const struct neighbour *neigh, struct hh_cache *hh, __be16 type)\r\n{\r\nstruct ethhdr *eth;\r\nconst struct net_device *dev = neigh->dev;\r\neth = (struct ethhdr *)\r\n(((u8 *) hh->hh_data) + (HH_DATA_OFF(sizeof(*eth))));\r\nif (type == htons(ETH_P_802_3))\r\nreturn -1;\r\neth->h_proto = type;\r\nmemcpy(eth->h_source, dev->dev_addr, ETH_ALEN);\r\nmemcpy(eth->h_dest, neigh->ha, ETH_ALEN);\r\nhh->hh_len = ETH_HLEN;\r\nreturn 0;\r\n}\r\nvoid eth_header_cache_update(struct hh_cache *hh,\r\nconst struct net_device *dev,\r\nconst unsigned char *haddr)\r\n{\r\nmemcpy(((u8 *) hh->hh_data) + HH_DATA_OFF(sizeof(struct ethhdr)),\r\nhaddr, ETH_ALEN);\r\n}\r\nint eth_prepare_mac_addr_change(struct net_device *dev, void *p)\r\n{\r\nstruct sockaddr *addr = p;\r\nif (!(dev->priv_flags & IFF_LIVE_ADDR_CHANGE) && netif_running(dev))\r\nreturn -EBUSY;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nreturn 0;\r\n}\r\nvoid eth_commit_mac_addr_change(struct net_device *dev, void *p)\r\n{\r\nstruct sockaddr *addr = p;\r\nmemcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);\r\n}\r\nint eth_mac_addr(struct net_device *dev, void *p)\r\n{\r\nint ret;\r\nret = eth_prepare_mac_addr_change(dev, p);\r\nif (ret < 0)\r\nreturn ret;\r\neth_commit_mac_addr_change(dev, p);\r\nreturn 0;\r\n}\r\nint eth_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nnetdev_warn(dev, "%s is deprecated\n", __func__);\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nint eth_validate_addr(struct net_device *dev)\r\n{\r\nif (!is_valid_ether_addr(dev->dev_addr))\r\nreturn -EADDRNOTAVAIL;\r\nreturn 0;\r\n}\r\nvoid ether_setup(struct net_device *dev)\r\n{\r\ndev->header_ops = &eth_header_ops;\r\ndev->type = ARPHRD_ETHER;\r\ndev->hard_header_len = ETH_HLEN;\r\ndev->min_header_len = ETH_HLEN;\r\ndev->mtu = ETH_DATA_LEN;\r\ndev->min_mtu = ETH_MIN_MTU;\r\ndev->max_mtu = ETH_DATA_LEN;\r\ndev->addr_len = ETH_ALEN;\r\ndev->tx_queue_len = DEFAULT_TX_QUEUE_LEN;\r\ndev->flags = IFF_BROADCAST|IFF_MULTICAST;\r\ndev->priv_flags |= IFF_TX_SKB_SHARING;\r\neth_broadcast_addr(dev->broadcast);\r\n}\r\nstruct net_device *alloc_etherdev_mqs(int sizeof_priv, unsigned int txqs,\r\nunsigned int rxqs)\r\n{\r\nreturn alloc_netdev_mqs(sizeof_priv, "eth%d", NET_NAME_UNKNOWN,\r\nether_setup, txqs, rxqs);\r\n}\r\nstatic void devm_free_netdev(struct device *dev, void *res)\r\n{\r\nfree_netdev(*(struct net_device **)res);\r\n}\r\nstruct net_device *devm_alloc_etherdev_mqs(struct device *dev, int sizeof_priv,\r\nunsigned int txqs, unsigned int rxqs)\r\n{\r\nstruct net_device **dr;\r\nstruct net_device *netdev;\r\ndr = devres_alloc(devm_free_netdev, sizeof(*dr), GFP_KERNEL);\r\nif (!dr)\r\nreturn NULL;\r\nnetdev = alloc_etherdev_mqs(sizeof_priv, txqs, rxqs);\r\nif (!netdev) {\r\ndevres_free(dr);\r\nreturn NULL;\r\n}\r\n*dr = netdev;\r\ndevres_add(dev, dr);\r\nreturn netdev;\r\n}\r\nssize_t sysfs_format_mac(char *buf, const unsigned char *addr, int len)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%*phC\n", len, addr);\r\n}\r\nstruct sk_buff **eth_gro_receive(struct sk_buff **head,\r\nstruct sk_buff *skb)\r\n{\r\nstruct sk_buff *p, **pp = NULL;\r\nstruct ethhdr *eh, *eh2;\r\nunsigned int hlen, off_eth;\r\nconst struct packet_offload *ptype;\r\n__be16 type;\r\nint flush = 1;\r\noff_eth = skb_gro_offset(skb);\r\nhlen = off_eth + sizeof(*eh);\r\neh = skb_gro_header_fast(skb, off_eth);\r\nif (skb_gro_header_hard(skb, hlen)) {\r\neh = skb_gro_header_slow(skb, hlen, off_eth);\r\nif (unlikely(!eh))\r\ngoto out;\r\n}\r\nflush = 0;\r\nfor (p = *head; p; p = p->next) {\r\nif (!NAPI_GRO_CB(p)->same_flow)\r\ncontinue;\r\neh2 = (struct ethhdr *)(p->data + off_eth);\r\nif (compare_ether_header(eh, eh2)) {\r\nNAPI_GRO_CB(p)->same_flow = 0;\r\ncontinue;\r\n}\r\n}\r\ntype = eh->h_proto;\r\nrcu_read_lock();\r\nptype = gro_find_receive_by_type(type);\r\nif (ptype == NULL) {\r\nflush = 1;\r\ngoto out_unlock;\r\n}\r\nskb_gro_pull(skb, sizeof(*eh));\r\nskb_gro_postpull_rcsum(skb, eh, sizeof(*eh));\r\npp = call_gro_receive(ptype->callbacks.gro_receive, head, skb);\r\nout_unlock:\r\nrcu_read_unlock();\r\nout:\r\nskb_gro_flush_final(skb, pp, flush);\r\nreturn pp;\r\n}\r\nint eth_gro_complete(struct sk_buff *skb, int nhoff)\r\n{\r\nstruct ethhdr *eh = (struct ethhdr *)(skb->data + nhoff);\r\n__be16 type = eh->h_proto;\r\nstruct packet_offload *ptype;\r\nint err = -ENOSYS;\r\nif (skb->encapsulation)\r\nskb_set_inner_mac_header(skb, nhoff);\r\nrcu_read_lock();\r\nptype = gro_find_complete_by_type(type);\r\nif (ptype != NULL)\r\nerr = ptype->callbacks.gro_complete(skb, nhoff +\r\nsizeof(struct ethhdr));\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nstatic int __init eth_offload_init(void)\r\n{\r\ndev_add_offload(&eth_packet_offload);\r\nreturn 0;\r\n}\r\nunsigned char * __weak arch_get_platform_mac_address(void)\r\n{\r\nreturn NULL;\r\n}\r\nint eth_platform_get_mac_address(struct device *dev, u8 *mac_addr)\r\n{\r\nconst unsigned char *addr;\r\nstruct device_node *dp;\r\nif (dev_is_pci(dev))\r\ndp = pci_device_to_OF_node(to_pci_dev(dev));\r\nelse\r\ndp = dev->of_node;\r\naddr = NULL;\r\nif (dp)\r\naddr = of_get_mac_address(dp);\r\nif (!addr)\r\naddr = arch_get_platform_mac_address();\r\nif (!addr)\r\nreturn -ENODEV;\r\nether_addr_copy(mac_addr, addr);\r\nreturn 0;\r\n}
