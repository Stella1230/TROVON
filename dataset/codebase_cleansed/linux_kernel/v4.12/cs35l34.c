static bool cs35l34_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase CS35L34_DEVID_AB:\r\ncase CS35L34_DEVID_CD:\r\ncase CS35L34_DEVID_E:\r\ncase CS35L34_FAB_ID:\r\ncase CS35L34_REV_ID:\r\ncase CS35L34_INT_STATUS_1:\r\ncase CS35L34_INT_STATUS_2:\r\ncase CS35L34_INT_STATUS_3:\r\ncase CS35L34_INT_STATUS_4:\r\ncase CS35L34_CLASS_H_STATUS:\r\ncase CS35L34_VPBR_ATTEN_STATUS:\r\ncase CS35L34_OTP_TRIM_STATUS:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool cs35l34_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase CS35L34_DEVID_AB:\r\ncase CS35L34_DEVID_CD:\r\ncase CS35L34_DEVID_E:\r\ncase CS35L34_FAB_ID:\r\ncase CS35L34_REV_ID:\r\ncase CS35L34_PWRCTL1:\r\ncase CS35L34_PWRCTL2:\r\ncase CS35L34_PWRCTL3:\r\ncase CS35L34_ADSP_CLK_CTL:\r\ncase CS35L34_MCLK_CTL:\r\ncase CS35L34_AMP_INP_DRV_CTL:\r\ncase CS35L34_AMP_DIG_VOL_CTL:\r\ncase CS35L34_AMP_DIG_VOL:\r\ncase CS35L34_AMP_ANLG_GAIN_CTL:\r\ncase CS35L34_PROTECT_CTL:\r\ncase CS35L34_AMP_KEEP_ALIVE_CTL:\r\ncase CS35L34_BST_CVTR_V_CTL:\r\ncase CS35L34_BST_PEAK_I:\r\ncase CS35L34_BST_RAMP_CTL:\r\ncase CS35L34_BST_CONV_COEF_1:\r\ncase CS35L34_BST_CONV_COEF_2:\r\ncase CS35L34_BST_CONV_SLOPE_COMP:\r\ncase CS35L34_BST_CONV_SW_FREQ:\r\ncase CS35L34_CLASS_H_CTL:\r\ncase CS35L34_CLASS_H_HEADRM_CTL:\r\ncase CS35L34_CLASS_H_RELEASE_RATE:\r\ncase CS35L34_CLASS_H_FET_DRIVE_CTL:\r\ncase CS35L34_CLASS_H_STATUS:\r\ncase CS35L34_VPBR_CTL:\r\ncase CS35L34_VPBR_VOL_CTL:\r\ncase CS35L34_VPBR_TIMING_CTL:\r\ncase CS35L34_PRED_MAX_ATTEN_SPK_LOAD:\r\ncase CS35L34_PRED_BROWNOUT_THRESH:\r\ncase CS35L34_PRED_BROWNOUT_VOL_CTL:\r\ncase CS35L34_PRED_BROWNOUT_RATE_CTL:\r\ncase CS35L34_PRED_WAIT_CTL:\r\ncase CS35L34_PRED_ZVP_INIT_IMP_CTL:\r\ncase CS35L34_PRED_MAN_SAFE_VPI_CTL:\r\ncase CS35L34_VPBR_ATTEN_STATUS:\r\ncase CS35L34_PRED_BRWNOUT_ATT_STATUS:\r\ncase CS35L34_SPKR_MON_CTL:\r\ncase CS35L34_ADSP_I2S_CTL:\r\ncase CS35L34_ADSP_TDM_CTL:\r\ncase CS35L34_TDM_TX_CTL_1_VMON:\r\ncase CS35L34_TDM_TX_CTL_2_IMON:\r\ncase CS35L34_TDM_TX_CTL_3_VPMON:\r\ncase CS35L34_TDM_TX_CTL_4_VBSTMON:\r\ncase CS35L34_TDM_TX_CTL_5_FLAG1:\r\ncase CS35L34_TDM_TX_CTL_6_FLAG2:\r\ncase CS35L34_TDM_TX_SLOT_EN_1:\r\ncase CS35L34_TDM_TX_SLOT_EN_2:\r\ncase CS35L34_TDM_TX_SLOT_EN_3:\r\ncase CS35L34_TDM_TX_SLOT_EN_4:\r\ncase CS35L34_TDM_RX_CTL_1_AUDIN:\r\ncase CS35L34_TDM_RX_CTL_3_ALIVE:\r\ncase CS35L34_MULT_DEV_SYNCH1:\r\ncase CS35L34_MULT_DEV_SYNCH2:\r\ncase CS35L34_PROT_RELEASE_CTL:\r\ncase CS35L34_DIAG_MODE_REG_LOCK:\r\ncase CS35L34_DIAG_MODE_CTL_1:\r\ncase CS35L34_DIAG_MODE_CTL_2:\r\ncase CS35L34_INT_MASK_1:\r\ncase CS35L34_INT_MASK_2:\r\ncase CS35L34_INT_MASK_3:\r\ncase CS35L34_INT_MASK_4:\r\ncase CS35L34_INT_STATUS_1:\r\ncase CS35L34_INT_STATUS_2:\r\ncase CS35L34_INT_STATUS_3:\r\ncase CS35L34_INT_STATUS_4:\r\ncase CS35L34_OTP_TRIM_STATUS:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool cs35l34_precious_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase CS35L34_INT_STATUS_1:\r\ncase CS35L34_INT_STATUS_2:\r\ncase CS35L34_INT_STATUS_3:\r\ncase CS35L34_INT_STATUS_4:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int cs35l34_sdin_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct cs35l34_private *priv = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nif (priv->tdm_mode)\r\nregmap_update_bits(priv->regmap, CS35L34_PWRCTL3,\r\nCS35L34_PDN_TDM, 0x00);\r\nret = regmap_update_bits(priv->regmap, CS35L34_PWRCTL1,\r\nCS35L34_PDN_ALL, 0);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Cannot set Power bits %d\n", ret);\r\nreturn ret;\r\n}\r\nusleep_range(5000, 5100);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nif (priv->tdm_mode) {\r\nregmap_update_bits(priv->regmap, CS35L34_PWRCTL3,\r\nCS35L34_PDN_TDM, CS35L34_PDN_TDM);\r\n}\r\nret = regmap_update_bits(priv->regmap, CS35L34_PWRCTL1,\r\nCS35L34_PDN_ALL, CS35L34_PDN_ALL);\r\nbreak;\r\ndefault:\r\npr_err("Invalid event = 0x%x\n", event);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs35l34_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\r\nunsigned int rx_mask, int slots, int slot_width)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct cs35l34_private *priv = snd_soc_codec_get_drvdata(codec);\r\nunsigned int reg, bit_pos;\r\nint slot, slot_num;\r\nif (slot_width != 8)\r\nreturn -EINVAL;\r\npriv->tdm_mode = true;\r\nslot = ffs(rx_mask) - 1;\r\nif (slot >= 0)\r\nsnd_soc_update_bits(codec, CS35L34_TDM_RX_CTL_1_AUDIN,\r\nCS35L34_X_LOC, slot);\r\nslot = ffs(tx_mask) - 1;\r\nslot_num = 0;\r\nsnd_soc_update_bits(codec, CS35L34_TDM_TX_CTL_3_VPMON,\r\nCS35L34_X_STATE | CS35L34_X_LOC,\r\nCS35L34_X_STATE | CS35L34_X_LOC);\r\nsnd_soc_update_bits(codec, CS35L34_TDM_TX_CTL_4_VBSTMON,\r\nCS35L34_X_STATE | CS35L34_X_LOC,\r\nCS35L34_X_STATE | CS35L34_X_LOC);\r\nwhile (slot >= 0) {\r\nif (slot_num == 0)\r\nsnd_soc_update_bits(codec, CS35L34_TDM_TX_CTL_1_VMON,\r\nCS35L34_X_STATE | CS35L34_X_LOC, slot);\r\nif (slot_num == 4) {\r\nsnd_soc_update_bits(codec, CS35L34_TDM_TX_CTL_2_IMON,\r\nCS35L34_X_STATE | CS35L34_X_LOC, slot);\r\n}\r\nif (slot_num == 3) {\r\nsnd_soc_update_bits(codec, CS35L34_TDM_TX_CTL_3_VPMON,\r\nCS35L34_X_STATE | CS35L34_X_LOC, slot);\r\n}\r\nif (slot_num == 7) {\r\nsnd_soc_update_bits(codec,\r\nCS35L34_TDM_TX_CTL_4_VBSTMON,\r\nCS35L34_X_STATE | CS35L34_X_LOC, slot);\r\n}\r\nreg = CS35L34_TDM_TX_SLOT_EN_4 - (slot/8);\r\nbit_pos = slot - ((slot / 8) * (8));\r\nsnd_soc_update_bits(codec, reg,\r\n1 << bit_pos, 1 << bit_pos);\r\ntx_mask &= ~(1 << slot);\r\nslot = ffs(tx_mask) - 1;\r\nslot_num++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs35l34_main_amp_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct cs35l34_private *priv = snd_soc_codec_get_drvdata(codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nregmap_update_bits(priv->regmap, CS35L34_BST_CVTR_V_CTL,\r\nCS35L34_BST_CVTL_MASK, priv->pdata.boost_vtge);\r\nusleep_range(5000, 5100);\r\nregmap_update_bits(priv->regmap, CS35L34_PROTECT_CTL,\r\nCS35L34_MUTE, 0);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nregmap_update_bits(priv->regmap, CS35L34_BST_CVTR_V_CTL,\r\nCS35L34_BST_CVTL_MASK, 0);\r\nregmap_update_bits(priv->regmap, CS35L34_PROTECT_CTL,\r\nCS35L34_MUTE, CS35L34_MUTE);\r\nusleep_range(5000, 5100);\r\nbreak;\r\ndefault:\r\npr_err("Invalid event = 0x%x\n", event);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs35l34_mclk_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct cs35l34_private *priv = snd_soc_codec_get_drvdata(codec);\r\nint ret, i;\r\nunsigned int reg;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nret = regmap_read(priv->regmap, CS35L34_AMP_DIG_VOL_CTL,\r\n&reg);\r\nif (ret != 0) {\r\npr_err("%s regmap read failure %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nif (reg & CS35L34_AMP_DIGSFT)\r\nmsleep(40);\r\nelse\r\nusleep_range(2000, 2100);\r\nfor (i = 0; i < PDN_DONE_ATTEMPTS; i++) {\r\nret = regmap_read(priv->regmap, CS35L34_INT_STATUS_2,\r\n&reg);\r\nif (ret != 0) {\r\npr_err("%s regmap read failure %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nif (reg & CS35L34_PDN_DONE)\r\nbreak;\r\nusleep_range(5000, 5100);\r\n}\r\nif (i == PDN_DONE_ATTEMPTS)\r\npr_err("%s Device did not power down properly\n",\r\n__func__);\r\nbreak;\r\ndefault:\r\npr_err("Invalid event = 0x%x\n", event);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs35l34_get_mclk_coeff(int mclk, int srate)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(cs35l34_mclk_coeffs); i++) {\r\nif (cs35l34_mclk_coeffs[i].mclk == mclk &&\r\ncs35l34_mclk_coeffs[i].srate == srate)\r\nreturn i;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int cs35l34_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct cs35l34_private *priv = snd_soc_codec_get_drvdata(codec);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nregmap_update_bits(priv->regmap, CS35L34_ADSP_CLK_CTL,\r\n0x80, 0x80);\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nregmap_update_bits(priv->regmap, CS35L34_ADSP_CLK_CTL,\r\n0x80, 0x00);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs35l34_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct cs35l34_private *priv = snd_soc_codec_get_drvdata(codec);\r\nint srate = params_rate(params);\r\nint ret;\r\nint coeff = cs35l34_get_mclk_coeff(priv->mclk_int, srate);\r\nif (coeff < 0) {\r\ndev_err(codec->dev, "ERROR: Invalid mclk %d and/or srate %d\n",\r\npriv->mclk_int, srate);\r\nreturn coeff;\r\n}\r\nret = regmap_update_bits(priv->regmap, CS35L34_ADSP_CLK_CTL,\r\nCS35L34_ADSP_RATE, cs35l34_mclk_coeffs[coeff].adsp_rate);\r\nif (ret != 0)\r\ndev_err(codec->dev, "Failed to set clock state %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int cs35l34_pcm_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nsnd_pcm_hw_constraint_list(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE, &cs35l34_constraints);\r\nreturn 0;\r\n}\r\nstatic int cs35l34_set_tristate(struct snd_soc_dai *dai, int tristate)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nif (tristate)\r\nsnd_soc_update_bits(codec, CS35L34_PWRCTL3,\r\nCS35L34_PDN_SDOUT, CS35L34_PDN_SDOUT);\r\nelse\r\nsnd_soc_update_bits(codec, CS35L34_PWRCTL3,\r\nCS35L34_PDN_SDOUT, 0);\r\nreturn 0;\r\n}\r\nstatic int cs35l34_dai_set_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct cs35l34_private *cs35l34 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int value;\r\nswitch (freq) {\r\ncase CS35L34_MCLK_5644:\r\nvalue = CS35L34_MCLK_RATE_5P6448;\r\ncs35l34->mclk_int = freq;\r\nbreak;\r\ncase CS35L34_MCLK_6:\r\nvalue = CS35L34_MCLK_RATE_6P0000;\r\ncs35l34->mclk_int = freq;\r\nbreak;\r\ncase CS35L34_MCLK_6144:\r\nvalue = CS35L34_MCLK_RATE_6P1440;\r\ncs35l34->mclk_int = freq;\r\nbreak;\r\ncase CS35L34_MCLK_11289:\r\nvalue = CS35L34_MCLK_DIV | CS35L34_MCLK_RATE_5P6448;\r\ncs35l34->mclk_int = freq / 2;\r\nbreak;\r\ncase CS35L34_MCLK_12:\r\nvalue = CS35L34_MCLK_DIV | CS35L34_MCLK_RATE_6P0000;\r\ncs35l34->mclk_int = freq / 2;\r\nbreak;\r\ncase CS35L34_MCLK_12288:\r\nvalue = CS35L34_MCLK_DIV | CS35L34_MCLK_RATE_6P1440;\r\ncs35l34->mclk_int = freq / 2;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "ERROR: Invalid Frequency %d\n", freq);\r\ncs35l34->mclk_int = 0;\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(cs35l34->regmap, CS35L34_MCLK_CTL,\r\nCS35L34_MCLK_DIV | CS35L34_MCLK_RATE_MASK, value);\r\nreturn 0;\r\n}\r\nstatic int cs35l34_boost_inductor(struct cs35l34_private *cs35l34,\r\nunsigned int inductor)\r\n{\r\nstruct snd_soc_codec *codec = cs35l34->codec;\r\nswitch (inductor) {\r\ncase 1000:\r\nregmap_write(cs35l34->regmap, CS35L34_BST_CONV_COEF_1, 0x24);\r\nregmap_write(cs35l34->regmap, CS35L34_BST_CONV_COEF_2, 0x24);\r\nregmap_write(cs35l34->regmap, CS35L34_BST_CONV_SLOPE_COMP,\r\n0x4E);\r\nregmap_write(cs35l34->regmap, CS35L34_BST_CONV_SW_FREQ, 0);\r\nbreak;\r\ncase 1200:\r\nregmap_write(cs35l34->regmap, CS35L34_BST_CONV_COEF_1, 0x20);\r\nregmap_write(cs35l34->regmap, CS35L34_BST_CONV_COEF_2, 0x20);\r\nregmap_write(cs35l34->regmap, CS35L34_BST_CONV_SLOPE_COMP,\r\n0x47);\r\nregmap_write(cs35l34->regmap, CS35L34_BST_CONV_SW_FREQ, 1);\r\nbreak;\r\ncase 1500:\r\nregmap_write(cs35l34->regmap, CS35L34_BST_CONV_COEF_1, 0x20);\r\nregmap_write(cs35l34->regmap, CS35L34_BST_CONV_COEF_2, 0x20);\r\nregmap_write(cs35l34->regmap, CS35L34_BST_CONV_SLOPE_COMP,\r\n0x3C);\r\nregmap_write(cs35l34->regmap, CS35L34_BST_CONV_SW_FREQ, 2);\r\nbreak;\r\ncase 2200:\r\nregmap_write(cs35l34->regmap, CS35L34_BST_CONV_COEF_1, 0x19);\r\nregmap_write(cs35l34->regmap, CS35L34_BST_CONV_COEF_2, 0x25);\r\nregmap_write(cs35l34->regmap, CS35L34_BST_CONV_SLOPE_COMP,\r\n0x23);\r\nregmap_write(cs35l34->regmap, CS35L34_BST_CONV_SW_FREQ, 3);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "%s Invalid Inductor Value %d uH\n",\r\n__func__, inductor);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs35l34_probe(struct snd_soc_codec *codec)\r\n{\r\nint ret = 0;\r\nstruct cs35l34_private *cs35l34 = snd_soc_codec_get_drvdata(codec);\r\npm_runtime_get_sync(codec->dev);\r\nregmap_update_bits(cs35l34->regmap, CS35L34_PROTECT_CTL,\r\nCS35L34_OTW_ATTN_MASK, 0x8);\r\nregmap_write(cs35l34->regmap, CS35L34_PWRCTL2, 0xFD);\r\nregmap_write(cs35l34->regmap, CS35L34_PWRCTL3, 0x1F);\r\nregmap_update_bits(cs35l34->regmap, CS35L34_PROTECT_CTL,\r\nCS35L34_MUTE, CS35L34_MUTE);\r\nif (cs35l34->pdata.boost_peak)\r\nregmap_update_bits(cs35l34->regmap, CS35L34_BST_PEAK_I,\r\nCS35L34_BST_PEAK_MASK,\r\ncs35l34->pdata.boost_peak);\r\nif (cs35l34->pdata.gain_zc_disable)\r\nregmap_update_bits(cs35l34->regmap, CS35L34_PROTECT_CTL,\r\nCS35L34_GAIN_ZC_MASK, 0);\r\nelse\r\nregmap_update_bits(cs35l34->regmap, CS35L34_PROTECT_CTL,\r\nCS35L34_GAIN_ZC_MASK, CS35L34_GAIN_ZC_MASK);\r\nif (cs35l34->pdata.aif_half_drv)\r\nregmap_update_bits(cs35l34->regmap, CS35L34_ADSP_CLK_CTL,\r\nCS35L34_ADSP_DRIVE, 0);\r\nif (cs35l34->pdata.digsft_disable)\r\nregmap_update_bits(cs35l34->regmap, CS35L34_AMP_DIG_VOL_CTL,\r\nCS35L34_AMP_DIGSFT, 0);\r\nif (cs35l34->pdata.amp_inv)\r\nregmap_update_bits(cs35l34->regmap, CS35L34_AMP_DIG_VOL_CTL,\r\nCS35L34_INV, CS35L34_INV);\r\nif (cs35l34->pdata.boost_ind)\r\nret = cs35l34_boost_inductor(cs35l34, cs35l34->pdata.boost_ind);\r\nif (cs35l34->pdata.i2s_sdinloc)\r\nregmap_update_bits(cs35l34->regmap, CS35L34_ADSP_I2S_CTL,\r\nCS35L34_I2S_LOC_MASK,\r\ncs35l34->pdata.i2s_sdinloc << CS35L34_I2S_LOC_SHIFT);\r\nif (cs35l34->pdata.tdm_rising_edge)\r\nregmap_update_bits(cs35l34->regmap, CS35L34_ADSP_TDM_CTL,\r\n1, 1);\r\npm_runtime_put_sync(codec->dev);\r\nreturn ret;\r\n}\r\nstatic int cs35l34_handle_of_data(struct i2c_client *i2c_client,\r\nstruct cs35l34_platform_data *pdata)\r\n{\r\nstruct device_node *np = i2c_client->dev.of_node;\r\nunsigned int val;\r\nif (of_property_read_u32(np, "cirrus,boost-vtge-millivolt",\r\n&val) >= 0) {\r\nif (val > 8000 || (val < 3300 && val > 0)) {\r\ndev_err(&i2c_client->dev,\r\n"Invalid Boost Voltage %d mV\n", val);\r\nreturn -EINVAL;\r\n}\r\nif (val == 0)\r\npdata->boost_vtge = 0;\r\nelse\r\npdata->boost_vtge = ((val - 3300)/100) + 1;\r\n} else {\r\ndev_warn(&i2c_client->dev,\r\n"Boost Voltage not specified. Using VP\n");\r\n}\r\nif (of_property_read_u32(np, "cirrus,boost-ind-nanohenry", &val) >= 0) {\r\npdata->boost_ind = val;\r\n} else {\r\ndev_err(&i2c_client->dev, "Inductor not specified.\n");\r\nreturn -EINVAL;\r\n}\r\nif (of_property_read_u32(np, "cirrus,boost-peak-milliamp", &val) >= 0) {\r\nif (val > 3840 || val < 1200) {\r\ndev_err(&i2c_client->dev,\r\n"Invalid Boost Peak Current %d mA\n", val);\r\nreturn -EINVAL;\r\n}\r\npdata->boost_peak = ((val - 1200)/80) + 1;\r\n}\r\npdata->aif_half_drv = of_property_read_bool(np,\r\n"cirrus,aif-half-drv");\r\npdata->digsft_disable = of_property_read_bool(np,\r\n"cirrus,digsft-disable");\r\npdata->gain_zc_disable = of_property_read_bool(np,\r\n"cirrus,gain-zc-disable");\r\npdata->amp_inv = of_property_read_bool(np, "cirrus,amp-inv");\r\nif (of_property_read_u32(np, "cirrus,i2s-sdinloc", &val) >= 0)\r\npdata->i2s_sdinloc = val;\r\nif (of_property_read_u32(np, "cirrus,tdm-rising-edge", &val) >= 0)\r\npdata->tdm_rising_edge = val;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t cs35l34_irq_thread(int irq, void *data)\r\n{\r\nstruct cs35l34_private *cs35l34 = data;\r\nstruct snd_soc_codec *codec = cs35l34->codec;\r\nunsigned int sticky1, sticky2, sticky3, sticky4;\r\nunsigned int mask1, mask2, mask3, mask4, current1;\r\nregmap_read(cs35l34->regmap, CS35L34_INT_STATUS_4, &sticky4);\r\nregmap_read(cs35l34->regmap, CS35L34_INT_STATUS_3, &sticky3);\r\nregmap_read(cs35l34->regmap, CS35L34_INT_STATUS_2, &sticky2);\r\nregmap_read(cs35l34->regmap, CS35L34_INT_STATUS_1, &sticky1);\r\nregmap_read(cs35l34->regmap, CS35L34_INT_MASK_4, &mask4);\r\nregmap_read(cs35l34->regmap, CS35L34_INT_MASK_3, &mask3);\r\nregmap_read(cs35l34->regmap, CS35L34_INT_MASK_2, &mask2);\r\nregmap_read(cs35l34->regmap, CS35L34_INT_MASK_1, &mask1);\r\nif (!(sticky1 & ~mask1) && !(sticky2 & ~mask2) && !(sticky3 & ~mask3)\r\n&& !(sticky4 & ~mask4))\r\nreturn IRQ_NONE;\r\nregmap_read(cs35l34->regmap, CS35L34_INT_STATUS_1, &current1);\r\nif (sticky1 & CS35L34_CAL_ERR) {\r\ndev_err(codec->dev, "Cal error\n");\r\nif (!(current1 & CS35L34_CAL_ERR)) {\r\ndev_dbg(codec->dev, "Cal error release\n");\r\nregmap_update_bits(cs35l34->regmap,\r\nCS35L34_PROT_RELEASE_CTL,\r\nCS35L34_CAL_ERR_RLS, 0);\r\nregmap_update_bits(cs35l34->regmap,\r\nCS35L34_PROT_RELEASE_CTL,\r\nCS35L34_CAL_ERR_RLS,\r\nCS35L34_CAL_ERR_RLS);\r\nregmap_update_bits(cs35l34->regmap,\r\nCS35L34_PROT_RELEASE_CTL,\r\nCS35L34_CAL_ERR_RLS, 0);\r\n}\r\n}\r\nif (sticky1 & CS35L34_ALIVE_ERR)\r\ndev_err(codec->dev, "Alive error\n");\r\nif (sticky1 & CS35L34_AMP_SHORT) {\r\ndev_crit(codec->dev, "Amp short error\n");\r\nif (!(current1 & CS35L34_AMP_SHORT)) {\r\ndev_dbg(codec->dev,\r\n"Amp short error release\n");\r\nregmap_update_bits(cs35l34->regmap,\r\nCS35L34_PROT_RELEASE_CTL,\r\nCS35L34_SHORT_RLS, 0);\r\nregmap_update_bits(cs35l34->regmap,\r\nCS35L34_PROT_RELEASE_CTL,\r\nCS35L34_SHORT_RLS,\r\nCS35L34_SHORT_RLS);\r\nregmap_update_bits(cs35l34->regmap,\r\nCS35L34_PROT_RELEASE_CTL,\r\nCS35L34_SHORT_RLS, 0);\r\n}\r\n}\r\nif (sticky1 & CS35L34_OTW) {\r\ndev_crit(codec->dev, "Over temperature warning\n");\r\nif (!(current1 & CS35L34_OTW)) {\r\ndev_dbg(codec->dev,\r\n"Over temperature warning release\n");\r\nregmap_update_bits(cs35l34->regmap,\r\nCS35L34_PROT_RELEASE_CTL,\r\nCS35L34_OTW_RLS, 0);\r\nregmap_update_bits(cs35l34->regmap,\r\nCS35L34_PROT_RELEASE_CTL,\r\nCS35L34_OTW_RLS,\r\nCS35L34_OTW_RLS);\r\nregmap_update_bits(cs35l34->regmap,\r\nCS35L34_PROT_RELEASE_CTL,\r\nCS35L34_OTW_RLS, 0);\r\n}\r\n}\r\nif (sticky1 & CS35L34_OTE) {\r\ndev_crit(codec->dev, "Over temperature error\n");\r\nif (!(current1 & CS35L34_OTE)) {\r\ndev_dbg(codec->dev,\r\n"Over temperature error release\n");\r\nregmap_update_bits(cs35l34->regmap,\r\nCS35L34_PROT_RELEASE_CTL,\r\nCS35L34_OTE_RLS, 0);\r\nregmap_update_bits(cs35l34->regmap,\r\nCS35L34_PROT_RELEASE_CTL,\r\nCS35L34_OTE_RLS,\r\nCS35L34_OTE_RLS);\r\nregmap_update_bits(cs35l34->regmap,\r\nCS35L34_PROT_RELEASE_CTL,\r\nCS35L34_OTE_RLS, 0);\r\n}\r\n}\r\nif (sticky3 & CS35L34_BST_HIGH) {\r\ndev_crit(codec->dev, "VBST too high error; powering off!\n");\r\nregmap_update_bits(cs35l34->regmap, CS35L34_PWRCTL2,\r\nCS35L34_PDN_AMP, CS35L34_PDN_AMP);\r\nregmap_update_bits(cs35l34->regmap, CS35L34_PWRCTL1,\r\nCS35L34_PDN_ALL, CS35L34_PDN_ALL);\r\n}\r\nif (sticky3 & CS35L34_LBST_SHORT) {\r\ndev_crit(codec->dev, "LBST short error; powering off!\n");\r\nregmap_update_bits(cs35l34->regmap, CS35L34_PWRCTL2,\r\nCS35L34_PDN_AMP, CS35L34_PDN_AMP);\r\nregmap_update_bits(cs35l34->regmap, CS35L34_PWRCTL1,\r\nCS35L34_PDN_ALL, CS35L34_PDN_ALL);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int cs35l34_i2c_probe(struct i2c_client *i2c_client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct cs35l34_private *cs35l34;\r\nstruct cs35l34_platform_data *pdata =\r\ndev_get_platdata(&i2c_client->dev);\r\nint i;\r\nint ret;\r\nunsigned int devid = 0;\r\nunsigned int reg;\r\ncs35l34 = devm_kzalloc(&i2c_client->dev,\r\nsizeof(struct cs35l34_private),\r\nGFP_KERNEL);\r\nif (!cs35l34) {\r\ndev_err(&i2c_client->dev, "could not allocate codec\n");\r\nreturn -ENOMEM;\r\n}\r\ni2c_set_clientdata(i2c_client, cs35l34);\r\ncs35l34->regmap = devm_regmap_init_i2c(i2c_client, &cs35l34_regmap);\r\nif (IS_ERR(cs35l34->regmap)) {\r\nret = PTR_ERR(cs35l34->regmap);\r\ndev_err(&i2c_client->dev, "regmap_init() failed: %d\n", ret);\r\nreturn ret;\r\n}\r\ncs35l34->num_core_supplies = ARRAY_SIZE(cs35l34_core_supplies);\r\nfor (i = 0; i < ARRAY_SIZE(cs35l34_core_supplies); i++)\r\ncs35l34->core_supplies[i].supply = cs35l34_core_supplies[i];\r\nret = devm_regulator_bulk_get(&i2c_client->dev,\r\ncs35l34->num_core_supplies,\r\ncs35l34->core_supplies);\r\nif (ret != 0) {\r\ndev_err(&i2c_client->dev,\r\n"Failed to request core supplies %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regulator_bulk_enable(cs35l34->num_core_supplies,\r\ncs35l34->core_supplies);\r\nif (ret != 0) {\r\ndev_err(&i2c_client->dev,\r\n"Failed to enable core supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (pdata) {\r\ncs35l34->pdata = *pdata;\r\n} else {\r\npdata = devm_kzalloc(&i2c_client->dev,\r\nsizeof(struct cs35l34_platform_data),\r\nGFP_KERNEL);\r\nif (!pdata) {\r\ndev_err(&i2c_client->dev,\r\n"could not allocate pdata\n");\r\nreturn -ENOMEM;\r\n}\r\nif (i2c_client->dev.of_node) {\r\nret = cs35l34_handle_of_data(i2c_client, pdata);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\ncs35l34->pdata = *pdata;\r\n}\r\nret = devm_request_threaded_irq(&i2c_client->dev, i2c_client->irq, NULL,\r\ncs35l34_irq_thread, IRQF_ONESHOT | IRQF_TRIGGER_LOW,\r\n"cs35l34", cs35l34);\r\nif (ret != 0)\r\ndev_err(&i2c_client->dev, "Failed to request IRQ: %d\n", ret);\r\ncs35l34->reset_gpio = devm_gpiod_get_optional(&i2c_client->dev,\r\n"reset-gpios", GPIOD_OUT_LOW);\r\nif (IS_ERR(cs35l34->reset_gpio))\r\nreturn PTR_ERR(cs35l34->reset_gpio);\r\ngpiod_set_value_cansleep(cs35l34->reset_gpio, 1);\r\nmsleep(CS35L34_START_DELAY);\r\nret = regmap_read(cs35l34->regmap, CS35L34_DEVID_AB, &reg);\r\ndevid = (reg & 0xFF) << 12;\r\nret = regmap_read(cs35l34->regmap, CS35L34_DEVID_CD, &reg);\r\ndevid |= (reg & 0xFF) << 4;\r\nret = regmap_read(cs35l34->regmap, CS35L34_DEVID_E, &reg);\r\ndevid |= (reg & 0xF0) >> 4;\r\nif (devid != CS35L34_CHIP_ID) {\r\ndev_err(&i2c_client->dev,\r\n"CS35l34 Device ID (%X). Expected ID %X\n",\r\ndevid, CS35L34_CHIP_ID);\r\nret = -ENODEV;\r\ngoto err_regulator;\r\n}\r\nret = regmap_read(cs35l34->regmap, CS35L34_REV_ID, &reg);\r\nif (ret < 0) {\r\ndev_err(&i2c_client->dev, "Get Revision ID failed\n");\r\ngoto err_regulator;\r\n}\r\ndev_info(&i2c_client->dev,\r\n"Cirrus Logic CS35l34 (%x), Revision: %02X\n", devid,\r\nreg & 0xFF);\r\nregmap_update_bits(cs35l34->regmap, CS35L34_INT_MASK_1,\r\nCS35L34_M_CAL_ERR | CS35L34_M_ALIVE_ERR |\r\nCS35L34_M_AMP_SHORT | CS35L34_M_OTW |\r\nCS35L34_M_OTE, 0);\r\nregmap_update_bits(cs35l34->regmap, CS35L34_INT_MASK_3,\r\nCS35L34_M_BST_HIGH | CS35L34_M_LBST_SHORT, 0);\r\npm_runtime_set_autosuspend_delay(&i2c_client->dev, 100);\r\npm_runtime_use_autosuspend(&i2c_client->dev);\r\npm_runtime_set_active(&i2c_client->dev);\r\npm_runtime_enable(&i2c_client->dev);\r\nret = snd_soc_register_codec(&i2c_client->dev,\r\n&soc_codec_dev_cs35l34, &cs35l34_dai, 1);\r\nif (ret < 0) {\r\ndev_err(&i2c_client->dev,\r\n"%s: Register codec failed\n", __func__);\r\ngoto err_regulator;\r\n}\r\nreturn 0;\r\nerr_regulator:\r\nregulator_bulk_disable(cs35l34->num_core_supplies,\r\ncs35l34->core_supplies);\r\nreturn ret;\r\n}\r\nstatic int cs35l34_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct cs35l34_private *cs35l34 = i2c_get_clientdata(client);\r\nsnd_soc_unregister_codec(&client->dev);\r\nif (cs35l34->reset_gpio)\r\ngpiod_set_value_cansleep(cs35l34->reset_gpio, 0);\r\npm_runtime_disable(&client->dev);\r\nregulator_bulk_disable(cs35l34->num_core_supplies,\r\ncs35l34->core_supplies);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused cs35l34_runtime_resume(struct device *dev)\r\n{\r\nstruct cs35l34_private *cs35l34 = dev_get_drvdata(dev);\r\nint ret;\r\nret = regulator_bulk_enable(cs35l34->num_core_supplies,\r\ncs35l34->core_supplies);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to enable core supplies: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nregcache_cache_only(cs35l34->regmap, false);\r\ngpiod_set_value_cansleep(cs35l34->reset_gpio, 1);\r\nmsleep(CS35L34_START_DELAY);\r\nret = regcache_sync(cs35l34->regmap);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to restore register cache\n");\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nregcache_cache_only(cs35l34->regmap, true);\r\nregulator_bulk_disable(cs35l34->num_core_supplies,\r\ncs35l34->core_supplies);\r\nreturn ret;\r\n}\r\nstatic int __maybe_unused cs35l34_runtime_suspend(struct device *dev)\r\n{\r\nstruct cs35l34_private *cs35l34 = dev_get_drvdata(dev);\r\nregcache_cache_only(cs35l34->regmap, true);\r\nregcache_mark_dirty(cs35l34->regmap);\r\ngpiod_set_value_cansleep(cs35l34->reset_gpio, 0);\r\nregulator_bulk_disable(cs35l34->num_core_supplies,\r\ncs35l34->core_supplies);\r\nreturn 0;\r\n}\r\nstatic int __init cs35l34_modinit(void)\r\n{\r\nint ret;\r\nret = i2c_add_driver(&cs35l34_i2c_driver);\r\nif (ret != 0) {\r\npr_err("Failed to register CS35l34 I2C driver: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit cs35l34_exit(void)\r\n{\r\ni2c_del_driver(&cs35l34_i2c_driver);\r\n}
