static int lm3646_mode_ctrl(struct lm3646_flash *flash,\r\nenum v4l2_flash_led_mode led_mode)\r\n{\r\nswitch (led_mode) {\r\ncase V4L2_FLASH_LED_MODE_NONE:\r\nreturn regmap_write(flash->regmap,\r\nREG_ENABLE, flash->mode_reg | MODE_SHDN);\r\ncase V4L2_FLASH_LED_MODE_TORCH:\r\nreturn regmap_write(flash->regmap,\r\nREG_ENABLE, flash->mode_reg | MODE_TORCH);\r\ncase V4L2_FLASH_LED_MODE_FLASH:\r\nreturn regmap_write(flash->regmap,\r\nREG_ENABLE, flash->mode_reg | MODE_FLASH);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int lm3646_get_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct lm3646_flash *flash = to_lm3646_flash(ctrl);\r\nunsigned int reg_val;\r\nint rval;\r\nif (ctrl->id != V4L2_CID_FLASH_FAULT)\r\nreturn -EINVAL;\r\nrval = regmap_read(flash->regmap, REG_FLAG, &reg_val);\r\nif (rval < 0)\r\nreturn rval;\r\nctrl->val = 0;\r\nif (reg_val & FAULT_TIMEOUT)\r\nctrl->val |= V4L2_FLASH_FAULT_TIMEOUT;\r\nif (reg_val & FAULT_SHORT_CIRCUIT)\r\nctrl->val |= V4L2_FLASH_FAULT_SHORT_CIRCUIT;\r\nif (reg_val & FAULT_UVLO)\r\nctrl->val |= V4L2_FLASH_FAULT_UNDER_VOLTAGE;\r\nif (reg_val & FAULT_IVFM)\r\nctrl->val |= V4L2_FLASH_FAULT_INPUT_VOLTAGE;\r\nif (reg_val & FAULT_OCP)\r\nctrl->val |= V4L2_FLASH_FAULT_OVER_CURRENT;\r\nif (reg_val & FAULT_OVERTEMP)\r\nctrl->val |= V4L2_FLASH_FAULT_OVER_TEMPERATURE;\r\nif (reg_val & FAULT_NTC_TRIP)\r\nctrl->val |= V4L2_FLASH_FAULT_LED_OVER_TEMPERATURE;\r\nif (reg_val & FAULT_OVP)\r\nctrl->val |= V4L2_FLASH_FAULT_OVER_VOLTAGE;\r\nreturn 0;\r\n}\r\nstatic int lm3646_set_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct lm3646_flash *flash = to_lm3646_flash(ctrl);\r\nunsigned int reg_val;\r\nint rval = -EINVAL;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_FLASH_LED_MODE:\r\nif (ctrl->val != V4L2_FLASH_LED_MODE_FLASH)\r\nreturn lm3646_mode_ctrl(flash, ctrl->val);\r\nreturn lm3646_mode_ctrl(flash, V4L2_FLASH_LED_MODE_NONE);\r\ncase V4L2_CID_FLASH_STROBE_SOURCE:\r\nreturn regmap_update_bits(flash->regmap,\r\nREG_STROBE_SRC, MASK_STROBE_SRC,\r\n(ctrl->val) << 7);\r\ncase V4L2_CID_FLASH_STROBE:\r\nrval = regmap_read(flash->regmap, REG_ENABLE, &reg_val);\r\nif (rval < 0 || ((reg_val & MASK_ENABLE) != MODE_SHDN))\r\nreturn rval;\r\nreturn lm3646_mode_ctrl(flash, V4L2_FLASH_LED_MODE_FLASH);\r\ncase V4L2_CID_FLASH_STROBE_STOP:\r\nrval = regmap_read(flash->regmap, REG_ENABLE, &reg_val);\r\nif (rval < 0)\r\nreturn rval;\r\nif ((reg_val & MASK_ENABLE) == MODE_FLASH)\r\nreturn lm3646_mode_ctrl(flash,\r\nV4L2_FLASH_LED_MODE_NONE);\r\nreturn rval;\r\ncase V4L2_CID_FLASH_TIMEOUT:\r\nreturn regmap_update_bits(flash->regmap,\r\nREG_FLASH_TOUT, MASK_FLASH_TOUT,\r\nLM3646_FLASH_TOUT_ms_TO_REG\r\n(ctrl->val));\r\ncase V4L2_CID_FLASH_INTENSITY:\r\nreturn regmap_update_bits(flash->regmap,\r\nREG_FLASH_BR, MASK_FLASH_BR,\r\nLM3646_TOTAL_FLASH_BRT_uA_TO_REG\r\n(ctrl->val));\r\ncase V4L2_CID_FLASH_TORCH_INTENSITY:\r\nreturn regmap_update_bits(flash->regmap,\r\nREG_TORCH_BR, MASK_TORCH_BR,\r\nLM3646_TOTAL_TORCH_BRT_uA_TO_REG\r\n(ctrl->val) << 4);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int lm3646_init_controls(struct lm3646_flash *flash)\r\n{\r\nstruct v4l2_ctrl *fault;\r\nstruct v4l2_ctrl_handler *hdl = &flash->ctrls_led;\r\nconst struct v4l2_ctrl_ops *ops = &lm3646_led_ctrl_ops;\r\nv4l2_ctrl_handler_init(hdl, 8);\r\nv4l2_ctrl_new_std_menu(hdl, ops, V4L2_CID_FLASH_LED_MODE,\r\nV4L2_FLASH_LED_MODE_TORCH, ~0x7,\r\nV4L2_FLASH_LED_MODE_NONE);\r\nv4l2_ctrl_new_std_menu(hdl, ops, V4L2_CID_FLASH_STROBE_SOURCE,\r\n0x1, ~0x3, V4L2_FLASH_STROBE_SOURCE_SOFTWARE);\r\nv4l2_ctrl_new_std(hdl, ops, V4L2_CID_FLASH_STROBE, 0, 0, 0, 0);\r\nv4l2_ctrl_new_std(hdl, ops, V4L2_CID_FLASH_STROBE_STOP, 0, 0, 0, 0);\r\nv4l2_ctrl_new_std(hdl, ops, V4L2_CID_FLASH_TIMEOUT,\r\nLM3646_FLASH_TOUT_MIN,\r\nLM3646_FLASH_TOUT_MAX,\r\nLM3646_FLASH_TOUT_STEP, flash->pdata->flash_timeout);\r\nv4l2_ctrl_new_std(hdl, ops, V4L2_CID_FLASH_INTENSITY,\r\nLM3646_TOTAL_FLASH_BRT_MIN,\r\nLM3646_TOTAL_FLASH_BRT_MAX,\r\nLM3646_TOTAL_FLASH_BRT_STEP,\r\nLM3646_TOTAL_FLASH_BRT_MAX);\r\nv4l2_ctrl_new_std(hdl, ops, V4L2_CID_FLASH_TORCH_INTENSITY,\r\nLM3646_TOTAL_TORCH_BRT_MIN,\r\nLM3646_TOTAL_TORCH_BRT_MAX,\r\nLM3646_TOTAL_TORCH_BRT_STEP,\r\nLM3646_TOTAL_TORCH_BRT_MAX);\r\nfault = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_FLASH_FAULT, 0,\r\nV4L2_FLASH_FAULT_OVER_VOLTAGE\r\n| V4L2_FLASH_FAULT_OVER_TEMPERATURE\r\n| V4L2_FLASH_FAULT_SHORT_CIRCUIT\r\n| V4L2_FLASH_FAULT_TIMEOUT, 0, 0);\r\nif (fault != NULL)\r\nfault->flags |= V4L2_CTRL_FLAG_VOLATILE;\r\nif (hdl->error)\r\nreturn hdl->error;\r\nflash->subdev_led.ctrl_handler = hdl;\r\nreturn 0;\r\n}\r\nstatic int lm3646_subdev_init(struct lm3646_flash *flash)\r\n{\r\nstruct i2c_client *client = to_i2c_client(flash->dev);\r\nint rval;\r\nv4l2_i2c_subdev_init(&flash->subdev_led, client, &lm3646_ops);\r\nflash->subdev_led.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nstrcpy(flash->subdev_led.name, LM3646_NAME);\r\nrval = lm3646_init_controls(flash);\r\nif (rval)\r\ngoto err_out;\r\nrval = media_entity_pads_init(&flash->subdev_led.entity, 0, NULL);\r\nif (rval < 0)\r\ngoto err_out;\r\nflash->subdev_led.entity.function = MEDIA_ENT_F_FLASH;\r\nreturn rval;\r\nerr_out:\r\nv4l2_ctrl_handler_free(&flash->ctrls_led);\r\nreturn rval;\r\n}\r\nstatic int lm3646_init_device(struct lm3646_flash *flash)\r\n{\r\nunsigned int reg_val;\r\nint rval;\r\nrval = regmap_read(flash->regmap, REG_ENABLE, &reg_val);\r\nif (rval < 0)\r\nreturn rval;\r\nflash->mode_reg = reg_val & 0xfc;\r\nrval = lm3646_mode_ctrl(flash, V4L2_FLASH_LED_MODE_NONE);\r\nif (rval < 0)\r\nreturn rval;\r\nrval = regmap_update_bits(flash->regmap,\r\nREG_LED1_FLASH_BR, 0x7F,\r\nLM3646_LED1_FLASH_BRT_uA_TO_REG\r\n(flash->pdata->led1_flash_brt));\r\nif (rval < 0)\r\nreturn rval;\r\nrval = regmap_update_bits(flash->regmap,\r\nREG_LED1_TORCH_BR, 0x7F,\r\nLM3646_LED1_TORCH_BRT_uA_TO_REG\r\n(flash->pdata->led1_torch_brt));\r\nif (rval < 0)\r\nreturn rval;\r\nreturn regmap_read(flash->regmap, REG_FLAG, &reg_val);\r\n}\r\nstatic int lm3646_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *devid)\r\n{\r\nstruct lm3646_flash *flash;\r\nstruct lm3646_platform_data *pdata = dev_get_platdata(&client->dev);\r\nint rval;\r\nflash = devm_kzalloc(&client->dev, sizeof(*flash), GFP_KERNEL);\r\nif (flash == NULL)\r\nreturn -ENOMEM;\r\nflash->regmap = devm_regmap_init_i2c(client, &lm3646_regmap);\r\nif (IS_ERR(flash->regmap))\r\nreturn PTR_ERR(flash->regmap);\r\nif (pdata == NULL) {\r\npdata = devm_kzalloc(&client->dev,\r\nsizeof(struct lm3646_platform_data),\r\nGFP_KERNEL);\r\nif (pdata == NULL)\r\nreturn -ENOMEM;\r\npdata->flash_timeout = LM3646_FLASH_TOUT_MAX;\r\npdata->led1_torch_brt = LM3646_LED1_TORCH_BRT_MAX;\r\npdata->led1_flash_brt = LM3646_LED1_FLASH_BRT_MAX;\r\n}\r\nflash->pdata = pdata;\r\nflash->dev = &client->dev;\r\nrval = lm3646_subdev_init(flash);\r\nif (rval < 0)\r\nreturn rval;\r\nrval = lm3646_init_device(flash);\r\nif (rval < 0)\r\nreturn rval;\r\ni2c_set_clientdata(client, flash);\r\nreturn 0;\r\n}\r\nstatic int lm3646_remove(struct i2c_client *client)\r\n{\r\nstruct lm3646_flash *flash = i2c_get_clientdata(client);\r\nv4l2_device_unregister_subdev(&flash->subdev_led);\r\nv4l2_ctrl_handler_free(&flash->ctrls_led);\r\nmedia_entity_cleanup(&flash->subdev_led.entity);\r\nreturn 0;\r\n}
