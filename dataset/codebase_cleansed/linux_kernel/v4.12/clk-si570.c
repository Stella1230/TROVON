static int si570_get_divs(struct clk_si570 *data, u64 *rfreq,\r\nunsigned int *n1, unsigned int *hs_div)\r\n{\r\nint err;\r\nu8 reg[6];\r\nu64 tmp;\r\nerr = regmap_bulk_read(data->regmap, SI570_REG_HS_N1 + data->div_offset,\r\nreg, ARRAY_SIZE(reg));\r\nif (err)\r\nreturn err;\r\n*hs_div = ((reg[0] & HS_DIV_MASK) >> HS_DIV_SHIFT) + HS_DIV_OFFSET;\r\n*n1 = ((reg[0] & N1_6_2_MASK) << 2) + ((reg[1] & N1_1_0_MASK) >> 6) + 1;\r\nif (*n1 > 1)\r\n*n1 &= ~1;\r\ntmp = reg[1] & RFREQ_37_32_MASK;\r\ntmp = (tmp << 8) + reg[2];\r\ntmp = (tmp << 8) + reg[3];\r\ntmp = (tmp << 8) + reg[4];\r\ntmp = (tmp << 8) + reg[5];\r\n*rfreq = tmp;\r\nreturn 0;\r\n}\r\nstatic int si570_get_defaults(struct clk_si570 *data, u64 fout)\r\n{\r\nint err;\r\nu64 fdco;\r\nregmap_write(data->regmap, SI570_REG_CONTROL, SI570_CNTRL_RECALL);\r\nerr = si570_get_divs(data, &data->rfreq, &data->n1, &data->hs_div);\r\nif (err)\r\nreturn err;\r\nfdco = fout * data->n1 * data->hs_div;\r\nif (fdco >= (1LL << 36))\r\ndata->fxtal = div64_u64(fdco << 24, data->rfreq >> 4);\r\nelse\r\ndata->fxtal = div64_u64(fdco << 28, data->rfreq);\r\ndata->frequency = fout;\r\nreturn 0;\r\n}\r\nstatic int si570_update_rfreq(struct clk_si570 *data)\r\n{\r\nu8 reg[5];\r\nreg[0] = ((data->n1 - 1) << 6) |\r\n((data->rfreq >> 32) & RFREQ_37_32_MASK);\r\nreg[1] = (data->rfreq >> 24) & 0xff;\r\nreg[2] = (data->rfreq >> 16) & 0xff;\r\nreg[3] = (data->rfreq >> 8) & 0xff;\r\nreg[4] = data->rfreq & 0xff;\r\nreturn regmap_bulk_write(data->regmap, SI570_REG_N1_RFREQ0 +\r\ndata->div_offset, reg, ARRAY_SIZE(reg));\r\n}\r\nstatic int si570_calc_divs(unsigned long frequency, struct clk_si570 *data,\r\nu64 *out_rfreq, unsigned int *out_n1, unsigned int *out_hs_div)\r\n{\r\nint i;\r\nunsigned int n1, hs_div;\r\nu64 fdco, best_fdco = ULLONG_MAX;\r\nstatic const uint8_t si570_hs_div_values[] = { 11, 9, 7, 6, 5, 4 };\r\nfor (i = 0; i < ARRAY_SIZE(si570_hs_div_values); i++) {\r\nhs_div = si570_hs_div_values[i];\r\nn1 = div_u64(div_u64(FDCO_MIN, hs_div), frequency);\r\nif (!n1 || (n1 & 1))\r\nn1++;\r\nwhile (n1 <= 128) {\r\nfdco = (u64)frequency * (u64)hs_div * (u64)n1;\r\nif (fdco > FDCO_MAX)\r\nbreak;\r\nif (fdco >= FDCO_MIN && fdco < best_fdco) {\r\n*out_n1 = n1;\r\n*out_hs_div = hs_div;\r\n*out_rfreq = div64_u64(fdco << 28, data->fxtal);\r\nbest_fdco = fdco;\r\n}\r\nn1 += (n1 == 1 ? 1 : 2);\r\n}\r\n}\r\nif (best_fdco == ULLONG_MAX)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic unsigned long si570_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nint err;\r\nu64 rfreq, rate;\r\nunsigned int n1, hs_div;\r\nstruct clk_si570 *data = to_clk_si570(hw);\r\nerr = si570_get_divs(data, &rfreq, &n1, &hs_div);\r\nif (err) {\r\ndev_err(&data->i2c_client->dev, "unable to recalc rate\n");\r\nreturn data->frequency;\r\n}\r\nrfreq = div_u64(rfreq, hs_div * n1);\r\nrate = (data->fxtal * rfreq) >> 28;\r\nreturn rate;\r\n}\r\nstatic long si570_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nint err;\r\nu64 rfreq;\r\nunsigned int n1, hs_div;\r\nstruct clk_si570 *data = to_clk_si570(hw);\r\nif (!rate)\r\nreturn 0;\r\nif (div64_u64(abs(rate - data->frequency) * 10000LL,\r\ndata->frequency) < 35) {\r\nrfreq = div64_u64((data->rfreq * rate) +\r\ndiv64_u64(data->frequency, 2), data->frequency);\r\nn1 = data->n1;\r\nhs_div = data->hs_div;\r\n} else {\r\nerr = si570_calc_divs(rate, data, &rfreq, &n1, &hs_div);\r\nif (err) {\r\ndev_err(&data->i2c_client->dev,\r\n"unable to round rate\n");\r\nreturn 0;\r\n}\r\n}\r\nreturn rate;\r\n}\r\nstatic int si570_set_frequency(struct clk_si570 *data, unsigned long frequency)\r\n{\r\nint err;\r\nerr = si570_calc_divs(frequency, data, &data->rfreq, &data->n1,\r\n&data->hs_div);\r\nif (err)\r\nreturn err;\r\nregmap_write(data->regmap, SI570_REG_FREEZE_DCO, SI570_FREEZE_DCO);\r\nregmap_write(data->regmap, SI570_REG_HS_N1 + data->div_offset,\r\n((data->hs_div - HS_DIV_OFFSET) << HS_DIV_SHIFT) |\r\n(((data->n1 - 1) >> 2) & N1_6_2_MASK));\r\nsi570_update_rfreq(data);\r\nregmap_write(data->regmap, SI570_REG_FREEZE_DCO, 0);\r\nregmap_write(data->regmap, SI570_REG_CONTROL, SI570_CNTRL_NEWFREQ);\r\nusleep_range(10000, 12000);\r\nreturn 0;\r\n}\r\nstatic int si570_set_frequency_small(struct clk_si570 *data,\r\nunsigned long frequency)\r\n{\r\ndata->rfreq = div64_u64((data->rfreq * frequency) +\r\ndiv_u64(data->frequency, 2), data->frequency);\r\nregmap_write(data->regmap, SI570_REG_CONTROL, SI570_CNTRL_FREEZE_M);\r\nsi570_update_rfreq(data);\r\nregmap_write(data->regmap, SI570_REG_CONTROL, 0);\r\nusleep_range(100, 200);\r\nreturn 0;\r\n}\r\nstatic int si570_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_si570 *data = to_clk_si570(hw);\r\nstruct i2c_client *client = data->i2c_client;\r\nint err;\r\nif (rate < SI570_MIN_FREQ || rate > data->max_freq) {\r\ndev_err(&client->dev,\r\n"requested frequency %lu Hz is out of range\n", rate);\r\nreturn -EINVAL;\r\n}\r\nif (div64_u64(abs(rate - data->frequency) * 10000LL,\r\ndata->frequency) < 35)\r\nerr = si570_set_frequency_small(data, rate);\r\nelse\r\nerr = si570_set_frequency(data, rate);\r\nif (err)\r\nreturn err;\r\ndata->frequency = rate;\r\nreturn 0;\r\n}\r\nstatic bool si570_regmap_is_volatile(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase SI570_REG_CONTROL:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool si570_regmap_is_writeable(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase SI570_REG_HS_N1 ... (SI570_REG_RFREQ4 + SI570_DIV_OFFSET_7PPM):\r\ncase SI570_REG_CONTROL:\r\ncase SI570_REG_FREEZE_DCO:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int si570_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct clk_si570 *data;\r\nstruct clk_init_data init;\r\nu32 initial_fout, factory_fout, stability;\r\nint err;\r\nenum clk_si570_variant variant = id->driver_data;\r\ndata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ninit.ops = &si570_clk_ops;\r\ninit.flags = 0;\r\ninit.num_parents = 0;\r\ndata->hw.init = &init;\r\ndata->i2c_client = client;\r\nif (variant == si57x) {\r\nerr = of_property_read_u32(client->dev.of_node,\r\n"temperature-stability", &stability);\r\nif (err) {\r\ndev_err(&client->dev,\r\n"'temperature-stability' property missing\n");\r\nreturn err;\r\n}\r\nif (stability == 7)\r\ndata->div_offset = SI570_DIV_OFFSET_7PPM;\r\ndata->max_freq = SI570_MAX_FREQ;\r\n} else {\r\ndata->max_freq = SI598_MAX_FREQ;\r\n}\r\nif (of_property_read_string(client->dev.of_node, "clock-output-names",\r\n&init.name))\r\ninit.name = client->dev.of_node->name;\r\nerr = of_property_read_u32(client->dev.of_node, "factory-fout",\r\n&factory_fout);\r\nif (err) {\r\ndev_err(&client->dev, "'factory-fout' property missing\n");\r\nreturn err;\r\n}\r\ndata->regmap = devm_regmap_init_i2c(client, &si570_regmap_config);\r\nif (IS_ERR(data->regmap)) {\r\ndev_err(&client->dev, "failed to allocate register map\n");\r\nreturn PTR_ERR(data->regmap);\r\n}\r\ni2c_set_clientdata(client, data);\r\nerr = si570_get_defaults(data, factory_fout);\r\nif (err)\r\nreturn err;\r\nerr = devm_clk_hw_register(&client->dev, &data->hw);\r\nif (err) {\r\ndev_err(&client->dev, "clock registration failed\n");\r\nreturn err;\r\n}\r\nerr = of_clk_add_hw_provider(client->dev.of_node, of_clk_hw_simple_get,\r\n&data->hw);\r\nif (err) {\r\ndev_err(&client->dev, "unable to add clk provider\n");\r\nreturn err;\r\n}\r\nif (!of_property_read_u32(client->dev.of_node, "clock-frequency",\r\n&initial_fout)) {\r\nerr = clk_set_rate(data->hw.clk, initial_fout);\r\nif (err) {\r\nof_clk_del_provider(client->dev.of_node);\r\nreturn err;\r\n}\r\n}\r\ndev_info(&client->dev, "registered, current frequency %llu Hz\n",\r\ndata->frequency);\r\nreturn 0;\r\n}\r\nstatic int si570_remove(struct i2c_client *client)\r\n{\r\nof_clk_del_provider(client->dev.of_node);\r\nreturn 0;\r\n}
