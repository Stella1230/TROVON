static void ivtv_stream_init(struct ivtv *itv, int type)\r\n{\r\nstruct ivtv_stream *s = &itv->streams[type];\r\nmemset(s, 0, sizeof(*s));\r\ns->itv = itv;\r\ns->type = type;\r\ns->name = ivtv_stream_info[type].name;\r\ns->caps = ivtv_stream_info[type].v4l2_caps;\r\nif (ivtv_stream_info[type].pio)\r\ns->dma = PCI_DMA_NONE;\r\nelse\r\ns->dma = ivtv_stream_info[type].dma;\r\ns->buf_size = itv->stream_buf_size[type];\r\nif (s->buf_size)\r\ns->buffers = (itv->options.kilobytes[type] * 1024 + s->buf_size - 1) / s->buf_size;\r\nspin_lock_init(&s->qlock);\r\ninit_waitqueue_head(&s->waitq);\r\ns->sg_handle = IVTV_DMA_UNMAPPED;\r\nivtv_queue_init(&s->q_free);\r\nivtv_queue_init(&s->q_full);\r\nivtv_queue_init(&s->q_dma);\r\nivtv_queue_init(&s->q_predma);\r\nivtv_queue_init(&s->q_io);\r\n}\r\nstatic int ivtv_prep_dev(struct ivtv *itv, int type)\r\n{\r\nstruct ivtv_stream *s = &itv->streams[type];\r\nint num_offset = ivtv_stream_info[type].num_offset;\r\nint num = itv->instance + ivtv_first_minor + num_offset;\r\ns->vdev.v4l2_dev = NULL;\r\ns->itv = itv;\r\ns->type = type;\r\ns->name = ivtv_stream_info[type].name;\r\nif (type == IVTV_ENC_STREAM_TYPE_RAD && !(itv->v4l2_cap & V4L2_CAP_RADIO))\r\nreturn 0;\r\nif (type >= IVTV_DEC_STREAM_TYPE_MPG && !(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT))\r\nreturn 0;\r\nif (ivtv_stream_info[type].dma != PCI_DMA_NONE &&\r\nitv->options.kilobytes[type] == 0) {\r\nIVTV_INFO("Disabled %s device\n", ivtv_stream_info[type].name);\r\nreturn 0;\r\n}\r\nivtv_stream_init(itv, type);\r\nsnprintf(s->vdev.name, sizeof(s->vdev.name), "%s %s",\r\nitv->v4l2_dev.name, s->name);\r\ns->vdev.num = num;\r\ns->vdev.v4l2_dev = &itv->v4l2_dev;\r\nif (ivtv_stream_info[type].v4l2_caps &\r\n(V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_SLICED_VBI_OUTPUT))\r\ns->vdev.vfl_dir = VFL_DIR_TX;\r\ns->vdev.fops = ivtv_stream_info[type].fops;\r\ns->vdev.ctrl_handler = itv->v4l2_dev.ctrl_handler;\r\ns->vdev.release = video_device_release_empty;\r\ns->vdev.tvnorms = V4L2_STD_ALL;\r\ns->vdev.lock = &itv->serialize_lock;\r\nif (s->type == IVTV_DEC_STREAM_TYPE_VBI) {\r\nv4l2_disable_ioctl(&s->vdev, VIDIOC_S_AUDIO);\r\nv4l2_disable_ioctl(&s->vdev, VIDIOC_G_AUDIO);\r\nv4l2_disable_ioctl(&s->vdev, VIDIOC_ENUMAUDIO);\r\nv4l2_disable_ioctl(&s->vdev, VIDIOC_ENUMINPUT);\r\nv4l2_disable_ioctl(&s->vdev, VIDIOC_S_INPUT);\r\nv4l2_disable_ioctl(&s->vdev, VIDIOC_G_INPUT);\r\nv4l2_disable_ioctl(&s->vdev, VIDIOC_S_FREQUENCY);\r\nv4l2_disable_ioctl(&s->vdev, VIDIOC_G_FREQUENCY);\r\nv4l2_disable_ioctl(&s->vdev, VIDIOC_S_TUNER);\r\nv4l2_disable_ioctl(&s->vdev, VIDIOC_G_TUNER);\r\nv4l2_disable_ioctl(&s->vdev, VIDIOC_S_STD);\r\n}\r\nivtv_set_funcs(&s->vdev);\r\nreturn 0;\r\n}\r\nint ivtv_streams_setup(struct ivtv *itv)\r\n{\r\nint type;\r\nfor (type = 0; type < IVTV_MAX_STREAMS; type++) {\r\nif (ivtv_prep_dev(itv, type))\r\nbreak;\r\nif (itv->streams[type].vdev.v4l2_dev == NULL)\r\ncontinue;\r\nif (ivtv_stream_alloc(&itv->streams[type]))\r\nbreak;\r\n}\r\nif (type == IVTV_MAX_STREAMS)\r\nreturn 0;\r\nivtv_streams_cleanup(itv);\r\nreturn -ENOMEM;\r\n}\r\nstatic int ivtv_reg_dev(struct ivtv *itv, int type)\r\n{\r\nstruct ivtv_stream *s = &itv->streams[type];\r\nint vfl_type = ivtv_stream_info[type].vfl_type;\r\nconst char *name;\r\nint num;\r\nif (s->vdev.v4l2_dev == NULL)\r\nreturn 0;\r\nnum = s->vdev.num;\r\nif (type != IVTV_ENC_STREAM_TYPE_MPG) {\r\nstruct ivtv_stream *s_mpg = &itv->streams[IVTV_ENC_STREAM_TYPE_MPG];\r\nif (s_mpg->vdev.v4l2_dev)\r\nnum = s_mpg->vdev.num + ivtv_stream_info[type].num_offset;\r\n}\r\nvideo_set_drvdata(&s->vdev, s);\r\nif (video_register_device_no_warn(&s->vdev, vfl_type, num)) {\r\nIVTV_ERR("Couldn't register v4l2 device for %s (device node number %d)\n",\r\ns->name, num);\r\nreturn -ENOMEM;\r\n}\r\nname = video_device_node_name(&s->vdev);\r\nswitch (vfl_type) {\r\ncase VFL_TYPE_GRABBER:\r\nIVTV_INFO("Registered device %s for %s (%d kB)\n",\r\nname, s->name, itv->options.kilobytes[type]);\r\nbreak;\r\ncase VFL_TYPE_RADIO:\r\nIVTV_INFO("Registered device %s for %s\n",\r\nname, s->name);\r\nbreak;\r\ncase VFL_TYPE_VBI:\r\nif (itv->options.kilobytes[type])\r\nIVTV_INFO("Registered device %s for %s (%d kB)\n",\r\nname, s->name, itv->options.kilobytes[type]);\r\nelse\r\nIVTV_INFO("Registered device %s for %s\n",\r\nname, s->name);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint ivtv_streams_register(struct ivtv *itv)\r\n{\r\nint type;\r\nint err = 0;\r\nfor (type = 0; type < IVTV_MAX_STREAMS; type++)\r\nerr |= ivtv_reg_dev(itv, type);\r\nif (err == 0)\r\nreturn 0;\r\nivtv_streams_cleanup(itv);\r\nreturn -ENOMEM;\r\n}\r\nvoid ivtv_streams_cleanup(struct ivtv *itv)\r\n{\r\nint type;\r\nfor (type = 0; type < IVTV_MAX_STREAMS; type++) {\r\nstruct video_device *vdev = &itv->streams[type].vdev;\r\nif (vdev->v4l2_dev == NULL)\r\ncontinue;\r\nvideo_unregister_device(vdev);\r\nivtv_stream_free(&itv->streams[type]);\r\nitv->streams[type].vdev.v4l2_dev = NULL;\r\n}\r\n}\r\nstatic void ivtv_vbi_setup(struct ivtv *itv)\r\n{\r\nint raw = ivtv_raw_vbi(itv);\r\nu32 data[CX2341X_MBOX_MAX_DATA];\r\nint lines;\r\nint i;\r\nivtv_vapi(itv, CX2341X_ENC_SET_VBI_LINE, 5, 0xffff , 0, 0, 0, 0);\r\nif (raw)\r\nv4l2_subdev_call(itv->sd_video, vbi, s_raw_fmt, &itv->vbi.in.fmt.vbi);\r\nelse\r\nv4l2_subdev_call(itv->sd_video, vbi, s_sliced_fmt, &itv->vbi.in.fmt.sliced);\r\nif (raw) {\r\nlines = itv->vbi.count * 2;\r\n} else {\r\nlines = itv->is_60hz ? 24 : 38;\r\nif (itv->is_60hz && (itv->hw_flags & IVTV_HW_CX25840))\r\nlines += 2;\r\n}\r\nitv->vbi.enc_size = lines * (raw ? itv->vbi.raw_size : itv->vbi.sliced_size);\r\ndata[0] = raw | 0x02 | (0xbd << 8);\r\ndata[1] = 1;\r\ndata[2] = raw ? 4 : 4 * (itv->vbi.raw_size / itv->vbi.enc_size);\r\nif (itv->hw_flags & IVTV_HW_CX25840) {\r\nif (raw) {\r\ndata[3] = 0x20602060;\r\ndata[4] = 0x30703070;\r\n} else {\r\ndata[3] = 0xB0F0B0F0;\r\ndata[4] = 0xA0E0A0E0;\r\n}\r\ndata[5] = lines;\r\ndata[6] = (raw ? itv->vbi.raw_size : itv->vbi.sliced_size);\r\n} else {\r\nif (raw) {\r\ndata[3] = 0x25256262;\r\ndata[4] = 0x387F7F7F;\r\n} else {\r\ndata[3] = 0xABABECEC;\r\ndata[4] = 0xB6F1F1F1;\r\n}\r\ndata[5] = lines;\r\ndata[6] = itv->vbi.enc_size / lines;\r\n}\r\nIVTV_DEBUG_INFO(\r\n"Setup VBI API header 0x%08x pkts %d buffs %d ln %d sz %d\n",\r\ndata[0], data[1], data[2], data[5], data[6]);\r\nivtv_api(itv, CX2341X_ENC_SET_VBI_CONFIG, 7, data);\r\nitv->vbi.enc_start = data[2];\r\nitv->vbi.fpi = data[0];\r\nif (!itv->vbi.fpi)\r\nitv->vbi.fpi = 1;\r\nIVTV_DEBUG_INFO("Setup VBI start 0x%08x frames %d fpi %d\n",\r\nitv->vbi.enc_start, data[1], itv->vbi.fpi);\r\nfor (i = 2; i <= 24; i++) {\r\nint valid;\r\nif (itv->is_60hz) {\r\nvalid = i >= 10 && i < 22;\r\n} else {\r\nvalid = i >= 6 && i < 24;\r\n}\r\nivtv_vapi(itv, CX2341X_ENC_SET_VBI_LINE, 5, i - 1,\r\nvalid, 0 , 0, 0);\r\nivtv_vapi(itv, CX2341X_ENC_SET_VBI_LINE, 5, (i - 1) | 0x80000000,\r\nvalid, 0, 0, 0);\r\n}\r\n}\r\nint ivtv_start_v4l2_encode_stream(struct ivtv_stream *s)\r\n{\r\nu32 data[CX2341X_MBOX_MAX_DATA];\r\nstruct ivtv *itv = s->itv;\r\nint captype = 0, subtype = 0;\r\nint enable_passthrough = 0;\r\nif (s->vdev.v4l2_dev == NULL)\r\nreturn -EINVAL;\r\nIVTV_DEBUG_INFO("Start encoder stream %s\n", s->name);\r\nswitch (s->type) {\r\ncase IVTV_ENC_STREAM_TYPE_MPG:\r\ncaptype = 0;\r\nsubtype = 3;\r\nif (itv->output_mode == OUT_PASSTHROUGH) {\r\nivtv_passthrough_mode(itv, 0);\r\nenable_passthrough = 1;\r\n}\r\nitv->mpg_data_received = itv->vbi_data_inserted = 0;\r\nitv->dualwatch_jiffies = jiffies;\r\nitv->dualwatch_stereo_mode = v4l2_ctrl_g_ctrl(itv->cxhdl.audio_mode);\r\nitv->search_pack_header = 0;\r\nbreak;\r\ncase IVTV_ENC_STREAM_TYPE_YUV:\r\nif (itv->output_mode == OUT_PASSTHROUGH) {\r\ncaptype = 2;\r\nsubtype = 11;\r\nbreak;\r\n}\r\ncaptype = 1;\r\nsubtype = 1;\r\nbreak;\r\ncase IVTV_ENC_STREAM_TYPE_PCM:\r\ncaptype = 1;\r\nsubtype = 2;\r\nbreak;\r\ncase IVTV_ENC_STREAM_TYPE_VBI:\r\ncaptype = 1;\r\nsubtype = 4;\r\nitv->vbi.frame = 0;\r\nitv->vbi.inserted_frame = 0;\r\nmemset(itv->vbi.sliced_mpeg_size,\r\n0, sizeof(itv->vbi.sliced_mpeg_size));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ns->subtype = subtype;\r\ns->buffers_stolen = 0;\r\nclear_bit(IVTV_F_S_STREAMOFF, &s->s_flags);\r\nif (atomic_read(&itv->capturing) == 0) {\r\nint digitizer;\r\nivtv_vapi(itv, CX2341X_ENC_SET_DMA_BLOCK_SIZE, 2, 1, 1);\r\nivtv_vapi(itv, CX2341X_ENC_SET_VERT_CROP_LINE, 1, 0);\r\nivtv_vapi(itv, CX2341X_ENC_MISC, 2, 3, !itv->has_cx23415);\r\nivtv_vapi(itv, CX2341X_ENC_MISC, 2, 8, 0);\r\nivtv_vapi(itv, CX2341X_ENC_MISC, 2, 4, 1);\r\nivtv_vapi(itv, CX2341X_ENC_MISC, 1, 12);\r\nivtv_vapi(itv, CX2341X_ENC_SET_PLACEHOLDER, 12,\r\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\r\nif (itv->card->hw_all & (IVTV_HW_SAA7115 | IVTV_HW_SAA717X))\r\ndigitizer = 0xF1;\r\nelse if (itv->card->hw_all & IVTV_HW_SAA7114)\r\ndigitizer = 0xEF;\r\nelse\r\ndigitizer = 0x140;\r\nivtv_vapi(itv, CX2341X_ENC_SET_NUM_VSYNC_LINES, 2, digitizer, digitizer);\r\nif (itv->v4l2_cap & V4L2_CAP_VBI_CAPTURE) {\r\nivtv_vbi_setup(itv);\r\n}\r\nivtv_vapi_result(itv, data, CX2341X_ENC_SET_PGM_INDEX_INFO, 2, 7, 400);\r\nitv->pgm_info_offset = data[0];\r\nitv->pgm_info_num = data[1];\r\nitv->pgm_info_write_idx = 0;\r\nitv->pgm_info_read_idx = 0;\r\nIVTV_DEBUG_INFO("PGM Index at 0x%08x with %d elements\n",\r\nitv->pgm_info_offset, itv->pgm_info_num);\r\ncx2341x_handler_setup(&itv->cxhdl);\r\nif (test_bit(IVTV_F_I_RADIO_USER, &itv->i_flags))\r\nivtv_vapi(itv, CX2341X_ENC_MUTE_VIDEO, 1,\r\n1 | (v4l2_ctrl_g_ctrl(itv->cxhdl.video_mute_yuv) << 8));\r\n}\r\nif (itv->has_cx23415 && !test_and_set_bit(IVTV_F_I_DIG_RST, &itv->i_flags)) {\r\nivtv_vapi(itv, CX2341X_ENC_SET_EVENT_NOTIFICATION, 4, 0, 1, IVTV_IRQ_ENC_VIM_RST, -1);\r\nivtv_clear_irq_mask(itv, IVTV_IRQ_ENC_VIM_RST);\r\n}\r\nif (atomic_read(&itv->capturing) == 0) {\r\nivtv_set_irq_mask(itv, IVTV_IRQ_MASK_CAPTURE);\r\nclear_bit(IVTV_F_I_EOS, &itv->i_flags);\r\ncx2341x_handler_set_busy(&itv->cxhdl, 1);\r\nv4l2_subdev_call(itv->sd_audio, audio, s_stream, 1);\r\nv4l2_subdev_call(itv->sd_video, video, s_stream, 0);\r\nivtv_msleep_timeout(300, 0);\r\nivtv_vapi(itv, CX2341X_ENC_INITIALIZE_INPUT, 0);\r\nv4l2_subdev_call(itv->sd_video, video, s_stream, 1);\r\n}\r\nif (ivtv_vapi(itv, CX2341X_ENC_START_CAPTURE, 2, captype, subtype))\r\n{\r\nIVTV_DEBUG_WARN( "Error starting capture!\n");\r\nreturn -EINVAL;\r\n}\r\nif (enable_passthrough) {\r\nivtv_passthrough_mode(itv, 1);\r\n}\r\nif (s->type == IVTV_ENC_STREAM_TYPE_VBI)\r\nivtv_clear_irq_mask(itv, IVTV_IRQ_ENC_VBI_CAP);\r\nelse\r\nivtv_clear_irq_mask(itv, IVTV_IRQ_MASK_CAPTURE);\r\natomic_inc(&itv->capturing);\r\nreturn 0;\r\n}\r\nstatic int ivtv_setup_v4l2_decode_stream(struct ivtv_stream *s)\r\n{\r\nu32 data[CX2341X_MBOX_MAX_DATA];\r\nstruct ivtv *itv = s->itv;\r\nint datatype;\r\nu16 width;\r\nu16 height;\r\nif (s->vdev.v4l2_dev == NULL)\r\nreturn -EINVAL;\r\nIVTV_DEBUG_INFO("Setting some initial decoder settings\n");\r\nwidth = itv->cxhdl.width;\r\nheight = itv->cxhdl.height;\r\nivtv_vapi(itv, CX2341X_DEC_SET_AUDIO_MODE, 2, itv->audio_bilingual_mode, itv->audio_stereo_mode);\r\nivtv_vapi(itv, CX2341X_DEC_SET_DISPLAY_BUFFERS, 1, 0);\r\nivtv_vapi(itv, CX2341X_DEC_SET_PREBUFFERING, 1, 1);\r\nivtv_vapi_result(itv, data, CX2341X_DEC_EXTRACT_VBI, 1, 1);\r\nitv->vbi.dec_start = data[0];\r\nIVTV_DEBUG_INFO("Decoder VBI RE-Insert start 0x%08x size 0x%08x\n",\r\nitv->vbi.dec_start, data[1]);\r\nswitch (s->type) {\r\ncase IVTV_DEC_STREAM_TYPE_YUV:\r\nif (itv->output_mode == OUT_PASSTHROUGH) {\r\ndatatype = 1;\r\n} else {\r\ndatatype = 2;\r\nwidth = 720;\r\nheight = itv->is_out_50hz ? 576 : 480;\r\n}\r\nIVTV_DEBUG_INFO("Setup DEC YUV Stream data[0] = %d\n", datatype);\r\nbreak;\r\ncase IVTV_DEC_STREAM_TYPE_MPG:\r\ndefault:\r\ndatatype = 0;\r\nbreak;\r\n}\r\nif (ivtv_vapi(itv, CX2341X_DEC_SET_DECODER_SOURCE, 4, datatype,\r\nwidth, height, itv->cxhdl.audio_properties)) {\r\nIVTV_DEBUG_WARN("Couldn't initialize decoder source\n");\r\n}\r\nivtv_msleep_timeout(10, 0);\r\nreturn ivtv_firmware_check(itv, "ivtv_setup_v4l2_decode_stream");\r\n}\r\nint ivtv_start_v4l2_decode_stream(struct ivtv_stream *s, int gop_offset)\r\n{\r\nstruct ivtv *itv = s->itv;\r\nint rc;\r\nif (s->vdev.v4l2_dev == NULL)\r\nreturn -EINVAL;\r\nif (test_and_set_bit(IVTV_F_S_STREAMING, &s->s_flags))\r\nreturn 0;\r\nIVTV_DEBUG_INFO("Starting decode stream %s (gop_offset %d)\n", s->name, gop_offset);\r\nrc = ivtv_setup_v4l2_decode_stream(s);\r\nif (rc < 0) {\r\nclear_bit(IVTV_F_S_STREAMING, &s->s_flags);\r\nreturn rc;\r\n}\r\nivtv_vapi(itv, CX2341X_DEC_SET_DMA_BLOCK_SIZE, 1, 65536);\r\nclear_bit(IVTV_F_S_STREAMOFF, &s->s_flags);\r\nwritel(0, &itv->dec_mbox.mbox[IVTV_MBOX_DMA_END].data[0]);\r\nwritel(0, &itv->dec_mbox.mbox[IVTV_MBOX_DMA_END].data[1]);\r\nwritel(0, &itv->dec_mbox.mbox[IVTV_MBOX_DMA_END].data[2]);\r\nwritel(0, &itv->dec_mbox.mbox[IVTV_MBOX_DMA_END].data[3]);\r\nwritel(0, &itv->dec_mbox.mbox[IVTV_MBOX_DMA].data[0]);\r\nwritel(0, &itv->dec_mbox.mbox[IVTV_MBOX_DMA].data[1]);\r\nwritel(0, &itv->dec_mbox.mbox[IVTV_MBOX_DMA].data[2]);\r\nwritel(0, &itv->dec_mbox.mbox[IVTV_MBOX_DMA].data[3]);\r\nivtv_vapi(itv, CX2341X_DEC_SET_EVENT_NOTIFICATION, 4, 0, 1, IVTV_IRQ_DEC_AUD_MODE_CHG, -1);\r\nivtv_vapi(itv, CX2341X_DEC_START_PLAYBACK, 2, gop_offset, 0);\r\nivtv_msleep_timeout(10, 0);\r\nivtv_clear_irq_mask(itv, IVTV_IRQ_MASK_DECODE);\r\nIVTV_DEBUG_IRQ("IRQ Mask is now: 0x%08x\n", itv->irqmask);\r\natomic_inc(&itv->decoding);\r\nreturn 0;\r\n}\r\nvoid ivtv_stop_all_captures(struct ivtv *itv)\r\n{\r\nint i;\r\nfor (i = IVTV_MAX_STREAMS - 1; i >= 0; i--) {\r\nstruct ivtv_stream *s = &itv->streams[i];\r\nif (s->vdev.v4l2_dev == NULL)\r\ncontinue;\r\nif (test_bit(IVTV_F_S_STREAMING, &s->s_flags)) {\r\nivtv_stop_v4l2_encode_stream(s, 0);\r\n}\r\n}\r\n}\r\nint ivtv_stop_v4l2_encode_stream(struct ivtv_stream *s, int gop_end)\r\n{\r\nstruct ivtv *itv = s->itv;\r\nDECLARE_WAITQUEUE(wait, current);\r\nint cap_type;\r\nint stopmode;\r\nif (s->vdev.v4l2_dev == NULL)\r\nreturn -EINVAL;\r\nIVTV_DEBUG_INFO("Stop Capture\n");\r\nif (s->type == IVTV_DEC_STREAM_TYPE_VOUT)\r\nreturn 0;\r\nif (atomic_read(&itv->capturing) == 0)\r\nreturn 0;\r\nswitch (s->type) {\r\ncase IVTV_ENC_STREAM_TYPE_YUV:\r\ncap_type = 1;\r\nbreak;\r\ncase IVTV_ENC_STREAM_TYPE_PCM:\r\ncap_type = 1;\r\nbreak;\r\ncase IVTV_ENC_STREAM_TYPE_VBI:\r\ncap_type = 1;\r\nbreak;\r\ncase IVTV_ENC_STREAM_TYPE_MPG:\r\ndefault:\r\ncap_type = 0;\r\nbreak;\r\n}\r\nif (s->type == IVTV_ENC_STREAM_TYPE_MPG && gop_end) {\r\nstopmode = 0;\r\n} else {\r\nstopmode = 1;\r\n}\r\nivtv_vapi(itv, CX2341X_ENC_STOP_CAPTURE, 3, stopmode, cap_type, s->subtype);\r\nif (!test_bit(IVTV_F_S_PASSTHROUGH, &s->s_flags)) {\r\nif (s->type == IVTV_ENC_STREAM_TYPE_MPG && gop_end) {\r\nunsigned long duration;\r\nunsigned long then = jiffies;\r\nadd_wait_queue(&itv->eos_waitq, &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nwhile (!test_bit(IVTV_F_I_EOS, &itv->i_flags) &&\r\ntime_before(jiffies,\r\nthen + msecs_to_jiffies(2000))) {\r\nschedule_timeout(msecs_to_jiffies(10));\r\n}\r\nduration = ((1000 + HZ / 2) / HZ) * (jiffies - then);\r\nif (!test_bit(IVTV_F_I_EOS, &itv->i_flags)) {\r\nIVTV_DEBUG_WARN("%s: EOS interrupt not received! stopping anyway.\n", s->name);\r\nIVTV_DEBUG_WARN("%s: waited %lu ms.\n", s->name, duration);\r\n} else {\r\nIVTV_DEBUG_INFO("%s: EOS took %lu ms to occur.\n", s->name, duration);\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&itv->eos_waitq, &wait);\r\nset_bit(IVTV_F_S_STREAMOFF, &s->s_flags);\r\n}\r\nivtv_msleep_timeout(100, 0);\r\n}\r\natomic_dec(&itv->capturing);\r\nclear_bit(IVTV_F_S_STREAMING, &s->s_flags);\r\nif (s->type == IVTV_ENC_STREAM_TYPE_VBI)\r\nivtv_set_irq_mask(itv, IVTV_IRQ_ENC_VBI_CAP);\r\nif (atomic_read(&itv->capturing) > 0) {\r\nreturn 0;\r\n}\r\ncx2341x_handler_set_busy(&itv->cxhdl, 0);\r\nivtv_set_irq_mask(itv, IVTV_IRQ_MASK_CAPTURE);\r\ndel_timer(&itv->dma_timer);\r\nif (test_and_clear_bit(IVTV_F_I_DIG_RST, &itv->i_flags)) {\r\nivtv_vapi(itv, CX2341X_ENC_SET_EVENT_NOTIFICATION, 4, 0, 0, IVTV_IRQ_ENC_VIM_RST, -1);\r\nivtv_set_irq_mask(itv, IVTV_IRQ_ENC_VIM_RST);\r\n}\r\nivtv_vapi(itv, CX2341X_ENC_STOP_CAPTURE, 3, 1, 2, 7);\r\nwake_up(&s->waitq);\r\nreturn 0;\r\n}\r\nint ivtv_stop_v4l2_decode_stream(struct ivtv_stream *s, int flags, u64 pts)\r\n{\r\nstatic const struct v4l2_event ev = {\r\n.type = V4L2_EVENT_EOS,\r\n};\r\nstruct ivtv *itv = s->itv;\r\nif (s->vdev.v4l2_dev == NULL)\r\nreturn -EINVAL;\r\nif (s->type != IVTV_DEC_STREAM_TYPE_YUV && s->type != IVTV_DEC_STREAM_TYPE_MPG)\r\nreturn -EINVAL;\r\nif (!test_bit(IVTV_F_S_STREAMING, &s->s_flags))\r\nreturn 0;\r\nIVTV_DEBUG_INFO("Stop Decode at %llu, flags: %x\n", (unsigned long long)pts, flags);\r\nif (!(flags & V4L2_DEC_CMD_STOP_IMMEDIATELY) || pts) {\r\nu32 tmp = 0;\r\nif (pts) {\r\nivtv_vapi(itv, CX2341X_DEC_STOP_PLAYBACK, 3,\r\n0, (u32)(pts & 0xffffffff), (u32)(pts >> 32));\r\n}\r\nwhile (1) {\r\nu32 data[CX2341X_MBOX_MAX_DATA];\r\nivtv_vapi_result(itv, data, CX2341X_DEC_GET_XFER_INFO, 0);\r\nif (s->q_full.buffers + s->q_dma.buffers == 0) {\r\nif (tmp == data[3])\r\nbreak;\r\ntmp = data[3];\r\n}\r\nif (ivtv_msleep_timeout(100, 1))\r\nbreak;\r\n}\r\n}\r\nivtv_vapi(itv, CX2341X_DEC_STOP_PLAYBACK, 3, flags & V4L2_DEC_CMD_STOP_TO_BLACK, 0, 0);\r\nivtv_vapi(itv, CX2341X_DEC_SET_EVENT_NOTIFICATION, 4, 0, 0, IVTV_IRQ_DEC_AUD_MODE_CHG, -1);\r\nivtv_set_irq_mask(itv, IVTV_IRQ_MASK_DECODE);\r\ndel_timer(&itv->dma_timer);\r\nclear_bit(IVTV_F_S_NEEDS_DATA, &s->s_flags);\r\nclear_bit(IVTV_F_S_STREAMING, &s->s_flags);\r\nivtv_flush_queues(s);\r\nivtv_msleep_timeout(40, 0);\r\natomic_dec(&itv->decoding);\r\nset_bit(IVTV_F_I_EV_DEC_STOPPED, &itv->i_flags);\r\nwake_up(&itv->event_waitq);\r\nv4l2_event_queue(&s->vdev, &ev);\r\nwake_up(&s->waitq);\r\nreturn 0;\r\n}\r\nint ivtv_passthrough_mode(struct ivtv *itv, int enable)\r\n{\r\nstruct ivtv_stream *yuv_stream = &itv->streams[IVTV_ENC_STREAM_TYPE_YUV];\r\nstruct ivtv_stream *dec_stream = &itv->streams[IVTV_DEC_STREAM_TYPE_YUV];\r\nif (yuv_stream->vdev.v4l2_dev == NULL || dec_stream->vdev.v4l2_dev == NULL)\r\nreturn -EINVAL;\r\nIVTV_DEBUG_INFO("ivtv ioctl: Select passthrough mode\n");\r\nif (enable) {\r\nif (itv->output_mode == OUT_PASSTHROUGH) {\r\nreturn 0;\r\n}\r\nif (ivtv_set_output_mode(itv, OUT_PASSTHROUGH) != OUT_PASSTHROUGH)\r\nreturn -EBUSY;\r\nset_bit(IVTV_F_S_PASSTHROUGH, &dec_stream->s_flags);\r\nset_bit(IVTV_F_S_STREAMING, &dec_stream->s_flags);\r\nivtv_setup_v4l2_decode_stream(dec_stream);\r\nivtv_vapi(itv, CX2341X_DEC_START_PLAYBACK, 2, 0, 1);\r\natomic_inc(&itv->decoding);\r\nif (atomic_read(&itv->capturing) == 0) {\r\ncx2341x_handler_setup(&itv->cxhdl);\r\ncx2341x_handler_set_busy(&itv->cxhdl, 1);\r\n}\r\nivtv_vapi(itv, CX2341X_ENC_START_CAPTURE, 2, 2, 11);\r\natomic_inc(&itv->capturing);\r\nreturn 0;\r\n}\r\nif (itv->output_mode != OUT_PASSTHROUGH)\r\nreturn 0;\r\nivtv_vapi(itv, CX2341X_ENC_STOP_CAPTURE, 3, 1, 2, 11);\r\nivtv_vapi(itv, CX2341X_DEC_STOP_PLAYBACK, 3, 1, 0, 0);\r\natomic_dec(&itv->capturing);\r\natomic_dec(&itv->decoding);\r\nclear_bit(IVTV_F_S_PASSTHROUGH, &dec_stream->s_flags);\r\nclear_bit(IVTV_F_S_STREAMING, &dec_stream->s_flags);\r\nitv->output_mode = OUT_NONE;\r\nif (atomic_read(&itv->capturing) == 0)\r\ncx2341x_handler_set_busy(&itv->cxhdl, 0);\r\nreturn 0;\r\n}
