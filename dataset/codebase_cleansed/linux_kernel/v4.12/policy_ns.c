bool aa_ns_visible(struct aa_ns *curr, struct aa_ns *view, bool subns)\r\n{\r\nif (curr == view)\r\nreturn true;\r\nif (!subns)\r\nreturn false;\r\nfor ( ; view; view = view->parent) {\r\nif (view->parent == curr)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nconst char *aa_ns_name(struct aa_ns *curr, struct aa_ns *view, bool subns)\r\n{\r\nif (curr == view)\r\nreturn "";\r\nif (aa_ns_visible(curr, view, subns)) {\r\nreturn view->base.hname + strlen(curr->base.hname) + 2;\r\n}\r\nreturn aa_hidden_ns_name;\r\n}\r\nstatic struct aa_ns *alloc_ns(const char *prefix, const char *name)\r\n{\r\nstruct aa_ns *ns;\r\nns = kzalloc(sizeof(*ns), GFP_KERNEL);\r\nAA_DEBUG("%s(%p)\n", __func__, ns);\r\nif (!ns)\r\nreturn NULL;\r\nif (!aa_policy_init(&ns->base, prefix, name, GFP_KERNEL))\r\ngoto fail_ns;\r\nINIT_LIST_HEAD(&ns->sub_ns);\r\nmutex_init(&ns->lock);\r\nns->unconfined = aa_alloc_profile("unconfined", GFP_KERNEL);\r\nif (!ns->unconfined)\r\ngoto fail_unconfined;\r\nns->unconfined->flags = PFLAG_IX_ON_NAME_ERROR |\r\nPFLAG_IMMUTABLE | PFLAG_NS_COUNT;\r\nns->unconfined->mode = APPARMOR_UNCONFINED;\r\nns->unconfined->ns = ns;\r\natomic_set(&ns->uniq_null, 0);\r\nreturn ns;\r\nfail_unconfined:\r\nkzfree(ns->base.hname);\r\nfail_ns:\r\nkzfree(ns);\r\nreturn NULL;\r\n}\r\nvoid aa_free_ns(struct aa_ns *ns)\r\n{\r\nif (!ns)\r\nreturn;\r\naa_policy_destroy(&ns->base);\r\naa_put_ns(ns->parent);\r\nns->unconfined->ns = NULL;\r\naa_free_profile(ns->unconfined);\r\nkzfree(ns);\r\n}\r\nstruct aa_ns *aa_findn_ns(struct aa_ns *root, const char *name, size_t n)\r\n{\r\nstruct aa_ns *ns = NULL;\r\nrcu_read_lock();\r\nns = aa_get_ns(__aa_findn_ns(&root->sub_ns, name, n));\r\nrcu_read_unlock();\r\nreturn ns;\r\n}\r\nstruct aa_ns *aa_find_ns(struct aa_ns *root, const char *name)\r\n{\r\nreturn aa_findn_ns(root, name, strlen(name));\r\n}\r\nstatic struct aa_ns *__aa_create_ns(struct aa_ns *parent, const char *name,\r\nstruct dentry *dir)\r\n{\r\nstruct aa_ns *ns;\r\nint error;\r\nAA_BUG(!parent);\r\nAA_BUG(!name);\r\nAA_BUG(!mutex_is_locked(&parent->lock));\r\nns = alloc_ns(parent->base.hname, name);\r\nif (!ns)\r\nreturn NULL;\r\nmutex_lock(&ns->lock);\r\nerror = __aa_fs_ns_mkdir(ns, ns_subns_dir(parent), name);\r\nif (error) {\r\nAA_ERROR("Failed to create interface for ns %s\n",\r\nns->base.name);\r\nmutex_unlock(&ns->lock);\r\naa_free_ns(ns);\r\nreturn ERR_PTR(error);\r\n}\r\nns->parent = aa_get_ns(parent);\r\nns->level = parent->level + 1;\r\nlist_add_rcu(&ns->base.list, &parent->sub_ns);\r\naa_get_ns(ns);\r\nmutex_unlock(&ns->lock);\r\nreturn ns;\r\n}\r\nstruct aa_ns *__aa_find_or_create_ns(struct aa_ns *parent, const char *name,\r\nstruct dentry *dir)\r\n{\r\nstruct aa_ns *ns;\r\nAA_BUG(!mutex_is_locked(&parent->lock));\r\nns = aa_get_ns(__aa_find_ns(&parent->sub_ns, name));\r\nif (!ns)\r\nns = __aa_create_ns(parent, name, dir);\r\nelse\r\nns = ERR_PTR(-EEXIST);\r\nreturn ns;\r\n}\r\nstruct aa_ns *aa_prepare_ns(struct aa_ns *parent, const char *name)\r\n{\r\nstruct aa_ns *ns;\r\nmutex_lock(&parent->lock);\r\nns = aa_get_ns(__aa_find_ns(&parent->sub_ns, name));\r\nif (!ns)\r\nns = __aa_create_ns(parent, name, NULL);\r\nmutex_unlock(&parent->lock);\r\nreturn ns;\r\n}\r\nstatic void destroy_ns(struct aa_ns *ns)\r\n{\r\nif (!ns)\r\nreturn;\r\nmutex_lock(&ns->lock);\r\n__aa_profile_list_release(&ns->base.profiles);\r\n__ns_list_release(&ns->sub_ns);\r\nif (ns->parent)\r\n__aa_update_proxy(ns->unconfined, ns->parent->unconfined);\r\n__aa_fs_ns_rmdir(ns);\r\nmutex_unlock(&ns->lock);\r\n}\r\nvoid __aa_remove_ns(struct aa_ns *ns)\r\n{\r\nlist_del_rcu(&ns->base.list);\r\ndestroy_ns(ns);\r\naa_put_ns(ns);\r\n}\r\nstatic void __ns_list_release(struct list_head *head)\r\n{\r\nstruct aa_ns *ns, *tmp;\r\nlist_for_each_entry_safe(ns, tmp, head, base.list)\r\n__aa_remove_ns(ns);\r\n}\r\nint __init aa_alloc_root_ns(void)\r\n{\r\nroot_ns = alloc_ns(NULL, "root");\r\nif (!root_ns)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid __init aa_free_root_ns(void)\r\n{\r\nstruct aa_ns *ns = root_ns;\r\nroot_ns = NULL;\r\ndestroy_ns(ns);\r\naa_put_ns(ns);\r\n}
