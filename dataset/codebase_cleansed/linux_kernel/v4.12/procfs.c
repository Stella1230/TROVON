static int show_version(struct seq_file *m, void *unused)\r\n{\r\nstruct super_block *sb = m->private;\r\nchar *format;\r\nif (REISERFS_SB(sb)->s_properties & (1 << REISERFS_3_6)) {\r\nformat = "3.6";\r\n} else if (REISERFS_SB(sb)->s_properties & (1 << REISERFS_3_5)) {\r\nformat = "3.5";\r\n} else {\r\nformat = "unknown";\r\n}\r\nseq_printf(m, "%s format\twith checks %s\n", format,\r\n#if defined( CONFIG_REISERFS_CHECK )\r\n"on"\r\n#else\r\n"off"\r\n#endif\r\n);\r\nreturn 0;\r\n}\r\nstatic int show_super(struct seq_file *m, void *unused)\r\n{\r\nstruct super_block *sb = m->private;\r\nstruct reiserfs_sb_info *r = REISERFS_SB(sb);\r\nseq_printf(m, "state: \t%s\n"\r\n"mount options: \t%s%s%s%s%s%s%s%s%s%s%s\n"\r\n"gen. counter: \t%i\n"\r\n"s_disk_reads: \t%i\n"\r\n"s_disk_writes: \t%i\n"\r\n"s_fix_nodes: \t%i\n"\r\n"s_do_balance: \t%i\n"\r\n"s_unneeded_left_neighbor: \t%i\n"\r\n"s_good_search_by_key_reada: \t%i\n"\r\n"s_bmaps: \t%i\n"\r\n"s_bmaps_without_search: \t%i\n"\r\n"s_direct2indirect: \t%i\n"\r\n"s_indirect2direct: \t%i\n"\r\n"\n"\r\n"max_hash_collisions: \t%i\n"\r\n"breads: \t%lu\n"\r\n"bread_misses: \t%lu\n"\r\n"search_by_key: \t%lu\n"\r\n"search_by_key_fs_changed: \t%lu\n"\r\n"search_by_key_restarted: \t%lu\n"\r\n"insert_item_restarted: \t%lu\n"\r\n"paste_into_item_restarted: \t%lu\n"\r\n"cut_from_item_restarted: \t%lu\n"\r\n"delete_solid_item_restarted: \t%lu\n"\r\n"delete_item_restarted: \t%lu\n"\r\n"leaked_oid: \t%lu\n"\r\n"leaves_removable: \t%lu\n",\r\nSF(s_mount_state) == REISERFS_VALID_FS ?\r\n"REISERFS_VALID_FS" : "REISERFS_ERROR_FS",\r\nreiserfs_r5_hash(sb) ? "FORCE_R5 " : "",\r\nreiserfs_rupasov_hash(sb) ? "FORCE_RUPASOV " : "",\r\nreiserfs_tea_hash(sb) ? "FORCE_TEA " : "",\r\nreiserfs_hash_detect(sb) ? "DETECT_HASH " : "",\r\nreiserfs_no_border(sb) ? "NO_BORDER " : "BORDER ",\r\nreiserfs_no_unhashed_relocation(sb) ?\r\n"NO_UNHASHED_RELOCATION " : "",\r\nreiserfs_hashed_relocation(sb) ? "UNHASHED_RELOCATION " : "",\r\nreiserfs_test4(sb) ? "TEST4 " : "",\r\nhave_large_tails(sb) ? "TAILS " : have_small_tails(sb) ?\r\n"SMALL_TAILS " : "NO_TAILS ",\r\nreplay_only(sb) ? "REPLAY_ONLY " : "",\r\nconvert_reiserfs(sb) ? "CONV " : "",\r\natomic_read(&r->s_generation_counter),\r\nSF(s_disk_reads), SF(s_disk_writes), SF(s_fix_nodes),\r\nSF(s_do_balance), SF(s_unneeded_left_neighbor),\r\nSF(s_good_search_by_key_reada), SF(s_bmaps),\r\nSF(s_bmaps_without_search), SF(s_direct2indirect),\r\nSF(s_indirect2direct), SFP(max_hash_collisions), SFP(breads),\r\nSFP(bread_miss), SFP(search_by_key),\r\nSFP(search_by_key_fs_changed), SFP(search_by_key_restarted),\r\nSFP(insert_item_restarted), SFP(paste_into_item_restarted),\r\nSFP(cut_from_item_restarted),\r\nSFP(delete_solid_item_restarted), SFP(delete_item_restarted),\r\nSFP(leaked_oid), SFP(leaves_removable));\r\nreturn 0;\r\n}\r\nstatic int show_per_level(struct seq_file *m, void *unused)\r\n{\r\nstruct super_block *sb = m->private;\r\nstruct reiserfs_sb_info *r = REISERFS_SB(sb);\r\nint level;\r\nseq_printf(m, "level\t"\r\n" balances"\r\n" [sbk: reads"\r\n" fs_changed"\r\n" restarted]"\r\n" free space"\r\n" items"\r\n" can_remove"\r\n" lnum"\r\n" rnum"\r\n" lbytes"\r\n" rbytes"\r\n" get_neig"\r\n" get_neig_res" " need_l_neig" " need_r_neig" "\n");\r\nfor (level = 0; level < MAX_HEIGHT; ++level) {\r\nseq_printf(m, "%i\t"\r\n" %12lu"\r\n" %12lu"\r\n" %12lu"\r\n" %12lu"\r\n" %12lu"\r\n" %12lu"\r\n" %12lu"\r\n" %12li"\r\n" %12li"\r\n" %12li"\r\n" %12li"\r\n" %12lu"\r\n" %12lu"\r\n" %12lu"\r\n" %12lu"\r\n"\n",\r\nlevel,\r\nSFPL(balance_at),\r\nSFPL(sbk_read_at),\r\nSFPL(sbk_fs_changed),\r\nSFPL(sbk_restarted),\r\nSFPL(free_at),\r\nSFPL(items_at),\r\nSFPL(can_node_be_removed),\r\nSFPL(lnum),\r\nSFPL(rnum),\r\nSFPL(lbytes),\r\nSFPL(rbytes),\r\nSFPL(get_neighbors),\r\nSFPL(get_neighbors_restart),\r\nSFPL(need_l_neighbor), SFPL(need_r_neighbor)\r\n);\r\n}\r\nreturn 0;\r\n}\r\nstatic int show_bitmap(struct seq_file *m, void *unused)\r\n{\r\nstruct super_block *sb = m->private;\r\nstruct reiserfs_sb_info *r = REISERFS_SB(sb);\r\nseq_printf(m, "free_block: %lu\n"\r\n" scan_bitmap:"\r\n" wait"\r\n" bmap"\r\n" retry"\r\n" stolen"\r\n" journal_hint"\r\n"journal_nohint"\r\n"\n"\r\n" %14lu"\r\n" %14lu"\r\n" %14lu"\r\n" %14lu"\r\n" %14lu"\r\n" %14lu"\r\n" %14lu"\r\n"\n",\r\nSFP(free_block),\r\nSFPF(call),\r\nSFPF(wait),\r\nSFPF(bmap),\r\nSFPF(retry),\r\nSFPF(stolen),\r\nSFPF(in_journal_hint), SFPF(in_journal_nohint));\r\nreturn 0;\r\n}\r\nstatic int show_on_disk_super(struct seq_file *m, void *unused)\r\n{\r\nstruct super_block *sb = m->private;\r\nstruct reiserfs_sb_info *sb_info = REISERFS_SB(sb);\r\nstruct reiserfs_super_block *rs = sb_info->s_rs;\r\nint hash_code = DFL(s_hash_function_code);\r\n__u32 flags = DJF(s_flags);\r\nseq_printf(m, "block_count: \t%i\n"\r\n"free_blocks: \t%i\n"\r\n"root_block: \t%i\n"\r\n"blocksize: \t%i\n"\r\n"oid_maxsize: \t%i\n"\r\n"oid_cursize: \t%i\n"\r\n"umount_state: \t%i\n"\r\n"magic: \t%10.10s\n"\r\n"fs_state: \t%i\n"\r\n"hash: \t%s\n"\r\n"tree_height: \t%i\n"\r\n"bmap_nr: \t%i\n"\r\n"version: \t%i\n"\r\n"flags: \t%x[%s]\n"\r\n"reserved_for_journal: \t%i\n",\r\nDFL(s_block_count),\r\nDFL(s_free_blocks),\r\nDFL(s_root_block),\r\nDF(s_blocksize),\r\nDF(s_oid_maxsize),\r\nDF(s_oid_cursize),\r\nDF(s_umount_state),\r\nrs->s_v1.s_magic,\r\nDF(s_fs_state),\r\nhash_code == TEA_HASH ? "tea" :\r\n(hash_code == YURA_HASH) ? "rupasov" :\r\n(hash_code == R5_HASH) ? "r5" :\r\n(hash_code == UNSET_HASH) ? "unset" : "unknown",\r\nDF(s_tree_height),\r\nDF(s_bmap_nr),\r\nDF(s_version), flags, (flags & reiserfs_attrs_cleared)\r\n? "attrs_cleared" : "", DF(s_reserved_for_journal));\r\nreturn 0;\r\n}\r\nstatic int show_oidmap(struct seq_file *m, void *unused)\r\n{\r\nstruct super_block *sb = m->private;\r\nstruct reiserfs_sb_info *sb_info = REISERFS_SB(sb);\r\nstruct reiserfs_super_block *rs = sb_info->s_rs;\r\nunsigned int mapsize = le16_to_cpu(rs->s_v1.s_oid_cursize);\r\nunsigned long total_used = 0;\r\nint i;\r\nfor (i = 0; i < mapsize; ++i) {\r\n__u32 right;\r\nright = (i == mapsize - 1) ? MAX_KEY_OBJECTID : MAP(i + 1);\r\nseq_printf(m, "%s: [ %x .. %x )\n",\r\n(i & 1) ? "free" : "used", MAP(i), right);\r\nif (!(i & 1)) {\r\ntotal_used += right - MAP(i);\r\n}\r\n}\r\n#if defined( REISERFS_USE_OIDMAPF )\r\nif (sb_info->oidmap.use_file && (sb_info->oidmap.mapf != NULL)) {\r\nloff_t size = file_inode(sb_info->oidmap.mapf)->i_size;\r\ntotal_used += size / sizeof(reiserfs_oidinterval_d_t);\r\n}\r\n#endif\r\nseq_printf(m, "total: \t%i [%i/%i] used: %lu [exact]\n",\r\nmapsize,\r\nmapsize, le16_to_cpu(rs->s_v1.s_oid_maxsize), total_used);\r\nreturn 0;\r\n}\r\nstatic int show_journal(struct seq_file *m, void *unused)\r\n{\r\nstruct super_block *sb = m->private;\r\nstruct reiserfs_sb_info *r = REISERFS_SB(sb);\r\nstruct reiserfs_super_block *rs = r->s_rs;\r\nstruct journal_params *jp = &rs->s_v1.s_journal;\r\nseq_printf(m,\r\n"jp_journal_1st_block: \t%i\n"\r\n"jp_journal_dev: \t%pg[%x]\n"\r\n"jp_journal_size: \t%i\n"\r\n"jp_journal_trans_max: \t%i\n"\r\n"jp_journal_magic: \t%i\n"\r\n"jp_journal_max_batch: \t%i\n"\r\n"jp_journal_max_commit_age: \t%i\n"\r\n"jp_journal_max_trans_age: \t%i\n"\r\n"j_1st_reserved_block: \t%i\n"\r\n"j_state: \t%li\n"\r\n"j_trans_id: \t%u\n"\r\n"j_mount_id: \t%lu\n"\r\n"j_start: \t%lu\n"\r\n"j_len: \t%lu\n"\r\n"j_len_alloc: \t%lu\n"\r\n"j_wcount: \t%i\n"\r\n"j_bcount: \t%lu\n"\r\n"j_first_unflushed_offset: \t%lu\n"\r\n"j_last_flush_trans_id: \t%u\n"\r\n"j_trans_start_time: \t%li\n"\r\n"j_list_bitmap_index: \t%i\n"\r\n"j_must_wait: \t%i\n"\r\n"j_next_full_flush: \t%i\n"\r\n"j_next_async_flush: \t%i\n"\r\n"j_cnode_used: \t%i\n" "j_cnode_free: \t%i\n" "\n"\r\n"in_journal: \t%12lu\n"\r\n"in_journal_bitmap: \t%12lu\n"\r\n"in_journal_reusable: \t%12lu\n"\r\n"lock_journal: \t%12lu\n"\r\n"lock_journal_wait: \t%12lu\n"\r\n"journal_begin: \t%12lu\n"\r\n"journal_relock_writers: \t%12lu\n"\r\n"journal_relock_wcount: \t%12lu\n"\r\n"mark_dirty: \t%12lu\n"\r\n"mark_dirty_already: \t%12lu\n"\r\n"mark_dirty_notjournal: \t%12lu\n"\r\n"restore_prepared: \t%12lu\n"\r\n"prepare: \t%12lu\n"\r\n"prepare_retry: \t%12lu\n",\r\nDJP(jp_journal_1st_block),\r\nSB_JOURNAL(sb)->j_dev_bd,\r\nDJP(jp_journal_dev),\r\nDJP(jp_journal_size),\r\nDJP(jp_journal_trans_max),\r\nDJP(jp_journal_magic),\r\nDJP(jp_journal_max_batch),\r\nSB_JOURNAL(sb)->j_max_commit_age,\r\nDJP(jp_journal_max_trans_age),\r\nJF(j_1st_reserved_block),\r\nJF(j_state),\r\nJF(j_trans_id),\r\nJF(j_mount_id),\r\nJF(j_start),\r\nJF(j_len),\r\nJF(j_len_alloc),\r\natomic_read(&r->s_journal->j_wcount),\r\nJF(j_bcount),\r\nJF(j_first_unflushed_offset),\r\nJF(j_last_flush_trans_id),\r\nJF(j_trans_start_time),\r\nJF(j_list_bitmap_index),\r\nJF(j_must_wait),\r\nJF(j_next_full_flush),\r\nJF(j_next_async_flush),\r\nJF(j_cnode_used),\r\nJF(j_cnode_free),\r\nSFPJ(in_journal),\r\nSFPJ(in_journal_bitmap),\r\nSFPJ(in_journal_reusable),\r\nSFPJ(lock_journal),\r\nSFPJ(lock_journal_wait),\r\nSFPJ(journal_being),\r\nSFPJ(journal_relock_writers),\r\nSFPJ(journal_relock_wcount),\r\nSFPJ(mark_dirty),\r\nSFPJ(mark_dirty_already),\r\nSFPJ(mark_dirty_notjournal),\r\nSFPJ(restore_prepared), SFPJ(prepare), SFPJ(prepare_retry)\r\n);\r\nreturn 0;\r\n}\r\nstatic int r_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, PDE_DATA(inode),\r\nproc_get_parent_data(inode));\r\n}\r\nstatic void add_file(struct super_block *sb, char *name,\r\nint (*func) (struct seq_file *, void *))\r\n{\r\nproc_create_data(name, 0, REISERFS_SB(sb)->procdir,\r\n&r_file_operations, func);\r\n}\r\nint reiserfs_proc_info_init(struct super_block *sb)\r\n{\r\nchar b[BDEVNAME_SIZE];\r\nchar *s;\r\nstrlcpy(b, sb->s_id, BDEVNAME_SIZE);\r\ns = strchr(b, '/');\r\nif (s)\r\n*s = '!';\r\nspin_lock_init(&__PINFO(sb).lock);\r\nREISERFS_SB(sb)->procdir = proc_mkdir_data(b, 0, proc_info_root, sb);\r\nif (REISERFS_SB(sb)->procdir) {\r\nadd_file(sb, "version", show_version);\r\nadd_file(sb, "super", show_super);\r\nadd_file(sb, "per-level", show_per_level);\r\nadd_file(sb, "bitmap", show_bitmap);\r\nadd_file(sb, "on-disk-super", show_on_disk_super);\r\nadd_file(sb, "oidmap", show_oidmap);\r\nadd_file(sb, "journal", show_journal);\r\nreturn 0;\r\n}\r\nreiserfs_warning(sb, "cannot create /proc/%s/%s",\r\nproc_info_root_name, b);\r\nreturn 1;\r\n}\r\nint reiserfs_proc_info_done(struct super_block *sb)\r\n{\r\nstruct proc_dir_entry *de = REISERFS_SB(sb)->procdir;\r\nif (de) {\r\nchar b[BDEVNAME_SIZE];\r\nchar *s;\r\nstrlcpy(b, sb->s_id, BDEVNAME_SIZE);\r\ns = strchr(b, '/');\r\nif (s)\r\n*s = '!';\r\nremove_proc_subtree(b, proc_info_root);\r\nREISERFS_SB(sb)->procdir = NULL;\r\n}\r\nreturn 0;\r\n}\r\nint reiserfs_proc_info_global_init(void)\r\n{\r\nif (proc_info_root == NULL) {\r\nproc_info_root = proc_mkdir(proc_info_root_name, NULL);\r\nif (!proc_info_root) {\r\nreiserfs_warning(NULL, "cannot create /proc/%s",\r\nproc_info_root_name);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint reiserfs_proc_info_global_done(void)\r\n{\r\nif (proc_info_root != NULL) {\r\nproc_info_root = NULL;\r\nremove_proc_entry(proc_info_root_name, NULL);\r\n}\r\nreturn 0;\r\n}
