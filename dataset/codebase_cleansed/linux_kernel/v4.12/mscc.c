static int vsc85xx_phy_page_set(struct phy_device *phydev, u8 page)\r\n{\r\nint rc;\r\nrc = phy_write(phydev, MSCC_EXT_PAGE_ACCESS, page);\r\nreturn rc;\r\n}\r\nstatic int vsc85xx_led_cntl_set(struct phy_device *phydev,\r\nu8 led_num,\r\nu8 mode)\r\n{\r\nint rc;\r\nu16 reg_val;\r\nmutex_lock(&phydev->lock);\r\nreg_val = phy_read(phydev, MSCC_PHY_LED_MODE_SEL);\r\nif (led_num) {\r\nreg_val &= ~LED_1_MODE_SEL_MASK;\r\nreg_val |= (((u16)mode << LED_1_MODE_SEL_POS) &\r\nLED_1_MODE_SEL_MASK);\r\n} else {\r\nreg_val &= ~LED_0_MODE_SEL_MASK;\r\nreg_val |= ((u16)mode & LED_0_MODE_SEL_MASK);\r\n}\r\nrc = phy_write(phydev, MSCC_PHY_LED_MODE_SEL, reg_val);\r\nmutex_unlock(&phydev->lock);\r\nreturn rc;\r\n}\r\nstatic int vsc85xx_mdix_get(struct phy_device *phydev, u8 *mdix)\r\n{\r\nu16 reg_val;\r\nreg_val = phy_read(phydev, MSCC_PHY_DEV_AUX_CNTL);\r\nif (reg_val & HP_AUTO_MDIX_X_OVER_IND_MASK)\r\n*mdix = ETH_TP_MDI_X;\r\nelse\r\n*mdix = ETH_TP_MDI;\r\nreturn 0;\r\n}\r\nstatic int vsc85xx_mdix_set(struct phy_device *phydev, u8 mdix)\r\n{\r\nint rc;\r\nu16 reg_val;\r\nreg_val = phy_read(phydev, MSCC_PHY_BYPASS_CONTROL);\r\nif ((mdix == ETH_TP_MDI) || (mdix == ETH_TP_MDI_X)) {\r\nreg_val |= (DISABLE_PAIR_SWAP_CORR_MASK |\r\nDISABLE_POLARITY_CORR_MASK |\r\nDISABLE_HP_AUTO_MDIX_MASK);\r\n} else {\r\nreg_val &= ~(DISABLE_PAIR_SWAP_CORR_MASK |\r\nDISABLE_POLARITY_CORR_MASK |\r\nDISABLE_HP_AUTO_MDIX_MASK);\r\n}\r\nrc = phy_write(phydev, MSCC_PHY_BYPASS_CONTROL, reg_val);\r\nif (rc != 0)\r\nreturn rc;\r\nrc = vsc85xx_phy_page_set(phydev, MSCC_PHY_PAGE_EXTENDED);\r\nif (rc != 0)\r\nreturn rc;\r\nreg_val = phy_read(phydev, MSCC_PHY_EXT_MODE_CNTL);\r\nreg_val &= ~(FORCE_MDI_CROSSOVER_MASK);\r\nif (mdix == ETH_TP_MDI)\r\nreg_val |= FORCE_MDI_CROSSOVER_MDI;\r\nelse if (mdix == ETH_TP_MDI_X)\r\nreg_val |= FORCE_MDI_CROSSOVER_MDIX;\r\nrc = phy_write(phydev, MSCC_PHY_EXT_MODE_CNTL, reg_val);\r\nif (rc != 0)\r\nreturn rc;\r\nrc = vsc85xx_phy_page_set(phydev, MSCC_PHY_PAGE_STANDARD);\r\nif (rc != 0)\r\nreturn rc;\r\nreturn genphy_restart_aneg(phydev);\r\n}\r\nstatic int vsc85xx_downshift_get(struct phy_device *phydev, u8 *count)\r\n{\r\nint rc;\r\nu16 reg_val;\r\nrc = vsc85xx_phy_page_set(phydev, MSCC_PHY_PAGE_EXTENDED);\r\nif (rc != 0)\r\ngoto out;\r\nreg_val = phy_read(phydev, MSCC_PHY_ACTIPHY_CNTL);\r\nreg_val &= DOWNSHIFT_CNTL_MASK;\r\nif (!(reg_val & DOWNSHIFT_EN))\r\n*count = DOWNSHIFT_DEV_DISABLE;\r\nelse\r\n*count = ((reg_val & ~DOWNSHIFT_EN) >> DOWNSHIFT_CNTL_POS) + 2;\r\nrc = vsc85xx_phy_page_set(phydev, MSCC_PHY_PAGE_STANDARD);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int vsc85xx_downshift_set(struct phy_device *phydev, u8 count)\r\n{\r\nint rc;\r\nu16 reg_val;\r\nif (count == DOWNSHIFT_DEV_DEFAULT_COUNT) {\r\ncount = ((1 << DOWNSHIFT_CNTL_POS) | DOWNSHIFT_EN);\r\n} else if (count > DOWNSHIFT_COUNT_MAX || count == 1) {\r\nphydev_err(phydev, "Downshift count should be 2,3,4 or 5\n");\r\nreturn -ERANGE;\r\n} else if (count) {\r\ncount = (((count - 2) << DOWNSHIFT_CNTL_POS) | DOWNSHIFT_EN);\r\n}\r\nrc = vsc85xx_phy_page_set(phydev, MSCC_PHY_PAGE_EXTENDED);\r\nif (rc != 0)\r\ngoto out;\r\nreg_val = phy_read(phydev, MSCC_PHY_ACTIPHY_CNTL);\r\nreg_val &= ~(DOWNSHIFT_CNTL_MASK);\r\nreg_val |= count;\r\nrc = phy_write(phydev, MSCC_PHY_ACTIPHY_CNTL, reg_val);\r\nif (rc != 0)\r\ngoto out;\r\nrc = vsc85xx_phy_page_set(phydev, MSCC_PHY_PAGE_STANDARD);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int vsc85xx_wol_set(struct phy_device *phydev,\r\nstruct ethtool_wolinfo *wol)\r\n{\r\nint rc;\r\nu16 reg_val;\r\nu8 i;\r\nu16 pwd[3] = {0, 0, 0};\r\nstruct ethtool_wolinfo *wol_conf = wol;\r\nu8 *mac_addr = phydev->attached_dev->dev_addr;\r\nmutex_lock(&phydev->lock);\r\nrc = vsc85xx_phy_page_set(phydev, MSCC_PHY_PAGE_EXTENDED_2);\r\nif (rc != 0)\r\ngoto out_unlock;\r\nif (wol->wolopts & WAKE_MAGIC) {\r\nfor (i = 0; i < ARRAY_SIZE(pwd); i++)\r\npwd[i] = mac_addr[5 - (i * 2 + 1)] << 8 |\r\nmac_addr[5 - i * 2];\r\nphy_write(phydev, MSCC_PHY_WOL_LOWER_MAC_ADDR, pwd[0]);\r\nphy_write(phydev, MSCC_PHY_WOL_MID_MAC_ADDR, pwd[1]);\r\nphy_write(phydev, MSCC_PHY_WOL_UPPER_MAC_ADDR, pwd[2]);\r\n} else {\r\nphy_write(phydev, MSCC_PHY_WOL_LOWER_MAC_ADDR, 0);\r\nphy_write(phydev, MSCC_PHY_WOL_MID_MAC_ADDR, 0);\r\nphy_write(phydev, MSCC_PHY_WOL_UPPER_MAC_ADDR, 0);\r\n}\r\nif (wol_conf->wolopts & WAKE_MAGICSECURE) {\r\nfor (i = 0; i < ARRAY_SIZE(pwd); i++)\r\npwd[i] = wol_conf->sopass[5 - (i * 2 + 1)] << 8 |\r\nwol_conf->sopass[5 - i * 2];\r\nphy_write(phydev, MSCC_PHY_WOL_LOWER_PASSWD, pwd[0]);\r\nphy_write(phydev, MSCC_PHY_WOL_MID_PASSWD, pwd[1]);\r\nphy_write(phydev, MSCC_PHY_WOL_UPPER_PASSWD, pwd[2]);\r\n} else {\r\nphy_write(phydev, MSCC_PHY_WOL_LOWER_PASSWD, 0);\r\nphy_write(phydev, MSCC_PHY_WOL_MID_PASSWD, 0);\r\nphy_write(phydev, MSCC_PHY_WOL_UPPER_PASSWD, 0);\r\n}\r\nreg_val = phy_read(phydev, MSCC_PHY_WOL_MAC_CONTROL);\r\nif (wol_conf->wolopts & WAKE_MAGICSECURE)\r\nreg_val |= SECURE_ON_ENABLE;\r\nelse\r\nreg_val &= ~SECURE_ON_ENABLE;\r\nphy_write(phydev, MSCC_PHY_WOL_MAC_CONTROL, reg_val);\r\nrc = vsc85xx_phy_page_set(phydev, MSCC_PHY_PAGE_STANDARD);\r\nif (rc != 0)\r\ngoto out_unlock;\r\nif (wol->wolopts & WAKE_MAGIC) {\r\nreg_val = phy_read(phydev, MII_VSC85XX_INT_MASK);\r\nreg_val |= MII_VSC85XX_INT_MASK_WOL;\r\nrc = phy_write(phydev, MII_VSC85XX_INT_MASK, reg_val);\r\nif (rc != 0)\r\ngoto out_unlock;\r\n} else {\r\nreg_val = phy_read(phydev, MII_VSC85XX_INT_MASK);\r\nreg_val &= (~MII_VSC85XX_INT_MASK_WOL);\r\nrc = phy_write(phydev, MII_VSC85XX_INT_MASK, reg_val);\r\nif (rc != 0)\r\ngoto out_unlock;\r\n}\r\nreg_val = phy_read(phydev, MII_VSC85XX_INT_STATUS);\r\nout_unlock:\r\nmutex_unlock(&phydev->lock);\r\nreturn rc;\r\n}\r\nstatic void vsc85xx_wol_get(struct phy_device *phydev,\r\nstruct ethtool_wolinfo *wol)\r\n{\r\nint rc;\r\nu16 reg_val;\r\nu8 i;\r\nu16 pwd[3] = {0, 0, 0};\r\nstruct ethtool_wolinfo *wol_conf = wol;\r\nmutex_lock(&phydev->lock);\r\nrc = vsc85xx_phy_page_set(phydev, MSCC_PHY_PAGE_EXTENDED_2);\r\nif (rc != 0)\r\ngoto out_unlock;\r\nreg_val = phy_read(phydev, MSCC_PHY_WOL_MAC_CONTROL);\r\nif (reg_val & SECURE_ON_ENABLE)\r\nwol_conf->wolopts |= WAKE_MAGICSECURE;\r\nif (wol_conf->wolopts & WAKE_MAGICSECURE) {\r\npwd[0] = phy_read(phydev, MSCC_PHY_WOL_LOWER_PASSWD);\r\npwd[1] = phy_read(phydev, MSCC_PHY_WOL_MID_PASSWD);\r\npwd[2] = phy_read(phydev, MSCC_PHY_WOL_UPPER_PASSWD);\r\nfor (i = 0; i < ARRAY_SIZE(pwd); i++) {\r\nwol_conf->sopass[5 - i * 2] = pwd[i] & 0x00ff;\r\nwol_conf->sopass[5 - (i * 2 + 1)] = (pwd[i] & 0xff00)\r\n>> 8;\r\n}\r\n}\r\nrc = vsc85xx_phy_page_set(phydev, MSCC_PHY_PAGE_STANDARD);\r\nout_unlock:\r\nmutex_unlock(&phydev->lock);\r\n}\r\nstatic int vsc85xx_edge_rate_magic_get(struct phy_device *phydev)\r\n{\r\nu8 sd;\r\nu16 vdd;\r\nint rc, i, j;\r\nstruct device *dev = &phydev->mdio.dev;\r\nstruct device_node *of_node = dev->of_node;\r\nu8 sd_array_size = ARRAY_SIZE(edge_table[0].slowdown);\r\nif (!of_node)\r\nreturn -ENODEV;\r\nrc = of_property_read_u16(of_node, "vsc8531,vddmac", &vdd);\r\nif (rc != 0)\r\nvdd = MSCC_VDDMAC_3300;\r\nrc = of_property_read_u8(of_node, "vsc8531,edge-slowdown", &sd);\r\nif (rc != 0)\r\nsd = 0;\r\nfor (i = 0; i < ARRAY_SIZE(edge_table); i++)\r\nif (edge_table[i].vddmac == vdd)\r\nfor (j = 0; j < sd_array_size; j++)\r\nif (edge_table[i].slowdown[j] == sd)\r\nreturn (sd_array_size - j - 1);\r\nreturn -EINVAL;\r\n}\r\nstatic int vsc85xx_dt_led_mode_get(struct phy_device *phydev,\r\nchar *led,\r\nu8 default_mode)\r\n{\r\nstruct device *dev = &phydev->mdio.dev;\r\nstruct device_node *of_node = dev->of_node;\r\nu8 led_mode;\r\nint err;\r\nif (!of_node)\r\nreturn -ENODEV;\r\nled_mode = default_mode;\r\nerr = of_property_read_u8(of_node, led, &led_mode);\r\nif (!err && (led_mode > 15 || led_mode == 7 || led_mode == 11)) {\r\nphydev_err(phydev, "DT %s invalid\n", led);\r\nreturn -EINVAL;\r\n}\r\nreturn led_mode;\r\n}\r\nstatic int vsc85xx_edge_rate_magic_get(struct phy_device *phydev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int vsc85xx_dt_led_mode_get(struct phy_device *phydev,\r\nchar *led,\r\nu8 default_mode)\r\n{\r\nreturn default_mode;\r\n}\r\nstatic int vsc85xx_edge_rate_cntl_set(struct phy_device *phydev, u8 edge_rate)\r\n{\r\nint rc;\r\nu16 reg_val;\r\nmutex_lock(&phydev->lock);\r\nrc = vsc85xx_phy_page_set(phydev, MSCC_PHY_PAGE_EXTENDED_2);\r\nif (rc != 0)\r\ngoto out_unlock;\r\nreg_val = phy_read(phydev, MSCC_PHY_WOL_MAC_CONTROL);\r\nreg_val &= ~(EDGE_RATE_CNTL_MASK);\r\nreg_val |= (edge_rate << EDGE_RATE_CNTL_POS);\r\nrc = phy_write(phydev, MSCC_PHY_WOL_MAC_CONTROL, reg_val);\r\nif (rc != 0)\r\ngoto out_unlock;\r\nrc = vsc85xx_phy_page_set(phydev, MSCC_PHY_PAGE_STANDARD);\r\nout_unlock:\r\nmutex_unlock(&phydev->lock);\r\nreturn rc;\r\n}\r\nstatic int vsc85xx_mac_if_set(struct phy_device *phydev,\r\nphy_interface_t interface)\r\n{\r\nint rc;\r\nu16 reg_val;\r\nmutex_lock(&phydev->lock);\r\nreg_val = phy_read(phydev, MSCC_PHY_EXT_PHY_CNTL_1);\r\nreg_val &= ~(MAC_IF_SELECTION_MASK);\r\nswitch (interface) {\r\ncase PHY_INTERFACE_MODE_RGMII:\r\nreg_val |= (MAC_IF_SELECTION_RGMII << MAC_IF_SELECTION_POS);\r\nbreak;\r\ncase PHY_INTERFACE_MODE_RMII:\r\nreg_val |= (MAC_IF_SELECTION_RMII << MAC_IF_SELECTION_POS);\r\nbreak;\r\ncase PHY_INTERFACE_MODE_MII:\r\ncase PHY_INTERFACE_MODE_GMII:\r\nreg_val |= (MAC_IF_SELECTION_GMII << MAC_IF_SELECTION_POS);\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nrc = phy_write(phydev, MSCC_PHY_EXT_PHY_CNTL_1, reg_val);\r\nif (rc != 0)\r\ngoto out_unlock;\r\nrc = genphy_soft_reset(phydev);\r\nout_unlock:\r\nmutex_unlock(&phydev->lock);\r\nreturn rc;\r\n}\r\nstatic int vsc85xx_default_config(struct phy_device *phydev)\r\n{\r\nint rc;\r\nu16 reg_val;\r\nphydev->mdix_ctrl = ETH_TP_MDI_AUTO;\r\nmutex_lock(&phydev->lock);\r\nrc = vsc85xx_phy_page_set(phydev, MSCC_PHY_PAGE_EXTENDED_2);\r\nif (rc != 0)\r\ngoto out_unlock;\r\nreg_val = phy_read(phydev, MSCC_PHY_RGMII_CNTL);\r\nreg_val &= ~(RGMII_RX_CLK_DELAY_MASK);\r\nreg_val |= (RGMII_RX_CLK_DELAY_1_1_NS << RGMII_RX_CLK_DELAY_POS);\r\nphy_write(phydev, MSCC_PHY_RGMII_CNTL, reg_val);\r\nrc = vsc85xx_phy_page_set(phydev, MSCC_PHY_PAGE_STANDARD);\r\nout_unlock:\r\nmutex_unlock(&phydev->lock);\r\nreturn rc;\r\n}\r\nstatic int vsc85xx_get_tunable(struct phy_device *phydev,\r\nstruct ethtool_tunable *tuna, void *data)\r\n{\r\nswitch (tuna->id) {\r\ncase ETHTOOL_PHY_DOWNSHIFT:\r\nreturn vsc85xx_downshift_get(phydev, (u8 *)data);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int vsc85xx_set_tunable(struct phy_device *phydev,\r\nstruct ethtool_tunable *tuna,\r\nconst void *data)\r\n{\r\nswitch (tuna->id) {\r\ncase ETHTOOL_PHY_DOWNSHIFT:\r\nreturn vsc85xx_downshift_set(phydev, *(u8 *)data);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int vsc85xx_config_init(struct phy_device *phydev)\r\n{\r\nint rc;\r\nstruct vsc8531_private *vsc8531 = phydev->priv;\r\nrc = vsc85xx_default_config(phydev);\r\nif (rc)\r\nreturn rc;\r\nrc = vsc85xx_mac_if_set(phydev, phydev->interface);\r\nif (rc)\r\nreturn rc;\r\nrc = vsc85xx_edge_rate_cntl_set(phydev, vsc8531->rate_magic);\r\nif (rc)\r\nreturn rc;\r\nrc = vsc85xx_led_cntl_set(phydev, 1, vsc8531->led_1_mode);\r\nif (rc)\r\nreturn rc;\r\nrc = vsc85xx_led_cntl_set(phydev, 0, vsc8531->led_0_mode);\r\nif (rc)\r\nreturn rc;\r\nrc = genphy_config_init(phydev);\r\nreturn rc;\r\n}\r\nstatic int vsc85xx_ack_interrupt(struct phy_device *phydev)\r\n{\r\nint rc = 0;\r\nif (phydev->interrupts == PHY_INTERRUPT_ENABLED)\r\nrc = phy_read(phydev, MII_VSC85XX_INT_STATUS);\r\nreturn (rc < 0) ? rc : 0;\r\n}\r\nstatic int vsc85xx_config_intr(struct phy_device *phydev)\r\n{\r\nint rc;\r\nif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\r\nrc = phy_write(phydev, MII_VSC85XX_INT_MASK,\r\nMII_VSC85XX_INT_MASK_MASK);\r\n} else {\r\nrc = phy_write(phydev, MII_VSC85XX_INT_MASK, 0);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = phy_read(phydev, MII_VSC85XX_INT_STATUS);\r\n}\r\nreturn rc;\r\n}\r\nstatic int vsc85xx_config_aneg(struct phy_device *phydev)\r\n{\r\nint rc;\r\nrc = vsc85xx_mdix_set(phydev, phydev->mdix_ctrl);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn genphy_config_aneg(phydev);\r\n}\r\nstatic int vsc85xx_read_status(struct phy_device *phydev)\r\n{\r\nint rc;\r\nrc = vsc85xx_mdix_get(phydev, &phydev->mdix);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn genphy_read_status(phydev);\r\n}\r\nstatic int vsc85xx_probe(struct phy_device *phydev)\r\n{\r\nstruct vsc8531_private *vsc8531;\r\nint rate_magic;\r\nint led_mode;\r\nrate_magic = vsc85xx_edge_rate_magic_get(phydev);\r\nif (rate_magic < 0)\r\nreturn rate_magic;\r\nvsc8531 = devm_kzalloc(&phydev->mdio.dev, sizeof(*vsc8531), GFP_KERNEL);\r\nif (!vsc8531)\r\nreturn -ENOMEM;\r\nphydev->priv = vsc8531;\r\nvsc8531->rate_magic = rate_magic;\r\nled_mode = vsc85xx_dt_led_mode_get(phydev, "vsc8531,led-0-mode",\r\nVSC8531_LINK_1000_ACTIVITY);\r\nif (led_mode < 0)\r\nreturn led_mode;\r\nvsc8531->led_0_mode = led_mode;\r\nled_mode = vsc85xx_dt_led_mode_get(phydev, "vsc8531,led-1-mode",\r\nVSC8531_LINK_100_ACTIVITY);\r\nif (led_mode < 0)\r\nreturn led_mode;\r\nvsc8531->led_1_mode = led_mode;\r\nreturn 0;\r\n}
