static void socfpga_dwmac_fix_mac_speed(void *priv, unsigned int speed)\r\n{\r\nstruct socfpga_dwmac *dwmac = (struct socfpga_dwmac *)priv;\r\nvoid __iomem *splitter_base = dwmac->splitter_base;\r\nvoid __iomem *tse_pcs_base = dwmac->pcs.tse_pcs_base;\r\nvoid __iomem *sgmii_adapter_base = dwmac->pcs.sgmii_adapter_base;\r\nstruct device *dev = dwmac->dev;\r\nstruct net_device *ndev = dev_get_drvdata(dev);\r\nstruct phy_device *phy_dev = ndev->phydev;\r\nu32 val;\r\nif ((tse_pcs_base) && (sgmii_adapter_base))\r\nwritew(SGMII_ADAPTER_DISABLE,\r\nsgmii_adapter_base + SGMII_ADAPTER_CTRL_REG);\r\nif (splitter_base) {\r\nval = readl(splitter_base + EMAC_SPLITTER_CTRL_REG);\r\nval &= ~EMAC_SPLITTER_CTRL_SPEED_MASK;\r\nswitch (speed) {\r\ncase 1000:\r\nval |= EMAC_SPLITTER_CTRL_SPEED_1000;\r\nbreak;\r\ncase 100:\r\nval |= EMAC_SPLITTER_CTRL_SPEED_100;\r\nbreak;\r\ncase 10:\r\nval |= EMAC_SPLITTER_CTRL_SPEED_10;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nwritel(val, splitter_base + EMAC_SPLITTER_CTRL_REG);\r\n}\r\nif (tse_pcs_base && sgmii_adapter_base)\r\ntse_pcs_fix_mac_speed(&dwmac->pcs, phy_dev, speed);\r\n}\r\nstatic int socfpga_dwmac_parse_data(struct socfpga_dwmac *dwmac, struct device *dev)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nstruct regmap *sys_mgr_base_addr;\r\nu32 reg_offset, reg_shift;\r\nint ret, index;\r\nstruct device_node *np_splitter = NULL;\r\nstruct device_node *np_sgmii_adapter = NULL;\r\nstruct resource res_splitter;\r\nstruct resource res_tse_pcs;\r\nstruct resource res_sgmii_adapter;\r\ndwmac->interface = of_get_phy_mode(np);\r\nsys_mgr_base_addr = syscon_regmap_lookup_by_phandle(np, "altr,sysmgr-syscon");\r\nif (IS_ERR(sys_mgr_base_addr)) {\r\ndev_info(dev, "No sysmgr-syscon node found\n");\r\nreturn PTR_ERR(sys_mgr_base_addr);\r\n}\r\nret = of_property_read_u32_index(np, "altr,sysmgr-syscon", 1, &reg_offset);\r\nif (ret) {\r\ndev_info(dev, "Could not read reg_offset from sysmgr-syscon!\n");\r\nreturn -EINVAL;\r\n}\r\nret = of_property_read_u32_index(np, "altr,sysmgr-syscon", 2, &reg_shift);\r\nif (ret) {\r\ndev_info(dev, "Could not read reg_shift from sysmgr-syscon!\n");\r\nreturn -EINVAL;\r\n}\r\ndwmac->f2h_ptp_ref_clk = of_property_read_bool(np, "altr,f2h_ptp_ref_clk");\r\nnp_splitter = of_parse_phandle(np, "altr,emac-splitter", 0);\r\nif (np_splitter) {\r\nret = of_address_to_resource(np_splitter, 0, &res_splitter);\r\nof_node_put(np_splitter);\r\nif (ret) {\r\ndev_info(dev, "Missing emac splitter address\n");\r\nreturn -EINVAL;\r\n}\r\ndwmac->splitter_base = devm_ioremap_resource(dev, &res_splitter);\r\nif (IS_ERR(dwmac->splitter_base)) {\r\ndev_info(dev, "Failed to mapping emac splitter\n");\r\nreturn PTR_ERR(dwmac->splitter_base);\r\n}\r\n}\r\nnp_sgmii_adapter = of_parse_phandle(np,\r\n"altr,gmii-to-sgmii-converter", 0);\r\nif (np_sgmii_adapter) {\r\nindex = of_property_match_string(np_sgmii_adapter, "reg-names",\r\n"hps_emac_interface_splitter_avalon_slave");\r\nif (index >= 0) {\r\nif (of_address_to_resource(np_sgmii_adapter, index,\r\n&res_splitter)) {\r\ndev_err(dev,\r\n"%s: ERROR: missing emac splitter address\n",\r\n__func__);\r\nret = -EINVAL;\r\ngoto err_node_put;\r\n}\r\ndwmac->splitter_base =\r\ndevm_ioremap_resource(dev, &res_splitter);\r\nif (IS_ERR(dwmac->splitter_base)) {\r\nret = PTR_ERR(dwmac->splitter_base);\r\ngoto err_node_put;\r\n}\r\n}\r\nindex = of_property_match_string(np_sgmii_adapter, "reg-names",\r\n"gmii_to_sgmii_adapter_avalon_slave");\r\nif (index >= 0) {\r\nif (of_address_to_resource(np_sgmii_adapter, index,\r\n&res_sgmii_adapter)) {\r\ndev_err(dev,\r\n"%s: ERROR: failed mapping adapter\n",\r\n__func__);\r\nret = -EINVAL;\r\ngoto err_node_put;\r\n}\r\ndwmac->pcs.sgmii_adapter_base =\r\ndevm_ioremap_resource(dev, &res_sgmii_adapter);\r\nif (IS_ERR(dwmac->pcs.sgmii_adapter_base)) {\r\nret = PTR_ERR(dwmac->pcs.sgmii_adapter_base);\r\ngoto err_node_put;\r\n}\r\n}\r\nindex = of_property_match_string(np_sgmii_adapter, "reg-names",\r\n"eth_tse_control_port");\r\nif (index >= 0) {\r\nif (of_address_to_resource(np_sgmii_adapter, index,\r\n&res_tse_pcs)) {\r\ndev_err(dev,\r\n"%s: ERROR: failed mapping tse control port\n",\r\n__func__);\r\nret = -EINVAL;\r\ngoto err_node_put;\r\n}\r\ndwmac->pcs.tse_pcs_base =\r\ndevm_ioremap_resource(dev, &res_tse_pcs);\r\nif (IS_ERR(dwmac->pcs.tse_pcs_base)) {\r\nret = PTR_ERR(dwmac->pcs.tse_pcs_base);\r\ngoto err_node_put;\r\n}\r\n}\r\n}\r\ndwmac->reg_offset = reg_offset;\r\ndwmac->reg_shift = reg_shift;\r\ndwmac->sys_mgr_base_addr = sys_mgr_base_addr;\r\ndwmac->dev = dev;\r\nof_node_put(np_sgmii_adapter);\r\nreturn 0;\r\nerr_node_put:\r\nof_node_put(np_sgmii_adapter);\r\nreturn ret;\r\n}\r\nstatic int socfpga_dwmac_set_phy_mode(struct socfpga_dwmac *dwmac)\r\n{\r\nstruct regmap *sys_mgr_base_addr = dwmac->sys_mgr_base_addr;\r\nint phymode = dwmac->interface;\r\nu32 reg_offset = dwmac->reg_offset;\r\nu32 reg_shift = dwmac->reg_shift;\r\nu32 ctrl, val, module;\r\nswitch (phymode) {\r\ncase PHY_INTERFACE_MODE_RGMII:\r\ncase PHY_INTERFACE_MODE_RGMII_ID:\r\nval = SYSMGR_EMACGRP_CTRL_PHYSEL_ENUM_RGMII;\r\nbreak;\r\ncase PHY_INTERFACE_MODE_MII:\r\ncase PHY_INTERFACE_MODE_GMII:\r\ncase PHY_INTERFACE_MODE_SGMII:\r\nval = SYSMGR_EMACGRP_CTRL_PHYSEL_ENUM_GMII_MII;\r\nbreak;\r\ndefault:\r\ndev_err(dwmac->dev, "bad phy mode %d\n", phymode);\r\nreturn -EINVAL;\r\n}\r\nif (dwmac->splitter_base)\r\nval = SYSMGR_EMACGRP_CTRL_PHYSEL_ENUM_GMII_MII;\r\nif (dwmac->stmmac_rst)\r\nreset_control_assert(dwmac->stmmac_rst);\r\nregmap_read(sys_mgr_base_addr, reg_offset, &ctrl);\r\nctrl &= ~(SYSMGR_EMACGRP_CTRL_PHYSEL_MASK << reg_shift);\r\nctrl |= val << reg_shift;\r\nif (dwmac->f2h_ptp_ref_clk) {\r\nctrl |= SYSMGR_EMACGRP_CTRL_PTP_REF_CLK_MASK << (reg_shift / 2);\r\nregmap_read(sys_mgr_base_addr, SYSMGR_FPGAGRP_MODULE_REG,\r\n&module);\r\nmodule |= (SYSMGR_FPGAGRP_MODULE_EMAC << (reg_shift / 2));\r\nregmap_write(sys_mgr_base_addr, SYSMGR_FPGAGRP_MODULE_REG,\r\nmodule);\r\n} else {\r\nctrl &= ~(SYSMGR_EMACGRP_CTRL_PTP_REF_CLK_MASK << (reg_shift / 2));\r\n}\r\nregmap_write(sys_mgr_base_addr, reg_offset, ctrl);\r\nif (dwmac->stmmac_rst)\r\nreset_control_deassert(dwmac->stmmac_rst);\r\nif (phymode == PHY_INTERFACE_MODE_SGMII) {\r\nif (tse_pcs_init(dwmac->pcs.tse_pcs_base, &dwmac->pcs) != 0) {\r\ndev_err(dwmac->dev, "Unable to initialize TSE PCS");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int socfpga_dwmac_probe(struct platform_device *pdev)\r\n{\r\nstruct plat_stmmacenet_data *plat_dat;\r\nstruct stmmac_resources stmmac_res;\r\nstruct device *dev = &pdev->dev;\r\nint ret;\r\nstruct socfpga_dwmac *dwmac;\r\nstruct net_device *ndev;\r\nstruct stmmac_priv *stpriv;\r\nret = stmmac_get_platform_resources(pdev, &stmmac_res);\r\nif (ret)\r\nreturn ret;\r\nplat_dat = stmmac_probe_config_dt(pdev, &stmmac_res.mac);\r\nif (IS_ERR(plat_dat))\r\nreturn PTR_ERR(plat_dat);\r\ndwmac = devm_kzalloc(dev, sizeof(*dwmac), GFP_KERNEL);\r\nif (!dwmac) {\r\nret = -ENOMEM;\r\ngoto err_remove_config_dt;\r\n}\r\nret = socfpga_dwmac_parse_data(dwmac, dev);\r\nif (ret) {\r\ndev_err(dev, "Unable to parse OF data\n");\r\ngoto err_remove_config_dt;\r\n}\r\nplat_dat->bsp_priv = dwmac;\r\nplat_dat->fix_mac_speed = socfpga_dwmac_fix_mac_speed;\r\nret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);\r\nif (ret)\r\ngoto err_remove_config_dt;\r\nndev = platform_get_drvdata(pdev);\r\nstpriv = netdev_priv(ndev);\r\ndwmac->stmmac_rst = stpriv->plat->stmmac_rst;\r\nret = socfpga_dwmac_set_phy_mode(dwmac);\r\nif (ret)\r\ngoto err_dvr_remove;\r\nreturn 0;\r\nerr_dvr_remove:\r\nstmmac_dvr_remove(&pdev->dev);\r\nerr_remove_config_dt:\r\nstmmac_remove_config_dt(pdev, plat_dat);\r\nreturn ret;\r\n}\r\nstatic int socfpga_dwmac_resume(struct device *dev)\r\n{\r\nstruct net_device *ndev = dev_get_drvdata(dev);\r\nstruct stmmac_priv *priv = netdev_priv(ndev);\r\nsocfpga_dwmac_set_phy_mode(priv->plat->bsp_priv);\r\nif (ndev->phydev)\r\nphy_resume(ndev->phydev);\r\nreturn stmmac_resume(dev);\r\n}
