static int rionet_rx_clean(struct net_device *ndev)\r\n{\r\nint i;\r\nint error = 0;\r\nstruct rionet_private *rnet = netdev_priv(ndev);\r\nvoid *data;\r\ni = rnet->rx_slot;\r\ndo {\r\nif (!rnet->rx_skb[i])\r\ncontinue;\r\nif (!(data = rio_get_inb_message(rnet->mport, RIONET_MAILBOX)))\r\nbreak;\r\nrnet->rx_skb[i]->data = data;\r\nskb_put(rnet->rx_skb[i], RIO_MAX_MSG_SIZE);\r\nrnet->rx_skb[i]->protocol =\r\neth_type_trans(rnet->rx_skb[i], ndev);\r\nerror = netif_rx(rnet->rx_skb[i]);\r\nif (error == NET_RX_DROP) {\r\nndev->stats.rx_dropped++;\r\n} else {\r\nndev->stats.rx_packets++;\r\nndev->stats.rx_bytes += RIO_MAX_MSG_SIZE;\r\n}\r\n} while ((i = (i + 1) % RIONET_RX_RING_SIZE) != rnet->rx_slot);\r\nreturn i;\r\n}\r\nstatic void rionet_rx_fill(struct net_device *ndev, int end)\r\n{\r\nint i;\r\nstruct rionet_private *rnet = netdev_priv(ndev);\r\ni = rnet->rx_slot;\r\ndo {\r\nrnet->rx_skb[i] = dev_alloc_skb(RIO_MAX_MSG_SIZE);\r\nif (!rnet->rx_skb[i])\r\nbreak;\r\nrio_add_inb_buffer(rnet->mport, RIONET_MAILBOX,\r\nrnet->rx_skb[i]->data);\r\n} while ((i = (i + 1) % RIONET_RX_RING_SIZE) != end);\r\nrnet->rx_slot = i;\r\n}\r\nstatic int rionet_queue_tx_msg(struct sk_buff *skb, struct net_device *ndev,\r\nstruct rio_dev *rdev)\r\n{\r\nstruct rionet_private *rnet = netdev_priv(ndev);\r\nrio_add_outb_message(rnet->mport, rdev, 0, skb->data, skb->len);\r\nrnet->tx_skb[rnet->tx_slot] = skb;\r\nndev->stats.tx_packets++;\r\nndev->stats.tx_bytes += skb->len;\r\nif (++rnet->tx_cnt == RIONET_TX_RING_SIZE)\r\nnetif_stop_queue(ndev);\r\n++rnet->tx_slot;\r\nrnet->tx_slot &= (RIONET_TX_RING_SIZE - 1);\r\nif (netif_msg_tx_queued(rnet))\r\nprintk(KERN_INFO "%s: queued skb len %8.8x\n", DRV_NAME,\r\nskb->len);\r\nreturn 0;\r\n}\r\nstatic int rionet_start_xmit(struct sk_buff *skb, struct net_device *ndev)\r\n{\r\nint i;\r\nstruct rionet_private *rnet = netdev_priv(ndev);\r\nstruct ethhdr *eth = (struct ethhdr *)skb->data;\r\nu16 destid;\r\nunsigned long flags;\r\nint add_num = 1;\r\nspin_lock_irqsave(&rnet->tx_lock, flags);\r\nif (is_multicast_ether_addr(eth->h_dest))\r\nadd_num = nets[rnet->mport->id].nact;\r\nif ((rnet->tx_cnt + add_num) > RIONET_TX_RING_SIZE) {\r\nnetif_stop_queue(ndev);\r\nspin_unlock_irqrestore(&rnet->tx_lock, flags);\r\nprintk(KERN_ERR "%s: BUG! Tx Ring full when queue awake!\n",\r\nndev->name);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nif (is_multicast_ether_addr(eth->h_dest)) {\r\nint count = 0;\r\nfor (i = 0; i < RIO_MAX_ROUTE_ENTRIES(rnet->mport->sys_size);\r\ni++)\r\nif (nets[rnet->mport->id].active[i]) {\r\nrionet_queue_tx_msg(skb, ndev,\r\nnets[rnet->mport->id].active[i]);\r\nif (count)\r\natomic_inc(&skb->users);\r\ncount++;\r\n}\r\n} else if (RIONET_MAC_MATCH(eth->h_dest)) {\r\ndestid = RIONET_GET_DESTID(eth->h_dest);\r\nif (nets[rnet->mport->id].active[destid])\r\nrionet_queue_tx_msg(skb, ndev,\r\nnets[rnet->mport->id].active[destid]);\r\nelse {\r\ndev_kfree_skb_any(skb);\r\nndev->stats.tx_packets++;\r\nndev->stats.tx_bytes += skb->len;\r\n}\r\n}\r\nspin_unlock_irqrestore(&rnet->tx_lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void rionet_dbell_event(struct rio_mport *mport, void *dev_id, u16 sid, u16 tid,\r\nu16 info)\r\n{\r\nstruct net_device *ndev = dev_id;\r\nstruct rionet_private *rnet = netdev_priv(ndev);\r\nstruct rionet_peer *peer;\r\nunsigned char netid = rnet->mport->id;\r\nif (netif_msg_intr(rnet))\r\nprintk(KERN_INFO "%s: doorbell sid %4.4x tid %4.4x info %4.4x",\r\nDRV_NAME, sid, tid, info);\r\nif (info == RIONET_DOORBELL_JOIN) {\r\nif (!nets[netid].active[sid]) {\r\nspin_lock(&nets[netid].lock);\r\nlist_for_each_entry(peer, &nets[netid].peers, node) {\r\nif (peer->rdev->destid == sid) {\r\nnets[netid].active[sid] = peer->rdev;\r\nnets[netid].nact++;\r\n}\r\n}\r\nspin_unlock(&nets[netid].lock);\r\nrio_mport_send_doorbell(mport, sid,\r\nRIONET_DOORBELL_JOIN);\r\n}\r\n} else if (info == RIONET_DOORBELL_LEAVE) {\r\nspin_lock(&nets[netid].lock);\r\nif (nets[netid].active[sid]) {\r\nnets[netid].active[sid] = NULL;\r\nnets[netid].nact--;\r\n}\r\nspin_unlock(&nets[netid].lock);\r\n} else {\r\nif (netif_msg_intr(rnet))\r\nprintk(KERN_WARNING "%s: unhandled doorbell\n",\r\nDRV_NAME);\r\n}\r\n}\r\nstatic void rionet_inb_msg_event(struct rio_mport *mport, void *dev_id, int mbox, int slot)\r\n{\r\nint n;\r\nstruct net_device *ndev = dev_id;\r\nstruct rionet_private *rnet = netdev_priv(ndev);\r\nif (netif_msg_intr(rnet))\r\nprintk(KERN_INFO "%s: inbound message event, mbox %d slot %d\n",\r\nDRV_NAME, mbox, slot);\r\nspin_lock(&rnet->lock);\r\nif ((n = rionet_rx_clean(ndev)) != rnet->rx_slot)\r\nrionet_rx_fill(ndev, n);\r\nspin_unlock(&rnet->lock);\r\n}\r\nstatic void rionet_outb_msg_event(struct rio_mport *mport, void *dev_id, int mbox, int slot)\r\n{\r\nstruct net_device *ndev = dev_id;\r\nstruct rionet_private *rnet = netdev_priv(ndev);\r\nspin_lock(&rnet->tx_lock);\r\nif (netif_msg_intr(rnet))\r\nprintk(KERN_INFO\r\n"%s: outbound message event, mbox %d slot %d\n",\r\nDRV_NAME, mbox, slot);\r\nwhile (rnet->tx_cnt && (rnet->ack_slot != slot)) {\r\ndev_kfree_skb_irq(rnet->tx_skb[rnet->ack_slot]);\r\nrnet->tx_skb[rnet->ack_slot] = NULL;\r\n++rnet->ack_slot;\r\nrnet->ack_slot &= (RIONET_TX_RING_SIZE - 1);\r\nrnet->tx_cnt--;\r\n}\r\nif (rnet->tx_cnt < RIONET_TX_RING_SIZE)\r\nnetif_wake_queue(ndev);\r\nspin_unlock(&rnet->tx_lock);\r\n}\r\nstatic int rionet_open(struct net_device *ndev)\r\n{\r\nint i, rc = 0;\r\nstruct rionet_peer *peer;\r\nstruct rionet_private *rnet = netdev_priv(ndev);\r\nunsigned char netid = rnet->mport->id;\r\nunsigned long flags;\r\nif (netif_msg_ifup(rnet))\r\nprintk(KERN_INFO "%s: open\n", DRV_NAME);\r\nif ((rc = rio_request_inb_dbell(rnet->mport,\r\n(void *)ndev,\r\nRIONET_DOORBELL_JOIN,\r\nRIONET_DOORBELL_LEAVE,\r\nrionet_dbell_event)) < 0)\r\ngoto out;\r\nif ((rc = rio_request_inb_mbox(rnet->mport,\r\n(void *)ndev,\r\nRIONET_MAILBOX,\r\nRIONET_RX_RING_SIZE,\r\nrionet_inb_msg_event)) < 0)\r\ngoto out;\r\nif ((rc = rio_request_outb_mbox(rnet->mport,\r\n(void *)ndev,\r\nRIONET_MAILBOX,\r\nRIONET_TX_RING_SIZE,\r\nrionet_outb_msg_event)) < 0)\r\ngoto out;\r\nfor (i = 0; i < RIONET_RX_RING_SIZE; i++)\r\nrnet->rx_skb[i] = NULL;\r\nrnet->rx_slot = 0;\r\nrionet_rx_fill(ndev, 0);\r\nrnet->tx_slot = 0;\r\nrnet->tx_cnt = 0;\r\nrnet->ack_slot = 0;\r\nnetif_carrier_on(ndev);\r\nnetif_start_queue(ndev);\r\nspin_lock_irqsave(&nets[netid].lock, flags);\r\nlist_for_each_entry(peer, &nets[netid].peers, node) {\r\nrio_send_doorbell(peer->rdev, RIONET_DOORBELL_JOIN);\r\n}\r\nspin_unlock_irqrestore(&nets[netid].lock, flags);\r\nrnet->open = true;\r\nout:\r\nreturn rc;\r\n}\r\nstatic int rionet_close(struct net_device *ndev)\r\n{\r\nstruct rionet_private *rnet = netdev_priv(ndev);\r\nstruct rionet_peer *peer;\r\nunsigned char netid = rnet->mport->id;\r\nunsigned long flags;\r\nint i;\r\nif (netif_msg_ifup(rnet))\r\nprintk(KERN_INFO "%s: close %s\n", DRV_NAME, ndev->name);\r\nnetif_stop_queue(ndev);\r\nnetif_carrier_off(ndev);\r\nrnet->open = false;\r\nfor (i = 0; i < RIONET_RX_RING_SIZE; i++)\r\nkfree_skb(rnet->rx_skb[i]);\r\nspin_lock_irqsave(&nets[netid].lock, flags);\r\nlist_for_each_entry(peer, &nets[netid].peers, node) {\r\nif (nets[netid].active[peer->rdev->destid]) {\r\nrio_send_doorbell(peer->rdev, RIONET_DOORBELL_LEAVE);\r\nnets[netid].active[peer->rdev->destid] = NULL;\r\n}\r\nif (peer->res)\r\nrio_release_outb_dbell(peer->rdev, peer->res);\r\n}\r\nspin_unlock_irqrestore(&nets[netid].lock, flags);\r\nrio_release_inb_dbell(rnet->mport, RIONET_DOORBELL_JOIN,\r\nRIONET_DOORBELL_LEAVE);\r\nrio_release_inb_mbox(rnet->mport, RIONET_MAILBOX);\r\nrio_release_outb_mbox(rnet->mport, RIONET_MAILBOX);\r\nreturn 0;\r\n}\r\nstatic void rionet_remove_dev(struct device *dev, struct subsys_interface *sif)\r\n{\r\nstruct rio_dev *rdev = to_rio_dev(dev);\r\nunsigned char netid = rdev->net->hport->id;\r\nstruct rionet_peer *peer;\r\nint state, found = 0;\r\nunsigned long flags;\r\nif (!dev_rionet_capable(rdev))\r\nreturn;\r\nspin_lock_irqsave(&nets[netid].lock, flags);\r\nlist_for_each_entry(peer, &nets[netid].peers, node) {\r\nif (peer->rdev == rdev) {\r\nlist_del(&peer->node);\r\nif (nets[netid].active[rdev->destid]) {\r\nstate = atomic_read(&rdev->state);\r\nif (state != RIO_DEVICE_GONE &&\r\nstate != RIO_DEVICE_INITIALIZING) {\r\nrio_send_doorbell(rdev,\r\nRIONET_DOORBELL_LEAVE);\r\n}\r\nnets[netid].active[rdev->destid] = NULL;\r\nnets[netid].nact--;\r\n}\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&nets[netid].lock, flags);\r\nif (found) {\r\nif (peer->res)\r\nrio_release_outb_dbell(rdev, peer->res);\r\nkfree(peer);\r\n}\r\n}\r\nstatic void rionet_get_drvinfo(struct net_device *ndev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct rionet_private *rnet = netdev_priv(ndev);\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nstrlcpy(info->fw_version, "n/a", sizeof(info->fw_version));\r\nstrlcpy(info->bus_info, rnet->mport->name, sizeof(info->bus_info));\r\n}\r\nstatic u32 rionet_get_msglevel(struct net_device *ndev)\r\n{\r\nstruct rionet_private *rnet = netdev_priv(ndev);\r\nreturn rnet->msg_enable;\r\n}\r\nstatic void rionet_set_msglevel(struct net_device *ndev, u32 value)\r\n{\r\nstruct rionet_private *rnet = netdev_priv(ndev);\r\nrnet->msg_enable = value;\r\n}\r\nstatic int rionet_setup_netdev(struct rio_mport *mport, struct net_device *ndev)\r\n{\r\nint rc = 0;\r\nstruct rionet_private *rnet;\r\nu16 device_id;\r\nconst size_t rionet_active_bytes = sizeof(void *) *\r\nRIO_MAX_ROUTE_ENTRIES(mport->sys_size);\r\nnets[mport->id].active = (struct rio_dev **)__get_free_pages(GFP_KERNEL,\r\nget_order(rionet_active_bytes));\r\nif (!nets[mport->id].active) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nmemset((void *)nets[mport->id].active, 0, rionet_active_bytes);\r\nrnet = netdev_priv(ndev);\r\nrnet->mport = mport;\r\nrnet->open = false;\r\ndevice_id = rio_local_get_device_id(mport);\r\nndev->dev_addr[0] = 0x00;\r\nndev->dev_addr[1] = 0x01;\r\nndev->dev_addr[2] = 0x00;\r\nndev->dev_addr[3] = 0x01;\r\nndev->dev_addr[4] = device_id >> 8;\r\nndev->dev_addr[5] = device_id & 0xff;\r\nndev->netdev_ops = &rionet_netdev_ops;\r\nndev->mtu = RIONET_MAX_MTU;\r\nndev->min_mtu = ETH_MIN_MTU;\r\nndev->max_mtu = RIONET_MAX_MTU;\r\nndev->features = NETIF_F_LLTX;\r\nSET_NETDEV_DEV(ndev, &mport->dev);\r\nndev->ethtool_ops = &rionet_ethtool_ops;\r\nspin_lock_init(&rnet->lock);\r\nspin_lock_init(&rnet->tx_lock);\r\nrnet->msg_enable = RIONET_DEFAULT_MSGLEVEL;\r\nrc = register_netdev(ndev);\r\nif (rc != 0) {\r\nfree_pages((unsigned long)nets[mport->id].active,\r\nget_order(rionet_active_bytes));\r\ngoto out;\r\n}\r\nprintk(KERN_INFO "%s: %s %s Version %s, MAC %pM, %s\n",\r\nndev->name,\r\nDRV_NAME,\r\nDRV_DESC,\r\nDRV_VERSION,\r\nndev->dev_addr,\r\nmport->name);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int rionet_add_dev(struct device *dev, struct subsys_interface *sif)\r\n{\r\nint rc = -ENODEV;\r\nu32 lsrc_ops, ldst_ops;\r\nstruct rionet_peer *peer;\r\nstruct net_device *ndev = NULL;\r\nstruct rio_dev *rdev = to_rio_dev(dev);\r\nunsigned char netid = rdev->net->hport->id;\r\nif (netid >= RIONET_MAX_NETS)\r\nreturn rc;\r\nif (!nets[netid].ndev) {\r\nrio_local_read_config_32(rdev->net->hport, RIO_SRC_OPS_CAR,\r\n&lsrc_ops);\r\nrio_local_read_config_32(rdev->net->hport, RIO_DST_OPS_CAR,\r\n&ldst_ops);\r\nif (!is_rionet_capable(lsrc_ops, ldst_ops)) {\r\nprintk(KERN_ERR\r\n"%s: local device %s is not network capable\n",\r\nDRV_NAME, rdev->net->hport->name);\r\ngoto out;\r\n}\r\nndev = alloc_etherdev(sizeof(struct rionet_private));\r\nif (ndev == NULL) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nrc = rionet_setup_netdev(rdev->net->hport, ndev);\r\nif (rc) {\r\nprintk(KERN_ERR "%s: failed to setup netdev (rc=%d)\n",\r\nDRV_NAME, rc);\r\nfree_netdev(ndev);\r\ngoto out;\r\n}\r\nINIT_LIST_HEAD(&nets[netid].peers);\r\nspin_lock_init(&nets[netid].lock);\r\nnets[netid].nact = 0;\r\nnets[netid].ndev = ndev;\r\n}\r\nif (dev_rionet_capable(rdev)) {\r\nstruct rionet_private *rnet;\r\nunsigned long flags;\r\nrnet = netdev_priv(nets[netid].ndev);\r\npeer = kzalloc(sizeof(*peer), GFP_KERNEL);\r\nif (!peer) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\npeer->rdev = rdev;\r\npeer->res = rio_request_outb_dbell(peer->rdev,\r\nRIONET_DOORBELL_JOIN,\r\nRIONET_DOORBELL_LEAVE);\r\nif (!peer->res) {\r\npr_err("%s: error requesting doorbells\n", DRV_NAME);\r\nkfree(peer);\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nspin_lock_irqsave(&nets[netid].lock, flags);\r\nlist_add_tail(&peer->node, &nets[netid].peers);\r\nspin_unlock_irqrestore(&nets[netid].lock, flags);\r\npr_debug("%s: %s add peer %s\n",\r\nDRV_NAME, __func__, rio_name(rdev));\r\nif (rnet->open)\r\nrio_send_doorbell(peer->rdev, RIONET_DOORBELL_JOIN);\r\n}\r\nreturn 0;\r\nout:\r\nreturn rc;\r\n}\r\nstatic int rionet_shutdown(struct notifier_block *nb, unsigned long code,\r\nvoid *unused)\r\n{\r\nstruct rionet_peer *peer;\r\nunsigned long flags;\r\nint i;\r\npr_debug("%s: %s\n", DRV_NAME, __func__);\r\nfor (i = 0; i < RIONET_MAX_NETS; i++) {\r\nif (!nets[i].ndev)\r\ncontinue;\r\nspin_lock_irqsave(&nets[i].lock, flags);\r\nlist_for_each_entry(peer, &nets[i].peers, node) {\r\nif (nets[i].active[peer->rdev->destid]) {\r\nrio_send_doorbell(peer->rdev,\r\nRIONET_DOORBELL_LEAVE);\r\nnets[i].active[peer->rdev->destid] = NULL;\r\n}\r\n}\r\nspin_unlock_irqrestore(&nets[i].lock, flags);\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void rionet_remove_mport(struct device *dev,\r\nstruct class_interface *class_intf)\r\n{\r\nstruct rio_mport *mport = to_rio_mport(dev);\r\nstruct net_device *ndev;\r\nint id = mport->id;\r\npr_debug("%s %s\n", __func__, mport->name);\r\nWARN(nets[id].nact, "%s called when connected to %d peers\n",\r\n__func__, nets[id].nact);\r\nWARN(!nets[id].ndev, "%s called for mport without NDEV\n",\r\n__func__);\r\nif (nets[id].ndev) {\r\nndev = nets[id].ndev;\r\nnetif_stop_queue(ndev);\r\nunregister_netdev(ndev);\r\nfree_pages((unsigned long)nets[id].active,\r\nget_order(sizeof(void *) *\r\nRIO_MAX_ROUTE_ENTRIES(mport->sys_size)));\r\nnets[id].active = NULL;\r\nfree_netdev(ndev);\r\nnets[id].ndev = NULL;\r\n}\r\n}\r\nstatic int __init rionet_init(void)\r\n{\r\nint ret;\r\nret = register_reboot_notifier(&rionet_notifier);\r\nif (ret) {\r\npr_err("%s: failed to register reboot notifier (err=%d)\n",\r\nDRV_NAME, ret);\r\nreturn ret;\r\n}\r\nret = class_interface_register(&rio_mport_interface);\r\nif (ret) {\r\npr_err("%s: class_interface_register error: %d\n",\r\nDRV_NAME, ret);\r\nreturn ret;\r\n}\r\nreturn subsys_interface_register(&rionet_interface);\r\n}\r\nstatic void __exit rionet_exit(void)\r\n{\r\nunregister_reboot_notifier(&rionet_notifier);\r\nsubsys_interface_unregister(&rionet_interface);\r\nclass_interface_unregister(&rio_mport_interface);\r\n}
