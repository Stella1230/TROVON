static void scif_invalidate_ep(int node)\r\n{\r\nstruct scif_endpt *ep;\r\nstruct list_head *pos, *tmpq;\r\nflush_work(&scif_info.conn_work);\r\nmutex_lock(&scif_info.connlock);\r\nlist_for_each_safe(pos, tmpq, &scif_info.disconnected) {\r\nep = list_entry(pos, struct scif_endpt, list);\r\nif (ep->remote_dev->node == node) {\r\nscif_unmap_all_windows(ep);\r\nspin_lock(&ep->lock);\r\nscif_cleanup_ep_qp(ep);\r\nspin_unlock(&ep->lock);\r\n}\r\n}\r\nlist_for_each_safe(pos, tmpq, &scif_info.connected) {\r\nep = list_entry(pos, struct scif_endpt, list);\r\nif (ep->remote_dev->node == node) {\r\nlist_del(pos);\r\nspin_lock(&ep->lock);\r\nep->state = SCIFEP_DISCONNECTED;\r\nlist_add_tail(&ep->list, &scif_info.disconnected);\r\nscif_cleanup_ep_qp(ep);\r\nwake_up_interruptible(&ep->sendwq);\r\nwake_up_interruptible(&ep->recvwq);\r\nspin_unlock(&ep->lock);\r\nscif_unmap_all_windows(ep);\r\n}\r\n}\r\nmutex_unlock(&scif_info.connlock);\r\n}\r\nvoid scif_free_qp(struct scif_dev *scifdev)\r\n{\r\nstruct scif_qp *qp = scifdev->qpairs;\r\nif (!qp)\r\nreturn;\r\nscif_unmap_single(qp->local_buf, scifdev, qp->inbound_q.size);\r\nkfree(qp->inbound_q.rb_base);\r\nscif_unmap_single(qp->local_qp, scifdev, sizeof(struct scif_qp));\r\nkfree(scifdev->qpairs);\r\nscifdev->qpairs = NULL;\r\n}\r\nstatic void scif_cleanup_qp(struct scif_dev *dev)\r\n{\r\nstruct scif_qp *qp = &dev->qpairs[0];\r\nif (!qp)\r\nreturn;\r\nscif_iounmap((void *)qp->remote_qp, sizeof(struct scif_qp), dev);\r\nscif_iounmap((void *)qp->outbound_q.rb_base,\r\nsizeof(struct scif_qp), dev);\r\nqp->remote_qp = NULL;\r\nqp->local_write = 0;\r\nqp->inbound_q.current_write_offset = 0;\r\nqp->inbound_q.current_read_offset = 0;\r\nif (scifdev_is_p2p(dev))\r\nscif_free_qp(dev);\r\n}\r\nvoid scif_send_acks(struct scif_dev *dev)\r\n{\r\nstruct scifmsg msg;\r\nif (dev->node_remove_ack_pending) {\r\nmsg.uop = SCIF_NODE_REMOVE_ACK;\r\nmsg.src.node = scif_info.nodeid;\r\nmsg.dst.node = SCIF_MGMT_NODE;\r\nmsg.payload[0] = dev->node;\r\nscif_nodeqp_send(&scif_dev[SCIF_MGMT_NODE], &msg);\r\ndev->node_remove_ack_pending = false;\r\n}\r\nif (dev->exit_ack_pending) {\r\nmsg.uop = SCIF_EXIT_ACK;\r\nmsg.src.node = scif_info.nodeid;\r\nmsg.dst.node = dev->node;\r\nscif_nodeqp_send(dev, &msg);\r\ndev->exit_ack_pending = false;\r\n}\r\n}\r\nvoid scif_cleanup_scifdev(struct scif_dev *dev)\r\n{\r\nstruct scif_hw_dev *sdev = dev->sdev;\r\nif (!dev->sdev)\r\nreturn;\r\nif (scifdev_is_p2p(dev)) {\r\nif (dev->cookie) {\r\nsdev->hw_ops->free_irq(sdev, dev->cookie, dev);\r\ndev->cookie = NULL;\r\n}\r\nscif_destroy_intr_wq(dev);\r\n}\r\nflush_work(&scif_info.misc_work);\r\nscif_destroy_p2p(dev);\r\nscif_invalidate_ep(dev->node);\r\nscif_zap_mmaps(dev->node);\r\nscif_cleanup_rma_for_zombies(dev->node);\r\nflush_work(&scif_info.misc_work);\r\nscif_send_acks(dev);\r\nif (!dev->node && scif_info.card_initiated_exit) {\r\nscif_send_exit(dev);\r\nscif_info.card_initiated_exit = false;\r\n}\r\nscif_cleanup_qp(dev);\r\n}\r\nvoid scif_handle_remove_node(int node)\r\n{\r\nstruct scif_dev *scifdev = &scif_dev[node];\r\nif (scif_peer_unregister_device(scifdev))\r\nscif_send_acks(scifdev);\r\n}\r\nstatic int scif_send_rmnode_msg(int node, int remove_node)\r\n{\r\nstruct scifmsg notif_msg;\r\nstruct scif_dev *dev = &scif_dev[node];\r\nnotif_msg.uop = SCIF_NODE_REMOVE;\r\nnotif_msg.src.node = scif_info.nodeid;\r\nnotif_msg.dst.node = node;\r\nnotif_msg.payload[0] = remove_node;\r\nreturn scif_nodeqp_send(dev, &notif_msg);\r\n}\r\nvoid scif_disconnect_node(u32 node_id, bool mgmt_initiated)\r\n{\r\nint ret;\r\nint msg_cnt = 0;\r\nu32 i = 0;\r\nstruct scif_dev *scifdev = &scif_dev[node_id];\r\nif (!node_id)\r\nreturn;\r\natomic_set(&scifdev->disconn_rescnt, 0);\r\nfor (i = 1; i <= scif_info.maxid; i++) {\r\nif (i == node_id)\r\ncontinue;\r\nret = scif_send_rmnode_msg(i, node_id);\r\nif (!ret)\r\nmsg_cnt++;\r\n}\r\nret = wait_event_timeout(scifdev->disconn_wq,\r\n(atomic_read(&scifdev->disconn_rescnt)\r\n== msg_cnt), SCIF_NODE_ALIVE_TIMEOUT);\r\nif (mgmt_initiated && _scifdev_alive(scifdev))\r\nscif_send_exit(scifdev);\r\natomic_set(&scifdev->disconn_rescnt, 0);\r\nret = scif_send_rmnode_msg(SCIF_MGMT_NODE, node_id);\r\nif (!ret)\r\nwait_event_timeout(scifdev->disconn_wq,\r\n(atomic_read(&scifdev->disconn_rescnt) == 1),\r\nSCIF_NODE_ALIVE_TIMEOUT);\r\n}\r\nvoid scif_get_node_info(void)\r\n{\r\nstruct scifmsg msg;\r\nDECLARE_COMPLETION_ONSTACK(node_info);\r\nmsg.uop = SCIF_GET_NODE_INFO;\r\nmsg.src.node = scif_info.nodeid;\r\nmsg.dst.node = SCIF_MGMT_NODE;\r\nmsg.payload[3] = (u64)&node_info;\r\nif ((scif_nodeqp_send(&scif_dev[SCIF_MGMT_NODE], &msg)))\r\nreturn;\r\nwait_for_completion(&node_info);\r\n}
