static inline void WRITERAP(struct lance_private *lp, __u16 value)\r\n{\r\ndo {\r\nout_be16(lp->base + HPLANCE_REGOFF + LANCE_RAP, value);\r\n} while ((in_8(lp->base + HPLANCE_STATUS) & LE_ACK) == 0);\r\n}\r\nstatic inline void WRITERDP(struct lance_private *lp, __u16 value)\r\n{\r\ndo {\r\nout_be16(lp->base + HPLANCE_REGOFF + LANCE_RDP, value);\r\n} while ((in_8(lp->base + HPLANCE_STATUS) & LE_ACK) == 0);\r\n}\r\nstatic inline __u16 READRDP(struct lance_private *lp)\r\n{\r\n__u16 value;\r\ndo {\r\nvalue = in_be16(lp->base + HPLANCE_REGOFF + LANCE_RDP);\r\n} while ((in_8(lp->base + HPLANCE_STATUS) & LE_ACK) == 0);\r\nreturn value;\r\n}\r\nstatic void load_csrs(struct lance_private *lp)\r\n{\r\nvolatile struct lance_init_block *aib = lp->lance_init_block;\r\nint leptr;\r\nleptr = LANCE_ADDR(aib);\r\nWRITERAP(lp, LE_CSR1);\r\nWRITERDP(lp, leptr & 0xFFFF);\r\nWRITERAP(lp, LE_CSR2);\r\nWRITERDP(lp, leptr >> 16);\r\nWRITERAP(lp, LE_CSR3);\r\nWRITERDP(lp, lp->busmaster_regval);\r\nWRITERAP(lp, LE_CSR0);\r\n}\r\nstatic void lance_init_ring(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nvolatile struct lance_init_block *ib = lp->init_block;\r\nvolatile struct lance_init_block *aib;\r\nint leptr;\r\nint i;\r\naib = lp->lance_init_block;\r\nlp->rx_new = lp->tx_new = 0;\r\nlp->rx_old = lp->tx_old = 0;\r\nib->mode = LE_MO_PROM;\r\n#ifdef __BIG_ENDIAN\r\nib->phys_addr[0] = dev->dev_addr[1];\r\nib->phys_addr[1] = dev->dev_addr[0];\r\nib->phys_addr[2] = dev->dev_addr[3];\r\nib->phys_addr[3] = dev->dev_addr[2];\r\nib->phys_addr[4] = dev->dev_addr[5];\r\nib->phys_addr[5] = dev->dev_addr[4];\r\n#else\r\nfor (i = 0; i < 6; i++)\r\nib->phys_addr[i] = dev->dev_addr[i];\r\n#endif\r\nif (DEBUG_IRING)\r\nprintk("TX rings:\n");\r\nlp->tx_full = 0;\r\nfor (i = 0; i < (1 << lp->lance_log_tx_bufs); i++) {\r\nleptr = LANCE_ADDR(&aib->tx_buf[i][0]);\r\nib->btx_ring[i].tmd0 = leptr;\r\nib->btx_ring[i].tmd1_hadr = leptr >> 16;\r\nib->btx_ring[i].tmd1_bits = 0;\r\nib->btx_ring[i].length = 0xf000;\r\nib->btx_ring[i].misc = 0;\r\nif (DEBUG_IRING)\r\nprintk("%d: 0x%8.8x\n", i, leptr);\r\n}\r\nif (DEBUG_IRING)\r\nprintk("RX rings:\n");\r\nfor (i = 0; i < (1 << lp->lance_log_rx_bufs); i++) {\r\nleptr = LANCE_ADDR(&aib->rx_buf[i][0]);\r\nib->brx_ring[i].rmd0 = leptr;\r\nib->brx_ring[i].rmd1_hadr = leptr >> 16;\r\nib->brx_ring[i].rmd1_bits = LE_R1_OWN;\r\nib->brx_ring[i].length = -RX_BUFF_SIZE | 0xf000;\r\nib->brx_ring[i].mblength = 0;\r\nif (DEBUG_IRING)\r\nprintk("%d: 0x%8.8x\n", i, leptr);\r\n}\r\nleptr = LANCE_ADDR(&aib->brx_ring);\r\nib->rx_len = (lp->lance_log_rx_bufs << 13) | (leptr >> 16);\r\nib->rx_ptr = leptr;\r\nif (DEBUG_IRING)\r\nprintk("RX ptr: %8.8x\n", leptr);\r\nleptr = LANCE_ADDR(&aib->btx_ring);\r\nib->tx_len = (lp->lance_log_tx_bufs << 13) | (leptr >> 16);\r\nib->tx_ptr = leptr;\r\nif (DEBUG_IRING)\r\nprintk("TX ptr: %8.8x\n", leptr);\r\nib->filter[0] = 0;\r\nib->filter[1] = 0;\r\nPRINT_RINGS();\r\n}\r\nstatic int init_restart_lance(struct lance_private *lp)\r\n{\r\nint i;\r\nWRITERAP(lp, LE_CSR0);\r\nWRITERDP(lp, LE_C0_INIT);\r\nfor (i = 0; (i < 100) && !(READRDP(lp) & (LE_C0_ERR | LE_C0_IDON)); i++)\r\nbarrier();\r\nif ((i == 100) || (READRDP(lp) & LE_C0_ERR)) {\r\nprintk("LANCE unopened after %d ticks, csr0=%4.4x.\n", i, READRDP(lp));\r\nreturn -1;\r\n}\r\nWRITERDP(lp, LE_C0_IDON);\r\nWRITERDP(lp, LE_C0_INEA | LE_C0_STRT);\r\nreturn 0;\r\n}\r\nstatic int lance_reset(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nint status;\r\nWRITERAP(lp, LE_CSR0);\r\nWRITERDP(lp, LE_C0_STOP);\r\nload_csrs(lp);\r\nlance_init_ring(dev);\r\nnetif_trans_update(dev);\r\nstatus = init_restart_lance(lp);\r\n#ifdef DEBUG_DRIVER\r\nprintk("Lance restart=%d\n", status);\r\n#endif\r\nreturn status;\r\n}\r\nstatic int lance_rx(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nvolatile struct lance_init_block *ib = lp->init_block;\r\nvolatile struct lance_rx_desc *rd;\r\nunsigned char bits;\r\n#ifdef TEST_HITS\r\nint i;\r\n#endif\r\n#ifdef TEST_HITS\r\nprintk("[");\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nif (i == lp->rx_new)\r\nprintk("%s",\r\nib->brx_ring[i].rmd1_bits & LE_R1_OWN ? "_" : "X");\r\nelse\r\nprintk("%s",\r\nib->brx_ring[i].rmd1_bits & LE_R1_OWN ? "." : "1");\r\n}\r\nprintk("]");\r\n#endif\r\n#ifdef CONFIG_HP300\r\nblinken_leds(0x40, 0);\r\n#endif\r\nWRITERDP(lp, LE_C0_RINT | LE_C0_INEA);\r\nfor (rd = &ib->brx_ring[lp->rx_new];\r\n!((bits = rd->rmd1_bits) & LE_R1_OWN);\r\nrd = &ib->brx_ring[lp->rx_new]) {\r\nif ((bits & LE_R1_POK) != LE_R1_POK) {\r\ndev->stats.rx_over_errors++;\r\ndev->stats.rx_errors++;\r\ncontinue;\r\n} else if (bits & LE_R1_ERR) {\r\nif (bits & LE_R1_BUF)\r\ndev->stats.rx_fifo_errors++;\r\nif (bits & LE_R1_CRC)\r\ndev->stats.rx_crc_errors++;\r\nif (bits & LE_R1_OFL)\r\ndev->stats.rx_over_errors++;\r\nif (bits & LE_R1_FRA)\r\ndev->stats.rx_frame_errors++;\r\nif (bits & LE_R1_EOP)\r\ndev->stats.rx_errors++;\r\n} else {\r\nint len = (rd->mblength & 0xfff) - 4;\r\nstruct sk_buff *skb = netdev_alloc_skb(dev, len + 2);\r\nif (!skb) {\r\ndev->stats.rx_dropped++;\r\nrd->mblength = 0;\r\nrd->rmd1_bits = LE_R1_OWN;\r\nlp->rx_new = (lp->rx_new + 1) & lp->rx_ring_mod_mask;\r\nreturn 0;\r\n}\r\nskb_reserve(skb, 2);\r\nskb_put(skb, len);\r\nskb_copy_to_linear_data(skb,\r\n(unsigned char *)&(ib->rx_buf[lp->rx_new][0]),\r\nlen);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += len;\r\n}\r\nrd->mblength = 0;\r\nrd->rmd1_bits = LE_R1_OWN;\r\nlp->rx_new = (lp->rx_new + 1) & lp->rx_ring_mod_mask;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lance_tx(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nvolatile struct lance_init_block *ib = lp->init_block;\r\nvolatile struct lance_tx_desc *td;\r\nint i, j;\r\nint status;\r\n#ifdef CONFIG_HP300\r\nblinken_leds(0x80, 0);\r\n#endif\r\nWRITERDP(lp, LE_C0_TINT | LE_C0_INEA);\r\nj = lp->tx_old;\r\nfor (i = j; i != lp->tx_new; i = j) {\r\ntd = &ib->btx_ring[i];\r\nif (td->tmd1_bits & LE_T1_OWN)\r\nbreak;\r\nif (td->tmd1_bits & LE_T1_ERR) {\r\nstatus = td->misc;\r\ndev->stats.tx_errors++;\r\nif (status & LE_T3_RTY)\r\ndev->stats.tx_aborted_errors++;\r\nif (status & LE_T3_LCOL)\r\ndev->stats.tx_window_errors++;\r\nif (status & LE_T3_CLOS) {\r\ndev->stats.tx_carrier_errors++;\r\nif (lp->auto_select) {\r\nlp->tpe = 1 - lp->tpe;\r\nprintk("%s: Carrier Lost, trying %s\n",\r\ndev->name,\r\nlp->tpe ? "TPE" : "AUI");\r\nWRITERAP(lp, LE_CSR0);\r\nWRITERDP(lp, LE_C0_STOP);\r\nlance_init_ring(dev);\r\nload_csrs(lp);\r\ninit_restart_lance(lp);\r\nreturn 0;\r\n}\r\n}\r\nif (status & (LE_T3_BUF|LE_T3_UFL)) {\r\ndev->stats.tx_fifo_errors++;\r\nprintk("%s: Tx: ERR_BUF|ERR_UFL, restarting\n",\r\ndev->name);\r\nWRITERAP(lp, LE_CSR0);\r\nWRITERDP(lp, LE_C0_STOP);\r\nlance_init_ring(dev);\r\nload_csrs(lp);\r\ninit_restart_lance(lp);\r\nreturn 0;\r\n}\r\n} else if ((td->tmd1_bits & LE_T1_POK) == LE_T1_POK) {\r\ntd->tmd1_bits &= ~(LE_T1_POK);\r\nif (td->tmd1_bits & LE_T1_EONE)\r\ndev->stats.collisions++;\r\nif (td->tmd1_bits & LE_T1_EMORE)\r\ndev->stats.collisions += 2;\r\ndev->stats.tx_packets++;\r\n}\r\nj = (j + 1) & lp->tx_ring_mod_mask;\r\n}\r\nlp->tx_old = j;\r\nWRITERDP(lp, LE_C0_TINT | LE_C0_INEA);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t\r\nlance_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *)dev_id;\r\nstruct lance_private *lp = netdev_priv(dev);\r\nint csr0;\r\nspin_lock(&lp->devlock);\r\nWRITERAP(lp, LE_CSR0);\r\ncsr0 = READRDP(lp);\r\nPRINT_RINGS();\r\nif (!(csr0 & LE_C0_INTR)) {\r\nspin_unlock(&lp->devlock);\r\nreturn IRQ_NONE;\r\n}\r\nWRITERDP(lp, csr0 & ~(LE_C0_INEA|LE_C0_TDMD|LE_C0_STOP|LE_C0_STRT|LE_C0_INIT));\r\nif ((csr0 & LE_C0_ERR)) {\r\nWRITERDP(lp, LE_C0_BABL|LE_C0_ERR|LE_C0_MISS|LE_C0_INEA);\r\n}\r\nif (csr0 & LE_C0_RINT)\r\nlance_rx(dev);\r\nif (csr0 & LE_C0_TINT)\r\nlance_tx(dev);\r\nif (csr0 & LE_C0_BABL)\r\ndev->stats.tx_errors++;\r\nif (csr0 & LE_C0_MISS)\r\ndev->stats.rx_errors++;\r\nif (csr0 & LE_C0_MERR) {\r\nprintk("%s: Bus master arbitration failure, status %4.4x.\n",\r\ndev->name, csr0);\r\nWRITERDP(lp, LE_C0_STRT);\r\n}\r\nif (lp->tx_full && netif_queue_stopped(dev) && (TX_BUFFS_AVAIL >= 0)) {\r\nlp->tx_full = 0;\r\nnetif_wake_queue(dev);\r\n}\r\nWRITERAP(lp, LE_CSR0);\r\nWRITERDP(lp, LE_C0_BABL|LE_C0_CERR|LE_C0_MISS|LE_C0_MERR|LE_C0_IDON|LE_C0_INEA);\r\nspin_unlock(&lp->devlock);\r\nreturn IRQ_HANDLED;\r\n}\r\nint lance_open(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nint res;\r\nif (request_irq(lp->irq, lance_interrupt, IRQF_SHARED, lp->name, dev))\r\nreturn -EAGAIN;\r\nres = lance_reset(dev);\r\nspin_lock_init(&lp->devlock);\r\nnetif_start_queue(dev);\r\nreturn res;\r\n}\r\nint lance_close(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nWRITERAP(lp, LE_CSR0);\r\nWRITERDP(lp, LE_C0_STOP);\r\nfree_irq(lp->irq, dev);\r\nreturn 0;\r\n}\r\nvoid lance_tx_timeout(struct net_device *dev)\r\n{\r\nprintk("lance_tx_timeout\n");\r\nlance_reset(dev);\r\nnetif_trans_update(dev);\r\nnetif_wake_queue(dev);\r\n}\r\nint lance_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nvolatile struct lance_init_block *ib = lp->init_block;\r\nint entry, skblen, len;\r\nstatic int outs;\r\nunsigned long flags;\r\nnetif_stop_queue(dev);\r\nif (!TX_BUFFS_AVAIL) {\r\ndev_consume_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nskblen = skb->len;\r\n#ifdef DEBUG_DRIVER\r\n{\r\nint i;\r\nfor (i = 0; i < 64; i++) {\r\nif ((i % 16) == 0)\r\nprintk("\n");\r\nprintk("%2.2x ", skb->data[i]);\r\n}\r\n}\r\n#endif\r\nlen = (skblen <= ETH_ZLEN) ? ETH_ZLEN : skblen;\r\nentry = lp->tx_new & lp->tx_ring_mod_mask;\r\nib->btx_ring[entry].length = (-len) | 0xf000;\r\nib->btx_ring[entry].misc = 0;\r\nif (skb->len < ETH_ZLEN)\r\nmemset((void *)&ib->tx_buf[entry][0], 0, ETH_ZLEN);\r\nskb_copy_from_linear_data(skb, (void *)&ib->tx_buf[entry][0], skblen);\r\nib->btx_ring[entry].tmd1_bits = (LE_T1_POK|LE_T1_OWN);\r\nlp->tx_new = (lp->tx_new + 1) & lp->tx_ring_mod_mask;\r\nouts++;\r\nWRITERDP(lp, LE_C0_INEA | LE_C0_TDMD);\r\ndev_consume_skb_any(skb);\r\nspin_lock_irqsave(&lp->devlock, flags);\r\nif (TX_BUFFS_AVAIL)\r\nnetif_start_queue(dev);\r\nelse\r\nlp->tx_full = 1;\r\nspin_unlock_irqrestore(&lp->devlock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void lance_load_multicast(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nvolatile struct lance_init_block *ib = lp->init_block;\r\nvolatile u16 *mcast_table = (u16 *)&ib->filter;\r\nstruct netdev_hw_addr *ha;\r\nu32 crc;\r\nif (dev->flags & IFF_ALLMULTI) {\r\nib->filter[0] = 0xffffffff;\r\nib->filter[1] = 0xffffffff;\r\nreturn;\r\n}\r\nib->filter[0] = 0;\r\nib->filter[1] = 0;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\ncrc = ether_crc_le(6, ha->addr);\r\ncrc = crc >> 26;\r\nmcast_table[crc >> 4] |= 1 << (crc & 0xf);\r\n}\r\n}\r\nvoid lance_set_multicast(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nvolatile struct lance_init_block *ib = lp->init_block;\r\nint stopped;\r\nstopped = netif_queue_stopped(dev);\r\nif (!stopped)\r\nnetif_stop_queue(dev);\r\nwhile (lp->tx_old != lp->tx_new)\r\nschedule();\r\nWRITERAP(lp, LE_CSR0);\r\nWRITERDP(lp, LE_C0_STOP);\r\nlance_init_ring(dev);\r\nif (dev->flags & IFF_PROMISC) {\r\nib->mode |= LE_MO_PROM;\r\n} else {\r\nib->mode &= ~LE_MO_PROM;\r\nlance_load_multicast(dev);\r\n}\r\nload_csrs(lp);\r\ninit_restart_lance(lp);\r\nif (!stopped)\r\nnetif_start_queue(dev);\r\n}\r\nvoid lance_poll(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nspin_lock(&lp->devlock);\r\nWRITERAP(lp, LE_CSR0);\r\nWRITERDP(lp, LE_C0_STRT);\r\nspin_unlock(&lp->devlock);\r\nlance_interrupt(dev->irq, dev);\r\n}
