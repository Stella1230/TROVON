int memcpy_hsa_user(void __user *dest, unsigned long src, size_t count)\r\n{\r\nunsigned long offset, bytes;\r\nif (!hsa_available)\r\nreturn -ENODATA;\r\nwhile (count) {\r\nif (sclp_sdias_copy(hsa_buf, src / PAGE_SIZE + 2, 1)) {\r\nTRACE("sclp_sdias_copy() failed\n");\r\nreturn -EIO;\r\n}\r\noffset = src % PAGE_SIZE;\r\nbytes = min(PAGE_SIZE - offset, count);\r\nif (copy_to_user(dest, hsa_buf + offset, bytes))\r\nreturn -EFAULT;\r\nsrc += bytes;\r\ndest += bytes;\r\ncount -= bytes;\r\n}\r\nreturn 0;\r\n}\r\nint memcpy_hsa_kernel(void *dest, unsigned long src, size_t count)\r\n{\r\nunsigned long offset, bytes;\r\nif (!hsa_available)\r\nreturn -ENODATA;\r\nwhile (count) {\r\nif (sclp_sdias_copy(hsa_buf, src / PAGE_SIZE + 2, 1)) {\r\nTRACE("sclp_sdias_copy() failed\n");\r\nreturn -EIO;\r\n}\r\noffset = src % PAGE_SIZE;\r\nbytes = min(PAGE_SIZE - offset, count);\r\nmemcpy(dest, hsa_buf + offset, bytes);\r\nsrc += bytes;\r\ndest += bytes;\r\ncount -= bytes;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init init_cpu_info(void)\r\n{\r\nstruct save_area *sa;\r\nsa = save_area_boot_cpu();\r\nif (!sa)\r\nreturn -ENOMEM;\r\nif (memcpy_hsa_kernel(hsa_buf, __LC_FPREGS_SAVE_AREA, 512) < 0) {\r\nTRACE("could not copy from HSA\n");\r\nreturn -EIO;\r\n}\r\nsave_area_add_regs(sa, hsa_buf);\r\nreturn 0;\r\n}\r\nstatic void release_hsa(void)\r\n{\r\ndiag308(DIAG308_REL_HSA, NULL);\r\nhsa_available = 0;\r\n}\r\nstatic ssize_t zcore_memmap_read(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn simple_read_from_buffer(buf, count, ppos, filp->private_data,\r\nmemblock.memory.cnt * CHUNK_INFO_SIZE);\r\n}\r\nstatic int zcore_memmap_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct memblock_region *reg;\r\nchar *buf;\r\nint i = 0;\r\nbuf = kzalloc(memblock.memory.cnt * CHUNK_INFO_SIZE, GFP_KERNEL);\r\nif (!buf) {\r\nreturn -ENOMEM;\r\n}\r\nfor_each_memblock(memory, reg) {\r\nsprintf(buf + (i++ * CHUNK_INFO_SIZE), "%016llx %016llx ",\r\n(unsigned long long) reg->base,\r\n(unsigned long long) reg->size);\r\n}\r\nfilp->private_data = buf;\r\nreturn nonseekable_open(inode, filp);\r\n}\r\nstatic int zcore_memmap_release(struct inode *inode, struct file *filp)\r\n{\r\nkfree(filp->private_data);\r\nreturn 0;\r\n}\r\nstatic ssize_t zcore_reipl_write(struct file *filp, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nif (ipl_block) {\r\ndiag308(DIAG308_SET, ipl_block);\r\ndiag308(DIAG308_LOAD_CLEAR, NULL);\r\n}\r\nreturn count;\r\n}\r\nstatic int zcore_reipl_open(struct inode *inode, struct file *filp)\r\n{\r\nreturn nonseekable_open(inode, filp);\r\n}\r\nstatic int zcore_reipl_release(struct inode *inode, struct file *filp)\r\n{\r\nreturn 0;\r\n}\r\nstatic ssize_t zcore_hsa_read(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstatic char str[18];\r\nif (hsa_available)\r\nsnprintf(str, sizeof(str), "%lx\n", sclp.hsa_size);\r\nelse\r\nsnprintf(str, sizeof(str), "0\n");\r\nreturn simple_read_from_buffer(buf, count, ppos, str, strlen(str));\r\n}\r\nstatic ssize_t zcore_hsa_write(struct file *filp, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar value;\r\nif (*ppos != 0)\r\nreturn -EPIPE;\r\nif (copy_from_user(&value, buf, 1))\r\nreturn -EFAULT;\r\nif (value != '0')\r\nreturn -EINVAL;\r\nrelease_hsa();\r\nreturn count;\r\n}\r\nstatic int __init check_sdias(void)\r\n{\r\nif (!sclp.hsa_size) {\r\nTRACE("Could not determine HSA size\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init zcore_reipl_init(void)\r\n{\r\nstruct ipib_info ipib_info;\r\nint rc;\r\nrc = memcpy_hsa_kernel(&ipib_info, __LC_DUMP_REIPL, sizeof(ipib_info));\r\nif (rc)\r\nreturn rc;\r\nif (ipib_info.ipib == 0)\r\nreturn 0;\r\nipl_block = (void *) __get_free_page(GFP_KERNEL);\r\nif (!ipl_block)\r\nreturn -ENOMEM;\r\nif (ipib_info.ipib < sclp.hsa_size)\r\nrc = memcpy_hsa_kernel(ipl_block, ipib_info.ipib, PAGE_SIZE);\r\nelse\r\nrc = memcpy_real(ipl_block, (void *) ipib_info.ipib, PAGE_SIZE);\r\nif (rc || (__force u32)csum_partial(ipl_block, ipl_block->hdr.len, 0) !=\r\nipib_info.checksum) {\r\nTRACE("Checksum does not match\n");\r\nfree_page((unsigned long) ipl_block);\r\nipl_block = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init zcore_init(void)\r\n{\r\nunsigned char arch;\r\nint rc;\r\nif (ipl_info.type != IPL_TYPE_FCP_DUMP)\r\nreturn -ENODATA;\r\nif (OLDMEM_BASE)\r\nreturn -ENODATA;\r\nzcore_dbf = debug_register("zcore", 4, 1, 4 * sizeof(long));\r\ndebug_register_view(zcore_dbf, &debug_sprintf_view);\r\ndebug_set_level(zcore_dbf, 6);\r\nTRACE("devno: %x\n", ipl_info.data.fcp.dev_id.devno);\r\nTRACE("wwpn: %llx\n", (unsigned long long) ipl_info.data.fcp.wwpn);\r\nTRACE("lun: %llx\n", (unsigned long long) ipl_info.data.fcp.lun);\r\nrc = sclp_sdias_init();\r\nif (rc)\r\ngoto fail;\r\nrc = check_sdias();\r\nif (rc)\r\ngoto fail;\r\nhsa_available = 1;\r\nrc = memcpy_hsa_kernel(&arch, __LC_AR_MODE_ID, 1);\r\nif (rc)\r\ngoto fail;\r\nif (arch == ARCH_S390) {\r\npr_alert("The 64-bit dump tool cannot be used for a "\r\n"32-bit system\n");\r\nrc = -EINVAL;\r\ngoto fail;\r\n}\r\npr_alert("The dump process started for a 64-bit operating system\n");\r\nrc = init_cpu_info();\r\nif (rc)\r\ngoto fail;\r\nrc = zcore_reipl_init();\r\nif (rc)\r\ngoto fail;\r\nzcore_dir = debugfs_create_dir("zcore" , NULL);\r\nif (!zcore_dir) {\r\nrc = -ENOMEM;\r\ngoto fail;\r\n}\r\nzcore_memmap_file = debugfs_create_file("memmap", S_IRUSR, zcore_dir,\r\nNULL, &zcore_memmap_fops);\r\nif (!zcore_memmap_file) {\r\nrc = -ENOMEM;\r\ngoto fail_dir;\r\n}\r\nzcore_reipl_file = debugfs_create_file("reipl", S_IRUSR, zcore_dir,\r\nNULL, &zcore_reipl_fops);\r\nif (!zcore_reipl_file) {\r\nrc = -ENOMEM;\r\ngoto fail_memmap_file;\r\n}\r\nzcore_hsa_file = debugfs_create_file("hsa", S_IRUSR|S_IWUSR, zcore_dir,\r\nNULL, &zcore_hsa_fops);\r\nif (!zcore_hsa_file) {\r\nrc = -ENOMEM;\r\ngoto fail_reipl_file;\r\n}\r\nreturn 0;\r\nfail_reipl_file:\r\ndebugfs_remove(zcore_reipl_file);\r\nfail_memmap_file:\r\ndebugfs_remove(zcore_memmap_file);\r\nfail_dir:\r\ndebugfs_remove(zcore_dir);\r\nfail:\r\ndiag308(DIAG308_REL_HSA, NULL);\r\nreturn rc;\r\n}
