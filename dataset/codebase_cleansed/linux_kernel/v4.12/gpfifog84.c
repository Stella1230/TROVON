static int\r\ng84_fifo_gpfifo_new(struct nvkm_fifo *base, const struct nvkm_oclass *oclass,\r\nvoid *data, u32 size, struct nvkm_object **pobject)\r\n{\r\nstruct nvkm_object *parent = oclass->parent;\r\nunion {\r\nstruct g82_channel_gpfifo_v0 v0;\r\n} *args = data;\r\nstruct nv50_fifo *fifo = nv50_fifo(base);\r\nstruct nv50_fifo_chan *chan;\r\nu64 ioffset, ilength;\r\nint ret = -ENOSYS;\r\nnvif_ioctl(parent, "create channel gpfifo size %d\n", size);\r\nif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\r\nnvif_ioctl(parent, "create channel gpfifo vers %d vm %llx "\r\n"pushbuf %llx ioffset %016llx "\r\n"ilength %08x\n",\r\nargs->v0.version, args->v0.vm, args->v0.pushbuf,\r\nargs->v0.ioffset, args->v0.ilength);\r\nif (!args->v0.pushbuf)\r\nreturn -EINVAL;\r\n} else\r\nreturn ret;\r\nif (!(chan = kzalloc(sizeof(*chan), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\n*pobject = &chan->base.object;\r\nret = g84_fifo_chan_ctor(fifo, args->v0.vm, args->v0.pushbuf,\r\noclass, chan);\r\nif (ret)\r\nreturn ret;\r\nargs->v0.chid = chan->base.chid;\r\nioffset = args->v0.ioffset;\r\nilength = order_base_2(args->v0.ilength / 8);\r\nnvkm_kmap(chan->ramfc);\r\nnvkm_wo32(chan->ramfc, 0x3c, 0x403f6078);\r\nnvkm_wo32(chan->ramfc, 0x44, 0x01003fff);\r\nnvkm_wo32(chan->ramfc, 0x48, chan->base.push->node->offset >> 4);\r\nnvkm_wo32(chan->ramfc, 0x50, lower_32_bits(ioffset));\r\nnvkm_wo32(chan->ramfc, 0x54, upper_32_bits(ioffset) | (ilength << 16));\r\nnvkm_wo32(chan->ramfc, 0x60, 0x7fffffff);\r\nnvkm_wo32(chan->ramfc, 0x78, 0x00000000);\r\nnvkm_wo32(chan->ramfc, 0x7c, 0x30000001);\r\nnvkm_wo32(chan->ramfc, 0x80, ((chan->ramht->bits - 9) << 27) |\r\n(4 << 24) |\r\n(chan->ramht->gpuobj->node->offset >> 4));\r\nnvkm_wo32(chan->ramfc, 0x88, chan->cache->addr >> 10);\r\nnvkm_wo32(chan->ramfc, 0x98, chan->base.inst->addr >> 12);\r\nnvkm_done(chan->ramfc);\r\nreturn 0;\r\n}
