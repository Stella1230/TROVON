static void _add_clkdev(struct omap_device *od, const char *clk_alias,\r\nconst char *clk_name)\r\n{\r\nstruct clk *r;\r\nint rc;\r\nif (!clk_alias || !clk_name)\r\nreturn;\r\ndev_dbg(&od->pdev->dev, "Creating %s -> %s\n", clk_alias, clk_name);\r\nr = clk_get_sys(dev_name(&od->pdev->dev), clk_alias);\r\nif (!IS_ERR(r)) {\r\ndev_dbg(&od->pdev->dev,\r\n"alias %s already exists\n", clk_alias);\r\nclk_put(r);\r\nreturn;\r\n}\r\nr = clk_get_sys(NULL, clk_name);\r\nif (IS_ERR(r) && of_have_populated_dt()) {\r\nstruct of_phandle_args clkspec;\r\nclkspec.np = of_find_node_by_name(NULL, clk_name);\r\nr = of_clk_get_from_provider(&clkspec);\r\nrc = clk_register_clkdev(r, clk_alias,\r\ndev_name(&od->pdev->dev));\r\n} else {\r\nrc = clk_add_alias(clk_alias, dev_name(&od->pdev->dev),\r\nclk_name, NULL);\r\n}\r\nif (rc) {\r\nif (rc == -ENODEV || rc == -ENOMEM)\r\ndev_err(&od->pdev->dev,\r\n"clkdev_alloc for %s failed\n", clk_alias);\r\nelse\r\ndev_err(&od->pdev->dev,\r\n"clk_get for %s failed\n", clk_name);\r\n}\r\n}\r\nstatic void _add_hwmod_clocks_clkdev(struct omap_device *od,\r\nstruct omap_hwmod *oh)\r\n{\r\nint i;\r\n_add_clkdev(od, "fck", oh->main_clk);\r\nfor (i = 0; i < oh->opt_clks_cnt; i++)\r\n_add_clkdev(od, oh->opt_clks[i].role, oh->opt_clks[i].clk);\r\n}\r\nstatic int omap_device_build_from_dt(struct platform_device *pdev)\r\n{\r\nstruct omap_hwmod **hwmods;\r\nstruct omap_device *od;\r\nstruct omap_hwmod *oh;\r\nstruct device_node *node = pdev->dev.of_node;\r\nconst char *oh_name;\r\nint oh_cnt, i, ret = 0;\r\nbool device_active = false;\r\noh_cnt = of_property_count_strings(node, "ti,hwmods");\r\nif (oh_cnt <= 0) {\r\ndev_dbg(&pdev->dev, "No 'hwmods' to build omap_device\n");\r\nreturn -ENODEV;\r\n}\r\nhwmods = kzalloc(sizeof(struct omap_hwmod *) * oh_cnt, GFP_KERNEL);\r\nif (!hwmods) {\r\nret = -ENOMEM;\r\ngoto odbfd_exit;\r\n}\r\nfor (i = 0; i < oh_cnt; i++) {\r\nof_property_read_string_index(node, "ti,hwmods", i, &oh_name);\r\noh = omap_hwmod_lookup(oh_name);\r\nif (!oh) {\r\ndev_err(&pdev->dev, "Cannot lookup hwmod '%s'\n",\r\noh_name);\r\nret = -EINVAL;\r\ngoto odbfd_exit1;\r\n}\r\nhwmods[i] = oh;\r\nif (oh->flags & HWMOD_INIT_NO_IDLE)\r\ndevice_active = true;\r\n}\r\nod = omap_device_alloc(pdev, hwmods, oh_cnt);\r\nif (IS_ERR(od)) {\r\ndev_err(&pdev->dev, "Cannot allocate omap_device for :%s\n",\r\noh_name);\r\nret = PTR_ERR(od);\r\ngoto odbfd_exit1;\r\n}\r\nfor (i = 0; i < pdev->num_resources; i++) {\r\nstruct resource *r = &pdev->resource[i];\r\nif (r->name == NULL)\r\nr->name = dev_name(&pdev->dev);\r\n}\r\ndev_pm_domain_set(&pdev->dev, &omap_device_pm_domain);\r\nif (device_active) {\r\nomap_device_enable(pdev);\r\npm_runtime_set_active(&pdev->dev);\r\n}\r\nodbfd_exit1:\r\nkfree(hwmods);\r\nodbfd_exit:\r\nif (ret)\r\ndev_pm_domain_set(&pdev->dev, &omap_device_fail_pm_domain);\r\nreturn ret;\r\n}\r\nstatic int _omap_device_notifier_call(struct notifier_block *nb,\r\nunsigned long event, void *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct omap_device *od;\r\nint err;\r\nswitch (event) {\r\ncase BUS_NOTIFY_REMOVED_DEVICE:\r\nif (pdev->archdata.od)\r\nomap_device_delete(pdev->archdata.od);\r\nbreak;\r\ncase BUS_NOTIFY_UNBOUND_DRIVER:\r\nod = to_omap_device(pdev);\r\nif (od && (od->_state == OMAP_DEVICE_STATE_ENABLED)) {\r\ndev_info(dev, "enabled after unload, idling\n");\r\nerr = omap_device_idle(pdev);\r\nif (err)\r\ndev_err(dev, "failed to idle\n");\r\n}\r\nbreak;\r\ncase BUS_NOTIFY_BIND_DRIVER:\r\nod = to_omap_device(pdev);\r\nif (od && (od->_state == OMAP_DEVICE_STATE_ENABLED) &&\r\npm_runtime_status_suspended(dev)) {\r\nod->_driver_status = BUS_NOTIFY_BIND_DRIVER;\r\npm_runtime_set_active(dev);\r\n}\r\nbreak;\r\ncase BUS_NOTIFY_ADD_DEVICE:\r\nif (pdev->dev.of_node)\r\nomap_device_build_from_dt(pdev);\r\nomap_auxdata_legacy_init(dev);\r\ndefault:\r\nod = to_omap_device(pdev);\r\nif (od)\r\nod->_driver_status = event;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int _omap_device_enable_hwmods(struct omap_device *od)\r\n{\r\nint ret = 0;\r\nint i;\r\nfor (i = 0; i < od->hwmods_cnt; i++)\r\nret |= omap_hwmod_enable(od->hwmods[i]);\r\nreturn ret;\r\n}\r\nstatic int _omap_device_idle_hwmods(struct omap_device *od)\r\n{\r\nint ret = 0;\r\nint i;\r\nfor (i = 0; i < od->hwmods_cnt; i++)\r\nret |= omap_hwmod_idle(od->hwmods[i]);\r\nreturn ret;\r\n}\r\nint omap_device_get_context_loss_count(struct platform_device *pdev)\r\n{\r\nstruct omap_device *od;\r\nu32 ret = 0;\r\nod = to_omap_device(pdev);\r\nif (od->hwmods_cnt)\r\nret = omap_hwmod_get_context_loss_count(od->hwmods[0]);\r\nreturn ret;\r\n}\r\nstatic int omap_device_count_resources(struct omap_device *od,\r\nunsigned long flags)\r\n{\r\nint c = 0;\r\nint i;\r\nfor (i = 0; i < od->hwmods_cnt; i++)\r\nc += omap_hwmod_count_resources(od->hwmods[i], flags);\r\npr_debug("omap_device: %s: counted %d total resources across %d hwmods\n",\r\nod->pdev->name, c, od->hwmods_cnt);\r\nreturn c;\r\n}\r\nstatic int omap_device_fill_resources(struct omap_device *od,\r\nstruct resource *res)\r\n{\r\nint i, r;\r\nfor (i = 0; i < od->hwmods_cnt; i++) {\r\nr = omap_hwmod_fill_resources(od->hwmods[i], res);\r\nres += r;\r\n}\r\nreturn 0;\r\n}\r\nstatic int _od_fill_dma_resources(struct omap_device *od,\r\nstruct resource *res)\r\n{\r\nint i, r;\r\nfor (i = 0; i < od->hwmods_cnt; i++) {\r\nr = omap_hwmod_fill_dma_resources(od->hwmods[i], res);\r\nres += r;\r\n}\r\nreturn 0;\r\n}\r\nstruct omap_device *omap_device_alloc(struct platform_device *pdev,\r\nstruct omap_hwmod **ohs, int oh_cnt)\r\n{\r\nint ret = -ENOMEM;\r\nstruct omap_device *od;\r\nstruct resource *res = NULL;\r\nint i, res_count;\r\nstruct omap_hwmod **hwmods;\r\nod = kzalloc(sizeof(struct omap_device), GFP_KERNEL);\r\nif (!od) {\r\nret = -ENOMEM;\r\ngoto oda_exit1;\r\n}\r\nod->hwmods_cnt = oh_cnt;\r\nhwmods = kmemdup(ohs, sizeof(struct omap_hwmod *) * oh_cnt, GFP_KERNEL);\r\nif (!hwmods)\r\ngoto oda_exit2;\r\nod->hwmods = hwmods;\r\nod->pdev = pdev;\r\nif (!pdev->num_resources) {\r\nres_count = omap_device_count_resources(od, IORESOURCE_IRQ |\r\nIORESOURCE_DMA |\r\nIORESOURCE_MEM);\r\n} else {\r\nfor (i = 0; i < pdev->num_resources; i++) {\r\nstruct resource *r = &pdev->resource[i];\r\nif (r->flags == IORESOURCE_DMA)\r\ngoto have_everything;\r\n}\r\nres_count = omap_device_count_resources(od, IORESOURCE_DMA);\r\nif (!res_count)\r\ngoto have_everything;\r\nres_count += pdev->num_resources;\r\n}\r\nres = kzalloc(sizeof(struct resource) * res_count, GFP_KERNEL);\r\nif (!res)\r\ngoto oda_exit3;\r\nif (!pdev->num_resources) {\r\ndev_dbg(&pdev->dev, "%s: using %d resources from hwmod\n",\r\n__func__, res_count);\r\nomap_device_fill_resources(od, res);\r\n} else {\r\ndev_dbg(&pdev->dev,\r\n"%s: appending %d DMA resources from hwmod\n",\r\n__func__, res_count - pdev->num_resources);\r\nmemcpy(res, pdev->resource,\r\nsizeof(struct resource) * pdev->num_resources);\r\n_od_fill_dma_resources(od, &res[pdev->num_resources]);\r\n}\r\nret = platform_device_add_resources(pdev, res, res_count);\r\nkfree(res);\r\nif (ret)\r\ngoto oda_exit3;\r\nhave_everything:\r\npdev->archdata.od = od;\r\nfor (i = 0; i < oh_cnt; i++) {\r\nhwmods[i]->od = od;\r\n_add_hwmod_clocks_clkdev(od, hwmods[i]);\r\n}\r\nreturn od;\r\noda_exit3:\r\nkfree(hwmods);\r\noda_exit2:\r\nkfree(od);\r\noda_exit1:\r\ndev_err(&pdev->dev, "omap_device: build failed (%d)\n", ret);\r\nreturn ERR_PTR(ret);\r\n}\r\nvoid omap_device_delete(struct omap_device *od)\r\n{\r\nif (!od)\r\nreturn;\r\nod->pdev->archdata.od = NULL;\r\nkfree(od->hwmods);\r\nkfree(od);\r\n}\r\nstruct platform_device __init *omap_device_build(const char *pdev_name,\r\nint pdev_id,\r\nstruct omap_hwmod *oh,\r\nvoid *pdata, int pdata_len)\r\n{\r\nstruct omap_hwmod *ohs[] = { oh };\r\nif (!oh)\r\nreturn ERR_PTR(-EINVAL);\r\nreturn omap_device_build_ss(pdev_name, pdev_id, ohs, 1, pdata,\r\npdata_len);\r\n}\r\nstruct platform_device __init *omap_device_build_ss(const char *pdev_name,\r\nint pdev_id,\r\nstruct omap_hwmod **ohs,\r\nint oh_cnt, void *pdata,\r\nint pdata_len)\r\n{\r\nint ret = -ENOMEM;\r\nstruct platform_device *pdev;\r\nstruct omap_device *od;\r\nif (!ohs || oh_cnt == 0 || !pdev_name)\r\nreturn ERR_PTR(-EINVAL);\r\nif (!pdata && pdata_len > 0)\r\nreturn ERR_PTR(-EINVAL);\r\npdev = platform_device_alloc(pdev_name, pdev_id);\r\nif (!pdev) {\r\nret = -ENOMEM;\r\ngoto odbs_exit;\r\n}\r\nif (pdev->id != -1)\r\ndev_set_name(&pdev->dev, "%s.%d", pdev->name, pdev->id);\r\nelse\r\ndev_set_name(&pdev->dev, "%s", pdev->name);\r\nod = omap_device_alloc(pdev, ohs, oh_cnt);\r\nif (IS_ERR(od))\r\ngoto odbs_exit1;\r\nret = platform_device_add_data(pdev, pdata, pdata_len);\r\nif (ret)\r\ngoto odbs_exit2;\r\nret = omap_device_register(pdev);\r\nif (ret)\r\ngoto odbs_exit2;\r\nreturn pdev;\r\nodbs_exit2:\r\nomap_device_delete(od);\r\nodbs_exit1:\r\nplatform_device_put(pdev);\r\nodbs_exit:\r\npr_err("omap_device: %s: build failed (%d)\n", pdev_name, ret);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic int _od_runtime_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nint ret;\r\nret = pm_generic_runtime_suspend(dev);\r\nif (ret)\r\nreturn ret;\r\nreturn omap_device_idle(pdev);\r\n}\r\nstatic int _od_runtime_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nint ret;\r\nret = omap_device_enable(pdev);\r\nif (ret) {\r\ndev_err(dev, "use pm_runtime_put_sync_suspend() in driver?\n");\r\nreturn ret;\r\n}\r\nreturn pm_generic_runtime_resume(dev);\r\n}\r\nstatic int _od_fail_runtime_suspend(struct device *dev)\r\n{\r\ndev_warn(dev, "%s: FIXME: missing hwmod/omap_dev info\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nstatic int _od_fail_runtime_resume(struct device *dev)\r\n{\r\ndev_warn(dev, "%s: FIXME: missing hwmod/omap_dev info\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nstatic int _od_suspend_noirq(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct omap_device *od = to_omap_device(pdev);\r\nint ret;\r\nif (od->_driver_status != BUS_NOTIFY_BOUND_DRIVER)\r\nreturn 0;\r\nret = pm_generic_suspend_noirq(dev);\r\nif (!ret && !pm_runtime_status_suspended(dev)) {\r\nif (pm_generic_runtime_suspend(dev) == 0) {\r\npm_runtime_set_suspended(dev);\r\nomap_device_idle(pdev);\r\nod->flags |= OMAP_DEVICE_SUSPENDED;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int _od_resume_noirq(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct omap_device *od = to_omap_device(pdev);\r\nif (od->flags & OMAP_DEVICE_SUSPENDED) {\r\nod->flags &= ~OMAP_DEVICE_SUSPENDED;\r\nomap_device_enable(pdev);\r\nWARN(pm_runtime_set_active(dev),\r\n"Could not set %s runtime state active\n", dev_name(dev));\r\npm_generic_runtime_resume(dev);\r\n}\r\nreturn pm_generic_resume_noirq(dev);\r\n}\r\nint omap_device_register(struct platform_device *pdev)\r\n{\r\npr_debug("omap_device: %s: registering\n", pdev->name);\r\ndev_pm_domain_set(&pdev->dev, &omap_device_pm_domain);\r\nreturn platform_device_add(pdev);\r\n}\r\nint omap_device_enable(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct omap_device *od;\r\nod = to_omap_device(pdev);\r\nif (od->_state == OMAP_DEVICE_STATE_ENABLED) {\r\ndev_warn(&pdev->dev,\r\n"omap_device: %s() called from invalid state %d\n",\r\n__func__, od->_state);\r\nreturn -EINVAL;\r\n}\r\nret = _omap_device_enable_hwmods(od);\r\nif (ret == 0)\r\nod->_state = OMAP_DEVICE_STATE_ENABLED;\r\nreturn ret;\r\n}\r\nint omap_device_idle(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct omap_device *od;\r\nod = to_omap_device(pdev);\r\nif (od->_state != OMAP_DEVICE_STATE_ENABLED) {\r\ndev_warn(&pdev->dev,\r\n"omap_device: %s() called from invalid state %d\n",\r\n__func__, od->_state);\r\nreturn -EINVAL;\r\n}\r\nret = _omap_device_idle_hwmods(od);\r\nif (ret == 0)\r\nod->_state = OMAP_DEVICE_STATE_IDLE;\r\nreturn ret;\r\n}\r\nint omap_device_assert_hardreset(struct platform_device *pdev, const char *name)\r\n{\r\nstruct omap_device *od = to_omap_device(pdev);\r\nint ret = 0;\r\nint i;\r\nfor (i = 0; i < od->hwmods_cnt; i++) {\r\nret = omap_hwmod_assert_hardreset(od->hwmods[i], name);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint omap_device_deassert_hardreset(struct platform_device *pdev,\r\nconst char *name)\r\n{\r\nstruct omap_device *od = to_omap_device(pdev);\r\nint ret = 0;\r\nint i;\r\nfor (i = 0; i < od->hwmods_cnt; i++) {\r\nret = omap_hwmod_deassert_hardreset(od->hwmods[i], name);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstruct device *omap_device_get_by_hwmod_name(const char *oh_name)\r\n{\r\nstruct omap_hwmod *oh;\r\nif (!oh_name) {\r\nWARN(1, "%s: no hwmod name!\n", __func__);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\noh = omap_hwmod_lookup(oh_name);\r\nif (!oh) {\r\nWARN(1, "%s: no hwmod for %s\n", __func__,\r\noh_name);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nif (!oh->od) {\r\nWARN(1, "%s: no omap_device for %s\n", __func__,\r\noh_name);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nreturn &oh->od->pdev->dev;\r\n}\r\nstatic int __init omap_device_init(void)\r\n{\r\nbus_register_notifier(&platform_bus_type, &platform_nb);\r\nreturn 0;\r\n}\r\nstatic int __init omap_device_late_idle(struct device *dev, void *data)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct omap_device *od = to_omap_device(pdev);\r\nint i;\r\nif (!od)\r\nreturn 0;\r\nfor (i = 0; i < od->hwmods_cnt; i++)\r\nif (od->hwmods[i]->flags & HWMOD_INIT_NO_IDLE)\r\nreturn 0;\r\nif (od->_driver_status != BUS_NOTIFY_BOUND_DRIVER &&\r\nod->_driver_status != BUS_NOTIFY_BIND_DRIVER) {\r\nif (od->_state == OMAP_DEVICE_STATE_ENABLED) {\r\ndev_warn(dev, "%s: enabled but no driver. Idling\n",\r\n__func__);\r\nomap_device_idle(pdev);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init omap_device_late_init(void)\r\n{\r\nbus_for_each_dev(&platform_bus_type, NULL, NULL, omap_device_late_idle);\r\nWARN(!of_have_populated_dt(),\r\n"legacy booting deprecated, please update to boot with .dts\n");\r\nreturn 0;\r\n}
