static int stmmac_adjust_freq(struct ptp_clock_info *ptp, s32 ppb)\r\n{\r\nstruct stmmac_priv *priv =\r\ncontainer_of(ptp, struct stmmac_priv, ptp_clock_ops);\r\nunsigned long flags;\r\nu32 diff, addend;\r\nint neg_adj = 0;\r\nu64 adj;\r\nif (ppb < 0) {\r\nneg_adj = 1;\r\nppb = -ppb;\r\n}\r\naddend = priv->default_addend;\r\nadj = addend;\r\nadj *= ppb;\r\ndiff = div_u64(adj, 1000000000ULL);\r\naddend = neg_adj ? (addend - diff) : (addend + diff);\r\nspin_lock_irqsave(&priv->ptp_lock, flags);\r\npriv->hw->ptp->config_addend(priv->ptpaddr, addend);\r\nspin_unlock_irqrestore(&priv->ptp_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int stmmac_adjust_time(struct ptp_clock_info *ptp, s64 delta)\r\n{\r\nstruct stmmac_priv *priv =\r\ncontainer_of(ptp, struct stmmac_priv, ptp_clock_ops);\r\nunsigned long flags;\r\nu32 sec, nsec;\r\nu32 quotient, reminder;\r\nint neg_adj = 0;\r\nif (delta < 0) {\r\nneg_adj = 1;\r\ndelta = -delta;\r\n}\r\nquotient = div_u64_rem(delta, 1000000000ULL, &reminder);\r\nsec = quotient;\r\nnsec = reminder;\r\nspin_lock_irqsave(&priv->ptp_lock, flags);\r\npriv->hw->ptp->adjust_systime(priv->ptpaddr, sec, nsec, neg_adj,\r\npriv->plat->has_gmac4);\r\nspin_unlock_irqrestore(&priv->ptp_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int stmmac_get_time(struct ptp_clock_info *ptp, struct timespec64 *ts)\r\n{\r\nstruct stmmac_priv *priv =\r\ncontainer_of(ptp, struct stmmac_priv, ptp_clock_ops);\r\nunsigned long flags;\r\nu64 ns;\r\nspin_lock_irqsave(&priv->ptp_lock, flags);\r\nns = priv->hw->ptp->get_systime(priv->ptpaddr);\r\nspin_unlock_irqrestore(&priv->ptp_lock, flags);\r\n*ts = ns_to_timespec64(ns);\r\nreturn 0;\r\n}\r\nstatic int stmmac_set_time(struct ptp_clock_info *ptp,\r\nconst struct timespec64 *ts)\r\n{\r\nstruct stmmac_priv *priv =\r\ncontainer_of(ptp, struct stmmac_priv, ptp_clock_ops);\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->ptp_lock, flags);\r\npriv->hw->ptp->init_systime(priv->ptpaddr, ts->tv_sec, ts->tv_nsec);\r\nspin_unlock_irqrestore(&priv->ptp_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int stmmac_enable(struct ptp_clock_info *ptp,\r\nstruct ptp_clock_request *rq, int on)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nvoid stmmac_ptp_register(struct stmmac_priv *priv)\r\n{\r\nspin_lock_init(&priv->ptp_lock);\r\npriv->ptp_clock_ops = stmmac_ptp_clock_ops;\r\npriv->ptp_clock = ptp_clock_register(&priv->ptp_clock_ops,\r\npriv->device);\r\nif (IS_ERR(priv->ptp_clock)) {\r\nnetdev_err(priv->dev, "ptp_clock_register failed\n");\r\npriv->ptp_clock = NULL;\r\n} else if (priv->ptp_clock)\r\nnetdev_info(priv->dev, "registered PTP clock\n");\r\n}\r\nvoid stmmac_ptp_unregister(struct stmmac_priv *priv)\r\n{\r\nif (priv->ptp_clock) {\r\nptp_clock_unregister(priv->ptp_clock);\r\npriv->ptp_clock = NULL;\r\npr_debug("Removed PTP HW clock successfully on %s\n",\r\npriv->dev->name);\r\n}\r\n}
