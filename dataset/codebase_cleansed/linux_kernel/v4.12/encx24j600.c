static void dump_packet(const char *msg, int len, const char *data)\r\n{\r\npr_debug(DRV_NAME ": %s - packet len:%d\n", msg, len);\r\nprint_hex_dump_bytes("pk data: ", DUMP_PREFIX_OFFSET, data, len);\r\n}\r\nstatic void encx24j600_dump_rsv(struct encx24j600_priv *priv, const char *msg,\r\nstruct rsv *rsv)\r\n{\r\nstruct net_device *dev = priv->ndev;\r\nnetdev_info(dev, "RX packet Len:%d\n", rsv->len);\r\nnetdev_dbg(dev, "%s - NextPk: 0x%04x\n", msg,\r\nrsv->next_packet);\r\nnetdev_dbg(dev, "RxOK: %d, DribbleNibble: %d\n",\r\nRSV_GETBIT(rsv->rxstat, RSV_RXOK),\r\nRSV_GETBIT(rsv->rxstat, RSV_DRIBBLENIBBLE));\r\nnetdev_dbg(dev, "CRCErr:%d, LenChkErr: %d, LenOutOfRange: %d\n",\r\nRSV_GETBIT(rsv->rxstat, RSV_CRCERROR),\r\nRSV_GETBIT(rsv->rxstat, RSV_LENCHECKERR),\r\nRSV_GETBIT(rsv->rxstat, RSV_LENOUTOFRANGE));\r\nnetdev_dbg(dev, "Multicast: %d, Broadcast: %d, LongDropEvent: %d, CarrierEvent: %d\n",\r\nRSV_GETBIT(rsv->rxstat, RSV_RXMULTICAST),\r\nRSV_GETBIT(rsv->rxstat, RSV_RXBROADCAST),\r\nRSV_GETBIT(rsv->rxstat, RSV_RXLONGEVDROPEV),\r\nRSV_GETBIT(rsv->rxstat, RSV_CARRIEREV));\r\nnetdev_dbg(dev, "ControlFrame: %d, PauseFrame: %d, UnknownOp: %d, VLanTagFrame: %d\n",\r\nRSV_GETBIT(rsv->rxstat, RSV_RXCONTROLFRAME),\r\nRSV_GETBIT(rsv->rxstat, RSV_RXPAUSEFRAME),\r\nRSV_GETBIT(rsv->rxstat, RSV_RXUNKNOWNOPCODE),\r\nRSV_GETBIT(rsv->rxstat, RSV_RXTYPEVLAN));\r\n}\r\nstatic u16 encx24j600_read_reg(struct encx24j600_priv *priv, u8 reg)\r\n{\r\nstruct net_device *dev = priv->ndev;\r\nunsigned int val = 0;\r\nint ret = regmap_read(priv->ctx.regmap, reg, &val);\r\nif (unlikely(ret))\r\nnetif_err(priv, drv, dev, "%s: error %d reading reg %02x\n",\r\n__func__, ret, reg);\r\nreturn val;\r\n}\r\nstatic void encx24j600_write_reg(struct encx24j600_priv *priv, u8 reg, u16 val)\r\n{\r\nstruct net_device *dev = priv->ndev;\r\nint ret = regmap_write(priv->ctx.regmap, reg, val);\r\nif (unlikely(ret))\r\nnetif_err(priv, drv, dev, "%s: error %d writing reg %02x=%04x\n",\r\n__func__, ret, reg, val);\r\n}\r\nstatic void encx24j600_update_reg(struct encx24j600_priv *priv, u8 reg,\r\nu16 mask, u16 val)\r\n{\r\nstruct net_device *dev = priv->ndev;\r\nint ret = regmap_update_bits(priv->ctx.regmap, reg, mask, val);\r\nif (unlikely(ret))\r\nnetif_err(priv, drv, dev, "%s: error %d updating reg %02x=%04x~%04x\n",\r\n__func__, ret, reg, val, mask);\r\n}\r\nstatic u16 encx24j600_read_phy(struct encx24j600_priv *priv, u8 reg)\r\n{\r\nstruct net_device *dev = priv->ndev;\r\nunsigned int val = 0;\r\nint ret = regmap_read(priv->ctx.phymap, reg, &val);\r\nif (unlikely(ret))\r\nnetif_err(priv, drv, dev, "%s: error %d reading %02x\n",\r\n__func__, ret, reg);\r\nreturn val;\r\n}\r\nstatic void encx24j600_write_phy(struct encx24j600_priv *priv, u8 reg, u16 val)\r\n{\r\nstruct net_device *dev = priv->ndev;\r\nint ret = regmap_write(priv->ctx.phymap, reg, val);\r\nif (unlikely(ret))\r\nnetif_err(priv, drv, dev, "%s: error %d writing reg %02x=%04x\n",\r\n__func__, ret, reg, val);\r\n}\r\nstatic void encx24j600_clr_bits(struct encx24j600_priv *priv, u8 reg, u16 mask)\r\n{\r\nencx24j600_update_reg(priv, reg, mask, 0);\r\n}\r\nstatic void encx24j600_set_bits(struct encx24j600_priv *priv, u8 reg, u16 mask)\r\n{\r\nencx24j600_update_reg(priv, reg, mask, mask);\r\n}\r\nstatic void encx24j600_cmd(struct encx24j600_priv *priv, u8 cmd)\r\n{\r\nstruct net_device *dev = priv->ndev;\r\nint ret = regmap_write(priv->ctx.regmap, cmd, 0);\r\nif (unlikely(ret))\r\nnetif_err(priv, drv, dev, "%s: error %d with cmd %02x\n",\r\n__func__, ret, cmd);\r\n}\r\nstatic int encx24j600_raw_read(struct encx24j600_priv *priv, u8 reg, u8 *data,\r\nsize_t count)\r\n{\r\nint ret;\r\nmutex_lock(&priv->ctx.mutex);\r\nret = regmap_encx24j600_spi_read(&priv->ctx, reg, data, count);\r\nmutex_unlock(&priv->ctx.mutex);\r\nreturn ret;\r\n}\r\nstatic int encx24j600_raw_write(struct encx24j600_priv *priv, u8 reg,\r\nconst u8 *data, size_t count)\r\n{\r\nint ret;\r\nmutex_lock(&priv->ctx.mutex);\r\nret = regmap_encx24j600_spi_write(&priv->ctx, reg, data, count);\r\nmutex_unlock(&priv->ctx.mutex);\r\nreturn ret;\r\n}\r\nstatic void encx24j600_update_phcon1(struct encx24j600_priv *priv)\r\n{\r\nu16 phcon1 = encx24j600_read_phy(priv, PHCON1);\r\nif (priv->autoneg == AUTONEG_ENABLE) {\r\nphcon1 |= ANEN | RENEG;\r\n} else {\r\nphcon1 &= ~ANEN;\r\nif (priv->speed == SPEED_100)\r\nphcon1 |= SPD100;\r\nelse\r\nphcon1 &= ~SPD100;\r\nif (priv->full_duplex)\r\nphcon1 |= PFULDPX;\r\nelse\r\nphcon1 &= ~PFULDPX;\r\n}\r\nencx24j600_write_phy(priv, PHCON1, phcon1);\r\n}\r\nstatic int encx24j600_wait_for_autoneg(struct encx24j600_priv *priv)\r\n{\r\nstruct net_device *dev = priv->ndev;\r\nunsigned long timeout = jiffies + msecs_to_jiffies(2000);\r\nu16 phstat1;\r\nu16 estat;\r\nint ret = 0;\r\nphstat1 = encx24j600_read_phy(priv, PHSTAT1);\r\nwhile ((phstat1 & ANDONE) == 0) {\r\nif (time_after(jiffies, timeout)) {\r\nu16 phstat3;\r\nnetif_notice(priv, drv, dev, "timeout waiting for autoneg done\n");\r\npriv->autoneg = AUTONEG_DISABLE;\r\nphstat3 = encx24j600_read_phy(priv, PHSTAT3);\r\npriv->speed = (phstat3 & PHY3SPD100)\r\n? SPEED_100 : SPEED_10;\r\npriv->full_duplex = (phstat3 & PHY3DPX) ? 1 : 0;\r\nencx24j600_update_phcon1(priv);\r\nnetif_notice(priv, drv, dev, "Using parallel detection: %s/%s",\r\npriv->speed == SPEED_100 ? "100" : "10",\r\npriv->full_duplex ? "Full" : "Half");\r\nreturn -ETIMEDOUT;\r\n}\r\ncpu_relax();\r\nphstat1 = encx24j600_read_phy(priv, PHSTAT1);\r\n}\r\nestat = encx24j600_read_reg(priv, ESTAT);\r\nif (estat & PHYDPX) {\r\nencx24j600_set_bits(priv, MACON2, FULDPX);\r\nencx24j600_write_reg(priv, MABBIPG, 0x15);\r\n} else {\r\nencx24j600_clr_bits(priv, MACON2, FULDPX);\r\nencx24j600_write_reg(priv, MABBIPG, 0x12);\r\nencx24j600_write_reg(priv, MACLCON, 0x370f);\r\n}\r\nreturn ret;\r\n}\r\nstatic void encx24j600_check_link_status(struct encx24j600_priv *priv)\r\n{\r\nstruct net_device *dev = priv->ndev;\r\nu16 estat;\r\nestat = encx24j600_read_reg(priv, ESTAT);\r\nif (estat & PHYLNK) {\r\nif (priv->autoneg == AUTONEG_ENABLE)\r\nencx24j600_wait_for_autoneg(priv);\r\nnetif_carrier_on(dev);\r\nnetif_info(priv, ifup, dev, "link up\n");\r\n} else {\r\nnetif_info(priv, ifdown, dev, "link down\n");\r\npriv->autoneg = AUTONEG_ENABLE;\r\npriv->full_duplex = true;\r\npriv->speed = SPEED_100;\r\nnetif_carrier_off(dev);\r\n}\r\n}\r\nstatic void encx24j600_int_link_handler(struct encx24j600_priv *priv)\r\n{\r\nstruct net_device *dev = priv->ndev;\r\nnetif_dbg(priv, intr, dev, "%s", __func__);\r\nencx24j600_check_link_status(priv);\r\nencx24j600_clr_bits(priv, EIR, LINKIF);\r\n}\r\nstatic void encx24j600_tx_complete(struct encx24j600_priv *priv, bool err)\r\n{\r\nstruct net_device *dev = priv->ndev;\r\nif (!priv->tx_skb) {\r\nBUG();\r\nreturn;\r\n}\r\nmutex_lock(&priv->lock);\r\nif (err)\r\ndev->stats.tx_errors++;\r\nelse\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += priv->tx_skb->len;\r\nencx24j600_clr_bits(priv, EIR, TXIF | TXABTIF);\r\nnetif_dbg(priv, tx_done, dev, "TX Done%s\n", err ? ": Err" : "");\r\ndev_kfree_skb(priv->tx_skb);\r\npriv->tx_skb = NULL;\r\nnetif_wake_queue(dev);\r\nmutex_unlock(&priv->lock);\r\n}\r\nstatic int encx24j600_receive_packet(struct encx24j600_priv *priv,\r\nstruct rsv *rsv)\r\n{\r\nstruct net_device *dev = priv->ndev;\r\nstruct sk_buff *skb = netdev_alloc_skb(dev, rsv->len + NET_IP_ALIGN);\r\nif (!skb) {\r\npr_err_ratelimited("RX: OOM: packet dropped\n");\r\ndev->stats.rx_dropped++;\r\nreturn -ENOMEM;\r\n}\r\nskb_reserve(skb, NET_IP_ALIGN);\r\nencx24j600_raw_read(priv, RRXDATA, skb_put(skb, rsv->len), rsv->len);\r\nif (netif_msg_pktdata(priv))\r\ndump_packet("RX", skb->len, skb->data);\r\nskb->dev = dev;\r\nskb->protocol = eth_type_trans(skb, dev);\r\nskb->ip_summed = CHECKSUM_COMPLETE;\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += rsv->len;\r\nnetif_rx(skb);\r\nreturn 0;\r\n}\r\nstatic void encx24j600_rx_packets(struct encx24j600_priv *priv, u8 packet_count)\r\n{\r\nstruct net_device *dev = priv->ndev;\r\nwhile (packet_count--) {\r\nstruct rsv rsv;\r\nu16 newrxtail;\r\nencx24j600_write_reg(priv, ERXRDPT, priv->next_packet);\r\nencx24j600_raw_read(priv, RRXDATA, (u8 *)&rsv, sizeof(rsv));\r\nif (netif_msg_rx_status(priv))\r\nencx24j600_dump_rsv(priv, __func__, &rsv);\r\nif (!RSV_GETBIT(rsv.rxstat, RSV_RXOK) ||\r\n(rsv.len > MAX_FRAMELEN)) {\r\nnetif_err(priv, rx_err, dev, "RX Error %04x\n",\r\nrsv.rxstat);\r\ndev->stats.rx_errors++;\r\nif (RSV_GETBIT(rsv.rxstat, RSV_CRCERROR))\r\ndev->stats.rx_crc_errors++;\r\nif (RSV_GETBIT(rsv.rxstat, RSV_LENCHECKERR))\r\ndev->stats.rx_frame_errors++;\r\nif (rsv.len > MAX_FRAMELEN)\r\ndev->stats.rx_over_errors++;\r\n} else {\r\nencx24j600_receive_packet(priv, &rsv);\r\n}\r\npriv->next_packet = rsv.next_packet;\r\nnewrxtail = priv->next_packet - 2;\r\nif (newrxtail == ENC_RX_BUF_START)\r\nnewrxtail = SRAM_SIZE - 2;\r\nencx24j600_cmd(priv, SETPKTDEC);\r\nencx24j600_write_reg(priv, ERXTAIL, newrxtail);\r\n}\r\n}\r\nstatic irqreturn_t encx24j600_isr(int irq, void *dev_id)\r\n{\r\nstruct encx24j600_priv *priv = dev_id;\r\nstruct net_device *dev = priv->ndev;\r\nint eir;\r\nencx24j600_cmd(priv, CLREIE);\r\neir = encx24j600_read_reg(priv, EIR);\r\nif (eir & LINKIF)\r\nencx24j600_int_link_handler(priv);\r\nif (eir & TXIF)\r\nencx24j600_tx_complete(priv, false);\r\nif (eir & TXABTIF)\r\nencx24j600_tx_complete(priv, true);\r\nif (eir & RXABTIF) {\r\nif (eir & PCFULIF) {\r\nnetif_err(priv, rx_err, dev, "Packet counter full\n");\r\n}\r\ndev->stats.rx_dropped++;\r\nencx24j600_clr_bits(priv, EIR, RXABTIF);\r\n}\r\nif (eir & PKTIF) {\r\nu8 packet_count;\r\nmutex_lock(&priv->lock);\r\npacket_count = encx24j600_read_reg(priv, ESTAT) & 0xff;\r\nwhile (packet_count) {\r\nencx24j600_rx_packets(priv, packet_count);\r\npacket_count = encx24j600_read_reg(priv, ESTAT) & 0xff;\r\n}\r\nmutex_unlock(&priv->lock);\r\n}\r\nencx24j600_cmd(priv, SETEIE);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int encx24j600_soft_reset(struct encx24j600_priv *priv)\r\n{\r\nint ret = 0;\r\nint timeout;\r\nu16 eudast;\r\nregcache_cache_bypass(priv->ctx.regmap, true);\r\ntimeout = 10;\r\ndo {\r\nencx24j600_write_reg(priv, EUDAST, EUDAST_TEST_VAL);\r\neudast = encx24j600_read_reg(priv, EUDAST);\r\nusleep_range(25, 100);\r\n} while ((eudast != EUDAST_TEST_VAL) && --timeout);\r\nregcache_cache_bypass(priv->ctx.regmap, false);\r\nif (timeout == 0) {\r\nret = -ETIMEDOUT;\r\ngoto err_out;\r\n}\r\ntimeout = 10;\r\nwhile (!(encx24j600_read_reg(priv, ESTAT) & CLKRDY) && --timeout)\r\nusleep_range(25, 100);\r\nif (timeout == 0) {\r\nret = -ETIMEDOUT;\r\ngoto err_out;\r\n}\r\nencx24j600_cmd(priv, SETETHRST);\r\nusleep_range(25, 100);\r\nif (encx24j600_read_reg(priv, EUDAST) != 0) {\r\nret = -EINVAL;\r\ngoto err_out;\r\n}\r\nusleep_range(256, 1000);\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic int encx24j600_hw_reset(struct encx24j600_priv *priv)\r\n{\r\nint ret;\r\nmutex_lock(&priv->lock);\r\nret = encx24j600_soft_reset(priv);\r\nmutex_unlock(&priv->lock);\r\nreturn ret;\r\n}\r\nstatic void encx24j600_reset_hw_tx(struct encx24j600_priv *priv)\r\n{\r\nencx24j600_set_bits(priv, ECON2, TXRST);\r\nencx24j600_clr_bits(priv, ECON2, TXRST);\r\n}\r\nstatic void encx24j600_hw_init_tx(struct encx24j600_priv *priv)\r\n{\r\nencx24j600_reset_hw_tx(priv);\r\nencx24j600_clr_bits(priv, EIR, TXIF | TXABTIF);\r\nencx24j600_write_reg(priv, EGPWRPT, ENC_TX_BUF_START);\r\n}\r\nstatic void encx24j600_hw_init_rx(struct encx24j600_priv *priv)\r\n{\r\nencx24j600_cmd(priv, DISABLERX);\r\nencx24j600_write_reg(priv, ERXST, ENC_RX_BUF_START);\r\nencx24j600_write_reg(priv, ERXRDPT, ENC_RX_BUF_START);\r\npriv->next_packet = ENC_RX_BUF_START;\r\nencx24j600_write_reg(priv, ERXTAIL, ENC_SRAM_SIZE - 2);\r\nencx24j600_write_reg(priv, EUDAST, ENC_SRAM_SIZE);\r\nencx24j600_write_reg(priv, EUDAND, ENC_SRAM_SIZE + 1);\r\nencx24j600_write_reg(priv, MAMXFL, MAX_FRAMELEN);\r\n}\r\nstatic void encx24j600_dump_config(struct encx24j600_priv *priv,\r\nconst char *msg)\r\n{\r\npr_info(DRV_NAME ": %s\n", msg);\r\npr_info(DRV_NAME " ECON1: %04X\n", encx24j600_read_reg(priv, ECON1));\r\npr_info(DRV_NAME " ECON2: %04X\n", encx24j600_read_reg(priv, ECON2));\r\npr_info(DRV_NAME " ERXFCON: %04X\n", encx24j600_read_reg(priv,\r\nERXFCON));\r\npr_info(DRV_NAME " ESTAT: %04X\n", encx24j600_read_reg(priv, ESTAT));\r\npr_info(DRV_NAME " EIR: %04X\n", encx24j600_read_reg(priv, EIR));\r\npr_info(DRV_NAME " EIDLED: %04X\n", encx24j600_read_reg(priv, EIDLED));\r\npr_info(DRV_NAME " MACON1: %04X\n", encx24j600_read_reg(priv, MACON1));\r\npr_info(DRV_NAME " MACON2: %04X\n", encx24j600_read_reg(priv, MACON2));\r\npr_info(DRV_NAME " MAIPG: %04X\n", encx24j600_read_reg(priv, MAIPG));\r\npr_info(DRV_NAME " MACLCON: %04X\n", encx24j600_read_reg(priv,\r\nMACLCON));\r\npr_info(DRV_NAME " MABBIPG: %04X\n", encx24j600_read_reg(priv,\r\nMABBIPG));\r\npr_info(DRV_NAME " PHCON1: %04X\n", encx24j600_read_phy(priv, PHCON1));\r\npr_info(DRV_NAME " PHCON2: %04X\n", encx24j600_read_phy(priv, PHCON2));\r\npr_info(DRV_NAME " PHANA: %04X\n", encx24j600_read_phy(priv, PHANA));\r\npr_info(DRV_NAME " PHANLPA: %04X\n", encx24j600_read_phy(priv,\r\nPHANLPA));\r\npr_info(DRV_NAME " PHANE: %04X\n", encx24j600_read_phy(priv, PHANE));\r\npr_info(DRV_NAME " PHSTAT1: %04X\n", encx24j600_read_phy(priv,\r\nPHSTAT1));\r\npr_info(DRV_NAME " PHSTAT2: %04X\n", encx24j600_read_phy(priv,\r\nPHSTAT2));\r\npr_info(DRV_NAME " PHSTAT3: %04X\n", encx24j600_read_phy(priv,\r\nPHSTAT3));\r\n}\r\nstatic void encx24j600_set_rxfilter_mode(struct encx24j600_priv *priv)\r\n{\r\nswitch (priv->rxfilter) {\r\ncase RXFILTER_PROMISC:\r\nencx24j600_set_bits(priv, MACON1, PASSALL);\r\nencx24j600_write_reg(priv, ERXFCON, UCEN | MCEN | NOTMEEN);\r\nbreak;\r\ncase RXFILTER_MULTI:\r\nencx24j600_clr_bits(priv, MACON1, PASSALL);\r\nencx24j600_write_reg(priv, ERXFCON, UCEN | CRCEN | BCEN | MCEN);\r\nbreak;\r\ncase RXFILTER_NORMAL:\r\ndefault:\r\nencx24j600_clr_bits(priv, MACON1, PASSALL);\r\nencx24j600_write_reg(priv, ERXFCON, UCEN | CRCEN | BCEN);\r\nbreak;\r\n}\r\n}\r\nstatic int encx24j600_hw_init(struct encx24j600_priv *priv)\r\n{\r\nint ret = 0;\r\nu16 macon2;\r\npriv->hw_enabled = false;\r\nencx24j600_update_reg(priv, EIDLED, 0xff00, 0xcb00);\r\nencx24j600_write_reg(priv, MACON1, 0x9);\r\nencx24j600_write_reg(priv, MAIPG, 0x0c12);\r\nencx24j600_write_phy(priv, PHANA, PHANA_DEFAULT);\r\nencx24j600_update_phcon1(priv);\r\nencx24j600_check_link_status(priv);\r\nmacon2 = MACON2_RSV1 | TXCRCEN | PADCFG0 | PADCFG2 | MACON2_DEFER;\r\nif ((priv->autoneg == AUTONEG_DISABLE) && priv->full_duplex)\r\nmacon2 |= FULDPX;\r\nencx24j600_set_bits(priv, MACON2, macon2);\r\npriv->rxfilter = RXFILTER_NORMAL;\r\nencx24j600_set_rxfilter_mode(priv);\r\nencx24j600_write_reg(priv, MAMXFL, MAX_FRAMELEN);\r\nencx24j600_hw_init_tx(priv);\r\nencx24j600_hw_init_rx(priv);\r\nif (netif_msg_hw(priv))\r\nencx24j600_dump_config(priv, "Hw is initialized");\r\nreturn ret;\r\n}\r\nstatic void encx24j600_hw_enable(struct encx24j600_priv *priv)\r\n{\r\nencx24j600_clr_bits(priv, EIR, (PCFULIF | RXABTIF | TXABTIF | TXIF |\r\nPKTIF | LINKIF));\r\nencx24j600_write_reg(priv, EIE, (PCFULIE | RXABTIE | TXABTIE | TXIE |\r\nPKTIE | LINKIE | INTIE));\r\nencx24j600_cmd(priv, ENABLERX);\r\npriv->hw_enabled = true;\r\n}\r\nstatic void encx24j600_hw_disable(struct encx24j600_priv *priv)\r\n{\r\nencx24j600_write_reg(priv, EIE, 0);\r\nencx24j600_cmd(priv, DISABLERX);\r\npriv->hw_enabled = false;\r\n}\r\nstatic int encx24j600_setlink(struct net_device *dev, u8 autoneg, u16 speed,\r\nu8 duplex)\r\n{\r\nstruct encx24j600_priv *priv = netdev_priv(dev);\r\nint ret = 0;\r\nif (!priv->hw_enabled) {\r\nif (speed == SPEED_10 || speed == SPEED_100) {\r\npriv->autoneg = (autoneg == AUTONEG_ENABLE);\r\npriv->full_duplex = (duplex == DUPLEX_FULL);\r\npriv->speed = (speed == SPEED_100);\r\n} else {\r\nnetif_warn(priv, link, dev, "unsupported link speed setting\n");\r\nret = -EOPNOTSUPP;\r\n}\r\n} else {\r\nnetif_warn(priv, link, dev, "Warning: hw must be disabled to set link mode\n");\r\nret = -EBUSY;\r\n}\r\nreturn ret;\r\n}\r\nstatic void encx24j600_hw_get_macaddr(struct encx24j600_priv *priv,\r\nunsigned char *ethaddr)\r\n{\r\nunsigned short val;\r\nval = encx24j600_read_reg(priv, MAADR1);\r\nethaddr[0] = val & 0x00ff;\r\nethaddr[1] = (val & 0xff00) >> 8;\r\nval = encx24j600_read_reg(priv, MAADR2);\r\nethaddr[2] = val & 0x00ffU;\r\nethaddr[3] = (val & 0xff00U) >> 8;\r\nval = encx24j600_read_reg(priv, MAADR3);\r\nethaddr[4] = val & 0x00ffU;\r\nethaddr[5] = (val & 0xff00U) >> 8;\r\n}\r\nstatic int encx24j600_set_hw_macaddr(struct net_device *dev)\r\n{\r\nstruct encx24j600_priv *priv = netdev_priv(dev);\r\nif (priv->hw_enabled) {\r\nnetif_info(priv, drv, dev, "Hardware must be disabled to set Mac address\n");\r\nreturn -EBUSY;\r\n}\r\nmutex_lock(&priv->lock);\r\nnetif_info(priv, drv, dev, "%s: Setting MAC address to %pM\n",\r\ndev->name, dev->dev_addr);\r\nencx24j600_write_reg(priv, MAADR3, (dev->dev_addr[4] |\r\ndev->dev_addr[5] << 8));\r\nencx24j600_write_reg(priv, MAADR2, (dev->dev_addr[2] |\r\ndev->dev_addr[3] << 8));\r\nencx24j600_write_reg(priv, MAADR1, (dev->dev_addr[0] |\r\ndev->dev_addr[1] << 8));\r\nmutex_unlock(&priv->lock);\r\nreturn 0;\r\n}\r\nstatic int encx24j600_set_mac_address(struct net_device *dev, void *addr)\r\n{\r\nstruct sockaddr *address = addr;\r\nif (netif_running(dev))\r\nreturn -EBUSY;\r\nif (!is_valid_ether_addr(address->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(dev->dev_addr, address->sa_data, dev->addr_len);\r\nreturn encx24j600_set_hw_macaddr(dev);\r\n}\r\nstatic int encx24j600_open(struct net_device *dev)\r\n{\r\nstruct encx24j600_priv *priv = netdev_priv(dev);\r\nint ret = request_threaded_irq(priv->ctx.spi->irq, NULL, encx24j600_isr,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\nDRV_NAME, priv);\r\nif (unlikely(ret < 0)) {\r\nnetdev_err(dev, "request irq %d failed (ret = %d)\n",\r\npriv->ctx.spi->irq, ret);\r\nreturn ret;\r\n}\r\nencx24j600_hw_disable(priv);\r\nencx24j600_hw_init(priv);\r\nencx24j600_hw_enable(priv);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int encx24j600_stop(struct net_device *dev)\r\n{\r\nstruct encx24j600_priv *priv = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nfree_irq(priv->ctx.spi->irq, priv);\r\nreturn 0;\r\n}\r\nstatic void encx24j600_setrx_proc(struct kthread_work *ws)\r\n{\r\nstruct encx24j600_priv *priv =\r\ncontainer_of(ws, struct encx24j600_priv, setrx_work);\r\nmutex_lock(&priv->lock);\r\nencx24j600_set_rxfilter_mode(priv);\r\nmutex_unlock(&priv->lock);\r\n}\r\nstatic void encx24j600_set_multicast_list(struct net_device *dev)\r\n{\r\nstruct encx24j600_priv *priv = netdev_priv(dev);\r\nint oldfilter = priv->rxfilter;\r\nif (dev->flags & IFF_PROMISC) {\r\nnetif_dbg(priv, link, dev, "promiscuous mode\n");\r\npriv->rxfilter = RXFILTER_PROMISC;\r\n} else if ((dev->flags & IFF_ALLMULTI) || !netdev_mc_empty(dev)) {\r\nnetif_dbg(priv, link, dev, "%smulticast mode\n",\r\n(dev->flags & IFF_ALLMULTI) ? "all-" : "");\r\npriv->rxfilter = RXFILTER_MULTI;\r\n} else {\r\nnetif_dbg(priv, link, dev, "normal mode\n");\r\npriv->rxfilter = RXFILTER_NORMAL;\r\n}\r\nif (oldfilter != priv->rxfilter)\r\nkthread_queue_work(&priv->kworker, &priv->setrx_work);\r\n}\r\nstatic void encx24j600_hw_tx(struct encx24j600_priv *priv)\r\n{\r\nstruct net_device *dev = priv->ndev;\r\nnetif_info(priv, tx_queued, dev, "TX Packet Len:%d\n",\r\npriv->tx_skb->len);\r\nif (netif_msg_pktdata(priv))\r\ndump_packet("TX", priv->tx_skb->len, priv->tx_skb->data);\r\nif (encx24j600_read_reg(priv, EIR) & TXABTIF)\r\nencx24j600_reset_hw_tx(priv);\r\nencx24j600_clr_bits(priv, EIR, TXIF);\r\nencx24j600_write_reg(priv, EGPWRPT, ENC_TX_BUF_START);\r\nencx24j600_raw_write(priv, WGPDATA, (u8 *)priv->tx_skb->data,\r\npriv->tx_skb->len);\r\nencx24j600_write_reg(priv, ETXST, ENC_TX_BUF_START);\r\nencx24j600_write_reg(priv, ETXLEN, priv->tx_skb->len);\r\nencx24j600_cmd(priv, SETTXRTS);\r\n}\r\nstatic void encx24j600_tx_proc(struct kthread_work *ws)\r\n{\r\nstruct encx24j600_priv *priv =\r\ncontainer_of(ws, struct encx24j600_priv, tx_work);\r\nmutex_lock(&priv->lock);\r\nencx24j600_hw_tx(priv);\r\nmutex_unlock(&priv->lock);\r\n}\r\nstatic netdev_tx_t encx24j600_tx(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct encx24j600_priv *priv = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nnetif_trans_update(dev);\r\npriv->tx_skb = skb;\r\nkthread_queue_work(&priv->kworker, &priv->tx_work);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void encx24j600_tx_timeout(struct net_device *dev)\r\n{\r\nstruct encx24j600_priv *priv = netdev_priv(dev);\r\nnetif_err(priv, tx_err, dev, "TX timeout at %ld, latency %ld\n",\r\njiffies, jiffies - dev_trans_start(dev));\r\ndev->stats.tx_errors++;\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int encx24j600_get_regs_len(struct net_device *dev)\r\n{\r\nreturn SFR_REG_COUNT;\r\n}\r\nstatic void encx24j600_get_regs(struct net_device *dev,\r\nstruct ethtool_regs *regs, void *p)\r\n{\r\nstruct encx24j600_priv *priv = netdev_priv(dev);\r\nu16 *buff = p;\r\nu8 reg;\r\nregs->version = 1;\r\nmutex_lock(&priv->lock);\r\nfor (reg = 0; reg < SFR_REG_COUNT; reg += 2) {\r\nunsigned int val = 0;\r\nregmap_read(priv->ctx.regmap, reg, &val);\r\nbuff[reg] = val & 0xffff;\r\n}\r\nmutex_unlock(&priv->lock);\r\n}\r\nstatic void encx24j600_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, dev_name(dev->dev.parent),\r\nsizeof(info->bus_info));\r\n}\r\nstatic int encx24j600_get_link_ksettings(struct net_device *dev,\r\nstruct ethtool_link_ksettings *cmd)\r\n{\r\nstruct encx24j600_priv *priv = netdev_priv(dev);\r\nu32 supported;\r\nsupported = SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full |\r\nSUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |\r\nSUPPORTED_Autoneg | SUPPORTED_TP;\r\nethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\r\nsupported);\r\ncmd->base.speed = priv->speed;\r\ncmd->base.duplex = priv->full_duplex ? DUPLEX_FULL : DUPLEX_HALF;\r\ncmd->base.port = PORT_TP;\r\ncmd->base.autoneg = priv->autoneg ? AUTONEG_ENABLE : AUTONEG_DISABLE;\r\nreturn 0;\r\n}\r\nstatic int\r\nencx24j600_set_link_ksettings(struct net_device *dev,\r\nconst struct ethtool_link_ksettings *cmd)\r\n{\r\nreturn encx24j600_setlink(dev, cmd->base.autoneg,\r\ncmd->base.speed, cmd->base.duplex);\r\n}\r\nstatic u32 encx24j600_get_msglevel(struct net_device *dev)\r\n{\r\nstruct encx24j600_priv *priv = netdev_priv(dev);\r\nreturn priv->msg_enable;\r\n}\r\nstatic void encx24j600_set_msglevel(struct net_device *dev, u32 val)\r\n{\r\nstruct encx24j600_priv *priv = netdev_priv(dev);\r\npriv->msg_enable = val;\r\n}\r\nstatic int encx24j600_spi_probe(struct spi_device *spi)\r\n{\r\nint ret;\r\nstruct net_device *ndev;\r\nstruct encx24j600_priv *priv;\r\nu16 eidled;\r\nndev = alloc_etherdev(sizeof(struct encx24j600_priv));\r\nif (!ndev) {\r\nret = -ENOMEM;\r\ngoto error_out;\r\n}\r\npriv = netdev_priv(ndev);\r\nspi_set_drvdata(spi, priv);\r\ndev_set_drvdata(&spi->dev, priv);\r\nSET_NETDEV_DEV(ndev, &spi->dev);\r\npriv->msg_enable = netif_msg_init(debug, DEFAULT_MSG_ENABLE);\r\npriv->ndev = ndev;\r\npriv->full_duplex = true;\r\npriv->autoneg = AUTONEG_ENABLE;\r\npriv->speed = SPEED_100;\r\npriv->ctx.spi = spi;\r\ndevm_regmap_init_encx24j600(&spi->dev, &priv->ctx);\r\nndev->irq = spi->irq;\r\nndev->netdev_ops = &encx24j600_netdev_ops;\r\nmutex_init(&priv->lock);\r\nif (encx24j600_hw_reset(priv)) {\r\nnetif_err(priv, probe, ndev,\r\nDRV_NAME ": Chip is not detected\n");\r\nret = -EIO;\r\ngoto out_free;\r\n}\r\nif (encx24j600_hw_init(priv)) {\r\nnetif_err(priv, probe, ndev,\r\nDRV_NAME ": HW initialization error\n");\r\nret = -EIO;\r\ngoto out_free;\r\n}\r\nkthread_init_worker(&priv->kworker);\r\nkthread_init_work(&priv->tx_work, encx24j600_tx_proc);\r\nkthread_init_work(&priv->setrx_work, encx24j600_setrx_proc);\r\npriv->kworker_task = kthread_run(kthread_worker_fn, &priv->kworker,\r\n"encx24j600");\r\nif (IS_ERR(priv->kworker_task)) {\r\nret = PTR_ERR(priv->kworker_task);\r\ngoto out_free;\r\n}\r\nencx24j600_hw_get_macaddr(priv, ndev->dev_addr);\r\nndev->ethtool_ops = &encx24j600_ethtool_ops;\r\nret = register_netdev(ndev);\r\nif (unlikely(ret)) {\r\nnetif_err(priv, probe, ndev, "Error %d initializing card encx24j600 card\n",\r\nret);\r\ngoto out_free;\r\n}\r\neidled = encx24j600_read_reg(priv, EIDLED);\r\nif (((eidled & DEVID_MASK) >> DEVID_SHIFT) != ENCX24J600_DEV_ID) {\r\nret = -EINVAL;\r\ngoto out_unregister;\r\n}\r\nnetif_info(priv, probe, ndev, "Silicon rev ID: 0x%02x\n",\r\n(eidled & REVID_MASK) >> REVID_SHIFT);\r\nnetif_info(priv, drv, priv->ndev, "MAC address %pM\n", ndev->dev_addr);\r\nreturn ret;\r\nout_unregister:\r\nunregister_netdev(priv->ndev);\r\nout_free:\r\nfree_netdev(ndev);\r\nerror_out:\r\nreturn ret;\r\n}\r\nstatic int encx24j600_spi_remove(struct spi_device *spi)\r\n{\r\nstruct encx24j600_priv *priv = dev_get_drvdata(&spi->dev);\r\nunregister_netdev(priv->ndev);\r\nfree_netdev(priv->ndev);\r\nreturn 0;\r\n}\r\nstatic int __init encx24j600_init(void)\r\n{\r\nreturn spi_register_driver(&encx24j600_spi_net_driver);\r\n}\r\nstatic void encx24j600_exit(void)\r\n{\r\nspi_unregister_driver(&encx24j600_spi_net_driver);\r\n}
