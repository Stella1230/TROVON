static irqreturn_t cplds_irq_handler(int in_irq, void *d)\r\n{\r\nstruct cplds *fpga = d;\r\nunsigned long pending;\r\nunsigned int bit;\r\ndo {\r\npending = readl(fpga->base + FPGA_IRQ_SET_CLR) & fpga->irq_mask;\r\nfor_each_set_bit(bit, &pending, CPLDS_NB_IRQ) {\r\ngeneric_handle_irq(irq_find_mapping(fpga->irqdomain,\r\nbit));\r\n}\r\n} while (pending);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void cplds_irq_mask(struct irq_data *d)\r\n{\r\nstruct cplds *fpga = irq_data_get_irq_chip_data(d);\r\nunsigned int cplds_irq = irqd_to_hwirq(d);\r\nunsigned int bit = BIT(cplds_irq);\r\nfpga->irq_mask &= ~bit;\r\nwritel(fpga->irq_mask, fpga->base + FPGA_IRQ_MASK_EN);\r\n}\r\nstatic void cplds_irq_unmask(struct irq_data *d)\r\n{\r\nstruct cplds *fpga = irq_data_get_irq_chip_data(d);\r\nunsigned int cplds_irq = irqd_to_hwirq(d);\r\nunsigned int set, bit = BIT(cplds_irq);\r\nset = readl(fpga->base + FPGA_IRQ_SET_CLR);\r\nwritel(set & ~bit, fpga->base + FPGA_IRQ_SET_CLR);\r\nfpga->irq_mask |= bit;\r\nwritel(fpga->irq_mask, fpga->base + FPGA_IRQ_MASK_EN);\r\n}\r\nstatic int cplds_irq_domain_map(struct irq_domain *d, unsigned int irq,\r\nirq_hw_number_t hwirq)\r\n{\r\nstruct cplds *fpga = d->host_data;\r\nirq_set_chip_and_handler(irq, &cplds_irq_chip, handle_level_irq);\r\nirq_set_chip_data(irq, fpga);\r\nreturn 0;\r\n}\r\nstatic int cplds_resume(struct platform_device *pdev)\r\n{\r\nstruct cplds *fpga = platform_get_drvdata(pdev);\r\nwritel(fpga->irq_mask, fpga->base + FPGA_IRQ_MASK_EN);\r\nreturn 0;\r\n}\r\nstatic int cplds_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct cplds *fpga;\r\nint ret;\r\nint base_irq;\r\nunsigned long irqflags = 0;\r\nfpga = devm_kzalloc(&pdev->dev, sizeof(*fpga), GFP_KERNEL);\r\nif (!fpga)\r\nreturn -ENOMEM;\r\nfpga->irq = platform_get_irq(pdev, 0);\r\nif (fpga->irq <= 0)\r\nreturn fpga->irq;\r\nbase_irq = platform_get_irq(pdev, 1);\r\nif (base_irq < 0)\r\nbase_irq = 0;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nfpga->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(fpga->base))\r\nreturn PTR_ERR(fpga->base);\r\nplatform_set_drvdata(pdev, fpga);\r\nwritel(fpga->irq_mask, fpga->base + FPGA_IRQ_MASK_EN);\r\nwritel(0, fpga->base + FPGA_IRQ_SET_CLR);\r\nirqflags = irq_get_trigger_type(fpga->irq);\r\nret = devm_request_irq(&pdev->dev, fpga->irq, cplds_irq_handler,\r\nirqflags, dev_name(&pdev->dev), fpga);\r\nif (ret == -ENOSYS)\r\nreturn -EPROBE_DEFER;\r\nif (ret) {\r\ndev_err(&pdev->dev, "couldn't request main irq%d: %d\n",\r\nfpga->irq, ret);\r\nreturn ret;\r\n}\r\nirq_set_irq_wake(fpga->irq, 1);\r\nfpga->irqdomain = irq_domain_add_linear(pdev->dev.of_node,\r\nCPLDS_NB_IRQ,\r\n&cplds_irq_domain_ops, fpga);\r\nif (!fpga->irqdomain)\r\nreturn -ENODEV;\r\nif (base_irq) {\r\nret = irq_create_strict_mappings(fpga->irqdomain, base_irq, 0,\r\nCPLDS_NB_IRQ);\r\nif (ret) {\r\ndev_err(&pdev->dev, "couldn't create the irq mapping %d..%d\n",\r\nbase_irq, base_irq + CPLDS_NB_IRQ);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cplds_remove(struct platform_device *pdev)\r\n{\r\nstruct cplds *fpga = platform_get_drvdata(pdev);\r\nirq_set_chip_and_handler(fpga->irq, NULL, NULL);\r\nreturn 0;\r\n}
