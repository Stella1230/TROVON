static int mlxcpld_mux_reg_write(struct i2c_adapter *adap,\r\nstruct i2c_client *client, u8 val)\r\n{\r\nstruct mlxcpld_mux_plat_data *pdata = dev_get_platdata(&client->dev);\r\nint ret = -ENODEV;\r\nif (adap->algo->master_xfer) {\r\nstruct i2c_msg msg;\r\nu8 msgbuf[] = {pdata->sel_reg_addr, val};\r\nmsg.addr = client->addr;\r\nmsg.flags = 0;\r\nmsg.len = 2;\r\nmsg.buf = msgbuf;\r\nret = __i2c_transfer(adap, &msg, 1);\r\nif (ret >= 0 && ret != 1)\r\nret = -EREMOTEIO;\r\n} else if (adap->algo->smbus_xfer) {\r\nunion i2c_smbus_data data;\r\ndata.byte = val;\r\nret = adap->algo->smbus_xfer(adap, client->addr,\r\nclient->flags, I2C_SMBUS_WRITE,\r\npdata->sel_reg_addr,\r\nI2C_SMBUS_BYTE_DATA, &data);\r\n}\r\nreturn ret;\r\n}\r\nstatic int mlxcpld_mux_select_chan(struct i2c_mux_core *muxc, u32 chan)\r\n{\r\nstruct mlxcpld_mux *data = i2c_mux_priv(muxc);\r\nstruct i2c_client *client = data->client;\r\nu8 regval = chan + 1;\r\nint err = 0;\r\nif (data->last_chan != regval) {\r\nerr = mlxcpld_mux_reg_write(muxc->parent, client, regval);\r\ndata->last_chan = err < 0 ? 0 : regval;\r\n}\r\nreturn err;\r\n}\r\nstatic int mlxcpld_mux_deselect(struct i2c_mux_core *muxc, u32 chan)\r\n{\r\nstruct mlxcpld_mux *data = i2c_mux_priv(muxc);\r\nstruct i2c_client *client = data->client;\r\ndata->last_chan = 0;\r\nreturn mlxcpld_mux_reg_write(muxc->parent, client, data->last_chan);\r\n}\r\nstatic int mlxcpld_mux_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adap = to_i2c_adapter(client->dev.parent);\r\nstruct mlxcpld_mux_plat_data *pdata = dev_get_platdata(&client->dev);\r\nstruct i2c_mux_core *muxc;\r\nint num, force;\r\nstruct mlxcpld_mux *data;\r\nint err;\r\nif (!pdata)\r\nreturn -EINVAL;\r\nif (!i2c_check_functionality(adap, I2C_FUNC_SMBUS_WRITE_BYTE_DATA))\r\nreturn -ENODEV;\r\nmuxc = i2c_mux_alloc(adap, &client->dev, CPLD_MUX_MAX_NCHANS,\r\nsizeof(*data), 0, mlxcpld_mux_select_chan,\r\nmlxcpld_mux_deselect);\r\nif (!muxc)\r\nreturn -ENOMEM;\r\ndata = i2c_mux_priv(muxc);\r\ni2c_set_clientdata(client, muxc);\r\ndata->client = client;\r\ndata->last_chan = 0;\r\nfor (num = 0; num < CPLD_MUX_MAX_NCHANS; num++) {\r\nif (num >= pdata->num_adaps)\r\nbreak;\r\nforce = pdata->adap_ids[num];\r\nerr = i2c_mux_add_adapter(muxc, force, num, 0);\r\nif (err)\r\ngoto virt_reg_failed;\r\n}\r\nreturn 0;\r\nvirt_reg_failed:\r\ni2c_mux_del_adapters(muxc);\r\nreturn err;\r\n}\r\nstatic int mlxcpld_mux_remove(struct i2c_client *client)\r\n{\r\nstruct i2c_mux_core *muxc = i2c_get_clientdata(client);\r\ni2c_mux_del_adapters(muxc);\r\nreturn 0;\r\n}
