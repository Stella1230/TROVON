static int fcoe_str_to_dev_loss(const char *buf, unsigned long *val)\r\n{\r\nint ret;\r\nret = kstrtoul(buf, 0, val);\r\nif (ret)\r\nreturn -EINVAL;\r\nif (*val > UINT_MAX)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int fcoe_fcf_set_dev_loss_tmo(struct fcoe_fcf_device *fcf,\r\nunsigned long val)\r\n{\r\nif ((fcf->state == FCOE_FCF_STATE_UNKNOWN) ||\r\n(fcf->state == FCOE_FCF_STATE_DISCONNECTED) ||\r\n(fcf->state == FCOE_FCF_STATE_DELETED))\r\nreturn -EBUSY;\r\nif (val > UINT_MAX)\r\nreturn -EINVAL;\r\nfcoe_fcf_dev_loss_tmo(fcf) = val;\r\nreturn 0;\r\n}\r\nstatic enum fip_conn_type fcoe_parse_mode(const char *buf)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(fip_conn_type_names); i++) {\r\nif (strcasecmp(buf, fip_conn_type_names[i]) == 0)\r\nreturn i;\r\n}\r\nreturn FIP_CONN_TYPE_UNKNOWN;\r\n}\r\nstatic ssize_t show_fcf_state(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct fcoe_fcf_device *fcf = dev_to_fcf(dev);\r\nconst char *name;\r\nname = get_fcoe_fcf_state_name(fcf->state);\r\nif (!name)\r\nreturn -EINVAL;\r\nreturn snprintf(buf, FCOE_FCF_STATE_MAX_NAMELEN, "%s\n", name);\r\n}\r\nstatic ssize_t show_ctlr_mode(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct fcoe_ctlr_device *ctlr = dev_to_ctlr(dev);\r\nconst char *name;\r\nname = get_fcoe_ctlr_mode_name(ctlr->mode);\r\nif (!name)\r\nreturn -EINVAL;\r\nreturn snprintf(buf, FCOE_MAX_MODENAME_LEN,\r\n"%s\n", name);\r\n}\r\nstatic ssize_t store_ctlr_mode(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fcoe_ctlr_device *ctlr = dev_to_ctlr(dev);\r\nchar mode[FCOE_MAX_MODENAME_LEN + 1];\r\nif (count > FCOE_MAX_MODENAME_LEN)\r\nreturn -EINVAL;\r\nstrncpy(mode, buf, count);\r\nif (mode[count - 1] == '\n')\r\nmode[count - 1] = '\0';\r\nelse\r\nmode[count] = '\0';\r\nswitch (ctlr->enabled) {\r\ncase FCOE_CTLR_ENABLED:\r\nLIBFCOE_SYSFS_DBG(ctlr, "Cannot change mode when enabled.\n");\r\nreturn -EBUSY;\r\ncase FCOE_CTLR_DISABLED:\r\nif (!ctlr->f->set_fcoe_ctlr_mode) {\r\nLIBFCOE_SYSFS_DBG(ctlr,\r\n"Mode change not supported by LLD.\n");\r\nreturn -ENOTSUPP;\r\n}\r\nctlr->mode = fcoe_parse_mode(mode);\r\nif (ctlr->mode == FIP_CONN_TYPE_UNKNOWN) {\r\nLIBFCOE_SYSFS_DBG(ctlr, "Unknown mode %s provided.\n",\r\nbuf);\r\nreturn -EINVAL;\r\n}\r\nctlr->f->set_fcoe_ctlr_mode(ctlr);\r\nLIBFCOE_SYSFS_DBG(ctlr, "Mode changed to %s.\n", buf);\r\nreturn count;\r\ncase FCOE_CTLR_UNUSED:\r\ndefault:\r\nLIBFCOE_SYSFS_DBG(ctlr, "Mode change not supported.\n");\r\nreturn -ENOTSUPP;\r\n};\r\n}\r\nstatic ssize_t store_ctlr_enabled(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fcoe_ctlr_device *ctlr = dev_to_ctlr(dev);\r\nbool enabled;\r\nint rc;\r\nif (*buf == '1')\r\nenabled = true;\r\nelse if (*buf == '0')\r\nenabled = false;\r\nelse\r\nreturn -EINVAL;\r\nswitch (ctlr->enabled) {\r\ncase FCOE_CTLR_ENABLED:\r\nif (enabled)\r\nreturn count;\r\nctlr->enabled = FCOE_CTLR_DISABLED;\r\nbreak;\r\ncase FCOE_CTLR_DISABLED:\r\nif (!enabled)\r\nreturn count;\r\nctlr->enabled = FCOE_CTLR_ENABLED;\r\nbreak;\r\ncase FCOE_CTLR_UNUSED:\r\nreturn -ENOTSUPP;\r\n};\r\nrc = ctlr->f->set_fcoe_ctlr_enabled(ctlr);\r\nif (rc)\r\nreturn rc;\r\nreturn count;\r\n}\r\nstatic ssize_t show_ctlr_enabled_state(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct fcoe_ctlr_device *ctlr = dev_to_ctlr(dev);\r\nconst char *name;\r\nname = get_fcoe_ctlr_enabled_state_name(ctlr->enabled);\r\nif (!name)\r\nreturn -EINVAL;\r\nreturn snprintf(buf, FCOE_CTLR_ENABLED_MAX_NAMELEN,\r\n"%s\n", name);\r\n}\r\nstatic ssize_t store_ctlr_fip_resp(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fcoe_ctlr_device *ctlr = dev_to_ctlr(dev);\r\nstruct fcoe_ctlr *fip = fcoe_ctlr_device_priv(ctlr);\r\nmutex_lock(&fip->ctlr_mutex);\r\nif ((buf[1] == '\0') || ((buf[1] == '\n') && (buf[2] == '\0'))) {\r\nif (buf[0] == '1') {\r\nfip->fip_resp = 1;\r\nmutex_unlock(&fip->ctlr_mutex);\r\nreturn count;\r\n}\r\nif (buf[0] == '0') {\r\nfip->fip_resp = 0;\r\nmutex_unlock(&fip->ctlr_mutex);\r\nreturn count;\r\n}\r\n}\r\nmutex_unlock(&fip->ctlr_mutex);\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t show_ctlr_fip_resp(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct fcoe_ctlr_device *ctlr = dev_to_ctlr(dev);\r\nstruct fcoe_ctlr *fip = fcoe_ctlr_device_priv(ctlr);\r\nreturn sprintf(buf, "%d\n", fip->fip_resp ? 1 : 0);\r\n}\r\nstatic ssize_t\r\nfcoe_ctlr_var_store(u32 *var, const char *buf, size_t count)\r\n{\r\nint err;\r\nunsigned long v;\r\nerr = kstrtoul(buf, 10, &v);\r\nif (err || v > UINT_MAX)\r\nreturn -EINVAL;\r\n*var = v;\r\nreturn count;\r\n}\r\nstatic ssize_t store_ctlr_r_a_tov(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fcoe_ctlr_device *ctlr_dev = dev_to_ctlr(dev);\r\nstruct fcoe_ctlr *ctlr = fcoe_ctlr_device_priv(ctlr_dev);\r\nif (ctlr_dev->enabled == FCOE_CTLR_ENABLED)\r\nreturn -EBUSY;\r\nif (ctlr_dev->enabled == FCOE_CTLR_DISABLED)\r\nreturn fcoe_ctlr_var_store(&ctlr->lp->r_a_tov, buf, count);\r\nreturn -ENOTSUPP;\r\n}\r\nstatic ssize_t show_ctlr_r_a_tov(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct fcoe_ctlr_device *ctlr_dev = dev_to_ctlr(dev);\r\nstruct fcoe_ctlr *ctlr = fcoe_ctlr_device_priv(ctlr_dev);\r\nreturn sprintf(buf, "%d\n", ctlr->lp->r_a_tov);\r\n}\r\nstatic ssize_t store_ctlr_e_d_tov(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fcoe_ctlr_device *ctlr_dev = dev_to_ctlr(dev);\r\nstruct fcoe_ctlr *ctlr = fcoe_ctlr_device_priv(ctlr_dev);\r\nif (ctlr_dev->enabled == FCOE_CTLR_ENABLED)\r\nreturn -EBUSY;\r\nif (ctlr_dev->enabled == FCOE_CTLR_DISABLED)\r\nreturn fcoe_ctlr_var_store(&ctlr->lp->e_d_tov, buf, count);\r\nreturn -ENOTSUPP;\r\n}\r\nstatic ssize_t show_ctlr_e_d_tov(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct fcoe_ctlr_device *ctlr_dev = dev_to_ctlr(dev);\r\nstruct fcoe_ctlr *ctlr = fcoe_ctlr_device_priv(ctlr_dev);\r\nreturn sprintf(buf, "%d\n", ctlr->lp->e_d_tov);\r\n}\r\nstatic ssize_t\r\nstore_private_fcoe_ctlr_fcf_dev_loss_tmo(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fcoe_ctlr_device *ctlr = dev_to_ctlr(dev);\r\nstruct fcoe_fcf_device *fcf;\r\nunsigned long val;\r\nint rc;\r\nrc = fcoe_str_to_dev_loss(buf, &val);\r\nif (rc)\r\nreturn rc;\r\nfcoe_ctlr_fcf_dev_loss_tmo(ctlr) = val;\r\nmutex_lock(&ctlr->lock);\r\nlist_for_each_entry(fcf, &ctlr->fcfs, peers)\r\nfcoe_fcf_set_dev_loss_tmo(fcf, val);\r\nmutex_unlock(&ctlr->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nstore_fcoe_fcf_dev_loss_tmo(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fcoe_fcf_device *fcf = dev_to_fcf(dev);\r\nunsigned long val;\r\nint rc;\r\nrc = fcoe_str_to_dev_loss(buf, &val);\r\nif (rc)\r\nreturn rc;\r\nrc = fcoe_fcf_set_dev_loss_tmo(fcf, val);\r\nif (rc)\r\nreturn rc;\r\nreturn count;\r\n}\r\nstatic int fcoe_bus_match(struct device *dev,\r\nstruct device_driver *drv)\r\n{\r\nif (dev->bus == &fcoe_bus_type)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void fcoe_ctlr_device_release(struct device *dev)\r\n{\r\nstruct fcoe_ctlr_device *ctlr = dev_to_ctlr(dev);\r\nkfree(ctlr);\r\n}\r\nstatic void fcoe_fcf_device_release(struct device *dev)\r\n{\r\nstruct fcoe_fcf_device *fcf = dev_to_fcf(dev);\r\nkfree(fcf);\r\n}\r\nstatic void fcoe_ctlr_device_flush_work(struct fcoe_ctlr_device *ctlr)\r\n{\r\nif (!fcoe_ctlr_work_q(ctlr)) {\r\nprintk(KERN_ERR\r\n"ERROR: FIP Ctlr '%d' attempted to flush work, "\r\n"when no workqueue created.\n", ctlr->id);\r\ndump_stack();\r\nreturn;\r\n}\r\nflush_workqueue(fcoe_ctlr_work_q(ctlr));\r\n}\r\nstatic int fcoe_ctlr_device_queue_work(struct fcoe_ctlr_device *ctlr,\r\nstruct work_struct *work)\r\n{\r\nif (unlikely(!fcoe_ctlr_work_q(ctlr))) {\r\nprintk(KERN_ERR\r\n"ERROR: FIP Ctlr '%d' attempted to queue work, "\r\n"when no workqueue created.\n", ctlr->id);\r\ndump_stack();\r\nreturn -EINVAL;\r\n}\r\nreturn queue_work(fcoe_ctlr_work_q(ctlr), work);\r\n}\r\nstatic void fcoe_ctlr_device_flush_devloss(struct fcoe_ctlr_device *ctlr)\r\n{\r\nif (!fcoe_ctlr_devloss_work_q(ctlr)) {\r\nprintk(KERN_ERR\r\n"ERROR: FIP Ctlr '%d' attempted to flush work, "\r\n"when no workqueue created.\n", ctlr->id);\r\ndump_stack();\r\nreturn;\r\n}\r\nflush_workqueue(fcoe_ctlr_devloss_work_q(ctlr));\r\n}\r\nstatic int fcoe_ctlr_device_queue_devloss_work(struct fcoe_ctlr_device *ctlr,\r\nstruct delayed_work *work,\r\nunsigned long delay)\r\n{\r\nif (unlikely(!fcoe_ctlr_devloss_work_q(ctlr))) {\r\nprintk(KERN_ERR\r\n"ERROR: FIP Ctlr '%d' attempted to queue work, "\r\n"when no workqueue created.\n", ctlr->id);\r\ndump_stack();\r\nreturn -EINVAL;\r\n}\r\nreturn queue_delayed_work(fcoe_ctlr_devloss_work_q(ctlr), work, delay);\r\n}\r\nstatic int fcoe_fcf_device_match(struct fcoe_fcf_device *new,\r\nstruct fcoe_fcf_device *old)\r\n{\r\nif (new->switch_name == old->switch_name &&\r\nnew->fabric_name == old->fabric_name &&\r\nnew->fc_map == old->fc_map &&\r\nether_addr_equal(new->mac, old->mac))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstruct fcoe_ctlr_device *fcoe_ctlr_device_add(struct device *parent,\r\nstruct fcoe_sysfs_function_template *f,\r\nint priv_size)\r\n{\r\nstruct fcoe_ctlr_device *ctlr;\r\nint error = 0;\r\nctlr = kzalloc(sizeof(struct fcoe_ctlr_device) + priv_size,\r\nGFP_KERNEL);\r\nif (!ctlr)\r\ngoto out;\r\nctlr->id = atomic_inc_return(&ctlr_num) - 1;\r\nctlr->f = f;\r\nctlr->mode = FIP_CONN_TYPE_FABRIC;\r\nINIT_LIST_HEAD(&ctlr->fcfs);\r\nmutex_init(&ctlr->lock);\r\nctlr->dev.parent = parent;\r\nctlr->dev.bus = &fcoe_bus_type;\r\nctlr->dev.type = &fcoe_ctlr_device_type;\r\nctlr->fcf_dev_loss_tmo = fcoe_fcf_dev_loss_tmo;\r\nsnprintf(ctlr->work_q_name, sizeof(ctlr->work_q_name),\r\n"ctlr_wq_%d", ctlr->id);\r\nctlr->work_q = create_singlethread_workqueue(\r\nctlr->work_q_name);\r\nif (!ctlr->work_q)\r\ngoto out_del;\r\nsnprintf(ctlr->devloss_work_q_name,\r\nsizeof(ctlr->devloss_work_q_name),\r\n"ctlr_dl_wq_%d", ctlr->id);\r\nctlr->devloss_work_q = create_singlethread_workqueue(\r\nctlr->devloss_work_q_name);\r\nif (!ctlr->devloss_work_q)\r\ngoto out_del_q;\r\ndev_set_name(&ctlr->dev, "ctlr_%d", ctlr->id);\r\nerror = device_register(&ctlr->dev);\r\nif (error)\r\ngoto out_del_q2;\r\nreturn ctlr;\r\nout_del_q2:\r\ndestroy_workqueue(ctlr->devloss_work_q);\r\nctlr->devloss_work_q = NULL;\r\nout_del_q:\r\ndestroy_workqueue(ctlr->work_q);\r\nctlr->work_q = NULL;\r\nout_del:\r\nkfree(ctlr);\r\nout:\r\nreturn NULL;\r\n}\r\nvoid fcoe_ctlr_device_delete(struct fcoe_ctlr_device *ctlr)\r\n{\r\nstruct fcoe_fcf_device *fcf, *next;\r\nmutex_lock(&ctlr->lock);\r\nlist_for_each_entry_safe(fcf, next,\r\n&ctlr->fcfs, peers) {\r\nlist_del(&fcf->peers);\r\nfcf->state = FCOE_FCF_STATE_DELETED;\r\nfcoe_ctlr_device_queue_work(ctlr, &fcf->delete_work);\r\n}\r\nmutex_unlock(&ctlr->lock);\r\nfcoe_ctlr_device_flush_work(ctlr);\r\ndestroy_workqueue(ctlr->devloss_work_q);\r\nctlr->devloss_work_q = NULL;\r\ndestroy_workqueue(ctlr->work_q);\r\nctlr->work_q = NULL;\r\ndevice_unregister(&ctlr->dev);\r\n}\r\nstatic void fcoe_fcf_device_final_delete(struct work_struct *work)\r\n{\r\nstruct fcoe_fcf_device *fcf =\r\ncontainer_of(work, struct fcoe_fcf_device, delete_work);\r\nstruct fcoe_ctlr_device *ctlr = fcoe_fcf_dev_to_ctlr_dev(fcf);\r\nif (!cancel_delayed_work(&fcf->dev_loss_work))\r\nfcoe_ctlr_device_flush_devloss(ctlr);\r\ndevice_unregister(&fcf->dev);\r\n}\r\nstatic void fip_timeout_deleted_fcf(struct work_struct *work)\r\n{\r\nstruct fcoe_fcf_device *fcf =\r\ncontainer_of(work, struct fcoe_fcf_device, dev_loss_work.work);\r\nstruct fcoe_ctlr_device *ctlr = fcoe_fcf_dev_to_ctlr_dev(fcf);\r\nmutex_lock(&ctlr->lock);\r\nif (fcf->state != FCOE_FCF_STATE_DISCONNECTED)\r\ngoto out;\r\ndev_printk(KERN_ERR, &fcf->dev,\r\n"FIP fcf connection time out: removing fcf\n");\r\nlist_del(&fcf->peers);\r\nfcf->state = FCOE_FCF_STATE_DELETED;\r\nfcoe_ctlr_device_queue_work(ctlr, &fcf->delete_work);\r\nout:\r\nmutex_unlock(&ctlr->lock);\r\n}\r\nvoid fcoe_fcf_device_delete(struct fcoe_fcf_device *fcf)\r\n{\r\nstruct fcoe_ctlr_device *ctlr = fcoe_fcf_dev_to_ctlr_dev(fcf);\r\nint timeout = fcf->dev_loss_tmo;\r\nif (fcf->state != FCOE_FCF_STATE_CONNECTED)\r\nreturn;\r\nfcf->state = FCOE_FCF_STATE_DISCONNECTED;\r\nfcf->priv = NULL;\r\nfcoe_ctlr_device_queue_devloss_work(ctlr, &fcf->dev_loss_work,\r\ntimeout * HZ);\r\n}\r\nstruct fcoe_fcf_device *fcoe_fcf_device_add(struct fcoe_ctlr_device *ctlr,\r\nstruct fcoe_fcf_device *new_fcf)\r\n{\r\nstruct fcoe_fcf_device *fcf;\r\nint error = 0;\r\nlist_for_each_entry(fcf, &ctlr->fcfs, peers) {\r\nif (fcoe_fcf_device_match(new_fcf, fcf)) {\r\nif (fcf->state == FCOE_FCF_STATE_CONNECTED)\r\nreturn fcf;\r\nfcf->state = FCOE_FCF_STATE_CONNECTED;\r\nif (!cancel_delayed_work(&fcf->dev_loss_work))\r\nfcoe_ctlr_device_flush_devloss(ctlr);\r\nreturn fcf;\r\n}\r\n}\r\nfcf = kzalloc(sizeof(struct fcoe_fcf_device), GFP_ATOMIC);\r\nif (unlikely(!fcf))\r\ngoto out;\r\nINIT_WORK(&fcf->delete_work, fcoe_fcf_device_final_delete);\r\nINIT_DELAYED_WORK(&fcf->dev_loss_work, fip_timeout_deleted_fcf);\r\nfcf->dev.parent = &ctlr->dev;\r\nfcf->dev.bus = &fcoe_bus_type;\r\nfcf->dev.type = &fcoe_fcf_device_type;\r\nfcf->id = atomic_inc_return(&fcf_num) - 1;\r\nfcf->state = FCOE_FCF_STATE_UNKNOWN;\r\nfcf->dev_loss_tmo = ctlr->fcf_dev_loss_tmo;\r\ndev_set_name(&fcf->dev, "fcf_%d", fcf->id);\r\nfcf->fabric_name = new_fcf->fabric_name;\r\nfcf->switch_name = new_fcf->switch_name;\r\nfcf->fc_map = new_fcf->fc_map;\r\nfcf->vfid = new_fcf->vfid;\r\nmemcpy(fcf->mac, new_fcf->mac, ETH_ALEN);\r\nfcf->priority = new_fcf->priority;\r\nfcf->fka_period = new_fcf->fka_period;\r\nfcf->selected = new_fcf->selected;\r\nerror = device_register(&fcf->dev);\r\nif (error)\r\ngoto out_del;\r\nfcf->state = FCOE_FCF_STATE_CONNECTED;\r\nlist_add_tail(&fcf->peers, &ctlr->fcfs);\r\nreturn fcf;\r\nout_del:\r\nkfree(fcf);\r\nout:\r\nreturn NULL;\r\n}\r\nint __init fcoe_sysfs_setup(void)\r\n{\r\nint error;\r\natomic_set(&ctlr_num, 0);\r\natomic_set(&fcf_num, 0);\r\nerror = bus_register(&fcoe_bus_type);\r\nif (error)\r\nreturn error;\r\nreturn 0;\r\n}\r\nvoid __exit fcoe_sysfs_teardown(void)\r\n{\r\nbus_unregister(&fcoe_bus_type);\r\n}
