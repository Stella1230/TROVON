void tw686x_audio_irq(struct tw686x_dev *dev, unsigned long requests,\r\nunsigned int pb_status)\r\n{\r\nunsigned long flags;\r\nunsigned int ch, pb;\r\nfor_each_set_bit(ch, &requests, max_channels(dev)) {\r\nstruct tw686x_audio_channel *ac = &dev->audio_channels[ch];\r\nstruct tw686x_audio_buf *done = NULL;\r\nstruct tw686x_audio_buf *next = NULL;\r\nstruct tw686x_dma_desc *desc;\r\npb = !!(pb_status & BIT(AUDIO_CHANNEL_OFFSET + ch));\r\nspin_lock_irqsave(&ac->lock, flags);\r\nif (!ac->ss || !ac->curr_bufs[0] || !ac->curr_bufs[1]) {\r\nspin_unlock_irqrestore(&ac->lock, flags);\r\ncontinue;\r\n}\r\nif (!list_empty(&ac->buf_list)) {\r\nnext = list_first_entry(&ac->buf_list,\r\nstruct tw686x_audio_buf, list);\r\nlist_move_tail(&next->list, &ac->buf_list);\r\ndone = ac->curr_bufs[!pb];\r\nac->curr_bufs[pb] = next;\r\n}\r\nspin_unlock_irqrestore(&ac->lock, flags);\r\nif (!done || !next)\r\ncontinue;\r\ndesc = &ac->dma_descs[pb];\r\nif (desc->virt) {\r\nmemcpy(done->virt, desc->virt,\r\ndev->period_size);\r\n} else {\r\nu32 reg = pb ? ADMA_B_ADDR[ch] : ADMA_P_ADDR[ch];\r\nreg_write(dev, reg, next->dma);\r\n}\r\nac->ptr = done->dma - ac->buf[0].dma;\r\nsnd_pcm_period_elapsed(ac->ss);\r\n}\r\n}\r\nstatic int tw686x_pcm_hw_params(struct snd_pcm_substream *ss,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_pcm_lib_malloc_pages(ss, params_buffer_bytes(hw_params));\r\n}\r\nstatic int tw686x_pcm_hw_free(struct snd_pcm_substream *ss)\r\n{\r\nreturn snd_pcm_lib_free_pages(ss);\r\n}\r\nstatic int tw686x_pcm_open(struct snd_pcm_substream *ss)\r\n{\r\nstruct tw686x_dev *dev = snd_pcm_substream_chip(ss);\r\nstruct tw686x_audio_channel *ac = &dev->audio_channels[ss->number];\r\nstruct snd_pcm_runtime *rt = ss->runtime;\r\nint err;\r\nac->ss = ss;\r\nrt->hw = tw686x_capture_hw;\r\nerr = snd_pcm_hw_constraint_integer(rt, SNDRV_PCM_HW_PARAM_PERIODS);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int tw686x_pcm_close(struct snd_pcm_substream *ss)\r\n{\r\nstruct tw686x_dev *dev = snd_pcm_substream_chip(ss);\r\nstruct tw686x_audio_channel *ac = &dev->audio_channels[ss->number];\r\nac->ss = NULL;\r\nreturn 0;\r\n}\r\nstatic int tw686x_pcm_prepare(struct snd_pcm_substream *ss)\r\n{\r\nstruct tw686x_dev *dev = snd_pcm_substream_chip(ss);\r\nstruct tw686x_audio_channel *ac = &dev->audio_channels[ss->number];\r\nstruct snd_pcm_runtime *rt = ss->runtime;\r\nunsigned int period_size = snd_pcm_lib_period_bytes(ss);\r\nstruct tw686x_audio_buf *p_buf, *b_buf;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&dev->lock, flags);\r\nif (((dev->audio_rate != rt->rate) ||\r\n(dev->period_size != period_size)) && dev->audio_enabled)\r\ngoto err_audio_busy;\r\ntw686x_disable_channel(dev, AUDIO_CHANNEL_OFFSET + ac->ch);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nif (dev->audio_rate != rt->rate) {\r\nu32 reg;\r\ndev->audio_rate = rt->rate;\r\nreg = ((125000000 / rt->rate) << 16) +\r\n((125000000 % rt->rate) << 16) / rt->rate;\r\nreg_write(dev, AUDIO_CONTROL2, reg);\r\n}\r\nif (dev->period_size != period_size) {\r\nu32 reg;\r\ndev->period_size = period_size;\r\nreg = reg_read(dev, AUDIO_CONTROL1);\r\nreg &= ~(AUDIO_DMA_SIZE_MASK << AUDIO_DMA_SIZE_SHIFT);\r\nreg |= period_size << AUDIO_DMA_SIZE_SHIFT;\r\nreg_write(dev, AUDIO_CONTROL1, reg);\r\n}\r\nif (rt->periods < TW686X_AUDIO_PERIODS_MIN ||\r\nrt->periods > TW686X_AUDIO_PERIODS_MAX)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&ac->lock, flags);\r\nINIT_LIST_HEAD(&ac->buf_list);\r\nfor (i = 0; i < rt->periods; i++) {\r\nac->buf[i].dma = rt->dma_addr + period_size * i;\r\nac->buf[i].virt = rt->dma_area + period_size * i;\r\nINIT_LIST_HEAD(&ac->buf[i].list);\r\nlist_add_tail(&ac->buf[i].list, &ac->buf_list);\r\n}\r\np_buf = list_first_entry(&ac->buf_list, struct tw686x_audio_buf, list);\r\nlist_move_tail(&p_buf->list, &ac->buf_list);\r\nb_buf = list_first_entry(&ac->buf_list, struct tw686x_audio_buf, list);\r\nlist_move_tail(&b_buf->list, &ac->buf_list);\r\nac->curr_bufs[0] = p_buf;\r\nac->curr_bufs[1] = b_buf;\r\nac->ptr = 0;\r\nif (dev->dma_mode != TW686X_DMA_MODE_MEMCPY) {\r\nreg_write(dev, ADMA_P_ADDR[ac->ch], p_buf->dma);\r\nreg_write(dev, ADMA_B_ADDR[ac->ch], b_buf->dma);\r\n}\r\nspin_unlock_irqrestore(&ac->lock, flags);\r\nreturn 0;\r\nerr_audio_busy:\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn -EBUSY;\r\n}\r\nstatic int tw686x_pcm_trigger(struct snd_pcm_substream *ss, int cmd)\r\n{\r\nstruct tw686x_dev *dev = snd_pcm_substream_chip(ss);\r\nstruct tw686x_audio_channel *ac = &dev->audio_channels[ss->number];\r\nunsigned long flags;\r\nint err = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nif (ac->curr_bufs[0] && ac->curr_bufs[1]) {\r\nspin_lock_irqsave(&dev->lock, flags);\r\ndev->audio_enabled = 1;\r\ntw686x_enable_channel(dev,\r\nAUDIO_CHANNEL_OFFSET + ac->ch);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nmod_timer(&dev->dma_delay_timer,\r\njiffies + msecs_to_jiffies(100));\r\n} else {\r\nerr = -EIO;\r\n}\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nspin_lock_irqsave(&dev->lock, flags);\r\ndev->audio_enabled = 0;\r\ntw686x_disable_channel(dev, AUDIO_CHANNEL_OFFSET + ac->ch);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nspin_lock_irqsave(&ac->lock, flags);\r\nac->curr_bufs[0] = NULL;\r\nac->curr_bufs[1] = NULL;\r\nspin_unlock_irqrestore(&ac->lock, flags);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic snd_pcm_uframes_t tw686x_pcm_pointer(struct snd_pcm_substream *ss)\r\n{\r\nstruct tw686x_dev *dev = snd_pcm_substream_chip(ss);\r\nstruct tw686x_audio_channel *ac = &dev->audio_channels[ss->number];\r\nreturn bytes_to_frames(ss->runtime, ac->ptr);\r\n}\r\nstatic int tw686x_snd_pcm_init(struct tw686x_dev *dev)\r\n{\r\nstruct snd_card *card = dev->snd_card;\r\nstruct snd_pcm *pcm;\r\nstruct snd_pcm_substream *ss;\r\nunsigned int i;\r\nint err;\r\nerr = snd_pcm_new(card, card->driver, 0, 0, max_channels(dev), &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &tw686x_pcm_ops);\r\nsnd_pcm_chip(pcm) = dev;\r\npcm->info_flags = 0;\r\nstrlcpy(pcm->name, "tw686x PCM", sizeof(pcm->name));\r\nfor (i = 0, ss = pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream;\r\nss; ss = ss->next, i++)\r\nsnprintf(ss->name, sizeof(ss->name), "vch%u audio", i);\r\nreturn snd_pcm_lib_preallocate_pages_for_all(pcm,\r\nSNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(dev->pci_dev),\r\nTW686X_AUDIO_PAGE_MAX * AUDIO_DMA_SIZE_MAX,\r\nTW686X_AUDIO_PAGE_MAX * AUDIO_DMA_SIZE_MAX);\r\n}\r\nstatic void tw686x_audio_dma_free(struct tw686x_dev *dev,\r\nstruct tw686x_audio_channel *ac)\r\n{\r\nint pb;\r\nfor (pb = 0; pb < 2; pb++) {\r\nif (!ac->dma_descs[pb].virt)\r\ncontinue;\r\npci_free_consistent(dev->pci_dev, ac->dma_descs[pb].size,\r\nac->dma_descs[pb].virt,\r\nac->dma_descs[pb].phys);\r\nac->dma_descs[pb].virt = NULL;\r\n}\r\n}\r\nstatic int tw686x_audio_dma_alloc(struct tw686x_dev *dev,\r\nstruct tw686x_audio_channel *ac)\r\n{\r\nint pb;\r\nif (dev->dma_mode != TW686X_DMA_MODE_MEMCPY)\r\nreturn 0;\r\nfor (pb = 0; pb < 2; pb++) {\r\nu32 reg = pb ? ADMA_B_ADDR[ac->ch] : ADMA_P_ADDR[ac->ch];\r\nvoid *virt;\r\nvirt = pci_alloc_consistent(dev->pci_dev, AUDIO_DMA_SIZE_MAX,\r\n&ac->dma_descs[pb].phys);\r\nif (!virt) {\r\ndev_err(&dev->pci_dev->dev,\r\n"dma%d: unable to allocate audio DMA %s-buffer\n",\r\nac->ch, pb ? "B" : "P");\r\nreturn -ENOMEM;\r\n}\r\nac->dma_descs[pb].virt = virt;\r\nac->dma_descs[pb].size = AUDIO_DMA_SIZE_MAX;\r\nreg_write(dev, reg, ac->dma_descs[pb].phys);\r\n}\r\nreturn 0;\r\n}\r\nvoid tw686x_audio_free(struct tw686x_dev *dev)\r\n{\r\nunsigned long flags;\r\nu32 dma_ch_mask;\r\nu32 dma_cmd;\r\nspin_lock_irqsave(&dev->lock, flags);\r\ndma_cmd = reg_read(dev, DMA_CMD);\r\ndma_ch_mask = reg_read(dev, DMA_CHANNEL_ENABLE);\r\nreg_write(dev, DMA_CMD, dma_cmd & ~0xff00);\r\nreg_write(dev, DMA_CHANNEL_ENABLE, dma_ch_mask & ~0xff00);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nif (!dev->snd_card)\r\nreturn;\r\nsnd_card_free(dev->snd_card);\r\ndev->snd_card = NULL;\r\n}\r\nint tw686x_audio_init(struct tw686x_dev *dev)\r\n{\r\nstruct pci_dev *pci_dev = dev->pci_dev;\r\nstruct snd_card *card;\r\nint err, ch;\r\nreg_write(dev, AUDIO_CONTROL1, BIT(0));\r\nerr = snd_card_new(&pci_dev->dev, SNDRV_DEFAULT_IDX1,\r\nSNDRV_DEFAULT_STR1,\r\nTHIS_MODULE, 0, &card);\r\nif (err < 0)\r\nreturn err;\r\ndev->snd_card = card;\r\nstrlcpy(card->driver, "tw686x", sizeof(card->driver));\r\nstrlcpy(card->shortname, "tw686x", sizeof(card->shortname));\r\nstrlcpy(card->longname, pci_name(pci_dev), sizeof(card->longname));\r\nsnd_card_set_dev(card, &pci_dev->dev);\r\nfor (ch = 0; ch < max_channels(dev); ch++) {\r\nstruct tw686x_audio_channel *ac;\r\nac = &dev->audio_channels[ch];\r\nspin_lock_init(&ac->lock);\r\nac->dev = dev;\r\nac->ch = ch;\r\nerr = tw686x_audio_dma_alloc(dev, ac);\r\nif (err < 0)\r\ngoto err_cleanup;\r\n}\r\nerr = tw686x_snd_pcm_init(dev);\r\nif (err < 0)\r\ngoto err_cleanup;\r\nerr = snd_card_register(card);\r\nif (!err)\r\nreturn 0;\r\nerr_cleanup:\r\nfor (ch = 0; ch < max_channels(dev); ch++) {\r\nif (!dev->audio_channels[ch].dev)\r\ncontinue;\r\ntw686x_audio_dma_free(dev, &dev->audio_channels[ch]);\r\n}\r\nsnd_card_free(card);\r\ndev->snd_card = NULL;\r\nreturn err;\r\n}
