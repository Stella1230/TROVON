bool afs_cm_incoming_call(struct afs_call *call)\r\n{\r\n_enter("{CB.OP %u}", call->operation_ID);\r\nswitch (call->operation_ID) {\r\ncase CBCallBack:\r\ncall->type = &afs_SRXCBCallBack;\r\nreturn true;\r\ncase CBInitCallBackState:\r\ncall->type = &afs_SRXCBInitCallBackState;\r\nreturn true;\r\ncase CBInitCallBackState3:\r\ncall->type = &afs_SRXCBInitCallBackState3;\r\nreturn true;\r\ncase CBProbe:\r\ncall->type = &afs_SRXCBProbe;\r\nreturn true;\r\ncase CBTellMeAboutYourself:\r\ncall->type = &afs_SRXCBTellMeAboutYourself;\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic void afs_cm_destructor(struct afs_call *call)\r\n{\r\n_enter("");\r\nif (call->unmarshall == 5) {\r\nASSERT(call->server && call->count && call->request);\r\nafs_break_callbacks(call->server, call->count, call->request);\r\n}\r\nafs_put_server(call->server);\r\ncall->server = NULL;\r\nkfree(call->buffer);\r\ncall->buffer = NULL;\r\n}\r\nstatic void SRXAFSCB_CallBack(struct work_struct *work)\r\n{\r\nstruct afs_call *call = container_of(work, struct afs_call, work);\r\n_enter("");\r\nafs_send_empty_reply(call);\r\nafs_break_callbacks(call->server, call->count, call->request);\r\nafs_put_call(call);\r\n_leave("");\r\n}\r\nstatic int afs_deliver_cb_callback(struct afs_call *call)\r\n{\r\nstruct sockaddr_rxrpc srx;\r\nstruct afs_callback *cb;\r\nstruct afs_server *server;\r\n__be32 *bp;\r\nint ret, loop;\r\n_enter("{%u}", call->unmarshall);\r\nswitch (call->unmarshall) {\r\ncase 0:\r\nrxrpc_kernel_get_peer(afs_socket, call->rxcall, &srx);\r\ncall->offset = 0;\r\ncall->unmarshall++;\r\ncase 1:\r\n_debug("extract FID count");\r\nret = afs_extract_data(call, &call->tmp, 4, true);\r\nif (ret < 0)\r\nreturn ret;\r\ncall->count = ntohl(call->tmp);\r\n_debug("FID count: %u", call->count);\r\nif (call->count > AFSCBMAX)\r\nreturn -EBADMSG;\r\ncall->buffer = kmalloc(call->count * 3 * 4, GFP_KERNEL);\r\nif (!call->buffer)\r\nreturn -ENOMEM;\r\ncall->offset = 0;\r\ncall->unmarshall++;\r\ncase 2:\r\n_debug("extract FID array");\r\nret = afs_extract_data(call, call->buffer,\r\ncall->count * 3 * 4, true);\r\nif (ret < 0)\r\nreturn ret;\r\n_debug("unmarshall FID array");\r\ncall->request = kcalloc(call->count,\r\nsizeof(struct afs_callback),\r\nGFP_KERNEL);\r\nif (!call->request)\r\nreturn -ENOMEM;\r\ncb = call->request;\r\nbp = call->buffer;\r\nfor (loop = call->count; loop > 0; loop--, cb++) {\r\ncb->fid.vid = ntohl(*bp++);\r\ncb->fid.vnode = ntohl(*bp++);\r\ncb->fid.unique = ntohl(*bp++);\r\ncb->type = AFSCM_CB_UNTYPED;\r\n}\r\ncall->offset = 0;\r\ncall->unmarshall++;\r\ncase 3:\r\n_debug("extract CB count");\r\nret = afs_extract_data(call, &call->tmp, 4, true);\r\nif (ret < 0)\r\nreturn ret;\r\ncall->count2 = ntohl(call->tmp);\r\n_debug("CB count: %u", call->count2);\r\nif (call->count2 != call->count && call->count2 != 0)\r\nreturn -EBADMSG;\r\ncall->offset = 0;\r\ncall->unmarshall++;\r\ncase 4:\r\n_debug("extract CB array");\r\nret = afs_extract_data(call, call->buffer,\r\ncall->count2 * 3 * 4, false);\r\nif (ret < 0)\r\nreturn ret;\r\n_debug("unmarshall CB array");\r\ncb = call->request;\r\nbp = call->buffer;\r\nfor (loop = call->count2; loop > 0; loop--, cb++) {\r\ncb->version = ntohl(*bp++);\r\ncb->expiry = ntohl(*bp++);\r\ncb->type = ntohl(*bp++);\r\n}\r\ncall->offset = 0;\r\ncall->unmarshall++;\r\ncall->unmarshall++;\r\ncase 5:\r\nbreak;\r\n}\r\ncall->state = AFS_CALL_REPLYING;\r\nserver = afs_find_server(&srx);\r\nif (!server)\r\nreturn -ENOTCONN;\r\ncall->server = server;\r\nreturn afs_queue_call_work(call);\r\n}\r\nstatic void SRXAFSCB_InitCallBackState(struct work_struct *work)\r\n{\r\nstruct afs_call *call = container_of(work, struct afs_call, work);\r\n_enter("{%p}", call->server);\r\nafs_init_callback_state(call->server);\r\nafs_send_empty_reply(call);\r\nafs_put_call(call);\r\n_leave("");\r\n}\r\nstatic int afs_deliver_cb_init_call_back_state(struct afs_call *call)\r\n{\r\nstruct sockaddr_rxrpc srx;\r\nstruct afs_server *server;\r\nint ret;\r\n_enter("");\r\nrxrpc_kernel_get_peer(afs_socket, call->rxcall, &srx);\r\nret = afs_extract_data(call, NULL, 0, false);\r\nif (ret < 0)\r\nreturn ret;\r\ncall->state = AFS_CALL_REPLYING;\r\nserver = afs_find_server(&srx);\r\nif (!server)\r\nreturn -ENOTCONN;\r\ncall->server = server;\r\nreturn afs_queue_call_work(call);\r\n}\r\nstatic int afs_deliver_cb_init_call_back_state3(struct afs_call *call)\r\n{\r\nstruct sockaddr_rxrpc srx;\r\nstruct afs_server *server;\r\nstruct uuid_v1 *r;\r\nunsigned loop;\r\n__be32 *b;\r\nint ret;\r\n_enter("");\r\nrxrpc_kernel_get_peer(afs_socket, call->rxcall, &srx);\r\n_enter("{%u}", call->unmarshall);\r\nswitch (call->unmarshall) {\r\ncase 0:\r\ncall->offset = 0;\r\ncall->buffer = kmalloc(11 * sizeof(__be32), GFP_KERNEL);\r\nif (!call->buffer)\r\nreturn -ENOMEM;\r\ncall->unmarshall++;\r\ncase 1:\r\n_debug("extract UUID");\r\nret = afs_extract_data(call, call->buffer,\r\n11 * sizeof(__be32), false);\r\nswitch (ret) {\r\ncase 0: break;\r\ncase -EAGAIN: return 0;\r\ndefault: return ret;\r\n}\r\n_debug("unmarshall UUID");\r\ncall->request = kmalloc(sizeof(struct uuid_v1), GFP_KERNEL);\r\nif (!call->request)\r\nreturn -ENOMEM;\r\nb = call->buffer;\r\nr = call->request;\r\nr->time_low = b[0];\r\nr->time_mid = htons(ntohl(b[1]));\r\nr->time_hi_and_version = htons(ntohl(b[2]));\r\nr->clock_seq_hi_and_reserved = ntohl(b[3]);\r\nr->clock_seq_low = ntohl(b[4]);\r\nfor (loop = 0; loop < 6; loop++)\r\nr->node[loop] = ntohl(b[loop + 5]);\r\ncall->offset = 0;\r\ncall->unmarshall++;\r\ncase 2:\r\nbreak;\r\n}\r\ncall->state = AFS_CALL_REPLYING;\r\nserver = afs_find_server(&srx);\r\nif (!server)\r\nreturn -ENOTCONN;\r\ncall->server = server;\r\nreturn afs_queue_call_work(call);\r\n}\r\nstatic void SRXAFSCB_Probe(struct work_struct *work)\r\n{\r\nstruct afs_call *call = container_of(work, struct afs_call, work);\r\n_enter("");\r\nafs_send_empty_reply(call);\r\nafs_put_call(call);\r\n_leave("");\r\n}\r\nstatic int afs_deliver_cb_probe(struct afs_call *call)\r\n{\r\nint ret;\r\n_enter("");\r\nret = afs_extract_data(call, NULL, 0, false);\r\nif (ret < 0)\r\nreturn ret;\r\ncall->state = AFS_CALL_REPLYING;\r\nreturn afs_queue_call_work(call);\r\n}\r\nstatic void SRXAFSCB_ProbeUuid(struct work_struct *work)\r\n{\r\nstruct afs_call *call = container_of(work, struct afs_call, work);\r\nstruct uuid_v1 *r = call->request;\r\nstruct {\r\n__be32 match;\r\n} reply;\r\n_enter("");\r\nif (memcmp(r, &afs_uuid, sizeof(afs_uuid)) == 0)\r\nreply.match = htonl(0);\r\nelse\r\nreply.match = htonl(1);\r\nafs_send_simple_reply(call, &reply, sizeof(reply));\r\nafs_put_call(call);\r\n_leave("");\r\n}\r\nstatic int afs_deliver_cb_probe_uuid(struct afs_call *call)\r\n{\r\nstruct uuid_v1 *r;\r\nunsigned loop;\r\n__be32 *b;\r\nint ret;\r\n_enter("{%u}", call->unmarshall);\r\nswitch (call->unmarshall) {\r\ncase 0:\r\ncall->offset = 0;\r\ncall->buffer = kmalloc(11 * sizeof(__be32), GFP_KERNEL);\r\nif (!call->buffer)\r\nreturn -ENOMEM;\r\ncall->unmarshall++;\r\ncase 1:\r\n_debug("extract UUID");\r\nret = afs_extract_data(call, call->buffer,\r\n11 * sizeof(__be32), false);\r\nswitch (ret) {\r\ncase 0: break;\r\ncase -EAGAIN: return 0;\r\ndefault: return ret;\r\n}\r\n_debug("unmarshall UUID");\r\ncall->request = kmalloc(sizeof(struct uuid_v1), GFP_KERNEL);\r\nif (!call->request)\r\nreturn -ENOMEM;\r\nb = call->buffer;\r\nr = call->request;\r\nr->time_low = b[0];\r\nr->time_mid = htons(ntohl(b[1]));\r\nr->time_hi_and_version = htons(ntohl(b[2]));\r\nr->clock_seq_hi_and_reserved = ntohl(b[3]);\r\nr->clock_seq_low = ntohl(b[4]);\r\nfor (loop = 0; loop < 6; loop++)\r\nr->node[loop] = ntohl(b[loop + 5]);\r\ncall->offset = 0;\r\ncall->unmarshall++;\r\ncase 2:\r\nbreak;\r\n}\r\ncall->state = AFS_CALL_REPLYING;\r\nreturn afs_queue_call_work(call);\r\n}\r\nstatic void SRXAFSCB_TellMeAboutYourself(struct work_struct *work)\r\n{\r\nstruct afs_interface *ifs;\r\nstruct afs_call *call = container_of(work, struct afs_call, work);\r\nint loop, nifs;\r\nstruct {\r\nstruct {\r\n__be32 nifs;\r\n__be32 uuid[11];\r\n__be32 ifaddr[32];\r\n__be32 netmask[32];\r\n__be32 mtu[32];\r\n} ia;\r\nstruct {\r\n__be32 capcount;\r\n__be32 caps[1];\r\n} cap;\r\n} reply;\r\n_enter("");\r\nnifs = 0;\r\nifs = kcalloc(32, sizeof(*ifs), GFP_KERNEL);\r\nif (ifs) {\r\nnifs = afs_get_ipv4_interfaces(ifs, 32, false);\r\nif (nifs < 0) {\r\nkfree(ifs);\r\nifs = NULL;\r\nnifs = 0;\r\n}\r\n}\r\nmemset(&reply, 0, sizeof(reply));\r\nreply.ia.nifs = htonl(nifs);\r\nreply.ia.uuid[0] = afs_uuid.time_low;\r\nreply.ia.uuid[1] = htonl(ntohs(afs_uuid.time_mid));\r\nreply.ia.uuid[2] = htonl(ntohs(afs_uuid.time_hi_and_version));\r\nreply.ia.uuid[3] = htonl((s8) afs_uuid.clock_seq_hi_and_reserved);\r\nreply.ia.uuid[4] = htonl((s8) afs_uuid.clock_seq_low);\r\nfor (loop = 0; loop < 6; loop++)\r\nreply.ia.uuid[loop + 5] = htonl((s8) afs_uuid.node[loop]);\r\nif (ifs) {\r\nfor (loop = 0; loop < nifs; loop++) {\r\nreply.ia.ifaddr[loop] = ifs[loop].address.s_addr;\r\nreply.ia.netmask[loop] = ifs[loop].netmask.s_addr;\r\nreply.ia.mtu[loop] = htonl(ifs[loop].mtu);\r\n}\r\nkfree(ifs);\r\n}\r\nreply.cap.capcount = htonl(1);\r\nreply.cap.caps[0] = htonl(AFS_CAP_ERROR_TRANSLATION);\r\nafs_send_simple_reply(call, &reply, sizeof(reply));\r\nafs_put_call(call);\r\n_leave("");\r\n}\r\nstatic int afs_deliver_cb_tell_me_about_yourself(struct afs_call *call)\r\n{\r\nint ret;\r\n_enter("");\r\nret = afs_extract_data(call, NULL, 0, false);\r\nif (ret < 0)\r\nreturn ret;\r\ncall->state = AFS_CALL_REPLYING;\r\nreturn afs_queue_call_work(call);\r\n}
