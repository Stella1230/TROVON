static int raydium_i2c_send(struct i2c_client *client,\r\nu8 addr, const void *data, size_t len)\r\n{\r\nu8 *buf;\r\nint tries = 0;\r\nint ret;\r\nbuf = kmalloc(len + 1, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nbuf[0] = addr;\r\nmemcpy(buf + 1, data, len);\r\ndo {\r\nret = i2c_master_send(client, buf, len + 1);\r\nif (likely(ret == len + 1))\r\nbreak;\r\nmsleep(20);\r\n} while (++tries < RM_MAX_RETRIES);\r\nkfree(buf);\r\nif (unlikely(ret != len + 1)) {\r\nif (ret >= 0)\r\nret = -EIO;\r\ndev_err(&client->dev, "%s failed: %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int raydium_i2c_read(struct i2c_client *client,\r\nu8 addr, void *data, size_t len)\r\n{\r\nstruct i2c_msg xfer[] = {\r\n{\r\n.addr = client->addr,\r\n.len = 1,\r\n.buf = &addr,\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = len,\r\n.buf = data,\r\n}\r\n};\r\nint ret;\r\nret = i2c_transfer(client->adapter, xfer, ARRAY_SIZE(xfer));\r\nif (unlikely(ret != ARRAY_SIZE(xfer)))\r\nreturn ret < 0 ? ret : -EIO;\r\nreturn 0;\r\n}\r\nstatic int raydium_i2c_read_message(struct i2c_client *client,\r\nu32 addr, void *data, size_t len)\r\n{\r\n__be32 be_addr;\r\nsize_t xfer_len;\r\nint error;\r\nwhile (len) {\r\nxfer_len = min_t(size_t, len, RM_MAX_READ_SIZE);\r\nbe_addr = cpu_to_be32(addr);\r\nerror = raydium_i2c_send(client, RM_CMD_BANK_SWITCH,\r\n&be_addr, sizeof(be_addr));\r\nif (!error)\r\nerror = raydium_i2c_read(client, addr & 0xff,\r\ndata, xfer_len);\r\nif (error)\r\nreturn error;\r\nlen -= xfer_len;\r\ndata += xfer_len;\r\naddr += xfer_len;\r\n}\r\nreturn 0;\r\n}\r\nstatic int raydium_i2c_send_message(struct i2c_client *client,\r\nu32 addr, const void *data, size_t len)\r\n{\r\n__be32 be_addr = cpu_to_be32(addr);\r\nint error;\r\nerror = raydium_i2c_send(client, RM_CMD_BANK_SWITCH,\r\n&be_addr, sizeof(be_addr));\r\nif (!error)\r\nerror = raydium_i2c_send(client, addr & 0xff, data, len);\r\nreturn error;\r\n}\r\nstatic int raydium_i2c_sw_reset(struct i2c_client *client)\r\n{\r\nconst u8 soft_rst_cmd = 0x01;\r\nint error;\r\nerror = raydium_i2c_send_message(client, RM_RESET_MSG_ADDR,\r\n&soft_rst_cmd, sizeof(soft_rst_cmd));\r\nif (error) {\r\ndev_err(&client->dev, "software reset failed: %d\n", error);\r\nreturn error;\r\n}\r\nmsleep(RM_RESET_DELAY_MSEC);\r\nreturn 0;\r\n}\r\nstatic int raydium_i2c_query_ts_info(struct raydium_data *ts)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nstruct raydium_data_info data_info;\r\n__le32 query_bank_addr;\r\nint error, retry_cnt;\r\nfor (retry_cnt = 0; retry_cnt < RM_MAX_RETRIES; retry_cnt++) {\r\nerror = raydium_i2c_read(client, RM_CMD_DATA_BANK,\r\n&data_info, sizeof(data_info));\r\nif (error)\r\ncontinue;\r\nif (ts->report_data && ts->pkg_size != data_info.pkg_size) {\r\ndev_warn(&client->dev,\r\n"report size changes, was: %d, new: %d\n",\r\nts->pkg_size, data_info.pkg_size);\r\n} else {\r\nts->pkg_size = data_info.pkg_size;\r\nts->report_size = ts->pkg_size - RM_PACKET_CRC_SIZE;\r\n}\r\nts->contact_size = data_info.tp_info_size;\r\nts->data_bank_addr = le32_to_cpu(data_info.data_bank_addr);\r\ndev_dbg(&client->dev,\r\n"data_bank_addr: %#08x, report_size: %d, contact_size: %d\n",\r\nts->data_bank_addr, ts->report_size, ts->contact_size);\r\nerror = raydium_i2c_read(client, RM_CMD_QUERY_BANK,\r\n&query_bank_addr,\r\nsizeof(query_bank_addr));\r\nif (error)\r\ncontinue;\r\nerror = raydium_i2c_read_message(client,\r\nle32_to_cpu(query_bank_addr),\r\n&ts->info, sizeof(ts->info));\r\nif (error)\r\ncontinue;\r\nreturn 0;\r\n}\r\ndev_err(&client->dev, "failed to query device parameters: %d\n", error);\r\nreturn error;\r\n}\r\nstatic int raydium_i2c_check_fw_status(struct raydium_data *ts)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nstatic const u8 bl_ack = 0x62;\r\nstatic const u8 main_ack = 0x66;\r\nu8 buf[4];\r\nint error;\r\nerror = raydium_i2c_read(client, RM_CMD_BOOT_READ, buf, sizeof(buf));\r\nif (!error) {\r\nif (buf[0] == bl_ack)\r\nts->boot_mode = RAYDIUM_TS_BLDR;\r\nelse if (buf[0] == main_ack)\r\nts->boot_mode = RAYDIUM_TS_MAIN;\r\nreturn 0;\r\n}\r\nreturn error;\r\n}\r\nstatic int raydium_i2c_initialize(struct raydium_data *ts)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nint error, retry_cnt;\r\nfor (retry_cnt = 0; retry_cnt < RM_MAX_RETRIES; retry_cnt++) {\r\nmsleep(RM_BOOT_DELAY_MS);\r\nerror = raydium_i2c_check_fw_status(ts);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"failed to read 'hello' packet: %d\n", error);\r\ncontinue;\r\n}\r\nif (ts->boot_mode == RAYDIUM_TS_BLDR ||\r\nts->boot_mode == RAYDIUM_TS_MAIN) {\r\nbreak;\r\n}\r\n}\r\nif (error)\r\nts->boot_mode = RAYDIUM_TS_BLDR;\r\nif (ts->boot_mode == RAYDIUM_TS_BLDR) {\r\nts->info.hw_ver = cpu_to_le32(0xffffffffUL);\r\nts->info.main_ver = 0xff;\r\nts->info.sub_ver = 0xff;\r\n} else {\r\nraydium_i2c_query_ts_info(ts);\r\n}\r\nreturn error;\r\n}\r\nstatic int raydium_i2c_bl_chk_state(struct i2c_client *client,\r\nenum raydium_bl_ack state)\r\n{\r\nstatic const u8 ack_ok[] = { 0xFF, 0x39, 0x30, 0x30, 0x54 };\r\nu8 rbuf[sizeof(ack_ok)];\r\nu8 retry;\r\nint error;\r\nfor (retry = 0; retry < RM_MAX_FW_RETRIES; retry++) {\r\nswitch (state) {\r\ncase RAYDIUM_ACK_NULL:\r\nreturn 0;\r\ncase RAYDIUM_WAIT_READY:\r\nerror = raydium_i2c_read(client, RM_CMD_BOOT_CHK,\r\n&rbuf[0], 1);\r\nif (!error && rbuf[0] == RM_BOOT_RDY)\r\nreturn 0;\r\nbreak;\r\ncase RAYDIUM_PATH_READY:\r\nerror = raydium_i2c_read(client, RM_CMD_BOOT_CHK,\r\nrbuf, sizeof(rbuf));\r\nif (!error && !memcmp(rbuf, ack_ok, sizeof(ack_ok)))\r\nreturn 0;\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev, "%s: invalid target state %d\n",\r\n__func__, state);\r\nreturn -EINVAL;\r\n}\r\nmsleep(20);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int raydium_i2c_write_object(struct i2c_client *client,\r\nconst void *data, size_t len,\r\nenum raydium_bl_ack state)\r\n{\r\nint error;\r\nerror = raydium_i2c_send(client, RM_CMD_BOOT_WRT, data, len);\r\nif (error) {\r\ndev_err(&client->dev, "WRT obj command failed: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = raydium_i2c_send(client, RM_CMD_BOOT_ACK, NULL, 0);\r\nif (error) {\r\ndev_err(&client->dev, "Ack obj command failed: %d\n", error);\r\nreturn error;\r\n}\r\nerror = raydium_i2c_bl_chk_state(client, state);\r\nif (error) {\r\ndev_err(&client->dev, "BL check state failed: %d\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool raydium_i2c_boot_trigger(struct i2c_client *client)\r\n{\r\nstatic const u8 cmd[7][6] = {\r\n{ 0x08, 0x0C, 0x09, 0x00, 0x50, 0xD7 },\r\n{ 0x08, 0x04, 0x09, 0x00, 0x50, 0xA5 },\r\n{ 0x08, 0x04, 0x09, 0x00, 0x50, 0x00 },\r\n{ 0x08, 0x04, 0x09, 0x00, 0x50, 0xA5 },\r\n{ 0x08, 0x0C, 0x09, 0x00, 0x50, 0x00 },\r\n{ 0x06, 0x01, 0x00, 0x00, 0x00, 0x00 },\r\n{ 0x02, 0xA2, 0x00, 0x00, 0x00, 0x00 },\r\n};\r\nint i;\r\nint error;\r\nfor (i = 0; i < 7; i++) {\r\nerror = raydium_i2c_write_object(client, cmd[i], sizeof(cmd[i]),\r\nRAYDIUM_WAIT_READY);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"boot trigger failed at step %d: %d\n",\r\ni, error);\r\nreturn error;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic bool raydium_i2c_fw_trigger(struct i2c_client *client)\r\n{\r\nstatic const u8 cmd[5][11] = {\r\n{ 0, 0x09, 0x71, 0x0C, 0x09, 0x00, 0x50, 0xD7, 0, 0, 0 },\r\n{ 0, 0x09, 0x71, 0x04, 0x09, 0x00, 0x50, 0xA5, 0, 0, 0 },\r\n{ 0, 0x09, 0x71, 0x04, 0x09, 0x00, 0x50, 0x00, 0, 0, 0 },\r\n{ 0, 0x09, 0x71, 0x04, 0x09, 0x00, 0x50, 0xA5, 0, 0, 0 },\r\n{ 0, 0x09, 0x71, 0x0C, 0x09, 0x00, 0x50, 0x00, 0, 0, 0 },\r\n};\r\nint i;\r\nint error;\r\nfor (i = 0; i < 5; i++) {\r\nerror = raydium_i2c_write_object(client, cmd[i], sizeof(cmd[i]),\r\nRAYDIUM_ACK_NULL);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"fw trigger failed at step %d: %d\n",\r\ni, error);\r\nreturn error;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int raydium_i2c_check_path(struct i2c_client *client)\r\n{\r\nstatic const u8 cmd[] = { 0x09, 0x00, 0x09, 0x00, 0x50, 0x10, 0x00 };\r\nint error;\r\nerror = raydium_i2c_write_object(client, cmd, sizeof(cmd),\r\nRAYDIUM_PATH_READY);\r\nif (error) {\r\ndev_err(&client->dev, "check path command failed: %d\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int raydium_i2c_enter_bl(struct i2c_client *client)\r\n{\r\nstatic const u8 cal_cmd[] = { 0x00, 0x01, 0x52 };\r\nint error;\r\nerror = raydium_i2c_write_object(client, cal_cmd, sizeof(cal_cmd),\r\nRAYDIUM_ACK_NULL);\r\nif (error) {\r\ndev_err(&client->dev, "enter bl command failed: %d\n", error);\r\nreturn error;\r\n}\r\nmsleep(RM_BOOT_DELAY_MS);\r\nreturn 0;\r\n}\r\nstatic int raydium_i2c_leave_bl(struct i2c_client *client)\r\n{\r\nstatic const u8 leave_cmd[] = { 0x05, 0x00 };\r\nint error;\r\nerror = raydium_i2c_write_object(client, leave_cmd, sizeof(leave_cmd),\r\nRAYDIUM_ACK_NULL);\r\nif (error) {\r\ndev_err(&client->dev, "leave bl command failed: %d\n", error);\r\nreturn error;\r\n}\r\nmsleep(RM_BOOT_DELAY_MS);\r\nreturn 0;\r\n}\r\nstatic int raydium_i2c_write_checksum(struct i2c_client *client,\r\nsize_t length, u16 checksum)\r\n{\r\nu8 checksum_cmd[] = { 0x00, 0x05, 0x6D, 0x00, 0x00, 0x00, 0x00 };\r\nint error;\r\nput_unaligned_le16(length, &checksum_cmd[3]);\r\nput_unaligned_le16(checksum, &checksum_cmd[5]);\r\nerror = raydium_i2c_write_object(client,\r\nchecksum_cmd, sizeof(checksum_cmd),\r\nRAYDIUM_ACK_NULL);\r\nif (error) {\r\ndev_err(&client->dev, "failed to write checksum: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int raydium_i2c_disable_watch_dog(struct i2c_client *client)\r\n{\r\nstatic const u8 cmd[] = { 0x0A, 0xAA };\r\nint error;\r\nerror = raydium_i2c_write_object(client, cmd, sizeof(cmd),\r\nRAYDIUM_WAIT_READY);\r\nif (error) {\r\ndev_err(&client->dev, "disable watchdog command failed: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int raydium_i2c_fw_write_page(struct i2c_client *client,\r\nu16 page_idx, const void *data, size_t len)\r\n{\r\nu8 buf[RM_BL_WRT_LEN];\r\nsize_t xfer_len;\r\nint error;\r\nint i;\r\nBUILD_BUG_ON((RM_FW_PAGE_SIZE % RM_BL_WRT_PKG_SIZE) != 0);\r\nfor (i = 0; i < RM_FW_PAGE_SIZE / RM_BL_WRT_PKG_SIZE; i++) {\r\nbuf[BL_HEADER] = RM_CMD_BOOT_PAGE_WRT;\r\nbuf[BL_PAGE_STR] = page_idx ? 0xff : 0;\r\nbuf[BL_PKG_IDX] = i + 1;\r\nxfer_len = min_t(size_t, len, RM_BL_WRT_PKG_SIZE);\r\nmemcpy(&buf[BL_DATA_STR], data, xfer_len);\r\nif (len < RM_BL_WRT_PKG_SIZE)\r\nmemset(&buf[BL_DATA_STR + xfer_len], 0xff,\r\nRM_BL_WRT_PKG_SIZE - xfer_len);\r\nerror = raydium_i2c_write_object(client, buf, RM_BL_WRT_LEN,\r\nRAYDIUM_WAIT_READY);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"page write command failed for page %d, chunk %d: %d\n",\r\npage_idx, i, error);\r\nreturn error;\r\n}\r\ndata += xfer_len;\r\nlen -= xfer_len;\r\n}\r\nreturn error;\r\n}\r\nstatic u16 raydium_calc_chksum(const u8 *buf, u16 len)\r\n{\r\nu16 checksum = 0;\r\nu16 i;\r\nfor (i = 0; i < len; i++)\r\nchecksum += buf[i];\r\nreturn checksum;\r\n}\r\nstatic int raydium_i2c_do_update_firmware(struct raydium_data *ts,\r\nconst struct firmware *fw)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nconst void *data;\r\nsize_t data_len;\r\nsize_t len;\r\nint page_nr;\r\nint i;\r\nint error;\r\nu16 fw_checksum;\r\nif (fw->size == 0 || fw->size > RM_MAX_FW_SIZE) {\r\ndev_err(&client->dev, "Invalid firmware length\n");\r\nreturn -EINVAL;\r\n}\r\nerror = raydium_i2c_check_fw_status(ts);\r\nif (error) {\r\ndev_err(&client->dev, "Unable to access IC %d\n", error);\r\nreturn error;\r\n}\r\nif (ts->boot_mode == RAYDIUM_TS_MAIN) {\r\nfor (i = 0; i < RM_MAX_RETRIES; i++) {\r\nerror = raydium_i2c_enter_bl(client);\r\nif (!error) {\r\nerror = raydium_i2c_check_fw_status(ts);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"unable to access IC: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nif (ts->boot_mode == RAYDIUM_TS_BLDR)\r\nbreak;\r\n}\r\n}\r\nif (ts->boot_mode == RAYDIUM_TS_MAIN) {\r\ndev_err(&client->dev,\r\n"failed to jump to boot loader: %d\n",\r\nerror);\r\nreturn -EIO;\r\n}\r\n}\r\nerror = raydium_i2c_disable_watch_dog(client);\r\nif (error)\r\nreturn error;\r\nerror = raydium_i2c_check_path(client);\r\nif (error)\r\nreturn error;\r\nerror = raydium_i2c_boot_trigger(client);\r\nif (error) {\r\ndev_err(&client->dev, "send boot trigger fail: %d\n", error);\r\nreturn error;\r\n}\r\nmsleep(RM_BOOT_DELAY_MS);\r\ndata = fw->data;\r\ndata_len = fw->size;\r\npage_nr = 0;\r\nwhile (data_len) {\r\nlen = min_t(size_t, data_len, RM_FW_PAGE_SIZE);\r\nerror = raydium_i2c_fw_write_page(client, page_nr++, data, len);\r\nif (error)\r\nreturn error;\r\nmsleep(20);\r\ndata += len;\r\ndata_len -= len;\r\n}\r\nerror = raydium_i2c_leave_bl(client);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"failed to leave boot loader: %d\n", error);\r\nreturn error;\r\n}\r\ndev_dbg(&client->dev, "left boot loader mode\n");\r\nmsleep(RM_BOOT_DELAY_MS);\r\nerror = raydium_i2c_check_fw_status(ts);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"failed to check fw status after write: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nif (ts->boot_mode != RAYDIUM_TS_MAIN) {\r\ndev_err(&client->dev,\r\n"failed to switch to main fw after writing firmware: %d\n",\r\nerror);\r\nreturn -EINVAL;\r\n}\r\nerror = raydium_i2c_fw_trigger(client);\r\nif (error) {\r\ndev_err(&client->dev, "failed to trigger fw: %d\n", error);\r\nreturn error;\r\n}\r\nfw_checksum = raydium_calc_chksum(fw->data, fw->size);\r\nerror = raydium_i2c_write_checksum(client, fw->size, fw_checksum);\r\nif (error)\r\nreturn error;\r\nreturn 0;\r\n}\r\nstatic int raydium_i2c_fw_update(struct raydium_data *ts)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nconst struct firmware *fw = NULL;\r\nconst char *fw_file = "raydium.fw";\r\nint error;\r\nerror = request_firmware(&fw, fw_file, &client->dev);\r\nif (error) {\r\ndev_err(&client->dev, "Unable to open firmware %s\n", fw_file);\r\nreturn error;\r\n}\r\ndisable_irq(client->irq);\r\nerror = raydium_i2c_do_update_firmware(ts, fw);\r\nif (error) {\r\ndev_err(&client->dev, "firmware update failed: %d\n", error);\r\nts->boot_mode = RAYDIUM_TS_BLDR;\r\ngoto out_enable_irq;\r\n}\r\nerror = raydium_i2c_initialize(ts);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"failed to initialize device after firmware update: %d\n",\r\nerror);\r\nts->boot_mode = RAYDIUM_TS_BLDR;\r\ngoto out_enable_irq;\r\n}\r\nts->boot_mode = RAYDIUM_TS_MAIN;\r\nout_enable_irq:\r\nenable_irq(client->irq);\r\nmsleep(100);\r\nrelease_firmware(fw);\r\nreturn error;\r\n}\r\nstatic void raydium_mt_event(struct raydium_data *ts)\r\n{\r\nint i;\r\nfor (i = 0; i < ts->report_size / ts->contact_size; i++) {\r\nu8 *contact = &ts->report_data[ts->contact_size * i];\r\nbool state = contact[RM_CONTACT_STATE_POS];\r\nu8 wx, wy;\r\ninput_mt_slot(ts->input, i);\r\ninput_mt_report_slot_state(ts->input, MT_TOOL_FINGER, state);\r\nif (!state)\r\ncontinue;\r\ninput_report_abs(ts->input, ABS_MT_POSITION_X,\r\nget_unaligned_le16(&contact[RM_CONTACT_X_POS]));\r\ninput_report_abs(ts->input, ABS_MT_POSITION_Y,\r\nget_unaligned_le16(&contact[RM_CONTACT_Y_POS]));\r\ninput_report_abs(ts->input, ABS_MT_PRESSURE,\r\ncontact[RM_CONTACT_PRESSURE_POS]);\r\nwx = contact[RM_CONTACT_WIDTH_X_POS];\r\nwy = contact[RM_CONTACT_WIDTH_Y_POS];\r\ninput_report_abs(ts->input, ABS_MT_TOUCH_MAJOR, max(wx, wy));\r\ninput_report_abs(ts->input, ABS_MT_TOUCH_MINOR, min(wx, wy));\r\n}\r\ninput_mt_sync_frame(ts->input);\r\ninput_sync(ts->input);\r\n}\r\nstatic irqreturn_t raydium_i2c_irq(int irq, void *_dev)\r\n{\r\nstruct raydium_data *ts = _dev;\r\nint error;\r\nu16 fw_crc;\r\nu16 calc_crc;\r\nif (ts->boot_mode != RAYDIUM_TS_MAIN)\r\ngoto out;\r\nerror = raydium_i2c_read_message(ts->client, ts->data_bank_addr,\r\nts->report_data, ts->pkg_size);\r\nif (error)\r\ngoto out;\r\nfw_crc = get_unaligned_le16(&ts->report_data[ts->report_size]);\r\ncalc_crc = raydium_calc_chksum(ts->report_data, ts->report_size);\r\nif (unlikely(fw_crc != calc_crc)) {\r\ndev_warn(&ts->client->dev,\r\n"%s: invalid packet crc %#04x vs %#04x\n",\r\n__func__, calc_crc, fw_crc);\r\ngoto out;\r\n}\r\nraydium_mt_event(ts);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic ssize_t raydium_i2c_fw_ver_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct raydium_data *ts = i2c_get_clientdata(client);\r\nreturn sprintf(buf, "%d.%d\n", ts->info.main_ver, ts->info.sub_ver);\r\n}\r\nstatic ssize_t raydium_i2c_hw_ver_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct raydium_data *ts = i2c_get_clientdata(client);\r\nreturn sprintf(buf, "%#04x\n", le32_to_cpu(ts->info.hw_ver));\r\n}\r\nstatic ssize_t raydium_i2c_boot_mode_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct raydium_data *ts = i2c_get_clientdata(client);\r\nreturn sprintf(buf, "%s\n",\r\nts->boot_mode == RAYDIUM_TS_MAIN ?\r\n"Normal" : "Recovery");\r\n}\r\nstatic ssize_t raydium_i2c_update_fw_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct raydium_data *ts = i2c_get_clientdata(client);\r\nint error;\r\nerror = mutex_lock_interruptible(&ts->sysfs_mutex);\r\nif (error)\r\nreturn error;\r\nerror = raydium_i2c_fw_update(ts);\r\nmutex_unlock(&ts->sysfs_mutex);\r\nreturn error ?: count;\r\n}\r\nstatic ssize_t raydium_i2c_calibrate_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct raydium_data *ts = i2c_get_clientdata(client);\r\nstatic const u8 cal_cmd[] = { 0x00, 0x01, 0x9E };\r\nint error;\r\nerror = mutex_lock_interruptible(&ts->sysfs_mutex);\r\nif (error)\r\nreturn error;\r\nerror = raydium_i2c_write_object(client, cal_cmd, sizeof(cal_cmd),\r\nRAYDIUM_WAIT_READY);\r\nif (error)\r\ndev_err(&client->dev, "calibrate command failed: %d\n", error);\r\nmutex_unlock(&ts->sysfs_mutex);\r\nreturn error ?: count;\r\n}\r\nstatic void raydium_i2c_remove_sysfs_group(void *_data)\r\n{\r\nstruct raydium_data *ts = _data;\r\nsysfs_remove_group(&ts->client->dev.kobj, &raydium_i2c_attribute_group);\r\n}\r\nstatic int raydium_i2c_power_on(struct raydium_data *ts)\r\n{\r\nint error;\r\nif (!ts->reset_gpio)\r\nreturn 0;\r\ngpiod_set_value_cansleep(ts->reset_gpio, 1);\r\nerror = regulator_enable(ts->avdd);\r\nif (error) {\r\ndev_err(&ts->client->dev,\r\n"failed to enable avdd regulator: %d\n", error);\r\ngoto release_reset_gpio;\r\n}\r\nerror = regulator_enable(ts->vccio);\r\nif (error) {\r\nregulator_disable(ts->avdd);\r\ndev_err(&ts->client->dev,\r\n"failed to enable vccio regulator: %d\n", error);\r\ngoto release_reset_gpio;\r\n}\r\nudelay(RM_POWERON_DELAY_USEC);\r\nrelease_reset_gpio:\r\ngpiod_set_value_cansleep(ts->reset_gpio, 0);\r\nif (error)\r\nreturn error;\r\nmsleep(RM_RESET_DELAY_MSEC);\r\nreturn 0;\r\n}\r\nstatic void raydium_i2c_power_off(void *_data)\r\n{\r\nstruct raydium_data *ts = _data;\r\nif (ts->reset_gpio) {\r\ngpiod_set_value_cansleep(ts->reset_gpio, 1);\r\nregulator_disable(ts->vccio);\r\nregulator_disable(ts->avdd);\r\n}\r\n}\r\nstatic int raydium_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nunion i2c_smbus_data dummy;\r\nstruct raydium_data *ts;\r\nint error;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\ndev_err(&client->dev,\r\n"i2c check functionality error (need I2C_FUNC_I2C)\n");\r\nreturn -ENXIO;\r\n}\r\nts = devm_kzalloc(&client->dev, sizeof(*ts), GFP_KERNEL);\r\nif (!ts)\r\nreturn -ENOMEM;\r\nmutex_init(&ts->sysfs_mutex);\r\nts->client = client;\r\ni2c_set_clientdata(client, ts);\r\nts->avdd = devm_regulator_get(&client->dev, "avdd");\r\nif (IS_ERR(ts->avdd)) {\r\nerror = PTR_ERR(ts->avdd);\r\nif (error != -EPROBE_DEFER)\r\ndev_err(&client->dev,\r\n"Failed to get 'avdd' regulator: %d\n", error);\r\nreturn error;\r\n}\r\nts->vccio = devm_regulator_get(&client->dev, "vccio");\r\nif (IS_ERR(ts->vccio)) {\r\nerror = PTR_ERR(ts->vccio);\r\nif (error != -EPROBE_DEFER)\r\ndev_err(&client->dev,\r\n"Failed to get 'vccio' regulator: %d\n", error);\r\nreturn error;\r\n}\r\nts->reset_gpio = devm_gpiod_get_optional(&client->dev, "reset",\r\nGPIOD_OUT_LOW);\r\nif (IS_ERR(ts->reset_gpio)) {\r\nerror = PTR_ERR(ts->reset_gpio);\r\nif (error != -EPROBE_DEFER)\r\ndev_err(&client->dev,\r\n"failed to get reset gpio: %d\n", error);\r\nreturn error;\r\n}\r\nerror = raydium_i2c_power_on(ts);\r\nif (error)\r\nreturn error;\r\nerror = devm_add_action(&client->dev, raydium_i2c_power_off, ts);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"failed to install power off action: %d\n", error);\r\nraydium_i2c_power_off(ts);\r\nreturn error;\r\n}\r\nif (i2c_smbus_xfer(client->adapter, client->addr, 0,\r\nI2C_SMBUS_READ, 0, I2C_SMBUS_BYTE, &dummy) < 0) {\r\ndev_err(&client->dev, "nothing at this address\n");\r\nreturn -ENXIO;\r\n}\r\nerror = raydium_i2c_initialize(ts);\r\nif (error) {\r\ndev_err(&client->dev, "failed to initialize: %d\n", error);\r\nreturn error;\r\n}\r\nts->report_data = devm_kmalloc(&client->dev,\r\nts->pkg_size, GFP_KERNEL);\r\nif (!ts->report_data)\r\nreturn -ENOMEM;\r\nts->input = devm_input_allocate_device(&client->dev);\r\nif (!ts->input) {\r\ndev_err(&client->dev, "Failed to allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\nts->input->name = "Raydium Touchscreen";\r\nts->input->id.bustype = BUS_I2C;\r\ninput_set_abs_params(ts->input, ABS_MT_POSITION_X,\r\n0, le16_to_cpu(ts->info.x_max), 0, 0);\r\ninput_set_abs_params(ts->input, ABS_MT_POSITION_Y,\r\n0, le16_to_cpu(ts->info.y_max), 0, 0);\r\ninput_abs_set_res(ts->input, ABS_MT_POSITION_X, ts->info.x_res);\r\ninput_abs_set_res(ts->input, ABS_MT_POSITION_Y, ts->info.y_res);\r\ninput_set_abs_params(ts->input, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);\r\ninput_set_abs_params(ts->input, ABS_MT_PRESSURE, 0, 255, 0, 0);\r\nerror = input_mt_init_slots(ts->input, RM_MAX_TOUCH_NUM,\r\nINPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"failed to initialize MT slots: %d\n", error);\r\nreturn error;\r\n}\r\nerror = input_register_device(ts->input);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"unable to register input device: %d\n", error);\r\nreturn error;\r\n}\r\nerror = devm_request_threaded_irq(&client->dev, client->irq,\r\nNULL, raydium_i2c_irq,\r\nIRQF_ONESHOT, client->name, ts);\r\nif (error) {\r\ndev_err(&client->dev, "Failed to register interrupt\n");\r\nreturn error;\r\n}\r\nerror = sysfs_create_group(&client->dev.kobj,\r\n&raydium_i2c_attribute_group);\r\nif (error) {\r\ndev_err(&client->dev, "failed to create sysfs attributes: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = devm_add_action(&client->dev,\r\nraydium_i2c_remove_sysfs_group, ts);\r\nif (error) {\r\nraydium_i2c_remove_sysfs_group(ts);\r\ndev_err(&client->dev,\r\n"Failed to add sysfs cleanup action: %d\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __maybe_unused raydium_enter_sleep(struct i2c_client *client)\r\n{\r\nstatic const u8 sleep_cmd[] = { 0x5A, 0xff, 0x00, 0x0f };\r\nint error;\r\nerror = raydium_i2c_send(client, RM_CMD_ENTER_SLEEP,\r\nsleep_cmd, sizeof(sleep_cmd));\r\nif (error)\r\ndev_err(&client->dev,\r\n"sleep command failed: %d\n", error);\r\n}\r\nstatic int __maybe_unused raydium_i2c_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct raydium_data *ts = i2c_get_clientdata(client);\r\nif (ts->boot_mode != RAYDIUM_TS_MAIN)\r\nreturn -EBUSY;\r\ndisable_irq(client->irq);\r\nif (device_may_wakeup(dev)) {\r\nraydium_enter_sleep(client);\r\nts->wake_irq_enabled = (enable_irq_wake(client->irq) == 0);\r\n} else {\r\nraydium_i2c_power_off(ts);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused raydium_i2c_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct raydium_data *ts = i2c_get_clientdata(client);\r\nif (device_may_wakeup(dev)) {\r\nif (ts->wake_irq_enabled)\r\ndisable_irq_wake(client->irq);\r\nraydium_i2c_sw_reset(client);\r\n} else {\r\nraydium_i2c_power_on(ts);\r\nraydium_i2c_initialize(ts);\r\n}\r\nenable_irq(client->irq);\r\nreturn 0;\r\n}
