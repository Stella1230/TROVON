static u8 xway_readb(struct mtd_info *mtd, int op)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct xway_nand_data *data = nand_get_controller_data(chip);\r\nreturn readb(data->nandaddr + op);\r\n}\r\nstatic void xway_writeb(struct mtd_info *mtd, int op, u8 value)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct xway_nand_data *data = nand_get_controller_data(chip);\r\nwriteb(value, data->nandaddr + op);\r\n}\r\nstatic void xway_select_chip(struct mtd_info *mtd, int select)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct xway_nand_data *data = nand_get_controller_data(chip);\r\nswitch (select) {\r\ncase -1:\r\nltq_ebu_w32_mask(NAND_CON_CE, 0, EBU_NAND_CON);\r\nltq_ebu_w32_mask(NAND_CON_NANDM, 0, EBU_NAND_CON);\r\nspin_unlock_irqrestore(&ebu_lock, data->csflags);\r\nbreak;\r\ncase 0:\r\nspin_lock_irqsave(&ebu_lock, data->csflags);\r\nltq_ebu_w32_mask(0, NAND_CON_NANDM, EBU_NAND_CON);\r\nltq_ebu_w32_mask(0, NAND_CON_CE, EBU_NAND_CON);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic void xway_cmd_ctrl(struct mtd_info *mtd, int cmd, unsigned int ctrl)\r\n{\r\nif (cmd == NAND_CMD_NONE)\r\nreturn;\r\nif (ctrl & NAND_CLE)\r\nxway_writeb(mtd, NAND_WRITE_CMD, cmd);\r\nelse if (ctrl & NAND_ALE)\r\nxway_writeb(mtd, NAND_WRITE_ADDR, cmd);\r\nwhile ((ltq_ebu_r32(EBU_NAND_WAIT) & NAND_WAIT_WR_C) == 0)\r\n;\r\n}\r\nstatic int xway_dev_ready(struct mtd_info *mtd)\r\n{\r\nreturn ltq_ebu_r32(EBU_NAND_WAIT) & NAND_WAIT_RD;\r\n}\r\nstatic unsigned char xway_read_byte(struct mtd_info *mtd)\r\n{\r\nreturn xway_readb(mtd, NAND_READ_DATA);\r\n}\r\nstatic void xway_read_buf(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nbuf[i] = xway_readb(mtd, NAND_WRITE_DATA);\r\n}\r\nstatic void xway_write_buf(struct mtd_info *mtd, const u_char *buf, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nxway_writeb(mtd, NAND_WRITE_DATA, buf[i]);\r\n}\r\nstatic int xway_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct xway_nand_data *data;\r\nstruct mtd_info *mtd;\r\nstruct resource *res;\r\nint err;\r\nu32 cs;\r\nu32 cs_flag = 0;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(struct xway_nand_data),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndata->nandaddr = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(data->nandaddr))\r\nreturn PTR_ERR(data->nandaddr);\r\nnand_set_flash_node(&data->chip, pdev->dev.of_node);\r\nmtd = nand_to_mtd(&data->chip);\r\nmtd->dev.parent = &pdev->dev;\r\ndata->chip.cmd_ctrl = xway_cmd_ctrl;\r\ndata->chip.dev_ready = xway_dev_ready;\r\ndata->chip.select_chip = xway_select_chip;\r\ndata->chip.write_buf = xway_write_buf;\r\ndata->chip.read_buf = xway_read_buf;\r\ndata->chip.read_byte = xway_read_byte;\r\ndata->chip.chip_delay = 30;\r\ndata->chip.ecc.mode = NAND_ECC_SOFT;\r\ndata->chip.ecc.algo = NAND_ECC_HAMMING;\r\nplatform_set_drvdata(pdev, data);\r\nnand_set_controller_data(&data->chip, data);\r\nerr = of_property_read_u32(pdev->dev.of_node, "lantiq,cs", &cs);\r\nif (!err && cs == 1)\r\ncs_flag = NAND_CON_IN_CS1 | NAND_CON_OUT_CS1;\r\nltq_ebu_w32(CPHYSADDR(data->nandaddr)\r\n| ADDSEL1_MASK(3) | ADDSEL1_REGEN, EBU_ADDSEL1);\r\nltq_ebu_w32(BUSCON1_SETUP | BUSCON1_BCGEN_RES | BUSCON1_WAITWRC2\r\n| BUSCON1_WAITRDC2 | BUSCON1_HOLDC1 | BUSCON1_RECOVC1\r\n| BUSCON1_CMULT4, LTQ_EBU_BUSCON1);\r\nltq_ebu_w32(NAND_CON_NANDM | NAND_CON_CSMUX | NAND_CON_CS_P\r\n| NAND_CON_SE_P | NAND_CON_WP_P | NAND_CON_PRE_P\r\n| cs_flag, EBU_NAND_CON);\r\nerr = nand_scan(mtd, 1);\r\nif (err)\r\nreturn err;\r\nerr = mtd_device_register(mtd, NULL, 0);\r\nif (err)\r\nnand_release(mtd);\r\nreturn err;\r\n}\r\nstatic int xway_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct xway_nand_data *data = platform_get_drvdata(pdev);\r\nnand_release(nand_to_mtd(&data->chip));\r\nreturn 0;\r\n}
