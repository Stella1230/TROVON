static void int3496_do_usb_id(struct work_struct *work)\r\n{\r\nstruct int3496_data *data =\r\ncontainer_of(work, struct int3496_data, work.work);\r\nint id = gpiod_get_value_cansleep(data->gpio_usb_id);\r\ndev_dbg(data->dev, "Connected %s cable\n", id ? "PERIPHERAL" : "HOST");\r\nif (!IS_ERR(data->gpio_usb_mux))\r\ngpiod_direction_output(data->gpio_usb_mux, id);\r\nif (!IS_ERR(data->gpio_vbus_en))\r\ngpiod_direction_output(data->gpio_vbus_en, !id);\r\nextcon_set_state_sync(data->edev, EXTCON_USB_HOST, !id);\r\n}\r\nstatic irqreturn_t int3496_thread_isr(int irq, void *priv)\r\n{\r\nstruct int3496_data *data = priv;\r\nmod_delayed_work(system_wq, &data->work, DEBOUNCE_TIME);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int int3496_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct int3496_data *data;\r\nint ret;\r\nret = acpi_dev_add_driver_gpios(ACPI_COMPANION(dev),\r\nacpi_int3496_default_gpios);\r\nif (ret) {\r\ndev_err(dev, "can't add GPIO ACPI mapping\n");\r\nreturn ret;\r\n}\r\ndata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->dev = dev;\r\nINIT_DELAYED_WORK(&data->work, int3496_do_usb_id);\r\ndata->gpio_usb_id = devm_gpiod_get(dev, "id", GPIOD_IN);\r\nif (IS_ERR(data->gpio_usb_id)) {\r\nret = PTR_ERR(data->gpio_usb_id);\r\ndev_err(dev, "can't request USB ID GPIO: %d\n", ret);\r\nreturn ret;\r\n} else if (gpiod_get_direction(data->gpio_usb_id) != GPIOF_DIR_IN) {\r\ndev_warn(dev, FW_BUG "USB ID GPIO not in input mode, fixing\n");\r\ngpiod_direction_input(data->gpio_usb_id);\r\n}\r\ndata->usb_id_irq = gpiod_to_irq(data->gpio_usb_id);\r\nif (data->usb_id_irq < 0) {\r\ndev_err(dev, "can't get USB ID IRQ: %d\n", data->usb_id_irq);\r\nreturn data->usb_id_irq;\r\n}\r\ndata->gpio_vbus_en = devm_gpiod_get(dev, "vbus", GPIOD_ASIS);\r\nif (IS_ERR(data->gpio_vbus_en))\r\ndev_info(dev, "can't request VBUS EN GPIO\n");\r\ndata->gpio_usb_mux = devm_gpiod_get(dev, "mux", GPIOD_ASIS);\r\nif (IS_ERR(data->gpio_usb_mux))\r\ndev_info(dev, "can't request USB MUX GPIO\n");\r\ndata->edev = devm_extcon_dev_allocate(dev, int3496_cable);\r\nif (IS_ERR(data->edev))\r\nreturn -ENOMEM;\r\nret = devm_extcon_dev_register(dev, data->edev);\r\nif (ret < 0) {\r\ndev_err(dev, "can't register extcon device: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = devm_request_threaded_irq(dev, data->usb_id_irq,\r\nNULL, int3496_thread_isr,\r\nIRQF_SHARED | IRQF_ONESHOT |\r\nIRQF_TRIGGER_RISING |\r\nIRQF_TRIGGER_FALLING,\r\ndev_name(dev), data);\r\nif (ret < 0) {\r\ndev_err(dev, "can't request IRQ for USB ID GPIO: %d\n", ret);\r\nreturn ret;\r\n}\r\nqueue_delayed_work(system_wq, &data->work, 0);\r\nplatform_set_drvdata(pdev, data);\r\nreturn 0;\r\n}\r\nstatic int int3496_remove(struct platform_device *pdev)\r\n{\r\nstruct int3496_data *data = platform_get_drvdata(pdev);\r\ndevm_free_irq(&pdev->dev, data->usb_id_irq, data);\r\ncancel_delayed_work_sync(&data->work);\r\nacpi_dev_remove_driver_gpios(ACPI_COMPANION(&pdev->dev));\r\nreturn 0;\r\n}
