static struct v4l2_subdev *\r\nxvip_dma_remote_subdev(struct media_pad *local, u32 *pad)\r\n{\r\nstruct media_pad *remote;\r\nremote = media_entity_remote_pad(local);\r\nif (!remote || !is_media_entity_v4l2_subdev(remote->entity))\r\nreturn NULL;\r\nif (pad)\r\n*pad = remote->index;\r\nreturn media_entity_to_v4l2_subdev(remote->entity);\r\n}\r\nstatic int xvip_dma_verify_format(struct xvip_dma *dma)\r\n{\r\nstruct v4l2_subdev_format fmt;\r\nstruct v4l2_subdev *subdev;\r\nint ret;\r\nsubdev = xvip_dma_remote_subdev(&dma->pad, &fmt.pad);\r\nif (subdev == NULL)\r\nreturn -EPIPE;\r\nfmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &fmt);\r\nif (ret < 0)\r\nreturn ret == -ENOIOCTLCMD ? -EINVAL : ret;\r\nif (dma->fmtinfo->code != fmt.format.code ||\r\ndma->format.height != fmt.format.height ||\r\ndma->format.width != fmt.format.width ||\r\ndma->format.colorspace != fmt.format.colorspace)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int xvip_pipeline_start_stop(struct xvip_pipeline *pipe, bool start)\r\n{\r\nstruct xvip_dma *dma = pipe->output;\r\nstruct media_entity *entity;\r\nstruct media_pad *pad;\r\nstruct v4l2_subdev *subdev;\r\nint ret;\r\nentity = &dma->video.entity;\r\nwhile (1) {\r\npad = &entity->pads[0];\r\nif (!(pad->flags & MEDIA_PAD_FL_SINK))\r\nbreak;\r\npad = media_entity_remote_pad(pad);\r\nif (!pad || !is_media_entity_v4l2_subdev(pad->entity))\r\nbreak;\r\nentity = pad->entity;\r\nsubdev = media_entity_to_v4l2_subdev(entity);\r\nret = v4l2_subdev_call(subdev, video, s_stream, start);\r\nif (start && ret < 0 && ret != -ENOIOCTLCMD)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xvip_pipeline_set_stream(struct xvip_pipeline *pipe, bool on)\r\n{\r\nint ret = 0;\r\nmutex_lock(&pipe->lock);\r\nif (on) {\r\nif (pipe->stream_count == pipe->num_dmas - 1) {\r\nret = xvip_pipeline_start_stop(pipe, true);\r\nif (ret < 0)\r\ngoto done;\r\n}\r\npipe->stream_count++;\r\n} else {\r\nif (--pipe->stream_count == 0)\r\nxvip_pipeline_start_stop(pipe, false);\r\n}\r\ndone:\r\nmutex_unlock(&pipe->lock);\r\nreturn ret;\r\n}\r\nstatic int xvip_pipeline_validate(struct xvip_pipeline *pipe,\r\nstruct xvip_dma *start)\r\n{\r\nstruct media_graph graph;\r\nstruct media_entity *entity = &start->video.entity;\r\nstruct media_device *mdev = entity->graph_obj.mdev;\r\nunsigned int num_inputs = 0;\r\nunsigned int num_outputs = 0;\r\nint ret;\r\nmutex_lock(&mdev->graph_mutex);\r\nret = media_graph_walk_init(&graph, mdev);\r\nif (ret) {\r\nmutex_unlock(&mdev->graph_mutex);\r\nreturn ret;\r\n}\r\nmedia_graph_walk_start(&graph, entity);\r\nwhile ((entity = media_graph_walk_next(&graph))) {\r\nstruct xvip_dma *dma;\r\nif (entity->function != MEDIA_ENT_F_IO_V4L)\r\ncontinue;\r\ndma = to_xvip_dma(media_entity_to_video_device(entity));\r\nif (dma->pad.flags & MEDIA_PAD_FL_SINK) {\r\npipe->output = dma;\r\nnum_outputs++;\r\n} else {\r\nnum_inputs++;\r\n}\r\n}\r\nmutex_unlock(&mdev->graph_mutex);\r\nmedia_graph_walk_cleanup(&graph);\r\nif (num_outputs != 1 || num_inputs > 1)\r\nreturn -EPIPE;\r\npipe->num_dmas = num_inputs + num_outputs;\r\nreturn 0;\r\n}\r\nstatic void __xvip_pipeline_cleanup(struct xvip_pipeline *pipe)\r\n{\r\npipe->num_dmas = 0;\r\npipe->output = NULL;\r\n}\r\nstatic void xvip_pipeline_cleanup(struct xvip_pipeline *pipe)\r\n{\r\nmutex_lock(&pipe->lock);\r\nif (--pipe->use_count == 0)\r\n__xvip_pipeline_cleanup(pipe);\r\nmutex_unlock(&pipe->lock);\r\n}\r\nstatic int xvip_pipeline_prepare(struct xvip_pipeline *pipe,\r\nstruct xvip_dma *dma)\r\n{\r\nint ret;\r\nmutex_lock(&pipe->lock);\r\nif (pipe->use_count == 0) {\r\nret = xvip_pipeline_validate(pipe, dma);\r\nif (ret < 0) {\r\n__xvip_pipeline_cleanup(pipe);\r\ngoto done;\r\n}\r\n}\r\npipe->use_count++;\r\nret = 0;\r\ndone:\r\nmutex_unlock(&pipe->lock);\r\nreturn ret;\r\n}\r\nstatic void xvip_dma_complete(void *param)\r\n{\r\nstruct xvip_dma_buffer *buf = param;\r\nstruct xvip_dma *dma = buf->dma;\r\nspin_lock(&dma->queued_lock);\r\nlist_del(&buf->queue);\r\nspin_unlock(&dma->queued_lock);\r\nbuf->buf.field = V4L2_FIELD_NONE;\r\nbuf->buf.sequence = dma->sequence++;\r\nbuf->buf.vb2_buf.timestamp = ktime_get_ns();\r\nvb2_set_plane_payload(&buf->buf.vb2_buf, 0, dma->format.sizeimage);\r\nvb2_buffer_done(&buf->buf.vb2_buf, VB2_BUF_STATE_DONE);\r\n}\r\nstatic int\r\nxvip_dma_queue_setup(struct vb2_queue *vq,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], struct device *alloc_devs[])\r\n{\r\nstruct xvip_dma *dma = vb2_get_drv_priv(vq);\r\nif (*nplanes)\r\nreturn sizes[0] < dma->format.sizeimage ? -EINVAL : 0;\r\n*nplanes = 1;\r\nsizes[0] = dma->format.sizeimage;\r\nreturn 0;\r\n}\r\nstatic int xvip_dma_buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct xvip_dma *dma = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct xvip_dma_buffer *buf = to_xvip_dma_buffer(vbuf);\r\nbuf->dma = dma;\r\nreturn 0;\r\n}\r\nstatic void xvip_dma_buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct xvip_dma *dma = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct xvip_dma_buffer *buf = to_xvip_dma_buffer(vbuf);\r\nstruct dma_async_tx_descriptor *desc;\r\ndma_addr_t addr = vb2_dma_contig_plane_dma_addr(vb, 0);\r\nu32 flags;\r\nif (dma->queue.type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nflags = DMA_PREP_INTERRUPT | DMA_CTRL_ACK;\r\ndma->xt.dir = DMA_DEV_TO_MEM;\r\ndma->xt.src_sgl = false;\r\ndma->xt.dst_sgl = true;\r\ndma->xt.dst_start = addr;\r\n} else {\r\nflags = DMA_PREP_INTERRUPT | DMA_CTRL_ACK;\r\ndma->xt.dir = DMA_MEM_TO_DEV;\r\ndma->xt.src_sgl = true;\r\ndma->xt.dst_sgl = false;\r\ndma->xt.src_start = addr;\r\n}\r\ndma->xt.frame_size = 1;\r\ndma->sgl[0].size = dma->format.width * dma->fmtinfo->bpp;\r\ndma->sgl[0].icg = dma->format.bytesperline - dma->sgl[0].size;\r\ndma->xt.numf = dma->format.height;\r\ndesc = dmaengine_prep_interleaved_dma(dma->dma, &dma->xt, flags);\r\nif (!desc) {\r\ndev_err(dma->xdev->dev, "Failed to prepare DMA transfer\n");\r\nvb2_buffer_done(&buf->buf.vb2_buf, VB2_BUF_STATE_ERROR);\r\nreturn;\r\n}\r\ndesc->callback = xvip_dma_complete;\r\ndesc->callback_param = buf;\r\nspin_lock_irq(&dma->queued_lock);\r\nlist_add_tail(&buf->queue, &dma->queued_bufs);\r\nspin_unlock_irq(&dma->queued_lock);\r\ndmaengine_submit(desc);\r\nif (vb2_is_streaming(&dma->queue))\r\ndma_async_issue_pending(dma->dma);\r\n}\r\nstatic int xvip_dma_start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct xvip_dma *dma = vb2_get_drv_priv(vq);\r\nstruct xvip_dma_buffer *buf, *nbuf;\r\nstruct xvip_pipeline *pipe;\r\nint ret;\r\ndma->sequence = 0;\r\npipe = dma->video.entity.pipe\r\n? to_xvip_pipeline(&dma->video.entity) : &dma->pipe;\r\nret = media_pipeline_start(&dma->video.entity, &pipe->pipe);\r\nif (ret < 0)\r\ngoto error;\r\nret = xvip_dma_verify_format(dma);\r\nif (ret < 0)\r\ngoto error_stop;\r\nret = xvip_pipeline_prepare(pipe, dma);\r\nif (ret < 0)\r\ngoto error_stop;\r\ndma_async_issue_pending(dma->dma);\r\nxvip_pipeline_set_stream(pipe, true);\r\nreturn 0;\r\nerror_stop:\r\nmedia_pipeline_stop(&dma->video.entity);\r\nerror:\r\nspin_lock_irq(&dma->queued_lock);\r\nlist_for_each_entry_safe(buf, nbuf, &dma->queued_bufs, queue) {\r\nvb2_buffer_done(&buf->buf.vb2_buf, VB2_BUF_STATE_QUEUED);\r\nlist_del(&buf->queue);\r\n}\r\nspin_unlock_irq(&dma->queued_lock);\r\nreturn ret;\r\n}\r\nstatic void xvip_dma_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct xvip_dma *dma = vb2_get_drv_priv(vq);\r\nstruct xvip_pipeline *pipe = to_xvip_pipeline(&dma->video.entity);\r\nstruct xvip_dma_buffer *buf, *nbuf;\r\nxvip_pipeline_set_stream(pipe, false);\r\ndmaengine_terminate_all(dma->dma);\r\nxvip_pipeline_cleanup(pipe);\r\nmedia_pipeline_stop(&dma->video.entity);\r\nspin_lock_irq(&dma->queued_lock);\r\nlist_for_each_entry_safe(buf, nbuf, &dma->queued_bufs, queue) {\r\nvb2_buffer_done(&buf->buf.vb2_buf, VB2_BUF_STATE_ERROR);\r\nlist_del(&buf->queue);\r\n}\r\nspin_unlock_irq(&dma->queued_lock);\r\n}\r\nstatic int\r\nxvip_dma_querycap(struct file *file, void *fh, struct v4l2_capability *cap)\r\n{\r\nstruct v4l2_fh *vfh = file->private_data;\r\nstruct xvip_dma *dma = to_xvip_dma(vfh->vdev);\r\ncap->capabilities = V4L2_CAP_DEVICE_CAPS | V4L2_CAP_STREAMING\r\n| dma->xdev->v4l2_caps;\r\nif (dma->queue.type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;\r\nelse\r\ncap->device_caps = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_STREAMING;\r\nstrlcpy(cap->driver, "xilinx-vipp", sizeof(cap->driver));\r\nstrlcpy(cap->card, dma->video.name, sizeof(cap->card));\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s:%u",\r\ndma->xdev->dev->of_node->name, dma->port);\r\nreturn 0;\r\n}\r\nstatic int\r\nxvip_dma_enum_format(struct file *file, void *fh, struct v4l2_fmtdesc *f)\r\n{\r\nstruct v4l2_fh *vfh = file->private_data;\r\nstruct xvip_dma *dma = to_xvip_dma(vfh->vdev);\r\nif (f->index > 0)\r\nreturn -EINVAL;\r\nf->pixelformat = dma->format.pixelformat;\r\nstrlcpy(f->description, dma->fmtinfo->description,\r\nsizeof(f->description));\r\nreturn 0;\r\n}\r\nstatic int\r\nxvip_dma_get_format(struct file *file, void *fh, struct v4l2_format *format)\r\n{\r\nstruct v4l2_fh *vfh = file->private_data;\r\nstruct xvip_dma *dma = to_xvip_dma(vfh->vdev);\r\nformat->fmt.pix = dma->format;\r\nreturn 0;\r\n}\r\nstatic void\r\n__xvip_dma_try_format(struct xvip_dma *dma, struct v4l2_pix_format *pix,\r\nconst struct xvip_video_format **fmtinfo)\r\n{\r\nconst struct xvip_video_format *info;\r\nunsigned int min_width;\r\nunsigned int max_width;\r\nunsigned int min_bpl;\r\nunsigned int max_bpl;\r\nunsigned int width;\r\nunsigned int align;\r\nunsigned int bpl;\r\ninfo = xvip_get_format_by_fourcc(pix->pixelformat);\r\nif (IS_ERR(info))\r\ninfo = xvip_get_format_by_fourcc(XVIP_DMA_DEF_FORMAT);\r\npix->pixelformat = info->fourcc;\r\npix->field = V4L2_FIELD_NONE;\r\nalign = lcm(dma->align, info->bpp);\r\nmin_width = roundup(XVIP_DMA_MIN_WIDTH, align);\r\nmax_width = rounddown(XVIP_DMA_MAX_WIDTH, align);\r\nwidth = rounddown(pix->width * info->bpp, align);\r\npix->width = clamp(width, min_width, max_width) / info->bpp;\r\npix->height = clamp(pix->height, XVIP_DMA_MIN_HEIGHT,\r\nXVIP_DMA_MAX_HEIGHT);\r\nmin_bpl = pix->width * info->bpp;\r\nmax_bpl = rounddown(XVIP_DMA_MAX_WIDTH, dma->align);\r\nbpl = rounddown(pix->bytesperline, dma->align);\r\npix->bytesperline = clamp(bpl, min_bpl, max_bpl);\r\npix->sizeimage = pix->bytesperline * pix->height;\r\nif (fmtinfo)\r\n*fmtinfo = info;\r\n}\r\nstatic int\r\nxvip_dma_try_format(struct file *file, void *fh, struct v4l2_format *format)\r\n{\r\nstruct v4l2_fh *vfh = file->private_data;\r\nstruct xvip_dma *dma = to_xvip_dma(vfh->vdev);\r\n__xvip_dma_try_format(dma, &format->fmt.pix, NULL);\r\nreturn 0;\r\n}\r\nstatic int\r\nxvip_dma_set_format(struct file *file, void *fh, struct v4l2_format *format)\r\n{\r\nstruct v4l2_fh *vfh = file->private_data;\r\nstruct xvip_dma *dma = to_xvip_dma(vfh->vdev);\r\nconst struct xvip_video_format *info;\r\n__xvip_dma_try_format(dma, &format->fmt.pix, &info);\r\nif (vb2_is_busy(&dma->queue))\r\nreturn -EBUSY;\r\ndma->format = format->fmt.pix;\r\ndma->fmtinfo = info;\r\nreturn 0;\r\n}\r\nint xvip_dma_init(struct xvip_composite_device *xdev, struct xvip_dma *dma,\r\nenum v4l2_buf_type type, unsigned int port)\r\n{\r\nchar name[16];\r\nint ret;\r\ndma->xdev = xdev;\r\ndma->port = port;\r\nmutex_init(&dma->lock);\r\nmutex_init(&dma->pipe.lock);\r\nINIT_LIST_HEAD(&dma->queued_bufs);\r\nspin_lock_init(&dma->queued_lock);\r\ndma->fmtinfo = xvip_get_format_by_fourcc(XVIP_DMA_DEF_FORMAT);\r\ndma->format.pixelformat = dma->fmtinfo->fourcc;\r\ndma->format.colorspace = V4L2_COLORSPACE_SRGB;\r\ndma->format.field = V4L2_FIELD_NONE;\r\ndma->format.width = XVIP_DMA_DEF_WIDTH;\r\ndma->format.height = XVIP_DMA_DEF_HEIGHT;\r\ndma->format.bytesperline = dma->format.width * dma->fmtinfo->bpp;\r\ndma->format.sizeimage = dma->format.bytesperline * dma->format.height;\r\ndma->pad.flags = type == V4L2_BUF_TYPE_VIDEO_CAPTURE\r\n? MEDIA_PAD_FL_SINK : MEDIA_PAD_FL_SOURCE;\r\nret = media_entity_pads_init(&dma->video.entity, 1, &dma->pad);\r\nif (ret < 0)\r\ngoto error;\r\ndma->video.fops = &xvip_dma_fops;\r\ndma->video.v4l2_dev = &xdev->v4l2_dev;\r\ndma->video.queue = &dma->queue;\r\nsnprintf(dma->video.name, sizeof(dma->video.name), "%s %s %u",\r\nxdev->dev->of_node->name,\r\ntype == V4L2_BUF_TYPE_VIDEO_CAPTURE ? "output" : "input",\r\nport);\r\ndma->video.vfl_type = VFL_TYPE_GRABBER;\r\ndma->video.vfl_dir = type == V4L2_BUF_TYPE_VIDEO_CAPTURE\r\n? VFL_DIR_RX : VFL_DIR_TX;\r\ndma->video.release = video_device_release_empty;\r\ndma->video.ioctl_ops = &xvip_dma_ioctl_ops;\r\ndma->video.lock = &dma->lock;\r\nvideo_set_drvdata(&dma->video, dma);\r\ndma->queue.type = type;\r\ndma->queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\r\ndma->queue.lock = &dma->lock;\r\ndma->queue.drv_priv = dma;\r\ndma->queue.buf_struct_size = sizeof(struct xvip_dma_buffer);\r\ndma->queue.ops = &xvip_dma_queue_qops;\r\ndma->queue.mem_ops = &vb2_dma_contig_memops;\r\ndma->queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC\r\n| V4L2_BUF_FLAG_TSTAMP_SRC_EOF;\r\ndma->queue.dev = dma->xdev->dev;\r\nret = vb2_queue_init(&dma->queue);\r\nif (ret < 0) {\r\ndev_err(dma->xdev->dev, "failed to initialize VB2 queue\n");\r\ngoto error;\r\n}\r\nsnprintf(name, sizeof(name), "port%u", port);\r\ndma->dma = dma_request_slave_channel(dma->xdev->dev, name);\r\nif (dma->dma == NULL) {\r\ndev_err(dma->xdev->dev, "no VDMA channel found\n");\r\nret = -ENODEV;\r\ngoto error;\r\n}\r\ndma->align = 1 << dma->dma->device->copy_align;\r\nret = video_register_device(&dma->video, VFL_TYPE_GRABBER, -1);\r\nif (ret < 0) {\r\ndev_err(dma->xdev->dev, "failed to register video device\n");\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nxvip_dma_cleanup(dma);\r\nreturn ret;\r\n}\r\nvoid xvip_dma_cleanup(struct xvip_dma *dma)\r\n{\r\nif (video_is_registered(&dma->video))\r\nvideo_unregister_device(&dma->video);\r\nif (dma->dma)\r\ndma_release_channel(dma->dma);\r\nmedia_entity_cleanup(&dma->video.entity);\r\nmutex_destroy(&dma->lock);\r\nmutex_destroy(&dma->pipe.lock);\r\n}
