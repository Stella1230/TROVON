resource_size_t\r\npcibios_align_resource(void *data, const struct resource *res,\r\nresource_size_t size, resource_size_t align)\r\n{\r\nstruct pci_dev *dev = data;\r\nstruct pci_controller *hose = dev->sysdata;\r\nresource_size_t start = res->start;\r\nif (res->flags & IORESOURCE_IO) {\r\nif (start < PCIBIOS_MIN_IO + hose->io_resource->start)\r\nstart = PCIBIOS_MIN_IO + hose->io_resource->start;\r\nif (start & 0x300)\r\nstart = (start + 0x3ff) & ~0x3ff;\r\n} else if (res->flags & IORESOURCE_MEM) {\r\nif (start < PCIBIOS_MIN_MEM + hose->mem_resource->start)\r\nstart = PCIBIOS_MIN_MEM + hose->mem_resource->start;\r\n}\r\nreturn start;\r\n}\r\nstatic void pcibios_scanbus(struct pci_controller *hose)\r\n{\r\nstatic int next_busno;\r\nstatic int need_domain_info;\r\nLIST_HEAD(resources);\r\nstruct pci_bus *bus;\r\nif (hose->get_busno && pci_has_flag(PCI_PROBE_ONLY))\r\nnext_busno = (*hose->get_busno)();\r\npci_add_resource_offset(&resources,\r\nhose->mem_resource, hose->mem_offset);\r\npci_add_resource_offset(&resources,\r\nhose->io_resource, hose->io_offset);\r\npci_add_resource_offset(&resources,\r\nhose->busn_resource, hose->busn_offset);\r\nbus = pci_scan_root_bus(NULL, next_busno, hose->pci_ops, hose,\r\n&resources);\r\nhose->bus = bus;\r\nneed_domain_info = need_domain_info || pci_domain_nr(bus);\r\nset_pci_need_domain_info(hose, need_domain_info);\r\nif (!bus) {\r\npci_free_resource_list(&resources);\r\nreturn;\r\n}\r\nnext_busno = bus->busn_res.end + 1;\r\nif (next_busno > 224) {\r\nnext_busno = 0;\r\nneed_domain_info = 1;\r\n}\r\nif (pci_has_flag(PCI_PROBE_ONLY)) {\r\npci_bus_claim_resources(bus);\r\n} else {\r\npci_bus_size_bridges(bus);\r\npci_bus_assign_resources(bus);\r\n}\r\npci_bus_add_devices(bus);\r\n}\r\nvoid pci_load_of_ranges(struct pci_controller *hose, struct device_node *node)\r\n{\r\nstruct of_pci_range range;\r\nstruct of_pci_range_parser parser;\r\npr_info("PCI host bridge %s ranges:\n", node->full_name);\r\nhose->of_node = node;\r\nif (of_pci_range_parser_init(&parser, node))\r\nreturn;\r\nfor_each_of_pci_range(&parser, &range) {\r\nstruct resource *res = NULL;\r\nswitch (range.flags & IORESOURCE_TYPE_BITS) {\r\ncase IORESOURCE_IO:\r\npr_info(" IO 0x%016llx..0x%016llx\n",\r\nrange.cpu_addr,\r\nrange.cpu_addr + range.size - 1);\r\nhose->io_map_base =\r\n(unsigned long)ioremap(range.cpu_addr,\r\nrange.size);\r\nres = hose->io_resource;\r\nbreak;\r\ncase IORESOURCE_MEM:\r\npr_info(" MEM 0x%016llx..0x%016llx\n",\r\nrange.cpu_addr,\r\nrange.cpu_addr + range.size - 1);\r\nres = hose->mem_resource;\r\nbreak;\r\n}\r\nif (res != NULL)\r\nof_pci_range_to_resource(&range, node, res);\r\n}\r\n}\r\nstruct device_node *pcibios_get_phb_of_node(struct pci_bus *bus)\r\n{\r\nstruct pci_controller *hose = bus->sysdata;\r\nreturn of_node_get(hose->of_node);\r\n}\r\nvoid register_pci_controller(struct pci_controller *hose)\r\n{\r\nstruct resource *parent;\r\nparent = hose->mem_resource->parent;\r\nif (!parent)\r\nparent = &iomem_resource;\r\nif (request_resource(parent, hose->mem_resource) < 0)\r\ngoto out;\r\nparent = hose->io_resource->parent;\r\nif (!parent)\r\nparent = &ioport_resource;\r\nif (request_resource(parent, hose->io_resource) < 0) {\r\nrelease_resource(hose->mem_resource);\r\ngoto out;\r\n}\r\nINIT_LIST_HEAD(&hose->list);\r\nlist_add_tail(&hose->list, &controllers);\r\nif (!hose->io_map_base) {\r\nprintk(KERN_WARNING\r\n"registering PCI controller with io_map_base unset\n");\r\n}\r\nif (pci_initialized) {\r\nmutex_lock(&pci_scan_mutex);\r\npcibios_scanbus(hose);\r\nmutex_unlock(&pci_scan_mutex);\r\n}\r\nreturn;\r\nout:\r\nprintk(KERN_WARNING\r\n"Skipping PCI bus scan due to resource conflict\n");\r\n}\r\nstatic int __init pcibios_init(void)\r\n{\r\nstruct pci_controller *hose;\r\nlist_for_each_entry(hose, &controllers, list)\r\npcibios_scanbus(hose);\r\npci_fixup_irqs(pci_common_swizzle, pcibios_map_irq);\r\npci_initialized = 1;\r\nreturn 0;\r\n}\r\nstatic int pcibios_enable_resources(struct pci_dev *dev, int mask)\r\n{\r\nu16 cmd, old_cmd;\r\nint idx;\r\nstruct resource *r;\r\npci_read_config_word(dev, PCI_COMMAND, &cmd);\r\nold_cmd = cmd;\r\nfor (idx=0; idx < PCI_NUM_RESOURCES; idx++) {\r\nif (!(mask & (1<<idx)))\r\ncontinue;\r\nr = &dev->resource[idx];\r\nif (!(r->flags & (IORESOURCE_IO | IORESOURCE_MEM)))\r\ncontinue;\r\nif ((idx == PCI_ROM_RESOURCE) &&\r\n(!(r->flags & IORESOURCE_ROM_ENABLE)))\r\ncontinue;\r\nif (!r->start && r->end) {\r\nprintk(KERN_ERR "PCI: Device %s not available "\r\n"because of resource collisions\n",\r\npci_name(dev));\r\nreturn -EINVAL;\r\n}\r\nif (r->flags & IORESOURCE_IO)\r\ncmd |= PCI_COMMAND_IO;\r\nif (r->flags & IORESOURCE_MEM)\r\ncmd |= PCI_COMMAND_MEMORY;\r\n}\r\nif (cmd != old_cmd) {\r\nprintk("PCI: Enabling device %s (%04x -> %04x)\n",\r\npci_name(dev), old_cmd, cmd);\r\npci_write_config_word(dev, PCI_COMMAND, cmd);\r\n}\r\nreturn 0;\r\n}\r\nint pcibios_enable_device(struct pci_dev *dev, int mask)\r\n{\r\nint err;\r\nif ((err = pcibios_enable_resources(dev, mask)) < 0)\r\nreturn err;\r\nreturn pcibios_plat_dev_init(dev);\r\n}\r\nvoid pcibios_fixup_bus(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *dev = bus->self;\r\nif (pci_has_flag(PCI_PROBE_ONLY) && dev &&\r\n(dev->class >> 8) == PCI_CLASS_BRIDGE_PCI) {\r\npci_read_bridge_bases(bus);\r\n}\r\n}\r\nchar *__init pcibios_setup(char *str)\r\n{\r\nif (pcibios_plat_setup)\r\nreturn pcibios_plat_setup(str);\r\nreturn str;\r\n}
