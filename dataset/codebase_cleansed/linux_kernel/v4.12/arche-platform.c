static int arche_apb_bootret_assert(struct device *dev, void *data)\r\n{\r\napb_bootret_assert(dev);\r\nreturn 0;\r\n}\r\nstatic int arche_apb_bootret_deassert(struct device *dev, void *data)\r\n{\r\napb_bootret_deassert(dev);\r\nreturn 0;\r\n}\r\nstatic void arche_platform_set_state(struct arche_platform_drvdata *arche_pdata,\r\nenum arche_platform_state state)\r\n{\r\narche_pdata->state = state;\r\n}\r\nint arche_platform_change_state(enum arche_platform_state state,\r\nstruct gb_timesync_svc *timesync_svc_pdata)\r\n{\r\nstruct arche_platform_drvdata *arche_pdata;\r\nstruct platform_device *pdev;\r\nstruct device_node *np;\r\nint ret = -EAGAIN;\r\nunsigned long flags;\r\nnp = of_find_compatible_node(NULL, NULL, "google,arche-platform");\r\nif (!np) {\r\npr_err("google,arche-platform device node not found\n");\r\nreturn -ENODEV;\r\n}\r\npdev = of_find_device_by_node(np);\r\nif (!pdev) {\r\npr_err("arche-platform device not found\n");\r\nof_node_put(np);\r\nreturn -ENODEV;\r\n}\r\narche_pdata = platform_get_drvdata(pdev);\r\nmutex_lock(&arche_pdata->platform_state_mutex);\r\nspin_lock_irqsave(&arche_pdata->wake_lock, flags);\r\nif (arche_pdata->state == state) {\r\nret = 0;\r\ngoto exit;\r\n}\r\nswitch (state) {\r\ncase ARCHE_PLATFORM_STATE_TIME_SYNC:\r\nif (arche_pdata->state != ARCHE_PLATFORM_STATE_ACTIVE) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nif (arche_pdata->wake_detect_state != WD_STATE_IDLE) {\r\ndev_err(arche_pdata->dev,\r\n"driver busy with wake/detect line ops\n");\r\ngoto exit;\r\n}\r\ndevice_for_each_child(arche_pdata->dev, NULL,\r\narche_apb_bootret_assert);\r\narche_pdata->wake_detect_state = WD_STATE_TIMESYNC;\r\nbreak;\r\ncase ARCHE_PLATFORM_STATE_ACTIVE:\r\nif (arche_pdata->state != ARCHE_PLATFORM_STATE_TIME_SYNC) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\ndevice_for_each_child(arche_pdata->dev, NULL,\r\narche_apb_bootret_deassert);\r\narche_pdata->wake_detect_state = WD_STATE_IDLE;\r\nbreak;\r\ncase ARCHE_PLATFORM_STATE_OFF:\r\ncase ARCHE_PLATFORM_STATE_STANDBY:\r\ncase ARCHE_PLATFORM_STATE_FW_FLASHING:\r\ndev_err(arche_pdata->dev, "busy, request to retry later\n");\r\ngoto exit;\r\ndefault:\r\nret = -EINVAL;\r\ndev_err(arche_pdata->dev,\r\n"invalid state transition request\n");\r\ngoto exit;\r\n}\r\narche_pdata->timesync_svc_pdata = timesync_svc_pdata;\r\narche_platform_set_state(arche_pdata, state);\r\nif (state == ARCHE_PLATFORM_STATE_ACTIVE)\r\nwake_up(&arche_pdata->wq);\r\nret = 0;\r\nexit:\r\nspin_unlock_irqrestore(&arche_pdata->wake_lock, flags);\r\nmutex_unlock(&arche_pdata->platform_state_mutex);\r\nput_device(&pdev->dev);\r\nof_node_put(np);\r\nreturn ret;\r\n}\r\nstatic void arche_platform_set_wake_detect_state(\r\nstruct arche_platform_drvdata *arche_pdata,\r\nenum svc_wakedetect_state state)\r\n{\r\narche_pdata->wake_detect_state = state;\r\n}\r\nstatic inline void svc_reset_onoff(unsigned int gpio, bool onoff)\r\n{\r\ngpio_set_value(gpio, onoff);\r\n}\r\nstatic int apb_cold_boot(struct device *dev, void *data)\r\n{\r\nint ret;\r\nret = apb_ctrl_coldboot(dev);\r\nif (ret)\r\ndev_warn(dev, "failed to coldboot\n");\r\nreturn 0;\r\n}\r\nstatic int apb_poweroff(struct device *dev, void *data)\r\n{\r\napb_ctrl_poweroff(dev);\r\nif (usb3613_hub_mode_ctrl(false))\r\ndev_warn(dev, "failed to control hub device\n");\r\nreturn 0;\r\n}\r\nstatic void arche_platform_wd_irq_en(struct arche_platform_drvdata *arche_pdata)\r\n{\r\ngpio_direction_input(arche_pdata->wake_detect_gpio);\r\nenable_irq(arche_pdata->wake_detect_irq);\r\n}\r\nstatic irqreturn_t arche_platform_wd_irq_thread(int irq, void *devid)\r\n{\r\nstruct arche_platform_drvdata *arche_pdata = devid;\r\nunsigned long flags;\r\nspin_lock_irqsave(&arche_pdata->wake_lock, flags);\r\nif (arche_pdata->wake_detect_state != WD_STATE_COLDBOOT_TRIG) {\r\nspin_unlock_irqrestore(&arche_pdata->wake_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\narche_platform_set_wake_detect_state(arche_pdata,\r\nWD_STATE_COLDBOOT_START);\r\nspin_unlock_irqrestore(&arche_pdata->wake_lock, flags);\r\ndevice_for_each_child(arche_pdata->dev, NULL, apb_poweroff);\r\ndevice_for_each_child(arche_pdata->dev, NULL, apb_cold_boot);\r\nif (usb3613_hub_mode_ctrl(true))\r\ndev_warn(arche_pdata->dev, "failed to control hub device\n");\r\nspin_lock_irqsave(&arche_pdata->wake_lock, flags);\r\narche_platform_set_wake_detect_state(arche_pdata, WD_STATE_IDLE);\r\nspin_unlock_irqrestore(&arche_pdata->wake_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t arche_platform_wd_irq(int irq, void *devid)\r\n{\r\nstruct arche_platform_drvdata *arche_pdata = devid;\r\nunsigned long flags;\r\nspin_lock_irqsave(&arche_pdata->wake_lock, flags);\r\nif (arche_pdata->wake_detect_state == WD_STATE_TIMESYNC) {\r\ngb_timesync_irq(arche_pdata->timesync_svc_pdata);\r\ngoto exit;\r\n}\r\nif (gpio_get_value(arche_pdata->wake_detect_gpio)) {\r\nif (arche_pdata->wake_detect_state == WD_STATE_BOOT_INIT) {\r\nif (time_before(jiffies,\r\narche_pdata->wake_detect_start +\r\nmsecs_to_jiffies(WD_COLDBOOT_PULSE_WIDTH_MS))) {\r\narche_platform_set_wake_detect_state(arche_pdata,\r\nWD_STATE_IDLE);\r\n} else {\r\nif (arche_pdata->wake_detect_state !=\r\nWD_STATE_COLDBOOT_START) {\r\narche_platform_set_wake_detect_state(arche_pdata,\r\nWD_STATE_COLDBOOT_TRIG);\r\nspin_unlock_irqrestore(\r\n&arche_pdata->wake_lock,\r\nflags);\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\n}\r\n}\r\n} else {\r\nif (arche_pdata->wake_detect_state == WD_STATE_IDLE) {\r\narche_pdata->wake_detect_start = jiffies;\r\narche_platform_set_wake_detect_state(arche_pdata,\r\nWD_STATE_BOOT_INIT);\r\n}\r\n}\r\nexit:\r\nspin_unlock_irqrestore(&arche_pdata->wake_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\narche_platform_coldboot_seq(struct arche_platform_drvdata *arche_pdata)\r\n{\r\nint ret;\r\nif (arche_pdata->state == ARCHE_PLATFORM_STATE_ACTIVE)\r\nreturn 0;\r\ndev_info(arche_pdata->dev, "Booting from cold boot state\n");\r\nsvc_reset_onoff(arche_pdata->svc_reset_gpio,\r\narche_pdata->is_reset_act_hi);\r\ngpio_set_value(arche_pdata->svc_sysboot_gpio, 0);\r\nusleep_range(100, 200);\r\nret = clk_prepare_enable(arche_pdata->svc_ref_clk);\r\nif (ret) {\r\ndev_err(arche_pdata->dev, "failed to enable svc_ref_clk: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nsvc_reset_onoff(arche_pdata->svc_reset_gpio,\r\n!arche_pdata->is_reset_act_hi);\r\narche_platform_set_state(arche_pdata, ARCHE_PLATFORM_STATE_ACTIVE);\r\nreturn 0;\r\n}\r\nstatic int\r\narche_platform_fw_flashing_seq(struct arche_platform_drvdata *arche_pdata)\r\n{\r\nint ret;\r\nif (arche_pdata->state == ARCHE_PLATFORM_STATE_FW_FLASHING)\r\nreturn 0;\r\ndev_info(arche_pdata->dev, "Switching to FW flashing state\n");\r\nsvc_reset_onoff(arche_pdata->svc_reset_gpio,\r\narche_pdata->is_reset_act_hi);\r\ngpio_set_value(arche_pdata->svc_sysboot_gpio, 1);\r\nusleep_range(100, 200);\r\nret = clk_prepare_enable(arche_pdata->svc_ref_clk);\r\nif (ret) {\r\ndev_err(arche_pdata->dev, "failed to enable svc_ref_clk: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nsvc_reset_onoff(arche_pdata->svc_reset_gpio,\r\n!arche_pdata->is_reset_act_hi);\r\narche_platform_set_state(arche_pdata, ARCHE_PLATFORM_STATE_FW_FLASHING);\r\nreturn 0;\r\n}\r\nstatic void\r\narche_platform_poweroff_seq(struct arche_platform_drvdata *arche_pdata)\r\n{\r\nunsigned long flags;\r\nif (arche_pdata->state == ARCHE_PLATFORM_STATE_OFF)\r\nreturn;\r\nif (arche_pdata->state != ARCHE_PLATFORM_STATE_FW_FLASHING) {\r\ndisable_irq(arche_pdata->wake_detect_irq);\r\nspin_lock_irqsave(&arche_pdata->wake_lock, flags);\r\narche_platform_set_wake_detect_state(arche_pdata,\r\nWD_STATE_IDLE);\r\nspin_unlock_irqrestore(&arche_pdata->wake_lock, flags);\r\n}\r\nclk_disable_unprepare(arche_pdata->svc_ref_clk);\r\nsvc_reset_onoff(arche_pdata->svc_reset_gpio,\r\narche_pdata->is_reset_act_hi);\r\narche_platform_set_state(arche_pdata, ARCHE_PLATFORM_STATE_OFF);\r\n}\r\nstatic ssize_t state_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct arche_platform_drvdata *arche_pdata = platform_get_drvdata(pdev);\r\nint ret = 0;\r\nretry:\r\nmutex_lock(&arche_pdata->platform_state_mutex);\r\nif (arche_pdata->state == ARCHE_PLATFORM_STATE_TIME_SYNC) {\r\nmutex_unlock(&arche_pdata->platform_state_mutex);\r\nret = wait_event_interruptible(\r\narche_pdata->wq,\r\narche_pdata->state != ARCHE_PLATFORM_STATE_TIME_SYNC);\r\nif (ret)\r\nreturn ret;\r\ngoto retry;\r\n}\r\nif (sysfs_streq(buf, "off")) {\r\nif (arche_pdata->state == ARCHE_PLATFORM_STATE_OFF)\r\ngoto exit;\r\ndevice_for_each_child(arche_pdata->dev, NULL, apb_poweroff);\r\narche_platform_poweroff_seq(arche_pdata);\r\n} else if (sysfs_streq(buf, "active")) {\r\nif (arche_pdata->state == ARCHE_PLATFORM_STATE_ACTIVE)\r\ngoto exit;\r\ndevice_for_each_child(arche_pdata->dev, NULL, apb_poweroff);\r\narche_platform_poweroff_seq(arche_pdata);\r\narche_platform_wd_irq_en(arche_pdata);\r\nret = arche_platform_coldboot_seq(arche_pdata);\r\nif (ret)\r\ngoto exit;\r\n} else if (sysfs_streq(buf, "standby")) {\r\nif (arche_pdata->state == ARCHE_PLATFORM_STATE_STANDBY)\r\ngoto exit;\r\ndev_warn(arche_pdata->dev, "standby state not supported\n");\r\n} else if (sysfs_streq(buf, "fw_flashing")) {\r\nif (arche_pdata->state == ARCHE_PLATFORM_STATE_FW_FLASHING)\r\ngoto exit;\r\narche_platform_poweroff_seq(arche_pdata);\r\nret = arche_platform_fw_flashing_seq(arche_pdata);\r\nif (ret)\r\ngoto exit;\r\n} else {\r\ndev_err(arche_pdata->dev, "unknown state\n");\r\nret = -EINVAL;\r\n}\r\nexit:\r\nmutex_unlock(&arche_pdata->platform_state_mutex);\r\nreturn ret ? ret : count;\r\n}\r\nstatic ssize_t state_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct arche_platform_drvdata *arche_pdata = dev_get_drvdata(dev);\r\nswitch (arche_pdata->state) {\r\ncase ARCHE_PLATFORM_STATE_OFF:\r\nreturn sprintf(buf, "off\n");\r\ncase ARCHE_PLATFORM_STATE_ACTIVE:\r\nreturn sprintf(buf, "active\n");\r\ncase ARCHE_PLATFORM_STATE_STANDBY:\r\nreturn sprintf(buf, "standby\n");\r\ncase ARCHE_PLATFORM_STATE_FW_FLASHING:\r\nreturn sprintf(buf, "fw_flashing\n");\r\ncase ARCHE_PLATFORM_STATE_TIME_SYNC:\r\nreturn sprintf(buf, "time_sync\n");\r\ndefault:\r\nreturn sprintf(buf, "unknown state\n");\r\n}\r\n}\r\nstatic int arche_platform_pm_notifier(struct notifier_block *notifier,\r\nunsigned long pm_event, void *unused)\r\n{\r\nstruct arche_platform_drvdata *arche_pdata =\r\ncontainer_of(notifier, struct arche_platform_drvdata,\r\npm_notifier);\r\nint ret = NOTIFY_DONE;\r\nmutex_lock(&arche_pdata->platform_state_mutex);\r\nswitch (pm_event) {\r\ncase PM_SUSPEND_PREPARE:\r\nif (arche_pdata->state != ARCHE_PLATFORM_STATE_ACTIVE) {\r\nret = NOTIFY_STOP;\r\nbreak;\r\n}\r\ndevice_for_each_child(arche_pdata->dev, NULL, apb_poweroff);\r\narche_platform_poweroff_seq(arche_pdata);\r\nbreak;\r\ncase PM_POST_SUSPEND:\r\nif (arche_pdata->state != ARCHE_PLATFORM_STATE_OFF)\r\nbreak;\r\narche_platform_wd_irq_en(arche_pdata);\r\narche_platform_coldboot_seq(arche_pdata);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmutex_unlock(&arche_pdata->platform_state_mutex);\r\nreturn ret;\r\n}\r\nstatic int arche_platform_probe(struct platform_device *pdev)\r\n{\r\nstruct arche_platform_drvdata *arche_pdata;\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nint ret;\r\narche_pdata = devm_kzalloc(&pdev->dev, sizeof(*arche_pdata),\r\nGFP_KERNEL);\r\nif (!arche_pdata)\r\nreturn -ENOMEM;\r\narche_pdata->is_reset_act_hi = of_property_read_bool(np,\r\n"svc,reset-active-high");\r\narche_pdata->svc_reset_gpio = of_get_named_gpio(np,\r\n"svc,reset-gpio",\r\n0);\r\nif (arche_pdata->svc_reset_gpio < 0) {\r\ndev_err(dev, "failed to get reset-gpio\n");\r\nreturn arche_pdata->svc_reset_gpio;\r\n}\r\nret = devm_gpio_request(dev, arche_pdata->svc_reset_gpio, "svc-reset");\r\nif (ret) {\r\ndev_err(dev, "failed to request svc-reset gpio:%d\n", ret);\r\nreturn ret;\r\n}\r\nret = gpio_direction_output(arche_pdata->svc_reset_gpio,\r\narche_pdata->is_reset_act_hi);\r\nif (ret) {\r\ndev_err(dev, "failed to set svc-reset gpio dir:%d\n", ret);\r\nreturn ret;\r\n}\r\narche_platform_set_state(arche_pdata, ARCHE_PLATFORM_STATE_OFF);\r\narche_pdata->svc_sysboot_gpio = of_get_named_gpio(np,\r\n"svc,sysboot-gpio", 0);\r\nif (arche_pdata->svc_sysboot_gpio < 0) {\r\ndev_err(dev, "failed to get sysboot gpio\n");\r\nreturn arche_pdata->svc_sysboot_gpio;\r\n}\r\nret = devm_gpio_request(dev, arche_pdata->svc_sysboot_gpio, "sysboot0");\r\nif (ret) {\r\ndev_err(dev, "failed to request sysboot0 gpio:%d\n", ret);\r\nreturn ret;\r\n}\r\nret = gpio_direction_output(arche_pdata->svc_sysboot_gpio, 0);\r\nif (ret) {\r\ndev_err(dev, "failed to set svc-reset gpio dir:%d\n", ret);\r\nreturn ret;\r\n}\r\narche_pdata->svc_refclk_req = of_get_named_gpio(np,\r\n"svc,refclk-req-gpio", 0);\r\nif (arche_pdata->svc_refclk_req < 0) {\r\ndev_err(dev, "failed to get svc clock-req gpio\n");\r\nreturn arche_pdata->svc_refclk_req;\r\n}\r\nret = devm_gpio_request(dev, arche_pdata->svc_refclk_req,\r\n"svc-clk-req");\r\nif (ret) {\r\ndev_err(dev, "failed to request svc-clk-req gpio: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = gpio_direction_input(arche_pdata->svc_refclk_req);\r\nif (ret) {\r\ndev_err(dev, "failed to set svc-clk-req gpio dir :%d\n", ret);\r\nreturn ret;\r\n}\r\narche_pdata->svc_ref_clk = devm_clk_get(dev, "svc_ref_clk");\r\nif (IS_ERR(arche_pdata->svc_ref_clk)) {\r\nret = PTR_ERR(arche_pdata->svc_ref_clk);\r\ndev_err(dev, "failed to get svc_ref_clk: %d\n", ret);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, arche_pdata);\r\narche_pdata->num_apbs = of_get_child_count(np);\r\ndev_dbg(dev, "Number of APB's available - %d\n", arche_pdata->num_apbs);\r\narche_pdata->wake_detect_gpio = of_get_named_gpio(np,\r\n"svc,wake-detect-gpio",\r\n0);\r\nif (arche_pdata->wake_detect_gpio < 0) {\r\ndev_err(dev, "failed to get wake detect gpio\n");\r\nreturn arche_pdata->wake_detect_gpio;\r\n}\r\nret = devm_gpio_request(dev, arche_pdata->wake_detect_gpio,\r\n"wake detect");\r\nif (ret) {\r\ndev_err(dev, "Failed requesting wake_detect gpio %d\n",\r\narche_pdata->wake_detect_gpio);\r\nreturn ret;\r\n}\r\narche_platform_set_wake_detect_state(arche_pdata, WD_STATE_IDLE);\r\narche_pdata->dev = &pdev->dev;\r\nspin_lock_init(&arche_pdata->wake_lock);\r\nmutex_init(&arche_pdata->platform_state_mutex);\r\ninit_waitqueue_head(&arche_pdata->wq);\r\narche_pdata->wake_detect_irq =\r\ngpio_to_irq(arche_pdata->wake_detect_gpio);\r\nret = devm_request_threaded_irq(dev, arche_pdata->wake_detect_irq,\r\narche_platform_wd_irq,\r\narche_platform_wd_irq_thread,\r\nIRQF_TRIGGER_FALLING |\r\nIRQF_TRIGGER_RISING | IRQF_ONESHOT,\r\ndev_name(dev), arche_pdata);\r\nif (ret) {\r\ndev_err(dev, "failed to request wake detect IRQ %d\n", ret);\r\nreturn ret;\r\n}\r\ndisable_irq(arche_pdata->wake_detect_irq);\r\nret = device_create_file(dev, &dev_attr_state);\r\nif (ret) {\r\ndev_err(dev, "failed to create state file in sysfs\n");\r\nreturn ret;\r\n}\r\nret = of_platform_populate(np, NULL, NULL, dev);\r\nif (ret) {\r\ndev_err(dev, "failed to populate child nodes %d\n", ret);\r\ngoto err_device_remove;\r\n}\r\narche_pdata->pm_notifier.notifier_call = arche_platform_pm_notifier;\r\nret = register_pm_notifier(&arche_pdata->pm_notifier);\r\nif (ret) {\r\ndev_err(dev, "failed to register pm notifier %d\n", ret);\r\ngoto err_device_remove;\r\n}\r\narche_platform_change_state_cb = arche_platform_change_state;\r\nif (!of_property_read_bool(pdev->dev.of_node, "arche,init-off")) {\r\nmutex_lock(&arche_pdata->platform_state_mutex);\r\nret = arche_platform_coldboot_seq(arche_pdata);\r\nif (ret) {\r\ndev_err(dev, "Failed to cold boot svc %d\n", ret);\r\ngoto err_coldboot;\r\n}\r\narche_platform_wd_irq_en(arche_pdata);\r\nmutex_unlock(&arche_pdata->platform_state_mutex);\r\n}\r\ndev_info(dev, "Device registered successfully\n");\r\nreturn 0;\r\nerr_coldboot:\r\nmutex_unlock(&arche_pdata->platform_state_mutex);\r\nerr_device_remove:\r\ndevice_remove_file(&pdev->dev, &dev_attr_state);\r\nreturn ret;\r\n}\r\nstatic int arche_remove_child(struct device *dev, void *unused)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nplatform_device_unregister(pdev);\r\nreturn 0;\r\n}\r\nstatic int arche_platform_remove(struct platform_device *pdev)\r\n{\r\nstruct arche_platform_drvdata *arche_pdata = platform_get_drvdata(pdev);\r\nunregister_pm_notifier(&arche_pdata->pm_notifier);\r\ndevice_remove_file(&pdev->dev, &dev_attr_state);\r\ndevice_for_each_child(&pdev->dev, NULL, arche_remove_child);\r\narche_platform_poweroff_seq(arche_pdata);\r\nplatform_set_drvdata(pdev, NULL);\r\nif (usb3613_hub_mode_ctrl(false))\r\ndev_warn(arche_pdata->dev, "failed to control hub device\n");\r\nreturn 0;\r\n}\r\nstatic int arche_platform_suspend(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int arche_platform_resume(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic void arche_platform_shutdown(struct platform_device *pdev)\r\n{\r\nstruct arche_platform_drvdata *arche_pdata = platform_get_drvdata(pdev);\r\narche_platform_poweroff_seq(arche_pdata);\r\nusb3613_hub_mode_ctrl(false);\r\n}\r\nstatic int __init arche_init(void)\r\n{\r\nint retval;\r\nretval = platform_driver_register(&arche_platform_device_driver);\r\nif (retval)\r\nreturn retval;\r\nretval = arche_apb_init();\r\nif (retval)\r\nplatform_driver_unregister(&arche_platform_device_driver);\r\nreturn retval;\r\n}\r\nstatic void __exit arche_exit(void)\r\n{\r\narche_apb_exit();\r\nplatform_driver_unregister(&arche_platform_device_driver);\r\n}
