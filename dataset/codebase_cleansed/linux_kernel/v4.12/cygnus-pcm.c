static struct cygnus_aio_port *cygnus_dai_get_dma_data(\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *soc_runtime = substream->private_data;\r\nreturn snd_soc_dai_get_dma_data(soc_runtime->cpu_dai, substream);\r\n}\r\nstatic void ringbuf_set_initial(void __iomem *audio_io,\r\nstruct ringbuf_regs *p_rbuf,\r\nbool is_playback,\r\nu32 start,\r\nu32 periodsize,\r\nu32 bufsize)\r\n{\r\nu32 initial_rd;\r\nu32 initial_wr;\r\nu32 end;\r\nu32 fmark_val;\r\np_rbuf->period_bytes = periodsize;\r\np_rbuf->buf_size = bufsize;\r\nif (is_playback) {\r\ninitial_rd = start;\r\ninitial_wr = initial_rd ^ BIT(31);\r\n} else {\r\ninitial_wr = start;\r\ninitial_rd = initial_wr;\r\n}\r\nend = start + bufsize - 1;\r\nfmark_val = periodsize - PERIOD_BYTES_MIN;\r\nwritel(start, audio_io + p_rbuf->baseaddr);\r\nwritel(end, audio_io + p_rbuf->endaddr);\r\nwritel(fmark_val, audio_io + p_rbuf->fmark);\r\nwritel(initial_rd, audio_io + p_rbuf->rdaddr);\r\nwritel(initial_wr, audio_io + p_rbuf->wraddr);\r\n}\r\nstatic int configure_ringbuf_regs(struct snd_pcm_substream *substream)\r\n{\r\nstruct cygnus_aio_port *aio;\r\nstruct ringbuf_regs *p_rbuf;\r\nint status = 0;\r\naio = cygnus_dai_get_dma_data(substream);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\np_rbuf = &aio->play_rb_regs;\r\nswitch (aio->portnum) {\r\ncase 0:\r\n*p_rbuf = RINGBUF_REG_PLAYBACK(0);\r\nbreak;\r\ncase 1:\r\n*p_rbuf = RINGBUF_REG_PLAYBACK(2);\r\nbreak;\r\ncase 2:\r\n*p_rbuf = RINGBUF_REG_PLAYBACK(4);\r\nbreak;\r\ncase 3:\r\n*p_rbuf = RINGBUF_REG_PLAYBACK(6);\r\nbreak;\r\ndefault:\r\nstatus = -EINVAL;\r\n}\r\n} else {\r\np_rbuf = &aio->capture_rb_regs;\r\nswitch (aio->portnum) {\r\ncase 0:\r\n*p_rbuf = RINGBUF_REG_CAPTURE(0);\r\nbreak;\r\ncase 1:\r\n*p_rbuf = RINGBUF_REG_CAPTURE(2);\r\nbreak;\r\ncase 2:\r\n*p_rbuf = RINGBUF_REG_CAPTURE(4);\r\nbreak;\r\ndefault:\r\nstatus = -EINVAL;\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic struct ringbuf_regs *get_ringbuf(struct snd_pcm_substream *substream)\r\n{\r\nstruct cygnus_aio_port *aio;\r\nstruct ringbuf_regs *p_rbuf = NULL;\r\naio = cygnus_dai_get_dma_data(substream);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\np_rbuf = &aio->play_rb_regs;\r\nelse\r\np_rbuf = &aio->capture_rb_regs;\r\nreturn p_rbuf;\r\n}\r\nstatic void enable_intr(struct snd_pcm_substream *substream)\r\n{\r\nstruct cygnus_aio_port *aio;\r\nu32 clear_mask;\r\naio = cygnus_dai_get_dma_data(substream);\r\nclear_mask = BIT(aio->portnum);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nwritel(clear_mask, aio->cygaud->audio + ESR0_STATUS_CLR_OFFSET);\r\nwritel(clear_mask, aio->cygaud->audio + ESR1_STATUS_CLR_OFFSET);\r\nwritel(clear_mask, aio->cygaud->audio + ESR3_STATUS_CLR_OFFSET);\r\nwritel(clear_mask, aio->cygaud->audio + ESR0_MASK_CLR_OFFSET);\r\nwritel(clear_mask, aio->cygaud->audio + ESR1_MASK_CLR_OFFSET);\r\nwritel(clear_mask, aio->cygaud->audio + ESR3_MASK_CLR_OFFSET);\r\nwritel(ANY_PLAYBACK_IRQ,\r\naio->cygaud->audio + INTH_R5F_MASK_CLEAR_OFFSET);\r\n} else {\r\nwritel(clear_mask, aio->cygaud->audio + ESR2_STATUS_CLR_OFFSET);\r\nwritel(clear_mask, aio->cygaud->audio + ESR4_STATUS_CLR_OFFSET);\r\nwritel(clear_mask, aio->cygaud->audio + ESR2_MASK_CLR_OFFSET);\r\nwritel(clear_mask, aio->cygaud->audio + ESR4_MASK_CLR_OFFSET);\r\nwritel(ANY_CAPTURE_IRQ,\r\naio->cygaud->audio + INTH_R5F_MASK_CLEAR_OFFSET);\r\n}\r\n}\r\nstatic void disable_intr(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct cygnus_aio_port *aio;\r\nu32 set_mask;\r\naio = cygnus_dai_get_dma_data(substream);\r\ndev_dbg(rtd->cpu_dai->dev, "%s on port %d\n", __func__, aio->portnum);\r\nset_mask = BIT(aio->portnum);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nwritel(set_mask, aio->cygaud->audio + ESR0_MASK_SET_OFFSET);\r\nwritel(set_mask, aio->cygaud->audio + ESR1_MASK_SET_OFFSET);\r\nwritel(set_mask, aio->cygaud->audio + ESR3_MASK_SET_OFFSET);\r\n} else {\r\nwritel(set_mask, aio->cygaud->audio + ESR2_MASK_SET_OFFSET);\r\nwritel(set_mask, aio->cygaud->audio + ESR4_MASK_SET_OFFSET);\r\n}\r\n}\r\nstatic int cygnus_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nenable_intr(substream);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ndisable_intr(substream);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void cygnus_pcm_period_elapsed(struct snd_pcm_substream *substream)\r\n{\r\nstruct cygnus_aio_port *aio;\r\nstruct ringbuf_regs *p_rbuf = NULL;\r\nu32 regval;\r\naio = cygnus_dai_get_dma_data(substream);\r\np_rbuf = get_ringbuf(substream);\r\nsnd_pcm_period_elapsed(substream);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nregval = readl(aio->cygaud->audio + p_rbuf->rdaddr);\r\nregval = regval ^ BIT(31);\r\nwritel(regval, aio->cygaud->audio + p_rbuf->wraddr);\r\n} else {\r\nregval = readl(aio->cygaud->audio + p_rbuf->wraddr);\r\nwritel(regval, aio->cygaud->audio + p_rbuf->rdaddr);\r\n}\r\n}\r\nstatic void handle_playback_irq(struct cygnus_audio *cygaud)\r\n{\r\nvoid __iomem *audio_io;\r\nu32 port;\r\nu32 esr_status0, esr_status1, esr_status3;\r\naudio_io = cygaud->audio;\r\nesr_status0 = readl(audio_io + ESR0_STATUS_OFFSET);\r\nesr_status0 &= ~readl(audio_io + ESR0_MASK_STATUS_OFFSET);\r\nesr_status1 = readl(audio_io + ESR1_STATUS_OFFSET);\r\nesr_status1 &= ~readl(audio_io + ESR1_MASK_STATUS_OFFSET);\r\nesr_status3 = readl(audio_io + ESR3_STATUS_OFFSET);\r\nesr_status3 &= ~readl(audio_io + ESR3_MASK_STATUS_OFFSET);\r\nfor (port = 0; port < CYGNUS_MAX_PLAYBACK_PORTS; port++) {\r\nu32 esrmask = BIT(port);\r\nif ((esrmask & esr_status1) || (esrmask & esr_status0)) {\r\ndev_dbg(cygaud->dev,\r\n"Underrun: esr0=0x%x, esr1=0x%x esr3=0x%x\n",\r\nesr_status0, esr_status1, esr_status3);\r\n}\r\nif (esrmask & esr_status3) {\r\nstruct snd_pcm_substream *playstr;\r\nplaystr = cygaud->portinfo[port].play_stream;\r\ncygnus_pcm_period_elapsed(playstr);\r\n}\r\n}\r\nwritel(esr_status0, audio_io + ESR0_STATUS_CLR_OFFSET);\r\nwritel(esr_status1, audio_io + ESR1_STATUS_CLR_OFFSET);\r\nwritel(esr_status3, audio_io + ESR3_STATUS_CLR_OFFSET);\r\nwritel(esr_status3, audio_io + BF_REARM_FREE_MARK_OFFSET);\r\n}\r\nstatic void handle_capture_irq(struct cygnus_audio *cygaud)\r\n{\r\nvoid __iomem *audio_io;\r\nu32 port;\r\nu32 esr_status2, esr_status4;\r\naudio_io = cygaud->audio;\r\nesr_status2 = readl(audio_io + ESR2_STATUS_OFFSET);\r\nesr_status2 &= ~readl(audio_io + ESR2_MASK_STATUS_OFFSET);\r\nesr_status4 = readl(audio_io + ESR4_STATUS_OFFSET);\r\nesr_status4 &= ~readl(audio_io + ESR4_MASK_STATUS_OFFSET);\r\nfor (port = 0; port < CYGNUS_MAX_CAPTURE_PORTS; port++) {\r\nu32 esrmask = BIT(port);\r\nif (esrmask & esr_status2)\r\ndev_dbg(cygaud->dev,\r\n"Overflow: esr2=0x%x\n", esr_status2);\r\nif (esrmask & esr_status4) {\r\nstruct snd_pcm_substream *capstr;\r\ncapstr = cygaud->portinfo[port].capture_stream;\r\ncygnus_pcm_period_elapsed(capstr);\r\n}\r\n}\r\nwritel(esr_status2, audio_io + ESR2_STATUS_CLR_OFFSET);\r\nwritel(esr_status4, audio_io + ESR4_STATUS_CLR_OFFSET);\r\nwritel(esr_status4, audio_io + BF_REARM_FULL_MARK_OFFSET);\r\n}\r\nstatic irqreturn_t cygnus_dma_irq(int irq, void *data)\r\n{\r\nu32 r5_status;\r\nstruct cygnus_audio *cygaud = data;\r\nr5_status = readl(cygaud->audio + INTH_R5F_STATUS_OFFSET);\r\nif (!(r5_status & (ANY_PLAYBACK_IRQ | ANY_CAPTURE_IRQ)))\r\nreturn IRQ_NONE;\r\nif (ANY_PLAYBACK_IRQ & r5_status) {\r\nhandle_playback_irq(cygaud);\r\nwritel(ANY_PLAYBACK_IRQ & r5_status,\r\ncygaud->audio + INTH_R5F_CLEAR_OFFSET);\r\n}\r\nif (ANY_CAPTURE_IRQ & r5_status) {\r\nhandle_capture_irq(cygaud);\r\nwritel(ANY_CAPTURE_IRQ & r5_status,\r\ncygaud->audio + INTH_R5F_CLEAR_OFFSET);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int cygnus_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct cygnus_aio_port *aio;\r\nint ret;\r\naio = cygnus_dai_get_dma_data(substream);\r\nif (!aio)\r\nreturn -ENODEV;\r\ndev_dbg(rtd->cpu_dai->dev, "%s port %d\n", __func__, aio->portnum);\r\nsnd_soc_set_runtime_hwparams(substream, &cygnus_pcm_hw);\r\nret = snd_pcm_hw_constraint_step(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_PERIOD_BYTES, PERIOD_BYTES_MIN);\r\nif (ret < 0)\r\nreturn ret;\r\nret = snd_pcm_hw_constraint_step(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_BUFFER_BYTES, PERIOD_BYTES_MIN);\r\nif (ret < 0)\r\nreturn ret;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\naio->play_stream = substream;\r\nelse\r\naio->capture_stream = substream;\r\nreturn 0;\r\n}\r\nstatic int cygnus_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct cygnus_aio_port *aio;\r\naio = cygnus_dai_get_dma_data(substream);\r\ndev_dbg(rtd->cpu_dai->dev, "%s port %d\n", __func__, aio->portnum);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\naio->play_stream = NULL;\r\nelse\r\naio->capture_stream = NULL;\r\nif (!aio->play_stream && !aio->capture_stream)\r\ndev_dbg(rtd->cpu_dai->dev, "freed port %d\n", aio->portnum);\r\nreturn 0;\r\n}\r\nstatic int cygnus_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct cygnus_aio_port *aio;\r\nint ret = 0;\r\naio = cygnus_dai_get_dma_data(substream);\r\ndev_dbg(rtd->cpu_dai->dev, "%s port %d\n", __func__, aio->portnum);\r\nsnd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);\r\nruntime->dma_bytes = params_buffer_bytes(params);\r\nreturn ret;\r\n}\r\nstatic int cygnus_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct cygnus_aio_port *aio;\r\naio = cygnus_dai_get_dma_data(substream);\r\ndev_dbg(rtd->cpu_dai->dev, "%s port %d\n", __func__, aio->portnum);\r\nsnd_pcm_set_runtime_buffer(substream, NULL);\r\nreturn 0;\r\n}\r\nstatic int cygnus_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct cygnus_aio_port *aio;\r\nunsigned long bufsize, periodsize;\r\nint ret = 0;\r\nbool is_play;\r\nu32 start;\r\nstruct ringbuf_regs *p_rbuf = NULL;\r\naio = cygnus_dai_get_dma_data(substream);\r\ndev_dbg(rtd->cpu_dai->dev, "%s port %d\n", __func__, aio->portnum);\r\nbufsize = snd_pcm_lib_buffer_bytes(substream);\r\nperiodsize = snd_pcm_lib_period_bytes(substream);\r\ndev_dbg(rtd->cpu_dai->dev, "%s (buf_size %lu) (period_size %lu)\n",\r\n__func__, bufsize, periodsize);\r\nconfigure_ringbuf_regs(substream);\r\np_rbuf = get_ringbuf(substream);\r\nstart = runtime->dma_addr;\r\nis_play = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ? 1 : 0;\r\nringbuf_set_initial(aio->cygaud->audio, p_rbuf, is_play, start,\r\nperiodsize, bufsize);\r\nreturn ret;\r\n}\r\nstatic snd_pcm_uframes_t cygnus_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct cygnus_aio_port *aio;\r\nunsigned int res = 0, cur = 0, base = 0;\r\nstruct ringbuf_regs *p_rbuf = NULL;\r\naio = cygnus_dai_get_dma_data(substream);\r\np_rbuf = get_ringbuf(substream);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ncur = readl(aio->cygaud->audio + p_rbuf->rdaddr);\r\nelse\r\ncur = readl(aio->cygaud->audio + p_rbuf->wraddr);\r\nbase = readl(aio->cygaud->audio + p_rbuf->baseaddr);\r\nres = (cur & 0x7fffffff) - (base & 0x7fffffff);\r\nreturn bytes_to_frames(substream->runtime, res);\r\n}\r\nstatic int cygnus_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)\r\n{\r\nstruct snd_pcm_substream *substream = pcm->streams[stream].substream;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_dma_buffer *buf = &substream->dma_buffer;\r\nsize_t size;\r\nsize = cygnus_pcm_hw.buffer_bytes_max;\r\nbuf->dev.type = SNDRV_DMA_TYPE_DEV;\r\nbuf->dev.dev = pcm->card->dev;\r\nbuf->private_data = NULL;\r\nbuf->area = dma_alloc_coherent(pcm->card->dev, size,\r\n&buf->addr, GFP_KERNEL);\r\ndev_dbg(rtd->cpu_dai->dev, "%s: size 0x%zx @ %pK\n",\r\n__func__, size, buf->area);\r\nif (!buf->area) {\r\ndev_err(rtd->cpu_dai->dev, "%s: dma_alloc failed\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nbuf->bytes = size;\r\nreturn 0;\r\n}\r\nstatic void cygnus_dma_free_dma_buffers(struct snd_pcm *pcm)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_dma_buffer *buf;\r\nsubstream = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream;\r\nif (substream) {\r\nbuf = &substream->dma_buffer;\r\nif (buf->area) {\r\ndma_free_coherent(pcm->card->dev, buf->bytes,\r\nbuf->area, buf->addr);\r\nbuf->area = NULL;\r\n}\r\n}\r\nsubstream = pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream;\r\nif (substream) {\r\nbuf = &substream->dma_buffer;\r\nif (buf->area) {\r\ndma_free_coherent(pcm->card->dev, buf->bytes,\r\nbuf->area, buf->addr);\r\nbuf->area = NULL;\r\n}\r\n}\r\n}\r\nstatic int cygnus_dma_new(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct snd_card *card = rtd->card->snd_card;\r\nstruct snd_pcm *pcm = rtd->pcm;\r\nint ret;\r\nif (!card->dev->dma_mask)\r\ncard->dev->dma_mask = &cygnus_dma_dmamask;\r\nif (!card->dev->coherent_dma_mask)\r\ncard->dev->coherent_dma_mask = DMA_BIT_MASK(32);\r\nif (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {\r\nret = cygnus_pcm_preallocate_dma_buffer(pcm,\r\nSNDRV_PCM_STREAM_PLAYBACK);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {\r\nret = cygnus_pcm_preallocate_dma_buffer(pcm,\r\nSNDRV_PCM_STREAM_CAPTURE);\r\nif (ret) {\r\ncygnus_dma_free_dma_buffers(pcm);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint cygnus_soc_platform_register(struct device *dev,\r\nstruct cygnus_audio *cygaud)\r\n{\r\nint rc = 0;\r\ndev_dbg(dev, "%s Enter\n", __func__);\r\nrc = devm_request_irq(dev, cygaud->irq_num, cygnus_dma_irq,\r\nIRQF_SHARED, "cygnus-audio", cygaud);\r\nif (rc) {\r\ndev_err(dev, "%s request_irq error %d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nrc = snd_soc_register_platform(dev, &cygnus_soc_platform);\r\nif (rc) {\r\ndev_err(dev, "%s failed\n", __func__);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nint cygnus_soc_platform_unregister(struct device *dev)\r\n{\r\nsnd_soc_unregister_platform(dev);\r\nreturn 0;\r\n}
