int __weak arch_kexec_kernel_image_probe(struct kimage *image, void *buf,\r\nunsigned long buf_len)\r\n{\r\nreturn -ENOEXEC;\r\n}\r\nvoid * __weak arch_kexec_kernel_image_load(struct kimage *image)\r\n{\r\nreturn ERR_PTR(-ENOEXEC);\r\n}\r\nint __weak arch_kimage_file_post_load_cleanup(struct kimage *image)\r\n{\r\nreturn -EINVAL;\r\n}\r\nint __weak arch_kexec_kernel_verify_sig(struct kimage *image, void *buf,\r\nunsigned long buf_len)\r\n{\r\nreturn -EKEYREJECTED;\r\n}\r\nint __weak\r\narch_kexec_apply_relocations_add(const Elf_Ehdr *ehdr, Elf_Shdr *sechdrs,\r\nunsigned int relsec)\r\n{\r\npr_err("RELA relocation unsupported.\n");\r\nreturn -ENOEXEC;\r\n}\r\nint __weak\r\narch_kexec_apply_relocations(const Elf_Ehdr *ehdr, Elf_Shdr *sechdrs,\r\nunsigned int relsec)\r\n{\r\npr_err("REL relocation unsupported.\n");\r\nreturn -ENOEXEC;\r\n}\r\nvoid kimage_file_post_load_cleanup(struct kimage *image)\r\n{\r\nstruct purgatory_info *pi = &image->purgatory_info;\r\nvfree(image->kernel_buf);\r\nimage->kernel_buf = NULL;\r\nvfree(image->initrd_buf);\r\nimage->initrd_buf = NULL;\r\nkfree(image->cmdline_buf);\r\nimage->cmdline_buf = NULL;\r\nvfree(pi->purgatory_buf);\r\npi->purgatory_buf = NULL;\r\nvfree(pi->sechdrs);\r\npi->sechdrs = NULL;\r\narch_kimage_file_post_load_cleanup(image);\r\nkfree(image->image_loader_data);\r\nimage->image_loader_data = NULL;\r\n}\r\nstatic int\r\nkimage_file_prepare_segments(struct kimage *image, int kernel_fd, int initrd_fd,\r\nconst char __user *cmdline_ptr,\r\nunsigned long cmdline_len, unsigned flags)\r\n{\r\nint ret = 0;\r\nvoid *ldata;\r\nloff_t size;\r\nret = kernel_read_file_from_fd(kernel_fd, &image->kernel_buf,\r\n&size, INT_MAX, READING_KEXEC_IMAGE);\r\nif (ret)\r\nreturn ret;\r\nimage->kernel_buf_len = size;\r\nima_add_kexec_buffer(image);\r\nret = arch_kexec_kernel_image_probe(image, image->kernel_buf,\r\nimage->kernel_buf_len);\r\nif (ret)\r\ngoto out;\r\n#ifdef CONFIG_KEXEC_VERIFY_SIG\r\nret = arch_kexec_kernel_verify_sig(image, image->kernel_buf,\r\nimage->kernel_buf_len);\r\nif (ret) {\r\npr_debug("kernel signature verification failed.\n");\r\ngoto out;\r\n}\r\npr_debug("kernel signature verification successful.\n");\r\n#endif\r\nif (!(flags & KEXEC_FILE_NO_INITRAMFS)) {\r\nret = kernel_read_file_from_fd(initrd_fd, &image->initrd_buf,\r\n&size, INT_MAX,\r\nREADING_KEXEC_INITRAMFS);\r\nif (ret)\r\ngoto out;\r\nimage->initrd_buf_len = size;\r\n}\r\nif (cmdline_len) {\r\nimage->cmdline_buf = kzalloc(cmdline_len, GFP_KERNEL);\r\nif (!image->cmdline_buf) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = copy_from_user(image->cmdline_buf, cmdline_ptr,\r\ncmdline_len);\r\nif (ret) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nimage->cmdline_buf_len = cmdline_len;\r\nif (image->cmdline_buf[cmdline_len - 1] != '\0') {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nldata = arch_kexec_kernel_image_load(image);\r\nif (IS_ERR(ldata)) {\r\nret = PTR_ERR(ldata);\r\ngoto out;\r\n}\r\nimage->image_loader_data = ldata;\r\nout:\r\nif (ret)\r\nkimage_file_post_load_cleanup(image);\r\nreturn ret;\r\n}\r\nstatic int\r\nkimage_file_alloc_init(struct kimage **rimage, int kernel_fd,\r\nint initrd_fd, const char __user *cmdline_ptr,\r\nunsigned long cmdline_len, unsigned long flags)\r\n{\r\nint ret;\r\nstruct kimage *image;\r\nbool kexec_on_panic = flags & KEXEC_FILE_ON_CRASH;\r\nimage = do_kimage_alloc_init();\r\nif (!image)\r\nreturn -ENOMEM;\r\nimage->file_mode = 1;\r\nif (kexec_on_panic) {\r\nimage->control_page = crashk_res.start;\r\nimage->type = KEXEC_TYPE_CRASH;\r\n}\r\nret = kimage_file_prepare_segments(image, kernel_fd, initrd_fd,\r\ncmdline_ptr, cmdline_len, flags);\r\nif (ret)\r\ngoto out_free_image;\r\nret = sanity_check_segment_list(image);\r\nif (ret)\r\ngoto out_free_post_load_bufs;\r\nret = -ENOMEM;\r\nimage->control_code_page = kimage_alloc_control_pages(image,\r\nget_order(KEXEC_CONTROL_PAGE_SIZE));\r\nif (!image->control_code_page) {\r\npr_err("Could not allocate control_code_buffer\n");\r\ngoto out_free_post_load_bufs;\r\n}\r\nif (!kexec_on_panic) {\r\nimage->swap_page = kimage_alloc_control_pages(image, 0);\r\nif (!image->swap_page) {\r\npr_err("Could not allocate swap buffer\n");\r\ngoto out_free_control_pages;\r\n}\r\n}\r\n*rimage = image;\r\nreturn 0;\r\nout_free_control_pages:\r\nkimage_free_page_list(&image->control_pages);\r\nout_free_post_load_bufs:\r\nkimage_file_post_load_cleanup(image);\r\nout_free_image:\r\nkfree(image);\r\nreturn ret;\r\n}\r\nstatic int locate_mem_hole_top_down(unsigned long start, unsigned long end,\r\nstruct kexec_buf *kbuf)\r\n{\r\nstruct kimage *image = kbuf->image;\r\nunsigned long temp_start, temp_end;\r\ntemp_end = min(end, kbuf->buf_max);\r\ntemp_start = temp_end - kbuf->memsz;\r\ndo {\r\ntemp_start = temp_start & (~(kbuf->buf_align - 1));\r\nif (temp_start < start || temp_start < kbuf->buf_min)\r\nreturn 0;\r\ntemp_end = temp_start + kbuf->memsz - 1;\r\nif (kimage_is_destination_range(image, temp_start, temp_end)) {\r\ntemp_start = temp_start - PAGE_SIZE;\r\ncontinue;\r\n}\r\nbreak;\r\n} while (1);\r\nkbuf->mem = temp_start;\r\nreturn 1;\r\n}\r\nstatic int locate_mem_hole_bottom_up(unsigned long start, unsigned long end,\r\nstruct kexec_buf *kbuf)\r\n{\r\nstruct kimage *image = kbuf->image;\r\nunsigned long temp_start, temp_end;\r\ntemp_start = max(start, kbuf->buf_min);\r\ndo {\r\ntemp_start = ALIGN(temp_start, kbuf->buf_align);\r\ntemp_end = temp_start + kbuf->memsz - 1;\r\nif (temp_end > end || temp_end > kbuf->buf_max)\r\nreturn 0;\r\nif (kimage_is_destination_range(image, temp_start, temp_end)) {\r\ntemp_start = temp_start + PAGE_SIZE;\r\ncontinue;\r\n}\r\nbreak;\r\n} while (1);\r\nkbuf->mem = temp_start;\r\nreturn 1;\r\n}\r\nstatic int locate_mem_hole_callback(u64 start, u64 end, void *arg)\r\n{\r\nstruct kexec_buf *kbuf = (struct kexec_buf *)arg;\r\nunsigned long sz = end - start + 1;\r\nif (sz < kbuf->memsz)\r\nreturn 0;\r\nif (end < kbuf->buf_min || start > kbuf->buf_max)\r\nreturn 0;\r\nif (kbuf->top_down)\r\nreturn locate_mem_hole_top_down(start, end, kbuf);\r\nreturn locate_mem_hole_bottom_up(start, end, kbuf);\r\n}\r\nint __weak arch_kexec_walk_mem(struct kexec_buf *kbuf,\r\nint (*func)(u64, u64, void *))\r\n{\r\nif (kbuf->image->type == KEXEC_TYPE_CRASH)\r\nreturn walk_iomem_res_desc(crashk_res.desc,\r\nIORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY,\r\ncrashk_res.start, crashk_res.end,\r\nkbuf, func);\r\nelse\r\nreturn walk_system_ram_res(0, ULONG_MAX, kbuf, func);\r\n}\r\nint kexec_locate_mem_hole(struct kexec_buf *kbuf)\r\n{\r\nint ret;\r\nret = arch_kexec_walk_mem(kbuf, locate_mem_hole_callback);\r\nreturn ret == 1 ? 0 : -EADDRNOTAVAIL;\r\n}\r\nint kexec_add_buffer(struct kexec_buf *kbuf)\r\n{\r\nstruct kexec_segment *ksegment;\r\nint ret;\r\nif (!kbuf->image->file_mode)\r\nreturn -EINVAL;\r\nif (kbuf->image->nr_segments >= KEXEC_SEGMENT_MAX)\r\nreturn -EINVAL;\r\nif (!list_empty(&kbuf->image->control_pages)) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nkbuf->memsz = ALIGN(kbuf->memsz, PAGE_SIZE);\r\nkbuf->buf_align = max(kbuf->buf_align, PAGE_SIZE);\r\nret = kexec_locate_mem_hole(kbuf);\r\nif (ret)\r\nreturn ret;\r\nksegment = &kbuf->image->segment[kbuf->image->nr_segments];\r\nksegment->kbuf = kbuf->buffer;\r\nksegment->bufsz = kbuf->bufsz;\r\nksegment->mem = kbuf->mem;\r\nksegment->memsz = kbuf->memsz;\r\nkbuf->image->nr_segments++;\r\nreturn 0;\r\n}\r\nstatic int kexec_calculate_store_digests(struct kimage *image)\r\n{\r\nstruct crypto_shash *tfm;\r\nstruct shash_desc *desc;\r\nint ret = 0, i, j, zero_buf_sz, sha_region_sz;\r\nsize_t desc_size, nullsz;\r\nchar *digest;\r\nvoid *zero_buf;\r\nstruct kexec_sha_region *sha_regions;\r\nstruct purgatory_info *pi = &image->purgatory_info;\r\nzero_buf = __va(page_to_pfn(ZERO_PAGE(0)) << PAGE_SHIFT);\r\nzero_buf_sz = PAGE_SIZE;\r\ntfm = crypto_alloc_shash("sha256", 0, 0);\r\nif (IS_ERR(tfm)) {\r\nret = PTR_ERR(tfm);\r\ngoto out;\r\n}\r\ndesc_size = crypto_shash_descsize(tfm) + sizeof(*desc);\r\ndesc = kzalloc(desc_size, GFP_KERNEL);\r\nif (!desc) {\r\nret = -ENOMEM;\r\ngoto out_free_tfm;\r\n}\r\nsha_region_sz = KEXEC_SEGMENT_MAX * sizeof(struct kexec_sha_region);\r\nsha_regions = vzalloc(sha_region_sz);\r\nif (!sha_regions)\r\ngoto out_free_desc;\r\ndesc->tfm = tfm;\r\ndesc->flags = 0;\r\nret = crypto_shash_init(desc);\r\nif (ret < 0)\r\ngoto out_free_sha_regions;\r\ndigest = kzalloc(SHA256_DIGEST_SIZE, GFP_KERNEL);\r\nif (!digest) {\r\nret = -ENOMEM;\r\ngoto out_free_sha_regions;\r\n}\r\nfor (j = i = 0; i < image->nr_segments; i++) {\r\nstruct kexec_segment *ksegment;\r\nksegment = &image->segment[i];\r\nif (ksegment->kbuf == pi->purgatory_buf)\r\ncontinue;\r\nret = crypto_shash_update(desc, ksegment->kbuf,\r\nksegment->bufsz);\r\nif (ret)\r\nbreak;\r\nnullsz = ksegment->memsz - ksegment->bufsz;\r\nwhile (nullsz) {\r\nunsigned long bytes = nullsz;\r\nif (bytes > zero_buf_sz)\r\nbytes = zero_buf_sz;\r\nret = crypto_shash_update(desc, zero_buf, bytes);\r\nif (ret)\r\nbreak;\r\nnullsz -= bytes;\r\n}\r\nif (ret)\r\nbreak;\r\nsha_regions[j].start = ksegment->mem;\r\nsha_regions[j].len = ksegment->memsz;\r\nj++;\r\n}\r\nif (!ret) {\r\nret = crypto_shash_final(desc, digest);\r\nif (ret)\r\ngoto out_free_digest;\r\nret = kexec_purgatory_get_set_symbol(image, "purgatory_sha_regions",\r\nsha_regions, sha_region_sz, 0);\r\nif (ret)\r\ngoto out_free_digest;\r\nret = kexec_purgatory_get_set_symbol(image, "purgatory_sha256_digest",\r\ndigest, SHA256_DIGEST_SIZE, 0);\r\nif (ret)\r\ngoto out_free_digest;\r\n}\r\nout_free_digest:\r\nkfree(digest);\r\nout_free_sha_regions:\r\nvfree(sha_regions);\r\nout_free_desc:\r\nkfree(desc);\r\nout_free_tfm:\r\nkfree(tfm);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __kexec_load_purgatory(struct kimage *image, unsigned long min,\r\nunsigned long max, int top_down)\r\n{\r\nstruct purgatory_info *pi = &image->purgatory_info;\r\nunsigned long align, bss_align, bss_sz, bss_pad;\r\nunsigned long entry, load_addr, curr_load_addr, bss_addr, offset;\r\nunsigned char *buf_addr, *src;\r\nint i, ret = 0, entry_sidx = -1;\r\nconst Elf_Shdr *sechdrs_c;\r\nElf_Shdr *sechdrs = NULL;\r\nstruct kexec_buf kbuf = { .image = image, .bufsz = 0, .buf_align = 1,\r\n.buf_min = min, .buf_max = max,\r\n.top_down = top_down };\r\nsechdrs_c = (void *)pi->ehdr + pi->ehdr->e_shoff;\r\nsechdrs = vzalloc(pi->ehdr->e_shnum * sizeof(Elf_Shdr));\r\nif (!sechdrs)\r\nreturn -ENOMEM;\r\nmemcpy(sechdrs, sechdrs_c, pi->ehdr->e_shnum * sizeof(Elf_Shdr));\r\nfor (i = 0; i < pi->ehdr->e_shnum; i++) {\r\nif (sechdrs[i].sh_type == SHT_NOBITS)\r\ncontinue;\r\nsechdrs[i].sh_offset = (unsigned long)pi->ehdr +\r\nsechdrs[i].sh_offset;\r\n}\r\nentry = pi->ehdr->e_entry;\r\nfor (i = 0; i < pi->ehdr->e_shnum; i++) {\r\nif (!(sechdrs[i].sh_flags & SHF_ALLOC))\r\ncontinue;\r\nif (!(sechdrs[i].sh_flags & SHF_EXECINSTR))\r\ncontinue;\r\nif (sechdrs[i].sh_addr <= pi->ehdr->e_entry &&\r\n((sechdrs[i].sh_addr + sechdrs[i].sh_size) >\r\npi->ehdr->e_entry)) {\r\nentry_sidx = i;\r\nentry -= sechdrs[i].sh_addr;\r\nbreak;\r\n}\r\n}\r\nbss_align = 1;\r\nbss_sz = 0;\r\nfor (i = 0; i < pi->ehdr->e_shnum; i++) {\r\nif (!(sechdrs[i].sh_flags & SHF_ALLOC))\r\ncontinue;\r\nalign = sechdrs[i].sh_addralign;\r\nif (sechdrs[i].sh_type != SHT_NOBITS) {\r\nif (kbuf.buf_align < align)\r\nkbuf.buf_align = align;\r\nkbuf.bufsz = ALIGN(kbuf.bufsz, align);\r\nkbuf.bufsz += sechdrs[i].sh_size;\r\n} else {\r\nif (bss_align < align)\r\nbss_align = align;\r\nbss_sz = ALIGN(bss_sz, align);\r\nbss_sz += sechdrs[i].sh_size;\r\n}\r\n}\r\nbss_pad = 0;\r\nif (kbuf.bufsz & (bss_align - 1))\r\nbss_pad = bss_align - (kbuf.bufsz & (bss_align - 1));\r\nkbuf.memsz = kbuf.bufsz + bss_pad + bss_sz;\r\nkbuf.buffer = vzalloc(kbuf.bufsz);\r\nif (!kbuf.buffer) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nif (kbuf.buf_align < bss_align)\r\nkbuf.buf_align = bss_align;\r\nret = kexec_add_buffer(&kbuf);\r\nif (ret)\r\ngoto out;\r\npi->purgatory_load_addr = kbuf.mem;\r\nbuf_addr = kbuf.buffer;\r\nload_addr = curr_load_addr = pi->purgatory_load_addr;\r\nbss_addr = load_addr + kbuf.bufsz + bss_pad;\r\nfor (i = 0; i < pi->ehdr->e_shnum; i++) {\r\nif (!(sechdrs[i].sh_flags & SHF_ALLOC))\r\ncontinue;\r\nalign = sechdrs[i].sh_addralign;\r\nif (sechdrs[i].sh_type != SHT_NOBITS) {\r\ncurr_load_addr = ALIGN(curr_load_addr, align);\r\noffset = curr_load_addr - load_addr;\r\nsrc = (char *) sechdrs[i].sh_offset;\r\nmemcpy(buf_addr + offset, src, sechdrs[i].sh_size);\r\nsechdrs[i].sh_addr = curr_load_addr;\r\nsechdrs[i].sh_offset = (unsigned long)(buf_addr + offset);\r\ncurr_load_addr += sechdrs[i].sh_size;\r\n} else {\r\nbss_addr = ALIGN(bss_addr, align);\r\nsechdrs[i].sh_addr = bss_addr;\r\nbss_addr += sechdrs[i].sh_size;\r\n}\r\n}\r\nif (entry_sidx >= 0)\r\nentry += sechdrs[entry_sidx].sh_addr;\r\nimage->start = entry;\r\npi->sechdrs = sechdrs;\r\npi->purgatory_buf = kbuf.buffer;\r\nreturn ret;\r\nout:\r\nvfree(sechdrs);\r\nvfree(kbuf.buffer);\r\nreturn ret;\r\n}\r\nstatic int kexec_apply_relocations(struct kimage *image)\r\n{\r\nint i, ret;\r\nstruct purgatory_info *pi = &image->purgatory_info;\r\nElf_Shdr *sechdrs = pi->sechdrs;\r\nfor (i = 0; i < pi->ehdr->e_shnum; i++) {\r\nElf_Shdr *section, *symtab;\r\nif (sechdrs[i].sh_type != SHT_RELA &&\r\nsechdrs[i].sh_type != SHT_REL)\r\ncontinue;\r\nif (sechdrs[i].sh_info >= pi->ehdr->e_shnum ||\r\nsechdrs[i].sh_link >= pi->ehdr->e_shnum)\r\nreturn -ENOEXEC;\r\nsection = &sechdrs[sechdrs[i].sh_info];\r\nsymtab = &sechdrs[sechdrs[i].sh_link];\r\nif (!(section->sh_flags & SHF_ALLOC))\r\ncontinue;\r\nif (symtab->sh_link >= pi->ehdr->e_shnum)\r\ncontinue;\r\nif (sechdrs[i].sh_type == SHT_RELA)\r\nret = arch_kexec_apply_relocations_add(pi->ehdr,\r\nsechdrs, i);\r\nelse if (sechdrs[i].sh_type == SHT_REL)\r\nret = arch_kexec_apply_relocations(pi->ehdr,\r\nsechdrs, i);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint kexec_load_purgatory(struct kimage *image, unsigned long min,\r\nunsigned long max, int top_down,\r\nunsigned long *load_addr)\r\n{\r\nstruct purgatory_info *pi = &image->purgatory_info;\r\nint ret;\r\nif (kexec_purgatory_size <= 0)\r\nreturn -EINVAL;\r\nif (kexec_purgatory_size < sizeof(Elf_Ehdr))\r\nreturn -ENOEXEC;\r\npi->ehdr = (Elf_Ehdr *)kexec_purgatory;\r\nif (memcmp(pi->ehdr->e_ident, ELFMAG, SELFMAG) != 0\r\n|| pi->ehdr->e_type != ET_REL\r\n|| !elf_check_arch(pi->ehdr)\r\n|| pi->ehdr->e_shentsize != sizeof(Elf_Shdr))\r\nreturn -ENOEXEC;\r\nif (pi->ehdr->e_shoff >= kexec_purgatory_size\r\n|| (pi->ehdr->e_shnum * sizeof(Elf_Shdr) >\r\nkexec_purgatory_size - pi->ehdr->e_shoff))\r\nreturn -ENOEXEC;\r\nret = __kexec_load_purgatory(image, min, max, top_down);\r\nif (ret)\r\nreturn ret;\r\nret = kexec_apply_relocations(image);\r\nif (ret)\r\ngoto out;\r\n*load_addr = pi->purgatory_load_addr;\r\nreturn 0;\r\nout:\r\nvfree(pi->sechdrs);\r\npi->sechdrs = NULL;\r\nvfree(pi->purgatory_buf);\r\npi->purgatory_buf = NULL;\r\nreturn ret;\r\n}\r\nstatic Elf_Sym *kexec_purgatory_find_symbol(struct purgatory_info *pi,\r\nconst char *name)\r\n{\r\nElf_Sym *syms;\r\nElf_Shdr *sechdrs;\r\nElf_Ehdr *ehdr;\r\nint i, k;\r\nconst char *strtab;\r\nif (!pi->sechdrs || !pi->ehdr)\r\nreturn NULL;\r\nsechdrs = pi->sechdrs;\r\nehdr = pi->ehdr;\r\nfor (i = 0; i < ehdr->e_shnum; i++) {\r\nif (sechdrs[i].sh_type != SHT_SYMTAB)\r\ncontinue;\r\nif (sechdrs[i].sh_link >= ehdr->e_shnum)\r\ncontinue;\r\nstrtab = (char *)sechdrs[sechdrs[i].sh_link].sh_offset;\r\nsyms = (Elf_Sym *)sechdrs[i].sh_offset;\r\nfor (k = 0; k < sechdrs[i].sh_size/sizeof(Elf_Sym); k++) {\r\nif (ELF_ST_BIND(syms[k].st_info) != STB_GLOBAL)\r\ncontinue;\r\nif (strcmp(strtab + syms[k].st_name, name) != 0)\r\ncontinue;\r\nif (syms[k].st_shndx == SHN_UNDEF ||\r\nsyms[k].st_shndx >= ehdr->e_shnum) {\r\npr_debug("Symbol: %s has bad section index %d.\n",\r\nname, syms[k].st_shndx);\r\nreturn NULL;\r\n}\r\nreturn &syms[k];\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nvoid *kexec_purgatory_get_symbol_addr(struct kimage *image, const char *name)\r\n{\r\nstruct purgatory_info *pi = &image->purgatory_info;\r\nElf_Sym *sym;\r\nElf_Shdr *sechdr;\r\nsym = kexec_purgatory_find_symbol(pi, name);\r\nif (!sym)\r\nreturn ERR_PTR(-EINVAL);\r\nsechdr = &pi->sechdrs[sym->st_shndx];\r\nreturn (void *)(sechdr->sh_addr + sym->st_value);\r\n}\r\nint kexec_purgatory_get_set_symbol(struct kimage *image, const char *name,\r\nvoid *buf, unsigned int size, bool get_value)\r\n{\r\nElf_Sym *sym;\r\nElf_Shdr *sechdrs;\r\nstruct purgatory_info *pi = &image->purgatory_info;\r\nchar *sym_buf;\r\nsym = kexec_purgatory_find_symbol(pi, name);\r\nif (!sym)\r\nreturn -EINVAL;\r\nif (sym->st_size != size) {\r\npr_err("symbol %s size mismatch: expected %lu actual %u\n",\r\nname, (unsigned long)sym->st_size, size);\r\nreturn -EINVAL;\r\n}\r\nsechdrs = pi->sechdrs;\r\nif (sechdrs[sym->st_shndx].sh_type == SHT_NOBITS) {\r\npr_err("symbol %s is in a bss section. Cannot %s\n", name,\r\nget_value ? "get" : "set");\r\nreturn -EINVAL;\r\n}\r\nsym_buf = (unsigned char *)sechdrs[sym->st_shndx].sh_offset +\r\nsym->st_value;\r\nif (get_value)\r\nmemcpy((void *)buf, sym_buf, size);\r\nelse\r\nmemcpy((void *)sym_buf, buf, size);\r\nreturn 0;\r\n}
