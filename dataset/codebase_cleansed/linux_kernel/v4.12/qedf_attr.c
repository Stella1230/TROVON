static ssize_t\r\nqedf_fcoe_mac_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fc_lport *lport = shost_priv(class_to_shost(dev));\r\nu32 port_id;\r\nu8 lport_src_id[3];\r\nu8 fcoe_mac[6];\r\nport_id = fc_host_port_id(lport->host);\r\nlport_src_id[2] = (port_id & 0x000000FF);\r\nlport_src_id[1] = (port_id & 0x0000FF00) >> 8;\r\nlport_src_id[0] = (port_id & 0x00FF0000) >> 16;\r\nfc_fcoe_set_mac(fcoe_mac, lport_src_id);\r\nreturn scnprintf(buf, PAGE_SIZE, "%pM\n", fcoe_mac);\r\n}\r\ninline bool qedf_is_vport(struct qedf_ctx *qedf)\r\n{\r\nreturn (!(qedf->lport->vport == NULL));\r\n}\r\nstatic struct qedf_ctx *qedf_get_base_qedf(struct qedf_ctx *qedf)\r\n{\r\nstruct fc_lport *lport;\r\nstruct fc_lport *base_lport;\r\nif (!(qedf_is_vport(qedf)))\r\nreturn NULL;\r\nlport = qedf->lport;\r\nbase_lport = shost_priv(vport_to_shost(lport->vport));\r\nreturn (struct qedf_ctx *)(lport_priv(base_lport));\r\n}\r\nvoid qedf_capture_grc_dump(struct qedf_ctx *qedf)\r\n{\r\nstruct qedf_ctx *base_qedf;\r\nif (qedf_is_vport(qedf))\r\nbase_qedf = qedf_get_base_qedf(qedf);\r\nelse\r\nbase_qedf = qedf;\r\nif (test_bit(QEDF_GRCDUMP_CAPTURE, &base_qedf->flags)) {\r\nQEDF_INFO(&(base_qedf->dbg_ctx), QEDF_LOG_INFO,\r\n"GRC Dump already captured.\n");\r\nreturn;\r\n}\r\nqedf_get_grc_dump(base_qedf->cdev, qed_ops->common,\r\n&base_qedf->grcdump, &base_qedf->grcdump_size);\r\nQEDF_ERR(&(base_qedf->dbg_ctx), "GRC Dump captured.\n");\r\nset_bit(QEDF_GRCDUMP_CAPTURE, &base_qedf->flags);\r\nqedf_uevent_emit(base_qedf->lport->host, QEDF_UEVENT_CODE_GRCDUMP,\r\nNULL);\r\n}\r\nstatic ssize_t\r\nqedf_sysfs_read_grcdump(struct file *filep, struct kobject *kobj,\r\nstruct bin_attribute *ba, char *buf, loff_t off,\r\nsize_t count)\r\n{\r\nssize_t ret = 0;\r\nstruct fc_lport *lport = shost_priv(dev_to_shost(container_of(kobj,\r\nstruct device, kobj)));\r\nstruct qedf_ctx *qedf = lport_priv(lport);\r\nif (test_bit(QEDF_GRCDUMP_CAPTURE, &qedf->flags)) {\r\nret = memory_read_from_buffer(buf, count, &off,\r\nqedf->grcdump, qedf->grcdump_size);\r\n} else {\r\nQEDF_ERR(&(qedf->dbg_ctx), "GRC Dump not captured!\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\nqedf_sysfs_write_grcdump(struct file *filep, struct kobject *kobj,\r\nstruct bin_attribute *ba, char *buf, loff_t off,\r\nsize_t count)\r\n{\r\nstruct fc_lport *lport = NULL;\r\nstruct qedf_ctx *qedf = NULL;\r\nlong reading;\r\nint ret = 0;\r\nchar msg[40];\r\nif (off != 0)\r\nreturn ret;\r\nlport = shost_priv(dev_to_shost(container_of(kobj,\r\nstruct device, kobj)));\r\nqedf = lport_priv(lport);\r\nbuf[1] = 0;\r\nret = kstrtol(buf, 10, &reading);\r\nif (ret) {\r\nQEDF_ERR(&(qedf->dbg_ctx), "Invalid input, err(%d)\n", ret);\r\nreturn ret;\r\n}\r\nmemset(msg, 0, sizeof(msg));\r\nswitch (reading) {\r\ncase 0:\r\nmemset(qedf->grcdump, 0, qedf->grcdump_size);\r\nclear_bit(QEDF_GRCDUMP_CAPTURE, &qedf->flags);\r\nbreak;\r\ncase 1:\r\nqedf_capture_grc_dump(qedf);\r\nbreak;\r\n}\r\nreturn count;\r\n}\r\nvoid qedf_create_sysfs_ctx_attr(struct qedf_ctx *qedf)\r\n{\r\nqedf_create_sysfs_attr(qedf->lport->host, bin_file_entries);\r\n}\r\nvoid qedf_remove_sysfs_ctx_attr(struct qedf_ctx *qedf)\r\n{\r\nqedf_remove_sysfs_attr(qedf->lport->host, bin_file_entries);\r\n}
