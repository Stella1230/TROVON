static int parman_enlarge(struct parman *parman)\r\n{\r\nunsigned long new_count = parman->limit_count +\r\nparman->ops->resize_step;\r\nint err;\r\nerr = parman->ops->resize(parman->priv, new_count);\r\nif (err)\r\nreturn err;\r\nparman->limit_count = new_count;\r\nreturn 0;\r\n}\r\nstatic int parman_shrink(struct parman *parman)\r\n{\r\nunsigned long new_count = parman->limit_count -\r\nparman->ops->resize_step;\r\nint err;\r\nif (new_count < parman->ops->base_count)\r\nreturn 0;\r\nerr = parman->ops->resize(parman->priv, new_count);\r\nif (err)\r\nreturn err;\r\nparman->limit_count = new_count;\r\nreturn 0;\r\n}\r\nstatic bool parman_prio_used(struct parman_prio *prio)\r\n{\r\nreturn !list_empty(&prio->item_list);\r\n}\r\nstatic struct parman_item *parman_prio_first_item(struct parman_prio *prio)\r\n{\r\nreturn list_first_entry(&prio->item_list,\r\ntypeof(struct parman_item), list);\r\n}\r\nstatic unsigned long parman_prio_first_index(struct parman_prio *prio)\r\n{\r\nreturn parman_prio_first_item(prio)->index;\r\n}\r\nstatic struct parman_item *parman_prio_last_item(struct parman_prio *prio)\r\n{\r\nreturn list_last_entry(&prio->item_list,\r\ntypeof(struct parman_item), list);\r\n}\r\nstatic unsigned long parman_prio_last_index(struct parman_prio *prio)\r\n{\r\nreturn parman_prio_last_item(prio)->index;\r\n}\r\nstatic unsigned long parman_lsort_new_index_find(struct parman *parman,\r\nstruct parman_prio *prio)\r\n{\r\nlist_for_each_entry_from_reverse(prio, &parman->prio_list, list) {\r\nif (!parman_prio_used(prio))\r\ncontinue;\r\nreturn parman_prio_last_index(prio) + 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __parman_prio_move(struct parman *parman, struct parman_prio *prio,\r\nstruct parman_item *item, unsigned long to_index,\r\nunsigned long count)\r\n{\r\nparman->ops->move(parman->priv, item->index, to_index, count);\r\n}\r\nstatic void parman_prio_shift_down(struct parman *parman,\r\nstruct parman_prio *prio)\r\n{\r\nstruct parman_item *item;\r\nunsigned long to_index;\r\nif (!parman_prio_used(prio))\r\nreturn;\r\nitem = parman_prio_first_item(prio);\r\nto_index = parman_prio_last_index(prio) + 1;\r\n__parman_prio_move(parman, prio, item, to_index, 1);\r\nlist_move_tail(&item->list, &prio->item_list);\r\nitem->index = to_index;\r\n}\r\nstatic void parman_prio_shift_up(struct parman *parman,\r\nstruct parman_prio *prio)\r\n{\r\nstruct parman_item *item;\r\nunsigned long to_index;\r\nif (!parman_prio_used(prio))\r\nreturn;\r\nitem = parman_prio_last_item(prio);\r\nto_index = parman_prio_first_index(prio) - 1;\r\n__parman_prio_move(parman, prio, item, to_index, 1);\r\nlist_move(&item->list, &prio->item_list);\r\nitem->index = to_index;\r\n}\r\nstatic void parman_prio_item_remove(struct parman *parman,\r\nstruct parman_prio *prio,\r\nstruct parman_item *item)\r\n{\r\nstruct parman_item *last_item;\r\nunsigned long to_index;\r\nlast_item = parman_prio_last_item(prio);\r\nif (last_item == item) {\r\nlist_del(&item->list);\r\nreturn;\r\n}\r\nto_index = item->index;\r\n__parman_prio_move(parman, prio, last_item, to_index, 1);\r\nlist_del(&last_item->list);\r\nlist_replace(&item->list, &last_item->list);\r\nlast_item->index = to_index;\r\n}\r\nstatic int parman_lsort_item_add(struct parman *parman,\r\nstruct parman_prio *prio,\r\nstruct parman_item *item)\r\n{\r\nstruct parman_prio *prio2;\r\nunsigned long new_index;\r\nint err;\r\nif (parman->count + 1 > parman->limit_count) {\r\nerr = parman_enlarge(parman);\r\nif (err)\r\nreturn err;\r\n}\r\nnew_index = parman_lsort_new_index_find(parman, prio);\r\nlist_for_each_entry_reverse(prio2, &parman->prio_list, list) {\r\nif (prio2 == prio)\r\nbreak;\r\nparman_prio_shift_down(parman, prio2);\r\n}\r\nitem->index = new_index;\r\nlist_add_tail(&item->list, &prio->item_list);\r\nparman->count++;\r\nreturn 0;\r\n}\r\nstatic void parman_lsort_item_remove(struct parman *parman,\r\nstruct parman_prio *prio,\r\nstruct parman_item *item)\r\n{\r\nparman_prio_item_remove(parman, prio, item);\r\nlist_for_each_entry_continue(prio, &parman->prio_list, list)\r\nparman_prio_shift_up(parman, prio);\r\nparman->count--;\r\nif (parman->limit_count - parman->count >= parman->ops->resize_step)\r\nparman_shrink(parman);\r\n}\r\nstruct parman *parman_create(const struct parman_ops *ops, void *priv)\r\n{\r\nstruct parman *parman;\r\nparman = kzalloc(sizeof(*parman), GFP_KERNEL);\r\nif (!parman)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&parman->prio_list);\r\nparman->ops = ops;\r\nparman->priv = priv;\r\nparman->limit_count = ops->base_count;\r\nparman->algo = parman_algos[ops->algo];\r\nreturn parman;\r\n}\r\nvoid parman_destroy(struct parman *parman)\r\n{\r\nWARN_ON(!list_empty(&parman->prio_list));\r\nkfree(parman);\r\n}\r\nvoid parman_prio_init(struct parman *parman, struct parman_prio *prio,\r\nunsigned long priority)\r\n{\r\nstruct parman_prio *prio2;\r\nstruct list_head *pos;\r\nINIT_LIST_HEAD(&prio->item_list);\r\nprio->priority = priority;\r\nlist_for_each(pos, &parman->prio_list) {\r\nprio2 = list_entry(pos, typeof(*prio2), list);\r\nif (prio2->priority > prio->priority)\r\nbreak;\r\n}\r\nlist_add_tail(&prio->list, pos);\r\n}\r\nvoid parman_prio_fini(struct parman_prio *prio)\r\n{\r\nWARN_ON(parman_prio_used(prio));\r\nlist_del(&prio->list);\r\n}\r\nint parman_item_add(struct parman *parman, struct parman_prio *prio,\r\nstruct parman_item *item)\r\n{\r\nreturn parman->algo->item_add(parman, prio, item);\r\n}\r\nvoid parman_item_remove(struct parman *parman, struct parman_prio *prio,\r\nstruct parman_item *item)\r\n{\r\nparman->algo->item_remove(parman, prio, item);\r\n}
