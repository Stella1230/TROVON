static inline struct axnet_dev *PRIV(struct net_device *dev)\r\n{\r\nvoid *p = (char *)netdev_priv(dev) + sizeof(struct ei_device);\r\nreturn p;\r\n}\r\nstatic int axnet_probe(struct pcmcia_device *link)\r\n{\r\nstruct axnet_dev *info;\r\nstruct net_device *dev;\r\nstruct ei_device *ei_local;\r\ndev_dbg(&link->dev, "axnet_attach()\n");\r\ndev = alloc_etherdev(sizeof(struct ei_device) + sizeof(struct axnet_dev));\r\nif (!dev)\r\nreturn -ENOMEM;\r\nei_local = netdev_priv(dev);\r\nei_local->msg_enable = axnet_msg_enable;\r\nspin_lock_init(&ei_local->page_lock);\r\ninfo = PRIV(dev);\r\ninfo->p_dev = link;\r\nlink->priv = dev;\r\nlink->config_flags |= CONF_ENABLE_IRQ;\r\ndev->netdev_ops = &axnet_netdev_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\nreturn axnet_config(link);\r\n}\r\nstatic void axnet_detach(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\ndev_dbg(&link->dev, "axnet_detach(0x%p)\n", link);\r\nunregister_netdev(dev);\r\naxnet_release(link);\r\nfree_netdev(dev);\r\n}\r\nstatic int get_prom(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nunsigned int ioaddr = dev->base_addr;\r\nint i, j;\r\nstruct {\r\nu_char value, offset;\r\n} program_seq[] = {\r\n{E8390_NODMA+E8390_PAGE0+E8390_STOP, E8390_CMD},\r\n{0x01, EN0_DCFG},\r\n{0x00, EN0_RCNTLO},\r\n{0x00, EN0_RCNTHI},\r\n{0x00, EN0_IMR},\r\n{0xFF, EN0_ISR},\r\n{E8390_RXOFF|0x40, EN0_RXCR},\r\n{E8390_TXOFF, EN0_TXCR},\r\n{0x10, EN0_RCNTLO},\r\n{0x00, EN0_RCNTHI},\r\n{0x00, EN0_RSARLO},\r\n{0x04, EN0_RSARHI},\r\n{E8390_RREAD+E8390_START, E8390_CMD},\r\n};\r\nif (link->config_base != 0x03c0)\r\nreturn 0;\r\naxnet_reset_8390(dev);\r\nmdelay(10);\r\nfor (i = 0; i < ARRAY_SIZE(program_seq); i++)\r\noutb_p(program_seq[i].value, ioaddr + program_seq[i].offset);\r\nfor (i = 0; i < 6; i += 2) {\r\nj = inw(ioaddr + AXNET_DATAPORT);\r\ndev->dev_addr[i] = j & 0xff;\r\ndev->dev_addr[i+1] = j >> 8;\r\n}\r\nreturn 1;\r\n}\r\nstatic int try_io_port(struct pcmcia_device *link)\r\n{\r\nint j, ret;\r\nlink->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\r\nlink->resource[1]->flags &= ~IO_DATA_PATH_WIDTH;\r\nif (link->resource[0]->end == 32) {\r\nlink->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;\r\nif (link->resource[1]->end > 0)\r\nlink->resource[1]->flags |= IO_DATA_PATH_WIDTH_8;\r\n} else {\r\nlink->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;\r\nlink->resource[1]->flags |= IO_DATA_PATH_WIDTH_16;\r\n}\r\nif (link->resource[0]->start == 0) {\r\nfor (j = 0; j < 0x400; j += 0x20) {\r\nlink->resource[0]->start = j ^ 0x300;\r\nlink->resource[1]->start = (j ^ 0x300) + 0x10;\r\nlink->io_lines = 16;\r\nret = pcmcia_request_io(link);\r\nif (ret == 0)\r\nreturn ret;\r\n}\r\nreturn ret;\r\n} else {\r\nreturn pcmcia_request_io(link);\r\n}\r\n}\r\nstatic int axnet_configcheck(struct pcmcia_device *p_dev, void *priv_data)\r\n{\r\nif (p_dev->config_index == 0)\r\nreturn -EINVAL;\r\np_dev->config_index = 0x05;\r\nif (p_dev->resource[0]->end + p_dev->resource[1]->end < 32)\r\nreturn -ENODEV;\r\nreturn try_io_port(p_dev);\r\n}\r\nstatic int axnet_config(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nstruct axnet_dev *info = PRIV(dev);\r\nint i, j, j2, ret;\r\ndev_dbg(&link->dev, "axnet_config(0x%p)\n", link);\r\nlink->config_regs = 0x63;\r\nlink->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO;\r\nret = pcmcia_loop_config(link, axnet_configcheck, NULL);\r\nif (ret != 0)\r\ngoto failed;\r\nif (!link->irq)\r\ngoto failed;\r\nif (resource_size(link->resource[1]) == 8)\r\nlink->config_flags |= CONF_ENABLE_SPKR;\r\nret = pcmcia_enable_device(link);\r\nif (ret)\r\ngoto failed;\r\ndev->irq = link->irq;\r\ndev->base_addr = link->resource[0]->start;\r\nif (!get_prom(link)) {\r\npr_notice("this is not an AX88190 card!\n");\r\npr_notice("use pcnet_cs instead.\n");\r\ngoto failed;\r\n}\r\nei_status.name = "AX88190";\r\nei_status.word16 = 1;\r\nei_status.tx_start_page = AXNET_START_PG;\r\nei_status.rx_start_page = AXNET_START_PG + TX_PAGES;\r\nei_status.stop_page = AXNET_STOP_PG;\r\nei_status.reset_8390 = axnet_reset_8390;\r\nei_status.get_8390_hdr = get_8390_hdr;\r\nei_status.block_input = block_input;\r\nei_status.block_output = block_output;\r\nif (inb(dev->base_addr + AXNET_TEST) != 0)\r\ninfo->flags |= IS_AX88790;\r\nelse\r\ninfo->flags |= IS_AX88190;\r\nif (info->flags & IS_AX88790)\r\noutb(0x10, dev->base_addr + AXNET_GPIO);\r\ninfo->active_low = 0;\r\nfor (i = 0; i < 32; i++) {\r\nj = mdio_read(dev->base_addr + AXNET_MII_EEP, i, 1);\r\nj2 = mdio_read(dev->base_addr + AXNET_MII_EEP, i, 2);\r\nif (j == j2) continue;\r\nif ((j != 0) && (j != 0xffff)) break;\r\n}\r\nif (i == 32) {\r\npcmcia_write_config_byte(link, CISREG_CCSR, 0x04);\r\nfor (i = 0; i < 32; i++) {\r\nj = mdio_read(dev->base_addr + AXNET_MII_EEP, i, 1);\r\nj2 = mdio_read(dev->base_addr + AXNET_MII_EEP, i, 2);\r\nif (j == j2) continue;\r\nif ((j != 0) && (j != 0xffff)) {\r\ninfo->active_low = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\ninfo->phy_id = (i < 32) ? i : -1;\r\nSET_NETDEV_DEV(dev, &link->dev);\r\nif (register_netdev(dev) != 0) {\r\npr_notice("register_netdev() failed\n");\r\ngoto failed;\r\n}\r\nnetdev_info(dev, "Asix AX88%d90: io %#3lx, irq %d, hw_addr %pM\n",\r\n((info->flags & IS_AX88790) ? 7 : 1),\r\ndev->base_addr, dev->irq, dev->dev_addr);\r\nif (info->phy_id != -1) {\r\nnetdev_dbg(dev, " MII transceiver at index %d, status %x\n",\r\ninfo->phy_id, j);\r\n} else {\r\nnetdev_notice(dev, " No MII transceivers found!\n");\r\n}\r\nreturn 0;\r\nfailed:\r\naxnet_release(link);\r\nreturn -ENODEV;\r\n}\r\nstatic void axnet_release(struct pcmcia_device *link)\r\n{\r\npcmcia_disable_device(link);\r\n}\r\nstatic int axnet_suspend(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nif (link->open)\r\nnetif_device_detach(dev);\r\nreturn 0;\r\n}\r\nstatic int axnet_resume(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nstruct axnet_dev *info = PRIV(dev);\r\nif (link->open) {\r\nif (info->active_low == 1)\r\npcmcia_write_config_byte(link, CISREG_CCSR, 0x04);\r\naxnet_reset_8390(dev);\r\nAX88190_init(dev, 1);\r\nnetif_device_attach(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void mdio_sync(unsigned int addr)\r\n{\r\nint bits;\r\nfor (bits = 0; bits < 32; bits++) {\r\noutb_p(MDIO_DATA_WRITE1, addr);\r\noutb_p(MDIO_DATA_WRITE1 | MDIO_SHIFT_CLK, addr);\r\n}\r\n}\r\nstatic int mdio_read(unsigned int addr, int phy_id, int loc)\r\n{\r\nu_int cmd = (0xf6<<10)|(phy_id<<5)|loc;\r\nint i, retval = 0;\r\nmdio_sync(addr);\r\nfor (i = 14; i >= 0; i--) {\r\nint dat = (cmd&(1<<i)) ? MDIO_DATA_WRITE1 : MDIO_DATA_WRITE0;\r\noutb_p(dat, addr);\r\noutb_p(dat | MDIO_SHIFT_CLK, addr);\r\n}\r\nfor (i = 19; i > 0; i--) {\r\noutb_p(MDIO_ENB_IN, addr);\r\nretval = (retval << 1) | ((inb_p(addr) & MDIO_DATA_READ) != 0);\r\noutb_p(MDIO_ENB_IN | MDIO_SHIFT_CLK, addr);\r\n}\r\nreturn (retval>>1) & 0xffff;\r\n}\r\nstatic void mdio_write(unsigned int addr, int phy_id, int loc, int value)\r\n{\r\nu_int cmd = (0x05<<28)|(phy_id<<23)|(loc<<18)|(1<<17)|value;\r\nint i;\r\nmdio_sync(addr);\r\nfor (i = 31; i >= 0; i--) {\r\nint dat = (cmd&(1<<i)) ? MDIO_DATA_WRITE1 : MDIO_DATA_WRITE0;\r\noutb_p(dat, addr);\r\noutb_p(dat | MDIO_SHIFT_CLK, addr);\r\n}\r\nfor (i = 1; i >= 0; i--) {\r\noutb_p(MDIO_ENB_IN, addr);\r\noutb_p(MDIO_ENB_IN | MDIO_SHIFT_CLK, addr);\r\n}\r\n}\r\nstatic int axnet_open(struct net_device *dev)\r\n{\r\nint ret;\r\nstruct axnet_dev *info = PRIV(dev);\r\nstruct pcmcia_device *link = info->p_dev;\r\nunsigned int nic_base = dev->base_addr;\r\ndev_dbg(&link->dev, "axnet_open('%s')\n", dev->name);\r\nif (!pcmcia_dev_present(link))\r\nreturn -ENODEV;\r\noutb_p(0xFF, nic_base + EN0_ISR);\r\nret = request_irq(dev->irq, ei_irq_wrapper, IRQF_SHARED, "axnet_cs", dev);\r\nif (ret)\r\nreturn ret;\r\nlink->open++;\r\ninfo->link_status = 0x00;\r\nsetup_timer(&info->watchdog, ei_watchdog, (u_long)dev);\r\nmod_timer(&info->watchdog, jiffies + HZ);\r\nreturn ax_open(dev);\r\n}\r\nstatic int axnet_close(struct net_device *dev)\r\n{\r\nstruct axnet_dev *info = PRIV(dev);\r\nstruct pcmcia_device *link = info->p_dev;\r\ndev_dbg(&link->dev, "axnet_close('%s')\n", dev->name);\r\nax_close(dev);\r\nfree_irq(dev->irq, dev);\r\nlink->open--;\r\nnetif_stop_queue(dev);\r\ndel_timer_sync(&info->watchdog);\r\nreturn 0;\r\n}\r\nstatic void axnet_reset_8390(struct net_device *dev)\r\n{\r\nunsigned int nic_base = dev->base_addr;\r\nint i;\r\nei_status.txing = ei_status.dmaing = 0;\r\noutb_p(E8390_NODMA+E8390_PAGE0+E8390_STOP, nic_base + E8390_CMD);\r\noutb(inb(nic_base + AXNET_RESET), nic_base + AXNET_RESET);\r\nfor (i = 0; i < 100; i++) {\r\nif ((inb_p(nic_base+EN0_ISR) & ENISR_RESET) != 0)\r\nbreak;\r\nudelay(100);\r\n}\r\noutb_p(ENISR_RESET, nic_base + EN0_ISR);\r\nif (i == 100)\r\nnetdev_err(dev, "axnet_reset_8390() did not complete\n");\r\n}\r\nstatic irqreturn_t ei_irq_wrapper(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nPRIV(dev)->stale = 0;\r\nreturn ax_interrupt(irq, dev_id);\r\n}\r\nstatic void ei_watchdog(u_long arg)\r\n{\r\nstruct net_device *dev = (struct net_device *)(arg);\r\nstruct axnet_dev *info = PRIV(dev);\r\nunsigned int nic_base = dev->base_addr;\r\nunsigned int mii_addr = nic_base + AXNET_MII_EEP;\r\nu_short link;\r\nif (!netif_device_present(dev)) goto reschedule;\r\nif (info->stale++ && (inb_p(nic_base + EN0_ISR) & ENISR_ALL)) {\r\nif (!info->fast_poll)\r\nnetdev_info(dev, "interrupt(s) dropped!\n");\r\nei_irq_wrapper(dev->irq, dev);\r\ninfo->fast_poll = HZ;\r\n}\r\nif (info->fast_poll) {\r\ninfo->fast_poll--;\r\ninfo->watchdog.expires = jiffies + 1;\r\nadd_timer(&info->watchdog);\r\nreturn;\r\n}\r\nif (info->phy_id < 0)\r\ngoto reschedule;\r\nlink = mdio_read(mii_addr, info->phy_id, 1);\r\nif (!link || (link == 0xffff)) {\r\nnetdev_info(dev, "MII is missing!\n");\r\ninfo->phy_id = -1;\r\ngoto reschedule;\r\n}\r\nlink &= 0x0004;\r\nif (link != info->link_status) {\r\nu_short p = mdio_read(mii_addr, info->phy_id, 5);\r\nnetdev_info(dev, "%s link beat\n", link ? "found" : "lost");\r\nif (link) {\r\ninfo->duplex_flag = (p & 0x0140) ? 0x80 : 0x00;\r\nif (p)\r\nnetdev_info(dev, "autonegotiation complete: %dbaseT-%cD selected\n",\r\n(p & 0x0180) ? 100 : 10, (p & 0x0140) ? 'F' : 'H');\r\nelse\r\nnetdev_info(dev, "link partner did not autonegotiate\n");\r\nAX88190_init(dev, 1);\r\n}\r\ninfo->link_status = link;\r\n}\r\nreschedule:\r\ninfo->watchdog.expires = jiffies + HZ;\r\nadd_timer(&info->watchdog);\r\n}\r\nstatic int axnet_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct axnet_dev *info = PRIV(dev);\r\nstruct mii_ioctl_data *data = if_mii(rq);\r\nunsigned int mii_addr = dev->base_addr + AXNET_MII_EEP;\r\nswitch (cmd) {\r\ncase SIOCGMIIPHY:\r\ndata->phy_id = info->phy_id;\r\ncase SIOCGMIIREG:\r\ndata->val_out = mdio_read(mii_addr, data->phy_id, data->reg_num & 0x1f);\r\nreturn 0;\r\ncase SIOCSMIIREG:\r\nmdio_write(mii_addr, data->phy_id, data->reg_num & 0x1f, data->val_in);\r\nreturn 0;\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic void get_8390_hdr(struct net_device *dev,\r\nstruct e8390_pkt_hdr *hdr,\r\nint ring_page)\r\n{\r\nunsigned int nic_base = dev->base_addr;\r\noutb_p(0, nic_base + EN0_RSARLO);\r\noutb_p(ring_page, nic_base + EN0_RSARHI);\r\noutb_p(E8390_RREAD+E8390_START, nic_base + AXNET_CMD);\r\ninsw(nic_base + AXNET_DATAPORT, hdr,\r\nsizeof(struct e8390_pkt_hdr)>>1);\r\nhdr->count = le16_to_cpu(hdr->count);\r\n}\r\nstatic void block_input(struct net_device *dev, int count,\r\nstruct sk_buff *skb, int ring_offset)\r\n{\r\nunsigned int nic_base = dev->base_addr;\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nint xfer_count = count;\r\nchar *buf = skb->data;\r\nif ((netif_msg_rx_status(ei_local)) && (count != 4))\r\nnetdev_dbg(dev, "[bi=%d]\n", count+4);\r\noutb_p(ring_offset & 0xff, nic_base + EN0_RSARLO);\r\noutb_p(ring_offset >> 8, nic_base + EN0_RSARHI);\r\noutb_p(E8390_RREAD+E8390_START, nic_base + AXNET_CMD);\r\ninsw(nic_base + AXNET_DATAPORT,buf,count>>1);\r\nif (count & 0x01)\r\nbuf[count-1] = inb(nic_base + AXNET_DATAPORT), xfer_count++;\r\n}\r\nstatic void block_output(struct net_device *dev, int count,\r\nconst u_char *buf, const int start_page)\r\n{\r\nunsigned int nic_base = dev->base_addr;\r\npr_debug("%s: [bo=%d]\n", dev->name, count);\r\nif (count & 0x01)\r\ncount++;\r\noutb_p(0x00, nic_base + EN0_RSARLO);\r\noutb_p(start_page, nic_base + EN0_RSARHI);\r\noutb_p(E8390_RWRITE+E8390_START, nic_base + AXNET_CMD);\r\noutsw(nic_base + AXNET_DATAPORT, buf, count>>1);\r\n}\r\nstatic int ax_open(struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nspin_lock_irqsave(&ei_local->page_lock, flags);\r\nAX88190_init(dev, 1);\r\nnetif_start_queue(dev);\r\nspin_unlock_irqrestore(&ei_local->page_lock, flags);\r\nei_local->irqlock = 0;\r\nreturn 0;\r\n}\r\nstatic int ax_close(struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev_lock(dev), flags);\r\nAX88190_init(dev, 0);\r\nspin_unlock_irqrestore(&dev_lock(dev), flags);\r\nnetif_stop_queue(dev);\r\nreturn 0;\r\n}\r\nstatic void axnet_tx_timeout(struct net_device *dev)\r\n{\r\nlong e8390_base = dev->base_addr;\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nint txsr, isr, tickssofar = jiffies - dev_trans_start(dev);\r\nunsigned long flags;\r\ndev->stats.tx_errors++;\r\nspin_lock_irqsave(&ei_local->page_lock, flags);\r\ntxsr = inb(e8390_base+EN0_TSR);\r\nisr = inb(e8390_base+EN0_ISR);\r\nspin_unlock_irqrestore(&ei_local->page_lock, flags);\r\nnetdev_dbg(dev, "Tx timed out, %s TSR=%#2x, ISR=%#2x, t=%d.\n",\r\n(txsr & ENTSR_ABT) ? "excess collisions." :\r\n(isr) ? "lost interrupt?" : "cable problem?",\r\ntxsr, isr, tickssofar);\r\nif (!isr && !dev->stats.tx_packets)\r\n{\r\nei_local->interface_num ^= 1;\r\n}\r\nspin_lock_irqsave(&ei_local->page_lock, flags);\r\nei_reset_8390(dev);\r\nAX88190_init(dev, 1);\r\nspin_unlock_irqrestore(&ei_local->page_lock, flags);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic netdev_tx_t axnet_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nlong e8390_base = dev->base_addr;\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nint length, send_length, output_page;\r\nunsigned long flags;\r\nu8 packet[ETH_ZLEN];\r\nnetif_stop_queue(dev);\r\nlength = skb->len;\r\nspin_lock_irqsave(&ei_local->page_lock, flags);\r\noutb_p(0x00, e8390_base + EN0_IMR);\r\nei_local->irqlock = 1;\r\nsend_length = max(length, ETH_ZLEN);\r\nif (ei_local->tx1 == 0)\r\n{\r\noutput_page = ei_local->tx_start_page;\r\nei_local->tx1 = send_length;\r\nif ((netif_msg_tx_queued(ei_local)) &&\r\nei_local->tx2 > 0)\r\nnetdev_dbg(dev,\r\n"idle transmitter tx2=%d, lasttx=%d, txing=%d\n",\r\nei_local->tx2, ei_local->lasttx,\r\nei_local->txing);\r\n}\r\nelse if (ei_local->tx2 == 0)\r\n{\r\noutput_page = ei_local->tx_start_page + TX_PAGES/2;\r\nei_local->tx2 = send_length;\r\nif ((netif_msg_tx_queued(ei_local)) &&\r\nei_local->tx1 > 0)\r\nnetdev_dbg(dev,\r\n"idle transmitter, tx1=%d, lasttx=%d, txing=%d\n",\r\nei_local->tx1, ei_local->lasttx,\r\nei_local->txing);\r\n}\r\nelse\r\n{\r\nnetif_dbg(ei_local, tx_err, dev,\r\n"No Tx buffers free! tx1=%d tx2=%d last=%d\n",\r\nei_local->tx1, ei_local->tx2,\r\nei_local->lasttx);\r\nei_local->irqlock = 0;\r\nnetif_stop_queue(dev);\r\noutb_p(ENISR_ALL, e8390_base + EN0_IMR);\r\nspin_unlock_irqrestore(&ei_local->page_lock, flags);\r\ndev->stats.tx_errors++;\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nif (length == skb->len)\r\nei_block_output(dev, length, skb->data, output_page);\r\nelse {\r\nmemset(packet, 0, ETH_ZLEN);\r\nskb_copy_from_linear_data(skb, packet, skb->len);\r\nei_block_output(dev, length, packet, output_page);\r\n}\r\nif (! ei_local->txing)\r\n{\r\nei_local->txing = 1;\r\nNS8390_trigger_send(dev, send_length, output_page);\r\nnetif_trans_update(dev);\r\nif (output_page == ei_local->tx_start_page)\r\n{\r\nei_local->tx1 = -1;\r\nei_local->lasttx = -1;\r\n}\r\nelse\r\n{\r\nei_local->tx2 = -1;\r\nei_local->lasttx = -2;\r\n}\r\n}\r\nelse ei_local->txqueue++;\r\nif (ei_local->tx1 && ei_local->tx2)\r\nnetif_stop_queue(dev);\r\nelse\r\nnetif_start_queue(dev);\r\nei_local->irqlock = 0;\r\noutb_p(ENISR_ALL, e8390_base + EN0_IMR);\r\nspin_unlock_irqrestore(&ei_local->page_lock, flags);\r\ndev_kfree_skb (skb);\r\ndev->stats.tx_bytes += send_length;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t ax_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nlong e8390_base;\r\nint interrupts, nr_serviced = 0, i;\r\nstruct ei_device *ei_local;\r\nint handled = 0;\r\nunsigned long flags;\r\ne8390_base = dev->base_addr;\r\nei_local = netdev_priv(dev);\r\nspin_lock_irqsave(&ei_local->page_lock, flags);\r\nif (ei_local->irqlock) {\r\n#if 1\r\nconst char *msg;\r\nif (ei_local->irqlock)\r\nmsg = "Interrupted while interrupts are masked!";\r\nelse\r\nmsg = "Reentering the interrupt handler!";\r\nnetdev_info(dev, "%s, isr=%#2x imr=%#2x\n",\r\nmsg,\r\ninb_p(e8390_base + EN0_ISR),\r\ninb_p(e8390_base + EN0_IMR));\r\n#endif\r\nspin_unlock_irqrestore(&ei_local->page_lock, flags);\r\nreturn IRQ_NONE;\r\n}\r\nnetif_dbg(ei_local, intr, dev, "interrupt(isr=%#2.2x)\n",\r\ninb_p(e8390_base + EN0_ISR));\r\noutb_p(0x00, e8390_base + EN0_ISR);\r\nei_local->irqlock = 1;\r\nwhile ((interrupts = inb_p(e8390_base + EN0_ISR)) != 0 &&\r\n++nr_serviced < MAX_SERVICE)\r\n{\r\nif (!netif_running(dev) || (interrupts == 0xff)) {\r\nnetif_warn(ei_local, intr, dev,\r\n"interrupt from stopped card\n");\r\noutb_p(interrupts, e8390_base + EN0_ISR);\r\ninterrupts = 0;\r\nbreak;\r\n}\r\nhandled = 1;\r\noutb_p(interrupts, e8390_base + EN0_ISR);\r\nfor (i = 0; i < 10; i++) {\r\nif (!(inb(e8390_base + EN0_ISR) & interrupts))\r\nbreak;\r\noutb_p(0, e8390_base + EN0_ISR);\r\noutb_p(interrupts, e8390_base + EN0_ISR);\r\n}\r\nif (interrupts & ENISR_OVER)\r\nei_rx_overrun(dev);\r\nelse if (interrupts & (ENISR_RX+ENISR_RX_ERR))\r\n{\r\nei_receive(dev);\r\n}\r\nif (interrupts & ENISR_TX)\r\nei_tx_intr(dev);\r\nelse if (interrupts & ENISR_TX_ERR)\r\nei_tx_err(dev);\r\nif (interrupts & ENISR_COUNTERS)\r\n{\r\ndev->stats.rx_frame_errors += inb_p(e8390_base + EN0_COUNTER0);\r\ndev->stats.rx_crc_errors += inb_p(e8390_base + EN0_COUNTER1);\r\ndev->stats.rx_missed_errors+= inb_p(e8390_base + EN0_COUNTER2);\r\n}\r\n}\r\nif (interrupts && (netif_msg_intr(ei_local)))\r\n{\r\nhandled = 1;\r\nif (nr_serviced >= MAX_SERVICE)\r\n{\r\nif (interrupts != 0xFF)\r\nnetdev_warn(dev,\r\n"Too much work at interrupt, status %#2.2x\n",\r\ninterrupts);\r\noutb_p(ENISR_ALL, e8390_base + EN0_ISR);\r\n} else {\r\nnetdev_warn(dev, "unknown interrupt %#2x\n",\r\ninterrupts);\r\noutb_p(0xff, e8390_base + EN0_ISR);\r\n}\r\n}\r\nei_local->irqlock = 0;\r\noutb_p(ENISR_ALL, e8390_base + EN0_IMR);\r\nspin_unlock_irqrestore(&ei_local->page_lock, flags);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void ei_tx_err(struct net_device *dev)\r\n{\r\nlong e8390_base = dev->base_addr;\r\nunsigned char txsr = inb_p(e8390_base+EN0_TSR);\r\nunsigned char tx_was_aborted = txsr & (ENTSR_ABT+ENTSR_FU);\r\n#ifdef VERBOSE_ERROR_DUMP\r\nnetdev_dbg(dev, "transmitter error (%#2x):", txsr);\r\nif (txsr & ENTSR_ABT)\r\npr_cont(" excess-collisions");\r\nif (txsr & ENTSR_ND)\r\npr_cont(" non-deferral");\r\nif (txsr & ENTSR_CRS)\r\npr_cont(" lost-carrier");\r\nif (txsr & ENTSR_FU)\r\npr_cont(" FIFO-underrun");\r\nif (txsr & ENTSR_CDH)\r\npr_cont(" lost-heartbeat");\r\npr_cont("\n");\r\n#endif\r\nif (tx_was_aborted)\r\nei_tx_intr(dev);\r\nelse\r\n{\r\ndev->stats.tx_errors++;\r\nif (txsr & ENTSR_CRS) dev->stats.tx_carrier_errors++;\r\nif (txsr & ENTSR_CDH) dev->stats.tx_heartbeat_errors++;\r\nif (txsr & ENTSR_OWC) dev->stats.tx_window_errors++;\r\n}\r\n}\r\nstatic void ei_tx_intr(struct net_device *dev)\r\n{\r\nlong e8390_base = dev->base_addr;\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nint status = inb(e8390_base + EN0_TSR);\r\nei_local->txqueue--;\r\nif (ei_local->tx1 < 0)\r\n{\r\nif (ei_local->lasttx != 1 && ei_local->lasttx != -1)\r\nnetdev_err(dev, "%s: bogus last_tx_buffer %d, tx1=%d\n",\r\nei_local->name, ei_local->lasttx,\r\nei_local->tx1);\r\nei_local->tx1 = 0;\r\nif (ei_local->tx2 > 0)\r\n{\r\nei_local->txing = 1;\r\nNS8390_trigger_send(dev, ei_local->tx2, ei_local->tx_start_page + 6);\r\nnetif_trans_update(dev);\r\nei_local->tx2 = -1,\r\nei_local->lasttx = 2;\r\n}\r\nelse ei_local->lasttx = 20, ei_local->txing = 0;\r\n}\r\nelse if (ei_local->tx2 < 0)\r\n{\r\nif (ei_local->lasttx != 2 && ei_local->lasttx != -2)\r\nnetdev_err(dev, "%s: bogus last_tx_buffer %d, tx2=%d\n",\r\nei_local->name, ei_local->lasttx,\r\nei_local->tx2);\r\nei_local->tx2 = 0;\r\nif (ei_local->tx1 > 0)\r\n{\r\nei_local->txing = 1;\r\nNS8390_trigger_send(dev, ei_local->tx1, ei_local->tx_start_page);\r\nnetif_trans_update(dev);\r\nei_local->tx1 = -1;\r\nei_local->lasttx = 1;\r\n}\r\nelse\r\nei_local->lasttx = 10, ei_local->txing = 0;\r\n}\r\nif (status & ENTSR_COL)\r\ndev->stats.collisions++;\r\nif (status & ENTSR_PTX)\r\ndev->stats.tx_packets++;\r\nelse\r\n{\r\ndev->stats.tx_errors++;\r\nif (status & ENTSR_ABT)\r\n{\r\ndev->stats.tx_aborted_errors++;\r\ndev->stats.collisions += 16;\r\n}\r\nif (status & ENTSR_CRS)\r\ndev->stats.tx_carrier_errors++;\r\nif (status & ENTSR_FU)\r\ndev->stats.tx_fifo_errors++;\r\nif (status & ENTSR_CDH)\r\ndev->stats.tx_heartbeat_errors++;\r\nif (status & ENTSR_OWC)\r\ndev->stats.tx_window_errors++;\r\n}\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void ei_receive(struct net_device *dev)\r\n{\r\nlong e8390_base = dev->base_addr;\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nunsigned char rxing_page, this_frame, next_frame;\r\nunsigned short current_offset;\r\nint rx_pkt_count = 0;\r\nstruct e8390_pkt_hdr rx_frame;\r\nwhile (++rx_pkt_count < 10)\r\n{\r\nint pkt_len, pkt_stat;\r\nrxing_page = inb_p(e8390_base + EN1_CURPAG -1);\r\nthis_frame = inb_p(e8390_base + EN0_BOUNDARY) + 1;\r\nif (this_frame >= ei_local->stop_page)\r\nthis_frame = ei_local->rx_start_page;\r\nif ((netif_msg_rx_err(ei_local)) &&\r\nthis_frame != ei_local->current_page &&\r\n(this_frame != 0x0 || rxing_page != 0xFF))\r\nnetdev_err(dev, "mismatched read page pointers %2x vs %2x\n",\r\nthis_frame, ei_local->current_page);\r\nif (this_frame == rxing_page)\r\nbreak;\r\ncurrent_offset = this_frame << 8;\r\nei_get_8390_hdr(dev, &rx_frame, this_frame);\r\npkt_len = rx_frame.count - sizeof(struct e8390_pkt_hdr);\r\npkt_stat = rx_frame.status;\r\nnext_frame = this_frame + 1 + ((pkt_len+4)>>8);\r\nif (pkt_len < 60 || pkt_len > 1518)\r\n{\r\nnetif_err(ei_local, rx_err, dev,\r\n"bogus packet size: %d, status=%#2x nxpg=%#2x\n",\r\nrx_frame.count, rx_frame.status,\r\nrx_frame.next);\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_length_errors++;\r\n}\r\nelse if ((pkt_stat & 0x0F) == ENRSR_RXOK)\r\n{\r\nstruct sk_buff *skb;\r\nskb = netdev_alloc_skb(dev, pkt_len + 2);\r\nif (skb == NULL)\r\n{\r\nnetif_err(ei_local, rx_err, dev,\r\n"Couldn't allocate a sk_buff of size %d\n",\r\npkt_len);\r\ndev->stats.rx_dropped++;\r\nbreak;\r\n}\r\nelse\r\n{\r\nskb_reserve(skb,2);\r\nskb_put(skb, pkt_len);\r\nei_block_input(dev, pkt_len, skb, current_offset + sizeof(rx_frame));\r\nskb->protocol=eth_type_trans(skb,dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += pkt_len;\r\nif (pkt_stat & ENRSR_PHY)\r\ndev->stats.multicast++;\r\n}\r\n}\r\nelse\r\n{\r\nnetif_err(ei_local, rx_err, dev,\r\n"bogus packet: status=%#2x nxpg=%#2x size=%d\n",\r\nrx_frame.status, rx_frame.next,\r\nrx_frame.count);\r\ndev->stats.rx_errors++;\r\nif (pkt_stat & ENRSR_FO)\r\ndev->stats.rx_fifo_errors++;\r\n}\r\nnext_frame = rx_frame.next;\r\nif (next_frame >= ei_local->stop_page) {\r\nnetdev_info(dev, "next frame inconsistency, %#2x\n",\r\nnext_frame);\r\nnext_frame = ei_local->rx_start_page;\r\n}\r\nei_local->current_page = next_frame;\r\noutb_p(next_frame-1, e8390_base+EN0_BOUNDARY);\r\n}\r\n}\r\nstatic void ei_rx_overrun(struct net_device *dev)\r\n{\r\nstruct axnet_dev *info = PRIV(dev);\r\nlong e8390_base = dev->base_addr;\r\nunsigned char was_txing, must_resend = 0;\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nwas_txing = inb_p(e8390_base+E8390_CMD) & E8390_TRANS;\r\noutb_p(E8390_NODMA+E8390_PAGE0+E8390_STOP, e8390_base+E8390_CMD);\r\nnetif_dbg(ei_local, rx_err, dev, "Receiver overrun\n");\r\ndev->stats.rx_over_errors++;\r\nmdelay(2);\r\noutb_p(0x00, e8390_base+EN0_RCNTLO);\r\noutb_p(0x00, e8390_base+EN0_RCNTHI);\r\nif (was_txing)\r\n{\r\nunsigned char tx_completed = inb_p(e8390_base+EN0_ISR) & (ENISR_TX+ENISR_TX_ERR);\r\nif (!tx_completed)\r\nmust_resend = 1;\r\n}\r\noutb_p(E8390_TXOFF, e8390_base + EN0_TXCR);\r\noutb_p(E8390_NODMA + E8390_PAGE0 + E8390_START, e8390_base + E8390_CMD);\r\nei_receive(dev);\r\noutb_p(E8390_TXCONFIG | info->duplex_flag, e8390_base + EN0_TXCR);\r\nif (must_resend)\r\noutb_p(E8390_NODMA + E8390_PAGE0 + E8390_START + E8390_TRANS, e8390_base + E8390_CMD);\r\n}\r\nstatic struct net_device_stats *get_stats(struct net_device *dev)\r\n{\r\nlong ioaddr = dev->base_addr;\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nunsigned long flags;\r\nif (!netif_running(dev))\r\nreturn &dev->stats;\r\nspin_lock_irqsave(&ei_local->page_lock,flags);\r\ndev->stats.rx_frame_errors += inb_p(ioaddr + EN0_COUNTER0);\r\ndev->stats.rx_crc_errors += inb_p(ioaddr + EN0_COUNTER1);\r\ndev->stats.rx_missed_errors+= inb_p(ioaddr + EN0_COUNTER2);\r\nspin_unlock_irqrestore(&ei_local->page_lock, flags);\r\nreturn &dev->stats;\r\n}\r\nstatic inline void make_mc_bits(u8 *bits, struct net_device *dev)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nu32 crc;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\ncrc = ether_crc(ETH_ALEN, ha->addr);\r\nbits[crc>>29] |= (1<<((crc>>26)&7));\r\n}\r\n}\r\nstatic void do_set_multicast_list(struct net_device *dev)\r\n{\r\nlong e8390_base = dev->base_addr;\r\nint i;\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nif (!(dev->flags&(IFF_PROMISC|IFF_ALLMULTI))) {\r\nmemset(ei_local->mcfilter, 0, 8);\r\nif (!netdev_mc_empty(dev))\r\nmake_mc_bits(ei_local->mcfilter, dev);\r\n} else {\r\nmemset(ei_local->mcfilter, 0xFF, 8);\r\n}\r\noutb_p(E8390_NODMA + E8390_PAGE1, e8390_base + E8390_CMD);\r\nfor(i = 0; i < 8; i++)\r\n{\r\noutb_p(ei_local->mcfilter[i], e8390_base + EN1_MULT_SHIFT(i));\r\n}\r\noutb_p(E8390_NODMA + E8390_PAGE0, e8390_base + E8390_CMD);\r\nif(dev->flags&IFF_PROMISC)\r\noutb_p(E8390_RXCONFIG | 0x58, e8390_base + EN0_RXCR);\r\nelse if (dev->flags & IFF_ALLMULTI || !netdev_mc_empty(dev))\r\noutb_p(E8390_RXCONFIG | 0x48, e8390_base + EN0_RXCR);\r\nelse\r\noutb_p(E8390_RXCONFIG | 0x40, e8390_base + EN0_RXCR);\r\noutb_p(E8390_NODMA+E8390_PAGE0+E8390_START, e8390_base+E8390_CMD);\r\n}\r\nstatic void set_multicast_list(struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev_lock(dev), flags);\r\ndo_set_multicast_list(dev);\r\nspin_unlock_irqrestore(&dev_lock(dev), flags);\r\n}\r\nstatic void AX88190_init(struct net_device *dev, int startp)\r\n{\r\nstruct axnet_dev *info = PRIV(dev);\r\nlong e8390_base = dev->base_addr;\r\nstruct ei_device *ei_local = netdev_priv(dev);\r\nint i;\r\nint endcfg = ei_local->word16 ? (0x48 | ENDCFG_WTS) : 0x48;\r\nif(sizeof(struct e8390_pkt_hdr)!=4)\r\npanic("8390.c: header struct mispacked\n");\r\noutb_p(E8390_NODMA+E8390_PAGE0+E8390_STOP, e8390_base+E8390_CMD);\r\noutb_p(endcfg, e8390_base + EN0_DCFG);\r\noutb_p(0x00, e8390_base + EN0_RCNTLO);\r\noutb_p(0x00, e8390_base + EN0_RCNTHI);\r\noutb_p(E8390_RXOFF|0x40, e8390_base + EN0_RXCR);\r\noutb_p(E8390_TXOFF, e8390_base + EN0_TXCR);\r\noutb_p(ei_local->tx_start_page, e8390_base + EN0_TPSR);\r\nei_local->tx1 = ei_local->tx2 = 0;\r\noutb_p(ei_local->rx_start_page, e8390_base + EN0_STARTPG);\r\noutb_p(ei_local->stop_page-1, e8390_base + EN0_BOUNDARY);\r\nei_local->current_page = ei_local->rx_start_page;\r\noutb_p(ei_local->stop_page, e8390_base + EN0_STOPPG);\r\noutb_p(0xFF, e8390_base + EN0_ISR);\r\noutb_p(0x00, e8390_base + EN0_IMR);\r\noutb_p(E8390_NODMA + E8390_PAGE1 + E8390_STOP, e8390_base+E8390_CMD);\r\nfor(i = 0; i < 6; i++)\r\n{\r\noutb_p(dev->dev_addr[i], e8390_base + EN1_PHYS_SHIFT(i));\r\nif(inb_p(e8390_base + EN1_PHYS_SHIFT(i))!=dev->dev_addr[i])\r\nnetdev_err(dev, "Hw. address read/write mismap %d\n", i);\r\n}\r\noutb_p(ei_local->rx_start_page, e8390_base + EN1_CURPAG);\r\noutb_p(E8390_NODMA+E8390_PAGE0+E8390_STOP, e8390_base+E8390_CMD);\r\nnetif_start_queue(dev);\r\nei_local->tx1 = ei_local->tx2 = 0;\r\nei_local->txing = 0;\r\nif (info->flags & IS_AX88790)\r\noutb(0x10, e8390_base + AXNET_GPIO);\r\nif (startp)\r\n{\r\noutb_p(0xff, e8390_base + EN0_ISR);\r\noutb_p(ENISR_ALL, e8390_base + EN0_IMR);\r\noutb_p(E8390_NODMA+E8390_PAGE0+E8390_START, e8390_base+E8390_CMD);\r\noutb_p(E8390_TXCONFIG | info->duplex_flag,\r\ne8390_base + EN0_TXCR);\r\noutb_p(E8390_RXCONFIG | 0x40, e8390_base + EN0_RXCR);\r\ndo_set_multicast_list(dev);\r\n}\r\n}\r\nstatic void NS8390_trigger_send(struct net_device *dev, unsigned int length,\r\nint start_page)\r\n{\r\nlong e8390_base = dev->base_addr;\r\nstruct ei_device *ei_local __attribute((unused)) = netdev_priv(dev);\r\nif (inb_p(e8390_base) & E8390_TRANS)\r\n{\r\nnetdev_warn(dev, "trigger_send() called with the transmitter busy\n");\r\nreturn;\r\n}\r\noutb_p(length & 0xff, e8390_base + EN0_TCNTLO);\r\noutb_p(length >> 8, e8390_base + EN0_TCNTHI);\r\noutb_p(start_page, e8390_base + EN0_TPSR);\r\noutb_p(E8390_NODMA+E8390_TRANS+E8390_START, e8390_base+E8390_CMD);\r\n}
