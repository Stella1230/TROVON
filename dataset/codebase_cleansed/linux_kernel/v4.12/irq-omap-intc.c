static void intc_writel(u32 reg, u32 val)\r\n{\r\nwritel_relaxed(val, omap_irq_base + reg);\r\n}\r\nstatic u32 intc_readl(u32 reg)\r\n{\r\nreturn readl_relaxed(omap_irq_base + reg);\r\n}\r\nvoid omap_intc_save_context(void)\r\n{\r\nint i;\r\nintc_context.sysconfig =\r\nintc_readl(INTC_SYSCONFIG);\r\nintc_context.protection =\r\nintc_readl(INTC_PROTECTION);\r\nintc_context.idle =\r\nintc_readl(INTC_IDLE);\r\nintc_context.threshold =\r\nintc_readl(INTC_THRESHOLD);\r\nfor (i = 0; i < omap_nr_irqs; i++)\r\nintc_context.ilr[i] =\r\nintc_readl((INTC_ILR0 + 0x4 * i));\r\nfor (i = 0; i < INTCPS_NR_MIR_REGS; i++)\r\nintc_context.mir[i] =\r\nintc_readl(INTC_MIR0 + (0x20 * i));\r\n}\r\nvoid omap_intc_restore_context(void)\r\n{\r\nint i;\r\nintc_writel(INTC_SYSCONFIG, intc_context.sysconfig);\r\nintc_writel(INTC_PROTECTION, intc_context.protection);\r\nintc_writel(INTC_IDLE, intc_context.idle);\r\nintc_writel(INTC_THRESHOLD, intc_context.threshold);\r\nfor (i = 0; i < omap_nr_irqs; i++)\r\nintc_writel(INTC_ILR0 + 0x4 * i,\r\nintc_context.ilr[i]);\r\nfor (i = 0; i < INTCPS_NR_MIR_REGS; i++)\r\nintc_writel(INTC_MIR0 + 0x20 * i,\r\nintc_context.mir[i]);\r\n}\r\nvoid omap3_intc_prepare_idle(void)\r\n{\r\nintc_writel(INTC_SYSCONFIG, 0);\r\nintc_writel(INTC_IDLE, INTC_IDLE_TURBO);\r\n}\r\nvoid omap3_intc_resume_idle(void)\r\n{\r\nintc_writel(INTC_SYSCONFIG, 1);\r\nintc_writel(INTC_IDLE, 0);\r\n}\r\nstatic void omap_ack_irq(struct irq_data *d)\r\n{\r\nintc_writel(INTC_CONTROL, 0x1);\r\n}\r\nstatic void omap_mask_ack_irq(struct irq_data *d)\r\n{\r\nirq_gc_mask_disable_reg(d);\r\nomap_ack_irq(d);\r\n}\r\nstatic void __init omap_irq_soft_reset(void)\r\n{\r\nunsigned long tmp;\r\ntmp = intc_readl(INTC_REVISION) & 0xff;\r\npr_info("IRQ: Found an INTC at 0x%p (revision %ld.%ld) with %d interrupts\n",\r\nomap_irq_base, tmp >> 4, tmp & 0xf, omap_nr_irqs);\r\ntmp = intc_readl(INTC_SYSCONFIG);\r\ntmp |= 1 << 1;\r\nintc_writel(INTC_SYSCONFIG, tmp);\r\nwhile (!(intc_readl(INTC_SYSSTATUS) & 0x1))\r\n;\r\nintc_writel(INTC_SYSCONFIG, 1 << 0);\r\n}\r\nint omap_irq_pending(void)\r\n{\r\nint i;\r\nfor (i = 0; i < omap_nr_pending; i++)\r\nif (intc_readl(INTC_PENDING_IRQ0 + (0x20 * i)))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nvoid omap3_intc_suspend(void)\r\n{\r\nomap_ack_irq(NULL);\r\n}\r\nstatic int __init omap_alloc_gc_of(struct irq_domain *d, void __iomem *base)\r\n{\r\nint ret;\r\nint i;\r\nret = irq_alloc_domain_generic_chips(d, 32, 1, "INTC",\r\nhandle_level_irq, IRQ_NOREQUEST | IRQ_NOPROBE,\r\nIRQ_LEVEL, 0);\r\nif (ret) {\r\npr_warn("Failed to allocate irq chips\n");\r\nreturn ret;\r\n}\r\nfor (i = 0; i < omap_nr_pending; i++) {\r\nstruct irq_chip_generic *gc;\r\nstruct irq_chip_type *ct;\r\ngc = irq_get_domain_generic_chip(d, 32 * i);\r\ngc->reg_base = base;\r\nct = gc->chip_types;\r\nct->type = IRQ_TYPE_LEVEL_MASK;\r\nct->chip.irq_ack = omap_mask_ack_irq;\r\nct->chip.irq_mask = irq_gc_mask_disable_reg;\r\nct->chip.irq_unmask = irq_gc_unmask_enable_reg;\r\nct->chip.flags |= IRQCHIP_SKIP_SET_WAKE;\r\nct->regs.enable = INTC_MIR_CLEAR0 + 32 * i;\r\nct->regs.disable = INTC_MIR_SET0 + 32 * i;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __init omap_alloc_gc_legacy(void __iomem *base,\r\nunsigned int irq_start, unsigned int num)\r\n{\r\nstruct irq_chip_generic *gc;\r\nstruct irq_chip_type *ct;\r\ngc = irq_alloc_generic_chip("INTC", 1, irq_start, base,\r\nhandle_level_irq);\r\nct = gc->chip_types;\r\nct->chip.irq_ack = omap_mask_ack_irq;\r\nct->chip.irq_mask = irq_gc_mask_disable_reg;\r\nct->chip.irq_unmask = irq_gc_unmask_enable_reg;\r\nct->chip.flags |= IRQCHIP_SKIP_SET_WAKE;\r\nct->regs.enable = INTC_MIR_CLEAR0;\r\nct->regs.disable = INTC_MIR_SET0;\r\nirq_setup_generic_chip(gc, IRQ_MSK(num), IRQ_GC_INIT_MASK_CACHE,\r\nIRQ_NOREQUEST | IRQ_NOPROBE, 0);\r\n}\r\nstatic int __init omap_init_irq_of(struct device_node *node)\r\n{\r\nint ret;\r\nomap_irq_base = of_iomap(node, 0);\r\nif (WARN_ON(!omap_irq_base))\r\nreturn -ENOMEM;\r\ndomain = irq_domain_add_linear(node, omap_nr_irqs,\r\n&irq_generic_chip_ops, NULL);\r\nomap_irq_soft_reset();\r\nret = omap_alloc_gc_of(domain, omap_irq_base);\r\nif (ret < 0)\r\nirq_domain_remove(domain);\r\nreturn ret;\r\n}\r\nstatic int __init omap_init_irq_legacy(u32 base, struct device_node *node)\r\n{\r\nint j, irq_base;\r\nomap_irq_base = ioremap(base, SZ_4K);\r\nif (WARN_ON(!omap_irq_base))\r\nreturn -ENOMEM;\r\nirq_base = irq_alloc_descs(-1, 0, omap_nr_irqs, 0);\r\nif (irq_base < 0) {\r\npr_warn("Couldn't allocate IRQ numbers\n");\r\nirq_base = 0;\r\n}\r\ndomain = irq_domain_add_legacy(node, omap_nr_irqs, irq_base, 0,\r\n&irq_domain_simple_ops, NULL);\r\nomap_irq_soft_reset();\r\nfor (j = 0; j < omap_nr_irqs; j += 32)\r\nomap_alloc_gc_legacy(omap_irq_base + j, j + irq_base, 32);\r\nreturn 0;\r\n}\r\nstatic void __init omap_irq_enable_protection(void)\r\n{\r\nu32 reg;\r\nreg = intc_readl(INTC_PROTECTION);\r\nreg |= INTC_PROTECTION_ENABLE;\r\nintc_writel(INTC_PROTECTION, reg);\r\n}\r\nstatic int __init omap_init_irq(u32 base, struct device_node *node)\r\n{\r\nint ret;\r\nif (of_device_is_compatible(node, "ti,omap2-intc") ||\r\nof_device_is_compatible(node, "ti,omap3-intc")) {\r\nstruct resource res;\r\nif (of_address_to_resource(node, 0, &res))\r\nreturn -ENOMEM;\r\nbase = res.start;\r\nret = omap_init_irq_legacy(base, node);\r\n} else if (node) {\r\nret = omap_init_irq_of(node);\r\n} else {\r\nret = omap_init_irq_legacy(base, NULL);\r\n}\r\nif (ret == 0)\r\nomap_irq_enable_protection();\r\nreturn ret;\r\n}\r\nstatic asmlinkage void __exception_irq_entry\r\nomap_intc_handle_irq(struct pt_regs *regs)\r\n{\r\nextern unsigned long irq_err_count;\r\nu32 irqnr;\r\nirqnr = intc_readl(INTC_SIR);\r\nif (unlikely((irqnr & SPURIOUSIRQ_MASK) == SPURIOUSIRQ_MASK)) {\r\npr_err_once("%s: spurious irq!\n", __func__);\r\nirq_err_count++;\r\nomap_ack_irq(NULL);\r\nreturn;\r\n}\r\nirqnr &= ACTIVEIRQ_MASK;\r\nhandle_domain_irq(domain, irqnr, regs);\r\n}\r\nvoid __init omap3_init_irq(void)\r\n{\r\nomap_nr_irqs = 96;\r\nomap_nr_pending = 3;\r\nomap_init_irq(OMAP34XX_IC_BASE, NULL);\r\nset_handle_irq(omap_intc_handle_irq);\r\n}\r\nstatic int __init intc_of_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nint ret;\r\nomap_nr_pending = 3;\r\nomap_nr_irqs = 96;\r\nif (WARN_ON(!node))\r\nreturn -ENODEV;\r\nif (of_device_is_compatible(node, "ti,dm814-intc") ||\r\nof_device_is_compatible(node, "ti,dm816-intc") ||\r\nof_device_is_compatible(node, "ti,am33xx-intc")) {\r\nomap_nr_irqs = 128;\r\nomap_nr_pending = 4;\r\n}\r\nret = omap_init_irq(-1, of_node_get(node));\r\nif (ret < 0)\r\nreturn ret;\r\nset_handle_irq(omap_intc_handle_irq);\r\nreturn 0;\r\n}
