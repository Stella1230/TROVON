static irqreturn_t vdoa_irq_handler(int irq, void *data)\r\n{\r\nstruct vdoa_data *vdoa = data;\r\nstruct vdoa_ctx *curr_ctx;\r\nu32 val;\r\nwritel(0, vdoa->regs + VDOAIE);\r\ncurr_ctx = vdoa->curr_ctx;\r\nif (!curr_ctx) {\r\ndev_dbg(vdoa->dev,\r\n"Instance released before the end of transaction\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nval = readl(vdoa->regs + VDOAIST);\r\nwritel(val, vdoa->regs + VDOAIST);\r\nif (val & VDOAIST_TERR) {\r\nval = readl(vdoa->regs + VDOASR) & VDOASR_ERRW;\r\ndev_err(vdoa->dev, "AXI %s error\n", val ? "write" : "read");\r\n} else if (!(val & VDOAIST_EOT)) {\r\ndev_warn(vdoa->dev, "Spurious interrupt\n");\r\n}\r\ncomplete(&curr_ctx->completion);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid vdoa_device_run(struct vdoa_ctx *ctx, dma_addr_t dst, dma_addr_t src)\r\n{\r\nstruct vdoa_q_data *src_q_data, *dst_q_data;\r\nstruct vdoa_data *vdoa = ctx->vdoa;\r\nu32 val;\r\nvdoa->curr_ctx = ctx;\r\nsrc_q_data = &ctx->q_data[V4L2_M2M_SRC];\r\ndst_q_data = &ctx->q_data[V4L2_M2M_DST];\r\nif (dst_q_data->pixelformat == V4L2_PIX_FMT_YUYV)\r\nval = VDOAC_PFS;\r\nelse\r\nval = 0;\r\nwritel(val, vdoa->regs + VDOAC);\r\nwritel(dst_q_data->height << 16 | dst_q_data->width,\r\nvdoa->regs + VDOAFP);\r\nval = dst;\r\nwritel(val, vdoa->regs + VDOAIEBA00);\r\nwritel(src_q_data->bytesperline << 16 | dst_q_data->bytesperline,\r\nvdoa->regs + VDOASL);\r\nif (dst_q_data->pixelformat == V4L2_PIX_FMT_NV12 ||\r\ndst_q_data->pixelformat == V4L2_PIX_FMT_NV21)\r\nval = dst_q_data->bytesperline * dst_q_data->height;\r\nelse\r\nval = 0;\r\nwritel(val, vdoa->regs + VDOAIUBO);\r\nval = src;\r\nwritel(val, vdoa->regs + VDOAVEBA0);\r\nval = round_up(src_q_data->bytesperline * src_q_data->height, 4096);\r\nwritel(val, vdoa->regs + VDOAVUBO);\r\nwritel(VDOAIE_EITERR | VDOAIE_EIEOT, vdoa->regs + VDOAIE);\r\nwritel(VDOASRR_START, vdoa->regs + VDOASRR);\r\n}\r\nint vdoa_wait_for_completion(struct vdoa_ctx *ctx)\r\n{\r\nstruct vdoa_data *vdoa = ctx->vdoa;\r\nif (!wait_for_completion_timeout(&ctx->completion,\r\nmsecs_to_jiffies(300))) {\r\ndev_err(vdoa->dev,\r\n"Timeout waiting for transfer result\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstruct vdoa_ctx *vdoa_context_create(struct vdoa_data *vdoa)\r\n{\r\nstruct vdoa_ctx *ctx;\r\nint err;\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn NULL;\r\nerr = clk_prepare_enable(vdoa->vdoa_clk);\r\nif (err) {\r\nkfree(ctx);\r\nreturn NULL;\r\n}\r\ninit_completion(&ctx->completion);\r\nctx->vdoa = vdoa;\r\nreturn ctx;\r\n}\r\nvoid vdoa_context_destroy(struct vdoa_ctx *ctx)\r\n{\r\nstruct vdoa_data *vdoa = ctx->vdoa;\r\nclk_disable_unprepare(vdoa->vdoa_clk);\r\nkfree(ctx);\r\n}\r\nint vdoa_context_configure(struct vdoa_ctx *ctx,\r\nunsigned int width, unsigned int height,\r\nu32 pixelformat)\r\n{\r\nstruct vdoa_q_data *src_q_data;\r\nstruct vdoa_q_data *dst_q_data;\r\nif (width < 16 || width > 8192 || width % 16 != 0 ||\r\nheight < 16 || height > 4096 || height % 16 != 0)\r\nreturn -EINVAL;\r\nif (pixelformat != V4L2_PIX_FMT_YUYV &&\r\npixelformat != V4L2_PIX_FMT_NV12)\r\nreturn -EINVAL;\r\nif (!ctx)\r\nreturn 0;\r\nsrc_q_data = &ctx->q_data[V4L2_M2M_SRC];\r\ndst_q_data = &ctx->q_data[V4L2_M2M_DST];\r\nsrc_q_data->width = width;\r\nsrc_q_data->height = height;\r\nsrc_q_data->bytesperline = width;\r\nsrc_q_data->sizeimage =\r\nround_up(src_q_data->bytesperline * height, 4096) +\r\nsrc_q_data->bytesperline * height / 2;\r\ndst_q_data->width = width;\r\ndst_q_data->height = height;\r\ndst_q_data->pixelformat = pixelformat;\r\nswitch (pixelformat) {\r\ncase V4L2_PIX_FMT_YUYV:\r\ndst_q_data->bytesperline = width * 2;\r\ndst_q_data->sizeimage = dst_q_data->bytesperline * height;\r\nbreak;\r\ncase V4L2_PIX_FMT_NV12:\r\ndefault:\r\ndst_q_data->bytesperline = width;\r\ndst_q_data->sizeimage =\r\ndst_q_data->bytesperline * height * 3 / 2;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vdoa_probe(struct platform_device *pdev)\r\n{\r\nstruct vdoa_data *vdoa;\r\nstruct resource *res;\r\ndma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));\r\nvdoa = devm_kzalloc(&pdev->dev, sizeof(*vdoa), GFP_KERNEL);\r\nif (!vdoa)\r\nreturn -ENOMEM;\r\nvdoa->dev = &pdev->dev;\r\nvdoa->vdoa_clk = devm_clk_get(vdoa->dev, NULL);\r\nif (IS_ERR(vdoa->vdoa_clk)) {\r\ndev_err(vdoa->dev, "Failed to get clock\n");\r\nreturn PTR_ERR(vdoa->vdoa_clk);\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nvdoa->regs = devm_ioremap_resource(vdoa->dev, res);\r\nif (IS_ERR(vdoa->regs))\r\nreturn PTR_ERR(vdoa->regs);\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nvdoa->irq = devm_request_threaded_irq(&pdev->dev, res->start, NULL,\r\nvdoa_irq_handler, IRQF_ONESHOT,\r\n"vdoa", vdoa);\r\nif (vdoa->irq < 0) {\r\ndev_err(vdoa->dev, "Failed to get irq\n");\r\nreturn vdoa->irq;\r\n}\r\nplatform_set_drvdata(pdev, vdoa);\r\nreturn 0;\r\n}\r\nstatic int vdoa_remove(struct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}
