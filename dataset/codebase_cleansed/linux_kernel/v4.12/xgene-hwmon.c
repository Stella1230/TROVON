static u16 xgene_word_tst_and_clr(u16 *addr, u16 mask)\r\n{\r\nu16 ret, val;\r\nval = le16_to_cpu(READ_ONCE(*addr));\r\nret = val & mask;\r\nval &= ~mask;\r\nWRITE_ONCE(*addr, cpu_to_le16(val));\r\nreturn ret;\r\n}\r\nstatic int xgene_hwmon_pcc_rd(struct xgene_hwmon_dev *ctx, u32 *msg)\r\n{\r\nstruct acpi_pcct_shared_memory *generic_comm_base = ctx->pcc_comm_addr;\r\nu32 *ptr = (void *)(generic_comm_base + 1);\r\nint rc, i;\r\nu16 val;\r\nmutex_lock(&ctx->rd_mutex);\r\ninit_completion(&ctx->rd_complete);\r\nctx->resp_pending = true;\r\nWRITE_ONCE(generic_comm_base->signature,\r\ncpu_to_le32(PCC_SIGNATURE_MASK | ctx->mbox_idx));\r\nWRITE_ONCE(generic_comm_base->command,\r\ncpu_to_le16(MSG_TYPE(msg[0]) | PCCC_GENERATE_DB_INT));\r\nval = le16_to_cpu(READ_ONCE(generic_comm_base->status));\r\nval &= ~PCCS_CMD_COMPLETE;\r\nWRITE_ONCE(generic_comm_base->status, cpu_to_le16(val));\r\nfor (i = 0; i < sizeof(struct slimpro_resp_msg) / 4; i++)\r\nWRITE_ONCE(ptr[i], cpu_to_le32(msg[i]));\r\nrc = mbox_send_message(ctx->mbox_chan, msg);\r\nif (rc < 0) {\r\ndev_err(ctx->dev, "Mailbox send error %d\n", rc);\r\ngoto err;\r\n}\r\nif (!wait_for_completion_timeout(&ctx->rd_complete,\r\nusecs_to_jiffies(ctx->usecs_lat))) {\r\ndev_err(ctx->dev, "Mailbox operation timed out\n");\r\nrc = -ETIMEDOUT;\r\ngoto err;\r\n}\r\nif (MSG_TYPE(ctx->sync_msg.msg) == MSG_TYPE_ERR) {\r\nrc = -EINVAL;\r\ngoto err;\r\n}\r\nmsg[0] = ctx->sync_msg.msg;\r\nmsg[1] = ctx->sync_msg.param1;\r\nmsg[2] = ctx->sync_msg.param2;\r\nerr:\r\nmbox_chan_txdone(ctx->mbox_chan, 0);\r\nctx->resp_pending = false;\r\nmutex_unlock(&ctx->rd_mutex);\r\nreturn rc;\r\n}\r\nstatic int xgene_hwmon_rd(struct xgene_hwmon_dev *ctx, u32 *msg)\r\n{\r\nint rc;\r\nmutex_lock(&ctx->rd_mutex);\r\ninit_completion(&ctx->rd_complete);\r\nctx->resp_pending = true;\r\nrc = mbox_send_message(ctx->mbox_chan, msg);\r\nif (rc < 0) {\r\ndev_err(ctx->dev, "Mailbox send error %d\n", rc);\r\ngoto err;\r\n}\r\nif (!wait_for_completion_timeout(&ctx->rd_complete,\r\nmsecs_to_jiffies(MBOX_OP_TIMEOUTMS))) {\r\ndev_err(ctx->dev, "Mailbox operation timed out\n");\r\nrc = -ETIMEDOUT;\r\ngoto err;\r\n}\r\nif (MSG_TYPE(ctx->sync_msg.msg) == MSG_TYPE_ERR) {\r\nrc = -EINVAL;\r\ngoto err;\r\n}\r\nmsg[0] = ctx->sync_msg.msg;\r\nmsg[1] = ctx->sync_msg.param1;\r\nmsg[2] = ctx->sync_msg.param2;\r\nerr:\r\nctx->resp_pending = false;\r\nmutex_unlock(&ctx->rd_mutex);\r\nreturn rc;\r\n}\r\nstatic int xgene_hwmon_reg_map_rd(struct xgene_hwmon_dev *ctx, u32 addr,\r\nu32 *data)\r\n{\r\nu32 msg[3];\r\nint rc;\r\nmsg[0] = SENSOR_RD_MSG;\r\nmsg[1] = SENSOR_RD_EN_ADDR(addr);\r\nmsg[2] = 0;\r\nif (acpi_disabled)\r\nrc = xgene_hwmon_rd(ctx, msg);\r\nelse\r\nrc = xgene_hwmon_pcc_rd(ctx, msg);\r\nif (rc < 0)\r\nreturn rc;\r\nif (msg[1] & SENSOR_INVALID_DATA)\r\nreturn -ENODATA;\r\n*data = msg[1];\r\nreturn rc;\r\n}\r\nstatic int xgene_hwmon_get_notification_msg(struct xgene_hwmon_dev *ctx,\r\nu32 *amsg)\r\n{\r\nu32 msg[3];\r\nint rc;\r\nmsg[0] = TPC_EN_MSG(PWRMGMT_SUBTYPE_TPC, TPC_GET_ALARM, 0);\r\nmsg[1] = 0;\r\nmsg[2] = 0;\r\nrc = xgene_hwmon_pcc_rd(ctx, msg);\r\nif (rc < 0)\r\nreturn rc;\r\namsg[0] = msg[0];\r\namsg[1] = msg[1];\r\namsg[2] = msg[2];\r\nreturn rc;\r\n}\r\nstatic int xgene_hwmon_get_cpu_pwr(struct xgene_hwmon_dev *ctx, u32 *val)\r\n{\r\nu32 watt, mwatt;\r\nint rc;\r\nrc = xgene_hwmon_reg_map_rd(ctx, PMD_PWR_REG, &watt);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = xgene_hwmon_reg_map_rd(ctx, PMD_PWR_MW_REG, &mwatt);\r\nif (rc < 0)\r\nreturn rc;\r\n*val = WATT_TO_mWATT(watt) + mwatt;\r\nreturn 0;\r\n}\r\nstatic int xgene_hwmon_get_io_pwr(struct xgene_hwmon_dev *ctx, u32 *val)\r\n{\r\nu32 watt, mwatt;\r\nint rc;\r\nrc = xgene_hwmon_reg_map_rd(ctx, SOC_PWR_REG, &watt);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = xgene_hwmon_reg_map_rd(ctx, SOC_PWR_MW_REG, &mwatt);\r\nif (rc < 0)\r\nreturn rc;\r\n*val = WATT_TO_mWATT(watt) + mwatt;\r\nreturn 0;\r\n}\r\nstatic int xgene_hwmon_get_temp(struct xgene_hwmon_dev *ctx, u32 *val)\r\n{\r\nreturn xgene_hwmon_reg_map_rd(ctx, SOC_TEMP_REG, val);\r\n}\r\nstatic ssize_t temp1_input_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct xgene_hwmon_dev *ctx = dev_get_drvdata(dev);\r\nint rc, temp;\r\nu32 val;\r\nrc = xgene_hwmon_get_temp(ctx, &val);\r\nif (rc < 0)\r\nreturn rc;\r\ntemp = sign_extend32(val, TEMP_NEGATIVE_BIT);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", CELSIUS_TO_mCELSIUS(temp));\r\n}\r\nstatic ssize_t temp1_label_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "SoC Temperature\n");\r\n}\r\nstatic ssize_t temp1_critical_alarm_show(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct xgene_hwmon_dev *ctx = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", ctx->temp_critical_alarm);\r\n}\r\nstatic ssize_t power1_label_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "CPU power\n");\r\n}\r\nstatic ssize_t power2_label_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "IO power\n");\r\n}\r\nstatic ssize_t power1_input_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct xgene_hwmon_dev *ctx = dev_get_drvdata(dev);\r\nu32 val;\r\nint rc;\r\nrc = xgene_hwmon_get_cpu_pwr(ctx, &val);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", mWATT_TO_uWATT(val));\r\n}\r\nstatic ssize_t power2_input_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct xgene_hwmon_dev *ctx = dev_get_drvdata(dev);\r\nu32 val;\r\nint rc;\r\nrc = xgene_hwmon_get_io_pwr(ctx, &val);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", mWATT_TO_uWATT(val));\r\n}\r\nstatic int xgene_hwmon_tpc_alarm(struct xgene_hwmon_dev *ctx,\r\nstruct slimpro_resp_msg *amsg)\r\n{\r\nctx->temp_critical_alarm = !!amsg->param2;\r\nsysfs_notify(&ctx->dev->kobj, NULL, "temp1_critical_alarm");\r\nreturn 0;\r\n}\r\nstatic void xgene_hwmon_process_pwrmsg(struct xgene_hwmon_dev *ctx,\r\nstruct slimpro_resp_msg *amsg)\r\n{\r\nif ((MSG_SUBTYPE(amsg->msg) == PWRMGMT_SUBTYPE_TPC) &&\r\n(TPC_CMD(amsg->msg) == TPC_ALARM))\r\nxgene_hwmon_tpc_alarm(ctx, amsg);\r\n}\r\nstatic void xgene_hwmon_evt_work(struct work_struct *work)\r\n{\r\nstruct slimpro_resp_msg amsg;\r\nstruct xgene_hwmon_dev *ctx;\r\nint ret;\r\nctx = container_of(work, struct xgene_hwmon_dev, workq);\r\nwhile (kfifo_out_spinlocked(&ctx->async_msg_fifo, &amsg,\r\nsizeof(struct slimpro_resp_msg),\r\n&ctx->kfifo_lock)) {\r\nif (!acpi_disabled) {\r\nret = xgene_hwmon_get_notification_msg(ctx,\r\n(u32 *)&amsg);\r\nif (ret < 0)\r\ncontinue;\r\n}\r\nif (MSG_TYPE(amsg.msg) == MSG_TYPE_PWRMGMT)\r\nxgene_hwmon_process_pwrmsg(ctx, &amsg);\r\n}\r\n}\r\nstatic int xgene_hwmon_rx_ready(struct xgene_hwmon_dev *ctx, void *msg)\r\n{\r\nif (IS_ERR_OR_NULL(ctx->hwmon_dev) && !ctx->resp_pending) {\r\nkfifo_in_spinlocked(&ctx->async_msg_fifo, msg,\r\nsizeof(struct slimpro_resp_msg),\r\n&ctx->kfifo_lock);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void xgene_hwmon_rx_cb(struct mbox_client *cl, void *msg)\r\n{\r\nstruct xgene_hwmon_dev *ctx = to_xgene_hwmon_dev(cl);\r\nif (xgene_hwmon_rx_ready(ctx, msg) < 0)\r\nreturn;\r\nif (ctx->resp_pending &&\r\n((MSG_TYPE(((u32 *)msg)[0]) == MSG_TYPE_ERR) ||\r\n(MSG_TYPE(((u32 *)msg)[0]) == MSG_TYPE_DBG &&\r\nMSG_SUBTYPE(((u32 *)msg)[0]) == DBG_SUBTYPE_SENSOR_READ) ||\r\n(MSG_TYPE(((u32 *)msg)[0]) == MSG_TYPE_PWRMGMT &&\r\nMSG_SUBTYPE(((u32 *)msg)[0]) == PWRMGMT_SUBTYPE_TPC &&\r\nTPC_CMD(((u32 *)msg)[0]) == TPC_ALARM))) {\r\nctx->sync_msg.msg = ((u32 *)msg)[0];\r\nctx->sync_msg.param1 = ((u32 *)msg)[1];\r\nctx->sync_msg.param2 = ((u32 *)msg)[2];\r\ncomplete(&ctx->rd_complete);\r\nreturn;\r\n}\r\nkfifo_in_spinlocked(&ctx->async_msg_fifo, msg,\r\nsizeof(struct slimpro_resp_msg), &ctx->kfifo_lock);\r\nschedule_work(&ctx->workq);\r\n}\r\nstatic void xgene_hwmon_pcc_rx_cb(struct mbox_client *cl, void *msg)\r\n{\r\nstruct xgene_hwmon_dev *ctx = to_xgene_hwmon_dev(cl);\r\nstruct acpi_pcct_shared_memory *generic_comm_base = ctx->pcc_comm_addr;\r\nstruct slimpro_resp_msg amsg;\r\nif (xgene_hwmon_rx_ready(ctx, &amsg) < 0)\r\nreturn;\r\nmsg = generic_comm_base + 1;\r\nif (!xgene_word_tst_and_clr(&generic_comm_base->status,\r\nPCCS_SCI_DOORBEL))\r\nreturn;\r\nif (ctx->resp_pending &&\r\n((MSG_TYPE(((u32 *)msg)[0]) == MSG_TYPE_ERR) ||\r\n(MSG_TYPE(((u32 *)msg)[0]) == MSG_TYPE_DBG &&\r\nMSG_SUBTYPE(((u32 *)msg)[0]) == DBG_SUBTYPE_SENSOR_READ) ||\r\n(MSG_TYPE(((u32 *)msg)[0]) == MSG_TYPE_PWRMGMT &&\r\nMSG_SUBTYPE(((u32 *)msg)[0]) == PWRMGMT_SUBTYPE_TPC &&\r\nTPC_CMD(((u32 *)msg)[0]) == TPC_ALARM))) {\r\nif (xgene_word_tst_and_clr(&generic_comm_base->status,\r\nPCCS_CMD_COMPLETE)) {\r\nctx->sync_msg.msg = ((u32 *)msg)[0];\r\nctx->sync_msg.param1 = ((u32 *)msg)[1];\r\nctx->sync_msg.param2 = ((u32 *)msg)[2];\r\ncomplete(&ctx->rd_complete);\r\nreturn;\r\n}\r\n}\r\nkfifo_in_spinlocked(&ctx->async_msg_fifo, &amsg,\r\nsizeof(struct slimpro_resp_msg), &ctx->kfifo_lock);\r\nschedule_work(&ctx->workq);\r\n}\r\nstatic void xgene_hwmon_tx_done(struct mbox_client *cl, void *msg, int ret)\r\n{\r\nif (ret) {\r\ndev_dbg(cl->dev, "TX did not complete: CMD sent:%x, ret:%d\n",\r\n*(u16 *)msg, ret);\r\n} else {\r\ndev_dbg(cl->dev, "TX completed. CMD sent:%x, ret:%d\n",\r\n*(u16 *)msg, ret);\r\n}\r\n}\r\nstatic int xgene_hwmon_probe(struct platform_device *pdev)\r\n{\r\nstruct xgene_hwmon_dev *ctx;\r\nstruct mbox_client *cl;\r\nint rc;\r\nctx = devm_kzalloc(&pdev->dev, sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nctx->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, ctx);\r\ncl = &ctx->mbox_client;\r\nspin_lock_init(&ctx->kfifo_lock);\r\nmutex_init(&ctx->rd_mutex);\r\nrc = kfifo_alloc(&ctx->async_msg_fifo,\r\nsizeof(struct slimpro_resp_msg) * ASYNC_MSG_FIFO_SIZE,\r\nGFP_KERNEL);\r\nif (rc)\r\ngoto out_mbox_free;\r\nINIT_WORK(&ctx->workq, xgene_hwmon_evt_work);\r\ncl->dev = &pdev->dev;\r\ncl->tx_done = xgene_hwmon_tx_done;\r\ncl->tx_block = false;\r\ncl->tx_tout = MBOX_OP_TIMEOUTMS;\r\ncl->knows_txdone = false;\r\nif (acpi_disabled) {\r\ncl->rx_callback = xgene_hwmon_rx_cb;\r\nctx->mbox_chan = mbox_request_channel(cl, 0);\r\nif (IS_ERR(ctx->mbox_chan)) {\r\ndev_err(&pdev->dev,\r\n"SLIMpro mailbox channel request failed\n");\r\nreturn -ENODEV;\r\n}\r\n} else {\r\nstruct acpi_pcct_hw_reduced *cppc_ss;\r\nif (device_property_read_u32(&pdev->dev, "pcc-channel",\r\n&ctx->mbox_idx)) {\r\ndev_err(&pdev->dev, "no pcc-channel property\n");\r\nreturn -ENODEV;\r\n}\r\ncl->rx_callback = xgene_hwmon_pcc_rx_cb;\r\nctx->mbox_chan = pcc_mbox_request_channel(cl, ctx->mbox_idx);\r\nif (IS_ERR(ctx->mbox_chan)) {\r\ndev_err(&pdev->dev,\r\n"PPC channel request failed\n");\r\nreturn -ENODEV;\r\n}\r\ncppc_ss = ctx->mbox_chan->con_priv;\r\nif (!cppc_ss) {\r\ndev_err(&pdev->dev, "PPC subspace not found\n");\r\nrc = -ENODEV;\r\ngoto out_mbox_free;\r\n}\r\nif (!ctx->mbox_chan->mbox->txdone_irq) {\r\ndev_err(&pdev->dev, "PCC IRQ not supported\n");\r\nrc = -ENODEV;\r\ngoto out_mbox_free;\r\n}\r\nctx->comm_base_addr = cppc_ss->base_address;\r\nif (ctx->comm_base_addr) {\r\nctx->pcc_comm_addr = memremap(ctx->comm_base_addr,\r\ncppc_ss->length,\r\nMEMREMAP_WB);\r\n} else {\r\ndev_err(&pdev->dev, "Failed to get PCC comm region\n");\r\nrc = -ENODEV;\r\ngoto out_mbox_free;\r\n}\r\nif (!ctx->pcc_comm_addr) {\r\ndev_err(&pdev->dev,\r\n"Failed to ioremap PCC comm region\n");\r\nrc = -ENOMEM;\r\ngoto out_mbox_free;\r\n}\r\nctx->usecs_lat = PCC_NUM_RETRIES * cppc_ss->latency;\r\n}\r\nctx->hwmon_dev = hwmon_device_register_with_groups(ctx->dev,\r\n"apm_xgene",\r\nctx,\r\nxgene_hwmon_groups);\r\nif (IS_ERR(ctx->hwmon_dev)) {\r\ndev_err(&pdev->dev, "Failed to register HW monitor device\n");\r\nrc = PTR_ERR(ctx->hwmon_dev);\r\ngoto out;\r\n}\r\nschedule_work(&ctx->workq);\r\ndev_info(&pdev->dev, "APM X-Gene SoC HW monitor driver registered\n");\r\nreturn 0;\r\nout:\r\nif (acpi_disabled)\r\nmbox_free_channel(ctx->mbox_chan);\r\nelse\r\npcc_mbox_free_channel(ctx->mbox_chan);\r\nout_mbox_free:\r\nkfifo_free(&ctx->async_msg_fifo);\r\nreturn rc;\r\n}\r\nstatic int xgene_hwmon_remove(struct platform_device *pdev)\r\n{\r\nstruct xgene_hwmon_dev *ctx = platform_get_drvdata(pdev);\r\nhwmon_device_unregister(ctx->hwmon_dev);\r\nkfifo_free(&ctx->async_msg_fifo);\r\nif (acpi_disabled)\r\nmbox_free_channel(ctx->mbox_chan);\r\nelse\r\npcc_mbox_free_channel(ctx->mbox_chan);\r\nreturn 0;\r\n}
