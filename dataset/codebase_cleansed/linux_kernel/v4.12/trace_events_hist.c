static u64 hist_field_none(struct hist_field *field, void *event)\r\n{\r\nreturn 0;\r\n}\r\nstatic u64 hist_field_counter(struct hist_field *field, void *event)\r\n{\r\nreturn 1;\r\n}\r\nstatic u64 hist_field_string(struct hist_field *hist_field, void *event)\r\n{\r\nchar *addr = (char *)(event + hist_field->field->offset);\r\nreturn (u64)(unsigned long)addr;\r\n}\r\nstatic u64 hist_field_dynstring(struct hist_field *hist_field, void *event)\r\n{\r\nu32 str_item = *(u32 *)(event + hist_field->field->offset);\r\nint str_loc = str_item & 0xffff;\r\nchar *addr = (char *)(event + str_loc);\r\nreturn (u64)(unsigned long)addr;\r\n}\r\nstatic u64 hist_field_pstring(struct hist_field *hist_field, void *event)\r\n{\r\nchar **addr = (char **)(event + hist_field->field->offset);\r\nreturn (u64)(unsigned long)*addr;\r\n}\r\nstatic u64 hist_field_log2(struct hist_field *hist_field, void *event)\r\n{\r\nu64 val = *(u64 *)(event + hist_field->field->offset);\r\nreturn (u64) ilog2(roundup_pow_of_two(val));\r\n}\r\nstatic hist_field_fn_t select_value_fn(int field_size, int field_is_signed)\r\n{\r\nhist_field_fn_t fn = NULL;\r\nswitch (field_size) {\r\ncase 8:\r\nif (field_is_signed)\r\nfn = hist_field_s64;\r\nelse\r\nfn = hist_field_u64;\r\nbreak;\r\ncase 4:\r\nif (field_is_signed)\r\nfn = hist_field_s32;\r\nelse\r\nfn = hist_field_u32;\r\nbreak;\r\ncase 2:\r\nif (field_is_signed)\r\nfn = hist_field_s16;\r\nelse\r\nfn = hist_field_u16;\r\nbreak;\r\ncase 1:\r\nif (field_is_signed)\r\nfn = hist_field_s8;\r\nelse\r\nfn = hist_field_u8;\r\nbreak;\r\n}\r\nreturn fn;\r\n}\r\nstatic int parse_map_size(char *str)\r\n{\r\nunsigned long size, map_bits;\r\nint ret;\r\nstrsep(&str, "=");\r\nif (!str) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = kstrtoul(str, 0, &size);\r\nif (ret)\r\ngoto out;\r\nmap_bits = ilog2(roundup_pow_of_two(size));\r\nif (map_bits < TRACING_MAP_BITS_MIN ||\r\nmap_bits > TRACING_MAP_BITS_MAX)\r\nret = -EINVAL;\r\nelse\r\nret = map_bits;\r\nout:\r\nreturn ret;\r\n}\r\nstatic void destroy_hist_trigger_attrs(struct hist_trigger_attrs *attrs)\r\n{\r\nif (!attrs)\r\nreturn;\r\nkfree(attrs->name);\r\nkfree(attrs->sort_key_str);\r\nkfree(attrs->keys_str);\r\nkfree(attrs->vals_str);\r\nkfree(attrs);\r\n}\r\nstatic struct hist_trigger_attrs *parse_hist_trigger_attrs(char *trigger_str)\r\n{\r\nstruct hist_trigger_attrs *attrs;\r\nint ret = 0;\r\nattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\r\nif (!attrs)\r\nreturn ERR_PTR(-ENOMEM);\r\nwhile (trigger_str) {\r\nchar *str = strsep(&trigger_str, ":");\r\nif ((strncmp(str, "key=", strlen("key=")) == 0) ||\r\n(strncmp(str, "keys=", strlen("keys=")) == 0))\r\nattrs->keys_str = kstrdup(str, GFP_KERNEL);\r\nelse if ((strncmp(str, "val=", strlen("val=")) == 0) ||\r\n(strncmp(str, "vals=", strlen("vals=")) == 0) ||\r\n(strncmp(str, "values=", strlen("values=")) == 0))\r\nattrs->vals_str = kstrdup(str, GFP_KERNEL);\r\nelse if (strncmp(str, "sort=", strlen("sort=")) == 0)\r\nattrs->sort_key_str = kstrdup(str, GFP_KERNEL);\r\nelse if (strncmp(str, "name=", strlen("name=")) == 0)\r\nattrs->name = kstrdup(str, GFP_KERNEL);\r\nelse if (strcmp(str, "pause") == 0)\r\nattrs->pause = true;\r\nelse if ((strcmp(str, "cont") == 0) ||\r\n(strcmp(str, "continue") == 0))\r\nattrs->cont = true;\r\nelse if (strcmp(str, "clear") == 0)\r\nattrs->clear = true;\r\nelse if (strncmp(str, "size=", strlen("size=")) == 0) {\r\nint map_bits = parse_map_size(str);\r\nif (map_bits < 0) {\r\nret = map_bits;\r\ngoto free;\r\n}\r\nattrs->map_bits = map_bits;\r\n} else {\r\nret = -EINVAL;\r\ngoto free;\r\n}\r\n}\r\nif (!attrs->keys_str) {\r\nret = -EINVAL;\r\ngoto free;\r\n}\r\nreturn attrs;\r\nfree:\r\ndestroy_hist_trigger_attrs(attrs);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic inline void save_comm(char *comm, struct task_struct *task)\r\n{\r\nif (!task->pid) {\r\nstrcpy(comm, "<idle>");\r\nreturn;\r\n}\r\nif (WARN_ON_ONCE(task->pid < 0)) {\r\nstrcpy(comm, "<XXX>");\r\nreturn;\r\n}\r\nmemcpy(comm, task->comm, TASK_COMM_LEN);\r\n}\r\nstatic void hist_trigger_elt_comm_free(struct tracing_map_elt *elt)\r\n{\r\nkfree((char *)elt->private_data);\r\n}\r\nstatic int hist_trigger_elt_comm_alloc(struct tracing_map_elt *elt)\r\n{\r\nstruct hist_trigger_data *hist_data = elt->map->private_data;\r\nstruct hist_field *key_field;\r\nunsigned int i;\r\nfor_each_hist_key_field(i, hist_data) {\r\nkey_field = hist_data->fields[i];\r\nif (key_field->flags & HIST_FIELD_FL_EXECNAME) {\r\nunsigned int size = TASK_COMM_LEN + 1;\r\nelt->private_data = kzalloc(size, GFP_KERNEL);\r\nif (!elt->private_data)\r\nreturn -ENOMEM;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void hist_trigger_elt_comm_copy(struct tracing_map_elt *to,\r\nstruct tracing_map_elt *from)\r\n{\r\nchar *comm_from = from->private_data;\r\nchar *comm_to = to->private_data;\r\nif (comm_from)\r\nmemcpy(comm_to, comm_from, TASK_COMM_LEN + 1);\r\n}\r\nstatic void hist_trigger_elt_comm_init(struct tracing_map_elt *elt)\r\n{\r\nchar *comm = elt->private_data;\r\nif (comm)\r\nsave_comm(comm, current);\r\n}\r\nstatic void destroy_hist_field(struct hist_field *hist_field)\r\n{\r\nkfree(hist_field);\r\n}\r\nstatic struct hist_field *create_hist_field(struct ftrace_event_field *field,\r\nunsigned long flags)\r\n{\r\nstruct hist_field *hist_field;\r\nif (field && is_function_field(field))\r\nreturn NULL;\r\nhist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\r\nif (!hist_field)\r\nreturn NULL;\r\nif (flags & HIST_FIELD_FL_HITCOUNT) {\r\nhist_field->fn = hist_field_counter;\r\ngoto out;\r\n}\r\nif (flags & HIST_FIELD_FL_STACKTRACE) {\r\nhist_field->fn = hist_field_none;\r\ngoto out;\r\n}\r\nif (flags & HIST_FIELD_FL_LOG2) {\r\nhist_field->fn = hist_field_log2;\r\ngoto out;\r\n}\r\nif (WARN_ON_ONCE(!field))\r\ngoto out;\r\nif (is_string_field(field)) {\r\nflags |= HIST_FIELD_FL_STRING;\r\nif (field->filter_type == FILTER_STATIC_STRING)\r\nhist_field->fn = hist_field_string;\r\nelse if (field->filter_type == FILTER_DYN_STRING)\r\nhist_field->fn = hist_field_dynstring;\r\nelse\r\nhist_field->fn = hist_field_pstring;\r\n} else {\r\nhist_field->fn = select_value_fn(field->size,\r\nfield->is_signed);\r\nif (!hist_field->fn) {\r\ndestroy_hist_field(hist_field);\r\nreturn NULL;\r\n}\r\n}\r\nout:\r\nhist_field->field = field;\r\nhist_field->flags = flags;\r\nreturn hist_field;\r\n}\r\nstatic void destroy_hist_fields(struct hist_trigger_data *hist_data)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < TRACING_MAP_FIELDS_MAX; i++) {\r\nif (hist_data->fields[i]) {\r\ndestroy_hist_field(hist_data->fields[i]);\r\nhist_data->fields[i] = NULL;\r\n}\r\n}\r\n}\r\nstatic int create_hitcount_val(struct hist_trigger_data *hist_data)\r\n{\r\nhist_data->fields[HITCOUNT_IDX] =\r\ncreate_hist_field(NULL, HIST_FIELD_FL_HITCOUNT);\r\nif (!hist_data->fields[HITCOUNT_IDX])\r\nreturn -ENOMEM;\r\nhist_data->n_vals++;\r\nif (WARN_ON(hist_data->n_vals > TRACING_MAP_VALS_MAX))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int create_val_field(struct hist_trigger_data *hist_data,\r\nunsigned int val_idx,\r\nstruct trace_event_file *file,\r\nchar *field_str)\r\n{\r\nstruct ftrace_event_field *field = NULL;\r\nunsigned long flags = 0;\r\nchar *field_name;\r\nint ret = 0;\r\nif (WARN_ON(val_idx >= TRACING_MAP_VALS_MAX))\r\nreturn -EINVAL;\r\nfield_name = strsep(&field_str, ".");\r\nif (field_str) {\r\nif (strcmp(field_str, "hex") == 0)\r\nflags |= HIST_FIELD_FL_HEX;\r\nelse {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nfield = trace_find_event_field(file->event_call, field_name);\r\nif (!field) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nhist_data->fields[val_idx] = create_hist_field(field, flags);\r\nif (!hist_data->fields[val_idx]) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\n++hist_data->n_vals;\r\nif (WARN_ON(hist_data->n_vals > TRACING_MAP_VALS_MAX))\r\nret = -EINVAL;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int create_val_fields(struct hist_trigger_data *hist_data,\r\nstruct trace_event_file *file)\r\n{\r\nchar *fields_str, *field_str;\r\nunsigned int i, j;\r\nint ret;\r\nret = create_hitcount_val(hist_data);\r\nif (ret)\r\ngoto out;\r\nfields_str = hist_data->attrs->vals_str;\r\nif (!fields_str)\r\ngoto out;\r\nstrsep(&fields_str, "=");\r\nif (!fields_str)\r\ngoto out;\r\nfor (i = 0, j = 1; i < TRACING_MAP_VALS_MAX &&\r\nj < TRACING_MAP_VALS_MAX; i++) {\r\nfield_str = strsep(&fields_str, ",");\r\nif (!field_str)\r\nbreak;\r\nif (strcmp(field_str, "hitcount") == 0)\r\ncontinue;\r\nret = create_val_field(hist_data, j++, file, field_str);\r\nif (ret)\r\ngoto out;\r\n}\r\nif (fields_str && (strcmp(fields_str, "hitcount") != 0))\r\nret = -EINVAL;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int create_key_field(struct hist_trigger_data *hist_data,\r\nunsigned int key_idx,\r\nunsigned int key_offset,\r\nstruct trace_event_file *file,\r\nchar *field_str)\r\n{\r\nstruct ftrace_event_field *field = NULL;\r\nunsigned long flags = 0;\r\nunsigned int key_size;\r\nint ret = 0;\r\nif (WARN_ON(key_idx >= TRACING_MAP_FIELDS_MAX))\r\nreturn -EINVAL;\r\nflags |= HIST_FIELD_FL_KEY;\r\nif (strcmp(field_str, "stacktrace") == 0) {\r\nflags |= HIST_FIELD_FL_STACKTRACE;\r\nkey_size = sizeof(unsigned long) * HIST_STACKTRACE_DEPTH;\r\n} else {\r\nchar *field_name = strsep(&field_str, ".");\r\nif (field_str) {\r\nif (strcmp(field_str, "hex") == 0)\r\nflags |= HIST_FIELD_FL_HEX;\r\nelse if (strcmp(field_str, "sym") == 0)\r\nflags |= HIST_FIELD_FL_SYM;\r\nelse if (strcmp(field_str, "sym-offset") == 0)\r\nflags |= HIST_FIELD_FL_SYM_OFFSET;\r\nelse if ((strcmp(field_str, "execname") == 0) &&\r\n(strcmp(field_name, "common_pid") == 0))\r\nflags |= HIST_FIELD_FL_EXECNAME;\r\nelse if (strcmp(field_str, "syscall") == 0)\r\nflags |= HIST_FIELD_FL_SYSCALL;\r\nelse if (strcmp(field_str, "log2") == 0)\r\nflags |= HIST_FIELD_FL_LOG2;\r\nelse {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nfield = trace_find_event_field(file->event_call, field_name);\r\nif (!field) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (is_string_field(field))\r\nkey_size = MAX_FILTER_STR_VAL;\r\nelse\r\nkey_size = field->size;\r\n}\r\nhist_data->fields[key_idx] = create_hist_field(field, flags);\r\nif (!hist_data->fields[key_idx]) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nkey_size = ALIGN(key_size, sizeof(u64));\r\nhist_data->fields[key_idx]->size = key_size;\r\nhist_data->fields[key_idx]->offset = key_offset;\r\nhist_data->key_size += key_size;\r\nif (hist_data->key_size > HIST_KEY_SIZE_MAX) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nhist_data->n_keys++;\r\nif (WARN_ON(hist_data->n_keys > TRACING_MAP_KEYS_MAX))\r\nreturn -EINVAL;\r\nret = key_size;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int create_key_fields(struct hist_trigger_data *hist_data,\r\nstruct trace_event_file *file)\r\n{\r\nunsigned int i, key_offset = 0, n_vals = hist_data->n_vals;\r\nchar *fields_str, *field_str;\r\nint ret = -EINVAL;\r\nfields_str = hist_data->attrs->keys_str;\r\nif (!fields_str)\r\ngoto out;\r\nstrsep(&fields_str, "=");\r\nif (!fields_str)\r\ngoto out;\r\nfor (i = n_vals; i < n_vals + TRACING_MAP_KEYS_MAX; i++) {\r\nfield_str = strsep(&fields_str, ",");\r\nif (!field_str)\r\nbreak;\r\nret = create_key_field(hist_data, i, key_offset,\r\nfile, field_str);\r\nif (ret < 0)\r\ngoto out;\r\nkey_offset += ret;\r\n}\r\nif (fields_str) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int create_hist_fields(struct hist_trigger_data *hist_data,\r\nstruct trace_event_file *file)\r\n{\r\nint ret;\r\nret = create_val_fields(hist_data, file);\r\nif (ret)\r\ngoto out;\r\nret = create_key_fields(hist_data, file);\r\nif (ret)\r\ngoto out;\r\nhist_data->n_fields = hist_data->n_vals + hist_data->n_keys;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int is_descending(const char *str)\r\n{\r\nif (!str)\r\nreturn 0;\r\nif (strcmp(str, "descending") == 0)\r\nreturn 1;\r\nif (strcmp(str, "ascending") == 0)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic int create_sort_keys(struct hist_trigger_data *hist_data)\r\n{\r\nchar *fields_str = hist_data->attrs->sort_key_str;\r\nstruct ftrace_event_field *field = NULL;\r\nstruct tracing_map_sort_key *sort_key;\r\nint descending, ret = 0;\r\nunsigned int i, j;\r\nhist_data->n_sort_keys = 1;\r\nif (!fields_str)\r\ngoto out;\r\nstrsep(&fields_str, "=");\r\nif (!fields_str) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nfor (i = 0; i < TRACING_MAP_SORT_KEYS_MAX; i++) {\r\nchar *field_str, *field_name;\r\nsort_key = &hist_data->sort_keys[i];\r\nfield_str = strsep(&fields_str, ",");\r\nif (!field_str) {\r\nif (i == 0)\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif ((i == TRACING_MAP_SORT_KEYS_MAX - 1) && fields_str) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nfield_name = strsep(&field_str, ".");\r\nif (!field_name) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (strcmp(field_name, "hitcount") == 0) {\r\ndescending = is_descending(field_str);\r\nif (descending < 0) {\r\nret = descending;\r\nbreak;\r\n}\r\nsort_key->descending = descending;\r\ncontinue;\r\n}\r\nfor (j = 1; j < hist_data->n_fields; j++) {\r\nfield = hist_data->fields[j]->field;\r\nif (field && (strcmp(field_name, field->name) == 0)) {\r\nsort_key->field_idx = j;\r\ndescending = is_descending(field_str);\r\nif (descending < 0) {\r\nret = descending;\r\ngoto out;\r\n}\r\nsort_key->descending = descending;\r\nbreak;\r\n}\r\n}\r\nif (j == hist_data->n_fields) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\n}\r\nhist_data->n_sort_keys = i;\r\nout:\r\nreturn ret;\r\n}\r\nstatic void destroy_hist_data(struct hist_trigger_data *hist_data)\r\n{\r\ndestroy_hist_trigger_attrs(hist_data->attrs);\r\ndestroy_hist_fields(hist_data);\r\ntracing_map_destroy(hist_data->map);\r\nkfree(hist_data);\r\n}\r\nstatic int create_tracing_map_fields(struct hist_trigger_data *hist_data)\r\n{\r\nstruct tracing_map *map = hist_data->map;\r\nstruct ftrace_event_field *field;\r\nstruct hist_field *hist_field;\r\nint i, idx;\r\nfor_each_hist_field(i, hist_data) {\r\nhist_field = hist_data->fields[i];\r\nif (hist_field->flags & HIST_FIELD_FL_KEY) {\r\ntracing_map_cmp_fn_t cmp_fn;\r\nfield = hist_field->field;\r\nif (hist_field->flags & HIST_FIELD_FL_STACKTRACE)\r\ncmp_fn = tracing_map_cmp_none;\r\nelse if (is_string_field(field))\r\ncmp_fn = tracing_map_cmp_string;\r\nelse\r\ncmp_fn = tracing_map_cmp_num(field->size,\r\nfield->is_signed);\r\nidx = tracing_map_add_key_field(map,\r\nhist_field->offset,\r\ncmp_fn);\r\n} else\r\nidx = tracing_map_add_sum_field(map);\r\nif (idx < 0)\r\nreturn idx;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool need_tracing_map_ops(struct hist_trigger_data *hist_data)\r\n{\r\nstruct hist_field *key_field;\r\nunsigned int i;\r\nfor_each_hist_key_field(i, hist_data) {\r\nkey_field = hist_data->fields[i];\r\nif (key_field->flags & HIST_FIELD_FL_EXECNAME)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic struct hist_trigger_data *\r\ncreate_hist_data(unsigned int map_bits,\r\nstruct hist_trigger_attrs *attrs,\r\nstruct trace_event_file *file)\r\n{\r\nconst struct tracing_map_ops *map_ops = NULL;\r\nstruct hist_trigger_data *hist_data;\r\nint ret = 0;\r\nhist_data = kzalloc(sizeof(*hist_data), GFP_KERNEL);\r\nif (!hist_data)\r\nreturn ERR_PTR(-ENOMEM);\r\nhist_data->attrs = attrs;\r\nret = create_hist_fields(hist_data, file);\r\nif (ret)\r\ngoto free;\r\nret = create_sort_keys(hist_data);\r\nif (ret)\r\ngoto free;\r\nif (need_tracing_map_ops(hist_data))\r\nmap_ops = &hist_trigger_elt_comm_ops;\r\nhist_data->map = tracing_map_create(map_bits, hist_data->key_size,\r\nmap_ops, hist_data);\r\nif (IS_ERR(hist_data->map)) {\r\nret = PTR_ERR(hist_data->map);\r\nhist_data->map = NULL;\r\ngoto free;\r\n}\r\nret = create_tracing_map_fields(hist_data);\r\nif (ret)\r\ngoto free;\r\nret = tracing_map_init(hist_data->map);\r\nif (ret)\r\ngoto free;\r\nhist_data->event_file = file;\r\nout:\r\nreturn hist_data;\r\nfree:\r\nhist_data->attrs = NULL;\r\ndestroy_hist_data(hist_data);\r\nhist_data = ERR_PTR(ret);\r\ngoto out;\r\n}\r\nstatic void hist_trigger_elt_update(struct hist_trigger_data *hist_data,\r\nstruct tracing_map_elt *elt,\r\nvoid *rec)\r\n{\r\nstruct hist_field *hist_field;\r\nunsigned int i;\r\nu64 hist_val;\r\nfor_each_hist_val_field(i, hist_data) {\r\nhist_field = hist_data->fields[i];\r\nhist_val = hist_field->fn(hist_field, rec);\r\ntracing_map_update_sum(elt, i, hist_val);\r\n}\r\n}\r\nstatic inline void add_to_key(char *compound_key, void *key,\r\nstruct hist_field *key_field, void *rec)\r\n{\r\nsize_t size = key_field->size;\r\nif (key_field->flags & HIST_FIELD_FL_STRING) {\r\nstruct ftrace_event_field *field;\r\nfield = key_field->field;\r\nif (field->filter_type == FILTER_DYN_STRING)\r\nsize = *(u32 *)(rec + field->offset) >> 16;\r\nelse if (field->filter_type == FILTER_PTR_STRING)\r\nsize = strlen(key);\r\nelse if (field->filter_type == FILTER_STATIC_STRING)\r\nsize = field->size;\r\nif (size > key_field->size - 1)\r\nsize = key_field->size - 1;\r\n}\r\nmemcpy(compound_key + key_field->offset, key, size);\r\n}\r\nstatic void event_hist_trigger(struct event_trigger_data *data, void *rec)\r\n{\r\nstruct hist_trigger_data *hist_data = data->private_data;\r\nbool use_compound_key = (hist_data->n_keys > 1);\r\nunsigned long entries[HIST_STACKTRACE_DEPTH];\r\nchar compound_key[HIST_KEY_SIZE_MAX];\r\nstruct stack_trace stacktrace;\r\nstruct hist_field *key_field;\r\nstruct tracing_map_elt *elt;\r\nu64 field_contents;\r\nvoid *key = NULL;\r\nunsigned int i;\r\nmemset(compound_key, 0, hist_data->key_size);\r\nfor_each_hist_key_field(i, hist_data) {\r\nkey_field = hist_data->fields[i];\r\nif (key_field->flags & HIST_FIELD_FL_STACKTRACE) {\r\nstacktrace.max_entries = HIST_STACKTRACE_DEPTH;\r\nstacktrace.entries = entries;\r\nstacktrace.nr_entries = 0;\r\nstacktrace.skip = HIST_STACKTRACE_SKIP;\r\nmemset(stacktrace.entries, 0, HIST_STACKTRACE_SIZE);\r\nsave_stack_trace(&stacktrace);\r\nkey = entries;\r\n} else {\r\nfield_contents = key_field->fn(key_field, rec);\r\nif (key_field->flags & HIST_FIELD_FL_STRING) {\r\nkey = (void *)(unsigned long)field_contents;\r\nuse_compound_key = true;\r\n} else\r\nkey = (void *)&field_contents;\r\n}\r\nif (use_compound_key)\r\nadd_to_key(compound_key, key, key_field, rec);\r\n}\r\nif (use_compound_key)\r\nkey = compound_key;\r\nelt = tracing_map_insert(hist_data->map, key);\r\nif (elt)\r\nhist_trigger_elt_update(hist_data, elt, rec);\r\n}\r\nstatic void hist_trigger_stacktrace_print(struct seq_file *m,\r\nunsigned long *stacktrace_entries,\r\nunsigned int max_entries)\r\n{\r\nchar str[KSYM_SYMBOL_LEN];\r\nunsigned int spaces = 8;\r\nunsigned int i;\r\nfor (i = 0; i < max_entries; i++) {\r\nif (stacktrace_entries[i] == ULONG_MAX)\r\nreturn;\r\nseq_printf(m, "%*c", 1 + spaces, ' ');\r\nsprint_symbol(str, stacktrace_entries[i]);\r\nseq_printf(m, "%s\n", str);\r\n}\r\n}\r\nstatic void\r\nhist_trigger_entry_print(struct seq_file *m,\r\nstruct hist_trigger_data *hist_data, void *key,\r\nstruct tracing_map_elt *elt)\r\n{\r\nstruct hist_field *key_field;\r\nchar str[KSYM_SYMBOL_LEN];\r\nbool multiline = false;\r\nunsigned int i;\r\nu64 uval;\r\nseq_puts(m, "{ ");\r\nfor_each_hist_key_field(i, hist_data) {\r\nkey_field = hist_data->fields[i];\r\nif (i > hist_data->n_vals)\r\nseq_puts(m, ", ");\r\nif (key_field->flags & HIST_FIELD_FL_HEX) {\r\nuval = *(u64 *)(key + key_field->offset);\r\nseq_printf(m, "%s: %llx",\r\nkey_field->field->name, uval);\r\n} else if (key_field->flags & HIST_FIELD_FL_SYM) {\r\nuval = *(u64 *)(key + key_field->offset);\r\nsprint_symbol_no_offset(str, uval);\r\nseq_printf(m, "%s: [%llx] %-45s",\r\nkey_field->field->name, uval, str);\r\n} else if (key_field->flags & HIST_FIELD_FL_SYM_OFFSET) {\r\nuval = *(u64 *)(key + key_field->offset);\r\nsprint_symbol(str, uval);\r\nseq_printf(m, "%s: [%llx] %-55s",\r\nkey_field->field->name, uval, str);\r\n} else if (key_field->flags & HIST_FIELD_FL_EXECNAME) {\r\nchar *comm = elt->private_data;\r\nuval = *(u64 *)(key + key_field->offset);\r\nseq_printf(m, "%s: %-16s[%10llu]",\r\nkey_field->field->name, comm, uval);\r\n} else if (key_field->flags & HIST_FIELD_FL_SYSCALL) {\r\nconst char *syscall_name;\r\nuval = *(u64 *)(key + key_field->offset);\r\nsyscall_name = get_syscall_name(uval);\r\nif (!syscall_name)\r\nsyscall_name = "unknown_syscall";\r\nseq_printf(m, "%s: %-30s[%3llu]",\r\nkey_field->field->name, syscall_name, uval);\r\n} else if (key_field->flags & HIST_FIELD_FL_STACKTRACE) {\r\nseq_puts(m, "stacktrace:\n");\r\nhist_trigger_stacktrace_print(m,\r\nkey + key_field->offset,\r\nHIST_STACKTRACE_DEPTH);\r\nmultiline = true;\r\n} else if (key_field->flags & HIST_FIELD_FL_LOG2) {\r\nseq_printf(m, "%s: ~ 2^%-2llu", key_field->field->name,\r\n*(u64 *)(key + key_field->offset));\r\n} else if (key_field->flags & HIST_FIELD_FL_STRING) {\r\nseq_printf(m, "%s: %-50s", key_field->field->name,\r\n(char *)(key + key_field->offset));\r\n} else {\r\nuval = *(u64 *)(key + key_field->offset);\r\nseq_printf(m, "%s: %10llu", key_field->field->name,\r\nuval);\r\n}\r\n}\r\nif (!multiline)\r\nseq_puts(m, " ");\r\nseq_puts(m, "}");\r\nseq_printf(m, " hitcount: %10llu",\r\ntracing_map_read_sum(elt, HITCOUNT_IDX));\r\nfor (i = 1; i < hist_data->n_vals; i++) {\r\nif (hist_data->fields[i]->flags & HIST_FIELD_FL_HEX) {\r\nseq_printf(m, " %s: %10llx",\r\nhist_data->fields[i]->field->name,\r\ntracing_map_read_sum(elt, i));\r\n} else {\r\nseq_printf(m, " %s: %10llu",\r\nhist_data->fields[i]->field->name,\r\ntracing_map_read_sum(elt, i));\r\n}\r\n}\r\nseq_puts(m, "\n");\r\n}\r\nstatic int print_entries(struct seq_file *m,\r\nstruct hist_trigger_data *hist_data)\r\n{\r\nstruct tracing_map_sort_entry **sort_entries = NULL;\r\nstruct tracing_map *map = hist_data->map;\r\nint i, n_entries;\r\nn_entries = tracing_map_sort_entries(map, hist_data->sort_keys,\r\nhist_data->n_sort_keys,\r\n&sort_entries);\r\nif (n_entries < 0)\r\nreturn n_entries;\r\nfor (i = 0; i < n_entries; i++)\r\nhist_trigger_entry_print(m, hist_data,\r\nsort_entries[i]->key,\r\nsort_entries[i]->elt);\r\ntracing_map_destroy_sort_entries(sort_entries, n_entries);\r\nreturn n_entries;\r\n}\r\nstatic void hist_trigger_show(struct seq_file *m,\r\nstruct event_trigger_data *data, int n)\r\n{\r\nstruct hist_trigger_data *hist_data;\r\nint n_entries, ret = 0;\r\nif (n > 0)\r\nseq_puts(m, "\n\n");\r\nseq_puts(m, "# event histogram\n#\n# trigger info: ");\r\ndata->ops->print(m, data->ops, data);\r\nseq_puts(m, "#\n\n");\r\nhist_data = data->private_data;\r\nn_entries = print_entries(m, hist_data);\r\nif (n_entries < 0) {\r\nret = n_entries;\r\nn_entries = 0;\r\n}\r\nseq_printf(m, "\nTotals:\n Hits: %llu\n Entries: %u\n Dropped: %llu\n",\r\n(u64)atomic64_read(&hist_data->map->hits),\r\nn_entries, (u64)atomic64_read(&hist_data->map->drops));\r\n}\r\nstatic int hist_show(struct seq_file *m, void *v)\r\n{\r\nstruct event_trigger_data *data;\r\nstruct trace_event_file *event_file;\r\nint n = 0, ret = 0;\r\nmutex_lock(&event_mutex);\r\nevent_file = event_file_data(m->private);\r\nif (unlikely(!event_file)) {\r\nret = -ENODEV;\r\ngoto out_unlock;\r\n}\r\nlist_for_each_entry_rcu(data, &event_file->triggers, list) {\r\nif (data->cmd_ops->trigger_type == ETT_EVENT_HIST)\r\nhist_trigger_show(m, data, n++);\r\n}\r\nout_unlock:\r\nmutex_unlock(&event_mutex);\r\nreturn ret;\r\n}\r\nstatic int event_hist_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, hist_show, file);\r\n}\r\nstatic const char *get_hist_field_flags(struct hist_field *hist_field)\r\n{\r\nconst char *flags_str = NULL;\r\nif (hist_field->flags & HIST_FIELD_FL_HEX)\r\nflags_str = "hex";\r\nelse if (hist_field->flags & HIST_FIELD_FL_SYM)\r\nflags_str = "sym";\r\nelse if (hist_field->flags & HIST_FIELD_FL_SYM_OFFSET)\r\nflags_str = "sym-offset";\r\nelse if (hist_field->flags & HIST_FIELD_FL_EXECNAME)\r\nflags_str = "execname";\r\nelse if (hist_field->flags & HIST_FIELD_FL_SYSCALL)\r\nflags_str = "syscall";\r\nelse if (hist_field->flags & HIST_FIELD_FL_LOG2)\r\nflags_str = "log2";\r\nreturn flags_str;\r\n}\r\nstatic void hist_field_print(struct seq_file *m, struct hist_field *hist_field)\r\n{\r\nseq_printf(m, "%s", hist_field->field->name);\r\nif (hist_field->flags) {\r\nconst char *flags_str = get_hist_field_flags(hist_field);\r\nif (flags_str)\r\nseq_printf(m, ".%s", flags_str);\r\n}\r\n}\r\nstatic int event_hist_trigger_print(struct seq_file *m,\r\nstruct event_trigger_ops *ops,\r\nstruct event_trigger_data *data)\r\n{\r\nstruct hist_trigger_data *hist_data = data->private_data;\r\nstruct hist_field *key_field;\r\nunsigned int i;\r\nseq_puts(m, "hist:");\r\nif (data->name)\r\nseq_printf(m, "%s:", data->name);\r\nseq_puts(m, "keys=");\r\nfor_each_hist_key_field(i, hist_data) {\r\nkey_field = hist_data->fields[i];\r\nif (i > hist_data->n_vals)\r\nseq_puts(m, ",");\r\nif (key_field->flags & HIST_FIELD_FL_STACKTRACE)\r\nseq_puts(m, "stacktrace");\r\nelse\r\nhist_field_print(m, key_field);\r\n}\r\nseq_puts(m, ":vals=");\r\nfor_each_hist_val_field(i, hist_data) {\r\nif (i == HITCOUNT_IDX)\r\nseq_puts(m, "hitcount");\r\nelse {\r\nseq_puts(m, ",");\r\nhist_field_print(m, hist_data->fields[i]);\r\n}\r\n}\r\nseq_puts(m, ":sort=");\r\nfor (i = 0; i < hist_data->n_sort_keys; i++) {\r\nstruct tracing_map_sort_key *sort_key;\r\nsort_key = &hist_data->sort_keys[i];\r\nif (i > 0)\r\nseq_puts(m, ",");\r\nif (sort_key->field_idx == HITCOUNT_IDX)\r\nseq_puts(m, "hitcount");\r\nelse {\r\nunsigned int idx = sort_key->field_idx;\r\nif (WARN_ON(idx >= TRACING_MAP_FIELDS_MAX))\r\nreturn -EINVAL;\r\nhist_field_print(m, hist_data->fields[idx]);\r\n}\r\nif (sort_key->descending)\r\nseq_puts(m, ".descending");\r\n}\r\nseq_printf(m, ":size=%u", (1 << hist_data->map->map_bits));\r\nif (data->filter_str)\r\nseq_printf(m, " if %s", data->filter_str);\r\nif (data->paused)\r\nseq_puts(m, " [paused]");\r\nelse\r\nseq_puts(m, " [active]");\r\nseq_putc(m, '\n');\r\nreturn 0;\r\n}\r\nstatic int event_hist_trigger_init(struct event_trigger_ops *ops,\r\nstruct event_trigger_data *data)\r\n{\r\nstruct hist_trigger_data *hist_data = data->private_data;\r\nif (!data->ref && hist_data->attrs->name)\r\nsave_named_trigger(hist_data->attrs->name, data);\r\ndata->ref++;\r\nreturn 0;\r\n}\r\nstatic void event_hist_trigger_free(struct event_trigger_ops *ops,\r\nstruct event_trigger_data *data)\r\n{\r\nstruct hist_trigger_data *hist_data = data->private_data;\r\nif (WARN_ON_ONCE(data->ref <= 0))\r\nreturn;\r\ndata->ref--;\r\nif (!data->ref) {\r\nif (data->name)\r\ndel_named_trigger(data);\r\ntrigger_data_free(data);\r\ndestroy_hist_data(hist_data);\r\n}\r\n}\r\nstatic int event_hist_trigger_named_init(struct event_trigger_ops *ops,\r\nstruct event_trigger_data *data)\r\n{\r\ndata->ref++;\r\nsave_named_trigger(data->named_data->name, data);\r\nevent_hist_trigger_init(ops, data->named_data);\r\nreturn 0;\r\n}\r\nstatic void event_hist_trigger_named_free(struct event_trigger_ops *ops,\r\nstruct event_trigger_data *data)\r\n{\r\nif (WARN_ON_ONCE(data->ref <= 0))\r\nreturn;\r\nevent_hist_trigger_free(ops, data->named_data);\r\ndata->ref--;\r\nif (!data->ref) {\r\ndel_named_trigger(data);\r\ntrigger_data_free(data);\r\n}\r\n}\r\nstatic struct event_trigger_ops *event_hist_get_trigger_ops(char *cmd,\r\nchar *param)\r\n{\r\nreturn &event_hist_trigger_ops;\r\n}\r\nstatic void hist_clear(struct event_trigger_data *data)\r\n{\r\nstruct hist_trigger_data *hist_data = data->private_data;\r\nif (data->name)\r\npause_named_trigger(data);\r\nsynchronize_sched();\r\ntracing_map_clear(hist_data->map);\r\nif (data->name)\r\nunpause_named_trigger(data);\r\n}\r\nstatic bool compatible_field(struct ftrace_event_field *field,\r\nstruct ftrace_event_field *test_field)\r\n{\r\nif (field == test_field)\r\nreturn true;\r\nif (field == NULL || test_field == NULL)\r\nreturn false;\r\nif (strcmp(field->name, test_field->name) != 0)\r\nreturn false;\r\nif (strcmp(field->type, test_field->type) != 0)\r\nreturn false;\r\nif (field->size != test_field->size)\r\nreturn false;\r\nif (field->is_signed != test_field->is_signed)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool hist_trigger_match(struct event_trigger_data *data,\r\nstruct event_trigger_data *data_test,\r\nstruct event_trigger_data *named_data,\r\nbool ignore_filter)\r\n{\r\nstruct tracing_map_sort_key *sort_key, *sort_key_test;\r\nstruct hist_trigger_data *hist_data, *hist_data_test;\r\nstruct hist_field *key_field, *key_field_test;\r\nunsigned int i;\r\nif (named_data && (named_data != data_test) &&\r\n(named_data != data_test->named_data))\r\nreturn false;\r\nif (!named_data && is_named_trigger(data_test))\r\nreturn false;\r\nhist_data = data->private_data;\r\nhist_data_test = data_test->private_data;\r\nif (hist_data->n_vals != hist_data_test->n_vals ||\r\nhist_data->n_fields != hist_data_test->n_fields ||\r\nhist_data->n_sort_keys != hist_data_test->n_sort_keys)\r\nreturn false;\r\nif (!ignore_filter) {\r\nif ((data->filter_str && !data_test->filter_str) ||\r\n(!data->filter_str && data_test->filter_str))\r\nreturn false;\r\n}\r\nfor_each_hist_field(i, hist_data) {\r\nkey_field = hist_data->fields[i];\r\nkey_field_test = hist_data_test->fields[i];\r\nif (key_field->flags != key_field_test->flags)\r\nreturn false;\r\nif (!compatible_field(key_field->field, key_field_test->field))\r\nreturn false;\r\nif (key_field->offset != key_field_test->offset)\r\nreturn false;\r\n}\r\nfor (i = 0; i < hist_data->n_sort_keys; i++) {\r\nsort_key = &hist_data->sort_keys[i];\r\nsort_key_test = &hist_data_test->sort_keys[i];\r\nif (sort_key->field_idx != sort_key_test->field_idx ||\r\nsort_key->descending != sort_key_test->descending)\r\nreturn false;\r\n}\r\nif (!ignore_filter && data->filter_str &&\r\n(strcmp(data->filter_str, data_test->filter_str) != 0))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int hist_register_trigger(char *glob, struct event_trigger_ops *ops,\r\nstruct event_trigger_data *data,\r\nstruct trace_event_file *file)\r\n{\r\nstruct hist_trigger_data *hist_data = data->private_data;\r\nstruct event_trigger_data *test, *named_data = NULL;\r\nint ret = 0;\r\nif (hist_data->attrs->name) {\r\nnamed_data = find_named_trigger(hist_data->attrs->name);\r\nif (named_data) {\r\nif (!hist_trigger_match(data, named_data, named_data,\r\ntrue)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\n}\r\nif (hist_data->attrs->name && !named_data)\r\ngoto new;\r\nlist_for_each_entry_rcu(test, &file->triggers, list) {\r\nif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\r\nif (!hist_trigger_match(data, test, named_data, false))\r\ncontinue;\r\nif (hist_data->attrs->pause)\r\ntest->paused = true;\r\nelse if (hist_data->attrs->cont)\r\ntest->paused = false;\r\nelse if (hist_data->attrs->clear)\r\nhist_clear(test);\r\nelse\r\nret = -EEXIST;\r\ngoto out;\r\n}\r\n}\r\nnew:\r\nif (hist_data->attrs->cont || hist_data->attrs->clear) {\r\nret = -ENOENT;\r\ngoto out;\r\n}\r\nif (hist_data->attrs->pause)\r\ndata->paused = true;\r\nif (named_data) {\r\ndestroy_hist_data(data->private_data);\r\ndata->private_data = named_data->private_data;\r\nset_named_trigger_data(data, named_data);\r\ndata->ops = &event_hist_trigger_named_ops;\r\n}\r\nif (data->ops->init) {\r\nret = data->ops->init(data->ops, data);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nlist_add_rcu(&data->list, &file->triggers);\r\nret++;\r\nupdate_cond_flag(file);\r\nif (trace_event_trigger_enable_disable(file, 1) < 0) {\r\nlist_del_rcu(&data->list);\r\nupdate_cond_flag(file);\r\nret--;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic void hist_unregister_trigger(char *glob, struct event_trigger_ops *ops,\r\nstruct event_trigger_data *data,\r\nstruct trace_event_file *file)\r\n{\r\nstruct hist_trigger_data *hist_data = data->private_data;\r\nstruct event_trigger_data *test, *named_data = NULL;\r\nbool unregistered = false;\r\nif (hist_data->attrs->name)\r\nnamed_data = find_named_trigger(hist_data->attrs->name);\r\nlist_for_each_entry_rcu(test, &file->triggers, list) {\r\nif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\r\nif (!hist_trigger_match(data, test, named_data, false))\r\ncontinue;\r\nunregistered = true;\r\nlist_del_rcu(&test->list);\r\ntrace_event_trigger_enable_disable(file, 0);\r\nupdate_cond_flag(file);\r\nbreak;\r\n}\r\n}\r\nif (unregistered && test->ops->free)\r\ntest->ops->free(test->ops, test);\r\n}\r\nstatic void hist_unreg_all(struct trace_event_file *file)\r\n{\r\nstruct event_trigger_data *test, *n;\r\nlist_for_each_entry_safe(test, n, &file->triggers, list) {\r\nif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\r\nlist_del_rcu(&test->list);\r\ntrace_event_trigger_enable_disable(file, 0);\r\nupdate_cond_flag(file);\r\nif (test->ops->free)\r\ntest->ops->free(test->ops, test);\r\n}\r\n}\r\n}\r\nstatic int event_hist_trigger_func(struct event_command *cmd_ops,\r\nstruct trace_event_file *file,\r\nchar *glob, char *cmd, char *param)\r\n{\r\nunsigned int hist_trigger_bits = TRACING_MAP_BITS_DEFAULT;\r\nstruct event_trigger_data *trigger_data;\r\nstruct hist_trigger_attrs *attrs;\r\nstruct event_trigger_ops *trigger_ops;\r\nstruct hist_trigger_data *hist_data;\r\nchar *trigger;\r\nint ret = 0;\r\nif (!param)\r\nreturn -EINVAL;\r\ntrigger = strsep(&param, " \t");\r\nif (!trigger)\r\nreturn -EINVAL;\r\nattrs = parse_hist_trigger_attrs(trigger);\r\nif (IS_ERR(attrs))\r\nreturn PTR_ERR(attrs);\r\nif (attrs->map_bits)\r\nhist_trigger_bits = attrs->map_bits;\r\nhist_data = create_hist_data(hist_trigger_bits, attrs, file);\r\nif (IS_ERR(hist_data)) {\r\ndestroy_hist_trigger_attrs(attrs);\r\nreturn PTR_ERR(hist_data);\r\n}\r\ntrigger_ops = cmd_ops->get_trigger_ops(cmd, trigger);\r\nret = -ENOMEM;\r\ntrigger_data = kzalloc(sizeof(*trigger_data), GFP_KERNEL);\r\nif (!trigger_data)\r\ngoto out_free;\r\ntrigger_data->count = -1;\r\ntrigger_data->ops = trigger_ops;\r\ntrigger_data->cmd_ops = cmd_ops;\r\nINIT_LIST_HEAD(&trigger_data->list);\r\nRCU_INIT_POINTER(trigger_data->filter, NULL);\r\ntrigger_data->private_data = hist_data;\r\nif (param && cmd_ops->set_filter) {\r\nret = cmd_ops->set_filter(param, trigger_data, file);\r\nif (ret < 0)\r\ngoto out_free;\r\n}\r\nif (glob[0] == '!') {\r\ncmd_ops->unreg(glob+1, trigger_ops, trigger_data, file);\r\nret = 0;\r\ngoto out_free;\r\n}\r\nret = cmd_ops->reg(glob, trigger_ops, trigger_data, file);\r\nif (!ret) {\r\nif (!(attrs->pause || attrs->cont || attrs->clear))\r\nret = -ENOENT;\r\ngoto out_free;\r\n} else if (ret < 0)\r\ngoto out_free;\r\nret = 0;\r\nout:\r\nreturn ret;\r\nout_free:\r\nif (cmd_ops->set_filter)\r\ncmd_ops->set_filter(NULL, trigger_data, NULL);\r\nkfree(trigger_data);\r\ndestroy_hist_data(hist_data);\r\ngoto out;\r\n}\r\n__init int register_trigger_hist_cmd(void)\r\n{\r\nint ret;\r\nret = register_event_command(&trigger_hist_cmd);\r\nWARN_ON(ret < 0);\r\nreturn ret;\r\n}\r\nstatic void\r\nhist_enable_trigger(struct event_trigger_data *data, void *rec)\r\n{\r\nstruct enable_trigger_data *enable_data = data->private_data;\r\nstruct event_trigger_data *test;\r\nlist_for_each_entry_rcu(test, &enable_data->file->triggers, list) {\r\nif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\r\nif (enable_data->enable)\r\ntest->paused = false;\r\nelse\r\ntest->paused = true;\r\n}\r\n}\r\n}\r\nstatic void\r\nhist_enable_count_trigger(struct event_trigger_data *data, void *rec)\r\n{\r\nif (!data->count)\r\nreturn;\r\nif (data->count != -1)\r\n(data->count)--;\r\nhist_enable_trigger(data, rec);\r\n}\r\nstatic struct event_trigger_ops *\r\nhist_enable_get_trigger_ops(char *cmd, char *param)\r\n{\r\nstruct event_trigger_ops *ops;\r\nbool enable;\r\nenable = (strcmp(cmd, ENABLE_HIST_STR) == 0);\r\nif (enable)\r\nops = param ? &hist_enable_count_trigger_ops :\r\n&hist_enable_trigger_ops;\r\nelse\r\nops = param ? &hist_disable_count_trigger_ops :\r\n&hist_disable_trigger_ops;\r\nreturn ops;\r\n}\r\nstatic void hist_enable_unreg_all(struct trace_event_file *file)\r\n{\r\nstruct event_trigger_data *test, *n;\r\nlist_for_each_entry_safe(test, n, &file->triggers, list) {\r\nif (test->cmd_ops->trigger_type == ETT_HIST_ENABLE) {\r\nlist_del_rcu(&test->list);\r\nupdate_cond_flag(file);\r\ntrace_event_trigger_enable_disable(file, 0);\r\nif (test->ops->free)\r\ntest->ops->free(test->ops, test);\r\n}\r\n}\r\n}\r\nstatic __init void unregister_trigger_hist_enable_disable_cmds(void)\r\n{\r\nunregister_event_command(&trigger_hist_enable_cmd);\r\nunregister_event_command(&trigger_hist_disable_cmd);\r\n}\r\n__init int register_trigger_hist_enable_disable_cmds(void)\r\n{\r\nint ret;\r\nret = register_event_command(&trigger_hist_enable_cmd);\r\nif (WARN_ON(ret < 0))\r\nreturn ret;\r\nret = register_event_command(&trigger_hist_disable_cmd);\r\nif (WARN_ON(ret < 0))\r\nunregister_trigger_hist_enable_disable_cmds();\r\nreturn ret;\r\n}
