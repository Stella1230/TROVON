static void mtx1_wdt_trigger(unsigned long unused)\r\n{\r\nspin_lock(&mtx1_wdt_device.lock);\r\nif (mtx1_wdt_device.running)\r\nticks--;\r\nmtx1_wdt_device.gstate = !mtx1_wdt_device.gstate;\r\ngpio_set_value(mtx1_wdt_device.gpio, mtx1_wdt_device.gstate);\r\nif (mtx1_wdt_device.queue && ticks)\r\nmod_timer(&mtx1_wdt_device.timer, jiffies + MTX1_WDT_INTERVAL);\r\nelse\r\ncomplete(&mtx1_wdt_device.stop);\r\nspin_unlock(&mtx1_wdt_device.lock);\r\n}\r\nstatic void mtx1_wdt_reset(void)\r\n{\r\nticks = mtx1_wdt_device.default_ticks;\r\n}\r\nstatic void mtx1_wdt_start(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mtx1_wdt_device.lock, flags);\r\nif (!mtx1_wdt_device.queue) {\r\nmtx1_wdt_device.queue = 1;\r\nmtx1_wdt_device.gstate = 1;\r\ngpio_set_value(mtx1_wdt_device.gpio, 1);\r\nmod_timer(&mtx1_wdt_device.timer, jiffies + MTX1_WDT_INTERVAL);\r\n}\r\nmtx1_wdt_device.running++;\r\nspin_unlock_irqrestore(&mtx1_wdt_device.lock, flags);\r\n}\r\nstatic int mtx1_wdt_stop(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mtx1_wdt_device.lock, flags);\r\nif (mtx1_wdt_device.queue) {\r\nmtx1_wdt_device.queue = 0;\r\nmtx1_wdt_device.gstate = 0;\r\ngpio_set_value(mtx1_wdt_device.gpio, 0);\r\n}\r\nticks = mtx1_wdt_device.default_ticks;\r\nspin_unlock_irqrestore(&mtx1_wdt_device.lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mtx1_wdt_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(0, &mtx1_wdt_device.inuse))\r\nreturn -EBUSY;\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int mtx1_wdt_release(struct inode *inode, struct file *file)\r\n{\r\nclear_bit(0, &mtx1_wdt_device.inuse);\r\nreturn 0;\r\n}\r\nstatic long mtx1_wdt_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = (int __user *)argp;\r\nunsigned int value;\r\nstatic const struct watchdog_info ident = {\r\n.options = WDIOF_CARDRESET,\r\n.identity = "MTX-1 WDT",\r\n};\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nif (copy_to_user(argp, &ident, sizeof(ident)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nput_user(0, p);\r\nbreak;\r\ncase WDIOC_SETOPTIONS:\r\nif (get_user(value, p))\r\nreturn -EFAULT;\r\nif (value & WDIOS_ENABLECARD)\r\nmtx1_wdt_start();\r\nelse if (value & WDIOS_DISABLECARD)\r\nmtx1_wdt_stop();\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\ncase WDIOC_KEEPALIVE:\r\nmtx1_wdt_reset();\r\nbreak;\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t mtx1_wdt_write(struct file *file, const char *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nif (!count)\r\nreturn -EIO;\r\nmtx1_wdt_reset();\r\nreturn count;\r\n}\r\nstatic int mtx1_wdt_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nmtx1_wdt_device.gpio = pdev->resource[0].start;\r\nret = devm_gpio_request_one(&pdev->dev, mtx1_wdt_device.gpio,\r\nGPIOF_OUT_INIT_HIGH, "mtx1-wdt");\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to request gpio");\r\nreturn ret;\r\n}\r\nspin_lock_init(&mtx1_wdt_device.lock);\r\ninit_completion(&mtx1_wdt_device.stop);\r\nmtx1_wdt_device.queue = 0;\r\nclear_bit(0, &mtx1_wdt_device.inuse);\r\nsetup_timer(&mtx1_wdt_device.timer, mtx1_wdt_trigger, 0L);\r\nmtx1_wdt_device.default_ticks = ticks;\r\nret = misc_register(&mtx1_wdt_misc);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to register\n");\r\nreturn ret;\r\n}\r\nmtx1_wdt_start();\r\ndev_info(&pdev->dev, "MTX-1 Watchdog driver\n");\r\nreturn 0;\r\n}\r\nstatic int mtx1_wdt_remove(struct platform_device *pdev)\r\n{\r\nif (mtx1_wdt_device.queue) {\r\nmtx1_wdt_device.queue = 0;\r\nwait_for_completion(&mtx1_wdt_device.stop);\r\n}\r\nmisc_deregister(&mtx1_wdt_misc);\r\nreturn 0;\r\n}
