static inline __u32 iov_crc32( __u32 c, struct kvec *iov, unsigned int cnt )\r\n{\r\nunsigned int j;\r\nfor (j = 0; j < cnt; j++)\r\nc = crc32_be( c, iov[j].iov_base, iov[j].iov_len );\r\nreturn c;\r\n}\r\nstatic void hexdump(const unsigned char *buf, unsigned short len)\r\n{\r\nprint_hex_dump_debug("", DUMP_PREFIX_OFFSET, 16, 1, buf, len, true);\r\n}\r\nstatic __be16 dvb_net_eth_type_trans(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct ethhdr *eth;\r\nunsigned char *rawp;\r\nskb_reset_mac_header(skb);\r\nskb_pull(skb,dev->hard_header_len);\r\neth = eth_hdr(skb);\r\nif (*eth->h_dest & 1) {\r\nif(ether_addr_equal(eth->h_dest,dev->broadcast))\r\nskb->pkt_type=PACKET_BROADCAST;\r\nelse\r\nskb->pkt_type=PACKET_MULTICAST;\r\n}\r\nif (ntohs(eth->h_proto) >= ETH_P_802_3_MIN)\r\nreturn eth->h_proto;\r\nrawp = skb->data;\r\nif (*(unsigned short *)rawp == 0xFFFF)\r\nreturn htons(ETH_P_802_3);\r\nreturn htons(ETH_P_802_2);\r\n}\r\nstatic int ule_test_sndu( struct dvb_net_priv *p )\r\n{\r\nreturn -1;\r\n}\r\nstatic int ule_bridged_sndu( struct dvb_net_priv *p )\r\n{\r\nstruct ethhdr *hdr = (struct ethhdr*) p->ule_next_hdr;\r\nif(ntohs(hdr->h_proto) < ETH_P_802_3_MIN) {\r\nint framelen = p->ule_sndu_len - ((p->ule_next_hdr+sizeof(struct ethhdr)) - p->ule_skb->data);\r\nif(framelen != ntohs(hdr->h_proto)) {\r\nreturn -1;\r\n}\r\n}\r\np->ule_bridged = 1;\r\nreturn 0;\r\n}\r\nstatic int ule_exthdr_padding(struct dvb_net_priv *p)\r\n{\r\nreturn 0;\r\n}\r\nstatic int handle_one_ule_extension( struct dvb_net_priv *p )\r\n{\r\nstatic int (*ule_mandatory_ext_handlers[255])( struct dvb_net_priv *p ) =\r\n{ [0] = ule_test_sndu, [1] = ule_bridged_sndu, [2] = NULL, }\r\nint handle_ule_extensions( struct dvb_net_priv *p )\r\n{\r\nint total_ext_len = 0, l;\r\np->ule_next_hdr = p->ule_skb->data;\r\ndo {\r\nl = handle_one_ule_extension( p );\r\nif (l < 0)\r\nreturn l;\r\ntotal_ext_len += l;\r\n#ifdef ULE_DEBUG\r\npr_debug("ule_next_hdr=%p, ule_sndu_type=%i, l=%i, total_ext_len=%i\n",\r\np->ule_next_hdr, (int)p->ule_sndu_type,\r\nl, total_ext_len);\r\n#endif\r\n} while (p->ule_sndu_type < ETH_P_802_3_MIN);\r\nreturn total_ext_len;\r\n}\r\nstatic inline void reset_ule( struct dvb_net_priv *p )\r\n{\r\np->ule_skb = NULL;\r\np->ule_next_hdr = NULL;\r\np->ule_sndu_len = 0;\r\np->ule_sndu_type = 0;\r\np->ule_sndu_type_1 = 0;\r\np->ule_sndu_remain = 0;\r\np->ule_dbit = 0xFF;\r\np->ule_bridged = 0;\r\n}\r\nstatic int dvb_net_ule_new_ts_cell(struct dvb_net_ule_handle *h)\r\n{\r\n#ifdef ULE_DEBUG\r\nif (h->ule_where >= &h->ule_hist[100*TS_SZ])\r\nh->ule_where = h->ule_hist;\r\nmemcpy(h->ule_where, h->ts, TS_SZ);\r\nif (h->ule_dump) {\r\nhexdump(h->ule_where, TS_SZ);\r\nh->ule_dump = 0;\r\n}\r\nh->ule_where += TS_SZ;\r\n#endif\r\nif ((h->ts[0] != TS_SYNC) || (h->ts[1] & TS_TEI) ||\r\n((h->ts[3] & TS_SC) != 0)) {\r\npr_warn("%lu: Invalid TS cell: SYNC %#x, TEI %u, SC %#x.\n",\r\nh->priv->ts_count, h->ts[0],\r\n(h->ts[1] & TS_TEI) >> 7,\r\n(h->ts[3] & TS_SC) >> 6);\r\nif (h->priv->ule_skb) {\r\ndev_kfree_skb(h->priv->ule_skb);\r\nh->dev->stats.rx_errors++;\r\nh->dev->stats.rx_frame_errors++;\r\n}\r\nreset_ule(h->priv);\r\nh->priv->need_pusi = 1;\r\nh->ts += TS_SZ;\r\nh->priv->ts_count++;\r\nreturn 1;\r\n}\r\nh->ts_remain = 184;\r\nh->from_where = h->ts + 4;\r\nreturn 0;\r\n}\r\nstatic int dvb_net_ule_ts_pusi(struct dvb_net_ule_handle *h)\r\n{\r\nif (h->ts[1] & TS_PUSI) {\r\nh->priv->tscc = h->ts[3] & 0x0F;\r\nif (h->ts[4] > h->ts_remain) {\r\npr_err("%lu: Invalid ULE packet (pointer field %d)\n",\r\nh->priv->ts_count, h->ts[4]);\r\nh->ts += TS_SZ;\r\nh->priv->ts_count++;\r\nreturn 1;\r\n}\r\nh->from_where = &h->ts[5] + h->ts[4];\r\nh->ts_remain -= 1 + h->ts[4];\r\nh->skipped = 0;\r\n} else {\r\nh->skipped++;\r\nh->ts += TS_SZ;\r\nh->priv->ts_count++;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dvb_net_ule_new_ts(struct dvb_net_ule_handle *h)\r\n{\r\nif ((h->ts[3] & 0x0F) == h->priv->tscc)\r\nh->priv->tscc = (h->priv->tscc + 1) & 0x0F;\r\nelse {\r\npr_warn("%lu: TS discontinuity: got %#x, expected %#x.\n",\r\nh->priv->ts_count, h->ts[3] & 0x0F,\r\nh->priv->tscc);\r\nif (h->priv->ule_skb) {\r\ndev_kfree_skb(h->priv->ule_skb);\r\nh->dev->stats.rx_errors++;\r\nh->dev->stats.rx_frame_errors++;\r\n}\r\nreset_ule(h->priv);\r\nh->priv->need_pusi = 1;\r\nreturn 1;\r\n}\r\nif (h->ts[1] & TS_PUSI) {\r\nif (!h->priv->need_pusi) {\r\nif (!(*h->from_where < (h->ts_remain-1)) ||\r\n*h->from_where != h->priv->ule_sndu_remain) {\r\npr_warn("%lu: Invalid pointer field: %u.\n",\r\nh->priv->ts_count,\r\n*h->from_where);\r\nif (h->priv->ule_skb) {\r\nh->error = true;\r\ndev_kfree_skb(h->priv->ule_skb);\r\n}\r\nif (h->error || h->priv->ule_sndu_remain) {\r\nh->dev->stats.rx_errors++;\r\nh->dev->stats.rx_frame_errors++;\r\nh->error = false;\r\n}\r\nreset_ule(h->priv);\r\nh->priv->need_pusi = 1;\r\nreturn 1;\r\n}\r\nh->from_where += 1;\r\nh->ts_remain -= 1;\r\n} else\r\nh->priv->need_pusi = 0;\r\nif (h->priv->ule_sndu_remain > 183) {\r\nh->dev->stats.rx_errors++;\r\nh->dev->stats.rx_length_errors++;\r\npr_warn("%lu: Expected %d more SNDU bytes, but got PUSI (pf %d, h->ts_remain %d). Flushing incomplete payload.\n",\r\nh->priv->ts_count,\r\nh->priv->ule_sndu_remain,\r\nh->ts[4], h->ts_remain);\r\ndev_kfree_skb(h->priv->ule_skb);\r\nreset_ule(h->priv);\r\nh->from_where += h->ts[4];\r\nh->ts_remain -= h->ts[4];\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dvb_net_ule_new_payload(struct dvb_net_ule_handle *h)\r\n{\r\nif (h->ts_remain < 2) {\r\npr_warn("Invalid payload packing: only %d bytes left in TS. Resyncing.\n",\r\nh->ts_remain);\r\nh->priv->ule_sndu_len = 0;\r\nh->priv->need_pusi = 1;\r\nh->ts += TS_SZ;\r\nreturn 1;\r\n}\r\nif (!h->priv->ule_sndu_len) {\r\nh->priv->ule_sndu_len = h->from_where[0] << 8 |\r\nh->from_where[1];\r\nif (h->priv->ule_sndu_len & 0x8000) {\r\nh->priv->ule_sndu_len &= 0x7FFF;\r\nh->priv->ule_dbit = 1;\r\n} else\r\nh->priv->ule_dbit = 0;\r\nif (h->priv->ule_sndu_len < 5) {\r\npr_warn("%lu: Invalid ULE SNDU length %u. Resyncing.\n",\r\nh->priv->ts_count,\r\nh->priv->ule_sndu_len);\r\nh->dev->stats.rx_errors++;\r\nh->dev->stats.rx_length_errors++;\r\nh->priv->ule_sndu_len = 0;\r\nh->priv->need_pusi = 1;\r\nh->new_ts = 1;\r\nh->ts += TS_SZ;\r\nh->priv->ts_count++;\r\nreturn 1;\r\n}\r\nh->ts_remain -= 2;\r\nh->from_where += 2;\r\n}\r\nh->priv->ule_sndu_remain = h->priv->ule_sndu_len + 2;\r\nswitch (h->ts_remain) {\r\ncase 1:\r\nh->priv->ule_sndu_remain--;\r\nh->priv->ule_sndu_type = h->from_where[0] << 8;\r\nh->priv->ule_sndu_type_1 = 1;\r\nh->ts_remain -= 1;\r\nh->from_where += 1;\r\ncase 0:\r\nh->new_ts = 1;\r\nh->ts += TS_SZ;\r\nh->priv->ts_count++;\r\nreturn 1;\r\ndefault:\r\nif (h->priv->ule_sndu_type_1) {\r\nh->priv->ule_sndu_type_1 = 0;\r\nh->priv->ule_sndu_type |= h->from_where[0];\r\nh->from_where += 1;\r\nh->ts_remain -= 1;\r\n} else {\r\nh->priv->ule_sndu_type = h->from_where[0] << 8 |\r\nh->from_where[1];\r\nh->from_where += 2;\r\nh->ts_remain -= 2;\r\n}\r\nbreak;\r\n}\r\nh->priv->ule_skb = dev_alloc_skb(h->priv->ule_sndu_len +\r\nETH_HLEN + ETH_ALEN);\r\nif (!h->priv->ule_skb) {\r\npr_notice("%s: Memory squeeze, dropping packet.\n",\r\nh->dev->name);\r\nh->dev->stats.rx_dropped++;\r\nreturn -1;\r\n}\r\nh->priv->ule_sndu_remain = h->priv->ule_sndu_len;\r\nh->priv->ule_skb->dev = h->dev;\r\nskb_reserve(h->priv->ule_skb, ETH_HLEN + ETH_ALEN);\r\nreturn 0;\r\n}\r\nstatic int dvb_net_ule_should_drop(struct dvb_net_ule_handle *h)\r\n{\r\nstatic const u8 bc_addr[ETH_ALEN] = { [0 ... ETH_ALEN - 1] = 0xff };\r\nif (h->priv->rx_mode == RX_MODE_PROMISC)\r\nreturn 0;\r\nif (h->priv->ule_skb->data[0] & 0x01) {\r\nif (!ether_addr_equal(h->priv->ule_skb->data, bc_addr)) {\r\nif (h->priv->rx_mode == RX_MODE_MULTI) {\r\nint i;\r\nfor (i = 0; i < h->priv->multi_num &&\r\n!ether_addr_equal(h->priv->ule_skb->data,\r\nh->priv->multi_macs[i]);\r\ni++)\r\n;\r\nif (i == h->priv->multi_num)\r\nreturn 1;\r\n} else if (h->priv->rx_mode != RX_MODE_ALL_MULTI)\r\nreturn 1;\r\n}\r\n} else if (!ether_addr_equal(h->priv->ule_skb->data, h->dev->dev_addr))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void dvb_net_ule_check_crc(struct dvb_net_ule_handle *h,\r\nu32 ule_crc, u32 expected_crc)\r\n{\r\nu8 dest_addr[ETH_ALEN];\r\nif (ule_crc != expected_crc) {\r\npr_warn("%lu: CRC32 check FAILED: %08x / %08x, SNDU len %d type %#x, ts_remain %d, next 2: %x.\n",\r\nh->priv->ts_count, ule_crc, expected_crc,\r\nh->priv->ule_sndu_len, h->priv->ule_sndu_type,\r\nh->ts_remain,\r\nh->ts_remain > 2 ?\r\n*(unsigned short *)h->from_where : 0);\r\n#ifdef ULE_DEBUG\r\nhexdump(iov[0].iov_base, iov[0].iov_len);\r\nhexdump(iov[1].iov_base, iov[1].iov_len);\r\nhexdump(iov[2].iov_base, iov[2].iov_len);\r\nif (h->ule_where == h->ule_hist) {\r\nhexdump(&h->ule_hist[98*TS_SZ], TS_SZ);\r\nhexdump(&h->ule_hist[99*TS_SZ], TS_SZ);\r\n} else if (h->ule_where == &h->ule_hist[TS_SZ]) {\r\nhexdump(&h->ule_hist[99*TS_SZ], TS_SZ);\r\nhexdump(h->ule_hist, TS_SZ);\r\n} else {\r\nhexdump(h->ule_where - TS_SZ - TS_SZ, TS_SZ);\r\nhexdump(h->ule_where - TS_SZ, TS_SZ);\r\n}\r\nh->ule_dump = 1;\r\n#endif\r\nh->dev->stats.rx_errors++;\r\nh->dev->stats.rx_crc_errors++;\r\ndev_kfree_skb(h->priv->ule_skb);\r\nreturn;\r\n}\r\nh->priv->ule_skb->tail -= 4;\r\nh->priv->ule_skb->len -= 4;\r\nif (!h->priv->ule_dbit) {\r\nif (dvb_net_ule_should_drop(h)) {\r\n#ifdef ULE_DEBUG\r\nnetdev_dbg(h->dev,\r\n"Dropping SNDU: MAC destination address does not match: dest addr: %pM, h->dev addr: %pM\n",\r\nh->priv->ule_skb->data, h->dev->dev_addr);\r\n#endif\r\ndev_kfree_skb(h->priv->ule_skb);\r\nreturn;\r\n}\r\nskb_copy_from_linear_data(h->priv->ule_skb, dest_addr,\r\nETH_ALEN);\r\nskb_pull(h->priv->ule_skb, ETH_ALEN);\r\n} else {\r\neth_zero_addr(dest_addr);\r\n}\r\nif (h->priv->ule_sndu_type < ETH_P_802_3_MIN) {\r\nint l = handle_ule_extensions(h->priv);\r\nif (l < 0) {\r\ndev_kfree_skb(h->priv->ule_skb);\r\nreturn;\r\n}\r\nskb_pull(h->priv->ule_skb, l);\r\n}\r\nif (!h->priv->ule_bridged) {\r\nskb_push(h->priv->ule_skb, ETH_HLEN);\r\nh->ethh = (struct ethhdr *)h->priv->ule_skb->data;\r\nmemcpy(h->ethh->h_dest, dest_addr, ETH_ALEN);\r\neth_zero_addr(h->ethh->h_source);\r\nh->ethh->h_proto = htons(h->priv->ule_sndu_type);\r\n}\r\nh->priv->ule_bridged = 0;\r\nh->priv->ule_skb->protocol = dvb_net_eth_type_trans(h->priv->ule_skb,\r\nh->dev);\r\n#if 0\r\nif (h->priv->ule_dbit && skb->pkt_type == PACKET_OTHERHOST)\r\nh->priv->ule_skb->pkt_type = PACKET_HOST;\r\n#endif\r\nh->dev->stats.rx_packets++;\r\nh->dev->stats.rx_bytes += h->priv->ule_skb->len;\r\nnetif_rx(h->priv->ule_skb);\r\n}\r\nstatic void dvb_net_ule(struct net_device *dev, const u8 *buf, size_t buf_len)\r\n{\r\nint ret;\r\nstruct dvb_net_ule_handle h = {\r\n.dev = dev,\r\n.buf = buf,\r\n.buf_len = buf_len,\r\n.skipped = 0L,\r\n.ts = NULL,\r\n.ts_end = NULL,\r\n.from_where = NULL,\r\n.ts_remain = 0,\r\n.how_much = 0,\r\n.new_ts = 1,\r\n.ethh = NULL,\r\n.error = false,\r\n#ifdef ULE_DEBUG\r\n.ule_where = ule_hist,\r\n#endif\r\n};\r\nfor (h.ts = h.buf, h.ts_end = h.buf + h.buf_len;\r\nh.ts < h.ts_end; ) {\r\nif (h.new_ts) {\r\nif (dvb_net_ule_new_ts_cell(&h))\r\ncontinue;\r\n}\r\nif (h.priv->need_pusi) {\r\nif (dvb_net_ule_ts_pusi(&h))\r\ncontinue;\r\n}\r\nif (h.new_ts) {\r\nif (dvb_net_ule_new_ts(&h))\r\ncontinue;\r\n}\r\nif (h.priv->ule_skb == NULL) {\r\nret = dvb_net_ule_new_payload(&h);\r\nif (ret < 0)\r\nreturn;\r\nif (ret)\r\ncontinue;\r\n}\r\nh.how_much = min(h.priv->ule_sndu_remain, (int)h.ts_remain);\r\nmemcpy(skb_put(h.priv->ule_skb, h.how_much),\r\nh.from_where, h.how_much);\r\nh.priv->ule_sndu_remain -= h.how_much;\r\nh.ts_remain -= h.how_much;\r\nh.from_where += h.how_much;\r\nif (h.priv->ule_sndu_remain <= 0) {\r\n__be16 ulen = htons(h.priv->ule_sndu_len);\r\n__be16 utype = htons(h.priv->ule_sndu_type);\r\nconst u8 *tail;\r\nstruct kvec iov[3] = {\r\n{ &ulen, sizeof ulen },\r\n{ &utype, sizeof utype },\r\n{ h.priv->ule_skb->data,\r\nh.priv->ule_skb->len - 4 }\r\n};\r\nu32 ule_crc = ~0L, expected_crc;\r\nif (h.priv->ule_dbit) {\r\nulen |= htons(0x8000);\r\n}\r\nule_crc = iov_crc32(ule_crc, iov, 3);\r\ntail = skb_tail_pointer(h.priv->ule_skb);\r\nexpected_crc = *(tail - 4) << 24 |\r\n*(tail - 3) << 16 |\r\n*(tail - 2) << 8 |\r\n*(tail - 1);\r\ndvb_net_ule_check_crc(&h, ule_crc, expected_crc);\r\nreset_ule(h.priv);\r\n}\r\nif (h.ts_remain >= 2 && *((unsigned short *)h.from_where) != 0xFFFF) {\r\nh.new_ts = 0;\r\nh.priv->ule_skb = NULL;\r\nh.priv->ule_sndu_type_1 = 0;\r\nh.priv->ule_sndu_len = 0;\r\n} else {\r\nh.new_ts = 1;\r\nh.ts += TS_SZ;\r\nh.priv->ts_count++;\r\nif (h.priv->ule_skb == NULL) {\r\nh.priv->need_pusi = 1;\r\nh.priv->ule_sndu_type_1 = 0;\r\nh.priv->ule_sndu_len = 0;\r\n}\r\n}\r\n}\r\n}\r\nstatic int dvb_net_ts_callback(const u8 *buffer1, size_t buffer1_len,\r\nconst u8 *buffer2, size_t buffer2_len,\r\nstruct dmx_ts_feed *feed)\r\n{\r\nstruct net_device *dev = feed->priv;\r\nif (buffer2)\r\npr_warn("buffer2 not NULL: %p.\n", buffer2);\r\nif (buffer1_len > 32768)\r\npr_warn("length > 32k: %zu.\n", buffer1_len);\r\ndvb_net_ule(dev, buffer1, buffer1_len);\r\nreturn 0;\r\n}\r\nstatic void dvb_net_sec(struct net_device *dev,\r\nconst u8 *pkt, int pkt_len)\r\n{\r\nu8 *eth;\r\nstruct sk_buff *skb;\r\nstruct net_device_stats *stats = &dev->stats;\r\nint snap = 0;\r\nif (pkt_len < 16) {\r\npr_warn("%s: IP/MPE packet length = %d too small.\n",\r\ndev->name, pkt_len);\r\nstats->rx_errors++;\r\nstats->rx_length_errors++;\r\nreturn;\r\n}\r\n#if 0\r\nif ((pkt[5] & 0xfd) != 0xc1) {\r\n#else\r\nif ((pkt[5] & 0x3c) != 0x00) {\r\n#endif\r\nstats->rx_errors++;\r\nstats->rx_crc_errors++;\r\nreturn;\r\n}\r\nif (pkt[5] & 0x02) {\r\nif (pkt_len < 24 || memcmp(&pkt[12], "\xaa\xaa\x03\0\0\0", 6)) {\r\nstats->rx_dropped++;\r\nreturn;\r\n}\r\nsnap = 8;\r\n}\r\nif (pkt[7]) {\r\nstats->rx_errors++;\r\nstats->rx_frame_errors++;\r\nreturn;\r\n}\r\nif (!(skb = dev_alloc_skb(pkt_len - 4 - 12 + 14 + 2 - snap))) {\r\nstats->rx_dropped++;\r\nreturn;\r\n}\r\nskb_reserve(skb, 2);\r\nskb->dev = dev;\r\neth = (u8 *) skb_put(skb, pkt_len - 12 - 4 + 14 - snap);\r\nmemcpy(eth + 14, pkt + 12 + snap, pkt_len - 12 - 4 - snap);\r\neth[0]=pkt[0x0b];\r\neth[1]=pkt[0x0a];\r\neth[2]=pkt[0x09];\r\neth[3]=pkt[0x08];\r\neth[4]=pkt[0x04];\r\neth[5]=pkt[0x03];\r\neth[6]=eth[7]=eth[8]=eth[9]=eth[10]=eth[11]=0;\r\nif (snap) {\r\neth[12] = pkt[18];\r\neth[13] = pkt[19];\r\n} else {\r\nif (pkt[12] >> 4 == 6) {\r\neth[12] = 0x86;\r\neth[13] = 0xdd;\r\n} else {\r\neth[12] = 0x08;\r\neth[13] = 0x00;\r\n}\r\n}\r\nskb->protocol = dvb_net_eth_type_trans(skb, dev);\r\nstats->rx_packets++;\r\nstats->rx_bytes+=skb->len;\r\nnetif_rx(skb);\r\n}\r\nstatic int dvb_net_sec_callback(const u8 *buffer1, size_t buffer1_len,\r\nconst u8 *buffer2, size_t buffer2_len,\r\nstruct dmx_section_filter *filter)\r\n{\r\nstruct net_device *dev = filter->priv;\r\ndvb_net_sec (dev, buffer1, buffer1_len);\r\nreturn 0;\r\n}\r\nstatic int dvb_net_tx(struct sk_buff *skb, struct net_device *dev)\r\n{\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int dvb_net_filter_sec_set(struct net_device *dev,\r\nstruct dmx_section_filter **secfilter,\r\nu8 *mac, u8 *mac_mask)\r\n{\r\nstruct dvb_net_priv *priv = netdev_priv(dev);\r\nint ret;\r\n*secfilter=NULL;\r\nret = priv->secfeed->allocate_filter(priv->secfeed, secfilter);\r\nif (ret<0) {\r\npr_err("%s: could not get filter\n", dev->name);\r\nreturn ret;\r\n}\r\n(*secfilter)->priv=(void *) dev;\r\nmemset((*secfilter)->filter_value, 0x00, DMX_MAX_FILTER_SIZE);\r\nmemset((*secfilter)->filter_mask, 0x00, DMX_MAX_FILTER_SIZE);\r\nmemset((*secfilter)->filter_mode, 0xff, DMX_MAX_FILTER_SIZE);\r\n(*secfilter)->filter_value[0]=0x3e;\r\n(*secfilter)->filter_value[3]=mac[5];\r\n(*secfilter)->filter_value[4]=mac[4];\r\n(*secfilter)->filter_value[8]=mac[3];\r\n(*secfilter)->filter_value[9]=mac[2];\r\n(*secfilter)->filter_value[10]=mac[1];\r\n(*secfilter)->filter_value[11]=mac[0];\r\n(*secfilter)->filter_mask[0] = 0xff;\r\n(*secfilter)->filter_mask[3] = mac_mask[5];\r\n(*secfilter)->filter_mask[4] = mac_mask[4];\r\n(*secfilter)->filter_mask[8] = mac_mask[3];\r\n(*secfilter)->filter_mask[9] = mac_mask[2];\r\n(*secfilter)->filter_mask[10] = mac_mask[1];\r\n(*secfilter)->filter_mask[11]=mac_mask[0];\r\nnetdev_dbg(dev, "filter mac=%pM mask=%pM\n", mac, mac_mask);\r\nreturn 0;\r\n}\r\nstatic int dvb_net_feed_start(struct net_device *dev)\r\n{\r\nint ret = 0, i;\r\nstruct dvb_net_priv *priv = netdev_priv(dev);\r\nstruct dmx_demux *demux = priv->demux;\r\nunsigned char *mac = (unsigned char *) dev->dev_addr;\r\nnetdev_dbg(dev, "rx_mode %i\n", priv->rx_mode);\r\nmutex_lock(&priv->mutex);\r\nif (priv->tsfeed || priv->secfeed || priv->secfilter || priv->multi_secfilter[0])\r\npr_err("%s: BUG %d\n", __func__, __LINE__);\r\npriv->secfeed=NULL;\r\npriv->secfilter=NULL;\r\npriv->tsfeed = NULL;\r\nif (priv->feedtype == DVB_NET_FEEDTYPE_MPE) {\r\nnetdev_dbg(dev, "alloc secfeed\n");\r\nret=demux->allocate_section_feed(demux, &priv->secfeed,\r\ndvb_net_sec_callback);\r\nif (ret<0) {\r\npr_err("%s: could not allocate section feed\n",\r\ndev->name);\r\ngoto error;\r\n}\r\nret = priv->secfeed->set(priv->secfeed, priv->pid, 1);\r\nif (ret<0) {\r\npr_err("%s: could not set section feed\n", dev->name);\r\npriv->demux->release_section_feed(priv->demux, priv->secfeed);\r\npriv->secfeed=NULL;\r\ngoto error;\r\n}\r\nif (priv->rx_mode != RX_MODE_PROMISC) {\r\nnetdev_dbg(dev, "set secfilter\n");\r\ndvb_net_filter_sec_set(dev, &priv->secfilter, mac, mask_normal);\r\n}\r\nswitch (priv->rx_mode) {\r\ncase RX_MODE_MULTI:\r\nfor (i = 0; i < priv->multi_num; i++) {\r\nnetdev_dbg(dev, "set multi_secfilter[%d]\n", i);\r\ndvb_net_filter_sec_set(dev, &priv->multi_secfilter[i],\r\npriv->multi_macs[i], mask_normal);\r\n}\r\nbreak;\r\ncase RX_MODE_ALL_MULTI:\r\npriv->multi_num=1;\r\nnetdev_dbg(dev, "set multi_secfilter[0]\n");\r\ndvb_net_filter_sec_set(dev, &priv->multi_secfilter[0],\r\nmac_allmulti, mask_allmulti);\r\nbreak;\r\ncase RX_MODE_PROMISC:\r\npriv->multi_num=0;\r\nnetdev_dbg(dev, "set secfilter\n");\r\ndvb_net_filter_sec_set(dev, &priv->secfilter, mac, mask_promisc);\r\nbreak;\r\n}\r\nnetdev_dbg(dev, "start filtering\n");\r\npriv->secfeed->start_filtering(priv->secfeed);\r\n} else if (priv->feedtype == DVB_NET_FEEDTYPE_ULE) {\r\nktime_t timeout = ns_to_ktime(10 * NSEC_PER_MSEC);\r\nnetdev_dbg(dev, "alloc tsfeed\n");\r\nret = demux->allocate_ts_feed(demux, &priv->tsfeed, dvb_net_ts_callback);\r\nif (ret < 0) {\r\npr_err("%s: could not allocate ts feed\n", dev->name);\r\ngoto error;\r\n}\r\npriv->tsfeed->priv = (void *)dev;\r\nret = priv->tsfeed->set(priv->tsfeed,\r\npriv->pid,\r\nTS_PACKET,\r\nDMX_PES_OTHER,\r\ntimeout\r\n);\r\nif (ret < 0) {\r\npr_err("%s: could not set ts feed\n", dev->name);\r\npriv->demux->release_ts_feed(priv->demux, priv->tsfeed);\r\npriv->tsfeed = NULL;\r\ngoto error;\r\n}\r\nnetdev_dbg(dev, "start filtering\n");\r\npriv->tsfeed->start_filtering(priv->tsfeed);\r\n} else\r\nret = -EINVAL;\r\nerror:\r\nmutex_unlock(&priv->mutex);\r\nreturn ret;\r\n}\r\nstatic int dvb_net_feed_stop(struct net_device *dev)\r\n{\r\nstruct dvb_net_priv *priv = netdev_priv(dev);\r\nint i, ret = 0;\r\nmutex_lock(&priv->mutex);\r\nif (priv->feedtype == DVB_NET_FEEDTYPE_MPE) {\r\nif (priv->secfeed) {\r\nif (priv->secfeed->is_filtering) {\r\nnetdev_dbg(dev, "stop secfeed\n");\r\npriv->secfeed->stop_filtering(priv->secfeed);\r\n}\r\nif (priv->secfilter) {\r\nnetdev_dbg(dev, "release secfilter\n");\r\npriv->secfeed->release_filter(priv->secfeed,\r\npriv->secfilter);\r\npriv->secfilter=NULL;\r\n}\r\nfor (i=0; i<priv->multi_num; i++) {\r\nif (priv->multi_secfilter[i]) {\r\nnetdev_dbg(dev, "release multi_filter[%d]\n",\r\ni);\r\npriv->secfeed->release_filter(priv->secfeed,\r\npriv->multi_secfilter[i]);\r\npriv->multi_secfilter[i] = NULL;\r\n}\r\n}\r\npriv->demux->release_section_feed(priv->demux, priv->secfeed);\r\npriv->secfeed = NULL;\r\n} else\r\npr_err("%s: no feed to stop\n", dev->name);\r\n} else if (priv->feedtype == DVB_NET_FEEDTYPE_ULE) {\r\nif (priv->tsfeed) {\r\nif (priv->tsfeed->is_filtering) {\r\nnetdev_dbg(dev, "stop tsfeed\n");\r\npriv->tsfeed->stop_filtering(priv->tsfeed);\r\n}\r\npriv->demux->release_ts_feed(priv->demux, priv->tsfeed);\r\npriv->tsfeed = NULL;\r\n}\r\nelse\r\npr_err("%s: no ts feed to stop\n", dev->name);\r\n} else\r\nret = -EINVAL;\r\nmutex_unlock(&priv->mutex);\r\nreturn ret;\r\n}\r\nstatic int dvb_set_mc_filter(struct net_device *dev, unsigned char *addr)\r\n{\r\nstruct dvb_net_priv *priv = netdev_priv(dev);\r\nif (priv->multi_num == DVB_NET_MULTICAST_MAX)\r\nreturn -ENOMEM;\r\nmemcpy(priv->multi_macs[priv->multi_num], addr, ETH_ALEN);\r\npriv->multi_num++;\r\nreturn 0;\r\n}\r\nstatic void wq_set_multicast_list (struct work_struct *work)\r\n{\r\nstruct dvb_net_priv *priv =\r\ncontainer_of(work, struct dvb_net_priv, set_multicast_list_wq);\r\nstruct net_device *dev = priv->net;\r\ndvb_net_feed_stop(dev);\r\npriv->rx_mode = RX_MODE_UNI;\r\nnetif_addr_lock_bh(dev);\r\nif (dev->flags & IFF_PROMISC) {\r\nnetdev_dbg(dev, "promiscuous mode\n");\r\npriv->rx_mode = RX_MODE_PROMISC;\r\n} else if ((dev->flags & IFF_ALLMULTI)) {\r\nnetdev_dbg(dev, "allmulti mode\n");\r\npriv->rx_mode = RX_MODE_ALL_MULTI;\r\n} else if (!netdev_mc_empty(dev)) {\r\nstruct netdev_hw_addr *ha;\r\nnetdev_dbg(dev, "set_mc_list, %d entries\n",\r\nnetdev_mc_count(dev));\r\npriv->rx_mode = RX_MODE_MULTI;\r\npriv->multi_num = 0;\r\nnetdev_for_each_mc_addr(ha, dev)\r\ndvb_set_mc_filter(dev, ha->addr);\r\n}\r\nnetif_addr_unlock_bh(dev);\r\ndvb_net_feed_start(dev);\r\n}\r\nstatic void dvb_net_set_multicast_list (struct net_device *dev)\r\n{\r\nstruct dvb_net_priv *priv = netdev_priv(dev);\r\nschedule_work(&priv->set_multicast_list_wq);\r\n}\r\nstatic void wq_restart_net_feed (struct work_struct *work)\r\n{\r\nstruct dvb_net_priv *priv =\r\ncontainer_of(work, struct dvb_net_priv, restart_net_feed_wq);\r\nstruct net_device *dev = priv->net;\r\nif (netif_running(dev)) {\r\ndvb_net_feed_stop(dev);\r\ndvb_net_feed_start(dev);\r\n}\r\n}\r\nstatic int dvb_net_set_mac (struct net_device *dev, void *p)\r\n{\r\nstruct dvb_net_priv *priv = netdev_priv(dev);\r\nstruct sockaddr *addr=p;\r\nmemcpy(dev->dev_addr, addr->sa_data, dev->addr_len);\r\nif (netif_running(dev))\r\nschedule_work(&priv->restart_net_feed_wq);\r\nreturn 0;\r\n}\r\nstatic int dvb_net_open(struct net_device *dev)\r\n{\r\nstruct dvb_net_priv *priv = netdev_priv(dev);\r\npriv->in_use++;\r\ndvb_net_feed_start(dev);\r\nreturn 0;\r\n}\r\nstatic int dvb_net_stop(struct net_device *dev)\r\n{\r\nstruct dvb_net_priv *priv = netdev_priv(dev);\r\npriv->in_use--;\r\nreturn dvb_net_feed_stop(dev);\r\n}\r\nstatic void dvb_net_setup(struct net_device *dev)\r\n{\r\nether_setup(dev);\r\ndev->header_ops = &dvb_header_ops;\r\ndev->netdev_ops = &dvb_netdev_ops;\r\ndev->mtu = 4096;\r\ndev->max_mtu = 4096;\r\ndev->flags |= IFF_NOARP;\r\n}\r\nstatic int get_if(struct dvb_net *dvbnet)\r\n{\r\nint i;\r\nfor (i=0; i<DVB_NET_DEVICES_MAX; i++)\r\nif (!dvbnet->state[i])\r\nbreak;\r\nif (i == DVB_NET_DEVICES_MAX)\r\nreturn -1;\r\ndvbnet->state[i]=1;\r\nreturn i;\r\n}\r\nstatic int dvb_net_add_if(struct dvb_net *dvbnet, u16 pid, u8 feedtype)\r\n{\r\nstruct net_device *net;\r\nstruct dvb_net_priv *priv;\r\nint result;\r\nint if_num;\r\nif (feedtype != DVB_NET_FEEDTYPE_MPE && feedtype != DVB_NET_FEEDTYPE_ULE)\r\nreturn -EINVAL;\r\nif ((if_num = get_if(dvbnet)) < 0)\r\nreturn -EINVAL;\r\nnet = alloc_netdev(sizeof(struct dvb_net_priv), "dvb",\r\nNET_NAME_UNKNOWN, dvb_net_setup);\r\nif (!net)\r\nreturn -ENOMEM;\r\nif (dvbnet->dvbdev->id)\r\nsnprintf(net->name, IFNAMSIZ, "dvb%d%u%d",\r\ndvbnet->dvbdev->adapter->num, dvbnet->dvbdev->id, if_num);\r\nelse\r\nsnprintf(net->name, IFNAMSIZ, "dvb%d_%d",\r\ndvbnet->dvbdev->adapter->num, if_num);\r\nnet->addr_len = 6;\r\nmemcpy(net->dev_addr, dvbnet->dvbdev->adapter->proposed_mac, 6);\r\ndvbnet->device[if_num] = net;\r\npriv = netdev_priv(net);\r\npriv->net = net;\r\npriv->demux = dvbnet->demux;\r\npriv->pid = pid;\r\npriv->rx_mode = RX_MODE_UNI;\r\npriv->need_pusi = 1;\r\npriv->tscc = 0;\r\npriv->feedtype = feedtype;\r\nreset_ule(priv);\r\nINIT_WORK(&priv->set_multicast_list_wq, wq_set_multicast_list);\r\nINIT_WORK(&priv->restart_net_feed_wq, wq_restart_net_feed);\r\nmutex_init(&priv->mutex);\r\nnet->base_addr = pid;\r\nif ((result = register_netdev(net)) < 0) {\r\ndvbnet->device[if_num] = NULL;\r\nfree_netdev(net);\r\nreturn result;\r\n}\r\npr_info("created network interface %s\n", net->name);\r\nreturn if_num;\r\n}\r\nstatic int dvb_net_remove_if(struct dvb_net *dvbnet, unsigned long num)\r\n{\r\nstruct net_device *net = dvbnet->device[num];\r\nstruct dvb_net_priv *priv;\r\nif (!dvbnet->state[num])\r\nreturn -EINVAL;\r\npriv = netdev_priv(net);\r\nif (priv->in_use)\r\nreturn -EBUSY;\r\ndvb_net_stop(net);\r\nflush_work(&priv->set_multicast_list_wq);\r\nflush_work(&priv->restart_net_feed_wq);\r\npr_info("removed network interface %s\n", net->name);\r\nunregister_netdev(net);\r\ndvbnet->state[num]=0;\r\ndvbnet->device[num] = NULL;\r\nfree_netdev(net);\r\nreturn 0;\r\n}\r\nstatic int dvb_net_do_ioctl(struct file *file,\r\nunsigned int cmd, void *parg)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct dvb_net *dvbnet = dvbdev->priv;\r\nint ret = 0;\r\nif (((file->f_flags&O_ACCMODE)==O_RDONLY))\r\nreturn -EPERM;\r\nif (mutex_lock_interruptible(&dvbnet->ioctl_mutex))\r\nreturn -ERESTARTSYS;\r\nswitch (cmd) {\r\ncase NET_ADD_IF:\r\n{\r\nstruct dvb_net_if *dvbnetif = parg;\r\nint result;\r\nif (!capable(CAP_SYS_ADMIN)) {\r\nret = -EPERM;\r\ngoto ioctl_error;\r\n}\r\nif (!try_module_get(dvbdev->adapter->module)) {\r\nret = -EPERM;\r\ngoto ioctl_error;\r\n}\r\nresult=dvb_net_add_if(dvbnet, dvbnetif->pid, dvbnetif->feedtype);\r\nif (result<0) {\r\nmodule_put(dvbdev->adapter->module);\r\nret = result;\r\ngoto ioctl_error;\r\n}\r\ndvbnetif->if_num=result;\r\nbreak;\r\n}\r\ncase NET_GET_IF:\r\n{\r\nstruct net_device *netdev;\r\nstruct dvb_net_priv *priv_data;\r\nstruct dvb_net_if *dvbnetif = parg;\r\nif (dvbnetif->if_num >= DVB_NET_DEVICES_MAX ||\r\n!dvbnet->state[dvbnetif->if_num]) {\r\nret = -EINVAL;\r\ngoto ioctl_error;\r\n}\r\nnetdev = dvbnet->device[dvbnetif->if_num];\r\npriv_data = netdev_priv(netdev);\r\ndvbnetif->pid=priv_data->pid;\r\ndvbnetif->feedtype=priv_data->feedtype;\r\nbreak;\r\n}\r\ncase NET_REMOVE_IF:\r\n{\r\nif (!capable(CAP_SYS_ADMIN)) {\r\nret = -EPERM;\r\ngoto ioctl_error;\r\n}\r\nif ((unsigned long) parg >= DVB_NET_DEVICES_MAX) {\r\nret = -EINVAL;\r\ngoto ioctl_error;\r\n}\r\nret = dvb_net_remove_if(dvbnet, (unsigned long) parg);\r\nif (!ret)\r\nmodule_put(dvbdev->adapter->module);\r\nbreak;\r\n}\r\ncase __NET_ADD_IF_OLD:\r\n{\r\nstruct __dvb_net_if_old *dvbnetif = parg;\r\nint result;\r\nif (!capable(CAP_SYS_ADMIN)) {\r\nret = -EPERM;\r\ngoto ioctl_error;\r\n}\r\nif (!try_module_get(dvbdev->adapter->module)) {\r\nret = -EPERM;\r\ngoto ioctl_error;\r\n}\r\nresult=dvb_net_add_if(dvbnet, dvbnetif->pid, DVB_NET_FEEDTYPE_MPE);\r\nif (result<0) {\r\nmodule_put(dvbdev->adapter->module);\r\nret = result;\r\ngoto ioctl_error;\r\n}\r\ndvbnetif->if_num=result;\r\nbreak;\r\n}\r\ncase __NET_GET_IF_OLD:\r\n{\r\nstruct net_device *netdev;\r\nstruct dvb_net_priv *priv_data;\r\nstruct __dvb_net_if_old *dvbnetif = parg;\r\nif (dvbnetif->if_num >= DVB_NET_DEVICES_MAX ||\r\n!dvbnet->state[dvbnetif->if_num]) {\r\nret = -EINVAL;\r\ngoto ioctl_error;\r\n}\r\nnetdev = dvbnet->device[dvbnetif->if_num];\r\npriv_data = netdev_priv(netdev);\r\ndvbnetif->pid=priv_data->pid;\r\nbreak;\r\n}\r\ndefault:\r\nret = -ENOTTY;\r\nbreak;\r\n}\r\nioctl_error:\r\nmutex_unlock(&dvbnet->ioctl_mutex);\r\nreturn ret;\r\n}\r\nstatic long dvb_net_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nreturn dvb_usercopy(file, cmd, arg, dvb_net_do_ioctl);\r\n}\r\nstatic int dvb_net_close(struct inode *inode, struct file *file)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct dvb_net *dvbnet = dvbdev->priv;\r\ndvb_generic_release(inode, file);\r\nif(dvbdev->users == 1 && dvbnet->exit == 1)\r\nwake_up(&dvbdev->wait_queue);\r\nreturn 0;\r\n}\r\nvoid dvb_net_release (struct dvb_net *dvbnet)\r\n{\r\nint i;\r\ndvbnet->exit = 1;\r\nif (dvbnet->dvbdev->users < 1)\r\nwait_event(dvbnet->dvbdev->wait_queue,\r\ndvbnet->dvbdev->users==1);\r\ndvb_unregister_device(dvbnet->dvbdev);\r\nfor (i=0; i<DVB_NET_DEVICES_MAX; i++) {\r\nif (!dvbnet->state[i])\r\ncontinue;\r\ndvb_net_remove_if(dvbnet, i);\r\n}\r\n}\r\nint dvb_net_init (struct dvb_adapter *adap, struct dvb_net *dvbnet,\r\nstruct dmx_demux *dmx)\r\n{\r\nint i;\r\nmutex_init(&dvbnet->ioctl_mutex);\r\ndvbnet->demux = dmx;\r\nfor (i=0; i<DVB_NET_DEVICES_MAX; i++)\r\ndvbnet->state[i] = 0;\r\nreturn dvb_register_device(adap, &dvbnet->dvbdev, &dvbdev_net,\r\ndvbnet, DVB_DEVICE_NET, 0);\r\n}
