static int\r\nsupported_gss_krb5_enctype(int etype)\r\n{\r\nint i;\r\nfor (i = 0; i < num_supported_enctypes; i++)\r\nif (supported_gss_krb5_enctypes[i].etype == etype)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic const struct gss_krb5_enctype *\r\nget_gss_krb5_enctype(int etype)\r\n{\r\nint i;\r\nfor (i = 0; i < num_supported_enctypes; i++)\r\nif (supported_gss_krb5_enctypes[i].etype == etype)\r\nreturn &supported_gss_krb5_enctypes[i];\r\nreturn NULL;\r\n}\r\nstatic const void *\r\nsimple_get_bytes(const void *p, const void *end, void *res, int len)\r\n{\r\nconst void *q = (const void *)((const char *)p + len);\r\nif (unlikely(q > end || q < p))\r\nreturn ERR_PTR(-EFAULT);\r\nmemcpy(res, p, len);\r\nreturn q;\r\n}\r\nstatic const void *\r\nsimple_get_netobj(const void *p, const void *end, struct xdr_netobj *res)\r\n{\r\nconst void *q;\r\nunsigned int len;\r\np = simple_get_bytes(p, end, &len, sizeof(len));\r\nif (IS_ERR(p))\r\nreturn p;\r\nq = (const void *)((const char *)p + len);\r\nif (unlikely(q > end || q < p))\r\nreturn ERR_PTR(-EFAULT);\r\nres->data = kmemdup(p, len, GFP_NOFS);\r\nif (unlikely(res->data == NULL))\r\nreturn ERR_PTR(-ENOMEM);\r\nres->len = len;\r\nreturn q;\r\n}\r\nstatic inline const void *\r\nget_key(const void *p, const void *end,\r\nstruct krb5_ctx *ctx, struct crypto_skcipher **res)\r\n{\r\nstruct xdr_netobj key;\r\nint alg;\r\np = simple_get_bytes(p, end, &alg, sizeof(alg));\r\nif (IS_ERR(p))\r\ngoto out_err;\r\nswitch (alg) {\r\ncase ENCTYPE_DES_CBC_CRC:\r\ncase ENCTYPE_DES_CBC_MD4:\r\ncase ENCTYPE_DES_CBC_MD5:\r\nalg = ENCTYPE_DES_CBC_RAW;\r\nbreak;\r\n}\r\nif (!supported_gss_krb5_enctype(alg)) {\r\nprintk(KERN_WARNING "gss_kerberos_mech: unsupported "\r\n"encryption key algorithm %d\n", alg);\r\np = ERR_PTR(-EINVAL);\r\ngoto out_err;\r\n}\r\np = simple_get_netobj(p, end, &key);\r\nif (IS_ERR(p))\r\ngoto out_err;\r\n*res = crypto_alloc_skcipher(ctx->gk5e->encrypt_name, 0,\r\nCRYPTO_ALG_ASYNC);\r\nif (IS_ERR(*res)) {\r\nprintk(KERN_WARNING "gss_kerberos_mech: unable to initialize "\r\n"crypto algorithm %s\n", ctx->gk5e->encrypt_name);\r\n*res = NULL;\r\ngoto out_err_free_key;\r\n}\r\nif (crypto_skcipher_setkey(*res, key.data, key.len)) {\r\nprintk(KERN_WARNING "gss_kerberos_mech: error setting key for "\r\n"crypto algorithm %s\n", ctx->gk5e->encrypt_name);\r\ngoto out_err_free_tfm;\r\n}\r\nkfree(key.data);\r\nreturn p;\r\nout_err_free_tfm:\r\ncrypto_free_skcipher(*res);\r\nout_err_free_key:\r\nkfree(key.data);\r\np = ERR_PTR(-EINVAL);\r\nout_err:\r\nreturn p;\r\n}\r\nstatic int\r\ngss_import_v1_context(const void *p, const void *end, struct krb5_ctx *ctx)\r\n{\r\nint tmp;\r\np = simple_get_bytes(p, end, &ctx->initiate, sizeof(ctx->initiate));\r\nif (IS_ERR(p))\r\ngoto out_err;\r\nctx->enctype = ENCTYPE_DES_CBC_RAW;\r\nctx->gk5e = get_gss_krb5_enctype(ctx->enctype);\r\nif (ctx->gk5e == NULL) {\r\np = ERR_PTR(-EINVAL);\r\ngoto out_err;\r\n}\r\nif (unlikely(p + 20 > end || p + 20 < p)) {\r\np = ERR_PTR(-EFAULT);\r\ngoto out_err;\r\n}\r\np += 20;\r\np = simple_get_bytes(p, end, &tmp, sizeof(tmp));\r\nif (IS_ERR(p))\r\ngoto out_err;\r\nif (tmp != SGN_ALG_DES_MAC_MD5) {\r\np = ERR_PTR(-ENOSYS);\r\ngoto out_err;\r\n}\r\np = simple_get_bytes(p, end, &tmp, sizeof(tmp));\r\nif (IS_ERR(p))\r\ngoto out_err;\r\nif (tmp != SEAL_ALG_DES) {\r\np = ERR_PTR(-ENOSYS);\r\ngoto out_err;\r\n}\r\np = simple_get_bytes(p, end, &ctx->endtime, sizeof(ctx->endtime));\r\nif (IS_ERR(p))\r\ngoto out_err;\r\np = simple_get_bytes(p, end, &ctx->seq_send, sizeof(ctx->seq_send));\r\nif (IS_ERR(p))\r\ngoto out_err;\r\np = simple_get_netobj(p, end, &ctx->mech_used);\r\nif (IS_ERR(p))\r\ngoto out_err;\r\np = get_key(p, end, ctx, &ctx->enc);\r\nif (IS_ERR(p))\r\ngoto out_err_free_mech;\r\np = get_key(p, end, ctx, &ctx->seq);\r\nif (IS_ERR(p))\r\ngoto out_err_free_key1;\r\nif (p != end) {\r\np = ERR_PTR(-EFAULT);\r\ngoto out_err_free_key2;\r\n}\r\nreturn 0;\r\nout_err_free_key2:\r\ncrypto_free_skcipher(ctx->seq);\r\nout_err_free_key1:\r\ncrypto_free_skcipher(ctx->enc);\r\nout_err_free_mech:\r\nkfree(ctx->mech_used.data);\r\nout_err:\r\nreturn PTR_ERR(p);\r\n}\r\nstatic struct crypto_skcipher *\r\ncontext_v2_alloc_cipher(struct krb5_ctx *ctx, const char *cname, u8 *key)\r\n{\r\nstruct crypto_skcipher *cp;\r\ncp = crypto_alloc_skcipher(cname, 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(cp)) {\r\ndprintk("gss_kerberos_mech: unable to initialize "\r\n"crypto algorithm %s\n", cname);\r\nreturn NULL;\r\n}\r\nif (crypto_skcipher_setkey(cp, key, ctx->gk5e->keylength)) {\r\ndprintk("gss_kerberos_mech: error setting key for "\r\n"crypto algorithm %s\n", cname);\r\ncrypto_free_skcipher(cp);\r\nreturn NULL;\r\n}\r\nreturn cp;\r\n}\r\nstatic inline void\r\nset_cdata(u8 cdata[GSS_KRB5_K5CLENGTH], u32 usage, u8 seed)\r\n{\r\ncdata[0] = (usage>>24)&0xff;\r\ncdata[1] = (usage>>16)&0xff;\r\ncdata[2] = (usage>>8)&0xff;\r\ncdata[3] = usage&0xff;\r\ncdata[4] = seed;\r\n}\r\nstatic int\r\ncontext_derive_keys_des3(struct krb5_ctx *ctx, gfp_t gfp_mask)\r\n{\r\nstruct xdr_netobj c, keyin, keyout;\r\nu8 cdata[GSS_KRB5_K5CLENGTH];\r\nu32 err;\r\nc.len = GSS_KRB5_K5CLENGTH;\r\nc.data = cdata;\r\nkeyin.data = ctx->Ksess;\r\nkeyin.len = ctx->gk5e->keylength;\r\nkeyout.len = ctx->gk5e->keylength;\r\nctx->seq = context_v2_alloc_cipher(ctx, ctx->gk5e->encrypt_name,\r\nctx->Ksess);\r\nif (ctx->seq == NULL)\r\ngoto out_err;\r\nctx->enc = context_v2_alloc_cipher(ctx, ctx->gk5e->encrypt_name,\r\nctx->Ksess);\r\nif (ctx->enc == NULL)\r\ngoto out_free_seq;\r\nset_cdata(cdata, KG_USAGE_SIGN, KEY_USAGE_SEED_CHECKSUM);\r\nkeyout.data = ctx->cksum;\r\nerr = krb5_derive_key(ctx->gk5e, &keyin, &keyout, &c, gfp_mask);\r\nif (err) {\r\ndprintk("%s: Error %d deriving cksum key\n",\r\n__func__, err);\r\ngoto out_free_enc;\r\n}\r\nreturn 0;\r\nout_free_enc:\r\ncrypto_free_skcipher(ctx->enc);\r\nout_free_seq:\r\ncrypto_free_skcipher(ctx->seq);\r\nout_err:\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\ncontext_derive_keys_rc4(struct krb5_ctx *ctx)\r\n{\r\nstruct crypto_shash *hmac;\r\nchar sigkeyconstant[] = "signaturekey";\r\nint slen = strlen(sigkeyconstant) + 1;\r\nstruct shash_desc *desc;\r\nint err;\r\ndprintk("RPC: %s: entered\n", __func__);\r\nhmac = crypto_alloc_shash(ctx->gk5e->cksum_name, 0, 0);\r\nif (IS_ERR(hmac)) {\r\ndprintk("%s: error %ld allocating hash '%s'\n",\r\n__func__, PTR_ERR(hmac), ctx->gk5e->cksum_name);\r\nerr = PTR_ERR(hmac);\r\ngoto out_err;\r\n}\r\nerr = crypto_shash_setkey(hmac, ctx->Ksess, ctx->gk5e->keylength);\r\nif (err)\r\ngoto out_err_free_hmac;\r\ndesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(hmac), GFP_NOFS);\r\nif (!desc) {\r\ndprintk("%s: failed to allocate hash descriptor for '%s'\n",\r\n__func__, ctx->gk5e->cksum_name);\r\nerr = -ENOMEM;\r\ngoto out_err_free_hmac;\r\n}\r\ndesc->tfm = hmac;\r\ndesc->flags = 0;\r\nerr = crypto_shash_digest(desc, sigkeyconstant, slen, ctx->cksum);\r\nkzfree(desc);\r\nif (err)\r\ngoto out_err_free_hmac;\r\nctx->enc = crypto_alloc_skcipher(ctx->gk5e->encrypt_name, 0,\r\nCRYPTO_ALG_ASYNC);\r\nif (IS_ERR(ctx->enc)) {\r\nerr = PTR_ERR(ctx->enc);\r\ngoto out_err_free_hmac;\r\n}\r\nctx->seq = crypto_alloc_skcipher(ctx->gk5e->encrypt_name, 0,\r\nCRYPTO_ALG_ASYNC);\r\nif (IS_ERR(ctx->seq)) {\r\ncrypto_free_skcipher(ctx->enc);\r\nerr = PTR_ERR(ctx->seq);\r\ngoto out_err_free_hmac;\r\n}\r\ndprintk("RPC: %s: returning success\n", __func__);\r\nerr = 0;\r\nout_err_free_hmac:\r\ncrypto_free_shash(hmac);\r\nout_err:\r\ndprintk("RPC: %s: returning %d\n", __func__, err);\r\nreturn err;\r\n}\r\nstatic int\r\ncontext_derive_keys_new(struct krb5_ctx *ctx, gfp_t gfp_mask)\r\n{\r\nstruct xdr_netobj c, keyin, keyout;\r\nu8 cdata[GSS_KRB5_K5CLENGTH];\r\nu32 err;\r\nc.len = GSS_KRB5_K5CLENGTH;\r\nc.data = cdata;\r\nkeyin.data = ctx->Ksess;\r\nkeyin.len = ctx->gk5e->keylength;\r\nkeyout.len = ctx->gk5e->keylength;\r\nset_cdata(cdata, KG_USAGE_INITIATOR_SEAL, KEY_USAGE_SEED_ENCRYPTION);\r\nkeyout.data = ctx->initiator_seal;\r\nerr = krb5_derive_key(ctx->gk5e, &keyin, &keyout, &c, gfp_mask);\r\nif (err) {\r\ndprintk("%s: Error %d deriving initiator_seal key\n",\r\n__func__, err);\r\ngoto out_err;\r\n}\r\nctx->initiator_enc = context_v2_alloc_cipher(ctx,\r\nctx->gk5e->encrypt_name,\r\nctx->initiator_seal);\r\nif (ctx->initiator_enc == NULL)\r\ngoto out_err;\r\nset_cdata(cdata, KG_USAGE_ACCEPTOR_SEAL, KEY_USAGE_SEED_ENCRYPTION);\r\nkeyout.data = ctx->acceptor_seal;\r\nerr = krb5_derive_key(ctx->gk5e, &keyin, &keyout, &c, gfp_mask);\r\nif (err) {\r\ndprintk("%s: Error %d deriving acceptor_seal key\n",\r\n__func__, err);\r\ngoto out_free_initiator_enc;\r\n}\r\nctx->acceptor_enc = context_v2_alloc_cipher(ctx,\r\nctx->gk5e->encrypt_name,\r\nctx->acceptor_seal);\r\nif (ctx->acceptor_enc == NULL)\r\ngoto out_free_initiator_enc;\r\nset_cdata(cdata, KG_USAGE_INITIATOR_SIGN, KEY_USAGE_SEED_CHECKSUM);\r\nkeyout.data = ctx->initiator_sign;\r\nerr = krb5_derive_key(ctx->gk5e, &keyin, &keyout, &c, gfp_mask);\r\nif (err) {\r\ndprintk("%s: Error %d deriving initiator_sign key\n",\r\n__func__, err);\r\ngoto out_free_acceptor_enc;\r\n}\r\nset_cdata(cdata, KG_USAGE_ACCEPTOR_SIGN, KEY_USAGE_SEED_CHECKSUM);\r\nkeyout.data = ctx->acceptor_sign;\r\nerr = krb5_derive_key(ctx->gk5e, &keyin, &keyout, &c, gfp_mask);\r\nif (err) {\r\ndprintk("%s: Error %d deriving acceptor_sign key\n",\r\n__func__, err);\r\ngoto out_free_acceptor_enc;\r\n}\r\nset_cdata(cdata, KG_USAGE_INITIATOR_SEAL, KEY_USAGE_SEED_INTEGRITY);\r\nkeyout.data = ctx->initiator_integ;\r\nerr = krb5_derive_key(ctx->gk5e, &keyin, &keyout, &c, gfp_mask);\r\nif (err) {\r\ndprintk("%s: Error %d deriving initiator_integ key\n",\r\n__func__, err);\r\ngoto out_free_acceptor_enc;\r\n}\r\nset_cdata(cdata, KG_USAGE_ACCEPTOR_SEAL, KEY_USAGE_SEED_INTEGRITY);\r\nkeyout.data = ctx->acceptor_integ;\r\nerr = krb5_derive_key(ctx->gk5e, &keyin, &keyout, &c, gfp_mask);\r\nif (err) {\r\ndprintk("%s: Error %d deriving acceptor_integ key\n",\r\n__func__, err);\r\ngoto out_free_acceptor_enc;\r\n}\r\nswitch (ctx->enctype) {\r\ncase ENCTYPE_AES128_CTS_HMAC_SHA1_96:\r\ncase ENCTYPE_AES256_CTS_HMAC_SHA1_96:\r\nctx->initiator_enc_aux =\r\ncontext_v2_alloc_cipher(ctx, "cbc(aes)",\r\nctx->initiator_seal);\r\nif (ctx->initiator_enc_aux == NULL)\r\ngoto out_free_acceptor_enc;\r\nctx->acceptor_enc_aux =\r\ncontext_v2_alloc_cipher(ctx, "cbc(aes)",\r\nctx->acceptor_seal);\r\nif (ctx->acceptor_enc_aux == NULL) {\r\ncrypto_free_skcipher(ctx->initiator_enc_aux);\r\ngoto out_free_acceptor_enc;\r\n}\r\n}\r\nreturn 0;\r\nout_free_acceptor_enc:\r\ncrypto_free_skcipher(ctx->acceptor_enc);\r\nout_free_initiator_enc:\r\ncrypto_free_skcipher(ctx->initiator_enc);\r\nout_err:\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\ngss_import_v2_context(const void *p, const void *end, struct krb5_ctx *ctx,\r\ngfp_t gfp_mask)\r\n{\r\nint keylen;\r\np = simple_get_bytes(p, end, &ctx->flags, sizeof(ctx->flags));\r\nif (IS_ERR(p))\r\ngoto out_err;\r\nctx->initiate = ctx->flags & KRB5_CTX_FLAG_INITIATOR;\r\np = simple_get_bytes(p, end, &ctx->endtime, sizeof(ctx->endtime));\r\nif (IS_ERR(p))\r\ngoto out_err;\r\np = simple_get_bytes(p, end, &ctx->seq_send64, sizeof(ctx->seq_send64));\r\nif (IS_ERR(p))\r\ngoto out_err;\r\nctx->seq_send = ctx->seq_send64;\r\nif (ctx->seq_send64 != ctx->seq_send) {\r\ndprintk("%s: seq_send64 %lx, seq_send %x overflow?\n", __func__,\r\n(unsigned long)ctx->seq_send64, ctx->seq_send);\r\np = ERR_PTR(-EINVAL);\r\ngoto out_err;\r\n}\r\np = simple_get_bytes(p, end, &ctx->enctype, sizeof(ctx->enctype));\r\nif (IS_ERR(p))\r\ngoto out_err;\r\nif (ctx->enctype == ENCTYPE_DES3_CBC_SHA1)\r\nctx->enctype = ENCTYPE_DES3_CBC_RAW;\r\nctx->gk5e = get_gss_krb5_enctype(ctx->enctype);\r\nif (ctx->gk5e == NULL) {\r\ndprintk("gss_kerberos_mech: unsupported krb5 enctype %u\n",\r\nctx->enctype);\r\np = ERR_PTR(-EINVAL);\r\ngoto out_err;\r\n}\r\nkeylen = ctx->gk5e->keylength;\r\np = simple_get_bytes(p, end, ctx->Ksess, keylen);\r\nif (IS_ERR(p))\r\ngoto out_err;\r\nif (p != end) {\r\np = ERR_PTR(-EINVAL);\r\ngoto out_err;\r\n}\r\nctx->mech_used.data = kmemdup(gss_kerberos_mech.gm_oid.data,\r\ngss_kerberos_mech.gm_oid.len, gfp_mask);\r\nif (unlikely(ctx->mech_used.data == NULL)) {\r\np = ERR_PTR(-ENOMEM);\r\ngoto out_err;\r\n}\r\nctx->mech_used.len = gss_kerberos_mech.gm_oid.len;\r\nswitch (ctx->enctype) {\r\ncase ENCTYPE_DES3_CBC_RAW:\r\nreturn context_derive_keys_des3(ctx, gfp_mask);\r\ncase ENCTYPE_ARCFOUR_HMAC:\r\nreturn context_derive_keys_rc4(ctx);\r\ncase ENCTYPE_AES128_CTS_HMAC_SHA1_96:\r\ncase ENCTYPE_AES256_CTS_HMAC_SHA1_96:\r\nreturn context_derive_keys_new(ctx, gfp_mask);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nout_err:\r\nreturn PTR_ERR(p);\r\n}\r\nstatic int\r\ngss_import_sec_context_kerberos(const void *p, size_t len,\r\nstruct gss_ctx *ctx_id,\r\ntime_t *endtime,\r\ngfp_t gfp_mask)\r\n{\r\nconst void *end = (const void *)((const char *)p + len);\r\nstruct krb5_ctx *ctx;\r\nint ret;\r\nctx = kzalloc(sizeof(*ctx), gfp_mask);\r\nif (ctx == NULL)\r\nreturn -ENOMEM;\r\nif (len == 85)\r\nret = gss_import_v1_context(p, end, ctx);\r\nelse\r\nret = gss_import_v2_context(p, end, ctx, gfp_mask);\r\nif (ret == 0) {\r\nctx_id->internal_ctx_id = ctx;\r\nif (endtime)\r\n*endtime = ctx->endtime;\r\n} else\r\nkfree(ctx);\r\ndprintk("RPC: %s: returning %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic void\r\ngss_delete_sec_context_kerberos(void *internal_ctx) {\r\nstruct krb5_ctx *kctx = internal_ctx;\r\ncrypto_free_skcipher(kctx->seq);\r\ncrypto_free_skcipher(kctx->enc);\r\ncrypto_free_skcipher(kctx->acceptor_enc);\r\ncrypto_free_skcipher(kctx->initiator_enc);\r\ncrypto_free_skcipher(kctx->acceptor_enc_aux);\r\ncrypto_free_skcipher(kctx->initiator_enc_aux);\r\nkfree(kctx->mech_used.data);\r\nkfree(kctx);\r\n}\r\nstatic int __init init_kerberos_module(void)\r\n{\r\nint status;\r\nstatus = gss_mech_register(&gss_kerberos_mech);\r\nif (status)\r\nprintk("Failed to register kerberos gss mechanism!\n");\r\nreturn status;\r\n}\r\nstatic void __exit cleanup_kerberos_module(void)\r\n{\r\ngss_mech_unregister(&gss_kerberos_mech);\r\n}
