static int msm_hsusb_init_vddcx(struct msm_otg *motg, int init)\r\n{\r\nint ret = 0;\r\nif (init) {\r\nret = regulator_set_voltage(motg->vddcx,\r\nmotg->vdd_levels[VDD_LEVEL_MIN],\r\nmotg->vdd_levels[VDD_LEVEL_MAX]);\r\nif (ret) {\r\ndev_err(motg->phy.dev, "Cannot set vddcx voltage\n");\r\nreturn ret;\r\n}\r\nret = regulator_enable(motg->vddcx);\r\nif (ret)\r\ndev_err(motg->phy.dev, "unable to enable hsusb vddcx\n");\r\n} else {\r\nret = regulator_set_voltage(motg->vddcx, 0,\r\nmotg->vdd_levels[VDD_LEVEL_MAX]);\r\nif (ret)\r\ndev_err(motg->phy.dev, "Cannot set vddcx voltage\n");\r\nret = regulator_disable(motg->vddcx);\r\nif (ret)\r\ndev_err(motg->phy.dev, "unable to disable hsusb vddcx\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic int msm_hsusb_ldo_init(struct msm_otg *motg, int init)\r\n{\r\nint rc = 0;\r\nif (init) {\r\nrc = regulator_set_voltage(motg->v3p3, USB_PHY_3P3_VOL_MIN,\r\nUSB_PHY_3P3_VOL_MAX);\r\nif (rc) {\r\ndev_err(motg->phy.dev, "Cannot set v3p3 voltage\n");\r\ngoto exit;\r\n}\r\nrc = regulator_enable(motg->v3p3);\r\nif (rc) {\r\ndev_err(motg->phy.dev, "unable to enable the hsusb 3p3\n");\r\ngoto exit;\r\n}\r\nrc = regulator_set_voltage(motg->v1p8, USB_PHY_1P8_VOL_MIN,\r\nUSB_PHY_1P8_VOL_MAX);\r\nif (rc) {\r\ndev_err(motg->phy.dev, "Cannot set v1p8 voltage\n");\r\ngoto disable_3p3;\r\n}\r\nrc = regulator_enable(motg->v1p8);\r\nif (rc) {\r\ndev_err(motg->phy.dev, "unable to enable the hsusb 1p8\n");\r\ngoto disable_3p3;\r\n}\r\nreturn 0;\r\n}\r\nregulator_disable(motg->v1p8);\r\ndisable_3p3:\r\nregulator_disable(motg->v3p3);\r\nexit:\r\nreturn rc;\r\n}\r\nstatic int msm_hsusb_ldo_set_mode(struct msm_otg *motg, int on)\r\n{\r\nint ret = 0;\r\nif (on) {\r\nret = regulator_set_load(motg->v1p8, USB_PHY_1P8_HPM_LOAD);\r\nif (ret < 0) {\r\npr_err("Could not set HPM for v1p8\n");\r\nreturn ret;\r\n}\r\nret = regulator_set_load(motg->v3p3, USB_PHY_3P3_HPM_LOAD);\r\nif (ret < 0) {\r\npr_err("Could not set HPM for v3p3\n");\r\nregulator_set_load(motg->v1p8, USB_PHY_1P8_LPM_LOAD);\r\nreturn ret;\r\n}\r\n} else {\r\nret = regulator_set_load(motg->v1p8, USB_PHY_1P8_LPM_LOAD);\r\nif (ret < 0)\r\npr_err("Could not set LPM for v1p8\n");\r\nret = regulator_set_load(motg->v3p3, USB_PHY_3P3_LPM_LOAD);\r\nif (ret < 0)\r\npr_err("Could not set LPM for v3p3\n");\r\n}\r\npr_debug("reg (%s)\n", on ? "HPM" : "LPM");\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nstatic int ulpi_read(struct usb_phy *phy, u32 reg)\r\n{\r\nstruct msm_otg *motg = container_of(phy, struct msm_otg, phy);\r\nint cnt = 0;\r\nwritel(ULPI_RUN | ULPI_READ | ULPI_ADDR(reg),\r\nUSB_ULPI_VIEWPORT);\r\nwhile (cnt < ULPI_IO_TIMEOUT_USEC) {\r\nif (!(readl(USB_ULPI_VIEWPORT) & ULPI_RUN))\r\nbreak;\r\nudelay(1);\r\ncnt++;\r\n}\r\nif (cnt >= ULPI_IO_TIMEOUT_USEC) {\r\ndev_err(phy->dev, "ulpi_read: timeout %08x\n",\r\nreadl(USB_ULPI_VIEWPORT));\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn ULPI_DATA_READ(readl(USB_ULPI_VIEWPORT));\r\n}\r\nstatic int ulpi_write(struct usb_phy *phy, u32 val, u32 reg)\r\n{\r\nstruct msm_otg *motg = container_of(phy, struct msm_otg, phy);\r\nint cnt = 0;\r\nwritel(ULPI_RUN | ULPI_WRITE |\r\nULPI_ADDR(reg) | ULPI_DATA(val),\r\nUSB_ULPI_VIEWPORT);\r\nwhile (cnt < ULPI_IO_TIMEOUT_USEC) {\r\nif (!(readl(USB_ULPI_VIEWPORT) & ULPI_RUN))\r\nbreak;\r\nudelay(1);\r\ncnt++;\r\n}\r\nif (cnt >= ULPI_IO_TIMEOUT_USEC) {\r\ndev_err(phy->dev, "ulpi_write: timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ulpi_init(struct msm_otg *motg)\r\n{\r\nstruct msm_otg_platform_data *pdata = motg->pdata;\r\nint *seq = pdata->phy_init_seq, idx;\r\nu32 addr = ULPI_EXT_VENDOR_SPECIFIC;\r\nfor (idx = 0; idx < pdata->phy_init_sz; idx++) {\r\nif (seq[idx] == -1)\r\ncontinue;\r\ndev_vdbg(motg->phy.dev, "ulpi: write 0x%02x to 0x%02x\n",\r\nseq[idx], addr + idx);\r\nulpi_write(&motg->phy, seq[idx], addr + idx);\r\n}\r\n}\r\nstatic int msm_phy_notify_disconnect(struct usb_phy *phy,\r\nenum usb_device_speed speed)\r\n{\r\nstruct msm_otg *motg = container_of(phy, struct msm_otg, phy);\r\nint val;\r\nif (motg->manual_pullup) {\r\nval = ULPI_MISC_A_VBUSVLDEXT | ULPI_MISC_A_VBUSVLDEXTSEL;\r\nusb_phy_io_write(phy, val, ULPI_CLR(ULPI_MISC_A));\r\n}\r\nval = ulpi_read(phy, ULPI_FUNC_CTRL);\r\nval &= ~ULPI_FUNC_CTRL_OPMODE_MASK;\r\nval |= ULPI_FUNC_CTRL_OPMODE_NONDRIVING;\r\nulpi_write(phy, val, ULPI_FUNC_CTRL);\r\nreturn 0;\r\n}\r\nstatic int msm_otg_link_clk_reset(struct msm_otg *motg, bool assert)\r\n{\r\nint ret;\r\nif (assert)\r\nret = reset_control_assert(motg->link_rst);\r\nelse\r\nret = reset_control_deassert(motg->link_rst);\r\nif (ret)\r\ndev_err(motg->phy.dev, "usb link clk reset %s failed\n",\r\nassert ? "assert" : "deassert");\r\nreturn ret;\r\n}\r\nstatic int msm_otg_phy_clk_reset(struct msm_otg *motg)\r\n{\r\nint ret = 0;\r\nif (motg->phy_rst)\r\nret = reset_control_reset(motg->phy_rst);\r\nif (ret)\r\ndev_err(motg->phy.dev, "usb phy clk reset failed\n");\r\nreturn ret;\r\n}\r\nstatic int msm_link_reset(struct msm_otg *motg)\r\n{\r\nu32 val;\r\nint ret;\r\nret = msm_otg_link_clk_reset(motg, 1);\r\nif (ret)\r\nreturn ret;\r\nusleep_range(1000, 1200);\r\nret = msm_otg_link_clk_reset(motg, 0);\r\nif (ret)\r\nreturn ret;\r\nif (motg->phy_number)\r\nwritel(readl(USB_PHY_CTRL2) | BIT(16), USB_PHY_CTRL2);\r\nval = readl(USB_PORTSC) & ~PORTSC_PTS_MASK;\r\nwritel(val | PORTSC_PTS_SERIAL, USB_PORTSC);\r\nreturn 0;\r\n}\r\nstatic int msm_otg_reset(struct usb_phy *phy)\r\n{\r\nstruct msm_otg *motg = container_of(phy, struct msm_otg, phy);\r\nint cnt = 0;\r\nwritel(USBCMD_RESET, USB_USBCMD);\r\nwhile (cnt < LINK_RESET_TIMEOUT_USEC) {\r\nif (!(readl(USB_USBCMD) & USBCMD_RESET))\r\nbreak;\r\nudelay(1);\r\ncnt++;\r\n}\r\nif (cnt >= LINK_RESET_TIMEOUT_USEC)\r\nreturn -ETIMEDOUT;\r\nwritel(PORTSC_PTS_ULPI, USB_PORTSC);\r\nwritel(0x0, USB_AHBBURST);\r\nwritel(0x08, USB_AHBMODE);\r\nif (motg->phy_number)\r\nwritel(readl(USB_PHY_CTRL2) | BIT(16), USB_PHY_CTRL2);\r\nreturn 0;\r\n}\r\nstatic void msm_phy_reset(struct msm_otg *motg)\r\n{\r\nvoid __iomem *addr;\r\nif (motg->pdata->phy_type != SNPS_28NM_INTEGRATED_PHY) {\r\nmsm_otg_phy_clk_reset(motg);\r\nreturn;\r\n}\r\naddr = USB_PHY_CTRL;\r\nif (motg->phy_number)\r\naddr = USB_PHY_CTRL2;\r\nwritel(readl(addr) | PHY_POR_ASSERT, addr);\r\nudelay(12);\r\nwritel(readl(addr) & ~PHY_POR_ASSERT, addr);\r\n}\r\nstatic int msm_usb_reset(struct usb_phy *phy)\r\n{\r\nstruct msm_otg *motg = container_of(phy, struct msm_otg, phy);\r\nint ret;\r\nif (!IS_ERR(motg->core_clk))\r\nclk_prepare_enable(motg->core_clk);\r\nret = msm_link_reset(motg);\r\nif (ret) {\r\ndev_err(phy->dev, "phy_reset failed\n");\r\nreturn ret;\r\n}\r\nret = msm_otg_reset(&motg->phy);\r\nif (ret) {\r\ndev_err(phy->dev, "link reset failed\n");\r\nreturn ret;\r\n}\r\nmsleep(100);\r\nmsm_phy_reset(motg);\r\nif (!IS_ERR(motg->core_clk))\r\nclk_disable_unprepare(motg->core_clk);\r\nreturn 0;\r\n}\r\nstatic int msm_phy_init(struct usb_phy *phy)\r\n{\r\nstruct msm_otg *motg = container_of(phy, struct msm_otg, phy);\r\nstruct msm_otg_platform_data *pdata = motg->pdata;\r\nu32 val, ulpi_val = 0;\r\nulpi_init(motg);\r\nmsm_phy_reset(motg);\r\nif (pdata->otg_control == OTG_PHY_CONTROL) {\r\nval = readl(USB_OTGSC);\r\nif (pdata->mode == USB_DR_MODE_OTG) {\r\nulpi_val = ULPI_INT_IDGRD | ULPI_INT_SESS_VALID;\r\nval |= OTGSC_IDIE | OTGSC_BSVIE;\r\n} else if (pdata->mode == USB_DR_MODE_PERIPHERAL) {\r\nulpi_val = ULPI_INT_SESS_VALID;\r\nval |= OTGSC_BSVIE;\r\n}\r\nwritel(val, USB_OTGSC);\r\nulpi_write(phy, ulpi_val, ULPI_USB_INT_EN_RISE);\r\nulpi_write(phy, ulpi_val, ULPI_USB_INT_EN_FALL);\r\n}\r\nif (motg->manual_pullup) {\r\nval = ULPI_MISC_A_VBUSVLDEXTSEL | ULPI_MISC_A_VBUSVLDEXT;\r\nulpi_write(phy, val, ULPI_SET(ULPI_MISC_A));\r\nval = readl(USB_GENCONFIG_2);\r\nval |= GENCONFIG_2_SESS_VLD_CTRL_EN;\r\nwritel(val, USB_GENCONFIG_2);\r\nval = readl(USB_USBCMD);\r\nval |= USBCMD_SESS_VLD_CTRL;\r\nwritel(val, USB_USBCMD);\r\nval = ulpi_read(phy, ULPI_FUNC_CTRL);\r\nval &= ~ULPI_FUNC_CTRL_OPMODE_MASK;\r\nval |= ULPI_FUNC_CTRL_OPMODE_NORMAL;\r\nulpi_write(phy, val, ULPI_FUNC_CTRL);\r\n}\r\nif (motg->phy_number)\r\nwritel(readl(USB_PHY_CTRL2) | BIT(16), USB_PHY_CTRL2);\r\nreturn 0;\r\n}\r\nstatic int msm_hsusb_config_vddcx(struct msm_otg *motg, int high)\r\n{\r\nint max_vol = motg->vdd_levels[VDD_LEVEL_MAX];\r\nint min_vol;\r\nint ret;\r\nif (high)\r\nmin_vol = motg->vdd_levels[VDD_LEVEL_MIN];\r\nelse\r\nmin_vol = motg->vdd_levels[VDD_LEVEL_NONE];\r\nret = regulator_set_voltage(motg->vddcx, min_vol, max_vol);\r\nif (ret) {\r\npr_err("Cannot set vddcx voltage\n");\r\nreturn ret;\r\n}\r\npr_debug("%s: min_vol:%d max_vol:%d\n", __func__, min_vol, max_vol);\r\nreturn ret;\r\n}\r\nstatic int msm_otg_suspend(struct msm_otg *motg)\r\n{\r\nstruct usb_phy *phy = &motg->phy;\r\nstruct usb_bus *bus = phy->otg->host;\r\nstruct msm_otg_platform_data *pdata = motg->pdata;\r\nvoid __iomem *addr;\r\nint cnt = 0;\r\nif (atomic_read(&motg->in_lpm))\r\nreturn 0;\r\ndisable_irq(motg->irq);\r\nif (motg->pdata->phy_type == CI_45NM_INTEGRATED_PHY) {\r\nulpi_read(phy, 0x14);\r\nif (pdata->otg_control == OTG_PHY_CONTROL)\r\nulpi_write(phy, 0x01, 0x30);\r\nulpi_write(phy, 0x08, 0x09);\r\n}\r\nwritel(readl(USB_PORTSC) | PORTSC_PHCD, USB_PORTSC);\r\nwhile (cnt < PHY_SUSPEND_TIMEOUT_USEC) {\r\nif (readl(USB_PORTSC) & PORTSC_PHCD)\r\nbreak;\r\nudelay(1);\r\ncnt++;\r\n}\r\nif (cnt >= PHY_SUSPEND_TIMEOUT_USEC) {\r\ndev_err(phy->dev, "Unable to suspend PHY\n");\r\nmsm_otg_reset(phy);\r\nenable_irq(motg->irq);\r\nreturn -ETIMEDOUT;\r\n}\r\nwritel(readl(USB_USBCMD) | ASYNC_INTR_CTRL | ULPI_STP_CTRL, USB_USBCMD);\r\naddr = USB_PHY_CTRL;\r\nif (motg->phy_number)\r\naddr = USB_PHY_CTRL2;\r\nif (motg->pdata->phy_type == SNPS_28NM_INTEGRATED_PHY &&\r\nmotg->pdata->otg_control == OTG_PMIC_CONTROL)\r\nwritel(readl(addr) | PHY_RETEN, addr);\r\nclk_disable_unprepare(motg->pclk);\r\nclk_disable_unprepare(motg->clk);\r\nif (!IS_ERR(motg->core_clk))\r\nclk_disable_unprepare(motg->core_clk);\r\nif (motg->pdata->phy_type == SNPS_28NM_INTEGRATED_PHY &&\r\nmotg->pdata->otg_control == OTG_PMIC_CONTROL) {\r\nmsm_hsusb_ldo_set_mode(motg, 0);\r\nmsm_hsusb_config_vddcx(motg, 0);\r\n}\r\nif (device_may_wakeup(phy->dev))\r\nenable_irq_wake(motg->irq);\r\nif (bus)\r\nclear_bit(HCD_FLAG_HW_ACCESSIBLE, &(bus_to_hcd(bus))->flags);\r\natomic_set(&motg->in_lpm, 1);\r\nenable_irq(motg->irq);\r\ndev_info(phy->dev, "USB in low power mode\n");\r\nreturn 0;\r\n}\r\nstatic int msm_otg_resume(struct msm_otg *motg)\r\n{\r\nstruct usb_phy *phy = &motg->phy;\r\nstruct usb_bus *bus = phy->otg->host;\r\nvoid __iomem *addr;\r\nint cnt = 0;\r\nunsigned temp;\r\nif (!atomic_read(&motg->in_lpm))\r\nreturn 0;\r\nclk_prepare_enable(motg->pclk);\r\nclk_prepare_enable(motg->clk);\r\nif (!IS_ERR(motg->core_clk))\r\nclk_prepare_enable(motg->core_clk);\r\nif (motg->pdata->phy_type == SNPS_28NM_INTEGRATED_PHY &&\r\nmotg->pdata->otg_control == OTG_PMIC_CONTROL) {\r\naddr = USB_PHY_CTRL;\r\nif (motg->phy_number)\r\naddr = USB_PHY_CTRL2;\r\nmsm_hsusb_ldo_set_mode(motg, 1);\r\nmsm_hsusb_config_vddcx(motg, 1);\r\nwritel(readl(addr) & ~PHY_RETEN, addr);\r\n}\r\ntemp = readl(USB_USBCMD);\r\ntemp &= ~ASYNC_INTR_CTRL;\r\ntemp &= ~ULPI_STP_CTRL;\r\nwritel(temp, USB_USBCMD);\r\nif (!(readl(USB_PORTSC) & PORTSC_PHCD))\r\ngoto skip_phy_resume;\r\nwritel(readl(USB_PORTSC) & ~PORTSC_PHCD, USB_PORTSC);\r\nwhile (cnt < PHY_RESUME_TIMEOUT_USEC) {\r\nif (!(readl(USB_PORTSC) & PORTSC_PHCD))\r\nbreak;\r\nudelay(1);\r\ncnt++;\r\n}\r\nif (cnt >= PHY_RESUME_TIMEOUT_USEC) {\r\ndev_err(phy->dev, "Unable to resume USB. Re-plugin the cable\n");\r\nmsm_otg_reset(phy);\r\n}\r\nskip_phy_resume:\r\nif (device_may_wakeup(phy->dev))\r\ndisable_irq_wake(motg->irq);\r\nif (bus)\r\nset_bit(HCD_FLAG_HW_ACCESSIBLE, &(bus_to_hcd(bus))->flags);\r\natomic_set(&motg->in_lpm, 0);\r\nif (motg->async_int) {\r\nmotg->async_int = 0;\r\npm_runtime_put(phy->dev);\r\nenable_irq(motg->irq);\r\n}\r\ndev_info(phy->dev, "USB exited from low power mode\n");\r\nreturn 0;\r\n}\r\nstatic void msm_otg_notify_charger(struct msm_otg *motg, unsigned mA)\r\n{\r\nif (motg->cur_power == mA)\r\nreturn;\r\ndev_info(motg->phy.dev, "Avail curr from USB = %u\n", mA);\r\nmotg->cur_power = mA;\r\n}\r\nstatic void msm_otg_start_host(struct usb_phy *phy, int on)\r\n{\r\nstruct msm_otg *motg = container_of(phy, struct msm_otg, phy);\r\nstruct msm_otg_platform_data *pdata = motg->pdata;\r\nstruct usb_hcd *hcd;\r\nif (!phy->otg->host)\r\nreturn;\r\nhcd = bus_to_hcd(phy->otg->host);\r\nif (on) {\r\ndev_dbg(phy->dev, "host on\n");\r\nif (pdata->vbus_power)\r\npdata->vbus_power(1);\r\nif (pdata->setup_gpio)\r\npdata->setup_gpio(OTG_STATE_A_HOST);\r\n#ifdef CONFIG_USB\r\nusb_add_hcd(hcd, hcd->irq, IRQF_SHARED);\r\ndevice_wakeup_enable(hcd->self.controller);\r\n#endif\r\n} else {\r\ndev_dbg(phy->dev, "host off\n");\r\n#ifdef CONFIG_USB\r\nusb_remove_hcd(hcd);\r\n#endif\r\nif (pdata->setup_gpio)\r\npdata->setup_gpio(OTG_STATE_UNDEFINED);\r\nif (pdata->vbus_power)\r\npdata->vbus_power(0);\r\n}\r\n}\r\nstatic int msm_otg_set_host(struct usb_otg *otg, struct usb_bus *host)\r\n{\r\nstruct msm_otg *motg = container_of(otg->usb_phy, struct msm_otg, phy);\r\nstruct usb_hcd *hcd;\r\nif (motg->pdata->mode == USB_DR_MODE_PERIPHERAL) {\r\ndev_info(otg->usb_phy->dev, "Host mode is not supported\n");\r\nreturn -ENODEV;\r\n}\r\nif (!host) {\r\nif (otg->state == OTG_STATE_A_HOST) {\r\npm_runtime_get_sync(otg->usb_phy->dev);\r\nmsm_otg_start_host(otg->usb_phy, 0);\r\notg->host = NULL;\r\notg->state = OTG_STATE_UNDEFINED;\r\nschedule_work(&motg->sm_work);\r\n} else {\r\notg->host = NULL;\r\n}\r\nreturn 0;\r\n}\r\nhcd = bus_to_hcd(host);\r\nhcd->power_budget = motg->pdata->power_budget;\r\notg->host = host;\r\ndev_dbg(otg->usb_phy->dev, "host driver registered w/ tranceiver\n");\r\npm_runtime_get_sync(otg->usb_phy->dev);\r\nschedule_work(&motg->sm_work);\r\nreturn 0;\r\n}\r\nstatic void msm_otg_start_peripheral(struct usb_phy *phy, int on)\r\n{\r\nstruct msm_otg *motg = container_of(phy, struct msm_otg, phy);\r\nstruct msm_otg_platform_data *pdata = motg->pdata;\r\nif (!phy->otg->gadget)\r\nreturn;\r\nif (on) {\r\ndev_dbg(phy->dev, "gadget on\n");\r\nif (pdata->setup_gpio)\r\npdata->setup_gpio(OTG_STATE_B_PERIPHERAL);\r\nusb_gadget_vbus_connect(phy->otg->gadget);\r\n} else {\r\ndev_dbg(phy->dev, "gadget off\n");\r\nusb_gadget_vbus_disconnect(phy->otg->gadget);\r\nif (pdata->setup_gpio)\r\npdata->setup_gpio(OTG_STATE_UNDEFINED);\r\n}\r\n}\r\nstatic int msm_otg_set_peripheral(struct usb_otg *otg,\r\nstruct usb_gadget *gadget)\r\n{\r\nstruct msm_otg *motg = container_of(otg->usb_phy, struct msm_otg, phy);\r\nif (motg->pdata->mode == USB_DR_MODE_HOST) {\r\ndev_info(otg->usb_phy->dev, "Peripheral mode is not supported\n");\r\nreturn -ENODEV;\r\n}\r\nif (!gadget) {\r\nif (otg->state == OTG_STATE_B_PERIPHERAL) {\r\npm_runtime_get_sync(otg->usb_phy->dev);\r\nmsm_otg_start_peripheral(otg->usb_phy, 0);\r\notg->gadget = NULL;\r\notg->state = OTG_STATE_UNDEFINED;\r\nschedule_work(&motg->sm_work);\r\n} else {\r\notg->gadget = NULL;\r\n}\r\nreturn 0;\r\n}\r\notg->gadget = gadget;\r\ndev_dbg(otg->usb_phy->dev,\r\n"peripheral driver registered w/ tranceiver\n");\r\npm_runtime_get_sync(otg->usb_phy->dev);\r\nschedule_work(&motg->sm_work);\r\nreturn 0;\r\n}\r\nstatic bool msm_chg_check_secondary_det(struct msm_otg *motg)\r\n{\r\nstruct usb_phy *phy = &motg->phy;\r\nu32 chg_det;\r\nbool ret = false;\r\nswitch (motg->pdata->phy_type) {\r\ncase CI_45NM_INTEGRATED_PHY:\r\nchg_det = ulpi_read(phy, 0x34);\r\nret = chg_det & (1 << 4);\r\nbreak;\r\ncase SNPS_28NM_INTEGRATED_PHY:\r\nchg_det = ulpi_read(phy, 0x87);\r\nret = chg_det & 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void msm_chg_enable_secondary_det(struct msm_otg *motg)\r\n{\r\nstruct usb_phy *phy = &motg->phy;\r\nu32 chg_det;\r\nswitch (motg->pdata->phy_type) {\r\ncase CI_45NM_INTEGRATED_PHY:\r\nchg_det = ulpi_read(phy, 0x34);\r\nchg_det |= ~(1 << 1);\r\nulpi_write(phy, chg_det, 0x34);\r\nudelay(20);\r\nchg_det &= ~(1 << 3);\r\nulpi_write(phy, chg_det, 0x34);\r\nchg_det &= ~(1 << 2);\r\nulpi_write(phy, chg_det, 0x34);\r\nchg_det &= ~(1 << 1);\r\nulpi_write(phy, chg_det, 0x34);\r\nudelay(20);\r\nchg_det &= ~(1 << 0);\r\nulpi_write(phy, chg_det, 0x34);\r\nbreak;\r\ncase SNPS_28NM_INTEGRATED_PHY:\r\nulpi_write(phy, 0x8, 0x85);\r\nulpi_write(phy, 0x2, 0x85);\r\nulpi_write(phy, 0x1, 0x85);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic bool msm_chg_check_primary_det(struct msm_otg *motg)\r\n{\r\nstruct usb_phy *phy = &motg->phy;\r\nu32 chg_det;\r\nbool ret = false;\r\nswitch (motg->pdata->phy_type) {\r\ncase CI_45NM_INTEGRATED_PHY:\r\nchg_det = ulpi_read(phy, 0x34);\r\nret = chg_det & (1 << 4);\r\nbreak;\r\ncase SNPS_28NM_INTEGRATED_PHY:\r\nchg_det = ulpi_read(phy, 0x87);\r\nret = chg_det & 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void msm_chg_enable_primary_det(struct msm_otg *motg)\r\n{\r\nstruct usb_phy *phy = &motg->phy;\r\nu32 chg_det;\r\nswitch (motg->pdata->phy_type) {\r\ncase CI_45NM_INTEGRATED_PHY:\r\nchg_det = ulpi_read(phy, 0x34);\r\nchg_det &= ~(1 << 0);\r\nulpi_write(phy, chg_det, 0x34);\r\nbreak;\r\ncase SNPS_28NM_INTEGRATED_PHY:\r\nulpi_write(phy, 0x2, 0x85);\r\nulpi_write(phy, 0x1, 0x85);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic bool msm_chg_check_dcd(struct msm_otg *motg)\r\n{\r\nstruct usb_phy *phy = &motg->phy;\r\nu32 line_state;\r\nbool ret = false;\r\nswitch (motg->pdata->phy_type) {\r\ncase CI_45NM_INTEGRATED_PHY:\r\nline_state = ulpi_read(phy, 0x15);\r\nret = !(line_state & 1);\r\nbreak;\r\ncase SNPS_28NM_INTEGRATED_PHY:\r\nline_state = ulpi_read(phy, 0x87);\r\nret = line_state & 2;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void msm_chg_disable_dcd(struct msm_otg *motg)\r\n{\r\nstruct usb_phy *phy = &motg->phy;\r\nu32 chg_det;\r\nswitch (motg->pdata->phy_type) {\r\ncase CI_45NM_INTEGRATED_PHY:\r\nchg_det = ulpi_read(phy, 0x34);\r\nchg_det &= ~(1 << 5);\r\nulpi_write(phy, chg_det, 0x34);\r\nbreak;\r\ncase SNPS_28NM_INTEGRATED_PHY:\r\nulpi_write(phy, 0x10, 0x86);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void msm_chg_enable_dcd(struct msm_otg *motg)\r\n{\r\nstruct usb_phy *phy = &motg->phy;\r\nu32 chg_det;\r\nswitch (motg->pdata->phy_type) {\r\ncase CI_45NM_INTEGRATED_PHY:\r\nchg_det = ulpi_read(phy, 0x34);\r\nchg_det |= (1 << 5);\r\nulpi_write(phy, chg_det, 0x34);\r\nbreak;\r\ncase SNPS_28NM_INTEGRATED_PHY:\r\nulpi_write(phy, 0x10, 0x85);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void msm_chg_block_on(struct msm_otg *motg)\r\n{\r\nstruct usb_phy *phy = &motg->phy;\r\nu32 func_ctrl, chg_det;\r\nfunc_ctrl = ulpi_read(phy, ULPI_FUNC_CTRL);\r\nfunc_ctrl &= ~ULPI_FUNC_CTRL_OPMODE_MASK;\r\nfunc_ctrl |= ULPI_FUNC_CTRL_OPMODE_NONDRIVING;\r\nulpi_write(phy, func_ctrl, ULPI_FUNC_CTRL);\r\nswitch (motg->pdata->phy_type) {\r\ncase CI_45NM_INTEGRATED_PHY:\r\nchg_det = ulpi_read(phy, 0x34);\r\nchg_det &= ~(1 << 3);\r\nulpi_write(phy, chg_det, 0x34);\r\nchg_det &= ~(1 << 1);\r\nulpi_write(phy, chg_det, 0x34);\r\nudelay(20);\r\nbreak;\r\ncase SNPS_28NM_INTEGRATED_PHY:\r\nulpi_write(phy, 0x3F, 0x86);\r\nulpi_write(phy, 0x1F, 0x92);\r\nulpi_write(phy, 0x1F, 0x95);\r\nudelay(100);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void msm_chg_block_off(struct msm_otg *motg)\r\n{\r\nstruct usb_phy *phy = &motg->phy;\r\nu32 func_ctrl, chg_det;\r\nswitch (motg->pdata->phy_type) {\r\ncase CI_45NM_INTEGRATED_PHY:\r\nchg_det = ulpi_read(phy, 0x34);\r\nchg_det |= ~(1 << 1);\r\nulpi_write(phy, chg_det, 0x34);\r\nbreak;\r\ncase SNPS_28NM_INTEGRATED_PHY:\r\nulpi_write(phy, 0x3F, 0x86);\r\nulpi_write(phy, 0x1F, 0x92);\r\nulpi_write(phy, 0x1F, 0x95);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nfunc_ctrl = ulpi_read(phy, ULPI_FUNC_CTRL);\r\nfunc_ctrl &= ~ULPI_FUNC_CTRL_OPMODE_MASK;\r\nfunc_ctrl |= ULPI_FUNC_CTRL_OPMODE_NORMAL;\r\nulpi_write(phy, func_ctrl, ULPI_FUNC_CTRL);\r\n}\r\nstatic void msm_chg_detect_work(struct work_struct *w)\r\n{\r\nstruct msm_otg *motg = container_of(w, struct msm_otg, chg_work.work);\r\nstruct usb_phy *phy = &motg->phy;\r\nbool is_dcd, tmout, vout;\r\nunsigned long delay;\r\ndev_dbg(phy->dev, "chg detection work\n");\r\nswitch (motg->chg_state) {\r\ncase USB_CHG_STATE_UNDEFINED:\r\npm_runtime_get_sync(phy->dev);\r\nmsm_chg_block_on(motg);\r\nmsm_chg_enable_dcd(motg);\r\nmotg->chg_state = USB_CHG_STATE_WAIT_FOR_DCD;\r\nmotg->dcd_retries = 0;\r\ndelay = MSM_CHG_DCD_POLL_TIME;\r\nbreak;\r\ncase USB_CHG_STATE_WAIT_FOR_DCD:\r\nis_dcd = msm_chg_check_dcd(motg);\r\ntmout = ++motg->dcd_retries == MSM_CHG_DCD_MAX_RETRIES;\r\nif (is_dcd || tmout) {\r\nmsm_chg_disable_dcd(motg);\r\nmsm_chg_enable_primary_det(motg);\r\ndelay = MSM_CHG_PRIMARY_DET_TIME;\r\nmotg->chg_state = USB_CHG_STATE_DCD_DONE;\r\n} else {\r\ndelay = MSM_CHG_DCD_POLL_TIME;\r\n}\r\nbreak;\r\ncase USB_CHG_STATE_DCD_DONE:\r\nvout = msm_chg_check_primary_det(motg);\r\nif (vout) {\r\nmsm_chg_enable_secondary_det(motg);\r\ndelay = MSM_CHG_SECONDARY_DET_TIME;\r\nmotg->chg_state = USB_CHG_STATE_PRIMARY_DONE;\r\n} else {\r\nmotg->chg_type = USB_SDP_CHARGER;\r\nmotg->chg_state = USB_CHG_STATE_DETECTED;\r\ndelay = 0;\r\n}\r\nbreak;\r\ncase USB_CHG_STATE_PRIMARY_DONE:\r\nvout = msm_chg_check_secondary_det(motg);\r\nif (vout)\r\nmotg->chg_type = USB_DCP_CHARGER;\r\nelse\r\nmotg->chg_type = USB_CDP_CHARGER;\r\nmotg->chg_state = USB_CHG_STATE_SECONDARY_DONE;\r\ncase USB_CHG_STATE_SECONDARY_DONE:\r\nmotg->chg_state = USB_CHG_STATE_DETECTED;\r\ncase USB_CHG_STATE_DETECTED:\r\nmsm_chg_block_off(motg);\r\ndev_dbg(phy->dev, "charger = %d\n", motg->chg_type);\r\nschedule_work(&motg->sm_work);\r\nreturn;\r\ndefault:\r\nreturn;\r\n}\r\nschedule_delayed_work(&motg->chg_work, delay);\r\n}\r\nstatic void msm_otg_init_sm(struct msm_otg *motg)\r\n{\r\nstruct msm_otg_platform_data *pdata = motg->pdata;\r\nu32 otgsc = readl(USB_OTGSC);\r\nswitch (pdata->mode) {\r\ncase USB_DR_MODE_OTG:\r\nif (pdata->otg_control == OTG_PHY_CONTROL) {\r\nif (otgsc & OTGSC_ID)\r\nset_bit(ID, &motg->inputs);\r\nelse\r\nclear_bit(ID, &motg->inputs);\r\nif (otgsc & OTGSC_BSV)\r\nset_bit(B_SESS_VLD, &motg->inputs);\r\nelse\r\nclear_bit(B_SESS_VLD, &motg->inputs);\r\n} else if (pdata->otg_control == OTG_USER_CONTROL) {\r\nset_bit(ID, &motg->inputs);\r\nclear_bit(B_SESS_VLD, &motg->inputs);\r\n}\r\nbreak;\r\ncase USB_DR_MODE_HOST:\r\nclear_bit(ID, &motg->inputs);\r\nbreak;\r\ncase USB_DR_MODE_PERIPHERAL:\r\nset_bit(ID, &motg->inputs);\r\nif (otgsc & OTGSC_BSV)\r\nset_bit(B_SESS_VLD, &motg->inputs);\r\nelse\r\nclear_bit(B_SESS_VLD, &motg->inputs);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void msm_otg_sm_work(struct work_struct *w)\r\n{\r\nstruct msm_otg *motg = container_of(w, struct msm_otg, sm_work);\r\nstruct usb_otg *otg = motg->phy.otg;\r\nswitch (otg->state) {\r\ncase OTG_STATE_UNDEFINED:\r\ndev_dbg(otg->usb_phy->dev, "OTG_STATE_UNDEFINED state\n");\r\nmsm_otg_reset(otg->usb_phy);\r\nmsm_otg_init_sm(motg);\r\notg->state = OTG_STATE_B_IDLE;\r\ncase OTG_STATE_B_IDLE:\r\ndev_dbg(otg->usb_phy->dev, "OTG_STATE_B_IDLE state\n");\r\nif (!test_bit(ID, &motg->inputs) && otg->host) {\r\nwritel(readl(USB_OTGSC) & ~OTGSC_BSVIE, USB_OTGSC);\r\nmsm_otg_start_host(otg->usb_phy, 1);\r\notg->state = OTG_STATE_A_HOST;\r\n} else if (test_bit(B_SESS_VLD, &motg->inputs)) {\r\nswitch (motg->chg_state) {\r\ncase USB_CHG_STATE_UNDEFINED:\r\nmsm_chg_detect_work(&motg->chg_work.work);\r\nbreak;\r\ncase USB_CHG_STATE_DETECTED:\r\nswitch (motg->chg_type) {\r\ncase USB_DCP_CHARGER:\r\nmsm_otg_notify_charger(motg,\r\nIDEV_CHG_MAX);\r\nbreak;\r\ncase USB_CDP_CHARGER:\r\nmsm_otg_notify_charger(motg,\r\nIDEV_CHG_MAX);\r\nmsm_otg_start_peripheral(otg->usb_phy,\r\n1);\r\notg->state\r\n= OTG_STATE_B_PERIPHERAL;\r\nbreak;\r\ncase USB_SDP_CHARGER:\r\nmsm_otg_notify_charger(motg, IUNIT);\r\nmsm_otg_start_peripheral(otg->usb_phy,\r\n1);\r\notg->state\r\n= OTG_STATE_B_PERIPHERAL;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nif (cancel_delayed_work_sync(&motg->chg_work)) {\r\npm_runtime_put_sync(otg->usb_phy->dev);\r\nmsm_otg_reset(otg->usb_phy);\r\n}\r\nmsm_otg_notify_charger(motg, 0);\r\nmotg->chg_state = USB_CHG_STATE_UNDEFINED;\r\nmotg->chg_type = USB_INVALID_CHARGER;\r\n}\r\nif (otg->state == OTG_STATE_B_IDLE)\r\npm_runtime_put_sync(otg->usb_phy->dev);\r\nbreak;\r\ncase OTG_STATE_B_PERIPHERAL:\r\ndev_dbg(otg->usb_phy->dev, "OTG_STATE_B_PERIPHERAL state\n");\r\nif (!test_bit(B_SESS_VLD, &motg->inputs) ||\r\n!test_bit(ID, &motg->inputs)) {\r\nmsm_otg_notify_charger(motg, 0);\r\nmsm_otg_start_peripheral(otg->usb_phy, 0);\r\nmotg->chg_state = USB_CHG_STATE_UNDEFINED;\r\nmotg->chg_type = USB_INVALID_CHARGER;\r\notg->state = OTG_STATE_B_IDLE;\r\nmsm_otg_reset(otg->usb_phy);\r\nschedule_work(w);\r\n}\r\nbreak;\r\ncase OTG_STATE_A_HOST:\r\ndev_dbg(otg->usb_phy->dev, "OTG_STATE_A_HOST state\n");\r\nif (test_bit(ID, &motg->inputs)) {\r\nmsm_otg_start_host(otg->usb_phy, 0);\r\notg->state = OTG_STATE_B_IDLE;\r\nmsm_otg_reset(otg->usb_phy);\r\nschedule_work(w);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic irqreturn_t msm_otg_irq(int irq, void *data)\r\n{\r\nstruct msm_otg *motg = data;\r\nstruct usb_phy *phy = &motg->phy;\r\nu32 otgsc = 0;\r\nif (atomic_read(&motg->in_lpm)) {\r\ndisable_irq_nosync(irq);\r\nmotg->async_int = 1;\r\npm_runtime_get(phy->dev);\r\nreturn IRQ_HANDLED;\r\n}\r\notgsc = readl(USB_OTGSC);\r\nif (!(otgsc & (OTGSC_IDIS | OTGSC_BSVIS)))\r\nreturn IRQ_NONE;\r\nif ((otgsc & OTGSC_IDIS) && (otgsc & OTGSC_IDIE)) {\r\nif (otgsc & OTGSC_ID)\r\nset_bit(ID, &motg->inputs);\r\nelse\r\nclear_bit(ID, &motg->inputs);\r\ndev_dbg(phy->dev, "ID set/clear\n");\r\npm_runtime_get_noresume(phy->dev);\r\n} else if ((otgsc & OTGSC_BSVIS) && (otgsc & OTGSC_BSVIE)) {\r\nif (otgsc & OTGSC_BSV)\r\nset_bit(B_SESS_VLD, &motg->inputs);\r\nelse\r\nclear_bit(B_SESS_VLD, &motg->inputs);\r\ndev_dbg(phy->dev, "BSV set/clear\n");\r\npm_runtime_get_noresume(phy->dev);\r\n}\r\nwritel(otgsc, USB_OTGSC);\r\nschedule_work(&motg->sm_work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int msm_otg_mode_show(struct seq_file *s, void *unused)\r\n{\r\nstruct msm_otg *motg = s->private;\r\nstruct usb_otg *otg = motg->phy.otg;\r\nswitch (otg->state) {\r\ncase OTG_STATE_A_HOST:\r\nseq_puts(s, "host\n");\r\nbreak;\r\ncase OTG_STATE_B_PERIPHERAL:\r\nseq_puts(s, "peripheral\n");\r\nbreak;\r\ndefault:\r\nseq_puts(s, "none\n");\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int msm_otg_mode_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, msm_otg_mode_show, inode->i_private);\r\n}\r\nstatic ssize_t msm_otg_mode_write(struct file *file, const char __user *ubuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct seq_file *s = file->private_data;\r\nstruct msm_otg *motg = s->private;\r\nchar buf[16];\r\nstruct usb_otg *otg = motg->phy.otg;\r\nint status = count;\r\nenum usb_dr_mode req_mode;\r\nmemset(buf, 0x00, sizeof(buf));\r\nif (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count))) {\r\nstatus = -EFAULT;\r\ngoto out;\r\n}\r\nif (!strncmp(buf, "host", 4)) {\r\nreq_mode = USB_DR_MODE_HOST;\r\n} else if (!strncmp(buf, "peripheral", 10)) {\r\nreq_mode = USB_DR_MODE_PERIPHERAL;\r\n} else if (!strncmp(buf, "none", 4)) {\r\nreq_mode = USB_DR_MODE_UNKNOWN;\r\n} else {\r\nstatus = -EINVAL;\r\ngoto out;\r\n}\r\nswitch (req_mode) {\r\ncase USB_DR_MODE_UNKNOWN:\r\nswitch (otg->state) {\r\ncase OTG_STATE_A_HOST:\r\ncase OTG_STATE_B_PERIPHERAL:\r\nset_bit(ID, &motg->inputs);\r\nclear_bit(B_SESS_VLD, &motg->inputs);\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\nbreak;\r\ncase USB_DR_MODE_PERIPHERAL:\r\nswitch (otg->state) {\r\ncase OTG_STATE_B_IDLE:\r\ncase OTG_STATE_A_HOST:\r\nset_bit(ID, &motg->inputs);\r\nset_bit(B_SESS_VLD, &motg->inputs);\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\nbreak;\r\ncase USB_DR_MODE_HOST:\r\nswitch (otg->state) {\r\ncase OTG_STATE_B_IDLE:\r\ncase OTG_STATE_B_PERIPHERAL:\r\nclear_bit(ID, &motg->inputs);\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\npm_runtime_get_sync(otg->usb_phy->dev);\r\nschedule_work(&motg->sm_work);\r\nout:\r\nreturn status;\r\n}\r\nstatic int msm_otg_debugfs_init(struct msm_otg *motg)\r\n{\r\nmsm_otg_dbg_root = debugfs_create_dir("msm_otg", NULL);\r\nif (!msm_otg_dbg_root || IS_ERR(msm_otg_dbg_root))\r\nreturn -ENODEV;\r\nmsm_otg_dbg_mode = debugfs_create_file("mode", S_IRUGO | S_IWUSR,\r\nmsm_otg_dbg_root, motg, &msm_otg_mode_fops);\r\nif (!msm_otg_dbg_mode) {\r\ndebugfs_remove(msm_otg_dbg_root);\r\nmsm_otg_dbg_root = NULL;\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void msm_otg_debugfs_cleanup(void)\r\n{\r\ndebugfs_remove(msm_otg_dbg_mode);\r\ndebugfs_remove(msm_otg_dbg_root);\r\n}\r\nstatic int msm_otg_vbus_notifier(struct notifier_block *nb, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct msm_usb_cable *vbus = container_of(nb, struct msm_usb_cable, nb);\r\nstruct msm_otg *motg = container_of(vbus, struct msm_otg, vbus);\r\nif (event)\r\nset_bit(B_SESS_VLD, &motg->inputs);\r\nelse\r\nclear_bit(B_SESS_VLD, &motg->inputs);\r\nif (test_bit(B_SESS_VLD, &motg->inputs)) {\r\ngpiod_set_value_cansleep(motg->switch_gpio, 0);\r\n} else {\r\ngpiod_set_value_cansleep(motg->switch_gpio, 1);\r\n}\r\nschedule_work(&motg->sm_work);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int msm_otg_id_notifier(struct notifier_block *nb, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct msm_usb_cable *id = container_of(nb, struct msm_usb_cable, nb);\r\nstruct msm_otg *motg = container_of(id, struct msm_otg, id);\r\nif (event)\r\nclear_bit(ID, &motg->inputs);\r\nelse\r\nset_bit(ID, &motg->inputs);\r\nschedule_work(&motg->sm_work);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int msm_otg_read_dt(struct platform_device *pdev, struct msm_otg *motg)\r\n{\r\nstruct msm_otg_platform_data *pdata;\r\nstruct extcon_dev *ext_id, *ext_vbus;\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct property *prop;\r\nint len, ret, words;\r\nu32 val, tmp[3];\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nmotg->pdata = pdata;\r\npdata->phy_type = (enum msm_usb_phy_type)of_device_get_match_data(&pdev->dev);\r\nif (!pdata->phy_type)\r\nreturn 1;\r\nmotg->link_rst = devm_reset_control_get(&pdev->dev, "link");\r\nif (IS_ERR(motg->link_rst))\r\nreturn PTR_ERR(motg->link_rst);\r\nmotg->phy_rst = devm_reset_control_get(&pdev->dev, "phy");\r\nif (IS_ERR(motg->phy_rst))\r\nmotg->phy_rst = NULL;\r\npdata->mode = usb_get_dr_mode(&pdev->dev);\r\nif (pdata->mode == USB_DR_MODE_UNKNOWN)\r\npdata->mode = USB_DR_MODE_OTG;\r\npdata->otg_control = OTG_PHY_CONTROL;\r\nif (!of_property_read_u32(node, "qcom,otg-control", &val))\r\nif (val == OTG_PMIC_CONTROL)\r\npdata->otg_control = val;\r\nif (!of_property_read_u32(node, "qcom,phy-num", &val) && val < 2)\r\nmotg->phy_number = val;\r\nmotg->vdd_levels[VDD_LEVEL_NONE] = USB_PHY_SUSP_DIG_VOL;\r\nmotg->vdd_levels[VDD_LEVEL_MIN] = USB_PHY_VDD_DIG_VOL_MIN;\r\nmotg->vdd_levels[VDD_LEVEL_MAX] = USB_PHY_VDD_DIG_VOL_MAX;\r\nif (of_get_property(node, "qcom,vdd-levels", &len) &&\r\nlen == sizeof(tmp)) {\r\nof_property_read_u32_array(node, "qcom,vdd-levels",\r\ntmp, len / sizeof(*tmp));\r\nmotg->vdd_levels[VDD_LEVEL_NONE] = tmp[VDD_LEVEL_NONE];\r\nmotg->vdd_levels[VDD_LEVEL_MIN] = tmp[VDD_LEVEL_MIN];\r\nmotg->vdd_levels[VDD_LEVEL_MAX] = tmp[VDD_LEVEL_MAX];\r\n}\r\nmotg->manual_pullup = of_property_read_bool(node, "qcom,manual-pullup");\r\nmotg->switch_gpio = devm_gpiod_get_optional(&pdev->dev, "switch",\r\nGPIOD_OUT_LOW);\r\nif (IS_ERR(motg->switch_gpio))\r\nreturn PTR_ERR(motg->switch_gpio);\r\next_id = ERR_PTR(-ENODEV);\r\next_vbus = ERR_PTR(-ENODEV);\r\nif (of_property_read_bool(node, "extcon")) {\r\next_vbus = extcon_get_edev_by_phandle(&pdev->dev, 0);\r\nif (IS_ERR(ext_vbus) && PTR_ERR(ext_vbus) != -ENODEV)\r\nreturn PTR_ERR(ext_vbus);\r\next_id = extcon_get_edev_by_phandle(&pdev->dev, 1);\r\nif (IS_ERR(ext_id) && PTR_ERR(ext_id) != -ENODEV)\r\nreturn PTR_ERR(ext_id);\r\n}\r\nif (!IS_ERR(ext_vbus)) {\r\nmotg->vbus.extcon = ext_vbus;\r\nmotg->vbus.nb.notifier_call = msm_otg_vbus_notifier;\r\nret = devm_extcon_register_notifier(&pdev->dev, ext_vbus,\r\nEXTCON_USB, &motg->vbus.nb);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "register VBUS notifier failed\n");\r\nreturn ret;\r\n}\r\nret = extcon_get_state(ext_vbus, EXTCON_USB);\r\nif (ret)\r\nset_bit(B_SESS_VLD, &motg->inputs);\r\nelse\r\nclear_bit(B_SESS_VLD, &motg->inputs);\r\n}\r\nif (!IS_ERR(ext_id)) {\r\nmotg->id.extcon = ext_id;\r\nmotg->id.nb.notifier_call = msm_otg_id_notifier;\r\nret = devm_extcon_register_notifier(&pdev->dev, ext_id,\r\nEXTCON_USB_HOST, &motg->id.nb);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "register ID notifier failed\n");\r\nreturn ret;\r\n}\r\nret = extcon_get_state(ext_id, EXTCON_USB_HOST);\r\nif (ret)\r\nclear_bit(ID, &motg->inputs);\r\nelse\r\nset_bit(ID, &motg->inputs);\r\n}\r\nprop = of_find_property(node, "qcom,phy-init-sequence", &len);\r\nif (!prop || !len)\r\nreturn 0;\r\nwords = len / sizeof(u32);\r\nif (words >= ULPI_EXT_VENDOR_SPECIFIC) {\r\ndev_warn(&pdev->dev, "Too big PHY init sequence %d\n", words);\r\nreturn 0;\r\n}\r\npdata->phy_init_seq = devm_kzalloc(&pdev->dev, len, GFP_KERNEL);\r\nif (!pdata->phy_init_seq)\r\nreturn 0;\r\nret = of_property_read_u32_array(node, "qcom,phy-init-sequence",\r\npdata->phy_init_seq, words);\r\nif (!ret)\r\npdata->phy_init_sz = words;\r\nreturn 0;\r\n}\r\nstatic int msm_otg_reboot_notify(struct notifier_block *this,\r\nunsigned long code, void *unused)\r\n{\r\nstruct msm_otg *motg = container_of(this, struct msm_otg, reboot);\r\ngpiod_set_value_cansleep(motg->switch_gpio, 0);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int msm_otg_probe(struct platform_device *pdev)\r\n{\r\nstruct regulator_bulk_data regs[3];\r\nint ret = 0;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct msm_otg_platform_data *pdata;\r\nstruct resource *res;\r\nstruct msm_otg *motg;\r\nstruct usb_phy *phy;\r\nvoid __iomem *phy_select;\r\nmotg = devm_kzalloc(&pdev->dev, sizeof(struct msm_otg), GFP_KERNEL);\r\nif (!motg)\r\nreturn -ENOMEM;\r\nmotg->phy.otg = devm_kzalloc(&pdev->dev, sizeof(struct usb_otg),\r\nGFP_KERNEL);\r\nif (!motg->phy.otg)\r\nreturn -ENOMEM;\r\nphy = &motg->phy;\r\nphy->dev = &pdev->dev;\r\nmotg->clk = devm_clk_get(&pdev->dev, np ? "core" : "usb_hs_clk");\r\nif (IS_ERR(motg->clk)) {\r\ndev_err(&pdev->dev, "failed to get usb_hs_clk\n");\r\nreturn PTR_ERR(motg->clk);\r\n}\r\nmotg->pclk = devm_clk_get(&pdev->dev, np ? "iface" : "usb_hs_pclk");\r\nif (IS_ERR(motg->pclk)) {\r\ndev_err(&pdev->dev, "failed to get usb_hs_pclk\n");\r\nreturn PTR_ERR(motg->pclk);\r\n}\r\nmotg->core_clk = devm_clk_get(&pdev->dev,\r\nnp ? "alt_core" : "usb_hs_core_clk");\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -EINVAL;\r\nmotg->regs = devm_ioremap(&pdev->dev, res->start, resource_size(res));\r\nif (!motg->regs)\r\nreturn -ENOMEM;\r\npdata = dev_get_platdata(&pdev->dev);\r\nif (!pdata) {\r\nif (!np)\r\nreturn -ENXIO;\r\nret = msm_otg_read_dt(pdev, motg);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (motg->phy_number) {\r\nphy_select = devm_ioremap_nocache(&pdev->dev, USB2_PHY_SEL, 4);\r\nif (!phy_select)\r\nreturn -ENOMEM;\r\nwritel(0x1, phy_select);\r\n}\r\ndev_info(&pdev->dev, "OTG regs = %p\n", motg->regs);\r\nmotg->irq = platform_get_irq(pdev, 0);\r\nif (motg->irq < 0) {\r\ndev_err(&pdev->dev, "platform_get_irq failed\n");\r\nret = motg->irq;\r\nreturn motg->irq;\r\n}\r\nregs[0].supply = "vddcx";\r\nregs[1].supply = "v3p3";\r\nregs[2].supply = "v1p8";\r\nret = devm_regulator_bulk_get(motg->phy.dev, ARRAY_SIZE(regs), regs);\r\nif (ret)\r\nreturn ret;\r\nmotg->vddcx = regs[0].consumer;\r\nmotg->v3p3 = regs[1].consumer;\r\nmotg->v1p8 = regs[2].consumer;\r\nclk_set_rate(motg->clk, 60000000);\r\nclk_prepare_enable(motg->clk);\r\nclk_prepare_enable(motg->pclk);\r\nif (!IS_ERR(motg->core_clk))\r\nclk_prepare_enable(motg->core_clk);\r\nret = msm_hsusb_init_vddcx(motg, 1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "hsusb vddcx configuration failed\n");\r\ngoto disable_clks;\r\n}\r\nret = msm_hsusb_ldo_init(motg, 1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "hsusb vreg configuration failed\n");\r\ngoto disable_vddcx;\r\n}\r\nret = msm_hsusb_ldo_set_mode(motg, 1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "hsusb vreg enable failed\n");\r\ngoto disable_ldo;\r\n}\r\nwritel(0, USB_USBINTR);\r\nwritel(0, USB_OTGSC);\r\nINIT_WORK(&motg->sm_work, msm_otg_sm_work);\r\nINIT_DELAYED_WORK(&motg->chg_work, msm_chg_detect_work);\r\nret = devm_request_irq(&pdev->dev, motg->irq, msm_otg_irq, IRQF_SHARED,\r\n"msm_otg", motg);\r\nif (ret) {\r\ndev_err(&pdev->dev, "request irq failed\n");\r\ngoto disable_ldo;\r\n}\r\nphy->init = msm_phy_init;\r\nphy->notify_disconnect = msm_phy_notify_disconnect;\r\nphy->type = USB_PHY_TYPE_USB2;\r\nphy->io_ops = &msm_otg_io_ops;\r\nphy->otg->usb_phy = &motg->phy;\r\nphy->otg->set_host = msm_otg_set_host;\r\nphy->otg->set_peripheral = msm_otg_set_peripheral;\r\nmsm_usb_reset(phy);\r\nret = usb_add_phy_dev(&motg->phy);\r\nif (ret) {\r\ndev_err(&pdev->dev, "usb_add_phy failed\n");\r\ngoto disable_ldo;\r\n}\r\nplatform_set_drvdata(pdev, motg);\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nif (motg->pdata->mode == USB_DR_MODE_OTG &&\r\nmotg->pdata->otg_control == OTG_USER_CONTROL) {\r\nret = msm_otg_debugfs_init(motg);\r\nif (ret)\r\ndev_dbg(&pdev->dev, "Can not create mode change file\n");\r\n}\r\nif (test_bit(B_SESS_VLD, &motg->inputs)) {\r\ngpiod_set_value_cansleep(motg->switch_gpio, 0);\r\n} else {\r\ngpiod_set_value_cansleep(motg->switch_gpio, 1);\r\n}\r\nmotg->reboot.notifier_call = msm_otg_reboot_notify;\r\nregister_reboot_notifier(&motg->reboot);\r\npm_runtime_set_active(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\nreturn 0;\r\ndisable_ldo:\r\nmsm_hsusb_ldo_init(motg, 0);\r\ndisable_vddcx:\r\nmsm_hsusb_init_vddcx(motg, 0);\r\ndisable_clks:\r\nclk_disable_unprepare(motg->pclk);\r\nclk_disable_unprepare(motg->clk);\r\nif (!IS_ERR(motg->core_clk))\r\nclk_disable_unprepare(motg->core_clk);\r\nreturn ret;\r\n}\r\nstatic int msm_otg_remove(struct platform_device *pdev)\r\n{\r\nstruct msm_otg *motg = platform_get_drvdata(pdev);\r\nstruct usb_phy *phy = &motg->phy;\r\nint cnt = 0;\r\nif (phy->otg->host || phy->otg->gadget)\r\nreturn -EBUSY;\r\nunregister_reboot_notifier(&motg->reboot);\r\ngpiod_set_value_cansleep(motg->switch_gpio, 0);\r\nmsm_otg_debugfs_cleanup();\r\ncancel_delayed_work_sync(&motg->chg_work);\r\ncancel_work_sync(&motg->sm_work);\r\npm_runtime_resume(&pdev->dev);\r\ndevice_init_wakeup(&pdev->dev, 0);\r\npm_runtime_disable(&pdev->dev);\r\nusb_remove_phy(phy);\r\ndisable_irq(motg->irq);\r\nulpi_read(phy, 0x14);\r\nulpi_write(phy, 0x08, 0x09);\r\nwritel(readl(USB_PORTSC) | PORTSC_PHCD, USB_PORTSC);\r\nwhile (cnt < PHY_SUSPEND_TIMEOUT_USEC) {\r\nif (readl(USB_PORTSC) & PORTSC_PHCD)\r\nbreak;\r\nudelay(1);\r\ncnt++;\r\n}\r\nif (cnt >= PHY_SUSPEND_TIMEOUT_USEC)\r\ndev_err(phy->dev, "Unable to suspend PHY\n");\r\nclk_disable_unprepare(motg->pclk);\r\nclk_disable_unprepare(motg->clk);\r\nif (!IS_ERR(motg->core_clk))\r\nclk_disable_unprepare(motg->core_clk);\r\nmsm_hsusb_ldo_init(motg, 0);\r\npm_runtime_set_suspended(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int msm_otg_runtime_idle(struct device *dev)\r\n{\r\nstruct msm_otg *motg = dev_get_drvdata(dev);\r\nstruct usb_otg *otg = motg->phy.otg;\r\ndev_dbg(dev, "OTG runtime idle\n");\r\nif (otg->state != OTG_STATE_UNDEFINED)\r\npm_schedule_suspend(dev, 1000);\r\nreturn -EAGAIN;\r\n}\r\nstatic int msm_otg_runtime_suspend(struct device *dev)\r\n{\r\nstruct msm_otg *motg = dev_get_drvdata(dev);\r\ndev_dbg(dev, "OTG runtime suspend\n");\r\nreturn msm_otg_suspend(motg);\r\n}\r\nstatic int msm_otg_runtime_resume(struct device *dev)\r\n{\r\nstruct msm_otg *motg = dev_get_drvdata(dev);\r\ndev_dbg(dev, "OTG runtime resume\n");\r\nreturn msm_otg_resume(motg);\r\n}\r\nstatic int msm_otg_pm_suspend(struct device *dev)\r\n{\r\nstruct msm_otg *motg = dev_get_drvdata(dev);\r\ndev_dbg(dev, "OTG PM suspend\n");\r\nreturn msm_otg_suspend(motg);\r\n}\r\nstatic int msm_otg_pm_resume(struct device *dev)\r\n{\r\nstruct msm_otg *motg = dev_get_drvdata(dev);\r\nint ret;\r\ndev_dbg(dev, "OTG PM resume\n");\r\nret = msm_otg_resume(motg);\r\nif (ret)\r\nreturn ret;\r\npm_runtime_disable(dev);\r\npm_runtime_set_active(dev);\r\npm_runtime_enable(dev);\r\nreturn 0;\r\n}
