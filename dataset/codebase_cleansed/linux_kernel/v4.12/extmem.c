static int\r\ndcss_set_subcodes(void)\r\n{\r\nchar *name = kmalloc(8 * sizeof(char), GFP_KERNEL | GFP_DMA);\r\nunsigned long rx, ry;\r\nint rc;\r\nif (name == NULL)\r\nreturn -ENOMEM;\r\nrx = (unsigned long) name;\r\nry = DCSS_FINDSEGX;\r\nstrcpy(name, "dummy");\r\ndiag_stat_inc(DIAG_STAT_X064);\r\nasm volatile(\r\n" diag %0,%1,0x64\n"\r\n"0: ipm %2\n"\r\n" srl %2,28\n"\r\n" j 2f\n"\r\n"1: la %2,3\n"\r\n"2:\n"\r\nEX_TABLE(0b, 1b)\r\n: "+d" (rx), "+d" (ry), "=d" (rc) : : "cc", "memory");\r\nkfree(name);\r\nif (rc != 3) {\r\nloadshr_scode = DCSS_LOADSHRX;\r\nloadnsr_scode = DCSS_LOADNSRX;\r\npurgeseg_scode = DCSS_PURGESEG;\r\nsegext_scode = DCSS_SEGEXTX;\r\nreturn 0;\r\n}\r\nloadshr_scode = DCSS_LOADNOLY;\r\nloadnsr_scode = DCSS_LOADNSR;\r\npurgeseg_scode = DCSS_PURGESEG;\r\nsegext_scode = DCSS_SEGEXT;\r\nreturn 0;\r\n}\r\nstatic void\r\ndcss_mkname(char *name, char *dcss_name)\r\n{\r\nint i;\r\nfor (i = 0; i < 8; i++) {\r\nif (name[i] == '\0')\r\nbreak;\r\ndcss_name[i] = toupper(name[i]);\r\n}\r\nfor (; i < 8; i++)\r\ndcss_name[i] = ' ';\r\nASCEBC(dcss_name, 8);\r\n}\r\nstatic struct dcss_segment *\r\nsegment_by_name (char *name)\r\n{\r\nchar dcss_name[9];\r\nstruct list_head *l;\r\nstruct dcss_segment *tmp, *retval = NULL;\r\nBUG_ON(!mutex_is_locked(&dcss_lock));\r\ndcss_mkname (name, dcss_name);\r\nlist_for_each (l, &dcss_list) {\r\ntmp = list_entry (l, struct dcss_segment, list);\r\nif (memcmp(tmp->dcss_name, dcss_name, 8) == 0) {\r\nretval = tmp;\r\nbreak;\r\n}\r\n}\r\nreturn retval;\r\n}\r\nstatic inline int\r\ndcss_diag(int *func, void *parameter,\r\nunsigned long *ret1, unsigned long *ret2)\r\n{\r\nunsigned long rx, ry;\r\nint rc;\r\nif (scode_set == 0) {\r\nrc = dcss_set_subcodes();\r\nif (rc < 0)\r\nreturn rc;\r\nscode_set = 1;\r\n}\r\nrx = (unsigned long) parameter;\r\nry = (unsigned long) *func;\r\ndiag_stat_inc(DIAG_STAT_X064);\r\nif (*func > DCSS_SEGEXT)\r\nasm volatile(\r\n" diag %0,%1,0x64\n"\r\n" ipm %2\n"\r\n" srl %2,28\n"\r\n: "+d" (rx), "+d" (ry), "=d" (rc) : : "cc");\r\nelse\r\nasm volatile(\r\n" sam31\n"\r\n" diag %0,%1,0x64\n"\r\n" sam64\n"\r\n" ipm %2\n"\r\n" srl %2,28\n"\r\n: "+d" (rx), "+d" (ry), "=d" (rc) : : "cc");\r\n*ret1 = rx;\r\n*ret2 = ry;\r\nreturn rc;\r\n}\r\nstatic inline int\r\ndcss_diag_translate_rc (int vm_rc) {\r\nif (vm_rc == 44)\r\nreturn -ENOENT;\r\nreturn -EIO;\r\n}\r\nstatic int\r\nquery_segment_type (struct dcss_segment *seg)\r\n{\r\nunsigned long dummy, vmrc;\r\nint diag_cc, rc, i;\r\nstruct qout64 *qout;\r\nstruct qin64 *qin;\r\nqin = kmalloc(sizeof(*qin), GFP_KERNEL | GFP_DMA);\r\nqout = kmalloc(sizeof(*qout), GFP_KERNEL | GFP_DMA);\r\nif ((qin == NULL) || (qout == NULL)) {\r\nrc = -ENOMEM;\r\ngoto out_free;\r\n}\r\nqin->qopcode = DCSS_FINDSEGA;\r\nqin->qoutptr = (unsigned long) qout;\r\nqin->qoutlen = sizeof(struct qout64);\r\nmemcpy (qin->qname, seg->dcss_name, 8);\r\ndiag_cc = dcss_diag(&segext_scode, qin, &dummy, &vmrc);\r\nif (diag_cc < 0) {\r\nrc = diag_cc;\r\ngoto out_free;\r\n}\r\nif (diag_cc > 1) {\r\npr_warn("Querying a DCSS type failed with rc=%ld\n", vmrc);\r\nrc = dcss_diag_translate_rc (vmrc);\r\ngoto out_free;\r\n}\r\nif (segext_scode == DCSS_SEGEXT) {\r\nstruct qout64_old *qout_old;\r\nqout_old = kzalloc(sizeof(*qout_old), GFP_KERNEL | GFP_DMA);\r\nif (qout_old == NULL) {\r\nrc = -ENOMEM;\r\ngoto out_free;\r\n}\r\nmemcpy(qout_old, qout, sizeof(struct qout64_old));\r\nqout->segstart = (unsigned long) qout_old->segstart;\r\nqout->segend = (unsigned long) qout_old->segend;\r\nqout->segcnt = qout_old->segcnt;\r\nqout->segrcnt = qout_old->segrcnt;\r\nif (qout->segcnt > 6)\r\nqout->segrcnt = 6;\r\nfor (i = 0; i < qout->segrcnt; i++) {\r\nqout->range[i].start =\r\n(unsigned long) qout_old->range[i].start;\r\nqout->range[i].end =\r\n(unsigned long) qout_old->range[i].end;\r\n}\r\nkfree(qout_old);\r\n}\r\nif (qout->segcnt > 6) {\r\nrc = -EOPNOTSUPP;\r\ngoto out_free;\r\n}\r\nif (qout->segcnt == 1) {\r\nseg->vm_segtype = qout->range[0].start & 0xff;\r\n} else {\r\nunsigned long start = qout->segstart >> PAGE_SHIFT;\r\nfor (i=0; i<qout->segcnt; i++) {\r\nif (((qout->range[i].start & 0xff) != SEG_TYPE_EW) &&\r\n((qout->range[i].start & 0xff) != SEG_TYPE_EN)) {\r\nrc = -EOPNOTSUPP;\r\ngoto out_free;\r\n}\r\nif (start != qout->range[i].start >> PAGE_SHIFT) {\r\nrc = -EOPNOTSUPP;\r\ngoto out_free;\r\n}\r\nstart = (qout->range[i].end >> PAGE_SHIFT) + 1;\r\n}\r\nseg->vm_segtype = SEG_TYPE_EWEN;\r\n}\r\nseg->start_addr = qout->segstart;\r\nseg->end = qout->segend;\r\nmemcpy (seg->range, qout->range, 6*sizeof(struct qrange));\r\nseg->segcnt = qout->segcnt;\r\nrc = 0;\r\nout_free:\r\nkfree(qin);\r\nkfree(qout);\r\nreturn rc;\r\n}\r\nint\r\nsegment_type (char* name)\r\n{\r\nint rc;\r\nstruct dcss_segment seg;\r\nif (!MACHINE_IS_VM)\r\nreturn -ENOSYS;\r\ndcss_mkname(name, seg.dcss_name);\r\nrc = query_segment_type (&seg);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn seg.vm_segtype;\r\n}\r\nstatic int\r\nsegment_overlaps_others (struct dcss_segment *seg)\r\n{\r\nstruct list_head *l;\r\nstruct dcss_segment *tmp;\r\nBUG_ON(!mutex_is_locked(&dcss_lock));\r\nlist_for_each(l, &dcss_list) {\r\ntmp = list_entry(l, struct dcss_segment, list);\r\nif ((tmp->start_addr >> 20) > (seg->end >> 20))\r\ncontinue;\r\nif ((tmp->end >> 20) < (seg->start_addr >> 20))\r\ncontinue;\r\nif (seg == tmp)\r\ncontinue;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\n__segment_load (char *name, int do_nonshared, unsigned long *addr, unsigned long *end)\r\n{\r\nunsigned long start_addr, end_addr, dummy;\r\nstruct dcss_segment *seg;\r\nint rc, diag_cc;\r\nstart_addr = end_addr = 0;\r\nseg = kmalloc(sizeof(*seg), GFP_KERNEL | GFP_DMA);\r\nif (seg == NULL) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\ndcss_mkname (name, seg->dcss_name);\r\nrc = query_segment_type (seg);\r\nif (rc < 0)\r\ngoto out_free;\r\nif (loadshr_scode == DCSS_LOADSHRX) {\r\nif (segment_overlaps_others(seg)) {\r\nrc = -EBUSY;\r\ngoto out_free;\r\n}\r\n}\r\nrc = vmem_add_mapping(seg->start_addr, seg->end - seg->start_addr + 1);\r\nif (rc)\r\ngoto out_free;\r\nseg->res = kzalloc(sizeof(struct resource), GFP_KERNEL);\r\nif (seg->res == NULL) {\r\nrc = -ENOMEM;\r\ngoto out_shared;\r\n}\r\nseg->res->flags = IORESOURCE_BUSY | IORESOURCE_MEM;\r\nseg->res->start = seg->start_addr;\r\nseg->res->end = seg->end;\r\nmemcpy(&seg->res_name, seg->dcss_name, 8);\r\nEBCASC(seg->res_name, 8);\r\nseg->res_name[8] = '\0';\r\nstrncat(seg->res_name, " (DCSS)", 7);\r\nseg->res->name = seg->res_name;\r\nrc = seg->vm_segtype;\r\nif (rc == SEG_TYPE_SC ||\r\n((rc == SEG_TYPE_SR || rc == SEG_TYPE_ER) && !do_nonshared))\r\nseg->res->flags |= IORESOURCE_READONLY;\r\nif (request_resource(&iomem_resource, seg->res)) {\r\nrc = -EBUSY;\r\nkfree(seg->res);\r\ngoto out_shared;\r\n}\r\nif (do_nonshared)\r\ndiag_cc = dcss_diag(&loadnsr_scode, seg->dcss_name,\r\n&start_addr, &end_addr);\r\nelse\r\ndiag_cc = dcss_diag(&loadshr_scode, seg->dcss_name,\r\n&start_addr, &end_addr);\r\nif (diag_cc < 0) {\r\ndcss_diag(&purgeseg_scode, seg->dcss_name,\r\n&dummy, &dummy);\r\nrc = diag_cc;\r\ngoto out_resource;\r\n}\r\nif (diag_cc > 1) {\r\npr_warn("Loading DCSS %s failed with rc=%ld\n", name, end_addr);\r\nrc = dcss_diag_translate_rc(end_addr);\r\ndcss_diag(&purgeseg_scode, seg->dcss_name,\r\n&dummy, &dummy);\r\ngoto out_resource;\r\n}\r\nseg->start_addr = start_addr;\r\nseg->end = end_addr;\r\nseg->do_nonshared = do_nonshared;\r\natomic_set(&seg->ref_count, 1);\r\nlist_add(&seg->list, &dcss_list);\r\n*addr = seg->start_addr;\r\n*end = seg->end;\r\nif (do_nonshared)\r\npr_info("DCSS %s of range %p to %p and type %s loaded as "\r\n"exclusive-writable\n", name, (void*) seg->start_addr,\r\n(void*) seg->end, segtype_string[seg->vm_segtype]);\r\nelse {\r\npr_info("DCSS %s of range %p to %p and type %s loaded in "\r\n"shared access mode\n", name, (void*) seg->start_addr,\r\n(void*) seg->end, segtype_string[seg->vm_segtype]);\r\n}\r\ngoto out;\r\nout_resource:\r\nrelease_resource(seg->res);\r\nkfree(seg->res);\r\nout_shared:\r\nvmem_remove_mapping(seg->start_addr, seg->end - seg->start_addr + 1);\r\nout_free:\r\nkfree(seg);\r\nout:\r\nreturn rc;\r\n}\r\nint\r\nsegment_load (char *name, int do_nonshared, unsigned long *addr,\r\nunsigned long *end)\r\n{\r\nstruct dcss_segment *seg;\r\nint rc;\r\nif (!MACHINE_IS_VM)\r\nreturn -ENOSYS;\r\nmutex_lock(&dcss_lock);\r\nseg = segment_by_name (name);\r\nif (seg == NULL)\r\nrc = __segment_load (name, do_nonshared, addr, end);\r\nelse {\r\nif (do_nonshared == seg->do_nonshared) {\r\natomic_inc(&seg->ref_count);\r\n*addr = seg->start_addr;\r\n*end = seg->end;\r\nrc = seg->vm_segtype;\r\n} else {\r\n*addr = *end = 0;\r\nrc = -EPERM;\r\n}\r\n}\r\nmutex_unlock(&dcss_lock);\r\nreturn rc;\r\n}\r\nint\r\nsegment_modify_shared (char *name, int do_nonshared)\r\n{\r\nstruct dcss_segment *seg;\r\nunsigned long start_addr, end_addr, dummy;\r\nint rc, diag_cc;\r\nstart_addr = end_addr = 0;\r\nmutex_lock(&dcss_lock);\r\nseg = segment_by_name (name);\r\nif (seg == NULL) {\r\nrc = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nif (do_nonshared == seg->do_nonshared) {\r\npr_info("DCSS %s is already in the requested access "\r\n"mode\n", name);\r\nrc = 0;\r\ngoto out_unlock;\r\n}\r\nif (atomic_read (&seg->ref_count) != 1) {\r\npr_warn("DCSS %s is in use and cannot be reloaded\n", name);\r\nrc = -EAGAIN;\r\ngoto out_unlock;\r\n}\r\nrelease_resource(seg->res);\r\nif (do_nonshared)\r\nseg->res->flags &= ~IORESOURCE_READONLY;\r\nelse\r\nif (seg->vm_segtype == SEG_TYPE_SR ||\r\nseg->vm_segtype == SEG_TYPE_ER)\r\nseg->res->flags |= IORESOURCE_READONLY;\r\nif (request_resource(&iomem_resource, seg->res)) {\r\npr_warn("DCSS %s overlaps with used memory resources and cannot be reloaded\n",\r\nname);\r\nrc = -EBUSY;\r\nkfree(seg->res);\r\ngoto out_del_mem;\r\n}\r\ndcss_diag(&purgeseg_scode, seg->dcss_name, &dummy, &dummy);\r\nif (do_nonshared)\r\ndiag_cc = dcss_diag(&loadnsr_scode, seg->dcss_name,\r\n&start_addr, &end_addr);\r\nelse\r\ndiag_cc = dcss_diag(&loadshr_scode, seg->dcss_name,\r\n&start_addr, &end_addr);\r\nif (diag_cc < 0) {\r\nrc = diag_cc;\r\ngoto out_del_res;\r\n}\r\nif (diag_cc > 1) {\r\npr_warn("Reloading DCSS %s failed with rc=%ld\n",\r\nname, end_addr);\r\nrc = dcss_diag_translate_rc(end_addr);\r\ngoto out_del_res;\r\n}\r\nseg->start_addr = start_addr;\r\nseg->end = end_addr;\r\nseg->do_nonshared = do_nonshared;\r\nrc = 0;\r\ngoto out_unlock;\r\nout_del_res:\r\nrelease_resource(seg->res);\r\nkfree(seg->res);\r\nout_del_mem:\r\nvmem_remove_mapping(seg->start_addr, seg->end - seg->start_addr + 1);\r\nlist_del(&seg->list);\r\ndcss_diag(&purgeseg_scode, seg->dcss_name, &dummy, &dummy);\r\nkfree(seg);\r\nout_unlock:\r\nmutex_unlock(&dcss_lock);\r\nreturn rc;\r\n}\r\nvoid\r\nsegment_unload(char *name)\r\n{\r\nunsigned long dummy;\r\nstruct dcss_segment *seg;\r\nif (!MACHINE_IS_VM)\r\nreturn;\r\nmutex_lock(&dcss_lock);\r\nseg = segment_by_name (name);\r\nif (seg == NULL) {\r\npr_err("Unloading unknown DCSS %s failed\n", name);\r\ngoto out_unlock;\r\n}\r\nif (atomic_dec_return(&seg->ref_count) != 0)\r\ngoto out_unlock;\r\nrelease_resource(seg->res);\r\nkfree(seg->res);\r\nvmem_remove_mapping(seg->start_addr, seg->end - seg->start_addr + 1);\r\nlist_del(&seg->list);\r\ndcss_diag(&purgeseg_scode, seg->dcss_name, &dummy, &dummy);\r\nkfree(seg);\r\nout_unlock:\r\nmutex_unlock(&dcss_lock);\r\n}\r\nvoid\r\nsegment_save(char *name)\r\n{\r\nstruct dcss_segment *seg;\r\nchar cmd1[160];\r\nchar cmd2[80];\r\nint i, response;\r\nif (!MACHINE_IS_VM)\r\nreturn;\r\nmutex_lock(&dcss_lock);\r\nseg = segment_by_name (name);\r\nif (seg == NULL) {\r\npr_err("Saving unknown DCSS %s failed\n", name);\r\ngoto out;\r\n}\r\nsprintf(cmd1, "DEFSEG %s", name);\r\nfor (i=0; i<seg->segcnt; i++) {\r\nsprintf(cmd1+strlen(cmd1), " %lX-%lX %s",\r\nseg->range[i].start >> PAGE_SHIFT,\r\nseg->range[i].end >> PAGE_SHIFT,\r\nsegtype_string[seg->range[i].start & 0xff]);\r\n}\r\nsprintf(cmd2, "SAVESEG %s", name);\r\nresponse = 0;\r\ncpcmd(cmd1, NULL, 0, &response);\r\nif (response) {\r\npr_err("Saving a DCSS failed with DEFSEG response code "\r\n"%i\n", response);\r\ngoto out;\r\n}\r\ncpcmd(cmd2, NULL, 0, &response);\r\nif (response) {\r\npr_err("Saving a DCSS failed with SAVESEG response code "\r\n"%i\n", response);\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&dcss_lock);\r\n}\r\nvoid segment_warning(int rc, char *seg_name)\r\n{\r\nswitch (rc) {\r\ncase -ENOENT:\r\npr_err("DCSS %s cannot be loaded or queried\n", seg_name);\r\nbreak;\r\ncase -ENOSYS:\r\npr_err("DCSS %s cannot be loaded or queried without "\r\n"z/VM\n", seg_name);\r\nbreak;\r\ncase -EIO:\r\npr_err("Loading or querying DCSS %s resulted in a "\r\n"hardware error\n", seg_name);\r\nbreak;\r\ncase -EOPNOTSUPP:\r\npr_err("DCSS %s has multiple page ranges and cannot be "\r\n"loaded or queried\n", seg_name);\r\nbreak;\r\ncase -ENOSPC:\r\npr_err("DCSS %s overlaps with used storage and cannot "\r\n"be loaded\n", seg_name);\r\nbreak;\r\ncase -EBUSY:\r\npr_err("%s needs used memory resources and cannot be "\r\n"loaded or queried\n", seg_name);\r\nbreak;\r\ncase -EPERM:\r\npr_err("DCSS %s is already loaded in a different access "\r\n"mode\n", seg_name);\r\nbreak;\r\ncase -ENOMEM:\r\npr_err("There is not enough memory to load or query "\r\n"DCSS %s\n", seg_name);\r\nbreak;\r\ncase -ERANGE:\r\npr_err("DCSS %s exceeds the kernel mapping range (%lu) "\r\n"and cannot be loaded\n", seg_name, VMEM_MAX_PHYS);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}
