static inline u32 ti_iodelay_extract(u32 val, u32 mask)\r\n{\r\nreturn (val & mask) >> __ffs(mask);\r\n}\r\nstatic inline u32 ti_iodelay_compute_dpe(u16 period, u16 ref, u16 delay,\r\nu16 delay_m)\r\n{\r\nu64 m, d;\r\nm = 10 * (u64)period * (u64)ref;\r\nd = 2 * (u64)delay * (u64)delay_m;\r\nreturn div64_u64(m, d);\r\n}\r\nstatic int ti_iodelay_pinconf_set(struct ti_iodelay_device *iod,\r\nstruct ti_iodelay_cfg *cfg)\r\n{\r\nconst struct ti_iodelay_reg_data *reg = iod->reg_data;\r\nstruct ti_iodelay_reg_values *ival = &iod->reg_init_conf_values;\r\nstruct device *dev = iod->dev;\r\nu32 g_delay_coarse, g_delay_fine;\r\nu32 a_delay_coarse, a_delay_fine;\r\nu32 c_elements, f_elements;\r\nu32 total_delay;\r\nu32 reg_mask, reg_val, tmp_val;\r\nint r;\r\ng_delay_coarse = cfg->g_delay / 920;\r\ng_delay_fine = ((cfg->g_delay % 920) * 10) / 60;\r\na_delay_coarse = cfg->a_delay / ival->cdpe;\r\na_delay_fine = ((cfg->a_delay % ival->cdpe) * 10) / ival->fdpe;\r\nc_elements = g_delay_coarse + a_delay_coarse;\r\nf_elements = (g_delay_fine + a_delay_fine) / 10;\r\nif (f_elements > 22) {\r\ntotal_delay = c_elements * ival->cdpe + f_elements * ival->fdpe;\r\nc_elements = total_delay / ival->cdpe;\r\nf_elements = (total_delay % ival->cdpe) / ival->fdpe;\r\n}\r\nreg_mask = reg->signature_mask;\r\nreg_val = reg->signature_value << __ffs(reg->signature_mask);\r\nreg_mask |= reg->binary_data_coarse_mask;\r\ntmp_val = c_elements << __ffs(reg->binary_data_coarse_mask);\r\nif (tmp_val & ~reg->binary_data_coarse_mask) {\r\ndev_err(dev, "Masking overflow of coarse elements %08x\n",\r\ntmp_val);\r\ntmp_val &= reg->binary_data_coarse_mask;\r\n}\r\nreg_val |= tmp_val;\r\nreg_mask |= reg->binary_data_fine_mask;\r\ntmp_val = f_elements << __ffs(reg->binary_data_fine_mask);\r\nif (tmp_val & ~reg->binary_data_fine_mask) {\r\ndev_err(dev, "Masking overflow of fine elements %08x\n",\r\ntmp_val);\r\ntmp_val &= reg->binary_data_fine_mask;\r\n}\r\nreg_val |= tmp_val;\r\nreg_mask |= reg->lock_mask;\r\nreg_val |= reg->unlock_val << __ffs(reg->lock_mask);\r\nr = regmap_update_bits(iod->regmap, cfg->offset, reg_mask, reg_val);\r\ndev_info(dev, "Set reg 0x%x Delay(a: %d g: %d), Elements(C=%d F=%d)0x%x\n",\r\ncfg->offset, cfg->a_delay, cfg->g_delay, c_elements,\r\nf_elements, reg_val);\r\nreturn r;\r\n}\r\nstatic int ti_iodelay_pinconf_init_dev(struct ti_iodelay_device *iod)\r\n{\r\nconst struct ti_iodelay_reg_data *reg = iod->reg_data;\r\nstruct device *dev = iod->dev;\r\nstruct ti_iodelay_reg_values *ival = &iod->reg_init_conf_values;\r\nu32 val;\r\nint r;\r\nr = regmap_update_bits(iod->regmap, reg->reg_global_lock_offset,\r\nreg->global_lock_mask, reg->global_unlock_val);\r\nif (r)\r\nreturn r;\r\nr = regmap_read(iod->regmap, reg->reg_refclk_offset, &val);\r\nif (r)\r\nreturn r;\r\nival->ref_clk_period = ti_iodelay_extract(val, reg->refclk_period_mask);\r\ndev_dbg(dev, "refclk_period=0x%04x\n", ival->ref_clk_period);\r\nr = regmap_read(iod->regmap, reg->reg_coarse_offset, &val);\r\nif (r)\r\nreturn r;\r\nival->coarse_ref_count =\r\nti_iodelay_extract(val, reg->coarse_ref_count_mask);\r\nival->coarse_delay_count =\r\nti_iodelay_extract(val, reg->coarse_delay_count_mask);\r\nif (!ival->coarse_delay_count) {\r\ndev_err(dev, "Invalid Coarse delay count (0) (reg=0x%08x)\n",\r\nval);\r\nreturn -EINVAL;\r\n}\r\nival->cdpe = ti_iodelay_compute_dpe(ival->ref_clk_period,\r\nival->coarse_ref_count,\r\nival->coarse_delay_count, 88);\r\nif (!ival->cdpe) {\r\ndev_err(dev, "Invalid cdpe computed params = %d %d %d\n",\r\nival->ref_clk_period, ival->coarse_ref_count,\r\nival->coarse_delay_count);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(iod->dev, "coarse: ref=0x%04x delay=0x%04x cdpe=0x%08x\n",\r\nival->coarse_ref_count, ival->coarse_delay_count, ival->cdpe);\r\nr = regmap_read(iod->regmap, reg->reg_fine_offset, &val);\r\nif (r)\r\nreturn r;\r\nival->fine_ref_count =\r\nti_iodelay_extract(val, reg->fine_ref_count_mask);\r\nival->fine_delay_count =\r\nti_iodelay_extract(val, reg->fine_delay_count_mask);\r\nif (!ival->fine_delay_count) {\r\ndev_err(dev, "Invalid Fine delay count (0) (reg=0x%08x)\n",\r\nval);\r\nreturn -EINVAL;\r\n}\r\nival->fdpe = ti_iodelay_compute_dpe(ival->ref_clk_period,\r\nival->fine_ref_count,\r\nival->fine_delay_count, 264);\r\nif (!ival->fdpe) {\r\ndev_err(dev, "Invalid fdpe(0) computed params = %d %d %d\n",\r\nival->ref_clk_period, ival->fine_ref_count,\r\nival->fine_delay_count);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(iod->dev, "fine: ref=0x%04x delay=0x%04x fdpe=0x%08x\n",\r\nival->fine_ref_count, ival->fine_delay_count, ival->fdpe);\r\nreturn 0;\r\n}\r\nstatic void ti_iodelay_pinconf_deinit_dev(struct ti_iodelay_device *iod)\r\n{\r\nconst struct ti_iodelay_reg_data *reg = iod->reg_data;\r\nregmap_update_bits(iod->regmap, reg->reg_global_lock_offset,\r\nreg->global_lock_mask, reg->global_lock_val);\r\n}\r\nstatic struct ti_iodelay_pingroup *\r\nti_iodelay_get_pingroup(struct ti_iodelay_device *iod, unsigned int selector)\r\n{\r\nstruct group_desc *g;\r\ng = pinctrl_generic_get_group(iod->pctl, selector);\r\nif (!g) {\r\ndev_err(iod->dev, "%s could not find pingroup %i\n", __func__,\r\nselector);\r\nreturn NULL;\r\n}\r\nreturn g->data;\r\n}\r\nstatic int ti_iodelay_offset_to_pin(struct ti_iodelay_device *iod,\r\nunsigned int offset)\r\n{\r\nconst struct ti_iodelay_reg_data *r = iod->reg_data;\r\nunsigned int index;\r\nif (offset > r->regmap_config->max_register) {\r\ndev_err(iod->dev, "mux offset out of range: 0x%x (0x%x)\n",\r\noffset, r->regmap_config->max_register);\r\nreturn -EINVAL;\r\n}\r\nindex = (offset - r->reg_start_offset) / r->regmap_config->reg_stride;\r\nindex /= r->reg_nr_per_pin;\r\nreturn index;\r\n}\r\nstatic int ti_iodelay_node_iterator(struct pinctrl_dev *pctldev,\r\nstruct device_node *np,\r\nconst struct of_phandle_args *pinctrl_spec,\r\nint *pins, int pin_index, void *data)\r\n{\r\nstruct ti_iodelay_device *iod;\r\nstruct ti_iodelay_cfg *cfg = data;\r\nconst struct ti_iodelay_reg_data *r;\r\nstruct pinctrl_pin_desc *pd;\r\nint pin;\r\niod = pinctrl_dev_get_drvdata(pctldev);\r\nif (!iod)\r\nreturn -EINVAL;\r\nr = iod->reg_data;\r\nif (pinctrl_spec->args_count < r->reg_nr_per_pin) {\r\ndev_err(iod->dev, "invalid args_count for spec: %i\n",\r\npinctrl_spec->args_count);\r\nreturn -EINVAL;\r\n}\r\ncfg[pin_index].offset = pinctrl_spec->args[0];\r\ncfg[pin_index].a_delay = pinctrl_spec->args[1] & 0xffff;\r\ncfg[pin_index].g_delay = pinctrl_spec->args[2] & 0xffff;\r\npin = ti_iodelay_offset_to_pin(iod, cfg[pin_index].offset);\r\nif (pin < 0) {\r\ndev_err(iod->dev, "could not add functions for %s %ux\n",\r\nnp->name, cfg[pin_index].offset);\r\nreturn -ENODEV;\r\n}\r\npins[pin_index] = pin;\r\npd = &iod->pa[pin];\r\npd->drv_data = &cfg[pin_index];\r\ndev_dbg(iod->dev, "%s offset=%x a_delay = %d g_delay = %d\n",\r\nnp->name, cfg[pin_index].offset, cfg[pin_index].a_delay,\r\ncfg[pin_index].g_delay);\r\nreturn 0;\r\n}\r\nstatic int ti_iodelay_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np,\r\nstruct pinctrl_map **map,\r\nunsigned int *num_maps)\r\n{\r\nstruct ti_iodelay_device *iod;\r\nstruct ti_iodelay_cfg *cfg;\r\nstruct ti_iodelay_pingroup *g;\r\nconst char *name = "pinctrl-pin-array";\r\nint rows, *pins, error = -EINVAL, i;\r\niod = pinctrl_dev_get_drvdata(pctldev);\r\nif (!iod)\r\nreturn -EINVAL;\r\nrows = pinctrl_count_index_with_args(np, name);\r\nif (rows == -EINVAL)\r\nreturn rows;\r\n*map = devm_kzalloc(iod->dev, sizeof(**map), GFP_KERNEL);\r\nif (!*map)\r\nreturn -ENOMEM;\r\n*num_maps = 0;\r\ng = devm_kzalloc(iod->dev, sizeof(*g), GFP_KERNEL);\r\nif (!g) {\r\nerror = -ENOMEM;\r\ngoto free_map;\r\n}\r\npins = devm_kzalloc(iod->dev, sizeof(*pins) * rows, GFP_KERNEL);\r\nif (!pins)\r\ngoto free_group;\r\ncfg = devm_kzalloc(iod->dev, sizeof(*cfg) * rows, GFP_KERNEL);\r\nif (!cfg) {\r\nerror = -ENOMEM;\r\ngoto free_pins;\r\n}\r\nfor (i = 0; i < rows; i++) {\r\nstruct of_phandle_args pinctrl_spec;\r\nerror = pinctrl_parse_index_with_args(np, name, i,\r\n&pinctrl_spec);\r\nif (error)\r\ngoto free_data;\r\nerror = ti_iodelay_node_iterator(pctldev, np, &pinctrl_spec,\r\npins, i, cfg);\r\nif (error)\r\ngoto free_data;\r\n}\r\ng->cfg = cfg;\r\ng->ncfg = i;\r\ng->config = PIN_CONFIG_END;\r\nerror = pinctrl_generic_add_group(iod->pctl, np->name, pins, i, g);\r\nif (error < 0)\r\ngoto free_data;\r\n(*map)->type = PIN_MAP_TYPE_CONFIGS_GROUP;\r\n(*map)->data.configs.group_or_pin = np->name;\r\n(*map)->data.configs.configs = &g->config;\r\n(*map)->data.configs.num_configs = 1;\r\n*num_maps = 1;\r\nreturn 0;\r\nfree_data:\r\ndevm_kfree(iod->dev, cfg);\r\nfree_pins:\r\ndevm_kfree(iod->dev, pins);\r\nfree_group:\r\ndevm_kfree(iod->dev, g);\r\nfree_map:\r\ndevm_kfree(iod->dev, *map);\r\nreturn error;\r\n}\r\nstatic int ti_iodelay_pinconf_group_get(struct pinctrl_dev *pctldev,\r\nunsigned int selector,\r\nunsigned long *config)\r\n{\r\nstruct ti_iodelay_device *iod;\r\nstruct device *dev;\r\nstruct ti_iodelay_pingroup *group;\r\niod = pinctrl_dev_get_drvdata(pctldev);\r\ndev = iod->dev;\r\ngroup = ti_iodelay_get_pingroup(iod, selector);\r\nif (!group)\r\nreturn -EINVAL;\r\n*config = group->config;\r\nreturn 0;\r\n}\r\nstatic int ti_iodelay_pinconf_group_set(struct pinctrl_dev *pctldev,\r\nunsigned int selector,\r\nunsigned long *configs,\r\nunsigned int num_configs)\r\n{\r\nstruct ti_iodelay_device *iod;\r\nstruct device *dev;\r\nstruct ti_iodelay_pingroup *group;\r\nint i;\r\niod = pinctrl_dev_get_drvdata(pctldev);\r\ndev = iod->dev;\r\ngroup = ti_iodelay_get_pingroup(iod, selector);\r\nif (num_configs != 1) {\r\ndev_err(dev, "Unsupported number of configurations %d\n",\r\nnum_configs);\r\nreturn -EINVAL;\r\n}\r\nif (*configs != PIN_CONFIG_END) {\r\ndev_err(dev, "Unsupported configuration\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < group->ncfg; i++) {\r\nif (ti_iodelay_pinconf_set(iod, &group->cfg[i]))\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int ti_iodelay_pin_to_offset(struct ti_iodelay_device *iod,\r\nunsigned int selector)\r\n{\r\nconst struct ti_iodelay_reg_data *r = iod->reg_data;\r\nunsigned int offset;\r\noffset = selector * r->regmap_config->reg_stride;\r\noffset *= r->reg_nr_per_pin;\r\noffset += r->reg_start_offset;\r\nreturn offset;\r\n}\r\nstatic void ti_iodelay_pin_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s,\r\nunsigned int pin)\r\n{\r\nstruct ti_iodelay_device *iod;\r\nstruct pinctrl_pin_desc *pd;\r\nstruct ti_iodelay_cfg *cfg;\r\nconst struct ti_iodelay_reg_data *r;\r\nunsigned long offset;\r\nu32 in, oen, out;\r\niod = pinctrl_dev_get_drvdata(pctldev);\r\nr = iod->reg_data;\r\noffset = ti_iodelay_pin_to_offset(iod, pin);\r\npd = &iod->pa[pin];\r\ncfg = pd->drv_data;\r\nregmap_read(iod->regmap, offset, &in);\r\nregmap_read(iod->regmap, offset + r->regmap_config->reg_stride, &oen);\r\nregmap_read(iod->regmap, offset + r->regmap_config->reg_stride * 2,\r\n&out);\r\nseq_printf(s, "%lx a: %i g: %i (%08x %08x %08x) %s ",\r\niod->phys_base + offset,\r\ncfg ? cfg->a_delay : -1,\r\ncfg ? cfg->g_delay : -1,\r\nin, oen, out, DRIVER_NAME);\r\n}\r\nstatic void ti_iodelay_pinconf_group_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s,\r\nunsigned int selector)\r\n{\r\nstruct ti_iodelay_device *iod;\r\nstruct device *dev;\r\nstruct ti_iodelay_pingroup *group;\r\nint i;\r\niod = pinctrl_dev_get_drvdata(pctldev);\r\ndev = iod->dev;\r\ngroup = ti_iodelay_get_pingroup(iod, selector);\r\nif (!group)\r\nreturn;\r\nfor (i = 0; i < group->ncfg; i++) {\r\nstruct ti_iodelay_cfg *cfg;\r\nu32 reg = 0;\r\ncfg = &group->cfg[i];\r\nregmap_read(iod->regmap, cfg->offset, &reg),\r\nseq_printf(s, "\n\t0x%08x = 0x%08x (%3d, %3d)",\r\ncfg->offset, reg, cfg->a_delay,\r\ncfg->g_delay);\r\n}\r\n}\r\nstatic int ti_iodelay_alloc_pins(struct device *dev,\r\nstruct ti_iodelay_device *iod, u32 base_phy)\r\n{\r\nconst struct ti_iodelay_reg_data *r = iod->reg_data;\r\nstruct pinctrl_pin_desc *pin;\r\nu32 phy_reg;\r\nint nr_pins, i;\r\nnr_pins = ti_iodelay_offset_to_pin(iod, r->regmap_config->max_register);\r\ndev_dbg(dev, "Allocating %i pins\n", nr_pins);\r\niod->pa = devm_kzalloc(dev, sizeof(*iod->pa) * nr_pins, GFP_KERNEL);\r\nif (!iod->pa)\r\nreturn -ENOMEM;\r\niod->desc.pins = iod->pa;\r\niod->desc.npins = nr_pins;\r\nphy_reg = r->reg_start_offset + base_phy;\r\nfor (i = 0; i < nr_pins; i++, phy_reg += 4) {\r\npin = &iod->pa[i];\r\npin->number = i;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ti_iodelay_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = of_node_get(dev->of_node);\r\nconst struct of_device_id *match;\r\nstruct resource *res;\r\nstruct ti_iodelay_device *iod;\r\nint ret = 0;\r\nif (!np) {\r\nret = -EINVAL;\r\ndev_err(dev, "No OF node\n");\r\ngoto exit_out;\r\n}\r\nmatch = of_match_device(ti_iodelay_of_match, dev);\r\nif (!match) {\r\nret = -EINVAL;\r\ndev_err(dev, "No DATA match\n");\r\ngoto exit_out;\r\n}\r\niod = devm_kzalloc(dev, sizeof(*iod), GFP_KERNEL);\r\nif (!iod) {\r\nret = -ENOMEM;\r\ngoto exit_out;\r\n}\r\niod->dev = dev;\r\niod->reg_data = match->data;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(dev, "Missing MEM resource\n");\r\nret = -ENODEV;\r\ngoto exit_out;\r\n}\r\niod->phys_base = res->start;\r\niod->reg_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(iod->reg_base)) {\r\nret = PTR_ERR(iod->reg_base);\r\ngoto exit_out;\r\n}\r\niod->regmap = devm_regmap_init_mmio(dev, iod->reg_base,\r\niod->reg_data->regmap_config);\r\nif (IS_ERR(iod->regmap)) {\r\ndev_err(dev, "Regmap MMIO init failed.\n");\r\nret = PTR_ERR(iod->regmap);\r\ngoto exit_out;\r\n}\r\nif (ti_iodelay_pinconf_init_dev(iod))\r\ngoto exit_out;\r\nret = ti_iodelay_alloc_pins(dev, iod, res->start);\r\nif (ret)\r\ngoto exit_out;\r\niod->desc.pctlops = &ti_iodelay_pinctrl_ops;\r\niod->desc.confops = &ti_iodelay_pinctrl_pinconf_ops;\r\niod->desc.name = dev_name(dev);\r\niod->desc.owner = THIS_MODULE;\r\nret = pinctrl_register_and_init(&iod->desc, dev, iod, &iod->pctl);\r\nif (ret) {\r\ndev_err(dev, "Failed to register pinctrl\n");\r\ngoto exit_out;\r\n}\r\nplatform_set_drvdata(pdev, iod);\r\nreturn pinctrl_enable(iod->pctl);\r\nexit_out:\r\nof_node_put(np);\r\nreturn ret;\r\n}\r\nstatic int ti_iodelay_remove(struct platform_device *pdev)\r\n{\r\nstruct ti_iodelay_device *iod = platform_get_drvdata(pdev);\r\nif (!iod)\r\nreturn 0;\r\nif (iod->pctl)\r\npinctrl_unregister(iod->pctl);\r\nti_iodelay_pinconf_deinit_dev(iod);\r\nreturn 0;\r\n}
