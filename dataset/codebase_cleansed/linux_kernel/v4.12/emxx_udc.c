static inline u32 _nbu2ss_readl(void *address)\r\n{\r\nreturn __raw_readl(address);\r\n}\r\nstatic inline void _nbu2ss_writel(void *address, u32 udata)\r\n{\r\n__raw_writel(udata, address);\r\n}\r\nstatic inline void _nbu2ss_bitset(void *address, u32 udata)\r\n{\r\nu32 reg_dt = __raw_readl(address) | (udata);\r\n__raw_writel(reg_dt, address);\r\n}\r\nstatic inline void _nbu2ss_bitclr(void *address, u32 udata)\r\n{\r\nu32 reg_dt = __raw_readl(address) & ~(udata);\r\n__raw_writel(reg_dt, address);\r\n}\r\nstatic void _nbu2ss_dump_register(struct nbu2ss_udc *udc)\r\n{\r\nint i;\r\nu32 reg_data;\r\npr_info("=== %s()\n", __func__);\r\nif (!udc) {\r\npr_err("%s udc == NULL\n", __func__);\r\nreturn;\r\n}\r\nspin_unlock(&udc->lock);\r\ndev_dbg(&udc->dev, "\n-USB REG-\n");\r\nfor (i = 0x0 ; i < USB_BASE_SIZE ; i += 16) {\r\nreg_data = _nbu2ss_readl(\r\n(u32 *)IO_ADDRESS(USB_BASE_ADDRESS + i));\r\ndev_dbg(&udc->dev, "USB%04x =%08x", i, (int)reg_data);\r\nreg_data = _nbu2ss_readl(\r\n(u32 *)IO_ADDRESS(USB_BASE_ADDRESS + i + 4));\r\ndev_dbg(&udc->dev, " %08x", (int)reg_data);\r\nreg_data = _nbu2ss_readl(\r\n(u32 *)IO_ADDRESS(USB_BASE_ADDRESS + i + 8));\r\ndev_dbg(&udc->dev, " %08x", (int)reg_data);\r\nreg_data = _nbu2ss_readl(\r\n(u32 *)IO_ADDRESS(USB_BASE_ADDRESS + i + 12));\r\ndev_dbg(&udc->dev, " %08x\n", (int)reg_data);\r\n}\r\nspin_lock(&udc->lock);\r\n}\r\nstatic void _nbu2ss_ep0_complete(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nu8 recipient;\r\nu16 selector;\r\nu32 test_mode;\r\nstruct usb_ctrlrequest *p_ctrl;\r\nstruct nbu2ss_udc *udc;\r\nif ((!_ep) || (!_req))\r\nreturn;\r\nudc = (struct nbu2ss_udc *)_req->context;\r\np_ctrl = &udc->ctrl;\r\nif ((p_ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {\r\nif (p_ctrl->bRequest == USB_REQ_SET_FEATURE) {\r\nrecipient = (u8)(p_ctrl->bRequestType & USB_RECIP_MASK);\r\nselector = p_ctrl->wValue;\r\nif ((recipient == USB_RECIP_DEVICE) &&\r\n(selector == USB_DEVICE_TEST_MODE)) {\r\ntest_mode = (u32)(p_ctrl->wIndex >> 8);\r\n_nbu2ss_set_test_mode(udc, test_mode);\r\n}\r\n}\r\n}\r\n}\r\nstatic void _nbu2ss_create_ep0_packet(\r\nstruct nbu2ss_udc *udc,\r\nvoid *p_buf,\r\nunsigned length\r\n)\r\n{\r\nudc->ep0_req.req.buf = p_buf;\r\nudc->ep0_req.req.length = length;\r\nudc->ep0_req.req.dma = 0;\r\nudc->ep0_req.req.zero = TRUE;\r\nudc->ep0_req.req.complete = _nbu2ss_ep0_complete;\r\nudc->ep0_req.req.status = -EINPROGRESS;\r\nudc->ep0_req.req.context = udc;\r\nudc->ep0_req.req.actual = 0;\r\n}\r\nstatic u32 _nbu2ss_get_begin_ram_address(struct nbu2ss_udc *udc)\r\n{\r\nu32 num, buf_type;\r\nu32 data, last_ram_adr, use_ram_size;\r\nstruct ep_regs *p_ep_regs;\r\nlast_ram_adr = (D_RAM_SIZE_CTRL / sizeof(u32)) * 2;\r\nuse_ram_size = 0;\r\nfor (num = 0; num < NUM_ENDPOINTS - 1; num++) {\r\np_ep_regs = &udc->p_regs->EP_REGS[num];\r\ndata = _nbu2ss_readl(&p_ep_regs->EP_PCKT_ADRS);\r\nbuf_type = _nbu2ss_readl(&p_ep_regs->EP_CONTROL) & EPn_BUF_TYPE;\r\nif (buf_type == 0) {\r\nuse_ram_size += (data & EPn_MPKT) / sizeof(u32);\r\n} else {\r\nuse_ram_size += ((data & EPn_MPKT) / sizeof(u32)) * 2;\r\n}\r\nif ((data >> 16) > last_ram_adr)\r\nlast_ram_adr = data >> 16;\r\n}\r\nreturn last_ram_adr + use_ram_size;\r\n}\r\nstatic int _nbu2ss_ep_init(struct nbu2ss_udc *udc, struct nbu2ss_ep *ep)\r\n{\r\nu32 num;\r\nu32 data;\r\nu32 begin_adrs;\r\nif (ep->epnum == 0)\r\nreturn -EINVAL;\r\nnum = ep->epnum - 1;\r\nbegin_adrs = _nbu2ss_get_begin_ram_address(udc);\r\ndata = (begin_adrs << 16) | ep->ep.maxpacket;\r\n_nbu2ss_writel(&udc->p_regs->EP_REGS[num].EP_PCKT_ADRS, data);\r\ndata = 1 << (ep->epnum + 8);\r\n_nbu2ss_bitset(&udc->p_regs->USB_INT_ENA, data);\r\nswitch (ep->ep_type) {\r\ncase USB_ENDPOINT_XFER_BULK:\r\ndata = EPn_BULK;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\ndata = EPn_BUF_SINGLE | EPn_INTERRUPT;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\ndata = EPn_ISO;\r\nbreak;\r\ndefault:\r\ndata = 0;\r\nbreak;\r\n}\r\n_nbu2ss_bitset(&udc->p_regs->EP_REGS[num].EP_CONTROL, data);\r\n_nbu2ss_endpoint_toggle_reset(udc, (ep->epnum | ep->direct));\r\nif (ep->direct == USB_DIR_OUT) {\r\ndata = EPn_EN | EPn_BCLR | EPn_DIR0;\r\n_nbu2ss_bitset(&udc->p_regs->EP_REGS[num].EP_CONTROL, data);\r\ndata = EPn_ONAK | EPn_OSTL_EN | EPn_OSTL;\r\n_nbu2ss_bitclr(&udc->p_regs->EP_REGS[num].EP_CONTROL, data);\r\ndata = EPn_OUT_EN | EPn_OUT_END_EN;\r\n_nbu2ss_bitset(&udc->p_regs->EP_REGS[num].EP_INT_ENA, data);\r\n} else {\r\ndata = EPn_EN | EPn_BCLR | EPn_AUTO;\r\n_nbu2ss_bitset(&udc->p_regs->EP_REGS[num].EP_CONTROL, data);\r\ndata = EPn_ISTL;\r\n_nbu2ss_bitclr(&udc->p_regs->EP_REGS[num].EP_CONTROL, data);\r\ndata = EPn_IN_EN | EPn_IN_END_EN;\r\n_nbu2ss_bitset(&udc->p_regs->EP_REGS[num].EP_INT_ENA, data);\r\n}\r\nreturn 0;\r\n}\r\nstatic int _nbu2ss_epn_exit(struct nbu2ss_udc *udc, struct nbu2ss_ep *ep)\r\n{\r\nu32 num;\r\nu32 data;\r\nif ((ep->epnum == 0) || (udc->vbus_active == 0))\r\nreturn -EINVAL;\r\nnum = ep->epnum - 1;\r\n_nbu2ss_writel(&udc->p_regs->EP_REGS[num].EP_PCKT_ADRS, 0);\r\ndata = 1 << (ep->epnum + 8);\r\n_nbu2ss_bitclr(&udc->p_regs->USB_INT_ENA, data);\r\nif (ep->direct == USB_DIR_OUT) {\r\ndata = EPn_ONAK | EPn_BCLR;\r\n_nbu2ss_bitset(&udc->p_regs->EP_REGS[num].EP_CONTROL, data);\r\ndata = EPn_EN | EPn_DIR0;\r\n_nbu2ss_bitclr(&udc->p_regs->EP_REGS[num].EP_CONTROL, data);\r\ndata = EPn_OUT_EN | EPn_OUT_END_EN;\r\n_nbu2ss_bitclr(&udc->p_regs->EP_REGS[num].EP_INT_ENA, data);\r\n} else {\r\ndata = EPn_BCLR;\r\n_nbu2ss_bitset(&udc->p_regs->EP_REGS[num].EP_CONTROL, data);\r\ndata = EPn_EN | EPn_AUTO;\r\n_nbu2ss_bitclr(&udc->p_regs->EP_REGS[num].EP_CONTROL, data);\r\ndata = EPn_IN_EN | EPn_IN_END_EN;\r\n_nbu2ss_bitclr(&udc->p_regs->EP_REGS[num].EP_INT_ENA, data);\r\n}\r\nreturn 0;\r\n}\r\nstatic void _nbu2ss_ep_dma_init(struct nbu2ss_udc *udc, struct nbu2ss_ep *ep)\r\n{\r\nu32 num;\r\nu32 data;\r\ndata = _nbu2ss_readl(&udc->p_regs->USBSSCONF);\r\nif (((ep->epnum == 0) || (data & (1 << ep->epnum)) == 0))\r\nreturn;\r\nnum = ep->epnum - 1;\r\nif (ep->direct == USB_DIR_OUT) {\r\ndata = ep->ep.maxpacket;\r\n_nbu2ss_writel(&udc->p_regs->EP_DCR[num].EP_DCR2, data);\r\ndata = DCR1_EPn_DIR0;\r\n_nbu2ss_bitset(&udc->p_regs->EP_DCR[num].EP_DCR1, data);\r\ndata = EPn_STOP_MODE | EPn_STOP_SET | EPn_DMAMODE0;\r\n_nbu2ss_writel(&udc->p_regs->EP_REGS[num].EP_DMA_CTRL, data);\r\n} else {\r\n_nbu2ss_bitset(&udc->p_regs->EP_REGS[num].EP_CONTROL, EPn_AUTO);\r\ndata = EPn_BURST_SET | EPn_DMAMODE0;\r\n_nbu2ss_writel(&udc->p_regs->EP_REGS[num].EP_DMA_CTRL, data);\r\n}\r\n}\r\nstatic void _nbu2ss_ep_dma_exit(struct nbu2ss_udc *udc, struct nbu2ss_ep *ep)\r\n{\r\nu32 num;\r\nu32 data;\r\nstruct fc_regs *preg = udc->p_regs;\r\nif (udc->vbus_active == 0)\r\nreturn;\r\ndata = _nbu2ss_readl(&preg->USBSSCONF);\r\nif ((ep->epnum == 0) || ((data & (1 << ep->epnum)) == 0))\r\nreturn;\r\nnum = ep->epnum - 1;\r\n_nbu2ss_ep_dma_abort(udc, ep);\r\nif (ep->direct == USB_DIR_OUT) {\r\n_nbu2ss_writel(&preg->EP_DCR[num].EP_DCR2, 0);\r\n_nbu2ss_bitclr(&preg->EP_DCR[num].EP_DCR1, DCR1_EPn_DIR0);\r\n_nbu2ss_writel(&preg->EP_REGS[num].EP_DMA_CTRL, 0);\r\n} else {\r\n_nbu2ss_bitclr(&preg->EP_REGS[num].EP_CONTROL, EPn_AUTO);\r\n_nbu2ss_writel(&preg->EP_REGS[num].EP_DMA_CTRL, 0);\r\n}\r\n}\r\nstatic void _nbu2ss_ep_dma_abort(struct nbu2ss_udc *udc, struct nbu2ss_ep *ep)\r\n{\r\nstruct fc_regs *preg = udc->p_regs;\r\n_nbu2ss_bitclr(&preg->EP_DCR[ep->epnum - 1].EP_DCR1, DCR1_EPn_REQEN);\r\nmdelay(DMA_DISABLE_TIME);\r\n_nbu2ss_bitclr(&preg->EP_REGS[ep->epnum - 1].EP_DMA_CTRL, EPn_DMA_EN);\r\n}\r\nstatic void _nbu2ss_ep_in_end(\r\nstruct nbu2ss_udc *udc,\r\nu32 epnum,\r\nu32 data32,\r\nu32 length\r\n)\r\n{\r\nu32 data;\r\nu32 num;\r\nstruct fc_regs *preg = udc->p_regs;\r\nif (length >= sizeof(u32))\r\nreturn;\r\nif (epnum == 0) {\r\n_nbu2ss_bitclr(&preg->EP0_CONTROL, EP0_AUTO);\r\nif (length)\r\n_nbu2ss_writel(&preg->EP0_WRITE, data32);\r\ndata = ((length << 5) & EP0_DW) | EP0_DEND;\r\n_nbu2ss_writel(&preg->EP0_CONTROL, data);\r\n_nbu2ss_bitset(&preg->EP0_CONTROL, EP0_AUTO);\r\n} else {\r\nnum = epnum - 1;\r\n_nbu2ss_bitclr(&preg->EP_REGS[num].EP_CONTROL, EPn_AUTO);\r\nif (length)\r\n_nbu2ss_writel(&preg->EP_REGS[num].EP_WRITE, data32);\r\ndata = (((length) << 5) & EPn_DW) | EPn_DEND;\r\n_nbu2ss_bitset(&preg->EP_REGS[num].EP_CONTROL, data);\r\n_nbu2ss_bitset(&preg->EP_REGS[num].EP_CONTROL, EPn_AUTO);\r\n}\r\n}\r\nstatic void _nbu2ss_dma_map_single(\r\nstruct nbu2ss_udc *udc,\r\nstruct nbu2ss_ep *ep,\r\nstruct nbu2ss_req *req,\r\nu8 direct\r\n)\r\n{\r\nif (req->req.dma == DMA_ADDR_INVALID) {\r\nif (req->unaligned) {\r\nreq->req.dma = ep->phys_buf;\r\n} else {\r\nreq->req.dma = dma_map_single(\r\nudc->gadget.dev.parent,\r\nreq->req.buf,\r\nreq->req.length,\r\n(direct == USB_DIR_IN)\r\n? DMA_TO_DEVICE : DMA_FROM_DEVICE);\r\n}\r\nreq->mapped = 1;\r\n} else {\r\nif (!req->unaligned)\r\ndma_sync_single_for_device(\r\nudc->gadget.dev.parent,\r\nreq->req.dma,\r\nreq->req.length,\r\n(direct == USB_DIR_IN)\r\n? DMA_TO_DEVICE : DMA_FROM_DEVICE);\r\nreq->mapped = 0;\r\n}\r\n}\r\nstatic void _nbu2ss_dma_unmap_single(\r\nstruct nbu2ss_udc *udc,\r\nstruct nbu2ss_ep *ep,\r\nstruct nbu2ss_req *req,\r\nu8 direct\r\n)\r\n{\r\nu8 data[4];\r\nu8 *p;\r\nu32 count = 0;\r\nif (direct == USB_DIR_OUT) {\r\ncount = req->req.actual % 4;\r\nif (count) {\r\np = req->req.buf;\r\np += (req->req.actual - count);\r\nmemcpy(data, p, count);\r\n}\r\n}\r\nif (req->mapped) {\r\nif (req->unaligned) {\r\nif (direct == USB_DIR_OUT)\r\nmemcpy(req->req.buf, ep->virt_buf,\r\nreq->req.actual & 0xfffffffc);\r\n} else\r\ndma_unmap_single(udc->gadget.dev.parent,\r\nreq->req.dma, req->req.length,\r\n(direct == USB_DIR_IN)\r\n? DMA_TO_DEVICE\r\n: DMA_FROM_DEVICE);\r\nreq->req.dma = DMA_ADDR_INVALID;\r\nreq->mapped = 0;\r\n} else {\r\nif (!req->unaligned)\r\ndma_sync_single_for_cpu(udc->gadget.dev.parent,\r\nreq->req.dma, req->req.length,\r\n(direct == USB_DIR_IN)\r\n? DMA_TO_DEVICE\r\n: DMA_FROM_DEVICE);\r\n}\r\nif (count) {\r\np = req->req.buf;\r\np += (req->req.actual - count);\r\nmemcpy(p, data, count);\r\n}\r\n}\r\nstatic int ep0_out_pio(struct nbu2ss_udc *udc, u8 *buf, u32 length)\r\n{\r\nu32 i;\r\nu32 numreads = length / sizeof(u32);\r\nunion usb_reg_access *buf32 = (union usb_reg_access *)buf;\r\nif (!numreads)\r\nreturn 0;\r\nfor (i = 0; i < numreads; i++) {\r\nbuf32->dw = _nbu2ss_readl(&udc->p_regs->EP0_READ);\r\nbuf32++;\r\n}\r\nreturn numreads * sizeof(u32);\r\n}\r\nstatic int EP0_out_OverBytes(struct nbu2ss_udc *udc, u8 *pBuf, u32 length)\r\n{\r\nu32 i;\r\nu32 iReadSize = 0;\r\nunion usb_reg_access Temp32;\r\nunion usb_reg_access *pBuf32 = (union usb_reg_access *)pBuf;\r\nif ((length > 0) && (length < sizeof(u32))) {\r\nTemp32.dw = _nbu2ss_readl(&udc->p_regs->EP0_READ);\r\nfor (i = 0 ; i < length ; i++)\r\npBuf32->byte.DATA[i] = Temp32.byte.DATA[i];\r\niReadSize += length;\r\n}\r\nreturn iReadSize;\r\n}\r\nstatic int EP0_in_PIO(struct nbu2ss_udc *udc, u8 *pBuf, u32 length)\r\n{\r\nu32 i;\r\nu32 iMaxLength = EP0_PACKETSIZE;\r\nu32 iWordLength = 0;\r\nu32 iWriteLength = 0;\r\nunion usb_reg_access *pBuf32 = (union usb_reg_access *)pBuf;\r\nif (iMaxLength < length)\r\niWordLength = iMaxLength / sizeof(u32);\r\nelse\r\niWordLength = length / sizeof(u32);\r\nfor (i = 0; i < iWordLength; i++) {\r\n_nbu2ss_writel(&udc->p_regs->EP0_WRITE, pBuf32->dw);\r\npBuf32++;\r\niWriteLength += sizeof(u32);\r\n}\r\nreturn iWriteLength;\r\n}\r\nstatic int EP0_in_OverBytes(struct nbu2ss_udc *udc, u8 *pBuf, u32 iRemainSize)\r\n{\r\nu32 i;\r\nunion usb_reg_access Temp32;\r\nunion usb_reg_access *pBuf32 = (union usb_reg_access *)pBuf;\r\nif ((iRemainSize > 0) && (iRemainSize < sizeof(u32))) {\r\nfor (i = 0 ; i < iRemainSize ; i++)\r\nTemp32.byte.DATA[i] = pBuf32->byte.DATA[i];\r\n_nbu2ss_ep_in_end(udc, 0, Temp32.dw, iRemainSize);\r\nreturn iRemainSize;\r\n}\r\nreturn 0;\r\n}\r\nstatic int EP0_send_NULL(struct nbu2ss_udc *udc, bool pid_flag)\r\n{\r\nu32 data;\r\ndata = _nbu2ss_readl(&udc->p_regs->EP0_CONTROL);\r\ndata &= ~(u32)EP0_INAK;\r\nif (pid_flag)\r\ndata |= (EP0_INAK_EN | EP0_PIDCLR | EP0_DEND);\r\nelse\r\ndata |= (EP0_INAK_EN | EP0_DEND);\r\n_nbu2ss_writel(&udc->p_regs->EP0_CONTROL, data);\r\nreturn 0;\r\n}\r\nstatic int EP0_receive_NULL(struct nbu2ss_udc *udc, bool pid_flag)\r\n{\r\nu32 data;\r\ndata = _nbu2ss_readl(&udc->p_regs->EP0_CONTROL);\r\ndata &= ~(u32)EP0_ONAK;\r\nif (pid_flag)\r\ndata |= EP0_PIDCLR;\r\n_nbu2ss_writel(&udc->p_regs->EP0_CONTROL, data);\r\nreturn 0;\r\n}\r\nstatic int _nbu2ss_ep0_in_transfer(\r\nstruct nbu2ss_udc *udc,\r\nstruct nbu2ss_req *req\r\n)\r\n{\r\nu8 *pBuffer;\r\nu32 data;\r\nu32 iRemainSize = 0;\r\nint result = 0;\r\nif (req->req.actual == req->req.length) {\r\nif ((req->req.actual % EP0_PACKETSIZE) == 0) {\r\nif (req->zero) {\r\nreq->zero = false;\r\nEP0_send_NULL(udc, FALSE);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\ndata = _nbu2ss_readl(&udc->p_regs->EP0_CONTROL);\r\ndata |= EP0_INAK_EN;\r\ndata &= ~(u32)EP0_INAK;\r\n_nbu2ss_writel(&udc->p_regs->EP0_CONTROL, data);\r\niRemainSize = req->req.length - req->req.actual;\r\npBuffer = (u8 *)req->req.buf;\r\npBuffer += req->req.actual;\r\nresult = EP0_in_PIO(udc, pBuffer, iRemainSize);\r\nreq->div_len = result;\r\niRemainSize -= result;\r\nif (iRemainSize == 0) {\r\nEP0_send_NULL(udc, FALSE);\r\nreturn result;\r\n}\r\nif ((iRemainSize < sizeof(u32)) && (result != EP0_PACKETSIZE)) {\r\npBuffer += result;\r\nresult += EP0_in_OverBytes(udc, pBuffer, iRemainSize);\r\nreq->div_len = result;\r\n}\r\nreturn result;\r\n}\r\nstatic int _nbu2ss_ep0_out_transfer(\r\nstruct nbu2ss_udc *udc,\r\nstruct nbu2ss_req *req\r\n)\r\n{\r\nu8 *pBuffer;\r\nu32 iRemainSize;\r\nu32 iRecvLength;\r\nint result = 0;\r\nint fRcvZero;\r\niRecvLength = _nbu2ss_readl(&udc->p_regs->EP0_LENGTH) & EP0_LDATA;\r\nif (iRecvLength != 0) {\r\nfRcvZero = 0;\r\niRemainSize = req->req.length - req->req.actual;\r\npBuffer = (u8 *)req->req.buf;\r\npBuffer += req->req.actual;\r\nresult = ep0_out_pio(udc, pBuffer\r\n, min(iRemainSize, iRecvLength));\r\nif (result < 0)\r\nreturn result;\r\nreq->req.actual += result;\r\niRecvLength -= result;\r\nif ((iRecvLength > 0) && (iRecvLength < sizeof(u32))) {\r\npBuffer += result;\r\niRemainSize -= result;\r\nresult = EP0_out_OverBytes(udc, pBuffer\r\n, min(iRemainSize, iRecvLength));\r\nreq->req.actual += result;\r\n}\r\n} else {\r\nfRcvZero = 1;\r\n}\r\nif (req->req.actual == req->req.length) {\r\nif ((req->req.actual % EP0_PACKETSIZE) == 0) {\r\nif (req->zero) {\r\nreq->zero = false;\r\nEP0_receive_NULL(udc, FALSE);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nif ((req->req.actual % EP0_PACKETSIZE) != 0)\r\nreturn 0;\r\nif (req->req.actual > req->req.length) {\r\ndev_err(udc->dev, " *** Overrun Error\n");\r\nreturn -EOVERFLOW;\r\n}\r\nif (fRcvZero != 0) {\r\niRemainSize = _nbu2ss_readl(&udc->p_regs->EP0_CONTROL);\r\nif (iRemainSize & EP0_ONAK) {\r\n_nbu2ss_bitclr(&udc->p_regs->EP0_CONTROL, EP0_ONAK);\r\n}\r\nresult = 1;\r\n}\r\nreturn result;\r\n}\r\nstatic int _nbu2ss_out_dma(\r\nstruct nbu2ss_udc *udc,\r\nstruct nbu2ss_req *req,\r\nu32 num,\r\nu32 length\r\n)\r\n{\r\ndma_addr_t pBuffer;\r\nu32 mpkt;\r\nu32 lmpkt;\r\nu32 dmacnt;\r\nu32 burst = 1;\r\nu32 data;\r\nint result = -EINVAL;\r\nstruct fc_regs *preg = udc->p_regs;\r\nif (req->dma_flag)\r\nreturn 1;\r\nreq->dma_flag = TRUE;\r\npBuffer = req->req.dma;\r\npBuffer += req->req.actual;\r\n_nbu2ss_writel(&preg->EP_DCR[num].EP_TADR, (u32)pBuffer);\r\nmpkt = _nbu2ss_readl(&preg->EP_REGS[num].EP_PCKT_ADRS) & EPn_MPKT;\r\ndmacnt = length / mpkt;\r\nlmpkt = (length % mpkt) & ~(u32)0x03;\r\nif (dmacnt > DMA_MAX_COUNT) {\r\ndmacnt = DMA_MAX_COUNT;\r\nlmpkt = 0;\r\n} else if (lmpkt != 0) {\r\nif (dmacnt == 0)\r\nburst = 0;\r\ndmacnt++;\r\n}\r\ndata = mpkt | (lmpkt << 16);\r\n_nbu2ss_writel(&preg->EP_DCR[num].EP_DCR2, data);\r\ndata = ((dmacnt & 0xff) << 16) | DCR1_EPn_DIR0 | DCR1_EPn_REQEN;\r\n_nbu2ss_writel(&preg->EP_DCR[num].EP_DCR1, data);\r\nif (burst == 0) {\r\n_nbu2ss_writel(&preg->EP_REGS[num].EP_LEN_DCNT, 0);\r\n_nbu2ss_bitclr(&preg->EP_REGS[num].EP_DMA_CTRL, EPn_BURST_SET);\r\n} else {\r\n_nbu2ss_writel(&preg->EP_REGS[num].EP_LEN_DCNT\r\n, (dmacnt << 16));\r\n_nbu2ss_bitset(&preg->EP_REGS[num].EP_DMA_CTRL, EPn_BURST_SET);\r\n}\r\n_nbu2ss_bitset(&preg->EP_REGS[num].EP_DMA_CTRL, EPn_DMA_EN);\r\nresult = length & ~(u32)0x03;\r\nreq->div_len = result;\r\nreturn result;\r\n}\r\nstatic int _nbu2ss_epn_out_pio(\r\nstruct nbu2ss_udc *udc,\r\nstruct nbu2ss_ep *ep,\r\nstruct nbu2ss_req *req,\r\nu32 length\r\n)\r\n{\r\nu8 *pBuffer;\r\nu32 i;\r\nu32 data;\r\nu32 iWordLength;\r\nunion usb_reg_access Temp32;\r\nunion usb_reg_access *pBuf32;\r\nint result = 0;\r\nstruct fc_regs *preg = udc->p_regs;\r\nif (req->dma_flag)\r\nreturn 1;\r\nif (length == 0)\r\nreturn 0;\r\npBuffer = (u8 *)req->req.buf;\r\npBuf32 = (union usb_reg_access *)(pBuffer + req->req.actual);\r\niWordLength = length / sizeof(u32);\r\nif (iWordLength > 0) {\r\nfor (i = 0; i < iWordLength; i++) {\r\npBuf32->dw =\r\n_nbu2ss_readl(&preg->EP_REGS[ep->epnum - 1].EP_READ);\r\npBuf32++;\r\n}\r\nresult = iWordLength * sizeof(u32);\r\n}\r\ndata = length - result;\r\nif (data > 0) {\r\nTemp32.dw = _nbu2ss_readl(&preg->EP_REGS[ep->epnum - 1].EP_READ);\r\nfor (i = 0 ; i < data ; i++)\r\npBuf32->byte.DATA[i] = Temp32.byte.DATA[i];\r\nresult += data;\r\n}\r\nreq->req.actual += result;\r\nif ((req->req.actual == req->req.length) ||\r\n((req->req.actual % ep->ep.maxpacket) != 0)) {\r\nresult = 0;\r\n}\r\nreturn result;\r\n}\r\nstatic int _nbu2ss_epn_out_data(\r\nstruct nbu2ss_udc *udc,\r\nstruct nbu2ss_ep *ep,\r\nstruct nbu2ss_req *req,\r\nu32 data_size\r\n)\r\n{\r\nu32 num;\r\nu32 iBufSize;\r\nint nret = 1;\r\nif (ep->epnum == 0)\r\nreturn -EINVAL;\r\nnum = ep->epnum - 1;\r\niBufSize = min((req->req.length - req->req.actual), data_size);\r\nif ((ep->ep_type != USB_ENDPOINT_XFER_INT) && (req->req.dma != 0) &&\r\n(iBufSize >= sizeof(u32))) {\r\nnret = _nbu2ss_out_dma(udc, req, num, iBufSize);\r\n} else {\r\niBufSize = min_t(u32, iBufSize, ep->ep.maxpacket);\r\nnret = _nbu2ss_epn_out_pio(udc, ep, req, iBufSize);\r\n}\r\nreturn nret;\r\n}\r\nstatic int _nbu2ss_epn_out_transfer(\r\nstruct nbu2ss_udc *udc,\r\nstruct nbu2ss_ep *ep,\r\nstruct nbu2ss_req *req\r\n)\r\n{\r\nu32 num;\r\nu32 iRecvLength;\r\nint result = 1;\r\nstruct fc_regs *preg = udc->p_regs;\r\nif (ep->epnum == 0)\r\nreturn -EINVAL;\r\nnum = ep->epnum - 1;\r\niRecvLength\r\n= _nbu2ss_readl(&preg->EP_REGS[num].EP_LEN_DCNT) & EPn_LDATA;\r\nif (iRecvLength != 0) {\r\nresult = _nbu2ss_epn_out_data(udc, ep, req, iRecvLength);\r\nif (iRecvLength < ep->ep.maxpacket) {\r\nif (iRecvLength == result) {\r\nreq->req.actual += result;\r\nresult = 0;\r\n}\r\n}\r\n} else {\r\nif ((req->req.actual == req->req.length) ||\r\n((req->req.actual % ep->ep.maxpacket) != 0)) {\r\nresult = 0;\r\n}\r\n}\r\nif (result == 0) {\r\nif ((req->req.actual % ep->ep.maxpacket) == 0) {\r\nif (req->zero) {\r\nreq->zero = false;\r\nreturn 1;\r\n}\r\n}\r\n}\r\nif (req->req.actual > req->req.length) {\r\ndev_err(udc->dev, " Overrun Error\n");\r\ndev_err(udc->dev, " actual = %d, length = %d\n",\r\nreq->req.actual, req->req.length);\r\nresult = -EOVERFLOW;\r\n}\r\nreturn result;\r\n}\r\nstatic int _nbu2ss_in_dma(\r\nstruct nbu2ss_udc *udc,\r\nstruct nbu2ss_ep *ep,\r\nstruct nbu2ss_req *req,\r\nu32 num,\r\nu32 length\r\n)\r\n{\r\ndma_addr_t pBuffer;\r\nu32 mpkt;\r\nu32 lmpkt;\r\nu32 dmacnt;\r\nu32 iWriteLength;\r\nu32 data;\r\nint result = -EINVAL;\r\nstruct fc_regs *preg = udc->p_regs;\r\nif (req->dma_flag)\r\nreturn 1;\r\n#ifdef USE_DMA\r\nif (req->req.actual == 0)\r\n_nbu2ss_dma_map_single(udc, ep, req, USB_DIR_IN);\r\n#endif\r\nreq->dma_flag = TRUE;\r\nmpkt = _nbu2ss_readl(&preg->EP_REGS[num].EP_PCKT_ADRS) & EPn_MPKT;\r\nif ((DMA_MAX_COUNT * mpkt) < length)\r\niWriteLength = DMA_MAX_COUNT * mpkt;\r\nelse\r\niWriteLength = length;\r\nif (mpkt < iWriteLength) {\r\ndmacnt = iWriteLength / mpkt;\r\nlmpkt = (iWriteLength % mpkt) & ~(u32)0x3;\r\nif (lmpkt != 0)\r\ndmacnt++;\r\nelse\r\nlmpkt = mpkt & ~(u32)0x3;\r\n} else {\r\ndmacnt = 1;\r\nlmpkt = iWriteLength & ~(u32)0x3;\r\n}\r\ndata = mpkt | (lmpkt << 16);\r\n_nbu2ss_writel(&preg->EP_DCR[num].EP_DCR2, data);\r\npBuffer = req->req.dma;\r\npBuffer += req->req.actual;\r\n_nbu2ss_writel(&preg->EP_DCR[num].EP_TADR, (u32)pBuffer);\r\ndata = ((dmacnt & 0xff) << 16) | DCR1_EPn_REQEN;\r\n_nbu2ss_writel(&preg->EP_DCR[num].EP_DCR1, data);\r\ndata = dmacnt << 16;\r\n_nbu2ss_writel(&preg->EP_REGS[num].EP_LEN_DCNT, data);\r\n_nbu2ss_bitset(&preg->EP_REGS[num].EP_DMA_CTRL, EPn_DMA_EN);\r\nresult = iWriteLength & ~(u32)0x3;\r\nreq->div_len = result;\r\nreturn result;\r\n}\r\nstatic int _nbu2ss_epn_in_pio(\r\nstruct nbu2ss_udc *udc,\r\nstruct nbu2ss_ep *ep,\r\nstruct nbu2ss_req *req,\r\nu32 length\r\n)\r\n{\r\nu8 *pBuffer;\r\nu32 i;\r\nu32 data;\r\nu32 iWordLength;\r\nunion usb_reg_access Temp32;\r\nunion usb_reg_access *pBuf32 = NULL;\r\nint result = 0;\r\nstruct fc_regs *preg = udc->p_regs;\r\nif (req->dma_flag)\r\nreturn 1;\r\nif (length > 0) {\r\npBuffer = (u8 *)req->req.buf;\r\npBuf32 = (union usb_reg_access *)(pBuffer + req->req.actual);\r\niWordLength = length / sizeof(u32);\r\nif (iWordLength > 0) {\r\nfor (i = 0; i < iWordLength; i++) {\r\n_nbu2ss_writel(\r\n&preg->EP_REGS[ep->epnum - 1].EP_WRITE\r\n, pBuf32->dw\r\n);\r\npBuf32++;\r\n}\r\nresult = iWordLength * sizeof(u32);\r\n}\r\n}\r\nif (result != ep->ep.maxpacket) {\r\ndata = length - result;\r\nTemp32.dw = 0;\r\nfor (i = 0 ; i < data ; i++)\r\nTemp32.byte.DATA[i] = pBuf32->byte.DATA[i];\r\n_nbu2ss_ep_in_end(udc, ep->epnum, Temp32.dw, data);\r\nresult += data;\r\n}\r\nreq->div_len = result;\r\nreturn result;\r\n}\r\nstatic int _nbu2ss_epn_in_data(\r\nstruct nbu2ss_udc *udc,\r\nstruct nbu2ss_ep *ep,\r\nstruct nbu2ss_req *req,\r\nu32 data_size\r\n)\r\n{\r\nu32 num;\r\nint nret = 1;\r\nif (ep->epnum == 0)\r\nreturn -EINVAL;\r\nnum = ep->epnum - 1;\r\nif ((ep->ep_type != USB_ENDPOINT_XFER_INT) && (req->req.dma != 0) &&\r\n(data_size >= sizeof(u32))) {\r\nnret = _nbu2ss_in_dma(udc, ep, req, num, data_size);\r\n} else {\r\ndata_size = min_t(u32, data_size, ep->ep.maxpacket);\r\nnret = _nbu2ss_epn_in_pio(udc, ep, req, data_size);\r\n}\r\nreturn nret;\r\n}\r\nstatic int _nbu2ss_epn_in_transfer(\r\nstruct nbu2ss_udc *udc,\r\nstruct nbu2ss_ep *ep,\r\nstruct nbu2ss_req *req\r\n)\r\n{\r\nu32 num;\r\nu32 iBufSize;\r\nint result = 0;\r\nu32 status;\r\nif (ep->epnum == 0)\r\nreturn -EINVAL;\r\nnum = ep->epnum - 1;\r\nstatus = _nbu2ss_readl(&udc->p_regs->EP_REGS[num].EP_STATUS);\r\nif (req->req.actual == 0) {\r\nif ((status & EPn_IN_EMPTY) == 0)\r\nreturn 1;\r\n} else {\r\nif ((status & EPn_IN_FULL) != 0)\r\nreturn 1;\r\n}\r\niBufSize = req->req.length - req->req.actual;\r\nif (iBufSize > 0)\r\nresult = _nbu2ss_epn_in_data(udc, ep, req, iBufSize);\r\nelse if (req->req.length == 0)\r\n_nbu2ss_zero_len_pkt(udc, ep->epnum);\r\nreturn result;\r\n}\r\nstatic int _nbu2ss_start_transfer(\r\nstruct nbu2ss_udc *udc,\r\nstruct nbu2ss_ep *ep,\r\nstruct nbu2ss_req *req,\r\nbool bflag)\r\n{\r\nint nret = -EINVAL;\r\nreq->dma_flag = FALSE;\r\nreq->div_len = 0;\r\nif (req->req.length == 0) {\r\nreq->zero = false;\r\n} else {\r\nif ((req->req.length % ep->ep.maxpacket) == 0)\r\nreq->zero = req->req.zero;\r\nelse\r\nreq->zero = false;\r\n}\r\nif (ep->epnum == 0) {\r\nswitch (udc->ep0state) {\r\ncase EP0_IN_DATA_PHASE:\r\nnret = _nbu2ss_ep0_in_transfer(udc, req);\r\nbreak;\r\ncase EP0_OUT_DATA_PHASE:\r\nnret = _nbu2ss_ep0_out_transfer(udc, req);\r\nbreak;\r\ncase EP0_IN_STATUS_PHASE:\r\nnret = EP0_send_NULL(udc, TRUE);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nif (ep->direct == USB_DIR_OUT) {\r\nif (!bflag)\r\nnret = _nbu2ss_epn_out_transfer(udc, ep, req);\r\n} else {\r\nnret = _nbu2ss_epn_in_transfer(udc, ep, req);\r\n}\r\n}\r\nreturn nret;\r\n}\r\nstatic void _nbu2ss_restert_transfer(struct nbu2ss_ep *ep)\r\n{\r\nu32 length;\r\nbool bflag = FALSE;\r\nstruct nbu2ss_req *req;\r\nreq = list_first_entry_or_null(&ep->queue, struct nbu2ss_req, queue);\r\nif (!req)\r\nreturn;\r\nif (ep->epnum > 0) {\r\nlength = _nbu2ss_readl(\r\n&ep->udc->p_regs->EP_REGS[ep->epnum - 1].EP_LEN_DCNT);\r\nlength &= EPn_LDATA;\r\nif (length < ep->ep.maxpacket)\r\nbflag = TRUE;\r\n}\r\n_nbu2ss_start_transfer(ep->udc, ep, req, bflag);\r\n}\r\nstatic void _nbu2ss_endpoint_toggle_reset(\r\nstruct nbu2ss_udc *udc,\r\nu8 ep_adrs)\r\n{\r\nu8 num;\r\nu32 data;\r\nif ((ep_adrs == 0) || (ep_adrs == 0x80))\r\nreturn;\r\nnum = (ep_adrs & 0x7F) - 1;\r\nif (ep_adrs & USB_DIR_IN)\r\ndata = EPn_IPIDCLR;\r\nelse\r\ndata = EPn_BCLR | EPn_OPIDCLR;\r\n_nbu2ss_bitset(&udc->p_regs->EP_REGS[num].EP_CONTROL, data);\r\n}\r\nstatic void _nbu2ss_set_endpoint_stall(\r\nstruct nbu2ss_udc *udc,\r\nu8 ep_adrs,\r\nbool bstall)\r\n{\r\nu8 num, epnum;\r\nu32 data;\r\nstruct nbu2ss_ep *ep;\r\nstruct fc_regs *preg = udc->p_regs;\r\nif ((ep_adrs == 0) || (ep_adrs == 0x80)) {\r\nif (bstall) {\r\n_nbu2ss_bitset(&preg->EP0_CONTROL, EP0_STL);\r\n} else {\r\n_nbu2ss_bitclr(&preg->EP0_CONTROL, EP0_STL);\r\n}\r\n} else {\r\nepnum = ep_adrs & USB_ENDPOINT_NUMBER_MASK;\r\nnum = epnum - 1;\r\nep = &udc->ep[epnum];\r\nif (bstall) {\r\nep->halted = TRUE;\r\nif (ep_adrs & USB_DIR_IN)\r\ndata = EPn_BCLR | EPn_ISTL;\r\nelse\r\ndata = EPn_OSTL_EN | EPn_OSTL;\r\n_nbu2ss_bitset(&preg->EP_REGS[num].EP_CONTROL, data);\r\n} else {\r\nep->stalled = FALSE;\r\nif (ep_adrs & USB_DIR_IN) {\r\n_nbu2ss_bitclr(&preg->EP_REGS[num].EP_CONTROL\r\n, EPn_ISTL);\r\n} else {\r\ndata =\r\n_nbu2ss_readl(&preg->EP_REGS[num].EP_CONTROL);\r\ndata &= ~EPn_OSTL;\r\ndata |= EPn_OSTL_EN;\r\n_nbu2ss_writel(&preg->EP_REGS[num].EP_CONTROL\r\n, data);\r\n}\r\nep->stalled = FALSE;\r\nif (ep->halted) {\r\nep->halted = FALSE;\r\n_nbu2ss_restert_transfer(ep);\r\n}\r\n}\r\n}\r\n}\r\nstatic void _nbu2ss_set_test_mode(struct nbu2ss_udc *udc, u32 mode)\r\n{\r\nu32 data;\r\nif (mode > MAX_TEST_MODE_NUM)\r\nreturn;\r\ndev_info(udc->dev, "SET FEATURE : test mode = %d\n", mode);\r\ndata = _nbu2ss_readl(&udc->p_regs->USB_CONTROL);\r\ndata &= ~TEST_FORCE_ENABLE;\r\ndata |= mode << TEST_MODE_SHIFT;\r\n_nbu2ss_writel(&udc->p_regs->USB_CONTROL, data);\r\n_nbu2ss_bitset(&udc->p_regs->TEST_CONTROL, CS_TESTMODEEN);\r\n}\r\nstatic int _nbu2ss_set_feature_device(\r\nstruct nbu2ss_udc *udc,\r\nu16 selector,\r\nu16 wIndex\r\n)\r\n{\r\nint result = -EOPNOTSUPP;\r\nswitch (selector) {\r\ncase USB_DEVICE_REMOTE_WAKEUP:\r\nif (wIndex == 0x0000) {\r\nudc->remote_wakeup = U2F_ENABLE;\r\nresult = 0;\r\n}\r\nbreak;\r\ncase USB_DEVICE_TEST_MODE:\r\nwIndex >>= 8;\r\nif (wIndex <= MAX_TEST_MODE_NUM)\r\nresult = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic int _nbu2ss_get_ep_stall(struct nbu2ss_udc *udc, u8 ep_adrs)\r\n{\r\nu8 epnum;\r\nu32 data = 0, bit_data;\r\nstruct fc_regs *preg = udc->p_regs;\r\nepnum = ep_adrs & ~USB_ENDPOINT_DIR_MASK;\r\nif (epnum == 0) {\r\ndata = _nbu2ss_readl(&preg->EP0_CONTROL);\r\nbit_data = EP0_STL;\r\n} else {\r\ndata = _nbu2ss_readl(&preg->EP_REGS[epnum - 1].EP_CONTROL);\r\nif ((data & EPn_EN) == 0)\r\nreturn -1;\r\nif (ep_adrs & USB_ENDPOINT_DIR_MASK)\r\nbit_data = EPn_ISTL;\r\nelse\r\nbit_data = EPn_OSTL;\r\n}\r\nif ((data & bit_data) == 0)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic inline int _nbu2ss_req_feature(struct nbu2ss_udc *udc, bool bset)\r\n{\r\nu8 recipient = (u8)(udc->ctrl.bRequestType & USB_RECIP_MASK);\r\nu8 direction = (u8)(udc->ctrl.bRequestType & USB_DIR_IN);\r\nu16 selector = udc->ctrl.wValue;\r\nu16 wIndex = udc->ctrl.wIndex;\r\nu8 ep_adrs;\r\nint result = -EOPNOTSUPP;\r\nif ((udc->ctrl.wLength != 0x0000) ||\r\n(direction != USB_DIR_OUT)) {\r\nreturn -EINVAL;\r\n}\r\nswitch (recipient) {\r\ncase USB_RECIP_DEVICE:\r\nif (bset)\r\nresult =\r\n_nbu2ss_set_feature_device(udc, selector, wIndex);\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\nif (0x0000 == (wIndex & 0xFF70)) {\r\nif (selector == USB_ENDPOINT_HALT) {\r\nep_adrs = wIndex & 0xFF;\r\nif (!bset) {\r\n_nbu2ss_endpoint_toggle_reset(\r\nudc, ep_adrs);\r\n}\r\n_nbu2ss_set_endpoint_stall(\r\nudc, ep_adrs, bset);\r\nresult = 0;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (result >= 0)\r\n_nbu2ss_create_ep0_packet(udc, udc->ep0_buf, 0);\r\nreturn result;\r\n}\r\nstatic inline enum usb_device_speed _nbu2ss_get_speed(struct nbu2ss_udc *udc)\r\n{\r\nu32 data;\r\nenum usb_device_speed speed = USB_SPEED_FULL;\r\ndata = _nbu2ss_readl(&udc->p_regs->USB_STATUS);\r\nif (data & HIGH_SPEED)\r\nspeed = USB_SPEED_HIGH;\r\nreturn speed;\r\n}\r\nstatic void _nbu2ss_epn_set_stall(\r\nstruct nbu2ss_udc *udc,\r\nstruct nbu2ss_ep *ep\r\n)\r\n{\r\nu8 ep_adrs;\r\nu32 regdata;\r\nint limit_cnt = 0;\r\nstruct fc_regs *preg = udc->p_regs;\r\nif (ep->direct == USB_DIR_IN) {\r\nfor (limit_cnt = 0\r\n; limit_cnt < IN_DATA_EMPTY_COUNT\r\n; limit_cnt++) {\r\nregdata = _nbu2ss_readl(\r\n&preg->EP_REGS[ep->epnum - 1].EP_STATUS);\r\nif ((regdata & EPn_IN_DATA) == 0)\r\nbreak;\r\nmdelay(1);\r\n}\r\n}\r\nep_adrs = ep->epnum | ep->direct;\r\n_nbu2ss_set_endpoint_stall(udc, ep_adrs, 1);\r\n}\r\nstatic int std_req_get_status(struct nbu2ss_udc *udc)\r\n{\r\nu32 length;\r\nu16 status_data = 0;\r\nu8 recipient = (u8)(udc->ctrl.bRequestType & USB_RECIP_MASK);\r\nu8 direction = (u8)(udc->ctrl.bRequestType & USB_DIR_IN);\r\nu8 ep_adrs;\r\nint result = -EINVAL;\r\nif ((udc->ctrl.wValue != 0x0000) || (direction != USB_DIR_IN))\r\nreturn result;\r\nlength = min_t(u16, udc->ctrl.wLength, sizeof(status_data));\r\nswitch (recipient) {\r\ncase USB_RECIP_DEVICE:\r\nif (udc->ctrl.wIndex == 0x0000) {\r\nif (udc->gadget.is_selfpowered)\r\nstatus_data |= (1 << USB_DEVICE_SELF_POWERED);\r\nif (udc->remote_wakeup)\r\nstatus_data |= (1 << USB_DEVICE_REMOTE_WAKEUP);\r\nresult = 0;\r\n}\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\nif (0x0000 == (udc->ctrl.wIndex & 0xFF70)) {\r\nep_adrs = (u8)(udc->ctrl.wIndex & 0xFF);\r\nresult = _nbu2ss_get_ep_stall(udc, ep_adrs);\r\nif (result > 0)\r\nstatus_data |= (1 << USB_ENDPOINT_HALT);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (result >= 0) {\r\nmemcpy(udc->ep0_buf, &status_data, length);\r\n_nbu2ss_create_ep0_packet(udc, udc->ep0_buf, length);\r\n_nbu2ss_ep0_in_transfer(udc, &udc->ep0_req);\r\n} else {\r\ndev_err(udc->dev, " Error GET_STATUS\n");\r\n}\r\nreturn result;\r\n}\r\nstatic int std_req_clear_feature(struct nbu2ss_udc *udc)\r\n{\r\nreturn _nbu2ss_req_feature(udc, FALSE);\r\n}\r\nstatic int std_req_set_feature(struct nbu2ss_udc *udc)\r\n{\r\nreturn _nbu2ss_req_feature(udc, TRUE);\r\n}\r\nstatic int std_req_set_address(struct nbu2ss_udc *udc)\r\n{\r\nint result = 0;\r\nu32 wValue = udc->ctrl.wValue;\r\nif ((udc->ctrl.bRequestType != 0x00) ||\r\n(udc->ctrl.wIndex != 0x0000) ||\r\n(udc->ctrl.wLength != 0x0000)) {\r\nreturn -EINVAL;\r\n}\r\nif (wValue != (wValue & 0x007F))\r\nreturn -EINVAL;\r\nwValue <<= USB_ADRS_SHIFT;\r\n_nbu2ss_writel(&udc->p_regs->USB_ADDRESS, wValue);\r\n_nbu2ss_create_ep0_packet(udc, udc->ep0_buf, 0);\r\nreturn result;\r\n}\r\nstatic int std_req_set_configuration(struct nbu2ss_udc *udc)\r\n{\r\nu32 ConfigValue = (u32)(udc->ctrl.wValue & 0x00ff);\r\nif ((udc->ctrl.wIndex != 0x0000) ||\r\n(udc->ctrl.wLength != 0x0000) ||\r\n(udc->ctrl.bRequestType != 0x00)) {\r\nreturn -EINVAL;\r\n}\r\nudc->curr_config = ConfigValue;\r\nif (ConfigValue > 0) {\r\n_nbu2ss_bitset(&udc->p_regs->USB_CONTROL, CONF);\r\nudc->devstate = USB_STATE_CONFIGURED;\r\n} else {\r\n_nbu2ss_bitclr(&udc->p_regs->USB_CONTROL, CONF);\r\nudc->devstate = USB_STATE_ADDRESS;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void _nbu2ss_read_request_data(struct nbu2ss_udc *udc, u32 *pdata)\r\n{\r\nif ((!udc) && (!pdata))\r\nreturn;\r\n*pdata = _nbu2ss_readl(&udc->p_regs->SETUP_DATA0);\r\npdata++;\r\n*pdata = _nbu2ss_readl(&udc->p_regs->SETUP_DATA1);\r\n}\r\nstatic inline int _nbu2ss_decode_request(struct nbu2ss_udc *udc)\r\n{\r\nbool bcall_back = TRUE;\r\nint nret = -EINVAL;\r\nstruct usb_ctrlrequest *p_ctrl;\r\np_ctrl = &udc->ctrl;\r\n_nbu2ss_read_request_data(udc, (u32 *)p_ctrl);\r\nif (p_ctrl->wLength == 0) {\r\nudc->ep0state = EP0_IN_STATUS_PHASE;\r\n} else {\r\nif (p_ctrl->bRequestType & USB_DIR_IN)\r\nudc->ep0state = EP0_IN_DATA_PHASE;\r\nelse\r\nudc->ep0state = EP0_OUT_DATA_PHASE;\r\n}\r\nif ((p_ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {\r\nswitch (p_ctrl->bRequest) {\r\ncase USB_REQ_GET_STATUS:\r\nnret = std_req_get_status(udc);\r\nbcall_back = FALSE;\r\nbreak;\r\ncase USB_REQ_CLEAR_FEATURE:\r\nnret = std_req_clear_feature(udc);\r\nbcall_back = FALSE;\r\nbreak;\r\ncase USB_REQ_SET_FEATURE:\r\nnret = std_req_set_feature(udc);\r\nbcall_back = FALSE;\r\nbreak;\r\ncase USB_REQ_SET_ADDRESS:\r\nnret = std_req_set_address(udc);\r\nbcall_back = FALSE;\r\nbreak;\r\ncase USB_REQ_SET_CONFIGURATION:\r\nnret = std_req_set_configuration(udc);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (!bcall_back) {\r\nif (udc->ep0state == EP0_IN_STATUS_PHASE) {\r\nif (nret >= 0) {\r\nnret = EP0_send_NULL(udc, TRUE);\r\n}\r\n}\r\n} else {\r\nspin_unlock(&udc->lock);\r\nnret = udc->driver->setup(&udc->gadget, &udc->ctrl);\r\nspin_lock(&udc->lock);\r\n}\r\nif (nret < 0)\r\nudc->ep0state = EP0_IDLE;\r\nreturn nret;\r\n}\r\nstatic inline int _nbu2ss_ep0_in_data_stage(struct nbu2ss_udc *udc)\r\n{\r\nint nret;\r\nstruct nbu2ss_req *req;\r\nstruct nbu2ss_ep *ep = &udc->ep[0];\r\nreq = list_first_entry_or_null(&ep->queue, struct nbu2ss_req, queue);\r\nif (!req)\r\nreq = &udc->ep0_req;\r\nreq->req.actual += req->div_len;\r\nreq->div_len = 0;\r\nnret = _nbu2ss_ep0_in_transfer(udc, req);\r\nif (nret == 0) {\r\nudc->ep0state = EP0_OUT_STATUS_PAHSE;\r\nEP0_receive_NULL(udc, TRUE);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int _nbu2ss_ep0_out_data_stage(struct nbu2ss_udc *udc)\r\n{\r\nint nret;\r\nstruct nbu2ss_req *req;\r\nstruct nbu2ss_ep *ep = &udc->ep[0];\r\nreq = list_first_entry_or_null(&ep->queue, struct nbu2ss_req, queue);\r\nif (!req)\r\nreq = &udc->ep0_req;\r\nnret = _nbu2ss_ep0_out_transfer(udc, req);\r\nif (nret == 0) {\r\nudc->ep0state = EP0_IN_STATUS_PHASE;\r\nEP0_send_NULL(udc, TRUE);\r\n} else if (nret < 0) {\r\n_nbu2ss_bitset(&udc->p_regs->EP0_CONTROL, EP0_BCLR);\r\nreq->req.status = nret;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int _nbu2ss_ep0_status_stage(struct nbu2ss_udc *udc)\r\n{\r\nstruct nbu2ss_req *req;\r\nstruct nbu2ss_ep *ep = &udc->ep[0];\r\nreq = list_first_entry_or_null(&ep->queue, struct nbu2ss_req, queue);\r\nif (!req) {\r\nreq = &udc->ep0_req;\r\nif (req->req.complete)\r\nreq->req.complete(&ep->ep, &req->req);\r\n} else {\r\nif (req->req.complete)\r\n_nbu2ss_ep_done(ep, req, 0);\r\n}\r\nudc->ep0state = EP0_IDLE;\r\nreturn 0;\r\n}\r\nstatic inline void _nbu2ss_ep0_int(struct nbu2ss_udc *udc)\r\n{\r\nint i;\r\nu32 status;\r\nu32 intr;\r\nint nret = -1;\r\nstatus = _nbu2ss_readl(&udc->p_regs->EP0_STATUS);\r\nintr = status & EP0_STATUS_RW_BIT;\r\n_nbu2ss_writel(&udc->p_regs->EP0_STATUS, ~intr);\r\nstatus &= (SETUP_INT | EP0_IN_INT | EP0_OUT_INT\r\n| STG_END_INT | EP0_OUT_NULL_INT);\r\nif (status == 0) {\r\ndev_info(udc->dev, "%s Not Decode Interrupt\n", __func__);\r\ndev_info(udc->dev, "EP0_STATUS = 0x%08x\n", intr);\r\nreturn;\r\n}\r\nif (udc->gadget.speed == USB_SPEED_UNKNOWN)\r\nudc->gadget.speed = _nbu2ss_get_speed(udc);\r\nfor (i = 0; i < EP0_END_XFER; i++) {\r\nswitch (udc->ep0state) {\r\ncase EP0_IDLE:\r\nif (status & SETUP_INT) {\r\nstatus = 0;\r\nnret = _nbu2ss_decode_request(udc);\r\n}\r\nbreak;\r\ncase EP0_IN_DATA_PHASE:\r\nif (status & EP0_IN_INT) {\r\nstatus &= ~EP0_IN_INT;\r\nnret = _nbu2ss_ep0_in_data_stage(udc);\r\n}\r\nbreak;\r\ncase EP0_OUT_DATA_PHASE:\r\nif (status & EP0_OUT_INT) {\r\nstatus &= ~EP0_OUT_INT;\r\nnret = _nbu2ss_ep0_out_data_stage(udc);\r\n}\r\nbreak;\r\ncase EP0_IN_STATUS_PHASE:\r\nif ((status & STG_END_INT) || (status & SETUP_INT)) {\r\nstatus &= ~(STG_END_INT | EP0_IN_INT);\r\nnret = _nbu2ss_ep0_status_stage(udc);\r\n}\r\nbreak;\r\ncase EP0_OUT_STATUS_PAHSE:\r\nif ((status & STG_END_INT) || (status & SETUP_INT) ||\r\n(status & EP0_OUT_NULL_INT)) {\r\nstatus &= ~(STG_END_INT\r\n| EP0_OUT_INT\r\n| EP0_OUT_NULL_INT);\r\nnret = _nbu2ss_ep0_status_stage(udc);\r\n}\r\nbreak;\r\ndefault:\r\nstatus = 0;\r\nbreak;\r\n}\r\nif (status == 0)\r\nbreak;\r\n}\r\nif (nret < 0) {\r\n_nbu2ss_set_endpoint_stall(udc, 0, TRUE);\r\n}\r\n}\r\nstatic void _nbu2ss_ep_done(\r\nstruct nbu2ss_ep *ep,\r\nstruct nbu2ss_req *req,\r\nint status)\r\n{\r\nstruct nbu2ss_udc *udc = ep->udc;\r\nlist_del_init(&req->queue);\r\nif (status == -ECONNRESET)\r\n_nbu2ss_fifo_flush(udc, ep);\r\nif (likely(req->req.status == -EINPROGRESS))\r\nreq->req.status = status;\r\nif (ep->stalled) {\r\n_nbu2ss_epn_set_stall(udc, ep);\r\n} else {\r\nif (!list_empty(&ep->queue))\r\n_nbu2ss_restert_transfer(ep);\r\n}\r\n#ifdef USE_DMA\r\nif ((ep->direct == USB_DIR_OUT) && (ep->epnum > 0) &&\r\n(req->req.dma != 0))\r\n_nbu2ss_dma_unmap_single(udc, ep, req, USB_DIR_OUT);\r\n#endif\r\nspin_unlock(&udc->lock);\r\nreq->req.complete(&ep->ep, &req->req);\r\nspin_lock(&udc->lock);\r\n}\r\nstatic inline void _nbu2ss_epn_in_int(\r\nstruct nbu2ss_udc *udc,\r\nstruct nbu2ss_ep *ep,\r\nstruct nbu2ss_req *req)\r\n{\r\nint result = 0;\r\nu32 status;\r\nstruct fc_regs *preg = udc->p_regs;\r\nif (req->dma_flag)\r\nreturn;\r\nreq->req.actual += req->div_len;\r\nreq->div_len = 0;\r\nif (req->req.actual != req->req.length) {\r\nresult = _nbu2ss_epn_in_transfer(udc, ep, req);\r\n} else {\r\nif (req->zero && ((req->req.actual % ep->ep.maxpacket) == 0)) {\r\nstatus =\r\n_nbu2ss_readl(&preg->EP_REGS[ep->epnum - 1].EP_STATUS);\r\nif ((status & EPn_IN_FULL) == 0) {\r\nreq->zero = false;\r\n_nbu2ss_zero_len_pkt(udc, ep->epnum);\r\n}\r\nreturn;\r\n}\r\n}\r\nif (result <= 0) {\r\n_nbu2ss_ep_done(ep, req, result);\r\n}\r\n}\r\nstatic inline void _nbu2ss_epn_out_int(\r\nstruct nbu2ss_udc *udc,\r\nstruct nbu2ss_ep *ep,\r\nstruct nbu2ss_req *req)\r\n{\r\nint result;\r\nresult = _nbu2ss_epn_out_transfer(udc, ep, req);\r\nif (result <= 0)\r\n_nbu2ss_ep_done(ep, req, result);\r\n}\r\nstatic inline void _nbu2ss_epn_in_dma_int(\r\nstruct nbu2ss_udc *udc,\r\nstruct nbu2ss_ep *ep,\r\nstruct nbu2ss_req *req)\r\n{\r\nu32 mpkt;\r\nu32 size;\r\nstruct usb_request *preq;\r\npreq = &req->req;\r\nif (!req->dma_flag)\r\nreturn;\r\npreq->actual += req->div_len;\r\nreq->div_len = 0;\r\nreq->dma_flag = FALSE;\r\n#ifdef USE_DMA\r\n_nbu2ss_dma_unmap_single(udc, ep, req, USB_DIR_IN);\r\n#endif\r\nif (preq->actual != preq->length) {\r\n_nbu2ss_epn_in_transfer(udc, ep, req);\r\n} else {\r\nmpkt = ep->ep.maxpacket;\r\nsize = preq->actual % mpkt;\r\nif (size > 0) {\r\nif (((preq->actual & 0x03) == 0) && (size < mpkt))\r\n_nbu2ss_ep_in_end(udc, ep->epnum, 0, 0);\r\n} else {\r\n_nbu2ss_epn_in_int(udc, ep, req);\r\n}\r\n}\r\n}\r\nstatic inline void _nbu2ss_epn_out_dma_int(\r\nstruct nbu2ss_udc *udc,\r\nstruct nbu2ss_ep *ep,\r\nstruct nbu2ss_req *req)\r\n{\r\nint i;\r\nu32 num;\r\nu32 dmacnt, ep_dmacnt;\r\nu32 mpkt;\r\nstruct fc_regs *preg = udc->p_regs;\r\nnum = ep->epnum - 1;\r\nif (req->req.actual == req->req.length) {\r\nif ((req->req.length % ep->ep.maxpacket) && !req->zero) {\r\nreq->div_len = 0;\r\nreq->dma_flag = FALSE;\r\n_nbu2ss_ep_done(ep, req, 0);\r\nreturn;\r\n}\r\n}\r\nep_dmacnt = _nbu2ss_readl(&preg->EP_REGS[num].EP_LEN_DCNT)\r\n& EPn_DMACNT;\r\nep_dmacnt >>= 16;\r\nfor (i = 0; i < EPC_PLL_LOCK_COUNT; i++) {\r\ndmacnt = _nbu2ss_readl(&preg->EP_DCR[num].EP_DCR1)\r\n& DCR1_EPn_DMACNT;\r\ndmacnt >>= 16;\r\nif (ep_dmacnt == dmacnt)\r\nbreak;\r\n}\r\n_nbu2ss_bitclr(&preg->EP_DCR[num].EP_DCR1, DCR1_EPn_REQEN);\r\nif (dmacnt != 0) {\r\nmpkt = ep->ep.maxpacket;\r\nif ((req->div_len % mpkt) == 0)\r\nreq->div_len -= mpkt * dmacnt;\r\n}\r\nif ((req->req.actual % ep->ep.maxpacket) > 0) {\r\nif (req->req.actual == req->div_len) {\r\nreq->div_len = 0;\r\nreq->dma_flag = FALSE;\r\n_nbu2ss_ep_done(ep, req, 0);\r\nreturn;\r\n}\r\n}\r\nreq->req.actual += req->div_len;\r\nreq->div_len = 0;\r\nreq->dma_flag = FALSE;\r\n_nbu2ss_epn_out_int(udc, ep, req);\r\n}\r\nstatic inline void _nbu2ss_epn_int(struct nbu2ss_udc *udc, u32 epnum)\r\n{\r\nu32 num;\r\nu32 status;\r\nstruct nbu2ss_req *req;\r\nstruct nbu2ss_ep *ep = &udc->ep[epnum];\r\nnum = epnum - 1;\r\nstatus = _nbu2ss_readl(&udc->p_regs->EP_REGS[num].EP_STATUS);\r\n_nbu2ss_writel(&udc->p_regs->EP_REGS[num].EP_STATUS, ~status);\r\nreq = list_first_entry_or_null(&ep->queue, struct nbu2ss_req, queue);\r\nif (!req) {\r\nreturn;\r\n}\r\nif (status & EPn_OUT_END_INT) {\r\nstatus &= ~EPn_OUT_INT;\r\n_nbu2ss_epn_out_dma_int(udc, ep, req);\r\n}\r\nif (status & EPn_OUT_INT)\r\n_nbu2ss_epn_out_int(udc, ep, req);\r\nif (status & EPn_IN_END_INT) {\r\nstatus &= ~EPn_IN_INT;\r\n_nbu2ss_epn_in_dma_int(udc, ep, req);\r\n}\r\nif (status & EPn_IN_INT)\r\n_nbu2ss_epn_in_int(udc, ep, req);\r\n}\r\nstatic inline void _nbu2ss_ep_int(struct nbu2ss_udc *udc, u32 epnum)\r\n{\r\nif (epnum == 0)\r\n_nbu2ss_ep0_int(udc);\r\nelse\r\n_nbu2ss_epn_int(udc, epnum);\r\n}\r\nstatic void _nbu2ss_ep0_enable(struct nbu2ss_udc *udc)\r\n{\r\n_nbu2ss_bitset(&udc->p_regs->EP0_CONTROL, (EP0_AUTO | EP0_BCLR));\r\n_nbu2ss_writel(&udc->p_regs->EP0_INT_ENA, EP0_INT_EN_BIT);\r\n}\r\nstatic int _nbu2ss_nuke(struct nbu2ss_udc *udc,\r\nstruct nbu2ss_ep *ep,\r\nint status)\r\n{\r\nstruct nbu2ss_req *req;\r\n_nbu2ss_epn_exit(udc, ep);\r\n_nbu2ss_ep_dma_exit(udc, ep);\r\nif (list_empty(&ep->queue))\r\nreturn 0;\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\n_nbu2ss_ep_done(ep, req, status);\r\n}\r\nreturn 0;\r\n}\r\nstatic void _nbu2ss_quiesce(struct nbu2ss_udc *udc)\r\n{\r\nstruct nbu2ss_ep *ep;\r\nudc->gadget.speed = USB_SPEED_UNKNOWN;\r\n_nbu2ss_nuke(udc, &udc->ep[0], -ESHUTDOWN);\r\nlist_for_each_entry(ep, &udc->gadget.ep_list, ep.ep_list) {\r\n_nbu2ss_nuke(udc, ep, -ESHUTDOWN);\r\n}\r\n}\r\nstatic int _nbu2ss_pullup(struct nbu2ss_udc *udc, int is_on)\r\n{\r\nu32 reg_dt;\r\nif (udc->vbus_active == 0)\r\nreturn -ESHUTDOWN;\r\nif (is_on) {\r\nif (udc->driver) {\r\nreg_dt = (_nbu2ss_readl(&udc->p_regs->USB_CONTROL)\r\n| PUE2) & ~(u32)CONNECTB;\r\n_nbu2ss_writel(&udc->p_regs->USB_CONTROL, reg_dt);\r\n}\r\n} else {\r\nreg_dt = (_nbu2ss_readl(&udc->p_regs->USB_CONTROL) | CONNECTB)\r\n& ~(u32)PUE2;\r\n_nbu2ss_writel(&udc->p_regs->USB_CONTROL, reg_dt);\r\nudc->gadget.speed = USB_SPEED_UNKNOWN;\r\n}\r\nreturn 0;\r\n}\r\nstatic void _nbu2ss_fifo_flush(struct nbu2ss_udc *udc, struct nbu2ss_ep *ep)\r\n{\r\nstruct fc_regs *p = udc->p_regs;\r\nif (udc->vbus_active == 0)\r\nreturn;\r\nif (ep->epnum == 0) {\r\n_nbu2ss_bitset(&p->EP0_CONTROL, EP0_BCLR);\r\n} else {\r\n_nbu2ss_ep_dma_abort(udc, ep);\r\n_nbu2ss_bitset(&p->EP_REGS[ep->epnum - 1].EP_CONTROL, EPn_BCLR);\r\n}\r\n}\r\nstatic int _nbu2ss_enable_controller(struct nbu2ss_udc *udc)\r\n{\r\nint waitcnt = 0;\r\nif (udc->udc_enabled)\r\nreturn 0;\r\n_nbu2ss_bitset(&udc->p_regs->EPCTR, (DIRPD | EPC_RST));\r\nudelay(EPC_RST_DISABLE_TIME);\r\n_nbu2ss_bitclr(&udc->p_regs->EPCTR, DIRPD);\r\nmdelay(EPC_DIRPD_DISABLE_TIME);\r\n_nbu2ss_bitclr(&udc->p_regs->EPCTR, EPC_RST);\r\n_nbu2ss_writel(&udc->p_regs->AHBSCTR, WAIT_MODE);\r\n_nbu2ss_writel(&udc->p_regs->AHBMCTR,\r\nHBUSREQ_MODE | HTRANS_MODE | WBURST_TYPE);\r\nwhile (!(_nbu2ss_readl(&udc->p_regs->EPCTR) & PLL_LOCK)) {\r\nwaitcnt++;\r\nudelay(1);\r\nif (waitcnt == EPC_PLL_LOCK_COUNT) {\r\ndev_err(udc->dev, "*** Reset Cancel failed\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\n_nbu2ss_bitset(&udc->p_regs->UTMI_CHARACTER_1, USB_SQUSET);\r\n_nbu2ss_bitset(&udc->p_regs->USB_CONTROL, (INT_SEL | SOF_RCV));\r\n_nbu2ss_ep0_enable(udc);\r\n_nbu2ss_bitset(&udc->p_regs->USB_INT_ENA, USB_INT_EN_BIT);\r\nudc->udc_enabled = TRUE;\r\nreturn 0;\r\n}\r\nstatic void _nbu2ss_reset_controller(struct nbu2ss_udc *udc)\r\n{\r\n_nbu2ss_bitset(&udc->p_regs->EPCTR, EPC_RST);\r\n_nbu2ss_bitclr(&udc->p_regs->EPCTR, EPC_RST);\r\n}\r\nstatic void _nbu2ss_disable_controller(struct nbu2ss_udc *udc)\r\n{\r\nif (udc->udc_enabled) {\r\nudc->udc_enabled = FALSE;\r\n_nbu2ss_reset_controller(udc);\r\n_nbu2ss_bitset(&udc->p_regs->EPCTR, (DIRPD | EPC_RST));\r\n}\r\n}\r\nstatic inline void _nbu2ss_check_vbus(struct nbu2ss_udc *udc)\r\n{\r\nint nret;\r\nu32 reg_dt;\r\nmdelay(VBUS_CHATTERING_MDELAY);\r\nreg_dt = gpio_get_value(VBUS_VALUE);\r\nif (reg_dt == 0) {\r\nudc->linux_suspended = 0;\r\n_nbu2ss_reset_controller(udc);\r\ndev_info(udc->dev, " ----- VBUS OFF\n");\r\nif (udc->vbus_active == 1) {\r\nudc->vbus_active = 0;\r\nif (udc->usb_suspended) {\r\nudc->usb_suspended = 0;\r\n}\r\nudc->devstate = USB_STATE_NOTATTACHED;\r\n_nbu2ss_quiesce(udc);\r\nif (udc->driver) {\r\nspin_unlock(&udc->lock);\r\nudc->driver->disconnect(&udc->gadget);\r\nspin_lock(&udc->lock);\r\n}\r\n_nbu2ss_disable_controller(udc);\r\n}\r\n} else {\r\nmdelay(5);\r\nreg_dt = gpio_get_value(VBUS_VALUE);\r\nif (reg_dt == 0)\r\nreturn;\r\ndev_info(udc->dev, " ----- VBUS ON\n");\r\nif (udc->linux_suspended)\r\nreturn;\r\nif (udc->vbus_active == 0) {\r\nudc->vbus_active = 1;\r\nudc->devstate = USB_STATE_POWERED;\r\nnret = _nbu2ss_enable_controller(udc);\r\nif (nret < 0) {\r\n_nbu2ss_disable_controller(udc);\r\nudc->vbus_active = 0;\r\nreturn;\r\n}\r\n_nbu2ss_pullup(udc, 1);\r\n#ifdef UDC_DEBUG_DUMP\r\n_nbu2ss_dump_register(udc);\r\n#endif\r\n} else {\r\nif (udc->devstate == USB_STATE_POWERED)\r\n_nbu2ss_pullup(udc, 1);\r\n}\r\n}\r\n}\r\nstatic inline void _nbu2ss_int_bus_reset(struct nbu2ss_udc *udc)\r\n{\r\nudc->devstate = USB_STATE_DEFAULT;\r\nudc->remote_wakeup = 0;\r\n_nbu2ss_quiesce(udc);\r\nudc->ep0state = EP0_IDLE;\r\n}\r\nstatic inline void _nbu2ss_int_usb_resume(struct nbu2ss_udc *udc)\r\n{\r\nif (udc->usb_suspended == 1) {\r\nudc->usb_suspended = 0;\r\nif (udc->driver && udc->driver->resume) {\r\nspin_unlock(&udc->lock);\r\nudc->driver->resume(&udc->gadget);\r\nspin_lock(&udc->lock);\r\n}\r\n}\r\n}\r\nstatic inline void _nbu2ss_int_usb_suspend(struct nbu2ss_udc *udc)\r\n{\r\nu32 reg_dt;\r\nif (udc->usb_suspended == 0) {\r\nreg_dt = gpio_get_value(VBUS_VALUE);\r\nif (reg_dt == 0)\r\nreturn;\r\nudc->usb_suspended = 1;\r\nif (udc->driver && udc->driver->suspend) {\r\nspin_unlock(&udc->lock);\r\nudc->driver->suspend(&udc->gadget);\r\nspin_lock(&udc->lock);\r\n}\r\n_nbu2ss_bitset(&udc->p_regs->USB_CONTROL, SUSPEND);\r\n}\r\n}\r\nstatic irqreturn_t _nbu2ss_vbus_irq(int irq, void *_udc)\r\n{\r\nstruct nbu2ss_udc *udc = (struct nbu2ss_udc *)_udc;\r\nspin_lock(&udc->lock);\r\n_nbu2ss_check_vbus(udc);\r\nspin_unlock(&udc->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t _nbu2ss_udc_irq(int irq, void *_udc)\r\n{\r\nu8 suspend_flag = 0;\r\nu32 status;\r\nu32 epnum, int_bit;\r\nstruct nbu2ss_udc *udc = (struct nbu2ss_udc *)_udc;\r\nstruct fc_regs *preg = udc->p_regs;\r\nif (gpio_get_value(VBUS_VALUE) == 0) {\r\n_nbu2ss_writel(&preg->USB_INT_STA, ~USB_INT_STA_RW);\r\n_nbu2ss_writel(&preg->USB_INT_ENA, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nspin_lock(&udc->lock);\r\nfor (;;) {\r\nif (gpio_get_value(VBUS_VALUE) == 0) {\r\n_nbu2ss_writel(&preg->USB_INT_STA, ~USB_INT_STA_RW);\r\n_nbu2ss_writel(&preg->USB_INT_ENA, 0);\r\nstatus = 0;\r\n} else {\r\nstatus = _nbu2ss_readl(&preg->USB_INT_STA);\r\n}\r\nif (status == 0)\r\nbreak;\r\n_nbu2ss_writel(&preg->USB_INT_STA, ~(status & USB_INT_STA_RW));\r\nif (status & USB_RST_INT) {\r\n_nbu2ss_int_bus_reset(udc);\r\n}\r\nif (status & RSUM_INT) {\r\n_nbu2ss_int_usb_resume(udc);\r\n}\r\nif (status & SPND_INT) {\r\nsuspend_flag = 1;\r\n}\r\nif (status & EPn_INT) {\r\nint_bit = status >> 8;\r\nfor (epnum = 0; epnum < NUM_ENDPOINTS; epnum++) {\r\nif (0x01 & int_bit)\r\n_nbu2ss_ep_int(udc, epnum);\r\nint_bit >>= 1;\r\nif (int_bit == 0)\r\nbreak;\r\n}\r\n}\r\n}\r\nif (suspend_flag)\r\n_nbu2ss_int_usb_suspend(udc);\r\nspin_unlock(&udc->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int nbu2ss_ep_enable(\r\nstruct usb_ep *_ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nu8 ep_type;\r\nunsigned long flags;\r\nstruct nbu2ss_ep *ep;\r\nstruct nbu2ss_udc *udc;\r\nif ((!_ep) || (!desc)) {\r\npr_err(" *** %s, bad param\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nep = container_of(_ep, struct nbu2ss_ep, ep);\r\nif ((!ep) || (!ep->udc)) {\r\npr_err(" *** %s, ep == NULL !!\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nep_type = usb_endpoint_type(desc);\r\nif ((ep_type == USB_ENDPOINT_XFER_CONTROL) ||\r\n(ep_type == USB_ENDPOINT_XFER_ISOC)) {\r\npr_err(" *** %s, bat bmAttributes\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nudc = ep->udc;\r\nif (udc->vbus_active == 0)\r\nreturn -ESHUTDOWN;\r\nif ((!udc->driver) || (udc->gadget.speed == USB_SPEED_UNKNOWN)) {\r\ndev_err(ep->udc->dev, " *** %s, udc !!\n", __func__);\r\nreturn -ESHUTDOWN;\r\n}\r\nspin_lock_irqsave(&udc->lock, flags);\r\nep->desc = desc;\r\nep->epnum = usb_endpoint_num(desc);\r\nep->direct = desc->bEndpointAddress & USB_ENDPOINT_DIR_MASK;\r\nep->ep_type = ep_type;\r\nep->wedged = 0;\r\nep->halted = FALSE;\r\nep->stalled = FALSE;\r\nep->ep.maxpacket = le16_to_cpu(desc->wMaxPacketSize);\r\n_nbu2ss_ep_dma_init(udc, ep);\r\n_nbu2ss_ep_init(udc, ep);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int nbu2ss_ep_disable(struct usb_ep *_ep)\r\n{\r\nstruct nbu2ss_ep *ep;\r\nstruct nbu2ss_udc *udc;\r\nunsigned long flags;\r\nif (!_ep) {\r\npr_err(" *** %s, bad param\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nep = container_of(_ep, struct nbu2ss_ep, ep);\r\nif ((!ep) || (!ep->udc)) {\r\npr_err("udc: *** %s, ep == NULL !!\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nudc = ep->udc;\r\nif (udc->vbus_active == 0)\r\nreturn -ESHUTDOWN;\r\nspin_lock_irqsave(&udc->lock, flags);\r\n_nbu2ss_nuke(udc, ep, -EINPROGRESS);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic struct usb_request *nbu2ss_ep_alloc_request(\r\nstruct usb_ep *ep,\r\ngfp_t gfp_flags)\r\n{\r\nstruct nbu2ss_req *req;\r\nreq = kzalloc(sizeof(*req), gfp_flags);\r\nif (!req)\r\nreturn NULL;\r\n#ifdef USE_DMA\r\nreq->req.dma = DMA_ADDR_INVALID;\r\n#endif\r\nINIT_LIST_HEAD(&req->queue);\r\nreturn &req->req;\r\n}\r\nstatic void nbu2ss_ep_free_request(\r\nstruct usb_ep *_ep,\r\nstruct usb_request *_req)\r\n{\r\nstruct nbu2ss_req *req;\r\nif (_req) {\r\nreq = container_of(_req, struct nbu2ss_req, req);\r\nkfree(req);\r\n}\r\n}\r\nstatic int nbu2ss_ep_queue(\r\nstruct usb_ep *_ep,\r\nstruct usb_request *_req,\r\ngfp_t gfp_flags)\r\n{\r\nstruct nbu2ss_req *req;\r\nstruct nbu2ss_ep *ep;\r\nstruct nbu2ss_udc *udc;\r\nunsigned long flags;\r\nbool bflag;\r\nint result = -EINVAL;\r\nif ((!_ep) || (!_req)) {\r\nif (!_ep)\r\npr_err("udc: %s --- _ep == NULL\n", __func__);\r\nif (!_req)\r\npr_err("udc: %s --- _req == NULL\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nreq = container_of(_req, struct nbu2ss_req, req);\r\nif (unlikely(!_req->complete || !_req->buf || !list_empty(&req->queue))) {\r\nif (!_req->complete)\r\npr_err("udc: %s --- !_req->complete\n", __func__);\r\nif (!_req->buf)\r\npr_err("udc:%s --- !_req->buf\n", __func__);\r\nif (!list_empty(&req->queue))\r\npr_err("%s --- !list_empty(&req->queue)\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nep = container_of(_ep, struct nbu2ss_ep, ep);\r\nudc = ep->udc;\r\nif (udc->vbus_active == 0) {\r\ndev_info(udc->dev, "Can't ep_queue (VBUS OFF)\n");\r\nreturn -ESHUTDOWN;\r\n}\r\nif (unlikely(!udc->driver)) {\r\ndev_err(udc->dev, "%s, bogus device state %p\n", __func__,\r\nudc->driver);\r\nreturn -ESHUTDOWN;\r\n}\r\nspin_lock_irqsave(&udc->lock, flags);\r\n#ifdef USE_DMA\r\nif ((uintptr_t)req->req.buf & 0x3)\r\nreq->unaligned = TRUE;\r\nelse\r\nreq->unaligned = FALSE;\r\nif (req->unaligned) {\r\nif (!ep->virt_buf)\r\nep->virt_buf = (u8 *)dma_alloc_coherent(\r\nNULL, PAGE_SIZE,\r\n&ep->phys_buf, GFP_ATOMIC | GFP_DMA);\r\nif (ep->epnum > 0) {\r\nif (ep->direct == USB_DIR_IN)\r\nmemcpy(ep->virt_buf, req->req.buf,\r\nreq->req.length);\r\n}\r\n}\r\nif ((ep->epnum > 0) && (ep->direct == USB_DIR_OUT) &&\r\n(req->req.dma != 0))\r\n_nbu2ss_dma_map_single(udc, ep, req, USB_DIR_OUT);\r\n#endif\r\n_req->status = -EINPROGRESS;\r\n_req->actual = 0;\r\nbflag = list_empty(&ep->queue);\r\nlist_add_tail(&req->queue, &ep->queue);\r\nif (bflag && !ep->stalled) {\r\nresult = _nbu2ss_start_transfer(udc, ep, req, FALSE);\r\nif (result < 0) {\r\ndev_err(udc->dev, " *** %s, result = %d\n", __func__,\r\nresult);\r\nlist_del(&req->queue);\r\n} else if ((ep->epnum > 0) && (ep->direct == USB_DIR_OUT)) {\r\n#ifdef USE_DMA\r\nif (req->req.length < 4 &&\r\nreq->req.length == req->req.actual)\r\n#else\r\nif (req->req.length == req->req.actual)\r\n#endif\r\n_nbu2ss_ep_done(ep, req, result);\r\n}\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int nbu2ss_ep_dequeue(\r\nstruct usb_ep *_ep,\r\nstruct usb_request *_req)\r\n{\r\nstruct nbu2ss_req *req;\r\nstruct nbu2ss_ep *ep;\r\nstruct nbu2ss_udc *udc;\r\nunsigned long flags;\r\nif ((!_ep) || (!_req)) {\r\nreturn -EINVAL;\r\n}\r\nep = container_of(_ep, struct nbu2ss_ep, ep);\r\nif (!ep) {\r\npr_err("%s, ep == NULL !!\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nudc = ep->udc;\r\nif (!udc)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\nif (&req->req == _req)\r\nbreak;\r\n}\r\nif (&req->req != _req) {\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\npr_debug("%s no queue(EINVAL)\n", __func__);\r\nreturn -EINVAL;\r\n}\r\n_nbu2ss_ep_done(ep, req, -ECONNRESET);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int nbu2ss_ep_set_halt(struct usb_ep *_ep, int value)\r\n{\r\nu8 ep_adrs;\r\nunsigned long flags;\r\nstruct nbu2ss_ep *ep;\r\nstruct nbu2ss_udc *udc;\r\nif (!_ep) {\r\npr_err("%s, bad param\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nep = container_of(_ep, struct nbu2ss_ep, ep);\r\nif (!ep) {\r\npr_err("%s, bad ep\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nudc = ep->udc;\r\nif (!udc) {\r\ndev_err(ep->udc->dev, " *** %s, bad udc\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&udc->lock, flags);\r\nep_adrs = ep->epnum | ep->direct;\r\nif (value == 0) {\r\n_nbu2ss_set_endpoint_stall(udc, ep_adrs, value);\r\nep->stalled = FALSE;\r\n} else {\r\nif (list_empty(&ep->queue))\r\n_nbu2ss_epn_set_stall(udc, ep);\r\nelse\r\nep->stalled = TRUE;\r\n}\r\nif (value == 0)\r\nep->wedged = 0;\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int nbu2ss_ep_set_wedge(struct usb_ep *_ep)\r\n{\r\nreturn nbu2ss_ep_set_halt(_ep, 1);\r\n}\r\nstatic int nbu2ss_ep_fifo_status(struct usb_ep *_ep)\r\n{\r\nu32 data;\r\nstruct nbu2ss_ep *ep;\r\nstruct nbu2ss_udc *udc;\r\nunsigned long flags;\r\nstruct fc_regs *preg;\r\nif (!_ep) {\r\npr_err("%s, bad param\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nep = container_of(_ep, struct nbu2ss_ep, ep);\r\nif (!ep) {\r\npr_err("%s, bad ep\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nudc = ep->udc;\r\nif (!udc) {\r\ndev_err(ep->udc->dev, "%s, bad udc\n", __func__);\r\nreturn -EINVAL;\r\n}\r\npreg = udc->p_regs;\r\ndata = gpio_get_value(VBUS_VALUE);\r\nif (data == 0)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (ep->epnum == 0) {\r\ndata = _nbu2ss_readl(&preg->EP0_LENGTH) & EP0_LDATA;\r\n} else {\r\ndata = _nbu2ss_readl(&preg->EP_REGS[ep->epnum - 1].EP_LEN_DCNT)\r\n& EPn_LDATA;\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void nbu2ss_ep_fifo_flush(struct usb_ep *_ep)\r\n{\r\nu32 data;\r\nstruct nbu2ss_ep *ep;\r\nstruct nbu2ss_udc *udc;\r\nunsigned long flags;\r\nif (!_ep) {\r\npr_err("udc: %s, bad param\n", __func__);\r\nreturn;\r\n}\r\nep = container_of(_ep, struct nbu2ss_ep, ep);\r\nif (!ep) {\r\npr_err("udc: %s, bad ep\n", __func__);\r\nreturn;\r\n}\r\nudc = ep->udc;\r\nif (!udc) {\r\ndev_err(ep->udc->dev, "%s, bad udc\n", __func__);\r\nreturn;\r\n}\r\ndata = gpio_get_value(VBUS_VALUE);\r\nif (data == 0)\r\nreturn;\r\nspin_lock_irqsave(&udc->lock, flags);\r\n_nbu2ss_fifo_flush(udc, ep);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\n}\r\nstatic int nbu2ss_gad_get_frame(struct usb_gadget *pgadget)\r\n{\r\nu32 data;\r\nstruct nbu2ss_udc *udc;\r\nif (!pgadget) {\r\npr_err("udc: %s, bad param\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nudc = container_of(pgadget, struct nbu2ss_udc, gadget);\r\nif (!udc) {\r\ndev_err(&pgadget->dev, "%s, udc == NULL\n", __func__);\r\nreturn -EINVAL;\r\n}\r\ndata = gpio_get_value(VBUS_VALUE);\r\nif (data == 0)\r\nreturn -EINVAL;\r\nreturn _nbu2ss_readl(&udc->p_regs->USB_ADDRESS) & FRAME;\r\n}\r\nstatic int nbu2ss_gad_wakeup(struct usb_gadget *pgadget)\r\n{\r\nint i;\r\nu32 data;\r\nstruct nbu2ss_udc *udc;\r\nif (!pgadget) {\r\npr_err("%s, bad param\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nudc = container_of(pgadget, struct nbu2ss_udc, gadget);\r\nif (!udc) {\r\ndev_err(&pgadget->dev, "%s, udc == NULL\n", __func__);\r\nreturn -EINVAL;\r\n}\r\ndata = gpio_get_value(VBUS_VALUE);\r\nif (data == 0) {\r\ndev_warn(&pgadget->dev, "VBUS LEVEL = %d\n", data);\r\nreturn -EINVAL;\r\n}\r\n_nbu2ss_bitset(&udc->p_regs->EPCTR, PLL_RESUME);\r\nfor (i = 0; i < EPC_PLL_LOCK_COUNT; i++) {\r\ndata = _nbu2ss_readl(&udc->p_regs->EPCTR);\r\nif (data & PLL_LOCK)\r\nbreak;\r\n}\r\n_nbu2ss_bitclr(&udc->p_regs->EPCTR, PLL_RESUME);\r\nreturn 0;\r\n}\r\nstatic int nbu2ss_gad_set_selfpowered(struct usb_gadget *pgadget,\r\nint is_selfpowered)\r\n{\r\nstruct nbu2ss_udc *udc;\r\nunsigned long flags;\r\nif (!pgadget) {\r\npr_err("%s, bad param\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nudc = container_of(pgadget, struct nbu2ss_udc, gadget);\r\nspin_lock_irqsave(&udc->lock, flags);\r\npgadget->is_selfpowered = (is_selfpowered != 0);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int nbu2ss_gad_vbus_session(struct usb_gadget *pgadget, int is_active)\r\n{\r\nreturn 0;\r\n}\r\nstatic int nbu2ss_gad_vbus_draw(struct usb_gadget *pgadget, unsigned int mA)\r\n{\r\nstruct nbu2ss_udc *udc;\r\nunsigned long flags;\r\nif (!pgadget) {\r\npr_err("%s, bad param\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nudc = container_of(pgadget, struct nbu2ss_udc, gadget);\r\nspin_lock_irqsave(&udc->lock, flags);\r\nudc->mA = mA;\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int nbu2ss_gad_pullup(struct usb_gadget *pgadget, int is_on)\r\n{\r\nstruct nbu2ss_udc *udc;\r\nunsigned long flags;\r\nif (!pgadget) {\r\npr_err("%s, bad param\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nudc = container_of(pgadget, struct nbu2ss_udc, gadget);\r\nif (!udc->driver) {\r\npr_warn("%s, Not Regist Driver\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (udc->vbus_active == 0)\r\nreturn -ESHUTDOWN;\r\nspin_lock_irqsave(&udc->lock, flags);\r\n_nbu2ss_pullup(udc, is_on);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int nbu2ss_gad_ioctl(\r\nstruct usb_gadget *pgadget,\r\nunsigned int code,\r\nunsigned long param)\r\n{\r\nreturn 0;\r\n}\r\nstatic void nbu2ss_drv_ep_init(struct nbu2ss_udc *udc)\r\n{\r\nint i;\r\nINIT_LIST_HEAD(&udc->gadget.ep_list);\r\nudc->gadget.ep0 = &udc->ep[0].ep;\r\nfor (i = 0; i < NUM_ENDPOINTS; i++) {\r\nstruct nbu2ss_ep *ep = &udc->ep[i];\r\nep->udc = udc;\r\nep->desc = NULL;\r\nep->ep.driver_data = NULL;\r\nep->ep.name = ep_info[i].name;\r\nep->ep.caps = ep_info[i].caps;\r\nep->ep.ops = &nbu2ss_ep_ops;\r\nusb_ep_set_maxpacket_limit(&ep->ep,\r\ni == 0 ? EP0_PACKETSIZE\r\n: EP_PACKETSIZE);\r\nlist_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);\r\nINIT_LIST_HEAD(&ep->queue);\r\n}\r\nlist_del_init(&udc->ep[0].ep.ep_list);\r\n}\r\nstatic int nbu2ss_drv_contest_init(\r\nstruct platform_device *pdev,\r\nstruct nbu2ss_udc *udc)\r\n{\r\nspin_lock_init(&udc->lock);\r\nudc->dev = &pdev->dev;\r\nudc->gadget.is_selfpowered = 1;\r\nudc->devstate = USB_STATE_NOTATTACHED;\r\nudc->pdev = pdev;\r\nudc->mA = 0;\r\nudc->pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);\r\nnbu2ss_drv_ep_init(udc);\r\nudc->gadget.ops = &nbu2ss_gadget_ops;\r\nudc->gadget.ep0 = &udc->ep[0].ep;\r\nudc->gadget.speed = USB_SPEED_UNKNOWN;\r\nudc->gadget.name = driver_name;\r\ndevice_initialize(&udc->gadget.dev);\r\ndev_set_name(&udc->gadget.dev, "gadget");\r\nudc->gadget.dev.parent = &pdev->dev;\r\nudc->gadget.dev.dma_mask = pdev->dev.dma_mask;\r\nreturn 0;\r\n}\r\nstatic int nbu2ss_drv_probe(struct platform_device *pdev)\r\n{\r\nint status = -ENODEV;\r\nstruct nbu2ss_udc *udc;\r\nstruct resource *r;\r\nint irq;\r\nvoid __iomem *mmio_base;\r\nudc = &udc_controller;\r\nmemset(udc, 0, sizeof(struct nbu2ss_udc));\r\nplatform_set_drvdata(pdev, udc);\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmmio_base = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(mmio_base))\r\nreturn PTR_ERR(mmio_base);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "failed to get IRQ\n");\r\nreturn irq;\r\n}\r\nstatus = devm_request_irq(&pdev->dev, irq, _nbu2ss_udc_irq,\r\n0, driver_name, udc);\r\nudc->p_regs = (struct fc_regs *)mmio_base;\r\nif (status != 0) {\r\ndev_err(udc->dev, "request_irq(USB_UDC_IRQ_1) failed\n");\r\nreturn status;\r\n}\r\nstatus = nbu2ss_drv_contest_init(pdev, udc);\r\nif (status < 0) {\r\nreturn status;\r\n}\r\nirq_set_irq_type(INT_VBUS, IRQ_TYPE_EDGE_BOTH);\r\nstatus = request_irq(INT_VBUS,\r\n_nbu2ss_vbus_irq, IRQF_SHARED, driver_name, udc);\r\nif (status != 0) {\r\ndev_err(udc->dev, "request_irq(INT_VBUS) failed\n");\r\nreturn status;\r\n}\r\nreturn status;\r\n}\r\nstatic void nbu2ss_drv_shutdown(struct platform_device *pdev)\r\n{\r\nstruct nbu2ss_udc *udc;\r\nudc = platform_get_drvdata(pdev);\r\nif (!udc)\r\nreturn;\r\n_nbu2ss_disable_controller(udc);\r\n}\r\nstatic int nbu2ss_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct nbu2ss_udc *udc;\r\nstruct nbu2ss_ep *ep;\r\nint i;\r\nudc = &udc_controller;\r\nfor (i = 0; i < NUM_ENDPOINTS; i++) {\r\nep = &udc->ep[i];\r\nif (ep->virt_buf)\r\ndma_free_coherent(NULL, PAGE_SIZE, (void *)ep->virt_buf,\r\nep->phys_buf);\r\n}\r\nfree_irq(INT_VBUS, udc);\r\nreturn 0;\r\n}\r\nstatic int nbu2ss_drv_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct nbu2ss_udc *udc;\r\nudc = platform_get_drvdata(pdev);\r\nif (!udc)\r\nreturn 0;\r\nif (udc->vbus_active) {\r\nudc->vbus_active = 0;\r\nudc->devstate = USB_STATE_NOTATTACHED;\r\nudc->linux_suspended = 1;\r\nif (udc->usb_suspended) {\r\nudc->usb_suspended = 0;\r\n_nbu2ss_reset_controller(udc);\r\n}\r\n_nbu2ss_quiesce(udc);\r\n}\r\n_nbu2ss_disable_controller(udc);\r\nreturn 0;\r\n}\r\nstatic int nbu2ss_drv_resume(struct platform_device *pdev)\r\n{\r\nu32 data;\r\nstruct nbu2ss_udc *udc;\r\nudc = platform_get_drvdata(pdev);\r\nif (!udc)\r\nreturn 0;\r\ndata = gpio_get_value(VBUS_VALUE);\r\nif (data) {\r\nudc->vbus_active = 1;\r\nudc->devstate = USB_STATE_POWERED;\r\n_nbu2ss_enable_controller(udc);\r\n_nbu2ss_pullup(udc, 1);\r\n}\r\nudc->linux_suspended = 0;\r\nreturn 0;\r\n}
