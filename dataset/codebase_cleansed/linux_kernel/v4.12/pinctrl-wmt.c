static inline void wmt_setbits(struct wmt_pinctrl_data *data, u32 reg,\r\nu32 mask)\r\n{\r\nu32 val;\r\nval = readl_relaxed(data->base + reg);\r\nval |= mask;\r\nwritel_relaxed(val, data->base + reg);\r\n}\r\nstatic inline void wmt_clearbits(struct wmt_pinctrl_data *data, u32 reg,\r\nu32 mask)\r\n{\r\nu32 val;\r\nval = readl_relaxed(data->base + reg);\r\nval &= ~mask;\r\nwritel_relaxed(val, data->base + reg);\r\n}\r\nstatic int wmt_pmx_get_functions_count(struct pinctrl_dev *pctldev)\r\n{\r\nreturn WMT_FSEL_COUNT;\r\n}\r\nstatic const char *wmt_pmx_get_function_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nreturn wmt_functions[selector];\r\n}\r\nstatic int wmt_pmx_get_function_groups(struct pinctrl_dev *pctldev,\r\nunsigned selector,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct wmt_pinctrl_data *data = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = data->groups;\r\n*num_groups = data->ngroups;\r\nreturn 0;\r\n}\r\nstatic int wmt_set_pinmux(struct wmt_pinctrl_data *data, unsigned func,\r\nunsigned pin)\r\n{\r\nu32 bank = WMT_BANK_FROM_PIN(pin);\r\nu32 bit = WMT_BIT_FROM_PIN(pin);\r\nu32 reg_en = data->banks[bank].reg_en;\r\nu32 reg_dir = data->banks[bank].reg_dir;\r\nif (reg_dir == NO_REG) {\r\ndev_err(data->dev, "pin:%d no direction register defined\n",\r\npin);\r\nreturn -EINVAL;\r\n}\r\nswitch (func) {\r\ncase WMT_FSEL_GPIO_IN:\r\nif (reg_en != NO_REG)\r\nwmt_setbits(data, reg_en, BIT(bit));\r\nwmt_clearbits(data, reg_dir, BIT(bit));\r\nbreak;\r\ncase WMT_FSEL_GPIO_OUT:\r\nif (reg_en != NO_REG)\r\nwmt_setbits(data, reg_en, BIT(bit));\r\nwmt_setbits(data, reg_dir, BIT(bit));\r\nbreak;\r\ncase WMT_FSEL_ALT:\r\nif (reg_en == NO_REG) {\r\ndev_err(data->dev, "pin:%d no alt function available\n",\r\npin);\r\nreturn -EINVAL;\r\n}\r\nwmt_clearbits(data, reg_en, BIT(bit));\r\n}\r\nreturn 0;\r\n}\r\nstatic int wmt_pmx_set_mux(struct pinctrl_dev *pctldev,\r\nunsigned func_selector,\r\nunsigned group_selector)\r\n{\r\nstruct wmt_pinctrl_data *data = pinctrl_dev_get_drvdata(pctldev);\r\nu32 pinnum = data->pins[group_selector].number;\r\nreturn wmt_set_pinmux(data, func_selector, pinnum);\r\n}\r\nstatic void wmt_pmx_gpio_disable_free(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset)\r\n{\r\nstruct wmt_pinctrl_data *data = pinctrl_dev_get_drvdata(pctldev);\r\nwmt_set_pinmux(data, WMT_FSEL_GPIO_IN, offset);\r\n}\r\nstatic int wmt_pmx_gpio_set_direction(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset,\r\nbool input)\r\n{\r\nstruct wmt_pinctrl_data *data = pinctrl_dev_get_drvdata(pctldev);\r\nwmt_set_pinmux(data, (input ? WMT_FSEL_GPIO_IN : WMT_FSEL_GPIO_OUT),\r\noffset);\r\nreturn 0;\r\n}\r\nstatic int wmt_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct wmt_pinctrl_data *data = pinctrl_dev_get_drvdata(pctldev);\r\nreturn data->ngroups;\r\n}\r\nstatic const char *wmt_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct wmt_pinctrl_data *data = pinctrl_dev_get_drvdata(pctldev);\r\nreturn data->groups[selector];\r\n}\r\nstatic int wmt_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned selector,\r\nconst unsigned **pins,\r\nunsigned *num_pins)\r\n{\r\nstruct wmt_pinctrl_data *data = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = &data->pins[selector].number;\r\n*num_pins = 1;\r\nreturn 0;\r\n}\r\nstatic int wmt_pctl_find_group_by_pin(struct wmt_pinctrl_data *data, u32 pin)\r\n{\r\nint i;\r\nfor (i = 0; i < data->npins; i++) {\r\nif (data->pins[i].number == pin)\r\nreturn i;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int wmt_pctl_dt_node_to_map_func(struct wmt_pinctrl_data *data,\r\nstruct device_node *np,\r\nu32 pin, u32 fnum,\r\nstruct pinctrl_map **maps)\r\n{\r\nint group;\r\nstruct pinctrl_map *map = *maps;\r\nif (fnum >= ARRAY_SIZE(wmt_functions)) {\r\ndev_err(data->dev, "invalid wm,function %d\n", fnum);\r\nreturn -EINVAL;\r\n}\r\ngroup = wmt_pctl_find_group_by_pin(data, pin);\r\nif (group < 0) {\r\ndev_err(data->dev, "unable to match pin %d to group\n", pin);\r\nreturn group;\r\n}\r\nmap->type = PIN_MAP_TYPE_MUX_GROUP;\r\nmap->data.mux.group = data->groups[group];\r\nmap->data.mux.function = wmt_functions[fnum];\r\n(*maps)++;\r\nreturn 0;\r\n}\r\nstatic int wmt_pctl_dt_node_to_map_pull(struct wmt_pinctrl_data *data,\r\nstruct device_node *np,\r\nu32 pin, u32 pull,\r\nstruct pinctrl_map **maps)\r\n{\r\nint group;\r\nunsigned long *configs;\r\nstruct pinctrl_map *map = *maps;\r\nif (pull > 2) {\r\ndev_err(data->dev, "invalid wm,pull %d\n", pull);\r\nreturn -EINVAL;\r\n}\r\ngroup = wmt_pctl_find_group_by_pin(data, pin);\r\nif (group < 0) {\r\ndev_err(data->dev, "unable to match pin %d to group\n", pin);\r\nreturn group;\r\n}\r\nconfigs = kzalloc(sizeof(*configs), GFP_KERNEL);\r\nif (!configs)\r\nreturn -ENOMEM;\r\nswitch (pull) {\r\ncase 0:\r\nconfigs[0] = PIN_CONFIG_BIAS_DISABLE;\r\nbreak;\r\ncase 1:\r\nconfigs[0] = PIN_CONFIG_BIAS_PULL_DOWN;\r\nbreak;\r\ncase 2:\r\nconfigs[0] = PIN_CONFIG_BIAS_PULL_UP;\r\nbreak;\r\ndefault:\r\nconfigs[0] = PIN_CONFIG_BIAS_DISABLE;\r\ndev_err(data->dev, "invalid pull state %d - disabling\n", pull);\r\n}\r\nmap->type = PIN_MAP_TYPE_CONFIGS_PIN;\r\nmap->data.configs.group_or_pin = data->groups[group];\r\nmap->data.configs.configs = configs;\r\nmap->data.configs.num_configs = 1;\r\n(*maps)++;\r\nreturn 0;\r\n}\r\nstatic void wmt_pctl_dt_free_map(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_map *maps,\r\nunsigned num_maps)\r\n{\r\nint i;\r\nfor (i = 0; i < num_maps; i++)\r\nif (maps[i].type == PIN_MAP_TYPE_CONFIGS_PIN)\r\nkfree(maps[i].data.configs.configs);\r\nkfree(maps);\r\n}\r\nstatic int wmt_pctl_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np,\r\nstruct pinctrl_map **map,\r\nunsigned *num_maps)\r\n{\r\nstruct pinctrl_map *maps, *cur_map;\r\nstruct property *pins, *funcs, *pulls;\r\nu32 pin, func, pull;\r\nint num_pins, num_funcs, num_pulls, maps_per_pin;\r\nint i, err;\r\nstruct wmt_pinctrl_data *data = pinctrl_dev_get_drvdata(pctldev);\r\npins = of_find_property(np, "wm,pins", NULL);\r\nif (!pins) {\r\ndev_err(data->dev, "missing wmt,pins property\n");\r\nreturn -EINVAL;\r\n}\r\nfuncs = of_find_property(np, "wm,function", NULL);\r\npulls = of_find_property(np, "wm,pull", NULL);\r\nif (!funcs && !pulls) {\r\ndev_err(data->dev, "neither wm,function nor wm,pull specified\n");\r\nreturn -EINVAL;\r\n}\r\nnum_pins = pins->length / sizeof(u32);\r\nnum_funcs = funcs ? (funcs->length / sizeof(u32)) : 0;\r\nnum_pulls = pulls ? (pulls->length / sizeof(u32)) : 0;\r\nif (num_funcs > 1 && num_funcs != num_pins) {\r\ndev_err(data->dev, "wm,function must have 1 or %d entries\n",\r\nnum_pins);\r\nreturn -EINVAL;\r\n}\r\nif (num_pulls > 1 && num_pulls != num_pins) {\r\ndev_err(data->dev, "wm,pull must have 1 or %d entries\n",\r\nnum_pins);\r\nreturn -EINVAL;\r\n}\r\nmaps_per_pin = 0;\r\nif (num_funcs)\r\nmaps_per_pin++;\r\nif (num_pulls)\r\nmaps_per_pin++;\r\ncur_map = maps = kzalloc(num_pins * maps_per_pin * sizeof(*maps),\r\nGFP_KERNEL);\r\nif (!maps)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < num_pins; i++) {\r\nerr = of_property_read_u32_index(np, "wm,pins", i, &pin);\r\nif (err)\r\ngoto fail;\r\nif (pin >= (data->nbanks * 32)) {\r\ndev_err(data->dev, "invalid wm,pins value\n");\r\nerr = -EINVAL;\r\ngoto fail;\r\n}\r\nif (num_funcs) {\r\nerr = of_property_read_u32_index(np, "wm,function",\r\n(num_funcs > 1 ? i : 0), &func);\r\nif (err)\r\ngoto fail;\r\nerr = wmt_pctl_dt_node_to_map_func(data, np, pin, func,\r\n&cur_map);\r\nif (err)\r\ngoto fail;\r\n}\r\nif (num_pulls) {\r\nerr = of_property_read_u32_index(np, "wm,pull",\r\n(num_pulls > 1 ? i : 0), &pull);\r\nif (err)\r\ngoto fail;\r\nerr = wmt_pctl_dt_node_to_map_pull(data, np, pin, pull,\r\n&cur_map);\r\nif (err)\r\ngoto fail;\r\n}\r\n}\r\n*map = maps;\r\n*num_maps = num_pins * maps_per_pin;\r\nreturn 0;\r\nfail:\r\nwmt_pctl_dt_free_map(pctldev, maps, num_pins * maps_per_pin);\r\nreturn err;\r\n}\r\nstatic int wmt_pinconf_get(struct pinctrl_dev *pctldev, unsigned pin,\r\nunsigned long *config)\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int wmt_pinconf_set(struct pinctrl_dev *pctldev, unsigned pin,\r\nunsigned long *configs, unsigned num_configs)\r\n{\r\nstruct wmt_pinctrl_data *data = pinctrl_dev_get_drvdata(pctldev);\r\nenum pin_config_param param;\r\nu32 arg;\r\nu32 bank = WMT_BANK_FROM_PIN(pin);\r\nu32 bit = WMT_BIT_FROM_PIN(pin);\r\nu32 reg_pull_en = data->banks[bank].reg_pull_en;\r\nu32 reg_pull_cfg = data->banks[bank].reg_pull_cfg;\r\nint i;\r\nif ((reg_pull_en == NO_REG) || (reg_pull_cfg == NO_REG)) {\r\ndev_err(data->dev, "bias functions not supported on pin %d\n",\r\npin);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = pinconf_to_config_param(configs[i]);\r\narg = pinconf_to_config_argument(configs[i]);\r\nif ((param == PIN_CONFIG_BIAS_PULL_DOWN) ||\r\n(param == PIN_CONFIG_BIAS_PULL_UP)) {\r\nif (arg == 0)\r\nparam = PIN_CONFIG_BIAS_DISABLE;\r\n}\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nwmt_clearbits(data, reg_pull_en, BIT(bit));\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nwmt_clearbits(data, reg_pull_cfg, BIT(bit));\r\nwmt_setbits(data, reg_pull_en, BIT(bit));\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nwmt_setbits(data, reg_pull_cfg, BIT(bit));\r\nwmt_setbits(data, reg_pull_en, BIT(bit));\r\nbreak;\r\ndefault:\r\ndev_err(data->dev, "unknown pinconf param\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int wmt_gpio_get_direction(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct wmt_pinctrl_data *data = gpiochip_get_data(chip);\r\nu32 bank = WMT_BANK_FROM_PIN(offset);\r\nu32 bit = WMT_BIT_FROM_PIN(offset);\r\nu32 reg_dir = data->banks[bank].reg_dir;\r\nu32 val;\r\nval = readl_relaxed(data->base + reg_dir);\r\nif (val & BIT(bit))\r\nreturn GPIOF_DIR_OUT;\r\nelse\r\nreturn GPIOF_DIR_IN;\r\n}\r\nstatic int wmt_gpio_get_value(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct wmt_pinctrl_data *data = gpiochip_get_data(chip);\r\nu32 bank = WMT_BANK_FROM_PIN(offset);\r\nu32 bit = WMT_BIT_FROM_PIN(offset);\r\nu32 reg_data_in = data->banks[bank].reg_data_in;\r\nif (reg_data_in == NO_REG) {\r\ndev_err(data->dev, "no data in register defined\n");\r\nreturn -EINVAL;\r\n}\r\nreturn !!(readl_relaxed(data->base + reg_data_in) & BIT(bit));\r\n}\r\nstatic void wmt_gpio_set_value(struct gpio_chip *chip, unsigned offset,\r\nint val)\r\n{\r\nstruct wmt_pinctrl_data *data = gpiochip_get_data(chip);\r\nu32 bank = WMT_BANK_FROM_PIN(offset);\r\nu32 bit = WMT_BIT_FROM_PIN(offset);\r\nu32 reg_data_out = data->banks[bank].reg_data_out;\r\nif (reg_data_out == NO_REG) {\r\ndev_err(data->dev, "no data out register defined\n");\r\nreturn;\r\n}\r\nif (val)\r\nwmt_setbits(data, reg_data_out, BIT(bit));\r\nelse\r\nwmt_clearbits(data, reg_data_out, BIT(bit));\r\n}\r\nstatic int wmt_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn pinctrl_gpio_direction_input(chip->base + offset);\r\n}\r\nstatic int wmt_gpio_direction_output(struct gpio_chip *chip, unsigned offset,\r\nint value)\r\n{\r\nwmt_gpio_set_value(chip, offset, value);\r\nreturn pinctrl_gpio_direction_output(chip->base + offset);\r\n}\r\nint wmt_pinctrl_probe(struct platform_device *pdev,\r\nstruct wmt_pinctrl_data *data)\r\n{\r\nint err;\r\nstruct resource *res;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndata->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(data->base))\r\nreturn PTR_ERR(data->base);\r\nwmt_desc.pins = data->pins;\r\nwmt_desc.npins = data->npins;\r\ndata->gpio_chip = wmt_gpio_chip;\r\ndata->gpio_chip.parent = &pdev->dev;\r\ndata->gpio_chip.of_node = pdev->dev.of_node;\r\ndata->gpio_chip.ngpio = data->nbanks * 32;\r\nplatform_set_drvdata(pdev, data);\r\ndata->dev = &pdev->dev;\r\ndata->pctl_dev = devm_pinctrl_register(&pdev->dev, &wmt_desc, data);\r\nif (IS_ERR(data->pctl_dev)) {\r\ndev_err(&pdev->dev, "Failed to register pinctrl\n");\r\nreturn PTR_ERR(data->pctl_dev);\r\n}\r\nerr = gpiochip_add_data(&data->gpio_chip, data);\r\nif (err) {\r\ndev_err(&pdev->dev, "could not add GPIO chip\n");\r\nreturn err;\r\n}\r\nerr = gpiochip_add_pin_range(&data->gpio_chip, dev_name(data->dev),\r\n0, 0, data->nbanks * 32);\r\nif (err)\r\ngoto fail_range;\r\ndev_info(&pdev->dev, "Pin controller initialized\n");\r\nreturn 0;\r\nfail_range:\r\ngpiochip_remove(&data->gpio_chip);\r\nreturn err;\r\n}
