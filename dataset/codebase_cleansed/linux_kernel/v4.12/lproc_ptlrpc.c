const char *ll_opcode2str(__u32 opcode)\r\n{\r\n__u32 offset = opcode_offset(opcode);\r\nLASSERTF(offset < LUSTRE_MAX_OPCODES,\r\n"offset %u >= LUSTRE_MAX_OPCODES %u\n",\r\noffset, LUSTRE_MAX_OPCODES);\r\nLASSERTF(ll_rpc_opcode_table[offset].opcode == opcode,\r\n"ll_rpc_opcode_table[%u].opcode %u != opcode %u\n",\r\noffset, ll_rpc_opcode_table[offset].opcode, opcode);\r\nreturn ll_rpc_opcode_table[offset].opname;\r\n}\r\nstatic const char *ll_eopcode2str(__u32 opcode)\r\n{\r\nLASSERT(ll_eopcode_table[opcode].opcode == opcode);\r\nreturn ll_eopcode_table[opcode].opname;\r\n}\r\nstatic void\r\nptlrpc_ldebugfs_register(struct dentry *root, char *dir,\r\nchar *name,\r\nstruct dentry **debugfs_root_ret,\r\nstruct lprocfs_stats **stats_ret)\r\n{\r\nstruct dentry *svc_debugfs_entry;\r\nstruct lprocfs_stats *svc_stats;\r\nint i, rc;\r\nunsigned int svc_counter_config = LPROCFS_CNTR_AVGMINMAX |\r\nLPROCFS_CNTR_STDDEV;\r\nLASSERT(!*debugfs_root_ret);\r\nLASSERT(!*stats_ret);\r\nsvc_stats = lprocfs_alloc_stats(EXTRA_MAX_OPCODES + LUSTRE_MAX_OPCODES,\r\n0);\r\nif (!svc_stats)\r\nreturn;\r\nif (dir) {\r\nsvc_debugfs_entry = ldebugfs_register(dir, root, NULL, NULL);\r\nif (IS_ERR(svc_debugfs_entry)) {\r\nlprocfs_free_stats(&svc_stats);\r\nreturn;\r\n}\r\n} else {\r\nsvc_debugfs_entry = root;\r\n}\r\nlprocfs_counter_init(svc_stats, PTLRPC_REQWAIT_CNTR,\r\nsvc_counter_config, "req_waittime", "usec");\r\nlprocfs_counter_init(svc_stats, PTLRPC_REQQDEPTH_CNTR,\r\nsvc_counter_config, "req_qdepth", "reqs");\r\nlprocfs_counter_init(svc_stats, PTLRPC_REQACTIVE_CNTR,\r\nsvc_counter_config, "req_active", "reqs");\r\nlprocfs_counter_init(svc_stats, PTLRPC_TIMEOUT,\r\nsvc_counter_config, "req_timeout", "sec");\r\nlprocfs_counter_init(svc_stats, PTLRPC_REQBUF_AVAIL_CNTR,\r\nsvc_counter_config, "reqbuf_avail", "bufs");\r\nfor (i = 0; i < EXTRA_LAST_OPC; i++) {\r\nchar *units;\r\nswitch (i) {\r\ncase BRW_WRITE_BYTES:\r\ncase BRW_READ_BYTES:\r\nunits = "bytes";\r\nbreak;\r\ndefault:\r\nunits = "reqs";\r\nbreak;\r\n}\r\nlprocfs_counter_init(svc_stats, PTLRPC_LAST_CNTR + i,\r\nsvc_counter_config,\r\nll_eopcode2str(i), units);\r\n}\r\nfor (i = 0; i < LUSTRE_MAX_OPCODES; i++) {\r\n__u32 opcode = ll_rpc_opcode_table[i].opcode;\r\nlprocfs_counter_init(svc_stats,\r\nEXTRA_MAX_OPCODES + i, svc_counter_config,\r\nll_opcode2str(opcode), "usec");\r\n}\r\nrc = ldebugfs_register_stats(svc_debugfs_entry, name, svc_stats);\r\nif (rc < 0) {\r\nif (dir)\r\nldebugfs_remove(&svc_debugfs_entry);\r\nlprocfs_free_stats(&svc_stats);\r\n} else {\r\nif (dir)\r\n*debugfs_root_ret = svc_debugfs_entry;\r\n*stats_ret = svc_stats;\r\n}\r\n}\r\nstatic int\r\nptlrpc_lprocfs_req_history_len_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct ptlrpc_service *svc = m->private;\r\nstruct ptlrpc_service_part *svcpt;\r\nint total = 0;\r\nint i;\r\nptlrpc_service_for_each_part(svcpt, i, svc)\r\ntotal += svcpt->scp_hist_nrqbds;\r\nseq_printf(m, "%d\n", total);\r\nreturn 0;\r\n}\r\nstatic int\r\nptlrpc_lprocfs_req_history_max_seq_show(struct seq_file *m, void *n)\r\n{\r\nstruct ptlrpc_service *svc = m->private;\r\nstruct ptlrpc_service_part *svcpt;\r\nint total = 0;\r\nint i;\r\nptlrpc_service_for_each_part(svcpt, i, svc)\r\ntotal += svc->srv_hist_nrqbds_cpt_max;\r\nseq_printf(m, "%d\n", total);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nptlrpc_lprocfs_req_history_max_seq_write(struct file *file,\r\nconst char __user *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct ptlrpc_service *svc = ((struct seq_file *)file->private_data)->private;\r\nint bufpages;\r\nint val;\r\nint rc;\r\nrc = lprocfs_write_helper(buffer, count, &val);\r\nif (rc < 0)\r\nreturn rc;\r\nif (val < 0)\r\nreturn -ERANGE;\r\nbufpages = (svc->srv_buf_size + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nif (val > totalram_pages / (2 * bufpages))\r\nreturn -ERANGE;\r\nspin_lock(&svc->srv_lock);\r\nif (val == 0)\r\nsvc->srv_hist_nrqbds_cpt_max = 0;\r\nelse\r\nsvc->srv_hist_nrqbds_cpt_max = max(1, (val / svc->srv_ncpts));\r\nspin_unlock(&svc->srv_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t threads_min_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ptlrpc_service *svc = container_of(kobj, struct ptlrpc_service,\r\nsrv_kobj);\r\nreturn sprintf(buf, "%d\n", svc->srv_nthrs_cpt_init * svc->srv_ncpts);\r\n}\r\nstatic ssize_t threads_min_store(struct kobject *kobj, struct attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nstruct ptlrpc_service *svc = container_of(kobj, struct ptlrpc_service,\r\nsrv_kobj);\r\nunsigned long val;\r\nint rc = kstrtoul(buffer, 10, &val);\r\nif (rc < 0)\r\nreturn rc;\r\nif (val / svc->srv_ncpts < PTLRPC_NTHRS_INIT)\r\nreturn -ERANGE;\r\nspin_lock(&svc->srv_lock);\r\nif (val > svc->srv_nthrs_cpt_limit * svc->srv_ncpts) {\r\nspin_unlock(&svc->srv_lock);\r\nreturn -ERANGE;\r\n}\r\nsvc->srv_nthrs_cpt_init = val / svc->srv_ncpts;\r\nspin_unlock(&svc->srv_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t threads_started_show(struct kobject *kobj,\r\nstruct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ptlrpc_service *svc = container_of(kobj, struct ptlrpc_service,\r\nsrv_kobj);\r\nstruct ptlrpc_service_part *svcpt;\r\nint total = 0;\r\nint i;\r\nptlrpc_service_for_each_part(svcpt, i, svc)\r\ntotal += svcpt->scp_nthrs_running;\r\nreturn sprintf(buf, "%d\n", total);\r\n}\r\nstatic ssize_t threads_max_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ptlrpc_service *svc = container_of(kobj, struct ptlrpc_service,\r\nsrv_kobj);\r\nreturn sprintf(buf, "%d\n", svc->srv_nthrs_cpt_limit * svc->srv_ncpts);\r\n}\r\nstatic ssize_t threads_max_store(struct kobject *kobj, struct attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nstruct ptlrpc_service *svc = container_of(kobj, struct ptlrpc_service,\r\nsrv_kobj);\r\nunsigned long val;\r\nint rc = kstrtoul(buffer, 10, &val);\r\nif (rc < 0)\r\nreturn rc;\r\nif (val / svc->srv_ncpts < PTLRPC_NTHRS_INIT)\r\nreturn -ERANGE;\r\nspin_lock(&svc->srv_lock);\r\nif (val < svc->srv_nthrs_cpt_init * svc->srv_ncpts) {\r\nspin_unlock(&svc->srv_lock);\r\nreturn -ERANGE;\r\n}\r\nsvc->srv_nthrs_cpt_limit = val / svc->srv_ncpts;\r\nspin_unlock(&svc->srv_lock);\r\nreturn count;\r\n}\r\nstatic const char *nrs_state2str(enum ptlrpc_nrs_pol_state state)\r\n{\r\nswitch (state) {\r\ndefault:\r\nLBUG();\r\ncase NRS_POL_STATE_INVALID:\r\nreturn "invalid";\r\ncase NRS_POL_STATE_STOPPED:\r\nreturn "stopped";\r\ncase NRS_POL_STATE_STOPPING:\r\nreturn "stopping";\r\ncase NRS_POL_STATE_STARTING:\r\nreturn "starting";\r\ncase NRS_POL_STATE_STARTED:\r\nreturn "started";\r\n}\r\n}\r\nstatic void nrs_policy_get_info_locked(struct ptlrpc_nrs_policy *policy,\r\nstruct ptlrpc_nrs_pol_info *info)\r\n{\r\nassert_spin_locked(&policy->pol_nrs->nrs_lock);\r\nmemcpy(info->pi_name, policy->pol_desc->pd_name, NRS_POL_NAME_MAX);\r\ninfo->pi_fallback = !!(policy->pol_flags & PTLRPC_NRS_FL_FALLBACK);\r\ninfo->pi_state = policy->pol_state;\r\ninfo->pi_req_queued = policy->pol_req_queued;\r\ninfo->pi_req_started = policy->pol_req_started;\r\n}\r\nstatic int ptlrpc_lprocfs_nrs_seq_show(struct seq_file *m, void *n)\r\n{\r\nstruct ptlrpc_service *svc = m->private;\r\nstruct ptlrpc_service_part *svcpt;\r\nstruct ptlrpc_nrs *nrs;\r\nstruct ptlrpc_nrs_policy *policy;\r\nstruct ptlrpc_nrs_pol_info *infos;\r\nstruct ptlrpc_nrs_pol_info tmp;\r\nunsigned int num_pols;\r\nunsigned int pol_idx = 0;\r\nbool hp = false;\r\nint i;\r\nint rc = 0;\r\nmutex_lock(&nrs_core.nrs_mutex);\r\nnrs = nrs_svcpt2nrs(svc->srv_parts[0], false);\r\nspin_lock(&nrs->nrs_lock);\r\nnum_pols = svc->srv_parts[0]->scp_nrs_reg.nrs_num_pols;\r\nspin_unlock(&nrs->nrs_lock);\r\ninfos = kcalloc(num_pols, sizeof(*infos), GFP_NOFS);\r\nif (!infos) {\r\nrc = -ENOMEM;\r\ngoto unlock;\r\n}\r\nagain:\r\nptlrpc_service_for_each_part(svcpt, i, svc) {\r\nnrs = nrs_svcpt2nrs(svcpt, hp);\r\nspin_lock(&nrs->nrs_lock);\r\npol_idx = 0;\r\nlist_for_each_entry(policy, &nrs->nrs_policy_list, pol_list) {\r\nLASSERT(pol_idx < num_pols);\r\nnrs_policy_get_info_locked(policy, &tmp);\r\nif (i == 0) {\r\nmemcpy(infos[pol_idx].pi_name, tmp.pi_name,\r\nNRS_POL_NAME_MAX);\r\nmemcpy(&infos[pol_idx].pi_state, &tmp.pi_state,\r\nsizeof(tmp.pi_state));\r\ninfos[pol_idx].pi_fallback = tmp.pi_fallback;\r\n} else {\r\nLASSERT(strncmp(infos[pol_idx].pi_name,\r\ntmp.pi_name,\r\nNRS_POL_NAME_MAX) == 0);\r\nLASSERT(infos[pol_idx].pi_fallback ==\r\ntmp.pi_fallback);\r\n}\r\ninfos[pol_idx].pi_req_queued += tmp.pi_req_queued;\r\ninfos[pol_idx].pi_req_started += tmp.pi_req_started;\r\npol_idx++;\r\n}\r\nspin_unlock(&nrs->nrs_lock);\r\n}\r\nseq_printf(m, "%s\n",\r\n!hp ? "\nregular_requests:" : "high_priority_requests:");\r\nfor (pol_idx = 0; pol_idx < num_pols; pol_idx++) {\r\nseq_printf(m, " - name: %s\n"\r\n" state: %s\n"\r\n" fallback: %s\n"\r\n" queued: %-20d\n"\r\n" active: %-20d\n\n",\r\ninfos[pol_idx].pi_name,\r\nnrs_state2str(infos[pol_idx].pi_state),\r\ninfos[pol_idx].pi_fallback ? "yes" : "no",\r\n(int)infos[pol_idx].pi_req_queued,\r\n(int)infos[pol_idx].pi_req_started);\r\n}\r\nif (!hp && nrs_svc_has_hp(svc)) {\r\nmemset(infos, 0, num_pols * sizeof(*infos));\r\nhp = true;\r\ngoto again;\r\n}\r\nkfree(infos);\r\nunlock:\r\nmutex_unlock(&nrs_core.nrs_mutex);\r\nreturn rc;\r\n}\r\nstatic ssize_t ptlrpc_lprocfs_nrs_seq_write(struct file *file,\r\nconst char __user *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct ptlrpc_service *svc = ((struct seq_file *)file->private_data)->private;\r\nenum ptlrpc_nrs_queue_type queue = PTLRPC_NRS_QUEUE_BOTH;\r\nchar *cmd;\r\nchar *cmd_copy = NULL;\r\nchar *token;\r\nint rc = 0;\r\nif (count >= LPROCFS_NRS_WR_MAX_CMD)\r\nreturn -EINVAL;\r\ncmd = kzalloc(LPROCFS_NRS_WR_MAX_CMD, GFP_NOFS);\r\nif (!cmd)\r\nreturn -ENOMEM;\r\ncmd_copy = cmd;\r\nif (copy_from_user(cmd, buffer, count)) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\ncmd[count] = '\0';\r\ntoken = strsep(&cmd, " ");\r\nif (strlen(token) > NRS_POL_NAME_MAX - 1) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (!cmd)\r\ngoto default_queue;\r\nif (strcmp(cmd, "reg") == 0) {\r\nqueue = PTLRPC_NRS_QUEUE_REG;\r\n} else if (strcmp(cmd, "hp") == 0) {\r\nqueue = PTLRPC_NRS_QUEUE_HP;\r\n} else {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\ndefault_queue:\r\nif (queue == PTLRPC_NRS_QUEUE_HP && !nrs_svc_has_hp(svc)) {\r\nrc = -ENODEV;\r\ngoto out;\r\n} else if (queue == PTLRPC_NRS_QUEUE_BOTH && !nrs_svc_has_hp(svc)) {\r\nqueue = PTLRPC_NRS_QUEUE_REG;\r\n}\r\nmutex_lock(&nrs_core.nrs_mutex);\r\nrc = ptlrpc_nrs_policy_control(svc, queue, token, PTLRPC_NRS_CTL_START,\r\nfalse, NULL);\r\nmutex_unlock(&nrs_core.nrs_mutex);\r\nout:\r\nkfree(cmd_copy);\r\nreturn rc < 0 ? rc : count;\r\n}\r\nstatic int\r\nptlrpc_lprocfs_svc_req_history_seek(struct ptlrpc_service_part *svcpt,\r\nstruct ptlrpc_srh_iterator *srhi,\r\n__u64 seq)\r\n{\r\nstruct list_head *e;\r\nstruct ptlrpc_request *req;\r\nif (srhi->srhi_req && srhi->srhi_seq > svcpt->scp_hist_seq_culled &&\r\nsrhi->srhi_seq <= seq) {\r\nLASSERTF(srhi->srhi_seq == srhi->srhi_req->rq_history_seq,\r\n"%s:%d: seek seq %llu, request seq %llu\n",\r\nsvcpt->scp_service->srv_name, svcpt->scp_cpt,\r\nsrhi->srhi_seq, srhi->srhi_req->rq_history_seq);\r\nLASSERTF(!list_empty(&svcpt->scp_hist_reqs),\r\n"%s:%d: seek offset %llu, request seq %llu, last culled %llu\n",\r\nsvcpt->scp_service->srv_name, svcpt->scp_cpt,\r\nseq, srhi->srhi_seq, svcpt->scp_hist_seq_culled);\r\ne = &srhi->srhi_req->rq_history_list;\r\n} else {\r\ne = svcpt->scp_hist_reqs.next;\r\n}\r\nwhile (e != &svcpt->scp_hist_reqs) {\r\nreq = list_entry(e, struct ptlrpc_request, rq_history_list);\r\nif (req->rq_history_seq >= seq) {\r\nsrhi->srhi_seq = req->rq_history_seq;\r\nsrhi->srhi_req = req;\r\nreturn 0;\r\n}\r\ne = e->next;\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic void *\r\nptlrpc_lprocfs_svc_req_history_start(struct seq_file *s, loff_t *pos)\r\n{\r\nstruct ptlrpc_service *svc = s->private;\r\nstruct ptlrpc_service_part *svcpt;\r\nstruct ptlrpc_srh_iterator *srhi;\r\nunsigned int cpt;\r\nint rc;\r\nint i;\r\nif (sizeof(loff_t) != sizeof(__u64)) {\r\nCWARN("Failed to read request history because size of loff_t %d can't match size of u64\n",\r\n(int)sizeof(loff_t));\r\nreturn NULL;\r\n}\r\nsrhi = kzalloc(sizeof(*srhi), GFP_NOFS);\r\nif (!srhi)\r\nreturn NULL;\r\nsrhi->srhi_seq = 0;\r\nsrhi->srhi_req = NULL;\r\ncpt = PTLRPC_REQ_POS2CPT(svc, *pos);\r\nptlrpc_service_for_each_part(svcpt, i, svc) {\r\nif (i < cpt)\r\ncontinue;\r\nif (i > cpt)\r\n*pos = PTLRPC_REQ_CPT2POS(svc, i);\r\nspin_lock(&svcpt->scp_lock);\r\nrc = ptlrpc_lprocfs_svc_req_history_seek(svcpt, srhi,\r\nPTLRPC_REQ_POS2SEQ(svc, *pos));\r\nspin_unlock(&svcpt->scp_lock);\r\nif (rc == 0) {\r\n*pos = PTLRPC_REQ_SEQ2POS(svc, srhi->srhi_seq);\r\nsrhi->srhi_idx = i;\r\nreturn srhi;\r\n}\r\n}\r\nkfree(srhi);\r\nreturn NULL;\r\n}\r\nstatic void\r\nptlrpc_lprocfs_svc_req_history_stop(struct seq_file *s, void *iter)\r\n{\r\nstruct ptlrpc_srh_iterator *srhi = iter;\r\nkfree(srhi);\r\n}\r\nstatic void *\r\nptlrpc_lprocfs_svc_req_history_next(struct seq_file *s,\r\nvoid *iter, loff_t *pos)\r\n{\r\nstruct ptlrpc_service *svc = s->private;\r\nstruct ptlrpc_srh_iterator *srhi = iter;\r\nstruct ptlrpc_service_part *svcpt;\r\n__u64 seq;\r\nint rc;\r\nint i;\r\nfor (i = srhi->srhi_idx; i < svc->srv_ncpts; i++) {\r\nsvcpt = svc->srv_parts[i];\r\nif (i > srhi->srhi_idx) {\r\nsrhi->srhi_req = NULL;\r\nseq = 0;\r\nsrhi->srhi_seq = 0;\r\n} else {\r\nseq = srhi->srhi_seq + (1 << svc->srv_cpt_bits);\r\n}\r\nspin_lock(&svcpt->scp_lock);\r\nrc = ptlrpc_lprocfs_svc_req_history_seek(svcpt, srhi, seq);\r\nspin_unlock(&svcpt->scp_lock);\r\nif (rc == 0) {\r\n*pos = PTLRPC_REQ_SEQ2POS(svc, srhi->srhi_seq);\r\nsrhi->srhi_idx = i;\r\nreturn srhi;\r\n}\r\n}\r\nkfree(srhi);\r\nreturn NULL;\r\n}\r\nstatic int ptlrpc_lprocfs_svc_req_history_show(struct seq_file *s, void *iter)\r\n{\r\nstruct ptlrpc_service *svc = s->private;\r\nstruct ptlrpc_srh_iterator *srhi = iter;\r\nstruct ptlrpc_service_part *svcpt;\r\nstruct ptlrpc_request *req;\r\nint rc;\r\nLASSERT(srhi->srhi_idx < svc->srv_ncpts);\r\nsvcpt = svc->srv_parts[srhi->srhi_idx];\r\nspin_lock(&svcpt->scp_lock);\r\nrc = ptlrpc_lprocfs_svc_req_history_seek(svcpt, srhi, srhi->srhi_seq);\r\nif (rc == 0) {\r\nchar nidstr[LNET_NIDSTR_SIZE];\r\nreq = srhi->srhi_req;\r\nlibcfs_nid2str_r(req->rq_self, nidstr, sizeof(nidstr));\r\nseq_printf(s, "%lld:%s:%s:x%llu:%d:%s:%lld:%lds(%+lds) ",\r\nreq->rq_history_seq, nidstr,\r\nlibcfs_id2str(req->rq_peer), req->rq_xid,\r\nreq->rq_reqlen, ptlrpc_rqphase2str(req),\r\n(s64)req->rq_arrival_time.tv_sec,\r\n(long)(req->rq_sent - req->rq_arrival_time.tv_sec),\r\n(long)(req->rq_sent - req->rq_deadline));\r\nif (!svc->srv_ops.so_req_printer)\r\nseq_putc(s, '\n');\r\nelse\r\nsvc->srv_ops.so_req_printer(s, srhi->srhi_req);\r\n}\r\nspin_unlock(&svcpt->scp_lock);\r\nreturn rc;\r\n}\r\nstatic int\r\nptlrpc_lprocfs_svc_req_history_open(struct inode *inode, struct file *file)\r\n{\r\nstatic const struct seq_operations sops = {\r\n.start = ptlrpc_lprocfs_svc_req_history_start,\r\n.stop = ptlrpc_lprocfs_svc_req_history_stop,\r\n.next = ptlrpc_lprocfs_svc_req_history_next,\r\n.show = ptlrpc_lprocfs_svc_req_history_show,\r\n};\r\nstruct seq_file *seqf;\r\nint rc;\r\nrc = seq_open(file, &sops);\r\nif (rc)\r\nreturn rc;\r\nseqf = file->private_data;\r\nseqf->private = inode->i_private;\r\nreturn 0;\r\n}\r\nstatic int ptlrpc_lprocfs_timeouts_seq_show(struct seq_file *m, void *n)\r\n{\r\nstruct ptlrpc_service *svc = m->private;\r\nstruct ptlrpc_service_part *svcpt;\r\nstruct dhms ts;\r\ntime64_t worstt;\r\nunsigned int cur;\r\nunsigned int worst;\r\nint i;\r\nif (AT_OFF) {\r\nseq_printf(m, "adaptive timeouts off, using obd_timeout %u\n",\r\nobd_timeout);\r\nreturn 0;\r\n}\r\nptlrpc_service_for_each_part(svcpt, i, svc) {\r\ncur = at_get(&svcpt->scp_at_estimate);\r\nworst = svcpt->scp_at_estimate.at_worst_ever;\r\nworstt = svcpt->scp_at_estimate.at_worst_time;\r\ns2dhms(&ts, ktime_get_real_seconds() - worstt);\r\nseq_printf(m, "%10s : cur %3u worst %3u (at %lld, "\r\nDHMS_FMT " ago) ", "service",\r\ncur, worst, (s64)worstt, DHMS_VARS(&ts));\r\nlprocfs_at_hist_helper(m, &svcpt->scp_at_estimate);\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t high_priority_ratio_show(struct kobject *kobj,\r\nstruct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ptlrpc_service *svc = container_of(kobj, struct ptlrpc_service,\r\nsrv_kobj);\r\nreturn sprintf(buf, "%d\n", svc->srv_hpreq_ratio);\r\n}\r\nstatic ssize_t high_priority_ratio_store(struct kobject *kobj,\r\nstruct attribute *attr,\r\nconst char *buffer,\r\nsize_t count)\r\n{\r\nstruct ptlrpc_service *svc = container_of(kobj, struct ptlrpc_service,\r\nsrv_kobj);\r\nint rc;\r\nint val;\r\nrc = kstrtoint(buffer, 10, &val);\r\nif (rc < 0)\r\nreturn rc;\r\nif (val < 0)\r\nreturn -ERANGE;\r\nspin_lock(&svc->srv_lock);\r\nsvc->srv_hpreq_ratio = val;\r\nspin_unlock(&svc->srv_lock);\r\nreturn count;\r\n}\r\nstatic void ptlrpc_sysfs_svc_release(struct kobject *kobj)\r\n{\r\nstruct ptlrpc_service *svc = container_of(kobj, struct ptlrpc_service,\r\nsrv_kobj);\r\ncomplete(&svc->srv_kobj_unregister);\r\n}\r\nvoid ptlrpc_sysfs_unregister_service(struct ptlrpc_service *svc)\r\n{\r\nif (svc->srv_kobj.kset) {\r\nkobject_put(&svc->srv_kobj);\r\nwait_for_completion(&svc->srv_kobj_unregister);\r\n}\r\n}\r\nint ptlrpc_sysfs_register_service(struct kset *parent,\r\nstruct ptlrpc_service *svc)\r\n{\r\nint rc;\r\nsvc->srv_kobj.kset = parent;\r\ninit_completion(&svc->srv_kobj_unregister);\r\nrc = kobject_init_and_add(&svc->srv_kobj, &ptlrpc_svc_ktype, NULL,\r\n"%s", svc->srv_name);\r\nreturn rc;\r\n}\r\nvoid ptlrpc_ldebugfs_register_service(struct dentry *entry,\r\nstruct ptlrpc_service *svc)\r\n{\r\nstruct lprocfs_vars lproc_vars[] = {\r\n{.name = "req_buffer_history_len",\r\n.fops = &ptlrpc_lprocfs_req_history_len_fops,\r\n.data = svc},\r\n{.name = "req_buffer_history_max",\r\n.fops = &ptlrpc_lprocfs_req_history_max_fops,\r\n.data = svc},\r\n{.name = "timeouts",\r\n.fops = &ptlrpc_lprocfs_timeouts_fops,\r\n.data = svc},\r\n{.name = "nrs_policies",\r\n.fops = &ptlrpc_lprocfs_nrs_fops,\r\n.data = svc},\r\n{NULL}\r\n};\r\nstatic const struct file_operations req_history_fops = {\r\n.owner = THIS_MODULE,\r\n.open = ptlrpc_lprocfs_svc_req_history_open,\r\n.read = seq_read,\r\n.llseek = seq_lseek,\r\n.release = lprocfs_seq_release,\r\n};\r\nint rc;\r\nptlrpc_ldebugfs_register(entry, svc->srv_name,\r\n"stats", &svc->srv_debugfs_entry,\r\n&svc->srv_stats);\r\nif (IS_ERR_OR_NULL(svc->srv_debugfs_entry))\r\nreturn;\r\nldebugfs_add_vars(svc->srv_debugfs_entry, lproc_vars, NULL);\r\nrc = ldebugfs_seq_create(svc->srv_debugfs_entry, "req_history",\r\n0400, &req_history_fops, svc);\r\nif (rc)\r\nCWARN("Error adding the req_history file\n");\r\n}\r\nvoid ptlrpc_lprocfs_register_obd(struct obd_device *obddev)\r\n{\r\nptlrpc_ldebugfs_register(obddev->obd_debugfs_entry, NULL, "stats",\r\n&obddev->obd_svc_debugfs_entry,\r\n&obddev->obd_svc_stats);\r\n}\r\nvoid ptlrpc_lprocfs_rpc_sent(struct ptlrpc_request *req, long amount)\r\n{\r\nstruct lprocfs_stats *svc_stats;\r\n__u32 op = lustre_msg_get_opc(req->rq_reqmsg);\r\nint opc = opcode_offset(op);\r\nsvc_stats = req->rq_import->imp_obd->obd_svc_stats;\r\nif (!svc_stats || opc <= 0)\r\nreturn;\r\nLASSERT(opc < LUSTRE_MAX_OPCODES);\r\nif (!(op == LDLM_ENQUEUE || op == MDS_REINT))\r\nlprocfs_counter_add(svc_stats, opc + EXTRA_MAX_OPCODES, amount);\r\n}\r\nvoid ptlrpc_lprocfs_brw(struct ptlrpc_request *req, int bytes)\r\n{\r\nstruct lprocfs_stats *svc_stats;\r\nint idx;\r\nif (!req->rq_import)\r\nreturn;\r\nsvc_stats = req->rq_import->imp_obd->obd_svc_stats;\r\nif (!svc_stats)\r\nreturn;\r\nidx = lustre_msg_get_opc(req->rq_reqmsg);\r\nswitch (idx) {\r\ncase OST_READ:\r\nidx = BRW_READ_BYTES + PTLRPC_LAST_CNTR;\r\nbreak;\r\ncase OST_WRITE:\r\nidx = BRW_WRITE_BYTES + PTLRPC_LAST_CNTR;\r\nbreak;\r\ndefault:\r\nLASSERTF(0, "unsupported opcode %u\n", idx);\r\nbreak;\r\n}\r\nlprocfs_counter_add(svc_stats, idx, bytes);\r\n}\r\nvoid ptlrpc_lprocfs_unregister_service(struct ptlrpc_service *svc)\r\n{\r\nif (!IS_ERR_OR_NULL(svc->srv_debugfs_entry))\r\nldebugfs_remove(&svc->srv_debugfs_entry);\r\nif (svc->srv_stats)\r\nlprocfs_free_stats(&svc->srv_stats);\r\n}\r\nvoid ptlrpc_lprocfs_unregister_obd(struct obd_device *obd)\r\n{\r\nif (!IS_ERR_OR_NULL(obd->obd_svc_debugfs_entry))\r\nldebugfs_remove(&obd->obd_svc_debugfs_entry);\r\nif (obd->obd_svc_stats)\r\nlprocfs_free_stats(&obd->obd_svc_stats);\r\n}\r\nint lprocfs_wr_ping(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct obd_device *obd = ((struct seq_file *)file->private_data)->private;\r\nstruct ptlrpc_request *req;\r\nint rc;\r\nrc = lprocfs_climp_check(obd);\r\nif (rc)\r\nreturn rc;\r\nreq = ptlrpc_prep_ping(obd->u.cli.cl_import);\r\nup_read(&obd->u.cli.cl_sem);\r\nif (!req)\r\nreturn -ENOMEM;\r\nreq->rq_send_state = LUSTRE_IMP_FULL;\r\nrc = ptlrpc_queue_wait(req);\r\nptlrpc_req_finished(req);\r\nif (rc >= 0)\r\nreturn count;\r\nreturn rc;\r\n}\r\nint lprocfs_wr_import(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct obd_device *obd = ((struct seq_file *)file->private_data)->private;\r\nstruct obd_import *imp = obd->u.cli.cl_import;\r\nchar *kbuf = NULL;\r\nchar *uuid;\r\nchar *ptr;\r\nint do_reconn = 1;\r\nconst char prefix[] = "connection=";\r\nconst int prefix_len = sizeof(prefix) - 1;\r\nif (count > PAGE_SIZE - 1 || count <= prefix_len)\r\nreturn -EINVAL;\r\nkbuf = kzalloc(count + 1, GFP_NOFS);\r\nif (!kbuf)\r\nreturn -ENOMEM;\r\nif (copy_from_user(kbuf, buffer, count)) {\r\ncount = -EFAULT;\r\ngoto out;\r\n}\r\nkbuf[count] = 0;\r\nif (strncmp(prefix, kbuf, prefix_len) != 0) {\r\ncount = -EINVAL;\r\ngoto out;\r\n}\r\nuuid = kbuf + prefix_len;\r\nptr = strstr(uuid, "::");\r\nif (ptr) {\r\n__u32 inst;\r\nchar *endptr;\r\n*ptr = 0;\r\ndo_reconn = 0;\r\nptr += strlen("::");\r\ninst = simple_strtoul(ptr, &endptr, 10);\r\nif (*endptr) {\r\nCERROR("config: wrong instance # %s\n", ptr);\r\n} else if (inst != imp->imp_connect_data.ocd_instance) {\r\nCDEBUG(D_INFO, "IR: %s is connecting to an obsoleted target(%u/%u), reconnecting...\n",\r\nimp->imp_obd->obd_name,\r\nimp->imp_connect_data.ocd_instance, inst);\r\ndo_reconn = 1;\r\n} else {\r\nCDEBUG(D_INFO, "IR: %s has already been connecting to new target(%u)\n",\r\nimp->imp_obd->obd_name, inst);\r\n}\r\n}\r\nif (do_reconn)\r\nptlrpc_recover_import(imp, uuid, 1);\r\nout:\r\nkfree(kbuf);\r\nreturn count;\r\n}\r\nint lprocfs_rd_pinger_recov(struct seq_file *m, void *n)\r\n{\r\nstruct obd_device *obd = m->private;\r\nstruct obd_import *imp = obd->u.cli.cl_import;\r\nint rc;\r\nrc = lprocfs_climp_check(obd);\r\nif (rc)\r\nreturn rc;\r\nseq_printf(m, "%d\n", !imp->imp_no_pinger_recover);\r\nup_read(&obd->u.cli.cl_sem);\r\nreturn 0;\r\n}\r\nint lprocfs_wr_pinger_recov(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct obd_device *obd = ((struct seq_file *)file->private_data)->private;\r\nstruct client_obd *cli = &obd->u.cli;\r\nstruct obd_import *imp = cli->cl_import;\r\nint rc, val;\r\nrc = lprocfs_write_helper(buffer, count, &val);\r\nif (rc < 0)\r\nreturn rc;\r\nif (val != 0 && val != 1)\r\nreturn -ERANGE;\r\nrc = lprocfs_climp_check(obd);\r\nif (rc)\r\nreturn rc;\r\nspin_lock(&imp->imp_lock);\r\nimp->imp_no_pinger_recover = !val;\r\nspin_unlock(&imp->imp_lock);\r\nup_read(&obd->u.cli.cl_sem);\r\nreturn count;\r\n}
