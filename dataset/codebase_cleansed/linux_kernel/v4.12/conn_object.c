struct rxrpc_connection *rxrpc_alloc_connection(gfp_t gfp)\r\n{\r\nstruct rxrpc_connection *conn;\r\n_enter("");\r\nconn = kzalloc(sizeof(struct rxrpc_connection), gfp);\r\nif (conn) {\r\nINIT_LIST_HEAD(&conn->cache_link);\r\nspin_lock_init(&conn->channel_lock);\r\nINIT_LIST_HEAD(&conn->waiting_calls);\r\nINIT_WORK(&conn->processor, &rxrpc_process_connection);\r\nINIT_LIST_HEAD(&conn->proc_link);\r\nINIT_LIST_HEAD(&conn->link);\r\nskb_queue_head_init(&conn->rx_queue);\r\nconn->security = &rxrpc_no_security;\r\nspin_lock_init(&conn->state_lock);\r\nconn->debug_id = atomic_inc_return(&rxrpc_debug_id);\r\nconn->size_align = 4;\r\nconn->idle_timestamp = jiffies;\r\n}\r\n_leave(" = %p{%d}", conn, conn ? conn->debug_id : 0);\r\nreturn conn;\r\n}\r\nstruct rxrpc_connection *rxrpc_find_connection_rcu(struct rxrpc_local *local,\r\nstruct sk_buff *skb)\r\n{\r\nstruct rxrpc_connection *conn;\r\nstruct rxrpc_conn_proto k;\r\nstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\r\nstruct sockaddr_rxrpc srx;\r\nstruct rxrpc_peer *peer;\r\n_enter(",%x", sp->hdr.cid & RXRPC_CIDMASK);\r\nif (rxrpc_extract_addr_from_skb(&srx, skb) < 0)\r\ngoto not_found;\r\nk.epoch = sp->hdr.epoch;\r\nk.cid = sp->hdr.cid & RXRPC_CIDMASK;\r\nif (srx.transport.family != local->srx.transport.family) {\r\npr_warn_ratelimited("AF_RXRPC: Protocol mismatch %u not %u\n",\r\nsrx.transport.family,\r\nlocal->srx.transport.family);\r\ngoto not_found;\r\n}\r\nk.epoch = sp->hdr.epoch;\r\nk.cid = sp->hdr.cid & RXRPC_CIDMASK;\r\nif (sp->hdr.flags & RXRPC_CLIENT_INITIATED) {\r\npeer = rxrpc_lookup_peer_rcu(local, &srx);\r\nif (!peer)\r\ngoto not_found;\r\nconn = rxrpc_find_service_conn_rcu(peer, skb);\r\nif (!conn || atomic_read(&conn->usage) == 0)\r\ngoto not_found;\r\n_leave(" = %p", conn);\r\nreturn conn;\r\n} else {\r\nconn = idr_find(&rxrpc_client_conn_ids,\r\nsp->hdr.cid >> RXRPC_CIDSHIFT);\r\nif (!conn || atomic_read(&conn->usage) == 0) {\r\n_debug("no conn");\r\ngoto not_found;\r\n}\r\nif (conn->proto.epoch != k.epoch ||\r\nconn->params.local != local)\r\ngoto not_found;\r\npeer = conn->params.peer;\r\nswitch (srx.transport.family) {\r\ncase AF_INET:\r\nif (peer->srx.transport.sin.sin_port !=\r\nsrx.transport.sin.sin_port ||\r\npeer->srx.transport.sin.sin_addr.s_addr !=\r\nsrx.transport.sin.sin_addr.s_addr)\r\ngoto not_found;\r\nbreak;\r\n#ifdef CONFIG_AF_RXRPC_IPV6\r\ncase AF_INET6:\r\nif (peer->srx.transport.sin6.sin6_port !=\r\nsrx.transport.sin6.sin6_port ||\r\nmemcmp(&peer->srx.transport.sin6.sin6_addr,\r\n&srx.transport.sin6.sin6_addr,\r\nsizeof(struct in6_addr)) != 0)\r\ngoto not_found;\r\nbreak;\r\n#endif\r\ndefault:\r\nBUG();\r\n}\r\n_leave(" = %p", conn);\r\nreturn conn;\r\n}\r\nnot_found:\r\n_leave(" = NULL");\r\nreturn NULL;\r\n}\r\nvoid __rxrpc_disconnect_call(struct rxrpc_connection *conn,\r\nstruct rxrpc_call *call)\r\n{\r\nstruct rxrpc_channel *chan =\r\n&conn->channels[call->cid & RXRPC_CHANNELMASK];\r\n_enter("%d,%x", conn->debug_id, call->cid);\r\nif (rcu_access_pointer(chan->call) == call) {\r\ntrace_rxrpc_disconnect_call(call);\r\nchan->last_service_id = call->service_id;\r\nif (call->abort_code) {\r\nchan->last_abort = call->abort_code;\r\nchan->last_type = RXRPC_PACKET_TYPE_ABORT;\r\n} else {\r\nchan->last_seq = call->rx_hard_ack;\r\nchan->last_type = RXRPC_PACKET_TYPE_ACK;\r\n}\r\nsmp_wmb();\r\nchan->last_call = chan->call_id;\r\nchan->call_id = chan->call_counter;\r\nrcu_assign_pointer(chan->call, NULL);\r\n}\r\n_leave("");\r\n}\r\nvoid rxrpc_disconnect_call(struct rxrpc_call *call)\r\n{\r\nstruct rxrpc_connection *conn = call->conn;\r\nspin_lock_bh(&conn->params.peer->lock);\r\nhlist_del_init(&call->error_link);\r\nspin_unlock_bh(&conn->params.peer->lock);\r\nif (rxrpc_is_client_call(call))\r\nreturn rxrpc_disconnect_client_call(call);\r\nspin_lock(&conn->channel_lock);\r\n__rxrpc_disconnect_call(conn, call);\r\nspin_unlock(&conn->channel_lock);\r\ncall->conn = NULL;\r\nconn->idle_timestamp = jiffies;\r\nrxrpc_put_connection(conn);\r\n}\r\nvoid rxrpc_kill_connection(struct rxrpc_connection *conn)\r\n{\r\nASSERT(!rcu_access_pointer(conn->channels[0].call) &&\r\n!rcu_access_pointer(conn->channels[1].call) &&\r\n!rcu_access_pointer(conn->channels[2].call) &&\r\n!rcu_access_pointer(conn->channels[3].call));\r\nASSERT(list_empty(&conn->cache_link));\r\nwrite_lock(&rxrpc_connection_lock);\r\nlist_del_init(&conn->proc_link);\r\nwrite_unlock(&rxrpc_connection_lock);\r\nrxrpc_purge_queue(&conn->rx_queue);\r\ncall_rcu(&conn->rcu, rxrpc_destroy_connection);\r\n}\r\nbool rxrpc_queue_conn(struct rxrpc_connection *conn)\r\n{\r\nconst void *here = __builtin_return_address(0);\r\nint n = __atomic_add_unless(&conn->usage, 1, 0);\r\nif (n == 0)\r\nreturn false;\r\nif (rxrpc_queue_work(&conn->processor))\r\ntrace_rxrpc_conn(conn, rxrpc_conn_queued, n + 1, here);\r\nelse\r\nrxrpc_put_connection(conn);\r\nreturn true;\r\n}\r\nvoid rxrpc_see_connection(struct rxrpc_connection *conn)\r\n{\r\nconst void *here = __builtin_return_address(0);\r\nif (conn) {\r\nint n = atomic_read(&conn->usage);\r\ntrace_rxrpc_conn(conn, rxrpc_conn_seen, n, here);\r\n}\r\n}\r\nvoid rxrpc_get_connection(struct rxrpc_connection *conn)\r\n{\r\nconst void *here = __builtin_return_address(0);\r\nint n = atomic_inc_return(&conn->usage);\r\ntrace_rxrpc_conn(conn, rxrpc_conn_got, n, here);\r\n}\r\nstruct rxrpc_connection *\r\nrxrpc_get_connection_maybe(struct rxrpc_connection *conn)\r\n{\r\nconst void *here = __builtin_return_address(0);\r\nif (conn) {\r\nint n = __atomic_add_unless(&conn->usage, 1, 0);\r\nif (n > 0)\r\ntrace_rxrpc_conn(conn, rxrpc_conn_got, n + 1, here);\r\nelse\r\nconn = NULL;\r\n}\r\nreturn conn;\r\n}\r\nvoid rxrpc_put_service_conn(struct rxrpc_connection *conn)\r\n{\r\nconst void *here = __builtin_return_address(0);\r\nint n;\r\nn = atomic_dec_return(&conn->usage);\r\ntrace_rxrpc_conn(conn, rxrpc_conn_put_service, n, here);\r\nASSERTCMP(n, >=, 0);\r\nif (n == 0)\r\nrxrpc_queue_delayed_work(&rxrpc_connection_reap, 0);\r\n}\r\nstatic void rxrpc_destroy_connection(struct rcu_head *rcu)\r\n{\r\nstruct rxrpc_connection *conn =\r\ncontainer_of(rcu, struct rxrpc_connection, rcu);\r\n_enter("{%d,u=%d}", conn->debug_id, atomic_read(&conn->usage));\r\nASSERTCMP(atomic_read(&conn->usage), ==, 0);\r\n_net("DESTROY CONN %d", conn->debug_id);\r\nrxrpc_purge_queue(&conn->rx_queue);\r\nconn->security->clear(conn);\r\nkey_put(conn->params.key);\r\nkey_put(conn->server_key);\r\nrxrpc_put_peer(conn->params.peer);\r\nrxrpc_put_local(conn->params.local);\r\nkfree(conn);\r\n_leave("");\r\n}\r\nstatic void rxrpc_connection_reaper(struct work_struct *work)\r\n{\r\nstruct rxrpc_connection *conn, *_p;\r\nunsigned long reap_older_than, earliest, idle_timestamp, now;\r\nLIST_HEAD(graveyard);\r\n_enter("");\r\nnow = jiffies;\r\nreap_older_than = now - rxrpc_connection_expiry * HZ;\r\nearliest = ULONG_MAX;\r\nwrite_lock(&rxrpc_connection_lock);\r\nlist_for_each_entry_safe(conn, _p, &rxrpc_connections, link) {\r\nASSERTCMP(atomic_read(&conn->usage), >, 0);\r\nif (likely(atomic_read(&conn->usage) > 1))\r\ncontinue;\r\nif (conn->state == RXRPC_CONN_SERVICE_PREALLOC)\r\ncontinue;\r\nidle_timestamp = READ_ONCE(conn->idle_timestamp);\r\n_debug("reap CONN %d { u=%d,t=%ld }",\r\nconn->debug_id, atomic_read(&conn->usage),\r\n(long)reap_older_than - (long)idle_timestamp);\r\nif (time_after(idle_timestamp, reap_older_than)) {\r\nif (time_before(idle_timestamp, earliest))\r\nearliest = idle_timestamp;\r\ncontinue;\r\n}\r\nif (atomic_cmpxchg(&conn->usage, 1, 0) != 1)\r\ncontinue;\r\nif (rxrpc_conn_is_client(conn))\r\nBUG();\r\nelse\r\nrxrpc_unpublish_service_conn(conn);\r\nlist_move_tail(&conn->link, &graveyard);\r\n}\r\nwrite_unlock(&rxrpc_connection_lock);\r\nif (earliest != ULONG_MAX) {\r\n_debug("reschedule reaper %ld", (long) earliest - now);\r\nASSERT(time_after(earliest, now));\r\nrxrpc_queue_delayed_work(&rxrpc_connection_reap,\r\nearliest - now);\r\n}\r\nwhile (!list_empty(&graveyard)) {\r\nconn = list_entry(graveyard.next, struct rxrpc_connection,\r\nlink);\r\nlist_del_init(&conn->link);\r\nASSERTCMP(atomic_read(&conn->usage), ==, 0);\r\nrxrpc_kill_connection(conn);\r\n}\r\n_leave("");\r\n}\r\nvoid __exit rxrpc_destroy_all_connections(void)\r\n{\r\nstruct rxrpc_connection *conn, *_p;\r\nbool leak = false;\r\n_enter("");\r\nrxrpc_destroy_all_client_connections();\r\nrxrpc_connection_expiry = 0;\r\ncancel_delayed_work(&rxrpc_connection_reap);\r\nrxrpc_queue_delayed_work(&rxrpc_connection_reap, 0);\r\nflush_workqueue(rxrpc_workqueue);\r\nwrite_lock(&rxrpc_connection_lock);\r\nlist_for_each_entry_safe(conn, _p, &rxrpc_connections, link) {\r\npr_err("AF_RXRPC: Leaked conn %p {%d}\n",\r\nconn, atomic_read(&conn->usage));\r\nleak = true;\r\n}\r\nwrite_unlock(&rxrpc_connection_lock);\r\nBUG_ON(leak);\r\nASSERT(list_empty(&rxrpc_connection_proc_list));\r\nrcu_barrier();\r\nrxrpc_destroy_client_conn_ids();\r\n_leave("");\r\n}
