static inline struct device *vop_dev(struct vop_vdev *vdev)\r\n{\r\nreturn vdev->vpdev->dev.parent;\r\n}\r\nstatic inline int vop_vdev_inited(struct vop_vdev *vdev)\r\n{\r\nif (!vdev)\r\nreturn -EINVAL;\r\nif (!vdev->dd || !vdev->dd->type) {\r\ndev_err(vop_dev(vdev), "%s %d err %d\n",\r\n__func__, __LINE__, -EINVAL);\r\nreturn -EINVAL;\r\n}\r\nif (vdev->dd->type == -1) {\r\ndev_dbg(vop_dev(vdev), "%s %d err %d\n",\r\n__func__, __LINE__, -ENODEV);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void _vop_notify(struct vringh *vrh)\r\n{\r\nstruct vop_vringh *vvrh = container_of(vrh, struct vop_vringh, vrh);\r\nstruct vop_vdev *vdev = vvrh->vdev;\r\nstruct vop_device *vpdev = vdev->vpdev;\r\ns8 db = vdev->dc->h2c_vdev_db;\r\nif (db != -1)\r\nvpdev->hw_ops->send_intr(vpdev, db);\r\n}\r\nstatic void vop_virtio_init_post(struct vop_vdev *vdev)\r\n{\r\nstruct mic_vqconfig *vqconfig = mic_vq_config(vdev->dd);\r\nstruct vop_device *vpdev = vdev->vpdev;\r\nint i, used_size;\r\nfor (i = 0; i < vdev->dd->num_vq; i++) {\r\nused_size = PAGE_ALIGN(sizeof(u16) * 3 +\r\nsizeof(struct vring_used_elem) *\r\nle16_to_cpu(vqconfig->num));\r\nif (!le64_to_cpu(vqconfig[i].used_address)) {\r\ndev_warn(vop_dev(vdev), "used_address zero??\n");\r\ncontinue;\r\n}\r\nvdev->vvr[i].vrh.vring.used =\r\n(void __force *)vpdev->hw_ops->ioremap(\r\nvpdev,\r\nle64_to_cpu(vqconfig[i].used_address),\r\nused_size);\r\n}\r\nvdev->dc->used_address_updated = 0;\r\ndev_info(vop_dev(vdev), "%s: device type %d LINKUP\n",\r\n__func__, vdev->virtio_id);\r\n}\r\nstatic inline void vop_virtio_device_reset(struct vop_vdev *vdev)\r\n{\r\nint i;\r\ndev_dbg(vop_dev(vdev), "%s: status %d device type %d RESET\n",\r\n__func__, vdev->dd->status, vdev->virtio_id);\r\nfor (i = 0; i < vdev->dd->num_vq; i++)\r\nmutex_lock_nested(&vdev->vvr[i].vr_mutex, i + 1);\r\nvdev->dd->status = 0;\r\nvdev->dc->vdev_reset = 0;\r\nvdev->dc->host_ack = 1;\r\nfor (i = 0; i < vdev->dd->num_vq; i++) {\r\nstruct vringh *vrh = &vdev->vvr[i].vrh;\r\nvdev->vvr[i].vring.info->avail_idx = 0;\r\nvrh->completed = 0;\r\nvrh->last_avail_idx = 0;\r\nvrh->last_used_idx = 0;\r\n}\r\nfor (i = 0; i < vdev->dd->num_vq; i++)\r\nmutex_unlock(&vdev->vvr[i].vr_mutex);\r\n}\r\nstatic void vop_virtio_reset_devices(struct vop_info *vi)\r\n{\r\nstruct list_head *pos, *tmp;\r\nstruct vop_vdev *vdev;\r\nlist_for_each_safe(pos, tmp, &vi->vdev_list) {\r\nvdev = list_entry(pos, struct vop_vdev, list);\r\nvop_virtio_device_reset(vdev);\r\nvdev->poll_wake = 1;\r\nwake_up(&vdev->waitq);\r\n}\r\n}\r\nstatic void vop_bh_handler(struct work_struct *work)\r\n{\r\nstruct vop_vdev *vdev = container_of(work, struct vop_vdev,\r\nvirtio_bh_work);\r\nif (vdev->dc->used_address_updated)\r\nvop_virtio_init_post(vdev);\r\nif (vdev->dc->vdev_reset)\r\nvop_virtio_device_reset(vdev);\r\nvdev->poll_wake = 1;\r\nwake_up(&vdev->waitq);\r\n}\r\nstatic irqreturn_t _vop_virtio_intr_handler(int irq, void *data)\r\n{\r\nstruct vop_vdev *vdev = data;\r\nstruct vop_device *vpdev = vdev->vpdev;\r\nvpdev->hw_ops->ack_interrupt(vpdev, vdev->virtio_db);\r\nschedule_work(&vdev->virtio_bh_work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int vop_virtio_config_change(struct vop_vdev *vdev, void *argp)\r\n{\r\nDECLARE_WAIT_QUEUE_HEAD_ONSTACK(wake);\r\nint ret = 0, retry, i;\r\nstruct vop_device *vpdev = vdev->vpdev;\r\nstruct vop_info *vi = dev_get_drvdata(&vpdev->dev);\r\nstruct mic_bootparam *bootparam = vpdev->hw_ops->get_dp(vpdev);\r\ns8 db = bootparam->h2c_config_db;\r\nmutex_lock(&vi->vop_mutex);\r\nfor (i = 0; i < vdev->dd->num_vq; i++)\r\nmutex_lock_nested(&vdev->vvr[i].vr_mutex, i + 1);\r\nif (db == -1 || vdev->dd->type == -1) {\r\nret = -EIO;\r\ngoto exit;\r\n}\r\nmemcpy(mic_vq_configspace(vdev->dd), argp, vdev->dd->config_len);\r\nvdev->dc->config_change = MIC_VIRTIO_PARAM_CONFIG_CHANGED;\r\nvpdev->hw_ops->send_intr(vpdev, db);\r\nfor (retry = 100; retry--;) {\r\nret = wait_event_timeout(wake, vdev->dc->guest_ack,\r\nmsecs_to_jiffies(100));\r\nif (ret)\r\nbreak;\r\n}\r\ndev_dbg(vop_dev(vdev),\r\n"%s %d retry: %d\n", __func__, __LINE__, retry);\r\nvdev->dc->config_change = 0;\r\nvdev->dc->guest_ack = 0;\r\nexit:\r\nfor (i = 0; i < vdev->dd->num_vq; i++)\r\nmutex_unlock(&vdev->vvr[i].vr_mutex);\r\nmutex_unlock(&vi->vop_mutex);\r\nreturn ret;\r\n}\r\nstatic int vop_copy_dp_entry(struct vop_vdev *vdev,\r\nstruct mic_device_desc *argp, __u8 *type,\r\nstruct mic_device_desc **devpage)\r\n{\r\nstruct vop_device *vpdev = vdev->vpdev;\r\nstruct mic_device_desc *devp;\r\nstruct mic_vqconfig *vqconfig;\r\nint ret = 0, i;\r\nbool slot_found = false;\r\nvqconfig = mic_vq_config(argp);\r\nfor (i = 0; i < argp->num_vq; i++) {\r\nif (le16_to_cpu(vqconfig[i].num) > MIC_MAX_VRING_ENTRIES) {\r\nret = -EINVAL;\r\ndev_err(vop_dev(vdev), "%s %d err %d\n",\r\n__func__, __LINE__, ret);\r\ngoto exit;\r\n}\r\n}\r\nfor (i = sizeof(struct mic_bootparam);\r\ni < MIC_DP_SIZE - mic_total_desc_size(argp);\r\ni += mic_total_desc_size(devp)) {\r\ndevp = vpdev->hw_ops->get_dp(vpdev) + i;\r\nif (devp->type == 0 || devp->type == -1) {\r\nslot_found = true;\r\nbreak;\r\n}\r\n}\r\nif (!slot_found) {\r\nret = -EINVAL;\r\ndev_err(vop_dev(vdev), "%s %d err %d\n",\r\n__func__, __LINE__, ret);\r\ngoto exit;\r\n}\r\n*type = argp->type;\r\nargp->type = 0;\r\nmemcpy(devp, argp, mic_desc_size(argp));\r\n*devpage = devp;\r\nexit:\r\nreturn ret;\r\n}\r\nstatic void vop_init_device_ctrl(struct vop_vdev *vdev,\r\nstruct mic_device_desc *devpage)\r\n{\r\nstruct mic_device_ctrl *dc;\r\ndc = (void *)devpage + mic_aligned_desc_size(devpage);\r\ndc->config_change = 0;\r\ndc->guest_ack = 0;\r\ndc->vdev_reset = 0;\r\ndc->host_ack = 0;\r\ndc->used_address_updated = 0;\r\ndc->c2h_vdev_db = -1;\r\ndc->h2c_vdev_db = -1;\r\nvdev->dc = dc;\r\n}\r\nstatic int vop_virtio_add_device(struct vop_vdev *vdev,\r\nstruct mic_device_desc *argp)\r\n{\r\nstruct vop_info *vi = vdev->vi;\r\nstruct vop_device *vpdev = vi->vpdev;\r\nstruct mic_device_desc *dd = NULL;\r\nstruct mic_vqconfig *vqconfig;\r\nint vr_size, i, j, ret;\r\nu8 type = 0;\r\ns8 db = -1;\r\nchar irqname[16];\r\nstruct mic_bootparam *bootparam;\r\nu16 num;\r\ndma_addr_t vr_addr;\r\nbootparam = vpdev->hw_ops->get_dp(vpdev);\r\ninit_waitqueue_head(&vdev->waitq);\r\nINIT_LIST_HEAD(&vdev->list);\r\nvdev->vpdev = vpdev;\r\nret = vop_copy_dp_entry(vdev, argp, &type, &dd);\r\nif (ret) {\r\ndev_err(vop_dev(vdev), "%s %d err %d\n",\r\n__func__, __LINE__, ret);\r\nreturn ret;\r\n}\r\nvop_init_device_ctrl(vdev, dd);\r\nvdev->dd = dd;\r\nvdev->virtio_id = type;\r\nvqconfig = mic_vq_config(dd);\r\nINIT_WORK(&vdev->virtio_bh_work, vop_bh_handler);\r\nfor (i = 0; i < dd->num_vq; i++) {\r\nstruct vop_vringh *vvr = &vdev->vvr[i];\r\nstruct mic_vring *vr = &vdev->vvr[i].vring;\r\nnum = le16_to_cpu(vqconfig[i].num);\r\nmutex_init(&vvr->vr_mutex);\r\nvr_size = PAGE_ALIGN(vring_size(num, MIC_VIRTIO_RING_ALIGN) +\r\nsizeof(struct _mic_vring_info));\r\nvr->va = (void *)\r\n__get_free_pages(GFP_KERNEL | __GFP_ZERO,\r\nget_order(vr_size));\r\nif (!vr->va) {\r\nret = -ENOMEM;\r\ndev_err(vop_dev(vdev), "%s %d err %d\n",\r\n__func__, __LINE__, ret);\r\ngoto err;\r\n}\r\nvr->len = vr_size;\r\nvr->info = vr->va + vring_size(num, MIC_VIRTIO_RING_ALIGN);\r\nvr->info->magic = cpu_to_le32(MIC_MAGIC + vdev->virtio_id + i);\r\nvr_addr = dma_map_single(&vpdev->dev, vr->va, vr_size,\r\nDMA_BIDIRECTIONAL);\r\nif (dma_mapping_error(&vpdev->dev, vr_addr)) {\r\nfree_pages((unsigned long)vr->va, get_order(vr_size));\r\nret = -ENOMEM;\r\ndev_err(vop_dev(vdev), "%s %d err %d\n",\r\n__func__, __LINE__, ret);\r\ngoto err;\r\n}\r\nvqconfig[i].address = cpu_to_le64(vr_addr);\r\nvring_init(&vr->vr, num, vr->va, MIC_VIRTIO_RING_ALIGN);\r\nret = vringh_init_kern(&vvr->vrh,\r\n*(u32 *)mic_vq_features(vdev->dd),\r\nnum, false, vr->vr.desc, vr->vr.avail,\r\nvr->vr.used);\r\nif (ret) {\r\ndev_err(vop_dev(vdev), "%s %d err %d\n",\r\n__func__, __LINE__, ret);\r\ngoto err;\r\n}\r\nvringh_kiov_init(&vvr->riov, NULL, 0);\r\nvringh_kiov_init(&vvr->wiov, NULL, 0);\r\nvvr->head = USHRT_MAX;\r\nvvr->vdev = vdev;\r\nvvr->vrh.notify = _vop_notify;\r\ndev_dbg(&vpdev->dev,\r\n"%s %d index %d va %p info %p vr_size 0x%x\n",\r\n__func__, __LINE__, i, vr->va, vr->info, vr_size);\r\nvvr->buf = (void *)__get_free_pages(GFP_KERNEL,\r\nget_order(VOP_INT_DMA_BUF_SIZE));\r\nvvr->buf_da = dma_map_single(&vpdev->dev,\r\nvvr->buf, VOP_INT_DMA_BUF_SIZE,\r\nDMA_BIDIRECTIONAL);\r\n}\r\nsnprintf(irqname, sizeof(irqname), "vop%dvirtio%d", vpdev->index,\r\nvdev->virtio_id);\r\nvdev->virtio_db = vpdev->hw_ops->next_db(vpdev);\r\nvdev->virtio_cookie = vpdev->hw_ops->request_irq(vpdev,\r\n_vop_virtio_intr_handler, irqname, vdev,\r\nvdev->virtio_db);\r\nif (IS_ERR(vdev->virtio_cookie)) {\r\nret = PTR_ERR(vdev->virtio_cookie);\r\ndev_dbg(&vpdev->dev, "request irq failed\n");\r\ngoto err;\r\n}\r\nvdev->dc->c2h_vdev_db = vdev->virtio_db;\r\nsmp_wmb();\r\ndd->type = type;\r\nargp->type = type;\r\nif (bootparam) {\r\ndb = bootparam->h2c_config_db;\r\nif (db != -1)\r\nvpdev->hw_ops->send_intr(vpdev, db);\r\n}\r\ndev_dbg(&vpdev->dev, "Added virtio id %d db %d\n", dd->type, db);\r\nreturn 0;\r\nerr:\r\nvqconfig = mic_vq_config(dd);\r\nfor (j = 0; j < i; j++) {\r\nstruct vop_vringh *vvr = &vdev->vvr[j];\r\ndma_unmap_single(&vpdev->dev, le64_to_cpu(vqconfig[j].address),\r\nvvr->vring.len, DMA_BIDIRECTIONAL);\r\nfree_pages((unsigned long)vvr->vring.va,\r\nget_order(vvr->vring.len));\r\n}\r\nreturn ret;\r\n}\r\nstatic void vop_dev_remove(struct vop_info *pvi, struct mic_device_ctrl *devp,\r\nstruct vop_device *vpdev)\r\n{\r\nstruct mic_bootparam *bootparam = vpdev->hw_ops->get_dp(vpdev);\r\ns8 db;\r\nint ret, retry;\r\nDECLARE_WAIT_QUEUE_HEAD_ONSTACK(wake);\r\ndevp->config_change = MIC_VIRTIO_PARAM_DEV_REMOVE;\r\ndb = bootparam->h2c_config_db;\r\nif (db != -1)\r\nvpdev->hw_ops->send_intr(vpdev, db);\r\nelse\r\ngoto done;\r\nfor (retry = 15; retry--;) {\r\nret = wait_event_timeout(wake, devp->guest_ack,\r\nmsecs_to_jiffies(1000));\r\nif (ret)\r\nbreak;\r\n}\r\ndone:\r\ndevp->config_change = 0;\r\ndevp->guest_ack = 0;\r\n}\r\nstatic void vop_virtio_del_device(struct vop_vdev *vdev)\r\n{\r\nstruct vop_info *vi = vdev->vi;\r\nstruct vop_device *vpdev = vdev->vpdev;\r\nint i;\r\nstruct mic_vqconfig *vqconfig;\r\nstruct mic_bootparam *bootparam = vpdev->hw_ops->get_dp(vpdev);\r\nif (!bootparam)\r\ngoto skip_hot_remove;\r\nvop_dev_remove(vi, vdev->dc, vpdev);\r\nskip_hot_remove:\r\nvpdev->hw_ops->free_irq(vpdev, vdev->virtio_cookie, vdev);\r\nflush_work(&vdev->virtio_bh_work);\r\nvqconfig = mic_vq_config(vdev->dd);\r\nfor (i = 0; i < vdev->dd->num_vq; i++) {\r\nstruct vop_vringh *vvr = &vdev->vvr[i];\r\ndma_unmap_single(&vpdev->dev,\r\nvvr->buf_da, VOP_INT_DMA_BUF_SIZE,\r\nDMA_BIDIRECTIONAL);\r\nfree_pages((unsigned long)vvr->buf,\r\nget_order(VOP_INT_DMA_BUF_SIZE));\r\nvringh_kiov_cleanup(&vvr->riov);\r\nvringh_kiov_cleanup(&vvr->wiov);\r\ndma_unmap_single(&vpdev->dev, le64_to_cpu(vqconfig[i].address),\r\nvvr->vring.len, DMA_BIDIRECTIONAL);\r\nfree_pages((unsigned long)vvr->vring.va,\r\nget_order(vvr->vring.len));\r\n}\r\nsmp_wmb();\r\nvdev->dd->type = -1;\r\n}\r\nstatic int vop_sync_dma(struct vop_vdev *vdev, dma_addr_t dst, dma_addr_t src,\r\nsize_t len)\r\n{\r\nint err = 0;\r\nstruct dma_device *ddev;\r\nstruct dma_async_tx_descriptor *tx;\r\nstruct vop_info *vi = dev_get_drvdata(&vdev->vpdev->dev);\r\nstruct dma_chan *vop_ch = vi->dma_ch;\r\nif (!vop_ch) {\r\nerr = -EBUSY;\r\ngoto error;\r\n}\r\nddev = vop_ch->device;\r\ntx = ddev->device_prep_dma_memcpy(vop_ch, dst, src, len,\r\nDMA_PREP_FENCE);\r\nif (!tx) {\r\nerr = -ENOMEM;\r\ngoto error;\r\n} else {\r\ndma_cookie_t cookie;\r\ncookie = tx->tx_submit(tx);\r\nif (dma_submit_error(cookie)) {\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\ndma_async_issue_pending(vop_ch);\r\nerr = dma_sync_wait(vop_ch, cookie);\r\n}\r\nerror:\r\nif (err)\r\ndev_err(&vi->vpdev->dev, "%s %d err %d\n",\r\n__func__, __LINE__, err);\r\nreturn err;\r\n}\r\nstatic int vop_virtio_copy_to_user(struct vop_vdev *vdev, void __user *ubuf,\r\nsize_t len, u64 daddr, size_t dlen,\r\nint vr_idx)\r\n{\r\nstruct vop_device *vpdev = vdev->vpdev;\r\nvoid __iomem *dbuf = vpdev->hw_ops->ioremap(vpdev, daddr, len);\r\nstruct vop_vringh *vvr = &vdev->vvr[vr_idx];\r\nstruct vop_info *vi = dev_get_drvdata(&vpdev->dev);\r\nsize_t dma_alignment = 1 << vi->dma_ch->device->copy_align;\r\nbool x200 = is_dma_copy_aligned(vi->dma_ch->device, 1, 1, 1);\r\nsize_t dma_offset, partlen;\r\nint err;\r\nif (!VOP_USE_DMA) {\r\nif (copy_to_user(ubuf, (void __force *)dbuf, len)) {\r\nerr = -EFAULT;\r\ndev_err(vop_dev(vdev), "%s %d err %d\n",\r\n__func__, __LINE__, err);\r\ngoto err;\r\n}\r\nvdev->in_bytes += len;\r\nerr = 0;\r\ngoto err;\r\n}\r\ndma_offset = daddr - round_down(daddr, dma_alignment);\r\ndaddr -= dma_offset;\r\nlen += dma_offset;\r\nif (x200)\r\ndaddr += vpdev->aper->pa;\r\nwhile (len) {\r\npartlen = min_t(size_t, len, VOP_INT_DMA_BUF_SIZE);\r\nerr = vop_sync_dma(vdev, vvr->buf_da, daddr,\r\nALIGN(partlen, dma_alignment));\r\nif (err) {\r\ndev_err(vop_dev(vdev), "%s %d err %d\n",\r\n__func__, __LINE__, err);\r\ngoto err;\r\n}\r\nif (copy_to_user(ubuf, vvr->buf + dma_offset,\r\npartlen - dma_offset)) {\r\nerr = -EFAULT;\r\ndev_err(vop_dev(vdev), "%s %d err %d\n",\r\n__func__, __LINE__, err);\r\ngoto err;\r\n}\r\ndaddr += partlen;\r\nubuf += partlen;\r\ndbuf += partlen;\r\nvdev->in_bytes_dma += partlen;\r\nvdev->in_bytes += partlen;\r\nlen -= partlen;\r\ndma_offset = 0;\r\n}\r\nerr = 0;\r\nerr:\r\nvpdev->hw_ops->iounmap(vpdev, dbuf);\r\ndev_dbg(vop_dev(vdev),\r\n"%s: ubuf %p dbuf %p len 0x%lx vr_idx 0x%x\n",\r\n__func__, ubuf, dbuf, len, vr_idx);\r\nreturn err;\r\n}\r\nstatic int vop_virtio_copy_from_user(struct vop_vdev *vdev, void __user *ubuf,\r\nsize_t len, u64 daddr, size_t dlen,\r\nint vr_idx)\r\n{\r\nstruct vop_device *vpdev = vdev->vpdev;\r\nvoid __iomem *dbuf = vpdev->hw_ops->ioremap(vpdev, daddr, len);\r\nstruct vop_vringh *vvr = &vdev->vvr[vr_idx];\r\nstruct vop_info *vi = dev_get_drvdata(&vdev->vpdev->dev);\r\nsize_t dma_alignment = 1 << vi->dma_ch->device->copy_align;\r\nbool x200 = is_dma_copy_aligned(vi->dma_ch->device, 1, 1, 1);\r\nsize_t partlen;\r\nbool dma = VOP_USE_DMA;\r\nint err = 0;\r\nif (daddr & (dma_alignment - 1)) {\r\nvdev->tx_dst_unaligned += len;\r\ndma = false;\r\n} else if (ALIGN(len, dma_alignment) > dlen) {\r\nvdev->tx_len_unaligned += len;\r\ndma = false;\r\n}\r\nif (!dma)\r\ngoto memcpy;\r\nif (x200)\r\ndaddr += vpdev->aper->pa;\r\nwhile (len) {\r\npartlen = min_t(size_t, len, VOP_INT_DMA_BUF_SIZE);\r\nif (copy_from_user(vvr->buf, ubuf, partlen)) {\r\nerr = -EFAULT;\r\ndev_err(vop_dev(vdev), "%s %d err %d\n",\r\n__func__, __LINE__, err);\r\ngoto err;\r\n}\r\nerr = vop_sync_dma(vdev, daddr, vvr->buf_da,\r\nALIGN(partlen, dma_alignment));\r\nif (err) {\r\ndev_err(vop_dev(vdev), "%s %d err %d\n",\r\n__func__, __LINE__, err);\r\ngoto err;\r\n}\r\ndaddr += partlen;\r\nubuf += partlen;\r\ndbuf += partlen;\r\nvdev->out_bytes_dma += partlen;\r\nvdev->out_bytes += partlen;\r\nlen -= partlen;\r\n}\r\nmemcpy:\r\nif (copy_from_user((void __force *)dbuf, ubuf, len)) {\r\nerr = -EFAULT;\r\ndev_err(vop_dev(vdev), "%s %d err %d\n",\r\n__func__, __LINE__, err);\r\ngoto err;\r\n}\r\nvdev->out_bytes += len;\r\nerr = 0;\r\nerr:\r\nvpdev->hw_ops->iounmap(vpdev, dbuf);\r\ndev_dbg(vop_dev(vdev),\r\n"%s: ubuf %p dbuf %p len 0x%lx vr_idx 0x%x\n",\r\n__func__, ubuf, dbuf, len, vr_idx);\r\nreturn err;\r\n}\r\nstatic inline u32 vop_vringh_iov_consumed(struct vringh_kiov *iov)\r\n{\r\nint i;\r\nu32 total = iov->consumed;\r\nfor (i = 0; i < iov->i; i++)\r\ntotal += iov->iov[i].iov_len;\r\nreturn total;\r\n}\r\nstatic int vop_vringh_copy(struct vop_vdev *vdev, struct vringh_kiov *iov,\r\nvoid __user *ubuf, size_t len, bool read, int vr_idx,\r\nsize_t *out_len)\r\n{\r\nint ret = 0;\r\nsize_t partlen, tot_len = 0;\r\nwhile (len && iov->i < iov->used) {\r\nstruct kvec *kiov = &iov->iov[iov->i];\r\npartlen = min(kiov->iov_len, len);\r\nif (read)\r\nret = vop_virtio_copy_to_user(vdev, ubuf, partlen,\r\n(u64)kiov->iov_base,\r\nkiov->iov_len,\r\nvr_idx);\r\nelse\r\nret = vop_virtio_copy_from_user(vdev, ubuf, partlen,\r\n(u64)kiov->iov_base,\r\nkiov->iov_len,\r\nvr_idx);\r\nif (ret) {\r\ndev_err(vop_dev(vdev), "%s %d err %d\n",\r\n__func__, __LINE__, ret);\r\nbreak;\r\n}\r\nlen -= partlen;\r\nubuf += partlen;\r\ntot_len += partlen;\r\niov->consumed += partlen;\r\nkiov->iov_len -= partlen;\r\nkiov->iov_base += partlen;\r\nif (!kiov->iov_len) {\r\nkiov->iov_len = iov->consumed;\r\nkiov->iov_base -= iov->consumed;\r\niov->consumed = 0;\r\niov->i++;\r\n}\r\n}\r\n*out_len = tot_len;\r\nreturn ret;\r\n}\r\nstatic int _vop_virtio_copy(struct vop_vdev *vdev, struct mic_copy_desc *copy)\r\n{\r\nint ret = 0;\r\nu32 iovcnt = copy->iovcnt;\r\nstruct iovec iov;\r\nstruct iovec __user *u_iov = copy->iov;\r\nvoid __user *ubuf = NULL;\r\nstruct vop_vringh *vvr = &vdev->vvr[copy->vr_idx];\r\nstruct vringh_kiov *riov = &vvr->riov;\r\nstruct vringh_kiov *wiov = &vvr->wiov;\r\nstruct vringh *vrh = &vvr->vrh;\r\nu16 *head = &vvr->head;\r\nstruct mic_vring *vr = &vvr->vring;\r\nsize_t len = 0, out_len;\r\ncopy->out_len = 0;\r\nif (riov->i == riov->used && wiov->i == wiov->used) {\r\nret = vringh_getdesc_kern(vrh, riov, wiov,\r\nhead, GFP_KERNEL);\r\nif (ret <= 0)\r\nreturn ret;\r\n}\r\nwhile (iovcnt) {\r\nif (!len) {\r\nret = copy_from_user(&iov, u_iov, sizeof(*u_iov));\r\nif (ret) {\r\nret = -EINVAL;\r\ndev_err(vop_dev(vdev), "%s %d err %d\n",\r\n__func__, __LINE__, ret);\r\nbreak;\r\n}\r\nlen = iov.iov_len;\r\nubuf = iov.iov_base;\r\n}\r\nret = vop_vringh_copy(vdev, riov, ubuf, len,\r\nMIC_VRINGH_READ, copy->vr_idx, &out_len);\r\nif (ret) {\r\ndev_err(vop_dev(vdev), "%s %d err %d\n",\r\n__func__, __LINE__, ret);\r\nbreak;\r\n}\r\nlen -= out_len;\r\nubuf += out_len;\r\ncopy->out_len += out_len;\r\nret = vop_vringh_copy(vdev, wiov, ubuf, len,\r\n!MIC_VRINGH_READ, copy->vr_idx, &out_len);\r\nif (ret) {\r\ndev_err(vop_dev(vdev), "%s %d err %d\n",\r\n__func__, __LINE__, ret);\r\nbreak;\r\n}\r\nlen -= out_len;\r\nubuf += out_len;\r\ncopy->out_len += out_len;\r\nif (!len) {\r\niovcnt--;\r\nu_iov++;\r\n}\r\nif (riov->i == riov->used && wiov->i == wiov->used)\r\nbreak;\r\n}\r\nif (*head != USHRT_MAX && copy->out_len && copy->update_used) {\r\nu32 total = 0;\r\ntotal += vop_vringh_iov_consumed(riov);\r\ntotal += vop_vringh_iov_consumed(wiov);\r\nvringh_complete_kern(vrh, *head, total);\r\n*head = USHRT_MAX;\r\nif (vringh_need_notify_kern(vrh) > 0)\r\nvringh_notify(vrh);\r\nvringh_kiov_cleanup(riov);\r\nvringh_kiov_cleanup(wiov);\r\nvr->info->avail_idx = vrh->last_avail_idx;\r\n}\r\nreturn ret;\r\n}\r\nstatic inline int vop_verify_copy_args(struct vop_vdev *vdev,\r\nstruct mic_copy_desc *copy)\r\n{\r\nif (!vdev || copy->vr_idx >= vdev->dd->num_vq)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int vop_virtio_copy_desc(struct vop_vdev *vdev,\r\nstruct mic_copy_desc *copy)\r\n{\r\nint err;\r\nstruct vop_vringh *vvr;\r\nerr = vop_verify_copy_args(vdev, copy);\r\nif (err)\r\nreturn err;\r\nvvr = &vdev->vvr[copy->vr_idx];\r\nmutex_lock(&vvr->vr_mutex);\r\nif (!vop_vdevup(vdev)) {\r\nerr = -ENODEV;\r\ndev_err(vop_dev(vdev), "%s %d err %d\n",\r\n__func__, __LINE__, err);\r\ngoto err;\r\n}\r\nerr = _vop_virtio_copy(vdev, copy);\r\nif (err) {\r\ndev_err(vop_dev(vdev), "%s %d err %d\n",\r\n__func__, __LINE__, err);\r\n}\r\nerr:\r\nmutex_unlock(&vvr->vr_mutex);\r\nreturn err;\r\n}\r\nstatic int vop_open(struct inode *inode, struct file *f)\r\n{\r\nstruct vop_vdev *vdev;\r\nstruct vop_info *vi = container_of(f->private_data,\r\nstruct vop_info, miscdev);\r\nvdev = kzalloc(sizeof(*vdev), GFP_KERNEL);\r\nif (!vdev)\r\nreturn -ENOMEM;\r\nvdev->vi = vi;\r\nmutex_init(&vdev->vdev_mutex);\r\nf->private_data = vdev;\r\ninit_completion(&vdev->destroy);\r\ncomplete(&vdev->destroy);\r\nreturn 0;\r\n}\r\nstatic int vop_release(struct inode *inode, struct file *f)\r\n{\r\nstruct vop_vdev *vdev = f->private_data, *vdev_tmp;\r\nstruct vop_info *vi = vdev->vi;\r\nstruct list_head *pos, *tmp;\r\nbool found = false;\r\nmutex_lock(&vdev->vdev_mutex);\r\nif (vdev->deleted)\r\ngoto unlock;\r\nmutex_lock(&vi->vop_mutex);\r\nlist_for_each_safe(pos, tmp, &vi->vdev_list) {\r\nvdev_tmp = list_entry(pos, struct vop_vdev, list);\r\nif (vdev == vdev_tmp) {\r\nvop_virtio_del_device(vdev);\r\nlist_del(pos);\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&vi->vop_mutex);\r\nunlock:\r\nmutex_unlock(&vdev->vdev_mutex);\r\nif (!found)\r\nwait_for_completion(&vdev->destroy);\r\nf->private_data = NULL;\r\nkfree(vdev);\r\nreturn 0;\r\n}\r\nstatic long vop_ioctl(struct file *f, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct vop_vdev *vdev = f->private_data;\r\nstruct vop_info *vi = vdev->vi;\r\nvoid __user *argp = (void __user *)arg;\r\nint ret;\r\nswitch (cmd) {\r\ncase MIC_VIRTIO_ADD_DEVICE:\r\n{\r\nstruct mic_device_desc dd, *dd_config;\r\nif (copy_from_user(&dd, argp, sizeof(dd)))\r\nreturn -EFAULT;\r\nif (mic_aligned_desc_size(&dd) > MIC_MAX_DESC_BLK_SIZE ||\r\ndd.num_vq > MIC_MAX_VRINGS)\r\nreturn -EINVAL;\r\ndd_config = kzalloc(mic_desc_size(&dd), GFP_KERNEL);\r\nif (!dd_config)\r\nreturn -ENOMEM;\r\nif (copy_from_user(dd_config, argp, mic_desc_size(&dd))) {\r\nret = -EFAULT;\r\ngoto free_ret;\r\n}\r\nif (memcmp(&dd, dd_config, sizeof(dd))) {\r\nret = -EINVAL;\r\ngoto free_ret;\r\n}\r\nmutex_lock(&vdev->vdev_mutex);\r\nmutex_lock(&vi->vop_mutex);\r\nret = vop_virtio_add_device(vdev, dd_config);\r\nif (ret)\r\ngoto unlock_ret;\r\nlist_add_tail(&vdev->list, &vi->vdev_list);\r\nunlock_ret:\r\nmutex_unlock(&vi->vop_mutex);\r\nmutex_unlock(&vdev->vdev_mutex);\r\nfree_ret:\r\nkfree(dd_config);\r\nreturn ret;\r\n}\r\ncase MIC_VIRTIO_COPY_DESC:\r\n{\r\nstruct mic_copy_desc copy;\r\nmutex_lock(&vdev->vdev_mutex);\r\nret = vop_vdev_inited(vdev);\r\nif (ret)\r\ngoto _unlock_ret;\r\nif (copy_from_user(&copy, argp, sizeof(copy))) {\r\nret = -EFAULT;\r\ngoto _unlock_ret;\r\n}\r\nret = vop_virtio_copy_desc(vdev, &copy);\r\nif (ret < 0)\r\ngoto _unlock_ret;\r\nif (copy_to_user(\r\n&((struct mic_copy_desc __user *)argp)->out_len,\r\n&copy.out_len, sizeof(copy.out_len)))\r\nret = -EFAULT;\r\n_unlock_ret:\r\nmutex_unlock(&vdev->vdev_mutex);\r\nreturn ret;\r\n}\r\ncase MIC_VIRTIO_CONFIG_CHANGE:\r\n{\r\nvoid *buf;\r\nmutex_lock(&vdev->vdev_mutex);\r\nret = vop_vdev_inited(vdev);\r\nif (ret)\r\ngoto __unlock_ret;\r\nbuf = kzalloc(vdev->dd->config_len, GFP_KERNEL);\r\nif (!buf) {\r\nret = -ENOMEM;\r\ngoto __unlock_ret;\r\n}\r\nif (copy_from_user(buf, argp, vdev->dd->config_len)) {\r\nret = -EFAULT;\r\ngoto done;\r\n}\r\nret = vop_virtio_config_change(vdev, buf);\r\ndone:\r\nkfree(buf);\r\n__unlock_ret:\r\nmutex_unlock(&vdev->vdev_mutex);\r\nreturn ret;\r\n}\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n};\r\nreturn 0;\r\n}\r\nstatic unsigned int vop_poll(struct file *f, poll_table *wait)\r\n{\r\nstruct vop_vdev *vdev = f->private_data;\r\nint mask = 0;\r\nmutex_lock(&vdev->vdev_mutex);\r\nif (vop_vdev_inited(vdev)) {\r\nmask = POLLERR;\r\ngoto done;\r\n}\r\npoll_wait(f, &vdev->waitq, wait);\r\nif (vop_vdev_inited(vdev)) {\r\nmask = POLLERR;\r\n} else if (vdev->poll_wake) {\r\nvdev->poll_wake = 0;\r\nmask = POLLIN | POLLOUT;\r\n}\r\ndone:\r\nmutex_unlock(&vdev->vdev_mutex);\r\nreturn mask;\r\n}\r\nstatic inline int\r\nvop_query_offset(struct vop_vdev *vdev, unsigned long offset,\r\nunsigned long *size, unsigned long *pa)\r\n{\r\nstruct vop_device *vpdev = vdev->vpdev;\r\nunsigned long start = MIC_DP_SIZE;\r\nint i;\r\nif (!offset) {\r\n*pa = virt_to_phys(vpdev->hw_ops->get_dp(vpdev));\r\n*size = MIC_DP_SIZE;\r\nreturn 0;\r\n}\r\nfor (i = 0; i < vdev->dd->num_vq; i++) {\r\nstruct vop_vringh *vvr = &vdev->vvr[i];\r\nif (offset == start) {\r\n*pa = virt_to_phys(vvr->vring.va);\r\n*size = vvr->vring.len;\r\nreturn 0;\r\n}\r\nstart += vvr->vring.len;\r\n}\r\nreturn -1;\r\n}\r\nstatic int vop_mmap(struct file *f, struct vm_area_struct *vma)\r\n{\r\nstruct vop_vdev *vdev = f->private_data;\r\nunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\r\nunsigned long pa, size = vma->vm_end - vma->vm_start, size_rem = size;\r\nint i, err;\r\nerr = vop_vdev_inited(vdev);\r\nif (err)\r\ngoto ret;\r\nif (vma->vm_flags & VM_WRITE) {\r\nerr = -EACCES;\r\ngoto ret;\r\n}\r\nwhile (size_rem) {\r\ni = vop_query_offset(vdev, offset, &size, &pa);\r\nif (i < 0) {\r\nerr = -EINVAL;\r\ngoto ret;\r\n}\r\nerr = remap_pfn_range(vma, vma->vm_start + offset,\r\npa >> PAGE_SHIFT, size,\r\nvma->vm_page_prot);\r\nif (err)\r\ngoto ret;\r\nsize_rem -= size;\r\noffset += size;\r\n}\r\nret:\r\nreturn err;\r\n}\r\nint vop_host_init(struct vop_info *vi)\r\n{\r\nint rc;\r\nstruct miscdevice *mdev;\r\nstruct vop_device *vpdev = vi->vpdev;\r\nINIT_LIST_HEAD(&vi->vdev_list);\r\nvi->dma_ch = vpdev->dma_ch;\r\nmdev = &vi->miscdev;\r\nmdev->minor = MISC_DYNAMIC_MINOR;\r\nsnprintf(vi->name, sizeof(vi->name), "vop_virtio%d", vpdev->index);\r\nmdev->name = vi->name;\r\nmdev->fops = &vop_fops;\r\nmdev->parent = &vpdev->dev;\r\nrc = misc_register(mdev);\r\nif (rc)\r\ndev_err(&vpdev->dev, "%s failed rc %d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nvoid vop_host_uninit(struct vop_info *vi)\r\n{\r\nstruct list_head *pos, *tmp;\r\nstruct vop_vdev *vdev;\r\nmutex_lock(&vi->vop_mutex);\r\nvop_virtio_reset_devices(vi);\r\nlist_for_each_safe(pos, tmp, &vi->vdev_list) {\r\nvdev = list_entry(pos, struct vop_vdev, list);\r\nlist_del(pos);\r\nreinit_completion(&vdev->destroy);\r\nmutex_unlock(&vi->vop_mutex);\r\nmutex_lock(&vdev->vdev_mutex);\r\nvop_virtio_del_device(vdev);\r\nvdev->deleted = true;\r\nmutex_unlock(&vdev->vdev_mutex);\r\ncomplete(&vdev->destroy);\r\nmutex_lock(&vi->vop_mutex);\r\n}\r\nmutex_unlock(&vi->vop_mutex);\r\nmisc_deregister(&vi->miscdev);\r\n}
