static int mtk_i2c_clock_enable(struct mtk_i2c *i2c)\r\n{\r\nint ret;\r\nret = clk_prepare_enable(i2c->clk_dma);\r\nif (ret)\r\nreturn ret;\r\nret = clk_prepare_enable(i2c->clk_main);\r\nif (ret)\r\ngoto err_main;\r\nif (i2c->have_pmic) {\r\nret = clk_prepare_enable(i2c->clk_pmic);\r\nif (ret)\r\ngoto err_pmic;\r\n}\r\nreturn 0;\r\nerr_pmic:\r\nclk_disable_unprepare(i2c->clk_main);\r\nerr_main:\r\nclk_disable_unprepare(i2c->clk_dma);\r\nreturn ret;\r\n}\r\nstatic void mtk_i2c_clock_disable(struct mtk_i2c *i2c)\r\n{\r\nif (i2c->have_pmic)\r\nclk_disable_unprepare(i2c->clk_pmic);\r\nclk_disable_unprepare(i2c->clk_main);\r\nclk_disable_unprepare(i2c->clk_dma);\r\n}\r\nstatic void mtk_i2c_init_hw(struct mtk_i2c *i2c)\r\n{\r\nu16 control_reg;\r\nwritew(I2C_SOFT_RST, i2c->base + OFFSET_SOFTRESET);\r\nif (i2c->use_push_pull)\r\nwritew(I2C_IO_CONFIG_PUSH_PULL, i2c->base + OFFSET_IO_CONFIG);\r\nelse\r\nwritew(I2C_IO_CONFIG_OPEN_DRAIN, i2c->base + OFFSET_IO_CONFIG);\r\nif (i2c->dev_comp->dcm)\r\nwritew(I2C_DCM_DISABLE, i2c->base + OFFSET_DCM_EN);\r\nwritew(i2c->timing_reg, i2c->base + OFFSET_TIMING);\r\nwritew(i2c->high_speed_reg, i2c->base + OFFSET_HS);\r\nif (i2c->have_pmic)\r\nwritew(I2C_CONTROL_WRAPPER, i2c->base + OFFSET_PATH_DIR);\r\ncontrol_reg = I2C_CONTROL_ACKERR_DET_EN |\r\nI2C_CONTROL_CLK_EXT_EN | I2C_CONTROL_DMA_EN;\r\nwritew(control_reg, i2c->base + OFFSET_CONTROL);\r\nwritew(I2C_DELAY_LEN, i2c->base + OFFSET_DELAY_LEN);\r\nwritel(I2C_DMA_HARD_RST, i2c->pdmabase + OFFSET_RST);\r\nudelay(50);\r\nwritel(I2C_DMA_CLR_FLAG, i2c->pdmabase + OFFSET_RST);\r\n}\r\nstatic int mtk_i2c_set_speed(struct mtk_i2c *i2c, unsigned int parent_clk,\r\nunsigned int clock_div)\r\n{\r\nunsigned int clk_src;\r\nunsigned int step_cnt;\r\nunsigned int sample_cnt;\r\nunsigned int max_step_cnt;\r\nunsigned int target_speed;\r\nunsigned int base_sample_cnt = MAX_SAMPLE_CNT_DIV;\r\nunsigned int base_step_cnt;\r\nunsigned int opt_div;\r\nunsigned int best_mul;\r\nunsigned int cnt_mul;\r\nclk_src = parent_clk / clock_div;\r\ntarget_speed = i2c->speed_hz;\r\nif (target_speed > MAX_HS_MODE_SPEED)\r\ntarget_speed = MAX_HS_MODE_SPEED;\r\nif (target_speed > MAX_FS_MODE_SPEED)\r\nmax_step_cnt = MAX_HS_STEP_CNT_DIV;\r\nelse\r\nmax_step_cnt = MAX_STEP_CNT_DIV;\r\nbase_step_cnt = max_step_cnt;\r\nopt_div = DIV_ROUND_UP(clk_src >> 1, target_speed);\r\nbest_mul = MAX_SAMPLE_CNT_DIV * max_step_cnt;\r\nfor (sample_cnt = 1; sample_cnt <= MAX_SAMPLE_CNT_DIV; sample_cnt++) {\r\nstep_cnt = DIV_ROUND_UP(opt_div, sample_cnt);\r\ncnt_mul = step_cnt * sample_cnt;\r\nif (step_cnt > max_step_cnt)\r\ncontinue;\r\nif (cnt_mul < best_mul) {\r\nbest_mul = cnt_mul;\r\nbase_sample_cnt = sample_cnt;\r\nbase_step_cnt = step_cnt;\r\nif (best_mul == opt_div)\r\nbreak;\r\n}\r\n}\r\nsample_cnt = base_sample_cnt;\r\nstep_cnt = base_step_cnt;\r\nif ((clk_src / (2 * sample_cnt * step_cnt)) > target_speed) {\r\ndev_dbg(i2c->dev, "Unsupported speed (%uhz)\n", target_speed);\r\nreturn -EINVAL;\r\n}\r\nstep_cnt--;\r\nsample_cnt--;\r\nif (target_speed > MAX_FS_MODE_SPEED) {\r\ni2c->timing_reg = I2C_FS_TIME_INIT_VALUE;\r\ni2c->high_speed_reg = I2C_TIME_DEFAULT_VALUE |\r\n(sample_cnt << 12) | (step_cnt << 8);\r\n} else {\r\ni2c->timing_reg = (sample_cnt << 8) | (step_cnt << 0);\r\ni2c->high_speed_reg = I2C_TIME_CLR_VALUE;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline u32 mtk_i2c_set_4g_mode(dma_addr_t addr)\r\n{\r\nreturn (addr & BIT_ULL(32)) ? I2C_DMA_4G_MODE : I2C_DMA_CLR_FLAG;\r\n}\r\nstatic int mtk_i2c_do_transfer(struct mtk_i2c *i2c, struct i2c_msg *msgs,\r\nint num, int left_num)\r\n{\r\nu16 addr_reg;\r\nu16 start_reg;\r\nu16 control_reg;\r\nu16 restart_flag = 0;\r\nu32 reg_4g_mode;\r\ndma_addr_t rpaddr = 0;\r\ndma_addr_t wpaddr = 0;\r\nint ret;\r\ni2c->irq_stat = 0;\r\nif (i2c->auto_restart)\r\nrestart_flag = I2C_RS_TRANSFER;\r\nreinit_completion(&i2c->msg_complete);\r\ncontrol_reg = readw(i2c->base + OFFSET_CONTROL) &\r\n~(I2C_CONTROL_DIR_CHANGE | I2C_CONTROL_RS);\r\nif ((i2c->speed_hz > 400000) || (left_num >= 1))\r\ncontrol_reg |= I2C_CONTROL_RS;\r\nif (i2c->op == I2C_MASTER_WRRD)\r\ncontrol_reg |= I2C_CONTROL_DIR_CHANGE | I2C_CONTROL_RS;\r\nwritew(control_reg, i2c->base + OFFSET_CONTROL);\r\nif (i2c->speed_hz <= 100000)\r\nwritew(I2C_ST_START_CON, i2c->base + OFFSET_EXT_CONF);\r\nelse\r\nwritew(I2C_FS_START_CON, i2c->base + OFFSET_EXT_CONF);\r\naddr_reg = i2c_8bit_addr_from_msg(msgs);\r\nwritew(addr_reg, i2c->base + OFFSET_SLAVE_ADDR);\r\nwritew(restart_flag | I2C_HS_NACKERR | I2C_ACKERR |\r\nI2C_TRANSAC_COMP, i2c->base + OFFSET_INTR_STAT);\r\nwritew(I2C_FIFO_ADDR_CLR, i2c->base + OFFSET_FIFO_ADDR_CLR);\r\nwritew(restart_flag | I2C_HS_NACKERR | I2C_ACKERR |\r\nI2C_TRANSAC_COMP, i2c->base + OFFSET_INTR_MASK);\r\nif (i2c->op == I2C_MASTER_WRRD) {\r\nif (i2c->dev_comp->aux_len_reg) {\r\nwritew(msgs->len, i2c->base + OFFSET_TRANSFER_LEN);\r\nwritew((msgs + 1)->len, i2c->base +\r\nOFFSET_TRANSFER_LEN_AUX);\r\n} else {\r\nwritew(msgs->len | ((msgs + 1)->len) << 8,\r\ni2c->base + OFFSET_TRANSFER_LEN);\r\n}\r\nwritew(I2C_WRRD_TRANAC_VALUE, i2c->base + OFFSET_TRANSAC_LEN);\r\n} else {\r\nwritew(msgs->len, i2c->base + OFFSET_TRANSFER_LEN);\r\nwritew(num, i2c->base + OFFSET_TRANSAC_LEN);\r\n}\r\nif (i2c->op == I2C_MASTER_RD) {\r\nwritel(I2C_DMA_INT_FLAG_NONE, i2c->pdmabase + OFFSET_INT_FLAG);\r\nwritel(I2C_DMA_CON_RX, i2c->pdmabase + OFFSET_CON);\r\nrpaddr = dma_map_single(i2c->dev, msgs->buf,\r\nmsgs->len, DMA_FROM_DEVICE);\r\nif (dma_mapping_error(i2c->dev, rpaddr))\r\nreturn -ENOMEM;\r\nif (i2c->dev_comp->support_33bits) {\r\nreg_4g_mode = mtk_i2c_set_4g_mode(rpaddr);\r\nwritel(reg_4g_mode, i2c->pdmabase + OFFSET_RX_4G_MODE);\r\n}\r\nwritel((u32)rpaddr, i2c->pdmabase + OFFSET_RX_MEM_ADDR);\r\nwritel(msgs->len, i2c->pdmabase + OFFSET_RX_LEN);\r\n} else if (i2c->op == I2C_MASTER_WR) {\r\nwritel(I2C_DMA_INT_FLAG_NONE, i2c->pdmabase + OFFSET_INT_FLAG);\r\nwritel(I2C_DMA_CON_TX, i2c->pdmabase + OFFSET_CON);\r\nwpaddr = dma_map_single(i2c->dev, msgs->buf,\r\nmsgs->len, DMA_TO_DEVICE);\r\nif (dma_mapping_error(i2c->dev, wpaddr))\r\nreturn -ENOMEM;\r\nif (i2c->dev_comp->support_33bits) {\r\nreg_4g_mode = mtk_i2c_set_4g_mode(wpaddr);\r\nwritel(reg_4g_mode, i2c->pdmabase + OFFSET_TX_4G_MODE);\r\n}\r\nwritel((u32)wpaddr, i2c->pdmabase + OFFSET_TX_MEM_ADDR);\r\nwritel(msgs->len, i2c->pdmabase + OFFSET_TX_LEN);\r\n} else {\r\nwritel(I2C_DMA_CLR_FLAG, i2c->pdmabase + OFFSET_INT_FLAG);\r\nwritel(I2C_DMA_CLR_FLAG, i2c->pdmabase + OFFSET_CON);\r\nwpaddr = dma_map_single(i2c->dev, msgs->buf,\r\nmsgs->len, DMA_TO_DEVICE);\r\nif (dma_mapping_error(i2c->dev, wpaddr))\r\nreturn -ENOMEM;\r\nrpaddr = dma_map_single(i2c->dev, (msgs + 1)->buf,\r\n(msgs + 1)->len,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(i2c->dev, rpaddr)) {\r\ndma_unmap_single(i2c->dev, wpaddr,\r\nmsgs->len, DMA_TO_DEVICE);\r\nreturn -ENOMEM;\r\n}\r\nif (i2c->dev_comp->support_33bits) {\r\nreg_4g_mode = mtk_i2c_set_4g_mode(wpaddr);\r\nwritel(reg_4g_mode, i2c->pdmabase + OFFSET_TX_4G_MODE);\r\nreg_4g_mode = mtk_i2c_set_4g_mode(rpaddr);\r\nwritel(reg_4g_mode, i2c->pdmabase + OFFSET_RX_4G_MODE);\r\n}\r\nwritel((u32)wpaddr, i2c->pdmabase + OFFSET_TX_MEM_ADDR);\r\nwritel((u32)rpaddr, i2c->pdmabase + OFFSET_RX_MEM_ADDR);\r\nwritel(msgs->len, i2c->pdmabase + OFFSET_TX_LEN);\r\nwritel((msgs + 1)->len, i2c->pdmabase + OFFSET_RX_LEN);\r\n}\r\nwritel(I2C_DMA_START_EN, i2c->pdmabase + OFFSET_EN);\r\nif (!i2c->auto_restart) {\r\nstart_reg = I2C_TRANSAC_START;\r\n} else {\r\nstart_reg = I2C_TRANSAC_START | I2C_RS_MUL_TRIG;\r\nif (left_num >= 1)\r\nstart_reg |= I2C_RS_MUL_CNFG;\r\n}\r\nwritew(start_reg, i2c->base + OFFSET_START);\r\nret = wait_for_completion_timeout(&i2c->msg_complete,\r\ni2c->adap.timeout);\r\nwritew(~(restart_flag | I2C_HS_NACKERR | I2C_ACKERR |\r\nI2C_TRANSAC_COMP), i2c->base + OFFSET_INTR_MASK);\r\nif (i2c->op == I2C_MASTER_WR) {\r\ndma_unmap_single(i2c->dev, wpaddr,\r\nmsgs->len, DMA_TO_DEVICE);\r\n} else if (i2c->op == I2C_MASTER_RD) {\r\ndma_unmap_single(i2c->dev, rpaddr,\r\nmsgs->len, DMA_FROM_DEVICE);\r\n} else {\r\ndma_unmap_single(i2c->dev, wpaddr, msgs->len,\r\nDMA_TO_DEVICE);\r\ndma_unmap_single(i2c->dev, rpaddr, (msgs + 1)->len,\r\nDMA_FROM_DEVICE);\r\n}\r\nif (ret == 0) {\r\ndev_dbg(i2c->dev, "addr: %x, transfer timeout\n", msgs->addr);\r\nmtk_i2c_init_hw(i2c);\r\nreturn -ETIMEDOUT;\r\n}\r\ncompletion_done(&i2c->msg_complete);\r\nif (i2c->irq_stat & (I2C_HS_NACKERR | I2C_ACKERR)) {\r\ndev_dbg(i2c->dev, "addr: %x, transfer ACK error\n", msgs->addr);\r\nmtk_i2c_init_hw(i2c);\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mtk_i2c_transfer(struct i2c_adapter *adap,\r\nstruct i2c_msg msgs[], int num)\r\n{\r\nint ret;\r\nint left_num = num;\r\nstruct mtk_i2c *i2c = i2c_get_adapdata(adap);\r\nret = mtk_i2c_clock_enable(i2c);\r\nif (ret)\r\nreturn ret;\r\ni2c->auto_restart = i2c->dev_comp->auto_restart;\r\nif (i2c->auto_restart && num == 2) {\r\nif (!(msgs[0].flags & I2C_M_RD) && (msgs[1].flags & I2C_M_RD) &&\r\nmsgs[0].addr == msgs[1].addr) {\r\ni2c->auto_restart = 0;\r\n}\r\n}\r\nif (i2c->auto_restart && num >= 2 && i2c->speed_hz > MAX_FS_MODE_SPEED)\r\ni2c->ignore_restart_irq = true;\r\nelse\r\ni2c->ignore_restart_irq = false;\r\nwhile (left_num--) {\r\nif (!msgs->buf) {\r\ndev_dbg(i2c->dev, "data buffer is NULL.\n");\r\nret = -EINVAL;\r\ngoto err_exit;\r\n}\r\nif (msgs->flags & I2C_M_RD)\r\ni2c->op = I2C_MASTER_RD;\r\nelse\r\ni2c->op = I2C_MASTER_WR;\r\nif (!i2c->auto_restart) {\r\nif (num > 1) {\r\ni2c->op = I2C_MASTER_WRRD;\r\nleft_num--;\r\n}\r\n}\r\nret = mtk_i2c_do_transfer(i2c, msgs, num, left_num);\r\nif (ret < 0)\r\ngoto err_exit;\r\nmsgs++;\r\n}\r\nret = num;\r\nerr_exit:\r\nmtk_i2c_clock_disable(i2c);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t mtk_i2c_irq(int irqno, void *dev_id)\r\n{\r\nstruct mtk_i2c *i2c = dev_id;\r\nu16 restart_flag = 0;\r\nu16 intr_stat;\r\nif (i2c->auto_restart)\r\nrestart_flag = I2C_RS_TRANSFER;\r\nintr_stat = readw(i2c->base + OFFSET_INTR_STAT);\r\nwritew(intr_stat, i2c->base + OFFSET_INTR_STAT);\r\ni2c->irq_stat |= intr_stat;\r\nif (i2c->ignore_restart_irq && (i2c->irq_stat & restart_flag)) {\r\ni2c->ignore_restart_irq = false;\r\ni2c->irq_stat = 0;\r\nwritew(I2C_RS_MUL_CNFG | I2C_RS_MUL_TRIG | I2C_TRANSAC_START,\r\ni2c->base + OFFSET_START);\r\n} else {\r\nif (i2c->irq_stat & (I2C_TRANSAC_COMP | restart_flag))\r\ncomplete(&i2c->msg_complete);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic u32 mtk_i2c_functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic int mtk_i2c_parse_dt(struct device_node *np, struct mtk_i2c *i2c,\r\nunsigned int *clk_src_div)\r\n{\r\nint ret;\r\nret = of_property_read_u32(np, "clock-frequency", &i2c->speed_hz);\r\nif (ret < 0)\r\ni2c->speed_hz = I2C_DEFAULT_SPEED;\r\nret = of_property_read_u32(np, "clock-div", clk_src_div);\r\nif (ret < 0)\r\nreturn ret;\r\nif (*clk_src_div == 0)\r\nreturn -EINVAL;\r\ni2c->have_pmic = of_property_read_bool(np, "mediatek,have-pmic");\r\ni2c->use_push_pull =\r\nof_property_read_bool(np, "mediatek,use-push-pull");\r\nreturn 0;\r\n}\r\nstatic int mtk_i2c_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id;\r\nint ret = 0;\r\nstruct mtk_i2c *i2c;\r\nstruct clk *clk;\r\nunsigned int clk_src_div;\r\nstruct resource *res;\r\nint irq;\r\ni2c = devm_kzalloc(&pdev->dev, sizeof(*i2c), GFP_KERNEL);\r\nif (!i2c)\r\nreturn -ENOMEM;\r\nret = mtk_i2c_parse_dt(pdev->dev.of_node, i2c, &clk_src_div);\r\nif (ret)\r\nreturn -EINVAL;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ni2c->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(i2c->base))\r\nreturn PTR_ERR(i2c->base);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\ni2c->pdmabase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(i2c->pdmabase))\r\nreturn PTR_ERR(i2c->pdmabase);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0)\r\nreturn irq;\r\ninit_completion(&i2c->msg_complete);\r\nof_id = of_match_node(mtk_i2c_of_match, pdev->dev.of_node);\r\nif (!of_id)\r\nreturn -EINVAL;\r\ni2c->dev_comp = of_id->data;\r\ni2c->adap.dev.of_node = pdev->dev.of_node;\r\ni2c->dev = &pdev->dev;\r\ni2c->adap.dev.parent = &pdev->dev;\r\ni2c->adap.owner = THIS_MODULE;\r\ni2c->adap.algo = &mtk_i2c_algorithm;\r\ni2c->adap.quirks = i2c->dev_comp->quirks;\r\ni2c->adap.timeout = 2 * HZ;\r\ni2c->adap.retries = 1;\r\nif (i2c->have_pmic && !i2c->dev_comp->pmic_i2c)\r\nreturn -EINVAL;\r\ni2c->clk_main = devm_clk_get(&pdev->dev, "main");\r\nif (IS_ERR(i2c->clk_main)) {\r\ndev_err(&pdev->dev, "cannot get main clock\n");\r\nreturn PTR_ERR(i2c->clk_main);\r\n}\r\ni2c->clk_dma = devm_clk_get(&pdev->dev, "dma");\r\nif (IS_ERR(i2c->clk_dma)) {\r\ndev_err(&pdev->dev, "cannot get dma clock\n");\r\nreturn PTR_ERR(i2c->clk_dma);\r\n}\r\nclk = i2c->clk_main;\r\nif (i2c->have_pmic) {\r\ni2c->clk_pmic = devm_clk_get(&pdev->dev, "pmic");\r\nif (IS_ERR(i2c->clk_pmic)) {\r\ndev_err(&pdev->dev, "cannot get pmic clock\n");\r\nreturn PTR_ERR(i2c->clk_pmic);\r\n}\r\nclk = i2c->clk_pmic;\r\n}\r\nstrlcpy(i2c->adap.name, I2C_DRV_NAME, sizeof(i2c->adap.name));\r\nret = mtk_i2c_set_speed(i2c, clk_get_rate(clk), clk_src_div);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to set the speed.\n");\r\nreturn -EINVAL;\r\n}\r\nif (i2c->dev_comp->support_33bits) {\r\nret = dma_set_mask(&pdev->dev, DMA_BIT_MASK(33));\r\nif (ret) {\r\ndev_err(&pdev->dev, "dma_set_mask return error.\n");\r\nreturn ret;\r\n}\r\n}\r\nret = mtk_i2c_clock_enable(i2c);\r\nif (ret) {\r\ndev_err(&pdev->dev, "clock enable failed!\n");\r\nreturn ret;\r\n}\r\nmtk_i2c_init_hw(i2c);\r\nmtk_i2c_clock_disable(i2c);\r\nret = devm_request_irq(&pdev->dev, irq, mtk_i2c_irq,\r\nIRQF_TRIGGER_NONE, I2C_DRV_NAME, i2c);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev,\r\n"Request I2C IRQ %d fail\n", irq);\r\nreturn ret;\r\n}\r\ni2c_set_adapdata(&i2c->adap, i2c);\r\nret = i2c_add_adapter(&i2c->adap);\r\nif (ret)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, i2c);\r\nreturn 0;\r\n}\r\nstatic int mtk_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct mtk_i2c *i2c = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&i2c->adap);\r\nreturn 0;\r\n}\r\nstatic int mtk_i2c_resume(struct device *dev)\r\n{\r\nstruct mtk_i2c *i2c = dev_get_drvdata(dev);\r\nmtk_i2c_init_hw(i2c);\r\nreturn 0;\r\n}
