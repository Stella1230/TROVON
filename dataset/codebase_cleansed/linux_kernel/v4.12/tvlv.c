static void batadv_tvlv_handler_release(struct kref *ref)\r\n{\r\nstruct batadv_tvlv_handler *tvlv_handler;\r\ntvlv_handler = container_of(ref, struct batadv_tvlv_handler, refcount);\r\nkfree_rcu(tvlv_handler, rcu);\r\n}\r\nstatic void batadv_tvlv_handler_put(struct batadv_tvlv_handler *tvlv_handler)\r\n{\r\nkref_put(&tvlv_handler->refcount, batadv_tvlv_handler_release);\r\n}\r\nstatic struct batadv_tvlv_handler *\r\nbatadv_tvlv_handler_get(struct batadv_priv *bat_priv, u8 type, u8 version)\r\n{\r\nstruct batadv_tvlv_handler *tvlv_handler_tmp, *tvlv_handler = NULL;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(tvlv_handler_tmp,\r\n&bat_priv->tvlv.handler_list, list) {\r\nif (tvlv_handler_tmp->type != type)\r\ncontinue;\r\nif (tvlv_handler_tmp->version != version)\r\ncontinue;\r\nif (!kref_get_unless_zero(&tvlv_handler_tmp->refcount))\r\ncontinue;\r\ntvlv_handler = tvlv_handler_tmp;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn tvlv_handler;\r\n}\r\nstatic void batadv_tvlv_container_release(struct kref *ref)\r\n{\r\nstruct batadv_tvlv_container *tvlv;\r\ntvlv = container_of(ref, struct batadv_tvlv_container, refcount);\r\nkfree(tvlv);\r\n}\r\nstatic void batadv_tvlv_container_put(struct batadv_tvlv_container *tvlv)\r\n{\r\nkref_put(&tvlv->refcount, batadv_tvlv_container_release);\r\n}\r\nstatic struct batadv_tvlv_container *\r\nbatadv_tvlv_container_get(struct batadv_priv *bat_priv, u8 type, u8 version)\r\n{\r\nstruct batadv_tvlv_container *tvlv_tmp, *tvlv = NULL;\r\nlockdep_assert_held(&bat_priv->tvlv.container_list_lock);\r\nhlist_for_each_entry(tvlv_tmp, &bat_priv->tvlv.container_list, list) {\r\nif (tvlv_tmp->tvlv_hdr.type != type)\r\ncontinue;\r\nif (tvlv_tmp->tvlv_hdr.version != version)\r\ncontinue;\r\nkref_get(&tvlv_tmp->refcount);\r\ntvlv = tvlv_tmp;\r\nbreak;\r\n}\r\nreturn tvlv;\r\n}\r\nstatic u16 batadv_tvlv_container_list_size(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_tvlv_container *tvlv;\r\nu16 tvlv_len = 0;\r\nlockdep_assert_held(&bat_priv->tvlv.container_list_lock);\r\nhlist_for_each_entry(tvlv, &bat_priv->tvlv.container_list, list) {\r\ntvlv_len += sizeof(struct batadv_tvlv_hdr);\r\ntvlv_len += ntohs(tvlv->tvlv_hdr.len);\r\n}\r\nreturn tvlv_len;\r\n}\r\nstatic void batadv_tvlv_container_remove(struct batadv_priv *bat_priv,\r\nstruct batadv_tvlv_container *tvlv)\r\n{\r\nlockdep_assert_held(&bat_priv->tvlv.container_list_lock);\r\nif (!tvlv)\r\nreturn;\r\nhlist_del(&tvlv->list);\r\nbatadv_tvlv_container_put(tvlv);\r\nbatadv_tvlv_container_put(tvlv);\r\n}\r\nvoid batadv_tvlv_container_unregister(struct batadv_priv *bat_priv,\r\nu8 type, u8 version)\r\n{\r\nstruct batadv_tvlv_container *tvlv;\r\nspin_lock_bh(&bat_priv->tvlv.container_list_lock);\r\ntvlv = batadv_tvlv_container_get(bat_priv, type, version);\r\nbatadv_tvlv_container_remove(bat_priv, tvlv);\r\nspin_unlock_bh(&bat_priv->tvlv.container_list_lock);\r\n}\r\nvoid batadv_tvlv_container_register(struct batadv_priv *bat_priv,\r\nu8 type, u8 version,\r\nvoid *tvlv_value, u16 tvlv_value_len)\r\n{\r\nstruct batadv_tvlv_container *tvlv_old, *tvlv_new;\r\nif (!tvlv_value)\r\ntvlv_value_len = 0;\r\ntvlv_new = kzalloc(sizeof(*tvlv_new) + tvlv_value_len, GFP_ATOMIC);\r\nif (!tvlv_new)\r\nreturn;\r\ntvlv_new->tvlv_hdr.version = version;\r\ntvlv_new->tvlv_hdr.type = type;\r\ntvlv_new->tvlv_hdr.len = htons(tvlv_value_len);\r\nmemcpy(tvlv_new + 1, tvlv_value, ntohs(tvlv_new->tvlv_hdr.len));\r\nINIT_HLIST_NODE(&tvlv_new->list);\r\nkref_init(&tvlv_new->refcount);\r\nspin_lock_bh(&bat_priv->tvlv.container_list_lock);\r\ntvlv_old = batadv_tvlv_container_get(bat_priv, type, version);\r\nbatadv_tvlv_container_remove(bat_priv, tvlv_old);\r\nkref_get(&tvlv_new->refcount);\r\nhlist_add_head(&tvlv_new->list, &bat_priv->tvlv.container_list);\r\nspin_unlock_bh(&bat_priv->tvlv.container_list_lock);\r\nbatadv_tvlv_container_put(tvlv_new);\r\n}\r\nstatic bool batadv_tvlv_realloc_packet_buff(unsigned char **packet_buff,\r\nint *packet_buff_len,\r\nint min_packet_len,\r\nint additional_packet_len)\r\n{\r\nunsigned char *new_buff;\r\nnew_buff = kmalloc(min_packet_len + additional_packet_len, GFP_ATOMIC);\r\nif (!new_buff)\r\nreturn false;\r\nmemcpy(new_buff, *packet_buff, min_packet_len);\r\nkfree(*packet_buff);\r\n*packet_buff = new_buff;\r\n*packet_buff_len = min_packet_len + additional_packet_len;\r\nreturn true;\r\n}\r\nu16 batadv_tvlv_container_ogm_append(struct batadv_priv *bat_priv,\r\nunsigned char **packet_buff,\r\nint *packet_buff_len, int packet_min_len)\r\n{\r\nstruct batadv_tvlv_container *tvlv;\r\nstruct batadv_tvlv_hdr *tvlv_hdr;\r\nu16 tvlv_value_len;\r\nvoid *tvlv_value;\r\nbool ret;\r\nspin_lock_bh(&bat_priv->tvlv.container_list_lock);\r\ntvlv_value_len = batadv_tvlv_container_list_size(bat_priv);\r\nret = batadv_tvlv_realloc_packet_buff(packet_buff, packet_buff_len,\r\npacket_min_len, tvlv_value_len);\r\nif (!ret)\r\ngoto end;\r\nif (!tvlv_value_len)\r\ngoto end;\r\ntvlv_value = (*packet_buff) + packet_min_len;\r\nhlist_for_each_entry(tvlv, &bat_priv->tvlv.container_list, list) {\r\ntvlv_hdr = tvlv_value;\r\ntvlv_hdr->type = tvlv->tvlv_hdr.type;\r\ntvlv_hdr->version = tvlv->tvlv_hdr.version;\r\ntvlv_hdr->len = tvlv->tvlv_hdr.len;\r\ntvlv_value = tvlv_hdr + 1;\r\nmemcpy(tvlv_value, tvlv + 1, ntohs(tvlv->tvlv_hdr.len));\r\ntvlv_value = (u8 *)tvlv_value + ntohs(tvlv->tvlv_hdr.len);\r\n}\r\nend:\r\nspin_unlock_bh(&bat_priv->tvlv.container_list_lock);\r\nreturn tvlv_value_len;\r\n}\r\nstatic int batadv_tvlv_call_handler(struct batadv_priv *bat_priv,\r\nstruct batadv_tvlv_handler *tvlv_handler,\r\nbool ogm_source,\r\nstruct batadv_orig_node *orig_node,\r\nu8 *src, u8 *dst,\r\nvoid *tvlv_value, u16 tvlv_value_len)\r\n{\r\nif (!tvlv_handler)\r\nreturn NET_RX_SUCCESS;\r\nif (ogm_source) {\r\nif (!tvlv_handler->ogm_handler)\r\nreturn NET_RX_SUCCESS;\r\nif (!orig_node)\r\nreturn NET_RX_SUCCESS;\r\ntvlv_handler->ogm_handler(bat_priv, orig_node,\r\nBATADV_NO_FLAGS,\r\ntvlv_value, tvlv_value_len);\r\ntvlv_handler->flags |= BATADV_TVLV_HANDLER_OGM_CALLED;\r\n} else {\r\nif (!src)\r\nreturn NET_RX_SUCCESS;\r\nif (!dst)\r\nreturn NET_RX_SUCCESS;\r\nif (!tvlv_handler->unicast_handler)\r\nreturn NET_RX_SUCCESS;\r\nreturn tvlv_handler->unicast_handler(bat_priv, src,\r\ndst, tvlv_value,\r\ntvlv_value_len);\r\n}\r\nreturn NET_RX_SUCCESS;\r\n}\r\nint batadv_tvlv_containers_process(struct batadv_priv *bat_priv,\r\nbool ogm_source,\r\nstruct batadv_orig_node *orig_node,\r\nu8 *src, u8 *dst,\r\nvoid *tvlv_value, u16 tvlv_value_len)\r\n{\r\nstruct batadv_tvlv_handler *tvlv_handler;\r\nstruct batadv_tvlv_hdr *tvlv_hdr;\r\nu16 tvlv_value_cont_len;\r\nu8 cifnotfound = BATADV_TVLV_HANDLER_OGM_CIFNOTFND;\r\nint ret = NET_RX_SUCCESS;\r\nwhile (tvlv_value_len >= sizeof(*tvlv_hdr)) {\r\ntvlv_hdr = tvlv_value;\r\ntvlv_value_cont_len = ntohs(tvlv_hdr->len);\r\ntvlv_value = tvlv_hdr + 1;\r\ntvlv_value_len -= sizeof(*tvlv_hdr);\r\nif (tvlv_value_cont_len > tvlv_value_len)\r\nbreak;\r\ntvlv_handler = batadv_tvlv_handler_get(bat_priv,\r\ntvlv_hdr->type,\r\ntvlv_hdr->version);\r\nret |= batadv_tvlv_call_handler(bat_priv, tvlv_handler,\r\nogm_source, orig_node,\r\nsrc, dst, tvlv_value,\r\ntvlv_value_cont_len);\r\nif (tvlv_handler)\r\nbatadv_tvlv_handler_put(tvlv_handler);\r\ntvlv_value = (u8 *)tvlv_value + tvlv_value_cont_len;\r\ntvlv_value_len -= tvlv_value_cont_len;\r\n}\r\nif (!ogm_source)\r\nreturn ret;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(tvlv_handler,\r\n&bat_priv->tvlv.handler_list, list) {\r\nif ((tvlv_handler->flags & BATADV_TVLV_HANDLER_OGM_CIFNOTFND) &&\r\n!(tvlv_handler->flags & BATADV_TVLV_HANDLER_OGM_CALLED))\r\ntvlv_handler->ogm_handler(bat_priv, orig_node,\r\ncifnotfound, NULL, 0);\r\ntvlv_handler->flags &= ~BATADV_TVLV_HANDLER_OGM_CALLED;\r\n}\r\nrcu_read_unlock();\r\nreturn NET_RX_SUCCESS;\r\n}\r\nvoid batadv_tvlv_ogm_receive(struct batadv_priv *bat_priv,\r\nstruct batadv_ogm_packet *batadv_ogm_packet,\r\nstruct batadv_orig_node *orig_node)\r\n{\r\nvoid *tvlv_value;\r\nu16 tvlv_value_len;\r\nif (!batadv_ogm_packet)\r\nreturn;\r\ntvlv_value_len = ntohs(batadv_ogm_packet->tvlv_len);\r\nif (!tvlv_value_len)\r\nreturn;\r\ntvlv_value = batadv_ogm_packet + 1;\r\nbatadv_tvlv_containers_process(bat_priv, true, orig_node, NULL, NULL,\r\ntvlv_value, tvlv_value_len);\r\n}\r\nvoid batadv_tvlv_handler_register(struct batadv_priv *bat_priv,\r\nvoid (*optr)(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig,\r\nu8 flags,\r\nvoid *tvlv_value,\r\nu16 tvlv_value_len),\r\nint (*uptr)(struct batadv_priv *bat_priv,\r\nu8 *src, u8 *dst,\r\nvoid *tvlv_value,\r\nu16 tvlv_value_len),\r\nu8 type, u8 version, u8 flags)\r\n{\r\nstruct batadv_tvlv_handler *tvlv_handler;\r\ntvlv_handler = batadv_tvlv_handler_get(bat_priv, type, version);\r\nif (tvlv_handler) {\r\nbatadv_tvlv_handler_put(tvlv_handler);\r\nreturn;\r\n}\r\ntvlv_handler = kzalloc(sizeof(*tvlv_handler), GFP_ATOMIC);\r\nif (!tvlv_handler)\r\nreturn;\r\ntvlv_handler->ogm_handler = optr;\r\ntvlv_handler->unicast_handler = uptr;\r\ntvlv_handler->type = type;\r\ntvlv_handler->version = version;\r\ntvlv_handler->flags = flags;\r\nkref_init(&tvlv_handler->refcount);\r\nINIT_HLIST_NODE(&tvlv_handler->list);\r\nspin_lock_bh(&bat_priv->tvlv.handler_list_lock);\r\nkref_get(&tvlv_handler->refcount);\r\nhlist_add_head_rcu(&tvlv_handler->list, &bat_priv->tvlv.handler_list);\r\nspin_unlock_bh(&bat_priv->tvlv.handler_list_lock);\r\nbatadv_tvlv_handler_put(tvlv_handler);\r\n}\r\nvoid batadv_tvlv_handler_unregister(struct batadv_priv *bat_priv,\r\nu8 type, u8 version)\r\n{\r\nstruct batadv_tvlv_handler *tvlv_handler;\r\ntvlv_handler = batadv_tvlv_handler_get(bat_priv, type, version);\r\nif (!tvlv_handler)\r\nreturn;\r\nbatadv_tvlv_handler_put(tvlv_handler);\r\nspin_lock_bh(&bat_priv->tvlv.handler_list_lock);\r\nhlist_del_rcu(&tvlv_handler->list);\r\nspin_unlock_bh(&bat_priv->tvlv.handler_list_lock);\r\nbatadv_tvlv_handler_put(tvlv_handler);\r\n}\r\nvoid batadv_tvlv_unicast_send(struct batadv_priv *bat_priv, u8 *src,\r\nu8 *dst, u8 type, u8 version,\r\nvoid *tvlv_value, u16 tvlv_value_len)\r\n{\r\nstruct batadv_unicast_tvlv_packet *unicast_tvlv_packet;\r\nstruct batadv_tvlv_hdr *tvlv_hdr;\r\nstruct batadv_orig_node *orig_node;\r\nstruct sk_buff *skb;\r\nunsigned char *tvlv_buff;\r\nunsigned int tvlv_len;\r\nssize_t hdr_len = sizeof(*unicast_tvlv_packet);\r\norig_node = batadv_orig_hash_find(bat_priv, dst);\r\nif (!orig_node)\r\nreturn;\r\ntvlv_len = sizeof(*tvlv_hdr) + tvlv_value_len;\r\nskb = netdev_alloc_skb_ip_align(NULL, ETH_HLEN + hdr_len + tvlv_len);\r\nif (!skb)\r\ngoto out;\r\nskb->priority = TC_PRIO_CONTROL;\r\nskb_reserve(skb, ETH_HLEN);\r\ntvlv_buff = skb_put(skb, sizeof(*unicast_tvlv_packet) + tvlv_len);\r\nunicast_tvlv_packet = (struct batadv_unicast_tvlv_packet *)tvlv_buff;\r\nunicast_tvlv_packet->packet_type = BATADV_UNICAST_TVLV;\r\nunicast_tvlv_packet->version = BATADV_COMPAT_VERSION;\r\nunicast_tvlv_packet->ttl = BATADV_TTL;\r\nunicast_tvlv_packet->reserved = 0;\r\nunicast_tvlv_packet->tvlv_len = htons(tvlv_len);\r\nunicast_tvlv_packet->align = 0;\r\nether_addr_copy(unicast_tvlv_packet->src, src);\r\nether_addr_copy(unicast_tvlv_packet->dst, dst);\r\ntvlv_buff = (unsigned char *)(unicast_tvlv_packet + 1);\r\ntvlv_hdr = (struct batadv_tvlv_hdr *)tvlv_buff;\r\ntvlv_hdr->version = version;\r\ntvlv_hdr->type = type;\r\ntvlv_hdr->len = htons(tvlv_value_len);\r\ntvlv_buff += sizeof(*tvlv_hdr);\r\nmemcpy(tvlv_buff, tvlv_value, tvlv_value_len);\r\nbatadv_send_skb_to_orig(skb, orig_node, NULL);\r\nout:\r\nbatadv_orig_node_put(orig_node);\r\n}
