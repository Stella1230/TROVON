static int gp8psk_usb_in_op(struct dvb_usb_device *d, u8 req, u16 value,\r\nu16 index, u8 *b, int blen)\r\n{\r\nstruct gp8psk_state *st = d->priv;\r\nint ret = 0,try = 0;\r\nif (blen > sizeof(st->data))\r\nreturn -EIO;\r\nif ((ret = mutex_lock_interruptible(&d->usb_mutex)))\r\nreturn ret;\r\nwhile (ret >= 0 && ret != blen && try < 3) {\r\nret = usb_control_msg(d->udev,\r\nusb_rcvctrlpipe(d->udev,0),\r\nreq,\r\nUSB_TYPE_VENDOR | USB_DIR_IN,\r\nvalue, index, st->data, blen,\r\n2000);\r\ndeb_info("reading number %d (ret: %d)\n",try,ret);\r\ntry++;\r\n}\r\nif (ret < 0 || ret != blen) {\r\nwarn("usb in %d operation failed.", req);\r\nret = -EIO;\r\n} else {\r\nret = 0;\r\nmemcpy(b, st->data, blen);\r\n}\r\ndeb_xfer("in: req. %x, val: %x, ind: %x, buffer: ",req,value,index);\r\ndebug_dump(b,blen,deb_xfer);\r\nmutex_unlock(&d->usb_mutex);\r\nreturn ret;\r\n}\r\nstatic int gp8psk_usb_out_op(struct dvb_usb_device *d, u8 req, u16 value,\r\nu16 index, u8 *b, int blen)\r\n{\r\nstruct gp8psk_state *st = d->priv;\r\nint ret;\r\ndeb_xfer("out: req. %x, val: %x, ind: %x, buffer: ",req,value,index);\r\ndebug_dump(b,blen,deb_xfer);\r\nif (blen > sizeof(st->data))\r\nreturn -EIO;\r\nif ((ret = mutex_lock_interruptible(&d->usb_mutex)))\r\nreturn ret;\r\nmemcpy(st->data, b, blen);\r\nif (usb_control_msg(d->udev,\r\nusb_sndctrlpipe(d->udev,0),\r\nreq,\r\nUSB_TYPE_VENDOR | USB_DIR_OUT,\r\nvalue, index, st->data, blen,\r\n2000) != blen) {\r\nwarn("usb out operation failed.");\r\nret = -EIO;\r\n} else\r\nret = 0;\r\nmutex_unlock(&d->usb_mutex);\r\nreturn ret;\r\n}\r\nstatic int gp8psk_get_fw_version(struct dvb_usb_device *d, u8 *fw_vers)\r\n{\r\nreturn gp8psk_usb_in_op(d, GET_FW_VERS, 0, 0, fw_vers, 6);\r\n}\r\nstatic int gp8psk_get_fpga_version(struct dvb_usb_device *d, u8 *fpga_vers)\r\n{\r\nreturn gp8psk_usb_in_op(d, GET_FPGA_VERS, 0, 0, fpga_vers, 1);\r\n}\r\nstatic void gp8psk_info(struct dvb_usb_device *d)\r\n{\r\nu8 fpga_vers, fw_vers[6];\r\nif (!gp8psk_get_fw_version(d, fw_vers))\r\ninfo("FW Version = %i.%02i.%i (0x%x) Build %4i/%02i/%02i",\r\nfw_vers[2], fw_vers[1], fw_vers[0], GP8PSK_FW_VERS(fw_vers),\r\n2000 + fw_vers[5], fw_vers[4], fw_vers[3]);\r\nelse\r\ninfo("failed to get FW version");\r\nif (!gp8psk_get_fpga_version(d, &fpga_vers))\r\ninfo("FPGA Version = %i", fpga_vers);\r\nelse\r\ninfo("failed to get FPGA version");\r\n}\r\nstatic int gp8psk_load_bcm4500fw(struct dvb_usb_device *d)\r\n{\r\nint ret;\r\nconst struct firmware *fw = NULL;\r\nconst u8 *ptr;\r\nu8 *buf;\r\nif ((ret = request_firmware(&fw, bcm4500_firmware,\r\n&d->udev->dev)) != 0) {\r\nerr("did not find the bcm4500 firmware file. (%s) Please see linux/Documentation/dvb/ for more details on firmware-problems. (%d)",\r\nbcm4500_firmware,ret);\r\nreturn ret;\r\n}\r\nret = -EINVAL;\r\nif (gp8psk_usb_out_op(d, LOAD_BCM4500,1,0,NULL, 0))\r\ngoto out_rel_fw;\r\ninfo("downloading bcm4500 firmware from file '%s'",bcm4500_firmware);\r\nptr = fw->data;\r\nbuf = kmalloc(64, GFP_KERNEL | GFP_DMA);\r\nif (!buf) {\r\nret = -ENOMEM;\r\ngoto out_rel_fw;\r\n}\r\nwhile (ptr[0] != 0xff) {\r\nu16 buflen = ptr[0] + 4;\r\nif (ptr + buflen >= fw->data + fw->size) {\r\nerr("failed to load bcm4500 firmware.");\r\ngoto out_free;\r\n}\r\nif (buflen > 64) {\r\nerr("firmware chunk size bigger than 64 bytes.");\r\ngoto out_free;\r\n}\r\nmemcpy(buf, ptr, buflen);\r\nif (dvb_usb_generic_write(d, buf, buflen)) {\r\nerr("failed to load bcm4500 firmware.");\r\ngoto out_free;\r\n}\r\nptr += buflen;\r\n}\r\nret = 0;\r\nout_free:\r\nkfree(buf);\r\nout_rel_fw:\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nstatic int gp8psk_power_ctrl(struct dvb_usb_device *d, int onoff)\r\n{\r\nu8 status, buf;\r\nint gp_product_id = le16_to_cpu(d->udev->descriptor.idProduct);\r\nif (onoff) {\r\ngp8psk_usb_in_op(d, GET_8PSK_CONFIG,0,0,&status,1);\r\nif (! (status & bm8pskStarted)) {\r\nif(gp_product_id == USB_PID_GENPIX_SKYWALKER_CW3K)\r\ngp8psk_usb_out_op(d, CW3K_INIT, 1, 0, NULL, 0);\r\nif (gp8psk_usb_in_op(d, BOOT_8PSK, 1, 0, &buf, 1))\r\nreturn -EINVAL;\r\ngp8psk_info(d);\r\n}\r\nif (gp_product_id == USB_PID_GENPIX_8PSK_REV_1_WARM)\r\nif (! (status & bm8pskFW_Loaded))\r\nif(gp8psk_load_bcm4500fw(d))\r\nreturn -EINVAL;\r\nif (! (status & bmIntersilOn))\r\nif (gp8psk_usb_in_op(d, START_INTERSIL, 1, 0,\r\n&buf, 1))\r\nreturn -EINVAL;\r\nif (gp_product_id == USB_PID_GENPIX_8PSK_REV_1_WARM)\r\nif (gp8psk_usb_out_op(d, SET_DVB_MODE, 1, 0, NULL, 0))\r\nreturn -EINVAL;\r\nif (gp8psk_usb_out_op(d, ARM_TRANSFER, 0, 0, NULL, 0))\r\nreturn -EINVAL;\r\n} else {\r\nif (gp8psk_usb_in_op(d, START_INTERSIL, 0, 0, &buf, 1))\r\nreturn -EINVAL;\r\nif (gp8psk_usb_in_op(d, BOOT_8PSK, 0, 0, &buf, 1))\r\nreturn -EINVAL;\r\nif(gp_product_id == USB_PID_GENPIX_SKYWALKER_CW3K)\r\ngp8psk_usb_out_op(d, CW3K_INIT, 0, 0, NULL, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int gp8psk_bcm4500_reload(struct dvb_usb_device *d)\r\n{\r\nu8 buf;\r\nint gp_product_id = le16_to_cpu(d->udev->descriptor.idProduct);\r\ndeb_xfer("reloading firmware\n");\r\nif (gp8psk_usb_in_op(d, BOOT_8PSK, 0, 0, &buf, 1))\r\nreturn -EINVAL;\r\nif (gp8psk_usb_in_op(d, BOOT_8PSK, 1, 0, &buf, 1))\r\nreturn -EINVAL;\r\nif (gp_product_id == USB_PID_GENPIX_8PSK_REV_1_WARM)\r\nif (gp8psk_load_bcm4500fw(d))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int gp8psk_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nreturn gp8psk_usb_out_op(adap->dev, ARM_TRANSFER, onoff, 0 , NULL, 0);\r\n}\r\nstatic int gp8psk_fe_in(void *priv, u8 req, u16 value,\r\nu16 index, u8 *b, int blen)\r\n{\r\nstruct dvb_usb_device *d = priv;\r\nreturn gp8psk_usb_in_op(d, req, value, index, b, blen);\r\n}\r\nstatic int gp8psk_fe_out(void *priv, u8 req, u16 value,\r\nu16 index, u8 *b, int blen)\r\n{\r\nstruct dvb_usb_device *d = priv;\r\nreturn gp8psk_usb_out_op(d, req, value, index, b, blen);\r\n}\r\nstatic int gp8psk_fe_reload(void *priv)\r\n{\r\nstruct dvb_usb_device *d = priv;\r\nreturn gp8psk_bcm4500_reload(d);\r\n}\r\nstatic int gp8psk_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_usb_device *d = adap->dev;\r\nint id = le16_to_cpu(d->udev->descriptor.idProduct);\r\nint is_rev1;\r\nis_rev1 = (id == USB_PID_GENPIX_8PSK_REV_1_WARM) ? true : false;\r\nadap->fe_adap[0].fe = dvb_attach(gp8psk_fe_attach,\r\n&gp8psk_fe_ops, d, is_rev1);\r\nreturn 0;\r\n}\r\nstatic int gp8psk_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nint ret;\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nret = dvb_usb_device_init(intf, &gp8psk_properties,\r\nTHIS_MODULE, NULL, adapter_nr);\r\nif (ret == 0) {\r\ninfo("found Genpix USB device pID = %x (hex)",\r\nle16_to_cpu(udev->descriptor.idProduct));\r\n}\r\nreturn ret;\r\n}
