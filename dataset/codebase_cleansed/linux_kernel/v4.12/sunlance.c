static void load_csrs(struct lance_private *lp)\r\n{\r\nu32 leptr;\r\nif (lp->pio_buffer)\r\nleptr = 0;\r\nelse\r\nleptr = LANCE_ADDR(lp->init_block_dvma);\r\nsbus_writew(LE_CSR1, lp->lregs + RAP);\r\nsbus_writew(leptr & 0xffff, lp->lregs + RDP);\r\nsbus_writew(LE_CSR2, lp->lregs + RAP);\r\nsbus_writew(leptr >> 16, lp->lregs + RDP);\r\nsbus_writew(LE_CSR3, lp->lregs + RAP);\r\nsbus_writew(lp->busmaster_regval, lp->lregs + RDP);\r\nsbus_writew(LE_CSR0, lp->lregs + RAP);\r\n}\r\nstatic void lance_init_ring_dvma(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nstruct lance_init_block *ib = lp->init_block_mem;\r\ndma_addr_t aib = lp->init_block_dvma;\r\n__u32 leptr;\r\nint i;\r\nnetif_stop_queue(dev);\r\nlp->rx_new = lp->tx_new = 0;\r\nlp->rx_old = lp->tx_old = 0;\r\nib->phys_addr [0] = dev->dev_addr [1];\r\nib->phys_addr [1] = dev->dev_addr [0];\r\nib->phys_addr [2] = dev->dev_addr [3];\r\nib->phys_addr [3] = dev->dev_addr [2];\r\nib->phys_addr [4] = dev->dev_addr [5];\r\nib->phys_addr [5] = dev->dev_addr [4];\r\nfor (i = 0; i < TX_RING_SIZE; i++) {\r\nleptr = LANCE_ADDR(aib + libbuff_offset(tx_buf, i));\r\nib->btx_ring [i].tmd0 = leptr;\r\nib->btx_ring [i].tmd1_hadr = leptr >> 16;\r\nib->btx_ring [i].tmd1_bits = 0;\r\nib->btx_ring [i].length = 0xf000;\r\nib->btx_ring [i].misc = 0;\r\n}\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nleptr = LANCE_ADDR(aib + libbuff_offset(rx_buf, i));\r\nib->brx_ring [i].rmd0 = leptr;\r\nib->brx_ring [i].rmd1_hadr = leptr >> 16;\r\nib->brx_ring [i].rmd1_bits = LE_R1_OWN;\r\nib->brx_ring [i].length = -RX_BUFF_SIZE | 0xf000;\r\nib->brx_ring [i].mblength = 0;\r\n}\r\nleptr = LANCE_ADDR(aib + libdesc_offset(brx_ring, 0));\r\nib->rx_len = (LANCE_LOG_RX_BUFFERS << 13) | (leptr >> 16);\r\nib->rx_ptr = leptr;\r\nleptr = LANCE_ADDR(aib + libdesc_offset(btx_ring, 0));\r\nib->tx_len = (LANCE_LOG_TX_BUFFERS << 13) | (leptr >> 16);\r\nib->tx_ptr = leptr;\r\n}\r\nstatic void lance_init_ring_pio(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nstruct lance_init_block __iomem *ib = lp->init_block_iomem;\r\nu32 leptr;\r\nint i;\r\nnetif_stop_queue(dev);\r\nlp->rx_new = lp->tx_new = 0;\r\nlp->rx_old = lp->tx_old = 0;\r\nsbus_writeb(dev->dev_addr[1], &ib->phys_addr[0]);\r\nsbus_writeb(dev->dev_addr[0], &ib->phys_addr[1]);\r\nsbus_writeb(dev->dev_addr[3], &ib->phys_addr[2]);\r\nsbus_writeb(dev->dev_addr[2], &ib->phys_addr[3]);\r\nsbus_writeb(dev->dev_addr[5], &ib->phys_addr[4]);\r\nsbus_writeb(dev->dev_addr[4], &ib->phys_addr[5]);\r\nfor (i = 0; i < TX_RING_SIZE; i++) {\r\nleptr = libbuff_offset(tx_buf, i);\r\nsbus_writew(leptr, &ib->btx_ring [i].tmd0);\r\nsbus_writeb(leptr >> 16,&ib->btx_ring [i].tmd1_hadr);\r\nsbus_writeb(0, &ib->btx_ring [i].tmd1_bits);\r\nsbus_writew(0xf000, &ib->btx_ring [i].length);\r\nsbus_writew(0, &ib->btx_ring [i].misc);\r\n}\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nleptr = libbuff_offset(rx_buf, i);\r\nsbus_writew(leptr, &ib->brx_ring [i].rmd0);\r\nsbus_writeb(leptr >> 16,&ib->brx_ring [i].rmd1_hadr);\r\nsbus_writeb(LE_R1_OWN, &ib->brx_ring [i].rmd1_bits);\r\nsbus_writew(-RX_BUFF_SIZE|0xf000,\r\n&ib->brx_ring [i].length);\r\nsbus_writew(0, &ib->brx_ring [i].mblength);\r\n}\r\nleptr = libdesc_offset(brx_ring, 0);\r\nsbus_writew((LANCE_LOG_RX_BUFFERS << 13) | (leptr >> 16),\r\n&ib->rx_len);\r\nsbus_writew(leptr, &ib->rx_ptr);\r\nleptr = libdesc_offset(btx_ring, 0);\r\nsbus_writew((LANCE_LOG_TX_BUFFERS << 13) | (leptr >> 16),\r\n&ib->tx_len);\r\nsbus_writew(leptr, &ib->tx_ptr);\r\n}\r\nstatic void init_restart_ledma(struct lance_private *lp)\r\n{\r\nu32 csr = sbus_readl(lp->dregs + DMA_CSR);\r\nif (!(csr & DMA_HNDL_ERROR)) {\r\nwhile (sbus_readl(lp->dregs + DMA_CSR) & DMA_FIFO_ISDRAIN)\r\nbarrier();\r\n}\r\ncsr = sbus_readl(lp->dregs + DMA_CSR);\r\ncsr &= ~DMA_E_BURSTS;\r\nif (lp->burst_sizes & DMA_BURST32)\r\ncsr |= DMA_E_BURST32;\r\nelse\r\ncsr |= DMA_E_BURST16;\r\ncsr |= (DMA_DSBL_RD_DRN | DMA_DSBL_WR_INV | DMA_FIFO_INV);\r\nif (lp->tpe)\r\ncsr |= DMA_EN_ENETAUI;\r\nelse\r\ncsr &= ~DMA_EN_ENETAUI;\r\nudelay(20);\r\nsbus_writel(csr, lp->dregs + DMA_CSR);\r\nudelay(200);\r\n}\r\nstatic int init_restart_lance(struct lance_private *lp)\r\n{\r\nu16 regval = 0;\r\nint i;\r\nif (lp->dregs)\r\ninit_restart_ledma(lp);\r\nsbus_writew(LE_CSR0, lp->lregs + RAP);\r\nsbus_writew(LE_C0_INIT, lp->lregs + RDP);\r\nfor (i = 0; i < 100; i++) {\r\nregval = sbus_readw(lp->lregs + RDP);\r\nif (regval & (LE_C0_ERR | LE_C0_IDON))\r\nbreak;\r\nbarrier();\r\n}\r\nif (i == 100 || (regval & LE_C0_ERR)) {\r\nprintk(KERN_ERR "LANCE unopened after %d ticks, csr0=%4.4x.\n",\r\ni, regval);\r\nif (lp->dregs)\r\nprintk("dcsr=%8.8x\n", sbus_readl(lp->dregs + DMA_CSR));\r\nreturn -1;\r\n}\r\nsbus_writew(LE_C0_IDON, lp->lregs + RDP);\r\nsbus_writew(LE_C0_INEA | LE_C0_STRT, lp->lregs + RDP);\r\nif (lp->dregs) {\r\nu32 csr = sbus_readl(lp->dregs + DMA_CSR);\r\ncsr |= DMA_INT_ENAB;\r\nsbus_writel(csr, lp->dregs + DMA_CSR);\r\n}\r\nreturn 0;\r\n}\r\nstatic void lance_rx_dvma(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nstruct lance_init_block *ib = lp->init_block_mem;\r\nstruct lance_rx_desc *rd;\r\nu8 bits;\r\nint len, entry = lp->rx_new;\r\nstruct sk_buff *skb;\r\nfor (rd = &ib->brx_ring [entry];\r\n!((bits = rd->rmd1_bits) & LE_R1_OWN);\r\nrd = &ib->brx_ring [entry]) {\r\nif ((bits & LE_R1_POK) != LE_R1_POK) {\r\ndev->stats.rx_over_errors++;\r\ndev->stats.rx_errors++;\r\n} else if (bits & LE_R1_ERR) {\r\nif (bits & LE_R1_BUF) dev->stats.rx_fifo_errors++;\r\nif (bits & LE_R1_CRC) dev->stats.rx_crc_errors++;\r\nif (bits & LE_R1_OFL) dev->stats.rx_over_errors++;\r\nif (bits & LE_R1_FRA) dev->stats.rx_frame_errors++;\r\nif (bits & LE_R1_EOP) dev->stats.rx_errors++;\r\n} else {\r\nlen = (rd->mblength & 0xfff) - 4;\r\nskb = netdev_alloc_skb(dev, len + 2);\r\nif (skb == NULL) {\r\ndev->stats.rx_dropped++;\r\nrd->mblength = 0;\r\nrd->rmd1_bits = LE_R1_OWN;\r\nlp->rx_new = RX_NEXT(entry);\r\nreturn;\r\n}\r\ndev->stats.rx_bytes += len;\r\nskb_reserve(skb, 2);\r\nskb_put(skb, len);\r\nskb_copy_to_linear_data(skb,\r\n(unsigned char *)&(ib->rx_buf [entry][0]),\r\nlen);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\n}\r\nrd->mblength = 0;\r\nrd->rmd1_bits = LE_R1_OWN;\r\nentry = RX_NEXT(entry);\r\n}\r\nlp->rx_new = entry;\r\n}\r\nstatic void lance_tx_dvma(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nstruct lance_init_block *ib = lp->init_block_mem;\r\nint i, j;\r\nspin_lock(&lp->lock);\r\nj = lp->tx_old;\r\nfor (i = j; i != lp->tx_new; i = j) {\r\nstruct lance_tx_desc *td = &ib->btx_ring [i];\r\nu8 bits = td->tmd1_bits;\r\nif (bits & LE_T1_OWN)\r\nbreak;\r\nif (bits & LE_T1_ERR) {\r\nu16 status = td->misc;\r\ndev->stats.tx_errors++;\r\nif (status & LE_T3_RTY) dev->stats.tx_aborted_errors++;\r\nif (status & LE_T3_LCOL) dev->stats.tx_window_errors++;\r\nif (status & LE_T3_CLOS) {\r\ndev->stats.tx_carrier_errors++;\r\nif (lp->auto_select) {\r\nlp->tpe = 1 - lp->tpe;\r\nprintk(KERN_NOTICE "%s: Carrier Lost, trying %s\n",\r\ndev->name, lp->tpe?"TPE":"AUI");\r\nSTOP_LANCE(lp);\r\nlp->init_ring(dev);\r\nload_csrs(lp);\r\ninit_restart_lance(lp);\r\ngoto out;\r\n}\r\n}\r\nif (status & (LE_T3_BUF|LE_T3_UFL)) {\r\ndev->stats.tx_fifo_errors++;\r\nprintk(KERN_ERR "%s: Tx: ERR_BUF|ERR_UFL, restarting\n",\r\ndev->name);\r\nSTOP_LANCE(lp);\r\nlp->init_ring(dev);\r\nload_csrs(lp);\r\ninit_restart_lance(lp);\r\ngoto out;\r\n}\r\n} else if ((bits & LE_T1_POK) == LE_T1_POK) {\r\ntd->tmd1_bits = bits & ~(LE_T1_POK);\r\nif (bits & LE_T1_EONE)\r\ndev->stats.collisions++;\r\nif (bits & LE_T1_EMORE)\r\ndev->stats.collisions += 2;\r\ndev->stats.tx_packets++;\r\n}\r\nj = TX_NEXT(j);\r\n}\r\nlp->tx_old = j;\r\nout:\r\nif (netif_queue_stopped(dev) &&\r\nTX_BUFFS_AVAIL > 0)\r\nnetif_wake_queue(dev);\r\nspin_unlock(&lp->lock);\r\n}\r\nstatic void lance_piocopy_to_skb(struct sk_buff *skb, void __iomem *piobuf, int len)\r\n{\r\nu16 *p16 = (u16 *) skb->data;\r\nu32 *p32;\r\nu8 *p8;\r\nvoid __iomem *pbuf = piobuf;\r\n*p16++ = sbus_readw(pbuf);\r\np32 = (u32 *) p16;\r\npbuf += 2;\r\nlen -= 2;\r\nwhile (len >= 4) {\r\n*p32++ = sbus_readl(pbuf);\r\npbuf += 4;\r\nlen -= 4;\r\n}\r\np8 = (u8 *) p32;\r\nif (len >= 2) {\r\np16 = (u16 *) p32;\r\n*p16++ = sbus_readw(pbuf);\r\npbuf += 2;\r\nlen -= 2;\r\np8 = (u8 *) p16;\r\n}\r\nif (len >= 1)\r\n*p8 = sbus_readb(pbuf);\r\n}\r\nstatic void lance_rx_pio(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nstruct lance_init_block __iomem *ib = lp->init_block_iomem;\r\nstruct lance_rx_desc __iomem *rd;\r\nunsigned char bits;\r\nint len, entry;\r\nstruct sk_buff *skb;\r\nentry = lp->rx_new;\r\nfor (rd = &ib->brx_ring [entry];\r\n!((bits = sbus_readb(&rd->rmd1_bits)) & LE_R1_OWN);\r\nrd = &ib->brx_ring [entry]) {\r\nif ((bits & LE_R1_POK) != LE_R1_POK) {\r\ndev->stats.rx_over_errors++;\r\ndev->stats.rx_errors++;\r\n} else if (bits & LE_R1_ERR) {\r\nif (bits & LE_R1_BUF) dev->stats.rx_fifo_errors++;\r\nif (bits & LE_R1_CRC) dev->stats.rx_crc_errors++;\r\nif (bits & LE_R1_OFL) dev->stats.rx_over_errors++;\r\nif (bits & LE_R1_FRA) dev->stats.rx_frame_errors++;\r\nif (bits & LE_R1_EOP) dev->stats.rx_errors++;\r\n} else {\r\nlen = (sbus_readw(&rd->mblength) & 0xfff) - 4;\r\nskb = netdev_alloc_skb(dev, len + 2);\r\nif (skb == NULL) {\r\ndev->stats.rx_dropped++;\r\nsbus_writew(0, &rd->mblength);\r\nsbus_writeb(LE_R1_OWN, &rd->rmd1_bits);\r\nlp->rx_new = RX_NEXT(entry);\r\nreturn;\r\n}\r\ndev->stats.rx_bytes += len;\r\nskb_reserve (skb, 2);\r\nskb_put(skb, len);\r\nlance_piocopy_to_skb(skb, &(ib->rx_buf[entry][0]), len);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\n}\r\nsbus_writew(0, &rd->mblength);\r\nsbus_writeb(LE_R1_OWN, &rd->rmd1_bits);\r\nentry = RX_NEXT(entry);\r\n}\r\nlp->rx_new = entry;\r\n}\r\nstatic void lance_tx_pio(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nstruct lance_init_block __iomem *ib = lp->init_block_iomem;\r\nint i, j;\r\nspin_lock(&lp->lock);\r\nj = lp->tx_old;\r\nfor (i = j; i != lp->tx_new; i = j) {\r\nstruct lance_tx_desc __iomem *td = &ib->btx_ring [i];\r\nu8 bits = sbus_readb(&td->tmd1_bits);\r\nif (bits & LE_T1_OWN)\r\nbreak;\r\nif (bits & LE_T1_ERR) {\r\nu16 status = sbus_readw(&td->misc);\r\ndev->stats.tx_errors++;\r\nif (status & LE_T3_RTY) dev->stats.tx_aborted_errors++;\r\nif (status & LE_T3_LCOL) dev->stats.tx_window_errors++;\r\nif (status & LE_T3_CLOS) {\r\ndev->stats.tx_carrier_errors++;\r\nif (lp->auto_select) {\r\nlp->tpe = 1 - lp->tpe;\r\nprintk(KERN_NOTICE "%s: Carrier Lost, trying %s\n",\r\ndev->name, lp->tpe?"TPE":"AUI");\r\nSTOP_LANCE(lp);\r\nlp->init_ring(dev);\r\nload_csrs(lp);\r\ninit_restart_lance(lp);\r\ngoto out;\r\n}\r\n}\r\nif (status & (LE_T3_BUF|LE_T3_UFL)) {\r\ndev->stats.tx_fifo_errors++;\r\nprintk(KERN_ERR "%s: Tx: ERR_BUF|ERR_UFL, restarting\n",\r\ndev->name);\r\nSTOP_LANCE(lp);\r\nlp->init_ring(dev);\r\nload_csrs(lp);\r\ninit_restart_lance(lp);\r\ngoto out;\r\n}\r\n} else if ((bits & LE_T1_POK) == LE_T1_POK) {\r\nsbus_writeb(bits & ~(LE_T1_POK), &td->tmd1_bits);\r\nif (bits & LE_T1_EONE)\r\ndev->stats.collisions++;\r\nif (bits & LE_T1_EMORE)\r\ndev->stats.collisions += 2;\r\ndev->stats.tx_packets++;\r\n}\r\nj = TX_NEXT(j);\r\n}\r\nlp->tx_old = j;\r\nif (netif_queue_stopped(dev) &&\r\nTX_BUFFS_AVAIL > 0)\r\nnetif_wake_queue(dev);\r\nout:\r\nspin_unlock(&lp->lock);\r\n}\r\nstatic irqreturn_t lance_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct lance_private *lp = netdev_priv(dev);\r\nint csr0;\r\nsbus_writew(LE_CSR0, lp->lregs + RAP);\r\ncsr0 = sbus_readw(lp->lregs + RDP);\r\nsbus_writew(csr0 & (LE_C0_INTR | LE_C0_TINT | LE_C0_RINT),\r\nlp->lregs + RDP);\r\nif ((csr0 & LE_C0_ERR) != 0) {\r\nsbus_writew((LE_C0_BABL | LE_C0_ERR | LE_C0_MISS |\r\nLE_C0_CERR | LE_C0_MERR),\r\nlp->lregs + RDP);\r\n}\r\nif (csr0 & LE_C0_RINT)\r\nlp->rx(dev);\r\nif (csr0 & LE_C0_TINT)\r\nlp->tx(dev);\r\nif (csr0 & LE_C0_BABL)\r\ndev->stats.tx_errors++;\r\nif (csr0 & LE_C0_MISS)\r\ndev->stats.rx_errors++;\r\nif (csr0 & LE_C0_MERR) {\r\nif (lp->dregs) {\r\nu32 addr = sbus_readl(lp->dregs + DMA_ADDR);\r\nprintk(KERN_ERR "%s: Memory error, status %04x, addr %06x\n",\r\ndev->name, csr0, addr & 0xffffff);\r\n} else {\r\nprintk(KERN_ERR "%s: Memory error, status %04x\n",\r\ndev->name, csr0);\r\n}\r\nsbus_writew(LE_C0_STOP, lp->lregs + RDP);\r\nif (lp->dregs) {\r\nu32 dma_csr = sbus_readl(lp->dregs + DMA_CSR);\r\ndma_csr |= DMA_FIFO_INV;\r\nsbus_writel(dma_csr, lp->dregs + DMA_CSR);\r\n}\r\nlp->init_ring(dev);\r\nload_csrs(lp);\r\ninit_restart_lance(lp);\r\nnetif_wake_queue(dev);\r\n}\r\nsbus_writew(LE_C0_INEA, lp->lregs + RDP);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void build_fake_packet(struct lance_private *lp)\r\n{\r\nstruct net_device *dev = lp->dev;\r\nint i, entry;\r\nentry = lp->tx_new & TX_RING_MOD_MASK;\r\nif (lp->pio_buffer) {\r\nstruct lance_init_block __iomem *ib = lp->init_block_iomem;\r\nu16 __iomem *packet = (u16 __iomem *) &(ib->tx_buf[entry][0]);\r\nstruct ethhdr __iomem *eth = (struct ethhdr __iomem *) packet;\r\nfor (i = 0; i < (ETH_ZLEN / sizeof(u16)); i++)\r\nsbus_writew(0, &packet[i]);\r\nfor (i = 0; i < 6; i++) {\r\nsbus_writeb(dev->dev_addr[i], &eth->h_dest[i]);\r\nsbus_writeb(dev->dev_addr[i], &eth->h_source[i]);\r\n}\r\nsbus_writew((-ETH_ZLEN) | 0xf000, &ib->btx_ring[entry].length);\r\nsbus_writew(0, &ib->btx_ring[entry].misc);\r\nsbus_writeb(LE_T1_POK|LE_T1_OWN, &ib->btx_ring[entry].tmd1_bits);\r\n} else {\r\nstruct lance_init_block *ib = lp->init_block_mem;\r\nu16 *packet = (u16 *) &(ib->tx_buf[entry][0]);\r\nstruct ethhdr *eth = (struct ethhdr *) packet;\r\nmemset(packet, 0, ETH_ZLEN);\r\nfor (i = 0; i < 6; i++) {\r\neth->h_dest[i] = dev->dev_addr[i];\r\neth->h_source[i] = dev->dev_addr[i];\r\n}\r\nib->btx_ring[entry].length = (-ETH_ZLEN) | 0xf000;\r\nib->btx_ring[entry].misc = 0;\r\nib->btx_ring[entry].tmd1_bits = (LE_T1_POK|LE_T1_OWN);\r\n}\r\nlp->tx_new = TX_NEXT(entry);\r\n}\r\nstatic int lance_open(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nint status = 0;\r\nSTOP_LANCE(lp);\r\nif (request_irq(dev->irq, lance_interrupt, IRQF_SHARED,\r\nlancestr, (void *) dev)) {\r\nprintk(KERN_ERR "Lance: Can't get irq %d\n", dev->irq);\r\nreturn -EAGAIN;\r\n}\r\nif (lp->dregs) {\r\nu32 regval = lp->init_block_dvma & 0xff000000;\r\nsbus_writel(regval, lp->dregs + DMA_TEST);\r\n}\r\nif (lp->pio_buffer) {\r\nstruct lance_init_block __iomem *ib = lp->init_block_iomem;\r\nsbus_writew(0, &ib->mode);\r\nsbus_writel(0, &ib->filter[0]);\r\nsbus_writel(0, &ib->filter[1]);\r\n} else {\r\nstruct lance_init_block *ib = lp->init_block_mem;\r\nib->mode = 0;\r\nib->filter [0] = 0;\r\nib->filter [1] = 0;\r\n}\r\nlp->init_ring(dev);\r\nload_csrs(lp);\r\nnetif_start_queue(dev);\r\nstatus = init_restart_lance(lp);\r\nif (!status && lp->auto_select) {\r\nbuild_fake_packet(lp);\r\nsbus_writew(LE_C0_INEA | LE_C0_TDMD, lp->lregs + RDP);\r\n}\r\nreturn status;\r\n}\r\nstatic int lance_close(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\ndel_timer_sync(&lp->multicast_timer);\r\nSTOP_LANCE(lp);\r\nfree_irq(dev->irq, (void *) dev);\r\nreturn 0;\r\n}\r\nstatic int lance_reset(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nint status;\r\nSTOP_LANCE(lp);\r\nif (lp->dregs) {\r\nu32 csr, addr;\r\nprintk(KERN_ERR "resetting ledma\n");\r\ncsr = sbus_readl(lp->dregs + DMA_CSR);\r\nsbus_writel(csr | DMA_RST_ENET, lp->dregs + DMA_CSR);\r\nudelay(200);\r\nsbus_writel(csr & ~DMA_RST_ENET, lp->dregs + DMA_CSR);\r\naddr = lp->init_block_dvma & 0xff000000;\r\nsbus_writel(addr, lp->dregs + DMA_TEST);\r\n}\r\nlp->init_ring(dev);\r\nload_csrs(lp);\r\nnetif_trans_update(dev);\r\nstatus = init_restart_lance(lp);\r\nreturn status;\r\n}\r\nstatic void lance_piocopy_from_skb(void __iomem *dest, unsigned char *src, int len)\r\n{\r\nvoid __iomem *piobuf = dest;\r\nu32 *p32;\r\nu16 *p16;\r\nu8 *p8;\r\nswitch ((unsigned long)src & 0x3) {\r\ncase 0:\r\np32 = (u32 *) src;\r\nwhile (len >= 4) {\r\nsbus_writel(*p32, piobuf);\r\np32++;\r\npiobuf += 4;\r\nlen -= 4;\r\n}\r\nsrc = (char *) p32;\r\nbreak;\r\ncase 1:\r\ncase 3:\r\np8 = (u8 *) src;\r\nwhile (len >= 4) {\r\nu32 val;\r\nval = p8[0] << 24;\r\nval |= p8[1] << 16;\r\nval |= p8[2] << 8;\r\nval |= p8[3];\r\nsbus_writel(val, piobuf);\r\np8 += 4;\r\npiobuf += 4;\r\nlen -= 4;\r\n}\r\nsrc = (char *) p8;\r\nbreak;\r\ncase 2:\r\np16 = (u16 *) src;\r\nwhile (len >= 4) {\r\nu32 val = p16[0]<<16 | p16[1];\r\nsbus_writel(val, piobuf);\r\np16 += 2;\r\npiobuf += 4;\r\nlen -= 4;\r\n}\r\nsrc = (char *) p16;\r\nbreak;\r\n}\r\nif (len >= 2) {\r\nu16 val = src[0] << 8 | src[1];\r\nsbus_writew(val, piobuf);\r\nsrc += 2;\r\npiobuf += 2;\r\nlen -= 2;\r\n}\r\nif (len >= 1)\r\nsbus_writeb(src[0], piobuf);\r\n}\r\nstatic void lance_piozero(void __iomem *dest, int len)\r\n{\r\nvoid __iomem *piobuf = dest;\r\nif ((unsigned long)piobuf & 1) {\r\nsbus_writeb(0, piobuf);\r\npiobuf += 1;\r\nlen -= 1;\r\nif (len == 0)\r\nreturn;\r\n}\r\nif (len == 1) {\r\nsbus_writeb(0, piobuf);\r\nreturn;\r\n}\r\nif ((unsigned long)piobuf & 2) {\r\nsbus_writew(0, piobuf);\r\npiobuf += 2;\r\nlen -= 2;\r\nif (len == 0)\r\nreturn;\r\n}\r\nwhile (len >= 4) {\r\nsbus_writel(0, piobuf);\r\npiobuf += 4;\r\nlen -= 4;\r\n}\r\nif (len >= 2) {\r\nsbus_writew(0, piobuf);\r\npiobuf += 2;\r\nlen -= 2;\r\n}\r\nif (len >= 1)\r\nsbus_writeb(0, piobuf);\r\n}\r\nstatic void lance_tx_timeout(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nprintk(KERN_ERR "%s: transmit timed out, status %04x, reset\n",\r\ndev->name, sbus_readw(lp->lregs + RDP));\r\nlance_reset(dev);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int lance_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nint entry, skblen, len;\r\nskblen = skb->len;\r\nlen = (skblen <= ETH_ZLEN) ? ETH_ZLEN : skblen;\r\nspin_lock_irq(&lp->lock);\r\ndev->stats.tx_bytes += len;\r\nentry = lp->tx_new & TX_RING_MOD_MASK;\r\nif (lp->pio_buffer) {\r\nstruct lance_init_block __iomem *ib = lp->init_block_iomem;\r\nsbus_writew((-len) | 0xf000, &ib->btx_ring[entry].length);\r\nsbus_writew(0, &ib->btx_ring[entry].misc);\r\nlance_piocopy_from_skb(&ib->tx_buf[entry][0], skb->data, skblen);\r\nif (len != skblen)\r\nlance_piozero(&ib->tx_buf[entry][skblen], len - skblen);\r\nsbus_writeb(LE_T1_POK | LE_T1_OWN, &ib->btx_ring[entry].tmd1_bits);\r\n} else {\r\nstruct lance_init_block *ib = lp->init_block_mem;\r\nib->btx_ring [entry].length = (-len) | 0xf000;\r\nib->btx_ring [entry].misc = 0;\r\nskb_copy_from_linear_data(skb, &ib->tx_buf [entry][0], skblen);\r\nif (len != skblen)\r\nmemset((char *) &ib->tx_buf [entry][skblen], 0, len - skblen);\r\nib->btx_ring [entry].tmd1_bits = (LE_T1_POK | LE_T1_OWN);\r\n}\r\nlp->tx_new = TX_NEXT(entry);\r\nif (TX_BUFFS_AVAIL <= 0)\r\nnetif_stop_queue(dev);\r\nsbus_writew(LE_C0_INEA | LE_C0_TDMD, lp->lregs + RDP);\r\nif (lp->dregs)\r\nsbus_readw(lp->lregs + RDP);\r\nspin_unlock_irq(&lp->lock);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void lance_load_multicast(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nstruct netdev_hw_addr *ha;\r\nu32 crc;\r\nu32 val;\r\nif (dev->flags & IFF_ALLMULTI)\r\nval = ~0;\r\nelse\r\nval = 0;\r\nif (lp->pio_buffer) {\r\nstruct lance_init_block __iomem *ib = lp->init_block_iomem;\r\nsbus_writel(val, &ib->filter[0]);\r\nsbus_writel(val, &ib->filter[1]);\r\n} else {\r\nstruct lance_init_block *ib = lp->init_block_mem;\r\nib->filter [0] = val;\r\nib->filter [1] = val;\r\n}\r\nif (dev->flags & IFF_ALLMULTI)\r\nreturn;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\ncrc = ether_crc_le(6, ha->addr);\r\ncrc = crc >> 26;\r\nif (lp->pio_buffer) {\r\nstruct lance_init_block __iomem *ib = lp->init_block_iomem;\r\nu16 __iomem *mcast_table = (u16 __iomem *) &ib->filter;\r\nu16 tmp = sbus_readw(&mcast_table[crc>>4]);\r\ntmp |= 1 << (crc & 0xf);\r\nsbus_writew(tmp, &mcast_table[crc>>4]);\r\n} else {\r\nstruct lance_init_block *ib = lp->init_block_mem;\r\nu16 *mcast_table = (u16 *) &ib->filter;\r\nmcast_table [crc >> 4] |= 1 << (crc & 0xf);\r\n}\r\n}\r\n}\r\nstatic void lance_set_multicast(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nstruct lance_init_block *ib_mem = lp->init_block_mem;\r\nstruct lance_init_block __iomem *ib_iomem = lp->init_block_iomem;\r\nu16 mode;\r\nif (!netif_running(dev))\r\nreturn;\r\nif (lp->tx_old != lp->tx_new) {\r\nmod_timer(&lp->multicast_timer, jiffies + 4);\r\nnetif_wake_queue(dev);\r\nreturn;\r\n}\r\nnetif_stop_queue(dev);\r\nSTOP_LANCE(lp);\r\nlp->init_ring(dev);\r\nif (lp->pio_buffer)\r\nmode = sbus_readw(&ib_iomem->mode);\r\nelse\r\nmode = ib_mem->mode;\r\nif (dev->flags & IFF_PROMISC) {\r\nmode |= LE_MO_PROM;\r\nif (lp->pio_buffer)\r\nsbus_writew(mode, &ib_iomem->mode);\r\nelse\r\nib_mem->mode = mode;\r\n} else {\r\nmode &= ~LE_MO_PROM;\r\nif (lp->pio_buffer)\r\nsbus_writew(mode, &ib_iomem->mode);\r\nelse\r\nib_mem->mode = mode;\r\nlance_load_multicast(dev);\r\n}\r\nload_csrs(lp);\r\ninit_restart_lance(lp);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void lance_set_multicast_retry(unsigned long _opaque)\r\n{\r\nstruct net_device *dev = (struct net_device *) _opaque;\r\nlance_set_multicast(dev);\r\n}\r\nstatic void lance_free_hwresources(struct lance_private *lp)\r\n{\r\nif (lp->lregs)\r\nof_iounmap(&lp->op->resource[0], lp->lregs, LANCE_REG_SIZE);\r\nif (lp->dregs) {\r\nstruct platform_device *ledma = lp->ledma;\r\nof_iounmap(&ledma->resource[0], lp->dregs,\r\nresource_size(&ledma->resource[0]));\r\n}\r\nif (lp->init_block_iomem) {\r\nof_iounmap(&lp->lebuffer->resource[0], lp->init_block_iomem,\r\nsizeof(struct lance_init_block));\r\n} else if (lp->init_block_mem) {\r\ndma_free_coherent(&lp->op->dev,\r\nsizeof(struct lance_init_block),\r\nlp->init_block_mem,\r\nlp->init_block_dvma);\r\n}\r\n}\r\nstatic void sparc_lance_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, "sunlance", sizeof(info->driver));\r\nstrlcpy(info->version, "2.02", sizeof(info->version));\r\n}\r\nstatic int sparc_lance_probe_one(struct platform_device *op,\r\nstruct platform_device *ledma,\r\nstruct platform_device *lebuffer)\r\n{\r\nstruct device_node *dp = op->dev.of_node;\r\nstatic unsigned version_printed;\r\nstruct lance_private *lp;\r\nstruct net_device *dev;\r\nint i;\r\ndev = alloc_etherdev(sizeof(struct lance_private) + 8);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nlp = netdev_priv(dev);\r\nif (sparc_lance_debug && version_printed++ == 0)\r\nprintk (KERN_INFO "%s", version);\r\nspin_lock_init(&lp->lock);\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = idprom->id_ethaddr[i];\r\nlp->lregs = of_ioremap(&op->resource[0], 0,\r\nLANCE_REG_SIZE, lancestr);\r\nif (!lp->lregs) {\r\nprintk(KERN_ERR "SunLance: Cannot map registers.\n");\r\ngoto fail;\r\n}\r\nlp->ledma = ledma;\r\nif (lp->ledma) {\r\nlp->dregs = of_ioremap(&ledma->resource[0], 0,\r\nresource_size(&ledma->resource[0]),\r\n"ledma");\r\nif (!lp->dregs) {\r\nprintk(KERN_ERR "SunLance: Cannot map "\r\n"ledma registers.\n");\r\ngoto fail;\r\n}\r\n}\r\nlp->op = op;\r\nlp->lebuffer = lebuffer;\r\nif (lebuffer) {\r\nif (lebuffer->resource[0].start & 7) {\r\nprintk(KERN_ERR "SunLance: ERROR: Rx and Tx rings not on even boundary.\n");\r\ngoto fail;\r\n}\r\nlp->init_block_iomem =\r\nof_ioremap(&lebuffer->resource[0], 0,\r\nsizeof(struct lance_init_block), "lebuffer");\r\nif (!lp->init_block_iomem) {\r\nprintk(KERN_ERR "SunLance: Cannot map PIO buffer.\n");\r\ngoto fail;\r\n}\r\nlp->init_block_dvma = 0;\r\nlp->pio_buffer = 1;\r\nlp->init_ring = lance_init_ring_pio;\r\nlp->rx = lance_rx_pio;\r\nlp->tx = lance_tx_pio;\r\n} else {\r\nlp->init_block_mem =\r\ndma_alloc_coherent(&op->dev,\r\nsizeof(struct lance_init_block),\r\n&lp->init_block_dvma, GFP_ATOMIC);\r\nif (!lp->init_block_mem)\r\ngoto fail;\r\nlp->pio_buffer = 0;\r\nlp->init_ring = lance_init_ring_dvma;\r\nlp->rx = lance_rx_dvma;\r\nlp->tx = lance_tx_dvma;\r\n}\r\nlp->busmaster_regval = of_getintprop_default(dp, "busmaster-regval",\r\n(LE_C3_BSWP |\r\nLE_C3_ACON |\r\nLE_C3_BCON));\r\nlp->name = lancestr;\r\nlp->burst_sizes = 0;\r\nif (lp->ledma) {\r\nstruct device_node *ledma_dp = ledma->dev.of_node;\r\nstruct device_node *sbus_dp;\r\nunsigned int sbmask;\r\nconst char *prop;\r\nu32 csr;\r\nlp->burst_sizes = of_getintprop_default(ledma_dp,\r\n"burst-sizes", 0);\r\nsbus_dp = ledma_dp->parent;\r\nsbmask = of_getintprop_default(sbus_dp, "burst-sizes",\r\nDMA_BURSTBITS);\r\nlp->burst_sizes &= sbmask;\r\nprop = of_get_property(ledma_dp, "cable-selection", NULL);\r\nif (!prop || prop[0] == '\0') {\r\nstruct device_node *nd;\r\nprintk(KERN_INFO "SunLance: using "\r\n"auto-carrier-detection.\n");\r\nnd = of_find_node_by_path("/options");\r\nif (!nd)\r\ngoto no_link_test;\r\nprop = of_get_property(nd, "tpe-link-test?", NULL);\r\nif (!prop)\r\ngoto no_link_test;\r\nif (strcmp(prop, "true")) {\r\nprintk(KERN_NOTICE "SunLance: warning: overriding option "\r\n"'tpe-link-test?'\n");\r\nprintk(KERN_NOTICE "SunLance: warning: mail any problems "\r\n"to ecd@skynet.be\n");\r\nauxio_set_lte(AUXIO_LTE_ON);\r\n}\r\nno_link_test:\r\nlp->auto_select = 1;\r\nlp->tpe = 0;\r\n} else if (!strcmp(prop, "aui")) {\r\nlp->auto_select = 0;\r\nlp->tpe = 0;\r\n} else {\r\nlp->auto_select = 0;\r\nlp->tpe = 1;\r\n}\r\ncsr = sbus_readl(lp->dregs + DMA_CSR);\r\nsbus_writel(csr | DMA_RST_ENET, lp->dregs + DMA_CSR);\r\nudelay(200);\r\nsbus_writel(csr & ~DMA_RST_ENET, lp->dregs + DMA_CSR);\r\n} else\r\nlp->dregs = NULL;\r\nlp->dev = dev;\r\nSET_NETDEV_DEV(dev, &op->dev);\r\ndev->watchdog_timeo = 5*HZ;\r\ndev->ethtool_ops = &sparc_lance_ethtool_ops;\r\ndev->netdev_ops = &sparc_lance_ops;\r\ndev->irq = op->archdata.irqs[0];\r\ninit_timer(&lp->multicast_timer);\r\nlp->multicast_timer.data = (unsigned long) dev;\r\nlp->multicast_timer.function = lance_set_multicast_retry;\r\nif (register_netdev(dev)) {\r\nprintk(KERN_ERR "SunLance: Cannot register device.\n");\r\ngoto fail;\r\n}\r\nplatform_set_drvdata(op, lp);\r\nprintk(KERN_INFO "%s: LANCE %pM\n",\r\ndev->name, dev->dev_addr);\r\nreturn 0;\r\nfail:\r\nlance_free_hwresources(lp);\r\nfree_netdev(dev);\r\nreturn -ENODEV;\r\n}\r\nstatic int sunlance_sbus_probe(struct platform_device *op)\r\n{\r\nstruct platform_device *parent = to_platform_device(op->dev.parent);\r\nstruct device_node *parent_dp = parent->dev.of_node;\r\nint err;\r\nif (!strcmp(parent_dp->name, "ledma")) {\r\nerr = sparc_lance_probe_one(op, parent, NULL);\r\n} else if (!strcmp(parent_dp->name, "lebuffer")) {\r\nerr = sparc_lance_probe_one(op, NULL, parent);\r\n} else\r\nerr = sparc_lance_probe_one(op, NULL, NULL);\r\nreturn err;\r\n}\r\nstatic int sunlance_sbus_remove(struct platform_device *op)\r\n{\r\nstruct lance_private *lp = platform_get_drvdata(op);\r\nstruct net_device *net_dev = lp->dev;\r\nunregister_netdev(net_dev);\r\nlance_free_hwresources(lp);\r\nfree_netdev(net_dev);\r\nreturn 0;\r\n}
