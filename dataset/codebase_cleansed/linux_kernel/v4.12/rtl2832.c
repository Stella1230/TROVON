static int rtl2832_rd_demod_reg(struct rtl2832_dev *dev, int reg, u32 *val)\r\n{\r\nstruct i2c_client *client = dev->client;\r\nint ret, i;\r\nu16 reg_start_addr;\r\nu8 msb, lsb, reading[4], len;\r\nu32 reading_tmp, mask;\r\nreg_start_addr = registers[reg].start_address;\r\nmsb = registers[reg].msb;\r\nlsb = registers[reg].lsb;\r\nlen = (msb >> 3) + 1;\r\nmask = REG_MASK(msb - lsb);\r\nret = regmap_bulk_read(dev->regmap, reg_start_addr, reading, len);\r\nif (ret)\r\ngoto err;\r\nreading_tmp = 0;\r\nfor (i = 0; i < len; i++)\r\nreading_tmp |= reading[i] << ((len - 1 - i) * 8);\r\n*val = (reading_tmp >> lsb) & mask;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832_wr_demod_reg(struct rtl2832_dev *dev, int reg, u32 val)\r\n{\r\nstruct i2c_client *client = dev->client;\r\nint ret, i;\r\nu16 reg_start_addr;\r\nu8 msb, lsb, reading[4], writing[4], len;\r\nu32 reading_tmp, writing_tmp, mask;\r\nreg_start_addr = registers[reg].start_address;\r\nmsb = registers[reg].msb;\r\nlsb = registers[reg].lsb;\r\nlen = (msb >> 3) + 1;\r\nmask = REG_MASK(msb - lsb);\r\nret = regmap_bulk_read(dev->regmap, reg_start_addr, reading, len);\r\nif (ret)\r\ngoto err;\r\nreading_tmp = 0;\r\nfor (i = 0; i < len; i++)\r\nreading_tmp |= reading[i] << ((len - 1 - i) * 8);\r\nwriting_tmp = reading_tmp & ~(mask << lsb);\r\nwriting_tmp |= ((val & mask) << lsb);\r\nfor (i = 0; i < len; i++)\r\nwriting[i] = (writing_tmp >> ((len - 1 - i) * 8)) & 0xff;\r\nret = regmap_bulk_write(dev->regmap, reg_start_addr, writing, len);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832_set_if(struct dvb_frontend *fe, u32 if_freq)\r\n{\r\nstruct rtl2832_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\nu64 pset_iffreq;\r\nu8 en_bbin = (if_freq == 0 ? 0x1 : 0x0);\r\npset_iffreq = if_freq % dev->pdata->clk;\r\npset_iffreq *= 0x400000;\r\npset_iffreq = div_u64(pset_iffreq, dev->pdata->clk);\r\npset_iffreq = -pset_iffreq;\r\npset_iffreq = pset_iffreq & 0x3fffff;\r\ndev_dbg(&client->dev, "if_frequency=%d pset_iffreq=%08x\n",\r\nif_freq, (unsigned)pset_iffreq);\r\nret = rtl2832_wr_demod_reg(dev, DVBT_EN_BBIN, en_bbin);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_wr_demod_reg(dev, DVBT_PSET_IFFREQ, pset_iffreq);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832_init(struct dvb_frontend *fe)\r\n{\r\nstruct rtl2832_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nstruct dtv_frontend_properties *c = &dev->fe.dtv_property_cache;\r\nconst struct rtl2832_reg_value *init;\r\nint i, ret, len;\r\nstruct rtl2832_reg_value rtl2832_initial_regs[] = {\r\n{DVBT_AD_EN_REG, 0x1},\r\n{DVBT_AD_EN_REG1, 0x1},\r\n{DVBT_RSD_BER_FAIL_VAL, 0x2800},\r\n{DVBT_MGD_THD0, 0x10},\r\n{DVBT_MGD_THD1, 0x20},\r\n{DVBT_MGD_THD2, 0x20},\r\n{DVBT_MGD_THD3, 0x40},\r\n{DVBT_MGD_THD4, 0x22},\r\n{DVBT_MGD_THD5, 0x32},\r\n{DVBT_MGD_THD6, 0x37},\r\n{DVBT_MGD_THD7, 0x39},\r\n{DVBT_EN_BK_TRK, 0x0},\r\n{DVBT_EN_CACQ_NOTCH, 0x0},\r\n{DVBT_AD_AV_REF, 0x2a},\r\n{DVBT_REG_PI, 0x6},\r\n{DVBT_PIP_ON, 0x0},\r\n{DVBT_CDIV_PH0, 0x8},\r\n{DVBT_CDIV_PH1, 0x8},\r\n{DVBT_SCALE1_B92, 0x4},\r\n{DVBT_SCALE1_B93, 0xb0},\r\n{DVBT_SCALE1_BA7, 0x78},\r\n{DVBT_SCALE1_BA9, 0x28},\r\n{DVBT_SCALE1_BAA, 0x59},\r\n{DVBT_SCALE1_BAB, 0x83},\r\n{DVBT_SCALE1_BAC, 0xd4},\r\n{DVBT_SCALE1_BB0, 0x65},\r\n{DVBT_SCALE1_BB1, 0x43},\r\n{DVBT_KB_P1, 0x1},\r\n{DVBT_KB_P2, 0x4},\r\n{DVBT_KB_P3, 0x7},\r\n{DVBT_K1_CR_STEP12, 0xa},\r\n{DVBT_REG_GPE, 0x1},\r\n{DVBT_SERIAL, 0x0},\r\n{DVBT_CDIV_PH0, 0x9},\r\n{DVBT_CDIV_PH1, 0x9},\r\n{DVBT_MPEG_IO_OPT_2_2, 0x0},\r\n{DVBT_MPEG_IO_OPT_1_0, 0x0},\r\n{DVBT_TRK_KS_P2, 0x4},\r\n{DVBT_TRK_KS_I2, 0x7},\r\n{DVBT_TR_THD_SET2, 0x6},\r\n{DVBT_TRK_KC_I2, 0x5},\r\n{DVBT_CR_THD_SET2, 0x1},\r\n};\r\ndev_dbg(&client->dev, "\n");\r\nret = rtl2832_wr_demod_reg(dev, DVBT_SOFT_RST, 0x0);\r\nif (ret)\r\ngoto err;\r\nfor (i = 0; i < ARRAY_SIZE(rtl2832_initial_regs); i++) {\r\nret = rtl2832_wr_demod_reg(dev, rtl2832_initial_regs[i].reg,\r\nrtl2832_initial_regs[i].value);\r\nif (ret)\r\ngoto err;\r\n}\r\ndev_dbg(&client->dev, "load settings for tuner=%02x\n",\r\ndev->pdata->tuner);\r\nswitch (dev->pdata->tuner) {\r\ncase RTL2832_TUNER_FC2580:\r\nlen = ARRAY_SIZE(rtl2832_tuner_init_fc2580);\r\ninit = rtl2832_tuner_init_fc2580;\r\nbreak;\r\ncase RTL2832_TUNER_FC0012:\r\ncase RTL2832_TUNER_FC0013:\r\nlen = ARRAY_SIZE(rtl2832_tuner_init_fc0012);\r\ninit = rtl2832_tuner_init_fc0012;\r\nbreak;\r\ncase RTL2832_TUNER_TUA9001:\r\nlen = ARRAY_SIZE(rtl2832_tuner_init_tua9001);\r\ninit = rtl2832_tuner_init_tua9001;\r\nbreak;\r\ncase RTL2832_TUNER_E4000:\r\nlen = ARRAY_SIZE(rtl2832_tuner_init_e4000);\r\ninit = rtl2832_tuner_init_e4000;\r\nbreak;\r\ncase RTL2832_TUNER_R820T:\r\ncase RTL2832_TUNER_R828D:\r\nlen = ARRAY_SIZE(rtl2832_tuner_init_r820t);\r\ninit = rtl2832_tuner_init_r820t;\r\nbreak;\r\ncase RTL2832_TUNER_SI2157:\r\nlen = ARRAY_SIZE(rtl2832_tuner_init_si2157);\r\ninit = rtl2832_tuner_init_si2157;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nfor (i = 0; i < len; i++) {\r\nret = rtl2832_wr_demod_reg(dev, init[i].reg, init[i].value);\r\nif (ret)\r\ngoto err;\r\n}\r\nc->strength.len = 1;\r\nc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->cnr.len = 1;\r\nc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_error.len = 1;\r\nc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_count.len = 1;\r\nc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\ndev->sleeping = false;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct rtl2832_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\ndev_dbg(&client->dev, "\n");\r\ndev->sleeping = true;\r\ndev->fe_status = 0;\r\nret = rtl2832_wr_demod_reg(dev, DVBT_SOFT_RST, 0x1);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *s)\r\n{\r\nstruct rtl2832_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\ndev_dbg(&client->dev, "\n");\r\ns->min_delay_ms = 1000;\r\ns->step_size = fe->ops.info.frequency_stepsize * 2;\r\ns->max_drift = (fe->ops.info.frequency_stepsize * 2) + 1;\r\nreturn 0;\r\n}\r\nstatic int rtl2832_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct rtl2832_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i, j;\r\nu64 bw_mode, num, num2;\r\nu32 resamp_ratio, cfreq_off_ratio;\r\nstatic u8 bw_params[3][32] = {\r\n{\r\n0xf5, 0xff, 0x15, 0x38, 0x5d, 0x6d, 0x52, 0x07, 0xfa, 0x2f,\r\n0x53, 0xf5, 0x3f, 0xca, 0x0b, 0x91, 0xea, 0x30, 0x63, 0xb2,\r\n0x13, 0xda, 0x0b, 0xc4, 0x18, 0x7e, 0x16, 0x66, 0x08, 0x67,\r\n0x19, 0xe0,\r\n},\r\n{\r\n0xe7, 0xcc, 0xb5, 0xba, 0xe8, 0x2f, 0x67, 0x61, 0x00, 0xaf,\r\n0x86, 0xf2, 0xbf, 0x59, 0x04, 0x11, 0xb6, 0x33, 0xa4, 0x30,\r\n0x15, 0x10, 0x0a, 0x42, 0x18, 0xf8, 0x17, 0xd9, 0x07, 0x22,\r\n0x19, 0x10,\r\n},\r\n{\r\n0x09, 0xf6, 0xd2, 0xa7, 0x9a, 0xc9, 0x27, 0x77, 0x06, 0xbf,\r\n0xec, 0xf4, 0x4f, 0x0b, 0xfc, 0x01, 0x63, 0x35, 0x54, 0xa7,\r\n0x16, 0x66, 0x08, 0xb4, 0x19, 0x6e, 0x19, 0x65, 0x05, 0xc8,\r\n0x19, 0xe0,\r\n},\r\n};\r\ndev_dbg(&client->dev, "frequency=%u bandwidth_hz=%u inversion=%u\n",\r\nc->frequency, c->bandwidth_hz, c->inversion);\r\nif (fe->ops.tuner_ops.set_params)\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.tuner_ops.get_if_frequency) {\r\nu32 if_freq;\r\nret = fe->ops.tuner_ops.get_if_frequency(fe, &if_freq);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_set_if(fe, if_freq);\r\nif (ret)\r\ngoto err;\r\n}\r\nswitch (c->bandwidth_hz) {\r\ncase 6000000:\r\ni = 0;\r\nbw_mode = 48000000;\r\nbreak;\r\ncase 7000000:\r\ni = 1;\r\nbw_mode = 56000000;\r\nbreak;\r\ncase 8000000:\r\ni = 2;\r\nbw_mode = 64000000;\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev, "invalid bandwidth_hz %u\n",\r\nc->bandwidth_hz);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nfor (j = 0; j < sizeof(bw_params[0]); j++) {\r\nret = regmap_bulk_write(dev->regmap,\r\n0x11c + j, &bw_params[i][j], 1);\r\nif (ret)\r\ngoto err;\r\n}\r\nnum = dev->pdata->clk * 7;\r\nnum *= 0x400000;\r\nnum = div_u64(num, bw_mode);\r\nresamp_ratio = num & 0x3ffffff;\r\nret = rtl2832_wr_demod_reg(dev, DVBT_RSAMP_RATIO, resamp_ratio);\r\nif (ret)\r\ngoto err;\r\nnum = bw_mode << 20;\r\nnum2 = dev->pdata->clk * 7;\r\nnum = div_u64(num, num2);\r\nnum = -num;\r\ncfreq_off_ratio = num & 0xfffff;\r\nret = rtl2832_wr_demod_reg(dev, DVBT_CFREQ_OFF_RATIO, cfreq_off_ratio);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_wr_demod_reg(dev, DVBT_SOFT_RST, 0x1);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_wr_demod_reg(dev, DVBT_SOFT_RST, 0x0);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832_get_frontend(struct dvb_frontend *fe,\r\nstruct dtv_frontend_properties *c)\r\n{\r\nstruct rtl2832_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\nu8 buf[3];\r\nif (dev->sleeping)\r\nreturn 0;\r\nret = regmap_bulk_read(dev->regmap, 0x33c, buf, 2);\r\nif (ret)\r\ngoto err;\r\nret = regmap_bulk_read(dev->regmap, 0x351, &buf[2], 1);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&client->dev, "TPS=%*ph\n", 3, buf);\r\nswitch ((buf[0] >> 2) & 3) {\r\ncase 0:\r\nc->modulation = QPSK;\r\nbreak;\r\ncase 1:\r\nc->modulation = QAM_16;\r\nbreak;\r\ncase 2:\r\nc->modulation = QAM_64;\r\nbreak;\r\n}\r\nswitch ((buf[2] >> 2) & 1) {\r\ncase 0:\r\nc->transmission_mode = TRANSMISSION_MODE_2K;\r\nbreak;\r\ncase 1:\r\nc->transmission_mode = TRANSMISSION_MODE_8K;\r\n}\r\nswitch ((buf[2] >> 0) & 3) {\r\ncase 0:\r\nc->guard_interval = GUARD_INTERVAL_1_32;\r\nbreak;\r\ncase 1:\r\nc->guard_interval = GUARD_INTERVAL_1_16;\r\nbreak;\r\ncase 2:\r\nc->guard_interval = GUARD_INTERVAL_1_8;\r\nbreak;\r\ncase 3:\r\nc->guard_interval = GUARD_INTERVAL_1_4;\r\nbreak;\r\n}\r\nswitch ((buf[0] >> 4) & 7) {\r\ncase 0:\r\nc->hierarchy = HIERARCHY_NONE;\r\nbreak;\r\ncase 1:\r\nc->hierarchy = HIERARCHY_1;\r\nbreak;\r\ncase 2:\r\nc->hierarchy = HIERARCHY_2;\r\nbreak;\r\ncase 3:\r\nc->hierarchy = HIERARCHY_4;\r\nbreak;\r\n}\r\nswitch ((buf[1] >> 3) & 7) {\r\ncase 0:\r\nc->code_rate_HP = FEC_1_2;\r\nbreak;\r\ncase 1:\r\nc->code_rate_HP = FEC_2_3;\r\nbreak;\r\ncase 2:\r\nc->code_rate_HP = FEC_3_4;\r\nbreak;\r\ncase 3:\r\nc->code_rate_HP = FEC_5_6;\r\nbreak;\r\ncase 4:\r\nc->code_rate_HP = FEC_7_8;\r\nbreak;\r\n}\r\nswitch ((buf[1] >> 0) & 7) {\r\ncase 0:\r\nc->code_rate_LP = FEC_1_2;\r\nbreak;\r\ncase 1:\r\nc->code_rate_LP = FEC_2_3;\r\nbreak;\r\ncase 2:\r\nc->code_rate_LP = FEC_3_4;\r\nbreak;\r\ncase 3:\r\nc->code_rate_LP = FEC_5_6;\r\nbreak;\r\ncase 4:\r\nc->code_rate_LP = FEC_7_8;\r\nbreak;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832_read_status(struct dvb_frontend *fe, enum fe_status *status)\r\n{\r\nstruct rtl2832_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret;\r\nu32 uninitialized_var(tmp);\r\nu8 u8tmp, buf[2];\r\nu16 u16tmp;\r\ndev_dbg(&client->dev, "\n");\r\n*status = 0;\r\nif (dev->sleeping)\r\nreturn 0;\r\nret = rtl2832_rd_demod_reg(dev, DVBT_FSM_STAGE, &tmp);\r\nif (ret)\r\ngoto err;\r\nif (tmp == 11) {\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;\r\n} else if (tmp == 10) {\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI;\r\n}\r\ndev->fe_status = *status;\r\nif (dev->fe_status & FE_HAS_SIGNAL) {\r\nret = regmap_bulk_read(dev->regmap, 0x305, &u8tmp, 1);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&client->dev, "digital agc=%02x", u8tmp);\r\nu8tmp = ~u8tmp;\r\nu16tmp = u8tmp << 8 | u8tmp << 0;\r\nc->strength.stat[0].scale = FE_SCALE_RELATIVE;\r\nc->strength.stat[0].uvalue = u16tmp;\r\n} else {\r\nc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\nif (dev->fe_status & FE_HAS_VITERBI) {\r\nunsigned hierarchy, constellation;\r\n#define CONSTELLATION_NUM 3\r\n#define HIERARCHY_NUM 4\r\nstatic const u32 constant[CONSTELLATION_NUM][HIERARCHY_NUM] = {\r\n{85387325, 85387325, 85387325, 85387325},\r\n{86676178, 86676178, 87167949, 87795660},\r\n{87659938, 87659938, 87885178, 88241743},\r\n};\r\nret = regmap_bulk_read(dev->regmap, 0x33c, &u8tmp, 1);\r\nif (ret)\r\ngoto err;\r\nconstellation = (u8tmp >> 2) & 0x03;\r\nif (constellation > CONSTELLATION_NUM - 1)\r\ngoto err;\r\nhierarchy = (u8tmp >> 4) & 0x07;\r\nif (hierarchy > HIERARCHY_NUM - 1)\r\ngoto err;\r\nret = regmap_bulk_read(dev->regmap, 0x40c, buf, 2);\r\nif (ret)\r\ngoto err;\r\nu16tmp = buf[0] << 8 | buf[1] << 0;\r\nif (u16tmp)\r\ntmp = (constant[constellation][hierarchy] -\r\nintlog10(u16tmp)) / ((1 << 24) / 10000);\r\nelse\r\ntmp = 0;\r\ndev_dbg(&client->dev, "cnr raw=%u\n", u16tmp);\r\nc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\r\nc->cnr.stat[0].svalue = tmp;\r\n} else {\r\nc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\nif (dev->fe_status & FE_HAS_LOCK) {\r\nret = regmap_bulk_read(dev->regmap, 0x34e, buf, 2);\r\nif (ret)\r\ngoto err;\r\nu16tmp = buf[0] << 8 | buf[1] << 0;\r\ndev->post_bit_error += u16tmp;\r\ndev->post_bit_count += 1000000;\r\ndev_dbg(&client->dev, "ber errors=%u total=1000000\n", u16tmp);\r\nc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\r\nc->post_bit_error.stat[0].uvalue = dev->post_bit_error;\r\nc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\r\nc->post_bit_count.stat[0].uvalue = dev->post_bit_count;\r\n} else {\r\nc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nif (c->cnr.stat[0].scale == FE_SCALE_DECIBEL)\r\n*snr = div_s64(c->cnr.stat[0].svalue, 100);\r\nelse\r\n*snr = 0;\r\nreturn 0;\r\n}\r\nstatic int rtl2832_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct rtl2832_dev *dev = fe->demodulator_priv;\r\n*ber = (dev->post_bit_error - dev->post_bit_error_prev);\r\ndev->post_bit_error_prev = dev->post_bit_error;\r\nreturn 0;\r\n}\r\nstatic void rtl2832_i2c_gate_work(struct work_struct *work)\r\n{\r\nstruct rtl2832_dev *dev = container_of(work, struct rtl2832_dev, i2c_gate_work.work);\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\nret = regmap_update_bits(dev->regmap, 0x101, 0x08, 0x00);\r\nif (ret)\r\ngoto err;\r\nreturn;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\n}\r\nstatic int rtl2832_select(struct i2c_mux_core *muxc, u32 chan_id)\r\n{\r\nstruct rtl2832_dev *dev = i2c_mux_priv(muxc);\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\ncancel_delayed_work(&dev->i2c_gate_work);\r\nret = regmap_update_bits(dev->regmap, 0x101, 0x08, 0x08);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832_deselect(struct i2c_mux_core *muxc, u32 chan_id)\r\n{\r\nstruct rtl2832_dev *dev = i2c_mux_priv(muxc);\r\nschedule_delayed_work(&dev->i2c_gate_work, usecs_to_jiffies(100));\r\nreturn 0;\r\n}\r\nstatic bool rtl2832_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase 0x305:\r\ncase 0x33c:\r\ncase 0x34e:\r\ncase 0x351:\r\ncase 0x40c ... 0x40d:\r\nreturn true;\r\ndefault:\r\nbreak;\r\n}\r\nreturn false;\r\n}\r\nstatic struct dvb_frontend *rtl2832_get_dvb_frontend(struct i2c_client *client)\r\n{\r\nstruct rtl2832_dev *dev = i2c_get_clientdata(client);\r\ndev_dbg(&client->dev, "\n");\r\nreturn &dev->fe;\r\n}\r\nstatic struct i2c_adapter *rtl2832_get_i2c_adapter(struct i2c_client *client)\r\n{\r\nstruct rtl2832_dev *dev = i2c_get_clientdata(client);\r\ndev_dbg(&client->dev, "\n");\r\nreturn dev->muxc->adapter[0];\r\n}\r\nstatic int rtl2832_slave_ts_ctrl(struct i2c_client *client, bool enable)\r\n{\r\nstruct rtl2832_dev *dev = i2c_get_clientdata(client);\r\nint ret;\r\ndev_dbg(&client->dev, "enable=%d\n", enable);\r\nif (enable) {\r\nret = rtl2832_wr_demod_reg(dev, DVBT_SOFT_RST, 0x0);\r\nif (ret)\r\ngoto err;\r\nret = regmap_bulk_write(dev->regmap, 0x10c, "\x5f\xff", 2);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_wr_demod_reg(dev, DVBT_PIP_ON, 0x1);\r\nif (ret)\r\ngoto err;\r\nret = regmap_bulk_write(dev->regmap, 0x0bc, "\x18", 1);\r\nif (ret)\r\ngoto err;\r\nret = regmap_bulk_write(dev->regmap, 0x192, "\x7f\xf7\xff", 3);\r\nif (ret)\r\ngoto err;\r\n} else {\r\nret = regmap_bulk_write(dev->regmap, 0x192, "\x00\x0f\xff", 3);\r\nif (ret)\r\ngoto err;\r\nret = regmap_bulk_write(dev->regmap, 0x0bc, "\x08", 1);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_wr_demod_reg(dev, DVBT_PIP_ON, 0x0);\r\nif (ret)\r\ngoto err;\r\nret = regmap_bulk_write(dev->regmap, 0x10c, "\x00\x00", 2);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_wr_demod_reg(dev, DVBT_SOFT_RST, 0x1);\r\nif (ret)\r\ngoto err;\r\n}\r\ndev->slave_ts = enable;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832_pid_filter_ctrl(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct rtl2832_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\nu8 u8tmp;\r\ndev_dbg(&client->dev, "onoff=%d, slave_ts=%d\n", onoff, dev->slave_ts);\r\nif (onoff)\r\nu8tmp = 0x80;\r\nelse\r\nu8tmp = 0x00;\r\nif (dev->slave_ts)\r\nret = regmap_update_bits(dev->regmap, 0x021, 0xc0, u8tmp);\r\nelse\r\nret = regmap_update_bits(dev->regmap, 0x061, 0xc0, u8tmp);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832_pid_filter(struct dvb_frontend *fe, u8 index, u16 pid,\r\nint onoff)\r\n{\r\nstruct rtl2832_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\nu8 buf[4];\r\ndev_dbg(&client->dev, "index=%d pid=%04x onoff=%d slave_ts=%d\n",\r\nindex, pid, onoff, dev->slave_ts);\r\nif (pid > 0x1fff || index > 32)\r\nreturn 0;\r\nif (onoff)\r\nset_bit(index, &dev->filters);\r\nelse\r\nclear_bit(index, &dev->filters);\r\nbuf[0] = (dev->filters >> 0) & 0xff;\r\nbuf[1] = (dev->filters >> 8) & 0xff;\r\nbuf[2] = (dev->filters >> 16) & 0xff;\r\nbuf[3] = (dev->filters >> 24) & 0xff;\r\nif (dev->slave_ts)\r\nret = regmap_bulk_write(dev->regmap, 0x022, buf, 4);\r\nelse\r\nret = regmap_bulk_write(dev->regmap, 0x062, buf, 4);\r\nif (ret)\r\ngoto err;\r\nbuf[0] = (pid >> 8) & 0xff;\r\nbuf[1] = (pid >> 0) & 0xff;\r\nif (dev->slave_ts)\r\nret = regmap_bulk_write(dev->regmap, 0x026 + 2 * index, buf, 2);\r\nelse\r\nret = regmap_bulk_write(dev->regmap, 0x066 + 2 * index, buf, 2);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct rtl2832_platform_data *pdata = client->dev.platform_data;\r\nstruct i2c_adapter *i2c = client->adapter;\r\nstruct rtl2832_dev *dev;\r\nint ret;\r\nu8 tmp;\r\nstatic const struct regmap_range_cfg regmap_range_cfg[] = {\r\n{\r\n.selector_reg = 0x00,\r\n.selector_mask = 0xff,\r\n.selector_shift = 0,\r\n.window_start = 0,\r\n.window_len = 0x100,\r\n.range_min = 0 * 0x100,\r\n.range_max = 5 * 0x100,\r\n},\r\n};\r\ndev_dbg(&client->dev, "\n");\r\ndev = kzalloc(sizeof(struct rtl2832_dev), GFP_KERNEL);\r\nif (dev == NULL) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ni2c_set_clientdata(client, dev);\r\ndev->client = client;\r\ndev->pdata = client->dev.platform_data;\r\ndev->sleeping = true;\r\nINIT_DELAYED_WORK(&dev->i2c_gate_work, rtl2832_i2c_gate_work);\r\ndev->regmap_config.reg_bits = 8,\r\ndev->regmap_config.val_bits = 8,\r\ndev->regmap_config.volatile_reg = rtl2832_volatile_reg,\r\ndev->regmap_config.max_register = 5 * 0x100,\r\ndev->regmap_config.ranges = regmap_range_cfg,\r\ndev->regmap_config.num_ranges = ARRAY_SIZE(regmap_range_cfg),\r\ndev->regmap_config.cache_type = REGCACHE_NONE,\r\ndev->regmap = regmap_init_i2c(client, &dev->regmap_config);\r\nif (IS_ERR(dev->regmap)) {\r\nret = PTR_ERR(dev->regmap);\r\ngoto err_kfree;\r\n}\r\nret = regmap_bulk_read(dev->regmap, 0x000, &tmp, 1);\r\nif (ret)\r\ngoto err_regmap_exit;\r\ndev->muxc = i2c_mux_alloc(i2c, &i2c->dev, 1, 0, I2C_MUX_LOCKED,\r\nrtl2832_select, rtl2832_deselect);\r\nif (!dev->muxc) {\r\nret = -ENOMEM;\r\ngoto err_regmap_exit;\r\n}\r\ndev->muxc->priv = dev;\r\nret = i2c_mux_add_adapter(dev->muxc, 0, 0, 0);\r\nif (ret)\r\ngoto err_regmap_exit;\r\nmemcpy(&dev->fe.ops, &rtl2832_ops, sizeof(struct dvb_frontend_ops));\r\ndev->fe.demodulator_priv = dev;\r\npdata->get_dvb_frontend = rtl2832_get_dvb_frontend;\r\npdata->get_i2c_adapter = rtl2832_get_i2c_adapter;\r\npdata->slave_ts_ctrl = rtl2832_slave_ts_ctrl;\r\npdata->pid_filter = rtl2832_pid_filter;\r\npdata->pid_filter_ctrl = rtl2832_pid_filter_ctrl;\r\npdata->regmap = dev->regmap;\r\ndev_info(&client->dev, "Realtek RTL2832 successfully attached\n");\r\nreturn 0;\r\nerr_regmap_exit:\r\nregmap_exit(dev->regmap);\r\nerr_kfree:\r\nkfree(dev);\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832_remove(struct i2c_client *client)\r\n{\r\nstruct rtl2832_dev *dev = i2c_get_clientdata(client);\r\ndev_dbg(&client->dev, "\n");\r\ncancel_delayed_work_sync(&dev->i2c_gate_work);\r\ni2c_mux_del_adapters(dev->muxc);\r\nregmap_exit(dev->regmap);\r\nkfree(dev);\r\nreturn 0;\r\n}
