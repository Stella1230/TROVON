static bool force_two_pcm_support(struct fw_unit *unit)\r\n{\r\nconst char *const models[] = {\r\n"StudioKonnekt48",\r\n"SAFFIRE_PRO_40",\r\n"LIQUID_SAFFIRE_56",\r\n"SAFFIRE_PRO_40_1",\r\n};\r\nchar model[32];\r\nunsigned int i;\r\nint err;\r\nerr = fw_csr_string(unit->directory, CSR_MODEL, model, sizeof(model));\r\nif (err < 0)\r\nreturn false;\r\nfor (i = 0; i < ARRAY_SIZE(models); i++) {\r\nif (strcmp(models[i], model) == 0)\r\nbreak;\r\n}\r\nreturn i < ARRAY_SIZE(models);\r\n}\r\nstatic int check_dice_category(struct fw_unit *unit)\r\n{\r\nstruct fw_device *device = fw_parent_device(unit);\r\nstruct fw_csr_iterator it;\r\nint key, val, vendor = -1, model = -1;\r\nunsigned int category;\r\nfw_csr_iterator_init(&it, unit->directory);\r\nwhile (fw_csr_iterator_next(&it, &key, &val)) {\r\nswitch (key) {\r\ncase CSR_SPECIFIER_ID:\r\nvendor = val;\r\nbreak;\r\ncase CSR_MODEL:\r\nmodel = val;\r\nbreak;\r\n}\r\n}\r\nif (vendor == OUI_FOCUSRITE || vendor == OUI_TCELECTRONIC) {\r\nif (force_two_pcm_support(unit))\r\nreturn 0;\r\n}\r\nif (vendor == OUI_WEISS)\r\ncategory = WEISS_CATEGORY_ID;\r\nelse if (vendor == OUI_LOUD)\r\ncategory = LOUD_CATEGORY_ID;\r\nelse\r\ncategory = DICE_CATEGORY_ID;\r\nif (device->config_rom[3] != ((vendor << 8) | category) ||\r\ndevice->config_rom[4] >> 22 != model)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int check_clock_caps(struct snd_dice *dice)\r\n{\r\n__be32 value;\r\nint err;\r\nif (dice->clock_caps > 0) {\r\nerr = snd_dice_transaction_read_global(dice,\r\nGLOBAL_CLOCK_CAPABILITIES,\r\n&value, 4);\r\nif (err < 0)\r\nreturn err;\r\ndice->clock_caps = be32_to_cpu(value);\r\n} else {\r\ndice->clock_caps = CLOCK_CAP_RATE_44100 |\r\nCLOCK_CAP_RATE_48000 |\r\nCLOCK_CAP_SOURCE_ARX1 |\r\nCLOCK_CAP_SOURCE_INTERNAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dice_card_strings(struct snd_dice *dice)\r\n{\r\nstruct snd_card *card = dice->card;\r\nstruct fw_device *dev = fw_parent_device(dice->unit);\r\nchar vendor[32], model[32];\r\nunsigned int i;\r\nint err;\r\nstrcpy(card->driver, "DICE");\r\nstrcpy(card->shortname, "DICE");\r\nBUILD_BUG_ON(NICK_NAME_SIZE < sizeof(card->shortname));\r\nerr = snd_dice_transaction_read_global(dice, GLOBAL_NICK_NAME,\r\ncard->shortname,\r\nsizeof(card->shortname));\r\nif (err >= 0) {\r\nBUILD_BUG_ON(sizeof(card->shortname) % 4 != 0);\r\nfor (i = 0; i < sizeof(card->shortname); i += 4)\r\nswab32s((u32 *)&card->shortname[i]);\r\ncard->shortname[sizeof(card->shortname) - 1] = '\0';\r\n}\r\nstrcpy(vendor, "?");\r\nfw_csr_string(dev->config_rom + 5, CSR_VENDOR, vendor, sizeof(vendor));\r\nstrcpy(model, "?");\r\nfw_csr_string(dice->unit->directory, CSR_MODEL, model, sizeof(model));\r\nsnprintf(card->longname, sizeof(card->longname),\r\n"%s %s (serial %u) at %s, S%d",\r\nvendor, model, dev->config_rom[4] & 0x3fffff,\r\ndev_name(&dice->unit->device), 100 << dev->max_speed);\r\nstrcpy(card->mixername, "DICE");\r\n}\r\nstatic void dice_free(struct snd_dice *dice)\r\n{\r\nsnd_dice_stream_destroy_duplex(dice);\r\nsnd_dice_transaction_destroy(dice);\r\nfw_unit_put(dice->unit);\r\nmutex_destroy(&dice->mutex);\r\nkfree(dice);\r\n}\r\nstatic void dice_card_free(struct snd_card *card)\r\n{\r\ndice_free(card->private_data);\r\n}\r\nstatic void do_registration(struct work_struct *work)\r\n{\r\nstruct snd_dice *dice = container_of(work, struct snd_dice, dwork.work);\r\nint err;\r\nif (dice->registered)\r\nreturn;\r\nerr = snd_card_new(&dice->unit->device, -1, NULL, THIS_MODULE, 0,\r\n&dice->card);\r\nif (err < 0)\r\nreturn;\r\nif (force_two_pcm_support(dice->unit))\r\ndice->force_two_pcms = true;\r\nerr = snd_dice_transaction_init(dice);\r\nif (err < 0)\r\ngoto error;\r\nerr = check_clock_caps(dice);\r\nif (err < 0)\r\ngoto error;\r\ndice_card_strings(dice);\r\nerr = snd_dice_stream_init_duplex(dice);\r\nif (err < 0)\r\ngoto error;\r\nsnd_dice_create_proc(dice);\r\nerr = snd_dice_create_pcm(dice);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_dice_create_midi(dice);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_dice_create_hwdep(dice);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_card_register(dice->card);\r\nif (err < 0)\r\ngoto error;\r\ndice->card->private_free = dice_card_free;\r\ndice->card->private_data = dice;\r\ndice->registered = true;\r\nreturn;\r\nerror:\r\nsnd_dice_stream_destroy_duplex(dice);\r\nsnd_dice_transaction_destroy(dice);\r\nsnd_dice_stream_destroy_duplex(dice);\r\nsnd_card_free(dice->card);\r\ndev_info(&dice->unit->device,\r\n"Sound card registration failed: %d\n", err);\r\n}\r\nstatic int dice_probe(struct fw_unit *unit, const struct ieee1394_device_id *id)\r\n{\r\nstruct snd_dice *dice;\r\nint err;\r\nerr = check_dice_category(unit);\r\nif (err < 0)\r\nreturn -ENODEV;\r\ndice = kzalloc(sizeof(struct snd_dice), GFP_KERNEL);\r\nif (dice == NULL)\r\nreturn -ENOMEM;\r\ndice->unit = fw_unit_get(unit);\r\ndev_set_drvdata(&unit->device, dice);\r\nspin_lock_init(&dice->lock);\r\nmutex_init(&dice->mutex);\r\ninit_completion(&dice->clock_accepted);\r\ninit_waitqueue_head(&dice->hwdep_wait);\r\nINIT_DEFERRABLE_WORK(&dice->dwork, do_registration);\r\nsnd_fw_schedule_registration(unit, &dice->dwork);\r\nreturn 0;\r\n}\r\nstatic void dice_remove(struct fw_unit *unit)\r\n{\r\nstruct snd_dice *dice = dev_get_drvdata(&unit->device);\r\ncancel_delayed_work_sync(&dice->dwork);\r\nif (dice->registered) {\r\nsnd_card_free_when_closed(dice->card);\r\n} else {\r\ndice_free(dice);\r\n}\r\n}\r\nstatic void dice_bus_reset(struct fw_unit *unit)\r\n{\r\nstruct snd_dice *dice = dev_get_drvdata(&unit->device);\r\nif (!dice->registered)\r\nsnd_fw_schedule_registration(unit, &dice->dwork);\r\nsnd_dice_transaction_reinit(dice);\r\nif (dice->registered) {\r\nmutex_lock(&dice->mutex);\r\nsnd_dice_stream_update_duplex(dice);\r\nmutex_unlock(&dice->mutex);\r\n}\r\n}\r\nstatic int __init alsa_dice_init(void)\r\n{\r\nreturn driver_register(&dice_driver.driver);\r\n}\r\nstatic void __exit alsa_dice_exit(void)\r\n{\r\ndriver_unregister(&dice_driver.driver);\r\n}
