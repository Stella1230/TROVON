static int ohci_da8xx_enable(struct usb_hcd *hcd)\r\n{\r\nstruct da8xx_ohci_hcd *da8xx_ohci = to_da8xx_ohci(hcd);\r\nint ret;\r\nret = clk_prepare_enable(da8xx_ohci->usb11_clk);\r\nif (ret)\r\nreturn ret;\r\nret = phy_init(da8xx_ohci->usb11_phy);\r\nif (ret)\r\ngoto err_phy_init;\r\nret = phy_power_on(da8xx_ohci->usb11_phy);\r\nif (ret)\r\ngoto err_phy_power_on;\r\nreturn 0;\r\nerr_phy_power_on:\r\nphy_exit(da8xx_ohci->usb11_phy);\r\nerr_phy_init:\r\nclk_disable_unprepare(da8xx_ohci->usb11_clk);\r\nreturn ret;\r\n}\r\nstatic void ohci_da8xx_disable(struct usb_hcd *hcd)\r\n{\r\nstruct da8xx_ohci_hcd *da8xx_ohci = to_da8xx_ohci(hcd);\r\nphy_power_off(da8xx_ohci->usb11_phy);\r\nphy_exit(da8xx_ohci->usb11_phy);\r\nclk_disable_unprepare(da8xx_ohci->usb11_clk);\r\n}\r\nstatic int ohci_da8xx_set_power(struct usb_hcd *hcd, int on)\r\n{\r\nstruct da8xx_ohci_hcd *da8xx_ohci = to_da8xx_ohci(hcd);\r\nstruct device *dev = hcd->self.controller;\r\nstruct da8xx_ohci_root_hub *hub = dev_get_platdata(dev);\r\nint ret;\r\nif (hub && hub->set_power)\r\nreturn hub->set_power(1, on);\r\nif (!da8xx_ohci->vbus_reg)\r\nreturn 0;\r\nif (on && !da8xx_ohci->reg_enabled) {\r\nret = regulator_enable(da8xx_ohci->vbus_reg);\r\nif (ret) {\r\ndev_err(dev, "Failed to enable regulator: %d\n", ret);\r\nreturn ret;\r\n}\r\nda8xx_ohci->reg_enabled = 1;\r\n} else if (!on && da8xx_ohci->reg_enabled) {\r\nret = regulator_disable(da8xx_ohci->vbus_reg);\r\nif (ret) {\r\ndev_err(dev, "Failed to disable regulator: %d\n", ret);\r\nreturn ret;\r\n}\r\nda8xx_ohci->reg_enabled = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ohci_da8xx_get_power(struct usb_hcd *hcd)\r\n{\r\nstruct da8xx_ohci_hcd *da8xx_ohci = to_da8xx_ohci(hcd);\r\nstruct device *dev = hcd->self.controller;\r\nstruct da8xx_ohci_root_hub *hub = dev_get_platdata(dev);\r\nif (hub && hub->get_power)\r\nreturn hub->get_power(1);\r\nif (da8xx_ohci->vbus_reg)\r\nreturn regulator_is_enabled(da8xx_ohci->vbus_reg);\r\nreturn 1;\r\n}\r\nstatic int ohci_da8xx_get_oci(struct usb_hcd *hcd)\r\n{\r\nstruct da8xx_ohci_hcd *da8xx_ohci = to_da8xx_ohci(hcd);\r\nstruct device *dev = hcd->self.controller;\r\nstruct da8xx_ohci_root_hub *hub = dev_get_platdata(dev);\r\nunsigned int flags;\r\nint ret;\r\nif (hub && hub->get_oci)\r\nreturn hub->get_oci(1);\r\nif (!da8xx_ohci->vbus_reg)\r\nreturn 0;\r\nret = regulator_get_error_flags(da8xx_ohci->vbus_reg, &flags);\r\nif (ret)\r\nreturn ret;\r\nif (flags & REGULATOR_ERROR_OVER_CURRENT)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int ohci_da8xx_has_set_power(struct usb_hcd *hcd)\r\n{\r\nstruct da8xx_ohci_hcd *da8xx_ohci = to_da8xx_ohci(hcd);\r\nstruct device *dev = hcd->self.controller;\r\nstruct da8xx_ohci_root_hub *hub = dev_get_platdata(dev);\r\nif (hub && hub->set_power)\r\nreturn 1;\r\nif (da8xx_ohci->vbus_reg)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int ohci_da8xx_has_oci(struct usb_hcd *hcd)\r\n{\r\nstruct da8xx_ohci_hcd *da8xx_ohci = to_da8xx_ohci(hcd);\r\nstruct device *dev = hcd->self.controller;\r\nstruct da8xx_ohci_root_hub *hub = dev_get_platdata(dev);\r\nif (hub && hub->get_oci)\r\nreturn 1;\r\nif (da8xx_ohci->vbus_reg)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int ohci_da8xx_has_potpgt(struct usb_hcd *hcd)\r\n{\r\nstruct device *dev = hcd->self.controller;\r\nstruct da8xx_ohci_root_hub *hub = dev_get_platdata(dev);\r\nif (hub && hub->potpgt)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void ohci_da8xx_ocic_handler(struct da8xx_ohci_root_hub *hub,\r\nunsigned port)\r\n{\r\nocic_mask |= 1 << port;\r\nif (hub->get_oci(port) > 0)\r\nhub->set_power(port, 0);\r\n}\r\nstatic int ohci_da8xx_regulator_event(struct notifier_block *nb,\r\nunsigned long event, void *data)\r\n{\r\nstruct da8xx_ohci_hcd *da8xx_ohci =\r\ncontainer_of(nb, struct da8xx_ohci_hcd, nb);\r\nif (event & REGULATOR_EVENT_OVER_CURRENT) {\r\nocic_mask |= 1 << 1;\r\nohci_da8xx_set_power(da8xx_ohci->hcd, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ohci_da8xx_register_notify(struct usb_hcd *hcd)\r\n{\r\nstruct da8xx_ohci_hcd *da8xx_ohci = to_da8xx_ohci(hcd);\r\nstruct device *dev = hcd->self.controller;\r\nstruct da8xx_ohci_root_hub *hub = dev_get_platdata(dev);\r\nint ret = 0;\r\nif (hub && hub->ocic_notify) {\r\nret = hub->ocic_notify(ohci_da8xx_ocic_handler);\r\n} else if (da8xx_ohci->vbus_reg) {\r\nda8xx_ohci->nb.notifier_call = ohci_da8xx_regulator_event;\r\nret = devm_regulator_register_notifier(da8xx_ohci->vbus_reg,\r\n&da8xx_ohci->nb);\r\n}\r\nif (ret)\r\ndev_err(dev, "Failed to register notifier: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void ohci_da8xx_unregister_notify(struct usb_hcd *hcd)\r\n{\r\nstruct device *dev = hcd->self.controller;\r\nstruct da8xx_ohci_root_hub *hub = dev_get_platdata(dev);\r\nif (hub && hub->ocic_notify)\r\nhub->ocic_notify(NULL);\r\n}\r\nstatic int ohci_da8xx_reset(struct usb_hcd *hcd)\r\n{\r\nstruct device *dev = hcd->self.controller;\r\nstruct da8xx_ohci_root_hub *hub = dev_get_platdata(dev);\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nint result;\r\nu32 rh_a;\r\ndev_dbg(dev, "starting USB controller\n");\r\nresult = ohci_da8xx_enable(hcd);\r\nif (result < 0)\r\nreturn result;\r\nohci->num_ports = 1;\r\nresult = ohci_setup(hcd);\r\nif (result < 0) {\r\nohci_da8xx_disable(hcd);\r\nreturn result;\r\n}\r\nrh_a = ohci_readl(ohci, &ohci->regs->roothub.a);\r\nif (ohci_da8xx_has_set_power(hcd)) {\r\nrh_a &= ~RH_A_NPS;\r\nrh_a |= RH_A_PSM;\r\n}\r\nif (ohci_da8xx_has_oci(hcd)) {\r\nrh_a &= ~RH_A_NOCP;\r\nrh_a |= RH_A_OCPM;\r\n}\r\nif (ohci_da8xx_has_potpgt(hcd)) {\r\nrh_a &= ~RH_A_POTPGT;\r\nrh_a |= hub->potpgt << 24;\r\n}\r\nohci_writel(ohci, rh_a, &ohci->regs->roothub.a);\r\nreturn result;\r\n}\r\nstatic int ohci_da8xx_hub_status_data(struct usb_hcd *hcd, char *buf)\r\n{\r\nint length = orig_ohci_hub_status_data(hcd, buf);\r\nif (ocic_mask & (1 << 1)) {\r\ndev_dbg(hcd->self.controller, "over-current indicator change "\r\n"on port 1\n");\r\nif (!length)\r\nlength = 1;\r\nbuf[0] |= 1 << 1;\r\n}\r\nreturn length;\r\n}\r\nstatic int ohci_da8xx_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,\r\nu16 wIndex, char *buf, u16 wLength)\r\n{\r\nstruct device *dev = hcd->self.controller;\r\nint temp;\r\nswitch (typeReq) {\r\ncase GetPortStatus:\r\nif (wIndex != 1)\r\nbreak;\r\ndev_dbg(dev, "GetPortStatus(%u)\n", wIndex);\r\ntemp = roothub_portstatus(hcd_to_ohci(hcd), wIndex - 1);\r\nif (!ohci_da8xx_get_power(hcd))\r\ntemp &= ~RH_PS_PPS;\r\nif (ohci_da8xx_get_oci(hcd) > 0)\r\ntemp |= RH_PS_POCI;\r\nif (ocic_mask & (1 << wIndex))\r\ntemp |= RH_PS_OCIC;\r\nput_unaligned(cpu_to_le32(temp), (__le32 *)buf);\r\nreturn 0;\r\ncase SetPortFeature:\r\ntemp = 1;\r\ngoto check_port;\r\ncase ClearPortFeature:\r\ntemp = 0;\r\ncheck_port:\r\nif (wIndex != 1)\r\nbreak;\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_POWER:\r\ndev_dbg(dev, "%sPortFeature(%u): %s\n",\r\ntemp ? "Set" : "Clear", wIndex, "POWER");\r\nreturn ohci_da8xx_set_power(hcd, temp) ? -EPIPE : 0;\r\ncase USB_PORT_FEAT_C_OVER_CURRENT:\r\ndev_dbg(dev, "%sPortFeature(%u): %s\n",\r\ntemp ? "Set" : "Clear", wIndex,\r\n"C_OVER_CURRENT");\r\nif (temp)\r\nocic_mask |= 1 << wIndex;\r\nelse\r\nocic_mask &= ~(1 << wIndex);\r\nreturn 0;\r\n}\r\n}\r\nreturn orig_ohci_hub_control(hcd, typeReq, wValue,\r\nwIndex, buf, wLength);\r\n}\r\nstatic int ohci_da8xx_probe(struct platform_device *pdev)\r\n{\r\nstruct da8xx_ohci_hcd *da8xx_ohci;\r\nstruct usb_hcd *hcd;\r\nstruct resource *mem;\r\nint error, irq;\r\nhcd = usb_create_hcd(&ohci_da8xx_hc_driver, &pdev->dev,\r\ndev_name(&pdev->dev));\r\nif (!hcd)\r\nreturn -ENOMEM;\r\nda8xx_ohci = to_da8xx_ohci(hcd);\r\nda8xx_ohci->hcd = hcd;\r\nda8xx_ohci->usb11_clk = devm_clk_get(&pdev->dev, "usb11");\r\nif (IS_ERR(da8xx_ohci->usb11_clk)) {\r\nerror = PTR_ERR(da8xx_ohci->usb11_clk);\r\nif (error != -EPROBE_DEFER)\r\ndev_err(&pdev->dev, "Failed to get clock.\n");\r\ngoto err;\r\n}\r\nda8xx_ohci->usb11_phy = devm_phy_get(&pdev->dev, "usb-phy");\r\nif (IS_ERR(da8xx_ohci->usb11_phy)) {\r\nerror = PTR_ERR(da8xx_ohci->usb11_phy);\r\nif (error != -EPROBE_DEFER)\r\ndev_err(&pdev->dev, "Failed to get phy.\n");\r\ngoto err;\r\n}\r\nda8xx_ohci->vbus_reg = devm_regulator_get_optional(&pdev->dev, "vbus");\r\nif (IS_ERR(da8xx_ohci->vbus_reg)) {\r\nerror = PTR_ERR(da8xx_ohci->vbus_reg);\r\nif (error == -ENODEV) {\r\nda8xx_ohci->vbus_reg = NULL;\r\n} else if (error == -EPROBE_DEFER) {\r\ngoto err;\r\n} else {\r\ndev_err(&pdev->dev, "Failed to get regulator\n");\r\ngoto err;\r\n}\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nhcd->regs = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(hcd->regs)) {\r\nerror = PTR_ERR(hcd->regs);\r\ngoto err;\r\n}\r\nhcd->rsrc_start = mem->start;\r\nhcd->rsrc_len = resource_size(mem);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\nerror = -ENODEV;\r\ngoto err;\r\n}\r\nerror = usb_add_hcd(hcd, irq, 0);\r\nif (error)\r\ngoto err;\r\ndevice_wakeup_enable(hcd->self.controller);\r\nerror = ohci_da8xx_register_notify(hcd);\r\nif (error)\r\ngoto err_remove_hcd;\r\nreturn 0;\r\nerr_remove_hcd:\r\nusb_remove_hcd(hcd);\r\nerr:\r\nusb_put_hcd(hcd);\r\nreturn error;\r\n}\r\nstatic int ohci_da8xx_remove(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nohci_da8xx_unregister_notify(hcd);\r\nusb_remove_hcd(hcd);\r\nusb_put_hcd(hcd);\r\nreturn 0;\r\n}\r\nstatic int ohci_da8xx_suspend(struct platform_device *pdev,\r\npm_message_t message)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nbool do_wakeup = device_may_wakeup(&pdev->dev);\r\nint ret;\r\nif (time_before(jiffies, ohci->next_statechange))\r\nmsleep(5);\r\nohci->next_statechange = jiffies;\r\nret = ohci_suspend(hcd, do_wakeup);\r\nif (ret)\r\nreturn ret;\r\nohci_da8xx_disable(hcd);\r\nhcd->state = HC_STATE_SUSPENDED;\r\nreturn ret;\r\n}\r\nstatic int ohci_da8xx_resume(struct platform_device *dev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(dev);\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nint ret;\r\nif (time_before(jiffies, ohci->next_statechange))\r\nmsleep(5);\r\nohci->next_statechange = jiffies;\r\nret = ohci_da8xx_enable(hcd);\r\nif (ret)\r\nreturn ret;\r\nohci_resume(hcd, false);\r\nreturn 0;\r\n}\r\nstatic int __init ohci_da8xx_init(void)\r\n{\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\npr_info("%s: " DRIVER_DESC "\n", DRV_NAME);\r\nohci_init_driver(&ohci_da8xx_hc_driver, &da8xx_overrides);\r\norig_ohci_hub_control = ohci_da8xx_hc_driver.hub_control;\r\norig_ohci_hub_status_data = ohci_da8xx_hc_driver.hub_status_data;\r\nohci_da8xx_hc_driver.hub_status_data = ohci_da8xx_hub_status_data;\r\nohci_da8xx_hc_driver.hub_control = ohci_da8xx_hub_control;\r\nreturn platform_driver_register(&ohci_hcd_da8xx_driver);\r\n}\r\nstatic void __exit ohci_da8xx_exit(void)\r\n{\r\nplatform_driver_unregister(&ohci_hcd_da8xx_driver);\r\n}
