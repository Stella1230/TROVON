static jsmntok_t *jsmn_alloc_token(jsmn_parser *parser,\r\njsmntok_t *tokens, size_t num_tokens)\r\n{\r\njsmntok_t *tok;\r\nif ((unsigned)parser->toknext >= num_tokens)\r\nreturn NULL;\r\ntok = &tokens[parser->toknext++];\r\ntok->start = tok->end = -1;\r\ntok->size = 0;\r\nreturn tok;\r\n}\r\nstatic void jsmn_fill_token(jsmntok_t *token, jsmntype_t type,\r\nint start, int end)\r\n{\r\ntoken->type = type;\r\ntoken->start = start;\r\ntoken->end = end;\r\ntoken->size = 0;\r\n}\r\nstatic jsmnerr_t jsmn_parse_primitive(jsmn_parser *parser, const char *js,\r\nsize_t len,\r\njsmntok_t *tokens, size_t num_tokens)\r\n{\r\njsmntok_t *token;\r\nint start;\r\nstart = parser->pos;\r\nfor (; parser->pos < len; parser->pos++) {\r\nswitch (js[parser->pos]) {\r\n#ifndef JSMN_STRICT\r\ncase ':':\r\n#endif\r\ncase '\t':\r\ncase '\r':\r\ncase '\n':\r\ncase ' ':\r\ncase ',':\r\ncase ']':\r\ncase '}':\r\ngoto found;\r\ndefault:\r\nbreak;\r\n}\r\nif (js[parser->pos] < 32 || js[parser->pos] >= 127) {\r\nparser->pos = start;\r\nreturn JSMN_ERROR_INVAL;\r\n}\r\n}\r\n#ifdef JSMN_STRICT\r\nparser->pos = start;\r\nreturn JSMN_ERROR_PART;\r\n#endif\r\nfound:\r\ntoken = jsmn_alloc_token(parser, tokens, num_tokens);\r\nif (token == NULL) {\r\nparser->pos = start;\r\nreturn JSMN_ERROR_NOMEM;\r\n}\r\njsmn_fill_token(token, JSMN_PRIMITIVE, start, parser->pos);\r\nparser->pos--;\r\nreturn JSMN_SUCCESS;\r\n}\r\nstatic jsmnerr_t jsmn_parse_string(jsmn_parser *parser, const char *js,\r\nsize_t len,\r\njsmntok_t *tokens, size_t num_tokens)\r\n{\r\njsmntok_t *token;\r\nint start = parser->pos;\r\nparser->pos++;\r\nfor (; parser->pos < len; parser->pos++) {\r\nchar c = js[parser->pos];\r\nif (c == '\"') {\r\ntoken = jsmn_alloc_token(parser, tokens, num_tokens);\r\nif (token == NULL) {\r\nparser->pos = start;\r\nreturn JSMN_ERROR_NOMEM;\r\n}\r\njsmn_fill_token(token, JSMN_STRING, start+1,\r\nparser->pos);\r\nreturn JSMN_SUCCESS;\r\n}\r\nif (c == '\\') {\r\nparser->pos++;\r\nswitch (js[parser->pos]) {\r\ncase '\"':\r\ncase '/':\r\ncase '\\':\r\ncase 'b':\r\ncase 'f':\r\ncase 'r':\r\ncase 'n':\r\ncase 't':\r\nbreak;\r\ncase 'u':\r\nbreak;\r\ndefault:\r\nparser->pos = start;\r\nreturn JSMN_ERROR_INVAL;\r\n}\r\n}\r\n}\r\nparser->pos = start;\r\nreturn JSMN_ERROR_PART;\r\n}\r\njsmnerr_t jsmn_parse(jsmn_parser *parser, const char *js, size_t len,\r\njsmntok_t *tokens, unsigned int num_tokens)\r\n{\r\njsmnerr_t r;\r\nint i;\r\njsmntok_t *token;\r\nfor (; parser->pos < len; parser->pos++) {\r\nchar c;\r\njsmntype_t type;\r\nc = js[parser->pos];\r\nswitch (c) {\r\ncase '{':\r\ncase '[':\r\ntoken = jsmn_alloc_token(parser, tokens, num_tokens);\r\nif (token == NULL)\r\nreturn JSMN_ERROR_NOMEM;\r\nif (parser->toksuper != -1)\r\ntokens[parser->toksuper].size++;\r\ntoken->type = (c == '{' ? JSMN_OBJECT : JSMN_ARRAY);\r\ntoken->start = parser->pos;\r\nparser->toksuper = parser->toknext - 1;\r\nbreak;\r\ncase '}':\r\ncase ']':\r\ntype = (c == '}' ? JSMN_OBJECT : JSMN_ARRAY);\r\nfor (i = parser->toknext - 1; i >= 0; i--) {\r\ntoken = &tokens[i];\r\nif (token->start != -1 && token->end == -1) {\r\nif (token->type != type)\r\nreturn JSMN_ERROR_INVAL;\r\nparser->toksuper = -1;\r\ntoken->end = parser->pos + 1;\r\nbreak;\r\n}\r\n}\r\nif (i == -1)\r\nreturn JSMN_ERROR_INVAL;\r\nfor (; i >= 0; i--) {\r\ntoken = &tokens[i];\r\nif (token->start != -1 && token->end == -1) {\r\nparser->toksuper = i;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase '\"':\r\nr = jsmn_parse_string(parser, js, len, tokens,\r\nnum_tokens);\r\nif (r < 0)\r\nreturn r;\r\nif (parser->toksuper != -1)\r\ntokens[parser->toksuper].size++;\r\nbreak;\r\ncase '\t':\r\ncase '\r':\r\ncase '\n':\r\ncase ':':\r\ncase ',':\r\ncase ' ':\r\nbreak;\r\n#ifdef JSMN_STRICT\r\ncase '-':\r\ncase '0':\r\ncase '1':\r\ncase '2':\r\ncase '3':\r\ncase '4':\r\ncase '5':\r\ncase '6':\r\ncase '7':\r\ncase '8':\r\ncase '9':\r\ncase 't':\r\ncase 'f':\r\ncase 'n':\r\n#else\r\ndefault:\r\n#endif\r\nr = jsmn_parse_primitive(parser, js, len, tokens,\r\nnum_tokens);\r\nif (r < 0)\r\nreturn r;\r\nif (parser->toksuper != -1)\r\ntokens[parser->toksuper].size++;\r\nbreak;\r\n#ifdef JSMN_STRICT\r\ndefault:\r\nreturn JSMN_ERROR_INVAL;\r\n#endif\r\n}\r\n}\r\nfor (i = parser->toknext - 1; i >= 0; i--) {\r\nif (tokens[i].start != -1 && tokens[i].end == -1)\r\nreturn JSMN_ERROR_PART;\r\n}\r\nreturn JSMN_SUCCESS;\r\n}\r\nvoid jsmn_init(jsmn_parser *parser)\r\n{\r\nparser->pos = 0;\r\nparser->toknext = 0;\r\nparser->toksuper = -1;\r\n}\r\nconst char *jsmn_strerror(jsmnerr_t err)\r\n{\r\nswitch (err) {\r\ncase JSMN_ERROR_NOMEM:\r\nreturn "No enough tokens";\r\ncase JSMN_ERROR_INVAL:\r\nreturn "Invalid character inside JSON string";\r\ncase JSMN_ERROR_PART:\r\nreturn "The string is not a full JSON packet, more bytes expected";\r\ncase JSMN_SUCCESS:\r\nreturn "Success";\r\ndefault:\r\nreturn "Unknown json error";\r\n}\r\n}
