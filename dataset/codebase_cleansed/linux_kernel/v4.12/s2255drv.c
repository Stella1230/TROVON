static inline struct s2255_dev *to_s2255_dev(struct v4l2_device *v4l2_dev)\r\n{\r\nreturn container_of(v4l2_dev, struct s2255_dev, v4l2_dev);\r\n}\r\nstatic int norm_maxw(struct s2255_vc *vc)\r\n{\r\nreturn (vc->std & V4L2_STD_525_60) ?\r\nLINE_SZ_4CIFS_NTSC : LINE_SZ_4CIFS_PAL;\r\n}\r\nstatic int norm_maxh(struct s2255_vc *vc)\r\n{\r\nreturn (vc->std & V4L2_STD_525_60) ?\r\n(NUM_LINES_1CIFS_NTSC * 2) : (NUM_LINES_1CIFS_PAL * 2);\r\n}\r\nstatic int norm_minw(struct s2255_vc *vc)\r\n{\r\nreturn (vc->std & V4L2_STD_525_60) ?\r\nLINE_SZ_1CIFS_NTSC : LINE_SZ_1CIFS_PAL;\r\n}\r\nstatic int norm_minh(struct s2255_vc *vc)\r\n{\r\nreturn (vc->std & V4L2_STD_525_60) ?\r\n(NUM_LINES_1CIFS_NTSC) : (NUM_LINES_1CIFS_PAL);\r\n}\r\nstatic void planar422p_to_yuv_packed(const unsigned char *in,\r\nunsigned char *out,\r\nint width, int height,\r\nint fmt)\r\n{\r\nunsigned char *pY;\r\nunsigned char *pCb;\r\nunsigned char *pCr;\r\nunsigned long size = height * width;\r\nunsigned int i;\r\npY = (unsigned char *)in;\r\npCr = (unsigned char *)in + height * width;\r\npCb = (unsigned char *)in + height * width + (height * width / 2);\r\nfor (i = 0; i < size * 2; i += 4) {\r\nout[i] = (fmt == V4L2_PIX_FMT_YUYV) ? *pY++ : *pCr++;\r\nout[i + 1] = (fmt == V4L2_PIX_FMT_YUYV) ? *pCr++ : *pY++;\r\nout[i + 2] = (fmt == V4L2_PIX_FMT_YUYV) ? *pY++ : *pCb++;\r\nout[i + 3] = (fmt == V4L2_PIX_FMT_YUYV) ? *pCb++ : *pY++;\r\n}\r\nreturn;\r\n}\r\nstatic void s2255_reset_dsppower(struct s2255_dev *dev)\r\n{\r\ns2255_vendor_req(dev, 0x40, 0x0000, 0x0001, NULL, 0, 1);\r\nmsleep(20);\r\ns2255_vendor_req(dev, 0x50, 0x0000, 0x0000, NULL, 0, 1);\r\nmsleep(600);\r\ns2255_vendor_req(dev, 0x10, 0x0000, 0x0000, NULL, 0, 1);\r\nreturn;\r\n}\r\nstatic void s2255_timer(unsigned long user_data)\r\n{\r\nstruct s2255_fw *data = (struct s2255_fw *)user_data;\r\nif (usb_submit_urb(data->fw_urb, GFP_ATOMIC) < 0) {\r\npr_err("s2255: can't submit urb\n");\r\natomic_set(&data->fw_state, S2255_FW_FAILED);\r\nwake_up(&data->wait_fw);\r\nreturn;\r\n}\r\n}\r\nstatic void s2255_fwchunk_complete(struct urb *urb)\r\n{\r\nstruct s2255_fw *data = urb->context;\r\nstruct usb_device *udev = urb->dev;\r\nint len;\r\nif (urb->status) {\r\ndev_err(&udev->dev, "URB failed with status %d\n", urb->status);\r\natomic_set(&data->fw_state, S2255_FW_FAILED);\r\nwake_up(&data->wait_fw);\r\nreturn;\r\n}\r\nif (data->fw_urb == NULL) {\r\ns2255_dev_err(&udev->dev, "disconnected\n");\r\natomic_set(&data->fw_state, S2255_FW_FAILED);\r\nwake_up(&data->wait_fw);\r\nreturn;\r\n}\r\n#define CHUNK_SIZE 512\r\nif (data->fw_loaded < data->fw_size) {\r\nlen = (data->fw_loaded + CHUNK_SIZE) > data->fw_size ?\r\ndata->fw_size % CHUNK_SIZE : CHUNK_SIZE;\r\nif (len < CHUNK_SIZE)\r\nmemset(data->pfw_data, 0, CHUNK_SIZE);\r\nmemcpy(data->pfw_data,\r\n(char *) data->fw->data + data->fw_loaded, len);\r\nusb_fill_bulk_urb(data->fw_urb, udev, usb_sndbulkpipe(udev, 2),\r\ndata->pfw_data, CHUNK_SIZE,\r\ns2255_fwchunk_complete, data);\r\nif (usb_submit_urb(data->fw_urb, GFP_ATOMIC) < 0) {\r\ndev_err(&udev->dev, "failed submit URB\n");\r\natomic_set(&data->fw_state, S2255_FW_FAILED);\r\nwake_up(&data->wait_fw);\r\nreturn;\r\n}\r\ndata->fw_loaded += len;\r\n} else\r\natomic_set(&data->fw_state, S2255_FW_LOADED_DSPWAIT);\r\nreturn;\r\n}\r\nstatic void s2255_got_frame(struct s2255_vc *vc, int jpgsize)\r\n{\r\nstruct s2255_buffer *buf;\r\nstruct s2255_dev *dev = to_s2255_dev(vc->vdev.v4l2_dev);\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(&vc->qlock, flags);\r\nif (list_empty(&vc->buf_list)) {\r\ndprintk(dev, 1, "No active queue to serve\n");\r\nspin_unlock_irqrestore(&vc->qlock, flags);\r\nreturn;\r\n}\r\nbuf = list_entry(vc->buf_list.next,\r\nstruct s2255_buffer, list);\r\nlist_del(&buf->list);\r\nbuf->vb.vb2_buf.timestamp = ktime_get_ns();\r\nbuf->vb.field = vc->field;\r\nbuf->vb.sequence = vc->frame_count;\r\nspin_unlock_irqrestore(&vc->qlock, flags);\r\ns2255_fillbuff(vc, buf, jpgsize);\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_DONE);\r\ndprintk(dev, 2, "%s: [buf] [%p]\n", __func__, buf);\r\n}\r\nstatic const struct s2255_fmt *format_by_fourcc(int fourcc)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(formats); i++) {\r\nif (-1 == formats[i].fourcc)\r\ncontinue;\r\nif (!jpeg_enable && ((formats[i].fourcc == V4L2_PIX_FMT_JPEG) ||\r\n(formats[i].fourcc == V4L2_PIX_FMT_MJPEG)))\r\ncontinue;\r\nif (formats[i].fourcc == fourcc)\r\nreturn formats + i;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void s2255_fillbuff(struct s2255_vc *vc,\r\nstruct s2255_buffer *buf, int jpgsize)\r\n{\r\nint pos = 0;\r\nconst char *tmpbuf;\r\nchar *vbuf = vb2_plane_vaddr(&buf->vb.vb2_buf, 0);\r\nunsigned long last_frame;\r\nstruct s2255_dev *dev = vc->dev;\r\nif (!vbuf)\r\nreturn;\r\nlast_frame = vc->last_frame;\r\nif (last_frame != -1) {\r\ntmpbuf =\r\n(const char *)vc->buffer.frame[last_frame].lpvbits;\r\nswitch (vc->fmt->fourcc) {\r\ncase V4L2_PIX_FMT_YUYV:\r\ncase V4L2_PIX_FMT_UYVY:\r\nplanar422p_to_yuv_packed((const unsigned char *)tmpbuf,\r\nvbuf, vc->width,\r\nvc->height,\r\nvc->fmt->fourcc);\r\nbreak;\r\ncase V4L2_PIX_FMT_GREY:\r\nmemcpy(vbuf, tmpbuf, vc->width * vc->height);\r\nbreak;\r\ncase V4L2_PIX_FMT_JPEG:\r\ncase V4L2_PIX_FMT_MJPEG:\r\nvb2_set_plane_payload(&buf->vb.vb2_buf, 0, jpgsize);\r\nmemcpy(vbuf, tmpbuf, jpgsize);\r\nbreak;\r\ncase V4L2_PIX_FMT_YUV422P:\r\nmemcpy(vbuf, tmpbuf,\r\nvc->width * vc->height * 2);\r\nbreak;\r\ndefault:\r\npr_info("s2255: unknown format?\n");\r\n}\r\nvc->last_frame = -1;\r\n} else {\r\npr_err("s2255: =======no frame\n");\r\nreturn;\r\n}\r\ndprintk(dev, 2, "s2255fill at : Buffer 0x%08lx size= %d\n",\r\n(unsigned long)vbuf, pos);\r\n}\r\nstatic int queue_setup(struct vb2_queue *vq,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], struct device *alloc_devs[])\r\n{\r\nstruct s2255_vc *vc = vb2_get_drv_priv(vq);\r\nif (*nbuffers < S2255_MIN_BUFS)\r\n*nbuffers = S2255_MIN_BUFS;\r\n*nplanes = 1;\r\nsizes[0] = vc->width * vc->height * (vc->fmt->depth >> 3);\r\nreturn 0;\r\n}\r\nstatic int buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct s2255_vc *vc = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct s2255_buffer *buf = container_of(vbuf, struct s2255_buffer, vb);\r\nint w = vc->width;\r\nint h = vc->height;\r\nunsigned long size;\r\ndprintk(vc->dev, 4, "%s\n", __func__);\r\nif (vc->fmt == NULL)\r\nreturn -EINVAL;\r\nif ((w < norm_minw(vc)) ||\r\n(w > norm_maxw(vc)) ||\r\n(h < norm_minh(vc)) ||\r\n(h > norm_maxh(vc))) {\r\ndprintk(vc->dev, 4, "invalid buffer prepare\n");\r\nreturn -EINVAL;\r\n}\r\nsize = w * h * (vc->fmt->depth >> 3);\r\nif (vb2_plane_size(vb, 0) < size) {\r\ndprintk(vc->dev, 4, "invalid buffer prepare\n");\r\nreturn -EINVAL;\r\n}\r\nvb2_set_plane_payload(&buf->vb.vb2_buf, 0, size);\r\nreturn 0;\r\n}\r\nstatic void buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct s2255_buffer *buf = container_of(vbuf, struct s2255_buffer, vb);\r\nstruct s2255_vc *vc = vb2_get_drv_priv(vb->vb2_queue);\r\nunsigned long flags = 0;\r\ndprintk(vc->dev, 1, "%s\n", __func__);\r\nspin_lock_irqsave(&vc->qlock, flags);\r\nlist_add_tail(&buf->list, &vc->buf_list);\r\nspin_unlock_irqrestore(&vc->qlock, flags);\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct s2255_vc *vc = video_drvdata(file);\r\nstruct s2255_dev *dev = vc->dev;\r\nstrlcpy(cap->driver, "s2255", sizeof(cap->driver));\r\nstrlcpy(cap->card, "s2255", sizeof(cap->card));\r\nusb_make_path(dev->udev, cap->bus_info, sizeof(cap->bus_info));\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING |\r\nV4L2_CAP_READWRITE;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nint index = f->index;\r\nif (index >= ARRAY_SIZE(formats))\r\nreturn -EINVAL;\r\nif (!jpeg_enable && ((formats[index].fourcc == V4L2_PIX_FMT_JPEG) ||\r\n(formats[index].fourcc == V4L2_PIX_FMT_MJPEG)))\r\nreturn -EINVAL;\r\nstrlcpy(f->description, formats[index].name, sizeof(f->description));\r\nf->pixelformat = formats[index].fourcc;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct s2255_vc *vc = video_drvdata(file);\r\nint is_ntsc = vc->std & V4L2_STD_525_60;\r\nf->fmt.pix.width = vc->width;\r\nf->fmt.pix.height = vc->height;\r\nif (f->fmt.pix.height >=\r\n(is_ntsc ? NUM_LINES_1CIFS_NTSC : NUM_LINES_1CIFS_PAL) * 2)\r\nf->fmt.pix.field = V4L2_FIELD_INTERLACED;\r\nelse\r\nf->fmt.pix.field = V4L2_FIELD_TOP;\r\nf->fmt.pix.pixelformat = vc->fmt->fourcc;\r\nf->fmt.pix.bytesperline = f->fmt.pix.width * (vc->fmt->depth >> 3);\r\nf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nf->fmt.pix.priv = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nconst struct s2255_fmt *fmt;\r\nenum v4l2_field field;\r\nstruct s2255_vc *vc = video_drvdata(file);\r\nint is_ntsc = vc->std & V4L2_STD_525_60;\r\nfmt = format_by_fourcc(f->fmt.pix.pixelformat);\r\nif (fmt == NULL)\r\nreturn -EINVAL;\r\nfield = f->fmt.pix.field;\r\ndprintk(vc->dev, 50, "%s NTSC: %d suggested width: %d, height: %d\n",\r\n__func__, is_ntsc, f->fmt.pix.width, f->fmt.pix.height);\r\nif (is_ntsc) {\r\nif (f->fmt.pix.height >= NUM_LINES_1CIFS_NTSC * 2) {\r\nf->fmt.pix.height = NUM_LINES_1CIFS_NTSC * 2;\r\nfield = V4L2_FIELD_INTERLACED;\r\n} else {\r\nf->fmt.pix.height = NUM_LINES_1CIFS_NTSC;\r\nfield = V4L2_FIELD_TOP;\r\n}\r\nif (f->fmt.pix.width >= LINE_SZ_4CIFS_NTSC)\r\nf->fmt.pix.width = LINE_SZ_4CIFS_NTSC;\r\nelse if (f->fmt.pix.width >= LINE_SZ_2CIFS_NTSC)\r\nf->fmt.pix.width = LINE_SZ_2CIFS_NTSC;\r\nelse if (f->fmt.pix.width >= LINE_SZ_1CIFS_NTSC)\r\nf->fmt.pix.width = LINE_SZ_1CIFS_NTSC;\r\nelse\r\nf->fmt.pix.width = LINE_SZ_1CIFS_NTSC;\r\n} else {\r\nif (f->fmt.pix.height >= NUM_LINES_1CIFS_PAL * 2) {\r\nf->fmt.pix.height = NUM_LINES_1CIFS_PAL * 2;\r\nfield = V4L2_FIELD_INTERLACED;\r\n} else {\r\nf->fmt.pix.height = NUM_LINES_1CIFS_PAL;\r\nfield = V4L2_FIELD_TOP;\r\n}\r\nif (f->fmt.pix.width >= LINE_SZ_4CIFS_PAL)\r\nf->fmt.pix.width = LINE_SZ_4CIFS_PAL;\r\nelse if (f->fmt.pix.width >= LINE_SZ_2CIFS_PAL)\r\nf->fmt.pix.width = LINE_SZ_2CIFS_PAL;\r\nelse if (f->fmt.pix.width >= LINE_SZ_1CIFS_PAL)\r\nf->fmt.pix.width = LINE_SZ_1CIFS_PAL;\r\nelse\r\nf->fmt.pix.width = LINE_SZ_1CIFS_PAL;\r\n}\r\nf->fmt.pix.field = field;\r\nf->fmt.pix.bytesperline = (f->fmt.pix.width * fmt->depth) >> 3;\r\nf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nf->fmt.pix.priv = 0;\r\ndprintk(vc->dev, 50, "%s: set width %d height %d field %d\n", __func__,\r\nf->fmt.pix.width, f->fmt.pix.height, f->fmt.pix.field);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct s2255_vc *vc = video_drvdata(file);\r\nconst struct s2255_fmt *fmt;\r\nstruct vb2_queue *q = &vc->vb_vidq;\r\nstruct s2255_mode mode;\r\nint ret;\r\nret = vidioc_try_fmt_vid_cap(file, vc, f);\r\nif (ret < 0)\r\nreturn ret;\r\nfmt = format_by_fourcc(f->fmt.pix.pixelformat);\r\nif (fmt == NULL)\r\nreturn -EINVAL;\r\nif (vb2_is_busy(q)) {\r\ndprintk(vc->dev, 1, "queue busy\n");\r\nreturn -EBUSY;\r\n}\r\nmode = vc->mode;\r\nvc->fmt = fmt;\r\nvc->width = f->fmt.pix.width;\r\nvc->height = f->fmt.pix.height;\r\nvc->field = f->fmt.pix.field;\r\nif (vc->width > norm_minw(vc)) {\r\nif (vc->height > norm_minh(vc)) {\r\nif (vc->cap_parm.capturemode &\r\nV4L2_MODE_HIGHQUALITY)\r\nmode.scale = SCALE_4CIFSI;\r\nelse\r\nmode.scale = SCALE_4CIFS;\r\n} else\r\nmode.scale = SCALE_2CIFS;\r\n} else {\r\nmode.scale = SCALE_1CIFS;\r\n}\r\nswitch (vc->fmt->fourcc) {\r\ncase V4L2_PIX_FMT_GREY:\r\nmode.color &= ~MASK_COLOR;\r\nmode.color |= COLOR_Y8;\r\nbreak;\r\ncase V4L2_PIX_FMT_JPEG:\r\ncase V4L2_PIX_FMT_MJPEG:\r\nmode.color &= ~MASK_COLOR;\r\nmode.color |= COLOR_JPG;\r\nmode.color |= (vc->jpegqual << 8);\r\nbreak;\r\ncase V4L2_PIX_FMT_YUV422P:\r\nmode.color &= ~MASK_COLOR;\r\nmode.color |= COLOR_YUVPL;\r\nbreak;\r\ncase V4L2_PIX_FMT_YUYV:\r\ncase V4L2_PIX_FMT_UYVY:\r\ndefault:\r\nmode.color &= ~MASK_COLOR;\r\nmode.color |= COLOR_YUVPK;\r\nbreak;\r\n}\r\nif ((mode.color & MASK_COLOR) != (vc->mode.color & MASK_COLOR))\r\nmode.restart = 1;\r\nelse if (mode.scale != vc->mode.scale)\r\nmode.restart = 1;\r\nelse if (mode.format != vc->mode.format)\r\nmode.restart = 1;\r\nvc->mode = mode;\r\n(void) s2255_set_mode(vc, &mode);\r\nreturn 0;\r\n}\r\nstatic int s2255_write_config(struct usb_device *udev, unsigned char *pbuf,\r\nint size)\r\n{\r\nint pipe;\r\nint done;\r\nlong retval = -1;\r\nif (udev) {\r\npipe = usb_sndbulkpipe(udev, S2255_CONFIG_EP);\r\nretval = usb_bulk_msg(udev, pipe, pbuf, size, &done, 500);\r\n}\r\nreturn retval;\r\n}\r\nstatic u32 get_transfer_size(struct s2255_mode *mode)\r\n{\r\nint linesPerFrame = LINE_SZ_DEF;\r\nint pixelsPerLine = NUM_LINES_DEF;\r\nu32 outImageSize;\r\nu32 usbInSize;\r\nunsigned int mask_mult;\r\nif (mode == NULL)\r\nreturn 0;\r\nif (mode->format == FORMAT_NTSC) {\r\nswitch (mode->scale) {\r\ncase SCALE_4CIFS:\r\ncase SCALE_4CIFSI:\r\nlinesPerFrame = NUM_LINES_4CIFS_NTSC * 2;\r\npixelsPerLine = LINE_SZ_4CIFS_NTSC;\r\nbreak;\r\ncase SCALE_2CIFS:\r\nlinesPerFrame = NUM_LINES_2CIFS_NTSC;\r\npixelsPerLine = LINE_SZ_2CIFS_NTSC;\r\nbreak;\r\ncase SCALE_1CIFS:\r\nlinesPerFrame = NUM_LINES_1CIFS_NTSC;\r\npixelsPerLine = LINE_SZ_1CIFS_NTSC;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else if (mode->format == FORMAT_PAL) {\r\nswitch (mode->scale) {\r\ncase SCALE_4CIFS:\r\ncase SCALE_4CIFSI:\r\nlinesPerFrame = NUM_LINES_4CIFS_PAL * 2;\r\npixelsPerLine = LINE_SZ_4CIFS_PAL;\r\nbreak;\r\ncase SCALE_2CIFS:\r\nlinesPerFrame = NUM_LINES_2CIFS_PAL;\r\npixelsPerLine = LINE_SZ_2CIFS_PAL;\r\nbreak;\r\ncase SCALE_1CIFS:\r\nlinesPerFrame = NUM_LINES_1CIFS_PAL;\r\npixelsPerLine = LINE_SZ_1CIFS_PAL;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\noutImageSize = linesPerFrame * pixelsPerLine;\r\nif ((mode->color & MASK_COLOR) != COLOR_Y8) {\r\noutImageSize *= 2;\r\n}\r\nusbInSize = outImageSize + PREFIX_SIZE;\r\nmask_mult = 0xffffffffUL - DEF_USB_BLOCK + 1;\r\nif (usbInSize & ~mask_mult)\r\nusbInSize = (usbInSize & mask_mult) + (DEF_USB_BLOCK);\r\nreturn usbInSize;\r\n}\r\nstatic void s2255_print_cfg(struct s2255_dev *sdev, struct s2255_mode *mode)\r\n{\r\nstruct device *dev = &sdev->udev->dev;\r\ndev_info(dev, "------------------------------------------------\n");\r\ndev_info(dev, "format: %d\nscale %d\n", mode->format, mode->scale);\r\ndev_info(dev, "fdec: %d\ncolor %d\n", mode->fdec, mode->color);\r\ndev_info(dev, "bright: 0x%x\n", mode->bright);\r\ndev_info(dev, "------------------------------------------------\n");\r\n}\r\nstatic int s2255_set_mode(struct s2255_vc *vc,\r\nstruct s2255_mode *mode)\r\n{\r\nint res;\r\nunsigned long chn_rev;\r\nstruct s2255_dev *dev = to_s2255_dev(vc->vdev.v4l2_dev);\r\nint i;\r\n__le32 *buffer = dev->cmdbuf;\r\nmutex_lock(&dev->cmdlock);\r\nchn_rev = G_chnmap[vc->idx];\r\ndprintk(dev, 3, "%s channel: %d\n", __func__, vc->idx);\r\nif ((mode->color & MASK_COLOR) == COLOR_JPG) {\r\nmode->color &= ~MASK_COLOR;\r\nmode->color |= COLOR_JPG;\r\nmode->color &= ~MASK_JPG_QUALITY;\r\nmode->color |= (vc->jpegqual << 8);\r\n}\r\nvc->mode = *mode;\r\nvc->req_image_size = get_transfer_size(mode);\r\ndprintk(dev, 1, "%s: reqsize %ld\n", __func__, vc->req_image_size);\r\nbuffer[0] = IN_DATA_TOKEN;\r\nbuffer[1] = (__le32) cpu_to_le32(chn_rev);\r\nbuffer[2] = CMD_SET_MODE;\r\nfor (i = 0; i < sizeof(struct s2255_mode) / sizeof(u32); i++)\r\nbuffer[3 + i] = cpu_to_le32(((u32 *)&vc->mode)[i]);\r\nvc->setmode_ready = 0;\r\nres = s2255_write_config(dev->udev, (unsigned char *)buffer, 512);\r\nif (debug)\r\ns2255_print_cfg(dev, mode);\r\nif (mode->restart) {\r\nwait_event_timeout(vc->wait_setmode,\r\n(vc->setmode_ready != 0),\r\nmsecs_to_jiffies(S2255_SETMODE_TIMEOUT));\r\nif (vc->setmode_ready != 1) {\r\ndprintk(dev, 0, "s2255: no set mode response\n");\r\nres = -EFAULT;\r\n}\r\n}\r\nvc->mode.restart = 0;\r\ndprintk(dev, 1, "%s chn %d, result: %d\n", __func__, vc->idx, res);\r\nmutex_unlock(&dev->cmdlock);\r\nreturn res;\r\n}\r\nstatic int s2255_cmd_status(struct s2255_vc *vc, u32 *pstatus)\r\n{\r\nint res;\r\nu32 chn_rev;\r\nstruct s2255_dev *dev = to_s2255_dev(vc->vdev.v4l2_dev);\r\n__le32 *buffer = dev->cmdbuf;\r\nmutex_lock(&dev->cmdlock);\r\nchn_rev = G_chnmap[vc->idx];\r\ndprintk(dev, 4, "%s chan %d\n", __func__, vc->idx);\r\nbuffer[0] = IN_DATA_TOKEN;\r\nbuffer[1] = (__le32) cpu_to_le32(chn_rev);\r\nbuffer[2] = CMD_STATUS;\r\n*pstatus = 0;\r\nvc->vidstatus_ready = 0;\r\nres = s2255_write_config(dev->udev, (unsigned char *)buffer, 512);\r\nwait_event_timeout(vc->wait_vidstatus,\r\n(vc->vidstatus_ready != 0),\r\nmsecs_to_jiffies(S2255_VIDSTATUS_TIMEOUT));\r\nif (vc->vidstatus_ready != 1) {\r\ndprintk(dev, 0, "s2255: no vidstatus response\n");\r\nres = -EFAULT;\r\n}\r\n*pstatus = vc->vidstatus;\r\ndprintk(dev, 4, "%s, vid status %d\n", __func__, *pstatus);\r\nmutex_unlock(&dev->cmdlock);\r\nreturn res;\r\n}\r\nstatic int start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct s2255_vc *vc = vb2_get_drv_priv(vq);\r\nint j;\r\nvc->last_frame = -1;\r\nvc->bad_payload = 0;\r\nvc->cur_frame = 0;\r\nvc->frame_count = 0;\r\nfor (j = 0; j < SYS_FRAMES; j++) {\r\nvc->buffer.frame[j].ulState = S2255_READ_IDLE;\r\nvc->buffer.frame[j].cur_size = 0;\r\n}\r\nreturn s2255_start_acquire(vc);\r\n}\r\nstatic void stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct s2255_vc *vc = vb2_get_drv_priv(vq);\r\nstruct s2255_buffer *buf, *node;\r\nunsigned long flags;\r\n(void) s2255_stop_acquire(vc);\r\nspin_lock_irqsave(&vc->qlock, flags);\r\nlist_for_each_entry_safe(buf, node, &vc->buf_list, list) {\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\r\ndprintk(vc->dev, 2, "[%p/%d] done\n",\r\nbuf, buf->vb.vb2_buf.index);\r\n}\r\nspin_unlock_irqrestore(&vc->qlock, flags);\r\n}\r\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id i)\r\n{\r\nstruct s2255_vc *vc = video_drvdata(file);\r\nstruct s2255_mode mode;\r\nstruct vb2_queue *q = &vc->vb_vidq;\r\nif (vb2_is_busy(q))\r\nreturn -EBUSY;\r\nmode = vc->mode;\r\nif (i & V4L2_STD_525_60) {\r\ndprintk(vc->dev, 4, "%s 60 Hz\n", __func__);\r\nif (mode.format != FORMAT_NTSC) {\r\nmode.restart = 1;\r\nmode.format = FORMAT_NTSC;\r\nmode.fdec = FDEC_1;\r\nvc->width = LINE_SZ_4CIFS_NTSC;\r\nvc->height = NUM_LINES_4CIFS_NTSC * 2;\r\n}\r\n} else if (i & V4L2_STD_625_50) {\r\ndprintk(vc->dev, 4, "%s 50 Hz\n", __func__);\r\nif (mode.format != FORMAT_PAL) {\r\nmode.restart = 1;\r\nmode.format = FORMAT_PAL;\r\nmode.fdec = FDEC_1;\r\nvc->width = LINE_SZ_4CIFS_PAL;\r\nvc->height = NUM_LINES_4CIFS_PAL * 2;\r\n}\r\n} else\r\nreturn -EINVAL;\r\nvc->std = i;\r\nif (mode.restart)\r\ns2255_set_mode(vc, &mode);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *i)\r\n{\r\nstruct s2255_vc *vc = video_drvdata(file);\r\n*i = vc->std;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *inp)\r\n{\r\nstruct s2255_vc *vc = video_drvdata(file);\r\nstruct s2255_dev *dev = vc->dev;\r\nu32 status = 0;\r\nif (inp->index != 0)\r\nreturn -EINVAL;\r\ninp->type = V4L2_INPUT_TYPE_CAMERA;\r\ninp->std = S2255_NORMS;\r\ninp->status = 0;\r\nif (dev->dsp_fw_ver >= S2255_MIN_DSP_STATUS) {\r\nint rc;\r\nrc = s2255_cmd_status(vc, &status);\r\ndprintk(dev, 4, "s2255_cmd_status rc: %d status %x\n",\r\nrc, status);\r\nif (rc == 0)\r\ninp->status = (status & 0x01) ? 0\r\n: V4L2_IN_ST_NO_SIGNAL;\r\n}\r\nswitch (dev->pid) {\r\ncase 0x2255:\r\ndefault:\r\nstrlcpy(inp->name, "Composite", sizeof(inp->name));\r\nbreak;\r\ncase 0x2257:\r\nstrlcpy(inp->name, (vc->idx < 2) ? "Composite" : "S-Video",\r\nsizeof(inp->name));\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nif (i > 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int s2255_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct s2255_vc *vc =\r\ncontainer_of(ctrl->handler, struct s2255_vc, hdl);\r\nstruct s2255_mode mode;\r\nmode = vc->mode;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nmode.bright = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nmode.contrast = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nmode.hue = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nmode.saturation = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_S2255_COLORFILTER:\r\nmode.color &= ~MASK_INPUT_TYPE;\r\nmode.color |= !ctrl->val << 16;\r\nbreak;\r\ncase V4L2_CID_JPEG_COMPRESSION_QUALITY:\r\nvc->jpegqual = ctrl->val;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmode.restart = 0;\r\ns2255_set_mode(vc, &mode);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_jpegcomp(struct file *file, void *priv,\r\nstruct v4l2_jpegcompression *jc)\r\n{\r\nstruct s2255_vc *vc = video_drvdata(file);\r\nmemset(jc, 0, sizeof(*jc));\r\njc->quality = vc->jpegqual;\r\ndprintk(vc->dev, 2, "%s: quality %d\n", __func__, jc->quality);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_jpegcomp(struct file *file, void *priv,\r\nconst struct v4l2_jpegcompression *jc)\r\n{\r\nstruct s2255_vc *vc = video_drvdata(file);\r\nif (jc->quality < 0 || jc->quality > 100)\r\nreturn -EINVAL;\r\nv4l2_ctrl_s_ctrl(vc->jpegqual_ctrl, jc->quality);\r\ndprintk(vc->dev, 2, "%s: quality %d\n", __func__, jc->quality);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_parm(struct file *file, void *priv,\r\nstruct v4l2_streamparm *sp)\r\n{\r\n__u32 def_num, def_dem;\r\nstruct s2255_vc *vc = video_drvdata(file);\r\nif (sp->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nsp->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;\r\nsp->parm.capture.capturemode = vc->cap_parm.capturemode;\r\nsp->parm.capture.readbuffers = S2255_MIN_BUFS;\r\ndef_num = (vc->mode.format == FORMAT_NTSC) ? 1001 : 1000;\r\ndef_dem = (vc->mode.format == FORMAT_NTSC) ? 30000 : 25000;\r\nsp->parm.capture.timeperframe.denominator = def_dem;\r\nswitch (vc->mode.fdec) {\r\ndefault:\r\ncase FDEC_1:\r\nsp->parm.capture.timeperframe.numerator = def_num;\r\nbreak;\r\ncase FDEC_2:\r\nsp->parm.capture.timeperframe.numerator = def_num * 2;\r\nbreak;\r\ncase FDEC_3:\r\nsp->parm.capture.timeperframe.numerator = def_num * 3;\r\nbreak;\r\ncase FDEC_5:\r\nsp->parm.capture.timeperframe.numerator = def_num * 5;\r\nbreak;\r\n}\r\ndprintk(vc->dev, 4, "%s capture mode, %d timeperframe %d/%d\n",\r\n__func__,\r\nsp->parm.capture.capturemode,\r\nsp->parm.capture.timeperframe.numerator,\r\nsp->parm.capture.timeperframe.denominator);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_parm(struct file *file, void *priv,\r\nstruct v4l2_streamparm *sp)\r\n{\r\nstruct s2255_vc *vc = video_drvdata(file);\r\nstruct s2255_mode mode;\r\nint fdec = FDEC_1;\r\n__u32 def_num, def_dem;\r\nif (sp->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nmode = vc->mode;\r\nif ((vc->cap_parm.capturemode != sp->parm.capture.capturemode)\r\n&& vb2_is_streaming(&vc->vb_vidq))\r\nreturn -EBUSY;\r\ndef_num = (mode.format == FORMAT_NTSC) ? 1001 : 1000;\r\ndef_dem = (mode.format == FORMAT_NTSC) ? 30000 : 25000;\r\nif (def_dem != sp->parm.capture.timeperframe.denominator)\r\nsp->parm.capture.timeperframe.numerator = def_num;\r\nelse if (sp->parm.capture.timeperframe.numerator <= def_num)\r\nsp->parm.capture.timeperframe.numerator = def_num;\r\nelse if (sp->parm.capture.timeperframe.numerator <= (def_num * 2)) {\r\nsp->parm.capture.timeperframe.numerator = def_num * 2;\r\nfdec = FDEC_2;\r\n} else if (sp->parm.capture.timeperframe.numerator <= (def_num * 3)) {\r\nsp->parm.capture.timeperframe.numerator = def_num * 3;\r\nfdec = FDEC_3;\r\n} else {\r\nsp->parm.capture.timeperframe.numerator = def_num * 5;\r\nfdec = FDEC_5;\r\n}\r\nmode.fdec = fdec;\r\nsp->parm.capture.timeperframe.denominator = def_dem;\r\nsp->parm.capture.readbuffers = S2255_MIN_BUFS;\r\ns2255_set_mode(vc, &mode);\r\ndprintk(vc->dev, 4, "%s capture mode, %d timeperframe %d/%d, fdec %d\n",\r\n__func__,\r\nsp->parm.capture.capturemode,\r\nsp->parm.capture.timeperframe.numerator,\r\nsp->parm.capture.timeperframe.denominator, fdec);\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_framesizes(struct file *file, void *priv,\r\nstruct v4l2_frmsizeenum *fe)\r\n{\r\nstruct s2255_vc *vc = video_drvdata(file);\r\nint is_ntsc = vc->std & V4L2_STD_525_60;\r\nconst struct s2255_fmt *fmt;\r\nif (fe->index >= NUM_SIZE_ENUMS)\r\nreturn -EINVAL;\r\nfmt = format_by_fourcc(fe->pixel_format);\r\nif (fmt == NULL)\r\nreturn -EINVAL;\r\nfe->type = V4L2_FRMSIZE_TYPE_DISCRETE;\r\nfe->discrete = is_ntsc ? ntsc_sizes[fe->index] : pal_sizes[fe->index];\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_frameintervals(struct file *file, void *priv,\r\nstruct v4l2_frmivalenum *fe)\r\n{\r\nstruct s2255_vc *vc = video_drvdata(file);\r\nconst struct s2255_fmt *fmt;\r\nconst struct v4l2_frmsize_discrete *sizes;\r\nint is_ntsc = vc->std & V4L2_STD_525_60;\r\n#define NUM_FRAME_ENUMS 4\r\nint frm_dec[NUM_FRAME_ENUMS] = {1, 2, 3, 5};\r\nint i;\r\nif (fe->index >= NUM_FRAME_ENUMS)\r\nreturn -EINVAL;\r\nfmt = format_by_fourcc(fe->pixel_format);\r\nif (fmt == NULL)\r\nreturn -EINVAL;\r\nsizes = is_ntsc ? ntsc_sizes : pal_sizes;\r\nfor (i = 0; i < NUM_SIZE_ENUMS; i++, sizes++)\r\nif (fe->width == sizes->width &&\r\nfe->height == sizes->height)\r\nbreak;\r\nif (i == NUM_SIZE_ENUMS)\r\nreturn -EINVAL;\r\nfe->type = V4L2_FRMIVAL_TYPE_DISCRETE;\r\nfe->discrete.denominator = is_ntsc ? 30000 : 25000;\r\nfe->discrete.numerator = (is_ntsc ? 1001 : 1000) * frm_dec[fe->index];\r\ndprintk(vc->dev, 4, "%s discrete %d/%d\n", __func__,\r\nfe->discrete.numerator,\r\nfe->discrete.denominator);\r\nreturn 0;\r\n}\r\nstatic int s2255_open(struct file *file)\r\n{\r\nstruct s2255_vc *vc = video_drvdata(file);\r\nstruct s2255_dev *dev = vc->dev;\r\nint state;\r\nint rc = 0;\r\nrc = v4l2_fh_open(file);\r\nif (rc != 0)\r\nreturn rc;\r\ndprintk(dev, 1, "s2255: %s\n", __func__);\r\nstate = atomic_read(&dev->fw_data->fw_state);\r\nswitch (state) {\r\ncase S2255_FW_DISCONNECTING:\r\nreturn -ENODEV;\r\ncase S2255_FW_FAILED:\r\ns2255_dev_err(&dev->udev->dev,\r\n"firmware load failed. retrying.\n");\r\ns2255_fwload_start(dev, 1);\r\nwait_event_timeout(dev->fw_data->wait_fw,\r\n((atomic_read(&dev->fw_data->fw_state)\r\n== S2255_FW_SUCCESS) ||\r\n(atomic_read(&dev->fw_data->fw_state)\r\n== S2255_FW_DISCONNECTING)),\r\nmsecs_to_jiffies(S2255_LOAD_TIMEOUT));\r\nstate = atomic_read(&dev->fw_data->fw_state);\r\nbreak;\r\ncase S2255_FW_NOTLOADED:\r\ncase S2255_FW_LOADED_DSPWAIT:\r\npr_info("%s waiting for firmware load\n", __func__);\r\nwait_event_timeout(dev->fw_data->wait_fw,\r\n((atomic_read(&dev->fw_data->fw_state)\r\n== S2255_FW_SUCCESS) ||\r\n(atomic_read(&dev->fw_data->fw_state)\r\n== S2255_FW_DISCONNECTING)),\r\nmsecs_to_jiffies(S2255_LOAD_TIMEOUT));\r\nstate = atomic_read(&dev->fw_data->fw_state);\r\nbreak;\r\ncase S2255_FW_SUCCESS:\r\ndefault:\r\nbreak;\r\n}\r\nswitch (state) {\r\ncase S2255_FW_SUCCESS:\r\nbreak;\r\ncase S2255_FW_FAILED:\r\npr_info("2255 firmware load failed.\n");\r\nreturn -ENODEV;\r\ncase S2255_FW_DISCONNECTING:\r\npr_info("%s: disconnecting\n", __func__);\r\nreturn -ENODEV;\r\ncase S2255_FW_LOADED_DSPWAIT:\r\ncase S2255_FW_NOTLOADED:\r\npr_info("%s: firmware not loaded, please retry\n",\r\n__func__);\r\natomic_set(&dev->fw_data->fw_state,\r\nS2255_FW_FAILED);\r\nreturn -EAGAIN;\r\ndefault:\r\npr_info("%s: unknown state\n", __func__);\r\nreturn -EFAULT;\r\n}\r\nif (!vc->configured) {\r\nvc->fmt = &formats[0];\r\ns2255_set_mode(vc, &vc->mode);\r\nvc->configured = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void s2255_destroy(struct s2255_dev *dev)\r\n{\r\ndprintk(dev, 1, "%s", __func__);\r\ns2255_board_shutdown(dev);\r\ndel_timer_sync(&dev->timer);\r\nif (dev->fw_data->fw_urb) {\r\nusb_kill_urb(dev->fw_data->fw_urb);\r\nusb_free_urb(dev->fw_data->fw_urb);\r\ndev->fw_data->fw_urb = NULL;\r\n}\r\nrelease_firmware(dev->fw_data->fw);\r\nkfree(dev->fw_data->pfw_data);\r\nkfree(dev->fw_data);\r\ns2255_reset_dsppower(dev);\r\nmutex_destroy(&dev->lock);\r\nusb_put_dev(dev->udev);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nkfree(dev->cmdbuf);\r\nkfree(dev);\r\n}\r\nstatic void s2255_video_device_release(struct video_device *vdev)\r\n{\r\nstruct s2255_dev *dev = to_s2255_dev(vdev->v4l2_dev);\r\nstruct s2255_vc *vc =\r\ncontainer_of(vdev, struct s2255_vc, vdev);\r\ndprintk(dev, 4, "%s, chnls: %d\n", __func__,\r\natomic_read(&dev->num_channels));\r\nv4l2_ctrl_handler_free(&vc->hdl);\r\nif (atomic_dec_and_test(&dev->num_channels))\r\ns2255_destroy(dev);\r\nreturn;\r\n}\r\nstatic int s2255_probe_v4l(struct s2255_dev *dev)\r\n{\r\nint ret;\r\nint i;\r\nint cur_nr = video_nr;\r\nstruct s2255_vc *vc;\r\nstruct vb2_queue *q;\r\nret = v4l2_device_register(&dev->interface->dev, &dev->v4l2_dev);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < MAX_CHANNELS; i++) {\r\nvc = &dev->vc[i];\r\nINIT_LIST_HEAD(&vc->buf_list);\r\nv4l2_ctrl_handler_init(&vc->hdl, 6);\r\nv4l2_ctrl_new_std(&vc->hdl, &s2255_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, -127, 127, 1, DEF_BRIGHT);\r\nv4l2_ctrl_new_std(&vc->hdl, &s2255_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 255, 1, DEF_CONTRAST);\r\nv4l2_ctrl_new_std(&vc->hdl, &s2255_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 255, 1, DEF_SATURATION);\r\nv4l2_ctrl_new_std(&vc->hdl, &s2255_ctrl_ops,\r\nV4L2_CID_HUE, 0, 255, 1, DEF_HUE);\r\nvc->jpegqual_ctrl = v4l2_ctrl_new_std(&vc->hdl,\r\n&s2255_ctrl_ops,\r\nV4L2_CID_JPEG_COMPRESSION_QUALITY,\r\n0, 100, 1, S2255_DEF_JPEG_QUAL);\r\nif (dev->dsp_fw_ver >= S2255_MIN_DSP_COLORFILTER &&\r\n(dev->pid != 0x2257 || vc->idx <= 1))\r\nv4l2_ctrl_new_custom(&vc->hdl, &color_filter_ctrl,\r\nNULL);\r\nif (vc->hdl.error) {\r\nret = vc->hdl.error;\r\nv4l2_ctrl_handler_free(&vc->hdl);\r\ndev_err(&dev->udev->dev, "couldn't register control\n");\r\nbreak;\r\n}\r\nq = &vc->vb_vidq;\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_READ | VB2_USERPTR;\r\nq->drv_priv = vc;\r\nq->lock = &vc->vb_lock;\r\nq->buf_struct_size = sizeof(struct s2255_buffer);\r\nq->mem_ops = &vb2_vmalloc_memops;\r\nq->ops = &s2255_video_qops;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nret = vb2_queue_init(q);\r\nif (ret != 0) {\r\ndev_err(&dev->udev->dev,\r\n"%s vb2_queue_init 0x%x\n", __func__, ret);\r\nbreak;\r\n}\r\nvc->vdev = template;\r\nvc->vdev.queue = q;\r\nvc->vdev.ctrl_handler = &vc->hdl;\r\nvc->vdev.lock = &dev->lock;\r\nvc->vdev.v4l2_dev = &dev->v4l2_dev;\r\nvideo_set_drvdata(&vc->vdev, vc);\r\nif (video_nr == -1)\r\nret = video_register_device(&vc->vdev,\r\nVFL_TYPE_GRABBER,\r\nvideo_nr);\r\nelse\r\nret = video_register_device(&vc->vdev,\r\nVFL_TYPE_GRABBER,\r\ncur_nr + i);\r\nif (ret) {\r\ndev_err(&dev->udev->dev,\r\n"failed to register video device!\n");\r\nbreak;\r\n}\r\natomic_inc(&dev->num_channels);\r\nv4l2_info(&dev->v4l2_dev, "V4L2 device registered as %s\n",\r\nvideo_device_node_name(&vc->vdev));\r\n}\r\npr_info("Sensoray 2255 V4L driver Revision: %s\n",\r\nS2255_VERSION);\r\nif (atomic_read(&dev->num_channels) == 0) {\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nreturn ret;\r\n}\r\nif (atomic_read(&dev->num_channels) != MAX_CHANNELS)\r\npr_warn("s2255: Not all channels available.\n");\r\nreturn 0;\r\n}\r\nstatic int save_frame(struct s2255_dev *dev, struct s2255_pipeinfo *pipe_info)\r\n{\r\nchar *pdest;\r\nu32 offset = 0;\r\nint bframe = 0;\r\nchar *psrc;\r\nunsigned long copy_size;\r\nunsigned long size;\r\ns32 idx = -1;\r\nstruct s2255_framei *frm;\r\nunsigned char *pdata;\r\nstruct s2255_vc *vc;\r\ndprintk(dev, 100, "buffer to user\n");\r\nvc = &dev->vc[dev->cc];\r\nidx = vc->cur_frame;\r\nfrm = &vc->buffer.frame[idx];\r\nif (frm->ulState == S2255_READ_IDLE) {\r\nint jj;\r\nunsigned int cc;\r\n__le32 *pdword;\r\nint payload;\r\npdata = (unsigned char *)pipe_info->transfer_buffer;\r\npdword = (__le32 *)pdata;\r\nfor (jj = 0; jj < (pipe_info->cur_transfer_size - 12); jj++) {\r\nswitch (*pdword) {\r\ncase S2255_MARKER_FRAME:\r\ndprintk(dev, 4, "marker @ offset: %d [%x %x]\n",\r\njj, pdata[0], pdata[1]);\r\noffset = jj + PREFIX_SIZE;\r\nbframe = 1;\r\ncc = le32_to_cpu(pdword[1]);\r\nif (cc >= MAX_CHANNELS) {\r\ndprintk(dev, 0,\r\n"bad channel\n");\r\nreturn -EINVAL;\r\n}\r\ndev->cc = G_chnmap[cc];\r\nvc = &dev->vc[dev->cc];\r\npayload = le32_to_cpu(pdword[3]);\r\nif (payload > vc->req_image_size) {\r\nvc->bad_payload++;\r\nreturn -EINVAL;\r\n}\r\nvc->pkt_size = payload;\r\nvc->jpg_size = le32_to_cpu(pdword[4]);\r\nbreak;\r\ncase S2255_MARKER_RESPONSE:\r\npdata += DEF_USB_BLOCK;\r\njj += DEF_USB_BLOCK;\r\nif (le32_to_cpu(pdword[1]) >= MAX_CHANNELS)\r\nbreak;\r\ncc = G_chnmap[le32_to_cpu(pdword[1])];\r\nif (cc >= MAX_CHANNELS)\r\nbreak;\r\nvc = &dev->vc[cc];\r\nswitch (pdword[2]) {\r\ncase S2255_RESPONSE_SETMODE:\r\nvc->setmode_ready = 1;\r\nwake_up(&vc->wait_setmode);\r\ndprintk(dev, 5, "setmode rdy %d\n", cc);\r\nbreak;\r\ncase S2255_RESPONSE_FW:\r\ndev->chn_ready |= (1 << cc);\r\nif ((dev->chn_ready & 0x0f) != 0x0f)\r\nbreak;\r\npr_info("s2255: fw loaded\n");\r\natomic_set(&dev->fw_data->fw_state,\r\nS2255_FW_SUCCESS);\r\nwake_up(&dev->fw_data->wait_fw);\r\nbreak;\r\ncase S2255_RESPONSE_STATUS:\r\nvc->vidstatus = le32_to_cpu(pdword[3]);\r\nvc->vidstatus_ready = 1;\r\nwake_up(&vc->wait_vidstatus);\r\ndprintk(dev, 5, "vstat %x chan %d\n",\r\nle32_to_cpu(pdword[3]), cc);\r\nbreak;\r\ndefault:\r\npr_info("s2255 unknown resp\n");\r\n}\r\ndefault:\r\npdata++;\r\nbreak;\r\n}\r\nif (bframe)\r\nbreak;\r\n}\r\nif (!bframe)\r\nreturn -EINVAL;\r\n}\r\nvc = &dev->vc[dev->cc];\r\nidx = vc->cur_frame;\r\nfrm = &vc->buffer.frame[idx];\r\nif (!vb2_is_streaming(&vc->vb_vidq)) {\r\nfrm->ulState = S2255_READ_IDLE;\r\nreturn -EINVAL;\r\n}\r\nif (frm->ulState == S2255_READ_IDLE) {\r\nfrm->ulState = S2255_READ_FRAME;\r\nfrm->cur_size = 0;\r\n}\r\npsrc = (u8 *)pipe_info->transfer_buffer + offset;\r\nif (frm->lpvbits == NULL) {\r\ndprintk(dev, 1, "s2255 frame buffer == NULL.%p %p %d %d",\r\nfrm, dev, dev->cc, idx);\r\nreturn -ENOMEM;\r\n}\r\npdest = frm->lpvbits + frm->cur_size;\r\ncopy_size = (pipe_info->cur_transfer_size - offset);\r\nsize = vc->pkt_size - PREFIX_SIZE;\r\nif ((copy_size + frm->cur_size) < vc->req_image_size)\r\nmemcpy(pdest, psrc, copy_size);\r\nfrm->cur_size += copy_size;\r\ndprintk(dev, 4, "cur_size: %lu, size: %lu\n", frm->cur_size, size);\r\nif (frm->cur_size >= size) {\r\ndprintk(dev, 2, "******[%d]Buffer[%d]full*******\n",\r\ndev->cc, idx);\r\nvc->last_frame = vc->cur_frame;\r\nvc->cur_frame++;\r\nif ((vc->cur_frame == SYS_FRAMES) ||\r\n(vc->cur_frame == vc->buffer.dwFrames))\r\nvc->cur_frame = 0;\r\nif (vb2_is_streaming(&vc->vb_vidq))\r\ns2255_got_frame(vc, vc->jpg_size);\r\nvc->frame_count++;\r\nfrm->ulState = S2255_READ_IDLE;\r\nfrm->cur_size = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void s2255_read_video_callback(struct s2255_dev *dev,\r\nstruct s2255_pipeinfo *pipe_info)\r\n{\r\nint res;\r\ndprintk(dev, 50, "callback read video\n");\r\nif (dev->cc >= MAX_CHANNELS) {\r\ndev->cc = 0;\r\ndev_err(&dev->udev->dev, "invalid channel\n");\r\nreturn;\r\n}\r\nres = save_frame(dev, pipe_info);\r\nif (res != 0)\r\ndprintk(dev, 4, "s2255: read callback failed\n");\r\ndprintk(dev, 50, "callback read video done\n");\r\nreturn;\r\n}\r\nstatic long s2255_vendor_req(struct s2255_dev *dev, unsigned char Request,\r\nu16 Index, u16 Value, void *TransferBuffer,\r\ns32 TransferBufferLength, int bOut)\r\n{\r\nint r;\r\nunsigned char *buf;\r\nbuf = kmalloc(TransferBufferLength, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (!bOut) {\r\nr = usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\r\nRequest,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE |\r\nUSB_DIR_IN,\r\nValue, Index, buf,\r\nTransferBufferLength, HZ * 5);\r\nif (r >= 0)\r\nmemcpy(TransferBuffer, buf, TransferBufferLength);\r\n} else {\r\nmemcpy(buf, TransferBuffer, TransferBufferLength);\r\nr = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\r\nRequest, USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nValue, Index, buf,\r\nTransferBufferLength, HZ * 5);\r\n}\r\nkfree(buf);\r\nreturn r;\r\n}\r\nstatic int s2255_get_fx2fw(struct s2255_dev *dev)\r\n{\r\nint fw;\r\nint ret;\r\nunsigned char transBuffer[64];\r\nret = s2255_vendor_req(dev, S2255_VR_FW, 0, 0, transBuffer, 2,\r\nS2255_VR_IN);\r\nif (ret < 0)\r\ndprintk(dev, 2, "get fw error: %x\n", ret);\r\nfw = transBuffer[0] + (transBuffer[1] << 8);\r\ndprintk(dev, 2, "Get FW %x %x\n", transBuffer[0], transBuffer[1]);\r\nreturn fw;\r\n}\r\nstatic int s2255_create_sys_buffers(struct s2255_vc *vc)\r\n{\r\nunsigned long i;\r\nunsigned long reqsize;\r\nvc->buffer.dwFrames = SYS_FRAMES;\r\nreqsize = SYS_FRAMES_MAXSIZE;\r\nif (reqsize > SYS_FRAMES_MAXSIZE)\r\nreqsize = SYS_FRAMES_MAXSIZE;\r\nfor (i = 0; i < SYS_FRAMES; i++) {\r\nvc->buffer.frame[i].lpvbits = vmalloc(reqsize);\r\nvc->buffer.frame[i].size = reqsize;\r\nif (vc->buffer.frame[i].lpvbits == NULL) {\r\npr_info("out of memory. using less frames\n");\r\nvc->buffer.dwFrames = i;\r\nbreak;\r\n}\r\n}\r\nfor (i = 0; i < SYS_FRAMES; i++) {\r\nvc->buffer.frame[i].ulState = 0;\r\nvc->buffer.frame[i].cur_size = 0;\r\n}\r\nvc->cur_frame = 0;\r\nvc->last_frame = -1;\r\nreturn 0;\r\n}\r\nstatic int s2255_release_sys_buffers(struct s2255_vc *vc)\r\n{\r\nunsigned long i;\r\nfor (i = 0; i < SYS_FRAMES; i++) {\r\nvfree(vc->buffer.frame[i].lpvbits);\r\nvc->buffer.frame[i].lpvbits = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s2255_board_init(struct s2255_dev *dev)\r\n{\r\nstruct s2255_mode mode_def = DEF_MODEI_NTSC_CONT;\r\nint fw_ver;\r\nint j;\r\nstruct s2255_pipeinfo *pipe = &dev->pipe;\r\ndprintk(dev, 4, "board init: %p", dev);\r\nmemset(pipe, 0, sizeof(*pipe));\r\npipe->dev = dev;\r\npipe->cur_transfer_size = S2255_USB_XFER_SIZE;\r\npipe->max_transfer_size = S2255_USB_XFER_SIZE;\r\npipe->transfer_buffer = kzalloc(pipe->max_transfer_size,\r\nGFP_KERNEL);\r\nif (pipe->transfer_buffer == NULL) {\r\ndprintk(dev, 1, "out of memory!\n");\r\nreturn -ENOMEM;\r\n}\r\nfw_ver = s2255_get_fx2fw(dev);\r\npr_info("s2255: usb firmware version %d.%d\n",\r\n(fw_ver >> 8) & 0xff,\r\nfw_ver & 0xff);\r\nif (fw_ver < S2255_CUR_USB_FWVER)\r\npr_info("s2255: newer USB firmware available\n");\r\nfor (j = 0; j < MAX_CHANNELS; j++) {\r\nstruct s2255_vc *vc = &dev->vc[j];\r\nvc->mode = mode_def;\r\nif (dev->pid == 0x2257 && j > 1)\r\nvc->mode.color |= (1 << 16);\r\nvc->jpegqual = S2255_DEF_JPEG_QUAL;\r\nvc->width = LINE_SZ_4CIFS_NTSC;\r\nvc->height = NUM_LINES_4CIFS_NTSC * 2;\r\nvc->std = V4L2_STD_NTSC_M;\r\nvc->fmt = &formats[0];\r\nvc->mode.restart = 1;\r\nvc->req_image_size = get_transfer_size(&mode_def);\r\nvc->frame_count = 0;\r\ns2255_create_sys_buffers(vc);\r\n}\r\ns2255_start_readpipe(dev);\r\ndprintk(dev, 1, "%s: success\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int s2255_board_shutdown(struct s2255_dev *dev)\r\n{\r\nu32 i;\r\ndprintk(dev, 1, "%s: dev: %p", __func__, dev);\r\nfor (i = 0; i < MAX_CHANNELS; i++) {\r\nif (vb2_is_streaming(&dev->vc[i].vb_vidq))\r\ns2255_stop_acquire(&dev->vc[i]);\r\n}\r\ns2255_stop_readpipe(dev);\r\nfor (i = 0; i < MAX_CHANNELS; i++)\r\ns2255_release_sys_buffers(&dev->vc[i]);\r\nkfree(dev->pipe.transfer_buffer);\r\nreturn 0;\r\n}\r\nstatic void read_pipe_completion(struct urb *purb)\r\n{\r\nstruct s2255_pipeinfo *pipe_info;\r\nstruct s2255_dev *dev;\r\nint status;\r\nint pipe;\r\npipe_info = purb->context;\r\nif (pipe_info == NULL) {\r\ndev_err(&purb->dev->dev, "no context!\n");\r\nreturn;\r\n}\r\ndev = pipe_info->dev;\r\nif (dev == NULL) {\r\ndev_err(&purb->dev->dev, "no context!\n");\r\nreturn;\r\n}\r\nstatus = purb->status;\r\nif (status == -ESHUTDOWN) {\r\ndprintk(dev, 2, "%s: err shutdown\n", __func__);\r\npipe_info->err_count++;\r\nreturn;\r\n}\r\nif (pipe_info->state == 0) {\r\ndprintk(dev, 2, "%s: exiting USB pipe", __func__);\r\nreturn;\r\n}\r\nif (status == 0)\r\ns2255_read_video_callback(dev, pipe_info);\r\nelse {\r\npipe_info->err_count++;\r\ndprintk(dev, 1, "%s: failed URB %d\n", __func__, status);\r\n}\r\npipe = usb_rcvbulkpipe(dev->udev, dev->read_endpoint);\r\nusb_fill_bulk_urb(pipe_info->stream_urb, dev->udev,\r\npipe,\r\npipe_info->transfer_buffer,\r\npipe_info->cur_transfer_size,\r\nread_pipe_completion, pipe_info);\r\nif (pipe_info->state != 0) {\r\nif (usb_submit_urb(pipe_info->stream_urb, GFP_ATOMIC))\r\ndev_err(&dev->udev->dev, "error submitting urb\n");\r\n} else {\r\ndprintk(dev, 2, "%s :complete state 0\n", __func__);\r\n}\r\nreturn;\r\n}\r\nstatic int s2255_start_readpipe(struct s2255_dev *dev)\r\n{\r\nint pipe;\r\nint retval;\r\nstruct s2255_pipeinfo *pipe_info = &dev->pipe;\r\npipe = usb_rcvbulkpipe(dev->udev, dev->read_endpoint);\r\ndprintk(dev, 2, "%s: IN %d\n", __func__, dev->read_endpoint);\r\npipe_info->state = 1;\r\npipe_info->err_count = 0;\r\npipe_info->stream_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!pipe_info->stream_urb)\r\nreturn -ENOMEM;\r\nusb_fill_bulk_urb(pipe_info->stream_urb, dev->udev,\r\npipe,\r\npipe_info->transfer_buffer,\r\npipe_info->cur_transfer_size,\r\nread_pipe_completion, pipe_info);\r\nretval = usb_submit_urb(pipe_info->stream_urb, GFP_KERNEL);\r\nif (retval) {\r\npr_err("s2255: start read pipe failed\n");\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s2255_start_acquire(struct s2255_vc *vc)\r\n{\r\nint res;\r\nunsigned long chn_rev;\r\nint j;\r\nstruct s2255_dev *dev = to_s2255_dev(vc->vdev.v4l2_dev);\r\n__le32 *buffer = dev->cmdbuf;\r\nmutex_lock(&dev->cmdlock);\r\nchn_rev = G_chnmap[vc->idx];\r\nvc->last_frame = -1;\r\nvc->bad_payload = 0;\r\nvc->cur_frame = 0;\r\nfor (j = 0; j < SYS_FRAMES; j++) {\r\nvc->buffer.frame[j].ulState = 0;\r\nvc->buffer.frame[j].cur_size = 0;\r\n}\r\nbuffer[0] = IN_DATA_TOKEN;\r\nbuffer[1] = (__le32) cpu_to_le32(chn_rev);\r\nbuffer[2] = CMD_START;\r\nres = s2255_write_config(dev->udev, (unsigned char *)buffer, 512);\r\nif (res != 0)\r\ndev_err(&dev->udev->dev, "CMD_START error\n");\r\ndprintk(dev, 2, "start acquire exit[%d] %d\n", vc->idx, res);\r\nmutex_unlock(&dev->cmdlock);\r\nreturn res;\r\n}\r\nstatic int s2255_stop_acquire(struct s2255_vc *vc)\r\n{\r\nint res;\r\nunsigned long chn_rev;\r\nstruct s2255_dev *dev = to_s2255_dev(vc->vdev.v4l2_dev);\r\n__le32 *buffer = dev->cmdbuf;\r\nmutex_lock(&dev->cmdlock);\r\nchn_rev = G_chnmap[vc->idx];\r\nbuffer[0] = IN_DATA_TOKEN;\r\nbuffer[1] = (__le32) cpu_to_le32(chn_rev);\r\nbuffer[2] = CMD_STOP;\r\nres = s2255_write_config(dev->udev, (unsigned char *)buffer, 512);\r\nif (res != 0)\r\ndev_err(&dev->udev->dev, "CMD_STOP error\n");\r\ndprintk(dev, 4, "%s: chn %d, res %d\n", __func__, vc->idx, res);\r\nmutex_unlock(&dev->cmdlock);\r\nreturn res;\r\n}\r\nstatic void s2255_stop_readpipe(struct s2255_dev *dev)\r\n{\r\nstruct s2255_pipeinfo *pipe = &dev->pipe;\r\npipe->state = 0;\r\nif (pipe->stream_urb) {\r\nusb_kill_urb(pipe->stream_urb);\r\nusb_free_urb(pipe->stream_urb);\r\npipe->stream_urb = NULL;\r\n}\r\ndprintk(dev, 4, "%s", __func__);\r\nreturn;\r\n}\r\nstatic void s2255_fwload_start(struct s2255_dev *dev, int reset)\r\n{\r\nif (reset)\r\ns2255_reset_dsppower(dev);\r\ndev->fw_data->fw_size = dev->fw_data->fw->size;\r\natomic_set(&dev->fw_data->fw_state, S2255_FW_NOTLOADED);\r\nmemcpy(dev->fw_data->pfw_data,\r\ndev->fw_data->fw->data, CHUNK_SIZE);\r\ndev->fw_data->fw_loaded = CHUNK_SIZE;\r\nusb_fill_bulk_urb(dev->fw_data->fw_urb, dev->udev,\r\nusb_sndbulkpipe(dev->udev, 2),\r\ndev->fw_data->pfw_data,\r\nCHUNK_SIZE, s2255_fwchunk_complete,\r\ndev->fw_data);\r\nmod_timer(&dev->timer, jiffies + HZ);\r\n}\r\nstatic int s2255_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct s2255_dev *dev = NULL;\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nint i;\r\nint retval = -ENOMEM;\r\n__le32 *pdata;\r\nint fw_size;\r\ndev = kzalloc(sizeof(struct s2255_dev), GFP_KERNEL);\r\nif (dev == NULL) {\r\ns2255_dev_err(&interface->dev, "out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->cmdbuf = kzalloc(S2255_CMDBUF_SIZE, GFP_KERNEL);\r\nif (dev->cmdbuf == NULL) {\r\ns2255_dev_err(&interface->dev, "out of memory\n");\r\ngoto errorFWDATA1;\r\n}\r\natomic_set(&dev->num_channels, 0);\r\ndev->pid = id->idProduct;\r\ndev->fw_data = kzalloc(sizeof(struct s2255_fw), GFP_KERNEL);\r\nif (!dev->fw_data)\r\ngoto errorFWDATA1;\r\nmutex_init(&dev->lock);\r\nmutex_init(&dev->cmdlock);\r\ndev->udev = usb_get_dev(interface_to_usbdev(interface));\r\nif (dev->udev == NULL) {\r\ndev_err(&interface->dev, "null usb device\n");\r\nretval = -ENODEV;\r\ngoto errorUDEV;\r\n}\r\ndev_dbg(&interface->dev, "dev: %p, udev %p interface %p\n",\r\ndev, dev->udev, interface);\r\ndev->interface = interface;\r\niface_desc = interface->cur_altsetting;\r\ndev_dbg(&interface->dev, "num EP: %d\n",\r\niface_desc->desc.bNumEndpoints);\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nif (!dev->read_endpoint && usb_endpoint_is_bulk_in(endpoint)) {\r\ndev->read_endpoint = endpoint->bEndpointAddress;\r\n}\r\n}\r\nif (!dev->read_endpoint) {\r\ndev_err(&interface->dev, "Could not find bulk-in endpoint\n");\r\ngoto errorEP;\r\n}\r\nsetup_timer(&dev->timer, s2255_timer, (unsigned long)dev->fw_data);\r\ninit_waitqueue_head(&dev->fw_data->wait_fw);\r\nfor (i = 0; i < MAX_CHANNELS; i++) {\r\nstruct s2255_vc *vc = &dev->vc[i];\r\nvc->idx = i;\r\nvc->dev = dev;\r\ninit_waitqueue_head(&vc->wait_setmode);\r\ninit_waitqueue_head(&vc->wait_vidstatus);\r\nspin_lock_init(&vc->qlock);\r\nmutex_init(&vc->vb_lock);\r\n}\r\ndev->fw_data->fw_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!dev->fw_data->fw_urb)\r\ngoto errorFWURB;\r\ndev->fw_data->pfw_data = kzalloc(CHUNK_SIZE, GFP_KERNEL);\r\nif (!dev->fw_data->pfw_data) {\r\ndev_err(&interface->dev, "out of memory!\n");\r\ngoto errorFWDATA2;\r\n}\r\nif (request_firmware(&dev->fw_data->fw,\r\nFIRMWARE_FILE_NAME, &dev->udev->dev)) {\r\ndev_err(&interface->dev, "sensoray 2255 failed to get firmware\n");\r\ngoto errorREQFW;\r\n}\r\nfw_size = dev->fw_data->fw->size;\r\npdata = (__le32 *) &dev->fw_data->fw->data[fw_size - 8];\r\nif (*pdata != S2255_FW_MARKER) {\r\ndev_err(&interface->dev, "Firmware invalid.\n");\r\nretval = -ENODEV;\r\ngoto errorFWMARKER;\r\n} else {\r\n__le32 *pRel;\r\npRel = (__le32 *) &dev->fw_data->fw->data[fw_size - 4];\r\npr_info("s2255 dsp fw version %x\n", le32_to_cpu(*pRel));\r\ndev->dsp_fw_ver = le32_to_cpu(*pRel);\r\nif (dev->dsp_fw_ver < S2255_CUR_DSP_FWVER)\r\npr_info("s2255: f2255usb.bin out of date.\n");\r\nif (dev->pid == 0x2257 &&\r\ndev->dsp_fw_ver < S2255_MIN_DSP_COLORFILTER)\r\npr_warn("2257 needs firmware %d or above.\n",\r\nS2255_MIN_DSP_COLORFILTER);\r\n}\r\nusb_reset_device(dev->udev);\r\nretval = s2255_board_init(dev);\r\nif (retval)\r\ngoto errorBOARDINIT;\r\ns2255_fwload_start(dev, 0);\r\nretval = s2255_probe_v4l(dev);\r\nif (retval)\r\ngoto errorBOARDINIT;\r\ndev_info(&interface->dev, "Sensoray 2255 detected\n");\r\nreturn 0;\r\nerrorBOARDINIT:\r\ns2255_board_shutdown(dev);\r\nerrorFWMARKER:\r\nrelease_firmware(dev->fw_data->fw);\r\nerrorREQFW:\r\nkfree(dev->fw_data->pfw_data);\r\nerrorFWDATA2:\r\nusb_free_urb(dev->fw_data->fw_urb);\r\nerrorFWURB:\r\ndel_timer_sync(&dev->timer);\r\nerrorEP:\r\nusb_put_dev(dev->udev);\r\nerrorUDEV:\r\nkfree(dev->fw_data);\r\nmutex_destroy(&dev->lock);\r\nerrorFWDATA1:\r\nkfree(dev->cmdbuf);\r\nkfree(dev);\r\npr_warn("Sensoray 2255 driver load failed: 0x%x\n", retval);\r\nreturn retval;\r\n}\r\nstatic void s2255_disconnect(struct usb_interface *interface)\r\n{\r\nstruct s2255_dev *dev = to_s2255_dev(usb_get_intfdata(interface));\r\nint i;\r\nint channels = atomic_read(&dev->num_channels);\r\nmutex_lock(&dev->lock);\r\nv4l2_device_disconnect(&dev->v4l2_dev);\r\nmutex_unlock(&dev->lock);\r\natomic_inc(&dev->num_channels);\r\nfor (i = 0; i < channels; i++)\r\nvideo_unregister_device(&dev->vc[i].vdev);\r\natomic_set(&dev->fw_data->fw_state, S2255_FW_DISCONNECTING);\r\nwake_up(&dev->fw_data->wait_fw);\r\nfor (i = 0; i < MAX_CHANNELS; i++) {\r\ndev->vc[i].setmode_ready = 1;\r\nwake_up(&dev->vc[i].wait_setmode);\r\ndev->vc[i].vidstatus_ready = 1;\r\nwake_up(&dev->vc[i].wait_vidstatus);\r\n}\r\nif (atomic_dec_and_test(&dev->num_channels))\r\ns2255_destroy(dev);\r\ndev_info(&interface->dev, "%s\n", __func__);\r\n}
