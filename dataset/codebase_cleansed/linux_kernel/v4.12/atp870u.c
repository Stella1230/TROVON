static inline void atp_writeb_base(struct atp_unit *atp, u8 reg, u8 val)\r\n{\r\noutb(val, atp->baseport + reg);\r\n}\r\nstatic inline void atp_writew_base(struct atp_unit *atp, u8 reg, u16 val)\r\n{\r\noutw(val, atp->baseport + reg);\r\n}\r\nstatic inline void atp_writeb_io(struct atp_unit *atp, u8 channel, u8 reg, u8 val)\r\n{\r\noutb(val, atp->ioport[channel] + reg);\r\n}\r\nstatic inline void atp_writew_io(struct atp_unit *atp, u8 channel, u8 reg, u16 val)\r\n{\r\noutw(val, atp->ioport[channel] + reg);\r\n}\r\nstatic inline void atp_writeb_pci(struct atp_unit *atp, u8 channel, u8 reg, u8 val)\r\n{\r\noutb(val, atp->pciport[channel] + reg);\r\n}\r\nstatic inline void atp_writel_pci(struct atp_unit *atp, u8 channel, u8 reg, u32 val)\r\n{\r\noutl(val, atp->pciport[channel] + reg);\r\n}\r\nstatic inline u8 atp_readb_base(struct atp_unit *atp, u8 reg)\r\n{\r\nreturn inb(atp->baseport + reg);\r\n}\r\nstatic inline u16 atp_readw_base(struct atp_unit *atp, u8 reg)\r\n{\r\nreturn inw(atp->baseport + reg);\r\n}\r\nstatic inline u32 atp_readl_base(struct atp_unit *atp, u8 reg)\r\n{\r\nreturn inl(atp->baseport + reg);\r\n}\r\nstatic inline u8 atp_readb_io(struct atp_unit *atp, u8 channel, u8 reg)\r\n{\r\nreturn inb(atp->ioport[channel] + reg);\r\n}\r\nstatic inline u16 atp_readw_io(struct atp_unit *atp, u8 channel, u8 reg)\r\n{\r\nreturn inw(atp->ioport[channel] + reg);\r\n}\r\nstatic inline u8 atp_readb_pci(struct atp_unit *atp, u8 channel, u8 reg)\r\n{\r\nreturn inb(atp->pciport[channel] + reg);\r\n}\r\nstatic inline bool is880(struct atp_unit *atp)\r\n{\r\nreturn atp->pdev->device == ATP880_DEVID1 ||\r\natp->pdev->device == ATP880_DEVID2;\r\n}\r\nstatic inline bool is885(struct atp_unit *atp)\r\n{\r\nreturn atp->pdev->device == ATP885_DEVID;\r\n}\r\nstatic irqreturn_t atp870u_intr_handle(int irq, void *dev_id)\r\n{\r\nunsigned long flags;\r\nunsigned short int id;\r\nunsigned char i, j, c, target_id, lun,cmdp;\r\nunsigned char *prd;\r\nstruct scsi_cmnd *workreq;\r\nunsigned long adrcnt, k;\r\n#ifdef ED_DBGP\r\nunsigned long l;\r\n#endif\r\nstruct Scsi_Host *host = dev_id;\r\nstruct atp_unit *dev = (struct atp_unit *)&host->hostdata;\r\nfor (c = 0; c < 2; c++) {\r\nj = atp_readb_io(dev, c, 0x1f);\r\nif ((j & 0x80) != 0)\r\nbreak;\r\ndev->in_int[c] = 0;\r\n}\r\nif ((j & 0x80) == 0)\r\nreturn IRQ_NONE;\r\n#ifdef ED_DBGP\r\nprintk("atp870u_intr_handle enter\n");\r\n#endif\r\ndev->in_int[c] = 1;\r\ncmdp = atp_readb_io(dev, c, 0x10);\r\nif (dev->working[c] != 0) {\r\nif (is885(dev)) {\r\nif ((atp_readb_io(dev, c, 0x16) & 0x80) == 0)\r\natp_writeb_io(dev, c, 0x16, (atp_readb_io(dev, c, 0x16) | 0x80));\r\n}\r\nif ((atp_readb_pci(dev, c, 0x00) & 0x08) != 0)\r\n{\r\nfor (k=0; k < 1000; k++) {\r\nif ((atp_readb_pci(dev, c, 2) & 0x08) == 0)\r\nbreak;\r\nif ((atp_readb_pci(dev, c, 2) & 0x01) == 0)\r\nbreak;\r\n}\r\n}\r\natp_writeb_pci(dev, c, 0, 0x00);\r\ni = atp_readb_io(dev, c, 0x17);\r\nif (is885(dev))\r\natp_writeb_pci(dev, c, 2, 0x06);\r\ntarget_id = atp_readb_io(dev, c, 0x15);\r\nif ((target_id & 0x40) != 0) {\r\ntarget_id = (target_id & 0x07) | 0x08;\r\n} else {\r\ntarget_id &= 0x07;\r\n}\r\nif ((j & 0x40) != 0) {\r\nif (dev->last_cmd[c] == 0xff) {\r\ndev->last_cmd[c] = target_id;\r\n}\r\ndev->last_cmd[c] |= 0x40;\r\n}\r\nif (is885(dev))\r\ndev->r1f[c][target_id] |= j;\r\n#ifdef ED_DBGP\r\nprintk("atp870u_intr_handle status = %x\n",i);\r\n#endif\r\nif (i == 0x85) {\r\nif ((dev->last_cmd[c] & 0xf0) != 0x40) {\r\ndev->last_cmd[c] = 0xff;\r\n}\r\nif (is885(dev)) {\r\nadrcnt = 0;\r\n((unsigned char *) &adrcnt)[2] = atp_readb_io(dev, c, 0x12);\r\n((unsigned char *) &adrcnt)[1] = atp_readb_io(dev, c, 0x13);\r\n((unsigned char *) &adrcnt)[0] = atp_readb_io(dev, c, 0x14);\r\nif (dev->id[c][target_id].last_len != adrcnt)\r\n{\r\nk = dev->id[c][target_id].last_len;\r\nk -= adrcnt;\r\ndev->id[c][target_id].tran_len = k;\r\ndev->id[c][target_id].last_len = adrcnt;\r\n}\r\n#ifdef ED_DBGP\r\nprintk("dev->id[c][target_id].last_len = %d dev->id[c][target_id].tran_len = %d\n",dev->id[c][target_id].last_len,dev->id[c][target_id].tran_len);\r\n#endif\r\n}\r\nif (dev->wide_id[c] != 0) {\r\natp_writeb_io(dev, c, 0x1b, 0x01);\r\nwhile ((atp_readb_io(dev, c, 0x1b) & 0x01) != 0x01)\r\natp_writeb_io(dev, c, 0x1b, 0x01);\r\n}\r\nspin_lock_irqsave(dev->host->host_lock, flags);\r\nif (((dev->quhd[c] != dev->quend[c]) || (dev->last_cmd[c] != 0xff)) &&\r\n(dev->in_snd[c] == 0)) {\r\n#ifdef ED_DBGP\r\nprintk("Call sent_s870\n");\r\n#endif\r\nsend_s870(dev,c);\r\n}\r\nspin_unlock_irqrestore(dev->host->host_lock, flags);\r\ndev->in_int[c] = 0;\r\n#ifdef ED_DBGP\r\nprintk("Status 0x85 return\n");\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nif (i == 0x40) {\r\ndev->last_cmd[c] |= 0x40;\r\ndev->in_int[c] = 0;\r\nreturn IRQ_HANDLED;\r\n}\r\nif (i == 0x21) {\r\nif ((dev->last_cmd[c] & 0xf0) != 0x40) {\r\ndev->last_cmd[c] = 0xff;\r\n}\r\nadrcnt = 0;\r\n((unsigned char *) &adrcnt)[2] = atp_readb_io(dev, c, 0x12);\r\n((unsigned char *) &adrcnt)[1] = atp_readb_io(dev, c, 0x13);\r\n((unsigned char *) &adrcnt)[0] = atp_readb_io(dev, c, 0x14);\r\nk = dev->id[c][target_id].last_len;\r\nk -= adrcnt;\r\ndev->id[c][target_id].tran_len = k;\r\ndev->id[c][target_id].last_len = adrcnt;\r\natp_writeb_io(dev, c, 0x10, 0x41);\r\natp_writeb_io(dev, c, 0x18, 0x08);\r\ndev->in_int[c] = 0;\r\nreturn IRQ_HANDLED;\r\n}\r\nif (is885(dev)) {\r\nif ((i == 0x4c) || (i == 0x4d) || (i == 0x8c) || (i == 0x8d)) {\r\nif ((i == 0x4c) || (i == 0x8c))\r\ni=0x48;\r\nelse\r\ni=0x49;\r\n}\r\n}\r\nif ((i == 0x80) || (i == 0x8f)) {\r\n#ifdef ED_DBGP\r\nprintk(KERN_DEBUG "Device reselect\n");\r\n#endif\r\nlun = 0;\r\nif (cmdp == 0x44 || i == 0x80)\r\nlun = atp_readb_io(dev, c, 0x1d) & 0x07;\r\nelse {\r\nif ((dev->last_cmd[c] & 0xf0) != 0x40) {\r\ndev->last_cmd[c] = 0xff;\r\n}\r\nif (cmdp == 0x41) {\r\n#ifdef ED_DBGP\r\nprintk("cmdp = 0x41\n");\r\n#endif\r\nadrcnt = 0;\r\n((unsigned char *) &adrcnt)[2] = atp_readb_io(dev, c, 0x12);\r\n((unsigned char *) &adrcnt)[1] = atp_readb_io(dev, c, 0x13);\r\n((unsigned char *) &adrcnt)[0] = atp_readb_io(dev, c, 0x14);\r\nk = dev->id[c][target_id].last_len;\r\nk -= adrcnt;\r\ndev->id[c][target_id].tran_len = k;\r\ndev->id[c][target_id].last_len = adrcnt;\r\natp_writeb_io(dev, c, 0x18, 0x08);\r\ndev->in_int[c] = 0;\r\nreturn IRQ_HANDLED;\r\n} else {\r\n#ifdef ED_DBGP\r\nprintk("cmdp != 0x41\n");\r\n#endif\r\natp_writeb_io(dev, c, 0x10, 0x46);\r\ndev->id[c][target_id].dirct = 0x00;\r\natp_writeb_io(dev, c, 0x12, 0x00);\r\natp_writeb_io(dev, c, 0x13, 0x00);\r\natp_writeb_io(dev, c, 0x14, 0x00);\r\natp_writeb_io(dev, c, 0x18, 0x08);\r\ndev->in_int[c] = 0;\r\nreturn IRQ_HANDLED;\r\n}\r\n}\r\nif (dev->last_cmd[c] != 0xff) {\r\ndev->last_cmd[c] |= 0x40;\r\n}\r\nif (is885(dev)) {\r\nj = atp_readb_base(dev, 0x29) & 0xfe;\r\natp_writeb_base(dev, 0x29, j);\r\n} else\r\natp_writeb_io(dev, c, 0x10, 0x45);\r\ntarget_id = atp_readb_io(dev, c, 0x16);\r\nif ((target_id & 0x10) != 0) {\r\ntarget_id = (target_id & 0x07) | 0x08;\r\n} else {\r\ntarget_id &= 0x07;\r\n}\r\nif (is885(dev))\r\natp_writeb_io(dev, c, 0x10, 0x45);\r\nworkreq = dev->id[c][target_id].curr_req;\r\n#ifdef ED_DBGP\r\nscmd_printk(KERN_DEBUG, workreq, "CDB");\r\nfor (l = 0; l < workreq->cmd_len; l++)\r\nprintk(KERN_DEBUG " %x",workreq->cmnd[l]);\r\nprintk("\n");\r\n#endif\r\natp_writeb_io(dev, c, 0x0f, lun);\r\natp_writeb_io(dev, c, 0x11, dev->id[c][target_id].devsp);\r\nadrcnt = dev->id[c][target_id].tran_len;\r\nk = dev->id[c][target_id].last_len;\r\natp_writeb_io(dev, c, 0x12, ((unsigned char *) &k)[2]);\r\natp_writeb_io(dev, c, 0x13, ((unsigned char *) &k)[1]);\r\natp_writeb_io(dev, c, 0x14, ((unsigned char *) &k)[0]);\r\n#ifdef ED_DBGP\r\nprintk("k %x, k[0] 0x%x k[1] 0x%x k[2] 0x%x\n", k, atp_readb_io(dev, c, 0x14), atp_readb_io(dev, c, 0x13), atp_readb_io(dev, c, 0x12));\r\n#endif\r\nj = target_id;\r\nif (target_id > 7) {\r\nj = (j & 0x07) | 0x40;\r\n}\r\nj |= dev->id[c][target_id].dirct;\r\natp_writeb_io(dev, c, 0x15, j);\r\natp_writeb_io(dev, c, 0x16, 0x80);\r\nif (is885(dev)) {\r\ni = atp_readb_pci(dev, c, 1) & 0xf3;\r\nif ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {\r\ni |= 0x0c;\r\n}\r\natp_writeb_pci(dev, c, 1, i);\r\n} else if (is880(dev)) {\r\nif ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a))\r\natp_writeb_base(dev, 0x3b, (atp_readb_base(dev, 0x3b) & 0x3f) | 0xc0);\r\nelse\r\natp_writeb_base(dev, 0x3b, atp_readb_base(dev, 0x3b) & 0x3f);\r\n} else {\r\nif ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a))\r\natp_writeb_base(dev, 0x3a, (atp_readb_base(dev, 0x3a) & 0xf3) | 0x08);\r\nelse\r\natp_writeb_base(dev, 0x3a, atp_readb_base(dev, 0x3a) & 0xf3);\r\n}\r\nj = 0;\r\nid = 1;\r\nid = id << target_id;\r\nif ((id & dev->wide_id[c]) != 0) {\r\nj |= 0x01;\r\n}\r\natp_writeb_io(dev, c, 0x1b, j);\r\nwhile ((atp_readb_io(dev, c, 0x1b) & 0x01) != j)\r\natp_writeb_io(dev, c, 0x1b, j);\r\nif (dev->id[c][target_id].last_len == 0) {\r\natp_writeb_io(dev, c, 0x18, 0x08);\r\ndev->in_int[c] = 0;\r\n#ifdef ED_DBGP\r\nprintk("dev->id[c][target_id].last_len = 0\n");\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\n#ifdef ED_DBGP\r\nprintk("target_id = %d adrcnt = %d\n",target_id,adrcnt);\r\n#endif\r\nprd = dev->id[c][target_id].prd_pos;\r\nwhile (adrcnt != 0) {\r\nid = ((unsigned short int *)prd)[2];\r\nif (id == 0) {\r\nk = 0x10000;\r\n} else {\r\nk = id;\r\n}\r\nif (k > adrcnt) {\r\n((unsigned short int *)prd)[2] = (unsigned short int)\r\n(k - adrcnt);\r\n((unsigned long *)prd)[0] += adrcnt;\r\nadrcnt = 0;\r\ndev->id[c][target_id].prd_pos = prd;\r\n} else {\r\nadrcnt -= k;\r\ndev->id[c][target_id].prdaddr += 0x08;\r\nprd += 0x08;\r\nif (adrcnt == 0) {\r\ndev->id[c][target_id].prd_pos = prd;\r\n}\r\n}\r\n}\r\natp_writel_pci(dev, c, 0x04, dev->id[c][target_id].prdaddr);\r\n#ifdef ED_DBGP\r\nprintk("dev->id[%d][%d].prdaddr 0x%8x\n", c, target_id, dev->id[c][target_id].prdaddr);\r\n#endif\r\nif (!is885(dev)) {\r\natp_writeb_pci(dev, c, 2, 0x06);\r\natp_writeb_pci(dev, c, 2, 0x00);\r\n}\r\nif (dev->id[c][target_id].dirct != 0) {\r\natp_writeb_io(dev, c, 0x18, 0x08);\r\natp_writeb_pci(dev, c, 0, 0x01);\r\ndev->in_int[c] = 0;\r\n#ifdef ED_DBGP\r\nprintk("status 0x80 return dirct != 0\n");\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\natp_writeb_io(dev, c, 0x18, 0x08);\r\natp_writeb_pci(dev, c, 0, 0x09);\r\ndev->in_int[c] = 0;\r\n#ifdef ED_DBGP\r\nprintk("status 0x80 return dirct = 0\n");\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nworkreq = dev->id[c][target_id].curr_req;\r\nif (i == 0x42 || i == 0x16) {\r\nif ((dev->last_cmd[c] & 0xf0) != 0x40) {\r\ndev->last_cmd[c] = 0xff;\r\n}\r\nif (i == 0x16) {\r\nworkreq->result = atp_readb_io(dev, c, 0x0f);\r\nif (((dev->r1f[c][target_id] & 0x10) != 0) && is885(dev)) {\r\nprintk(KERN_WARNING "AEC67162 CRC ERROR !\n");\r\nworkreq->result = 0x02;\r\n}\r\n} else\r\nworkreq->result = 0x02;\r\nif (is885(dev)) {\r\nj = atp_readb_base(dev, 0x29) | 0x01;\r\natp_writeb_base(dev, 0x29, j);\r\n}\r\nscsi_dma_unmap(workreq);\r\nspin_lock_irqsave(dev->host->host_lock, flags);\r\n(*workreq->scsi_done) (workreq);\r\n#ifdef ED_DBGP\r\nprintk("workreq->scsi_done\n");\r\n#endif\r\ndev->id[c][target_id].curr_req = NULL;\r\ndev->working[c]--;\r\nspin_unlock_irqrestore(dev->host->host_lock, flags);\r\nif (dev->wide_id[c] != 0) {\r\natp_writeb_io(dev, c, 0x1b, 0x01);\r\nwhile ((atp_readb_io(dev, c, 0x1b) & 0x01) != 0x01)\r\natp_writeb_io(dev, c, 0x1b, 0x01);\r\n}\r\nspin_lock_irqsave(dev->host->host_lock, flags);\r\nif (((dev->last_cmd[c] != 0xff) || (dev->quhd[c] != dev->quend[c])) &&\r\n(dev->in_snd[c] == 0)) {\r\n#ifdef ED_DBGP\r\nprintk("Call sent_s870(scsi_done)\n");\r\n#endif\r\nsend_s870(dev,c);\r\n}\r\nspin_unlock_irqrestore(dev->host->host_lock, flags);\r\ndev->in_int[c] = 0;\r\nreturn IRQ_HANDLED;\r\n}\r\nif ((dev->last_cmd[c] & 0xf0) != 0x40) {\r\ndev->last_cmd[c] = 0xff;\r\n}\r\nif (i == 0x4f) {\r\ni = 0x89;\r\n}\r\ni &= 0x0f;\r\nif (i == 0x09) {\r\natp_writel_pci(dev, c, 4, dev->id[c][target_id].prdaddr);\r\natp_writeb_pci(dev, c, 2, 0x06);\r\natp_writeb_pci(dev, c, 2, 0x00);\r\natp_writeb_io(dev, c, 0x10, 0x41);\r\nif (is885(dev)) {\r\nk = dev->id[c][target_id].last_len;\r\natp_writeb_io(dev, c, 0x12, ((unsigned char *) (&k))[2]);\r\natp_writeb_io(dev, c, 0x13, ((unsigned char *) (&k))[1]);\r\natp_writeb_io(dev, c, 0x14, ((unsigned char *) (&k))[0]);\r\ndev->id[c][target_id].dirct = 0x00;\r\n} else {\r\ndev->id[c][target_id].dirct = 0x00;\r\n}\r\natp_writeb_io(dev, c, 0x18, 0x08);\r\natp_writeb_pci(dev, c, 0, 0x09);\r\ndev->in_int[c] = 0;\r\nreturn IRQ_HANDLED;\r\n}\r\nif (i == 0x08) {\r\natp_writel_pci(dev, c, 4, dev->id[c][target_id].prdaddr);\r\natp_writeb_pci(dev, c, 2, 0x06);\r\natp_writeb_pci(dev, c, 2, 0x00);\r\natp_writeb_io(dev, c, 0x10, 0x41);\r\nif (is885(dev)) {\r\nk = dev->id[c][target_id].last_len;\r\natp_writeb_io(dev, c, 0x12, ((unsigned char *) (&k))[2]);\r\natp_writeb_io(dev, c, 0x13, ((unsigned char *) (&k))[1]);\r\natp_writeb_io(dev, c, 0x14, ((unsigned char *) (&k))[0]);\r\n}\r\natp_writeb_io(dev, c, 0x15, atp_readb_io(dev, c, 0x15) | 0x20);\r\ndev->id[c][target_id].dirct = 0x20;\r\natp_writeb_io(dev, c, 0x18, 0x08);\r\natp_writeb_pci(dev, c, 0, 0x01);\r\ndev->in_int[c] = 0;\r\nreturn IRQ_HANDLED;\r\n}\r\nif (i == 0x0a)\r\natp_writeb_io(dev, c, 0x10, 0x30);\r\nelse\r\natp_writeb_io(dev, c, 0x10, 0x46);\r\ndev->id[c][target_id].dirct = 0x00;\r\natp_writeb_io(dev, c, 0x12, 0x00);\r\natp_writeb_io(dev, c, 0x13, 0x00);\r\natp_writeb_io(dev, c, 0x14, 0x00);\r\natp_writeb_io(dev, c, 0x18, 0x08);\r\n}\r\ndev->in_int[c] = 0;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int atp870u_queuecommand_lck(struct scsi_cmnd *req_p,\r\nvoid (*done) (struct scsi_cmnd *))\r\n{\r\nunsigned char c;\r\nunsigned int m;\r\nstruct atp_unit *dev;\r\nstruct Scsi_Host *host;\r\nc = scmd_channel(req_p);\r\nreq_p->sense_buffer[0]=0;\r\nscsi_set_resid(req_p, 0);\r\nif (scmd_channel(req_p) > 1) {\r\nreq_p->result = 0x00040000;\r\ndone(req_p);\r\n#ifdef ED_DBGP\r\nprintk("atp870u_queuecommand : req_p->device->channel > 1\n");\r\n#endif\r\nreturn 0;\r\n}\r\nhost = req_p->device->host;\r\ndev = (struct atp_unit *)&host->hostdata;\r\nm = 1;\r\nm = m << scmd_id(req_p);\r\nif ((m & dev->active_id[c]) == 0) {\r\nreq_p->result = 0x00040000;\r\ndone(req_p);\r\nreturn 0;\r\n}\r\nif (done) {\r\nreq_p->scsi_done = done;\r\n} else {\r\n#ifdef ED_DBGP\r\nprintk( "atp870u_queuecommand: done can't be NULL\n");\r\n#endif\r\nreq_p->result = 0;\r\ndone(req_p);\r\nreturn 0;\r\n}\r\ndev->quend[c]++;\r\nif (dev->quend[c] >= qcnt) {\r\ndev->quend[c] = 0;\r\n}\r\nif (dev->quhd[c] == dev->quend[c]) {\r\nif (dev->quend[c] == 0) {\r\ndev->quend[c] = qcnt;\r\n}\r\n#ifdef ED_DBGP\r\nprintk("atp870u_queuecommand : dev->quhd[c] == dev->quend[c]\n");\r\n#endif\r\ndev->quend[c]--;\r\nreq_p->result = 0x00020000;\r\ndone(req_p);\r\nreturn 0;\r\n}\r\ndev->quereq[c][dev->quend[c]] = req_p;\r\n#ifdef ED_DBGP\r\nprintk("dev->ioport[c] = %x atp_readb_io(dev, c, 0x1c) = %x dev->in_int[%d] = %d dev->in_snd[%d] = %d\n",dev->ioport[c],atp_readb_io(dev, c, 0x1c),c,dev->in_int[c],c,dev->in_snd[c]);\r\n#endif\r\nif ((atp_readb_io(dev, c, 0x1c) == 0) && (dev->in_int[c] == 0) && (dev->in_snd[c] == 0)) {\r\n#ifdef ED_DBGP\r\nprintk("Call sent_s870(atp870u_queuecommand)\n");\r\n#endif\r\nsend_s870(dev,c);\r\n}\r\n#ifdef ED_DBGP\r\nprintk("atp870u_queuecommand : exit\n");\r\n#endif\r\nreturn 0;\r\n}\r\nunsigned char fun_scam(struct atp_unit *dev, unsigned short int *val)\r\n{\r\nunsigned short int i, k;\r\nunsigned char j;\r\natp_writew_io(dev, 0, 0x1c, *val);\r\nfor (i = 0; i < 10; i++) {\r\nk = atp_readw_io(dev, 0, 0x1c);\r\nj = (unsigned char) (k >> 8);\r\nif ((k & 0x8000) != 0)\r\ni = 0;\r\n}\r\n*val |= 0x4000;\r\natp_writew_io(dev, 0, 0x1c, *val);\r\n*val &= 0xdfff;\r\natp_writew_io(dev, 0, 0x1c, *val);\r\nfor (i = 0; i < 10; i++) {\r\nif ((atp_readw_io(dev, 0, 0x1c) & 0x2000) != 0)\r\ni = 0;\r\n}\r\n*val |= 0x8000;\r\n*val &= 0xe0ff;\r\natp_writew_io(dev, 0, 0x1c, *val);\r\n*val &= 0xbfff;\r\natp_writew_io(dev, 0, 0x1c, *val);\r\nfor (i = 0; i < 10; i++) {\r\nif ((atp_readw_io(dev, 0, 0x1c) & 0x4000) != 0)\r\ni = 0;\r\n}\r\nreturn j;\r\n}\r\nstatic void tscam(struct Scsi_Host *host, bool wide_chip, u8 scam_on)\r\n{\r\nunsigned char i, j, k;\r\nunsigned long n;\r\nunsigned short int m, assignid_map, val;\r\nunsigned char mbuf[33], quintet[2];\r\nstruct atp_unit *dev = (struct atp_unit *)&host->hostdata;\r\nstatic unsigned char g2q_tab[8] = {\r\n0x38, 0x31, 0x32, 0x2b, 0x34, 0x2d, 0x2e, 0x27\r\n};\r\natp_writeb_io(dev, 0, 1, 0x08);\r\natp_writeb_io(dev, 0, 2, 0x7f);\r\natp_writeb_io(dev, 0, 0x11, 0x20);\r\nif ((scam_on & 0x40) == 0) {\r\nreturn;\r\n}\r\nm = 1;\r\nm <<= dev->host_id[0];\r\nj = 16;\r\nif (!wide_chip) {\r\nm |= 0xff00;\r\nj = 8;\r\n}\r\nassignid_map = m;\r\natp_writeb_io(dev, 0, 0x02, 0x02);\r\natp_writeb_io(dev, 0, 0x03, 0);\r\natp_writeb_io(dev, 0, 0x04, 0);\r\natp_writeb_io(dev, 0, 0x05, 0);\r\natp_writeb_io(dev, 0, 0x06, 0);\r\natp_writeb_io(dev, 0, 0x07, 0);\r\natp_writeb_io(dev, 0, 0x08, 0);\r\nfor (i = 0; i < j; i++) {\r\nm = 1;\r\nm = m << i;\r\nif ((m & assignid_map) != 0) {\r\ncontinue;\r\n}\r\natp_writeb_io(dev, 0, 0x0f, 0);\r\natp_writeb_io(dev, 0, 0x12, 0);\r\natp_writeb_io(dev, 0, 0x13, 0);\r\natp_writeb_io(dev, 0, 0x14, 0);\r\nif (i > 7) {\r\nk = (i & 0x07) | 0x40;\r\n} else {\r\nk = i;\r\n}\r\natp_writeb_io(dev, 0, 0x15, k);\r\nif (wide_chip)\r\natp_writeb_io(dev, 0, 0x1b, 0x01);\r\nelse\r\natp_writeb_io(dev, 0, 0x1b, 0x00);\r\ndo {\r\natp_writeb_io(dev, 0, 0x18, 0x09);\r\nwhile ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)\r\ncpu_relax();\r\nk = atp_readb_io(dev, 0, 0x17);\r\nif ((k == 0x85) || (k == 0x42))\r\nbreak;\r\nif (k != 0x16)\r\natp_writeb_io(dev, 0, 0x10, 0x41);\r\n} while (k != 0x16);\r\nif ((k == 0x85) || (k == 0x42))\r\ncontinue;\r\nassignid_map |= m;\r\n}\r\natp_writeb_io(dev, 0, 0x02, 0x7f);\r\natp_writeb_io(dev, 0, 0x1b, 0x02);\r\nudelay(2);\r\nval = 0x0080;\r\natp_writew_io(dev, 0, 0x1c, val);\r\nval |= 0x0040;\r\natp_writew_io(dev, 0, 0x1c, val);\r\nval |= 0x0004;\r\natp_writew_io(dev, 0, 0x1c, val);\r\nudelay(2);\r\nval &= 0x007f;\r\natp_writew_io(dev, 0, 0x1c, val);\r\nmdelay(128);\r\nval &= 0x00fb;\r\natp_writew_io(dev, 0, 0x1c, val);\r\nwhile ((atp_readb_io(dev, 0, 0x1c) & 0x04) != 0)\r\n;\r\nudelay(2);\r\nudelay(100);\r\nfor (n = 0; n < 0x30000; n++)\r\nif ((atp_readb_io(dev, 0, 0x1c) & 0x80) != 0)\r\nbreak;\r\nif (n < 0x30000)\r\nfor (n = 0; n < 0x30000; n++)\r\nif ((atp_readb_io(dev, 0, 0x1c) & 0x81) == 0x0081) {\r\nudelay(2);\r\nval |= 0x8003;\r\natp_writew_io(dev, 0, 0x1c, val);\r\nudelay(2);\r\nval &= 0x00bf;\r\natp_writew_io(dev, 0, 0x1c, val);\r\nudelay(2);\r\nbreak;\r\n}\r\nwhile (1) {\r\nmdelay(2);\r\nudelay(48);\r\nif ((atp_readb_io(dev, 0, 0x1c) & 0x80) == 0x00) {\r\natp_writew_io(dev, 0, 0x1c, 0);\r\natp_writeb_io(dev, 0, 0x1b, 0);\r\natp_writeb_io(dev, 0, 0x15, 0);\r\natp_writeb_io(dev, 0, 0x18, 0x09);\r\nwhile ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0)\r\ncpu_relax();\r\natp_readb_io(dev, 0, 0x17);\r\nreturn;\r\n}\r\nval &= 0x00ff;\r\nval |= 0x3f00;\r\nfun_scam(dev, &val);\r\nudelay(2);\r\nval &= 0x00ff;\r\nval |= 0x2000;\r\nfun_scam(dev, &val);\r\nudelay(2);\r\ni = 8;\r\nj = 0;\r\nwhile (1) {\r\nif ((atp_readw_io(dev, 0, 0x1c) & 0x2000) == 0)\r\ncontinue;\r\nudelay(2);\r\nval &= 0x00ff;\r\nval |= 0x2000;\r\nk = fun_scam(dev, &val);\r\nif ((k & 0x03) == 0)\r\nbreak;\r\nmbuf[j] <<= 0x01;\r\nmbuf[j] &= 0xfe;\r\nif ((k & 0x02) != 0)\r\nmbuf[j] |= 0x01;\r\ni--;\r\nif (i > 0)\r\ncontinue;\r\nj++;\r\ni = 8;\r\n}\r\ni = 15;\r\nj = mbuf[0];\r\nif ((j & 0x20) != 0) {\r\ni = 7;\r\n}\r\nif ((j & 0x06) != 0) {\r\nk = mbuf[1];\r\nwhile (1) {\r\nm = 1;\r\nm <<= k;\r\nif ((m & assignid_map) == 0)\r\nbreak;\r\nif (k > 0)\r\nk--;\r\nelse\r\nbreak;\r\n}\r\n}\r\nif ((m & assignid_map) != 0) {\r\nk = i;\r\nwhile (1) {\r\nm = 1;\r\nm <<= k;\r\nif ((m & assignid_map) == 0)\r\nbreak;\r\nif (k > 0)\r\nk--;\r\nelse\r\nbreak;\r\n}\r\n}\r\nassignid_map |= m;\r\nif (k < 8) {\r\nquintet[0] = 0x38;\r\n} else {\r\nquintet[0] = 0x31;\r\n}\r\nk &= 0x07;\r\nquintet[1] = g2q_tab[k];\r\nval &= 0x00ff;\r\nm = quintet[0] << 8;\r\nval |= m;\r\nfun_scam(dev, &val);\r\nval &= 0x00ff;\r\nm = quintet[1] << 8;\r\nval |= m;\r\nfun_scam(dev, &val);\r\n}\r\n}\r\nstatic void atp870u_free_tables(struct Scsi_Host *host)\r\n{\r\nstruct atp_unit *atp_dev = (struct atp_unit *)&host->hostdata;\r\nint j, k;\r\nfor (j=0; j < 2; j++) {\r\nfor (k = 0; k < 16; k++) {\r\nif (!atp_dev->id[j][k].prd_table)\r\ncontinue;\r\npci_free_consistent(atp_dev->pdev, 1024, atp_dev->id[j][k].prd_table, atp_dev->id[j][k].prd_bus);\r\natp_dev->id[j][k].prd_table = NULL;\r\n}\r\n}\r\n}\r\nstatic int atp870u_init_tables(struct Scsi_Host *host)\r\n{\r\nstruct atp_unit *atp_dev = (struct atp_unit *)&host->hostdata;\r\nint c,k;\r\nfor(c=0;c < 2;c++) {\r\nfor(k=0;k<16;k++) {\r\natp_dev->id[c][k].prd_table = pci_alloc_consistent(atp_dev->pdev, 1024, &(atp_dev->id[c][k].prd_bus));\r\nif (!atp_dev->id[c][k].prd_table) {\r\nprintk("atp870u_init_tables fail\n");\r\natp870u_free_tables(host);\r\nreturn -ENOMEM;\r\n}\r\natp_dev->id[c][k].prdaddr = atp_dev->id[c][k].prd_bus;\r\natp_dev->id[c][k].devsp=0x20;\r\natp_dev->id[c][k].devtype = 0x7f;\r\natp_dev->id[c][k].curr_req = NULL;\r\n}\r\natp_dev->active_id[c] = 0;\r\natp_dev->wide_id[c] = 0;\r\natp_dev->host_id[c] = 0x07;\r\natp_dev->quhd[c] = 0;\r\natp_dev->quend[c] = 0;\r\natp_dev->last_cmd[c] = 0xff;\r\natp_dev->in_snd[c] = 0;\r\natp_dev->in_int[c] = 0;\r\nfor (k = 0; k < qcnt; k++) {\r\natp_dev->quereq[c][k] = NULL;\r\n}\r\nfor (k = 0; k < 16; k++) {\r\natp_dev->id[c][k].curr_req = NULL;\r\natp_dev->sp[c][k] = 0x04;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void atp_set_host_id(struct atp_unit *atp, u8 c, u8 host_id)\r\n{\r\natp_writeb_io(atp, c, 0, host_id | 0x08);\r\natp_writeb_io(atp, c, 0x18, 0);\r\nwhile ((atp_readb_io(atp, c, 0x1f) & 0x80) == 0)\r\nmdelay(1);\r\natp_readb_io(atp, c, 0x17);\r\natp_writeb_io(atp, c, 1, 8);\r\natp_writeb_io(atp, c, 2, 0x7f);\r\natp_writeb_io(atp, c, 0x11, 0x20);\r\n}\r\nstatic void atp870_init(struct Scsi_Host *shpnt)\r\n{\r\nstruct atp_unit *atpdev = shost_priv(shpnt);\r\nstruct pci_dev *pdev = atpdev->pdev;\r\nunsigned char k, host_id;\r\nu8 scam_on;\r\nbool wide_chip =\r\n(pdev->device == PCI_DEVICE_ID_ARTOP_AEC7610 &&\r\npdev->revision == 4) ||\r\n(pdev->device == PCI_DEVICE_ID_ARTOP_AEC7612UW) ||\r\n(pdev->device == PCI_DEVICE_ID_ARTOP_AEC7612SUW);\r\npci_read_config_byte(pdev, 0x49, &host_id);\r\ndev_info(&pdev->dev, "ACARD AEC-671X PCI Ultra/W SCSI-2/3 Host Adapter: IO:%lx, IRQ:%d.\n",\r\nshpnt->io_port, shpnt->irq);\r\natpdev->ioport[0] = shpnt->io_port;\r\natpdev->pciport[0] = shpnt->io_port + 0x20;\r\nhost_id &= 0x07;\r\natpdev->host_id[0] = host_id;\r\nscam_on = atp_readb_pci(atpdev, 0, 2);\r\natpdev->global_map[0] = atp_readb_base(atpdev, 0x2d);\r\natpdev->ultra_map[0] = atp_readw_base(atpdev, 0x2e);\r\nif (atpdev->ultra_map[0] == 0) {\r\nscam_on = 0x00;\r\natpdev->global_map[0] = 0x20;\r\natpdev->ultra_map[0] = 0xffff;\r\n}\r\nif (pdev->revision > 0x07)\r\natp_writeb_base(atpdev, 0x3e, 0x00);\r\nk = (atp_readb_base(atpdev, 0x3a) & 0xf3) | 0x10;\r\natp_writeb_base(atpdev, 0x3a, k);\r\natp_writeb_base(atpdev, 0x3a, k & 0xdf);\r\nmdelay(32);\r\natp_writeb_base(atpdev, 0x3a, k);\r\nmdelay(32);\r\natp_set_host_id(atpdev, 0, host_id);\r\ntscam(shpnt, wide_chip, scam_on);\r\natp_writeb_base(atpdev, 0x3a, atp_readb_base(atpdev, 0x3a) | 0x10);\r\natp_is(atpdev, 0, wide_chip, 0);\r\natp_writeb_base(atpdev, 0x3a, atp_readb_base(atpdev, 0x3a) & 0xef);\r\natp_writeb_base(atpdev, 0x3b, atp_readb_base(atpdev, 0x3b) | 0x20);\r\nshpnt->max_id = wide_chip ? 16 : 8;\r\nshpnt->this_id = host_id;\r\n}\r\nstatic void atp880_init(struct Scsi_Host *shpnt)\r\n{\r\nstruct atp_unit *atpdev = shost_priv(shpnt);\r\nstruct pci_dev *pdev = atpdev->pdev;\r\nunsigned char k, m, host_id;\r\nunsigned int n;\r\npci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0x80);\r\natpdev->ioport[0] = shpnt->io_port + 0x40;\r\natpdev->pciport[0] = shpnt->io_port + 0x28;\r\nhost_id = atp_readb_base(atpdev, 0x39) >> 4;\r\ndev_info(&pdev->dev, "ACARD AEC-67160 PCI Ultra3 LVD Host Adapter: IO:%lx, IRQ:%d.\n",\r\nshpnt->io_port, shpnt->irq);\r\natpdev->host_id[0] = host_id;\r\natpdev->global_map[0] = atp_readb_base(atpdev, 0x35);\r\natpdev->ultra_map[0] = atp_readw_base(atpdev, 0x3c);\r\nn = 0x3f09;\r\nwhile (n < 0x4000) {\r\nm = 0;\r\natp_writew_base(atpdev, 0x34, n);\r\nn += 0x0002;\r\nif (atp_readb_base(atpdev, 0x30) == 0xff)\r\nbreak;\r\natpdev->sp[0][m++] = atp_readb_base(atpdev, 0x30);\r\natpdev->sp[0][m++] = atp_readb_base(atpdev, 0x31);\r\natpdev->sp[0][m++] = atp_readb_base(atpdev, 0x32);\r\natpdev->sp[0][m++] = atp_readb_base(atpdev, 0x33);\r\natp_writew_base(atpdev, 0x34, n);\r\nn += 0x0002;\r\natpdev->sp[0][m++] = atp_readb_base(atpdev, 0x30);\r\natpdev->sp[0][m++] = atp_readb_base(atpdev, 0x31);\r\natpdev->sp[0][m++] = atp_readb_base(atpdev, 0x32);\r\natpdev->sp[0][m++] = atp_readb_base(atpdev, 0x33);\r\natp_writew_base(atpdev, 0x34, n);\r\nn += 0x0002;\r\natpdev->sp[0][m++] = atp_readb_base(atpdev, 0x30);\r\natpdev->sp[0][m++] = atp_readb_base(atpdev, 0x31);\r\natpdev->sp[0][m++] = atp_readb_base(atpdev, 0x32);\r\natpdev->sp[0][m++] = atp_readb_base(atpdev, 0x33);\r\natp_writew_base(atpdev, 0x34, n);\r\nn += 0x0002;\r\natpdev->sp[0][m++] = atp_readb_base(atpdev, 0x30);\r\natpdev->sp[0][m++] = atp_readb_base(atpdev, 0x31);\r\natpdev->sp[0][m++] = atp_readb_base(atpdev, 0x32);\r\natpdev->sp[0][m++] = atp_readb_base(atpdev, 0x33);\r\nn += 0x0018;\r\n}\r\natp_writew_base(atpdev, 0x34, 0);\r\natpdev->ultra_map[0] = 0;\r\natpdev->async[0] = 0;\r\nfor (k = 0; k < 16; k++) {\r\nn = 1 << k;\r\nif (atpdev->sp[0][k] > 1)\r\natpdev->ultra_map[0] |= n;\r\nelse\r\nif (atpdev->sp[0][k] == 0)\r\natpdev->async[0] |= n;\r\n}\r\natpdev->async[0] = ~(atpdev->async[0]);\r\natp_writeb_base(atpdev, 0x35, atpdev->global_map[0]);\r\nk = atp_readb_base(atpdev, 0x38) & 0x80;\r\natp_writeb_base(atpdev, 0x38, k);\r\natp_writeb_base(atpdev, 0x3b, 0x20);\r\nmdelay(32);\r\natp_writeb_base(atpdev, 0x3b, 0);\r\nmdelay(32);\r\natp_readb_io(atpdev, 0, 0x1b);\r\natp_readb_io(atpdev, 0, 0x17);\r\natp_set_host_id(atpdev, 0, host_id);\r\ntscam(shpnt, true, atp_readb_base(atpdev, 0x22));\r\natp_is(atpdev, 0, true, atp_readb_base(atpdev, 0x3f) & 0x40);\r\natp_writeb_base(atpdev, 0x38, 0xb0);\r\nshpnt->max_id = 16;\r\nshpnt->this_id = host_id;\r\n}\r\nstatic void atp885_init(struct Scsi_Host *shpnt)\r\n{\r\nstruct atp_unit *atpdev = shost_priv(shpnt);\r\nstruct pci_dev *pdev = atpdev->pdev;\r\nunsigned char k, m, c;\r\nunsigned int n;\r\nunsigned char setupdata[2][16];\r\ndev_info(&pdev->dev, "ACARD AEC-67162 PCI Ultra3 LVD Host Adapter: IO:%lx, IRQ:%d.\n",\r\nshpnt->io_port, shpnt->irq);\r\natpdev->ioport[0] = shpnt->io_port + 0x80;\r\natpdev->ioport[1] = shpnt->io_port + 0xc0;\r\natpdev->pciport[0] = shpnt->io_port + 0x40;\r\natpdev->pciport[1] = shpnt->io_port + 0x50;\r\nc = atp_readb_base(atpdev, 0x29);\r\natp_writeb_base(atpdev, 0x29, c | 0x04);\r\nn = 0x1f80;\r\nwhile (n < 0x2000) {\r\natp_writew_base(atpdev, 0x3c, n);\r\nif (atp_readl_base(atpdev, 0x38) == 0xffffffff)\r\nbreak;\r\nfor (m = 0; m < 2; m++) {\r\natpdev->global_map[m] = 0;\r\nfor (k = 0; k < 4; k++) {\r\natp_writew_base(atpdev, 0x3c, n++);\r\n((unsigned long *)&setupdata[m][0])[k] = atp_readl_base(atpdev, 0x38);\r\n}\r\nfor (k = 0; k < 4; k++) {\r\natp_writew_base(atpdev, 0x3c, n++);\r\n((unsigned long *)&atpdev->sp[m][0])[k] = atp_readl_base(atpdev, 0x38);\r\n}\r\nn += 8;\r\n}\r\n}\r\nc = atp_readb_base(atpdev, 0x29);\r\natp_writeb_base(atpdev, 0x29, c & 0xfb);\r\nfor (c = 0; c < 2; c++) {\r\natpdev->ultra_map[c] = 0;\r\natpdev->async[c] = 0;\r\nfor (k = 0; k < 16; k++) {\r\nn = 1 << k;\r\nif (atpdev->sp[c][k] > 1)\r\natpdev->ultra_map[c] |= n;\r\nelse\r\nif (atpdev->sp[c][k] == 0)\r\natpdev->async[c] |= n;\r\n}\r\natpdev->async[c] = ~(atpdev->async[c]);\r\nif (atpdev->global_map[c] == 0) {\r\nk = setupdata[c][1];\r\nif ((k & 0x40) != 0)\r\natpdev->global_map[c] |= 0x20;\r\nk &= 0x07;\r\natpdev->global_map[c] |= k;\r\nif ((setupdata[c][2] & 0x04) != 0)\r\natpdev->global_map[c] |= 0x08;\r\natpdev->host_id[c] = setupdata[c][0] & 0x07;\r\n}\r\n}\r\nk = atp_readb_base(atpdev, 0x28) & 0x8f;\r\nk |= 0x10;\r\natp_writeb_base(atpdev, 0x28, k);\r\natp_writeb_pci(atpdev, 0, 1, 0x80);\r\natp_writeb_pci(atpdev, 1, 1, 0x80);\r\nmdelay(100);\r\natp_writeb_pci(atpdev, 0, 1, 0);\r\natp_writeb_pci(atpdev, 1, 1, 0);\r\nmdelay(1000);\r\natp_readb_io(atpdev, 0, 0x1b);\r\natp_readb_io(atpdev, 0, 0x17);\r\natp_readb_io(atpdev, 1, 0x1b);\r\natp_readb_io(atpdev, 1, 0x17);\r\nk = atpdev->host_id[0];\r\nif (k > 7)\r\nk = (k & 0x07) | 0x40;\r\natp_set_host_id(atpdev, 0, k);\r\nk = atpdev->host_id[1];\r\nif (k > 7)\r\nk = (k & 0x07) | 0x40;\r\natp_set_host_id(atpdev, 1, k);\r\nmdelay(600);\r\ndev_info(&pdev->dev, "Scanning Channel A SCSI Device ...\n");\r\natp_is(atpdev, 0, true, atp_readb_io(atpdev, 0, 0x1b) >> 7);\r\natp_writeb_io(atpdev, 0, 0x16, 0x80);\r\ndev_info(&pdev->dev, "Scanning Channel B SCSI Device ...\n");\r\natp_is(atpdev, 1, true, atp_readb_io(atpdev, 1, 0x1b) >> 7);\r\natp_writeb_io(atpdev, 1, 0x16, 0x80);\r\nk = atp_readb_base(atpdev, 0x28) & 0xcf;\r\nk |= 0xc0;\r\natp_writeb_base(atpdev, 0x28, k);\r\nk = atp_readb_base(atpdev, 0x1f) | 0x80;\r\natp_writeb_base(atpdev, 0x1f, k);\r\nk = atp_readb_base(atpdev, 0x29) | 0x01;\r\natp_writeb_base(atpdev, 0x29, k);\r\nshpnt->max_id = 16;\r\nshpnt->max_lun = (atpdev->global_map[0] & 0x07) + 1;\r\nshpnt->max_channel = 1;\r\nshpnt->this_id = atpdev->host_id[0];\r\n}\r\nstatic int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct Scsi_Host *shpnt = NULL;\r\nstruct atp_unit *atpdev;\r\nint err;\r\nif (ent->device == PCI_DEVICE_ID_ARTOP_AEC7610 && pdev->revision < 2) {\r\ndev_err(&pdev->dev, "ATP850S chips (AEC6710L/F cards) are not supported.\n");\r\nreturn -ENODEV;\r\n}\r\nerr = pci_enable_device(pdev);\r\nif (err)\r\ngoto fail;\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {\r\nprintk(KERN_ERR "atp870u: DMA mask required but not available.\n");\r\nerr = -EIO;\r\ngoto disable_device;\r\n}\r\nerr = pci_request_regions(pdev, "atp870u");\r\nif (err)\r\ngoto disable_device;\r\npci_set_master(pdev);\r\nerr = -ENOMEM;\r\nshpnt = scsi_host_alloc(&atp870u_template, sizeof(struct atp_unit));\r\nif (!shpnt)\r\ngoto release_region;\r\natpdev = shost_priv(shpnt);\r\natpdev->host = shpnt;\r\natpdev->pdev = pdev;\r\npci_set_drvdata(pdev, atpdev);\r\nshpnt->io_port = pci_resource_start(pdev, 0);\r\nshpnt->io_port &= 0xfffffff8;\r\nshpnt->n_io_port = pci_resource_len(pdev, 0);\r\natpdev->baseport = shpnt->io_port;\r\nshpnt->unique_id = shpnt->io_port;\r\nshpnt->irq = pdev->irq;\r\nerr = atp870u_init_tables(shpnt);\r\nif (err) {\r\ndev_err(&pdev->dev, "Unable to allocate tables for Acard controller\n");\r\ngoto unregister;\r\n}\r\nif (is880(atpdev))\r\natp880_init(shpnt);\r\nelse if (is885(atpdev))\r\natp885_init(shpnt);\r\nelse\r\natp870_init(shpnt);\r\nerr = request_irq(shpnt->irq, atp870u_intr_handle, IRQF_SHARED, "atp870u", shpnt);\r\nif (err) {\r\ndev_err(&pdev->dev, "Unable to allocate IRQ %d.\n", shpnt->irq);\r\ngoto free_tables;\r\n}\r\nerr = scsi_add_host(shpnt, &pdev->dev);\r\nif (err)\r\ngoto scsi_add_fail;\r\nscsi_scan_host(shpnt);\r\nreturn 0;\r\nscsi_add_fail:\r\nfree_irq(shpnt->irq, shpnt);\r\nfree_tables:\r\natp870u_free_tables(shpnt);\r\nunregister:\r\nscsi_host_put(shpnt);\r\nrelease_region:\r\npci_release_regions(pdev);\r\ndisable_device:\r\npci_disable_device(pdev);\r\nfail:\r\nreturn err;\r\n}\r\nstatic int atp870u_abort(struct scsi_cmnd * SCpnt)\r\n{\r\nunsigned char j, k, c;\r\nstruct scsi_cmnd *workrequ;\r\nstruct atp_unit *dev;\r\nstruct Scsi_Host *host;\r\nhost = SCpnt->device->host;\r\ndev = (struct atp_unit *)&host->hostdata;\r\nc = scmd_channel(SCpnt);\r\nprintk(" atp870u: abort Channel = %x \n", c);\r\nprintk("working=%x last_cmd=%x ", dev->working[c], dev->last_cmd[c]);\r\nprintk(" quhdu=%x quendu=%x ", dev->quhd[c], dev->quend[c]);\r\nfor (j = 0; j < 0x18; j++) {\r\nprintk(" r%2x=%2x", j, atp_readb_io(dev, c, j));\r\n}\r\nprintk(" r1c=%2x", atp_readb_io(dev, c, 0x1c));\r\nprintk(" r1f=%2x in_snd=%2x ", atp_readb_io(dev, c, 0x1f), dev->in_snd[c]);\r\nprintk(" d00=%2x", atp_readb_pci(dev, c, 0x00));\r\nprintk(" d02=%2x", atp_readb_pci(dev, c, 0x02));\r\nfor(j=0;j<16;j++) {\r\nif (dev->id[c][j].curr_req != NULL) {\r\nworkrequ = dev->id[c][j].curr_req;\r\nprintk("\n que cdb= ");\r\nfor (k=0; k < workrequ->cmd_len; k++) {\r\nprintk(" %2x ",workrequ->cmnd[k]);\r\n}\r\nprintk(" last_lenu= %x ",(unsigned int)dev->id[c][j].last_len);\r\n}\r\n}\r\nreturn SUCCESS;\r\n}\r\nstatic const char *atp870u_info(struct Scsi_Host *notused)\r\n{\r\nstatic char buffer[128];\r\nstrcpy(buffer, "ACARD AEC-6710/6712/67160 PCI Ultra/W/LVD SCSI-3 Adapter Driver V2.6+ac ");\r\nreturn buffer;\r\n}\r\nstatic int atp870u_show_info(struct seq_file *m, struct Scsi_Host *HBAptr)\r\n{\r\nseq_puts(m, "ACARD AEC-671X Driver Version: 2.6+ac\n\n"\r\n"Adapter Configuration:\n");\r\nseq_printf(m, " Base IO: %#.4lx\n", HBAptr->io_port);\r\nseq_printf(m, " IRQ: %d\n", HBAptr->irq);\r\nreturn 0;\r\n}\r\nstatic int atp870u_biosparam(struct scsi_device *disk, struct block_device *dev,\r\nsector_t capacity, int *ip)\r\n{\r\nint heads, sectors, cylinders;\r\nheads = 64;\r\nsectors = 32;\r\ncylinders = (unsigned long)capacity / (heads * sectors);\r\nif (cylinders > 1024) {\r\nheads = 255;\r\nsectors = 63;\r\ncylinders = (unsigned long)capacity / (heads * sectors);\r\n}\r\nip[0] = heads;\r\nip[1] = sectors;\r\nip[2] = cylinders;\r\nreturn 0;\r\n}\r\nstatic void atp870u_remove (struct pci_dev *pdev)\r\n{\r\nstruct atp_unit *devext = pci_get_drvdata(pdev);\r\nstruct Scsi_Host *pshost = devext->host;\r\nscsi_remove_host(pshost);\r\nfree_irq(pshost->irq, pshost);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\natp870u_free_tables(pshost);\r\nscsi_host_put(pshost);\r\n}\r\nstatic void atp_is(struct atp_unit *dev, unsigned char c, bool wide_chip, unsigned char lvdmode)\r\n{\r\nunsigned char i, j, k, rmb, n;\r\nunsigned short int m;\r\nstatic unsigned char mbuf[512];\r\nstatic unsigned char satn[9] = { 0, 0, 0, 0, 0, 0, 0, 6, 6 };\r\nstatic unsigned char inqd[9] = { 0x12, 0, 0, 0, 0x24, 0, 0, 0x24, 6 };\r\nstatic unsigned char synn[6] = { 0x80, 1, 3, 1, 0x19, 0x0e };\r\nunsigned char synu[6] = { 0x80, 1, 3, 1, 0x0a, 0x0e };\r\nstatic unsigned char synw[6] = { 0x80, 1, 3, 1, 0x19, 0x0e };\r\nstatic unsigned char synw_870[6] = { 0x80, 1, 3, 1, 0x0c, 0x07 };\r\nunsigned char synuw[6] = { 0x80, 1, 3, 1, 0x0a, 0x0e };\r\nstatic unsigned char wide[6] = { 0x80, 1, 2, 3, 1, 0 };\r\nstatic unsigned char u3[9] = { 0x80, 1, 6, 4, 0x09, 00, 0x0e, 0x01, 0x02 };\r\nfor (i = 0; i < 16; i++) {\r\nif (!wide_chip && (i > 7))\r\nbreak;\r\nm = 1;\r\nm = m << i;\r\nif ((m & dev->active_id[c]) != 0) {\r\ncontinue;\r\n}\r\nif (i == dev->host_id[c]) {\r\nprintk(KERN_INFO " ID: %2d Host Adapter\n", dev->host_id[c]);\r\ncontinue;\r\n}\r\natp_writeb_io(dev, c, 0x1b, wide_chip ? 0x01 : 0x00);\r\natp_writeb_io(dev, c, 1, 0x08);\r\natp_writeb_io(dev, c, 2, 0x7f);\r\natp_writeb_io(dev, c, 3, satn[0]);\r\natp_writeb_io(dev, c, 4, satn[1]);\r\natp_writeb_io(dev, c, 5, satn[2]);\r\natp_writeb_io(dev, c, 6, satn[3]);\r\natp_writeb_io(dev, c, 7, satn[4]);\r\natp_writeb_io(dev, c, 8, satn[5]);\r\natp_writeb_io(dev, c, 0x0f, 0);\r\natp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);\r\natp_writeb_io(dev, c, 0x12, 0);\r\natp_writeb_io(dev, c, 0x13, satn[6]);\r\natp_writeb_io(dev, c, 0x14, satn[7]);\r\nj = i;\r\nif ((j & 0x08) != 0) {\r\nj = (j & 0x07) | 0x40;\r\n}\r\natp_writeb_io(dev, c, 0x15, j);\r\natp_writeb_io(dev, c, 0x18, satn[8]);\r\nwhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)\r\ncpu_relax();\r\nif (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)\r\ncontinue;\r\nwhile (atp_readb_io(dev, c, 0x17) != 0x8e)\r\ncpu_relax();\r\ndev->active_id[c] |= m;\r\natp_writeb_io(dev, c, 0x10, 0x30);\r\nif (is885(dev) || is880(dev))\r\natp_writeb_io(dev, c, 0x14, 0x00);\r\nelse\r\natp_writeb_io(dev, c, 0x04, 0x00);\r\nphase_cmd:\r\natp_writeb_io(dev, c, 0x18, 0x08);\r\nwhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)\r\ncpu_relax();\r\nj = atp_readb_io(dev, c, 0x17);\r\nif (j != 0x16) {\r\natp_writeb_io(dev, c, 0x10, 0x41);\r\ngoto phase_cmd;\r\n}\r\nsel_ok:\r\natp_writeb_io(dev, c, 3, inqd[0]);\r\natp_writeb_io(dev, c, 4, inqd[1]);\r\natp_writeb_io(dev, c, 5, inqd[2]);\r\natp_writeb_io(dev, c, 6, inqd[3]);\r\natp_writeb_io(dev, c, 7, inqd[4]);\r\natp_writeb_io(dev, c, 8, inqd[5]);\r\natp_writeb_io(dev, c, 0x0f, 0);\r\natp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);\r\natp_writeb_io(dev, c, 0x12, 0);\r\natp_writeb_io(dev, c, 0x13, inqd[6]);\r\natp_writeb_io(dev, c, 0x14, inqd[7]);\r\natp_writeb_io(dev, c, 0x18, inqd[8]);\r\nwhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)\r\ncpu_relax();\r\nif (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)\r\ncontinue;\r\nwhile (atp_readb_io(dev, c, 0x17) != 0x8e)\r\ncpu_relax();\r\nif (wide_chip)\r\natp_writeb_io(dev, c, 0x1b, 0x00);\r\natp_writeb_io(dev, c, 0x18, 0x08);\r\nj = 0;\r\nrd_inq_data:\r\nk = atp_readb_io(dev, c, 0x1f);\r\nif ((k & 0x01) != 0) {\r\nmbuf[j++] = atp_readb_io(dev, c, 0x19);\r\ngoto rd_inq_data;\r\n}\r\nif ((k & 0x80) == 0) {\r\ngoto rd_inq_data;\r\n}\r\nj = atp_readb_io(dev, c, 0x17);\r\nif (j == 0x16) {\r\ngoto inq_ok;\r\n}\r\natp_writeb_io(dev, c, 0x10, 0x46);\r\natp_writeb_io(dev, c, 0x12, 0);\r\natp_writeb_io(dev, c, 0x13, 0);\r\natp_writeb_io(dev, c, 0x14, 0);\r\natp_writeb_io(dev, c, 0x18, 0x08);\r\nwhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)\r\ncpu_relax();\r\nif (atp_readb_io(dev, c, 0x17) != 0x16)\r\ngoto sel_ok;\r\ninq_ok:\r\nmbuf[36] = 0;\r\nprintk(KERN_INFO " ID: %2d %s\n", i, &mbuf[8]);\r\ndev->id[c][i].devtype = mbuf[0];\r\nrmb = mbuf[1];\r\nn = mbuf[7];\r\nif (!wide_chip)\r\ngoto not_wide;\r\nif ((mbuf[7] & 0x60) == 0) {\r\ngoto not_wide;\r\n}\r\nif (is885(dev) || is880(dev)) {\r\nif ((i < 8) && ((dev->global_map[c] & 0x20) == 0))\r\ngoto not_wide;\r\n} else {\r\nif ((dev->global_map[c] & 0x20) == 0)\r\ngoto not_wide;\r\n}\r\nif (lvdmode == 0) {\r\ngoto chg_wide;\r\n}\r\nif (dev->sp[c][i] != 0x04)\r\n{\r\ngoto chg_wide;\r\n}\r\natp_writeb_io(dev, c, 0x1b, 0x01);\r\natp_writeb_io(dev, c, 3, satn[0]);\r\natp_writeb_io(dev, c, 4, satn[1]);\r\natp_writeb_io(dev, c, 5, satn[2]);\r\natp_writeb_io(dev, c, 6, satn[3]);\r\natp_writeb_io(dev, c, 7, satn[4]);\r\natp_writeb_io(dev, c, 8, satn[5]);\r\natp_writeb_io(dev, c, 0x0f, 0);\r\natp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);\r\natp_writeb_io(dev, c, 0x12, 0);\r\natp_writeb_io(dev, c, 0x13, satn[6]);\r\natp_writeb_io(dev, c, 0x14, satn[7]);\r\natp_writeb_io(dev, c, 0x18, satn[8]);\r\nwhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)\r\ncpu_relax();\r\nif (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)\r\ncontinue;\r\nwhile (atp_readb_io(dev, c, 0x17) != 0x8e)\r\ncpu_relax();\r\ntry_u3:\r\nj = 0;\r\natp_writeb_io(dev, c, 0x14, 0x09);\r\natp_writeb_io(dev, c, 0x18, 0x20);\r\nwhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {\r\nif ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0)\r\natp_writeb_io(dev, c, 0x19, u3[j++]);\r\ncpu_relax();\r\n}\r\nwhile ((atp_readb_io(dev, c, 0x17) & 0x80) == 0x00)\r\ncpu_relax();\r\nj = atp_readb_io(dev, c, 0x17) & 0x0f;\r\nif (j == 0x0f) {\r\ngoto u3p_in;\r\n}\r\nif (j == 0x0a) {\r\ngoto u3p_cmd;\r\n}\r\nif (j == 0x0e) {\r\ngoto try_u3;\r\n}\r\ncontinue;\r\nu3p_out:\r\natp_writeb_io(dev, c, 0x18, 0x20);\r\nwhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {\r\nif ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0)\r\natp_writeb_io(dev, c, 0x19, 0);\r\ncpu_relax();\r\n}\r\nj = atp_readb_io(dev, c, 0x17) & 0x0f;\r\nif (j == 0x0f) {\r\ngoto u3p_in;\r\n}\r\nif (j == 0x0a) {\r\ngoto u3p_cmd;\r\n}\r\nif (j == 0x0e) {\r\ngoto u3p_out;\r\n}\r\ncontinue;\r\nu3p_in:\r\natp_writeb_io(dev, c, 0x14, 0x09);\r\natp_writeb_io(dev, c, 0x18, 0x20);\r\nk = 0;\r\nu3p_in1:\r\nj = atp_readb_io(dev, c, 0x1f);\r\nif ((j & 0x01) != 0) {\r\nmbuf[k++] = atp_readb_io(dev, c, 0x19);\r\ngoto u3p_in1;\r\n}\r\nif ((j & 0x80) == 0x00) {\r\ngoto u3p_in1;\r\n}\r\nj = atp_readb_io(dev, c, 0x17) & 0x0f;\r\nif (j == 0x0f) {\r\ngoto u3p_in;\r\n}\r\nif (j == 0x0a) {\r\ngoto u3p_cmd;\r\n}\r\nif (j == 0x0e) {\r\ngoto u3p_out;\r\n}\r\ncontinue;\r\nu3p_cmd:\r\natp_writeb_io(dev, c, 0x10, 0x30);\r\natp_writeb_io(dev, c, 0x14, 0x00);\r\natp_writeb_io(dev, c, 0x18, 0x08);\r\nwhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00);\r\nj = atp_readb_io(dev, c, 0x17);\r\nif (j != 0x16) {\r\nif (j == 0x4e) {\r\ngoto u3p_out;\r\n}\r\ncontinue;\r\n}\r\nif (mbuf[0] != 0x01) {\r\ngoto chg_wide;\r\n}\r\nif (mbuf[1] != 0x06) {\r\ngoto chg_wide;\r\n}\r\nif (mbuf[2] != 0x04) {\r\ngoto chg_wide;\r\n}\r\nif (mbuf[3] == 0x09) {\r\nm = 1;\r\nm = m << i;\r\ndev->wide_id[c] |= m;\r\ndev->id[c][i].devsp = 0xce;\r\n#ifdef ED_DBGP\r\nprintk("dev->id[%2d][%2d].devsp = %2x\n",c,i,dev->id[c][i].devsp);\r\n#endif\r\ncontinue;\r\n}\r\nchg_wide:\r\natp_writeb_io(dev, c, 0x1b, 0x01);\r\natp_writeb_io(dev, c, 3, satn[0]);\r\natp_writeb_io(dev, c, 4, satn[1]);\r\natp_writeb_io(dev, c, 5, satn[2]);\r\natp_writeb_io(dev, c, 6, satn[3]);\r\natp_writeb_io(dev, c, 7, satn[4]);\r\natp_writeb_io(dev, c, 8, satn[5]);\r\natp_writeb_io(dev, c, 0x0f, 0);\r\natp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);\r\natp_writeb_io(dev, c, 0x12, 0);\r\natp_writeb_io(dev, c, 0x13, satn[6]);\r\natp_writeb_io(dev, c, 0x14, satn[7]);\r\natp_writeb_io(dev, c, 0x18, satn[8]);\r\nwhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)\r\ncpu_relax();\r\nif (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)\r\ncontinue;\r\nwhile (atp_readb_io(dev, c, 0x17) != 0x8e)\r\ncpu_relax();\r\ntry_wide:\r\nj = 0;\r\natp_writeb_io(dev, c, 0x14, 0x05);\r\natp_writeb_io(dev, c, 0x18, 0x20);\r\nwhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {\r\nif ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0)\r\natp_writeb_io(dev, c, 0x19, wide[j++]);\r\ncpu_relax();\r\n}\r\nwhile ((atp_readb_io(dev, c, 0x17) & 0x80) == 0x00)\r\ncpu_relax();\r\nj = atp_readb_io(dev, c, 0x17) & 0x0f;\r\nif (j == 0x0f) {\r\ngoto widep_in;\r\n}\r\nif (j == 0x0a) {\r\ngoto widep_cmd;\r\n}\r\nif (j == 0x0e) {\r\ngoto try_wide;\r\n}\r\ncontinue;\r\nwidep_out:\r\natp_writeb_io(dev, c, 0x18, 0x20);\r\nwhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {\r\nif ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0)\r\natp_writeb_io(dev, c, 0x19, 0);\r\ncpu_relax();\r\n}\r\nj = atp_readb_io(dev, c, 0x17) & 0x0f;\r\nif (j == 0x0f) {\r\ngoto widep_in;\r\n}\r\nif (j == 0x0a) {\r\ngoto widep_cmd;\r\n}\r\nif (j == 0x0e) {\r\ngoto widep_out;\r\n}\r\ncontinue;\r\nwidep_in:\r\natp_writeb_io(dev, c, 0x14, 0xff);\r\natp_writeb_io(dev, c, 0x18, 0x20);\r\nk = 0;\r\nwidep_in1:\r\nj = atp_readb_io(dev, c, 0x1f);\r\nif ((j & 0x01) != 0) {\r\nmbuf[k++] = atp_readb_io(dev, c, 0x19);\r\ngoto widep_in1;\r\n}\r\nif ((j & 0x80) == 0x00) {\r\ngoto widep_in1;\r\n}\r\nj = atp_readb_io(dev, c, 0x17) & 0x0f;\r\nif (j == 0x0f) {\r\ngoto widep_in;\r\n}\r\nif (j == 0x0a) {\r\ngoto widep_cmd;\r\n}\r\nif (j == 0x0e) {\r\ngoto widep_out;\r\n}\r\ncontinue;\r\nwidep_cmd:\r\natp_writeb_io(dev, c, 0x10, 0x30);\r\natp_writeb_io(dev, c, 0x14, 0x00);\r\natp_writeb_io(dev, c, 0x18, 0x08);\r\nwhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)\r\ncpu_relax();\r\nj = atp_readb_io(dev, c, 0x17);\r\nif (j != 0x16) {\r\nif (j == 0x4e) {\r\ngoto widep_out;\r\n}\r\ncontinue;\r\n}\r\nif (mbuf[0] != 0x01) {\r\ngoto not_wide;\r\n}\r\nif (mbuf[1] != 0x02) {\r\ngoto not_wide;\r\n}\r\nif (mbuf[2] != 0x03) {\r\ngoto not_wide;\r\n}\r\nif (mbuf[3] != 0x01) {\r\ngoto not_wide;\r\n}\r\nm = 1;\r\nm = m << i;\r\ndev->wide_id[c] |= m;\r\nnot_wide:\r\nif ((dev->id[c][i].devtype == 0x00) || (dev->id[c][i].devtype == 0x07) || ((dev->id[c][i].devtype == 0x05) && ((n & 0x10) != 0))) {\r\nm = 1;\r\nm = m << i;\r\nif ((dev->async[c] & m) != 0) {\r\ngoto set_sync;\r\n}\r\n}\r\ncontinue;\r\nset_sync:\r\nif ((!is885(dev) && !is880(dev)) || (dev->sp[c][i] == 0x02)) {\r\nsynu[4] = 0x0c;\r\nsynuw[4] = 0x0c;\r\n} else {\r\nif (dev->sp[c][i] >= 0x03) {\r\nsynu[4] = 0x0a;\r\nsynuw[4] = 0x0a;\r\n}\r\n}\r\nj = 0;\r\nif ((m & dev->wide_id[c]) != 0) {\r\nj |= 0x01;\r\n}\r\natp_writeb_io(dev, c, 0x1b, j);\r\natp_writeb_io(dev, c, 3, satn[0]);\r\natp_writeb_io(dev, c, 4, satn[1]);\r\natp_writeb_io(dev, c, 5, satn[2]);\r\natp_writeb_io(dev, c, 6, satn[3]);\r\natp_writeb_io(dev, c, 7, satn[4]);\r\natp_writeb_io(dev, c, 8, satn[5]);\r\natp_writeb_io(dev, c, 0x0f, 0);\r\natp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);\r\natp_writeb_io(dev, c, 0x12, 0);\r\natp_writeb_io(dev, c, 0x13, satn[6]);\r\natp_writeb_io(dev, c, 0x14, satn[7]);\r\natp_writeb_io(dev, c, 0x18, satn[8]);\r\nwhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)\r\ncpu_relax();\r\nif (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)\r\ncontinue;\r\nwhile (atp_readb_io(dev, c, 0x17) != 0x8e)\r\ncpu_relax();\r\ntry_sync:\r\nj = 0;\r\natp_writeb_io(dev, c, 0x14, 0x06);\r\natp_writeb_io(dev, c, 0x18, 0x20);\r\nwhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {\r\nif ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0) {\r\nif ((m & dev->wide_id[c]) != 0) {\r\nif (is885(dev) || is880(dev)) {\r\nif ((m & dev->ultra_map[c]) != 0) {\r\natp_writeb_io(dev, c, 0x19, synuw[j++]);\r\n} else {\r\natp_writeb_io(dev, c, 0x19, synw[j++]);\r\n}\r\n} else\r\natp_writeb_io(dev, c, 0x19, synw_870[j++]);\r\n} else {\r\nif ((m & dev->ultra_map[c]) != 0) {\r\natp_writeb_io(dev, c, 0x19, synu[j++]);\r\n} else {\r\natp_writeb_io(dev, c, 0x19, synn[j++]);\r\n}\r\n}\r\n}\r\n}\r\nwhile ((atp_readb_io(dev, c, 0x17) & 0x80) == 0x00)\r\ncpu_relax();\r\nj = atp_readb_io(dev, c, 0x17) & 0x0f;\r\nif (j == 0x0f) {\r\ngoto phase_ins;\r\n}\r\nif (j == 0x0a) {\r\ngoto phase_cmds;\r\n}\r\nif (j == 0x0e) {\r\ngoto try_sync;\r\n}\r\ncontinue;\r\nphase_outs:\r\natp_writeb_io(dev, c, 0x18, 0x20);\r\nwhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00) {\r\nif ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0x00)\r\natp_writeb_io(dev, c, 0x19, 0x00);\r\ncpu_relax();\r\n}\r\nj = atp_readb_io(dev, c, 0x17);\r\nif (j == 0x85) {\r\ngoto tar_dcons;\r\n}\r\nj &= 0x0f;\r\nif (j == 0x0f) {\r\ngoto phase_ins;\r\n}\r\nif (j == 0x0a) {\r\ngoto phase_cmds;\r\n}\r\nif (j == 0x0e) {\r\ngoto phase_outs;\r\n}\r\ncontinue;\r\nphase_ins:\r\nif (is885(dev) || is880(dev))\r\natp_writeb_io(dev, c, 0x14, 0x06);\r\nelse\r\natp_writeb_io(dev, c, 0x14, 0xff);\r\natp_writeb_io(dev, c, 0x18, 0x20);\r\nk = 0;\r\nphase_ins1:\r\nj = atp_readb_io(dev, c, 0x1f);\r\nif ((j & 0x01) != 0x00) {\r\nmbuf[k++] = atp_readb_io(dev, c, 0x19);\r\ngoto phase_ins1;\r\n}\r\nif ((j & 0x80) == 0x00) {\r\ngoto phase_ins1;\r\n}\r\nwhile ((atp_readb_io(dev, c, 0x17) & 0x80) == 0x00);\r\nj = atp_readb_io(dev, c, 0x17);\r\nif (j == 0x85) {\r\ngoto tar_dcons;\r\n}\r\nj &= 0x0f;\r\nif (j == 0x0f) {\r\ngoto phase_ins;\r\n}\r\nif (j == 0x0a) {\r\ngoto phase_cmds;\r\n}\r\nif (j == 0x0e) {\r\ngoto phase_outs;\r\n}\r\ncontinue;\r\nphase_cmds:\r\natp_writeb_io(dev, c, 0x10, 0x30);\r\ntar_dcons:\r\natp_writeb_io(dev, c, 0x14, 0x00);\r\natp_writeb_io(dev, c, 0x18, 0x08);\r\nwhile ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)\r\ncpu_relax();\r\nj = atp_readb_io(dev, c, 0x17);\r\nif (j != 0x16) {\r\ncontinue;\r\n}\r\nif (mbuf[0] != 0x01) {\r\ncontinue;\r\n}\r\nif (mbuf[1] != 0x03) {\r\ncontinue;\r\n}\r\nif (mbuf[4] == 0x00) {\r\ncontinue;\r\n}\r\nif (mbuf[3] > 0x64) {\r\ncontinue;\r\n}\r\nif (is885(dev) || is880(dev)) {\r\nif (mbuf[4] > 0x0e) {\r\nmbuf[4] = 0x0e;\r\n}\r\n} else {\r\nif (mbuf[4] > 0x0c) {\r\nmbuf[4] = 0x0c;\r\n}\r\n}\r\ndev->id[c][i].devsp = mbuf[4];\r\nif (is885(dev) || is880(dev))\r\nif (mbuf[3] < 0x0c) {\r\nj = 0xb0;\r\ngoto set_syn_ok;\r\n}\r\nif ((mbuf[3] < 0x0d) && (rmb == 0)) {\r\nj = 0xa0;\r\ngoto set_syn_ok;\r\n}\r\nif (mbuf[3] < 0x1a) {\r\nj = 0x20;\r\ngoto set_syn_ok;\r\n}\r\nif (mbuf[3] < 0x33) {\r\nj = 0x40;\r\ngoto set_syn_ok;\r\n}\r\nif (mbuf[3] < 0x4c) {\r\nj = 0x50;\r\ngoto set_syn_ok;\r\n}\r\nj = 0x60;\r\nset_syn_ok:\r\ndev->id[c][i].devsp = (dev->id[c][i].devsp & 0x0f) | j;\r\n#ifdef ED_DBGP\r\nprintk("dev->id[%2d][%2d].devsp = %2x\n",c,i,dev->id[c][i].devsp);\r\n#endif\r\n}\r\n}
