static void emac_get_drvinfo(struct net_device *ndev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, emac_version_string, sizeof(info->driver));\r\nstrlcpy(info->version, EMAC_MODULE_VERSION, sizeof(info->version));\r\n}\r\nstatic int emac_get_coalesce(struct net_device *ndev,\r\nstruct ethtool_coalesce *coal)\r\n{\r\nstruct emac_priv *priv = netdev_priv(ndev);\r\ncoal->rx_coalesce_usecs = priv->coal_intvl;\r\nreturn 0;\r\n}\r\nstatic int emac_set_coalesce(struct net_device *ndev,\r\nstruct ethtool_coalesce *coal)\r\n{\r\nstruct emac_priv *priv = netdev_priv(ndev);\r\nu32 int_ctrl, num_interrupts = 0;\r\nu32 prescale = 0, addnl_dvdr = 1, coal_intvl = 0;\r\nif (!coal->rx_coalesce_usecs)\r\nreturn -EINVAL;\r\ncoal_intvl = coal->rx_coalesce_usecs;\r\nswitch (priv->version) {\r\ncase EMAC_VERSION_2:\r\nint_ctrl = emac_ctrl_read(EMAC_DM646X_CMINTCTRL);\r\nprescale = priv->bus_freq_mhz * 4;\r\nif (coal_intvl < EMAC_DM646X_CMINTMIN_INTVL)\r\ncoal_intvl = EMAC_DM646X_CMINTMIN_INTVL;\r\nif (coal_intvl > EMAC_DM646X_CMINTMAX_INTVL) {\r\naddnl_dvdr = EMAC_DM646X_INTPRESCALE_MASK / prescale;\r\nif (addnl_dvdr > 1) {\r\nprescale *= addnl_dvdr;\r\nif (coal_intvl > (EMAC_DM646X_CMINTMAX_INTVL\r\n* addnl_dvdr))\r\ncoal_intvl = (EMAC_DM646X_CMINTMAX_INTVL\r\n* addnl_dvdr);\r\n} else {\r\naddnl_dvdr = 1;\r\ncoal_intvl = EMAC_DM646X_CMINTMAX_INTVL;\r\n}\r\n}\r\nnum_interrupts = (1000 * addnl_dvdr) / coal_intvl;\r\nint_ctrl |= EMAC_DM646X_INTPACEEN;\r\nint_ctrl &= (~EMAC_DM646X_INTPRESCALE_MASK);\r\nint_ctrl |= (prescale & EMAC_DM646X_INTPRESCALE_MASK);\r\nemac_ctrl_write(EMAC_DM646X_CMINTCTRL, int_ctrl);\r\nemac_ctrl_write(EMAC_DM646X_CMRXINTMAX, num_interrupts);\r\nemac_ctrl_write(EMAC_DM646X_CMTXINTMAX, num_interrupts);\r\nbreak;\r\ndefault:\r\nint_ctrl = emac_ctrl_read(EMAC_CTRL_EWINTTCNT);\r\nint_ctrl &= (~EMAC_DM644X_EWINTCNT_MASK);\r\nprescale = coal_intvl * priv->bus_freq_mhz;\r\nif (prescale > EMAC_DM644X_EWINTCNT_MASK) {\r\nprescale = EMAC_DM644X_EWINTCNT_MASK;\r\ncoal_intvl = prescale / priv->bus_freq_mhz;\r\n}\r\nemac_ctrl_write(EMAC_CTRL_EWINTTCNT, (int_ctrl | prescale));\r\nbreak;\r\n}\r\nprintk(KERN_INFO"Set coalesce to %d usecs.\n", coal_intvl);\r\npriv->coal_intvl = coal_intvl;\r\nreturn 0;\r\n}\r\nstatic void emac_update_phystatus(struct emac_priv *priv)\r\n{\r\nu32 mac_control;\r\nu32 new_duplex;\r\nu32 cur_duplex;\r\nstruct net_device *ndev = priv->ndev;\r\nmac_control = emac_read(EMAC_MACCONTROL);\r\ncur_duplex = (mac_control & EMAC_MACCONTROL_FULLDUPLEXEN) ?\r\nDUPLEX_FULL : DUPLEX_HALF;\r\nif (ndev->phydev)\r\nnew_duplex = ndev->phydev->duplex;\r\nelse\r\nnew_duplex = DUPLEX_FULL;\r\nif ((priv->link) && (new_duplex != cur_duplex)) {\r\npriv->duplex = new_duplex;\r\nif (DUPLEX_FULL == priv->duplex)\r\nmac_control |= (EMAC_MACCONTROL_FULLDUPLEXEN);\r\nelse\r\nmac_control &= ~(EMAC_MACCONTROL_FULLDUPLEXEN);\r\n}\r\nif (priv->speed == SPEED_1000 && (priv->version == EMAC_VERSION_2)) {\r\nmac_control = emac_read(EMAC_MACCONTROL);\r\nmac_control |= (EMAC_DM646X_MACCONTORL_GIG |\r\nEMAC_DM646X_MACCONTORL_GIGFORCE);\r\n} else {\r\nmac_control &= ~(EMAC_DM646X_MACCONTORL_GIGFORCE |\r\nEMAC_DM646X_MACCONTORL_GIG);\r\nif (priv->rmii_en && (priv->speed == SPEED_100))\r\nmac_control |= EMAC_MACCONTROL_RMIISPEED_MASK;\r\nelse\r\nmac_control &= ~EMAC_MACCONTROL_RMIISPEED_MASK;\r\n}\r\nemac_write(EMAC_MACCONTROL, mac_control);\r\nif (priv->link) {\r\nif (!netif_carrier_ok(ndev))\r\nnetif_carrier_on(ndev);\r\nif (netif_running(ndev) && netif_queue_stopped(ndev))\r\nnetif_wake_queue(ndev);\r\n} else {\r\nif (netif_carrier_ok(ndev))\r\nnetif_carrier_off(ndev);\r\nif (!netif_queue_stopped(ndev))\r\nnetif_stop_queue(ndev);\r\n}\r\n}\r\nstatic u32 hash_get(u8 *addr)\r\n{\r\nu32 hash;\r\nu8 tmpval;\r\nint cnt;\r\nhash = 0;\r\nfor (cnt = 0; cnt < 2; cnt++) {\r\ntmpval = *addr++;\r\nhash ^= (tmpval >> 2) ^ (tmpval << 4);\r\ntmpval = *addr++;\r\nhash ^= (tmpval >> 4) ^ (tmpval << 2);\r\ntmpval = *addr++;\r\nhash ^= (tmpval >> 6) ^ (tmpval);\r\n}\r\nreturn hash & 0x3F;\r\n}\r\nstatic int emac_hash_add(struct emac_priv *priv, u8 *mac_addr)\r\n{\r\nstruct device *emac_dev = &priv->ndev->dev;\r\nu32 rc = 0;\r\nu32 hash_bit;\r\nu32 hash_value = hash_get(mac_addr);\r\nif (hash_value >= EMAC_NUM_MULTICAST_BITS) {\r\nif (netif_msg_drv(priv)) {\r\ndev_err(emac_dev, "DaVinci EMAC: emac_hash_add(): Invalid "\\r\n"Hash %08x, should not be greater than %08x",\r\nhash_value, (EMAC_NUM_MULTICAST_BITS - 1));\r\n}\r\nreturn -1;\r\n}\r\nif (priv->multicast_hash_cnt[hash_value] == 0) {\r\nrc = 1;\r\nif (hash_value < 32) {\r\nhash_bit = BIT(hash_value);\r\npriv->mac_hash1 |= hash_bit;\r\n} else {\r\nhash_bit = BIT((hash_value - 32));\r\npriv->mac_hash2 |= hash_bit;\r\n}\r\n}\r\n++priv->multicast_hash_cnt[hash_value];\r\nreturn rc;\r\n}\r\nstatic int emac_hash_del(struct emac_priv *priv, u8 *mac_addr)\r\n{\r\nu32 hash_value;\r\nu32 hash_bit;\r\nhash_value = hash_get(mac_addr);\r\nif (priv->multicast_hash_cnt[hash_value] > 0) {\r\n--priv->multicast_hash_cnt[hash_value];\r\n}\r\nif (priv->multicast_hash_cnt[hash_value] > 0)\r\nreturn 0;\r\nif (hash_value < 32) {\r\nhash_bit = BIT(hash_value);\r\npriv->mac_hash1 &= ~hash_bit;\r\n} else {\r\nhash_bit = BIT((hash_value - 32));\r\npriv->mac_hash2 &= ~hash_bit;\r\n}\r\nreturn 1;\r\n}\r\nstatic void emac_add_mcast(struct emac_priv *priv, u32 action, u8 *mac_addr)\r\n{\r\nstruct device *emac_dev = &priv->ndev->dev;\r\nint update = -1;\r\nswitch (action) {\r\ncase EMAC_MULTICAST_ADD:\r\nupdate = emac_hash_add(priv, mac_addr);\r\nbreak;\r\ncase EMAC_MULTICAST_DEL:\r\nupdate = emac_hash_del(priv, mac_addr);\r\nbreak;\r\ncase EMAC_ALL_MULTI_SET:\r\nupdate = 1;\r\npriv->mac_hash1 = EMAC_ALL_MULTI_REG_VALUE;\r\npriv->mac_hash2 = EMAC_ALL_MULTI_REG_VALUE;\r\nbreak;\r\ncase EMAC_ALL_MULTI_CLR:\r\nupdate = 1;\r\npriv->mac_hash1 = 0;\r\npriv->mac_hash2 = 0;\r\nmemset(&(priv->multicast_hash_cnt[0]), 0,\r\nsizeof(priv->multicast_hash_cnt[0]) *\r\nEMAC_NUM_MULTICAST_BITS);\r\nbreak;\r\ndefault:\r\nif (netif_msg_drv(priv))\r\ndev_err(emac_dev, "DaVinci EMAC: add_mcast"\\r\n": bad operation %d", action);\r\nbreak;\r\n}\r\nif (update > 0) {\r\nemac_write(EMAC_MACHASH1, priv->mac_hash1);\r\nemac_write(EMAC_MACHASH2, priv->mac_hash2);\r\n}\r\n}\r\nstatic void emac_dev_mcast_set(struct net_device *ndev)\r\n{\r\nu32 mbp_enable;\r\nstruct emac_priv *priv = netdev_priv(ndev);\r\nmbp_enable = emac_read(EMAC_RXMBPENABLE);\r\nif (ndev->flags & IFF_PROMISC) {\r\nmbp_enable &= (~EMAC_MBP_PROMISCCH(EMAC_DEF_PROM_CH));\r\nmbp_enable |= (EMAC_MBP_RXPROMISC);\r\n} else {\r\nmbp_enable = (mbp_enable & ~EMAC_MBP_RXPROMISC);\r\nif ((ndev->flags & IFF_ALLMULTI) ||\r\nnetdev_mc_count(ndev) > EMAC_DEF_MAX_MULTICAST_ADDRESSES) {\r\nmbp_enable = (mbp_enable | EMAC_MBP_RXMCAST);\r\nemac_add_mcast(priv, EMAC_ALL_MULTI_SET, NULL);\r\n} else if (!netdev_mc_empty(ndev)) {\r\nstruct netdev_hw_addr *ha;\r\nmbp_enable = (mbp_enable | EMAC_MBP_RXMCAST);\r\nemac_add_mcast(priv, EMAC_ALL_MULTI_CLR, NULL);\r\nnetdev_for_each_mc_addr(ha, ndev) {\r\nemac_add_mcast(priv, EMAC_MULTICAST_ADD,\r\n(u8 *) ha->addr);\r\n}\r\n} else {\r\nmbp_enable = (mbp_enable & ~EMAC_MBP_RXMCAST);\r\nemac_add_mcast(priv, EMAC_ALL_MULTI_CLR, NULL);\r\n}\r\n}\r\nemac_write(EMAC_RXMBPENABLE, mbp_enable);\r\n}\r\nstatic void emac_int_disable(struct emac_priv *priv)\r\n{\r\nif (priv->version == EMAC_VERSION_2) {\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nemac_ctrl_write(EMAC_DM646X_CMRXINTEN, 0x0);\r\nemac_ctrl_write(EMAC_DM646X_CMTXINTEN, 0x0);\r\nif (priv->int_disable)\r\npriv->int_disable();\r\nemac_write(EMAC_DM646X_MACEOIVECTOR,\r\nEMAC_DM646X_MAC_EOI_C0_RXEN);\r\nemac_write(EMAC_DM646X_MACEOIVECTOR,\r\nEMAC_DM646X_MAC_EOI_C0_TXEN);\r\nlocal_irq_restore(flags);\r\n} else {\r\nemac_ctrl_write(EMAC_CTRL_EWCTL, 0x0);\r\n}\r\n}\r\nstatic void emac_int_enable(struct emac_priv *priv)\r\n{\r\nif (priv->version == EMAC_VERSION_2) {\r\nif (priv->int_enable)\r\npriv->int_enable();\r\nemac_ctrl_write(EMAC_DM646X_CMRXINTEN, 0xff);\r\nemac_ctrl_write(EMAC_DM646X_CMTXINTEN, 0xff);\r\n} else {\r\nemac_ctrl_write(EMAC_CTRL_EWCTL, 0x1);\r\n}\r\n}\r\nstatic irqreturn_t emac_irq(int irq, void *dev_id)\r\n{\r\nstruct net_device *ndev = (struct net_device *)dev_id;\r\nstruct emac_priv *priv = netdev_priv(ndev);\r\n++priv->isr_count;\r\nif (likely(netif_running(priv->ndev))) {\r\nemac_int_disable(priv);\r\nnapi_schedule(&priv->napi);\r\n} else {\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic struct sk_buff *emac_rx_alloc(struct emac_priv *priv)\r\n{\r\nstruct sk_buff *skb = netdev_alloc_skb(priv->ndev, priv->rx_buf_size);\r\nif (WARN_ON(!skb))\r\nreturn NULL;\r\nskb_reserve(skb, NET_IP_ALIGN);\r\nreturn skb;\r\n}\r\nstatic void emac_rx_handler(void *token, int len, int status)\r\n{\r\nstruct sk_buff *skb = token;\r\nstruct net_device *ndev = skb->dev;\r\nstruct emac_priv *priv = netdev_priv(ndev);\r\nstruct device *emac_dev = &ndev->dev;\r\nint ret;\r\nif (unlikely(!netif_running(ndev))) {\r\ndev_kfree_skb_any(skb);\r\nreturn;\r\n}\r\nif (status < 0) {\r\nndev->stats.rx_errors++;\r\ngoto recycle;\r\n}\r\nskb_put(skb, len);\r\nskb->protocol = eth_type_trans(skb, ndev);\r\nnetif_receive_skb(skb);\r\nndev->stats.rx_bytes += len;\r\nndev->stats.rx_packets++;\r\nskb = emac_rx_alloc(priv);\r\nif (!skb) {\r\nif (netif_msg_rx_err(priv) && net_ratelimit())\r\ndev_err(emac_dev, "failed rx buffer alloc\n");\r\nreturn;\r\n}\r\nrecycle:\r\nret = cpdma_chan_submit(priv->rxchan, skb, skb->data,\r\nskb_tailroom(skb), 0);\r\nWARN_ON(ret == -ENOMEM);\r\nif (unlikely(ret < 0))\r\ndev_kfree_skb_any(skb);\r\n}\r\nstatic void emac_tx_handler(void *token, int len, int status)\r\n{\r\nstruct sk_buff *skb = token;\r\nstruct net_device *ndev = skb->dev;\r\nif (unlikely(netif_queue_stopped(ndev)))\r\nnetif_wake_queue(ndev);\r\nndev->stats.tx_packets++;\r\nndev->stats.tx_bytes += len;\r\ndev_kfree_skb_any(skb);\r\n}\r\nstatic int emac_dev_xmit(struct sk_buff *skb, struct net_device *ndev)\r\n{\r\nstruct device *emac_dev = &ndev->dev;\r\nint ret_code;\r\nstruct emac_priv *priv = netdev_priv(ndev);\r\nif (unlikely(!priv->link)) {\r\nif (netif_msg_tx_err(priv) && net_ratelimit())\r\ndev_err(emac_dev, "DaVinci EMAC: No link to transmit");\r\ngoto fail_tx;\r\n}\r\nret_code = skb_padto(skb, EMAC_DEF_MIN_ETHPKTSIZE);\r\nif (unlikely(ret_code < 0)) {\r\nif (netif_msg_tx_err(priv) && net_ratelimit())\r\ndev_err(emac_dev, "DaVinci EMAC: packet pad failed");\r\ngoto fail_tx;\r\n}\r\nskb_tx_timestamp(skb);\r\nret_code = cpdma_chan_submit(priv->txchan, skb, skb->data, skb->len,\r\n0);\r\nif (unlikely(ret_code != 0)) {\r\nif (netif_msg_tx_err(priv) && net_ratelimit())\r\ndev_err(emac_dev, "DaVinci EMAC: desc submit failed");\r\ngoto fail_tx;\r\n}\r\nif (unlikely(!cpdma_check_free_tx_desc(priv->txchan)))\r\nnetif_stop_queue(ndev);\r\nreturn NETDEV_TX_OK;\r\nfail_tx:\r\nndev->stats.tx_dropped++;\r\nnetif_stop_queue(ndev);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nstatic void emac_dev_tx_timeout(struct net_device *ndev)\r\n{\r\nstruct emac_priv *priv = netdev_priv(ndev);\r\nstruct device *emac_dev = &ndev->dev;\r\nif (netif_msg_tx_err(priv))\r\ndev_err(emac_dev, "DaVinci EMAC: xmit timeout, restarting TX");\r\nndev->stats.tx_errors++;\r\nemac_int_disable(priv);\r\ncpdma_chan_stop(priv->txchan);\r\ncpdma_chan_start(priv->txchan);\r\nemac_int_enable(priv);\r\n}\r\nstatic void emac_set_type0addr(struct emac_priv *priv, u32 ch, char *mac_addr)\r\n{\r\nu32 val;\r\nval = ((mac_addr[5] << 8) | (mac_addr[4]));\r\nemac_write(EMAC_MACSRCADDRLO, val);\r\nval = ((mac_addr[3] << 24) | (mac_addr[2] << 16) | \\r\n(mac_addr[1] << 8) | (mac_addr[0]));\r\nemac_write(EMAC_MACSRCADDRHI, val);\r\nval = emac_read(EMAC_RXUNICASTSET);\r\nval |= BIT(ch);\r\nemac_write(EMAC_RXUNICASTSET, val);\r\nval = emac_read(EMAC_RXUNICASTCLEAR);\r\nval &= ~BIT(ch);\r\nemac_write(EMAC_RXUNICASTCLEAR, val);\r\n}\r\nstatic void emac_set_type1addr(struct emac_priv *priv, u32 ch, char *mac_addr)\r\n{\r\nu32 val;\r\nemac_write(EMAC_MACINDEX, ch);\r\nval = ((mac_addr[5] << 8) | mac_addr[4]);\r\nemac_write(EMAC_MACADDRLO, val);\r\nval = ((mac_addr[3] << 24) | (mac_addr[2] << 16) | \\r\n(mac_addr[1] << 8) | (mac_addr[0]));\r\nemac_write(EMAC_MACADDRHI, val);\r\nemac_set_type0addr(priv, ch, mac_addr);\r\n}\r\nstatic void emac_set_type2addr(struct emac_priv *priv, u32 ch,\r\nchar *mac_addr, int index, int match)\r\n{\r\nu32 val;\r\nemac_write(EMAC_MACINDEX, index);\r\nval = ((mac_addr[3] << 24) | (mac_addr[2] << 16) | \\r\n(mac_addr[1] << 8) | (mac_addr[0]));\r\nemac_write(EMAC_MACADDRHI, val);\r\nval = ((mac_addr[5] << 8) | mac_addr[4] | ((ch & 0x7) << 16) | \\r\n(match << 19) | BIT(20));\r\nemac_write(EMAC_MACADDRLO, val);\r\nemac_set_type0addr(priv, ch, mac_addr);\r\n}\r\nstatic void emac_setmac(struct emac_priv *priv, u32 ch, char *mac_addr)\r\n{\r\nstruct device *emac_dev = &priv->ndev->dev;\r\nif (priv->rx_addr_type == 0) {\r\nemac_set_type0addr(priv, ch, mac_addr);\r\n} else if (priv->rx_addr_type == 1) {\r\nu32 cnt;\r\nfor (cnt = 0; cnt < EMAC_MAX_TXRX_CHANNELS; cnt++)\r\nemac_set_type1addr(priv, ch, mac_addr);\r\n} else if (priv->rx_addr_type == 2) {\r\nemac_set_type2addr(priv, ch, mac_addr, ch, 1);\r\nemac_set_type0addr(priv, ch, mac_addr);\r\n} else {\r\nif (netif_msg_drv(priv))\r\ndev_err(emac_dev, "DaVinci EMAC: Wrong addressing\n");\r\n}\r\n}\r\nstatic int emac_dev_setmac_addr(struct net_device *ndev, void *addr)\r\n{\r\nstruct emac_priv *priv = netdev_priv(ndev);\r\nstruct device *emac_dev = &priv->ndev->dev;\r\nstruct sockaddr *sa = addr;\r\nif (!is_valid_ether_addr(sa->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(priv->mac_addr, sa->sa_data, ndev->addr_len);\r\nmemcpy(ndev->dev_addr, sa->sa_data, ndev->addr_len);\r\nif (netif_running(ndev)) {\r\nemac_setmac(priv, EMAC_DEF_RX_CH, priv->mac_addr);\r\n}\r\nif (netif_msg_drv(priv))\r\ndev_notice(emac_dev, "DaVinci EMAC: emac_dev_setmac_addr %pM\n",\r\npriv->mac_addr);\r\nreturn 0;\r\n}\r\nstatic int emac_hw_enable(struct emac_priv *priv)\r\n{\r\nu32 val, mbp_enable, mac_control;\r\nemac_write(EMAC_SOFTRESET, 1);\r\nwhile (emac_read(EMAC_SOFTRESET))\r\ncpu_relax();\r\nemac_int_disable(priv);\r\nmac_control =\r\n(((EMAC_DEF_TXPRIO_FIXED) ? (EMAC_MACCONTROL_TXPTYPE) : 0x0) |\r\n((priv->speed == 1000) ? EMAC_MACCONTROL_GIGABITEN : 0x0) |\r\n((EMAC_DEF_TXPACING_EN) ? (EMAC_MACCONTROL_TXPACEEN) : 0x0) |\r\n((priv->duplex == DUPLEX_FULL) ? 0x1 : 0));\r\nemac_write(EMAC_MACCONTROL, mac_control);\r\nmbp_enable =\r\n(((EMAC_DEF_PASS_CRC) ? (EMAC_RXMBP_PASSCRC_MASK) : 0x0) |\r\n((EMAC_DEF_QOS_EN) ? (EMAC_RXMBP_QOSEN_MASK) : 0x0) |\r\n((EMAC_DEF_NO_BUFF_CHAIN) ? (EMAC_RXMBP_NOCHAIN_MASK) : 0x0) |\r\n((EMAC_DEF_MACCTRL_FRAME_EN) ? (EMAC_RXMBP_CMFEN_MASK) : 0x0) |\r\n((EMAC_DEF_SHORT_FRAME_EN) ? (EMAC_RXMBP_CSFEN_MASK) : 0x0) |\r\n((EMAC_DEF_ERROR_FRAME_EN) ? (EMAC_RXMBP_CEFEN_MASK) : 0x0) |\r\n((EMAC_DEF_PROM_EN) ? (EMAC_RXMBP_CAFEN_MASK) : 0x0) |\r\n((EMAC_DEF_PROM_CH & EMAC_RXMBP_CHMASK) << \\r\nEMAC_RXMBP_PROMCH_SHIFT) |\r\n((EMAC_DEF_BCAST_EN) ? (EMAC_RXMBP_BROADEN_MASK) : 0x0) |\r\n((EMAC_DEF_BCAST_CH & EMAC_RXMBP_CHMASK) << \\r\nEMAC_RXMBP_BROADCH_SHIFT) |\r\n((EMAC_DEF_MCAST_EN) ? (EMAC_RXMBP_MULTIEN_MASK) : 0x0) |\r\n((EMAC_DEF_MCAST_CH & EMAC_RXMBP_CHMASK) << \\r\nEMAC_RXMBP_MULTICH_SHIFT));\r\nemac_write(EMAC_RXMBPENABLE, mbp_enable);\r\nemac_write(EMAC_RXMAXLEN, (EMAC_DEF_MAX_FRAME_SIZE &\r\nEMAC_RX_MAX_LEN_MASK));\r\nemac_write(EMAC_RXBUFFEROFFSET, (EMAC_DEF_BUFFER_OFFSET &\r\nEMAC_RX_BUFFER_OFFSET_MASK));\r\nemac_write(EMAC_RXFILTERLOWTHRESH, 0);\r\nemac_write(EMAC_RXUNICASTCLEAR, EMAC_RX_UNICAST_CLEAR_ALL);\r\npriv->rx_addr_type = (emac_read(EMAC_MACCONFIG) >> 8) & 0xFF;\r\nemac_write(EMAC_MACINTMASKSET, EMAC_MAC_HOST_ERR_INTMASK_VAL);\r\nemac_setmac(priv, EMAC_DEF_RX_CH, priv->mac_addr);\r\nval = emac_read(EMAC_MACCONTROL);\r\nval |= (EMAC_MACCONTROL_GMIIEN);\r\nemac_write(EMAC_MACCONTROL, val);\r\nnapi_enable(&priv->napi);\r\nemac_int_enable(priv);\r\nreturn 0;\r\n}\r\nstatic int emac_poll(struct napi_struct *napi, int budget)\r\n{\r\nunsigned int mask;\r\nstruct emac_priv *priv = container_of(napi, struct emac_priv, napi);\r\nstruct net_device *ndev = priv->ndev;\r\nstruct device *emac_dev = &ndev->dev;\r\nu32 status = 0;\r\nu32 num_tx_pkts = 0, num_rx_pkts = 0;\r\nstatus = emac_read(EMAC_MACINVECTOR);\r\nmask = EMAC_DM644X_MAC_IN_VECTOR_TX_INT_VEC;\r\nif (priv->version == EMAC_VERSION_2)\r\nmask = EMAC_DM646X_MAC_IN_VECTOR_TX_INT_VEC;\r\nif (status & mask) {\r\nnum_tx_pkts = cpdma_chan_process(priv->txchan,\r\nEMAC_DEF_TX_MAX_SERVICE);\r\n}\r\nmask = EMAC_DM644X_MAC_IN_VECTOR_RX_INT_VEC;\r\nif (priv->version == EMAC_VERSION_2)\r\nmask = EMAC_DM646X_MAC_IN_VECTOR_RX_INT_VEC;\r\nif (status & mask) {\r\nnum_rx_pkts = cpdma_chan_process(priv->rxchan, budget);\r\n}\r\nmask = EMAC_DM644X_MAC_IN_VECTOR_HOST_INT;\r\nif (priv->version == EMAC_VERSION_2)\r\nmask = EMAC_DM646X_MAC_IN_VECTOR_HOST_INT;\r\nif (unlikely(status & mask)) {\r\nu32 ch, cause;\r\ndev_err(emac_dev, "DaVinci EMAC: Fatal Hardware Error\n");\r\nnetif_stop_queue(ndev);\r\nnapi_disable(&priv->napi);\r\nstatus = emac_read(EMAC_MACSTATUS);\r\ncause = ((status & EMAC_MACSTATUS_TXERRCODE_MASK) >>\r\nEMAC_MACSTATUS_TXERRCODE_SHIFT);\r\nif (cause) {\r\nch = ((status & EMAC_MACSTATUS_TXERRCH_MASK) >>\r\nEMAC_MACSTATUS_TXERRCH_SHIFT);\r\nif (net_ratelimit()) {\r\ndev_err(emac_dev, "TX Host error %s on ch=%d\n",\r\n&emac_txhost_errcodes[cause][0], ch);\r\n}\r\n}\r\ncause = ((status & EMAC_MACSTATUS_RXERRCODE_MASK) >>\r\nEMAC_MACSTATUS_RXERRCODE_SHIFT);\r\nif (cause) {\r\nch = ((status & EMAC_MACSTATUS_RXERRCH_MASK) >>\r\nEMAC_MACSTATUS_RXERRCH_SHIFT);\r\nif (netif_msg_hw(priv) && net_ratelimit())\r\ndev_err(emac_dev, "RX Host error %s on ch=%d\n",\r\n&emac_rxhost_errcodes[cause][0], ch);\r\n}\r\n} else if (num_rx_pkts < budget) {\r\nnapi_complete_done(napi, num_rx_pkts);\r\nemac_int_enable(priv);\r\n}\r\nreturn num_rx_pkts;\r\n}\r\nstatic void emac_poll_controller(struct net_device *ndev)\r\n{\r\nstruct emac_priv *priv = netdev_priv(ndev);\r\nemac_int_disable(priv);\r\nemac_irq(ndev->irq, ndev);\r\nemac_int_enable(priv);\r\n}\r\nstatic void emac_adjust_link(struct net_device *ndev)\r\n{\r\nstruct emac_priv *priv = netdev_priv(ndev);\r\nstruct phy_device *phydev = ndev->phydev;\r\nunsigned long flags;\r\nint new_state = 0;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (phydev->link) {\r\nif (phydev->duplex != priv->duplex) {\r\nnew_state = 1;\r\npriv->duplex = phydev->duplex;\r\n}\r\nif (phydev->speed != priv->speed) {\r\nnew_state = 1;\r\npriv->speed = phydev->speed;\r\n}\r\nif (!priv->link) {\r\nnew_state = 1;\r\npriv->link = 1;\r\n}\r\n} else if (priv->link) {\r\nnew_state = 1;\r\npriv->link = 0;\r\npriv->speed = 0;\r\npriv->duplex = ~0;\r\n}\r\nif (new_state) {\r\nemac_update_phystatus(priv);\r\nphy_print_status(ndev->phydev);\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic int emac_devioctl(struct net_device *ndev, struct ifreq *ifrq, int cmd)\r\n{\r\nif (!(netif_running(ndev)))\r\nreturn -EINVAL;\r\nif (ndev->phydev)\r\nreturn phy_mii_ioctl(ndev->phydev, ifrq, cmd);\r\nelse\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int match_first_device(struct device *dev, void *data)\r\n{\r\nreturn !strncmp(dev_name(dev), "davinci_mdio", 12);\r\n}\r\nstatic int emac_dev_open(struct net_device *ndev)\r\n{\r\nstruct device *emac_dev = &ndev->dev;\r\nu32 cnt;\r\nstruct resource *res;\r\nint q, m, ret;\r\nint res_num = 0, irq_num = 0;\r\nint i = 0;\r\nstruct emac_priv *priv = netdev_priv(ndev);\r\nstruct phy_device *phydev = NULL;\r\nstruct device *phy = NULL;\r\nret = pm_runtime_get_sync(&priv->pdev->dev);\r\nif (ret < 0) {\r\npm_runtime_put_noidle(&priv->pdev->dev);\r\ndev_err(&priv->pdev->dev, "%s: failed to get_sync(%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nnetif_carrier_off(ndev);\r\nfor (cnt = 0; cnt < ETH_ALEN; cnt++)\r\nndev->dev_addr[cnt] = priv->mac_addr[cnt];\r\npriv->rx_buf_size = EMAC_DEF_MAX_FRAME_SIZE + NET_IP_ALIGN;\r\npriv->mac_hash1 = 0;\r\npriv->mac_hash2 = 0;\r\nemac_write(EMAC_MACHASH1, 0);\r\nemac_write(EMAC_MACHASH2, 0);\r\nfor (i = 0; i < EMAC_DEF_RX_NUM_DESC; i++) {\r\nstruct sk_buff *skb = emac_rx_alloc(priv);\r\nif (!skb)\r\nbreak;\r\nret = cpdma_chan_submit(priv->rxchan, skb, skb->data,\r\nskb_tailroom(skb), 0);\r\nif (WARN_ON(ret < 0))\r\nbreak;\r\n}\r\nwhile ((res = platform_get_resource(priv->pdev, IORESOURCE_IRQ,\r\nres_num))) {\r\nfor (irq_num = res->start; irq_num <= res->end; irq_num++) {\r\nif (request_irq(irq_num, emac_irq, 0, ndev->name,\r\nndev)) {\r\ndev_err(emac_dev,\r\n"DaVinci EMAC: request_irq() failed\n");\r\nret = -EBUSY;\r\ngoto rollback;\r\n}\r\n}\r\nres_num++;\r\n}\r\nres_num--;\r\nirq_num--;\r\nemac_hw_enable(priv);\r\nif (priv->coal_intvl != 0) {\r\nstruct ethtool_coalesce coal;\r\ncoal.rx_coalesce_usecs = (priv->coal_intvl << 4);\r\nemac_set_coalesce(ndev, &coal);\r\n}\r\ncpdma_ctlr_start(priv->dma);\r\nif (priv->phy_node) {\r\nphydev = of_phy_connect(ndev, priv->phy_node,\r\n&emac_adjust_link, 0, 0);\r\nif (!phydev) {\r\ndev_err(emac_dev, "could not connect to phy %s\n",\r\npriv->phy_node->full_name);\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\n}\r\nif (!phydev && !priv->phy_id) {\r\nphy = bus_find_device(&mdio_bus_type, NULL, NULL,\r\nmatch_first_device);\r\nif (phy) {\r\npriv->phy_id = dev_name(phy);\r\nif (!priv->phy_id || !*priv->phy_id)\r\nput_device(phy);\r\n}\r\n}\r\nif (!phydev && priv->phy_id && *priv->phy_id) {\r\nphydev = phy_connect(ndev, priv->phy_id,\r\n&emac_adjust_link,\r\nPHY_INTERFACE_MODE_MII);\r\nput_device(phy);\r\nif (IS_ERR(phydev)) {\r\ndev_err(emac_dev, "could not connect to phy %s\n",\r\npriv->phy_id);\r\nret = PTR_ERR(phydev);\r\ngoto err;\r\n}\r\npriv->link = 0;\r\npriv->speed = 0;\r\npriv->duplex = ~0;\r\nphy_attached_info(phydev);\r\n}\r\nif (!phydev) {\r\ndev_notice(emac_dev, "no phy, defaulting to 100/full\n");\r\npriv->link = 1;\r\npriv->speed = SPEED_100;\r\npriv->duplex = DUPLEX_FULL;\r\nemac_update_phystatus(priv);\r\n}\r\nif (netif_msg_drv(priv))\r\ndev_notice(emac_dev, "DaVinci EMAC: Opened %s\n", ndev->name);\r\nif (phydev)\r\nphy_start(phydev);\r\nreturn 0;\r\nerr:\r\nemac_int_disable(priv);\r\nnapi_disable(&priv->napi);\r\nrollback:\r\nfor (q = res_num; q >= 0; q--) {\r\nres = platform_get_resource(priv->pdev, IORESOURCE_IRQ, q);\r\nif (q != res_num)\r\nirq_num = res->end;\r\nfor (m = irq_num; m >= res->start; m--)\r\nfree_irq(m, ndev);\r\n}\r\ncpdma_ctlr_stop(priv->dma);\r\npm_runtime_put(&priv->pdev->dev);\r\nreturn ret;\r\n}\r\nstatic int emac_dev_stop(struct net_device *ndev)\r\n{\r\nstruct resource *res;\r\nint i = 0;\r\nint irq_num;\r\nstruct emac_priv *priv = netdev_priv(ndev);\r\nstruct device *emac_dev = &ndev->dev;\r\nnetif_stop_queue(ndev);\r\nnapi_disable(&priv->napi);\r\nnetif_carrier_off(ndev);\r\nemac_int_disable(priv);\r\ncpdma_ctlr_stop(priv->dma);\r\nemac_write(EMAC_SOFTRESET, 1);\r\nif (ndev->phydev)\r\nphy_disconnect(ndev->phydev);\r\nwhile ((res = platform_get_resource(priv->pdev, IORESOURCE_IRQ, i))) {\r\nfor (irq_num = res->start; irq_num <= res->end; irq_num++)\r\nfree_irq(irq_num, priv->ndev);\r\ni++;\r\n}\r\nif (netif_msg_drv(priv))\r\ndev_notice(emac_dev, "DaVinci EMAC: %s stopped\n", ndev->name);\r\npm_runtime_put(&priv->pdev->dev);\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *emac_dev_getnetstats(struct net_device *ndev)\r\n{\r\nstruct emac_priv *priv = netdev_priv(ndev);\r\nu32 mac_control;\r\nu32 stats_clear_mask;\r\nint err;\r\nerr = pm_runtime_get_sync(&priv->pdev->dev);\r\nif (err < 0) {\r\npm_runtime_put_noidle(&priv->pdev->dev);\r\ndev_err(&priv->pdev->dev, "%s: failed to get_sync(%d)\n",\r\n__func__, err);\r\nreturn &ndev->stats;\r\n}\r\nmac_control = emac_read(EMAC_MACCONTROL);\r\nif (mac_control & EMAC_MACCONTROL_GMIIEN)\r\nstats_clear_mask = EMAC_STATS_CLR_MASK;\r\nelse\r\nstats_clear_mask = 0;\r\nndev->stats.multicast += emac_read(EMAC_RXMCASTFRAMES);\r\nemac_write(EMAC_RXMCASTFRAMES, stats_clear_mask);\r\nndev->stats.collisions += (emac_read(EMAC_TXCOLLISION) +\r\nemac_read(EMAC_TXSINGLECOLL) +\r\nemac_read(EMAC_TXMULTICOLL));\r\nemac_write(EMAC_TXCOLLISION, stats_clear_mask);\r\nemac_write(EMAC_TXSINGLECOLL, stats_clear_mask);\r\nemac_write(EMAC_TXMULTICOLL, stats_clear_mask);\r\nndev->stats.rx_length_errors += (emac_read(EMAC_RXOVERSIZED) +\r\nemac_read(EMAC_RXJABBER) +\r\nemac_read(EMAC_RXUNDERSIZED));\r\nemac_write(EMAC_RXOVERSIZED, stats_clear_mask);\r\nemac_write(EMAC_RXJABBER, stats_clear_mask);\r\nemac_write(EMAC_RXUNDERSIZED, stats_clear_mask);\r\nndev->stats.rx_over_errors += (emac_read(EMAC_RXSOFOVERRUNS) +\r\nemac_read(EMAC_RXMOFOVERRUNS));\r\nemac_write(EMAC_RXSOFOVERRUNS, stats_clear_mask);\r\nemac_write(EMAC_RXMOFOVERRUNS, stats_clear_mask);\r\nndev->stats.rx_fifo_errors += emac_read(EMAC_RXDMAOVERRUNS);\r\nemac_write(EMAC_RXDMAOVERRUNS, stats_clear_mask);\r\nndev->stats.tx_carrier_errors +=\r\nemac_read(EMAC_TXCARRIERSENSE);\r\nemac_write(EMAC_TXCARRIERSENSE, stats_clear_mask);\r\nndev->stats.tx_fifo_errors += emac_read(EMAC_TXUNDERRUN);\r\nemac_write(EMAC_TXUNDERRUN, stats_clear_mask);\r\npm_runtime_put(&priv->pdev->dev);\r\nreturn &ndev->stats;\r\n}\r\nstatic struct emac_platform_data *\r\ndavinci_emac_of_get_pdata(struct platform_device *pdev, struct emac_priv *priv)\r\n{\r\nstruct device_node *np;\r\nconst struct of_device_id *match;\r\nconst struct emac_platform_data *auxdata;\r\nstruct emac_platform_data *pdata = NULL;\r\nconst u8 *mac_addr;\r\nif (!IS_ENABLED(CONFIG_OF) || !pdev->dev.of_node)\r\nreturn dev_get_platdata(&pdev->dev);\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn NULL;\r\nnp = pdev->dev.of_node;\r\npdata->version = EMAC_VERSION_2;\r\nif (!is_valid_ether_addr(pdata->mac_addr)) {\r\nmac_addr = of_get_mac_address(np);\r\nif (mac_addr)\r\nether_addr_copy(pdata->mac_addr, mac_addr);\r\n}\r\nof_property_read_u32(np, "ti,davinci-ctrl-reg-offset",\r\n&pdata->ctrl_reg_offset);\r\nof_property_read_u32(np, "ti,davinci-ctrl-mod-reg-offset",\r\n&pdata->ctrl_mod_reg_offset);\r\nof_property_read_u32(np, "ti,davinci-ctrl-ram-offset",\r\n&pdata->ctrl_ram_offset);\r\nof_property_read_u32(np, "ti,davinci-ctrl-ram-size",\r\n&pdata->ctrl_ram_size);\r\nof_property_read_u8(np, "ti,davinci-rmii-en", &pdata->rmii_en);\r\npdata->no_bd_ram = of_property_read_bool(np, "ti,davinci-no-bd-ram");\r\npriv->phy_node = of_parse_phandle(np, "phy-handle", 0);\r\nif (!priv->phy_node) {\r\nif (!of_phy_is_fixed_link(np))\r\npdata->phy_id = NULL;\r\nelse if (of_phy_register_fixed_link(np) >= 0)\r\npriv->phy_node = of_node_get(np);\r\n}\r\nauxdata = pdev->dev.platform_data;\r\nif (auxdata) {\r\npdata->interrupt_enable = auxdata->interrupt_enable;\r\npdata->interrupt_disable = auxdata->interrupt_disable;\r\n}\r\nmatch = of_match_device(davinci_emac_of_match, &pdev->dev);\r\nif (match && match->data) {\r\nauxdata = match->data;\r\npdata->version = auxdata->version;\r\npdata->hw_ram_addr = auxdata->hw_ram_addr;\r\n}\r\nreturn pdata;\r\n}\r\nstatic int davinci_emac_try_get_mac(struct platform_device *pdev,\r\nint instance, u8 *mac_addr)\r\n{\r\nif (!pdev->dev.of_node)\r\nreturn -EINVAL;\r\nreturn ti_cm_get_macid(&pdev->dev, instance, mac_addr);\r\n}\r\nstatic int davinci_emac_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nint rc = 0;\r\nstruct resource *res, *res_ctrl;\r\nstruct net_device *ndev;\r\nstruct emac_priv *priv;\r\nunsigned long hw_ram_addr;\r\nstruct emac_platform_data *pdata;\r\nstruct cpdma_params dma_params;\r\nstruct clk *emac_clk;\r\nunsigned long emac_bus_frequency;\r\nemac_clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(emac_clk)) {\r\ndev_err(&pdev->dev, "failed to get EMAC clock\n");\r\nreturn -EBUSY;\r\n}\r\nemac_bus_frequency = clk_get_rate(emac_clk);\r\ndevm_clk_put(&pdev->dev, emac_clk);\r\nndev = alloc_etherdev(sizeof(struct emac_priv));\r\nif (!ndev)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, ndev);\r\npriv = netdev_priv(ndev);\r\npriv->pdev = pdev;\r\npriv->ndev = ndev;\r\npriv->msg_enable = netif_msg_init(debug_level, DAVINCI_EMAC_DEBUG);\r\nspin_lock_init(&priv->lock);\r\npdata = davinci_emac_of_get_pdata(pdev, priv);\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "no platform data\n");\r\nrc = -ENODEV;\r\ngoto err_free_netdev;\r\n}\r\nmemcpy(priv->mac_addr, pdata->mac_addr, ETH_ALEN);\r\npriv->phy_id = pdata->phy_id;\r\npriv->rmii_en = pdata->rmii_en;\r\npriv->version = pdata->version;\r\npriv->int_enable = pdata->interrupt_enable;\r\npriv->int_disable = pdata->interrupt_disable;\r\npriv->coal_intvl = 0;\r\npriv->bus_freq_mhz = (u32)(emac_bus_frequency / 1000000);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npriv->emac_base_phys = res->start + pdata->ctrl_reg_offset;\r\npriv->remap_addr = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(priv->remap_addr)) {\r\nrc = PTR_ERR(priv->remap_addr);\r\ngoto no_pdata;\r\n}\r\nres_ctrl = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (res_ctrl) {\r\npriv->ctrl_base =\r\ndevm_ioremap_resource(&pdev->dev, res_ctrl);\r\nif (IS_ERR(priv->ctrl_base)) {\r\nrc = PTR_ERR(priv->ctrl_base);\r\ngoto no_pdata;\r\n}\r\n} else {\r\npriv->ctrl_base = priv->remap_addr + pdata->ctrl_mod_reg_offset;\r\n}\r\npriv->emac_base = priv->remap_addr + pdata->ctrl_reg_offset;\r\nndev->base_addr = (unsigned long)priv->remap_addr;\r\nhw_ram_addr = pdata->hw_ram_addr;\r\nif (!hw_ram_addr)\r\nhw_ram_addr = (u32 __force)res->start + pdata->ctrl_ram_offset;\r\nmemset(&dma_params, 0, sizeof(dma_params));\r\ndma_params.dev = &pdev->dev;\r\ndma_params.dmaregs = priv->emac_base;\r\ndma_params.rxthresh = priv->emac_base + 0x120;\r\ndma_params.rxfree = priv->emac_base + 0x140;\r\ndma_params.txhdp = priv->emac_base + 0x600;\r\ndma_params.rxhdp = priv->emac_base + 0x620;\r\ndma_params.txcp = priv->emac_base + 0x640;\r\ndma_params.rxcp = priv->emac_base + 0x660;\r\ndma_params.num_chan = EMAC_MAX_TXRX_CHANNELS;\r\ndma_params.min_packet_size = EMAC_DEF_MIN_ETHPKTSIZE;\r\ndma_params.desc_hw_addr = hw_ram_addr;\r\ndma_params.desc_mem_size = pdata->ctrl_ram_size;\r\ndma_params.desc_align = 16;\r\ndma_params.desc_mem_phys = pdata->no_bd_ram ? 0 :\r\n(u32 __force)res->start + pdata->ctrl_ram_offset;\r\npriv->dma = cpdma_ctlr_create(&dma_params);\r\nif (!priv->dma) {\r\ndev_err(&pdev->dev, "error initializing DMA\n");\r\nrc = -ENOMEM;\r\ngoto no_pdata;\r\n}\r\npriv->txchan = cpdma_chan_create(priv->dma, EMAC_DEF_TX_CH,\r\nemac_tx_handler, 0);\r\npriv->rxchan = cpdma_chan_create(priv->dma, EMAC_DEF_RX_CH,\r\nemac_rx_handler, 1);\r\nif (WARN_ON(!priv->txchan || !priv->rxchan)) {\r\nrc = -ENOMEM;\r\ngoto no_cpdma_chan;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "error getting irq res\n");\r\nrc = -ENOENT;\r\ngoto no_cpdma_chan;\r\n}\r\nndev->irq = res->start;\r\nrc = davinci_emac_try_get_mac(pdev, res_ctrl ? 0 : 1, priv->mac_addr);\r\nif (!rc)\r\nether_addr_copy(ndev->dev_addr, priv->mac_addr);\r\nif (!is_valid_ether_addr(priv->mac_addr)) {\r\neth_hw_addr_random(ndev);\r\nmemcpy(priv->mac_addr, ndev->dev_addr, ndev->addr_len);\r\ndev_warn(&pdev->dev, "using random MAC addr: %pM\n",\r\npriv->mac_addr);\r\n}\r\nndev->netdev_ops = &emac_netdev_ops;\r\nndev->ethtool_ops = &ethtool_ops;\r\nnetif_napi_add(ndev, &priv->napi, emac_poll, EMAC_POLL_WEIGHT);\r\npm_runtime_enable(&pdev->dev);\r\nrc = pm_runtime_get_sync(&pdev->dev);\r\nif (rc < 0) {\r\npm_runtime_put_noidle(&pdev->dev);\r\ndev_err(&pdev->dev, "%s: failed to get_sync(%d)\n",\r\n__func__, rc);\r\ngoto no_cpdma_chan;\r\n}\r\nSET_NETDEV_DEV(ndev, &pdev->dev);\r\nrc = register_netdev(ndev);\r\nif (rc) {\r\ndev_err(&pdev->dev, "error in register_netdev\n");\r\nrc = -ENODEV;\r\npm_runtime_put(&pdev->dev);\r\ngoto no_cpdma_chan;\r\n}\r\nif (netif_msg_probe(priv)) {\r\ndev_notice(&pdev->dev, "DaVinci EMAC Probe found device "\r\n"(regs: %p, irq: %d)\n",\r\n(void *)priv->emac_base_phys, ndev->irq);\r\n}\r\npm_runtime_put(&pdev->dev);\r\nreturn 0;\r\nno_cpdma_chan:\r\nif (priv->txchan)\r\ncpdma_chan_destroy(priv->txchan);\r\nif (priv->rxchan)\r\ncpdma_chan_destroy(priv->rxchan);\r\ncpdma_ctlr_destroy(priv->dma);\r\nno_pdata:\r\nif (of_phy_is_fixed_link(np))\r\nof_phy_deregister_fixed_link(np);\r\nof_node_put(priv->phy_node);\r\nerr_free_netdev:\r\nfree_netdev(ndev);\r\nreturn rc;\r\n}\r\nstatic int davinci_emac_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct emac_priv *priv = netdev_priv(ndev);\r\nstruct device_node *np = pdev->dev.of_node;\r\ndev_notice(&ndev->dev, "DaVinci EMAC: davinci_emac_remove()\n");\r\nif (priv->txchan)\r\ncpdma_chan_destroy(priv->txchan);\r\nif (priv->rxchan)\r\ncpdma_chan_destroy(priv->rxchan);\r\ncpdma_ctlr_destroy(priv->dma);\r\nunregister_netdev(ndev);\r\nof_node_put(priv->phy_node);\r\npm_runtime_disable(&pdev->dev);\r\nif (of_phy_is_fixed_link(np))\r\nof_phy_deregister_fixed_link(np);\r\nfree_netdev(ndev);\r\nreturn 0;\r\n}\r\nstatic int davinci_emac_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nif (netif_running(ndev))\r\nemac_dev_stop(ndev);\r\nreturn 0;\r\n}\r\nstatic int davinci_emac_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nif (netif_running(ndev))\r\nemac_dev_open(ndev);\r\nreturn 0;\r\n}\r\nstatic int __init davinci_emac_init(void)\r\n{\r\nreturn platform_driver_register(&davinci_emac_driver);\r\n}\r\nstatic void __exit davinci_emac_exit(void)\r\n{\r\nplatform_driver_unregister(&davinci_emac_driver);\r\n}
