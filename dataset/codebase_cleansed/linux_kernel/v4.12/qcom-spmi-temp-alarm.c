static int qpnp_tm_read(struct qpnp_tm_chip *chip, u16 addr, u8 *data)\r\n{\r\nunsigned int val;\r\nint ret;\r\nret = regmap_read(chip->map, chip->base + addr, &val);\r\nif (ret < 0)\r\nreturn ret;\r\n*data = val;\r\nreturn 0;\r\n}\r\nstatic int qpnp_tm_write(struct qpnp_tm_chip *chip, u16 addr, u8 data)\r\n{\r\nreturn regmap_write(chip->map, chip->base + addr, data);\r\n}\r\nstatic int qpnp_tm_update_temp_no_adc(struct qpnp_tm_chip *chip)\r\n{\r\nunsigned int stage;\r\nint ret;\r\nu8 reg = 0;\r\nret = qpnp_tm_read(chip, QPNP_TM_REG_STATUS, &reg);\r\nif (ret < 0)\r\nreturn ret;\r\nstage = reg & STATUS_STAGE_MASK;\r\nif (stage > chip->stage) {\r\nchip->temp = (stage - 1) * TEMP_STAGE_STEP +\r\nchip->thresh * TEMP_THRESH_STEP +\r\nTEMP_STAGE_HYSTERESIS + TEMP_THRESH_MIN;\r\n} else if (stage < chip->stage) {\r\nchip->temp = stage * TEMP_STAGE_STEP +\r\nchip->thresh * TEMP_THRESH_STEP -\r\nTEMP_STAGE_HYSTERESIS + TEMP_THRESH_MIN;\r\n}\r\nchip->stage = stage;\r\nreturn 0;\r\n}\r\nstatic int qpnp_tm_get_temp(void *data, int *temp)\r\n{\r\nstruct qpnp_tm_chip *chip = data;\r\nint ret, mili_celsius;\r\nif (!temp)\r\nreturn -EINVAL;\r\nif (IS_ERR(chip->adc)) {\r\nret = qpnp_tm_update_temp_no_adc(chip);\r\nif (ret < 0)\r\nreturn ret;\r\n} else {\r\nret = iio_read_channel_processed(chip->adc, &mili_celsius);\r\nif (ret < 0)\r\nreturn ret;\r\nchip->temp = mili_celsius;\r\n}\r\n*temp = chip->temp < 0 ? 0 : chip->temp;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t qpnp_tm_isr(int irq, void *data)\r\n{\r\nstruct qpnp_tm_chip *chip = data;\r\nthermal_zone_device_update(chip->tz_dev, THERMAL_EVENT_UNSPECIFIED);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int qpnp_tm_init(struct qpnp_tm_chip *chip)\r\n{\r\nint ret;\r\nu8 reg;\r\nchip->thresh = THRESH_MIN;\r\nchip->temp = DEFAULT_TEMP;\r\nret = qpnp_tm_read(chip, QPNP_TM_REG_STATUS, &reg);\r\nif (ret < 0)\r\nreturn ret;\r\nchip->stage = reg & STATUS_STAGE_MASK;\r\nif (chip->stage)\r\nchip->temp = chip->thresh * TEMP_THRESH_STEP +\r\n(chip->stage - 1) * TEMP_STAGE_STEP +\r\nTEMP_THRESH_MIN;\r\nreg = chip->thresh & SHUTDOWN_CTRL1_THRESHOLD_MASK;\r\nret = qpnp_tm_write(chip, QPNP_TM_REG_SHUTDOWN_CTRL1, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreg = ALARM_CTRL_FORCE_ENABLE;\r\nret = qpnp_tm_write(chip, QPNP_TM_REG_ALARM_CTRL, reg);\r\nreturn ret;\r\n}\r\nstatic int qpnp_tm_probe(struct platform_device *pdev)\r\n{\r\nstruct qpnp_tm_chip *chip;\r\nstruct device_node *node;\r\nu8 type, subtype;\r\nu32 res;\r\nint ret, irq;\r\nnode = pdev->dev.of_node;\r\nchip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(&pdev->dev, chip);\r\nchip->map = dev_get_regmap(pdev->dev.parent, NULL);\r\nif (!chip->map)\r\nreturn -ENXIO;\r\nret = of_property_read_u32(node, "reg", &res);\r\nif (ret < 0)\r\nreturn ret;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\nchip->adc = iio_channel_get(&pdev->dev, "thermal");\r\nif (PTR_ERR(chip->adc) == -EPROBE_DEFER)\r\nreturn PTR_ERR(chip->adc);\r\nchip->base = res;\r\nret = qpnp_tm_read(chip, QPNP_TM_REG_TYPE, &type);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "could not read type\n");\r\ngoto fail;\r\n}\r\nret = qpnp_tm_read(chip, QPNP_TM_REG_SUBTYPE, &subtype);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "could not read subtype\n");\r\ngoto fail;\r\n}\r\nif (type != QPNP_TM_TYPE || subtype != QPNP_TM_SUBTYPE) {\r\ndev_err(&pdev->dev, "invalid type 0x%02x or subtype 0x%02x\n",\r\ntype, subtype);\r\nret = -ENODEV;\r\ngoto fail;\r\n}\r\nret = qpnp_tm_init(chip);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "init failed\n");\r\ngoto fail;\r\n}\r\nret = devm_request_threaded_irq(&pdev->dev, irq, NULL, qpnp_tm_isr,\r\nIRQF_ONESHOT, node->name, chip);\r\nif (ret < 0)\r\ngoto fail;\r\nchip->tz_dev = devm_thermal_zone_of_sensor_register(&pdev->dev, 0, chip,\r\n&qpnp_tm_sensor_ops);\r\nif (IS_ERR(chip->tz_dev)) {\r\ndev_err(&pdev->dev, "failed to register sensor\n");\r\nret = PTR_ERR(chip->tz_dev);\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\nif (!IS_ERR(chip->adc))\r\niio_channel_release(chip->adc);\r\nreturn ret;\r\n}\r\nstatic int qpnp_tm_remove(struct platform_device *pdev)\r\n{\r\nstruct qpnp_tm_chip *chip = dev_get_drvdata(&pdev->dev);\r\nif (!IS_ERR(chip->adc))\r\niio_channel_release(chip->adc);\r\nreturn 0;\r\n}
