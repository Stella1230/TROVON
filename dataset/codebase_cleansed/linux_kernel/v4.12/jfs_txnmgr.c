static inline void TXN_SLEEP_DROP_LOCK(wait_queue_head_t * event)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nadd_wait_queue(event, &wait);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nTXN_UNLOCK();\r\nio_schedule();\r\nremove_wait_queue(event, &wait);\r\n}\r\nstatic lid_t txLockAlloc(void)\r\n{\r\nlid_t lid;\r\nINCREMENT(TxStat.txLockAlloc);\r\nif (!TxAnchor.freelock) {\r\nINCREMENT(TxStat.txLockAlloc_freelock);\r\n}\r\nwhile (!(lid = TxAnchor.freelock))\r\nTXN_SLEEP(&TxAnchor.freelockwait);\r\nTxAnchor.freelock = TxLock[lid].next;\r\nHIGHWATERMARK(stattx.maxlid, lid);\r\nif ((++TxAnchor.tlocksInUse > TxLockHWM) && (jfs_tlocks_low == 0)) {\r\njfs_info("txLockAlloc tlocks low");\r\njfs_tlocks_low = 1;\r\nwake_up_process(jfsSyncThread);\r\n}\r\nreturn lid;\r\n}\r\nstatic void txLockFree(lid_t lid)\r\n{\r\nTxLock[lid].tid = 0;\r\nTxLock[lid].next = TxAnchor.freelock;\r\nTxAnchor.freelock = lid;\r\nTxAnchor.tlocksInUse--;\r\nif (jfs_tlocks_low && (TxAnchor.tlocksInUse < TxLockLWM)) {\r\njfs_info("txLockFree jfs_tlocks_low no more");\r\njfs_tlocks_low = 0;\r\nTXN_WAKEUP(&TxAnchor.lowlockwait);\r\n}\r\nTXN_WAKEUP(&TxAnchor.freelockwait);\r\n}\r\nint txInit(void)\r\n{\r\nint k, size;\r\nstruct sysinfo si;\r\nif (nTxLock == -1) {\r\nif (nTxBlock == -1) {\r\nsi_meminfo(&si);\r\nif (si.totalram > (256 * 1024))\r\nnTxLock = 64 * 1024;\r\nelse\r\nnTxLock = si.totalram >> 2;\r\n} else if (nTxBlock > (8 * 1024))\r\nnTxLock = 64 * 1024;\r\nelse\r\nnTxLock = nTxBlock << 3;\r\n}\r\nif (nTxBlock == -1)\r\nnTxBlock = nTxLock >> 3;\r\nif (nTxBlock < 16)\r\nnTxBlock = 16;\r\nif (nTxBlock > 65536)\r\nnTxBlock = 65536;\r\nif (nTxLock < 256)\r\nnTxLock = 256;\r\nif (nTxLock > 65536)\r\nnTxLock = 65536;\r\nprintk(KERN_INFO "JFS: nTxBlock = %d, nTxLock = %d\n",\r\nnTxBlock, nTxLock);\r\nTxLockLWM = (nTxLock * 4) / 10;\r\nTxLockHWM = (nTxLock * 7) / 10;\r\nTxLockVHWM = (nTxLock * 8) / 10;\r\nsize = sizeof(struct tblock) * nTxBlock;\r\nTxBlock = vmalloc(size);\r\nif (TxBlock == NULL)\r\nreturn -ENOMEM;\r\nfor (k = 1; k < nTxBlock - 1; k++) {\r\nTxBlock[k].next = k + 1;\r\ninit_waitqueue_head(&TxBlock[k].gcwait);\r\ninit_waitqueue_head(&TxBlock[k].waitor);\r\n}\r\nTxBlock[k].next = 0;\r\ninit_waitqueue_head(&TxBlock[k].gcwait);\r\ninit_waitqueue_head(&TxBlock[k].waitor);\r\nTxAnchor.freetid = 1;\r\ninit_waitqueue_head(&TxAnchor.freewait);\r\nstattx.maxtid = 1;\r\nsize = sizeof(struct tlock) * nTxLock;\r\nTxLock = vmalloc(size);\r\nif (TxLock == NULL) {\r\nvfree(TxBlock);\r\nreturn -ENOMEM;\r\n}\r\nfor (k = 1; k < nTxLock - 1; k++)\r\nTxLock[k].next = k + 1;\r\nTxLock[k].next = 0;\r\ninit_waitqueue_head(&TxAnchor.freelockwait);\r\ninit_waitqueue_head(&TxAnchor.lowlockwait);\r\nTxAnchor.freelock = 1;\r\nTxAnchor.tlocksInUse = 0;\r\nINIT_LIST_HEAD(&TxAnchor.anon_list);\r\nINIT_LIST_HEAD(&TxAnchor.anon_list2);\r\nLAZY_LOCK_INIT();\r\nINIT_LIST_HEAD(&TxAnchor.unlock_queue);\r\nstattx.maxlid = 1;\r\nreturn 0;\r\n}\r\nvoid txExit(void)\r\n{\r\nvfree(TxLock);\r\nTxLock = NULL;\r\nvfree(TxBlock);\r\nTxBlock = NULL;\r\n}\r\ntid_t txBegin(struct super_block *sb, int flag)\r\n{\r\ntid_t t;\r\nstruct tblock *tblk;\r\nstruct jfs_log *log;\r\njfs_info("txBegin: flag = 0x%x", flag);\r\nlog = JFS_SBI(sb)->log;\r\nTXN_LOCK();\r\nINCREMENT(TxStat.txBegin);\r\nretry:\r\nif (!(flag & COMMIT_FORCE)) {\r\nif (test_bit(log_SYNCBARRIER, &log->flag) ||\r\ntest_bit(log_QUIESCE, &log->flag)) {\r\nINCREMENT(TxStat.txBegin_barrier);\r\nTXN_SLEEP(&log->syncwait);\r\ngoto retry;\r\n}\r\n}\r\nif (flag == 0) {\r\nif (TxAnchor.tlocksInUse > TxLockVHWM) {\r\nINCREMENT(TxStat.txBegin_lockslow);\r\nTXN_SLEEP(&TxAnchor.lowlockwait);\r\ngoto retry;\r\n}\r\n}\r\nif ((t = TxAnchor.freetid) == 0) {\r\njfs_info("txBegin: waiting for free tid");\r\nINCREMENT(TxStat.txBegin_freetid);\r\nTXN_SLEEP(&TxAnchor.freewait);\r\ngoto retry;\r\n}\r\ntblk = tid_to_tblock(t);\r\nif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\r\njfs_info("txBegin: waiting for free tid");\r\nINCREMENT(TxStat.txBegin_freetid);\r\nTXN_SLEEP(&TxAnchor.freewait);\r\ngoto retry;\r\n}\r\nTxAnchor.freetid = tblk->next;\r\ntblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\r\ntblk->sb = sb;\r\n++log->logtid;\r\ntblk->logtid = log->logtid;\r\n++log->active;\r\nHIGHWATERMARK(stattx.maxtid, t);\r\nINCREMENT(stattx.ntid);\r\nTXN_UNLOCK();\r\njfs_info("txBegin: returning tid = %d", t);\r\nreturn t;\r\n}\r\nvoid txBeginAnon(struct super_block *sb)\r\n{\r\nstruct jfs_log *log;\r\nlog = JFS_SBI(sb)->log;\r\nTXN_LOCK();\r\nINCREMENT(TxStat.txBeginAnon);\r\nretry:\r\nif (test_bit(log_SYNCBARRIER, &log->flag) ||\r\ntest_bit(log_QUIESCE, &log->flag)) {\r\nINCREMENT(TxStat.txBeginAnon_barrier);\r\nTXN_SLEEP(&log->syncwait);\r\ngoto retry;\r\n}\r\nif (TxAnchor.tlocksInUse > TxLockVHWM) {\r\nINCREMENT(TxStat.txBeginAnon_lockslow);\r\nTXN_SLEEP(&TxAnchor.lowlockwait);\r\ngoto retry;\r\n}\r\nTXN_UNLOCK();\r\n}\r\nvoid txEnd(tid_t tid)\r\n{\r\nstruct tblock *tblk = tid_to_tblock(tid);\r\nstruct jfs_log *log;\r\njfs_info("txEnd: tid = %d", tid);\r\nTXN_LOCK();\r\nTXN_WAKEUP(&tblk->waitor);\r\nlog = JFS_SBI(tblk->sb)->log;\r\nif (tblk->flag & tblkGC_LAZY) {\r\njfs_info("txEnd called w/lazy tid: %d, tblk = 0x%p", tid, tblk);\r\nTXN_UNLOCK();\r\nspin_lock_irq(&log->gclock);\r\ntblk->flag |= tblkGC_UNLOCKED;\r\nspin_unlock_irq(&log->gclock);\r\nreturn;\r\n}\r\njfs_info("txEnd: tid: %d, tblk = 0x%p", tid, tblk);\r\nassert(tblk->next == 0);\r\ntblk->next = TxAnchor.freetid;\r\nTxAnchor.freetid = tid;\r\nif (--log->active == 0) {\r\nclear_bit(log_FLUSH, &log->flag);\r\nif (test_bit(log_SYNCBARRIER, &log->flag)) {\r\nTXN_UNLOCK();\r\njfs_syncpt(log, 1);\r\njfs_info("log barrier off: 0x%x", log->lsn);\r\nclear_bit(log_SYNCBARRIER, &log->flag);\r\nTXN_WAKEUP(&log->syncwait);\r\ngoto wakeup;\r\n}\r\n}\r\nTXN_UNLOCK();\r\nwakeup:\r\nTXN_WAKEUP(&TxAnchor.freewait);\r\n}\r\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\r\nint type)\r\n{\r\nstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\r\nint dir_xtree = 0;\r\nlid_t lid;\r\ntid_t xtid;\r\nstruct tlock *tlck;\r\nstruct xtlock *xtlck;\r\nstruct linelock *linelock;\r\nxtpage_t *p;\r\nstruct tblock *tblk;\r\nTXN_LOCK();\r\nif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\r\n!(mp->xflag & COMMIT_PAGE)) {\r\ndir_xtree = 1;\r\nlid = jfs_ip->xtlid;\r\n} else\r\nlid = mp->lid;\r\nif (lid == 0)\r\ngoto allocateLock;\r\njfs_info("txLock: tid:%d ip:0x%p mp:0x%p lid:%d", tid, ip, mp, lid);\r\ntlck = lid_to_tlock(lid);\r\nif ((xtid = tlck->tid) == tid) {\r\nTXN_UNLOCK();\r\ngoto grantLock;\r\n}\r\nif (xtid == 0) {\r\ntlck->tid = tid;\r\nTXN_UNLOCK();\r\ntblk = tid_to_tblock(tid);\r\nif (jfs_ip->atlhead == lid) {\r\nif (jfs_ip->atltail == lid) {\r\nTXN_LOCK();\r\nlist_del_init(&jfs_ip->anon_inode_list);\r\nTXN_UNLOCK();\r\n}\r\njfs_ip->atlhead = tlck->next;\r\n} else {\r\nlid_t last;\r\nfor (last = jfs_ip->atlhead;\r\nlid_to_tlock(last)->next != lid;\r\nlast = lid_to_tlock(last)->next) {\r\nassert(last);\r\n}\r\nlid_to_tlock(last)->next = tlck->next;\r\nif (jfs_ip->atltail == lid)\r\njfs_ip->atltail = last;\r\n}\r\nif (tblk->next)\r\nlid_to_tlock(tblk->last)->next = lid;\r\nelse\r\ntblk->next = lid;\r\ntlck->next = 0;\r\ntblk->last = lid;\r\ngoto grantLock;\r\n}\r\ngoto waitLock;\r\nallocateLock:\r\nlid = txLockAlloc();\r\ntlck = lid_to_tlock(lid);\r\ntlck->tid = tid;\r\nTXN_UNLOCK();\r\nif (mp->xflag & COMMIT_PAGE) {\r\ntlck->flag = tlckPAGELOCK;\r\nmetapage_nohomeok(mp);\r\njfs_info("locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p",\r\nmp, mp->nohomeok, tid, tlck);\r\nif ((tid == 0) && mp->lsn)\r\nset_cflag(COMMIT_Synclist, ip);\r\n}\r\nelse\r\ntlck->flag = tlckINODELOCK;\r\nif (S_ISDIR(ip->i_mode))\r\ntlck->flag |= tlckDIRECTORY;\r\ntlck->type = 0;\r\ntlck->ip = ip;\r\ntlck->mp = mp;\r\nif (dir_xtree)\r\njfs_ip->xtlid = lid;\r\nelse\r\nmp->lid = lid;\r\nif (tid) {\r\ntblk = tid_to_tblock(tid);\r\nif (tblk->next)\r\nlid_to_tlock(tblk->last)->next = lid;\r\nelse\r\ntblk->next = lid;\r\ntlck->next = 0;\r\ntblk->last = lid;\r\n}\r\nelse {\r\ntlck->next = jfs_ip->atlhead;\r\njfs_ip->atlhead = lid;\r\nif (tlck->next == 0) {\r\njfs_ip->atltail = lid;\r\nTXN_LOCK();\r\nlist_add_tail(&jfs_ip->anon_inode_list,\r\n&TxAnchor.anon_list);\r\nTXN_UNLOCK();\r\n}\r\n}\r\nlinelock = (struct linelock *) & tlck->lock;\r\nlinelock->next = 0;\r\nlinelock->flag = tlckLINELOCK;\r\nlinelock->maxcnt = TLOCKSHORT;\r\nlinelock->index = 0;\r\nswitch (type & tlckTYPE) {\r\ncase tlckDTREE:\r\nlinelock->l2linesize = L2DTSLOTSIZE;\r\nbreak;\r\ncase tlckXTREE:\r\nlinelock->l2linesize = L2XTSLOTSIZE;\r\nxtlck = (struct xtlock *) linelock;\r\nxtlck->header.offset = 0;\r\nxtlck->header.length = 2;\r\nif (type & tlckNEW) {\r\nxtlck->lwm.offset = XTENTRYSTART;\r\n} else {\r\nif (mp->xflag & COMMIT_PAGE)\r\np = (xtpage_t *) mp->data;\r\nelse\r\np = &jfs_ip->i_xtroot;\r\nxtlck->lwm.offset =\r\nle16_to_cpu(p->header.nextindex);\r\n}\r\nxtlck->lwm.length = 0;\r\nxtlck->twm.offset = 0;\r\nxtlck->hwm.offset = 0;\r\nxtlck->index = 2;\r\nbreak;\r\ncase tlckINODE:\r\nlinelock->l2linesize = L2INODESLOTSIZE;\r\nbreak;\r\ncase tlckDATA:\r\nlinelock->l2linesize = L2DATASLOTSIZE;\r\nbreak;\r\ndefault:\r\njfs_err("UFO tlock:0x%p", tlck);\r\n}\r\ngrantLock:\r\ntlck->type |= type;\r\nreturn tlck;\r\nwaitLock:\r\nif (jfs_ip->fileset != AGGREGATE_I) {\r\nprintk(KERN_ERR "txLock: trying to lock locked page!");\r\nprint_hex_dump(KERN_ERR, "ip: ", DUMP_PREFIX_ADDRESS, 16, 4,\r\nip, sizeof(*ip), 0);\r\nprint_hex_dump(KERN_ERR, "mp: ", DUMP_PREFIX_ADDRESS, 16, 4,\r\nmp, sizeof(*mp), 0);\r\nprint_hex_dump(KERN_ERR, "Locker's tblock: ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\r\nsizeof(struct tblock), 0);\r\nprint_hex_dump(KERN_ERR, "Tlock: ", DUMP_PREFIX_ADDRESS, 16, 4,\r\ntlck, sizeof(*tlck), 0);\r\nBUG();\r\n}\r\nINCREMENT(stattx.waitlock);\r\nTXN_UNLOCK();\r\nrelease_metapage(mp);\r\nTXN_LOCK();\r\nxtid = tlck->tid;\r\njfs_info("txLock: in waitLock, tid = %d, xtid = %d, lid = %d",\r\ntid, xtid, lid);\r\nif (xtid && (tlck->mp == mp) && (mp->lid == lid))\r\nTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\r\nelse\r\nTXN_UNLOCK();\r\njfs_info("txLock: awakened tid = %d, lid = %d", tid, lid);\r\nreturn NULL;\r\n}\r\nstatic void txRelease(struct tblock * tblk)\r\n{\r\nstruct metapage *mp;\r\nlid_t lid;\r\nstruct tlock *tlck;\r\nTXN_LOCK();\r\nfor (lid = tblk->next; lid; lid = tlck->next) {\r\ntlck = lid_to_tlock(lid);\r\nif ((mp = tlck->mp) != NULL &&\r\n(tlck->type & tlckBTROOT) == 0) {\r\nassert(mp->xflag & COMMIT_PAGE);\r\nmp->lid = 0;\r\n}\r\n}\r\nTXN_WAKEUP(&tblk->waitor);\r\nTXN_UNLOCK();\r\n}\r\nstatic void txUnlock(struct tblock * tblk)\r\n{\r\nstruct tlock *tlck;\r\nstruct linelock *linelock;\r\nlid_t lid, next, llid, k;\r\nstruct metapage *mp;\r\nstruct jfs_log *log;\r\nint difft, diffp;\r\nunsigned long flags;\r\njfs_info("txUnlock: tblk = 0x%p", tblk);\r\nlog = JFS_SBI(tblk->sb)->log;\r\nfor (lid = tblk->next; lid; lid = next) {\r\ntlck = lid_to_tlock(lid);\r\nnext = tlck->next;\r\njfs_info("unlocking lid = %d, tlck = 0x%p", lid, tlck);\r\nif ((mp = tlck->mp) != NULL &&\r\n(tlck->type & tlckBTROOT) == 0) {\r\nassert(mp->xflag & COMMIT_PAGE);\r\nhold_metapage(mp);\r\nassert(mp->nohomeok > 0);\r\n_metapage_homeok(mp);\r\nLOGSYNC_LOCK(log, flags);\r\nif (mp->clsn) {\r\nlogdiff(difft, tblk->clsn, log);\r\nlogdiff(diffp, mp->clsn, log);\r\nif (difft > diffp)\r\nmp->clsn = tblk->clsn;\r\n} else\r\nmp->clsn = tblk->clsn;\r\nLOGSYNC_UNLOCK(log, flags);\r\nassert(!(tlck->flag & tlckFREEPAGE));\r\nput_metapage(mp);\r\n}\r\nTXN_LOCK();\r\nllid = ((struct linelock *) & tlck->lock)->next;\r\nwhile (llid) {\r\nlinelock = (struct linelock *) lid_to_tlock(llid);\r\nk = linelock->next;\r\ntxLockFree(llid);\r\nllid = k;\r\n}\r\ntxLockFree(lid);\r\nTXN_UNLOCK();\r\n}\r\ntblk->next = tblk->last = 0;\r\nif (tblk->lsn) {\r\nLOGSYNC_LOCK(log, flags);\r\nlog->count--;\r\nlist_del(&tblk->synclist);\r\nLOGSYNC_UNLOCK(log, flags);\r\n}\r\n}\r\nstruct tlock *txMaplock(tid_t tid, struct inode *ip, int type)\r\n{\r\nstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\r\nlid_t lid;\r\nstruct tblock *tblk;\r\nstruct tlock *tlck;\r\nstruct maplock *maplock;\r\nTXN_LOCK();\r\nlid = txLockAlloc();\r\ntlck = lid_to_tlock(lid);\r\ntlck->tid = tid;\r\ntlck->flag = tlckINODELOCK;\r\nif (S_ISDIR(ip->i_mode))\r\ntlck->flag |= tlckDIRECTORY;\r\ntlck->ip = ip;\r\ntlck->mp = NULL;\r\ntlck->type = type;\r\nif (tid) {\r\ntblk = tid_to_tblock(tid);\r\nif (tblk->next)\r\nlid_to_tlock(tblk->last)->next = lid;\r\nelse\r\ntblk->next = lid;\r\ntlck->next = 0;\r\ntblk->last = lid;\r\n}\r\nelse {\r\ntlck->next = jfs_ip->atlhead;\r\njfs_ip->atlhead = lid;\r\nif (tlck->next == 0) {\r\njfs_ip->atltail = lid;\r\nlist_add_tail(&jfs_ip->anon_inode_list,\r\n&TxAnchor.anon_list);\r\n}\r\n}\r\nTXN_UNLOCK();\r\nmaplock = (struct maplock *) & tlck->lock;\r\nmaplock->next = 0;\r\nmaplock->maxcnt = 0;\r\nmaplock->index = 0;\r\nreturn tlck;\r\n}\r\nstruct linelock *txLinelock(struct linelock * tlock)\r\n{\r\nlid_t lid;\r\nstruct tlock *tlck;\r\nstruct linelock *linelock;\r\nTXN_LOCK();\r\nlid = txLockAlloc();\r\ntlck = lid_to_tlock(lid);\r\nTXN_UNLOCK();\r\nlinelock = (struct linelock *) tlck;\r\nlinelock->next = 0;\r\nlinelock->flag = tlckLINELOCK;\r\nlinelock->maxcnt = TLOCKLONG;\r\nlinelock->index = 0;\r\nif (tlck->flag & tlckDIRECTORY)\r\nlinelock->flag |= tlckDIRECTORY;\r\nlinelock->next = tlock->next;\r\ntlock->next = lid;\r\nreturn linelock;\r\n}\r\nint txCommit(tid_t tid,\r\nint nip,\r\nstruct inode **iplist,\r\nint flag)\r\n{\r\nint rc = 0;\r\nstruct commit cd;\r\nstruct jfs_log *log;\r\nstruct tblock *tblk;\r\nstruct lrd *lrd;\r\nstruct inode *ip;\r\nstruct jfs_inode_info *jfs_ip;\r\nint k, n;\r\nino_t top;\r\nstruct super_block *sb;\r\njfs_info("txCommit, tid = %d, flag = %d", tid, flag);\r\nif (isReadOnly(iplist[0])) {\r\nrc = -EROFS;\r\ngoto TheEnd;\r\n}\r\nsb = cd.sb = iplist[0]->i_sb;\r\ncd.tid = tid;\r\nif (tid == 0)\r\ntid = txBegin(sb, 0);\r\ntblk = tid_to_tblock(tid);\r\nlog = JFS_SBI(sb)->log;\r\ncd.log = log;\r\nlrd = &cd.lrd;\r\nlrd->logtid = cpu_to_le32(tblk->logtid);\r\nlrd->backchain = 0;\r\ntblk->xflag |= flag;\r\nif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\r\ntblk->xflag |= COMMIT_LAZY;\r\ncd.iplist = iplist;\r\ncd.nip = nip;\r\nfor (k = 0; k < cd.nip; k++) {\r\ntop = (cd.iplist[k])->i_ino;\r\nfor (n = k + 1; n < cd.nip; n++) {\r\nip = cd.iplist[n];\r\nif (ip->i_ino > top) {\r\ntop = ip->i_ino;\r\ncd.iplist[n] = cd.iplist[k];\r\ncd.iplist[k] = ip;\r\n}\r\n}\r\nip = cd.iplist[k];\r\njfs_ip = JFS_IP(ip);\r\nclear_cflag(COMMIT_Dirty, ip);\r\nif (jfs_ip->atlhead) {\r\nlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\r\ntblk->next = jfs_ip->atlhead;\r\nif (!tblk->last)\r\ntblk->last = jfs_ip->atltail;\r\njfs_ip->atlhead = jfs_ip->atltail = 0;\r\nTXN_LOCK();\r\nlist_del_init(&jfs_ip->anon_inode_list);\r\nTXN_UNLOCK();\r\n}\r\nif (((rc = diWrite(tid, ip))))\r\ngoto out;\r\n}\r\nif ((rc = txLog(log, tblk, &cd)))\r\ngoto TheEnd;\r\nif (tblk->xflag & COMMIT_DELETE) {\r\nihold(tblk->u.ip);\r\nif (tblk->u.ip->i_state & I_SYNC)\r\ntblk->xflag &= ~COMMIT_LAZY;\r\n}\r\nASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\r\n((tblk->u.ip->i_nlink == 0) &&\r\n!test_cflag(COMMIT_Nolink, tblk->u.ip)));\r\nlrd->type = cpu_to_le16(LOG_COMMIT);\r\nlrd->length = 0;\r\nlmLog(log, tblk, lrd, NULL);\r\nlmGroupCommit(log, tblk);\r\nif (flag & COMMIT_FORCE)\r\ntxForce(tblk);\r\nif (tblk->xflag & COMMIT_FORCE)\r\ntxUpdateMap(tblk);\r\ntxRelease(tblk);\r\nif ((tblk->flag & tblkGC_LAZY) == 0)\r\ntxUnlock(tblk);\r\nfor (k = 0; k < cd.nip; k++) {\r\nip = cd.iplist[k];\r\njfs_ip = JFS_IP(ip);\r\njfs_ip->bxflag = 0;\r\njfs_ip->blid = 0;\r\n}\r\nout:\r\nif (rc != 0)\r\ntxAbort(tid, 1);\r\nTheEnd:\r\njfs_info("txCommit: tid = %d, returning %d", tid, rc);\r\nreturn rc;\r\n}\r\nstatic int txLog(struct jfs_log * log, struct tblock * tblk, struct commit * cd)\r\n{\r\nint rc = 0;\r\nstruct inode *ip;\r\nlid_t lid;\r\nstruct tlock *tlck;\r\nstruct lrd *lrd = &cd->lrd;\r\nfor (lid = tblk->next; lid; lid = tlck->next) {\r\ntlck = lid_to_tlock(lid);\r\ntlck->flag |= tlckLOG;\r\nip = tlck->ip;\r\nlrd->aggregate = cpu_to_le32(JFS_SBI(ip->i_sb)->aggregate);\r\nlrd->log.redopage.fileset = cpu_to_le32(JFS_IP(ip)->fileset);\r\nlrd->log.redopage.inode = cpu_to_le32(ip->i_ino);\r\nswitch (tlck->type & tlckTYPE) {\r\ncase tlckXTREE:\r\nxtLog(log, tblk, lrd, tlck);\r\nbreak;\r\ncase tlckDTREE:\r\ndtLog(log, tblk, lrd, tlck);\r\nbreak;\r\ncase tlckINODE:\r\ndiLog(log, tblk, lrd, tlck, cd);\r\nbreak;\r\ncase tlckMAP:\r\nmapLog(log, tblk, lrd, tlck);\r\nbreak;\r\ncase tlckDATA:\r\ndataLog(log, tblk, lrd, tlck);\r\nbreak;\r\ndefault:\r\njfs_err("UFO tlock:0x%p", tlck);\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\r\nstruct tlock * tlck, struct commit * cd)\r\n{\r\nint rc = 0;\r\nstruct metapage *mp;\r\npxd_t *pxd;\r\nstruct pxd_lock *pxdlock;\r\nmp = tlck->mp;\r\nlrd->log.redopage.type = cpu_to_le16(LOG_INODE);\r\nlrd->log.redopage.l2linesize = cpu_to_le16(L2INODESLOTSIZE);\r\npxd = &lrd->log.redopage.pxd;\r\nif (tlck->type & tlckENTRY) {\r\nlrd->type = cpu_to_le16(LOG_REDOPAGE);\r\nPXDaddress(pxd, mp->index);\r\nPXDlength(pxd,\r\nmp->logical_size >> tblk->sb->s_blocksize_bits);\r\nlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\r\ntlck->flag |= tlckWRITEPAGE;\r\n} else if (tlck->type & tlckFREE) {\r\nlrd->type = cpu_to_le16(LOG_NOREDOINOEXT);\r\nlrd->log.noredoinoext.iagnum =\r\ncpu_to_le32((u32) (size_t) cd->iplist[1]);\r\nlrd->log.noredoinoext.inoext_idx =\r\ncpu_to_le32((u32) (size_t) cd->iplist[2]);\r\npxdlock = (struct pxd_lock *) & tlck->lock;\r\n*pxd = pxdlock->pxd;\r\nlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, NULL));\r\ntlck->flag |= tlckUPDATEMAP;\r\ntlck->flag |= tlckWRITEPAGE;\r\n} else\r\njfs_err("diLog: UFO type tlck:0x%p", tlck);\r\n#ifdef _JFS_WIP\r\nelse {\r\nassert(tlck->type & tlckEA);\r\nlrd->type = cpu_to_le16(LOG_UPDATEMAP);\r\npxdlock = (struct pxd_lock *) & tlck->lock;\r\nnlock = pxdlock->index;\r\nfor (i = 0; i < nlock; i++, pxdlock++) {\r\nif (pxdlock->flag & mlckALLOCPXD)\r\nlrd->log.updatemap.type =\r\ncpu_to_le16(LOG_ALLOCPXD);\r\nelse\r\nlrd->log.updatemap.type =\r\ncpu_to_le16(LOG_FREEPXD);\r\nlrd->log.updatemap.nxd = cpu_to_le16(1);\r\nlrd->log.updatemap.pxd = pxdlock->pxd;\r\nlrd->backchain =\r\ncpu_to_le32(lmLog(log, tblk, lrd, NULL));\r\n}\r\ntlck->flag |= tlckUPDATEMAP;\r\n}\r\n#endif\r\nreturn rc;\r\n}\r\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\r\nstruct tlock * tlck)\r\n{\r\nstruct metapage *mp;\r\npxd_t *pxd;\r\nmp = tlck->mp;\r\nlrd->log.redopage.type = cpu_to_le16(LOG_DATA);\r\nlrd->log.redopage.l2linesize = cpu_to_le16(L2DATASLOTSIZE);\r\npxd = &lrd->log.redopage.pxd;\r\nlrd->type = cpu_to_le16(LOG_REDOPAGE);\r\nif (jfs_dirtable_inline(tlck->ip)) {\r\nmp->lid = 0;\r\ngrab_metapage(mp);\r\nmetapage_homeok(mp);\r\ndiscard_metapage(mp);\r\ntlck->mp = NULL;\r\nreturn 0;\r\n}\r\nPXDaddress(pxd, mp->index);\r\nPXDlength(pxd, mp->logical_size >> tblk->sb->s_blocksize_bits);\r\nlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\r\ntlck->flag |= tlckWRITEPAGE;\r\nreturn 0;\r\n}\r\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\r\nstruct tlock * tlck)\r\n{\r\nstruct metapage *mp;\r\nstruct pxd_lock *pxdlock;\r\npxd_t *pxd;\r\nmp = tlck->mp;\r\nlrd->log.redopage.type = cpu_to_le16(LOG_DTREE);\r\nlrd->log.redopage.l2linesize = cpu_to_le16(L2DTSLOTSIZE);\r\npxd = &lrd->log.redopage.pxd;\r\nif (tlck->type & tlckBTROOT)\r\nlrd->log.redopage.type |= cpu_to_le16(LOG_BTROOT);\r\nif (tlck->type & (tlckNEW | tlckEXTEND)) {\r\nlrd->type = cpu_to_le16(LOG_REDOPAGE);\r\nif (tlck->type & tlckEXTEND)\r\nlrd->log.redopage.type |= cpu_to_le16(LOG_EXTEND);\r\nelse\r\nlrd->log.redopage.type |= cpu_to_le16(LOG_NEW);\r\nPXDaddress(pxd, mp->index);\r\nPXDlength(pxd,\r\nmp->logical_size >> tblk->sb->s_blocksize_bits);\r\nlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\r\nif (tlck->type & tlckBTROOT)\r\nreturn;\r\ntlck->flag |= tlckUPDATEMAP;\r\npxdlock = (struct pxd_lock *) & tlck->lock;\r\npxdlock->flag = mlckALLOCPXD;\r\npxdlock->pxd = *pxd;\r\npxdlock->index = 1;\r\ntlck->flag |= tlckWRITEPAGE;\r\nreturn;\r\n}\r\nif (tlck->type & (tlckENTRY | tlckRELINK)) {\r\nlrd->type = cpu_to_le16(LOG_REDOPAGE);\r\nPXDaddress(pxd, mp->index);\r\nPXDlength(pxd,\r\nmp->logical_size >> tblk->sb->s_blocksize_bits);\r\nlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\r\ntlck->flag |= tlckWRITEPAGE;\r\nreturn;\r\n}\r\nif (tlck->type & (tlckFREE | tlckRELOCATE)) {\r\nlrd->type = cpu_to_le16(LOG_NOREDOPAGE);\r\npxdlock = (struct pxd_lock *) & tlck->lock;\r\n*pxd = pxdlock->pxd;\r\nlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, NULL));\r\ntlck->flag |= tlckUPDATEMAP;\r\n}\r\nreturn;\r\n}\r\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\r\nstruct tlock * tlck)\r\n{\r\nstruct inode *ip;\r\nstruct metapage *mp;\r\nxtpage_t *p;\r\nstruct xtlock *xtlck;\r\nstruct maplock *maplock;\r\nstruct xdlistlock *xadlock;\r\nstruct pxd_lock *pxdlock;\r\npxd_t *page_pxd;\r\nint next, lwm, hwm;\r\nip = tlck->ip;\r\nmp = tlck->mp;\r\nlrd->log.redopage.type = cpu_to_le16(LOG_XTREE);\r\nlrd->log.redopage.l2linesize = cpu_to_le16(L2XTSLOTSIZE);\r\npage_pxd = &lrd->log.redopage.pxd;\r\nif (tlck->type & tlckBTROOT) {\r\nlrd->log.redopage.type |= cpu_to_le16(LOG_BTROOT);\r\np = &JFS_IP(ip)->i_xtroot;\r\nif (S_ISDIR(ip->i_mode))\r\nlrd->log.redopage.type |=\r\ncpu_to_le16(LOG_DIR_XTREE);\r\n} else\r\np = (xtpage_t *) mp->data;\r\nnext = le16_to_cpu(p->header.nextindex);\r\nxtlck = (struct xtlock *) & tlck->lock;\r\nmaplock = (struct maplock *) & tlck->lock;\r\nxadlock = (struct xdlistlock *) maplock;\r\nif (tlck->type & (tlckNEW | tlckGROW | tlckRELINK)) {\r\nlrd->type = cpu_to_le16(LOG_REDOPAGE);\r\nPXDaddress(page_pxd, mp->index);\r\nPXDlength(page_pxd,\r\nmp->logical_size >> tblk->sb->s_blocksize_bits);\r\nlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\r\nlwm = xtlck->lwm.offset;\r\nif (lwm == 0)\r\nlwm = XTPAGEMAXSLOT;\r\nif (lwm == next)\r\ngoto out;\r\nif (lwm > next) {\r\njfs_err("xtLog: lwm > next");\r\ngoto out;\r\n}\r\ntlck->flag |= tlckUPDATEMAP;\r\nxadlock->flag = mlckALLOCXADLIST;\r\nxadlock->count = next - lwm;\r\nif ((xadlock->count <= 4) && (tblk->xflag & COMMIT_LAZY)) {\r\nint i;\r\npxd_t *pxd;\r\nxadlock->flag = mlckALLOCPXDLIST;\r\npxd = xadlock->xdlist = &xtlck->pxdlock;\r\nfor (i = 0; i < xadlock->count; i++) {\r\nPXDaddress(pxd, addressXAD(&p->xad[lwm + i]));\r\nPXDlength(pxd, lengthXAD(&p->xad[lwm + i]));\r\np->xad[lwm + i].flag &=\r\n~(XAD_NEW | XAD_EXTENDED);\r\npxd++;\r\n}\r\n} else {\r\nxadlock->flag = mlckALLOCXADLIST;\r\nxadlock->xdlist = &p->xad[lwm];\r\ntblk->xflag &= ~COMMIT_LAZY;\r\n}\r\njfs_info("xtLog: alloc ip:0x%p mp:0x%p tlck:0x%p lwm:%d count:%d",\r\ntlck->ip, mp, tlck, lwm, xadlock->count);\r\nmaplock->index = 1;\r\nout:\r\ntlck->flag |= tlckWRITEPAGE;\r\nreturn;\r\n}\r\nif (tlck->type & tlckFREE) {\r\nif (tblk->xflag & COMMIT_TRUNCATE) {\r\nlrd->type = cpu_to_le16(LOG_NOREDOPAGE);\r\nPXDaddress(page_pxd, mp->index);\r\nPXDlength(page_pxd,\r\nmp->logical_size >> tblk->sb->\r\ns_blocksize_bits);\r\nlrd->backchain =\r\ncpu_to_le32(lmLog(log, tblk, lrd, NULL));\r\nif (tlck->type & tlckBTROOT) {\r\nlrd->type = cpu_to_le16(LOG_REDOPAGE);\r\nlrd->backchain =\r\ncpu_to_le32(lmLog(log, tblk, lrd, tlck));\r\n}\r\n}\r\nlrd->type = cpu_to_le16(LOG_UPDATEMAP);\r\nlrd->log.updatemap.type = cpu_to_le16(LOG_FREEXADLIST);\r\nxtlck = (struct xtlock *) & tlck->lock;\r\nhwm = xtlck->hwm.offset;\r\nlrd->log.updatemap.nxd =\r\ncpu_to_le16(hwm - XTENTRYSTART + 1);\r\nxtlck->header.offset = XTENTRYSTART;\r\nxtlck->header.length = hwm - XTENTRYSTART + 1;\r\nxtlck->index = 1;\r\nlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\r\ntlck->flag |= tlckUPDATEMAP;\r\nxadlock->count = hwm - XTENTRYSTART + 1;\r\nif ((xadlock->count <= 4) && (tblk->xflag & COMMIT_LAZY)) {\r\nint i;\r\npxd_t *pxd;\r\nxadlock->flag = mlckFREEPXDLIST;\r\npxd = xadlock->xdlist = &xtlck->pxdlock;\r\nfor (i = 0; i < xadlock->count; i++) {\r\nPXDaddress(pxd,\r\naddressXAD(&p->xad[XTENTRYSTART + i]));\r\nPXDlength(pxd,\r\nlengthXAD(&p->xad[XTENTRYSTART + i]));\r\npxd++;\r\n}\r\n} else {\r\nxadlock->flag = mlckFREEXADLIST;\r\nxadlock->xdlist = &p->xad[XTENTRYSTART];\r\ntblk->xflag &= ~COMMIT_LAZY;\r\n}\r\njfs_info("xtLog: free ip:0x%p mp:0x%p count:%d lwm:2",\r\ntlck->ip, mp, xadlock->count);\r\nmaplock->index = 1;\r\nif (((tblk->xflag & COMMIT_PWMAP) || S_ISDIR(ip->i_mode))\r\n&& !(tlck->type & tlckBTROOT))\r\ntlck->flag |= tlckFREEPAGE;\r\nreturn;\r\n}\r\nif (tlck->type & tlckTRUNCATE) {\r\npxd_t pxd = pxd;\r\nint twm;\r\ntblk->xflag &= ~COMMIT_LAZY;\r\nlwm = xtlck->lwm.offset;\r\nif (lwm == 0)\r\nlwm = XTPAGEMAXSLOT;\r\nhwm = xtlck->hwm.offset;\r\ntwm = xtlck->twm.offset;\r\nlrd->type = cpu_to_le16(LOG_REDOPAGE);\r\nPXDaddress(page_pxd, mp->index);\r\nPXDlength(page_pxd,\r\nmp->logical_size >> tblk->sb->s_blocksize_bits);\r\nlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));\r\nif (twm == next - 1) {\r\npxdlock = (struct pxd_lock *) & xtlck->pxdlock;\r\nlrd->type = cpu_to_le16(LOG_UPDATEMAP);\r\nlrd->log.updatemap.type = cpu_to_le16(LOG_FREEPXD);\r\nlrd->log.updatemap.nxd = cpu_to_le16(1);\r\nlrd->log.updatemap.pxd = pxdlock->pxd;\r\npxd = pxdlock->pxd;\r\nlrd->backchain =\r\ncpu_to_le32(lmLog(log, tblk, lrd, NULL));\r\n}\r\nif (hwm >= next) {\r\nlrd->type = cpu_to_le16(LOG_UPDATEMAP);\r\nlrd->log.updatemap.type =\r\ncpu_to_le16(LOG_FREEXADLIST);\r\nxtlck = (struct xtlock *) & tlck->lock;\r\nhwm = xtlck->hwm.offset;\r\nlrd->log.updatemap.nxd =\r\ncpu_to_le16(hwm - next + 1);\r\nxtlck->header.offset = next;\r\nxtlck->header.length = hwm - next + 1;\r\nxtlck->index = 1;\r\nlrd->backchain =\r\ncpu_to_le32(lmLog(log, tblk, lrd, tlck));\r\n}\r\nmaplock->index = 0;\r\nif (lwm < next) {\r\ntlck->flag |= tlckUPDATEMAP;\r\nxadlock->flag = mlckALLOCXADLIST;\r\nxadlock->count = next - lwm;\r\nxadlock->xdlist = &p->xad[lwm];\r\njfs_info("xtLog: alloc ip:0x%p mp:0x%p count:%d lwm:%d next:%d",\r\ntlck->ip, mp, xadlock->count, lwm, next);\r\nmaplock->index++;\r\nxadlock++;\r\n}\r\nif (twm == next - 1) {\r\ntlck->flag |= tlckUPDATEMAP;\r\npxdlock = (struct pxd_lock *) xadlock;\r\npxdlock->flag = mlckFREEPXD;\r\npxdlock->count = 1;\r\npxdlock->pxd = pxd;\r\njfs_info("xtLog: truncate ip:0x%p mp:0x%p count:%d hwm:%d",\r\nip, mp, pxdlock->count, hwm);\r\nmaplock->index++;\r\nxadlock++;\r\n}\r\nif (hwm >= next) {\r\ntlck->flag |= tlckUPDATEMAP;\r\nxadlock->flag = mlckFREEXADLIST;\r\nxadlock->count = hwm - next + 1;\r\nxadlock->xdlist = &p->xad[next];\r\njfs_info("xtLog: free ip:0x%p mp:0x%p count:%d next:%d hwm:%d",\r\ntlck->ip, mp, xadlock->count, next, hwm);\r\nmaplock->index++;\r\n}\r\ntlck->flag |= tlckWRITEPAGE;\r\n}\r\nreturn;\r\n}\r\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\r\nstruct tlock * tlck)\r\n{\r\nstruct pxd_lock *pxdlock;\r\nint i, nlock;\r\npxd_t *pxd;\r\nif (tlck->type & tlckRELOCATE) {\r\nlrd->type = cpu_to_le16(LOG_NOREDOPAGE);\r\npxdlock = (struct pxd_lock *) & tlck->lock;\r\npxd = &lrd->log.redopage.pxd;\r\n*pxd = pxdlock->pxd;\r\nlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, NULL));\r\nlrd->type = cpu_to_le16(LOG_UPDATEMAP);\r\nlrd->log.updatemap.type = cpu_to_le16(LOG_FREEPXD);\r\nlrd->log.updatemap.nxd = cpu_to_le16(1);\r\nlrd->log.updatemap.pxd = pxdlock->pxd;\r\nlrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, NULL));\r\ntlck->flag |= tlckUPDATEMAP;\r\nreturn;\r\n}\r\nelse {\r\nlrd->type = cpu_to_le16(LOG_UPDATEMAP);\r\npxdlock = (struct pxd_lock *) & tlck->lock;\r\nnlock = pxdlock->index;\r\nfor (i = 0; i < nlock; i++, pxdlock++) {\r\nif (pxdlock->flag & mlckALLOCPXD)\r\nlrd->log.updatemap.type =\r\ncpu_to_le16(LOG_ALLOCPXD);\r\nelse\r\nlrd->log.updatemap.type =\r\ncpu_to_le16(LOG_FREEPXD);\r\nlrd->log.updatemap.nxd = cpu_to_le16(1);\r\nlrd->log.updatemap.pxd = pxdlock->pxd;\r\nlrd->backchain =\r\ncpu_to_le32(lmLog(log, tblk, lrd, NULL));\r\njfs_info("mapLog: xaddr:0x%lx xlen:0x%x",\r\n(ulong) addressPXD(&pxdlock->pxd),\r\nlengthPXD(&pxdlock->pxd));\r\n}\r\ntlck->flag |= tlckUPDATEMAP;\r\n}\r\n}\r\nvoid txEA(tid_t tid, struct inode *ip, dxd_t * oldea, dxd_t * newea)\r\n{\r\nstruct tlock *tlck = NULL;\r\nstruct pxd_lock *maplock = NULL, *pxdlock = NULL;\r\nif (newea) {\r\nif (newea->flag & DXD_EXTENT) {\r\ntlck = txMaplock(tid, ip, tlckMAP);\r\nmaplock = (struct pxd_lock *) & tlck->lock;\r\npxdlock = (struct pxd_lock *) maplock;\r\npxdlock->flag = mlckALLOCPXD;\r\nPXDaddress(&pxdlock->pxd, addressDXD(newea));\r\nPXDlength(&pxdlock->pxd, lengthDXD(newea));\r\npxdlock++;\r\nmaplock->index = 1;\r\n} else if (newea->flag & DXD_INLINE) {\r\ntlck = NULL;\r\nset_cflag(COMMIT_Inlineea, ip);\r\n}\r\n}\r\nif (!test_cflag(COMMIT_Nolink, ip) && oldea->flag & DXD_EXTENT) {\r\nif (tlck == NULL) {\r\ntlck = txMaplock(tid, ip, tlckMAP);\r\nmaplock = (struct pxd_lock *) & tlck->lock;\r\npxdlock = (struct pxd_lock *) maplock;\r\nmaplock->index = 0;\r\n}\r\npxdlock->flag = mlckFREEPXD;\r\nPXDaddress(&pxdlock->pxd, addressDXD(oldea));\r\nPXDlength(&pxdlock->pxd, lengthDXD(oldea));\r\nmaplock->index++;\r\n}\r\n}\r\nstatic void txForce(struct tblock * tblk)\r\n{\r\nstruct tlock *tlck;\r\nlid_t lid, next;\r\nstruct metapage *mp;\r\ntlck = lid_to_tlock(tblk->next);\r\nlid = tlck->next;\r\ntlck->next = 0;\r\nwhile (lid) {\r\ntlck = lid_to_tlock(lid);\r\nnext = tlck->next;\r\ntlck->next = tblk->next;\r\ntblk->next = lid;\r\nlid = next;\r\n}\r\nfor (lid = tblk->next; lid; lid = next) {\r\ntlck = lid_to_tlock(lid);\r\nnext = tlck->next;\r\nif ((mp = tlck->mp) != NULL &&\r\n(tlck->type & tlckBTROOT) == 0) {\r\nassert(mp->xflag & COMMIT_PAGE);\r\nif (tlck->flag & tlckWRITEPAGE) {\r\ntlck->flag &= ~tlckWRITEPAGE;\r\nforce_metapage(mp);\r\n#if 0\r\nassert(mp->nohomeok);\r\nset_bit(META_dirty, &mp->flag);\r\nset_bit(META_sync, &mp->flag);\r\n#endif\r\n}\r\n}\r\n}\r\n}\r\nstatic void txUpdateMap(struct tblock * tblk)\r\n{\r\nstruct inode *ip;\r\nstruct inode *ipimap;\r\nlid_t lid;\r\nstruct tlock *tlck;\r\nstruct maplock *maplock;\r\nstruct pxd_lock pxdlock;\r\nint maptype;\r\nint k, nlock;\r\nstruct metapage *mp = NULL;\r\nipimap = JFS_SBI(tblk->sb)->ipimap;\r\nmaptype = (tblk->xflag & COMMIT_PMAP) ? COMMIT_PMAP : COMMIT_PWMAP;\r\nfor (lid = tblk->next; lid; lid = tlck->next) {\r\ntlck = lid_to_tlock(lid);\r\nif ((tlck->flag & tlckUPDATEMAP) == 0)\r\ncontinue;\r\nif (tlck->flag & tlckFREEPAGE) {\r\nmp = tlck->mp;\r\nASSERT(mp->xflag & COMMIT_PAGE);\r\ngrab_metapage(mp);\r\n}\r\nmaplock = (struct maplock *) & tlck->lock;\r\nnlock = maplock->index;\r\nfor (k = 0; k < nlock; k++, maplock++) {\r\nif (maplock->flag & mlckALLOC) {\r\ntxAllocPMap(ipimap, maplock, tblk);\r\n}\r\nelse {\r\nif (tlck->flag & tlckDIRECTORY)\r\ntxFreeMap(ipimap, maplock,\r\ntblk, COMMIT_PWMAP);\r\nelse\r\ntxFreeMap(ipimap, maplock,\r\ntblk, maptype);\r\n}\r\n}\r\nif (tlck->flag & tlckFREEPAGE) {\r\nif (!(tblk->flag & tblkGC_LAZY)) {\r\nASSERT(mp->lid == lid);\r\ntlck->mp->lid = 0;\r\n}\r\nassert(mp->nohomeok == 1);\r\nmetapage_homeok(mp);\r\ndiscard_metapage(mp);\r\ntlck->mp = NULL;\r\n}\r\n}\r\nif (tblk->xflag & COMMIT_CREATE) {\r\ndiUpdatePMap(ipimap, tblk->ino, false, tblk);\r\npxdlock.flag = mlckALLOCPXD;\r\npxdlock.pxd = tblk->u.ixpxd;\r\npxdlock.index = 1;\r\ntxAllocPMap(ipimap, (struct maplock *) & pxdlock, tblk);\r\n} else if (tblk->xflag & COMMIT_DELETE) {\r\nip = tblk->u.ip;\r\ndiUpdatePMap(ipimap, ip->i_ino, true, tblk);\r\niput(ip);\r\n}\r\n}\r\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\r\nstruct tblock * tblk)\r\n{\r\nstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\r\nstruct xdlistlock *xadlistlock;\r\nxad_t *xad;\r\ns64 xaddr;\r\nint xlen;\r\nstruct pxd_lock *pxdlock;\r\nstruct xdlistlock *pxdlistlock;\r\npxd_t *pxd;\r\nint n;\r\nif (maplock->flag & mlckALLOCXADLIST) {\r\nxadlistlock = (struct xdlistlock *) maplock;\r\nxad = xadlistlock->xdlist;\r\nfor (n = 0; n < xadlistlock->count; n++, xad++) {\r\nif (xad->flag & (XAD_NEW | XAD_EXTENDED)) {\r\nxaddr = addressXAD(xad);\r\nxlen = lengthXAD(xad);\r\ndbUpdatePMap(ipbmap, false, xaddr,\r\n(s64) xlen, tblk);\r\nxad->flag &= ~(XAD_NEW | XAD_EXTENDED);\r\njfs_info("allocPMap: xaddr:0x%lx xlen:%d",\r\n(ulong) xaddr, xlen);\r\n}\r\n}\r\n} else if (maplock->flag & mlckALLOCPXD) {\r\npxdlock = (struct pxd_lock *) maplock;\r\nxaddr = addressPXD(&pxdlock->pxd);\r\nxlen = lengthPXD(&pxdlock->pxd);\r\ndbUpdatePMap(ipbmap, false, xaddr, (s64) xlen, tblk);\r\njfs_info("allocPMap: xaddr:0x%lx xlen:%d", (ulong) xaddr, xlen);\r\n} else {\r\npxdlistlock = (struct xdlistlock *) maplock;\r\npxd = pxdlistlock->xdlist;\r\nfor (n = 0; n < pxdlistlock->count; n++, pxd++) {\r\nxaddr = addressPXD(pxd);\r\nxlen = lengthPXD(pxd);\r\ndbUpdatePMap(ipbmap, false, xaddr, (s64) xlen,\r\ntblk);\r\njfs_info("allocPMap: xaddr:0x%lx xlen:%d",\r\n(ulong) xaddr, xlen);\r\n}\r\n}\r\n}\r\nvoid txFreeMap(struct inode *ip,\r\nstruct maplock * maplock, struct tblock * tblk, int maptype)\r\n{\r\nstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\r\nstruct xdlistlock *xadlistlock;\r\nxad_t *xad;\r\ns64 xaddr;\r\nint xlen;\r\nstruct pxd_lock *pxdlock;\r\nstruct xdlistlock *pxdlistlock;\r\npxd_t *pxd;\r\nint n;\r\njfs_info("txFreeMap: tblk:0x%p maplock:0x%p maptype:0x%x",\r\ntblk, maplock, maptype);\r\nif (maptype == COMMIT_PMAP || maptype == COMMIT_PWMAP) {\r\nif (maplock->flag & mlckFREEXADLIST) {\r\nxadlistlock = (struct xdlistlock *) maplock;\r\nxad = xadlistlock->xdlist;\r\nfor (n = 0; n < xadlistlock->count; n++, xad++) {\r\nif (!(xad->flag & XAD_NEW)) {\r\nxaddr = addressXAD(xad);\r\nxlen = lengthXAD(xad);\r\ndbUpdatePMap(ipbmap, true, xaddr,\r\n(s64) xlen, tblk);\r\njfs_info("freePMap: xaddr:0x%lx xlen:%d",\r\n(ulong) xaddr, xlen);\r\n}\r\n}\r\n} else if (maplock->flag & mlckFREEPXD) {\r\npxdlock = (struct pxd_lock *) maplock;\r\nxaddr = addressPXD(&pxdlock->pxd);\r\nxlen = lengthPXD(&pxdlock->pxd);\r\ndbUpdatePMap(ipbmap, true, xaddr, (s64) xlen,\r\ntblk);\r\njfs_info("freePMap: xaddr:0x%lx xlen:%d",\r\n(ulong) xaddr, xlen);\r\n} else {\r\npxdlistlock = (struct xdlistlock *) maplock;\r\npxd = pxdlistlock->xdlist;\r\nfor (n = 0; n < pxdlistlock->count; n++, pxd++) {\r\nxaddr = addressPXD(pxd);\r\nxlen = lengthPXD(pxd);\r\ndbUpdatePMap(ipbmap, true, xaddr,\r\n(s64) xlen, tblk);\r\njfs_info("freePMap: xaddr:0x%lx xlen:%d",\r\n(ulong) xaddr, xlen);\r\n}\r\n}\r\n}\r\nif (maptype == COMMIT_PWMAP || maptype == COMMIT_WMAP) {\r\nif (maplock->flag & mlckFREEXADLIST) {\r\nxadlistlock = (struct xdlistlock *) maplock;\r\nxad = xadlistlock->xdlist;\r\nfor (n = 0; n < xadlistlock->count; n++, xad++) {\r\nxaddr = addressXAD(xad);\r\nxlen = lengthXAD(xad);\r\ndbFree(ip, xaddr, (s64) xlen);\r\nxad->flag = 0;\r\njfs_info("freeWMap: xaddr:0x%lx xlen:%d",\r\n(ulong) xaddr, xlen);\r\n}\r\n} else if (maplock->flag & mlckFREEPXD) {\r\npxdlock = (struct pxd_lock *) maplock;\r\nxaddr = addressPXD(&pxdlock->pxd);\r\nxlen = lengthPXD(&pxdlock->pxd);\r\ndbFree(ip, xaddr, (s64) xlen);\r\njfs_info("freeWMap: xaddr:0x%lx xlen:%d",\r\n(ulong) xaddr, xlen);\r\n} else {\r\npxdlistlock = (struct xdlistlock *) maplock;\r\npxd = pxdlistlock->xdlist;\r\nfor (n = 0; n < pxdlistlock->count; n++, pxd++) {\r\nxaddr = addressPXD(pxd);\r\nxlen = lengthPXD(pxd);\r\ndbFree(ip, xaddr, (s64) xlen);\r\njfs_info("freeWMap: xaddr:0x%lx xlen:%d",\r\n(ulong) xaddr, xlen);\r\n}\r\n}\r\n}\r\n}\r\nvoid txFreelock(struct inode *ip)\r\n{\r\nstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\r\nstruct tlock *xtlck, *tlck;\r\nlid_t xlid = 0, lid;\r\nif (!jfs_ip->atlhead)\r\nreturn;\r\nTXN_LOCK();\r\nxtlck = (struct tlock *) &jfs_ip->atlhead;\r\nwhile ((lid = xtlck->next) != 0) {\r\ntlck = lid_to_tlock(lid);\r\nif (tlck->flag & tlckFREELOCK) {\r\nxtlck->next = tlck->next;\r\ntxLockFree(lid);\r\n} else {\r\nxtlck = tlck;\r\nxlid = lid;\r\n}\r\n}\r\nif (jfs_ip->atlhead)\r\njfs_ip->atltail = xlid;\r\nelse {\r\njfs_ip->atltail = 0;\r\nlist_del_init(&jfs_ip->anon_inode_list);\r\n}\r\nTXN_UNLOCK();\r\n}\r\nvoid txAbort(tid_t tid, int dirty)\r\n{\r\nlid_t lid, next;\r\nstruct metapage *mp;\r\nstruct tblock *tblk = tid_to_tblock(tid);\r\nstruct tlock *tlck;\r\nfor (lid = tblk->next; lid; lid = next) {\r\ntlck = lid_to_tlock(lid);\r\nnext = tlck->next;\r\nmp = tlck->mp;\r\nJFS_IP(tlck->ip)->xtlid = 0;\r\nif (mp) {\r\nmp->lid = 0;\r\nif (mp->xflag & COMMIT_PAGE && mp->lsn)\r\nLogSyncRelease(mp);\r\n}\r\nTXN_LOCK();\r\ntxLockFree(lid);\r\nTXN_UNLOCK();\r\n}\r\ntblk->next = tblk->last = 0;\r\nif (dirty)\r\njfs_error(tblk->sb, "\n");\r\nreturn;\r\n}\r\nstatic void txLazyCommit(struct tblock * tblk)\r\n{\r\nstruct jfs_log *log;\r\nwhile (((tblk->flag & tblkGC_READY) == 0) &&\r\n((tblk->flag & tblkGC_UNLOCKED) == 0)) {\r\njfs_info("jfs_lazycommit: tblk 0x%p not unlocked", tblk);\r\nyield();\r\n}\r\njfs_info("txLazyCommit: processing tblk 0x%p", tblk);\r\ntxUpdateMap(tblk);\r\nlog = (struct jfs_log *) JFS_SBI(tblk->sb)->log;\r\nspin_lock_irq(&log->gclock);\r\ntblk->flag |= tblkGC_COMMITTED;\r\nif (tblk->flag & tblkGC_READY)\r\nlog->gcrtc--;\r\nwake_up_all(&tblk->gcwait);\r\nif (tblk->flag & tblkGC_LAZY) {\r\nspin_unlock_irq(&log->gclock);\r\ntxUnlock(tblk);\r\ntblk->flag &= ~tblkGC_LAZY;\r\ntxEnd(tblk - TxBlock);\r\n} else\r\nspin_unlock_irq(&log->gclock);\r\njfs_info("txLazyCommit: done: tblk = 0x%p", tblk);\r\n}\r\nint jfs_lazycommit(void *arg)\r\n{\r\nint WorkDone;\r\nstruct tblock *tblk;\r\nunsigned long flags;\r\nstruct jfs_sb_info *sbi;\r\ndo {\r\nLAZY_LOCK(flags);\r\njfs_commit_thread_waking = 0;\r\nwhile (!list_empty(&TxAnchor.unlock_queue)) {\r\nWorkDone = 0;\r\nlist_for_each_entry(tblk, &TxAnchor.unlock_queue,\r\ncqueue) {\r\nsbi = JFS_SBI(tblk->sb);\r\nif (sbi->commit_state & IN_LAZYCOMMIT)\r\ncontinue;\r\nsbi->commit_state |= IN_LAZYCOMMIT;\r\nWorkDone = 1;\r\nlist_del(&tblk->cqueue);\r\nLAZY_UNLOCK(flags);\r\ntxLazyCommit(tblk);\r\nLAZY_LOCK(flags);\r\nsbi->commit_state &= ~IN_LAZYCOMMIT;\r\nbreak;\r\n}\r\nif (!WorkDone)\r\nbreak;\r\n}\r\njfs_commit_thread_waking = 0;\r\nif (freezing(current)) {\r\nLAZY_UNLOCK(flags);\r\ntry_to_freeze();\r\n} else {\r\nDECLARE_WAITQUEUE(wq, current);\r\nadd_wait_queue(&jfs_commit_thread_wait, &wq);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nLAZY_UNLOCK(flags);\r\nschedule();\r\nremove_wait_queue(&jfs_commit_thread_wait, &wq);\r\n}\r\n} while (!kthread_should_stop());\r\nif (!list_empty(&TxAnchor.unlock_queue))\r\njfs_err("jfs_lazycommit being killed w/pending transactions!");\r\nelse\r\njfs_info("jfs_lazycommit being killed");\r\nreturn 0;\r\n}\r\nvoid txLazyUnlock(struct tblock * tblk)\r\n{\r\nunsigned long flags;\r\nLAZY_LOCK(flags);\r\nlist_add_tail(&tblk->cqueue, &TxAnchor.unlock_queue);\r\nif (!(JFS_SBI(tblk->sb)->commit_state & IN_LAZYCOMMIT) &&\r\n!jfs_commit_thread_waking) {\r\njfs_commit_thread_waking = 1;\r\nwake_up(&jfs_commit_thread_wait);\r\n}\r\nLAZY_UNLOCK(flags);\r\n}\r\nstatic void LogSyncRelease(struct metapage * mp)\r\n{\r\nstruct jfs_log *log = mp->log;\r\nassert(mp->nohomeok);\r\nassert(log);\r\nmetapage_homeok(mp);\r\n}\r\nvoid txQuiesce(struct super_block *sb)\r\n{\r\nstruct inode *ip;\r\nstruct jfs_inode_info *jfs_ip;\r\nstruct jfs_log *log = JFS_SBI(sb)->log;\r\ntid_t tid;\r\nset_bit(log_QUIESCE, &log->flag);\r\nTXN_LOCK();\r\nrestart:\r\nwhile (!list_empty(&TxAnchor.anon_list)) {\r\njfs_ip = list_entry(TxAnchor.anon_list.next,\r\nstruct jfs_inode_info,\r\nanon_inode_list);\r\nip = &jfs_ip->vfs_inode;\r\nTXN_UNLOCK();\r\ntid = txBegin(ip->i_sb, COMMIT_INODE | COMMIT_FORCE);\r\nmutex_lock(&jfs_ip->commit_mutex);\r\ntxCommit(tid, 1, &ip, 0);\r\ntxEnd(tid);\r\nmutex_unlock(&jfs_ip->commit_mutex);\r\ncond_resched();\r\nTXN_LOCK();\r\n}\r\nif (!list_empty(&TxAnchor.anon_list2)) {\r\nlist_splice_init(&TxAnchor.anon_list2, &TxAnchor.anon_list);\r\ngoto restart;\r\n}\r\nTXN_UNLOCK();\r\njfs_flush_journal(log, 0);\r\n}\r\nvoid txResume(struct super_block *sb)\r\n{\r\nstruct jfs_log *log = JFS_SBI(sb)->log;\r\nclear_bit(log_QUIESCE, &log->flag);\r\nTXN_WAKEUP(&log->syncwait);\r\n}\r\nint jfs_sync(void *arg)\r\n{\r\nstruct inode *ip;\r\nstruct jfs_inode_info *jfs_ip;\r\ntid_t tid;\r\ndo {\r\nTXN_LOCK();\r\nwhile (jfs_tlocks_low && !list_empty(&TxAnchor.anon_list)) {\r\njfs_ip = list_entry(TxAnchor.anon_list.next,\r\nstruct jfs_inode_info,\r\nanon_inode_list);\r\nip = &jfs_ip->vfs_inode;\r\nif (! igrab(ip)) {\r\nlist_del_init(&jfs_ip->anon_inode_list);\r\n} else if (mutex_trylock(&jfs_ip->commit_mutex)) {\r\nTXN_UNLOCK();\r\ntid = txBegin(ip->i_sb, COMMIT_INODE);\r\ntxCommit(tid, 1, &ip, 0);\r\ntxEnd(tid);\r\nmutex_unlock(&jfs_ip->commit_mutex);\r\niput(ip);\r\ncond_resched();\r\nTXN_LOCK();\r\n} else {\r\nlist_move(&jfs_ip->anon_inode_list,\r\n&TxAnchor.anon_list2);\r\nTXN_UNLOCK();\r\niput(ip);\r\nTXN_LOCK();\r\n}\r\n}\r\nlist_splice_init(&TxAnchor.anon_list2, &TxAnchor.anon_list);\r\nif (freezing(current)) {\r\nTXN_UNLOCK();\r\ntry_to_freeze();\r\n} else {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nTXN_UNLOCK();\r\nschedule();\r\n}\r\n} while (!kthread_should_stop());\r\njfs_info("jfs_sync being killed");\r\nreturn 0;\r\n}\r\nstatic int jfs_txanchor_proc_show(struct seq_file *m, void *v)\r\n{\r\nchar *freewait;\r\nchar *freelockwait;\r\nchar *lowlockwait;\r\nfreewait =\r\nwaitqueue_active(&TxAnchor.freewait) ? "active" : "empty";\r\nfreelockwait =\r\nwaitqueue_active(&TxAnchor.freelockwait) ? "active" : "empty";\r\nlowlockwait =\r\nwaitqueue_active(&TxAnchor.lowlockwait) ? "active" : "empty";\r\nseq_printf(m,\r\n"JFS TxAnchor\n"\r\n"============\n"\r\n"freetid = %d\n"\r\n"freewait = %s\n"\r\n"freelock = %d\n"\r\n"freelockwait = %s\n"\r\n"lowlockwait = %s\n"\r\n"tlocksInUse = %d\n"\r\n"jfs_tlocks_low = %d\n"\r\n"unlock_queue is %sempty\n",\r\nTxAnchor.freetid,\r\nfreewait,\r\nTxAnchor.freelock,\r\nfreelockwait,\r\nlowlockwait,\r\nTxAnchor.tlocksInUse,\r\njfs_tlocks_low,\r\nlist_empty(&TxAnchor.unlock_queue) ? "" : "not ");\r\nreturn 0;\r\n}\r\nstatic int jfs_txanchor_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, jfs_txanchor_proc_show, NULL);\r\n}\r\nstatic int jfs_txstats_proc_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m,\r\n"JFS TxStats\n"\r\n"===========\n"\r\n"calls to txBegin = %d\n"\r\n"txBegin blocked by sync barrier = %d\n"\r\n"txBegin blocked by tlocks low = %d\n"\r\n"txBegin blocked by no free tid = %d\n"\r\n"calls to txBeginAnon = %d\n"\r\n"txBeginAnon blocked by sync barrier = %d\n"\r\n"txBeginAnon blocked by tlocks low = %d\n"\r\n"calls to txLockAlloc = %d\n"\r\n"tLockAlloc blocked by no free lock = %d\n",\r\nTxStat.txBegin,\r\nTxStat.txBegin_barrier,\r\nTxStat.txBegin_lockslow,\r\nTxStat.txBegin_freetid,\r\nTxStat.txBeginAnon,\r\nTxStat.txBeginAnon_barrier,\r\nTxStat.txBeginAnon_lockslow,\r\nTxStat.txLockAlloc,\r\nTxStat.txLockAlloc_freelock);\r\nreturn 0;\r\n}\r\nstatic int jfs_txstats_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, jfs_txstats_proc_show, NULL);\r\n}
