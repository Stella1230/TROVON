static int ath9k_hw_4k_get_eeprom_ver(struct ath_hw *ah)\r\n{\r\nu16 version = le16_to_cpu(ah->eeprom.map4k.baseEepHeader.version);\r\nreturn (version & AR5416_EEP_VER_MAJOR_MASK) >>\r\nAR5416_EEP_VER_MAJOR_SHIFT;\r\n}\r\nstatic int ath9k_hw_4k_get_eeprom_rev(struct ath_hw *ah)\r\n{\r\nu16 version = le16_to_cpu(ah->eeprom.map4k.baseEepHeader.version);\r\nreturn version & AR5416_EEP_VER_MINOR_MASK;\r\n}\r\nstatic bool __ath9k_hw_4k_fill_eeprom(struct ath_hw *ah)\r\n{\r\nu16 *eep_data = (u16 *)&ah->eeprom.map4k;\r\nint addr, eep_start_loc = 64;\r\nfor (addr = 0; addr < SIZE_EEPROM_4K; addr++) {\r\nif (!ath9k_hw_nvram_read(ah, addr + eep_start_loc, eep_data))\r\nreturn false;\r\neep_data++;\r\n}\r\nreturn true;\r\n}\r\nstatic bool __ath9k_hw_usb_4k_fill_eeprom(struct ath_hw *ah)\r\n{\r\nu16 *eep_data = (u16 *)&ah->eeprom.map4k;\r\nath9k_hw_usb_gen_fill_eeprom(ah, eep_data, 64, SIZE_EEPROM_4K);\r\nreturn true;\r\n}\r\nstatic bool ath9k_hw_4k_fill_eeprom(struct ath_hw *ah)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nif (!ath9k_hw_use_flash(ah)) {\r\nath_dbg(common, EEPROM, "Reading from EEPROM, not flash\n");\r\n}\r\nif (common->bus_ops->ath_bus_type == ATH_USB)\r\nreturn __ath9k_hw_usb_4k_fill_eeprom(ah);\r\nelse\r\nreturn __ath9k_hw_4k_fill_eeprom(ah);\r\n}\r\nstatic u32 ath9k_dump_4k_modal_eeprom(char *buf, u32 len, u32 size,\r\nstruct modal_eep_4k_header *modal_hdr)\r\n{\r\nPR_EEP("Chain0 Ant. Control", le16_to_cpu(modal_hdr->antCtrlChain[0]));\r\nPR_EEP("Ant. Common Control", le32_to_cpu(modal_hdr->antCtrlCommon));\r\nPR_EEP("Chain0 Ant. Gain", modal_hdr->antennaGainCh[0]);\r\nPR_EEP("Switch Settle", modal_hdr->switchSettling);\r\nPR_EEP("Chain0 TxRxAtten", modal_hdr->txRxAttenCh[0]);\r\nPR_EEP("Chain0 RxTxMargin", modal_hdr->rxTxMarginCh[0]);\r\nPR_EEP("ADC Desired size", modal_hdr->adcDesiredSize);\r\nPR_EEP("PGA Desired size", modal_hdr->pgaDesiredSize);\r\nPR_EEP("Chain0 xlna Gain", modal_hdr->xlnaGainCh[0]);\r\nPR_EEP("txEndToXpaOff", modal_hdr->txEndToXpaOff);\r\nPR_EEP("txEndToRxOn", modal_hdr->txEndToRxOn);\r\nPR_EEP("txFrameToXpaOn", modal_hdr->txFrameToXpaOn);\r\nPR_EEP("CCA Threshold)", modal_hdr->thresh62);\r\nPR_EEP("Chain0 NF Threshold", modal_hdr->noiseFloorThreshCh[0]);\r\nPR_EEP("xpdGain", modal_hdr->xpdGain);\r\nPR_EEP("External PD", modal_hdr->xpd);\r\nPR_EEP("Chain0 I Coefficient", modal_hdr->iqCalICh[0]);\r\nPR_EEP("Chain0 Q Coefficient", modal_hdr->iqCalQCh[0]);\r\nPR_EEP("pdGainOverlap", modal_hdr->pdGainOverlap);\r\nPR_EEP("O/D Bias Version", modal_hdr->version);\r\nPR_EEP("CCK OutputBias", modal_hdr->ob_0);\r\nPR_EEP("BPSK OutputBias", modal_hdr->ob_1);\r\nPR_EEP("QPSK OutputBias", modal_hdr->ob_2);\r\nPR_EEP("16QAM OutputBias", modal_hdr->ob_3);\r\nPR_EEP("64QAM OutputBias", modal_hdr->ob_4);\r\nPR_EEP("CCK Driver1_Bias", modal_hdr->db1_0);\r\nPR_EEP("BPSK Driver1_Bias", modal_hdr->db1_1);\r\nPR_EEP("QPSK Driver1_Bias", modal_hdr->db1_2);\r\nPR_EEP("16QAM Driver1_Bias", modal_hdr->db1_3);\r\nPR_EEP("64QAM Driver1_Bias", modal_hdr->db1_4);\r\nPR_EEP("CCK Driver2_Bias", modal_hdr->db2_0);\r\nPR_EEP("BPSK Driver2_Bias", modal_hdr->db2_1);\r\nPR_EEP("QPSK Driver2_Bias", modal_hdr->db2_2);\r\nPR_EEP("16QAM Driver2_Bias", modal_hdr->db2_3);\r\nPR_EEP("64QAM Driver2_Bias", modal_hdr->db2_4);\r\nPR_EEP("xPA Bias Level", modal_hdr->xpaBiasLvl);\r\nPR_EEP("txFrameToDataStart", modal_hdr->txFrameToDataStart);\r\nPR_EEP("txFrameToPaOn", modal_hdr->txFrameToPaOn);\r\nPR_EEP("HT40 Power Inc.", modal_hdr->ht40PowerIncForPdadc);\r\nPR_EEP("Chain0 bswAtten", modal_hdr->bswAtten[0]);\r\nPR_EEP("Chain0 bswMargin", modal_hdr->bswMargin[0]);\r\nPR_EEP("HT40 Switch Settle", modal_hdr->swSettleHt40);\r\nPR_EEP("Chain0 xatten2Db", modal_hdr->xatten2Db[0]);\r\nPR_EEP("Chain0 xatten2Margin", modal_hdr->xatten2Margin[0]);\r\nPR_EEP("Ant. Diversity ctl1", modal_hdr->antdiv_ctl1);\r\nPR_EEP("Ant. Diversity ctl2", modal_hdr->antdiv_ctl2);\r\nPR_EEP("TX Diversity", modal_hdr->tx_diversity);\r\nreturn len;\r\n}\r\nstatic u32 ath9k_hw_4k_dump_eeprom(struct ath_hw *ah, bool dump_base_hdr,\r\nu8 *buf, u32 len, u32 size)\r\n{\r\nstruct ar5416_eeprom_4k *eep = &ah->eeprom.map4k;\r\nstruct base_eep_header_4k *pBase = &eep->baseEepHeader;\r\nu32 binBuildNumber = le32_to_cpu(pBase->binBuildNumber);\r\nif (!dump_base_hdr) {\r\nlen += scnprintf(buf + len, size - len,\r\n"%20s :\n", "2GHz modal Header");\r\nlen = ath9k_dump_4k_modal_eeprom(buf, len, size,\r\n&eep->modalHeader);\r\ngoto out;\r\n}\r\nPR_EEP("Major Version", ath9k_hw_4k_get_eeprom_ver(ah));\r\nPR_EEP("Minor Version", ath9k_hw_4k_get_eeprom_rev(ah));\r\nPR_EEP("Checksum", le16_to_cpu(pBase->checksum));\r\nPR_EEP("Length", le16_to_cpu(pBase->length));\r\nPR_EEP("RegDomain1", le16_to_cpu(pBase->regDmn[0]));\r\nPR_EEP("RegDomain2", le16_to_cpu(pBase->regDmn[1]));\r\nPR_EEP("TX Mask", pBase->txMask);\r\nPR_EEP("RX Mask", pBase->rxMask);\r\nPR_EEP("Allow 5GHz", !!(pBase->opCapFlags & AR5416_OPFLAGS_11A));\r\nPR_EEP("Allow 2GHz", !!(pBase->opCapFlags & AR5416_OPFLAGS_11G));\r\nPR_EEP("Disable 2GHz HT20", !!(pBase->opCapFlags &\r\nAR5416_OPFLAGS_N_2G_HT20));\r\nPR_EEP("Disable 2GHz HT40", !!(pBase->opCapFlags &\r\nAR5416_OPFLAGS_N_2G_HT40));\r\nPR_EEP("Disable 5Ghz HT20", !!(pBase->opCapFlags &\r\nAR5416_OPFLAGS_N_5G_HT20));\r\nPR_EEP("Disable 5Ghz HT40", !!(pBase->opCapFlags &\r\nAR5416_OPFLAGS_N_5G_HT40));\r\nPR_EEP("Big Endian", !!(pBase->eepMisc & AR5416_EEPMISC_BIG_ENDIAN));\r\nPR_EEP("Cal Bin Major Ver", (binBuildNumber >> 24) & 0xFF);\r\nPR_EEP("Cal Bin Minor Ver", (binBuildNumber >> 16) & 0xFF);\r\nPR_EEP("Cal Bin Build", (binBuildNumber >> 8) & 0xFF);\r\nPR_EEP("TX Gain type", pBase->txGainType);\r\nlen += scnprintf(buf + len, size - len, "%20s : %pM\n", "MacAddress",\r\npBase->macAddr);\r\nout:\r\nif (len > size)\r\nlen = size;\r\nreturn len;\r\n}\r\nstatic u32 ath9k_hw_4k_dump_eeprom(struct ath_hw *ah, bool dump_base_hdr,\r\nu8 *buf, u32 len, u32 size)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ath9k_hw_4k_check_eeprom(struct ath_hw *ah)\r\n{\r\nstruct ar5416_eeprom_4k *eep = &ah->eeprom.map4k;\r\nu32 el;\r\nbool need_swap;\r\nint i, err;\r\nerr = ath9k_hw_nvram_swap_data(ah, &need_swap, SIZE_EEPROM_4K);\r\nif (err)\r\nreturn err;\r\nif (need_swap)\r\nel = swab16((__force u16)eep->baseEepHeader.length);\r\nelse\r\nel = le16_to_cpu(eep->baseEepHeader.length);\r\nel = min(el / sizeof(u16), SIZE_EEPROM_4K);\r\nif (!ath9k_hw_nvram_validate_checksum(ah, el))\r\nreturn -EINVAL;\r\nif (need_swap) {\r\nEEPROM_FIELD_SWAB16(eep->baseEepHeader.length);\r\nEEPROM_FIELD_SWAB16(eep->baseEepHeader.checksum);\r\nEEPROM_FIELD_SWAB16(eep->baseEepHeader.version);\r\nEEPROM_FIELD_SWAB16(eep->baseEepHeader.regDmn[0]);\r\nEEPROM_FIELD_SWAB16(eep->baseEepHeader.regDmn[1]);\r\nEEPROM_FIELD_SWAB16(eep->baseEepHeader.rfSilent);\r\nEEPROM_FIELD_SWAB16(eep->baseEepHeader.blueToothOptions);\r\nEEPROM_FIELD_SWAB16(eep->baseEepHeader.deviceCap);\r\nEEPROM_FIELD_SWAB32(eep->modalHeader.antCtrlCommon);\r\nfor (i = 0; i < AR5416_EEP4K_MAX_CHAINS; i++)\r\nEEPROM_FIELD_SWAB32(eep->modalHeader.antCtrlChain[i]);\r\nfor (i = 0; i < AR_EEPROM_MODAL_SPURS; i++)\r\nEEPROM_FIELD_SWAB16(\r\neep->modalHeader.spurChans[i].spurChan);\r\n}\r\nif (!ath9k_hw_nvram_check_version(ah, AR5416_EEP_VER,\r\nAR5416_EEP_NO_BACK_VER))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic u32 ath9k_hw_4k_get_eeprom(struct ath_hw *ah,\r\nenum eeprom_param param)\r\n{\r\nstruct ar5416_eeprom_4k *eep = &ah->eeprom.map4k;\r\nstruct modal_eep_4k_header *pModal = &eep->modalHeader;\r\nstruct base_eep_header_4k *pBase = &eep->baseEepHeader;\r\nswitch (param) {\r\ncase EEP_NFTHRESH_2:\r\nreturn pModal->noiseFloorThreshCh[0];\r\ncase EEP_MAC_LSW:\r\nreturn get_unaligned_be16(pBase->macAddr);\r\ncase EEP_MAC_MID:\r\nreturn get_unaligned_be16(pBase->macAddr + 2);\r\ncase EEP_MAC_MSW:\r\nreturn get_unaligned_be16(pBase->macAddr + 4);\r\ncase EEP_REG_0:\r\nreturn le16_to_cpu(pBase->regDmn[0]);\r\ncase EEP_OP_CAP:\r\nreturn le16_to_cpu(pBase->deviceCap);\r\ncase EEP_OP_MODE:\r\nreturn pBase->opCapFlags;\r\ncase EEP_RF_SILENT:\r\nreturn le16_to_cpu(pBase->rfSilent);\r\ncase EEP_OB_2:\r\nreturn pModal->ob_0;\r\ncase EEP_DB_2:\r\nreturn pModal->db1_1;\r\ncase EEP_TX_MASK:\r\nreturn pBase->txMask;\r\ncase EEP_RX_MASK:\r\nreturn pBase->rxMask;\r\ncase EEP_FRAC_N_5G:\r\nreturn 0;\r\ncase EEP_PWR_TABLE_OFFSET:\r\nreturn AR5416_PWR_TABLE_OFFSET_DB;\r\ncase EEP_MODAL_VER:\r\nreturn pModal->version;\r\ncase EEP_ANT_DIV_CTL1:\r\nreturn pModal->antdiv_ctl1;\r\ncase EEP_TXGAIN_TYPE:\r\nreturn pBase->txGainType;\r\ncase EEP_ANTENNA_GAIN_2G:\r\nreturn pModal->antennaGainCh[0];\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void ath9k_hw_set_4k_power_cal_table(struct ath_hw *ah,\r\nstruct ath9k_channel *chan)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ar5416_eeprom_4k *pEepData = &ah->eeprom.map4k;\r\nstruct cal_data_per_freq_4k *pRawDataset;\r\nu8 *pCalBChans = NULL;\r\nu16 pdGainOverlap_t2;\r\nstatic u8 pdadcValues[AR5416_NUM_PDADC_VALUES];\r\nu16 gainBoundaries[AR5416_PD_GAINS_IN_MASK];\r\nu16 numPiers, i, j;\r\nu16 numXpdGain, xpdMask;\r\nu16 xpdGainValues[AR5416_EEP4K_NUM_PD_GAINS] = { 0, 0 };\r\nu32 reg32, regOffset, regChainOffset;\r\nxpdMask = pEepData->modalHeader.xpdGain;\r\nif (ath9k_hw_4k_get_eeprom_rev(ah) >= AR5416_EEP_MINOR_VER_2)\r\npdGainOverlap_t2 =\r\npEepData->modalHeader.pdGainOverlap;\r\nelse\r\npdGainOverlap_t2 = (u16)(MS(REG_READ(ah, AR_PHY_TPCRG5),\r\nAR_PHY_TPCRG5_PD_GAIN_OVERLAP));\r\npCalBChans = pEepData->calFreqPier2G;\r\nnumPiers = AR5416_EEP4K_NUM_2G_CAL_PIERS;\r\nnumXpdGain = 0;\r\nfor (i = 1; i <= AR5416_PD_GAINS_IN_MASK; i++) {\r\nif ((xpdMask >> (AR5416_PD_GAINS_IN_MASK - i)) & 1) {\r\nif (numXpdGain >= AR5416_EEP4K_NUM_PD_GAINS)\r\nbreak;\r\nxpdGainValues[numXpdGain] =\r\n(u16)(AR5416_PD_GAINS_IN_MASK - i);\r\nnumXpdGain++;\r\n}\r\n}\r\nENABLE_REG_RMW_BUFFER(ah);\r\nREG_RMW_FIELD(ah, AR_PHY_TPCRG1, AR_PHY_TPCRG1_NUM_PD_GAIN,\r\n(numXpdGain - 1) & 0x3);\r\nREG_RMW_FIELD(ah, AR_PHY_TPCRG1, AR_PHY_TPCRG1_PD_GAIN_1,\r\nxpdGainValues[0]);\r\nREG_RMW_FIELD(ah, AR_PHY_TPCRG1, AR_PHY_TPCRG1_PD_GAIN_2,\r\nxpdGainValues[1]);\r\nREG_RMW_FIELD(ah, AR_PHY_TPCRG1, AR_PHY_TPCRG1_PD_GAIN_3, 0);\r\nREG_RMW_BUFFER_FLUSH(ah);\r\nfor (i = 0; i < AR5416_EEP4K_MAX_CHAINS; i++) {\r\nregChainOffset = i * 0x1000;\r\nif (pEepData->baseEepHeader.txMask & (1 << i)) {\r\npRawDataset = pEepData->calPierData2G[i];\r\nath9k_hw_get_gain_boundaries_pdadcs(ah, chan,\r\npRawDataset, pCalBChans,\r\nnumPiers, pdGainOverlap_t2,\r\ngainBoundaries,\r\npdadcValues, numXpdGain);\r\nENABLE_REGWRITE_BUFFER(ah);\r\nREG_WRITE(ah, AR_PHY_TPCRG5 + regChainOffset,\r\nSM(pdGainOverlap_t2,\r\nAR_PHY_TPCRG5_PD_GAIN_OVERLAP)\r\n| SM(gainBoundaries[0],\r\nAR_PHY_TPCRG5_PD_GAIN_BOUNDARY_1)\r\n| SM(gainBoundaries[1],\r\nAR_PHY_TPCRG5_PD_GAIN_BOUNDARY_2)\r\n| SM(gainBoundaries[2],\r\nAR_PHY_TPCRG5_PD_GAIN_BOUNDARY_3)\r\n| SM(gainBoundaries[3],\r\nAR_PHY_TPCRG5_PD_GAIN_BOUNDARY_4));\r\nregOffset = AR_PHY_BASE + (672 << 2) + regChainOffset;\r\nfor (j = 0; j < 32; j++) {\r\nreg32 = get_unaligned_le32(&pdadcValues[4 * j]);\r\nREG_WRITE(ah, regOffset, reg32);\r\nath_dbg(common, EEPROM,\r\n"PDADC (%d,%4x): %4.4x %8.8x\n",\r\ni, regChainOffset, regOffset,\r\nreg32);\r\nath_dbg(common, EEPROM,\r\n"PDADC: Chain %d | "\r\n"PDADC %3d Value %3d | "\r\n"PDADC %3d Value %3d | "\r\n"PDADC %3d Value %3d | "\r\n"PDADC %3d Value %3d |\n",\r\ni, 4 * j, pdadcValues[4 * j],\r\n4 * j + 1, pdadcValues[4 * j + 1],\r\n4 * j + 2, pdadcValues[4 * j + 2],\r\n4 * j + 3, pdadcValues[4 * j + 3]);\r\nregOffset += 4;\r\n}\r\nREGWRITE_BUFFER_FLUSH(ah);\r\n}\r\n}\r\n}\r\nstatic void ath9k_hw_set_4k_power_per_rate_table(struct ath_hw *ah,\r\nstruct ath9k_channel *chan,\r\nint16_t *ratesArray,\r\nu16 cfgCtl,\r\nu16 antenna_reduction,\r\nu16 powerLimit)\r\n{\r\n#define CMP_TEST_GRP \\r\n(((cfgCtl & ~CTL_MODE_M)| (pCtlMode[ctlMode] & CTL_MODE_M)) == \\r\npEepData->ctlIndex[i]) \\r\n|| (((cfgCtl & ~CTL_MODE_M) | (pCtlMode[ctlMode] & CTL_MODE_M)) == \\r\n((pEepData->ctlIndex[i] & CTL_MODE_M) | SD_NO_CTL))\r\nint i;\r\nu16 twiceMinEdgePower;\r\nu16 twiceMaxEdgePower;\r\nu16 scaledPower = 0, minCtlPower;\r\nu16 numCtlModes;\r\nconst u16 *pCtlMode;\r\nu16 ctlMode, freq;\r\nstruct chan_centers centers;\r\nstruct cal_ctl_data_4k *rep;\r\nstruct ar5416_eeprom_4k *pEepData = &ah->eeprom.map4k;\r\nstruct cal_target_power_leg targetPowerOfdm, targetPowerCck = {\r\n0, { 0, 0, 0, 0}\r\n};\r\nstruct cal_target_power_leg targetPowerOfdmExt = {\r\n0, { 0, 0, 0, 0} }, targetPowerCckExt = {\r\n0, { 0, 0, 0, 0 }\r\n};\r\nstruct cal_target_power_ht targetPowerHt20, targetPowerHt40 = {\r\n0, {0, 0, 0, 0}\r\n};\r\nstatic const u16 ctlModesFor11g[] = {\r\nCTL_11B, CTL_11G, CTL_2GHT20,\r\nCTL_11B_EXT, CTL_11G_EXT, CTL_2GHT40\r\n};\r\nath9k_hw_get_channel_centers(ah, chan, &centers);\r\nscaledPower = powerLimit - antenna_reduction;\r\nnumCtlModes = ARRAY_SIZE(ctlModesFor11g) - SUB_NUM_CTL_MODES_AT_2G_40;\r\npCtlMode = ctlModesFor11g;\r\nath9k_hw_get_legacy_target_powers(ah, chan,\r\npEepData->calTargetPowerCck,\r\nAR5416_NUM_2G_CCK_TARGET_POWERS,\r\n&targetPowerCck, 4, false);\r\nath9k_hw_get_legacy_target_powers(ah, chan,\r\npEepData->calTargetPower2G,\r\nAR5416_NUM_2G_20_TARGET_POWERS,\r\n&targetPowerOfdm, 4, false);\r\nath9k_hw_get_target_powers(ah, chan,\r\npEepData->calTargetPower2GHT20,\r\nAR5416_NUM_2G_20_TARGET_POWERS,\r\n&targetPowerHt20, 8, false);\r\nif (IS_CHAN_HT40(chan)) {\r\nnumCtlModes = ARRAY_SIZE(ctlModesFor11g);\r\nath9k_hw_get_target_powers(ah, chan,\r\npEepData->calTargetPower2GHT40,\r\nAR5416_NUM_2G_40_TARGET_POWERS,\r\n&targetPowerHt40, 8, true);\r\nath9k_hw_get_legacy_target_powers(ah, chan,\r\npEepData->calTargetPowerCck,\r\nAR5416_NUM_2G_CCK_TARGET_POWERS,\r\n&targetPowerCckExt, 4, true);\r\nath9k_hw_get_legacy_target_powers(ah, chan,\r\npEepData->calTargetPower2G,\r\nAR5416_NUM_2G_20_TARGET_POWERS,\r\n&targetPowerOfdmExt, 4, true);\r\n}\r\nfor (ctlMode = 0; ctlMode < numCtlModes; ctlMode++) {\r\nbool isHt40CtlMode = (pCtlMode[ctlMode] == CTL_5GHT40) ||\r\n(pCtlMode[ctlMode] == CTL_2GHT40);\r\nif (isHt40CtlMode)\r\nfreq = centers.synth_center;\r\nelse if (pCtlMode[ctlMode] & EXT_ADDITIVE)\r\nfreq = centers.ext_center;\r\nelse\r\nfreq = centers.ctl_center;\r\ntwiceMaxEdgePower = MAX_RATE_POWER;\r\nfor (i = 0; (i < AR5416_EEP4K_NUM_CTLS) &&\r\npEepData->ctlIndex[i]; i++) {\r\nif (CMP_TEST_GRP) {\r\nrep = &(pEepData->ctlData[i]);\r\ntwiceMinEdgePower = ath9k_hw_get_max_edge_power(\r\nfreq,\r\nrep->ctlEdges[\r\nar5416_get_ntxchains(ah->txchainmask) - 1],\r\nIS_CHAN_2GHZ(chan),\r\nAR5416_EEP4K_NUM_BAND_EDGES);\r\nif ((cfgCtl & ~CTL_MODE_M) == SD_NO_CTL) {\r\ntwiceMaxEdgePower =\r\nmin(twiceMaxEdgePower,\r\ntwiceMinEdgePower);\r\n} else {\r\ntwiceMaxEdgePower = twiceMinEdgePower;\r\nbreak;\r\n}\r\n}\r\n}\r\nminCtlPower = (u8)min(twiceMaxEdgePower, scaledPower);\r\nswitch (pCtlMode[ctlMode]) {\r\ncase CTL_11B:\r\nfor (i = 0; i < ARRAY_SIZE(targetPowerCck.tPow2x); i++) {\r\ntargetPowerCck.tPow2x[i] =\r\nmin((u16)targetPowerCck.tPow2x[i],\r\nminCtlPower);\r\n}\r\nbreak;\r\ncase CTL_11G:\r\nfor (i = 0; i < ARRAY_SIZE(targetPowerOfdm.tPow2x); i++) {\r\ntargetPowerOfdm.tPow2x[i] =\r\nmin((u16)targetPowerOfdm.tPow2x[i],\r\nminCtlPower);\r\n}\r\nbreak;\r\ncase CTL_2GHT20:\r\nfor (i = 0; i < ARRAY_SIZE(targetPowerHt20.tPow2x); i++) {\r\ntargetPowerHt20.tPow2x[i] =\r\nmin((u16)targetPowerHt20.tPow2x[i],\r\nminCtlPower);\r\n}\r\nbreak;\r\ncase CTL_11B_EXT:\r\ntargetPowerCckExt.tPow2x[0] =\r\nmin((u16)targetPowerCckExt.tPow2x[0],\r\nminCtlPower);\r\nbreak;\r\ncase CTL_11G_EXT:\r\ntargetPowerOfdmExt.tPow2x[0] =\r\nmin((u16)targetPowerOfdmExt.tPow2x[0],\r\nminCtlPower);\r\nbreak;\r\ncase CTL_2GHT40:\r\nfor (i = 0; i < ARRAY_SIZE(targetPowerHt40.tPow2x); i++) {\r\ntargetPowerHt40.tPow2x[i] =\r\nmin((u16)targetPowerHt40.tPow2x[i],\r\nminCtlPower);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nratesArray[rate6mb] =\r\nratesArray[rate9mb] =\r\nratesArray[rate12mb] =\r\nratesArray[rate18mb] =\r\nratesArray[rate24mb] =\r\ntargetPowerOfdm.tPow2x[0];\r\nratesArray[rate36mb] = targetPowerOfdm.tPow2x[1];\r\nratesArray[rate48mb] = targetPowerOfdm.tPow2x[2];\r\nratesArray[rate54mb] = targetPowerOfdm.tPow2x[3];\r\nratesArray[rateXr] = targetPowerOfdm.tPow2x[0];\r\nfor (i = 0; i < ARRAY_SIZE(targetPowerHt20.tPow2x); i++)\r\nratesArray[rateHt20_0 + i] = targetPowerHt20.tPow2x[i];\r\nratesArray[rate1l] = targetPowerCck.tPow2x[0];\r\nratesArray[rate2s] = ratesArray[rate2l] = targetPowerCck.tPow2x[1];\r\nratesArray[rate5_5s] = ratesArray[rate5_5l] = targetPowerCck.tPow2x[2];\r\nratesArray[rate11s] = ratesArray[rate11l] = targetPowerCck.tPow2x[3];\r\nif (IS_CHAN_HT40(chan)) {\r\nfor (i = 0; i < ARRAY_SIZE(targetPowerHt40.tPow2x); i++) {\r\nratesArray[rateHt40_0 + i] =\r\ntargetPowerHt40.tPow2x[i];\r\n}\r\nratesArray[rateDupOfdm] = targetPowerHt40.tPow2x[0];\r\nratesArray[rateDupCck] = targetPowerHt40.tPow2x[0];\r\nratesArray[rateExtOfdm] = targetPowerOfdmExt.tPow2x[0];\r\nratesArray[rateExtCck] = targetPowerCckExt.tPow2x[0];\r\n}\r\n#undef CMP_TEST_GRP\r\n}\r\nstatic void ath9k_hw_4k_set_txpower(struct ath_hw *ah,\r\nstruct ath9k_channel *chan,\r\nu16 cfgCtl,\r\nu8 twiceAntennaReduction,\r\nu8 powerLimit, bool test)\r\n{\r\nstruct ath_regulatory *regulatory = ath9k_hw_regulatory(ah);\r\nstruct ar5416_eeprom_4k *pEepData = &ah->eeprom.map4k;\r\nstruct modal_eep_4k_header *pModal = &pEepData->modalHeader;\r\nint16_t ratesArray[Ar5416RateSize];\r\nu8 ht40PowerIncForPdadc = 2;\r\nint i;\r\nmemset(ratesArray, 0, sizeof(ratesArray));\r\nif (ath9k_hw_4k_get_eeprom_rev(ah) >= AR5416_EEP_MINOR_VER_2)\r\nht40PowerIncForPdadc = pModal->ht40PowerIncForPdadc;\r\nath9k_hw_set_4k_power_per_rate_table(ah, chan,\r\n&ratesArray[0], cfgCtl,\r\ntwiceAntennaReduction,\r\npowerLimit);\r\nath9k_hw_set_4k_power_cal_table(ah, chan);\r\nregulatory->max_power_level = 0;\r\nfor (i = 0; i < ARRAY_SIZE(ratesArray); i++) {\r\nif (ratesArray[i] > MAX_RATE_POWER)\r\nratesArray[i] = MAX_RATE_POWER;\r\nif (ratesArray[i] > regulatory->max_power_level)\r\nregulatory->max_power_level = ratesArray[i];\r\n}\r\nif (test)\r\nreturn;\r\nfor (i = 0; i < Ar5416RateSize; i++)\r\nratesArray[i] -= AR5416_PWR_TABLE_OFFSET_DB * 2;\r\nENABLE_REGWRITE_BUFFER(ah);\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE1,\r\nATH9K_POW_SM(ratesArray[rate18mb], 24)\r\n| ATH9K_POW_SM(ratesArray[rate12mb], 16)\r\n| ATH9K_POW_SM(ratesArray[rate9mb], 8)\r\n| ATH9K_POW_SM(ratesArray[rate6mb], 0));\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE2,\r\nATH9K_POW_SM(ratesArray[rate54mb], 24)\r\n| ATH9K_POW_SM(ratesArray[rate48mb], 16)\r\n| ATH9K_POW_SM(ratesArray[rate36mb], 8)\r\n| ATH9K_POW_SM(ratesArray[rate24mb], 0));\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE3,\r\nATH9K_POW_SM(ratesArray[rate2s], 24)\r\n| ATH9K_POW_SM(ratesArray[rate2l], 16)\r\n| ATH9K_POW_SM(ratesArray[rateXr], 8)\r\n| ATH9K_POW_SM(ratesArray[rate1l], 0));\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE4,\r\nATH9K_POW_SM(ratesArray[rate11s], 24)\r\n| ATH9K_POW_SM(ratesArray[rate11l], 16)\r\n| ATH9K_POW_SM(ratesArray[rate5_5s], 8)\r\n| ATH9K_POW_SM(ratesArray[rate5_5l], 0));\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE5,\r\nATH9K_POW_SM(ratesArray[rateHt20_3], 24)\r\n| ATH9K_POW_SM(ratesArray[rateHt20_2], 16)\r\n| ATH9K_POW_SM(ratesArray[rateHt20_1], 8)\r\n| ATH9K_POW_SM(ratesArray[rateHt20_0], 0));\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE6,\r\nATH9K_POW_SM(ratesArray[rateHt20_7], 24)\r\n| ATH9K_POW_SM(ratesArray[rateHt20_6], 16)\r\n| ATH9K_POW_SM(ratesArray[rateHt20_5], 8)\r\n| ATH9K_POW_SM(ratesArray[rateHt20_4], 0));\r\nif (IS_CHAN_HT40(chan)) {\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE7,\r\nATH9K_POW_SM(ratesArray[rateHt40_3] +\r\nht40PowerIncForPdadc, 24)\r\n| ATH9K_POW_SM(ratesArray[rateHt40_2] +\r\nht40PowerIncForPdadc, 16)\r\n| ATH9K_POW_SM(ratesArray[rateHt40_1] +\r\nht40PowerIncForPdadc, 8)\r\n| ATH9K_POW_SM(ratesArray[rateHt40_0] +\r\nht40PowerIncForPdadc, 0));\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE8,\r\nATH9K_POW_SM(ratesArray[rateHt40_7] +\r\nht40PowerIncForPdadc, 24)\r\n| ATH9K_POW_SM(ratesArray[rateHt40_6] +\r\nht40PowerIncForPdadc, 16)\r\n| ATH9K_POW_SM(ratesArray[rateHt40_5] +\r\nht40PowerIncForPdadc, 8)\r\n| ATH9K_POW_SM(ratesArray[rateHt40_4] +\r\nht40PowerIncForPdadc, 0));\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE9,\r\nATH9K_POW_SM(ratesArray[rateExtOfdm], 24)\r\n| ATH9K_POW_SM(ratesArray[rateExtCck], 16)\r\n| ATH9K_POW_SM(ratesArray[rateDupOfdm], 8)\r\n| ATH9K_POW_SM(ratesArray[rateDupCck], 0));\r\n}\r\nif (ah->tpc_enabled) {\r\nint ht40_delta;\r\nht40_delta = (IS_CHAN_HT40(chan)) ? ht40PowerIncForPdadc : 0;\r\nar5008_hw_init_rate_txpower(ah, ratesArray, chan, ht40_delta);\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE_MAX,\r\nMAX_RATE_POWER | AR_PHY_POWER_TX_RATE_MAX_TPC_ENABLE);\r\n} else {\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE_MAX, MAX_RATE_POWER);\r\n}\r\nREGWRITE_BUFFER_FLUSH(ah);\r\n}\r\nstatic void ath9k_hw_4k_set_gain(struct ath_hw *ah,\r\nstruct modal_eep_4k_header *pModal,\r\nstruct ar5416_eeprom_4k *eep,\r\nu8 txRxAttenLocal)\r\n{\r\nENABLE_REG_RMW_BUFFER(ah);\r\nREG_RMW(ah, AR_PHY_SWITCH_CHAIN_0,\r\nle32_to_cpu(pModal->antCtrlChain[0]), 0);\r\nREG_RMW(ah, AR_PHY_TIMING_CTRL4(0),\r\nSM(pModal->iqCalICh[0], AR_PHY_TIMING_CTRL4_IQCORR_Q_I_COFF) |\r\nSM(pModal->iqCalQCh[0], AR_PHY_TIMING_CTRL4_IQCORR_Q_Q_COFF),\r\nAR_PHY_TIMING_CTRL4_IQCORR_Q_Q_COFF | AR_PHY_TIMING_CTRL4_IQCORR_Q_I_COFF);\r\nif (ath9k_hw_4k_get_eeprom_rev(ah) >= AR5416_EEP_MINOR_VER_3) {\r\ntxRxAttenLocal = pModal->txRxAttenCh[0];\r\nREG_RMW_FIELD(ah, AR_PHY_GAIN_2GHZ,\r\nAR_PHY_GAIN_2GHZ_XATTEN1_MARGIN, pModal->bswMargin[0]);\r\nREG_RMW_FIELD(ah, AR_PHY_GAIN_2GHZ,\r\nAR_PHY_GAIN_2GHZ_XATTEN1_DB, pModal->bswAtten[0]);\r\nREG_RMW_FIELD(ah, AR_PHY_GAIN_2GHZ,\r\nAR_PHY_GAIN_2GHZ_XATTEN2_MARGIN,\r\npModal->xatten2Margin[0]);\r\nREG_RMW_FIELD(ah, AR_PHY_GAIN_2GHZ,\r\nAR_PHY_GAIN_2GHZ_XATTEN2_DB, pModal->xatten2Db[0]);\r\nREG_RMW_FIELD(ah, AR_PHY_GAIN_2GHZ + 0x1000,\r\nAR_PHY_GAIN_2GHZ_XATTEN1_MARGIN,\r\npModal->bswMargin[0]);\r\nREG_RMW_FIELD(ah, AR_PHY_GAIN_2GHZ + 0x1000,\r\nAR_PHY_GAIN_2GHZ_XATTEN1_DB, pModal->bswAtten[0]);\r\nREG_RMW_FIELD(ah, AR_PHY_GAIN_2GHZ + 0x1000,\r\nAR_PHY_GAIN_2GHZ_XATTEN2_MARGIN,\r\npModal->xatten2Margin[0]);\r\nREG_RMW_FIELD(ah, AR_PHY_GAIN_2GHZ + 0x1000,\r\nAR_PHY_GAIN_2GHZ_XATTEN2_DB,\r\npModal->xatten2Db[0]);\r\n}\r\nREG_RMW_FIELD(ah, AR_PHY_RXGAIN,\r\nAR9280_PHY_RXGAIN_TXRX_ATTEN, txRxAttenLocal);\r\nREG_RMW_FIELD(ah, AR_PHY_RXGAIN,\r\nAR9280_PHY_RXGAIN_TXRX_MARGIN, pModal->rxTxMarginCh[0]);\r\nREG_RMW_FIELD(ah, AR_PHY_RXGAIN + 0x1000,\r\nAR9280_PHY_RXGAIN_TXRX_ATTEN, txRxAttenLocal);\r\nREG_RMW_FIELD(ah, AR_PHY_RXGAIN + 0x1000,\r\nAR9280_PHY_RXGAIN_TXRX_MARGIN, pModal->rxTxMarginCh[0]);\r\nREG_RMW_BUFFER_FLUSH(ah);\r\n}\r\nstatic void ath9k_hw_4k_set_board_values(struct ath_hw *ah,\r\nstruct ath9k_channel *chan)\r\n{\r\nstruct ath9k_hw_capabilities *pCap = &ah->caps;\r\nstruct modal_eep_4k_header *pModal;\r\nstruct ar5416_eeprom_4k *eep = &ah->eeprom.map4k;\r\nstruct base_eep_header_4k *pBase = &eep->baseEepHeader;\r\nu8 txRxAttenLocal;\r\nu8 ob[5], db1[5], db2[5];\r\nu8 ant_div_control1, ant_div_control2;\r\nu8 bb_desired_scale;\r\nu32 regVal;\r\npModal = &eep->modalHeader;\r\ntxRxAttenLocal = 23;\r\nREG_WRITE(ah, AR_PHY_SWITCH_COM, le32_to_cpu(pModal->antCtrlCommon));\r\nath9k_hw_4k_set_gain(ah, pModal, eep, txRxAttenLocal);\r\nif (pModal->version >= 3) {\r\nant_div_control1 = pModal->antdiv_ctl1;\r\nant_div_control2 = pModal->antdiv_ctl2;\r\nregVal = REG_READ(ah, AR_PHY_MULTICHAIN_GAIN_CTL);\r\nregVal &= (~(AR_PHY_9285_ANT_DIV_CTL_ALL));\r\nregVal |= SM(ant_div_control1,\r\nAR_PHY_9285_ANT_DIV_CTL);\r\nregVal |= SM(ant_div_control2,\r\nAR_PHY_9285_ANT_DIV_ALT_LNACONF);\r\nregVal |= SM((ant_div_control2 >> 2),\r\nAR_PHY_9285_ANT_DIV_MAIN_LNACONF);\r\nregVal |= SM((ant_div_control1 >> 1),\r\nAR_PHY_9285_ANT_DIV_ALT_GAINTB);\r\nregVal |= SM((ant_div_control1 >> 2),\r\nAR_PHY_9285_ANT_DIV_MAIN_GAINTB);\r\nREG_WRITE(ah, AR_PHY_MULTICHAIN_GAIN_CTL, regVal);\r\nregVal = REG_READ(ah, AR_PHY_MULTICHAIN_GAIN_CTL);\r\nregVal = REG_READ(ah, AR_PHY_CCK_DETECT);\r\nregVal &= (~AR_PHY_CCK_DETECT_BB_ENABLE_ANT_FAST_DIV);\r\nregVal |= SM((ant_div_control1 >> 3),\r\nAR_PHY_CCK_DETECT_BB_ENABLE_ANT_FAST_DIV);\r\nREG_WRITE(ah, AR_PHY_CCK_DETECT, regVal);\r\nregVal = REG_READ(ah, AR_PHY_CCK_DETECT);\r\nif (pCap->hw_caps & ATH9K_HW_CAP_ANT_DIV_COMB) {\r\nregVal = REG_READ(ah, AR_PHY_MULTICHAIN_GAIN_CTL);\r\nregVal &= (~(AR_PHY_9285_ANT_DIV_MAIN_LNACONF |\r\nAR_PHY_9285_ANT_DIV_ALT_LNACONF));\r\nregVal |= (ATH_ANT_DIV_COMB_LNA1 <<\r\nAR_PHY_9285_ANT_DIV_MAIN_LNACONF_S);\r\nregVal |= (ATH_ANT_DIV_COMB_LNA2 <<\r\nAR_PHY_9285_ANT_DIV_ALT_LNACONF_S);\r\nregVal &= (~(AR_PHY_9285_FAST_DIV_BIAS));\r\nregVal |= (0 << AR_PHY_9285_FAST_DIV_BIAS_S);\r\nREG_WRITE(ah, AR_PHY_MULTICHAIN_GAIN_CTL, regVal);\r\n}\r\n}\r\nif (pModal->version >= 2) {\r\nob[0] = pModal->ob_0;\r\nob[1] = pModal->ob_1;\r\nob[2] = pModal->ob_2;\r\nob[3] = pModal->ob_3;\r\nob[4] = pModal->ob_4;\r\ndb1[0] = pModal->db1_0;\r\ndb1[1] = pModal->db1_1;\r\ndb1[2] = pModal->db1_2;\r\ndb1[3] = pModal->db1_3;\r\ndb1[4] = pModal->db1_4;\r\ndb2[0] = pModal->db2_0;\r\ndb2[1] = pModal->db2_1;\r\ndb2[2] = pModal->db2_2;\r\ndb2[3] = pModal->db2_3;\r\ndb2[4] = pModal->db2_4;\r\n} else if (pModal->version == 1) {\r\nob[0] = pModal->ob_0;\r\nob[1] = ob[2] = ob[3] = ob[4] = pModal->ob_1;\r\ndb1[0] = pModal->db1_0;\r\ndb1[1] = db1[2] = db1[3] = db1[4] = pModal->db1_1;\r\ndb2[0] = pModal->db2_0;\r\ndb2[1] = db2[2] = db2[3] = db2[4] = pModal->db2_1;\r\n} else {\r\nint i;\r\nfor (i = 0; i < 5; i++) {\r\nob[i] = pModal->ob_0;\r\ndb1[i] = pModal->db1_0;\r\ndb2[i] = pModal->db1_0;\r\n}\r\n}\r\nENABLE_REG_RMW_BUFFER(ah);\r\nif (AR_SREV_9271(ah)) {\r\nath9k_hw_analog_shift_rmw(ah,\r\nAR9285_AN_RF2G3,\r\nAR9271_AN_RF2G3_OB_cck,\r\nAR9271_AN_RF2G3_OB_cck_S,\r\nob[0]);\r\nath9k_hw_analog_shift_rmw(ah,\r\nAR9285_AN_RF2G3,\r\nAR9271_AN_RF2G3_OB_psk,\r\nAR9271_AN_RF2G3_OB_psk_S,\r\nob[1]);\r\nath9k_hw_analog_shift_rmw(ah,\r\nAR9285_AN_RF2G3,\r\nAR9271_AN_RF2G3_OB_qam,\r\nAR9271_AN_RF2G3_OB_qam_S,\r\nob[2]);\r\nath9k_hw_analog_shift_rmw(ah,\r\nAR9285_AN_RF2G3,\r\nAR9271_AN_RF2G3_DB_1,\r\nAR9271_AN_RF2G3_DB_1_S,\r\ndb1[0]);\r\nath9k_hw_analog_shift_rmw(ah,\r\nAR9285_AN_RF2G4,\r\nAR9271_AN_RF2G4_DB_2,\r\nAR9271_AN_RF2G4_DB_2_S,\r\ndb2[0]);\r\n} else {\r\nath9k_hw_analog_shift_rmw(ah,\r\nAR9285_AN_RF2G3,\r\nAR9285_AN_RF2G3_OB_0,\r\nAR9285_AN_RF2G3_OB_0_S,\r\nob[0]);\r\nath9k_hw_analog_shift_rmw(ah,\r\nAR9285_AN_RF2G3,\r\nAR9285_AN_RF2G3_OB_1,\r\nAR9285_AN_RF2G3_OB_1_S,\r\nob[1]);\r\nath9k_hw_analog_shift_rmw(ah,\r\nAR9285_AN_RF2G3,\r\nAR9285_AN_RF2G3_OB_2,\r\nAR9285_AN_RF2G3_OB_2_S,\r\nob[2]);\r\nath9k_hw_analog_shift_rmw(ah,\r\nAR9285_AN_RF2G3,\r\nAR9285_AN_RF2G3_OB_3,\r\nAR9285_AN_RF2G3_OB_3_S,\r\nob[3]);\r\nath9k_hw_analog_shift_rmw(ah,\r\nAR9285_AN_RF2G3,\r\nAR9285_AN_RF2G3_OB_4,\r\nAR9285_AN_RF2G3_OB_4_S,\r\nob[4]);\r\nath9k_hw_analog_shift_rmw(ah,\r\nAR9285_AN_RF2G3,\r\nAR9285_AN_RF2G3_DB1_0,\r\nAR9285_AN_RF2G3_DB1_0_S,\r\ndb1[0]);\r\nath9k_hw_analog_shift_rmw(ah,\r\nAR9285_AN_RF2G3,\r\nAR9285_AN_RF2G3_DB1_1,\r\nAR9285_AN_RF2G3_DB1_1_S,\r\ndb1[1]);\r\nath9k_hw_analog_shift_rmw(ah,\r\nAR9285_AN_RF2G3,\r\nAR9285_AN_RF2G3_DB1_2,\r\nAR9285_AN_RF2G3_DB1_2_S,\r\ndb1[2]);\r\nath9k_hw_analog_shift_rmw(ah,\r\nAR9285_AN_RF2G4,\r\nAR9285_AN_RF2G4_DB1_3,\r\nAR9285_AN_RF2G4_DB1_3_S,\r\ndb1[3]);\r\nath9k_hw_analog_shift_rmw(ah,\r\nAR9285_AN_RF2G4,\r\nAR9285_AN_RF2G4_DB1_4,\r\nAR9285_AN_RF2G4_DB1_4_S, db1[4]);\r\nath9k_hw_analog_shift_rmw(ah,\r\nAR9285_AN_RF2G4,\r\nAR9285_AN_RF2G4_DB2_0,\r\nAR9285_AN_RF2G4_DB2_0_S,\r\ndb2[0]);\r\nath9k_hw_analog_shift_rmw(ah,\r\nAR9285_AN_RF2G4,\r\nAR9285_AN_RF2G4_DB2_1,\r\nAR9285_AN_RF2G4_DB2_1_S,\r\ndb2[1]);\r\nath9k_hw_analog_shift_rmw(ah,\r\nAR9285_AN_RF2G4,\r\nAR9285_AN_RF2G4_DB2_2,\r\nAR9285_AN_RF2G4_DB2_2_S,\r\ndb2[2]);\r\nath9k_hw_analog_shift_rmw(ah,\r\nAR9285_AN_RF2G4,\r\nAR9285_AN_RF2G4_DB2_3,\r\nAR9285_AN_RF2G4_DB2_3_S,\r\ndb2[3]);\r\nath9k_hw_analog_shift_rmw(ah,\r\nAR9285_AN_RF2G4,\r\nAR9285_AN_RF2G4_DB2_4,\r\nAR9285_AN_RF2G4_DB2_4_S,\r\ndb2[4]);\r\n}\r\nREG_RMW_BUFFER_FLUSH(ah);\r\nENABLE_REG_RMW_BUFFER(ah);\r\nREG_RMW_FIELD(ah, AR_PHY_SETTLING, AR_PHY_SETTLING_SWITCH,\r\npModal->switchSettling);\r\nREG_RMW_FIELD(ah, AR_PHY_DESIRED_SZ, AR_PHY_DESIRED_SZ_ADC,\r\npModal->adcDesiredSize);\r\nREG_RMW(ah, AR_PHY_RF_CTL4,\r\nSM(pModal->txEndToXpaOff, AR_PHY_RF_CTL4_TX_END_XPAA_OFF) |\r\nSM(pModal->txEndToXpaOff, AR_PHY_RF_CTL4_TX_END_XPAB_OFF) |\r\nSM(pModal->txFrameToXpaOn, AR_PHY_RF_CTL4_FRAME_XPAA_ON) |\r\nSM(pModal->txFrameToXpaOn, AR_PHY_RF_CTL4_FRAME_XPAB_ON), 0);\r\nREG_RMW_FIELD(ah, AR_PHY_RF_CTL3, AR_PHY_TX_END_TO_A2_RX_ON,\r\npModal->txEndToRxOn);\r\nif (AR_SREV_9271_10(ah))\r\nREG_RMW_FIELD(ah, AR_PHY_RF_CTL3, AR_PHY_TX_END_TO_A2_RX_ON,\r\npModal->txEndToRxOn);\r\nREG_RMW_FIELD(ah, AR_PHY_CCA, AR9280_PHY_CCA_THRESH62,\r\npModal->thresh62);\r\nREG_RMW_FIELD(ah, AR_PHY_EXT_CCA0, AR_PHY_EXT_CCA0_THRESH62,\r\npModal->thresh62);\r\nif (ath9k_hw_4k_get_eeprom_rev(ah) >= AR5416_EEP_MINOR_VER_2) {\r\nREG_RMW_FIELD(ah, AR_PHY_RF_CTL2, AR_PHY_TX_END_DATA_START,\r\npModal->txFrameToDataStart);\r\nREG_RMW_FIELD(ah, AR_PHY_RF_CTL2, AR_PHY_TX_END_PA_ON,\r\npModal->txFrameToPaOn);\r\n}\r\nif (ath9k_hw_4k_get_eeprom_rev(ah) >= AR5416_EEP_MINOR_VER_3) {\r\nif (IS_CHAN_HT40(chan))\r\nREG_RMW_FIELD(ah, AR_PHY_SETTLING,\r\nAR_PHY_SETTLING_SWITCH,\r\npModal->swSettleHt40);\r\n}\r\nREG_RMW_BUFFER_FLUSH(ah);\r\nbb_desired_scale = (pModal->bb_scale_smrt_antenna &\r\nEEP_4K_BB_DESIRED_SCALE_MASK);\r\nif ((pBase->txGainType == 0) && (bb_desired_scale != 0)) {\r\nu32 pwrctrl, mask, clr;\r\nmask = BIT(0)|BIT(5)|BIT(10)|BIT(15)|BIT(20)|BIT(25);\r\npwrctrl = mask * bb_desired_scale;\r\nclr = mask * 0x1f;\r\nENABLE_REG_RMW_BUFFER(ah);\r\nREG_RMW(ah, AR_PHY_TX_PWRCTRL8, pwrctrl, clr);\r\nREG_RMW(ah, AR_PHY_TX_PWRCTRL10, pwrctrl, clr);\r\nREG_RMW(ah, AR_PHY_CH0_TX_PWRCTRL12, pwrctrl, clr);\r\nmask = BIT(0)|BIT(5)|BIT(15);\r\npwrctrl = mask * bb_desired_scale;\r\nclr = mask * 0x1f;\r\nREG_RMW(ah, AR_PHY_TX_PWRCTRL9, pwrctrl, clr);\r\nmask = BIT(0)|BIT(5);\r\npwrctrl = mask * bb_desired_scale;\r\nclr = mask * 0x1f;\r\nREG_RMW(ah, AR_PHY_CH0_TX_PWRCTRL11, pwrctrl, clr);\r\nREG_RMW(ah, AR_PHY_CH0_TX_PWRCTRL13, pwrctrl, clr);\r\nREG_RMW_BUFFER_FLUSH(ah);\r\n}\r\n}\r\nstatic u16 ath9k_hw_4k_get_spur_channel(struct ath_hw *ah, u16 i, bool is2GHz)\r\n{\r\nreturn le16_to_cpu(ah->eeprom.map4k.modalHeader.spurChans[i].spurChan);\r\n}\r\nstatic u8 ath9k_hw_4k_get_eepmisc(struct ath_hw *ah)\r\n{\r\nreturn ah->eeprom.map4k.baseEepHeader.eepMisc;\r\n}
