static int axp20x_set_dcdc_freq(struct platform_device *pdev, u32 dcdcfreq)\r\n{\r\nstruct axp20x_dev *axp20x = dev_get_drvdata(pdev->dev.parent);\r\nunsigned int reg = AXP20X_DCDC_FREQ;\r\nu32 min, max, def, step;\r\nswitch (axp20x->variant) {\r\ncase AXP202_ID:\r\ncase AXP209_ID:\r\nmin = 750;\r\nmax = 1875;\r\ndef = 1500;\r\nstep = 75;\r\nbreak;\r\ncase AXP806_ID:\r\nreg = AXP806_DCDC_FREQ_CTRL;\r\ncase AXP221_ID:\r\ncase AXP223_ID:\r\ncase AXP809_ID:\r\nmin = 1800;\r\nmax = 4050;\r\ndef = 3000;\r\nstep = 150;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev,\r\n"Setting DCDC frequency for unsupported AXP variant\n");\r\nreturn -EINVAL;\r\n}\r\nif (dcdcfreq == 0)\r\ndcdcfreq = def;\r\nif (dcdcfreq < min) {\r\ndcdcfreq = min;\r\ndev_warn(&pdev->dev, "DCDC frequency too low. Set to %ukHz\n",\r\nmin);\r\n}\r\nif (dcdcfreq > max) {\r\ndcdcfreq = max;\r\ndev_warn(&pdev->dev, "DCDC frequency too high. Set to %ukHz\n",\r\nmax);\r\n}\r\ndcdcfreq = (dcdcfreq - min) / step;\r\nreturn regmap_update_bits(axp20x->regmap, reg,\r\nAXP20X_FREQ_DCDC_MASK, dcdcfreq);\r\n}\r\nstatic int axp20x_regulator_parse_dt(struct platform_device *pdev)\r\n{\r\nstruct device_node *np, *regulators;\r\nint ret;\r\nu32 dcdcfreq = 0;\r\nnp = of_node_get(pdev->dev.parent->of_node);\r\nif (!np)\r\nreturn 0;\r\nregulators = of_get_child_by_name(np, "regulators");\r\nif (!regulators) {\r\ndev_warn(&pdev->dev, "regulators node not found\n");\r\n} else {\r\nof_property_read_u32(regulators, "x-powers,dcdc-freq", &dcdcfreq);\r\nret = axp20x_set_dcdc_freq(pdev, dcdcfreq);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Error setting dcdc frequency: %d\n", ret);\r\nreturn ret;\r\n}\r\nof_node_put(regulators);\r\n}\r\nreturn 0;\r\n}\r\nstatic int axp20x_set_dcdc_workmode(struct regulator_dev *rdev, int id, u32 workmode)\r\n{\r\nstruct axp20x_dev *axp20x = rdev_get_drvdata(rdev);\r\nunsigned int reg = AXP20X_DCDC_MODE;\r\nunsigned int mask;\r\nswitch (axp20x->variant) {\r\ncase AXP202_ID:\r\ncase AXP209_ID:\r\nif ((id != AXP20X_DCDC2) && (id != AXP20X_DCDC3))\r\nreturn -EINVAL;\r\nmask = AXP20X_WORKMODE_DCDC2_MASK;\r\nif (id == AXP20X_DCDC3)\r\nmask = AXP20X_WORKMODE_DCDC3_MASK;\r\nworkmode <<= ffs(mask) - 1;\r\nbreak;\r\ncase AXP806_ID:\r\nreg = AXP806_DCDC_MODE_CTRL2;\r\ncase AXP221_ID:\r\ncase AXP223_ID:\r\ncase AXP809_ID:\r\nif (id < AXP22X_DCDC1 || id > AXP22X_DCDC5)\r\nreturn -EINVAL;\r\nmask = AXP22X_WORKMODE_DCDCX_MASK(id - AXP22X_DCDC1);\r\nworkmode <<= id - AXP22X_DCDC1;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nreturn regmap_update_bits(rdev->regmap, reg, mask, workmode);\r\n}\r\nstatic bool axp20x_is_polyphase_slave(struct axp20x_dev *axp20x, int id)\r\n{\r\nu32 reg = 0;\r\nif (axp20x->variant != AXP806_ID)\r\nreturn false;\r\nregmap_read(axp20x->regmap, AXP806_DCDC_MODE_CTRL2, &reg);\r\nswitch (id) {\r\ncase AXP806_DCDCB:\r\nreturn (((reg & GENMASK(7, 6)) == BIT(6)) ||\r\n((reg & GENMASK(7, 6)) == BIT(7)));\r\ncase AXP806_DCDCC:\r\nreturn ((reg & GENMASK(7, 6)) == BIT(7));\r\ncase AXP806_DCDCE:\r\nreturn !!(reg & BIT(5));\r\n}\r\nreturn false;\r\n}\r\nstatic int axp20x_regulator_probe(struct platform_device *pdev)\r\n{\r\nstruct regulator_dev *rdev;\r\nstruct axp20x_dev *axp20x = dev_get_drvdata(pdev->dev.parent);\r\nconst struct regulator_desc *regulators;\r\nstruct regulator_config config = {\r\n.dev = pdev->dev.parent,\r\n.regmap = axp20x->regmap,\r\n.driver_data = axp20x,\r\n};\r\nint ret, i, nregulators;\r\nu32 workmode;\r\nconst char *dcdc1_name = axp22x_regulators[AXP22X_DCDC1].name;\r\nconst char *dcdc5_name = axp22x_regulators[AXP22X_DCDC5].name;\r\nbool drivevbus = false;\r\nswitch (axp20x->variant) {\r\ncase AXP202_ID:\r\ncase AXP209_ID:\r\nregulators = axp20x_regulators;\r\nnregulators = AXP20X_REG_ID_MAX;\r\nbreak;\r\ncase AXP221_ID:\r\ncase AXP223_ID:\r\nregulators = axp22x_regulators;\r\nnregulators = AXP22X_REG_ID_MAX;\r\ndrivevbus = of_property_read_bool(pdev->dev.parent->of_node,\r\n"x-powers,drive-vbus-en");\r\nbreak;\r\ncase AXP806_ID:\r\nregulators = axp806_regulators;\r\nnregulators = AXP806_REG_ID_MAX;\r\nbreak;\r\ncase AXP809_ID:\r\nregulators = axp809_regulators;\r\nnregulators = AXP809_REG_ID_MAX;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "Unsupported AXP variant: %ld\n",\r\naxp20x->variant);\r\nreturn -EINVAL;\r\n}\r\naxp20x_regulator_parse_dt(pdev);\r\nfor (i = 0; i < nregulators; i++) {\r\nconst struct regulator_desc *desc = &regulators[i];\r\nstruct regulator_desc *new_desc;\r\nif (axp20x_is_polyphase_slave(axp20x, i))\r\ncontinue;\r\nif ((regulators == axp22x_regulators && i == AXP22X_DC1SW) ||\r\n(regulators == axp809_regulators && i == AXP809_DC1SW)) {\r\nnew_desc = devm_kzalloc(&pdev->dev, sizeof(*desc),\r\nGFP_KERNEL);\r\n*new_desc = regulators[i];\r\nnew_desc->supply_name = dcdc1_name;\r\ndesc = new_desc;\r\n}\r\nif ((regulators == axp22x_regulators && i == AXP22X_DC5LDO) ||\r\n(regulators == axp809_regulators && i == AXP809_DC5LDO)) {\r\nnew_desc = devm_kzalloc(&pdev->dev, sizeof(*desc),\r\nGFP_KERNEL);\r\n*new_desc = regulators[i];\r\nnew_desc->supply_name = dcdc5_name;\r\ndesc = new_desc;\r\n}\r\nrdev = devm_regulator_register(&pdev->dev, desc, &config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(&pdev->dev, "Failed to register %s\n",\r\nregulators[i].name);\r\nreturn PTR_ERR(rdev);\r\n}\r\nret = of_property_read_u32(rdev->dev.of_node,\r\n"x-powers,dcdc-workmode",\r\n&workmode);\r\nif (!ret) {\r\nif (axp20x_set_dcdc_workmode(rdev, i, workmode))\r\ndev_err(&pdev->dev, "Failed to set workmode on %s\n",\r\nrdev->desc->name);\r\n}\r\nif ((regulators == axp22x_regulators && i == AXP22X_DCDC1) ||\r\n(regulators == axp809_regulators && i == AXP809_DCDC1))\r\nof_property_read_string(rdev->dev.of_node,\r\n"regulator-name",\r\n&dcdc1_name);\r\nif ((regulators == axp22x_regulators && i == AXP22X_DCDC5) ||\r\n(regulators == axp809_regulators && i == AXP809_DCDC5))\r\nof_property_read_string(rdev->dev.of_node,\r\n"regulator-name",\r\n&dcdc5_name);\r\n}\r\nif (drivevbus) {\r\nregmap_update_bits(axp20x->regmap, AXP20X_OVER_TMP,\r\nAXP22X_MISC_N_VBUSEN_FUNC, 0);\r\nrdev = devm_regulator_register(&pdev->dev,\r\n&axp22x_drivevbus_regulator,\r\n&config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(&pdev->dev, "Failed to register drivevbus\n");\r\nreturn PTR_ERR(rdev);\r\n}\r\n}\r\nreturn 0;\r\n}
