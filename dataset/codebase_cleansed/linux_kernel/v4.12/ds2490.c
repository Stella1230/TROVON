static int ds_send_control_cmd(struct ds_device *dev, u16 value, u16 index)\r\n{\r\nint err;\r\nerr = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, dev->ep[EP_CONTROL]),\r\nCONTROL_CMD, VENDOR, value, index, NULL, 0, 1000);\r\nif (err < 0) {\r\npr_err("Failed to send command control message %x.%x: err=%d.\n",\r\nvalue, index, err);\r\nreturn err;\r\n}\r\nreturn err;\r\n}\r\nstatic int ds_send_control_mode(struct ds_device *dev, u16 value, u16 index)\r\n{\r\nint err;\r\nerr = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, dev->ep[EP_CONTROL]),\r\nMODE_CMD, VENDOR, value, index, NULL, 0, 1000);\r\nif (err < 0) {\r\npr_err("Failed to send mode control message %x.%x: err=%d.\n",\r\nvalue, index, err);\r\nreturn err;\r\n}\r\nreturn err;\r\n}\r\nstatic int ds_send_control(struct ds_device *dev, u16 value, u16 index)\r\n{\r\nint err;\r\nerr = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, dev->ep[EP_CONTROL]),\r\nCOMM_CMD, VENDOR, value, index, NULL, 0, 1000);\r\nif (err < 0) {\r\npr_err("Failed to send control message %x.%x: err=%d.\n",\r\nvalue, index, err);\r\nreturn err;\r\n}\r\nreturn err;\r\n}\r\nstatic inline void ds_print_msg(unsigned char *buf, unsigned char *str, int off)\r\n{\r\npr_info("%45s: %8x\n", str, buf[off]);\r\n}\r\nstatic void ds_dump_status(struct ds_device *dev, unsigned char *buf, int count)\r\n{\r\nint i;\r\npr_info("0x%x: count=%d, status: ", dev->ep[EP_STATUS], count);\r\nfor (i=0; i<count; ++i)\r\npr_info("%02x ", buf[i]);\r\npr_info("\n");\r\nif (count >= 16) {\r\nds_print_msg(buf, "enable flag", 0);\r\nds_print_msg(buf, "1-wire speed", 1);\r\nds_print_msg(buf, "strong pullup duration", 2);\r\nds_print_msg(buf, "programming pulse duration", 3);\r\nds_print_msg(buf, "pulldown slew rate control", 4);\r\nds_print_msg(buf, "write-1 low time", 5);\r\nds_print_msg(buf, "data sample offset/write-0 recovery time",\r\n6);\r\nds_print_msg(buf, "reserved (test register)", 7);\r\nds_print_msg(buf, "device status flags", 8);\r\nds_print_msg(buf, "communication command byte 1", 9);\r\nds_print_msg(buf, "communication command byte 2", 10);\r\nds_print_msg(buf, "communication command buffer status", 11);\r\nds_print_msg(buf, "1-wire data output buffer status", 12);\r\nds_print_msg(buf, "1-wire data input buffer status", 13);\r\nds_print_msg(buf, "reserved", 14);\r\nds_print_msg(buf, "reserved", 15);\r\n}\r\nfor (i = 16; i < count; ++i) {\r\nif (buf[i] == RR_DETECT) {\r\nds_print_msg(buf, "new device detect", i);\r\ncontinue;\r\n}\r\nds_print_msg(buf, "Result Register Value: ", i);\r\nif (buf[i] & RR_NRS)\r\npr_info("NRS: Reset no presence or ...\n");\r\nif (buf[i] & RR_SH)\r\npr_info("SH: short on reset or set path\n");\r\nif (buf[i] & RR_APP)\r\npr_info("APP: alarming presence on reset\n");\r\nif (buf[i] & RR_VPP)\r\npr_info("VPP: 12V expected not seen\n");\r\nif (buf[i] & RR_CMP)\r\npr_info("CMP: compare error\n");\r\nif (buf[i] & RR_CRC)\r\npr_info("CRC: CRC error detected\n");\r\nif (buf[i] & RR_RDP)\r\npr_info("RDP: redirected page\n");\r\nif (buf[i] & RR_EOS)\r\npr_info("EOS: end of search error\n");\r\n}\r\n}\r\nstatic int ds_recv_status(struct ds_device *dev, struct ds_status *st,\r\nbool dump)\r\n{\r\nint count, err;\r\nif (st)\r\nmemset(st, 0, sizeof(*st));\r\ncount = 0;\r\nerr = usb_interrupt_msg(dev->udev,\r\nusb_rcvintpipe(dev->udev,\r\ndev->ep[EP_STATUS]),\r\ndev->st_buf, sizeof(dev->st_buf),\r\n&count, 1000);\r\nif (err < 0) {\r\npr_err("Failed to read 1-wire data from 0x%x: err=%d.\n",\r\ndev->ep[EP_STATUS], err);\r\nreturn err;\r\n}\r\nif (dump)\r\nds_dump_status(dev, dev->st_buf, count);\r\nif (st && count >= sizeof(*st))\r\nmemcpy(st, dev->st_buf, sizeof(*st));\r\nreturn count;\r\n}\r\nstatic void ds_reset_device(struct ds_device *dev)\r\n{\r\nds_send_control_cmd(dev, CTL_RESET_DEVICE, 0);\r\nif (ds_send_control_mode(dev, MOD_PULSE_EN, PULSE_SPUE))\r\npr_err("ds_reset_device: Error allowing strong pullup\n");\r\nif (dev->spu_sleep) {\r\nu8 del = dev->spu_sleep>>4;\r\nif (ds_send_control(dev, COMM_SET_DURATION | COMM_IM, del))\r\npr_err("ds_reset_device: Error setting duration\n");\r\n}\r\n}\r\nstatic int ds_recv_data(struct ds_device *dev, unsigned char *buf, int size)\r\n{\r\nint count, err;\r\ncount = 0;\r\nerr = usb_bulk_msg(dev->udev, usb_rcvbulkpipe(dev->udev, dev->ep[EP_DATA_IN]),\r\nbuf, size, &count, 1000);\r\nif (err < 0) {\r\npr_info("Clearing ep0x%x.\n", dev->ep[EP_DATA_IN]);\r\nusb_clear_halt(dev->udev, usb_rcvbulkpipe(dev->udev, dev->ep[EP_DATA_IN]));\r\nds_recv_status(dev, NULL, true);\r\nreturn err;\r\n}\r\n#if 0\r\n{\r\nint i;\r\nprintk("%s: count=%d: ", __func__, count);\r\nfor (i=0; i<count; ++i)\r\nprintk("%02x ", buf[i]);\r\nprintk("\n");\r\n}\r\n#endif\r\nreturn count;\r\n}\r\nstatic int ds_send_data(struct ds_device *dev, unsigned char *buf, int len)\r\n{\r\nint count, err;\r\ncount = 0;\r\nerr = usb_bulk_msg(dev->udev, usb_sndbulkpipe(dev->udev, dev->ep[EP_DATA_OUT]), buf, len, &count, 1000);\r\nif (err < 0) {\r\npr_err("Failed to write 1-wire data to ep0x%x: "\r\n"err=%d.\n", dev->ep[EP_DATA_OUT], err);\r\nreturn err;\r\n}\r\nreturn err;\r\n}\r\nstatic int ds_wait_status(struct ds_device *dev, struct ds_status *st)\r\n{\r\nint err, count = 0;\r\ndo {\r\nst->status = 0;\r\nerr = ds_recv_status(dev, st, false);\r\n#if 0\r\nif (err >= 0) {\r\nint i;\r\nprintk("0x%x: count=%d, status: ", dev->ep[EP_STATUS], err);\r\nfor (i=0; i<err; ++i)\r\nprintk("%02x ", dev->st_buf[i]);\r\nprintk("\n");\r\n}\r\n#endif\r\n} while (!(st->status & ST_IDLE) && !(err < 0) && ++count < 100);\r\nif (err >= 16 && st->status & ST_EPOF) {\r\npr_info("Resetting device after ST_EPOF.\n");\r\nds_reset_device(dev);\r\ncount = 101;\r\n}\r\nif (err > 16 || count >= 100 || err < 0)\r\nds_dump_status(dev, dev->st_buf, err);\r\nif (count >= 100 || err < 0)\r\nreturn -1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int ds_reset(struct ds_device *dev)\r\n{\r\nint err;\r\nerr = ds_send_control(dev, COMM_1_WIRE_RESET | COMM_IM, SPEED_NORMAL);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int ds_set_pullup(struct ds_device *dev, int delay)\r\n{\r\nint err = 0;\r\nu8 del = 1 + (u8)(delay >> 4);\r\nint ms = del<<4;\r\ndev->spu_bit = delay ? COMM_SPU : 0;\r\nif (delay == 0 || ms == dev->spu_sleep)\r\nreturn err;\r\nerr = ds_send_control(dev, COMM_SET_DURATION | COMM_IM, del);\r\nif (err)\r\nreturn err;\r\ndev->spu_sleep = ms;\r\nreturn err;\r\n}\r\nstatic int ds_touch_bit(struct ds_device *dev, u8 bit, u8 *tbit)\r\n{\r\nint err;\r\nstruct ds_status st;\r\nerr = ds_send_control(dev, COMM_BIT_IO | COMM_IM | (bit ? COMM_D : 0),\r\n0);\r\nif (err)\r\nreturn err;\r\nds_wait_status(dev, &st);\r\nerr = ds_recv_data(dev, tbit, sizeof(*tbit));\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int ds_write_byte(struct ds_device *dev, u8 byte)\r\n{\r\nint err;\r\nstruct ds_status st;\r\nerr = ds_send_control(dev, COMM_BYTE_IO | COMM_IM | dev->spu_bit, byte);\r\nif (err)\r\nreturn err;\r\nif (dev->spu_bit)\r\nmsleep(dev->spu_sleep);\r\nerr = ds_wait_status(dev, &st);\r\nif (err)\r\nreturn err;\r\nerr = ds_recv_data(dev, &dev->byte_buf, 1);\r\nif (err < 0)\r\nreturn err;\r\nreturn !(byte == dev->byte_buf);\r\n}\r\nstatic int ds_read_byte(struct ds_device *dev, u8 *byte)\r\n{\r\nint err;\r\nstruct ds_status st;\r\nerr = ds_send_control(dev, COMM_BYTE_IO | COMM_IM , 0xff);\r\nif (err)\r\nreturn err;\r\nds_wait_status(dev, &st);\r\nerr = ds_recv_data(dev, byte, sizeof(*byte));\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int ds_read_block(struct ds_device *dev, u8 *buf, int len)\r\n{\r\nstruct ds_status st;\r\nint err;\r\nif (len > 64*1024)\r\nreturn -E2BIG;\r\nmemset(buf, 0xFF, len);\r\nerr = ds_send_data(dev, buf, len);\r\nif (err < 0)\r\nreturn err;\r\nerr = ds_send_control(dev, COMM_BLOCK_IO | COMM_IM, len);\r\nif (err)\r\nreturn err;\r\nds_wait_status(dev, &st);\r\nmemset(buf, 0x00, len);\r\nerr = ds_recv_data(dev, buf, len);\r\nreturn err;\r\n}\r\nstatic int ds_write_block(struct ds_device *dev, u8 *buf, int len)\r\n{\r\nint err;\r\nstruct ds_status st;\r\nerr = ds_send_data(dev, buf, len);\r\nif (err < 0)\r\nreturn err;\r\nerr = ds_send_control(dev, COMM_BLOCK_IO | COMM_IM | dev->spu_bit, len);\r\nif (err)\r\nreturn err;\r\nif (dev->spu_bit)\r\nmsleep(dev->spu_sleep);\r\nds_wait_status(dev, &st);\r\nerr = ds_recv_data(dev, buf, len);\r\nif (err < 0)\r\nreturn err;\r\nreturn !(err == len);\r\n}\r\nstatic void ds9490r_search(void *data, struct w1_master *master,\r\nu8 search_type, w1_slave_found_callback callback)\r\n{\r\nstruct ds_device *dev = data;\r\nint err;\r\nu16 value, index;\r\nstruct ds_status st;\r\nint search_limit;\r\nint found = 0;\r\nint i;\r\nconst unsigned long jtime = msecs_to_jiffies(1000*8/75);\r\nconst size_t bufsize = 2 * 64;\r\nu64 *buf;\r\nbuf = kmalloc(bufsize, GFP_KERNEL);\r\nif (!buf)\r\nreturn;\r\nmutex_lock(&master->bus_mutex);\r\nif (ds_send_data(dev, (u8 *)&master->search_id, 8) < 0)\r\ngoto search_out;\r\nmaster->search_id = 0;\r\nvalue = COMM_SEARCH_ACCESS | COMM_IM | COMM_RST | COMM_SM | COMM_F |\r\nCOMM_RTS;\r\nsearch_limit = master->max_slave_count;\r\nif (search_limit > 255)\r\nsearch_limit = 0;\r\nindex = search_type | (search_limit << 8);\r\nif (ds_send_control(dev, value, index) < 0)\r\ngoto search_out;\r\ndo {\r\nschedule_timeout(jtime);\r\nerr = ds_recv_status(dev, &st, false);\r\nif (err < 0 || err < sizeof(st))\r\nbreak;\r\nif (st.data_in_buffer_status) {\r\nerr = ds_recv_data(dev, (u8 *)buf, bufsize);\r\nif (err < 0)\r\nbreak;\r\nfor (i = 0; i < err/8; ++i) {\r\n++found;\r\nif (found <= search_limit)\r\ncallback(master, buf[i]);\r\nif (found == search_limit)\r\nmaster->search_id = buf[i];\r\n}\r\n}\r\nif (test_bit(W1_ABORT_SEARCH, &master->flags))\r\nbreak;\r\n} while (!(st.status & (ST_IDLE | ST_HALT)));\r\nif (found <= search_limit) {\r\nmaster->search_id = 0;\r\n} else if (!test_bit(W1_WARN_MAX_COUNT, &master->flags)) {\r\ndev_info(&dev->udev->dev, "%s: max_slave_count %d reached, "\r\n"will continue next search.\n", __func__,\r\nmaster->max_slave_count);\r\nset_bit(W1_WARN_MAX_COUNT, &master->flags);\r\n}\r\nsearch_out:\r\nmutex_unlock(&master->bus_mutex);\r\nkfree(buf);\r\n}\r\nstatic u8 ds9490r_touch_bit(void *data, u8 bit)\r\n{\r\nstruct ds_device *dev = data;\r\nif (ds_touch_bit(dev, bit, &dev->byte_buf))\r\nreturn 0;\r\nreturn dev->byte_buf;\r\n}\r\nstatic void ds9490r_write_byte(void *data, u8 byte)\r\n{\r\nstruct ds_device *dev = data;\r\nds_write_byte(dev, byte);\r\n}\r\nstatic u8 ds9490r_read_byte(void *data)\r\n{\r\nstruct ds_device *dev = data;\r\nint err;\r\nerr = ds_read_byte(dev, &dev->byte_buf);\r\nif (err)\r\nreturn 0;\r\nreturn dev->byte_buf;\r\n}\r\nstatic void ds9490r_write_block(void *data, const u8 *buf, int len)\r\n{\r\nstruct ds_device *dev = data;\r\nu8 *tbuf;\r\nif (len <= 0)\r\nreturn;\r\ntbuf = kmemdup(buf, len, GFP_KERNEL);\r\nif (!tbuf)\r\nreturn;\r\nds_write_block(dev, tbuf, len);\r\nkfree(tbuf);\r\n}\r\nstatic u8 ds9490r_read_block(void *data, u8 *buf, int len)\r\n{\r\nstruct ds_device *dev = data;\r\nint err;\r\nu8 *tbuf;\r\nif (len <= 0)\r\nreturn 0;\r\ntbuf = kmalloc(len, GFP_KERNEL);\r\nif (!tbuf)\r\nreturn 0;\r\nerr = ds_read_block(dev, tbuf, len);\r\nif (err >= 0)\r\nmemcpy(buf, tbuf, len);\r\nkfree(tbuf);\r\nreturn err >= 0 ? len : 0;\r\n}\r\nstatic u8 ds9490r_reset(void *data)\r\n{\r\nstruct ds_device *dev = data;\r\nint err;\r\nerr = ds_reset(dev);\r\nif (err)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic u8 ds9490r_set_pullup(void *data, int delay)\r\n{\r\nstruct ds_device *dev = data;\r\nif (ds_set_pullup(dev, delay))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int ds_w1_init(struct ds_device *dev)\r\n{\r\nmemset(&dev->master, 0, sizeof(struct w1_bus_master));\r\nds_reset_device(dev);\r\ndev->master.data = dev;\r\ndev->master.touch_bit = &ds9490r_touch_bit;\r\ndev->master.read_byte = &ds9490r_read_byte;\r\ndev->master.write_byte = &ds9490r_write_byte;\r\ndev->master.read_block = &ds9490r_read_block;\r\ndev->master.write_block = &ds9490r_write_block;\r\ndev->master.reset_bus = &ds9490r_reset;\r\ndev->master.set_pullup = &ds9490r_set_pullup;\r\ndev->master.search = &ds9490r_search;\r\nreturn w1_add_master_device(&dev->master);\r\n}\r\nstatic void ds_w1_fini(struct ds_device *dev)\r\n{\r\nw1_remove_master_device(&dev->master);\r\n}\r\nstatic int ds_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *udev_id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct usb_endpoint_descriptor *endpoint;\r\nstruct usb_host_interface *iface_desc;\r\nstruct ds_device *dev;\r\nint i, err, alt;\r\ndev = kzalloc(sizeof(struct ds_device), GFP_KERNEL);\r\nif (!dev) {\r\npr_info("Failed to allocate new DS9490R structure.\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->udev = usb_get_dev(udev);\r\nif (!dev->udev) {\r\nerr = -ENOMEM;\r\ngoto err_out_free;\r\n}\r\nmemset(dev->ep, 0, sizeof(dev->ep));\r\nusb_set_intfdata(intf, dev);\r\nerr = usb_reset_configuration(dev->udev);\r\nif (err) {\r\ndev_err(&dev->udev->dev,\r\n"Failed to reset configuration: err=%d.\n", err);\r\ngoto err_out_clear;\r\n}\r\nalt = 3;\r\nerr = usb_set_interface(dev->udev,\r\nintf->altsetting[alt].desc.bInterfaceNumber, alt);\r\nif (err) {\r\ndev_err(&dev->udev->dev, "Failed to set alternative setting %d "\r\n"for %d interface: err=%d.\n", alt,\r\nintf->altsetting[alt].desc.bInterfaceNumber, err);\r\ngoto err_out_clear;\r\n}\r\niface_desc = &intf->altsetting[alt];\r\nif (iface_desc->desc.bNumEndpoints != NUM_EP-1) {\r\npr_info("Num endpoints=%d. It is not DS9490R.\n",\r\niface_desc->desc.bNumEndpoints);\r\nerr = -EINVAL;\r\ngoto err_out_clear;\r\n}\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\ndev->ep[i+1] = endpoint->bEndpointAddress;\r\n#if 0\r\nprintk("%d: addr=%x, size=%d, dir=%s, type=%x\n",\r\ni, endpoint->bEndpointAddress, le16_to_cpu(endpoint->wMaxPacketSize),\r\n(endpoint->bEndpointAddress & USB_DIR_IN)?"IN":"OUT",\r\nendpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK);\r\n#endif\r\n}\r\nerr = ds_w1_init(dev);\r\nif (err)\r\ngoto err_out_clear;\r\nmutex_lock(&ds_mutex);\r\nlist_add_tail(&dev->ds_entry, &ds_devices);\r\nmutex_unlock(&ds_mutex);\r\nreturn 0;\r\nerr_out_clear:\r\nusb_set_intfdata(intf, NULL);\r\nusb_put_dev(dev->udev);\r\nerr_out_free:\r\nkfree(dev);\r\nreturn err;\r\n}\r\nstatic void ds_disconnect(struct usb_interface *intf)\r\n{\r\nstruct ds_device *dev;\r\ndev = usb_get_intfdata(intf);\r\nif (!dev)\r\nreturn;\r\nmutex_lock(&ds_mutex);\r\nlist_del(&dev->ds_entry);\r\nmutex_unlock(&ds_mutex);\r\nds_w1_fini(dev);\r\nusb_set_intfdata(intf, NULL);\r\nusb_put_dev(dev->udev);\r\nkfree(dev);\r\n}
