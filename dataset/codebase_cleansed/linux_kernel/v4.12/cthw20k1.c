static int src_get_rsc_ctrl_blk(void **rblk)\r\n{\r\nstruct src_rsc_ctrl_blk *blk;\r\n*rblk = NULL;\r\nblk = kzalloc(sizeof(*blk), GFP_KERNEL);\r\nif (!blk)\r\nreturn -ENOMEM;\r\n*rblk = blk;\r\nreturn 0;\r\n}\r\nstatic int src_put_rsc_ctrl_blk(void *blk)\r\n{\r\nkfree((struct src_rsc_ctrl_blk *)blk);\r\nreturn 0;\r\n}\r\nstatic int src_set_state(void *blk, unsigned int state)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->ctl, SRCCTL_STATE, state);\r\nctl->dirty.bf.ctl = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_bm(void *blk, unsigned int bm)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->ctl, SRCCTL_BM, bm);\r\nctl->dirty.bf.ctl = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_rsr(void *blk, unsigned int rsr)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->ctl, SRCCTL_RSR, rsr);\r\nctl->dirty.bf.ctl = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_sf(void *blk, unsigned int sf)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->ctl, SRCCTL_SF, sf);\r\nctl->dirty.bf.ctl = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_wr(void *blk, unsigned int wr)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->ctl, SRCCTL_WR, wr);\r\nctl->dirty.bf.ctl = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_pm(void *blk, unsigned int pm)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->ctl, SRCCTL_PM, pm);\r\nctl->dirty.bf.ctl = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_rom(void *blk, unsigned int rom)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->ctl, SRCCTL_ROM, rom);\r\nctl->dirty.bf.ctl = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_vo(void *blk, unsigned int vo)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->ctl, SRCCTL_VO, vo);\r\nctl->dirty.bf.ctl = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_st(void *blk, unsigned int st)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->ctl, SRCCTL_ST, st);\r\nctl->dirty.bf.ctl = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_ie(void *blk, unsigned int ie)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->ctl, SRCCTL_IE, ie);\r\nctl->dirty.bf.ctl = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_ilsz(void *blk, unsigned int ilsz)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->ctl, SRCCTL_ILSZ, ilsz);\r\nctl->dirty.bf.ctl = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_bp(void *blk, unsigned int bp)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->ctl, SRCCTL_BP, bp);\r\nctl->dirty.bf.ctl = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_cisz(void *blk, unsigned int cisz)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->ccr, SRCCCR_CISZ, cisz);\r\nctl->dirty.bf.ccr = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_ca(void *blk, unsigned int ca)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->ca, SRCCA_CA, ca);\r\nctl->dirty.bf.ca = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_sa(void *blk, unsigned int sa)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->sa, SRCSA_SA, sa);\r\nctl->dirty.bf.sa = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_la(void *blk, unsigned int la)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->la, SRCLA_LA, la);\r\nctl->dirty.bf.la = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_pitch(void *blk, unsigned int pitch)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->mpr, MPRLH_PITCH, pitch);\r\nctl->dirty.bf.mpr = 1;\r\nreturn 0;\r\n}\r\nstatic int src_set_clear_zbufs(void *blk, unsigned int clear)\r\n{\r\n((struct src_rsc_ctrl_blk *)blk)->dirty.bf.czbfs = (clear ? 1 : 0);\r\nreturn 0;\r\n}\r\nstatic int src_set_dirty(void *blk, unsigned int flags)\r\n{\r\n((struct src_rsc_ctrl_blk *)blk)->dirty.data = (flags & 0xffff);\r\nreturn 0;\r\n}\r\nstatic int src_set_dirty_all(void *blk)\r\n{\r\n((struct src_rsc_ctrl_blk *)blk)->dirty.data = ~(0x0);\r\nreturn 0;\r\n}\r\nstatic unsigned int src_param_pitch_mixer(unsigned int src_idx)\r\n{\r\nreturn ((src_idx << 4) + AR_PTS_PITCH + AR_SLOT_SIZE\r\n- AR_PARAM_SRC_OFFSET) % AR_SLOT_SIZE;\r\n}\r\nstatic int src_commit_write(struct hw *hw, unsigned int idx, void *blk)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nint i;\r\nif (ctl->dirty.bf.czbfs) {\r\nfor (i = 0; i < 8; i++)\r\nhw_write_20kx(hw, SRCUPZ+idx*0x100+i*0x4, 0);\r\nfor (i = 0; i < 4; i++)\r\nhw_write_20kx(hw, SRCDN0Z+idx*0x100+i*0x4, 0);\r\nfor (i = 0; i < 8; i++)\r\nhw_write_20kx(hw, SRCDN1Z+idx*0x100+i*0x4, 0);\r\nctl->dirty.bf.czbfs = 0;\r\n}\r\nif (ctl->dirty.bf.mpr) {\r\nunsigned int pm_idx = src_param_pitch_mixer(idx);\r\nhw_write_20kx(hw, PRING_LO_HI+4*pm_idx, ctl->mpr);\r\nhw_write_20kx(hw, PMOPLO+8*pm_idx, 0x3);\r\nhw_write_20kx(hw, PMOPHI+8*pm_idx, 0x0);\r\nctl->dirty.bf.mpr = 0;\r\n}\r\nif (ctl->dirty.bf.sa) {\r\nhw_write_20kx(hw, SRCSA+idx*0x100, ctl->sa);\r\nctl->dirty.bf.sa = 0;\r\n}\r\nif (ctl->dirty.bf.la) {\r\nhw_write_20kx(hw, SRCLA+idx*0x100, ctl->la);\r\nctl->dirty.bf.la = 0;\r\n}\r\nif (ctl->dirty.bf.ca) {\r\nhw_write_20kx(hw, SRCCA+idx*0x100, ctl->ca);\r\nctl->dirty.bf.ca = 0;\r\n}\r\nhw_write_20kx(hw, SRCCF+idx*0x100, 0x0);\r\nif (ctl->dirty.bf.ccr) {\r\nhw_write_20kx(hw, SRCCCR+idx*0x100, ctl->ccr);\r\nctl->dirty.bf.ccr = 0;\r\n}\r\nif (ctl->dirty.bf.ctl) {\r\nhw_write_20kx(hw, SRCCTL+idx*0x100, ctl->ctl);\r\nctl->dirty.bf.ctl = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int src_get_ca(struct hw *hw, unsigned int idx, void *blk)\r\n{\r\nstruct src_rsc_ctrl_blk *ctl = blk;\r\nctl->ca = hw_read_20kx(hw, SRCCA+idx*0x100);\r\nctl->dirty.bf.ca = 0;\r\nreturn get_field(ctl->ca, SRCCA_CA);\r\n}\r\nstatic unsigned int src_get_dirty(void *blk)\r\n{\r\nreturn ((struct src_rsc_ctrl_blk *)blk)->dirty.data;\r\n}\r\nstatic unsigned int src_dirty_conj_mask(void)\r\n{\r\nreturn 0x20;\r\n}\r\nstatic int src_mgr_enbs_src(void *blk, unsigned int idx)\r\n{\r\n((struct src_mgr_ctrl_blk *)blk)->enbsa = ~(0x0);\r\n((struct src_mgr_ctrl_blk *)blk)->dirty.bf.enbsa = 1;\r\n((struct src_mgr_ctrl_blk *)blk)->enb[idx/32] |= (0x1 << (idx%32));\r\nreturn 0;\r\n}\r\nstatic int src_mgr_enb_src(void *blk, unsigned int idx)\r\n{\r\n((struct src_mgr_ctrl_blk *)blk)->enb[idx/32] |= (0x1 << (idx%32));\r\n((struct src_mgr_ctrl_blk *)blk)->dirty.data |= (0x1 << (idx/32));\r\nreturn 0;\r\n}\r\nstatic int src_mgr_dsb_src(void *blk, unsigned int idx)\r\n{\r\n((struct src_mgr_ctrl_blk *)blk)->enb[idx/32] &= ~(0x1 << (idx%32));\r\n((struct src_mgr_ctrl_blk *)blk)->dirty.data |= (0x1 << (idx/32));\r\nreturn 0;\r\n}\r\nstatic int src_mgr_commit_write(struct hw *hw, void *blk)\r\n{\r\nstruct src_mgr_ctrl_blk *ctl = blk;\r\nint i;\r\nunsigned int ret;\r\nif (ctl->dirty.bf.enbsa) {\r\ndo {\r\nret = hw_read_20kx(hw, SRCENBSTAT);\r\n} while (ret & 0x1);\r\nhw_write_20kx(hw, SRCENBS, ctl->enbsa);\r\nctl->dirty.bf.enbsa = 0;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\nif ((ctl->dirty.data & (0x1 << i))) {\r\nhw_write_20kx(hw, SRCENB+(i*0x100), ctl->enb[i]);\r\nctl->dirty.data &= ~(0x1 << i);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int src_mgr_get_ctrl_blk(void **rblk)\r\n{\r\nstruct src_mgr_ctrl_blk *blk;\r\n*rblk = NULL;\r\nblk = kzalloc(sizeof(*blk), GFP_KERNEL);\r\nif (!blk)\r\nreturn -ENOMEM;\r\n*rblk = blk;\r\nreturn 0;\r\n}\r\nstatic int src_mgr_put_ctrl_blk(void *blk)\r\n{\r\nkfree((struct src_mgr_ctrl_blk *)blk);\r\nreturn 0;\r\n}\r\nstatic int srcimp_mgr_get_ctrl_blk(void **rblk)\r\n{\r\nstruct srcimp_mgr_ctrl_blk *blk;\r\n*rblk = NULL;\r\nblk = kzalloc(sizeof(*blk), GFP_KERNEL);\r\nif (!blk)\r\nreturn -ENOMEM;\r\n*rblk = blk;\r\nreturn 0;\r\n}\r\nstatic int srcimp_mgr_put_ctrl_blk(void *blk)\r\n{\r\nkfree((struct srcimp_mgr_ctrl_blk *)blk);\r\nreturn 0;\r\n}\r\nstatic int srcimp_mgr_set_imaparc(void *blk, unsigned int slot)\r\n{\r\nstruct srcimp_mgr_ctrl_blk *ctl = blk;\r\nset_field(&ctl->srcimap.srcaim, SRCAIM_ARC, slot);\r\nctl->dirty.bf.srcimap = 1;\r\nreturn 0;\r\n}\r\nstatic int srcimp_mgr_set_imapuser(void *blk, unsigned int user)\r\n{\r\nstruct srcimp_mgr_ctrl_blk *ctl = blk;\r\nset_field(&ctl->srcimap.srcaim, SRCAIM_SRC, user);\r\nctl->dirty.bf.srcimap = 1;\r\nreturn 0;\r\n}\r\nstatic int srcimp_mgr_set_imapnxt(void *blk, unsigned int next)\r\n{\r\nstruct srcimp_mgr_ctrl_blk *ctl = blk;\r\nset_field(&ctl->srcimap.srcaim, SRCAIM_NXT, next);\r\nctl->dirty.bf.srcimap = 1;\r\nreturn 0;\r\n}\r\nstatic int srcimp_mgr_set_imapaddr(void *blk, unsigned int addr)\r\n{\r\nstruct srcimp_mgr_ctrl_blk *ctl = blk;\r\nctl->srcimap.idx = addr;\r\nctl->dirty.bf.srcimap = 1;\r\nreturn 0;\r\n}\r\nstatic int srcimp_mgr_commit_write(struct hw *hw, void *blk)\r\n{\r\nstruct srcimp_mgr_ctrl_blk *ctl = blk;\r\nif (ctl->dirty.bf.srcimap) {\r\nhw_write_20kx(hw, SRCIMAP+ctl->srcimap.idx*0x100,\r\nctl->srcimap.srcaim);\r\nctl->dirty.bf.srcimap = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int amixer_set_mode(void *blk, unsigned int mode)\r\n{\r\nstruct amixer_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->amoplo, AMOPLO_M, mode);\r\nctl->dirty.bf.amoplo = 1;\r\nreturn 0;\r\n}\r\nstatic int amixer_set_iv(void *blk, unsigned int iv)\r\n{\r\nreturn 0;\r\n}\r\nstatic int amixer_set_x(void *blk, unsigned int x)\r\n{\r\nstruct amixer_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->amoplo, AMOPLO_X, x);\r\nctl->dirty.bf.amoplo = 1;\r\nreturn 0;\r\n}\r\nstatic int amixer_set_y(void *blk, unsigned int y)\r\n{\r\nstruct amixer_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->amoplo, AMOPLO_Y, y);\r\nctl->dirty.bf.amoplo = 1;\r\nreturn 0;\r\n}\r\nstatic int amixer_set_sadr(void *blk, unsigned int sadr)\r\n{\r\nstruct amixer_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->amophi, AMOPHI_SADR, sadr);\r\nctl->dirty.bf.amophi = 1;\r\nreturn 0;\r\n}\r\nstatic int amixer_set_se(void *blk, unsigned int se)\r\n{\r\nstruct amixer_rsc_ctrl_blk *ctl = blk;\r\nset_field(&ctl->amophi, AMOPHI_SE, se);\r\nctl->dirty.bf.amophi = 1;\r\nreturn 0;\r\n}\r\nstatic int amixer_set_dirty(void *blk, unsigned int flags)\r\n{\r\n((struct amixer_rsc_ctrl_blk *)blk)->dirty.data = (flags & 0xffff);\r\nreturn 0;\r\n}\r\nstatic int amixer_set_dirty_all(void *blk)\r\n{\r\n((struct amixer_rsc_ctrl_blk *)blk)->dirty.data = ~(0x0);\r\nreturn 0;\r\n}\r\nstatic int amixer_commit_write(struct hw *hw, unsigned int idx, void *blk)\r\n{\r\nstruct amixer_rsc_ctrl_blk *ctl = blk;\r\nif (ctl->dirty.bf.amoplo || ctl->dirty.bf.amophi) {\r\nhw_write_20kx(hw, AMOPLO+idx*8, ctl->amoplo);\r\nctl->dirty.bf.amoplo = 0;\r\nhw_write_20kx(hw, AMOPHI+idx*8, ctl->amophi);\r\nctl->dirty.bf.amophi = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int amixer_get_y(void *blk)\r\n{\r\nstruct amixer_rsc_ctrl_blk *ctl = blk;\r\nreturn get_field(ctl->amoplo, AMOPLO_Y);\r\n}\r\nstatic unsigned int amixer_get_dirty(void *blk)\r\n{\r\nreturn ((struct amixer_rsc_ctrl_blk *)blk)->dirty.data;\r\n}\r\nstatic int amixer_rsc_get_ctrl_blk(void **rblk)\r\n{\r\nstruct amixer_rsc_ctrl_blk *blk;\r\n*rblk = NULL;\r\nblk = kzalloc(sizeof(*blk), GFP_KERNEL);\r\nif (!blk)\r\nreturn -ENOMEM;\r\n*rblk = blk;\r\nreturn 0;\r\n}\r\nstatic int amixer_rsc_put_ctrl_blk(void *blk)\r\n{\r\nkfree((struct amixer_rsc_ctrl_blk *)blk);\r\nreturn 0;\r\n}\r\nstatic int amixer_mgr_get_ctrl_blk(void **rblk)\r\n{\r\n*rblk = NULL;\r\nreturn 0;\r\n}\r\nstatic int amixer_mgr_put_ctrl_blk(void *blk)\r\n{\r\nreturn 0;\r\n}\r\nstatic int dai_srt_set_srcr(void *blk, unsigned int src)\r\n{\r\nstruct dai_ctrl_blk *ctl = blk;\r\nset_field(&ctl->srtctl, SRTCTL_SRCR, src);\r\nctl->dirty.bf.srtctl = 1;\r\nreturn 0;\r\n}\r\nstatic int dai_srt_set_srcl(void *blk, unsigned int src)\r\n{\r\nstruct dai_ctrl_blk *ctl = blk;\r\nset_field(&ctl->srtctl, SRTCTL_SRCL, src);\r\nctl->dirty.bf.srtctl = 1;\r\nreturn 0;\r\n}\r\nstatic int dai_srt_set_rsr(void *blk, unsigned int rsr)\r\n{\r\nstruct dai_ctrl_blk *ctl = blk;\r\nset_field(&ctl->srtctl, SRTCTL_RSR, rsr);\r\nctl->dirty.bf.srtctl = 1;\r\nreturn 0;\r\n}\r\nstatic int dai_srt_set_drat(void *blk, unsigned int drat)\r\n{\r\nstruct dai_ctrl_blk *ctl = blk;\r\nset_field(&ctl->srtctl, SRTCTL_DRAT, drat);\r\nctl->dirty.bf.srtctl = 1;\r\nreturn 0;\r\n}\r\nstatic int dai_srt_set_ec(void *blk, unsigned int ec)\r\n{\r\nstruct dai_ctrl_blk *ctl = blk;\r\nset_field(&ctl->srtctl, SRTCTL_EC, ec ? 1 : 0);\r\nctl->dirty.bf.srtctl = 1;\r\nreturn 0;\r\n}\r\nstatic int dai_srt_set_et(void *blk, unsigned int et)\r\n{\r\nstruct dai_ctrl_blk *ctl = blk;\r\nset_field(&ctl->srtctl, SRTCTL_ET, et ? 1 : 0);\r\nctl->dirty.bf.srtctl = 1;\r\nreturn 0;\r\n}\r\nstatic int dai_commit_write(struct hw *hw, unsigned int idx, void *blk)\r\n{\r\nstruct dai_ctrl_blk *ctl = blk;\r\nif (ctl->dirty.bf.srtctl) {\r\nif (idx < 4) {\r\nhw_write_20kx(hw, SRTSCTL+0x4*idx, ctl->srtctl);\r\n} else {\r\nhw_write_20kx(hw, SRTICTL, ctl->srtctl);\r\n}\r\nctl->dirty.bf.srtctl = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dai_get_ctrl_blk(void **rblk)\r\n{\r\nstruct dai_ctrl_blk *blk;\r\n*rblk = NULL;\r\nblk = kzalloc(sizeof(*blk), GFP_KERNEL);\r\nif (!blk)\r\nreturn -ENOMEM;\r\n*rblk = blk;\r\nreturn 0;\r\n}\r\nstatic int dai_put_ctrl_blk(void *blk)\r\n{\r\nkfree((struct dai_ctrl_blk *)blk);\r\nreturn 0;\r\n}\r\nstatic int dao_set_spos(void *blk, unsigned int spos)\r\n{\r\n((struct dao_ctrl_blk *)blk)->spos = spos;\r\n((struct dao_ctrl_blk *)blk)->dirty.bf.spos = 1;\r\nreturn 0;\r\n}\r\nstatic int dao_commit_write(struct hw *hw, unsigned int idx, void *blk)\r\n{\r\nstruct dao_ctrl_blk *ctl = blk;\r\nif (ctl->dirty.bf.spos) {\r\nif (idx < 4) {\r\nhw_write_20kx(hw, SPOS+0x4*idx, ctl->spos);\r\n}\r\nctl->dirty.bf.spos = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dao_get_spos(void *blk, unsigned int *spos)\r\n{\r\n*spos = ((struct dao_ctrl_blk *)blk)->spos;\r\nreturn 0;\r\n}\r\nstatic int dao_get_ctrl_blk(void **rblk)\r\n{\r\nstruct dao_ctrl_blk *blk;\r\n*rblk = NULL;\r\nblk = kzalloc(sizeof(*blk), GFP_KERNEL);\r\nif (!blk)\r\nreturn -ENOMEM;\r\n*rblk = blk;\r\nreturn 0;\r\n}\r\nstatic int dao_put_ctrl_blk(void *blk)\r\n{\r\nkfree((struct dao_ctrl_blk *)blk);\r\nreturn 0;\r\n}\r\nstatic int daio_mgr_enb_dai(void *blk, unsigned int idx)\r\n{\r\nstruct daio_mgr_ctrl_blk *ctl = blk;\r\nif (idx < 4) {\r\nset_field(&ctl->spictl, SPICTL_EN << (idx*8), 1);\r\nctl->dirty.bf.spictl |= (0x1 << idx);\r\n} else {\r\nidx %= 4;\r\nset_field(&ctl->i2sctl, I2SCTL_EI << (idx*8), 1);\r\nctl->dirty.bf.i2sictl |= (0x1 << idx);\r\n}\r\nreturn 0;\r\n}\r\nstatic int daio_mgr_dsb_dai(void *blk, unsigned int idx)\r\n{\r\nstruct daio_mgr_ctrl_blk *ctl = blk;\r\nif (idx < 4) {\r\nset_field(&ctl->spictl, SPICTL_EN << (idx*8), 0);\r\nctl->dirty.bf.spictl |= (0x1 << idx);\r\n} else {\r\nidx %= 4;\r\nset_field(&ctl->i2sctl, I2SCTL_EI << (idx*8), 0);\r\nctl->dirty.bf.i2sictl |= (0x1 << idx);\r\n}\r\nreturn 0;\r\n}\r\nstatic int daio_mgr_enb_dao(void *blk, unsigned int idx)\r\n{\r\nstruct daio_mgr_ctrl_blk *ctl = blk;\r\nif (idx < 4) {\r\nset_field(&ctl->spoctl, SPOCTL_OE << (idx*8), 1);\r\nctl->dirty.bf.spoctl |= (0x1 << idx);\r\n} else {\r\nidx %= 4;\r\nset_field(&ctl->i2sctl, I2SCTL_EA << (idx*8), 1);\r\nctl->dirty.bf.i2soctl |= (0x1 << idx);\r\n}\r\nreturn 0;\r\n}\r\nstatic int daio_mgr_dsb_dao(void *blk, unsigned int idx)\r\n{\r\nstruct daio_mgr_ctrl_blk *ctl = blk;\r\nif (idx < 4) {\r\nset_field(&ctl->spoctl, SPOCTL_OE << (idx*8), 0);\r\nctl->dirty.bf.spoctl |= (0x1 << idx);\r\n} else {\r\nidx %= 4;\r\nset_field(&ctl->i2sctl, I2SCTL_EA << (idx*8), 0);\r\nctl->dirty.bf.i2soctl |= (0x1 << idx);\r\n}\r\nreturn 0;\r\n}\r\nstatic int daio_mgr_dao_init(void *blk, unsigned int idx, unsigned int conf)\r\n{\r\nstruct daio_mgr_ctrl_blk *ctl = blk;\r\nif (idx < 4) {\r\nswitch ((conf & 0x7)) {\r\ncase 0:\r\nset_field(&ctl->spoctl, SPOCTL_SR << (idx*8), 3);\r\nbreak;\r\ncase 1:\r\nset_field(&ctl->spoctl, SPOCTL_SR << (idx*8), 0);\r\nbreak;\r\ncase 2:\r\nset_field(&ctl->spoctl, SPOCTL_SR << (idx*8), 1);\r\nbreak;\r\ncase 4:\r\nset_field(&ctl->spoctl, SPOCTL_SR << (idx*8), 2);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nset_field(&ctl->spoctl, SPOCTL_LIV << (idx*8),\r\n(conf >> 4) & 0x1);\r\nset_field(&ctl->spoctl, SPOCTL_RIV << (idx*8),\r\n(conf >> 4) & 0x1);\r\nset_field(&ctl->spoctl, SPOCTL_OS << (idx*8),\r\n((conf >> 3) & 0x1) ? 2 : 2);\r\nctl->dirty.bf.spoctl |= (0x1 << idx);\r\n} else {\r\n}\r\nreturn 0;\r\n}\r\nstatic int daio_mgr_set_imaparc(void *blk, unsigned int slot)\r\n{\r\nstruct daio_mgr_ctrl_blk *ctl = blk;\r\nset_field(&ctl->daoimap.aim, AIM_ARC, slot);\r\nctl->dirty.bf.daoimap = 1;\r\nreturn 0;\r\n}\r\nstatic int daio_mgr_set_imapnxt(void *blk, unsigned int next)\r\n{\r\nstruct daio_mgr_ctrl_blk *ctl = blk;\r\nset_field(&ctl->daoimap.aim, AIM_NXT, next);\r\nctl->dirty.bf.daoimap = 1;\r\nreturn 0;\r\n}\r\nstatic int daio_mgr_set_imapaddr(void *blk, unsigned int addr)\r\n{\r\nstruct daio_mgr_ctrl_blk *ctl = blk;\r\nctl->daoimap.idx = addr;\r\nctl->dirty.bf.daoimap = 1;\r\nreturn 0;\r\n}\r\nstatic int daio_mgr_commit_write(struct hw *hw, void *blk)\r\n{\r\nstruct daio_mgr_ctrl_blk *ctl = blk;\r\nint i;\r\nif (ctl->dirty.bf.i2sictl || ctl->dirty.bf.i2soctl) {\r\nfor (i = 0; i < 4; i++) {\r\nif ((ctl->dirty.bf.i2sictl & (0x1 << i)))\r\nctl->dirty.bf.i2sictl &= ~(0x1 << i);\r\nif ((ctl->dirty.bf.i2soctl & (0x1 << i)))\r\nctl->dirty.bf.i2soctl &= ~(0x1 << i);\r\n}\r\nhw_write_20kx(hw, I2SCTL, ctl->i2sctl);\r\nmdelay(1);\r\n}\r\nif (ctl->dirty.bf.spoctl) {\r\nfor (i = 0; i < 4; i++) {\r\nif ((ctl->dirty.bf.spoctl & (0x1 << i)))\r\nctl->dirty.bf.spoctl &= ~(0x1 << i);\r\n}\r\nhw_write_20kx(hw, SPOCTL, ctl->spoctl);\r\nmdelay(1);\r\n}\r\nif (ctl->dirty.bf.spictl) {\r\nfor (i = 0; i < 4; i++) {\r\nif ((ctl->dirty.bf.spictl & (0x1 << i)))\r\nctl->dirty.bf.spictl &= ~(0x1 << i);\r\n}\r\nhw_write_20kx(hw, SPICTL, ctl->spictl);\r\nmdelay(1);\r\n}\r\nif (ctl->dirty.bf.daoimap) {\r\nhw_write_20kx(hw, DAOIMAP+ctl->daoimap.idx*4,\r\nctl->daoimap.aim);\r\nctl->dirty.bf.daoimap = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int daio_mgr_get_ctrl_blk(struct hw *hw, void **rblk)\r\n{\r\nstruct daio_mgr_ctrl_blk *blk;\r\n*rblk = NULL;\r\nblk = kzalloc(sizeof(*blk), GFP_KERNEL);\r\nif (!blk)\r\nreturn -ENOMEM;\r\nblk->i2sctl = hw_read_20kx(hw, I2SCTL);\r\nblk->spoctl = hw_read_20kx(hw, SPOCTL);\r\nblk->spictl = hw_read_20kx(hw, SPICTL);\r\n*rblk = blk;\r\nreturn 0;\r\n}\r\nstatic int daio_mgr_put_ctrl_blk(void *blk)\r\n{\r\nkfree((struct daio_mgr_ctrl_blk *)blk);\r\nreturn 0;\r\n}\r\nstatic int set_timer_irq(struct hw *hw, int enable)\r\n{\r\nhw_write_20kx(hw, GIE, enable ? IT_INT : 0);\r\nreturn 0;\r\n}\r\nstatic int set_timer_tick(struct hw *hw, unsigned int ticks)\r\n{\r\nif (ticks)\r\nticks |= TIMR_IE | TIMR_IP;\r\nhw_write_20kx(hw, TIMR, ticks);\r\nreturn 0;\r\n}\r\nstatic unsigned int get_wc(struct hw *hw)\r\n{\r\nreturn hw_read_20kx(hw, WC);\r\n}\r\nstatic int hw_daio_init(struct hw *hw, const struct daio_conf *info)\r\n{\r\nu32 i2sorg;\r\nu32 spdorg;\r\ni2sorg = 0x94040404;\r\ni2sorg &= 0xfffffffc;\r\nhw_write_20kx(hw, SPOCTL, 0x0);\r\nspdorg = 0x05;\r\nswitch (info->msr) {\r\ncase 1:\r\ni2sorg |= 1;\r\nspdorg |= (0x0 << 6);\r\nbreak;\r\ncase 2:\r\ni2sorg |= 2;\r\nspdorg |= (0x1 << 6);\r\nbreak;\r\ncase 4:\r\ni2sorg |= 3;\r\nspdorg |= (0x2 << 6);\r\nbreak;\r\ndefault:\r\ni2sorg |= 1;\r\nbreak;\r\n}\r\nhw_write_20kx(hw, I2SCTL, i2sorg);\r\nhw_write_20kx(hw, SPOCTL, spdorg);\r\nhw_write_20kx(hw, SPICTL, 0x0);\r\nmdelay(1);\r\nspdorg = 0x0a0a0a0a;\r\nhw_write_20kx(hw, SPICTL, spdorg);\r\nmdelay(1);\r\nreturn 0;\r\n}\r\nstatic int hw_trn_init(struct hw *hw, const struct trn_conf *info)\r\n{\r\nu32 trnctl;\r\nu32 ptp_phys_low, ptp_phys_high;\r\nif ((~0UL) == info->vm_pgt_phys) {\r\ndev_err(hw->card->dev,\r\n"Wrong device page table page address!\n");\r\nreturn -1;\r\n}\r\ntrnctl = 0x13;\r\nptp_phys_low = (u32)info->vm_pgt_phys;\r\nptp_phys_high = upper_32_bits(info->vm_pgt_phys);\r\nif (sizeof(void *) == 8)\r\ntrnctl |= (1 << 2);\r\n#if 0\r\n#if PAGE_SIZE == 8192\r\ntrnctl |= (1<<5);\r\n#endif\r\n#endif\r\nhw_write_20kx(hw, PTPALX, ptp_phys_low);\r\nhw_write_20kx(hw, PTPAHX, ptp_phys_high);\r\nhw_write_20kx(hw, TRNCTL, trnctl);\r\nhw_write_20kx(hw, TRNIS, 0x200c01);\r\nreturn 0;\r\n}\r\nstatic int hw_pll_init(struct hw *hw, unsigned int rsr)\r\n{\r\nunsigned int pllctl;\r\nint i;\r\npllctl = (48000 == rsr) ? 0x1480a001 : 0x1480a731;\r\nfor (i = 0; i < 3; i++) {\r\nif (hw_read_20kx(hw, PLLCTL) == pllctl)\r\nbreak;\r\nhw_write_20kx(hw, PLLCTL, pllctl);\r\nmdelay(40);\r\n}\r\nif (i >= 3) {\r\ndev_alert(hw->card->dev, "PLL initialization failed!!!\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hw_auto_init(struct hw *hw)\r\n{\r\nunsigned int gctl;\r\nint i;\r\ngctl = hw_read_20kx(hw, GCTL);\r\nset_field(&gctl, GCTL_EAI, 0);\r\nhw_write_20kx(hw, GCTL, gctl);\r\nset_field(&gctl, GCTL_EAI, 1);\r\nhw_write_20kx(hw, GCTL, gctl);\r\nmdelay(10);\r\nfor (i = 0; i < 400000; i++) {\r\ngctl = hw_read_20kx(hw, GCTL);\r\nif (get_field(gctl, GCTL_AID))\r\nbreak;\r\n}\r\nif (!get_field(gctl, GCTL_AID)) {\r\ndev_alert(hw->card->dev, "Card Auto-init failed!!!\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2c_unlock(struct hw *hw)\r\n{\r\nif ((hw_read_pci(hw, 0xcc) & 0xff) == 0xaa)\r\nreturn 0;\r\nhw_write_pci(hw, 0xcc, 0x8c);\r\nhw_write_pci(hw, 0xcc, 0x0e);\r\nif ((hw_read_pci(hw, 0xcc) & 0xff) == 0xaa)\r\nreturn 0;\r\nhw_write_pci(hw, 0xcc, 0xee);\r\nhw_write_pci(hw, 0xcc, 0xaa);\r\nif ((hw_read_pci(hw, 0xcc) & 0xff) == 0xaa)\r\nreturn 0;\r\nreturn -1;\r\n}\r\nstatic void i2c_lock(struct hw *hw)\r\n{\r\nif ((hw_read_pci(hw, 0xcc) & 0xff) == 0xaa)\r\nhw_write_pci(hw, 0xcc, 0x00);\r\n}\r\nstatic void i2c_write(struct hw *hw, u32 device, u32 addr, u32 data)\r\n{\r\nunsigned int ret;\r\ndo {\r\nret = hw_read_pci(hw, 0xEC);\r\n} while (!(ret & 0x800000));\r\nhw_write_pci(hw, 0xE0, device);\r\nhw_write_pci(hw, 0xE4, (data << 8) | (addr & 0xff));\r\n}\r\nstatic int hw_reset_dac(struct hw *hw)\r\n{\r\nu32 i;\r\nu16 gpioorg;\r\nunsigned int ret;\r\nif (i2c_unlock(hw))\r\nreturn -1;\r\ndo {\r\nret = hw_read_pci(hw, 0xEC);\r\n} while (!(ret & 0x800000));\r\nhw_write_pci(hw, 0xEC, 0x05);\r\nfor (i = 0; i < 2; i++) {\r\nmdelay(100);\r\ngpioorg = (u16)hw_read_20kx(hw, GPIO);\r\ngpioorg &= 0xfffd;\r\nhw_write_20kx(hw, GPIO, gpioorg);\r\nmdelay(1);\r\nhw_write_20kx(hw, GPIO, gpioorg | 0x2);\r\n}\r\ni2c_write(hw, 0x00180080, 0x01, 0x80);\r\ni2c_write(hw, 0x00180080, 0x02, 0x10);\r\ni2c_lock(hw);\r\nreturn 0;\r\n}\r\nstatic int hw_dac_init(struct hw *hw, const struct dac_conf *info)\r\n{\r\nu32 data;\r\nu16 gpioorg;\r\nunsigned int ret;\r\nif (hw->model == CTSB055X) {\r\ngpioorg = (u16)hw_read_20kx(hw, GPIO);\r\ngpioorg &= 0xffbf;\r\ngpioorg |= 2;\r\nhw_write_20kx(hw, GPIO, gpioorg);\r\nreturn 0;\r\n}\r\ngpioorg = (u16)hw_read_20kx(hw, GPIO);\r\ngpioorg &= 0xffbf;\r\nhw_write_20kx(hw, GPIO, gpioorg);\r\nhw_reset_dac(hw);\r\nif (i2c_unlock(hw))\r\nreturn -1;\r\nhw_write_pci(hw, 0xEC, 0x05);\r\ndo {\r\nret = hw_read_pci(hw, 0xEC);\r\n} while (!(ret & 0x800000));\r\nswitch (info->msr) {\r\ncase 1:\r\ndata = 0x24;\r\nbreak;\r\ncase 2:\r\ndata = 0x25;\r\nbreak;\r\ncase 4:\r\ndata = 0x26;\r\nbreak;\r\ndefault:\r\ndata = 0x24;\r\nbreak;\r\n}\r\ni2c_write(hw, 0x00180080, 0x06, data);\r\ni2c_write(hw, 0x00180080, 0x09, data);\r\ni2c_write(hw, 0x00180080, 0x0c, data);\r\ni2c_write(hw, 0x00180080, 0x0f, data);\r\ni2c_lock(hw);\r\ngpioorg = (u16)hw_read_20kx(hw, GPIO);\r\ngpioorg = gpioorg | 0x40;\r\nhw_write_20kx(hw, GPIO, gpioorg);\r\nreturn 0;\r\n}\r\nstatic int is_adc_input_selected_SB055x(struct hw *hw, enum ADCSRC type)\r\n{\r\nreturn 0;\r\n}\r\nstatic int is_adc_input_selected_SBx(struct hw *hw, enum ADCSRC type)\r\n{\r\nu32 data;\r\ndata = hw_read_20kx(hw, GPIO);\r\nswitch (type) {\r\ncase ADC_MICIN:\r\ndata = ((data & (0x1<<7)) && (data & (0x1<<8)));\r\nbreak;\r\ncase ADC_LINEIN:\r\ndata = (!(data & (0x1<<7)) && (data & (0x1<<8)));\r\nbreak;\r\ncase ADC_NONE:\r\ndata = (!(data & (0x1<<8)));\r\nbreak;\r\ndefault:\r\ndata = 0;\r\n}\r\nreturn data;\r\n}\r\nstatic int is_adc_input_selected_hendrix(struct hw *hw, enum ADCSRC type)\r\n{\r\nu32 data;\r\ndata = hw_read_20kx(hw, GPIO);\r\nswitch (type) {\r\ncase ADC_MICIN:\r\ndata = (data & (0x1 << 7)) ? 1 : 0;\r\nbreak;\r\ncase ADC_LINEIN:\r\ndata = (data & (0x1 << 7)) ? 0 : 1;\r\nbreak;\r\ndefault:\r\ndata = 0;\r\n}\r\nreturn data;\r\n}\r\nstatic int hw_is_adc_input_selected(struct hw *hw, enum ADCSRC type)\r\n{\r\nswitch (hw->model) {\r\ncase CTSB055X:\r\nreturn is_adc_input_selected_SB055x(hw, type);\r\ncase CTSB073X:\r\nreturn is_adc_input_selected_hendrix(hw, type);\r\ncase CTUAA:\r\nreturn is_adc_input_selected_hendrix(hw, type);\r\ndefault:\r\nreturn is_adc_input_selected_SBx(hw, type);\r\n}\r\n}\r\nstatic int\r\nadc_input_select_SB055x(struct hw *hw, enum ADCSRC type, unsigned char boost)\r\n{\r\nu32 data;\r\ndata = hw_read_20kx(hw, GPIO);\r\ndata &= 0xec73;\r\nswitch (type) {\r\ncase ADC_MICIN:\r\ndata |= (0x1<<7) | (0x1<<8) | (0x1<<9) ;\r\ndata |= boost ? (0x1<<2) : 0;\r\nbreak;\r\ncase ADC_LINEIN:\r\ndata |= (0x1<<8);\r\nbreak;\r\ncase ADC_AUX:\r\ndata |= (0x1<<8) | (0x1<<12);\r\nbreak;\r\ncase ADC_NONE:\r\ndata |= (0x1<<12);\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nhw_write_20kx(hw, GPIO, data);\r\nreturn 0;\r\n}\r\nstatic int\r\nadc_input_select_SBx(struct hw *hw, enum ADCSRC type, unsigned char boost)\r\n{\r\nu32 data;\r\nu32 i2c_data;\r\nunsigned int ret;\r\nif (i2c_unlock(hw))\r\nreturn -1;\r\ndo {\r\nret = hw_read_pci(hw, 0xEC);\r\n} while (!(ret & 0x800000));\r\nhw_write_pci(hw, 0xEC, 0x05);\r\ndata = hw_read_20kx(hw, GPIO);\r\nswitch (type) {\r\ncase ADC_MICIN:\r\ndata |= ((0x1 << 7) | (0x1 << 8));\r\ni2c_data = 0x1;\r\nbreak;\r\ncase ADC_LINEIN:\r\ndata &= ~(0x1 << 7);\r\ndata |= (0x1 << 8);\r\ni2c_data = 0x2;\r\nbreak;\r\ncase ADC_NONE:\r\ndata &= ~(0x1 << 8);\r\ni2c_data = 0x0;\r\nbreak;\r\ndefault:\r\ni2c_lock(hw);\r\nreturn -1;\r\n}\r\nhw_write_20kx(hw, GPIO, data);\r\ni2c_write(hw, 0x001a0080, 0x2a, i2c_data);\r\nif (boost) {\r\ni2c_write(hw, 0x001a0080, 0x1c, 0xe7);\r\ni2c_write(hw, 0x001a0080, 0x1e, 0xe7);\r\n} else {\r\ni2c_write(hw, 0x001a0080, 0x1c, 0xcf);\r\ni2c_write(hw, 0x001a0080, 0x1e, 0xcf);\r\n}\r\ni2c_lock(hw);\r\nreturn 0;\r\n}\r\nstatic int\r\nadc_input_select_hendrix(struct hw *hw, enum ADCSRC type, unsigned char boost)\r\n{\r\nu32 data;\r\nu32 i2c_data;\r\nunsigned int ret;\r\nif (i2c_unlock(hw))\r\nreturn -1;\r\ndo {\r\nret = hw_read_pci(hw, 0xEC);\r\n} while (!(ret & 0x800000));\r\nhw_write_pci(hw, 0xEC, 0x05);\r\ndata = hw_read_20kx(hw, GPIO);\r\nswitch (type) {\r\ncase ADC_MICIN:\r\ndata |= (0x1 << 7);\r\ni2c_data = 0x1;\r\nbreak;\r\ncase ADC_LINEIN:\r\ndata &= ~(0x1 << 7);\r\ni2c_data = 0x2;\r\nbreak;\r\ndefault:\r\ni2c_lock(hw);\r\nreturn -1;\r\n}\r\nhw_write_20kx(hw, GPIO, data);\r\ni2c_write(hw, 0x001a0080, 0x2a, i2c_data);\r\nif (boost) {\r\ni2c_write(hw, 0x001a0080, 0x1c, 0xe7);\r\ni2c_write(hw, 0x001a0080, 0x1e, 0xe7);\r\n} else {\r\ni2c_write(hw, 0x001a0080, 0x1c, 0xcf);\r\ni2c_write(hw, 0x001a0080, 0x1e, 0xcf);\r\n}\r\ni2c_lock(hw);\r\nreturn 0;\r\n}\r\nstatic int hw_adc_input_select(struct hw *hw, enum ADCSRC type)\r\n{\r\nint state = type == ADC_MICIN;\r\nswitch (hw->model) {\r\ncase CTSB055X:\r\nreturn adc_input_select_SB055x(hw, type, state);\r\ncase CTSB073X:\r\nreturn adc_input_select_hendrix(hw, type, state);\r\ncase CTUAA:\r\nreturn adc_input_select_hendrix(hw, type, state);\r\ndefault:\r\nreturn adc_input_select_SBx(hw, type, state);\r\n}\r\n}\r\nstatic int adc_init_SB055x(struct hw *hw, int input, int mic20db)\r\n{\r\nreturn adc_input_select_SB055x(hw, input, mic20db);\r\n}\r\nstatic int adc_init_SBx(struct hw *hw, int input, int mic20db)\r\n{\r\nu16 gpioorg;\r\nu16 input_source;\r\nu32 adcdata;\r\nunsigned int ret;\r\ninput_source = 0x100;\r\nswitch (input) {\r\ncase ADC_MICIN:\r\nadcdata = 0x1;\r\ninput_source = 0x180;\r\nbreak;\r\ncase ADC_LINEIN:\r\nadcdata = 0x2;\r\nbreak;\r\ncase ADC_VIDEO:\r\nadcdata = 0x4;\r\nbreak;\r\ncase ADC_AUX:\r\nadcdata = 0x8;\r\nbreak;\r\ncase ADC_NONE:\r\nadcdata = 0x0;\r\ninput_source = 0x0;\r\nbreak;\r\ndefault:\r\nadcdata = 0x0;\r\nbreak;\r\n}\r\nif (i2c_unlock(hw))\r\nreturn -1;\r\ndo {\r\nret = hw_read_pci(hw, 0xEC);\r\n} while (!(ret & 0x800000));\r\nhw_write_pci(hw, 0xEC, 0x05);\r\ni2c_write(hw, 0x001a0080, 0x0e, 0x08);\r\ni2c_write(hw, 0x001a0080, 0x18, 0x0a);\r\ni2c_write(hw, 0x001a0080, 0x28, 0x86);\r\ni2c_write(hw, 0x001a0080, 0x2a, adcdata);\r\nif (mic20db) {\r\ni2c_write(hw, 0x001a0080, 0x1c, 0xf7);\r\ni2c_write(hw, 0x001a0080, 0x1e, 0xf7);\r\n} else {\r\ni2c_write(hw, 0x001a0080, 0x1c, 0xcf);\r\ni2c_write(hw, 0x001a0080, 0x1e, 0xcf);\r\n}\r\nif (!(hw_read_20kx(hw, ID0) & 0x100))\r\ni2c_write(hw, 0x001a0080, 0x16, 0x26);\r\ni2c_lock(hw);\r\ngpioorg = (u16)hw_read_20kx(hw, GPIO);\r\ngpioorg &= 0xfe7f;\r\ngpioorg |= input_source;\r\nhw_write_20kx(hw, GPIO, gpioorg);\r\nreturn 0;\r\n}\r\nstatic int hw_adc_init(struct hw *hw, const struct adc_conf *info)\r\n{\r\nif (hw->model == CTSB055X)\r\nreturn adc_init_SB055x(hw, info->input, info->mic20db);\r\nelse\r\nreturn adc_init_SBx(hw, info->input, info->mic20db);\r\n}\r\nstatic struct capabilities hw_capabilities(struct hw *hw)\r\n{\r\nstruct capabilities cap;\r\ncap.digit_io_switch = !(hw->model == CTSB073X || hw->model == CTUAA);\r\ncap.dedicated_mic = 0;\r\ncap.output_switch = 0;\r\ncap.mic_source_switch = 0;\r\nreturn cap;\r\n}\r\nstatic int uaa_to_xfi(struct pci_dev *pci)\r\n{\r\nunsigned int bar0, bar1, bar2, bar3, bar4, bar5;\r\nunsigned int cmd, irq, cl_size, l_timer, pwr;\r\nunsigned int is_uaa;\r\nunsigned int data[4] = {0};\r\nunsigned int io_base;\r\nvoid __iomem *mem_base;\r\nint i;\r\nconst u32 CTLX = CTLBITS('C', 'T', 'L', 'X');\r\nconst u32 CTL_ = CTLBITS('C', 'T', 'L', '-');\r\nconst u32 CTLF = CTLBITS('C', 'T', 'L', 'F');\r\nconst u32 CTLi = CTLBITS('C', 'T', 'L', 'i');\r\nconst u32 CTLA = CTLBITS('C', 'T', 'L', 'A');\r\nconst u32 CTLZ = CTLBITS('C', 'T', 'L', 'Z');\r\nconst u32 CTLL = CTLBITS('C', 'T', 'L', 'L');\r\nio_base = pci_resource_start(pci, 0);\r\nmem_base = ioremap(io_base, pci_resource_len(pci, 0));\r\nif (!mem_base)\r\nreturn -ENOENT;\r\nfor (i = 0; i < 4; i++)\r\ndata[i] = readl(mem_base + UAA_CORE_CHANGE);\r\nif (data[0] == CTLA) {\r\nis_uaa = ((data[1] == CTLZ && data[2] == CTLL\r\n&& data[3] == CTLA) || (data[1] == CTLA\r\n&& data[2] == CTLZ && data[3] == CTLL));\r\n} else if (data[0] == CTLZ) {\r\nis_uaa = (data[1] == CTLL\r\n&& data[2] == CTLA && data[3] == CTLA);\r\n} else if (data[0] == CTLL) {\r\nis_uaa = (data[1] == CTLA\r\n&& data[2] == CTLA && data[3] == CTLZ);\r\n} else {\r\nis_uaa = 0;\r\n}\r\nif (!is_uaa) {\r\niounmap(mem_base);\r\nreturn 0;\r\n}\r\npci_read_config_dword(pci, PCI_BASE_ADDRESS_0, &bar0);\r\npci_read_config_dword(pci, PCI_BASE_ADDRESS_1, &bar1);\r\npci_read_config_dword(pci, PCI_BASE_ADDRESS_2, &bar2);\r\npci_read_config_dword(pci, PCI_BASE_ADDRESS_3, &bar3);\r\npci_read_config_dword(pci, PCI_BASE_ADDRESS_4, &bar4);\r\npci_read_config_dword(pci, PCI_BASE_ADDRESS_5, &bar5);\r\npci_read_config_dword(pci, PCI_INTERRUPT_LINE, &irq);\r\npci_read_config_dword(pci, PCI_CACHE_LINE_SIZE, &cl_size);\r\npci_read_config_dword(pci, PCI_LATENCY_TIMER, &l_timer);\r\npci_read_config_dword(pci, UAA_CFG_PWRSTATUS, &pwr);\r\npci_read_config_dword(pci, PCI_COMMAND, &cmd);\r\npci_write_config_dword(pci, UAA_CFG_SPACE_FLAG, 0x87654321);\r\npci_write_config_dword(pci, PCI_BASE_ADDRESS_0, bar5);\r\npci_write_config_dword(pci, UAA_CFG_SPACE_FLAG, 0x12345678);\r\npci_write_config_dword(pci, PCI_BASE_ADDRESS_1, bar1);\r\npci_write_config_dword(pci, PCI_BASE_ADDRESS_2, bar2);\r\npci_write_config_dword(pci, PCI_BASE_ADDRESS_3, bar3);\r\npci_write_config_dword(pci, PCI_BASE_ADDRESS_4, bar4);\r\npci_write_config_dword(pci, PCI_INTERRUPT_LINE, irq);\r\npci_write_config_dword(pci, PCI_CACHE_LINE_SIZE, cl_size);\r\npci_write_config_dword(pci, PCI_LATENCY_TIMER, l_timer);\r\npci_write_config_dword(pci, UAA_CFG_PWRSTATUS, pwr);\r\npci_write_config_dword(pci, PCI_COMMAND, cmd);\r\nwritel(CTLX, (mem_base + UAA_CORE_CHANGE));\r\nwritel(CTL_, (mem_base + UAA_CORE_CHANGE));\r\nwritel(CTLF, (mem_base + UAA_CORE_CHANGE));\r\nwritel(CTLi, (mem_base + UAA_CORE_CHANGE));\r\niounmap(mem_base);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t ct_20k1_interrupt(int irq, void *dev_id)\r\n{\r\nstruct hw *hw = dev_id;\r\nunsigned int status;\r\nstatus = hw_read_20kx(hw, GIP);\r\nif (!status)\r\nreturn IRQ_NONE;\r\nif (hw->irq_callback)\r\nhw->irq_callback(hw->irq_callback_data, status);\r\nhw_write_20kx(hw, GIP, status);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int hw_card_start(struct hw *hw)\r\n{\r\nint err;\r\nstruct pci_dev *pci = hw->pci;\r\nconst unsigned int dma_bits = BITS_PER_LONG;\r\nerr = pci_enable_device(pci);\r\nif (err < 0)\r\nreturn err;\r\nif (!dma_set_mask(&pci->dev, DMA_BIT_MASK(dma_bits))) {\r\ndma_set_coherent_mask(&pci->dev, DMA_BIT_MASK(dma_bits));\r\n} else {\r\ndma_set_mask(&pci->dev, DMA_BIT_MASK(32));\r\ndma_set_coherent_mask(&pci->dev, DMA_BIT_MASK(32));\r\n}\r\nif (!hw->io_base) {\r\nerr = pci_request_regions(pci, "XFi");\r\nif (err < 0)\r\ngoto error1;\r\nif (hw->model == CTUAA)\r\nhw->io_base = pci_resource_start(pci, 5);\r\nelse\r\nhw->io_base = pci_resource_start(pci, 0);\r\n}\r\nif (hw->model == CTUAA) {\r\nerr = uaa_to_xfi(pci);\r\nif (err)\r\ngoto error2;\r\n}\r\nif (hw->irq < 0) {\r\nerr = request_irq(pci->irq, ct_20k1_interrupt, IRQF_SHARED,\r\nKBUILD_MODNAME, hw);\r\nif (err < 0) {\r\ndev_err(hw->card->dev,\r\n"XFi: Cannot get irq %d\n", pci->irq);\r\ngoto error2;\r\n}\r\nhw->irq = pci->irq;\r\n}\r\npci_set_master(pci);\r\nreturn 0;\r\nerror2:\r\npci_release_regions(pci);\r\nhw->io_base = 0;\r\nerror1:\r\npci_disable_device(pci);\r\nreturn err;\r\n}\r\nstatic int hw_card_stop(struct hw *hw)\r\n{\r\nunsigned int data;\r\nhw_write_20kx(hw, TRNCTL, 0x00);\r\ndata = hw_read_20kx(hw, PLLCTL);\r\nhw_write_20kx(hw, PLLCTL, (data & (~(0x0F<<12))));\r\nif (hw->irq >= 0)\r\nsynchronize_irq(hw->irq);\r\nreturn 0;\r\n}\r\nstatic int hw_card_shutdown(struct hw *hw)\r\n{\r\nif (hw->irq >= 0)\r\nfree_irq(hw->irq, hw);\r\nhw->irq = -1;\r\niounmap(hw->mem_base);\r\nhw->mem_base = NULL;\r\nif (hw->io_base)\r\npci_release_regions(hw->pci);\r\nhw->io_base = 0;\r\npci_disable_device(hw->pci);\r\nreturn 0;\r\n}\r\nstatic int hw_card_init(struct hw *hw, struct card_conf *info)\r\n{\r\nint err;\r\nunsigned int gctl;\r\nu32 data;\r\nstruct dac_conf dac_info = {0};\r\nstruct adc_conf adc_info = {0};\r\nstruct daio_conf daio_info = {0};\r\nstruct trn_conf trn_info = {0};\r\nerr = hw_card_start(hw);\r\nif (err)\r\nreturn err;\r\nerr = hw_pll_init(hw, info->rsr);\r\nif (err < 0)\r\nreturn err;\r\nerr = hw_auto_init(hw);\r\nif (err < 0)\r\nreturn err;\r\ngctl = hw_read_20kx(hw, GCTL);\r\nset_field(&gctl, GCTL_EAC, 1);\r\nset_field(&gctl, GCTL_DBP, 1);\r\nset_field(&gctl, GCTL_TBP, 1);\r\nset_field(&gctl, GCTL_FBP, 1);\r\nset_field(&gctl, GCTL_ET, 1);\r\nhw_write_20kx(hw, GCTL, gctl);\r\nmdelay(10);\r\nhw_write_20kx(hw, GIE, 0);\r\nhw_write_20kx(hw, SRCIP, 0);\r\nmdelay(30);\r\nswitch (hw->model) {\r\ncase CTSB055X:\r\nhw_write_20kx(hw, GPIOCTL, 0x13fe);\r\nbreak;\r\ncase CTSB073X:\r\nhw_write_20kx(hw, GPIOCTL, 0x00e6);\r\nbreak;\r\ncase CTUAA:\r\nhw_write_20kx(hw, GPIOCTL, 0x00c2);\r\nbreak;\r\ndefault:\r\nhw_write_20kx(hw, GPIOCTL, 0x01e6);\r\nbreak;\r\n}\r\ntrn_info.vm_pgt_phys = info->vm_pgt_phys;\r\nerr = hw_trn_init(hw, &trn_info);\r\nif (err < 0)\r\nreturn err;\r\ndaio_info.msr = info->msr;\r\nerr = hw_daio_init(hw, &daio_info);\r\nif (err < 0)\r\nreturn err;\r\ndac_info.msr = info->msr;\r\nerr = hw_dac_init(hw, &dac_info);\r\nif (err < 0)\r\nreturn err;\r\nadc_info.msr = info->msr;\r\nadc_info.input = ADC_LINEIN;\r\nadc_info.mic20db = 0;\r\nerr = hw_adc_init(hw, &adc_info);\r\nif (err < 0)\r\nreturn err;\r\ndata = hw_read_20kx(hw, SRCMCTL);\r\ndata |= 0x1;\r\nhw_write_20kx(hw, SRCMCTL, data);\r\nreturn 0;\r\n}\r\nstatic int hw_suspend(struct hw *hw)\r\n{\r\nstruct pci_dev *pci = hw->pci;\r\nhw_card_stop(hw);\r\nif (hw->model == CTUAA) {\r\npci_write_config_dword(pci, UAA_CFG_SPACE_FLAG, 0x0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int hw_resume(struct hw *hw, struct card_conf *info)\r\n{\r\nreturn hw_card_init(hw, info);\r\n}\r\nstatic u32 hw_read_20kx(struct hw *hw, u32 reg)\r\n{\r\nu32 value;\r\nunsigned long flags;\r\nspin_lock_irqsave(\r\n&container_of(hw, struct hw20k1, hw)->reg_20k1_lock, flags);\r\noutl(reg, hw->io_base + 0x0);\r\nvalue = inl(hw->io_base + 0x4);\r\nspin_unlock_irqrestore(\r\n&container_of(hw, struct hw20k1, hw)->reg_20k1_lock, flags);\r\nreturn value;\r\n}\r\nstatic void hw_write_20kx(struct hw *hw, u32 reg, u32 data)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(\r\n&container_of(hw, struct hw20k1, hw)->reg_20k1_lock, flags);\r\noutl(reg, hw->io_base + 0x0);\r\noutl(data, hw->io_base + 0x4);\r\nspin_unlock_irqrestore(\r\n&container_of(hw, struct hw20k1, hw)->reg_20k1_lock, flags);\r\n}\r\nstatic u32 hw_read_pci(struct hw *hw, u32 reg)\r\n{\r\nu32 value;\r\nunsigned long flags;\r\nspin_lock_irqsave(\r\n&container_of(hw, struct hw20k1, hw)->reg_pci_lock, flags);\r\noutl(reg, hw->io_base + 0x10);\r\nvalue = inl(hw->io_base + 0x14);\r\nspin_unlock_irqrestore(\r\n&container_of(hw, struct hw20k1, hw)->reg_pci_lock, flags);\r\nreturn value;\r\n}\r\nstatic void hw_write_pci(struct hw *hw, u32 reg, u32 data)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(\r\n&container_of(hw, struct hw20k1, hw)->reg_pci_lock, flags);\r\noutl(reg, hw->io_base + 0x10);\r\noutl(data, hw->io_base + 0x14);\r\nspin_unlock_irqrestore(\r\n&container_of(hw, struct hw20k1, hw)->reg_pci_lock, flags);\r\n}\r\nint create_20k1_hw_obj(struct hw **rhw)\r\n{\r\nstruct hw20k1 *hw20k1;\r\n*rhw = NULL;\r\nhw20k1 = kzalloc(sizeof(*hw20k1), GFP_KERNEL);\r\nif (!hw20k1)\r\nreturn -ENOMEM;\r\nspin_lock_init(&hw20k1->reg_20k1_lock);\r\nspin_lock_init(&hw20k1->reg_pci_lock);\r\nhw20k1->hw = ct20k1_preset;\r\n*rhw = &hw20k1->hw;\r\nreturn 0;\r\n}\r\nint destroy_20k1_hw_obj(struct hw *hw)\r\n{\r\nif (hw->io_base)\r\nhw_card_shutdown(hw);\r\nkfree(container_of(hw, struct hw20k1, hw));\r\nreturn 0;\r\n}
