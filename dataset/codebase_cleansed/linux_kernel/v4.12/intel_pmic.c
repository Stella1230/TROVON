static int pmic_get_reg_bit(int address, struct pmic_table *table,\r\nint count, int *reg, int *bit)\r\n{\r\nint i;\r\nfor (i = 0; i < count; i++) {\r\nif (table[i].address == address) {\r\n*reg = table[i].reg;\r\nif (bit)\r\n*bit = table[i].bit;\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic acpi_status intel_pmic_power_handler(u32 function,\r\nacpi_physical_address address, u32 bits, u64 *value64,\r\nvoid *handler_context, void *region_context)\r\n{\r\nstruct intel_pmic_opregion *opregion = region_context;\r\nstruct regmap *regmap = opregion->regmap;\r\nstruct intel_pmic_opregion_data *d = opregion->data;\r\nint reg, bit, result;\r\nif (bits != 32 || !value64)\r\nreturn AE_BAD_PARAMETER;\r\nif (function == ACPI_WRITE && !(*value64 == 0 || *value64 == 1))\r\nreturn AE_BAD_PARAMETER;\r\nresult = pmic_get_reg_bit(address, d->power_table,\r\nd->power_table_count, &reg, &bit);\r\nif (result == -ENOENT)\r\nreturn AE_BAD_PARAMETER;\r\nmutex_lock(&opregion->lock);\r\nresult = function == ACPI_READ ?\r\nd->get_power(regmap, reg, bit, value64) :\r\nd->update_power(regmap, reg, bit, *value64 == 1);\r\nmutex_unlock(&opregion->lock);\r\nreturn result ? AE_ERROR : AE_OK;\r\n}\r\nstatic int pmic_read_temp(struct intel_pmic_opregion *opregion,\r\nint reg, u64 *value)\r\n{\r\nint raw_temp, temp;\r\nif (!opregion->data->get_raw_temp)\r\nreturn -ENXIO;\r\nraw_temp = opregion->data->get_raw_temp(opregion->regmap, reg);\r\nif (raw_temp < 0)\r\nreturn raw_temp;\r\nif (!opregion->lpat_table) {\r\n*value = raw_temp;\r\nreturn 0;\r\n}\r\ntemp = acpi_lpat_raw_to_temp(opregion->lpat_table, raw_temp);\r\nif (temp < 0)\r\nreturn temp;\r\n*value = temp;\r\nreturn 0;\r\n}\r\nstatic int pmic_thermal_temp(struct intel_pmic_opregion *opregion, int reg,\r\nu32 function, u64 *value)\r\n{\r\nreturn function == ACPI_READ ?\r\npmic_read_temp(opregion, reg, value) : -EINVAL;\r\n}\r\nstatic int pmic_thermal_aux(struct intel_pmic_opregion *opregion, int reg,\r\nu32 function, u64 *value)\r\n{\r\nint raw_temp;\r\nif (function == ACPI_READ)\r\nreturn pmic_read_temp(opregion, reg, value);\r\nif (!opregion->data->update_aux)\r\nreturn -ENXIO;\r\nif (opregion->lpat_table) {\r\nraw_temp = acpi_lpat_temp_to_raw(opregion->lpat_table, *value);\r\nif (raw_temp < 0)\r\nreturn raw_temp;\r\n} else {\r\nraw_temp = *value;\r\n}\r\nreturn opregion->data->update_aux(opregion->regmap, reg, raw_temp);\r\n}\r\nstatic int pmic_thermal_pen(struct intel_pmic_opregion *opregion, int reg,\r\nint bit, u32 function, u64 *value)\r\n{\r\nstruct intel_pmic_opregion_data *d = opregion->data;\r\nstruct regmap *regmap = opregion->regmap;\r\nif (!d->get_policy || !d->update_policy)\r\nreturn -ENXIO;\r\nif (function == ACPI_READ)\r\nreturn d->get_policy(regmap, reg, bit, value);\r\nif (*value != 0 && *value != 1)\r\nreturn -EINVAL;\r\nreturn d->update_policy(regmap, reg, bit, *value);\r\n}\r\nstatic bool pmic_thermal_is_temp(int address)\r\n{\r\nreturn (address <= 0x3c) && !(address % 12);\r\n}\r\nstatic bool pmic_thermal_is_aux(int address)\r\n{\r\nreturn (address >= 4 && address <= 0x40 && !((address - 4) % 12)) ||\r\n(address >= 8 && address <= 0x44 && !((address - 8) % 12));\r\n}\r\nstatic bool pmic_thermal_is_pen(int address)\r\n{\r\nreturn address >= 0x48 && address <= 0x5c;\r\n}\r\nstatic acpi_status intel_pmic_thermal_handler(u32 function,\r\nacpi_physical_address address, u32 bits, u64 *value64,\r\nvoid *handler_context, void *region_context)\r\n{\r\nstruct intel_pmic_opregion *opregion = region_context;\r\nstruct intel_pmic_opregion_data *d = opregion->data;\r\nint reg, bit, result;\r\nif (bits != 32 || !value64)\r\nreturn AE_BAD_PARAMETER;\r\nresult = pmic_get_reg_bit(address, d->thermal_table,\r\nd->thermal_table_count, &reg, &bit);\r\nif (result == -ENOENT)\r\nreturn AE_BAD_PARAMETER;\r\nmutex_lock(&opregion->lock);\r\nif (pmic_thermal_is_temp(address))\r\nresult = pmic_thermal_temp(opregion, reg, function, value64);\r\nelse if (pmic_thermal_is_aux(address))\r\nresult = pmic_thermal_aux(opregion, reg, function, value64);\r\nelse if (pmic_thermal_is_pen(address))\r\nresult = pmic_thermal_pen(opregion, reg, bit,\r\nfunction, value64);\r\nelse\r\nresult = -EINVAL;\r\nmutex_unlock(&opregion->lock);\r\nif (result < 0) {\r\nif (result == -EINVAL)\r\nreturn AE_BAD_PARAMETER;\r\nelse\r\nreturn AE_ERROR;\r\n}\r\nreturn AE_OK;\r\n}\r\nstatic acpi_status intel_pmic_regs_handler(u32 function,\r\nacpi_physical_address address, u32 bits, u64 *value64,\r\nvoid *handler_context, void *region_context)\r\n{\r\nstruct intel_pmic_opregion *opregion = region_context;\r\nint result = 0;\r\nswitch (address) {\r\ncase 0:\r\nreturn AE_OK;\r\ncase 1:\r\nopregion->ctx.addr |= (*value64 & 0xff) << 8;\r\nreturn AE_OK;\r\ncase 2:\r\nopregion->ctx.addr |= *value64 & 0xff;\r\nreturn AE_OK;\r\ncase 3:\r\nopregion->ctx.val = *value64 & 0xff;\r\nreturn AE_OK;\r\ncase 4:\r\nif (*value64) {\r\nresult = regmap_write(opregion->regmap, opregion->ctx.addr,\r\nopregion->ctx.val);\r\n} else {\r\nresult = regmap_read(opregion->regmap, opregion->ctx.addr,\r\n&opregion->ctx.val);\r\nif (result == 0)\r\n*value64 = opregion->ctx.val;\r\n}\r\nmemset(&opregion->ctx, 0x00, sizeof(opregion->ctx));\r\n}\r\nif (result < 0) {\r\nif (result == -EINVAL)\r\nreturn AE_BAD_PARAMETER;\r\nelse\r\nreturn AE_ERROR;\r\n}\r\nreturn AE_OK;\r\n}\r\nint intel_pmic_install_opregion_handler(struct device *dev, acpi_handle handle,\r\nstruct regmap *regmap,\r\nstruct intel_pmic_opregion_data *d)\r\n{\r\nacpi_status status;\r\nstruct intel_pmic_opregion *opregion;\r\nint ret;\r\nif (!dev || !regmap || !d)\r\nreturn -EINVAL;\r\nif (!handle)\r\nreturn -ENODEV;\r\nopregion = devm_kzalloc(dev, sizeof(*opregion), GFP_KERNEL);\r\nif (!opregion)\r\nreturn -ENOMEM;\r\nmutex_init(&opregion->lock);\r\nopregion->regmap = regmap;\r\nopregion->lpat_table = acpi_lpat_get_conversion_table(handle);\r\nstatus = acpi_install_address_space_handler(handle,\r\nPMIC_POWER_OPREGION_ID,\r\nintel_pmic_power_handler,\r\nNULL, opregion);\r\nif (ACPI_FAILURE(status)) {\r\nret = -ENODEV;\r\ngoto out_error;\r\n}\r\nstatus = acpi_install_address_space_handler(handle,\r\nPMIC_THERMAL_OPREGION_ID,\r\nintel_pmic_thermal_handler,\r\nNULL, opregion);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_remove_address_space_handler(handle, PMIC_POWER_OPREGION_ID,\r\nintel_pmic_power_handler);\r\nret = -ENODEV;\r\ngoto out_remove_power_handler;\r\n}\r\nstatus = acpi_install_address_space_handler(handle,\r\nPMIC_REGS_OPREGION_ID, intel_pmic_regs_handler, NULL,\r\nopregion);\r\nif (ACPI_FAILURE(status)) {\r\nret = -ENODEV;\r\ngoto out_remove_thermal_handler;\r\n}\r\nopregion->data = d;\r\nreturn 0;\r\nout_remove_thermal_handler:\r\nacpi_remove_address_space_handler(handle, PMIC_THERMAL_OPREGION_ID,\r\nintel_pmic_thermal_handler);\r\nout_remove_power_handler:\r\nacpi_remove_address_space_handler(handle, PMIC_POWER_OPREGION_ID,\r\nintel_pmic_power_handler);\r\nout_error:\r\nacpi_lpat_free_conversion_table(opregion->lpat_table);\r\nreturn ret;\r\n}
