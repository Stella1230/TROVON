static void sclp_suspend_req_cb(struct sclp_req *req, void *data)\r\n{\r\ncomplete(&sclp_request_queue_flushed);\r\n}\r\nstatic int __init sclp_setup_console_pages(char *str)\r\n{\r\nint pages, rc;\r\nrc = kstrtoint(str, 0, &pages);\r\nif (!rc && pages >= SCLP_CONSOLE_PAGES)\r\nsclp_console_pages = pages;\r\nreturn 1;\r\n}\r\nstatic int __init sclp_setup_console_drop(char *str)\r\n{\r\nint drop, rc;\r\nrc = kstrtoint(str, 0, &drop);\r\nif (!rc)\r\nsclp_console_drop = drop;\r\nreturn 1;\r\n}\r\nstatic void\r\n__sclp_queue_read_req(void)\r\n{\r\nif (sclp_reading_state == sclp_reading_state_idle) {\r\nsclp_reading_state = sclp_reading_state_reading;\r\n__sclp_make_read_req();\r\nlist_add(&sclp_read_req.list, &sclp_req_queue);\r\n}\r\n}\r\nstatic inline void\r\n__sclp_set_request_timer(unsigned long time, void (*function)(unsigned long),\r\nunsigned long data)\r\n{\r\ndel_timer(&sclp_request_timer);\r\nsclp_request_timer.function = function;\r\nsclp_request_timer.data = data;\r\nsclp_request_timer.expires = jiffies + time;\r\nadd_timer(&sclp_request_timer);\r\n}\r\nstatic void\r\nsclp_request_timeout(unsigned long data)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&sclp_lock, flags);\r\nif (data) {\r\nif (sclp_running_state == sclp_running_state_running) {\r\n__sclp_queue_read_req();\r\nsclp_running_state = sclp_running_state_idle;\r\n}\r\n} else {\r\n__sclp_set_request_timer(SCLP_BUSY_INTERVAL * HZ,\r\nsclp_request_timeout, 0);\r\n}\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nsclp_process_queue();\r\n}\r\nstatic unsigned long __sclp_req_queue_find_next_timeout(void)\r\n{\r\nunsigned long expires_next = 0;\r\nstruct sclp_req *req;\r\nlist_for_each_entry(req, &sclp_req_queue, list) {\r\nif (!req->queue_expires)\r\ncontinue;\r\nif (!expires_next ||\r\n(time_before(req->queue_expires, expires_next)))\r\nexpires_next = req->queue_expires;\r\n}\r\nreturn expires_next;\r\n}\r\nstatic struct sclp_req *__sclp_req_queue_remove_expired_req(void)\r\n{\r\nunsigned long flags, now;\r\nstruct sclp_req *req;\r\nspin_lock_irqsave(&sclp_lock, flags);\r\nnow = jiffies;\r\nlist_for_each_entry(req, &sclp_req_queue, list) {\r\nif (!req->queue_expires)\r\ncontinue;\r\nif (time_before_eq(req->queue_expires, now)) {\r\nif (req->status == SCLP_REQ_QUEUED) {\r\nreq->status = SCLP_REQ_QUEUED_TIMEOUT;\r\nlist_del(&req->list);\r\ngoto out;\r\n}\r\n}\r\n}\r\nreq = NULL;\r\nout:\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nreturn req;\r\n}\r\nstatic void sclp_req_queue_timeout(unsigned long data)\r\n{\r\nunsigned long flags, expires_next;\r\nstruct sclp_req *req;\r\ndo {\r\nreq = __sclp_req_queue_remove_expired_req();\r\nif (req && req->callback)\r\nreq->callback(req, req->callback_data);\r\n} while (req);\r\nspin_lock_irqsave(&sclp_lock, flags);\r\nexpires_next = __sclp_req_queue_find_next_timeout();\r\nif (expires_next)\r\nmod_timer(&sclp_queue_timer, expires_next);\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\n}\r\nstatic int\r\n__sclp_start_request(struct sclp_req *req)\r\n{\r\nint rc;\r\nif (sclp_running_state != sclp_running_state_idle)\r\nreturn 0;\r\ndel_timer(&sclp_request_timer);\r\nrc = sclp_service_call(req->command, req->sccb);\r\nreq->start_count++;\r\nif (rc == 0) {\r\nreq->status = SCLP_REQ_RUNNING;\r\nsclp_running_state = sclp_running_state_running;\r\n__sclp_set_request_timer(SCLP_RETRY_INTERVAL * HZ,\r\nsclp_request_timeout, 1);\r\nreturn 0;\r\n} else if (rc == -EBUSY) {\r\n__sclp_set_request_timer(SCLP_BUSY_INTERVAL * HZ,\r\nsclp_request_timeout, 0);\r\nreturn 0;\r\n}\r\nreq->status = SCLP_REQ_FAILED;\r\nreturn rc;\r\n}\r\nstatic void\r\nsclp_process_queue(void)\r\n{\r\nstruct sclp_req *req;\r\nint rc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sclp_lock, flags);\r\nif (sclp_running_state != sclp_running_state_idle) {\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nreturn;\r\n}\r\ndel_timer(&sclp_request_timer);\r\nwhile (!list_empty(&sclp_req_queue)) {\r\nreq = list_entry(sclp_req_queue.next, struct sclp_req, list);\r\nif (!req->sccb)\r\ngoto do_post;\r\nrc = __sclp_start_request(req);\r\nif (rc == 0)\r\nbreak;\r\nif (req->start_count > 1) {\r\n__sclp_set_request_timer(SCLP_BUSY_INTERVAL * HZ,\r\nsclp_request_timeout, 0);\r\nbreak;\r\n}\r\ndo_post:\r\nlist_del(&req->list);\r\nif (req->callback) {\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nreq->callback(req, req->callback_data);\r\nspin_lock_irqsave(&sclp_lock, flags);\r\n}\r\n}\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\n}\r\nstatic int __sclp_can_add_request(struct sclp_req *req)\r\n{\r\nif (req == &sclp_suspend_req || req == &sclp_init_req)\r\nreturn 1;\r\nif (sclp_suspend_state != sclp_suspend_state_running)\r\nreturn 0;\r\nif (sclp_init_state != sclp_init_state_initialized)\r\nreturn 0;\r\nif (sclp_activation_state != sclp_activation_state_active)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint\r\nsclp_add_request(struct sclp_req *req)\r\n{\r\nunsigned long flags;\r\nint rc;\r\nspin_lock_irqsave(&sclp_lock, flags);\r\nif (!__sclp_can_add_request(req)) {\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nreturn -EIO;\r\n}\r\nreq->status = SCLP_REQ_QUEUED;\r\nreq->start_count = 0;\r\nlist_add_tail(&req->list, &sclp_req_queue);\r\nrc = 0;\r\nif (req->queue_timeout) {\r\nreq->queue_expires = jiffies + req->queue_timeout * HZ;\r\nif (!timer_pending(&sclp_queue_timer) ||\r\ntime_after(sclp_queue_timer.expires, req->queue_expires))\r\nmod_timer(&sclp_queue_timer, req->queue_expires);\r\n} else\r\nreq->queue_expires = 0;\r\nif (sclp_running_state == sclp_running_state_idle &&\r\nreq->list.prev == &sclp_req_queue) {\r\nif (!req->sccb) {\r\nlist_del(&req->list);\r\nrc = -ENODATA;\r\ngoto out;\r\n}\r\nrc = __sclp_start_request(req);\r\nif (rc)\r\nlist_del(&req->list);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nreturn rc;\r\n}\r\nstatic int\r\nsclp_dispatch_evbufs(struct sccb_header *sccb)\r\n{\r\nunsigned long flags;\r\nstruct evbuf_header *evbuf;\r\nstruct list_head *l;\r\nstruct sclp_register *reg;\r\nint offset;\r\nint rc;\r\nspin_lock_irqsave(&sclp_lock, flags);\r\nrc = 0;\r\nfor (offset = sizeof(struct sccb_header); offset < sccb->length;\r\noffset += evbuf->length) {\r\nevbuf = (struct evbuf_header *) ((addr_t) sccb + offset);\r\nif (evbuf->length == 0)\r\nbreak;\r\nreg = NULL;\r\nlist_for_each(l, &sclp_reg_list) {\r\nreg = list_entry(l, struct sclp_register, list);\r\nif (reg->receive_mask & (1 << (32 - evbuf->type)))\r\nbreak;\r\nelse\r\nreg = NULL;\r\n}\r\nif (reg && reg->receiver_fn) {\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nreg->receiver_fn(evbuf);\r\nspin_lock_irqsave(&sclp_lock, flags);\r\n} else if (reg == NULL)\r\nrc = -EOPNOTSUPP;\r\n}\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nreturn rc;\r\n}\r\nstatic void\r\nsclp_read_cb(struct sclp_req *req, void *data)\r\n{\r\nunsigned long flags;\r\nstruct sccb_header *sccb;\r\nsccb = (struct sccb_header *) req->sccb;\r\nif (req->status == SCLP_REQ_DONE && (sccb->response_code == 0x20 ||\r\nsccb->response_code == 0x220))\r\nsclp_dispatch_evbufs(sccb);\r\nspin_lock_irqsave(&sclp_lock, flags);\r\nsclp_reading_state = sclp_reading_state_idle;\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\n}\r\nstatic void __sclp_make_read_req(void)\r\n{\r\nstruct sccb_header *sccb;\r\nsccb = (struct sccb_header *) sclp_read_sccb;\r\nclear_page(sccb);\r\nmemset(&sclp_read_req, 0, sizeof(struct sclp_req));\r\nsclp_read_req.command = SCLP_CMDW_READ_EVENT_DATA;\r\nsclp_read_req.status = SCLP_REQ_QUEUED;\r\nsclp_read_req.start_count = 0;\r\nsclp_read_req.callback = sclp_read_cb;\r\nsclp_read_req.sccb = sccb;\r\nsccb->length = PAGE_SIZE;\r\nsccb->function_code = 0;\r\nsccb->control_mask[2] = 0x80;\r\n}\r\nstatic inline struct sclp_req *\r\n__sclp_find_req(u32 sccb)\r\n{\r\nstruct list_head *l;\r\nstruct sclp_req *req;\r\nlist_for_each(l, &sclp_req_queue) {\r\nreq = list_entry(l, struct sclp_req, list);\r\nif (sccb == (u32) (addr_t) req->sccb)\r\nreturn req;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void sclp_interrupt_handler(struct ext_code ext_code,\r\nunsigned int param32, unsigned long param64)\r\n{\r\nstruct sclp_req *req;\r\nu32 finished_sccb;\r\nu32 evbuf_pending;\r\ninc_irq_stat(IRQEXT_SCP);\r\nspin_lock(&sclp_lock);\r\nfinished_sccb = param32 & 0xfffffff8;\r\nevbuf_pending = param32 & 0x3;\r\nif (finished_sccb) {\r\ndel_timer(&sclp_request_timer);\r\nsclp_running_state = sclp_running_state_reset_pending;\r\nreq = __sclp_find_req(finished_sccb);\r\nif (req) {\r\nlist_del(&req->list);\r\nreq->status = SCLP_REQ_DONE;\r\nif (req->callback) {\r\nspin_unlock(&sclp_lock);\r\nreq->callback(req, req->callback_data);\r\nspin_lock(&sclp_lock);\r\n}\r\n}\r\nsclp_running_state = sclp_running_state_idle;\r\n}\r\nif (evbuf_pending &&\r\nsclp_activation_state == sclp_activation_state_active)\r\n__sclp_queue_read_req();\r\nspin_unlock(&sclp_lock);\r\nsclp_process_queue();\r\n}\r\nstatic inline u64\r\nsclp_tod_from_jiffies(unsigned long jiffies)\r\n{\r\nreturn (u64) (jiffies / HZ) << 32;\r\n}\r\nvoid\r\nsclp_sync_wait(void)\r\n{\r\nunsigned long long old_tick;\r\nunsigned long flags;\r\nunsigned long cr0, cr0_sync;\r\nu64 timeout;\r\nint irq_context;\r\ntimeout = 0;\r\nif (timer_pending(&sclp_request_timer)) {\r\ntimeout = get_tod_clock_fast() +\r\nsclp_tod_from_jiffies(sclp_request_timer.expires -\r\njiffies);\r\n}\r\nlocal_irq_save(flags);\r\nirq_context = in_interrupt();\r\nif (!irq_context)\r\nlocal_bh_disable();\r\nold_tick = local_tick_disable();\r\ntrace_hardirqs_on();\r\n__ctl_store(cr0, 0, 0);\r\ncr0_sync = cr0 & ~CR0_IRQ_SUBCLASS_MASK;\r\ncr0_sync |= 1UL << (63 - 54);\r\n__ctl_load(cr0_sync, 0, 0);\r\n__arch_local_irq_stosm(0x01);\r\nwhile (sclp_running_state != sclp_running_state_idle) {\r\nif (timer_pending(&sclp_request_timer) &&\r\nget_tod_clock_fast() > timeout &&\r\ndel_timer(&sclp_request_timer))\r\nsclp_request_timer.function(sclp_request_timer.data);\r\ncpu_relax();\r\n}\r\nlocal_irq_disable();\r\n__ctl_load(cr0, 0, 0);\r\nif (!irq_context)\r\n_local_bh_enable();\r\nlocal_tick_enable(old_tick);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void\r\nsclp_dispatch_state_change(void)\r\n{\r\nstruct list_head *l;\r\nstruct sclp_register *reg;\r\nunsigned long flags;\r\nsccb_mask_t receive_mask;\r\nsccb_mask_t send_mask;\r\ndo {\r\nspin_lock_irqsave(&sclp_lock, flags);\r\nreg = NULL;\r\nlist_for_each(l, &sclp_reg_list) {\r\nreg = list_entry(l, struct sclp_register, list);\r\nreceive_mask = reg->send_mask & sclp_receive_mask;\r\nsend_mask = reg->receive_mask & sclp_send_mask;\r\nif (reg->sclp_receive_mask != receive_mask ||\r\nreg->sclp_send_mask != send_mask) {\r\nreg->sclp_receive_mask = receive_mask;\r\nreg->sclp_send_mask = send_mask;\r\nbreak;\r\n} else\r\nreg = NULL;\r\n}\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nif (reg && reg->state_change_fn)\r\nreg->state_change_fn(reg);\r\n} while (reg);\r\n}\r\nstatic void\r\nsclp_state_change_cb(struct evbuf_header *evbuf)\r\n{\r\nunsigned long flags;\r\nstruct sclp_statechangebuf *scbuf;\r\nscbuf = (struct sclp_statechangebuf *) evbuf;\r\nif (scbuf->mask_length != sizeof(sccb_mask_t))\r\nreturn;\r\nspin_lock_irqsave(&sclp_lock, flags);\r\nif (scbuf->validity_sclp_receive_mask)\r\nsclp_receive_mask = scbuf->sclp_receive_mask;\r\nif (scbuf->validity_sclp_send_mask)\r\nsclp_send_mask = scbuf->sclp_send_mask;\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nif (scbuf->validity_sclp_active_facility_mask)\r\nsclp.facilities = scbuf->sclp_active_facility_mask;\r\nsclp_dispatch_state_change();\r\n}\r\nstatic inline void\r\n__sclp_get_mask(sccb_mask_t *receive_mask, sccb_mask_t *send_mask)\r\n{\r\nstruct list_head *l;\r\nstruct sclp_register *t;\r\n*receive_mask = 0;\r\n*send_mask = 0;\r\nlist_for_each(l, &sclp_reg_list) {\r\nt = list_entry(l, struct sclp_register, list);\r\n*receive_mask |= t->receive_mask;\r\n*send_mask |= t->send_mask;\r\n}\r\n}\r\nint\r\nsclp_register(struct sclp_register *reg)\r\n{\r\nunsigned long flags;\r\nsccb_mask_t receive_mask;\r\nsccb_mask_t send_mask;\r\nint rc;\r\nrc = sclp_init();\r\nif (rc)\r\nreturn rc;\r\nspin_lock_irqsave(&sclp_lock, flags);\r\n__sclp_get_mask(&receive_mask, &send_mask);\r\nif (reg->receive_mask & receive_mask || reg->send_mask & send_mask) {\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nreturn -EBUSY;\r\n}\r\nreg->sclp_receive_mask = 0;\r\nreg->sclp_send_mask = 0;\r\nreg->pm_event_posted = 0;\r\nlist_add(&reg->list, &sclp_reg_list);\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nrc = sclp_init_mask(1);\r\nif (rc) {\r\nspin_lock_irqsave(&sclp_lock, flags);\r\nlist_del(&reg->list);\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\n}\r\nreturn rc;\r\n}\r\nvoid\r\nsclp_unregister(struct sclp_register *reg)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&sclp_lock, flags);\r\nlist_del(&reg->list);\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nsclp_init_mask(1);\r\n}\r\nint\r\nsclp_remove_processed(struct sccb_header *sccb)\r\n{\r\nstruct evbuf_header *evbuf;\r\nint unprocessed;\r\nu16 remaining;\r\nevbuf = (struct evbuf_header *) (sccb + 1);\r\nunprocessed = 0;\r\nremaining = sccb->length - sizeof(struct sccb_header);\r\nwhile (remaining > 0) {\r\nremaining -= evbuf->length;\r\nif (evbuf->flags & 0x80) {\r\nsccb->length -= evbuf->length;\r\nmemcpy(evbuf, (void *) ((addr_t) evbuf + evbuf->length),\r\nremaining);\r\n} else {\r\nunprocessed++;\r\nevbuf = (struct evbuf_header *)\r\n((addr_t) evbuf + evbuf->length);\r\n}\r\n}\r\nreturn unprocessed;\r\n}\r\nstatic inline void\r\n__sclp_make_init_req(u32 receive_mask, u32 send_mask)\r\n{\r\nstruct init_sccb *sccb;\r\nsccb = (struct init_sccb *) sclp_init_sccb;\r\nclear_page(sccb);\r\nmemset(&sclp_init_req, 0, sizeof(struct sclp_req));\r\nsclp_init_req.command = SCLP_CMDW_WRITE_EVENT_MASK;\r\nsclp_init_req.status = SCLP_REQ_FILLED;\r\nsclp_init_req.start_count = 0;\r\nsclp_init_req.callback = NULL;\r\nsclp_init_req.callback_data = NULL;\r\nsclp_init_req.sccb = sccb;\r\nsccb->header.length = sizeof(struct init_sccb);\r\nsccb->mask_length = sizeof(sccb_mask_t);\r\nsccb->receive_mask = receive_mask;\r\nsccb->send_mask = send_mask;\r\nsccb->sclp_receive_mask = 0;\r\nsccb->sclp_send_mask = 0;\r\n}\r\nstatic int\r\nsclp_init_mask(int calculate)\r\n{\r\nunsigned long flags;\r\nstruct init_sccb *sccb = (struct init_sccb *) sclp_init_sccb;\r\nsccb_mask_t receive_mask;\r\nsccb_mask_t send_mask;\r\nint retry;\r\nint rc;\r\nunsigned long wait;\r\nspin_lock_irqsave(&sclp_lock, flags);\r\nif (sclp_mask_state != sclp_mask_state_idle) {\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nreturn -EBUSY;\r\n}\r\nif (sclp_activation_state == sclp_activation_state_inactive) {\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nreturn -EINVAL;\r\n}\r\nsclp_mask_state = sclp_mask_state_initializing;\r\nif (calculate)\r\n__sclp_get_mask(&receive_mask, &send_mask);\r\nelse {\r\nreceive_mask = 0;\r\nsend_mask = 0;\r\n}\r\nrc = -EIO;\r\nfor (retry = 0; retry <= SCLP_MASK_RETRY; retry++) {\r\n__sclp_make_init_req(receive_mask, send_mask);\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nif (sclp_add_request(&sclp_init_req)) {\r\nwait = jiffies + SCLP_BUSY_INTERVAL * HZ;\r\nwhile (time_before(jiffies, wait))\r\nsclp_sync_wait();\r\nspin_lock_irqsave(&sclp_lock, flags);\r\ncontinue;\r\n}\r\nwhile (sclp_init_req.status != SCLP_REQ_DONE &&\r\nsclp_init_req.status != SCLP_REQ_FAILED)\r\nsclp_sync_wait();\r\nspin_lock_irqsave(&sclp_lock, flags);\r\nif (sclp_init_req.status == SCLP_REQ_DONE &&\r\nsccb->header.response_code == 0x20) {\r\nif (calculate) {\r\nsclp_receive_mask = sccb->sclp_receive_mask;\r\nsclp_send_mask = sccb->sclp_send_mask;\r\n} else {\r\nsclp_receive_mask = 0;\r\nsclp_send_mask = 0;\r\n}\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nsclp_dispatch_state_change();\r\nspin_lock_irqsave(&sclp_lock, flags);\r\nrc = 0;\r\nbreak;\r\n}\r\n}\r\nsclp_mask_state = sclp_mask_state_idle;\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nreturn rc;\r\n}\r\nint\r\nsclp_deactivate(void)\r\n{\r\nunsigned long flags;\r\nint rc;\r\nspin_lock_irqsave(&sclp_lock, flags);\r\nif (sclp_activation_state != sclp_activation_state_active) {\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nreturn -EINVAL;\r\n}\r\nsclp_activation_state = sclp_activation_state_deactivating;\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nrc = sclp_init_mask(0);\r\nspin_lock_irqsave(&sclp_lock, flags);\r\nif (rc == 0)\r\nsclp_activation_state = sclp_activation_state_inactive;\r\nelse\r\nsclp_activation_state = sclp_activation_state_active;\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nreturn rc;\r\n}\r\nint\r\nsclp_reactivate(void)\r\n{\r\nunsigned long flags;\r\nint rc;\r\nspin_lock_irqsave(&sclp_lock, flags);\r\nif (sclp_activation_state != sclp_activation_state_inactive) {\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nreturn -EINVAL;\r\n}\r\nsclp_activation_state = sclp_activation_state_activating;\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nrc = sclp_init_mask(1);\r\nspin_lock_irqsave(&sclp_lock, flags);\r\nif (rc == 0)\r\nsclp_activation_state = sclp_activation_state_active;\r\nelse\r\nsclp_activation_state = sclp_activation_state_inactive;\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nreturn rc;\r\n}\r\nstatic void sclp_check_handler(struct ext_code ext_code,\r\nunsigned int param32, unsigned long param64)\r\n{\r\nu32 finished_sccb;\r\ninc_irq_stat(IRQEXT_SCP);\r\nfinished_sccb = param32 & 0xfffffff8;\r\nif (finished_sccb == 0)\r\nreturn;\r\nif (finished_sccb != (u32) (addr_t) sclp_init_sccb)\r\npanic("sclp: unsolicited interrupt for buffer at 0x%x\n",\r\nfinished_sccb);\r\nspin_lock(&sclp_lock);\r\nif (sclp_running_state == sclp_running_state_running) {\r\nsclp_init_req.status = SCLP_REQ_DONE;\r\nsclp_running_state = sclp_running_state_idle;\r\n}\r\nspin_unlock(&sclp_lock);\r\n}\r\nstatic void\r\nsclp_check_timeout(unsigned long data)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&sclp_lock, flags);\r\nif (sclp_running_state == sclp_running_state_running) {\r\nsclp_init_req.status = SCLP_REQ_FAILED;\r\nsclp_running_state = sclp_running_state_idle;\r\n}\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\n}\r\nstatic int\r\nsclp_check_interface(void)\r\n{\r\nstruct init_sccb *sccb;\r\nunsigned long flags;\r\nint retry;\r\nint rc;\r\nspin_lock_irqsave(&sclp_lock, flags);\r\nrc = register_external_irq(EXT_IRQ_SERVICE_SIG, sclp_check_handler);\r\nif (rc) {\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nreturn rc;\r\n}\r\nfor (retry = 0; retry <= SCLP_INIT_RETRY; retry++) {\r\n__sclp_make_init_req(0, 0);\r\nsccb = (struct init_sccb *) sclp_init_req.sccb;\r\nrc = sclp_service_call(sclp_init_req.command, sccb);\r\nif (rc == -EIO)\r\nbreak;\r\nsclp_init_req.status = SCLP_REQ_RUNNING;\r\nsclp_running_state = sclp_running_state_running;\r\n__sclp_set_request_timer(SCLP_RETRY_INTERVAL * HZ,\r\nsclp_check_timeout, 0);\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nirq_subclass_register(IRQ_SUBCLASS_SERVICE_SIGNAL);\r\nsclp_sync_wait();\r\nirq_subclass_unregister(IRQ_SUBCLASS_SERVICE_SIGNAL);\r\nspin_lock_irqsave(&sclp_lock, flags);\r\ndel_timer(&sclp_request_timer);\r\nif (sclp_init_req.status == SCLP_REQ_DONE &&\r\nsccb->header.response_code == 0x20) {\r\nrc = 0;\r\nbreak;\r\n} else\r\nrc = -EBUSY;\r\n}\r\nunregister_external_irq(EXT_IRQ_SERVICE_SIG, sclp_check_handler);\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nreturn rc;\r\n}\r\nstatic int\r\nsclp_reboot_event(struct notifier_block *this, unsigned long event, void *ptr)\r\n{\r\nsclp_deactivate();\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void sclp_pm_event(enum sclp_pm_event sclp_pm_event, int rollback)\r\n{\r\nstruct sclp_register *reg;\r\nunsigned long flags;\r\nif (!rollback) {\r\nspin_lock_irqsave(&sclp_lock, flags);\r\nlist_for_each_entry(reg, &sclp_reg_list, list)\r\nreg->pm_event_posted = 0;\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\n}\r\ndo {\r\nspin_lock_irqsave(&sclp_lock, flags);\r\nlist_for_each_entry(reg, &sclp_reg_list, list) {\r\nif (rollback && reg->pm_event_posted)\r\ngoto found;\r\nif (!rollback && !reg->pm_event_posted)\r\ngoto found;\r\n}\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nreturn;\r\nfound:\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nif (reg->pm_event_fn)\r\nreg->pm_event_fn(reg, sclp_pm_event);\r\nreg->pm_event_posted = rollback ? 0 : 1;\r\n} while (1);\r\n}\r\nstatic int sclp_freeze(struct device *dev)\r\n{\r\nunsigned long flags;\r\nint rc;\r\nsclp_pm_event(SCLP_PM_EVENT_FREEZE, 0);\r\nspin_lock_irqsave(&sclp_lock, flags);\r\nsclp_suspend_state = sclp_suspend_state_suspended;\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nmemset(&sclp_suspend_req, 0, sizeof(sclp_suspend_req));\r\nsclp_suspend_req.callback = sclp_suspend_req_cb;\r\nsclp_suspend_req.status = SCLP_REQ_FILLED;\r\ninit_completion(&sclp_request_queue_flushed);\r\nrc = sclp_add_request(&sclp_suspend_req);\r\nif (rc == 0)\r\nwait_for_completion(&sclp_request_queue_flushed);\r\nelse if (rc != -ENODATA)\r\ngoto fail_thaw;\r\nrc = sclp_deactivate();\r\nif (rc)\r\ngoto fail_thaw;\r\nreturn 0;\r\nfail_thaw:\r\nspin_lock_irqsave(&sclp_lock, flags);\r\nsclp_suspend_state = sclp_suspend_state_running;\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nsclp_pm_event(SCLP_PM_EVENT_THAW, 1);\r\nreturn rc;\r\n}\r\nstatic int sclp_undo_suspend(enum sclp_pm_event event)\r\n{\r\nunsigned long flags;\r\nint rc;\r\nrc = sclp_reactivate();\r\nif (rc)\r\nreturn rc;\r\nspin_lock_irqsave(&sclp_lock, flags);\r\nsclp_suspend_state = sclp_suspend_state_running;\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nsclp_pm_event(event, 0);\r\nreturn 0;\r\n}\r\nstatic int sclp_thaw(struct device *dev)\r\n{\r\nreturn sclp_undo_suspend(SCLP_PM_EVENT_THAW);\r\n}\r\nstatic int sclp_restore(struct device *dev)\r\n{\r\nreturn sclp_undo_suspend(SCLP_PM_EVENT_RESTORE);\r\n}\r\nstatic ssize_t sclp_show_console_pages(struct device_driver *dev, char *buf)\r\n{\r\nreturn sprintf(buf, "%i\n", sclp_console_pages);\r\n}\r\nstatic ssize_t sclp_show_con_drop(struct device_driver *dev, char *buf)\r\n{\r\nreturn sprintf(buf, "%i\n", sclp_console_drop);\r\n}\r\nstatic ssize_t sclp_show_console_full(struct device_driver *dev, char *buf)\r\n{\r\nreturn sprintf(buf, "%lu\n", sclp_console_full);\r\n}\r\nstatic int\r\nsclp_init(void)\r\n{\r\nunsigned long flags;\r\nint rc = 0;\r\nspin_lock_irqsave(&sclp_lock, flags);\r\nif (sclp_init_state != sclp_init_state_uninitialized)\r\ngoto fail_unlock;\r\nsclp_init_state = sclp_init_state_initializing;\r\nINIT_LIST_HEAD(&sclp_req_queue);\r\nINIT_LIST_HEAD(&sclp_reg_list);\r\nlist_add(&sclp_state_change_event.list, &sclp_reg_list);\r\ninit_timer(&sclp_request_timer);\r\ninit_timer(&sclp_queue_timer);\r\nsclp_queue_timer.function = sclp_req_queue_timeout;\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nrc = sclp_check_interface();\r\nspin_lock_irqsave(&sclp_lock, flags);\r\nif (rc)\r\ngoto fail_init_state_uninitialized;\r\nrc = register_reboot_notifier(&sclp_reboot_notifier);\r\nif (rc)\r\ngoto fail_init_state_uninitialized;\r\nrc = register_external_irq(EXT_IRQ_SERVICE_SIG, sclp_interrupt_handler);\r\nif (rc)\r\ngoto fail_unregister_reboot_notifier;\r\nsclp_init_state = sclp_init_state_initialized;\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nirq_subclass_register(IRQ_SUBCLASS_SERVICE_SIGNAL);\r\nsclp_init_mask(1);\r\nreturn 0;\r\nfail_unregister_reboot_notifier:\r\nunregister_reboot_notifier(&sclp_reboot_notifier);\r\nfail_init_state_uninitialized:\r\nsclp_init_state = sclp_init_state_uninitialized;\r\nfail_unlock:\r\nspin_unlock_irqrestore(&sclp_lock, flags);\r\nreturn rc;\r\n}\r\nstatic int sclp_panic_notify(struct notifier_block *self,\r\nunsigned long event, void *data)\r\n{\r\nif (sclp_suspend_state == sclp_suspend_state_suspended)\r\nsclp_undo_suspend(SCLP_PM_EVENT_THAW);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic __init int sclp_initcall(void)\r\n{\r\nint rc;\r\nrc = platform_driver_register(&sclp_pdrv);\r\nif (rc)\r\nreturn rc;\r\nsclp_pdev = platform_device_register_simple("sclp", -1, NULL, 0);\r\nrc = PTR_ERR_OR_ZERO(sclp_pdev);\r\nif (rc)\r\ngoto fail_platform_driver_unregister;\r\nrc = atomic_notifier_chain_register(&panic_notifier_list,\r\n&sclp_on_panic_nb);\r\nif (rc)\r\ngoto fail_platform_device_unregister;\r\nreturn sclp_init();\r\nfail_platform_device_unregister:\r\nplatform_device_unregister(sclp_pdev);\r\nfail_platform_driver_unregister:\r\nplatform_driver_unregister(&sclp_pdrv);\r\nreturn rc;\r\n}
