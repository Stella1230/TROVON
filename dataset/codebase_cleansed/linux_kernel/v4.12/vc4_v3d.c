int vc4_v3d_debugfs_regs(struct seq_file *m, void *unused)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *)m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nstruct vc4_dev *vc4 = to_vc4_dev(dev);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(vc4_reg_defs); i++) {\r\nseq_printf(m, "%s (0x%04x): 0x%08x\n",\r\nvc4_reg_defs[i].name, vc4_reg_defs[i].reg,\r\nV3D_READ(vc4_reg_defs[i].reg));\r\n}\r\nreturn 0;\r\n}\r\nint vc4_v3d_debugfs_ident(struct seq_file *m, void *unused)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *)m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nstruct vc4_dev *vc4 = to_vc4_dev(dev);\r\nuint32_t ident1 = V3D_READ(V3D_IDENT1);\r\nuint32_t nslc = VC4_GET_FIELD(ident1, V3D_IDENT1_NSLC);\r\nuint32_t tups = VC4_GET_FIELD(ident1, V3D_IDENT1_TUPS);\r\nuint32_t qups = VC4_GET_FIELD(ident1, V3D_IDENT1_QUPS);\r\nseq_printf(m, "Revision: %d\n",\r\nVC4_GET_FIELD(ident1, V3D_IDENT1_REV));\r\nseq_printf(m, "Slices: %d\n", nslc);\r\nseq_printf(m, "TMUs: %d\n", nslc * tups);\r\nseq_printf(m, "QPUs: %d\n", nslc * qups);\r\nseq_printf(m, "Semaphores: %d\n",\r\nVC4_GET_FIELD(ident1, V3D_IDENT1_NSEM));\r\nreturn 0;\r\n}\r\nstatic void vc4_v3d_init_hw(struct drm_device *dev)\r\n{\r\nstruct vc4_dev *vc4 = to_vc4_dev(dev);\r\nV3D_WRITE(V3D_VPMBASE, 0);\r\n}\r\nstatic int vc4_v3d_runtime_suspend(struct device *dev)\r\n{\r\nstruct vc4_v3d *v3d = dev_get_drvdata(dev);\r\nstruct vc4_dev *vc4 = v3d->vc4;\r\nvc4_irq_uninstall(vc4->dev);\r\nreturn 0;\r\n}\r\nstatic int vc4_v3d_runtime_resume(struct device *dev)\r\n{\r\nstruct vc4_v3d *v3d = dev_get_drvdata(dev);\r\nstruct vc4_dev *vc4 = v3d->vc4;\r\nvc4_v3d_init_hw(vc4->dev);\r\nvc4_irq_postinstall(vc4->dev);\r\nreturn 0;\r\n}\r\nstatic int vc4_v3d_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct drm_device *drm = dev_get_drvdata(master);\r\nstruct vc4_dev *vc4 = to_vc4_dev(drm);\r\nstruct vc4_v3d *v3d = NULL;\r\nint ret;\r\nv3d = devm_kzalloc(&pdev->dev, sizeof(*v3d), GFP_KERNEL);\r\nif (!v3d)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(dev, v3d);\r\nv3d->pdev = pdev;\r\nv3d->regs = vc4_ioremap_regs(pdev, 0);\r\nif (IS_ERR(v3d->regs))\r\nreturn PTR_ERR(v3d->regs);\r\nvc4->v3d = v3d;\r\nv3d->vc4 = vc4;\r\nif (V3D_READ(V3D_IDENT0) != V3D_EXPECTED_IDENT0) {\r\nDRM_ERROR("V3D_IDENT0 read 0x%08x instead of 0x%08x\n",\r\nV3D_READ(V3D_IDENT0), V3D_EXPECTED_IDENT0);\r\nreturn -EINVAL;\r\n}\r\nV3D_WRITE(V3D_BPOA, 0);\r\nV3D_WRITE(V3D_BPOS, 0);\r\nvc4_v3d_init_hw(drm);\r\nret = drm_irq_install(drm, platform_get_irq(pdev, 0));\r\nif (ret) {\r\nDRM_ERROR("Failed to install IRQ handler\n");\r\nreturn ret;\r\n}\r\npm_runtime_use_autosuspend(dev);\r\npm_runtime_set_autosuspend_delay(dev, 40);\r\npm_runtime_enable(dev);\r\nreturn 0;\r\n}\r\nstatic void vc4_v3d_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct drm_device *drm = dev_get_drvdata(master);\r\nstruct vc4_dev *vc4 = to_vc4_dev(drm);\r\npm_runtime_disable(dev);\r\ndrm_irq_uninstall(drm);\r\nV3D_WRITE(V3D_BPOA, 0);\r\nV3D_WRITE(V3D_BPOS, 0);\r\nvc4->v3d = NULL;\r\n}\r\nstatic int vc4_v3d_dev_probe(struct platform_device *pdev)\r\n{\r\nreturn component_add(&pdev->dev, &vc4_v3d_ops);\r\n}\r\nstatic int vc4_v3d_dev_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &vc4_v3d_ops);\r\nreturn 0;\r\n}
