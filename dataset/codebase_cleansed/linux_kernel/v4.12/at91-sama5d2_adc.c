static unsigned at91_adc_startup_time(unsigned startup_time_min,\r\nunsigned adc_clk_khz)\r\n{\r\nconst unsigned startup_lookup[] = {\r\n0, 8, 16, 24,\r\n64, 80, 96, 112,\r\n512, 576, 640, 704,\r\n768, 832, 896, 960\r\n};\r\nunsigned ticks_min, i;\r\nticks_min = startup_time_min * adc_clk_khz / 1000;\r\nfor (i = 0; i < ARRAY_SIZE(startup_lookup); i++)\r\nif (startup_lookup[i] > ticks_min)\r\nbreak;\r\nreturn i;\r\n}\r\nstatic void at91_adc_setup_samp_freq(struct at91_adc_state *st, unsigned freq)\r\n{\r\nstruct iio_dev *indio_dev = iio_priv_to_dev(st);\r\nunsigned f_per, prescal, startup, mr;\r\nf_per = clk_get_rate(st->per_clk);\r\nprescal = (f_per / (2 * freq)) - 1;\r\nstartup = at91_adc_startup_time(st->soc_info.startup_time,\r\nfreq / 1000);\r\nmr = at91_adc_readl(st, AT91_SAMA5D2_MR);\r\nmr &= ~(AT91_SAMA5D2_MR_STARTUP_MASK | AT91_SAMA5D2_MR_PRESCAL_MASK);\r\nmr |= AT91_SAMA5D2_MR_STARTUP(startup);\r\nmr |= AT91_SAMA5D2_MR_PRESCAL(prescal);\r\nat91_adc_writel(st, AT91_SAMA5D2_MR, mr);\r\ndev_dbg(&indio_dev->dev, "freq: %u, startup: %u, prescal: %u\n",\r\nfreq, startup, prescal);\r\n}\r\nstatic unsigned at91_adc_get_sample_freq(struct at91_adc_state *st)\r\n{\r\nunsigned f_adc, f_per = clk_get_rate(st->per_clk);\r\nunsigned mr, prescal;\r\nmr = at91_adc_readl(st, AT91_SAMA5D2_MR);\r\nprescal = (mr >> AT91_SAMA5D2_MR_PRESCAL_OFFSET)\r\n& AT91_SAMA5D2_MR_PRESCAL_MAX;\r\nf_adc = f_per / (2 * (prescal + 1));\r\nreturn f_adc;\r\n}\r\nstatic irqreturn_t at91_adc_interrupt(int irq, void *private)\r\n{\r\nstruct iio_dev *indio = private;\r\nstruct at91_adc_state *st = iio_priv(indio);\r\nu32 status = at91_adc_readl(st, AT91_SAMA5D2_ISR);\r\nu32 imr = at91_adc_readl(st, AT91_SAMA5D2_IMR);\r\nif (status & imr) {\r\nst->conversion_value = at91_adc_readl(st, st->chan->address);\r\nst->conversion_done = true;\r\nwake_up_interruptible(&st->wq_data_available);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic int at91_adc_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct at91_adc_state *st = iio_priv(indio_dev);\r\nu32 cor = 0;\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nmutex_lock(&st->lock);\r\nst->chan = chan;\r\nif (chan->differential)\r\ncor = (BIT(chan->channel) | BIT(chan->channel2)) <<\r\nAT91_SAMA5D2_COR_DIFF_OFFSET;\r\nat91_adc_writel(st, AT91_SAMA5D2_COR, cor);\r\nat91_adc_writel(st, AT91_SAMA5D2_CHER, BIT(chan->channel));\r\nat91_adc_writel(st, AT91_SAMA5D2_IER, BIT(chan->channel));\r\nat91_adc_writel(st, AT91_SAMA5D2_CR, AT91_SAMA5D2_CR_START);\r\nret = wait_event_interruptible_timeout(st->wq_data_available,\r\nst->conversion_done,\r\nmsecs_to_jiffies(1000));\r\nif (ret == 0)\r\nret = -ETIMEDOUT;\r\nif (ret > 0) {\r\n*val = st->conversion_value;\r\nif (chan->scan_type.sign == 's')\r\n*val = sign_extend32(*val, 11);\r\nret = IIO_VAL_INT;\r\nst->conversion_done = false;\r\n}\r\nat91_adc_writel(st, AT91_SAMA5D2_IDR, BIT(chan->channel));\r\nat91_adc_writel(st, AT91_SAMA5D2_CHDR, BIT(chan->channel));\r\nmutex_unlock(&st->lock);\r\nreturn ret;\r\ncase IIO_CHAN_INFO_SCALE:\r\n*val = st->vref_uv / 1000;\r\nif (chan->differential)\r\n*val *= 2;\r\n*val2 = chan->scan_type.realbits;\r\nreturn IIO_VAL_FRACTIONAL_LOG2;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\n*val = at91_adc_get_sample_freq(st);\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int at91_adc_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val, int val2, long mask)\r\n{\r\nstruct at91_adc_state *st = iio_priv(indio_dev);\r\nif (mask != IIO_CHAN_INFO_SAMP_FREQ)\r\nreturn -EINVAL;\r\nif (val < st->soc_info.min_sample_rate ||\r\nval > st->soc_info.max_sample_rate)\r\nreturn -EINVAL;\r\nat91_adc_setup_samp_freq(st, val);\r\nreturn 0;\r\n}\r\nstatic int at91_adc_probe(struct platform_device *pdev)\r\n{\r\nstruct iio_dev *indio_dev;\r\nstruct at91_adc_state *st;\r\nstruct resource *res;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*st));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nindio_dev->dev.parent = &pdev->dev;\r\nindio_dev->name = dev_name(&pdev->dev);\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->info = &at91_adc_info;\r\nindio_dev->channels = at91_adc_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(at91_adc_channels);\r\nst = iio_priv(indio_dev);\r\nret = of_property_read_u32(pdev->dev.of_node,\r\n"atmel,min-sample-rate-hz",\r\n&st->soc_info.min_sample_rate);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"invalid or missing value for atmel,min-sample-rate-hz\n");\r\nreturn ret;\r\n}\r\nret = of_property_read_u32(pdev->dev.of_node,\r\n"atmel,max-sample-rate-hz",\r\n&st->soc_info.max_sample_rate);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"invalid or missing value for atmel,max-sample-rate-hz\n");\r\nreturn ret;\r\n}\r\nret = of_property_read_u32(pdev->dev.of_node, "atmel,startup-time-ms",\r\n&st->soc_info.startup_time);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"invalid or missing value for atmel,startup-time-ms\n");\r\nreturn ret;\r\n}\r\ninit_waitqueue_head(&st->wq_data_available);\r\nmutex_init(&st->lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -EINVAL;\r\nst->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(st->base))\r\nreturn PTR_ERR(st->base);\r\nst->irq = platform_get_irq(pdev, 0);\r\nif (st->irq <= 0) {\r\nif (!st->irq)\r\nst->irq = -ENXIO;\r\nreturn st->irq;\r\n}\r\nst->per_clk = devm_clk_get(&pdev->dev, "adc_clk");\r\nif (IS_ERR(st->per_clk))\r\nreturn PTR_ERR(st->per_clk);\r\nst->reg = devm_regulator_get(&pdev->dev, "vddana");\r\nif (IS_ERR(st->reg))\r\nreturn PTR_ERR(st->reg);\r\nst->vref = devm_regulator_get(&pdev->dev, "vref");\r\nif (IS_ERR(st->vref))\r\nreturn PTR_ERR(st->vref);\r\nret = devm_request_irq(&pdev->dev, st->irq, at91_adc_interrupt, 0,\r\npdev->dev.driver->name, indio_dev);\r\nif (ret)\r\nreturn ret;\r\nret = regulator_enable(st->reg);\r\nif (ret)\r\nreturn ret;\r\nret = regulator_enable(st->vref);\r\nif (ret)\r\ngoto reg_disable;\r\nst->vref_uv = regulator_get_voltage(st->vref);\r\nif (st->vref_uv <= 0) {\r\nret = -EINVAL;\r\ngoto vref_disable;\r\n}\r\nat91_adc_writel(st, AT91_SAMA5D2_CR, AT91_SAMA5D2_CR_SWRST);\r\nat91_adc_writel(st, AT91_SAMA5D2_IDR, 0xffffffff);\r\nat91_adc_writel(st, AT91_SAMA5D2_MR,\r\nAT91_SAMA5D2_MR_TRANSFER(2) | AT91_SAMA5D2_MR_ANACH);\r\nat91_adc_setup_samp_freq(st, st->soc_info.min_sample_rate);\r\nret = clk_prepare_enable(st->per_clk);\r\nif (ret)\r\ngoto vref_disable;\r\nplatform_set_drvdata(pdev, indio_dev);\r\nret = iio_device_register(indio_dev);\r\nif (ret < 0)\r\ngoto per_clk_disable_unprepare;\r\ndev_info(&pdev->dev, "version: %x\n",\r\nreadl_relaxed(st->base + AT91_SAMA5D2_VERSION));\r\nreturn 0;\r\nper_clk_disable_unprepare:\r\nclk_disable_unprepare(st->per_clk);\r\nvref_disable:\r\nregulator_disable(st->vref);\r\nreg_disable:\r\nregulator_disable(st->reg);\r\nreturn ret;\r\n}\r\nstatic int at91_adc_remove(struct platform_device *pdev)\r\n{\r\nstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\r\nstruct at91_adc_state *st = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\nclk_disable_unprepare(st->per_clk);\r\nregulator_disable(st->vref);\r\nregulator_disable(st->reg);\r\nreturn 0;\r\n}
