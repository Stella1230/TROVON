static int tse850_get_mux1(struct snd_kcontrol *kctrl,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kctrl);\r\nstruct snd_soc_card *card = dapm->card;\r\nstruct tse850_priv *tse850 = snd_soc_card_get_drvdata(card);\r\nucontrol->value.enumerated.item[0] = tse850->loop1_cache;\r\nreturn 0;\r\n}\r\nstatic int tse850_put_mux1(struct snd_kcontrol *kctrl,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kctrl);\r\nstruct snd_soc_card *card = dapm->card;\r\nstruct tse850_priv *tse850 = snd_soc_card_get_drvdata(card);\r\nstruct soc_enum *e = (struct soc_enum *)kctrl->private_value;\r\nunsigned int val = ucontrol->value.enumerated.item[0];\r\nif (val >= e->items)\r\nreturn -EINVAL;\r\ngpiod_set_value_cansleep(tse850->loop1, val);\r\ntse850->loop1_cache = val;\r\nreturn snd_soc_dapm_put_enum_double(kctrl, ucontrol);\r\n}\r\nstatic int tse850_get_mux2(struct snd_kcontrol *kctrl,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kctrl);\r\nstruct snd_soc_card *card = dapm->card;\r\nstruct tse850_priv *tse850 = snd_soc_card_get_drvdata(card);\r\nucontrol->value.enumerated.item[0] = tse850->loop2_cache;\r\nreturn 0;\r\n}\r\nstatic int tse850_put_mux2(struct snd_kcontrol *kctrl,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kctrl);\r\nstruct snd_soc_card *card = dapm->card;\r\nstruct tse850_priv *tse850 = snd_soc_card_get_drvdata(card);\r\nstruct soc_enum *e = (struct soc_enum *)kctrl->private_value;\r\nunsigned int val = ucontrol->value.enumerated.item[0];\r\nif (val >= e->items)\r\nreturn -EINVAL;\r\ngpiod_set_value_cansleep(tse850->loop2, val);\r\ntse850->loop2_cache = val;\r\nreturn snd_soc_dapm_put_enum_double(kctrl, ucontrol);\r\n}\r\nint tse850_get_mix(struct snd_kcontrol *kctrl,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kctrl);\r\nstruct snd_soc_card *card = dapm->card;\r\nstruct tse850_priv *tse850 = snd_soc_card_get_drvdata(card);\r\nucontrol->value.enumerated.item[0] = tse850->add_cache;\r\nreturn 0;\r\n}\r\nint tse850_put_mix(struct snd_kcontrol *kctrl,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kctrl);\r\nstruct snd_soc_card *card = dapm->card;\r\nstruct tse850_priv *tse850 = snd_soc_card_get_drvdata(card);\r\nint connect = !!ucontrol->value.integer.value[0];\r\nif (tse850->add_cache == connect)\r\nreturn 0;\r\ngpiod_set_value_cansleep(tse850->add, connect);\r\ntse850->add_cache = connect;\r\nsnd_soc_dapm_mixer_update_power(dapm, kctrl, connect, NULL);\r\nreturn 1;\r\n}\r\nint tse850_get_ana(struct snd_kcontrol *kctrl,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kctrl);\r\nstruct snd_soc_card *card = dapm->card;\r\nstruct tse850_priv *tse850 = snd_soc_card_get_drvdata(card);\r\nint ret;\r\nret = regulator_get_voltage(tse850->ana);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret < 11000000)\r\nret = 11000000;\r\nelse if (ret > 20000000)\r\nret = 20000000;\r\nret -= 11000000;\r\nret = (ret + 500000) / 1000000;\r\nucontrol->value.enumerated.item[0] = ret;\r\nreturn 0;\r\n}\r\nint tse850_put_ana(struct snd_kcontrol *kctrl,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kctrl);\r\nstruct snd_soc_card *card = dapm->card;\r\nstruct tse850_priv *tse850 = snd_soc_card_get_drvdata(card);\r\nstruct soc_enum *e = (struct soc_enum *)kctrl->private_value;\r\nunsigned int uV = ucontrol->value.enumerated.item[0];\r\nint ret;\r\nif (uV >= e->items)\r\nreturn -EINVAL;\r\nif (uV)\r\nuV = 11000000 + (1000000 * uV);\r\nelse\r\nuV = 2000000;\r\nret = regulator_set_voltage(tse850->ana, uV, uV);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn snd_soc_dapm_put_enum_double(kctrl, ucontrol);\r\n}\r\nstatic int tse850_dt_init(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device_node *codec_np, *cpu_np;\r\nstruct snd_soc_dai_link *dailink = &tse850_dailink;\r\nif (!np) {\r\ndev_err(&pdev->dev, "only device tree supported\n");\r\nreturn -EINVAL;\r\n}\r\ncpu_np = of_parse_phandle(np, "axentia,cpu-dai", 0);\r\nif (!cpu_np) {\r\ndev_err(&pdev->dev, "failed to get cpu dai\n");\r\nreturn -EINVAL;\r\n}\r\ndailink->cpu_of_node = cpu_np;\r\ndailink->platform_of_node = cpu_np;\r\nof_node_put(cpu_np);\r\ncodec_np = of_parse_phandle(np, "axentia,audio-codec", 0);\r\nif (!codec_np) {\r\ndev_err(&pdev->dev, "failed to get codec info\n");\r\nreturn -EINVAL;\r\n}\r\ndailink->codec_of_node = codec_np;\r\nof_node_put(codec_np);\r\nreturn 0;\r\n}\r\nstatic int tse850_probe(struct platform_device *pdev)\r\n{\r\nstruct snd_soc_card *card = &tse850_card;\r\nstruct device *dev = card->dev = &pdev->dev;\r\nstruct tse850_priv *tse850;\r\nint ret;\r\ntse850 = devm_kzalloc(dev, sizeof(*tse850), GFP_KERNEL);\r\nif (!tse850)\r\nreturn -ENOMEM;\r\nsnd_soc_card_set_drvdata(card, tse850);\r\nret = tse850_dt_init(pdev);\r\nif (ret) {\r\ndev_err(dev, "failed to init dt info\n");\r\nreturn ret;\r\n}\r\ntse850->add = devm_gpiod_get(dev, "axentia,add", GPIOD_OUT_HIGH);\r\nif (IS_ERR(tse850->add)) {\r\nif (PTR_ERR(tse850->add) != -EPROBE_DEFER)\r\ndev_err(dev, "failed to get 'add' gpio\n");\r\nreturn PTR_ERR(tse850->add);\r\n}\r\ntse850->add_cache = 1;\r\ntse850->loop1 = devm_gpiod_get(dev, "axentia,loop1", GPIOD_OUT_HIGH);\r\nif (IS_ERR(tse850->loop1)) {\r\nif (PTR_ERR(tse850->loop1) != -EPROBE_DEFER)\r\ndev_err(dev, "failed to get 'loop1' gpio\n");\r\nreturn PTR_ERR(tse850->loop1);\r\n}\r\ntse850->loop1_cache = 1;\r\ntse850->loop2 = devm_gpiod_get(dev, "axentia,loop2", GPIOD_OUT_HIGH);\r\nif (IS_ERR(tse850->loop2)) {\r\nif (PTR_ERR(tse850->loop2) != -EPROBE_DEFER)\r\ndev_err(dev, "failed to get 'loop2' gpio\n");\r\nreturn PTR_ERR(tse850->loop2);\r\n}\r\ntse850->loop2_cache = 1;\r\ntse850->ana = devm_regulator_get(dev, "axentia,ana");\r\nif (IS_ERR(tse850->ana)) {\r\nif (PTR_ERR(tse850->ana) != -EPROBE_DEFER)\r\ndev_err(dev, "failed to get 'ana' regulator\n");\r\nreturn PTR_ERR(tse850->ana);\r\n}\r\nret = regulator_enable(tse850->ana);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to enable the 'ana' regulator\n");\r\nreturn ret;\r\n}\r\nret = snd_soc_register_card(card);\r\nif (ret) {\r\ndev_err(dev, "snd_soc_register_card failed\n");\r\ngoto err_disable_ana;\r\n}\r\nreturn 0;\r\nerr_disable_ana:\r\nregulator_disable(tse850->ana);\r\nreturn ret;\r\n}\r\nstatic int tse850_remove(struct platform_device *pdev)\r\n{\r\nstruct snd_soc_card *card = platform_get_drvdata(pdev);\r\nstruct tse850_priv *tse850 = snd_soc_card_get_drvdata(card);\r\nsnd_soc_unregister_card(card);\r\nregulator_disable(tse850->ana);\r\nreturn 0;\r\n}
