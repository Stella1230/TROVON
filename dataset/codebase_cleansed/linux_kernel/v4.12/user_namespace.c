static struct ucounts *inc_user_namespaces(struct user_namespace *ns, kuid_t uid)\r\n{\r\nreturn inc_ucount(ns, uid, UCOUNT_USER_NAMESPACES);\r\n}\r\nstatic void dec_user_namespaces(struct ucounts *ucounts)\r\n{\r\nreturn dec_ucount(ucounts, UCOUNT_USER_NAMESPACES);\r\n}\r\nstatic void set_cred_user_ns(struct cred *cred, struct user_namespace *user_ns)\r\n{\r\ncred->securebits = SECUREBITS_DEFAULT;\r\ncred->cap_inheritable = CAP_EMPTY_SET;\r\ncred->cap_permitted = CAP_FULL_SET;\r\ncred->cap_effective = CAP_FULL_SET;\r\ncred->cap_ambient = CAP_EMPTY_SET;\r\ncred->cap_bset = CAP_FULL_SET;\r\n#ifdef CONFIG_KEYS\r\nkey_put(cred->request_key_auth);\r\ncred->request_key_auth = NULL;\r\n#endif\r\ncred->user_ns = user_ns;\r\n}\r\nint create_user_ns(struct cred *new)\r\n{\r\nstruct user_namespace *ns, *parent_ns = new->user_ns;\r\nkuid_t owner = new->euid;\r\nkgid_t group = new->egid;\r\nstruct ucounts *ucounts;\r\nint ret, i;\r\nret = -ENOSPC;\r\nif (parent_ns->level > 32)\r\ngoto fail;\r\nucounts = inc_user_namespaces(parent_ns, owner);\r\nif (!ucounts)\r\ngoto fail;\r\nret = -EPERM;\r\nif (current_chrooted())\r\ngoto fail_dec;\r\nret = -EPERM;\r\nif (!kuid_has_mapping(parent_ns, owner) ||\r\n!kgid_has_mapping(parent_ns, group))\r\ngoto fail_dec;\r\nret = -ENOMEM;\r\nns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);\r\nif (!ns)\r\ngoto fail_dec;\r\nret = ns_alloc_inum(&ns->ns);\r\nif (ret)\r\ngoto fail_free;\r\nns->ns.ops = &userns_operations;\r\natomic_set(&ns->count, 1);\r\nns->parent = parent_ns;\r\nns->level = parent_ns->level + 1;\r\nns->owner = owner;\r\nns->group = group;\r\nINIT_WORK(&ns->work, free_user_ns);\r\nfor (i = 0; i < UCOUNT_COUNTS; i++) {\r\nns->ucount_max[i] = INT_MAX;\r\n}\r\nns->ucounts = ucounts;\r\nmutex_lock(&userns_state_mutex);\r\nns->flags = parent_ns->flags;\r\nmutex_unlock(&userns_state_mutex);\r\n#ifdef CONFIG_PERSISTENT_KEYRINGS\r\ninit_rwsem(&ns->persistent_keyring_register_sem);\r\n#endif\r\nret = -ENOMEM;\r\nif (!setup_userns_sysctls(ns))\r\ngoto fail_keyring;\r\nset_cred_user_ns(new, ns);\r\nreturn 0;\r\nfail_keyring:\r\n#ifdef CONFIG_PERSISTENT_KEYRINGS\r\nkey_put(ns->persistent_keyring_register);\r\n#endif\r\nns_free_inum(&ns->ns);\r\nfail_free:\r\nkmem_cache_free(user_ns_cachep, ns);\r\nfail_dec:\r\ndec_user_namespaces(ucounts);\r\nfail:\r\nreturn ret;\r\n}\r\nint unshare_userns(unsigned long unshare_flags, struct cred **new_cred)\r\n{\r\nstruct cred *cred;\r\nint err = -ENOMEM;\r\nif (!(unshare_flags & CLONE_NEWUSER))\r\nreturn 0;\r\ncred = prepare_creds();\r\nif (cred) {\r\nerr = create_user_ns(cred);\r\nif (err)\r\nput_cred(cred);\r\nelse\r\n*new_cred = cred;\r\n}\r\nreturn err;\r\n}\r\nstatic void free_user_ns(struct work_struct *work)\r\n{\r\nstruct user_namespace *parent, *ns =\r\ncontainer_of(work, struct user_namespace, work);\r\ndo {\r\nstruct ucounts *ucounts = ns->ucounts;\r\nparent = ns->parent;\r\nretire_userns_sysctls(ns);\r\n#ifdef CONFIG_PERSISTENT_KEYRINGS\r\nkey_put(ns->persistent_keyring_register);\r\n#endif\r\nns_free_inum(&ns->ns);\r\nkmem_cache_free(user_ns_cachep, ns);\r\ndec_user_namespaces(ucounts);\r\nns = parent;\r\n} while (atomic_dec_and_test(&parent->count));\r\n}\r\nvoid __put_user_ns(struct user_namespace *ns)\r\n{\r\nschedule_work(&ns->work);\r\n}\r\nstatic u32 map_id_range_down(struct uid_gid_map *map, u32 id, u32 count)\r\n{\r\nunsigned idx, extents;\r\nu32 first, last, id2;\r\nid2 = id + count - 1;\r\nextents = map->nr_extents;\r\nsmp_rmb();\r\nfor (idx = 0; idx < extents; idx++) {\r\nfirst = map->extent[idx].first;\r\nlast = first + map->extent[idx].count - 1;\r\nif (id >= first && id <= last &&\r\n(id2 >= first && id2 <= last))\r\nbreak;\r\n}\r\nif (idx < extents)\r\nid = (id - first) + map->extent[idx].lower_first;\r\nelse\r\nid = (u32) -1;\r\nreturn id;\r\n}\r\nstatic u32 map_id_down(struct uid_gid_map *map, u32 id)\r\n{\r\nunsigned idx, extents;\r\nu32 first, last;\r\nextents = map->nr_extents;\r\nsmp_rmb();\r\nfor (idx = 0; idx < extents; idx++) {\r\nfirst = map->extent[idx].first;\r\nlast = first + map->extent[idx].count - 1;\r\nif (id >= first && id <= last)\r\nbreak;\r\n}\r\nif (idx < extents)\r\nid = (id - first) + map->extent[idx].lower_first;\r\nelse\r\nid = (u32) -1;\r\nreturn id;\r\n}\r\nstatic u32 map_id_up(struct uid_gid_map *map, u32 id)\r\n{\r\nunsigned idx, extents;\r\nu32 first, last;\r\nextents = map->nr_extents;\r\nsmp_rmb();\r\nfor (idx = 0; idx < extents; idx++) {\r\nfirst = map->extent[idx].lower_first;\r\nlast = first + map->extent[idx].count - 1;\r\nif (id >= first && id <= last)\r\nbreak;\r\n}\r\nif (idx < extents)\r\nid = (id - first) + map->extent[idx].first;\r\nelse\r\nid = (u32) -1;\r\nreturn id;\r\n}\r\nkuid_t make_kuid(struct user_namespace *ns, uid_t uid)\r\n{\r\nreturn KUIDT_INIT(map_id_down(&ns->uid_map, uid));\r\n}\r\nuid_t from_kuid(struct user_namespace *targ, kuid_t kuid)\r\n{\r\nreturn map_id_up(&targ->uid_map, __kuid_val(kuid));\r\n}\r\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\r\n{\r\nuid_t uid;\r\nuid = from_kuid(targ, kuid);\r\nif (uid == (uid_t) -1)\r\nuid = overflowuid;\r\nreturn uid;\r\n}\r\nkgid_t make_kgid(struct user_namespace *ns, gid_t gid)\r\n{\r\nreturn KGIDT_INIT(map_id_down(&ns->gid_map, gid));\r\n}\r\ngid_t from_kgid(struct user_namespace *targ, kgid_t kgid)\r\n{\r\nreturn map_id_up(&targ->gid_map, __kgid_val(kgid));\r\n}\r\ngid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\r\n{\r\ngid_t gid;\r\ngid = from_kgid(targ, kgid);\r\nif (gid == (gid_t) -1)\r\ngid = overflowgid;\r\nreturn gid;\r\n}\r\nkprojid_t make_kprojid(struct user_namespace *ns, projid_t projid)\r\n{\r\nreturn KPROJIDT_INIT(map_id_down(&ns->projid_map, projid));\r\n}\r\nprojid_t from_kprojid(struct user_namespace *targ, kprojid_t kprojid)\r\n{\r\nreturn map_id_up(&targ->projid_map, __kprojid_val(kprojid));\r\n}\r\nprojid_t from_kprojid_munged(struct user_namespace *targ, kprojid_t kprojid)\r\n{\r\nprojid_t projid;\r\nprojid = from_kprojid(targ, kprojid);\r\nif (projid == (projid_t) -1)\r\nprojid = OVERFLOW_PROJID;\r\nreturn projid;\r\n}\r\nstatic int uid_m_show(struct seq_file *seq, void *v)\r\n{\r\nstruct user_namespace *ns = seq->private;\r\nstruct uid_gid_extent *extent = v;\r\nstruct user_namespace *lower_ns;\r\nuid_t lower;\r\nlower_ns = seq_user_ns(seq);\r\nif ((lower_ns == ns) && lower_ns->parent)\r\nlower_ns = lower_ns->parent;\r\nlower = from_kuid(lower_ns, KUIDT_INIT(extent->lower_first));\r\nseq_printf(seq, "%10u %10u %10u\n",\r\nextent->first,\r\nlower,\r\nextent->count);\r\nreturn 0;\r\n}\r\nstatic int gid_m_show(struct seq_file *seq, void *v)\r\n{\r\nstruct user_namespace *ns = seq->private;\r\nstruct uid_gid_extent *extent = v;\r\nstruct user_namespace *lower_ns;\r\ngid_t lower;\r\nlower_ns = seq_user_ns(seq);\r\nif ((lower_ns == ns) && lower_ns->parent)\r\nlower_ns = lower_ns->parent;\r\nlower = from_kgid(lower_ns, KGIDT_INIT(extent->lower_first));\r\nseq_printf(seq, "%10u %10u %10u\n",\r\nextent->first,\r\nlower,\r\nextent->count);\r\nreturn 0;\r\n}\r\nstatic int projid_m_show(struct seq_file *seq, void *v)\r\n{\r\nstruct user_namespace *ns = seq->private;\r\nstruct uid_gid_extent *extent = v;\r\nstruct user_namespace *lower_ns;\r\nprojid_t lower;\r\nlower_ns = seq_user_ns(seq);\r\nif ((lower_ns == ns) && lower_ns->parent)\r\nlower_ns = lower_ns->parent;\r\nlower = from_kprojid(lower_ns, KPROJIDT_INIT(extent->lower_first));\r\nseq_printf(seq, "%10u %10u %10u\n",\r\nextent->first,\r\nlower,\r\nextent->count);\r\nreturn 0;\r\n}\r\nstatic void *m_start(struct seq_file *seq, loff_t *ppos,\r\nstruct uid_gid_map *map)\r\n{\r\nstruct uid_gid_extent *extent = NULL;\r\nloff_t pos = *ppos;\r\nif (pos < map->nr_extents)\r\nextent = &map->extent[pos];\r\nreturn extent;\r\n}\r\nstatic void *uid_m_start(struct seq_file *seq, loff_t *ppos)\r\n{\r\nstruct user_namespace *ns = seq->private;\r\nreturn m_start(seq, ppos, &ns->uid_map);\r\n}\r\nstatic void *gid_m_start(struct seq_file *seq, loff_t *ppos)\r\n{\r\nstruct user_namespace *ns = seq->private;\r\nreturn m_start(seq, ppos, &ns->gid_map);\r\n}\r\nstatic void *projid_m_start(struct seq_file *seq, loff_t *ppos)\r\n{\r\nstruct user_namespace *ns = seq->private;\r\nreturn m_start(seq, ppos, &ns->projid_map);\r\n}\r\nstatic void *m_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\n(*pos)++;\r\nreturn seq->op->start(seq, pos);\r\n}\r\nstatic void m_stop(struct seq_file *seq, void *v)\r\n{\r\nreturn;\r\n}\r\nstatic bool mappings_overlap(struct uid_gid_map *new_map,\r\nstruct uid_gid_extent *extent)\r\n{\r\nu32 upper_first, lower_first, upper_last, lower_last;\r\nunsigned idx;\r\nupper_first = extent->first;\r\nlower_first = extent->lower_first;\r\nupper_last = upper_first + extent->count - 1;\r\nlower_last = lower_first + extent->count - 1;\r\nfor (idx = 0; idx < new_map->nr_extents; idx++) {\r\nu32 prev_upper_first, prev_lower_first;\r\nu32 prev_upper_last, prev_lower_last;\r\nstruct uid_gid_extent *prev;\r\nprev = &new_map->extent[idx];\r\nprev_upper_first = prev->first;\r\nprev_lower_first = prev->lower_first;\r\nprev_upper_last = prev_upper_first + prev->count - 1;\r\nprev_lower_last = prev_lower_first + prev->count - 1;\r\nif ((prev_upper_first <= upper_last) &&\r\n(prev_upper_last >= upper_first))\r\nreturn true;\r\nif ((prev_lower_first <= lower_last) &&\r\n(prev_lower_last >= lower_first))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic ssize_t map_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos,\r\nint cap_setid,\r\nstruct uid_gid_map *map,\r\nstruct uid_gid_map *parent_map)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct user_namespace *ns = seq->private;\r\nstruct uid_gid_map new_map;\r\nunsigned idx;\r\nstruct uid_gid_extent *extent = NULL;\r\nchar *kbuf = NULL, *pos, *next_line;\r\nssize_t ret = -EINVAL;\r\nmutex_lock(&userns_state_mutex);\r\nret = -EPERM;\r\nif (map->nr_extents != 0)\r\ngoto out;\r\nif (cap_valid(cap_setid) && !file_ns_capable(file, ns, CAP_SYS_ADMIN))\r\ngoto out;\r\nret = -EINVAL;\r\nif ((*ppos != 0) || (count >= PAGE_SIZE))\r\ngoto out;\r\nkbuf = memdup_user_nul(buf, count);\r\nif (IS_ERR(kbuf)) {\r\nret = PTR_ERR(kbuf);\r\nkbuf = NULL;\r\ngoto out;\r\n}\r\nret = -EINVAL;\r\npos = kbuf;\r\nnew_map.nr_extents = 0;\r\nfor (; pos; pos = next_line) {\r\nextent = &new_map.extent[new_map.nr_extents];\r\nnext_line = strchr(pos, '\n');\r\nif (next_line) {\r\n*next_line = '\0';\r\nnext_line++;\r\nif (*next_line == '\0')\r\nnext_line = NULL;\r\n}\r\npos = skip_spaces(pos);\r\nextent->first = simple_strtoul(pos, &pos, 10);\r\nif (!isspace(*pos))\r\ngoto out;\r\npos = skip_spaces(pos);\r\nextent->lower_first = simple_strtoul(pos, &pos, 10);\r\nif (!isspace(*pos))\r\ngoto out;\r\npos = skip_spaces(pos);\r\nextent->count = simple_strtoul(pos, &pos, 10);\r\nif (*pos && !isspace(*pos))\r\ngoto out;\r\npos = skip_spaces(pos);\r\nif (*pos != '\0')\r\ngoto out;\r\nif ((extent->first == (u32) -1) ||\r\n(extent->lower_first == (u32) -1))\r\ngoto out;\r\nif ((extent->first + extent->count) <= extent->first)\r\ngoto out;\r\nif ((extent->lower_first + extent->count) <=\r\nextent->lower_first)\r\ngoto out;\r\nif (mappings_overlap(&new_map, extent))\r\ngoto out;\r\nnew_map.nr_extents++;\r\nif ((new_map.nr_extents == UID_GID_MAP_MAX_EXTENTS) &&\r\n(next_line != NULL))\r\ngoto out;\r\n}\r\nif (new_map.nr_extents == 0)\r\ngoto out;\r\nret = -EPERM;\r\nif (!new_idmap_permitted(file, ns, cap_setid, &new_map))\r\ngoto out;\r\nfor (idx = 0; idx < new_map.nr_extents; idx++) {\r\nu32 lower_first;\r\nextent = &new_map.extent[idx];\r\nlower_first = map_id_range_down(parent_map,\r\nextent->lower_first,\r\nextent->count);\r\nif (lower_first == (u32) -1)\r\ngoto out;\r\nextent->lower_first = lower_first;\r\n}\r\nmemcpy(map->extent, new_map.extent,\r\nnew_map.nr_extents*sizeof(new_map.extent[0]));\r\nsmp_wmb();\r\nmap->nr_extents = new_map.nr_extents;\r\n*ppos = count;\r\nret = count;\r\nout:\r\nmutex_unlock(&userns_state_mutex);\r\nkfree(kbuf);\r\nreturn ret;\r\n}\r\nssize_t proc_uid_map_write(struct file *file, const char __user *buf,\r\nsize_t size, loff_t *ppos)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct user_namespace *ns = seq->private;\r\nstruct user_namespace *seq_ns = seq_user_ns(seq);\r\nif (!ns->parent)\r\nreturn -EPERM;\r\nif ((seq_ns != ns) && (seq_ns != ns->parent))\r\nreturn -EPERM;\r\nreturn map_write(file, buf, size, ppos, CAP_SETUID,\r\n&ns->uid_map, &ns->parent->uid_map);\r\n}\r\nssize_t proc_gid_map_write(struct file *file, const char __user *buf,\r\nsize_t size, loff_t *ppos)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct user_namespace *ns = seq->private;\r\nstruct user_namespace *seq_ns = seq_user_ns(seq);\r\nif (!ns->parent)\r\nreturn -EPERM;\r\nif ((seq_ns != ns) && (seq_ns != ns->parent))\r\nreturn -EPERM;\r\nreturn map_write(file, buf, size, ppos, CAP_SETGID,\r\n&ns->gid_map, &ns->parent->gid_map);\r\n}\r\nssize_t proc_projid_map_write(struct file *file, const char __user *buf,\r\nsize_t size, loff_t *ppos)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct user_namespace *ns = seq->private;\r\nstruct user_namespace *seq_ns = seq_user_ns(seq);\r\nif (!ns->parent)\r\nreturn -EPERM;\r\nif ((seq_ns != ns) && (seq_ns != ns->parent))\r\nreturn -EPERM;\r\nreturn map_write(file, buf, size, ppos, -1,\r\n&ns->projid_map, &ns->parent->projid_map);\r\n}\r\nstatic bool new_idmap_permitted(const struct file *file,\r\nstruct user_namespace *ns, int cap_setid,\r\nstruct uid_gid_map *new_map)\r\n{\r\nconst struct cred *cred = file->f_cred;\r\nif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1) &&\r\nuid_eq(ns->owner, cred->euid)) {\r\nu32 id = new_map->extent[0].lower_first;\r\nif (cap_setid == CAP_SETUID) {\r\nkuid_t uid = make_kuid(ns->parent, id);\r\nif (uid_eq(uid, cred->euid))\r\nreturn true;\r\n} else if (cap_setid == CAP_SETGID) {\r\nkgid_t gid = make_kgid(ns->parent, id);\r\nif (!(ns->flags & USERNS_SETGROUPS_ALLOWED) &&\r\ngid_eq(gid, cred->egid))\r\nreturn true;\r\n}\r\n}\r\nif (!cap_valid(cap_setid))\r\nreturn true;\r\nif (ns_capable(ns->parent, cap_setid) &&\r\nfile_ns_capable(file, ns->parent, cap_setid))\r\nreturn true;\r\nreturn false;\r\n}\r\nint proc_setgroups_show(struct seq_file *seq, void *v)\r\n{\r\nstruct user_namespace *ns = seq->private;\r\nunsigned long userns_flags = ACCESS_ONCE(ns->flags);\r\nseq_printf(seq, "%s\n",\r\n(userns_flags & USERNS_SETGROUPS_ALLOWED) ?\r\n"allow" : "deny");\r\nreturn 0;\r\n}\r\nssize_t proc_setgroups_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct user_namespace *ns = seq->private;\r\nchar kbuf[8], *pos;\r\nbool setgroups_allowed;\r\nssize_t ret;\r\nret = -EINVAL;\r\nif ((*ppos != 0) || (count >= sizeof(kbuf)))\r\ngoto out;\r\nret = -EFAULT;\r\nif (copy_from_user(kbuf, buf, count))\r\ngoto out;\r\nkbuf[count] = '\0';\r\npos = kbuf;\r\nret = -EINVAL;\r\nif (strncmp(pos, "allow", 5) == 0) {\r\npos += 5;\r\nsetgroups_allowed = true;\r\n}\r\nelse if (strncmp(pos, "deny", 4) == 0) {\r\npos += 4;\r\nsetgroups_allowed = false;\r\n}\r\nelse\r\ngoto out;\r\npos = skip_spaces(pos);\r\nif (*pos != '\0')\r\ngoto out;\r\nret = -EPERM;\r\nmutex_lock(&userns_state_mutex);\r\nif (setgroups_allowed) {\r\nif (!(ns->flags & USERNS_SETGROUPS_ALLOWED))\r\ngoto out_unlock;\r\n} else {\r\nif (ns->gid_map.nr_extents != 0)\r\ngoto out_unlock;\r\nns->flags &= ~USERNS_SETGROUPS_ALLOWED;\r\n}\r\nmutex_unlock(&userns_state_mutex);\r\n*ppos = count;\r\nret = count;\r\nout:\r\nreturn ret;\r\nout_unlock:\r\nmutex_unlock(&userns_state_mutex);\r\ngoto out;\r\n}\r\nbool userns_may_setgroups(const struct user_namespace *ns)\r\n{\r\nbool allowed;\r\nmutex_lock(&userns_state_mutex);\r\nallowed = ns->gid_map.nr_extents != 0;\r\nallowed = allowed && (ns->flags & USERNS_SETGROUPS_ALLOWED);\r\nmutex_unlock(&userns_state_mutex);\r\nreturn allowed;\r\n}\r\nbool current_in_userns(const struct user_namespace *target_ns)\r\n{\r\nstruct user_namespace *ns;\r\nfor (ns = current_user_ns(); ns; ns = ns->parent) {\r\nif (ns == target_ns)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic inline struct user_namespace *to_user_ns(struct ns_common *ns)\r\n{\r\nreturn container_of(ns, struct user_namespace, ns);\r\n}\r\nstatic struct ns_common *userns_get(struct task_struct *task)\r\n{\r\nstruct user_namespace *user_ns;\r\nrcu_read_lock();\r\nuser_ns = get_user_ns(__task_cred(task)->user_ns);\r\nrcu_read_unlock();\r\nreturn user_ns ? &user_ns->ns : NULL;\r\n}\r\nstatic void userns_put(struct ns_common *ns)\r\n{\r\nput_user_ns(to_user_ns(ns));\r\n}\r\nstatic int userns_install(struct nsproxy *nsproxy, struct ns_common *ns)\r\n{\r\nstruct user_namespace *user_ns = to_user_ns(ns);\r\nstruct cred *cred;\r\nif (user_ns == current_user_ns())\r\nreturn -EINVAL;\r\nif (!thread_group_empty(current))\r\nreturn -EINVAL;\r\nif (current->fs->users != 1)\r\nreturn -EINVAL;\r\nif (!ns_capable(user_ns, CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\ncred = prepare_creds();\r\nif (!cred)\r\nreturn -ENOMEM;\r\nput_user_ns(cred->user_ns);\r\nset_cred_user_ns(cred, get_user_ns(user_ns));\r\nreturn commit_creds(cred);\r\n}\r\nstruct ns_common *ns_get_owner(struct ns_common *ns)\r\n{\r\nstruct user_namespace *my_user_ns = current_user_ns();\r\nstruct user_namespace *owner, *p;\r\nowner = p = ns->ops->owner(ns);\r\nfor (;;) {\r\nif (!p)\r\nreturn ERR_PTR(-EPERM);\r\nif (p == my_user_ns)\r\nbreak;\r\np = p->parent;\r\n}\r\nreturn &get_user_ns(owner)->ns;\r\n}\r\nstatic struct user_namespace *userns_owner(struct ns_common *ns)\r\n{\r\nreturn to_user_ns(ns)->parent;\r\n}\r\nstatic __init int user_namespaces_init(void)\r\n{\r\nuser_ns_cachep = KMEM_CACHE(user_namespace, SLAB_PANIC);\r\nreturn 0;\r\n}
