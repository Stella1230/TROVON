static void fsl_lpspi_intctrl(struct fsl_lpspi_data *fsl_lpspi,\r\nunsigned int enable)\r\n{\r\nwritel(enable, fsl_lpspi->base + IMX7ULP_IER);\r\n}\r\nstatic int lpspi_prepare_xfer_hardware(struct spi_master *master)\r\n{\r\nstruct fsl_lpspi_data *fsl_lpspi = spi_master_get_devdata(master);\r\nreturn clk_prepare_enable(fsl_lpspi->clk);\r\n}\r\nstatic int lpspi_unprepare_xfer_hardware(struct spi_master *master)\r\n{\r\nstruct fsl_lpspi_data *fsl_lpspi = spi_master_get_devdata(master);\r\nclk_disable_unprepare(fsl_lpspi->clk);\r\nreturn 0;\r\n}\r\nstatic int fsl_lpspi_txfifo_empty(struct fsl_lpspi_data *fsl_lpspi)\r\n{\r\nu32 txcnt;\r\nunsigned long orig_jiffies = jiffies;\r\ndo {\r\ntxcnt = readl(fsl_lpspi->base + IMX7ULP_FSR) & 0xff;\r\nif (time_after(jiffies, orig_jiffies + msecs_to_jiffies(500))) {\r\ndev_dbg(fsl_lpspi->dev, "txfifo empty timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\ncond_resched();\r\n} while (txcnt);\r\nreturn 0;\r\n}\r\nstatic void fsl_lpspi_write_tx_fifo(struct fsl_lpspi_data *fsl_lpspi)\r\n{\r\nu8 txfifo_cnt;\r\ntxfifo_cnt = readl(fsl_lpspi->base + IMX7ULP_FSR) & 0xff;\r\nwhile (txfifo_cnt < fsl_lpspi->txfifosize) {\r\nif (!fsl_lpspi->remain)\r\nbreak;\r\nfsl_lpspi->tx(fsl_lpspi);\r\ntxfifo_cnt++;\r\n}\r\nif (!fsl_lpspi->remain && (txfifo_cnt < fsl_lpspi->txfifosize))\r\nwritel(0, fsl_lpspi->base + IMX7ULP_TDR);\r\nelse\r\nfsl_lpspi_intctrl(fsl_lpspi, IER_TDIE);\r\n}\r\nstatic void fsl_lpspi_read_rx_fifo(struct fsl_lpspi_data *fsl_lpspi)\r\n{\r\nwhile (!(readl(fsl_lpspi->base + IMX7ULP_RSR) & RSR_RXEMPTY))\r\nfsl_lpspi->rx(fsl_lpspi);\r\n}\r\nstatic void fsl_lpspi_set_cmd(struct fsl_lpspi_data *fsl_lpspi,\r\nbool is_first_xfer)\r\n{\r\nu32 temp = 0;\r\ntemp |= fsl_lpspi->config.bpw - 1;\r\ntemp |= fsl_lpspi->config.prescale << 27;\r\ntemp |= (fsl_lpspi->config.mode & 0x3) << 30;\r\ntemp |= (fsl_lpspi->config.chip_select & 0x3) << 24;\r\ntemp |= TCR_CONT;\r\nif (is_first_xfer)\r\ntemp &= ~TCR_CONTC;\r\nelse\r\ntemp |= TCR_CONTC;\r\nwritel(temp, fsl_lpspi->base + IMX7ULP_TCR);\r\ndev_dbg(fsl_lpspi->dev, "TCR=0x%x\n", temp);\r\n}\r\nstatic void fsl_lpspi_set_watermark(struct fsl_lpspi_data *fsl_lpspi)\r\n{\r\nu32 temp;\r\ntemp = fsl_lpspi->txfifosize >> 1 | (fsl_lpspi->rxfifosize >> 1) << 16;\r\nwritel(temp, fsl_lpspi->base + IMX7ULP_FCR);\r\ndev_dbg(fsl_lpspi->dev, "FCR=0x%x\n", temp);\r\n}\r\nstatic int fsl_lpspi_set_bitrate(struct fsl_lpspi_data *fsl_lpspi)\r\n{\r\nstruct lpspi_config config = fsl_lpspi->config;\r\nunsigned int perclk_rate, scldiv;\r\nu8 prescale;\r\nperclk_rate = clk_get_rate(fsl_lpspi->clk);\r\nfor (prescale = 0; prescale < 8; prescale++) {\r\nscldiv = perclk_rate /\r\n(clkdivs[prescale] * config.speed_hz) - 2;\r\nif (scldiv < 256) {\r\nfsl_lpspi->config.prescale = prescale;\r\nbreak;\r\n}\r\n}\r\nif (prescale == 8 && scldiv >= 256)\r\nreturn -EINVAL;\r\nwritel(scldiv, fsl_lpspi->base + IMX7ULP_CCR);\r\ndev_dbg(fsl_lpspi->dev, "perclk=%d, speed=%d, prescale =%d, scldiv=%d\n",\r\nperclk_rate, config.speed_hz, prescale, scldiv);\r\nreturn 0;\r\n}\r\nstatic int fsl_lpspi_config(struct fsl_lpspi_data *fsl_lpspi)\r\n{\r\nu32 temp;\r\nint ret;\r\ntemp = CR_RST;\r\nwritel(temp, fsl_lpspi->base + IMX7ULP_CR);\r\nwritel(0, fsl_lpspi->base + IMX7ULP_CR);\r\nret = fsl_lpspi_set_bitrate(fsl_lpspi);\r\nif (ret)\r\nreturn ret;\r\nfsl_lpspi_set_watermark(fsl_lpspi);\r\ntemp = CFGR1_PCSCFG | CFGR1_MASTER | CFGR1_NOSTALL;\r\nif (fsl_lpspi->config.mode & SPI_CS_HIGH)\r\ntemp |= CFGR1_PCSPOL;\r\nwritel(temp, fsl_lpspi->base + IMX7ULP_CFGR1);\r\ntemp = readl(fsl_lpspi->base + IMX7ULP_CR);\r\ntemp |= CR_RRF | CR_RTF | CR_MEN;\r\nwritel(temp, fsl_lpspi->base + IMX7ULP_CR);\r\nreturn 0;\r\n}\r\nstatic void fsl_lpspi_setup_transfer(struct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct fsl_lpspi_data *fsl_lpspi = spi_master_get_devdata(spi->master);\r\nfsl_lpspi->config.mode = spi->mode;\r\nfsl_lpspi->config.bpw = t ? t->bits_per_word : spi->bits_per_word;\r\nfsl_lpspi->config.speed_hz = t ? t->speed_hz : spi->max_speed_hz;\r\nfsl_lpspi->config.chip_select = spi->chip_select;\r\nif (!fsl_lpspi->config.speed_hz)\r\nfsl_lpspi->config.speed_hz = spi->max_speed_hz;\r\nif (!fsl_lpspi->config.bpw)\r\nfsl_lpspi->config.bpw = spi->bits_per_word;\r\nif (fsl_lpspi->config.bpw <= 8) {\r\nfsl_lpspi->rx = fsl_lpspi_buf_rx_u8;\r\nfsl_lpspi->tx = fsl_lpspi_buf_tx_u8;\r\n} else if (fsl_lpspi->config.bpw <= 16) {\r\nfsl_lpspi->rx = fsl_lpspi_buf_rx_u16;\r\nfsl_lpspi->tx = fsl_lpspi_buf_tx_u16;\r\n} else {\r\nfsl_lpspi->rx = fsl_lpspi_buf_rx_u32;\r\nfsl_lpspi->tx = fsl_lpspi_buf_tx_u32;\r\n}\r\nfsl_lpspi_config(fsl_lpspi);\r\n}\r\nstatic int fsl_lpspi_transfer_one(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct fsl_lpspi_data *fsl_lpspi = spi_master_get_devdata(master);\r\nint ret;\r\nfsl_lpspi->tx_buf = t->tx_buf;\r\nfsl_lpspi->rx_buf = t->rx_buf;\r\nfsl_lpspi->remain = t->len;\r\nreinit_completion(&fsl_lpspi->xfer_done);\r\nfsl_lpspi_write_tx_fifo(fsl_lpspi);\r\nret = wait_for_completion_timeout(&fsl_lpspi->xfer_done, HZ);\r\nif (!ret) {\r\ndev_dbg(fsl_lpspi->dev, "wait for completion timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nret = fsl_lpspi_txfifo_empty(fsl_lpspi);\r\nif (ret)\r\nreturn ret;\r\nfsl_lpspi_read_rx_fifo(fsl_lpspi);\r\nreturn 0;\r\n}\r\nstatic int fsl_lpspi_transfer_one_msg(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nstruct fsl_lpspi_data *fsl_lpspi = spi_master_get_devdata(master);\r\nstruct spi_device *spi = msg->spi;\r\nstruct spi_transfer *xfer;\r\nbool is_first_xfer = true;\r\nu32 temp;\r\nint ret = 0;\r\nmsg->status = 0;\r\nmsg->actual_length = 0;\r\nlist_for_each_entry(xfer, &msg->transfers, transfer_list) {\r\nfsl_lpspi_setup_transfer(spi, xfer);\r\nfsl_lpspi_set_cmd(fsl_lpspi, is_first_xfer);\r\nis_first_xfer = false;\r\nret = fsl_lpspi_transfer_one(master, spi, xfer);\r\nif (ret < 0)\r\ngoto complete;\r\nmsg->actual_length += xfer->len;\r\n}\r\ncomplete:\r\ntemp = readl(fsl_lpspi->base + IMX7ULP_TCR);\r\ntemp &= ~TCR_CONTC;\r\nwritel(temp, fsl_lpspi->base + IMX7ULP_TCR);\r\nmsg->status = ret;\r\nspi_finalize_current_message(master);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t fsl_lpspi_isr(int irq, void *dev_id)\r\n{\r\nstruct fsl_lpspi_data *fsl_lpspi = dev_id;\r\nu32 temp;\r\nfsl_lpspi_intctrl(fsl_lpspi, 0);\r\ntemp = readl(fsl_lpspi->base + IMX7ULP_SR);\r\nfsl_lpspi_read_rx_fifo(fsl_lpspi);\r\nif (temp & SR_TDF) {\r\nfsl_lpspi_write_tx_fifo(fsl_lpspi);\r\nif (!fsl_lpspi->remain)\r\ncomplete(&fsl_lpspi->xfer_done);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic int fsl_lpspi_probe(struct platform_device *pdev)\r\n{\r\nstruct fsl_lpspi_data *fsl_lpspi;\r\nstruct spi_master *master;\r\nstruct resource *res;\r\nint ret, irq;\r\nu32 temp;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(struct fsl_lpspi_data));\r\nif (!master)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, master);\r\nmaster->bits_per_word_mask = SPI_BPW_RANGE_MASK(8, 32);\r\nmaster->bus_num = pdev->id;\r\nfsl_lpspi = spi_master_get_devdata(master);\r\nfsl_lpspi->dev = &pdev->dev;\r\nmaster->transfer_one_message = fsl_lpspi_transfer_one_msg;\r\nmaster->prepare_transfer_hardware = lpspi_prepare_xfer_hardware;\r\nmaster->unprepare_transfer_hardware = lpspi_unprepare_xfer_hardware;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\r\nmaster->flags = SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX;\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nmaster->bus_num = pdev->id;\r\ninit_completion(&fsl_lpspi->xfer_done);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nfsl_lpspi->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(fsl_lpspi->base)) {\r\nret = PTR_ERR(fsl_lpspi->base);\r\ngoto out_master_put;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\nret = irq;\r\ngoto out_master_put;\r\n}\r\nret = devm_request_irq(&pdev->dev, irq, fsl_lpspi_isr, 0,\r\ndev_name(&pdev->dev), fsl_lpspi);\r\nif (ret) {\r\ndev_err(&pdev->dev, "can't get irq%d: %d\n", irq, ret);\r\ngoto out_master_put;\r\n}\r\nfsl_lpspi->clk = devm_clk_get(&pdev->dev, "ipg");\r\nif (IS_ERR(fsl_lpspi->clk)) {\r\nret = PTR_ERR(fsl_lpspi->clk);\r\ngoto out_master_put;\r\n}\r\nret = clk_prepare_enable(fsl_lpspi->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "can't enable lpspi clock, ret=%d\n", ret);\r\ngoto out_master_put;\r\n}\r\ntemp = readl(fsl_lpspi->base + IMX7ULP_PARAM);\r\nfsl_lpspi->txfifosize = 1 << (temp & 0x0f);\r\nfsl_lpspi->rxfifosize = 1 << ((temp >> 8) & 0x0f);\r\nclk_disable_unprepare(fsl_lpspi->clk);\r\nret = devm_spi_register_master(&pdev->dev, master);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "spi_register_master error.\n");\r\ngoto out_master_put;\r\n}\r\nreturn 0;\r\nout_master_put:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int fsl_lpspi_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct fsl_lpspi_data *fsl_lpspi = spi_master_get_devdata(master);\r\nclk_disable_unprepare(fsl_lpspi->clk);\r\nreturn 0;\r\n}
