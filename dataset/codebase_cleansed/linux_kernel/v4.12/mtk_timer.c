static u64 notrace mtk_read_sched_clock(void)\r\n{\r\nreturn readl_relaxed(gpt_sched_reg);\r\n}\r\nstatic inline struct mtk_clock_event_device *to_mtk_clk(\r\nstruct clock_event_device *c)\r\n{\r\nreturn container_of(c, struct mtk_clock_event_device, dev);\r\n}\r\nstatic void mtk_clkevt_time_stop(struct mtk_clock_event_device *evt, u8 timer)\r\n{\r\nu32 val;\r\nval = readl(evt->gpt_base + TIMER_CTRL_REG(timer));\r\nwritel(val & ~TIMER_CTRL_ENABLE, evt->gpt_base +\r\nTIMER_CTRL_REG(timer));\r\n}\r\nstatic void mtk_clkevt_time_setup(struct mtk_clock_event_device *evt,\r\nunsigned long delay, u8 timer)\r\n{\r\nwritel(delay, evt->gpt_base + TIMER_CMP_REG(timer));\r\n}\r\nstatic void mtk_clkevt_time_start(struct mtk_clock_event_device *evt,\r\nbool periodic, u8 timer)\r\n{\r\nu32 val;\r\nwritel(GPT_IRQ_ACK(timer), evt->gpt_base + GPT_IRQ_ACK_REG);\r\nval = readl(evt->gpt_base + TIMER_CTRL_REG(timer));\r\nval &= ~TIMER_CTRL_OP(0x3);\r\nif (periodic)\r\nval |= TIMER_CTRL_OP(TIMER_CTRL_OP_REPEAT);\r\nelse\r\nval |= TIMER_CTRL_OP(TIMER_CTRL_OP_ONESHOT);\r\nwritel(val | TIMER_CTRL_ENABLE | TIMER_CTRL_CLEAR,\r\nevt->gpt_base + TIMER_CTRL_REG(timer));\r\n}\r\nstatic int mtk_clkevt_shutdown(struct clock_event_device *clk)\r\n{\r\nmtk_clkevt_time_stop(to_mtk_clk(clk), GPT_CLK_EVT);\r\nreturn 0;\r\n}\r\nstatic int mtk_clkevt_set_periodic(struct clock_event_device *clk)\r\n{\r\nstruct mtk_clock_event_device *evt = to_mtk_clk(clk);\r\nmtk_clkevt_time_stop(evt, GPT_CLK_EVT);\r\nmtk_clkevt_time_setup(evt, evt->ticks_per_jiffy, GPT_CLK_EVT);\r\nmtk_clkevt_time_start(evt, true, GPT_CLK_EVT);\r\nreturn 0;\r\n}\r\nstatic int mtk_clkevt_next_event(unsigned long event,\r\nstruct clock_event_device *clk)\r\n{\r\nstruct mtk_clock_event_device *evt = to_mtk_clk(clk);\r\nmtk_clkevt_time_stop(evt, GPT_CLK_EVT);\r\nmtk_clkevt_time_setup(evt, event, GPT_CLK_EVT);\r\nmtk_clkevt_time_start(evt, false, GPT_CLK_EVT);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t mtk_timer_interrupt(int irq, void *dev_id)\r\n{\r\nstruct mtk_clock_event_device *evt = dev_id;\r\nwritel(GPT_IRQ_ACK(GPT_CLK_EVT), evt->gpt_base + GPT_IRQ_ACK_REG);\r\nevt->dev.event_handler(&evt->dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\n__init mtk_timer_setup(struct mtk_clock_event_device *evt, u8 timer, u8 option)\r\n{\r\nwritel(TIMER_CTRL_CLEAR | TIMER_CTRL_DISABLE,\r\nevt->gpt_base + TIMER_CTRL_REG(timer));\r\nwritel(TIMER_CLK_SRC(TIMER_CLK_SRC_SYS13M) | TIMER_CLK_DIV1,\r\nevt->gpt_base + TIMER_CLK_REG(timer));\r\nwritel(0x0, evt->gpt_base + TIMER_CMP_REG(timer));\r\nwritel(TIMER_CTRL_OP(option) | TIMER_CTRL_ENABLE,\r\nevt->gpt_base + TIMER_CTRL_REG(timer));\r\n}\r\nstatic void mtk_timer_enable_irq(struct mtk_clock_event_device *evt, u8 timer)\r\n{\r\nu32 val;\r\nwritel(0x0, evt->gpt_base + GPT_IRQ_EN_REG);\r\nwritel(0x3f, evt->gpt_base + GPT_IRQ_ACK_REG);\r\nval = readl(evt->gpt_base + GPT_IRQ_EN_REG);\r\nwritel(val | GPT_IRQ_ENABLE(timer),\r\nevt->gpt_base + GPT_IRQ_EN_REG);\r\n}\r\nstatic int __init mtk_timer_init(struct device_node *node)\r\n{\r\nstruct mtk_clock_event_device *evt;\r\nstruct resource res;\r\nunsigned long rate = 0;\r\nstruct clk *clk;\r\nevt = kzalloc(sizeof(*evt), GFP_KERNEL);\r\nif (!evt)\r\nreturn -ENOMEM;\r\nevt->dev.name = "mtk_tick";\r\nevt->dev.rating = 300;\r\nevt->dev.features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT;\r\nevt->dev.set_state_shutdown = mtk_clkevt_shutdown;\r\nevt->dev.set_state_periodic = mtk_clkevt_set_periodic;\r\nevt->dev.set_state_oneshot = mtk_clkevt_shutdown;\r\nevt->dev.tick_resume = mtk_clkevt_shutdown;\r\nevt->dev.set_next_event = mtk_clkevt_next_event;\r\nevt->dev.cpumask = cpu_possible_mask;\r\nevt->gpt_base = of_io_request_and_map(node, 0, "mtk-timer");\r\nif (IS_ERR(evt->gpt_base)) {\r\npr_err("Can't get resource\n");\r\ngoto err_kzalloc;\r\n}\r\nevt->dev.irq = irq_of_parse_and_map(node, 0);\r\nif (evt->dev.irq <= 0) {\r\npr_err("Can't parse IRQ\n");\r\ngoto err_mem;\r\n}\r\nclk = of_clk_get(node, 0);\r\nif (IS_ERR(clk)) {\r\npr_err("Can't get timer clock\n");\r\ngoto err_irq;\r\n}\r\nif (clk_prepare_enable(clk)) {\r\npr_err("Can't prepare clock\n");\r\ngoto err_clk_put;\r\n}\r\nrate = clk_get_rate(clk);\r\nif (request_irq(evt->dev.irq, mtk_timer_interrupt,\r\nIRQF_TIMER | IRQF_IRQPOLL, "mtk_timer", evt)) {\r\npr_err("failed to setup irq %d\n", evt->dev.irq);\r\ngoto err_clk_disable;\r\n}\r\nevt->ticks_per_jiffy = DIV_ROUND_UP(rate, HZ);\r\nmtk_timer_setup(evt, GPT_CLK_SRC, TIMER_CTRL_OP_FREERUN);\r\nclocksource_mmio_init(evt->gpt_base + TIMER_CNT_REG(GPT_CLK_SRC),\r\nnode->name, rate, 300, 32, clocksource_mmio_readl_up);\r\ngpt_sched_reg = evt->gpt_base + TIMER_CNT_REG(GPT_CLK_SRC);\r\nsched_clock_register(mtk_read_sched_clock, 32, rate);\r\nmtk_timer_setup(evt, GPT_CLK_EVT, TIMER_CTRL_OP_REPEAT);\r\nclockevents_config_and_register(&evt->dev, rate, 0x3,\r\n0xffffffff);\r\nmtk_timer_enable_irq(evt, GPT_CLK_EVT);\r\nreturn 0;\r\nerr_clk_disable:\r\nclk_disable_unprepare(clk);\r\nerr_clk_put:\r\nclk_put(clk);\r\nerr_irq:\r\nirq_dispose_mapping(evt->dev.irq);\r\nerr_mem:\r\niounmap(evt->gpt_base);\r\nof_address_to_resource(node, 0, &res);\r\nrelease_mem_region(res.start, resource_size(&res));\r\nerr_kzalloc:\r\nkfree(evt);\r\nreturn -EINVAL;\r\n}
