static void xgbe_get_strings(struct net_device *netdev, u32 stringset, u8 *data)\r\n{\r\nint i;\r\nswitch (stringset) {\r\ncase ETH_SS_STATS:\r\nfor (i = 0; i < XGBE_STATS_COUNT; i++) {\r\nmemcpy(data, xgbe_gstring_stats[i].stat_string,\r\nETH_GSTRING_LEN);\r\ndata += ETH_GSTRING_LEN;\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void xgbe_get_ethtool_stats(struct net_device *netdev,\r\nstruct ethtool_stats *stats, u64 *data)\r\n{\r\nstruct xgbe_prv_data *pdata = netdev_priv(netdev);\r\nu8 *stat;\r\nint i;\r\npdata->hw_if.read_mmc_stats(pdata);\r\nfor (i = 0; i < XGBE_STATS_COUNT; i++) {\r\nstat = (u8 *)pdata + xgbe_gstring_stats[i].stat_offset;\r\n*data++ = *(u64 *)stat;\r\n}\r\n}\r\nstatic int xgbe_get_sset_count(struct net_device *netdev, int stringset)\r\n{\r\nint ret;\r\nswitch (stringset) {\r\ncase ETH_SS_STATS:\r\nret = XGBE_STATS_COUNT;\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\n}\r\nreturn ret;\r\n}\r\nstatic void xgbe_get_pauseparam(struct net_device *netdev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct xgbe_prv_data *pdata = netdev_priv(netdev);\r\npause->autoneg = pdata->phy.pause_autoneg;\r\npause->tx_pause = pdata->phy.tx_pause;\r\npause->rx_pause = pdata->phy.rx_pause;\r\n}\r\nstatic int xgbe_set_pauseparam(struct net_device *netdev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct xgbe_prv_data *pdata = netdev_priv(netdev);\r\nint ret = 0;\r\nif (pause->autoneg && (pdata->phy.autoneg != AUTONEG_ENABLE)) {\r\nnetdev_err(netdev,\r\n"autoneg disabled, pause autoneg not avialable\n");\r\nreturn -EINVAL;\r\n}\r\npdata->phy.pause_autoneg = pause->autoneg;\r\npdata->phy.tx_pause = pause->tx_pause;\r\npdata->phy.rx_pause = pause->rx_pause;\r\npdata->phy.advertising &= ~ADVERTISED_Pause;\r\npdata->phy.advertising &= ~ADVERTISED_Asym_Pause;\r\nif (pause->rx_pause) {\r\npdata->phy.advertising |= ADVERTISED_Pause;\r\npdata->phy.advertising |= ADVERTISED_Asym_Pause;\r\n}\r\nif (pause->tx_pause)\r\npdata->phy.advertising ^= ADVERTISED_Asym_Pause;\r\nif (netif_running(netdev))\r\nret = pdata->phy_if.phy_config_aneg(pdata);\r\nreturn ret;\r\n}\r\nstatic int xgbe_get_link_ksettings(struct net_device *netdev,\r\nstruct ethtool_link_ksettings *cmd)\r\n{\r\nstruct xgbe_prv_data *pdata = netdev_priv(netdev);\r\ncmd->base.phy_address = pdata->phy.address;\r\nethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\r\npdata->phy.supported);\r\nethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\r\npdata->phy.advertising);\r\nethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.lp_advertising,\r\npdata->phy.lp_advertising);\r\ncmd->base.autoneg = pdata->phy.autoneg;\r\ncmd->base.speed = pdata->phy.speed;\r\ncmd->base.duplex = pdata->phy.duplex;\r\ncmd->base.port = PORT_NONE;\r\nreturn 0;\r\n}\r\nstatic int xgbe_set_link_ksettings(struct net_device *netdev,\r\nconst struct ethtool_link_ksettings *cmd)\r\n{\r\nstruct xgbe_prv_data *pdata = netdev_priv(netdev);\r\nu32 advertising;\r\nu32 speed;\r\nint ret;\r\nspeed = cmd->base.speed;\r\nif (cmd->base.phy_address != pdata->phy.address) {\r\nnetdev_err(netdev, "invalid phy address %hhu\n",\r\ncmd->base.phy_address);\r\nreturn -EINVAL;\r\n}\r\nif ((cmd->base.autoneg != AUTONEG_ENABLE) &&\r\n(cmd->base.autoneg != AUTONEG_DISABLE)) {\r\nnetdev_err(netdev, "unsupported autoneg %hhu\n",\r\ncmd->base.autoneg);\r\nreturn -EINVAL;\r\n}\r\nif (cmd->base.autoneg == AUTONEG_DISABLE) {\r\nif (!pdata->phy_if.phy_valid_speed(pdata, speed)) {\r\nnetdev_err(netdev, "unsupported speed %u\n", speed);\r\nreturn -EINVAL;\r\n}\r\nif (cmd->base.duplex != DUPLEX_FULL) {\r\nnetdev_err(netdev, "unsupported duplex %hhu\n",\r\ncmd->base.duplex);\r\nreturn -EINVAL;\r\n}\r\n}\r\nethtool_convert_link_mode_to_legacy_u32(&advertising,\r\ncmd->link_modes.advertising);\r\nnetif_dbg(pdata, link, netdev,\r\n"requested advertisement %#x, phy supported %#x\n",\r\nadvertising, pdata->phy.supported);\r\nadvertising &= pdata->phy.supported;\r\nif ((cmd->base.autoneg == AUTONEG_ENABLE) && !advertising) {\r\nnetdev_err(netdev,\r\n"unsupported requested advertisement\n");\r\nreturn -EINVAL;\r\n}\r\nret = 0;\r\npdata->phy.autoneg = cmd->base.autoneg;\r\npdata->phy.speed = speed;\r\npdata->phy.duplex = cmd->base.duplex;\r\npdata->phy.advertising = advertising;\r\nif (cmd->base.autoneg == AUTONEG_ENABLE)\r\npdata->phy.advertising |= ADVERTISED_Autoneg;\r\nelse\r\npdata->phy.advertising &= ~ADVERTISED_Autoneg;\r\nif (netif_running(netdev))\r\nret = pdata->phy_if.phy_config_aneg(pdata);\r\nreturn ret;\r\n}\r\nstatic void xgbe_get_drvinfo(struct net_device *netdev,\r\nstruct ethtool_drvinfo *drvinfo)\r\n{\r\nstruct xgbe_prv_data *pdata = netdev_priv(netdev);\r\nstruct xgbe_hw_features *hw_feat = &pdata->hw_feat;\r\nstrlcpy(drvinfo->driver, XGBE_DRV_NAME, sizeof(drvinfo->driver));\r\nstrlcpy(drvinfo->version, XGBE_DRV_VERSION, sizeof(drvinfo->version));\r\nstrlcpy(drvinfo->bus_info, dev_name(pdata->dev),\r\nsizeof(drvinfo->bus_info));\r\nsnprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version), "%d.%d.%d",\r\nXGMAC_GET_BITS(hw_feat->version, MAC_VR, USERVER),\r\nXGMAC_GET_BITS(hw_feat->version, MAC_VR, DEVID),\r\nXGMAC_GET_BITS(hw_feat->version, MAC_VR, SNPSVER));\r\n}\r\nstatic u32 xgbe_get_msglevel(struct net_device *netdev)\r\n{\r\nstruct xgbe_prv_data *pdata = netdev_priv(netdev);\r\nreturn pdata->msg_enable;\r\n}\r\nstatic void xgbe_set_msglevel(struct net_device *netdev, u32 msglevel)\r\n{\r\nstruct xgbe_prv_data *pdata = netdev_priv(netdev);\r\npdata->msg_enable = msglevel;\r\n}\r\nstatic int xgbe_get_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *ec)\r\n{\r\nstruct xgbe_prv_data *pdata = netdev_priv(netdev);\r\nmemset(ec, 0, sizeof(struct ethtool_coalesce));\r\nec->rx_coalesce_usecs = pdata->rx_usecs;\r\nec->rx_max_coalesced_frames = pdata->rx_frames;\r\nec->tx_max_coalesced_frames = pdata->tx_frames;\r\nreturn 0;\r\n}\r\nstatic int xgbe_set_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *ec)\r\n{\r\nstruct xgbe_prv_data *pdata = netdev_priv(netdev);\r\nstruct xgbe_hw_if *hw_if = &pdata->hw_if;\r\nunsigned int rx_frames, rx_riwt, rx_usecs;\r\nunsigned int tx_frames;\r\nif ((ec->rx_coalesce_usecs_irq) ||\r\n(ec->rx_max_coalesced_frames_irq) ||\r\n(ec->tx_coalesce_usecs) ||\r\n(ec->tx_coalesce_usecs_irq) ||\r\n(ec->tx_max_coalesced_frames_irq) ||\r\n(ec->stats_block_coalesce_usecs) ||\r\n(ec->use_adaptive_rx_coalesce) ||\r\n(ec->use_adaptive_tx_coalesce) ||\r\n(ec->pkt_rate_low) ||\r\n(ec->rx_coalesce_usecs_low) ||\r\n(ec->rx_max_coalesced_frames_low) ||\r\n(ec->tx_coalesce_usecs_low) ||\r\n(ec->tx_max_coalesced_frames_low) ||\r\n(ec->pkt_rate_high) ||\r\n(ec->rx_coalesce_usecs_high) ||\r\n(ec->rx_max_coalesced_frames_high) ||\r\n(ec->tx_coalesce_usecs_high) ||\r\n(ec->tx_max_coalesced_frames_high) ||\r\n(ec->rate_sample_interval)) {\r\nnetdev_err(netdev, "unsupported coalescing parameter\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nrx_riwt = hw_if->usec_to_riwt(pdata, ec->rx_coalesce_usecs);\r\nrx_usecs = ec->rx_coalesce_usecs;\r\nrx_frames = ec->rx_max_coalesced_frames;\r\nif (rx_usecs && !rx_riwt)\r\nrx_riwt = 1;\r\nif (rx_riwt > XGMAC_MAX_DMA_RIWT) {\r\nnetdev_err(netdev, "rx-usec is limited to %d usecs\n",\r\nhw_if->riwt_to_usec(pdata, XGMAC_MAX_DMA_RIWT));\r\nreturn -EINVAL;\r\n}\r\nif (rx_frames > pdata->rx_desc_count) {\r\nnetdev_err(netdev, "rx-frames is limited to %d frames\n",\r\npdata->rx_desc_count);\r\nreturn -EINVAL;\r\n}\r\ntx_frames = ec->tx_max_coalesced_frames;\r\nif (tx_frames > pdata->tx_desc_count) {\r\nnetdev_err(netdev, "tx-frames is limited to %d frames\n",\r\npdata->tx_desc_count);\r\nreturn -EINVAL;\r\n}\r\npdata->rx_riwt = rx_riwt;\r\npdata->rx_usecs = rx_usecs;\r\npdata->rx_frames = rx_frames;\r\nhw_if->config_rx_coalesce(pdata);\r\npdata->tx_frames = tx_frames;\r\nhw_if->config_tx_coalesce(pdata);\r\nreturn 0;\r\n}\r\nstatic int xgbe_get_rxnfc(struct net_device *netdev,\r\nstruct ethtool_rxnfc *rxnfc, u32 *rule_locs)\r\n{\r\nstruct xgbe_prv_data *pdata = netdev_priv(netdev);\r\nswitch (rxnfc->cmd) {\r\ncase ETHTOOL_GRXRINGS:\r\nrxnfc->data = pdata->rx_ring_count;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 xgbe_get_rxfh_key_size(struct net_device *netdev)\r\n{\r\nstruct xgbe_prv_data *pdata = netdev_priv(netdev);\r\nreturn sizeof(pdata->rss_key);\r\n}\r\nstatic u32 xgbe_get_rxfh_indir_size(struct net_device *netdev)\r\n{\r\nstruct xgbe_prv_data *pdata = netdev_priv(netdev);\r\nreturn ARRAY_SIZE(pdata->rss_table);\r\n}\r\nstatic int xgbe_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,\r\nu8 *hfunc)\r\n{\r\nstruct xgbe_prv_data *pdata = netdev_priv(netdev);\r\nunsigned int i;\r\nif (indir) {\r\nfor (i = 0; i < ARRAY_SIZE(pdata->rss_table); i++)\r\nindir[i] = XGMAC_GET_BITS(pdata->rss_table[i],\r\nMAC_RSSDR, DMCH);\r\n}\r\nif (key)\r\nmemcpy(key, pdata->rss_key, sizeof(pdata->rss_key));\r\nif (hfunc)\r\n*hfunc = ETH_RSS_HASH_TOP;\r\nreturn 0;\r\n}\r\nstatic int xgbe_set_rxfh(struct net_device *netdev, const u32 *indir,\r\nconst u8 *key, const u8 hfunc)\r\n{\r\nstruct xgbe_prv_data *pdata = netdev_priv(netdev);\r\nstruct xgbe_hw_if *hw_if = &pdata->hw_if;\r\nunsigned int ret;\r\nif (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP) {\r\nnetdev_err(netdev, "unsupported hash function\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (indir) {\r\nret = hw_if->set_rss_lookup_table(pdata, indir);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (key) {\r\nret = hw_if->set_rss_hash_key(pdata, key);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xgbe_get_ts_info(struct net_device *netdev,\r\nstruct ethtool_ts_info *ts_info)\r\n{\r\nstruct xgbe_prv_data *pdata = netdev_priv(netdev);\r\nts_info->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |\r\nSOF_TIMESTAMPING_RX_SOFTWARE |\r\nSOF_TIMESTAMPING_SOFTWARE |\r\nSOF_TIMESTAMPING_TX_HARDWARE |\r\nSOF_TIMESTAMPING_RX_HARDWARE |\r\nSOF_TIMESTAMPING_RAW_HARDWARE;\r\nif (pdata->ptp_clock)\r\nts_info->phc_index = ptp_clock_index(pdata->ptp_clock);\r\nelse\r\nts_info->phc_index = -1;\r\nts_info->tx_types = (1 << HWTSTAMP_TX_OFF) | (1 << HWTSTAMP_TX_ON);\r\nts_info->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |\r\n(1 << HWTSTAMP_FILTER_PTP_V1_L4_EVENT) |\r\n(1 << HWTSTAMP_FILTER_PTP_V1_L4_SYNC) |\r\n(1 << HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_L4_SYNC) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_EVENT) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_SYNC) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_DELAY_REQ) |\r\n(1 << HWTSTAMP_FILTER_ALL);\r\nreturn 0;\r\n}\r\nconst struct ethtool_ops *xgbe_get_ethtool_ops(void)\r\n{\r\nreturn &xgbe_ethtool_ops;\r\n}
