static bool rvin_mbus_supported(struct rvin_graph_entity *entity)\r\n{\r\nstruct v4l2_subdev *sd = entity->subdev;\r\nstruct v4l2_subdev_mbus_code_enum code = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n};\r\ncode.index = 0;\r\nwhile (!v4l2_subdev_call(sd, pad, enum_mbus_code, NULL, &code)) {\r\ncode.index++;\r\nswitch (code.code) {\r\ncase MEDIA_BUS_FMT_YUYV8_1X16:\r\ncase MEDIA_BUS_FMT_UYVY8_2X8:\r\ncase MEDIA_BUS_FMT_UYVY10_2X10:\r\ncase MEDIA_BUS_FMT_RGB888_1X24:\r\nentity->code = code.code;\r\nreturn true;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic int rvin_digital_notify_complete(struct v4l2_async_notifier *notifier)\r\n{\r\nstruct rvin_dev *vin = notifier_to_vin(notifier);\r\nint ret;\r\nif (!rvin_mbus_supported(&vin->digital)) {\r\nvin_err(vin, "Unsupported media bus format for %s\n",\r\nvin->digital.subdev->name);\r\nreturn -EINVAL;\r\n}\r\nvin_dbg(vin, "Found media bus format for %s: %d\n",\r\nvin->digital.subdev->name, vin->digital.code);\r\nret = v4l2_device_register_subdev_nodes(&vin->v4l2_dev);\r\nif (ret < 0) {\r\nvin_err(vin, "Failed to register subdev nodes\n");\r\nreturn ret;\r\n}\r\nreturn rvin_v4l2_probe(vin);\r\n}\r\nstatic void rvin_digital_notify_unbind(struct v4l2_async_notifier *notifier,\r\nstruct v4l2_subdev *subdev,\r\nstruct v4l2_async_subdev *asd)\r\n{\r\nstruct rvin_dev *vin = notifier_to_vin(notifier);\r\nif (vin->digital.subdev == subdev) {\r\nvin_dbg(vin, "unbind digital subdev %s\n", subdev->name);\r\nrvin_v4l2_remove(vin);\r\nvin->digital.subdev = NULL;\r\nreturn;\r\n}\r\nvin_err(vin, "no entity for subdev %s to unbind\n", subdev->name);\r\n}\r\nstatic int rvin_digital_notify_bound(struct v4l2_async_notifier *notifier,\r\nstruct v4l2_subdev *subdev,\r\nstruct v4l2_async_subdev *asd)\r\n{\r\nstruct rvin_dev *vin = notifier_to_vin(notifier);\r\nv4l2_set_subdev_hostdata(subdev, vin);\r\nif (vin->digital.asd.match.of.node == subdev->dev->of_node) {\r\nvin_dbg(vin, "bound digital subdev %s\n", subdev->name);\r\nvin->digital.subdev = subdev;\r\nreturn 0;\r\n}\r\nvin_err(vin, "no entity for subdev %s to bind\n", subdev->name);\r\nreturn -EINVAL;\r\n}\r\nstatic int rvin_digitial_parse_v4l2(struct rvin_dev *vin,\r\nstruct device_node *ep,\r\nstruct v4l2_mbus_config *mbus_cfg)\r\n{\r\nstruct v4l2_of_endpoint v4l2_ep;\r\nint ret;\r\nret = v4l2_of_parse_endpoint(ep, &v4l2_ep);\r\nif (ret) {\r\nvin_err(vin, "Could not parse v4l2 endpoint\n");\r\nreturn -EINVAL;\r\n}\r\nmbus_cfg->type = v4l2_ep.bus_type;\r\nswitch (mbus_cfg->type) {\r\ncase V4L2_MBUS_PARALLEL:\r\nvin_dbg(vin, "Found PARALLEL media bus\n");\r\nmbus_cfg->flags = v4l2_ep.bus.parallel.flags;\r\nbreak;\r\ncase V4L2_MBUS_BT656:\r\nvin_dbg(vin, "Found BT656 media bus\n");\r\nmbus_cfg->flags = 0;\r\nbreak;\r\ndefault:\r\nvin_err(vin, "Unknown media bus type\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rvin_digital_graph_parse(struct rvin_dev *vin)\r\n{\r\nstruct device_node *ep, *np;\r\nint ret;\r\nvin->digital.asd.match.of.node = NULL;\r\nvin->digital.subdev = NULL;\r\nep = of_graph_get_endpoint_by_regs(vin->dev->of_node, 0, 0);\r\nif (!ep)\r\nreturn 0;\r\nnp = of_graph_get_remote_port_parent(ep);\r\nif (!np) {\r\nvin_err(vin, "No remote parent for digital input\n");\r\nof_node_put(ep);\r\nreturn -EINVAL;\r\n}\r\nof_node_put(np);\r\nret = rvin_digitial_parse_v4l2(vin, ep, &vin->digital.mbus_cfg);\r\nof_node_put(ep);\r\nif (ret)\r\nreturn ret;\r\nvin->digital.asd.match.of.node = np;\r\nvin->digital.asd.match_type = V4L2_ASYNC_MATCH_OF;\r\nreturn 0;\r\n}\r\nstatic int rvin_digital_graph_init(struct rvin_dev *vin)\r\n{\r\nstruct v4l2_async_subdev **subdevs = NULL;\r\nint ret;\r\nret = rvin_digital_graph_parse(vin);\r\nif (ret)\r\nreturn ret;\r\nif (!vin->digital.asd.match.of.node) {\r\nvin_dbg(vin, "No digital subdevice found\n");\r\nreturn -ENODEV;\r\n}\r\nsubdevs = devm_kzalloc(vin->dev, sizeof(*subdevs), GFP_KERNEL);\r\nif (subdevs == NULL)\r\nreturn -ENOMEM;\r\nsubdevs[0] = &vin->digital.asd;\r\nvin_dbg(vin, "Found digital subdevice %s\n",\r\nof_node_full_name(subdevs[0]->match.of.node));\r\nvin->notifier.num_subdevs = 1;\r\nvin->notifier.subdevs = subdevs;\r\nvin->notifier.bound = rvin_digital_notify_bound;\r\nvin->notifier.unbind = rvin_digital_notify_unbind;\r\nvin->notifier.complete = rvin_digital_notify_complete;\r\nret = v4l2_async_notifier_register(&vin->v4l2_dev, &vin->notifier);\r\nif (ret < 0) {\r\nvin_err(vin, "Notifier registration failed\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rcar_vin_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct rvin_dev *vin;\r\nstruct resource *mem;\r\nint irq, ret;\r\nvin = devm_kzalloc(&pdev->dev, sizeof(*vin), GFP_KERNEL);\r\nif (!vin)\r\nreturn -ENOMEM;\r\nmatch = of_match_device(of_match_ptr(rvin_of_id_table), &pdev->dev);\r\nif (!match)\r\nreturn -ENODEV;\r\nvin->dev = &pdev->dev;\r\nvin->chip = (enum chip_id)match->data;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (mem == NULL)\r\nreturn -EINVAL;\r\nvin->base = devm_ioremap_resource(vin->dev, mem);\r\nif (IS_ERR(vin->base))\r\nreturn PTR_ERR(vin->base);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\nret = rvin_dma_probe(vin, irq);\r\nif (ret)\r\nreturn ret;\r\nret = rvin_digital_graph_init(vin);\r\nif (ret < 0)\r\ngoto error;\r\npm_suspend_ignore_children(&pdev->dev, true);\r\npm_runtime_enable(&pdev->dev);\r\nplatform_set_drvdata(pdev, vin);\r\nreturn 0;\r\nerror:\r\nrvin_dma_remove(vin);\r\nreturn ret;\r\n}\r\nstatic int rcar_vin_remove(struct platform_device *pdev)\r\n{\r\nstruct rvin_dev *vin = platform_get_drvdata(pdev);\r\npm_runtime_disable(&pdev->dev);\r\nv4l2_async_notifier_unregister(&vin->notifier);\r\nrvin_dma_remove(vin);\r\nreturn 0;\r\n}
