static int zpci_refresh_global(struct zpci_dev *zdev)\r\n{\r\nreturn zpci_refresh_trans((u64) zdev->fh << 32, zdev->start_dma,\r\nzdev->iommu_pages * PAGE_SIZE);\r\n}\r\nunsigned long *dma_alloc_cpu_table(void)\r\n{\r\nunsigned long *table, *entry;\r\ntable = kmem_cache_alloc(dma_region_table_cache, GFP_ATOMIC);\r\nif (!table)\r\nreturn NULL;\r\nfor (entry = table; entry < table + ZPCI_TABLE_ENTRIES; entry++)\r\n*entry = ZPCI_TABLE_INVALID;\r\nreturn table;\r\n}\r\nstatic void dma_free_cpu_table(void *table)\r\n{\r\nkmem_cache_free(dma_region_table_cache, table);\r\n}\r\nstatic unsigned long *dma_alloc_page_table(void)\r\n{\r\nunsigned long *table, *entry;\r\ntable = kmem_cache_alloc(dma_page_table_cache, GFP_ATOMIC);\r\nif (!table)\r\nreturn NULL;\r\nfor (entry = table; entry < table + ZPCI_PT_ENTRIES; entry++)\r\n*entry = ZPCI_PTE_INVALID;\r\nreturn table;\r\n}\r\nstatic void dma_free_page_table(void *table)\r\n{\r\nkmem_cache_free(dma_page_table_cache, table);\r\n}\r\nstatic unsigned long *dma_get_seg_table_origin(unsigned long *entry)\r\n{\r\nunsigned long *sto;\r\nif (reg_entry_isvalid(*entry))\r\nsto = get_rt_sto(*entry);\r\nelse {\r\nsto = dma_alloc_cpu_table();\r\nif (!sto)\r\nreturn NULL;\r\nset_rt_sto(entry, sto);\r\nvalidate_rt_entry(entry);\r\nentry_clr_protected(entry);\r\n}\r\nreturn sto;\r\n}\r\nstatic unsigned long *dma_get_page_table_origin(unsigned long *entry)\r\n{\r\nunsigned long *pto;\r\nif (reg_entry_isvalid(*entry))\r\npto = get_st_pto(*entry);\r\nelse {\r\npto = dma_alloc_page_table();\r\nif (!pto)\r\nreturn NULL;\r\nset_st_pto(entry, pto);\r\nvalidate_st_entry(entry);\r\nentry_clr_protected(entry);\r\n}\r\nreturn pto;\r\n}\r\nunsigned long *dma_walk_cpu_trans(unsigned long *rto, dma_addr_t dma_addr)\r\n{\r\nunsigned long *sto, *pto;\r\nunsigned int rtx, sx, px;\r\nrtx = calc_rtx(dma_addr);\r\nsto = dma_get_seg_table_origin(&rto[rtx]);\r\nif (!sto)\r\nreturn NULL;\r\nsx = calc_sx(dma_addr);\r\npto = dma_get_page_table_origin(&sto[sx]);\r\nif (!pto)\r\nreturn NULL;\r\npx = calc_px(dma_addr);\r\nreturn &pto[px];\r\n}\r\nvoid dma_update_cpu_trans(unsigned long *entry, void *page_addr, int flags)\r\n{\r\nif (flags & ZPCI_PTE_INVALID) {\r\ninvalidate_pt_entry(entry);\r\n} else {\r\nset_pt_pfaa(entry, page_addr);\r\nvalidate_pt_entry(entry);\r\n}\r\nif (flags & ZPCI_TABLE_PROTECTED)\r\nentry_set_protected(entry);\r\nelse\r\nentry_clr_protected(entry);\r\n}\r\nstatic int __dma_update_trans(struct zpci_dev *zdev, unsigned long pa,\r\ndma_addr_t dma_addr, size_t size, int flags)\r\n{\r\nunsigned int nr_pages = PAGE_ALIGN(size) >> PAGE_SHIFT;\r\nu8 *page_addr = (u8 *) (pa & PAGE_MASK);\r\nunsigned long irq_flags;\r\nunsigned long *entry;\r\nint i, rc = 0;\r\nif (!nr_pages)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&zdev->dma_table_lock, irq_flags);\r\nif (!zdev->dma_table) {\r\nrc = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nfor (i = 0; i < nr_pages; i++) {\r\nentry = dma_walk_cpu_trans(zdev->dma_table, dma_addr);\r\nif (!entry) {\r\nrc = -ENOMEM;\r\ngoto undo_cpu_trans;\r\n}\r\ndma_update_cpu_trans(entry, page_addr, flags);\r\npage_addr += PAGE_SIZE;\r\ndma_addr += PAGE_SIZE;\r\n}\r\nundo_cpu_trans:\r\nif (rc && ((flags & ZPCI_PTE_VALID_MASK) == ZPCI_PTE_VALID)) {\r\nflags = ZPCI_PTE_INVALID;\r\nwhile (i-- > 0) {\r\npage_addr -= PAGE_SIZE;\r\ndma_addr -= PAGE_SIZE;\r\nentry = dma_walk_cpu_trans(zdev->dma_table, dma_addr);\r\nif (!entry)\r\nbreak;\r\ndma_update_cpu_trans(entry, page_addr, flags);\r\n}\r\n}\r\nout_unlock:\r\nspin_unlock_irqrestore(&zdev->dma_table_lock, irq_flags);\r\nreturn rc;\r\n}\r\nstatic int __dma_purge_tlb(struct zpci_dev *zdev, dma_addr_t dma_addr,\r\nsize_t size, int flags)\r\n{\r\nif ((flags & ZPCI_PTE_VALID_MASK) == ZPCI_PTE_VALID) {\r\nif (!zdev->tlb_refresh)\r\nreturn 0;\r\n} else {\r\nif (!s390_iommu_strict)\r\nreturn 0;\r\n}\r\nreturn zpci_refresh_trans((u64) zdev->fh << 32, dma_addr,\r\nPAGE_ALIGN(size));\r\n}\r\nstatic int dma_update_trans(struct zpci_dev *zdev, unsigned long pa,\r\ndma_addr_t dma_addr, size_t size, int flags)\r\n{\r\nint rc;\r\nrc = __dma_update_trans(zdev, pa, dma_addr, size, flags);\r\nif (rc)\r\nreturn rc;\r\nrc = __dma_purge_tlb(zdev, dma_addr, size, flags);\r\nif (rc && ((flags & ZPCI_PTE_VALID_MASK) == ZPCI_PTE_VALID))\r\n__dma_update_trans(zdev, pa, dma_addr, size, ZPCI_PTE_INVALID);\r\nreturn rc;\r\n}\r\nvoid dma_free_seg_table(unsigned long entry)\r\n{\r\nunsigned long *sto = get_rt_sto(entry);\r\nint sx;\r\nfor (sx = 0; sx < ZPCI_TABLE_ENTRIES; sx++)\r\nif (reg_entry_isvalid(sto[sx]))\r\ndma_free_page_table(get_st_pto(sto[sx]));\r\ndma_free_cpu_table(sto);\r\n}\r\nvoid dma_cleanup_tables(unsigned long *table)\r\n{\r\nint rtx;\r\nif (!table)\r\nreturn;\r\nfor (rtx = 0; rtx < ZPCI_TABLE_ENTRIES; rtx++)\r\nif (reg_entry_isvalid(table[rtx]))\r\ndma_free_seg_table(table[rtx]);\r\ndma_free_cpu_table(table);\r\n}\r\nstatic unsigned long __dma_alloc_iommu(struct device *dev,\r\nunsigned long start, int size)\r\n{\r\nstruct zpci_dev *zdev = to_zpci(to_pci_dev(dev));\r\nunsigned long boundary_size;\r\nboundary_size = ALIGN(dma_get_seg_boundary(dev) + 1,\r\nPAGE_SIZE) >> PAGE_SHIFT;\r\nreturn iommu_area_alloc(zdev->iommu_bitmap, zdev->iommu_pages,\r\nstart, size, zdev->start_dma >> PAGE_SHIFT,\r\nboundary_size, 0);\r\n}\r\nstatic dma_addr_t dma_alloc_address(struct device *dev, int size)\r\n{\r\nstruct zpci_dev *zdev = to_zpci(to_pci_dev(dev));\r\nunsigned long offset, flags;\r\nspin_lock_irqsave(&zdev->iommu_bitmap_lock, flags);\r\noffset = __dma_alloc_iommu(dev, zdev->next_bit, size);\r\nif (offset == -1) {\r\nif (!s390_iommu_strict) {\r\nif (zpci_refresh_global(zdev))\r\ngoto out_error;\r\nbitmap_andnot(zdev->iommu_bitmap, zdev->iommu_bitmap,\r\nzdev->lazy_bitmap, zdev->iommu_pages);\r\nbitmap_zero(zdev->lazy_bitmap, zdev->iommu_pages);\r\n}\r\noffset = __dma_alloc_iommu(dev, 0, size);\r\nif (offset == -1)\r\ngoto out_error;\r\n}\r\nzdev->next_bit = offset + size;\r\nspin_unlock_irqrestore(&zdev->iommu_bitmap_lock, flags);\r\nreturn zdev->start_dma + offset * PAGE_SIZE;\r\nout_error:\r\nspin_unlock_irqrestore(&zdev->iommu_bitmap_lock, flags);\r\nreturn DMA_ERROR_CODE;\r\n}\r\nstatic void dma_free_address(struct device *dev, dma_addr_t dma_addr, int size)\r\n{\r\nstruct zpci_dev *zdev = to_zpci(to_pci_dev(dev));\r\nunsigned long flags, offset;\r\noffset = (dma_addr - zdev->start_dma) >> PAGE_SHIFT;\r\nspin_lock_irqsave(&zdev->iommu_bitmap_lock, flags);\r\nif (!zdev->iommu_bitmap)\r\ngoto out;\r\nif (s390_iommu_strict)\r\nbitmap_clear(zdev->iommu_bitmap, offset, size);\r\nelse\r\nbitmap_set(zdev->lazy_bitmap, offset, size);\r\nout:\r\nspin_unlock_irqrestore(&zdev->iommu_bitmap_lock, flags);\r\n}\r\nstatic inline void zpci_err_dma(unsigned long rc, unsigned long addr)\r\n{\r\nstruct {\r\nunsigned long rc;\r\nunsigned long addr;\r\n} __packed data = {rc, addr};\r\nzpci_err_hex(&data, sizeof(data));\r\n}\r\nstatic dma_addr_t s390_dma_map_pages(struct device *dev, struct page *page,\r\nunsigned long offset, size_t size,\r\nenum dma_data_direction direction,\r\nunsigned long attrs)\r\n{\r\nstruct zpci_dev *zdev = to_zpci(to_pci_dev(dev));\r\nunsigned long pa = page_to_phys(page) + offset;\r\nint flags = ZPCI_PTE_VALID;\r\nunsigned long nr_pages;\r\ndma_addr_t dma_addr;\r\nint ret;\r\nnr_pages = iommu_num_pages(pa, size, PAGE_SIZE);\r\ndma_addr = dma_alloc_address(dev, nr_pages);\r\nif (dma_addr == DMA_ERROR_CODE) {\r\nret = -ENOSPC;\r\ngoto out_err;\r\n}\r\nsize = nr_pages * PAGE_SIZE;\r\nif (direction == DMA_NONE || direction == DMA_TO_DEVICE)\r\nflags |= ZPCI_TABLE_PROTECTED;\r\nret = dma_update_trans(zdev, pa, dma_addr, size, flags);\r\nif (ret)\r\ngoto out_free;\r\natomic64_add(nr_pages, &zdev->mapped_pages);\r\nreturn dma_addr + (offset & ~PAGE_MASK);\r\nout_free:\r\ndma_free_address(dev, dma_addr, nr_pages);\r\nout_err:\r\nzpci_err("map error:\n");\r\nzpci_err_dma(ret, pa);\r\nreturn DMA_ERROR_CODE;\r\n}\r\nstatic void s390_dma_unmap_pages(struct device *dev, dma_addr_t dma_addr,\r\nsize_t size, enum dma_data_direction direction,\r\nunsigned long attrs)\r\n{\r\nstruct zpci_dev *zdev = to_zpci(to_pci_dev(dev));\r\nint npages, ret;\r\nnpages = iommu_num_pages(dma_addr, size, PAGE_SIZE);\r\ndma_addr = dma_addr & PAGE_MASK;\r\nret = dma_update_trans(zdev, 0, dma_addr, npages * PAGE_SIZE,\r\nZPCI_PTE_INVALID);\r\nif (ret) {\r\nzpci_err("unmap error:\n");\r\nzpci_err_dma(ret, dma_addr);\r\nreturn;\r\n}\r\natomic64_add(npages, &zdev->unmapped_pages);\r\ndma_free_address(dev, dma_addr, npages);\r\n}\r\nstatic void *s390_dma_alloc(struct device *dev, size_t size,\r\ndma_addr_t *dma_handle, gfp_t flag,\r\nunsigned long attrs)\r\n{\r\nstruct zpci_dev *zdev = to_zpci(to_pci_dev(dev));\r\nstruct page *page;\r\nunsigned long pa;\r\ndma_addr_t map;\r\nsize = PAGE_ALIGN(size);\r\npage = alloc_pages(flag, get_order(size));\r\nif (!page)\r\nreturn NULL;\r\npa = page_to_phys(page);\r\nmap = s390_dma_map_pages(dev, page, 0, size, DMA_BIDIRECTIONAL, 0);\r\nif (dma_mapping_error(dev, map)) {\r\nfree_pages(pa, get_order(size));\r\nreturn NULL;\r\n}\r\natomic64_add(size / PAGE_SIZE, &zdev->allocated_pages);\r\nif (dma_handle)\r\n*dma_handle = map;\r\nreturn (void *) pa;\r\n}\r\nstatic void s390_dma_free(struct device *dev, size_t size,\r\nvoid *pa, dma_addr_t dma_handle,\r\nunsigned long attrs)\r\n{\r\nstruct zpci_dev *zdev = to_zpci(to_pci_dev(dev));\r\nsize = PAGE_ALIGN(size);\r\natomic64_sub(size / PAGE_SIZE, &zdev->allocated_pages);\r\ns390_dma_unmap_pages(dev, dma_handle, size, DMA_BIDIRECTIONAL, 0);\r\nfree_pages((unsigned long) pa, get_order(size));\r\n}\r\nstatic int __s390_dma_map_sg(struct device *dev, struct scatterlist *sg,\r\nsize_t size, dma_addr_t *handle,\r\nenum dma_data_direction dir)\r\n{\r\nunsigned long nr_pages = PAGE_ALIGN(size) >> PAGE_SHIFT;\r\nstruct zpci_dev *zdev = to_zpci(to_pci_dev(dev));\r\ndma_addr_t dma_addr_base, dma_addr;\r\nint flags = ZPCI_PTE_VALID;\r\nstruct scatterlist *s;\r\nunsigned long pa = 0;\r\nint ret;\r\ndma_addr_base = dma_alloc_address(dev, nr_pages);\r\nif (dma_addr_base == DMA_ERROR_CODE)\r\nreturn -ENOMEM;\r\ndma_addr = dma_addr_base;\r\nif (dir == DMA_NONE || dir == DMA_TO_DEVICE)\r\nflags |= ZPCI_TABLE_PROTECTED;\r\nfor (s = sg; dma_addr < dma_addr_base + size; s = sg_next(s)) {\r\npa = page_to_phys(sg_page(s));\r\nret = __dma_update_trans(zdev, pa, dma_addr,\r\ns->offset + s->length, flags);\r\nif (ret)\r\ngoto unmap;\r\ndma_addr += s->offset + s->length;\r\n}\r\nret = __dma_purge_tlb(zdev, dma_addr_base, size, flags);\r\nif (ret)\r\ngoto unmap;\r\n*handle = dma_addr_base;\r\natomic64_add(nr_pages, &zdev->mapped_pages);\r\nreturn ret;\r\nunmap:\r\ndma_update_trans(zdev, 0, dma_addr_base, dma_addr - dma_addr_base,\r\nZPCI_PTE_INVALID);\r\ndma_free_address(dev, dma_addr_base, nr_pages);\r\nzpci_err("map error:\n");\r\nzpci_err_dma(ret, pa);\r\nreturn ret;\r\n}\r\nstatic int s390_dma_map_sg(struct device *dev, struct scatterlist *sg,\r\nint nr_elements, enum dma_data_direction dir,\r\nunsigned long attrs)\r\n{\r\nstruct scatterlist *s = sg, *start = sg, *dma = sg;\r\nunsigned int max = dma_get_max_seg_size(dev);\r\nunsigned int size = s->offset + s->length;\r\nunsigned int offset = s->offset;\r\nint count = 0, i;\r\nfor (i = 1; i < nr_elements; i++) {\r\ns = sg_next(s);\r\ns->dma_address = DMA_ERROR_CODE;\r\ns->dma_length = 0;\r\nif (s->offset || (size & ~PAGE_MASK) ||\r\nsize + s->length > max) {\r\nif (__s390_dma_map_sg(dev, start, size,\r\n&dma->dma_address, dir))\r\ngoto unmap;\r\ndma->dma_address += offset;\r\ndma->dma_length = size - offset;\r\nsize = offset = s->offset;\r\nstart = s;\r\ndma = sg_next(dma);\r\ncount++;\r\n}\r\nsize += s->length;\r\n}\r\nif (__s390_dma_map_sg(dev, start, size, &dma->dma_address, dir))\r\ngoto unmap;\r\ndma->dma_address += offset;\r\ndma->dma_length = size - offset;\r\nreturn count + 1;\r\nunmap:\r\nfor_each_sg(sg, s, count, i)\r\ns390_dma_unmap_pages(dev, sg_dma_address(s), sg_dma_len(s),\r\ndir, attrs);\r\nreturn 0;\r\n}\r\nstatic void s390_dma_unmap_sg(struct device *dev, struct scatterlist *sg,\r\nint nr_elements, enum dma_data_direction dir,\r\nunsigned long attrs)\r\n{\r\nstruct scatterlist *s;\r\nint i;\r\nfor_each_sg(sg, s, nr_elements, i) {\r\nif (s->dma_length)\r\ns390_dma_unmap_pages(dev, s->dma_address, s->dma_length,\r\ndir, attrs);\r\ns->dma_address = 0;\r\ns->dma_length = 0;\r\n}\r\n}\r\nint zpci_dma_init_device(struct zpci_dev *zdev)\r\n{\r\nint rc;\r\nWARN_ON(zdev->s390_domain);\r\nspin_lock_init(&zdev->iommu_bitmap_lock);\r\nspin_lock_init(&zdev->dma_table_lock);\r\nzdev->dma_table = dma_alloc_cpu_table();\r\nif (!zdev->dma_table) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nzdev->start_dma = PAGE_ALIGN(zdev->start_dma);\r\nzdev->iommu_size = min3((u64) high_memory,\r\nZPCI_TABLE_SIZE_RT - zdev->start_dma,\r\nzdev->end_dma - zdev->start_dma + 1);\r\nzdev->end_dma = zdev->start_dma + zdev->iommu_size - 1;\r\nzdev->iommu_pages = zdev->iommu_size >> PAGE_SHIFT;\r\nzdev->iommu_bitmap = vzalloc(zdev->iommu_pages / 8);\r\nif (!zdev->iommu_bitmap) {\r\nrc = -ENOMEM;\r\ngoto free_dma_table;\r\n}\r\nif (!s390_iommu_strict) {\r\nzdev->lazy_bitmap = vzalloc(zdev->iommu_pages / 8);\r\nif (!zdev->lazy_bitmap) {\r\nrc = -ENOMEM;\r\ngoto free_bitmap;\r\n}\r\n}\r\nrc = zpci_register_ioat(zdev, 0, zdev->start_dma, zdev->end_dma,\r\n(u64) zdev->dma_table);\r\nif (rc)\r\ngoto free_bitmap;\r\nreturn 0;\r\nfree_bitmap:\r\nvfree(zdev->iommu_bitmap);\r\nzdev->iommu_bitmap = NULL;\r\nvfree(zdev->lazy_bitmap);\r\nzdev->lazy_bitmap = NULL;\r\nfree_dma_table:\r\ndma_free_cpu_table(zdev->dma_table);\r\nzdev->dma_table = NULL;\r\nout:\r\nreturn rc;\r\n}\r\nvoid zpci_dma_exit_device(struct zpci_dev *zdev)\r\n{\r\nWARN_ON(zdev->s390_domain);\r\nzpci_unregister_ioat(zdev, 0);\r\ndma_cleanup_tables(zdev->dma_table);\r\nzdev->dma_table = NULL;\r\nvfree(zdev->iommu_bitmap);\r\nzdev->iommu_bitmap = NULL;\r\nvfree(zdev->lazy_bitmap);\r\nzdev->lazy_bitmap = NULL;\r\nzdev->next_bit = 0;\r\n}\r\nstatic int __init dma_alloc_cpu_table_caches(void)\r\n{\r\ndma_region_table_cache = kmem_cache_create("PCI_DMA_region_tables",\r\nZPCI_TABLE_SIZE, ZPCI_TABLE_ALIGN,\r\n0, NULL);\r\nif (!dma_region_table_cache)\r\nreturn -ENOMEM;\r\ndma_page_table_cache = kmem_cache_create("PCI_DMA_page_tables",\r\nZPCI_PT_SIZE, ZPCI_PT_ALIGN,\r\n0, NULL);\r\nif (!dma_page_table_cache) {\r\nkmem_cache_destroy(dma_region_table_cache);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nint __init zpci_dma_init(void)\r\n{\r\nreturn dma_alloc_cpu_table_caches();\r\n}\r\nvoid zpci_dma_exit(void)\r\n{\r\nkmem_cache_destroy(dma_page_table_cache);\r\nkmem_cache_destroy(dma_region_table_cache);\r\n}\r\nstatic int __init dma_debug_do_init(void)\r\n{\r\ndma_debug_init(PREALLOC_DMA_DEBUG_ENTRIES);\r\nreturn 0;\r\n}\r\nstatic int __init s390_iommu_setup(char *str)\r\n{\r\nif (!strncmp(str, "strict", 6))\r\ns390_iommu_strict = 1;\r\nreturn 0;\r\n}
