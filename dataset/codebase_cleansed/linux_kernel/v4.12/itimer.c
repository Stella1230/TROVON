static struct timeval itimer_get_remtime(struct hrtimer *timer)\r\n{\r\nktime_t rem = __hrtimer_get_remaining(timer, true);\r\nif (hrtimer_active(timer)) {\r\nif (rem <= 0)\r\nrem = NSEC_PER_USEC;\r\n} else\r\nrem = 0;\r\nreturn ktime_to_timeval(rem);\r\n}\r\nstatic void get_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,\r\nstruct itimerval *const value)\r\n{\r\nu64 val, interval;\r\nstruct cpu_itimer *it = &tsk->signal->it[clock_id];\r\nspin_lock_irq(&tsk->sighand->siglock);\r\nval = it->expires;\r\ninterval = it->incr;\r\nif (val) {\r\nstruct task_cputime cputime;\r\nu64 t;\r\nthread_group_cputimer(tsk, &cputime);\r\nif (clock_id == CPUCLOCK_PROF)\r\nt = cputime.utime + cputime.stime;\r\nelse\r\nt = cputime.utime;\r\nif (val < t)\r\nval = TICK_NSEC;\r\nelse\r\nval -= t;\r\n}\r\nspin_unlock_irq(&tsk->sighand->siglock);\r\nvalue->it_value = ns_to_timeval(val);\r\nvalue->it_interval = ns_to_timeval(interval);\r\n}\r\nint do_getitimer(int which, struct itimerval *value)\r\n{\r\nstruct task_struct *tsk = current;\r\nswitch (which) {\r\ncase ITIMER_REAL:\r\nspin_lock_irq(&tsk->sighand->siglock);\r\nvalue->it_value = itimer_get_remtime(&tsk->signal->real_timer);\r\nvalue->it_interval =\r\nktime_to_timeval(tsk->signal->it_real_incr);\r\nspin_unlock_irq(&tsk->sighand->siglock);\r\nbreak;\r\ncase ITIMER_VIRTUAL:\r\nget_cpu_itimer(tsk, CPUCLOCK_VIRT, value);\r\nbreak;\r\ncase ITIMER_PROF:\r\nget_cpu_itimer(tsk, CPUCLOCK_PROF, value);\r\nbreak;\r\ndefault:\r\nreturn(-EINVAL);\r\n}\r\nreturn 0;\r\n}\r\nenum hrtimer_restart it_real_fn(struct hrtimer *timer)\r\n{\r\nstruct signal_struct *sig =\r\ncontainer_of(timer, struct signal_struct, real_timer);\r\ntrace_itimer_expire(ITIMER_REAL, sig->leader_pid, 0);\r\nkill_pid_info(SIGALRM, SEND_SIG_PRIV, sig->leader_pid);\r\nreturn HRTIMER_NORESTART;\r\n}\r\nstatic void set_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,\r\nconst struct itimerval *const value,\r\nstruct itimerval *const ovalue)\r\n{\r\nu64 oval, nval, ointerval, ninterval;\r\nstruct cpu_itimer *it = &tsk->signal->it[clock_id];\r\nnval = timeval_to_ns(&value->it_value);\r\nninterval = timeval_to_ns(&value->it_interval);\r\nspin_lock_irq(&tsk->sighand->siglock);\r\noval = it->expires;\r\nointerval = it->incr;\r\nif (oval || nval) {\r\nif (nval > 0)\r\nnval += TICK_NSEC;\r\nset_process_cpu_timer(tsk, clock_id, &nval, &oval);\r\n}\r\nit->expires = nval;\r\nit->incr = ninterval;\r\ntrace_itimer_state(clock_id == CPUCLOCK_VIRT ?\r\nITIMER_VIRTUAL : ITIMER_PROF, value, nval);\r\nspin_unlock_irq(&tsk->sighand->siglock);\r\nif (ovalue) {\r\novalue->it_value = ns_to_timeval(oval);\r\novalue->it_interval = ns_to_timeval(ointerval);\r\n}\r\n}\r\nint do_setitimer(int which, struct itimerval *value, struct itimerval *ovalue)\r\n{\r\nstruct task_struct *tsk = current;\r\nstruct hrtimer *timer;\r\nktime_t expires;\r\nif (!timeval_valid(&value->it_value) ||\r\n!timeval_valid(&value->it_interval))\r\nreturn -EINVAL;\r\nswitch (which) {\r\ncase ITIMER_REAL:\r\nagain:\r\nspin_lock_irq(&tsk->sighand->siglock);\r\ntimer = &tsk->signal->real_timer;\r\nif (ovalue) {\r\novalue->it_value = itimer_get_remtime(timer);\r\novalue->it_interval\r\n= ktime_to_timeval(tsk->signal->it_real_incr);\r\n}\r\nif (hrtimer_try_to_cancel(timer) < 0) {\r\nspin_unlock_irq(&tsk->sighand->siglock);\r\ngoto again;\r\n}\r\nexpires = timeval_to_ktime(value->it_value);\r\nif (expires != 0) {\r\ntsk->signal->it_real_incr =\r\ntimeval_to_ktime(value->it_interval);\r\nhrtimer_start(timer, expires, HRTIMER_MODE_REL);\r\n} else\r\ntsk->signal->it_real_incr = 0;\r\ntrace_itimer_state(ITIMER_REAL, value, 0);\r\nspin_unlock_irq(&tsk->sighand->siglock);\r\nbreak;\r\ncase ITIMER_VIRTUAL:\r\nset_cpu_itimer(tsk, CPUCLOCK_VIRT, value, ovalue);\r\nbreak;\r\ncase ITIMER_PROF:\r\nset_cpu_itimer(tsk, CPUCLOCK_PROF, value, ovalue);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int alarm_setitimer(unsigned int seconds)\r\n{\r\nstruct itimerval it_new, it_old;\r\n#if BITS_PER_LONG < 64\r\nif (seconds > INT_MAX)\r\nseconds = INT_MAX;\r\n#endif\r\nit_new.it_value.tv_sec = seconds;\r\nit_new.it_value.tv_usec = 0;\r\nit_new.it_interval.tv_sec = it_new.it_interval.tv_usec = 0;\r\ndo_setitimer(ITIMER_REAL, &it_new, &it_old);\r\nif ((!it_old.it_value.tv_sec && it_old.it_value.tv_usec) ||\r\nit_old.it_value.tv_usec >= 500000)\r\nit_old.it_value.tv_sec++;\r\nreturn it_old.it_value.tv_sec;\r\n}
