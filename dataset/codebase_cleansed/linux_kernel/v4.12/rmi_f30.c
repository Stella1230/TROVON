static int rmi_f30_read_control_parameters(struct rmi_function *fn,\r\nstruct f30_data *f30)\r\n{\r\nint error;\r\nerror = rmi_read_block(fn->rmi_dev, fn->fd.control_base_addr,\r\nf30->ctrl_regs, f30->ctrl_regs_size);\r\nif (error) {\r\ndev_err(&fn->dev,\r\n"%s: Could not read control registers at 0x%x: %d\n",\r\n__func__, fn->fd.control_base_addr, error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rmi_f30_report_button(struct rmi_function *fn,\r\nstruct f30_data *f30, unsigned int button)\r\n{\r\nunsigned int reg_num = button >> 3;\r\nunsigned int bit_num = button & 0x07;\r\nu16 key_code = f30->gpioled_key_map[button];\r\nbool key_down = !(f30->data_regs[reg_num] & BIT(bit_num));\r\nif (f30->trackstick_buttons &&\r\nbutton >= TRACKSTICK_RANGE_START &&\r\nbutton <= TRACKSTICK_RANGE_END) {\r\nrmi_f03_overwrite_button(f30->f03, key_code, key_down);\r\n} else {\r\nrmi_dbg(RMI_DEBUG_FN, &fn->dev,\r\n"%s: call input report key (0x%04x) value (0x%02x)",\r\n__func__, key_code, key_down);\r\ninput_report_key(f30->input, key_code, key_down);\r\n}\r\n}\r\nstatic int rmi_f30_attention(struct rmi_function *fn, unsigned long *irq_bits)\r\n{\r\nstruct f30_data *f30 = dev_get_drvdata(&fn->dev);\r\nstruct rmi_driver_data *drvdata = dev_get_drvdata(&fn->rmi_dev->dev);\r\nint error;\r\nint i;\r\nif (drvdata->attn_data.data) {\r\nif (drvdata->attn_data.size < f30->register_count) {\r\ndev_warn(&fn->dev,\r\n"F30 interrupted, but data is missing\n");\r\nreturn 0;\r\n}\r\nmemcpy(f30->data_regs, drvdata->attn_data.data,\r\nf30->register_count);\r\ndrvdata->attn_data.data += f30->register_count;\r\ndrvdata->attn_data.size -= f30->register_count;\r\n} else {\r\nerror = rmi_read_block(fn->rmi_dev, fn->fd.data_base_addr,\r\nf30->data_regs, f30->register_count);\r\nif (error) {\r\ndev_err(&fn->dev,\r\n"%s: Failed to read F30 data registers: %d\n",\r\n__func__, error);\r\nreturn error;\r\n}\r\n}\r\nif (f30->has_gpio) {\r\nfor (i = 0; i < f30->gpioled_count; i++)\r\nif (f30->gpioled_key_map[i] != KEY_RESERVED)\r\nrmi_f30_report_button(fn, f30, i);\r\nif (f30->trackstick_buttons)\r\nrmi_f03_commit_buttons(f30->f03);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_f30_config(struct rmi_function *fn)\r\n{\r\nstruct f30_data *f30 = dev_get_drvdata(&fn->dev);\r\nstruct rmi_driver *drv = fn->rmi_dev->driver;\r\nconst struct rmi_device_platform_data *pdata =\r\nrmi_get_platform_data(fn->rmi_dev);\r\nint error;\r\nif (!f30)\r\nreturn 0;\r\nif (pdata->f30_data.trackstick_buttons) {\r\nf30->f03 = rmi_find_function(fn->rmi_dev, 0x03);\r\nf30->trackstick_buttons = f30->f03 != NULL;\r\n}\r\nif (pdata->f30_data.disable) {\r\ndrv->clear_irq_bits(fn->rmi_dev, fn->irq_mask);\r\n} else {\r\nerror = rmi_write_block(fn->rmi_dev, fn->fd.control_base_addr,\r\nf30->ctrl_regs, f30->ctrl_regs_size);\r\nif (error) {\r\ndev_err(&fn->dev,\r\n"%s: Could not write control registers at 0x%x: %d\n",\r\n__func__, fn->fd.control_base_addr, error);\r\nreturn error;\r\n}\r\ndrv->set_irq_bits(fn->rmi_dev, fn->irq_mask);\r\n}\r\nreturn 0;\r\n}\r\nstatic void rmi_f30_set_ctrl_data(struct rmi_f30_ctrl_data *ctrl,\r\nint *ctrl_addr, int len, u8 **reg)\r\n{\r\nctrl->address = *ctrl_addr;\r\nctrl->length = len;\r\nctrl->regs = *reg;\r\n*ctrl_addr += len;\r\n*reg += len;\r\n}\r\nstatic bool rmi_f30_is_valid_button(int button, struct rmi_f30_ctrl_data *ctrl)\r\n{\r\nint byte_position = button >> 3;\r\nint bit_position = button & 0x07;\r\nreturn !(ctrl[2].regs[byte_position] & BIT(bit_position)) &&\r\n(ctrl[3].regs[byte_position] & BIT(bit_position));\r\n}\r\nstatic int rmi_f30_map_gpios(struct rmi_function *fn,\r\nstruct f30_data *f30)\r\n{\r\nconst struct rmi_device_platform_data *pdata =\r\nrmi_get_platform_data(fn->rmi_dev);\r\nstruct input_dev *input = f30->input;\r\nunsigned int button = BTN_LEFT;\r\nunsigned int trackstick_button = BTN_LEFT;\r\nbool button_mapped = false;\r\nint i;\r\nf30->gpioled_key_map = devm_kcalloc(&fn->dev,\r\nf30->gpioled_count,\r\nsizeof(f30->gpioled_key_map[0]),\r\nGFP_KERNEL);\r\nif (!f30->gpioled_key_map) {\r\ndev_err(&fn->dev, "Failed to allocate gpioled map memory.\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < f30->gpioled_count; i++) {\r\nif (!rmi_f30_is_valid_button(i, f30->ctrl))\r\ncontinue;\r\nif (pdata->f30_data.trackstick_buttons &&\r\ni >= TRACKSTICK_RANGE_START && i < TRACKSTICK_RANGE_END) {\r\nf30->gpioled_key_map[i] = trackstick_button++;\r\n} else if (!pdata->f30_data.buttonpad || !button_mapped) {\r\nf30->gpioled_key_map[i] = button;\r\ninput_set_capability(input, EV_KEY, button++);\r\nbutton_mapped = true;\r\n}\r\n}\r\ninput->keycode = f30->gpioled_key_map;\r\ninput->keycodesize = sizeof(f30->gpioled_key_map[0]);\r\ninput->keycodemax = f30->gpioled_count;\r\nif (pdata->f30_data.buttonpad || (button - BTN_LEFT == 1))\r\n__set_bit(INPUT_PROP_BUTTONPAD, input->propbit);\r\nreturn 0;\r\n}\r\nstatic int rmi_f30_initialize(struct rmi_function *fn, struct f30_data *f30)\r\n{\r\nu8 *ctrl_reg = f30->ctrl_regs;\r\nint control_address = fn->fd.control_base_addr;\r\nu8 buf[RMI_F30_QUERY_SIZE];\r\nint error;\r\nerror = rmi_read_block(fn->rmi_dev, fn->fd.query_base_addr,\r\nbuf, RMI_F30_QUERY_SIZE);\r\nif (error) {\r\ndev_err(&fn->dev, "Failed to read query register\n");\r\nreturn error;\r\n}\r\nf30->has_extended_pattern = buf[0] & RMI_F30_EXTENDED_PATTERNS;\r\nf30->has_mappable_buttons = buf[0] & RMI_F30_HAS_MAPPABLE_BUTTONS;\r\nf30->has_led = buf[0] & RMI_F30_HAS_LED;\r\nf30->has_gpio = buf[0] & RMI_F30_HAS_GPIO;\r\nf30->has_haptic = buf[0] & RMI_F30_HAS_HAPTIC;\r\nf30->has_gpio_driver_control = buf[0] & RMI_F30_HAS_GPIO_DRV_CTL;\r\nf30->has_mech_mouse_btns = buf[0] & RMI_F30_HAS_MECH_MOUSE_BTNS;\r\nf30->gpioled_count = buf[1] & RMI_F30_GPIO_LED_COUNT;\r\nf30->register_count = DIV_ROUND_UP(f30->gpioled_count, 8);\r\nif (f30->has_gpio && f30->has_led)\r\nrmi_f30_set_ctrl_data(&f30->ctrl[0], &control_address,\r\nf30->register_count, &ctrl_reg);\r\nrmi_f30_set_ctrl_data(&f30->ctrl[1], &control_address,\r\nsizeof(u8), &ctrl_reg);\r\nif (f30->has_gpio) {\r\nrmi_f30_set_ctrl_data(&f30->ctrl[2], &control_address,\r\nf30->register_count, &ctrl_reg);\r\nrmi_f30_set_ctrl_data(&f30->ctrl[3], &control_address,\r\nf30->register_count, &ctrl_reg);\r\n}\r\nif (f30->has_led) {\r\nrmi_f30_set_ctrl_data(&f30->ctrl[4], &control_address,\r\nf30->register_count, &ctrl_reg);\r\nrmi_f30_set_ctrl_data(&f30->ctrl[5], &control_address,\r\nf30->has_extended_pattern ? 6 : 2,\r\n&ctrl_reg);\r\n}\r\nif (f30->has_led || f30->has_gpio_driver_control) {\r\nrmi_f30_set_ctrl_data(&f30->ctrl[6], &control_address,\r\nf30->gpioled_count, &ctrl_reg);\r\n}\r\nif (f30->has_mappable_buttons) {\r\nrmi_f30_set_ctrl_data(&f30->ctrl[7], &control_address,\r\nf30->gpioled_count, &ctrl_reg);\r\n}\r\nif (f30->has_haptic) {\r\nrmi_f30_set_ctrl_data(&f30->ctrl[8], &control_address,\r\nf30->register_count, &ctrl_reg);\r\nrmi_f30_set_ctrl_data(&f30->ctrl[9], &control_address,\r\nsizeof(u8), &ctrl_reg);\r\n}\r\nif (f30->has_mech_mouse_btns)\r\nrmi_f30_set_ctrl_data(&f30->ctrl[10], &control_address,\r\nsizeof(u8), &ctrl_reg);\r\nf30->ctrl_regs_size = ctrl_reg -\r\nf30->ctrl_regs ?: RMI_F30_CTRL_REGS_MAX_SIZE;\r\nerror = rmi_f30_read_control_parameters(fn, f30);\r\nif (error) {\r\ndev_err(&fn->dev,\r\n"Failed to initialize F30 control params: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nif (f30->has_gpio) {\r\nerror = rmi_f30_map_gpios(fn, f30);\r\nif (error)\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_f30_probe(struct rmi_function *fn)\r\n{\r\nstruct rmi_device *rmi_dev = fn->rmi_dev;\r\nconst struct rmi_device_platform_data *pdata =\r\nrmi_get_platform_data(rmi_dev);\r\nstruct rmi_driver_data *drv_data = dev_get_drvdata(&rmi_dev->dev);\r\nstruct f30_data *f30;\r\nint error;\r\nif (pdata->f30_data.disable)\r\nreturn 0;\r\nif (!drv_data->input) {\r\ndev_info(&fn->dev, "F30: no input device found, ignoring\n");\r\nreturn -ENXIO;\r\n}\r\nf30 = devm_kzalloc(&fn->dev, sizeof(*f30), GFP_KERNEL);\r\nif (!f30)\r\nreturn -ENOMEM;\r\nf30->input = drv_data->input;\r\nerror = rmi_f30_initialize(fn, f30);\r\nif (error)\r\nreturn error;\r\ndev_set_drvdata(&fn->dev, f30);\r\nreturn 0;\r\n}
