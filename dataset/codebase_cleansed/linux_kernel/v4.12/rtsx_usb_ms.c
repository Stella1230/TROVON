static inline struct device *ms_dev(struct rtsx_usb_ms *host)\r\n{\r\nreturn &(host->pdev->dev);\r\n}\r\nstatic inline void ms_clear_error(struct rtsx_usb_ms *host)\r\n{\r\nstruct rtsx_ucr *ucr = host->ucr;\r\nrtsx_usb_ep0_write_register(ucr, CARD_STOP,\r\nMS_STOP | MS_CLR_ERR,\r\nMS_STOP | MS_CLR_ERR);\r\nrtsx_usb_clear_dma_err(ucr);\r\nrtsx_usb_clear_fsm_err(ucr);\r\n}\r\nstatic void ms_print_debug_regs(struct rtsx_usb_ms *host)\r\n{\r\nstruct rtsx_ucr *ucr = host->ucr;\r\nu16 i;\r\nu8 *ptr;\r\nrtsx_usb_init_cmd(ucr);\r\nfor (i = 0xFD40; i <= 0xFD44; i++)\r\nrtsx_usb_add_cmd(ucr, READ_REG_CMD, i, 0, 0);\r\nfor (i = 0xFD51; i <= 0xFD56; i++)\r\nrtsx_usb_add_cmd(ucr, READ_REG_CMD, i, 0, 0);\r\nfor (i = 0xFD60; i <= 0xFD65; i++)\r\nrtsx_usb_add_cmd(ucr, READ_REG_CMD, i, 0, 0);\r\nrtsx_usb_add_cmd(ucr, READ_REG_CMD, CARD_DATA_SOURCE, 0, 0);\r\nrtsx_usb_add_cmd(ucr, READ_REG_CMD, CARD_SELECT, 0, 0);\r\nrtsx_usb_add_cmd(ucr, READ_REG_CMD, CARD_CLK_EN, 0, 0);\r\nrtsx_usb_add_cmd(ucr, READ_REG_CMD, CARD_PWR_CTL, 0, 0);\r\nrtsx_usb_send_cmd(ucr, MODE_CR, 100);\r\nrtsx_usb_get_rsp(ucr, 21, 100);\r\nptr = ucr->rsp_buf;\r\nfor (i = 0xFD40; i <= 0xFD44; i++)\r\ndev_dbg(ms_dev(host), "0x%04X: 0x%02x\n", i, *(ptr++));\r\nfor (i = 0xFD51; i <= 0xFD56; i++)\r\ndev_dbg(ms_dev(host), "0x%04X: 0x%02x\n", i, *(ptr++));\r\nfor (i = 0xFD60; i <= 0xFD65; i++)\r\ndev_dbg(ms_dev(host), "0x%04X: 0x%02x\n", i, *(ptr++));\r\ndev_dbg(ms_dev(host), "0x%04X: 0x%02x\n", CARD_DATA_SOURCE, *(ptr++));\r\ndev_dbg(ms_dev(host), "0x%04X: 0x%02x\n", CARD_SELECT, *(ptr++));\r\ndev_dbg(ms_dev(host), "0x%04X: 0x%02x\n", CARD_CLK_EN, *(ptr++));\r\ndev_dbg(ms_dev(host), "0x%04X: 0x%02x\n", CARD_PWR_CTL, *(ptr++));\r\n}\r\nstatic void ms_print_debug_regs(struct rtsx_usb_ms *host)\r\n{\r\n}\r\nstatic int ms_pull_ctl_disable_lqfp48(struct rtsx_ucr *ucr)\r\n{\r\nrtsx_usb_init_cmd(ucr);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL1, 0xFF, 0x55);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL2, 0xFF, 0x55);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL3, 0xFF, 0x95);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL4, 0xFF, 0x55);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL5, 0xFF, 0x55);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL6, 0xFF, 0xA5);\r\nreturn rtsx_usb_send_cmd(ucr, MODE_C, 100);\r\n}\r\nstatic int ms_pull_ctl_disable_qfn24(struct rtsx_ucr *ucr)\r\n{\r\nrtsx_usb_init_cmd(ucr);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL1, 0xFF, 0x65);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL2, 0xFF, 0x55);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL3, 0xFF, 0x95);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL4, 0xFF, 0x55);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL5, 0xFF, 0x56);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL6, 0xFF, 0x59);\r\nreturn rtsx_usb_send_cmd(ucr, MODE_C, 100);\r\n}\r\nstatic int ms_pull_ctl_enable_lqfp48(struct rtsx_ucr *ucr)\r\n{\r\nrtsx_usb_init_cmd(ucr);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL1, 0xFF, 0x55);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL2, 0xFF, 0x55);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL3, 0xFF, 0x95);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL4, 0xFF, 0x55);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL5, 0xFF, 0x55);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL6, 0xFF, 0xA5);\r\nreturn rtsx_usb_send_cmd(ucr, MODE_C, 100);\r\n}\r\nstatic int ms_pull_ctl_enable_qfn24(struct rtsx_ucr *ucr)\r\n{\r\nrtsx_usb_init_cmd(ucr);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL1, 0xFF, 0x65);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL2, 0xFF, 0x55);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL3, 0xFF, 0x95);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL4, 0xFF, 0x55);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL5, 0xFF, 0x55);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL6, 0xFF, 0x59);\r\nreturn rtsx_usb_send_cmd(ucr, MODE_C, 100);\r\n}\r\nstatic int ms_power_on(struct rtsx_usb_ms *host)\r\n{\r\nstruct rtsx_ucr *ucr = host->ucr;\r\nint err;\r\ndev_dbg(ms_dev(host), "%s\n", __func__);\r\nrtsx_usb_init_cmd(ucr);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_SELECT, 0x07, MS_MOD_SEL);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_SHARE_MODE,\r\nCARD_SHARE_MASK, CARD_SHARE_MS);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_CLK_EN,\r\nMS_CLK_EN, MS_CLK_EN);\r\nerr = rtsx_usb_send_cmd(ucr, MODE_C, 100);\r\nif (err < 0)\r\nreturn err;\r\nif (CHECK_PKG(ucr, LQFP48))\r\nerr = ms_pull_ctl_enable_lqfp48(ucr);\r\nelse\r\nerr = ms_pull_ctl_enable_qfn24(ucr);\r\nif (err < 0)\r\nreturn err;\r\nerr = rtsx_usb_write_register(ucr, CARD_PWR_CTL,\r\nPOWER_MASK, PARTIAL_POWER_ON);\r\nif (err)\r\nreturn err;\r\nusleep_range(800, 1000);\r\nrtsx_usb_init_cmd(ucr);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PWR_CTL,\r\nPOWER_MASK, POWER_ON);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_OE,\r\nMS_OUTPUT_EN, MS_OUTPUT_EN);\r\nreturn rtsx_usb_send_cmd(ucr, MODE_C, 100);\r\n}\r\nstatic int ms_power_off(struct rtsx_usb_ms *host)\r\n{\r\nstruct rtsx_ucr *ucr = host->ucr;\r\nint err;\r\ndev_dbg(ms_dev(host), "%s\n", __func__);\r\nrtsx_usb_init_cmd(ucr);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_CLK_EN, MS_CLK_EN, 0);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_OE, MS_OUTPUT_EN, 0);\r\nerr = rtsx_usb_send_cmd(ucr, MODE_C, 100);\r\nif (err < 0)\r\nreturn err;\r\nif (CHECK_PKG(ucr, LQFP48))\r\nreturn ms_pull_ctl_disable_lqfp48(ucr);\r\nreturn ms_pull_ctl_disable_qfn24(ucr);\r\n}\r\nstatic int ms_transfer_data(struct rtsx_usb_ms *host, unsigned char data_dir,\r\nu8 tpc, u8 cfg, struct scatterlist *sg)\r\n{\r\nstruct rtsx_ucr *ucr = host->ucr;\r\nint err;\r\nunsigned int length = sg->length;\r\nu16 sec_cnt = (u16)(length / 512);\r\nu8 trans_mode, dma_dir, flag;\r\nunsigned int pipe;\r\nstruct memstick_dev *card = host->msh->card;\r\ndev_dbg(ms_dev(host), "%s: tpc = 0x%02x, data_dir = %s, length = %d\n",\r\n__func__, tpc, (data_dir == READ) ? "READ" : "WRITE",\r\nlength);\r\nif (data_dir == READ) {\r\nflag = MODE_CDIR;\r\ndma_dir = DMA_DIR_FROM_CARD;\r\nif (card->id.type != MEMSTICK_TYPE_PRO)\r\ntrans_mode = MS_TM_NORMAL_READ;\r\nelse\r\ntrans_mode = MS_TM_AUTO_READ;\r\npipe = usb_rcvbulkpipe(ucr->pusb_dev, EP_BULK_IN);\r\n} else {\r\nflag = MODE_CDOR;\r\ndma_dir = DMA_DIR_TO_CARD;\r\nif (card->id.type != MEMSTICK_TYPE_PRO)\r\ntrans_mode = MS_TM_NORMAL_WRITE;\r\nelse\r\ntrans_mode = MS_TM_AUTO_WRITE;\r\npipe = usb_sndbulkpipe(ucr->pusb_dev, EP_BULK_OUT);\r\n}\r\nrtsx_usb_init_cmd(ucr);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MS_TPC, 0xFF, tpc);\r\nif (card->id.type == MEMSTICK_TYPE_PRO) {\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MS_SECTOR_CNT_H,\r\n0xFF, (u8)(sec_cnt >> 8));\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MS_SECTOR_CNT_L,\r\n0xFF, (u8)sec_cnt);\r\n}\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MS_TRANS_CFG, 0xFF, cfg);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MC_DMA_TC3,\r\n0xFF, (u8)(length >> 24));\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MC_DMA_TC2,\r\n0xFF, (u8)(length >> 16));\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MC_DMA_TC1,\r\n0xFF, (u8)(length >> 8));\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MC_DMA_TC0, 0xFF,\r\n(u8)length);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MC_DMA_CTL,\r\n0x03 | DMA_PACK_SIZE_MASK, dma_dir | DMA_EN | DMA_512);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_DATA_SOURCE,\r\n0x01, RING_BUFFER);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MS_TRANSFER,\r\n0xFF, MS_TRANSFER_START | trans_mode);\r\nrtsx_usb_add_cmd(ucr, CHECK_REG_CMD, MS_TRANSFER,\r\nMS_TRANSFER_END, MS_TRANSFER_END);\r\nerr = rtsx_usb_send_cmd(ucr, flag | STAGE_MS_STATUS, 100);\r\nif (err)\r\nreturn err;\r\nerr = rtsx_usb_transfer_data(ucr, pipe, sg, length,\r\n1, NULL, 10000);\r\nif (err)\r\ngoto err_out;\r\nerr = rtsx_usb_get_rsp(ucr, 3, 15000);\r\nif (err)\r\ngoto err_out;\r\nif (ucr->rsp_buf[0] & MS_TRANSFER_ERR ||\r\nucr->rsp_buf[1] & (MS_CRC16_ERR | MS_RDY_TIMEOUT)) {\r\nerr = -EIO;\r\ngoto err_out;\r\n}\r\nreturn 0;\r\nerr_out:\r\nms_clear_error(host);\r\nreturn err;\r\n}\r\nstatic int ms_write_bytes(struct rtsx_usb_ms *host, u8 tpc,\r\nu8 cfg, u8 cnt, u8 *data, u8 *int_reg)\r\n{\r\nstruct rtsx_ucr *ucr = host->ucr;\r\nint err, i;\r\ndev_dbg(ms_dev(host), "%s: tpc = 0x%02x\n", __func__, tpc);\r\nrtsx_usb_init_cmd(ucr);\r\nfor (i = 0; i < cnt; i++)\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\r\nPPBUF_BASE2 + i, 0xFF, data[i]);\r\nif (cnt % 2)\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\r\nPPBUF_BASE2 + i, 0xFF, 0xFF);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MS_TPC, 0xFF, tpc);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MS_BYTE_CNT, 0xFF, cnt);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MS_TRANS_CFG, 0xFF, cfg);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_DATA_SOURCE,\r\n0x01, PINGPONG_BUFFER);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MS_TRANSFER,\r\n0xFF, MS_TRANSFER_START | MS_TM_WRITE_BYTES);\r\nrtsx_usb_add_cmd(ucr, CHECK_REG_CMD, MS_TRANSFER,\r\nMS_TRANSFER_END, MS_TRANSFER_END);\r\nrtsx_usb_add_cmd(ucr, READ_REG_CMD, MS_TRANS_CFG, 0, 0);\r\nerr = rtsx_usb_send_cmd(ucr, MODE_CR, 100);\r\nif (err)\r\nreturn err;\r\nerr = rtsx_usb_get_rsp(ucr, 2, 5000);\r\nif (err || (ucr->rsp_buf[0] & MS_TRANSFER_ERR)) {\r\nu8 val;\r\nrtsx_usb_ep0_read_register(ucr, MS_TRANS_CFG, &val);\r\ndev_dbg(ms_dev(host), "MS_TRANS_CFG: 0x%02x\n", val);\r\nif (int_reg)\r\n*int_reg = val & 0x0F;\r\nms_print_debug_regs(host);\r\nms_clear_error(host);\r\nif (!(tpc & 0x08)) {\r\nif (val & MS_CRC16_ERR)\r\nreturn -EIO;\r\n} else {\r\nif (!(val & 0x80)) {\r\nif (val & (MS_INT_ERR | MS_INT_CMDNK))\r\nreturn -EIO;\r\n}\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nif (int_reg)\r\n*int_reg = ucr->rsp_buf[1] & 0x0F;\r\nreturn 0;\r\n}\r\nstatic int ms_read_bytes(struct rtsx_usb_ms *host, u8 tpc,\r\nu8 cfg, u8 cnt, u8 *data, u8 *int_reg)\r\n{\r\nstruct rtsx_ucr *ucr = host->ucr;\r\nint err, i;\r\nu8 *ptr;\r\ndev_dbg(ms_dev(host), "%s: tpc = 0x%02x\n", __func__, tpc);\r\nrtsx_usb_init_cmd(ucr);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MS_TPC, 0xFF, tpc);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MS_BYTE_CNT, 0xFF, cnt);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MS_TRANS_CFG, 0xFF, cfg);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_DATA_SOURCE,\r\n0x01, PINGPONG_BUFFER);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MS_TRANSFER,\r\n0xFF, MS_TRANSFER_START | MS_TM_READ_BYTES);\r\nrtsx_usb_add_cmd(ucr, CHECK_REG_CMD, MS_TRANSFER,\r\nMS_TRANSFER_END, MS_TRANSFER_END);\r\nfor (i = 0; i < cnt - 1; i++)\r\nrtsx_usb_add_cmd(ucr, READ_REG_CMD, PPBUF_BASE2 + i, 0, 0);\r\nif (cnt % 2)\r\nrtsx_usb_add_cmd(ucr, READ_REG_CMD, PPBUF_BASE2 + cnt, 0, 0);\r\nelse\r\nrtsx_usb_add_cmd(ucr, READ_REG_CMD,\r\nPPBUF_BASE2 + cnt - 1, 0, 0);\r\nrtsx_usb_add_cmd(ucr, READ_REG_CMD, MS_TRANS_CFG, 0, 0);\r\nerr = rtsx_usb_send_cmd(ucr, MODE_CR, 100);\r\nif (err)\r\nreturn err;\r\nerr = rtsx_usb_get_rsp(ucr, cnt + 2, 5000);\r\nif (err || (ucr->rsp_buf[0] & MS_TRANSFER_ERR)) {\r\nu8 val;\r\nrtsx_usb_ep0_read_register(ucr, MS_TRANS_CFG, &val);\r\ndev_dbg(ms_dev(host), "MS_TRANS_CFG: 0x%02x\n", val);\r\nif (int_reg && (host->ifmode != MEMSTICK_SERIAL))\r\n*int_reg = val & 0x0F;\r\nms_print_debug_regs(host);\r\nms_clear_error(host);\r\nif (!(tpc & 0x08)) {\r\nif (val & MS_CRC16_ERR)\r\nreturn -EIO;\r\n} else {\r\nif (!(val & 0x80)) {\r\nif (val & (MS_INT_ERR | MS_INT_CMDNK))\r\nreturn -EIO;\r\n}\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nptr = ucr->rsp_buf + 1;\r\nfor (i = 0; i < cnt; i++)\r\ndata[i] = *ptr++;\r\nif (int_reg && (host->ifmode != MEMSTICK_SERIAL))\r\n*int_reg = *ptr & 0x0F;\r\nreturn 0;\r\n}\r\nstatic int rtsx_usb_ms_issue_cmd(struct rtsx_usb_ms *host)\r\n{\r\nstruct memstick_request *req = host->req;\r\nint err = 0;\r\nu8 cfg = 0, int_reg;\r\ndev_dbg(ms_dev(host), "%s\n", __func__);\r\nif (req->need_card_int) {\r\nif (host->ifmode != MEMSTICK_SERIAL)\r\ncfg = WAIT_INT;\r\n}\r\nif (req->long_data) {\r\nerr = ms_transfer_data(host, req->data_dir,\r\nreq->tpc, cfg, &(req->sg));\r\n} else {\r\nif (req->data_dir == READ)\r\nerr = ms_read_bytes(host, req->tpc, cfg,\r\nreq->data_len, req->data, &int_reg);\r\nelse\r\nerr = ms_write_bytes(host, req->tpc, cfg,\r\nreq->data_len, req->data, &int_reg);\r\n}\r\nif (err < 0)\r\nreturn err;\r\nif (req->need_card_int) {\r\nif (host->ifmode == MEMSTICK_SERIAL) {\r\nerr = ms_read_bytes(host, MS_TPC_GET_INT,\r\nNO_WAIT_INT, 1, &req->int_reg, NULL);\r\nif (err < 0)\r\nreturn err;\r\n} else {\r\nif (int_reg & MS_INT_CMDNK)\r\nreq->int_reg |= MEMSTICK_INT_CMDNAK;\r\nif (int_reg & MS_INT_BREQ)\r\nreq->int_reg |= MEMSTICK_INT_BREQ;\r\nif (int_reg & MS_INT_ERR)\r\nreq->int_reg |= MEMSTICK_INT_ERR;\r\nif (int_reg & MS_INT_CED)\r\nreq->int_reg |= MEMSTICK_INT_CED;\r\n}\r\ndev_dbg(ms_dev(host), "int_reg: 0x%02x\n", req->int_reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic void rtsx_usb_ms_handle_req(struct work_struct *work)\r\n{\r\nstruct rtsx_usb_ms *host = container_of(work,\r\nstruct rtsx_usb_ms, handle_req);\r\nstruct rtsx_ucr *ucr = host->ucr;\r\nstruct memstick_host *msh = host->msh;\r\nint rc;\r\nif (!host->req) {\r\npm_runtime_get_sync(ms_dev(host));\r\ndo {\r\nrc = memstick_next_req(msh, &host->req);\r\ndev_dbg(ms_dev(host), "next req %d\n", rc);\r\nif (!rc) {\r\nmutex_lock(&ucr->dev_mutex);\r\nif (rtsx_usb_card_exclusive_check(ucr,\r\nRTSX_USB_MS_CARD))\r\nhost->req->error = -EIO;\r\nelse\r\nhost->req->error =\r\nrtsx_usb_ms_issue_cmd(host);\r\nmutex_unlock(&ucr->dev_mutex);\r\ndev_dbg(ms_dev(host), "req result %d\n",\r\nhost->req->error);\r\n}\r\n} while (!rc);\r\npm_runtime_put(ms_dev(host));\r\n}\r\n}\r\nstatic void rtsx_usb_ms_request(struct memstick_host *msh)\r\n{\r\nstruct rtsx_usb_ms *host = memstick_priv(msh);\r\ndev_dbg(ms_dev(host), "--> %s\n", __func__);\r\nif (!host->eject)\r\nschedule_work(&host->handle_req);\r\n}\r\nstatic int rtsx_usb_ms_set_param(struct memstick_host *msh,\r\nenum memstick_param param, int value)\r\n{\r\nstruct rtsx_usb_ms *host = memstick_priv(msh);\r\nstruct rtsx_ucr *ucr = host->ucr;\r\nunsigned int clock = 0;\r\nu8 ssc_depth = 0;\r\nint err;\r\ndev_dbg(ms_dev(host), "%s: param = %d, value = %d\n",\r\n__func__, param, value);\r\npm_runtime_get_sync(ms_dev(host));\r\nmutex_lock(&ucr->dev_mutex);\r\nerr = rtsx_usb_card_exclusive_check(ucr, RTSX_USB_MS_CARD);\r\nif (err)\r\ngoto out;\r\nswitch (param) {\r\ncase MEMSTICK_POWER:\r\nif (value == host->power_mode)\r\nbreak;\r\nif (value == MEMSTICK_POWER_ON) {\r\npm_runtime_get_sync(ms_dev(host));\r\nerr = ms_power_on(host);\r\n} else if (value == MEMSTICK_POWER_OFF) {\r\nerr = ms_power_off(host);\r\nif (host->msh->card)\r\npm_runtime_put_noidle(ms_dev(host));\r\nelse\r\npm_runtime_put(ms_dev(host));\r\n} else\r\nerr = -EINVAL;\r\nif (!err)\r\nhost->power_mode = value;\r\nbreak;\r\ncase MEMSTICK_INTERFACE:\r\nif (value == MEMSTICK_SERIAL) {\r\nclock = 19000000;\r\nssc_depth = SSC_DEPTH_512K;\r\nerr = rtsx_usb_write_register(ucr, MS_CFG, 0x5A,\r\nMS_BUS_WIDTH_1 | PUSH_TIME_DEFAULT);\r\nif (err < 0)\r\nbreak;\r\n} else if (value == MEMSTICK_PAR4) {\r\nclock = 39000000;\r\nssc_depth = SSC_DEPTH_1M;\r\nerr = rtsx_usb_write_register(ucr, MS_CFG, 0x5A,\r\nMS_BUS_WIDTH_4 | PUSH_TIME_ODD |\r\nMS_NO_CHECK_INT);\r\nif (err < 0)\r\nbreak;\r\n} else {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nerr = rtsx_usb_switch_clock(ucr, clock,\r\nssc_depth, false, true, false);\r\nif (err < 0) {\r\ndev_dbg(ms_dev(host), "switch clock failed\n");\r\nbreak;\r\n}\r\nhost->ssc_depth = ssc_depth;\r\nhost->clock = clock;\r\nhost->ifmode = value;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nout:\r\nmutex_unlock(&ucr->dev_mutex);\r\npm_runtime_put(ms_dev(host));\r\nif (param == MEMSTICK_POWER && value == MEMSTICK_POWER_ON)\r\nusleep_range(10000, 12000);\r\ndev_dbg(ms_dev(host), "%s: return = %d\n", __func__, err);\r\nreturn err;\r\n}\r\nstatic int rtsx_usb_ms_suspend(struct device *dev)\r\n{\r\nstruct rtsx_usb_ms *host = dev_get_drvdata(dev);\r\nstruct memstick_host *msh = host->msh;\r\ndev_dbg(ms_dev(host), "--> %s\n", __func__);\r\nmemstick_suspend_host(msh);\r\nreturn 0;\r\n}\r\nstatic int rtsx_usb_ms_resume(struct device *dev)\r\n{\r\nstruct rtsx_usb_ms *host = dev_get_drvdata(dev);\r\nstruct memstick_host *msh = host->msh;\r\ndev_dbg(ms_dev(host), "--> %s\n", __func__);\r\nmemstick_resume_host(msh);\r\nreturn 0;\r\n}\r\nstatic int rtsx_usb_detect_ms_card(void *__host)\r\n{\r\nstruct rtsx_usb_ms *host = (struct rtsx_usb_ms *)__host;\r\nstruct rtsx_ucr *ucr = host->ucr;\r\nu8 val = 0;\r\nint err;\r\nfor (;;) {\r\npm_runtime_get_sync(ms_dev(host));\r\nmutex_lock(&ucr->dev_mutex);\r\nerr = rtsx_usb_read_register(ucr, CARD_INT_PEND, &val);\r\nif (err) {\r\nmutex_unlock(&ucr->dev_mutex);\r\ngoto poll_again;\r\n}\r\nrtsx_usb_write_register(ucr, CARD_INT_PEND,\r\nXD_INT | MS_INT | SD_INT,\r\nXD_INT | MS_INT | SD_INT);\r\nmutex_unlock(&ucr->dev_mutex);\r\nif (val & MS_INT) {\r\ndev_dbg(ms_dev(host), "MS slot change detected\n");\r\nmemstick_detect_change(host->msh);\r\n}\r\npoll_again:\r\npm_runtime_put(ms_dev(host));\r\nif (host->eject)\r\nbreak;\r\nschedule_timeout_idle(HZ);\r\n}\r\ncomplete(&host->detect_ms_exit);\r\nreturn 0;\r\n}\r\nstatic int rtsx_usb_ms_drv_probe(struct platform_device *pdev)\r\n{\r\nstruct memstick_host *msh;\r\nstruct rtsx_usb_ms *host;\r\nstruct rtsx_ucr *ucr;\r\nint err;\r\nucr = usb_get_intfdata(to_usb_interface(pdev->dev.parent));\r\nif (!ucr)\r\nreturn -ENXIO;\r\ndev_dbg(&(pdev->dev),\r\n"Realtek USB Memstick controller found\n");\r\nmsh = memstick_alloc_host(sizeof(*host), &pdev->dev);\r\nif (!msh)\r\nreturn -ENOMEM;\r\nhost = memstick_priv(msh);\r\nhost->ucr = ucr;\r\nhost->msh = msh;\r\nhost->pdev = pdev;\r\nhost->power_mode = MEMSTICK_POWER_OFF;\r\nplatform_set_drvdata(pdev, host);\r\nmutex_init(&host->host_mutex);\r\nINIT_WORK(&host->handle_req, rtsx_usb_ms_handle_req);\r\ninit_completion(&host->detect_ms_exit);\r\nhost->detect_ms = kthread_create(rtsx_usb_detect_ms_card, host,\r\n"rtsx_usb_ms_%d", pdev->id);\r\nif (IS_ERR(host->detect_ms)) {\r\ndev_dbg(&(pdev->dev),\r\n"Unable to create polling thread.\n");\r\nerr = PTR_ERR(host->detect_ms);\r\ngoto err_out;\r\n}\r\nmsh->request = rtsx_usb_ms_request;\r\nmsh->set_param = rtsx_usb_ms_set_param;\r\nmsh->caps = MEMSTICK_CAP_PAR4;\r\npm_runtime_enable(&pdev->dev);\r\nerr = memstick_add_host(msh);\r\nif (err)\r\ngoto err_out;\r\nwake_up_process(host->detect_ms);\r\nreturn 0;\r\nerr_out:\r\nmemstick_free_host(msh);\r\nreturn err;\r\n}\r\nstatic int rtsx_usb_ms_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct rtsx_usb_ms *host = platform_get_drvdata(pdev);\r\nstruct memstick_host *msh;\r\nint err;\r\nmsh = host->msh;\r\nhost->eject = true;\r\ncancel_work_sync(&host->handle_req);\r\nmutex_lock(&host->host_mutex);\r\nif (host->req) {\r\ndev_dbg(&(pdev->dev),\r\n"%s: Controller removed during transfer\n",\r\ndev_name(&msh->dev));\r\nhost->req->error = -ENOMEDIUM;\r\ndo {\r\nerr = memstick_next_req(msh, &host->req);\r\nif (!err)\r\nhost->req->error = -ENOMEDIUM;\r\n} while (!err);\r\n}\r\nmutex_unlock(&host->host_mutex);\r\nwait_for_completion(&host->detect_ms_exit);\r\nmemstick_remove_host(msh);\r\nmemstick_free_host(msh);\r\nif (pm_runtime_active(ms_dev(host)))\r\npm_runtime_put(ms_dev(host));\r\npm_runtime_disable(&pdev->dev);\r\nplatform_set_drvdata(pdev, NULL);\r\ndev_dbg(&(pdev->dev),\r\n": Realtek USB Memstick controller has been removed\n");\r\nreturn 0;\r\n}
