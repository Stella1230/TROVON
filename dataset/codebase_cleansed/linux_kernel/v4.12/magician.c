static void toppoly_lcd_power(int on, struct fb_var_screeninfo *si)\r\n{\r\npr_debug("Toppoly LCD power: %s\n", on ? "on" : "off");\r\nif (on) {\r\ngpio_set_value(EGPIO_MAGICIAN_TOPPOLY_POWER, 1);\r\ngpio_set_value(GPIO106_MAGICIAN_LCD_DCDC_NRESET, 1);\r\nudelay(2000);\r\ngpio_set_value(EGPIO_MAGICIAN_LCD_POWER, 1);\r\nudelay(2000);\r\nudelay(2000);\r\ngpio_set_value(GPIO104_MAGICIAN_LCD_VOFF_EN, 1);\r\nudelay(2000);\r\ngpio_set_value(GPIO105_MAGICIAN_LCD_VON_EN, 1);\r\n} else {\r\nmsleep(15);\r\ngpio_set_value(GPIO105_MAGICIAN_LCD_VON_EN, 0);\r\nudelay(500);\r\ngpio_set_value(GPIO104_MAGICIAN_LCD_VOFF_EN, 0);\r\nudelay(1000);\r\ngpio_set_value(GPIO106_MAGICIAN_LCD_DCDC_NRESET, 0);\r\ngpio_set_value(EGPIO_MAGICIAN_LCD_POWER, 0);\r\n}\r\n}\r\nstatic void samsung_lcd_power(int on, struct fb_var_screeninfo *si)\r\n{\r\npr_debug("Samsung LCD power: %s\n", on ? "on" : "off");\r\nif (on) {\r\nif (system_rev < 3)\r\ngpio_set_value(GPIO75_MAGICIAN_SAMSUNG_POWER, 1);\r\nelse\r\ngpio_set_value(EGPIO_MAGICIAN_LCD_POWER, 1);\r\nmdelay(6);\r\ngpio_set_value(GPIO106_MAGICIAN_LCD_DCDC_NRESET, 1);\r\nmdelay(6);\r\ngpio_set_value(GPIO104_MAGICIAN_LCD_VOFF_EN, 1);\r\nmdelay(16);\r\ngpio_set_value(GPIO105_MAGICIAN_LCD_VON_EN, 1);\r\n} else {\r\ngpio_set_value(GPIO105_MAGICIAN_LCD_VON_EN, 0);\r\nmdelay(16);\r\ngpio_set_value(GPIO104_MAGICIAN_LCD_VOFF_EN, 0);\r\nmdelay(6);\r\ngpio_set_value(GPIO106_MAGICIAN_LCD_DCDC_NRESET, 0);\r\nmdelay(6);\r\nif (system_rev < 3)\r\ngpio_set_value(GPIO75_MAGICIAN_SAMSUNG_POWER, 0);\r\nelse\r\ngpio_set_value(EGPIO_MAGICIAN_LCD_POWER, 0);\r\n}\r\n}\r\nstatic int magician_backlight_init(struct device *dev)\r\n{\r\nreturn gpio_request_array(ARRAY_AND_SIZE(magician_bl_gpios));\r\n}\r\nstatic int magician_backlight_notify(struct device *dev, int brightness)\r\n{\r\npr_debug("Brightness = %i\n", brightness);\r\ngpio_set_value(EGPIO_MAGICIAN_BL_POWER, brightness);\r\nif (brightness >= 200) {\r\ngpio_set_value(EGPIO_MAGICIAN_BL_POWER2, 1);\r\nreturn brightness - 72;\r\n} else {\r\ngpio_set_value(EGPIO_MAGICIAN_BL_POWER2, 0);\r\nreturn brightness;\r\n}\r\n}\r\nstatic void magician_backlight_exit(struct device *dev)\r\n{\r\ngpio_free_array(ARRAY_AND_SIZE(magician_bl_gpios));\r\n}\r\nstatic void magician_udc_command(int cmd)\r\n{\r\nif (cmd == PXA2XX_UDC_CMD_CONNECT)\r\nUP2OCR |= UP2OCR_DPPUE | UP2OCR_DPPUBE;\r\nelse if (cmd == PXA2XX_UDC_CMD_DISCONNECT)\r\nUP2OCR &= ~(UP2OCR_DPPUE | UP2OCR_DPPUBE);\r\n}\r\nstatic int magician_supply_init(struct device *dev)\r\n{\r\nint ret = -1;\r\nret = gpio_request(EGPIO_MAGICIAN_CABLE_TYPE, "Cable is AC charger");\r\nif (ret) {\r\npr_err("Cannot request AC/USB charger GPIO (%i)\n", ret);\r\ngoto err_ac;\r\n}\r\nret = gpio_request(EGPIO_MAGICIAN_CABLE_INSERTED, "Cable inserted");\r\nif (ret) {\r\npr_err("Cannot request cable detection GPIO (%i)\n", ret);\r\ngoto err_usb;\r\n}\r\nreturn 0;\r\nerr_usb:\r\ngpio_free(EGPIO_MAGICIAN_CABLE_TYPE);\r\nerr_ac:\r\nreturn ret;\r\n}\r\nstatic void magician_set_charge(int flags)\r\n{\r\nif (flags & PDA_POWER_CHARGE_AC) {\r\npr_debug("Charging from AC\n");\r\ngpio_set_value(EGPIO_MAGICIAN_NICD_CHARGE, 1);\r\n} else if (flags & PDA_POWER_CHARGE_USB) {\r\npr_debug("Charging from USB\n");\r\ngpio_set_value(EGPIO_MAGICIAN_NICD_CHARGE, 1);\r\n} else {\r\npr_debug("Charging disabled\n");\r\ngpio_set_value(EGPIO_MAGICIAN_NICD_CHARGE, 0);\r\n}\r\n}\r\nstatic int magician_is_ac_online(void)\r\n{\r\nreturn gpio_get_value(EGPIO_MAGICIAN_CABLE_INSERTED) &&\r\ngpio_get_value(EGPIO_MAGICIAN_CABLE_TYPE);\r\n}\r\nstatic int magician_is_usb_online(void)\r\n{\r\nreturn gpio_get_value(EGPIO_MAGICIAN_CABLE_INSERTED) &&\r\n(!gpio_get_value(EGPIO_MAGICIAN_CABLE_TYPE));\r\n}\r\nstatic void magician_supply_exit(struct device *dev)\r\n{\r\ngpio_free(EGPIO_MAGICIAN_CABLE_INSERTED);\r\ngpio_free(EGPIO_MAGICIAN_CABLE_TYPE);\r\n}\r\nstatic int magician_mci_init(struct device *dev,\r\nirq_handler_t detect_irq, void *data)\r\n{\r\nreturn request_irq(IRQ_MAGICIAN_SD, detect_irq, 0,\r\n"mmc card detect", data);\r\n}\r\nstatic void magician_mci_exit(struct device *dev, void *data)\r\n{\r\nfree_irq(IRQ_MAGICIAN_SD, data);\r\n}\r\nstatic int magician_flash_init(struct platform_device *pdev)\r\n{\r\nint ret = gpio_request(EGPIO_MAGICIAN_FLASH_VPP, "flash Vpp enable");\r\nif (ret) {\r\npr_err("Cannot request flash enable GPIO (%i)\n", ret);\r\nreturn ret;\r\n}\r\nret = gpio_direction_output(EGPIO_MAGICIAN_FLASH_VPP, 1);\r\nif (ret) {\r\npr_err("Cannot set direction for flash enable (%i)\n", ret);\r\ngpio_free(EGPIO_MAGICIAN_FLASH_VPP);\r\n}\r\nreturn ret;\r\n}\r\nstatic void magician_set_vpp(struct platform_device *pdev, int vpp)\r\n{\r\ngpio_set_value(EGPIO_MAGICIAN_FLASH_VPP, vpp);\r\n}\r\nstatic void magician_flash_exit(struct platform_device *pdev)\r\n{\r\ngpio_free(EGPIO_MAGICIAN_FLASH_VPP);\r\n}\r\nstatic void __init magician_init(void)\r\n{\r\nvoid __iomem *cpld;\r\nint lcd_select;\r\nint err;\r\npxa2xx_mfp_config(ARRAY_AND_SIZE(magician_pin_config));\r\nerr = gpio_request_array(ARRAY_AND_SIZE(magician_global_gpios));\r\nif (err)\r\npr_err("magician: Failed to request global GPIOs: %d\n", err);\r\npxa_set_ffuart_info(NULL);\r\npxa_set_btuart_info(NULL);\r\npwm_add_table(magician_pwm_lookup, ARRAY_SIZE(magician_pwm_lookup));\r\npxa_set_ficp_info(&magician_ficp_info);\r\npxa27x_set_i2c_power_info(&magician_i2c_power_info);\r\npxa_set_i2c_info(&i2c_info);\r\ni2c_register_board_info(1,\r\nARRAY_AND_SIZE(magician_pwr_i2c_board_info));\r\npxa_set_mci_info(&magician_mci_info);\r\npxa_set_ohci_info(&magician_ohci_info);\r\npxa_set_udc_info(&magician_udc_info);\r\ncpld = ioremap_nocache(PXA_CS3_PHYS, 0x1000);\r\nif (cpld) {\r\nu8 board_id = __raw_readb(cpld + 0x14);\r\niounmap(cpld);\r\nsystem_rev = board_id & 0x7;\r\nlcd_select = board_id & 0x8;\r\npr_info("LCD type: %s\n", lcd_select ? "Samsung" : "Toppoly");\r\nif (lcd_select && (system_rev < 3))\r\ngpio_request_one(GPIO75_MAGICIAN_SAMSUNG_POWER,\r\nGPIOF_OUT_INIT_LOW, "Samsung LCD Power");\r\npxa_set_fb_info(NULL,\r\nlcd_select ? &samsung_info : &toppoly_info);\r\n} else\r\npr_err("LCD detection: CPLD mapping failed\n");\r\nregulator_register_always_on(0, "power", pwm_backlight_supply,\r\nARRAY_SIZE(pwm_backlight_supply), 5000000);\r\nplatform_add_devices(ARRAY_AND_SIZE(devices));\r\n}
