int copro_handle_mm_fault(struct mm_struct *mm, unsigned long ea,\r\nunsigned long dsisr, unsigned *flt)\r\n{\r\nstruct vm_area_struct *vma;\r\nunsigned long is_write;\r\nint ret;\r\nif (mm == NULL)\r\nreturn -EFAULT;\r\nif (mm->pgd == NULL)\r\nreturn -EFAULT;\r\ndown_read(&mm->mmap_sem);\r\nret = -EFAULT;\r\nvma = find_vma(mm, ea);\r\nif (!vma)\r\ngoto out_unlock;\r\nif (ea < vma->vm_start) {\r\nif (!(vma->vm_flags & VM_GROWSDOWN))\r\ngoto out_unlock;\r\nif (expand_stack(vma, ea))\r\ngoto out_unlock;\r\n}\r\nis_write = dsisr & DSISR_ISSTORE;\r\nif (is_write) {\r\nif (!(vma->vm_flags & VM_WRITE))\r\ngoto out_unlock;\r\n} else {\r\nif (!(vma->vm_flags & (VM_READ | VM_EXEC)))\r\ngoto out_unlock;\r\nif (!radix_enabled())\r\nWARN_ON_ONCE(dsisr & DSISR_PROTFAULT);\r\n}\r\nret = 0;\r\n*flt = handle_mm_fault(vma, ea, is_write ? FAULT_FLAG_WRITE : 0);\r\nif (unlikely(*flt & VM_FAULT_ERROR)) {\r\nif (*flt & VM_FAULT_OOM) {\r\nret = -ENOMEM;\r\ngoto out_unlock;\r\n} else if (*flt & (VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV)) {\r\nret = -EFAULT;\r\ngoto out_unlock;\r\n}\r\nBUG();\r\n}\r\nif (*flt & VM_FAULT_MAJOR)\r\ncurrent->maj_flt++;\r\nelse\r\ncurrent->min_flt++;\r\nout_unlock:\r\nup_read(&mm->mmap_sem);\r\nreturn ret;\r\n}\r\nint copro_calculate_slb(struct mm_struct *mm, u64 ea, struct copro_slb *slb)\r\n{\r\nu64 vsid, vsidkey;\r\nint psize, ssize;\r\nswitch (REGION_ID(ea)) {\r\ncase USER_REGION_ID:\r\npr_devel("%s: 0x%llx -- USER_REGION_ID\n", __func__, ea);\r\nif (mm == NULL)\r\nreturn 1;\r\npsize = get_slice_psize(mm, ea);\r\nssize = user_segment_size(ea);\r\nvsid = get_vsid(mm->context.id, ea, ssize);\r\nvsidkey = SLB_VSID_USER;\r\nbreak;\r\ncase VMALLOC_REGION_ID:\r\npr_devel("%s: 0x%llx -- VMALLOC_REGION_ID\n", __func__, ea);\r\nif (ea < VMALLOC_END)\r\npsize = mmu_vmalloc_psize;\r\nelse\r\npsize = mmu_io_psize;\r\nssize = mmu_kernel_ssize;\r\nvsid = get_kernel_vsid(ea, mmu_kernel_ssize);\r\nvsidkey = SLB_VSID_KERNEL;\r\nbreak;\r\ncase KERNEL_REGION_ID:\r\npr_devel("%s: 0x%llx -- KERNEL_REGION_ID\n", __func__, ea);\r\npsize = mmu_linear_psize;\r\nssize = mmu_kernel_ssize;\r\nvsid = get_kernel_vsid(ea, mmu_kernel_ssize);\r\nvsidkey = SLB_VSID_KERNEL;\r\nbreak;\r\ndefault:\r\npr_debug("%s: invalid region access at %016llx\n", __func__, ea);\r\nreturn 1;\r\n}\r\nif (!vsid)\r\nreturn 1;\r\nvsid = (vsid << slb_vsid_shift(ssize)) | vsidkey;\r\nvsid |= mmu_psize_defs[psize].sllp |\r\n((ssize == MMU_SEGSIZE_1T) ? SLB_VSID_B_1T : 0);\r\nslb->esid = (ea & (ssize == MMU_SEGSIZE_1T ? ESID_MASK_1T : ESID_MASK)) | SLB_ESID_V;\r\nslb->vsid = vsid;\r\nreturn 0;\r\n}\r\nvoid copro_flush_all_slbs(struct mm_struct *mm)\r\n{\r\n#ifdef CONFIG_SPU_BASE\r\nspu_flush_all_slbs(mm);\r\n#endif\r\ncxl_slbia(mm);\r\n}
