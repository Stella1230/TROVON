static int\r\nsnd_emu8000_open_dma(struct snd_emu8000 *emu, int write)\r\n{\r\nint i;\r\nfor (i = 0; i < EMU8000_DRAM_VOICES; i++) {\r\nsnd_emux_lock_voice(emu->emu, i);\r\nsnd_emu8000_dma_chan(emu, i, write);\r\n}\r\nEMU8000_VTFT_WRITE(emu, 30, 0);\r\nEMU8000_PSST_WRITE(emu, 30, 0x1d8);\r\nEMU8000_CSL_WRITE(emu, 30, 0x1e0);\r\nEMU8000_CCCA_WRITE(emu, 30, 0x1d8);\r\nEMU8000_VTFT_WRITE(emu, 31, 0);\r\nEMU8000_PSST_WRITE(emu, 31, 0x1d8);\r\nEMU8000_CSL_WRITE(emu, 31, 0x1e0);\r\nEMU8000_CCCA_WRITE(emu, 31, 0x1d8);\r\nreturn 0;\r\n}\r\nstatic void\r\nsnd_emu8000_close_dma(struct snd_emu8000 *emu)\r\n{\r\nint i;\r\nfor (i = 0; i < EMU8000_DRAM_VOICES; i++) {\r\nsnd_emu8000_dma_chan(emu, i, EMU8000_RAM_CLOSE);\r\nsnd_emux_unlock_voice(emu->emu, i);\r\n}\r\n}\r\nstatic unsigned short\r\nread_word(const void __user *buf, int offset, int mode)\r\n{\r\nunsigned short c;\r\nif (mode & SNDRV_SFNT_SAMPLE_8BITS) {\r\nunsigned char cc;\r\nget_user(cc, (unsigned char __user *)buf + offset);\r\nc = cc << 8;\r\n} else {\r\n#ifdef SNDRV_LITTLE_ENDIAN\r\nget_user(c, (unsigned short __user *)buf + offset);\r\n#else\r\nunsigned short cc;\r\nget_user(cc, (unsigned short __user *)buf + offset);\r\nc = swab16(cc);\r\n#endif\r\n}\r\nif (mode & SNDRV_SFNT_SAMPLE_UNSIGNED)\r\nc ^= 0x8000;\r\nreturn c;\r\n}\r\nstatic void\r\nsnd_emu8000_write_wait(struct snd_emu8000 *emu)\r\n{\r\nwhile ((EMU8000_SMALW_READ(emu) & 0x80000000) != 0) {\r\nschedule_timeout_interruptible(1);\r\nif (signal_pending(current))\r\nbreak;\r\n}\r\n}\r\nstatic inline void\r\nwrite_word(struct snd_emu8000 *emu, int *offset, unsigned short data)\r\n{\r\nif (emu8000_reset_addr) {\r\nif (emu8000_reset_addr > 1)\r\nsnd_emu8000_write_wait(emu);\r\nEMU8000_SMALW_WRITE(emu, *offset);\r\n}\r\nEMU8000_SMLD_WRITE(emu, data);\r\n*offset += 1;\r\n}\r\nint\r\nsnd_emu8000_sample_new(struct snd_emux *rec, struct snd_sf_sample *sp,\r\nstruct snd_util_memhdr *hdr,\r\nconst void __user *data, long count)\r\n{\r\nint i;\r\nint rc;\r\nint offset;\r\nint truesize;\r\nint dram_offset, dram_start;\r\nstruct snd_emu8000 *emu;\r\nemu = rec->hw;\r\nif (snd_BUG_ON(!sp))\r\nreturn -EINVAL;\r\nif (sp->v.size == 0)\r\nreturn 0;\r\nif (sp->v.loopstart > sp->v.loopend) {\r\nint tmp = sp->v.loopstart;\r\nsp->v.loopstart = sp->v.loopend;\r\nsp->v.loopend = tmp;\r\n}\r\ntruesize = sp->v.size;\r\nif (sp->v.mode_flags & (SNDRV_SFNT_SAMPLE_BIDIR_LOOP|SNDRV_SFNT_SAMPLE_REVERSE_LOOP))\r\ntruesize += sp->v.loopend - sp->v.loopstart;\r\nif (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_NO_BLANK)\r\ntruesize += BLANK_LOOP_SIZE;\r\nsp->block = snd_util_mem_alloc(hdr, truesize * 2);\r\nif (sp->block == NULL) {\r\nreturn -ENOSPC;\r\n}\r\nif (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_8BITS) {\r\nif (!access_ok(VERIFY_READ, data, sp->v.size))\r\nreturn -EFAULT;\r\n} else {\r\nif (!access_ok(VERIFY_READ, data, sp->v.size * 2))\r\nreturn -EFAULT;\r\n}\r\nsp->v.end -= sp->v.start;\r\nsp->v.loopstart -= sp->v.start;\r\nsp->v.loopend -= sp->v.start;\r\nsp->v.start = 0;\r\ndram_offset = EMU8000_DRAM_OFFSET + (sp->block->offset >> 1);\r\ndram_start = dram_offset;\r\nsp->v.truesize = truesize * 2;\r\nsnd_emux_terminate_all(emu->emu);\r\nif ((rc = snd_emu8000_open_dma(emu, EMU8000_RAM_WRITE)) != 0)\r\nreturn rc;\r\nsnd_emu8000_write_wait(emu);\r\nEMU8000_SMALW_WRITE(emu, dram_offset);\r\n#if 0\r\nif (! sp->block->offset) {\r\nfor (i = 0; i < BLANK_HEAD_SIZE; i++) {\r\nwrite_word(emu, &dram_offset, 0);\r\n}\r\n}\r\n#endif\r\noffset = 0;\r\nfor (i = 0; i < sp->v.size; i++) {\r\nunsigned short s;\r\ns = read_word(data, offset, sp->v.mode_flags);\r\noffset++;\r\nwrite_word(emu, &dram_offset, s);\r\ncond_resched();\r\nif (i == sp->v.loopend &&\r\n(sp->v.mode_flags & (SNDRV_SFNT_SAMPLE_BIDIR_LOOP|SNDRV_SFNT_SAMPLE_REVERSE_LOOP)))\r\n{\r\nint looplen = sp->v.loopend - sp->v.loopstart;\r\nint k;\r\nfor (k = 1; k <= looplen; k++) {\r\ns = read_word(data, offset - k, sp->v.mode_flags);\r\nwrite_word(emu, &dram_offset, s);\r\n}\r\nif (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_BIDIR_LOOP) {\r\nsp->v.loopend += looplen;\r\n} else {\r\nsp->v.loopstart += looplen;\r\nsp->v.loopend += looplen;\r\n}\r\nsp->v.end += looplen;\r\n}\r\n}\r\nif (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_NO_BLANK) {\r\nfor (i = 0; i < BLANK_LOOP_SIZE; i++) {\r\nwrite_word(emu, &dram_offset, 0);\r\n}\r\nif (sp->v.mode_flags & SNDRV_SFNT_SAMPLE_SINGLESHOT) {\r\nsp->v.loopstart = sp->v.end + BLANK_LOOP_START;\r\nsp->v.loopend = sp->v.end + BLANK_LOOP_END;\r\n}\r\n}\r\nsp->v.start += dram_start;\r\nsp->v.end += dram_start;\r\nsp->v.loopstart += dram_start;\r\nsp->v.loopend += dram_start;\r\nsnd_emu8000_close_dma(emu);\r\nsnd_emu8000_init_fm(emu);\r\nreturn 0;\r\n}\r\nint\r\nsnd_emu8000_sample_free(struct snd_emux *rec, struct snd_sf_sample *sp,\r\nstruct snd_util_memhdr *hdr)\r\n{\r\nif (sp->block) {\r\nsnd_util_mem_free(hdr, sp->block);\r\nsp->block = NULL;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nsnd_emu8000_sample_reset(struct snd_emux *rec)\r\n{\r\nsnd_emux_terminate_all(rec);\r\n}
