int\r\nsmb2_open_file(const unsigned int xid, struct cifs_open_parms *oparms,\r\n__u32 *oplock, FILE_ALL_INFO *buf)\r\n{\r\nint rc;\r\n__le16 *smb2_path;\r\nstruct smb2_file_all_info *smb2_data = NULL;\r\n__u8 smb2_oplock[17];\r\nstruct cifs_fid *fid = oparms->fid;\r\nstruct network_resiliency_req nr_ioctl_req;\r\nsmb2_path = cifs_convert_path_to_utf16(oparms->path, oparms->cifs_sb);\r\nif (smb2_path == NULL) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nsmb2_data = kzalloc(sizeof(struct smb2_file_all_info) + PATH_MAX * 2,\r\nGFP_KERNEL);\r\nif (smb2_data == NULL) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\noparms->desired_access |= FILE_READ_ATTRIBUTES;\r\n*smb2_oplock = SMB2_OPLOCK_LEVEL_BATCH;\r\nif (oparms->tcon->ses->server->capabilities & SMB2_GLOBAL_CAP_LEASING)\r\nmemcpy(smb2_oplock + 1, fid->lease_key, SMB2_LEASE_KEY_SIZE);\r\nrc = SMB2_open(xid, oparms, smb2_path, smb2_oplock, smb2_data, NULL);\r\nif (rc)\r\ngoto out;\r\nif (oparms->tcon->use_resilient) {\r\nnr_ioctl_req.Timeout = 0;\r\nnr_ioctl_req.Reserved = 0;\r\nrc = SMB2_ioctl(xid, oparms->tcon, fid->persistent_fid,\r\nfid->volatile_fid, FSCTL_LMR_REQUEST_RESILIENCY,\r\ntrue , false ,\r\n(char *)&nr_ioctl_req, sizeof(nr_ioctl_req),\r\nNULL, NULL );\r\nif (rc == -EOPNOTSUPP) {\r\ncifs_dbg(VFS,\r\n"resiliency not supported by server, disabling\n");\r\noparms->tcon->use_resilient = false;\r\n} else if (rc)\r\ncifs_dbg(FYI, "error %d setting resiliency\n", rc);\r\nrc = 0;\r\n}\r\nif (buf) {\r\nrc = SMB2_get_srv_num(xid, oparms->tcon, fid->persistent_fid,\r\nfid->volatile_fid,\r\n&smb2_data->IndexNumber);\r\nif (rc) {\r\nsmb2_data->IndexNumber = 0;\r\nrc = 0;\r\n}\r\nmove_smb2_info_to_cifs(buf, smb2_data);\r\n}\r\n*oplock = *smb2_oplock;\r\nout:\r\nkfree(smb2_data);\r\nkfree(smb2_path);\r\nreturn rc;\r\n}\r\nint\r\nsmb2_unlock_range(struct cifsFileInfo *cfile, struct file_lock *flock,\r\nconst unsigned int xid)\r\n{\r\nint rc = 0, stored_rc;\r\nunsigned int max_num, num = 0, max_buf;\r\nstruct smb2_lock_element *buf, *cur;\r\nstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\r\nstruct cifsInodeInfo *cinode = CIFS_I(d_inode(cfile->dentry));\r\nstruct cifsLockInfo *li, *tmp;\r\n__u64 length = 1 + flock->fl_end - flock->fl_start;\r\nstruct list_head tmp_llist;\r\nINIT_LIST_HEAD(&tmp_llist);\r\nmax_buf = tcon->ses->server->maxBuf;\r\nif (!max_buf)\r\nreturn -EINVAL;\r\nmax_num = max_buf / sizeof(struct smb2_lock_element);\r\nbuf = kcalloc(max_num, sizeof(struct smb2_lock_element), GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\ncur = buf;\r\ndown_write(&cinode->lock_sem);\r\nlist_for_each_entry_safe(li, tmp, &cfile->llist->locks, llist) {\r\nif (flock->fl_start > li->offset ||\r\n(flock->fl_start + length) <\r\n(li->offset + li->length))\r\ncontinue;\r\nif (current->tgid != li->pid)\r\ncontinue;\r\nif (cinode->can_cache_brlcks) {\r\nlist_del(&li->llist);\r\ncifs_del_lock_waiters(li);\r\nkfree(li);\r\ncontinue;\r\n}\r\ncur->Length = cpu_to_le64(li->length);\r\ncur->Offset = cpu_to_le64(li->offset);\r\ncur->Flags = cpu_to_le32(SMB2_LOCKFLAG_UNLOCK);\r\nlist_move(&li->llist, &tmp_llist);\r\nif (++num == max_num) {\r\nstored_rc = smb2_lockv(xid, tcon,\r\ncfile->fid.persistent_fid,\r\ncfile->fid.volatile_fid,\r\ncurrent->tgid, num, buf);\r\nif (stored_rc) {\r\ncifs_move_llist(&tmp_llist,\r\n&cfile->llist->locks);\r\nrc = stored_rc;\r\n} else\r\ncifs_free_llist(&tmp_llist);\r\ncur = buf;\r\nnum = 0;\r\n} else\r\ncur++;\r\n}\r\nif (num) {\r\nstored_rc = smb2_lockv(xid, tcon, cfile->fid.persistent_fid,\r\ncfile->fid.volatile_fid, current->tgid,\r\nnum, buf);\r\nif (stored_rc) {\r\ncifs_move_llist(&tmp_llist, &cfile->llist->locks);\r\nrc = stored_rc;\r\n} else\r\ncifs_free_llist(&tmp_llist);\r\n}\r\nup_write(&cinode->lock_sem);\r\nkfree(buf);\r\nreturn rc;\r\n}\r\nstatic int\r\nsmb2_push_mand_fdlocks(struct cifs_fid_locks *fdlocks, const unsigned int xid,\r\nstruct smb2_lock_element *buf, unsigned int max_num)\r\n{\r\nint rc = 0, stored_rc;\r\nstruct cifsFileInfo *cfile = fdlocks->cfile;\r\nstruct cifsLockInfo *li;\r\nunsigned int num = 0;\r\nstruct smb2_lock_element *cur = buf;\r\nstruct cifs_tcon *tcon = tlink_tcon(cfile->tlink);\r\nlist_for_each_entry(li, &fdlocks->locks, llist) {\r\ncur->Length = cpu_to_le64(li->length);\r\ncur->Offset = cpu_to_le64(li->offset);\r\ncur->Flags = cpu_to_le32(li->type |\r\nSMB2_LOCKFLAG_FAIL_IMMEDIATELY);\r\nif (++num == max_num) {\r\nstored_rc = smb2_lockv(xid, tcon,\r\ncfile->fid.persistent_fid,\r\ncfile->fid.volatile_fid,\r\ncurrent->tgid, num, buf);\r\nif (stored_rc)\r\nrc = stored_rc;\r\ncur = buf;\r\nnum = 0;\r\n} else\r\ncur++;\r\n}\r\nif (num) {\r\nstored_rc = smb2_lockv(xid, tcon,\r\ncfile->fid.persistent_fid,\r\ncfile->fid.volatile_fid,\r\ncurrent->tgid, num, buf);\r\nif (stored_rc)\r\nrc = stored_rc;\r\n}\r\nreturn rc;\r\n}\r\nint\r\nsmb2_push_mandatory_locks(struct cifsFileInfo *cfile)\r\n{\r\nint rc = 0, stored_rc;\r\nunsigned int xid;\r\nunsigned int max_num, max_buf;\r\nstruct smb2_lock_element *buf;\r\nstruct cifsInodeInfo *cinode = CIFS_I(d_inode(cfile->dentry));\r\nstruct cifs_fid_locks *fdlocks;\r\nxid = get_xid();\r\nmax_buf = tlink_tcon(cfile->tlink)->ses->server->maxBuf;\r\nif (max_buf < sizeof(struct smb2_lock_element)) {\r\nfree_xid(xid);\r\nreturn -EINVAL;\r\n}\r\nmax_num = max_buf / sizeof(struct smb2_lock_element);\r\nbuf = kcalloc(max_num, sizeof(struct smb2_lock_element), GFP_KERNEL);\r\nif (!buf) {\r\nfree_xid(xid);\r\nreturn -ENOMEM;\r\n}\r\nlist_for_each_entry(fdlocks, &cinode->llist, llist) {\r\nstored_rc = smb2_push_mand_fdlocks(fdlocks, xid, buf, max_num);\r\nif (stored_rc)\r\nrc = stored_rc;\r\n}\r\nkfree(buf);\r\nfree_xid(xid);\r\nreturn rc;\r\n}
