static void ahci_enable_ahci(void __iomem *mmio)\r\n{\r\nint i;\r\nu32 tmp;\r\ntmp = readl(mmio + HOST_CTL);\r\nif (tmp & HOST_AHCI_EN)\r\nreturn;\r\nfor (i = 0; i < 5; i++) {\r\ntmp |= HOST_AHCI_EN;\r\nwritel(tmp, mmio + HOST_CTL);\r\ntmp = readl(mmio + HOST_CTL);\r\nif (tmp & HOST_AHCI_EN)\r\nreturn;\r\nmsleep(10);\r\n}\r\nWARN_ON(1);\r\n}\r\nstatic int ahci_rpm_get_port(struct ata_port *ap)\r\n{\r\nreturn pm_runtime_get_sync(ap->dev);\r\n}\r\nstatic void ahci_rpm_put_port(struct ata_port *ap)\r\n{\r\npm_runtime_put(ap->dev);\r\n}\r\nstatic ssize_t ahci_show_host_caps(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct ata_port *ap = ata_shost_to_port(shost);\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nreturn sprintf(buf, "%x\n", hpriv->cap);\r\n}\r\nstatic ssize_t ahci_show_host_cap2(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct ata_port *ap = ata_shost_to_port(shost);\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nreturn sprintf(buf, "%x\n", hpriv->cap2);\r\n}\r\nstatic ssize_t ahci_show_host_version(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct ata_port *ap = ata_shost_to_port(shost);\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nreturn sprintf(buf, "%x\n", hpriv->version);\r\n}\r\nstatic ssize_t ahci_show_port_cmd(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct ata_port *ap = ata_shost_to_port(shost);\r\nvoid __iomem *port_mmio = ahci_port_base(ap);\r\nssize_t ret;\r\nahci_rpm_get_port(ap);\r\nret = sprintf(buf, "%x\n", readl(port_mmio + PORT_CMD));\r\nahci_rpm_put_port(ap);\r\nreturn ret;\r\n}\r\nstatic ssize_t ahci_read_em_buffer(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct ata_port *ap = ata_shost_to_port(shost);\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nvoid __iomem *mmio = hpriv->mmio;\r\nvoid __iomem *em_mmio = mmio + hpriv->em_loc;\r\nu32 em_ctl, msg;\r\nunsigned long flags;\r\nsize_t count;\r\nint i;\r\nahci_rpm_get_port(ap);\r\nspin_lock_irqsave(ap->lock, flags);\r\nem_ctl = readl(mmio + HOST_EM_CTL);\r\nif (!(ap->flags & ATA_FLAG_EM) || em_ctl & EM_CTL_XMT ||\r\n!(hpriv->em_msg_type & EM_MSG_TYPE_SGPIO)) {\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nahci_rpm_put_port(ap);\r\nreturn -EINVAL;\r\n}\r\nif (!(em_ctl & EM_CTL_MR)) {\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nahci_rpm_put_port(ap);\r\nreturn -EAGAIN;\r\n}\r\nif (!(em_ctl & EM_CTL_SMB))\r\nem_mmio += hpriv->em_buf_sz;\r\ncount = hpriv->em_buf_sz;\r\nif (count > PAGE_SIZE) {\r\nif (printk_ratelimit())\r\nata_port_warn(ap,\r\n"EM read buffer size too large: "\r\n"buffer size %u, page size %lu\n",\r\nhpriv->em_buf_sz, PAGE_SIZE);\r\ncount = PAGE_SIZE;\r\n}\r\nfor (i = 0; i < count; i += 4) {\r\nmsg = readl(em_mmio + i);\r\nbuf[i] = msg & 0xff;\r\nbuf[i + 1] = (msg >> 8) & 0xff;\r\nbuf[i + 2] = (msg >> 16) & 0xff;\r\nbuf[i + 3] = (msg >> 24) & 0xff;\r\n}\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nahci_rpm_put_port(ap);\r\nreturn i;\r\n}\r\nstatic ssize_t ahci_store_em_buffer(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct ata_port *ap = ata_shost_to_port(shost);\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nvoid __iomem *mmio = hpriv->mmio;\r\nvoid __iomem *em_mmio = mmio + hpriv->em_loc;\r\nconst unsigned char *msg_buf = buf;\r\nu32 em_ctl, msg;\r\nunsigned long flags;\r\nint i;\r\nif (!(ap->flags & ATA_FLAG_EM) ||\r\n!(hpriv->em_msg_type & EM_MSG_TYPE_SGPIO) ||\r\nsize % 4 || size > hpriv->em_buf_sz)\r\nreturn -EINVAL;\r\nahci_rpm_get_port(ap);\r\nspin_lock_irqsave(ap->lock, flags);\r\nem_ctl = readl(mmio + HOST_EM_CTL);\r\nif (em_ctl & EM_CTL_TM) {\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nahci_rpm_put_port(ap);\r\nreturn -EBUSY;\r\n}\r\nfor (i = 0; i < size; i += 4) {\r\nmsg = msg_buf[i] | msg_buf[i + 1] << 8 |\r\nmsg_buf[i + 2] << 16 | msg_buf[i + 3] << 24;\r\nwritel(msg, em_mmio + i);\r\n}\r\nwritel(em_ctl | EM_CTL_TM, mmio + HOST_EM_CTL);\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nahci_rpm_put_port(ap);\r\nreturn size;\r\n}\r\nstatic ssize_t ahci_show_em_supported(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct ata_port *ap = ata_shost_to_port(shost);\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nvoid __iomem *mmio = hpriv->mmio;\r\nu32 em_ctl;\r\nahci_rpm_get_port(ap);\r\nem_ctl = readl(mmio + HOST_EM_CTL);\r\nahci_rpm_put_port(ap);\r\nreturn sprintf(buf, "%s%s%s%s\n",\r\nem_ctl & EM_CTL_LED ? "led " : "",\r\nem_ctl & EM_CTL_SAFTE ? "saf-te " : "",\r\nem_ctl & EM_CTL_SES ? "ses-2 " : "",\r\nem_ctl & EM_CTL_SGPIO ? "sgpio " : "");\r\n}\r\nvoid ahci_save_initial_config(struct device *dev, struct ahci_host_priv *hpriv)\r\n{\r\nvoid __iomem *mmio = hpriv->mmio;\r\nu32 cap, cap2, vers, port_map;\r\nint i;\r\nahci_enable_ahci(mmio);\r\nhpriv->saved_cap = cap = readl(mmio + HOST_CAP);\r\nhpriv->saved_port_map = port_map = readl(mmio + HOST_PORTS_IMPL);\r\nvers = readl(mmio + HOST_VERSION);\r\nif ((vers >> 16) > 1 ||\r\n((vers >> 16) == 1 && (vers & 0xFFFF) >= 0x200))\r\nhpriv->saved_cap2 = cap2 = readl(mmio + HOST_CAP2);\r\nelse\r\nhpriv->saved_cap2 = cap2 = 0;\r\nif ((cap & HOST_CAP_64) && (hpriv->flags & AHCI_HFLAG_32BIT_ONLY)) {\r\ndev_info(dev, "controller can't do 64bit DMA, forcing 32bit\n");\r\ncap &= ~HOST_CAP_64;\r\n}\r\nif ((cap & HOST_CAP_NCQ) && (hpriv->flags & AHCI_HFLAG_NO_NCQ)) {\r\ndev_info(dev, "controller can't do NCQ, turning off CAP_NCQ\n");\r\ncap &= ~HOST_CAP_NCQ;\r\n}\r\nif (!(cap & HOST_CAP_NCQ) && (hpriv->flags & AHCI_HFLAG_YES_NCQ)) {\r\ndev_info(dev, "controller can do NCQ, turning on CAP_NCQ\n");\r\ncap |= HOST_CAP_NCQ;\r\n}\r\nif ((cap & HOST_CAP_PMP) && (hpriv->flags & AHCI_HFLAG_NO_PMP)) {\r\ndev_info(dev, "controller can't do PMP, turning off CAP_PMP\n");\r\ncap &= ~HOST_CAP_PMP;\r\n}\r\nif ((cap & HOST_CAP_SNTF) && (hpriv->flags & AHCI_HFLAG_NO_SNTF)) {\r\ndev_info(dev,\r\n"controller can't do SNTF, turning off CAP_SNTF\n");\r\ncap &= ~HOST_CAP_SNTF;\r\n}\r\nif ((cap2 & HOST_CAP2_SDS) && (hpriv->flags & AHCI_HFLAG_NO_DEVSLP)) {\r\ndev_info(dev,\r\n"controller can't do DEVSLP, turning off\n");\r\ncap2 &= ~HOST_CAP2_SDS;\r\ncap2 &= ~HOST_CAP2_SADM;\r\n}\r\nif (!(cap & HOST_CAP_FBS) && (hpriv->flags & AHCI_HFLAG_YES_FBS)) {\r\ndev_info(dev, "controller can do FBS, turning on CAP_FBS\n");\r\ncap |= HOST_CAP_FBS;\r\n}\r\nif ((cap & HOST_CAP_FBS) && (hpriv->flags & AHCI_HFLAG_NO_FBS)) {\r\ndev_info(dev, "controller can't do FBS, turning off CAP_FBS\n");\r\ncap &= ~HOST_CAP_FBS;\r\n}\r\nif (hpriv->force_port_map && port_map != hpriv->force_port_map) {\r\ndev_info(dev, "forcing port_map 0x%x -> 0x%x\n",\r\nport_map, hpriv->force_port_map);\r\nport_map = hpriv->force_port_map;\r\nhpriv->saved_port_map = port_map;\r\n}\r\nif (hpriv->mask_port_map) {\r\ndev_warn(dev, "masking port_map 0x%x -> 0x%x\n",\r\nport_map,\r\nport_map & hpriv->mask_port_map);\r\nport_map &= hpriv->mask_port_map;\r\n}\r\nif (port_map) {\r\nint map_ports = 0;\r\nfor (i = 0; i < AHCI_MAX_PORTS; i++)\r\nif (port_map & (1 << i))\r\nmap_ports++;\r\nif (map_ports > ahci_nr_ports(cap)) {\r\ndev_warn(dev,\r\n"implemented port map (0x%x) contains more ports than nr_ports (%u), using nr_ports\n",\r\nport_map, ahci_nr_ports(cap));\r\nport_map = 0;\r\n}\r\n}\r\nif (!port_map && vers < 0x10300) {\r\nport_map = (1 << ahci_nr_ports(cap)) - 1;\r\ndev_warn(dev, "forcing PORTS_IMPL to 0x%x\n", port_map);\r\nhpriv->saved_port_map = port_map;\r\n}\r\nhpriv->cap = cap;\r\nhpriv->cap2 = cap2;\r\nhpriv->version = readl(mmio + HOST_VERSION);\r\nhpriv->port_map = port_map;\r\nif (!hpriv->start_engine)\r\nhpriv->start_engine = ahci_start_engine;\r\nif (!hpriv->irq_handler)\r\nhpriv->irq_handler = ahci_single_level_irq_intr;\r\n}\r\nstatic void ahci_restore_initial_config(struct ata_host *host)\r\n{\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nvoid __iomem *mmio = hpriv->mmio;\r\nwritel(hpriv->saved_cap, mmio + HOST_CAP);\r\nif (hpriv->saved_cap2)\r\nwritel(hpriv->saved_cap2, mmio + HOST_CAP2);\r\nwritel(hpriv->saved_port_map, mmio + HOST_PORTS_IMPL);\r\n(void) readl(mmio + HOST_PORTS_IMPL);\r\n}\r\nstatic unsigned ahci_scr_offset(struct ata_port *ap, unsigned int sc_reg)\r\n{\r\nstatic const int offset[] = {\r\n[SCR_STATUS] = PORT_SCR_STAT,\r\n[SCR_CONTROL] = PORT_SCR_CTL,\r\n[SCR_ERROR] = PORT_SCR_ERR,\r\n[SCR_ACTIVE] = PORT_SCR_ACT,\r\n[SCR_NOTIFICATION] = PORT_SCR_NTF,\r\n};\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nif (sc_reg < ARRAY_SIZE(offset) &&\r\n(sc_reg != SCR_NOTIFICATION || (hpriv->cap & HOST_CAP_SNTF)))\r\nreturn offset[sc_reg];\r\nreturn 0;\r\n}\r\nstatic int ahci_scr_read(struct ata_link *link, unsigned int sc_reg, u32 *val)\r\n{\r\nvoid __iomem *port_mmio = ahci_port_base(link->ap);\r\nint offset = ahci_scr_offset(link->ap, sc_reg);\r\nif (offset) {\r\n*val = readl(port_mmio + offset);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ahci_scr_write(struct ata_link *link, unsigned int sc_reg, u32 val)\r\n{\r\nvoid __iomem *port_mmio = ahci_port_base(link->ap);\r\nint offset = ahci_scr_offset(link->ap, sc_reg);\r\nif (offset) {\r\nwritel(val, port_mmio + offset);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nvoid ahci_start_engine(struct ata_port *ap)\r\n{\r\nvoid __iomem *port_mmio = ahci_port_base(ap);\r\nu32 tmp;\r\ntmp = readl(port_mmio + PORT_CMD);\r\ntmp |= PORT_CMD_START;\r\nwritel(tmp, port_mmio + PORT_CMD);\r\nreadl(port_mmio + PORT_CMD);\r\n}\r\nint ahci_stop_engine(struct ata_port *ap)\r\n{\r\nvoid __iomem *port_mmio = ahci_port_base(ap);\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nu32 tmp;\r\nif ((hpriv->flags & AHCI_HFLAG_WAKE_BEFORE_STOP) &&\r\n(ap->link.lpm_policy > ATA_LPM_MAX_POWER) &&\r\nahci_set_lpm(&ap->link, ATA_LPM_MAX_POWER, ATA_LPM_WAKE_ONLY)) {\r\ndev_err(ap->host->dev, "Failed to wake up port before engine stop\n");\r\nreturn -EIO;\r\n}\r\ntmp = readl(port_mmio + PORT_CMD);\r\nif ((tmp & (PORT_CMD_START | PORT_CMD_LIST_ON)) == 0)\r\nreturn 0;\r\ntmp &= ~PORT_CMD_START;\r\nwritel(tmp, port_mmio + PORT_CMD);\r\ntmp = ata_wait_register(ap, port_mmio + PORT_CMD,\r\nPORT_CMD_LIST_ON, PORT_CMD_LIST_ON, 1, 500);\r\nif (tmp & PORT_CMD_LIST_ON)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nvoid ahci_start_fis_rx(struct ata_port *ap)\r\n{\r\nvoid __iomem *port_mmio = ahci_port_base(ap);\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nu32 tmp;\r\nif (hpriv->cap & HOST_CAP_64)\r\nwritel((pp->cmd_slot_dma >> 16) >> 16,\r\nport_mmio + PORT_LST_ADDR_HI);\r\nwritel(pp->cmd_slot_dma & 0xffffffff, port_mmio + PORT_LST_ADDR);\r\nif (hpriv->cap & HOST_CAP_64)\r\nwritel((pp->rx_fis_dma >> 16) >> 16,\r\nport_mmio + PORT_FIS_ADDR_HI);\r\nwritel(pp->rx_fis_dma & 0xffffffff, port_mmio + PORT_FIS_ADDR);\r\ntmp = readl(port_mmio + PORT_CMD);\r\ntmp |= PORT_CMD_FIS_RX;\r\nwritel(tmp, port_mmio + PORT_CMD);\r\nreadl(port_mmio + PORT_CMD);\r\n}\r\nstatic int ahci_stop_fis_rx(struct ata_port *ap)\r\n{\r\nvoid __iomem *port_mmio = ahci_port_base(ap);\r\nu32 tmp;\r\ntmp = readl(port_mmio + PORT_CMD);\r\ntmp &= ~PORT_CMD_FIS_RX;\r\nwritel(tmp, port_mmio + PORT_CMD);\r\ntmp = ata_wait_register(ap, port_mmio + PORT_CMD, PORT_CMD_FIS_ON,\r\nPORT_CMD_FIS_ON, 10, 1000);\r\nif (tmp & PORT_CMD_FIS_ON)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic void ahci_power_up(struct ata_port *ap)\r\n{\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nvoid __iomem *port_mmio = ahci_port_base(ap);\r\nu32 cmd;\r\ncmd = readl(port_mmio + PORT_CMD) & ~PORT_CMD_ICC_MASK;\r\nif (hpriv->cap & HOST_CAP_SSS) {\r\ncmd |= PORT_CMD_SPIN_UP;\r\nwritel(cmd, port_mmio + PORT_CMD);\r\n}\r\nwritel(cmd | PORT_CMD_ICC_ACTIVE, port_mmio + PORT_CMD);\r\n}\r\nstatic int ahci_set_lpm(struct ata_link *link, enum ata_lpm_policy policy,\r\nunsigned int hints)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nvoid __iomem *port_mmio = ahci_port_base(ap);\r\nif (policy != ATA_LPM_MAX_POWER) {\r\nhints &= ~ATA_LPM_WAKE_ONLY;\r\npp->intr_mask &= ~PORT_IRQ_PHYRDY;\r\nwritel(pp->intr_mask, port_mmio + PORT_IRQ_MASK);\r\nsata_link_scr_lpm(link, policy, false);\r\n}\r\nif (hpriv->cap & HOST_CAP_ALPM) {\r\nu32 cmd = readl(port_mmio + PORT_CMD);\r\nif (policy == ATA_LPM_MAX_POWER || !(hints & ATA_LPM_HIPM)) {\r\nif (!(hints & ATA_LPM_WAKE_ONLY))\r\ncmd &= ~(PORT_CMD_ASP | PORT_CMD_ALPE);\r\ncmd |= PORT_CMD_ICC_ACTIVE;\r\nwritel(cmd, port_mmio + PORT_CMD);\r\nreadl(port_mmio + PORT_CMD);\r\nata_msleep(ap, 10);\r\nif (hints & ATA_LPM_WAKE_ONLY)\r\nreturn 0;\r\n} else {\r\ncmd |= PORT_CMD_ALPE;\r\nif (policy == ATA_LPM_MIN_POWER)\r\ncmd |= PORT_CMD_ASP;\r\nwritel(cmd, port_mmio + PORT_CMD);\r\n}\r\n}\r\nif ((hpriv->cap2 & HOST_CAP2_SDS) &&\r\n(hpriv->cap2 & HOST_CAP2_SADM) &&\r\n(link->device->flags & ATA_DFLAG_DEVSLP)) {\r\nif (policy == ATA_LPM_MIN_POWER)\r\nahci_set_aggressive_devslp(ap, true);\r\nelse\r\nahci_set_aggressive_devslp(ap, false);\r\n}\r\nif (policy == ATA_LPM_MAX_POWER) {\r\nsata_link_scr_lpm(link, policy, false);\r\npp->intr_mask |= PORT_IRQ_PHYRDY;\r\nwritel(pp->intr_mask, port_mmio + PORT_IRQ_MASK);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ahci_power_down(struct ata_port *ap)\r\n{\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nvoid __iomem *port_mmio = ahci_port_base(ap);\r\nu32 cmd, scontrol;\r\nif (!(hpriv->cap & HOST_CAP_SSS))\r\nreturn;\r\nscontrol = readl(port_mmio + PORT_SCR_CTL);\r\nscontrol &= ~0xf;\r\nwritel(scontrol, port_mmio + PORT_SCR_CTL);\r\ncmd = readl(port_mmio + PORT_CMD) & ~PORT_CMD_ICC_MASK;\r\ncmd &= ~PORT_CMD_SPIN_UP;\r\nwritel(cmd, port_mmio + PORT_CMD);\r\n}\r\nstatic void ahci_start_port(struct ata_port *ap)\r\n{\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nstruct ata_link *link;\r\nstruct ahci_em_priv *emp;\r\nssize_t rc;\r\nint i;\r\nahci_start_fis_rx(ap);\r\nif (!(hpriv->flags & AHCI_HFLAG_DELAY_ENGINE))\r\nhpriv->start_engine(ap);\r\nif (ap->flags & ATA_FLAG_EM) {\r\nata_for_each_link(link, ap, EDGE) {\r\nemp = &pp->em_priv[link->pmp];\r\nfor (i = 0; i < EM_MAX_RETRY; i++) {\r\nrc = ap->ops->transmit_led_message(ap,\r\nemp->led_state,\r\n4);\r\nif (rc == -EBUSY)\r\nmsleep(1);\r\nelse\r\nbreak;\r\n}\r\n}\r\n}\r\nif (ap->flags & ATA_FLAG_SW_ACTIVITY)\r\nata_for_each_link(link, ap, EDGE)\r\nahci_init_sw_activity(link);\r\n}\r\nstatic int ahci_deinit_port(struct ata_port *ap, const char **emsg)\r\n{\r\nint rc;\r\nrc = ahci_stop_engine(ap);\r\nif (rc) {\r\n*emsg = "failed to stop engine";\r\nreturn rc;\r\n}\r\nrc = ahci_stop_fis_rx(ap);\r\nif (rc) {\r\n*emsg = "failed stop FIS RX";\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nint ahci_reset_controller(struct ata_host *host)\r\n{\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nvoid __iomem *mmio = hpriv->mmio;\r\nu32 tmp;\r\nahci_enable_ahci(mmio);\r\nif (!ahci_skip_host_reset) {\r\ntmp = readl(mmio + HOST_CTL);\r\nif ((tmp & HOST_RESET) == 0) {\r\nwritel(tmp | HOST_RESET, mmio + HOST_CTL);\r\nreadl(mmio + HOST_CTL);\r\n}\r\ntmp = ata_wait_register(NULL, mmio + HOST_CTL, HOST_RESET,\r\nHOST_RESET, 10, 1000);\r\nif (tmp & HOST_RESET) {\r\ndev_err(host->dev, "controller reset failed (0x%x)\n",\r\ntmp);\r\nreturn -EIO;\r\n}\r\nahci_enable_ahci(mmio);\r\nahci_restore_initial_config(host);\r\n} else\r\ndev_info(host->dev, "skipping global host reset\n");\r\nreturn 0;\r\n}\r\nstatic void ahci_sw_activity(struct ata_link *link)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nstruct ahci_em_priv *emp = &pp->em_priv[link->pmp];\r\nif (!(link->flags & ATA_LFLAG_SW_ACTIVITY))\r\nreturn;\r\nemp->activity++;\r\nif (!timer_pending(&emp->timer))\r\nmod_timer(&emp->timer, jiffies + msecs_to_jiffies(10));\r\n}\r\nstatic void ahci_sw_activity_blink(unsigned long arg)\r\n{\r\nstruct ata_link *link = (struct ata_link *)arg;\r\nstruct ata_port *ap = link->ap;\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nstruct ahci_em_priv *emp = &pp->em_priv[link->pmp];\r\nunsigned long led_message = emp->led_state;\r\nu32 activity_led_state;\r\nunsigned long flags;\r\nled_message &= EM_MSG_LED_VALUE;\r\nled_message |= ap->port_no | (link->pmp << 8);\r\nspin_lock_irqsave(ap->lock, flags);\r\nif (emp->saved_activity != emp->activity) {\r\nemp->saved_activity = emp->activity;\r\nactivity_led_state = led_message & EM_MSG_LED_VALUE_ON;\r\nif (activity_led_state)\r\nactivity_led_state = 0;\r\nelse\r\nactivity_led_state = 1;\r\nled_message &= ~EM_MSG_LED_VALUE_ACTIVITY;\r\nled_message |= (activity_led_state << 16);\r\nmod_timer(&emp->timer, jiffies + msecs_to_jiffies(100));\r\n} else {\r\nled_message &= ~EM_MSG_LED_VALUE_ACTIVITY;\r\nif (emp->blink_policy == BLINK_OFF)\r\nled_message |= (1 << 16);\r\n}\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nap->ops->transmit_led_message(ap, led_message, 4);\r\n}\r\nstatic void ahci_init_sw_activity(struct ata_link *link)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nstruct ahci_em_priv *emp = &pp->em_priv[link->pmp];\r\nemp->saved_activity = emp->activity = 0;\r\nsetup_timer(&emp->timer, ahci_sw_activity_blink, (unsigned long)link);\r\nif (emp->blink_policy)\r\nlink->flags |= ATA_LFLAG_SW_ACTIVITY;\r\n}\r\nint ahci_reset_em(struct ata_host *host)\r\n{\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nvoid __iomem *mmio = hpriv->mmio;\r\nu32 em_ctl;\r\nem_ctl = readl(mmio + HOST_EM_CTL);\r\nif ((em_ctl & EM_CTL_TM) || (em_ctl & EM_CTL_RST))\r\nreturn -EINVAL;\r\nwritel(em_ctl | EM_CTL_RST, mmio + HOST_EM_CTL);\r\nreturn 0;\r\n}\r\nstatic ssize_t ahci_transmit_led_message(struct ata_port *ap, u32 state,\r\nssize_t size)\r\n{\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nvoid __iomem *mmio = hpriv->mmio;\r\nu32 em_ctl;\r\nu32 message[] = {0, 0};\r\nunsigned long flags;\r\nint pmp;\r\nstruct ahci_em_priv *emp;\r\npmp = (state & EM_MSG_LED_PMP_SLOT) >> 8;\r\nif (pmp < EM_MAX_SLOTS)\r\nemp = &pp->em_priv[pmp];\r\nelse\r\nreturn -EINVAL;\r\nahci_rpm_get_port(ap);\r\nspin_lock_irqsave(ap->lock, flags);\r\nem_ctl = readl(mmio + HOST_EM_CTL);\r\nif (em_ctl & EM_CTL_TM) {\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nahci_rpm_put_port(ap);\r\nreturn -EBUSY;\r\n}\r\nif (hpriv->em_msg_type & EM_MSG_TYPE_LED) {\r\nmessage[0] |= (4 << 8);\r\nmessage[1] = ((state & ~EM_MSG_LED_HBA_PORT) | ap->port_no);\r\nwritel(message[0], mmio + hpriv->em_loc);\r\nwritel(message[1], mmio + hpriv->em_loc+4);\r\nwritel(em_ctl | EM_CTL_TM, mmio + HOST_EM_CTL);\r\n}\r\nemp->led_state = state;\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nahci_rpm_put_port(ap);\r\nreturn size;\r\n}\r\nstatic ssize_t ahci_led_show(struct ata_port *ap, char *buf)\r\n{\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nstruct ata_link *link;\r\nstruct ahci_em_priv *emp;\r\nint rc = 0;\r\nata_for_each_link(link, ap, EDGE) {\r\nemp = &pp->em_priv[link->pmp];\r\nrc += sprintf(buf, "%lx\n", emp->led_state);\r\n}\r\nreturn rc;\r\n}\r\nstatic ssize_t ahci_led_store(struct ata_port *ap, const char *buf,\r\nsize_t size)\r\n{\r\nunsigned int state;\r\nint pmp;\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nstruct ahci_em_priv *emp;\r\nif (kstrtouint(buf, 0, &state) < 0)\r\nreturn -EINVAL;\r\npmp = (state & EM_MSG_LED_PMP_SLOT) >> 8;\r\nif (pmp < EM_MAX_SLOTS)\r\nemp = &pp->em_priv[pmp];\r\nelse\r\nreturn -EINVAL;\r\nif (emp->blink_policy)\r\nstate &= ~EM_MSG_LED_VALUE_ACTIVITY;\r\nreturn ap->ops->transmit_led_message(ap, state, size);\r\n}\r\nstatic ssize_t ahci_activity_store(struct ata_device *dev, enum sw_activity val)\r\n{\r\nstruct ata_link *link = dev->link;\r\nstruct ata_port *ap = link->ap;\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nstruct ahci_em_priv *emp = &pp->em_priv[link->pmp];\r\nu32 port_led_state = emp->led_state;\r\nif (val == OFF) {\r\nlink->flags &= ~(ATA_LFLAG_SW_ACTIVITY);\r\nport_led_state &= EM_MSG_LED_VALUE_OFF;\r\nport_led_state |= (ap->port_no | (link->pmp << 8));\r\nap->ops->transmit_led_message(ap, port_led_state, 4);\r\n} else {\r\nlink->flags |= ATA_LFLAG_SW_ACTIVITY;\r\nif (val == BLINK_OFF) {\r\nport_led_state &= EM_MSG_LED_VALUE_OFF;\r\nport_led_state |= (ap->port_no | (link->pmp << 8));\r\nport_led_state |= EM_MSG_LED_VALUE_ON;\r\nap->ops->transmit_led_message(ap, port_led_state, 4);\r\n}\r\n}\r\nemp->blink_policy = val;\r\nreturn 0;\r\n}\r\nstatic ssize_t ahci_activity_show(struct ata_device *dev, char *buf)\r\n{\r\nstruct ata_link *link = dev->link;\r\nstruct ata_port *ap = link->ap;\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nstruct ahci_em_priv *emp = &pp->em_priv[link->pmp];\r\nreturn sprintf(buf, "%d\n", emp->blink_policy);\r\n}\r\nstatic void ahci_port_init(struct device *dev, struct ata_port *ap,\r\nint port_no, void __iomem *mmio,\r\nvoid __iomem *port_mmio)\r\n{\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nconst char *emsg = NULL;\r\nint rc;\r\nu32 tmp;\r\nrc = ahci_deinit_port(ap, &emsg);\r\nif (rc)\r\ndev_warn(dev, "%s (%d)\n", emsg, rc);\r\ntmp = readl(port_mmio + PORT_SCR_ERR);\r\nVPRINTK("PORT_SCR_ERR 0x%x\n", tmp);\r\nwritel(tmp, port_mmio + PORT_SCR_ERR);\r\ntmp = readl(port_mmio + PORT_IRQ_STAT);\r\nVPRINTK("PORT_IRQ_STAT 0x%x\n", tmp);\r\nif (tmp)\r\nwritel(tmp, port_mmio + PORT_IRQ_STAT);\r\nwritel(1 << port_no, mmio + HOST_IRQ_STAT);\r\ntmp = readl(port_mmio + PORT_CMD);\r\nif ((tmp & PORT_CMD_ESP) && (hpriv->cap & HOST_CAP_SXS))\r\nap->pflags |= ATA_PFLAG_EXTERNAL;\r\n}\r\nvoid ahci_init_controller(struct ata_host *host)\r\n{\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nvoid __iomem *mmio = hpriv->mmio;\r\nint i;\r\nvoid __iomem *port_mmio;\r\nu32 tmp;\r\nfor (i = 0; i < host->n_ports; i++) {\r\nstruct ata_port *ap = host->ports[i];\r\nport_mmio = ahci_port_base(ap);\r\nif (ata_port_is_dummy(ap))\r\ncontinue;\r\nahci_port_init(host->dev, ap, i, mmio, port_mmio);\r\n}\r\ntmp = readl(mmio + HOST_CTL);\r\nVPRINTK("HOST_CTL 0x%x\n", tmp);\r\nwritel(tmp | HOST_IRQ_EN, mmio + HOST_CTL);\r\ntmp = readl(mmio + HOST_CTL);\r\nVPRINTK("HOST_CTL 0x%x\n", tmp);\r\n}\r\nstatic void ahci_dev_config(struct ata_device *dev)\r\n{\r\nstruct ahci_host_priv *hpriv = dev->link->ap->host->private_data;\r\nif (hpriv->flags & AHCI_HFLAG_SECT255) {\r\ndev->max_sectors = 255;\r\nata_dev_info(dev,\r\n"SB600 AHCI: limiting to 255 sectors per cmd\n");\r\n}\r\n}\r\nunsigned int ahci_dev_classify(struct ata_port *ap)\r\n{\r\nvoid __iomem *port_mmio = ahci_port_base(ap);\r\nstruct ata_taskfile tf;\r\nu32 tmp;\r\ntmp = readl(port_mmio + PORT_SIG);\r\ntf.lbah = (tmp >> 24) & 0xff;\r\ntf.lbam = (tmp >> 16) & 0xff;\r\ntf.lbal = (tmp >> 8) & 0xff;\r\ntf.nsect = (tmp) & 0xff;\r\nreturn ata_dev_classify(&tf);\r\n}\r\nvoid ahci_fill_cmd_slot(struct ahci_port_priv *pp, unsigned int tag,\r\nu32 opts)\r\n{\r\ndma_addr_t cmd_tbl_dma;\r\ncmd_tbl_dma = pp->cmd_tbl_dma + tag * AHCI_CMD_TBL_SZ;\r\npp->cmd_slot[tag].opts = cpu_to_le32(opts);\r\npp->cmd_slot[tag].status = 0;\r\npp->cmd_slot[tag].tbl_addr = cpu_to_le32(cmd_tbl_dma & 0xffffffff);\r\npp->cmd_slot[tag].tbl_addr_hi = cpu_to_le32((cmd_tbl_dma >> 16) >> 16);\r\n}\r\nint ahci_kick_engine(struct ata_port *ap)\r\n{\r\nvoid __iomem *port_mmio = ahci_port_base(ap);\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nu8 status = readl(port_mmio + PORT_TFDATA) & 0xFF;\r\nu32 tmp;\r\nint busy, rc;\r\nrc = ahci_stop_engine(ap);\r\nif (rc)\r\ngoto out_restart;\r\nbusy = status & (ATA_BUSY | ATA_DRQ);\r\nif (!busy && !sata_pmp_attached(ap)) {\r\nrc = 0;\r\ngoto out_restart;\r\n}\r\nif (!(hpriv->cap & HOST_CAP_CLO)) {\r\nrc = -EOPNOTSUPP;\r\ngoto out_restart;\r\n}\r\ntmp = readl(port_mmio + PORT_CMD);\r\ntmp |= PORT_CMD_CLO;\r\nwritel(tmp, port_mmio + PORT_CMD);\r\nrc = 0;\r\ntmp = ata_wait_register(ap, port_mmio + PORT_CMD,\r\nPORT_CMD_CLO, PORT_CMD_CLO, 1, 500);\r\nif (tmp & PORT_CMD_CLO)\r\nrc = -EIO;\r\nout_restart:\r\nhpriv->start_engine(ap);\r\nreturn rc;\r\n}\r\nstatic int ahci_exec_polled_cmd(struct ata_port *ap, int pmp,\r\nstruct ata_taskfile *tf, int is_cmd, u16 flags,\r\nunsigned long timeout_msec)\r\n{\r\nconst u32 cmd_fis_len = 5;\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nvoid __iomem *port_mmio = ahci_port_base(ap);\r\nu8 *fis = pp->cmd_tbl;\r\nu32 tmp;\r\nata_tf_to_fis(tf, pmp, is_cmd, fis);\r\nahci_fill_cmd_slot(pp, 0, cmd_fis_len | flags | (pmp << 12));\r\nif (pp->fbs_enabled && pp->fbs_last_dev != pmp) {\r\ntmp = readl(port_mmio + PORT_FBS);\r\ntmp &= ~(PORT_FBS_DEV_MASK | PORT_FBS_DEC);\r\ntmp |= pmp << PORT_FBS_DEV_OFFSET;\r\nwritel(tmp, port_mmio + PORT_FBS);\r\npp->fbs_last_dev = pmp;\r\n}\r\nwritel(1, port_mmio + PORT_CMD_ISSUE);\r\nif (timeout_msec) {\r\ntmp = ata_wait_register(ap, port_mmio + PORT_CMD_ISSUE,\r\n0x1, 0x1, 1, timeout_msec);\r\nif (tmp & 0x1) {\r\nahci_kick_engine(ap);\r\nreturn -EBUSY;\r\n}\r\n} else\r\nreadl(port_mmio + PORT_CMD_ISSUE);\r\nreturn 0;\r\n}\r\nint ahci_do_softreset(struct ata_link *link, unsigned int *class,\r\nint pmp, unsigned long deadline,\r\nint (*check_ready)(struct ata_link *link))\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nconst char *reason = NULL;\r\nunsigned long now, msecs;\r\nstruct ata_taskfile tf;\r\nbool fbs_disabled = false;\r\nint rc;\r\nDPRINTK("ENTER\n");\r\nrc = ahci_kick_engine(ap);\r\nif (rc && rc != -EOPNOTSUPP)\r\nata_link_warn(link, "failed to reset engine (errno=%d)\n", rc);\r\nif (!ata_is_host_link(link) && pp->fbs_enabled) {\r\nahci_disable_fbs(ap);\r\nfbs_disabled = true;\r\n}\r\nata_tf_init(link->device, &tf);\r\nmsecs = 0;\r\nnow = jiffies;\r\nif (time_after(deadline, now))\r\nmsecs = jiffies_to_msecs(deadline - now);\r\ntf.ctl |= ATA_SRST;\r\nif (ahci_exec_polled_cmd(ap, pmp, &tf, 0,\r\nAHCI_CMD_RESET | AHCI_CMD_CLR_BUSY, msecs)) {\r\nrc = -EIO;\r\nreason = "1st FIS failed";\r\ngoto fail;\r\n}\r\nata_msleep(ap, 1);\r\ntf.ctl &= ~ATA_SRST;\r\nahci_exec_polled_cmd(ap, pmp, &tf, 0, 0, 0);\r\nrc = ata_wait_after_reset(link, deadline, check_ready);\r\nif (rc == -EBUSY && hpriv->flags & AHCI_HFLAG_SRST_TOUT_IS_OFFLINE) {\r\nata_link_info(link, "device not ready, treating as offline\n");\r\n*class = ATA_DEV_NONE;\r\n} else if (rc) {\r\nreason = "device not ready";\r\ngoto fail;\r\n} else\r\n*class = ahci_dev_classify(ap);\r\nif (fbs_disabled)\r\nahci_enable_fbs(ap);\r\nDPRINTK("EXIT, class=%u\n", *class);\r\nreturn 0;\r\nfail:\r\nata_link_err(link, "softreset failed (%s)\n", reason);\r\nreturn rc;\r\n}\r\nint ahci_check_ready(struct ata_link *link)\r\n{\r\nvoid __iomem *port_mmio = ahci_port_base(link->ap);\r\nu8 status = readl(port_mmio + PORT_TFDATA) & 0xFF;\r\nreturn ata_check_ready(status);\r\n}\r\nstatic int ahci_softreset(struct ata_link *link, unsigned int *class,\r\nunsigned long deadline)\r\n{\r\nint pmp = sata_srst_pmp(link);\r\nDPRINTK("ENTER\n");\r\nreturn ahci_do_softreset(link, class, pmp, deadline, ahci_check_ready);\r\n}\r\nstatic int ahci_bad_pmp_check_ready(struct ata_link *link)\r\n{\r\nvoid __iomem *port_mmio = ahci_port_base(link->ap);\r\nu8 status = readl(port_mmio + PORT_TFDATA) & 0xFF;\r\nu32 irq_status = readl(port_mmio + PORT_IRQ_STAT);\r\nif (irq_status & PORT_IRQ_BAD_PMP)\r\nreturn -EIO;\r\nreturn ata_check_ready(status);\r\n}\r\nstatic int ahci_pmp_retry_softreset(struct ata_link *link, unsigned int *class,\r\nunsigned long deadline)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nvoid __iomem *port_mmio = ahci_port_base(ap);\r\nint pmp = sata_srst_pmp(link);\r\nint rc;\r\nu32 irq_sts;\r\nDPRINTK("ENTER\n");\r\nrc = ahci_do_softreset(link, class, pmp, deadline,\r\nahci_bad_pmp_check_ready);\r\nif (rc == -EIO) {\r\nirq_sts = readl(port_mmio + PORT_IRQ_STAT);\r\nif (irq_sts & PORT_IRQ_BAD_PMP) {\r\nata_link_warn(link,\r\n"applying PMP SRST workaround "\r\n"and retrying\n");\r\nrc = ahci_do_softreset(link, class, 0, deadline,\r\nahci_check_ready);\r\n}\r\n}\r\nreturn rc;\r\n}\r\nint ahci_do_hardreset(struct ata_link *link, unsigned int *class,\r\nunsigned long deadline, bool *online)\r\n{\r\nconst unsigned long *timing = sata_ehc_deb_timing(&link->eh_context);\r\nstruct ata_port *ap = link->ap;\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nu8 *d2h_fis = pp->rx_fis + RX_FIS_D2H_REG;\r\nstruct ata_taskfile tf;\r\nint rc;\r\nDPRINTK("ENTER\n");\r\nahci_stop_engine(ap);\r\nata_tf_init(link->device, &tf);\r\ntf.command = ATA_BUSY;\r\nata_tf_to_fis(&tf, 0, 0, d2h_fis);\r\nrc = sata_link_hardreset(link, timing, deadline, online,\r\nahci_check_ready);\r\nhpriv->start_engine(ap);\r\nif (*online)\r\n*class = ahci_dev_classify(ap);\r\nDPRINTK("EXIT, rc=%d, class=%u\n", rc, *class);\r\nreturn rc;\r\n}\r\nstatic int ahci_hardreset(struct ata_link *link, unsigned int *class,\r\nunsigned long deadline)\r\n{\r\nbool online;\r\nreturn ahci_do_hardreset(link, class, deadline, &online);\r\n}\r\nstatic void ahci_postreset(struct ata_link *link, unsigned int *class)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nvoid __iomem *port_mmio = ahci_port_base(ap);\r\nu32 new_tmp, tmp;\r\nata_std_postreset(link, class);\r\nnew_tmp = tmp = readl(port_mmio + PORT_CMD);\r\nif (*class == ATA_DEV_ATAPI)\r\nnew_tmp |= PORT_CMD_ATAPI;\r\nelse\r\nnew_tmp &= ~PORT_CMD_ATAPI;\r\nif (new_tmp != tmp) {\r\nwritel(new_tmp, port_mmio + PORT_CMD);\r\nreadl(port_mmio + PORT_CMD);\r\n}\r\n}\r\nstatic unsigned int ahci_fill_sg(struct ata_queued_cmd *qc, void *cmd_tbl)\r\n{\r\nstruct scatterlist *sg;\r\nstruct ahci_sg *ahci_sg = cmd_tbl + AHCI_CMD_TBL_HDR_SZ;\r\nunsigned int si;\r\nVPRINTK("ENTER\n");\r\nfor_each_sg(qc->sg, sg, qc->n_elem, si) {\r\ndma_addr_t addr = sg_dma_address(sg);\r\nu32 sg_len = sg_dma_len(sg);\r\nahci_sg[si].addr = cpu_to_le32(addr & 0xffffffff);\r\nahci_sg[si].addr_hi = cpu_to_le32((addr >> 16) >> 16);\r\nahci_sg[si].flags_size = cpu_to_le32(sg_len - 1);\r\n}\r\nreturn si;\r\n}\r\nstatic int ahci_pmp_qc_defer(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nif (!sata_pmp_attached(ap) || pp->fbs_enabled)\r\nreturn ata_std_qc_defer(qc);\r\nelse\r\nreturn sata_pmp_qc_defer_cmd_switch(qc);\r\n}\r\nstatic void ahci_qc_prep(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nint is_atapi = ata_is_atapi(qc->tf.protocol);\r\nvoid *cmd_tbl;\r\nu32 opts;\r\nconst u32 cmd_fis_len = 5;\r\nunsigned int n_elem;\r\ncmd_tbl = pp->cmd_tbl + qc->tag * AHCI_CMD_TBL_SZ;\r\nata_tf_to_fis(&qc->tf, qc->dev->link->pmp, 1, cmd_tbl);\r\nif (is_atapi) {\r\nmemset(cmd_tbl + AHCI_CMD_TBL_CDB, 0, 32);\r\nmemcpy(cmd_tbl + AHCI_CMD_TBL_CDB, qc->cdb, qc->dev->cdb_len);\r\n}\r\nn_elem = 0;\r\nif (qc->flags & ATA_QCFLAG_DMAMAP)\r\nn_elem = ahci_fill_sg(qc, cmd_tbl);\r\nopts = cmd_fis_len | n_elem << 16 | (qc->dev->link->pmp << 12);\r\nif (qc->tf.flags & ATA_TFLAG_WRITE)\r\nopts |= AHCI_CMD_WRITE;\r\nif (is_atapi)\r\nopts |= AHCI_CMD_ATAPI | AHCI_CMD_PREFETCH;\r\nahci_fill_cmd_slot(pp, qc->tag, opts);\r\n}\r\nstatic void ahci_fbs_dec_intr(struct ata_port *ap)\r\n{\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nvoid __iomem *port_mmio = ahci_port_base(ap);\r\nu32 fbs = readl(port_mmio + PORT_FBS);\r\nint retries = 3;\r\nDPRINTK("ENTER\n");\r\nBUG_ON(!pp->fbs_enabled);\r\nwritel(fbs | PORT_FBS_DEC, port_mmio + PORT_FBS);\r\nfbs = readl(port_mmio + PORT_FBS);\r\nwhile ((fbs & PORT_FBS_DEC) && retries--) {\r\nudelay(1);\r\nfbs = readl(port_mmio + PORT_FBS);\r\n}\r\nif (fbs & PORT_FBS_DEC)\r\ndev_err(ap->host->dev, "failed to clear device error\n");\r\n}\r\nstatic void ahci_error_intr(struct ata_port *ap, u32 irq_stat)\r\n{\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nstruct ata_eh_info *host_ehi = &ap->link.eh_info;\r\nstruct ata_link *link = NULL;\r\nstruct ata_queued_cmd *active_qc;\r\nstruct ata_eh_info *active_ehi;\r\nbool fbs_need_dec = false;\r\nu32 serror;\r\nif (pp->fbs_enabled) {\r\nvoid __iomem *port_mmio = ahci_port_base(ap);\r\nu32 fbs = readl(port_mmio + PORT_FBS);\r\nint pmp = fbs >> PORT_FBS_DWE_OFFSET;\r\nif ((fbs & PORT_FBS_SDE) && (pmp < ap->nr_pmp_links)) {\r\nlink = &ap->pmp_link[pmp];\r\nfbs_need_dec = true;\r\n}\r\n} else\r\nata_for_each_link(link, ap, EDGE)\r\nif (ata_link_active(link))\r\nbreak;\r\nif (!link)\r\nlink = &ap->link;\r\nactive_qc = ata_qc_from_tag(ap, link->active_tag);\r\nactive_ehi = &link->eh_info;\r\nata_ehi_clear_desc(host_ehi);\r\nata_ehi_push_desc(host_ehi, "irq_stat 0x%08x", irq_stat);\r\nahci_scr_read(&ap->link, SCR_ERROR, &serror);\r\nahci_scr_write(&ap->link, SCR_ERROR, serror);\r\nhost_ehi->serror |= serror;\r\nif (hpriv->flags & AHCI_HFLAG_IGN_IRQ_IF_ERR)\r\nirq_stat &= ~PORT_IRQ_IF_ERR;\r\nif (irq_stat & PORT_IRQ_TF_ERR) {\r\nif (active_qc)\r\nactive_qc->err_mask |= AC_ERR_DEV;\r\nelse\r\nactive_ehi->err_mask |= AC_ERR_DEV;\r\nif (hpriv->flags & AHCI_HFLAG_IGN_SERR_INTERNAL)\r\nhost_ehi->serror &= ~SERR_INTERNAL;\r\n}\r\nif (irq_stat & PORT_IRQ_UNK_FIS) {\r\nu32 *unk = pp->rx_fis + RX_FIS_UNK;\r\nactive_ehi->err_mask |= AC_ERR_HSM;\r\nactive_ehi->action |= ATA_EH_RESET;\r\nata_ehi_push_desc(active_ehi,\r\n"unknown FIS %08x %08x %08x %08x" ,\r\nunk[0], unk[1], unk[2], unk[3]);\r\n}\r\nif (sata_pmp_attached(ap) && (irq_stat & PORT_IRQ_BAD_PMP)) {\r\nactive_ehi->err_mask |= AC_ERR_HSM;\r\nactive_ehi->action |= ATA_EH_RESET;\r\nata_ehi_push_desc(active_ehi, "incorrect PMP");\r\n}\r\nif (irq_stat & (PORT_IRQ_HBUS_ERR | PORT_IRQ_HBUS_DATA_ERR)) {\r\nhost_ehi->err_mask |= AC_ERR_HOST_BUS;\r\nhost_ehi->action |= ATA_EH_RESET;\r\nata_ehi_push_desc(host_ehi, "host bus error");\r\n}\r\nif (irq_stat & PORT_IRQ_IF_ERR) {\r\nif (fbs_need_dec)\r\nactive_ehi->err_mask |= AC_ERR_DEV;\r\nelse {\r\nhost_ehi->err_mask |= AC_ERR_ATA_BUS;\r\nhost_ehi->action |= ATA_EH_RESET;\r\n}\r\nata_ehi_push_desc(host_ehi, "interface fatal error");\r\n}\r\nif (irq_stat & (PORT_IRQ_CONNECT | PORT_IRQ_PHYRDY)) {\r\nata_ehi_hotplugged(host_ehi);\r\nata_ehi_push_desc(host_ehi, "%s",\r\nirq_stat & PORT_IRQ_CONNECT ?\r\n"connection status changed" : "PHY RDY changed");\r\n}\r\nif (irq_stat & PORT_IRQ_FREEZE)\r\nata_port_freeze(ap);\r\nelse if (fbs_need_dec) {\r\nata_link_abort(link);\r\nahci_fbs_dec_intr(ap);\r\n} else\r\nata_port_abort(ap);\r\n}\r\nstatic void ahci_handle_port_interrupt(struct ata_port *ap,\r\nvoid __iomem *port_mmio, u32 status)\r\n{\r\nstruct ata_eh_info *ehi = &ap->link.eh_info;\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nint resetting = !!(ap->pflags & ATA_PFLAG_RESETTING);\r\nu32 qc_active = 0;\r\nint rc;\r\nif (unlikely(resetting))\r\nstatus &= ~PORT_IRQ_BAD_PMP;\r\nif (sata_lpm_ignore_phy_events(&ap->link)) {\r\nstatus &= ~PORT_IRQ_PHYRDY;\r\nahci_scr_write(&ap->link, SCR_ERROR, SERR_PHYRDY_CHG);\r\n}\r\nif (unlikely(status & PORT_IRQ_ERROR)) {\r\nahci_error_intr(ap, status);\r\nreturn;\r\n}\r\nif (status & PORT_IRQ_SDB_FIS) {\r\nif (hpriv->cap & HOST_CAP_SNTF)\r\nsata_async_notification(ap);\r\nelse {\r\nif (pp->fbs_enabled)\r\nWARN_ON_ONCE(1);\r\nelse {\r\nconst __le32 *f = pp->rx_fis + RX_FIS_SDB;\r\nu32 f0 = le32_to_cpu(f[0]);\r\nif (f0 & (1 << 15))\r\nsata_async_notification(ap);\r\n}\r\n}\r\n}\r\nif (pp->fbs_enabled) {\r\nif (ap->qc_active) {\r\nqc_active = readl(port_mmio + PORT_SCR_ACT);\r\nqc_active |= readl(port_mmio + PORT_CMD_ISSUE);\r\n}\r\n} else {\r\nif (ap->qc_active && pp->active_link->sactive)\r\nqc_active = readl(port_mmio + PORT_SCR_ACT);\r\nelse\r\nqc_active = readl(port_mmio + PORT_CMD_ISSUE);\r\n}\r\nrc = ata_qc_complete_multiple(ap, qc_active);\r\nif (unlikely(rc < 0 && !resetting)) {\r\nehi->err_mask |= AC_ERR_HSM;\r\nehi->action |= ATA_EH_RESET;\r\nata_port_freeze(ap);\r\n}\r\n}\r\nstatic void ahci_port_intr(struct ata_port *ap)\r\n{\r\nvoid __iomem *port_mmio = ahci_port_base(ap);\r\nu32 status;\r\nstatus = readl(port_mmio + PORT_IRQ_STAT);\r\nwritel(status, port_mmio + PORT_IRQ_STAT);\r\nahci_handle_port_interrupt(ap, port_mmio, status);\r\n}\r\nstatic irqreturn_t ahci_multi_irqs_intr_hard(int irq, void *dev_instance)\r\n{\r\nstruct ata_port *ap = dev_instance;\r\nvoid __iomem *port_mmio = ahci_port_base(ap);\r\nu32 status;\r\nVPRINTK("ENTER\n");\r\nstatus = readl(port_mmio + PORT_IRQ_STAT);\r\nwritel(status, port_mmio + PORT_IRQ_STAT);\r\nspin_lock(ap->lock);\r\nahci_handle_port_interrupt(ap, port_mmio, status);\r\nspin_unlock(ap->lock);\r\nVPRINTK("EXIT\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nu32 ahci_handle_port_intr(struct ata_host *host, u32 irq_masked)\r\n{\r\nunsigned int i, handled = 0;\r\nfor (i = 0; i < host->n_ports; i++) {\r\nstruct ata_port *ap;\r\nif (!(irq_masked & (1 << i)))\r\ncontinue;\r\nap = host->ports[i];\r\nif (ap) {\r\nahci_port_intr(ap);\r\nVPRINTK("port %u\n", i);\r\n} else {\r\nVPRINTK("port %u (no irq)\n", i);\r\nif (ata_ratelimit())\r\ndev_warn(host->dev,\r\n"interrupt on disabled port %u\n", i);\r\n}\r\nhandled = 1;\r\n}\r\nreturn handled;\r\n}\r\nstatic irqreturn_t ahci_single_level_irq_intr(int irq, void *dev_instance)\r\n{\r\nstruct ata_host *host = dev_instance;\r\nstruct ahci_host_priv *hpriv;\r\nunsigned int rc = 0;\r\nvoid __iomem *mmio;\r\nu32 irq_stat, irq_masked;\r\nVPRINTK("ENTER\n");\r\nhpriv = host->private_data;\r\nmmio = hpriv->mmio;\r\nirq_stat = readl(mmio + HOST_IRQ_STAT);\r\nif (!irq_stat)\r\nreturn IRQ_NONE;\r\nirq_masked = irq_stat & hpriv->port_map;\r\nspin_lock(&host->lock);\r\nrc = ahci_handle_port_intr(host, irq_masked);\r\nwritel(irq_stat, mmio + HOST_IRQ_STAT);\r\nspin_unlock(&host->lock);\r\nVPRINTK("EXIT\n");\r\nreturn IRQ_RETVAL(rc);\r\n}\r\nunsigned int ahci_qc_issue(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nvoid __iomem *port_mmio = ahci_port_base(ap);\r\nstruct ahci_port_priv *pp = ap->private_data;\r\npp->active_link = qc->dev->link;\r\nif (ata_is_ncq(qc->tf.protocol))\r\nwritel(1 << qc->tag, port_mmio + PORT_SCR_ACT);\r\nif (pp->fbs_enabled && pp->fbs_last_dev != qc->dev->link->pmp) {\r\nu32 fbs = readl(port_mmio + PORT_FBS);\r\nfbs &= ~(PORT_FBS_DEV_MASK | PORT_FBS_DEC);\r\nfbs |= qc->dev->link->pmp << PORT_FBS_DEV_OFFSET;\r\nwritel(fbs, port_mmio + PORT_FBS);\r\npp->fbs_last_dev = qc->dev->link->pmp;\r\n}\r\nwritel(1 << qc->tag, port_mmio + PORT_CMD_ISSUE);\r\nahci_sw_activity(qc->dev->link);\r\nreturn 0;\r\n}\r\nstatic bool ahci_qc_fill_rtf(struct ata_queued_cmd *qc)\r\n{\r\nstruct ahci_port_priv *pp = qc->ap->private_data;\r\nu8 *rx_fis = pp->rx_fis;\r\nif (pp->fbs_enabled)\r\nrx_fis += qc->dev->link->pmp * AHCI_RX_FIS_SZ;\r\nif (qc->tf.protocol == ATA_PROT_PIO && qc->dma_dir == DMA_FROM_DEVICE &&\r\n!(qc->flags & ATA_QCFLAG_FAILED)) {\r\nata_tf_from_fis(rx_fis + RX_FIS_PIO_SETUP, &qc->result_tf);\r\nqc->result_tf.command = (rx_fis + RX_FIS_PIO_SETUP)[15];\r\n} else\r\nata_tf_from_fis(rx_fis + RX_FIS_D2H_REG, &qc->result_tf);\r\nreturn true;\r\n}\r\nstatic void ahci_freeze(struct ata_port *ap)\r\n{\r\nvoid __iomem *port_mmio = ahci_port_base(ap);\r\nwritel(0, port_mmio + PORT_IRQ_MASK);\r\n}\r\nstatic void ahci_thaw(struct ata_port *ap)\r\n{\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nvoid __iomem *mmio = hpriv->mmio;\r\nvoid __iomem *port_mmio = ahci_port_base(ap);\r\nu32 tmp;\r\nstruct ahci_port_priv *pp = ap->private_data;\r\ntmp = readl(port_mmio + PORT_IRQ_STAT);\r\nwritel(tmp, port_mmio + PORT_IRQ_STAT);\r\nwritel(1 << ap->port_no, mmio + HOST_IRQ_STAT);\r\nwritel(pp->intr_mask, port_mmio + PORT_IRQ_MASK);\r\n}\r\nvoid ahci_error_handler(struct ata_port *ap)\r\n{\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nif (!(ap->pflags & ATA_PFLAG_FROZEN)) {\r\nahci_stop_engine(ap);\r\nhpriv->start_engine(ap);\r\n}\r\nsata_pmp_error_handler(ap);\r\nif (!ata_dev_enabled(ap->link.device))\r\nahci_stop_engine(ap);\r\n}\r\nstatic void ahci_post_internal_cmd(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nif (qc->flags & ATA_QCFLAG_FAILED)\r\nahci_kick_engine(ap);\r\n}\r\nstatic void ahci_set_aggressive_devslp(struct ata_port *ap, bool sleep)\r\n{\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nvoid __iomem *port_mmio = ahci_port_base(ap);\r\nstruct ata_device *dev = ap->link.device;\r\nu32 devslp, dm, dito, mdat, deto;\r\nint rc;\r\nunsigned int err_mask;\r\ndevslp = readl(port_mmio + PORT_DEVSLP);\r\nif (!(devslp & PORT_DEVSLP_DSP)) {\r\ndev_info(ap->host->dev, "port does not support device sleep\n");\r\nreturn;\r\n}\r\nif (!sleep) {\r\nif (devslp & PORT_DEVSLP_ADSE) {\r\nwritel(devslp & ~PORT_DEVSLP_ADSE,\r\nport_mmio + PORT_DEVSLP);\r\nerr_mask = ata_dev_set_feature(dev,\r\nSETFEATURES_SATA_DISABLE,\r\nSATA_DEVSLP);\r\nif (err_mask && err_mask != AC_ERR_DEV)\r\nata_dev_warn(dev, "failed to disable DEVSLP\n");\r\n}\r\nreturn;\r\n}\r\nif (devslp & PORT_DEVSLP_ADSE)\r\nreturn;\r\nrc = ahci_stop_engine(ap);\r\nif (rc)\r\nreturn;\r\ndm = (devslp & PORT_DEVSLP_DM_MASK) >> PORT_DEVSLP_DM_OFFSET;\r\ndito = devslp_idle_timeout / (dm + 1);\r\nif (dito > 0x3ff)\r\ndito = 0x3ff;\r\nif (dev->devslp_timing[ATA_LOG_DEVSLP_VALID] &\r\nATA_LOG_DEVSLP_VALID_MASK) {\r\nmdat = dev->devslp_timing[ATA_LOG_DEVSLP_MDAT] &\r\nATA_LOG_DEVSLP_MDAT_MASK;\r\nif (!mdat)\r\nmdat = 10;\r\ndeto = dev->devslp_timing[ATA_LOG_DEVSLP_DETO];\r\nif (!deto)\r\ndeto = 20;\r\n} else {\r\nmdat = 10;\r\ndeto = 20;\r\n}\r\ndevslp |= ((dito << PORT_DEVSLP_DITO_OFFSET) |\r\n(mdat << PORT_DEVSLP_MDAT_OFFSET) |\r\n(deto << PORT_DEVSLP_DETO_OFFSET) |\r\nPORT_DEVSLP_ADSE);\r\nwritel(devslp, port_mmio + PORT_DEVSLP);\r\nhpriv->start_engine(ap);\r\nerr_mask = ata_dev_set_feature(dev,\r\nSETFEATURES_SATA_ENABLE,\r\nSATA_DEVSLP);\r\nif (err_mask && err_mask != AC_ERR_DEV)\r\nata_dev_warn(dev, "failed to enable DEVSLP\n");\r\n}\r\nstatic void ahci_enable_fbs(struct ata_port *ap)\r\n{\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nvoid __iomem *port_mmio = ahci_port_base(ap);\r\nu32 fbs;\r\nint rc;\r\nif (!pp->fbs_supported)\r\nreturn;\r\nfbs = readl(port_mmio + PORT_FBS);\r\nif (fbs & PORT_FBS_EN) {\r\npp->fbs_enabled = true;\r\npp->fbs_last_dev = -1;\r\nreturn;\r\n}\r\nrc = ahci_stop_engine(ap);\r\nif (rc)\r\nreturn;\r\nwritel(fbs | PORT_FBS_EN, port_mmio + PORT_FBS);\r\nfbs = readl(port_mmio + PORT_FBS);\r\nif (fbs & PORT_FBS_EN) {\r\ndev_info(ap->host->dev, "FBS is enabled\n");\r\npp->fbs_enabled = true;\r\npp->fbs_last_dev = -1;\r\n} else\r\ndev_err(ap->host->dev, "Failed to enable FBS\n");\r\nhpriv->start_engine(ap);\r\n}\r\nstatic void ahci_disable_fbs(struct ata_port *ap)\r\n{\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nvoid __iomem *port_mmio = ahci_port_base(ap);\r\nu32 fbs;\r\nint rc;\r\nif (!pp->fbs_supported)\r\nreturn;\r\nfbs = readl(port_mmio + PORT_FBS);\r\nif ((fbs & PORT_FBS_EN) == 0) {\r\npp->fbs_enabled = false;\r\nreturn;\r\n}\r\nrc = ahci_stop_engine(ap);\r\nif (rc)\r\nreturn;\r\nwritel(fbs & ~PORT_FBS_EN, port_mmio + PORT_FBS);\r\nfbs = readl(port_mmio + PORT_FBS);\r\nif (fbs & PORT_FBS_EN)\r\ndev_err(ap->host->dev, "Failed to disable FBS\n");\r\nelse {\r\ndev_info(ap->host->dev, "FBS is disabled\n");\r\npp->fbs_enabled = false;\r\n}\r\nhpriv->start_engine(ap);\r\n}\r\nstatic void ahci_pmp_attach(struct ata_port *ap)\r\n{\r\nvoid __iomem *port_mmio = ahci_port_base(ap);\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nu32 cmd;\r\ncmd = readl(port_mmio + PORT_CMD);\r\ncmd |= PORT_CMD_PMP;\r\nwritel(cmd, port_mmio + PORT_CMD);\r\nahci_enable_fbs(ap);\r\npp->intr_mask |= PORT_IRQ_BAD_PMP;\r\nif (!(ap->pflags & ATA_PFLAG_FROZEN))\r\nwritel(pp->intr_mask, port_mmio + PORT_IRQ_MASK);\r\n}\r\nstatic void ahci_pmp_detach(struct ata_port *ap)\r\n{\r\nvoid __iomem *port_mmio = ahci_port_base(ap);\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nu32 cmd;\r\nahci_disable_fbs(ap);\r\ncmd = readl(port_mmio + PORT_CMD);\r\ncmd &= ~PORT_CMD_PMP;\r\nwritel(cmd, port_mmio + PORT_CMD);\r\npp->intr_mask &= ~PORT_IRQ_BAD_PMP;\r\nif (!(ap->pflags & ATA_PFLAG_FROZEN))\r\nwritel(pp->intr_mask, port_mmio + PORT_IRQ_MASK);\r\n}\r\nint ahci_port_resume(struct ata_port *ap)\r\n{\r\nahci_rpm_get_port(ap);\r\nahci_power_up(ap);\r\nahci_start_port(ap);\r\nif (sata_pmp_attached(ap))\r\nahci_pmp_attach(ap);\r\nelse\r\nahci_pmp_detach(ap);\r\nreturn 0;\r\n}\r\nstatic int ahci_port_suspend(struct ata_port *ap, pm_message_t mesg)\r\n{\r\nconst char *emsg = NULL;\r\nint rc;\r\nrc = ahci_deinit_port(ap, &emsg);\r\nif (rc == 0)\r\nahci_power_down(ap);\r\nelse {\r\nata_port_err(ap, "%s (%d)\n", emsg, rc);\r\nata_port_freeze(ap);\r\n}\r\nahci_rpm_put_port(ap);\r\nreturn rc;\r\n}\r\nstatic int ahci_port_start(struct ata_port *ap)\r\n{\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nstruct device *dev = ap->host->dev;\r\nstruct ahci_port_priv *pp;\r\nvoid *mem;\r\ndma_addr_t mem_dma;\r\nsize_t dma_sz, rx_fis_sz;\r\npp = devm_kzalloc(dev, sizeof(*pp), GFP_KERNEL);\r\nif (!pp)\r\nreturn -ENOMEM;\r\nif (ap->host->n_ports > 1) {\r\npp->irq_desc = devm_kzalloc(dev, 8, GFP_KERNEL);\r\nif (!pp->irq_desc) {\r\ndevm_kfree(dev, pp);\r\nreturn -ENOMEM;\r\n}\r\nsnprintf(pp->irq_desc, 8,\r\n"%s%d", dev_driver_string(dev), ap->port_no);\r\n}\r\nif ((hpriv->cap & HOST_CAP_FBS) && sata_pmp_supported(ap)) {\r\nvoid __iomem *port_mmio = ahci_port_base(ap);\r\nu32 cmd = readl(port_mmio + PORT_CMD);\r\nif (cmd & PORT_CMD_FBSCP)\r\npp->fbs_supported = true;\r\nelse if (hpriv->flags & AHCI_HFLAG_YES_FBS) {\r\ndev_info(dev, "port %d can do FBS, forcing FBSCP\n",\r\nap->port_no);\r\npp->fbs_supported = true;\r\n} else\r\ndev_warn(dev, "port %d is not capable of FBS\n",\r\nap->port_no);\r\n}\r\nif (pp->fbs_supported) {\r\ndma_sz = AHCI_PORT_PRIV_FBS_DMA_SZ;\r\nrx_fis_sz = AHCI_RX_FIS_SZ * 16;\r\n} else {\r\ndma_sz = AHCI_PORT_PRIV_DMA_SZ;\r\nrx_fis_sz = AHCI_RX_FIS_SZ;\r\n}\r\nmem = dmam_alloc_coherent(dev, dma_sz, &mem_dma, GFP_KERNEL);\r\nif (!mem)\r\nreturn -ENOMEM;\r\nmemset(mem, 0, dma_sz);\r\npp->cmd_slot = mem;\r\npp->cmd_slot_dma = mem_dma;\r\nmem += AHCI_CMD_SLOT_SZ;\r\nmem_dma += AHCI_CMD_SLOT_SZ;\r\npp->rx_fis = mem;\r\npp->rx_fis_dma = mem_dma;\r\nmem += rx_fis_sz;\r\nmem_dma += rx_fis_sz;\r\npp->cmd_tbl = mem;\r\npp->cmd_tbl_dma = mem_dma;\r\npp->intr_mask = DEF_PORT_IRQ;\r\nif (hpriv->flags & AHCI_HFLAG_MULTI_MSI) {\r\nspin_lock_init(&pp->lock);\r\nap->lock = &pp->lock;\r\n}\r\nap->private_data = pp;\r\nreturn ahci_port_resume(ap);\r\n}\r\nstatic void ahci_port_stop(struct ata_port *ap)\r\n{\r\nconst char *emsg = NULL;\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nvoid __iomem *host_mmio = hpriv->mmio;\r\nint rc;\r\nrc = ahci_deinit_port(ap, &emsg);\r\nif (rc)\r\nata_port_warn(ap, "%s (%d)\n", emsg, rc);\r\nwritel(1 << ap->port_no, host_mmio + HOST_IRQ_STAT);\r\n}\r\nvoid ahci_print_info(struct ata_host *host, const char *scc_s)\r\n{\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nu32 vers, cap, cap2, impl, speed;\r\nconst char *speed_s;\r\nvers = hpriv->version;\r\ncap = hpriv->cap;\r\ncap2 = hpriv->cap2;\r\nimpl = hpriv->port_map;\r\nspeed = (cap >> 20) & 0xf;\r\nif (speed == 1)\r\nspeed_s = "1.5";\r\nelse if (speed == 2)\r\nspeed_s = "3";\r\nelse if (speed == 3)\r\nspeed_s = "6";\r\nelse\r\nspeed_s = "?";\r\ndev_info(host->dev,\r\n"AHCI %02x%02x.%02x%02x "\r\n"%u slots %u ports %s Gbps 0x%x impl %s mode\n"\r\n,\r\n(vers >> 24) & 0xff,\r\n(vers >> 16) & 0xff,\r\n(vers >> 8) & 0xff,\r\nvers & 0xff,\r\n((cap >> 8) & 0x1f) + 1,\r\n(cap & 0x1f) + 1,\r\nspeed_s,\r\nimpl,\r\nscc_s);\r\ndev_info(host->dev,\r\n"flags: "\r\n"%s%s%s%s%s%s%s"\r\n"%s%s%s%s%s%s%s"\r\n"%s%s%s%s%s%s%s"\r\n"%s%s\n"\r\n,\r\ncap & HOST_CAP_64 ? "64bit " : "",\r\ncap & HOST_CAP_NCQ ? "ncq " : "",\r\ncap & HOST_CAP_SNTF ? "sntf " : "",\r\ncap & HOST_CAP_MPS ? "ilck " : "",\r\ncap & HOST_CAP_SSS ? "stag " : "",\r\ncap & HOST_CAP_ALPM ? "pm " : "",\r\ncap & HOST_CAP_LED ? "led " : "",\r\ncap & HOST_CAP_CLO ? "clo " : "",\r\ncap & HOST_CAP_ONLY ? "only " : "",\r\ncap & HOST_CAP_PMP ? "pmp " : "",\r\ncap & HOST_CAP_FBS ? "fbs " : "",\r\ncap & HOST_CAP_PIO_MULTI ? "pio " : "",\r\ncap & HOST_CAP_SSC ? "slum " : "",\r\ncap & HOST_CAP_PART ? "part " : "",\r\ncap & HOST_CAP_CCC ? "ccc " : "",\r\ncap & HOST_CAP_EMS ? "ems " : "",\r\ncap & HOST_CAP_SXS ? "sxs " : "",\r\ncap2 & HOST_CAP2_DESO ? "deso " : "",\r\ncap2 & HOST_CAP2_SADM ? "sadm " : "",\r\ncap2 & HOST_CAP2_SDS ? "sds " : "",\r\ncap2 & HOST_CAP2_APST ? "apst " : "",\r\ncap2 & HOST_CAP2_NVMHCI ? "nvmp " : "",\r\ncap2 & HOST_CAP2_BOH ? "boh " : ""\r\n);\r\n}\r\nvoid ahci_set_em_messages(struct ahci_host_priv *hpriv,\r\nstruct ata_port_info *pi)\r\n{\r\nu8 messages;\r\nvoid __iomem *mmio = hpriv->mmio;\r\nu32 em_loc = readl(mmio + HOST_EM_LOC);\r\nu32 em_ctl = readl(mmio + HOST_EM_CTL);\r\nif (!ahci_em_messages || !(hpriv->cap & HOST_CAP_EMS))\r\nreturn;\r\nmessages = (em_ctl & EM_CTRL_MSG_TYPE) >> 16;\r\nif (messages) {\r\nhpriv->em_loc = ((em_loc >> 16) * 4);\r\nhpriv->em_buf_sz = ((em_loc & 0xff) * 4);\r\nhpriv->em_msg_type = messages;\r\npi->flags |= ATA_FLAG_EM;\r\nif (!(em_ctl & EM_CTL_ALHD))\r\npi->flags |= ATA_FLAG_SW_ACTIVITY;\r\n}\r\n}\r\nstatic int ahci_host_activate_multi_irqs(struct ata_host *host,\r\nstruct scsi_host_template *sht)\r\n{\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nint i, rc;\r\nrc = ata_host_start(host);\r\nif (rc)\r\nreturn rc;\r\nfor (i = 0; i < host->n_ports; i++) {\r\nstruct ahci_port_priv *pp = host->ports[i]->private_data;\r\nint irq = hpriv->get_irq_vector(host, i);\r\nif (!pp) {\r\ndisable_irq(irq);\r\ncontinue;\r\n}\r\nrc = devm_request_irq(host->dev, irq, ahci_multi_irqs_intr_hard,\r\n0, pp->irq_desc, host->ports[i]);\r\nif (rc)\r\nreturn rc;\r\nata_port_desc(host->ports[i], "irq %d", irq);\r\n}\r\nreturn ata_host_register(host, sht);\r\n}\r\nint ahci_host_activate(struct ata_host *host, struct scsi_host_template *sht)\r\n{\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nint irq = hpriv->irq;\r\nint rc;\r\nif (hpriv->flags & AHCI_HFLAG_MULTI_MSI) {\r\nif (hpriv->irq_handler)\r\ndev_warn(host->dev,\r\n"both AHCI_HFLAG_MULTI_MSI flag set and custom irq handler implemented\n");\r\nif (!hpriv->get_irq_vector) {\r\ndev_err(host->dev,\r\n"AHCI_HFLAG_MULTI_MSI requires ->get_irq_vector!\n");\r\nreturn -EIO;\r\n}\r\nrc = ahci_host_activate_multi_irqs(host, sht);\r\n} else {\r\nrc = ata_host_activate(host, irq, hpriv->irq_handler,\r\nIRQF_SHARED, sht);\r\n}\r\nreturn rc;\r\n}
