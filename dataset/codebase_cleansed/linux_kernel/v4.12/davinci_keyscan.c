static int __init davinci_ks_initialize(struct davinci_ks *davinci_ks)\r\n{\r\nstruct device *dev = &davinci_ks->input->dev;\r\nstruct davinci_ks_platform_data *pdata = davinci_ks->pdata;\r\nu32 matrix_ctrl;\r\n__raw_writel(DAVINCI_KEYSCAN_INT_ALL,\r\ndavinci_ks->base + DAVINCI_KEYSCAN_INTENA);\r\n__raw_writel(DAVINCI_KEYSCAN_INT_ALL,\r\ndavinci_ks->base + DAVINCI_KEYSCAN_INTCLR);\r\n__raw_writel(pdata->strobe,\r\ndavinci_ks->base + DAVINCI_KEYSCAN_STRBWIDTH);\r\n__raw_writel(pdata->interval,\r\ndavinci_ks->base + DAVINCI_KEYSCAN_INTERVAL);\r\n__raw_writel(0x01,\r\ndavinci_ks->base + DAVINCI_KEYSCAN_CONTTIME);\r\nswitch (pdata->matrix_type) {\r\ncase DAVINCI_KEYSCAN_MATRIX_4X4:\r\nmatrix_ctrl = 0;\r\nbreak;\r\ncase DAVINCI_KEYSCAN_MATRIX_5X3:\r\nmatrix_ctrl = (1 << 6);\r\nbreak;\r\ndefault:\r\ndev_err(dev->parent, "wrong matrix type\n");\r\nreturn -EINVAL;\r\n}\r\n__raw_writel(DAVINCI_KEYSCAN_AUTODET | DAVINCI_KEYSCAN_KEYEN |\r\nmatrix_ctrl, davinci_ks->base + DAVINCI_KEYSCAN_KEYCTRL);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t davinci_ks_interrupt(int irq, void *dev_id)\r\n{\r\nstruct davinci_ks *davinci_ks = dev_id;\r\nstruct device *dev = &davinci_ks->input->dev;\r\nunsigned short *keymap = davinci_ks->keymap;\r\nint keymapsize = davinci_ks->pdata->keymapsize;\r\nu32 prev_status, new_status, changed;\r\nbool release;\r\nint keycode = KEY_UNKNOWN;\r\nint i;\r\n__raw_writel(0x0, davinci_ks->base + DAVINCI_KEYSCAN_INTENA);\r\nprev_status = __raw_readl(davinci_ks->base + DAVINCI_KEYSCAN_PREVSTATE);\r\nnew_status = __raw_readl(davinci_ks->base + DAVINCI_KEYSCAN_CURRENTST);\r\nchanged = prev_status ^ new_status;\r\nif (changed) {\r\nfor (i = 0 ; i < keymapsize; i++) {\r\nif ((changed>>i) & 0x1) {\r\nkeycode = keymap[i];\r\nrelease = (new_status >> i) & 0x1;\r\ndev_dbg(dev->parent, "key %d %s\n", keycode,\r\nrelease ? "released" : "pressed");\r\ninput_report_key(davinci_ks->input, keycode,\r\n!release);\r\ninput_sync(davinci_ks->input);\r\n}\r\n}\r\n__raw_writel(DAVINCI_KEYSCAN_INT_ALL,\r\ndavinci_ks->base + DAVINCI_KEYSCAN_INTCLR);\r\n}\r\n__raw_writel(0x1, davinci_ks->base + DAVINCI_KEYSCAN_INTENA);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init davinci_ks_probe(struct platform_device *pdev)\r\n{\r\nstruct davinci_ks *davinci_ks;\r\nstruct input_dev *key_dev;\r\nstruct resource *res, *mem;\r\nstruct device *dev = &pdev->dev;\r\nstruct davinci_ks_platform_data *pdata = dev_get_platdata(dev);\r\nint error, i;\r\nif (pdata->device_enable) {\r\nerror = pdata->device_enable(dev);\r\nif (error < 0) {\r\ndev_dbg(dev, "device enable function failed\n");\r\nreturn error;\r\n}\r\n}\r\nif (!pdata->keymap) {\r\ndev_dbg(dev, "no keymap from pdata\n");\r\nreturn -EINVAL;\r\n}\r\ndavinci_ks = kzalloc(sizeof(struct davinci_ks) +\r\nsizeof(unsigned short) * pdata->keymapsize, GFP_KERNEL);\r\nif (!davinci_ks) {\r\ndev_dbg(dev, "could not allocate memory for private data\n");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(davinci_ks->keymap, pdata->keymap,\r\nsizeof(unsigned short) * pdata->keymapsize);\r\nkey_dev = input_allocate_device();\r\nif (!key_dev) {\r\ndev_dbg(dev, "could not allocate input device\n");\r\nerror = -ENOMEM;\r\ngoto fail1;\r\n}\r\ndavinci_ks->input = key_dev;\r\ndavinci_ks->irq = platform_get_irq(pdev, 0);\r\nif (davinci_ks->irq < 0) {\r\ndev_err(dev, "no key scan irq\n");\r\nerror = davinci_ks->irq;\r\ngoto fail2;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(dev, "no mem resource\n");\r\nerror = -EINVAL;\r\ngoto fail2;\r\n}\r\ndavinci_ks->pbase = res->start;\r\ndavinci_ks->base_size = resource_size(res);\r\nmem = request_mem_region(davinci_ks->pbase, davinci_ks->base_size,\r\npdev->name);\r\nif (!mem) {\r\ndev_err(dev, "key scan registers at %08x are not free\n",\r\ndavinci_ks->pbase);\r\nerror = -EBUSY;\r\ngoto fail2;\r\n}\r\ndavinci_ks->base = ioremap(davinci_ks->pbase, davinci_ks->base_size);\r\nif (!davinci_ks->base) {\r\ndev_err(dev, "can't ioremap MEM resource.\n");\r\nerror = -ENOMEM;\r\ngoto fail3;\r\n}\r\nif (pdata->rep)\r\n__set_bit(EV_REP, key_dev->evbit);\r\n__set_bit(EV_KEY, key_dev->evbit);\r\ndavinci_ks->pdata = pdata;\r\nfor (i = 0; i < davinci_ks->pdata->keymapsize; i++)\r\n__set_bit(davinci_ks->pdata->keymap[i], key_dev->keybit);\r\nkey_dev->name = "davinci_keyscan";\r\nkey_dev->phys = "davinci_keyscan/input0";\r\nkey_dev->dev.parent = dev;\r\nkey_dev->id.bustype = BUS_HOST;\r\nkey_dev->id.vendor = 0x0001;\r\nkey_dev->id.product = 0x0001;\r\nkey_dev->id.version = 0x0001;\r\nkey_dev->keycode = davinci_ks->keymap;\r\nkey_dev->keycodesize = sizeof(davinci_ks->keymap[0]);\r\nkey_dev->keycodemax = davinci_ks->pdata->keymapsize;\r\nerror = input_register_device(davinci_ks->input);\r\nif (error < 0) {\r\ndev_err(dev, "unable to register davinci key scan device\n");\r\ngoto fail4;\r\n}\r\nerror = request_irq(davinci_ks->irq, davinci_ks_interrupt,\r\n0, pdev->name, davinci_ks);\r\nif (error < 0) {\r\ndev_err(dev, "unable to register davinci key scan interrupt\n");\r\ngoto fail5;\r\n}\r\nerror = davinci_ks_initialize(davinci_ks);\r\nif (error < 0) {\r\ndev_err(dev, "unable to initialize davinci key scan device\n");\r\ngoto fail6;\r\n}\r\nplatform_set_drvdata(pdev, davinci_ks);\r\nreturn 0;\r\nfail6:\r\nfree_irq(davinci_ks->irq, davinci_ks);\r\nfail5:\r\ninput_unregister_device(davinci_ks->input);\r\nkey_dev = NULL;\r\nfail4:\r\niounmap(davinci_ks->base);\r\nfail3:\r\nrelease_mem_region(davinci_ks->pbase, davinci_ks->base_size);\r\nfail2:\r\ninput_free_device(key_dev);\r\nfail1:\r\nkfree(davinci_ks);\r\nreturn error;\r\n}\r\nstatic int davinci_ks_remove(struct platform_device *pdev)\r\n{\r\nstruct davinci_ks *davinci_ks = platform_get_drvdata(pdev);\r\nfree_irq(davinci_ks->irq, davinci_ks);\r\ninput_unregister_device(davinci_ks->input);\r\niounmap(davinci_ks->base);\r\nrelease_mem_region(davinci_ks->pbase, davinci_ks->base_size);\r\nkfree(davinci_ks);\r\nreturn 0;\r\n}
