static inline bool check_debug_ip(struct kvm_vcpu *vcpu)\r\n{\r\n#ifdef DEBUG_MMU_PTE_IP\r\nreturn vcpu->arch.pc == DEBUG_MMU_PTE_IP;\r\n#else\r\nreturn true;\r\n#endif\r\n}\r\nstatic inline u32 sr_vsid(u32 sr_raw)\r\n{\r\nreturn sr_raw & 0x0fffffff;\r\n}\r\nstatic inline bool sr_valid(u32 sr_raw)\r\n{\r\nreturn (sr_raw & 0x80000000) ? false : true;\r\n}\r\nstatic inline bool sr_ks(u32 sr_raw)\r\n{\r\nreturn (sr_raw & 0x40000000) ? true: false;\r\n}\r\nstatic inline bool sr_kp(u32 sr_raw)\r\n{\r\nreturn (sr_raw & 0x20000000) ? true: false;\r\n}\r\nstatic u32 find_sr(struct kvm_vcpu *vcpu, gva_t eaddr)\r\n{\r\nreturn kvmppc_get_sr(vcpu, (eaddr >> 28) & 0xf);\r\n}\r\nstatic u64 kvmppc_mmu_book3s_32_ea_to_vp(struct kvm_vcpu *vcpu, gva_t eaddr,\r\nbool data)\r\n{\r\nu64 vsid;\r\nstruct kvmppc_pte pte;\r\nif (!kvmppc_mmu_book3s_32_xlate_bat(vcpu, eaddr, &pte, data, false))\r\nreturn pte.vpage;\r\nkvmppc_mmu_book3s_32_esid_to_vsid(vcpu, eaddr >> SID_SHIFT, &vsid);\r\nreturn (((u64)eaddr >> 12) & 0xffff) | (vsid << 16);\r\n}\r\nstatic void kvmppc_mmu_book3s_32_reset_msr(struct kvm_vcpu *vcpu)\r\n{\r\nkvmppc_set_msr(vcpu, 0);\r\n}\r\nstatic hva_t kvmppc_mmu_book3s_32_get_pteg(struct kvm_vcpu *vcpu,\r\nu32 sre, gva_t eaddr,\r\nbool primary)\r\n{\r\nstruct kvmppc_vcpu_book3s *vcpu_book3s = to_book3s(vcpu);\r\nu32 page, hash, pteg, htabmask;\r\nhva_t r;\r\npage = (eaddr & 0x0FFFFFFF) >> 12;\r\nhtabmask = ((vcpu_book3s->sdr1 & 0x1FF) << 16) | 0xFFC0;\r\nhash = ((sr_vsid(sre) ^ page) << 6);\r\nif (!primary)\r\nhash = ~hash;\r\nhash &= htabmask;\r\npteg = (vcpu_book3s->sdr1 & 0xffff0000) | hash;\r\ndprintk("MMU: pc=0x%lx eaddr=0x%lx sdr1=0x%llx pteg=0x%x vsid=0x%x\n",\r\nkvmppc_get_pc(vcpu), eaddr, vcpu_book3s->sdr1, pteg,\r\nsr_vsid(sre));\r\nr = gfn_to_hva(vcpu->kvm, pteg >> PAGE_SHIFT);\r\nif (kvm_is_error_hva(r))\r\nreturn r;\r\nreturn r | (pteg & ~PAGE_MASK);\r\n}\r\nstatic u32 kvmppc_mmu_book3s_32_get_ptem(u32 sre, gva_t eaddr, bool primary)\r\n{\r\nreturn ((eaddr & 0x0fffffff) >> 22) | (sr_vsid(sre) << 7) |\r\n(primary ? 0 : 0x40) | 0x80000000;\r\n}\r\nstatic int kvmppc_mmu_book3s_32_xlate_bat(struct kvm_vcpu *vcpu, gva_t eaddr,\r\nstruct kvmppc_pte *pte, bool data,\r\nbool iswrite)\r\n{\r\nstruct kvmppc_vcpu_book3s *vcpu_book3s = to_book3s(vcpu);\r\nstruct kvmppc_bat *bat;\r\nint i;\r\nfor (i = 0; i < 8; i++) {\r\nif (data)\r\nbat = &vcpu_book3s->dbat[i];\r\nelse\r\nbat = &vcpu_book3s->ibat[i];\r\nif (kvmppc_get_msr(vcpu) & MSR_PR) {\r\nif (!bat->vp)\r\ncontinue;\r\n} else {\r\nif (!bat->vs)\r\ncontinue;\r\n}\r\nif (check_debug_ip(vcpu))\r\n{\r\ndprintk_pte("%cBAT %02d: 0x%lx - 0x%x (0x%x)\n",\r\ndata ? 'd' : 'i', i, eaddr, bat->bepi,\r\nbat->bepi_mask);\r\n}\r\nif ((eaddr & bat->bepi_mask) == bat->bepi) {\r\nu64 vsid;\r\nkvmppc_mmu_book3s_32_esid_to_vsid(vcpu,\r\neaddr >> SID_SHIFT, &vsid);\r\nvsid <<= 16;\r\npte->vpage = (((u64)eaddr >> 12) & 0xffff) | vsid;\r\npte->raddr = bat->brpn | (eaddr & ~bat->bepi_mask);\r\npte->may_read = bat->pp;\r\npte->may_write = bat->pp > 1;\r\npte->may_execute = true;\r\nif (!pte->may_read) {\r\nprintk(KERN_INFO "BAT is not readable!\n");\r\ncontinue;\r\n}\r\nif (iswrite && !pte->may_write) {\r\ndprintk_pte("BAT is read-only!\n");\r\ncontinue;\r\n}\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic int kvmppc_mmu_book3s_32_xlate_pte(struct kvm_vcpu *vcpu, gva_t eaddr,\r\nstruct kvmppc_pte *pte, bool data,\r\nbool iswrite, bool primary)\r\n{\r\nu32 sre;\r\nhva_t ptegp;\r\nu32 pteg[16];\r\nu32 pte0, pte1;\r\nu32 ptem = 0;\r\nint i;\r\nint found = 0;\r\nsre = find_sr(vcpu, eaddr);\r\ndprintk_pte("SR 0x%lx: vsid=0x%x, raw=0x%x\n", eaddr >> 28,\r\nsr_vsid(sre), sre);\r\npte->vpage = kvmppc_mmu_book3s_32_ea_to_vp(vcpu, eaddr, data);\r\nptegp = kvmppc_mmu_book3s_32_get_pteg(vcpu, sre, eaddr, primary);\r\nif (kvm_is_error_hva(ptegp)) {\r\nprintk(KERN_INFO "KVM: Invalid PTEG!\n");\r\ngoto no_page_found;\r\n}\r\nptem = kvmppc_mmu_book3s_32_get_ptem(sre, eaddr, primary);\r\nif(copy_from_user(pteg, (void __user *)ptegp, sizeof(pteg))) {\r\nprintk_ratelimited(KERN_ERR\r\n"KVM: Can't copy data from 0x%lx!\n", ptegp);\r\ngoto no_page_found;\r\n}\r\nfor (i=0; i<16; i+=2) {\r\npte0 = be32_to_cpu(pteg[i]);\r\npte1 = be32_to_cpu(pteg[i + 1]);\r\nif (ptem == pte0) {\r\nu8 pp;\r\npte->raddr = (pte1 & ~(0xFFFULL)) | (eaddr & 0xFFF);\r\npp = pte1 & 3;\r\nif ((sr_kp(sre) && (kvmppc_get_msr(vcpu) & MSR_PR)) ||\r\n(sr_ks(sre) && !(kvmppc_get_msr(vcpu) & MSR_PR)))\r\npp |= 4;\r\npte->may_write = false;\r\npte->may_read = false;\r\npte->may_execute = true;\r\nswitch (pp) {\r\ncase 0:\r\ncase 1:\r\ncase 2:\r\ncase 6:\r\npte->may_write = true;\r\ncase 3:\r\ncase 5:\r\ncase 7:\r\npte->may_read = true;\r\nbreak;\r\n}\r\ndprintk_pte("MMU: Found PTE -> %x %x - %x\n",\r\npte0, pte1, pp);\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (found) {\r\nu32 pte_r = pte1;\r\nchar __user *addr = (char __user *) (ptegp + (i+1) * sizeof(u32));\r\nif (pte->may_read && !(pte_r & PTEG_FLAG_ACCESSED)) {\r\npte_r |= PTEG_FLAG_ACCESSED;\r\nput_user(pte_r >> 8, addr + 2);\r\n}\r\nif (iswrite && pte->may_write && !(pte_r & PTEG_FLAG_DIRTY)) {\r\npte_r |= PTEG_FLAG_DIRTY;\r\nput_user(pte_r, addr + 3);\r\n}\r\nif (!pte->may_read || (iswrite && !pte->may_write))\r\nreturn -EPERM;\r\nreturn 0;\r\n}\r\nno_page_found:\r\nif (check_debug_ip(vcpu)) {\r\ndprintk_pte("KVM MMU: No PTE found (sdr1=0x%llx ptegp=0x%lx)\n",\r\nto_book3s(vcpu)->sdr1, ptegp);\r\nfor (i=0; i<16; i+=2) {\r\ndprintk_pte(" %02d: 0x%x - 0x%x (0x%x)\n",\r\ni, be32_to_cpu(pteg[i]),\r\nbe32_to_cpu(pteg[i+1]), ptem);\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic int kvmppc_mmu_book3s_32_xlate(struct kvm_vcpu *vcpu, gva_t eaddr,\r\nstruct kvmppc_pte *pte, bool data,\r\nbool iswrite)\r\n{\r\nint r;\r\nulong mp_ea = vcpu->arch.magic_page_ea;\r\npte->eaddr = eaddr;\r\npte->page_size = MMU_PAGE_4K;\r\nif (unlikely(mp_ea) &&\r\nunlikely((eaddr & ~0xfffULL) == (mp_ea & ~0xfffULL)) &&\r\n!(kvmppc_get_msr(vcpu) & MSR_PR)) {\r\npte->vpage = kvmppc_mmu_book3s_32_ea_to_vp(vcpu, eaddr, data);\r\npte->raddr = vcpu->arch.magic_page_pa | (pte->raddr & 0xfff);\r\npte->raddr &= KVM_PAM;\r\npte->may_execute = true;\r\npte->may_read = true;\r\npte->may_write = true;\r\nreturn 0;\r\n}\r\nr = kvmppc_mmu_book3s_32_xlate_bat(vcpu, eaddr, pte, data, iswrite);\r\nif (r < 0)\r\nr = kvmppc_mmu_book3s_32_xlate_pte(vcpu, eaddr, pte,\r\ndata, iswrite, true);\r\nif (r == -ENOENT)\r\nr = kvmppc_mmu_book3s_32_xlate_pte(vcpu, eaddr, pte,\r\ndata, iswrite, false);\r\nreturn r;\r\n}\r\nstatic u32 kvmppc_mmu_book3s_32_mfsrin(struct kvm_vcpu *vcpu, u32 srnum)\r\n{\r\nreturn kvmppc_get_sr(vcpu, srnum);\r\n}\r\nstatic void kvmppc_mmu_book3s_32_mtsrin(struct kvm_vcpu *vcpu, u32 srnum,\r\nulong value)\r\n{\r\nkvmppc_set_sr(vcpu, srnum, value);\r\nkvmppc_mmu_map_segment(vcpu, srnum << SID_SHIFT);\r\n}\r\nstatic void kvmppc_mmu_book3s_32_tlbie(struct kvm_vcpu *vcpu, ulong ea, bool large)\r\n{\r\nint i;\r\nstruct kvm_vcpu *v;\r\nkvm_for_each_vcpu(i, v, vcpu->kvm)\r\nkvmppc_mmu_pte_flush(v, ea, 0x0FFFF000);\r\n}\r\nstatic int kvmppc_mmu_book3s_32_esid_to_vsid(struct kvm_vcpu *vcpu, ulong esid,\r\nu64 *vsid)\r\n{\r\nulong ea = esid << SID_SHIFT;\r\nu32 sr;\r\nu64 gvsid = esid;\r\nu64 msr = kvmppc_get_msr(vcpu);\r\nif (msr & (MSR_DR|MSR_IR)) {\r\nsr = find_sr(vcpu, ea);\r\nif (sr_valid(sr))\r\ngvsid = sr_vsid(sr);\r\n}\r\nswitch (msr & (MSR_DR|MSR_IR)) {\r\ncase 0:\r\n*vsid = VSID_REAL | esid;\r\nbreak;\r\ncase MSR_IR:\r\n*vsid = VSID_REAL_IR | gvsid;\r\nbreak;\r\ncase MSR_DR:\r\n*vsid = VSID_REAL_DR | gvsid;\r\nbreak;\r\ncase MSR_DR|MSR_IR:\r\nif (sr_valid(sr))\r\n*vsid = sr_vsid(sr);\r\nelse\r\n*vsid = VSID_BAT | gvsid;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nif (msr & MSR_PR)\r\n*vsid |= VSID_PR;\r\nreturn 0;\r\n}\r\nstatic bool kvmppc_mmu_book3s_32_is_dcbz32(struct kvm_vcpu *vcpu)\r\n{\r\nreturn true;\r\n}\r\nvoid kvmppc_mmu_book3s_32_init(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvmppc_mmu *mmu = &vcpu->arch.mmu;\r\nmmu->mtsrin = kvmppc_mmu_book3s_32_mtsrin;\r\nmmu->mfsrin = kvmppc_mmu_book3s_32_mfsrin;\r\nmmu->xlate = kvmppc_mmu_book3s_32_xlate;\r\nmmu->reset_msr = kvmppc_mmu_book3s_32_reset_msr;\r\nmmu->tlbie = kvmppc_mmu_book3s_32_tlbie;\r\nmmu->esid_to_vsid = kvmppc_mmu_book3s_32_esid_to_vsid;\r\nmmu->ea_to_vp = kvmppc_mmu_book3s_32_ea_to_vp;\r\nmmu->is_dcbz32 = kvmppc_mmu_book3s_32_is_dcbz32;\r\nmmu->slbmte = NULL;\r\nmmu->slbmfee = NULL;\r\nmmu->slbmfev = NULL;\r\nmmu->slbie = NULL;\r\nmmu->slbia = NULL;\r\n}
