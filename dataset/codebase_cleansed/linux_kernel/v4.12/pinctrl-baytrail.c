static struct byt_community *byt_get_community(struct byt_gpio *vg,\r\nunsigned int pin)\r\n{\r\nstruct byt_community *comm;\r\nint i;\r\nfor (i = 0; i < vg->soc_data->ncommunities; i++) {\r\ncomm = vg->communities_copy + i;\r\nif (pin < comm->pin_base + comm->npins && pin >= comm->pin_base)\r\nreturn comm;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void __iomem *byt_gpio_reg(struct byt_gpio *vg, unsigned int offset,\r\nint reg)\r\n{\r\nstruct byt_community *comm = byt_get_community(vg, offset);\r\nu32 reg_offset;\r\nif (!comm)\r\nreturn NULL;\r\noffset -= comm->pin_base;\r\nswitch (reg) {\r\ncase BYT_INT_STAT_REG:\r\nreg_offset = (offset / 32) * 4;\r\nbreak;\r\ncase BYT_DEBOUNCE_REG:\r\nreg_offset = 0;\r\nbreak;\r\ndefault:\r\nreg_offset = comm->pad_map[offset] * 16;\r\nbreak;\r\n}\r\nreturn comm->reg_base + reg_offset + reg;\r\n}\r\nstatic int byt_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct byt_gpio *vg = pinctrl_dev_get_drvdata(pctldev);\r\nreturn vg->soc_data->ngroups;\r\n}\r\nstatic const char *byt_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned int selector)\r\n{\r\nstruct byt_gpio *vg = pinctrl_dev_get_drvdata(pctldev);\r\nreturn vg->soc_data->groups[selector].name;\r\n}\r\nstatic int byt_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned int selector,\r\nconst unsigned int **pins,\r\nunsigned int *num_pins)\r\n{\r\nstruct byt_gpio *vg = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = vg->soc_data->groups[selector].pins;\r\n*num_pins = vg->soc_data->groups[selector].npins;\r\nreturn 0;\r\n}\r\nstatic int byt_get_functions_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct byt_gpio *vg = pinctrl_dev_get_drvdata(pctldev);\r\nreturn vg->soc_data->nfunctions;\r\n}\r\nstatic const char *byt_get_function_name(struct pinctrl_dev *pctldev,\r\nunsigned int selector)\r\n{\r\nstruct byt_gpio *vg = pinctrl_dev_get_drvdata(pctldev);\r\nreturn vg->soc_data->functions[selector].name;\r\n}\r\nstatic int byt_get_function_groups(struct pinctrl_dev *pctldev,\r\nunsigned int selector,\r\nconst char * const **groups,\r\nunsigned int *num_groups)\r\n{\r\nstruct byt_gpio *vg = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = vg->soc_data->functions[selector].groups;\r\n*num_groups = vg->soc_data->functions[selector].ngroups;\r\nreturn 0;\r\n}\r\nstatic int byt_get_group_simple_mux(const struct byt_pingroup group,\r\nconst char *func_name,\r\nunsigned short *func)\r\n{\r\nint i;\r\nfor (i = 0; i < group.nfuncs; i++) {\r\nif (!strcmp(group.simple_funcs[i].name, func_name)) {\r\n*func = group.simple_funcs[i].func;\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int byt_get_group_mixed_mux(const struct byt_pingroup group,\r\nconst char *func_name,\r\nconst unsigned short **func)\r\n{\r\nint i;\r\nfor (i = 0; i < group.nfuncs; i++) {\r\nif (!strcmp(group.mixed_funcs[i].name, func_name)) {\r\n*func = group.mixed_funcs[i].func_values;\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic void byt_set_group_simple_mux(struct byt_gpio *vg,\r\nconst struct byt_pingroup group,\r\nunsigned short func)\r\n{\r\nunsigned long flags;\r\nint i;\r\nraw_spin_lock_irqsave(&vg->lock, flags);\r\nfor (i = 0; i < group.npins; i++) {\r\nvoid __iomem *padcfg0;\r\nu32 value;\r\npadcfg0 = byt_gpio_reg(vg, group.pins[i], BYT_CONF0_REG);\r\nif (!padcfg0) {\r\ndev_warn(&vg->pdev->dev,\r\n"Group %s, pin %i not muxed (no padcfg0)\n",\r\ngroup.name, i);\r\ncontinue;\r\n}\r\nvalue = readl(padcfg0);\r\nvalue &= ~BYT_PIN_MUX;\r\nvalue |= func;\r\nwritel(value, padcfg0);\r\n}\r\nraw_spin_unlock_irqrestore(&vg->lock, flags);\r\n}\r\nstatic void byt_set_group_mixed_mux(struct byt_gpio *vg,\r\nconst struct byt_pingroup group,\r\nconst unsigned short *func)\r\n{\r\nunsigned long flags;\r\nint i;\r\nraw_spin_lock_irqsave(&vg->lock, flags);\r\nfor (i = 0; i < group.npins; i++) {\r\nvoid __iomem *padcfg0;\r\nu32 value;\r\npadcfg0 = byt_gpio_reg(vg, group.pins[i], BYT_CONF0_REG);\r\nif (!padcfg0) {\r\ndev_warn(&vg->pdev->dev,\r\n"Group %s, pin %i not muxed (no padcfg0)\n",\r\ngroup.name, i);\r\ncontinue;\r\n}\r\nvalue = readl(padcfg0);\r\nvalue &= ~BYT_PIN_MUX;\r\nvalue |= func[i];\r\nwritel(value, padcfg0);\r\n}\r\nraw_spin_unlock_irqrestore(&vg->lock, flags);\r\n}\r\nstatic int byt_set_mux(struct pinctrl_dev *pctldev, unsigned int func_selector,\r\nunsigned int group_selector)\r\n{\r\nstruct byt_gpio *vg = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct byt_function func = vg->soc_data->functions[func_selector];\r\nconst struct byt_pingroup group = vg->soc_data->groups[group_selector];\r\nconst unsigned short *mixed_func;\r\nunsigned short simple_func;\r\nint ret = 1;\r\nif (group.has_simple_funcs)\r\nret = byt_get_group_simple_mux(group, func.name, &simple_func);\r\nelse\r\nret = byt_get_group_mixed_mux(group, func.name, &mixed_func);\r\nif (ret)\r\nbyt_set_group_simple_mux(vg, group, BYT_DEFAULT_GPIO_MUX);\r\nelse if (group.has_simple_funcs)\r\nbyt_set_group_simple_mux(vg, group, simple_func);\r\nelse\r\nbyt_set_group_mixed_mux(vg, group, mixed_func);\r\nreturn 0;\r\n}\r\nstatic u32 byt_get_gpio_mux(struct byt_gpio *vg, unsigned offset)\r\n{\r\nif (!strcmp(vg->soc_data->uid, BYT_SCORE_ACPI_UID) &&\r\noffset >= 92 && offset <= 93)\r\nreturn 1;\r\nif (!strcmp(vg->soc_data->uid, BYT_SUS_ACPI_UID) &&\r\noffset >= 11 && offset <= 21)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void byt_gpio_clear_triggering(struct byt_gpio *vg, unsigned int offset)\r\n{\r\nvoid __iomem *reg = byt_gpio_reg(vg, offset, BYT_CONF0_REG);\r\nunsigned long flags;\r\nu32 value;\r\nraw_spin_lock_irqsave(&vg->lock, flags);\r\nvalue = readl(reg);\r\nvalue &= ~(BYT_TRIG_POS | BYT_TRIG_NEG | BYT_TRIG_LVL);\r\nwritel(value, reg);\r\nraw_spin_unlock_irqrestore(&vg->lock, flags);\r\n}\r\nstatic int byt_gpio_request_enable(struct pinctrl_dev *pctl_dev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned int offset)\r\n{\r\nstruct byt_gpio *vg = pinctrl_dev_get_drvdata(pctl_dev);\r\nvoid __iomem *reg = byt_gpio_reg(vg, offset, BYT_CONF0_REG);\r\nu32 value, gpio_mux;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&vg->lock, flags);\r\nvalue = readl(reg) & BYT_PIN_MUX;\r\ngpio_mux = byt_get_gpio_mux(vg, offset);\r\nif (WARN_ON(gpio_mux != value)) {\r\nvalue = readl(reg) & ~BYT_PIN_MUX;\r\nvalue |= gpio_mux;\r\nwritel(value, reg);\r\ndev_warn(&vg->pdev->dev,\r\n"pin %u forcibly re-configured as GPIO\n", offset);\r\n}\r\nraw_spin_unlock_irqrestore(&vg->lock, flags);\r\npm_runtime_get(&vg->pdev->dev);\r\nreturn 0;\r\n}\r\nstatic void byt_gpio_disable_free(struct pinctrl_dev *pctl_dev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned int offset)\r\n{\r\nstruct byt_gpio *vg = pinctrl_dev_get_drvdata(pctl_dev);\r\nbyt_gpio_clear_triggering(vg, offset);\r\npm_runtime_put(&vg->pdev->dev);\r\n}\r\nstatic int byt_gpio_set_direction(struct pinctrl_dev *pctl_dev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned int offset,\r\nbool input)\r\n{\r\nstruct byt_gpio *vg = pinctrl_dev_get_drvdata(pctl_dev);\r\nvoid __iomem *val_reg = byt_gpio_reg(vg, offset, BYT_VAL_REG);\r\nvoid __iomem *conf_reg = byt_gpio_reg(vg, offset, BYT_CONF0_REG);\r\nunsigned long flags;\r\nu32 value;\r\nraw_spin_lock_irqsave(&vg->lock, flags);\r\nvalue = readl(val_reg);\r\nvalue &= ~BYT_DIR_MASK;\r\nif (input)\r\nvalue |= BYT_OUTPUT_EN;\r\nelse\r\nWARN(readl(conf_reg) & BYT_DIRECT_IRQ_EN,\r\n"Potential Error: Setting GPIO with direct_irq_en to output");\r\nwritel(value, val_reg);\r\nraw_spin_unlock_irqrestore(&vg->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void byt_get_pull_strength(u32 reg, u16 *strength)\r\n{\r\nswitch (reg & BYT_PULL_STR_MASK) {\r\ncase BYT_PULL_STR_2K:\r\n*strength = 2000;\r\nbreak;\r\ncase BYT_PULL_STR_10K:\r\n*strength = 10000;\r\nbreak;\r\ncase BYT_PULL_STR_20K:\r\n*strength = 20000;\r\nbreak;\r\ncase BYT_PULL_STR_40K:\r\n*strength = 40000;\r\nbreak;\r\n}\r\n}\r\nstatic int byt_set_pull_strength(u32 *reg, u16 strength)\r\n{\r\n*reg &= ~BYT_PULL_STR_MASK;\r\nswitch (strength) {\r\ncase 2000:\r\n*reg |= BYT_PULL_STR_2K;\r\nbreak;\r\ncase 10000:\r\n*reg |= BYT_PULL_STR_10K;\r\nbreak;\r\ncase 20000:\r\n*reg |= BYT_PULL_STR_20K;\r\nbreak;\r\ncase 40000:\r\n*reg |= BYT_PULL_STR_40K;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int byt_pin_config_get(struct pinctrl_dev *pctl_dev, unsigned int offset,\r\nunsigned long *config)\r\n{\r\nstruct byt_gpio *vg = pinctrl_dev_get_drvdata(pctl_dev);\r\nenum pin_config_param param = pinconf_to_config_param(*config);\r\nvoid __iomem *conf_reg = byt_gpio_reg(vg, offset, BYT_CONF0_REG);\r\nvoid __iomem *val_reg = byt_gpio_reg(vg, offset, BYT_VAL_REG);\r\nvoid __iomem *db_reg = byt_gpio_reg(vg, offset, BYT_DEBOUNCE_REG);\r\nunsigned long flags;\r\nu32 conf, pull, val, debounce;\r\nu16 arg = 0;\r\nraw_spin_lock_irqsave(&vg->lock, flags);\r\nconf = readl(conf_reg);\r\npull = conf & BYT_PULL_ASSIGN_MASK;\r\nval = readl(val_reg);\r\nraw_spin_unlock_irqrestore(&vg->lock, flags);\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nif (pull)\r\nreturn -EINVAL;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nif ((val & BYT_INPUT_EN) || pull != BYT_PULL_ASSIGN_DOWN)\r\nreturn -EINVAL;\r\nbyt_get_pull_strength(conf, &arg);\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nif ((val & BYT_INPUT_EN) || pull != BYT_PULL_ASSIGN_UP)\r\nreturn -EINVAL;\r\nbyt_get_pull_strength(conf, &arg);\r\nbreak;\r\ncase PIN_CONFIG_INPUT_DEBOUNCE:\r\nif (!(conf & BYT_DEBOUNCE_EN))\r\nreturn -EINVAL;\r\nraw_spin_lock_irqsave(&vg->lock, flags);\r\ndebounce = readl(db_reg);\r\nraw_spin_unlock_irqrestore(&vg->lock, flags);\r\nswitch (debounce & BYT_DEBOUNCE_PULSE_MASK) {\r\ncase BYT_DEBOUNCE_PULSE_375US:\r\narg = 375;\r\nbreak;\r\ncase BYT_DEBOUNCE_PULSE_750US:\r\narg = 750;\r\nbreak;\r\ncase BYT_DEBOUNCE_PULSE_1500US:\r\narg = 1500;\r\nbreak;\r\ncase BYT_DEBOUNCE_PULSE_3MS:\r\narg = 3000;\r\nbreak;\r\ncase BYT_DEBOUNCE_PULSE_6MS:\r\narg = 6000;\r\nbreak;\r\ncase BYT_DEBOUNCE_PULSE_12MS:\r\narg = 12000;\r\nbreak;\r\ncase BYT_DEBOUNCE_PULSE_24MS:\r\narg = 24000;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\n*config = pinconf_to_config_packed(param, arg);\r\nreturn 0;\r\n}\r\nstatic int byt_pin_config_set(struct pinctrl_dev *pctl_dev,\r\nunsigned int offset,\r\nunsigned long *configs,\r\nunsigned int num_configs)\r\n{\r\nstruct byt_gpio *vg = pinctrl_dev_get_drvdata(pctl_dev);\r\nunsigned int param, arg;\r\nvoid __iomem *conf_reg = byt_gpio_reg(vg, offset, BYT_CONF0_REG);\r\nvoid __iomem *val_reg = byt_gpio_reg(vg, offset, BYT_VAL_REG);\r\nvoid __iomem *db_reg = byt_gpio_reg(vg, offset, BYT_DEBOUNCE_REG);\r\nunsigned long flags;\r\nu32 conf, val, debounce;\r\nint i, ret = 0;\r\nraw_spin_lock_irqsave(&vg->lock, flags);\r\nconf = readl(conf_reg);\r\nval = readl(val_reg);\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = pinconf_to_config_param(configs[i]);\r\narg = pinconf_to_config_argument(configs[i]);\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nconf &= ~BYT_PULL_ASSIGN_MASK;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nif (arg == 1)\r\narg = 2000;\r\nif (val & BYT_INPUT_EN) {\r\nval &= ~BYT_INPUT_EN;\r\nwritel(val, val_reg);\r\ndev_warn(&vg->pdev->dev,\r\n"pin %u forcibly set to input mode\n",\r\noffset);\r\n}\r\nconf &= ~BYT_PULL_ASSIGN_MASK;\r\nconf |= BYT_PULL_ASSIGN_DOWN;\r\nret = byt_set_pull_strength(&conf, arg);\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nif (arg == 1)\r\narg = 2000;\r\nif (val & BYT_INPUT_EN) {\r\nval &= ~BYT_INPUT_EN;\r\nwritel(val, val_reg);\r\ndev_warn(&vg->pdev->dev,\r\n"pin %u forcibly set to input mode\n",\r\noffset);\r\n}\r\nconf &= ~BYT_PULL_ASSIGN_MASK;\r\nconf |= BYT_PULL_ASSIGN_UP;\r\nret = byt_set_pull_strength(&conf, arg);\r\nbreak;\r\ncase PIN_CONFIG_INPUT_DEBOUNCE:\r\ndebounce = readl(db_reg);\r\ndebounce &= ~BYT_DEBOUNCE_PULSE_MASK;\r\nif (arg)\r\nconf |= BYT_DEBOUNCE_EN;\r\nelse\r\nconf &= ~BYT_DEBOUNCE_EN;\r\nswitch (arg) {\r\ncase 375:\r\ndebounce |= BYT_DEBOUNCE_PULSE_375US;\r\nbreak;\r\ncase 750:\r\ndebounce |= BYT_DEBOUNCE_PULSE_750US;\r\nbreak;\r\ncase 1500:\r\ndebounce |= BYT_DEBOUNCE_PULSE_1500US;\r\nbreak;\r\ncase 3000:\r\ndebounce |= BYT_DEBOUNCE_PULSE_3MS;\r\nbreak;\r\ncase 6000:\r\ndebounce |= BYT_DEBOUNCE_PULSE_6MS;\r\nbreak;\r\ncase 12000:\r\ndebounce |= BYT_DEBOUNCE_PULSE_12MS;\r\nbreak;\r\ncase 24000:\r\ndebounce |= BYT_DEBOUNCE_PULSE_24MS;\r\nbreak;\r\ndefault:\r\nif (arg)\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (!ret)\r\nwritel(debounce, db_reg);\r\nbreak;\r\ndefault:\r\nret = -ENOTSUPP;\r\n}\r\nif (ret)\r\nbreak;\r\n}\r\nif (!ret)\r\nwritel(conf, conf_reg);\r\nraw_spin_unlock_irqrestore(&vg->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int byt_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct byt_gpio *vg = gpiochip_get_data(chip);\r\nvoid __iomem *reg = byt_gpio_reg(vg, offset, BYT_VAL_REG);\r\nunsigned long flags;\r\nu32 val;\r\nraw_spin_lock_irqsave(&vg->lock, flags);\r\nval = readl(reg);\r\nraw_spin_unlock_irqrestore(&vg->lock, flags);\r\nreturn !!(val & BYT_LEVEL);\r\n}\r\nstatic void byt_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct byt_gpio *vg = gpiochip_get_data(chip);\r\nvoid __iomem *reg = byt_gpio_reg(vg, offset, BYT_VAL_REG);\r\nunsigned long flags;\r\nu32 old_val;\r\nif (!reg)\r\nreturn;\r\nraw_spin_lock_irqsave(&vg->lock, flags);\r\nold_val = readl(reg);\r\nif (value)\r\nwritel(old_val | BYT_LEVEL, reg);\r\nelse\r\nwritel(old_val & ~BYT_LEVEL, reg);\r\nraw_spin_unlock_irqrestore(&vg->lock, flags);\r\n}\r\nstatic int byt_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)\r\n{\r\nstruct byt_gpio *vg = gpiochip_get_data(chip);\r\nvoid __iomem *reg = byt_gpio_reg(vg, offset, BYT_VAL_REG);\r\nunsigned long flags;\r\nu32 value;\r\nif (!reg)\r\nreturn -EINVAL;\r\nraw_spin_lock_irqsave(&vg->lock, flags);\r\nvalue = readl(reg);\r\nraw_spin_unlock_irqrestore(&vg->lock, flags);\r\nif (!(value & BYT_OUTPUT_EN))\r\nreturn GPIOF_DIR_OUT;\r\nif (!(value & BYT_INPUT_EN))\r\nreturn GPIOF_DIR_IN;\r\nreturn -EINVAL;\r\n}\r\nstatic int byt_gpio_direction_input(struct gpio_chip *chip, unsigned int offset)\r\n{\r\nreturn pinctrl_gpio_direction_input(chip->base + offset);\r\n}\r\nstatic int byt_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned int offset, int value)\r\n{\r\nint ret = pinctrl_gpio_direction_output(chip->base + offset);\r\nif (ret)\r\nreturn ret;\r\nbyt_gpio_set(chip, offset, value);\r\nreturn 0;\r\n}\r\nstatic void byt_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)\r\n{\r\nstruct byt_gpio *vg = gpiochip_get_data(chip);\r\nint i;\r\nu32 conf0, val;\r\nfor (i = 0; i < vg->soc_data->npins; i++) {\r\nconst struct byt_community *comm;\r\nconst char *pull_str = NULL;\r\nconst char *pull = NULL;\r\nvoid __iomem *reg;\r\nunsigned long flags;\r\nconst char *label;\r\nunsigned int pin;\r\nraw_spin_lock_irqsave(&vg->lock, flags);\r\npin = vg->soc_data->pins[i].number;\r\nreg = byt_gpio_reg(vg, pin, BYT_CONF0_REG);\r\nif (!reg) {\r\nseq_printf(s,\r\n"Could not retrieve pin %i conf0 reg\n",\r\npin);\r\nraw_spin_unlock_irqrestore(&vg->lock, flags);\r\ncontinue;\r\n}\r\nconf0 = readl(reg);\r\nreg = byt_gpio_reg(vg, pin, BYT_VAL_REG);\r\nif (!reg) {\r\nseq_printf(s,\r\n"Could not retrieve pin %i val reg\n", pin);\r\nraw_spin_unlock_irqrestore(&vg->lock, flags);\r\ncontinue;\r\n}\r\nval = readl(reg);\r\nraw_spin_unlock_irqrestore(&vg->lock, flags);\r\ncomm = byt_get_community(vg, pin);\r\nif (!comm) {\r\nseq_printf(s,\r\n"Could not get community for pin %i\n", pin);\r\ncontinue;\r\n}\r\nlabel = gpiochip_is_requested(chip, i);\r\nif (!label)\r\nlabel = "Unrequested";\r\nswitch (conf0 & BYT_PULL_ASSIGN_MASK) {\r\ncase BYT_PULL_ASSIGN_UP:\r\npull = "up";\r\nbreak;\r\ncase BYT_PULL_ASSIGN_DOWN:\r\npull = "down";\r\nbreak;\r\n}\r\nswitch (conf0 & BYT_PULL_STR_MASK) {\r\ncase BYT_PULL_STR_2K:\r\npull_str = "2k";\r\nbreak;\r\ncase BYT_PULL_STR_10K:\r\npull_str = "10k";\r\nbreak;\r\ncase BYT_PULL_STR_20K:\r\npull_str = "20k";\r\nbreak;\r\ncase BYT_PULL_STR_40K:\r\npull_str = "40k";\r\nbreak;\r\n}\r\nseq_printf(s,\r\n" gpio-%-3d (%-20.20s) %s %s %s pad-%-3d offset:0x%03x mux:%d %s%s%s",\r\npin,\r\nlabel,\r\nval & BYT_INPUT_EN ? " " : "in",\r\nval & BYT_OUTPUT_EN ? " " : "out",\r\nval & BYT_LEVEL ? "hi" : "lo",\r\ncomm->pad_map[i], comm->pad_map[i] * 16,\r\nconf0 & 0x7,\r\nconf0 & BYT_TRIG_NEG ? " fall" : " ",\r\nconf0 & BYT_TRIG_POS ? " rise" : " ",\r\nconf0 & BYT_TRIG_LVL ? " level" : " ");\r\nif (pull && pull_str)\r\nseq_printf(s, " %-4s %-3s", pull, pull_str);\r\nelse\r\nseq_puts(s, " ");\r\nif (conf0 & BYT_IODEN)\r\nseq_puts(s, " open-drain");\r\nseq_puts(s, "\n");\r\n}\r\n}\r\nstatic void byt_irq_ack(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct byt_gpio *vg = gpiochip_get_data(gc);\r\nunsigned offset = irqd_to_hwirq(d);\r\nvoid __iomem *reg;\r\nreg = byt_gpio_reg(vg, offset, BYT_INT_STAT_REG);\r\nif (!reg)\r\nreturn;\r\nraw_spin_lock(&vg->lock);\r\nwritel(BIT(offset % 32), reg);\r\nraw_spin_unlock(&vg->lock);\r\n}\r\nstatic void byt_irq_mask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct byt_gpio *vg = gpiochip_get_data(gc);\r\nbyt_gpio_clear_triggering(vg, irqd_to_hwirq(d));\r\n}\r\nstatic void byt_irq_unmask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct byt_gpio *vg = gpiochip_get_data(gc);\r\nunsigned offset = irqd_to_hwirq(d);\r\nunsigned long flags;\r\nvoid __iomem *reg;\r\nu32 value;\r\nreg = byt_gpio_reg(vg, offset, BYT_CONF0_REG);\r\nif (!reg)\r\nreturn;\r\nraw_spin_lock_irqsave(&vg->lock, flags);\r\nvalue = readl(reg);\r\nswitch (irqd_get_trigger_type(d)) {\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nvalue |= BYT_TRIG_LVL;\r\ncase IRQ_TYPE_EDGE_RISING:\r\nvalue |= BYT_TRIG_POS;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nvalue |= BYT_TRIG_LVL;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nvalue |= BYT_TRIG_NEG;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nvalue |= (BYT_TRIG_NEG | BYT_TRIG_POS);\r\nbreak;\r\n}\r\nwritel(value, reg);\r\nraw_spin_unlock_irqrestore(&vg->lock, flags);\r\n}\r\nstatic int byt_irq_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct byt_gpio *vg = gpiochip_get_data(irq_data_get_irq_chip_data(d));\r\nu32 offset = irqd_to_hwirq(d);\r\nu32 value;\r\nunsigned long flags;\r\nvoid __iomem *reg = byt_gpio_reg(vg, offset, BYT_CONF0_REG);\r\nif (!reg || offset >= vg->chip.ngpio)\r\nreturn -EINVAL;\r\nraw_spin_lock_irqsave(&vg->lock, flags);\r\nvalue = readl(reg);\r\nWARN(value & BYT_DIRECT_IRQ_EN,\r\n"Bad pad config for io mode, force direct_irq_en bit clearing");\r\nvalue &= ~(BYT_DIRECT_IRQ_EN | BYT_TRIG_POS | BYT_TRIG_NEG |\r\nBYT_TRIG_LVL);\r\nwritel(value, reg);\r\nif (type & IRQ_TYPE_EDGE_BOTH)\r\nirq_set_handler_locked(d, handle_edge_irq);\r\nelse if (type & IRQ_TYPE_LEVEL_MASK)\r\nirq_set_handler_locked(d, handle_level_irq);\r\nraw_spin_unlock_irqrestore(&vg->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void byt_gpio_irq_handler(struct irq_desc *desc)\r\n{\r\nstruct irq_data *data = irq_desc_get_irq_data(desc);\r\nstruct byt_gpio *vg = gpiochip_get_data(\r\nirq_desc_get_handler_data(desc));\r\nstruct irq_chip *chip = irq_data_get_irq_chip(data);\r\nu32 base, pin;\r\nvoid __iomem *reg;\r\nunsigned long pending;\r\nunsigned int virq;\r\nfor (base = 0; base < vg->chip.ngpio; base += 32) {\r\nreg = byt_gpio_reg(vg, base, BYT_INT_STAT_REG);\r\nif (!reg) {\r\ndev_warn(&vg->pdev->dev,\r\n"Pin %i: could not retrieve interrupt status register\n",\r\nbase);\r\ncontinue;\r\n}\r\nraw_spin_lock(&vg->lock);\r\npending = readl(reg);\r\nraw_spin_unlock(&vg->lock);\r\nfor_each_set_bit(pin, &pending, 32) {\r\nvirq = irq_find_mapping(vg->chip.irqdomain, base + pin);\r\ngeneric_handle_irq(virq);\r\n}\r\n}\r\nchip->irq_eoi(data);\r\n}\r\nstatic void byt_gpio_irq_init_hw(struct byt_gpio *vg)\r\n{\r\nstruct gpio_chip *gc = &vg->chip;\r\nstruct device *dev = &vg->pdev->dev;\r\nvoid __iomem *reg;\r\nu32 base, value;\r\nint i;\r\nfor (i = 0; i < vg->soc_data->npins; i++) {\r\nunsigned int pin = vg->soc_data->pins[i].number;\r\nreg = byt_gpio_reg(vg, pin, BYT_CONF0_REG);\r\nif (!reg) {\r\ndev_warn(&vg->pdev->dev,\r\n"Pin %i: could not retrieve conf0 register\n",\r\ni);\r\ncontinue;\r\n}\r\nvalue = readl(reg);\r\nif (value & BYT_DIRECT_IRQ_EN) {\r\nclear_bit(i, gc->irq_valid_mask);\r\ndev_dbg(dev, "excluding GPIO %d from IRQ domain\n", i);\r\n} else if ((value & BYT_PIN_MUX) == byt_get_gpio_mux(vg, i)) {\r\nbyt_gpio_clear_triggering(vg, i);\r\ndev_dbg(dev, "disabling GPIO %d\n", i);\r\n}\r\n}\r\nfor (base = 0; base < vg->soc_data->npins; base += 32) {\r\nreg = byt_gpio_reg(vg, base, BYT_INT_STAT_REG);\r\nif (!reg) {\r\ndev_warn(&vg->pdev->dev,\r\n"Pin %i: could not retrieve irq status reg\n",\r\nbase);\r\ncontinue;\r\n}\r\nwritel(0xffffffff, reg);\r\nvalue = readl(reg);\r\nif (value)\r\ndev_err(&vg->pdev->dev,\r\n"GPIO interrupt error, pins misconfigured\n");\r\n}\r\n}\r\nstatic int byt_gpio_probe(struct byt_gpio *vg)\r\n{\r\nstruct gpio_chip *gc;\r\nstruct resource *irq_rc;\r\nint ret;\r\nvg->chip = byt_gpio_chip;\r\ngc = &vg->chip;\r\ngc->label = dev_name(&vg->pdev->dev);\r\ngc->base = -1;\r\ngc->can_sleep = false;\r\ngc->parent = &vg->pdev->dev;\r\ngc->ngpio = vg->soc_data->npins;\r\ngc->irq_need_valid_mask = true;\r\n#ifdef CONFIG_PM_SLEEP\r\nvg->saved_context = devm_kcalloc(&vg->pdev->dev, gc->ngpio,\r\nsizeof(*vg->saved_context), GFP_KERNEL);\r\n#endif\r\nret = devm_gpiochip_add_data(&vg->pdev->dev, gc, vg);\r\nif (ret) {\r\ndev_err(&vg->pdev->dev, "failed adding byt-gpio chip\n");\r\nreturn ret;\r\n}\r\nret = gpiochip_add_pin_range(&vg->chip, dev_name(&vg->pdev->dev),\r\n0, 0, vg->soc_data->npins);\r\nif (ret) {\r\ndev_err(&vg->pdev->dev, "failed to add GPIO pin range\n");\r\nreturn ret;\r\n}\r\nirq_rc = platform_get_resource(vg->pdev, IORESOURCE_IRQ, 0);\r\nif (irq_rc && irq_rc->start) {\r\nbyt_gpio_irq_init_hw(vg);\r\nret = gpiochip_irqchip_add(gc, &byt_irqchip, 0,\r\nhandle_bad_irq, IRQ_TYPE_NONE);\r\nif (ret) {\r\ndev_err(&vg->pdev->dev, "failed to add irqchip\n");\r\nreturn ret;\r\n}\r\ngpiochip_set_chained_irqchip(gc, &byt_irqchip,\r\n(unsigned)irq_rc->start,\r\nbyt_gpio_irq_handler);\r\n}\r\nreturn ret;\r\n}\r\nstatic int byt_set_soc_data(struct byt_gpio *vg,\r\nconst struct byt_pinctrl_soc_data *soc_data)\r\n{\r\nint i;\r\nvg->soc_data = soc_data;\r\nvg->communities_copy = devm_kcalloc(&vg->pdev->dev,\r\nsoc_data->ncommunities,\r\nsizeof(*vg->communities_copy),\r\nGFP_KERNEL);\r\nif (!vg->communities_copy)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < soc_data->ncommunities; i++) {\r\nstruct byt_community *comm = vg->communities_copy + i;\r\nstruct resource *mem_rc;\r\n*comm = vg->soc_data->communities[i];\r\nmem_rc = platform_get_resource(vg->pdev, IORESOURCE_MEM, 0);\r\ncomm->reg_base = devm_ioremap_resource(&vg->pdev->dev, mem_rc);\r\nif (IS_ERR(comm->reg_base))\r\nreturn PTR_ERR(comm->reg_base);\r\n}\r\nreturn 0;\r\n}\r\nstatic int byt_pinctrl_probe(struct platform_device *pdev)\r\n{\r\nconst struct byt_pinctrl_soc_data *soc_data = NULL;\r\nconst struct byt_pinctrl_soc_data **soc_table;\r\nconst struct acpi_device_id *acpi_id;\r\nstruct acpi_device *acpi_dev;\r\nstruct byt_gpio *vg;\r\nint i, ret;\r\nacpi_dev = ACPI_COMPANION(&pdev->dev);\r\nif (!acpi_dev)\r\nreturn -ENODEV;\r\nacpi_id = acpi_match_device(byt_gpio_acpi_match, &pdev->dev);\r\nif (!acpi_id)\r\nreturn -ENODEV;\r\nsoc_table = (const struct byt_pinctrl_soc_data **)acpi_id->driver_data;\r\nfor (i = 0; soc_table[i]; i++) {\r\nif (!strcmp(acpi_dev->pnp.unique_id, soc_table[i]->uid)) {\r\nsoc_data = soc_table[i];\r\nbreak;\r\n}\r\n}\r\nif (!soc_data)\r\nreturn -ENODEV;\r\nvg = devm_kzalloc(&pdev->dev, sizeof(*vg), GFP_KERNEL);\r\nif (!vg)\r\nreturn -ENOMEM;\r\nvg->pdev = pdev;\r\nret = byt_set_soc_data(vg, soc_data);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to set soc data\n");\r\nreturn ret;\r\n}\r\nvg->pctl_desc = byt_pinctrl_desc;\r\nvg->pctl_desc.name = dev_name(&pdev->dev);\r\nvg->pctl_desc.pins = vg->soc_data->pins;\r\nvg->pctl_desc.npins = vg->soc_data->npins;\r\nvg->pctl_dev = devm_pinctrl_register(&pdev->dev, &vg->pctl_desc, vg);\r\nif (IS_ERR(vg->pctl_dev)) {\r\ndev_err(&pdev->dev, "failed to register pinctrl driver\n");\r\nreturn PTR_ERR(vg->pctl_dev);\r\n}\r\nraw_spin_lock_init(&vg->lock);\r\nret = byt_gpio_probe(vg);\r\nif (ret)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, vg);\r\npm_runtime_enable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int byt_gpio_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct byt_gpio *vg = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < vg->soc_data->npins; i++) {\r\nvoid __iomem *reg;\r\nu32 value;\r\nunsigned int pin = vg->soc_data->pins[i].number;\r\nreg = byt_gpio_reg(vg, pin, BYT_CONF0_REG);\r\nif (!reg) {\r\ndev_warn(&vg->pdev->dev,\r\n"Pin %i: could not retrieve conf0 register\n",\r\ni);\r\ncontinue;\r\n}\r\nvalue = readl(reg) & BYT_CONF0_RESTORE_MASK;\r\nvg->saved_context[i].conf0 = value;\r\nreg = byt_gpio_reg(vg, pin, BYT_VAL_REG);\r\nvalue = readl(reg) & BYT_VAL_RESTORE_MASK;\r\nvg->saved_context[i].val = value;\r\n}\r\nreturn 0;\r\n}\r\nstatic int byt_gpio_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct byt_gpio *vg = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < vg->soc_data->npins; i++) {\r\nvoid __iomem *reg;\r\nu32 value;\r\nunsigned int pin = vg->soc_data->pins[i].number;\r\nreg = byt_gpio_reg(vg, pin, BYT_CONF0_REG);\r\nif (!reg) {\r\ndev_warn(&vg->pdev->dev,\r\n"Pin %i: could not retrieve conf0 register\n",\r\ni);\r\ncontinue;\r\n}\r\nvalue = readl(reg);\r\nif ((value & BYT_CONF0_RESTORE_MASK) !=\r\nvg->saved_context[i].conf0) {\r\nvalue &= ~BYT_CONF0_RESTORE_MASK;\r\nvalue |= vg->saved_context[i].conf0;\r\nwritel(value, reg);\r\ndev_info(dev, "restored pin %d conf0 %#08x", i, value);\r\n}\r\nreg = byt_gpio_reg(vg, pin, BYT_VAL_REG);\r\nvalue = readl(reg);\r\nif ((value & BYT_VAL_RESTORE_MASK) !=\r\nvg->saved_context[i].val) {\r\nu32 v;\r\nv = value & ~BYT_VAL_RESTORE_MASK;\r\nv |= vg->saved_context[i].val;\r\nif (v != value) {\r\nwritel(v, reg);\r\ndev_dbg(dev, "restored pin %d val %#08x\n",\r\ni, v);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int byt_gpio_runtime_suspend(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int byt_gpio_runtime_resume(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init byt_gpio_init(void)\r\n{\r\nreturn platform_driver_register(&byt_gpio_driver);\r\n}
