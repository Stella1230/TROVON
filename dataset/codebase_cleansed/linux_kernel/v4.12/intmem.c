static void crisv32_intmem_init(void)\r\n{\r\nstatic int initiated = 0;\r\nif (!initiated) {\r\nstruct intmem_allocation* alloc;\r\nalloc = kmalloc(sizeof *alloc, GFP_KERNEL);\r\nINIT_LIST_HEAD(&intmem_allocations);\r\nintmem_virtual = ioremap(MEM_INTMEM_START + RESERVED_SIZE,\r\nMEM_INTMEM_SIZE - RESERVED_SIZE);\r\ninitiated = 1;\r\nalloc->size = MEM_INTMEM_SIZE - RESERVED_SIZE;\r\nalloc->offset = 0;\r\nalloc->status = STATUS_FREE;\r\nlist_add_tail(&alloc->entry, &intmem_allocations);\r\n}\r\n}\r\nvoid* crisv32_intmem_alloc(unsigned size, unsigned align)\r\n{\r\nstruct intmem_allocation* allocation;\r\nstruct intmem_allocation* tmp;\r\nvoid* ret = NULL;\r\npreempt_disable();\r\ncrisv32_intmem_init();\r\nlist_for_each_entry_safe(allocation, tmp, &intmem_allocations, entry) {\r\nint alignment = allocation->offset % align;\r\nalignment = alignment ? align - alignment : alignment;\r\nif (allocation->status == STATUS_FREE &&\r\nallocation->size >= size + alignment) {\r\nif (allocation->size > size + alignment) {\r\nstruct intmem_allocation* alloc;\r\nalloc = kmalloc(sizeof *alloc, GFP_ATOMIC);\r\nalloc->status = STATUS_FREE;\r\nalloc->size = allocation->size - size -\r\nalignment;\r\nalloc->offset = allocation->offset + size +\r\nalignment;\r\nlist_add(&alloc->entry, &allocation->entry);\r\nif (alignment) {\r\nstruct intmem_allocation *tmp;\r\ntmp = kmalloc(sizeof *tmp, GFP_ATOMIC);\r\ntmp->offset = allocation->offset;\r\ntmp->size = alignment;\r\ntmp->status = STATUS_FREE;\r\nallocation->offset += alignment;\r\nlist_add_tail(&tmp->entry,\r\n&allocation->entry);\r\n}\r\n}\r\nallocation->status = STATUS_ALLOCATED;\r\nallocation->size = size;\r\nret = (void*)((int)intmem_virtual + allocation->offset);\r\n}\r\n}\r\npreempt_enable();\r\nreturn ret;\r\n}\r\nvoid crisv32_intmem_free(void* addr)\r\n{\r\nstruct intmem_allocation* allocation;\r\nstruct intmem_allocation* tmp;\r\nif (addr == NULL)\r\nreturn;\r\npreempt_disable();\r\ncrisv32_intmem_init();\r\nlist_for_each_entry_safe(allocation, tmp, &intmem_allocations, entry) {\r\nif (allocation->offset == (int)(addr - intmem_virtual)) {\r\nstruct intmem_allocation *prev =\r\nlist_entry(allocation->entry.prev,\r\nstruct intmem_allocation, entry);\r\nstruct intmem_allocation *next =\r\nlist_entry(allocation->entry.next,\r\nstruct intmem_allocation, entry);\r\nallocation->status = STATUS_FREE;\r\nif ((&prev->entry != &intmem_allocations) &&\r\n(prev->status == STATUS_FREE)) {\r\nprev->size += allocation->size;\r\nlist_del(&allocation->entry);\r\nkfree(allocation);\r\nallocation = prev;\r\n}\r\nif ((&next->entry != &intmem_allocations) &&\r\n(next->status == STATUS_FREE)) {\r\nallocation->size += next->size;\r\nlist_del(&next->entry);\r\nkfree(next);\r\n}\r\npreempt_enable();\r\nreturn;\r\n}\r\n}\r\npreempt_enable();\r\n}\r\nvoid* crisv32_intmem_phys_to_virt(unsigned long addr)\r\n{\r\nreturn (void *)(addr - (MEM_INTMEM_START + RESERVED_SIZE) +\r\n(unsigned long)intmem_virtual);\r\n}\r\nunsigned long crisv32_intmem_virt_to_phys(void* addr)\r\n{\r\nreturn (unsigned long)((unsigned long )addr -\r\n(unsigned long)intmem_virtual + MEM_INTMEM_START +\r\nRESERVED_SIZE);\r\n}\r\nstatic int __init crisv32_intmem_setup(void)\r\n{\r\ncrisv32_intmem_init();\r\nreturn 0;\r\n}
