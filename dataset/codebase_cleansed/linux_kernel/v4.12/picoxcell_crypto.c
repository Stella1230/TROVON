static inline struct spacc_alg *to_spacc_alg(struct crypto_alg *alg)\r\n{\r\nreturn alg ? container_of(alg, struct spacc_alg, alg) : NULL;\r\n}\r\nstatic inline struct spacc_aead *to_spacc_aead(struct aead_alg *alg)\r\n{\r\nreturn container_of(alg, struct spacc_aead, alg);\r\n}\r\nstatic inline int spacc_fifo_cmd_full(struct spacc_engine *engine)\r\n{\r\nu32 fifo_stat = readl(engine->regs + SPA_FIFO_STAT_REG_OFFSET);\r\nreturn fifo_stat & SPA_FIFO_CMD_FULL;\r\n}\r\nstatic inline void __iomem *spacc_ctx_page_addr(struct spacc_generic_ctx *ctx,\r\nunsigned indx,\r\nbool is_cipher_ctx)\r\n{\r\nreturn is_cipher_ctx ? ctx->engine->cipher_ctx_base +\r\n(indx * ctx->engine->cipher_pg_sz) :\r\nctx->engine->hash_key_base + (indx * ctx->engine->hash_pg_sz);\r\n}\r\nstatic inline void memcpy_toio32(u32 __iomem *dst, const void *src,\r\nunsigned count)\r\n{\r\nconst u32 *src32 = (const u32 *) src;\r\nwhile (count--)\r\nwritel(*src32++, dst++);\r\n}\r\nstatic void spacc_cipher_write_ctx(struct spacc_generic_ctx *ctx,\r\nvoid __iomem *page_addr, const u8 *key,\r\nsize_t key_len, const u8 *iv, size_t iv_len)\r\n{\r\nvoid __iomem *key_ptr = page_addr + ctx->key_offs;\r\nvoid __iomem *iv_ptr = page_addr + ctx->iv_offs;\r\nmemcpy_toio32(key_ptr, key, key_len / 4);\r\nmemcpy_toio32(iv_ptr, iv, iv_len / 4);\r\n}\r\nstatic unsigned spacc_load_ctx(struct spacc_generic_ctx *ctx,\r\nconst u8 *ciph_key, size_t ciph_len,\r\nconst u8 *iv, size_t ivlen, const u8 *hash_key,\r\nsize_t hash_len)\r\n{\r\nunsigned indx = ctx->engine->next_ctx++;\r\nvoid __iomem *ciph_page_addr, *hash_page_addr;\r\nciph_page_addr = spacc_ctx_page_addr(ctx, indx, 1);\r\nhash_page_addr = spacc_ctx_page_addr(ctx, indx, 0);\r\nctx->engine->next_ctx &= ctx->engine->fifo_sz - 1;\r\nspacc_cipher_write_ctx(ctx, ciph_page_addr, ciph_key, ciph_len, iv,\r\nivlen);\r\nwritel(ciph_len | (indx << SPA_KEY_SZ_CTX_INDEX_OFFSET) |\r\n(1 << SPA_KEY_SZ_CIPHER_OFFSET),\r\nctx->engine->regs + SPA_KEY_SZ_REG_OFFSET);\r\nif (hash_key) {\r\nmemcpy_toio32(hash_page_addr, hash_key, hash_len / 4);\r\nwritel(hash_len | (indx << SPA_KEY_SZ_CTX_INDEX_OFFSET),\r\nctx->engine->regs + SPA_KEY_SZ_REG_OFFSET);\r\n}\r\nreturn indx;\r\n}\r\nstatic inline void ddt_set(struct spacc_ddt *ddt, dma_addr_t phys, size_t len)\r\n{\r\nddt->p = phys;\r\nddt->len = len;\r\n}\r\nstatic struct spacc_ddt *spacc_sg_to_ddt(struct spacc_engine *engine,\r\nstruct scatterlist *payload,\r\nunsigned nbytes,\r\nenum dma_data_direction dir,\r\ndma_addr_t *ddt_phys)\r\n{\r\nunsigned mapped_ents;\r\nstruct scatterlist *cur;\r\nstruct spacc_ddt *ddt;\r\nint i;\r\nint nents;\r\nnents = sg_nents_for_len(payload, nbytes);\r\nif (nents < 0) {\r\ndev_err(engine->dev, "Invalid numbers of SG.\n");\r\nreturn NULL;\r\n}\r\nmapped_ents = dma_map_sg(engine->dev, payload, nents, dir);\r\nif (mapped_ents + 1 > MAX_DDT_LEN)\r\ngoto out;\r\nddt = dma_pool_alloc(engine->req_pool, GFP_ATOMIC, ddt_phys);\r\nif (!ddt)\r\ngoto out;\r\nfor_each_sg(payload, cur, mapped_ents, i)\r\nddt_set(&ddt[i], sg_dma_address(cur), sg_dma_len(cur));\r\nddt_set(&ddt[mapped_ents], 0, 0);\r\nreturn ddt;\r\nout:\r\ndma_unmap_sg(engine->dev, payload, nents, dir);\r\nreturn NULL;\r\n}\r\nstatic int spacc_aead_make_ddts(struct aead_request *areq)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(areq);\r\nstruct spacc_req *req = aead_request_ctx(areq);\r\nstruct spacc_engine *engine = req->engine;\r\nstruct spacc_ddt *src_ddt, *dst_ddt;\r\nunsigned total;\r\nint src_nents, dst_nents;\r\nstruct scatterlist *cur;\r\nint i, dst_ents, src_ents;\r\ntotal = areq->assoclen + areq->cryptlen;\r\nif (req->is_encrypt)\r\ntotal += crypto_aead_authsize(aead);\r\nsrc_nents = sg_nents_for_len(areq->src, total);\r\nif (src_nents < 0) {\r\ndev_err(engine->dev, "Invalid numbers of src SG.\n");\r\nreturn src_nents;\r\n}\r\nif (src_nents + 1 > MAX_DDT_LEN)\r\nreturn -E2BIG;\r\ndst_nents = 0;\r\nif (areq->src != areq->dst) {\r\ndst_nents = sg_nents_for_len(areq->dst, total);\r\nif (dst_nents < 0) {\r\ndev_err(engine->dev, "Invalid numbers of dst SG.\n");\r\nreturn dst_nents;\r\n}\r\nif (src_nents + 1 > MAX_DDT_LEN)\r\nreturn -E2BIG;\r\n}\r\nsrc_ddt = dma_pool_alloc(engine->req_pool, GFP_ATOMIC, &req->src_addr);\r\nif (!src_ddt)\r\ngoto err;\r\ndst_ddt = dma_pool_alloc(engine->req_pool, GFP_ATOMIC, &req->dst_addr);\r\nif (!dst_ddt)\r\ngoto err_free_src;\r\nreq->src_ddt = src_ddt;\r\nreq->dst_ddt = dst_ddt;\r\nif (dst_nents) {\r\nsrc_ents = dma_map_sg(engine->dev, areq->src, src_nents,\r\nDMA_TO_DEVICE);\r\nif (!src_ents)\r\ngoto err_free_dst;\r\ndst_ents = dma_map_sg(engine->dev, areq->dst, dst_nents,\r\nDMA_FROM_DEVICE);\r\nif (!dst_ents) {\r\ndma_unmap_sg(engine->dev, areq->src, src_nents,\r\nDMA_TO_DEVICE);\r\ngoto err_free_dst;\r\n}\r\n} else {\r\nsrc_ents = dma_map_sg(engine->dev, areq->src, src_nents,\r\nDMA_BIDIRECTIONAL);\r\nif (!src_ents)\r\ngoto err_free_dst;\r\ndst_ents = src_ents;\r\n}\r\nfor_each_sg(areq->src, cur, src_ents, i)\r\nddt_set(src_ddt++, sg_dma_address(cur), sg_dma_len(cur));\r\ntotal = req->is_encrypt ? 0 : areq->assoclen;\r\nfor_each_sg(areq->dst, cur, dst_ents, i) {\r\nunsigned len = sg_dma_len(cur);\r\nif (len <= total) {\r\ntotal -= len;\r\ncontinue;\r\n}\r\nddt_set(dst_ddt++, sg_dma_address(cur) + total, len - total);\r\n}\r\nddt_set(src_ddt, 0, 0);\r\nddt_set(dst_ddt, 0, 0);\r\nreturn 0;\r\nerr_free_dst:\r\ndma_pool_free(engine->req_pool, dst_ddt, req->dst_addr);\r\nerr_free_src:\r\ndma_pool_free(engine->req_pool, src_ddt, req->src_addr);\r\nerr:\r\nreturn -ENOMEM;\r\n}\r\nstatic void spacc_aead_free_ddts(struct spacc_req *req)\r\n{\r\nstruct aead_request *areq = container_of(req->req, struct aead_request,\r\nbase);\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(areq);\r\nunsigned total = areq->assoclen + areq->cryptlen +\r\n(req->is_encrypt ? crypto_aead_authsize(aead) : 0);\r\nstruct spacc_aead_ctx *aead_ctx = crypto_aead_ctx(aead);\r\nstruct spacc_engine *engine = aead_ctx->generic.engine;\r\nint nents = sg_nents_for_len(areq->src, total);\r\nif (unlikely(nents < 0)) {\r\ndev_err(engine->dev, "Invalid numbers of src SG.\n");\r\nreturn;\r\n}\r\nif (areq->src != areq->dst) {\r\ndma_unmap_sg(engine->dev, areq->src, nents, DMA_TO_DEVICE);\r\nnents = sg_nents_for_len(areq->dst, total);\r\nif (unlikely(nents < 0)) {\r\ndev_err(engine->dev, "Invalid numbers of dst SG.\n");\r\nreturn;\r\n}\r\ndma_unmap_sg(engine->dev, areq->dst, nents, DMA_FROM_DEVICE);\r\n} else\r\ndma_unmap_sg(engine->dev, areq->src, nents, DMA_BIDIRECTIONAL);\r\ndma_pool_free(engine->req_pool, req->src_ddt, req->src_addr);\r\ndma_pool_free(engine->req_pool, req->dst_ddt, req->dst_addr);\r\n}\r\nstatic void spacc_free_ddt(struct spacc_req *req, struct spacc_ddt *ddt,\r\ndma_addr_t ddt_addr, struct scatterlist *payload,\r\nunsigned nbytes, enum dma_data_direction dir)\r\n{\r\nint nents = sg_nents_for_len(payload, nbytes);\r\nif (nents < 0) {\r\ndev_err(req->engine->dev, "Invalid numbers of SG.\n");\r\nreturn;\r\n}\r\ndma_unmap_sg(req->engine->dev, payload, nents, dir);\r\ndma_pool_free(req->engine->req_pool, ddt, ddt_addr);\r\n}\r\nstatic int spacc_aead_setkey(struct crypto_aead *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct spacc_aead_ctx *ctx = crypto_aead_ctx(tfm);\r\nstruct crypto_authenc_keys keys;\r\nint err;\r\ncrypto_aead_clear_flags(ctx->sw_cipher, CRYPTO_TFM_REQ_MASK);\r\ncrypto_aead_set_flags(ctx->sw_cipher, crypto_aead_get_flags(tfm) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_aead_setkey(ctx->sw_cipher, key, keylen);\r\ncrypto_aead_clear_flags(tfm, CRYPTO_TFM_RES_MASK);\r\ncrypto_aead_set_flags(tfm, crypto_aead_get_flags(ctx->sw_cipher) &\r\nCRYPTO_TFM_RES_MASK);\r\nif (err)\r\nreturn err;\r\nif (crypto_authenc_extractkeys(&keys, key, keylen) != 0)\r\ngoto badkey;\r\nif (keys.enckeylen > AES_MAX_KEY_SIZE)\r\ngoto badkey;\r\nif (keys.authkeylen > sizeof(ctx->hash_ctx))\r\ngoto badkey;\r\nmemcpy(ctx->cipher_key, keys.enckey, keys.enckeylen);\r\nctx->cipher_key_len = keys.enckeylen;\r\nmemcpy(ctx->hash_ctx, keys.authkey, keys.authkeylen);\r\nctx->hash_key_len = keys.authkeylen;\r\nreturn 0;\r\nbadkey:\r\ncrypto_aead_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn -EINVAL;\r\n}\r\nstatic int spacc_aead_setauthsize(struct crypto_aead *tfm,\r\nunsigned int authsize)\r\n{\r\nstruct spacc_aead_ctx *ctx = crypto_tfm_ctx(crypto_aead_tfm(tfm));\r\nreturn crypto_aead_setauthsize(ctx->sw_cipher, authsize);\r\n}\r\nstatic int spacc_aead_need_fallback(struct aead_request *aead_req)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(aead_req);\r\nstruct aead_alg *alg = crypto_aead_alg(aead);\r\nstruct spacc_aead *spacc_alg = to_spacc_aead(alg);\r\nstruct spacc_aead_ctx *ctx = crypto_aead_ctx(aead);\r\nif ((spacc_alg->ctrl_default & SPACC_CRYPTO_ALG_MASK) ==\r\nSPA_CTRL_CIPH_ALG_AES &&\r\nctx->cipher_key_len != AES_KEYSIZE_128 &&\r\nctx->cipher_key_len != AES_KEYSIZE_256)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int spacc_aead_do_fallback(struct aead_request *req, unsigned alg_type,\r\nbool is_encrypt)\r\n{\r\nstruct crypto_tfm *old_tfm = crypto_aead_tfm(crypto_aead_reqtfm(req));\r\nstruct spacc_aead_ctx *ctx = crypto_tfm_ctx(old_tfm);\r\nstruct aead_request *subreq = aead_request_ctx(req);\r\naead_request_set_tfm(subreq, ctx->sw_cipher);\r\naead_request_set_callback(subreq, req->base.flags,\r\nreq->base.complete, req->base.data);\r\naead_request_set_crypt(subreq, req->src, req->dst, req->cryptlen,\r\nreq->iv);\r\naead_request_set_ad(subreq, req->assoclen);\r\nreturn is_encrypt ? crypto_aead_encrypt(subreq) :\r\ncrypto_aead_decrypt(subreq);\r\n}\r\nstatic void spacc_aead_complete(struct spacc_req *req)\r\n{\r\nspacc_aead_free_ddts(req);\r\nreq->req->complete(req->req, req->result);\r\n}\r\nstatic int spacc_aead_submit(struct spacc_req *req)\r\n{\r\nstruct aead_request *aead_req =\r\ncontainer_of(req->req, struct aead_request, base);\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(aead_req);\r\nunsigned int authsize = crypto_aead_authsize(aead);\r\nstruct spacc_aead_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct aead_alg *alg = crypto_aead_alg(aead);\r\nstruct spacc_aead *spacc_alg = to_spacc_aead(alg);\r\nstruct spacc_engine *engine = ctx->generic.engine;\r\nu32 ctrl, proc_len, assoc_len;\r\nreq->result = -EINPROGRESS;\r\nreq->ctx_id = spacc_load_ctx(&ctx->generic, ctx->cipher_key,\r\nctx->cipher_key_len, aead_req->iv, crypto_aead_ivsize(aead),\r\nctx->hash_ctx, ctx->hash_key_len);\r\nwritel(req->src_addr, engine->regs + SPA_SRC_PTR_REG_OFFSET);\r\nwritel(req->dst_addr, engine->regs + SPA_DST_PTR_REG_OFFSET);\r\nwritel(0, engine->regs + SPA_OFFSET_REG_OFFSET);\r\nassoc_len = aead_req->assoclen;\r\nproc_len = aead_req->cryptlen + assoc_len;\r\nif (!req->is_encrypt)\r\nproc_len -= authsize;\r\nwritel(proc_len, engine->regs + SPA_PROC_LEN_REG_OFFSET);\r\nwritel(assoc_len, engine->regs + SPA_AAD_LEN_REG_OFFSET);\r\nwritel(authsize, engine->regs + SPA_ICV_LEN_REG_OFFSET);\r\nwritel(0, engine->regs + SPA_ICV_OFFSET_REG_OFFSET);\r\nwritel(0, engine->regs + SPA_AUX_INFO_REG_OFFSET);\r\nctrl = spacc_alg->ctrl_default | (req->ctx_id << SPA_CTRL_CTX_IDX) |\r\n(1 << SPA_CTRL_ICV_APPEND);\r\nif (req->is_encrypt)\r\nctrl |= (1 << SPA_CTRL_ENCRYPT_IDX) | (1 << SPA_CTRL_AAD_COPY);\r\nelse\r\nctrl |= (1 << SPA_CTRL_KEY_EXP);\r\nmod_timer(&engine->packet_timeout, jiffies + PACKET_TIMEOUT);\r\nwritel(ctrl, engine->regs + SPA_CTRL_REG_OFFSET);\r\nreturn -EINPROGRESS;\r\n}\r\nstatic void spacc_push(struct spacc_engine *engine)\r\n{\r\nstruct spacc_req *req;\r\nwhile (!list_empty(&engine->pending) &&\r\nengine->in_flight + 1 <= engine->fifo_sz) {\r\n++engine->in_flight;\r\nreq = list_first_entry(&engine->pending, struct spacc_req,\r\nlist);\r\nlist_move_tail(&req->list, &engine->in_progress);\r\nreq->result = spacc_req_submit(req);\r\n}\r\n}\r\nstatic int spacc_aead_setup(struct aead_request *req,\r\nunsigned alg_type, bool is_encrypt)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct aead_alg *alg = crypto_aead_alg(aead);\r\nstruct spacc_engine *engine = to_spacc_aead(alg)->engine;\r\nstruct spacc_req *dev_req = aead_request_ctx(req);\r\nint err;\r\nunsigned long flags;\r\ndev_req->req = &req->base;\r\ndev_req->is_encrypt = is_encrypt;\r\ndev_req->result = -EBUSY;\r\ndev_req->engine = engine;\r\ndev_req->complete = spacc_aead_complete;\r\nif (unlikely(spacc_aead_need_fallback(req) ||\r\n((err = spacc_aead_make_ddts(req)) == -E2BIG)))\r\nreturn spacc_aead_do_fallback(req, alg_type, is_encrypt);\r\nif (err)\r\ngoto out;\r\nerr = -EINPROGRESS;\r\nspin_lock_irqsave(&engine->hw_lock, flags);\r\nif (unlikely(spacc_fifo_cmd_full(engine)) ||\r\nengine->in_flight + 1 > engine->fifo_sz) {\r\nif (!(req->base.flags & CRYPTO_TFM_REQ_MAY_BACKLOG)) {\r\nerr = -EBUSY;\r\nspin_unlock_irqrestore(&engine->hw_lock, flags);\r\ngoto out_free_ddts;\r\n}\r\nlist_add_tail(&dev_req->list, &engine->pending);\r\n} else {\r\nlist_add_tail(&dev_req->list, &engine->pending);\r\nspacc_push(engine);\r\n}\r\nspin_unlock_irqrestore(&engine->hw_lock, flags);\r\ngoto out;\r\nout_free_ddts:\r\nspacc_aead_free_ddts(dev_req);\r\nout:\r\nreturn err;\r\n}\r\nstatic int spacc_aead_encrypt(struct aead_request *req)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct spacc_aead *alg = to_spacc_aead(crypto_aead_alg(aead));\r\nreturn spacc_aead_setup(req, alg->type, 1);\r\n}\r\nstatic int spacc_aead_decrypt(struct aead_request *req)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct spacc_aead *alg = to_spacc_aead(crypto_aead_alg(aead));\r\nreturn spacc_aead_setup(req, alg->type, 0);\r\n}\r\nstatic int spacc_aead_cra_init(struct crypto_aead *tfm)\r\n{\r\nstruct spacc_aead_ctx *ctx = crypto_aead_ctx(tfm);\r\nstruct aead_alg *alg = crypto_aead_alg(tfm);\r\nstruct spacc_aead *spacc_alg = to_spacc_aead(alg);\r\nstruct spacc_engine *engine = spacc_alg->engine;\r\nctx->generic.flags = spacc_alg->type;\r\nctx->generic.engine = engine;\r\nctx->sw_cipher = crypto_alloc_aead(alg->base.cra_name, 0,\r\nCRYPTO_ALG_NEED_FALLBACK);\r\nif (IS_ERR(ctx->sw_cipher))\r\nreturn PTR_ERR(ctx->sw_cipher);\r\nctx->generic.key_offs = spacc_alg->key_offs;\r\nctx->generic.iv_offs = spacc_alg->iv_offs;\r\ncrypto_aead_set_reqsize(\r\ntfm,\r\nmax(sizeof(struct spacc_req),\r\nsizeof(struct aead_request) +\r\ncrypto_aead_reqsize(ctx->sw_cipher)));\r\nreturn 0;\r\n}\r\nstatic void spacc_aead_cra_exit(struct crypto_aead *tfm)\r\n{\r\nstruct spacc_aead_ctx *ctx = crypto_aead_ctx(tfm);\r\ncrypto_free_aead(ctx->sw_cipher);\r\n}\r\nstatic int spacc_des_setkey(struct crypto_ablkcipher *cipher, const u8 *key,\r\nunsigned int len)\r\n{\r\nstruct crypto_tfm *tfm = crypto_ablkcipher_tfm(cipher);\r\nstruct spacc_ablk_ctx *ctx = crypto_tfm_ctx(tfm);\r\nu32 tmp[DES_EXPKEY_WORDS];\r\nif (len > DES3_EDE_KEY_SIZE) {\r\ncrypto_ablkcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(!des_ekey(tmp, key)) &&\r\n(crypto_ablkcipher_get_flags(cipher) & CRYPTO_TFM_REQ_WEAK_KEY)) {\r\ntfm->crt_flags |= CRYPTO_TFM_RES_WEAK_KEY;\r\nreturn -EINVAL;\r\n}\r\nmemcpy(ctx->key, key, len);\r\nctx->key_len = len;\r\nreturn 0;\r\n}\r\nstatic int spacc_aes_setkey(struct crypto_ablkcipher *cipher, const u8 *key,\r\nunsigned int len)\r\n{\r\nstruct crypto_tfm *tfm = crypto_ablkcipher_tfm(cipher);\r\nstruct spacc_ablk_ctx *ctx = crypto_tfm_ctx(tfm);\r\nint err = 0;\r\nif (len > AES_MAX_KEY_SIZE) {\r\ncrypto_ablkcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn -EINVAL;\r\n}\r\nif (len != AES_KEYSIZE_128 && len != AES_KEYSIZE_256) {\r\nif (!ctx->sw_cipher)\r\nreturn -EINVAL;\r\ncrypto_skcipher_clear_flags(ctx->sw_cipher,\r\nCRYPTO_TFM_REQ_MASK);\r\ncrypto_skcipher_set_flags(ctx->sw_cipher,\r\ncipher->base.crt_flags &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_skcipher_setkey(ctx->sw_cipher, key, len);\r\ntfm->crt_flags &= ~CRYPTO_TFM_RES_MASK;\r\ntfm->crt_flags |=\r\ncrypto_skcipher_get_flags(ctx->sw_cipher) &\r\nCRYPTO_TFM_RES_MASK;\r\nif (err)\r\ngoto sw_setkey_failed;\r\n}\r\nmemcpy(ctx->key, key, len);\r\nctx->key_len = len;\r\nsw_setkey_failed:\r\nreturn err;\r\n}\r\nstatic int spacc_kasumi_f8_setkey(struct crypto_ablkcipher *cipher,\r\nconst u8 *key, unsigned int len)\r\n{\r\nstruct crypto_tfm *tfm = crypto_ablkcipher_tfm(cipher);\r\nstruct spacc_ablk_ctx *ctx = crypto_tfm_ctx(tfm);\r\nint err = 0;\r\nif (len > AES_MAX_KEY_SIZE) {\r\ncrypto_ablkcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nmemcpy(ctx->key, key, len);\r\nctx->key_len = len;\r\nout:\r\nreturn err;\r\n}\r\nstatic int spacc_ablk_need_fallback(struct spacc_req *req)\r\n{\r\nstruct spacc_ablk_ctx *ctx;\r\nstruct crypto_tfm *tfm = req->req->tfm;\r\nstruct crypto_alg *alg = req->req->tfm->__crt_alg;\r\nstruct spacc_alg *spacc_alg = to_spacc_alg(alg);\r\nctx = crypto_tfm_ctx(tfm);\r\nreturn (spacc_alg->ctrl_default & SPACC_CRYPTO_ALG_MASK) ==\r\nSPA_CTRL_CIPH_ALG_AES &&\r\nctx->key_len != AES_KEYSIZE_128 &&\r\nctx->key_len != AES_KEYSIZE_256;\r\n}\r\nstatic void spacc_ablk_complete(struct spacc_req *req)\r\n{\r\nstruct ablkcipher_request *ablk_req = ablkcipher_request_cast(req->req);\r\nif (ablk_req->src != ablk_req->dst) {\r\nspacc_free_ddt(req, req->src_ddt, req->src_addr, ablk_req->src,\r\nablk_req->nbytes, DMA_TO_DEVICE);\r\nspacc_free_ddt(req, req->dst_ddt, req->dst_addr, ablk_req->dst,\r\nablk_req->nbytes, DMA_FROM_DEVICE);\r\n} else\r\nspacc_free_ddt(req, req->dst_ddt, req->dst_addr, ablk_req->dst,\r\nablk_req->nbytes, DMA_BIDIRECTIONAL);\r\nreq->req->complete(req->req, req->result);\r\n}\r\nstatic int spacc_ablk_submit(struct spacc_req *req)\r\n{\r\nstruct crypto_tfm *tfm = req->req->tfm;\r\nstruct spacc_ablk_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct ablkcipher_request *ablk_req = ablkcipher_request_cast(req->req);\r\nstruct crypto_alg *alg = req->req->tfm->__crt_alg;\r\nstruct spacc_alg *spacc_alg = to_spacc_alg(alg);\r\nstruct spacc_engine *engine = ctx->generic.engine;\r\nu32 ctrl;\r\nreq->ctx_id = spacc_load_ctx(&ctx->generic, ctx->key,\r\nctx->key_len, ablk_req->info, alg->cra_ablkcipher.ivsize,\r\nNULL, 0);\r\nwritel(req->src_addr, engine->regs + SPA_SRC_PTR_REG_OFFSET);\r\nwritel(req->dst_addr, engine->regs + SPA_DST_PTR_REG_OFFSET);\r\nwritel(0, engine->regs + SPA_OFFSET_REG_OFFSET);\r\nwritel(ablk_req->nbytes, engine->regs + SPA_PROC_LEN_REG_OFFSET);\r\nwritel(0, engine->regs + SPA_ICV_OFFSET_REG_OFFSET);\r\nwritel(0, engine->regs + SPA_AUX_INFO_REG_OFFSET);\r\nwritel(0, engine->regs + SPA_AAD_LEN_REG_OFFSET);\r\nctrl = spacc_alg->ctrl_default | (req->ctx_id << SPA_CTRL_CTX_IDX) |\r\n(req->is_encrypt ? (1 << SPA_CTRL_ENCRYPT_IDX) :\r\n(1 << SPA_CTRL_KEY_EXP));\r\nmod_timer(&engine->packet_timeout, jiffies + PACKET_TIMEOUT);\r\nwritel(ctrl, engine->regs + SPA_CTRL_REG_OFFSET);\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int spacc_ablk_do_fallback(struct ablkcipher_request *req,\r\nunsigned alg_type, bool is_encrypt)\r\n{\r\nstruct crypto_tfm *old_tfm =\r\ncrypto_ablkcipher_tfm(crypto_ablkcipher_reqtfm(req));\r\nstruct spacc_ablk_ctx *ctx = crypto_tfm_ctx(old_tfm);\r\nSKCIPHER_REQUEST_ON_STACK(subreq, ctx->sw_cipher);\r\nint err;\r\nskcipher_request_set_tfm(subreq, ctx->sw_cipher);\r\nskcipher_request_set_callback(subreq, req->base.flags, NULL, NULL);\r\nskcipher_request_set_crypt(subreq, req->src, req->dst,\r\nreq->nbytes, req->info);\r\nerr = is_encrypt ? crypto_skcipher_encrypt(subreq) :\r\ncrypto_skcipher_decrypt(subreq);\r\nskcipher_request_zero(subreq);\r\nreturn err;\r\n}\r\nstatic int spacc_ablk_setup(struct ablkcipher_request *req, unsigned alg_type,\r\nbool is_encrypt)\r\n{\r\nstruct crypto_alg *alg = req->base.tfm->__crt_alg;\r\nstruct spacc_engine *engine = to_spacc_alg(alg)->engine;\r\nstruct spacc_req *dev_req = ablkcipher_request_ctx(req);\r\nunsigned long flags;\r\nint err = -ENOMEM;\r\ndev_req->req = &req->base;\r\ndev_req->is_encrypt = is_encrypt;\r\ndev_req->engine = engine;\r\ndev_req->complete = spacc_ablk_complete;\r\ndev_req->result = -EINPROGRESS;\r\nif (unlikely(spacc_ablk_need_fallback(dev_req)))\r\nreturn spacc_ablk_do_fallback(req, alg_type, is_encrypt);\r\nif (req->src != req->dst) {\r\ndev_req->src_ddt = spacc_sg_to_ddt(engine, req->src,\r\nreq->nbytes, DMA_TO_DEVICE, &dev_req->src_addr);\r\nif (!dev_req->src_ddt)\r\ngoto out;\r\ndev_req->dst_ddt = spacc_sg_to_ddt(engine, req->dst,\r\nreq->nbytes, DMA_FROM_DEVICE, &dev_req->dst_addr);\r\nif (!dev_req->dst_ddt)\r\ngoto out_free_src;\r\n} else {\r\ndev_req->dst_ddt = spacc_sg_to_ddt(engine, req->dst,\r\nreq->nbytes, DMA_BIDIRECTIONAL, &dev_req->dst_addr);\r\nif (!dev_req->dst_ddt)\r\ngoto out;\r\ndev_req->src_ddt = NULL;\r\ndev_req->src_addr = dev_req->dst_addr;\r\n}\r\nerr = -EINPROGRESS;\r\nspin_lock_irqsave(&engine->hw_lock, flags);\r\nif (unlikely(spacc_fifo_cmd_full(engine)) ||\r\nengine->in_flight + 1 > engine->fifo_sz) {\r\nif (!(req->base.flags & CRYPTO_TFM_REQ_MAY_BACKLOG)) {\r\nerr = -EBUSY;\r\nspin_unlock_irqrestore(&engine->hw_lock, flags);\r\ngoto out_free_ddts;\r\n}\r\nlist_add_tail(&dev_req->list, &engine->pending);\r\n} else {\r\nlist_add_tail(&dev_req->list, &engine->pending);\r\nspacc_push(engine);\r\n}\r\nspin_unlock_irqrestore(&engine->hw_lock, flags);\r\ngoto out;\r\nout_free_ddts:\r\nspacc_free_ddt(dev_req, dev_req->dst_ddt, dev_req->dst_addr, req->dst,\r\nreq->nbytes, req->src == req->dst ?\r\nDMA_BIDIRECTIONAL : DMA_FROM_DEVICE);\r\nout_free_src:\r\nif (req->src != req->dst)\r\nspacc_free_ddt(dev_req, dev_req->src_ddt, dev_req->src_addr,\r\nreq->src, req->nbytes, DMA_TO_DEVICE);\r\nout:\r\nreturn err;\r\n}\r\nstatic int spacc_ablk_cra_init(struct crypto_tfm *tfm)\r\n{\r\nstruct spacc_ablk_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct crypto_alg *alg = tfm->__crt_alg;\r\nstruct spacc_alg *spacc_alg = to_spacc_alg(alg);\r\nstruct spacc_engine *engine = spacc_alg->engine;\r\nctx->generic.flags = spacc_alg->type;\r\nctx->generic.engine = engine;\r\nif (alg->cra_flags & CRYPTO_ALG_NEED_FALLBACK) {\r\nctx->sw_cipher = crypto_alloc_skcipher(\r\nalg->cra_name, 0, CRYPTO_ALG_ASYNC |\r\nCRYPTO_ALG_NEED_FALLBACK);\r\nif (IS_ERR(ctx->sw_cipher)) {\r\ndev_warn(engine->dev, "failed to allocate fallback for %s\n",\r\nalg->cra_name);\r\nreturn PTR_ERR(ctx->sw_cipher);\r\n}\r\n}\r\nctx->generic.key_offs = spacc_alg->key_offs;\r\nctx->generic.iv_offs = spacc_alg->iv_offs;\r\ntfm->crt_ablkcipher.reqsize = sizeof(struct spacc_req);\r\nreturn 0;\r\n}\r\nstatic void spacc_ablk_cra_exit(struct crypto_tfm *tfm)\r\n{\r\nstruct spacc_ablk_ctx *ctx = crypto_tfm_ctx(tfm);\r\ncrypto_free_skcipher(ctx->sw_cipher);\r\n}\r\nstatic int spacc_ablk_encrypt(struct ablkcipher_request *req)\r\n{\r\nstruct crypto_ablkcipher *cipher = crypto_ablkcipher_reqtfm(req);\r\nstruct crypto_tfm *tfm = crypto_ablkcipher_tfm(cipher);\r\nstruct spacc_alg *alg = to_spacc_alg(tfm->__crt_alg);\r\nreturn spacc_ablk_setup(req, alg->type, 1);\r\n}\r\nstatic int spacc_ablk_decrypt(struct ablkcipher_request *req)\r\n{\r\nstruct crypto_ablkcipher *cipher = crypto_ablkcipher_reqtfm(req);\r\nstruct crypto_tfm *tfm = crypto_ablkcipher_tfm(cipher);\r\nstruct spacc_alg *alg = to_spacc_alg(tfm->__crt_alg);\r\nreturn spacc_ablk_setup(req, alg->type, 0);\r\n}\r\nstatic inline int spacc_fifo_stat_empty(struct spacc_engine *engine)\r\n{\r\nreturn readl(engine->regs + SPA_FIFO_STAT_REG_OFFSET) &\r\nSPA_FIFO_STAT_EMPTY;\r\n}\r\nstatic void spacc_process_done(struct spacc_engine *engine)\r\n{\r\nstruct spacc_req *req;\r\nunsigned long flags;\r\nspin_lock_irqsave(&engine->hw_lock, flags);\r\nwhile (!spacc_fifo_stat_empty(engine)) {\r\nreq = list_first_entry(&engine->in_progress, struct spacc_req,\r\nlist);\r\nlist_move_tail(&req->list, &engine->completed);\r\n--engine->in_flight;\r\nwritel(~0, engine->regs + SPA_STAT_POP_REG_OFFSET);\r\nreq->result = (readl(engine->regs + SPA_STATUS_REG_OFFSET) &\r\nSPA_STATUS_RES_CODE_MASK) >> SPA_STATUS_RES_CODE_OFFSET;\r\nif (unlikely(req->result)) {\r\nswitch (req->result) {\r\ncase SPA_STATUS_ICV_FAIL:\r\nreq->result = -EBADMSG;\r\nbreak;\r\ncase SPA_STATUS_MEMORY_ERROR:\r\ndev_warn(engine->dev,\r\n"memory error triggered\n");\r\nreq->result = -EFAULT;\r\nbreak;\r\ncase SPA_STATUS_BLOCK_ERROR:\r\ndev_warn(engine->dev,\r\n"block error triggered\n");\r\nreq->result = -EIO;\r\nbreak;\r\n}\r\n}\r\n}\r\ntasklet_schedule(&engine->complete);\r\nspin_unlock_irqrestore(&engine->hw_lock, flags);\r\n}\r\nstatic irqreturn_t spacc_spacc_irq(int irq, void *dev)\r\n{\r\nstruct spacc_engine *engine = (struct spacc_engine *)dev;\r\nu32 spacc_irq_stat = readl(engine->regs + SPA_IRQ_STAT_REG_OFFSET);\r\nwritel(spacc_irq_stat, engine->regs + SPA_IRQ_STAT_REG_OFFSET);\r\nspacc_process_done(engine);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void spacc_packet_timeout(unsigned long data)\r\n{\r\nstruct spacc_engine *engine = (struct spacc_engine *)data;\r\nspacc_process_done(engine);\r\n}\r\nstatic int spacc_req_submit(struct spacc_req *req)\r\n{\r\nstruct crypto_alg *alg = req->req->tfm->__crt_alg;\r\nif (CRYPTO_ALG_TYPE_AEAD == (CRYPTO_ALG_TYPE_MASK & alg->cra_flags))\r\nreturn spacc_aead_submit(req);\r\nelse\r\nreturn spacc_ablk_submit(req);\r\n}\r\nstatic void spacc_spacc_complete(unsigned long data)\r\n{\r\nstruct spacc_engine *engine = (struct spacc_engine *)data;\r\nstruct spacc_req *req, *tmp;\r\nunsigned long flags;\r\nLIST_HEAD(completed);\r\nspin_lock_irqsave(&engine->hw_lock, flags);\r\nlist_splice_init(&engine->completed, &completed);\r\nspacc_push(engine);\r\nif (engine->in_flight)\r\nmod_timer(&engine->packet_timeout, jiffies + PACKET_TIMEOUT);\r\nspin_unlock_irqrestore(&engine->hw_lock, flags);\r\nlist_for_each_entry_safe(req, tmp, &completed, list) {\r\nlist_del(&req->list);\r\nreq->complete(req);\r\n}\r\n}\r\nstatic int spacc_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct spacc_engine *engine = platform_get_drvdata(pdev);\r\nclk_disable(engine->clk);\r\nreturn 0;\r\n}\r\nstatic int spacc_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct spacc_engine *engine = platform_get_drvdata(pdev);\r\nreturn clk_enable(engine->clk);\r\n}\r\nstatic inline struct spacc_engine *spacc_dev_to_engine(struct device *dev)\r\n{\r\nreturn dev ? platform_get_drvdata(to_platform_device(dev)) : NULL;\r\n}\r\nstatic ssize_t spacc_stat_irq_thresh_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct spacc_engine *engine = spacc_dev_to_engine(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", engine->stat_irq_thresh);\r\n}\r\nstatic ssize_t spacc_stat_irq_thresh_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct spacc_engine *engine = spacc_dev_to_engine(dev);\r\nunsigned long thresh;\r\nif (kstrtoul(buf, 0, &thresh))\r\nreturn -EINVAL;\r\nthresh = clamp(thresh, 1UL, engine->fifo_sz - 1);\r\nengine->stat_irq_thresh = thresh;\r\nwritel(engine->stat_irq_thresh << SPA_IRQ_CTRL_STAT_CNT_OFFSET,\r\nengine->regs + SPA_IRQ_CTRL_REG_OFFSET);\r\nreturn len;\r\n}\r\nstatic int spacc_probe(struct platform_device *pdev)\r\n{\r\nint i, err, ret = -EINVAL;\r\nstruct resource *mem, *irq;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct spacc_engine *engine = devm_kzalloc(&pdev->dev, sizeof(*engine),\r\nGFP_KERNEL);\r\nif (!engine)\r\nreturn -ENOMEM;\r\nif (of_device_is_compatible(np, "picochip,spacc-ipsec")) {\r\nengine->max_ctxs = SPACC_CRYPTO_IPSEC_MAX_CTXS;\r\nengine->cipher_pg_sz = SPACC_CRYPTO_IPSEC_CIPHER_PG_SZ;\r\nengine->hash_pg_sz = SPACC_CRYPTO_IPSEC_HASH_PG_SZ;\r\nengine->fifo_sz = SPACC_CRYPTO_IPSEC_FIFO_SZ;\r\nengine->algs = ipsec_engine_algs;\r\nengine->num_algs = ARRAY_SIZE(ipsec_engine_algs);\r\nengine->aeads = ipsec_engine_aeads;\r\nengine->num_aeads = ARRAY_SIZE(ipsec_engine_aeads);\r\n} else if (of_device_is_compatible(np, "picochip,spacc-l2")) {\r\nengine->max_ctxs = SPACC_CRYPTO_L2_MAX_CTXS;\r\nengine->cipher_pg_sz = SPACC_CRYPTO_L2_CIPHER_PG_SZ;\r\nengine->hash_pg_sz = SPACC_CRYPTO_L2_HASH_PG_SZ;\r\nengine->fifo_sz = SPACC_CRYPTO_L2_FIFO_SZ;\r\nengine->algs = l2_engine_algs;\r\nengine->num_algs = ARRAY_SIZE(l2_engine_algs);\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nengine->name = dev_name(&pdev->dev);\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nengine->regs = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(engine->regs))\r\nreturn PTR_ERR(engine->regs);\r\nirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!irq) {\r\ndev_err(&pdev->dev, "no memory/irq resource for engine\n");\r\nreturn -ENXIO;\r\n}\r\nif (devm_request_irq(&pdev->dev, irq->start, spacc_spacc_irq, 0,\r\nengine->name, engine)) {\r\ndev_err(engine->dev, "failed to request IRQ\n");\r\nreturn -EBUSY;\r\n}\r\nengine->dev = &pdev->dev;\r\nengine->cipher_ctx_base = engine->regs + SPA_CIPH_KEY_BASE_REG_OFFSET;\r\nengine->hash_key_base = engine->regs + SPA_HASH_KEY_BASE_REG_OFFSET;\r\nengine->req_pool = dmam_pool_create(engine->name, engine->dev,\r\nMAX_DDT_LEN * sizeof(struct spacc_ddt), 8, SZ_64K);\r\nif (!engine->req_pool)\r\nreturn -ENOMEM;\r\nspin_lock_init(&engine->hw_lock);\r\nengine->clk = clk_get(&pdev->dev, "ref");\r\nif (IS_ERR(engine->clk)) {\r\ndev_info(&pdev->dev, "clk unavailable\n");\r\ndevice_remove_file(&pdev->dev, &dev_attr_stat_irq_thresh);\r\nreturn PTR_ERR(engine->clk);\r\n}\r\nif (clk_prepare_enable(engine->clk)) {\r\ndev_info(&pdev->dev, "unable to prepare/enable clk\n");\r\nclk_put(engine->clk);\r\nreturn -EIO;\r\n}\r\nerr = device_create_file(&pdev->dev, &dev_attr_stat_irq_thresh);\r\nif (err) {\r\nclk_disable_unprepare(engine->clk);\r\nclk_put(engine->clk);\r\nreturn err;\r\n}\r\nengine->stat_irq_thresh = (engine->fifo_sz / 2);\r\nwritel(engine->stat_irq_thresh << SPA_IRQ_CTRL_STAT_CNT_OFFSET,\r\nengine->regs + SPA_IRQ_CTRL_REG_OFFSET);\r\nwritel(SPA_IRQ_EN_STAT_EN | SPA_IRQ_EN_GLBL_EN,\r\nengine->regs + SPA_IRQ_EN_REG_OFFSET);\r\nsetup_timer(&engine->packet_timeout, spacc_packet_timeout,\r\n(unsigned long)engine);\r\nINIT_LIST_HEAD(&engine->pending);\r\nINIT_LIST_HEAD(&engine->completed);\r\nINIT_LIST_HEAD(&engine->in_progress);\r\nengine->in_flight = 0;\r\ntasklet_init(&engine->complete, spacc_spacc_complete,\r\n(unsigned long)engine);\r\nplatform_set_drvdata(pdev, engine);\r\nINIT_LIST_HEAD(&engine->registered_algs);\r\nfor (i = 0; i < engine->num_algs; ++i) {\r\nengine->algs[i].engine = engine;\r\nerr = crypto_register_alg(&engine->algs[i].alg);\r\nif (!err) {\r\nlist_add_tail(&engine->algs[i].entry,\r\n&engine->registered_algs);\r\nret = 0;\r\n}\r\nif (err)\r\ndev_err(engine->dev, "failed to register alg \"%s\"\n",\r\nengine->algs[i].alg.cra_name);\r\nelse\r\ndev_dbg(engine->dev, "registered alg \"%s\"\n",\r\nengine->algs[i].alg.cra_name);\r\n}\r\nINIT_LIST_HEAD(&engine->registered_aeads);\r\nfor (i = 0; i < engine->num_aeads; ++i) {\r\nengine->aeads[i].engine = engine;\r\nerr = crypto_register_aead(&engine->aeads[i].alg);\r\nif (!err) {\r\nlist_add_tail(&engine->aeads[i].entry,\r\n&engine->registered_aeads);\r\nret = 0;\r\n}\r\nif (err)\r\ndev_err(engine->dev, "failed to register alg \"%s\"\n",\r\nengine->aeads[i].alg.base.cra_name);\r\nelse\r\ndev_dbg(engine->dev, "registered alg \"%s\"\n",\r\nengine->aeads[i].alg.base.cra_name);\r\n}\r\nreturn ret;\r\n}\r\nstatic int spacc_remove(struct platform_device *pdev)\r\n{\r\nstruct spacc_aead *aead, *an;\r\nstruct spacc_alg *alg, *next;\r\nstruct spacc_engine *engine = platform_get_drvdata(pdev);\r\ndel_timer_sync(&engine->packet_timeout);\r\ndevice_remove_file(&pdev->dev, &dev_attr_stat_irq_thresh);\r\nlist_for_each_entry_safe(aead, an, &engine->registered_aeads, entry) {\r\nlist_del(&aead->entry);\r\ncrypto_unregister_aead(&aead->alg);\r\n}\r\nlist_for_each_entry_safe(alg, next, &engine->registered_algs, entry) {\r\nlist_del(&alg->entry);\r\ncrypto_unregister_alg(&alg->alg);\r\n}\r\nclk_disable_unprepare(engine->clk);\r\nclk_put(engine->clk);\r\nreturn 0;\r\n}
