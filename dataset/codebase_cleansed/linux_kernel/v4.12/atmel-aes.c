static const char *atmel_aes_reg_name(u32 offset, char *tmp, size_t sz)\r\n{\r\nswitch (offset) {\r\ncase AES_CR:\r\nreturn "CR";\r\ncase AES_MR:\r\nreturn "MR";\r\ncase AES_ISR:\r\nreturn "ISR";\r\ncase AES_IMR:\r\nreturn "IMR";\r\ncase AES_IER:\r\nreturn "IER";\r\ncase AES_IDR:\r\nreturn "IDR";\r\ncase AES_KEYWR(0):\r\ncase AES_KEYWR(1):\r\ncase AES_KEYWR(2):\r\ncase AES_KEYWR(3):\r\ncase AES_KEYWR(4):\r\ncase AES_KEYWR(5):\r\ncase AES_KEYWR(6):\r\ncase AES_KEYWR(7):\r\nsnprintf(tmp, sz, "KEYWR[%u]", (offset - AES_KEYWR(0)) >> 2);\r\nbreak;\r\ncase AES_IDATAR(0):\r\ncase AES_IDATAR(1):\r\ncase AES_IDATAR(2):\r\ncase AES_IDATAR(3):\r\nsnprintf(tmp, sz, "IDATAR[%u]", (offset - AES_IDATAR(0)) >> 2);\r\nbreak;\r\ncase AES_ODATAR(0):\r\ncase AES_ODATAR(1):\r\ncase AES_ODATAR(2):\r\ncase AES_ODATAR(3):\r\nsnprintf(tmp, sz, "ODATAR[%u]", (offset - AES_ODATAR(0)) >> 2);\r\nbreak;\r\ncase AES_IVR(0):\r\ncase AES_IVR(1):\r\ncase AES_IVR(2):\r\ncase AES_IVR(3):\r\nsnprintf(tmp, sz, "IVR[%u]", (offset - AES_IVR(0)) >> 2);\r\nbreak;\r\ncase AES_AADLENR:\r\nreturn "AADLENR";\r\ncase AES_CLENR:\r\nreturn "CLENR";\r\ncase AES_GHASHR(0):\r\ncase AES_GHASHR(1):\r\ncase AES_GHASHR(2):\r\ncase AES_GHASHR(3):\r\nsnprintf(tmp, sz, "GHASHR[%u]", (offset - AES_GHASHR(0)) >> 2);\r\nbreak;\r\ncase AES_TAGR(0):\r\ncase AES_TAGR(1):\r\ncase AES_TAGR(2):\r\ncase AES_TAGR(3):\r\nsnprintf(tmp, sz, "TAGR[%u]", (offset - AES_TAGR(0)) >> 2);\r\nbreak;\r\ncase AES_CTRR:\r\nreturn "CTRR";\r\ncase AES_GCMHR(0):\r\ncase AES_GCMHR(1):\r\ncase AES_GCMHR(2):\r\ncase AES_GCMHR(3):\r\nsnprintf(tmp, sz, "GCMHR[%u]", (offset - AES_GCMHR(0)) >> 2);\r\nbreak;\r\ncase AES_EMR:\r\nreturn "EMR";\r\ncase AES_TWR(0):\r\ncase AES_TWR(1):\r\ncase AES_TWR(2):\r\ncase AES_TWR(3):\r\nsnprintf(tmp, sz, "TWR[%u]", (offset - AES_TWR(0)) >> 2);\r\nbreak;\r\ncase AES_ALPHAR(0):\r\ncase AES_ALPHAR(1):\r\ncase AES_ALPHAR(2):\r\ncase AES_ALPHAR(3):\r\nsnprintf(tmp, sz, "ALPHAR[%u]", (offset - AES_ALPHAR(0)) >> 2);\r\nbreak;\r\ndefault:\r\nsnprintf(tmp, sz, "0x%02x", offset);\r\nbreak;\r\n}\r\nreturn tmp;\r\n}\r\nstatic inline u32 atmel_aes_read(struct atmel_aes_dev *dd, u32 offset)\r\n{\r\nu32 value = readl_relaxed(dd->io_base + offset);\r\n#ifdef VERBOSE_DEBUG\r\nif (dd->flags & AES_FLAGS_DUMP_REG) {\r\nchar tmp[16];\r\ndev_vdbg(dd->dev, "read 0x%08x from %s\n", value,\r\natmel_aes_reg_name(offset, tmp, sizeof(tmp)));\r\n}\r\n#endif\r\nreturn value;\r\n}\r\nstatic inline void atmel_aes_write(struct atmel_aes_dev *dd,\r\nu32 offset, u32 value)\r\n{\r\n#ifdef VERBOSE_DEBUG\r\nif (dd->flags & AES_FLAGS_DUMP_REG) {\r\nchar tmp[16];\r\ndev_vdbg(dd->dev, "write 0x%08x into %s\n", value,\r\natmel_aes_reg_name(offset, tmp, sizeof(tmp)));\r\n}\r\n#endif\r\nwritel_relaxed(value, dd->io_base + offset);\r\n}\r\nstatic void atmel_aes_read_n(struct atmel_aes_dev *dd, u32 offset,\r\nu32 *value, int count)\r\n{\r\nfor (; count--; value++, offset += 4)\r\n*value = atmel_aes_read(dd, offset);\r\n}\r\nstatic void atmel_aes_write_n(struct atmel_aes_dev *dd, u32 offset,\r\nconst u32 *value, int count)\r\n{\r\nfor (; count--; value++, offset += 4)\r\natmel_aes_write(dd, offset, *value);\r\n}\r\nstatic inline void atmel_aes_read_block(struct atmel_aes_dev *dd, u32 offset,\r\nu32 *value)\r\n{\r\natmel_aes_read_n(dd, offset, value, SIZE_IN_WORDS(AES_BLOCK_SIZE));\r\n}\r\nstatic inline void atmel_aes_write_block(struct atmel_aes_dev *dd, u32 offset,\r\nconst u32 *value)\r\n{\r\natmel_aes_write_n(dd, offset, value, SIZE_IN_WORDS(AES_BLOCK_SIZE));\r\n}\r\nstatic inline int atmel_aes_wait_for_data_ready(struct atmel_aes_dev *dd,\r\natmel_aes_fn_t resume)\r\n{\r\nu32 isr = atmel_aes_read(dd, AES_ISR);\r\nif (unlikely(isr & AES_INT_DATARDY))\r\nreturn resume(dd);\r\ndd->resume = resume;\r\natmel_aes_write(dd, AES_IER, AES_INT_DATARDY);\r\nreturn -EINPROGRESS;\r\n}\r\nstatic inline size_t atmel_aes_padlen(size_t len, size_t block_size)\r\n{\r\nlen &= block_size - 1;\r\nreturn len ? block_size - len : 0;\r\n}\r\nstatic struct atmel_aes_dev *atmel_aes_find_dev(struct atmel_aes_base_ctx *ctx)\r\n{\r\nstruct atmel_aes_dev *aes_dd = NULL;\r\nstruct atmel_aes_dev *tmp;\r\nspin_lock_bh(&atmel_aes.lock);\r\nif (!ctx->dd) {\r\nlist_for_each_entry(tmp, &atmel_aes.dev_list, list) {\r\naes_dd = tmp;\r\nbreak;\r\n}\r\nctx->dd = aes_dd;\r\n} else {\r\naes_dd = ctx->dd;\r\n}\r\nspin_unlock_bh(&atmel_aes.lock);\r\nreturn aes_dd;\r\n}\r\nstatic int atmel_aes_hw_init(struct atmel_aes_dev *dd)\r\n{\r\nint err;\r\nerr = clk_enable(dd->iclk);\r\nif (err)\r\nreturn err;\r\nif (!(dd->flags & AES_FLAGS_INIT)) {\r\natmel_aes_write(dd, AES_CR, AES_CR_SWRST);\r\natmel_aes_write(dd, AES_MR, 0xE << AES_MR_CKEY_OFFSET);\r\ndd->flags |= AES_FLAGS_INIT;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline unsigned int atmel_aes_get_version(struct atmel_aes_dev *dd)\r\n{\r\nreturn atmel_aes_read(dd, AES_HW_VERSION) & 0x00000fff;\r\n}\r\nstatic int atmel_aes_hw_version_init(struct atmel_aes_dev *dd)\r\n{\r\nint err;\r\nerr = atmel_aes_hw_init(dd);\r\nif (err)\r\nreturn err;\r\ndd->hw_version = atmel_aes_get_version(dd);\r\ndev_info(dd->dev, "version: 0x%x\n", dd->hw_version);\r\nclk_disable(dd->iclk);\r\nreturn 0;\r\n}\r\nstatic inline void atmel_aes_set_mode(struct atmel_aes_dev *dd,\r\nconst struct atmel_aes_reqctx *rctx)\r\n{\r\ndd->flags = (dd->flags & AES_FLAGS_PERSISTENT) | rctx->mode;\r\n}\r\nstatic inline bool atmel_aes_is_encrypt(const struct atmel_aes_dev *dd)\r\n{\r\nreturn (dd->flags & AES_FLAGS_ENCRYPT);\r\n}\r\nstatic inline int atmel_aes_complete(struct atmel_aes_dev *dd, int err)\r\n{\r\n#ifdef CONFIG_CRYPTO_DEV_ATMEL_AUTHENC\r\natmel_aes_authenc_complete(dd, err);\r\n#endif\r\nclk_disable(dd->iclk);\r\ndd->flags &= ~AES_FLAGS_BUSY;\r\nif (dd->is_async)\r\ndd->areq->complete(dd->areq, err);\r\ntasklet_schedule(&dd->queue_task);\r\nreturn err;\r\n}\r\nstatic void atmel_aes_write_ctrl_key(struct atmel_aes_dev *dd, bool use_dma,\r\nconst u32 *iv, const u32 *key, int keylen)\r\n{\r\nu32 valmr = 0;\r\nif (keylen == AES_KEYSIZE_128)\r\nvalmr |= AES_MR_KEYSIZE_128;\r\nelse if (keylen == AES_KEYSIZE_192)\r\nvalmr |= AES_MR_KEYSIZE_192;\r\nelse\r\nvalmr |= AES_MR_KEYSIZE_256;\r\nvalmr |= dd->flags & AES_FLAGS_MODE_MASK;\r\nif (use_dma) {\r\nvalmr |= AES_MR_SMOD_IDATAR0;\r\nif (dd->caps.has_dualbuff)\r\nvalmr |= AES_MR_DUALBUFF;\r\n} else {\r\nvalmr |= AES_MR_SMOD_AUTO;\r\n}\r\natmel_aes_write(dd, AES_MR, valmr);\r\natmel_aes_write_n(dd, AES_KEYWR(0), key, SIZE_IN_WORDS(keylen));\r\nif (iv && (valmr & AES_MR_OPMOD_MASK) != AES_MR_OPMOD_ECB)\r\natmel_aes_write_block(dd, AES_IVR(0), iv);\r\n}\r\nstatic inline void atmel_aes_write_ctrl(struct atmel_aes_dev *dd, bool use_dma,\r\nconst u32 *iv)\r\n{\r\natmel_aes_write_ctrl_key(dd, use_dma, iv,\r\ndd->ctx->key, dd->ctx->keylen);\r\n}\r\nstatic int atmel_aes_cpu_transfer(struct atmel_aes_dev *dd)\r\n{\r\nint err = 0;\r\nu32 isr;\r\nfor (;;) {\r\natmel_aes_read_block(dd, AES_ODATAR(0), dd->data);\r\ndd->data += 4;\r\ndd->datalen -= AES_BLOCK_SIZE;\r\nif (dd->datalen < AES_BLOCK_SIZE)\r\nbreak;\r\natmel_aes_write_block(dd, AES_IDATAR(0), dd->data);\r\nisr = atmel_aes_read(dd, AES_ISR);\r\nif (!(isr & AES_INT_DATARDY)) {\r\ndd->resume = atmel_aes_cpu_transfer;\r\natmel_aes_write(dd, AES_IER, AES_INT_DATARDY);\r\nreturn -EINPROGRESS;\r\n}\r\n}\r\nif (!sg_copy_from_buffer(dd->real_dst, sg_nents(dd->real_dst),\r\ndd->buf, dd->total))\r\nerr = -EINVAL;\r\nif (err)\r\nreturn atmel_aes_complete(dd, err);\r\nreturn dd->cpu_transfer_complete(dd);\r\n}\r\nstatic int atmel_aes_cpu_start(struct atmel_aes_dev *dd,\r\nstruct scatterlist *src,\r\nstruct scatterlist *dst,\r\nsize_t len,\r\natmel_aes_fn_t resume)\r\n{\r\nsize_t padlen = atmel_aes_padlen(len, AES_BLOCK_SIZE);\r\nif (unlikely(len == 0))\r\nreturn -EINVAL;\r\nsg_copy_to_buffer(src, sg_nents(src), dd->buf, len);\r\ndd->total = len;\r\ndd->real_dst = dst;\r\ndd->cpu_transfer_complete = resume;\r\ndd->datalen = len + padlen;\r\ndd->data = (u32 *)dd->buf;\r\natmel_aes_write_block(dd, AES_IDATAR(0), dd->data);\r\nreturn atmel_aes_wait_for_data_ready(dd, atmel_aes_cpu_transfer);\r\n}\r\nstatic bool atmel_aes_check_aligned(struct atmel_aes_dev *dd,\r\nstruct scatterlist *sg,\r\nsize_t len,\r\nstruct atmel_aes_dma *dma)\r\n{\r\nint nents;\r\nif (!IS_ALIGNED(len, dd->ctx->block_size))\r\nreturn false;\r\nfor (nents = 0; sg; sg = sg_next(sg), ++nents) {\r\nif (!IS_ALIGNED(sg->offset, sizeof(u32)))\r\nreturn false;\r\nif (len <= sg->length) {\r\nif (!IS_ALIGNED(len, dd->ctx->block_size))\r\nreturn false;\r\ndma->nents = nents+1;\r\ndma->remainder = sg->length - len;\r\nsg->length = len;\r\nreturn true;\r\n}\r\nif (!IS_ALIGNED(sg->length, dd->ctx->block_size))\r\nreturn false;\r\nlen -= sg->length;\r\n}\r\nreturn false;\r\n}\r\nstatic inline void atmel_aes_restore_sg(const struct atmel_aes_dma *dma)\r\n{\r\nstruct scatterlist *sg = dma->sg;\r\nint nents = dma->nents;\r\nif (!dma->remainder)\r\nreturn;\r\nwhile (--nents > 0 && sg)\r\nsg = sg_next(sg);\r\nif (!sg)\r\nreturn;\r\nsg->length += dma->remainder;\r\n}\r\nstatic int atmel_aes_map(struct atmel_aes_dev *dd,\r\nstruct scatterlist *src,\r\nstruct scatterlist *dst,\r\nsize_t len)\r\n{\r\nbool src_aligned, dst_aligned;\r\nsize_t padlen;\r\ndd->total = len;\r\ndd->src.sg = src;\r\ndd->dst.sg = dst;\r\ndd->real_dst = dst;\r\nsrc_aligned = atmel_aes_check_aligned(dd, src, len, &dd->src);\r\nif (src == dst)\r\ndst_aligned = src_aligned;\r\nelse\r\ndst_aligned = atmel_aes_check_aligned(dd, dst, len, &dd->dst);\r\nif (!src_aligned || !dst_aligned) {\r\npadlen = atmel_aes_padlen(len, dd->ctx->block_size);\r\nif (dd->buflen < len + padlen)\r\nreturn -ENOMEM;\r\nif (!src_aligned) {\r\nsg_copy_to_buffer(src, sg_nents(src), dd->buf, len);\r\ndd->src.sg = &dd->aligned_sg;\r\ndd->src.nents = 1;\r\ndd->src.remainder = 0;\r\n}\r\nif (!dst_aligned) {\r\ndd->dst.sg = &dd->aligned_sg;\r\ndd->dst.nents = 1;\r\ndd->dst.remainder = 0;\r\n}\r\nsg_init_table(&dd->aligned_sg, 1);\r\nsg_set_buf(&dd->aligned_sg, dd->buf, len + padlen);\r\n}\r\nif (dd->src.sg == dd->dst.sg) {\r\ndd->src.sg_len = dma_map_sg(dd->dev, dd->src.sg, dd->src.nents,\r\nDMA_BIDIRECTIONAL);\r\ndd->dst.sg_len = dd->src.sg_len;\r\nif (!dd->src.sg_len)\r\nreturn -EFAULT;\r\n} else {\r\ndd->src.sg_len = dma_map_sg(dd->dev, dd->src.sg, dd->src.nents,\r\nDMA_TO_DEVICE);\r\nif (!dd->src.sg_len)\r\nreturn -EFAULT;\r\ndd->dst.sg_len = dma_map_sg(dd->dev, dd->dst.sg, dd->dst.nents,\r\nDMA_FROM_DEVICE);\r\nif (!dd->dst.sg_len) {\r\ndma_unmap_sg(dd->dev, dd->src.sg, dd->src.nents,\r\nDMA_TO_DEVICE);\r\nreturn -EFAULT;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void atmel_aes_unmap(struct atmel_aes_dev *dd)\r\n{\r\nif (dd->src.sg == dd->dst.sg) {\r\ndma_unmap_sg(dd->dev, dd->src.sg, dd->src.nents,\r\nDMA_BIDIRECTIONAL);\r\nif (dd->src.sg != &dd->aligned_sg)\r\natmel_aes_restore_sg(&dd->src);\r\n} else {\r\ndma_unmap_sg(dd->dev, dd->dst.sg, dd->dst.nents,\r\nDMA_FROM_DEVICE);\r\nif (dd->dst.sg != &dd->aligned_sg)\r\natmel_aes_restore_sg(&dd->dst);\r\ndma_unmap_sg(dd->dev, dd->src.sg, dd->src.nents,\r\nDMA_TO_DEVICE);\r\nif (dd->src.sg != &dd->aligned_sg)\r\natmel_aes_restore_sg(&dd->src);\r\n}\r\nif (dd->dst.sg == &dd->aligned_sg)\r\nsg_copy_from_buffer(dd->real_dst, sg_nents(dd->real_dst),\r\ndd->buf, dd->total);\r\n}\r\nstatic int atmel_aes_dma_transfer_start(struct atmel_aes_dev *dd,\r\nenum dma_slave_buswidth addr_width,\r\nenum dma_transfer_direction dir,\r\nu32 maxburst)\r\n{\r\nstruct dma_async_tx_descriptor *desc;\r\nstruct dma_slave_config config;\r\ndma_async_tx_callback callback;\r\nstruct atmel_aes_dma *dma;\r\nint err;\r\nmemset(&config, 0, sizeof(config));\r\nconfig.direction = dir;\r\nconfig.src_addr_width = addr_width;\r\nconfig.dst_addr_width = addr_width;\r\nconfig.src_maxburst = maxburst;\r\nconfig.dst_maxburst = maxburst;\r\nswitch (dir) {\r\ncase DMA_MEM_TO_DEV:\r\ndma = &dd->src;\r\ncallback = NULL;\r\nconfig.dst_addr = dd->phys_base + AES_IDATAR(0);\r\nbreak;\r\ncase DMA_DEV_TO_MEM:\r\ndma = &dd->dst;\r\ncallback = atmel_aes_dma_callback;\r\nconfig.src_addr = dd->phys_base + AES_ODATAR(0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nerr = dmaengine_slave_config(dma->chan, &config);\r\nif (err)\r\nreturn err;\r\ndesc = dmaengine_prep_slave_sg(dma->chan, dma->sg, dma->sg_len, dir,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc)\r\nreturn -ENOMEM;\r\ndesc->callback = callback;\r\ndesc->callback_param = dd;\r\ndmaengine_submit(desc);\r\ndma_async_issue_pending(dma->chan);\r\nreturn 0;\r\n}\r\nstatic void atmel_aes_dma_transfer_stop(struct atmel_aes_dev *dd,\r\nenum dma_transfer_direction dir)\r\n{\r\nstruct atmel_aes_dma *dma;\r\nswitch (dir) {\r\ncase DMA_MEM_TO_DEV:\r\ndma = &dd->src;\r\nbreak;\r\ncase DMA_DEV_TO_MEM:\r\ndma = &dd->dst;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\ndmaengine_terminate_all(dma->chan);\r\n}\r\nstatic int atmel_aes_dma_start(struct atmel_aes_dev *dd,\r\nstruct scatterlist *src,\r\nstruct scatterlist *dst,\r\nsize_t len,\r\natmel_aes_fn_t resume)\r\n{\r\nenum dma_slave_buswidth addr_width;\r\nu32 maxburst;\r\nint err;\r\nswitch (dd->ctx->block_size) {\r\ncase CFB8_BLOCK_SIZE:\r\naddr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\nmaxburst = 1;\r\nbreak;\r\ncase CFB16_BLOCK_SIZE:\r\naddr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\r\nmaxburst = 1;\r\nbreak;\r\ncase CFB32_BLOCK_SIZE:\r\ncase CFB64_BLOCK_SIZE:\r\naddr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nmaxburst = 1;\r\nbreak;\r\ncase AES_BLOCK_SIZE:\r\naddr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nmaxburst = dd->caps.max_burst_size;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto exit;\r\n}\r\nerr = atmel_aes_map(dd, src, dst, len);\r\nif (err)\r\ngoto exit;\r\ndd->resume = resume;\r\nerr = atmel_aes_dma_transfer_start(dd, addr_width, DMA_DEV_TO_MEM,\r\nmaxburst);\r\nif (err)\r\ngoto unmap;\r\nerr = atmel_aes_dma_transfer_start(dd, addr_width, DMA_MEM_TO_DEV,\r\nmaxburst);\r\nif (err)\r\ngoto output_transfer_stop;\r\nreturn -EINPROGRESS;\r\noutput_transfer_stop:\r\natmel_aes_dma_transfer_stop(dd, DMA_DEV_TO_MEM);\r\nunmap:\r\natmel_aes_unmap(dd);\r\nexit:\r\nreturn atmel_aes_complete(dd, err);\r\n}\r\nstatic void atmel_aes_dma_stop(struct atmel_aes_dev *dd)\r\n{\r\natmel_aes_dma_transfer_stop(dd, DMA_MEM_TO_DEV);\r\natmel_aes_dma_transfer_stop(dd, DMA_DEV_TO_MEM);\r\natmel_aes_unmap(dd);\r\n}\r\nstatic void atmel_aes_dma_callback(void *data)\r\n{\r\nstruct atmel_aes_dev *dd = data;\r\natmel_aes_dma_stop(dd);\r\ndd->is_async = true;\r\n(void)dd->resume(dd);\r\n}\r\nstatic int atmel_aes_handle_queue(struct atmel_aes_dev *dd,\r\nstruct crypto_async_request *new_areq)\r\n{\r\nstruct crypto_async_request *areq, *backlog;\r\nstruct atmel_aes_base_ctx *ctx;\r\nunsigned long flags;\r\nbool start_async;\r\nint err, ret = 0;\r\nspin_lock_irqsave(&dd->lock, flags);\r\nif (new_areq)\r\nret = crypto_enqueue_request(&dd->queue, new_areq);\r\nif (dd->flags & AES_FLAGS_BUSY) {\r\nspin_unlock_irqrestore(&dd->lock, flags);\r\nreturn ret;\r\n}\r\nbacklog = crypto_get_backlog(&dd->queue);\r\nareq = crypto_dequeue_request(&dd->queue);\r\nif (areq)\r\ndd->flags |= AES_FLAGS_BUSY;\r\nspin_unlock_irqrestore(&dd->lock, flags);\r\nif (!areq)\r\nreturn ret;\r\nif (backlog)\r\nbacklog->complete(backlog, -EINPROGRESS);\r\nctx = crypto_tfm_ctx(areq->tfm);\r\ndd->areq = areq;\r\ndd->ctx = ctx;\r\nstart_async = (areq != new_areq);\r\ndd->is_async = start_async;\r\nerr = ctx->start(dd);\r\nreturn (start_async) ? ret : err;\r\n}\r\nstatic int atmel_aes_transfer_complete(struct atmel_aes_dev *dd)\r\n{\r\nreturn atmel_aes_complete(dd, 0);\r\n}\r\nstatic int atmel_aes_start(struct atmel_aes_dev *dd)\r\n{\r\nstruct ablkcipher_request *req = ablkcipher_request_cast(dd->areq);\r\nstruct atmel_aes_reqctx *rctx = ablkcipher_request_ctx(req);\r\nbool use_dma = (req->nbytes >= ATMEL_AES_DMA_THRESHOLD ||\r\ndd->ctx->block_size != AES_BLOCK_SIZE);\r\nint err;\r\natmel_aes_set_mode(dd, rctx);\r\nerr = atmel_aes_hw_init(dd);\r\nif (err)\r\nreturn atmel_aes_complete(dd, err);\r\natmel_aes_write_ctrl(dd, use_dma, req->info);\r\nif (use_dma)\r\nreturn atmel_aes_dma_start(dd, req->src, req->dst, req->nbytes,\r\natmel_aes_transfer_complete);\r\nreturn atmel_aes_cpu_start(dd, req->src, req->dst, req->nbytes,\r\natmel_aes_transfer_complete);\r\n}\r\nstatic inline struct atmel_aes_ctr_ctx *\r\natmel_aes_ctr_ctx_cast(struct atmel_aes_base_ctx *ctx)\r\n{\r\nreturn container_of(ctx, struct atmel_aes_ctr_ctx, base);\r\n}\r\nstatic int atmel_aes_ctr_transfer(struct atmel_aes_dev *dd)\r\n{\r\nstruct atmel_aes_ctr_ctx *ctx = atmel_aes_ctr_ctx_cast(dd->ctx);\r\nstruct ablkcipher_request *req = ablkcipher_request_cast(dd->areq);\r\nstruct scatterlist *src, *dst;\r\nu32 ctr, blocks;\r\nsize_t datalen;\r\nbool use_dma, fragmented = false;\r\nctx->offset += dd->total;\r\nif (ctx->offset >= req->nbytes)\r\nreturn atmel_aes_transfer_complete(dd);\r\ndatalen = req->nbytes - ctx->offset;\r\nblocks = DIV_ROUND_UP(datalen, AES_BLOCK_SIZE);\r\nctr = be32_to_cpu(ctx->iv[3]);\r\nif (dd->caps.has_ctr32) {\r\nu32 start = ctr;\r\nu32 end = start + blocks - 1;\r\nif (end < start) {\r\nctr |= 0xffffffff;\r\ndatalen = AES_BLOCK_SIZE * -start;\r\nfragmented = true;\r\n}\r\n} else {\r\nu16 start = ctr & 0xffff;\r\nu16 end = start + (u16)blocks - 1;\r\nif (blocks >> 16 || end < start) {\r\nctr |= 0xffff;\r\ndatalen = AES_BLOCK_SIZE * (0x10000-start);\r\nfragmented = true;\r\n}\r\n}\r\nuse_dma = (datalen >= ATMEL_AES_DMA_THRESHOLD);\r\nsrc = scatterwalk_ffwd(ctx->src, req->src, ctx->offset);\r\ndst = ((req->src == req->dst) ? src :\r\nscatterwalk_ffwd(ctx->dst, req->dst, ctx->offset));\r\natmel_aes_write_ctrl(dd, use_dma, ctx->iv);\r\nif (unlikely(fragmented)) {\r\nctx->iv[3] = cpu_to_be32(ctr);\r\ncrypto_inc((u8 *)ctx->iv, AES_BLOCK_SIZE);\r\n}\r\nif (use_dma)\r\nreturn atmel_aes_dma_start(dd, src, dst, datalen,\r\natmel_aes_ctr_transfer);\r\nreturn atmel_aes_cpu_start(dd, src, dst, datalen,\r\natmel_aes_ctr_transfer);\r\n}\r\nstatic int atmel_aes_ctr_start(struct atmel_aes_dev *dd)\r\n{\r\nstruct atmel_aes_ctr_ctx *ctx = atmel_aes_ctr_ctx_cast(dd->ctx);\r\nstruct ablkcipher_request *req = ablkcipher_request_cast(dd->areq);\r\nstruct atmel_aes_reqctx *rctx = ablkcipher_request_ctx(req);\r\nint err;\r\natmel_aes_set_mode(dd, rctx);\r\nerr = atmel_aes_hw_init(dd);\r\nif (err)\r\nreturn atmel_aes_complete(dd, err);\r\nmemcpy(ctx->iv, req->info, AES_BLOCK_SIZE);\r\nctx->offset = 0;\r\ndd->total = 0;\r\nreturn atmel_aes_ctr_transfer(dd);\r\n}\r\nstatic int atmel_aes_crypt(struct ablkcipher_request *req, unsigned long mode)\r\n{\r\nstruct atmel_aes_base_ctx *ctx;\r\nstruct atmel_aes_reqctx *rctx;\r\nstruct atmel_aes_dev *dd;\r\nctx = crypto_ablkcipher_ctx(crypto_ablkcipher_reqtfm(req));\r\nswitch (mode & AES_FLAGS_OPMODE_MASK) {\r\ncase AES_FLAGS_CFB8:\r\nctx->block_size = CFB8_BLOCK_SIZE;\r\nbreak;\r\ncase AES_FLAGS_CFB16:\r\nctx->block_size = CFB16_BLOCK_SIZE;\r\nbreak;\r\ncase AES_FLAGS_CFB32:\r\nctx->block_size = CFB32_BLOCK_SIZE;\r\nbreak;\r\ncase AES_FLAGS_CFB64:\r\nctx->block_size = CFB64_BLOCK_SIZE;\r\nbreak;\r\ndefault:\r\nctx->block_size = AES_BLOCK_SIZE;\r\nbreak;\r\n}\r\ndd = atmel_aes_find_dev(ctx);\r\nif (!dd)\r\nreturn -ENODEV;\r\nrctx = ablkcipher_request_ctx(req);\r\nrctx->mode = mode;\r\nreturn atmel_aes_handle_queue(dd, &req->base);\r\n}\r\nstatic int atmel_aes_setkey(struct crypto_ablkcipher *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct atmel_aes_base_ctx *ctx = crypto_ablkcipher_ctx(tfm);\r\nif (keylen != AES_KEYSIZE_128 &&\r\nkeylen != AES_KEYSIZE_192 &&\r\nkeylen != AES_KEYSIZE_256) {\r\ncrypto_ablkcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(ctx->key, key, keylen);\r\nctx->keylen = keylen;\r\nreturn 0;\r\n}\r\nstatic int atmel_aes_ecb_encrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_aes_crypt(req, AES_FLAGS_ECB | AES_FLAGS_ENCRYPT);\r\n}\r\nstatic int atmel_aes_ecb_decrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_aes_crypt(req, AES_FLAGS_ECB);\r\n}\r\nstatic int atmel_aes_cbc_encrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_aes_crypt(req, AES_FLAGS_CBC | AES_FLAGS_ENCRYPT);\r\n}\r\nstatic int atmel_aes_cbc_decrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_aes_crypt(req, AES_FLAGS_CBC);\r\n}\r\nstatic int atmel_aes_ofb_encrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_aes_crypt(req, AES_FLAGS_OFB | AES_FLAGS_ENCRYPT);\r\n}\r\nstatic int atmel_aes_ofb_decrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_aes_crypt(req, AES_FLAGS_OFB);\r\n}\r\nstatic int atmel_aes_cfb_encrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_aes_crypt(req, AES_FLAGS_CFB128 | AES_FLAGS_ENCRYPT);\r\n}\r\nstatic int atmel_aes_cfb_decrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_aes_crypt(req, AES_FLAGS_CFB128);\r\n}\r\nstatic int atmel_aes_cfb64_encrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_aes_crypt(req, AES_FLAGS_CFB64 | AES_FLAGS_ENCRYPT);\r\n}\r\nstatic int atmel_aes_cfb64_decrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_aes_crypt(req, AES_FLAGS_CFB64);\r\n}\r\nstatic int atmel_aes_cfb32_encrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_aes_crypt(req, AES_FLAGS_CFB32 | AES_FLAGS_ENCRYPT);\r\n}\r\nstatic int atmel_aes_cfb32_decrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_aes_crypt(req, AES_FLAGS_CFB32);\r\n}\r\nstatic int atmel_aes_cfb16_encrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_aes_crypt(req, AES_FLAGS_CFB16 | AES_FLAGS_ENCRYPT);\r\n}\r\nstatic int atmel_aes_cfb16_decrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_aes_crypt(req, AES_FLAGS_CFB16);\r\n}\r\nstatic int atmel_aes_cfb8_encrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_aes_crypt(req, AES_FLAGS_CFB8 | AES_FLAGS_ENCRYPT);\r\n}\r\nstatic int atmel_aes_cfb8_decrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_aes_crypt(req, AES_FLAGS_CFB8);\r\n}\r\nstatic int atmel_aes_ctr_encrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_aes_crypt(req, AES_FLAGS_CTR | AES_FLAGS_ENCRYPT);\r\n}\r\nstatic int atmel_aes_ctr_decrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_aes_crypt(req, AES_FLAGS_CTR);\r\n}\r\nstatic int atmel_aes_cra_init(struct crypto_tfm *tfm)\r\n{\r\nstruct atmel_aes_ctx *ctx = crypto_tfm_ctx(tfm);\r\ntfm->crt_ablkcipher.reqsize = sizeof(struct atmel_aes_reqctx);\r\nctx->base.start = atmel_aes_start;\r\nreturn 0;\r\n}\r\nstatic int atmel_aes_ctr_cra_init(struct crypto_tfm *tfm)\r\n{\r\nstruct atmel_aes_ctx *ctx = crypto_tfm_ctx(tfm);\r\ntfm->crt_ablkcipher.reqsize = sizeof(struct atmel_aes_reqctx);\r\nctx->base.start = atmel_aes_ctr_start;\r\nreturn 0;\r\n}\r\nstatic void atmel_aes_cra_exit(struct crypto_tfm *tfm)\r\n{\r\n}\r\nstatic inline struct atmel_aes_gcm_ctx *\r\natmel_aes_gcm_ctx_cast(struct atmel_aes_base_ctx *ctx)\r\n{\r\nreturn container_of(ctx, struct atmel_aes_gcm_ctx, base);\r\n}\r\nstatic int atmel_aes_gcm_ghash(struct atmel_aes_dev *dd,\r\nconst u32 *data, size_t datalen,\r\nconst u32 *ghash_in, u32 *ghash_out,\r\natmel_aes_fn_t resume)\r\n{\r\nstruct atmel_aes_gcm_ctx *ctx = atmel_aes_gcm_ctx_cast(dd->ctx);\r\ndd->data = (u32 *)data;\r\ndd->datalen = datalen;\r\nctx->ghash_in = ghash_in;\r\nctx->ghash_out = ghash_out;\r\nctx->ghash_resume = resume;\r\natmel_aes_write_ctrl(dd, false, NULL);\r\nreturn atmel_aes_wait_for_data_ready(dd, atmel_aes_gcm_ghash_init);\r\n}\r\nstatic int atmel_aes_gcm_ghash_init(struct atmel_aes_dev *dd)\r\n{\r\nstruct atmel_aes_gcm_ctx *ctx = atmel_aes_gcm_ctx_cast(dd->ctx);\r\natmel_aes_write(dd, AES_AADLENR, dd->total);\r\natmel_aes_write(dd, AES_CLENR, 0);\r\nif (ctx->ghash_in)\r\natmel_aes_write_block(dd, AES_GHASHR(0), ctx->ghash_in);\r\nreturn atmel_aes_gcm_ghash_finalize(dd);\r\n}\r\nstatic int atmel_aes_gcm_ghash_finalize(struct atmel_aes_dev *dd)\r\n{\r\nstruct atmel_aes_gcm_ctx *ctx = atmel_aes_gcm_ctx_cast(dd->ctx);\r\nu32 isr;\r\nwhile (dd->datalen > 0) {\r\natmel_aes_write_block(dd, AES_IDATAR(0), dd->data);\r\ndd->data += 4;\r\ndd->datalen -= AES_BLOCK_SIZE;\r\nisr = atmel_aes_read(dd, AES_ISR);\r\nif (!(isr & AES_INT_DATARDY)) {\r\ndd->resume = atmel_aes_gcm_ghash_finalize;\r\natmel_aes_write(dd, AES_IER, AES_INT_DATARDY);\r\nreturn -EINPROGRESS;\r\n}\r\n}\r\natmel_aes_read_block(dd, AES_GHASHR(0), ctx->ghash_out);\r\nreturn ctx->ghash_resume(dd);\r\n}\r\nstatic int atmel_aes_gcm_start(struct atmel_aes_dev *dd)\r\n{\r\nstruct atmel_aes_gcm_ctx *ctx = atmel_aes_gcm_ctx_cast(dd->ctx);\r\nstruct aead_request *req = aead_request_cast(dd->areq);\r\nstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\r\nstruct atmel_aes_reqctx *rctx = aead_request_ctx(req);\r\nsize_t ivsize = crypto_aead_ivsize(tfm);\r\nsize_t datalen, padlen;\r\nconst void *iv = req->iv;\r\nu8 *data = dd->buf;\r\nint err;\r\natmel_aes_set_mode(dd, rctx);\r\nerr = atmel_aes_hw_init(dd);\r\nif (err)\r\nreturn atmel_aes_complete(dd, err);\r\nif (likely(ivsize == 12)) {\r\nmemcpy(ctx->j0, iv, ivsize);\r\nctx->j0[3] = cpu_to_be32(1);\r\nreturn atmel_aes_gcm_process(dd);\r\n}\r\npadlen = atmel_aes_padlen(ivsize, AES_BLOCK_SIZE);\r\ndatalen = ivsize + padlen + AES_BLOCK_SIZE;\r\nif (datalen > dd->buflen)\r\nreturn atmel_aes_complete(dd, -EINVAL);\r\nmemcpy(data, iv, ivsize);\r\nmemset(data + ivsize, 0, padlen + sizeof(u64));\r\n((u64 *)(data + datalen))[-1] = cpu_to_be64(ivsize * 8);\r\nreturn atmel_aes_gcm_ghash(dd, (const u32 *)data, datalen,\r\nNULL, ctx->j0, atmel_aes_gcm_process);\r\n}\r\nstatic int atmel_aes_gcm_process(struct atmel_aes_dev *dd)\r\n{\r\nstruct atmel_aes_gcm_ctx *ctx = atmel_aes_gcm_ctx_cast(dd->ctx);\r\nstruct aead_request *req = aead_request_cast(dd->areq);\r\nstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\r\nbool enc = atmel_aes_is_encrypt(dd);\r\nu32 authsize;\r\nauthsize = crypto_aead_authsize(tfm);\r\nctx->textlen = req->cryptlen - (enc ? 0 : authsize);\r\nif (likely(req->assoclen != 0 || ctx->textlen != 0))\r\ndd->flags |= AES_FLAGS_GTAGEN;\r\natmel_aes_write_ctrl(dd, false, NULL);\r\nreturn atmel_aes_wait_for_data_ready(dd, atmel_aes_gcm_length);\r\n}\r\nstatic int atmel_aes_gcm_length(struct atmel_aes_dev *dd)\r\n{\r\nstruct atmel_aes_gcm_ctx *ctx = atmel_aes_gcm_ctx_cast(dd->ctx);\r\nstruct aead_request *req = aead_request_cast(dd->areq);\r\nu32 j0_lsw, *j0 = ctx->j0;\r\nsize_t padlen;\r\nj0_lsw = j0[3];\r\nj0[3] = cpu_to_be32(be32_to_cpu(j0[3]) + 1);\r\natmel_aes_write_block(dd, AES_IVR(0), j0);\r\nj0[3] = j0_lsw;\r\natmel_aes_write(dd, AES_AADLENR, req->assoclen);\r\natmel_aes_write(dd, AES_CLENR, ctx->textlen);\r\nif (unlikely(req->assoclen == 0)) {\r\ndd->datalen = 0;\r\nreturn atmel_aes_gcm_data(dd);\r\n}\r\npadlen = atmel_aes_padlen(req->assoclen, AES_BLOCK_SIZE);\r\nif (unlikely(req->assoclen + padlen > dd->buflen))\r\nreturn atmel_aes_complete(dd, -EINVAL);\r\nsg_copy_to_buffer(req->src, sg_nents(req->src), dd->buf, req->assoclen);\r\ndd->data = (u32 *)dd->buf;\r\ndd->datalen = req->assoclen + padlen;\r\nreturn atmel_aes_gcm_data(dd);\r\n}\r\nstatic int atmel_aes_gcm_data(struct atmel_aes_dev *dd)\r\n{\r\nstruct atmel_aes_gcm_ctx *ctx = atmel_aes_gcm_ctx_cast(dd->ctx);\r\nstruct aead_request *req = aead_request_cast(dd->areq);\r\nbool use_dma = (ctx->textlen >= ATMEL_AES_DMA_THRESHOLD);\r\nstruct scatterlist *src, *dst;\r\nu32 isr, mr;\r\nwhile (dd->datalen > 0) {\r\natmel_aes_write_block(dd, AES_IDATAR(0), dd->data);\r\ndd->data += 4;\r\ndd->datalen -= AES_BLOCK_SIZE;\r\nisr = atmel_aes_read(dd, AES_ISR);\r\nif (!(isr & AES_INT_DATARDY)) {\r\ndd->resume = atmel_aes_gcm_data;\r\natmel_aes_write(dd, AES_IER, AES_INT_DATARDY);\r\nreturn -EINPROGRESS;\r\n}\r\n}\r\nif (unlikely(ctx->textlen == 0))\r\nreturn atmel_aes_gcm_tag_init(dd);\r\nsrc = scatterwalk_ffwd(ctx->src, req->src, req->assoclen);\r\ndst = ((req->src == req->dst) ? src :\r\nscatterwalk_ffwd(ctx->dst, req->dst, req->assoclen));\r\nif (use_dma) {\r\nmr = atmel_aes_read(dd, AES_MR);\r\nmr &= ~(AES_MR_SMOD_MASK | AES_MR_DUALBUFF);\r\nmr |= AES_MR_SMOD_IDATAR0;\r\nif (dd->caps.has_dualbuff)\r\nmr |= AES_MR_DUALBUFF;\r\natmel_aes_write(dd, AES_MR, mr);\r\nreturn atmel_aes_dma_start(dd, src, dst, ctx->textlen,\r\natmel_aes_gcm_tag_init);\r\n}\r\nreturn atmel_aes_cpu_start(dd, src, dst, ctx->textlen,\r\natmel_aes_gcm_tag_init);\r\n}\r\nstatic int atmel_aes_gcm_tag_init(struct atmel_aes_dev *dd)\r\n{\r\nstruct atmel_aes_gcm_ctx *ctx = atmel_aes_gcm_ctx_cast(dd->ctx);\r\nstruct aead_request *req = aead_request_cast(dd->areq);\r\nu64 *data = dd->buf;\r\nif (likely(dd->flags & AES_FLAGS_GTAGEN)) {\r\nif (!(atmel_aes_read(dd, AES_ISR) & AES_INT_TAGRDY)) {\r\ndd->resume = atmel_aes_gcm_tag_init;\r\natmel_aes_write(dd, AES_IER, AES_INT_TAGRDY);\r\nreturn -EINPROGRESS;\r\n}\r\nreturn atmel_aes_gcm_finalize(dd);\r\n}\r\natmel_aes_read_block(dd, AES_GHASHR(0), ctx->ghash);\r\ndata[0] = cpu_to_be64(req->assoclen * 8);\r\ndata[1] = cpu_to_be64(ctx->textlen * 8);\r\nreturn atmel_aes_gcm_ghash(dd, (const u32 *)data, AES_BLOCK_SIZE,\r\nctx->ghash, ctx->ghash, atmel_aes_gcm_tag);\r\n}\r\nstatic int atmel_aes_gcm_tag(struct atmel_aes_dev *dd)\r\n{\r\nstruct atmel_aes_gcm_ctx *ctx = atmel_aes_gcm_ctx_cast(dd->ctx);\r\nunsigned long flags;\r\nflags = dd->flags;\r\ndd->flags &= ~(AES_FLAGS_OPMODE_MASK | AES_FLAGS_GTAGEN);\r\ndd->flags |= AES_FLAGS_CTR;\r\natmel_aes_write_ctrl(dd, false, ctx->j0);\r\ndd->flags = flags;\r\natmel_aes_write_block(dd, AES_IDATAR(0), ctx->ghash);\r\nreturn atmel_aes_wait_for_data_ready(dd, atmel_aes_gcm_finalize);\r\n}\r\nstatic int atmel_aes_gcm_finalize(struct atmel_aes_dev *dd)\r\n{\r\nstruct atmel_aes_gcm_ctx *ctx = atmel_aes_gcm_ctx_cast(dd->ctx);\r\nstruct aead_request *req = aead_request_cast(dd->areq);\r\nstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\r\nbool enc = atmel_aes_is_encrypt(dd);\r\nu32 offset, authsize, itag[4], *otag = ctx->tag;\r\nint err;\r\nif (likely(dd->flags & AES_FLAGS_GTAGEN))\r\natmel_aes_read_block(dd, AES_TAGR(0), ctx->tag);\r\nelse\r\natmel_aes_read_block(dd, AES_ODATAR(0), ctx->tag);\r\noffset = req->assoclen + ctx->textlen;\r\nauthsize = crypto_aead_authsize(tfm);\r\nif (enc) {\r\nscatterwalk_map_and_copy(otag, req->dst, offset, authsize, 1);\r\nerr = 0;\r\n} else {\r\nscatterwalk_map_and_copy(itag, req->src, offset, authsize, 0);\r\nerr = crypto_memneq(itag, otag, authsize) ? -EBADMSG : 0;\r\n}\r\nreturn atmel_aes_complete(dd, err);\r\n}\r\nstatic int atmel_aes_gcm_crypt(struct aead_request *req,\r\nunsigned long mode)\r\n{\r\nstruct atmel_aes_base_ctx *ctx;\r\nstruct atmel_aes_reqctx *rctx;\r\nstruct atmel_aes_dev *dd;\r\nctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\r\nctx->block_size = AES_BLOCK_SIZE;\r\ndd = atmel_aes_find_dev(ctx);\r\nif (!dd)\r\nreturn -ENODEV;\r\nrctx = aead_request_ctx(req);\r\nrctx->mode = AES_FLAGS_GCM | mode;\r\nreturn atmel_aes_handle_queue(dd, &req->base);\r\n}\r\nstatic int atmel_aes_gcm_setkey(struct crypto_aead *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct atmel_aes_base_ctx *ctx = crypto_aead_ctx(tfm);\r\nif (keylen != AES_KEYSIZE_256 &&\r\nkeylen != AES_KEYSIZE_192 &&\r\nkeylen != AES_KEYSIZE_128) {\r\ncrypto_aead_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(ctx->key, key, keylen);\r\nctx->keylen = keylen;\r\nreturn 0;\r\n}\r\nstatic int atmel_aes_gcm_setauthsize(struct crypto_aead *tfm,\r\nunsigned int authsize)\r\n{\r\nswitch (authsize) {\r\ncase 4:\r\ncase 8:\r\ncase 12:\r\ncase 13:\r\ncase 14:\r\ncase 15:\r\ncase 16:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int atmel_aes_gcm_encrypt(struct aead_request *req)\r\n{\r\nreturn atmel_aes_gcm_crypt(req, AES_FLAGS_ENCRYPT);\r\n}\r\nstatic int atmel_aes_gcm_decrypt(struct aead_request *req)\r\n{\r\nreturn atmel_aes_gcm_crypt(req, 0);\r\n}\r\nstatic int atmel_aes_gcm_init(struct crypto_aead *tfm)\r\n{\r\nstruct atmel_aes_gcm_ctx *ctx = crypto_aead_ctx(tfm);\r\ncrypto_aead_set_reqsize(tfm, sizeof(struct atmel_aes_reqctx));\r\nctx->base.start = atmel_aes_gcm_start;\r\nreturn 0;\r\n}\r\nstatic void atmel_aes_gcm_exit(struct crypto_aead *tfm)\r\n{\r\n}\r\nstatic inline struct atmel_aes_xts_ctx *\r\natmel_aes_xts_ctx_cast(struct atmel_aes_base_ctx *ctx)\r\n{\r\nreturn container_of(ctx, struct atmel_aes_xts_ctx, base);\r\n}\r\nstatic int atmel_aes_xts_start(struct atmel_aes_dev *dd)\r\n{\r\nstruct atmel_aes_xts_ctx *ctx = atmel_aes_xts_ctx_cast(dd->ctx);\r\nstruct ablkcipher_request *req = ablkcipher_request_cast(dd->areq);\r\nstruct atmel_aes_reqctx *rctx = ablkcipher_request_ctx(req);\r\nunsigned long flags;\r\nint err;\r\natmel_aes_set_mode(dd, rctx);\r\nerr = atmel_aes_hw_init(dd);\r\nif (err)\r\nreturn atmel_aes_complete(dd, err);\r\nflags = dd->flags;\r\ndd->flags &= ~AES_FLAGS_MODE_MASK;\r\ndd->flags |= (AES_FLAGS_ECB | AES_FLAGS_ENCRYPT);\r\natmel_aes_write_ctrl_key(dd, false, NULL,\r\nctx->key2, ctx->base.keylen);\r\ndd->flags = flags;\r\natmel_aes_write_block(dd, AES_IDATAR(0), req->info);\r\nreturn atmel_aes_wait_for_data_ready(dd, atmel_aes_xts_process_data);\r\n}\r\nstatic int atmel_aes_xts_process_data(struct atmel_aes_dev *dd)\r\n{\r\nstruct ablkcipher_request *req = ablkcipher_request_cast(dd->areq);\r\nbool use_dma = (req->nbytes >= ATMEL_AES_DMA_THRESHOLD);\r\nu32 tweak[AES_BLOCK_SIZE / sizeof(u32)];\r\nstatic const u32 one[AES_BLOCK_SIZE / sizeof(u32)] = {cpu_to_le32(1), };\r\nu8 *tweak_bytes = (u8 *)tweak;\r\nint i;\r\natmel_aes_read_block(dd, AES_ODATAR(0), tweak);\r\nfor (i = 0; i < AES_BLOCK_SIZE/2; ++i) {\r\nu8 tmp = tweak_bytes[AES_BLOCK_SIZE - 1 - i];\r\ntweak_bytes[AES_BLOCK_SIZE - 1 - i] = tweak_bytes[i];\r\ntweak_bytes[i] = tmp;\r\n}\r\natmel_aes_write_ctrl(dd, use_dma, NULL);\r\natmel_aes_write_block(dd, AES_TWR(0), tweak);\r\natmel_aes_write_block(dd, AES_ALPHAR(0), one);\r\nif (use_dma)\r\nreturn atmel_aes_dma_start(dd, req->src, req->dst, req->nbytes,\r\natmel_aes_transfer_complete);\r\nreturn atmel_aes_cpu_start(dd, req->src, req->dst, req->nbytes,\r\natmel_aes_transfer_complete);\r\n}\r\nstatic int atmel_aes_xts_setkey(struct crypto_ablkcipher *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct atmel_aes_xts_ctx *ctx = crypto_ablkcipher_ctx(tfm);\r\nint err;\r\nerr = xts_check_key(crypto_ablkcipher_tfm(tfm), key, keylen);\r\nif (err)\r\nreturn err;\r\nmemcpy(ctx->base.key, key, keylen/2);\r\nmemcpy(ctx->key2, key + keylen/2, keylen/2);\r\nctx->base.keylen = keylen/2;\r\nreturn 0;\r\n}\r\nstatic int atmel_aes_xts_encrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_aes_crypt(req, AES_FLAGS_XTS | AES_FLAGS_ENCRYPT);\r\n}\r\nstatic int atmel_aes_xts_decrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_aes_crypt(req, AES_FLAGS_XTS);\r\n}\r\nstatic int atmel_aes_xts_cra_init(struct crypto_tfm *tfm)\r\n{\r\nstruct atmel_aes_xts_ctx *ctx = crypto_tfm_ctx(tfm);\r\ntfm->crt_ablkcipher.reqsize = sizeof(struct atmel_aes_reqctx);\r\nctx->base.start = atmel_aes_xts_start;\r\nreturn 0;\r\n}\r\nstatic void atmel_aes_authenc_complete(struct atmel_aes_dev *dd, int err)\r\n{\r\nstruct aead_request *req = aead_request_cast(dd->areq);\r\nstruct atmel_aes_authenc_reqctx *rctx = aead_request_ctx(req);\r\nif (err && (dd->flags & AES_FLAGS_OWN_SHA))\r\natmel_sha_authenc_abort(&rctx->auth_req);\r\ndd->flags &= ~AES_FLAGS_OWN_SHA;\r\n}\r\nstatic int atmel_aes_authenc_start(struct atmel_aes_dev *dd)\r\n{\r\nstruct aead_request *req = aead_request_cast(dd->areq);\r\nstruct atmel_aes_authenc_reqctx *rctx = aead_request_ctx(req);\r\nstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\r\nstruct atmel_aes_authenc_ctx *ctx = crypto_aead_ctx(tfm);\r\nint err;\r\natmel_aes_set_mode(dd, &rctx->base);\r\nerr = atmel_aes_hw_init(dd);\r\nif (err)\r\nreturn atmel_aes_complete(dd, err);\r\nreturn atmel_sha_authenc_schedule(&rctx->auth_req, ctx->auth,\r\natmel_aes_authenc_init, dd);\r\n}\r\nstatic int atmel_aes_authenc_init(struct atmel_aes_dev *dd, int err,\r\nbool is_async)\r\n{\r\nstruct aead_request *req = aead_request_cast(dd->areq);\r\nstruct atmel_aes_authenc_reqctx *rctx = aead_request_ctx(req);\r\nif (is_async)\r\ndd->is_async = true;\r\nif (err)\r\nreturn atmel_aes_complete(dd, err);\r\ndd->flags |= AES_FLAGS_OWN_SHA;\r\nreturn atmel_sha_authenc_init(&rctx->auth_req,\r\nreq->src, req->assoclen,\r\nrctx->textlen,\r\natmel_aes_authenc_transfer, dd);\r\n}\r\nstatic int atmel_aes_authenc_transfer(struct atmel_aes_dev *dd, int err,\r\nbool is_async)\r\n{\r\nstruct aead_request *req = aead_request_cast(dd->areq);\r\nstruct atmel_aes_authenc_reqctx *rctx = aead_request_ctx(req);\r\nbool enc = atmel_aes_is_encrypt(dd);\r\nstruct scatterlist *src, *dst;\r\nu32 iv[AES_BLOCK_SIZE / sizeof(u32)];\r\nu32 emr;\r\nif (is_async)\r\ndd->is_async = true;\r\nif (err)\r\nreturn atmel_aes_complete(dd, err);\r\nsrc = scatterwalk_ffwd(rctx->src, req->src, req->assoclen);\r\ndst = src;\r\nif (req->src != req->dst)\r\ndst = scatterwalk_ffwd(rctx->dst, req->dst, req->assoclen);\r\nmemcpy(iv, req->iv, sizeof(iv));\r\natmel_aes_write_ctrl(dd, true, iv);\r\nemr = AES_EMR_PLIPEN;\r\nif (!enc)\r\nemr |= AES_EMR_PLIPD;\r\natmel_aes_write(dd, AES_EMR, emr);\r\nreturn atmel_aes_dma_start(dd, src, dst, rctx->textlen,\r\natmel_aes_authenc_digest);\r\n}\r\nstatic int atmel_aes_authenc_digest(struct atmel_aes_dev *dd)\r\n{\r\nstruct aead_request *req = aead_request_cast(dd->areq);\r\nstruct atmel_aes_authenc_reqctx *rctx = aead_request_ctx(req);\r\ndd->flags &= ~AES_FLAGS_OWN_SHA;\r\nreturn atmel_sha_authenc_final(&rctx->auth_req,\r\nrctx->digest, sizeof(rctx->digest),\r\natmel_aes_authenc_final, dd);\r\n}\r\nstatic int atmel_aes_authenc_final(struct atmel_aes_dev *dd, int err,\r\nbool is_async)\r\n{\r\nstruct aead_request *req = aead_request_cast(dd->areq);\r\nstruct atmel_aes_authenc_reqctx *rctx = aead_request_ctx(req);\r\nstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\r\nbool enc = atmel_aes_is_encrypt(dd);\r\nu32 idigest[SHA512_DIGEST_SIZE / sizeof(u32)], *odigest = rctx->digest;\r\nu32 offs, authsize;\r\nif (is_async)\r\ndd->is_async = true;\r\nif (err)\r\ngoto complete;\r\noffs = req->assoclen + rctx->textlen;\r\nauthsize = crypto_aead_authsize(tfm);\r\nif (enc) {\r\nscatterwalk_map_and_copy(odigest, req->dst, offs, authsize, 1);\r\n} else {\r\nscatterwalk_map_and_copy(idigest, req->src, offs, authsize, 0);\r\nif (crypto_memneq(idigest, odigest, authsize))\r\nerr = -EBADMSG;\r\n}\r\ncomplete:\r\nreturn atmel_aes_complete(dd, err);\r\n}\r\nstatic int atmel_aes_authenc_setkey(struct crypto_aead *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct atmel_aes_authenc_ctx *ctx = crypto_aead_ctx(tfm);\r\nstruct crypto_authenc_keys keys;\r\nu32 flags;\r\nint err;\r\nif (crypto_authenc_extractkeys(&keys, key, keylen) != 0)\r\ngoto badkey;\r\nif (keys.enckeylen > sizeof(ctx->base.key))\r\ngoto badkey;\r\nflags = crypto_aead_get_flags(tfm);\r\nerr = atmel_sha_authenc_setkey(ctx->auth,\r\nkeys.authkey, keys.authkeylen,\r\n&flags);\r\ncrypto_aead_set_flags(tfm, flags & CRYPTO_TFM_RES_MASK);\r\nif (err) {\r\nmemzero_explicit(&keys, sizeof(keys));\r\nreturn err;\r\n}\r\nctx->base.keylen = keys.enckeylen;\r\nmemcpy(ctx->base.key, keys.enckey, keys.enckeylen);\r\nmemzero_explicit(&keys, sizeof(keys));\r\nreturn 0;\r\nbadkey:\r\ncrypto_aead_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nmemzero_explicit(&key, sizeof(keys));\r\nreturn -EINVAL;\r\n}\r\nstatic int atmel_aes_authenc_init_tfm(struct crypto_aead *tfm,\r\nunsigned long auth_mode)\r\n{\r\nstruct atmel_aes_authenc_ctx *ctx = crypto_aead_ctx(tfm);\r\nunsigned int auth_reqsize = atmel_sha_authenc_get_reqsize();\r\nctx->auth = atmel_sha_authenc_spawn(auth_mode);\r\nif (IS_ERR(ctx->auth))\r\nreturn PTR_ERR(ctx->auth);\r\ncrypto_aead_set_reqsize(tfm, (sizeof(struct atmel_aes_authenc_reqctx) +\r\nauth_reqsize));\r\nctx->base.start = atmel_aes_authenc_start;\r\nreturn 0;\r\n}\r\nstatic int atmel_aes_authenc_hmac_sha1_init_tfm(struct crypto_aead *tfm)\r\n{\r\nreturn atmel_aes_authenc_init_tfm(tfm, SHA_FLAGS_HMAC_SHA1);\r\n}\r\nstatic int atmel_aes_authenc_hmac_sha224_init_tfm(struct crypto_aead *tfm)\r\n{\r\nreturn atmel_aes_authenc_init_tfm(tfm, SHA_FLAGS_HMAC_SHA224);\r\n}\r\nstatic int atmel_aes_authenc_hmac_sha256_init_tfm(struct crypto_aead *tfm)\r\n{\r\nreturn atmel_aes_authenc_init_tfm(tfm, SHA_FLAGS_HMAC_SHA256);\r\n}\r\nstatic int atmel_aes_authenc_hmac_sha384_init_tfm(struct crypto_aead *tfm)\r\n{\r\nreturn atmel_aes_authenc_init_tfm(tfm, SHA_FLAGS_HMAC_SHA384);\r\n}\r\nstatic int atmel_aes_authenc_hmac_sha512_init_tfm(struct crypto_aead *tfm)\r\n{\r\nreturn atmel_aes_authenc_init_tfm(tfm, SHA_FLAGS_HMAC_SHA512);\r\n}\r\nstatic void atmel_aes_authenc_exit_tfm(struct crypto_aead *tfm)\r\n{\r\nstruct atmel_aes_authenc_ctx *ctx = crypto_aead_ctx(tfm);\r\natmel_sha_authenc_free(ctx->auth);\r\n}\r\nstatic int atmel_aes_authenc_crypt(struct aead_request *req,\r\nunsigned long mode)\r\n{\r\nstruct atmel_aes_authenc_reqctx *rctx = aead_request_ctx(req);\r\nstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\r\nstruct atmel_aes_base_ctx *ctx = crypto_aead_ctx(tfm);\r\nu32 authsize = crypto_aead_authsize(tfm);\r\nbool enc = (mode & AES_FLAGS_ENCRYPT);\r\nstruct atmel_aes_dev *dd;\r\nif (!enc && req->cryptlen < authsize)\r\nreturn -EINVAL;\r\nrctx->textlen = req->cryptlen - (enc ? 0 : authsize);\r\nif (!rctx->textlen && !req->assoclen)\r\nreturn -EINVAL;\r\nrctx->base.mode = mode;\r\nctx->block_size = AES_BLOCK_SIZE;\r\ndd = atmel_aes_find_dev(ctx);\r\nif (!dd)\r\nreturn -ENODEV;\r\nreturn atmel_aes_handle_queue(dd, &req->base);\r\n}\r\nstatic int atmel_aes_authenc_cbc_aes_encrypt(struct aead_request *req)\r\n{\r\nreturn atmel_aes_authenc_crypt(req, AES_FLAGS_CBC | AES_FLAGS_ENCRYPT);\r\n}\r\nstatic int atmel_aes_authenc_cbc_aes_decrypt(struct aead_request *req)\r\n{\r\nreturn atmel_aes_authenc_crypt(req, AES_FLAGS_CBC);\r\n}\r\nstatic int atmel_aes_buff_init(struct atmel_aes_dev *dd)\r\n{\r\ndd->buf = (void *)__get_free_pages(GFP_KERNEL, ATMEL_AES_BUFFER_ORDER);\r\ndd->buflen = ATMEL_AES_BUFFER_SIZE;\r\ndd->buflen &= ~(AES_BLOCK_SIZE - 1);\r\nif (!dd->buf) {\r\ndev_err(dd->dev, "unable to alloc pages.\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void atmel_aes_buff_cleanup(struct atmel_aes_dev *dd)\r\n{\r\nfree_page((unsigned long)dd->buf);\r\n}\r\nstatic bool atmel_aes_filter(struct dma_chan *chan, void *slave)\r\n{\r\nstruct at_dma_slave *sl = slave;\r\nif (sl && sl->dma_dev == chan->device->dev) {\r\nchan->private = sl;\r\nreturn true;\r\n} else {\r\nreturn false;\r\n}\r\n}\r\nstatic int atmel_aes_dma_init(struct atmel_aes_dev *dd,\r\nstruct crypto_platform_data *pdata)\r\n{\r\nstruct at_dma_slave *slave;\r\nint err = -ENOMEM;\r\ndma_cap_mask_t mask;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nslave = &pdata->dma_slave->rxdata;\r\ndd->src.chan = dma_request_slave_channel_compat(mask, atmel_aes_filter,\r\nslave, dd->dev, "tx");\r\nif (!dd->src.chan)\r\ngoto err_dma_in;\r\nslave = &pdata->dma_slave->txdata;\r\ndd->dst.chan = dma_request_slave_channel_compat(mask, atmel_aes_filter,\r\nslave, dd->dev, "rx");\r\nif (!dd->dst.chan)\r\ngoto err_dma_out;\r\nreturn 0;\r\nerr_dma_out:\r\ndma_release_channel(dd->src.chan);\r\nerr_dma_in:\r\ndev_warn(dd->dev, "no DMA channel available\n");\r\nreturn err;\r\n}\r\nstatic void atmel_aes_dma_cleanup(struct atmel_aes_dev *dd)\r\n{\r\ndma_release_channel(dd->dst.chan);\r\ndma_release_channel(dd->src.chan);\r\n}\r\nstatic void atmel_aes_queue_task(unsigned long data)\r\n{\r\nstruct atmel_aes_dev *dd = (struct atmel_aes_dev *)data;\r\natmel_aes_handle_queue(dd, NULL);\r\n}\r\nstatic void atmel_aes_done_task(unsigned long data)\r\n{\r\nstruct atmel_aes_dev *dd = (struct atmel_aes_dev *)data;\r\ndd->is_async = true;\r\n(void)dd->resume(dd);\r\n}\r\nstatic irqreturn_t atmel_aes_irq(int irq, void *dev_id)\r\n{\r\nstruct atmel_aes_dev *aes_dd = dev_id;\r\nu32 reg;\r\nreg = atmel_aes_read(aes_dd, AES_ISR);\r\nif (reg & atmel_aes_read(aes_dd, AES_IMR)) {\r\natmel_aes_write(aes_dd, AES_IDR, reg);\r\nif (AES_FLAGS_BUSY & aes_dd->flags)\r\ntasklet_schedule(&aes_dd->done_task);\r\nelse\r\ndev_warn(aes_dd->dev, "AES interrupt when no active requests.\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic void atmel_aes_unregister_algs(struct atmel_aes_dev *dd)\r\n{\r\nint i;\r\n#ifdef CONFIG_CRYPTO_DEV_ATMEL_AUTHENC\r\nif (dd->caps.has_authenc)\r\nfor (i = 0; i < ARRAY_SIZE(aes_authenc_algs); i++)\r\ncrypto_unregister_aead(&aes_authenc_algs[i]);\r\n#endif\r\nif (dd->caps.has_xts)\r\ncrypto_unregister_alg(&aes_xts_alg);\r\nif (dd->caps.has_gcm)\r\ncrypto_unregister_aead(&aes_gcm_alg);\r\nif (dd->caps.has_cfb64)\r\ncrypto_unregister_alg(&aes_cfb64_alg);\r\nfor (i = 0; i < ARRAY_SIZE(aes_algs); i++)\r\ncrypto_unregister_alg(&aes_algs[i]);\r\n}\r\nstatic int atmel_aes_register_algs(struct atmel_aes_dev *dd)\r\n{\r\nint err, i, j;\r\nfor (i = 0; i < ARRAY_SIZE(aes_algs); i++) {\r\nerr = crypto_register_alg(&aes_algs[i]);\r\nif (err)\r\ngoto err_aes_algs;\r\n}\r\nif (dd->caps.has_cfb64) {\r\nerr = crypto_register_alg(&aes_cfb64_alg);\r\nif (err)\r\ngoto err_aes_cfb64_alg;\r\n}\r\nif (dd->caps.has_gcm) {\r\nerr = crypto_register_aead(&aes_gcm_alg);\r\nif (err)\r\ngoto err_aes_gcm_alg;\r\n}\r\nif (dd->caps.has_xts) {\r\nerr = crypto_register_alg(&aes_xts_alg);\r\nif (err)\r\ngoto err_aes_xts_alg;\r\n}\r\n#ifdef CONFIG_CRYPTO_DEV_ATMEL_AUTHENC\r\nif (dd->caps.has_authenc) {\r\nfor (i = 0; i < ARRAY_SIZE(aes_authenc_algs); i++) {\r\nerr = crypto_register_aead(&aes_authenc_algs[i]);\r\nif (err)\r\ngoto err_aes_authenc_alg;\r\n}\r\n}\r\n#endif\r\nreturn 0;\r\n#ifdef CONFIG_CRYPTO_DEV_ATMEL_AUTHENC\r\nerr_aes_authenc_alg:\r\nfor (j = 0; j < i; j++)\r\ncrypto_unregister_aead(&aes_authenc_algs[j]);\r\ncrypto_unregister_alg(&aes_xts_alg);\r\n#endif\r\nerr_aes_xts_alg:\r\ncrypto_unregister_aead(&aes_gcm_alg);\r\nerr_aes_gcm_alg:\r\ncrypto_unregister_alg(&aes_cfb64_alg);\r\nerr_aes_cfb64_alg:\r\ni = ARRAY_SIZE(aes_algs);\r\nerr_aes_algs:\r\nfor (j = 0; j < i; j++)\r\ncrypto_unregister_alg(&aes_algs[j]);\r\nreturn err;\r\n}\r\nstatic void atmel_aes_get_cap(struct atmel_aes_dev *dd)\r\n{\r\ndd->caps.has_dualbuff = 0;\r\ndd->caps.has_cfb64 = 0;\r\ndd->caps.has_ctr32 = 0;\r\ndd->caps.has_gcm = 0;\r\ndd->caps.has_xts = 0;\r\ndd->caps.has_authenc = 0;\r\ndd->caps.max_burst_size = 1;\r\nswitch (dd->hw_version & 0xff0) {\r\ncase 0x500:\r\ndd->caps.has_dualbuff = 1;\r\ndd->caps.has_cfb64 = 1;\r\ndd->caps.has_ctr32 = 1;\r\ndd->caps.has_gcm = 1;\r\ndd->caps.has_xts = 1;\r\ndd->caps.has_authenc = 1;\r\ndd->caps.max_burst_size = 4;\r\nbreak;\r\ncase 0x200:\r\ndd->caps.has_dualbuff = 1;\r\ndd->caps.has_cfb64 = 1;\r\ndd->caps.has_ctr32 = 1;\r\ndd->caps.has_gcm = 1;\r\ndd->caps.max_burst_size = 4;\r\nbreak;\r\ncase 0x130:\r\ndd->caps.has_dualbuff = 1;\r\ndd->caps.has_cfb64 = 1;\r\ndd->caps.max_burst_size = 4;\r\nbreak;\r\ncase 0x120:\r\nbreak;\r\ndefault:\r\ndev_warn(dd->dev,\r\n"Unmanaged aes version, set minimum capabilities\n");\r\nbreak;\r\n}\r\n}\r\nstatic struct crypto_platform_data *atmel_aes_of_init(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct crypto_platform_data *pdata;\r\nif (!np) {\r\ndev_err(&pdev->dev, "device node not found\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "could not allocate memory for pdata\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\npdata->dma_slave = devm_kzalloc(&pdev->dev,\r\nsizeof(*(pdata->dma_slave)),\r\nGFP_KERNEL);\r\nif (!pdata->dma_slave) {\r\ndev_err(&pdev->dev, "could not allocate memory for dma_slave\n");\r\ndevm_kfree(&pdev->dev, pdata);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nreturn pdata;\r\n}\r\nstatic inline struct crypto_platform_data *atmel_aes_of_init(struct platform_device *pdev)\r\n{\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic int atmel_aes_probe(struct platform_device *pdev)\r\n{\r\nstruct atmel_aes_dev *aes_dd;\r\nstruct crypto_platform_data *pdata;\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *aes_res;\r\nint err;\r\npdata = pdev->dev.platform_data;\r\nif (!pdata) {\r\npdata = atmel_aes_of_init(pdev);\r\nif (IS_ERR(pdata)) {\r\nerr = PTR_ERR(pdata);\r\ngoto aes_dd_err;\r\n}\r\n}\r\nif (!pdata->dma_slave) {\r\nerr = -ENXIO;\r\ngoto aes_dd_err;\r\n}\r\naes_dd = devm_kzalloc(&pdev->dev, sizeof(*aes_dd), GFP_KERNEL);\r\nif (aes_dd == NULL) {\r\ndev_err(dev, "unable to alloc data struct.\n");\r\nerr = -ENOMEM;\r\ngoto aes_dd_err;\r\n}\r\naes_dd->dev = dev;\r\nplatform_set_drvdata(pdev, aes_dd);\r\nINIT_LIST_HEAD(&aes_dd->list);\r\nspin_lock_init(&aes_dd->lock);\r\ntasklet_init(&aes_dd->done_task, atmel_aes_done_task,\r\n(unsigned long)aes_dd);\r\ntasklet_init(&aes_dd->queue_task, atmel_aes_queue_task,\r\n(unsigned long)aes_dd);\r\ncrypto_init_queue(&aes_dd->queue, ATMEL_AES_QUEUE_LENGTH);\r\naes_dd->irq = -1;\r\naes_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!aes_res) {\r\ndev_err(dev, "no MEM resource info\n");\r\nerr = -ENODEV;\r\ngoto res_err;\r\n}\r\naes_dd->phys_base = aes_res->start;\r\naes_dd->irq = platform_get_irq(pdev, 0);\r\nif (aes_dd->irq < 0) {\r\ndev_err(dev, "no IRQ resource info\n");\r\nerr = aes_dd->irq;\r\ngoto res_err;\r\n}\r\nerr = devm_request_irq(&pdev->dev, aes_dd->irq, atmel_aes_irq,\r\nIRQF_SHARED, "atmel-aes", aes_dd);\r\nif (err) {\r\ndev_err(dev, "unable to request aes irq.\n");\r\ngoto res_err;\r\n}\r\naes_dd->iclk = devm_clk_get(&pdev->dev, "aes_clk");\r\nif (IS_ERR(aes_dd->iclk)) {\r\ndev_err(dev, "clock initialization failed.\n");\r\nerr = PTR_ERR(aes_dd->iclk);\r\ngoto res_err;\r\n}\r\naes_dd->io_base = devm_ioremap_resource(&pdev->dev, aes_res);\r\nif (IS_ERR(aes_dd->io_base)) {\r\ndev_err(dev, "can't ioremap\n");\r\nerr = PTR_ERR(aes_dd->io_base);\r\ngoto res_err;\r\n}\r\nerr = clk_prepare(aes_dd->iclk);\r\nif (err)\r\ngoto res_err;\r\nerr = atmel_aes_hw_version_init(aes_dd);\r\nif (err)\r\ngoto iclk_unprepare;\r\natmel_aes_get_cap(aes_dd);\r\n#ifdef CONFIG_CRYPTO_DEV_ATMEL_AUTHENC\r\nif (aes_dd->caps.has_authenc && !atmel_sha_authenc_is_ready()) {\r\nerr = -EPROBE_DEFER;\r\ngoto iclk_unprepare;\r\n}\r\n#endif\r\nerr = atmel_aes_buff_init(aes_dd);\r\nif (err)\r\ngoto err_aes_buff;\r\nerr = atmel_aes_dma_init(aes_dd, pdata);\r\nif (err)\r\ngoto err_aes_dma;\r\nspin_lock(&atmel_aes.lock);\r\nlist_add_tail(&aes_dd->list, &atmel_aes.dev_list);\r\nspin_unlock(&atmel_aes.lock);\r\nerr = atmel_aes_register_algs(aes_dd);\r\nif (err)\r\ngoto err_algs;\r\ndev_info(dev, "Atmel AES - Using %s, %s for DMA transfers\n",\r\ndma_chan_name(aes_dd->src.chan),\r\ndma_chan_name(aes_dd->dst.chan));\r\nreturn 0;\r\nerr_algs:\r\nspin_lock(&atmel_aes.lock);\r\nlist_del(&aes_dd->list);\r\nspin_unlock(&atmel_aes.lock);\r\natmel_aes_dma_cleanup(aes_dd);\r\nerr_aes_dma:\r\natmel_aes_buff_cleanup(aes_dd);\r\nerr_aes_buff:\r\niclk_unprepare:\r\nclk_unprepare(aes_dd->iclk);\r\nres_err:\r\ntasklet_kill(&aes_dd->done_task);\r\ntasklet_kill(&aes_dd->queue_task);\r\naes_dd_err:\r\nif (err != -EPROBE_DEFER)\r\ndev_err(dev, "initialization failed.\n");\r\nreturn err;\r\n}\r\nstatic int atmel_aes_remove(struct platform_device *pdev)\r\n{\r\nstruct atmel_aes_dev *aes_dd;\r\naes_dd = platform_get_drvdata(pdev);\r\nif (!aes_dd)\r\nreturn -ENODEV;\r\nspin_lock(&atmel_aes.lock);\r\nlist_del(&aes_dd->list);\r\nspin_unlock(&atmel_aes.lock);\r\natmel_aes_unregister_algs(aes_dd);\r\ntasklet_kill(&aes_dd->done_task);\r\ntasklet_kill(&aes_dd->queue_task);\r\natmel_aes_dma_cleanup(aes_dd);\r\natmel_aes_buff_cleanup(aes_dd);\r\nclk_unprepare(aes_dd->iclk);\r\nreturn 0;\r\n}
