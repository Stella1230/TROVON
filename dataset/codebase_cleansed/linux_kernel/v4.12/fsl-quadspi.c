static inline int needs_swap_endian(struct fsl_qspi *q)\r\n{\r\nreturn q->devtype_data->driver_data & QUADSPI_QUIRK_SWAP_ENDIAN;\r\n}\r\nstatic inline int needs_4x_clock(struct fsl_qspi *q)\r\n{\r\nreturn q->devtype_data->driver_data & QUADSPI_QUIRK_4X_INT_CLK;\r\n}\r\nstatic inline int needs_fill_txfifo(struct fsl_qspi *q)\r\n{\r\nreturn q->devtype_data->driver_data & QUADSPI_QUIRK_TKT253890;\r\n}\r\nstatic inline int needs_wakeup_wait_mode(struct fsl_qspi *q)\r\n{\r\nreturn q->devtype_data->driver_data & QUADSPI_QUIRK_TKT245618;\r\n}\r\nstatic void qspi_writel(struct fsl_qspi *q, u32 val, void __iomem *addr)\r\n{\r\nif (q->big_endian)\r\niowrite32be(val, addr);\r\nelse\r\niowrite32(val, addr);\r\n}\r\nstatic u32 qspi_readl(struct fsl_qspi *q, void __iomem *addr)\r\n{\r\nif (q->big_endian)\r\nreturn ioread32be(addr);\r\nelse\r\nreturn ioread32(addr);\r\n}\r\nstatic inline u32 fsl_qspi_endian_xchg(struct fsl_qspi *q, u32 a)\r\n{\r\nreturn needs_swap_endian(q) ? __swab32(a) : a;\r\n}\r\nstatic inline void fsl_qspi_unlock_lut(struct fsl_qspi *q)\r\n{\r\nqspi_writel(q, QUADSPI_LUTKEY_VALUE, q->iobase + QUADSPI_LUTKEY);\r\nqspi_writel(q, QUADSPI_LCKER_UNLOCK, q->iobase + QUADSPI_LCKCR);\r\n}\r\nstatic inline void fsl_qspi_lock_lut(struct fsl_qspi *q)\r\n{\r\nqspi_writel(q, QUADSPI_LUTKEY_VALUE, q->iobase + QUADSPI_LUTKEY);\r\nqspi_writel(q, QUADSPI_LCKER_LOCK, q->iobase + QUADSPI_LCKCR);\r\n}\r\nstatic irqreturn_t fsl_qspi_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct fsl_qspi *q = dev_id;\r\nu32 reg;\r\nreg = qspi_readl(q, q->iobase + QUADSPI_FR);\r\nqspi_writel(q, reg, q->iobase + QUADSPI_FR);\r\nif (reg & QUADSPI_FR_TFF_MASK)\r\ncomplete(&q->c);\r\ndev_dbg(q->dev, "QUADSPI_FR : 0x%.8x:0x%.8x\n", q->chip_base_addr, reg);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void fsl_qspi_init_lut(struct fsl_qspi *q)\r\n{\r\nvoid __iomem *base = q->iobase;\r\nint rxfifo = q->devtype_data->rxfifo;\r\nu32 lut_base;\r\nint i;\r\nstruct spi_nor *nor = &q->nor[0];\r\nu8 addrlen = (nor->addr_width == 3) ? ADDR24BIT : ADDR32BIT;\r\nu8 read_op = nor->read_opcode;\r\nu8 read_dm = nor->read_dummy;\r\nfsl_qspi_unlock_lut(q);\r\nfor (i = 0; i < QUADSPI_LUT_NUM; i++)\r\nqspi_writel(q, 0, base + QUADSPI_LUT_BASE + i * 4);\r\nlut_base = SEQID_READ * 4;\r\nqspi_writel(q, LUT0(CMD, PAD1, read_op) | LUT1(ADDR, PAD1, addrlen),\r\nbase + QUADSPI_LUT(lut_base));\r\nqspi_writel(q, LUT0(DUMMY, PAD1, read_dm) |\r\nLUT1(FSL_READ, PAD4, rxfifo),\r\nbase + QUADSPI_LUT(lut_base + 1));\r\nlut_base = SEQID_WREN * 4;\r\nqspi_writel(q, LUT0(CMD, PAD1, SPINOR_OP_WREN),\r\nbase + QUADSPI_LUT(lut_base));\r\nlut_base = SEQID_PP * 4;\r\nqspi_writel(q, LUT0(CMD, PAD1, nor->program_opcode) |\r\nLUT1(ADDR, PAD1, addrlen),\r\nbase + QUADSPI_LUT(lut_base));\r\nqspi_writel(q, LUT0(FSL_WRITE, PAD1, 0),\r\nbase + QUADSPI_LUT(lut_base + 1));\r\nlut_base = SEQID_RDSR * 4;\r\nqspi_writel(q, LUT0(CMD, PAD1, SPINOR_OP_RDSR) |\r\nLUT1(FSL_READ, PAD1, 0x1),\r\nbase + QUADSPI_LUT(lut_base));\r\nlut_base = SEQID_SE * 4;\r\nqspi_writel(q, LUT0(CMD, PAD1, nor->erase_opcode) |\r\nLUT1(ADDR, PAD1, addrlen),\r\nbase + QUADSPI_LUT(lut_base));\r\nlut_base = SEQID_CHIP_ERASE * 4;\r\nqspi_writel(q, LUT0(CMD, PAD1, SPINOR_OP_CHIP_ERASE),\r\nbase + QUADSPI_LUT(lut_base));\r\nlut_base = SEQID_RDID * 4;\r\nqspi_writel(q, LUT0(CMD, PAD1, SPINOR_OP_RDID) |\r\nLUT1(FSL_READ, PAD1, 0x8),\r\nbase + QUADSPI_LUT(lut_base));\r\nlut_base = SEQID_WRSR * 4;\r\nqspi_writel(q, LUT0(CMD, PAD1, SPINOR_OP_WRSR) |\r\nLUT1(FSL_WRITE, PAD1, 0x2),\r\nbase + QUADSPI_LUT(lut_base));\r\nlut_base = SEQID_RDCR * 4;\r\nqspi_writel(q, LUT0(CMD, PAD1, SPINOR_OP_RDCR) |\r\nLUT1(FSL_READ, PAD1, 0x1),\r\nbase + QUADSPI_LUT(lut_base));\r\nlut_base = SEQID_WRDI * 4;\r\nqspi_writel(q, LUT0(CMD, PAD1, SPINOR_OP_WRDI),\r\nbase + QUADSPI_LUT(lut_base));\r\nlut_base = SEQID_EN4B * 4;\r\nqspi_writel(q, LUT0(CMD, PAD1, SPINOR_OP_EN4B),\r\nbase + QUADSPI_LUT(lut_base));\r\nlut_base = SEQID_BRWR * 4;\r\nqspi_writel(q, LUT0(CMD, PAD1, SPINOR_OP_BRWR),\r\nbase + QUADSPI_LUT(lut_base));\r\nfsl_qspi_lock_lut(q);\r\n}\r\nstatic int fsl_qspi_get_seqid(struct fsl_qspi *q, u8 cmd)\r\n{\r\nswitch (cmd) {\r\ncase SPINOR_OP_READ_1_1_4:\r\nreturn SEQID_READ;\r\ncase SPINOR_OP_WREN:\r\nreturn SEQID_WREN;\r\ncase SPINOR_OP_WRDI:\r\nreturn SEQID_WRDI;\r\ncase SPINOR_OP_RDSR:\r\nreturn SEQID_RDSR;\r\ncase SPINOR_OP_SE:\r\nreturn SEQID_SE;\r\ncase SPINOR_OP_CHIP_ERASE:\r\nreturn SEQID_CHIP_ERASE;\r\ncase SPINOR_OP_PP:\r\nreturn SEQID_PP;\r\ncase SPINOR_OP_RDID:\r\nreturn SEQID_RDID;\r\ncase SPINOR_OP_WRSR:\r\nreturn SEQID_WRSR;\r\ncase SPINOR_OP_RDCR:\r\nreturn SEQID_RDCR;\r\ncase SPINOR_OP_EN4B:\r\nreturn SEQID_EN4B;\r\ncase SPINOR_OP_BRWR:\r\nreturn SEQID_BRWR;\r\ndefault:\r\nif (cmd == q->nor[0].erase_opcode)\r\nreturn SEQID_SE;\r\ndev_err(q->dev, "Unsupported cmd 0x%.2x\n", cmd);\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nfsl_qspi_runcmd(struct fsl_qspi *q, u8 cmd, unsigned int addr, int len)\r\n{\r\nvoid __iomem *base = q->iobase;\r\nint seqid;\r\nu32 reg, reg2;\r\nint err;\r\ninit_completion(&q->c);\r\ndev_dbg(q->dev, "to 0x%.8x:0x%.8x, len:%d, cmd:%.2x\n",\r\nq->chip_base_addr, addr, len, cmd);\r\nreg = qspi_readl(q, base + QUADSPI_MCR);\r\nqspi_writel(q, q->memmap_phy + q->chip_base_addr + addr,\r\nbase + QUADSPI_SFAR);\r\nqspi_writel(q, QUADSPI_RBCT_WMRK_MASK | QUADSPI_RBCT_RXBRD_USEIPS,\r\nbase + QUADSPI_RBCT);\r\nqspi_writel(q, reg | QUADSPI_MCR_CLR_RXF_MASK, base + QUADSPI_MCR);\r\ndo {\r\nreg2 = qspi_readl(q, base + QUADSPI_SR);\r\nif (reg2 & (QUADSPI_SR_IP_ACC_MASK | QUADSPI_SR_AHB_ACC_MASK)) {\r\nudelay(1);\r\ndev_dbg(q->dev, "The controller is busy, 0x%x\n", reg2);\r\ncontinue;\r\n}\r\nbreak;\r\n} while (1);\r\nseqid = fsl_qspi_get_seqid(q, cmd);\r\nqspi_writel(q, (seqid << QUADSPI_IPCR_SEQID_SHIFT) | len,\r\nbase + QUADSPI_IPCR);\r\nif (!wait_for_completion_timeout(&q->c, msecs_to_jiffies(1000))) {\r\ndev_err(q->dev,\r\n"cmd 0x%.2x timeout, addr@%.8x, FR:0x%.8x, SR:0x%.8x\n",\r\ncmd, addr, qspi_readl(q, base + QUADSPI_FR),\r\nqspi_readl(q, base + QUADSPI_SR));\r\nerr = -ETIMEDOUT;\r\n} else {\r\nerr = 0;\r\n}\r\nqspi_writel(q, reg, base + QUADSPI_MCR);\r\nreturn err;\r\n}\r\nstatic void fsl_qspi_read_data(struct fsl_qspi *q, int len, u8 *rxbuf)\r\n{\r\nu32 tmp;\r\nint i = 0;\r\nwhile (len > 0) {\r\ntmp = qspi_readl(q, q->iobase + QUADSPI_RBDR + i * 4);\r\ntmp = fsl_qspi_endian_xchg(q, tmp);\r\ndev_dbg(q->dev, "chip addr:0x%.8x, rcv:0x%.8x\n",\r\nq->chip_base_addr, tmp);\r\nif (len >= 4) {\r\n*((u32 *)rxbuf) = tmp;\r\nrxbuf += 4;\r\n} else {\r\nmemcpy(rxbuf, &tmp, len);\r\nbreak;\r\n}\r\nlen -= 4;\r\ni++;\r\n}\r\n}\r\nstatic inline void fsl_qspi_invalid(struct fsl_qspi *q)\r\n{\r\nu32 reg;\r\nreg = qspi_readl(q, q->iobase + QUADSPI_MCR);\r\nreg |= QUADSPI_MCR_SWRSTHD_MASK | QUADSPI_MCR_SWRSTSD_MASK;\r\nqspi_writel(q, reg, q->iobase + QUADSPI_MCR);\r\nudelay(1);\r\nreg &= ~(QUADSPI_MCR_SWRSTHD_MASK | QUADSPI_MCR_SWRSTSD_MASK);\r\nqspi_writel(q, reg, q->iobase + QUADSPI_MCR);\r\n}\r\nstatic ssize_t fsl_qspi_nor_write(struct fsl_qspi *q, struct spi_nor *nor,\r\nu8 opcode, unsigned int to, u32 *txbuf,\r\nunsigned count)\r\n{\r\nint ret, i, j;\r\nu32 tmp;\r\ndev_dbg(q->dev, "to 0x%.8x:0x%.8x, len : %d\n",\r\nq->chip_base_addr, to, count);\r\ntmp = qspi_readl(q, q->iobase + QUADSPI_MCR);\r\nqspi_writel(q, tmp | QUADSPI_MCR_CLR_TXF_MASK, q->iobase + QUADSPI_MCR);\r\nfor (j = 0, i = ((count + 3) / 4); j < i; j++) {\r\ntmp = fsl_qspi_endian_xchg(q, *txbuf);\r\nqspi_writel(q, tmp, q->iobase + QUADSPI_TBDR);\r\ntxbuf++;\r\n}\r\nif (needs_fill_txfifo(q))\r\nfor (; i < 4; i++)\r\nqspi_writel(q, tmp, q->iobase + QUADSPI_TBDR);\r\nret = fsl_qspi_runcmd(q, opcode, to, count);\r\nif (ret == 0)\r\nreturn count;\r\nreturn ret;\r\n}\r\nstatic void fsl_qspi_set_map_addr(struct fsl_qspi *q)\r\n{\r\nint nor_size = q->nor_size;\r\nvoid __iomem *base = q->iobase;\r\nqspi_writel(q, nor_size + q->memmap_phy, base + QUADSPI_SFA1AD);\r\nqspi_writel(q, nor_size * 2 + q->memmap_phy, base + QUADSPI_SFA2AD);\r\nqspi_writel(q, nor_size * 3 + q->memmap_phy, base + QUADSPI_SFB1AD);\r\nqspi_writel(q, nor_size * 4 + q->memmap_phy, base + QUADSPI_SFB2AD);\r\n}\r\nstatic void fsl_qspi_init_abh_read(struct fsl_qspi *q)\r\n{\r\nvoid __iomem *base = q->iobase;\r\nint seqid;\r\nqspi_writel(q, QUADSPI_BUFXCR_INVALID_MSTRID, base + QUADSPI_BUF0CR);\r\nqspi_writel(q, QUADSPI_BUFXCR_INVALID_MSTRID, base + QUADSPI_BUF1CR);\r\nqspi_writel(q, QUADSPI_BUFXCR_INVALID_MSTRID, base + QUADSPI_BUF2CR);\r\nqspi_writel(q, QUADSPI_BUF3CR_ALLMST_MASK |\r\n((q->devtype_data->ahb_buf_size / 8)\r\n<< QUADSPI_BUF3CR_ADATSZ_SHIFT),\r\nbase + QUADSPI_BUF3CR);\r\nqspi_writel(q, 0, base + QUADSPI_BUF0IND);\r\nqspi_writel(q, 0, base + QUADSPI_BUF1IND);\r\nqspi_writel(q, 0, base + QUADSPI_BUF2IND);\r\nseqid = fsl_qspi_get_seqid(q, q->nor[0].read_opcode);\r\nqspi_writel(q, seqid << QUADSPI_BFGENCR_SEQID_SHIFT,\r\nq->iobase + QUADSPI_BFGENCR);\r\n}\r\nstatic int fsl_qspi_clk_prep_enable(struct fsl_qspi *q)\r\n{\r\nint ret;\r\nret = clk_prepare_enable(q->clk_en);\r\nif (ret)\r\nreturn ret;\r\nret = clk_prepare_enable(q->clk);\r\nif (ret) {\r\nclk_disable_unprepare(q->clk_en);\r\nreturn ret;\r\n}\r\nif (needs_wakeup_wait_mode(q))\r\npm_qos_add_request(&q->pm_qos_req, PM_QOS_CPU_DMA_LATENCY, 0);\r\nreturn 0;\r\n}\r\nstatic void fsl_qspi_clk_disable_unprep(struct fsl_qspi *q)\r\n{\r\nif (needs_wakeup_wait_mode(q))\r\npm_qos_remove_request(&q->pm_qos_req);\r\nclk_disable_unprepare(q->clk);\r\nclk_disable_unprepare(q->clk_en);\r\n}\r\nstatic int fsl_qspi_nor_setup(struct fsl_qspi *q)\r\n{\r\nvoid __iomem *base = q->iobase;\r\nu32 reg;\r\nint ret;\r\nfsl_qspi_clk_disable_unprep(q);\r\nret = clk_set_rate(q->clk, 66000000);\r\nif (ret)\r\nreturn ret;\r\nret = fsl_qspi_clk_prep_enable(q);\r\nif (ret)\r\nreturn ret;\r\nqspi_writel(q, QUADSPI_MCR_SWRSTSD_MASK | QUADSPI_MCR_SWRSTHD_MASK,\r\nbase + QUADSPI_MCR);\r\nudelay(1);\r\nfsl_qspi_init_lut(q);\r\nqspi_writel(q, QUADSPI_MCR_MDIS_MASK | QUADSPI_MCR_RESERVED_MASK,\r\nbase + QUADSPI_MCR);\r\nreg = qspi_readl(q, base + QUADSPI_SMPR);\r\nqspi_writel(q, reg & ~(QUADSPI_SMPR_FSDLY_MASK\r\n| QUADSPI_SMPR_FSPHS_MASK\r\n| QUADSPI_SMPR_HSENA_MASK\r\n| QUADSPI_SMPR_DDRSMP_MASK), base + QUADSPI_SMPR);\r\nqspi_writel(q, QUADSPI_MCR_RESERVED_MASK | QUADSPI_MCR_END_CFG_MASK,\r\nbase + QUADSPI_MCR);\r\nqspi_writel(q, 0xffffffff, q->iobase + QUADSPI_FR);\r\nqspi_writel(q, QUADSPI_RSER_TFIE, q->iobase + QUADSPI_RSER);\r\nreturn 0;\r\n}\r\nstatic int fsl_qspi_nor_setup_last(struct fsl_qspi *q)\r\n{\r\nunsigned long rate = q->clk_rate;\r\nint ret;\r\nif (needs_4x_clock(q))\r\nrate *= 4;\r\nfsl_qspi_clk_disable_unprep(q);\r\nret = clk_set_rate(q->clk, rate);\r\nif (ret)\r\nreturn ret;\r\nret = fsl_qspi_clk_prep_enable(q);\r\nif (ret)\r\nreturn ret;\r\nfsl_qspi_init_lut(q);\r\nfsl_qspi_init_abh_read(q);\r\nreturn 0;\r\n}\r\nstatic void fsl_qspi_set_base_addr(struct fsl_qspi *q, struct spi_nor *nor)\r\n{\r\nq->chip_base_addr = q->nor_size * (nor - q->nor);\r\n}\r\nstatic int fsl_qspi_read_reg(struct spi_nor *nor, u8 opcode, u8 *buf, int len)\r\n{\r\nint ret;\r\nstruct fsl_qspi *q = nor->priv;\r\nret = fsl_qspi_runcmd(q, opcode, 0, len);\r\nif (ret)\r\nreturn ret;\r\nfsl_qspi_read_data(q, len, buf);\r\nreturn 0;\r\n}\r\nstatic int fsl_qspi_write_reg(struct spi_nor *nor, u8 opcode, u8 *buf, int len)\r\n{\r\nstruct fsl_qspi *q = nor->priv;\r\nint ret;\r\nif (!buf) {\r\nret = fsl_qspi_runcmd(q, opcode, 0, 1);\r\nif (ret)\r\nreturn ret;\r\nif (opcode == SPINOR_OP_CHIP_ERASE)\r\nfsl_qspi_invalid(q);\r\n} else if (len > 0) {\r\nret = fsl_qspi_nor_write(q, nor, opcode, 0,\r\n(u32 *)buf, len);\r\nif (ret > 0)\r\nreturn 0;\r\n} else {\r\ndev_err(q->dev, "invalid cmd %d\n", opcode);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t fsl_qspi_write(struct spi_nor *nor, loff_t to,\r\nsize_t len, const u_char *buf)\r\n{\r\nstruct fsl_qspi *q = nor->priv;\r\nssize_t ret = fsl_qspi_nor_write(q, nor, nor->program_opcode, to,\r\n(u32 *)buf, len);\r\nfsl_qspi_invalid(q);\r\nreturn ret;\r\n}\r\nstatic ssize_t fsl_qspi_read(struct spi_nor *nor, loff_t from,\r\nsize_t len, u_char *buf)\r\n{\r\nstruct fsl_qspi *q = nor->priv;\r\nu8 cmd = nor->read_opcode;\r\nif (!q->ahb_addr) {\r\nq->memmap_offs = q->chip_base_addr + from;\r\nq->memmap_len = len > QUADSPI_MIN_IOMAP ? len : QUADSPI_MIN_IOMAP;\r\nq->ahb_addr = ioremap_nocache(\r\nq->memmap_phy + q->memmap_offs,\r\nq->memmap_len);\r\nif (!q->ahb_addr) {\r\ndev_err(q->dev, "ioremap failed\n");\r\nreturn -ENOMEM;\r\n}\r\n} else if (q->chip_base_addr + from < q->memmap_offs\r\n|| q->chip_base_addr + from + len >\r\nq->memmap_offs + q->memmap_len) {\r\niounmap(q->ahb_addr);\r\nq->memmap_offs = q->chip_base_addr + from;\r\nq->memmap_len = len > QUADSPI_MIN_IOMAP ? len : QUADSPI_MIN_IOMAP;\r\nq->ahb_addr = ioremap_nocache(\r\nq->memmap_phy + q->memmap_offs,\r\nq->memmap_len);\r\nif (!q->ahb_addr) {\r\ndev_err(q->dev, "ioremap failed\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\ndev_dbg(q->dev, "cmd [%x],read from %p, len:%zd\n",\r\ncmd, q->ahb_addr + q->chip_base_addr + from - q->memmap_offs,\r\nlen);\r\nmemcpy(buf, q->ahb_addr + q->chip_base_addr + from - q->memmap_offs,\r\nlen);\r\nreturn len;\r\n}\r\nstatic int fsl_qspi_erase(struct spi_nor *nor, loff_t offs)\r\n{\r\nstruct fsl_qspi *q = nor->priv;\r\nint ret;\r\ndev_dbg(nor->dev, "%dKiB at 0x%08x:0x%08x\n",\r\nnor->mtd.erasesize / 1024, q->chip_base_addr, (u32)offs);\r\nret = fsl_qspi_runcmd(q, nor->erase_opcode, offs, 0);\r\nif (ret)\r\nreturn ret;\r\nfsl_qspi_invalid(q);\r\nreturn 0;\r\n}\r\nstatic int fsl_qspi_prep(struct spi_nor *nor, enum spi_nor_ops ops)\r\n{\r\nstruct fsl_qspi *q = nor->priv;\r\nint ret;\r\nmutex_lock(&q->lock);\r\nret = fsl_qspi_clk_prep_enable(q);\r\nif (ret)\r\ngoto err_mutex;\r\nfsl_qspi_set_base_addr(q, nor);\r\nreturn 0;\r\nerr_mutex:\r\nmutex_unlock(&q->lock);\r\nreturn ret;\r\n}\r\nstatic void fsl_qspi_unprep(struct spi_nor *nor, enum spi_nor_ops ops)\r\n{\r\nstruct fsl_qspi *q = nor->priv;\r\nfsl_qspi_clk_disable_unprep(q);\r\nmutex_unlock(&q->lock);\r\n}\r\nstatic int fsl_qspi_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device *dev = &pdev->dev;\r\nstruct fsl_qspi *q;\r\nstruct resource *res;\r\nstruct spi_nor *nor;\r\nstruct mtd_info *mtd;\r\nint ret, i = 0;\r\nq = devm_kzalloc(dev, sizeof(*q), GFP_KERNEL);\r\nif (!q)\r\nreturn -ENOMEM;\r\nq->nor_num = of_get_child_count(dev->of_node);\r\nif (!q->nor_num || q->nor_num > FSL_QSPI_MAX_CHIP)\r\nreturn -ENODEV;\r\nq->dev = dev;\r\nq->devtype_data = of_device_get_match_data(dev);\r\nif (!q->devtype_data)\r\nreturn -ENODEV;\r\nplatform_set_drvdata(pdev, q);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "QuadSPI");\r\nq->iobase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(q->iobase))\r\nreturn PTR_ERR(q->iobase);\r\nq->big_endian = of_property_read_bool(np, "big-endian");\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"QuadSPI-memory");\r\nif (!devm_request_mem_region(dev, res->start, resource_size(res),\r\nres->name)) {\r\ndev_err(dev, "can't request region for resource %pR\n", res);\r\nreturn -EBUSY;\r\n}\r\nq->memmap_phy = res->start;\r\nq->clk_en = devm_clk_get(dev, "qspi_en");\r\nif (IS_ERR(q->clk_en))\r\nreturn PTR_ERR(q->clk_en);\r\nq->clk = devm_clk_get(dev, "qspi");\r\nif (IS_ERR(q->clk))\r\nreturn PTR_ERR(q->clk);\r\nret = fsl_qspi_clk_prep_enable(q);\r\nif (ret) {\r\ndev_err(dev, "can not enable the clock\n");\r\ngoto clk_failed;\r\n}\r\nret = platform_get_irq(pdev, 0);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to get the irq: %d\n", ret);\r\ngoto irq_failed;\r\n}\r\nret = devm_request_irq(dev, ret,\r\nfsl_qspi_irq_handler, 0, pdev->name, q);\r\nif (ret) {\r\ndev_err(dev, "failed to request irq: %d\n", ret);\r\ngoto irq_failed;\r\n}\r\nret = fsl_qspi_nor_setup(q);\r\nif (ret)\r\ngoto irq_failed;\r\nif (of_get_property(np, "fsl,qspi-has-second-chip", NULL))\r\nq->has_second_chip = true;\r\nmutex_init(&q->lock);\r\nfor_each_available_child_of_node(dev->of_node, np) {\r\nif (!q->has_second_chip)\r\ni *= 2;\r\nnor = &q->nor[i];\r\nmtd = &nor->mtd;\r\nnor->dev = dev;\r\nspi_nor_set_flash_node(nor, np);\r\nnor->priv = q;\r\nnor->read_reg = fsl_qspi_read_reg;\r\nnor->write_reg = fsl_qspi_write_reg;\r\nnor->read = fsl_qspi_read;\r\nnor->write = fsl_qspi_write;\r\nnor->erase = fsl_qspi_erase;\r\nnor->prepare = fsl_qspi_prep;\r\nnor->unprepare = fsl_qspi_unprep;\r\nret = of_property_read_u32(np, "spi-max-frequency",\r\n&q->clk_rate);\r\nif (ret < 0)\r\ngoto mutex_failed;\r\nfsl_qspi_set_base_addr(q, nor);\r\nret = spi_nor_scan(nor, NULL, SPI_NOR_QUAD);\r\nif (ret)\r\ngoto mutex_failed;\r\nret = mtd_device_register(mtd, NULL, 0);\r\nif (ret)\r\ngoto mutex_failed;\r\nif (q->nor_size == 0) {\r\nq->nor_size = mtd->size;\r\nfsl_qspi_set_map_addr(q);\r\n}\r\nif (nor->page_size > q->devtype_data->txfifo)\r\nnor->page_size = q->devtype_data->txfifo;\r\ni++;\r\n}\r\nret = fsl_qspi_nor_setup_last(q);\r\nif (ret)\r\ngoto last_init_failed;\r\nfsl_qspi_clk_disable_unprep(q);\r\nreturn 0;\r\nlast_init_failed:\r\nfor (i = 0; i < q->nor_num; i++) {\r\nif (!q->has_second_chip)\r\ni *= 2;\r\nmtd_device_unregister(&q->nor[i].mtd);\r\n}\r\nmutex_failed:\r\nmutex_destroy(&q->lock);\r\nirq_failed:\r\nfsl_qspi_clk_disable_unprep(q);\r\nclk_failed:\r\ndev_err(dev, "Freescale QuadSPI probe failed\n");\r\nreturn ret;\r\n}\r\nstatic int fsl_qspi_remove(struct platform_device *pdev)\r\n{\r\nstruct fsl_qspi *q = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < q->nor_num; i++) {\r\nif (!q->has_second_chip)\r\ni *= 2;\r\nmtd_device_unregister(&q->nor[i].mtd);\r\n}\r\nqspi_writel(q, QUADSPI_MCR_MDIS_MASK, q->iobase + QUADSPI_MCR);\r\nqspi_writel(q, 0x0, q->iobase + QUADSPI_RSER);\r\nmutex_destroy(&q->lock);\r\nif (q->ahb_addr)\r\niounmap(q->ahb_addr);\r\nreturn 0;\r\n}\r\nstatic int fsl_qspi_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nreturn 0;\r\n}\r\nstatic int fsl_qspi_resume(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct fsl_qspi *q = platform_get_drvdata(pdev);\r\nret = fsl_qspi_clk_prep_enable(q);\r\nif (ret)\r\nreturn ret;\r\nfsl_qspi_nor_setup(q);\r\nfsl_qspi_set_map_addr(q);\r\nfsl_qspi_nor_setup_last(q);\r\nfsl_qspi_clk_disable_unprep(q);\r\nreturn 0;\r\n}
