static int br_nf_check_hbh_len(struct sk_buff *skb)\r\n{\r\nunsigned char *raw = (u8 *)(ipv6_hdr(skb) + 1);\r\nu32 pkt_len;\r\nconst unsigned char *nh = skb_network_header(skb);\r\nint off = raw - nh;\r\nint len = (raw[1] + 1) << 3;\r\nif ((raw + len) - skb->data > skb_headlen(skb))\r\ngoto bad;\r\noff += 2;\r\nlen -= 2;\r\nwhile (len > 0) {\r\nint optlen = nh[off + 1] + 2;\r\nswitch (nh[off]) {\r\ncase IPV6_TLV_PAD1:\r\noptlen = 1;\r\nbreak;\r\ncase IPV6_TLV_PADN:\r\nbreak;\r\ncase IPV6_TLV_JUMBO:\r\nif (nh[off + 1] != 4 || (off & 3) != 2)\r\ngoto bad;\r\npkt_len = ntohl(*(__be32 *)(nh + off + 2));\r\nif (pkt_len <= IPV6_MAXPLEN ||\r\nipv6_hdr(skb)->payload_len)\r\ngoto bad;\r\nif (pkt_len > skb->len - sizeof(struct ipv6hdr))\r\ngoto bad;\r\nif (pskb_trim_rcsum(skb,\r\npkt_len + sizeof(struct ipv6hdr)))\r\ngoto bad;\r\nnh = skb_network_header(skb);\r\nbreak;\r\ndefault:\r\nif (optlen > len)\r\ngoto bad;\r\nbreak;\r\n}\r\noff += optlen;\r\nlen -= optlen;\r\n}\r\nif (len == 0)\r\nreturn 0;\r\nbad:\r\nreturn -1;\r\n}\r\nint br_validate_ipv6(struct net *net, struct sk_buff *skb)\r\n{\r\nconst struct ipv6hdr *hdr;\r\nstruct inet6_dev *idev = __in6_dev_get(skb->dev);\r\nu32 pkt_len;\r\nu8 ip6h_len = sizeof(struct ipv6hdr);\r\nif (!pskb_may_pull(skb, ip6h_len))\r\ngoto inhdr_error;\r\nif (skb->len < ip6h_len)\r\ngoto drop;\r\nhdr = ipv6_hdr(skb);\r\nif (hdr->version != 6)\r\ngoto inhdr_error;\r\npkt_len = ntohs(hdr->payload_len);\r\nif (pkt_len || hdr->nexthdr != NEXTHDR_HOP) {\r\nif (pkt_len + ip6h_len > skb->len) {\r\n__IP6_INC_STATS(net, idev,\r\nIPSTATS_MIB_INTRUNCATEDPKTS);\r\ngoto drop;\r\n}\r\nif (pskb_trim_rcsum(skb, pkt_len + ip6h_len)) {\r\n__IP6_INC_STATS(net, idev,\r\nIPSTATS_MIB_INDISCARDS);\r\ngoto drop;\r\n}\r\n}\r\nif (hdr->nexthdr == NEXTHDR_HOP && br_nf_check_hbh_len(skb))\r\ngoto drop;\r\nmemset(IP6CB(skb), 0, sizeof(struct inet6_skb_parm));\r\nreturn 0;\r\ninhdr_error:\r\n__IP6_INC_STATS(net, idev, IPSTATS_MIB_INHDRERRORS);\r\ndrop:\r\nreturn -1;\r\n}\r\nstatic inline bool\r\nbr_nf_ipv6_daddr_was_changed(const struct sk_buff *skb,\r\nconst struct nf_bridge_info *nf_bridge)\r\n{\r\nreturn memcmp(&nf_bridge->ipv6_daddr, &ipv6_hdr(skb)->daddr,\r\nsizeof(ipv6_hdr(skb)->daddr)) != 0;\r\n}\r\nstatic int br_nf_pre_routing_finish_ipv6(struct net *net, struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);\r\nstruct rtable *rt;\r\nstruct net_device *dev = skb->dev;\r\nconst struct nf_ipv6_ops *v6ops = nf_get_ipv6_ops();\r\nnf_bridge->frag_max_size = IP6CB(skb)->frag_max_size;\r\nif (nf_bridge->pkt_otherhost) {\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nnf_bridge->pkt_otherhost = false;\r\n}\r\nnf_bridge->in_prerouting = 0;\r\nif (br_nf_ipv6_daddr_was_changed(skb, nf_bridge)) {\r\nskb_dst_drop(skb);\r\nv6ops->route_input(skb);\r\nif (skb_dst(skb)->error) {\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nif (skb_dst(skb)->dev == dev) {\r\nskb->dev = nf_bridge->physindev;\r\nnf_bridge_update_protocol(skb);\r\nnf_bridge_push_encap_header(skb);\r\nbr_nf_hook_thresh(NF_BR_PRE_ROUTING,\r\nnet, sk, skb, skb->dev, NULL,\r\nbr_nf_pre_routing_finish_bridge);\r\nreturn 0;\r\n}\r\nether_addr_copy(eth_hdr(skb)->h_dest, dev->dev_addr);\r\nskb->pkt_type = PACKET_HOST;\r\n} else {\r\nrt = bridge_parent_rtable(nf_bridge->physindev);\r\nif (!rt) {\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nskb_dst_set_noref(skb, &rt->dst);\r\n}\r\nskb->dev = nf_bridge->physindev;\r\nnf_bridge_update_protocol(skb);\r\nnf_bridge_push_encap_header(skb);\r\nbr_nf_hook_thresh(NF_BR_PRE_ROUTING, net, sk, skb,\r\nskb->dev, NULL, br_handle_frame_finish);\r\nreturn 0;\r\n}\r\nunsigned int br_nf_pre_routing_ipv6(void *priv,\r\nstruct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nstruct nf_bridge_info *nf_bridge;\r\nif (br_validate_ipv6(state->net, skb))\r\nreturn NF_DROP;\r\nnf_bridge_put(skb->nf_bridge);\r\nif (!nf_bridge_alloc(skb))\r\nreturn NF_DROP;\r\nif (!setup_pre_routing(skb))\r\nreturn NF_DROP;\r\nnf_bridge = nf_bridge_info_get(skb);\r\nnf_bridge->ipv6_daddr = ipv6_hdr(skb)->daddr;\r\nskb->protocol = htons(ETH_P_IPV6);\r\nNF_HOOK(NFPROTO_IPV6, NF_INET_PRE_ROUTING, state->net, state->sk, skb,\r\nskb->dev, NULL,\r\nbr_nf_pre_routing_finish_ipv6);\r\nreturn NF_STOLEN;\r\n}
