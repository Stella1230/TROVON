static void iic_wr(struct sh_mobile_i2c_data *pd, int offs, unsigned char data)\r\n{\r\nif (offs == ICIC)\r\ndata |= pd->icic;\r\niowrite8(data, pd->reg + offs);\r\n}\r\nstatic unsigned char iic_rd(struct sh_mobile_i2c_data *pd, int offs)\r\n{\r\nreturn ioread8(pd->reg + offs);\r\n}\r\nstatic void iic_set_clr(struct sh_mobile_i2c_data *pd, int offs,\r\nunsigned char set, unsigned char clr)\r\n{\r\niic_wr(pd, offs, (iic_rd(pd, offs) | set) & ~clr);\r\n}\r\nstatic u32 sh_mobile_i2c_iccl(unsigned long count_khz, u32 tLOW, u32 tf)\r\n{\r\nreturn (((count_khz * (tLOW + tf)) + 5000) / 10000);\r\n}\r\nstatic u32 sh_mobile_i2c_icch(unsigned long count_khz, u32 tHIGH, u32 tf)\r\n{\r\nreturn (((count_khz * (tHIGH + tf)) + 5000) / 10000);\r\n}\r\nstatic int sh_mobile_i2c_init(struct sh_mobile_i2c_data *pd)\r\n{\r\nunsigned long i2c_clk_khz;\r\nu32 tHIGH, tLOW, tf;\r\nuint16_t max_val;\r\nclk_prepare_enable(pd->clk);\r\ni2c_clk_khz = clk_get_rate(pd->clk) / 1000;\r\nclk_disable_unprepare(pd->clk);\r\ni2c_clk_khz /= pd->clks_per_count;\r\nif (pd->bus_speed == STANDARD_MODE) {\r\ntLOW = 47;\r\ntHIGH = 40;\r\ntf = 3;\r\n} else if (pd->bus_speed == FAST_MODE) {\r\ntLOW = 13;\r\ntHIGH = 6;\r\ntf = 3;\r\n} else {\r\ndev_err(pd->dev, "unrecognized bus speed %lu Hz\n",\r\npd->bus_speed);\r\nreturn -EINVAL;\r\n}\r\npd->iccl = sh_mobile_i2c_iccl(i2c_clk_khz, tLOW, tf);\r\npd->icch = sh_mobile_i2c_icch(i2c_clk_khz, tHIGH, tf);\r\nmax_val = pd->flags & IIC_FLAG_HAS_ICIC67 ? 0x1ff : 0xff;\r\nif (pd->iccl > max_val || pd->icch > max_val) {\r\ndev_err(pd->dev, "timing values out of range: L/H=0x%x/0x%x\n",\r\npd->iccl, pd->icch);\r\nreturn -EINVAL;\r\n}\r\nif (pd->iccl & 0x100)\r\npd->icic |= ICIC_ICCLB8;\r\nelse\r\npd->icic &= ~ICIC_ICCLB8;\r\nif (pd->icch & 0x100)\r\npd->icic |= ICIC_ICCHB8;\r\nelse\r\npd->icic &= ~ICIC_ICCHB8;\r\ndev_dbg(pd->dev, "timing values: L/H=0x%x/0x%x\n", pd->iccl, pd->icch);\r\nreturn 0;\r\n}\r\nstatic void activate_ch(struct sh_mobile_i2c_data *pd)\r\n{\r\npm_runtime_get_sync(pd->dev);\r\nclk_prepare_enable(pd->clk);\r\niic_set_clr(pd, ICCR, ICCR_ICE, 0);\r\niic_wr(pd, ICIC, 0);\r\niic_wr(pd, ICCL, pd->iccl & 0xff);\r\niic_wr(pd, ICCH, pd->icch & 0xff);\r\n}\r\nstatic void deactivate_ch(struct sh_mobile_i2c_data *pd)\r\n{\r\niic_wr(pd, ICSR, 0);\r\niic_wr(pd, ICIC, 0);\r\niic_set_clr(pd, ICCR, 0, ICCR_ICE);\r\nclk_disable_unprepare(pd->clk);\r\npm_runtime_put_sync(pd->dev);\r\n}\r\nstatic unsigned char i2c_op(struct sh_mobile_i2c_data *pd,\r\nenum sh_mobile_i2c_op op, unsigned char data)\r\n{\r\nunsigned char ret = 0;\r\nunsigned long flags;\r\ndev_dbg(pd->dev, "op %d, data in 0x%02x\n", op, data);\r\nspin_lock_irqsave(&pd->lock, flags);\r\nswitch (op) {\r\ncase OP_START:\r\niic_wr(pd, ICCR, ICCR_ICE | ICCR_TRS | ICCR_BBSY);\r\nbreak;\r\ncase OP_TX_FIRST:\r\niic_wr(pd, ICIC, ICIC_WAITE | ICIC_ALE | ICIC_TACKE);\r\niic_wr(pd, ICDR, data);\r\nbreak;\r\ncase OP_TX:\r\niic_wr(pd, ICDR, data);\r\nbreak;\r\ncase OP_TX_STOP_DATA:\r\niic_wr(pd, ICDR, data);\r\ncase OP_TX_STOP:\r\niic_wr(pd, ICCR, pd->send_stop ? ICCR_ICE | ICCR_TRS\r\n: ICCR_ICE | ICCR_TRS | ICCR_BBSY);\r\nbreak;\r\ncase OP_TX_TO_RX:\r\niic_wr(pd, ICCR, ICCR_ICE | ICCR_SCP);\r\nbreak;\r\ncase OP_RX:\r\nret = iic_rd(pd, ICDR);\r\nbreak;\r\ncase OP_RX_STOP:\r\niic_wr(pd, ICIC,\r\nICIC_DTEE | ICIC_WAITE | ICIC_ALE | ICIC_TACKE);\r\niic_wr(pd, ICCR, ICCR_ICE | ICCR_RACK);\r\nbreak;\r\ncase OP_RX_STOP_DATA:\r\niic_wr(pd, ICIC,\r\nICIC_DTEE | ICIC_WAITE | ICIC_ALE | ICIC_TACKE);\r\nret = iic_rd(pd, ICDR);\r\niic_wr(pd, ICCR, ICCR_ICE | ICCR_RACK);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&pd->lock, flags);\r\ndev_dbg(pd->dev, "op %d, data out 0x%02x\n", op, ret);\r\nreturn ret;\r\n}\r\nstatic bool sh_mobile_i2c_is_first_byte(struct sh_mobile_i2c_data *pd)\r\n{\r\nreturn pd->pos == -1;\r\n}\r\nstatic bool sh_mobile_i2c_is_last_byte(struct sh_mobile_i2c_data *pd)\r\n{\r\nreturn pd->pos == pd->msg->len - 1;\r\n}\r\nstatic void sh_mobile_i2c_get_data(struct sh_mobile_i2c_data *pd,\r\nunsigned char *buf)\r\n{\r\nswitch (pd->pos) {\r\ncase -1:\r\n*buf = i2c_8bit_addr_from_msg(pd->msg);\r\nbreak;\r\ndefault:\r\n*buf = pd->msg->buf[pd->pos];\r\n}\r\n}\r\nstatic int sh_mobile_i2c_isr_tx(struct sh_mobile_i2c_data *pd)\r\n{\r\nunsigned char data;\r\nif (pd->pos == pd->msg->len) {\r\nif (pd->send_stop && pd->stop_after_dma)\r\ni2c_op(pd, OP_TX_STOP, 0);\r\nreturn 1;\r\n}\r\nsh_mobile_i2c_get_data(pd, &data);\r\nif (sh_mobile_i2c_is_last_byte(pd))\r\ni2c_op(pd, OP_TX_STOP_DATA, data);\r\nelse if (sh_mobile_i2c_is_first_byte(pd))\r\ni2c_op(pd, OP_TX_FIRST, data);\r\nelse\r\ni2c_op(pd, OP_TX, data);\r\npd->pos++;\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_i2c_isr_rx(struct sh_mobile_i2c_data *pd)\r\n{\r\nunsigned char data;\r\nint real_pos;\r\ndo {\r\nif (pd->pos <= -1) {\r\nsh_mobile_i2c_get_data(pd, &data);\r\nif (sh_mobile_i2c_is_first_byte(pd))\r\ni2c_op(pd, OP_TX_FIRST, data);\r\nelse\r\ni2c_op(pd, OP_TX, data);\r\nbreak;\r\n}\r\nif (pd->pos == 0) {\r\ni2c_op(pd, OP_TX_TO_RX, 0);\r\nbreak;\r\n}\r\nreal_pos = pd->pos - 2;\r\nif (pd->pos == pd->msg->len) {\r\nif (pd->stop_after_dma) {\r\ni2c_op(pd, OP_RX_STOP, 0);\r\npd->pos++;\r\nbreak;\r\n}\r\nif (real_pos < 0) {\r\ni2c_op(pd, OP_RX_STOP, 0);\r\nbreak;\r\n}\r\ndata = i2c_op(pd, OP_RX_STOP_DATA, 0);\r\n} else\r\ndata = i2c_op(pd, OP_RX, 0);\r\nif (real_pos >= 0)\r\npd->msg->buf[real_pos] = data;\r\n} while (0);\r\npd->pos++;\r\nreturn pd->pos == (pd->msg->len + 2);\r\n}\r\nstatic irqreturn_t sh_mobile_i2c_isr(int irq, void *dev_id)\r\n{\r\nstruct sh_mobile_i2c_data *pd = dev_id;\r\nunsigned char sr;\r\nint wakeup = 0;\r\nsr = iic_rd(pd, ICSR);\r\npd->sr |= sr;\r\ndev_dbg(pd->dev, "i2c_isr 0x%02x 0x%02x %s %d %d!\n", sr, pd->sr,\r\n(pd->msg->flags & I2C_M_RD) ? "read" : "write",\r\npd->pos, pd->msg->len);\r\nif (pd->dma_direction == DMA_TO_DEVICE && pd->pos == 0)\r\niic_set_clr(pd, ICIC, ICIC_TDMAE, 0);\r\nelse if (sr & (ICSR_AL | ICSR_TACK))\r\niic_wr(pd, ICSR, sr & ~(ICSR_AL | ICSR_TACK));\r\nelse if (pd->msg->flags & I2C_M_RD)\r\nwakeup = sh_mobile_i2c_isr_rx(pd);\r\nelse\r\nwakeup = sh_mobile_i2c_isr_tx(pd);\r\nif (pd->dma_direction == DMA_FROM_DEVICE && pd->pos == 1)\r\niic_set_clr(pd, ICIC, ICIC_RDMAE, 0);\r\nif (sr & ICSR_WAIT)\r\niic_wr(pd, ICSR, sr & ~ICSR_WAIT);\r\nif (wakeup) {\r\npd->sr |= SW_DONE;\r\nwake_up(&pd->wait);\r\n}\r\niic_rd(pd, ICSR);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sh_mobile_i2c_dma_unmap(struct sh_mobile_i2c_data *pd)\r\n{\r\nstruct dma_chan *chan = pd->dma_direction == DMA_FROM_DEVICE\r\n? pd->dma_rx : pd->dma_tx;\r\ndma_unmap_single(chan->device->dev, sg_dma_address(&pd->sg),\r\npd->msg->len, pd->dma_direction);\r\npd->dma_direction = DMA_NONE;\r\n}\r\nstatic void sh_mobile_i2c_cleanup_dma(struct sh_mobile_i2c_data *pd)\r\n{\r\nif (pd->dma_direction == DMA_NONE)\r\nreturn;\r\nelse if (pd->dma_direction == DMA_FROM_DEVICE)\r\ndmaengine_terminate_all(pd->dma_rx);\r\nelse if (pd->dma_direction == DMA_TO_DEVICE)\r\ndmaengine_terminate_all(pd->dma_tx);\r\nsh_mobile_i2c_dma_unmap(pd);\r\n}\r\nstatic void sh_mobile_i2c_dma_callback(void *data)\r\n{\r\nstruct sh_mobile_i2c_data *pd = data;\r\nsh_mobile_i2c_dma_unmap(pd);\r\npd->pos = pd->msg->len;\r\npd->stop_after_dma = true;\r\niic_set_clr(pd, ICIC, 0, ICIC_TDMAE | ICIC_RDMAE);\r\n}\r\nstatic struct dma_chan *sh_mobile_i2c_request_dma_chan(struct device *dev,\r\nenum dma_transfer_direction dir, dma_addr_t port_addr)\r\n{\r\nstruct dma_chan *chan;\r\nstruct dma_slave_config cfg;\r\nchar *chan_name = dir == DMA_MEM_TO_DEV ? "tx" : "rx";\r\nint ret;\r\nchan = dma_request_slave_channel_reason(dev, chan_name);\r\nif (IS_ERR(chan)) {\r\nret = PTR_ERR(chan);\r\ndev_dbg(dev, "request_channel failed for %s (%d)\n", chan_name, ret);\r\nreturn chan;\r\n}\r\nmemset(&cfg, 0, sizeof(cfg));\r\ncfg.direction = dir;\r\nif (dir == DMA_MEM_TO_DEV) {\r\ncfg.dst_addr = port_addr;\r\ncfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\n} else {\r\ncfg.src_addr = port_addr;\r\ncfg.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\n}\r\nret = dmaengine_slave_config(chan, &cfg);\r\nif (ret) {\r\ndev_dbg(dev, "slave_config failed for %s (%d)\n", chan_name, ret);\r\ndma_release_channel(chan);\r\nreturn ERR_PTR(ret);\r\n}\r\ndev_dbg(dev, "got DMA channel for %s\n", chan_name);\r\nreturn chan;\r\n}\r\nstatic void sh_mobile_i2c_xfer_dma(struct sh_mobile_i2c_data *pd)\r\n{\r\nbool read = pd->msg->flags & I2C_M_RD;\r\nenum dma_data_direction dir = read ? DMA_FROM_DEVICE : DMA_TO_DEVICE;\r\nstruct dma_chan *chan = read ? pd->dma_rx : pd->dma_tx;\r\nstruct dma_async_tx_descriptor *txdesc;\r\ndma_addr_t dma_addr;\r\ndma_cookie_t cookie;\r\nif (PTR_ERR(chan) == -EPROBE_DEFER) {\r\nif (read)\r\nchan = pd->dma_rx = sh_mobile_i2c_request_dma_chan(pd->dev, DMA_DEV_TO_MEM,\r\npd->res->start + ICDR);\r\nelse\r\nchan = pd->dma_tx = sh_mobile_i2c_request_dma_chan(pd->dev, DMA_MEM_TO_DEV,\r\npd->res->start + ICDR);\r\n}\r\nif (IS_ERR(chan))\r\nreturn;\r\ndma_addr = dma_map_single(chan->device->dev, pd->msg->buf, pd->msg->len, dir);\r\nif (dma_mapping_error(chan->device->dev, dma_addr)) {\r\ndev_dbg(pd->dev, "dma map failed, using PIO\n");\r\nreturn;\r\n}\r\nsg_dma_len(&pd->sg) = pd->msg->len;\r\nsg_dma_address(&pd->sg) = dma_addr;\r\npd->dma_direction = dir;\r\ntxdesc = dmaengine_prep_slave_sg(chan, &pd->sg, 1,\r\nread ? DMA_DEV_TO_MEM : DMA_MEM_TO_DEV,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!txdesc) {\r\ndev_dbg(pd->dev, "dma prep slave sg failed, using PIO\n");\r\nsh_mobile_i2c_cleanup_dma(pd);\r\nreturn;\r\n}\r\ntxdesc->callback = sh_mobile_i2c_dma_callback;\r\ntxdesc->callback_param = pd;\r\ncookie = dmaengine_submit(txdesc);\r\nif (dma_submit_error(cookie)) {\r\ndev_dbg(pd->dev, "submitting dma failed, using PIO\n");\r\nsh_mobile_i2c_cleanup_dma(pd);\r\nreturn;\r\n}\r\ndma_async_issue_pending(chan);\r\n}\r\nstatic int start_ch(struct sh_mobile_i2c_data *pd, struct i2c_msg *usr_msg,\r\nbool do_init)\r\n{\r\nif (usr_msg->len == 0 && (usr_msg->flags & I2C_M_RD)) {\r\ndev_err(pd->dev, "Unsupported zero length i2c read\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (do_init) {\r\niic_set_clr(pd, ICCR, 0, ICCR_ICE);\r\niic_set_clr(pd, ICCR, ICCR_ICE, 0);\r\niic_wr(pd, ICCL, pd->iccl & 0xff);\r\niic_wr(pd, ICCH, pd->icch & 0xff);\r\n}\r\npd->msg = usr_msg;\r\npd->pos = -1;\r\npd->sr = 0;\r\nif (pd->msg->len > 8)\r\nsh_mobile_i2c_xfer_dma(pd);\r\niic_wr(pd, ICIC, ICIC_DTEE | ICIC_WAITE | ICIC_ALE | ICIC_TACKE);\r\nreturn 0;\r\n}\r\nstatic int poll_dte(struct sh_mobile_i2c_data *pd)\r\n{\r\nint i;\r\nfor (i = 1000; i; i--) {\r\nu_int8_t val = iic_rd(pd, ICSR);\r\nif (val & ICSR_DTE)\r\nbreak;\r\nif (val & ICSR_TACK)\r\nreturn -ENXIO;\r\nudelay(10);\r\n}\r\nreturn i ? 0 : -ETIMEDOUT;\r\n}\r\nstatic int poll_busy(struct sh_mobile_i2c_data *pd)\r\n{\r\nint i;\r\nfor (i = 1000; i; i--) {\r\nu_int8_t val = iic_rd(pd, ICSR);\r\ndev_dbg(pd->dev, "val 0x%02x pd->sr 0x%02x\n", val, pd->sr);\r\nif (!(val & ICSR_BUSY)) {\r\nval |= pd->sr;\r\nif (val & ICSR_TACK)\r\nreturn -ENXIO;\r\nif (val & ICSR_AL)\r\nreturn -EAGAIN;\r\nbreak;\r\n}\r\nudelay(10);\r\n}\r\nreturn i ? 0 : -ETIMEDOUT;\r\n}\r\nstatic int sh_mobile_i2c_xfer(struct i2c_adapter *adapter,\r\nstruct i2c_msg *msgs,\r\nint num)\r\n{\r\nstruct sh_mobile_i2c_data *pd = i2c_get_adapdata(adapter);\r\nstruct i2c_msg *msg;\r\nint err = 0;\r\nint i;\r\nlong timeout;\r\nactivate_ch(pd);\r\nfor (i = 0; i < num; i++) {\r\nbool do_start = pd->send_stop || !i;\r\nmsg = &msgs[i];\r\npd->send_stop = i == num - 1 || msg->flags & I2C_M_STOP;\r\npd->stop_after_dma = false;\r\nerr = start_ch(pd, msg, do_start);\r\nif (err)\r\nbreak;\r\nif (do_start)\r\ni2c_op(pd, OP_START, 0);\r\ntimeout = wait_event_timeout(pd->wait,\r\npd->sr & (ICSR_TACK | SW_DONE),\r\nadapter->timeout);\r\nif (!timeout) {\r\ndev_err(pd->dev, "Transfer request timed out\n");\r\nif (pd->dma_direction != DMA_NONE)\r\nsh_mobile_i2c_cleanup_dma(pd);\r\nerr = -ETIMEDOUT;\r\nbreak;\r\n}\r\nif (pd->send_stop)\r\nerr = poll_busy(pd);\r\nelse\r\nerr = poll_dte(pd);\r\nif (err < 0)\r\nbreak;\r\n}\r\ndeactivate_ch(pd);\r\nif (!err)\r\nerr = num;\r\nreturn err;\r\n}\r\nstatic u32 sh_mobile_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_PROTOCOL_MANGLING;\r\n}\r\nstatic void sh_mobile_i2c_r8a7740_workaround(struct sh_mobile_i2c_data *pd)\r\n{\r\niic_set_clr(pd, ICCR, ICCR_ICE, 0);\r\niic_rd(pd, ICCR);\r\niic_set_clr(pd, ICSTART, ICSTART_ICSTART, 0);\r\niic_rd(pd, ICSTART);\r\nudelay(10);\r\niic_wr(pd, ICCR, ICCR_SCP);\r\niic_wr(pd, ICSTART, 0);\r\nudelay(10);\r\niic_wr(pd, ICCR, ICCR_TRS);\r\nudelay(10);\r\niic_wr(pd, ICCR, 0);\r\nudelay(10);\r\niic_wr(pd, ICCR, ICCR_TRS);\r\nudelay(10);\r\n}\r\nstatic void sh_mobile_i2c_release_dma(struct sh_mobile_i2c_data *pd)\r\n{\r\nif (!IS_ERR(pd->dma_tx)) {\r\ndma_release_channel(pd->dma_tx);\r\npd->dma_tx = ERR_PTR(-EPROBE_DEFER);\r\n}\r\nif (!IS_ERR(pd->dma_rx)) {\r\ndma_release_channel(pd->dma_rx);\r\npd->dma_rx = ERR_PTR(-EPROBE_DEFER);\r\n}\r\n}\r\nstatic int sh_mobile_i2c_hook_irqs(struct platform_device *dev, struct sh_mobile_i2c_data *pd)\r\n{\r\nstruct resource *res;\r\nresource_size_t n;\r\nint k = 0, ret;\r\nwhile ((res = platform_get_resource(dev, IORESOURCE_IRQ, k))) {\r\nfor (n = res->start; n <= res->end; n++) {\r\nret = devm_request_irq(&dev->dev, n, sh_mobile_i2c_isr,\r\n0, dev_name(&dev->dev), pd);\r\nif (ret) {\r\ndev_err(&dev->dev, "cannot request IRQ %pa\n", &n);\r\nreturn ret;\r\n}\r\n}\r\nk++;\r\n}\r\nreturn k > 0 ? 0 : -ENOENT;\r\n}\r\nstatic int sh_mobile_i2c_probe(struct platform_device *dev)\r\n{\r\nstruct i2c_sh_mobile_platform_data *pdata = dev_get_platdata(&dev->dev);\r\nstruct sh_mobile_i2c_data *pd;\r\nstruct i2c_adapter *adap;\r\nstruct resource *res;\r\nint ret;\r\nu32 bus_speed;\r\npd = devm_kzalloc(&dev->dev, sizeof(struct sh_mobile_i2c_data), GFP_KERNEL);\r\nif (!pd)\r\nreturn -ENOMEM;\r\npd->clk = devm_clk_get(&dev->dev, NULL);\r\nif (IS_ERR(pd->clk)) {\r\ndev_err(&dev->dev, "cannot get clock\n");\r\nreturn PTR_ERR(pd->clk);\r\n}\r\nret = sh_mobile_i2c_hook_irqs(dev, pd);\r\nif (ret)\r\nreturn ret;\r\npd->dev = &dev->dev;\r\nplatform_set_drvdata(dev, pd);\r\nres = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\npd->res = res;\r\npd->reg = devm_ioremap_resource(&dev->dev, res);\r\nif (IS_ERR(pd->reg))\r\nreturn PTR_ERR(pd->reg);\r\nret = of_property_read_u32(dev->dev.of_node, "clock-frequency", &bus_speed);\r\npd->bus_speed = ret ? STANDARD_MODE : bus_speed;\r\npd->clks_per_count = 1;\r\nif (dev->dev.of_node) {\r\nconst struct of_device_id *match;\r\nmatch = of_match_device(sh_mobile_i2c_dt_ids, &dev->dev);\r\nif (match) {\r\nconst struct sh_mobile_dt_config *config;\r\nconfig = match->data;\r\npd->clks_per_count = config->clks_per_count;\r\nif (config->setup)\r\nconfig->setup(pd);\r\n}\r\n} else {\r\nif (pdata && pdata->bus_speed)\r\npd->bus_speed = pdata->bus_speed;\r\nif (pdata && pdata->clks_per_count)\r\npd->clks_per_count = pdata->clks_per_count;\r\n}\r\nif (resource_size(res) > 0x17)\r\npd->flags |= IIC_FLAG_HAS_ICIC67;\r\nret = sh_mobile_i2c_init(pd);\r\nif (ret)\r\nreturn ret;\r\nsg_init_table(&pd->sg, 1);\r\npd->dma_direction = DMA_NONE;\r\npd->dma_rx = pd->dma_tx = ERR_PTR(-EPROBE_DEFER);\r\npm_suspend_ignore_children(&dev->dev, true);\r\npm_runtime_enable(&dev->dev);\r\nadap = &pd->adap;\r\ni2c_set_adapdata(adap, pd);\r\nadap->owner = THIS_MODULE;\r\nadap->algo = &sh_mobile_i2c_algorithm;\r\nadap->dev.parent = &dev->dev;\r\nadap->retries = 5;\r\nadap->nr = dev->id;\r\nadap->dev.of_node = dev->dev.of_node;\r\nstrlcpy(adap->name, dev->name, sizeof(adap->name));\r\nspin_lock_init(&pd->lock);\r\ninit_waitqueue_head(&pd->wait);\r\nret = i2c_add_numbered_adapter(adap);\r\nif (ret < 0) {\r\nsh_mobile_i2c_release_dma(pd);\r\nreturn ret;\r\n}\r\ndev_info(&dev->dev, "I2C adapter %d, bus speed %lu Hz\n", adap->nr, pd->bus_speed);\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_i2c_remove(struct platform_device *dev)\r\n{\r\nstruct sh_mobile_i2c_data *pd = platform_get_drvdata(dev);\r\ni2c_del_adapter(&pd->adap);\r\nsh_mobile_i2c_release_dma(pd);\r\npm_runtime_disable(&dev->dev);\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_i2c_runtime_nop(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init sh_mobile_i2c_adap_init(void)\r\n{\r\nreturn platform_driver_register(&sh_mobile_i2c_driver);\r\n}\r\nstatic void __exit sh_mobile_i2c_adap_exit(void)\r\n{\r\nplatform_driver_unregister(&sh_mobile_i2c_driver);\r\n}
