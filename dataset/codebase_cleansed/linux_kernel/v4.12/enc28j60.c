static int\r\nspi_read_buf(struct enc28j60_net *priv, int len, u8 *data)\r\n{\r\nu8 *rx_buf = priv->spi_transfer_buf + 4;\r\nu8 *tx_buf = priv->spi_transfer_buf;\r\nstruct spi_transfer tx = {\r\n.tx_buf = tx_buf,\r\n.len = SPI_OPLEN,\r\n};\r\nstruct spi_transfer rx = {\r\n.rx_buf = rx_buf,\r\n.len = len,\r\n};\r\nstruct spi_message msg;\r\nint ret;\r\ntx_buf[0] = ENC28J60_READ_BUF_MEM;\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&tx, &msg);\r\nspi_message_add_tail(&rx, &msg);\r\nret = spi_sync(priv->spi, &msg);\r\nif (ret == 0) {\r\nmemcpy(data, rx_buf, len);\r\nret = msg.status;\r\n}\r\nif (ret && netif_msg_drv(priv))\r\nprintk(KERN_DEBUG DRV_NAME ": %s() failed: ret = %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nstatic int spi_write_buf(struct enc28j60_net *priv, int len,\r\nconst u8 *data)\r\n{\r\nint ret;\r\nif (len > SPI_TRANSFER_BUF_LEN - 1 || len <= 0)\r\nret = -EINVAL;\r\nelse {\r\npriv->spi_transfer_buf[0] = ENC28J60_WRITE_BUF_MEM;\r\nmemcpy(&priv->spi_transfer_buf[1], data, len);\r\nret = spi_write(priv->spi, priv->spi_transfer_buf, len + 1);\r\nif (ret && netif_msg_drv(priv))\r\nprintk(KERN_DEBUG DRV_NAME ": %s() failed: ret = %d\n",\r\n__func__, ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic u8 spi_read_op(struct enc28j60_net *priv, u8 op,\r\nu8 addr)\r\n{\r\nu8 tx_buf[2];\r\nu8 rx_buf[4];\r\nu8 val = 0;\r\nint ret;\r\nint slen = SPI_OPLEN;\r\nif (addr & SPRD_MASK)\r\nslen++;\r\ntx_buf[0] = op | (addr & ADDR_MASK);\r\nret = spi_write_then_read(priv->spi, tx_buf, 1, rx_buf, slen);\r\nif (ret)\r\nprintk(KERN_DEBUG DRV_NAME ": %s() failed: ret = %d\n",\r\n__func__, ret);\r\nelse\r\nval = rx_buf[slen - 1];\r\nreturn val;\r\n}\r\nstatic int spi_write_op(struct enc28j60_net *priv, u8 op,\r\nu8 addr, u8 val)\r\n{\r\nint ret;\r\npriv->spi_transfer_buf[0] = op | (addr & ADDR_MASK);\r\npriv->spi_transfer_buf[1] = val;\r\nret = spi_write(priv->spi, priv->spi_transfer_buf, 2);\r\nif (ret && netif_msg_drv(priv))\r\nprintk(KERN_DEBUG DRV_NAME ": %s() failed: ret = %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nstatic void enc28j60_soft_reset(struct enc28j60_net *priv)\r\n{\r\nif (netif_msg_hw(priv))\r\nprintk(KERN_DEBUG DRV_NAME ": %s() enter\n", __func__);\r\nspi_write_op(priv, ENC28J60_SOFT_RESET, 0, ENC28J60_SOFT_RESET);\r\nudelay(2000);\r\n}\r\nstatic void enc28j60_set_bank(struct enc28j60_net *priv, u8 addr)\r\n{\r\nu8 b = (addr & BANK_MASK) >> 5;\r\nif (addr >= EIE && addr <= ECON1)\r\nreturn;\r\nif ((b & ECON1_BSEL0) != (priv->bank & ECON1_BSEL0)) {\r\nif (b & ECON1_BSEL0)\r\nspi_write_op(priv, ENC28J60_BIT_FIELD_SET, ECON1,\r\nECON1_BSEL0);\r\nelse\r\nspi_write_op(priv, ENC28J60_BIT_FIELD_CLR, ECON1,\r\nECON1_BSEL0);\r\n}\r\nif ((b & ECON1_BSEL1) != (priv->bank & ECON1_BSEL1)) {\r\nif (b & ECON1_BSEL1)\r\nspi_write_op(priv, ENC28J60_BIT_FIELD_SET, ECON1,\r\nECON1_BSEL1);\r\nelse\r\nspi_write_op(priv, ENC28J60_BIT_FIELD_CLR, ECON1,\r\nECON1_BSEL1);\r\n}\r\npriv->bank = b;\r\n}\r\nstatic void nolock_reg_bfset(struct enc28j60_net *priv,\r\nu8 addr, u8 mask)\r\n{\r\nenc28j60_set_bank(priv, addr);\r\nspi_write_op(priv, ENC28J60_BIT_FIELD_SET, addr, mask);\r\n}\r\nstatic void locked_reg_bfset(struct enc28j60_net *priv,\r\nu8 addr, u8 mask)\r\n{\r\nmutex_lock(&priv->lock);\r\nnolock_reg_bfset(priv, addr, mask);\r\nmutex_unlock(&priv->lock);\r\n}\r\nstatic void nolock_reg_bfclr(struct enc28j60_net *priv,\r\nu8 addr, u8 mask)\r\n{\r\nenc28j60_set_bank(priv, addr);\r\nspi_write_op(priv, ENC28J60_BIT_FIELD_CLR, addr, mask);\r\n}\r\nstatic void locked_reg_bfclr(struct enc28j60_net *priv,\r\nu8 addr, u8 mask)\r\n{\r\nmutex_lock(&priv->lock);\r\nnolock_reg_bfclr(priv, addr, mask);\r\nmutex_unlock(&priv->lock);\r\n}\r\nstatic int nolock_regb_read(struct enc28j60_net *priv,\r\nu8 address)\r\n{\r\nenc28j60_set_bank(priv, address);\r\nreturn spi_read_op(priv, ENC28J60_READ_CTRL_REG, address);\r\n}\r\nstatic int locked_regb_read(struct enc28j60_net *priv,\r\nu8 address)\r\n{\r\nint ret;\r\nmutex_lock(&priv->lock);\r\nret = nolock_regb_read(priv, address);\r\nmutex_unlock(&priv->lock);\r\nreturn ret;\r\n}\r\nstatic int nolock_regw_read(struct enc28j60_net *priv,\r\nu8 address)\r\n{\r\nint rl, rh;\r\nenc28j60_set_bank(priv, address);\r\nrl = spi_read_op(priv, ENC28J60_READ_CTRL_REG, address);\r\nrh = spi_read_op(priv, ENC28J60_READ_CTRL_REG, address + 1);\r\nreturn (rh << 8) | rl;\r\n}\r\nstatic int locked_regw_read(struct enc28j60_net *priv,\r\nu8 address)\r\n{\r\nint ret;\r\nmutex_lock(&priv->lock);\r\nret = nolock_regw_read(priv, address);\r\nmutex_unlock(&priv->lock);\r\nreturn ret;\r\n}\r\nstatic void nolock_regb_write(struct enc28j60_net *priv,\r\nu8 address, u8 data)\r\n{\r\nenc28j60_set_bank(priv, address);\r\nspi_write_op(priv, ENC28J60_WRITE_CTRL_REG, address, data);\r\n}\r\nstatic void locked_regb_write(struct enc28j60_net *priv,\r\nu8 address, u8 data)\r\n{\r\nmutex_lock(&priv->lock);\r\nnolock_regb_write(priv, address, data);\r\nmutex_unlock(&priv->lock);\r\n}\r\nstatic void nolock_regw_write(struct enc28j60_net *priv,\r\nu8 address, u16 data)\r\n{\r\nenc28j60_set_bank(priv, address);\r\nspi_write_op(priv, ENC28J60_WRITE_CTRL_REG, address, (u8) data);\r\nspi_write_op(priv, ENC28J60_WRITE_CTRL_REG, address + 1,\r\n(u8) (data >> 8));\r\n}\r\nstatic void locked_regw_write(struct enc28j60_net *priv,\r\nu8 address, u16 data)\r\n{\r\nmutex_lock(&priv->lock);\r\nnolock_regw_write(priv, address, data);\r\nmutex_unlock(&priv->lock);\r\n}\r\nstatic void enc28j60_mem_read(struct enc28j60_net *priv,\r\nu16 addr, int len, u8 *data)\r\n{\r\nmutex_lock(&priv->lock);\r\nnolock_regw_write(priv, ERDPTL, addr);\r\n#ifdef CONFIG_ENC28J60_WRITEVERIFY\r\nif (netif_msg_drv(priv)) {\r\nu16 reg;\r\nreg = nolock_regw_read(priv, ERDPTL);\r\nif (reg != addr)\r\nprintk(KERN_DEBUG DRV_NAME ": %s() error writing ERDPT "\r\n"(0x%04x - 0x%04x)\n", __func__, reg, addr);\r\n}\r\n#endif\r\nspi_read_buf(priv, len, data);\r\nmutex_unlock(&priv->lock);\r\n}\r\nstatic void\r\nenc28j60_packet_write(struct enc28j60_net *priv, int len, const u8 *data)\r\n{\r\nmutex_lock(&priv->lock);\r\nnolock_regw_write(priv, EWRPTL, TXSTART_INIT);\r\n#ifdef CONFIG_ENC28J60_WRITEVERIFY\r\nif (netif_msg_drv(priv)) {\r\nu16 reg;\r\nreg = nolock_regw_read(priv, EWRPTL);\r\nif (reg != TXSTART_INIT)\r\nprintk(KERN_DEBUG DRV_NAME\r\n": %s() ERWPT:0x%04x != 0x%04x\n",\r\n__func__, reg, TXSTART_INIT);\r\n}\r\n#endif\r\nnolock_regw_write(priv, ETXNDL, TXSTART_INIT + len);\r\nspi_write_op(priv, ENC28J60_WRITE_BUF_MEM, 0, 0x00);\r\nif (netif_msg_hw(priv))\r\nprintk(KERN_DEBUG DRV_NAME\r\n": %s() after control byte ERWPT:0x%04x\n",\r\n__func__, nolock_regw_read(priv, EWRPTL));\r\nspi_write_buf(priv, len, data);\r\nif (netif_msg_hw(priv))\r\nprintk(KERN_DEBUG DRV_NAME\r\n": %s() after write packet ERWPT:0x%04x, len=%d\n",\r\n__func__, nolock_regw_read(priv, EWRPTL), len);\r\nmutex_unlock(&priv->lock);\r\n}\r\nstatic int poll_ready(struct enc28j60_net *priv, u8 reg, u8 mask, u8 val)\r\n{\r\nunsigned long timeout = jiffies + msec20_to_jiffies;\r\nwhile ((nolock_regb_read(priv, reg) & mask) != val) {\r\nif (time_after(jiffies, timeout)) {\r\nif (netif_msg_drv(priv))\r\ndev_dbg(&priv->spi->dev,\r\n"reg %02x ready timeout!\n", reg);\r\nreturn -ETIMEDOUT;\r\n}\r\ncpu_relax();\r\n}\r\nreturn 0;\r\n}\r\nstatic int wait_phy_ready(struct enc28j60_net *priv)\r\n{\r\nreturn poll_ready(priv, MISTAT, MISTAT_BUSY, 0) ? 0 : 1;\r\n}\r\nstatic u16 enc28j60_phy_read(struct enc28j60_net *priv, u8 address)\r\n{\r\nu16 ret;\r\nmutex_lock(&priv->lock);\r\nnolock_regb_write(priv, MIREGADR, address);\r\nnolock_regb_write(priv, MICMD, MICMD_MIIRD);\r\nwait_phy_ready(priv);\r\nnolock_regb_write(priv, MICMD, 0x00);\r\nret = nolock_regw_read(priv, MIRDL);\r\nmutex_unlock(&priv->lock);\r\nreturn ret;\r\n}\r\nstatic int enc28j60_phy_write(struct enc28j60_net *priv, u8 address, u16 data)\r\n{\r\nint ret;\r\nmutex_lock(&priv->lock);\r\nnolock_regb_write(priv, MIREGADR, address);\r\nnolock_regw_write(priv, MIWRL, data);\r\nret = wait_phy_ready(priv);\r\nmutex_unlock(&priv->lock);\r\nreturn ret;\r\n}\r\nstatic int enc28j60_set_hw_macaddr(struct net_device *ndev)\r\n{\r\nint ret;\r\nstruct enc28j60_net *priv = netdev_priv(ndev);\r\nmutex_lock(&priv->lock);\r\nif (!priv->hw_enable) {\r\nif (netif_msg_drv(priv))\r\nprintk(KERN_INFO DRV_NAME\r\n": %s: Setting MAC address to %pM\n",\r\nndev->name, ndev->dev_addr);\r\nnolock_regb_write(priv, MAADR5, ndev->dev_addr[0]);\r\nnolock_regb_write(priv, MAADR4, ndev->dev_addr[1]);\r\nnolock_regb_write(priv, MAADR3, ndev->dev_addr[2]);\r\nnolock_regb_write(priv, MAADR2, ndev->dev_addr[3]);\r\nnolock_regb_write(priv, MAADR1, ndev->dev_addr[4]);\r\nnolock_regb_write(priv, MAADR0, ndev->dev_addr[5]);\r\nret = 0;\r\n} else {\r\nif (netif_msg_drv(priv))\r\nprintk(KERN_DEBUG DRV_NAME\r\n": %s() Hardware must be disabled to set "\r\n"Mac address\n", __func__);\r\nret = -EBUSY;\r\n}\r\nmutex_unlock(&priv->lock);\r\nreturn ret;\r\n}\r\nstatic int enc28j60_set_mac_address(struct net_device *dev, void *addr)\r\n{\r\nstruct sockaddr *address = addr;\r\nif (netif_running(dev))\r\nreturn -EBUSY;\r\nif (!is_valid_ether_addr(address->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(dev->dev_addr, address->sa_data, dev->addr_len);\r\nreturn enc28j60_set_hw_macaddr(dev);\r\n}\r\nstatic void enc28j60_dump_regs(struct enc28j60_net *priv, const char *msg)\r\n{\r\nmutex_lock(&priv->lock);\r\nprintk(KERN_DEBUG DRV_NAME " %s\n"\r\n"HwRevID: 0x%02x\n"\r\n"Cntrl: ECON1 ECON2 ESTAT EIR EIE\n"\r\n" 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n"\r\n"MAC : MACON1 MACON3 MACON4\n"\r\n" 0x%02x 0x%02x 0x%02x\n"\r\n"Rx : ERXST ERXND ERXWRPT ERXRDPT ERXFCON EPKTCNT MAMXFL\n"\r\n" 0x%04x 0x%04x 0x%04x 0x%04x "\r\n"0x%02x 0x%02x 0x%04x\n"\r\n"Tx : ETXST ETXND MACLCON1 MACLCON2 MAPHSUP\n"\r\n" 0x%04x 0x%04x 0x%02x 0x%02x 0x%02x\n",\r\nmsg, nolock_regb_read(priv, EREVID),\r\nnolock_regb_read(priv, ECON1), nolock_regb_read(priv, ECON2),\r\nnolock_regb_read(priv, ESTAT), nolock_regb_read(priv, EIR),\r\nnolock_regb_read(priv, EIE), nolock_regb_read(priv, MACON1),\r\nnolock_regb_read(priv, MACON3), nolock_regb_read(priv, MACON4),\r\nnolock_regw_read(priv, ERXSTL), nolock_regw_read(priv, ERXNDL),\r\nnolock_regw_read(priv, ERXWRPTL),\r\nnolock_regw_read(priv, ERXRDPTL),\r\nnolock_regb_read(priv, ERXFCON),\r\nnolock_regb_read(priv, EPKTCNT),\r\nnolock_regw_read(priv, MAMXFLL), nolock_regw_read(priv, ETXSTL),\r\nnolock_regw_read(priv, ETXNDL),\r\nnolock_regb_read(priv, MACLCON1),\r\nnolock_regb_read(priv, MACLCON2),\r\nnolock_regb_read(priv, MAPHSUP));\r\nmutex_unlock(&priv->lock);\r\n}\r\nstatic u16 erxrdpt_workaround(u16 next_packet_ptr, u16 start, u16 end)\r\n{\r\nu16 erxrdpt;\r\nif ((next_packet_ptr - 1 < start) || (next_packet_ptr - 1 > end))\r\nerxrdpt = end;\r\nelse\r\nerxrdpt = next_packet_ptr - 1;\r\nreturn erxrdpt;\r\n}\r\nstatic u16 rx_packet_start(u16 ptr)\r\n{\r\nif (ptr + RSV_SIZE > RXEND_INIT)\r\nreturn (ptr + RSV_SIZE) - (RXEND_INIT - RXSTART_INIT + 1);\r\nelse\r\nreturn ptr + RSV_SIZE;\r\n}\r\nstatic void nolock_rxfifo_init(struct enc28j60_net *priv, u16 start, u16 end)\r\n{\r\nu16 erxrdpt;\r\nif (start > 0x1FFF || end > 0x1FFF || start > end) {\r\nif (netif_msg_drv(priv))\r\nprintk(KERN_ERR DRV_NAME ": %s(%d, %d) RXFIFO "\r\n"bad parameters!\n", __func__, start, end);\r\nreturn;\r\n}\r\npriv->next_pk_ptr = start;\r\nnolock_regw_write(priv, ERXSTL, start);\r\nerxrdpt = erxrdpt_workaround(priv->next_pk_ptr, start, end);\r\nnolock_regw_write(priv, ERXRDPTL, erxrdpt);\r\nnolock_regw_write(priv, ERXNDL, end);\r\n}\r\nstatic void nolock_txfifo_init(struct enc28j60_net *priv, u16 start, u16 end)\r\n{\r\nif (start > 0x1FFF || end > 0x1FFF || start > end) {\r\nif (netif_msg_drv(priv))\r\nprintk(KERN_ERR DRV_NAME ": %s(%d, %d) TXFIFO "\r\n"bad parameters!\n", __func__, start, end);\r\nreturn;\r\n}\r\nnolock_regw_write(priv, ETXSTL, start);\r\nnolock_regw_write(priv, ETXNDL, end);\r\n}\r\nstatic void enc28j60_lowpower(struct enc28j60_net *priv, bool is_low)\r\n{\r\nif (netif_msg_drv(priv))\r\ndev_dbg(&priv->spi->dev, "%s power...\n",\r\nis_low ? "low" : "high");\r\nmutex_lock(&priv->lock);\r\nif (is_low) {\r\nnolock_reg_bfclr(priv, ECON1, ECON1_RXEN);\r\npoll_ready(priv, ESTAT, ESTAT_RXBUSY, 0);\r\npoll_ready(priv, ECON1, ECON1_TXRTS, 0);\r\nnolock_reg_bfset(priv, ECON2, ECON2_PWRSV);\r\n} else {\r\nnolock_reg_bfclr(priv, ECON2, ECON2_PWRSV);\r\npoll_ready(priv, ESTAT, ESTAT_CLKRDY, ESTAT_CLKRDY);\r\n}\r\nmutex_unlock(&priv->lock);\r\n}\r\nstatic int enc28j60_hw_init(struct enc28j60_net *priv)\r\n{\r\nu8 reg;\r\nif (netif_msg_drv(priv))\r\nprintk(KERN_DEBUG DRV_NAME ": %s() - %s\n", __func__,\r\npriv->full_duplex ? "FullDuplex" : "HalfDuplex");\r\nmutex_lock(&priv->lock);\r\nenc28j60_soft_reset(priv);\r\nspi_write_op(priv, ENC28J60_WRITE_CTRL_REG, ECON1, 0x00);\r\npriv->bank = 0;\r\npriv->hw_enable = false;\r\npriv->tx_retry_count = 0;\r\npriv->max_pk_counter = 0;\r\npriv->rxfilter = RXFILTER_NORMAL;\r\nnolock_regb_write(priv, ECON2, ECON2_AUTOINC | ECON2_VRPS);\r\nnolock_rxfifo_init(priv, RXSTART_INIT, RXEND_INIT);\r\nnolock_txfifo_init(priv, TXSTART_INIT, TXEND_INIT);\r\nmutex_unlock(&priv->lock);\r\nreg = locked_regb_read(priv, EREVID);\r\nif (netif_msg_drv(priv))\r\nprintk(KERN_INFO DRV_NAME ": chip RevID: 0x%02x\n", reg);\r\nif (reg == 0x00 || reg == 0xff) {\r\nif (netif_msg_drv(priv))\r\nprintk(KERN_DEBUG DRV_NAME ": %s() Invalid RevId %d\n",\r\n__func__, reg);\r\nreturn 0;\r\n}\r\nlocked_regb_write(priv, ERXFCON,\r\nERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN);\r\nlocked_regb_write(priv, MACON1,\r\nMACON1_MARXEN | MACON1_TXPAUS | MACON1_RXPAUS);\r\nif (priv->full_duplex) {\r\nlocked_regb_write(priv, MACON3,\r\nMACON3_PADCFG0 | MACON3_TXCRCEN |\r\nMACON3_FRMLNEN | MACON3_FULDPX);\r\nlocked_regb_write(priv, MAIPGL, 0x12);\r\nlocked_regb_write(priv, MABBIPG, 0x15);\r\n} else {\r\nlocked_regb_write(priv, MACON3,\r\nMACON3_PADCFG0 | MACON3_TXCRCEN |\r\nMACON3_FRMLNEN);\r\nlocked_regb_write(priv, MACON4, 1 << 6);\r\nlocked_regw_write(priv, MAIPGL, 0x0C12);\r\nlocked_regb_write(priv, MABBIPG, 0x12);\r\n}\r\nlocked_regw_write(priv, MAMXFLL, MAX_FRAMELEN);\r\nif (!enc28j60_phy_write(priv, PHLCON, ENC28J60_LAMPS_MODE))\r\nreturn 0;\r\nif (priv->full_duplex) {\r\nif (!enc28j60_phy_write(priv, PHCON1, PHCON1_PDPXMD))\r\nreturn 0;\r\nif (!enc28j60_phy_write(priv, PHCON2, 0x00))\r\nreturn 0;\r\n} else {\r\nif (!enc28j60_phy_write(priv, PHCON1, 0x00))\r\nreturn 0;\r\nif (!enc28j60_phy_write(priv, PHCON2, PHCON2_HDLDIS))\r\nreturn 0;\r\n}\r\nif (netif_msg_hw(priv))\r\nenc28j60_dump_regs(priv, "Hw initialized.");\r\nreturn 1;\r\n}\r\nstatic void enc28j60_hw_enable(struct enc28j60_net *priv)\r\n{\r\nif (netif_msg_hw(priv))\r\nprintk(KERN_DEBUG DRV_NAME ": %s() enabling interrupts.\n",\r\n__func__);\r\nenc28j60_phy_write(priv, PHIE, PHIE_PGEIE | PHIE_PLNKIE);\r\nmutex_lock(&priv->lock);\r\nnolock_reg_bfclr(priv, EIR, EIR_DMAIF | EIR_LINKIF |\r\nEIR_TXIF | EIR_TXERIF | EIR_RXERIF | EIR_PKTIF);\r\nnolock_regb_write(priv, EIE, EIE_INTIE | EIE_PKTIE | EIE_LINKIE |\r\nEIE_TXIE | EIE_TXERIE | EIE_RXERIE);\r\nnolock_reg_bfset(priv, ECON1, ECON1_RXEN);\r\npriv->hw_enable = true;\r\nmutex_unlock(&priv->lock);\r\n}\r\nstatic void enc28j60_hw_disable(struct enc28j60_net *priv)\r\n{\r\nmutex_lock(&priv->lock);\r\nnolock_regb_write(priv, EIE, 0x00);\r\nnolock_reg_bfclr(priv, ECON1, ECON1_RXEN);\r\npriv->hw_enable = false;\r\nmutex_unlock(&priv->lock);\r\n}\r\nstatic int\r\nenc28j60_setlink(struct net_device *ndev, u8 autoneg, u16 speed, u8 duplex)\r\n{\r\nstruct enc28j60_net *priv = netdev_priv(ndev);\r\nint ret = 0;\r\nif (!priv->hw_enable) {\r\nif (autoneg == AUTONEG_DISABLE && speed == SPEED_10)\r\npriv->full_duplex = (duplex == DUPLEX_FULL);\r\nelse {\r\nif (netif_msg_link(priv))\r\ndev_warn(&ndev->dev,\r\n"unsupported link setting\n");\r\nret = -EOPNOTSUPP;\r\n}\r\n} else {\r\nif (netif_msg_link(priv))\r\ndev_warn(&ndev->dev, "Warning: hw must be disabled "\r\n"to set link mode\n");\r\nret = -EBUSY;\r\n}\r\nreturn ret;\r\n}\r\nstatic void enc28j60_read_tsv(struct enc28j60_net *priv, u8 tsv[TSV_SIZE])\r\n{\r\nint endptr;\r\nendptr = locked_regw_read(priv, ETXNDL);\r\nif (netif_msg_hw(priv))\r\nprintk(KERN_DEBUG DRV_NAME ": reading TSV at addr:0x%04x\n",\r\nendptr + 1);\r\nenc28j60_mem_read(priv, endptr + 1, TSV_SIZE, tsv);\r\n}\r\nstatic void enc28j60_dump_tsv(struct enc28j60_net *priv, const char *msg,\r\nu8 tsv[TSV_SIZE])\r\n{\r\nu16 tmp1, tmp2;\r\nprintk(KERN_DEBUG DRV_NAME ": %s - TSV:\n", msg);\r\ntmp1 = tsv[1];\r\ntmp1 <<= 8;\r\ntmp1 |= tsv[0];\r\ntmp2 = tsv[5];\r\ntmp2 <<= 8;\r\ntmp2 |= tsv[4];\r\nprintk(KERN_DEBUG DRV_NAME ": ByteCount: %d, CollisionCount: %d,"\r\n" TotByteOnWire: %d\n", tmp1, tsv[2] & 0x0f, tmp2);\r\nprintk(KERN_DEBUG DRV_NAME ": TxDone: %d, CRCErr:%d, LenChkErr: %d,"\r\n" LenOutOfRange: %d\n", TSV_GETBIT(tsv, TSV_TXDONE),\r\nTSV_GETBIT(tsv, TSV_TXCRCERROR),\r\nTSV_GETBIT(tsv, TSV_TXLENCHKERROR),\r\nTSV_GETBIT(tsv, TSV_TXLENOUTOFRANGE));\r\nprintk(KERN_DEBUG DRV_NAME ": Multicast: %d, Broadcast: %d, "\r\n"PacketDefer: %d, ExDefer: %d\n",\r\nTSV_GETBIT(tsv, TSV_TXMULTICAST),\r\nTSV_GETBIT(tsv, TSV_TXBROADCAST),\r\nTSV_GETBIT(tsv, TSV_TXPACKETDEFER),\r\nTSV_GETBIT(tsv, TSV_TXEXDEFER));\r\nprintk(KERN_DEBUG DRV_NAME ": ExCollision: %d, LateCollision: %d, "\r\n"Giant: %d, Underrun: %d\n",\r\nTSV_GETBIT(tsv, TSV_TXEXCOLLISION),\r\nTSV_GETBIT(tsv, TSV_TXLATECOLLISION),\r\nTSV_GETBIT(tsv, TSV_TXGIANT), TSV_GETBIT(tsv, TSV_TXUNDERRUN));\r\nprintk(KERN_DEBUG DRV_NAME ": ControlFrame: %d, PauseFrame: %d, "\r\n"BackPressApp: %d, VLanTagFrame: %d\n",\r\nTSV_GETBIT(tsv, TSV_TXCONTROLFRAME),\r\nTSV_GETBIT(tsv, TSV_TXPAUSEFRAME),\r\nTSV_GETBIT(tsv, TSV_BACKPRESSUREAPP),\r\nTSV_GETBIT(tsv, TSV_TXVLANTAGFRAME));\r\n}\r\nstatic void enc28j60_dump_rsv(struct enc28j60_net *priv, const char *msg,\r\nu16 pk_ptr, int len, u16 sts)\r\n{\r\nprintk(KERN_DEBUG DRV_NAME ": %s - NextPk: 0x%04x - RSV:\n",\r\nmsg, pk_ptr);\r\nprintk(KERN_DEBUG DRV_NAME ": ByteCount: %d, DribbleNibble: %d\n", len,\r\nRSV_GETBIT(sts, RSV_DRIBBLENIBBLE));\r\nprintk(KERN_DEBUG DRV_NAME ": RxOK: %d, CRCErr:%d, LenChkErr: %d,"\r\n" LenOutOfRange: %d\n", RSV_GETBIT(sts, RSV_RXOK),\r\nRSV_GETBIT(sts, RSV_CRCERROR),\r\nRSV_GETBIT(sts, RSV_LENCHECKERR),\r\nRSV_GETBIT(sts, RSV_LENOUTOFRANGE));\r\nprintk(KERN_DEBUG DRV_NAME ": Multicast: %d, Broadcast: %d, "\r\n"LongDropEvent: %d, CarrierEvent: %d\n",\r\nRSV_GETBIT(sts, RSV_RXMULTICAST),\r\nRSV_GETBIT(sts, RSV_RXBROADCAST),\r\nRSV_GETBIT(sts, RSV_RXLONGEVDROPEV),\r\nRSV_GETBIT(sts, RSV_CARRIEREV));\r\nprintk(KERN_DEBUG DRV_NAME ": ControlFrame: %d, PauseFrame: %d,"\r\n" UnknownOp: %d, VLanTagFrame: %d\n",\r\nRSV_GETBIT(sts, RSV_RXCONTROLFRAME),\r\nRSV_GETBIT(sts, RSV_RXPAUSEFRAME),\r\nRSV_GETBIT(sts, RSV_RXUNKNOWNOPCODE),\r\nRSV_GETBIT(sts, RSV_RXTYPEVLAN));\r\n}\r\nstatic void dump_packet(const char *msg, int len, const char *data)\r\n{\r\nprintk(KERN_DEBUG DRV_NAME ": %s - packet len:%d\n", msg, len);\r\nprint_hex_dump(KERN_DEBUG, "pk data: ", DUMP_PREFIX_OFFSET, 16, 1,\r\ndata, len, true);\r\n}\r\nstatic void enc28j60_hw_rx(struct net_device *ndev)\r\n{\r\nstruct enc28j60_net *priv = netdev_priv(ndev);\r\nstruct sk_buff *skb = NULL;\r\nu16 erxrdpt, next_packet, rxstat;\r\nu8 rsv[RSV_SIZE];\r\nint len;\r\nif (netif_msg_rx_status(priv))\r\nprintk(KERN_DEBUG DRV_NAME ": RX pk_addr:0x%04x\n",\r\npriv->next_pk_ptr);\r\nif (unlikely(priv->next_pk_ptr > RXEND_INIT)) {\r\nif (netif_msg_rx_err(priv))\r\ndev_err(&ndev->dev,\r\n"%s() Invalid packet address!! 0x%04x\n",\r\n__func__, priv->next_pk_ptr);\r\nmutex_lock(&priv->lock);\r\nnolock_reg_bfclr(priv, ECON1, ECON1_RXEN);\r\nnolock_reg_bfset(priv, ECON1, ECON1_RXRST);\r\nnolock_reg_bfclr(priv, ECON1, ECON1_RXRST);\r\nnolock_rxfifo_init(priv, RXSTART_INIT, RXEND_INIT);\r\nnolock_reg_bfclr(priv, EIR, EIR_RXERIF);\r\nnolock_reg_bfset(priv, ECON1, ECON1_RXEN);\r\nmutex_unlock(&priv->lock);\r\nndev->stats.rx_errors++;\r\nreturn;\r\n}\r\nenc28j60_mem_read(priv, priv->next_pk_ptr, sizeof(rsv), rsv);\r\nnext_packet = rsv[1];\r\nnext_packet <<= 8;\r\nnext_packet |= rsv[0];\r\nlen = rsv[3];\r\nlen <<= 8;\r\nlen |= rsv[2];\r\nrxstat = rsv[5];\r\nrxstat <<= 8;\r\nrxstat |= rsv[4];\r\nif (netif_msg_rx_status(priv))\r\nenc28j60_dump_rsv(priv, __func__, next_packet, len, rxstat);\r\nif (!RSV_GETBIT(rxstat, RSV_RXOK) || len > MAX_FRAMELEN) {\r\nif (netif_msg_rx_err(priv))\r\ndev_err(&ndev->dev, "Rx Error (%04x)\n", rxstat);\r\nndev->stats.rx_errors++;\r\nif (RSV_GETBIT(rxstat, RSV_CRCERROR))\r\nndev->stats.rx_crc_errors++;\r\nif (RSV_GETBIT(rxstat, RSV_LENCHECKERR))\r\nndev->stats.rx_frame_errors++;\r\nif (len > MAX_FRAMELEN)\r\nndev->stats.rx_over_errors++;\r\n} else {\r\nskb = netdev_alloc_skb(ndev, len + NET_IP_ALIGN);\r\nif (!skb) {\r\nif (netif_msg_rx_err(priv))\r\ndev_err(&ndev->dev,\r\n"out of memory for Rx'd frame\n");\r\nndev->stats.rx_dropped++;\r\n} else {\r\nskb_reserve(skb, NET_IP_ALIGN);\r\nenc28j60_mem_read(priv,\r\nrx_packet_start(priv->next_pk_ptr),\r\nlen, skb_put(skb, len));\r\nif (netif_msg_pktdata(priv))\r\ndump_packet(__func__, skb->len, skb->data);\r\nskb->protocol = eth_type_trans(skb, ndev);\r\nndev->stats.rx_packets++;\r\nndev->stats.rx_bytes += len;\r\nnetif_rx_ni(skb);\r\n}\r\n}\r\nerxrdpt = erxrdpt_workaround(next_packet, RXSTART_INIT, RXEND_INIT);\r\nif (netif_msg_hw(priv))\r\nprintk(KERN_DEBUG DRV_NAME ": %s() ERXRDPT:0x%04x\n",\r\n__func__, erxrdpt);\r\nmutex_lock(&priv->lock);\r\nnolock_regw_write(priv, ERXRDPTL, erxrdpt);\r\n#ifdef CONFIG_ENC28J60_WRITEVERIFY\r\nif (netif_msg_drv(priv)) {\r\nu16 reg;\r\nreg = nolock_regw_read(priv, ERXRDPTL);\r\nif (reg != erxrdpt)\r\nprintk(KERN_DEBUG DRV_NAME ": %s() ERXRDPT verify "\r\n"error (0x%04x - 0x%04x)\n", __func__,\r\nreg, erxrdpt);\r\n}\r\n#endif\r\npriv->next_pk_ptr = next_packet;\r\nnolock_reg_bfset(priv, ECON2, ECON2_PKTDEC);\r\nmutex_unlock(&priv->lock);\r\n}\r\nstatic int enc28j60_get_free_rxfifo(struct enc28j60_net *priv)\r\n{\r\nint epkcnt, erxst, erxnd, erxwr, erxrd;\r\nint free_space;\r\nmutex_lock(&priv->lock);\r\nepkcnt = nolock_regb_read(priv, EPKTCNT);\r\nif (epkcnt >= 255)\r\nfree_space = -1;\r\nelse {\r\nerxst = nolock_regw_read(priv, ERXSTL);\r\nerxnd = nolock_regw_read(priv, ERXNDL);\r\nerxwr = nolock_regw_read(priv, ERXWRPTL);\r\nerxrd = nolock_regw_read(priv, ERXRDPTL);\r\nif (erxwr > erxrd)\r\nfree_space = (erxnd - erxst) - (erxwr - erxrd);\r\nelse if (erxwr == erxrd)\r\nfree_space = (erxnd - erxst);\r\nelse\r\nfree_space = erxrd - erxwr - 1;\r\n}\r\nmutex_unlock(&priv->lock);\r\nif (netif_msg_rx_status(priv))\r\nprintk(KERN_DEBUG DRV_NAME ": %s() free_space = %d\n",\r\n__func__, free_space);\r\nreturn free_space;\r\n}\r\nstatic void enc28j60_check_link_status(struct net_device *ndev)\r\n{\r\nstruct enc28j60_net *priv = netdev_priv(ndev);\r\nu16 reg;\r\nint duplex;\r\nreg = enc28j60_phy_read(priv, PHSTAT2);\r\nif (netif_msg_hw(priv))\r\nprintk(KERN_DEBUG DRV_NAME ": %s() PHSTAT1: %04x, "\r\n"PHSTAT2: %04x\n", __func__,\r\nenc28j60_phy_read(priv, PHSTAT1), reg);\r\nduplex = reg & PHSTAT2_DPXSTAT;\r\nif (reg & PHSTAT2_LSTAT) {\r\nnetif_carrier_on(ndev);\r\nif (netif_msg_ifup(priv))\r\ndev_info(&ndev->dev, "link up - %s\n",\r\nduplex ? "Full duplex" : "Half duplex");\r\n} else {\r\nif (netif_msg_ifdown(priv))\r\ndev_info(&ndev->dev, "link down\n");\r\nnetif_carrier_off(ndev);\r\n}\r\n}\r\nstatic void enc28j60_tx_clear(struct net_device *ndev, bool err)\r\n{\r\nstruct enc28j60_net *priv = netdev_priv(ndev);\r\nif (err)\r\nndev->stats.tx_errors++;\r\nelse\r\nndev->stats.tx_packets++;\r\nif (priv->tx_skb) {\r\nif (!err)\r\nndev->stats.tx_bytes += priv->tx_skb->len;\r\ndev_kfree_skb(priv->tx_skb);\r\npriv->tx_skb = NULL;\r\n}\r\nlocked_reg_bfclr(priv, ECON1, ECON1_TXRTS);\r\nnetif_wake_queue(ndev);\r\n}\r\nstatic int enc28j60_rx_interrupt(struct net_device *ndev)\r\n{\r\nstruct enc28j60_net *priv = netdev_priv(ndev);\r\nint pk_counter, ret;\r\npk_counter = locked_regb_read(priv, EPKTCNT);\r\nif (pk_counter && netif_msg_intr(priv))\r\nprintk(KERN_DEBUG DRV_NAME ": intRX, pk_cnt: %d\n", pk_counter);\r\nif (pk_counter > priv->max_pk_counter) {\r\npriv->max_pk_counter = pk_counter;\r\nif (netif_msg_rx_status(priv) && priv->max_pk_counter > 1)\r\nprintk(KERN_DEBUG DRV_NAME ": RX max_pk_cnt: %d\n",\r\npriv->max_pk_counter);\r\n}\r\nret = pk_counter;\r\nwhile (pk_counter-- > 0)\r\nenc28j60_hw_rx(ndev);\r\nreturn ret;\r\n}\r\nstatic void enc28j60_irq_work_handler(struct work_struct *work)\r\n{\r\nstruct enc28j60_net *priv =\r\ncontainer_of(work, struct enc28j60_net, irq_work);\r\nstruct net_device *ndev = priv->netdev;\r\nint intflags, loop;\r\nif (netif_msg_intr(priv))\r\nprintk(KERN_DEBUG DRV_NAME ": %s() enter\n", __func__);\r\nlocked_reg_bfclr(priv, EIE, EIE_INTIE);\r\ndo {\r\nloop = 0;\r\nintflags = locked_regb_read(priv, EIR);\r\nif ((intflags & EIR_DMAIF) != 0) {\r\nloop++;\r\nif (netif_msg_intr(priv))\r\nprintk(KERN_DEBUG DRV_NAME\r\n": intDMA(%d)\n", loop);\r\nlocked_reg_bfclr(priv, EIR, EIR_DMAIF);\r\n}\r\nif ((intflags & EIR_LINKIF) != 0) {\r\nloop++;\r\nif (netif_msg_intr(priv))\r\nprintk(KERN_DEBUG DRV_NAME\r\n": intLINK(%d)\n", loop);\r\nenc28j60_check_link_status(ndev);\r\nenc28j60_phy_read(priv, PHIR);\r\n}\r\nif (((intflags & EIR_TXIF) != 0) &&\r\n((intflags & EIR_TXERIF) == 0)) {\r\nbool err = false;\r\nloop++;\r\nif (netif_msg_intr(priv))\r\nprintk(KERN_DEBUG DRV_NAME\r\n": intTX(%d)\n", loop);\r\npriv->tx_retry_count = 0;\r\nif (locked_regb_read(priv, ESTAT) & ESTAT_TXABRT) {\r\nif (netif_msg_tx_err(priv))\r\ndev_err(&ndev->dev,\r\n"Tx Error (aborted)\n");\r\nerr = true;\r\n}\r\nif (netif_msg_tx_done(priv)) {\r\nu8 tsv[TSV_SIZE];\r\nenc28j60_read_tsv(priv, tsv);\r\nenc28j60_dump_tsv(priv, "Tx Done", tsv);\r\n}\r\nenc28j60_tx_clear(ndev, err);\r\nlocked_reg_bfclr(priv, EIR, EIR_TXIF);\r\n}\r\nif ((intflags & EIR_TXERIF) != 0) {\r\nu8 tsv[TSV_SIZE];\r\nloop++;\r\nif (netif_msg_intr(priv))\r\nprintk(KERN_DEBUG DRV_NAME\r\n": intTXErr(%d)\n", loop);\r\nlocked_reg_bfclr(priv, ECON1, ECON1_TXRTS);\r\nenc28j60_read_tsv(priv, tsv);\r\nif (netif_msg_tx_err(priv))\r\nenc28j60_dump_tsv(priv, "Tx Error", tsv);\r\nmutex_lock(&priv->lock);\r\nnolock_reg_bfset(priv, ECON1, ECON1_TXRST);\r\nnolock_reg_bfclr(priv, ECON1, ECON1_TXRST);\r\nnolock_txfifo_init(priv, TXSTART_INIT, TXEND_INIT);\r\nmutex_unlock(&priv->lock);\r\nif (TSV_GETBIT(tsv, TSV_TXLATECOLLISION)) {\r\nif (netif_msg_tx_err(priv))\r\nprintk(KERN_DEBUG DRV_NAME\r\n": LateCollision TXErr (%d)\n",\r\npriv->tx_retry_count);\r\nif (priv->tx_retry_count++ < MAX_TX_RETRYCOUNT)\r\nlocked_reg_bfset(priv, ECON1,\r\nECON1_TXRTS);\r\nelse\r\nenc28j60_tx_clear(ndev, true);\r\n} else\r\nenc28j60_tx_clear(ndev, true);\r\nlocked_reg_bfclr(priv, EIR, EIR_TXERIF | EIR_TXIF);\r\n}\r\nif ((intflags & EIR_RXERIF) != 0) {\r\nloop++;\r\nif (netif_msg_intr(priv))\r\nprintk(KERN_DEBUG DRV_NAME\r\n": intRXErr(%d)\n", loop);\r\nif (enc28j60_get_free_rxfifo(priv) <= 0) {\r\nif (netif_msg_rx_err(priv))\r\nprintk(KERN_DEBUG DRV_NAME\r\n": RX Overrun\n");\r\nndev->stats.rx_dropped++;\r\n}\r\nlocked_reg_bfclr(priv, EIR, EIR_RXERIF);\r\n}\r\nif (enc28j60_rx_interrupt(ndev))\r\nloop++;\r\n} while (loop);\r\nlocked_reg_bfset(priv, EIE, EIE_INTIE);\r\nif (netif_msg_intr(priv))\r\nprintk(KERN_DEBUG DRV_NAME ": %s() exit\n", __func__);\r\n}\r\nstatic void enc28j60_hw_tx(struct enc28j60_net *priv)\r\n{\r\nBUG_ON(!priv->tx_skb);\r\nif (netif_msg_tx_queued(priv))\r\nprintk(KERN_DEBUG DRV_NAME\r\n": Tx Packet Len:%d\n", priv->tx_skb->len);\r\nif (netif_msg_pktdata(priv))\r\ndump_packet(__func__,\r\npriv->tx_skb->len, priv->tx_skb->data);\r\nenc28j60_packet_write(priv, priv->tx_skb->len, priv->tx_skb->data);\r\n#ifdef CONFIG_ENC28J60_WRITEVERIFY\r\nif (netif_msg_drv(priv)) {\r\nint test_len, k;\r\nu8 test_buf[64];\r\nint okflag;\r\ntest_len = priv->tx_skb->len;\r\nif (test_len > sizeof(test_buf))\r\ntest_len = sizeof(test_buf);\r\nenc28j60_mem_read(priv, TXSTART_INIT + 1, test_len, test_buf);\r\nokflag = 1;\r\nfor (k = 0; k < test_len; k++) {\r\nif (priv->tx_skb->data[k] != test_buf[k]) {\r\nprintk(KERN_DEBUG DRV_NAME\r\n": Error, %d location differ: "\r\n"0x%02x-0x%02x\n", k,\r\npriv->tx_skb->data[k], test_buf[k]);\r\nokflag = 0;\r\n}\r\n}\r\nif (!okflag)\r\nprintk(KERN_DEBUG DRV_NAME ": Tx write buffer, "\r\n"verify ERROR!\n");\r\n}\r\n#endif\r\nlocked_reg_bfset(priv, ECON1, ECON1_TXRTS);\r\n}\r\nstatic netdev_tx_t enc28j60_send_packet(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct enc28j60_net *priv = netdev_priv(dev);\r\nif (netif_msg_tx_queued(priv))\r\nprintk(KERN_DEBUG DRV_NAME ": %s() enter\n", __func__);\r\nnetif_stop_queue(dev);\r\npriv->tx_skb = skb;\r\nschedule_work(&priv->tx_work);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void enc28j60_tx_work_handler(struct work_struct *work)\r\n{\r\nstruct enc28j60_net *priv =\r\ncontainer_of(work, struct enc28j60_net, tx_work);\r\nenc28j60_hw_tx(priv);\r\n}\r\nstatic irqreturn_t enc28j60_irq(int irq, void *dev_id)\r\n{\r\nstruct enc28j60_net *priv = dev_id;\r\nschedule_work(&priv->irq_work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void enc28j60_tx_timeout(struct net_device *ndev)\r\n{\r\nstruct enc28j60_net *priv = netdev_priv(ndev);\r\nif (netif_msg_timer(priv))\r\ndev_err(&ndev->dev, DRV_NAME " tx timeout\n");\r\nndev->stats.tx_errors++;\r\nschedule_work(&priv->restart_work);\r\n}\r\nstatic int enc28j60_net_open(struct net_device *dev)\r\n{\r\nstruct enc28j60_net *priv = netdev_priv(dev);\r\nif (netif_msg_drv(priv))\r\nprintk(KERN_DEBUG DRV_NAME ": %s() enter\n", __func__);\r\nif (!is_valid_ether_addr(dev->dev_addr)) {\r\nif (netif_msg_ifup(priv))\r\ndev_err(&dev->dev, "invalid MAC address %pM\n",\r\ndev->dev_addr);\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nenc28j60_lowpower(priv, false);\r\nenc28j60_hw_disable(priv);\r\nif (!enc28j60_hw_init(priv)) {\r\nif (netif_msg_ifup(priv))\r\ndev_err(&dev->dev, "hw_reset() failed\n");\r\nreturn -EINVAL;\r\n}\r\nenc28j60_set_hw_macaddr(dev);\r\nenc28j60_hw_enable(priv);\r\nenc28j60_check_link_status(dev);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int enc28j60_net_close(struct net_device *dev)\r\n{\r\nstruct enc28j60_net *priv = netdev_priv(dev);\r\nif (netif_msg_drv(priv))\r\nprintk(KERN_DEBUG DRV_NAME ": %s() enter\n", __func__);\r\nenc28j60_hw_disable(priv);\r\nenc28j60_lowpower(priv, true);\r\nnetif_stop_queue(dev);\r\nreturn 0;\r\n}\r\nstatic void enc28j60_set_multicast_list(struct net_device *dev)\r\n{\r\nstruct enc28j60_net *priv = netdev_priv(dev);\r\nint oldfilter = priv->rxfilter;\r\nif (dev->flags & IFF_PROMISC) {\r\nif (netif_msg_link(priv))\r\ndev_info(&dev->dev, "promiscuous mode\n");\r\npriv->rxfilter = RXFILTER_PROMISC;\r\n} else if ((dev->flags & IFF_ALLMULTI) || !netdev_mc_empty(dev)) {\r\nif (netif_msg_link(priv))\r\ndev_info(&dev->dev, "%smulticast mode\n",\r\n(dev->flags & IFF_ALLMULTI) ? "all-" : "");\r\npriv->rxfilter = RXFILTER_MULTI;\r\n} else {\r\nif (netif_msg_link(priv))\r\ndev_info(&dev->dev, "normal mode\n");\r\npriv->rxfilter = RXFILTER_NORMAL;\r\n}\r\nif (oldfilter != priv->rxfilter)\r\nschedule_work(&priv->setrx_work);\r\n}\r\nstatic void enc28j60_setrx_work_handler(struct work_struct *work)\r\n{\r\nstruct enc28j60_net *priv =\r\ncontainer_of(work, struct enc28j60_net, setrx_work);\r\nif (priv->rxfilter == RXFILTER_PROMISC) {\r\nif (netif_msg_drv(priv))\r\nprintk(KERN_DEBUG DRV_NAME ": promiscuous mode\n");\r\nlocked_regb_write(priv, ERXFCON, 0x00);\r\n} else if (priv->rxfilter == RXFILTER_MULTI) {\r\nif (netif_msg_drv(priv))\r\nprintk(KERN_DEBUG DRV_NAME ": multicast mode\n");\r\nlocked_regb_write(priv, ERXFCON,\r\nERXFCON_UCEN | ERXFCON_CRCEN |\r\nERXFCON_BCEN | ERXFCON_MCEN);\r\n} else {\r\nif (netif_msg_drv(priv))\r\nprintk(KERN_DEBUG DRV_NAME ": normal mode\n");\r\nlocked_regb_write(priv, ERXFCON,\r\nERXFCON_UCEN | ERXFCON_CRCEN |\r\nERXFCON_BCEN);\r\n}\r\n}\r\nstatic void enc28j60_restart_work_handler(struct work_struct *work)\r\n{\r\nstruct enc28j60_net *priv =\r\ncontainer_of(work, struct enc28j60_net, restart_work);\r\nstruct net_device *ndev = priv->netdev;\r\nint ret;\r\nrtnl_lock();\r\nif (netif_running(ndev)) {\r\nenc28j60_net_close(ndev);\r\nret = enc28j60_net_open(ndev);\r\nif (unlikely(ret)) {\r\ndev_info(&ndev->dev, " could not restart %d\n", ret);\r\ndev_close(ndev);\r\n}\r\n}\r\nrtnl_unlock();\r\n}\r\nstatic void\r\nenc28j60_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info,\r\ndev_name(dev->dev.parent), sizeof(info->bus_info));\r\n}\r\nstatic int\r\nenc28j60_get_link_ksettings(struct net_device *dev,\r\nstruct ethtool_link_ksettings *cmd)\r\n{\r\nstruct enc28j60_net *priv = netdev_priv(dev);\r\nethtool_link_ksettings_zero_link_mode(cmd, supported);\r\nethtool_link_ksettings_add_link_mode(cmd, supported, 10baseT_Half);\r\nethtool_link_ksettings_add_link_mode(cmd, supported, 10baseT_Full);\r\nethtool_link_ksettings_add_link_mode(cmd, supported, TP);\r\ncmd->base.speed = SPEED_10;\r\ncmd->base.duplex = priv->full_duplex ? DUPLEX_FULL : DUPLEX_HALF;\r\ncmd->base.port = PORT_TP;\r\ncmd->base.autoneg = AUTONEG_DISABLE;\r\nreturn 0;\r\n}\r\nstatic int\r\nenc28j60_set_link_ksettings(struct net_device *dev,\r\nconst struct ethtool_link_ksettings *cmd)\r\n{\r\nreturn enc28j60_setlink(dev, cmd->base.autoneg,\r\ncmd->base.speed, cmd->base.duplex);\r\n}\r\nstatic u32 enc28j60_get_msglevel(struct net_device *dev)\r\n{\r\nstruct enc28j60_net *priv = netdev_priv(dev);\r\nreturn priv->msg_enable;\r\n}\r\nstatic void enc28j60_set_msglevel(struct net_device *dev, u32 val)\r\n{\r\nstruct enc28j60_net *priv = netdev_priv(dev);\r\npriv->msg_enable = val;\r\n}\r\nstatic int enc28j60_chipset_init(struct net_device *dev)\r\n{\r\nstruct enc28j60_net *priv = netdev_priv(dev);\r\nreturn enc28j60_hw_init(priv);\r\n}\r\nstatic int enc28j60_probe(struct spi_device *spi)\r\n{\r\nstruct net_device *dev;\r\nstruct enc28j60_net *priv;\r\nconst void *macaddr;\r\nint ret = 0;\r\nif (netif_msg_drv(&debug))\r\ndev_info(&spi->dev, DRV_NAME " Ethernet driver %s loaded\n",\r\nDRV_VERSION);\r\ndev = alloc_etherdev(sizeof(struct enc28j60_net));\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto error_alloc;\r\n}\r\npriv = netdev_priv(dev);\r\npriv->netdev = dev;\r\npriv->spi = spi;\r\npriv->msg_enable = netif_msg_init(debug.msg_enable,\r\nENC28J60_MSG_DEFAULT);\r\nmutex_init(&priv->lock);\r\nINIT_WORK(&priv->tx_work, enc28j60_tx_work_handler);\r\nINIT_WORK(&priv->setrx_work, enc28j60_setrx_work_handler);\r\nINIT_WORK(&priv->irq_work, enc28j60_irq_work_handler);\r\nINIT_WORK(&priv->restart_work, enc28j60_restart_work_handler);\r\nspi_set_drvdata(spi, priv);\r\nSET_NETDEV_DEV(dev, &spi->dev);\r\nif (!enc28j60_chipset_init(dev)) {\r\nif (netif_msg_probe(priv))\r\ndev_info(&spi->dev, DRV_NAME " chip not found\n");\r\nret = -EIO;\r\ngoto error_irq;\r\n}\r\nmacaddr = of_get_mac_address(spi->dev.of_node);\r\nif (macaddr)\r\nether_addr_copy(dev->dev_addr, macaddr);\r\nelse\r\neth_hw_addr_random(dev);\r\nenc28j60_set_hw_macaddr(dev);\r\nret = request_irq(spi->irq, enc28j60_irq, 0, DRV_NAME, priv);\r\nif (ret < 0) {\r\nif (netif_msg_probe(priv))\r\ndev_err(&spi->dev, DRV_NAME ": request irq %d failed "\r\n"(ret = %d)\n", spi->irq, ret);\r\ngoto error_irq;\r\n}\r\ndev->if_port = IF_PORT_10BASET;\r\ndev->irq = spi->irq;\r\ndev->netdev_ops = &enc28j60_netdev_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\ndev->ethtool_ops = &enc28j60_ethtool_ops;\r\nenc28j60_lowpower(priv, true);\r\nret = register_netdev(dev);\r\nif (ret) {\r\nif (netif_msg_probe(priv))\r\ndev_err(&spi->dev, "register netdev " DRV_NAME\r\n" failed (ret = %d)\n", ret);\r\ngoto error_register;\r\n}\r\ndev_info(&dev->dev, DRV_NAME " driver registered\n");\r\nreturn 0;\r\nerror_register:\r\nfree_irq(spi->irq, priv);\r\nerror_irq:\r\nfree_netdev(dev);\r\nerror_alloc:\r\nreturn ret;\r\n}\r\nstatic int enc28j60_remove(struct spi_device *spi)\r\n{\r\nstruct enc28j60_net *priv = spi_get_drvdata(spi);\r\nif (netif_msg_drv(priv))\r\nprintk(KERN_DEBUG DRV_NAME ": remove\n");\r\nunregister_netdev(priv->netdev);\r\nfree_irq(spi->irq, priv);\r\nfree_netdev(priv->netdev);\r\nreturn 0;\r\n}\r\nstatic int __init enc28j60_init(void)\r\n{\r\nmsec20_to_jiffies = msecs_to_jiffies(20);\r\nreturn spi_register_driver(&enc28j60_driver);\r\n}\r\nstatic void __exit enc28j60_exit(void)\r\n{\r\nspi_unregister_driver(&enc28j60_driver);\r\n}
