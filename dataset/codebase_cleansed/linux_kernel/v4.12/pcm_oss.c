static inline mm_segment_t snd_enter_user(void)\r\n{\r\nmm_segment_t fs = get_fs();\r\nset_fs(get_ds());\r\nreturn fs;\r\n}\r\nstatic inline void snd_leave_user(mm_segment_t fs)\r\n{\r\nset_fs(fs);\r\n}\r\nstatic int snd_interval_refine_min(struct snd_interval *i, unsigned int min, int openmin)\r\n{\r\nint changed = 0;\r\nif (i->min < min) {\r\ni->min = min;\r\ni->openmin = openmin;\r\nchanged = 1;\r\n} else if (i->min == min && !i->openmin && openmin) {\r\ni->openmin = 1;\r\nchanged = 1;\r\n}\r\nif (i->integer) {\r\nif (i->openmin) {\r\ni->min++;\r\ni->openmin = 0;\r\n}\r\n}\r\nif (snd_interval_checkempty(i)) {\r\nsnd_interval_none(i);\r\nreturn -EINVAL;\r\n}\r\nreturn changed;\r\n}\r\nstatic int snd_interval_refine_max(struct snd_interval *i, unsigned int max, int openmax)\r\n{\r\nint changed = 0;\r\nif (i->max > max) {\r\ni->max = max;\r\ni->openmax = openmax;\r\nchanged = 1;\r\n} else if (i->max == max && !i->openmax && openmax) {\r\ni->openmax = 1;\r\nchanged = 1;\r\n}\r\nif (i->integer) {\r\nif (i->openmax) {\r\ni->max--;\r\ni->openmax = 0;\r\n}\r\n}\r\nif (snd_interval_checkempty(i)) {\r\nsnd_interval_none(i);\r\nreturn -EINVAL;\r\n}\r\nreturn changed;\r\n}\r\nstatic int snd_interval_refine_set(struct snd_interval *i, unsigned int val)\r\n{\r\nstruct snd_interval t;\r\nt.empty = 0;\r\nt.min = t.max = val;\r\nt.openmin = t.openmax = 0;\r\nt.integer = 1;\r\nreturn snd_interval_refine(i, &t);\r\n}\r\nstatic unsigned int\r\nsnd_pcm_hw_param_value_min(const struct snd_pcm_hw_params *params,\r\nsnd_pcm_hw_param_t var, int *dir)\r\n{\r\nif (hw_is_mask(var)) {\r\nif (dir)\r\n*dir = 0;\r\nreturn snd_mask_min(hw_param_mask_c(params, var));\r\n}\r\nif (hw_is_interval(var)) {\r\nconst struct snd_interval *i = hw_param_interval_c(params, var);\r\nif (dir)\r\n*dir = i->openmin;\r\nreturn snd_interval_min(i);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic unsigned int\r\nsnd_pcm_hw_param_value_max(const struct snd_pcm_hw_params *params,\r\nsnd_pcm_hw_param_t var, int *dir)\r\n{\r\nif (hw_is_mask(var)) {\r\nif (dir)\r\n*dir = 0;\r\nreturn snd_mask_max(hw_param_mask_c(params, var));\r\n}\r\nif (hw_is_interval(var)) {\r\nconst struct snd_interval *i = hw_param_interval_c(params, var);\r\nif (dir)\r\n*dir = - (int) i->openmax;\r\nreturn snd_interval_max(i);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int _snd_pcm_hw_param_mask(struct snd_pcm_hw_params *params,\r\nsnd_pcm_hw_param_t var,\r\nconst struct snd_mask *val)\r\n{\r\nint changed;\r\nchanged = snd_mask_refine(hw_param_mask(params, var), val);\r\nif (changed) {\r\nparams->cmask |= 1 << var;\r\nparams->rmask |= 1 << var;\r\n}\r\nreturn changed;\r\n}\r\nstatic int snd_pcm_hw_param_mask(struct snd_pcm_substream *pcm,\r\nstruct snd_pcm_hw_params *params,\r\nsnd_pcm_hw_param_t var,\r\nconst struct snd_mask *val)\r\n{\r\nint changed = _snd_pcm_hw_param_mask(params, var, val);\r\nif (changed < 0)\r\nreturn changed;\r\nif (params->rmask) {\r\nint err = snd_pcm_hw_refine(pcm, params);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int _snd_pcm_hw_param_min(struct snd_pcm_hw_params *params,\r\nsnd_pcm_hw_param_t var, unsigned int val,\r\nint dir)\r\n{\r\nint changed;\r\nint open = 0;\r\nif (dir) {\r\nif (dir > 0) {\r\nopen = 1;\r\n} else if (dir < 0) {\r\nif (val > 0) {\r\nopen = 1;\r\nval--;\r\n}\r\n}\r\n}\r\nif (hw_is_mask(var))\r\nchanged = snd_mask_refine_min(hw_param_mask(params, var),\r\nval + !!open);\r\nelse if (hw_is_interval(var))\r\nchanged = snd_interval_refine_min(hw_param_interval(params, var),\r\nval, open);\r\nelse\r\nreturn -EINVAL;\r\nif (changed) {\r\nparams->cmask |= 1 << var;\r\nparams->rmask |= 1 << var;\r\n}\r\nreturn changed;\r\n}\r\nstatic int snd_pcm_hw_param_min(struct snd_pcm_substream *pcm,\r\nstruct snd_pcm_hw_params *params,\r\nsnd_pcm_hw_param_t var, unsigned int val,\r\nint *dir)\r\n{\r\nint changed = _snd_pcm_hw_param_min(params, var, val, dir ? *dir : 0);\r\nif (changed < 0)\r\nreturn changed;\r\nif (params->rmask) {\r\nint err = snd_pcm_hw_refine(pcm, params);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn snd_pcm_hw_param_value_min(params, var, dir);\r\n}\r\nstatic int _snd_pcm_hw_param_max(struct snd_pcm_hw_params *params,\r\nsnd_pcm_hw_param_t var, unsigned int val,\r\nint dir)\r\n{\r\nint changed;\r\nint open = 0;\r\nif (dir) {\r\nif (dir < 0) {\r\nopen = 1;\r\n} else if (dir > 0) {\r\nopen = 1;\r\nval++;\r\n}\r\n}\r\nif (hw_is_mask(var)) {\r\nif (val == 0 && open) {\r\nsnd_mask_none(hw_param_mask(params, var));\r\nchanged = -EINVAL;\r\n} else\r\nchanged = snd_mask_refine_max(hw_param_mask(params, var),\r\nval - !!open);\r\n} else if (hw_is_interval(var))\r\nchanged = snd_interval_refine_max(hw_param_interval(params, var),\r\nval, open);\r\nelse\r\nreturn -EINVAL;\r\nif (changed) {\r\nparams->cmask |= 1 << var;\r\nparams->rmask |= 1 << var;\r\n}\r\nreturn changed;\r\n}\r\nstatic int snd_pcm_hw_param_max(struct snd_pcm_substream *pcm,\r\nstruct snd_pcm_hw_params *params,\r\nsnd_pcm_hw_param_t var, unsigned int val,\r\nint *dir)\r\n{\r\nint changed = _snd_pcm_hw_param_max(params, var, val, dir ? *dir : 0);\r\nif (changed < 0)\r\nreturn changed;\r\nif (params->rmask) {\r\nint err = snd_pcm_hw_refine(pcm, params);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn snd_pcm_hw_param_value_max(params, var, dir);\r\n}\r\nstatic int boundary_sub(int a, int adir,\r\nint b, int bdir,\r\nint *c, int *cdir)\r\n{\r\nadir = adir < 0 ? -1 : (adir > 0 ? 1 : 0);\r\nbdir = bdir < 0 ? -1 : (bdir > 0 ? 1 : 0);\r\n*c = a - b;\r\n*cdir = adir - bdir;\r\nif (*cdir == -2) {\r\n(*c)--;\r\n} else if (*cdir == 2) {\r\n(*c)++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int boundary_lt(unsigned int a, int adir,\r\nunsigned int b, int bdir)\r\n{\r\nif (adir < 0) {\r\na--;\r\nadir = 1;\r\n} else if (adir > 0)\r\nadir = 1;\r\nif (bdir < 0) {\r\nb--;\r\nbdir = 1;\r\n} else if (bdir > 0)\r\nbdir = 1;\r\nreturn a < b || (a == b && adir < bdir);\r\n}\r\nstatic int boundary_nearer(int min, int mindir,\r\nint best, int bestdir,\r\nint max, int maxdir)\r\n{\r\nint dmin, dmindir;\r\nint dmax, dmaxdir;\r\nboundary_sub(best, bestdir, min, mindir, &dmin, &dmindir);\r\nboundary_sub(max, maxdir, best, bestdir, &dmax, &dmaxdir);\r\nreturn boundary_lt(dmin, dmindir, dmax, dmaxdir);\r\n}\r\nstatic int snd_pcm_hw_param_near(struct snd_pcm_substream *pcm,\r\nstruct snd_pcm_hw_params *params,\r\nsnd_pcm_hw_param_t var, unsigned int best,\r\nint *dir)\r\n{\r\nstruct snd_pcm_hw_params *save = NULL;\r\nint v;\r\nunsigned int saved_min;\r\nint last = 0;\r\nint min, max;\r\nint mindir, maxdir;\r\nint valdir = dir ? *dir : 0;\r\nif (best > INT_MAX)\r\nbest = INT_MAX;\r\nmin = max = best;\r\nmindir = maxdir = valdir;\r\nif (maxdir > 0)\r\nmaxdir = 0;\r\nelse if (maxdir == 0)\r\nmaxdir = -1;\r\nelse {\r\nmaxdir = 1;\r\nmax--;\r\n}\r\nsave = kmalloc(sizeof(*save), GFP_KERNEL);\r\nif (save == NULL)\r\nreturn -ENOMEM;\r\n*save = *params;\r\nsaved_min = min;\r\nmin = snd_pcm_hw_param_min(pcm, params, var, min, &mindir);\r\nif (min >= 0) {\r\nstruct snd_pcm_hw_params *params1;\r\nif (max < 0)\r\ngoto _end;\r\nif ((unsigned int)min == saved_min && mindir == valdir)\r\ngoto _end;\r\nparams1 = kmalloc(sizeof(*params1), GFP_KERNEL);\r\nif (params1 == NULL) {\r\nkfree(save);\r\nreturn -ENOMEM;\r\n}\r\n*params1 = *save;\r\nmax = snd_pcm_hw_param_max(pcm, params1, var, max, &maxdir);\r\nif (max < 0) {\r\nkfree(params1);\r\ngoto _end;\r\n}\r\nif (boundary_nearer(max, maxdir, best, valdir, min, mindir)) {\r\n*params = *params1;\r\nlast = 1;\r\n}\r\nkfree(params1);\r\n} else {\r\n*params = *save;\r\nmax = snd_pcm_hw_param_max(pcm, params, var, max, &maxdir);\r\nif (max < 0) {\r\nkfree(save);\r\nreturn max;\r\n}\r\nlast = 1;\r\n}\r\n_end:\r\nkfree(save);\r\nif (last)\r\nv = snd_pcm_hw_param_last(pcm, params, var, dir);\r\nelse\r\nv = snd_pcm_hw_param_first(pcm, params, var, dir);\r\nsnd_BUG_ON(v < 0);\r\nreturn v;\r\n}\r\nstatic int _snd_pcm_hw_param_set(struct snd_pcm_hw_params *params,\r\nsnd_pcm_hw_param_t var, unsigned int val,\r\nint dir)\r\n{\r\nint changed;\r\nif (hw_is_mask(var)) {\r\nstruct snd_mask *m = hw_param_mask(params, var);\r\nif (val == 0 && dir < 0) {\r\nchanged = -EINVAL;\r\nsnd_mask_none(m);\r\n} else {\r\nif (dir > 0)\r\nval++;\r\nelse if (dir < 0)\r\nval--;\r\nchanged = snd_mask_refine_set(hw_param_mask(params, var), val);\r\n}\r\n} else if (hw_is_interval(var)) {\r\nstruct snd_interval *i = hw_param_interval(params, var);\r\nif (val == 0 && dir < 0) {\r\nchanged = -EINVAL;\r\nsnd_interval_none(i);\r\n} else if (dir == 0)\r\nchanged = snd_interval_refine_set(i, val);\r\nelse {\r\nstruct snd_interval t;\r\nt.openmin = 1;\r\nt.openmax = 1;\r\nt.empty = 0;\r\nt.integer = 0;\r\nif (dir < 0) {\r\nt.min = val - 1;\r\nt.max = val;\r\n} else {\r\nt.min = val;\r\nt.max = val+1;\r\n}\r\nchanged = snd_interval_refine(i, &t);\r\n}\r\n} else\r\nreturn -EINVAL;\r\nif (changed) {\r\nparams->cmask |= 1 << var;\r\nparams->rmask |= 1 << var;\r\n}\r\nreturn changed;\r\n}\r\nstatic int snd_pcm_hw_param_set(struct snd_pcm_substream *pcm,\r\nstruct snd_pcm_hw_params *params,\r\nsnd_pcm_hw_param_t var, unsigned int val,\r\nint dir)\r\n{\r\nint changed = _snd_pcm_hw_param_set(params, var, val, dir);\r\nif (changed < 0)\r\nreturn changed;\r\nif (params->rmask) {\r\nint err = snd_pcm_hw_refine(pcm, params);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn snd_pcm_hw_param_value(params, var, NULL);\r\n}\r\nstatic int _snd_pcm_hw_param_setinteger(struct snd_pcm_hw_params *params,\r\nsnd_pcm_hw_param_t var)\r\n{\r\nint changed;\r\nchanged = snd_interval_setinteger(hw_param_interval(params, var));\r\nif (changed) {\r\nparams->cmask |= 1 << var;\r\nparams->rmask |= 1 << var;\r\n}\r\nreturn changed;\r\n}\r\nstatic int snd_pcm_oss_plugin_clear(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_pcm_plugin *plugin, *next;\r\nplugin = runtime->oss.plugin_first;\r\nwhile (plugin) {\r\nnext = plugin->next;\r\nsnd_pcm_plugin_free(plugin);\r\nplugin = next;\r\n}\r\nruntime->oss.plugin_first = runtime->oss.plugin_last = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_plugin_insert(struct snd_pcm_plugin *plugin)\r\n{\r\nstruct snd_pcm_runtime *runtime = plugin->plug->runtime;\r\nplugin->next = runtime->oss.plugin_first;\r\nplugin->prev = NULL;\r\nif (runtime->oss.plugin_first) {\r\nruntime->oss.plugin_first->prev = plugin;\r\nruntime->oss.plugin_first = plugin;\r\n} else {\r\nruntime->oss.plugin_last =\r\nruntime->oss.plugin_first = plugin;\r\n}\r\nreturn 0;\r\n}\r\nint snd_pcm_plugin_append(struct snd_pcm_plugin *plugin)\r\n{\r\nstruct snd_pcm_runtime *runtime = plugin->plug->runtime;\r\nplugin->next = NULL;\r\nplugin->prev = runtime->oss.plugin_last;\r\nif (runtime->oss.plugin_last) {\r\nruntime->oss.plugin_last->next = plugin;\r\nruntime->oss.plugin_last = plugin;\r\n} else {\r\nruntime->oss.plugin_last =\r\nruntime->oss.plugin_first = plugin;\r\n}\r\nreturn 0;\r\n}\r\nstatic long snd_pcm_oss_bytes(struct snd_pcm_substream *substream, long frames)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nlong buffer_size = snd_pcm_lib_buffer_bytes(substream);\r\nlong bytes = frames_to_bytes(runtime, frames);\r\nif (buffer_size == runtime->oss.buffer_bytes)\r\nreturn bytes;\r\n#if BITS_PER_LONG >= 64\r\nreturn runtime->oss.buffer_bytes * bytes / buffer_size;\r\n#else\r\n{\r\nu64 bsize = (u64)runtime->oss.buffer_bytes * (u64)bytes;\r\nreturn div_u64(bsize, buffer_size);\r\n}\r\n#endif\r\n}\r\nstatic long snd_pcm_alsa_frames(struct snd_pcm_substream *substream, long bytes)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nlong buffer_size = snd_pcm_lib_buffer_bytes(substream);\r\nif (buffer_size == runtime->oss.buffer_bytes)\r\nreturn bytes_to_frames(runtime, bytes);\r\nreturn bytes_to_frames(runtime, (buffer_size * bytes) / runtime->oss.buffer_bytes);\r\n}\r\nstatic inline\r\nsnd_pcm_uframes_t get_hw_ptr_period(struct snd_pcm_runtime *runtime)\r\n{\r\nreturn runtime->hw_ptr_interrupt;\r\n}\r\nstatic snd_pcm_format_t snd_pcm_oss_format_from(int format)\r\n{\r\nswitch (format) {\r\ncase AFMT_MU_LAW: return SNDRV_PCM_FORMAT_MU_LAW;\r\ncase AFMT_A_LAW: return SNDRV_PCM_FORMAT_A_LAW;\r\ncase AFMT_IMA_ADPCM: return SNDRV_PCM_FORMAT_IMA_ADPCM;\r\ncase AFMT_U8: return SNDRV_PCM_FORMAT_U8;\r\ncase AFMT_S16_LE: return SNDRV_PCM_FORMAT_S16_LE;\r\ncase AFMT_S16_BE: return SNDRV_PCM_FORMAT_S16_BE;\r\ncase AFMT_S8: return SNDRV_PCM_FORMAT_S8;\r\ncase AFMT_U16_LE: return SNDRV_PCM_FORMAT_U16_LE;\r\ncase AFMT_U16_BE: return SNDRV_PCM_FORMAT_U16_BE;\r\ncase AFMT_MPEG: return SNDRV_PCM_FORMAT_MPEG;\r\ncase AFMT_S32_LE: return SNDRV_PCM_FORMAT_S32_LE;\r\ncase AFMT_S32_BE: return SNDRV_PCM_FORMAT_S32_BE;\r\ncase AFMT_S24_LE: return SNDRV_PCM_FORMAT_S24_LE;\r\ncase AFMT_S24_BE: return SNDRV_PCM_FORMAT_S24_BE;\r\ncase AFMT_S24_PACKED: return SNDRV_PCM_FORMAT_S24_3LE;\r\ncase AFMT_FLOAT: return SNDRV_PCM_FORMAT_FLOAT;\r\ncase AFMT_SPDIF_RAW: return SNDRV_PCM_FORMAT_IEC958_SUBFRAME;\r\ndefault: return SNDRV_PCM_FORMAT_U8;\r\n}\r\n}\r\nstatic int snd_pcm_oss_format_to(snd_pcm_format_t format)\r\n{\r\nswitch (format) {\r\ncase SNDRV_PCM_FORMAT_MU_LAW: return AFMT_MU_LAW;\r\ncase SNDRV_PCM_FORMAT_A_LAW: return AFMT_A_LAW;\r\ncase SNDRV_PCM_FORMAT_IMA_ADPCM: return AFMT_IMA_ADPCM;\r\ncase SNDRV_PCM_FORMAT_U8: return AFMT_U8;\r\ncase SNDRV_PCM_FORMAT_S16_LE: return AFMT_S16_LE;\r\ncase SNDRV_PCM_FORMAT_S16_BE: return AFMT_S16_BE;\r\ncase SNDRV_PCM_FORMAT_S8: return AFMT_S8;\r\ncase SNDRV_PCM_FORMAT_U16_LE: return AFMT_U16_LE;\r\ncase SNDRV_PCM_FORMAT_U16_BE: return AFMT_U16_BE;\r\ncase SNDRV_PCM_FORMAT_MPEG: return AFMT_MPEG;\r\ncase SNDRV_PCM_FORMAT_S32_LE: return AFMT_S32_LE;\r\ncase SNDRV_PCM_FORMAT_S32_BE: return AFMT_S32_BE;\r\ncase SNDRV_PCM_FORMAT_S24_LE: return AFMT_S24_LE;\r\ncase SNDRV_PCM_FORMAT_S24_BE: return AFMT_S24_BE;\r\ncase SNDRV_PCM_FORMAT_S24_3LE: return AFMT_S24_PACKED;\r\ncase SNDRV_PCM_FORMAT_FLOAT: return AFMT_FLOAT;\r\ncase SNDRV_PCM_FORMAT_IEC958_SUBFRAME: return AFMT_SPDIF_RAW;\r\ndefault: return -EINVAL;\r\n}\r\n}\r\nstatic int snd_pcm_oss_period_size(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *oss_params,\r\nstruct snd_pcm_hw_params *slave_params)\r\n{\r\nsize_t s;\r\nsize_t oss_buffer_size, oss_period_size, oss_periods;\r\nsize_t min_period_size, max_period_size;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsize_t oss_frame_size;\r\noss_frame_size = snd_pcm_format_physical_width(params_format(oss_params)) *\r\nparams_channels(oss_params) / 8;\r\noss_buffer_size = snd_pcm_plug_client_size(substream,\r\nsnd_pcm_hw_param_value_max(slave_params, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, NULL)) * oss_frame_size;\r\noss_buffer_size = rounddown_pow_of_two(oss_buffer_size);\r\nif (atomic_read(&substream->mmap_count)) {\r\nif (oss_buffer_size > runtime->oss.mmap_bytes)\r\noss_buffer_size = runtime->oss.mmap_bytes;\r\n}\r\nif (substream->oss.setup.period_size > 16)\r\noss_period_size = substream->oss.setup.period_size;\r\nelse if (runtime->oss.fragshift) {\r\noss_period_size = 1 << runtime->oss.fragshift;\r\nif (oss_period_size > oss_buffer_size / 2)\r\noss_period_size = oss_buffer_size / 2;\r\n} else {\r\nint sd;\r\nsize_t bytes_per_sec = params_rate(oss_params) * snd_pcm_format_physical_width(params_format(oss_params)) * params_channels(oss_params) / 8;\r\noss_period_size = oss_buffer_size;\r\ndo {\r\noss_period_size /= 2;\r\n} while (oss_period_size > bytes_per_sec);\r\nif (runtime->oss.subdivision == 0) {\r\nsd = 4;\r\nif (oss_period_size / sd > 4096)\r\nsd *= 2;\r\nif (oss_period_size / sd < 4096)\r\nsd = 1;\r\n} else\r\nsd = runtime->oss.subdivision;\r\noss_period_size /= sd;\r\nif (oss_period_size < 16)\r\noss_period_size = 16;\r\n}\r\nmin_period_size = snd_pcm_plug_client_size(substream,\r\nsnd_pcm_hw_param_value_min(slave_params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, NULL));\r\nmin_period_size *= oss_frame_size;\r\nmin_period_size = roundup_pow_of_two(min_period_size);\r\nif (oss_period_size < min_period_size)\r\noss_period_size = min_period_size;\r\nmax_period_size = snd_pcm_plug_client_size(substream,\r\nsnd_pcm_hw_param_value_max(slave_params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, NULL));\r\nmax_period_size *= oss_frame_size;\r\nmax_period_size = rounddown_pow_of_two(max_period_size);\r\nif (oss_period_size > max_period_size)\r\noss_period_size = max_period_size;\r\noss_periods = oss_buffer_size / oss_period_size;\r\nif (substream->oss.setup.periods > 1)\r\noss_periods = substream->oss.setup.periods;\r\ns = snd_pcm_hw_param_value_max(slave_params, SNDRV_PCM_HW_PARAM_PERIODS, NULL);\r\nif (runtime->oss.maxfrags && s > runtime->oss.maxfrags)\r\ns = runtime->oss.maxfrags;\r\nif (oss_periods > s)\r\noss_periods = s;\r\ns = snd_pcm_hw_param_value_min(slave_params, SNDRV_PCM_HW_PARAM_PERIODS, NULL);\r\nif (s < 2)\r\ns = 2;\r\nif (oss_periods < s)\r\noss_periods = s;\r\nwhile (oss_period_size * oss_periods > oss_buffer_size)\r\noss_period_size /= 2;\r\nif (oss_period_size < 16)\r\nreturn -EINVAL;\r\nruntime->oss.period_bytes = oss_period_size;\r\nruntime->oss.period_frames = 1;\r\nruntime->oss.periods = oss_periods;\r\nreturn 0;\r\n}\r\nstatic int choose_rate(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, unsigned int best_rate)\r\n{\r\nstruct snd_interval *it;\r\nstruct snd_pcm_hw_params *save;\r\nunsigned int rate, prev;\r\nsave = kmalloc(sizeof(*save), GFP_KERNEL);\r\nif (save == NULL)\r\nreturn -ENOMEM;\r\n*save = *params;\r\nit = hw_param_interval(save, SNDRV_PCM_HW_PARAM_RATE);\r\nrate = best_rate;\r\nfor (;;) {\r\nif (it->max < rate || (it->max == rate && it->openmax))\r\nbreak;\r\nif (it->min < rate || (it->min == rate && !it->openmin)) {\r\nint ret;\r\nret = snd_pcm_hw_param_set(substream, params,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\nrate, 0);\r\nif (ret == (int)rate) {\r\nkfree(save);\r\nreturn rate;\r\n}\r\n*params = *save;\r\n}\r\nprev = rate;\r\nrate += best_rate;\r\nif (rate <= prev)\r\nbreak;\r\n}\r\nkfree(save);\r\nreturn snd_pcm_hw_param_near(substream, params, SNDRV_PCM_HW_PARAM_RATE, best_rate, NULL);\r\n}\r\nstatic int snd_pcm_oss_change_params(struct snd_pcm_substream *substream,\r\nbool trylock)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_pcm_hw_params *params, *sparams;\r\nstruct snd_pcm_sw_params *sw_params;\r\nssize_t oss_buffer_size, oss_period_size;\r\nsize_t oss_frame_size;\r\nint err;\r\nint direct;\r\nsnd_pcm_format_t format, sformat;\r\nint n;\r\nstruct snd_mask sformat_mask;\r\nstruct snd_mask mask;\r\nif (trylock) {\r\nif (!(mutex_trylock(&runtime->oss.params_lock)))\r\nreturn -EAGAIN;\r\n} else if (mutex_lock_interruptible(&runtime->oss.params_lock))\r\nreturn -EINTR;\r\nsw_params = kzalloc(sizeof(*sw_params), GFP_KERNEL);\r\nparams = kmalloc(sizeof(*params), GFP_KERNEL);\r\nsparams = kmalloc(sizeof(*sparams), GFP_KERNEL);\r\nif (!sw_params || !params || !sparams) {\r\nerr = -ENOMEM;\r\ngoto failure;\r\n}\r\nif (atomic_read(&substream->mmap_count))\r\ndirect = 1;\r\nelse\r\ndirect = substream->oss.setup.direct;\r\n_snd_pcm_hw_params_any(sparams);\r\n_snd_pcm_hw_param_setinteger(sparams, SNDRV_PCM_HW_PARAM_PERIODS);\r\n_snd_pcm_hw_param_min(sparams, SNDRV_PCM_HW_PARAM_PERIODS, 2, 0);\r\nsnd_mask_none(&mask);\r\nif (atomic_read(&substream->mmap_count))\r\nsnd_mask_set(&mask, (__force int)SNDRV_PCM_ACCESS_MMAP_INTERLEAVED);\r\nelse {\r\nsnd_mask_set(&mask, (__force int)SNDRV_PCM_ACCESS_RW_INTERLEAVED);\r\nif (!direct)\r\nsnd_mask_set(&mask, (__force int)SNDRV_PCM_ACCESS_RW_NONINTERLEAVED);\r\n}\r\nerr = snd_pcm_hw_param_mask(substream, sparams, SNDRV_PCM_HW_PARAM_ACCESS, &mask);\r\nif (err < 0) {\r\npcm_dbg(substream->pcm, "No usable accesses\n");\r\nerr = -EINVAL;\r\ngoto failure;\r\n}\r\nchoose_rate(substream, sparams, runtime->oss.rate);\r\nsnd_pcm_hw_param_near(substream, sparams, SNDRV_PCM_HW_PARAM_CHANNELS, runtime->oss.channels, NULL);\r\nformat = snd_pcm_oss_format_from(runtime->oss.format);\r\nsformat_mask = *hw_param_mask(sparams, SNDRV_PCM_HW_PARAM_FORMAT);\r\nif (direct)\r\nsformat = format;\r\nelse\r\nsformat = snd_pcm_plug_slave_format(format, &sformat_mask);\r\nif ((__force int)sformat < 0 ||\r\n!snd_mask_test(&sformat_mask, (__force int)sformat)) {\r\nfor (sformat = (__force snd_pcm_format_t)0;\r\n(__force int)sformat <= (__force int)SNDRV_PCM_FORMAT_LAST;\r\nsformat = (__force snd_pcm_format_t)((__force int)sformat + 1)) {\r\nif (snd_mask_test(&sformat_mask, (__force int)sformat) &&\r\nsnd_pcm_oss_format_to(sformat) >= 0)\r\nbreak;\r\n}\r\nif ((__force int)sformat > (__force int)SNDRV_PCM_FORMAT_LAST) {\r\npcm_dbg(substream->pcm, "Cannot find a format!!!\n");\r\nerr = -EINVAL;\r\ngoto failure;\r\n}\r\n}\r\nerr = _snd_pcm_hw_param_set(sparams, SNDRV_PCM_HW_PARAM_FORMAT, (__force int)sformat, 0);\r\nif (err < 0)\r\ngoto failure;\r\nif (direct) {\r\nmemcpy(params, sparams, sizeof(*params));\r\n} else {\r\n_snd_pcm_hw_params_any(params);\r\n_snd_pcm_hw_param_set(params, SNDRV_PCM_HW_PARAM_ACCESS,\r\n(__force int)SNDRV_PCM_ACCESS_RW_INTERLEAVED, 0);\r\n_snd_pcm_hw_param_set(params, SNDRV_PCM_HW_PARAM_FORMAT,\r\n(__force int)snd_pcm_oss_format_from(runtime->oss.format), 0);\r\n_snd_pcm_hw_param_set(params, SNDRV_PCM_HW_PARAM_CHANNELS,\r\nruntime->oss.channels, 0);\r\n_snd_pcm_hw_param_set(params, SNDRV_PCM_HW_PARAM_RATE,\r\nruntime->oss.rate, 0);\r\npdprintf("client: access = %i, format = %i, channels = %i, rate = %i\n",\r\nparams_access(params), params_format(params),\r\nparams_channels(params), params_rate(params));\r\n}\r\npdprintf("slave: access = %i, format = %i, channels = %i, rate = %i\n",\r\nparams_access(sparams), params_format(sparams),\r\nparams_channels(sparams), params_rate(sparams));\r\noss_frame_size = snd_pcm_format_physical_width(params_format(params)) *\r\nparams_channels(params) / 8;\r\n#ifdef CONFIG_SND_PCM_OSS_PLUGINS\r\nsnd_pcm_oss_plugin_clear(substream);\r\nif (!direct) {\r\nsnd_pcm_oss_plugin_clear(substream);\r\nif ((err = snd_pcm_plug_format_plugins(substream,\r\nparams,\r\nsparams)) < 0) {\r\npcm_dbg(substream->pcm,\r\n"snd_pcm_plug_format_plugins failed: %i\n", err);\r\nsnd_pcm_oss_plugin_clear(substream);\r\ngoto failure;\r\n}\r\nif (runtime->oss.plugin_first) {\r\nstruct snd_pcm_plugin *plugin;\r\nif ((err = snd_pcm_plugin_build_io(substream, sparams, &plugin)) < 0) {\r\npcm_dbg(substream->pcm,\r\n"snd_pcm_plugin_build_io failed: %i\n", err);\r\nsnd_pcm_oss_plugin_clear(substream);\r\ngoto failure;\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nerr = snd_pcm_plugin_append(plugin);\r\n} else {\r\nerr = snd_pcm_plugin_insert(plugin);\r\n}\r\nif (err < 0) {\r\nsnd_pcm_oss_plugin_clear(substream);\r\ngoto failure;\r\n}\r\n}\r\n}\r\n#endif\r\nerr = snd_pcm_oss_period_size(substream, params, sparams);\r\nif (err < 0)\r\ngoto failure;\r\nn = snd_pcm_plug_slave_size(substream, runtime->oss.period_bytes / oss_frame_size);\r\nerr = snd_pcm_hw_param_near(substream, sparams, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, n, NULL);\r\nif (err < 0)\r\ngoto failure;\r\nerr = snd_pcm_hw_param_near(substream, sparams, SNDRV_PCM_HW_PARAM_PERIODS,\r\nruntime->oss.periods, NULL);\r\nif (err < 0)\r\ngoto failure;\r\nsnd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DROP, NULL);\r\nif ((err = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_HW_PARAMS, sparams)) < 0) {\r\npcm_dbg(substream->pcm, "HW_PARAMS failed: %i\n", err);\r\ngoto failure;\r\n}\r\nif (runtime->oss.trigger) {\r\nsw_params->start_threshold = 1;\r\n} else {\r\nsw_params->start_threshold = runtime->boundary;\r\n}\r\nif (atomic_read(&substream->mmap_count) ||\r\nsubstream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\nsw_params->stop_threshold = runtime->boundary;\r\nelse\r\nsw_params->stop_threshold = runtime->buffer_size;\r\nsw_params->tstamp_mode = SNDRV_PCM_TSTAMP_NONE;\r\nsw_params->period_step = 1;\r\nsw_params->avail_min = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?\r\n1 : runtime->period_size;\r\nif (atomic_read(&substream->mmap_count) ||\r\nsubstream->oss.setup.nosilence) {\r\nsw_params->silence_threshold = 0;\r\nsw_params->silence_size = 0;\r\n} else {\r\nsnd_pcm_uframes_t frames;\r\nframes = runtime->period_size + 16;\r\nif (frames > runtime->buffer_size)\r\nframes = runtime->buffer_size;\r\nsw_params->silence_threshold = frames;\r\nsw_params->silence_size = frames;\r\n}\r\nif ((err = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_SW_PARAMS, sw_params)) < 0) {\r\npcm_dbg(substream->pcm, "SW_PARAMS failed: %i\n", err);\r\ngoto failure;\r\n}\r\nruntime->oss.periods = params_periods(sparams);\r\noss_period_size = snd_pcm_plug_client_size(substream, params_period_size(sparams));\r\nif (oss_period_size < 0) {\r\nerr = -EINVAL;\r\ngoto failure;\r\n}\r\n#ifdef CONFIG_SND_PCM_OSS_PLUGINS\r\nif (runtime->oss.plugin_first) {\r\nerr = snd_pcm_plug_alloc(substream, oss_period_size);\r\nif (err < 0)\r\ngoto failure;\r\n}\r\n#endif\r\noss_period_size *= oss_frame_size;\r\noss_buffer_size = oss_period_size * runtime->oss.periods;\r\nif (oss_buffer_size < 0) {\r\nerr = -EINVAL;\r\ngoto failure;\r\n}\r\nruntime->oss.period_bytes = oss_period_size;\r\nruntime->oss.buffer_bytes = oss_buffer_size;\r\npdprintf("oss: period bytes = %i, buffer bytes = %i\n",\r\nruntime->oss.period_bytes,\r\nruntime->oss.buffer_bytes);\r\npdprintf("slave: period_size = %i, buffer_size = %i\n",\r\nparams_period_size(sparams),\r\nparams_buffer_size(sparams));\r\nruntime->oss.format = snd_pcm_oss_format_to(params_format(params));\r\nruntime->oss.channels = params_channels(params);\r\nruntime->oss.rate = params_rate(params);\r\nvfree(runtime->oss.buffer);\r\nruntime->oss.buffer = vmalloc(runtime->oss.period_bytes);\r\nif (!runtime->oss.buffer) {\r\nerr = -ENOMEM;\r\ngoto failure;\r\n}\r\nruntime->oss.params = 0;\r\nruntime->oss.prepare = 1;\r\nruntime->oss.buffer_used = 0;\r\nif (runtime->dma_area)\r\nsnd_pcm_format_set_silence(runtime->format, runtime->dma_area, bytes_to_samples(runtime, runtime->dma_bytes));\r\nruntime->oss.period_frames = snd_pcm_alsa_frames(substream, oss_period_size);\r\nerr = 0;\r\nfailure:\r\nkfree(sw_params);\r\nkfree(params);\r\nkfree(sparams);\r\nmutex_unlock(&runtime->oss.params_lock);\r\nreturn err;\r\n}\r\nstatic int snd_pcm_oss_get_active_substream(struct snd_pcm_oss_file *pcm_oss_file, struct snd_pcm_substream **r_substream)\r\n{\r\nint idx, err;\r\nstruct snd_pcm_substream *asubstream = NULL, *substream;\r\nfor (idx = 0; idx < 2; idx++) {\r\nsubstream = pcm_oss_file->streams[idx];\r\nif (substream == NULL)\r\ncontinue;\r\nif (asubstream == NULL)\r\nasubstream = substream;\r\nif (substream->runtime->oss.params) {\r\nerr = snd_pcm_oss_change_params(substream, false);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nif (!asubstream)\r\nreturn -EIO;\r\nif (r_substream)\r\n*r_substream = asubstream;\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_oss_prepare(struct snd_pcm_substream *substream)\r\n{\r\nint err;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nerr = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_PREPARE, NULL);\r\nif (err < 0) {\r\npcm_dbg(substream->pcm,\r\n"snd_pcm_oss_prepare: SNDRV_PCM_IOCTL_PREPARE failed\n");\r\nreturn err;\r\n}\r\nruntime->oss.prepare = 0;\r\nruntime->oss.prev_hw_ptr_period = 0;\r\nruntime->oss.period_ptr = 0;\r\nruntime->oss.buffer_used = 0;\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_oss_make_ready(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nint err;\r\nif (substream == NULL)\r\nreturn 0;\r\nruntime = substream->runtime;\r\nif (runtime->oss.params) {\r\nerr = snd_pcm_oss_change_params(substream, false);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (runtime->oss.prepare) {\r\nerr = snd_pcm_oss_prepare(substream);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_oss_capture_position_fixup(struct snd_pcm_substream *substream, snd_pcm_sframes_t *delay)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nsnd_pcm_uframes_t frames;\r\nint err = 0;\r\nwhile (1) {\r\nerr = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DELAY, delay);\r\nif (err < 0)\r\nbreak;\r\nruntime = substream->runtime;\r\nif (*delay <= (snd_pcm_sframes_t)runtime->buffer_size)\r\nbreak;\r\nframes = (*delay - runtime->buffer_size) + runtime->period_size - 1;\r\nframes /= runtime->period_size;\r\nframes *= runtime->period_size;\r\nerr = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_FORWARD, &frames);\r\nif (err < 0)\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nsnd_pcm_sframes_t snd_pcm_oss_write3(struct snd_pcm_substream *substream, const char *ptr, snd_pcm_uframes_t frames, int in_kernel)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint ret;\r\nwhile (1) {\r\nif (runtime->status->state == SNDRV_PCM_STATE_XRUN ||\r\nruntime->status->state == SNDRV_PCM_STATE_SUSPENDED) {\r\n#ifdef OSS_DEBUG\r\npcm_dbg(substream->pcm,\r\n"pcm_oss: write: recovering from %s\n",\r\nruntime->status->state == SNDRV_PCM_STATE_XRUN ?\r\n"XRUN" : "SUSPEND");\r\n#endif\r\nret = snd_pcm_oss_prepare(substream);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nif (in_kernel) {\r\nmm_segment_t fs;\r\nfs = snd_enter_user();\r\nret = snd_pcm_lib_write(substream, (void __force __user *)ptr, frames);\r\nsnd_leave_user(fs);\r\n} else {\r\nret = snd_pcm_lib_write(substream, (void __force __user *)ptr, frames);\r\n}\r\nif (ret != -EPIPE && ret != -ESTRPIPE)\r\nbreak;\r\nif (runtime->status->state == SNDRV_PCM_STATE_PREPARED)\r\nreturn -EAGAIN;\r\n}\r\nreturn ret;\r\n}\r\nsnd_pcm_sframes_t snd_pcm_oss_read3(struct snd_pcm_substream *substream, char *ptr, snd_pcm_uframes_t frames, int in_kernel)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_sframes_t delay;\r\nint ret;\r\nwhile (1) {\r\nif (runtime->status->state == SNDRV_PCM_STATE_XRUN ||\r\nruntime->status->state == SNDRV_PCM_STATE_SUSPENDED) {\r\n#ifdef OSS_DEBUG\r\npcm_dbg(substream->pcm,\r\n"pcm_oss: read: recovering from %s\n",\r\nruntime->status->state == SNDRV_PCM_STATE_XRUN ?\r\n"XRUN" : "SUSPEND");\r\n#endif\r\nret = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DRAIN, NULL);\r\nif (ret < 0)\r\nbreak;\r\n} else if (runtime->status->state == SNDRV_PCM_STATE_SETUP) {\r\nret = snd_pcm_oss_prepare(substream);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nret = snd_pcm_oss_capture_position_fixup(substream, &delay);\r\nif (ret < 0)\r\nbreak;\r\nif (in_kernel) {\r\nmm_segment_t fs;\r\nfs = snd_enter_user();\r\nret = snd_pcm_lib_read(substream, (void __force __user *)ptr, frames);\r\nsnd_leave_user(fs);\r\n} else {\r\nret = snd_pcm_lib_read(substream, (void __force __user *)ptr, frames);\r\n}\r\nif (ret == -EPIPE) {\r\nif (runtime->status->state == SNDRV_PCM_STATE_DRAINING) {\r\nret = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DROP, NULL);\r\nif (ret < 0)\r\nbreak;\r\n}\r\ncontinue;\r\n}\r\nif (ret != -ESTRPIPE)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nsnd_pcm_sframes_t snd_pcm_oss_writev3(struct snd_pcm_substream *substream, void **bufs, snd_pcm_uframes_t frames, int in_kernel)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint ret;\r\nwhile (1) {\r\nif (runtime->status->state == SNDRV_PCM_STATE_XRUN ||\r\nruntime->status->state == SNDRV_PCM_STATE_SUSPENDED) {\r\n#ifdef OSS_DEBUG\r\npcm_dbg(substream->pcm,\r\n"pcm_oss: writev: recovering from %s\n",\r\nruntime->status->state == SNDRV_PCM_STATE_XRUN ?\r\n"XRUN" : "SUSPEND");\r\n#endif\r\nret = snd_pcm_oss_prepare(substream);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nif (in_kernel) {\r\nmm_segment_t fs;\r\nfs = snd_enter_user();\r\nret = snd_pcm_lib_writev(substream, (void __user **)bufs, frames);\r\nsnd_leave_user(fs);\r\n} else {\r\nret = snd_pcm_lib_writev(substream, (void __user **)bufs, frames);\r\n}\r\nif (ret != -EPIPE && ret != -ESTRPIPE)\r\nbreak;\r\nif (runtime->status->state == SNDRV_PCM_STATE_PREPARED)\r\nreturn -EAGAIN;\r\n}\r\nreturn ret;\r\n}\r\nsnd_pcm_sframes_t snd_pcm_oss_readv3(struct snd_pcm_substream *substream, void **bufs, snd_pcm_uframes_t frames, int in_kernel)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint ret;\r\nwhile (1) {\r\nif (runtime->status->state == SNDRV_PCM_STATE_XRUN ||\r\nruntime->status->state == SNDRV_PCM_STATE_SUSPENDED) {\r\n#ifdef OSS_DEBUG\r\npcm_dbg(substream->pcm,\r\n"pcm_oss: readv: recovering from %s\n",\r\nruntime->status->state == SNDRV_PCM_STATE_XRUN ?\r\n"XRUN" : "SUSPEND");\r\n#endif\r\nret = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DRAIN, NULL);\r\nif (ret < 0)\r\nbreak;\r\n} else if (runtime->status->state == SNDRV_PCM_STATE_SETUP) {\r\nret = snd_pcm_oss_prepare(substream);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nif (in_kernel) {\r\nmm_segment_t fs;\r\nfs = snd_enter_user();\r\nret = snd_pcm_lib_readv(substream, (void __user **)bufs, frames);\r\nsnd_leave_user(fs);\r\n} else {\r\nret = snd_pcm_lib_readv(substream, (void __user **)bufs, frames);\r\n}\r\nif (ret != -EPIPE && ret != -ESTRPIPE)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t snd_pcm_oss_write2(struct snd_pcm_substream *substream, const char *buf, size_t bytes, int in_kernel)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_sframes_t frames, frames1;\r\n#ifdef CONFIG_SND_PCM_OSS_PLUGINS\r\nif (runtime->oss.plugin_first) {\r\nstruct snd_pcm_plugin_channel *channels;\r\nsize_t oss_frame_bytes = (runtime->oss.plugin_first->src_width * runtime->oss.plugin_first->src_format.channels) / 8;\r\nif (!in_kernel) {\r\nif (copy_from_user(runtime->oss.buffer, (const char __force __user *)buf, bytes))\r\nreturn -EFAULT;\r\nbuf = runtime->oss.buffer;\r\n}\r\nframes = bytes / oss_frame_bytes;\r\nframes1 = snd_pcm_plug_client_channels_buf(substream, (char *)buf, frames, &channels);\r\nif (frames1 < 0)\r\nreturn frames1;\r\nframes1 = snd_pcm_plug_write_transfer(substream, channels, frames1);\r\nif (frames1 <= 0)\r\nreturn frames1;\r\nbytes = frames1 * oss_frame_bytes;\r\n} else\r\n#endif\r\n{\r\nframes = bytes_to_frames(runtime, bytes);\r\nframes1 = snd_pcm_oss_write3(substream, buf, frames, in_kernel);\r\nif (frames1 <= 0)\r\nreturn frames1;\r\nbytes = frames_to_bytes(runtime, frames1);\r\n}\r\nreturn bytes;\r\n}\r\nstatic ssize_t snd_pcm_oss_write1(struct snd_pcm_substream *substream, const char __user *buf, size_t bytes)\r\n{\r\nsize_t xfer = 0;\r\nssize_t tmp;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (atomic_read(&substream->mmap_count))\r\nreturn -ENXIO;\r\nif ((tmp = snd_pcm_oss_make_ready(substream)) < 0)\r\nreturn tmp;\r\nmutex_lock(&runtime->oss.params_lock);\r\nwhile (bytes > 0) {\r\nif (bytes < runtime->oss.period_bytes || runtime->oss.buffer_used > 0) {\r\ntmp = bytes;\r\nif (tmp + runtime->oss.buffer_used > runtime->oss.period_bytes)\r\ntmp = runtime->oss.period_bytes - runtime->oss.buffer_used;\r\nif (tmp > 0) {\r\nif (copy_from_user(runtime->oss.buffer + runtime->oss.buffer_used, buf, tmp)) {\r\ntmp = -EFAULT;\r\ngoto err;\r\n}\r\n}\r\nruntime->oss.buffer_used += tmp;\r\nbuf += tmp;\r\nbytes -= tmp;\r\nxfer += tmp;\r\nif (substream->oss.setup.partialfrag ||\r\nruntime->oss.buffer_used == runtime->oss.period_bytes) {\r\ntmp = snd_pcm_oss_write2(substream, runtime->oss.buffer + runtime->oss.period_ptr,\r\nruntime->oss.buffer_used - runtime->oss.period_ptr, 1);\r\nif (tmp <= 0)\r\ngoto err;\r\nruntime->oss.bytes += tmp;\r\nruntime->oss.period_ptr += tmp;\r\nruntime->oss.period_ptr %= runtime->oss.period_bytes;\r\nif (runtime->oss.period_ptr == 0 ||\r\nruntime->oss.period_ptr == runtime->oss.buffer_used)\r\nruntime->oss.buffer_used = 0;\r\nelse if ((substream->f_flags & O_NONBLOCK) != 0) {\r\ntmp = -EAGAIN;\r\ngoto err;\r\n}\r\n}\r\n} else {\r\ntmp = snd_pcm_oss_write2(substream,\r\n(const char __force *)buf,\r\nruntime->oss.period_bytes, 0);\r\nif (tmp <= 0)\r\ngoto err;\r\nruntime->oss.bytes += tmp;\r\nbuf += tmp;\r\nbytes -= tmp;\r\nxfer += tmp;\r\nif ((substream->f_flags & O_NONBLOCK) != 0 &&\r\ntmp != runtime->oss.period_bytes)\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&runtime->oss.params_lock);\r\nreturn xfer;\r\nerr:\r\nmutex_unlock(&runtime->oss.params_lock);\r\nreturn xfer > 0 ? (snd_pcm_sframes_t)xfer : tmp;\r\n}\r\nstatic ssize_t snd_pcm_oss_read2(struct snd_pcm_substream *substream, char *buf, size_t bytes, int in_kernel)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_sframes_t frames, frames1;\r\n#ifdef CONFIG_SND_PCM_OSS_PLUGINS\r\nchar __user *final_dst = (char __force __user *)buf;\r\nif (runtime->oss.plugin_first) {\r\nstruct snd_pcm_plugin_channel *channels;\r\nsize_t oss_frame_bytes = (runtime->oss.plugin_last->dst_width * runtime->oss.plugin_last->dst_format.channels) / 8;\r\nif (!in_kernel)\r\nbuf = runtime->oss.buffer;\r\nframes = bytes / oss_frame_bytes;\r\nframes1 = snd_pcm_plug_client_channels_buf(substream, buf, frames, &channels);\r\nif (frames1 < 0)\r\nreturn frames1;\r\nframes1 = snd_pcm_plug_read_transfer(substream, channels, frames1);\r\nif (frames1 <= 0)\r\nreturn frames1;\r\nbytes = frames1 * oss_frame_bytes;\r\nif (!in_kernel && copy_to_user(final_dst, buf, bytes))\r\nreturn -EFAULT;\r\n} else\r\n#endif\r\n{\r\nframes = bytes_to_frames(runtime, bytes);\r\nframes1 = snd_pcm_oss_read3(substream, buf, frames, in_kernel);\r\nif (frames1 <= 0)\r\nreturn frames1;\r\nbytes = frames_to_bytes(runtime, frames1);\r\n}\r\nreturn bytes;\r\n}\r\nstatic ssize_t snd_pcm_oss_read1(struct snd_pcm_substream *substream, char __user *buf, size_t bytes)\r\n{\r\nsize_t xfer = 0;\r\nssize_t tmp;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (atomic_read(&substream->mmap_count))\r\nreturn -ENXIO;\r\nif ((tmp = snd_pcm_oss_make_ready(substream)) < 0)\r\nreturn tmp;\r\nmutex_lock(&runtime->oss.params_lock);\r\nwhile (bytes > 0) {\r\nif (bytes < runtime->oss.period_bytes || runtime->oss.buffer_used > 0) {\r\nif (runtime->oss.buffer_used == 0) {\r\ntmp = snd_pcm_oss_read2(substream, runtime->oss.buffer, runtime->oss.period_bytes, 1);\r\nif (tmp <= 0)\r\ngoto err;\r\nruntime->oss.bytes += tmp;\r\nruntime->oss.period_ptr = tmp;\r\nruntime->oss.buffer_used = tmp;\r\n}\r\ntmp = bytes;\r\nif ((size_t) tmp > runtime->oss.buffer_used)\r\ntmp = runtime->oss.buffer_used;\r\nif (copy_to_user(buf, runtime->oss.buffer + (runtime->oss.period_ptr - runtime->oss.buffer_used), tmp)) {\r\ntmp = -EFAULT;\r\ngoto err;\r\n}\r\nbuf += tmp;\r\nbytes -= tmp;\r\nxfer += tmp;\r\nruntime->oss.buffer_used -= tmp;\r\n} else {\r\ntmp = snd_pcm_oss_read2(substream, (char __force *)buf,\r\nruntime->oss.period_bytes, 0);\r\nif (tmp <= 0)\r\ngoto err;\r\nruntime->oss.bytes += tmp;\r\nbuf += tmp;\r\nbytes -= tmp;\r\nxfer += tmp;\r\n}\r\n}\r\nmutex_unlock(&runtime->oss.params_lock);\r\nreturn xfer;\r\nerr:\r\nmutex_unlock(&runtime->oss.params_lock);\r\nreturn xfer > 0 ? (snd_pcm_sframes_t)xfer : tmp;\r\n}\r\nstatic int snd_pcm_oss_reset(struct snd_pcm_oss_file *pcm_oss_file)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_pcm_runtime *runtime;\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nsubstream = pcm_oss_file->streams[i];\r\nif (!substream)\r\ncontinue;\r\nruntime = substream->runtime;\r\nsnd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DROP, NULL);\r\nruntime->oss.prepare = 1;\r\nruntime->oss.buffer_used = 0;\r\nruntime->oss.prev_hw_ptr_period = 0;\r\nruntime->oss.period_ptr = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_oss_post(struct snd_pcm_oss_file *pcm_oss_file)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nint err;\r\nsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];\r\nif (substream != NULL) {\r\nif ((err = snd_pcm_oss_make_ready(substream)) < 0)\r\nreturn err;\r\nsnd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_START, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_oss_sync1(struct snd_pcm_substream *substream, size_t size)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nssize_t result = 0;\r\nsnd_pcm_state_t state;\r\nlong res;\r\nwait_queue_t wait;\r\nruntime = substream->runtime;\r\ninit_waitqueue_entry(&wait, current);\r\nadd_wait_queue(&runtime->sleep, &wait);\r\n#ifdef OSS_DEBUG\r\npcm_dbg(substream->pcm, "sync1: size = %li\n", size);\r\n#endif\r\nwhile (1) {\r\nresult = snd_pcm_oss_write2(substream, runtime->oss.buffer, size, 1);\r\nif (result > 0) {\r\nruntime->oss.buffer_used = 0;\r\nresult = 0;\r\nbreak;\r\n}\r\nif (result != 0 && result != -EAGAIN)\r\nbreak;\r\nresult = 0;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nsnd_pcm_stream_lock_irq(substream);\r\nstate = runtime->status->state;\r\nsnd_pcm_stream_unlock_irq(substream);\r\nif (state != SNDRV_PCM_STATE_RUNNING) {\r\nset_current_state(TASK_RUNNING);\r\nbreak;\r\n}\r\nres = schedule_timeout(10 * HZ);\r\nif (signal_pending(current)) {\r\nresult = -ERESTARTSYS;\r\nbreak;\r\n}\r\nif (res == 0) {\r\npcm_err(substream->pcm,\r\n"OSS sync error - DMA timeout\n");\r\nresult = -EIO;\r\nbreak;\r\n}\r\n}\r\nremove_wait_queue(&runtime->sleep, &wait);\r\nreturn result;\r\n}\r\nstatic int snd_pcm_oss_sync(struct snd_pcm_oss_file *pcm_oss_file)\r\n{\r\nint err = 0;\r\nunsigned int saved_f_flags;\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_pcm_runtime *runtime;\r\nsnd_pcm_format_t format;\r\nunsigned long width;\r\nsize_t size;\r\nsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];\r\nif (substream != NULL) {\r\nruntime = substream->runtime;\r\nif (atomic_read(&substream->mmap_count))\r\ngoto __direct;\r\nif ((err = snd_pcm_oss_make_ready(substream)) < 0)\r\nreturn err;\r\nformat = snd_pcm_oss_format_from(runtime->oss.format);\r\nwidth = snd_pcm_format_physical_width(format);\r\nmutex_lock(&runtime->oss.params_lock);\r\nif (runtime->oss.buffer_used > 0) {\r\n#ifdef OSS_DEBUG\r\npcm_dbg(substream->pcm, "sync: buffer_used\n");\r\n#endif\r\nsize = (8 * (runtime->oss.period_bytes - runtime->oss.buffer_used) + 7) / width;\r\nsnd_pcm_format_set_silence(format,\r\nruntime->oss.buffer + runtime->oss.buffer_used,\r\nsize);\r\nerr = snd_pcm_oss_sync1(substream, runtime->oss.period_bytes);\r\nif (err < 0) {\r\nmutex_unlock(&runtime->oss.params_lock);\r\nreturn err;\r\n}\r\n} else if (runtime->oss.period_ptr > 0) {\r\n#ifdef OSS_DEBUG\r\npcm_dbg(substream->pcm, "sync: period_ptr\n");\r\n#endif\r\nsize = runtime->oss.period_bytes - runtime->oss.period_ptr;\r\nsnd_pcm_format_set_silence(format,\r\nruntime->oss.buffer,\r\nsize * 8 / width);\r\nerr = snd_pcm_oss_sync1(substream, size);\r\nif (err < 0) {\r\nmutex_unlock(&runtime->oss.params_lock);\r\nreturn err;\r\n}\r\n}\r\nsize = runtime->control->appl_ptr % runtime->period_size;\r\nif (size > 0) {\r\nsize = runtime->period_size - size;\r\nif (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED) {\r\nsize = (runtime->frame_bits * size) / 8;\r\nwhile (size > 0) {\r\nmm_segment_t fs;\r\nsize_t size1 = size < runtime->oss.period_bytes ? size : runtime->oss.period_bytes;\r\nsize -= size1;\r\nsize1 *= 8;\r\nsize1 /= runtime->sample_bits;\r\nsnd_pcm_format_set_silence(runtime->format,\r\nruntime->oss.buffer,\r\nsize1);\r\nsize1 /= runtime->channels;\r\nfs = snd_enter_user();\r\nsnd_pcm_lib_write(substream, (void __force __user *)runtime->oss.buffer, size1);\r\nsnd_leave_user(fs);\r\n}\r\n} else if (runtime->access == SNDRV_PCM_ACCESS_RW_NONINTERLEAVED) {\r\nvoid __user *buffers[runtime->channels];\r\nmemset(buffers, 0, runtime->channels * sizeof(void *));\r\nsnd_pcm_lib_writev(substream, buffers, size);\r\n}\r\n}\r\nmutex_unlock(&runtime->oss.params_lock);\r\n__direct:\r\nsaved_f_flags = substream->f_flags;\r\nsubstream->f_flags &= ~O_NONBLOCK;\r\nerr = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DRAIN, NULL);\r\nsubstream->f_flags = saved_f_flags;\r\nif (err < 0)\r\nreturn err;\r\nruntime->oss.prepare = 1;\r\n}\r\nsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];\r\nif (substream != NULL) {\r\nif ((err = snd_pcm_oss_make_ready(substream)) < 0)\r\nreturn err;\r\nruntime = substream->runtime;\r\nerr = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DROP, NULL);\r\nif (err < 0)\r\nreturn err;\r\nruntime->oss.buffer_used = 0;\r\nruntime->oss.prepare = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_oss_set_rate(struct snd_pcm_oss_file *pcm_oss_file, int rate)\r\n{\r\nint idx;\r\nfor (idx = 1; idx >= 0; --idx) {\r\nstruct snd_pcm_substream *substream = pcm_oss_file->streams[idx];\r\nstruct snd_pcm_runtime *runtime;\r\nif (substream == NULL)\r\ncontinue;\r\nruntime = substream->runtime;\r\nif (rate < 1000)\r\nrate = 1000;\r\nelse if (rate > 192000)\r\nrate = 192000;\r\nif (runtime->oss.rate != rate) {\r\nruntime->oss.params = 1;\r\nruntime->oss.rate = rate;\r\n}\r\n}\r\nreturn snd_pcm_oss_get_rate(pcm_oss_file);\r\n}\r\nstatic int snd_pcm_oss_get_rate(struct snd_pcm_oss_file *pcm_oss_file)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nint err;\r\nif ((err = snd_pcm_oss_get_active_substream(pcm_oss_file, &substream)) < 0)\r\nreturn err;\r\nreturn substream->runtime->oss.rate;\r\n}\r\nstatic int snd_pcm_oss_set_channels(struct snd_pcm_oss_file *pcm_oss_file, unsigned int channels)\r\n{\r\nint idx;\r\nif (channels < 1)\r\nchannels = 1;\r\nif (channels > 128)\r\nreturn -EINVAL;\r\nfor (idx = 1; idx >= 0; --idx) {\r\nstruct snd_pcm_substream *substream = pcm_oss_file->streams[idx];\r\nstruct snd_pcm_runtime *runtime;\r\nif (substream == NULL)\r\ncontinue;\r\nruntime = substream->runtime;\r\nif (runtime->oss.channels != channels) {\r\nruntime->oss.params = 1;\r\nruntime->oss.channels = channels;\r\n}\r\n}\r\nreturn snd_pcm_oss_get_channels(pcm_oss_file);\r\n}\r\nstatic int snd_pcm_oss_get_channels(struct snd_pcm_oss_file *pcm_oss_file)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nint err;\r\nif ((err = snd_pcm_oss_get_active_substream(pcm_oss_file, &substream)) < 0)\r\nreturn err;\r\nreturn substream->runtime->oss.channels;\r\n}\r\nstatic int snd_pcm_oss_get_block_size(struct snd_pcm_oss_file *pcm_oss_file)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nint err;\r\nif ((err = snd_pcm_oss_get_active_substream(pcm_oss_file, &substream)) < 0)\r\nreturn err;\r\nreturn substream->runtime->oss.period_bytes;\r\n}\r\nstatic int snd_pcm_oss_get_formats(struct snd_pcm_oss_file *pcm_oss_file)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nint err;\r\nint direct;\r\nstruct snd_pcm_hw_params *params;\r\nunsigned int formats = 0;\r\nstruct snd_mask format_mask;\r\nint fmt;\r\nif ((err = snd_pcm_oss_get_active_substream(pcm_oss_file, &substream)) < 0)\r\nreturn err;\r\nif (atomic_read(&substream->mmap_count))\r\ndirect = 1;\r\nelse\r\ndirect = substream->oss.setup.direct;\r\nif (!direct)\r\nreturn AFMT_MU_LAW | AFMT_U8 |\r\nAFMT_S16_LE | AFMT_S16_BE |\r\nAFMT_S8 | AFMT_U16_LE |\r\nAFMT_U16_BE |\r\nAFMT_S32_LE | AFMT_S32_BE |\r\nAFMT_S24_LE | AFMT_S24_BE |\r\nAFMT_S24_PACKED;\r\nparams = kmalloc(sizeof(*params), GFP_KERNEL);\r\nif (!params)\r\nreturn -ENOMEM;\r\n_snd_pcm_hw_params_any(params);\r\nerr = snd_pcm_hw_refine(substream, params);\r\nformat_mask = *hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\r\nkfree(params);\r\nif (err < 0)\r\nreturn err;\r\nfor (fmt = 0; fmt < 32; ++fmt) {\r\nif (snd_mask_test(&format_mask, fmt)) {\r\nint f = snd_pcm_oss_format_to(fmt);\r\nif (f >= 0)\r\nformats |= f;\r\n}\r\n}\r\nreturn formats;\r\n}\r\nstatic int snd_pcm_oss_set_format(struct snd_pcm_oss_file *pcm_oss_file, int format)\r\n{\r\nint formats, idx;\r\nif (format != AFMT_QUERY) {\r\nformats = snd_pcm_oss_get_formats(pcm_oss_file);\r\nif (formats < 0)\r\nreturn formats;\r\nif (!(formats & format))\r\nformat = AFMT_U8;\r\nfor (idx = 1; idx >= 0; --idx) {\r\nstruct snd_pcm_substream *substream = pcm_oss_file->streams[idx];\r\nstruct snd_pcm_runtime *runtime;\r\nif (substream == NULL)\r\ncontinue;\r\nruntime = substream->runtime;\r\nif (runtime->oss.format != format) {\r\nruntime->oss.params = 1;\r\nruntime->oss.format = format;\r\n}\r\n}\r\n}\r\nreturn snd_pcm_oss_get_format(pcm_oss_file);\r\n}\r\nstatic int snd_pcm_oss_get_format(struct snd_pcm_oss_file *pcm_oss_file)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nint err;\r\nif ((err = snd_pcm_oss_get_active_substream(pcm_oss_file, &substream)) < 0)\r\nreturn err;\r\nreturn substream->runtime->oss.format;\r\n}\r\nstatic int snd_pcm_oss_set_subdivide1(struct snd_pcm_substream *substream, int subdivide)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nif (substream == NULL)\r\nreturn 0;\r\nruntime = substream->runtime;\r\nif (subdivide == 0) {\r\nsubdivide = runtime->oss.subdivision;\r\nif (subdivide == 0)\r\nsubdivide = 1;\r\nreturn subdivide;\r\n}\r\nif (runtime->oss.subdivision || runtime->oss.fragshift)\r\nreturn -EINVAL;\r\nif (subdivide != 1 && subdivide != 2 && subdivide != 4 &&\r\nsubdivide != 8 && subdivide != 16)\r\nreturn -EINVAL;\r\nruntime->oss.subdivision = subdivide;\r\nruntime->oss.params = 1;\r\nreturn subdivide;\r\n}\r\nstatic int snd_pcm_oss_set_subdivide(struct snd_pcm_oss_file *pcm_oss_file, int subdivide)\r\n{\r\nint err = -EINVAL, idx;\r\nfor (idx = 1; idx >= 0; --idx) {\r\nstruct snd_pcm_substream *substream = pcm_oss_file->streams[idx];\r\nif (substream == NULL)\r\ncontinue;\r\nif ((err = snd_pcm_oss_set_subdivide1(substream, subdivide)) < 0)\r\nreturn err;\r\n}\r\nreturn err;\r\n}\r\nstatic int snd_pcm_oss_set_fragment1(struct snd_pcm_substream *substream, unsigned int val)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nif (substream == NULL)\r\nreturn 0;\r\nruntime = substream->runtime;\r\nif (runtime->oss.subdivision || runtime->oss.fragshift)\r\nreturn -EINVAL;\r\nruntime->oss.fragshift = val & 0xffff;\r\nruntime->oss.maxfrags = (val >> 16) & 0xffff;\r\nif (runtime->oss.fragshift < 4)\r\nruntime->oss.fragshift = 4;\r\nif (runtime->oss.maxfrags < 2)\r\nruntime->oss.maxfrags = 2;\r\nruntime->oss.params = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_oss_set_fragment(struct snd_pcm_oss_file *pcm_oss_file, unsigned int val)\r\n{\r\nint err = -EINVAL, idx;\r\nfor (idx = 1; idx >= 0; --idx) {\r\nstruct snd_pcm_substream *substream = pcm_oss_file->streams[idx];\r\nif (substream == NULL)\r\ncontinue;\r\nif ((err = snd_pcm_oss_set_fragment1(substream, val)) < 0)\r\nreturn err;\r\n}\r\nreturn err;\r\n}\r\nstatic int snd_pcm_oss_nonblock(struct file * file)\r\n{\r\nspin_lock(&file->f_lock);\r\nfile->f_flags |= O_NONBLOCK;\r\nspin_unlock(&file->f_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_oss_get_caps1(struct snd_pcm_substream *substream, int res)\r\n{\r\nif (substream == NULL) {\r\nres &= ~DSP_CAP_DUPLEX;\r\nreturn res;\r\n}\r\n#ifdef DSP_CAP_MULTI\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nif (substream->pstr->substream_count > 1)\r\nres |= DSP_CAP_MULTI;\r\n#endif\r\n#if defined(DSP_CAP_REALTIME) && 0\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (runtime->info & (SNDRV_PCM_INFO_BLOCK_TRANSFER|SNDRV_PCM_INFO_BATCH))\r\nres &= ~DSP_CAP_REALTIME;\r\n}\r\n#endif\r\nreturn res;\r\n}\r\nstatic int snd_pcm_oss_get_caps(struct snd_pcm_oss_file *pcm_oss_file)\r\n{\r\nint result, idx;\r\nresult = DSP_CAP_TRIGGER | DSP_CAP_MMAP | DSP_CAP_DUPLEX | DSP_CAP_REALTIME;\r\nfor (idx = 0; idx < 2; idx++) {\r\nstruct snd_pcm_substream *substream = pcm_oss_file->streams[idx];\r\nresult = snd_pcm_oss_get_caps1(substream, result);\r\n}\r\nresult |= 0x0001;\r\nreturn result;\r\n}\r\nstatic void snd_pcm_oss_simulate_fill(struct snd_pcm_substream *substream,\r\nsnd_pcm_uframes_t hw_ptr)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_uframes_t appl_ptr;\r\nappl_ptr = hw_ptr + runtime->buffer_size;\r\nappl_ptr %= runtime->boundary;\r\nruntime->control->appl_ptr = appl_ptr;\r\n}\r\nstatic int snd_pcm_oss_set_trigger(struct snd_pcm_oss_file *pcm_oss_file, int trigger)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nstruct snd_pcm_substream *psubstream = NULL, *csubstream = NULL;\r\nint err, cmd;\r\n#ifdef OSS_DEBUG\r\npcm_dbg(substream->pcm, "pcm_oss: trigger = 0x%x\n", trigger);\r\n#endif\r\npsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];\r\ncsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];\r\nif (psubstream) {\r\nif ((err = snd_pcm_oss_make_ready(psubstream)) < 0)\r\nreturn err;\r\n}\r\nif (csubstream) {\r\nif ((err = snd_pcm_oss_make_ready(csubstream)) < 0)\r\nreturn err;\r\n}\r\nif (psubstream) {\r\nruntime = psubstream->runtime;\r\nif (trigger & PCM_ENABLE_OUTPUT) {\r\nif (runtime->oss.trigger)\r\ngoto _skip1;\r\nif (atomic_read(&psubstream->mmap_count))\r\nsnd_pcm_oss_simulate_fill(psubstream,\r\nget_hw_ptr_period(runtime));\r\nruntime->oss.trigger = 1;\r\nruntime->start_threshold = 1;\r\ncmd = SNDRV_PCM_IOCTL_START;\r\n} else {\r\nif (!runtime->oss.trigger)\r\ngoto _skip1;\r\nruntime->oss.trigger = 0;\r\nruntime->start_threshold = runtime->boundary;\r\ncmd = SNDRV_PCM_IOCTL_DROP;\r\nruntime->oss.prepare = 1;\r\n}\r\nerr = snd_pcm_kernel_ioctl(psubstream, cmd, NULL);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n_skip1:\r\nif (csubstream) {\r\nruntime = csubstream->runtime;\r\nif (trigger & PCM_ENABLE_INPUT) {\r\nif (runtime->oss.trigger)\r\ngoto _skip2;\r\nruntime->oss.trigger = 1;\r\nruntime->start_threshold = 1;\r\ncmd = SNDRV_PCM_IOCTL_START;\r\n} else {\r\nif (!runtime->oss.trigger)\r\ngoto _skip2;\r\nruntime->oss.trigger = 0;\r\nruntime->start_threshold = runtime->boundary;\r\ncmd = SNDRV_PCM_IOCTL_DROP;\r\nruntime->oss.prepare = 1;\r\n}\r\nerr = snd_pcm_kernel_ioctl(csubstream, cmd, NULL);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n_skip2:\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_oss_get_trigger(struct snd_pcm_oss_file *pcm_oss_file)\r\n{\r\nstruct snd_pcm_substream *psubstream = NULL, *csubstream = NULL;\r\nint result = 0;\r\npsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];\r\ncsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];\r\nif (psubstream && psubstream->runtime && psubstream->runtime->oss.trigger)\r\nresult |= PCM_ENABLE_OUTPUT;\r\nif (csubstream && csubstream->runtime && csubstream->runtime->oss.trigger)\r\nresult |= PCM_ENABLE_INPUT;\r\nreturn result;\r\n}\r\nstatic int snd_pcm_oss_get_odelay(struct snd_pcm_oss_file *pcm_oss_file)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_pcm_runtime *runtime;\r\nsnd_pcm_sframes_t delay;\r\nint err;\r\nsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];\r\nif (substream == NULL)\r\nreturn -EINVAL;\r\nif ((err = snd_pcm_oss_make_ready(substream)) < 0)\r\nreturn err;\r\nruntime = substream->runtime;\r\nif (runtime->oss.params || runtime->oss.prepare)\r\nreturn 0;\r\nerr = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DELAY, &delay);\r\nif (err == -EPIPE)\r\ndelay = 0;\r\nelse if (err < 0)\r\nreturn err;\r\nreturn snd_pcm_oss_bytes(substream, delay);\r\n}\r\nstatic int snd_pcm_oss_get_ptr(struct snd_pcm_oss_file *pcm_oss_file, int stream, struct count_info __user * _info)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_pcm_runtime *runtime;\r\nsnd_pcm_sframes_t delay;\r\nint fixup;\r\nstruct count_info info;\r\nint err;\r\nif (_info == NULL)\r\nreturn -EFAULT;\r\nsubstream = pcm_oss_file->streams[stream];\r\nif (substream == NULL)\r\nreturn -EINVAL;\r\nif ((err = snd_pcm_oss_make_ready(substream)) < 0)\r\nreturn err;\r\nruntime = substream->runtime;\r\nif (runtime->oss.params || runtime->oss.prepare) {\r\nmemset(&info, 0, sizeof(info));\r\nif (copy_to_user(_info, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nerr = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DELAY, &delay);\r\nif (err == -EPIPE || err == -ESTRPIPE || (! err && delay < 0)) {\r\nerr = 0;\r\ndelay = 0;\r\nfixup = 0;\r\n} else {\r\nfixup = runtime->oss.buffer_used;\r\n}\r\n} else {\r\nerr = snd_pcm_oss_capture_position_fixup(substream, &delay);\r\nfixup = -runtime->oss.buffer_used;\r\n}\r\nif (err < 0)\r\nreturn err;\r\ninfo.ptr = snd_pcm_oss_bytes(substream, runtime->status->hw_ptr % runtime->buffer_size);\r\nif (atomic_read(&substream->mmap_count)) {\r\nsnd_pcm_sframes_t n;\r\ndelay = get_hw_ptr_period(runtime);\r\nn = delay - runtime->oss.prev_hw_ptr_period;\r\nif (n < 0)\r\nn += runtime->boundary;\r\ninfo.blocks = n / runtime->period_size;\r\nruntime->oss.prev_hw_ptr_period = delay;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nsnd_pcm_oss_simulate_fill(substream, delay);\r\ninfo.bytes = snd_pcm_oss_bytes(substream, runtime->status->hw_ptr) & INT_MAX;\r\n} else {\r\ndelay = snd_pcm_oss_bytes(substream, delay);\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nif (substream->oss.setup.buggyptr)\r\ninfo.blocks = (runtime->oss.buffer_bytes - delay - fixup) / runtime->oss.period_bytes;\r\nelse\r\ninfo.blocks = (delay + fixup) / runtime->oss.period_bytes;\r\ninfo.bytes = (runtime->oss.bytes - delay) & INT_MAX;\r\n} else {\r\ndelay += fixup;\r\ninfo.blocks = delay / runtime->oss.period_bytes;\r\ninfo.bytes = (runtime->oss.bytes + delay) & INT_MAX;\r\n}\r\n}\r\nif (copy_to_user(_info, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_oss_get_space(struct snd_pcm_oss_file *pcm_oss_file, int stream, struct audio_buf_info __user *_info)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_pcm_runtime *runtime;\r\nsnd_pcm_sframes_t avail;\r\nint fixup;\r\nstruct audio_buf_info info;\r\nint err;\r\nif (_info == NULL)\r\nreturn -EFAULT;\r\nsubstream = pcm_oss_file->streams[stream];\r\nif (substream == NULL)\r\nreturn -EINVAL;\r\nruntime = substream->runtime;\r\nif (runtime->oss.params &&\r\n(err = snd_pcm_oss_change_params(substream, false)) < 0)\r\nreturn err;\r\ninfo.fragsize = runtime->oss.period_bytes;\r\ninfo.fragstotal = runtime->periods;\r\nif (runtime->oss.prepare) {\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\ninfo.bytes = runtime->oss.period_bytes * runtime->oss.periods;\r\ninfo.fragments = runtime->oss.periods;\r\n} else {\r\ninfo.bytes = 0;\r\ninfo.fragments = 0;\r\n}\r\n} else {\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nerr = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DELAY, &avail);\r\nif (err == -EPIPE || err == -ESTRPIPE || (! err && avail < 0)) {\r\navail = runtime->buffer_size;\r\nerr = 0;\r\nfixup = 0;\r\n} else {\r\navail = runtime->buffer_size - avail;\r\nfixup = -runtime->oss.buffer_used;\r\n}\r\n} else {\r\nerr = snd_pcm_oss_capture_position_fixup(substream, &avail);\r\nfixup = runtime->oss.buffer_used;\r\n}\r\nif (err < 0)\r\nreturn err;\r\ninfo.bytes = snd_pcm_oss_bytes(substream, avail) + fixup;\r\ninfo.fragments = info.bytes / runtime->oss.period_bytes;\r\n}\r\n#ifdef OSS_DEBUG\r\npcm_dbg(substream->pcm,\r\n"pcm_oss: space: bytes = %i, fragments = %i, fragstotal = %i, fragsize = %i\n",\r\ninfo.bytes, info.fragments, info.fragstotal, info.fragsize);\r\n#endif\r\nif (copy_to_user(_info, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_oss_get_mapbuf(struct snd_pcm_oss_file *pcm_oss_file, int stream, struct buffmem_desc __user * _info)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic const char *strip_task_path(const char *path)\r\n{\r\nconst char *ptr, *ptrl = NULL;\r\nfor (ptr = path; *ptr; ptr++) {\r\nif (*ptr == '/')\r\nptrl = ptr + 1;\r\n}\r\nreturn ptrl;\r\n}\r\nstatic void snd_pcm_oss_look_for_setup(struct snd_pcm *pcm, int stream,\r\nconst char *task_name,\r\nstruct snd_pcm_oss_setup *rsetup)\r\n{\r\nstruct snd_pcm_oss_setup *setup;\r\nmutex_lock(&pcm->streams[stream].oss.setup_mutex);\r\ndo {\r\nfor (setup = pcm->streams[stream].oss.setup_list; setup;\r\nsetup = setup->next) {\r\nif (!strcmp(setup->task_name, task_name))\r\ngoto out;\r\n}\r\n} while ((task_name = strip_task_path(task_name)) != NULL);\r\nout:\r\nif (setup)\r\n*rsetup = *setup;\r\nmutex_unlock(&pcm->streams[stream].oss.setup_mutex);\r\n}\r\nstatic void snd_pcm_oss_release_substream(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nruntime = substream->runtime;\r\nvfree(runtime->oss.buffer);\r\nruntime->oss.buffer = NULL;\r\n#ifdef CONFIG_SND_PCM_OSS_PLUGINS\r\nsnd_pcm_oss_plugin_clear(substream);\r\n#endif\r\nsubstream->oss.oss = 0;\r\n}\r\nstatic void snd_pcm_oss_init_substream(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_oss_setup *setup,\r\nint minor)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nsubstream->oss.oss = 1;\r\nsubstream->oss.setup = *setup;\r\nif (setup->nonblock)\r\nsubstream->f_flags |= O_NONBLOCK;\r\nelse if (setup->block)\r\nsubstream->f_flags &= ~O_NONBLOCK;\r\nruntime = substream->runtime;\r\nruntime->oss.params = 1;\r\nruntime->oss.trigger = 1;\r\nruntime->oss.rate = 8000;\r\nmutex_init(&runtime->oss.params_lock);\r\nswitch (SNDRV_MINOR_OSS_DEVICE(minor)) {\r\ncase SNDRV_MINOR_OSS_PCM_8:\r\nruntime->oss.format = AFMT_U8;\r\nbreak;\r\ncase SNDRV_MINOR_OSS_PCM_16:\r\nruntime->oss.format = AFMT_S16_LE;\r\nbreak;\r\ndefault:\r\nruntime->oss.format = AFMT_MU_LAW;\r\n}\r\nruntime->oss.channels = 1;\r\nruntime->oss.fragshift = 0;\r\nruntime->oss.maxfrags = 0;\r\nruntime->oss.subdivision = 0;\r\nsubstream->pcm_release = snd_pcm_oss_release_substream;\r\n}\r\nstatic int snd_pcm_oss_release_file(struct snd_pcm_oss_file *pcm_oss_file)\r\n{\r\nint cidx;\r\nif (!pcm_oss_file)\r\nreturn 0;\r\nfor (cidx = 0; cidx < 2; ++cidx) {\r\nstruct snd_pcm_substream *substream = pcm_oss_file->streams[cidx];\r\nif (substream)\r\nsnd_pcm_release_substream(substream);\r\n}\r\nkfree(pcm_oss_file);\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_oss_open_file(struct file *file,\r\nstruct snd_pcm *pcm,\r\nstruct snd_pcm_oss_file **rpcm_oss_file,\r\nint minor,\r\nstruct snd_pcm_oss_setup *setup)\r\n{\r\nint idx, err;\r\nstruct snd_pcm_oss_file *pcm_oss_file;\r\nstruct snd_pcm_substream *substream;\r\nfmode_t f_mode = file->f_mode;\r\nif (rpcm_oss_file)\r\n*rpcm_oss_file = NULL;\r\npcm_oss_file = kzalloc(sizeof(*pcm_oss_file), GFP_KERNEL);\r\nif (pcm_oss_file == NULL)\r\nreturn -ENOMEM;\r\nif ((f_mode & (FMODE_WRITE|FMODE_READ)) == (FMODE_WRITE|FMODE_READ) &&\r\n(pcm->info_flags & SNDRV_PCM_INFO_HALF_DUPLEX))\r\nf_mode = FMODE_WRITE;\r\nfile->f_flags &= ~O_APPEND;\r\nfor (idx = 0; idx < 2; idx++) {\r\nif (setup[idx].disable)\r\ncontinue;\r\nif (! pcm->streams[idx].substream_count)\r\ncontinue;\r\nif (idx == SNDRV_PCM_STREAM_PLAYBACK) {\r\nif (! (f_mode & FMODE_WRITE))\r\ncontinue;\r\n} else {\r\nif (! (f_mode & FMODE_READ))\r\ncontinue;\r\n}\r\nerr = snd_pcm_open_substream(pcm, idx, file, &substream);\r\nif (err < 0) {\r\nsnd_pcm_oss_release_file(pcm_oss_file);\r\nreturn err;\r\n}\r\npcm_oss_file->streams[idx] = substream;\r\nsubstream->file = pcm_oss_file;\r\nsnd_pcm_oss_init_substream(substream, &setup[idx], minor);\r\n}\r\nif (!pcm_oss_file->streams[0] && !pcm_oss_file->streams[1]) {\r\nsnd_pcm_oss_release_file(pcm_oss_file);\r\nreturn -EINVAL;\r\n}\r\nfile->private_data = pcm_oss_file;\r\nif (rpcm_oss_file)\r\n*rpcm_oss_file = pcm_oss_file;\r\nreturn 0;\r\n}\r\nstatic int snd_task_name(struct task_struct *task, char *name, size_t size)\r\n{\r\nunsigned int idx;\r\nif (snd_BUG_ON(!task || !name || size < 2))\r\nreturn -EINVAL;\r\nfor (idx = 0; idx < sizeof(task->comm) && idx + 1 < size; idx++)\r\nname[idx] = task->comm[idx];\r\nname[idx] = '\0';\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_oss_open(struct inode *inode, struct file *file)\r\n{\r\nint err;\r\nchar task_name[32];\r\nstruct snd_pcm *pcm;\r\nstruct snd_pcm_oss_file *pcm_oss_file;\r\nstruct snd_pcm_oss_setup setup[2];\r\nint nonblock;\r\nwait_queue_t wait;\r\nerr = nonseekable_open(inode, file);\r\nif (err < 0)\r\nreturn err;\r\npcm = snd_lookup_oss_minor_data(iminor(inode),\r\nSNDRV_OSS_DEVICE_TYPE_PCM);\r\nif (pcm == NULL) {\r\nerr = -ENODEV;\r\ngoto __error1;\r\n}\r\nerr = snd_card_file_add(pcm->card, file);\r\nif (err < 0)\r\ngoto __error1;\r\nif (!try_module_get(pcm->card->module)) {\r\nerr = -EFAULT;\r\ngoto __error2;\r\n}\r\nif (snd_task_name(current, task_name, sizeof(task_name)) < 0) {\r\nerr = -EFAULT;\r\ngoto __error;\r\n}\r\nmemset(setup, 0, sizeof(setup));\r\nif (file->f_mode & FMODE_WRITE)\r\nsnd_pcm_oss_look_for_setup(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\ntask_name, &setup[0]);\r\nif (file->f_mode & FMODE_READ)\r\nsnd_pcm_oss_look_for_setup(pcm, SNDRV_PCM_STREAM_CAPTURE,\r\ntask_name, &setup[1]);\r\nnonblock = !!(file->f_flags & O_NONBLOCK);\r\nif (!nonblock)\r\nnonblock = nonblock_open;\r\ninit_waitqueue_entry(&wait, current);\r\nadd_wait_queue(&pcm->open_wait, &wait);\r\nmutex_lock(&pcm->open_mutex);\r\nwhile (1) {\r\nerr = snd_pcm_oss_open_file(file, pcm, &pcm_oss_file,\r\niminor(inode), setup);\r\nif (err >= 0)\r\nbreak;\r\nif (err == -EAGAIN) {\r\nif (nonblock) {\r\nerr = -EBUSY;\r\nbreak;\r\n}\r\n} else\r\nbreak;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nmutex_unlock(&pcm->open_mutex);\r\nschedule();\r\nmutex_lock(&pcm->open_mutex);\r\nif (pcm->card->shutdown) {\r\nerr = -ENODEV;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nerr = -ERESTARTSYS;\r\nbreak;\r\n}\r\n}\r\nremove_wait_queue(&pcm->open_wait, &wait);\r\nmutex_unlock(&pcm->open_mutex);\r\nif (err < 0)\r\ngoto __error;\r\nsnd_card_unref(pcm->card);\r\nreturn err;\r\n__error:\r\nmodule_put(pcm->card->module);\r\n__error2:\r\nsnd_card_file_remove(pcm->card, file);\r\n__error1:\r\nif (pcm)\r\nsnd_card_unref(pcm->card);\r\nreturn err;\r\n}\r\nstatic int snd_pcm_oss_release(struct inode *inode, struct file *file)\r\n{\r\nstruct snd_pcm *pcm;\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_pcm_oss_file *pcm_oss_file;\r\npcm_oss_file = file->private_data;\r\nsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];\r\nif (substream == NULL)\r\nsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];\r\nif (snd_BUG_ON(!substream))\r\nreturn -ENXIO;\r\npcm = substream->pcm;\r\nif (!pcm->card->shutdown)\r\nsnd_pcm_oss_sync(pcm_oss_file);\r\nmutex_lock(&pcm->open_mutex);\r\nsnd_pcm_oss_release_file(pcm_oss_file);\r\nmutex_unlock(&pcm->open_mutex);\r\nwake_up(&pcm->open_wait);\r\nmodule_put(pcm->card->module);\r\nsnd_card_file_remove(pcm->card, file);\r\nreturn 0;\r\n}\r\nstatic long snd_pcm_oss_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct snd_pcm_oss_file *pcm_oss_file;\r\nint __user *p = (int __user *)arg;\r\nint res;\r\npcm_oss_file = file->private_data;\r\nif (cmd == OSS_GETVERSION)\r\nreturn put_user(SNDRV_OSS_VERSION, p);\r\nif (cmd == OSS_ALSAEMULVER)\r\nreturn put_user(1, p);\r\n#if IS_REACHABLE(CONFIG_SND_MIXER_OSS)\r\nif (((cmd >> 8) & 0xff) == 'M') {\r\nstruct snd_pcm_substream *substream;\r\nint idx;\r\nfor (idx = 0; idx < 2; ++idx) {\r\nsubstream = pcm_oss_file->streams[idx];\r\nif (substream != NULL)\r\nbreak;\r\n}\r\nif (snd_BUG_ON(idx >= 2))\r\nreturn -ENXIO;\r\nreturn snd_mixer_oss_ioctl_card(substream->pcm->card, cmd, arg);\r\n}\r\n#endif\r\nif (((cmd >> 8) & 0xff) != 'P')\r\nreturn -EINVAL;\r\n#ifdef OSS_DEBUG\r\npr_debug("pcm_oss: ioctl = 0x%x\n", cmd);\r\n#endif\r\nswitch (cmd) {\r\ncase SNDCTL_DSP_RESET:\r\nreturn snd_pcm_oss_reset(pcm_oss_file);\r\ncase SNDCTL_DSP_SYNC:\r\nreturn snd_pcm_oss_sync(pcm_oss_file);\r\ncase SNDCTL_DSP_SPEED:\r\nif (get_user(res, p))\r\nreturn -EFAULT;\r\nif ((res = snd_pcm_oss_set_rate(pcm_oss_file, res))<0)\r\nreturn res;\r\nreturn put_user(res, p);\r\ncase SOUND_PCM_READ_RATE:\r\nres = snd_pcm_oss_get_rate(pcm_oss_file);\r\nif (res < 0)\r\nreturn res;\r\nreturn put_user(res, p);\r\ncase SNDCTL_DSP_STEREO:\r\nif (get_user(res, p))\r\nreturn -EFAULT;\r\nres = res > 0 ? 2 : 1;\r\nif ((res = snd_pcm_oss_set_channels(pcm_oss_file, res)) < 0)\r\nreturn res;\r\nreturn put_user(--res, p);\r\ncase SNDCTL_DSP_GETBLKSIZE:\r\nres = snd_pcm_oss_get_block_size(pcm_oss_file);\r\nif (res < 0)\r\nreturn res;\r\nreturn put_user(res, p);\r\ncase SNDCTL_DSP_SETFMT:\r\nif (get_user(res, p))\r\nreturn -EFAULT;\r\nres = snd_pcm_oss_set_format(pcm_oss_file, res);\r\nif (res < 0)\r\nreturn res;\r\nreturn put_user(res, p);\r\ncase SOUND_PCM_READ_BITS:\r\nres = snd_pcm_oss_get_format(pcm_oss_file);\r\nif (res < 0)\r\nreturn res;\r\nreturn put_user(res, p);\r\ncase SNDCTL_DSP_CHANNELS:\r\nif (get_user(res, p))\r\nreturn -EFAULT;\r\nres = snd_pcm_oss_set_channels(pcm_oss_file, res);\r\nif (res < 0)\r\nreturn res;\r\nreturn put_user(res, p);\r\ncase SOUND_PCM_READ_CHANNELS:\r\nres = snd_pcm_oss_get_channels(pcm_oss_file);\r\nif (res < 0)\r\nreturn res;\r\nreturn put_user(res, p);\r\ncase SOUND_PCM_WRITE_FILTER:\r\ncase SOUND_PCM_READ_FILTER:\r\nreturn -EIO;\r\ncase SNDCTL_DSP_POST:\r\nreturn snd_pcm_oss_post(pcm_oss_file);\r\ncase SNDCTL_DSP_SUBDIVIDE:\r\nif (get_user(res, p))\r\nreturn -EFAULT;\r\nres = snd_pcm_oss_set_subdivide(pcm_oss_file, res);\r\nif (res < 0)\r\nreturn res;\r\nreturn put_user(res, p);\r\ncase SNDCTL_DSP_SETFRAGMENT:\r\nif (get_user(res, p))\r\nreturn -EFAULT;\r\nreturn snd_pcm_oss_set_fragment(pcm_oss_file, res);\r\ncase SNDCTL_DSP_GETFMTS:\r\nres = snd_pcm_oss_get_formats(pcm_oss_file);\r\nif (res < 0)\r\nreturn res;\r\nreturn put_user(res, p);\r\ncase SNDCTL_DSP_GETOSPACE:\r\ncase SNDCTL_DSP_GETISPACE:\r\nreturn snd_pcm_oss_get_space(pcm_oss_file,\r\ncmd == SNDCTL_DSP_GETISPACE ?\r\nSNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK,\r\n(struct audio_buf_info __user *) arg);\r\ncase SNDCTL_DSP_NONBLOCK:\r\nreturn snd_pcm_oss_nonblock(file);\r\ncase SNDCTL_DSP_GETCAPS:\r\nres = snd_pcm_oss_get_caps(pcm_oss_file);\r\nif (res < 0)\r\nreturn res;\r\nreturn put_user(res, p);\r\ncase SNDCTL_DSP_GETTRIGGER:\r\nres = snd_pcm_oss_get_trigger(pcm_oss_file);\r\nif (res < 0)\r\nreturn res;\r\nreturn put_user(res, p);\r\ncase SNDCTL_DSP_SETTRIGGER:\r\nif (get_user(res, p))\r\nreturn -EFAULT;\r\nreturn snd_pcm_oss_set_trigger(pcm_oss_file, res);\r\ncase SNDCTL_DSP_GETIPTR:\r\ncase SNDCTL_DSP_GETOPTR:\r\nreturn snd_pcm_oss_get_ptr(pcm_oss_file,\r\ncmd == SNDCTL_DSP_GETIPTR ?\r\nSNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK,\r\n(struct count_info __user *) arg);\r\ncase SNDCTL_DSP_MAPINBUF:\r\ncase SNDCTL_DSP_MAPOUTBUF:\r\nreturn snd_pcm_oss_get_mapbuf(pcm_oss_file,\r\ncmd == SNDCTL_DSP_MAPINBUF ?\r\nSNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK,\r\n(struct buffmem_desc __user *) arg);\r\ncase SNDCTL_DSP_SETSYNCRO:\r\nreturn 0;\r\ncase SNDCTL_DSP_SETDUPLEX:\r\nif (snd_pcm_oss_get_caps(pcm_oss_file) & DSP_CAP_DUPLEX)\r\nreturn 0;\r\nreturn -EIO;\r\ncase SNDCTL_DSP_GETODELAY:\r\nres = snd_pcm_oss_get_odelay(pcm_oss_file);\r\nif (res < 0) {\r\nput_user(0, p);\r\nreturn res;\r\n}\r\nreturn put_user(res, p);\r\ncase SNDCTL_DSP_PROFILE:\r\nreturn 0;\r\ndefault:\r\npr_debug("pcm_oss: unknown command = 0x%x\n", cmd);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic long snd_pcm_oss_ioctl_compat(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nreturn snd_pcm_oss_ioctl(file, cmd, (unsigned long)compat_ptr(arg));\r\n}\r\nstatic ssize_t snd_pcm_oss_read(struct file *file, char __user *buf, size_t count, loff_t *offset)\r\n{\r\nstruct snd_pcm_oss_file *pcm_oss_file;\r\nstruct snd_pcm_substream *substream;\r\npcm_oss_file = file->private_data;\r\nsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];\r\nif (substream == NULL)\r\nreturn -ENXIO;\r\nsubstream->f_flags = file->f_flags & O_NONBLOCK;\r\n#ifndef OSS_DEBUG\r\nreturn snd_pcm_oss_read1(substream, buf, count);\r\n#else\r\n{\r\nssize_t res = snd_pcm_oss_read1(substream, buf, count);\r\npcm_dbg(substream->pcm,\r\n"pcm_oss: read %li bytes (returned %li bytes)\n",\r\n(long)count, (long)res);\r\nreturn res;\r\n}\r\n#endif\r\n}\r\nstatic ssize_t snd_pcm_oss_write(struct file *file, const char __user *buf, size_t count, loff_t *offset)\r\n{\r\nstruct snd_pcm_oss_file *pcm_oss_file;\r\nstruct snd_pcm_substream *substream;\r\nlong result;\r\npcm_oss_file = file->private_data;\r\nsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];\r\nif (substream == NULL)\r\nreturn -ENXIO;\r\nsubstream->f_flags = file->f_flags & O_NONBLOCK;\r\nresult = snd_pcm_oss_write1(substream, buf, count);\r\n#ifdef OSS_DEBUG\r\npcm_dbg(substream->pcm, "pcm_oss: write %li bytes (wrote %li bytes)\n",\r\n(long)count, (long)result);\r\n#endif\r\nreturn result;\r\n}\r\nstatic int snd_pcm_oss_playback_ready(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (atomic_read(&substream->mmap_count))\r\nreturn runtime->oss.prev_hw_ptr_period !=\r\nget_hw_ptr_period(runtime);\r\nelse\r\nreturn snd_pcm_playback_avail(runtime) >=\r\nruntime->oss.period_frames;\r\n}\r\nstatic int snd_pcm_oss_capture_ready(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (atomic_read(&substream->mmap_count))\r\nreturn runtime->oss.prev_hw_ptr_period !=\r\nget_hw_ptr_period(runtime);\r\nelse\r\nreturn snd_pcm_capture_avail(runtime) >=\r\nruntime->oss.period_frames;\r\n}\r\nstatic unsigned int snd_pcm_oss_poll(struct file *file, poll_table * wait)\r\n{\r\nstruct snd_pcm_oss_file *pcm_oss_file;\r\nunsigned int mask;\r\nstruct snd_pcm_substream *psubstream = NULL, *csubstream = NULL;\r\npcm_oss_file = file->private_data;\r\npsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];\r\ncsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];\r\nmask = 0;\r\nif (psubstream != NULL) {\r\nstruct snd_pcm_runtime *runtime = psubstream->runtime;\r\npoll_wait(file, &runtime->sleep, wait);\r\nsnd_pcm_stream_lock_irq(psubstream);\r\nif (runtime->status->state != SNDRV_PCM_STATE_DRAINING &&\r\n(runtime->status->state != SNDRV_PCM_STATE_RUNNING ||\r\nsnd_pcm_oss_playback_ready(psubstream)))\r\nmask |= POLLOUT | POLLWRNORM;\r\nsnd_pcm_stream_unlock_irq(psubstream);\r\n}\r\nif (csubstream != NULL) {\r\nstruct snd_pcm_runtime *runtime = csubstream->runtime;\r\nsnd_pcm_state_t ostate;\r\npoll_wait(file, &runtime->sleep, wait);\r\nsnd_pcm_stream_lock_irq(csubstream);\r\nif ((ostate = runtime->status->state) != SNDRV_PCM_STATE_RUNNING ||\r\nsnd_pcm_oss_capture_ready(csubstream))\r\nmask |= POLLIN | POLLRDNORM;\r\nsnd_pcm_stream_unlock_irq(csubstream);\r\nif (ostate != SNDRV_PCM_STATE_RUNNING && runtime->oss.trigger) {\r\nstruct snd_pcm_oss_file ofile;\r\nmemset(&ofile, 0, sizeof(ofile));\r\nofile.streams[SNDRV_PCM_STREAM_CAPTURE] = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];\r\nruntime->oss.trigger = 0;\r\nsnd_pcm_oss_set_trigger(&ofile, PCM_ENABLE_INPUT);\r\n}\r\n}\r\nreturn mask;\r\n}\r\nstatic int snd_pcm_oss_mmap(struct file *file, struct vm_area_struct *area)\r\n{\r\nstruct snd_pcm_oss_file *pcm_oss_file;\r\nstruct snd_pcm_substream *substream = NULL;\r\nstruct snd_pcm_runtime *runtime;\r\nint err;\r\n#ifdef OSS_DEBUG\r\npr_debug("pcm_oss: mmap begin\n");\r\n#endif\r\npcm_oss_file = file->private_data;\r\nswitch ((area->vm_flags & (VM_READ | VM_WRITE))) {\r\ncase VM_READ | VM_WRITE:\r\nsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];\r\nif (substream)\r\nbreak;\r\ncase VM_READ:\r\nsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_CAPTURE];\r\nbreak;\r\ncase VM_WRITE:\r\nsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\narea->vm_flags |= VM_READ;\r\nif (substream == NULL)\r\nreturn -ENXIO;\r\nruntime = substream->runtime;\r\nif (!(runtime->info & SNDRV_PCM_INFO_MMAP_VALID))\r\nreturn -EIO;\r\nif (runtime->info & SNDRV_PCM_INFO_INTERLEAVED)\r\nruntime->access = SNDRV_PCM_ACCESS_MMAP_INTERLEAVED;\r\nelse\r\nreturn -EIO;\r\nif (runtime->oss.params) {\r\nerr = snd_pcm_oss_change_params(substream, true);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n#ifdef CONFIG_SND_PCM_OSS_PLUGINS\r\nif (runtime->oss.plugin_first != NULL)\r\nreturn -EIO;\r\n#endif\r\nif (area->vm_pgoff != 0)\r\nreturn -EINVAL;\r\nerr = snd_pcm_mmap_data(substream, file, area);\r\nif (err < 0)\r\nreturn err;\r\nruntime->oss.mmap_bytes = area->vm_end - area->vm_start;\r\nruntime->silence_threshold = 0;\r\nruntime->silence_size = 0;\r\n#ifdef OSS_DEBUG\r\npr_debug("pcm_oss: mmap ok, bytes = 0x%x\n",\r\nruntime->oss.mmap_bytes);\r\n#endif\r\nruntime->stop_threshold = runtime->boundary;\r\nreturn 0;\r\n}\r\nstatic void snd_pcm_oss_proc_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_pcm_str *pstr = entry->private_data;\r\nstruct snd_pcm_oss_setup *setup = pstr->oss.setup_list;\r\nmutex_lock(&pstr->oss.setup_mutex);\r\nwhile (setup) {\r\nsnd_iprintf(buffer, "%s %u %u%s%s%s%s%s%s\n",\r\nsetup->task_name,\r\nsetup->periods,\r\nsetup->period_size,\r\nsetup->disable ? " disable" : "",\r\nsetup->direct ? " direct" : "",\r\nsetup->block ? " block" : "",\r\nsetup->nonblock ? " non-block" : "",\r\nsetup->partialfrag ? " partial-frag" : "",\r\nsetup->nosilence ? " no-silence" : "");\r\nsetup = setup->next;\r\n}\r\nmutex_unlock(&pstr->oss.setup_mutex);\r\n}\r\nstatic void snd_pcm_oss_proc_free_setup_list(struct snd_pcm_str * pstr)\r\n{\r\nstruct snd_pcm_oss_setup *setup, *setupn;\r\nfor (setup = pstr->oss.setup_list, pstr->oss.setup_list = NULL;\r\nsetup; setup = setupn) {\r\nsetupn = setup->next;\r\nkfree(setup->task_name);\r\nkfree(setup);\r\n}\r\npstr->oss.setup_list = NULL;\r\n}\r\nstatic void snd_pcm_oss_proc_write(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_pcm_str *pstr = entry->private_data;\r\nchar line[128], str[32], task_name[32];\r\nconst char *ptr;\r\nint idx1;\r\nstruct snd_pcm_oss_setup *setup, *setup1, template;\r\nwhile (!snd_info_get_line(buffer, line, sizeof(line))) {\r\nmutex_lock(&pstr->oss.setup_mutex);\r\nmemset(&template, 0, sizeof(template));\r\nptr = snd_info_get_str(task_name, line, sizeof(task_name));\r\nif (!strcmp(task_name, "clear") || !strcmp(task_name, "erase")) {\r\nsnd_pcm_oss_proc_free_setup_list(pstr);\r\nmutex_unlock(&pstr->oss.setup_mutex);\r\ncontinue;\r\n}\r\nfor (setup = pstr->oss.setup_list; setup; setup = setup->next) {\r\nif (!strcmp(setup->task_name, task_name)) {\r\ntemplate = *setup;\r\nbreak;\r\n}\r\n}\r\nptr = snd_info_get_str(str, ptr, sizeof(str));\r\ntemplate.periods = simple_strtoul(str, NULL, 10);\r\nptr = snd_info_get_str(str, ptr, sizeof(str));\r\ntemplate.period_size = simple_strtoul(str, NULL, 10);\r\nfor (idx1 = 31; idx1 >= 0; idx1--)\r\nif (template.period_size & (1 << idx1))\r\nbreak;\r\nfor (idx1--; idx1 >= 0; idx1--)\r\ntemplate.period_size &= ~(1 << idx1);\r\ndo {\r\nptr = snd_info_get_str(str, ptr, sizeof(str));\r\nif (!strcmp(str, "disable")) {\r\ntemplate.disable = 1;\r\n} else if (!strcmp(str, "direct")) {\r\ntemplate.direct = 1;\r\n} else if (!strcmp(str, "block")) {\r\ntemplate.block = 1;\r\n} else if (!strcmp(str, "non-block")) {\r\ntemplate.nonblock = 1;\r\n} else if (!strcmp(str, "partial-frag")) {\r\ntemplate.partialfrag = 1;\r\n} else if (!strcmp(str, "no-silence")) {\r\ntemplate.nosilence = 1;\r\n} else if (!strcmp(str, "buggy-ptr")) {\r\ntemplate.buggyptr = 1;\r\n}\r\n} while (*str);\r\nif (setup == NULL) {\r\nsetup = kmalloc(sizeof(*setup), GFP_KERNEL);\r\nif (! setup) {\r\nbuffer->error = -ENOMEM;\r\nmutex_unlock(&pstr->oss.setup_mutex);\r\nreturn;\r\n}\r\nif (pstr->oss.setup_list == NULL)\r\npstr->oss.setup_list = setup;\r\nelse {\r\nfor (setup1 = pstr->oss.setup_list;\r\nsetup1->next; setup1 = setup1->next);\r\nsetup1->next = setup;\r\n}\r\ntemplate.task_name = kstrdup(task_name, GFP_KERNEL);\r\nif (! template.task_name) {\r\nkfree(setup);\r\nbuffer->error = -ENOMEM;\r\nmutex_unlock(&pstr->oss.setup_mutex);\r\nreturn;\r\n}\r\n}\r\n*setup = template;\r\nmutex_unlock(&pstr->oss.setup_mutex);\r\n}\r\n}\r\nstatic void snd_pcm_oss_proc_init(struct snd_pcm *pcm)\r\n{\r\nint stream;\r\nfor (stream = 0; stream < 2; ++stream) {\r\nstruct snd_info_entry *entry;\r\nstruct snd_pcm_str *pstr = &pcm->streams[stream];\r\nif (pstr->substream_count == 0)\r\ncontinue;\r\nif ((entry = snd_info_create_card_entry(pcm->card, "oss", pstr->proc_root)) != NULL) {\r\nentry->content = SNDRV_INFO_CONTENT_TEXT;\r\nentry->mode = S_IFREG | S_IRUGO | S_IWUSR;\r\nentry->c.text.read = snd_pcm_oss_proc_read;\r\nentry->c.text.write = snd_pcm_oss_proc_write;\r\nentry->private_data = pstr;\r\nif (snd_info_register(entry) < 0) {\r\nsnd_info_free_entry(entry);\r\nentry = NULL;\r\n}\r\n}\r\npstr->oss.proc_entry = entry;\r\n}\r\n}\r\nstatic void snd_pcm_oss_proc_done(struct snd_pcm *pcm)\r\n{\r\nint stream;\r\nfor (stream = 0; stream < 2; ++stream) {\r\nstruct snd_pcm_str *pstr = &pcm->streams[stream];\r\nsnd_info_free_entry(pstr->oss.proc_entry);\r\npstr->oss.proc_entry = NULL;\r\nsnd_pcm_oss_proc_free_setup_list(pstr);\r\n}\r\n}\r\nstatic void register_oss_dsp(struct snd_pcm *pcm, int index)\r\n{\r\nif (snd_register_oss_device(SNDRV_OSS_DEVICE_TYPE_PCM,\r\npcm->card, index, &snd_pcm_oss_f_reg,\r\npcm) < 0) {\r\npcm_err(pcm, "unable to register OSS PCM device %i:%i\n",\r\npcm->card->number, pcm->device);\r\n}\r\n}\r\nstatic int snd_pcm_oss_register_minor(struct snd_pcm *pcm)\r\n{\r\npcm->oss.reg = 0;\r\nif (dsp_map[pcm->card->number] == (int)pcm->device) {\r\nchar name[128];\r\nint duplex;\r\nregister_oss_dsp(pcm, 0);\r\nduplex = (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream_count > 0 &&\r\npcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream_count &&\r\n!(pcm->info_flags & SNDRV_PCM_INFO_HALF_DUPLEX));\r\nsprintf(name, "%s%s", pcm->name, duplex ? " (DUPLEX)" : "");\r\n#ifdef SNDRV_OSS_INFO_DEV_AUDIO\r\nsnd_oss_info_register(SNDRV_OSS_INFO_DEV_AUDIO,\r\npcm->card->number,\r\nname);\r\n#endif\r\npcm->oss.reg++;\r\npcm->oss.reg_mask |= 1;\r\n}\r\nif (adsp_map[pcm->card->number] == (int)pcm->device) {\r\nregister_oss_dsp(pcm, 1);\r\npcm->oss.reg++;\r\npcm->oss.reg_mask |= 2;\r\n}\r\nif (pcm->oss.reg)\r\nsnd_pcm_oss_proc_init(pcm);\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_oss_disconnect_minor(struct snd_pcm *pcm)\r\n{\r\nif (pcm->oss.reg) {\r\nif (pcm->oss.reg_mask & 1) {\r\npcm->oss.reg_mask &= ~1;\r\nsnd_unregister_oss_device(SNDRV_OSS_DEVICE_TYPE_PCM,\r\npcm->card, 0);\r\n}\r\nif (pcm->oss.reg_mask & 2) {\r\npcm->oss.reg_mask &= ~2;\r\nsnd_unregister_oss_device(SNDRV_OSS_DEVICE_TYPE_PCM,\r\npcm->card, 1);\r\n}\r\nif (dsp_map[pcm->card->number] == (int)pcm->device) {\r\n#ifdef SNDRV_OSS_INFO_DEV_AUDIO\r\nsnd_oss_info_unregister(SNDRV_OSS_INFO_DEV_AUDIO, pcm->card->number);\r\n#endif\r\n}\r\npcm->oss.reg = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_oss_unregister_minor(struct snd_pcm *pcm)\r\n{\r\nsnd_pcm_oss_disconnect_minor(pcm);\r\nsnd_pcm_oss_proc_done(pcm);\r\nreturn 0;\r\n}\r\nstatic int __init alsa_pcm_oss_init(void)\r\n{\r\nint i;\r\nint err;\r\nfor (i = 0; i < SNDRV_CARDS; i++) {\r\nif (dsp_map[i] < 0 || dsp_map[i] >= SNDRV_PCM_DEVICES) {\r\npr_err("ALSA: pcm_oss: invalid dsp_map[%d] = %d\n",\r\ni, dsp_map[i]);\r\ndsp_map[i] = 0;\r\n}\r\nif (adsp_map[i] < 0 || adsp_map[i] >= SNDRV_PCM_DEVICES) {\r\npr_err("ALSA: pcm_oss: invalid adsp_map[%d] = %d\n",\r\ni, adsp_map[i]);\r\nadsp_map[i] = 1;\r\n}\r\n}\r\nif ((err = snd_pcm_notify(&snd_pcm_oss_notify, 0)) < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_pcm_oss_exit(void)\r\n{\r\nsnd_pcm_notify(&snd_pcm_oss_notify, 1);\r\n}
