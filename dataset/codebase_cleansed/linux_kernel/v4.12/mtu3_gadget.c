void mtu3_req_complete(struct mtu3_ep *mep,\r\nstruct usb_request *req, int status)\r\n__releases(mep->mtu->lock)\r\n__acquires(mep->mtu->lock)\r\n{\r\nstruct mtu3_request *mreq;\r\nstruct mtu3 *mtu;\r\nint busy = mep->busy;\r\nmreq = to_mtu3_request(req);\r\nlist_del(&mreq->list);\r\nif (mreq->request.status == -EINPROGRESS)\r\nmreq->request.status = status;\r\nmtu = mreq->mtu;\r\nmep->busy = 1;\r\nspin_unlock(&mtu->lock);\r\nif (mep->epnum)\r\nusb_gadget_unmap_request(&mtu->g, req, mep->is_in);\r\ndev_dbg(mtu->dev, "%s complete req: %p, sts %d, %d/%d\n", mep->name,\r\nreq, req->status, mreq->request.actual, mreq->request.length);\r\nusb_gadget_giveback_request(&mep->ep, &mreq->request);\r\nspin_lock(&mtu->lock);\r\nmep->busy = busy;\r\n}\r\nstatic void nuke(struct mtu3_ep *mep, const int status)\r\n{\r\nstruct mtu3_request *mreq = NULL;\r\nmep->busy = 1;\r\nif (list_empty(&mep->req_list))\r\nreturn;\r\ndev_dbg(mep->mtu->dev, "abort %s's req: sts %d\n", mep->name, status);\r\nif (mep->epnum)\r\nmtu3_qmu_flush(mep);\r\nwhile (!list_empty(&mep->req_list)) {\r\nmreq = list_first_entry(&mep->req_list,\r\nstruct mtu3_request, list);\r\nmtu3_req_complete(mep, &mreq->request, status);\r\n}\r\n}\r\nstatic int mtu3_ep_enable(struct mtu3_ep *mep)\r\n{\r\nconst struct usb_endpoint_descriptor *desc;\r\nconst struct usb_ss_ep_comp_descriptor *comp_desc;\r\nstruct mtu3 *mtu = mep->mtu;\r\nu32 interval = 0;\r\nu32 mult = 0;\r\nu32 burst = 0;\r\nint max_packet;\r\nint ret;\r\ndesc = mep->desc;\r\ncomp_desc = mep->comp_desc;\r\nmep->type = usb_endpoint_type(desc);\r\nmax_packet = usb_endpoint_maxp(desc);\r\nmep->maxp = max_packet & GENMASK(10, 0);\r\nswitch (mtu->g.speed) {\r\ncase USB_SPEED_SUPER:\r\nif (usb_endpoint_xfer_int(desc) ||\r\nusb_endpoint_xfer_isoc(desc)) {\r\ninterval = desc->bInterval;\r\ninterval = clamp_val(interval, 1, 16) - 1;\r\nif (usb_endpoint_xfer_isoc(desc) && comp_desc)\r\nmult = comp_desc->bmAttributes;\r\n}\r\nif (comp_desc)\r\nburst = comp_desc->bMaxBurst;\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\nif (usb_endpoint_xfer_isoc(desc) ||\r\nusb_endpoint_xfer_int(desc)) {\r\ninterval = desc->bInterval;\r\ninterval = clamp_val(interval, 1, 16) - 1;\r\nburst = (max_packet & GENMASK(12, 11)) >> 11;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndev_dbg(mtu->dev, "%s maxp:%d, interval:%d, burst:%d, mult:%d\n",\r\n__func__, mep->maxp, interval, burst, mult);\r\nmep->ep.maxpacket = mep->maxp;\r\nmep->ep.desc = desc;\r\nmep->ep.comp_desc = comp_desc;\r\nmep->slot = usb_endpoint_xfer_int(desc) ? 0 : mtu->slot;\r\nret = mtu3_config_ep(mtu, mep, interval, burst, mult);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mtu3_gpd_ring_alloc(mep);\r\nif (ret < 0) {\r\nmtu3_deconfig_ep(mtu, mep);\r\nreturn ret;\r\n}\r\nmtu3_qmu_start(mep);\r\nreturn 0;\r\n}\r\nstatic int mtu3_ep_disable(struct mtu3_ep *mep)\r\n{\r\nstruct mtu3 *mtu = mep->mtu;\r\nmtu3_qmu_stop(mep);\r\nnuke(mep, -ESHUTDOWN);\r\nmtu3_deconfig_ep(mtu, mep);\r\nmtu3_gpd_ring_free(mep);\r\nmep->desc = NULL;\r\nmep->ep.desc = NULL;\r\nmep->comp_desc = NULL;\r\nmep->type = 0;\r\nmep->flags = 0;\r\nreturn 0;\r\n}\r\nstatic int mtu3_gadget_ep_enable(struct usb_ep *ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct mtu3_ep *mep;\r\nstruct mtu3 *mtu;\r\nunsigned long flags;\r\nint ret = -EINVAL;\r\nif (!ep || !desc || desc->bDescriptorType != USB_DT_ENDPOINT) {\r\npr_debug("%s invalid parameters\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (!desc->wMaxPacketSize) {\r\npr_debug("%s missing wMaxPacketSize\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nmep = to_mtu3_ep(ep);\r\nmtu = mep->mtu;\r\nif (usb_endpoint_num(desc) != mep->epnum)\r\nreturn -EINVAL;\r\nif (!!usb_endpoint_dir_in(desc) ^ !!mep->is_in)\r\nreturn -EINVAL;\r\ndev_dbg(mtu->dev, "%s %s\n", __func__, ep->name);\r\nif (mep->flags & MTU3_EP_ENABLED) {\r\ndev_WARN_ONCE(mtu->dev, true, "%s is already enabled\n",\r\nmep->name);\r\nreturn 0;\r\n}\r\nspin_lock_irqsave(&mtu->lock, flags);\r\nmep->desc = desc;\r\nmep->comp_desc = ep->comp_desc;\r\nret = mtu3_ep_enable(mep);\r\nif (ret)\r\ngoto error;\r\nmep->busy = 0;\r\nmep->wedged = 0;\r\nmep->flags |= MTU3_EP_ENABLED;\r\nmtu->active_ep++;\r\nerror:\r\nspin_unlock_irqrestore(&mtu->lock, flags);\r\ndev_dbg(mtu->dev, "%s active_ep=%d\n", __func__, mtu->active_ep);\r\nreturn ret;\r\n}\r\nstatic int mtu3_gadget_ep_disable(struct usb_ep *ep)\r\n{\r\nstruct mtu3_ep *mep = to_mtu3_ep(ep);\r\nstruct mtu3 *mtu = mep->mtu;\r\nunsigned long flags;\r\ndev_dbg(mtu->dev, "%s %s\n", __func__, mep->name);\r\nif (!(mep->flags & MTU3_EP_ENABLED)) {\r\ndev_warn(mtu->dev, "%s is already disabled\n", mep->name);\r\nreturn 0;\r\n}\r\nspin_lock_irqsave(&mtu->lock, flags);\r\nmtu3_ep_disable(mep);\r\nmep->flags &= ~MTU3_EP_ENABLED;\r\nmtu->active_ep--;\r\nspin_unlock_irqrestore(&(mtu->lock), flags);\r\ndev_dbg(mtu->dev, "%s active_ep=%d, mtu3 is_active=%d\n",\r\n__func__, mtu->active_ep, mtu->is_active);\r\nreturn 0;\r\n}\r\nstruct usb_request *mtu3_alloc_request(struct usb_ep *ep, gfp_t gfp_flags)\r\n{\r\nstruct mtu3_ep *mep = to_mtu3_ep(ep);\r\nstruct mtu3_request *mreq;\r\nmreq = kzalloc(sizeof(*mreq), gfp_flags);\r\nif (!mreq)\r\nreturn NULL;\r\nmreq->request.dma = DMA_ADDR_INVALID;\r\nmreq->epnum = mep->epnum;\r\nmreq->mep = mep;\r\nreturn &mreq->request;\r\n}\r\nvoid mtu3_free_request(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nkfree(to_mtu3_request(req));\r\n}\r\nstatic int mtu3_gadget_queue(struct usb_ep *ep,\r\nstruct usb_request *req, gfp_t gfp_flags)\r\n{\r\nstruct mtu3_ep *mep;\r\nstruct mtu3_request *mreq;\r\nstruct mtu3 *mtu;\r\nunsigned long flags;\r\nint ret = 0;\r\nif (!ep || !req)\r\nreturn -EINVAL;\r\nif (!req->buf)\r\nreturn -ENODATA;\r\nmep = to_mtu3_ep(ep);\r\nmtu = mep->mtu;\r\nmreq = to_mtu3_request(req);\r\nmreq->mtu = mtu;\r\nif (mreq->mep != mep)\r\nreturn -EINVAL;\r\ndev_dbg(mtu->dev, "%s %s EP%d(%s), req=%p, maxp=%d, len#%d\n",\r\n__func__, mep->is_in ? "TX" : "RX", mreq->epnum, ep->name,\r\nmreq, ep->maxpacket, mreq->request.length);\r\nif (req->length > GPD_BUF_SIZE) {\r\ndev_warn(mtu->dev,\r\n"req length > supported MAX:%d requested:%d\n",\r\nGPD_BUF_SIZE, req->length);\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (!mep->desc) {\r\ndev_dbg(mtu->dev, "req=%p queued to %s while it's disabled\n",\r\nreq, ep->name);\r\nreturn -ESHUTDOWN;\r\n}\r\nmreq->request.actual = 0;\r\nmreq->request.status = -EINPROGRESS;\r\nret = usb_gadget_map_request(&mtu->g, req, mep->is_in);\r\nif (ret) {\r\ndev_err(mtu->dev, "dma mapping failed\n");\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&mtu->lock, flags);\r\nif (mtu3_prepare_transfer(mep)) {\r\nret = -EAGAIN;\r\ngoto error;\r\n}\r\nlist_add_tail(&mreq->list, &mep->req_list);\r\nmtu3_insert_gpd(mep, mreq);\r\nmtu3_qmu_resume(mep);\r\nerror:\r\nspin_unlock_irqrestore(&mtu->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int mtu3_gadget_dequeue(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct mtu3_ep *mep = to_mtu3_ep(ep);\r\nstruct mtu3_request *mreq = to_mtu3_request(req);\r\nstruct mtu3_request *r;\r\nunsigned long flags;\r\nint ret = 0;\r\nstruct mtu3 *mtu = mep->mtu;\r\nif (!ep || !req || mreq->mep != mep)\r\nreturn -EINVAL;\r\ndev_dbg(mtu->dev, "%s : req=%p\n", __func__, req);\r\nspin_lock_irqsave(&mtu->lock, flags);\r\nlist_for_each_entry(r, &mep->req_list, list) {\r\nif (r == mreq)\r\nbreak;\r\n}\r\nif (r != mreq) {\r\ndev_dbg(mtu->dev, "req=%p not queued to %s\n", req, ep->name);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nmtu3_qmu_flush(mep);\r\nmtu3_req_complete(mep, req, -ECONNRESET);\r\nmtu3_qmu_start(mep);\r\ndone:\r\nspin_unlock_irqrestore(&mtu->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int mtu3_gadget_ep_set_halt(struct usb_ep *ep, int value)\r\n{\r\nstruct mtu3_ep *mep = to_mtu3_ep(ep);\r\nstruct mtu3 *mtu = mep->mtu;\r\nstruct mtu3_request *mreq;\r\nunsigned long flags;\r\nint ret = 0;\r\nif (!ep)\r\nreturn -EINVAL;\r\ndev_dbg(mtu->dev, "%s : %s...", __func__, ep->name);\r\nspin_lock_irqsave(&mtu->lock, flags);\r\nif (mep->type == USB_ENDPOINT_XFER_ISOC) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nmreq = next_request(mep);\r\nif (value) {\r\nif (mreq) {\r\ndev_dbg(mtu->dev, "req in progress, cannot halt %s\n",\r\nep->name);\r\nret = -EAGAIN;\r\ngoto done;\r\n}\r\n} else {\r\nmep->wedged = 0;\r\n}\r\ndev_dbg(mtu->dev, "%s %s stall\n", ep->name, value ? "set" : "clear");\r\nmtu3_ep_stall_set(mep, value);\r\ndone:\r\nspin_unlock_irqrestore(&mtu->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int mtu3_gadget_ep_set_wedge(struct usb_ep *ep)\r\n{\r\nstruct mtu3_ep *mep = to_mtu3_ep(ep);\r\nif (!ep)\r\nreturn -EINVAL;\r\nmep->wedged = 1;\r\nreturn usb_ep_set_halt(ep);\r\n}\r\nstatic int mtu3_gadget_get_frame(struct usb_gadget *gadget)\r\n{\r\nstruct mtu3 *mtu = gadget_to_mtu3(gadget);\r\nreturn (int)mtu3_readl(mtu->mac_base, U3D_USB20_FRAME_NUM);\r\n}\r\nstatic int mtu3_gadget_wakeup(struct usb_gadget *gadget)\r\n{\r\nstruct mtu3 *mtu = gadget_to_mtu3(gadget);\r\nunsigned long flags;\r\ndev_dbg(mtu->dev, "%s\n", __func__);\r\nif (!mtu->may_wakeup)\r\nreturn -EOPNOTSUPP;\r\nspin_lock_irqsave(&mtu->lock, flags);\r\nif (mtu->g.speed == USB_SPEED_SUPER) {\r\nmtu3_setbits(mtu->mac_base, U3D_LINK_POWER_CONTROL, UX_EXIT);\r\n} else {\r\nmtu3_setbits(mtu->mac_base, U3D_POWER_MANAGEMENT, RESUME);\r\nspin_unlock_irqrestore(&mtu->lock, flags);\r\nusleep_range(10000, 11000);\r\nspin_lock_irqsave(&mtu->lock, flags);\r\nmtu3_clrbits(mtu->mac_base, U3D_POWER_MANAGEMENT, RESUME);\r\n}\r\nspin_unlock_irqrestore(&mtu->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mtu3_gadget_set_self_powered(struct usb_gadget *gadget,\r\nint is_selfpowered)\r\n{\r\nstruct mtu3 *mtu = gadget_to_mtu3(gadget);\r\nmtu->is_self_powered = !!is_selfpowered;\r\nreturn 0;\r\n}\r\nstatic int mtu3_gadget_pullup(struct usb_gadget *gadget, int is_on)\r\n{\r\nstruct mtu3 *mtu = gadget_to_mtu3(gadget);\r\nunsigned long flags;\r\ndev_dbg(mtu->dev, "%s (%s) for %sactive device\n", __func__,\r\nis_on ? "on" : "off", mtu->is_active ? "" : "in");\r\nspin_lock_irqsave(&mtu->lock, flags);\r\nis_on = !!is_on;\r\nif (!mtu->is_active) {\r\nmtu->softconnect = is_on;\r\n} else if (is_on != mtu->softconnect) {\r\nmtu->softconnect = is_on;\r\nmtu3_dev_on_off(mtu, is_on);\r\n}\r\nspin_unlock_irqrestore(&mtu->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mtu3_gadget_start(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct mtu3 *mtu = gadget_to_mtu3(gadget);\r\nunsigned long flags;\r\nif (mtu->gadget_driver) {\r\ndev_err(mtu->dev, "%s is already bound to %s\n",\r\nmtu->g.name, mtu->gadget_driver->driver.name);\r\nreturn -EBUSY;\r\n}\r\ndev_dbg(mtu->dev, "bind driver %s\n", driver->function);\r\nspin_lock_irqsave(&mtu->lock, flags);\r\nmtu->softconnect = 0;\r\nmtu->gadget_driver = driver;\r\nif (mtu->ssusb->dr_mode == USB_DR_MODE_PERIPHERAL)\r\nmtu3_start(mtu);\r\nspin_unlock_irqrestore(&mtu->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void stop_activity(struct mtu3 *mtu)\r\n{\r\nstruct usb_gadget_driver *driver = mtu->gadget_driver;\r\nint i;\r\nif (mtu->g.speed == USB_SPEED_UNKNOWN)\r\ndriver = NULL;\r\nelse\r\nmtu->g.speed = USB_SPEED_UNKNOWN;\r\nif (mtu->softconnect) {\r\nmtu->softconnect = 0;\r\nmtu3_dev_on_off(mtu, 0);\r\n}\r\nnuke(mtu->ep0, -ESHUTDOWN);\r\nfor (i = 1; i < mtu->num_eps; i++) {\r\nnuke(mtu->in_eps + i, -ESHUTDOWN);\r\nnuke(mtu->out_eps + i, -ESHUTDOWN);\r\n}\r\nif (driver) {\r\nspin_unlock(&mtu->lock);\r\ndriver->disconnect(&mtu->g);\r\nspin_lock(&mtu->lock);\r\n}\r\n}\r\nstatic int mtu3_gadget_stop(struct usb_gadget *g)\r\n{\r\nstruct mtu3 *mtu = gadget_to_mtu3(g);\r\nunsigned long flags;\r\ndev_dbg(mtu->dev, "%s\n", __func__);\r\nspin_lock_irqsave(&mtu->lock, flags);\r\nstop_activity(mtu);\r\nmtu->gadget_driver = NULL;\r\nif (mtu->ssusb->dr_mode == USB_DR_MODE_PERIPHERAL)\r\nmtu3_stop(mtu);\r\nspin_unlock_irqrestore(&mtu->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void init_hw_ep(struct mtu3 *mtu, struct mtu3_ep *mep,\r\nu32 epnum, u32 is_in)\r\n{\r\nmep->epnum = epnum;\r\nmep->mtu = mtu;\r\nmep->is_in = is_in;\r\nINIT_LIST_HEAD(&mep->req_list);\r\nsprintf(mep->name, "ep%d%s", epnum,\r\n!epnum ? "" : (is_in ? "in" : "out"));\r\nmep->ep.name = mep->name;\r\nINIT_LIST_HEAD(&mep->ep.ep_list);\r\nif (!epnum) {\r\nusb_ep_set_maxpacket_limit(&mep->ep, 512);\r\nmep->ep.caps.type_control = true;\r\nmep->ep.ops = &mtu3_ep0_ops;\r\nmtu->g.ep0 = &mep->ep;\r\n} else {\r\nusb_ep_set_maxpacket_limit(&mep->ep, 1024);\r\nmep->ep.caps.type_iso = true;\r\nmep->ep.caps.type_bulk = true;\r\nmep->ep.caps.type_int = true;\r\nmep->ep.ops = &mtu3_ep_ops;\r\nlist_add_tail(&mep->ep.ep_list, &mtu->g.ep_list);\r\n}\r\ndev_dbg(mtu->dev, "%s, name=%s, maxp=%d\n", __func__, mep->ep.name,\r\nmep->ep.maxpacket);\r\nif (!epnum) {\r\nmep->ep.caps.dir_in = true;\r\nmep->ep.caps.dir_out = true;\r\n} else if (is_in) {\r\nmep->ep.caps.dir_in = true;\r\n} else {\r\nmep->ep.caps.dir_out = true;\r\n}\r\n}\r\nstatic void mtu3_gadget_init_eps(struct mtu3 *mtu)\r\n{\r\nu8 epnum;\r\nINIT_LIST_HEAD(&(mtu->g.ep_list));\r\ndev_dbg(mtu->dev, "%s num_eps(1 for a pair of tx&rx ep)=%d\n",\r\n__func__, mtu->num_eps);\r\ninit_hw_ep(mtu, mtu->ep0, 0, 0);\r\nfor (epnum = 1; epnum < mtu->num_eps; epnum++) {\r\ninit_hw_ep(mtu, mtu->in_eps + epnum, epnum, 1);\r\ninit_hw_ep(mtu, mtu->out_eps + epnum, epnum, 0);\r\n}\r\n}\r\nint mtu3_gadget_setup(struct mtu3 *mtu)\r\n{\r\nint ret;\r\nmtu->g.ops = &mtu3_gadget_ops;\r\nmtu->g.max_speed = mtu->max_speed;\r\nmtu->g.speed = USB_SPEED_UNKNOWN;\r\nmtu->g.sg_supported = 0;\r\nmtu->g.name = MTU3_DRIVER_NAME;\r\nmtu->is_active = 0;\r\nmtu3_gadget_init_eps(mtu);\r\nret = usb_add_gadget_udc(mtu->dev, &mtu->g);\r\nif (ret) {\r\ndev_err(mtu->dev, "failed to register udc\n");\r\nreturn ret;\r\n}\r\nusb_gadget_set_state(&mtu->g, USB_STATE_NOTATTACHED);\r\nreturn 0;\r\n}\r\nvoid mtu3_gadget_cleanup(struct mtu3 *mtu)\r\n{\r\nusb_del_gadget_udc(&mtu->g);\r\n}\r\nvoid mtu3_gadget_resume(struct mtu3 *mtu)\r\n{\r\ndev_dbg(mtu->dev, "gadget RESUME\n");\r\nif (mtu->gadget_driver && mtu->gadget_driver->resume) {\r\nspin_unlock(&mtu->lock);\r\nmtu->gadget_driver->resume(&mtu->g);\r\nspin_lock(&mtu->lock);\r\n}\r\n}\r\nvoid mtu3_gadget_suspend(struct mtu3 *mtu)\r\n{\r\ndev_dbg(mtu->dev, "gadget SUSPEND\n");\r\nif (mtu->gadget_driver && mtu->gadget_driver->suspend) {\r\nspin_unlock(&mtu->lock);\r\nmtu->gadget_driver->suspend(&mtu->g);\r\nspin_lock(&mtu->lock);\r\n}\r\n}\r\nvoid mtu3_gadget_disconnect(struct mtu3 *mtu)\r\n{\r\ndev_dbg(mtu->dev, "gadget DISCONNECT\n");\r\nif (mtu->gadget_driver && mtu->gadget_driver->disconnect) {\r\nspin_unlock(&mtu->lock);\r\nmtu->gadget_driver->disconnect(&mtu->g);\r\nspin_lock(&mtu->lock);\r\n}\r\nusb_gadget_set_state(&mtu->g, USB_STATE_NOTATTACHED);\r\n}\r\nvoid mtu3_gadget_reset(struct mtu3 *mtu)\r\n{\r\ndev_dbg(mtu->dev, "gadget RESET\n");\r\nif (mtu->g.speed != USB_SPEED_UNKNOWN)\r\nmtu3_gadget_disconnect(mtu);\r\nmtu->address = 0;\r\nmtu->ep0_state = MU3D_EP0_STATE_SETUP;\r\nmtu->may_wakeup = 0;\r\n}
