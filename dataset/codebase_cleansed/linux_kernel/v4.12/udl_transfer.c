static inline u16 pixel32_to_be16(const uint32_t pixel)\r\n{\r\nreturn (((pixel >> 3) & 0x001f) |\r\n((pixel >> 5) & 0x07e0) |\r\n((pixel >> 8) & 0xf800));\r\n}\r\nstatic inline u16 get_pixel_val16(const uint8_t *pixel, int bpp)\r\n{\r\nu16 pixel_val16 = 0;\r\nif (bpp == 2)\r\npixel_val16 = *(const uint16_t *)pixel;\r\nelse if (bpp == 4)\r\npixel_val16 = pixel32_to_be16(*(const uint32_t *)pixel);\r\nreturn pixel_val16;\r\n}\r\nstatic void udl_compress_hline16(\r\nconst u8 **pixel_start_ptr,\r\nconst u8 *const pixel_end,\r\nuint32_t *device_address_ptr,\r\nuint8_t **command_buffer_ptr,\r\nconst uint8_t *const cmd_buffer_end, int bpp)\r\n{\r\nconst u8 *pixel = *pixel_start_ptr;\r\nuint32_t dev_addr = *device_address_ptr;\r\nuint8_t *cmd = *command_buffer_ptr;\r\nwhile ((pixel_end > pixel) &&\r\n(cmd_buffer_end - MIN_RLX_CMD_BYTES > cmd)) {\r\nuint8_t *raw_pixels_count_byte = NULL;\r\nuint8_t *cmd_pixels_count_byte = NULL;\r\nconst u8 *raw_pixel_start = NULL;\r\nconst u8 *cmd_pixel_start, *cmd_pixel_end = NULL;\r\nuint16_t pixel_val16;\r\nprefetchw((void *) cmd);\r\n*cmd++ = 0xaf;\r\n*cmd++ = 0x6b;\r\n*cmd++ = (uint8_t) ((dev_addr >> 16) & 0xFF);\r\n*cmd++ = (uint8_t) ((dev_addr >> 8) & 0xFF);\r\n*cmd++ = (uint8_t) ((dev_addr) & 0xFF);\r\ncmd_pixels_count_byte = cmd++;\r\ncmd_pixel_start = pixel;\r\nraw_pixels_count_byte = cmd++;\r\nraw_pixel_start = pixel;\r\ncmd_pixel_end = pixel + (min(MAX_CMD_PIXELS + 1,\r\nmin((int)(pixel_end - pixel) / bpp,\r\n(int)(cmd_buffer_end - cmd) / 2))) * bpp;\r\nprefetch_range((void *) pixel, (cmd_pixel_end - pixel) * bpp);\r\npixel_val16 = get_pixel_val16(pixel, bpp);\r\nwhile (pixel < cmd_pixel_end) {\r\nconst u8 *const start = pixel;\r\nconst uint16_t repeating_pixel_val16 = pixel_val16;\r\nput_unaligned_be16(pixel_val16, cmd);\r\ncmd += 2;\r\npixel += bpp;\r\nwhile (pixel < cmd_pixel_end) {\r\npixel_val16 = get_pixel_val16(pixel, bpp);\r\nif (pixel_val16 != repeating_pixel_val16)\r\nbreak;\r\npixel += bpp;\r\n}\r\nif (unlikely(pixel > start + bpp)) {\r\n*raw_pixels_count_byte = (((start -\r\nraw_pixel_start) / bpp) + 1) & 0xFF;\r\n*cmd++ = (((pixel - start) / bpp) - 1) & 0xFF;\r\nraw_pixel_start = pixel;\r\nraw_pixels_count_byte = cmd++;\r\n}\r\n}\r\nif (pixel > raw_pixel_start) {\r\n*raw_pixels_count_byte = ((pixel-raw_pixel_start) / bpp) & 0xFF;\r\n}\r\n*cmd_pixels_count_byte = ((pixel - cmd_pixel_start) / bpp) & 0xFF;\r\ndev_addr += ((pixel - cmd_pixel_start) / bpp) * 2;\r\n}\r\nif (cmd_buffer_end <= MIN_RLX_CMD_BYTES + cmd) {\r\nif (cmd_buffer_end > cmd)\r\nmemset(cmd, 0xAF, cmd_buffer_end - cmd);\r\ncmd = (uint8_t *) cmd_buffer_end;\r\n}\r\n*command_buffer_ptr = cmd;\r\n*pixel_start_ptr = pixel;\r\n*device_address_ptr = dev_addr;\r\nreturn;\r\n}\r\nint udl_render_hline(struct drm_device *dev, int bpp, struct urb **urb_ptr,\r\nconst char *front, char **urb_buf_ptr,\r\nu32 byte_offset, u32 device_byte_offset,\r\nu32 byte_width,\r\nint *ident_ptr, int *sent_ptr)\r\n{\r\nconst u8 *line_start, *line_end, *next_pixel;\r\nu32 base16 = 0 + (device_byte_offset / bpp) * 2;\r\nstruct urb *urb = *urb_ptr;\r\nu8 *cmd = *urb_buf_ptr;\r\nu8 *cmd_end = (u8 *) urb->transfer_buffer + urb->transfer_buffer_length;\r\nBUG_ON(!(bpp == 2 || bpp == 4));\r\nline_start = (u8 *) (front + byte_offset);\r\nnext_pixel = line_start;\r\nline_end = next_pixel + byte_width;\r\nwhile (next_pixel < line_end) {\r\nudl_compress_hline16(&next_pixel,\r\nline_end, &base16,\r\n(u8 **) &cmd, (u8 *) cmd_end, bpp);\r\nif (cmd >= cmd_end) {\r\nint len = cmd - (u8 *) urb->transfer_buffer;\r\nif (udl_submit_urb(dev, urb, len))\r\nreturn 1;\r\n*sent_ptr += len;\r\nurb = udl_get_urb(dev);\r\nif (!urb)\r\nreturn 1;\r\n*urb_ptr = urb;\r\ncmd = urb->transfer_buffer;\r\ncmd_end = &cmd[urb->transfer_buffer_length];\r\n}\r\n}\r\n*urb_buf_ptr = cmd;\r\nreturn 0;\r\n}
