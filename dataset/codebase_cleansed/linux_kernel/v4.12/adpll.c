static const char *ti_adpll_clk_get_name(struct ti_adpll_data *d,\r\nint output_index,\r\nconst char *postfix)\r\n{\r\nconst char *name;\r\nint err;\r\nif (output_index >= 0) {\r\nerr = of_property_read_string_index(d->np,\r\n"clock-output-names",\r\noutput_index,\r\n&name);\r\nif (err)\r\nreturn NULL;\r\n} else {\r\nconst char *base_name = "adpll";\r\nchar *buf;\r\nbuf = devm_kzalloc(d->dev, 8 + 1 + strlen(base_name) + 1 +\r\nstrlen(postfix), GFP_KERNEL);\r\nif (!buf)\r\nreturn NULL;\r\nsprintf(buf, "%08lx.%s.%s", d->pa, base_name, postfix);\r\nname = buf;\r\n}\r\nreturn name;\r\n}\r\nstatic int ti_adpll_setup_clock(struct ti_adpll_data *d, struct clk *clock,\r\nint index, int output_index, const char *name,\r\nvoid (*unregister)(struct clk *clk))\r\n{\r\nstruct clk_lookup *cl;\r\nconst char *postfix = NULL;\r\nchar con_id[ADPLL_MAX_CON_ID];\r\nd->clocks[index].clk = clock;\r\nd->clocks[index].unregister = unregister;\r\npostfix = strrchr(name, '.');\r\nif (strlen(postfix) > 1) {\r\nif (strlen(postfix) > ADPLL_MAX_CON_ID)\r\ndev_warn(d->dev, "clock %s con_id lookup may fail\n",\r\nname);\r\nsnprintf(con_id, 16, "pll%03lx%s", d->pa & 0xfff, postfix + 1);\r\ncl = clkdev_create(clock, con_id, NULL);\r\nif (!cl)\r\nreturn -ENOMEM;\r\nd->clocks[index].cl = cl;\r\n} else {\r\ndev_warn(d->dev, "no con_id for clock %s\n", name);\r\n}\r\nif (output_index < 0)\r\nreturn 0;\r\nd->outputs.clks[output_index] = clock;\r\nd->outputs.clk_num++;\r\nreturn 0;\r\n}\r\nstatic int ti_adpll_init_divider(struct ti_adpll_data *d,\r\nenum ti_adpll_clocks index,\r\nint output_index, char *name,\r\nstruct clk *parent_clock,\r\nvoid __iomem *reg,\r\nu8 shift, u8 width,\r\nu8 clk_divider_flags)\r\n{\r\nconst char *child_name;\r\nconst char *parent_name;\r\nstruct clk *clock;\r\nchild_name = ti_adpll_clk_get_name(d, output_index, name);\r\nif (!child_name)\r\nreturn -EINVAL;\r\nparent_name = __clk_get_name(parent_clock);\r\nclock = clk_register_divider(d->dev, child_name, parent_name, 0,\r\nreg, shift, width, clk_divider_flags,\r\n&d->lock);\r\nif (IS_ERR(clock)) {\r\ndev_err(d->dev, "failed to register divider %s: %li\n",\r\nname, PTR_ERR(clock));\r\nreturn PTR_ERR(clock);\r\n}\r\nreturn ti_adpll_setup_clock(d, clock, index, output_index, child_name,\r\nclk_unregister_divider);\r\n}\r\nstatic int ti_adpll_init_mux(struct ti_adpll_data *d,\r\nenum ti_adpll_clocks index,\r\nchar *name, struct clk *clk0,\r\nstruct clk *clk1,\r\nvoid __iomem *reg,\r\nu8 shift)\r\n{\r\nconst char *child_name;\r\nconst char *parents[2];\r\nstruct clk *clock;\r\nchild_name = ti_adpll_clk_get_name(d, -ENODEV, name);\r\nif (!child_name)\r\nreturn -ENOMEM;\r\nparents[0] = __clk_get_name(clk0);\r\nparents[1] = __clk_get_name(clk1);\r\nclock = clk_register_mux(d->dev, child_name, parents, 2, 0,\r\nreg, shift, 1, 0, &d->lock);\r\nif (IS_ERR(clock)) {\r\ndev_err(d->dev, "failed to register mux %s: %li\n",\r\nname, PTR_ERR(clock));\r\nreturn PTR_ERR(clock);\r\n}\r\nreturn ti_adpll_setup_clock(d, clock, index, -ENODEV, child_name,\r\nclk_unregister_mux);\r\n}\r\nstatic int ti_adpll_init_gate(struct ti_adpll_data *d,\r\nenum ti_adpll_clocks index,\r\nint output_index, char *name,\r\nstruct clk *parent_clock,\r\nvoid __iomem *reg,\r\nu8 bit_idx,\r\nu8 clk_gate_flags)\r\n{\r\nconst char *child_name;\r\nconst char *parent_name;\r\nstruct clk *clock;\r\nchild_name = ti_adpll_clk_get_name(d, output_index, name);\r\nif (!child_name)\r\nreturn -EINVAL;\r\nparent_name = __clk_get_name(parent_clock);\r\nclock = clk_register_gate(d->dev, child_name, parent_name, 0,\r\nreg, bit_idx, clk_gate_flags,\r\n&d->lock);\r\nif (IS_ERR(clock)) {\r\ndev_err(d->dev, "failed to register gate %s: %li\n",\r\nname, PTR_ERR(clock));\r\nreturn PTR_ERR(clock);\r\n}\r\nreturn ti_adpll_setup_clock(d, clock, index, output_index, child_name,\r\nclk_unregister_gate);\r\n}\r\nstatic int ti_adpll_init_fixed_factor(struct ti_adpll_data *d,\r\nenum ti_adpll_clocks index,\r\nchar *name,\r\nstruct clk *parent_clock,\r\nunsigned int mult,\r\nunsigned int div)\r\n{\r\nconst char *child_name;\r\nconst char *parent_name;\r\nstruct clk *clock;\r\nchild_name = ti_adpll_clk_get_name(d, -ENODEV, name);\r\nif (!child_name)\r\nreturn -ENOMEM;\r\nparent_name = __clk_get_name(parent_clock);\r\nclock = clk_register_fixed_factor(d->dev, child_name, parent_name,\r\n0, mult, div);\r\nif (IS_ERR(clock))\r\nreturn PTR_ERR(clock);\r\nreturn ti_adpll_setup_clock(d, clock, index, -ENODEV, child_name,\r\nclk_unregister);\r\n}\r\nstatic void ti_adpll_set_idle_bypass(struct ti_adpll_data *d)\r\n{\r\nunsigned long flags;\r\nu32 v;\r\nspin_lock_irqsave(&d->lock, flags);\r\nv = readl_relaxed(d->regs + ADPLL_CLKCTRL_OFFSET);\r\nv |= BIT(ADPLL_CLKCTRL_IDLE);\r\nwritel_relaxed(v, d->regs + ADPLL_CLKCTRL_OFFSET);\r\nspin_unlock_irqrestore(&d->lock, flags);\r\n}\r\nstatic void ti_adpll_clear_idle_bypass(struct ti_adpll_data *d)\r\n{\r\nunsigned long flags;\r\nu32 v;\r\nspin_lock_irqsave(&d->lock, flags);\r\nv = readl_relaxed(d->regs + ADPLL_CLKCTRL_OFFSET);\r\nv &= ~BIT(ADPLL_CLKCTRL_IDLE);\r\nwritel_relaxed(v, d->regs + ADPLL_CLKCTRL_OFFSET);\r\nspin_unlock_irqrestore(&d->lock, flags);\r\n}\r\nstatic bool ti_adpll_clock_is_bypass(struct ti_adpll_data *d)\r\n{\r\nu32 v;\r\nv = readl_relaxed(d->regs + ADPLL_STATUS_OFFSET);\r\nreturn v & BIT(ADPLL_STATUS_BYPASS);\r\n}\r\nstatic bool ti_adpll_is_locked(struct ti_adpll_data *d)\r\n{\r\nu32 v = readl_relaxed(d->regs + ADPLL_STATUS_OFFSET);\r\nreturn (v & ADPLL_STATUS_PREPARED_MASK) == ADPLL_STATUS_PREPARED_MASK;\r\n}\r\nstatic int ti_adpll_wait_lock(struct ti_adpll_data *d)\r\n{\r\nint retries = ADPLL_MAX_RETRIES;\r\ndo {\r\nif (ti_adpll_is_locked(d))\r\nreturn 0;\r\nusleep_range(200, 300);\r\n} while (retries--);\r\ndev_err(d->dev, "pll failed to lock\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int ti_adpll_prepare(struct clk_hw *hw)\r\n{\r\nstruct ti_adpll_dco_data *dco = to_dco(hw);\r\nstruct ti_adpll_data *d = to_adpll(dco);\r\nti_adpll_clear_idle_bypass(d);\r\nti_adpll_wait_lock(d);\r\nreturn 0;\r\n}\r\nstatic void ti_adpll_unprepare(struct clk_hw *hw)\r\n{\r\nstruct ti_adpll_dco_data *dco = to_dco(hw);\r\nstruct ti_adpll_data *d = to_adpll(dco);\r\nti_adpll_set_idle_bypass(d);\r\n}\r\nstatic int ti_adpll_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct ti_adpll_dco_data *dco = to_dco(hw);\r\nstruct ti_adpll_data *d = to_adpll(dco);\r\nreturn ti_adpll_is_locked(d);\r\n}\r\nstatic unsigned long ti_adpll_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct ti_adpll_dco_data *dco = to_dco(hw);\r\nstruct ti_adpll_data *d = to_adpll(dco);\r\nu32 frac_m, divider, v;\r\nu64 rate;\r\nunsigned long flags;\r\nif (ti_adpll_clock_is_bypass(d))\r\nreturn 0;\r\nspin_lock_irqsave(&d->lock, flags);\r\nfrac_m = readl_relaxed(d->regs + ADPLL_FRACDIV_OFFSET);\r\nfrac_m &= ADPLL_FRACDIV_FRACTIONALM_MASK;\r\nrate = (u64)readw_relaxed(d->regs + ADPLL_MN2DIV_OFFSET) << 18;\r\nrate += frac_m;\r\nrate *= parent_rate;\r\ndivider = (readw_relaxed(d->regs + ADPLL_M2NDIV_OFFSET) + 1) << 18;\r\nspin_unlock_irqrestore(&d->lock, flags);\r\ndo_div(rate, divider);\r\nif (d->c->is_type_s) {\r\nv = readl_relaxed(d->regs + ADPLL_CLKCTRL_OFFSET);\r\nif (v & BIT(ADPLL_CLKCTRL_REGM4XEN_ADPLL_S))\r\nrate *= 4;\r\nrate *= 2;\r\n}\r\nreturn rate;\r\n}\r\nstatic u8 ti_adpll_get_parent(struct clk_hw *hw)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ti_adpll_init_dco(struct ti_adpll_data *d)\r\n{\r\nstruct clk_init_data init;\r\nstruct clk *clock;\r\nconst char *postfix;\r\nint width, err;\r\nd->outputs.clks = devm_kzalloc(d->dev, sizeof(struct clk *) *\r\nMAX_ADPLL_OUTPUTS,\r\nGFP_KERNEL);\r\nif (!d->outputs.clks)\r\nreturn -ENOMEM;\r\nif (d->c->output_index < 0)\r\npostfix = "dco";\r\nelse\r\npostfix = NULL;\r\ninit.name = ti_adpll_clk_get_name(d, d->c->output_index, postfix);\r\nif (!init.name)\r\nreturn -EINVAL;\r\ninit.parent_names = d->parent_names;\r\ninit.num_parents = d->c->nr_max_inputs;\r\ninit.ops = &ti_adpll_ops;\r\ninit.flags = CLK_GET_RATE_NOCACHE;\r\nd->dco.hw.init = &init;\r\nif (d->c->is_type_s)\r\nwidth = 5;\r\nelse\r\nwidth = 4;\r\nerr = ti_adpll_init_divider(d, TI_ADPLL_N2, -ENODEV, "n2",\r\nd->parent_clocks[TI_ADPLL_CLKINP],\r\nd->regs + ADPLL_MN2DIV_OFFSET,\r\nADPLL_MN2DIV_N2, width, 0);\r\nif (err)\r\nreturn err;\r\nclock = devm_clk_register(d->dev, &d->dco.hw);\r\nif (IS_ERR(clock))\r\nreturn PTR_ERR(clock);\r\nreturn ti_adpll_setup_clock(d, clock, TI_ADPLL_DCO, d->c->output_index,\r\ninit.name, NULL);\r\n}\r\nstatic int ti_adpll_clkout_enable(struct clk_hw *hw)\r\n{\r\nstruct ti_adpll_clkout_data *co = to_clkout(hw);\r\nstruct clk_hw *gate_hw = &co->gate.hw;\r\n__clk_hw_set_clk(gate_hw, hw);\r\nreturn clk_gate_ops.enable(gate_hw);\r\n}\r\nstatic void ti_adpll_clkout_disable(struct clk_hw *hw)\r\n{\r\nstruct ti_adpll_clkout_data *co = to_clkout(hw);\r\nstruct clk_hw *gate_hw = &co->gate.hw;\r\n__clk_hw_set_clk(gate_hw, hw);\r\nclk_gate_ops.disable(gate_hw);\r\n}\r\nstatic int ti_adpll_clkout_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct ti_adpll_clkout_data *co = to_clkout(hw);\r\nstruct clk_hw *gate_hw = &co->gate.hw;\r\n__clk_hw_set_clk(gate_hw, hw);\r\nreturn clk_gate_ops.is_enabled(gate_hw);\r\n}\r\nstatic u8 ti_adpll_clkout_get_parent(struct clk_hw *hw)\r\n{\r\nstruct ti_adpll_clkout_data *co = to_clkout(hw);\r\nstruct ti_adpll_data *d = co->adpll;\r\nreturn ti_adpll_clock_is_bypass(d);\r\n}\r\nstatic int ti_adpll_init_clkout(struct ti_adpll_data *d,\r\nenum ti_adpll_clocks index,\r\nint output_index, int gate_bit,\r\nchar *name, struct clk *clk0,\r\nstruct clk *clk1)\r\n{\r\nstruct ti_adpll_clkout_data *co;\r\nstruct clk_init_data init;\r\nstruct clk_ops *ops;\r\nconst char *parent_names[2];\r\nconst char *child_name;\r\nstruct clk *clock;\r\nint err;\r\nco = devm_kzalloc(d->dev, sizeof(*co), GFP_KERNEL);\r\nif (!co)\r\nreturn -ENOMEM;\r\nco->adpll = d;\r\nerr = of_property_read_string_index(d->np,\r\n"clock-output-names",\r\noutput_index,\r\n&child_name);\r\nif (err)\r\nreturn err;\r\nops = devm_kzalloc(d->dev, sizeof(*ops), GFP_KERNEL);\r\nif (!ops)\r\nreturn -ENOMEM;\r\ninit.name = child_name;\r\ninit.ops = ops;\r\ninit.flags = CLK_IS_BASIC;\r\nco->hw.init = &init;\r\nparent_names[0] = __clk_get_name(clk0);\r\nparent_names[1] = __clk_get_name(clk1);\r\ninit.parent_names = parent_names;\r\ninit.num_parents = 2;\r\nops->get_parent = ti_adpll_clkout_get_parent;\r\nops->determine_rate = __clk_mux_determine_rate;\r\nif (gate_bit) {\r\nco->gate.lock = &d->lock;\r\nco->gate.reg = d->regs + ADPLL_CLKCTRL_OFFSET;\r\nco->gate.bit_idx = gate_bit;\r\nops->enable = ti_adpll_clkout_enable;\r\nops->disable = ti_adpll_clkout_disable;\r\nops->is_enabled = ti_adpll_clkout_is_enabled;\r\n}\r\nclock = devm_clk_register(d->dev, &co->hw);\r\nif (IS_ERR(clock)) {\r\ndev_err(d->dev, "failed to register output %s: %li\n",\r\nname, PTR_ERR(clock));\r\nreturn PTR_ERR(clock);\r\n}\r\nreturn ti_adpll_setup_clock(d, clock, index, output_index, child_name,\r\nNULL);\r\n}\r\nstatic int ti_adpll_init_children_adpll_s(struct ti_adpll_data *d)\r\n{\r\nint err;\r\nif (!d->c->is_type_s)\r\nreturn 0;\r\nerr = ti_adpll_init_mux(d, TI_ADPLL_BYPASS, "bypass",\r\nd->clocks[TI_ADPLL_N2].clk,\r\nd->parent_clocks[TI_ADPLL_CLKINPULOW],\r\nd->regs + ADPLL_CLKCTRL_OFFSET,\r\nADPLL_CLKCTRL_ULOWCLKEN);\r\nif (err)\r\nreturn err;\r\nerr = ti_adpll_init_divider(d, TI_ADPLL_M2, -ENODEV, "m2",\r\nd->clocks[TI_ADPLL_DCO].clk,\r\nd->regs + ADPLL_M2NDIV_OFFSET,\r\nADPLL_M2NDIV_M2,\r\nADPLL_M2NDIV_M2_ADPLL_S_WIDTH,\r\nCLK_DIVIDER_ONE_BASED);\r\nif (err)\r\nreturn err;\r\nerr = ti_adpll_init_fixed_factor(d, TI_ADPLL_DIV2, "div2",\r\nd->clocks[TI_ADPLL_M2].clk,\r\n1, 2);\r\nif (err)\r\nreturn err;\r\nerr = ti_adpll_init_clkout(d, TI_ADPLL_CLKOUT, TI_ADPLL_S_CLKOUT,\r\nADPLL_CLKCTRL_CLKOUTEN, "clkout",\r\nd->clocks[TI_ADPLL_DIV2].clk,\r\nd->clocks[TI_ADPLL_BYPASS].clk);\r\nif (err)\r\nreturn err;\r\nerr = ti_adpll_init_clkout(d, TI_ADPLL_CLKOUT2, TI_ADPLL_S_CLKOUTX2, 0,\r\n"clkout2", d->clocks[TI_ADPLL_M2].clk,\r\nd->clocks[TI_ADPLL_BYPASS].clk);\r\nif (err)\r\nreturn err;\r\nif (d->parent_clocks[TI_ADPLL_CLKINPHIF]) {\r\nerr = ti_adpll_init_mux(d, TI_ADPLL_HIF, "hif",\r\nd->clocks[TI_ADPLL_DCO].clk,\r\nd->parent_clocks[TI_ADPLL_CLKINPHIF],\r\nd->regs + ADPLL_CLKCTRL_OFFSET,\r\nADPLL_CLKINPHIFSEL_ADPLL_S);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = ti_adpll_init_divider(d, TI_ADPLL_M3, TI_ADPLL_S_CLKOUTHIF, "m3",\r\nd->clocks[TI_ADPLL_HIF].clk,\r\nd->regs + ADPLL_M3DIV_OFFSET,\r\nADPLL_M3DIV_M3,\r\nADPLL_M3DIV_M3_WIDTH,\r\nCLK_DIVIDER_ONE_BASED);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int ti_adpll_init_children_adpll_lj(struct ti_adpll_data *d)\r\n{\r\nint err;\r\nif (d->c->is_type_s)\r\nreturn 0;\r\nerr = ti_adpll_init_gate(d, TI_ADPLL_DCO_GATE, TI_ADPLL_LJ_CLKDCOLDO,\r\n"clkdcoldo", d->clocks[TI_ADPLL_DCO].clk,\r\nd->regs + ADPLL_CLKCTRL_OFFSET,\r\nADPLL_CLKCTRL_CLKDCOLDOEN, 0);\r\nif (err)\r\nreturn err;\r\nerr = ti_adpll_init_divider(d, TI_ADPLL_M2, -ENODEV,\r\n"m2", d->clocks[TI_ADPLL_DCO].clk,\r\nd->regs + ADPLL_M2NDIV_OFFSET,\r\nADPLL_M2NDIV_M2,\r\nADPLL_M2NDIV_M2_ADPLL_LJ_WIDTH,\r\nCLK_DIVIDER_ONE_BASED);\r\nif (err)\r\nreturn err;\r\nerr = ti_adpll_init_gate(d, TI_ADPLL_M2_GATE, TI_ADPLL_LJ_CLKOUTLDO,\r\n"clkoutldo", d->clocks[TI_ADPLL_M2].clk,\r\nd->regs + ADPLL_CLKCTRL_OFFSET,\r\nADPLL_CLKCTRL_CLKOUTLDOEN_ADPLL_LJ,\r\n0);\r\nif (err)\r\nreturn err;\r\nerr = ti_adpll_init_mux(d, TI_ADPLL_BYPASS, "bypass",\r\nd->clocks[TI_ADPLL_N2].clk,\r\nd->parent_clocks[TI_ADPLL_CLKINPULOW],\r\nd->regs + ADPLL_CLKCTRL_OFFSET,\r\nADPLL_CLKCTRL_ULOWCLKEN);\r\nif (err)\r\nreturn err;\r\nerr = ti_adpll_init_clkout(d, TI_ADPLL_CLKOUT, TI_ADPLL_S_CLKOUT,\r\nADPLL_CLKCTRL_CLKOUTEN, "clkout",\r\nd->clocks[TI_ADPLL_M2].clk,\r\nd->clocks[TI_ADPLL_BYPASS].clk);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void ti_adpll_free_resources(struct ti_adpll_data *d)\r\n{\r\nint i;\r\nfor (i = TI_ADPLL_M3; i >= 0; i--) {\r\nstruct ti_adpll_clock *ac = &d->clocks[i];\r\nif (!ac || IS_ERR_OR_NULL(ac->clk))\r\ncontinue;\r\nif (ac->cl)\r\nclkdev_drop(ac->cl);\r\nif (ac->unregister)\r\nac->unregister(ac->clk);\r\n}\r\n}\r\nstatic void ti_adpll_unlock_all(void __iomem *reg)\r\n{\r\nu32 v;\r\nv = readl_relaxed(reg);\r\nif (v == ADPLL_PLLSS_MMR_LOCK_ENABLED)\r\nwritel_relaxed(ADPLL_PLLSS_MMR_UNLOCK_MAGIC, reg);\r\n}\r\nstatic int ti_adpll_init_registers(struct ti_adpll_data *d)\r\n{\r\nint register_offset = 0;\r\nif (d->c->is_type_s) {\r\nregister_offset = 8;\r\nti_adpll_unlock_all(d->iobase + ADPLL_PLLSS_MMR_LOCK_OFFSET);\r\n}\r\nd->regs = d->iobase + register_offset + ADPLL_PWRCTRL_OFFSET;\r\nreturn 0;\r\n}\r\nstatic int ti_adpll_init_inputs(struct ti_adpll_data *d)\r\n{\r\nconst char *error = "need at least %i inputs";\r\nstruct clk *clock;\r\nint nr_inputs;\r\nnr_inputs = of_clk_get_parent_count(d->np);\r\nif (nr_inputs < d->c->nr_max_inputs) {\r\ndev_err(d->dev, error, nr_inputs);\r\nreturn -EINVAL;\r\n}\r\nof_clk_parent_fill(d->np, d->parent_names, nr_inputs);\r\nclock = devm_clk_get(d->dev, d->parent_names[0]);\r\nif (IS_ERR(clock)) {\r\ndev_err(d->dev, "could not get clkinp\n");\r\nreturn PTR_ERR(clock);\r\n}\r\nd->parent_clocks[TI_ADPLL_CLKINP] = clock;\r\nclock = devm_clk_get(d->dev, d->parent_names[1]);\r\nif (IS_ERR(clock)) {\r\ndev_err(d->dev, "could not get clkinpulow clock\n");\r\nreturn PTR_ERR(clock);\r\n}\r\nd->parent_clocks[TI_ADPLL_CLKINPULOW] = clock;\r\nif (d->c->is_type_s) {\r\nclock = devm_clk_get(d->dev, d->parent_names[2]);\r\nif (IS_ERR(clock)) {\r\ndev_err(d->dev, "could not get clkinphif clock\n");\r\nreturn PTR_ERR(clock);\r\n}\r\nd->parent_clocks[TI_ADPLL_CLKINPHIF] = clock;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ti_adpll_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct device *dev = &pdev->dev;\r\nconst struct of_device_id *match;\r\nconst struct ti_adpll_platform_data *pdata;\r\nstruct ti_adpll_data *d;\r\nstruct resource *res;\r\nint err;\r\nmatch = of_match_device(ti_adpll_match, dev);\r\nif (match)\r\npdata = match->data;\r\nelse\r\nreturn -ENODEV;\r\nd = devm_kzalloc(dev, sizeof(*d), GFP_KERNEL);\r\nif (!d)\r\nreturn -ENOMEM;\r\nd->dev = dev;\r\nd->np = node;\r\nd->c = pdata;\r\ndev_set_drvdata(d->dev, d);\r\nspin_lock_init(&d->lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\nd->pa = res->start;\r\nd->iobase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(d->iobase)) {\r\ndev_err(dev, "could not get IO base: %li\n",\r\nPTR_ERR(d->iobase));\r\nreturn PTR_ERR(d->iobase);\r\n}\r\nerr = ti_adpll_init_registers(d);\r\nif (err)\r\nreturn err;\r\nerr = ti_adpll_init_inputs(d);\r\nif (err)\r\nreturn err;\r\nd->clocks = devm_kzalloc(d->dev, sizeof(struct ti_adpll_clock) *\r\nTI_ADPLL_NR_CLOCKS,\r\nGFP_KERNEL);\r\nif (!d->clocks)\r\nreturn -ENOMEM;\r\nerr = ti_adpll_init_dco(d);\r\nif (err) {\r\ndev_err(dev, "could not register dco: %i\n", err);\r\ngoto free;\r\n}\r\nerr = ti_adpll_init_children_adpll_s(d);\r\nif (err)\r\ngoto free;\r\nerr = ti_adpll_init_children_adpll_lj(d);\r\nif (err)\r\ngoto free;\r\nerr = of_clk_add_provider(d->np, of_clk_src_onecell_get, &d->outputs);\r\nif (err)\r\ngoto free;\r\nreturn 0;\r\nfree:\r\nWARN_ON(1);\r\nti_adpll_free_resources(d);\r\nreturn err;\r\n}\r\nstatic int ti_adpll_remove(struct platform_device *pdev)\r\n{\r\nstruct ti_adpll_data *d = dev_get_drvdata(&pdev->dev);\r\nti_adpll_free_resources(d);\r\nreturn 0;\r\n}\r\nstatic int __init ti_adpll_init(void)\r\n{\r\nreturn platform_driver_register(&ti_adpll_driver);\r\n}\r\nstatic void __exit ti_adpll_exit(void)\r\n{\r\nplatform_driver_unregister(&ti_adpll_driver);\r\n}
