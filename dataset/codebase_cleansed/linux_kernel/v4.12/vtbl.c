static int ubi_update_layout_vol(struct ubi_device *ubi)\r\n{\r\nstruct ubi_volume *layout_vol;\r\nint i, err;\r\nlayout_vol = ubi->volumes[vol_id2idx(ubi, UBI_LAYOUT_VOLUME_ID)];\r\nfor (i = 0; i < UBI_LAYOUT_VOLUME_EBS; i++) {\r\nerr = ubi_eba_atomic_leb_change(ubi, layout_vol, i, ubi->vtbl,\r\nubi->vtbl_size);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint ubi_change_vtbl_record(struct ubi_device *ubi, int idx,\r\nstruct ubi_vtbl_record *vtbl_rec)\r\n{\r\nint err;\r\nuint32_t crc;\r\nubi_assert(idx >= 0 && idx < ubi->vtbl_slots);\r\nif (!vtbl_rec)\r\nvtbl_rec = &empty_vtbl_record;\r\nelse {\r\ncrc = crc32(UBI_CRC32_INIT, vtbl_rec, UBI_VTBL_RECORD_SIZE_CRC);\r\nvtbl_rec->crc = cpu_to_be32(crc);\r\n}\r\nmemcpy(&ubi->vtbl[idx], vtbl_rec, sizeof(struct ubi_vtbl_record));\r\nerr = ubi_update_layout_vol(ubi);\r\nself_vtbl_check(ubi);\r\nreturn err ? err : 0;\r\n}\r\nint ubi_vtbl_rename_volumes(struct ubi_device *ubi,\r\nstruct list_head *rename_list)\r\n{\r\nstruct ubi_rename_entry *re;\r\nlist_for_each_entry(re, rename_list, list) {\r\nuint32_t crc;\r\nstruct ubi_volume *vol = re->desc->vol;\r\nstruct ubi_vtbl_record *vtbl_rec = &ubi->vtbl[vol->vol_id];\r\nif (re->remove) {\r\nmemcpy(vtbl_rec, &empty_vtbl_record,\r\nsizeof(struct ubi_vtbl_record));\r\ncontinue;\r\n}\r\nvtbl_rec->name_len = cpu_to_be16(re->new_name_len);\r\nmemcpy(vtbl_rec->name, re->new_name, re->new_name_len);\r\nmemset(vtbl_rec->name + re->new_name_len, 0,\r\nUBI_VOL_NAME_MAX + 1 - re->new_name_len);\r\ncrc = crc32(UBI_CRC32_INIT, vtbl_rec,\r\nUBI_VTBL_RECORD_SIZE_CRC);\r\nvtbl_rec->crc = cpu_to_be32(crc);\r\n}\r\nreturn ubi_update_layout_vol(ubi);\r\n}\r\nstatic int vtbl_check(const struct ubi_device *ubi,\r\nconst struct ubi_vtbl_record *vtbl)\r\n{\r\nint i, n, reserved_pebs, alignment, data_pad, vol_type, name_len;\r\nint upd_marker, err;\r\nuint32_t crc;\r\nconst char *name;\r\nfor (i = 0; i < ubi->vtbl_slots; i++) {\r\ncond_resched();\r\nreserved_pebs = be32_to_cpu(vtbl[i].reserved_pebs);\r\nalignment = be32_to_cpu(vtbl[i].alignment);\r\ndata_pad = be32_to_cpu(vtbl[i].data_pad);\r\nupd_marker = vtbl[i].upd_marker;\r\nvol_type = vtbl[i].vol_type;\r\nname_len = be16_to_cpu(vtbl[i].name_len);\r\nname = &vtbl[i].name[0];\r\ncrc = crc32(UBI_CRC32_INIT, &vtbl[i], UBI_VTBL_RECORD_SIZE_CRC);\r\nif (be32_to_cpu(vtbl[i].crc) != crc) {\r\nubi_err(ubi, "bad CRC at record %u: %#08x, not %#08x",\r\ni, crc, be32_to_cpu(vtbl[i].crc));\r\nubi_dump_vtbl_record(&vtbl[i], i);\r\nreturn 1;\r\n}\r\nif (reserved_pebs == 0) {\r\nif (memcmp(&vtbl[i], &empty_vtbl_record,\r\nUBI_VTBL_RECORD_SIZE)) {\r\nerr = 2;\r\ngoto bad;\r\n}\r\ncontinue;\r\n}\r\nif (reserved_pebs < 0 || alignment < 0 || data_pad < 0 ||\r\nname_len < 0) {\r\nerr = 3;\r\ngoto bad;\r\n}\r\nif (alignment > ubi->leb_size || alignment == 0) {\r\nerr = 4;\r\ngoto bad;\r\n}\r\nn = alignment & (ubi->min_io_size - 1);\r\nif (alignment != 1 && n) {\r\nerr = 5;\r\ngoto bad;\r\n}\r\nn = ubi->leb_size % alignment;\r\nif (data_pad != n) {\r\nubi_err(ubi, "bad data_pad, has to be %d", n);\r\nerr = 6;\r\ngoto bad;\r\n}\r\nif (vol_type != UBI_VID_DYNAMIC && vol_type != UBI_VID_STATIC) {\r\nerr = 7;\r\ngoto bad;\r\n}\r\nif (upd_marker != 0 && upd_marker != 1) {\r\nerr = 8;\r\ngoto bad;\r\n}\r\nif (reserved_pebs > ubi->good_peb_count) {\r\nubi_err(ubi, "too large reserved_pebs %d, good PEBs %d",\r\nreserved_pebs, ubi->good_peb_count);\r\nerr = 9;\r\ngoto bad;\r\n}\r\nif (name_len > UBI_VOL_NAME_MAX) {\r\nerr = 10;\r\ngoto bad;\r\n}\r\nif (name[0] == '\0') {\r\nerr = 11;\r\ngoto bad;\r\n}\r\nif (name_len != strnlen(name, name_len + 1)) {\r\nerr = 12;\r\ngoto bad;\r\n}\r\n}\r\nfor (i = 0; i < ubi->vtbl_slots - 1; i++) {\r\nfor (n = i + 1; n < ubi->vtbl_slots; n++) {\r\nint len1 = be16_to_cpu(vtbl[i].name_len);\r\nint len2 = be16_to_cpu(vtbl[n].name_len);\r\nif (len1 > 0 && len1 == len2 &&\r\n!strncmp(vtbl[i].name, vtbl[n].name, len1)) {\r\nubi_err(ubi, "volumes %d and %d have the same name \"%s\"",\r\ni, n, vtbl[i].name);\r\nubi_dump_vtbl_record(&vtbl[i], i);\r\nubi_dump_vtbl_record(&vtbl[n], n);\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nreturn 0;\r\nbad:\r\nubi_err(ubi, "volume table check failed: record %d, error %d", i, err);\r\nubi_dump_vtbl_record(&vtbl[i], i);\r\nreturn -EINVAL;\r\n}\r\nstatic int create_vtbl(struct ubi_device *ubi, struct ubi_attach_info *ai,\r\nint copy, void *vtbl)\r\n{\r\nint err, tries = 0;\r\nstruct ubi_vid_io_buf *vidb;\r\nstruct ubi_vid_hdr *vid_hdr;\r\nstruct ubi_ainf_peb *new_aeb;\r\ndbg_gen("create volume table (copy #%d)", copy + 1);\r\nvidb = ubi_alloc_vid_buf(ubi, GFP_KERNEL);\r\nif (!vidb)\r\nreturn -ENOMEM;\r\nvid_hdr = ubi_get_vid_hdr(vidb);\r\nretry:\r\nnew_aeb = ubi_early_get_peb(ubi, ai);\r\nif (IS_ERR(new_aeb)) {\r\nerr = PTR_ERR(new_aeb);\r\ngoto out_free;\r\n}\r\nvid_hdr->vol_type = UBI_LAYOUT_VOLUME_TYPE;\r\nvid_hdr->vol_id = cpu_to_be32(UBI_LAYOUT_VOLUME_ID);\r\nvid_hdr->compat = UBI_LAYOUT_VOLUME_COMPAT;\r\nvid_hdr->data_size = vid_hdr->used_ebs =\r\nvid_hdr->data_pad = cpu_to_be32(0);\r\nvid_hdr->lnum = cpu_to_be32(copy);\r\nvid_hdr->sqnum = cpu_to_be64(++ai->max_sqnum);\r\nerr = ubi_io_write_vid_hdr(ubi, new_aeb->pnum, vidb);\r\nif (err)\r\ngoto write_error;\r\nerr = ubi_io_write_data(ubi, vtbl, new_aeb->pnum, 0, ubi->vtbl_size);\r\nif (err)\r\ngoto write_error;\r\nerr = ubi_add_to_av(ubi, ai, new_aeb->pnum, new_aeb->ec, vid_hdr, 0);\r\nubi_free_aeb(ai, new_aeb);\r\nubi_free_vid_buf(vidb);\r\nreturn err;\r\nwrite_error:\r\nif (err == -EIO && ++tries <= 5) {\r\nlist_add(&new_aeb->u.list, &ai->erase);\r\ngoto retry;\r\n}\r\nubi_free_aeb(ai, new_aeb);\r\nout_free:\r\nubi_free_vid_buf(vidb);\r\nreturn err;\r\n}\r\nstatic struct ubi_vtbl_record *process_lvol(struct ubi_device *ubi,\r\nstruct ubi_attach_info *ai,\r\nstruct ubi_ainf_volume *av)\r\n{\r\nint err;\r\nstruct rb_node *rb;\r\nstruct ubi_ainf_peb *aeb;\r\nstruct ubi_vtbl_record *leb[UBI_LAYOUT_VOLUME_EBS] = { NULL, NULL };\r\nint leb_corrupted[UBI_LAYOUT_VOLUME_EBS] = {1, 1};\r\ndbg_gen("check layout volume");\r\nubi_rb_for_each_entry(rb, aeb, &av->root, u.rb) {\r\nleb[aeb->lnum] = vzalloc(ubi->vtbl_size);\r\nif (!leb[aeb->lnum]) {\r\nerr = -ENOMEM;\r\ngoto out_free;\r\n}\r\nerr = ubi_io_read_data(ubi, leb[aeb->lnum], aeb->pnum, 0,\r\nubi->vtbl_size);\r\nif (err == UBI_IO_BITFLIPS || mtd_is_eccerr(err))\r\naeb->scrub = 1;\r\nelse if (err)\r\ngoto out_free;\r\n}\r\nerr = -EINVAL;\r\nif (leb[0]) {\r\nleb_corrupted[0] = vtbl_check(ubi, leb[0]);\r\nif (leb_corrupted[0] < 0)\r\ngoto out_free;\r\n}\r\nif (!leb_corrupted[0]) {\r\nif (leb[1])\r\nleb_corrupted[1] = memcmp(leb[0], leb[1],\r\nubi->vtbl_size);\r\nif (leb_corrupted[1]) {\r\nubi_warn(ubi, "volume table copy #2 is corrupted");\r\nerr = create_vtbl(ubi, ai, 1, leb[0]);\r\nif (err)\r\ngoto out_free;\r\nubi_msg(ubi, "volume table was restored");\r\n}\r\nvfree(leb[1]);\r\nreturn leb[0];\r\n} else {\r\nif (leb[1]) {\r\nleb_corrupted[1] = vtbl_check(ubi, leb[1]);\r\nif (leb_corrupted[1] < 0)\r\ngoto out_free;\r\n}\r\nif (leb_corrupted[1]) {\r\nubi_err(ubi, "both volume tables are corrupted");\r\ngoto out_free;\r\n}\r\nubi_warn(ubi, "volume table copy #1 is corrupted");\r\nerr = create_vtbl(ubi, ai, 0, leb[1]);\r\nif (err)\r\ngoto out_free;\r\nubi_msg(ubi, "volume table was restored");\r\nvfree(leb[0]);\r\nreturn leb[1];\r\n}\r\nout_free:\r\nvfree(leb[0]);\r\nvfree(leb[1]);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic struct ubi_vtbl_record *create_empty_lvol(struct ubi_device *ubi,\r\nstruct ubi_attach_info *ai)\r\n{\r\nint i;\r\nstruct ubi_vtbl_record *vtbl;\r\nvtbl = vzalloc(ubi->vtbl_size);\r\nif (!vtbl)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (i = 0; i < ubi->vtbl_slots; i++)\r\nmemcpy(&vtbl[i], &empty_vtbl_record, UBI_VTBL_RECORD_SIZE);\r\nfor (i = 0; i < UBI_LAYOUT_VOLUME_EBS; i++) {\r\nint err;\r\nerr = create_vtbl(ubi, ai, i, vtbl);\r\nif (err) {\r\nvfree(vtbl);\r\nreturn ERR_PTR(err);\r\n}\r\n}\r\nreturn vtbl;\r\n}\r\nstatic int init_volumes(struct ubi_device *ubi,\r\nconst struct ubi_attach_info *ai,\r\nconst struct ubi_vtbl_record *vtbl)\r\n{\r\nint i, reserved_pebs = 0;\r\nstruct ubi_ainf_volume *av;\r\nstruct ubi_volume *vol;\r\nfor (i = 0; i < ubi->vtbl_slots; i++) {\r\ncond_resched();\r\nif (be32_to_cpu(vtbl[i].reserved_pebs) == 0)\r\ncontinue;\r\nvol = kzalloc(sizeof(struct ubi_volume), GFP_KERNEL);\r\nif (!vol)\r\nreturn -ENOMEM;\r\nvol->reserved_pebs = be32_to_cpu(vtbl[i].reserved_pebs);\r\nvol->alignment = be32_to_cpu(vtbl[i].alignment);\r\nvol->data_pad = be32_to_cpu(vtbl[i].data_pad);\r\nvol->upd_marker = vtbl[i].upd_marker;\r\nvol->vol_type = vtbl[i].vol_type == UBI_VID_DYNAMIC ?\r\nUBI_DYNAMIC_VOLUME : UBI_STATIC_VOLUME;\r\nvol->name_len = be16_to_cpu(vtbl[i].name_len);\r\nvol->usable_leb_size = ubi->leb_size - vol->data_pad;\r\nmemcpy(vol->name, vtbl[i].name, vol->name_len);\r\nvol->name[vol->name_len] = '\0';\r\nvol->vol_id = i;\r\nif (vtbl[i].flags & UBI_VTBL_AUTORESIZE_FLG) {\r\nif (ubi->autoresize_vol_id != -1) {\r\nubi_err(ubi, "more than one auto-resize volume (%d and %d)",\r\nubi->autoresize_vol_id, i);\r\nkfree(vol);\r\nreturn -EINVAL;\r\n}\r\nubi->autoresize_vol_id = i;\r\n}\r\nubi_assert(!ubi->volumes[i]);\r\nubi->volumes[i] = vol;\r\nubi->vol_count += 1;\r\nvol->ubi = ubi;\r\nreserved_pebs += vol->reserved_pebs;\r\nif (vol->vol_type == UBI_DYNAMIC_VOLUME) {\r\nvol->used_ebs = vol->reserved_pebs;\r\nvol->last_eb_bytes = vol->usable_leb_size;\r\nvol->used_bytes =\r\n(long long)vol->used_ebs * vol->usable_leb_size;\r\ncontinue;\r\n}\r\nav = ubi_find_av(ai, i);\r\nif (!av || !av->leb_count) {\r\ncontinue;\r\n}\r\nif (av->leb_count != av->used_ebs) {\r\nubi_warn(ubi, "static volume %d misses %d LEBs - corrupted",\r\nav->vol_id, av->used_ebs - av->leb_count);\r\nvol->corrupted = 1;\r\ncontinue;\r\n}\r\nvol->used_ebs = av->used_ebs;\r\nvol->used_bytes =\r\n(long long)(vol->used_ebs - 1) * vol->usable_leb_size;\r\nvol->used_bytes += av->last_data_size;\r\nvol->last_eb_bytes = av->last_data_size;\r\n}\r\nvol = kzalloc(sizeof(struct ubi_volume), GFP_KERNEL);\r\nif (!vol)\r\nreturn -ENOMEM;\r\nvol->reserved_pebs = UBI_LAYOUT_VOLUME_EBS;\r\nvol->alignment = UBI_LAYOUT_VOLUME_ALIGN;\r\nvol->vol_type = UBI_DYNAMIC_VOLUME;\r\nvol->name_len = sizeof(UBI_LAYOUT_VOLUME_NAME) - 1;\r\nmemcpy(vol->name, UBI_LAYOUT_VOLUME_NAME, vol->name_len + 1);\r\nvol->usable_leb_size = ubi->leb_size;\r\nvol->used_ebs = vol->reserved_pebs;\r\nvol->last_eb_bytes = vol->reserved_pebs;\r\nvol->used_bytes =\r\n(long long)vol->used_ebs * (ubi->leb_size - vol->data_pad);\r\nvol->vol_id = UBI_LAYOUT_VOLUME_ID;\r\nvol->ref_count = 1;\r\nubi_assert(!ubi->volumes[i]);\r\nubi->volumes[vol_id2idx(ubi, vol->vol_id)] = vol;\r\nreserved_pebs += vol->reserved_pebs;\r\nubi->vol_count += 1;\r\nvol->ubi = ubi;\r\nif (reserved_pebs > ubi->avail_pebs) {\r\nubi_err(ubi, "not enough PEBs, required %d, available %d",\r\nreserved_pebs, ubi->avail_pebs);\r\nif (ubi->corr_peb_count)\r\nubi_err(ubi, "%d PEBs are corrupted and not used",\r\nubi->corr_peb_count);\r\nreturn -ENOSPC;\r\n}\r\nubi->rsvd_pebs += reserved_pebs;\r\nubi->avail_pebs -= reserved_pebs;\r\nreturn 0;\r\n}\r\nstatic int check_av(const struct ubi_volume *vol,\r\nconst struct ubi_ainf_volume *av)\r\n{\r\nint err;\r\nif (av->highest_lnum >= vol->reserved_pebs) {\r\nerr = 1;\r\ngoto bad;\r\n}\r\nif (av->leb_count > vol->reserved_pebs) {\r\nerr = 2;\r\ngoto bad;\r\n}\r\nif (av->vol_type != vol->vol_type) {\r\nerr = 3;\r\ngoto bad;\r\n}\r\nif (av->used_ebs > vol->reserved_pebs) {\r\nerr = 4;\r\ngoto bad;\r\n}\r\nif (av->data_pad != vol->data_pad) {\r\nerr = 5;\r\ngoto bad;\r\n}\r\nreturn 0;\r\nbad:\r\nubi_err(vol->ubi, "bad attaching information, error %d", err);\r\nubi_dump_av(av);\r\nubi_dump_vol_info(vol);\r\nreturn -EINVAL;\r\n}\r\nstatic int check_attaching_info(const struct ubi_device *ubi,\r\nstruct ubi_attach_info *ai)\r\n{\r\nint err, i;\r\nstruct ubi_ainf_volume *av;\r\nstruct ubi_volume *vol;\r\nif (ai->vols_found > UBI_INT_VOL_COUNT + ubi->vtbl_slots) {\r\nubi_err(ubi, "found %d volumes while attaching, maximum is %d + %d",\r\nai->vols_found, UBI_INT_VOL_COUNT, ubi->vtbl_slots);\r\nreturn -EINVAL;\r\n}\r\nif (ai->highest_vol_id >= ubi->vtbl_slots + UBI_INT_VOL_COUNT &&\r\nai->highest_vol_id < UBI_INTERNAL_VOL_START) {\r\nubi_err(ubi, "too large volume ID %d found",\r\nai->highest_vol_id);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < ubi->vtbl_slots + UBI_INT_VOL_COUNT; i++) {\r\ncond_resched();\r\nav = ubi_find_av(ai, i);\r\nvol = ubi->volumes[i];\r\nif (!vol) {\r\nif (av)\r\nubi_remove_av(ai, av);\r\ncontinue;\r\n}\r\nif (vol->reserved_pebs == 0) {\r\nubi_assert(i < ubi->vtbl_slots);\r\nif (!av)\r\ncontinue;\r\nubi_msg(ubi, "finish volume %d removal", av->vol_id);\r\nubi_remove_av(ai, av);\r\n} else if (av) {\r\nerr = check_av(vol, av);\r\nif (err)\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint ubi_read_volume_table(struct ubi_device *ubi, struct ubi_attach_info *ai)\r\n{\r\nint i, err;\r\nstruct ubi_ainf_volume *av;\r\nempty_vtbl_record.crc = cpu_to_be32(0xf116c36b);\r\nubi->vtbl_slots = ubi->leb_size / UBI_VTBL_RECORD_SIZE;\r\nif (ubi->vtbl_slots > UBI_MAX_VOLUMES)\r\nubi->vtbl_slots = UBI_MAX_VOLUMES;\r\nubi->vtbl_size = ubi->vtbl_slots * UBI_VTBL_RECORD_SIZE;\r\nubi->vtbl_size = ALIGN(ubi->vtbl_size, ubi->min_io_size);\r\nav = ubi_find_av(ai, UBI_LAYOUT_VOLUME_ID);\r\nif (!av) {\r\nif (ai->is_empty) {\r\nubi->vtbl = create_empty_lvol(ubi, ai);\r\nif (IS_ERR(ubi->vtbl))\r\nreturn PTR_ERR(ubi->vtbl);\r\n} else {\r\nubi_err(ubi, "the layout volume was not found");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nif (av->leb_count > UBI_LAYOUT_VOLUME_EBS) {\r\nubi_err(ubi, "too many LEBs (%d) in layout volume",\r\nav->leb_count);\r\nreturn -EINVAL;\r\n}\r\nubi->vtbl = process_lvol(ubi, ai, av);\r\nif (IS_ERR(ubi->vtbl))\r\nreturn PTR_ERR(ubi->vtbl);\r\n}\r\nubi->avail_pebs = ubi->good_peb_count - ubi->corr_peb_count;\r\nerr = init_volumes(ubi, ai, ubi->vtbl);\r\nif (err)\r\ngoto out_free;\r\nerr = check_attaching_info(ubi, ai);\r\nif (err)\r\ngoto out_free;\r\nreturn 0;\r\nout_free:\r\nvfree(ubi->vtbl);\r\nfor (i = 0; i < ubi->vtbl_slots + UBI_INT_VOL_COUNT; i++) {\r\nkfree(ubi->volumes[i]);\r\nubi->volumes[i] = NULL;\r\n}\r\nreturn err;\r\n}\r\nstatic void self_vtbl_check(const struct ubi_device *ubi)\r\n{\r\nif (!ubi_dbg_chk_gen(ubi))\r\nreturn;\r\nif (vtbl_check(ubi, ubi->vtbl)) {\r\nubi_err(ubi, "self-check failed");\r\nBUG();\r\n}\r\n}
