static inline struct tegra_bpmp *\r\nmbox_client_to_bpmp(struct mbox_client *client)\r\n{\r\nreturn container_of(client, struct tegra_bpmp, mbox.client);\r\n}\r\nstruct tegra_bpmp *tegra_bpmp_get(struct device *dev)\r\n{\r\nstruct platform_device *pdev;\r\nstruct tegra_bpmp *bpmp;\r\nstruct device_node *np;\r\nnp = of_parse_phandle(dev->of_node, "nvidia,bpmp", 0);\r\nif (!np)\r\nreturn ERR_PTR(-ENOENT);\r\npdev = of_find_device_by_node(np);\r\nif (!pdev) {\r\nbpmp = ERR_PTR(-ENODEV);\r\ngoto put;\r\n}\r\nbpmp = platform_get_drvdata(pdev);\r\nif (!bpmp) {\r\nbpmp = ERR_PTR(-EPROBE_DEFER);\r\nput_device(&pdev->dev);\r\ngoto put;\r\n}\r\nput:\r\nof_node_put(np);\r\nreturn bpmp;\r\n}\r\nvoid tegra_bpmp_put(struct tegra_bpmp *bpmp)\r\n{\r\nif (bpmp)\r\nput_device(bpmp->dev);\r\n}\r\nstatic int tegra_bpmp_channel_get_index(struct tegra_bpmp_channel *channel)\r\n{\r\nreturn channel - channel->bpmp->channels;\r\n}\r\nstatic int\r\ntegra_bpmp_channel_get_thread_index(struct tegra_bpmp_channel *channel)\r\n{\r\nstruct tegra_bpmp *bpmp = channel->bpmp;\r\nunsigned int offset, count;\r\nint index;\r\noffset = bpmp->soc->channels.thread.offset;\r\ncount = bpmp->soc->channels.thread.count;\r\nindex = tegra_bpmp_channel_get_index(channel);\r\nif (index < 0)\r\nreturn index;\r\nif (index < offset || index >= offset + count)\r\nreturn -EINVAL;\r\nreturn index - offset;\r\n}\r\nstatic struct tegra_bpmp_channel *\r\ntegra_bpmp_channel_get_thread(struct tegra_bpmp *bpmp, unsigned int index)\r\n{\r\nunsigned int offset = bpmp->soc->channels.thread.offset;\r\nunsigned int count = bpmp->soc->channels.thread.count;\r\nif (index >= count)\r\nreturn NULL;\r\nreturn &bpmp->channels[offset + index];\r\n}\r\nstatic struct tegra_bpmp_channel *\r\ntegra_bpmp_channel_get_tx(struct tegra_bpmp *bpmp)\r\n{\r\nunsigned int offset = bpmp->soc->channels.cpu_tx.offset;\r\nreturn &bpmp->channels[offset + smp_processor_id()];\r\n}\r\nstatic struct tegra_bpmp_channel *\r\ntegra_bpmp_channel_get_rx(struct tegra_bpmp *bpmp)\r\n{\r\nunsigned int offset = bpmp->soc->channels.cpu_rx.offset;\r\nreturn &bpmp->channels[offset];\r\n}\r\nstatic bool tegra_bpmp_message_valid(const struct tegra_bpmp_message *msg)\r\n{\r\nreturn (msg->tx.size <= MSG_DATA_MIN_SZ) &&\r\n(msg->rx.size <= MSG_DATA_MIN_SZ) &&\r\n(msg->tx.size == 0 || msg->tx.data) &&\r\n(msg->rx.size == 0 || msg->rx.data);\r\n}\r\nstatic bool tegra_bpmp_master_acked(struct tegra_bpmp_channel *channel)\r\n{\r\nvoid *frame;\r\nframe = tegra_ivc_read_get_next_frame(channel->ivc);\r\nif (IS_ERR(frame)) {\r\nchannel->ib = NULL;\r\nreturn false;\r\n}\r\nchannel->ib = frame;\r\nreturn true;\r\n}\r\nstatic int tegra_bpmp_wait_ack(struct tegra_bpmp_channel *channel)\r\n{\r\nunsigned long timeout = channel->bpmp->soc->channels.cpu_tx.timeout;\r\nktime_t end;\r\nend = ktime_add_us(ktime_get(), timeout);\r\ndo {\r\nif (tegra_bpmp_master_acked(channel))\r\nreturn 0;\r\n} while (ktime_before(ktime_get(), end));\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic bool tegra_bpmp_master_free(struct tegra_bpmp_channel *channel)\r\n{\r\nvoid *frame;\r\nframe = tegra_ivc_write_get_next_frame(channel->ivc);\r\nif (IS_ERR(frame)) {\r\nchannel->ob = NULL;\r\nreturn false;\r\n}\r\nchannel->ob = frame;\r\nreturn true;\r\n}\r\nstatic int tegra_bpmp_wait_master_free(struct tegra_bpmp_channel *channel)\r\n{\r\nunsigned long timeout = channel->bpmp->soc->channels.cpu_tx.timeout;\r\nktime_t start, now;\r\nstart = ns_to_ktime(local_clock());\r\ndo {\r\nif (tegra_bpmp_master_free(channel))\r\nreturn 0;\r\nnow = ns_to_ktime(local_clock());\r\n} while (ktime_us_delta(now, start) < timeout);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic ssize_t __tegra_bpmp_channel_read(struct tegra_bpmp_channel *channel,\r\nvoid *data, size_t size)\r\n{\r\nif (data && size > 0)\r\nmemcpy(data, channel->ib->data, size);\r\nreturn tegra_ivc_read_advance(channel->ivc);\r\n}\r\nstatic ssize_t tegra_bpmp_channel_read(struct tegra_bpmp_channel *channel,\r\nvoid *data, size_t size)\r\n{\r\nstruct tegra_bpmp *bpmp = channel->bpmp;\r\nunsigned long flags;\r\nssize_t err;\r\nint index;\r\nindex = tegra_bpmp_channel_get_thread_index(channel);\r\nif (index < 0)\r\nreturn index;\r\nspin_lock_irqsave(&bpmp->lock, flags);\r\nerr = __tegra_bpmp_channel_read(channel, data, size);\r\nclear_bit(index, bpmp->threaded.allocated);\r\nspin_unlock_irqrestore(&bpmp->lock, flags);\r\nup(&bpmp->threaded.lock);\r\nreturn err;\r\n}\r\nstatic ssize_t __tegra_bpmp_channel_write(struct tegra_bpmp_channel *channel,\r\nunsigned int mrq, unsigned long flags,\r\nconst void *data, size_t size)\r\n{\r\nchannel->ob->code = mrq;\r\nchannel->ob->flags = flags;\r\nif (data && size > 0)\r\nmemcpy(channel->ob->data, data, size);\r\nreturn tegra_ivc_write_advance(channel->ivc);\r\n}\r\nstatic struct tegra_bpmp_channel *\r\ntegra_bpmp_write_threaded(struct tegra_bpmp *bpmp, unsigned int mrq,\r\nconst void *data, size_t size)\r\n{\r\nunsigned long timeout = bpmp->soc->channels.thread.timeout;\r\nunsigned int count = bpmp->soc->channels.thread.count;\r\nstruct tegra_bpmp_channel *channel;\r\nunsigned long flags;\r\nunsigned int index;\r\nint err;\r\nerr = down_timeout(&bpmp->threaded.lock, usecs_to_jiffies(timeout));\r\nif (err < 0)\r\nreturn ERR_PTR(err);\r\nspin_lock_irqsave(&bpmp->lock, flags);\r\nindex = find_first_zero_bit(bpmp->threaded.allocated, count);\r\nif (index == count) {\r\nchannel = ERR_PTR(-EBUSY);\r\ngoto unlock;\r\n}\r\nchannel = tegra_bpmp_channel_get_thread(bpmp, index);\r\nif (!channel) {\r\nchannel = ERR_PTR(-EINVAL);\r\ngoto unlock;\r\n}\r\nif (!tegra_bpmp_master_free(channel)) {\r\nchannel = ERR_PTR(-EBUSY);\r\ngoto unlock;\r\n}\r\nset_bit(index, bpmp->threaded.allocated);\r\nerr = __tegra_bpmp_channel_write(channel, mrq, MSG_ACK | MSG_RING,\r\ndata, size);\r\nif (err < 0) {\r\nclear_bit(index, bpmp->threaded.allocated);\r\ngoto unlock;\r\n}\r\nset_bit(index, bpmp->threaded.busy);\r\nunlock:\r\nspin_unlock_irqrestore(&bpmp->lock, flags);\r\nreturn channel;\r\n}\r\nstatic ssize_t tegra_bpmp_channel_write(struct tegra_bpmp_channel *channel,\r\nunsigned int mrq, unsigned long flags,\r\nconst void *data, size_t size)\r\n{\r\nint err;\r\nerr = tegra_bpmp_wait_master_free(channel);\r\nif (err < 0)\r\nreturn err;\r\nreturn __tegra_bpmp_channel_write(channel, mrq, flags, data, size);\r\n}\r\nint tegra_bpmp_transfer_atomic(struct tegra_bpmp *bpmp,\r\nstruct tegra_bpmp_message *msg)\r\n{\r\nstruct tegra_bpmp_channel *channel;\r\nint err;\r\nif (WARN_ON(!irqs_disabled()))\r\nreturn -EPERM;\r\nif (!tegra_bpmp_message_valid(msg))\r\nreturn -EINVAL;\r\nchannel = tegra_bpmp_channel_get_tx(bpmp);\r\nerr = tegra_bpmp_channel_write(channel, msg->mrq, MSG_ACK,\r\nmsg->tx.data, msg->tx.size);\r\nif (err < 0)\r\nreturn err;\r\nerr = mbox_send_message(bpmp->mbox.channel, NULL);\r\nif (err < 0)\r\nreturn err;\r\nmbox_client_txdone(bpmp->mbox.channel, 0);\r\nerr = tegra_bpmp_wait_ack(channel);\r\nif (err < 0)\r\nreturn err;\r\nreturn __tegra_bpmp_channel_read(channel, msg->rx.data, msg->rx.size);\r\n}\r\nint tegra_bpmp_transfer(struct tegra_bpmp *bpmp,\r\nstruct tegra_bpmp_message *msg)\r\n{\r\nstruct tegra_bpmp_channel *channel;\r\nunsigned long timeout;\r\nint err;\r\nif (WARN_ON(irqs_disabled()))\r\nreturn -EPERM;\r\nif (!tegra_bpmp_message_valid(msg))\r\nreturn -EINVAL;\r\nchannel = tegra_bpmp_write_threaded(bpmp, msg->mrq, msg->tx.data,\r\nmsg->tx.size);\r\nif (IS_ERR(channel))\r\nreturn PTR_ERR(channel);\r\nerr = mbox_send_message(bpmp->mbox.channel, NULL);\r\nif (err < 0)\r\nreturn err;\r\nmbox_client_txdone(bpmp->mbox.channel, 0);\r\ntimeout = usecs_to_jiffies(bpmp->soc->channels.thread.timeout);\r\nerr = wait_for_completion_timeout(&channel->completion, timeout);\r\nif (err == 0)\r\nreturn -ETIMEDOUT;\r\nreturn tegra_bpmp_channel_read(channel, msg->rx.data, msg->rx.size);\r\n}\r\nstatic struct tegra_bpmp_mrq *tegra_bpmp_find_mrq(struct tegra_bpmp *bpmp,\r\nunsigned int mrq)\r\n{\r\nstruct tegra_bpmp_mrq *entry;\r\nlist_for_each_entry(entry, &bpmp->mrqs, list)\r\nif (entry->mrq == mrq)\r\nreturn entry;\r\nreturn NULL;\r\n}\r\nstatic void tegra_bpmp_mrq_return(struct tegra_bpmp_channel *channel,\r\nint code, const void *data, size_t size)\r\n{\r\nunsigned long flags = channel->ib->flags;\r\nstruct tegra_bpmp *bpmp = channel->bpmp;\r\nstruct tegra_bpmp_mb_data *frame;\r\nint err;\r\nif (WARN_ON(size > MSG_DATA_MIN_SZ))\r\nreturn;\r\nerr = tegra_ivc_read_advance(channel->ivc);\r\nif (WARN_ON(err < 0))\r\nreturn;\r\nif ((flags & MSG_ACK) == 0)\r\nreturn;\r\nframe = tegra_ivc_write_get_next_frame(channel->ivc);\r\nif (WARN_ON(IS_ERR(frame)))\r\nreturn;\r\nframe->code = code;\r\nif (data && size > 0)\r\nmemcpy(frame->data, data, size);\r\nerr = tegra_ivc_write_advance(channel->ivc);\r\nif (WARN_ON(err < 0))\r\nreturn;\r\nif (flags & MSG_RING) {\r\nerr = mbox_send_message(bpmp->mbox.channel, NULL);\r\nif (WARN_ON(err < 0))\r\nreturn;\r\nmbox_client_txdone(bpmp->mbox.channel, 0);\r\n}\r\n}\r\nstatic void tegra_bpmp_handle_mrq(struct tegra_bpmp *bpmp,\r\nunsigned int mrq,\r\nstruct tegra_bpmp_channel *channel)\r\n{\r\nstruct tegra_bpmp_mrq *entry;\r\nu32 zero = 0;\r\nspin_lock(&bpmp->lock);\r\nentry = tegra_bpmp_find_mrq(bpmp, mrq);\r\nif (!entry) {\r\nspin_unlock(&bpmp->lock);\r\ntegra_bpmp_mrq_return(channel, -EINVAL, &zero, sizeof(zero));\r\nreturn;\r\n}\r\nentry->handler(mrq, channel, entry->data);\r\nspin_unlock(&bpmp->lock);\r\n}\r\nint tegra_bpmp_request_mrq(struct tegra_bpmp *bpmp, unsigned int mrq,\r\ntegra_bpmp_mrq_handler_t handler, void *data)\r\n{\r\nstruct tegra_bpmp_mrq *entry;\r\nunsigned long flags;\r\nif (!handler)\r\nreturn -EINVAL;\r\nentry = devm_kzalloc(bpmp->dev, sizeof(*entry), GFP_KERNEL);\r\nif (!entry)\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&bpmp->lock, flags);\r\nentry->mrq = mrq;\r\nentry->handler = handler;\r\nentry->data = data;\r\nlist_add(&entry->list, &bpmp->mrqs);\r\nspin_unlock_irqrestore(&bpmp->lock, flags);\r\nreturn 0;\r\n}\r\nvoid tegra_bpmp_free_mrq(struct tegra_bpmp *bpmp, unsigned int mrq, void *data)\r\n{\r\nstruct tegra_bpmp_mrq *entry;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bpmp->lock, flags);\r\nentry = tegra_bpmp_find_mrq(bpmp, mrq);\r\nif (!entry)\r\ngoto unlock;\r\nlist_del(&entry->list);\r\ndevm_kfree(bpmp->dev, entry);\r\nunlock:\r\nspin_unlock_irqrestore(&bpmp->lock, flags);\r\n}\r\nstatic void tegra_bpmp_mrq_handle_ping(unsigned int mrq,\r\nstruct tegra_bpmp_channel *channel,\r\nvoid *data)\r\n{\r\nstruct mrq_ping_request *request;\r\nstruct mrq_ping_response response;\r\nrequest = (struct mrq_ping_request *)channel->ib->data;\r\nmemset(&response, 0, sizeof(response));\r\nresponse.reply = request->challenge << 1;\r\ntegra_bpmp_mrq_return(channel, 0, &response, sizeof(response));\r\n}\r\nstatic int tegra_bpmp_ping(struct tegra_bpmp *bpmp)\r\n{\r\nstruct mrq_ping_response response;\r\nstruct mrq_ping_request request;\r\nstruct tegra_bpmp_message msg;\r\nunsigned long flags;\r\nktime_t start, end;\r\nint err;\r\nmemset(&request, 0, sizeof(request));\r\nrequest.challenge = 1;\r\nmemset(&response, 0, sizeof(response));\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.mrq = MRQ_PING;\r\nmsg.tx.data = &request;\r\nmsg.tx.size = sizeof(request);\r\nmsg.rx.data = &response;\r\nmsg.rx.size = sizeof(response);\r\nlocal_irq_save(flags);\r\nstart = ktime_get();\r\nerr = tegra_bpmp_transfer_atomic(bpmp, &msg);\r\nend = ktime_get();\r\nlocal_irq_restore(flags);\r\nif (!err)\r\ndev_dbg(bpmp->dev,\r\n"ping ok: challenge: %u, response: %u, time: %lld\n",\r\nrequest.challenge, response.reply,\r\nktime_to_us(ktime_sub(end, start)));\r\nreturn err;\r\n}\r\nstatic int tegra_bpmp_get_firmware_tag(struct tegra_bpmp *bpmp, char *tag,\r\nsize_t size)\r\n{\r\nstruct mrq_query_tag_request request;\r\nstruct tegra_bpmp_message msg;\r\nunsigned long flags;\r\ndma_addr_t phys;\r\nvoid *virt;\r\nint err;\r\nvirt = dma_alloc_coherent(bpmp->dev, MSG_DATA_MIN_SZ, &phys,\r\nGFP_KERNEL | GFP_DMA32);\r\nif (!virt)\r\nreturn -ENOMEM;\r\nmemset(&request, 0, sizeof(request));\r\nrequest.addr = phys;\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.mrq = MRQ_QUERY_TAG;\r\nmsg.tx.data = &request;\r\nmsg.tx.size = sizeof(request);\r\nlocal_irq_save(flags);\r\nerr = tegra_bpmp_transfer_atomic(bpmp, &msg);\r\nlocal_irq_restore(flags);\r\nif (err == 0)\r\nstrlcpy(tag, virt, size);\r\ndma_free_coherent(bpmp->dev, MSG_DATA_MIN_SZ, virt, phys);\r\nreturn err;\r\n}\r\nstatic void tegra_bpmp_channel_signal(struct tegra_bpmp_channel *channel)\r\n{\r\nunsigned long flags = channel->ob->flags;\r\nif ((flags & MSG_RING) == 0)\r\nreturn;\r\ncomplete(&channel->completion);\r\n}\r\nstatic void tegra_bpmp_handle_rx(struct mbox_client *client, void *data)\r\n{\r\nstruct tegra_bpmp *bpmp = mbox_client_to_bpmp(client);\r\nstruct tegra_bpmp_channel *channel;\r\nunsigned int i, count;\r\nunsigned long *busy;\r\nchannel = tegra_bpmp_channel_get_rx(bpmp);\r\ncount = bpmp->soc->channels.thread.count;\r\nbusy = bpmp->threaded.busy;\r\nif (tegra_bpmp_master_acked(channel))\r\ntegra_bpmp_handle_mrq(bpmp, channel->ib->code, channel);\r\nspin_lock(&bpmp->lock);\r\nfor_each_set_bit(i, busy, count) {\r\nstruct tegra_bpmp_channel *channel;\r\nchannel = tegra_bpmp_channel_get_thread(bpmp, i);\r\nif (!channel)\r\ncontinue;\r\nif (tegra_bpmp_master_acked(channel)) {\r\ntegra_bpmp_channel_signal(channel);\r\nclear_bit(i, busy);\r\n}\r\n}\r\nspin_unlock(&bpmp->lock);\r\n}\r\nstatic void tegra_bpmp_ivc_notify(struct tegra_ivc *ivc, void *data)\r\n{\r\nstruct tegra_bpmp *bpmp = data;\r\nint err;\r\nif (WARN_ON(bpmp->mbox.channel == NULL))\r\nreturn;\r\nerr = mbox_send_message(bpmp->mbox.channel, NULL);\r\nif (err < 0)\r\nreturn;\r\nmbox_client_txdone(bpmp->mbox.channel, 0);\r\n}\r\nstatic int tegra_bpmp_channel_init(struct tegra_bpmp_channel *channel,\r\nstruct tegra_bpmp *bpmp,\r\nunsigned int index)\r\n{\r\nsize_t message_size, queue_size;\r\nunsigned int offset;\r\nint err;\r\nchannel->ivc = devm_kzalloc(bpmp->dev, sizeof(*channel->ivc),\r\nGFP_KERNEL);\r\nif (!channel->ivc)\r\nreturn -ENOMEM;\r\nmessage_size = tegra_ivc_align(MSG_MIN_SZ);\r\nqueue_size = tegra_ivc_total_queue_size(message_size);\r\noffset = queue_size * index;\r\nerr = tegra_ivc_init(channel->ivc, NULL,\r\nbpmp->rx.virt + offset, bpmp->rx.phys + offset,\r\nbpmp->tx.virt + offset, bpmp->tx.phys + offset,\r\n1, message_size, tegra_bpmp_ivc_notify,\r\nbpmp);\r\nif (err < 0) {\r\ndev_err(bpmp->dev, "failed to setup IVC for channel %u: %d\n",\r\nindex, err);\r\nreturn err;\r\n}\r\ninit_completion(&channel->completion);\r\nchannel->bpmp = bpmp;\r\nreturn 0;\r\n}\r\nstatic void tegra_bpmp_channel_reset(struct tegra_bpmp_channel *channel)\r\n{\r\ntegra_ivc_reset(channel->ivc);\r\nwhile (tegra_ivc_notified(channel->ivc))\r\n;\r\n}\r\nstatic void tegra_bpmp_channel_cleanup(struct tegra_bpmp_channel *channel)\r\n{\r\ntegra_ivc_cleanup(channel->ivc);\r\n}\r\nstatic int tegra_bpmp_probe(struct platform_device *pdev)\r\n{\r\nstruct tegra_bpmp_channel *channel;\r\nstruct tegra_bpmp *bpmp;\r\nunsigned int i;\r\nchar tag[32];\r\nsize_t size;\r\nint err;\r\nbpmp = devm_kzalloc(&pdev->dev, sizeof(*bpmp), GFP_KERNEL);\r\nif (!bpmp)\r\nreturn -ENOMEM;\r\nbpmp->soc = of_device_get_match_data(&pdev->dev);\r\nbpmp->dev = &pdev->dev;\r\nbpmp->tx.pool = of_gen_pool_get(pdev->dev.of_node, "shmem", 0);\r\nif (!bpmp->tx.pool) {\r\ndev_err(&pdev->dev, "TX shmem pool not found\n");\r\nreturn -ENOMEM;\r\n}\r\nbpmp->tx.virt = gen_pool_dma_alloc(bpmp->tx.pool, 4096, &bpmp->tx.phys);\r\nif (!bpmp->tx.virt) {\r\ndev_err(&pdev->dev, "failed to allocate from TX pool\n");\r\nreturn -ENOMEM;\r\n}\r\nbpmp->rx.pool = of_gen_pool_get(pdev->dev.of_node, "shmem", 1);\r\nif (!bpmp->rx.pool) {\r\ndev_err(&pdev->dev, "RX shmem pool not found\n");\r\nerr = -ENOMEM;\r\ngoto free_tx;\r\n}\r\nbpmp->rx.virt = gen_pool_dma_alloc(bpmp->rx.pool, 4096, &bpmp->rx.phys);\r\nif (!bpmp->rx.pool) {\r\ndev_err(&pdev->dev, "failed to allocate from RX pool\n");\r\nerr = -ENOMEM;\r\ngoto free_tx;\r\n}\r\nINIT_LIST_HEAD(&bpmp->mrqs);\r\nspin_lock_init(&bpmp->lock);\r\nbpmp->threaded.count = bpmp->soc->channels.thread.count;\r\nsema_init(&bpmp->threaded.lock, bpmp->threaded.count);\r\nsize = BITS_TO_LONGS(bpmp->threaded.count) * sizeof(long);\r\nbpmp->threaded.allocated = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);\r\nif (!bpmp->threaded.allocated) {\r\nerr = -ENOMEM;\r\ngoto free_rx;\r\n}\r\nbpmp->threaded.busy = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);\r\nif (!bpmp->threaded.busy) {\r\nerr = -ENOMEM;\r\ngoto free_rx;\r\n}\r\nbpmp->num_channels = bpmp->soc->channels.cpu_tx.count +\r\nbpmp->soc->channels.thread.count +\r\nbpmp->soc->channels.cpu_rx.count;\r\nbpmp->channels = devm_kcalloc(&pdev->dev, bpmp->num_channels,\r\nsizeof(*channel), GFP_KERNEL);\r\nif (!bpmp->channels) {\r\nerr = -ENOMEM;\r\ngoto free_rx;\r\n}\r\nfor (i = 0; i < bpmp->num_channels; i++) {\r\nstruct tegra_bpmp_channel *channel = &bpmp->channels[i];\r\nerr = tegra_bpmp_channel_init(channel, bpmp, i);\r\nif (err < 0)\r\ngoto cleanup_channels;\r\n}\r\nbpmp->mbox.client.dev = &pdev->dev;\r\nbpmp->mbox.client.rx_callback = tegra_bpmp_handle_rx;\r\nbpmp->mbox.client.tx_block = false;\r\nbpmp->mbox.client.knows_txdone = false;\r\nbpmp->mbox.channel = mbox_request_channel(&bpmp->mbox.client, 0);\r\nif (IS_ERR(bpmp->mbox.channel)) {\r\nerr = PTR_ERR(bpmp->mbox.channel);\r\ndev_err(&pdev->dev, "failed to get HSP mailbox: %d\n", err);\r\ngoto cleanup_channels;\r\n}\r\nfor (i = 0; i < bpmp->num_channels; i++) {\r\nstruct tegra_bpmp_channel *channel = &bpmp->channels[i];\r\ntegra_bpmp_channel_reset(channel);\r\n}\r\nerr = tegra_bpmp_request_mrq(bpmp, MRQ_PING,\r\ntegra_bpmp_mrq_handle_ping, bpmp);\r\nif (err < 0)\r\ngoto free_mbox;\r\nerr = tegra_bpmp_ping(bpmp);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to ping BPMP: %d\n", err);\r\ngoto free_mrq;\r\n}\r\nerr = tegra_bpmp_get_firmware_tag(bpmp, tag, sizeof(tag) - 1);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to get firmware tag: %d\n", err);\r\ngoto free_mrq;\r\n}\r\ndev_info(&pdev->dev, "firmware: %s\n", tag);\r\nerr = of_platform_default_populate(pdev->dev.of_node, NULL, &pdev->dev);\r\nif (err < 0)\r\ngoto free_mrq;\r\nerr = tegra_bpmp_init_clocks(bpmp);\r\nif (err < 0)\r\ngoto free_mrq;\r\nerr = tegra_bpmp_init_resets(bpmp);\r\nif (err < 0)\r\ngoto free_mrq;\r\nplatform_set_drvdata(pdev, bpmp);\r\nreturn 0;\r\nfree_mrq:\r\ntegra_bpmp_free_mrq(bpmp, MRQ_PING, bpmp);\r\nfree_mbox:\r\nmbox_free_channel(bpmp->mbox.channel);\r\ncleanup_channels:\r\nwhile (i--)\r\ntegra_bpmp_channel_cleanup(&bpmp->channels[i]);\r\nfree_rx:\r\ngen_pool_free(bpmp->rx.pool, (unsigned long)bpmp->rx.virt, 4096);\r\nfree_tx:\r\ngen_pool_free(bpmp->tx.pool, (unsigned long)bpmp->tx.virt, 4096);\r\nreturn err;\r\n}\r\nstatic int __init tegra_bpmp_init(void)\r\n{\r\nreturn platform_driver_register(&tegra_bpmp_driver);\r\n}
