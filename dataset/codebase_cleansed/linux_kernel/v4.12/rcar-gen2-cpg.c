static unsigned long cpg_z_clk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct cpg_z_clk *zclk = to_z_clk(hw);\r\nunsigned int mult;\r\nunsigned int val;\r\nval = (readl(zclk->reg) & CPG_FRQCRC_ZFC_MASK) >> CPG_FRQCRC_ZFC_SHIFT;\r\nmult = 32 - val;\r\nreturn div_u64((u64)parent_rate * mult, 32);\r\n}\r\nstatic long cpg_z_clk_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nunsigned long prate = *parent_rate;\r\nunsigned int mult;\r\nif (!prate)\r\nprate = 1;\r\nmult = div_u64((u64)rate * 32, prate);\r\nmult = clamp(mult, 1U, 32U);\r\nreturn *parent_rate / 32 * mult;\r\n}\r\nstatic int cpg_z_clk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct cpg_z_clk *zclk = to_z_clk(hw);\r\nunsigned int mult;\r\nu32 val, kick;\r\nunsigned int i;\r\nmult = div_u64((u64)rate * 32, parent_rate);\r\nmult = clamp(mult, 1U, 32U);\r\nif (readl(zclk->kick_reg) & CPG_FRQCRB_KICK)\r\nreturn -EBUSY;\r\nval = readl(zclk->reg);\r\nval &= ~CPG_FRQCRC_ZFC_MASK;\r\nval |= (32 - mult) << CPG_FRQCRC_ZFC_SHIFT;\r\nwritel(val, zclk->reg);\r\nkick = readl(zclk->kick_reg);\r\nkick |= CPG_FRQCRB_KICK;\r\nwritel(kick, zclk->kick_reg);\r\nfor (i = 1000; i; i--) {\r\nif (!(readl(zclk->kick_reg) & CPG_FRQCRB_KICK))\r\nreturn 0;\r\ncpu_relax();\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic struct clk * __init cpg_z_clk_register(const char *name,\r\nconst char *parent_name,\r\nvoid __iomem *base)\r\n{\r\nstruct clk_init_data init;\r\nstruct cpg_z_clk *zclk;\r\nstruct clk *clk;\r\nzclk = kzalloc(sizeof(*zclk), GFP_KERNEL);\r\nif (!zclk)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &cpg_z_clk_ops;\r\ninit.flags = 0;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\nzclk->reg = base + CPG_FRQCRC;\r\nzclk->kick_reg = base + CPG_FRQCRB;\r\nzclk->hw.init = &init;\r\nclk = clk_register(NULL, &zclk->hw);\r\nif (IS_ERR(clk))\r\nkfree(zclk);\r\nreturn clk;\r\n}\r\nstatic struct clk * __init cpg_rcan_clk_register(const char *name,\r\nconst char *parent_name,\r\nvoid __iomem *base)\r\n{\r\nstruct clk_fixed_factor *fixed;\r\nstruct clk_gate *gate;\r\nstruct clk *clk;\r\nfixed = kzalloc(sizeof(*fixed), GFP_KERNEL);\r\nif (!fixed)\r\nreturn ERR_PTR(-ENOMEM);\r\nfixed->mult = 1;\r\nfixed->div = 6;\r\ngate = kzalloc(sizeof(*gate), GFP_KERNEL);\r\nif (!gate) {\r\nkfree(fixed);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ngate->reg = base + CPG_RCANCKCR;\r\ngate->bit_idx = 8;\r\ngate->flags = CLK_GATE_SET_TO_DISABLE;\r\ngate->lock = &cpg_lock;\r\nclk = clk_register_composite(NULL, name, &parent_name, 1, NULL, NULL,\r\n&fixed->hw, &clk_fixed_factor_ops,\r\n&gate->hw, &clk_gate_ops, 0);\r\nif (IS_ERR(clk)) {\r\nkfree(gate);\r\nkfree(fixed);\r\n}\r\nreturn clk;\r\n}\r\nstatic struct clk * __init cpg_adsp_clk_register(const char *name,\r\nconst char *parent_name,\r\nvoid __iomem *base)\r\n{\r\nstruct clk_divider *div;\r\nstruct clk_gate *gate;\r\nstruct clk *clk;\r\ndiv = kzalloc(sizeof(*div), GFP_KERNEL);\r\nif (!div)\r\nreturn ERR_PTR(-ENOMEM);\r\ndiv->reg = base + CPG_ADSPCKCR;\r\ndiv->width = 4;\r\ndiv->table = cpg_adsp_div_table;\r\ndiv->lock = &cpg_lock;\r\ngate = kzalloc(sizeof(*gate), GFP_KERNEL);\r\nif (!gate) {\r\nkfree(div);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ngate->reg = base + CPG_ADSPCKCR;\r\ngate->bit_idx = 8;\r\ngate->flags = CLK_GATE_SET_TO_DISABLE;\r\ngate->lock = &cpg_lock;\r\nclk = clk_register_composite(NULL, name, &parent_name, 1, NULL, NULL,\r\n&div->hw, &clk_divider_ops,\r\n&gate->hw, &clk_gate_ops, 0);\r\nif (IS_ERR(clk)) {\r\nkfree(gate);\r\nkfree(div);\r\n}\r\nreturn clk;\r\n}\r\nstruct clk * __init rcar_gen2_cpg_clk_register(struct device *dev,\r\nconst struct cpg_core_clk *core,\r\nconst struct cpg_mssr_info *info,\r\nstruct clk **clks,\r\nvoid __iomem *base)\r\n{\r\nconst struct clk_div_table *table = NULL;\r\nconst struct clk *parent;\r\nconst char *parent_name;\r\nunsigned int mult = 1;\r\nunsigned int div = 1;\r\nunsigned int shift;\r\nparent = clks[core->parent];\r\nif (IS_ERR(parent))\r\nreturn ERR_CAST(parent);\r\nparent_name = __clk_get_name(parent);\r\nswitch (core->type) {\r\ncase CLK_TYPE_GEN2_MAIN:\r\ndiv = cpg_pll_config->extal_div;\r\nbreak;\r\ncase CLK_TYPE_GEN2_PLL0:\r\nmult = cpg_pll_config->pll0_mult;\r\ndiv = cpg_pll0_div;\r\nif (!mult) {\r\nu32 pll0cr = readl(base + CPG_PLL0CR);\r\nmult = (((pll0cr & CPG_PLL0CR_STC_MASK) >>\r\nCPG_PLL0CR_STC_SHIFT) + 1) * 2;\r\n}\r\nbreak;\r\ncase CLK_TYPE_GEN2_PLL1:\r\nmult = cpg_pll_config->pll1_mult / 2;\r\nbreak;\r\ncase CLK_TYPE_GEN2_PLL3:\r\nmult = cpg_pll_config->pll3_mult;\r\nbreak;\r\ncase CLK_TYPE_GEN2_Z:\r\nreturn cpg_z_clk_register(core->name, parent_name, base);\r\ncase CLK_TYPE_GEN2_LB:\r\ndiv = cpg_mode & BIT(18) ? 36 : 24;\r\nbreak;\r\ncase CLK_TYPE_GEN2_ADSP:\r\nreturn cpg_adsp_clk_register(core->name, parent_name, base);\r\ncase CLK_TYPE_GEN2_SDH:\r\ntable = cpg_sdh_div_table;\r\nshift = 8;\r\nbreak;\r\ncase CLK_TYPE_GEN2_SD0:\r\ntable = cpg_sd01_div_table;\r\nshift = 4;\r\nbreak;\r\ncase CLK_TYPE_GEN2_SD1:\r\ntable = cpg_sd01_div_table;\r\nshift = 0;\r\nbreak;\r\ncase CLK_TYPE_GEN2_QSPI:\r\ndiv = (cpg_mode & (BIT(3) | BIT(2) | BIT(1))) == BIT(2) ?\r\n8 : 10;\r\nbreak;\r\ncase CLK_TYPE_GEN2_RCAN:\r\nreturn cpg_rcan_clk_register(core->name, parent_name, base);\r\ndefault:\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (!table)\r\nreturn clk_register_fixed_factor(NULL, core->name, parent_name,\r\n0, mult, div);\r\nelse\r\nreturn clk_register_divider_table(NULL, core->name,\r\nparent_name, 0,\r\nbase + CPG_SDCKCR, shift, 4,\r\n0, table, &cpg_lock);\r\n}\r\nint __init rcar_gen2_cpg_init(const struct rcar_gen2_cpg_pll_config *config,\r\nunsigned int pll0_div, u32 mode)\r\n{\r\ncpg_pll_config = config;\r\ncpg_pll0_div = pll0_div;\r\ncpg_mode = mode;\r\nspin_lock_init(&cpg_lock);\r\nreturn 0;\r\n}
