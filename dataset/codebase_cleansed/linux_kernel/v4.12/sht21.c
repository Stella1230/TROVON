static inline int sht21_temp_ticks_to_millicelsius(int ticks)\r\n{\r\nticks &= ~0x0003;\r\nreturn ((21965 * ticks) >> 13) - 46850;\r\n}\r\nstatic inline int sht21_rh_ticks_to_per_cent_mille(int ticks)\r\n{\r\nticks &= ~0x0003;\r\nreturn ((15625 * ticks) >> 13) - 6000;\r\n}\r\nstatic int sht21_update_measurements(struct device *dev)\r\n{\r\nint ret = 0;\r\nstruct sht21 *sht21 = dev_get_drvdata(dev);\r\nstruct i2c_client *client = sht21->client;\r\nmutex_lock(&sht21->lock);\r\nif (time_after(jiffies, sht21->last_update + HZ / 2) || !sht21->valid) {\r\nret = i2c_smbus_read_word_swapped(client,\r\nSHT21_TRIG_T_MEASUREMENT_HM);\r\nif (ret < 0)\r\ngoto out;\r\nsht21->temperature = sht21_temp_ticks_to_millicelsius(ret);\r\nret = i2c_smbus_read_word_swapped(client,\r\nSHT21_TRIG_RH_MEASUREMENT_HM);\r\nif (ret < 0)\r\ngoto out;\r\nsht21->humidity = sht21_rh_ticks_to_per_cent_mille(ret);\r\nsht21->last_update = jiffies;\r\nsht21->valid = 1;\r\n}\r\nout:\r\nmutex_unlock(&sht21->lock);\r\nreturn ret >= 0 ? 0 : ret;\r\n}\r\nstatic ssize_t sht21_show_temperature(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sht21 *sht21 = dev_get_drvdata(dev);\r\nint ret;\r\nret = sht21_update_measurements(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", sht21->temperature);\r\n}\r\nstatic ssize_t sht21_show_humidity(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sht21 *sht21 = dev_get_drvdata(dev);\r\nint ret;\r\nret = sht21_update_measurements(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", sht21->humidity);\r\n}\r\nstatic ssize_t eic_read(struct sht21 *sht21)\r\n{\r\nstruct i2c_client *client = sht21->client;\r\nu8 tx[2];\r\nu8 rx[8];\r\nu8 eic[8];\r\nstruct i2c_msg msgs[2] = {\r\n{\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = 2,\r\n.buf = tx,\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = 8,\r\n.buf = rx,\r\n},\r\n};\r\nint ret;\r\ntx[0] = SHT21_READ_SNB_CMD1;\r\ntx[1] = SHT21_READ_SNB_CMD2;\r\nret = i2c_transfer(client->adapter, msgs, 2);\r\nif (ret < 0)\r\ngoto out;\r\neic[2] = rx[0];\r\neic[3] = rx[2];\r\neic[4] = rx[4];\r\neic[5] = rx[6];\r\ntx[0] = SHT21_READ_SNAC_CMD1;\r\ntx[1] = SHT21_READ_SNAC_CMD2;\r\nmsgs[1].len = 6;\r\nret = i2c_transfer(client->adapter, msgs, 2);\r\nif (ret < 0)\r\ngoto out;\r\neic[0] = rx[3];\r\neic[1] = rx[4];\r\neic[6] = rx[0];\r\neic[7] = rx[1];\r\nret = snprintf(sht21->eic, sizeof(sht21->eic),\r\n"%02x%02x%02x%02x%02x%02x%02x%02x\n",\r\neic[0], eic[1], eic[2], eic[3],\r\neic[4], eic[5], eic[6], eic[7]);\r\nout:\r\nif (ret < 0)\r\nsht21->eic[0] = 0;\r\nreturn ret;\r\n}\r\nstatic ssize_t eic_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sht21 *sht21 = dev_get_drvdata(dev);\r\nint ret;\r\nret = sizeof(sht21->eic) - 1;\r\nmutex_lock(&sht21->lock);\r\nif (!sht21->eic[0])\r\nret = eic_read(sht21);\r\nif (ret > 0)\r\nmemcpy(buf, sht21->eic, ret);\r\nmutex_unlock(&sht21->lock);\r\nreturn ret;\r\n}\r\nstatic int sht21_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct device *hwmon_dev;\r\nstruct sht21 *sht21;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_WORD_DATA)) {\r\ndev_err(&client->dev,\r\n"adapter does not support SMBus word transactions\n");\r\nreturn -ENODEV;\r\n}\r\nsht21 = devm_kzalloc(dev, sizeof(*sht21), GFP_KERNEL);\r\nif (!sht21)\r\nreturn -ENOMEM;\r\nsht21->client = client;\r\nmutex_init(&sht21->lock);\r\nhwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\r\nsht21, sht21_groups);\r\nreturn PTR_ERR_OR_ZERO(hwmon_dev);\r\n}
