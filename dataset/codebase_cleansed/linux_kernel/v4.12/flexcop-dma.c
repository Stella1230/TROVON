int flexcop_dma_allocate(struct pci_dev *pdev,\r\nstruct flexcop_dma *dma, u32 size)\r\n{\r\nu8 *tcpu;\r\ndma_addr_t tdma = 0;\r\nif (size % 2) {\r\nerr("dma buffersize has to be even.");\r\nreturn -EINVAL;\r\n}\r\nif ((tcpu = pci_alloc_consistent(pdev, size, &tdma)) != NULL) {\r\ndma->pdev = pdev;\r\ndma->cpu_addr0 = tcpu;\r\ndma->dma_addr0 = tdma;\r\ndma->cpu_addr1 = tcpu + size/2;\r\ndma->dma_addr1 = tdma + size/2;\r\ndma->size = size/2;\r\nreturn 0;\r\n}\r\nreturn -ENOMEM;\r\n}\r\nvoid flexcop_dma_free(struct flexcop_dma *dma)\r\n{\r\npci_free_consistent(dma->pdev, dma->size*2,\r\ndma->cpu_addr0, dma->dma_addr0);\r\nmemset(dma,0,sizeof(struct flexcop_dma));\r\n}\r\nint flexcop_dma_config(struct flexcop_device *fc,\r\nstruct flexcop_dma *dma,\r\nflexcop_dma_index_t dma_idx)\r\n{\r\nflexcop_ibi_value v0x0,v0x4,v0xc;\r\nv0x0.raw = v0x4.raw = v0xc.raw = 0;\r\nv0x0.dma_0x0.dma_address0 = dma->dma_addr0 >> 2;\r\nv0xc.dma_0xc.dma_address1 = dma->dma_addr1 >> 2;\r\nv0x4.dma_0x4_write.dma_addr_size = dma->size / 4;\r\nif ((dma_idx & FC_DMA_1) == dma_idx) {\r\nfc->write_ibi_reg(fc,dma1_000,v0x0);\r\nfc->write_ibi_reg(fc,dma1_004,v0x4);\r\nfc->write_ibi_reg(fc,dma1_00c,v0xc);\r\n} else if ((dma_idx & FC_DMA_2) == dma_idx) {\r\nfc->write_ibi_reg(fc,dma2_010,v0x0);\r\nfc->write_ibi_reg(fc,dma2_014,v0x4);\r\nfc->write_ibi_reg(fc,dma2_01c,v0xc);\r\n} else {\r\nerr("either DMA1 or DMA2 can be configured within one flexcop_dma_config call.");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint flexcop_dma_xfer_control(struct flexcop_device *fc,\r\nflexcop_dma_index_t dma_idx,\r\nflexcop_dma_addr_index_t index,\r\nint onoff)\r\n{\r\nflexcop_ibi_value v0x0,v0xc;\r\nflexcop_ibi_register r0x0,r0xc;\r\nif ((dma_idx & FC_DMA_1) == dma_idx) {\r\nr0x0 = dma1_000;\r\nr0xc = dma1_00c;\r\n} else if ((dma_idx & FC_DMA_2) == dma_idx) {\r\nr0x0 = dma2_010;\r\nr0xc = dma2_01c;\r\n} else {\r\nerr("either transfer DMA1 or DMA2 can be started within one flexcop_dma_xfer_control call.");\r\nreturn -EINVAL;\r\n}\r\nv0x0 = fc->read_ibi_reg(fc,r0x0);\r\nv0xc = fc->read_ibi_reg(fc,r0xc);\r\ndeb_rdump("reg: %03x: %x\n",r0x0,v0x0.raw);\r\ndeb_rdump("reg: %03x: %x\n",r0xc,v0xc.raw);\r\nif (index & FC_DMA_SUBADDR_0)\r\nv0x0.dma_0x0.dma_0start = onoff;\r\nif (index & FC_DMA_SUBADDR_1)\r\nv0xc.dma_0xc.dma_1start = onoff;\r\nfc->write_ibi_reg(fc,r0x0,v0x0);\r\nfc->write_ibi_reg(fc,r0xc,v0xc);\r\ndeb_rdump("reg: %03x: %x\n",r0x0,v0x0.raw);\r\ndeb_rdump("reg: %03x: %x\n",r0xc,v0xc.raw);\r\nreturn 0;\r\n}\r\nstatic int flexcop_dma_remap(struct flexcop_device *fc,\r\nflexcop_dma_index_t dma_idx,\r\nint onoff)\r\n{\r\nflexcop_ibi_register r = (dma_idx & FC_DMA_1) ? dma1_00c : dma2_01c;\r\nflexcop_ibi_value v = fc->read_ibi_reg(fc,r);\r\ndeb_info("%s\n",__func__);\r\nv.dma_0xc.remap_enable = onoff;\r\nfc->write_ibi_reg(fc,r,v);\r\nreturn 0;\r\n}\r\nint flexcop_dma_control_size_irq(struct flexcop_device *fc,\r\nflexcop_dma_index_t no,\r\nint onoff)\r\n{\r\nflexcop_ibi_value v = fc->read_ibi_reg(fc,ctrl_208);\r\nif (no & FC_DMA_1)\r\nv.ctrl_208.DMA1_IRQ_Enable_sig = onoff;\r\nif (no & FC_DMA_2)\r\nv.ctrl_208.DMA2_IRQ_Enable_sig = onoff;\r\nfc->write_ibi_reg(fc,ctrl_208,v);\r\nreturn 0;\r\n}\r\nint flexcop_dma_control_timer_irq(struct flexcop_device *fc,\r\nflexcop_dma_index_t no,\r\nint onoff)\r\n{\r\nflexcop_ibi_value v = fc->read_ibi_reg(fc,ctrl_208);\r\nif (no & FC_DMA_1)\r\nv.ctrl_208.DMA1_Timer_Enable_sig = onoff;\r\nif (no & FC_DMA_2)\r\nv.ctrl_208.DMA2_Timer_Enable_sig = onoff;\r\nfc->write_ibi_reg(fc,ctrl_208,v);\r\nreturn 0;\r\n}\r\nint flexcop_dma_config_timer(struct flexcop_device *fc,\r\nflexcop_dma_index_t dma_idx, u8 cycles)\r\n{\r\nflexcop_ibi_register r = (dma_idx & FC_DMA_1) ? dma1_004 : dma2_014;\r\nflexcop_ibi_value v = fc->read_ibi_reg(fc,r);\r\nflexcop_dma_remap(fc,dma_idx,0);\r\ndeb_info("%s\n",__func__);\r\nv.dma_0x4_write.dmatimer = cycles;\r\nfc->write_ibi_reg(fc,r,v);\r\nreturn 0;\r\n}
