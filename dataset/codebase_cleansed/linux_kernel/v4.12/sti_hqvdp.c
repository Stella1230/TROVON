static int sti_hqvdp_get_free_cmd(struct sti_hqvdp *hqvdp)\r\n{\r\nu32 curr_cmd, next_cmd;\r\nu32 cmd = hqvdp->hqvdp_cmd_paddr;\r\nint i;\r\ncurr_cmd = readl(hqvdp->regs + HQVDP_MBX_CURRENT_CMD);\r\nnext_cmd = readl(hqvdp->regs + HQVDP_MBX_NEXT_CMD);\r\nfor (i = 0; i < NB_VDP_CMD; i++) {\r\nif ((cmd != curr_cmd) && (cmd != next_cmd))\r\nreturn i * sizeof(struct sti_hqvdp_cmd);\r\ncmd += sizeof(struct sti_hqvdp_cmd);\r\n}\r\nreturn -1;\r\n}\r\nstatic int sti_hqvdp_get_curr_cmd(struct sti_hqvdp *hqvdp)\r\n{\r\nu32 curr_cmd;\r\nu32 cmd = hqvdp->hqvdp_cmd_paddr;\r\nunsigned int i;\r\ncurr_cmd = readl(hqvdp->regs + HQVDP_MBX_CURRENT_CMD);\r\nfor (i = 0; i < NB_VDP_CMD; i++) {\r\nif (cmd == curr_cmd)\r\nreturn i * sizeof(struct sti_hqvdp_cmd);\r\ncmd += sizeof(struct sti_hqvdp_cmd);\r\n}\r\nreturn -1;\r\n}\r\nstatic int sti_hqvdp_get_next_cmd(struct sti_hqvdp *hqvdp)\r\n{\r\nint next_cmd;\r\ndma_addr_t cmd = hqvdp->hqvdp_cmd_paddr;\r\nunsigned int i;\r\nnext_cmd = readl(hqvdp->regs + HQVDP_MBX_NEXT_CMD);\r\nfor (i = 0; i < NB_VDP_CMD; i++) {\r\nif (cmd == next_cmd)\r\nreturn i * sizeof(struct sti_hqvdp_cmd);\r\ncmd += sizeof(struct sti_hqvdp_cmd);\r\n}\r\nreturn -1;\r\n}\r\nstatic const char *hqvdp_dbg_get_lut(u32 *coef)\r\n{\r\nif (!memcmp(coef, coef_lut_a_legacy, 16))\r\nreturn "LUT A";\r\nif (!memcmp(coef, coef_lut_b, 16))\r\nreturn "LUT B";\r\nif (!memcmp(coef, coef_lut_c_y_legacy, 16))\r\nreturn "LUT C Y";\r\nif (!memcmp(coef, coef_lut_c_c_legacy, 16))\r\nreturn "LUT C C";\r\nif (!memcmp(coef, coef_lut_d_y_legacy, 16))\r\nreturn "LUT D Y";\r\nif (!memcmp(coef, coef_lut_d_c_legacy, 16))\r\nreturn "LUT D C";\r\nif (!memcmp(coef, coef_lut_e_y_legacy, 16))\r\nreturn "LUT E Y";\r\nif (!memcmp(coef, coef_lut_e_c_legacy, 16))\r\nreturn "LUT E C";\r\nif (!memcmp(coef, coef_lut_f_y_legacy, 16))\r\nreturn "LUT F Y";\r\nif (!memcmp(coef, coef_lut_f_c_legacy, 16))\r\nreturn "LUT F C";\r\nreturn "<UNKNOWN>";\r\n}\r\nstatic void hqvdp_dbg_dump_cmd(struct seq_file *s, struct sti_hqvdp_cmd *c)\r\n{\r\nint src_w, src_h, dst_w, dst_h;\r\nseq_puts(s, "\n\tTOP:");\r\nseq_printf(s, "\n\t %-20s 0x%08X", "Config", c->top.config);\r\nswitch (c->top.config) {\r\ncase TOP_CONFIG_PROGRESSIVE:\r\nseq_puts(s, "\tProgressive");\r\nbreak;\r\ncase TOP_CONFIG_INTER_TOP:\r\nseq_puts(s, "\tInterlaced, top field");\r\nbreak;\r\ncase TOP_CONFIG_INTER_BTM:\r\nseq_puts(s, "\tInterlaced, bottom field");\r\nbreak;\r\ndefault:\r\nseq_puts(s, "\t<UNKNOWN>");\r\nbreak;\r\n}\r\nseq_printf(s, "\n\t %-20s 0x%08X", "MemFormat", c->top.mem_format);\r\nseq_printf(s, "\n\t %-20s 0x%08X", "CurrentY", c->top.current_luma);\r\nseq_printf(s, "\n\t %-20s 0x%08X", "CurrentC", c->top.current_chroma);\r\nseq_printf(s, "\n\t %-20s 0x%08X", "YSrcPitch", c->top.luma_src_pitch);\r\nseq_printf(s, "\n\t %-20s 0x%08X", "CSrcPitch",\r\nc->top.chroma_src_pitch);\r\nseq_printf(s, "\n\t %-20s 0x%08X", "InputFrameSize",\r\nc->top.input_frame_size);\r\nseq_printf(s, "\t%dx%d",\r\nc->top.input_frame_size & 0x0000FFFF,\r\nc->top.input_frame_size >> 16);\r\nseq_printf(s, "\n\t %-20s 0x%08X", "InputViewportSize",\r\nc->top.input_viewport_size);\r\nsrc_w = c->top.input_viewport_size & 0x0000FFFF;\r\nsrc_h = c->top.input_viewport_size >> 16;\r\nseq_printf(s, "\t%dx%d", src_w, src_h);\r\nseq_puts(s, "\n\tHVSRC:");\r\nseq_printf(s, "\n\t %-20s 0x%08X", "OutputPictureSize",\r\nc->hvsrc.output_picture_size);\r\ndst_w = c->hvsrc.output_picture_size & 0x0000FFFF;\r\ndst_h = c->hvsrc.output_picture_size >> 16;\r\nseq_printf(s, "\t%dx%d", dst_w, dst_h);\r\nseq_printf(s, "\n\t %-20s 0x%08X", "ParamCtrl", c->hvsrc.param_ctrl);\r\nseq_printf(s, "\n\t %-20s %s", "yh_coef",\r\nhqvdp_dbg_get_lut(c->hvsrc.yh_coef));\r\nseq_printf(s, "\n\t %-20s %s", "ch_coef",\r\nhqvdp_dbg_get_lut(c->hvsrc.ch_coef));\r\nseq_printf(s, "\n\t %-20s %s", "yv_coef",\r\nhqvdp_dbg_get_lut(c->hvsrc.yv_coef));\r\nseq_printf(s, "\n\t %-20s %s", "cv_coef",\r\nhqvdp_dbg_get_lut(c->hvsrc.cv_coef));\r\nseq_printf(s, "\n\t %-20s", "ScaleH");\r\nif (dst_w > src_w)\r\nseq_printf(s, " %d/1", dst_w / src_w);\r\nelse\r\nseq_printf(s, " 1/%d", src_w / dst_w);\r\nseq_printf(s, "\n\t %-20s", "tScaleV");\r\nif (dst_h > src_h)\r\nseq_printf(s, " %d/1", dst_h / src_h);\r\nelse\r\nseq_printf(s, " 1/%d", src_h / dst_h);\r\nseq_puts(s, "\n\tCSDI:");\r\nseq_printf(s, "\n\t %-20s 0x%08X\t", "Config", c->csdi.config);\r\nswitch (c->csdi.config) {\r\ncase CSDI_CONFIG_PROG:\r\nseq_puts(s, "Bypass");\r\nbreak;\r\ncase CSDI_CONFIG_INTER_DIR:\r\nseq_puts(s, "Deinterlace, directional");\r\nbreak;\r\ndefault:\r\nseq_puts(s, "<UNKNOWN>");\r\nbreak;\r\n}\r\nseq_printf(s, "\n\t %-20s 0x%08X", "Config2", c->csdi.config2);\r\nseq_printf(s, "\n\t %-20s 0x%08X", "DcdiConfig", c->csdi.dcdi_config);\r\n}\r\nstatic int hqvdp_dbg_show(struct seq_file *s, void *data)\r\n{\r\nstruct drm_info_node *node = s->private;\r\nstruct sti_hqvdp *hqvdp = (struct sti_hqvdp *)node->info_ent->data;\r\nint cmd, cmd_offset, infoxp70;\r\nvoid *virt;\r\nseq_printf(s, "%s: (vaddr = 0x%p)",\r\nsti_plane_to_str(&hqvdp->plane), hqvdp->regs);\r\nDBGFS_DUMP(HQVDP_MBX_IRQ_TO_XP70);\r\nDBGFS_DUMP(HQVDP_MBX_INFO_HOST);\r\nDBGFS_DUMP(HQVDP_MBX_IRQ_TO_HOST);\r\nDBGFS_DUMP(HQVDP_MBX_INFO_XP70);\r\ninfoxp70 = readl(hqvdp->regs + HQVDP_MBX_INFO_XP70);\r\nseq_puts(s, "\tFirmware state: ");\r\nif (infoxp70 & INFO_XP70_FW_READY)\r\nseq_puts(s, "idle and ready");\r\nelse if (infoxp70 & INFO_XP70_FW_PROCESSING)\r\nseq_puts(s, "processing a picture");\r\nelse if (infoxp70 & INFO_XP70_FW_INITQUEUES)\r\nseq_puts(s, "programming queues");\r\nelse\r\nseq_puts(s, "NOT READY");\r\nDBGFS_DUMP(HQVDP_MBX_SW_RESET_CTRL);\r\nDBGFS_DUMP(HQVDP_MBX_STARTUP_CTRL1);\r\nif (readl(hqvdp->regs + HQVDP_MBX_STARTUP_CTRL1)\r\n& STARTUP_CTRL1_RST_DONE)\r\nseq_puts(s, "\tReset is done");\r\nelse\r\nseq_puts(s, "\tReset is NOT done");\r\nDBGFS_DUMP(HQVDP_MBX_STARTUP_CTRL2);\r\nif (readl(hqvdp->regs + HQVDP_MBX_STARTUP_CTRL2)\r\n& STARTUP_CTRL2_FETCH_EN)\r\nseq_puts(s, "\tFetch is enabled");\r\nelse\r\nseq_puts(s, "\tFetch is NOT enabled");\r\nDBGFS_DUMP(HQVDP_MBX_GP_STATUS);\r\nDBGFS_DUMP(HQVDP_MBX_NEXT_CMD);\r\nDBGFS_DUMP(HQVDP_MBX_CURRENT_CMD);\r\nDBGFS_DUMP(HQVDP_MBX_SOFT_VSYNC);\r\nif (!(readl(hqvdp->regs + HQVDP_MBX_SOFT_VSYNC) & 3))\r\nseq_puts(s, "\tHW Vsync");\r\nelse\r\nseq_puts(s, "\tSW Vsync ?!?!");\r\ncmd = readl(hqvdp->regs + HQVDP_MBX_CURRENT_CMD);\r\ncmd_offset = sti_hqvdp_get_curr_cmd(hqvdp);\r\nif (cmd_offset == -1) {\r\nseq_puts(s, "\n\n Last command: unknown");\r\n} else {\r\nvirt = hqvdp->hqvdp_cmd + cmd_offset;\r\nseq_printf(s, "\n\n Last command: address @ 0x%x (0x%p)",\r\ncmd, virt);\r\nhqvdp_dbg_dump_cmd(s, (struct sti_hqvdp_cmd *)virt);\r\n}\r\ncmd = readl(hqvdp->regs + HQVDP_MBX_NEXT_CMD);\r\ncmd_offset = sti_hqvdp_get_next_cmd(hqvdp);\r\nif (cmd_offset == -1) {\r\nseq_puts(s, "\n\n Next command: unknown");\r\n} else {\r\nvirt = hqvdp->hqvdp_cmd + cmd_offset;\r\nseq_printf(s, "\n\n Next command address: @ 0x%x (0x%p)",\r\ncmd, virt);\r\nhqvdp_dbg_dump_cmd(s, (struct sti_hqvdp_cmd *)virt);\r\n}\r\nseq_puts(s, "\n");\r\nreturn 0;\r\n}\r\nstatic int hqvdp_debugfs_init(struct sti_hqvdp *hqvdp, struct drm_minor *minor)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(hqvdp_debugfs_files); i++)\r\nhqvdp_debugfs_files[i].data = hqvdp;\r\nreturn drm_debugfs_create_files(hqvdp_debugfs_files,\r\nARRAY_SIZE(hqvdp_debugfs_files),\r\nminor->debugfs_root, minor);\r\n}\r\nstatic void sti_hqvdp_update_hvsrc(enum sti_hvsrc_orient orient, int scale,\r\nstruct sti_hqvdp_hvsrc *hvsrc)\r\n{\r\nconst int *coef_c, *coef_y;\r\nint shift_c, shift_y;\r\nif (scale < SCALE_MAX_FOR_LEG_LUT_F) {\r\ncoef_y = coef_lut_f_y_legacy;\r\ncoef_c = coef_lut_f_c_legacy;\r\nshift_y = SHIFT_LUT_F_Y_LEGACY;\r\nshift_c = SHIFT_LUT_F_C_LEGACY;\r\n} else if (scale < SCALE_MAX_FOR_LEG_LUT_E) {\r\ncoef_y = coef_lut_e_y_legacy;\r\ncoef_c = coef_lut_e_c_legacy;\r\nshift_y = SHIFT_LUT_E_Y_LEGACY;\r\nshift_c = SHIFT_LUT_E_C_LEGACY;\r\n} else if (scale < SCALE_MAX_FOR_LEG_LUT_D) {\r\ncoef_y = coef_lut_d_y_legacy;\r\ncoef_c = coef_lut_d_c_legacy;\r\nshift_y = SHIFT_LUT_D_Y_LEGACY;\r\nshift_c = SHIFT_LUT_D_C_LEGACY;\r\n} else if (scale < SCALE_MAX_FOR_LEG_LUT_C) {\r\ncoef_y = coef_lut_c_y_legacy;\r\ncoef_c = coef_lut_c_c_legacy;\r\nshift_y = SHIFT_LUT_C_Y_LEGACY;\r\nshift_c = SHIFT_LUT_C_C_LEGACY;\r\n} else if (scale == SCALE_MAX_FOR_LEG_LUT_C) {\r\ncoef_y = coef_c = coef_lut_b;\r\nshift_y = shift_c = SHIFT_LUT_B;\r\n} else {\r\ncoef_y = coef_c = coef_lut_a_legacy;\r\nshift_y = shift_c = SHIFT_LUT_A_LEGACY;\r\n}\r\nif (orient == HVSRC_HORI) {\r\nhvsrc->hori_shift = (shift_c << 16) | shift_y;\r\nmemcpy(hvsrc->yh_coef, coef_y, sizeof(hvsrc->yh_coef));\r\nmemcpy(hvsrc->ch_coef, coef_c, sizeof(hvsrc->ch_coef));\r\n} else {\r\nhvsrc->vert_shift = (shift_c << 16) | shift_y;\r\nmemcpy(hvsrc->yv_coef, coef_y, sizeof(hvsrc->yv_coef));\r\nmemcpy(hvsrc->cv_coef, coef_c, sizeof(hvsrc->cv_coef));\r\n}\r\n}\r\nstatic bool sti_hqvdp_check_hw_scaling(struct sti_hqvdp *hqvdp,\r\nstruct drm_display_mode *mode,\r\nint src_w, int src_h,\r\nint dst_w, int dst_h)\r\n{\r\nunsigned long lfw;\r\nunsigned int inv_zy;\r\nlfw = mode->htotal * (clk_get_rate(hqvdp->clk) / 1000000);\r\nlfw /= max(src_w, dst_w) * mode->clock / 1000;\r\ninv_zy = DIV_ROUND_UP(src_h, dst_h);\r\nreturn (inv_zy <= lfw) ? true : false;\r\n}\r\nstatic void sti_hqvdp_disable(struct sti_hqvdp *hqvdp)\r\n{\r\nint i;\r\nDRM_DEBUG_DRIVER("%s\n", sti_plane_to_str(&hqvdp->plane));\r\nif (sti_vtg_unregister_client(hqvdp->vtg, &hqvdp->vtg_nb))\r\nDRM_DEBUG_DRIVER("Warning: cannot unregister VTG notifier\n");\r\nwritel(0, hqvdp->regs + HQVDP_MBX_NEXT_CMD);\r\nfor (i = 0; i < POLL_MAX_ATTEMPT; i++) {\r\nif (readl(hqvdp->regs + HQVDP_MBX_INFO_XP70)\r\n& INFO_XP70_FW_READY)\r\nbreak;\r\nmsleep(POLL_DELAY_MS);\r\n}\r\nclk_disable_unprepare(hqvdp->clk_pix_main);\r\nif (i == POLL_MAX_ATTEMPT)\r\nDRM_ERROR("XP70 could not revert to idle\n");\r\nhqvdp->plane.status = STI_PLANE_DISABLED;\r\nhqvdp->vtg_registered = false;\r\n}\r\nstatic int sti_hqvdp_vtg_cb(struct notifier_block *nb, unsigned long evt, void *data)\r\n{\r\nstruct sti_hqvdp *hqvdp = container_of(nb, struct sti_hqvdp, vtg_nb);\r\nint btm_cmd_offset, top_cmd_offest;\r\nstruct sti_hqvdp_cmd *btm_cmd, *top_cmd;\r\nif ((evt != VTG_TOP_FIELD_EVENT) && (evt != VTG_BOTTOM_FIELD_EVENT)) {\r\nDRM_DEBUG_DRIVER("Unknown event\n");\r\nreturn 0;\r\n}\r\nif (hqvdp->plane.status == STI_PLANE_FLUSHING) {\r\nDRM_DEBUG_DRIVER("Vsync event received => disable %s\n",\r\nsti_plane_to_str(&hqvdp->plane));\r\nsti_hqvdp_disable(hqvdp);\r\n}\r\nif (hqvdp->btm_field_pending) {\r\nbtm_cmd_offset = sti_hqvdp_get_free_cmd(hqvdp);\r\ntop_cmd_offest = sti_hqvdp_get_curr_cmd(hqvdp);\r\nif ((btm_cmd_offset == -1) || (top_cmd_offest == -1)) {\r\nDRM_DEBUG_DRIVER("Warning: no cmd, will skip field\n");\r\nreturn -EBUSY;\r\n}\r\nbtm_cmd = hqvdp->hqvdp_cmd + btm_cmd_offset;\r\ntop_cmd = hqvdp->hqvdp_cmd + top_cmd_offest;\r\nmemcpy(btm_cmd, top_cmd, sizeof(*btm_cmd));\r\nbtm_cmd->top.config = TOP_CONFIG_INTER_BTM;\r\nbtm_cmd->top.current_luma +=\r\nbtm_cmd->top.luma_src_pitch / 2;\r\nbtm_cmd->top.current_chroma +=\r\nbtm_cmd->top.chroma_src_pitch / 2;\r\nwritel(hqvdp->hqvdp_cmd_paddr + btm_cmd_offset,\r\nhqvdp->regs + HQVDP_MBX_NEXT_CMD);\r\nhqvdp->btm_field_pending = false;\r\ndev_dbg(hqvdp->dev, "%s Posted command:0x%x\n",\r\n__func__, hqvdp->hqvdp_cmd_paddr);\r\nsti_plane_update_fps(&hqvdp->plane, false, true);\r\n}\r\nreturn 0;\r\n}\r\nstatic void sti_hqvdp_init(struct sti_hqvdp *hqvdp)\r\n{\r\nint size;\r\ndma_addr_t dma_addr;\r\nhqvdp->vtg_nb.notifier_call = sti_hqvdp_vtg_cb;\r\nsize = NB_VDP_CMD * sizeof(struct sti_hqvdp_cmd);\r\nhqvdp->hqvdp_cmd = dma_alloc_wc(hqvdp->dev, size,\r\n&dma_addr,\r\nGFP_KERNEL | GFP_DMA);\r\nif (!hqvdp->hqvdp_cmd) {\r\nDRM_ERROR("Failed to allocate memory for VDP cmd\n");\r\nreturn;\r\n}\r\nhqvdp->hqvdp_cmd_paddr = (u32)dma_addr;\r\nmemset(hqvdp->hqvdp_cmd, 0, size);\r\n}\r\nstatic void sti_hqvdp_init_plugs(struct sti_hqvdp *hqvdp)\r\n{\r\nwritel(PLUG_PAGE_SIZE_256, hqvdp->regs + HQVDP_RD_PLUG_PAGE_SIZE);\r\nwritel(PLUG_MIN_OPC_8, hqvdp->regs + HQVDP_RD_PLUG_MIN_OPC);\r\nwritel(PLUG_MAX_OPC_64, hqvdp->regs + HQVDP_RD_PLUG_MAX_OPC);\r\nwritel(PLUG_MAX_CHK_2X, hqvdp->regs + HQVDP_RD_PLUG_MAX_CHK);\r\nwritel(PLUG_MAX_MSG_1X, hqvdp->regs + HQVDP_RD_PLUG_MAX_MSG);\r\nwritel(PLUG_MIN_SPACE_1, hqvdp->regs + HQVDP_RD_PLUG_MIN_SPACE);\r\nwritel(PLUG_CONTROL_ENABLE, hqvdp->regs + HQVDP_RD_PLUG_CONTROL);\r\nwritel(PLUG_PAGE_SIZE_256, hqvdp->regs + HQVDP_WR_PLUG_PAGE_SIZE);\r\nwritel(PLUG_MIN_OPC_8, hqvdp->regs + HQVDP_WR_PLUG_MIN_OPC);\r\nwritel(PLUG_MAX_OPC_64, hqvdp->regs + HQVDP_WR_PLUG_MAX_OPC);\r\nwritel(PLUG_MAX_CHK_2X, hqvdp->regs + HQVDP_WR_PLUG_MAX_CHK);\r\nwritel(PLUG_MAX_MSG_1X, hqvdp->regs + HQVDP_WR_PLUG_MAX_MSG);\r\nwritel(PLUG_MIN_SPACE_1, hqvdp->regs + HQVDP_WR_PLUG_MIN_SPACE);\r\nwritel(PLUG_CONTROL_ENABLE, hqvdp->regs + HQVDP_WR_PLUG_CONTROL);\r\n}\r\nstatic void sti_hqvdp_start_xp70(struct sti_hqvdp *hqvdp)\r\n{\r\nconst struct firmware *firmware;\r\nu32 *fw_rd_plug, *fw_wr_plug, *fw_pmem, *fw_dmem;\r\nu8 *data;\r\nint i;\r\nstruct fw_header {\r\nint rd_size;\r\nint wr_size;\r\nint pmem_size;\r\nint dmem_size;\r\n} *header;\r\nDRM_DEBUG_DRIVER("\n");\r\nif (hqvdp->xp70_initialized) {\r\nDRM_DEBUG_DRIVER("HQVDP XP70 already initialized\n");\r\nreturn;\r\n}\r\nif (request_firmware(&firmware, HQVDP_FMW_NAME, hqvdp->dev)) {\r\nDRM_ERROR("Can't get HQVDP firmware\n");\r\nreturn;\r\n}\r\nif (!firmware) {\r\nDRM_ERROR("Firmware not available\n");\r\nreturn;\r\n}\r\nheader = (struct fw_header *)firmware->data;\r\nif (firmware->size < sizeof(*header)) {\r\nDRM_ERROR("Invalid firmware size (%d)\n", firmware->size);\r\ngoto out;\r\n}\r\nif ((sizeof(*header) + header->rd_size + header->wr_size +\r\nheader->pmem_size + header->dmem_size) != firmware->size) {\r\nDRM_ERROR("Invalid fmw structure (%d+%d+%d+%d+%d != %d)\n",\r\nsizeof(*header), header->rd_size, header->wr_size,\r\nheader->pmem_size, header->dmem_size,\r\nfirmware->size);\r\ngoto out;\r\n}\r\ndata = (u8 *)firmware->data;\r\ndata += sizeof(*header);\r\nfw_rd_plug = (void *)data;\r\ndata += header->rd_size;\r\nfw_wr_plug = (void *)data;\r\ndata += header->wr_size;\r\nfw_pmem = (void *)data;\r\ndata += header->pmem_size;\r\nfw_dmem = (void *)data;\r\nif (clk_prepare_enable(hqvdp->clk))\r\nDRM_ERROR("Failed to prepare/enable HQVDP clk\n");\r\nwritel(SW_RESET_CTRL_FULL, hqvdp->regs + HQVDP_MBX_SW_RESET_CTRL);\r\nfor (i = 0; i < POLL_MAX_ATTEMPT; i++) {\r\nif (readl(hqvdp->regs + HQVDP_MBX_STARTUP_CTRL1)\r\n& STARTUP_CTRL1_RST_DONE)\r\nbreak;\r\nmsleep(POLL_DELAY_MS);\r\n}\r\nif (i == POLL_MAX_ATTEMPT) {\r\nDRM_ERROR("Could not reset\n");\r\ngoto out;\r\n}\r\nfor (i = 0; i < header->rd_size / 4; i++)\r\nwritel(fw_rd_plug[i], hqvdp->regs + HQVDP_RD_PLUG + i * 4);\r\nfor (i = 0; i < header->wr_size / 4; i++)\r\nwritel(fw_wr_plug[i], hqvdp->regs + HQVDP_WR_PLUG + i * 4);\r\nsti_hqvdp_init_plugs(hqvdp);\r\nwritel(STARTUP_CTRL1_AUTH_IDLE, hqvdp->regs + HQVDP_MBX_STARTUP_CTRL1);\r\nwritel(SOFT_VSYNC_SW_CTRL_IRQ, hqvdp->regs + HQVDP_MBX_SOFT_VSYNC);\r\nwritel(0, hqvdp->regs + HQVDP_MBX_NEXT_CMD);\r\nfor (i = 0; i < header->pmem_size / 4; i++)\r\nwritel(fw_pmem[i], hqvdp->regs + HQVDP_PMEM + i * 4);\r\nfor (i = 0; i < header->dmem_size / 4; i++)\r\nwritel(fw_dmem[i], hqvdp->regs + HQVDP_DMEM + i * 4);\r\nwritel(STARTUP_CTRL2_FETCH_EN, hqvdp->regs + HQVDP_MBX_STARTUP_CTRL2);\r\nfor (i = 0; i < POLL_MAX_ATTEMPT; i++) {\r\nif (readl(hqvdp->regs + HQVDP_MBX_INFO_XP70)\r\n& INFO_XP70_FW_READY)\r\nbreak;\r\nmsleep(POLL_DELAY_MS);\r\n}\r\nif (i == POLL_MAX_ATTEMPT) {\r\nDRM_ERROR("Could not boot\n");\r\ngoto out;\r\n}\r\nwritel(SOFT_VSYNC_HW, hqvdp->regs + HQVDP_MBX_SOFT_VSYNC);\r\nDRM_INFO("HQVDP XP70 initialized\n");\r\nhqvdp->xp70_initialized = true;\r\nout:\r\nrelease_firmware(firmware);\r\n}\r\nstatic int sti_hqvdp_atomic_check(struct drm_plane *drm_plane,\r\nstruct drm_plane_state *state)\r\n{\r\nstruct sti_plane *plane = to_sti_plane(drm_plane);\r\nstruct sti_hqvdp *hqvdp = to_sti_hqvdp(plane);\r\nstruct drm_crtc *crtc = state->crtc;\r\nstruct drm_framebuffer *fb = state->fb;\r\nstruct drm_crtc_state *crtc_state;\r\nstruct drm_display_mode *mode;\r\nint dst_x, dst_y, dst_w, dst_h;\r\nint src_x, src_y, src_w, src_h;\r\nif (!crtc || !fb)\r\nreturn 0;\r\ncrtc_state = drm_atomic_get_crtc_state(state->state, crtc);\r\nmode = &crtc_state->mode;\r\ndst_x = state->crtc_x;\r\ndst_y = state->crtc_y;\r\ndst_w = clamp_val(state->crtc_w, 0, mode->hdisplay - dst_x);\r\ndst_h = clamp_val(state->crtc_h, 0, mode->vdisplay - dst_y);\r\nsrc_x = state->src_x >> 16;\r\nsrc_y = state->src_y >> 16;\r\nsrc_w = state->src_w >> 16;\r\nsrc_h = state->src_h >> 16;\r\nif (mode->clock && !sti_hqvdp_check_hw_scaling(hqvdp, mode,\r\nsrc_w, src_h,\r\ndst_w, dst_h)) {\r\nDRM_ERROR("Scaling beyond HW capabilities\n");\r\nreturn -EINVAL;\r\n}\r\nif (!drm_fb_cma_get_gem_obj(fb, 0)) {\r\nDRM_ERROR("Can't get CMA GEM object for fb\n");\r\nreturn -EINVAL;\r\n}\r\ndst_w = ALIGN(dst_w, 2);\r\ndst_h = ALIGN(dst_h, 2);\r\nif ((src_w > MAX_WIDTH) || (src_w < MIN_WIDTH) ||\r\n(src_h > MAX_HEIGHT) || (src_h < MIN_HEIGHT) ||\r\n(dst_w > MAX_WIDTH) || (dst_w < MIN_WIDTH) ||\r\n(dst_h > MAX_HEIGHT) || (dst_h < MIN_HEIGHT)) {\r\nDRM_ERROR("Invalid in/out size %dx%d -> %dx%d\n",\r\nsrc_w, src_h,\r\ndst_w, dst_h);\r\nreturn -EINVAL;\r\n}\r\nif (!hqvdp->xp70_initialized)\r\nsti_hqvdp_start_xp70(hqvdp);\r\nif (!hqvdp->vtg_registered) {\r\nif (clk_prepare_enable(hqvdp->clk_pix_main)) {\r\nDRM_ERROR("Failed to prepare/enable pix main clk\n");\r\nreturn -EINVAL;\r\n}\r\nif (sti_vtg_register_client(hqvdp->vtg,\r\n&hqvdp->vtg_nb,\r\ncrtc)) {\r\nDRM_ERROR("Cannot register VTG notifier\n");\r\nreturn -EINVAL;\r\n}\r\nhqvdp->vtg_registered = true;\r\n}\r\nDRM_DEBUG_KMS("CRTC:%d (%s) drm plane:%d (%s)\n",\r\ncrtc->base.id, sti_mixer_to_str(to_sti_mixer(crtc)),\r\ndrm_plane->base.id, sti_plane_to_str(plane));\r\nDRM_DEBUG_KMS("%s dst=(%dx%d)@(%d,%d) - src=(%dx%d)@(%d,%d)\n",\r\nsti_plane_to_str(plane),\r\ndst_w, dst_h, dst_x, dst_y,\r\nsrc_w, src_h, src_x, src_y);\r\nreturn 0;\r\n}\r\nstatic void sti_hqvdp_atomic_update(struct drm_plane *drm_plane,\r\nstruct drm_plane_state *oldstate)\r\n{\r\nstruct drm_plane_state *state = drm_plane->state;\r\nstruct sti_plane *plane = to_sti_plane(drm_plane);\r\nstruct sti_hqvdp *hqvdp = to_sti_hqvdp(plane);\r\nstruct drm_crtc *crtc = state->crtc;\r\nstruct drm_framebuffer *fb = state->fb;\r\nstruct drm_display_mode *mode;\r\nint dst_x, dst_y, dst_w, dst_h;\r\nint src_x, src_y, src_w, src_h;\r\nstruct drm_gem_cma_object *cma_obj;\r\nstruct sti_hqvdp_cmd *cmd;\r\nint scale_h, scale_v;\r\nint cmd_offset;\r\nif (!crtc || !fb)\r\nreturn;\r\nif ((oldstate->fb == state->fb) &&\r\n(oldstate->crtc_x == state->crtc_x) &&\r\n(oldstate->crtc_y == state->crtc_y) &&\r\n(oldstate->crtc_w == state->crtc_w) &&\r\n(oldstate->crtc_h == state->crtc_h) &&\r\n(oldstate->src_x == state->src_x) &&\r\n(oldstate->src_y == state->src_y) &&\r\n(oldstate->src_w == state->src_w) &&\r\n(oldstate->src_h == state->src_h)) {\r\nDRM_DEBUG_DRIVER("No change, not posting cmd\n");\r\nplane->status = STI_PLANE_UPDATED;\r\nreturn;\r\n}\r\nmode = &crtc->mode;\r\ndst_x = state->crtc_x;\r\ndst_y = state->crtc_y;\r\ndst_w = clamp_val(state->crtc_w, 0, mode->hdisplay - dst_x);\r\ndst_h = clamp_val(state->crtc_h, 0, mode->vdisplay - dst_y);\r\nsrc_x = state->src_x >> 16;\r\nsrc_y = state->src_y >> 16;\r\nsrc_w = state->src_w >> 16;\r\nsrc_h = state->src_h >> 16;\r\ncmd_offset = sti_hqvdp_get_free_cmd(hqvdp);\r\nif (cmd_offset == -1) {\r\nDRM_DEBUG_DRIVER("Warning: no cmd, will skip frame\n");\r\nreturn;\r\n}\r\ncmd = hqvdp->hqvdp_cmd + cmd_offset;\r\ncmd->top.config = TOP_CONFIG_PROGRESSIVE;\r\ncmd->top.mem_format = TOP_MEM_FORMAT_DFLT;\r\ncmd->hvsrc.param_ctrl = HVSRC_PARAM_CTRL_DFLT;\r\ncmd->csdi.config = CSDI_CONFIG_PROG;\r\ncmd->iqi.config = IQI_CONFIG_DFLT;\r\ncmd->iqi.con_bri = IQI_CON_BRI_DFLT;\r\ncmd->iqi.sat_gain = IQI_SAT_GAIN_DFLT;\r\ncmd->iqi.pxf_conf = IQI_PXF_CONF_DFLT;\r\ncma_obj = drm_fb_cma_get_gem_obj(fb, 0);\r\nDRM_DEBUG_DRIVER("drm FB:%d format:%.4s phys@:0x%lx\n", fb->base.id,\r\n(char *)&fb->format->format,\r\n(unsigned long)cma_obj->paddr);\r\ncmd->top.current_luma = (u32)cma_obj->paddr + fb->offsets[0];\r\ncmd->top.current_chroma = (u32)cma_obj->paddr + fb->offsets[1];\r\ncmd->top.luma_processed_pitch = fb->pitches[0];\r\ncmd->top.luma_src_pitch = fb->pitches[0];\r\ncmd->top.chroma_processed_pitch = fb->pitches[1];\r\ncmd->top.chroma_src_pitch = fb->pitches[1];\r\ndst_w = ALIGN(dst_w, 2);\r\ndst_h = ALIGN(dst_h, 2);\r\ncmd->top.input_viewport_size = src_h << 16 | src_w;\r\ncmd->top.input_frame_size = src_h << 16 | src_w;\r\ncmd->hvsrc.output_picture_size = dst_h << 16 | dst_w;\r\ncmd->top.input_viewport_ori = src_y << 16 | src_x;\r\nif (fb->flags & DRM_MODE_FB_INTERLACED) {\r\ncmd->top.config = TOP_CONFIG_INTER_TOP;\r\ncmd->top.input_frame_size = (src_h / 2) << 16 | src_w;\r\ncmd->top.luma_processed_pitch *= 2;\r\ncmd->top.luma_src_pitch *= 2;\r\ncmd->top.chroma_processed_pitch *= 2;\r\ncmd->top.chroma_src_pitch *= 2;\r\ncmd->csdi.config = CSDI_CONFIG_INTER_DIR;\r\ncmd->csdi.config2 = CSDI_CONFIG2_DFLT;\r\ncmd->csdi.dcdi_config = CSDI_DCDI_CONFIG_DFLT;\r\n}\r\nscale_h = SCALE_FACTOR * dst_w / src_w;\r\nsti_hqvdp_update_hvsrc(HVSRC_HORI, scale_h, &cmd->hvsrc);\r\nscale_v = SCALE_FACTOR * dst_h / src_h;\r\nsti_hqvdp_update_hvsrc(HVSRC_VERT, scale_v, &cmd->hvsrc);\r\nwritel(hqvdp->hqvdp_cmd_paddr + cmd_offset,\r\nhqvdp->regs + HQVDP_MBX_NEXT_CMD);\r\nif (fb->flags & DRM_MODE_FB_INTERLACED)\r\nhqvdp->btm_field_pending = true;\r\ndev_dbg(hqvdp->dev, "%s Posted command:0x%x\n",\r\n__func__, hqvdp->hqvdp_cmd_paddr + cmd_offset);\r\nsti_plane_update_fps(plane, true, true);\r\nplane->status = STI_PLANE_UPDATED;\r\n}\r\nstatic void sti_hqvdp_atomic_disable(struct drm_plane *drm_plane,\r\nstruct drm_plane_state *oldstate)\r\n{\r\nstruct sti_plane *plane = to_sti_plane(drm_plane);\r\nif (!oldstate->crtc) {\r\nDRM_DEBUG_DRIVER("drm plane:%d not enabled\n",\r\ndrm_plane->base.id);\r\nreturn;\r\n}\r\nDRM_DEBUG_DRIVER("CRTC:%d (%s) drm plane:%d (%s)\n",\r\noldstate->crtc->base.id,\r\nsti_mixer_to_str(to_sti_mixer(oldstate->crtc)),\r\ndrm_plane->base.id, sti_plane_to_str(plane));\r\nplane->status = STI_PLANE_DISABLING;\r\n}\r\nstatic void sti_hqvdp_destroy(struct drm_plane *drm_plane)\r\n{\r\nDRM_DEBUG_DRIVER("\n");\r\ndrm_plane_helper_disable(drm_plane);\r\ndrm_plane_cleanup(drm_plane);\r\n}\r\nstatic int sti_hqvdp_late_register(struct drm_plane *drm_plane)\r\n{\r\nstruct sti_plane *plane = to_sti_plane(drm_plane);\r\nstruct sti_hqvdp *hqvdp = to_sti_hqvdp(plane);\r\nreturn hqvdp_debugfs_init(hqvdp, drm_plane->dev->primary);\r\n}\r\nstatic struct drm_plane *sti_hqvdp_create(struct drm_device *drm_dev,\r\nstruct device *dev, int desc)\r\n{\r\nstruct sti_hqvdp *hqvdp = dev_get_drvdata(dev);\r\nint res;\r\nhqvdp->plane.desc = desc;\r\nhqvdp->plane.status = STI_PLANE_DISABLED;\r\nsti_hqvdp_init(hqvdp);\r\nres = drm_universal_plane_init(drm_dev, &hqvdp->plane.drm_plane, 1,\r\n&sti_hqvdp_plane_helpers_funcs,\r\nhqvdp_supported_formats,\r\nARRAY_SIZE(hqvdp_supported_formats),\r\nDRM_PLANE_TYPE_OVERLAY, NULL);\r\nif (res) {\r\nDRM_ERROR("Failed to initialize universal plane\n");\r\nreturn NULL;\r\n}\r\ndrm_plane_helper_add(&hqvdp->plane.drm_plane, &sti_hqvdp_helpers_funcs);\r\nsti_plane_init_property(&hqvdp->plane, DRM_PLANE_TYPE_OVERLAY);\r\nreturn &hqvdp->plane.drm_plane;\r\n}\r\nstatic int sti_hqvdp_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct sti_hqvdp *hqvdp = dev_get_drvdata(dev);\r\nstruct drm_device *drm_dev = data;\r\nstruct drm_plane *plane;\r\nDRM_DEBUG_DRIVER("\n");\r\nhqvdp->drm_dev = drm_dev;\r\nplane = sti_hqvdp_create(drm_dev, hqvdp->dev, STI_HQVDP_0);\r\nif (!plane)\r\nDRM_ERROR("Can't create HQVDP plane\n");\r\nreturn 0;\r\n}\r\nstatic void sti_hqvdp_unbind(struct device *dev,\r\nstruct device *master, void *data)\r\n{\r\n}\r\nstatic int sti_hqvdp_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *vtg_np;\r\nstruct sti_hqvdp *hqvdp;\r\nstruct resource *res;\r\nDRM_DEBUG_DRIVER("\n");\r\nhqvdp = devm_kzalloc(dev, sizeof(*hqvdp), GFP_KERNEL);\r\nif (!hqvdp) {\r\nDRM_ERROR("Failed to allocate HQVDP context\n");\r\nreturn -ENOMEM;\r\n}\r\nhqvdp->dev = dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\nDRM_ERROR("Get memory resource failed\n");\r\nreturn -ENXIO;\r\n}\r\nhqvdp->regs = devm_ioremap(dev, res->start, resource_size(res));\r\nif (hqvdp->regs == NULL) {\r\nDRM_ERROR("Register mapping failed\n");\r\nreturn -ENXIO;\r\n}\r\nhqvdp->clk = devm_clk_get(dev, "hqvdp");\r\nhqvdp->clk_pix_main = devm_clk_get(dev, "pix_main");\r\nif (IS_ERR(hqvdp->clk) || IS_ERR(hqvdp->clk_pix_main)) {\r\nDRM_ERROR("Cannot get clocks\n");\r\nreturn -ENXIO;\r\n}\r\nhqvdp->reset = devm_reset_control_get(dev, "hqvdp");\r\nif (!IS_ERR(hqvdp->reset))\r\nreset_control_deassert(hqvdp->reset);\r\nvtg_np = of_parse_phandle(pdev->dev.of_node, "st,vtg", 0);\r\nif (vtg_np)\r\nhqvdp->vtg = of_vtg_find(vtg_np);\r\nof_node_put(vtg_np);\r\nplatform_set_drvdata(pdev, hqvdp);\r\nreturn component_add(&pdev->dev, &sti_hqvdp_ops);\r\n}\r\nstatic int sti_hqvdp_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &sti_hqvdp_ops);\r\nreturn 0;\r\n}
