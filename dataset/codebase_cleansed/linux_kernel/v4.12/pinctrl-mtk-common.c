static struct regmap *mtk_get_regmap(struct mtk_pinctrl *pctl,\r\nunsigned long pin)\r\n{\r\nif (pin >= pctl->devdata->type1_start && pin < pctl->devdata->type1_end)\r\nreturn pctl->regmap2;\r\nreturn pctl->regmap1;\r\n}\r\nstatic unsigned int mtk_get_port(struct mtk_pinctrl *pctl, unsigned long pin)\r\n{\r\nreturn ((pin >> 4) & pctl->devdata->port_mask)\r\n<< pctl->devdata->port_shf;\r\n}\r\nstatic int mtk_pmx_gpio_set_direction(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range, unsigned offset,\r\nbool input)\r\n{\r\nunsigned int reg_addr;\r\nunsigned int bit;\r\nstruct mtk_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nreg_addr = mtk_get_port(pctl, offset) + pctl->devdata->dir_offset;\r\nbit = BIT(offset & 0xf);\r\nif (pctl->devdata->spec_dir_set)\r\npctl->devdata->spec_dir_set(&reg_addr, offset);\r\nif (input)\r\nreg_addr = CLR_ADDR(reg_addr, pctl);\r\nelse\r\nreg_addr = SET_ADDR(reg_addr, pctl);\r\nregmap_write(mtk_get_regmap(pctl, offset), reg_addr, bit);\r\nreturn 0;\r\n}\r\nstatic void mtk_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nunsigned int reg_addr;\r\nunsigned int bit;\r\nstruct mtk_pinctrl *pctl = gpiochip_get_data(chip);\r\nreg_addr = mtk_get_port(pctl, offset) + pctl->devdata->dout_offset;\r\nbit = BIT(offset & 0xf);\r\nif (value)\r\nreg_addr = SET_ADDR(reg_addr, pctl);\r\nelse\r\nreg_addr = CLR_ADDR(reg_addr, pctl);\r\nregmap_write(mtk_get_regmap(pctl, offset), reg_addr, bit);\r\n}\r\nstatic int mtk_pconf_set_ies_smt(struct mtk_pinctrl *pctl, unsigned pin,\r\nint value, enum pin_config_param arg)\r\n{\r\nunsigned int reg_addr, offset;\r\nunsigned int bit;\r\nif (!pctl->devdata->spec_ies_smt_set &&\r\npctl->devdata->ies_offset == MTK_PINCTRL_NOT_SUPPORT &&\r\narg == PIN_CONFIG_INPUT_ENABLE)\r\nreturn -EINVAL;\r\nif (!pctl->devdata->spec_ies_smt_set &&\r\npctl->devdata->smt_offset == MTK_PINCTRL_NOT_SUPPORT &&\r\narg == PIN_CONFIG_INPUT_SCHMITT_ENABLE)\r\nreturn -EINVAL;\r\nif (pctl->devdata->spec_ies_smt_set) {\r\nreturn pctl->devdata->spec_ies_smt_set(mtk_get_regmap(pctl, pin),\r\npin, pctl->devdata->port_align, value, arg);\r\n}\r\nbit = BIT(pin & 0xf);\r\nif (arg == PIN_CONFIG_INPUT_ENABLE)\r\noffset = pctl->devdata->ies_offset;\r\nelse\r\noffset = pctl->devdata->smt_offset;\r\nif (value)\r\nreg_addr = SET_ADDR(mtk_get_port(pctl, pin) + offset, pctl);\r\nelse\r\nreg_addr = CLR_ADDR(mtk_get_port(pctl, pin) + offset, pctl);\r\nregmap_write(mtk_get_regmap(pctl, pin), reg_addr, bit);\r\nreturn 0;\r\n}\r\nint mtk_pconf_spec_set_ies_smt_range(struct regmap *regmap,\r\nconst struct mtk_pin_ies_smt_set *ies_smt_infos, unsigned int info_num,\r\nunsigned int pin, unsigned char align, int value)\r\n{\r\nunsigned int i, reg_addr, bit;\r\nfor (i = 0; i < info_num; i++) {\r\nif (pin >= ies_smt_infos[i].start &&\r\npin <= ies_smt_infos[i].end) {\r\nbreak;\r\n}\r\n}\r\nif (i == info_num)\r\nreturn -EINVAL;\r\nif (value)\r\nreg_addr = ies_smt_infos[i].offset + align;\r\nelse\r\nreg_addr = ies_smt_infos[i].offset + (align << 1);\r\nbit = BIT(ies_smt_infos[i].bit);\r\nregmap_write(regmap, reg_addr, bit);\r\nreturn 0;\r\n}\r\nstatic const struct mtk_pin_drv_grp *mtk_find_pin_drv_grp_by_pin(\r\nstruct mtk_pinctrl *pctl, unsigned long pin) {\r\nint i;\r\nfor (i = 0; i < pctl->devdata->n_pin_drv_grps; i++) {\r\nconst struct mtk_pin_drv_grp *pin_drv =\r\npctl->devdata->pin_drv_grp + i;\r\nif (pin == pin_drv->pin)\r\nreturn pin_drv;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int mtk_pconf_set_driving(struct mtk_pinctrl *pctl,\r\nunsigned int pin, unsigned char driving)\r\n{\r\nconst struct mtk_pin_drv_grp *pin_drv;\r\nunsigned int val;\r\nunsigned int bits, mask, shift;\r\nconst struct mtk_drv_group_desc *drv_grp;\r\nif (pin >= pctl->devdata->npins)\r\nreturn -EINVAL;\r\npin_drv = mtk_find_pin_drv_grp_by_pin(pctl, pin);\r\nif (!pin_drv || pin_drv->grp > pctl->devdata->n_grp_cls)\r\nreturn -EINVAL;\r\ndrv_grp = pctl->devdata->grp_desc + pin_drv->grp;\r\nif (driving >= drv_grp->min_drv && driving <= drv_grp->max_drv\r\n&& !(driving % drv_grp->step)) {\r\nval = driving / drv_grp->step - 1;\r\nbits = drv_grp->high_bit - drv_grp->low_bit + 1;\r\nmask = BIT(bits) - 1;\r\nshift = pin_drv->bit + drv_grp->low_bit;\r\nmask <<= shift;\r\nval <<= shift;\r\nreturn regmap_update_bits(mtk_get_regmap(pctl, pin),\r\npin_drv->offset, mask, val);\r\n}\r\nreturn -EINVAL;\r\n}\r\nint mtk_pctrl_spec_pull_set_samereg(struct regmap *regmap,\r\nconst struct mtk_pin_spec_pupd_set_samereg *pupd_infos,\r\nunsigned int info_num, unsigned int pin,\r\nunsigned char align, bool isup, unsigned int r1r0)\r\n{\r\nunsigned int i;\r\nunsigned int reg_pupd, reg_set, reg_rst;\r\nunsigned int bit_pupd, bit_r0, bit_r1;\r\nconst struct mtk_pin_spec_pupd_set_samereg *spec_pupd_pin;\r\nbool find = false;\r\nfor (i = 0; i < info_num; i++) {\r\nif (pin == pupd_infos[i].pin) {\r\nfind = true;\r\nbreak;\r\n}\r\n}\r\nif (!find)\r\nreturn -EINVAL;\r\nspec_pupd_pin = pupd_infos + i;\r\nreg_set = spec_pupd_pin->offset + align;\r\nreg_rst = spec_pupd_pin->offset + (align << 1);\r\nif (isup)\r\nreg_pupd = reg_rst;\r\nelse\r\nreg_pupd = reg_set;\r\nbit_pupd = BIT(spec_pupd_pin->pupd_bit);\r\nregmap_write(regmap, reg_pupd, bit_pupd);\r\nbit_r0 = BIT(spec_pupd_pin->r0_bit);\r\nbit_r1 = BIT(spec_pupd_pin->r1_bit);\r\nswitch (r1r0) {\r\ncase MTK_PUPD_SET_R1R0_00:\r\nregmap_write(regmap, reg_rst, bit_r0);\r\nregmap_write(regmap, reg_rst, bit_r1);\r\nbreak;\r\ncase MTK_PUPD_SET_R1R0_01:\r\nregmap_write(regmap, reg_set, bit_r0);\r\nregmap_write(regmap, reg_rst, bit_r1);\r\nbreak;\r\ncase MTK_PUPD_SET_R1R0_10:\r\nregmap_write(regmap, reg_rst, bit_r0);\r\nregmap_write(regmap, reg_set, bit_r1);\r\nbreak;\r\ncase MTK_PUPD_SET_R1R0_11:\r\nregmap_write(regmap, reg_set, bit_r0);\r\nregmap_write(regmap, reg_set, bit_r1);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mtk_pconf_set_pull_select(struct mtk_pinctrl *pctl,\r\nunsigned int pin, bool enable, bool isup, unsigned int arg)\r\n{\r\nunsigned int bit;\r\nunsigned int reg_pullen, reg_pullsel;\r\nint ret;\r\nif (pctl->devdata->spec_pull_set) {\r\nret = pctl->devdata->spec_pull_set(mtk_get_regmap(pctl, pin),\r\npin, pctl->devdata->port_align, isup, arg);\r\nif (!ret)\r\nreturn 0;\r\n}\r\nif (arg != 0 && arg != 1) {\r\ndev_err(pctl->dev, "invalid pull-up argument %d on pin %d .\n",\r\narg, pin);\r\nreturn -EINVAL;\r\n}\r\nbit = BIT(pin & 0xf);\r\nif (enable)\r\nreg_pullen = SET_ADDR(mtk_get_port(pctl, pin) +\r\npctl->devdata->pullen_offset, pctl);\r\nelse\r\nreg_pullen = CLR_ADDR(mtk_get_port(pctl, pin) +\r\npctl->devdata->pullen_offset, pctl);\r\nif (isup)\r\nreg_pullsel = SET_ADDR(mtk_get_port(pctl, pin) +\r\npctl->devdata->pullsel_offset, pctl);\r\nelse\r\nreg_pullsel = CLR_ADDR(mtk_get_port(pctl, pin) +\r\npctl->devdata->pullsel_offset, pctl);\r\nregmap_write(mtk_get_regmap(pctl, pin), reg_pullen, bit);\r\nregmap_write(mtk_get_regmap(pctl, pin), reg_pullsel, bit);\r\nreturn 0;\r\n}\r\nstatic int mtk_pconf_parse_conf(struct pinctrl_dev *pctldev,\r\nunsigned int pin, enum pin_config_param param,\r\nenum pin_config_param arg)\r\n{\r\nint ret = 0;\r\nstruct mtk_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nret = mtk_pconf_set_pull_select(pctl, pin, false, false, arg);\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nret = mtk_pconf_set_pull_select(pctl, pin, true, true, arg);\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nret = mtk_pconf_set_pull_select(pctl, pin, true, false, arg);\r\nbreak;\r\ncase PIN_CONFIG_INPUT_ENABLE:\r\nmtk_pmx_gpio_set_direction(pctldev, NULL, pin, true);\r\nret = mtk_pconf_set_ies_smt(pctl, pin, arg, param);\r\nbreak;\r\ncase PIN_CONFIG_OUTPUT:\r\nmtk_gpio_set(pctl->chip, pin, arg);\r\nret = mtk_pmx_gpio_set_direction(pctldev, NULL, pin, false);\r\nbreak;\r\ncase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\r\nmtk_pmx_gpio_set_direction(pctldev, NULL, pin, true);\r\nret = mtk_pconf_set_ies_smt(pctl, pin, arg, param);\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\nret = mtk_pconf_set_driving(pctl, pin, arg);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int mtk_pconf_group_get(struct pinctrl_dev *pctldev,\r\nunsigned group,\r\nunsigned long *config)\r\n{\r\nstruct mtk_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\n*config = pctl->groups[group].config;\r\nreturn 0;\r\n}\r\nstatic int mtk_pconf_group_set(struct pinctrl_dev *pctldev, unsigned group,\r\nunsigned long *configs, unsigned num_configs)\r\n{\r\nstruct mtk_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct mtk_pinctrl_group *g = &pctl->groups[group];\r\nint i, ret;\r\nfor (i = 0; i < num_configs; i++) {\r\nret = mtk_pconf_parse_conf(pctldev, g->pin,\r\npinconf_to_config_param(configs[i]),\r\npinconf_to_config_argument(configs[i]));\r\nif (ret < 0)\r\nreturn ret;\r\ng->config = configs[i];\r\n}\r\nreturn 0;\r\n}\r\nstatic struct mtk_pinctrl_group *\r\nmtk_pctrl_find_group_by_pin(struct mtk_pinctrl *pctl, u32 pin)\r\n{\r\nint i;\r\nfor (i = 0; i < pctl->ngroups; i++) {\r\nstruct mtk_pinctrl_group *grp = pctl->groups + i;\r\nif (grp->pin == pin)\r\nreturn grp;\r\n}\r\nreturn NULL;\r\n}\r\nstatic const struct mtk_desc_function *mtk_pctrl_find_function_by_pin(\r\nstruct mtk_pinctrl *pctl, u32 pin_num, u32 fnum)\r\n{\r\nconst struct mtk_desc_pin *pin = pctl->devdata->pins + pin_num;\r\nconst struct mtk_desc_function *func = pin->functions;\r\nwhile (func && func->name) {\r\nif (func->muxval == fnum)\r\nreturn func;\r\nfunc++;\r\n}\r\nreturn NULL;\r\n}\r\nstatic bool mtk_pctrl_is_function_valid(struct mtk_pinctrl *pctl,\r\nu32 pin_num, u32 fnum)\r\n{\r\nint i;\r\nfor (i = 0; i < pctl->devdata->npins; i++) {\r\nconst struct mtk_desc_pin *pin = pctl->devdata->pins + i;\r\nif (pin->pin.number == pin_num) {\r\nconst struct mtk_desc_function *func =\r\npin->functions;\r\nwhile (func && func->name) {\r\nif (func->muxval == fnum)\r\nreturn true;\r\nfunc++;\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic int mtk_pctrl_dt_node_to_map_func(struct mtk_pinctrl *pctl,\r\nu32 pin, u32 fnum, struct mtk_pinctrl_group *grp,\r\nstruct pinctrl_map **map, unsigned *reserved_maps,\r\nunsigned *num_maps)\r\n{\r\nbool ret;\r\nif (*num_maps == *reserved_maps)\r\nreturn -ENOSPC;\r\n(*map)[*num_maps].type = PIN_MAP_TYPE_MUX_GROUP;\r\n(*map)[*num_maps].data.mux.group = grp->name;\r\nret = mtk_pctrl_is_function_valid(pctl, pin, fnum);\r\nif (!ret) {\r\ndev_err(pctl->dev, "invalid function %d on pin %d .\n",\r\nfnum, pin);\r\nreturn -EINVAL;\r\n}\r\n(*map)[*num_maps].data.mux.function = mtk_gpio_functions[fnum];\r\n(*num_maps)++;\r\nreturn 0;\r\n}\r\nstatic int mtk_pctrl_dt_subnode_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *node,\r\nstruct pinctrl_map **map,\r\nunsigned *reserved_maps,\r\nunsigned *num_maps)\r\n{\r\nstruct property *pins;\r\nu32 pinfunc, pin, func;\r\nint num_pins, num_funcs, maps_per_pin;\r\nunsigned long *configs;\r\nunsigned int num_configs;\r\nbool has_config = 0;\r\nint i, err;\r\nunsigned reserve = 0;\r\nstruct mtk_pinctrl_group *grp;\r\nstruct mtk_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\npins = of_find_property(node, "pinmux", NULL);\r\nif (!pins) {\r\ndev_err(pctl->dev, "missing pins property in node %s .\n",\r\nnode->name);\r\nreturn -EINVAL;\r\n}\r\nerr = pinconf_generic_parse_dt_config(node, pctldev, &configs,\r\n&num_configs);\r\nif (err)\r\nreturn err;\r\nif (num_configs)\r\nhas_config = 1;\r\nnum_pins = pins->length / sizeof(u32);\r\nnum_funcs = num_pins;\r\nmaps_per_pin = 0;\r\nif (num_funcs)\r\nmaps_per_pin++;\r\nif (has_config && num_pins >= 1)\r\nmaps_per_pin++;\r\nif (!num_pins || !maps_per_pin) {\r\nerr = -EINVAL;\r\ngoto exit;\r\n}\r\nreserve = num_pins * maps_per_pin;\r\nerr = pinctrl_utils_reserve_map(pctldev, map,\r\nreserved_maps, num_maps, reserve);\r\nif (err < 0)\r\ngoto exit;\r\nfor (i = 0; i < num_pins; i++) {\r\nerr = of_property_read_u32_index(node, "pinmux",\r\ni, &pinfunc);\r\nif (err)\r\ngoto exit;\r\npin = MTK_GET_PIN_NO(pinfunc);\r\nfunc = MTK_GET_PIN_FUNC(pinfunc);\r\nif (pin >= pctl->devdata->npins ||\r\nfunc >= ARRAY_SIZE(mtk_gpio_functions)) {\r\ndev_err(pctl->dev, "invalid pins value.\n");\r\nerr = -EINVAL;\r\ngoto exit;\r\n}\r\ngrp = mtk_pctrl_find_group_by_pin(pctl, pin);\r\nif (!grp) {\r\ndev_err(pctl->dev, "unable to match pin %d to group\n",\r\npin);\r\nerr = -EINVAL;\r\ngoto exit;\r\n}\r\nerr = mtk_pctrl_dt_node_to_map_func(pctl, pin, func, grp, map,\r\nreserved_maps, num_maps);\r\nif (err < 0)\r\ngoto exit;\r\nif (has_config) {\r\nerr = pinctrl_utils_add_map_configs(pctldev, map,\r\nreserved_maps, num_maps, grp->name,\r\nconfigs, num_configs,\r\nPIN_MAP_TYPE_CONFIGS_GROUP);\r\nif (err < 0)\r\ngoto exit;\r\n}\r\n}\r\nerr = 0;\r\nexit:\r\nkfree(configs);\r\nreturn err;\r\n}\r\nstatic int mtk_pctrl_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np_config,\r\nstruct pinctrl_map **map, unsigned *num_maps)\r\n{\r\nstruct device_node *np;\r\nunsigned reserved_maps;\r\nint ret;\r\n*map = NULL;\r\n*num_maps = 0;\r\nreserved_maps = 0;\r\nfor_each_child_of_node(np_config, np) {\r\nret = mtk_pctrl_dt_subnode_to_map(pctldev, np, map,\r\n&reserved_maps, num_maps);\r\nif (ret < 0) {\r\npinctrl_utils_free_map(pctldev, *map, *num_maps);\r\nof_node_put(np);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mtk_pctrl_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct mtk_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctl->ngroups;\r\n}\r\nstatic const char *mtk_pctrl_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned group)\r\n{\r\nstruct mtk_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctl->groups[group].name;\r\n}\r\nstatic int mtk_pctrl_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned group,\r\nconst unsigned **pins,\r\nunsigned *num_pins)\r\n{\r\nstruct mtk_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = (unsigned *)&pctl->groups[group].pin;\r\n*num_pins = 1;\r\nreturn 0;\r\n}\r\nstatic int mtk_pmx_get_funcs_cnt(struct pinctrl_dev *pctldev)\r\n{\r\nreturn ARRAY_SIZE(mtk_gpio_functions);\r\n}\r\nstatic const char *mtk_pmx_get_func_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nreturn mtk_gpio_functions[selector];\r\n}\r\nstatic int mtk_pmx_get_func_groups(struct pinctrl_dev *pctldev,\r\nunsigned function,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct mtk_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = pctl->grp_names;\r\n*num_groups = pctl->ngroups;\r\nreturn 0;\r\n}\r\nstatic int mtk_pmx_set_mode(struct pinctrl_dev *pctldev,\r\nunsigned long pin, unsigned long mode)\r\n{\r\nunsigned int reg_addr;\r\nunsigned char bit;\r\nunsigned int val;\r\nunsigned int mask = (1L << GPIO_MODE_BITS) - 1;\r\nstruct mtk_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nif (pctl->devdata->spec_pinmux_set)\r\npctl->devdata->spec_pinmux_set(mtk_get_regmap(pctl, pin),\r\npin, mode);\r\nreg_addr = ((pin / MAX_GPIO_MODE_PER_REG) << pctl->devdata->port_shf)\r\n+ pctl->devdata->pinmux_offset;\r\nmode &= mask;\r\nbit = pin % MAX_GPIO_MODE_PER_REG;\r\nmask <<= (GPIO_MODE_BITS * bit);\r\nval = (mode << (GPIO_MODE_BITS * bit));\r\nreturn regmap_update_bits(mtk_get_regmap(pctl, pin),\r\nreg_addr, mask, val);\r\n}\r\nstatic const struct mtk_desc_pin *\r\nmtk_find_pin_by_eint_num(struct mtk_pinctrl *pctl, unsigned int eint_num)\r\n{\r\nint i;\r\nconst struct mtk_desc_pin *pin;\r\nfor (i = 0; i < pctl->devdata->npins; i++) {\r\npin = pctl->devdata->pins + i;\r\nif (pin->eint.eintnum == eint_num)\r\nreturn pin;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int mtk_pmx_set_mux(struct pinctrl_dev *pctldev,\r\nunsigned function,\r\nunsigned group)\r\n{\r\nbool ret;\r\nconst struct mtk_desc_function *desc;\r\nstruct mtk_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct mtk_pinctrl_group *g = pctl->groups + group;\r\nret = mtk_pctrl_is_function_valid(pctl, g->pin, function);\r\nif (!ret) {\r\ndev_err(pctl->dev, "invalid function %d on group %d .\n",\r\nfunction, group);\r\nreturn -EINVAL;\r\n}\r\ndesc = mtk_pctrl_find_function_by_pin(pctl, g->pin, function);\r\nif (!desc)\r\nreturn -EINVAL;\r\nmtk_pmx_set_mode(pctldev, g->pin, desc->muxval);\r\nreturn 0;\r\n}\r\nstatic int mtk_pmx_find_gpio_mode(struct mtk_pinctrl *pctl,\r\nunsigned offset)\r\n{\r\nconst struct mtk_desc_pin *pin = pctl->devdata->pins + offset;\r\nconst struct mtk_desc_function *func = pin->functions;\r\nwhile (func && func->name) {\r\nif (!strncmp(func->name, GPIO_MODE_PREFIX,\r\nsizeof(GPIO_MODE_PREFIX)-1))\r\nreturn func->muxval;\r\nfunc++;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int mtk_pmx_gpio_request_enable(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset)\r\n{\r\nint muxval;\r\nstruct mtk_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\r\nmuxval = mtk_pmx_find_gpio_mode(pctl, offset);\r\nif (muxval < 0) {\r\ndev_err(pctl->dev, "invalid gpio pin %d.\n", offset);\r\nreturn -EINVAL;\r\n}\r\nmtk_pmx_set_mode(pctldev, offset, muxval);\r\nmtk_pconf_set_ies_smt(pctl, offset, 1, PIN_CONFIG_INPUT_ENABLE);\r\nreturn 0;\r\n}\r\nstatic int mtk_gpio_direction_input(struct gpio_chip *chip,\r\nunsigned offset)\r\n{\r\nreturn pinctrl_gpio_direction_input(chip->base + offset);\r\n}\r\nstatic int mtk_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nmtk_gpio_set(chip, offset, value);\r\nreturn pinctrl_gpio_direction_output(chip->base + offset);\r\n}\r\nstatic int mtk_gpio_get_direction(struct gpio_chip *chip, unsigned offset)\r\n{\r\nunsigned int reg_addr;\r\nunsigned int bit;\r\nunsigned int read_val = 0;\r\nstruct mtk_pinctrl *pctl = gpiochip_get_data(chip);\r\nreg_addr = mtk_get_port(pctl, offset) + pctl->devdata->dir_offset;\r\nbit = BIT(offset & 0xf);\r\nif (pctl->devdata->spec_dir_set)\r\npctl->devdata->spec_dir_set(&reg_addr, offset);\r\nregmap_read(pctl->regmap1, reg_addr, &read_val);\r\nreturn !(read_val & bit);\r\n}\r\nstatic int mtk_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nunsigned int reg_addr;\r\nunsigned int bit;\r\nunsigned int read_val = 0;\r\nstruct mtk_pinctrl *pctl = gpiochip_get_data(chip);\r\nreg_addr = mtk_get_port(pctl, offset) +\r\npctl->devdata->din_offset;\r\nbit = BIT(offset & 0xf);\r\nregmap_read(pctl->regmap1, reg_addr, &read_val);\r\nreturn !!(read_val & bit);\r\n}\r\nstatic int mtk_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nconst struct mtk_desc_pin *pin;\r\nstruct mtk_pinctrl *pctl = gpiochip_get_data(chip);\r\nint irq;\r\npin = pctl->devdata->pins + offset;\r\nif (pin->eint.eintnum == NO_EINT_SUPPORT)\r\nreturn -EINVAL;\r\nirq = irq_find_mapping(pctl->domain, pin->eint.eintnum);\r\nif (!irq)\r\nreturn -EINVAL;\r\nreturn irq;\r\n}\r\nstatic int mtk_pinctrl_irq_request_resources(struct irq_data *d)\r\n{\r\nstruct mtk_pinctrl *pctl = irq_data_get_irq_chip_data(d);\r\nconst struct mtk_desc_pin *pin;\r\nint ret;\r\npin = mtk_find_pin_by_eint_num(pctl, d->hwirq);\r\nif (!pin) {\r\ndev_err(pctl->dev, "Can not find pin\n");\r\nreturn -EINVAL;\r\n}\r\nret = gpiochip_lock_as_irq(pctl->chip, pin->pin.number);\r\nif (ret) {\r\ndev_err(pctl->dev, "unable to lock HW IRQ %lu for IRQ\n",\r\nirqd_to_hwirq(d));\r\nreturn ret;\r\n}\r\nmtk_pmx_set_mode(pctl->pctl_dev, pin->pin.number, pin->eint.eintmux);\r\nmtk_pmx_gpio_set_direction(pctl->pctl_dev, NULL, pin->pin.number, true);\r\nmtk_pconf_set_ies_smt(pctl, pin->pin.number, 1, PIN_CONFIG_INPUT_ENABLE);\r\nreturn 0;\r\n}\r\nstatic void mtk_pinctrl_irq_release_resources(struct irq_data *d)\r\n{\r\nstruct mtk_pinctrl *pctl = irq_data_get_irq_chip_data(d);\r\nconst struct mtk_desc_pin *pin;\r\npin = mtk_find_pin_by_eint_num(pctl, d->hwirq);\r\nif (!pin) {\r\ndev_err(pctl->dev, "Can not find pin\n");\r\nreturn;\r\n}\r\ngpiochip_unlock_as_irq(pctl->chip, pin->pin.number);\r\n}\r\nstatic void __iomem *mtk_eint_get_offset(struct mtk_pinctrl *pctl,\r\nunsigned int eint_num, unsigned int offset)\r\n{\r\nunsigned int eint_base = 0;\r\nvoid __iomem *reg;\r\nif (eint_num >= pctl->devdata->ap_num)\r\neint_base = pctl->devdata->ap_num;\r\nreg = pctl->eint_reg_base + offset + ((eint_num - eint_base) / 32) * 4;\r\nreturn reg;\r\n}\r\nstatic unsigned int mtk_eint_can_en_debounce(struct mtk_pinctrl *pctl,\r\nunsigned int eint_num)\r\n{\r\nunsigned int sens;\r\nunsigned int bit = BIT(eint_num % 32);\r\nconst struct mtk_eint_offsets *eint_offsets =\r\n&pctl->devdata->eint_offsets;\r\nvoid __iomem *reg = mtk_eint_get_offset(pctl, eint_num,\r\neint_offsets->sens);\r\nif (readl(reg) & bit)\r\nsens = MT_LEVEL_SENSITIVE;\r\nelse\r\nsens = MT_EDGE_SENSITIVE;\r\nif ((eint_num < pctl->devdata->db_cnt) && (sens != MT_EDGE_SENSITIVE))\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic unsigned int mtk_eint_get_mask(struct mtk_pinctrl *pctl,\r\nunsigned int eint_num)\r\n{\r\nunsigned int bit = BIT(eint_num % 32);\r\nconst struct mtk_eint_offsets *eint_offsets =\r\n&pctl->devdata->eint_offsets;\r\nvoid __iomem *reg = mtk_eint_get_offset(pctl, eint_num,\r\neint_offsets->mask);\r\nreturn !!(readl(reg) & bit);\r\n}\r\nstatic int mtk_eint_flip_edge(struct mtk_pinctrl *pctl, int hwirq)\r\n{\r\nint start_level, curr_level;\r\nunsigned int reg_offset;\r\nconst struct mtk_eint_offsets *eint_offsets = &(pctl->devdata->eint_offsets);\r\nu32 mask = BIT(hwirq & 0x1f);\r\nu32 port = (hwirq >> 5) & eint_offsets->port_mask;\r\nvoid __iomem *reg = pctl->eint_reg_base + (port << 2);\r\nconst struct mtk_desc_pin *pin;\r\npin = mtk_find_pin_by_eint_num(pctl, hwirq);\r\ncurr_level = mtk_gpio_get(pctl->chip, pin->pin.number);\r\ndo {\r\nstart_level = curr_level;\r\nif (start_level)\r\nreg_offset = eint_offsets->pol_clr;\r\nelse\r\nreg_offset = eint_offsets->pol_set;\r\nwritel(mask, reg + reg_offset);\r\ncurr_level = mtk_gpio_get(pctl->chip, pin->pin.number);\r\n} while (start_level != curr_level);\r\nreturn start_level;\r\n}\r\nstatic void mtk_eint_mask(struct irq_data *d)\r\n{\r\nstruct mtk_pinctrl *pctl = irq_data_get_irq_chip_data(d);\r\nconst struct mtk_eint_offsets *eint_offsets =\r\n&pctl->devdata->eint_offsets;\r\nu32 mask = BIT(d->hwirq & 0x1f);\r\nvoid __iomem *reg = mtk_eint_get_offset(pctl, d->hwirq,\r\neint_offsets->mask_set);\r\nwritel(mask, reg);\r\n}\r\nstatic void mtk_eint_unmask(struct irq_data *d)\r\n{\r\nstruct mtk_pinctrl *pctl = irq_data_get_irq_chip_data(d);\r\nconst struct mtk_eint_offsets *eint_offsets =\r\n&pctl->devdata->eint_offsets;\r\nu32 mask = BIT(d->hwirq & 0x1f);\r\nvoid __iomem *reg = mtk_eint_get_offset(pctl, d->hwirq,\r\neint_offsets->mask_clr);\r\nwritel(mask, reg);\r\nif (pctl->eint_dual_edges[d->hwirq])\r\nmtk_eint_flip_edge(pctl, d->hwirq);\r\n}\r\nstatic int mtk_gpio_set_debounce(struct gpio_chip *chip, unsigned offset,\r\nunsigned debounce)\r\n{\r\nstruct mtk_pinctrl *pctl = dev_get_drvdata(chip->parent);\r\nint eint_num, virq, eint_offset;\r\nunsigned int set_offset, bit, clr_bit, clr_offset, rst, i, unmask, dbnc;\r\nstatic const unsigned int debounce_time[] = {500, 1000, 16000, 32000, 64000,\r\n128000, 256000};\r\nconst struct mtk_desc_pin *pin;\r\nstruct irq_data *d;\r\npin = pctl->devdata->pins + offset;\r\nif (pin->eint.eintnum == NO_EINT_SUPPORT)\r\nreturn -EINVAL;\r\neint_num = pin->eint.eintnum;\r\nvirq = irq_find_mapping(pctl->domain, eint_num);\r\neint_offset = (eint_num % 4) * 8;\r\nd = irq_get_irq_data(virq);\r\nset_offset = (eint_num / 4) * 4 + pctl->devdata->eint_offsets.dbnc_set;\r\nclr_offset = (eint_num / 4) * 4 + pctl->devdata->eint_offsets.dbnc_clr;\r\nif (!mtk_eint_can_en_debounce(pctl, eint_num))\r\nreturn -ENOSYS;\r\ndbnc = ARRAY_SIZE(debounce_time);\r\nfor (i = 0; i < ARRAY_SIZE(debounce_time); i++) {\r\nif (debounce <= debounce_time[i]) {\r\ndbnc = i;\r\nbreak;\r\n}\r\n}\r\nif (!mtk_eint_get_mask(pctl, eint_num)) {\r\nmtk_eint_mask(d);\r\nunmask = 1;\r\n} else {\r\nunmask = 0;\r\n}\r\nclr_bit = 0xff << eint_offset;\r\nwritel(clr_bit, pctl->eint_reg_base + clr_offset);\r\nbit = ((dbnc << EINT_DBNC_SET_DBNC_BITS) | EINT_DBNC_SET_EN) <<\r\neint_offset;\r\nrst = EINT_DBNC_RST_BIT << eint_offset;\r\nwritel(rst | bit, pctl->eint_reg_base + set_offset);\r\nudelay(1);\r\nif (unmask == 1)\r\nmtk_eint_unmask(d);\r\nreturn 0;\r\n}\r\nstatic int mtk_gpio_set_config(struct gpio_chip *chip, unsigned offset,\r\nunsigned long config)\r\n{\r\nu32 debounce;\r\nif (pinconf_to_config_param(config) != PIN_CONFIG_INPUT_DEBOUNCE)\r\nreturn -ENOTSUPP;\r\ndebounce = pinconf_to_config_argument(config);\r\nreturn mtk_gpio_set_debounce(chip, offset, debounce);\r\n}\r\nstatic int mtk_eint_set_type(struct irq_data *d,\r\nunsigned int type)\r\n{\r\nstruct mtk_pinctrl *pctl = irq_data_get_irq_chip_data(d);\r\nconst struct mtk_eint_offsets *eint_offsets =\r\n&pctl->devdata->eint_offsets;\r\nu32 mask = BIT(d->hwirq & 0x1f);\r\nvoid __iomem *reg;\r\nif (((type & IRQ_TYPE_EDGE_BOTH) && (type & IRQ_TYPE_LEVEL_MASK)) ||\r\n((type & IRQ_TYPE_LEVEL_MASK) == IRQ_TYPE_LEVEL_MASK)) {\r\ndev_err(pctl->dev, "Can't configure IRQ%d (EINT%lu) for type 0x%X\n",\r\nd->irq, d->hwirq, type);\r\nreturn -EINVAL;\r\n}\r\nif ((type & IRQ_TYPE_EDGE_BOTH) == IRQ_TYPE_EDGE_BOTH)\r\npctl->eint_dual_edges[d->hwirq] = 1;\r\nelse\r\npctl->eint_dual_edges[d->hwirq] = 0;\r\nif (type & (IRQ_TYPE_LEVEL_LOW | IRQ_TYPE_EDGE_FALLING)) {\r\nreg = mtk_eint_get_offset(pctl, d->hwirq,\r\neint_offsets->pol_clr);\r\nwritel(mask, reg);\r\n} else {\r\nreg = mtk_eint_get_offset(pctl, d->hwirq,\r\neint_offsets->pol_set);\r\nwritel(mask, reg);\r\n}\r\nif (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING)) {\r\nreg = mtk_eint_get_offset(pctl, d->hwirq,\r\neint_offsets->sens_clr);\r\nwritel(mask, reg);\r\n} else {\r\nreg = mtk_eint_get_offset(pctl, d->hwirq,\r\neint_offsets->sens_set);\r\nwritel(mask, reg);\r\n}\r\nif (pctl->eint_dual_edges[d->hwirq])\r\nmtk_eint_flip_edge(pctl, d->hwirq);\r\nreturn 0;\r\n}\r\nstatic int mtk_eint_irq_set_wake(struct irq_data *d, unsigned int on)\r\n{\r\nstruct mtk_pinctrl *pctl = irq_data_get_irq_chip_data(d);\r\nint shift = d->hwirq & 0x1f;\r\nint reg = d->hwirq >> 5;\r\nif (on)\r\npctl->wake_mask[reg] |= BIT(shift);\r\nelse\r\npctl->wake_mask[reg] &= ~BIT(shift);\r\nreturn 0;\r\n}\r\nstatic void mtk_eint_chip_write_mask(const struct mtk_eint_offsets *chip,\r\nvoid __iomem *eint_reg_base, u32 *buf)\r\n{\r\nint port;\r\nvoid __iomem *reg;\r\nfor (port = 0; port < chip->ports; port++) {\r\nreg = eint_reg_base + (port << 2);\r\nwritel_relaxed(~buf[port], reg + chip->mask_set);\r\nwritel_relaxed(buf[port], reg + chip->mask_clr);\r\n}\r\n}\r\nstatic void mtk_eint_chip_read_mask(const struct mtk_eint_offsets *chip,\r\nvoid __iomem *eint_reg_base, u32 *buf)\r\n{\r\nint port;\r\nvoid __iomem *reg;\r\nfor (port = 0; port < chip->ports; port++) {\r\nreg = eint_reg_base + chip->mask + (port << 2);\r\nbuf[port] = ~readl_relaxed(reg);\r\n}\r\n}\r\nstatic int mtk_eint_suspend(struct device *device)\r\n{\r\nvoid __iomem *reg;\r\nstruct mtk_pinctrl *pctl = dev_get_drvdata(device);\r\nconst struct mtk_eint_offsets *eint_offsets =\r\n&pctl->devdata->eint_offsets;\r\nreg = pctl->eint_reg_base;\r\nmtk_eint_chip_read_mask(eint_offsets, reg, pctl->cur_mask);\r\nmtk_eint_chip_write_mask(eint_offsets, reg, pctl->wake_mask);\r\nreturn 0;\r\n}\r\nstatic int mtk_eint_resume(struct device *device)\r\n{\r\nstruct mtk_pinctrl *pctl = dev_get_drvdata(device);\r\nconst struct mtk_eint_offsets *eint_offsets =\r\n&pctl->devdata->eint_offsets;\r\nmtk_eint_chip_write_mask(eint_offsets,\r\npctl->eint_reg_base, pctl->cur_mask);\r\nreturn 0;\r\n}\r\nstatic void mtk_eint_ack(struct irq_data *d)\r\n{\r\nstruct mtk_pinctrl *pctl = irq_data_get_irq_chip_data(d);\r\nconst struct mtk_eint_offsets *eint_offsets =\r\n&pctl->devdata->eint_offsets;\r\nu32 mask = BIT(d->hwirq & 0x1f);\r\nvoid __iomem *reg = mtk_eint_get_offset(pctl, d->hwirq,\r\neint_offsets->ack);\r\nwritel(mask, reg);\r\n}\r\nstatic unsigned int mtk_eint_init(struct mtk_pinctrl *pctl)\r\n{\r\nconst struct mtk_eint_offsets *eint_offsets =\r\n&pctl->devdata->eint_offsets;\r\nvoid __iomem *reg = pctl->eint_reg_base + eint_offsets->dom_en;\r\nunsigned int i;\r\nfor (i = 0; i < pctl->devdata->ap_num; i += 32) {\r\nwritel(0xffffffff, reg);\r\nreg += 4;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void\r\nmtk_eint_debounce_process(struct mtk_pinctrl *pctl, int index)\r\n{\r\nunsigned int rst, ctrl_offset;\r\nunsigned int bit, dbnc;\r\nconst struct mtk_eint_offsets *eint_offsets =\r\n&pctl->devdata->eint_offsets;\r\nctrl_offset = (index / 4) * 4 + eint_offsets->dbnc_ctrl;\r\ndbnc = readl(pctl->eint_reg_base + ctrl_offset);\r\nbit = EINT_DBNC_SET_EN << ((index % 4) * 8);\r\nif ((bit & dbnc) > 0) {\r\nctrl_offset = (index / 4) * 4 + eint_offsets->dbnc_set;\r\nrst = EINT_DBNC_RST_BIT << ((index % 4) * 8);\r\nwritel(rst, pctl->eint_reg_base + ctrl_offset);\r\n}\r\n}\r\nstatic void mtk_eint_irq_handler(struct irq_desc *desc)\r\n{\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nstruct mtk_pinctrl *pctl = irq_desc_get_handler_data(desc);\r\nunsigned int status, eint_num;\r\nint offset, index, virq;\r\nconst struct mtk_eint_offsets *eint_offsets =\r\n&pctl->devdata->eint_offsets;\r\nvoid __iomem *reg = mtk_eint_get_offset(pctl, 0, eint_offsets->stat);\r\nint dual_edges, start_level, curr_level;\r\nconst struct mtk_desc_pin *pin;\r\nchained_irq_enter(chip, desc);\r\nfor (eint_num = 0;\r\neint_num < pctl->devdata->ap_num;\r\neint_num += 32, reg += 4) {\r\nstatus = readl(reg);\r\nwhile (status) {\r\noffset = __ffs(status);\r\nindex = eint_num + offset;\r\nvirq = irq_find_mapping(pctl->domain, index);\r\nstatus &= ~BIT(offset);\r\ndual_edges = pctl->eint_dual_edges[index];\r\nif (dual_edges) {\r\nwritel(BIT(offset), reg - eint_offsets->stat +\r\neint_offsets->soft_clr);\r\npin = mtk_find_pin_by_eint_num(pctl, index);\r\nstart_level = mtk_gpio_get(pctl->chip,\r\npin->pin.number);\r\n}\r\ngeneric_handle_irq(virq);\r\nif (dual_edges) {\r\ncurr_level = mtk_eint_flip_edge(pctl, index);\r\nif (start_level != curr_level)\r\nwritel(BIT(offset), reg -\r\neint_offsets->stat +\r\neint_offsets->soft_set);\r\n}\r\nif (index < pctl->devdata->db_cnt)\r\nmtk_eint_debounce_process(pctl , index);\r\n}\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int mtk_pctrl_build_state(struct platform_device *pdev)\r\n{\r\nstruct mtk_pinctrl *pctl = platform_get_drvdata(pdev);\r\nint i;\r\npctl->ngroups = pctl->devdata->npins;\r\npctl->groups = devm_kcalloc(&pdev->dev, pctl->ngroups,\r\nsizeof(*pctl->groups), GFP_KERNEL);\r\nif (!pctl->groups)\r\nreturn -ENOMEM;\r\npctl->grp_names = devm_kcalloc(&pdev->dev, pctl->ngroups,\r\nsizeof(*pctl->grp_names), GFP_KERNEL);\r\nif (!pctl->grp_names)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < pctl->devdata->npins; i++) {\r\nconst struct mtk_desc_pin *pin = pctl->devdata->pins + i;\r\nstruct mtk_pinctrl_group *group = pctl->groups + i;\r\ngroup->name = pin->pin.name;\r\ngroup->pin = pin->pin.number;\r\npctl->grp_names[i] = pin->pin.name;\r\n}\r\nreturn 0;\r\n}\r\nint mtk_pctrl_init(struct platform_device *pdev,\r\nconst struct mtk_pinctrl_devdata *data,\r\nstruct regmap *regmap)\r\n{\r\nstruct pinctrl_pin_desc *pins;\r\nstruct mtk_pinctrl *pctl;\r\nstruct device_node *np = pdev->dev.of_node, *node;\r\nstruct property *prop;\r\nstruct resource *res;\r\nint i, ret, irq, ports_buf;\r\npctl = devm_kzalloc(&pdev->dev, sizeof(*pctl), GFP_KERNEL);\r\nif (!pctl)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, pctl);\r\nprop = of_find_property(np, "pins-are-numbered", NULL);\r\nif (!prop) {\r\ndev_err(&pdev->dev, "only support pins-are-numbered format\n");\r\nreturn -EINVAL;\r\n}\r\nnode = of_parse_phandle(np, "mediatek,pctl-regmap", 0);\r\nif (node) {\r\npctl->regmap1 = syscon_node_to_regmap(node);\r\nif (IS_ERR(pctl->regmap1))\r\nreturn PTR_ERR(pctl->regmap1);\r\n} else if (regmap) {\r\npctl->regmap1 = regmap;\r\n} else {\r\ndev_err(&pdev->dev, "Pinctrl node has not register regmap.\n");\r\nreturn -EINVAL;\r\n}\r\nnode = of_parse_phandle(np, "mediatek,pctl-regmap", 1);\r\nif (node) {\r\npctl->regmap2 = syscon_node_to_regmap(node);\r\nif (IS_ERR(pctl->regmap2))\r\nreturn PTR_ERR(pctl->regmap2);\r\n}\r\npctl->devdata = data;\r\nret = mtk_pctrl_build_state(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "build state failed: %d\n", ret);\r\nreturn -EINVAL;\r\n}\r\npins = devm_kcalloc(&pdev->dev, pctl->devdata->npins, sizeof(*pins),\r\nGFP_KERNEL);\r\nif (!pins)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < pctl->devdata->npins; i++)\r\npins[i] = pctl->devdata->pins[i].pin;\r\npctl->pctl_desc.name = dev_name(&pdev->dev);\r\npctl->pctl_desc.owner = THIS_MODULE;\r\npctl->pctl_desc.pins = pins;\r\npctl->pctl_desc.npins = pctl->devdata->npins;\r\npctl->pctl_desc.confops = &mtk_pconf_ops;\r\npctl->pctl_desc.pctlops = &mtk_pctrl_ops;\r\npctl->pctl_desc.pmxops = &mtk_pmx_ops;\r\npctl->dev = &pdev->dev;\r\npctl->pctl_dev = devm_pinctrl_register(&pdev->dev, &pctl->pctl_desc,\r\npctl);\r\nif (IS_ERR(pctl->pctl_dev)) {\r\ndev_err(&pdev->dev, "couldn't register pinctrl driver\n");\r\nreturn PTR_ERR(pctl->pctl_dev);\r\n}\r\npctl->chip = devm_kzalloc(&pdev->dev, sizeof(*pctl->chip), GFP_KERNEL);\r\nif (!pctl->chip)\r\nreturn -ENOMEM;\r\n*pctl->chip = mtk_gpio_chip;\r\npctl->chip->ngpio = pctl->devdata->npins;\r\npctl->chip->label = dev_name(&pdev->dev);\r\npctl->chip->parent = &pdev->dev;\r\npctl->chip->base = -1;\r\nret = gpiochip_add_data(pctl->chip, pctl);\r\nif (ret)\r\nreturn -EINVAL;\r\nret = gpiochip_add_pin_range(pctl->chip, dev_name(&pdev->dev),\r\n0, 0, pctl->devdata->npins);\r\nif (ret) {\r\nret = -EINVAL;\r\ngoto chip_error;\r\n}\r\nif (!of_property_read_bool(np, "interrupt-controller"))\r\nreturn 0;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "Unable to get Pinctrl resource\n");\r\nret = -EINVAL;\r\ngoto chip_error;\r\n}\r\npctl->eint_reg_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pctl->eint_reg_base)) {\r\nret = -EINVAL;\r\ngoto chip_error;\r\n}\r\nports_buf = pctl->devdata->eint_offsets.ports;\r\npctl->wake_mask = devm_kcalloc(&pdev->dev, ports_buf,\r\nsizeof(*pctl->wake_mask), GFP_KERNEL);\r\nif (!pctl->wake_mask) {\r\nret = -ENOMEM;\r\ngoto chip_error;\r\n}\r\npctl->cur_mask = devm_kcalloc(&pdev->dev, ports_buf,\r\nsizeof(*pctl->cur_mask), GFP_KERNEL);\r\nif (!pctl->cur_mask) {\r\nret = -ENOMEM;\r\ngoto chip_error;\r\n}\r\npctl->eint_dual_edges = devm_kcalloc(&pdev->dev, pctl->devdata->ap_num,\r\nsizeof(int), GFP_KERNEL);\r\nif (!pctl->eint_dual_edges) {\r\nret = -ENOMEM;\r\ngoto chip_error;\r\n}\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (!irq) {\r\ndev_err(&pdev->dev, "couldn't parse and map irq\n");\r\nret = -EINVAL;\r\ngoto chip_error;\r\n}\r\npctl->domain = irq_domain_add_linear(np,\r\npctl->devdata->ap_num, &irq_domain_simple_ops, NULL);\r\nif (!pctl->domain) {\r\ndev_err(&pdev->dev, "Couldn't register IRQ domain\n");\r\nret = -ENOMEM;\r\ngoto chip_error;\r\n}\r\nmtk_eint_init(pctl);\r\nfor (i = 0; i < pctl->devdata->ap_num; i++) {\r\nint virq = irq_create_mapping(pctl->domain, i);\r\nirq_set_chip_and_handler(virq, &mtk_pinctrl_irq_chip,\r\nhandle_level_irq);\r\nirq_set_chip_data(virq, pctl);\r\n}\r\nirq_set_chained_handler_and_data(irq, mtk_eint_irq_handler, pctl);\r\nreturn 0;\r\nchip_error:\r\ngpiochip_remove(pctl->chip);\r\nreturn ret;\r\n}
