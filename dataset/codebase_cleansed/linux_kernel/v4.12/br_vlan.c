static inline int br_vlan_cmp(struct rhashtable_compare_arg *arg,\r\nconst void *ptr)\r\n{\r\nconst struct net_bridge_vlan *vle = ptr;\r\nu16 vid = *(u16 *)arg->key;\r\nreturn vle->vid != vid;\r\n}\r\nstatic struct net_bridge_vlan *br_vlan_lookup(struct rhashtable *tbl, u16 vid)\r\n{\r\nreturn rhashtable_lookup_fast(tbl, &vid, br_vlan_rht_params);\r\n}\r\nstatic void __vlan_add_pvid(struct net_bridge_vlan_group *vg, u16 vid)\r\n{\r\nif (vg->pvid == vid)\r\nreturn;\r\nsmp_wmb();\r\nvg->pvid = vid;\r\n}\r\nstatic void __vlan_delete_pvid(struct net_bridge_vlan_group *vg, u16 vid)\r\n{\r\nif (vg->pvid != vid)\r\nreturn;\r\nsmp_wmb();\r\nvg->pvid = 0;\r\n}\r\nstatic void __vlan_add_flags(struct net_bridge_vlan *v, u16 flags)\r\n{\r\nstruct net_bridge_vlan_group *vg;\r\nif (br_vlan_is_master(v))\r\nvg = br_vlan_group(v->br);\r\nelse\r\nvg = nbp_vlan_group(v->port);\r\nif (flags & BRIDGE_VLAN_INFO_PVID)\r\n__vlan_add_pvid(vg, v->vid);\r\nelse\r\n__vlan_delete_pvid(vg, v->vid);\r\nif (flags & BRIDGE_VLAN_INFO_UNTAGGED)\r\nv->flags |= BRIDGE_VLAN_INFO_UNTAGGED;\r\nelse\r\nv->flags &= ~BRIDGE_VLAN_INFO_UNTAGGED;\r\n}\r\nstatic int __vlan_vid_add(struct net_device *dev, struct net_bridge *br,\r\nu16 vid, u16 flags)\r\n{\r\nstruct switchdev_obj_port_vlan v = {\r\n.obj.orig_dev = dev,\r\n.obj.id = SWITCHDEV_OBJ_ID_PORT_VLAN,\r\n.flags = flags,\r\n.vid_begin = vid,\r\n.vid_end = vid,\r\n};\r\nint err;\r\nerr = switchdev_port_obj_add(dev, &v.obj);\r\nif (err == -EOPNOTSUPP)\r\nreturn vlan_vid_add(dev, br->vlan_proto, vid);\r\nreturn err;\r\n}\r\nstatic void __vlan_add_list(struct net_bridge_vlan *v)\r\n{\r\nstruct net_bridge_vlan_group *vg;\r\nstruct list_head *headp, *hpos;\r\nstruct net_bridge_vlan *vent;\r\nif (br_vlan_is_master(v))\r\nvg = br_vlan_group(v->br);\r\nelse\r\nvg = nbp_vlan_group(v->port);\r\nheadp = &vg->vlan_list;\r\nlist_for_each_prev(hpos, headp) {\r\nvent = list_entry(hpos, struct net_bridge_vlan, vlist);\r\nif (v->vid < vent->vid)\r\ncontinue;\r\nelse\r\nbreak;\r\n}\r\nlist_add_rcu(&v->vlist, hpos);\r\n}\r\nstatic void __vlan_del_list(struct net_bridge_vlan *v)\r\n{\r\nlist_del_rcu(&v->vlist);\r\n}\r\nstatic int __vlan_vid_del(struct net_device *dev, struct net_bridge *br,\r\nu16 vid)\r\n{\r\nstruct switchdev_obj_port_vlan v = {\r\n.obj.orig_dev = dev,\r\n.obj.id = SWITCHDEV_OBJ_ID_PORT_VLAN,\r\n.vid_begin = vid,\r\n.vid_end = vid,\r\n};\r\nint err;\r\nerr = switchdev_port_obj_del(dev, &v.obj);\r\nif (err == -EOPNOTSUPP) {\r\nvlan_vid_del(dev, br->vlan_proto, vid);\r\nreturn 0;\r\n}\r\nreturn err;\r\n}\r\nstatic struct net_bridge_vlan *br_vlan_get_master(struct net_bridge *br, u16 vid)\r\n{\r\nstruct net_bridge_vlan_group *vg;\r\nstruct net_bridge_vlan *masterv;\r\nvg = br_vlan_group(br);\r\nmasterv = br_vlan_find(vg, vid);\r\nif (!masterv) {\r\nif (br_vlan_add(br, vid, 0))\r\nreturn NULL;\r\nmasterv = br_vlan_find(vg, vid);\r\nif (WARN_ON(!masterv))\r\nreturn NULL;\r\n}\r\natomic_inc(&masterv->refcnt);\r\nreturn masterv;\r\n}\r\nstatic void br_master_vlan_rcu_free(struct rcu_head *rcu)\r\n{\r\nstruct net_bridge_vlan *v;\r\nv = container_of(rcu, struct net_bridge_vlan, rcu);\r\nWARN_ON(!br_vlan_is_master(v));\r\nfree_percpu(v->stats);\r\nv->stats = NULL;\r\nkfree(v);\r\n}\r\nstatic void br_vlan_put_master(struct net_bridge_vlan *masterv)\r\n{\r\nstruct net_bridge_vlan_group *vg;\r\nif (!br_vlan_is_master(masterv))\r\nreturn;\r\nvg = br_vlan_group(masterv->br);\r\nif (atomic_dec_and_test(&masterv->refcnt)) {\r\nrhashtable_remove_fast(&vg->vlan_hash,\r\n&masterv->vnode, br_vlan_rht_params);\r\n__vlan_del_list(masterv);\r\ncall_rcu(&masterv->rcu, br_master_vlan_rcu_free);\r\n}\r\n}\r\nstatic int __vlan_add(struct net_bridge_vlan *v, u16 flags)\r\n{\r\nstruct net_bridge_vlan *masterv = NULL;\r\nstruct net_bridge_port *p = NULL;\r\nstruct net_bridge_vlan_group *vg;\r\nstruct net_device *dev;\r\nstruct net_bridge *br;\r\nint err;\r\nif (br_vlan_is_master(v)) {\r\nbr = v->br;\r\ndev = br->dev;\r\nvg = br_vlan_group(br);\r\n} else {\r\np = v->port;\r\nbr = p->br;\r\ndev = p->dev;\r\nvg = nbp_vlan_group(p);\r\n}\r\nif (p) {\r\nerr = __vlan_vid_add(dev, br, v->vid, flags);\r\nif (err)\r\ngoto out;\r\nif (flags & BRIDGE_VLAN_INFO_MASTER) {\r\nerr = br_vlan_add(br, v->vid, flags |\r\nBRIDGE_VLAN_INFO_BRENTRY);\r\nif (err)\r\ngoto out_filt;\r\n}\r\nmasterv = br_vlan_get_master(br, v->vid);\r\nif (!masterv)\r\ngoto out_filt;\r\nv->brvlan = masterv;\r\nv->stats = masterv->stats;\r\n}\r\nif (br_vlan_should_use(v)) {\r\nerr = br_fdb_insert(br, p, dev->dev_addr, v->vid);\r\nif (err) {\r\nbr_err(br, "failed insert local address into bridge forwarding table\n");\r\ngoto out_filt;\r\n}\r\nvg->num_vlans++;\r\n}\r\nerr = rhashtable_lookup_insert_fast(&vg->vlan_hash, &v->vnode,\r\nbr_vlan_rht_params);\r\nif (err)\r\ngoto out_fdb_insert;\r\n__vlan_add_list(v);\r\n__vlan_add_flags(v, flags);\r\nout:\r\nreturn err;\r\nout_fdb_insert:\r\nif (br_vlan_should_use(v)) {\r\nbr_fdb_find_delete_local(br, p, dev->dev_addr, v->vid);\r\nvg->num_vlans--;\r\n}\r\nout_filt:\r\nif (p) {\r\n__vlan_vid_del(dev, br, v->vid);\r\nif (masterv) {\r\nbr_vlan_put_master(masterv);\r\nv->brvlan = NULL;\r\n}\r\n}\r\ngoto out;\r\n}\r\nstatic int __vlan_del(struct net_bridge_vlan *v)\r\n{\r\nstruct net_bridge_vlan *masterv = v;\r\nstruct net_bridge_vlan_group *vg;\r\nstruct net_bridge_port *p = NULL;\r\nint err = 0;\r\nif (br_vlan_is_master(v)) {\r\nvg = br_vlan_group(v->br);\r\n} else {\r\np = v->port;\r\nvg = nbp_vlan_group(v->port);\r\nmasterv = v->brvlan;\r\n}\r\n__vlan_delete_pvid(vg, v->vid);\r\nif (p) {\r\nerr = __vlan_vid_del(p->dev, p->br, v->vid);\r\nif (err)\r\ngoto out;\r\n}\r\nif (br_vlan_should_use(v)) {\r\nv->flags &= ~BRIDGE_VLAN_INFO_BRENTRY;\r\nvg->num_vlans--;\r\n}\r\nif (masterv != v) {\r\nvlan_tunnel_info_del(vg, v);\r\nrhashtable_remove_fast(&vg->vlan_hash, &v->vnode,\r\nbr_vlan_rht_params);\r\n__vlan_del_list(v);\r\nkfree_rcu(v, rcu);\r\n}\r\nbr_vlan_put_master(masterv);\r\nout:\r\nreturn err;\r\n}\r\nstatic void __vlan_group_free(struct net_bridge_vlan_group *vg)\r\n{\r\nWARN_ON(!list_empty(&vg->vlan_list));\r\nrhashtable_destroy(&vg->vlan_hash);\r\nvlan_tunnel_deinit(vg);\r\nkfree(vg);\r\n}\r\nstatic void __vlan_flush(struct net_bridge_vlan_group *vg)\r\n{\r\nstruct net_bridge_vlan *vlan, *tmp;\r\n__vlan_delete_pvid(vg, vg->pvid);\r\nlist_for_each_entry_safe(vlan, tmp, &vg->vlan_list, vlist)\r\n__vlan_del(vlan);\r\n}\r\nstruct sk_buff *br_handle_vlan(struct net_bridge *br,\r\nconst struct net_bridge_port *p,\r\nstruct net_bridge_vlan_group *vg,\r\nstruct sk_buff *skb)\r\n{\r\nstruct br_vlan_stats *stats;\r\nstruct net_bridge_vlan *v;\r\nu16 vid;\r\nif (!BR_INPUT_SKB_CB(skb)->vlan_filtered)\r\ngoto out;\r\nbr_vlan_get_tag(skb, &vid);\r\nv = br_vlan_find(vg, vid);\r\nif (!v || !br_vlan_should_use(v)) {\r\nif ((br->dev->flags & IFF_PROMISC) && skb->dev == br->dev) {\r\ngoto out;\r\n} else {\r\nkfree_skb(skb);\r\nreturn NULL;\r\n}\r\n}\r\nif (br->vlan_stats_enabled) {\r\nstats = this_cpu_ptr(v->stats);\r\nu64_stats_update_begin(&stats->syncp);\r\nstats->tx_bytes += skb->len;\r\nstats->tx_packets++;\r\nu64_stats_update_end(&stats->syncp);\r\n}\r\nif (v->flags & BRIDGE_VLAN_INFO_UNTAGGED)\r\nskb->vlan_tci = 0;\r\nif (p && (p->flags & BR_VLAN_TUNNEL) &&\r\nbr_handle_egress_vlan_tunnel(skb, v)) {\r\nkfree_skb(skb);\r\nreturn NULL;\r\n}\r\nout:\r\nreturn skb;\r\n}\r\nstatic bool __allowed_ingress(const struct net_bridge *br,\r\nstruct net_bridge_vlan_group *vg,\r\nstruct sk_buff *skb, u16 *vid)\r\n{\r\nstruct br_vlan_stats *stats;\r\nstruct net_bridge_vlan *v;\r\nbool tagged;\r\nBR_INPUT_SKB_CB(skb)->vlan_filtered = true;\r\nif (unlikely(!skb_vlan_tag_present(skb) &&\r\nskb->protocol == br->vlan_proto)) {\r\nskb = skb_vlan_untag(skb);\r\nif (unlikely(!skb))\r\nreturn false;\r\n}\r\nif (!br_vlan_get_tag(skb, vid)) {\r\nif (skb->vlan_proto != br->vlan_proto) {\r\nskb_push(skb, ETH_HLEN);\r\nskb = vlan_insert_tag_set_proto(skb, skb->vlan_proto,\r\nskb_vlan_tag_get(skb));\r\nif (unlikely(!skb))\r\nreturn false;\r\nskb_pull(skb, ETH_HLEN);\r\nskb_reset_mac_len(skb);\r\n*vid = 0;\r\ntagged = false;\r\n} else {\r\ntagged = true;\r\n}\r\n} else {\r\ntagged = false;\r\n}\r\nif (!*vid) {\r\nu16 pvid = br_get_pvid(vg);\r\nif (!pvid)\r\ngoto drop;\r\n*vid = pvid;\r\nif (likely(!tagged))\r\n__vlan_hwaccel_put_tag(skb, br->vlan_proto, pvid);\r\nelse\r\nskb->vlan_tci |= pvid;\r\nif (!br->vlan_stats_enabled)\r\nreturn true;\r\n}\r\nv = br_vlan_find(vg, *vid);\r\nif (!v || !br_vlan_should_use(v))\r\ngoto drop;\r\nif (br->vlan_stats_enabled) {\r\nstats = this_cpu_ptr(v->stats);\r\nu64_stats_update_begin(&stats->syncp);\r\nstats->rx_bytes += skb->len;\r\nstats->rx_packets++;\r\nu64_stats_update_end(&stats->syncp);\r\n}\r\nreturn true;\r\ndrop:\r\nkfree_skb(skb);\r\nreturn false;\r\n}\r\nbool br_allowed_ingress(const struct net_bridge *br,\r\nstruct net_bridge_vlan_group *vg, struct sk_buff *skb,\r\nu16 *vid)\r\n{\r\nif (!br->vlan_enabled) {\r\nBR_INPUT_SKB_CB(skb)->vlan_filtered = false;\r\nreturn true;\r\n}\r\nreturn __allowed_ingress(br, vg, skb, vid);\r\n}\r\nbool br_allowed_egress(struct net_bridge_vlan_group *vg,\r\nconst struct sk_buff *skb)\r\n{\r\nconst struct net_bridge_vlan *v;\r\nu16 vid;\r\nif (!BR_INPUT_SKB_CB(skb)->vlan_filtered)\r\nreturn true;\r\nbr_vlan_get_tag(skb, &vid);\r\nv = br_vlan_find(vg, vid);\r\nif (v && br_vlan_should_use(v))\r\nreturn true;\r\nreturn false;\r\n}\r\nbool br_should_learn(struct net_bridge_port *p, struct sk_buff *skb, u16 *vid)\r\n{\r\nstruct net_bridge_vlan_group *vg;\r\nstruct net_bridge *br = p->br;\r\nif (!br->vlan_enabled)\r\nreturn true;\r\nvg = nbp_vlan_group_rcu(p);\r\nif (!vg || !vg->num_vlans)\r\nreturn false;\r\nif (!br_vlan_get_tag(skb, vid) && skb->vlan_proto != br->vlan_proto)\r\n*vid = 0;\r\nif (!*vid) {\r\n*vid = br_get_pvid(vg);\r\nif (!*vid)\r\nreturn false;\r\nreturn true;\r\n}\r\nif (br_vlan_find(vg, *vid))\r\nreturn true;\r\nreturn false;\r\n}\r\nint br_vlan_add(struct net_bridge *br, u16 vid, u16 flags)\r\n{\r\nstruct net_bridge_vlan_group *vg;\r\nstruct net_bridge_vlan *vlan;\r\nint ret;\r\nASSERT_RTNL();\r\nvg = br_vlan_group(br);\r\nvlan = br_vlan_find(vg, vid);\r\nif (vlan) {\r\nif (!br_vlan_is_brentry(vlan)) {\r\nif (!(flags & BRIDGE_VLAN_INFO_BRENTRY))\r\nreturn -EINVAL;\r\nret = br_fdb_insert(br, NULL, br->dev->dev_addr,\r\nvlan->vid);\r\nif (ret) {\r\nbr_err(br, "failed insert local address into bridge forwarding table\n");\r\nreturn ret;\r\n}\r\natomic_inc(&vlan->refcnt);\r\nvlan->flags |= BRIDGE_VLAN_INFO_BRENTRY;\r\nvg->num_vlans++;\r\n}\r\n__vlan_add_flags(vlan, flags);\r\nreturn 0;\r\n}\r\nvlan = kzalloc(sizeof(*vlan), GFP_KERNEL);\r\nif (!vlan)\r\nreturn -ENOMEM;\r\nvlan->stats = netdev_alloc_pcpu_stats(struct br_vlan_stats);\r\nif (!vlan->stats) {\r\nkfree(vlan);\r\nreturn -ENOMEM;\r\n}\r\nvlan->vid = vid;\r\nvlan->flags = flags | BRIDGE_VLAN_INFO_MASTER;\r\nvlan->flags &= ~BRIDGE_VLAN_INFO_PVID;\r\nvlan->br = br;\r\nif (flags & BRIDGE_VLAN_INFO_BRENTRY)\r\natomic_set(&vlan->refcnt, 1);\r\nret = __vlan_add(vlan, flags);\r\nif (ret) {\r\nfree_percpu(vlan->stats);\r\nkfree(vlan);\r\n}\r\nreturn ret;\r\n}\r\nint br_vlan_delete(struct net_bridge *br, u16 vid)\r\n{\r\nstruct net_bridge_vlan_group *vg;\r\nstruct net_bridge_vlan *v;\r\nASSERT_RTNL();\r\nvg = br_vlan_group(br);\r\nv = br_vlan_find(vg, vid);\r\nif (!v || !br_vlan_is_brentry(v))\r\nreturn -ENOENT;\r\nbr_fdb_find_delete_local(br, NULL, br->dev->dev_addr, vid);\r\nbr_fdb_delete_by_port(br, NULL, vid, 0);\r\nvlan_tunnel_info_del(vg, v);\r\nreturn __vlan_del(v);\r\n}\r\nvoid br_vlan_flush(struct net_bridge *br)\r\n{\r\nstruct net_bridge_vlan_group *vg;\r\nASSERT_RTNL();\r\nvg = br_vlan_group(br);\r\n__vlan_flush(vg);\r\nRCU_INIT_POINTER(br->vlgrp, NULL);\r\nsynchronize_rcu();\r\n__vlan_group_free(vg);\r\n}\r\nstruct net_bridge_vlan *br_vlan_find(struct net_bridge_vlan_group *vg, u16 vid)\r\n{\r\nif (!vg)\r\nreturn NULL;\r\nreturn br_vlan_lookup(&vg->vlan_hash, vid);\r\n}\r\nstatic void recalculate_group_addr(struct net_bridge *br)\r\n{\r\nif (br->group_addr_set)\r\nreturn;\r\nspin_lock_bh(&br->lock);\r\nif (!br->vlan_enabled || br->vlan_proto == htons(ETH_P_8021Q)) {\r\nbr->group_addr[5] = 0x00;\r\n} else {\r\nbr->group_addr[5] = 0x08;\r\n}\r\nspin_unlock_bh(&br->lock);\r\n}\r\nvoid br_recalculate_fwd_mask(struct net_bridge *br)\r\n{\r\nif (!br->vlan_enabled || br->vlan_proto == htons(ETH_P_8021Q))\r\nbr->group_fwd_mask_required = BR_GROUPFWD_DEFAULT;\r\nelse\r\nbr->group_fwd_mask_required = BR_GROUPFWD_8021AD &\r\n~(1u << br->group_addr[5]);\r\n}\r\nint __br_vlan_filter_toggle(struct net_bridge *br, unsigned long val)\r\n{\r\nstruct switchdev_attr attr = {\r\n.orig_dev = br->dev,\r\n.id = SWITCHDEV_ATTR_ID_BRIDGE_VLAN_FILTERING,\r\n.flags = SWITCHDEV_F_SKIP_EOPNOTSUPP,\r\n.u.vlan_filtering = val,\r\n};\r\nint err;\r\nif (br->vlan_enabled == val)\r\nreturn 0;\r\nerr = switchdev_port_attr_set(br->dev, &attr);\r\nif (err && err != -EOPNOTSUPP)\r\nreturn err;\r\nbr->vlan_enabled = val;\r\nbr_manage_promisc(br);\r\nrecalculate_group_addr(br);\r\nbr_recalculate_fwd_mask(br);\r\nreturn 0;\r\n}\r\nint br_vlan_filter_toggle(struct net_bridge *br, unsigned long val)\r\n{\r\nreturn __br_vlan_filter_toggle(br, val);\r\n}\r\nint __br_vlan_set_proto(struct net_bridge *br, __be16 proto)\r\n{\r\nint err = 0;\r\nstruct net_bridge_port *p;\r\nstruct net_bridge_vlan *vlan;\r\nstruct net_bridge_vlan_group *vg;\r\n__be16 oldproto;\r\nif (br->vlan_proto == proto)\r\nreturn 0;\r\nlist_for_each_entry(p, &br->port_list, list) {\r\nvg = nbp_vlan_group(p);\r\nlist_for_each_entry(vlan, &vg->vlan_list, vlist) {\r\nerr = vlan_vid_add(p->dev, proto, vlan->vid);\r\nif (err)\r\ngoto err_filt;\r\n}\r\n}\r\noldproto = br->vlan_proto;\r\nbr->vlan_proto = proto;\r\nrecalculate_group_addr(br);\r\nbr_recalculate_fwd_mask(br);\r\nlist_for_each_entry(p, &br->port_list, list) {\r\nvg = nbp_vlan_group(p);\r\nlist_for_each_entry(vlan, &vg->vlan_list, vlist)\r\nvlan_vid_del(p->dev, oldproto, vlan->vid);\r\n}\r\nreturn 0;\r\nerr_filt:\r\nlist_for_each_entry_continue_reverse(vlan, &vg->vlan_list, vlist)\r\nvlan_vid_del(p->dev, proto, vlan->vid);\r\nlist_for_each_entry_continue_reverse(p, &br->port_list, list) {\r\nvg = nbp_vlan_group(p);\r\nlist_for_each_entry(vlan, &vg->vlan_list, vlist)\r\nvlan_vid_del(p->dev, proto, vlan->vid);\r\n}\r\nreturn err;\r\n}\r\nint br_vlan_set_proto(struct net_bridge *br, unsigned long val)\r\n{\r\nif (val != ETH_P_8021Q && val != ETH_P_8021AD)\r\nreturn -EPROTONOSUPPORT;\r\nreturn __br_vlan_set_proto(br, htons(val));\r\n}\r\nint br_vlan_set_stats(struct net_bridge *br, unsigned long val)\r\n{\r\nswitch (val) {\r\ncase 0:\r\ncase 1:\r\nbr->vlan_stats_enabled = val;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool vlan_default_pvid(struct net_bridge_vlan_group *vg, u16 vid)\r\n{\r\nstruct net_bridge_vlan *v;\r\nif (vid != vg->pvid)\r\nreturn false;\r\nv = br_vlan_lookup(&vg->vlan_hash, vid);\r\nif (v && br_vlan_should_use(v) &&\r\n(v->flags & BRIDGE_VLAN_INFO_UNTAGGED))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void br_vlan_disable_default_pvid(struct net_bridge *br)\r\n{\r\nstruct net_bridge_port *p;\r\nu16 pvid = br->default_pvid;\r\nif (vlan_default_pvid(br_vlan_group(br), pvid))\r\nbr_vlan_delete(br, pvid);\r\nlist_for_each_entry(p, &br->port_list, list) {\r\nif (vlan_default_pvid(nbp_vlan_group(p), pvid))\r\nnbp_vlan_delete(p, pvid);\r\n}\r\nbr->default_pvid = 0;\r\n}\r\nint __br_vlan_set_default_pvid(struct net_bridge *br, u16 pvid)\r\n{\r\nconst struct net_bridge_vlan *pvent;\r\nstruct net_bridge_vlan_group *vg;\r\nstruct net_bridge_port *p;\r\nu16 old_pvid;\r\nint err = 0;\r\nunsigned long *changed;\r\nif (!pvid) {\r\nbr_vlan_disable_default_pvid(br);\r\nreturn 0;\r\n}\r\nchanged = kcalloc(BITS_TO_LONGS(BR_MAX_PORTS), sizeof(unsigned long),\r\nGFP_KERNEL);\r\nif (!changed)\r\nreturn -ENOMEM;\r\nold_pvid = br->default_pvid;\r\nvg = br_vlan_group(br);\r\npvent = br_vlan_find(vg, pvid);\r\nif ((!old_pvid || vlan_default_pvid(vg, old_pvid)) &&\r\n(!pvent || !br_vlan_should_use(pvent))) {\r\nerr = br_vlan_add(br, pvid,\r\nBRIDGE_VLAN_INFO_PVID |\r\nBRIDGE_VLAN_INFO_UNTAGGED |\r\nBRIDGE_VLAN_INFO_BRENTRY);\r\nif (err)\r\ngoto out;\r\nbr_vlan_delete(br, old_pvid);\r\nset_bit(0, changed);\r\n}\r\nlist_for_each_entry(p, &br->port_list, list) {\r\nvg = nbp_vlan_group(p);\r\nif ((old_pvid &&\r\n!vlan_default_pvid(vg, old_pvid)) ||\r\nbr_vlan_find(vg, pvid))\r\ncontinue;\r\nerr = nbp_vlan_add(p, pvid,\r\nBRIDGE_VLAN_INFO_PVID |\r\nBRIDGE_VLAN_INFO_UNTAGGED);\r\nif (err)\r\ngoto err_port;\r\nnbp_vlan_delete(p, old_pvid);\r\nset_bit(p->port_no, changed);\r\n}\r\nbr->default_pvid = pvid;\r\nout:\r\nkfree(changed);\r\nreturn err;\r\nerr_port:\r\nlist_for_each_entry_continue_reverse(p, &br->port_list, list) {\r\nif (!test_bit(p->port_no, changed))\r\ncontinue;\r\nif (old_pvid)\r\nnbp_vlan_add(p, old_pvid,\r\nBRIDGE_VLAN_INFO_PVID |\r\nBRIDGE_VLAN_INFO_UNTAGGED);\r\nnbp_vlan_delete(p, pvid);\r\n}\r\nif (test_bit(0, changed)) {\r\nif (old_pvid)\r\nbr_vlan_add(br, old_pvid,\r\nBRIDGE_VLAN_INFO_PVID |\r\nBRIDGE_VLAN_INFO_UNTAGGED |\r\nBRIDGE_VLAN_INFO_BRENTRY);\r\nbr_vlan_delete(br, pvid);\r\n}\r\ngoto out;\r\n}\r\nint br_vlan_set_default_pvid(struct net_bridge *br, unsigned long val)\r\n{\r\nu16 pvid = val;\r\nint err = 0;\r\nif (val >= VLAN_VID_MASK)\r\nreturn -EINVAL;\r\nif (pvid == br->default_pvid)\r\ngoto out;\r\nif (br->vlan_enabled) {\r\npr_info_once("Please disable vlan filtering to change default_pvid\n");\r\nerr = -EPERM;\r\ngoto out;\r\n}\r\nerr = __br_vlan_set_default_pvid(br, pvid);\r\nout:\r\nreturn err;\r\n}\r\nint br_vlan_init(struct net_bridge *br)\r\n{\r\nstruct net_bridge_vlan_group *vg;\r\nint ret = -ENOMEM;\r\nvg = kzalloc(sizeof(*vg), GFP_KERNEL);\r\nif (!vg)\r\ngoto out;\r\nret = rhashtable_init(&vg->vlan_hash, &br_vlan_rht_params);\r\nif (ret)\r\ngoto err_rhtbl;\r\nret = vlan_tunnel_init(vg);\r\nif (ret)\r\ngoto err_tunnel_init;\r\nINIT_LIST_HEAD(&vg->vlan_list);\r\nbr->vlan_proto = htons(ETH_P_8021Q);\r\nbr->default_pvid = 1;\r\nrcu_assign_pointer(br->vlgrp, vg);\r\nret = br_vlan_add(br, 1,\r\nBRIDGE_VLAN_INFO_PVID | BRIDGE_VLAN_INFO_UNTAGGED |\r\nBRIDGE_VLAN_INFO_BRENTRY);\r\nif (ret)\r\ngoto err_vlan_add;\r\nout:\r\nreturn ret;\r\nerr_vlan_add:\r\nvlan_tunnel_deinit(vg);\r\nerr_tunnel_init:\r\nrhashtable_destroy(&vg->vlan_hash);\r\nerr_rhtbl:\r\nkfree(vg);\r\ngoto out;\r\n}\r\nint nbp_vlan_init(struct net_bridge_port *p)\r\n{\r\nstruct switchdev_attr attr = {\r\n.orig_dev = p->br->dev,\r\n.id = SWITCHDEV_ATTR_ID_BRIDGE_VLAN_FILTERING,\r\n.flags = SWITCHDEV_F_SKIP_EOPNOTSUPP,\r\n.u.vlan_filtering = p->br->vlan_enabled,\r\n};\r\nstruct net_bridge_vlan_group *vg;\r\nint ret = -ENOMEM;\r\nvg = kzalloc(sizeof(struct net_bridge_vlan_group), GFP_KERNEL);\r\nif (!vg)\r\ngoto out;\r\nret = switchdev_port_attr_set(p->dev, &attr);\r\nif (ret && ret != -EOPNOTSUPP)\r\ngoto err_vlan_enabled;\r\nret = rhashtable_init(&vg->vlan_hash, &br_vlan_rht_params);\r\nif (ret)\r\ngoto err_rhtbl;\r\nret = vlan_tunnel_init(vg);\r\nif (ret)\r\ngoto err_tunnel_init;\r\nINIT_LIST_HEAD(&vg->vlan_list);\r\nrcu_assign_pointer(p->vlgrp, vg);\r\nif (p->br->default_pvid) {\r\nret = nbp_vlan_add(p, p->br->default_pvid,\r\nBRIDGE_VLAN_INFO_PVID |\r\nBRIDGE_VLAN_INFO_UNTAGGED);\r\nif (ret)\r\ngoto err_vlan_add;\r\n}\r\nout:\r\nreturn ret;\r\nerr_vlan_add:\r\nRCU_INIT_POINTER(p->vlgrp, NULL);\r\nsynchronize_rcu();\r\nvlan_tunnel_deinit(vg);\r\nerr_tunnel_init:\r\nrhashtable_destroy(&vg->vlan_hash);\r\nerr_rhtbl:\r\nerr_vlan_enabled:\r\nkfree(vg);\r\ngoto out;\r\n}\r\nint nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags)\r\n{\r\nstruct switchdev_obj_port_vlan v = {\r\n.obj.orig_dev = port->dev,\r\n.obj.id = SWITCHDEV_OBJ_ID_PORT_VLAN,\r\n.flags = flags,\r\n.vid_begin = vid,\r\n.vid_end = vid,\r\n};\r\nstruct net_bridge_vlan *vlan;\r\nint ret;\r\nASSERT_RTNL();\r\nvlan = br_vlan_find(nbp_vlan_group(port), vid);\r\nif (vlan) {\r\nret = switchdev_port_obj_add(port->dev, &v.obj);\r\nif (ret && ret != -EOPNOTSUPP)\r\nreturn ret;\r\n__vlan_add_flags(vlan, flags);\r\nreturn 0;\r\n}\r\nvlan = kzalloc(sizeof(*vlan), GFP_KERNEL);\r\nif (!vlan)\r\nreturn -ENOMEM;\r\nvlan->vid = vid;\r\nvlan->port = port;\r\nret = __vlan_add(vlan, flags);\r\nif (ret)\r\nkfree(vlan);\r\nreturn ret;\r\n}\r\nint nbp_vlan_delete(struct net_bridge_port *port, u16 vid)\r\n{\r\nstruct net_bridge_vlan *v;\r\nASSERT_RTNL();\r\nv = br_vlan_find(nbp_vlan_group(port), vid);\r\nif (!v)\r\nreturn -ENOENT;\r\nbr_fdb_find_delete_local(port->br, port, port->dev->dev_addr, vid);\r\nbr_fdb_delete_by_port(port->br, port, vid, 0);\r\nreturn __vlan_del(v);\r\n}\r\nvoid nbp_vlan_flush(struct net_bridge_port *port)\r\n{\r\nstruct net_bridge_vlan_group *vg;\r\nASSERT_RTNL();\r\nvg = nbp_vlan_group(port);\r\n__vlan_flush(vg);\r\nRCU_INIT_POINTER(port->vlgrp, NULL);\r\nsynchronize_rcu();\r\n__vlan_group_free(vg);\r\n}\r\nvoid br_vlan_get_stats(const struct net_bridge_vlan *v,\r\nstruct br_vlan_stats *stats)\r\n{\r\nint i;\r\nmemset(stats, 0, sizeof(*stats));\r\nfor_each_possible_cpu(i) {\r\nu64 rxpackets, rxbytes, txpackets, txbytes;\r\nstruct br_vlan_stats *cpu_stats;\r\nunsigned int start;\r\ncpu_stats = per_cpu_ptr(v->stats, i);\r\ndo {\r\nstart = u64_stats_fetch_begin_irq(&cpu_stats->syncp);\r\nrxpackets = cpu_stats->rx_packets;\r\nrxbytes = cpu_stats->rx_bytes;\r\ntxbytes = cpu_stats->tx_bytes;\r\ntxpackets = cpu_stats->tx_packets;\r\n} while (u64_stats_fetch_retry_irq(&cpu_stats->syncp, start));\r\nstats->rx_packets += rxpackets;\r\nstats->rx_bytes += rxbytes;\r\nstats->tx_bytes += txbytes;\r\nstats->tx_packets += txpackets;\r\n}\r\n}
