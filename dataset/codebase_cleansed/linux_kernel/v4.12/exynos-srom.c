static struct exynos_srom_reg_dump *exynos_srom_alloc_reg_dump(\r\nconst unsigned long *rdump,\r\nunsigned long nr_rdump)\r\n{\r\nstruct exynos_srom_reg_dump *rd;\r\nunsigned int i;\r\nrd = kcalloc(nr_rdump, sizeof(*rd), GFP_KERNEL);\r\nif (!rd)\r\nreturn NULL;\r\nfor (i = 0; i < nr_rdump; ++i)\r\nrd[i].offset = rdump[i];\r\nreturn rd;\r\n}\r\nstatic int exynos_srom_configure_bank(struct exynos_srom *srom,\r\nstruct device_node *np)\r\n{\r\nu32 bank, width, pmc = 0;\r\nu32 timing[6];\r\nu32 cs, bw;\r\nif (of_property_read_u32(np, "reg", &bank))\r\nreturn -EINVAL;\r\nif (of_property_read_u32(np, "reg-io-width", &width))\r\nwidth = 1;\r\nif (of_property_read_bool(np, "samsung,srom-page-mode"))\r\npmc = 1 << EXYNOS_SROM_BCX__PMC__SHIFT;\r\nif (of_property_read_u32_array(np, "samsung,srom-timing", timing,\r\nARRAY_SIZE(timing)))\r\nreturn -EINVAL;\r\nbank *= 4;\r\ncs = 1 << EXYNOS_SROM_BW__BYTEENABLE__SHIFT;\r\nif (width == 2)\r\ncs |= 1 << EXYNOS_SROM_BW__DATAWIDTH__SHIFT;\r\nbw = readl_relaxed(srom->reg_base + EXYNOS_SROM_BW);\r\nbw = (bw & ~(EXYNOS_SROM_BW__CS_MASK << bank)) | (cs << bank);\r\nwritel_relaxed(bw, srom->reg_base + EXYNOS_SROM_BW);\r\nwritel_relaxed(pmc | (timing[0] << EXYNOS_SROM_BCX__TACP__SHIFT) |\r\n(timing[1] << EXYNOS_SROM_BCX__TCAH__SHIFT) |\r\n(timing[2] << EXYNOS_SROM_BCX__TCOH__SHIFT) |\r\n(timing[3] << EXYNOS_SROM_BCX__TACC__SHIFT) |\r\n(timing[4] << EXYNOS_SROM_BCX__TCOS__SHIFT) |\r\n(timing[5] << EXYNOS_SROM_BCX__TACS__SHIFT),\r\nsrom->reg_base + EXYNOS_SROM_BC0 + bank);\r\nreturn 0;\r\n}\r\nstatic int exynos_srom_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np, *child;\r\nstruct exynos_srom *srom;\r\nstruct device *dev = &pdev->dev;\r\nbool bad_bank_config = false;\r\nnp = dev->of_node;\r\nif (!np) {\r\ndev_err(&pdev->dev, "could not find device info\n");\r\nreturn -EINVAL;\r\n}\r\nsrom = devm_kzalloc(&pdev->dev,\r\nsizeof(struct exynos_srom), GFP_KERNEL);\r\nif (!srom)\r\nreturn -ENOMEM;\r\nsrom->dev = dev;\r\nsrom->reg_base = of_iomap(np, 0);\r\nif (!srom->reg_base) {\r\ndev_err(&pdev->dev, "iomap of exynos srom controller failed\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, srom);\r\nsrom->reg_offset = exynos_srom_alloc_reg_dump(exynos_srom_offsets,\r\nARRAY_SIZE(exynos_srom_offsets));\r\nif (!srom->reg_offset) {\r\niounmap(srom->reg_base);\r\nreturn -ENOMEM;\r\n}\r\nfor_each_child_of_node(np, child) {\r\nif (exynos_srom_configure_bank(srom, child)) {\r\ndev_err(dev,\r\n"Could not decode bank configuration for %s\n",\r\nchild->name);\r\nbad_bank_config = true;\r\n}\r\n}\r\nif (bad_bank_config)\r\nreturn 0;\r\nreturn of_platform_populate(np, NULL, NULL, dev);\r\n}\r\nstatic void exynos_srom_save(void __iomem *base,\r\nstruct exynos_srom_reg_dump *rd,\r\nunsigned int num_regs)\r\n{\r\nfor (; num_regs > 0; --num_regs, ++rd)\r\nrd->value = readl(base + rd->offset);\r\n}\r\nstatic void exynos_srom_restore(void __iomem *base,\r\nconst struct exynos_srom_reg_dump *rd,\r\nunsigned int num_regs)\r\n{\r\nfor (; num_regs > 0; --num_regs, ++rd)\r\nwritel(rd->value, base + rd->offset);\r\n}\r\nstatic int exynos_srom_suspend(struct device *dev)\r\n{\r\nstruct exynos_srom *srom = dev_get_drvdata(dev);\r\nexynos_srom_save(srom->reg_base, srom->reg_offset,\r\nARRAY_SIZE(exynos_srom_offsets));\r\nreturn 0;\r\n}\r\nstatic int exynos_srom_resume(struct device *dev)\r\n{\r\nstruct exynos_srom *srom = dev_get_drvdata(dev);\r\nexynos_srom_restore(srom->reg_base, srom->reg_offset,\r\nARRAY_SIZE(exynos_srom_offsets));\r\nreturn 0;\r\n}
