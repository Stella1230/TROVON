bool torture_offline(int cpu, long *n_offl_attempts, long *n_offl_successes,\r\nunsigned long *sum_offl, int *min_offl, int *max_offl)\r\n{\r\nunsigned long delta;\r\nint ret;\r\nunsigned long starttime;\r\nif (!cpu_online(cpu) || !cpu_is_hotpluggable(cpu))\r\nreturn false;\r\nif (verbose)\r\npr_alert("%s" TORTURE_FLAG\r\n"torture_onoff task: offlining %d\n",\r\ntorture_type, cpu);\r\nstarttime = jiffies;\r\n(*n_offl_attempts)++;\r\nret = cpu_down(cpu);\r\nif (ret) {\r\nif (verbose)\r\npr_alert("%s" TORTURE_FLAG\r\n"torture_onoff task: offline %d failed: errno %d\n",\r\ntorture_type, cpu, ret);\r\n} else {\r\nif (verbose)\r\npr_alert("%s" TORTURE_FLAG\r\n"torture_onoff task: offlined %d\n",\r\ntorture_type, cpu);\r\n(*n_offl_successes)++;\r\ndelta = jiffies - starttime;\r\nsum_offl += delta;\r\nif (*min_offl < 0) {\r\n*min_offl = delta;\r\n*max_offl = delta;\r\n}\r\nif (*min_offl > delta)\r\n*min_offl = delta;\r\nif (*max_offl < delta)\r\n*max_offl = delta;\r\n}\r\nreturn true;\r\n}\r\nbool torture_online(int cpu, long *n_onl_attempts, long *n_onl_successes,\r\nunsigned long *sum_onl, int *min_onl, int *max_onl)\r\n{\r\nunsigned long delta;\r\nint ret;\r\nunsigned long starttime;\r\nif (cpu_online(cpu) || !cpu_is_hotpluggable(cpu))\r\nreturn false;\r\nif (verbose)\r\npr_alert("%s" TORTURE_FLAG\r\n"torture_onoff task: onlining %d\n",\r\ntorture_type, cpu);\r\nstarttime = jiffies;\r\n(*n_onl_attempts)++;\r\nret = cpu_up(cpu);\r\nif (ret) {\r\nif (verbose)\r\npr_alert("%s" TORTURE_FLAG\r\n"torture_onoff task: online %d failed: errno %d\n",\r\ntorture_type, cpu, ret);\r\n} else {\r\nif (verbose)\r\npr_alert("%s" TORTURE_FLAG\r\n"torture_onoff task: onlined %d\n",\r\ntorture_type, cpu);\r\n(*n_onl_successes)++;\r\ndelta = jiffies - starttime;\r\n*sum_onl += delta;\r\nif (*min_onl < 0) {\r\n*min_onl = delta;\r\n*max_onl = delta;\r\n}\r\nif (*min_onl > delta)\r\n*min_onl = delta;\r\nif (*max_onl < delta)\r\n*max_onl = delta;\r\n}\r\nreturn true;\r\n}\r\nstatic int\r\ntorture_onoff(void *arg)\r\n{\r\nint cpu;\r\nint maxcpu = -1;\r\nDEFINE_TORTURE_RANDOM(rand);\r\nVERBOSE_TOROUT_STRING("torture_onoff task started");\r\nfor_each_online_cpu(cpu)\r\nmaxcpu = cpu;\r\nWARN_ON(maxcpu < 0);\r\nif (maxcpu == 0) {\r\nVERBOSE_TOROUT_STRING("Only one CPU, so CPU-hotplug testing is disabled");\r\ngoto stop;\r\n}\r\nif (onoff_holdoff > 0) {\r\nVERBOSE_TOROUT_STRING("torture_onoff begin holdoff");\r\nschedule_timeout_interruptible(onoff_holdoff);\r\nVERBOSE_TOROUT_STRING("torture_onoff end holdoff");\r\n}\r\nwhile (!torture_must_stop()) {\r\ncpu = (torture_random(&rand) >> 4) % (maxcpu + 1);\r\nif (!torture_offline(cpu,\r\n&n_offline_attempts, &n_offline_successes,\r\n&sum_offline, &min_offline, &max_offline))\r\ntorture_online(cpu,\r\n&n_online_attempts, &n_online_successes,\r\n&sum_online, &min_online, &max_online);\r\nschedule_timeout_interruptible(onoff_interval);\r\n}\r\nstop:\r\ntorture_kthread_stopping("torture_onoff");\r\nreturn 0;\r\n}\r\nint torture_onoff_init(long ooholdoff, long oointerval)\r\n{\r\nint ret = 0;\r\n#ifdef CONFIG_HOTPLUG_CPU\r\nonoff_holdoff = ooholdoff;\r\nonoff_interval = oointerval;\r\nif (onoff_interval <= 0)\r\nreturn 0;\r\nret = torture_create_kthread(torture_onoff, NULL, onoff_task);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void torture_onoff_cleanup(void)\r\n{\r\n#ifdef CONFIG_HOTPLUG_CPU\r\nif (onoff_task == NULL)\r\nreturn;\r\nVERBOSE_TOROUT_STRING("Stopping torture_onoff task");\r\nkthread_stop(onoff_task);\r\nonoff_task = NULL;\r\n#endif\r\n}\r\nvoid torture_onoff_stats(void)\r\n{\r\n#ifdef CONFIG_HOTPLUG_CPU\r\npr_cont("onoff: %ld/%ld:%ld/%ld %d,%d:%d,%d %lu:%lu (HZ=%d) ",\r\nn_online_successes, n_online_attempts,\r\nn_offline_successes, n_offline_attempts,\r\nmin_online, max_online,\r\nmin_offline, max_offline,\r\nsum_online, sum_offline, HZ);\r\n#endif\r\n}\r\nbool torture_onoff_failures(void)\r\n{\r\n#ifdef CONFIG_HOTPLUG_CPU\r\nreturn n_online_successes != n_online_attempts ||\r\nn_offline_successes != n_offline_attempts;\r\n#else\r\nreturn false;\r\n#endif\r\n}\r\nunsigned long\r\ntorture_random(struct torture_random_state *trsp)\r\n{\r\nif (--trsp->trs_count < 0) {\r\ntrsp->trs_state += (unsigned long)local_clock();\r\ntrsp->trs_count = TORTURE_RANDOM_REFRESH;\r\n}\r\ntrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\r\nTORTURE_RANDOM_ADD;\r\nreturn swahw32(trsp->trs_state);\r\n}\r\nvoid torture_shuffle_task_register(struct task_struct *tp)\r\n{\r\nstruct shuffle_task *stp;\r\nif (WARN_ON_ONCE(tp == NULL))\r\nreturn;\r\nstp = kmalloc(sizeof(*stp), GFP_KERNEL);\r\nif (WARN_ON_ONCE(stp == NULL))\r\nreturn;\r\nstp->st_t = tp;\r\nmutex_lock(&shuffle_task_mutex);\r\nlist_add(&stp->st_l, &shuffle_task_list);\r\nmutex_unlock(&shuffle_task_mutex);\r\n}\r\nstatic void torture_shuffle_task_unregister_all(void)\r\n{\r\nstruct shuffle_task *stp;\r\nstruct shuffle_task *p;\r\nmutex_lock(&shuffle_task_mutex);\r\nlist_for_each_entry_safe(stp, p, &shuffle_task_list, st_l) {\r\nlist_del(&stp->st_l);\r\nkfree(stp);\r\n}\r\nmutex_unlock(&shuffle_task_mutex);\r\n}\r\nstatic void torture_shuffle_tasks(void)\r\n{\r\nstruct shuffle_task *stp;\r\ncpumask_setall(shuffle_tmp_mask);\r\nget_online_cpus();\r\nif (num_online_cpus() == 1) {\r\nput_online_cpus();\r\nreturn;\r\n}\r\nshuffle_idle_cpu = cpumask_next(shuffle_idle_cpu, shuffle_tmp_mask);\r\nif (shuffle_idle_cpu >= nr_cpu_ids)\r\nshuffle_idle_cpu = -1;\r\nelse\r\ncpumask_clear_cpu(shuffle_idle_cpu, shuffle_tmp_mask);\r\nmutex_lock(&shuffle_task_mutex);\r\nlist_for_each_entry(stp, &shuffle_task_list, st_l)\r\nset_cpus_allowed_ptr(stp->st_t, shuffle_tmp_mask);\r\nmutex_unlock(&shuffle_task_mutex);\r\nput_online_cpus();\r\n}\r\nstatic int torture_shuffle(void *arg)\r\n{\r\nVERBOSE_TOROUT_STRING("torture_shuffle task started");\r\ndo {\r\nschedule_timeout_interruptible(shuffle_interval);\r\ntorture_shuffle_tasks();\r\ntorture_shutdown_absorb("torture_shuffle");\r\n} while (!torture_must_stop());\r\ntorture_kthread_stopping("torture_shuffle");\r\nreturn 0;\r\n}\r\nint torture_shuffle_init(long shuffint)\r\n{\r\nshuffle_interval = shuffint;\r\nshuffle_idle_cpu = -1;\r\nif (!alloc_cpumask_var(&shuffle_tmp_mask, GFP_KERNEL)) {\r\nVERBOSE_TOROUT_ERRSTRING("Failed to alloc mask");\r\nreturn -ENOMEM;\r\n}\r\nreturn torture_create_kthread(torture_shuffle, NULL, shuffler_task);\r\n}\r\nstatic void torture_shuffle_cleanup(void)\r\n{\r\ntorture_shuffle_task_unregister_all();\r\nif (shuffler_task) {\r\nVERBOSE_TOROUT_STRING("Stopping torture_shuffle task");\r\nkthread_stop(shuffler_task);\r\nfree_cpumask_var(shuffle_tmp_mask);\r\n}\r\nshuffler_task = NULL;\r\n}\r\nvoid torture_shutdown_absorb(const char *title)\r\n{\r\nwhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\r\npr_notice("torture thread %s parking due to system shutdown\n",\r\ntitle);\r\nschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\r\n}\r\n}\r\nstatic int torture_shutdown(void *arg)\r\n{\r\nktime_t ktime_snap;\r\nVERBOSE_TOROUT_STRING("torture_shutdown task started");\r\nktime_snap = ktime_get();\r\nwhile (ktime_before(ktime_snap, shutdown_time) &&\r\n!torture_must_stop()) {\r\nif (verbose)\r\npr_alert("%s" TORTURE_FLAG\r\n"torture_shutdown task: %llu ms remaining\n",\r\ntorture_type,\r\nktime_ms_delta(shutdown_time, ktime_snap));\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_hrtimeout(&shutdown_time, HRTIMER_MODE_ABS);\r\nktime_snap = ktime_get();\r\n}\r\nif (torture_must_stop()) {\r\ntorture_kthread_stopping("torture_shutdown");\r\nreturn 0;\r\n}\r\nVERBOSE_TOROUT_STRING("torture_shutdown task shutting down system");\r\nshutdown_task = NULL;\r\nif (torture_shutdown_hook)\r\ntorture_shutdown_hook();\r\nelse\r\nVERBOSE_TOROUT_STRING("No torture_shutdown_hook(), skipping.");\r\nftrace_dump(DUMP_ALL);\r\nkernel_power_off();\r\nreturn 0;\r\n}\r\nint torture_shutdown_init(int ssecs, void (*cleanup)(void))\r\n{\r\nint ret = 0;\r\ntorture_shutdown_hook = cleanup;\r\nif (ssecs > 0) {\r\nshutdown_time = ktime_add(ktime_get(), ktime_set(ssecs, 0));\r\nret = torture_create_kthread(torture_shutdown, NULL,\r\nshutdown_task);\r\n}\r\nreturn ret;\r\n}\r\nstatic int torture_shutdown_notify(struct notifier_block *unused1,\r\nunsigned long unused2, void *unused3)\r\n{\r\nmutex_lock(&fullstop_mutex);\r\nif (READ_ONCE(fullstop) == FULLSTOP_DONTSTOP) {\r\nVERBOSE_TOROUT_STRING("Unscheduled system shutdown detected");\r\nWRITE_ONCE(fullstop, FULLSTOP_SHUTDOWN);\r\n} else {\r\npr_warn("Concurrent rmmod and shutdown illegal!\n");\r\n}\r\nmutex_unlock(&fullstop_mutex);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void torture_shutdown_cleanup(void)\r\n{\r\nunregister_reboot_notifier(&torture_shutdown_nb);\r\nif (shutdown_task != NULL) {\r\nVERBOSE_TOROUT_STRING("Stopping torture_shutdown task");\r\nkthread_stop(shutdown_task);\r\n}\r\nshutdown_task = NULL;\r\n}\r\nvoid stutter_wait(const char *title)\r\n{\r\ncond_resched_rcu_qs();\r\nwhile (READ_ONCE(stutter_pause_test) ||\r\n(torture_runnable && !READ_ONCE(*torture_runnable))) {\r\nif (stutter_pause_test)\r\nif (READ_ONCE(stutter_pause_test) == 1)\r\nschedule_timeout_interruptible(1);\r\nelse\r\nwhile (READ_ONCE(stutter_pause_test))\r\ncond_resched();\r\nelse\r\nschedule_timeout_interruptible(round_jiffies_relative(HZ));\r\ntorture_shutdown_absorb(title);\r\n}\r\n}\r\nstatic int torture_stutter(void *arg)\r\n{\r\nVERBOSE_TOROUT_STRING("torture_stutter task started");\r\ndo {\r\nif (!torture_must_stop()) {\r\nif (stutter > 1) {\r\nschedule_timeout_interruptible(stutter - 1);\r\nWRITE_ONCE(stutter_pause_test, 2);\r\n}\r\nschedule_timeout_interruptible(1);\r\nWRITE_ONCE(stutter_pause_test, 1);\r\n}\r\nif (!torture_must_stop())\r\nschedule_timeout_interruptible(stutter);\r\nWRITE_ONCE(stutter_pause_test, 0);\r\ntorture_shutdown_absorb("torture_stutter");\r\n} while (!torture_must_stop());\r\ntorture_kthread_stopping("torture_stutter");\r\nreturn 0;\r\n}\r\nint torture_stutter_init(int s)\r\n{\r\nint ret;\r\nstutter = s;\r\nret = torture_create_kthread(torture_stutter, NULL, stutter_task);\r\nreturn ret;\r\n}\r\nstatic void torture_stutter_cleanup(void)\r\n{\r\nif (!stutter_task)\r\nreturn;\r\nVERBOSE_TOROUT_STRING("Stopping torture_stutter task");\r\nkthread_stop(stutter_task);\r\nstutter_task = NULL;\r\n}\r\nbool torture_init_begin(char *ttype, bool v, int *runnable)\r\n{\r\nmutex_lock(&fullstop_mutex);\r\nif (torture_type != NULL) {\r\npr_alert("torture_init_begin: Refusing %s init: %s running.\n",\r\nttype, torture_type);\r\npr_alert("torture_init_begin: One torture test at a time!\n");\r\nmutex_unlock(&fullstop_mutex);\r\nreturn false;\r\n}\r\ntorture_type = ttype;\r\nverbose = v;\r\ntorture_runnable = runnable;\r\nfullstop = FULLSTOP_DONTSTOP;\r\nreturn true;\r\n}\r\nvoid torture_init_end(void)\r\n{\r\nmutex_unlock(&fullstop_mutex);\r\nregister_reboot_notifier(&torture_shutdown_nb);\r\n}\r\nbool torture_cleanup_begin(void)\r\n{\r\nmutex_lock(&fullstop_mutex);\r\nif (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\r\npr_warn("Concurrent rmmod and shutdown illegal!\n");\r\nmutex_unlock(&fullstop_mutex);\r\nschedule_timeout_uninterruptible(10);\r\nreturn true;\r\n}\r\nWRITE_ONCE(fullstop, FULLSTOP_RMMOD);\r\nmutex_unlock(&fullstop_mutex);\r\ntorture_shutdown_cleanup();\r\ntorture_shuffle_cleanup();\r\ntorture_stutter_cleanup();\r\ntorture_onoff_cleanup();\r\nreturn false;\r\n}\r\nvoid torture_cleanup_end(void)\r\n{\r\nmutex_lock(&fullstop_mutex);\r\ntorture_type = NULL;\r\nmutex_unlock(&fullstop_mutex);\r\n}\r\nbool torture_must_stop(void)\r\n{\r\nreturn torture_must_stop_irq() || kthread_should_stop();\r\n}\r\nbool torture_must_stop_irq(void)\r\n{\r\nreturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\r\n}\r\nvoid torture_kthread_stopping(char *title)\r\n{\r\nchar buf[128];\r\nsnprintf(buf, sizeof(buf), "Stopping %s", title);\r\nVERBOSE_TOROUT_STRING(buf);\r\nwhile (!kthread_should_stop()) {\r\ntorture_shutdown_absorb(title);\r\nschedule_timeout_uninterruptible(1);\r\n}\r\n}\r\nint _torture_create_kthread(int (*fn)(void *arg), void *arg, char *s, char *m,\r\nchar *f, struct task_struct **tp)\r\n{\r\nint ret = 0;\r\nVERBOSE_TOROUT_STRING(m);\r\n*tp = kthread_run(fn, arg, "%s", s);\r\nif (IS_ERR(*tp)) {\r\nret = PTR_ERR(*tp);\r\nVERBOSE_TOROUT_ERRSTRING(f);\r\n*tp = NULL;\r\n}\r\ntorture_shuffle_task_register(*tp);\r\nreturn ret;\r\n}\r\nvoid _torture_stop_kthread(char *m, struct task_struct **tp)\r\n{\r\nif (*tp == NULL)\r\nreturn;\r\nVERBOSE_TOROUT_STRING(m);\r\nkthread_stop(*tp);\r\n*tp = NULL;\r\n}
