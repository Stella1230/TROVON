static int __init enable_object_debug(char *str)\r\n{\r\ndebug_objects_enabled = 1;\r\nreturn 0;\r\n}\r\nstatic int __init disable_object_debug(char *str)\r\n{\r\ndebug_objects_enabled = 0;\r\nreturn 0;\r\n}\r\nstatic void fill_pool(void)\r\n{\r\ngfp_t gfp = GFP_ATOMIC | __GFP_NORETRY | __GFP_NOWARN;\r\nstruct debug_obj *new;\r\nunsigned long flags;\r\nif (likely(obj_pool_free >= debug_objects_pool_min_level))\r\nreturn;\r\nif (unlikely(!obj_cache))\r\nreturn;\r\nwhile (obj_pool_free < debug_objects_pool_min_level) {\r\nnew = kmem_cache_zalloc(obj_cache, gfp);\r\nif (!new)\r\nreturn;\r\nraw_spin_lock_irqsave(&pool_lock, flags);\r\nhlist_add_head(&new->node, &obj_pool);\r\ndebug_objects_allocated++;\r\nobj_pool_free++;\r\nraw_spin_unlock_irqrestore(&pool_lock, flags);\r\n}\r\n}\r\nstatic struct debug_obj *lookup_object(void *addr, struct debug_bucket *b)\r\n{\r\nstruct debug_obj *obj;\r\nint cnt = 0;\r\nhlist_for_each_entry(obj, &b->list, node) {\r\ncnt++;\r\nif (obj->object == addr)\r\nreturn obj;\r\n}\r\nif (cnt > debug_objects_maxchain)\r\ndebug_objects_maxchain = cnt;\r\nreturn NULL;\r\n}\r\nstatic struct debug_obj *\r\nalloc_object(void *addr, struct debug_bucket *b, struct debug_obj_descr *descr)\r\n{\r\nstruct debug_obj *obj = NULL;\r\nraw_spin_lock(&pool_lock);\r\nif (obj_pool.first) {\r\nobj = hlist_entry(obj_pool.first, typeof(*obj), node);\r\nobj->object = addr;\r\nobj->descr = descr;\r\nobj->state = ODEBUG_STATE_NONE;\r\nobj->astate = 0;\r\nhlist_del(&obj->node);\r\nhlist_add_head(&obj->node, &b->list);\r\nobj_pool_used++;\r\nif (obj_pool_used > obj_pool_max_used)\r\nobj_pool_max_used = obj_pool_used;\r\nobj_pool_free--;\r\nif (obj_pool_free < obj_pool_min_free)\r\nobj_pool_min_free = obj_pool_free;\r\n}\r\nraw_spin_unlock(&pool_lock);\r\nreturn obj;\r\n}\r\nstatic void free_obj_work(struct work_struct *work)\r\n{\r\nstruct debug_obj *objs[ODEBUG_FREE_BATCH];\r\nunsigned long flags;\r\nint i;\r\nif (!raw_spin_trylock_irqsave(&pool_lock, flags))\r\nreturn;\r\nwhile (obj_pool_free >= debug_objects_pool_size + ODEBUG_FREE_BATCH) {\r\nfor (i = 0; i < ODEBUG_FREE_BATCH; i++) {\r\nobjs[i] = hlist_entry(obj_pool.first,\r\ntypeof(*objs[0]), node);\r\nhlist_del(&objs[i]->node);\r\n}\r\nobj_pool_free -= ODEBUG_FREE_BATCH;\r\ndebug_objects_freed += ODEBUG_FREE_BATCH;\r\nraw_spin_unlock_irqrestore(&pool_lock, flags);\r\nfor (i = 0; i < ODEBUG_FREE_BATCH; i++)\r\nkmem_cache_free(obj_cache, objs[i]);\r\nif (!raw_spin_trylock_irqsave(&pool_lock, flags))\r\nreturn;\r\n}\r\nraw_spin_unlock_irqrestore(&pool_lock, flags);\r\n}\r\nstatic void free_object(struct debug_obj *obj)\r\n{\r\nunsigned long flags;\r\nint sched = 0;\r\nraw_spin_lock_irqsave(&pool_lock, flags);\r\nif (obj_pool_free > debug_objects_pool_size && obj_cache)\r\nsched = 1;\r\nhlist_add_head(&obj->node, &obj_pool);\r\nobj_pool_free++;\r\nobj_pool_used--;\r\nraw_spin_unlock_irqrestore(&pool_lock, flags);\r\nif (sched)\r\nschedule_work(&debug_obj_work);\r\n}\r\nstatic void debug_objects_oom(void)\r\n{\r\nstruct debug_bucket *db = obj_hash;\r\nstruct hlist_node *tmp;\r\nHLIST_HEAD(freelist);\r\nstruct debug_obj *obj;\r\nunsigned long flags;\r\nint i;\r\npr_warn("Out of memory. ODEBUG disabled\n");\r\nfor (i = 0; i < ODEBUG_HASH_SIZE; i++, db++) {\r\nraw_spin_lock_irqsave(&db->lock, flags);\r\nhlist_move_list(&db->list, &freelist);\r\nraw_spin_unlock_irqrestore(&db->lock, flags);\r\nhlist_for_each_entry_safe(obj, tmp, &freelist, node) {\r\nhlist_del(&obj->node);\r\nfree_object(obj);\r\n}\r\n}\r\n}\r\nstatic struct debug_bucket *get_bucket(unsigned long addr)\r\n{\r\nunsigned long hash;\r\nhash = hash_long((addr >> ODEBUG_CHUNK_SHIFT), ODEBUG_HASH_BITS);\r\nreturn &obj_hash[hash];\r\n}\r\nstatic void debug_print_object(struct debug_obj *obj, char *msg)\r\n{\r\nstruct debug_obj_descr *descr = obj->descr;\r\nstatic int limit;\r\nif (limit < 5 && descr != descr_test) {\r\nvoid *hint = descr->debug_hint ?\r\ndescr->debug_hint(obj->object) : NULL;\r\nlimit++;\r\nWARN(1, KERN_ERR "ODEBUG: %s %s (active state %u) "\r\n"object type: %s hint: %pS\n",\r\nmsg, obj_states[obj->state], obj->astate,\r\ndescr->name, hint);\r\n}\r\ndebug_objects_warnings++;\r\n}\r\nstatic bool\r\ndebug_object_fixup(bool (*fixup)(void *addr, enum debug_obj_state state),\r\nvoid * addr, enum debug_obj_state state)\r\n{\r\nif (fixup && fixup(addr, state)) {\r\ndebug_objects_fixups++;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void debug_object_is_on_stack(void *addr, int onstack)\r\n{\r\nint is_on_stack;\r\nstatic int limit;\r\nif (limit > 4)\r\nreturn;\r\nis_on_stack = object_is_on_stack(addr);\r\nif (is_on_stack == onstack)\r\nreturn;\r\nlimit++;\r\nif (is_on_stack)\r\npr_warn("object is on stack, but not annotated\n");\r\nelse\r\npr_warn("object is not on stack, but annotated\n");\r\nWARN_ON(1);\r\n}\r\nstatic void\r\n__debug_object_init(void *addr, struct debug_obj_descr *descr, int onstack)\r\n{\r\nenum debug_obj_state state;\r\nstruct debug_bucket *db;\r\nstruct debug_obj *obj;\r\nunsigned long flags;\r\nfill_pool();\r\ndb = get_bucket((unsigned long) addr);\r\nraw_spin_lock_irqsave(&db->lock, flags);\r\nobj = lookup_object(addr, db);\r\nif (!obj) {\r\nobj = alloc_object(addr, db, descr);\r\nif (!obj) {\r\ndebug_objects_enabled = 0;\r\nraw_spin_unlock_irqrestore(&db->lock, flags);\r\ndebug_objects_oom();\r\nreturn;\r\n}\r\ndebug_object_is_on_stack(addr, onstack);\r\n}\r\nswitch (obj->state) {\r\ncase ODEBUG_STATE_NONE:\r\ncase ODEBUG_STATE_INIT:\r\ncase ODEBUG_STATE_INACTIVE:\r\nobj->state = ODEBUG_STATE_INIT;\r\nbreak;\r\ncase ODEBUG_STATE_ACTIVE:\r\ndebug_print_object(obj, "init");\r\nstate = obj->state;\r\nraw_spin_unlock_irqrestore(&db->lock, flags);\r\ndebug_object_fixup(descr->fixup_init, addr, state);\r\nreturn;\r\ncase ODEBUG_STATE_DESTROYED:\r\ndebug_print_object(obj, "init");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nraw_spin_unlock_irqrestore(&db->lock, flags);\r\n}\r\nvoid debug_object_init(void *addr, struct debug_obj_descr *descr)\r\n{\r\nif (!debug_objects_enabled)\r\nreturn;\r\n__debug_object_init(addr, descr, 0);\r\n}\r\nvoid debug_object_init_on_stack(void *addr, struct debug_obj_descr *descr)\r\n{\r\nif (!debug_objects_enabled)\r\nreturn;\r\n__debug_object_init(addr, descr, 1);\r\n}\r\nint debug_object_activate(void *addr, struct debug_obj_descr *descr)\r\n{\r\nenum debug_obj_state state;\r\nstruct debug_bucket *db;\r\nstruct debug_obj *obj;\r\nunsigned long flags;\r\nint ret;\r\nstruct debug_obj o = { .object = addr,\r\n.state = ODEBUG_STATE_NOTAVAILABLE,\r\n.descr = descr };\r\nif (!debug_objects_enabled)\r\nreturn 0;\r\ndb = get_bucket((unsigned long) addr);\r\nraw_spin_lock_irqsave(&db->lock, flags);\r\nobj = lookup_object(addr, db);\r\nif (obj) {\r\nswitch (obj->state) {\r\ncase ODEBUG_STATE_INIT:\r\ncase ODEBUG_STATE_INACTIVE:\r\nobj->state = ODEBUG_STATE_ACTIVE;\r\nret = 0;\r\nbreak;\r\ncase ODEBUG_STATE_ACTIVE:\r\ndebug_print_object(obj, "activate");\r\nstate = obj->state;\r\nraw_spin_unlock_irqrestore(&db->lock, flags);\r\nret = debug_object_fixup(descr->fixup_activate, addr, state);\r\nreturn ret ? 0 : -EINVAL;\r\ncase ODEBUG_STATE_DESTROYED:\r\ndebug_print_object(obj, "activate");\r\nret = -EINVAL;\r\nbreak;\r\ndefault:\r\nret = 0;\r\nbreak;\r\n}\r\nraw_spin_unlock_irqrestore(&db->lock, flags);\r\nreturn ret;\r\n}\r\nraw_spin_unlock_irqrestore(&db->lock, flags);\r\nif (descr->is_static_object && descr->is_static_object(addr)) {\r\ndebug_object_init(addr, descr);\r\ndebug_object_activate(addr, descr);\r\n} else {\r\ndebug_print_object(&o, "activate");\r\nret = debug_object_fixup(descr->fixup_activate, addr,\r\nODEBUG_STATE_NOTAVAILABLE);\r\nreturn ret ? 0 : -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid debug_object_deactivate(void *addr, struct debug_obj_descr *descr)\r\n{\r\nstruct debug_bucket *db;\r\nstruct debug_obj *obj;\r\nunsigned long flags;\r\nif (!debug_objects_enabled)\r\nreturn;\r\ndb = get_bucket((unsigned long) addr);\r\nraw_spin_lock_irqsave(&db->lock, flags);\r\nobj = lookup_object(addr, db);\r\nif (obj) {\r\nswitch (obj->state) {\r\ncase ODEBUG_STATE_INIT:\r\ncase ODEBUG_STATE_INACTIVE:\r\ncase ODEBUG_STATE_ACTIVE:\r\nif (!obj->astate)\r\nobj->state = ODEBUG_STATE_INACTIVE;\r\nelse\r\ndebug_print_object(obj, "deactivate");\r\nbreak;\r\ncase ODEBUG_STATE_DESTROYED:\r\ndebug_print_object(obj, "deactivate");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nstruct debug_obj o = { .object = addr,\r\n.state = ODEBUG_STATE_NOTAVAILABLE,\r\n.descr = descr };\r\ndebug_print_object(&o, "deactivate");\r\n}\r\nraw_spin_unlock_irqrestore(&db->lock, flags);\r\n}\r\nvoid debug_object_destroy(void *addr, struct debug_obj_descr *descr)\r\n{\r\nenum debug_obj_state state;\r\nstruct debug_bucket *db;\r\nstruct debug_obj *obj;\r\nunsigned long flags;\r\nif (!debug_objects_enabled)\r\nreturn;\r\ndb = get_bucket((unsigned long) addr);\r\nraw_spin_lock_irqsave(&db->lock, flags);\r\nobj = lookup_object(addr, db);\r\nif (!obj)\r\ngoto out_unlock;\r\nswitch (obj->state) {\r\ncase ODEBUG_STATE_NONE:\r\ncase ODEBUG_STATE_INIT:\r\ncase ODEBUG_STATE_INACTIVE:\r\nobj->state = ODEBUG_STATE_DESTROYED;\r\nbreak;\r\ncase ODEBUG_STATE_ACTIVE:\r\ndebug_print_object(obj, "destroy");\r\nstate = obj->state;\r\nraw_spin_unlock_irqrestore(&db->lock, flags);\r\ndebug_object_fixup(descr->fixup_destroy, addr, state);\r\nreturn;\r\ncase ODEBUG_STATE_DESTROYED:\r\ndebug_print_object(obj, "destroy");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nout_unlock:\r\nraw_spin_unlock_irqrestore(&db->lock, flags);\r\n}\r\nvoid debug_object_free(void *addr, struct debug_obj_descr *descr)\r\n{\r\nenum debug_obj_state state;\r\nstruct debug_bucket *db;\r\nstruct debug_obj *obj;\r\nunsigned long flags;\r\nif (!debug_objects_enabled)\r\nreturn;\r\ndb = get_bucket((unsigned long) addr);\r\nraw_spin_lock_irqsave(&db->lock, flags);\r\nobj = lookup_object(addr, db);\r\nif (!obj)\r\ngoto out_unlock;\r\nswitch (obj->state) {\r\ncase ODEBUG_STATE_ACTIVE:\r\ndebug_print_object(obj, "free");\r\nstate = obj->state;\r\nraw_spin_unlock_irqrestore(&db->lock, flags);\r\ndebug_object_fixup(descr->fixup_free, addr, state);\r\nreturn;\r\ndefault:\r\nhlist_del(&obj->node);\r\nraw_spin_unlock_irqrestore(&db->lock, flags);\r\nfree_object(obj);\r\nreturn;\r\n}\r\nout_unlock:\r\nraw_spin_unlock_irqrestore(&db->lock, flags);\r\n}\r\nvoid debug_object_assert_init(void *addr, struct debug_obj_descr *descr)\r\n{\r\nstruct debug_bucket *db;\r\nstruct debug_obj *obj;\r\nunsigned long flags;\r\nif (!debug_objects_enabled)\r\nreturn;\r\ndb = get_bucket((unsigned long) addr);\r\nraw_spin_lock_irqsave(&db->lock, flags);\r\nobj = lookup_object(addr, db);\r\nif (!obj) {\r\nstruct debug_obj o = { .object = addr,\r\n.state = ODEBUG_STATE_NOTAVAILABLE,\r\n.descr = descr };\r\nraw_spin_unlock_irqrestore(&db->lock, flags);\r\nif (descr->is_static_object && descr->is_static_object(addr)) {\r\ndebug_object_init(addr, descr);\r\n} else {\r\ndebug_print_object(&o, "assert_init");\r\ndebug_object_fixup(descr->fixup_assert_init, addr,\r\nODEBUG_STATE_NOTAVAILABLE);\r\n}\r\nreturn;\r\n}\r\nraw_spin_unlock_irqrestore(&db->lock, flags);\r\n}\r\nvoid\r\ndebug_object_active_state(void *addr, struct debug_obj_descr *descr,\r\nunsigned int expect, unsigned int next)\r\n{\r\nstruct debug_bucket *db;\r\nstruct debug_obj *obj;\r\nunsigned long flags;\r\nif (!debug_objects_enabled)\r\nreturn;\r\ndb = get_bucket((unsigned long) addr);\r\nraw_spin_lock_irqsave(&db->lock, flags);\r\nobj = lookup_object(addr, db);\r\nif (obj) {\r\nswitch (obj->state) {\r\ncase ODEBUG_STATE_ACTIVE:\r\nif (obj->astate == expect)\r\nobj->astate = next;\r\nelse\r\ndebug_print_object(obj, "active_state");\r\nbreak;\r\ndefault:\r\ndebug_print_object(obj, "active_state");\r\nbreak;\r\n}\r\n} else {\r\nstruct debug_obj o = { .object = addr,\r\n.state = ODEBUG_STATE_NOTAVAILABLE,\r\n.descr = descr };\r\ndebug_print_object(&o, "active_state");\r\n}\r\nraw_spin_unlock_irqrestore(&db->lock, flags);\r\n}\r\nstatic void __debug_check_no_obj_freed(const void *address, unsigned long size)\r\n{\r\nunsigned long flags, oaddr, saddr, eaddr, paddr, chunks;\r\nstruct hlist_node *tmp;\r\nHLIST_HEAD(freelist);\r\nstruct debug_obj_descr *descr;\r\nenum debug_obj_state state;\r\nstruct debug_bucket *db;\r\nstruct debug_obj *obj;\r\nint cnt;\r\nsaddr = (unsigned long) address;\r\neaddr = saddr + size;\r\npaddr = saddr & ODEBUG_CHUNK_MASK;\r\nchunks = ((eaddr - paddr) + (ODEBUG_CHUNK_SIZE - 1));\r\nchunks >>= ODEBUG_CHUNK_SHIFT;\r\nfor (;chunks > 0; chunks--, paddr += ODEBUG_CHUNK_SIZE) {\r\ndb = get_bucket(paddr);\r\nrepeat:\r\ncnt = 0;\r\nraw_spin_lock_irqsave(&db->lock, flags);\r\nhlist_for_each_entry_safe(obj, tmp, &db->list, node) {\r\ncnt++;\r\noaddr = (unsigned long) obj->object;\r\nif (oaddr < saddr || oaddr >= eaddr)\r\ncontinue;\r\nswitch (obj->state) {\r\ncase ODEBUG_STATE_ACTIVE:\r\ndebug_print_object(obj, "free");\r\ndescr = obj->descr;\r\nstate = obj->state;\r\nraw_spin_unlock_irqrestore(&db->lock, flags);\r\ndebug_object_fixup(descr->fixup_free,\r\n(void *) oaddr, state);\r\ngoto repeat;\r\ndefault:\r\nhlist_del(&obj->node);\r\nhlist_add_head(&obj->node, &freelist);\r\nbreak;\r\n}\r\n}\r\nraw_spin_unlock_irqrestore(&db->lock, flags);\r\nhlist_for_each_entry_safe(obj, tmp, &freelist, node) {\r\nhlist_del(&obj->node);\r\nfree_object(obj);\r\n}\r\nif (cnt > debug_objects_maxchain)\r\ndebug_objects_maxchain = cnt;\r\n}\r\n}\r\nvoid debug_check_no_obj_freed(const void *address, unsigned long size)\r\n{\r\nif (debug_objects_enabled)\r\n__debug_check_no_obj_freed(address, size);\r\n}\r\nstatic int debug_stats_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "max_chain :%d\n", debug_objects_maxchain);\r\nseq_printf(m, "warnings :%d\n", debug_objects_warnings);\r\nseq_printf(m, "fixups :%d\n", debug_objects_fixups);\r\nseq_printf(m, "pool_free :%d\n", obj_pool_free);\r\nseq_printf(m, "pool_min_free :%d\n", obj_pool_min_free);\r\nseq_printf(m, "pool_used :%d\n", obj_pool_used);\r\nseq_printf(m, "pool_max_used :%d\n", obj_pool_max_used);\r\nseq_printf(m, "objs_allocated:%d\n", debug_objects_allocated);\r\nseq_printf(m, "objs_freed :%d\n", debug_objects_freed);\r\nreturn 0;\r\n}\r\nstatic int debug_stats_open(struct inode *inode, struct file *filp)\r\n{\r\nreturn single_open(filp, debug_stats_show, NULL);\r\n}\r\nstatic int __init debug_objects_init_debugfs(void)\r\n{\r\nstruct dentry *dbgdir, *dbgstats;\r\nif (!debug_objects_enabled)\r\nreturn 0;\r\ndbgdir = debugfs_create_dir("debug_objects", NULL);\r\nif (!dbgdir)\r\nreturn -ENOMEM;\r\ndbgstats = debugfs_create_file("stats", 0444, dbgdir, NULL,\r\n&debug_stats_fops);\r\nif (!dbgstats)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndebugfs_remove(dbgdir);\r\nreturn -ENOMEM;\r\n}\r\nstatic inline void debug_objects_init_debugfs(void) { }\r\nstatic bool __init is_static_object(void *addr)\r\n{\r\nstruct self_test *obj = addr;\r\nreturn obj->static_init;\r\n}\r\nstatic bool __init fixup_init(void *addr, enum debug_obj_state state)\r\n{\r\nstruct self_test *obj = addr;\r\nswitch (state) {\r\ncase ODEBUG_STATE_ACTIVE:\r\ndebug_object_deactivate(obj, &descr_type_test);\r\ndebug_object_init(obj, &descr_type_test);\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool __init fixup_activate(void *addr, enum debug_obj_state state)\r\n{\r\nstruct self_test *obj = addr;\r\nswitch (state) {\r\ncase ODEBUG_STATE_NOTAVAILABLE:\r\nreturn true;\r\ncase ODEBUG_STATE_ACTIVE:\r\ndebug_object_deactivate(obj, &descr_type_test);\r\ndebug_object_activate(obj, &descr_type_test);\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool __init fixup_destroy(void *addr, enum debug_obj_state state)\r\n{\r\nstruct self_test *obj = addr;\r\nswitch (state) {\r\ncase ODEBUG_STATE_ACTIVE:\r\ndebug_object_deactivate(obj, &descr_type_test);\r\ndebug_object_destroy(obj, &descr_type_test);\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool __init fixup_free(void *addr, enum debug_obj_state state)\r\n{\r\nstruct self_test *obj = addr;\r\nswitch (state) {\r\ncase ODEBUG_STATE_ACTIVE:\r\ndebug_object_deactivate(obj, &descr_type_test);\r\ndebug_object_free(obj, &descr_type_test);\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int __init\r\ncheck_results(void *addr, enum debug_obj_state state, int fixups, int warnings)\r\n{\r\nstruct debug_bucket *db;\r\nstruct debug_obj *obj;\r\nunsigned long flags;\r\nint res = -EINVAL;\r\ndb = get_bucket((unsigned long) addr);\r\nraw_spin_lock_irqsave(&db->lock, flags);\r\nobj = lookup_object(addr, db);\r\nif (!obj && state != ODEBUG_STATE_NONE) {\r\nWARN(1, KERN_ERR "ODEBUG: selftest object not found\n");\r\ngoto out;\r\n}\r\nif (obj && obj->state != state) {\r\nWARN(1, KERN_ERR "ODEBUG: selftest wrong state: %d != %d\n",\r\nobj->state, state);\r\ngoto out;\r\n}\r\nif (fixups != debug_objects_fixups) {\r\nWARN(1, KERN_ERR "ODEBUG: selftest fixups failed %d != %d\n",\r\nfixups, debug_objects_fixups);\r\ngoto out;\r\n}\r\nif (warnings != debug_objects_warnings) {\r\nWARN(1, KERN_ERR "ODEBUG: selftest warnings failed %d != %d\n",\r\nwarnings, debug_objects_warnings);\r\ngoto out;\r\n}\r\nres = 0;\r\nout:\r\nraw_spin_unlock_irqrestore(&db->lock, flags);\r\nif (res)\r\ndebug_objects_enabled = 0;\r\nreturn res;\r\n}\r\nstatic void __init debug_objects_selftest(void)\r\n{\r\nint fixups, oldfixups, warnings, oldwarnings;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nfixups = oldfixups = debug_objects_fixups;\r\nwarnings = oldwarnings = debug_objects_warnings;\r\ndescr_test = &descr_type_test;\r\ndebug_object_init(&obj, &descr_type_test);\r\nif (check_results(&obj, ODEBUG_STATE_INIT, fixups, warnings))\r\ngoto out;\r\ndebug_object_activate(&obj, &descr_type_test);\r\nif (check_results(&obj, ODEBUG_STATE_ACTIVE, fixups, warnings))\r\ngoto out;\r\ndebug_object_activate(&obj, &descr_type_test);\r\nif (check_results(&obj, ODEBUG_STATE_ACTIVE, ++fixups, ++warnings))\r\ngoto out;\r\ndebug_object_deactivate(&obj, &descr_type_test);\r\nif (check_results(&obj, ODEBUG_STATE_INACTIVE, fixups, warnings))\r\ngoto out;\r\ndebug_object_destroy(&obj, &descr_type_test);\r\nif (check_results(&obj, ODEBUG_STATE_DESTROYED, fixups, warnings))\r\ngoto out;\r\ndebug_object_init(&obj, &descr_type_test);\r\nif (check_results(&obj, ODEBUG_STATE_DESTROYED, fixups, ++warnings))\r\ngoto out;\r\ndebug_object_activate(&obj, &descr_type_test);\r\nif (check_results(&obj, ODEBUG_STATE_DESTROYED, fixups, ++warnings))\r\ngoto out;\r\ndebug_object_deactivate(&obj, &descr_type_test);\r\nif (check_results(&obj, ODEBUG_STATE_DESTROYED, fixups, ++warnings))\r\ngoto out;\r\ndebug_object_free(&obj, &descr_type_test);\r\nif (check_results(&obj, ODEBUG_STATE_NONE, fixups, warnings))\r\ngoto out;\r\nobj.static_init = 1;\r\ndebug_object_activate(&obj, &descr_type_test);\r\nif (check_results(&obj, ODEBUG_STATE_ACTIVE, fixups, warnings))\r\ngoto out;\r\ndebug_object_init(&obj, &descr_type_test);\r\nif (check_results(&obj, ODEBUG_STATE_INIT, ++fixups, ++warnings))\r\ngoto out;\r\ndebug_object_free(&obj, &descr_type_test);\r\nif (check_results(&obj, ODEBUG_STATE_NONE, fixups, warnings))\r\ngoto out;\r\n#ifdef CONFIG_DEBUG_OBJECTS_FREE\r\ndebug_object_init(&obj, &descr_type_test);\r\nif (check_results(&obj, ODEBUG_STATE_INIT, fixups, warnings))\r\ngoto out;\r\ndebug_object_activate(&obj, &descr_type_test);\r\nif (check_results(&obj, ODEBUG_STATE_ACTIVE, fixups, warnings))\r\ngoto out;\r\n__debug_check_no_obj_freed(&obj, sizeof(obj));\r\nif (check_results(&obj, ODEBUG_STATE_NONE, ++fixups, ++warnings))\r\ngoto out;\r\n#endif\r\npr_info("selftest passed\n");\r\nout:\r\ndebug_objects_fixups = oldfixups;\r\ndebug_objects_warnings = oldwarnings;\r\ndescr_test = NULL;\r\nlocal_irq_restore(flags);\r\n}\r\nstatic inline void debug_objects_selftest(void) { }\r\nvoid __init debug_objects_early_init(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ODEBUG_HASH_SIZE; i++)\r\nraw_spin_lock_init(&obj_hash[i].lock);\r\nfor (i = 0; i < ODEBUG_POOL_SIZE; i++)\r\nhlist_add_head(&obj_static_pool[i].node, &obj_pool);\r\n}\r\nstatic int __init debug_objects_replace_static_objects(void)\r\n{\r\nstruct debug_bucket *db = obj_hash;\r\nstruct hlist_node *tmp;\r\nstruct debug_obj *obj, *new;\r\nHLIST_HEAD(objects);\r\nint i, cnt = 0;\r\nfor (i = 0; i < ODEBUG_POOL_SIZE; i++) {\r\nobj = kmem_cache_zalloc(obj_cache, GFP_KERNEL);\r\nif (!obj)\r\ngoto free;\r\nhlist_add_head(&obj->node, &objects);\r\n}\r\nlocal_irq_disable();\r\nhlist_for_each_entry_safe(obj, tmp, &obj_pool, node)\r\nhlist_del(&obj->node);\r\nhlist_move_list(&objects, &obj_pool);\r\nfor (i = 0; i < ODEBUG_HASH_SIZE; i++, db++) {\r\nhlist_move_list(&db->list, &objects);\r\nhlist_for_each_entry(obj, &objects, node) {\r\nnew = hlist_entry(obj_pool.first, typeof(*obj), node);\r\nhlist_del(&new->node);\r\n*new = *obj;\r\nhlist_add_head(&new->node, &db->list);\r\ncnt++;\r\n}\r\n}\r\nlocal_irq_enable();\r\npr_debug("%d of %d active objects replaced\n",\r\ncnt, obj_pool_used);\r\nreturn 0;\r\nfree:\r\nhlist_for_each_entry_safe(obj, tmp, &objects, node) {\r\nhlist_del(&obj->node);\r\nkmem_cache_free(obj_cache, obj);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nvoid __init debug_objects_mem_init(void)\r\n{\r\nif (!debug_objects_enabled)\r\nreturn;\r\nobj_cache = kmem_cache_create("debug_objects_cache",\r\nsizeof (struct debug_obj), 0,\r\nSLAB_DEBUG_OBJECTS, NULL);\r\nif (!obj_cache || debug_objects_replace_static_objects()) {\r\ndebug_objects_enabled = 0;\r\nif (obj_cache)\r\nkmem_cache_destroy(obj_cache);\r\npr_warn("out of memory.\n");\r\n} else\r\ndebug_objects_selftest();\r\ndebug_objects_pool_size += num_possible_cpus() * 32;\r\ndebug_objects_pool_min_level += num_possible_cpus() * 4;\r\n}
