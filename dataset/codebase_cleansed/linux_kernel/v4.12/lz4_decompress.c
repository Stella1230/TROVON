static FORCE_INLINE int LZ4_decompress_generic(\r\nconst char * const source,\r\nchar * const dest,\r\nint inputSize,\r\nint outputSize,\r\nint endOnInput,\r\nint partialDecoding,\r\nint targetOutputSize,\r\nint dict,\r\nconst BYTE * const lowPrefix,\r\nconst BYTE * const dictStart,\r\nconst size_t dictSize\r\n)\r\n{\r\nconst BYTE *ip = (const BYTE *) source;\r\nconst BYTE * const iend = ip + inputSize;\r\nBYTE *op = (BYTE *) dest;\r\nBYTE * const oend = op + outputSize;\r\nBYTE *cpy;\r\nBYTE *oexit = op + targetOutputSize;\r\nconst BYTE * const lowLimit = lowPrefix - dictSize;\r\nconst BYTE * const dictEnd = (const BYTE *)dictStart + dictSize;\r\nconst unsigned int dec32table[] = { 0, 1, 2, 1, 4, 4, 4, 4 };\r\nconst int dec64table[] = { 0, 0, 0, -1, 0, 1, 2, 3 };\r\nconst int safeDecode = (endOnInput == endOnInputSize);\r\nconst int checkOffset = ((safeDecode) && (dictSize < (int)(64 * KB)));\r\nif ((partialDecoding) && (oexit > oend - MFLIMIT))\r\noexit = oend - MFLIMIT;\r\nif ((endOnInput) && (unlikely(outputSize == 0)))\r\nreturn ((inputSize == 1) && (*ip == 0)) ? 0 : -1;\r\nif ((!endOnInput) && (unlikely(outputSize == 0)))\r\nreturn (*ip == 0 ? 1 : -1);\r\nwhile (1) {\r\nsize_t length;\r\nconst BYTE *match;\r\nsize_t offset;\r\nunsigned int const token = *ip++;\r\nlength = token>>ML_BITS;\r\nif (length == RUN_MASK) {\r\nunsigned int s;\r\ndo {\r\ns = *ip++;\r\nlength += s;\r\n} while (likely(endOnInput\r\n? ip < iend - RUN_MASK\r\n: 1) & (s == 255));\r\nif ((safeDecode)\r\n&& unlikely(\r\n(size_t)(op + length) < (size_t)(op))) {\r\ngoto _output_error;\r\n}\r\nif ((safeDecode)\r\n&& unlikely(\r\n(size_t)(ip + length) < (size_t)(ip))) {\r\ngoto _output_error;\r\n}\r\n}\r\ncpy = op + length;\r\nif (((endOnInput) && ((cpy > (partialDecoding ? oexit : oend - MFLIMIT))\r\n|| (ip + length > iend - (2 + 1 + LASTLITERALS))))\r\n|| ((!endOnInput) && (cpy > oend - WILDCOPYLENGTH))) {\r\nif (partialDecoding) {\r\nif (cpy > oend) {\r\ngoto _output_error;\r\n}\r\nif ((endOnInput)\r\n&& (ip + length > iend)) {\r\ngoto _output_error;\r\n}\r\n} else {\r\nif ((!endOnInput)\r\n&& (cpy != oend)) {\r\ngoto _output_error;\r\n}\r\nif ((endOnInput)\r\n&& ((ip + length != iend)\r\n|| (cpy > oend))) {\r\ngoto _output_error;\r\n}\r\n}\r\nmemcpy(op, ip, length);\r\nip += length;\r\nop += length;\r\nbreak;\r\n}\r\nLZ4_wildCopy(op, ip, cpy);\r\nip += length;\r\nop = cpy;\r\noffset = LZ4_readLE16(ip);\r\nip += 2;\r\nmatch = op - offset;\r\nif ((checkOffset) && (unlikely(match < lowLimit))) {\r\ngoto _output_error;\r\n}\r\nLZ4_write32(op, (U32)offset);\r\nlength = token & ML_MASK;\r\nif (length == ML_MASK) {\r\nunsigned int s;\r\ndo {\r\ns = *ip++;\r\nif ((endOnInput) && (ip > iend - LASTLITERALS))\r\ngoto _output_error;\r\nlength += s;\r\n} while (s == 255);\r\nif ((safeDecode)\r\n&& unlikely(\r\n(size_t)(op + length) < (size_t)op)) {\r\ngoto _output_error;\r\n}\r\n}\r\nlength += MINMATCH;\r\nif ((dict == usingExtDict) && (match < lowPrefix)) {\r\nif (unlikely(op + length > oend - LASTLITERALS)) {\r\ngoto _output_error;\r\n}\r\nif (length <= (size_t)(lowPrefix - match)) {\r\nmemmove(op, dictEnd - (lowPrefix - match),\r\nlength);\r\nop += length;\r\n} else {\r\nsize_t const copySize = (size_t)(lowPrefix - match);\r\nsize_t const restSize = length - copySize;\r\nmemcpy(op, dictEnd - copySize, copySize);\r\nop += copySize;\r\nif (restSize > (size_t)(op - lowPrefix)) {\r\nBYTE * const endOfMatch = op + restSize;\r\nconst BYTE *copyFrom = lowPrefix;\r\nwhile (op < endOfMatch)\r\n*op++ = *copyFrom++;\r\n} else {\r\nmemcpy(op, lowPrefix, restSize);\r\nop += restSize;\r\n}\r\n}\r\ncontinue;\r\n}\r\ncpy = op + length;\r\nif (unlikely(offset < 8)) {\r\nconst int dec64 = dec64table[offset];\r\nop[0] = match[0];\r\nop[1] = match[1];\r\nop[2] = match[2];\r\nop[3] = match[3];\r\nmatch += dec32table[offset];\r\nmemcpy(op + 4, match, 4);\r\nmatch -= dec64;\r\n} else {\r\nLZ4_copy8(op, match);\r\nmatch += 8;\r\n}\r\nop += 8;\r\nif (unlikely(cpy > oend - 12)) {\r\nBYTE * const oCopyLimit = oend - (WILDCOPYLENGTH - 1);\r\nif (cpy > oend - LASTLITERALS) {\r\ngoto _output_error;\r\n}\r\nif (op < oCopyLimit) {\r\nLZ4_wildCopy(op, match, oCopyLimit);\r\nmatch += oCopyLimit - op;\r\nop = oCopyLimit;\r\n}\r\nwhile (op < cpy)\r\n*op++ = *match++;\r\n} else {\r\nLZ4_copy8(op, match);\r\nif (length > 16)\r\nLZ4_wildCopy(op + 8, match + 8, cpy);\r\n}\r\nop = cpy;\r\n}\r\nif (endOnInput) {\r\nreturn (int) (((char *)op) - dest);\r\n} else {\r\nreturn (int) (((const char *)ip) - source);\r\n}\r\n_output_error:\r\nreturn -1;\r\n}\r\nint LZ4_decompress_safe(const char *source, char *dest,\r\nint compressedSize, int maxDecompressedSize)\r\n{\r\nreturn LZ4_decompress_generic(source, dest, compressedSize,\r\nmaxDecompressedSize, endOnInputSize, full, 0,\r\nnoDict, (BYTE *)dest, NULL, 0);\r\n}\r\nint LZ4_decompress_safe_partial(const char *source, char *dest,\r\nint compressedSize, int targetOutputSize, int maxDecompressedSize)\r\n{\r\nreturn LZ4_decompress_generic(source, dest, compressedSize,\r\nmaxDecompressedSize, endOnInputSize, partial,\r\ntargetOutputSize, noDict, (BYTE *)dest, NULL, 0);\r\n}\r\nint LZ4_decompress_fast(const char *source, char *dest, int originalSize)\r\n{\r\nreturn LZ4_decompress_generic(source, dest, 0, originalSize,\r\nendOnOutputSize, full, 0, withPrefix64k,\r\n(BYTE *)(dest - 64 * KB), NULL, 64 * KB);\r\n}\r\nint LZ4_setStreamDecode(LZ4_streamDecode_t *LZ4_streamDecode,\r\nconst char *dictionary, int dictSize)\r\n{\r\nLZ4_streamDecode_t_internal *lz4sd = (LZ4_streamDecode_t_internal *) LZ4_streamDecode;\r\nlz4sd->prefixSize = (size_t) dictSize;\r\nlz4sd->prefixEnd = (const BYTE *) dictionary + dictSize;\r\nlz4sd->externalDict = NULL;\r\nlz4sd->extDictSize = 0;\r\nreturn 1;\r\n}\r\nint LZ4_decompress_safe_continue(LZ4_streamDecode_t *LZ4_streamDecode,\r\nconst char *source, char *dest, int compressedSize, int maxOutputSize)\r\n{\r\nLZ4_streamDecode_t_internal *lz4sd = &LZ4_streamDecode->internal_donotuse;\r\nint result;\r\nif (lz4sd->prefixEnd == (BYTE *)dest) {\r\nresult = LZ4_decompress_generic(source, dest,\r\ncompressedSize,\r\nmaxOutputSize,\r\nendOnInputSize, full, 0,\r\nusingExtDict, lz4sd->prefixEnd - lz4sd->prefixSize,\r\nlz4sd->externalDict,\r\nlz4sd->extDictSize);\r\nif (result <= 0)\r\nreturn result;\r\nlz4sd->prefixSize += result;\r\nlz4sd->prefixEnd += result;\r\n} else {\r\nlz4sd->extDictSize = lz4sd->prefixSize;\r\nlz4sd->externalDict = lz4sd->prefixEnd - lz4sd->extDictSize;\r\nresult = LZ4_decompress_generic(source, dest,\r\ncompressedSize, maxOutputSize,\r\nendOnInputSize, full, 0,\r\nusingExtDict, (BYTE *)dest,\r\nlz4sd->externalDict, lz4sd->extDictSize);\r\nif (result <= 0)\r\nreturn result;\r\nlz4sd->prefixSize = result;\r\nlz4sd->prefixEnd = (BYTE *)dest + result;\r\n}\r\nreturn result;\r\n}\r\nint LZ4_decompress_fast_continue(LZ4_streamDecode_t *LZ4_streamDecode,\r\nconst char *source, char *dest, int originalSize)\r\n{\r\nLZ4_streamDecode_t_internal *lz4sd = &LZ4_streamDecode->internal_donotuse;\r\nint result;\r\nif (lz4sd->prefixEnd == (BYTE *)dest) {\r\nresult = LZ4_decompress_generic(source, dest, 0, originalSize,\r\nendOnOutputSize, full, 0,\r\nusingExtDict,\r\nlz4sd->prefixEnd - lz4sd->prefixSize,\r\nlz4sd->externalDict, lz4sd->extDictSize);\r\nif (result <= 0)\r\nreturn result;\r\nlz4sd->prefixSize += originalSize;\r\nlz4sd->prefixEnd += originalSize;\r\n} else {\r\nlz4sd->extDictSize = lz4sd->prefixSize;\r\nlz4sd->externalDict = lz4sd->prefixEnd - lz4sd->extDictSize;\r\nresult = LZ4_decompress_generic(source, dest, 0, originalSize,\r\nendOnOutputSize, full, 0,\r\nusingExtDict, (BYTE *)dest,\r\nlz4sd->externalDict, lz4sd->extDictSize);\r\nif (result <= 0)\r\nreturn result;\r\nlz4sd->prefixSize = originalSize;\r\nlz4sd->prefixEnd = (BYTE *)dest + originalSize;\r\n}\r\nreturn result;\r\n}\r\nstatic FORCE_INLINE int LZ4_decompress_usingDict_generic(const char *source,\r\nchar *dest, int compressedSize, int maxOutputSize, int safe,\r\nconst char *dictStart, int dictSize)\r\n{\r\nif (dictSize == 0)\r\nreturn LZ4_decompress_generic(source, dest,\r\ncompressedSize, maxOutputSize, safe, full, 0,\r\nnoDict, (BYTE *)dest, NULL, 0);\r\nif (dictStart + dictSize == dest) {\r\nif (dictSize >= (int)(64 * KB - 1))\r\nreturn LZ4_decompress_generic(source, dest,\r\ncompressedSize, maxOutputSize, safe, full, 0,\r\nwithPrefix64k, (BYTE *)dest - 64 * KB, NULL, 0);\r\nreturn LZ4_decompress_generic(source, dest, compressedSize,\r\nmaxOutputSize, safe, full, 0, noDict,\r\n(BYTE *)dest - dictSize, NULL, 0);\r\n}\r\nreturn LZ4_decompress_generic(source, dest, compressedSize,\r\nmaxOutputSize, safe, full, 0, usingExtDict,\r\n(BYTE *)dest, (const BYTE *)dictStart, dictSize);\r\n}\r\nint LZ4_decompress_safe_usingDict(const char *source, char *dest,\r\nint compressedSize, int maxOutputSize,\r\nconst char *dictStart, int dictSize)\r\n{\r\nreturn LZ4_decompress_usingDict_generic(source, dest,\r\ncompressedSize, maxOutputSize, 1, dictStart, dictSize);\r\n}\r\nint LZ4_decompress_fast_usingDict(const char *source, char *dest,\r\nint originalSize, const char *dictStart, int dictSize)\r\n{\r\nreturn LZ4_decompress_usingDict_generic(source, dest, 0,\r\noriginalSize, 0, dictStart, dictSize);\r\n}
