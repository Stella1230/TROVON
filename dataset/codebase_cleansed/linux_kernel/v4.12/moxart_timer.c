static inline struct moxart_timer *to_moxart(struct clock_event_device *evt)\r\n{\r\nreturn container_of(evt, struct moxart_timer, clkevt);\r\n}\r\nstatic inline void moxart_disable(struct clock_event_device *evt)\r\n{\r\nstruct moxart_timer *timer = to_moxart(evt);\r\nwritel(timer->t1_disable_val, timer->base + TIMER_CR);\r\n}\r\nstatic inline void moxart_enable(struct clock_event_device *evt)\r\n{\r\nstruct moxart_timer *timer = to_moxart(evt);\r\nwritel(timer->t1_enable_val, timer->base + TIMER_CR);\r\n}\r\nstatic int moxart_shutdown(struct clock_event_device *evt)\r\n{\r\nmoxart_disable(evt);\r\nreturn 0;\r\n}\r\nstatic int moxart_set_oneshot(struct clock_event_device *evt)\r\n{\r\nmoxart_disable(evt);\r\nwritel(~0, to_moxart(evt)->base + TIMER1_BASE + REG_LOAD);\r\nreturn 0;\r\n}\r\nstatic int moxart_set_periodic(struct clock_event_device *evt)\r\n{\r\nstruct moxart_timer *timer = to_moxart(evt);\r\nmoxart_disable(evt);\r\nwritel(timer->count_per_tick, timer->base + TIMER1_BASE + REG_LOAD);\r\nwritel(0, timer->base + TIMER1_BASE + REG_MATCH1);\r\nmoxart_enable(evt);\r\nreturn 0;\r\n}\r\nstatic int moxart_clkevt_next_event(unsigned long cycles,\r\nstruct clock_event_device *evt)\r\n{\r\nstruct moxart_timer *timer = to_moxart(evt);\r\nu32 u;\r\nmoxart_disable(evt);\r\nu = readl(timer->base + TIMER1_BASE + REG_COUNT) - cycles;\r\nwritel(u, timer->base + TIMER1_BASE + REG_MATCH1);\r\nmoxart_enable(evt);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t moxart_timer_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = dev_id;\r\nevt->event_handler(evt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init moxart_timer_init(struct device_node *node)\r\n{\r\nint ret, irq;\r\nunsigned long pclk;\r\nstruct clk *clk;\r\nstruct moxart_timer *timer;\r\ntimer = kzalloc(sizeof(*timer), GFP_KERNEL);\r\nif (!timer)\r\nreturn -ENOMEM;\r\ntimer->base = of_iomap(node, 0);\r\nif (!timer->base) {\r\npr_err("%s: of_iomap failed\n", node->full_name);\r\nret = -ENXIO;\r\ngoto out_free;\r\n}\r\nirq = irq_of_parse_and_map(node, 0);\r\nif (irq <= 0) {\r\npr_err("%s: irq_of_parse_and_map failed\n", node->full_name);\r\nret = -EINVAL;\r\ngoto out_unmap;\r\n}\r\nclk = of_clk_get(node, 0);\r\nif (IS_ERR(clk)) {\r\npr_err("%s: of_clk_get failed\n", node->full_name);\r\nret = PTR_ERR(clk);\r\ngoto out_unmap;\r\n}\r\npclk = clk_get_rate(clk);\r\nif (of_device_is_compatible(node, "moxa,moxart-timer")) {\r\ntimer->t1_enable_val = MOXART_TIMER1_ENABLE;\r\ntimer->t1_disable_val = MOXART_TIMER1_DISABLE;\r\n} else if (of_device_is_compatible(node, "aspeed,ast2400-timer")) {\r\ntimer->t1_enable_val = ASPEED_TIMER1_ENABLE;\r\ntimer->t1_disable_val = ASPEED_TIMER1_DISABLE;\r\n} else {\r\npr_err("%s: unknown platform\n", node->full_name);\r\nret = -EINVAL;\r\ngoto out_unmap;\r\n}\r\ntimer->count_per_tick = DIV_ROUND_CLOSEST(pclk, HZ);\r\ntimer->clkevt.name = node->name;\r\ntimer->clkevt.rating = 200;\r\ntimer->clkevt.features = CLOCK_EVT_FEAT_PERIODIC |\r\nCLOCK_EVT_FEAT_ONESHOT;\r\ntimer->clkevt.set_state_shutdown = moxart_shutdown;\r\ntimer->clkevt.set_state_periodic = moxart_set_periodic;\r\ntimer->clkevt.set_state_oneshot = moxart_set_oneshot;\r\ntimer->clkevt.tick_resume = moxart_set_oneshot;\r\ntimer->clkevt.set_next_event = moxart_clkevt_next_event;\r\ntimer->clkevt.cpumask = cpumask_of(0);\r\ntimer->clkevt.irq = irq;\r\nret = clocksource_mmio_init(timer->base + TIMER2_BASE + REG_COUNT,\r\n"moxart_timer", pclk, 200, 32,\r\nclocksource_mmio_readl_down);\r\nif (ret) {\r\npr_err("%s: clocksource_mmio_init failed\n", node->full_name);\r\ngoto out_unmap;\r\n}\r\nret = request_irq(irq, moxart_timer_interrupt, IRQF_TIMER,\r\nnode->name, &timer->clkevt);\r\nif (ret) {\r\npr_err("%s: setup_irq failed\n", node->full_name);\r\ngoto out_unmap;\r\n}\r\nwritel(0, timer->base + TIMER1_BASE + REG_MATCH1);\r\nwritel(0, timer->base + TIMER1_BASE + REG_MATCH2);\r\nwritel(0, timer->base + TIMER2_BASE + REG_MATCH1);\r\nwritel(0, timer->base + TIMER2_BASE + REG_MATCH2);\r\nwritel(0, timer->base + TIMER_CR);\r\nwritel(~0, timer->base + TIMER2_BASE + REG_LOAD);\r\nwritel(timer->t1_disable_val, timer->base + TIMER_CR);\r\nclockevents_config_and_register(&timer->clkevt, pclk, 0x4, 0xfffffffe);\r\nreturn 0;\r\nout_unmap:\r\niounmap(timer->base);\r\nout_free:\r\nkfree(timer);\r\nreturn ret;\r\n}
