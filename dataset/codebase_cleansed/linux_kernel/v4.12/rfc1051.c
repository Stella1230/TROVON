static int __init arcnet_rfc1051_init(void)\r\n{\r\npr_info("%s\n", "RFC1051 \"simple standard\" (`s') encapsulation support loaded");\r\narc_proto_map[ARC_P_IP_RFC1051]\r\n= arc_proto_map[ARC_P_ARP_RFC1051]\r\n= &rfc1051_proto;\r\nif (arc_bcast_proto == arc_proto_default)\r\narc_bcast_proto = &rfc1051_proto;\r\nreturn 0;\r\n}\r\nstatic void __exit arcnet_rfc1051_exit(void)\r\n{\r\narcnet_unregister_proto(&rfc1051_proto);\r\n}\r\nstatic __be16 type_trans(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct archdr *pkt = (struct archdr *)skb->data;\r\nstruct arc_rfc1051 *soft = &pkt->soft.rfc1051;\r\nint hdr_size = ARC_HDR_SIZE + RFC1051_HDR_SIZE;\r\nskb_reset_mac_header(skb);\r\nskb_pull(skb, hdr_size);\r\nif (pkt->hard.dest == 0) {\r\nskb->pkt_type = PACKET_BROADCAST;\r\n} else if (dev->flags & IFF_PROMISC) {\r\nif (pkt->hard.dest != dev->dev_addr[0])\r\nskb->pkt_type = PACKET_OTHERHOST;\r\n}\r\nswitch (soft->proto) {\r\ncase ARC_P_IP_RFC1051:\r\nreturn htons(ETH_P_IP);\r\ncase ARC_P_ARP_RFC1051:\r\nreturn htons(ETH_P_ARP);\r\ndefault:\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_crc_errors++;\r\nreturn 0;\r\n}\r\nreturn htons(ETH_P_IP);\r\n}\r\nstatic void rx(struct net_device *dev, int bufnum,\r\nstruct archdr *pkthdr, int length)\r\n{\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nstruct sk_buff *skb;\r\nstruct archdr *pkt = pkthdr;\r\nint ofs;\r\narc_printk(D_DURING, dev, "it's a raw packet (length=%d)\n", length);\r\nif (length >= MinTU)\r\nofs = 512 - length;\r\nelse\r\nofs = 256 - length;\r\nskb = alloc_skb(length + ARC_HDR_SIZE, GFP_ATOMIC);\r\nif (!skb) {\r\ndev->stats.rx_dropped++;\r\nreturn;\r\n}\r\nskb_put(skb, length + ARC_HDR_SIZE);\r\nskb->dev = dev;\r\npkt = (struct archdr *)skb->data;\r\nmemcpy(pkt, pkthdr, sizeof(struct archdr));\r\nif (length > sizeof(pkt->soft))\r\nlp->hw.copy_from_card(dev, bufnum, ofs + sizeof(pkt->soft),\r\npkt->soft.raw + sizeof(pkt->soft),\r\nlength - sizeof(pkt->soft));\r\nif (BUGLVL(D_SKB))\r\narcnet_dump_skb(dev, skb, "rx");\r\nskb->protocol = type_trans(skb, dev);\r\nnetif_rx(skb);\r\n}\r\nstatic int build_header(struct sk_buff *skb, struct net_device *dev,\r\nunsigned short type, uint8_t daddr)\r\n{\r\nint hdr_size = ARC_HDR_SIZE + RFC1051_HDR_SIZE;\r\nstruct archdr *pkt = (struct archdr *)skb_push(skb, hdr_size);\r\nstruct arc_rfc1051 *soft = &pkt->soft.rfc1051;\r\nswitch (type) {\r\ncase ETH_P_IP:\r\nsoft->proto = ARC_P_IP_RFC1051;\r\nbreak;\r\ncase ETH_P_ARP:\r\nsoft->proto = ARC_P_ARP_RFC1051;\r\nbreak;\r\ndefault:\r\narc_printk(D_NORMAL, dev, "RFC1051: I don't understand protocol %d (%Xh)\n",\r\ntype, type);\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_aborted_errors++;\r\nreturn 0;\r\n}\r\npkt->hard.source = *dev->dev_addr;\r\nif (dev->flags & (IFF_LOOPBACK | IFF_NOARP)) {\r\npkt->hard.dest = 0;\r\nreturn hdr_size;\r\n}\r\npkt->hard.dest = daddr;\r\nreturn hdr_size;\r\n}\r\nstatic int prepare_tx(struct net_device *dev, struct archdr *pkt, int length,\r\nint bufnum)\r\n{\r\nstruct arcnet_local *lp = netdev_priv(dev);\r\nstruct arc_hardware *hard = &pkt->hard;\r\nint ofs;\r\narc_printk(D_DURING, dev, "prepare_tx: txbufs=%d/%d/%d\n",\r\nlp->next_tx, lp->cur_tx, bufnum);\r\nlength -= ARC_HDR_SIZE;\r\nif (length > XMTU) {\r\narc_printk(D_NORMAL, dev, "Bug! prepare_tx with size %d (> %d)\n",\r\nlength, XMTU);\r\nlength = XMTU;\r\n}\r\nif (length > MinTU) {\r\nhard->offset[0] = 0;\r\nhard->offset[1] = ofs = 512 - length;\r\n} else if (length > MTU) {\r\nhard->offset[0] = 0;\r\nhard->offset[1] = ofs = 512 - length - 3;\r\n} else {\r\nhard->offset[0] = ofs = 256 - length;\r\n}\r\nlp->hw.copy_to_card(dev, bufnum, 0, hard, ARC_HDR_SIZE);\r\nlp->hw.copy_to_card(dev, bufnum, ofs, &pkt->soft, length);\r\nlp->lastload_dest = hard->dest;\r\nreturn 1;\r\n}
