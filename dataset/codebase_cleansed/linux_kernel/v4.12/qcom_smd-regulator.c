static int rpm_reg_write_active(struct qcom_rpm_reg *vreg,\r\nstruct rpm_regulator_req *req,\r\nsize_t size)\r\n{\r\nreturn qcom_rpm_smd_write(vreg->rpm,\r\nQCOM_SMD_RPM_ACTIVE_STATE,\r\nvreg->type,\r\nvreg->id,\r\nreq, size);\r\n}\r\nstatic int rpm_reg_enable(struct regulator_dev *rdev)\r\n{\r\nstruct qcom_rpm_reg *vreg = rdev_get_drvdata(rdev);\r\nstruct rpm_regulator_req req;\r\nint ret;\r\nreq.key = cpu_to_le32(RPM_KEY_SWEN);\r\nreq.nbytes = cpu_to_le32(sizeof(u32));\r\nreq.value = cpu_to_le32(1);\r\nret = rpm_reg_write_active(vreg, &req, sizeof(req));\r\nif (!ret)\r\nvreg->is_enabled = 1;\r\nreturn ret;\r\n}\r\nstatic int rpm_reg_is_enabled(struct regulator_dev *rdev)\r\n{\r\nstruct qcom_rpm_reg *vreg = rdev_get_drvdata(rdev);\r\nreturn vreg->is_enabled;\r\n}\r\nstatic int rpm_reg_disable(struct regulator_dev *rdev)\r\n{\r\nstruct qcom_rpm_reg *vreg = rdev_get_drvdata(rdev);\r\nstruct rpm_regulator_req req;\r\nint ret;\r\nreq.key = cpu_to_le32(RPM_KEY_SWEN);\r\nreq.nbytes = cpu_to_le32(sizeof(u32));\r\nreq.value = 0;\r\nret = rpm_reg_write_active(vreg, &req, sizeof(req));\r\nif (!ret)\r\nvreg->is_enabled = 0;\r\nreturn ret;\r\n}\r\nstatic int rpm_reg_get_voltage(struct regulator_dev *rdev)\r\n{\r\nstruct qcom_rpm_reg *vreg = rdev_get_drvdata(rdev);\r\nreturn vreg->uV;\r\n}\r\nstatic int rpm_reg_set_voltage(struct regulator_dev *rdev,\r\nint min_uV,\r\nint max_uV,\r\nunsigned *selector)\r\n{\r\nstruct qcom_rpm_reg *vreg = rdev_get_drvdata(rdev);\r\nstruct rpm_regulator_req req;\r\nint ret = 0;\r\nreq.key = cpu_to_le32(RPM_KEY_UV);\r\nreq.nbytes = cpu_to_le32(sizeof(u32));\r\nreq.value = cpu_to_le32(min_uV);\r\nret = rpm_reg_write_active(vreg, &req, sizeof(req));\r\nif (!ret)\r\nvreg->uV = min_uV;\r\nreturn ret;\r\n}\r\nstatic int rpm_reg_set_load(struct regulator_dev *rdev, int load_uA)\r\n{\r\nstruct qcom_rpm_reg *vreg = rdev_get_drvdata(rdev);\r\nstruct rpm_regulator_req req;\r\nreq.key = cpu_to_le32(RPM_KEY_MA);\r\nreq.nbytes = cpu_to_le32(sizeof(u32));\r\nreq.value = cpu_to_le32(load_uA / 1000);\r\nreturn rpm_reg_write_active(vreg, &req, sizeof(req));\r\n}\r\nstatic int rpm_reg_probe(struct platform_device *pdev)\r\n{\r\nconst struct rpm_regulator_data *reg;\r\nconst struct of_device_id *match;\r\nstruct regulator_config config = { };\r\nstruct regulator_dev *rdev;\r\nstruct qcom_rpm_reg *vreg;\r\nstruct qcom_smd_rpm *rpm;\r\nrpm = dev_get_drvdata(pdev->dev.parent);\r\nif (!rpm) {\r\ndev_err(&pdev->dev, "unable to retrieve handle to rpm\n");\r\nreturn -ENODEV;\r\n}\r\nmatch = of_match_device(rpm_of_match, &pdev->dev);\r\nfor (reg = match->data; reg->name; reg++) {\r\nvreg = devm_kzalloc(&pdev->dev, sizeof(*vreg), GFP_KERNEL);\r\nif (!vreg)\r\nreturn -ENOMEM;\r\nvreg->dev = &pdev->dev;\r\nvreg->type = reg->type;\r\nvreg->id = reg->id;\r\nvreg->rpm = rpm;\r\nmemcpy(&vreg->desc, reg->desc, sizeof(vreg->desc));\r\nvreg->desc.id = -1;\r\nvreg->desc.owner = THIS_MODULE;\r\nvreg->desc.type = REGULATOR_VOLTAGE;\r\nvreg->desc.name = reg->name;\r\nvreg->desc.supply_name = reg->supply;\r\nvreg->desc.of_match = reg->name;\r\nconfig.dev = &pdev->dev;\r\nconfig.driver_data = vreg;\r\nrdev = devm_regulator_register(&pdev->dev, &vreg->desc, &config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(&pdev->dev, "failed to register %s\n", reg->name);\r\nreturn PTR_ERR(rdev);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init rpm_reg_init(void)\r\n{\r\nreturn platform_driver_register(&rpm_reg_driver);\r\n}\r\nstatic void __exit rpm_reg_exit(void)\r\n{\r\nplatform_driver_unregister(&rpm_reg_driver);\r\n}
