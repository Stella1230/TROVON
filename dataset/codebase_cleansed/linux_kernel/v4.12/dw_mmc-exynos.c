static inline u8 dw_mci_exynos_get_ciu_div(struct dw_mci *host)\r\n{\r\nstruct dw_mci_exynos_priv_data *priv = host->priv;\r\nif (priv->ctrl_type == DW_MCI_TYPE_EXYNOS4412)\r\nreturn EXYNOS4412_FIXED_CIU_CLK_DIV;\r\nelse if (priv->ctrl_type == DW_MCI_TYPE_EXYNOS4210)\r\nreturn EXYNOS4210_FIXED_CIU_CLK_DIV;\r\nelse if (priv->ctrl_type == DW_MCI_TYPE_EXYNOS7 ||\r\npriv->ctrl_type == DW_MCI_TYPE_EXYNOS7_SMU)\r\nreturn SDMMC_CLKSEL_GET_DIV(mci_readl(host, CLKSEL64)) + 1;\r\nelse\r\nreturn SDMMC_CLKSEL_GET_DIV(mci_readl(host, CLKSEL)) + 1;\r\n}\r\nstatic void dw_mci_exynos_config_smu(struct dw_mci *host)\r\n{\r\nstruct dw_mci_exynos_priv_data *priv = host->priv;\r\nif (priv->ctrl_type == DW_MCI_TYPE_EXYNOS5420_SMU ||\r\npriv->ctrl_type == DW_MCI_TYPE_EXYNOS7_SMU) {\r\nmci_writel(host, MPSBEGIN0, 0);\r\nmci_writel(host, MPSEND0, SDMMC_ENDING_SEC_NR_MAX);\r\nmci_writel(host, MPSCTRL0, SDMMC_MPSCTRL_SECURE_WRITE_BIT |\r\nSDMMC_MPSCTRL_NON_SECURE_READ_BIT |\r\nSDMMC_MPSCTRL_VALID |\r\nSDMMC_MPSCTRL_NON_SECURE_WRITE_BIT);\r\n}\r\n}\r\nstatic int dw_mci_exynos_priv_init(struct dw_mci *host)\r\n{\r\nstruct dw_mci_exynos_priv_data *priv = host->priv;\r\ndw_mci_exynos_config_smu(host);\r\nif (priv->ctrl_type >= DW_MCI_TYPE_EXYNOS5420) {\r\npriv->saved_strobe_ctrl = mci_readl(host, HS400_DLINE_CTRL);\r\npriv->saved_dqs_en = mci_readl(host, HS400_DQS_EN);\r\npriv->saved_dqs_en |= AXI_NON_BLOCKING_WR;\r\nmci_writel(host, HS400_DQS_EN, priv->saved_dqs_en);\r\nif (!priv->dqs_delay)\r\npriv->dqs_delay =\r\nDQS_CTRL_GET_RD_DELAY(priv->saved_strobe_ctrl);\r\n}\r\nhost->bus_hz /= (priv->ciu_div + 1);\r\nreturn 0;\r\n}\r\nstatic void dw_mci_exynos_set_clksel_timing(struct dw_mci *host, u32 timing)\r\n{\r\nstruct dw_mci_exynos_priv_data *priv = host->priv;\r\nu32 clksel;\r\nif (priv->ctrl_type == DW_MCI_TYPE_EXYNOS7 ||\r\npriv->ctrl_type == DW_MCI_TYPE_EXYNOS7_SMU)\r\nclksel = mci_readl(host, CLKSEL64);\r\nelse\r\nclksel = mci_readl(host, CLKSEL);\r\nclksel = (clksel & ~SDMMC_CLKSEL_TIMING_MASK) | timing;\r\nif (priv->ctrl_type == DW_MCI_TYPE_EXYNOS7 ||\r\npriv->ctrl_type == DW_MCI_TYPE_EXYNOS7_SMU)\r\nmci_writel(host, CLKSEL64, clksel);\r\nelse\r\nmci_writel(host, CLKSEL, clksel);\r\nif (!SDMMC_CLKSEL_GET_DRV_WD3(clksel) && host->cur_slot)\r\nset_bit(DW_MMC_CARD_NO_USE_HOLD, &host->cur_slot->flags);\r\n}\r\nstatic int dw_mci_exynos_runtime_resume(struct device *dev)\r\n{\r\nstruct dw_mci *host = dev_get_drvdata(dev);\r\ndw_mci_exynos_config_smu(host);\r\nreturn dw_mci_runtime_resume(dev);\r\n}\r\nstatic int dw_mci_exynos_resume_noirq(struct device *dev)\r\n{\r\nstruct dw_mci *host = dev_get_drvdata(dev);\r\nstruct dw_mci_exynos_priv_data *priv = host->priv;\r\nu32 clksel;\r\nif (priv->ctrl_type == DW_MCI_TYPE_EXYNOS7 ||\r\npriv->ctrl_type == DW_MCI_TYPE_EXYNOS7_SMU)\r\nclksel = mci_readl(host, CLKSEL64);\r\nelse\r\nclksel = mci_readl(host, CLKSEL);\r\nif (clksel & SDMMC_CLKSEL_WAKEUP_INT) {\r\nif (priv->ctrl_type == DW_MCI_TYPE_EXYNOS7 ||\r\npriv->ctrl_type == DW_MCI_TYPE_EXYNOS7_SMU)\r\nmci_writel(host, CLKSEL64, clksel);\r\nelse\r\nmci_writel(host, CLKSEL, clksel);\r\n}\r\nreturn 0;\r\n}\r\nstatic void dw_mci_exynos_config_hs400(struct dw_mci *host, u32 timing)\r\n{\r\nstruct dw_mci_exynos_priv_data *priv = host->priv;\r\nu32 dqs, strobe;\r\nif (priv->ctrl_type < DW_MCI_TYPE_EXYNOS5420) {\r\nif (timing == MMC_TIMING_MMC_HS400)\r\ndev_warn(host->dev,\r\n"cannot configure HS400, unsupported chipset\n");\r\nreturn;\r\n}\r\ndqs = priv->saved_dqs_en;\r\nstrobe = priv->saved_strobe_ctrl;\r\nif (timing == MMC_TIMING_MMC_HS400) {\r\ndqs |= DATA_STROBE_EN;\r\nstrobe = DQS_CTRL_RD_DELAY(strobe, priv->dqs_delay);\r\n} else {\r\ndqs &= ~DATA_STROBE_EN;\r\n}\r\nmci_writel(host, HS400_DQS_EN, dqs);\r\nmci_writel(host, HS400_DLINE_CTRL, strobe);\r\n}\r\nstatic void dw_mci_exynos_adjust_clock(struct dw_mci *host, unsigned int wanted)\r\n{\r\nstruct dw_mci_exynos_priv_data *priv = host->priv;\r\nunsigned long actual;\r\nu8 div;\r\nint ret;\r\nif (!wanted || IS_ERR(host->ciu_clk))\r\nreturn;\r\nif (wanted < EXYNOS_CCLKIN_MIN)\r\nwanted = EXYNOS_CCLKIN_MIN;\r\nif (wanted == priv->cur_speed)\r\nreturn;\r\ndiv = dw_mci_exynos_get_ciu_div(host);\r\nret = clk_set_rate(host->ciu_clk, wanted * div);\r\nif (ret)\r\ndev_warn(host->dev,\r\n"failed to set clk-rate %u error: %d\n",\r\nwanted * div, ret);\r\nactual = clk_get_rate(host->ciu_clk);\r\nhost->bus_hz = actual / div;\r\npriv->cur_speed = wanted;\r\nhost->current_speed = 0;\r\n}\r\nstatic void dw_mci_exynos_set_ios(struct dw_mci *host, struct mmc_ios *ios)\r\n{\r\nstruct dw_mci_exynos_priv_data *priv = host->priv;\r\nunsigned int wanted = ios->clock;\r\nu32 timing = ios->timing, clksel;\r\nswitch (timing) {\r\ncase MMC_TIMING_MMC_HS400:\r\nclksel = SDMMC_CLKSEL_UP_SAMPLE(\r\npriv->hs400_timing, priv->tuned_sample);\r\nwanted <<= 1;\r\nbreak;\r\ncase MMC_TIMING_MMC_DDR52:\r\nclksel = priv->ddr_timing;\r\nif (ios->bus_width == MMC_BUS_WIDTH_8)\r\nwanted <<= 1;\r\nbreak;\r\ndefault:\r\nclksel = priv->sdr_timing;\r\n}\r\ndw_mci_exynos_set_clksel_timing(host, clksel);\r\ndw_mci_exynos_config_hs400(host, timing);\r\ndw_mci_exynos_adjust_clock(host, wanted);\r\n}\r\nstatic int dw_mci_exynos_parse_dt(struct dw_mci *host)\r\n{\r\nstruct dw_mci_exynos_priv_data *priv;\r\nstruct device_node *np = host->dev->of_node;\r\nu32 timing[2];\r\nu32 div = 0;\r\nint idx;\r\nint ret;\r\npriv = devm_kzalloc(host->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nfor (idx = 0; idx < ARRAY_SIZE(exynos_compat); idx++) {\r\nif (of_device_is_compatible(np, exynos_compat[idx].compatible))\r\npriv->ctrl_type = exynos_compat[idx].ctrl_type;\r\n}\r\nif (priv->ctrl_type == DW_MCI_TYPE_EXYNOS4412)\r\npriv->ciu_div = EXYNOS4412_FIXED_CIU_CLK_DIV - 1;\r\nelse if (priv->ctrl_type == DW_MCI_TYPE_EXYNOS4210)\r\npriv->ciu_div = EXYNOS4210_FIXED_CIU_CLK_DIV - 1;\r\nelse {\r\nof_property_read_u32(np, "samsung,dw-mshc-ciu-div", &div);\r\npriv->ciu_div = div;\r\n}\r\nret = of_property_read_u32_array(np,\r\n"samsung,dw-mshc-sdr-timing", timing, 2);\r\nif (ret)\r\nreturn ret;\r\npriv->sdr_timing = SDMMC_CLKSEL_TIMING(timing[0], timing[1], div);\r\nret = of_property_read_u32_array(np,\r\n"samsung,dw-mshc-ddr-timing", timing, 2);\r\nif (ret)\r\nreturn ret;\r\npriv->ddr_timing = SDMMC_CLKSEL_TIMING(timing[0], timing[1], div);\r\nret = of_property_read_u32_array(np,\r\n"samsung,dw-mshc-hs400-timing", timing, 2);\r\nif (!ret && of_property_read_u32(np,\r\n"samsung,read-strobe-delay", &priv->dqs_delay))\r\ndev_dbg(host->dev,\r\n"read-strobe-delay is not found, assuming usage of default value\n");\r\npriv->hs400_timing = SDMMC_CLKSEL_TIMING(timing[0], timing[1],\r\nHS400_FIXED_CIU_CLK_DIV);\r\nhost->priv = priv;\r\nreturn 0;\r\n}\r\nstatic inline u8 dw_mci_exynos_get_clksmpl(struct dw_mci *host)\r\n{\r\nstruct dw_mci_exynos_priv_data *priv = host->priv;\r\nif (priv->ctrl_type == DW_MCI_TYPE_EXYNOS7 ||\r\npriv->ctrl_type == DW_MCI_TYPE_EXYNOS7_SMU)\r\nreturn SDMMC_CLKSEL_CCLK_SAMPLE(mci_readl(host, CLKSEL64));\r\nelse\r\nreturn SDMMC_CLKSEL_CCLK_SAMPLE(mci_readl(host, CLKSEL));\r\n}\r\nstatic inline void dw_mci_exynos_set_clksmpl(struct dw_mci *host, u8 sample)\r\n{\r\nu32 clksel;\r\nstruct dw_mci_exynos_priv_data *priv = host->priv;\r\nif (priv->ctrl_type == DW_MCI_TYPE_EXYNOS7 ||\r\npriv->ctrl_type == DW_MCI_TYPE_EXYNOS7_SMU)\r\nclksel = mci_readl(host, CLKSEL64);\r\nelse\r\nclksel = mci_readl(host, CLKSEL);\r\nclksel = SDMMC_CLKSEL_UP_SAMPLE(clksel, sample);\r\nif (priv->ctrl_type == DW_MCI_TYPE_EXYNOS7 ||\r\npriv->ctrl_type == DW_MCI_TYPE_EXYNOS7_SMU)\r\nmci_writel(host, CLKSEL64, clksel);\r\nelse\r\nmci_writel(host, CLKSEL, clksel);\r\n}\r\nstatic inline u8 dw_mci_exynos_move_next_clksmpl(struct dw_mci *host)\r\n{\r\nstruct dw_mci_exynos_priv_data *priv = host->priv;\r\nu32 clksel;\r\nu8 sample;\r\nif (priv->ctrl_type == DW_MCI_TYPE_EXYNOS7 ||\r\npriv->ctrl_type == DW_MCI_TYPE_EXYNOS7_SMU)\r\nclksel = mci_readl(host, CLKSEL64);\r\nelse\r\nclksel = mci_readl(host, CLKSEL);\r\nsample = (clksel + 1) & 0x7;\r\nclksel = SDMMC_CLKSEL_UP_SAMPLE(clksel, sample);\r\nif (priv->ctrl_type == DW_MCI_TYPE_EXYNOS7 ||\r\npriv->ctrl_type == DW_MCI_TYPE_EXYNOS7_SMU)\r\nmci_writel(host, CLKSEL64, clksel);\r\nelse\r\nmci_writel(host, CLKSEL, clksel);\r\nreturn sample;\r\n}\r\nstatic s8 dw_mci_exynos_get_best_clksmpl(u8 candiates)\r\n{\r\nconst u8 iter = 8;\r\nu8 __c;\r\ns8 i, loc = -1;\r\nfor (i = 0; i < iter; i++) {\r\n__c = ror8(candiates, i);\r\nif ((__c & 0xc7) == 0xc7) {\r\nloc = i;\r\ngoto out;\r\n}\r\n}\r\nfor (i = 0; i < iter; i++) {\r\n__c = ror8(candiates, i);\r\nif ((__c & 0x83) == 0x83) {\r\nloc = i;\r\ngoto out;\r\n}\r\n}\r\nout:\r\nreturn loc;\r\n}\r\nstatic int dw_mci_exynos_execute_tuning(struct dw_mci_slot *slot, u32 opcode)\r\n{\r\nstruct dw_mci *host = slot->host;\r\nstruct dw_mci_exynos_priv_data *priv = host->priv;\r\nstruct mmc_host *mmc = slot->mmc;\r\nu8 start_smpl, smpl, candiates = 0;\r\ns8 found = -1;\r\nint ret = 0;\r\nstart_smpl = dw_mci_exynos_get_clksmpl(host);\r\ndo {\r\nmci_writel(host, TMOUT, ~0);\r\nsmpl = dw_mci_exynos_move_next_clksmpl(host);\r\nif (!mmc_send_tuning(mmc, opcode, NULL))\r\ncandiates |= (1 << smpl);\r\n} while (start_smpl != smpl);\r\nfound = dw_mci_exynos_get_best_clksmpl(candiates);\r\nif (found >= 0) {\r\ndw_mci_exynos_set_clksmpl(host, found);\r\npriv->tuned_sample = found;\r\n} else {\r\nret = -EIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int dw_mci_exynos_prepare_hs400_tuning(struct dw_mci *host,\r\nstruct mmc_ios *ios)\r\n{\r\nstruct dw_mci_exynos_priv_data *priv = host->priv;\r\ndw_mci_exynos_set_clksel_timing(host, priv->hs400_timing);\r\ndw_mci_exynos_adjust_clock(host, (ios->clock) << 1);\r\nreturn 0;\r\n}\r\nstatic int dw_mci_exynos_probe(struct platform_device *pdev)\r\n{\r\nconst struct dw_mci_drv_data *drv_data;\r\nconst struct of_device_id *match;\r\nint ret;\r\nmatch = of_match_node(dw_mci_exynos_match, pdev->dev.of_node);\r\ndrv_data = match->data;\r\npm_runtime_get_noresume(&pdev->dev);\r\npm_runtime_set_active(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\nret = dw_mci_pltfm_register(pdev, drv_data);\r\nif (ret) {\r\npm_runtime_disable(&pdev->dev);\r\npm_runtime_set_suspended(&pdev->dev);\r\npm_runtime_put_noidle(&pdev->dev);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dw_mci_exynos_remove(struct platform_device *pdev)\r\n{\r\npm_runtime_disable(&pdev->dev);\r\npm_runtime_set_suspended(&pdev->dev);\r\npm_runtime_put_noidle(&pdev->dev);\r\nreturn dw_mci_pltfm_remove(pdev);\r\n}
