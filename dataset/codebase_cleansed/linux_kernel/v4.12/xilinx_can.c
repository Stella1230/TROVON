static void xcan_write_reg_le(const struct xcan_priv *priv, enum xcan_reg reg,\r\nu32 val)\r\n{\r\niowrite32(val, priv->reg_base + reg);\r\n}\r\nstatic u32 xcan_read_reg_le(const struct xcan_priv *priv, enum xcan_reg reg)\r\n{\r\nreturn ioread32(priv->reg_base + reg);\r\n}\r\nstatic void xcan_write_reg_be(const struct xcan_priv *priv, enum xcan_reg reg,\r\nu32 val)\r\n{\r\niowrite32be(val, priv->reg_base + reg);\r\n}\r\nstatic u32 xcan_read_reg_be(const struct xcan_priv *priv, enum xcan_reg reg)\r\n{\r\nreturn ioread32be(priv->reg_base + reg);\r\n}\r\nstatic int set_reset_mode(struct net_device *ndev)\r\n{\r\nstruct xcan_priv *priv = netdev_priv(ndev);\r\nunsigned long timeout;\r\npriv->write_reg(priv, XCAN_SRR_OFFSET, XCAN_SRR_RESET_MASK);\r\ntimeout = jiffies + XCAN_TIMEOUT;\r\nwhile (!(priv->read_reg(priv, XCAN_SR_OFFSET) & XCAN_SR_CONFIG_MASK)) {\r\nif (time_after(jiffies, timeout)) {\r\nnetdev_warn(ndev, "timed out for config mode\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nusleep_range(500, 10000);\r\n}\r\nreturn 0;\r\n}\r\nstatic int xcan_set_bittiming(struct net_device *ndev)\r\n{\r\nstruct xcan_priv *priv = netdev_priv(ndev);\r\nstruct can_bittiming *bt = &priv->can.bittiming;\r\nu32 btr0, btr1;\r\nu32 is_config_mode;\r\nis_config_mode = priv->read_reg(priv, XCAN_SR_OFFSET) &\r\nXCAN_SR_CONFIG_MASK;\r\nif (!is_config_mode) {\r\nnetdev_alert(ndev,\r\n"BUG! Cannot set bittiming - CAN is not in config mode\n");\r\nreturn -EPERM;\r\n}\r\nbtr0 = (bt->brp - 1);\r\nbtr1 = (bt->prop_seg + bt->phase_seg1 - 1);\r\nbtr1 |= (bt->phase_seg2 - 1) << XCAN_BTR_TS2_SHIFT;\r\nbtr1 |= (bt->sjw - 1) << XCAN_BTR_SJW_SHIFT;\r\npriv->write_reg(priv, XCAN_BRPR_OFFSET, btr0);\r\npriv->write_reg(priv, XCAN_BTR_OFFSET, btr1);\r\nnetdev_dbg(ndev, "BRPR=0x%08x, BTR=0x%08x\n",\r\npriv->read_reg(priv, XCAN_BRPR_OFFSET),\r\npriv->read_reg(priv, XCAN_BTR_OFFSET));\r\nreturn 0;\r\n}\r\nstatic int xcan_chip_start(struct net_device *ndev)\r\n{\r\nstruct xcan_priv *priv = netdev_priv(ndev);\r\nu32 reg_msr, reg_sr_mask;\r\nint err;\r\nunsigned long timeout;\r\nerr = set_reset_mode(ndev);\r\nif (err < 0)\r\nreturn err;\r\nerr = xcan_set_bittiming(ndev);\r\nif (err < 0)\r\nreturn err;\r\npriv->write_reg(priv, XCAN_IER_OFFSET, XCAN_INTR_ALL);\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK) {\r\nreg_msr = XCAN_MSR_LBACK_MASK;\r\nreg_sr_mask = XCAN_SR_LBACK_MASK;\r\n} else {\r\nreg_msr = 0x0;\r\nreg_sr_mask = XCAN_SR_NORMAL_MASK;\r\n}\r\npriv->write_reg(priv, XCAN_MSR_OFFSET, reg_msr);\r\npriv->write_reg(priv, XCAN_SRR_OFFSET, XCAN_SRR_CEN_MASK);\r\ntimeout = jiffies + XCAN_TIMEOUT;\r\nwhile (!(priv->read_reg(priv, XCAN_SR_OFFSET) & reg_sr_mask)) {\r\nif (time_after(jiffies, timeout)) {\r\nnetdev_warn(ndev,\r\n"timed out for correct mode\n");\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\nnetdev_dbg(ndev, "status:#x%08x\n",\r\npriv->read_reg(priv, XCAN_SR_OFFSET));\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nreturn 0;\r\n}\r\nstatic int xcan_do_set_mode(struct net_device *ndev, enum can_mode mode)\r\n{\r\nint ret;\r\nswitch (mode) {\r\ncase CAN_MODE_START:\r\nret = xcan_chip_start(ndev);\r\nif (ret < 0) {\r\nnetdev_err(ndev, "xcan_chip_start failed!\n");\r\nreturn ret;\r\n}\r\nnetif_wake_queue(ndev);\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int xcan_start_xmit(struct sk_buff *skb, struct net_device *ndev)\r\n{\r\nstruct xcan_priv *priv = netdev_priv(ndev);\r\nstruct net_device_stats *stats = &ndev->stats;\r\nstruct can_frame *cf = (struct can_frame *)skb->data;\r\nu32 id, dlc, data[2] = {0, 0};\r\nif (can_dropped_invalid_skb(ndev, skb))\r\nreturn NETDEV_TX_OK;\r\nif (unlikely(priv->read_reg(priv, XCAN_SR_OFFSET) &\r\nXCAN_SR_TXFLL_MASK)) {\r\nnetif_stop_queue(ndev);\r\nnetdev_err(ndev, "BUG!, TX FIFO full when queue awake!\n");\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nif (cf->can_id & CAN_EFF_FLAG) {\r\nid = ((cf->can_id & CAN_EFF_MASK) << XCAN_IDR_ID2_SHIFT) &\r\nXCAN_IDR_ID2_MASK;\r\nid |= (((cf->can_id & CAN_EFF_MASK) >>\r\n(CAN_EFF_ID_BITS-CAN_SFF_ID_BITS)) <<\r\nXCAN_IDR_ID1_SHIFT) & XCAN_IDR_ID1_MASK;\r\nid |= XCAN_IDR_IDE_MASK | XCAN_IDR_SRR_MASK;\r\nif (cf->can_id & CAN_RTR_FLAG)\r\nid |= XCAN_IDR_RTR_MASK;\r\n} else {\r\nid = ((cf->can_id & CAN_SFF_MASK) << XCAN_IDR_ID1_SHIFT) &\r\nXCAN_IDR_ID1_MASK;\r\nif (cf->can_id & CAN_RTR_FLAG)\r\nid |= XCAN_IDR_SRR_MASK;\r\n}\r\ndlc = cf->can_dlc << XCAN_DLCR_DLC_SHIFT;\r\nif (cf->can_dlc > 0)\r\ndata[0] = be32_to_cpup((__be32 *)(cf->data + 0));\r\nif (cf->can_dlc > 4)\r\ndata[1] = be32_to_cpup((__be32 *)(cf->data + 4));\r\ncan_put_echo_skb(skb, ndev, priv->tx_head % priv->tx_max);\r\npriv->tx_head++;\r\npriv->write_reg(priv, XCAN_TXFIFO_ID_OFFSET, id);\r\npriv->write_reg(priv, XCAN_TXFIFO_DLC_OFFSET, dlc);\r\nif (!(cf->can_id & CAN_RTR_FLAG)) {\r\npriv->write_reg(priv, XCAN_TXFIFO_DW1_OFFSET, data[0]);\r\npriv->write_reg(priv, XCAN_TXFIFO_DW2_OFFSET, data[1]);\r\nstats->tx_bytes += cf->can_dlc;\r\n}\r\nif ((priv->tx_head - priv->tx_tail) == priv->tx_max)\r\nnetif_stop_queue(ndev);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int xcan_rx(struct net_device *ndev)\r\n{\r\nstruct xcan_priv *priv = netdev_priv(ndev);\r\nstruct net_device_stats *stats = &ndev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nu32 id_xcan, dlc, data[2] = {0, 0};\r\nskb = alloc_can_skb(ndev, &cf);\r\nif (unlikely(!skb)) {\r\nstats->rx_dropped++;\r\nreturn 0;\r\n}\r\nid_xcan = priv->read_reg(priv, XCAN_RXFIFO_ID_OFFSET);\r\ndlc = priv->read_reg(priv, XCAN_RXFIFO_DLC_OFFSET) >>\r\nXCAN_DLCR_DLC_SHIFT;\r\ncf->can_dlc = get_can_dlc(dlc);\r\nif (id_xcan & XCAN_IDR_IDE_MASK) {\r\ncf->can_id = (id_xcan & XCAN_IDR_ID1_MASK) >> 3;\r\ncf->can_id |= (id_xcan & XCAN_IDR_ID2_MASK) >>\r\nXCAN_IDR_ID2_SHIFT;\r\ncf->can_id |= CAN_EFF_FLAG;\r\nif (id_xcan & XCAN_IDR_RTR_MASK)\r\ncf->can_id |= CAN_RTR_FLAG;\r\n} else {\r\ncf->can_id = (id_xcan & XCAN_IDR_ID1_MASK) >>\r\nXCAN_IDR_ID1_SHIFT;\r\nif (id_xcan & XCAN_IDR_SRR_MASK)\r\ncf->can_id |= CAN_RTR_FLAG;\r\n}\r\ndata[0] = priv->read_reg(priv, XCAN_RXFIFO_DW1_OFFSET);\r\ndata[1] = priv->read_reg(priv, XCAN_RXFIFO_DW2_OFFSET);\r\nif (!(cf->can_id & CAN_RTR_FLAG)) {\r\nif (cf->can_dlc > 0)\r\n*(__be32 *)(cf->data) = cpu_to_be32(data[0]);\r\nif (cf->can_dlc > 4)\r\n*(__be32 *)(cf->data + 4) = cpu_to_be32(data[1]);\r\n}\r\nstats->rx_bytes += cf->can_dlc;\r\nstats->rx_packets++;\r\nnetif_receive_skb(skb);\r\nreturn 1;\r\n}\r\nstatic void xcan_err_interrupt(struct net_device *ndev, u32 isr)\r\n{\r\nstruct xcan_priv *priv = netdev_priv(ndev);\r\nstruct net_device_stats *stats = &ndev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nu32 err_status, status, txerr = 0, rxerr = 0;\r\nskb = alloc_can_err_skb(ndev, &cf);\r\nerr_status = priv->read_reg(priv, XCAN_ESR_OFFSET);\r\npriv->write_reg(priv, XCAN_ESR_OFFSET, err_status);\r\ntxerr = priv->read_reg(priv, XCAN_ECR_OFFSET) & XCAN_ECR_TEC_MASK;\r\nrxerr = ((priv->read_reg(priv, XCAN_ECR_OFFSET) &\r\nXCAN_ECR_REC_MASK) >> XCAN_ESR_REC_SHIFT);\r\nstatus = priv->read_reg(priv, XCAN_SR_OFFSET);\r\nif (isr & XCAN_IXR_BSOFF_MASK) {\r\npriv->can.state = CAN_STATE_BUS_OFF;\r\npriv->can.can_stats.bus_off++;\r\npriv->write_reg(priv, XCAN_SRR_OFFSET, XCAN_SRR_RESET_MASK);\r\ncan_bus_off(ndev);\r\nif (skb)\r\ncf->can_id |= CAN_ERR_BUSOFF;\r\n} else if ((status & XCAN_SR_ESTAT_MASK) == XCAN_SR_ESTAT_MASK) {\r\npriv->can.state = CAN_STATE_ERROR_PASSIVE;\r\npriv->can.can_stats.error_passive++;\r\nif (skb) {\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] = (rxerr > 127) ?\r\nCAN_ERR_CRTL_RX_PASSIVE :\r\nCAN_ERR_CRTL_TX_PASSIVE;\r\ncf->data[6] = txerr;\r\ncf->data[7] = rxerr;\r\n}\r\n} else if (status & XCAN_SR_ERRWRN_MASK) {\r\npriv->can.state = CAN_STATE_ERROR_WARNING;\r\npriv->can.can_stats.error_warning++;\r\nif (skb) {\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] |= (txerr > rxerr) ?\r\nCAN_ERR_CRTL_TX_WARNING :\r\nCAN_ERR_CRTL_RX_WARNING;\r\ncf->data[6] = txerr;\r\ncf->data[7] = rxerr;\r\n}\r\n}\r\nif (isr & XCAN_IXR_ARBLST_MASK) {\r\npriv->can.can_stats.arbitration_lost++;\r\nif (skb) {\r\ncf->can_id |= CAN_ERR_LOSTARB;\r\ncf->data[0] = CAN_ERR_LOSTARB_UNSPEC;\r\n}\r\n}\r\nif (isr & XCAN_IXR_RXOFLW_MASK) {\r\nstats->rx_over_errors++;\r\nstats->rx_errors++;\r\npriv->write_reg(priv, XCAN_SRR_OFFSET, XCAN_SRR_RESET_MASK);\r\nif (skb) {\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] |= CAN_ERR_CRTL_RX_OVERFLOW;\r\n}\r\n}\r\nif (isr & XCAN_IXR_ERROR_MASK) {\r\nif (skb)\r\ncf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\r\nif (err_status & XCAN_ESR_ACKER_MASK) {\r\nstats->tx_errors++;\r\nif (skb) {\r\ncf->can_id |= CAN_ERR_ACK;\r\ncf->data[3] = CAN_ERR_PROT_LOC_ACK;\r\n}\r\n}\r\nif (err_status & XCAN_ESR_BERR_MASK) {\r\nstats->tx_errors++;\r\nif (skb) {\r\ncf->can_id |= CAN_ERR_PROT;\r\ncf->data[2] = CAN_ERR_PROT_BIT;\r\n}\r\n}\r\nif (err_status & XCAN_ESR_STER_MASK) {\r\nstats->rx_errors++;\r\nif (skb) {\r\ncf->can_id |= CAN_ERR_PROT;\r\ncf->data[2] = CAN_ERR_PROT_STUFF;\r\n}\r\n}\r\nif (err_status & XCAN_ESR_FMER_MASK) {\r\nstats->rx_errors++;\r\nif (skb) {\r\ncf->can_id |= CAN_ERR_PROT;\r\ncf->data[2] = CAN_ERR_PROT_FORM;\r\n}\r\n}\r\nif (err_status & XCAN_ESR_CRCER_MASK) {\r\nstats->rx_errors++;\r\nif (skb) {\r\ncf->can_id |= CAN_ERR_PROT;\r\ncf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;\r\n}\r\n}\r\npriv->can.can_stats.bus_error++;\r\n}\r\nif (skb) {\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nnetif_rx(skb);\r\n}\r\nnetdev_dbg(ndev, "%s: error status register:0x%x\n",\r\n__func__, priv->read_reg(priv, XCAN_ESR_OFFSET));\r\n}\r\nstatic void xcan_state_interrupt(struct net_device *ndev, u32 isr)\r\n{\r\nstruct xcan_priv *priv = netdev_priv(ndev);\r\nif (isr & XCAN_IXR_SLP_MASK)\r\npriv->can.state = CAN_STATE_SLEEPING;\r\nif (isr & XCAN_IXR_WKUP_MASK)\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\n}\r\nstatic int xcan_rx_poll(struct napi_struct *napi, int quota)\r\n{\r\nstruct net_device *ndev = napi->dev;\r\nstruct xcan_priv *priv = netdev_priv(ndev);\r\nu32 isr, ier;\r\nint work_done = 0;\r\nisr = priv->read_reg(priv, XCAN_ISR_OFFSET);\r\nwhile ((isr & XCAN_IXR_RXNEMP_MASK) && (work_done < quota)) {\r\nif (isr & XCAN_IXR_RXOK_MASK) {\r\npriv->write_reg(priv, XCAN_ICR_OFFSET,\r\nXCAN_IXR_RXOK_MASK);\r\nwork_done += xcan_rx(ndev);\r\n} else {\r\npriv->write_reg(priv, XCAN_ICR_OFFSET,\r\nXCAN_IXR_RXNEMP_MASK);\r\nbreak;\r\n}\r\npriv->write_reg(priv, XCAN_ICR_OFFSET, XCAN_IXR_RXNEMP_MASK);\r\nisr = priv->read_reg(priv, XCAN_ISR_OFFSET);\r\n}\r\nif (work_done)\r\ncan_led_event(ndev, CAN_LED_EVENT_RX);\r\nif (work_done < quota) {\r\nnapi_complete_done(napi, work_done);\r\nier = priv->read_reg(priv, XCAN_IER_OFFSET);\r\nier |= (XCAN_IXR_RXOK_MASK | XCAN_IXR_RXNEMP_MASK);\r\npriv->write_reg(priv, XCAN_IER_OFFSET, ier);\r\n}\r\nreturn work_done;\r\n}\r\nstatic void xcan_tx_interrupt(struct net_device *ndev, u32 isr)\r\n{\r\nstruct xcan_priv *priv = netdev_priv(ndev);\r\nstruct net_device_stats *stats = &ndev->stats;\r\nwhile ((priv->tx_head - priv->tx_tail > 0) &&\r\n(isr & XCAN_IXR_TXOK_MASK)) {\r\npriv->write_reg(priv, XCAN_ICR_OFFSET, XCAN_IXR_TXOK_MASK);\r\ncan_get_echo_skb(ndev, priv->tx_tail %\r\npriv->tx_max);\r\npriv->tx_tail++;\r\nstats->tx_packets++;\r\nisr = priv->read_reg(priv, XCAN_ISR_OFFSET);\r\n}\r\ncan_led_event(ndev, CAN_LED_EVENT_TX);\r\nnetif_wake_queue(ndev);\r\n}\r\nstatic irqreturn_t xcan_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *ndev = (struct net_device *)dev_id;\r\nstruct xcan_priv *priv = netdev_priv(ndev);\r\nu32 isr, ier;\r\nisr = priv->read_reg(priv, XCAN_ISR_OFFSET);\r\nif (!isr)\r\nreturn IRQ_NONE;\r\nif (isr & (XCAN_IXR_SLP_MASK | XCAN_IXR_WKUP_MASK)) {\r\npriv->write_reg(priv, XCAN_ICR_OFFSET, (XCAN_IXR_SLP_MASK |\r\nXCAN_IXR_WKUP_MASK));\r\nxcan_state_interrupt(ndev, isr);\r\n}\r\nif (isr & XCAN_IXR_TXOK_MASK)\r\nxcan_tx_interrupt(ndev, isr);\r\nif (isr & (XCAN_IXR_ERROR_MASK | XCAN_IXR_RXOFLW_MASK |\r\nXCAN_IXR_BSOFF_MASK | XCAN_IXR_ARBLST_MASK)) {\r\npriv->write_reg(priv, XCAN_ICR_OFFSET, (XCAN_IXR_ERROR_MASK |\r\nXCAN_IXR_RXOFLW_MASK | XCAN_IXR_BSOFF_MASK |\r\nXCAN_IXR_ARBLST_MASK));\r\nxcan_err_interrupt(ndev, isr);\r\n}\r\nif (isr & (XCAN_IXR_RXNEMP_MASK | XCAN_IXR_RXOK_MASK)) {\r\nier = priv->read_reg(priv, XCAN_IER_OFFSET);\r\nier &= ~(XCAN_IXR_RXNEMP_MASK | XCAN_IXR_RXOK_MASK);\r\npriv->write_reg(priv, XCAN_IER_OFFSET, ier);\r\nnapi_schedule(&priv->napi);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void xcan_chip_stop(struct net_device *ndev)\r\n{\r\nstruct xcan_priv *priv = netdev_priv(ndev);\r\nu32 ier;\r\nier = priv->read_reg(priv, XCAN_IER_OFFSET);\r\nier &= ~XCAN_INTR_ALL;\r\npriv->write_reg(priv, XCAN_IER_OFFSET, ier);\r\npriv->write_reg(priv, XCAN_SRR_OFFSET, XCAN_SRR_RESET_MASK);\r\npriv->can.state = CAN_STATE_STOPPED;\r\n}\r\nstatic int xcan_open(struct net_device *ndev)\r\n{\r\nstruct xcan_priv *priv = netdev_priv(ndev);\r\nint ret;\r\nret = pm_runtime_get_sync(priv->dev);\r\nif (ret < 0) {\r\nnetdev_err(ndev, "%s: pm_runtime_get failed(%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nret = request_irq(ndev->irq, xcan_interrupt, priv->irq_flags,\r\nndev->name, ndev);\r\nif (ret < 0) {\r\nnetdev_err(ndev, "irq allocation for CAN failed\n");\r\ngoto err;\r\n}\r\nret = set_reset_mode(ndev);\r\nif (ret < 0) {\r\nnetdev_err(ndev, "mode resetting failed!\n");\r\ngoto err_irq;\r\n}\r\nret = open_candev(ndev);\r\nif (ret)\r\ngoto err_irq;\r\nret = xcan_chip_start(ndev);\r\nif (ret < 0) {\r\nnetdev_err(ndev, "xcan_chip_start failed!\n");\r\ngoto err_candev;\r\n}\r\ncan_led_event(ndev, CAN_LED_EVENT_OPEN);\r\nnapi_enable(&priv->napi);\r\nnetif_start_queue(ndev);\r\nreturn 0;\r\nerr_candev:\r\nclose_candev(ndev);\r\nerr_irq:\r\nfree_irq(ndev->irq, ndev);\r\nerr:\r\npm_runtime_put(priv->dev);\r\nreturn ret;\r\n}\r\nstatic int xcan_close(struct net_device *ndev)\r\n{\r\nstruct xcan_priv *priv = netdev_priv(ndev);\r\nnetif_stop_queue(ndev);\r\nnapi_disable(&priv->napi);\r\nxcan_chip_stop(ndev);\r\nfree_irq(ndev->irq, ndev);\r\nclose_candev(ndev);\r\ncan_led_event(ndev, CAN_LED_EVENT_STOP);\r\npm_runtime_put(priv->dev);\r\nreturn 0;\r\n}\r\nstatic int xcan_get_berr_counter(const struct net_device *ndev,\r\nstruct can_berr_counter *bec)\r\n{\r\nstruct xcan_priv *priv = netdev_priv(ndev);\r\nint ret;\r\nret = pm_runtime_get_sync(priv->dev);\r\nif (ret < 0) {\r\nnetdev_err(ndev, "%s: pm_runtime_get failed(%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nbec->txerr = priv->read_reg(priv, XCAN_ECR_OFFSET) & XCAN_ECR_TEC_MASK;\r\nbec->rxerr = ((priv->read_reg(priv, XCAN_ECR_OFFSET) &\r\nXCAN_ECR_REC_MASK) >> XCAN_ESR_REC_SHIFT);\r\npm_runtime_put(priv->dev);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused xcan_suspend(struct device *dev)\r\n{\r\nif (!device_may_wakeup(dev))\r\nreturn pm_runtime_force_suspend(dev);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused xcan_resume(struct device *dev)\r\n{\r\nif (!device_may_wakeup(dev))\r\nreturn pm_runtime_force_resume(dev);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused xcan_runtime_suspend(struct device *dev)\r\n{\r\nstruct net_device *ndev = dev_get_drvdata(dev);\r\nstruct xcan_priv *priv = netdev_priv(ndev);\r\nif (netif_running(ndev)) {\r\nnetif_stop_queue(ndev);\r\nnetif_device_detach(ndev);\r\n}\r\npriv->write_reg(priv, XCAN_MSR_OFFSET, XCAN_MSR_SLEEP_MASK);\r\npriv->can.state = CAN_STATE_SLEEPING;\r\nclk_disable_unprepare(priv->bus_clk);\r\nclk_disable_unprepare(priv->can_clk);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused xcan_runtime_resume(struct device *dev)\r\n{\r\nstruct net_device *ndev = dev_get_drvdata(dev);\r\nstruct xcan_priv *priv = netdev_priv(ndev);\r\nint ret;\r\nu32 isr, status;\r\nret = clk_prepare_enable(priv->bus_clk);\r\nif (ret) {\r\ndev_err(dev, "Cannot enable clock.\n");\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(priv->can_clk);\r\nif (ret) {\r\ndev_err(dev, "Cannot enable clock.\n");\r\nclk_disable_unprepare(priv->bus_clk);\r\nreturn ret;\r\n}\r\npriv->write_reg(priv, XCAN_SRR_OFFSET, XCAN_SRR_RESET_MASK);\r\nisr = priv->read_reg(priv, XCAN_ISR_OFFSET);\r\nstatus = priv->read_reg(priv, XCAN_SR_OFFSET);\r\nif (netif_running(ndev)) {\r\nif (isr & XCAN_IXR_BSOFF_MASK) {\r\npriv->can.state = CAN_STATE_BUS_OFF;\r\npriv->write_reg(priv, XCAN_SRR_OFFSET,\r\nXCAN_SRR_RESET_MASK);\r\n} else if ((status & XCAN_SR_ESTAT_MASK) ==\r\nXCAN_SR_ESTAT_MASK) {\r\npriv->can.state = CAN_STATE_ERROR_PASSIVE;\r\n} else if (status & XCAN_SR_ERRWRN_MASK) {\r\npriv->can.state = CAN_STATE_ERROR_WARNING;\r\n} else {\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\n}\r\nnetif_device_attach(ndev);\r\nnetif_start_queue(ndev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int xcan_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct net_device *ndev;\r\nstruct xcan_priv *priv;\r\nvoid __iomem *addr;\r\nint ret, rx_max, tx_max;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\naddr = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(addr)) {\r\nret = PTR_ERR(addr);\r\ngoto err;\r\n}\r\nret = of_property_read_u32(pdev->dev.of_node, "tx-fifo-depth", &tx_max);\r\nif (ret < 0)\r\ngoto err;\r\nret = of_property_read_u32(pdev->dev.of_node, "rx-fifo-depth", &rx_max);\r\nif (ret < 0)\r\ngoto err;\r\nndev = alloc_candev(sizeof(struct xcan_priv), tx_max);\r\nif (!ndev)\r\nreturn -ENOMEM;\r\npriv = netdev_priv(ndev);\r\npriv->dev = &pdev->dev;\r\npriv->can.bittiming_const = &xcan_bittiming_const;\r\npriv->can.do_set_mode = xcan_do_set_mode;\r\npriv->can.do_get_berr_counter = xcan_get_berr_counter;\r\npriv->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |\r\nCAN_CTRLMODE_BERR_REPORTING;\r\npriv->reg_base = addr;\r\npriv->tx_max = tx_max;\r\nndev->irq = platform_get_irq(pdev, 0);\r\nndev->flags |= IFF_ECHO;\r\nplatform_set_drvdata(pdev, ndev);\r\nSET_NETDEV_DEV(ndev, &pdev->dev);\r\nndev->netdev_ops = &xcan_netdev_ops;\r\npriv->can_clk = devm_clk_get(&pdev->dev, "can_clk");\r\nif (IS_ERR(priv->can_clk)) {\r\ndev_err(&pdev->dev, "Device clock not found.\n");\r\nret = PTR_ERR(priv->can_clk);\r\ngoto err_free;\r\n}\r\nif (of_device_is_compatible(pdev->dev.of_node,\r\n"xlnx,zynq-can-1.0")) {\r\npriv->bus_clk = devm_clk_get(&pdev->dev, "pclk");\r\nif (IS_ERR(priv->bus_clk)) {\r\ndev_err(&pdev->dev, "bus clock not found\n");\r\nret = PTR_ERR(priv->bus_clk);\r\ngoto err_free;\r\n}\r\n} else {\r\npriv->bus_clk = devm_clk_get(&pdev->dev, "s_axi_aclk");\r\nif (IS_ERR(priv->bus_clk)) {\r\ndev_err(&pdev->dev, "bus clock not found\n");\r\nret = PTR_ERR(priv->bus_clk);\r\ngoto err_free;\r\n}\r\n}\r\npriv->write_reg = xcan_write_reg_le;\r\npriv->read_reg = xcan_read_reg_le;\r\npm_runtime_enable(&pdev->dev);\r\nret = pm_runtime_get_sync(&pdev->dev);\r\nif (ret < 0) {\r\nnetdev_err(ndev, "%s: pm_runtime_get failed(%d)\n",\r\n__func__, ret);\r\ngoto err_pmdisable;\r\n}\r\nif (priv->read_reg(priv, XCAN_SR_OFFSET) != XCAN_SR_CONFIG_MASK) {\r\npriv->write_reg = xcan_write_reg_be;\r\npriv->read_reg = xcan_read_reg_be;\r\n}\r\npriv->can.clock.freq = clk_get_rate(priv->can_clk);\r\nnetif_napi_add(ndev, &priv->napi, xcan_rx_poll, rx_max);\r\nret = register_candev(ndev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "fail to register failed (err=%d)\n", ret);\r\ngoto err_disableclks;\r\n}\r\ndevm_can_led_init(ndev);\r\npm_runtime_put(&pdev->dev);\r\nnetdev_dbg(ndev, "reg_base=0x%p irq=%d clock=%d, tx fifo depth:%d\n",\r\npriv->reg_base, ndev->irq, priv->can.clock.freq,\r\npriv->tx_max);\r\nreturn 0;\r\nerr_disableclks:\r\npm_runtime_put(priv->dev);\r\nerr_pmdisable:\r\npm_runtime_disable(&pdev->dev);\r\nerr_free:\r\nfree_candev(ndev);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int xcan_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct xcan_priv *priv = netdev_priv(ndev);\r\nunregister_candev(ndev);\r\npm_runtime_disable(&pdev->dev);\r\nnetif_napi_del(&priv->napi);\r\nfree_candev(ndev);\r\nreturn 0;\r\n}
