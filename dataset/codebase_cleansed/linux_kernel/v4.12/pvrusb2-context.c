static void pvr2_context_set_notify(struct pvr2_context *mp, int fl)\r\n{\r\nint signal_flag = 0;\r\nmutex_lock(&pvr2_context_mutex);\r\nif (fl) {\r\nif (!mp->notify_flag) {\r\nsignal_flag = (pvr2_context_notify_first == NULL);\r\nmp->notify_prev = pvr2_context_notify_last;\r\nmp->notify_next = NULL;\r\npvr2_context_notify_last = mp;\r\nif (mp->notify_prev) {\r\nmp->notify_prev->notify_next = mp;\r\n} else {\r\npvr2_context_notify_first = mp;\r\n}\r\nmp->notify_flag = !0;\r\n}\r\n} else {\r\nif (mp->notify_flag) {\r\nmp->notify_flag = 0;\r\nif (mp->notify_next) {\r\nmp->notify_next->notify_prev = mp->notify_prev;\r\n} else {\r\npvr2_context_notify_last = mp->notify_prev;\r\n}\r\nif (mp->notify_prev) {\r\nmp->notify_prev->notify_next = mp->notify_next;\r\n} else {\r\npvr2_context_notify_first = mp->notify_next;\r\n}\r\n}\r\n}\r\nmutex_unlock(&pvr2_context_mutex);\r\nif (signal_flag) wake_up(&pvr2_context_sync_data);\r\n}\r\nstatic void pvr2_context_destroy(struct pvr2_context *mp)\r\n{\r\npvr2_trace(PVR2_TRACE_CTXT,"pvr2_context %p (destroy)",mp);\r\npvr2_hdw_destroy(mp->hdw);\r\npvr2_context_set_notify(mp, 0);\r\nmutex_lock(&pvr2_context_mutex);\r\nif (mp->exist_next) {\r\nmp->exist_next->exist_prev = mp->exist_prev;\r\n} else {\r\npvr2_context_exist_last = mp->exist_prev;\r\n}\r\nif (mp->exist_prev) {\r\nmp->exist_prev->exist_next = mp->exist_next;\r\n} else {\r\npvr2_context_exist_first = mp->exist_next;\r\n}\r\nif (!pvr2_context_exist_first) {\r\nwake_up(&pvr2_context_sync_data);\r\n}\r\nmutex_unlock(&pvr2_context_mutex);\r\nkfree(mp);\r\n}\r\nstatic void pvr2_context_notify(struct pvr2_context *mp)\r\n{\r\npvr2_context_set_notify(mp,!0);\r\n}\r\nstatic void pvr2_context_check(struct pvr2_context *mp)\r\n{\r\nstruct pvr2_channel *ch1, *ch2;\r\npvr2_trace(PVR2_TRACE_CTXT,\r\n"pvr2_context %p (notify)", mp);\r\nif (!mp->initialized_flag && !mp->disconnect_flag) {\r\nmp->initialized_flag = !0;\r\npvr2_trace(PVR2_TRACE_CTXT,\r\n"pvr2_context %p (initialize)", mp);\r\nif (pvr2_hdw_initialize(mp->hdw,\r\n(void (*)(void *))pvr2_context_notify,\r\nmp)) {\r\nmp->video_stream.stream =\r\npvr2_hdw_get_video_stream(mp->hdw);\r\nif (mp->setup_func) mp->setup_func(mp);\r\n} else {\r\npvr2_trace(PVR2_TRACE_CTXT,\r\n"pvr2_context %p (thread skipping setup)",\r\nmp);\r\n}\r\n}\r\nfor (ch1 = mp->mc_first; ch1; ch1 = ch2) {\r\nch2 = ch1->mc_next;\r\nif (ch1->check_func) ch1->check_func(ch1);\r\n}\r\nif (mp->disconnect_flag && !mp->mc_first) {\r\npvr2_context_destroy(mp);\r\nreturn;\r\n}\r\n}\r\nstatic int pvr2_context_shutok(void)\r\n{\r\nreturn pvr2_context_cleanup_flag && (pvr2_context_exist_first == NULL);\r\n}\r\nstatic int pvr2_context_thread_func(void *foo)\r\n{\r\nstruct pvr2_context *mp;\r\npvr2_trace(PVR2_TRACE_CTXT,"pvr2_context thread start");\r\ndo {\r\nwhile ((mp = pvr2_context_notify_first) != NULL) {\r\npvr2_context_set_notify(mp, 0);\r\npvr2_context_check(mp);\r\n}\r\nwait_event_interruptible(\r\npvr2_context_sync_data,\r\n((pvr2_context_notify_first != NULL) ||\r\npvr2_context_shutok()));\r\n} while (!pvr2_context_shutok());\r\npvr2_context_cleaned_flag = !0;\r\nwake_up(&pvr2_context_cleanup_data);\r\npvr2_trace(PVR2_TRACE_CTXT,"pvr2_context thread cleaned up");\r\nwait_event_interruptible(\r\npvr2_context_sync_data,\r\nkthread_should_stop());\r\npvr2_trace(PVR2_TRACE_CTXT,"pvr2_context thread end");\r\nreturn 0;\r\n}\r\nint pvr2_context_global_init(void)\r\n{\r\npvr2_context_thread_ptr = kthread_run(pvr2_context_thread_func,\r\nNULL,\r\n"pvrusb2-context");\r\nreturn IS_ERR(pvr2_context_thread_ptr) ? -ENOMEM : 0;\r\n}\r\nvoid pvr2_context_global_done(void)\r\n{\r\npvr2_context_cleanup_flag = !0;\r\nwake_up(&pvr2_context_sync_data);\r\nwait_event_interruptible(\r\npvr2_context_cleanup_data,\r\npvr2_context_cleaned_flag);\r\nkthread_stop(pvr2_context_thread_ptr);\r\n}\r\nstruct pvr2_context *pvr2_context_create(\r\nstruct usb_interface *intf,\r\nconst struct usb_device_id *devid,\r\nvoid (*setup_func)(struct pvr2_context *))\r\n{\r\nstruct pvr2_context *mp = NULL;\r\nmp = kzalloc(sizeof(*mp),GFP_KERNEL);\r\nif (!mp) goto done;\r\npvr2_trace(PVR2_TRACE_CTXT,"pvr2_context %p (create)",mp);\r\nmp->setup_func = setup_func;\r\nmutex_init(&mp->mutex);\r\nmutex_lock(&pvr2_context_mutex);\r\nmp->exist_prev = pvr2_context_exist_last;\r\nmp->exist_next = NULL;\r\npvr2_context_exist_last = mp;\r\nif (mp->exist_prev) {\r\nmp->exist_prev->exist_next = mp;\r\n} else {\r\npvr2_context_exist_first = mp;\r\n}\r\nmutex_unlock(&pvr2_context_mutex);\r\nmp->hdw = pvr2_hdw_create(intf,devid);\r\nif (!mp->hdw) {\r\npvr2_context_destroy(mp);\r\nmp = NULL;\r\ngoto done;\r\n}\r\npvr2_context_set_notify(mp, !0);\r\ndone:\r\nreturn mp;\r\n}\r\nstatic void pvr2_context_reset_input_limits(struct pvr2_context *mp)\r\n{\r\nunsigned int tmsk,mmsk;\r\nstruct pvr2_channel *cp;\r\nstruct pvr2_hdw *hdw = mp->hdw;\r\nmmsk = pvr2_hdw_get_input_available(hdw);\r\ntmsk = mmsk;\r\nfor (cp = mp->mc_first; cp; cp = cp->mc_next) {\r\nif (!cp->input_mask) continue;\r\ntmsk &= cp->input_mask;\r\n}\r\npvr2_hdw_set_input_allowed(hdw,mmsk,tmsk);\r\npvr2_hdw_commit_ctl(hdw);\r\n}\r\nstatic void pvr2_context_enter(struct pvr2_context *mp)\r\n{\r\nmutex_lock(&mp->mutex);\r\n}\r\nstatic void pvr2_context_exit(struct pvr2_context *mp)\r\n{\r\nint destroy_flag = 0;\r\nif (!(mp->mc_first || !mp->disconnect_flag)) {\r\ndestroy_flag = !0;\r\n}\r\nmutex_unlock(&mp->mutex);\r\nif (destroy_flag) pvr2_context_notify(mp);\r\n}\r\nvoid pvr2_context_disconnect(struct pvr2_context *mp)\r\n{\r\npvr2_hdw_disconnect(mp->hdw);\r\nmp->disconnect_flag = !0;\r\npvr2_context_notify(mp);\r\n}\r\nvoid pvr2_channel_init(struct pvr2_channel *cp,struct pvr2_context *mp)\r\n{\r\npvr2_context_enter(mp);\r\ncp->hdw = mp->hdw;\r\ncp->mc_head = mp;\r\ncp->mc_next = NULL;\r\ncp->mc_prev = mp->mc_last;\r\nif (mp->mc_last) {\r\nmp->mc_last->mc_next = cp;\r\n} else {\r\nmp->mc_first = cp;\r\n}\r\nmp->mc_last = cp;\r\npvr2_context_exit(mp);\r\n}\r\nstatic void pvr2_channel_disclaim_stream(struct pvr2_channel *cp)\r\n{\r\nif (!cp->stream) return;\r\npvr2_stream_kill(cp->stream->stream);\r\ncp->stream->user = NULL;\r\ncp->stream = NULL;\r\n}\r\nvoid pvr2_channel_done(struct pvr2_channel *cp)\r\n{\r\nstruct pvr2_context *mp = cp->mc_head;\r\npvr2_context_enter(mp);\r\ncp->input_mask = 0;\r\npvr2_channel_disclaim_stream(cp);\r\npvr2_context_reset_input_limits(mp);\r\nif (cp->mc_next) {\r\ncp->mc_next->mc_prev = cp->mc_prev;\r\n} else {\r\nmp->mc_last = cp->mc_prev;\r\n}\r\nif (cp->mc_prev) {\r\ncp->mc_prev->mc_next = cp->mc_next;\r\n} else {\r\nmp->mc_first = cp->mc_next;\r\n}\r\ncp->hdw = NULL;\r\npvr2_context_exit(mp);\r\n}\r\nint pvr2_channel_limit_inputs(struct pvr2_channel *cp,unsigned int cmsk)\r\n{\r\nunsigned int tmsk,mmsk;\r\nint ret = 0;\r\nstruct pvr2_channel *p2;\r\nstruct pvr2_hdw *hdw = cp->hdw;\r\nmmsk = pvr2_hdw_get_input_available(hdw);\r\ncmsk &= mmsk;\r\nif (cmsk == cp->input_mask) {\r\nreturn 0;\r\n}\r\npvr2_context_enter(cp->mc_head);\r\ndo {\r\nif (!cmsk) {\r\ncp->input_mask = 0;\r\npvr2_context_reset_input_limits(cp->mc_head);\r\nbreak;\r\n}\r\ntmsk = mmsk;\r\nfor (p2 = cp->mc_head->mc_first; p2; p2 = p2->mc_next) {\r\nif (p2 == cp) continue;\r\nif (!p2->input_mask) continue;\r\ntmsk &= p2->input_mask;\r\n}\r\nif (!(tmsk & cmsk)) {\r\nret = -EPERM;\r\nbreak;\r\n}\r\ntmsk &= cmsk;\r\nif ((ret = pvr2_hdw_set_input_allowed(hdw,mmsk,tmsk)) != 0) {\r\nbreak;\r\n}\r\ncp->input_mask = cmsk;\r\npvr2_hdw_commit_ctl(hdw);\r\n} while (0);\r\npvr2_context_exit(cp->mc_head);\r\nreturn ret;\r\n}\r\nunsigned int pvr2_channel_get_limited_inputs(struct pvr2_channel *cp)\r\n{\r\nreturn cp->input_mask;\r\n}\r\nint pvr2_channel_claim_stream(struct pvr2_channel *cp,\r\nstruct pvr2_context_stream *sp)\r\n{\r\nint code = 0;\r\npvr2_context_enter(cp->mc_head); do {\r\nif (sp == cp->stream) break;\r\nif (sp && sp->user) {\r\ncode = -EBUSY;\r\nbreak;\r\n}\r\npvr2_channel_disclaim_stream(cp);\r\nif (!sp) break;\r\nsp->user = cp;\r\ncp->stream = sp;\r\n} while (0);\r\npvr2_context_exit(cp->mc_head);\r\nreturn code;\r\n}\r\nstruct pvr2_ioread *pvr2_channel_create_mpeg_stream(\r\nstruct pvr2_context_stream *sp)\r\n{\r\nstruct pvr2_ioread *cp;\r\ncp = pvr2_ioread_create();\r\nif (!cp) return NULL;\r\npvr2_ioread_setup(cp,sp->stream);\r\npvr2_ioread_set_sync_key(cp,stream_sync_key,sizeof(stream_sync_key));\r\nreturn cp;\r\n}
