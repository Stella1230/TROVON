static struct gbaudio_data_connection *\r\nfind_data(struct gbaudio_module_info *module, int id)\r\n{\r\nstruct gbaudio_data_connection *data;\r\nlist_for_each_entry(data, &module->data_list, list) {\r\nif (id == data->id)\r\nreturn data;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct gbaudio_stream_params *\r\nfind_dai_stream_params(struct gbaudio_codec_info *codec, int id, int stream)\r\n{\r\nstruct gbaudio_codec_dai *dai;\r\nlist_for_each_entry(dai, &codec->dai_list, list) {\r\nif (dai->id == id)\r\nreturn &dai->params[stream];\r\n}\r\nreturn NULL;\r\n}\r\nstatic int gbaudio_module_enable_tx(struct gbaudio_codec_info *codec,\r\nstruct gbaudio_module_info *module, int id)\r\n{\r\nint module_state, ret = 0;\r\nu16 data_cport, i2s_port, cportid;\r\nu8 sig_bits, channels;\r\nuint32_t format, rate;\r\nstruct gbaudio_data_connection *data;\r\nstruct gbaudio_stream_params *params;\r\ndata = find_data(module, id);\r\nif (!data) {\r\ndev_err(module->dev, "%d:DATA connection missing\n", id);\r\nreturn -ENODEV;\r\n}\r\nmodule_state = data->state[SNDRV_PCM_STREAM_PLAYBACK];\r\nparams = find_dai_stream_params(codec, id, SNDRV_PCM_STREAM_PLAYBACK);\r\nif (!params) {\r\ndev_err(codec->dev, "Failed to fetch dai_stream pointer\n");\r\nreturn -EINVAL;\r\n}\r\nif (module_state < GBAUDIO_CODEC_STARTUP) {\r\ni2s_port = 0;\r\ncportid = data->connection->hd_cport_id;\r\nret = gb_audio_apbridgea_register_cport(data->connection,\r\ni2s_port, cportid,\r\nAUDIO_APBRIDGEA_DIRECTION_TX);\r\nif (ret) {\r\ndev_err_ratelimited(module->dev,\r\n"reg_cport failed:%d\n", ret);\r\nreturn ret;\r\n}\r\ndata->state[SNDRV_PCM_STREAM_PLAYBACK] =\r\nGBAUDIO_CODEC_STARTUP;\r\ndev_dbg(module->dev, "Dynamic Register %d DAI\n", cportid);\r\n}\r\nif (module_state < GBAUDIO_CODEC_HWPARAMS) {\r\nformat = params->format;\r\nchannels = params->channels;\r\nrate = params->rate;\r\nsig_bits = params->sig_bits;\r\ndata_cport = data->connection->intf_cport_id;\r\nret = gb_audio_gb_set_pcm(module->mgmt_connection, data_cport,\r\nformat, rate, channels, sig_bits);\r\nif (ret) {\r\ndev_err_ratelimited(module->dev, "set_pcm failed:%d\n",\r\nret);\r\nreturn ret;\r\n}\r\ndata->state[SNDRV_PCM_STREAM_PLAYBACK] =\r\nGBAUDIO_CODEC_HWPARAMS;\r\ndev_dbg(module->dev, "Dynamic hw_params %d DAI\n", data_cport);\r\n}\r\nif (module_state < GBAUDIO_CODEC_PREPARE) {\r\ndata_cport = data->connection->intf_cport_id;\r\nret = gb_audio_gb_set_tx_data_size(module->mgmt_connection,\r\ndata_cport, 192);\r\nif (ret) {\r\ndev_err_ratelimited(module->dev,\r\n"set_tx_data_size failed:%d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = gb_audio_gb_activate_tx(module->mgmt_connection,\r\ndata_cport);\r\nif (ret) {\r\ndev_err_ratelimited(module->dev,\r\n"activate_tx failed:%d\n", ret);\r\nreturn ret;\r\n}\r\ndata->state[SNDRV_PCM_STREAM_PLAYBACK] =\r\nGBAUDIO_CODEC_PREPARE;\r\ndev_dbg(module->dev, "Dynamic prepare %d DAI\n", data_cport);\r\n}\r\nreturn 0;\r\n}\r\nstatic int gbaudio_module_disable_tx(struct gbaudio_module_info *module, int id)\r\n{\r\nint ret;\r\nu16 data_cport, cportid, i2s_port;\r\nint module_state;\r\nstruct gbaudio_data_connection *data;\r\ndata = find_data(module, id);\r\nif (!data) {\r\ndev_err(module->dev, "%d:DATA connection missing\n", id);\r\nreturn -ENODEV;\r\n}\r\nmodule_state = data->state[SNDRV_PCM_STREAM_PLAYBACK];\r\nif (module_state > GBAUDIO_CODEC_HWPARAMS) {\r\ndata_cport = data->connection->intf_cport_id;\r\nret = gb_audio_gb_deactivate_tx(module->mgmt_connection,\r\ndata_cport);\r\nif (ret) {\r\ndev_err_ratelimited(module->dev,\r\n"deactivate_tx failed:%d\n", ret);\r\nreturn ret;\r\n}\r\ndev_dbg(module->dev, "Dynamic deactivate %d DAI\n", data_cport);\r\ndata->state[SNDRV_PCM_STREAM_PLAYBACK] =\r\nGBAUDIO_CODEC_HWPARAMS;\r\n}\r\nif (module_state > GBAUDIO_CODEC_SHUTDOWN) {\r\ni2s_port = 0;\r\ncportid = data->connection->hd_cport_id;\r\nret = gb_audio_apbridgea_unregister_cport(data->connection,\r\ni2s_port, cportid,\r\nAUDIO_APBRIDGEA_DIRECTION_TX);\r\nif (ret) {\r\ndev_err_ratelimited(module->dev,\r\n"unregister_cport failed:%d\n",\r\nret);\r\nreturn ret;\r\n}\r\ndev_dbg(module->dev, "Dynamic Unregister %d DAI\n", cportid);\r\ndata->state[SNDRV_PCM_STREAM_PLAYBACK] =\r\nGBAUDIO_CODEC_SHUTDOWN;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gbaudio_module_enable_rx(struct gbaudio_codec_info *codec,\r\nstruct gbaudio_module_info *module, int id)\r\n{\r\nint module_state, ret = 0;\r\nu16 data_cport, i2s_port, cportid;\r\nu8 sig_bits, channels;\r\nuint32_t format, rate;\r\nstruct gbaudio_data_connection *data;\r\nstruct gbaudio_stream_params *params;\r\ndata = find_data(module, id);\r\nif (!data) {\r\ndev_err(module->dev, "%d:DATA connection missing\n", id);\r\nreturn -ENODEV;\r\n}\r\nmodule_state = data->state[SNDRV_PCM_STREAM_CAPTURE];\r\nparams = find_dai_stream_params(codec, id, SNDRV_PCM_STREAM_CAPTURE);\r\nif (!params) {\r\ndev_err(codec->dev, "Failed to fetch dai_stream pointer\n");\r\nreturn -EINVAL;\r\n}\r\nif (module_state < GBAUDIO_CODEC_STARTUP) {\r\ni2s_port = 0;\r\ncportid = data->connection->hd_cport_id;\r\nret = gb_audio_apbridgea_register_cport(data->connection,\r\ni2s_port, cportid,\r\nAUDIO_APBRIDGEA_DIRECTION_RX);\r\nif (ret) {\r\ndev_err_ratelimited(module->dev,\r\n"reg_cport failed:%d\n", ret);\r\nreturn ret;\r\n}\r\ndata->state[SNDRV_PCM_STREAM_CAPTURE] =\r\nGBAUDIO_CODEC_STARTUP;\r\ndev_dbg(module->dev, "Dynamic Register %d DAI\n", cportid);\r\n}\r\nif (module_state < GBAUDIO_CODEC_HWPARAMS) {\r\nformat = params->format;\r\nchannels = params->channels;\r\nrate = params->rate;\r\nsig_bits = params->sig_bits;\r\ndata_cport = data->connection->intf_cport_id;\r\nret = gb_audio_gb_set_pcm(module->mgmt_connection, data_cport,\r\nformat, rate, channels, sig_bits);\r\nif (ret) {\r\ndev_err_ratelimited(module->dev, "set_pcm failed:%d\n",\r\nret);\r\nreturn ret;\r\n}\r\ndata->state[SNDRV_PCM_STREAM_CAPTURE] =\r\nGBAUDIO_CODEC_HWPARAMS;\r\ndev_dbg(module->dev, "Dynamic hw_params %d DAI\n", data_cport);\r\n}\r\nif (module_state < GBAUDIO_CODEC_PREPARE) {\r\ndata_cport = data->connection->intf_cport_id;\r\nret = gb_audio_gb_set_rx_data_size(module->mgmt_connection,\r\ndata_cport, 192);\r\nif (ret) {\r\ndev_err_ratelimited(module->dev,\r\n"set_rx_data_size failed:%d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = gb_audio_gb_activate_rx(module->mgmt_connection,\r\ndata_cport);\r\nif (ret) {\r\ndev_err_ratelimited(module->dev,\r\n"activate_rx failed:%d\n", ret);\r\nreturn ret;\r\n}\r\ndata->state[SNDRV_PCM_STREAM_CAPTURE] =\r\nGBAUDIO_CODEC_PREPARE;\r\ndev_dbg(module->dev, "Dynamic prepare %d DAI\n", data_cport);\r\n}\r\nreturn 0;\r\n}\r\nstatic int gbaudio_module_disable_rx(struct gbaudio_module_info *module, int id)\r\n{\r\nint ret;\r\nu16 data_cport, cportid, i2s_port;\r\nint module_state;\r\nstruct gbaudio_data_connection *data;\r\ndata = find_data(module, id);\r\nif (!data) {\r\ndev_err(module->dev, "%d:DATA connection missing\n", id);\r\nreturn -ENODEV;\r\n}\r\nmodule_state = data->state[SNDRV_PCM_STREAM_CAPTURE];\r\nif (module_state > GBAUDIO_CODEC_HWPARAMS) {\r\ndata_cport = data->connection->intf_cport_id;\r\nret = gb_audio_gb_deactivate_rx(module->mgmt_connection,\r\ndata_cport);\r\nif (ret) {\r\ndev_err_ratelimited(module->dev,\r\n"deactivate_rx failed:%d\n", ret);\r\nreturn ret;\r\n}\r\ndev_dbg(module->dev, "Dynamic deactivate %d DAI\n", data_cport);\r\ndata->state[SNDRV_PCM_STREAM_CAPTURE] =\r\nGBAUDIO_CODEC_HWPARAMS;\r\n}\r\nif (module_state > GBAUDIO_CODEC_SHUTDOWN) {\r\ni2s_port = 0;\r\ncportid = data->connection->hd_cport_id;\r\nret = gb_audio_apbridgea_unregister_cport(data->connection,\r\ni2s_port, cportid,\r\nAUDIO_APBRIDGEA_DIRECTION_RX);\r\nif (ret) {\r\ndev_err_ratelimited(module->dev,\r\n"unregister_cport failed:%d\n",\r\nret);\r\nreturn ret;\r\n}\r\ndev_dbg(module->dev, "Dynamic Unregister %d DAI\n", cportid);\r\ndata->state[SNDRV_PCM_STREAM_CAPTURE] =\r\nGBAUDIO_CODEC_SHUTDOWN;\r\n}\r\nreturn 0;\r\n}\r\nint gbaudio_module_update(struct gbaudio_codec_info *codec,\r\nstruct snd_soc_dapm_widget *w,\r\nstruct gbaudio_module_info *module, int enable)\r\n{\r\nint dai_id, ret;\r\nchar intf_name[NAME_SIZE], dir[NAME_SIZE];\r\ndev_dbg(module->dev, "%s:Module update %s sequence\n", w->name,\r\nenable ? "Enable":"Disable");\r\nif ((w->id != snd_soc_dapm_aif_in) && (w->id != snd_soc_dapm_aif_out)) {\r\ndev_dbg(codec->dev, "No action required for %s\n", w->name);\r\nreturn 0;\r\n}\r\nret = sscanf(w->sname, "%s %d %s", intf_name, &dai_id, dir);\r\nif (ret < 3) {\r\ndev_err(codec->dev, "Error while parsing dai_id for %s\n",\r\nw->name);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&codec->lock);\r\nif (w->id == snd_soc_dapm_aif_in) {\r\nif (enable)\r\nret = gbaudio_module_enable_tx(codec, module, dai_id);\r\nelse\r\nret = gbaudio_module_disable_tx(module, dai_id);\r\n} else if (w->id == snd_soc_dapm_aif_out) {\r\nif (enable)\r\nret = gbaudio_module_enable_rx(codec, module, dai_id);\r\nelse\r\nret = gbaudio_module_disable_rx(module, dai_id);\r\n}\r\nmutex_unlock(&codec->lock);\r\nreturn ret;\r\n}\r\nstatic int gbcodec_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);\r\nstruct gbaudio_stream_params *params;\r\nmutex_lock(&codec->lock);\r\nif (list_empty(&codec->module_list)) {\r\ndev_err(codec->dev, "No codec module available\n");\r\nmutex_unlock(&codec->lock);\r\nreturn -ENODEV;\r\n}\r\nparams = find_dai_stream_params(codec, dai->id, substream->stream);\r\nif (!params) {\r\ndev_err(codec->dev, "Failed to fetch dai_stream pointer\n");\r\nmutex_unlock(&codec->lock);\r\nreturn -EINVAL;\r\n}\r\nparams->state = GBAUDIO_CODEC_STARTUP;\r\nmutex_unlock(&codec->lock);\r\npm_stay_awake(dai->dev);\r\nreturn 0;\r\n}\r\nstatic void gbcodec_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);\r\nstruct gbaudio_stream_params *params;\r\nmutex_lock(&codec->lock);\r\nif (list_empty(&codec->module_list))\r\ndev_info(codec->dev, "No codec module available during shutdown\n");\r\nparams = find_dai_stream_params(codec, dai->id, substream->stream);\r\nif (!params) {\r\ndev_err(codec->dev, "Failed to fetch dai_stream pointer\n");\r\nmutex_unlock(&codec->lock);\r\nreturn;\r\n}\r\nparams->state = GBAUDIO_CODEC_SHUTDOWN;\r\nmutex_unlock(&codec->lock);\r\npm_relax(dai->dev);\r\n}\r\nstatic int gbcodec_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hwparams,\r\nstruct snd_soc_dai *dai)\r\n{\r\nint ret;\r\nu8 sig_bits, channels;\r\nuint32_t format, rate;\r\nstruct gbaudio_module_info *module;\r\nstruct gbaudio_data_connection *data;\r\nstruct gb_bundle *bundle;\r\nstruct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);\r\nstruct gbaudio_stream_params *params;\r\nmutex_lock(&codec->lock);\r\nif (list_empty(&codec->module_list)) {\r\ndev_err(codec->dev, "No codec module available\n");\r\nmutex_unlock(&codec->lock);\r\nreturn -ENODEV;\r\n}\r\nif (params_channels(hwparams) != 2) {\r\ndev_err(dai->dev, "Invalid channel count:%d\n",\r\nparams_channels(hwparams));\r\nmutex_unlock(&codec->lock);\r\nreturn -EINVAL;\r\n}\r\nchannels = params_channels(hwparams);\r\nif (params_rate(hwparams) != 48000) {\r\ndev_err(dai->dev, "Invalid sampling rate:%d\n",\r\nparams_rate(hwparams));\r\nmutex_unlock(&codec->lock);\r\nreturn -EINVAL;\r\n}\r\nrate = GB_AUDIO_PCM_RATE_48000;\r\nif (params_format(hwparams) != SNDRV_PCM_FORMAT_S16_LE) {\r\ndev_err(dai->dev, "Invalid format:%d\n",\r\nparams_format(hwparams));\r\nmutex_unlock(&codec->lock);\r\nreturn -EINVAL;\r\n}\r\nformat = GB_AUDIO_PCM_FMT_S16_LE;\r\nlist_for_each_entry(module, &codec->module_list, list) {\r\ndata = find_data(module, dai->id);\r\nif (data)\r\nbreak;\r\n}\r\nif (!data) {\r\ndev_err(dai->dev, "DATA connection missing\n");\r\nmutex_unlock(&codec->lock);\r\nreturn -EINVAL;\r\n}\r\nparams = find_dai_stream_params(codec, dai->id, substream->stream);\r\nif (!params) {\r\ndev_err(codec->dev, "Failed to fetch dai_stream pointer\n");\r\nmutex_unlock(&codec->lock);\r\nreturn -EINVAL;\r\n}\r\nbundle = to_gb_bundle(module->dev);\r\nret = gb_pm_runtime_get_sync(bundle);\r\nif (ret) {\r\nmutex_unlock(&codec->lock);\r\nreturn ret;\r\n}\r\nret = gb_audio_apbridgea_set_config(data->connection, 0,\r\nAUDIO_APBRIDGEA_PCM_FMT_16,\r\nAUDIO_APBRIDGEA_PCM_RATE_48000,\r\n6144000);\r\nif (ret) {\r\ndev_err_ratelimited(dai->dev, "%d: Error during set_config\n",\r\nret);\r\nmutex_unlock(&codec->lock);\r\nreturn ret;\r\n}\r\ngb_pm_runtime_put_noidle(bundle);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nsig_bits = dai->driver->playback.sig_bits;\r\nelse\r\nsig_bits = dai->driver->capture.sig_bits;\r\nparams->state = GBAUDIO_CODEC_HWPARAMS;\r\nparams->format = format;\r\nparams->rate = rate;\r\nparams->channels = channels;\r\nparams->sig_bits = sig_bits;\r\nmutex_unlock(&codec->lock);\r\nreturn 0;\r\n}\r\nstatic int gbcodec_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nint ret;\r\nstruct gbaudio_module_info *module;\r\nstruct gbaudio_data_connection *data;\r\nstruct gb_bundle *bundle;\r\nstruct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);\r\nstruct gbaudio_stream_params *params;\r\nmutex_lock(&codec->lock);\r\nif (list_empty(&codec->module_list)) {\r\ndev_err(codec->dev, "No codec module available\n");\r\nmutex_unlock(&codec->lock);\r\nreturn -ENODEV;\r\n}\r\nlist_for_each_entry(module, &codec->module_list, list) {\r\ndata = find_data(module, dai->id);\r\nif (data)\r\nbreak;\r\n}\r\nif (!data) {\r\ndev_err(dai->dev, "DATA connection missing\n");\r\nmutex_unlock(&codec->lock);\r\nreturn -ENODEV;\r\n}\r\nparams = find_dai_stream_params(codec, dai->id, substream->stream);\r\nif (!params) {\r\ndev_err(codec->dev, "Failed to fetch dai_stream pointer\n");\r\nmutex_unlock(&codec->lock);\r\nreturn -EINVAL;\r\n}\r\nbundle = to_gb_bundle(module->dev);\r\nret = gb_pm_runtime_get_sync(bundle);\r\nif (ret) {\r\nmutex_unlock(&codec->lock);\r\nreturn ret;\r\n}\r\nswitch (substream->stream) {\r\ncase SNDRV_PCM_STREAM_PLAYBACK:\r\nret = gb_audio_apbridgea_set_tx_data_size(data->connection, 0,\r\n192);\r\nbreak;\r\ncase SNDRV_PCM_STREAM_CAPTURE:\r\nret = gb_audio_apbridgea_set_rx_data_size(data->connection, 0,\r\n192);\r\nbreak;\r\n}\r\nif (ret) {\r\nmutex_unlock(&codec->lock);\r\ndev_err_ratelimited(dai->dev, "set_data_size failed:%d\n",\r\nret);\r\nreturn ret;\r\n}\r\ngb_pm_runtime_put_noidle(bundle);\r\nparams->state = GBAUDIO_CODEC_PREPARE;\r\nmutex_unlock(&codec->lock);\r\nreturn 0;\r\n}\r\nstatic int gbcodec_mute_stream(struct snd_soc_dai *dai, int mute, int stream)\r\n{\r\nint ret;\r\nstruct gbaudio_data_connection *data;\r\nstruct gbaudio_module_info *module;\r\nstruct gb_bundle *bundle;\r\nstruct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);\r\nstruct gbaudio_stream_params *params;\r\ndev_dbg(dai->dev, "Mute:%d, Direction:%s\n", mute,\r\nstream ? "CAPTURE":"PLAYBACK");\r\nmutex_lock(&codec->lock);\r\nparams = find_dai_stream_params(codec, dai->id, stream);\r\nif (!params) {\r\ndev_err(codec->dev, "Failed to fetch dai_stream pointer\n");\r\nmutex_unlock(&codec->lock);\r\nreturn -EINVAL;\r\n}\r\nif (list_empty(&codec->module_list)) {\r\ndev_err(codec->dev, "No codec module available\n");\r\nif (mute) {\r\nparams->state = GBAUDIO_CODEC_STOP;\r\nret = 0;\r\n} else {\r\nret = -ENODEV;\r\n}\r\nmutex_unlock(&codec->lock);\r\nreturn ret;\r\n}\r\nlist_for_each_entry(module, &codec->module_list, list) {\r\ndata = find_data(module, dai->id);\r\nif (data)\r\nbreak;\r\n}\r\nif (!data) {\r\ndev_err(dai->dev, "%s:%s DATA connection missing\n",\r\ndai->name, module->name);\r\nmutex_unlock(&codec->lock);\r\nreturn -ENODEV;\r\n}\r\nbundle = to_gb_bundle(module->dev);\r\nret = gb_pm_runtime_get_sync(bundle);\r\nif (ret) {\r\nmutex_unlock(&codec->lock);\r\nreturn ret;\r\n}\r\nif (!mute && !stream) {\r\nret = gb_audio_apbridgea_prepare_tx(data->connection,\r\n0);\r\nif (!ret)\r\nret = gb_audio_apbridgea_start_tx(data->connection,\r\n0, 0);\r\nparams->state = GBAUDIO_CODEC_START;\r\n} else if (!mute && stream) {\r\nret = gb_audio_apbridgea_prepare_rx(data->connection,\r\n0);\r\nif (!ret)\r\nret = gb_audio_apbridgea_start_rx(data->connection,\r\n0);\r\nparams->state = GBAUDIO_CODEC_START;\r\n} else if (mute && !stream) {\r\nret = gb_audio_apbridgea_stop_tx(data->connection, 0);\r\nif (!ret)\r\nret = gb_audio_apbridgea_shutdown_tx(data->connection,\r\n0);\r\nparams->state = GBAUDIO_CODEC_STOP;\r\n} else if (mute && stream) {\r\nret = gb_audio_apbridgea_stop_rx(data->connection, 0);\r\nif (!ret)\r\nret = gb_audio_apbridgea_shutdown_rx(data->connection,\r\n0);\r\nparams->state = GBAUDIO_CODEC_STOP;\r\n} else {\r\nret = -EINVAL;\r\n}\r\nif (ret)\r\ndev_err_ratelimited(dai->dev,\r\n"%s:Error during %s %s stream:%d\n",\r\nmodule->name, mute ? "Mute" : "Unmute",\r\nstream ? "Capture" : "Playback", ret);\r\ngb_pm_runtime_put_noidle(bundle);\r\nmutex_unlock(&codec->lock);\r\nreturn ret;\r\n}\r\nstatic int gbaudio_init_jack(struct gbaudio_module_info *module,\r\nstruct snd_soc_codec *codec)\r\n{\r\nint ret;\r\nif (!module->jack_mask)\r\nreturn 0;\r\nsnprintf(module->jack_name, NAME_SIZE, "GB %d Headset Jack",\r\nmodule->dev_id);\r\nret = snd_soc_jack_new(codec, module->jack_name, module->jack_mask,\r\n&module->headset_jack);\r\nif (ret) {\r\ndev_err(module->dev, "Failed to create new jack\n");\r\nreturn ret;\r\n}\r\nif (!module->button_mask)\r\nreturn 0;\r\nsnprintf(module->button_name, NAME_SIZE, "GB %d Button Jack",\r\nmodule->dev_id);\r\nret = snd_soc_jack_new(codec, module->button_name, module->button_mask,\r\n&module->button_jack);\r\nif (ret) {\r\ndev_err(module->dev, "Failed to create button jack\n");\r\nreturn ret;\r\n}\r\nif (module->button_mask & SND_JACK_BTN_0) {\r\nret = snd_jack_set_key(module->button_jack.jack, SND_JACK_BTN_0,\r\nKEY_MEDIA);\r\nif (ret) {\r\ndev_err(module->dev, "Failed to set BTN_0\n");\r\nreturn ret;\r\n}\r\n}\r\nif (module->button_mask & SND_JACK_BTN_1) {\r\nret = snd_jack_set_key(module->button_jack.jack, SND_JACK_BTN_1,\r\nKEY_VOICECOMMAND);\r\nif (ret) {\r\ndev_err(module->dev, "Failed to set BTN_1\n");\r\nreturn ret;\r\n}\r\n}\r\nif (module->button_mask & SND_JACK_BTN_2) {\r\nret = snd_jack_set_key(module->button_jack.jack, SND_JACK_BTN_2,\r\nKEY_VOLUMEUP);\r\nif (ret) {\r\ndev_err(module->dev, "Failed to set BTN_2\n");\r\nreturn ret;\r\n}\r\n}\r\nif (module->button_mask & SND_JACK_BTN_3) {\r\nret = snd_jack_set_key(module->button_jack.jack, SND_JACK_BTN_3,\r\nKEY_VOLUMEDOWN);\r\nif (ret) {\r\ndev_err(module->dev, "Failed to set BTN_0\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint gbaudio_register_module(struct gbaudio_module_info *module)\r\n{\r\nint ret;\r\nstruct snd_soc_codec *codec;\r\nstruct snd_card *card;\r\nstruct snd_soc_jack *jack = NULL;\r\nif (!gbcodec) {\r\ndev_err(module->dev, "GB Codec not yet probed\n");\r\nreturn -EAGAIN;\r\n}\r\ncodec = gbcodec->codec;\r\ncard = codec->card->snd_card;\r\ndown_write(&card->controls_rwsem);\r\nif (module->num_dais) {\r\ndev_err(gbcodec->dev,\r\n"%d:DAIs not supported via gbcodec driver\n",\r\nmodule->num_dais);\r\nup_write(&card->controls_rwsem);\r\nreturn -EINVAL;\r\n}\r\nret = gbaudio_init_jack(module, codec);\r\nif (ret) {\r\nup_write(&card->controls_rwsem);\r\nreturn ret;\r\n}\r\nif (module->dapm_widgets)\r\nsnd_soc_dapm_new_controls(&codec->dapm, module->dapm_widgets,\r\nmodule->num_dapm_widgets);\r\nif (module->controls)\r\nsnd_soc_add_codec_controls(codec, module->controls,\r\nmodule->num_controls);\r\nif (module->dapm_routes)\r\nsnd_soc_dapm_add_routes(&codec->dapm, module->dapm_routes,\r\nmodule->num_dapm_routes);\r\nif (codec->card->instantiated) {\r\nsnd_soc_dapm_link_component_dai_widgets(codec->card,\r\n&codec->dapm);\r\n#ifdef CONFIG_SND_JACK\r\nlist_for_each_entry(jack, &codec->jack_list, list) {\r\nif ((jack == &module->headset_jack)\r\n|| (jack == &module->button_jack))\r\nsnd_device_register(codec->card->snd_card,\r\njack->jack);\r\n}\r\n#endif\r\n}\r\nmutex_lock(&gbcodec->lock);\r\nlist_add(&module->list, &gbcodec->module_list);\r\nmutex_unlock(&gbcodec->lock);\r\nif (codec->card->instantiated)\r\nret = snd_soc_dapm_new_widgets(&codec->dapm);\r\ndev_dbg(codec->dev, "Registered %s module\n", module->name);\r\nup_write(&card->controls_rwsem);\r\nreturn ret;\r\n}\r\nstatic void gbaudio_codec_clean_data_tx(struct gbaudio_data_connection *data)\r\n{\r\nu16 i2s_port, cportid;\r\nint ret;\r\nif (list_is_singular(&gbcodec->module_list)) {\r\nret = gb_audio_apbridgea_stop_tx(data->connection, 0);\r\nif (ret)\r\nreturn;\r\nret = gb_audio_apbridgea_shutdown_tx(data->connection,\r\n0);\r\nif (ret)\r\nreturn;\r\n}\r\ni2s_port = 0;\r\ncportid = data->connection->hd_cport_id;\r\nret = gb_audio_apbridgea_unregister_cport(data->connection,\r\ni2s_port, cportid,\r\nAUDIO_APBRIDGEA_DIRECTION_TX);\r\ndata->state[0] = GBAUDIO_CODEC_SHUTDOWN;\r\n}\r\nstatic void gbaudio_codec_clean_data_rx(struct gbaudio_data_connection *data)\r\n{\r\nu16 i2s_port, cportid;\r\nint ret;\r\nif (list_is_singular(&gbcodec->module_list)) {\r\nret = gb_audio_apbridgea_stop_rx(data->connection, 0);\r\nif (ret)\r\nreturn;\r\nret = gb_audio_apbridgea_shutdown_rx(data->connection,\r\n0);\r\nif (ret)\r\nreturn;\r\n}\r\ni2s_port = 0;\r\ncportid = data->connection->hd_cport_id;\r\nret = gb_audio_apbridgea_unregister_cport(data->connection,\r\ni2s_port, cportid,\r\nAUDIO_APBRIDGEA_DIRECTION_RX);\r\ndata->state[1] = GBAUDIO_CODEC_SHUTDOWN;\r\n}\r\nstatic void gbaudio_codec_cleanup(struct gbaudio_module_info *module)\r\n{\r\nstruct gbaudio_data_connection *data;\r\nint pb_state, cap_state;\r\ndev_dbg(gbcodec->dev, "%s: removed, cleanup APBridge\n", module->name);\r\nlist_for_each_entry(data, &module->data_list, list) {\r\npb_state = data->state[0];\r\ncap_state = data->state[1];\r\nif (pb_state > GBAUDIO_CODEC_SHUTDOWN)\r\ngbaudio_codec_clean_data_tx(data);\r\nif (cap_state > GBAUDIO_CODEC_SHUTDOWN)\r\ngbaudio_codec_clean_data_rx(data);\r\n}\r\n}\r\nvoid gbaudio_unregister_module(struct gbaudio_module_info *module)\r\n{\r\nstruct snd_soc_codec *codec = gbcodec->codec;\r\nstruct snd_card *card = codec->card->snd_card;\r\nstruct snd_soc_jack *jack, *next_j;\r\nint mask;\r\ndev_dbg(codec->dev, "Unregister %s module\n", module->name);\r\ndown_write(&card->controls_rwsem);\r\nmutex_lock(&gbcodec->lock);\r\ngbaudio_codec_cleanup(module);\r\nlist_del(&module->list);\r\ndev_dbg(codec->dev, "Process Unregister %s module\n", module->name);\r\nmutex_unlock(&gbcodec->lock);\r\n#ifdef CONFIG_SND_JACK\r\nlist_for_each_entry_safe(jack, next_j, &codec->jack_list, list) {\r\nif (jack == &module->headset_jack)\r\nmask = GBCODEC_JACK_MASK;\r\nelse if (jack == &module->button_jack)\r\nmask = GBCODEC_JACK_BUTTON_MASK;\r\nelse\r\nmask = 0;\r\nif (mask) {\r\ndev_dbg(module->dev, "Report %s removal\n",\r\njack->jack->id);\r\nsnd_soc_jack_report(jack, 0, mask);\r\nsnd_device_free(codec->card->snd_card, jack->jack);\r\nlist_del(&jack->list);\r\n}\r\n}\r\n#endif\r\nif (module->dapm_routes) {\r\ndev_dbg(codec->dev, "Removing %d routes\n",\r\nmodule->num_dapm_routes);\r\nsnd_soc_dapm_del_routes(&codec->dapm, module->dapm_routes,\r\nmodule->num_dapm_routes);\r\n}\r\nif (module->controls) {\r\ndev_dbg(codec->dev, "Removing %d controls\n",\r\nmodule->num_controls);\r\nsnd_soc_remove_codec_controls(codec, module->controls,\r\nmodule->num_controls);\r\n}\r\nif (module->dapm_widgets) {\r\ndev_dbg(codec->dev, "Removing %d widgets\n",\r\nmodule->num_dapm_widgets);\r\nsnd_soc_dapm_free_controls(&codec->dapm, module->dapm_widgets,\r\nmodule->num_dapm_widgets);\r\n}\r\ndev_dbg(codec->dev, "Unregistered %s module\n", module->name);\r\nup_write(&card->controls_rwsem);\r\n}\r\nstatic int gbcodec_probe(struct snd_soc_codec *codec)\r\n{\r\nint i;\r\nstruct gbaudio_codec_info *info;\r\nstruct gbaudio_codec_dai *dai;\r\ninfo = devm_kzalloc(codec->dev, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->dev = codec->dev;\r\nINIT_LIST_HEAD(&info->module_list);\r\nmutex_init(&info->lock);\r\nINIT_LIST_HEAD(&info->dai_list);\r\nfor (i = 0; i < ARRAY_SIZE(gbaudio_dai); i++) {\r\ndai = devm_kzalloc(codec->dev, sizeof(*dai), GFP_KERNEL);\r\nif (!dai)\r\nreturn -ENOMEM;\r\ndai->id = gbaudio_dai[i].id;\r\nlist_add(&dai->list, &info->dai_list);\r\n}\r\ninfo->codec = codec;\r\nsnd_soc_codec_set_drvdata(codec, info);\r\ngbcodec = info;\r\ndevice_init_wakeup(codec->dev, 1);\r\nreturn 0;\r\n}\r\nstatic int gbcodec_remove(struct snd_soc_codec *codec)\r\n{\r\nreturn 0;\r\n}\r\nstatic int gbcodec_write(struct snd_soc_codec *codec, unsigned int reg,\r\nunsigned int value)\r\n{\r\nreturn 0;\r\n}\r\nstatic unsigned int gbcodec_read(struct snd_soc_codec *codec,\r\nunsigned int reg)\r\n{\r\nreturn 0;\r\n}\r\nstatic int gbaudio_codec_suspend(struct device *dev)\r\n{\r\ndev_dbg(dev, "%s: suspend\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int gbaudio_codec_resume(struct device *dev)\r\n{\r\ndev_dbg(dev, "%s: resume\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int gbaudio_codec_probe(struct platform_device *pdev)\r\n{\r\nreturn snd_soc_register_codec(&pdev->dev, &soc_codec_dev_gbaudio,\r\ngbaudio_dai, ARRAY_SIZE(gbaudio_dai));\r\n}\r\nstatic int gbaudio_codec_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_codec(&pdev->dev);\r\nreturn 0;\r\n}
