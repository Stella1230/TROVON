static int elan_smbus_initialize(struct i2c_client *client)\r\n{\r\nu8 check[ETP_SMBUS_HELLOPACKET_LEN] = { 0x55, 0x55, 0x55, 0x55, 0x55 };\r\nu8 values[ETP_SMBUS_HELLOPACKET_LEN] = { 0, 0, 0, 0, 0 };\r\nint len, error;\r\nlen = i2c_smbus_read_block_data(client,\r\nETP_SMBUS_HELLOPACKET_CMD, values);\r\nif (len != ETP_SMBUS_HELLOPACKET_LEN) {\r\ndev_err(&client->dev, "hello packet length fail: %d\n", len);\r\nerror = len < 0 ? len : -EIO;\r\nreturn error;\r\n}\r\nif (memcmp(values, check, ETP_SMBUS_HELLOPACKET_LEN)) {\r\ndev_err(&client->dev, "hello packet fail [%*ph]\n",\r\nETP_SMBUS_HELLOPACKET_LEN, values);\r\nreturn -ENXIO;\r\n}\r\nerror = i2c_smbus_write_byte(client, ETP_SMBUS_ENABLE_TP);\r\nif (error) {\r\ndev_err(&client->dev, "failed to enable touchpad: %d\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int elan_smbus_set_mode(struct i2c_client *client, u8 mode)\r\n{\r\nu8 cmd[4] = { 0x00, 0x07, 0x00, mode };\r\nreturn i2c_smbus_write_block_data(client, ETP_SMBUS_IAP_CMD,\r\nsizeof(cmd), cmd);\r\n}\r\nstatic int elan_smbus_sleep_control(struct i2c_client *client, bool sleep)\r\n{\r\nif (sleep)\r\nreturn i2c_smbus_write_byte(client, ETP_SMBUS_SLEEP_CMD);\r\nelse\r\nreturn 0;\r\n}\r\nstatic int elan_smbus_power_control(struct i2c_client *client, bool enable)\r\n{\r\nreturn 0;\r\n}\r\nstatic int elan_smbus_calibrate(struct i2c_client *client)\r\n{\r\nu8 cmd[4] = { 0x00, 0x08, 0x00, 0x01 };\r\nreturn i2c_smbus_write_block_data(client, ETP_SMBUS_IAP_CMD,\r\nsizeof(cmd), cmd);\r\n}\r\nstatic int elan_smbus_calibrate_result(struct i2c_client *client, u8 *val)\r\n{\r\nint error;\r\nerror = i2c_smbus_read_block_data(client,\r\nETP_SMBUS_CALIBRATE_QUERY, val);\r\nif (error < 0)\r\nreturn error;\r\nreturn 0;\r\n}\r\nstatic int elan_smbus_get_baseline_data(struct i2c_client *client,\r\nbool max_baseline, u8 *value)\r\n{\r\nint error;\r\nu8 val[3];\r\nerror = i2c_smbus_read_block_data(client,\r\nmax_baseline ?\r\nETP_SMBUS_MAX_BASELINE_CMD :\r\nETP_SMBUS_MIN_BASELINE_CMD,\r\nval);\r\nif (error < 0)\r\nreturn error;\r\n*value = be16_to_cpup((__be16 *)val);\r\nreturn 0;\r\n}\r\nstatic int elan_smbus_get_version(struct i2c_client *client,\r\nbool iap, u8 *version)\r\n{\r\nint error;\r\nu8 val[3];\r\nerror = i2c_smbus_read_block_data(client,\r\niap ? ETP_SMBUS_IAP_VERSION_CMD :\r\nETP_SMBUS_FW_VERSION_CMD,\r\nval);\r\nif (error < 0) {\r\ndev_err(&client->dev, "failed to get %s version: %d\n",\r\niap ? "IAP" : "FW", error);\r\nreturn error;\r\n}\r\n*version = val[2];\r\nreturn 0;\r\n}\r\nstatic int elan_smbus_get_sm_version(struct i2c_client *client,\r\nu8 *ic_type, u8 *version)\r\n{\r\nint error;\r\nu8 val[3];\r\nerror = i2c_smbus_read_block_data(client,\r\nETP_SMBUS_SM_VERSION_CMD, val);\r\nif (error < 0) {\r\ndev_err(&client->dev, "failed to get SM version: %d\n", error);\r\nreturn error;\r\n}\r\n*version = val[0];\r\n*ic_type = val[1];\r\nreturn 0;\r\n}\r\nstatic int elan_smbus_get_product_id(struct i2c_client *client, u16 *id)\r\n{\r\nint error;\r\nu8 val[3];\r\nerror = i2c_smbus_read_block_data(client,\r\nETP_SMBUS_UNIQUEID_CMD, val);\r\nif (error < 0) {\r\ndev_err(&client->dev, "failed to get product ID: %d\n", error);\r\nreturn error;\r\n}\r\n*id = be16_to_cpup((__be16 *)val);\r\nreturn 0;\r\n}\r\nstatic int elan_smbus_get_checksum(struct i2c_client *client,\r\nbool iap, u16 *csum)\r\n{\r\nint error;\r\nu8 val[3];\r\nerror = i2c_smbus_read_block_data(client,\r\niap ? ETP_SMBUS_FW_CHECKSUM_CMD :\r\nETP_SMBUS_IAP_CHECKSUM_CMD,\r\nval);\r\nif (error < 0) {\r\ndev_err(&client->dev, "failed to get %s checksum: %d\n",\r\niap ? "IAP" : "FW", error);\r\nreturn error;\r\n}\r\n*csum = be16_to_cpup((__be16 *)val);\r\nreturn 0;\r\n}\r\nstatic int elan_smbus_get_max(struct i2c_client *client,\r\nunsigned int *max_x, unsigned int *max_y)\r\n{\r\nint ret;\r\nint error;\r\nu8 val[3];\r\nret = i2c_smbus_read_block_data(client, ETP_SMBUS_RANGE_CMD, val);\r\nif (ret != 3) {\r\nerror = ret < 0 ? ret : -EIO;\r\ndev_err(&client->dev, "failed to get dimensions: %d\n", error);\r\nreturn error;\r\n}\r\n*max_x = (0x0f & val[0]) << 8 | val[1];\r\n*max_y = (0xf0 & val[0]) << 4 | val[2];\r\nreturn 0;\r\n}\r\nstatic int elan_smbus_get_resolution(struct i2c_client *client,\r\nu8 *hw_res_x, u8 *hw_res_y)\r\n{\r\nint ret;\r\nint error;\r\nu8 val[3];\r\nret = i2c_smbus_read_block_data(client, ETP_SMBUS_RESOLUTION_CMD, val);\r\nif (ret != 3) {\r\nerror = ret < 0 ? ret : -EIO;\r\ndev_err(&client->dev, "failed to get resolution: %d\n", error);\r\nreturn error;\r\n}\r\n*hw_res_x = val[1] & 0x0F;\r\n*hw_res_y = (val[1] & 0xF0) >> 4;\r\nreturn 0;\r\n}\r\nstatic int elan_smbus_get_num_traces(struct i2c_client *client,\r\nunsigned int *x_traces,\r\nunsigned int *y_traces)\r\n{\r\nint ret;\r\nint error;\r\nu8 val[3];\r\nret = i2c_smbus_read_block_data(client, ETP_SMBUS_XY_TRACENUM_CMD, val);\r\nif (ret != 3) {\r\nerror = ret < 0 ? ret : -EIO;\r\ndev_err(&client->dev, "failed to get trace info: %d\n", error);\r\nreturn error;\r\n}\r\n*x_traces = val[1];\r\n*y_traces = val[2];\r\nreturn 0;\r\n}\r\nstatic int elan_smbus_get_pressure_adjustment(struct i2c_client *client,\r\nint *adjustment)\r\n{\r\n*adjustment = ETP_PRESSURE_OFFSET;\r\nreturn 0;\r\n}\r\nstatic int elan_smbus_iap_get_mode(struct i2c_client *client,\r\nenum tp_mode *mode)\r\n{\r\nint error;\r\nu16 constant;\r\nu8 val[3];\r\nerror = i2c_smbus_read_block_data(client, ETP_SMBUS_IAP_CTRL_CMD, val);\r\nif (error < 0) {\r\ndev_err(&client->dev, "failed to read iap ctrol register: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nconstant = be16_to_cpup((__be16 *)val);\r\ndev_dbg(&client->dev, "iap control reg: 0x%04x.\n", constant);\r\n*mode = (constant & ETP_SMBUS_IAP_MODE_ON) ? IAP_MODE : MAIN_MODE;\r\nreturn 0;\r\n}\r\nstatic int elan_smbus_iap_reset(struct i2c_client *client)\r\n{\r\nint error;\r\nerror = i2c_smbus_write_byte(client, ETP_SMBUS_IAP_RESET_CMD);\r\nif (error) {\r\ndev_err(&client->dev, "cannot reset IC: %d\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int elan_smbus_set_flash_key(struct i2c_client *client)\r\n{\r\nint error;\r\nu8 cmd[4] = { 0x00, 0x0B, 0x00, 0x5A };\r\nerror = i2c_smbus_write_block_data(client, ETP_SMBUS_IAP_CMD,\r\nsizeof(cmd), cmd);\r\nif (error) {\r\ndev_err(&client->dev, "cannot set flash key: %d\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int elan_smbus_prepare_fw_update(struct i2c_client *client)\r\n{\r\nstruct device *dev = &client->dev;\r\nint len;\r\nint error;\r\nenum tp_mode mode;\r\nu8 val[3];\r\nu8 cmd[4] = {0x0F, 0x78, 0x00, 0x06};\r\nu16 password;\r\nerror = elan_smbus_iap_get_mode(client, &mode);\r\nif (error)\r\nreturn error;\r\nif (mode == MAIN_MODE) {\r\nerror = elan_smbus_set_flash_key(client);\r\nif (error)\r\nreturn error;\r\nif (i2c_smbus_write_byte(client,\r\nETP_SMBUS_IAP_PASSWORD_WRITE) < 0) {\r\ndev_err(dev, "cannot write iap password\n");\r\nreturn -EIO;\r\n}\r\nerror = i2c_smbus_write_block_data(client, ETP_SMBUS_IAP_CMD,\r\nsizeof(cmd), cmd);\r\nif (error) {\r\ndev_err(dev, "failed to write iap password: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nlen = i2c_smbus_read_block_data(client,\r\nETP_SMBUS_IAP_PASSWORD_READ,\r\nval);\r\nif (len < sizeof(u16)) {\r\nerror = len < 0 ? len : -EIO;\r\ndev_err(dev, "failed to read iap password: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\npassword = be16_to_cpup((__be16 *)val);\r\nif (password != ETP_SMBUS_IAP_PASSWORD) {\r\ndev_err(dev, "wrong iap password = 0x%X\n", password);\r\nreturn -EIO;\r\n}\r\nmsleep(30);\r\n}\r\nerror = elan_smbus_set_flash_key(client);\r\nif (error)\r\nreturn error;\r\nerror = elan_smbus_iap_reset(client);\r\nif (error)\r\nreturn error;\r\nreturn 0;\r\n}\r\nstatic int elan_smbus_write_fw_block(struct i2c_client *client,\r\nconst u8 *page, u16 checksum, int idx)\r\n{\r\nstruct device *dev = &client->dev;\r\nint error;\r\nu16 result;\r\nu8 val[3];\r\nerror = i2c_smbus_write_block_data(client,\r\nETP_SMBUS_WRITE_FW_BLOCK,\r\nETP_FW_PAGE_SIZE / 2,\r\npage);\r\nif (error) {\r\ndev_err(dev, "Failed to write page %d (part %d): %d\n",\r\nidx, 1, error);\r\nreturn error;\r\n}\r\nerror = i2c_smbus_write_block_data(client,\r\nETP_SMBUS_WRITE_FW_BLOCK,\r\nETP_FW_PAGE_SIZE / 2,\r\npage + ETP_FW_PAGE_SIZE / 2);\r\nif (error) {\r\ndev_err(dev, "Failed to write page %d (part %d): %d\n",\r\nidx, 2, error);\r\nreturn error;\r\n}\r\nusleep_range(8000, 10000);\r\nerror = i2c_smbus_read_block_data(client,\r\nETP_SMBUS_IAP_CTRL_CMD, val);\r\nif (error < 0) {\r\ndev_err(dev, "Failed to read IAP write result: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nresult = be16_to_cpup((__be16 *)val);\r\nif (result & (ETP_FW_IAP_PAGE_ERR | ETP_FW_IAP_INTF_ERR)) {\r\ndev_err(dev, "IAP reports failed write: %04hx\n",\r\nresult);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int elan_smbus_get_report(struct i2c_client *client, u8 *report)\r\n{\r\nint len;\r\nlen = i2c_smbus_read_block_data(client,\r\nETP_SMBUS_PACKET_QUERY,\r\n&report[ETP_SMBUS_REPORT_OFFSET]);\r\nif (len < 0) {\r\ndev_err(&client->dev, "failed to read report data: %d\n", len);\r\nreturn len;\r\n}\r\nif (len != ETP_SMBUS_REPORT_LEN) {\r\ndev_err(&client->dev,\r\n"wrong report length (%d vs %d expected)\n",\r\nlen, ETP_SMBUS_REPORT_LEN);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int elan_smbus_finish_fw_update(struct i2c_client *client,\r\nstruct completion *fw_completion)\r\n{\r\nreturn 0;\r\n}
