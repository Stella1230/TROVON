static int atl1c_get_link_ksettings(struct net_device *netdev,\r\nstruct ethtool_link_ksettings *cmd)\r\n{\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\nstruct atl1c_hw *hw = &adapter->hw;\r\nu32 supported, advertising;\r\nsupported = (SUPPORTED_10baseT_Half |\r\nSUPPORTED_10baseT_Full |\r\nSUPPORTED_100baseT_Half |\r\nSUPPORTED_100baseT_Full |\r\nSUPPORTED_Autoneg |\r\nSUPPORTED_TP);\r\nif (hw->link_cap_flags & ATL1C_LINK_CAP_1000M)\r\nsupported |= SUPPORTED_1000baseT_Full;\r\nadvertising = ADVERTISED_TP;\r\nadvertising |= hw->autoneg_advertised;\r\ncmd->base.port = PORT_TP;\r\ncmd->base.phy_address = 0;\r\nif (adapter->link_speed != SPEED_0) {\r\ncmd->base.speed = adapter->link_speed;\r\nif (adapter->link_duplex == FULL_DUPLEX)\r\ncmd->base.duplex = DUPLEX_FULL;\r\nelse\r\ncmd->base.duplex = DUPLEX_HALF;\r\n} else {\r\ncmd->base.speed = SPEED_UNKNOWN;\r\ncmd->base.duplex = DUPLEX_UNKNOWN;\r\n}\r\ncmd->base.autoneg = AUTONEG_ENABLE;\r\nethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\r\nsupported);\r\nethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\r\nadvertising);\r\nreturn 0;\r\n}\r\nstatic int atl1c_set_link_ksettings(struct net_device *netdev,\r\nconst struct ethtool_link_ksettings *cmd)\r\n{\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\nstruct atl1c_hw *hw = &adapter->hw;\r\nu16 autoneg_advertised;\r\nwhile (test_and_set_bit(__AT_RESETTING, &adapter->flags))\r\nmsleep(1);\r\nif (cmd->base.autoneg == AUTONEG_ENABLE) {\r\nautoneg_advertised = ADVERTISED_Autoneg;\r\n} else {\r\nu32 speed = cmd->base.speed;\r\nif (speed == SPEED_1000) {\r\nif (cmd->base.duplex != DUPLEX_FULL) {\r\nif (netif_msg_link(adapter))\r\ndev_warn(&adapter->pdev->dev,\r\n"1000M half is invalid\n");\r\nclear_bit(__AT_RESETTING, &adapter->flags);\r\nreturn -EINVAL;\r\n}\r\nautoneg_advertised = ADVERTISED_1000baseT_Full;\r\n} else if (speed == SPEED_100) {\r\nif (cmd->base.duplex == DUPLEX_FULL)\r\nautoneg_advertised = ADVERTISED_100baseT_Full;\r\nelse\r\nautoneg_advertised = ADVERTISED_100baseT_Half;\r\n} else {\r\nif (cmd->base.duplex == DUPLEX_FULL)\r\nautoneg_advertised = ADVERTISED_10baseT_Full;\r\nelse\r\nautoneg_advertised = ADVERTISED_10baseT_Half;\r\n}\r\n}\r\nif (hw->autoneg_advertised != autoneg_advertised) {\r\nhw->autoneg_advertised = autoneg_advertised;\r\nif (atl1c_restart_autoneg(hw) != 0) {\r\nif (netif_msg_link(adapter))\r\ndev_warn(&adapter->pdev->dev,\r\n"ethtool speed/duplex setting failed\n");\r\nclear_bit(__AT_RESETTING, &adapter->flags);\r\nreturn -EINVAL;\r\n}\r\n}\r\nclear_bit(__AT_RESETTING, &adapter->flags);\r\nreturn 0;\r\n}\r\nstatic u32 atl1c_get_msglevel(struct net_device *netdev)\r\n{\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\nreturn adapter->msg_enable;\r\n}\r\nstatic void atl1c_set_msglevel(struct net_device *netdev, u32 data)\r\n{\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\nadapter->msg_enable = data;\r\n}\r\nstatic int atl1c_get_regs_len(struct net_device *netdev)\r\n{\r\nreturn AT_REGS_LEN;\r\n}\r\nstatic void atl1c_get_regs(struct net_device *netdev,\r\nstruct ethtool_regs *regs, void *p)\r\n{\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\nstruct atl1c_hw *hw = &adapter->hw;\r\nu32 *regs_buff = p;\r\nu16 phy_data;\r\nmemset(p, 0, AT_REGS_LEN);\r\nregs->version = 1;\r\nAT_READ_REG(hw, REG_PM_CTRL, p++);\r\nAT_READ_REG(hw, REG_MAC_HALF_DUPLX_CTRL, p++);\r\nAT_READ_REG(hw, REG_TWSI_CTRL, p++);\r\nAT_READ_REG(hw, REG_PCIE_DEV_MISC_CTRL, p++);\r\nAT_READ_REG(hw, REG_MASTER_CTRL, p++);\r\nAT_READ_REG(hw, REG_MANUAL_TIMER_INIT, p++);\r\nAT_READ_REG(hw, REG_IRQ_MODRT_TIMER_INIT, p++);\r\nAT_READ_REG(hw, REG_GPHY_CTRL, p++);\r\nAT_READ_REG(hw, REG_LINK_CTRL, p++);\r\nAT_READ_REG(hw, REG_IDLE_STATUS, p++);\r\nAT_READ_REG(hw, REG_MDIO_CTRL, p++);\r\nAT_READ_REG(hw, REG_SERDES, p++);\r\nAT_READ_REG(hw, REG_MAC_CTRL, p++);\r\nAT_READ_REG(hw, REG_MAC_IPG_IFG, p++);\r\nAT_READ_REG(hw, REG_MAC_STA_ADDR, p++);\r\nAT_READ_REG(hw, REG_MAC_STA_ADDR+4, p++);\r\nAT_READ_REG(hw, REG_RX_HASH_TABLE, p++);\r\nAT_READ_REG(hw, REG_RX_HASH_TABLE+4, p++);\r\nAT_READ_REG(hw, REG_RXQ_CTRL, p++);\r\nAT_READ_REG(hw, REG_TXQ_CTRL, p++);\r\nAT_READ_REG(hw, REG_MTU, p++);\r\nAT_READ_REG(hw, REG_WOL_CTRL, p++);\r\natl1c_read_phy_reg(hw, MII_BMCR, &phy_data);\r\nregs_buff[AT_REGS_LEN/sizeof(u32) - 2] = (u32) phy_data;\r\natl1c_read_phy_reg(hw, MII_BMSR, &phy_data);\r\nregs_buff[AT_REGS_LEN/sizeof(u32) - 1] = (u32) phy_data;\r\n}\r\nstatic int atl1c_get_eeprom_len(struct net_device *netdev)\r\n{\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\nif (atl1c_check_eeprom_exist(&adapter->hw))\r\nreturn AT_EEPROM_LEN;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int atl1c_get_eeprom(struct net_device *netdev,\r\nstruct ethtool_eeprom *eeprom, u8 *bytes)\r\n{\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\nstruct atl1c_hw *hw = &adapter->hw;\r\nu32 *eeprom_buff;\r\nint first_dword, last_dword;\r\nint ret_val = 0;\r\nint i;\r\nif (eeprom->len == 0)\r\nreturn -EINVAL;\r\nif (!atl1c_check_eeprom_exist(hw))\r\nreturn -EINVAL;\r\neeprom->magic = adapter->pdev->vendor |\r\n(adapter->pdev->device << 16);\r\nfirst_dword = eeprom->offset >> 2;\r\nlast_dword = (eeprom->offset + eeprom->len - 1) >> 2;\r\neeprom_buff = kmalloc(sizeof(u32) *\r\n(last_dword - first_dword + 1), GFP_KERNEL);\r\nif (eeprom_buff == NULL)\r\nreturn -ENOMEM;\r\nfor (i = first_dword; i < last_dword; i++) {\r\nif (!atl1c_read_eeprom(hw, i * 4, &(eeprom_buff[i-first_dword]))) {\r\nkfree(eeprom_buff);\r\nreturn -EIO;\r\n}\r\n}\r\nmemcpy(bytes, (u8 *)eeprom_buff + (eeprom->offset & 3),\r\neeprom->len);\r\nkfree(eeprom_buff);\r\nreturn ret_val;\r\nreturn 0;\r\n}\r\nstatic void atl1c_get_drvinfo(struct net_device *netdev,\r\nstruct ethtool_drvinfo *drvinfo)\r\n{\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\nstrlcpy(drvinfo->driver, atl1c_driver_name, sizeof(drvinfo->driver));\r\nstrlcpy(drvinfo->version, atl1c_driver_version,\r\nsizeof(drvinfo->version));\r\nstrlcpy(drvinfo->bus_info, pci_name(adapter->pdev),\r\nsizeof(drvinfo->bus_info));\r\n}\r\nstatic void atl1c_get_wol(struct net_device *netdev,\r\nstruct ethtool_wolinfo *wol)\r\n{\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\nwol->supported = WAKE_MAGIC | WAKE_PHY;\r\nwol->wolopts = 0;\r\nif (adapter->wol & AT_WUFC_EX)\r\nwol->wolopts |= WAKE_UCAST;\r\nif (adapter->wol & AT_WUFC_MC)\r\nwol->wolopts |= WAKE_MCAST;\r\nif (adapter->wol & AT_WUFC_BC)\r\nwol->wolopts |= WAKE_BCAST;\r\nif (adapter->wol & AT_WUFC_MAG)\r\nwol->wolopts |= WAKE_MAGIC;\r\nif (adapter->wol & AT_WUFC_LNKC)\r\nwol->wolopts |= WAKE_PHY;\r\n}\r\nstatic int atl1c_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\nif (wol->wolopts & (WAKE_ARP | WAKE_MAGICSECURE |\r\nWAKE_UCAST | WAKE_BCAST | WAKE_MCAST))\r\nreturn -EOPNOTSUPP;\r\nadapter->wol = 0;\r\nif (wol->wolopts & WAKE_MAGIC)\r\nadapter->wol |= AT_WUFC_MAG;\r\nif (wol->wolopts & WAKE_PHY)\r\nadapter->wol |= AT_WUFC_LNKC;\r\ndevice_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);\r\nreturn 0;\r\n}\r\nstatic int atl1c_nway_reset(struct net_device *netdev)\r\n{\r\nstruct atl1c_adapter *adapter = netdev_priv(netdev);\r\nif (netif_running(netdev))\r\natl1c_reinit_locked(adapter);\r\nreturn 0;\r\n}\r\nvoid atl1c_set_ethtool_ops(struct net_device *netdev)\r\n{\r\nnetdev->ethtool_ops = &atl1c_ethtool_ops;\r\n}
