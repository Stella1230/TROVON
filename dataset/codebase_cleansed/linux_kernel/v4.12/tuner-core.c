static void tuner_detach(struct dvb_frontend *fe)\r\n{\r\nif (fe->ops.tuner_ops.release) {\r\nfe->ops.tuner_ops.release(fe);\r\nsymbol_put_addr(fe->ops.tuner_ops.release);\r\n}\r\nif (fe->ops.analog_ops.release) {\r\nfe->ops.analog_ops.release(fe);\r\nsymbol_put_addr(fe->ops.analog_ops.release);\r\n}\r\n}\r\nstatic void tuner_detach(struct dvb_frontend *fe)\r\n{\r\nif (fe->ops.tuner_ops.release)\r\nfe->ops.tuner_ops.release(fe);\r\nif (fe->ops.analog_ops.release)\r\nfe->ops.analog_ops.release(fe);\r\n}\r\nstatic inline struct tuner *to_tuner(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct tuner, sd);\r\n}\r\nstatic void fe_set_params(struct dvb_frontend *fe,\r\nstruct analog_parameters *params)\r\n{\r\nstruct dvb_tuner_ops *fe_tuner_ops = &fe->ops.tuner_ops;\r\nstruct tuner *t = fe->analog_demod_priv;\r\nif (NULL == fe_tuner_ops->set_analog_params) {\r\npr_warn("Tuner frontend module has no way to set freq\n");\r\nreturn;\r\n}\r\nfe_tuner_ops->set_analog_params(fe, params);\r\n}\r\nstatic void fe_standby(struct dvb_frontend *fe)\r\n{\r\nstruct dvb_tuner_ops *fe_tuner_ops = &fe->ops.tuner_ops;\r\nif (fe_tuner_ops->sleep)\r\nfe_tuner_ops->sleep(fe);\r\n}\r\nstatic int fe_set_config(struct dvb_frontend *fe, void *priv_cfg)\r\n{\r\nstruct dvb_tuner_ops *fe_tuner_ops = &fe->ops.tuner_ops;\r\nstruct tuner *t = fe->analog_demod_priv;\r\nif (fe_tuner_ops->set_config)\r\nreturn fe_tuner_ops->set_config(fe, priv_cfg);\r\npr_warn("Tuner frontend module has no way to set config\n");\r\nreturn 0;\r\n}\r\nstatic void set_type(struct i2c_client *c, unsigned int type,\r\nunsigned int new_mode_mask, void *new_config,\r\nint (*tuner_callback) (void *dev, int component, int cmd, int arg))\r\n{\r\nstruct tuner *t = to_tuner(i2c_get_clientdata(c));\r\nstruct dvb_tuner_ops *fe_tuner_ops = &t->fe.ops.tuner_ops;\r\nstruct analog_demod_ops *analog_ops = &t->fe.ops.analog_ops;\r\nunsigned char buffer[4];\r\nint tune_now = 1;\r\nif (type == UNSET || type == TUNER_ABSENT) {\r\ndprintk("tuner 0x%02x: Tuner type absent\n", c->addr);\r\nreturn;\r\n}\r\nt->type = type;\r\nt->config = new_config;\r\nif (tuner_callback != NULL) {\r\ndprintk("defining GPIO callback\n");\r\nt->fe.callback = tuner_callback;\r\n}\r\ntuner_detach(&t->fe);\r\nt->fe.analog_demod_priv = NULL;\r\nswitch (t->type) {\r\ncase TUNER_MT2032:\r\nif (!dvb_attach(microtune_attach,\r\n&t->fe, t->i2c->adapter, t->i2c->addr))\r\ngoto attach_failed;\r\nbreak;\r\ncase TUNER_PHILIPS_TDA8290:\r\n{\r\nif (!dvb_attach(tda829x_attach, &t->fe, t->i2c->adapter,\r\nt->i2c->addr, t->config))\r\ngoto attach_failed;\r\nbreak;\r\n}\r\ncase TUNER_TEA5767:\r\nif (!dvb_attach(tea5767_attach, &t->fe,\r\nt->i2c->adapter, t->i2c->addr))\r\ngoto attach_failed;\r\nt->mode_mask = T_RADIO;\r\nbreak;\r\ncase TUNER_TEA5761:\r\nif (!dvb_attach(tea5761_attach, &t->fe,\r\nt->i2c->adapter, t->i2c->addr))\r\ngoto attach_failed;\r\nt->mode_mask = T_RADIO;\r\nbreak;\r\ncase TUNER_PHILIPS_FMD1216ME_MK3:\r\ncase TUNER_PHILIPS_FMD1216MEX_MK3:\r\nbuffer[0] = 0x0b;\r\nbuffer[1] = 0xdc;\r\nbuffer[2] = 0x9c;\r\nbuffer[3] = 0x60;\r\ni2c_master_send(c, buffer, 4);\r\nmdelay(1);\r\nbuffer[2] = 0x86;\r\nbuffer[3] = 0x54;\r\ni2c_master_send(c, buffer, 4);\r\nif (!dvb_attach(simple_tuner_attach, &t->fe,\r\nt->i2c->adapter, t->i2c->addr, t->type))\r\ngoto attach_failed;\r\nbreak;\r\ncase TUNER_PHILIPS_TD1316:\r\nbuffer[0] = 0x0b;\r\nbuffer[1] = 0xdc;\r\nbuffer[2] = 0x86;\r\nbuffer[3] = 0xa4;\r\ni2c_master_send(c, buffer, 4);\r\nif (!dvb_attach(simple_tuner_attach, &t->fe,\r\nt->i2c->adapter, t->i2c->addr, t->type))\r\ngoto attach_failed;\r\nbreak;\r\ncase TUNER_XC2028:\r\n{\r\nstruct xc2028_config cfg = {\r\n.i2c_adap = t->i2c->adapter,\r\n.i2c_addr = t->i2c->addr,\r\n};\r\nif (!dvb_attach(xc2028_attach, &t->fe, &cfg))\r\ngoto attach_failed;\r\ntune_now = 0;\r\nbreak;\r\n}\r\ncase TUNER_TDA9887:\r\nif (!dvb_attach(tda9887_attach,\r\n&t->fe, t->i2c->adapter, t->i2c->addr))\r\ngoto attach_failed;\r\nbreak;\r\ncase TUNER_XC5000:\r\n{\r\nstruct xc5000_config xc5000_cfg = {\r\n.i2c_address = t->i2c->addr,\r\n.if_khz = 0,\r\n};\r\nif (!dvb_attach(xc5000_attach,\r\n&t->fe, t->i2c->adapter, &xc5000_cfg))\r\ngoto attach_failed;\r\ntune_now = 0;\r\nbreak;\r\n}\r\ncase TUNER_XC5000C:\r\n{\r\nstruct xc5000_config xc5000c_cfg = {\r\n.i2c_address = t->i2c->addr,\r\n.if_khz = 0,\r\n.chip_id = XC5000C,\r\n};\r\nif (!dvb_attach(xc5000_attach,\r\n&t->fe, t->i2c->adapter, &xc5000c_cfg))\r\ngoto attach_failed;\r\ntune_now = 0;\r\nbreak;\r\n}\r\ncase TUNER_NXP_TDA18271:\r\n{\r\nstruct tda18271_config cfg = {\r\n.small_i2c = TDA18271_03_BYTE_CHUNK_INIT,\r\n};\r\nif (!dvb_attach(tda18271_attach, &t->fe, t->i2c->addr,\r\nt->i2c->adapter, &cfg))\r\ngoto attach_failed;\r\ntune_now = 0;\r\nbreak;\r\n}\r\ncase TUNER_XC4000:\r\n{\r\nstruct xc4000_config xc4000_cfg = {\r\n.i2c_address = t->i2c->addr,\r\n.default_pm = 0,\r\n.dvb_amplitude = 0,\r\n.set_smoothedcvbs = 0,\r\n.if_khz = 0\r\n};\r\nif (!dvb_attach(xc4000_attach,\r\n&t->fe, t->i2c->adapter, &xc4000_cfg))\r\ngoto attach_failed;\r\ntune_now = 0;\r\nbreak;\r\n}\r\ndefault:\r\nif (!dvb_attach(simple_tuner_attach, &t->fe,\r\nt->i2c->adapter, t->i2c->addr, t->type))\r\ngoto attach_failed;\r\nbreak;\r\n}\r\nif ((NULL == analog_ops->set_params) &&\r\n(fe_tuner_ops->set_analog_params)) {\r\nt->name = fe_tuner_ops->info.name;\r\nt->fe.analog_demod_priv = t;\r\nmemcpy(analog_ops, &tuner_analog_ops,\r\nsizeof(struct analog_demod_ops));\r\nif (fe_tuner_ops->get_rf_strength)\r\nanalog_ops->has_signal = fe_tuner_ops->get_rf_strength;\r\nif (fe_tuner_ops->get_afc)\r\nanalog_ops->get_afc = fe_tuner_ops->get_afc;\r\n} else {\r\nt->name = analog_ops->info.name;\r\n}\r\n#ifdef CONFIG_MEDIA_CONTROLLER\r\nt->sd.entity.name = t->name;\r\n#endif\r\ndprintk("type set to %s\n", t->name);\r\nt->mode_mask = new_mode_mask;\r\nif (tune_now) {\r\nif (V4L2_TUNER_RADIO == t->mode)\r\nset_radio_freq(c, t->radio_freq);\r\nelse\r\nset_tv_freq(c, t->tv_freq);\r\n}\r\ndprintk("%s %s I2C addr 0x%02x with type %d used for 0x%02x\n",\r\nc->adapter->name, c->dev.driver->name, c->addr << 1, type,\r\nt->mode_mask);\r\nreturn;\r\nattach_failed:\r\ndprintk("Tuner attach for type = %d failed.\n", t->type);\r\nt->type = TUNER_ABSENT;\r\nreturn;\r\n}\r\nstatic int tuner_s_type_addr(struct v4l2_subdev *sd,\r\nstruct tuner_setup *tun_setup)\r\n{\r\nstruct tuner *t = to_tuner(sd);\r\nstruct i2c_client *c = v4l2_get_subdevdata(sd);\r\ndprintk("Calling set_type_addr for type=%d, addr=0x%02x, mode=0x%02x, config=%p\n",\r\ntun_setup->type,\r\ntun_setup->addr,\r\ntun_setup->mode_mask,\r\ntun_setup->config);\r\nif ((t->type == UNSET && ((tun_setup->addr == ADDR_UNSET) &&\r\n(t->mode_mask & tun_setup->mode_mask))) ||\r\n(tun_setup->addr == c->addr)) {\r\nset_type(c, tun_setup->type, tun_setup->mode_mask,\r\ntun_setup->config, tun_setup->tuner_callback);\r\n} else\r\ndprintk("set addr discarded for type %i, mask %x. Asked to change tuner at addr 0x%02x, with mask %x\n",\r\nt->type, t->mode_mask,\r\ntun_setup->addr, tun_setup->mode_mask);\r\nreturn 0;\r\n}\r\nstatic int tuner_s_config(struct v4l2_subdev *sd,\r\nconst struct v4l2_priv_tun_config *cfg)\r\n{\r\nstruct tuner *t = to_tuner(sd);\r\nstruct analog_demod_ops *analog_ops = &t->fe.ops.analog_ops;\r\nif (t->type != cfg->tuner)\r\nreturn 0;\r\nif (analog_ops->set_config) {\r\nanalog_ops->set_config(&t->fe, cfg->priv);\r\nreturn 0;\r\n}\r\ndprintk("Tuner frontend module has no way to set config\n");\r\nreturn 0;\r\n}\r\nstatic void tuner_lookup(struct i2c_adapter *adap,\r\nstruct tuner **radio, struct tuner **tv)\r\n{\r\nstruct tuner *pos;\r\n*radio = NULL;\r\n*tv = NULL;\r\nlist_for_each_entry(pos, &tuner_list, list) {\r\nint mode_mask;\r\nif (pos->i2c->adapter != adap ||\r\nstrcmp(pos->i2c->dev.driver->name, "tuner"))\r\ncontinue;\r\nmode_mask = pos->mode_mask;\r\nif (*radio == NULL && mode_mask == T_RADIO)\r\n*radio = pos;\r\nelse if (*tv == NULL && pos->type != TUNER_TDA9887 &&\r\n(pos->mode_mask & T_ANALOG_TV))\r\n*tv = pos;\r\n}\r\n}\r\nstatic int tuner_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct tuner *t;\r\nstruct tuner *radio;\r\nstruct tuner *tv;\r\n#ifdef CONFIG_MEDIA_CONTROLLER\r\nint ret;\r\n#endif\r\nt = kzalloc(sizeof(struct tuner), GFP_KERNEL);\r\nif (NULL == t)\r\nreturn -ENOMEM;\r\nv4l2_i2c_subdev_init(&t->sd, client, &tuner_ops);\r\nt->i2c = client;\r\nt->name = "(tuner unset)";\r\nt->type = UNSET;\r\nt->audmode = V4L2_TUNER_MODE_STEREO;\r\nt->standby = true;\r\nt->radio_freq = 87.5 * 16000;\r\nt->tv_freq = 400 * 16;\r\nif (show_i2c) {\r\nunsigned char buffer[16];\r\nint rc;\r\nmemset(buffer, 0, sizeof(buffer));\r\nrc = i2c_master_recv(client, buffer, sizeof(buffer));\r\nif (rc >= 0)\r\npr_info("I2C RECV = %*ph\n", rc, buffer);\r\n}\r\nif (!no_autodetect) {\r\nswitch (client->addr) {\r\ncase 0x10:\r\nif (tuner_symbol_probe(tea5761_autodetection,\r\nt->i2c->adapter,\r\nt->i2c->addr) >= 0) {\r\nt->type = TUNER_TEA5761;\r\nt->mode_mask = T_RADIO;\r\ntuner_lookup(t->i2c->adapter, &radio, &tv);\r\nif (tv)\r\ntv->mode_mask &= ~T_RADIO;\r\ngoto register_client;\r\n}\r\nkfree(t);\r\nreturn -ENODEV;\r\ncase 0x42:\r\ncase 0x43:\r\ncase 0x4a:\r\ncase 0x4b:\r\nif (tuner_symbol_probe(tda829x_probe, t->i2c->adapter,\r\nt->i2c->addr) >= 0) {\r\ndprintk("tda829x detected\n");\r\n} else {\r\nt->type = TUNER_TDA9887;\r\nt->mode_mask = T_RADIO | T_ANALOG_TV;\r\ngoto register_client;\r\n}\r\nbreak;\r\ncase 0x60:\r\nif (tuner_symbol_probe(tea5767_autodetection,\r\nt->i2c->adapter, t->i2c->addr)\r\n>= 0) {\r\nt->type = TUNER_TEA5767;\r\nt->mode_mask = T_RADIO;\r\ntuner_lookup(t->i2c->adapter, &radio, &tv);\r\nif (tv)\r\ntv->mode_mask &= ~T_RADIO;\r\ngoto register_client;\r\n}\r\nbreak;\r\n}\r\n}\r\ntuner_lookup(t->i2c->adapter, &radio, &tv);\r\nif (tv == NULL) {\r\nt->mode_mask = T_ANALOG_TV;\r\nif (radio == NULL)\r\nt->mode_mask |= T_RADIO;\r\ndprintk("Setting mode_mask to 0x%02x\n", t->mode_mask);\r\n}\r\nregister_client:\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\nt->sd.entity.name = t->name;\r\nif (t->type == TUNER_TDA9887) {\r\nt->pad[IF_VID_DEC_PAD_IF_INPUT].flags = MEDIA_PAD_FL_SINK;\r\nt->pad[IF_VID_DEC_PAD_OUT].flags = MEDIA_PAD_FL_SOURCE;\r\nret = media_entity_pads_init(&t->sd.entity,\r\nIF_VID_DEC_PAD_NUM_PADS,\r\n&t->pad[0]);\r\nt->sd.entity.function = MEDIA_ENT_F_IF_VID_DECODER;\r\n} else {\r\nt->pad[TUNER_PAD_RF_INPUT].flags = MEDIA_PAD_FL_SINK;\r\nt->pad[TUNER_PAD_OUTPUT].flags = MEDIA_PAD_FL_SOURCE;\r\nt->pad[TUNER_PAD_AUD_OUT].flags = MEDIA_PAD_FL_SOURCE;\r\nret = media_entity_pads_init(&t->sd.entity, TUNER_NUM_PADS,\r\n&t->pad[0]);\r\nt->sd.entity.function = MEDIA_ENT_F_TUNER;\r\n}\r\nif (ret < 0) {\r\npr_err("failed to initialize media entity!\n");\r\nkfree(t);\r\nreturn ret;\r\n}\r\n#endif\r\nif (t->mode_mask & T_ANALOG_TV)\r\nt->mode = V4L2_TUNER_ANALOG_TV;\r\nelse\r\nt->mode = V4L2_TUNER_RADIO;\r\nset_type(client, t->type, t->mode_mask, t->config, t->fe.callback);\r\nlist_add_tail(&t->list, &tuner_list);\r\npr_info("Tuner %d found with type(s)%s%s.\n",\r\nt->type,\r\nt->mode_mask & T_RADIO ? " Radio" : "",\r\nt->mode_mask & T_ANALOG_TV ? " TV" : "");\r\nreturn 0;\r\n}\r\nstatic int tuner_remove(struct i2c_client *client)\r\n{\r\nstruct tuner *t = to_tuner(i2c_get_clientdata(client));\r\nv4l2_device_unregister_subdev(&t->sd);\r\ntuner_detach(&t->fe);\r\nt->fe.analog_demod_priv = NULL;\r\nlist_del(&t->list);\r\nkfree(t);\r\nreturn 0;\r\n}\r\nstatic inline int check_mode(struct tuner *t, enum v4l2_tuner_type mode)\r\n{\r\nint t_mode;\r\nif (mode == V4L2_TUNER_RADIO)\r\nt_mode = T_RADIO;\r\nelse\r\nt_mode = T_ANALOG_TV;\r\nif ((t_mode & t->mode_mask) == 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int set_mode(struct tuner *t, enum v4l2_tuner_type mode)\r\n{\r\nstruct analog_demod_ops *analog_ops = &t->fe.ops.analog_ops;\r\nif (mode != t->mode) {\r\nif (check_mode(t, mode) == -EINVAL) {\r\ndprintk("Tuner doesn't support mode %d. Putting tuner to sleep\n",\r\nmode);\r\nt->standby = true;\r\nif (analog_ops->standby)\r\nanalog_ops->standby(&t->fe);\r\nreturn -EINVAL;\r\n}\r\nt->mode = mode;\r\ndprintk("Changing to mode %d\n", mode);\r\n}\r\nreturn 0;\r\n}\r\nstatic void set_freq(struct tuner *t, unsigned int freq)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&t->sd);\r\nif (t->mode == V4L2_TUNER_RADIO) {\r\nif (!freq)\r\nfreq = t->radio_freq;\r\nset_radio_freq(client, freq);\r\n} else {\r\nif (!freq)\r\nfreq = t->tv_freq;\r\nset_tv_freq(client, freq);\r\n}\r\n}\r\nstatic void set_tv_freq(struct i2c_client *c, unsigned int freq)\r\n{\r\nstruct tuner *t = to_tuner(i2c_get_clientdata(c));\r\nstruct analog_demod_ops *analog_ops = &t->fe.ops.analog_ops;\r\nstruct analog_parameters params = {\r\n.mode = t->mode,\r\n.audmode = t->audmode,\r\n.std = t->std\r\n};\r\nif (t->type == UNSET) {\r\npr_warn("tuner type not set\n");\r\nreturn;\r\n}\r\nif (NULL == analog_ops->set_params) {\r\npr_warn("Tuner has no way to set tv freq\n");\r\nreturn;\r\n}\r\nif (freq < tv_range[0] * 16 || freq > tv_range[1] * 16) {\r\ndprintk("TV freq (%d.%02d) out of range (%d-%d)\n",\r\nfreq / 16, freq % 16 * 100 / 16, tv_range[0],\r\ntv_range[1]);\r\nif (freq < tv_range[0] * 16)\r\nfreq = tv_range[0] * 16;\r\nelse\r\nfreq = tv_range[1] * 16;\r\n}\r\nparams.frequency = freq;\r\ndprintk("tv freq set to %d.%02d\n",\r\nfreq / 16, freq % 16 * 100 / 16);\r\nt->tv_freq = freq;\r\nt->standby = false;\r\nanalog_ops->set_params(&t->fe, &params);\r\n}\r\nstatic v4l2_std_id tuner_fixup_std(struct tuner *t, v4l2_std_id std)\r\n{\r\nif (pal[0] != '-' && (std & V4L2_STD_PAL) == V4L2_STD_PAL) {\r\nswitch (pal[0]) {\r\ncase '6':\r\nreturn V4L2_STD_PAL_60;\r\ncase 'b':\r\ncase 'B':\r\ncase 'g':\r\ncase 'G':\r\nreturn V4L2_STD_PAL_BG;\r\ncase 'i':\r\ncase 'I':\r\nreturn V4L2_STD_PAL_I;\r\ncase 'd':\r\ncase 'D':\r\ncase 'k':\r\ncase 'K':\r\nreturn V4L2_STD_PAL_DK;\r\ncase 'M':\r\ncase 'm':\r\nreturn V4L2_STD_PAL_M;\r\ncase 'N':\r\ncase 'n':\r\nif (pal[1] == 'c' || pal[1] == 'C')\r\nreturn V4L2_STD_PAL_Nc;\r\nreturn V4L2_STD_PAL_N;\r\ndefault:\r\npr_warn("pal= argument not recognised\n");\r\nbreak;\r\n}\r\n}\r\nif (secam[0] != '-' && (std & V4L2_STD_SECAM) == V4L2_STD_SECAM) {\r\nswitch (secam[0]) {\r\ncase 'b':\r\ncase 'B':\r\ncase 'g':\r\ncase 'G':\r\ncase 'h':\r\ncase 'H':\r\nreturn V4L2_STD_SECAM_B |\r\nV4L2_STD_SECAM_G |\r\nV4L2_STD_SECAM_H;\r\ncase 'd':\r\ncase 'D':\r\ncase 'k':\r\ncase 'K':\r\nreturn V4L2_STD_SECAM_DK;\r\ncase 'l':\r\ncase 'L':\r\nif ((secam[1] == 'C') || (secam[1] == 'c'))\r\nreturn V4L2_STD_SECAM_LC;\r\nreturn V4L2_STD_SECAM_L;\r\ndefault:\r\npr_warn("secam= argument not recognised\n");\r\nbreak;\r\n}\r\n}\r\nif (ntsc[0] != '-' && (std & V4L2_STD_NTSC) == V4L2_STD_NTSC) {\r\nswitch (ntsc[0]) {\r\ncase 'm':\r\ncase 'M':\r\nreturn V4L2_STD_NTSC_M;\r\ncase 'j':\r\ncase 'J':\r\nreturn V4L2_STD_NTSC_M_JP;\r\ncase 'k':\r\ncase 'K':\r\nreturn V4L2_STD_NTSC_M_KR;\r\ndefault:\r\npr_info("ntsc= argument not recognised\n");\r\nbreak;\r\n}\r\n}\r\nreturn std;\r\n}\r\nstatic void set_radio_freq(struct i2c_client *c, unsigned int freq)\r\n{\r\nstruct tuner *t = to_tuner(i2c_get_clientdata(c));\r\nstruct analog_demod_ops *analog_ops = &t->fe.ops.analog_ops;\r\nstruct analog_parameters params = {\r\n.mode = t->mode,\r\n.audmode = t->audmode,\r\n.std = t->std\r\n};\r\nif (t->type == UNSET) {\r\npr_warn("tuner type not set\n");\r\nreturn;\r\n}\r\nif (NULL == analog_ops->set_params) {\r\npr_warn("tuner has no way to set radio frequency\n");\r\nreturn;\r\n}\r\nif (freq < radio_range[0] * 16000 || freq > radio_range[1] * 16000) {\r\ndprintk("radio freq (%d.%02d) out of range (%d-%d)\n",\r\nfreq / 16000, freq % 16000 * 100 / 16000,\r\nradio_range[0], radio_range[1]);\r\nif (freq < radio_range[0] * 16000)\r\nfreq = radio_range[0] * 16000;\r\nelse\r\nfreq = radio_range[1] * 16000;\r\n}\r\nparams.frequency = freq;\r\ndprintk("radio freq set to %d.%02d\n",\r\nfreq / 16000, freq % 16000 * 100 / 16000);\r\nt->radio_freq = freq;\r\nt->standby = false;\r\nanalog_ops->set_params(&t->fe, &params);\r\nt->audmode = params.audmode;\r\n}\r\nstatic void tuner_status(struct dvb_frontend *fe)\r\n{\r\nstruct tuner *t = fe->analog_demod_priv;\r\nunsigned long freq, freq_fraction;\r\nstruct dvb_tuner_ops *fe_tuner_ops = &fe->ops.tuner_ops;\r\nstruct analog_demod_ops *analog_ops = &fe->ops.analog_ops;\r\nconst char *p;\r\nswitch (t->mode) {\r\ncase V4L2_TUNER_RADIO:\r\np = "radio";\r\nbreak;\r\ncase V4L2_TUNER_DIGITAL_TV:\r\np = "digital TV";\r\nbreak;\r\ncase V4L2_TUNER_ANALOG_TV:\r\ndefault:\r\np = "analog TV";\r\nbreak;\r\n}\r\nif (t->mode == V4L2_TUNER_RADIO) {\r\nfreq = t->radio_freq / 16000;\r\nfreq_fraction = (t->radio_freq % 16000) * 100 / 16000;\r\n} else {\r\nfreq = t->tv_freq / 16;\r\nfreq_fraction = (t->tv_freq % 16) * 100 / 16;\r\n}\r\npr_info("Tuner mode: %s%s\n", p,\r\nt->standby ? " on standby mode" : "");\r\npr_info("Frequency: %lu.%02lu MHz\n", freq, freq_fraction);\r\npr_info("Standard: 0x%08lx\n", (unsigned long)t->std);\r\nif (t->mode != V4L2_TUNER_RADIO)\r\nreturn;\r\nif (fe_tuner_ops->get_status) {\r\nu32 tuner_status;\r\nfe_tuner_ops->get_status(&t->fe, &tuner_status);\r\nif (tuner_status & TUNER_STATUS_LOCKED)\r\npr_info("Tuner is locked.\n");\r\nif (tuner_status & TUNER_STATUS_STEREO)\r\npr_info("Stereo: yes\n");\r\n}\r\nif (analog_ops->has_signal) {\r\nu16 signal;\r\nif (!analog_ops->has_signal(fe, &signal))\r\npr_info("Signal strength: %hu\n", signal);\r\n}\r\n}\r\nstatic int tuner_s_radio(struct v4l2_subdev *sd)\r\n{\r\nstruct tuner *t = to_tuner(sd);\r\nif (set_mode(t, V4L2_TUNER_RADIO) == 0)\r\nset_freq(t, 0);\r\nreturn 0;\r\n}\r\nstatic int tuner_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct tuner *t = to_tuner(sd);\r\nstruct analog_demod_ops *analog_ops = &t->fe.ops.analog_ops;\r\nif (on) {\r\nif (t->standby && set_mode(t, t->mode) == 0) {\r\ndprintk("Waking up tuner\n");\r\nset_freq(t, 0);\r\n}\r\nreturn 0;\r\n}\r\ndprintk("Putting tuner to sleep\n");\r\nt->standby = true;\r\nif (analog_ops->standby)\r\nanalog_ops->standby(&t->fe);\r\nreturn 0;\r\n}\r\nstatic int tuner_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nstruct tuner *t = to_tuner(sd);\r\nif (set_mode(t, V4L2_TUNER_ANALOG_TV))\r\nreturn 0;\r\nt->std = tuner_fixup_std(t, std);\r\nif (t->std != std)\r\ndprintk("Fixup standard %llx to %llx\n", std, t->std);\r\nset_freq(t, 0);\r\nreturn 0;\r\n}\r\nstatic int tuner_s_frequency(struct v4l2_subdev *sd, const struct v4l2_frequency *f)\r\n{\r\nstruct tuner *t = to_tuner(sd);\r\nif (set_mode(t, f->type) == 0)\r\nset_freq(t, f->frequency);\r\nreturn 0;\r\n}\r\nstatic int tuner_g_frequency(struct v4l2_subdev *sd, struct v4l2_frequency *f)\r\n{\r\nstruct tuner *t = to_tuner(sd);\r\nstruct dvb_tuner_ops *fe_tuner_ops = &t->fe.ops.tuner_ops;\r\nif (check_mode(t, f->type) == -EINVAL)\r\nreturn 0;\r\nif (f->type == t->mode && fe_tuner_ops->get_frequency && !t->standby) {\r\nu32 abs_freq;\r\nfe_tuner_ops->get_frequency(&t->fe, &abs_freq);\r\nf->frequency = (V4L2_TUNER_RADIO == t->mode) ?\r\nDIV_ROUND_CLOSEST(abs_freq * 2, 125) :\r\nDIV_ROUND_CLOSEST(abs_freq, 62500);\r\n} else {\r\nf->frequency = (V4L2_TUNER_RADIO == f->type) ?\r\nt->radio_freq : t->tv_freq;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tuner_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *vt)\r\n{\r\nstruct tuner *t = to_tuner(sd);\r\nstruct analog_demod_ops *analog_ops = &t->fe.ops.analog_ops;\r\nstruct dvb_tuner_ops *fe_tuner_ops = &t->fe.ops.tuner_ops;\r\nif (check_mode(t, vt->type) == -EINVAL)\r\nreturn 0;\r\nif (vt->type == t->mode && analog_ops->get_afc)\r\nanalog_ops->get_afc(&t->fe, &vt->afc);\r\nif (vt->type == t->mode && analog_ops->has_signal) {\r\nu16 signal = (u16)vt->signal;\r\nif (!analog_ops->has_signal(&t->fe, &signal))\r\nvt->signal = signal;\r\n}\r\nif (vt->type != V4L2_TUNER_RADIO) {\r\nvt->capability |= V4L2_TUNER_CAP_NORM;\r\nvt->rangelow = tv_range[0] * 16;\r\nvt->rangehigh = tv_range[1] * 16;\r\nreturn 0;\r\n}\r\nif (vt->type == t->mode) {\r\nvt->rxsubchans = V4L2_TUNER_SUB_MONO | V4L2_TUNER_SUB_STEREO;\r\nif (fe_tuner_ops->get_status) {\r\nu32 tuner_status;\r\nfe_tuner_ops->get_status(&t->fe, &tuner_status);\r\nvt->rxsubchans =\r\n(tuner_status & TUNER_STATUS_STEREO) ?\r\nV4L2_TUNER_SUB_STEREO :\r\nV4L2_TUNER_SUB_MONO;\r\n}\r\nvt->audmode = t->audmode;\r\n}\r\nvt->capability |= V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_STEREO;\r\nvt->rangelow = radio_range[0] * 16000;\r\nvt->rangehigh = radio_range[1] * 16000;\r\nreturn 0;\r\n}\r\nstatic int tuner_s_tuner(struct v4l2_subdev *sd, const struct v4l2_tuner *vt)\r\n{\r\nstruct tuner *t = to_tuner(sd);\r\nif (set_mode(t, vt->type))\r\nreturn 0;\r\nif (t->mode == V4L2_TUNER_RADIO) {\r\nt->audmode = vt->audmode;\r\nif (t->audmode != V4L2_TUNER_MODE_MONO &&\r\nt->audmode != V4L2_TUNER_MODE_STEREO)\r\nt->audmode = V4L2_TUNER_MODE_STEREO;\r\n}\r\nset_freq(t, 0);\r\nreturn 0;\r\n}\r\nstatic int tuner_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct tuner *t = to_tuner(sd);\r\nstruct analog_demod_ops *analog_ops = &t->fe.ops.analog_ops;\r\nif (analog_ops->tuner_status)\r\nanalog_ops->tuner_status(&t->fe);\r\nreturn 0;\r\n}\r\nstatic int tuner_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *c = to_i2c_client(dev);\r\nstruct tuner *t = to_tuner(i2c_get_clientdata(c));\r\nstruct analog_demod_ops *analog_ops = &t->fe.ops.analog_ops;\r\ndprintk("suspend\n");\r\nif (t->fe.ops.tuner_ops.suspend)\r\nt->fe.ops.tuner_ops.suspend(&t->fe);\r\nelse if (!t->standby && analog_ops->standby)\r\nanalog_ops->standby(&t->fe);\r\nreturn 0;\r\n}\r\nstatic int tuner_resume(struct device *dev)\r\n{\r\nstruct i2c_client *c = to_i2c_client(dev);\r\nstruct tuner *t = to_tuner(i2c_get_clientdata(c));\r\ndprintk("resume\n");\r\nif (t->fe.ops.tuner_ops.resume)\r\nt->fe.ops.tuner_ops.resume(&t->fe);\r\nelse if (!t->standby)\r\nif (set_mode(t, t->mode) == 0)\r\nset_freq(t, 0);\r\nreturn 0;\r\n}\r\nstatic int tuner_command(struct i2c_client *client, unsigned cmd, void *arg)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nswitch (cmd) {\r\ncase TUNER_SET_CONFIG:\r\nreturn tuner_s_config(sd, arg);\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}
