static inline void opal_flash_validate(void)\r\n{\r\nlong ret;\r\nvoid *buf = validate_flash_data.buf;\r\n__be32 size = cpu_to_be32(validate_flash_data.buf_size);\r\n__be32 result;\r\nret = opal_validate_flash(__pa(buf), &size, &result);\r\nvalidate_flash_data.status = ret;\r\nvalidate_flash_data.buf_size = be32_to_cpu(size);\r\nvalidate_flash_data.result = be32_to_cpu(result);\r\n}\r\nstatic ssize_t validate_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *buf)\r\n{\r\nstruct validate_flash_t *args_buf = &validate_flash_data;\r\nint len;\r\nif (args_buf->status < VALIDATE_TMP_UPDATE) {\r\nlen = sprintf(buf, "%d\n", args_buf->status);\r\ngoto out;\r\n}\r\nlen = sprintf(buf, "%d\n", args_buf->result);\r\nif ((args_buf->result != VALIDATE_TMP_UPDATE) &&\r\n(args_buf->result < VALIDATE_CUR_UNKNOWN))\r\ngoto out;\r\nif (args_buf->buf_size > (VALIDATE_BUF_SIZE - len)) {\r\nmemcpy(buf + len, args_buf->buf, VALIDATE_BUF_SIZE - len);\r\nlen = VALIDATE_BUF_SIZE;\r\n} else {\r\nmemcpy(buf + len, args_buf->buf, args_buf->buf_size);\r\nlen += args_buf->buf_size;\r\n}\r\nout:\r\nargs_buf->status = FLASH_NO_OP;\r\nreturn len;\r\n}\r\nstatic ssize_t validate_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct validate_flash_t *args_buf = &validate_flash_data;\r\nif (buf[0] != '1')\r\nreturn -EINVAL;\r\nmutex_lock(&image_data_mutex);\r\nif (image_data.status != IMAGE_READY ||\r\nimage_data.size < VALIDATE_BUF_SIZE) {\r\nargs_buf->result = VALIDATE_INVALID_IMG;\r\nargs_buf->status = VALIDATE_IMG_INCOMPLETE;\r\ngoto out;\r\n}\r\nmemcpy(args_buf->buf, image_data.data, VALIDATE_BUF_SIZE);\r\nargs_buf->status = VALIDATE_IMG_READY;\r\nargs_buf->buf_size = VALIDATE_BUF_SIZE;\r\nopal_flash_validate();\r\nout:\r\nmutex_unlock(&image_data_mutex);\r\nreturn count;\r\n}\r\nstatic inline void opal_flash_manage(uint8_t op)\r\n{\r\nstruct manage_flash_t *const args_buf = &manage_flash_data;\r\nargs_buf->status = opal_manage_flash(op);\r\n}\r\nstatic ssize_t manage_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *buf)\r\n{\r\nstruct manage_flash_t *const args_buf = &manage_flash_data;\r\nint rc;\r\nrc = sprintf(buf, "%d\n", args_buf->status);\r\nargs_buf->status = FLASH_NO_OP;\r\nreturn rc;\r\n}\r\nstatic ssize_t manage_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nuint8_t op;\r\nswitch (buf[0]) {\r\ncase '0':\r\nop = FLASH_REJECT_TMP_SIDE;\r\nbreak;\r\ncase '1':\r\nop = FLASH_COMMIT_TMP_SIDE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nopal_flash_manage(op);\r\nreturn count;\r\n}\r\nstatic int opal_flash_update(int op)\r\n{\r\nstruct opal_sg_list *list;\r\nunsigned long addr;\r\nint64_t rc = OPAL_PARAMETER;\r\nif (op == FLASH_UPDATE_CANCEL) {\r\npr_alert("FLASH: Image update cancelled\n");\r\naddr = '\0';\r\ngoto flash;\r\n}\r\nlist = opal_vmalloc_to_sg_list(image_data.data, image_data.size);\r\nif (!list)\r\ngoto invalid_img;\r\naddr = __pa(list);\r\nflash:\r\nrc = opal_update_flash(addr);\r\ninvalid_img:\r\nreturn rc;\r\n}\r\nstatic void flash_return_cpu(void *info)\r\n{\r\nint cpu = smp_processor_id();\r\nif (!cpu_online(cpu))\r\nreturn;\r\nhard_irq_disable();\r\nopal_return_cpu();\r\n}\r\nvoid opal_flash_term_callback(void)\r\n{\r\nstruct cpumask mask;\r\nif (update_flash_data.status != FLASH_IMG_READY)\r\nreturn;\r\npr_alert("FLASH: Flashing new firmware\n");\r\npr_alert("FLASH: Image is %u bytes\n", image_data.size);\r\npr_alert("FLASH: Performing flash and reboot/shutdown\n");\r\npr_alert("FLASH: This will take several minutes. Do not power off!\n");\r\nmsleep(500);\r\ncpumask_copy(&mask, cpu_online_mask);\r\ncpumask_clear_cpu(smp_processor_id(), &mask);\r\nif (!cpumask_empty(&mask))\r\nsmp_call_function_many(&mask,\r\nflash_return_cpu, NULL, false);\r\nhard_irq_disable();\r\n}\r\nstatic ssize_t update_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *buf)\r\n{\r\nstruct update_flash_t *const args_buf = &update_flash_data;\r\nreturn sprintf(buf, "%d\n", args_buf->status);\r\n}\r\nstatic ssize_t update_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct update_flash_t *const args_buf = &update_flash_data;\r\nint rc = count;\r\nmutex_lock(&image_data_mutex);\r\nswitch (buf[0]) {\r\ncase '0':\r\nif (args_buf->status == FLASH_IMG_READY)\r\nopal_flash_update(FLASH_UPDATE_CANCEL);\r\nargs_buf->status = FLASH_NO_OP;\r\nbreak;\r\ncase '1':\r\nif (image_data.status == IMAGE_READY)\r\nargs_buf->status =\r\nopal_flash_update(FLASH_UPDATE_INIT);\r\nelse\r\nargs_buf->status = FLASH_INVALID_IMG;\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\n}\r\nmutex_unlock(&image_data_mutex);\r\nreturn rc;\r\n}\r\nstatic void free_image_buf(void)\r\n{\r\nvoid *addr;\r\nint size;\r\naddr = image_data.data;\r\nsize = PAGE_ALIGN(image_data.size);\r\nwhile (size > 0) {\r\nClearPageReserved(vmalloc_to_page(addr));\r\naddr += PAGE_SIZE;\r\nsize -= PAGE_SIZE;\r\n}\r\nvfree(image_data.data);\r\nimage_data.data = NULL;\r\nimage_data.status = IMAGE_INVALID;\r\n}\r\nstatic int alloc_image_buf(char *buffer, size_t count)\r\n{\r\nvoid *addr;\r\nint size;\r\nif (count < sizeof(struct image_header_t)) {\r\npr_warn("FLASH: Invalid candidate image\n");\r\nreturn -EINVAL;\r\n}\r\nmemcpy(&image_header, (void *)buffer, sizeof(struct image_header_t));\r\nimage_data.size = be32_to_cpu(image_header.size);\r\npr_debug("FLASH: Candidate image size = %u\n", image_data.size);\r\nif (image_data.size > MAX_IMAGE_SIZE) {\r\npr_warn("FLASH: Too large image\n");\r\nreturn -EINVAL;\r\n}\r\nif (image_data.size < VALIDATE_BUF_SIZE) {\r\npr_warn("FLASH: Image is shorter than expected\n");\r\nreturn -EINVAL;\r\n}\r\nimage_data.data = vzalloc(PAGE_ALIGN(image_data.size));\r\nif (!image_data.data) {\r\npr_err("%s : Failed to allocate memory\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\naddr = image_data.data;\r\nsize = PAGE_ALIGN(image_data.size);\r\nwhile (size > 0) {\r\nSetPageReserved(vmalloc_to_page(addr));\r\naddr += PAGE_SIZE;\r\nsize -= PAGE_SIZE;\r\n}\r\nimage_data.status = IMAGE_LOADING;\r\nreturn 0;\r\n}\r\nstatic ssize_t image_data_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buffer, loff_t pos, size_t count)\r\n{\r\nint rc;\r\nmutex_lock(&image_data_mutex);\r\nif (pos == 0) {\r\nif (image_data.data)\r\nfree_image_buf();\r\nif (update_flash_data.status == FLASH_IMG_READY)\r\nopal_flash_update(FLASH_UPDATE_CANCEL);\r\nrc = alloc_image_buf(buffer, count);\r\nif (rc)\r\ngoto out;\r\n}\r\nif (image_data.status != IMAGE_LOADING) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nif ((pos + count) > image_data.size) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nmemcpy(image_data.data + pos, (void *)buffer, count);\r\nrc = count;\r\nif ((pos + count) == image_data.size) {\r\npr_debug("FLASH: Candidate image loaded....\n");\r\nimage_data.status = IMAGE_READY;\r\n}\r\nout:\r\nmutex_unlock(&image_data_mutex);\r\nreturn rc;\r\n}\r\nvoid __init opal_flash_update_init(void)\r\n{\r\nint ret;\r\nvalidate_flash_data.buf = kzalloc(VALIDATE_BUF_SIZE, GFP_KERNEL);\r\nif (!validate_flash_data.buf) {\r\npr_err("%s : Failed to allocate memory\n", __func__);\r\nreturn;\r\n}\r\nif (!opal_kobj) {\r\npr_warn("FLASH: opal kobject is not available\n");\r\ngoto nokobj;\r\n}\r\nret = sysfs_create_group(opal_kobj, &image_op_attr_group);\r\nif (ret) {\r\npr_warn("FLASH: Failed to create sysfs files\n");\r\ngoto nokobj;\r\n}\r\nret = sysfs_create_bin_file(opal_kobj, &image_data_attr);\r\nif (ret) {\r\npr_warn("FLASH: Failed to create sysfs files\n");\r\ngoto nosysfs_file;\r\n}\r\nvalidate_flash_data.status = FLASH_NO_OP;\r\nmanage_flash_data.status = FLASH_NO_OP;\r\nupdate_flash_data.status = FLASH_NO_OP;\r\nimage_data.status = IMAGE_INVALID;\r\nreturn;\r\nnosysfs_file:\r\nsysfs_remove_group(opal_kobj, &image_op_attr_group);\r\nnokobj:\r\nkfree(validate_flash_data.buf);\r\nreturn;\r\n}
