static struct master *__master_find(struct device *dev,\r\nconst struct component_master_ops *ops)\r\n{\r\nstruct master *m;\r\nlist_for_each_entry(m, &masters, node)\r\nif (m->dev == dev && (!ops || m->ops == ops))\r\nreturn m;\r\nreturn NULL;\r\n}\r\nstatic struct component *find_component(struct master *master,\r\nint (*compare)(struct device *, void *), void *compare_data)\r\n{\r\nstruct component *c;\r\nlist_for_each_entry(c, &component_list, node) {\r\nif (c->master && c->master != master)\r\ncontinue;\r\nif (compare(c->dev, compare_data))\r\nreturn c;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int find_components(struct master *master)\r\n{\r\nstruct component_match *match = master->match;\r\nsize_t i;\r\nint ret = 0;\r\nfor (i = 0; i < match->num; i++) {\r\nstruct component_match_array *mc = &match->compare[i];\r\nstruct component *c;\r\ndev_dbg(master->dev, "Looking for component %zu\n", i);\r\nif (match->compare[i].component)\r\ncontinue;\r\nc = find_component(master, mc->compare, mc->data);\r\nif (!c) {\r\nret = -ENXIO;\r\nbreak;\r\n}\r\ndev_dbg(master->dev, "found component %s, duplicate %u\n", dev_name(c->dev), !!c->master);\r\nmatch->compare[i].duplicate = !!c->master;\r\nmatch->compare[i].component = c;\r\nc->master = master;\r\n}\r\nreturn ret;\r\n}\r\nstatic void remove_component(struct master *master, struct component *c)\r\n{\r\nsize_t i;\r\nfor (i = 0; i < master->match->num; i++)\r\nif (master->match->compare[i].component == c)\r\nmaster->match->compare[i].component = NULL;\r\n}\r\nstatic int try_to_bring_up_master(struct master *master,\r\nstruct component *component)\r\n{\r\nint ret;\r\ndev_dbg(master->dev, "trying to bring up master\n");\r\nif (find_components(master)) {\r\ndev_dbg(master->dev, "master has incomplete components\n");\r\nreturn 0;\r\n}\r\nif (component && component->master != master) {\r\ndev_dbg(master->dev, "master is not for this component (%s)\n",\r\ndev_name(component->dev));\r\nreturn 0;\r\n}\r\nif (!devres_open_group(master->dev, NULL, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nret = master->ops->bind(master->dev);\r\nif (ret < 0) {\r\ndevres_release_group(master->dev, NULL);\r\ndev_info(master->dev, "master bind failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nmaster->bound = true;\r\nreturn 1;\r\n}\r\nstatic int try_to_bring_up_masters(struct component *component)\r\n{\r\nstruct master *m;\r\nint ret = 0;\r\nlist_for_each_entry(m, &masters, node) {\r\nif (!m->bound) {\r\nret = try_to_bring_up_master(m, component);\r\nif (ret != 0)\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void take_down_master(struct master *master)\r\n{\r\nif (master->bound) {\r\nmaster->ops->unbind(master->dev);\r\ndevres_release_group(master->dev, NULL);\r\nmaster->bound = false;\r\n}\r\n}\r\nstatic void component_match_release(struct device *master,\r\nstruct component_match *match)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < match->num; i++) {\r\nstruct component_match_array *mc = &match->compare[i];\r\nif (mc->release)\r\nmc->release(master, mc->data);\r\n}\r\nkfree(match->compare);\r\n}\r\nstatic void devm_component_match_release(struct device *dev, void *res)\r\n{\r\ncomponent_match_release(dev, res);\r\n}\r\nstatic int component_match_realloc(struct device *dev,\r\nstruct component_match *match, size_t num)\r\n{\r\nstruct component_match_array *new;\r\nif (match->alloc == num)\r\nreturn 0;\r\nnew = kmalloc_array(num, sizeof(*new), GFP_KERNEL);\r\nif (!new)\r\nreturn -ENOMEM;\r\nif (match->compare) {\r\nmemcpy(new, match->compare, sizeof(*new) *\r\nmin(match->num, num));\r\nkfree(match->compare);\r\n}\r\nmatch->compare = new;\r\nmatch->alloc = num;\r\nreturn 0;\r\n}\r\nvoid component_match_add_release(struct device *master,\r\nstruct component_match **matchptr,\r\nvoid (*release)(struct device *, void *),\r\nint (*compare)(struct device *, void *), void *compare_data)\r\n{\r\nstruct component_match *match = *matchptr;\r\nif (IS_ERR(match))\r\nreturn;\r\nif (!match) {\r\nmatch = devres_alloc(devm_component_match_release,\r\nsizeof(*match), GFP_KERNEL);\r\nif (!match) {\r\n*matchptr = ERR_PTR(-ENOMEM);\r\nreturn;\r\n}\r\ndevres_add(master, match);\r\n*matchptr = match;\r\n}\r\nif (match->num == match->alloc) {\r\nsize_t new_size = match->alloc + 16;\r\nint ret;\r\nret = component_match_realloc(master, match, new_size);\r\nif (ret) {\r\n*matchptr = ERR_PTR(ret);\r\nreturn;\r\n}\r\n}\r\nmatch->compare[match->num].compare = compare;\r\nmatch->compare[match->num].release = release;\r\nmatch->compare[match->num].data = compare_data;\r\nmatch->compare[match->num].component = NULL;\r\nmatch->num++;\r\n}\r\nstatic void free_master(struct master *master)\r\n{\r\nstruct component_match *match = master->match;\r\nint i;\r\nlist_del(&master->node);\r\nif (match) {\r\nfor (i = 0; i < match->num; i++) {\r\nstruct component *c = match->compare[i].component;\r\nif (c)\r\nc->master = NULL;\r\n}\r\n}\r\nkfree(master);\r\n}\r\nint component_master_add_with_match(struct device *dev,\r\nconst struct component_master_ops *ops,\r\nstruct component_match *match)\r\n{\r\nstruct master *master;\r\nint ret;\r\nret = component_match_realloc(dev, match, match->num);\r\nif (ret)\r\nreturn ret;\r\nmaster = kzalloc(sizeof(*master), GFP_KERNEL);\r\nif (!master)\r\nreturn -ENOMEM;\r\nmaster->dev = dev;\r\nmaster->ops = ops;\r\nmaster->match = match;\r\nmutex_lock(&component_mutex);\r\nlist_add(&master->node, &masters);\r\nret = try_to_bring_up_master(master, NULL);\r\nif (ret < 0)\r\nfree_master(master);\r\nmutex_unlock(&component_mutex);\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nvoid component_master_del(struct device *dev,\r\nconst struct component_master_ops *ops)\r\n{\r\nstruct master *master;\r\nmutex_lock(&component_mutex);\r\nmaster = __master_find(dev, ops);\r\nif (master) {\r\ntake_down_master(master);\r\nfree_master(master);\r\n}\r\nmutex_unlock(&component_mutex);\r\n}\r\nstatic void component_unbind(struct component *component,\r\nstruct master *master, void *data)\r\n{\r\nWARN_ON(!component->bound);\r\ncomponent->ops->unbind(component->dev, master->dev, data);\r\ncomponent->bound = false;\r\ndevres_release_group(component->dev, component);\r\n}\r\nvoid component_unbind_all(struct device *master_dev, void *data)\r\n{\r\nstruct master *master;\r\nstruct component *c;\r\nsize_t i;\r\nWARN_ON(!mutex_is_locked(&component_mutex));\r\nmaster = __master_find(master_dev, NULL);\r\nif (!master)\r\nreturn;\r\nfor (i = master->match->num; i--; )\r\nif (!master->match->compare[i].duplicate) {\r\nc = master->match->compare[i].component;\r\ncomponent_unbind(c, master, data);\r\n}\r\n}\r\nstatic int component_bind(struct component *component, struct master *master,\r\nvoid *data)\r\n{\r\nint ret;\r\nif (!devres_open_group(master->dev, NULL, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nif (!devres_open_group(component->dev, component, GFP_KERNEL)) {\r\ndevres_release_group(master->dev, NULL);\r\nreturn -ENOMEM;\r\n}\r\ndev_dbg(master->dev, "binding %s (ops %ps)\n",\r\ndev_name(component->dev), component->ops);\r\nret = component->ops->bind(component->dev, master->dev, data);\r\nif (!ret) {\r\ncomponent->bound = true;\r\ndevres_close_group(component->dev, NULL);\r\ndevres_remove_group(master->dev, NULL);\r\ndev_info(master->dev, "bound %s (ops %ps)\n",\r\ndev_name(component->dev), component->ops);\r\n} else {\r\ndevres_release_group(component->dev, NULL);\r\ndevres_release_group(master->dev, NULL);\r\ndev_err(master->dev, "failed to bind %s (ops %ps): %d\n",\r\ndev_name(component->dev), component->ops, ret);\r\n}\r\nreturn ret;\r\n}\r\nint component_bind_all(struct device *master_dev, void *data)\r\n{\r\nstruct master *master;\r\nstruct component *c;\r\nsize_t i;\r\nint ret = 0;\r\nWARN_ON(!mutex_is_locked(&component_mutex));\r\nmaster = __master_find(master_dev, NULL);\r\nif (!master)\r\nreturn -EINVAL;\r\nfor (i = 0; i < master->match->num; i++)\r\nif (!master->match->compare[i].duplicate) {\r\nc = master->match->compare[i].component;\r\nret = component_bind(c, master, data);\r\nif (ret)\r\nbreak;\r\n}\r\nif (ret != 0) {\r\nfor (; i--; )\r\nif (!master->match->compare[i].duplicate) {\r\nc = master->match->compare[i].component;\r\ncomponent_unbind(c, master, data);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint component_add(struct device *dev, const struct component_ops *ops)\r\n{\r\nstruct component *component;\r\nint ret;\r\ncomponent = kzalloc(sizeof(*component), GFP_KERNEL);\r\nif (!component)\r\nreturn -ENOMEM;\r\ncomponent->ops = ops;\r\ncomponent->dev = dev;\r\ndev_dbg(dev, "adding component (ops %ps)\n", ops);\r\nmutex_lock(&component_mutex);\r\nlist_add_tail(&component->node, &component_list);\r\nret = try_to_bring_up_masters(component);\r\nif (ret < 0) {\r\nif (component->master)\r\nremove_component(component->master, component);\r\nlist_del(&component->node);\r\nkfree(component);\r\n}\r\nmutex_unlock(&component_mutex);\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nvoid component_del(struct device *dev, const struct component_ops *ops)\r\n{\r\nstruct component *c, *component = NULL;\r\nmutex_lock(&component_mutex);\r\nlist_for_each_entry(c, &component_list, node)\r\nif (c->dev == dev && c->ops == ops) {\r\nlist_del(&c->node);\r\ncomponent = c;\r\nbreak;\r\n}\r\nif (component && component->master) {\r\ntake_down_master(component->master);\r\nremove_component(component->master, component);\r\n}\r\nmutex_unlock(&component_mutex);\r\nWARN_ON(!component);\r\nkfree(component);\r\n}
