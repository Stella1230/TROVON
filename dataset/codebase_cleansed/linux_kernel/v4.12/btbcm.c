int btbcm_check_bdaddr(struct hci_dev *hdev)\r\n{\r\nstruct hci_rp_read_bd_addr *bda;\r\nstruct sk_buff *skb;\r\nskb = __hci_cmd_sync(hdev, HCI_OP_READ_BD_ADDR, 0, NULL,\r\nHCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nint err = PTR_ERR(skb);\r\nBT_ERR("%s: BCM: Reading device address failed (%d)",\r\nhdev->name, err);\r\nreturn err;\r\n}\r\nif (skb->len != sizeof(*bda)) {\r\nBT_ERR("%s: BCM: Device address length mismatch", hdev->name);\r\nkfree_skb(skb);\r\nreturn -EIO;\r\n}\r\nbda = (struct hci_rp_read_bd_addr *)skb->data;\r\nif (!bacmp(&bda->bdaddr, BDADDR_BCM20702A0) ||\r\n!bacmp(&bda->bdaddr, BDADDR_BCM4324B3) ||\r\n!bacmp(&bda->bdaddr, BDADDR_BCM4330B1)) {\r\nBT_INFO("%s: BCM: Using default device address (%pMR)",\r\nhdev->name, &bda->bdaddr);\r\nset_bit(HCI_QUIRK_INVALID_BDADDR, &hdev->quirks);\r\n}\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nint btbcm_set_bdaddr(struct hci_dev *hdev, const bdaddr_t *bdaddr)\r\n{\r\nstruct sk_buff *skb;\r\nint err;\r\nskb = __hci_cmd_sync(hdev, 0xfc01, 6, bdaddr, HCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nerr = PTR_ERR(skb);\r\nBT_ERR("%s: BCM: Change address command failed (%d)",\r\nhdev->name, err);\r\nreturn err;\r\n}\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nint btbcm_patchram(struct hci_dev *hdev, const struct firmware *fw)\r\n{\r\nconst struct hci_command_hdr *cmd;\r\nconst u8 *fw_ptr;\r\nsize_t fw_size;\r\nstruct sk_buff *skb;\r\nu16 opcode;\r\nint err = 0;\r\nskb = __hci_cmd_sync(hdev, 0xfc2e, 0, NULL, HCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nerr = PTR_ERR(skb);\r\nBT_ERR("%s: BCM: Download Minidrv command failed (%d)",\r\nhdev->name, err);\r\ngoto done;\r\n}\r\nkfree_skb(skb);\r\nmsleep(50);\r\nfw_ptr = fw->data;\r\nfw_size = fw->size;\r\nwhile (fw_size >= sizeof(*cmd)) {\r\nconst u8 *cmd_param;\r\ncmd = (struct hci_command_hdr *)fw_ptr;\r\nfw_ptr += sizeof(*cmd);\r\nfw_size -= sizeof(*cmd);\r\nif (fw_size < cmd->plen) {\r\nBT_ERR("%s: BCM: Patch is corrupted", hdev->name);\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\ncmd_param = fw_ptr;\r\nfw_ptr += cmd->plen;\r\nfw_size -= cmd->plen;\r\nopcode = le16_to_cpu(cmd->opcode);\r\nskb = __hci_cmd_sync(hdev, opcode, cmd->plen, cmd_param,\r\nHCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nerr = PTR_ERR(skb);\r\nBT_ERR("%s: BCM: Patch command %04x failed (%d)",\r\nhdev->name, opcode, err);\r\ngoto done;\r\n}\r\nkfree_skb(skb);\r\n}\r\nmsleep(250);\r\ndone:\r\nreturn err;\r\n}\r\nstatic int btbcm_reset(struct hci_dev *hdev)\r\n{\r\nstruct sk_buff *skb;\r\nskb = __hci_cmd_sync(hdev, HCI_OP_RESET, 0, NULL, HCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nint err = PTR_ERR(skb);\r\nBT_ERR("%s: BCM: Reset failed (%d)", hdev->name, err);\r\nreturn err;\r\n}\r\nkfree_skb(skb);\r\nmsleep(100);\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *btbcm_read_local_name(struct hci_dev *hdev)\r\n{\r\nstruct sk_buff *skb;\r\nskb = __hci_cmd_sync(hdev, HCI_OP_READ_LOCAL_NAME, 0, NULL,\r\nHCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nBT_ERR("%s: BCM: Reading local name failed (%ld)",\r\nhdev->name, PTR_ERR(skb));\r\nreturn skb;\r\n}\r\nif (skb->len != sizeof(struct hci_rp_read_local_name)) {\r\nBT_ERR("%s: BCM: Local name length mismatch", hdev->name);\r\nkfree_skb(skb);\r\nreturn ERR_PTR(-EIO);\r\n}\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *btbcm_read_local_version(struct hci_dev *hdev)\r\n{\r\nstruct sk_buff *skb;\r\nskb = __hci_cmd_sync(hdev, HCI_OP_READ_LOCAL_VERSION, 0, NULL,\r\nHCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nBT_ERR("%s: BCM: Reading local version info failed (%ld)",\r\nhdev->name, PTR_ERR(skb));\r\nreturn skb;\r\n}\r\nif (skb->len != sizeof(struct hci_rp_read_local_version)) {\r\nBT_ERR("%s: BCM: Local version length mismatch", hdev->name);\r\nkfree_skb(skb);\r\nreturn ERR_PTR(-EIO);\r\n}\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *btbcm_read_verbose_config(struct hci_dev *hdev)\r\n{\r\nstruct sk_buff *skb;\r\nskb = __hci_cmd_sync(hdev, 0xfc79, 0, NULL, HCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nBT_ERR("%s: BCM: Read verbose config info failed (%ld)",\r\nhdev->name, PTR_ERR(skb));\r\nreturn skb;\r\n}\r\nif (skb->len != 7) {\r\nBT_ERR("%s: BCM: Verbose config length mismatch", hdev->name);\r\nkfree_skb(skb);\r\nreturn ERR_PTR(-EIO);\r\n}\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *btbcm_read_usb_product(struct hci_dev *hdev)\r\n{\r\nstruct sk_buff *skb;\r\nskb = __hci_cmd_sync(hdev, 0xfc5a, 0, NULL, HCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nBT_ERR("%s: BCM: Read USB product info failed (%ld)",\r\nhdev->name, PTR_ERR(skb));\r\nreturn skb;\r\n}\r\nif (skb->len != 5) {\r\nBT_ERR("%s: BCM: USB product length mismatch", hdev->name);\r\nkfree_skb(skb);\r\nreturn ERR_PTR(-EIO);\r\n}\r\nreturn skb;\r\n}\r\nint btbcm_initialize(struct hci_dev *hdev, char *fw_name, size_t len)\r\n{\r\nu16 subver, rev;\r\nconst char *hw_name = NULL;\r\nstruct sk_buff *skb;\r\nstruct hci_rp_read_local_version *ver;\r\nint i, err;\r\nerr = btbcm_reset(hdev);\r\nif (err)\r\nreturn err;\r\nskb = btbcm_read_local_version(hdev);\r\nif (IS_ERR(skb))\r\nreturn PTR_ERR(skb);\r\nver = (struct hci_rp_read_local_version *)skb->data;\r\nrev = le16_to_cpu(ver->hci_rev);\r\nsubver = le16_to_cpu(ver->lmp_subver);\r\nkfree_skb(skb);\r\nskb = btbcm_read_verbose_config(hdev);\r\nif (IS_ERR(skb))\r\nreturn PTR_ERR(skb);\r\nBT_INFO("%s: BCM: chip id %u", hdev->name, skb->data[1]);\r\nkfree_skb(skb);\r\nswitch ((rev & 0xf000) >> 12) {\r\ncase 0:\r\ncase 1:\r\ncase 3:\r\nfor (i = 0; bcm_uart_subver_table[i].name; i++) {\r\nif (subver == bcm_uart_subver_table[i].subver) {\r\nhw_name = bcm_uart_subver_table[i].name;\r\nbreak;\r\n}\r\n}\r\nsnprintf(fw_name, len, "brcm/%s.hcd", hw_name ? : "BCM");\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nBT_INFO("%s: %s (%3.3u.%3.3u.%3.3u) build %4.4u", hdev->name,\r\nhw_name ? : "BCM", (subver & 0xe000) >> 13,\r\n(subver & 0x1f00) >> 8, (subver & 0x00ff), rev & 0x0fff);\r\nreturn 0;\r\n}\r\nint btbcm_finalize(struct hci_dev *hdev)\r\n{\r\nstruct sk_buff *skb;\r\nstruct hci_rp_read_local_version *ver;\r\nu16 subver, rev;\r\nint err;\r\nerr = btbcm_reset(hdev);\r\nif (err)\r\nreturn err;\r\nskb = btbcm_read_local_version(hdev);\r\nif (IS_ERR(skb))\r\nreturn PTR_ERR(skb);\r\nver = (struct hci_rp_read_local_version *)skb->data;\r\nrev = le16_to_cpu(ver->hci_rev);\r\nsubver = le16_to_cpu(ver->lmp_subver);\r\nkfree_skb(skb);\r\nBT_INFO("%s: BCM (%3.3u.%3.3u.%3.3u) build %4.4u", hdev->name,\r\n(subver & 0xe000) >> 13, (subver & 0x1f00) >> 8,\r\n(subver & 0x00ff), rev & 0x0fff);\r\nbtbcm_check_bdaddr(hdev);\r\nset_bit(HCI_QUIRK_STRICT_DUPLICATE_FILTER, &hdev->quirks);\r\nreturn 0;\r\n}\r\nint btbcm_setup_patchram(struct hci_dev *hdev)\r\n{\r\nchar fw_name[64];\r\nconst struct firmware *fw;\r\nu16 subver, rev, pid, vid;\r\nconst char *hw_name = NULL;\r\nstruct sk_buff *skb;\r\nstruct hci_rp_read_local_version *ver;\r\nint i, err;\r\nerr = btbcm_reset(hdev);\r\nif (err)\r\nreturn err;\r\nskb = btbcm_read_local_version(hdev);\r\nif (IS_ERR(skb))\r\nreturn PTR_ERR(skb);\r\nver = (struct hci_rp_read_local_version *)skb->data;\r\nrev = le16_to_cpu(ver->hci_rev);\r\nsubver = le16_to_cpu(ver->lmp_subver);\r\nkfree_skb(skb);\r\nskb = btbcm_read_verbose_config(hdev);\r\nif (IS_ERR(skb))\r\nreturn PTR_ERR(skb);\r\nBT_INFO("%s: BCM: chip id %u", hdev->name, skb->data[1]);\r\nkfree_skb(skb);\r\nskb = btbcm_read_local_name(hdev);\r\nif (IS_ERR(skb))\r\nreturn PTR_ERR(skb);\r\nBT_INFO("%s: %s", hdev->name, (char *)(skb->data + 1));\r\nkfree_skb(skb);\r\nswitch ((rev & 0xf000) >> 12) {\r\ncase 0:\r\ncase 3:\r\nfor (i = 0; bcm_uart_subver_table[i].name; i++) {\r\nif (subver == bcm_uart_subver_table[i].subver) {\r\nhw_name = bcm_uart_subver_table[i].name;\r\nbreak;\r\n}\r\n}\r\nsnprintf(fw_name, sizeof(fw_name), "brcm/%s.hcd",\r\nhw_name ? : "BCM");\r\nbreak;\r\ncase 1:\r\ncase 2:\r\nskb = btbcm_read_usb_product(hdev);\r\nif (IS_ERR(skb))\r\nreturn PTR_ERR(skb);\r\nvid = get_unaligned_le16(skb->data + 1);\r\npid = get_unaligned_le16(skb->data + 3);\r\nkfree_skb(skb);\r\nfor (i = 0; bcm_usb_subver_table[i].name; i++) {\r\nif (subver == bcm_usb_subver_table[i].subver) {\r\nhw_name = bcm_usb_subver_table[i].name;\r\nbreak;\r\n}\r\n}\r\nsnprintf(fw_name, sizeof(fw_name), "brcm/%s-%4.4x-%4.4x.hcd",\r\nhw_name ? : "BCM", vid, pid);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nBT_INFO("%s: %s (%3.3u.%3.3u.%3.3u) build %4.4u", hdev->name,\r\nhw_name ? : "BCM", (subver & 0xe000) >> 13,\r\n(subver & 0x1f00) >> 8, (subver & 0x00ff), rev & 0x0fff);\r\nerr = request_firmware(&fw, fw_name, &hdev->dev);\r\nif (err < 0) {\r\nBT_INFO("%s: BCM: Patch %s not found", hdev->name, fw_name);\r\ngoto done;\r\n}\r\nbtbcm_patchram(hdev, fw);\r\nrelease_firmware(fw);\r\nerr = btbcm_reset(hdev);\r\nif (err)\r\nreturn err;\r\nskb = btbcm_read_local_version(hdev);\r\nif (IS_ERR(skb))\r\nreturn PTR_ERR(skb);\r\nver = (struct hci_rp_read_local_version *)skb->data;\r\nrev = le16_to_cpu(ver->hci_rev);\r\nsubver = le16_to_cpu(ver->lmp_subver);\r\nkfree_skb(skb);\r\nBT_INFO("%s: %s (%3.3u.%3.3u.%3.3u) build %4.4u", hdev->name,\r\nhw_name ? : "BCM", (subver & 0xe000) >> 13,\r\n(subver & 0x1f00) >> 8, (subver & 0x00ff), rev & 0x0fff);\r\nskb = btbcm_read_local_name(hdev);\r\nif (IS_ERR(skb))\r\nreturn PTR_ERR(skb);\r\nBT_INFO("%s: %s", hdev->name, (char *)(skb->data + 1));\r\nkfree_skb(skb);\r\ndone:\r\nbtbcm_check_bdaddr(hdev);\r\nset_bit(HCI_QUIRK_STRICT_DUPLICATE_FILTER, &hdev->quirks);\r\nreturn 0;\r\n}\r\nint btbcm_setup_apple(struct hci_dev *hdev)\r\n{\r\nstruct sk_buff *skb;\r\nint err;\r\nerr = btbcm_reset(hdev);\r\nif (err)\r\nreturn err;\r\nskb = btbcm_read_verbose_config(hdev);\r\nif (!IS_ERR(skb)) {\r\nBT_INFO("%s: BCM: chip id %u build %4.4u", hdev->name,\r\nskb->data[1], get_unaligned_le16(skb->data + 5));\r\nkfree_skb(skb);\r\n}\r\nskb = btbcm_read_usb_product(hdev);\r\nif (!IS_ERR(skb)) {\r\nBT_INFO("%s: BCM: product %4.4x:%4.4x", hdev->name,\r\nget_unaligned_le16(skb->data + 1),\r\nget_unaligned_le16(skb->data + 3));\r\nkfree_skb(skb);\r\n}\r\nskb = btbcm_read_local_name(hdev);\r\nif (!IS_ERR(skb)) {\r\nBT_INFO("%s: %s", hdev->name, (char *)(skb->data + 1));\r\nkfree_skb(skb);\r\n}\r\nset_bit(HCI_QUIRK_STRICT_DUPLICATE_FILTER, &hdev->quirks);\r\nreturn 0;\r\n}
