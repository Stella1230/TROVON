static inline void\r\nat86rf230_sleep(struct at86rf230_local *lp)\r\n{\r\nif (gpio_is_valid(lp->slp_tr)) {\r\ngpio_set_value(lp->slp_tr, 1);\r\nusleep_range(lp->data->t_off_to_sleep,\r\nlp->data->t_off_to_sleep + 10);\r\nlp->sleep = true;\r\n}\r\n}\r\nstatic inline void\r\nat86rf230_awake(struct at86rf230_local *lp)\r\n{\r\nif (gpio_is_valid(lp->slp_tr)) {\r\ngpio_set_value(lp->slp_tr, 0);\r\nusleep_range(lp->data->t_sleep_to_off,\r\nlp->data->t_sleep_to_off + 100);\r\nlp->sleep = false;\r\n}\r\n}\r\nstatic inline int\r\n__at86rf230_write(struct at86rf230_local *lp,\r\nunsigned int addr, unsigned int data)\r\n{\r\nbool sleep = lp->sleep;\r\nint ret;\r\nif (sleep)\r\nat86rf230_awake(lp);\r\nret = regmap_write(lp->regmap, addr, data);\r\nif (sleep)\r\nat86rf230_sleep(lp);\r\nreturn ret;\r\n}\r\nstatic inline int\r\n__at86rf230_read(struct at86rf230_local *lp,\r\nunsigned int addr, unsigned int *data)\r\n{\r\nbool sleep = lp->sleep;\r\nint ret;\r\nif (sleep)\r\nat86rf230_awake(lp);\r\nret = regmap_read(lp->regmap, addr, data);\r\nif (sleep)\r\nat86rf230_sleep(lp);\r\nreturn ret;\r\n}\r\nstatic inline int\r\nat86rf230_read_subreg(struct at86rf230_local *lp,\r\nunsigned int addr, unsigned int mask,\r\nunsigned int shift, unsigned int *data)\r\n{\r\nint rc;\r\nrc = __at86rf230_read(lp, addr, data);\r\nif (!rc)\r\n*data = (*data & mask) >> shift;\r\nreturn rc;\r\n}\r\nstatic inline int\r\nat86rf230_write_subreg(struct at86rf230_local *lp,\r\nunsigned int addr, unsigned int mask,\r\nunsigned int shift, unsigned int data)\r\n{\r\nbool sleep = lp->sleep;\r\nint ret;\r\nif (sleep)\r\nat86rf230_awake(lp);\r\nret = regmap_update_bits(lp->regmap, addr, mask, data << shift);\r\nif (sleep)\r\nat86rf230_sleep(lp);\r\nreturn ret;\r\n}\r\nstatic inline void\r\nat86rf230_slp_tr_rising_edge(struct at86rf230_local *lp)\r\n{\r\ngpio_set_value(lp->slp_tr, 1);\r\nudelay(1);\r\ngpio_set_value(lp->slp_tr, 0);\r\n}\r\nstatic bool\r\nat86rf230_reg_writeable(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase RG_TRX_STATE:\r\ncase RG_TRX_CTRL_0:\r\ncase RG_TRX_CTRL_1:\r\ncase RG_PHY_TX_PWR:\r\ncase RG_PHY_ED_LEVEL:\r\ncase RG_PHY_CC_CCA:\r\ncase RG_CCA_THRES:\r\ncase RG_RX_CTRL:\r\ncase RG_SFD_VALUE:\r\ncase RG_TRX_CTRL_2:\r\ncase RG_ANT_DIV:\r\ncase RG_IRQ_MASK:\r\ncase RG_VREG_CTRL:\r\ncase RG_BATMON:\r\ncase RG_XOSC_CTRL:\r\ncase RG_RX_SYN:\r\ncase RG_XAH_CTRL_1:\r\ncase RG_FTN_CTRL:\r\ncase RG_PLL_CF:\r\ncase RG_PLL_DCU:\r\ncase RG_SHORT_ADDR_0:\r\ncase RG_SHORT_ADDR_1:\r\ncase RG_PAN_ID_0:\r\ncase RG_PAN_ID_1:\r\ncase RG_IEEE_ADDR_0:\r\ncase RG_IEEE_ADDR_1:\r\ncase RG_IEEE_ADDR_2:\r\ncase RG_IEEE_ADDR_3:\r\ncase RG_IEEE_ADDR_4:\r\ncase RG_IEEE_ADDR_5:\r\ncase RG_IEEE_ADDR_6:\r\ncase RG_IEEE_ADDR_7:\r\ncase RG_XAH_CTRL_0:\r\ncase RG_CSMA_SEED_0:\r\ncase RG_CSMA_SEED_1:\r\ncase RG_CSMA_BE:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool\r\nat86rf230_reg_readable(struct device *dev, unsigned int reg)\r\n{\r\nbool rc;\r\nrc = at86rf230_reg_writeable(dev, reg);\r\nif (rc)\r\nreturn rc;\r\nswitch (reg) {\r\ncase RG_TRX_STATUS:\r\ncase RG_PHY_RSSI:\r\ncase RG_IRQ_STATUS:\r\ncase RG_PART_NUM:\r\ncase RG_VERSION_NUM:\r\ncase RG_MAN_ID_1:\r\ncase RG_MAN_ID_0:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool\r\nat86rf230_reg_volatile(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase RG_TRX_STATUS:\r\ncase RG_TRX_STATE:\r\ncase RG_PHY_RSSI:\r\ncase RG_PHY_ED_LEVEL:\r\ncase RG_IRQ_STATUS:\r\ncase RG_VREG_CTRL:\r\ncase RG_PLL_CF:\r\ncase RG_PLL_DCU:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool\r\nat86rf230_reg_precious(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase RG_IRQ_STATUS:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic void\r\nat86rf230_async_error_recover_complete(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\nif (ctx->free)\r\nkfree(ctx);\r\nieee802154_wake_queue(lp->hw);\r\n}\r\nstatic void\r\nat86rf230_async_error_recover(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\nlp->is_tx = 0;\r\nat86rf230_async_state_change(lp, ctx, STATE_RX_AACK_ON,\r\nat86rf230_async_error_recover_complete);\r\n}\r\nstatic inline void\r\nat86rf230_async_error(struct at86rf230_local *lp,\r\nstruct at86rf230_state_change *ctx, int rc)\r\n{\r\ndev_err(&lp->spi->dev, "spi_async error %d\n", rc);\r\nat86rf230_async_state_change(lp, ctx, STATE_FORCE_TRX_OFF,\r\nat86rf230_async_error_recover);\r\n}\r\nstatic void\r\nat86rf230_async_read_reg(struct at86rf230_local *lp, u8 reg,\r\nstruct at86rf230_state_change *ctx,\r\nvoid (*complete)(void *context))\r\n{\r\nint rc;\r\nu8 *tx_buf = ctx->buf;\r\ntx_buf[0] = (reg & CMD_REG_MASK) | CMD_REG;\r\nctx->msg.complete = complete;\r\nrc = spi_async(lp->spi, &ctx->msg);\r\nif (rc)\r\nat86rf230_async_error(lp, ctx, rc);\r\n}\r\nstatic void\r\nat86rf230_async_write_reg(struct at86rf230_local *lp, u8 reg, u8 val,\r\nstruct at86rf230_state_change *ctx,\r\nvoid (*complete)(void *context))\r\n{\r\nint rc;\r\nctx->buf[0] = (reg & CMD_REG_MASK) | CMD_REG | CMD_WRITE;\r\nctx->buf[1] = val;\r\nctx->msg.complete = complete;\r\nrc = spi_async(lp->spi, &ctx->msg);\r\nif (rc)\r\nat86rf230_async_error(lp, ctx, rc);\r\n}\r\nstatic void\r\nat86rf230_async_state_assert(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\nconst u8 *buf = ctx->buf;\r\nconst u8 trx_state = buf[1] & TRX_STATE_MASK;\r\nif (trx_state != ctx->to_state) {\r\nif (trx_state == STATE_BUSY_RX_AACK) {\r\nif (ctx->to_state == STATE_RX_AACK_ON)\r\ngoto done;\r\nif (ctx->to_state == STATE_TX_ON ||\r\nctx->to_state == STATE_TRX_OFF) {\r\nu8 state = ctx->to_state;\r\nif (lp->tx_retry >= AT86RF2XX_MAX_TX_RETRIES)\r\nstate = STATE_FORCE_TRX_OFF;\r\nlp->tx_retry++;\r\nat86rf230_async_state_change(lp, ctx, state,\r\nctx->complete);\r\nreturn;\r\n}\r\n}\r\ndev_warn(&lp->spi->dev, "unexcept state change from 0x%02x to 0x%02x. Actual state: 0x%02x\n",\r\nctx->from_state, ctx->to_state, trx_state);\r\n}\r\ndone:\r\nif (ctx->complete)\r\nctx->complete(context);\r\n}\r\nstatic enum hrtimer_restart at86rf230_async_state_timer(struct hrtimer *timer)\r\n{\r\nstruct at86rf230_state_change *ctx =\r\ncontainer_of(timer, struct at86rf230_state_change, timer);\r\nstruct at86rf230_local *lp = ctx->lp;\r\nat86rf230_async_read_reg(lp, RG_TRX_STATUS, ctx,\r\nat86rf230_async_state_assert);\r\nreturn HRTIMER_NORESTART;\r\n}\r\nstatic void\r\nat86rf230_async_state_delay(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\nstruct at86rf2xx_chip_data *c = lp->data;\r\nbool force = false;\r\nktime_t tim;\r\nswitch (ctx->to_state) {\r\ncase STATE_FORCE_TX_ON:\r\nctx->to_state = STATE_TX_ON;\r\nforce = true;\r\nbreak;\r\ncase STATE_FORCE_TRX_OFF:\r\nctx->to_state = STATE_TRX_OFF;\r\nforce = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (ctx->from_state) {\r\ncase STATE_TRX_OFF:\r\nswitch (ctx->to_state) {\r\ncase STATE_RX_AACK_ON:\r\ntim = c->t_off_to_aack * NSEC_PER_USEC;\r\nlp->cal_timeout = jiffies + AT86RF2XX_CAL_LOOP_TIMEOUT;\r\ngoto change;\r\ncase STATE_TX_ARET_ON:\r\ncase STATE_TX_ON:\r\ntim = c->t_off_to_tx_on * NSEC_PER_USEC;\r\nlp->cal_timeout = jiffies + AT86RF2XX_CAL_LOOP_TIMEOUT;\r\ngoto change;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase STATE_BUSY_RX_AACK:\r\nswitch (ctx->to_state) {\r\ncase STATE_TRX_OFF:\r\ncase STATE_TX_ON:\r\nif (!force) {\r\ntim = (c->t_frame + c->t_p_ack) * NSEC_PER_USEC;\r\ngoto change;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase STATE_P_ON:\r\nswitch (ctx->to_state) {\r\ncase STATE_TRX_OFF:\r\ntim = c->t_reset_to_off * NSEC_PER_USEC;\r\ngoto change;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nudelay(1);\r\nat86rf230_async_state_timer(&ctx->timer);\r\nreturn;\r\nchange:\r\nhrtimer_start(&ctx->timer, tim, HRTIMER_MODE_REL);\r\n}\r\nstatic void\r\nat86rf230_async_state_change_start(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\nu8 *buf = ctx->buf;\r\nconst u8 trx_state = buf[1] & TRX_STATE_MASK;\r\nif (trx_state == STATE_TRANSITION_IN_PROGRESS) {\r\nudelay(1);\r\nat86rf230_async_read_reg(lp, RG_TRX_STATUS, ctx,\r\nat86rf230_async_state_change_start);\r\nreturn;\r\n}\r\nif (trx_state == ctx->to_state) {\r\nif (ctx->complete)\r\nctx->complete(context);\r\nreturn;\r\n}\r\nctx->from_state = trx_state;\r\nat86rf230_async_write_reg(lp, RG_TRX_STATE, ctx->to_state, ctx,\r\nat86rf230_async_state_delay);\r\n}\r\nstatic void\r\nat86rf230_async_state_change(struct at86rf230_local *lp,\r\nstruct at86rf230_state_change *ctx,\r\nconst u8 state, void (*complete)(void *context))\r\n{\r\nctx->to_state = state;\r\nctx->complete = complete;\r\nat86rf230_async_read_reg(lp, RG_TRX_STATUS, ctx,\r\nat86rf230_async_state_change_start);\r\n}\r\nstatic void\r\nat86rf230_sync_state_change_complete(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\ncomplete(&lp->state_complete);\r\n}\r\nstatic int\r\nat86rf230_sync_state_change(struct at86rf230_local *lp, unsigned int state)\r\n{\r\nunsigned long rc;\r\nat86rf230_async_state_change(lp, &lp->state, state,\r\nat86rf230_sync_state_change_complete);\r\nrc = wait_for_completion_timeout(&lp->state_complete,\r\nmsecs_to_jiffies(100));\r\nif (!rc) {\r\nat86rf230_async_error(lp, &lp->state, -ETIMEDOUT);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nat86rf230_tx_complete(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\nieee802154_xmit_complete(lp->hw, lp->tx_skb, false);\r\nkfree(ctx);\r\n}\r\nstatic void\r\nat86rf230_tx_on(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\nat86rf230_async_state_change(lp, ctx, STATE_RX_AACK_ON,\r\nat86rf230_tx_complete);\r\n}\r\nstatic void\r\nat86rf230_tx_trac_check(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\nif (IS_ENABLED(CONFIG_IEEE802154_AT86RF230_DEBUGFS)) {\r\nu8 trac = TRAC_MASK(ctx->buf[1]);\r\nswitch (trac) {\r\ncase TRAC_SUCCESS:\r\nlp->trac.success++;\r\nbreak;\r\ncase TRAC_SUCCESS_DATA_PENDING:\r\nlp->trac.success_data_pending++;\r\nbreak;\r\ncase TRAC_CHANNEL_ACCESS_FAILURE:\r\nlp->trac.channel_access_failure++;\r\nbreak;\r\ncase TRAC_NO_ACK:\r\nlp->trac.no_ack++;\r\nbreak;\r\ncase TRAC_INVALID:\r\nlp->trac.invalid++;\r\nbreak;\r\ndefault:\r\nWARN_ONCE(1, "received tx trac status %d\n", trac);\r\nbreak;\r\n}\r\n}\r\nat86rf230_async_state_change(lp, ctx, STATE_TX_ON, at86rf230_tx_on);\r\n}\r\nstatic void\r\nat86rf230_rx_read_frame_complete(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\nconst u8 *buf = ctx->buf;\r\nstruct sk_buff *skb;\r\nu8 len, lqi;\r\nlen = buf[1];\r\nif (!ieee802154_is_valid_psdu_len(len)) {\r\ndev_vdbg(&lp->spi->dev, "corrupted frame received\n");\r\nlen = IEEE802154_MTU;\r\n}\r\nlqi = buf[2 + len];\r\nskb = dev_alloc_skb(IEEE802154_MTU);\r\nif (!skb) {\r\ndev_vdbg(&lp->spi->dev, "failed to allocate sk_buff\n");\r\nkfree(ctx);\r\nreturn;\r\n}\r\nmemcpy(skb_put(skb, len), buf + 2, len);\r\nieee802154_rx_irqsafe(lp->hw, skb, lqi);\r\nkfree(ctx);\r\n}\r\nstatic void\r\nat86rf230_rx_trac_check(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\nu8 *buf = ctx->buf;\r\nint rc;\r\nif (IS_ENABLED(CONFIG_IEEE802154_AT86RF230_DEBUGFS)) {\r\nu8 trac = TRAC_MASK(buf[1]);\r\nswitch (trac) {\r\ncase TRAC_SUCCESS:\r\nlp->trac.success++;\r\nbreak;\r\ncase TRAC_SUCCESS_WAIT_FOR_ACK:\r\nlp->trac.success_wait_for_ack++;\r\nbreak;\r\ncase TRAC_INVALID:\r\nlp->trac.invalid++;\r\nbreak;\r\ndefault:\r\nWARN_ONCE(1, "received rx trac status %d\n", trac);\r\nbreak;\r\n}\r\n}\r\nbuf[0] = CMD_FB;\r\nctx->trx.len = AT86RF2XX_MAX_BUF;\r\nctx->msg.complete = at86rf230_rx_read_frame_complete;\r\nrc = spi_async(lp->spi, &ctx->msg);\r\nif (rc) {\r\nctx->trx.len = 2;\r\nat86rf230_async_error(lp, ctx, rc);\r\n}\r\n}\r\nstatic void\r\nat86rf230_irq_trx_end(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\nif (lp->is_tx) {\r\nlp->is_tx = 0;\r\nat86rf230_async_read_reg(lp, RG_TRX_STATE, ctx,\r\nat86rf230_tx_trac_check);\r\n} else {\r\nat86rf230_async_read_reg(lp, RG_TRX_STATE, ctx,\r\nat86rf230_rx_trac_check);\r\n}\r\n}\r\nstatic void\r\nat86rf230_irq_status(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\nconst u8 *buf = ctx->buf;\r\nu8 irq = buf[1];\r\nenable_irq(lp->spi->irq);\r\nif (irq & IRQ_TRX_END) {\r\nat86rf230_irq_trx_end(ctx);\r\n} else {\r\ndev_err(&lp->spi->dev, "not supported irq %02x received\n",\r\nirq);\r\nkfree(ctx);\r\n}\r\n}\r\nstatic void\r\nat86rf230_setup_spi_messages(struct at86rf230_local *lp,\r\nstruct at86rf230_state_change *state)\r\n{\r\nstate->lp = lp;\r\nstate->irq = lp->spi->irq;\r\nspi_message_init(&state->msg);\r\nstate->msg.context = state;\r\nstate->trx.len = 2;\r\nstate->trx.tx_buf = state->buf;\r\nstate->trx.rx_buf = state->buf;\r\nspi_message_add_tail(&state->trx, &state->msg);\r\nhrtimer_init(&state->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\r\nstate->timer.function = at86rf230_async_state_timer;\r\n}\r\nstatic irqreturn_t at86rf230_isr(int irq, void *data)\r\n{\r\nstruct at86rf230_local *lp = data;\r\nstruct at86rf230_state_change *ctx;\r\nint rc;\r\ndisable_irq_nosync(irq);\r\nctx = kzalloc(sizeof(*ctx), GFP_ATOMIC);\r\nif (!ctx) {\r\nenable_irq(irq);\r\nreturn IRQ_NONE;\r\n}\r\nat86rf230_setup_spi_messages(lp, ctx);\r\nctx->free = true;\r\nctx->buf[0] = (RG_IRQ_STATUS & CMD_REG_MASK) | CMD_REG;\r\nctx->msg.complete = at86rf230_irq_status;\r\nrc = spi_async(lp->spi, &ctx->msg);\r\nif (rc) {\r\nat86rf230_async_error(lp, ctx, rc);\r\nenable_irq(irq);\r\nreturn IRQ_NONE;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nat86rf230_write_frame_complete(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\nctx->trx.len = 2;\r\nif (gpio_is_valid(lp->slp_tr))\r\nat86rf230_slp_tr_rising_edge(lp);\r\nelse\r\nat86rf230_async_write_reg(lp, RG_TRX_STATE, STATE_BUSY_TX, ctx,\r\nNULL);\r\n}\r\nstatic void\r\nat86rf230_write_frame(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\nstruct sk_buff *skb = lp->tx_skb;\r\nu8 *buf = ctx->buf;\r\nint rc;\r\nlp->is_tx = 1;\r\nbuf[0] = CMD_FB | CMD_WRITE;\r\nbuf[1] = skb->len + 2;\r\nmemcpy(buf + 2, skb->data, skb->len);\r\nctx->trx.len = skb->len + 2;\r\nctx->msg.complete = at86rf230_write_frame_complete;\r\nrc = spi_async(lp->spi, &ctx->msg);\r\nif (rc) {\r\nctx->trx.len = 2;\r\nat86rf230_async_error(lp, ctx, rc);\r\n}\r\n}\r\nstatic void\r\nat86rf230_xmit_tx_on(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\nat86rf230_async_state_change(lp, ctx, STATE_TX_ARET_ON,\r\nat86rf230_write_frame);\r\n}\r\nstatic void\r\nat86rf230_xmit_start(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\nif (lp->is_tx_from_off)\r\nat86rf230_async_state_change(lp, ctx, STATE_TX_ARET_ON,\r\nat86rf230_write_frame);\r\nelse\r\nat86rf230_async_state_change(lp, ctx, STATE_TX_ON,\r\nat86rf230_xmit_tx_on);\r\n}\r\nstatic int\r\nat86rf230_xmit(struct ieee802154_hw *hw, struct sk_buff *skb)\r\n{\r\nstruct at86rf230_local *lp = hw->priv;\r\nstruct at86rf230_state_change *ctx = &lp->tx;\r\nlp->tx_skb = skb;\r\nlp->tx_retry = 0;\r\nif (time_is_before_jiffies(lp->cal_timeout)) {\r\nlp->is_tx_from_off = true;\r\nat86rf230_async_state_change(lp, ctx, STATE_TRX_OFF,\r\nat86rf230_xmit_start);\r\n} else {\r\nlp->is_tx_from_off = false;\r\nat86rf230_xmit_start(ctx);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nat86rf230_ed(struct ieee802154_hw *hw, u8 *level)\r\n{\r\nBUG_ON(!level);\r\n*level = 0xbe;\r\nreturn 0;\r\n}\r\nstatic int\r\nat86rf230_start(struct ieee802154_hw *hw)\r\n{\r\nstruct at86rf230_local *lp = hw->priv;\r\nif (IS_ENABLED(CONFIG_IEEE802154_AT86RF230_DEBUGFS))\r\nmemset(&lp->trac, 0, sizeof(struct at86rf230_trac));\r\nat86rf230_awake(lp);\r\nenable_irq(lp->spi->irq);\r\nreturn at86rf230_sync_state_change(lp, STATE_RX_AACK_ON);\r\n}\r\nstatic void\r\nat86rf230_stop(struct ieee802154_hw *hw)\r\n{\r\nstruct at86rf230_local *lp = hw->priv;\r\nu8 csma_seed[2];\r\nat86rf230_sync_state_change(lp, STATE_FORCE_TRX_OFF);\r\ndisable_irq(lp->spi->irq);\r\nget_random_bytes(csma_seed, ARRAY_SIZE(csma_seed));\r\nat86rf230_write_subreg(lp, SR_CSMA_SEED_0, csma_seed[0]);\r\nat86rf230_write_subreg(lp, SR_CSMA_SEED_1, csma_seed[1]);\r\nat86rf230_sleep(lp);\r\n}\r\nstatic int\r\nat86rf23x_set_channel(struct at86rf230_local *lp, u8 page, u8 channel)\r\n{\r\nreturn at86rf230_write_subreg(lp, SR_CHANNEL, channel);\r\n}\r\nstatic inline int\r\nat86rf212_update_cca_ed_level(struct at86rf230_local *lp, int rssi_base_val)\r\n{\r\nunsigned int cca_ed_thres;\r\nint rc;\r\nrc = at86rf230_read_subreg(lp, SR_CCA_ED_THRES, &cca_ed_thres);\r\nif (rc < 0)\r\nreturn rc;\r\nswitch (rssi_base_val) {\r\ncase -98:\r\nlp->hw->phy->supported.cca_ed_levels = at86rf212_ed_levels_98;\r\nlp->hw->phy->supported.cca_ed_levels_size = ARRAY_SIZE(at86rf212_ed_levels_98);\r\nlp->hw->phy->cca_ed_level = at86rf212_ed_levels_98[cca_ed_thres];\r\nbreak;\r\ncase -100:\r\nlp->hw->phy->supported.cca_ed_levels = at86rf212_ed_levels_100;\r\nlp->hw->phy->supported.cca_ed_levels_size = ARRAY_SIZE(at86rf212_ed_levels_100);\r\nlp->hw->phy->cca_ed_level = at86rf212_ed_levels_100[cca_ed_thres];\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nat86rf212_set_channel(struct at86rf230_local *lp, u8 page, u8 channel)\r\n{\r\nint rc;\r\nif (channel == 0)\r\nrc = at86rf230_write_subreg(lp, SR_SUB_MODE, 0);\r\nelse\r\nrc = at86rf230_write_subreg(lp, SR_SUB_MODE, 1);\r\nif (rc < 0)\r\nreturn rc;\r\nif (page == 0) {\r\nrc = at86rf230_write_subreg(lp, SR_BPSK_QPSK, 0);\r\nlp->data->rssi_base_val = -100;\r\n} else {\r\nrc = at86rf230_write_subreg(lp, SR_BPSK_QPSK, 1);\r\nlp->data->rssi_base_val = -98;\r\n}\r\nif (rc < 0)\r\nreturn rc;\r\nrc = at86rf212_update_cca_ed_level(lp, lp->data->rssi_base_val);\r\nif (rc < 0)\r\nreturn rc;\r\nif (channel == 0) {\r\nif (page == 0) {\r\nlp->hw->phy->symbol_duration = 50;\r\n} else {\r\nlp->hw->phy->symbol_duration = 25;\r\n}\r\n} else {\r\nif (page == 0)\r\nlp->hw->phy->symbol_duration = 40;\r\nelse\r\nlp->hw->phy->symbol_duration = 16;\r\n}\r\nlp->hw->phy->lifs_period = IEEE802154_LIFS_PERIOD *\r\nlp->hw->phy->symbol_duration;\r\nlp->hw->phy->sifs_period = IEEE802154_SIFS_PERIOD *\r\nlp->hw->phy->symbol_duration;\r\nreturn at86rf230_write_subreg(lp, SR_CHANNEL, channel);\r\n}\r\nstatic int\r\nat86rf230_channel(struct ieee802154_hw *hw, u8 page, u8 channel)\r\n{\r\nstruct at86rf230_local *lp = hw->priv;\r\nint rc;\r\nrc = lp->data->set_channel(lp, page, channel);\r\nusleep_range(lp->data->t_channel_switch,\r\nlp->data->t_channel_switch + 10);\r\nlp->cal_timeout = jiffies + AT86RF2XX_CAL_LOOP_TIMEOUT;\r\nreturn rc;\r\n}\r\nstatic int\r\nat86rf230_set_hw_addr_filt(struct ieee802154_hw *hw,\r\nstruct ieee802154_hw_addr_filt *filt,\r\nunsigned long changed)\r\n{\r\nstruct at86rf230_local *lp = hw->priv;\r\nif (changed & IEEE802154_AFILT_SADDR_CHANGED) {\r\nu16 addr = le16_to_cpu(filt->short_addr);\r\ndev_vdbg(&lp->spi->dev,\r\n"at86rf230_set_hw_addr_filt called for saddr\n");\r\n__at86rf230_write(lp, RG_SHORT_ADDR_0, addr);\r\n__at86rf230_write(lp, RG_SHORT_ADDR_1, addr >> 8);\r\n}\r\nif (changed & IEEE802154_AFILT_PANID_CHANGED) {\r\nu16 pan = le16_to_cpu(filt->pan_id);\r\ndev_vdbg(&lp->spi->dev,\r\n"at86rf230_set_hw_addr_filt called for pan id\n");\r\n__at86rf230_write(lp, RG_PAN_ID_0, pan);\r\n__at86rf230_write(lp, RG_PAN_ID_1, pan >> 8);\r\n}\r\nif (changed & IEEE802154_AFILT_IEEEADDR_CHANGED) {\r\nu8 i, addr[8];\r\nmemcpy(addr, &filt->ieee_addr, 8);\r\ndev_vdbg(&lp->spi->dev,\r\n"at86rf230_set_hw_addr_filt called for IEEE addr\n");\r\nfor (i = 0; i < 8; i++)\r\n__at86rf230_write(lp, RG_IEEE_ADDR_0 + i, addr[i]);\r\n}\r\nif (changed & IEEE802154_AFILT_PANC_CHANGED) {\r\ndev_vdbg(&lp->spi->dev,\r\n"at86rf230_set_hw_addr_filt called for panc change\n");\r\nif (filt->pan_coord)\r\nat86rf230_write_subreg(lp, SR_AACK_I_AM_COORD, 1);\r\nelse\r\nat86rf230_write_subreg(lp, SR_AACK_I_AM_COORD, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nat86rf23x_set_txpower(struct at86rf230_local *lp, s32 mbm)\r\n{\r\nu32 i;\r\nfor (i = 0; i < lp->hw->phy->supported.tx_powers_size; i++) {\r\nif (lp->hw->phy->supported.tx_powers[i] == mbm)\r\nreturn at86rf230_write_subreg(lp, SR_TX_PWR_23X, i);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nat86rf212_set_txpower(struct at86rf230_local *lp, s32 mbm)\r\n{\r\nu32 i;\r\nfor (i = 0; i < lp->hw->phy->supported.tx_powers_size; i++) {\r\nif (lp->hw->phy->supported.tx_powers[i] == mbm)\r\nreturn at86rf230_write_subreg(lp, SR_TX_PWR_212, i);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nat86rf230_set_txpower(struct ieee802154_hw *hw, s32 mbm)\r\n{\r\nstruct at86rf230_local *lp = hw->priv;\r\nreturn lp->data->set_txpower(lp, mbm);\r\n}\r\nstatic int\r\nat86rf230_set_lbt(struct ieee802154_hw *hw, bool on)\r\n{\r\nstruct at86rf230_local *lp = hw->priv;\r\nreturn at86rf230_write_subreg(lp, SR_CSMA_LBT_MODE, on);\r\n}\r\nstatic int\r\nat86rf230_set_cca_mode(struct ieee802154_hw *hw,\r\nconst struct wpan_phy_cca *cca)\r\n{\r\nstruct at86rf230_local *lp = hw->priv;\r\nu8 val;\r\nswitch (cca->mode) {\r\ncase NL802154_CCA_ENERGY:\r\nval = 1;\r\nbreak;\r\ncase NL802154_CCA_CARRIER:\r\nval = 2;\r\nbreak;\r\ncase NL802154_CCA_ENERGY_CARRIER:\r\nswitch (cca->opt) {\r\ncase NL802154_CCA_OPT_ENERGY_CARRIER_AND:\r\nval = 3;\r\nbreak;\r\ncase NL802154_CCA_OPT_ENERGY_CARRIER_OR:\r\nval = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn at86rf230_write_subreg(lp, SR_CCA_MODE, val);\r\n}\r\nstatic int\r\nat86rf230_set_cca_ed_level(struct ieee802154_hw *hw, s32 mbm)\r\n{\r\nstruct at86rf230_local *lp = hw->priv;\r\nu32 i;\r\nfor (i = 0; i < hw->phy->supported.cca_ed_levels_size; i++) {\r\nif (hw->phy->supported.cca_ed_levels[i] == mbm)\r\nreturn at86rf230_write_subreg(lp, SR_CCA_ED_THRES, i);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nat86rf230_set_csma_params(struct ieee802154_hw *hw, u8 min_be, u8 max_be,\r\nu8 retries)\r\n{\r\nstruct at86rf230_local *lp = hw->priv;\r\nint rc;\r\nrc = at86rf230_write_subreg(lp, SR_MIN_BE, min_be);\r\nif (rc)\r\nreturn rc;\r\nrc = at86rf230_write_subreg(lp, SR_MAX_BE, max_be);\r\nif (rc)\r\nreturn rc;\r\nreturn at86rf230_write_subreg(lp, SR_MAX_CSMA_RETRIES, retries);\r\n}\r\nstatic int\r\nat86rf230_set_frame_retries(struct ieee802154_hw *hw, s8 retries)\r\n{\r\nstruct at86rf230_local *lp = hw->priv;\r\nreturn at86rf230_write_subreg(lp, SR_MAX_FRAME_RETRIES, retries);\r\n}\r\nstatic int\r\nat86rf230_set_promiscuous_mode(struct ieee802154_hw *hw, const bool on)\r\n{\r\nstruct at86rf230_local *lp = hw->priv;\r\nint rc;\r\nif (on) {\r\nrc = at86rf230_write_subreg(lp, SR_AACK_DIS_ACK, 1);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = at86rf230_write_subreg(lp, SR_AACK_PROM_MODE, 1);\r\nif (rc < 0)\r\nreturn rc;\r\n} else {\r\nrc = at86rf230_write_subreg(lp, SR_AACK_PROM_MODE, 0);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = at86rf230_write_subreg(lp, SR_AACK_DIS_ACK, 0);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int at86rf230_hw_init(struct at86rf230_local *lp, u8 xtal_trim)\r\n{\r\nint rc, irq_type, irq_pol = IRQ_ACTIVE_HIGH;\r\nunsigned int dvdd;\r\nu8 csma_seed[2];\r\nrc = at86rf230_sync_state_change(lp, STATE_FORCE_TRX_OFF);\r\nif (rc)\r\nreturn rc;\r\nirq_type = irq_get_trigger_type(lp->spi->irq);\r\nif (irq_type == IRQ_TYPE_EDGE_FALLING ||\r\nirq_type == IRQ_TYPE_LEVEL_LOW)\r\nirq_pol = IRQ_ACTIVE_LOW;\r\nrc = at86rf230_write_subreg(lp, SR_IRQ_POLARITY, irq_pol);\r\nif (rc)\r\nreturn rc;\r\nrc = at86rf230_write_subreg(lp, SR_RX_SAFE_MODE, 1);\r\nif (rc)\r\nreturn rc;\r\nrc = at86rf230_write_subreg(lp, SR_IRQ_MASK, IRQ_TRX_END);\r\nif (rc)\r\nreturn rc;\r\nrc = at86rf230_write_subreg(lp, SR_IRQ_MASK_MODE, 0);\r\nif (rc)\r\nreturn rc;\r\nget_random_bytes(csma_seed, ARRAY_SIZE(csma_seed));\r\nrc = at86rf230_write_subreg(lp, SR_CSMA_SEED_0, csma_seed[0]);\r\nif (rc)\r\nreturn rc;\r\nrc = at86rf230_write_subreg(lp, SR_CSMA_SEED_1, csma_seed[1]);\r\nif (rc)\r\nreturn rc;\r\nrc = at86rf230_write_subreg(lp, SR_CLKM_SHA_SEL, 0x00);\r\nif (rc)\r\nreturn rc;\r\nrc = at86rf230_write_subreg(lp, SR_CLKM_CTRL, 0x00);\r\nif (rc)\r\nreturn rc;\r\nusleep_range(lp->data->t_sleep_cycle,\r\nlp->data->t_sleep_cycle + 100);\r\nrc = at86rf230_write_subreg(lp, SR_XTAL_TRIM, xtal_trim);\r\nif (rc)\r\nreturn rc;\r\nrc = at86rf230_read_subreg(lp, SR_DVDD_OK, &dvdd);\r\nif (rc)\r\nreturn rc;\r\nif (!dvdd) {\r\ndev_err(&lp->spi->dev, "DVDD error\n");\r\nreturn -EINVAL;\r\n}\r\nreturn at86rf230_write_subreg(lp, SR_SLOTTED_OPERATION, 0);\r\n}\r\nstatic int\r\nat86rf230_get_pdata(struct spi_device *spi, int *rstn, int *slp_tr,\r\nu8 *xtal_trim)\r\n{\r\nstruct at86rf230_platform_data *pdata = spi->dev.platform_data;\r\nint ret;\r\nif (!IS_ENABLED(CONFIG_OF) || !spi->dev.of_node) {\r\nif (!pdata)\r\nreturn -ENOENT;\r\n*rstn = pdata->rstn;\r\n*slp_tr = pdata->slp_tr;\r\n*xtal_trim = pdata->xtal_trim;\r\nreturn 0;\r\n}\r\n*rstn = of_get_named_gpio(spi->dev.of_node, "reset-gpio", 0);\r\n*slp_tr = of_get_named_gpio(spi->dev.of_node, "sleep-gpio", 0);\r\nret = of_property_read_u8(spi->dev.of_node, "xtal-trim", xtal_trim);\r\nif (ret < 0 && ret != -EINVAL)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int\r\nat86rf230_detect_device(struct at86rf230_local *lp)\r\n{\r\nunsigned int part, version, val;\r\nu16 man_id = 0;\r\nconst char *chip;\r\nint rc;\r\nrc = __at86rf230_read(lp, RG_MAN_ID_0, &val);\r\nif (rc)\r\nreturn rc;\r\nman_id |= val;\r\nrc = __at86rf230_read(lp, RG_MAN_ID_1, &val);\r\nif (rc)\r\nreturn rc;\r\nman_id |= (val << 8);\r\nrc = __at86rf230_read(lp, RG_PART_NUM, &part);\r\nif (rc)\r\nreturn rc;\r\nrc = __at86rf230_read(lp, RG_VERSION_NUM, &version);\r\nif (rc)\r\nreturn rc;\r\nif (man_id != 0x001f) {\r\ndev_err(&lp->spi->dev, "Non-Atmel dev found (MAN_ID %02x %02x)\n",\r\nman_id >> 8, man_id & 0xFF);\r\nreturn -EINVAL;\r\n}\r\nlp->hw->flags = IEEE802154_HW_TX_OMIT_CKSUM |\r\nIEEE802154_HW_CSMA_PARAMS |\r\nIEEE802154_HW_FRAME_RETRIES | IEEE802154_HW_AFILT |\r\nIEEE802154_HW_PROMISCUOUS;\r\nlp->hw->phy->flags = WPAN_PHY_FLAG_TXPOWER |\r\nWPAN_PHY_FLAG_CCA_ED_LEVEL |\r\nWPAN_PHY_FLAG_CCA_MODE;\r\nlp->hw->phy->supported.cca_modes = BIT(NL802154_CCA_ENERGY) |\r\nBIT(NL802154_CCA_CARRIER) | BIT(NL802154_CCA_ENERGY_CARRIER);\r\nlp->hw->phy->supported.cca_opts = BIT(NL802154_CCA_OPT_ENERGY_CARRIER_AND) |\r\nBIT(NL802154_CCA_OPT_ENERGY_CARRIER_OR);\r\nlp->hw->phy->cca.mode = NL802154_CCA_ENERGY;\r\nswitch (part) {\r\ncase 2:\r\nchip = "at86rf230";\r\nrc = -ENOTSUPP;\r\ngoto not_supp;\r\ncase 3:\r\nchip = "at86rf231";\r\nlp->data = &at86rf231_data;\r\nlp->hw->phy->supported.channels[0] = 0x7FFF800;\r\nlp->hw->phy->current_channel = 11;\r\nlp->hw->phy->symbol_duration = 16;\r\nlp->hw->phy->supported.tx_powers = at86rf231_powers;\r\nlp->hw->phy->supported.tx_powers_size = ARRAY_SIZE(at86rf231_powers);\r\nlp->hw->phy->supported.cca_ed_levels = at86rf231_ed_levels;\r\nlp->hw->phy->supported.cca_ed_levels_size = ARRAY_SIZE(at86rf231_ed_levels);\r\nbreak;\r\ncase 7:\r\nchip = "at86rf212";\r\nlp->data = &at86rf212_data;\r\nlp->hw->flags |= IEEE802154_HW_LBT;\r\nlp->hw->phy->supported.channels[0] = 0x00007FF;\r\nlp->hw->phy->supported.channels[2] = 0x00007FF;\r\nlp->hw->phy->current_channel = 5;\r\nlp->hw->phy->symbol_duration = 25;\r\nlp->hw->phy->supported.lbt = NL802154_SUPPORTED_BOOL_BOTH;\r\nlp->hw->phy->supported.tx_powers = at86rf212_powers;\r\nlp->hw->phy->supported.tx_powers_size = ARRAY_SIZE(at86rf212_powers);\r\nlp->hw->phy->supported.cca_ed_levels = at86rf212_ed_levels_100;\r\nlp->hw->phy->supported.cca_ed_levels_size = ARRAY_SIZE(at86rf212_ed_levels_100);\r\nbreak;\r\ncase 11:\r\nchip = "at86rf233";\r\nlp->data = &at86rf233_data;\r\nlp->hw->phy->supported.channels[0] = 0x7FFF800;\r\nlp->hw->phy->current_channel = 13;\r\nlp->hw->phy->symbol_duration = 16;\r\nlp->hw->phy->supported.tx_powers = at86rf233_powers;\r\nlp->hw->phy->supported.tx_powers_size = ARRAY_SIZE(at86rf233_powers);\r\nlp->hw->phy->supported.cca_ed_levels = at86rf233_ed_levels;\r\nlp->hw->phy->supported.cca_ed_levels_size = ARRAY_SIZE(at86rf233_ed_levels);\r\nbreak;\r\ndefault:\r\nchip = "unknown";\r\nrc = -ENOTSUPP;\r\ngoto not_supp;\r\n}\r\nlp->hw->phy->cca_ed_level = lp->hw->phy->supported.cca_ed_levels[7];\r\nlp->hw->phy->transmit_power = lp->hw->phy->supported.tx_powers[0];\r\nnot_supp:\r\ndev_info(&lp->spi->dev, "Detected %s chip version %d\n", chip, version);\r\nreturn rc;\r\n}\r\nstatic int at86rf230_stats_show(struct seq_file *file, void *offset)\r\n{\r\nstruct at86rf230_local *lp = file->private;\r\nseq_printf(file, "SUCCESS:\t\t%8llu\n", lp->trac.success);\r\nseq_printf(file, "SUCCESS_DATA_PENDING:\t%8llu\n",\r\nlp->trac.success_data_pending);\r\nseq_printf(file, "SUCCESS_WAIT_FOR_ACK:\t%8llu\n",\r\nlp->trac.success_wait_for_ack);\r\nseq_printf(file, "CHANNEL_ACCESS_FAILURE:\t%8llu\n",\r\nlp->trac.channel_access_failure);\r\nseq_printf(file, "NO_ACK:\t\t\t%8llu\n", lp->trac.no_ack);\r\nseq_printf(file, "INVALID:\t\t%8llu\n", lp->trac.invalid);\r\nreturn 0;\r\n}\r\nstatic int at86rf230_stats_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, at86rf230_stats_show, inode->i_private);\r\n}\r\nstatic int at86rf230_debugfs_init(struct at86rf230_local *lp)\r\n{\r\nchar debugfs_dir_name[DNAME_INLINE_LEN + 1] = "at86rf230-";\r\nstruct dentry *stats;\r\nstrncat(debugfs_dir_name, dev_name(&lp->spi->dev), DNAME_INLINE_LEN);\r\nat86rf230_debugfs_root = debugfs_create_dir(debugfs_dir_name, NULL);\r\nif (!at86rf230_debugfs_root)\r\nreturn -ENOMEM;\r\nstats = debugfs_create_file("trac_stats", S_IRUGO,\r\nat86rf230_debugfs_root, lp,\r\n&at86rf230_stats_fops);\r\nif (!stats)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void at86rf230_debugfs_remove(void)\r\n{\r\ndebugfs_remove_recursive(at86rf230_debugfs_root);\r\n}\r\nstatic int at86rf230_debugfs_init(struct at86rf230_local *lp) { return 0; }\r\nstatic void at86rf230_debugfs_remove(void) { }\r\nstatic int at86rf230_probe(struct spi_device *spi)\r\n{\r\nstruct ieee802154_hw *hw;\r\nstruct at86rf230_local *lp;\r\nunsigned int status;\r\nint rc, irq_type, rstn, slp_tr;\r\nu8 xtal_trim = 0;\r\nif (!spi->irq) {\r\ndev_err(&spi->dev, "no IRQ specified\n");\r\nreturn -EINVAL;\r\n}\r\nrc = at86rf230_get_pdata(spi, &rstn, &slp_tr, &xtal_trim);\r\nif (rc < 0) {\r\ndev_err(&spi->dev, "failed to parse platform_data: %d\n", rc);\r\nreturn rc;\r\n}\r\nif (gpio_is_valid(rstn)) {\r\nrc = devm_gpio_request_one(&spi->dev, rstn,\r\nGPIOF_OUT_INIT_HIGH, "rstn");\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (gpio_is_valid(slp_tr)) {\r\nrc = devm_gpio_request_one(&spi->dev, slp_tr,\r\nGPIOF_OUT_INIT_LOW, "slp_tr");\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (gpio_is_valid(rstn)) {\r\nudelay(1);\r\ngpio_set_value_cansleep(rstn, 0);\r\nudelay(1);\r\ngpio_set_value_cansleep(rstn, 1);\r\nusleep_range(120, 240);\r\n}\r\nhw = ieee802154_alloc_hw(sizeof(*lp), &at86rf230_ops);\r\nif (!hw)\r\nreturn -ENOMEM;\r\nlp = hw->priv;\r\nlp->hw = hw;\r\nlp->spi = spi;\r\nlp->slp_tr = slp_tr;\r\nhw->parent = &spi->dev;\r\nieee802154_random_extended_addr(&hw->phy->perm_extended_addr);\r\nlp->regmap = devm_regmap_init_spi(spi, &at86rf230_regmap_spi_config);\r\nif (IS_ERR(lp->regmap)) {\r\nrc = PTR_ERR(lp->regmap);\r\ndev_err(&spi->dev, "Failed to allocate register map: %d\n",\r\nrc);\r\ngoto free_dev;\r\n}\r\nat86rf230_setup_spi_messages(lp, &lp->state);\r\nat86rf230_setup_spi_messages(lp, &lp->tx);\r\nrc = at86rf230_detect_device(lp);\r\nif (rc < 0)\r\ngoto free_dev;\r\ninit_completion(&lp->state_complete);\r\nspi_set_drvdata(spi, lp);\r\nrc = at86rf230_hw_init(lp, xtal_trim);\r\nif (rc)\r\ngoto free_dev;\r\nrc = at86rf230_read_subreg(lp, RG_IRQ_STATUS, 0xff, 0, &status);\r\nif (rc)\r\ngoto free_dev;\r\nirq_type = irq_get_trigger_type(spi->irq);\r\nif (!irq_type)\r\nirq_type = IRQF_TRIGGER_HIGH;\r\nrc = devm_request_irq(&spi->dev, spi->irq, at86rf230_isr,\r\nIRQF_SHARED | irq_type, dev_name(&spi->dev), lp);\r\nif (rc)\r\ngoto free_dev;\r\ndisable_irq(spi->irq);\r\nat86rf230_sleep(lp);\r\nrc = at86rf230_debugfs_init(lp);\r\nif (rc)\r\ngoto free_dev;\r\nrc = ieee802154_register_hw(lp->hw);\r\nif (rc)\r\ngoto free_debugfs;\r\nreturn rc;\r\nfree_debugfs:\r\nat86rf230_debugfs_remove();\r\nfree_dev:\r\nieee802154_free_hw(lp->hw);\r\nreturn rc;\r\n}\r\nstatic int at86rf230_remove(struct spi_device *spi)\r\n{\r\nstruct at86rf230_local *lp = spi_get_drvdata(spi);\r\nat86rf230_write_subreg(lp, SR_IRQ_MASK, 0);\r\nieee802154_unregister_hw(lp->hw);\r\nieee802154_free_hw(lp->hw);\r\nat86rf230_debugfs_remove();\r\ndev_dbg(&spi->dev, "unregistered at86rf230\n");\r\nreturn 0;\r\n}
