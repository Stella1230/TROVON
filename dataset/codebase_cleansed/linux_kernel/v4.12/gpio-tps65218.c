static int tps65218_gpio_get(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct tps65218_gpio *tps65218_gpio = gpiochip_get_data(gc);\r\nstruct tps65218 *tps65218 = tps65218_gpio->tps65218;\r\nunsigned int val;\r\nint ret;\r\nret = regmap_read(tps65218->regmap, TPS65218_REG_ENABLE2, &val);\r\nif (ret)\r\nreturn ret;\r\nreturn !!(val & (TPS65218_ENABLE2_GPIO1 << offset));\r\n}\r\nstatic void tps65218_gpio_set(struct gpio_chip *gc, unsigned offset,\r\nint value)\r\n{\r\nstruct tps65218_gpio *tps65218_gpio = gpiochip_get_data(gc);\r\nstruct tps65218 *tps65218 = tps65218_gpio->tps65218;\r\nif (value)\r\ntps65218_set_bits(tps65218, TPS65218_REG_ENABLE2,\r\nTPS65218_ENABLE2_GPIO1 << offset,\r\nTPS65218_ENABLE2_GPIO1 << offset,\r\nTPS65218_PROTECT_L1);\r\nelse\r\ntps65218_clear_bits(tps65218, TPS65218_REG_ENABLE2,\r\nTPS65218_ENABLE2_GPIO1 << offset,\r\nTPS65218_PROTECT_L1);\r\n}\r\nstatic int tps65218_gpio_output(struct gpio_chip *gc, unsigned offset,\r\nint value)\r\n{\r\ntps65218_gpio_set(gc, offset, value);\r\nreturn 0;\r\n}\r\nstatic int tps65218_gpio_input(struct gpio_chip *gc, unsigned offset)\r\n{\r\nreturn -EPERM;\r\n}\r\nstatic int tps65218_gpio_request(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct tps65218_gpio *tps65218_gpio = gpiochip_get_data(gc);\r\nstruct tps65218 *tps65218 = tps65218_gpio->tps65218;\r\nint ret;\r\nif (gpiochip_line_is_open_source(gc, offset)) {\r\ndev_err(gc->parent, "can't work as open source\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (offset) {\r\ncase 0:\r\nif (!gpiochip_line_is_open_drain(gc, offset)) {\r\ndev_err(gc->parent, "GPO1 works only as open drain\n");\r\nreturn -EINVAL;\r\n}\r\nret = tps65218_clear_bits(tps65218, TPS65218_REG_SEQ7,\r\nTPS65218_SEQ7_GPO1_SEQ_MASK,\r\nTPS65218_PROTECT_L1);\r\nif (ret)\r\nreturn ret;\r\nret = tps65218_clear_bits(tps65218, TPS65218_REG_CONFIG1,\r\nTPS65218_CONFIG1_IO1_SEL,\r\nTPS65218_PROTECT_L1);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase 1:\r\nret = tps65218_clear_bits(tps65218, TPS65218_REG_CONFIG1,\r\nTPS65218_CONFIG1_IO1_SEL,\r\nTPS65218_PROTECT_L1);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase 2:\r\nif (!gpiochip_line_is_open_drain(gc, offset)) {\r\ndev_err(gc->parent, "GPO3 works only as open drain\n");\r\nreturn -EINVAL;\r\n}\r\nret = tps65218_clear_bits(tps65218, TPS65218_REG_SEQ7,\r\nTPS65218_SEQ7_GPO3_SEQ_MASK,\r\nTPS65218_PROTECT_L1);\r\nif (ret)\r\nreturn ret;\r\nret = tps65218_clear_bits(tps65218, TPS65218_REG_CONFIG2,\r\nTPS65218_CONFIG2_DC12_RST,\r\nTPS65218_PROTECT_L1);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tps65218_gpio_set_config(struct gpio_chip *gc, unsigned offset,\r\nunsigned long config)\r\n{\r\nstruct tps65218_gpio *tps65218_gpio = gpiochip_get_data(gc);\r\nstruct tps65218 *tps65218 = tps65218_gpio->tps65218;\r\nenum pin_config_param param = pinconf_to_config_param(config);\r\nswitch (offset) {\r\ncase 0:\r\ncase 2:\r\nif (param == PIN_CONFIG_DRIVE_OPEN_DRAIN)\r\nreturn 0;\r\nreturn -ENOTSUPP;\r\ncase 1:\r\nif (param == PIN_CONFIG_DRIVE_OPEN_DRAIN)\r\nreturn tps65218_clear_bits(tps65218,\r\nTPS65218_REG_CONFIG1,\r\nTPS65218_CONFIG1_GPO2_BUF,\r\nTPS65218_PROTECT_L1);\r\nif (param == PIN_CONFIG_DRIVE_PUSH_PULL)\r\nreturn tps65218_set_bits(tps65218,\r\nTPS65218_REG_CONFIG1,\r\nTPS65218_CONFIG1_GPO2_BUF,\r\nTPS65218_CONFIG1_GPO2_BUF,\r\nTPS65218_PROTECT_L1);\r\nreturn -ENOTSUPP;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int tps65218_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct tps65218 *tps65218 = dev_get_drvdata(pdev->dev.parent);\r\nstruct tps65218_gpio *tps65218_gpio;\r\nint ret;\r\ntps65218_gpio = devm_kzalloc(&pdev->dev, sizeof(*tps65218_gpio),\r\nGFP_KERNEL);\r\nif (!tps65218_gpio)\r\nreturn -ENOMEM;\r\ntps65218_gpio->tps65218 = tps65218;\r\ntps65218_gpio->gpio_chip = template_chip;\r\ntps65218_gpio->gpio_chip.parent = &pdev->dev;\r\n#ifdef CONFIG_OF_GPIO\r\ntps65218_gpio->gpio_chip.of_node = pdev->dev.of_node;\r\n#endif\r\nret = devm_gpiochip_add_data(&pdev->dev, &tps65218_gpio->gpio_chip,\r\ntps65218_gpio);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to register gpiochip, %d\n", ret);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, tps65218_gpio);\r\nreturn ret;\r\n}
