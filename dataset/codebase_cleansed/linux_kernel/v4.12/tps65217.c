static void tps65217_irq_lock(struct irq_data *data)\r\n{\r\nstruct tps65217 *tps = irq_data_get_irq_chip_data(data);\r\nmutex_lock(&tps->irq_lock);\r\n}\r\nstatic void tps65217_irq_sync_unlock(struct irq_data *data)\r\n{\r\nstruct tps65217 *tps = irq_data_get_irq_chip_data(data);\r\nint ret;\r\nret = tps65217_set_bits(tps, TPS65217_REG_INT, TPS65217_INT_MASK,\r\ntps->irq_mask, TPS65217_PROTECT_NONE);\r\nif (ret != 0)\r\ndev_err(tps->dev, "Failed to sync IRQ masks\n");\r\nmutex_unlock(&tps->irq_lock);\r\n}\r\nstatic void tps65217_irq_enable(struct irq_data *data)\r\n{\r\nstruct tps65217 *tps = irq_data_get_irq_chip_data(data);\r\nu8 mask = BIT(data->hwirq) << TPS65217_INT_SHIFT;\r\ntps->irq_mask &= ~mask;\r\n}\r\nstatic void tps65217_irq_disable(struct irq_data *data)\r\n{\r\nstruct tps65217 *tps = irq_data_get_irq_chip_data(data);\r\nu8 mask = BIT(data->hwirq) << TPS65217_INT_SHIFT;\r\ntps->irq_mask |= mask;\r\n}\r\nstatic irqreturn_t tps65217_irq_thread(int irq, void *data)\r\n{\r\nstruct tps65217 *tps = data;\r\nunsigned int status;\r\nbool handled = false;\r\nint i;\r\nint ret;\r\nret = tps65217_reg_read(tps, TPS65217_REG_INT, &status);\r\nif (ret < 0) {\r\ndev_err(tps->dev, "Failed to read IRQ status: %d\n",\r\nret);\r\nreturn IRQ_NONE;\r\n}\r\nfor (i = 0; i < TPS65217_NUM_IRQ; i++) {\r\nif (status & BIT(i)) {\r\nhandle_nested_irq(irq_find_mapping(tps->irq_domain, i));\r\nhandled = true;\r\n}\r\n}\r\nif (handled)\r\nreturn IRQ_HANDLED;\r\nreturn IRQ_NONE;\r\n}\r\nstatic int tps65217_irq_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nstruct tps65217 *tps = h->host_data;\r\nirq_set_chip_data(virq, tps);\r\nirq_set_chip_and_handler(virq, &tps65217_irq_chip, handle_edge_irq);\r\nirq_set_nested_thread(virq, 1);\r\nirq_set_parent(virq, tps->irq);\r\nirq_set_noprobe(virq);\r\nreturn 0;\r\n}\r\nstatic int tps65217_irq_init(struct tps65217 *tps, int irq)\r\n{\r\nint ret;\r\nmutex_init(&tps->irq_lock);\r\ntps->irq = irq;\r\ntps->irq_mask = TPS65217_INT_MASK;\r\ntps65217_set_bits(tps, TPS65217_REG_INT, TPS65217_INT_MASK,\r\nTPS65217_INT_MASK, TPS65217_PROTECT_NONE);\r\ntps->irq_domain = irq_domain_add_linear(tps->dev->of_node,\r\nTPS65217_NUM_IRQ, &tps65217_irq_domain_ops, tps);\r\nif (!tps->irq_domain) {\r\ndev_err(tps->dev, "Could not create IRQ domain\n");\r\nreturn -ENOMEM;\r\n}\r\nret = devm_request_threaded_irq(tps->dev, irq, NULL,\r\ntps65217_irq_thread, IRQF_ONESHOT,\r\n"tps65217-irq", tps);\r\nif (ret) {\r\ndev_err(tps->dev, "Failed to request IRQ %d: %d\n",\r\nirq, ret);\r\nreturn ret;\r\n}\r\nenable_irq_wake(irq);\r\nreturn 0;\r\n}\r\nint tps65217_reg_read(struct tps65217 *tps, unsigned int reg,\r\nunsigned int *val)\r\n{\r\nreturn regmap_read(tps->regmap, reg, val);\r\n}\r\nint tps65217_reg_write(struct tps65217 *tps, unsigned int reg,\r\nunsigned int val, unsigned int level)\r\n{\r\nint ret;\r\nunsigned int xor_reg_val;\r\nswitch (level) {\r\ncase TPS65217_PROTECT_NONE:\r\nreturn regmap_write(tps->regmap, reg, val);\r\ncase TPS65217_PROTECT_L1:\r\nxor_reg_val = reg ^ TPS65217_PASSWORD_REGS_UNLOCK;\r\nret = regmap_write(tps->regmap, TPS65217_REG_PASSWORD,\r\nxor_reg_val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn regmap_write(tps->regmap, reg, val);\r\ncase TPS65217_PROTECT_L2:\r\nxor_reg_val = reg ^ TPS65217_PASSWORD_REGS_UNLOCK;\r\nret = regmap_write(tps->regmap, TPS65217_REG_PASSWORD,\r\nxor_reg_val);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_write(tps->regmap, reg, val);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_write(tps->regmap, TPS65217_REG_PASSWORD,\r\nxor_reg_val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn regmap_write(tps->regmap, reg, val);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int tps65217_update_bits(struct tps65217 *tps, unsigned int reg,\r\nunsigned int mask, unsigned int val, unsigned int level)\r\n{\r\nint ret;\r\nunsigned int data;\r\nret = tps65217_reg_read(tps, reg, &data);\r\nif (ret) {\r\ndev_err(tps->dev, "Read from reg 0x%x failed\n", reg);\r\nreturn ret;\r\n}\r\ndata &= ~mask;\r\ndata |= val & mask;\r\nret = tps65217_reg_write(tps, reg, data, level);\r\nif (ret)\r\ndev_err(tps->dev, "Write for reg 0x%x failed\n", reg);\r\nreturn ret;\r\n}\r\nint tps65217_set_bits(struct tps65217 *tps, unsigned int reg,\r\nunsigned int mask, unsigned int val, unsigned int level)\r\n{\r\nreturn tps65217_update_bits(tps, reg, mask, val, level);\r\n}\r\nint tps65217_clear_bits(struct tps65217 *tps, unsigned int reg,\r\nunsigned int mask, unsigned int level)\r\n{\r\nreturn tps65217_update_bits(tps, reg, mask, 0, level);\r\n}\r\nstatic bool tps65217_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase TPS65217_REG_INT:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int tps65217_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *ids)\r\n{\r\nstruct tps65217 *tps;\r\nunsigned int version;\r\nunsigned long chip_id = ids->driver_data;\r\nconst struct of_device_id *match;\r\nbool status_off = false;\r\nint ret;\r\nif (client->dev.of_node) {\r\nmatch = of_match_device(tps65217_of_match, &client->dev);\r\nif (!match) {\r\ndev_err(&client->dev,\r\n"Failed to find matching dt id\n");\r\nreturn -EINVAL;\r\n}\r\nchip_id = (unsigned long)match->data;\r\nstatus_off = of_property_read_bool(client->dev.of_node,\r\n"ti,pmic-shutdown-controller");\r\n}\r\nif (!chip_id) {\r\ndev_err(&client->dev, "id is null.\n");\r\nreturn -ENODEV;\r\n}\r\ntps = devm_kzalloc(&client->dev, sizeof(*tps), GFP_KERNEL);\r\nif (!tps)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, tps);\r\ntps->dev = &client->dev;\r\ntps->id = chip_id;\r\ntps->regmap = devm_regmap_init_i2c(client, &tps65217_regmap_config);\r\nif (IS_ERR(tps->regmap)) {\r\nret = PTR_ERR(tps->regmap);\r\ndev_err(tps->dev, "Failed to allocate register map: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nif (client->irq) {\r\ntps65217_irq_init(tps, client->irq);\r\n} else {\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(tps65217s); i++)\r\ntps65217s[i].num_resources = 0;\r\n}\r\nret = devm_mfd_add_devices(tps->dev, -1, tps65217s,\r\nARRAY_SIZE(tps65217s), NULL, 0,\r\ntps->irq_domain);\r\nif (ret < 0) {\r\ndev_err(tps->dev, "mfd_add_devices failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = tps65217_reg_read(tps, TPS65217_REG_CHIPID, &version);\r\nif (ret < 0) {\r\ndev_err(tps->dev, "Failed to read revision register: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nif (status_off) {\r\nret = tps65217_set_bits(tps, TPS65217_REG_STATUS,\r\nTPS65217_STATUS_OFF, TPS65217_STATUS_OFF,\r\nTPS65217_PROTECT_NONE);\r\nif (ret)\r\ndev_warn(tps->dev, "unable to set the status OFF\n");\r\n}\r\ndev_info(tps->dev, "TPS65217 ID %#x version 1.%d\n",\r\n(version & TPS65217_CHIPID_CHIP_MASK) >> 4,\r\nversion & TPS65217_CHIPID_REV_MASK);\r\nreturn 0;\r\n}\r\nstatic int tps65217_remove(struct i2c_client *client)\r\n{\r\nstruct tps65217 *tps = i2c_get_clientdata(client);\r\nunsigned int virq;\r\nint i;\r\nfor (i = 0; i < TPS65217_NUM_IRQ; i++) {\r\nvirq = irq_find_mapping(tps->irq_domain, i);\r\nif (virq)\r\nirq_dispose_mapping(virq);\r\n}\r\nirq_domain_remove(tps->irq_domain);\r\ntps->irq_domain = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init tps65217_init(void)\r\n{\r\nreturn i2c_add_driver(&tps65217_driver);\r\n}\r\nstatic void __exit tps65217_exit(void)\r\n{\r\ni2c_del_driver(&tps65217_driver);\r\n}
