static int rtl8723au_parse_efuse(struct rtl8xxxu_priv *priv)\r\n{\r\nstruct rtl8723au_efuse *efuse = &priv->efuse_wifi.efuse8723;\r\nif (efuse->rtl_id != cpu_to_le16(0x8129))\r\nreturn -EINVAL;\r\nether_addr_copy(priv->mac_addr, efuse->mac_addr);\r\nmemcpy(priv->cck_tx_power_index_A,\r\nefuse->cck_tx_power_index_A,\r\nsizeof(efuse->cck_tx_power_index_A));\r\nmemcpy(priv->cck_tx_power_index_B,\r\nefuse->cck_tx_power_index_B,\r\nsizeof(efuse->cck_tx_power_index_B));\r\nmemcpy(priv->ht40_1s_tx_power_index_A,\r\nefuse->ht40_1s_tx_power_index_A,\r\nsizeof(efuse->ht40_1s_tx_power_index_A));\r\nmemcpy(priv->ht40_1s_tx_power_index_B,\r\nefuse->ht40_1s_tx_power_index_B,\r\nsizeof(efuse->ht40_1s_tx_power_index_B));\r\nmemcpy(priv->ht20_tx_power_index_diff,\r\nefuse->ht20_tx_power_index_diff,\r\nsizeof(efuse->ht20_tx_power_index_diff));\r\nmemcpy(priv->ofdm_tx_power_index_diff,\r\nefuse->ofdm_tx_power_index_diff,\r\nsizeof(efuse->ofdm_tx_power_index_diff));\r\nmemcpy(priv->ht40_max_power_offset,\r\nefuse->ht40_max_power_offset,\r\nsizeof(efuse->ht40_max_power_offset));\r\nmemcpy(priv->ht20_max_power_offset,\r\nefuse->ht20_max_power_offset,\r\nsizeof(efuse->ht20_max_power_offset));\r\nif (priv->efuse_wifi.efuse8723.version >= 0x01) {\r\npriv->has_xtalk = 1;\r\npriv->xtalk = priv->efuse_wifi.efuse8723.xtal_k & 0x3f;\r\n}\r\npriv->power_base = &rtl8723a_power_base;\r\ndev_info(&priv->udev->dev, "Vendor: %.7s\n",\r\nefuse->vendor_name);\r\ndev_info(&priv->udev->dev, "Product: %.41s\n",\r\nefuse->device_name);\r\nreturn 0;\r\n}\r\nstatic int rtl8723au_load_firmware(struct rtl8xxxu_priv *priv)\r\n{\r\nchar *fw_name;\r\nint ret;\r\nswitch (priv->chip_cut) {\r\ncase 0:\r\nfw_name = "rtlwifi/rtl8723aufw_A.bin";\r\nbreak;\r\ncase 1:\r\nif (priv->enable_bluetooth)\r\nfw_name = "rtlwifi/rtl8723aufw_B.bin";\r\nelse\r\nfw_name = "rtlwifi/rtl8723aufw_B_NoBT.bin";\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = rtl8xxxu_load_firmware(priv, fw_name);\r\nreturn ret;\r\n}\r\nstatic int rtl8723au_init_phy_rf(struct rtl8xxxu_priv *priv)\r\n{\r\nint ret;\r\nret = rtl8xxxu_init_phy_rf(priv, rtl8723au_radioa_1t_init_table, RF_A);\r\nrtl8xxxu_write32(priv, REG_AFE_XTAL_CTRL, 0x0381808d);\r\nrtl8xxxu_write32(priv, REG_AFE_PLL_CTRL, 0xf0ffff83);\r\nrtl8xxxu_write32(priv, REG_AFE_PLL_CTRL, 0xf0ffff82);\r\nrtl8xxxu_write32(priv, REG_AFE_PLL_CTRL, 0xf0ffff83);\r\nreturn ret;\r\n}\r\nstatic int rtl8723a_emu_to_active(struct rtl8xxxu_priv *priv)\r\n{\r\nu8 val8;\r\nu32 val32;\r\nint count, ret = 0;\r\nval8 = rtl8xxxu_read8(priv, REG_LDOA15_CTRL);\r\nval8 |= LDOA15_ENABLE;\r\nrtl8xxxu_write8(priv, REG_LDOA15_CTRL, val8);\r\nval8 = rtl8xxxu_read8(priv, 0x0067);\r\nval8 &= ~BIT(4);\r\nrtl8xxxu_write8(priv, 0x0067, val8);\r\nmdelay(1);\r\nval8 = rtl8xxxu_read8(priv, REG_SYS_ISO_CTRL);\r\nval8 &= ~SYS_ISO_ANALOG_IPS;\r\nrtl8xxxu_write8(priv, REG_SYS_ISO_CTRL, val8);\r\nval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\r\nval8 &= ~BIT(2);\r\nrtl8xxxu_write8(priv, REG_APS_FSMCO + 1, val8);\r\nfor (count = RTL8XXXU_MAX_REG_POLL; count; count--) {\r\nval32 = rtl8xxxu_read32(priv, REG_APS_FSMCO);\r\nif (val32 & BIT(17))\r\nbreak;\r\nudelay(10);\r\n}\r\nif (!count) {\r\nret = -EBUSY;\r\ngoto exit;\r\n}\r\nval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 2);\r\nval8 |= BIT(0);\r\nrtl8xxxu_write8(priv, REG_APS_FSMCO + 2, val8);\r\nval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\r\nval8 &= ~BIT(7);\r\nrtl8xxxu_write8(priv, REG_APS_FSMCO + 1, val8);\r\nval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\r\nval8 &= ~(BIT(3) | BIT(4));\r\nrtl8xxxu_write8(priv, REG_APS_FSMCO + 1, val8);\r\nval32 = rtl8xxxu_read32(priv, REG_APS_FSMCO);\r\nval32 |= APS_FSMCO_MAC_ENABLE;\r\nrtl8xxxu_write32(priv, REG_APS_FSMCO, val32);\r\nfor (count = RTL8XXXU_MAX_REG_POLL; count; count--) {\r\nval32 = rtl8xxxu_read32(priv, REG_APS_FSMCO);\r\nif ((val32 & APS_FSMCO_MAC_ENABLE) == 0) {\r\nret = 0;\r\nbreak;\r\n}\r\nudelay(10);\r\n}\r\nif (!count) {\r\nret = -EBUSY;\r\ngoto exit;\r\n}\r\nval8 = rtl8xxxu_read8(priv, REG_LEDCFG2);\r\nval8 |= LEDCFG2_DPDT_SELECT;\r\nval8 &= ~LEDCFG2_DPDT_SELECT;\r\nrtl8xxxu_write8(priv, REG_LEDCFG2, val8);\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int rtl8723au_power_on(struct rtl8xxxu_priv *priv)\r\n{\r\nu8 val8;\r\nu16 val16;\r\nu32 val32;\r\nint ret;\r\nrtl8xxxu_write8(priv, REG_RSV_CTRL, 0x0);\r\nrtl8xxxu_disabled_to_emu(priv);\r\nret = rtl8723a_emu_to_active(priv);\r\nif (ret)\r\ngoto exit;\r\nval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 2);\r\nval8 |= BIT(3);\r\nrtl8xxxu_write8(priv, REG_APS_FSMCO + 2, val8);\r\nval16 = rtl8xxxu_read16(priv, REG_CR);\r\nval16 |= (CR_HCI_TXDMA_ENABLE | CR_HCI_RXDMA_ENABLE |\r\nCR_TXDMA_ENABLE | CR_RXDMA_ENABLE |\r\nCR_PROTOCOL_ENABLE | CR_SCHEDULE_ENABLE |\r\nCR_MAC_TX_ENABLE | CR_MAC_RX_ENABLE |\r\nCR_SECURITY_ENABLE | CR_CALTIMER_ENABLE);\r\nrtl8xxxu_write16(priv, REG_CR, val16);\r\nval32 = rtl8xxxu_read32(priv, REG_EFUSE_CTRL);\r\nval32 &= ~(BIT(28) | BIT(29) | BIT(30));\r\nval32 |= (0x06 << 28);\r\nrtl8xxxu_write32(priv, REG_EFUSE_CTRL, val32);\r\nexit:\r\nreturn ret;\r\n}
