static inline void e100_write_flush(struct nic *nic)\r\n{\r\n(void)ioread8(&nic->csr->scb.status);\r\n}\r\nstatic void e100_enable_irq(struct nic *nic)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&nic->cmd_lock, flags);\r\niowrite8(irq_mask_none, &nic->csr->scb.cmd_hi);\r\ne100_write_flush(nic);\r\nspin_unlock_irqrestore(&nic->cmd_lock, flags);\r\n}\r\nstatic void e100_disable_irq(struct nic *nic)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&nic->cmd_lock, flags);\r\niowrite8(irq_mask_all, &nic->csr->scb.cmd_hi);\r\ne100_write_flush(nic);\r\nspin_unlock_irqrestore(&nic->cmd_lock, flags);\r\n}\r\nstatic void e100_hw_reset(struct nic *nic)\r\n{\r\niowrite32(selective_reset, &nic->csr->port);\r\ne100_write_flush(nic); udelay(20);\r\niowrite32(software_reset, &nic->csr->port);\r\ne100_write_flush(nic); udelay(20);\r\ne100_disable_irq(nic);\r\n}\r\nstatic int e100_self_test(struct nic *nic)\r\n{\r\nu32 dma_addr = nic->dma_addr + offsetof(struct mem, selftest);\r\nnic->mem->selftest.signature = 0;\r\nnic->mem->selftest.result = 0xFFFFFFFF;\r\niowrite32(selftest | dma_addr, &nic->csr->port);\r\ne100_write_flush(nic);\r\nmsleep(10);\r\ne100_disable_irq(nic);\r\nif (nic->mem->selftest.result != 0) {\r\nnetif_err(nic, hw, nic->netdev,\r\n"Self-test failed: result=0x%08X\n",\r\nnic->mem->selftest.result);\r\nreturn -ETIMEDOUT;\r\n}\r\nif (nic->mem->selftest.signature == 0) {\r\nnetif_err(nic, hw, nic->netdev, "Self-test failed: timed out\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void e100_eeprom_write(struct nic *nic, u16 addr_len, u16 addr, __le16 data)\r\n{\r\nu32 cmd_addr_data[3];\r\nu8 ctrl;\r\nint i, j;\r\ncmd_addr_data[0] = op_ewen << (addr_len - 2);\r\ncmd_addr_data[1] = (((op_write << addr_len) | addr) << 16) |\r\nle16_to_cpu(data);\r\ncmd_addr_data[2] = op_ewds << (addr_len - 2);\r\nfor (j = 0; j < 3; j++) {\r\niowrite8(eecs | eesk, &nic->csr->eeprom_ctrl_lo);\r\ne100_write_flush(nic); udelay(4);\r\nfor (i = 31; i >= 0; i--) {\r\nctrl = (cmd_addr_data[j] & (1 << i)) ?\r\neecs | eedi : eecs;\r\niowrite8(ctrl, &nic->csr->eeprom_ctrl_lo);\r\ne100_write_flush(nic); udelay(4);\r\niowrite8(ctrl | eesk, &nic->csr->eeprom_ctrl_lo);\r\ne100_write_flush(nic); udelay(4);\r\n}\r\nmsleep(10);\r\niowrite8(0, &nic->csr->eeprom_ctrl_lo);\r\ne100_write_flush(nic); udelay(4);\r\n}\r\n}\r\nstatic __le16 e100_eeprom_read(struct nic *nic, u16 *addr_len, u16 addr)\r\n{\r\nu32 cmd_addr_data;\r\nu16 data = 0;\r\nu8 ctrl;\r\nint i;\r\ncmd_addr_data = ((op_read << *addr_len) | addr) << 16;\r\niowrite8(eecs | eesk, &nic->csr->eeprom_ctrl_lo);\r\ne100_write_flush(nic); udelay(4);\r\nfor (i = 31; i >= 0; i--) {\r\nctrl = (cmd_addr_data & (1 << i)) ? eecs | eedi : eecs;\r\niowrite8(ctrl, &nic->csr->eeprom_ctrl_lo);\r\ne100_write_flush(nic); udelay(4);\r\niowrite8(ctrl | eesk, &nic->csr->eeprom_ctrl_lo);\r\ne100_write_flush(nic); udelay(4);\r\nctrl = ioread8(&nic->csr->eeprom_ctrl_lo);\r\nif (!(ctrl & eedo) && i > 16) {\r\n*addr_len -= (i - 16);\r\ni = 17;\r\n}\r\ndata = (data << 1) | (ctrl & eedo ? 1 : 0);\r\n}\r\niowrite8(0, &nic->csr->eeprom_ctrl_lo);\r\ne100_write_flush(nic); udelay(4);\r\nreturn cpu_to_le16(data);\r\n}\r\nstatic int e100_eeprom_load(struct nic *nic)\r\n{\r\nu16 addr, addr_len = 8, checksum = 0;\r\ne100_eeprom_read(nic, &addr_len, 0);\r\nnic->eeprom_wc = 1 << addr_len;\r\nfor (addr = 0; addr < nic->eeprom_wc; addr++) {\r\nnic->eeprom[addr] = e100_eeprom_read(nic, &addr_len, addr);\r\nif (addr < nic->eeprom_wc - 1)\r\nchecksum += le16_to_cpu(nic->eeprom[addr]);\r\n}\r\nif (cpu_to_le16(0xBABA - checksum) != nic->eeprom[nic->eeprom_wc - 1]) {\r\nnetif_err(nic, probe, nic->netdev, "EEPROM corrupted\n");\r\nif (!eeprom_bad_csum_allow)\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic int e100_eeprom_save(struct nic *nic, u16 start, u16 count)\r\n{\r\nu16 addr, addr_len = 8, checksum = 0;\r\ne100_eeprom_read(nic, &addr_len, 0);\r\nnic->eeprom_wc = 1 << addr_len;\r\nif (start + count >= nic->eeprom_wc)\r\nreturn -EINVAL;\r\nfor (addr = start; addr < start + count; addr++)\r\ne100_eeprom_write(nic, addr_len, addr, nic->eeprom[addr]);\r\nfor (addr = 0; addr < nic->eeprom_wc - 1; addr++)\r\nchecksum += le16_to_cpu(nic->eeprom[addr]);\r\nnic->eeprom[nic->eeprom_wc - 1] = cpu_to_le16(0xBABA - checksum);\r\ne100_eeprom_write(nic, addr_len, nic->eeprom_wc - 1,\r\nnic->eeprom[nic->eeprom_wc - 1]);\r\nreturn 0;\r\n}\r\nstatic int e100_exec_cmd(struct nic *nic, u8 cmd, dma_addr_t dma_addr)\r\n{\r\nunsigned long flags;\r\nunsigned int i;\r\nint err = 0;\r\nspin_lock_irqsave(&nic->cmd_lock, flags);\r\nfor (i = 0; i < E100_WAIT_SCB_TIMEOUT; i++) {\r\nif (likely(!ioread8(&nic->csr->scb.cmd_lo)))\r\nbreak;\r\ncpu_relax();\r\nif (unlikely(i > E100_WAIT_SCB_FAST))\r\nudelay(5);\r\n}\r\nif (unlikely(i == E100_WAIT_SCB_TIMEOUT)) {\r\nerr = -EAGAIN;\r\ngoto err_unlock;\r\n}\r\nif (unlikely(cmd != cuc_resume))\r\niowrite32(dma_addr, &nic->csr->scb.gen_ptr);\r\niowrite8(cmd, &nic->csr->scb.cmd_lo);\r\nerr_unlock:\r\nspin_unlock_irqrestore(&nic->cmd_lock, flags);\r\nreturn err;\r\n}\r\nstatic int e100_exec_cb(struct nic *nic, struct sk_buff *skb,\r\nint (*cb_prepare)(struct nic *, struct cb *, struct sk_buff *))\r\n{\r\nstruct cb *cb;\r\nunsigned long flags;\r\nint err;\r\nspin_lock_irqsave(&nic->cb_lock, flags);\r\nif (unlikely(!nic->cbs_avail)) {\r\nerr = -ENOMEM;\r\ngoto err_unlock;\r\n}\r\ncb = nic->cb_to_use;\r\nnic->cb_to_use = cb->next;\r\nnic->cbs_avail--;\r\ncb->skb = skb;\r\nerr = cb_prepare(nic, cb, skb);\r\nif (err)\r\ngoto err_unlock;\r\nif (unlikely(!nic->cbs_avail))\r\nerr = -ENOSPC;\r\ncb->command |= cpu_to_le16(cb_s);\r\ndma_wmb();\r\ncb->prev->command &= cpu_to_le16(~cb_s);\r\nwhile (nic->cb_to_send != nic->cb_to_use) {\r\nif (unlikely(e100_exec_cmd(nic, nic->cuc_cmd,\r\nnic->cb_to_send->dma_addr))) {\r\nif (err == -ENOSPC) {\r\nschedule_work(&nic->tx_timeout_task);\r\n}\r\nbreak;\r\n} else {\r\nnic->cuc_cmd = cuc_resume;\r\nnic->cb_to_send = nic->cb_to_send->next;\r\n}\r\n}\r\nerr_unlock:\r\nspin_unlock_irqrestore(&nic->cb_lock, flags);\r\nreturn err;\r\n}\r\nstatic int mdio_read(struct net_device *netdev, int addr, int reg)\r\n{\r\nstruct nic *nic = netdev_priv(netdev);\r\nreturn nic->mdio_ctrl(nic, addr, mdi_read, reg, 0);\r\n}\r\nstatic void mdio_write(struct net_device *netdev, int addr, int reg, int data)\r\n{\r\nstruct nic *nic = netdev_priv(netdev);\r\nnic->mdio_ctrl(nic, addr, mdi_write, reg, data);\r\n}\r\nstatic u16 mdio_ctrl_hw(struct nic *nic, u32 addr, u32 dir, u32 reg, u16 data)\r\n{\r\nu32 data_out = 0;\r\nunsigned int i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&nic->mdio_lock, flags);\r\nfor (i = 100; i; --i) {\r\nif (ioread32(&nic->csr->mdi_ctrl) & mdi_ready)\r\nbreak;\r\nudelay(20);\r\n}\r\nif (unlikely(!i)) {\r\nnetdev_err(nic->netdev, "e100.mdio_ctrl won't go Ready\n");\r\nspin_unlock_irqrestore(&nic->mdio_lock, flags);\r\nreturn 0;\r\n}\r\niowrite32((reg << 16) | (addr << 21) | dir | data, &nic->csr->mdi_ctrl);\r\nfor (i = 0; i < 100; i++) {\r\nudelay(20);\r\nif ((data_out = ioread32(&nic->csr->mdi_ctrl)) & mdi_ready)\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&nic->mdio_lock, flags);\r\nnetif_printk(nic, hw, KERN_DEBUG, nic->netdev,\r\n"%s:addr=%d, reg=%d, data_in=0x%04X, data_out=0x%04X\n",\r\ndir == mdi_read ? "READ" : "WRITE",\r\naddr, reg, data, data_out);\r\nreturn (u16)data_out;\r\n}\r\nstatic u16 mdio_ctrl_phy_82552_v(struct nic *nic,\r\nu32 addr,\r\nu32 dir,\r\nu32 reg,\r\nu16 data)\r\n{\r\nif ((reg == MII_BMCR) && (dir == mdi_write)) {\r\nif (data & (BMCR_ANRESTART | BMCR_ANENABLE)) {\r\nu16 advert = mdio_read(nic->netdev, nic->mii.phy_id,\r\nMII_ADVERTISE);\r\nif (advert & ADVERTISE_100FULL)\r\ndata |= BMCR_SPEED100 | BMCR_FULLDPLX;\r\nelse if (advert & ADVERTISE_100HALF)\r\ndata |= BMCR_SPEED100;\r\n}\r\n}\r\nreturn mdio_ctrl_hw(nic, addr, dir, reg, data);\r\n}\r\nstatic u16 mdio_ctrl_phy_mii_emulated(struct nic *nic,\r\nu32 addr,\r\nu32 dir,\r\nu32 reg,\r\nu16 data)\r\n{\r\nif (dir == mdi_read) {\r\nswitch (reg) {\r\ncase MII_BMCR:\r\nreturn BMCR_ANENABLE |\r\nBMCR_FULLDPLX;\r\ncase MII_BMSR:\r\nreturn BMSR_LSTATUS |\r\nBMSR_ANEGCAPABLE |\r\nBMSR_10FULL;\r\ncase MII_ADVERTISE:\r\nreturn ADVERTISE_10HALF |\r\nADVERTISE_10FULL;\r\ndefault:\r\nnetif_printk(nic, hw, KERN_DEBUG, nic->netdev,\r\n"%s:addr=%d, reg=%d, data=0x%04X: unimplemented emulation!\n",\r\ndir == mdi_read ? "READ" : "WRITE",\r\naddr, reg, data);\r\nreturn 0xFFFF;\r\n}\r\n} else {\r\nswitch (reg) {\r\ndefault:\r\nnetif_printk(nic, hw, KERN_DEBUG, nic->netdev,\r\n"%s:addr=%d, reg=%d, data=0x%04X: unimplemented emulation!\n",\r\ndir == mdi_read ? "READ" : "WRITE",\r\naddr, reg, data);\r\nreturn 0xFFFF;\r\n}\r\n}\r\n}\r\nstatic inline int e100_phy_supports_mii(struct nic *nic)\r\n{\r\nreturn (nic->mdio_ctrl != mdio_ctrl_phy_mii_emulated);\r\n}\r\nstatic void e100_get_defaults(struct nic *nic)\r\n{\r\nstruct param_range rfds = { .min = 16, .max = 256, .count = 256 };\r\nstruct param_range cbs = { .min = 64, .max = 256, .count = 128 };\r\nnic->mac = (nic->flags & ich) ? mac_82559_D101M : nic->pdev->revision;\r\nif (nic->mac == mac_unknown)\r\nnic->mac = mac_82557_D100_A;\r\nnic->params.rfds = rfds;\r\nnic->params.cbs = cbs;\r\nnic->tx_threshold = 0xE0;\r\nnic->tx_command = cpu_to_le16(cb_tx | cb_tx_sf |\r\n((nic->mac >= mac_82558_D101_A4) ? cb_cid : cb_i));\r\nnic->blank_rfd.command = 0;\r\nnic->blank_rfd.rbd = cpu_to_le32(0xFFFFFFFF);\r\nnic->blank_rfd.size = cpu_to_le16(VLAN_ETH_FRAME_LEN + ETH_FCS_LEN);\r\nnic->mii.phy_id_mask = 0x1F;\r\nnic->mii.reg_num_mask = 0x1F;\r\nnic->mii.dev = nic->netdev;\r\nnic->mii.mdio_read = mdio_read;\r\nnic->mii.mdio_write = mdio_write;\r\n}\r\nstatic int e100_configure(struct nic *nic, struct cb *cb, struct sk_buff *skb)\r\n{\r\nstruct config *config = &cb->u.config;\r\nu8 *c = (u8 *)config;\r\nstruct net_device *netdev = nic->netdev;\r\ncb->command = cpu_to_le16(cb_config);\r\nmemset(config, 0, sizeof(struct config));\r\nconfig->byte_count = 0x16;\r\nconfig->rx_fifo_limit = 0x8;\r\nconfig->direct_rx_dma = 0x1;\r\nconfig->standard_tcb = 0x1;\r\nconfig->standard_stat_counter = 0x1;\r\nconfig->rx_discard_short_frames = 0x1;\r\nconfig->tx_underrun_retry = 0x3;\r\nif (e100_phy_supports_mii(nic))\r\nconfig->mii_mode = 1;\r\nconfig->pad10 = 0x6;\r\nconfig->no_source_addr_insertion = 0x1;\r\nconfig->preamble_length = 0x2;\r\nconfig->ifs = 0x6;\r\nconfig->ip_addr_hi = 0xF2;\r\nconfig->pad15_1 = 0x1;\r\nconfig->pad15_2 = 0x1;\r\nconfig->crs_or_cdt = 0x0;\r\nconfig->fc_delay_hi = 0x40;\r\nconfig->tx_padding = 0x1;\r\nconfig->fc_priority_threshold = 0x7;\r\nconfig->pad18 = 0x1;\r\nconfig->full_duplex_pin = 0x1;\r\nconfig->pad20_1 = 0x1F;\r\nconfig->fc_priority_location = 0x1;\r\nconfig->pad21_1 = 0x5;\r\nconfig->adaptive_ifs = nic->adaptive_ifs;\r\nconfig->loopback = nic->loopback;\r\nif (nic->mii.force_media && nic->mii.full_duplex)\r\nconfig->full_duplex_force = 0x1;\r\nif (nic->flags & promiscuous || nic->loopback) {\r\nconfig->rx_save_bad_frames = 0x1;\r\nconfig->rx_discard_short_frames = 0x0;\r\nconfig->promiscuous_mode = 0x1;\r\n}\r\nif (unlikely(netdev->features & NETIF_F_RXFCS))\r\nconfig->rx_crc_transfer = 0x1;\r\nif (nic->flags & multicast_all)\r\nconfig->multicast_all = 0x1;\r\nif (netif_running(nic->netdev) || !(nic->flags & wol_magic))\r\nconfig->magic_packet_disable = 0x1;\r\nif (nic->mac >= mac_82558_D101_A4) {\r\nconfig->fc_disable = 0x1;\r\nconfig->mwi_enable = 0x1;\r\nconfig->standard_tcb = 0x0;\r\nconfig->rx_long_ok = 0x1;\r\nif (nic->mac >= mac_82559_D101M) {\r\nconfig->tno_intr = 0x1;\r\nif (nic->mac >= mac_82551_10) {\r\nconfig->byte_count = 0x20;\r\nconfig->rx_d102_mode = 0x1;\r\n}\r\n} else {\r\nconfig->standard_stat_counter = 0x0;\r\n}\r\n}\r\nif (netdev->features & NETIF_F_RXALL) {\r\nconfig->rx_save_overruns = 0x1;\r\nconfig->rx_save_bad_frames = 0x1;\r\nconfig->rx_discard_short_frames = 0x0;\r\n}\r\nnetif_printk(nic, hw, KERN_DEBUG, nic->netdev, "[00-07]=%8ph\n",\r\nc + 0);\r\nnetif_printk(nic, hw, KERN_DEBUG, nic->netdev, "[08-15]=%8ph\n",\r\nc + 8);\r\nnetif_printk(nic, hw, KERN_DEBUG, nic->netdev, "[16-23]=%8ph\n",\r\nc + 16);\r\nreturn 0;\r\n}\r\nstatic const struct firmware *e100_request_firmware(struct nic *nic)\r\n{\r\nconst char *fw_name;\r\nconst struct firmware *fw = nic->fw;\r\nu8 timer, bundle, min_size;\r\nint err = 0;\r\nbool required = false;\r\nif (nic->flags & ich)\r\nreturn NULL;\r\nif (nic->mac == mac_82559_D101M) {\r\nfw_name = FIRMWARE_D101M;\r\n} else if (nic->mac == mac_82559_D101S) {\r\nfw_name = FIRMWARE_D101S;\r\n} else if (nic->mac == mac_82551_F || nic->mac == mac_82551_10) {\r\nfw_name = FIRMWARE_D102E;\r\nrequired = true;\r\n} else {\r\nreturn NULL;\r\n}\r\nif (!fw)\r\nerr = request_firmware(&fw, fw_name, &nic->pdev->dev);\r\nif (err) {\r\nif (required) {\r\nnetif_err(nic, probe, nic->netdev,\r\n"Failed to load firmware \"%s\": %d\n",\r\nfw_name, err);\r\nreturn ERR_PTR(err);\r\n} else {\r\nnetif_info(nic, probe, nic->netdev,\r\n"CPUSaver disabled. Needs \"%s\": %d\n",\r\nfw_name, err);\r\nreturn NULL;\r\n}\r\n}\r\nif (fw->size != UCODE_SIZE * 4 + 3) {\r\nnetif_err(nic, probe, nic->netdev,\r\n"Firmware \"%s\" has wrong size %zu\n",\r\nfw_name, fw->size);\r\nrelease_firmware(fw);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ntimer = fw->data[UCODE_SIZE * 4];\r\nbundle = fw->data[UCODE_SIZE * 4 + 1];\r\nmin_size = fw->data[UCODE_SIZE * 4 + 2];\r\nif (timer >= UCODE_SIZE || bundle >= UCODE_SIZE ||\r\nmin_size >= UCODE_SIZE) {\r\nnetif_err(nic, probe, nic->netdev,\r\n"\"%s\" has bogus offset values (0x%x,0x%x,0x%x)\n",\r\nfw_name, timer, bundle, min_size);\r\nrelease_firmware(fw);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nnic->fw = fw;\r\nreturn fw;\r\n}\r\nstatic int e100_setup_ucode(struct nic *nic, struct cb *cb,\r\nstruct sk_buff *skb)\r\n{\r\nconst struct firmware *fw = (void *)skb;\r\nu8 timer, bundle, min_size;\r\ncb->skb = NULL;\r\nmemcpy(cb->u.ucode, fw->data, UCODE_SIZE * 4);\r\ntimer = fw->data[UCODE_SIZE * 4];\r\nbundle = fw->data[UCODE_SIZE * 4 + 1];\r\nmin_size = fw->data[UCODE_SIZE * 4 + 2];\r\ncb->u.ucode[timer] &= cpu_to_le32(0xFFFF0000);\r\ncb->u.ucode[timer] |= cpu_to_le32(INTDELAY);\r\ncb->u.ucode[bundle] &= cpu_to_le32(0xFFFF0000);\r\ncb->u.ucode[bundle] |= cpu_to_le32(BUNDLEMAX);\r\ncb->u.ucode[min_size] &= cpu_to_le32(0xFFFF0000);\r\ncb->u.ucode[min_size] |= cpu_to_le32((BUNDLESMALL) ? 0xFFFF : 0xFF80);\r\ncb->command = cpu_to_le16(cb_ucode | cb_el);\r\nreturn 0;\r\n}\r\nstatic inline int e100_load_ucode_wait(struct nic *nic)\r\n{\r\nconst struct firmware *fw;\r\nint err = 0, counter = 50;\r\nstruct cb *cb = nic->cb_to_clean;\r\nfw = e100_request_firmware(nic);\r\nif (!fw || IS_ERR(fw))\r\nreturn PTR_ERR(fw);\r\nif ((err = e100_exec_cb(nic, (void *)fw, e100_setup_ucode)))\r\nnetif_err(nic, probe, nic->netdev,\r\n"ucode cmd failed with error %d\n", err);\r\nnic->cuc_cmd = cuc_start;\r\ne100_write_flush(nic);\r\nudelay(10);\r\nwhile (!(cb->status & cpu_to_le16(cb_complete))) {\r\nmsleep(10);\r\nif (!--counter) break;\r\n}\r\niowrite8(~0, &nic->csr->scb.stat_ack);\r\nif (!counter || !(cb->status & cpu_to_le16(cb_ok))) {\r\nnetif_err(nic, probe, nic->netdev, "ucode load failed\n");\r\nerr = -EPERM;\r\n}\r\nreturn err;\r\n}\r\nstatic int e100_setup_iaaddr(struct nic *nic, struct cb *cb,\r\nstruct sk_buff *skb)\r\n{\r\ncb->command = cpu_to_le16(cb_iaaddr);\r\nmemcpy(cb->u.iaaddr, nic->netdev->dev_addr, ETH_ALEN);\r\nreturn 0;\r\n}\r\nstatic int e100_dump(struct nic *nic, struct cb *cb, struct sk_buff *skb)\r\n{\r\ncb->command = cpu_to_le16(cb_dump);\r\ncb->u.dump_buffer_addr = cpu_to_le32(nic->dma_addr +\r\noffsetof(struct mem, dump_buf));\r\nreturn 0;\r\n}\r\nstatic int e100_phy_check_without_mii(struct nic *nic)\r\n{\r\nu8 phy_type;\r\nint without_mii;\r\nphy_type = (nic->eeprom[eeprom_phy_iface] >> 8) & 0x0f;\r\nswitch (phy_type) {\r\ncase NoSuchPhy:\r\ncase I82503:\r\ncase S80C24:\r\nnetif_info(nic, probe, nic->netdev,\r\n"found MII-less i82503 or 80c24 or other PHY\n");\r\nnic->mdio_ctrl = mdio_ctrl_phy_mii_emulated;\r\nnic->mii.phy_id = 0;\r\nwithout_mii = 1;\r\nbreak;\r\ndefault:\r\nwithout_mii = 0;\r\nbreak;\r\n}\r\nreturn without_mii;\r\n}\r\nstatic int e100_phy_init(struct nic *nic)\r\n{\r\nstruct net_device *netdev = nic->netdev;\r\nu32 addr;\r\nu16 bmcr, stat, id_lo, id_hi, cong;\r\nfor (addr = 0; addr < 32; addr++) {\r\nnic->mii.phy_id = (addr == 0) ? 1 : (addr == 1) ? 0 : addr;\r\nbmcr = mdio_read(netdev, nic->mii.phy_id, MII_BMCR);\r\nstat = mdio_read(netdev, nic->mii.phy_id, MII_BMSR);\r\nstat = mdio_read(netdev, nic->mii.phy_id, MII_BMSR);\r\nif (!((bmcr == 0xFFFF) || ((stat == 0) && (bmcr == 0))))\r\nbreak;\r\n}\r\nif (addr == 32) {\r\nif (e100_phy_check_without_mii(nic))\r\nreturn 0;\r\nelse {\r\nnetif_err(nic, hw, nic->netdev,\r\n"Failed to locate any known PHY, aborting\n");\r\nreturn -EAGAIN;\r\n}\r\n} else\r\nnetif_printk(nic, hw, KERN_DEBUG, nic->netdev,\r\n"phy_addr = %d\n", nic->mii.phy_id);\r\nid_lo = mdio_read(netdev, nic->mii.phy_id, MII_PHYSID1);\r\nid_hi = mdio_read(netdev, nic->mii.phy_id, MII_PHYSID2);\r\nnic->phy = (u32)id_hi << 16 | (u32)id_lo;\r\nnetif_printk(nic, hw, KERN_DEBUG, nic->netdev,\r\n"phy ID = 0x%08X\n", nic->phy);\r\nfor (addr = 0; addr < 32; addr++) {\r\nif (addr != nic->mii.phy_id) {\r\nmdio_write(netdev, addr, MII_BMCR, BMCR_ISOLATE);\r\n} else if (nic->phy != phy_82552_v) {\r\nbmcr = mdio_read(netdev, addr, MII_BMCR);\r\nmdio_write(netdev, addr, MII_BMCR,\r\nbmcr & ~BMCR_ISOLATE);\r\n}\r\n}\r\nif (nic->phy == phy_82552_v)\r\nmdio_write(netdev, nic->mii.phy_id, MII_BMCR,\r\nbmcr & ~BMCR_ISOLATE);\r\n#define NCS_PHY_MODEL_MASK 0xFFF0FFFF\r\nif ((nic->phy & NCS_PHY_MODEL_MASK) == phy_nsc_tx) {\r\ncong = mdio_read(netdev, nic->mii.phy_id, MII_NSC_CONG);\r\ncong |= NSC_CONG_TXREADY;\r\ncong &= ~NSC_CONG_ENABLE;\r\nmdio_write(netdev, nic->mii.phy_id, MII_NSC_CONG, cong);\r\n}\r\nif (nic->phy == phy_82552_v) {\r\nu16 advert = mdio_read(netdev, nic->mii.phy_id, MII_ADVERTISE);\r\nnic->mdio_ctrl = mdio_ctrl_phy_82552_v;\r\nadvert |= ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;\r\nmdio_write(netdev, nic->mii.phy_id, MII_ADVERTISE, advert);\r\nbmcr = mdio_read(netdev, nic->mii.phy_id, MII_BMCR);\r\nbmcr |= BMCR_RESET;\r\nmdio_write(netdev, nic->mii.phy_id, MII_BMCR, bmcr);\r\n} else if ((nic->mac >= mac_82550_D102) || ((nic->flags & ich) &&\r\n(mdio_read(netdev, nic->mii.phy_id, MII_TPISTATUS) & 0x8000) &&\r\n(nic->eeprom[eeprom_cnfg_mdix] & eeprom_mdix_enabled))) {\r\nmdio_write(netdev, nic->mii.phy_id, MII_NCONFIG,\r\nnic->mii.force_media ? 0 : NCONFIG_AUTO_SWITCH);\r\n}\r\nreturn 0;\r\n}\r\nstatic int e100_hw_init(struct nic *nic)\r\n{\r\nint err = 0;\r\ne100_hw_reset(nic);\r\nnetif_err(nic, hw, nic->netdev, "e100_hw_init\n");\r\nif (!in_interrupt() && (err = e100_self_test(nic)))\r\nreturn err;\r\nif ((err = e100_phy_init(nic)))\r\nreturn err;\r\nif ((err = e100_exec_cmd(nic, cuc_load_base, 0)))\r\nreturn err;\r\nif ((err = e100_exec_cmd(nic, ruc_load_base, 0)))\r\nreturn err;\r\nif ((err = e100_load_ucode_wait(nic)))\r\nreturn err;\r\nif ((err = e100_exec_cb(nic, NULL, e100_configure)))\r\nreturn err;\r\nif ((err = e100_exec_cb(nic, NULL, e100_setup_iaaddr)))\r\nreturn err;\r\nif ((err = e100_exec_cmd(nic, cuc_dump_addr,\r\nnic->dma_addr + offsetof(struct mem, stats))))\r\nreturn err;\r\nif ((err = e100_exec_cmd(nic, cuc_dump_reset, 0)))\r\nreturn err;\r\ne100_disable_irq(nic);\r\nreturn 0;\r\n}\r\nstatic int e100_multi(struct nic *nic, struct cb *cb, struct sk_buff *skb)\r\n{\r\nstruct net_device *netdev = nic->netdev;\r\nstruct netdev_hw_addr *ha;\r\nu16 i, count = min(netdev_mc_count(netdev), E100_MAX_MULTICAST_ADDRS);\r\ncb->command = cpu_to_le16(cb_multi);\r\ncb->u.multi.count = cpu_to_le16(count * ETH_ALEN);\r\ni = 0;\r\nnetdev_for_each_mc_addr(ha, netdev) {\r\nif (i == count)\r\nbreak;\r\nmemcpy(&cb->u.multi.addr[i++ * ETH_ALEN], &ha->addr,\r\nETH_ALEN);\r\n}\r\nreturn 0;\r\n}\r\nstatic void e100_set_multicast_list(struct net_device *netdev)\r\n{\r\nstruct nic *nic = netdev_priv(netdev);\r\nnetif_printk(nic, hw, KERN_DEBUG, nic->netdev,\r\n"mc_count=%d, flags=0x%04X\n",\r\nnetdev_mc_count(netdev), netdev->flags);\r\nif (netdev->flags & IFF_PROMISC)\r\nnic->flags |= promiscuous;\r\nelse\r\nnic->flags &= ~promiscuous;\r\nif (netdev->flags & IFF_ALLMULTI ||\r\nnetdev_mc_count(netdev) > E100_MAX_MULTICAST_ADDRS)\r\nnic->flags |= multicast_all;\r\nelse\r\nnic->flags &= ~multicast_all;\r\ne100_exec_cb(nic, NULL, e100_configure);\r\ne100_exec_cb(nic, NULL, e100_multi);\r\n}\r\nstatic void e100_update_stats(struct nic *nic)\r\n{\r\nstruct net_device *dev = nic->netdev;\r\nstruct net_device_stats *ns = &dev->stats;\r\nstruct stats *s = &nic->mem->stats;\r\n__le32 *complete = (nic->mac < mac_82558_D101_A4) ? &s->fc_xmt_pause :\r\n(nic->mac < mac_82559_D101M) ? (__le32 *)&s->xmt_tco_frames :\r\n&s->complete;\r\nif (*complete == cpu_to_le32(cuc_dump_reset_complete)) {\r\n*complete = 0;\r\nnic->tx_frames = le32_to_cpu(s->tx_good_frames);\r\nnic->tx_collisions = le32_to_cpu(s->tx_total_collisions);\r\nns->tx_aborted_errors += le32_to_cpu(s->tx_max_collisions);\r\nns->tx_window_errors += le32_to_cpu(s->tx_late_collisions);\r\nns->tx_carrier_errors += le32_to_cpu(s->tx_lost_crs);\r\nns->tx_fifo_errors += le32_to_cpu(s->tx_underruns);\r\nns->collisions += nic->tx_collisions;\r\nns->tx_errors += le32_to_cpu(s->tx_max_collisions) +\r\nle32_to_cpu(s->tx_lost_crs);\r\nnic->rx_short_frame_errors +=\r\nle32_to_cpu(s->rx_short_frame_errors);\r\nns->rx_length_errors = nic->rx_short_frame_errors +\r\nnic->rx_over_length_errors;\r\nns->rx_crc_errors += le32_to_cpu(s->rx_crc_errors);\r\nns->rx_frame_errors += le32_to_cpu(s->rx_alignment_errors);\r\nns->rx_over_errors += le32_to_cpu(s->rx_overrun_errors);\r\nns->rx_fifo_errors += le32_to_cpu(s->rx_overrun_errors);\r\nns->rx_missed_errors += le32_to_cpu(s->rx_resource_errors);\r\nns->rx_errors += le32_to_cpu(s->rx_crc_errors) +\r\nle32_to_cpu(s->rx_alignment_errors) +\r\nle32_to_cpu(s->rx_short_frame_errors) +\r\nle32_to_cpu(s->rx_cdt_errors);\r\nnic->tx_deferred += le32_to_cpu(s->tx_deferred);\r\nnic->tx_single_collisions +=\r\nle32_to_cpu(s->tx_single_collisions);\r\nnic->tx_multiple_collisions +=\r\nle32_to_cpu(s->tx_multiple_collisions);\r\nif (nic->mac >= mac_82558_D101_A4) {\r\nnic->tx_fc_pause += le32_to_cpu(s->fc_xmt_pause);\r\nnic->rx_fc_pause += le32_to_cpu(s->fc_rcv_pause);\r\nnic->rx_fc_unsupported +=\r\nle32_to_cpu(s->fc_rcv_unsupported);\r\nif (nic->mac >= mac_82559_D101M) {\r\nnic->tx_tco_frames +=\r\nle16_to_cpu(s->xmt_tco_frames);\r\nnic->rx_tco_frames +=\r\nle16_to_cpu(s->rcv_tco_frames);\r\n}\r\n}\r\n}\r\nif (e100_exec_cmd(nic, cuc_dump_reset, 0))\r\nnetif_printk(nic, tx_err, KERN_DEBUG, nic->netdev,\r\n"exec cuc_dump_reset failed\n");\r\n}\r\nstatic void e100_adjust_adaptive_ifs(struct nic *nic, int speed, int duplex)\r\n{\r\nif (duplex == DUPLEX_HALF) {\r\nu32 prev = nic->adaptive_ifs;\r\nu32 min_frames = (speed == SPEED_100) ? 1000 : 100;\r\nif ((nic->tx_frames / 32 < nic->tx_collisions) &&\r\n(nic->tx_frames > min_frames)) {\r\nif (nic->adaptive_ifs < 60)\r\nnic->adaptive_ifs += 5;\r\n} else if (nic->tx_frames < min_frames) {\r\nif (nic->adaptive_ifs >= 5)\r\nnic->adaptive_ifs -= 5;\r\n}\r\nif (nic->adaptive_ifs != prev)\r\ne100_exec_cb(nic, NULL, e100_configure);\r\n}\r\n}\r\nstatic void e100_watchdog(unsigned long data)\r\n{\r\nstruct nic *nic = (struct nic *)data;\r\nstruct ethtool_cmd cmd = { .cmd = ETHTOOL_GSET };\r\nu32 speed;\r\nnetif_printk(nic, timer, KERN_DEBUG, nic->netdev,\r\n"right now = %ld\n", jiffies);\r\nmii_ethtool_gset(&nic->mii, &cmd);\r\nspeed = ethtool_cmd_speed(&cmd);\r\nif (mii_link_ok(&nic->mii) && !netif_carrier_ok(nic->netdev)) {\r\nnetdev_info(nic->netdev, "NIC Link is Up %u Mbps %s Duplex\n",\r\nspeed == SPEED_100 ? 100 : 10,\r\ncmd.duplex == DUPLEX_FULL ? "Full" : "Half");\r\n} else if (!mii_link_ok(&nic->mii) && netif_carrier_ok(nic->netdev)) {\r\nnetdev_info(nic->netdev, "NIC Link is Down\n");\r\n}\r\nmii_check_link(&nic->mii);\r\nspin_lock_irq(&nic->cmd_lock);\r\niowrite8(ioread8(&nic->csr->scb.cmd_hi) | irq_sw_gen,&nic->csr->scb.cmd_hi);\r\ne100_write_flush(nic);\r\nspin_unlock_irq(&nic->cmd_lock);\r\ne100_update_stats(nic);\r\ne100_adjust_adaptive_ifs(nic, speed, cmd.duplex);\r\nif (nic->mac <= mac_82557_D100_C)\r\ne100_set_multicast_list(nic->netdev);\r\nif (nic->flags & ich && speed == SPEED_10 && cmd.duplex == DUPLEX_HALF)\r\nnic->flags |= ich_10h_workaround;\r\nelse\r\nnic->flags &= ~ich_10h_workaround;\r\nmod_timer(&nic->watchdog,\r\nround_jiffies(jiffies + E100_WATCHDOG_PERIOD));\r\n}\r\nstatic int e100_xmit_prepare(struct nic *nic, struct cb *cb,\r\nstruct sk_buff *skb)\r\n{\r\ndma_addr_t dma_addr;\r\ncb->command = nic->tx_command;\r\ndma_addr = pci_map_single(nic->pdev,\r\nskb->data, skb->len, PCI_DMA_TODEVICE);\r\nif (pci_dma_mapping_error(nic->pdev, dma_addr)) {\r\ndev_kfree_skb_any(skb);\r\nskb = NULL;\r\nreturn -ENOMEM;\r\n}\r\nif (unlikely(skb->no_fcs))\r\ncb->command |= cpu_to_le16(cb_tx_nc);\r\nelse\r\ncb->command &= ~cpu_to_le16(cb_tx_nc);\r\nif ((nic->cbs_avail & ~15) == nic->cbs_avail)\r\ncb->command |= cpu_to_le16(cb_i);\r\ncb->u.tcb.tbd_array = cb->dma_addr + offsetof(struct cb, u.tcb.tbd);\r\ncb->u.tcb.tcb_byte_count = 0;\r\ncb->u.tcb.threshold = nic->tx_threshold;\r\ncb->u.tcb.tbd_count = 1;\r\ncb->u.tcb.tbd.buf_addr = cpu_to_le32(dma_addr);\r\ncb->u.tcb.tbd.size = cpu_to_le16(skb->len);\r\nskb_tx_timestamp(skb);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t e100_xmit_frame(struct sk_buff *skb,\r\nstruct net_device *netdev)\r\n{\r\nstruct nic *nic = netdev_priv(netdev);\r\nint err;\r\nif (nic->flags & ich_10h_workaround) {\r\nif (e100_exec_cmd(nic, cuc_nop, 0))\r\nnetif_printk(nic, tx_err, KERN_DEBUG, nic->netdev,\r\n"exec cuc_nop failed\n");\r\nudelay(1);\r\n}\r\nerr = e100_exec_cb(nic, skb, e100_xmit_prepare);\r\nswitch (err) {\r\ncase -ENOSPC:\r\nnetif_printk(nic, tx_err, KERN_DEBUG, nic->netdev,\r\n"No space for CB\n");\r\nnetif_stop_queue(netdev);\r\nbreak;\r\ncase -ENOMEM:\r\nnetif_printk(nic, tx_err, KERN_DEBUG, nic->netdev,\r\n"Out of Tx resources, returning skb\n");\r\nnetif_stop_queue(netdev);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int e100_tx_clean(struct nic *nic)\r\n{\r\nstruct net_device *dev = nic->netdev;\r\nstruct cb *cb;\r\nint tx_cleaned = 0;\r\nspin_lock(&nic->cb_lock);\r\nfor (cb = nic->cb_to_clean;\r\ncb->status & cpu_to_le16(cb_complete);\r\ncb = nic->cb_to_clean = cb->next) {\r\ndma_rmb();\r\nnetif_printk(nic, tx_done, KERN_DEBUG, nic->netdev,\r\n"cb[%d]->status = 0x%04X\n",\r\n(int)(((void*)cb - (void*)nic->cbs)/sizeof(struct cb)),\r\ncb->status);\r\nif (likely(cb->skb != NULL)) {\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += cb->skb->len;\r\npci_unmap_single(nic->pdev,\r\nle32_to_cpu(cb->u.tcb.tbd.buf_addr),\r\nle16_to_cpu(cb->u.tcb.tbd.size),\r\nPCI_DMA_TODEVICE);\r\ndev_kfree_skb_any(cb->skb);\r\ncb->skb = NULL;\r\ntx_cleaned = 1;\r\n}\r\ncb->status = 0;\r\nnic->cbs_avail++;\r\n}\r\nspin_unlock(&nic->cb_lock);\r\nif (unlikely(tx_cleaned && netif_queue_stopped(nic->netdev)))\r\nnetif_wake_queue(nic->netdev);\r\nreturn tx_cleaned;\r\n}\r\nstatic void e100_clean_cbs(struct nic *nic)\r\n{\r\nif (nic->cbs) {\r\nwhile (nic->cbs_avail != nic->params.cbs.count) {\r\nstruct cb *cb = nic->cb_to_clean;\r\nif (cb->skb) {\r\npci_unmap_single(nic->pdev,\r\nle32_to_cpu(cb->u.tcb.tbd.buf_addr),\r\nle16_to_cpu(cb->u.tcb.tbd.size),\r\nPCI_DMA_TODEVICE);\r\ndev_kfree_skb(cb->skb);\r\n}\r\nnic->cb_to_clean = nic->cb_to_clean->next;\r\nnic->cbs_avail++;\r\n}\r\npci_pool_free(nic->cbs_pool, nic->cbs, nic->cbs_dma_addr);\r\nnic->cbs = NULL;\r\nnic->cbs_avail = 0;\r\n}\r\nnic->cuc_cmd = cuc_start;\r\nnic->cb_to_use = nic->cb_to_send = nic->cb_to_clean =\r\nnic->cbs;\r\n}\r\nstatic int e100_alloc_cbs(struct nic *nic)\r\n{\r\nstruct cb *cb;\r\nunsigned int i, count = nic->params.cbs.count;\r\nnic->cuc_cmd = cuc_start;\r\nnic->cb_to_use = nic->cb_to_send = nic->cb_to_clean = NULL;\r\nnic->cbs_avail = 0;\r\nnic->cbs = pci_pool_alloc(nic->cbs_pool, GFP_KERNEL,\r\n&nic->cbs_dma_addr);\r\nif (!nic->cbs)\r\nreturn -ENOMEM;\r\nmemset(nic->cbs, 0, count * sizeof(struct cb));\r\nfor (cb = nic->cbs, i = 0; i < count; cb++, i++) {\r\ncb->next = (i + 1 < count) ? cb + 1 : nic->cbs;\r\ncb->prev = (i == 0) ? nic->cbs + count - 1 : cb - 1;\r\ncb->dma_addr = nic->cbs_dma_addr + i * sizeof(struct cb);\r\ncb->link = cpu_to_le32(nic->cbs_dma_addr +\r\n((i+1) % count) * sizeof(struct cb));\r\n}\r\nnic->cb_to_use = nic->cb_to_send = nic->cb_to_clean = nic->cbs;\r\nnic->cbs_avail = count;\r\nreturn 0;\r\n}\r\nstatic inline void e100_start_receiver(struct nic *nic, struct rx *rx)\r\n{\r\nif (!nic->rxs) return;\r\nif (RU_SUSPENDED != nic->ru_running) return;\r\nif (!rx) rx = nic->rxs;\r\nif (rx->skb) {\r\ne100_exec_cmd(nic, ruc_start, rx->dma_addr);\r\nnic->ru_running = RU_RUNNING;\r\n}\r\n}\r\nstatic int e100_rx_alloc_skb(struct nic *nic, struct rx *rx)\r\n{\r\nif (!(rx->skb = netdev_alloc_skb_ip_align(nic->netdev, RFD_BUF_LEN)))\r\nreturn -ENOMEM;\r\nskb_copy_to_linear_data(rx->skb, &nic->blank_rfd, sizeof(struct rfd));\r\nrx->dma_addr = pci_map_single(nic->pdev, rx->skb->data,\r\nRFD_BUF_LEN, PCI_DMA_BIDIRECTIONAL);\r\nif (pci_dma_mapping_error(nic->pdev, rx->dma_addr)) {\r\ndev_kfree_skb_any(rx->skb);\r\nrx->skb = NULL;\r\nrx->dma_addr = 0;\r\nreturn -ENOMEM;\r\n}\r\nif (rx->prev->skb) {\r\nstruct rfd *prev_rfd = (struct rfd *)rx->prev->skb->data;\r\nput_unaligned_le32(rx->dma_addr, &prev_rfd->link);\r\npci_dma_sync_single_for_device(nic->pdev, rx->prev->dma_addr,\r\nsizeof(struct rfd), PCI_DMA_BIDIRECTIONAL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int e100_rx_indicate(struct nic *nic, struct rx *rx,\r\nunsigned int *work_done, unsigned int work_to_do)\r\n{\r\nstruct net_device *dev = nic->netdev;\r\nstruct sk_buff *skb = rx->skb;\r\nstruct rfd *rfd = (struct rfd *)skb->data;\r\nu16 rfd_status, actual_size;\r\nu16 fcs_pad = 0;\r\nif (unlikely(work_done && *work_done >= work_to_do))\r\nreturn -EAGAIN;\r\npci_dma_sync_single_for_cpu(nic->pdev, rx->dma_addr,\r\nsizeof(struct rfd), PCI_DMA_BIDIRECTIONAL);\r\nrfd_status = le16_to_cpu(rfd->status);\r\nnetif_printk(nic, rx_status, KERN_DEBUG, nic->netdev,\r\n"status=0x%04X\n", rfd_status);\r\ndma_rmb();\r\nif (unlikely(!(rfd_status & cb_complete))) {\r\nif ((le16_to_cpu(rfd->command) & cb_el) &&\r\n(RU_RUNNING == nic->ru_running))\r\nif (ioread8(&nic->csr->scb.status) & rus_no_res)\r\nnic->ru_running = RU_SUSPENDED;\r\npci_dma_sync_single_for_device(nic->pdev, rx->dma_addr,\r\nsizeof(struct rfd),\r\nPCI_DMA_FROMDEVICE);\r\nreturn -ENODATA;\r\n}\r\nif (unlikely(dev->features & NETIF_F_RXFCS))\r\nfcs_pad = 4;\r\nactual_size = le16_to_cpu(rfd->actual_size) & 0x3FFF;\r\nif (unlikely(actual_size > RFD_BUF_LEN - sizeof(struct rfd)))\r\nactual_size = RFD_BUF_LEN - sizeof(struct rfd);\r\npci_unmap_single(nic->pdev, rx->dma_addr,\r\nRFD_BUF_LEN, PCI_DMA_BIDIRECTIONAL);\r\nif ((le16_to_cpu(rfd->command) & cb_el) &&\r\n(RU_RUNNING == nic->ru_running)) {\r\nif (ioread8(&nic->csr->scb.status) & rus_no_res)\r\nnic->ru_running = RU_SUSPENDED;\r\n}\r\nskb_reserve(skb, sizeof(struct rfd));\r\nskb_put(skb, actual_size);\r\nskb->protocol = eth_type_trans(skb, nic->netdev);\r\nif (unlikely(dev->features & NETIF_F_RXALL)) {\r\nif (actual_size > ETH_DATA_LEN + VLAN_ETH_HLEN + fcs_pad)\r\nnic->rx_over_length_errors++;\r\ngoto process_skb;\r\n}\r\nif (unlikely(!(rfd_status & cb_ok))) {\r\ndev_kfree_skb_any(skb);\r\n} else if (actual_size > ETH_DATA_LEN + VLAN_ETH_HLEN + fcs_pad) {\r\nnic->rx_over_length_errors++;\r\ndev_kfree_skb_any(skb);\r\n} else {\r\nprocess_skb:\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += (actual_size - fcs_pad);\r\nnetif_receive_skb(skb);\r\nif (work_done)\r\n(*work_done)++;\r\n}\r\nrx->skb = NULL;\r\nreturn 0;\r\n}\r\nstatic void e100_rx_clean(struct nic *nic, unsigned int *work_done,\r\nunsigned int work_to_do)\r\n{\r\nstruct rx *rx;\r\nint restart_required = 0, err = 0;\r\nstruct rx *old_before_last_rx, *new_before_last_rx;\r\nstruct rfd *old_before_last_rfd, *new_before_last_rfd;\r\nfor (rx = nic->rx_to_clean; rx->skb; rx = nic->rx_to_clean = rx->next) {\r\nerr = e100_rx_indicate(nic, rx, work_done, work_to_do);\r\nif (-EAGAIN == err || -ENODATA == err)\r\nbreak;\r\n}\r\nif (-EAGAIN != err && RU_SUSPENDED == nic->ru_running)\r\nrestart_required = 1;\r\nold_before_last_rx = nic->rx_to_use->prev->prev;\r\nold_before_last_rfd = (struct rfd *)old_before_last_rx->skb->data;\r\nfor (rx = nic->rx_to_use; !rx->skb; rx = nic->rx_to_use = rx->next) {\r\nif (unlikely(e100_rx_alloc_skb(nic, rx)))\r\nbreak;\r\n}\r\nnew_before_last_rx = nic->rx_to_use->prev->prev;\r\nif (new_before_last_rx != old_before_last_rx) {\r\nnew_before_last_rfd =\r\n(struct rfd *)new_before_last_rx->skb->data;\r\nnew_before_last_rfd->size = 0;\r\nnew_before_last_rfd->command |= cpu_to_le16(cb_el);\r\npci_dma_sync_single_for_device(nic->pdev,\r\nnew_before_last_rx->dma_addr, sizeof(struct rfd),\r\nPCI_DMA_BIDIRECTIONAL);\r\nold_before_last_rfd->command &= ~cpu_to_le16(cb_el);\r\npci_dma_sync_single_for_device(nic->pdev,\r\nold_before_last_rx->dma_addr, sizeof(struct rfd),\r\nPCI_DMA_BIDIRECTIONAL);\r\nold_before_last_rfd->size = cpu_to_le16(VLAN_ETH_FRAME_LEN\r\n+ ETH_FCS_LEN);\r\npci_dma_sync_single_for_device(nic->pdev,\r\nold_before_last_rx->dma_addr, sizeof(struct rfd),\r\nPCI_DMA_BIDIRECTIONAL);\r\n}\r\nif (restart_required) {\r\niowrite8(stat_ack_rnr, &nic->csr->scb.stat_ack);\r\ne100_start_receiver(nic, nic->rx_to_clean);\r\nif (work_done)\r\n(*work_done)++;\r\n}\r\n}\r\nstatic void e100_rx_clean_list(struct nic *nic)\r\n{\r\nstruct rx *rx;\r\nunsigned int i, count = nic->params.rfds.count;\r\nnic->ru_running = RU_UNINITIALIZED;\r\nif (nic->rxs) {\r\nfor (rx = nic->rxs, i = 0; i < count; rx++, i++) {\r\nif (rx->skb) {\r\npci_unmap_single(nic->pdev, rx->dma_addr,\r\nRFD_BUF_LEN, PCI_DMA_BIDIRECTIONAL);\r\ndev_kfree_skb(rx->skb);\r\n}\r\n}\r\nkfree(nic->rxs);\r\nnic->rxs = NULL;\r\n}\r\nnic->rx_to_use = nic->rx_to_clean = NULL;\r\n}\r\nstatic int e100_rx_alloc_list(struct nic *nic)\r\n{\r\nstruct rx *rx;\r\nunsigned int i, count = nic->params.rfds.count;\r\nstruct rfd *before_last;\r\nnic->rx_to_use = nic->rx_to_clean = NULL;\r\nnic->ru_running = RU_UNINITIALIZED;\r\nif (!(nic->rxs = kcalloc(count, sizeof(struct rx), GFP_ATOMIC)))\r\nreturn -ENOMEM;\r\nfor (rx = nic->rxs, i = 0; i < count; rx++, i++) {\r\nrx->next = (i + 1 < count) ? rx + 1 : nic->rxs;\r\nrx->prev = (i == 0) ? nic->rxs + count - 1 : rx - 1;\r\nif (e100_rx_alloc_skb(nic, rx)) {\r\ne100_rx_clean_list(nic);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nrx = nic->rxs->prev->prev;\r\nbefore_last = (struct rfd *)rx->skb->data;\r\nbefore_last->command |= cpu_to_le16(cb_el);\r\nbefore_last->size = 0;\r\npci_dma_sync_single_for_device(nic->pdev, rx->dma_addr,\r\nsizeof(struct rfd), PCI_DMA_BIDIRECTIONAL);\r\nnic->rx_to_use = nic->rx_to_clean = nic->rxs;\r\nnic->ru_running = RU_SUSPENDED;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t e100_intr(int irq, void *dev_id)\r\n{\r\nstruct net_device *netdev = dev_id;\r\nstruct nic *nic = netdev_priv(netdev);\r\nu8 stat_ack = ioread8(&nic->csr->scb.stat_ack);\r\nnetif_printk(nic, intr, KERN_DEBUG, nic->netdev,\r\n"stat_ack = 0x%02X\n", stat_ack);\r\nif (stat_ack == stat_ack_not_ours ||\r\nstat_ack == stat_ack_not_present)\r\nreturn IRQ_NONE;\r\niowrite8(stat_ack, &nic->csr->scb.stat_ack);\r\nif (stat_ack & stat_ack_rnr)\r\nnic->ru_running = RU_SUSPENDED;\r\nif (likely(napi_schedule_prep(&nic->napi))) {\r\ne100_disable_irq(nic);\r\n__napi_schedule(&nic->napi);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int e100_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct nic *nic = container_of(napi, struct nic, napi);\r\nunsigned int work_done = 0;\r\ne100_rx_clean(nic, &work_done, budget);\r\ne100_tx_clean(nic);\r\nif (work_done < budget) {\r\nnapi_complete_done(napi, work_done);\r\ne100_enable_irq(nic);\r\n}\r\nreturn work_done;\r\n}\r\nstatic void e100_netpoll(struct net_device *netdev)\r\n{\r\nstruct nic *nic = netdev_priv(netdev);\r\ne100_disable_irq(nic);\r\ne100_intr(nic->pdev->irq, netdev);\r\ne100_tx_clean(nic);\r\ne100_enable_irq(nic);\r\n}\r\nstatic int e100_set_mac_address(struct net_device *netdev, void *p)\r\n{\r\nstruct nic *nic = netdev_priv(netdev);\r\nstruct sockaddr *addr = p;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(netdev->dev_addr, addr->sa_data, netdev->addr_len);\r\ne100_exec_cb(nic, NULL, e100_setup_iaaddr);\r\nreturn 0;\r\n}\r\nstatic int e100_asf(struct nic *nic)\r\n{\r\nreturn (nic->pdev->device >= 0x1050) && (nic->pdev->device <= 0x1057) &&\r\n(nic->eeprom[eeprom_config_asf] & eeprom_asf) &&\r\n!(nic->eeprom[eeprom_config_asf] & eeprom_gcl) &&\r\n((nic->eeprom[eeprom_smbus_addr] & 0xFF) != 0xFE);\r\n}\r\nstatic int e100_up(struct nic *nic)\r\n{\r\nint err;\r\nif ((err = e100_rx_alloc_list(nic)))\r\nreturn err;\r\nif ((err = e100_alloc_cbs(nic)))\r\ngoto err_rx_clean_list;\r\nif ((err = e100_hw_init(nic)))\r\ngoto err_clean_cbs;\r\ne100_set_multicast_list(nic->netdev);\r\ne100_start_receiver(nic, NULL);\r\nmod_timer(&nic->watchdog, jiffies);\r\nif ((err = request_irq(nic->pdev->irq, e100_intr, IRQF_SHARED,\r\nnic->netdev->name, nic->netdev)))\r\ngoto err_no_irq;\r\nnetif_wake_queue(nic->netdev);\r\nnapi_enable(&nic->napi);\r\ne100_enable_irq(nic);\r\nreturn 0;\r\nerr_no_irq:\r\ndel_timer_sync(&nic->watchdog);\r\nerr_clean_cbs:\r\ne100_clean_cbs(nic);\r\nerr_rx_clean_list:\r\ne100_rx_clean_list(nic);\r\nreturn err;\r\n}\r\nstatic void e100_down(struct nic *nic)\r\n{\r\nnapi_disable(&nic->napi);\r\nnetif_stop_queue(nic->netdev);\r\ne100_hw_reset(nic);\r\nfree_irq(nic->pdev->irq, nic->netdev);\r\ndel_timer_sync(&nic->watchdog);\r\nnetif_carrier_off(nic->netdev);\r\ne100_clean_cbs(nic);\r\ne100_rx_clean_list(nic);\r\n}\r\nstatic void e100_tx_timeout(struct net_device *netdev)\r\n{\r\nstruct nic *nic = netdev_priv(netdev);\r\nschedule_work(&nic->tx_timeout_task);\r\n}\r\nstatic void e100_tx_timeout_task(struct work_struct *work)\r\n{\r\nstruct nic *nic = container_of(work, struct nic, tx_timeout_task);\r\nstruct net_device *netdev = nic->netdev;\r\nnetif_printk(nic, tx_err, KERN_DEBUG, nic->netdev,\r\n"scb.status=0x%02X\n", ioread8(&nic->csr->scb.status));\r\nrtnl_lock();\r\nif (netif_running(netdev)) {\r\ne100_down(netdev_priv(netdev));\r\ne100_up(netdev_priv(netdev));\r\n}\r\nrtnl_unlock();\r\n}\r\nstatic int e100_loopback_test(struct nic *nic, enum loopback loopback_mode)\r\n{\r\nint err;\r\nstruct sk_buff *skb;\r\nif ((err = e100_rx_alloc_list(nic)))\r\nreturn err;\r\nif ((err = e100_alloc_cbs(nic)))\r\ngoto err_clean_rx;\r\nif (nic->flags & ich && loopback_mode == lb_phy)\r\nloopback_mode = lb_mac;\r\nnic->loopback = loopback_mode;\r\nif ((err = e100_hw_init(nic)))\r\ngoto err_loopback_none;\r\nif (loopback_mode == lb_phy)\r\nmdio_write(nic->netdev, nic->mii.phy_id, MII_BMCR,\r\nBMCR_LOOPBACK);\r\ne100_start_receiver(nic, NULL);\r\nif (!(skb = netdev_alloc_skb(nic->netdev, ETH_DATA_LEN))) {\r\nerr = -ENOMEM;\r\ngoto err_loopback_none;\r\n}\r\nskb_put(skb, ETH_DATA_LEN);\r\nmemset(skb->data, 0xFF, ETH_DATA_LEN);\r\ne100_xmit_frame(skb, nic->netdev);\r\nmsleep(10);\r\npci_dma_sync_single_for_cpu(nic->pdev, nic->rx_to_clean->dma_addr,\r\nRFD_BUF_LEN, PCI_DMA_BIDIRECTIONAL);\r\nif (memcmp(nic->rx_to_clean->skb->data + sizeof(struct rfd),\r\nskb->data, ETH_DATA_LEN))\r\nerr = -EAGAIN;\r\nerr_loopback_none:\r\nmdio_write(nic->netdev, nic->mii.phy_id, MII_BMCR, 0);\r\nnic->loopback = lb_none;\r\ne100_clean_cbs(nic);\r\ne100_hw_reset(nic);\r\nerr_clean_rx:\r\ne100_rx_clean_list(nic);\r\nreturn err;\r\n}\r\nstatic int e100_get_link_ksettings(struct net_device *netdev,\r\nstruct ethtool_link_ksettings *cmd)\r\n{\r\nstruct nic *nic = netdev_priv(netdev);\r\nreturn mii_ethtool_get_link_ksettings(&nic->mii, cmd);\r\n}\r\nstatic int e100_set_link_ksettings(struct net_device *netdev,\r\nconst struct ethtool_link_ksettings *cmd)\r\n{\r\nstruct nic *nic = netdev_priv(netdev);\r\nint err;\r\nmdio_write(netdev, nic->mii.phy_id, MII_BMCR, BMCR_RESET);\r\nerr = mii_ethtool_set_link_ksettings(&nic->mii, cmd);\r\ne100_exec_cb(nic, NULL, e100_configure);\r\nreturn err;\r\n}\r\nstatic void e100_get_drvinfo(struct net_device *netdev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct nic *nic = netdev_priv(netdev);\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, pci_name(nic->pdev),\r\nsizeof(info->bus_info));\r\n}\r\nstatic int e100_get_regs_len(struct net_device *netdev)\r\n{\r\nstruct nic *nic = netdev_priv(netdev);\r\nreturn 1 + E100_PHY_REGS + sizeof(nic->mem->dump_buf);\r\n}\r\nstatic void e100_get_regs(struct net_device *netdev,\r\nstruct ethtool_regs *regs, void *p)\r\n{\r\nstruct nic *nic = netdev_priv(netdev);\r\nu32 *buff = p;\r\nint i;\r\nregs->version = (1 << 24) | nic->pdev->revision;\r\nbuff[0] = ioread8(&nic->csr->scb.cmd_hi) << 24 |\r\nioread8(&nic->csr->scb.cmd_lo) << 16 |\r\nioread16(&nic->csr->scb.status);\r\nfor (i = E100_PHY_REGS; i >= 0; i--)\r\nbuff[1 + E100_PHY_REGS - i] =\r\nmdio_read(netdev, nic->mii.phy_id, i);\r\nmemset(nic->mem->dump_buf, 0, sizeof(nic->mem->dump_buf));\r\ne100_exec_cb(nic, NULL, e100_dump);\r\nmsleep(10);\r\nmemcpy(&buff[2 + E100_PHY_REGS], nic->mem->dump_buf,\r\nsizeof(nic->mem->dump_buf));\r\n}\r\nstatic void e100_get_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct nic *nic = netdev_priv(netdev);\r\nwol->supported = (nic->mac >= mac_82558_D101_A4) ? WAKE_MAGIC : 0;\r\nwol->wolopts = (nic->flags & wol_magic) ? WAKE_MAGIC : 0;\r\n}\r\nstatic int e100_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct nic *nic = netdev_priv(netdev);\r\nif ((wol->wolopts && wol->wolopts != WAKE_MAGIC) ||\r\n!device_can_wakeup(&nic->pdev->dev))\r\nreturn -EOPNOTSUPP;\r\nif (wol->wolopts)\r\nnic->flags |= wol_magic;\r\nelse\r\nnic->flags &= ~wol_magic;\r\ndevice_set_wakeup_enable(&nic->pdev->dev, wol->wolopts);\r\ne100_exec_cb(nic, NULL, e100_configure);\r\nreturn 0;\r\n}\r\nstatic u32 e100_get_msglevel(struct net_device *netdev)\r\n{\r\nstruct nic *nic = netdev_priv(netdev);\r\nreturn nic->msg_enable;\r\n}\r\nstatic void e100_set_msglevel(struct net_device *netdev, u32 value)\r\n{\r\nstruct nic *nic = netdev_priv(netdev);\r\nnic->msg_enable = value;\r\n}\r\nstatic int e100_nway_reset(struct net_device *netdev)\r\n{\r\nstruct nic *nic = netdev_priv(netdev);\r\nreturn mii_nway_restart(&nic->mii);\r\n}\r\nstatic u32 e100_get_link(struct net_device *netdev)\r\n{\r\nstruct nic *nic = netdev_priv(netdev);\r\nreturn mii_link_ok(&nic->mii);\r\n}\r\nstatic int e100_get_eeprom_len(struct net_device *netdev)\r\n{\r\nstruct nic *nic = netdev_priv(netdev);\r\nreturn nic->eeprom_wc << 1;\r\n}\r\nstatic int e100_get_eeprom(struct net_device *netdev,\r\nstruct ethtool_eeprom *eeprom, u8 *bytes)\r\n{\r\nstruct nic *nic = netdev_priv(netdev);\r\neeprom->magic = E100_EEPROM_MAGIC;\r\nmemcpy(bytes, &((u8 *)nic->eeprom)[eeprom->offset], eeprom->len);\r\nreturn 0;\r\n}\r\nstatic int e100_set_eeprom(struct net_device *netdev,\r\nstruct ethtool_eeprom *eeprom, u8 *bytes)\r\n{\r\nstruct nic *nic = netdev_priv(netdev);\r\nif (eeprom->magic != E100_EEPROM_MAGIC)\r\nreturn -EINVAL;\r\nmemcpy(&((u8 *)nic->eeprom)[eeprom->offset], bytes, eeprom->len);\r\nreturn e100_eeprom_save(nic, eeprom->offset >> 1,\r\n(eeprom->len >> 1) + 1);\r\n}\r\nstatic void e100_get_ringparam(struct net_device *netdev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct nic *nic = netdev_priv(netdev);\r\nstruct param_range *rfds = &nic->params.rfds;\r\nstruct param_range *cbs = &nic->params.cbs;\r\nring->rx_max_pending = rfds->max;\r\nring->tx_max_pending = cbs->max;\r\nring->rx_pending = rfds->count;\r\nring->tx_pending = cbs->count;\r\n}\r\nstatic int e100_set_ringparam(struct net_device *netdev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct nic *nic = netdev_priv(netdev);\r\nstruct param_range *rfds = &nic->params.rfds;\r\nstruct param_range *cbs = &nic->params.cbs;\r\nif ((ring->rx_mini_pending) || (ring->rx_jumbo_pending))\r\nreturn -EINVAL;\r\nif (netif_running(netdev))\r\ne100_down(nic);\r\nrfds->count = max(ring->rx_pending, rfds->min);\r\nrfds->count = min(rfds->count, rfds->max);\r\ncbs->count = max(ring->tx_pending, cbs->min);\r\ncbs->count = min(cbs->count, cbs->max);\r\nnetif_info(nic, drv, nic->netdev, "Ring Param settings: rx: %d, tx %d\n",\r\nrfds->count, cbs->count);\r\nif (netif_running(netdev))\r\ne100_up(nic);\r\nreturn 0;\r\n}\r\nstatic void e100_diag_test(struct net_device *netdev,\r\nstruct ethtool_test *test, u64 *data)\r\n{\r\nstruct ethtool_cmd cmd;\r\nstruct nic *nic = netdev_priv(netdev);\r\nint i, err;\r\nmemset(data, 0, E100_TEST_LEN * sizeof(u64));\r\ndata[0] = !mii_link_ok(&nic->mii);\r\ndata[1] = e100_eeprom_load(nic);\r\nif (test->flags & ETH_TEST_FL_OFFLINE) {\r\nerr = mii_ethtool_gset(&nic->mii, &cmd);\r\nif (netif_running(netdev))\r\ne100_down(nic);\r\ndata[2] = e100_self_test(nic);\r\ndata[3] = e100_loopback_test(nic, lb_mac);\r\ndata[4] = e100_loopback_test(nic, lb_phy);\r\nerr = mii_ethtool_sset(&nic->mii, &cmd);\r\nif (netif_running(netdev))\r\ne100_up(nic);\r\n}\r\nfor (i = 0; i < E100_TEST_LEN; i++)\r\ntest->flags |= data[i] ? ETH_TEST_FL_FAILED : 0;\r\nmsleep_interruptible(4 * 1000);\r\n}\r\nstatic int e100_set_phys_id(struct net_device *netdev,\r\nenum ethtool_phys_id_state state)\r\n{\r\nstruct nic *nic = netdev_priv(netdev);\r\nenum led_state {\r\nled_on = 0x01,\r\nled_off = 0x04,\r\nled_on_559 = 0x05,\r\nled_on_557 = 0x07,\r\n};\r\nu16 led_reg = (nic->phy == phy_82552_v) ? E100_82552_LED_OVERRIDE :\r\nMII_LED_CONTROL;\r\nu16 leds = 0;\r\nswitch (state) {\r\ncase ETHTOOL_ID_ACTIVE:\r\nreturn 2;\r\ncase ETHTOOL_ID_ON:\r\nleds = (nic->phy == phy_82552_v) ? E100_82552_LED_ON :\r\n(nic->mac < mac_82559_D101M) ? led_on_557 : led_on_559;\r\nbreak;\r\ncase ETHTOOL_ID_OFF:\r\nleds = (nic->phy == phy_82552_v) ? E100_82552_LED_OFF : led_off;\r\nbreak;\r\ncase ETHTOOL_ID_INACTIVE:\r\nbreak;\r\n}\r\nmdio_write(netdev, nic->mii.phy_id, led_reg, leds);\r\nreturn 0;\r\n}\r\nstatic int e100_get_sset_count(struct net_device *netdev, int sset)\r\n{\r\nswitch (sset) {\r\ncase ETH_SS_TEST:\r\nreturn E100_TEST_LEN;\r\ncase ETH_SS_STATS:\r\nreturn E100_STATS_LEN;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void e100_get_ethtool_stats(struct net_device *netdev,\r\nstruct ethtool_stats *stats, u64 *data)\r\n{\r\nstruct nic *nic = netdev_priv(netdev);\r\nint i;\r\nfor (i = 0; i < E100_NET_STATS_LEN; i++)\r\ndata[i] = ((unsigned long *)&netdev->stats)[i];\r\ndata[i++] = nic->tx_deferred;\r\ndata[i++] = nic->tx_single_collisions;\r\ndata[i++] = nic->tx_multiple_collisions;\r\ndata[i++] = nic->tx_fc_pause;\r\ndata[i++] = nic->rx_fc_pause;\r\ndata[i++] = nic->rx_fc_unsupported;\r\ndata[i++] = nic->tx_tco_frames;\r\ndata[i++] = nic->rx_tco_frames;\r\ndata[i++] = nic->rx_short_frame_errors;\r\ndata[i++] = nic->rx_over_length_errors;\r\n}\r\nstatic void e100_get_strings(struct net_device *netdev, u32 stringset, u8 *data)\r\n{\r\nswitch (stringset) {\r\ncase ETH_SS_TEST:\r\nmemcpy(data, *e100_gstrings_test, sizeof(e100_gstrings_test));\r\nbreak;\r\ncase ETH_SS_STATS:\r\nmemcpy(data, *e100_gstrings_stats, sizeof(e100_gstrings_stats));\r\nbreak;\r\n}\r\n}\r\nstatic int e100_do_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct nic *nic = netdev_priv(netdev);\r\nreturn generic_mii_ioctl(&nic->mii, if_mii(ifr), cmd, NULL);\r\n}\r\nstatic int e100_alloc(struct nic *nic)\r\n{\r\nnic->mem = pci_alloc_consistent(nic->pdev, sizeof(struct mem),\r\n&nic->dma_addr);\r\nreturn nic->mem ? 0 : -ENOMEM;\r\n}\r\nstatic void e100_free(struct nic *nic)\r\n{\r\nif (nic->mem) {\r\npci_free_consistent(nic->pdev, sizeof(struct mem),\r\nnic->mem, nic->dma_addr);\r\nnic->mem = NULL;\r\n}\r\n}\r\nstatic int e100_open(struct net_device *netdev)\r\n{\r\nstruct nic *nic = netdev_priv(netdev);\r\nint err = 0;\r\nnetif_carrier_off(netdev);\r\nif ((err = e100_up(nic)))\r\nnetif_err(nic, ifup, nic->netdev, "Cannot open interface, aborting\n");\r\nreturn err;\r\n}\r\nstatic int e100_close(struct net_device *netdev)\r\n{\r\ne100_down(netdev_priv(netdev));\r\nreturn 0;\r\n}\r\nstatic int e100_set_features(struct net_device *netdev,\r\nnetdev_features_t features)\r\n{\r\nstruct nic *nic = netdev_priv(netdev);\r\nnetdev_features_t changed = features ^ netdev->features;\r\nif (!(changed & (NETIF_F_RXFCS | NETIF_F_RXALL)))\r\nreturn 0;\r\nnetdev->features = features;\r\ne100_exec_cb(nic, NULL, e100_configure);\r\nreturn 0;\r\n}\r\nstatic int e100_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct net_device *netdev;\r\nstruct nic *nic;\r\nint err;\r\nif (!(netdev = alloc_etherdev(sizeof(struct nic))))\r\nreturn -ENOMEM;\r\nnetdev->hw_features |= NETIF_F_RXFCS;\r\nnetdev->priv_flags |= IFF_SUPP_NOFCS;\r\nnetdev->hw_features |= NETIF_F_RXALL;\r\nnetdev->netdev_ops = &e100_netdev_ops;\r\nnetdev->ethtool_ops = &e100_ethtool_ops;\r\nnetdev->watchdog_timeo = E100_WATCHDOG_PERIOD;\r\nstrncpy(netdev->name, pci_name(pdev), sizeof(netdev->name) - 1);\r\nnic = netdev_priv(netdev);\r\nnetif_napi_add(netdev, &nic->napi, e100_poll, E100_NAPI_WEIGHT);\r\nnic->netdev = netdev;\r\nnic->pdev = pdev;\r\nnic->msg_enable = (1 << debug) - 1;\r\nnic->mdio_ctrl = mdio_ctrl_hw;\r\npci_set_drvdata(pdev, netdev);\r\nif ((err = pci_enable_device(pdev))) {\r\nnetif_err(nic, probe, nic->netdev, "Cannot enable PCI device, aborting\n");\r\ngoto err_out_free_dev;\r\n}\r\nif (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {\r\nnetif_err(nic, probe, nic->netdev, "Cannot find proper PCI device base address, aborting\n");\r\nerr = -ENODEV;\r\ngoto err_out_disable_pdev;\r\n}\r\nif ((err = pci_request_regions(pdev, DRV_NAME))) {\r\nnetif_err(nic, probe, nic->netdev, "Cannot obtain PCI resources, aborting\n");\r\ngoto err_out_disable_pdev;\r\n}\r\nif ((err = pci_set_dma_mask(pdev, DMA_BIT_MASK(32)))) {\r\nnetif_err(nic, probe, nic->netdev, "No usable DMA configuration, aborting\n");\r\ngoto err_out_free_res;\r\n}\r\nSET_NETDEV_DEV(netdev, &pdev->dev);\r\nif (use_io)\r\nnetif_info(nic, probe, nic->netdev, "using i/o access mode\n");\r\nnic->csr = pci_iomap(pdev, (use_io ? 1 : 0), sizeof(struct csr));\r\nif (!nic->csr) {\r\nnetif_err(nic, probe, nic->netdev, "Cannot map device registers, aborting\n");\r\nerr = -ENOMEM;\r\ngoto err_out_free_res;\r\n}\r\nif (ent->driver_data)\r\nnic->flags |= ich;\r\nelse\r\nnic->flags &= ~ich;\r\ne100_get_defaults(nic);\r\nif (nic->mac < mac_82558_D101_A4)\r\nnetdev->features |= NETIF_F_VLAN_CHALLENGED;\r\nspin_lock_init(&nic->cb_lock);\r\nspin_lock_init(&nic->cmd_lock);\r\nspin_lock_init(&nic->mdio_lock);\r\ne100_hw_reset(nic);\r\npci_set_master(pdev);\r\nsetup_timer(&nic->watchdog, e100_watchdog, (unsigned long)nic);\r\nINIT_WORK(&nic->tx_timeout_task, e100_tx_timeout_task);\r\nif ((err = e100_alloc(nic))) {\r\nnetif_err(nic, probe, nic->netdev, "Cannot alloc driver memory, aborting\n");\r\ngoto err_out_iounmap;\r\n}\r\nif ((err = e100_eeprom_load(nic)))\r\ngoto err_out_free;\r\ne100_phy_init(nic);\r\nmemcpy(netdev->dev_addr, nic->eeprom, ETH_ALEN);\r\nif (!is_valid_ether_addr(netdev->dev_addr)) {\r\nif (!eeprom_bad_csum_allow) {\r\nnetif_err(nic, probe, nic->netdev, "Invalid MAC address from EEPROM, aborting\n");\r\nerr = -EAGAIN;\r\ngoto err_out_free;\r\n} else {\r\nnetif_err(nic, probe, nic->netdev, "Invalid MAC address from EEPROM, you MUST configure one.\n");\r\n}\r\n}\r\nif ((nic->mac >= mac_82558_D101_A4) &&\r\n(nic->eeprom[eeprom_id] & eeprom_id_wol)) {\r\nnic->flags |= wol_magic;\r\ndevice_set_wakeup_enable(&pdev->dev, true);\r\n}\r\npci_pme_active(pdev, false);\r\nstrcpy(netdev->name, "eth%d");\r\nif ((err = register_netdev(netdev))) {\r\nnetif_err(nic, probe, nic->netdev, "Cannot register net device, aborting\n");\r\ngoto err_out_free;\r\n}\r\nnic->cbs_pool = pci_pool_create(netdev->name,\r\nnic->pdev,\r\nnic->params.cbs.max * sizeof(struct cb),\r\nsizeof(u32),\r\n0);\r\nif (!nic->cbs_pool) {\r\nnetif_err(nic, probe, nic->netdev, "Cannot create DMA pool, aborting\n");\r\nerr = -ENOMEM;\r\ngoto err_out_pool;\r\n}\r\nnetif_info(nic, probe, nic->netdev,\r\n"addr 0x%llx, irq %d, MAC addr %pM\n",\r\n(unsigned long long)pci_resource_start(pdev, use_io ? 1 : 0),\r\npdev->irq, netdev->dev_addr);\r\nreturn 0;\r\nerr_out_pool:\r\nunregister_netdev(netdev);\r\nerr_out_free:\r\ne100_free(nic);\r\nerr_out_iounmap:\r\npci_iounmap(pdev, nic->csr);\r\nerr_out_free_res:\r\npci_release_regions(pdev);\r\nerr_out_disable_pdev:\r\npci_disable_device(pdev);\r\nerr_out_free_dev:\r\nfree_netdev(netdev);\r\nreturn err;\r\n}\r\nstatic void e100_remove(struct pci_dev *pdev)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nif (netdev) {\r\nstruct nic *nic = netdev_priv(netdev);\r\nunregister_netdev(netdev);\r\ne100_free(nic);\r\npci_iounmap(pdev, nic->csr);\r\npci_pool_destroy(nic->cbs_pool);\r\nfree_netdev(netdev);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\n}\r\n}\r\nstatic void __e100_shutdown(struct pci_dev *pdev, bool *enable_wake)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct nic *nic = netdev_priv(netdev);\r\nif (netif_running(netdev))\r\ne100_down(nic);\r\nnetif_device_detach(netdev);\r\npci_save_state(pdev);\r\nif ((nic->flags & wol_magic) | e100_asf(nic)) {\r\nif (nic->phy == phy_82552_v) {\r\nu16 smartspeed = mdio_read(netdev, nic->mii.phy_id,\r\nE100_82552_SMARTSPEED);\r\nmdio_write(netdev, nic->mii.phy_id,\r\nE100_82552_SMARTSPEED, smartspeed |\r\nE100_82552_REV_ANEG | E100_82552_ANEG_NOW);\r\n}\r\n*enable_wake = true;\r\n} else {\r\n*enable_wake = false;\r\n}\r\npci_clear_master(pdev);\r\n}\r\nstatic int __e100_power_off(struct pci_dev *pdev, bool wake)\r\n{\r\nif (wake)\r\nreturn pci_prepare_to_sleep(pdev);\r\npci_wake_from_d3(pdev, false);\r\npci_set_power_state(pdev, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic int e100_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nbool wake;\r\n__e100_shutdown(pdev, &wake);\r\nreturn __e100_power_off(pdev, wake);\r\n}\r\nstatic int e100_resume(struct pci_dev *pdev)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct nic *nic = netdev_priv(netdev);\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\npci_enable_wake(pdev, PCI_D0, 0);\r\nif (nic->phy == phy_82552_v) {\r\nu16 smartspeed = mdio_read(netdev, nic->mii.phy_id,\r\nE100_82552_SMARTSPEED);\r\nmdio_write(netdev, nic->mii.phy_id,\r\nE100_82552_SMARTSPEED,\r\nsmartspeed & ~(E100_82552_REV_ANEG));\r\n}\r\nnetif_device_attach(netdev);\r\nif (netif_running(netdev))\r\ne100_up(nic);\r\nreturn 0;\r\n}\r\nstatic void e100_shutdown(struct pci_dev *pdev)\r\n{\r\nbool wake;\r\n__e100_shutdown(pdev, &wake);\r\nif (system_state == SYSTEM_POWER_OFF)\r\n__e100_power_off(pdev, wake);\r\n}\r\nstatic pci_ers_result_t e100_io_error_detected(struct pci_dev *pdev, pci_channel_state_t state)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct nic *nic = netdev_priv(netdev);\r\nnetif_device_detach(netdev);\r\nif (state == pci_channel_io_perm_failure)\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\nif (netif_running(netdev))\r\ne100_down(nic);\r\npci_disable_device(pdev);\r\nreturn PCI_ERS_RESULT_NEED_RESET;\r\n}\r\nstatic pci_ers_result_t e100_io_slot_reset(struct pci_dev *pdev)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct nic *nic = netdev_priv(netdev);\r\nif (pci_enable_device(pdev)) {\r\npr_err("Cannot re-enable PCI device after reset\n");\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\n}\r\npci_set_master(pdev);\r\nif (0 != PCI_FUNC(pdev->devfn))\r\nreturn PCI_ERS_RESULT_RECOVERED;\r\ne100_hw_reset(nic);\r\ne100_phy_init(nic);\r\nreturn PCI_ERS_RESULT_RECOVERED;\r\n}\r\nstatic void e100_io_resume(struct pci_dev *pdev)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct nic *nic = netdev_priv(netdev);\r\npci_enable_wake(pdev, PCI_D0, 0);\r\nnetif_device_attach(netdev);\r\nif (netif_running(netdev)) {\r\ne100_open(netdev);\r\nmod_timer(&nic->watchdog, jiffies);\r\n}\r\n}\r\nstatic int __init e100_init_module(void)\r\n{\r\nif (((1 << debug) - 1) & NETIF_MSG_DRV) {\r\npr_info("%s, %s\n", DRV_DESCRIPTION, DRV_VERSION);\r\npr_info("%s\n", DRV_COPYRIGHT);\r\n}\r\nreturn pci_register_driver(&e100_driver);\r\n}\r\nstatic void __exit e100_cleanup_module(void)\r\n{\r\npci_unregister_driver(&e100_driver);\r\n}
