static int sh_pfc_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pmx->pfc->info->nr_groups;\r\n}\r\nstatic const char *sh_pfc_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pmx->pfc->info->groups[selector].name;\r\n}\r\nstatic int sh_pfc_get_group_pins(struct pinctrl_dev *pctldev, unsigned selector,\r\nconst unsigned **pins, unsigned *num_pins)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = pmx->pfc->info->groups[selector].pins;\r\n*num_pins = pmx->pfc->info->groups[selector].nr_pins;\r\nreturn 0;\r\n}\r\nstatic void sh_pfc_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,\r\nunsigned offset)\r\n{\r\nseq_printf(s, "%s", DRV_NAME);\r\n}\r\nstatic int sh_pfc_map_add_config(struct pinctrl_map *map,\r\nconst char *group_or_pin,\r\nenum pinctrl_map_type type,\r\nunsigned long *configs,\r\nunsigned int num_configs)\r\n{\r\nunsigned long *cfgs;\r\ncfgs = kmemdup(configs, num_configs * sizeof(*cfgs),\r\nGFP_KERNEL);\r\nif (cfgs == NULL)\r\nreturn -ENOMEM;\r\nmap->type = type;\r\nmap->data.configs.group_or_pin = group_or_pin;\r\nmap->data.configs.configs = cfgs;\r\nmap->data.configs.num_configs = num_configs;\r\nreturn 0;\r\n}\r\nstatic int sh_pfc_dt_subnode_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np,\r\nstruct pinctrl_map **map,\r\nunsigned int *num_maps, unsigned int *index)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nstruct device *dev = pmx->pfc->dev;\r\nstruct pinctrl_map *maps = *map;\r\nunsigned int nmaps = *num_maps;\r\nunsigned int idx = *index;\r\nunsigned int num_configs;\r\nconst char *function = NULL;\r\nunsigned long *configs;\r\nstruct property *prop;\r\nunsigned int num_groups;\r\nunsigned int num_pins;\r\nconst char *group;\r\nconst char *pin;\r\nint ret;\r\nif (!pmx->func_prop_name) {\r\nif (of_find_property(np, "groups", NULL) ||\r\nof_find_property(np, "pins", NULL)) {\r\npmx->func_prop_name = "function";\r\npmx->groups_prop_name = "groups";\r\npmx->pins_prop_name = "pins";\r\n} else {\r\npmx->func_prop_name = "renesas,function";\r\npmx->groups_prop_name = "renesas,groups";\r\npmx->pins_prop_name = "renesas,pins";\r\n}\r\n}\r\nret = of_property_read_string(np, pmx->func_prop_name, &function);\r\nif (ret < 0 && ret != -EINVAL) {\r\ndev_err(dev, "Invalid function in DT\n");\r\nreturn ret;\r\n}\r\nret = pinconf_generic_parse_dt_config(np, NULL, &configs, &num_configs);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!function && num_configs == 0) {\r\ndev_err(dev,\r\n"DT node must contain at least a function or config\n");\r\nret = -ENODEV;\r\ngoto done;\r\n}\r\nret = of_property_count_strings(np, pmx->pins_prop_name);\r\nif (ret == -EINVAL) {\r\nnum_pins = 0;\r\n} else if (ret < 0) {\r\ndev_err(dev, "Invalid pins list in DT\n");\r\ngoto done;\r\n} else {\r\nnum_pins = ret;\r\n}\r\nret = of_property_count_strings(np, pmx->groups_prop_name);\r\nif (ret == -EINVAL) {\r\nnum_groups = 0;\r\n} else if (ret < 0) {\r\ndev_err(dev, "Invalid pin groups list in DT\n");\r\ngoto done;\r\n} else {\r\nnum_groups = ret;\r\n}\r\nif (!num_pins && !num_groups) {\r\ndev_err(dev, "No pin or group provided in DT node\n");\r\nret = -ENODEV;\r\ngoto done;\r\n}\r\nif (function)\r\nnmaps += num_groups;\r\nif (configs)\r\nnmaps += num_pins + num_groups;\r\nmaps = krealloc(maps, sizeof(*maps) * nmaps, GFP_KERNEL);\r\nif (maps == NULL) {\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\n*map = maps;\r\n*num_maps = nmaps;\r\nof_property_for_each_string(np, pmx->groups_prop_name, prop, group) {\r\nif (function) {\r\nmaps[idx].type = PIN_MAP_TYPE_MUX_GROUP;\r\nmaps[idx].data.mux.group = group;\r\nmaps[idx].data.mux.function = function;\r\nidx++;\r\n}\r\nif (configs) {\r\nret = sh_pfc_map_add_config(&maps[idx], group,\r\nPIN_MAP_TYPE_CONFIGS_GROUP,\r\nconfigs, num_configs);\r\nif (ret < 0)\r\ngoto done;\r\nidx++;\r\n}\r\n}\r\nif (!configs) {\r\nret = 0;\r\ngoto done;\r\n}\r\nof_property_for_each_string(np, pmx->pins_prop_name, prop, pin) {\r\nret = sh_pfc_map_add_config(&maps[idx], pin,\r\nPIN_MAP_TYPE_CONFIGS_PIN,\r\nconfigs, num_configs);\r\nif (ret < 0)\r\ngoto done;\r\nidx++;\r\n}\r\ndone:\r\n*index = idx;\r\nkfree(configs);\r\nreturn ret;\r\n}\r\nstatic void sh_pfc_dt_free_map(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_map *map, unsigned num_maps)\r\n{\r\nunsigned int i;\r\nif (map == NULL)\r\nreturn;\r\nfor (i = 0; i < num_maps; ++i) {\r\nif (map[i].type == PIN_MAP_TYPE_CONFIGS_GROUP ||\r\nmap[i].type == PIN_MAP_TYPE_CONFIGS_PIN)\r\nkfree(map[i].data.configs.configs);\r\n}\r\nkfree(map);\r\n}\r\nstatic int sh_pfc_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np,\r\nstruct pinctrl_map **map, unsigned *num_maps)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nstruct device *dev = pmx->pfc->dev;\r\nstruct device_node *child;\r\nunsigned int index;\r\nint ret;\r\n*map = NULL;\r\n*num_maps = 0;\r\nindex = 0;\r\nfor_each_child_of_node(np, child) {\r\nret = sh_pfc_dt_subnode_to_map(pctldev, child, map, num_maps,\r\n&index);\r\nif (ret < 0) {\r\nof_node_put(child);\r\ngoto done;\r\n}\r\n}\r\nif (*num_maps == 0) {\r\nret = sh_pfc_dt_subnode_to_map(pctldev, np, map, num_maps,\r\n&index);\r\nif (ret < 0)\r\ngoto done;\r\n}\r\nif (*num_maps)\r\nreturn 0;\r\ndev_err(dev, "no mapping found in node %s\n", np->full_name);\r\nret = -EINVAL;\r\ndone:\r\nif (ret < 0)\r\nsh_pfc_dt_free_map(pctldev, *map, *num_maps);\r\nreturn ret;\r\n}\r\nstatic int sh_pfc_get_functions_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pmx->pfc->info->nr_functions;\r\n}\r\nstatic const char *sh_pfc_get_function_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pmx->pfc->info->functions[selector].name;\r\n}\r\nstatic int sh_pfc_get_function_groups(struct pinctrl_dev *pctldev,\r\nunsigned selector,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = pmx->pfc->info->functions[selector].groups;\r\n*num_groups = pmx->pfc->info->functions[selector].nr_groups;\r\nreturn 0;\r\n}\r\nstatic int sh_pfc_func_set_mux(struct pinctrl_dev *pctldev, unsigned selector,\r\nunsigned group)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nstruct sh_pfc *pfc = pmx->pfc;\r\nconst struct sh_pfc_pin_group *grp = &pfc->info->groups[group];\r\nunsigned long flags;\r\nunsigned int i;\r\nint ret = 0;\r\nspin_lock_irqsave(&pfc->lock, flags);\r\nfor (i = 0; i < grp->nr_pins; ++i) {\r\nint idx = sh_pfc_get_pin_index(pfc, grp->pins[i]);\r\nstruct sh_pfc_pin_config *cfg = &pmx->configs[idx];\r\nif (cfg->type != PINMUX_TYPE_NONE) {\r\nret = -EBUSY;\r\ngoto done;\r\n}\r\n}\r\nfor (i = 0; i < grp->nr_pins; ++i) {\r\nret = sh_pfc_config_mux(pfc, grp->mux[i], PINMUX_TYPE_FUNCTION);\r\nif (ret < 0)\r\nbreak;\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&pfc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int sh_pfc_gpio_request_enable(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nstruct sh_pfc *pfc = pmx->pfc;\r\nint idx = sh_pfc_get_pin_index(pfc, offset);\r\nstruct sh_pfc_pin_config *cfg = &pmx->configs[idx];\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&pfc->lock, flags);\r\nif (cfg->type != PINMUX_TYPE_NONE) {\r\ndev_err(pfc->dev,\r\n"Pin %u is busy, can't configure it as GPIO.\n",\r\noffset);\r\nret = -EBUSY;\r\ngoto done;\r\n}\r\nif (!pfc->gpio) {\r\nconst struct sh_pfc_pin *pin = &pfc->info->pins[idx];\r\nret = sh_pfc_config_mux(pfc, pin->enum_id, PINMUX_TYPE_GPIO);\r\nif (ret < 0)\r\ngoto done;\r\n}\r\ncfg->type = PINMUX_TYPE_GPIO;\r\nret = 0;\r\ndone:\r\nspin_unlock_irqrestore(&pfc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void sh_pfc_gpio_disable_free(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nstruct sh_pfc *pfc = pmx->pfc;\r\nint idx = sh_pfc_get_pin_index(pfc, offset);\r\nstruct sh_pfc_pin_config *cfg = &pmx->configs[idx];\r\nunsigned long flags;\r\nspin_lock_irqsave(&pfc->lock, flags);\r\ncfg->type = PINMUX_TYPE_NONE;\r\nspin_unlock_irqrestore(&pfc->lock, flags);\r\n}\r\nstatic int sh_pfc_gpio_set_direction(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset, bool input)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nstruct sh_pfc *pfc = pmx->pfc;\r\nint new_type = input ? PINMUX_TYPE_INPUT : PINMUX_TYPE_OUTPUT;\r\nint idx = sh_pfc_get_pin_index(pfc, offset);\r\nconst struct sh_pfc_pin *pin = &pfc->info->pins[idx];\r\nstruct sh_pfc_pin_config *cfg = &pmx->configs[idx];\r\nunsigned long flags;\r\nunsigned int dir;\r\nint ret;\r\nif (pin->configs) {\r\ndir = input ? SH_PFC_PIN_CFG_INPUT : SH_PFC_PIN_CFG_OUTPUT;\r\nif (!(pin->configs & dir))\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&pfc->lock, flags);\r\nret = sh_pfc_config_mux(pfc, pin->enum_id, new_type);\r\nif (ret < 0)\r\ngoto done;\r\ncfg->type = new_type;\r\ndone:\r\nspin_unlock_irqrestore(&pfc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic u32 sh_pfc_pinconf_find_drive_strength_reg(struct sh_pfc *pfc,\r\nunsigned int pin, unsigned int *offset, unsigned int *size)\r\n{\r\nconst struct pinmux_drive_reg_field *field;\r\nconst struct pinmux_drive_reg *reg;\r\nunsigned int i;\r\nfor (reg = pfc->info->drive_regs; reg->reg; ++reg) {\r\nfor (i = 0; i < ARRAY_SIZE(reg->fields); ++i) {\r\nfield = &reg->fields[i];\r\nif (field->size && field->pin == pin) {\r\n*offset = field->offset;\r\n*size = field->size;\r\nreturn reg->reg;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sh_pfc_pinconf_get_drive_strength(struct sh_pfc *pfc,\r\nunsigned int pin)\r\n{\r\nunsigned long flags;\r\nunsigned int offset;\r\nunsigned int size;\r\nu32 reg;\r\nu32 val;\r\nreg = sh_pfc_pinconf_find_drive_strength_reg(pfc, pin, &offset, &size);\r\nif (!reg)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&pfc->lock, flags);\r\nval = sh_pfc_read_reg(pfc, reg, 32);\r\nspin_unlock_irqrestore(&pfc->lock, flags);\r\nval = (val >> offset) & GENMASK(size - 1, 0);\r\nreturn (val + 1) * (size == 2 ? 6 : 3);\r\n}\r\nstatic int sh_pfc_pinconf_set_drive_strength(struct sh_pfc *pfc,\r\nunsigned int pin, u16 strength)\r\n{\r\nunsigned long flags;\r\nunsigned int offset;\r\nunsigned int size;\r\nunsigned int step;\r\nu32 reg;\r\nu32 val;\r\nreg = sh_pfc_pinconf_find_drive_strength_reg(pfc, pin, &offset, &size);\r\nif (!reg)\r\nreturn -EINVAL;\r\nstep = size == 2 ? 6 : 3;\r\nif (strength < step || strength > 24)\r\nreturn -EINVAL;\r\nstrength = strength / step - 1;\r\nspin_lock_irqsave(&pfc->lock, flags);\r\nval = sh_pfc_read_reg(pfc, reg, 32);\r\nval &= ~GENMASK(offset + size - 1, offset);\r\nval |= strength << offset;\r\nsh_pfc_write_reg(pfc, reg, 32, val);\r\nspin_unlock_irqrestore(&pfc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic bool sh_pfc_pinconf_validate(struct sh_pfc *pfc, unsigned int _pin,\r\nenum pin_config_param param)\r\n{\r\nint idx = sh_pfc_get_pin_index(pfc, _pin);\r\nconst struct sh_pfc_pin *pin = &pfc->info->pins[idx];\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nreturn pin->configs &\r\n(SH_PFC_PIN_CFG_PULL_UP | SH_PFC_PIN_CFG_PULL_DOWN);\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nreturn pin->configs & SH_PFC_PIN_CFG_PULL_UP;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nreturn pin->configs & SH_PFC_PIN_CFG_PULL_DOWN;\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\nreturn pin->configs & SH_PFC_PIN_CFG_DRIVE_STRENGTH;\r\ncase PIN_CONFIG_POWER_SOURCE:\r\nreturn pin->configs & SH_PFC_PIN_CFG_IO_VOLTAGE;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int sh_pfc_pinconf_get(struct pinctrl_dev *pctldev, unsigned _pin,\r\nunsigned long *config)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nstruct sh_pfc *pfc = pmx->pfc;\r\nenum pin_config_param param = pinconf_to_config_param(*config);\r\nunsigned long flags;\r\nunsigned int arg;\r\nif (!sh_pfc_pinconf_validate(pfc, _pin, param))\r\nreturn -ENOTSUPP;\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\ncase PIN_CONFIG_BIAS_PULL_DOWN: {\r\nunsigned int bias;\r\nif (!pfc->info->ops || !pfc->info->ops->get_bias)\r\nreturn -ENOTSUPP;\r\nspin_lock_irqsave(&pfc->lock, flags);\r\nbias = pfc->info->ops->get_bias(pfc, _pin);\r\nspin_unlock_irqrestore(&pfc->lock, flags);\r\nif (bias != param)\r\nreturn -EINVAL;\r\narg = 0;\r\nbreak;\r\n}\r\ncase PIN_CONFIG_DRIVE_STRENGTH: {\r\nint ret;\r\nret = sh_pfc_pinconf_get_drive_strength(pfc, _pin);\r\nif (ret < 0)\r\nreturn ret;\r\narg = ret;\r\nbreak;\r\n}\r\ncase PIN_CONFIG_POWER_SOURCE: {\r\nu32 pocctrl, val;\r\nint bit;\r\nif (!pfc->info->ops || !pfc->info->ops->pin_to_pocctrl)\r\nreturn -ENOTSUPP;\r\nbit = pfc->info->ops->pin_to_pocctrl(pfc, _pin, &pocctrl);\r\nif (WARN(bit < 0, "invalid pin %#x", _pin))\r\nreturn bit;\r\nspin_lock_irqsave(&pfc->lock, flags);\r\nval = sh_pfc_read_reg(pfc, pocctrl, 32);\r\nspin_unlock_irqrestore(&pfc->lock, flags);\r\narg = (val & BIT(bit)) ? 3300 : 1800;\r\nbreak;\r\n}\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\n*config = pinconf_to_config_packed(param, arg);\r\nreturn 0;\r\n}\r\nstatic int sh_pfc_pinconf_set(struct pinctrl_dev *pctldev, unsigned _pin,\r\nunsigned long *configs, unsigned num_configs)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nstruct sh_pfc *pfc = pmx->pfc;\r\nenum pin_config_param param;\r\nunsigned long flags;\r\nunsigned int i;\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = pinconf_to_config_param(configs[i]);\r\nif (!sh_pfc_pinconf_validate(pfc, _pin, param))\r\nreturn -ENOTSUPP;\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nif (!pfc->info->ops || !pfc->info->ops->set_bias)\r\nreturn -ENOTSUPP;\r\nspin_lock_irqsave(&pfc->lock, flags);\r\npfc->info->ops->set_bias(pfc, _pin, param);\r\nspin_unlock_irqrestore(&pfc->lock, flags);\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_STRENGTH: {\r\nunsigned int arg =\r\npinconf_to_config_argument(configs[i]);\r\nint ret;\r\nret = sh_pfc_pinconf_set_drive_strength(pfc, _pin, arg);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\n}\r\ncase PIN_CONFIG_POWER_SOURCE: {\r\nunsigned int mV = pinconf_to_config_argument(configs[i]);\r\nu32 pocctrl, val;\r\nint bit;\r\nif (!pfc->info->ops || !pfc->info->ops->pin_to_pocctrl)\r\nreturn -ENOTSUPP;\r\nbit = pfc->info->ops->pin_to_pocctrl(pfc, _pin, &pocctrl);\r\nif (WARN(bit < 0, "invalid pin %#x", _pin))\r\nreturn bit;\r\nif (mV != 1800 && mV != 3300)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&pfc->lock, flags);\r\nval = sh_pfc_read_reg(pfc, pocctrl, 32);\r\nif (mV == 3300)\r\nval |= BIT(bit);\r\nelse\r\nval &= ~BIT(bit);\r\nsh_pfc_write_reg(pfc, pocctrl, 32, val);\r\nspin_unlock_irqrestore(&pfc->lock, flags);\r\nbreak;\r\n}\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sh_pfc_pinconf_group_set(struct pinctrl_dev *pctldev, unsigned group,\r\nunsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nconst unsigned int *pins;\r\nunsigned int num_pins;\r\nunsigned int i;\r\npins = pmx->pfc->info->groups[group].pins;\r\nnum_pins = pmx->pfc->info->groups[group].nr_pins;\r\nfor (i = 0; i < num_pins; ++i)\r\nsh_pfc_pinconf_set(pctldev, pins[i], configs, num_configs);\r\nreturn 0;\r\n}\r\nstatic int sh_pfc_map_pins(struct sh_pfc *pfc, struct sh_pfc_pinctrl *pmx)\r\n{\r\nunsigned int i;\r\npmx->pins = devm_kzalloc(pfc->dev,\r\nsizeof(*pmx->pins) * pfc->info->nr_pins,\r\nGFP_KERNEL);\r\nif (unlikely(!pmx->pins))\r\nreturn -ENOMEM;\r\npmx->configs = devm_kzalloc(pfc->dev,\r\nsizeof(*pmx->configs) * pfc->info->nr_pins,\r\nGFP_KERNEL);\r\nif (unlikely(!pmx->configs))\r\nreturn -ENOMEM;\r\nfor (i = 0; i < pfc->info->nr_pins; ++i) {\r\nconst struct sh_pfc_pin *info = &pfc->info->pins[i];\r\nstruct sh_pfc_pin_config *cfg = &pmx->configs[i];\r\nstruct pinctrl_pin_desc *pin = &pmx->pins[i];\r\npin->number = info->pin != (u16)-1 ? info->pin : i;\r\npin->name = info->name;\r\ncfg->type = PINMUX_TYPE_NONE;\r\n}\r\nreturn 0;\r\n}\r\nint sh_pfc_register_pinctrl(struct sh_pfc *pfc)\r\n{\r\nstruct sh_pfc_pinctrl *pmx;\r\nint ret;\r\npmx = devm_kzalloc(pfc->dev, sizeof(*pmx), GFP_KERNEL);\r\nif (unlikely(!pmx))\r\nreturn -ENOMEM;\r\npmx->pfc = pfc;\r\nret = sh_pfc_map_pins(pfc, pmx);\r\nif (ret < 0)\r\nreturn ret;\r\npmx->pctl_desc.name = DRV_NAME;\r\npmx->pctl_desc.owner = THIS_MODULE;\r\npmx->pctl_desc.pctlops = &sh_pfc_pinctrl_ops;\r\npmx->pctl_desc.pmxops = &sh_pfc_pinmux_ops;\r\npmx->pctl_desc.confops = &sh_pfc_pinconf_ops;\r\npmx->pctl_desc.pins = pmx->pins;\r\npmx->pctl_desc.npins = pfc->info->nr_pins;\r\nret = devm_pinctrl_register_and_init(pfc->dev, &pmx->pctl_desc, pmx,\r\n&pmx->pctl);\r\nif (ret) {\r\ndev_err(pfc->dev, "could not register: %i\n", ret);\r\nreturn ret;\r\n}\r\nreturn pinctrl_enable(pmx->pctl);\r\n}
