struct xfs_bud_log_item *\r\nxfs_trans_get_bud(\r\nstruct xfs_trans *tp,\r\nstruct xfs_bui_log_item *buip)\r\n{\r\nstruct xfs_bud_log_item *budp;\r\nbudp = xfs_bud_init(tp->t_mountp, buip);\r\nxfs_trans_add_item(tp, &budp->bud_item);\r\nreturn budp;\r\n}\r\nint\r\nxfs_trans_log_finish_bmap_update(\r\nstruct xfs_trans *tp,\r\nstruct xfs_bud_log_item *budp,\r\nstruct xfs_defer_ops *dop,\r\nenum xfs_bmap_intent_type type,\r\nstruct xfs_inode *ip,\r\nint whichfork,\r\nxfs_fileoff_t startoff,\r\nxfs_fsblock_t startblock,\r\nxfs_filblks_t blockcount,\r\nxfs_exntst_t state)\r\n{\r\nint error;\r\nerror = xfs_bmap_finish_one(tp, dop, ip, type, whichfork, startoff,\r\nstartblock, blockcount, state);\r\ntp->t_flags |= XFS_TRANS_DIRTY;\r\nbudp->bud_item.li_desc->lid_flags |= XFS_LID_DIRTY;\r\nreturn error;\r\n}\r\nstatic int\r\nxfs_bmap_update_diff_items(\r\nvoid *priv,\r\nstruct list_head *a,\r\nstruct list_head *b)\r\n{\r\nstruct xfs_bmap_intent *ba;\r\nstruct xfs_bmap_intent *bb;\r\nba = container_of(a, struct xfs_bmap_intent, bi_list);\r\nbb = container_of(b, struct xfs_bmap_intent, bi_list);\r\nreturn ba->bi_owner->i_ino - bb->bi_owner->i_ino;\r\n}\r\nSTATIC void *\r\nxfs_bmap_update_create_intent(\r\nstruct xfs_trans *tp,\r\nunsigned int count)\r\n{\r\nstruct xfs_bui_log_item *buip;\r\nASSERT(count == XFS_BUI_MAX_FAST_EXTENTS);\r\nASSERT(tp != NULL);\r\nbuip = xfs_bui_init(tp->t_mountp);\r\nASSERT(buip != NULL);\r\nxfs_trans_add_item(tp, &buip->bui_item);\r\nreturn buip;\r\n}\r\nstatic void\r\nxfs_trans_set_bmap_flags(\r\nstruct xfs_map_extent *bmap,\r\nenum xfs_bmap_intent_type type,\r\nint whichfork,\r\nxfs_exntst_t state)\r\n{\r\nbmap->me_flags = 0;\r\nswitch (type) {\r\ncase XFS_BMAP_MAP:\r\ncase XFS_BMAP_UNMAP:\r\nbmap->me_flags = type;\r\nbreak;\r\ndefault:\r\nASSERT(0);\r\n}\r\nif (state == XFS_EXT_UNWRITTEN)\r\nbmap->me_flags |= XFS_BMAP_EXTENT_UNWRITTEN;\r\nif (whichfork == XFS_ATTR_FORK)\r\nbmap->me_flags |= XFS_BMAP_EXTENT_ATTR_FORK;\r\n}\r\nSTATIC void\r\nxfs_bmap_update_log_item(\r\nstruct xfs_trans *tp,\r\nvoid *intent,\r\nstruct list_head *item)\r\n{\r\nstruct xfs_bui_log_item *buip = intent;\r\nstruct xfs_bmap_intent *bmap;\r\nuint next_extent;\r\nstruct xfs_map_extent *map;\r\nbmap = container_of(item, struct xfs_bmap_intent, bi_list);\r\ntp->t_flags |= XFS_TRANS_DIRTY;\r\nbuip->bui_item.li_desc->lid_flags |= XFS_LID_DIRTY;\r\nnext_extent = atomic_inc_return(&buip->bui_next_extent) - 1;\r\nASSERT(next_extent < buip->bui_format.bui_nextents);\r\nmap = &buip->bui_format.bui_extents[next_extent];\r\nmap->me_owner = bmap->bi_owner->i_ino;\r\nmap->me_startblock = bmap->bi_bmap.br_startblock;\r\nmap->me_startoff = bmap->bi_bmap.br_startoff;\r\nmap->me_len = bmap->bi_bmap.br_blockcount;\r\nxfs_trans_set_bmap_flags(map, bmap->bi_type, bmap->bi_whichfork,\r\nbmap->bi_bmap.br_state);\r\n}\r\nSTATIC void *\r\nxfs_bmap_update_create_done(\r\nstruct xfs_trans *tp,\r\nvoid *intent,\r\nunsigned int count)\r\n{\r\nreturn xfs_trans_get_bud(tp, intent);\r\n}\r\nSTATIC int\r\nxfs_bmap_update_finish_item(\r\nstruct xfs_trans *tp,\r\nstruct xfs_defer_ops *dop,\r\nstruct list_head *item,\r\nvoid *done_item,\r\nvoid **state)\r\n{\r\nstruct xfs_bmap_intent *bmap;\r\nint error;\r\nbmap = container_of(item, struct xfs_bmap_intent, bi_list);\r\nerror = xfs_trans_log_finish_bmap_update(tp, done_item, dop,\r\nbmap->bi_type,\r\nbmap->bi_owner, bmap->bi_whichfork,\r\nbmap->bi_bmap.br_startoff,\r\nbmap->bi_bmap.br_startblock,\r\nbmap->bi_bmap.br_blockcount,\r\nbmap->bi_bmap.br_state);\r\nkmem_free(bmap);\r\nreturn error;\r\n}\r\nSTATIC void\r\nxfs_bmap_update_abort_intent(\r\nvoid *intent)\r\n{\r\nxfs_bui_release(intent);\r\n}\r\nSTATIC void\r\nxfs_bmap_update_cancel_item(\r\nstruct list_head *item)\r\n{\r\nstruct xfs_bmap_intent *bmap;\r\nbmap = container_of(item, struct xfs_bmap_intent, bi_list);\r\nkmem_free(bmap);\r\n}\r\nvoid\r\nxfs_bmap_update_init_defer_op(void)\r\n{\r\nxfs_defer_init_op_type(&xfs_bmap_update_defer_type);\r\n}
