static struct clk * __init\r\nr8a73a4_cpg_register_clock(struct device_node *np, struct r8a73a4_cpg *cpg,\r\nconst char *name)\r\n{\r\nconst struct clk_div_table *table = NULL;\r\nconst char *parent_name;\r\nunsigned int shift, reg;\r\nunsigned int mult = 1;\r\nunsigned int div = 1;\r\nif (!strcmp(name, "main")) {\r\nu32 ckscr = clk_readl(cpg->reg + CPG_CKSCR);\r\nswitch ((ckscr >> 28) & 3) {\r\ncase 0:\r\nparent_name = of_clk_get_parent_name(np, 0);\r\nbreak;\r\ncase 1:\r\nparent_name = of_clk_get_parent_name(np, 0);\r\ndiv = 2;\r\nbreak;\r\ncase 2:\r\nparent_name = of_clk_get_parent_name(np, 1);\r\nbreak;\r\ncase 3:\r\nparent_name = of_clk_get_parent_name(np, 1);\r\ndiv = 2;\r\nbreak;\r\n}\r\n} else if (!strcmp(name, "pll0")) {\r\nu32 value = clk_readl(cpg->reg + CPG_PLL0CR);\r\nparent_name = "main";\r\nmult = ((value >> 24) & 0x7f) + 1;\r\nif (value & BIT(20))\r\ndiv = 2;\r\n} else if (!strcmp(name, "pll1")) {\r\nu32 value = clk_readl(cpg->reg + CPG_PLL1CR);\r\nparent_name = "main";\r\nmult = ((value >> 24) & 0x7f) + 1;\r\nif (value & BIT(7))\r\ndiv = 2;\r\n} else if (!strncmp(name, "pll2", 4)) {\r\nu32 value, cr;\r\nswitch (name[4]) {\r\ncase 0:\r\ncr = CPG_PLL2CR;\r\nbreak;\r\ncase 's':\r\ncr = CPG_PLL2SCR;\r\nbreak;\r\ncase 'h':\r\ncr = CPG_PLL2HCR;\r\nbreak;\r\ndefault:\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nvalue = clk_readl(cpg->reg + cr);\r\nswitch ((value >> 5) & 7) {\r\ncase 0:\r\nparent_name = "main";\r\ndiv = 2;\r\nbreak;\r\ncase 1:\r\nparent_name = "extal2";\r\ndiv = 2;\r\nbreak;\r\ncase 3:\r\nparent_name = "extal2";\r\ndiv = 4;\r\nbreak;\r\ncase 4:\r\nparent_name = "main";\r\nbreak;\r\ncase 5:\r\nparent_name = "extal2";\r\nbreak;\r\ndefault:\r\npr_warn("%s: unexpected parent of %s\n", __func__,\r\nname);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nmult = ((value >> 24) & 0x7f) + 1;\r\n} else if (!strcmp(name, "z") || !strcmp(name, "z2")) {\r\nu32 shift = 8;\r\nparent_name = "pll0";\r\nif (name[1] == '2') {\r\ndiv = 2;\r\nshift = 0;\r\n}\r\ndiv *= 32;\r\nmult = 0x20 - ((clk_readl(cpg->reg + CPG_FRQCRC) >> shift)\r\n& 0x1f);\r\n} else {\r\nstruct div4_clk *c;\r\nfor (c = div4_clks; c->name; c++) {\r\nif (!strcmp(name, c->name))\r\nbreak;\r\n}\r\nif (!c->name)\r\nreturn ERR_PTR(-EINVAL);\r\nparent_name = "pll1";\r\ntable = div4_div_table;\r\nreg = c->reg;\r\nshift = c->shift;\r\n}\r\nif (!table) {\r\nreturn clk_register_fixed_factor(NULL, name, parent_name, 0,\r\nmult, div);\r\n} else {\r\nreturn clk_register_divider_table(NULL, name, parent_name, 0,\r\ncpg->reg + reg, shift, 4, 0,\r\ntable, &cpg->lock);\r\n}\r\n}\r\nstatic void __init r8a73a4_cpg_clocks_init(struct device_node *np)\r\n{\r\nstruct r8a73a4_cpg *cpg;\r\nstruct clk **clks;\r\nunsigned int i;\r\nint num_clks;\r\nnum_clks = of_property_count_strings(np, "clock-output-names");\r\nif (num_clks < 0) {\r\npr_err("%s: failed to count clocks\n", __func__);\r\nreturn;\r\n}\r\ncpg = kzalloc(sizeof(*cpg), GFP_KERNEL);\r\nclks = kcalloc(num_clks, sizeof(*clks), GFP_KERNEL);\r\nif (cpg == NULL || clks == NULL) {\r\nreturn;\r\n}\r\nspin_lock_init(&cpg->lock);\r\ncpg->data.clks = clks;\r\ncpg->data.clk_num = num_clks;\r\ncpg->reg = of_iomap(np, 0);\r\nif (WARN_ON(cpg->reg == NULL))\r\nreturn;\r\nfor (i = 0; i < num_clks; ++i) {\r\nconst char *name;\r\nstruct clk *clk;\r\nof_property_read_string_index(np, "clock-output-names", i,\r\n&name);\r\nclk = r8a73a4_cpg_register_clock(np, cpg, name);\r\nif (IS_ERR(clk))\r\npr_err("%s: failed to register %s %s clock (%ld)\n",\r\n__func__, np->name, name, PTR_ERR(clk));\r\nelse\r\ncpg->data.clks[i] = clk;\r\n}\r\nof_clk_add_provider(np, of_clk_src_onecell_get, &cpg->data);\r\n}
