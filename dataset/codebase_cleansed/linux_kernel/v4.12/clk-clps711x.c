static struct clps711x_clk * __init _clps711x_clk_init(void __iomem *base,\r\nu32 fref)\r\n{\r\nu32 tmp, f_cpu, f_pll, f_bus, f_tim, f_pwm, f_spi;\r\nstruct clps711x_clk *clps711x_clk;\r\nunsigned i;\r\nif (!base)\r\nreturn ERR_PTR(-ENOMEM);\r\nclps711x_clk = kzalloc(sizeof(*clps711x_clk) +\r\nsizeof(*clps711x_clk->clk_data.hws) * CLPS711X_CLK_MAX,\r\nGFP_KERNEL);\r\nif (!clps711x_clk)\r\nreturn ERR_PTR(-ENOMEM);\r\nspin_lock_init(&clps711x_clk->lock);\r\ntmp = readl(base + CLPS711X_PLLR) >> 24;\r\nif (((tmp >= 10) && (tmp <= 50)) || !fref)\r\nf_pll = DIV_ROUND_UP(CLPS711X_OSC_FREQ * tmp, 2);\r\nelse\r\nf_pll = fref;\r\ntmp = readl(base + CLPS711X_SYSFLG2);\r\nif (tmp & SYSFLG2_CKMODE) {\r\nf_cpu = CLPS711X_EXT_FREQ;\r\nf_bus = CLPS711X_EXT_FREQ;\r\nf_spi = DIV_ROUND_CLOSEST(CLPS711X_EXT_FREQ, 96);\r\nf_pll = 0;\r\nf_pwm = DIV_ROUND_CLOSEST(CLPS711X_EXT_FREQ, 128);\r\n} else {\r\nf_cpu = f_pll;\r\nif (f_cpu > 36864000)\r\nf_bus = DIV_ROUND_UP(f_cpu, 2);\r\nelse\r\nf_bus = 36864000 / 2;\r\nf_spi = DIV_ROUND_CLOSEST(f_cpu, 576);\r\nf_pwm = DIV_ROUND_CLOSEST(f_cpu, 768);\r\n}\r\nif (tmp & SYSFLG2_CKMODE) {\r\nif (readl(base + CLPS711X_SYSCON2) & SYSCON2_OSTB)\r\nf_tim = DIV_ROUND_CLOSEST(CLPS711X_EXT_FREQ, 26);\r\nelse\r\nf_tim = DIV_ROUND_CLOSEST(CLPS711X_EXT_FREQ, 24);\r\n} else\r\nf_tim = DIV_ROUND_CLOSEST(f_cpu, 144);\r\ntmp = readl(base + CLPS711X_SYSCON1);\r\ntmp &= ~(SYSCON1_TC1M | SYSCON1_TC1S);\r\ntmp |= SYSCON1_TC2M | SYSCON1_TC2S;\r\nwritel(tmp, base + CLPS711X_SYSCON1);\r\nclps711x_clk->clk_data.hws[CLPS711X_CLK_DUMMY] =\r\nclk_hw_register_fixed_rate(NULL, "dummy", NULL, 0, 0);\r\nclps711x_clk->clk_data.hws[CLPS711X_CLK_CPU] =\r\nclk_hw_register_fixed_rate(NULL, "cpu", NULL, 0, f_cpu);\r\nclps711x_clk->clk_data.hws[CLPS711X_CLK_BUS] =\r\nclk_hw_register_fixed_rate(NULL, "bus", NULL, 0, f_bus);\r\nclps711x_clk->clk_data.hws[CLPS711X_CLK_PLL] =\r\nclk_hw_register_fixed_rate(NULL, "pll", NULL, 0, f_pll);\r\nclps711x_clk->clk_data.hws[CLPS711X_CLK_TIMERREF] =\r\nclk_hw_register_fixed_rate(NULL, "timer_ref", NULL, 0, f_tim);\r\nclps711x_clk->clk_data.hws[CLPS711X_CLK_TIMER1] =\r\nclk_hw_register_divider_table(NULL, "timer1", "timer_ref", 0,\r\nbase + CLPS711X_SYSCON1, 5, 1, 0,\r\ntimer_div_table, &clps711x_clk->lock);\r\nclps711x_clk->clk_data.hws[CLPS711X_CLK_TIMER2] =\r\nclk_hw_register_divider_table(NULL, "timer2", "timer_ref", 0,\r\nbase + CLPS711X_SYSCON1, 7, 1, 0,\r\ntimer_div_table, &clps711x_clk->lock);\r\nclps711x_clk->clk_data.hws[CLPS711X_CLK_PWM] =\r\nclk_hw_register_fixed_rate(NULL, "pwm", NULL, 0, f_pwm);\r\nclps711x_clk->clk_data.hws[CLPS711X_CLK_SPIREF] =\r\nclk_hw_register_fixed_rate(NULL, "spi_ref", NULL, 0, f_spi);\r\nclps711x_clk->clk_data.hws[CLPS711X_CLK_SPI] =\r\nclk_hw_register_divider_table(NULL, "spi", "spi_ref", 0,\r\nbase + CLPS711X_SYSCON1, 16, 2, 0,\r\nspi_div_table, &clps711x_clk->lock);\r\nclps711x_clk->clk_data.hws[CLPS711X_CLK_UART] =\r\nclk_hw_register_fixed_factor(NULL, "uart", "bus", 0, 1, 10);\r\nclps711x_clk->clk_data.hws[CLPS711X_CLK_TICK] =\r\nclk_hw_register_fixed_rate(NULL, "tick", NULL, 0, 64);\r\nfor (i = 0; i < CLPS711X_CLK_MAX; i++)\r\nif (IS_ERR(clps711x_clk->clk_data.hws[i]))\r\npr_err("clk %i: register failed with %ld\n",\r\ni, PTR_ERR(clps711x_clk->clk_data.hws[i]));\r\nreturn clps711x_clk;\r\n}\r\nvoid __init clps711x_clk_init(void __iomem *base)\r\n{\r\nstruct clps711x_clk *clps711x_clk;\r\nclps711x_clk = _clps711x_clk_init(base, 73728000);\r\nBUG_ON(IS_ERR(clps711x_clk));\r\nclk_hw_register_clkdev(clps711x_clk->clk_data.hws[CLPS711X_CLK_TIMER1],\r\nNULL, "clps711x-timer.0");\r\nclk_hw_register_clkdev(clps711x_clk->clk_data.hws[CLPS711X_CLK_TIMER2],\r\nNULL, "clps711x-timer.1");\r\nclk_hw_register_clkdev(clps711x_clk->clk_data.hws[CLPS711X_CLK_PWM],\r\nNULL, "clps711x-pwm");\r\nclk_hw_register_clkdev(clps711x_clk->clk_data.hws[CLPS711X_CLK_UART],\r\nNULL, "clps711x-uart.0");\r\nclk_hw_register_clkdev(clps711x_clk->clk_data.hws[CLPS711X_CLK_UART],\r\nNULL, "clps711x-uart.1");\r\n}\r\nstatic void __init clps711x_clk_init_dt(struct device_node *np)\r\n{\r\nvoid __iomem *base = of_iomap(np, 0);\r\nstruct clps711x_clk *clps711x_clk;\r\nu32 fref = 0;\r\nWARN_ON(of_property_read_u32(np, "startup-frequency", &fref));\r\nclps711x_clk = _clps711x_clk_init(base, fref);\r\nBUG_ON(IS_ERR(clps711x_clk));\r\nclps711x_clk->clk_data.num = CLPS711X_CLK_MAX;\r\nof_clk_add_hw_provider(np, of_clk_hw_onecell_get,\r\n&clps711x_clk->clk_data);\r\n}
