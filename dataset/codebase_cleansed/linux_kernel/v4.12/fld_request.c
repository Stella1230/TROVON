static int fld_rrb_hash(struct lu_client_fld *fld, u64 seq)\r\n{\r\nLASSERT(fld->lcf_count > 0);\r\nreturn do_div(seq, fld->lcf_count);\r\n}\r\nstatic struct lu_fld_target *\r\nfld_rrb_scan(struct lu_client_fld *fld, u64 seq)\r\n{\r\nstruct lu_fld_target *target;\r\nint hash;\r\nif (fid_seq_is_norm(seq))\r\nhash = fld_rrb_hash(fld, seq);\r\nelse\r\nhash = 0;\r\nagain:\r\nlist_for_each_entry(target, &fld->lcf_targets, ft_chain) {\r\nif (target->ft_idx == hash)\r\nreturn target;\r\n}\r\nif (hash != 0) {\r\nhash = 0;\r\ngoto again;\r\n}\r\nCERROR("%s: Can't find target by hash %d (seq %#llx). Targets (%d):\n",\r\nfld->lcf_name, hash, seq, fld->lcf_count);\r\nlist_for_each_entry(target, &fld->lcf_targets, ft_chain) {\r\nconst char *srv_name = target->ft_srv ?\r\ntarget->ft_srv->lsf_name : "<null>";\r\nconst char *exp_name = target->ft_exp ?\r\n(char *)target->ft_exp->exp_obd->obd_uuid.uuid :\r\n"<null>";\r\nCERROR(" exp: 0x%p (%s), srv: 0x%p (%s), idx: %llu\n",\r\ntarget->ft_exp, exp_name, target->ft_srv,\r\nsrv_name, target->ft_idx);\r\n}\r\nLBUG();\r\nreturn NULL;\r\n}\r\nstatic struct lu_fld_target *\r\nfld_client_get_target(struct lu_client_fld *fld, u64 seq)\r\n{\r\nstruct lu_fld_target *target;\r\nLASSERT(fld->lcf_hash);\r\nspin_lock(&fld->lcf_lock);\r\ntarget = fld->lcf_hash->fh_scan_func(fld, seq);\r\nspin_unlock(&fld->lcf_lock);\r\nif (target) {\r\nCDEBUG(D_INFO, "%s: Found target (idx %llu) by seq %#llx\n",\r\nfld->lcf_name, target->ft_idx, seq);\r\n}\r\nreturn target;\r\n}\r\nint fld_client_add_target(struct lu_client_fld *fld,\r\nstruct lu_fld_target *tar)\r\n{\r\nconst char *name;\r\nstruct lu_fld_target *target, *tmp;\r\nLASSERT(tar);\r\nname = fld_target_name(tar);\r\nLASSERT(name);\r\nLASSERT(tar->ft_srv || tar->ft_exp);\r\nCDEBUG(D_INFO, "%s: Adding target %s (idx %llu)\n",\r\nfld->lcf_name, name, tar->ft_idx);\r\ntarget = kzalloc(sizeof(*target), GFP_NOFS);\r\nif (!target)\r\nreturn -ENOMEM;\r\nspin_lock(&fld->lcf_lock);\r\nlist_for_each_entry(tmp, &fld->lcf_targets, ft_chain) {\r\nif (tmp->ft_idx == tar->ft_idx) {\r\nspin_unlock(&fld->lcf_lock);\r\nkfree(target);\r\nCERROR("Target %s exists in FLD and known as %s:#%llu\n",\r\nname, fld_target_name(tmp), tmp->ft_idx);\r\nreturn -EEXIST;\r\n}\r\n}\r\ntarget->ft_exp = tar->ft_exp;\r\nif (target->ft_exp)\r\nclass_export_get(target->ft_exp);\r\ntarget->ft_srv = tar->ft_srv;\r\ntarget->ft_idx = tar->ft_idx;\r\nlist_add_tail(&target->ft_chain, &fld->lcf_targets);\r\nfld->lcf_count++;\r\nspin_unlock(&fld->lcf_lock);\r\nreturn 0;\r\n}\r\nint fld_client_del_target(struct lu_client_fld *fld, __u64 idx)\r\n{\r\nstruct lu_fld_target *target, *tmp;\r\nspin_lock(&fld->lcf_lock);\r\nlist_for_each_entry_safe(target, tmp, &fld->lcf_targets, ft_chain) {\r\nif (target->ft_idx == idx) {\r\nfld->lcf_count--;\r\nlist_del(&target->ft_chain);\r\nspin_unlock(&fld->lcf_lock);\r\nif (target->ft_exp)\r\nclass_export_put(target->ft_exp);\r\nkfree(target);\r\nreturn 0;\r\n}\r\n}\r\nspin_unlock(&fld->lcf_lock);\r\nreturn -ENOENT;\r\n}\r\nstatic int fld_client_debugfs_init(struct lu_client_fld *fld)\r\n{\r\nint rc;\r\nfld->lcf_debugfs_entry = ldebugfs_register(fld->lcf_name,\r\nfld_debugfs_dir,\r\nNULL, NULL);\r\nif (IS_ERR_OR_NULL(fld->lcf_debugfs_entry)) {\r\nCERROR("%s: LdebugFS failed in fld-init\n", fld->lcf_name);\r\nrc = fld->lcf_debugfs_entry ? PTR_ERR(fld->lcf_debugfs_entry)\r\n: -ENOMEM;\r\nfld->lcf_debugfs_entry = NULL;\r\nreturn rc;\r\n}\r\nrc = ldebugfs_add_vars(fld->lcf_debugfs_entry,\r\nfld_client_debugfs_list, fld);\r\nif (rc) {\r\nCERROR("%s: Can't init FLD debufs, rc %d\n", fld->lcf_name, rc);\r\ngoto out_cleanup;\r\n}\r\nreturn 0;\r\nout_cleanup:\r\nfld_client_debugfs_fini(fld);\r\nreturn rc;\r\n}\r\nvoid fld_client_debugfs_fini(struct lu_client_fld *fld)\r\n{\r\nif (!IS_ERR_OR_NULL(fld->lcf_debugfs_entry))\r\nldebugfs_remove(&fld->lcf_debugfs_entry);\r\n}\r\nstatic inline int hash_is_sane(int hash)\r\n{\r\nreturn (hash >= 0 && hash < ARRAY_SIZE(fld_hash));\r\n}\r\nint fld_client_init(struct lu_client_fld *fld,\r\nconst char *prefix, int hash)\r\n{\r\nint cache_size, cache_threshold;\r\nint rc;\r\nsnprintf(fld->lcf_name, sizeof(fld->lcf_name),\r\n"cli-%s", prefix);\r\nif (!hash_is_sane(hash)) {\r\nCERROR("%s: Wrong hash function %#x\n",\r\nfld->lcf_name, hash);\r\nreturn -EINVAL;\r\n}\r\nfld->lcf_count = 0;\r\nspin_lock_init(&fld->lcf_lock);\r\nfld->lcf_hash = &fld_hash[hash];\r\nINIT_LIST_HEAD(&fld->lcf_targets);\r\ncache_size = FLD_CLIENT_CACHE_SIZE /\r\nsizeof(struct fld_cache_entry);\r\ncache_threshold = cache_size *\r\nFLD_CLIENT_CACHE_THRESHOLD / 100;\r\nfld->lcf_cache = fld_cache_init(fld->lcf_name,\r\ncache_size, cache_threshold);\r\nif (IS_ERR(fld->lcf_cache)) {\r\nrc = PTR_ERR(fld->lcf_cache);\r\nfld->lcf_cache = NULL;\r\ngoto out;\r\n}\r\nrc = fld_client_debugfs_init(fld);\r\nif (rc)\r\ngoto out;\r\nout:\r\nif (rc)\r\nfld_client_fini(fld);\r\nelse\r\nCDEBUG(D_INFO, "%s: Using \"%s\" hash\n",\r\nfld->lcf_name, fld->lcf_hash->fh_name);\r\nreturn rc;\r\n}\r\nvoid fld_client_fini(struct lu_client_fld *fld)\r\n{\r\nstruct lu_fld_target *target, *tmp;\r\nspin_lock(&fld->lcf_lock);\r\nlist_for_each_entry_safe(target, tmp, &fld->lcf_targets, ft_chain) {\r\nfld->lcf_count--;\r\nlist_del(&target->ft_chain);\r\nif (target->ft_exp)\r\nclass_export_put(target->ft_exp);\r\nkfree(target);\r\n}\r\nspin_unlock(&fld->lcf_lock);\r\nif (fld->lcf_cache) {\r\nif (!IS_ERR(fld->lcf_cache))\r\nfld_cache_fini(fld->lcf_cache);\r\nfld->lcf_cache = NULL;\r\n}\r\n}\r\nint fld_client_rpc(struct obd_export *exp,\r\nstruct lu_seq_range *range, __u32 fld_op,\r\nstruct ptlrpc_request **reqp)\r\n{\r\nstruct ptlrpc_request *req = NULL;\r\nstruct lu_seq_range *prange;\r\n__u32 *op;\r\nint rc = 0;\r\nstruct obd_import *imp;\r\nLASSERT(exp);\r\nimp = class_exp2cliimp(exp);\r\nswitch (fld_op) {\r\ncase FLD_QUERY:\r\nreq = ptlrpc_request_alloc_pack(imp, &RQF_FLD_QUERY,\r\nLUSTRE_MDS_VERSION, FLD_QUERY);\r\nif (!req)\r\nreturn -ENOMEM;\r\nop = req_capsule_client_get(&req->rq_pill, &RMF_FLD_OPC);\r\n*op = FLD_LOOKUP;\r\nif (imp->imp_connect_flags_orig & OBD_CONNECT_MDS_MDS)\r\nreq->rq_allow_replay = 1;\r\nbreak;\r\ncase FLD_READ:\r\nreq = ptlrpc_request_alloc_pack(imp, &RQF_FLD_READ,\r\nLUSTRE_MDS_VERSION, FLD_READ);\r\nif (!req)\r\nreturn -ENOMEM;\r\nreq_capsule_set_size(&req->rq_pill, &RMF_GENERIC_DATA,\r\nRCL_SERVER, PAGE_SIZE);\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\nif (rc)\r\nreturn rc;\r\nprange = req_capsule_client_get(&req->rq_pill, &RMF_FLD_MDFLD);\r\n*prange = *range;\r\nptlrpc_request_set_replen(req);\r\nreq->rq_request_portal = FLD_REQUEST_PORTAL;\r\nreq->rq_reply_portal = MDC_REPLY_PORTAL;\r\nptlrpc_at_set_req_timeout(req);\r\nobd_get_request_slot(&exp->exp_obd->u.cli);\r\nrc = ptlrpc_queue_wait(req);\r\nobd_put_request_slot(&exp->exp_obd->u.cli);\r\nif (rc)\r\ngoto out_req;\r\nif (fld_op == FLD_QUERY) {\r\nprange = req_capsule_server_get(&req->rq_pill, &RMF_FLD_MDFLD);\r\nif (!prange) {\r\nrc = -EFAULT;\r\ngoto out_req;\r\n}\r\n*range = *prange;\r\n}\r\nout_req:\r\nif (rc || !reqp) {\r\nptlrpc_req_finished(req);\r\nreq = NULL;\r\n}\r\nif (reqp)\r\n*reqp = req;\r\nreturn rc;\r\n}\r\nint fld_client_lookup(struct lu_client_fld *fld, u64 seq, u32 *mds,\r\n__u32 flags, const struct lu_env *env)\r\n{\r\nstruct lu_seq_range res = { 0 };\r\nstruct lu_fld_target *target;\r\nint rc;\r\nrc = fld_cache_lookup(fld->lcf_cache, seq, &res);\r\nif (rc == 0) {\r\n*mds = res.lsr_index;\r\nreturn 0;\r\n}\r\ntarget = fld_client_get_target(fld, seq);\r\nLASSERT(target);\r\nCDEBUG(D_INFO, "%s: Lookup fld entry (seq: %#llx) on target %s (idx %llu)\n",\r\nfld->lcf_name, seq, fld_target_name(target), target->ft_idx);\r\nres.lsr_start = seq;\r\nfld_range_set_type(&res, flags);\r\nrc = fld_client_rpc(target->ft_exp, &res, FLD_QUERY, NULL);\r\nif (rc == 0) {\r\n*mds = res.lsr_index;\r\nfld_cache_insert(fld->lcf_cache, &res);\r\n}\r\nreturn rc;\r\n}\r\nvoid fld_client_flush(struct lu_client_fld *fld)\r\n{\r\nfld_cache_flush(fld->lcf_cache);\r\n}\r\nstatic int __init fld_init(void)\r\n{\r\nfld_debugfs_dir = ldebugfs_register(LUSTRE_FLD_NAME,\r\ndebugfs_lustre_root,\r\nNULL, NULL);\r\nreturn PTR_ERR_OR_ZERO(fld_debugfs_dir);\r\n}\r\nstatic void __exit fld_exit(void)\r\n{\r\nif (!IS_ERR_OR_NULL(fld_debugfs_dir))\r\nldebugfs_remove(&fld_debugfs_dir);\r\n}
