static inline void __iomem *combiner_base(struct irq_data *data)\r\n{\r\nstruct combiner_chip_data *combiner_data =\r\nirq_data_get_irq_chip_data(data);\r\nreturn combiner_data->base;\r\n}\r\nstatic void combiner_mask_irq(struct irq_data *data)\r\n{\r\nu32 mask = 1 << (data->hwirq % 32);\r\nwritel_relaxed(mask, combiner_base(data) + COMBINER_ENABLE_CLEAR);\r\n}\r\nstatic void combiner_unmask_irq(struct irq_data *data)\r\n{\r\nu32 mask = 1 << (data->hwirq % 32);\r\nwritel_relaxed(mask, combiner_base(data) + COMBINER_ENABLE_SET);\r\n}\r\nstatic void combiner_handle_cascade_irq(struct irq_desc *desc)\r\n{\r\nstruct combiner_chip_data *chip_data = irq_desc_get_handler_data(desc);\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nunsigned int cascade_irq, combiner_irq;\r\nunsigned long status;\r\nchained_irq_enter(chip, desc);\r\nspin_lock(&irq_controller_lock);\r\nstatus = readl_relaxed(chip_data->base + COMBINER_INT_STATUS);\r\nspin_unlock(&irq_controller_lock);\r\nstatus &= chip_data->irq_mask;\r\nif (status == 0)\r\ngoto out;\r\ncombiner_irq = chip_data->hwirq_offset + __ffs(status);\r\ncascade_irq = irq_find_mapping(combiner_irq_domain, combiner_irq);\r\nif (unlikely(!cascade_irq))\r\nhandle_bad_irq(desc);\r\nelse\r\ngeneric_handle_irq(cascade_irq);\r\nout:\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int combiner_set_affinity(struct irq_data *d,\r\nconst struct cpumask *mask_val, bool force)\r\n{\r\nstruct combiner_chip_data *chip_data = irq_data_get_irq_chip_data(d);\r\nstruct irq_chip *chip = irq_get_chip(chip_data->parent_irq);\r\nstruct irq_data *data = irq_get_irq_data(chip_data->parent_irq);\r\nif (chip && chip->irq_set_affinity)\r\nreturn chip->irq_set_affinity(data, mask_val, force);\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic void __init combiner_cascade_irq(struct combiner_chip_data *combiner_data,\r\nunsigned int irq)\r\n{\r\nirq_set_chained_handler_and_data(irq, combiner_handle_cascade_irq,\r\ncombiner_data);\r\n}\r\nstatic void __init combiner_init_one(struct combiner_chip_data *combiner_data,\r\nunsigned int combiner_nr,\r\nvoid __iomem *base, unsigned int irq)\r\n{\r\ncombiner_data->base = base;\r\ncombiner_data->hwirq_offset = (combiner_nr & ~3) * IRQ_IN_COMBINER;\r\ncombiner_data->irq_mask = 0xff << ((combiner_nr % 4) << 3);\r\ncombiner_data->parent_irq = irq;\r\nwritel_relaxed(combiner_data->irq_mask, base + COMBINER_ENABLE_CLEAR);\r\n}\r\nstatic int combiner_irq_domain_xlate(struct irq_domain *d,\r\nstruct device_node *controller,\r\nconst u32 *intspec, unsigned int intsize,\r\nunsigned long *out_hwirq,\r\nunsigned int *out_type)\r\n{\r\nif (irq_domain_get_of_node(d) != controller)\r\nreturn -EINVAL;\r\nif (intsize < 2)\r\nreturn -EINVAL;\r\n*out_hwirq = intspec[0] * IRQ_IN_COMBINER + intspec[1];\r\n*out_type = 0;\r\nreturn 0;\r\n}\r\nstatic int combiner_irq_domain_map(struct irq_domain *d, unsigned int irq,\r\nirq_hw_number_t hw)\r\n{\r\nstruct combiner_chip_data *combiner_data = d->host_data;\r\nirq_set_chip_and_handler(irq, &combiner_chip, handle_level_irq);\r\nirq_set_chip_data(irq, &combiner_data[hw >> 3]);\r\nirq_set_probe(irq);\r\nreturn 0;\r\n}\r\nstatic void __init combiner_init(void __iomem *combiner_base,\r\nstruct device_node *np)\r\n{\r\nint i, irq;\r\nunsigned int nr_irq;\r\nnr_irq = max_nr * IRQ_IN_COMBINER;\r\ncombiner_data = kcalloc(max_nr, sizeof (*combiner_data), GFP_KERNEL);\r\nif (!combiner_data) {\r\npr_warn("%s: could not allocate combiner data\n", __func__);\r\nreturn;\r\n}\r\ncombiner_irq_domain = irq_domain_add_linear(np, nr_irq,\r\n&combiner_irq_domain_ops, combiner_data);\r\nif (WARN_ON(!combiner_irq_domain)) {\r\npr_warn("%s: irq domain init failed\n", __func__);\r\nreturn;\r\n}\r\nfor (i = 0; i < max_nr; i++) {\r\nirq = irq_of_parse_and_map(np, i);\r\ncombiner_init_one(&combiner_data[i], i,\r\ncombiner_base + (i >> 2) * 0x10, irq);\r\ncombiner_cascade_irq(&combiner_data[i], irq);\r\n}\r\n}\r\nstatic int combiner_suspend(void)\r\n{\r\nint i;\r\nfor (i = 0; i < max_nr; i++)\r\ncombiner_data[i].pm_save =\r\nreadl_relaxed(combiner_data[i].base + COMBINER_ENABLE_SET);\r\nreturn 0;\r\n}\r\nstatic void combiner_resume(void)\r\n{\r\nint i;\r\nfor (i = 0; i < max_nr; i++) {\r\nwritel_relaxed(combiner_data[i].irq_mask,\r\ncombiner_data[i].base + COMBINER_ENABLE_CLEAR);\r\nwritel_relaxed(combiner_data[i].pm_save,\r\ncombiner_data[i].base + COMBINER_ENABLE_SET);\r\n}\r\n}\r\nstatic int __init combiner_of_init(struct device_node *np,\r\nstruct device_node *parent)\r\n{\r\nvoid __iomem *combiner_base;\r\ncombiner_base = of_iomap(np, 0);\r\nif (!combiner_base) {\r\npr_err("%s: failed to map combiner registers\n", __func__);\r\nreturn -ENXIO;\r\n}\r\nif (of_property_read_u32(np, "samsung,combiner-nr", &max_nr)) {\r\npr_info("%s: number of combiners not specified, "\r\n"setting default as %d.\n",\r\n__func__, max_nr);\r\n}\r\ncombiner_init(combiner_base, np);\r\nregister_syscore_ops(&combiner_syscore_ops);\r\nreturn 0;\r\n}
