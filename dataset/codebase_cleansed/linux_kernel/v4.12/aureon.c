static void aureon_pca9554_write(struct snd_ice1712 *ice, unsigned char reg,\r\nunsigned char data)\r\n{\r\nunsigned int tmp;\r\nint i, j;\r\nunsigned char dev = PCA9554_DEV;\r\nunsigned char val = 0;\r\ntmp = snd_ice1712_gpio_read(ice);\r\nsnd_ice1712_gpio_set_mask(ice, ~(AUREON_SPI_MOSI|AUREON_SPI_CLK|\r\nAUREON_WM_RW|AUREON_WM_CS|\r\nAUREON_CS8415_CS));\r\ntmp |= AUREON_WM_RW;\r\ntmp |= AUREON_CS8415_CS | AUREON_WM_CS;\r\ntmp &= ~AUREON_SPI_MOSI;\r\ntmp &= ~AUREON_SPI_CLK;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(50);\r\ntmp |= AUREON_SPI_CLK;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(50);\r\ntmp |= AUREON_SPI_MOSI;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(100);\r\ntmp &= ~AUREON_SPI_MOSI;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(50);\r\ntmp &= ~AUREON_SPI_CLK;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(100);\r\nfor (j = 0; j < 3; j++) {\r\nswitch (j) {\r\ncase 0:\r\nval = dev;\r\nbreak;\r\ncase 1:\r\nval = reg;\r\nbreak;\r\ncase 2:\r\nval = data;\r\nbreak;\r\n}\r\nfor (i = 7; i >= 0; i--) {\r\ntmp &= ~AUREON_SPI_CLK;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(40);\r\nif (val & (1 << i))\r\ntmp |= AUREON_SPI_MOSI;\r\nelse\r\ntmp &= ~AUREON_SPI_MOSI;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(40);\r\ntmp |= AUREON_SPI_CLK;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(40);\r\n}\r\ntmp &= ~AUREON_SPI_CLK;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(40);\r\ntmp |= AUREON_SPI_CLK;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(40);\r\ntmp &= ~AUREON_SPI_CLK;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(40);\r\n}\r\ntmp &= ~AUREON_SPI_CLK;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(40);\r\ntmp &= ~AUREON_SPI_MOSI;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(40);\r\ntmp |= AUREON_SPI_CLK;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(50);\r\ntmp |= AUREON_SPI_MOSI;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(100);\r\n}\r\nstatic int aureon_universe_inmux_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char * const texts[3] =\r\n{"Internal Aux", "Wavetable", "Rear Line-In"};\r\nreturn snd_ctl_enum_info(uinfo, 1, 3, texts);\r\n}\r\nstatic int aureon_universe_inmux_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct aureon_spec *spec = ice->spec;\r\nucontrol->value.enumerated.item[0] = spec->pca9554_out;\r\nreturn 0;\r\n}\r\nstatic int aureon_universe_inmux_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct aureon_spec *spec = ice->spec;\r\nunsigned char oval, nval;\r\nint change;\r\nnval = ucontrol->value.enumerated.item[0];\r\nif (nval >= 3)\r\nreturn -EINVAL;\r\nsnd_ice1712_save_gpio_status(ice);\r\noval = spec->pca9554_out;\r\nchange = (oval != nval);\r\nif (change) {\r\naureon_pca9554_write(ice, PCA9554_OUT, nval);\r\nspec->pca9554_out = nval;\r\n}\r\nsnd_ice1712_restore_gpio_status(ice);\r\nreturn change;\r\n}\r\nstatic void aureon_ac97_write(struct snd_ice1712 *ice, unsigned short reg,\r\nunsigned short val)\r\n{\r\nstruct aureon_spec *spec = ice->spec;\r\nunsigned int tmp;\r\ntmp = (snd_ice1712_gpio_read(ice) & ~0xFF) | (reg & 0x7F);\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(10);\r\ntmp |= AUREON_AC97_ADDR;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(10);\r\ntmp &= ~AUREON_AC97_ADDR;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(10);\r\ntmp &= ~AUREON_AC97_DATA_MASK;\r\ntmp |= val & AUREON_AC97_DATA_MASK;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(10);\r\ntmp |= AUREON_AC97_DATA_LOW;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(10);\r\ntmp &= ~AUREON_AC97_DATA_LOW;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(10);\r\ntmp &= ~AUREON_AC97_DATA_MASK;\r\ntmp |= (val >> 8) & AUREON_AC97_DATA_MASK;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(10);\r\ntmp |= AUREON_AC97_DATA_HIGH;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(10);\r\ntmp &= ~AUREON_AC97_DATA_HIGH;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(10);\r\ntmp |= AUREON_AC97_COMMIT;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(10);\r\ntmp &= ~AUREON_AC97_COMMIT;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(10);\r\nspec->stac9744[(reg & 0x7F) >> 1] = val;\r\n}\r\nstatic unsigned short aureon_ac97_read(struct snd_ice1712 *ice, unsigned short reg)\r\n{\r\nstruct aureon_spec *spec = ice->spec;\r\nreturn spec->stac9744[(reg & 0x7F) >> 1];\r\n}\r\nstatic int aureon_ac97_init(struct snd_ice1712 *ice)\r\n{\r\nstruct aureon_spec *spec = ice->spec;\r\nint i;\r\nstatic const unsigned short ac97_defaults[] = {\r\n0x00, 0x9640,\r\n0x02, 0x8000,\r\n0x04, 0x8000,\r\n0x06, 0x8000,\r\n0x0C, 0x8008,\r\n0x0E, 0x8008,\r\n0x10, 0x8808,\r\n0x12, 0x8808,\r\n0x14, 0x8808,\r\n0x16, 0x8808,\r\n0x18, 0x8808,\r\n0x1C, 0x8000,\r\n0x26, 0x000F,\r\n0x28, 0x0201,\r\n0x2C, 0xBB80,\r\n0x32, 0xBB80,\r\n0x7C, 0x8384,\r\n0x7E, 0x7644,\r\n(unsigned short)-1\r\n};\r\nunsigned int tmp;\r\ntmp = (snd_ice1712_gpio_read(ice) | AUREON_AC97_RESET) & ~AUREON_AC97_DATA_MASK;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(3);\r\ntmp &= ~AUREON_AC97_RESET;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(3);\r\ntmp |= AUREON_AC97_RESET;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(3);\r\nmemset(&spec->stac9744, 0, sizeof(spec->stac9744));\r\nfor (i = 0; ac97_defaults[i] != (unsigned short)-1; i += 2)\r\nspec->stac9744[(ac97_defaults[i]) >> 1] = ac97_defaults[i+1];\r\naureon_ac97_write(ice, AC97_MASTER, 0x0000);\r\nreturn 0;\r\n}\r\nstatic int aureon_ac97_vol_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = kcontrol->private_value & AUREON_AC97_STEREO ? 2 : 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 31;\r\nreturn 0;\r\n}\r\nstatic int aureon_ac97_vol_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned short vol;\r\nmutex_lock(&ice->gpio_mutex);\r\nvol = aureon_ac97_read(ice, kcontrol->private_value & 0x7F);\r\nucontrol->value.integer.value[0] = 0x1F - (vol & 0x1F);\r\nif (kcontrol->private_value & AUREON_AC97_STEREO)\r\nucontrol->value.integer.value[1] = 0x1F - ((vol >> 8) & 0x1F);\r\nmutex_unlock(&ice->gpio_mutex);\r\nreturn 0;\r\n}\r\nstatic int aureon_ac97_vol_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned short ovol, nvol;\r\nint change;\r\nsnd_ice1712_save_gpio_status(ice);\r\novol = aureon_ac97_read(ice, kcontrol->private_value & 0x7F);\r\nnvol = (0x1F - ucontrol->value.integer.value[0]) & 0x001F;\r\nif (kcontrol->private_value & AUREON_AC97_STEREO)\r\nnvol |= ((0x1F - ucontrol->value.integer.value[1]) << 8) & 0x1F00;\r\nnvol |= ovol & ~0x1F1F;\r\nchange = (ovol != nvol);\r\nif (change)\r\naureon_ac97_write(ice, kcontrol->private_value & 0x7F, nvol);\r\nsnd_ice1712_restore_gpio_status(ice);\r\nreturn change;\r\n}\r\nstatic int aureon_ac97_mute_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&ice->gpio_mutex);\r\nucontrol->value.integer.value[0] = aureon_ac97_read(ice,\r\nkcontrol->private_value & 0x7F) & 0x8000 ? 0 : 1;\r\nmutex_unlock(&ice->gpio_mutex);\r\nreturn 0;\r\n}\r\nstatic int aureon_ac97_mute_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned short ovol, nvol;\r\nint change;\r\nsnd_ice1712_save_gpio_status(ice);\r\novol = aureon_ac97_read(ice, kcontrol->private_value & 0x7F);\r\nnvol = (ucontrol->value.integer.value[0] ? 0x0000 : 0x8000) | (ovol & ~0x8000);\r\nchange = (ovol != nvol);\r\nif (change)\r\naureon_ac97_write(ice, kcontrol->private_value & 0x7F, nvol);\r\nsnd_ice1712_restore_gpio_status(ice);\r\nreturn change;\r\n}\r\nstatic int aureon_ac97_micboost_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&ice->gpio_mutex);\r\nucontrol->value.integer.value[0] = aureon_ac97_read(ice, AC97_MIC) & 0x0020 ? 0 : 1;\r\nmutex_unlock(&ice->gpio_mutex);\r\nreturn 0;\r\n}\r\nstatic int aureon_ac97_micboost_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned short ovol, nvol;\r\nint change;\r\nsnd_ice1712_save_gpio_status(ice);\r\novol = aureon_ac97_read(ice, AC97_MIC);\r\nnvol = (ucontrol->value.integer.value[0] ? 0x0000 : 0x0020) | (ovol & ~0x0020);\r\nchange = (ovol != nvol);\r\nif (change)\r\naureon_ac97_write(ice, AC97_MIC, nvol);\r\nsnd_ice1712_restore_gpio_status(ice);\r\nreturn change;\r\n}\r\nstatic void aureon_spi_write(struct snd_ice1712 *ice, unsigned int cs, unsigned int data, int bits)\r\n{\r\nunsigned int tmp;\r\nint i;\r\nunsigned int mosi, clk;\r\ntmp = snd_ice1712_gpio_read(ice);\r\nif (ice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71LT ||\r\nice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71XT) {\r\nsnd_ice1712_gpio_set_mask(ice, ~(PRODIGY_SPI_MOSI|PRODIGY_SPI_CLK|PRODIGY_WM_CS));\r\nmosi = PRODIGY_SPI_MOSI;\r\nclk = PRODIGY_SPI_CLK;\r\n} else {\r\nsnd_ice1712_gpio_set_mask(ice, ~(AUREON_WM_RW|AUREON_SPI_MOSI|AUREON_SPI_CLK|\r\nAUREON_WM_CS|AUREON_CS8415_CS));\r\nmosi = AUREON_SPI_MOSI;\r\nclk = AUREON_SPI_CLK;\r\ntmp |= AUREON_WM_RW;\r\n}\r\ntmp &= ~cs;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\nfor (i = bits - 1; i >= 0; i--) {\r\ntmp &= ~clk;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\nif (data & (1 << i))\r\ntmp |= mosi;\r\nelse\r\ntmp &= ~mosi;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\ntmp |= clk;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\n}\r\ntmp &= ~clk;\r\ntmp |= cs;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\ntmp |= clk;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\n}\r\nstatic void aureon_spi_read(struct snd_ice1712 *ice, unsigned int cs,\r\nunsigned int data, int bits, unsigned char *buffer, int size)\r\n{\r\nint i, j;\r\nunsigned int tmp;\r\ntmp = (snd_ice1712_gpio_read(ice) & ~AUREON_SPI_CLK) | AUREON_CS8415_CS|AUREON_WM_CS;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\ntmp &= ~cs;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\nfor (i = bits-1; i >= 0; i--) {\r\nif (data & (1 << i))\r\ntmp |= AUREON_SPI_MOSI;\r\nelse\r\ntmp &= ~AUREON_SPI_MOSI;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\ntmp |= AUREON_SPI_CLK;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\ntmp &= ~AUREON_SPI_CLK;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\n}\r\nfor (j = 0; j < size; j++) {\r\nunsigned char outdata = 0;\r\nfor (i = 7; i >= 0; i--) {\r\ntmp = snd_ice1712_gpio_read(ice);\r\noutdata <<= 1;\r\noutdata |= (tmp & AUREON_SPI_MISO) ? 1 : 0;\r\nudelay(1);\r\ntmp |= AUREON_SPI_CLK;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\ntmp &= ~AUREON_SPI_CLK;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\n}\r\nbuffer[j] = outdata;\r\n}\r\ntmp |= cs;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\n}\r\nstatic unsigned char aureon_cs8415_get(struct snd_ice1712 *ice, int reg)\r\n{\r\nunsigned char val;\r\naureon_spi_write(ice, AUREON_CS8415_CS, 0x2000 | reg, 16);\r\naureon_spi_read(ice, AUREON_CS8415_CS, 0x21, 8, &val, 1);\r\nreturn val;\r\n}\r\nstatic void aureon_cs8415_read(struct snd_ice1712 *ice, int reg,\r\nunsigned char *buffer, int size)\r\n{\r\naureon_spi_write(ice, AUREON_CS8415_CS, 0x2000 | reg, 16);\r\naureon_spi_read(ice, AUREON_CS8415_CS, 0x21, 8, buffer, size);\r\n}\r\nstatic void aureon_cs8415_put(struct snd_ice1712 *ice, int reg,\r\nunsigned char val)\r\n{\r\naureon_spi_write(ice, AUREON_CS8415_CS, 0x200000 | (reg << 8) | val, 24);\r\n}\r\nstatic unsigned short wm_get(struct snd_ice1712 *ice, int reg)\r\n{\r\nreg <<= 1;\r\nreturn ((unsigned short)ice->akm[0].images[reg] << 8) |\r\nice->akm[0].images[reg + 1];\r\n}\r\nstatic void wm_put_nocache(struct snd_ice1712 *ice, int reg, unsigned short val)\r\n{\r\naureon_spi_write(ice,\r\n((ice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71LT ||\r\nice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71XT) ?\r\nPRODIGY_WM_CS : AUREON_WM_CS),\r\n(reg << 9) | (val & 0x1ff), 16);\r\n}\r\nstatic void wm_put(struct snd_ice1712 *ice, int reg, unsigned short val)\r\n{\r\nwm_put_nocache(ice, reg, val);\r\nreg <<= 1;\r\nice->akm[0].images[reg] = val >> 8;\r\nice->akm[0].images[reg + 1] = val;\r\n}\r\nstatic int aureon_ac97_mmute_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&ice->gpio_mutex);\r\nucontrol->value.integer.value[0] = (wm_get(ice, WM_OUT_MUX1) >> 1) & 0x01;\r\nmutex_unlock(&ice->gpio_mutex);\r\nreturn 0;\r\n}\r\nstatic int aureon_ac97_mmute_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned short ovol, nvol;\r\nint change;\r\nsnd_ice1712_save_gpio_status(ice);\r\novol = wm_get(ice, WM_OUT_MUX1);\r\nnvol = (ovol & ~0x02) | (ucontrol->value.integer.value[0] ? 0x02 : 0x00);\r\nchange = (ovol != nvol);\r\nif (change)\r\nwm_put(ice, WM_OUT_MUX1, nvol);\r\nsnd_ice1712_restore_gpio_status(ice);\r\nreturn change;\r\n}\r\nstatic void wm_set_vol(struct snd_ice1712 *ice, unsigned int index, unsigned short vol, unsigned short master)\r\n{\r\nunsigned char nvol;\r\nif ((master & WM_VOL_MUTE) || (vol & WM_VOL_MUTE)) {\r\nnvol = 0;\r\n} else {\r\nnvol = ((vol % WM_VOL_CNT) * (master % WM_VOL_CNT)) /\r\nWM_VOL_MAX;\r\nnvol += 0x1b;\r\n}\r\nwm_put(ice, index, nvol);\r\nwm_put_nocache(ice, index, 0x180 | nvol);\r\n}\r\nstatic int wm_pcm_mute_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&ice->gpio_mutex);\r\nucontrol->value.integer.value[0] = (wm_get(ice, WM_MUTE) & 0x10) ? 0 : 1;\r\nmutex_unlock(&ice->gpio_mutex);\r\nreturn 0;\r\n}\r\nstatic int wm_pcm_mute_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned short nval, oval;\r\nint change;\r\nsnd_ice1712_save_gpio_status(ice);\r\noval = wm_get(ice, WM_MUTE);\r\nnval = (oval & ~0x10) | (ucontrol->value.integer.value[0] ? 0 : 0x10);\r\nchange = (oval != nval);\r\nif (change)\r\nwm_put(ice, WM_MUTE, nval);\r\nsnd_ice1712_restore_gpio_status(ice);\r\nreturn change;\r\n}\r\nstatic int wm_master_vol_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = WM_VOL_MAX;\r\nreturn 0;\r\n}\r\nstatic int wm_master_vol_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct aureon_spec *spec = ice->spec;\r\nint i;\r\nfor (i = 0; i < 2; i++)\r\nucontrol->value.integer.value[i] =\r\nspec->master[i] & ~WM_VOL_MUTE;\r\nreturn 0;\r\n}\r\nstatic int wm_master_vol_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct aureon_spec *spec = ice->spec;\r\nint ch, change = 0;\r\nsnd_ice1712_save_gpio_status(ice);\r\nfor (ch = 0; ch < 2; ch++) {\r\nunsigned int vol = ucontrol->value.integer.value[ch];\r\nif (vol > WM_VOL_MAX)\r\nvol = WM_VOL_MAX;\r\nvol |= spec->master[ch] & WM_VOL_MUTE;\r\nif (vol != spec->master[ch]) {\r\nint dac;\r\nspec->master[ch] = vol;\r\nfor (dac = 0; dac < ice->num_total_dacs; dac += 2)\r\nwm_set_vol(ice, WM_DAC_ATTEN + dac + ch,\r\nspec->vol[dac + ch],\r\nspec->master[ch]);\r\nchange = 1;\r\n}\r\n}\r\nsnd_ice1712_restore_gpio_status(ice);\r\nreturn change;\r\n}\r\nstatic int wm_vol_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nint voices = kcontrol->private_value >> 8;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = voices;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = WM_VOL_MAX;\r\nreturn 0;\r\n}\r\nstatic int wm_vol_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct aureon_spec *spec = ice->spec;\r\nint i, ofs, voices;\r\nvoices = kcontrol->private_value >> 8;\r\nofs = kcontrol->private_value & 0xff;\r\nfor (i = 0; i < voices; i++)\r\nucontrol->value.integer.value[i] =\r\nspec->vol[ofs+i] & ~WM_VOL_MUTE;\r\nreturn 0;\r\n}\r\nstatic int wm_vol_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct aureon_spec *spec = ice->spec;\r\nint i, idx, ofs, voices;\r\nint change = 0;\r\nvoices = kcontrol->private_value >> 8;\r\nofs = kcontrol->private_value & 0xff;\r\nsnd_ice1712_save_gpio_status(ice);\r\nfor (i = 0; i < voices; i++) {\r\nunsigned int vol = ucontrol->value.integer.value[i];\r\nif (vol > WM_VOL_MAX)\r\nvol = WM_VOL_MAX;\r\nvol |= spec->vol[ofs+i] & WM_VOL_MUTE;\r\nif (vol != spec->vol[ofs+i]) {\r\nspec->vol[ofs+i] = vol;\r\nidx = WM_DAC_ATTEN + ofs + i;\r\nwm_set_vol(ice, idx, spec->vol[ofs + i],\r\nspec->master[i]);\r\nchange = 1;\r\n}\r\n}\r\nsnd_ice1712_restore_gpio_status(ice);\r\nreturn change;\r\n}\r\nstatic int wm_mute_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = kcontrol->private_value >> 8;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nstatic int wm_mute_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct aureon_spec *spec = ice->spec;\r\nint voices, ofs, i;\r\nvoices = kcontrol->private_value >> 8;\r\nofs = kcontrol->private_value & 0xFF;\r\nfor (i = 0; i < voices; i++)\r\nucontrol->value.integer.value[i] =\r\n(spec->vol[ofs + i] & WM_VOL_MUTE) ? 0 : 1;\r\nreturn 0;\r\n}\r\nstatic int wm_mute_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct aureon_spec *spec = ice->spec;\r\nint change = 0, voices, ofs, i;\r\nvoices = kcontrol->private_value >> 8;\r\nofs = kcontrol->private_value & 0xFF;\r\nsnd_ice1712_save_gpio_status(ice);\r\nfor (i = 0; i < voices; i++) {\r\nint val = (spec->vol[ofs + i] & WM_VOL_MUTE) ? 0 : 1;\r\nif (ucontrol->value.integer.value[i] != val) {\r\nspec->vol[ofs + i] &= ~WM_VOL_MUTE;\r\nspec->vol[ofs + i] |=\r\nucontrol->value.integer.value[i] ? 0 : WM_VOL_MUTE;\r\nwm_set_vol(ice, ofs + i, spec->vol[ofs + i],\r\nspec->master[i]);\r\nchange = 1;\r\n}\r\n}\r\nsnd_ice1712_restore_gpio_status(ice);\r\nreturn change;\r\n}\r\nstatic int wm_master_mute_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct aureon_spec *spec = ice->spec;\r\nucontrol->value.integer.value[0] =\r\n(spec->master[0] & WM_VOL_MUTE) ? 0 : 1;\r\nucontrol->value.integer.value[1] =\r\n(spec->master[1] & WM_VOL_MUTE) ? 0 : 1;\r\nreturn 0;\r\n}\r\nstatic int wm_master_mute_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct aureon_spec *spec = ice->spec;\r\nint change = 0, i;\r\nsnd_ice1712_save_gpio_status(ice);\r\nfor (i = 0; i < 2; i++) {\r\nint val = (spec->master[i] & WM_VOL_MUTE) ? 0 : 1;\r\nif (ucontrol->value.integer.value[i] != val) {\r\nint dac;\r\nspec->master[i] &= ~WM_VOL_MUTE;\r\nspec->master[i] |=\r\nucontrol->value.integer.value[i] ? 0 : WM_VOL_MUTE;\r\nfor (dac = 0; dac < ice->num_total_dacs; dac += 2)\r\nwm_set_vol(ice, WM_DAC_ATTEN + dac + i,\r\nspec->vol[dac + i],\r\nspec->master[i]);\r\nchange = 1;\r\n}\r\n}\r\nsnd_ice1712_restore_gpio_status(ice);\r\nreturn change;\r\n}\r\nstatic int wm_pcm_vol_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = PCM_RES;\r\nreturn 0;\r\n}\r\nstatic int wm_pcm_vol_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned short val;\r\nmutex_lock(&ice->gpio_mutex);\r\nval = wm_get(ice, WM_DAC_DIG_MASTER_ATTEN) & 0xff;\r\nval = val > PCM_MIN ? (val - PCM_MIN) : 0;\r\nucontrol->value.integer.value[0] = val;\r\nmutex_unlock(&ice->gpio_mutex);\r\nreturn 0;\r\n}\r\nstatic int wm_pcm_vol_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned short ovol, nvol;\r\nint change = 0;\r\nnvol = ucontrol->value.integer.value[0];\r\nif (nvol > PCM_RES)\r\nreturn -EINVAL;\r\nsnd_ice1712_save_gpio_status(ice);\r\nnvol = (nvol ? (nvol + PCM_MIN) : 0) & 0xff;\r\novol = wm_get(ice, WM_DAC_DIG_MASTER_ATTEN) & 0xff;\r\nif (ovol != nvol) {\r\nwm_put(ice, WM_DAC_DIG_MASTER_ATTEN, nvol);\r\nwm_put_nocache(ice, WM_DAC_DIG_MASTER_ATTEN, nvol | 0x100);\r\nchange = 1;\r\n}\r\nsnd_ice1712_restore_gpio_status(ice);\r\nreturn change;\r\n}\r\nstatic int wm_adc_mute_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned short val;\r\nint i;\r\nmutex_lock(&ice->gpio_mutex);\r\nfor (i = 0; i < 2; i++) {\r\nval = wm_get(ice, WM_ADC_GAIN + i);\r\nucontrol->value.integer.value[i] = ~val>>5 & 0x1;\r\n}\r\nmutex_unlock(&ice->gpio_mutex);\r\nreturn 0;\r\n}\r\nstatic int wm_adc_mute_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned short new, old;\r\nint i, change = 0;\r\nsnd_ice1712_save_gpio_status(ice);\r\nfor (i = 0; i < 2; i++) {\r\nold = wm_get(ice, WM_ADC_GAIN + i);\r\nnew = (~ucontrol->value.integer.value[i]<<5&0x20) | (old&~0x20);\r\nif (new != old) {\r\nwm_put(ice, WM_ADC_GAIN + i, new);\r\nchange = 1;\r\n}\r\n}\r\nsnd_ice1712_restore_gpio_status(ice);\r\nreturn change;\r\n}\r\nstatic int wm_adc_vol_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 0x1f;\r\nreturn 0;\r\n}\r\nstatic int wm_adc_vol_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint i, idx;\r\nunsigned short vol;\r\nmutex_lock(&ice->gpio_mutex);\r\nfor (i = 0; i < 2; i++) {\r\nidx = WM_ADC_GAIN + i;\r\nvol = wm_get(ice, idx) & 0x1f;\r\nucontrol->value.integer.value[i] = vol;\r\n}\r\nmutex_unlock(&ice->gpio_mutex);\r\nreturn 0;\r\n}\r\nstatic int wm_adc_vol_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint i, idx;\r\nunsigned short ovol, nvol;\r\nint change = 0;\r\nsnd_ice1712_save_gpio_status(ice);\r\nfor (i = 0; i < 2; i++) {\r\nidx = WM_ADC_GAIN + i;\r\nnvol = ucontrol->value.integer.value[i] & 0x1f;\r\novol = wm_get(ice, idx);\r\nif ((ovol & 0x1f) != nvol) {\r\nwm_put(ice, idx, nvol | (ovol & ~0x1f));\r\nchange = 1;\r\n}\r\n}\r\nsnd_ice1712_restore_gpio_status(ice);\r\nreturn change;\r\n}\r\nstatic int wm_adc_mux_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char * const texts[] = {\r\n"CD",\r\n"Aux",\r\n"Line",\r\n"Mic",\r\n"AC97"\r\n};\r\nstatic const char * const universe_texts[] = {\r\n"Aux1",\r\n"CD",\r\n"Phono",\r\n"Line",\r\n"Aux2",\r\n"Mic",\r\n"Aux3",\r\n"AC97"\r\n};\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nif (ice->eeprom.subvendor == VT1724_SUBDEVICE_AUREON71_UNIVERSE)\r\nreturn snd_ctl_enum_info(uinfo, 2, 8, universe_texts);\r\nelse\r\nreturn snd_ctl_enum_info(uinfo, 2, 5, texts);\r\n}\r\nstatic int wm_adc_mux_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned short val;\r\nmutex_lock(&ice->gpio_mutex);\r\nval = wm_get(ice, WM_ADC_MUX);\r\nucontrol->value.enumerated.item[0] = val & 7;\r\nucontrol->value.enumerated.item[1] = (val >> 4) & 7;\r\nmutex_unlock(&ice->gpio_mutex);\r\nreturn 0;\r\n}\r\nstatic int wm_adc_mux_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned short oval, nval;\r\nint change;\r\nsnd_ice1712_save_gpio_status(ice);\r\noval = wm_get(ice, WM_ADC_MUX);\r\nnval = oval & ~0x77;\r\nnval |= ucontrol->value.enumerated.item[0] & 7;\r\nnval |= (ucontrol->value.enumerated.item[1] & 7) << 4;\r\nchange = (oval != nval);\r\nif (change)\r\nwm_put(ice, WM_ADC_MUX, nval);\r\nsnd_ice1712_restore_gpio_status(ice);\r\nreturn change;\r\n}\r\nstatic int aureon_cs8415_mux_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstatic const char * const aureon_texts[] = {\r\n"CD",\r\n"Optical"\r\n};\r\nstatic const char * const prodigy_texts[] = {\r\n"CD",\r\n"Coax"\r\n};\r\nif (ice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71)\r\nreturn snd_ctl_enum_info(uinfo, 1, 2, prodigy_texts);\r\nelse\r\nreturn snd_ctl_enum_info(uinfo, 1, 2, aureon_texts);\r\n}\r\nstatic int aureon_cs8415_mux_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct aureon_spec *spec = ice->spec;\r\nucontrol->value.enumerated.item[0] = spec->cs8415_mux;\r\nreturn 0;\r\n}\r\nstatic int aureon_cs8415_mux_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct aureon_spec *spec = ice->spec;\r\nunsigned short oval, nval;\r\nint change;\r\nsnd_ice1712_save_gpio_status(ice);\r\noval = aureon_cs8415_get(ice, CS8415_CTRL2);\r\nnval = oval & ~0x07;\r\nnval |= ucontrol->value.enumerated.item[0] & 7;\r\nchange = (oval != nval);\r\nif (change)\r\naureon_cs8415_put(ice, CS8415_CTRL2, nval);\r\nsnd_ice1712_restore_gpio_status(ice);\r\nspec->cs8415_mux = ucontrol->value.enumerated.item[0];\r\nreturn change;\r\n}\r\nstatic int aureon_cs8415_rate_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 192000;\r\nreturn 0;\r\n}\r\nstatic int aureon_cs8415_rate_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned char ratio;\r\nratio = aureon_cs8415_get(ice, CS8415_RATIO);\r\nucontrol->value.integer.value[0] = (int)((unsigned int)ratio * 750);\r\nreturn 0;\r\n}\r\nstatic int aureon_cs8415_mute_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nsnd_ice1712_save_gpio_status(ice);\r\nucontrol->value.integer.value[0] = (aureon_cs8415_get(ice, CS8415_CTRL1) & 0x20) ? 0 : 1;\r\nsnd_ice1712_restore_gpio_status(ice);\r\nreturn 0;\r\n}\r\nstatic int aureon_cs8415_mute_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned char oval, nval;\r\nint change;\r\nsnd_ice1712_save_gpio_status(ice);\r\noval = aureon_cs8415_get(ice, CS8415_CTRL1);\r\nif (ucontrol->value.integer.value[0])\r\nnval = oval & ~0x20;\r\nelse\r\nnval = oval | 0x20;\r\nchange = (oval != nval);\r\nif (change)\r\naureon_cs8415_put(ice, CS8415_CTRL1, nval);\r\nsnd_ice1712_restore_gpio_status(ice);\r\nreturn change;\r\n}\r\nstatic int aureon_cs8415_qsub_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\r\nuinfo->count = 10;\r\nreturn 0;\r\n}\r\nstatic int aureon_cs8415_qsub_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nsnd_ice1712_save_gpio_status(ice);\r\naureon_cs8415_read(ice, CS8415_QSUB, ucontrol->value.bytes.data, 10);\r\nsnd_ice1712_restore_gpio_status(ice);\r\nreturn 0;\r\n}\r\nstatic int aureon_cs8415_spdif_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int aureon_cs8415_mask_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nmemset(ucontrol->value.iec958.status, 0xFF, 24);\r\nreturn 0;\r\n}\r\nstatic int aureon_cs8415_spdif_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nsnd_ice1712_save_gpio_status(ice);\r\naureon_cs8415_read(ice, CS8415_C_BUFFER, ucontrol->value.iec958.status, 24);\r\nsnd_ice1712_restore_gpio_status(ice);\r\nreturn 0;\r\n}\r\nstatic int aureon_set_headphone_amp(struct snd_ice1712 *ice, int enable)\r\n{\r\nunsigned int tmp, tmp2;\r\ntmp2 = tmp = snd_ice1712_gpio_read(ice);\r\nif (enable)\r\nif (ice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71LT &&\r\nice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71XT)\r\ntmp |= AUREON_HP_SEL;\r\nelse\r\ntmp |= PRODIGY_HP_SEL;\r\nelse\r\nif (ice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71LT &&\r\nice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71XT)\r\ntmp &= ~AUREON_HP_SEL;\r\nelse\r\ntmp &= ~PRODIGY_HP_SEL;\r\nif (tmp != tmp2) {\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int aureon_get_headphone_amp(struct snd_ice1712 *ice)\r\n{\r\nunsigned int tmp = snd_ice1712_gpio_read(ice);\r\nreturn (tmp & AUREON_HP_SEL) != 0;\r\n}\r\nstatic int aureon_hpamp_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = aureon_get_headphone_amp(ice);\r\nreturn 0;\r\n}\r\nstatic int aureon_hpamp_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nreturn aureon_set_headphone_amp(ice, ucontrol->value.integer.value[0]);\r\n}\r\nstatic int aureon_deemp_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = (wm_get(ice, WM_DAC_CTRL2) & 0xf) == 0xf;\r\nreturn 0;\r\n}\r\nstatic int aureon_deemp_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint temp, temp2;\r\ntemp2 = temp = wm_get(ice, WM_DAC_CTRL2);\r\nif (ucontrol->value.integer.value[0])\r\ntemp |= 0xf;\r\nelse\r\ntemp &= ~0xf;\r\nif (temp != temp2) {\r\nwm_put(ice, WM_DAC_CTRL2, temp);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int aureon_oversampling_info(struct snd_kcontrol *k, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char * const texts[2] = { "128x", "64x" };\r\nreturn snd_ctl_enum_info(uinfo, 1, 2, texts);\r\n}\r\nstatic int aureon_oversampling_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = (wm_get(ice, WM_MASTER) & 0x8) == 0x8;\r\nreturn 0;\r\n}\r\nstatic int aureon_oversampling_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nint temp, temp2;\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\ntemp2 = temp = wm_get(ice, WM_MASTER);\r\nif (ucontrol->value.enumerated.item[0])\r\ntemp |= 0x8;\r\nelse\r\ntemp &= ~0x8;\r\nif (temp != temp2) {\r\nwm_put(ice, WM_MASTER, temp);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int aureon_add_controls(struct snd_ice1712 *ice)\r\n{\r\nunsigned int i, counts;\r\nint err;\r\ncounts = ARRAY_SIZE(aureon_dac_controls);\r\nif (ice->eeprom.subvendor == VT1724_SUBDEVICE_AUREON51_SKY)\r\ncounts -= 2;\r\nfor (i = 0; i < counts; i++) {\r\nerr = snd_ctl_add(ice->card, snd_ctl_new1(&aureon_dac_controls[i], ice));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(wm_controls); i++) {\r\nerr = snd_ctl_add(ice->card, snd_ctl_new1(&wm_controls[i], ice));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (ice->eeprom.subvendor == VT1724_SUBDEVICE_AUREON71_UNIVERSE) {\r\nfor (i = 0; i < ARRAY_SIZE(universe_ac97_controls); i++) {\r\nerr = snd_ctl_add(ice->card, snd_ctl_new1(&universe_ac97_controls[i], ice));\r\nif (err < 0)\r\nreturn err;\r\n}\r\n} else if (ice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71LT &&\r\nice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71XT) {\r\nfor (i = 0; i < ARRAY_SIZE(ac97_controls); i++) {\r\nerr = snd_ctl_add(ice->card, snd_ctl_new1(&ac97_controls[i], ice));\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nif (ice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71LT &&\r\nice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71XT) {\r\nunsigned char id;\r\nsnd_ice1712_save_gpio_status(ice);\r\nid = aureon_cs8415_get(ice, CS8415_ID);\r\nif (id != 0x41)\r\ndev_info(ice->card->dev,\r\n"No CS8415 chip. Skipping CS8415 controls.\n");\r\nelse if ((id & 0x0F) != 0x01)\r\ndev_info(ice->card->dev,\r\n"Detected unsupported CS8415 rev. (%c)\n",\r\n(char)((id & 0x0F) + 'A' - 1));\r\nelse {\r\nfor (i = 0; i < ARRAY_SIZE(cs8415_controls); i++) {\r\nstruct snd_kcontrol *kctl;\r\nerr = snd_ctl_add(ice->card, (kctl = snd_ctl_new1(&cs8415_controls[i], ice)));\r\nif (err < 0)\r\nreturn err;\r\nif (i > 1)\r\nkctl->id.device = ice->pcm->device;\r\n}\r\n}\r\nsnd_ice1712_restore_gpio_status(ice);\r\n}\r\nreturn 0;\r\n}\r\nstatic int aureon_reset(struct snd_ice1712 *ice)\r\n{\r\nstatic const unsigned short wm_inits_aureon[] = {\r\n0x1b, 0x044,\r\n0x1c, 0x00B,\r\n0x1d, 0x009,\r\n0x18, 0x000,\r\n0x16, 0x122,\r\n0x17, 0x022,\r\n0x00, 0,\r\n0x01, 0,\r\n0x02, 0,\r\n0x03, 0,\r\n0x04, 0,\r\n0x05, 0,\r\n0x06, 0,\r\n0x07, 0,\r\n0x08, 0x100,\r\n0x09, 0xff,\r\n0x0a, 0xff,\r\n0x0b, 0xff,\r\n0x0c, 0xff,\r\n0x0d, 0xff,\r\n0x0e, 0xff,\r\n0x0f, 0xff,\r\n0x10, 0xff,\r\n0x11, 0x1ff,\r\n0x12, 0x000,\r\n0x13, 0x090,\r\n0x14, 0x000,\r\n0x15, 0x000,\r\n0x19, 0x000,\r\n0x1a, 0x000,\r\n(unsigned short)-1\r\n};\r\nstatic const unsigned short wm_inits_prodigy[] = {\r\n0x1b, 0x000,\r\n0x1c, 0x009,\r\n0x1d, 0x009,\r\n0x18, 0x000,\r\n0x16, 0x022,\r\n0x17, 0x006,\r\n0x00, 0,\r\n0x01, 0,\r\n0x02, 0,\r\n0x03, 0,\r\n0x04, 0,\r\n0x05, 0,\r\n0x06, 0,\r\n0x07, 0,\r\n0x08, 0x100,\r\n0x09, 0x7f,\r\n0x0a, 0x7f,\r\n0x0b, 0x7f,\r\n0x0c, 0x7f,\r\n0x0d, 0x7f,\r\n0x0e, 0x7f,\r\n0x0f, 0x7f,\r\n0x10, 0x7f,\r\n0x11, 0x1FF,\r\n0x12, 0x000,\r\n0x13, 0x090,\r\n0x14, 0x000,\r\n0x15, 0x000,\r\n0x19, 0x000,\r\n0x1a, 0x000,\r\n(unsigned short)-1\r\n};\r\nstatic const unsigned short cs_inits[] = {\r\n0x0441,\r\n0x0180,\r\n0x0201,\r\n0x0605,\r\n(unsigned short)-1\r\n};\r\nunsigned int tmp;\r\nconst unsigned short *p;\r\nint err;\r\nstruct aureon_spec *spec = ice->spec;\r\nerr = aureon_ac97_init(ice);\r\nif (err != 0)\r\nreturn err;\r\nsnd_ice1712_gpio_set_dir(ice, 0x5fffff);\r\nsnd_ice1712_save_gpio_status(ice);\r\nsnd_ice1712_gpio_set_mask(ice, ~(AUREON_WM_RESET|AUREON_WM_CS|AUREON_CS8415_CS|AUREON_HP_SEL));\r\ntmp = snd_ice1712_gpio_read(ice);\r\ntmp &= ~AUREON_WM_RESET;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\ntmp |= AUREON_WM_CS | AUREON_CS8415_CS;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\ntmp |= AUREON_WM_RESET;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\nudelay(1);\r\nif (ice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71 ||\r\nice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71LT ||\r\nice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71XT)\r\np = wm_inits_prodigy;\r\nelse\r\np = wm_inits_aureon;\r\nfor (; *p != (unsigned short)-1; p += 2)\r\nwm_put(ice, p[0], p[1]);\r\nif (ice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71LT &&\r\nice->eeprom.subvendor != VT1724_SUBDEVICE_PRODIGY71XT) {\r\nfor (p = cs_inits; *p != (unsigned short)-1; p++)\r\naureon_spi_write(ice, AUREON_CS8415_CS, *p | 0x200000, 24);\r\nspec->cs8415_mux = 1;\r\naureon_set_headphone_amp(ice, 1);\r\n}\r\nsnd_ice1712_restore_gpio_status(ice);\r\naureon_pca9554_write(ice, PCA9554_DIR, 0x00);\r\naureon_pca9554_write(ice, PCA9554_OUT, 0x00);\r\nreturn 0;\r\n}\r\nstatic int aureon_resume(struct snd_ice1712 *ice)\r\n{\r\nstruct aureon_spec *spec = ice->spec;\r\nint err, i;\r\nerr = aureon_reset(ice);\r\nif (err != 0)\r\nreturn err;\r\nfor (i = 0; i < ice->num_total_dacs; i++)\r\nwm_set_vol(ice, i, spec->vol[i], spec->master[i % 2]);\r\nreturn 0;\r\n}\r\nstatic int aureon_init(struct snd_ice1712 *ice)\r\n{\r\nstruct aureon_spec *spec;\r\nint i, err;\r\nspec = kzalloc(sizeof(*spec), GFP_KERNEL);\r\nif (!spec)\r\nreturn -ENOMEM;\r\nice->spec = spec;\r\nif (ice->eeprom.subvendor == VT1724_SUBDEVICE_AUREON51_SKY) {\r\nice->num_total_dacs = 6;\r\nice->num_total_adcs = 2;\r\n} else {\r\nice->num_total_dacs = 8;\r\nice->num_total_adcs = 2;\r\n}\r\nice->akm = kzalloc(sizeof(struct snd_akm4xxx), GFP_KERNEL);\r\nif (!ice->akm)\r\nreturn -ENOMEM;\r\nice->akm_codecs = 1;\r\nerr = aureon_reset(ice);\r\nif (err != 0)\r\nreturn err;\r\nspec->master[0] = WM_VOL_MUTE;\r\nspec->master[1] = WM_VOL_MUTE;\r\nfor (i = 0; i < ice->num_total_dacs; i++) {\r\nspec->vol[i] = WM_VOL_MUTE;\r\nwm_set_vol(ice, i, spec->vol[i], spec->master[i % 2]);\r\n}\r\n#ifdef CONFIG_PM_SLEEP\r\nice->pm_resume = aureon_resume;\r\nice->pm_suspend_enabled = 1;\r\n#endif\r\nreturn 0;\r\n}
