static void __init octeon_wdt_build_stage1(void)\r\n{\r\nint i;\r\nint len;\r\nu32 *p = nmi_stage1_insns;\r\n#ifdef CONFIG_HOTPLUG_CPU\r\nstruct uasm_label *l = labels;\r\nstruct uasm_reloc *r = relocs;\r\n#endif\r\nuasm_i_dmtc0(&p, K0, C0_DESAVE);\r\nuasm_i_mfc0(&p, K0, C0_STATUS);\r\n#ifdef CONFIG_HOTPLUG_CPU\r\nif (octeon_bootloader_entry_addr)\r\nuasm_il_bbit0(&p, &r, K0, ilog2(ST0_NMI),\r\nlabel_enter_bootloader);\r\n#endif\r\nuasm_i_ori(&p, K0, K0, ST0_UX | ST0_SX | ST0_KX);\r\nuasm_i_mtc0(&p, K0, C0_STATUS);\r\n#ifdef CONFIG_HOTPLUG_CPU\r\nif (octeon_bootloader_entry_addr) {\r\nuasm_i_mfc0(&p, K0, C0_EBASE);\r\nuasm_i_andi(&p, K0, K0, 0xf);\r\nuasm_i_dsll_safe(&p, K0, K0, 3 + 16);\r\nuasm_i_ori(&p, K0, K0, 0x8001);\r\nuasm_i_dsll_safe(&p, K0, K0, 16);\r\nuasm_i_ori(&p, K0, K0, 0x0700);\r\nuasm_i_drotr_safe(&p, K0, K0, 32);\r\nuasm_i_ld(&p, K0, 0x500, K0);\r\nuasm_il_bbit0(&p, &r, K0, 1, label_enter_bootloader);\r\nuasm_i_nop(&p);\r\n}\r\n#endif\r\nuasm_i_cache(&p, 1, 0, 0);\r\nuasm_i_dmfc0(&p, K0, C0_CVMMEMCTL);\r\nuasm_i_dins(&p, K0, 0, 0, 6);\r\nuasm_i_ori(&p, K0, K0, 0x1c0 | 54);\r\nuasm_i_dmtc0(&p, K0, C0_CVMMEMCTL);\r\nUASM_i_LA(&p, K0, (long)octeon_wdt_nmi_stage2);\r\nuasm_i_jr(&p, K0);\r\nuasm_i_dmfc0(&p, K0, C0_DESAVE);\r\n#ifdef CONFIG_HOTPLUG_CPU\r\nif (octeon_bootloader_entry_addr) {\r\nuasm_build_label(&l, p, label_enter_bootloader);\r\nUASM_i_LA(&p, K0, (long)octeon_bootloader_entry_addr);\r\nuasm_i_jr(&p, K0);\r\nuasm_i_dmfc0(&p, K0, C0_DESAVE);\r\n}\r\n#endif\r\nuasm_resolve_relocs(relocs, labels);\r\nlen = (int)(p - nmi_stage1_insns);\r\npr_debug("Synthesized NMI stage 1 handler (%d instructions)\n", len);\r\npr_debug("\t.set push\n");\r\npr_debug("\t.set noreorder\n");\r\nfor (i = 0; i < len; i++)\r\npr_debug("\t.word 0x%08x\n", nmi_stage1_insns[i]);\r\npr_debug("\t.set pop\n");\r\nif (len > 32)\r\npanic("NMI stage 1 handler exceeds 32 instructions, was %d\n",\r\nlen);\r\n}\r\nstatic int cpu2core(int cpu)\r\n{\r\n#ifdef CONFIG_SMP\r\nreturn cpu_logical_map(cpu);\r\n#else\r\nreturn cvmx_get_core_num();\r\n#endif\r\n}\r\nstatic int core2cpu(int coreid)\r\n{\r\n#ifdef CONFIG_SMP\r\nreturn cpu_number_map(coreid);\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic irqreturn_t octeon_wdt_poke_irq(int cpl, void *dev_id)\r\n{\r\nunsigned int core = cvmx_get_core_num();\r\nint cpu = core2cpu(core);\r\nif (do_coundown) {\r\nif (per_cpu_countdown[cpu] > 0) {\r\ncvmx_write_csr(CVMX_CIU_PP_POKEX(core), 1);\r\nper_cpu_countdown[cpu]--;\r\n} else {\r\ndisable_irq_nosync(cpl);\r\ncpumask_clear_cpu(cpu, &irq_enabled_cpus);\r\n}\r\n} else {\r\ncvmx_write_csr(CVMX_CIU_PP_POKEX(core), 1);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void octeon_wdt_write_string(const char *str)\r\n{\r\nwhile (*str)\r\nprom_putchar(*str++);\r\n}\r\nstatic void octeon_wdt_write_hex(u64 value, int digits)\r\n{\r\nint d;\r\nint v;\r\nfor (d = 0; d < digits; d++) {\r\nv = (value >> ((digits - d - 1) * 4)) & 0xf;\r\nif (v >= 10)\r\nprom_putchar('a' + v - 10);\r\nelse\r\nprom_putchar('0' + v);\r\n}\r\n}\r\nvoid octeon_wdt_nmi_stage3(u64 reg[32])\r\n{\r\nu64 i;\r\nunsigned int coreid = cvmx_get_core_num();\r\nu64 cp0_cause = read_c0_cause();\r\nu64 cp0_status = read_c0_status();\r\nu64 cp0_error_epc = read_c0_errorepc();\r\nu64 cp0_epc = read_c0_epc();\r\n__delay(100000000ull * coreid);\r\nocteon_wdt_write_string("\r\n*** NMI Watchdog interrupt on Core 0x");\r\nocteon_wdt_write_hex(coreid, 1);\r\nocteon_wdt_write_string(" ***\r\n");\r\nfor (i = 0; i < 32; i++) {\r\nocteon_wdt_write_string("\t");\r\nocteon_wdt_write_string(reg_name[i]);\r\nocteon_wdt_write_string("\t0x");\r\nocteon_wdt_write_hex(reg[i], 16);\r\nif (i & 1)\r\nocteon_wdt_write_string("\r\n");\r\n}\r\nocteon_wdt_write_string("\terr_epc\t0x");\r\nocteon_wdt_write_hex(cp0_error_epc, 16);\r\nocteon_wdt_write_string("\tepc\t0x");\r\nocteon_wdt_write_hex(cp0_epc, 16);\r\nocteon_wdt_write_string("\r\n");\r\nocteon_wdt_write_string("\tstatus\t0x");\r\nocteon_wdt_write_hex(cp0_status, 16);\r\nocteon_wdt_write_string("\tcause\t0x");\r\nocteon_wdt_write_hex(cp0_cause, 16);\r\nocteon_wdt_write_string("\r\n");\r\nocteon_wdt_write_string("\tsum0\t0x");\r\nocteon_wdt_write_hex(cvmx_read_csr(CVMX_CIU_INTX_SUM0(coreid * 2)), 16);\r\nocteon_wdt_write_string("\ten0\t0x");\r\nocteon_wdt_write_hex(cvmx_read_csr(CVMX_CIU_INTX_EN0(coreid * 2)), 16);\r\nocteon_wdt_write_string("\r\n");\r\nocteon_wdt_write_string("*** Chip soft reset soon ***\r\n");\r\n}\r\nstatic int octeon_wdt_cpu_pre_down(unsigned int cpu)\r\n{\r\nunsigned int core;\r\nunsigned int irq;\r\nunion cvmx_ciu_wdogx ciu_wdog;\r\ncore = cpu2core(cpu);\r\nirq = OCTEON_IRQ_WDOG0 + core;\r\ncvmx_write_csr(CVMX_CIU_PP_POKEX(core), 1);\r\nciu_wdog.u64 = 0;\r\ncvmx_write_csr(CVMX_CIU_WDOGX(core), ciu_wdog.u64);\r\nfree_irq(irq, octeon_wdt_poke_irq);\r\nreturn 0;\r\n}\r\nstatic int octeon_wdt_cpu_online(unsigned int cpu)\r\n{\r\nunsigned int core;\r\nunsigned int irq;\r\nunion cvmx_ciu_wdogx ciu_wdog;\r\ncore = cpu2core(cpu);\r\nciu_wdog.u64 = 0;\r\ncvmx_write_csr(CVMX_CIU_WDOGX(core), ciu_wdog.u64);\r\nper_cpu_countdown[cpu] = countdown_reset;\r\nirq = OCTEON_IRQ_WDOG0 + core;\r\nif (request_irq(irq, octeon_wdt_poke_irq,\r\nIRQF_NO_THREAD, "octeon_wdt", octeon_wdt_poke_irq))\r\npanic("octeon_wdt: Couldn't obtain irq %d", irq);\r\ncpumask_set_cpu(cpu, &irq_enabled_cpus);\r\ncvmx_write_csr(CVMX_CIU_PP_POKEX(core), 1);\r\nciu_wdog.u64 = 0;\r\nciu_wdog.s.len = timeout_cnt;\r\nciu_wdog.s.mode = 3;\r\ncvmx_write_csr(CVMX_CIU_WDOGX(core), ciu_wdog.u64);\r\nreturn 0;\r\n}\r\nstatic int octeon_wdt_ping(struct watchdog_device __always_unused *wdog)\r\n{\r\nint cpu;\r\nint coreid;\r\nfor_each_online_cpu(cpu) {\r\ncoreid = cpu2core(cpu);\r\ncvmx_write_csr(CVMX_CIU_PP_POKEX(coreid), 1);\r\nper_cpu_countdown[cpu] = countdown_reset;\r\nif ((countdown_reset || !do_coundown) &&\r\n!cpumask_test_cpu(cpu, &irq_enabled_cpus)) {\r\nint irq = OCTEON_IRQ_WDOG0 + coreid;\r\nenable_irq(irq);\r\ncpumask_set_cpu(cpu, &irq_enabled_cpus);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void octeon_wdt_calc_parameters(int t)\r\n{\r\nunsigned int periods;\r\ntimeout_sec = max_timeout_sec;\r\nwhile ((t % timeout_sec) != 0)\r\ntimeout_sec--;\r\nperiods = t / timeout_sec;\r\ncountdown_reset = periods > 2 ? periods - 2 : 0;\r\nheartbeat = t;\r\ntimeout_cnt = ((octeon_get_io_clock_rate() >> 8) * timeout_sec) >> 8;\r\n}\r\nstatic int octeon_wdt_set_timeout(struct watchdog_device *wdog,\r\nunsigned int t)\r\n{\r\nint cpu;\r\nint coreid;\r\nunion cvmx_ciu_wdogx ciu_wdog;\r\nif (t <= 0)\r\nreturn -1;\r\nocteon_wdt_calc_parameters(t);\r\nfor_each_online_cpu(cpu) {\r\ncoreid = cpu2core(cpu);\r\ncvmx_write_csr(CVMX_CIU_PP_POKEX(coreid), 1);\r\nciu_wdog.u64 = 0;\r\nciu_wdog.s.len = timeout_cnt;\r\nciu_wdog.s.mode = 3;\r\ncvmx_write_csr(CVMX_CIU_WDOGX(coreid), ciu_wdog.u64);\r\ncvmx_write_csr(CVMX_CIU_PP_POKEX(coreid), 1);\r\n}\r\nocteon_wdt_ping(wdog);\r\nreturn 0;\r\n}\r\nstatic int octeon_wdt_start(struct watchdog_device *wdog)\r\n{\r\nocteon_wdt_ping(wdog);\r\ndo_coundown = 1;\r\nreturn 0;\r\n}\r\nstatic int octeon_wdt_stop(struct watchdog_device *wdog)\r\n{\r\ndo_coundown = 0;\r\nocteon_wdt_ping(wdog);\r\nreturn 0;\r\n}\r\nstatic int __init octeon_wdt_init(void)\r\n{\r\nint i;\r\nint ret;\r\nu64 *ptr;\r\nmax_timeout_sec = 6;\r\ndo {\r\nmax_timeout_sec--;\r\ntimeout_cnt = ((octeon_get_io_clock_rate() >> 8) *\r\nmax_timeout_sec) >> 8;\r\n} while (timeout_cnt > 65535);\r\nBUG_ON(timeout_cnt == 0);\r\nocteon_wdt_calc_parameters(heartbeat);\r\npr_info("Initial granularity %d Sec\n", timeout_sec);\r\nocteon_wdt.timeout = timeout_sec;\r\nocteon_wdt.max_timeout = UINT_MAX;\r\nwatchdog_set_nowayout(&octeon_wdt, nowayout);\r\nret = watchdog_register_device(&octeon_wdt);\r\nif (ret) {\r\npr_err("watchdog_register_device() failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nocteon_wdt_build_stage1();\r\nptr = (u64 *) nmi_stage1_insns;\r\nfor (i = 0; i < 16; i++) {\r\ncvmx_write_csr(CVMX_MIO_BOOT_LOC_ADR, i * 8);\r\ncvmx_write_csr(CVMX_MIO_BOOT_LOC_DAT, ptr[i]);\r\n}\r\ncvmx_write_csr(CVMX_MIO_BOOT_LOC_CFGX(0), 0x81fc0000);\r\ncpumask_clear(&irq_enabled_cpus);\r\nret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, "watchdog/octeon:online",\r\nocteon_wdt_cpu_online, octeon_wdt_cpu_pre_down);\r\nif (ret < 0)\r\ngoto err;\r\nocteon_wdt_online = ret;\r\nreturn 0;\r\nerr:\r\ncvmx_write_csr(CVMX_MIO_BOOT_LOC_CFGX(0), 0);\r\nwatchdog_unregister_device(&octeon_wdt);\r\nreturn ret;\r\n}\r\nstatic void __exit octeon_wdt_cleanup(void)\r\n{\r\nwatchdog_unregister_device(&octeon_wdt);\r\ncpuhp_remove_state(octeon_wdt_online);\r\ncvmx_write_csr(CVMX_MIO_BOOT_LOC_CFGX(0), 0);\r\n}
