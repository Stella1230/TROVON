static int sprint_frac(char *dest, int value, int denom)\r\n{\r\nint frac = value % denom;\r\nint result = sprintf(dest, "%d", value / denom);\r\nif (frac == 0)\r\nreturn result;\r\ndest[result++] = '.';\r\ndo {\r\ndenom /= 10;\r\nsprintf(dest + result, "%d", frac / denom);\r\nresult++;\r\nfrac %= denom;\r\n} while (frac);\r\ndest[result++] = '\0';\r\nreturn result;\r\n}\r\nstatic int spi_execute(struct scsi_device *sdev, const void *cmd,\r\nenum dma_data_direction dir,\r\nvoid *buffer, unsigned bufflen,\r\nstruct scsi_sense_hdr *sshdr)\r\n{\r\nint i, result;\r\nunsigned char sense[SCSI_SENSE_BUFFERSIZE];\r\nstruct scsi_sense_hdr sshdr_tmp;\r\nif (!sshdr)\r\nsshdr = &sshdr_tmp;\r\nfor(i = 0; i < DV_RETRIES; i++) {\r\nresult = scsi_execute(sdev, cmd, dir, buffer, bufflen, sense,\r\nsshdr, DV_TIMEOUT, 1,\r\nREQ_FAILFAST_DEV |\r\nREQ_FAILFAST_TRANSPORT |\r\nREQ_FAILFAST_DRIVER,\r\n0, NULL);\r\nif (!(driver_byte(result) & DRIVER_SENSE) ||\r\nsshdr->sense_key != UNIT_ATTENTION)\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic inline const char *spi_signal_to_string(enum spi_signal_type type)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(signal_types); i++) {\r\nif (type == signal_types[i].value)\r\nreturn signal_types[i].name;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline enum spi_signal_type spi_signal_to_value(const char *name)\r\n{\r\nint i, len;\r\nfor (i = 0; i < ARRAY_SIZE(signal_types); i++) {\r\nlen = strlen(signal_types[i].name);\r\nif (strncmp(name, signal_types[i].name, len) == 0 &&\r\n(name[len] == '\n' || name[len] == '\0'))\r\nreturn signal_types[i].value;\r\n}\r\nreturn SPI_SIGNAL_UNKNOWN;\r\n}\r\nstatic int spi_host_setup(struct transport_container *tc, struct device *dev,\r\nstruct device *cdev)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(dev);\r\nspi_signalling(shost) = SPI_SIGNAL_UNKNOWN;\r\nreturn 0;\r\n}\r\nstatic int spi_host_match(struct attribute_container *cont,\r\nstruct device *dev)\r\n{\r\nstruct Scsi_Host *shost;\r\nif (!scsi_is_host_device(dev))\r\nreturn 0;\r\nshost = dev_to_shost(dev);\r\nif (!shost->transportt || shost->transportt->host_attrs.ac.class\r\n!= &spi_host_class.class)\r\nreturn 0;\r\nreturn &shost->transportt->host_attrs.ac == cont;\r\n}\r\nstatic int spi_device_configure(struct transport_container *tc,\r\nstruct device *dev,\r\nstruct device *cdev)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nstruct scsi_target *starget = sdev->sdev_target;\r\nunsigned bflags = scsi_get_device_flags_keyed(sdev, &sdev->inquiry[8],\r\n&sdev->inquiry[16],\r\nSCSI_DEVINFO_SPI);\r\nspi_support_sync(starget) = scsi_device_sync(sdev);\r\nspi_support_wide(starget) = scsi_device_wide(sdev);\r\nspi_support_dt(starget) = scsi_device_dt(sdev);\r\nspi_support_dt_only(starget) = scsi_device_dt_only(sdev);\r\nspi_support_ius(starget) = scsi_device_ius(sdev);\r\nif (bflags & SPI_BLIST_NOIUS) {\r\ndev_info(dev, "Information Units disabled by blacklist\n");\r\nspi_support_ius(starget) = 0;\r\n}\r\nspi_support_qas(starget) = scsi_device_qas(sdev);\r\nreturn 0;\r\n}\r\nstatic int spi_setup_transport_attrs(struct transport_container *tc,\r\nstruct device *dev,\r\nstruct device *cdev)\r\n{\r\nstruct scsi_target *starget = to_scsi_target(dev);\r\nspi_period(starget) = -1;\r\nspi_min_period(starget) = 0;\r\nspi_offset(starget) = 0;\r\nspi_max_offset(starget) = 255;\r\nspi_width(starget) = 0;\r\nspi_max_width(starget) = 1;\r\nspi_iu(starget) = 0;\r\nspi_max_iu(starget) = 1;\r\nspi_dt(starget) = 0;\r\nspi_qas(starget) = 0;\r\nspi_max_qas(starget) = 1;\r\nspi_wr_flow(starget) = 0;\r\nspi_rd_strm(starget) = 0;\r\nspi_rti(starget) = 0;\r\nspi_pcomp_en(starget) = 0;\r\nspi_hold_mcs(starget) = 0;\r\nspi_dv_pending(starget) = 0;\r\nspi_dv_in_progress(starget) = 0;\r\nspi_initial_dv(starget) = 0;\r\nmutex_init(&spi_dv_mutex(starget));\r\nreturn 0;\r\n}\r\nstatic int child_iter(struct device *dev, void *data)\r\n{\r\nif (!scsi_is_sdev_device(dev))\r\nreturn 0;\r\nspi_dv_device(to_scsi_device(dev));\r\nreturn 1;\r\n}\r\nstatic ssize_t\r\nstore_spi_revalidate(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct scsi_target *starget = transport_class_to_starget(dev);\r\ndevice_for_each_child(&starget->dev, NULL, child_iter);\r\nreturn count;\r\n}\r\nstatic int period_to_str(char *buf, int period)\r\n{\r\nint len, picosec;\r\nif (period < 0 || period > 0xff) {\r\npicosec = -1;\r\n} else if (period <= SPI_STATIC_PPR) {\r\npicosec = ppr_to_ps[period];\r\n} else {\r\npicosec = period * 4000;\r\n}\r\nif (picosec == -1) {\r\nlen = sprintf(buf, "reserved");\r\n} else {\r\nlen = sprint_frac(buf, picosec, 1000);\r\n}\r\nreturn len;\r\n}\r\nstatic ssize_t\r\nshow_spi_transport_period_helper(char *buf, int period)\r\n{\r\nint len = period_to_str(buf, period);\r\nbuf[len++] = '\n';\r\nbuf[len] = '\0';\r\nreturn len;\r\n}\r\nstatic ssize_t\r\nstore_spi_transport_period_helper(struct device *dev, const char *buf,\r\nsize_t count, int *periodp)\r\n{\r\nint j, picosec, period = -1;\r\nchar *endp;\r\npicosec = simple_strtoul(buf, &endp, 10) * 1000;\r\nif (*endp == '.') {\r\nint mult = 100;\r\ndo {\r\nendp++;\r\nif (!isdigit(*endp))\r\nbreak;\r\npicosec += (*endp - '0') * mult;\r\nmult /= 10;\r\n} while (mult > 0);\r\n}\r\nfor (j = 0; j <= SPI_STATIC_PPR; j++) {\r\nif (ppr_to_ps[j] < picosec)\r\ncontinue;\r\nperiod = j;\r\nbreak;\r\n}\r\nif (period == -1)\r\nperiod = picosec / 4000;\r\nif (period > 0xff)\r\nperiod = 0xff;\r\n*periodp = period;\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_spi_transport_period(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct scsi_target *starget = transport_class_to_starget(dev);\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct spi_internal *i = to_spi_internal(shost->transportt);\r\nstruct spi_transport_attrs *tp =\r\n(struct spi_transport_attrs *)&starget->starget_data;\r\nif (i->f->get_period)\r\ni->f->get_period(starget);\r\nreturn show_spi_transport_period_helper(buf, tp->period);\r\n}\r\nstatic ssize_t\r\nstore_spi_transport_period(struct device *cdev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct scsi_target *starget = transport_class_to_starget(cdev);\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct spi_internal *i = to_spi_internal(shost->transportt);\r\nstruct spi_transport_attrs *tp =\r\n(struct spi_transport_attrs *)&starget->starget_data;\r\nint period, retval;\r\nif (!i->f->set_period)\r\nreturn -EINVAL;\r\nretval = store_spi_transport_period_helper(cdev, buf, count, &period);\r\nif (period < tp->min_period)\r\nperiod = tp->min_period;\r\ni->f->set_period(starget, period);\r\nreturn retval;\r\n}\r\nstatic ssize_t\r\nshow_spi_transport_min_period(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct scsi_target *starget = transport_class_to_starget(cdev);\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct spi_internal *i = to_spi_internal(shost->transportt);\r\nstruct spi_transport_attrs *tp =\r\n(struct spi_transport_attrs *)&starget->starget_data;\r\nif (!i->f->set_period)\r\nreturn -EINVAL;\r\nreturn show_spi_transport_period_helper(buf, tp->min_period);\r\n}\r\nstatic ssize_t\r\nstore_spi_transport_min_period(struct device *cdev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct scsi_target *starget = transport_class_to_starget(cdev);\r\nstruct spi_transport_attrs *tp =\r\n(struct spi_transport_attrs *)&starget->starget_data;\r\nreturn store_spi_transport_period_helper(cdev, buf, count,\r\n&tp->min_period);\r\n}\r\nstatic ssize_t show_spi_host_signalling(struct device *cdev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = transport_class_to_shost(cdev);\r\nstruct spi_internal *i = to_spi_internal(shost->transportt);\r\nif (i->f->get_signalling)\r\ni->f->get_signalling(shost);\r\nreturn sprintf(buf, "%s\n", spi_signal_to_string(spi_signalling(shost)));\r\n}\r\nstatic ssize_t store_spi_host_signalling(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = transport_class_to_shost(dev);\r\nstruct spi_internal *i = to_spi_internal(shost->transportt);\r\nenum spi_signal_type type = spi_signal_to_value(buf);\r\nif (!i->f->set_signalling)\r\nreturn -EINVAL;\r\nif (type != SPI_SIGNAL_UNKNOWN)\r\ni->f->set_signalling(shost, type);\r\nreturn count;\r\n}\r\nstatic ssize_t show_spi_host_width(struct device *cdev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = transport_class_to_shost(cdev);\r\nreturn sprintf(buf, "%s\n", shost->max_id == 16 ? "wide" : "narrow");\r\n}\r\nstatic ssize_t show_spi_host_hba_id(struct device *cdev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = transport_class_to_shost(cdev);\r\nreturn sprintf(buf, "%d\n", shost->this_id);\r\n}\r\nstatic enum spi_compare_returns\r\nspi_dv_device_echo_buffer(struct scsi_device *sdev, u8 *buffer,\r\nu8 *ptr, const int retries)\r\n{\r\nint len = ptr - buffer;\r\nint j, k, r, result;\r\nunsigned int pattern = 0x0000ffff;\r\nstruct scsi_sense_hdr sshdr;\r\nconst char spi_write_buffer[] = {\r\nWRITE_BUFFER, 0x0a, 0, 0, 0, 0, 0, len >> 8, len & 0xff, 0\r\n};\r\nconst char spi_read_buffer[] = {\r\nREAD_BUFFER, 0x0a, 0, 0, 0, 0, 0, len >> 8, len & 0xff, 0\r\n};\r\nfor (j = 0; j < len; ) {\r\nfor ( ; j < min(len, 32); j++)\r\nbuffer[j] = j;\r\nk = j;\r\nfor ( ; j < min(len, k + 32); j += 2) {\r\nu16 *word = (u16 *)&buffer[j];\r\n*word = (j & 0x02) ? 0x0000 : 0xffff;\r\n}\r\nk = j;\r\nfor ( ; j < min(len, k + 32); j += 2) {\r\nu16 *word = (u16 *)&buffer[j];\r\n*word = (j & 0x02) ? 0x5555 : 0xaaaa;\r\n}\r\nk = j;\r\nfor ( ; j < min(len, k + 32); j += 4) {\r\nu32 *word = (unsigned int *)&buffer[j];\r\nu32 roll = (pattern & 0x80000000) ? 1 : 0;\r\n*word = pattern;\r\npattern = (pattern << 1) | roll;\r\n}\r\n}\r\nfor (r = 0; r < retries; r++) {\r\nresult = spi_execute(sdev, spi_write_buffer, DMA_TO_DEVICE,\r\nbuffer, len, &sshdr);\r\nif(result || !scsi_device_online(sdev)) {\r\nscsi_device_set_state(sdev, SDEV_QUIESCE);\r\nif (scsi_sense_valid(&sshdr)\r\n&& sshdr.sense_key == ILLEGAL_REQUEST\r\n&& sshdr.asc == 0x24 && sshdr.ascq == 0x00)\r\nreturn SPI_COMPARE_SKIP_TEST;\r\nsdev_printk(KERN_ERR, sdev, "Write Buffer failure %x\n", result);\r\nreturn SPI_COMPARE_FAILURE;\r\n}\r\nmemset(ptr, 0, len);\r\nspi_execute(sdev, spi_read_buffer, DMA_FROM_DEVICE,\r\nptr, len, NULL);\r\nscsi_device_set_state(sdev, SDEV_QUIESCE);\r\nif (memcmp(buffer, ptr, len) != 0)\r\nreturn SPI_COMPARE_FAILURE;\r\n}\r\nreturn SPI_COMPARE_SUCCESS;\r\n}\r\nstatic enum spi_compare_returns\r\nspi_dv_device_compare_inquiry(struct scsi_device *sdev, u8 *buffer,\r\nu8 *ptr, const int retries)\r\n{\r\nint r, result;\r\nconst int len = sdev->inquiry_len;\r\nconst char spi_inquiry[] = {\r\nINQUIRY, 0, 0, 0, len, 0\r\n};\r\nfor (r = 0; r < retries; r++) {\r\nmemset(ptr, 0, len);\r\nresult = spi_execute(sdev, spi_inquiry, DMA_FROM_DEVICE,\r\nptr, len, NULL);\r\nif(result || !scsi_device_online(sdev)) {\r\nscsi_device_set_state(sdev, SDEV_QUIESCE);\r\nreturn SPI_COMPARE_FAILURE;\r\n}\r\nif (ptr == buffer) {\r\nptr += len;\r\n--r;\r\ncontinue;\r\n}\r\nif (memcmp(buffer, ptr, len) != 0)\r\nreturn SPI_COMPARE_FAILURE;\r\n}\r\nreturn SPI_COMPARE_SUCCESS;\r\n}\r\nstatic int\r\nspi_dv_device_get_echo_buffer(struct scsi_device *sdev, u8 *buffer)\r\n{\r\nint l, result;\r\nconst char spi_test_unit_ready[] = {\r\nTEST_UNIT_READY, 0, 0, 0, 0, 0\r\n};\r\nconst char spi_read_buffer_descriptor[] = {\r\nREAD_BUFFER, 0x0b, 0, 0, 0, 0, 0, 0, 4, 0\r\n};\r\nfor (l = 0; ; l++) {\r\nresult = spi_execute(sdev, spi_test_unit_ready, DMA_NONE,\r\nNULL, 0, NULL);\r\nif(result) {\r\nif(l >= 3)\r\nreturn 0;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nresult = spi_execute(sdev, spi_read_buffer_descriptor,\r\nDMA_FROM_DEVICE, buffer, 4, NULL);\r\nif (result)\r\nreturn 0;\r\nreturn buffer[3] + ((buffer[2] & 0x1f) << 8);\r\n}\r\nstatic void\r\nspi_dv_device_internal(struct scsi_device *sdev, u8 *buffer)\r\n{\r\nstruct spi_internal *i = to_spi_internal(sdev->host->transportt);\r\nstruct scsi_target *starget = sdev->sdev_target;\r\nstruct Scsi_Host *shost = sdev->host;\r\nint len = sdev->inquiry_len;\r\nint min_period = spi_min_period(starget);\r\nint max_width = spi_max_width(starget);\r\nDV_SET(offset, 0);\r\nDV_SET(width, 0);\r\nif (spi_dv_device_compare_inquiry(sdev, buffer, buffer, DV_LOOPS)\r\n!= SPI_COMPARE_SUCCESS) {\r\nstarget_printk(KERN_ERR, starget, "Domain Validation Initial Inquiry Failed\n");\r\nreturn;\r\n}\r\nif (!spi_support_wide(starget)) {\r\nspi_max_width(starget) = 0;\r\nmax_width = 0;\r\n}\r\nif (i->f->set_width && max_width) {\r\ni->f->set_width(starget, 1);\r\nif (spi_dv_device_compare_inquiry(sdev, buffer,\r\nbuffer + len,\r\nDV_LOOPS)\r\n!= SPI_COMPARE_SUCCESS) {\r\nstarget_printk(KERN_ERR, starget, "Wide Transfers Fail\n");\r\ni->f->set_width(starget, 0);\r\nmax_width = 0;\r\nif (min_period < 10)\r\nmin_period = 10;\r\n}\r\n}\r\nif (!i->f->set_period)\r\nreturn;\r\nif (!spi_support_sync(starget) && !spi_support_dt(starget))\r\nreturn;\r\nlen = -1;\r\nretry:\r\nDV_SET(offset, spi_max_offset(starget));\r\nDV_SET(period, min_period);\r\nif (spi_support_qas(starget) && spi_max_qas(starget)) {\r\nDV_SET(qas, 1);\r\n} else {\r\nDV_SET(qas, 0);\r\n}\r\nif (spi_support_ius(starget) && spi_max_iu(starget) &&\r\nmin_period < 9) {\r\nDV_SET(iu, 1);\r\nDV_SET(rd_strm, 1);\r\nDV_SET(wr_flow, 1);\r\nDV_SET(rti, 1);\r\nif (min_period == 8)\r\nDV_SET(pcomp_en, 1);\r\n} else {\r\nDV_SET(iu, 0);\r\n}\r\nif (i->f->get_signalling)\r\ni->f->get_signalling(shost);\r\nif (spi_signalling(shost) == SPI_SIGNAL_SE ||\r\nspi_signalling(shost) == SPI_SIGNAL_HVD ||\r\n!spi_support_dt(starget)) {\r\nDV_SET(dt, 0);\r\n} else {\r\nDV_SET(dt, 1);\r\n}\r\nDV_SET(width, max_width);\r\nspi_dv_retrain(sdev, buffer, buffer + sdev->inquiry_len,\r\nspi_dv_device_compare_inquiry);\r\nif (i->f->get_dt)\r\ni->f->get_dt(starget);\r\nif (len == -1 && spi_dt(starget))\r\nlen = spi_dv_device_get_echo_buffer(sdev, buffer);\r\nif (len <= 0) {\r\nstarget_printk(KERN_INFO, starget, "Domain Validation skipping write tests\n");\r\nreturn;\r\n}\r\nif (len > SPI_MAX_ECHO_BUFFER_SIZE) {\r\nstarget_printk(KERN_WARNING, starget, "Echo buffer size %d is too big, trimming to %d\n", len, SPI_MAX_ECHO_BUFFER_SIZE);\r\nlen = SPI_MAX_ECHO_BUFFER_SIZE;\r\n}\r\nif (spi_dv_retrain(sdev, buffer, buffer + len,\r\nspi_dv_device_echo_buffer)\r\n== SPI_COMPARE_SKIP_TEST) {\r\nlen = 0;\r\ngoto retry;\r\n}\r\n}\r\nvoid\r\nspi_dv_device(struct scsi_device *sdev)\r\n{\r\nstruct scsi_target *starget = sdev->sdev_target;\r\nu8 *buffer;\r\nconst int len = SPI_MAX_ECHO_BUFFER_SIZE*2;\r\nif (unlikely(spi_dv_in_progress(starget)))\r\nreturn;\r\nif (unlikely(scsi_device_get(sdev)))\r\nreturn;\r\nspi_dv_in_progress(starget) = 1;\r\nbuffer = kzalloc(len, GFP_KERNEL);\r\nif (unlikely(!buffer))\r\ngoto out_put;\r\nif (unlikely(scsi_device_quiesce(sdev)))\r\ngoto out_free;\r\nscsi_target_quiesce(starget);\r\nspi_dv_pending(starget) = 1;\r\nmutex_lock(&spi_dv_mutex(starget));\r\nstarget_printk(KERN_INFO, starget, "Beginning Domain Validation\n");\r\nspi_dv_device_internal(sdev, buffer);\r\nstarget_printk(KERN_INFO, starget, "Ending Domain Validation\n");\r\nmutex_unlock(&spi_dv_mutex(starget));\r\nspi_dv_pending(starget) = 0;\r\nscsi_target_resume(starget);\r\nspi_initial_dv(starget) = 1;\r\nout_free:\r\nkfree(buffer);\r\nout_put:\r\nspi_dv_in_progress(starget) = 0;\r\nscsi_device_put(sdev);\r\n}\r\nstatic void\r\nspi_dv_device_work_wrapper(struct work_struct *work)\r\n{\r\nstruct work_queue_wrapper *wqw =\r\ncontainer_of(work, struct work_queue_wrapper, work);\r\nstruct scsi_device *sdev = wqw->sdev;\r\nkfree(wqw);\r\nspi_dv_device(sdev);\r\nspi_dv_pending(sdev->sdev_target) = 0;\r\nscsi_device_put(sdev);\r\n}\r\nvoid\r\nspi_schedule_dv_device(struct scsi_device *sdev)\r\n{\r\nstruct work_queue_wrapper *wqw =\r\nkmalloc(sizeof(struct work_queue_wrapper), GFP_ATOMIC);\r\nif (unlikely(!wqw))\r\nreturn;\r\nif (unlikely(spi_dv_pending(sdev->sdev_target))) {\r\nkfree(wqw);\r\nreturn;\r\n}\r\nspi_dv_pending(sdev->sdev_target) = 1;\r\nif (unlikely(scsi_device_get(sdev))) {\r\nkfree(wqw);\r\nspi_dv_pending(sdev->sdev_target) = 0;\r\nreturn;\r\n}\r\nINIT_WORK(&wqw->work, spi_dv_device_work_wrapper);\r\nwqw->sdev = sdev;\r\nschedule_work(&wqw->work);\r\n}\r\nvoid spi_display_xfer_agreement(struct scsi_target *starget)\r\n{\r\nstruct spi_transport_attrs *tp;\r\ntp = (struct spi_transport_attrs *)&starget->starget_data;\r\nif (tp->offset > 0 && tp->period > 0) {\r\nunsigned int picosec, kb100;\r\nchar *scsi = "FAST-?";\r\nchar tmp[8];\r\nif (tp->period <= SPI_STATIC_PPR) {\r\npicosec = ppr_to_ps[tp->period];\r\nswitch (tp->period) {\r\ncase 7: scsi = "FAST-320"; break;\r\ncase 8: scsi = "FAST-160"; break;\r\ncase 9: scsi = "FAST-80"; break;\r\ncase 10:\r\ncase 11: scsi = "FAST-40"; break;\r\ncase 12: scsi = "FAST-20"; break;\r\n}\r\n} else {\r\npicosec = tp->period * 4000;\r\nif (tp->period < 25)\r\nscsi = "FAST-20";\r\nelse if (tp->period < 50)\r\nscsi = "FAST-10";\r\nelse\r\nscsi = "FAST-5";\r\n}\r\nkb100 = (10000000 + picosec / 2) / picosec;\r\nif (tp->width)\r\nkb100 *= 2;\r\nsprint_frac(tmp, picosec, 1000);\r\ndev_info(&starget->dev,\r\n"%s %sSCSI %d.%d MB/s %s%s%s%s%s%s%s%s (%s ns, offset %d)\n",\r\nscsi, tp->width ? "WIDE " : "", kb100/10, kb100 % 10,\r\ntp->dt ? "DT" : "ST",\r\ntp->iu ? " IU" : "",\r\ntp->qas ? " QAS" : "",\r\ntp->rd_strm ? " RDSTRM" : "",\r\ntp->rti ? " RTI" : "",\r\ntp->wr_flow ? " WRFLOW" : "",\r\ntp->pcomp_en ? " PCOMP" : "",\r\ntp->hold_mcs ? " HMCS" : "",\r\ntmp, tp->offset);\r\n} else {\r\ndev_info(&starget->dev, "%sasynchronous\n",\r\ntp->width ? "wide " : "");\r\n}\r\n}\r\nint spi_populate_width_msg(unsigned char *msg, int width)\r\n{\r\nmsg[0] = EXTENDED_MESSAGE;\r\nmsg[1] = 2;\r\nmsg[2] = EXTENDED_WDTR;\r\nmsg[3] = width;\r\nreturn 4;\r\n}\r\nint spi_populate_sync_msg(unsigned char *msg, int period, int offset)\r\n{\r\nmsg[0] = EXTENDED_MESSAGE;\r\nmsg[1] = 3;\r\nmsg[2] = EXTENDED_SDTR;\r\nmsg[3] = period;\r\nmsg[4] = offset;\r\nreturn 5;\r\n}\r\nint spi_populate_ppr_msg(unsigned char *msg, int period, int offset,\r\nint width, int options)\r\n{\r\nmsg[0] = EXTENDED_MESSAGE;\r\nmsg[1] = 6;\r\nmsg[2] = EXTENDED_PPR;\r\nmsg[3] = period;\r\nmsg[4] = 0;\r\nmsg[5] = offset;\r\nmsg[6] = width;\r\nmsg[7] = options;\r\nreturn 8;\r\n}\r\nint spi_populate_tag_msg(unsigned char *msg, struct scsi_cmnd *cmd)\r\n{\r\nif (cmd->flags & SCMD_TAGGED) {\r\n*msg++ = SIMPLE_QUEUE_TAG;\r\n*msg++ = cmd->request->tag;\r\nreturn 2;\r\n}\r\nreturn 0;\r\n}\r\nstatic void print_nego(const unsigned char *msg, int per, int off, int width)\r\n{\r\nif (per) {\r\nchar buf[20];\r\nperiod_to_str(buf, msg[per]);\r\nprintk("period = %s ns ", buf);\r\n}\r\nif (off)\r\nprintk("offset = %d ", msg[off]);\r\nif (width)\r\nprintk("width = %d ", 8 << msg[width]);\r\n}\r\nstatic void print_ptr(const unsigned char *msg, int msb, const char *desc)\r\n{\r\nint ptr = (msg[msb] << 24) | (msg[msb+1] << 16) | (msg[msb+2] << 8) |\r\nmsg[msb+3];\r\nprintk("%s = %d ", desc, ptr);\r\n}\r\nint spi_print_msg(const unsigned char *msg)\r\n{\r\nint len = 1, i;\r\nif (msg[0] == EXTENDED_MESSAGE) {\r\nlen = 2 + msg[1];\r\nif (len == 2)\r\nlen += 256;\r\nif (msg[2] < ARRAY_SIZE(extended_msgs))\r\nprintk ("%s ", extended_msgs[msg[2]]);\r\nelse\r\nprintk ("Extended Message, reserved code (0x%02x) ",\r\n(int) msg[2]);\r\nswitch (msg[2]) {\r\ncase EXTENDED_MODIFY_DATA_POINTER:\r\nprint_ptr(msg, 3, "pointer");\r\nbreak;\r\ncase EXTENDED_SDTR:\r\nprint_nego(msg, 3, 4, 0);\r\nbreak;\r\ncase EXTENDED_WDTR:\r\nprint_nego(msg, 0, 0, 3);\r\nbreak;\r\ncase EXTENDED_PPR:\r\nprint_nego(msg, 3, 5, 6);\r\nbreak;\r\ncase EXTENDED_MODIFY_BIDI_DATA_PTR:\r\nprint_ptr(msg, 3, "out");\r\nprint_ptr(msg, 7, "in");\r\nbreak;\r\ndefault:\r\nfor (i = 2; i < len; ++i)\r\nprintk("%02x ", msg[i]);\r\n}\r\n} else if (msg[0] & 0x80) {\r\nprintk("Identify disconnect %sallowed %s %d ",\r\n(msg[0] & 0x40) ? "" : "not ",\r\n(msg[0] & 0x20) ? "target routine" : "lun",\r\nmsg[0] & 0x7);\r\n} else if (msg[0] < 0x1f) {\r\nif (msg[0] < ARRAY_SIZE(one_byte_msgs) && one_byte_msgs[msg[0]])\r\nprintk("%s ", one_byte_msgs[msg[0]]);\r\nelse\r\nprintk("reserved (%02x) ", msg[0]);\r\n} else if (msg[0] == 0x55) {\r\nprintk("QAS Request ");\r\n} else if (msg[0] <= 0x2f) {\r\nif ((msg[0] - 0x20) < ARRAY_SIZE(two_byte_msgs))\r\nprintk("%s %02x ", two_byte_msgs[msg[0] - 0x20],\r\nmsg[1]);\r\nelse\r\nprintk("reserved two byte (%02x %02x) ",\r\nmsg[0], msg[1]);\r\nlen = 2;\r\n} else\r\nprintk("reserved ");\r\nreturn len;\r\n}\r\nint spi_print_msg(const unsigned char *msg)\r\n{\r\nint len = 1, i;\r\nif (msg[0] == EXTENDED_MESSAGE) {\r\nlen = 2 + msg[1];\r\nif (len == 2)\r\nlen += 256;\r\nfor (i = 0; i < len; ++i)\r\nprintk("%02x ", msg[i]);\r\n} else if (msg[0] & 0x80) {\r\nprintk("%02x ", msg[0]);\r\n} else if ((msg[0] < 0x1f) || (msg[0] == 0x55)) {\r\nprintk("%02x ", msg[0]);\r\n} else if (msg[0] <= 0x2f) {\r\nprintk("%02x %02x", msg[0], msg[1]);\r\nlen = 2;\r\n} else\r\nprintk("%02x ", msg[0]);\r\nreturn len;\r\n}\r\nstatic int spi_device_match(struct attribute_container *cont,\r\nstruct device *dev)\r\n{\r\nstruct scsi_device *sdev;\r\nstruct Scsi_Host *shost;\r\nstruct spi_internal *i;\r\nif (!scsi_is_sdev_device(dev))\r\nreturn 0;\r\nsdev = to_scsi_device(dev);\r\nshost = sdev->host;\r\nif (!shost->transportt || shost->transportt->host_attrs.ac.class\r\n!= &spi_host_class.class)\r\nreturn 0;\r\ni = to_spi_internal(shost->transportt);\r\nif (i->f->deny_binding && i->f->deny_binding(sdev->sdev_target))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int spi_target_match(struct attribute_container *cont,\r\nstruct device *dev)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct scsi_target *starget;\r\nstruct spi_internal *i;\r\nif (!scsi_is_target_device(dev))\r\nreturn 0;\r\nshost = dev_to_shost(dev->parent);\r\nif (!shost->transportt || shost->transportt->host_attrs.ac.class\r\n!= &spi_host_class.class)\r\nreturn 0;\r\ni = to_spi_internal(shost->transportt);\r\nstarget = to_scsi_target(dev);\r\nif (i->f->deny_binding && i->f->deny_binding(starget))\r\nreturn 0;\r\nreturn &i->t.target_attrs.ac == cont;\r\n}\r\nstatic int spi_host_configure(struct transport_container *tc,\r\nstruct device *dev,\r\nstruct device *cdev)\r\n{\r\nstruct kobject *kobj = &cdev->kobj;\r\nstruct Scsi_Host *shost = transport_class_to_shost(cdev);\r\nstruct spi_internal *si = to_spi_internal(shost->transportt);\r\nstruct attribute *attr = &dev_attr_signalling.attr;\r\nint rc = 0;\r\nif (si->f->set_signalling)\r\nrc = sysfs_chmod_file(kobj, attr, attr->mode | S_IWUSR);\r\nreturn rc;\r\n}\r\nstatic umode_t target_attribute_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int i)\r\n{\r\nstruct device *cdev = container_of(kobj, struct device, kobj);\r\nstruct scsi_target *starget = transport_class_to_starget(cdev);\r\nstruct Scsi_Host *shost = transport_class_to_shost(cdev);\r\nstruct spi_internal *si = to_spi_internal(shost->transportt);\r\nif (attr == &dev_attr_period.attr &&\r\nspi_support_sync(starget))\r\nreturn TARGET_ATTRIBUTE_HELPER(period);\r\nelse if (attr == &dev_attr_min_period.attr &&\r\nspi_support_sync(starget))\r\nreturn TARGET_ATTRIBUTE_HELPER(period);\r\nelse if (attr == &dev_attr_offset.attr &&\r\nspi_support_sync(starget))\r\nreturn TARGET_ATTRIBUTE_HELPER(offset);\r\nelse if (attr == &dev_attr_max_offset.attr &&\r\nspi_support_sync(starget))\r\nreturn TARGET_ATTRIBUTE_HELPER(offset);\r\nelse if (attr == &dev_attr_width.attr &&\r\nspi_support_wide(starget))\r\nreturn TARGET_ATTRIBUTE_HELPER(width);\r\nelse if (attr == &dev_attr_max_width.attr &&\r\nspi_support_wide(starget))\r\nreturn TARGET_ATTRIBUTE_HELPER(width);\r\nelse if (attr == &dev_attr_iu.attr &&\r\nspi_support_ius(starget))\r\nreturn TARGET_ATTRIBUTE_HELPER(iu);\r\nelse if (attr == &dev_attr_max_iu.attr &&\r\nspi_support_ius(starget))\r\nreturn TARGET_ATTRIBUTE_HELPER(iu);\r\nelse if (attr == &dev_attr_dt.attr &&\r\nspi_support_dt(starget))\r\nreturn TARGET_ATTRIBUTE_HELPER(dt);\r\nelse if (attr == &dev_attr_qas.attr &&\r\nspi_support_qas(starget))\r\nreturn TARGET_ATTRIBUTE_HELPER(qas);\r\nelse if (attr == &dev_attr_max_qas.attr &&\r\nspi_support_qas(starget))\r\nreturn TARGET_ATTRIBUTE_HELPER(qas);\r\nelse if (attr == &dev_attr_wr_flow.attr &&\r\nspi_support_ius(starget))\r\nreturn TARGET_ATTRIBUTE_HELPER(wr_flow);\r\nelse if (attr == &dev_attr_rd_strm.attr &&\r\nspi_support_ius(starget))\r\nreturn TARGET_ATTRIBUTE_HELPER(rd_strm);\r\nelse if (attr == &dev_attr_rti.attr &&\r\nspi_support_ius(starget))\r\nreturn TARGET_ATTRIBUTE_HELPER(rti);\r\nelse if (attr == &dev_attr_pcomp_en.attr &&\r\nspi_support_ius(starget))\r\nreturn TARGET_ATTRIBUTE_HELPER(pcomp_en);\r\nelse if (attr == &dev_attr_hold_mcs.attr &&\r\nspi_support_ius(starget))\r\nreturn TARGET_ATTRIBUTE_HELPER(hold_mcs);\r\nelse if (attr == &dev_attr_revalidate.attr)\r\nreturn S_IWUSR;\r\nreturn 0;\r\n}\r\nstatic int spi_target_configure(struct transport_container *tc,\r\nstruct device *dev,\r\nstruct device *cdev)\r\n{\r\nstruct kobject *kobj = &cdev->kobj;\r\nsysfs_update_group(kobj, &target_attribute_group);\r\nreturn 0;\r\n}\r\nstruct scsi_transport_template *\r\nspi_attach_transport(struct spi_function_template *ft)\r\n{\r\nstruct spi_internal *i = kzalloc(sizeof(struct spi_internal),\r\nGFP_KERNEL);\r\nif (unlikely(!i))\r\nreturn NULL;\r\ni->t.target_attrs.ac.class = &spi_transport_class.class;\r\ni->t.target_attrs.ac.grp = &target_attribute_group;\r\ni->t.target_attrs.ac.match = spi_target_match;\r\ntransport_container_register(&i->t.target_attrs);\r\ni->t.target_size = sizeof(struct spi_transport_attrs);\r\ni->t.host_attrs.ac.class = &spi_host_class.class;\r\ni->t.host_attrs.ac.grp = &host_attribute_group;\r\ni->t.host_attrs.ac.match = spi_host_match;\r\ntransport_container_register(&i->t.host_attrs);\r\ni->t.host_size = sizeof(struct spi_host_attrs);\r\ni->f = ft;\r\nreturn &i->t;\r\n}\r\nvoid spi_release_transport(struct scsi_transport_template *t)\r\n{\r\nstruct spi_internal *i = to_spi_internal(t);\r\ntransport_container_unregister(&i->t.target_attrs);\r\ntransport_container_unregister(&i->t.host_attrs);\r\nkfree(i);\r\n}\r\nstatic __init int spi_transport_init(void)\r\n{\r\nint error = scsi_dev_info_add_list(SCSI_DEVINFO_SPI,\r\n"SCSI Parallel Transport Class");\r\nif (!error) {\r\nint i;\r\nfor (i = 0; spi_static_device_list[i].vendor; i++)\r\nscsi_dev_info_list_add_keyed(1,\r\nspi_static_device_list[i].vendor,\r\nspi_static_device_list[i].model,\r\nNULL,\r\nspi_static_device_list[i].flags,\r\nSCSI_DEVINFO_SPI);\r\n}\r\nerror = transport_class_register(&spi_transport_class);\r\nif (error)\r\nreturn error;\r\nerror = anon_transport_class_register(&spi_device_class);\r\nreturn transport_class_register(&spi_host_class);\r\n}\r\nstatic void __exit spi_transport_exit(void)\r\n{\r\ntransport_class_unregister(&spi_transport_class);\r\nanon_transport_class_unregister(&spi_device_class);\r\ntransport_class_unregister(&spi_host_class);\r\nscsi_dev_info_remove_list(SCSI_DEVINFO_SPI);\r\n}
