static tree handle_user_attribute(tree *node, tree name, tree args, int flags, bool *no_add_attrs)\r\n{\r\n*no_add_attrs = true;\r\nif (TREE_CODE(*node) != FIELD_DECL)\r\nreturn NULL_TREE;\r\n*no_add_attrs = false;\r\nreturn NULL_TREE;\r\n}\r\nstatic void register_attributes(void *event_data, void *data)\r\n{\r\nregister_attribute(&user_attr);\r\n}\r\nstatic tree get_field_type(tree field)\r\n{\r\nreturn strip_array_types(TREE_TYPE(field));\r\n}\r\nstatic bool is_userspace_type(tree type)\r\n{\r\ntree field;\r\nfor (field = TYPE_FIELDS(type); field; field = TREE_CHAIN(field)) {\r\ntree fieldtype = get_field_type(field);\r\nenum tree_code code = TREE_CODE(fieldtype);\r\nif (code == RECORD_TYPE || code == UNION_TYPE)\r\nif (is_userspace_type(fieldtype))\r\nreturn true;\r\nif (lookup_attribute("user", DECL_ATTRIBUTES(field)))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void finish_type(void *event_data, void *data)\r\n{\r\ntree type = (tree)event_data;\r\nif (type == NULL_TREE || type == error_mark_node)\r\nreturn;\r\n#if BUILDING_GCC_VERSION >= 5000\r\nif (TREE_CODE(type) == ENUMERAL_TYPE)\r\nreturn;\r\n#endif\r\nif (TYPE_USERSPACE(type))\r\nreturn;\r\nif (is_userspace_type(type))\r\nTYPE_USERSPACE(type) = 1;\r\n}\r\nstatic void initialize(tree var)\r\n{\r\nbasic_block bb;\r\ngimple_stmt_iterator gsi;\r\ntree initializer;\r\ngimple init_stmt;\r\nbb = single_succ(ENTRY_BLOCK_PTR_FOR_FN(cfun));\r\nfor (gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi)) {\r\ngimple stmt = gsi_stmt(gsi);\r\ntree rhs1;\r\nif (!gimple_assign_single_p(stmt))\r\ncontinue;\r\nrhs1 = gimple_assign_rhs1(stmt);\r\n#if BUILDING_GCC_VERSION >= 4007\r\nif (TREE_CLOBBER_P(rhs1))\r\ncontinue;\r\n#endif\r\nif (gimple_get_lhs(stmt) != var)\r\ncontinue;\r\nif (TREE_CODE(rhs1) == CONSTRUCTOR)\r\nreturn;\r\n}\r\nif (verbose)\r\ninform(DECL_SOURCE_LOCATION(var),\r\n"userspace variable will be forcibly initialized");\r\ninitializer = build_constructor(TREE_TYPE(var), NULL);\r\ninit_stmt = gimple_build_assign(var, initializer);\r\ngsi = gsi_after_labels(single_succ(ENTRY_BLOCK_PTR_FOR_FN(cfun)));\r\ngsi_insert_before(&gsi, init_stmt, GSI_NEW_STMT);\r\nupdate_stmt(init_stmt);\r\n}\r\nstatic unsigned int structleak_execute(void)\r\n{\r\nbasic_block bb;\r\nunsigned int ret = 0;\r\ntree var;\r\nunsigned int i;\r\ngcc_assert(single_succ_p(ENTRY_BLOCK_PTR_FOR_FN(cfun)));\r\nbb = single_succ(ENTRY_BLOCK_PTR_FOR_FN(cfun));\r\nif (!single_pred_p(bb)) {\r\nsplit_edge(single_succ_edge(ENTRY_BLOCK_PTR_FOR_FN(cfun)));\r\ngcc_assert(single_succ_p(ENTRY_BLOCK_PTR_FOR_FN(cfun)));\r\n}\r\nFOR_EACH_LOCAL_DECL(cfun, i, var) {\r\ntree type = TREE_TYPE(var);\r\ngcc_assert(DECL_P(var));\r\nif (!auto_var_in_fn_p(var, current_function_decl))\r\ncontinue;\r\nif (TREE_CODE(type) != RECORD_TYPE && TREE_CODE(type) != UNION_TYPE)\r\ncontinue;\r\nif (TYPE_USERSPACE(type))\r\ninitialize(var);\r\n}\r\nreturn ret;\r\n}\r\n__visible int plugin_init(struct plugin_name_args *plugin_info, struct plugin_gcc_version *version)\r\n{\r\nint i;\r\nconst char * const plugin_name = plugin_info->base_name;\r\nconst int argc = plugin_info->argc;\r\nconst struct plugin_argument * const argv = plugin_info->argv;\r\nbool enable = true;\r\nPASS_INFO(structleak, "early_optimizations", 1, PASS_POS_INSERT_BEFORE);\r\nif (!plugin_default_version_check(version, &gcc_version)) {\r\nerror(G_("incompatible gcc/plugin versions"));\r\nreturn 1;\r\n}\r\nif (strncmp(lang_hooks.name, "GNU C", 5) && !strncmp(lang_hooks.name, "GNU C+", 6)) {\r\ninform(UNKNOWN_LOCATION, G_("%s supports C only, not %s"), plugin_name, lang_hooks.name);\r\nenable = false;\r\n}\r\nfor (i = 0; i < argc; ++i) {\r\nif (!strcmp(argv[i].key, "disable")) {\r\nenable = false;\r\ncontinue;\r\n}\r\nif (!strcmp(argv[i].key, "verbose")) {\r\nverbose = true;\r\ncontinue;\r\n}\r\nerror(G_("unknown option '-fplugin-arg-%s-%s'"), plugin_name, argv[i].key);\r\n}\r\nregister_callback(plugin_name, PLUGIN_INFO, NULL, &structleak_plugin_info);\r\nif (enable) {\r\nregister_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL, &structleak_pass_info);\r\nregister_callback(plugin_name, PLUGIN_FINISH_TYPE, finish_type, NULL);\r\n}\r\nregister_callback(plugin_name, PLUGIN_ATTRIBUTES, register_attributes, NULL);\r\nreturn 0;\r\n}
