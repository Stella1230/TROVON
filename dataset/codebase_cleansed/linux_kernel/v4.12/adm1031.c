static inline u8 adm1031_read_value(struct i2c_client *client, u8 reg)\r\n{\r\nreturn i2c_smbus_read_byte_data(client, reg);\r\n}\r\nstatic inline int\r\nadm1031_write_value(struct i2c_client *client, u8 reg, unsigned int value)\r\n{\r\nreturn i2c_smbus_write_byte_data(client, reg, value);\r\n}\r\nstatic struct adm1031_data *adm1031_update_device(struct device *dev)\r\n{\r\nstruct adm1031_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nunsigned long next_update;\r\nint chan;\r\nmutex_lock(&data->update_lock);\r\nnext_update = data->last_updated\r\n+ msecs_to_jiffies(data->update_interval);\r\nif (time_after(jiffies, next_update) || !data->valid) {\r\ndev_dbg(&client->dev, "Starting adm1031 update\n");\r\nfor (chan = 0;\r\nchan < ((data->chip_type == adm1031) ? 3 : 2); chan++) {\r\nu8 oldh, newh;\r\noldh =\r\nadm1031_read_value(client, ADM1031_REG_TEMP(chan));\r\ndata->ext_temp[chan] =\r\nadm1031_read_value(client, ADM1031_REG_EXT_TEMP);\r\nnewh =\r\nadm1031_read_value(client, ADM1031_REG_TEMP(chan));\r\nif (newh != oldh) {\r\ndata->ext_temp[chan] =\r\nadm1031_read_value(client,\r\nADM1031_REG_EXT_TEMP);\r\n#ifdef DEBUG\r\noldh =\r\nadm1031_read_value(client,\r\nADM1031_REG_TEMP(chan));\r\nif (newh != oldh)\r\ndev_warn(&client->dev,\r\n"Remote temperature may be wrong.\n");\r\n#endif\r\n}\r\ndata->temp[chan] = newh;\r\ndata->temp_offset[chan] =\r\nadm1031_read_value(client,\r\nADM1031_REG_TEMP_OFFSET(chan));\r\ndata->temp_min[chan] =\r\nadm1031_read_value(client,\r\nADM1031_REG_TEMP_MIN(chan));\r\ndata->temp_max[chan] =\r\nadm1031_read_value(client,\r\nADM1031_REG_TEMP_MAX(chan));\r\ndata->temp_crit[chan] =\r\nadm1031_read_value(client,\r\nADM1031_REG_TEMP_CRIT(chan));\r\ndata->auto_temp[chan] =\r\nadm1031_read_value(client,\r\nADM1031_REG_AUTO_TEMP(chan));\r\n}\r\ndata->conf1 = adm1031_read_value(client, ADM1031_REG_CONF1);\r\ndata->conf2 = adm1031_read_value(client, ADM1031_REG_CONF2);\r\ndata->alarm = adm1031_read_value(client, ADM1031_REG_STATUS(0))\r\n| (adm1031_read_value(client, ADM1031_REG_STATUS(1)) << 8);\r\nif (data->chip_type == adm1030)\r\ndata->alarm &= 0xc0ff;\r\nfor (chan = 0; chan < (data->chip_type == adm1030 ? 1 : 2);\r\nchan++) {\r\ndata->fan_div[chan] =\r\nadm1031_read_value(client,\r\nADM1031_REG_FAN_DIV(chan));\r\ndata->fan_min[chan] =\r\nadm1031_read_value(client,\r\nADM1031_REG_FAN_MIN(chan));\r\ndata->fan[chan] =\r\nadm1031_read_value(client,\r\nADM1031_REG_FAN_SPEED(chan));\r\ndata->pwm[chan] =\r\n(adm1031_read_value(client,\r\nADM1031_REG_PWM) >> (4 * chan)) & 0x0f;\r\n}\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic int FAN_TO_REG(int reg, int div)\r\n{\r\nint tmp;\r\ntmp = FAN_FROM_REG(clamp_val(reg, 0, 65535), div);\r\nreturn tmp > 255 ? 255 : tmp;\r\n}\r\nstatic int AUTO_TEMP_MAX_TO_REG(int val, int reg, int pwm)\r\n{\r\nint ret;\r\nint range = val - AUTO_TEMP_MIN_FROM_REG(reg);\r\nrange = ((val - AUTO_TEMP_MIN_FROM_REG(reg))*10)/(16 - pwm);\r\nret = ((reg & 0xf8) |\r\n(range < 10000 ? 0 :\r\nrange < 20000 ? 1 :\r\nrange < 40000 ? 2 : range < 80000 ? 3 : 4));\r\nreturn ret;\r\n}\r\nstatic int\r\nget_fan_auto_nearest(struct adm1031_data *data, int chan, u8 val, u8 reg)\r\n{\r\nint i;\r\nint first_match = -1, exact_match = -1;\r\nu8 other_reg_val =\r\n(*data->chan_select_table)[FAN_CHAN_FROM_REG(reg)][chan ? 0 : 1];\r\nif (val == 0)\r\nreturn 0;\r\nfor (i = 0; i < 8; i++) {\r\nif ((val == (*data->chan_select_table)[i][chan]) &&\r\n((*data->chan_select_table)[i][chan ? 0 : 1] ==\r\nother_reg_val)) {\r\nexact_match = i;\r\nbreak;\r\n} else if (val == (*data->chan_select_table)[i][chan] &&\r\nfirst_match == -1) {\r\nfirst_match = i;\r\n}\r\n}\r\nif (exact_match >= 0)\r\nreturn exact_match;\r\nelse if (first_match >= 0)\r\nreturn first_match;\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t show_fan_auto_channel(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct adm1031_data *data = adm1031_update_device(dev);\r\nreturn sprintf(buf, "%d\n", GET_FAN_AUTO_BITFIELD(data, nr));\r\n}\r\nstatic ssize_t\r\nset_fan_auto_channel(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct adm1031_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nlong val;\r\nu8 reg;\r\nint ret;\r\nu8 old_fan_mode;\r\nret = kstrtol(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nold_fan_mode = data->conf1;\r\nmutex_lock(&data->update_lock);\r\nret = get_fan_auto_nearest(data, nr, val, data->conf1);\r\nif (ret < 0) {\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nreg = ret;\r\ndata->conf1 = FAN_CHAN_TO_REG(reg, data->conf1);\r\nif ((data->conf1 & ADM1031_CONF1_AUTO_MODE) ^\r\n(old_fan_mode & ADM1031_CONF1_AUTO_MODE)) {\r\nif (data->conf1 & ADM1031_CONF1_AUTO_MODE) {\r\ndata->old_pwm[0] = data->pwm[0];\r\ndata->old_pwm[1] = data->pwm[1];\r\nadm1031_write_value(client, ADM1031_REG_PWM, 0x55);\r\n} else {\r\ndata->pwm[0] = data->old_pwm[0];\r\ndata->pwm[1] = data->old_pwm[1];\r\nadm1031_write_value(client, ADM1031_REG_PWM,\r\ndata->pwm[0] | (data->pwm[1] << 4));\r\n}\r\n}\r\ndata->conf1 = FAN_CHAN_TO_REG(reg, data->conf1);\r\nadm1031_write_value(client, ADM1031_REG_CONF1, data->conf1);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_auto_temp_off(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct adm1031_data *data = adm1031_update_device(dev);\r\nreturn sprintf(buf, "%d\n",\r\nAUTO_TEMP_OFF_FROM_REG(data->auto_temp[nr]));\r\n}\r\nstatic ssize_t show_auto_temp_min(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct adm1031_data *data = adm1031_update_device(dev);\r\nreturn sprintf(buf, "%d\n",\r\nAUTO_TEMP_MIN_FROM_REG(data->auto_temp[nr]));\r\n}\r\nstatic ssize_t\r\nset_auto_temp_min(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct adm1031_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nlong val;\r\nint ret;\r\nret = kstrtol(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nval = clamp_val(val, 0, 127000);\r\nmutex_lock(&data->update_lock);\r\ndata->auto_temp[nr] = AUTO_TEMP_MIN_TO_REG(val, data->auto_temp[nr]);\r\nadm1031_write_value(client, ADM1031_REG_AUTO_TEMP(nr),\r\ndata->auto_temp[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_auto_temp_max(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct adm1031_data *data = adm1031_update_device(dev);\r\nreturn sprintf(buf, "%d\n",\r\nAUTO_TEMP_MAX_FROM_REG(data->auto_temp[nr]));\r\n}\r\nstatic ssize_t\r\nset_auto_temp_max(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct adm1031_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nlong val;\r\nint ret;\r\nret = kstrtol(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nval = clamp_val(val, 0, 127000);\r\nmutex_lock(&data->update_lock);\r\ndata->temp_max[nr] = AUTO_TEMP_MAX_TO_REG(val, data->auto_temp[nr],\r\ndata->pwm[nr]);\r\nadm1031_write_value(client, ADM1031_REG_AUTO_TEMP(nr),\r\ndata->temp_max[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct adm1031_data *data = adm1031_update_device(dev);\r\nreturn sprintf(buf, "%d\n", PWM_FROM_REG(data->pwm[nr]));\r\n}\r\nstatic ssize_t set_pwm(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct adm1031_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nlong val;\r\nint ret, reg;\r\nret = kstrtol(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&data->update_lock);\r\nif ((data->conf1 & ADM1031_CONF1_AUTO_MODE) &&\r\n(((val>>4) & 0xf) != 5)) {\r\nmutex_unlock(&data->update_lock);\r\nreturn -EINVAL;\r\n}\r\ndata->pwm[nr] = PWM_TO_REG(val);\r\nreg = adm1031_read_value(client, ADM1031_REG_PWM);\r\nadm1031_write_value(client, ADM1031_REG_PWM,\r\nnr ? ((data->pwm[nr] << 4) & 0xf0) | (reg & 0xf)\r\n: (data->pwm[nr] & 0xf) | (reg & 0xf0));\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic int trust_fan_readings(struct adm1031_data *data, int chan)\r\n{\r\nint res = 0;\r\nif (data->conf1 & ADM1031_CONF1_AUTO_MODE) {\r\nswitch (data->conf1 & 0x60) {\r\ncase 0x00:\r\nres = data->temp[chan+1] >=\r\nAUTO_TEMP_MIN_FROM_REG_DEG(data->auto_temp[chan+1]);\r\nbreak;\r\ncase 0x20:\r\nres =\r\ndata->temp[1] >=\r\nAUTO_TEMP_MIN_FROM_REG_DEG(data->auto_temp[1]);\r\nbreak;\r\ncase 0x40:\r\nres =\r\ndata->temp[2] >=\r\nAUTO_TEMP_MIN_FROM_REG_DEG(data->auto_temp[2]);\r\nbreak;\r\ncase 0x60:\r\nres =\r\ndata->temp[0] >=\r\nAUTO_TEMP_MIN_FROM_REG_DEG(data->auto_temp[0])\r\n|| data->temp[1] >=\r\nAUTO_TEMP_MIN_FROM_REG_DEG(data->auto_temp[1])\r\n|| (data->chip_type == adm1031\r\n&& data->temp[2] >=\r\nAUTO_TEMP_MIN_FROM_REG_DEG(data->auto_temp[2]));\r\nbreak;\r\n}\r\n} else {\r\nres = data->pwm[chan] > 0;\r\n}\r\nreturn res;\r\n}\r\nstatic ssize_t show_fan(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct adm1031_data *data = adm1031_update_device(dev);\r\nint value;\r\nvalue = trust_fan_readings(data, nr) ? FAN_FROM_REG(data->fan[nr],\r\nFAN_DIV_FROM_REG(data->fan_div[nr])) : 0;\r\nreturn sprintf(buf, "%d\n", value);\r\n}\r\nstatic ssize_t show_fan_div(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct adm1031_data *data = adm1031_update_device(dev);\r\nreturn sprintf(buf, "%d\n", FAN_DIV_FROM_REG(data->fan_div[nr]));\r\n}\r\nstatic ssize_t show_fan_min(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct adm1031_data *data = adm1031_update_device(dev);\r\nreturn sprintf(buf, "%d\n",\r\nFAN_FROM_REG(data->fan_min[nr],\r\nFAN_DIV_FROM_REG(data->fan_div[nr])));\r\n}\r\nstatic ssize_t set_fan_min(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct adm1031_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nlong val;\r\nint ret;\r\nret = kstrtol(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&data->update_lock);\r\nif (val) {\r\ndata->fan_min[nr] =\r\nFAN_TO_REG(val, FAN_DIV_FROM_REG(data->fan_div[nr]));\r\n} else {\r\ndata->fan_min[nr] = 0xff;\r\n}\r\nadm1031_write_value(client, ADM1031_REG_FAN_MIN(nr), data->fan_min[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_fan_div(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct adm1031_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nlong val;\r\nu8 tmp;\r\nint old_div;\r\nint new_min;\r\nint ret;\r\nret = kstrtol(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\ntmp = val == 8 ? 0xc0 :\r\nval == 4 ? 0x80 :\r\nval == 2 ? 0x40 :\r\nval == 1 ? 0x00 :\r\n0xff;\r\nif (tmp == 0xff)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->fan_div[nr] = adm1031_read_value(client,\r\nADM1031_REG_FAN_DIV(nr));\r\ndata->fan_min[nr] = adm1031_read_value(client,\r\nADM1031_REG_FAN_MIN(nr));\r\nold_div = FAN_DIV_FROM_REG(data->fan_div[nr]);\r\ndata->fan_div[nr] = tmp | (0x3f & data->fan_div[nr]);\r\nnew_min = data->fan_min[nr] * old_div / val;\r\ndata->fan_min[nr] = new_min > 0xff ? 0xff : new_min;\r\nadm1031_write_value(client, ADM1031_REG_FAN_DIV(nr),\r\ndata->fan_div[nr]);\r\nadm1031_write_value(client, ADM1031_REG_FAN_MIN(nr),\r\ndata->fan_min[nr]);\r\ndata->valid = 0;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct adm1031_data *data = adm1031_update_device(dev);\r\nint ext;\r\next = nr == 0 ?\r\n((data->ext_temp[nr] >> 6) & 0x3) * 2 :\r\n(((data->ext_temp[nr] >> ((nr - 1) * 3)) & 7));\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG_EXT(data->temp[nr], ext));\r\n}\r\nstatic ssize_t show_temp_offset(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct adm1031_data *data = adm1031_update_device(dev);\r\nreturn sprintf(buf, "%d\n",\r\nTEMP_OFFSET_FROM_REG(data->temp_offset[nr]));\r\n}\r\nstatic ssize_t show_temp_min(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct adm1031_data *data = adm1031_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp_min[nr]));\r\n}\r\nstatic ssize_t show_temp_max(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct adm1031_data *data = adm1031_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp_max[nr]));\r\n}\r\nstatic ssize_t show_temp_crit(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct adm1031_data *data = adm1031_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp_crit[nr]));\r\n}\r\nstatic ssize_t set_temp_offset(struct device *dev,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct adm1031_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nlong val;\r\nint ret;\r\nret = kstrtol(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nval = clamp_val(val, -15000, 15000);\r\nmutex_lock(&data->update_lock);\r\ndata->temp_offset[nr] = TEMP_OFFSET_TO_REG(val);\r\nadm1031_write_value(client, ADM1031_REG_TEMP_OFFSET(nr),\r\ndata->temp_offset[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_temp_min(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct adm1031_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nlong val;\r\nint ret;\r\nret = kstrtol(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nval = clamp_val(val, -55000, 127000);\r\nmutex_lock(&data->update_lock);\r\ndata->temp_min[nr] = TEMP_TO_REG(val);\r\nadm1031_write_value(client, ADM1031_REG_TEMP_MIN(nr),\r\ndata->temp_min[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_temp_max(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct adm1031_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nlong val;\r\nint ret;\r\nret = kstrtol(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nval = clamp_val(val, -55000, 127000);\r\nmutex_lock(&data->update_lock);\r\ndata->temp_max[nr] = TEMP_TO_REG(val);\r\nadm1031_write_value(client, ADM1031_REG_TEMP_MAX(nr),\r\ndata->temp_max[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_temp_crit(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct adm1031_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nlong val;\r\nint ret;\r\nret = kstrtol(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nval = clamp_val(val, -55000, 127000);\r\nmutex_lock(&data->update_lock);\r\ndata->temp_crit[nr] = TEMP_TO_REG(val);\r\nadm1031_write_value(client, ADM1031_REG_TEMP_CRIT(nr),\r\ndata->temp_crit[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t alarms_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct adm1031_data *data = adm1031_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->alarm);\r\n}\r\nstatic ssize_t show_alarm(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint bitnr = to_sensor_dev_attr(attr)->index;\r\nstruct adm1031_data *data = adm1031_update_device(dev);\r\nreturn sprintf(buf, "%d\n", (data->alarm >> bitnr) & 1);\r\n}\r\nstatic ssize_t update_interval_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct adm1031_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", data->update_interval);\r\n}\r\nstatic ssize_t update_interval_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct adm1031_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nunsigned long val;\r\nint i, err;\r\nu8 reg;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < ARRAY_SIZE(update_intervals) - 1; i++) {\r\nif (val >= update_intervals[i])\r\nbreak;\r\n}\r\nreg = adm1031_read_value(client, ADM1031_REG_FAN_FILTER);\r\nreg &= ~ADM1031_UPDATE_RATE_MASK;\r\nreg |= i << ADM1031_UPDATE_RATE_SHIFT;\r\nadm1031_write_value(client, ADM1031_REG_FAN_FILTER, reg);\r\nmutex_lock(&data->update_lock);\r\ndata->update_interval = update_intervals[i];\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic int adm1031_detect(struct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nconst char *name;\r\nint id, co;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nid = i2c_smbus_read_byte_data(client, 0x3d);\r\nco = i2c_smbus_read_byte_data(client, 0x3e);\r\nif (!((id == 0x31 || id == 0x30) && co == 0x41))\r\nreturn -ENODEV;\r\nname = (id == 0x30) ? "adm1030" : "adm1031";\r\nstrlcpy(info->type, name, I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic void adm1031_init_client(struct i2c_client *client)\r\n{\r\nunsigned int read_val;\r\nunsigned int mask;\r\nint i;\r\nstruct adm1031_data *data = i2c_get_clientdata(client);\r\nmask = (ADM1031_CONF2_PWM1_ENABLE | ADM1031_CONF2_TACH1_ENABLE);\r\nif (data->chip_type == adm1031) {\r\nmask |= (ADM1031_CONF2_PWM2_ENABLE |\r\nADM1031_CONF2_TACH2_ENABLE);\r\n}\r\nread_val = adm1031_read_value(client, ADM1031_REG_CONF2);\r\nif ((read_val | mask) != read_val)\r\nadm1031_write_value(client, ADM1031_REG_CONF2, read_val | mask);\r\nread_val = adm1031_read_value(client, ADM1031_REG_CONF1);\r\nif ((read_val | ADM1031_CONF1_MONITOR_ENABLE) != read_val) {\r\nadm1031_write_value(client, ADM1031_REG_CONF1,\r\nread_val | ADM1031_CONF1_MONITOR_ENABLE);\r\n}\r\nmask = ADM1031_UPDATE_RATE_MASK;\r\nread_val = adm1031_read_value(client, ADM1031_REG_FAN_FILTER);\r\ni = (read_val & mask) >> ADM1031_UPDATE_RATE_SHIFT;\r\ndata->update_interval = update_intervals[i];\r\n}\r\nstatic int adm1031_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct device *hwmon_dev;\r\nstruct adm1031_data *data;\r\ndata = devm_kzalloc(dev, sizeof(struct adm1031_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\ndata->client = client;\r\ndata->chip_type = id->driver_data;\r\nmutex_init(&data->update_lock);\r\nif (data->chip_type == adm1030)\r\ndata->chan_select_table = &auto_channel_select_table_adm1030;\r\nelse\r\ndata->chan_select_table = &auto_channel_select_table_adm1031;\r\nadm1031_init_client(client);\r\ndata->groups[0] = &adm1031_group;\r\nif (data->chip_type == adm1031)\r\ndata->groups[1] = &adm1031_group_opt;\r\nhwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\r\ndata, data->groups);\r\nreturn PTR_ERR_OR_ZERO(hwmon_dev);\r\n}
