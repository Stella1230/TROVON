static void cpm1_cmd(int op)\r\n{\r\nwhile (in_be16(cpcr) & 1)\r\n;\r\nout_be16(cpcr, (op << 8) | cpm_cmd | 1);\r\nwhile (in_be16(cpcr) & 1)\r\n;\r\n}\r\nstatic void cpm2_cmd(int op)\r\n{\r\nwhile (in_be32(cpcr) & 0x10000)\r\n;\r\nout_be32(cpcr, op | cpm_cmd | 0x10000);\r\nwhile (in_be32(cpcr) & 0x10000)\r\n;\r\n}\r\nstatic void smc_disable_port(void)\r\n{\r\ndo_cmd(CPM_CMD_STOP_TX);\r\nout_be16(&smc->smcmr, in_be16(&smc->smcmr) & ~3);\r\n}\r\nstatic void scc_disable_port(void)\r\n{\r\ndo_cmd(CPM_CMD_STOP_TX);\r\nout_be32(&scc->gsmrl, in_be32(&scc->gsmrl) & ~0x30);\r\n}\r\nstatic void smc_enable_port(void)\r\n{\r\nout_be16(&smc->smcmr, in_be16(&smc->smcmr) | 3);\r\ndo_cmd(CPM_CMD_RESTART_TX);\r\n}\r\nstatic void scc_enable_port(void)\r\n{\r\nout_be32(&scc->gsmrl, in_be32(&scc->gsmrl) | 0x30);\r\ndo_cmd(CPM_CMD_RESTART_TX);\r\n}\r\nstatic int cpm_serial_open(void)\r\n{\r\ndisable_port();\r\nout_8(&param->rfcr, 0x10);\r\nout_8(&param->tfcr, 0x10);\r\nout_be16(&param->mrblr, 1);\r\nout_be16(&param->maxidl, 0);\r\nout_be16(&param->brkec, 0);\r\nout_be16(&param->brkln, 0);\r\nout_be16(&param->brkcr, 0);\r\nrbdf = cbd_addr;\r\nrbdf->addr = (u8 *)rbdf - 1;\r\nrbdf->sc = 0xa000;\r\nrbdf->len = 1;\r\ntbdf = rbdf + 1;\r\ntbdf->addr = (u8 *)rbdf - 2;\r\ntbdf->sc = 0x2000;\r\ntbdf->len = 1;\r\nsync();\r\nout_be16(&param->rbase, cbd_offset);\r\nout_be16(&param->tbase, cbd_offset + sizeof(struct cpm_bd));\r\ndo_cmd(CPM_CMD_INIT_RX_TX);\r\nenable_port();\r\nreturn 0;\r\n}\r\nstatic void cpm_serial_putc(unsigned char c)\r\n{\r\nwhile (tbdf->sc & 0x8000)\r\nbarrier();\r\nsync();\r\ntbdf->addr[0] = c;\r\neieio();\r\ntbdf->sc |= 0x8000;\r\n}\r\nstatic unsigned char cpm_serial_tstc(void)\r\n{\r\nbarrier();\r\nreturn !(rbdf->sc & 0x8000);\r\n}\r\nstatic unsigned char cpm_serial_getc(void)\r\n{\r\nunsigned char c;\r\nwhile (!cpm_serial_tstc())\r\n;\r\nsync();\r\nc = rbdf->addr[0];\r\neieio();\r\nrbdf->sc |= 0x8000;\r\nreturn c;\r\n}\r\nint cpm_console_init(void *devp, struct serial_console_data *scdp)\r\n{\r\nvoid *vreg[2];\r\nu32 reg[2];\r\nint is_smc = 0, is_cpm2 = 0;\r\nvoid *parent, *muram;\r\nvoid *muram_addr;\r\nunsigned long muram_offset, muram_size;\r\nif (dt_is_compatible(devp, "fsl,cpm1-smc-uart")) {\r\nis_smc = 1;\r\n} else if (dt_is_compatible(devp, "fsl,cpm2-scc-uart")) {\r\nis_cpm2 = 1;\r\n} else if (dt_is_compatible(devp, "fsl,cpm2-smc-uart")) {\r\nis_cpm2 = 1;\r\nis_smc = 1;\r\n}\r\nif (is_smc) {\r\nenable_port = smc_enable_port;\r\ndisable_port = smc_disable_port;\r\n} else {\r\nenable_port = scc_enable_port;\r\ndisable_port = scc_disable_port;\r\n}\r\nif (is_cpm2)\r\ndo_cmd = cpm2_cmd;\r\nelse\r\ndo_cmd = cpm1_cmd;\r\nif (getprop(devp, "fsl,cpm-command", &cpm_cmd, 4) < 4)\r\nreturn -1;\r\nif (dt_get_virtual_reg(devp, vreg, 2) < 2)\r\nreturn -1;\r\nif (is_smc)\r\nsmc = vreg[0];\r\nelse\r\nscc = vreg[0];\r\nparam = vreg[1];\r\nparent = get_parent(devp);\r\nif (!parent)\r\nreturn -1;\r\nif (dt_get_virtual_reg(parent, &cpcr, 1) < 1)\r\nreturn -1;\r\nmuram = finddevice("/soc/cpm/muram/data");\r\nif (!muram)\r\nreturn -1;\r\nif (dt_get_virtual_reg(muram, &muram_addr, 1) < 1)\r\nreturn -1;\r\nif (getprop(muram, "reg", reg, 8) < 8)\r\nreturn -1;\r\nmuram_offset = reg[0];\r\nmuram_size = reg[1];\r\ncbd_offset = muram_offset + muram_size - 2 * sizeof(struct cpm_bd);\r\nif (is_cpm2 && is_smc) {\r\nu16 *smc_base = (u16 *)param;\r\nu16 pram_offset;\r\npram_offset = cbd_offset - 64;\r\npram_offset = _ALIGN_DOWN(pram_offset, 64);\r\ndisable_port();\r\nout_be16(smc_base, pram_offset);\r\nparam = muram_addr - muram_offset + pram_offset;\r\n}\r\ncbd_addr = muram_addr - muram_offset + cbd_offset;\r\nscdp->open = cpm_serial_open;\r\nscdp->putc = cpm_serial_putc;\r\nscdp->getc = cpm_serial_getc;\r\nscdp->tstc = cpm_serial_tstc;\r\nreturn 0;\r\n}
