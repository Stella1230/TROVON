static void vim2m_dev_release(struct device *dev)\r\n{}\r\nstatic struct vim2m_fmt *find_format(struct v4l2_format *f)\r\n{\r\nstruct vim2m_fmt *fmt;\r\nunsigned int k;\r\nfor (k = 0; k < NUM_FORMATS; k++) {\r\nfmt = &formats[k];\r\nif (fmt->fourcc == f->fmt.pix.pixelformat)\r\nbreak;\r\n}\r\nif (k == NUM_FORMATS)\r\nreturn NULL;\r\nreturn &formats[k];\r\n}\r\nstatic inline struct vim2m_ctx *file2ctx(struct file *file)\r\n{\r\nreturn container_of(file->private_data, struct vim2m_ctx, fh);\r\n}\r\nstatic struct vim2m_q_data *get_q_data(struct vim2m_ctx *ctx,\r\nenum v4l2_buf_type type)\r\n{\r\nswitch (type) {\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT:\r\nreturn &ctx->q_data[V4L2_M2M_SRC];\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nreturn &ctx->q_data[V4L2_M2M_DST];\r\ndefault:\r\nBUG();\r\n}\r\nreturn NULL;\r\n}\r\nstatic int device_process(struct vim2m_ctx *ctx,\r\nstruct vb2_v4l2_buffer *in_vb,\r\nstruct vb2_v4l2_buffer *out_vb)\r\n{\r\nstruct vim2m_dev *dev = ctx->dev;\r\nstruct vim2m_q_data *q_data;\r\nu8 *p_in, *p_out;\r\nint x, y, t, w;\r\nint tile_w, bytes_left;\r\nint width, height, bytesperline;\r\nq_data = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\r\nwidth = q_data->width;\r\nheight = q_data->height;\r\nbytesperline = (q_data->width * q_data->fmt->depth) >> 3;\r\np_in = vb2_plane_vaddr(&in_vb->vb2_buf, 0);\r\np_out = vb2_plane_vaddr(&out_vb->vb2_buf, 0);\r\nif (!p_in || !p_out) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"Acquiring kernel pointers to buffers failed\n");\r\nreturn -EFAULT;\r\n}\r\nif (vb2_plane_size(&in_vb->vb2_buf, 0) >\r\nvb2_plane_size(&out_vb->vb2_buf, 0)) {\r\nv4l2_err(&dev->v4l2_dev, "Output buffer is too small\n");\r\nreturn -EINVAL;\r\n}\r\ntile_w = (width * (q_data[V4L2_M2M_DST].fmt->depth >> 3))\r\n/ MEM2MEM_NUM_TILES;\r\nbytes_left = bytesperline - tile_w * MEM2MEM_NUM_TILES;\r\nw = 0;\r\nout_vb->sequence =\r\nget_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE)->sequence++;\r\nin_vb->sequence = q_data->sequence++;\r\nout_vb->vb2_buf.timestamp = in_vb->vb2_buf.timestamp;\r\nif (in_vb->flags & V4L2_BUF_FLAG_TIMECODE)\r\nout_vb->timecode = in_vb->timecode;\r\nout_vb->field = in_vb->field;\r\nout_vb->flags = in_vb->flags &\r\n(V4L2_BUF_FLAG_TIMECODE |\r\nV4L2_BUF_FLAG_KEYFRAME |\r\nV4L2_BUF_FLAG_PFRAME |\r\nV4L2_BUF_FLAG_BFRAME |\r\nV4L2_BUF_FLAG_TSTAMP_SRC_MASK);\r\nswitch (ctx->mode) {\r\ncase MEM2MEM_HFLIP | MEM2MEM_VFLIP:\r\np_out += bytesperline * height - bytes_left;\r\nfor (y = 0; y < height; ++y) {\r\nfor (t = 0; t < MEM2MEM_NUM_TILES; ++t) {\r\nif (w & 0x1) {\r\nfor (x = 0; x < tile_w; ++x)\r\n*--p_out = *p_in++ +\r\nMEM2MEM_COLOR_STEP;\r\n} else {\r\nfor (x = 0; x < tile_w; ++x)\r\n*--p_out = *p_in++ -\r\nMEM2MEM_COLOR_STEP;\r\n}\r\n++w;\r\n}\r\np_in += bytes_left;\r\np_out -= bytes_left;\r\n}\r\nbreak;\r\ncase MEM2MEM_HFLIP:\r\nfor (y = 0; y < height; ++y) {\r\np_out += MEM2MEM_NUM_TILES * tile_w;\r\nfor (t = 0; t < MEM2MEM_NUM_TILES; ++t) {\r\nif (w & 0x01) {\r\nfor (x = 0; x < tile_w; ++x)\r\n*--p_out = *p_in++ +\r\nMEM2MEM_COLOR_STEP;\r\n} else {\r\nfor (x = 0; x < tile_w; ++x)\r\n*--p_out = *p_in++ -\r\nMEM2MEM_COLOR_STEP;\r\n}\r\n++w;\r\n}\r\np_in += bytes_left;\r\np_out += bytesperline;\r\n}\r\nbreak;\r\ncase MEM2MEM_VFLIP:\r\np_out += bytesperline * (height - 1);\r\nfor (y = 0; y < height; ++y) {\r\nfor (t = 0; t < MEM2MEM_NUM_TILES; ++t) {\r\nif (w & 0x1) {\r\nfor (x = 0; x < tile_w; ++x)\r\n*p_out++ = *p_in++ +\r\nMEM2MEM_COLOR_STEP;\r\n} else {\r\nfor (x = 0; x < tile_w; ++x)\r\n*p_out++ = *p_in++ -\r\nMEM2MEM_COLOR_STEP;\r\n}\r\n++w;\r\n}\r\np_in += bytes_left;\r\np_out += bytes_left - 2 * bytesperline;\r\n}\r\nbreak;\r\ndefault:\r\nfor (y = 0; y < height; ++y) {\r\nfor (t = 0; t < MEM2MEM_NUM_TILES; ++t) {\r\nif (w & 0x1) {\r\nfor (x = 0; x < tile_w; ++x)\r\n*p_out++ = *p_in++ +\r\nMEM2MEM_COLOR_STEP;\r\n} else {\r\nfor (x = 0; x < tile_w; ++x)\r\n*p_out++ = *p_in++ -\r\nMEM2MEM_COLOR_STEP;\r\n}\r\n++w;\r\n}\r\np_in += bytes_left;\r\np_out += bytes_left;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void schedule_irq(struct vim2m_dev *dev, int msec_timeout)\r\n{\r\ndprintk(dev, "Scheduling a simulated irq\n");\r\nmod_timer(&dev->timer, jiffies + msecs_to_jiffies(msec_timeout));\r\n}\r\nstatic int job_ready(void *priv)\r\n{\r\nstruct vim2m_ctx *ctx = priv;\r\nif (v4l2_m2m_num_src_bufs_ready(ctx->fh.m2m_ctx) < ctx->translen\r\n|| v4l2_m2m_num_dst_bufs_ready(ctx->fh.m2m_ctx) < ctx->translen) {\r\ndprintk(ctx->dev, "Not enough buffers available\n");\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void job_abort(void *priv)\r\n{\r\nstruct vim2m_ctx *ctx = priv;\r\nctx->aborting = 1;\r\n}\r\nstatic void device_run(void *priv)\r\n{\r\nstruct vim2m_ctx *ctx = priv;\r\nstruct vim2m_dev *dev = ctx->dev;\r\nstruct vb2_v4l2_buffer *src_buf, *dst_buf;\r\nsrc_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\r\ndst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\r\ndevice_process(ctx, src_buf, dst_buf);\r\nschedule_irq(dev, ctx->transtime);\r\n}\r\nstatic void device_isr(unsigned long priv)\r\n{\r\nstruct vim2m_dev *vim2m_dev = (struct vim2m_dev *)priv;\r\nstruct vim2m_ctx *curr_ctx;\r\nstruct vb2_v4l2_buffer *src_vb, *dst_vb;\r\nunsigned long flags;\r\ncurr_ctx = v4l2_m2m_get_curr_priv(vim2m_dev->m2m_dev);\r\nif (NULL == curr_ctx) {\r\npr_err("Instance released before the end of transaction\n");\r\nreturn;\r\n}\r\nsrc_vb = v4l2_m2m_src_buf_remove(curr_ctx->fh.m2m_ctx);\r\ndst_vb = v4l2_m2m_dst_buf_remove(curr_ctx->fh.m2m_ctx);\r\ncurr_ctx->num_processed++;\r\nspin_lock_irqsave(&vim2m_dev->irqlock, flags);\r\nv4l2_m2m_buf_done(src_vb, VB2_BUF_STATE_DONE);\r\nv4l2_m2m_buf_done(dst_vb, VB2_BUF_STATE_DONE);\r\nspin_unlock_irqrestore(&vim2m_dev->irqlock, flags);\r\nif (curr_ctx->num_processed == curr_ctx->translen\r\n|| curr_ctx->aborting) {\r\ndprintk(curr_ctx->dev, "Finishing transaction\n");\r\ncurr_ctx->num_processed = 0;\r\nv4l2_m2m_job_finish(vim2m_dev->m2m_dev, curr_ctx->fh.m2m_ctx);\r\n} else {\r\ndevice_run(curr_ctx);\r\n}\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstrncpy(cap->driver, MEM2MEM_NAME, sizeof(cap->driver) - 1);\r\nstrncpy(cap->card, MEM2MEM_NAME, sizeof(cap->card) - 1);\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info),\r\n"platform:%s", MEM2MEM_NAME);\r\ncap->device_caps = V4L2_CAP_VIDEO_M2M | V4L2_CAP_STREAMING;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int enum_fmt(struct v4l2_fmtdesc *f, u32 type)\r\n{\r\nint i, num;\r\nstruct vim2m_fmt *fmt;\r\nnum = 0;\r\nfor (i = 0; i < NUM_FORMATS; ++i) {\r\nif (formats[i].types & type) {\r\nif (num == f->index)\r\nbreak;\r\n++num;\r\n}\r\n}\r\nif (i < NUM_FORMATS) {\r\nfmt = &formats[i];\r\nf->pixelformat = fmt->fourcc;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nreturn enum_fmt(f, MEM2MEM_CAPTURE);\r\n}\r\nstatic int vidioc_enum_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nreturn enum_fmt(f, MEM2MEM_OUTPUT);\r\n}\r\nstatic int vidioc_g_fmt(struct vim2m_ctx *ctx, struct v4l2_format *f)\r\n{\r\nstruct vb2_queue *vq;\r\nstruct vim2m_q_data *q_data;\r\nvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\r\nif (!vq)\r\nreturn -EINVAL;\r\nq_data = get_q_data(ctx, f->type);\r\nf->fmt.pix.width = q_data->width;\r\nf->fmt.pix.height = q_data->height;\r\nf->fmt.pix.field = V4L2_FIELD_NONE;\r\nf->fmt.pix.pixelformat = q_data->fmt->fourcc;\r\nf->fmt.pix.bytesperline = (q_data->width * q_data->fmt->depth) >> 3;\r\nf->fmt.pix.sizeimage = q_data->sizeimage;\r\nf->fmt.pix.colorspace = ctx->colorspace;\r\nf->fmt.pix.xfer_func = ctx->xfer_func;\r\nf->fmt.pix.ycbcr_enc = ctx->ycbcr_enc;\r\nf->fmt.pix.quantization = ctx->quant;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nreturn vidioc_g_fmt(file2ctx(file), f);\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nreturn vidioc_g_fmt(file2ctx(file), f);\r\n}\r\nstatic int vidioc_try_fmt(struct v4l2_format *f, struct vim2m_fmt *fmt)\r\n{\r\nif (f->fmt.pix.height < MIN_H)\r\nf->fmt.pix.height = MIN_H;\r\nelse if (f->fmt.pix.height > MAX_H)\r\nf->fmt.pix.height = MAX_H;\r\nif (f->fmt.pix.width < MIN_W)\r\nf->fmt.pix.width = MIN_W;\r\nelse if (f->fmt.pix.width > MAX_W)\r\nf->fmt.pix.width = MAX_W;\r\nf->fmt.pix.width &= ~DIM_ALIGN_MASK;\r\nf->fmt.pix.bytesperline = (f->fmt.pix.width * fmt->depth) >> 3;\r\nf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\r\nf->fmt.pix.field = V4L2_FIELD_NONE;\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct vim2m_fmt *fmt;\r\nstruct vim2m_ctx *ctx = file2ctx(file);\r\nfmt = find_format(f);\r\nif (!fmt) {\r\nf->fmt.pix.pixelformat = formats[0].fourcc;\r\nfmt = find_format(f);\r\n}\r\nif (!(fmt->types & MEM2MEM_CAPTURE)) {\r\nv4l2_err(&ctx->dev->v4l2_dev,\r\n"Fourcc format (0x%08x) invalid.\n",\r\nf->fmt.pix.pixelformat);\r\nreturn -EINVAL;\r\n}\r\nf->fmt.pix.colorspace = ctx->colorspace;\r\nf->fmt.pix.xfer_func = ctx->xfer_func;\r\nf->fmt.pix.ycbcr_enc = ctx->ycbcr_enc;\r\nf->fmt.pix.quantization = ctx->quant;\r\nreturn vidioc_try_fmt(f, fmt);\r\n}\r\nstatic int vidioc_try_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct vim2m_fmt *fmt;\r\nstruct vim2m_ctx *ctx = file2ctx(file);\r\nfmt = find_format(f);\r\nif (!fmt) {\r\nf->fmt.pix.pixelformat = formats[0].fourcc;\r\nfmt = find_format(f);\r\n}\r\nif (!(fmt->types & MEM2MEM_OUTPUT)) {\r\nv4l2_err(&ctx->dev->v4l2_dev,\r\n"Fourcc format (0x%08x) invalid.\n",\r\nf->fmt.pix.pixelformat);\r\nreturn -EINVAL;\r\n}\r\nif (!f->fmt.pix.colorspace)\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_REC709;\r\nreturn vidioc_try_fmt(f, fmt);\r\n}\r\nstatic int vidioc_s_fmt(struct vim2m_ctx *ctx, struct v4l2_format *f)\r\n{\r\nstruct vim2m_q_data *q_data;\r\nstruct vb2_queue *vq;\r\nvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\r\nif (!vq)\r\nreturn -EINVAL;\r\nq_data = get_q_data(ctx, f->type);\r\nif (!q_data)\r\nreturn -EINVAL;\r\nif (vb2_is_busy(vq)) {\r\nv4l2_err(&ctx->dev->v4l2_dev, "%s queue busy\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nq_data->fmt = find_format(f);\r\nq_data->width = f->fmt.pix.width;\r\nq_data->height = f->fmt.pix.height;\r\nq_data->sizeimage = q_data->width * q_data->height\r\n* q_data->fmt->depth >> 3;\r\ndprintk(ctx->dev,\r\n"Setting format for type %d, wxh: %dx%d, fmt: %d\n",\r\nf->type, q_data->width, q_data->height, q_data->fmt->fourcc);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nint ret;\r\nret = vidioc_try_fmt_vid_cap(file, priv, f);\r\nif (ret)\r\nreturn ret;\r\nreturn vidioc_s_fmt(file2ctx(file), f);\r\n}\r\nstatic int vidioc_s_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct vim2m_ctx *ctx = file2ctx(file);\r\nint ret;\r\nret = vidioc_try_fmt_vid_out(file, priv, f);\r\nif (ret)\r\nreturn ret;\r\nret = vidioc_s_fmt(file2ctx(file), f);\r\nif (!ret) {\r\nctx->colorspace = f->fmt.pix.colorspace;\r\nctx->xfer_func = f->fmt.pix.xfer_func;\r\nctx->ycbcr_enc = f->fmt.pix.ycbcr_enc;\r\nctx->quant = f->fmt.pix.quantization;\r\n}\r\nreturn ret;\r\n}\r\nstatic int vim2m_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct vim2m_ctx *ctx =\r\ncontainer_of(ctrl->handler, struct vim2m_ctx, hdl);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_HFLIP:\r\nif (ctrl->val)\r\nctx->mode |= MEM2MEM_HFLIP;\r\nelse\r\nctx->mode &= ~MEM2MEM_HFLIP;\r\nbreak;\r\ncase V4L2_CID_VFLIP:\r\nif (ctrl->val)\r\nctx->mode |= MEM2MEM_VFLIP;\r\nelse\r\nctx->mode &= ~MEM2MEM_VFLIP;\r\nbreak;\r\ncase V4L2_CID_TRANS_TIME_MSEC:\r\nctx->transtime = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_TRANS_NUM_BUFS:\r\nctx->translen = ctrl->val;\r\nbreak;\r\ndefault:\r\nv4l2_err(&ctx->dev->v4l2_dev, "Invalid control\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vim2m_queue_setup(struct vb2_queue *vq,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], struct device *alloc_devs[])\r\n{\r\nstruct vim2m_ctx *ctx = vb2_get_drv_priv(vq);\r\nstruct vim2m_q_data *q_data;\r\nunsigned int size, count = *nbuffers;\r\nq_data = get_q_data(ctx, vq->type);\r\nsize = q_data->width * q_data->height * q_data->fmt->depth >> 3;\r\nwhile (size * count > MEM2MEM_VID_MEM_LIMIT)\r\n(count)--;\r\n*nbuffers = count;\r\nif (*nplanes)\r\nreturn sizes[0] < size ? -EINVAL : 0;\r\n*nplanes = 1;\r\nsizes[0] = size;\r\ndprintk(ctx->dev, "get %d buffer(s) of size %d each.\n", count, size);\r\nreturn 0;\r\n}\r\nstatic int vim2m_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct vim2m_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vim2m_q_data *q_data;\r\ndprintk(ctx->dev, "type: %d\n", vb->vb2_queue->type);\r\nq_data = get_q_data(ctx, vb->vb2_queue->type);\r\nif (V4L2_TYPE_IS_OUTPUT(vb->vb2_queue->type)) {\r\nif (vbuf->field == V4L2_FIELD_ANY)\r\nvbuf->field = V4L2_FIELD_NONE;\r\nif (vbuf->field != V4L2_FIELD_NONE) {\r\ndprintk(ctx->dev, "%s field isn't supported\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (vb2_plane_size(vb, 0) < q_data->sizeimage) {\r\ndprintk(ctx->dev, "%s data will not fit into plane (%lu < %lu)\n",\r\n__func__, vb2_plane_size(vb, 0), (long)q_data->sizeimage);\r\nreturn -EINVAL;\r\n}\r\nvb2_set_plane_payload(vb, 0, q_data->sizeimage);\r\nreturn 0;\r\n}\r\nstatic void vim2m_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct vim2m_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\r\n}\r\nstatic int vim2m_start_streaming(struct vb2_queue *q, unsigned count)\r\n{\r\nstruct vim2m_ctx *ctx = vb2_get_drv_priv(q);\r\nstruct vim2m_q_data *q_data = get_q_data(ctx, q->type);\r\nq_data->sequence = 0;\r\nreturn 0;\r\n}\r\nstatic void vim2m_stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct vim2m_ctx *ctx = vb2_get_drv_priv(q);\r\nstruct vb2_v4l2_buffer *vbuf;\r\nunsigned long flags;\r\nfor (;;) {\r\nif (V4L2_TYPE_IS_OUTPUT(q->type))\r\nvbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\r\nelse\r\nvbuf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\r\nif (vbuf == NULL)\r\nreturn;\r\nspin_lock_irqsave(&ctx->dev->irqlock, flags);\r\nv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\r\nspin_unlock_irqrestore(&ctx->dev->irqlock, flags);\r\n}\r\n}\r\nstatic int queue_init(void *priv, struct vb2_queue *src_vq, struct vb2_queue *dst_vq)\r\n{\r\nstruct vim2m_ctx *ctx = priv;\r\nint ret;\r\nsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nsrc_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\r\nsrc_vq->drv_priv = ctx;\r\nsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\r\nsrc_vq->ops = &vim2m_qops;\r\nsrc_vq->mem_ops = &vb2_vmalloc_memops;\r\nsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\nsrc_vq->lock = &ctx->dev->dev_mutex;\r\nret = vb2_queue_init(src_vq);\r\nif (ret)\r\nreturn ret;\r\ndst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\ndst_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\r\ndst_vq->drv_priv = ctx;\r\ndst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\r\ndst_vq->ops = &vim2m_qops;\r\ndst_vq->mem_ops = &vb2_vmalloc_memops;\r\ndst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\ndst_vq->lock = &ctx->dev->dev_mutex;\r\nreturn vb2_queue_init(dst_vq);\r\n}\r\nstatic int vim2m_open(struct file *file)\r\n{\r\nstruct vim2m_dev *dev = video_drvdata(file);\r\nstruct vim2m_ctx *ctx = NULL;\r\nstruct v4l2_ctrl_handler *hdl;\r\nint rc = 0;\r\nif (mutex_lock_interruptible(&dev->dev_mutex))\r\nreturn -ERESTARTSYS;\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx) {\r\nrc = -ENOMEM;\r\ngoto open_unlock;\r\n}\r\nv4l2_fh_init(&ctx->fh, video_devdata(file));\r\nfile->private_data = &ctx->fh;\r\nctx->dev = dev;\r\nhdl = &ctx->hdl;\r\nv4l2_ctrl_handler_init(hdl, 4);\r\nv4l2_ctrl_new_std(hdl, &vim2m_ctrl_ops, V4L2_CID_HFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(hdl, &vim2m_ctrl_ops, V4L2_CID_VFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_new_custom(hdl, &vim2m_ctrl_trans_time_msec, NULL);\r\nv4l2_ctrl_new_custom(hdl, &vim2m_ctrl_trans_num_bufs, NULL);\r\nif (hdl->error) {\r\nrc = hdl->error;\r\nv4l2_ctrl_handler_free(hdl);\r\nkfree(ctx);\r\ngoto open_unlock;\r\n}\r\nctx->fh.ctrl_handler = hdl;\r\nv4l2_ctrl_handler_setup(hdl);\r\nctx->q_data[V4L2_M2M_SRC].fmt = &formats[0];\r\nctx->q_data[V4L2_M2M_SRC].width = 640;\r\nctx->q_data[V4L2_M2M_SRC].height = 480;\r\nctx->q_data[V4L2_M2M_SRC].sizeimage =\r\nctx->q_data[V4L2_M2M_SRC].width *\r\nctx->q_data[V4L2_M2M_SRC].height *\r\n(ctx->q_data[V4L2_M2M_SRC].fmt->depth >> 3);\r\nctx->q_data[V4L2_M2M_DST] = ctx->q_data[V4L2_M2M_SRC];\r\nctx->colorspace = V4L2_COLORSPACE_REC709;\r\nctx->fh.m2m_ctx = v4l2_m2m_ctx_init(dev->m2m_dev, ctx, &queue_init);\r\nif (IS_ERR(ctx->fh.m2m_ctx)) {\r\nrc = PTR_ERR(ctx->fh.m2m_ctx);\r\nv4l2_ctrl_handler_free(hdl);\r\nv4l2_fh_exit(&ctx->fh);\r\nkfree(ctx);\r\ngoto open_unlock;\r\n}\r\nv4l2_fh_add(&ctx->fh);\r\natomic_inc(&dev->num_inst);\r\ndprintk(dev, "Created instance: %p, m2m_ctx: %p\n",\r\nctx, ctx->fh.m2m_ctx);\r\nopen_unlock:\r\nmutex_unlock(&dev->dev_mutex);\r\nreturn rc;\r\n}\r\nstatic int vim2m_release(struct file *file)\r\n{\r\nstruct vim2m_dev *dev = video_drvdata(file);\r\nstruct vim2m_ctx *ctx = file2ctx(file);\r\ndprintk(dev, "Releasing instance %p\n", ctx);\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nv4l2_ctrl_handler_free(&ctx->hdl);\r\nmutex_lock(&dev->dev_mutex);\r\nv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\r\nmutex_unlock(&dev->dev_mutex);\r\nkfree(ctx);\r\natomic_dec(&dev->num_inst);\r\nreturn 0;\r\n}\r\nstatic int vim2m_probe(struct platform_device *pdev)\r\n{\r\nstruct vim2m_dev *dev;\r\nstruct video_device *vfd;\r\nint ret;\r\ndev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nspin_lock_init(&dev->irqlock);\r\nret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);\r\nif (ret)\r\nreturn ret;\r\natomic_set(&dev->num_inst, 0);\r\nmutex_init(&dev->dev_mutex);\r\ndev->vfd = vim2m_videodev;\r\nvfd = &dev->vfd;\r\nvfd->lock = &dev->dev_mutex;\r\nvfd->v4l2_dev = &dev->v4l2_dev;\r\nret = video_register_device(vfd, VFL_TYPE_GRABBER, 0);\r\nif (ret) {\r\nv4l2_err(&dev->v4l2_dev, "Failed to register video device\n");\r\ngoto unreg_dev;\r\n}\r\nvideo_set_drvdata(vfd, dev);\r\nsnprintf(vfd->name, sizeof(vfd->name), "%s", vim2m_videodev.name);\r\nv4l2_info(&dev->v4l2_dev,\r\n"Device registered as /dev/video%d\n", vfd->num);\r\nsetup_timer(&dev->timer, device_isr, (long)dev);\r\nplatform_set_drvdata(pdev, dev);\r\ndev->m2m_dev = v4l2_m2m_init(&m2m_ops);\r\nif (IS_ERR(dev->m2m_dev)) {\r\nv4l2_err(&dev->v4l2_dev, "Failed to init mem2mem device\n");\r\nret = PTR_ERR(dev->m2m_dev);\r\ngoto err_m2m;\r\n}\r\nreturn 0;\r\nerr_m2m:\r\nv4l2_m2m_release(dev->m2m_dev);\r\nvideo_unregister_device(&dev->vfd);\r\nunreg_dev:\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nreturn ret;\r\n}\r\nstatic int vim2m_remove(struct platform_device *pdev)\r\n{\r\nstruct vim2m_dev *dev = platform_get_drvdata(pdev);\r\nv4l2_info(&dev->v4l2_dev, "Removing " MEM2MEM_NAME);\r\nv4l2_m2m_release(dev->m2m_dev);\r\ndel_timer_sync(&dev->timer);\r\nvideo_unregister_device(&dev->vfd);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nreturn 0;\r\n}\r\nstatic void __exit vim2m_exit(void)\r\n{\r\nplatform_driver_unregister(&vim2m_pdrv);\r\nplatform_device_unregister(&vim2m_pdev);\r\n}\r\nstatic int __init vim2m_init(void)\r\n{\r\nint ret;\r\nret = platform_device_register(&vim2m_pdev);\r\nif (ret)\r\nreturn ret;\r\nret = platform_driver_register(&vim2m_pdrv);\r\nif (ret)\r\nplatform_device_unregister(&vim2m_pdev);\r\nreturn ret;\r\n}
