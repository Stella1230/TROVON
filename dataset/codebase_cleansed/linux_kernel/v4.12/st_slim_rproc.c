static int slim_clk_get(struct st_slim_rproc *slim_rproc, struct device *dev)\r\n{\r\nint clk, err;\r\nfor (clk = 0; clk < ST_SLIM_MAX_CLK; clk++) {\r\nslim_rproc->clks[clk] = of_clk_get(dev->of_node, clk);\r\nif (IS_ERR(slim_rproc->clks[clk])) {\r\nerr = PTR_ERR(slim_rproc->clks[clk]);\r\nif (err == -EPROBE_DEFER)\r\ngoto err_put_clks;\r\nslim_rproc->clks[clk] = NULL;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\nerr_put_clks:\r\nwhile (--clk >= 0)\r\nclk_put(slim_rproc->clks[clk]);\r\nreturn err;\r\n}\r\nstatic void slim_clk_disable(struct st_slim_rproc *slim_rproc)\r\n{\r\nint clk;\r\nfor (clk = 0; clk < ST_SLIM_MAX_CLK && slim_rproc->clks[clk]; clk++)\r\nclk_disable_unprepare(slim_rproc->clks[clk]);\r\n}\r\nstatic int slim_clk_enable(struct st_slim_rproc *slim_rproc)\r\n{\r\nint clk, ret;\r\nfor (clk = 0; clk < ST_SLIM_MAX_CLK && slim_rproc->clks[clk]; clk++) {\r\nret = clk_prepare_enable(slim_rproc->clks[clk]);\r\nif (ret)\r\ngoto err_disable_clks;\r\n}\r\nreturn 0;\r\nerr_disable_clks:\r\nwhile (--clk >= 0)\r\nclk_disable_unprepare(slim_rproc->clks[clk]);\r\nreturn ret;\r\n}\r\nstatic int slim_rproc_start(struct rproc *rproc)\r\n{\r\nstruct device *dev = &rproc->dev;\r\nstruct st_slim_rproc *slim_rproc = rproc->priv;\r\nunsigned long hw_id, hw_ver, fw_rev;\r\nu32 val;\r\nval = SLIM_CLK_GATE_DIS | SLIM_CLK_GATE_RESET;\r\nwritel(val, slim_rproc->slimcore + SLIM_CLK_GATE_OFST);\r\nwritel(SLIM_STBUS_SYNC_DIS, slim_rproc->peri + SLIM_STBUS_SYNC_OFST);\r\nwritel(!SLIM_CLK_GATE_DIS,\r\nslim_rproc->slimcore + SLIM_CLK_GATE_OFST);\r\nwritel(~0U, slim_rproc->peri + SLIM_INT_CLR_OFST);\r\nwritel(~0U, slim_rproc->peri + SLIM_CMD_CLR_OFST);\r\nwritel(~0U, slim_rproc->peri + SLIM_INT_MASK_OFST);\r\nwritel(~0U, slim_rproc->peri + SLIM_CMD_MASK_OFST);\r\nwritel(SLIM_EN_RUN, slim_rproc->slimcore + SLIM_EN_OFST);\r\nhw_id = readl_relaxed(slim_rproc->slimcore + SLIM_ID_OFST);\r\nhw_ver = readl_relaxed(slim_rproc->slimcore + SLIM_VER_OFST);\r\nfw_rev = readl(slim_rproc->mem[ST_SLIM_DMEM].cpu_addr +\r\nSLIM_REV_ID_OFST);\r\ndev_info(dev, "fw rev:%ld.%ld on SLIM %ld.%ld\n",\r\nSLIM_REV_ID_MAJ(fw_rev), SLIM_REV_ID_MIN(fw_rev),\r\nhw_id, hw_ver);\r\nreturn 0;\r\n}\r\nstatic int slim_rproc_stop(struct rproc *rproc)\r\n{\r\nstruct st_slim_rproc *slim_rproc = rproc->priv;\r\nu32 val;\r\nwritel(0UL, slim_rproc->peri + SLIM_INT_MASK_OFST);\r\nwritel(0UL, slim_rproc->peri + SLIM_CMD_MASK_OFST);\r\nwritel(SLIM_CLK_GATE_DIS, slim_rproc->slimcore + SLIM_CLK_GATE_OFST);\r\nwritel(!SLIM_EN_RUN, slim_rproc->slimcore + SLIM_EN_OFST);\r\nval = readl(slim_rproc->slimcore + SLIM_EN_OFST);\r\nif (val & SLIM_EN_RUN)\r\ndev_warn(&rproc->dev, "Failed to disable SLIM");\r\ndev_dbg(&rproc->dev, "slim stopped\n");\r\nreturn 0;\r\n}\r\nstatic void *slim_rproc_da_to_va(struct rproc *rproc, u64 da, int len)\r\n{\r\nstruct st_slim_rproc *slim_rproc = rproc->priv;\r\nvoid *va = NULL;\r\nint i;\r\nfor (i = 0; i < ST_SLIM_MEM_MAX; i++) {\r\nif (da != slim_rproc->mem[i].bus_addr)\r\ncontinue;\r\nif (len <= slim_rproc->mem[i].size) {\r\nva = (__force void *)slim_rproc->mem[i].cpu_addr;\r\nbreak;\r\n}\r\n}\r\ndev_dbg(&rproc->dev, "da = 0x%llx len = 0x%x va = 0x%p\n", da, len, va);\r\nreturn va;\r\n}\r\nstatic struct resource_table *slim_rproc_find_rsc_table(struct rproc *rproc,\r\nconst struct firmware *fw,\r\nint *tablesz)\r\n{\r\n*tablesz = sizeof(empty_rsc_tbl);\r\nreturn &empty_rsc_tbl;\r\n}\r\nstruct st_slim_rproc *st_slim_rproc_alloc(struct platform_device *pdev,\r\nchar *fw_name)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct st_slim_rproc *slim_rproc;\r\nstruct device_node *np = dev->of_node;\r\nstruct rproc *rproc;\r\nstruct resource *res;\r\nint err, i;\r\nconst struct rproc_fw_ops *elf_ops;\r\nif (!fw_name)\r\nreturn ERR_PTR(-EINVAL);\r\nif (!of_device_is_compatible(np, "st,slim-rproc"))\r\nreturn ERR_PTR(-EINVAL);\r\nrproc = rproc_alloc(dev, np->name, &slim_rproc_ops,\r\nfw_name, sizeof(*slim_rproc));\r\nif (!rproc)\r\nreturn ERR_PTR(-ENOMEM);\r\nrproc->has_iommu = false;\r\nslim_rproc = rproc->priv;\r\nslim_rproc->rproc = rproc;\r\nelf_ops = rproc->fw_ops;\r\nslim_rproc_fw_ops.load = elf_ops->load;\r\nslim_rproc_fw_ops.sanity_check = elf_ops->sanity_check;\r\nrproc->fw_ops = &slim_rproc_fw_ops;\r\nfor (i = 0; i < ARRAY_SIZE(mem_names); i++) {\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\nmem_names[i]);\r\nslim_rproc->mem[i].cpu_addr = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(slim_rproc->mem[i].cpu_addr)) {\r\ndev_err(&pdev->dev, "devm_ioremap_resource failed\n");\r\nerr = PTR_ERR(slim_rproc->mem[i].cpu_addr);\r\ngoto err;\r\n}\r\nslim_rproc->mem[i].bus_addr = res->start;\r\nslim_rproc->mem[i].size = resource_size(res);\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "slimcore");\r\nslim_rproc->slimcore = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(slim_rproc->slimcore)) {\r\ndev_err(&pdev->dev, "failed to ioremap slimcore IO\n");\r\nerr = PTR_ERR(slim_rproc->slimcore);\r\ngoto err;\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "peripherals");\r\nslim_rproc->peri = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(slim_rproc->peri)) {\r\ndev_err(&pdev->dev, "failed to ioremap peripherals IO\n");\r\nerr = PTR_ERR(slim_rproc->peri);\r\ngoto err;\r\n}\r\nerr = slim_clk_get(slim_rproc, dev);\r\nif (err)\r\ngoto err;\r\nerr = slim_clk_enable(slim_rproc);\r\nif (err) {\r\ndev_err(dev, "Failed to enable clocks\n");\r\ngoto err_clk_put;\r\n}\r\nerr = rproc_add(rproc);\r\nif (err) {\r\ndev_err(dev, "registration of slim remoteproc failed\n");\r\ngoto err_clk_dis;\r\n}\r\nreturn slim_rproc;\r\nerr_clk_dis:\r\nslim_clk_disable(slim_rproc);\r\nerr_clk_put:\r\nfor (i = 0; i < ST_SLIM_MAX_CLK && slim_rproc->clks[i]; i++)\r\nclk_put(slim_rproc->clks[i]);\r\nerr:\r\nrproc_free(rproc);\r\nreturn ERR_PTR(err);\r\n}\r\nvoid st_slim_rproc_put(struct st_slim_rproc *slim_rproc)\r\n{\r\nint clk;\r\nif (!slim_rproc)\r\nreturn;\r\nslim_clk_disable(slim_rproc);\r\nfor (clk = 0; clk < ST_SLIM_MAX_CLK && slim_rproc->clks[clk]; clk++)\r\nclk_put(slim_rproc->clks[clk]);\r\nrproc_del(slim_rproc->rproc);\r\nrproc_free(slim_rproc->rproc);\r\n}
