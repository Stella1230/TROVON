static int irda_data_indication(void *instance, void *sap, struct sk_buff *skb)\r\n{\r\nstruct irda_sock *self;\r\nstruct sock *sk;\r\nint err;\r\nself = instance;\r\nsk = instance;\r\nerr = sock_queue_rcv_skb(sk, skb);\r\nif (err) {\r\npr_debug("%s(), error: no more mem!\n", __func__);\r\nself->rx_flow = FLOW_STOP;\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void irda_disconnect_indication(void *instance, void *sap,\r\nLM_REASON reason, struct sk_buff *skb)\r\n{\r\nstruct irda_sock *self;\r\nstruct sock *sk;\r\nself = instance;\r\npr_debug("%s(%p)\n", __func__, self);\r\nif(skb)\r\ndev_kfree_skb(skb);\r\nsk = instance;\r\nif (sk == NULL) {\r\npr_debug("%s(%p) : BUG : sk is NULL\n",\r\n__func__, self);\r\nreturn;\r\n}\r\nbh_lock_sock(sk);\r\nif (!sock_flag(sk, SOCK_DEAD) && sk->sk_state != TCP_CLOSE) {\r\nsk->sk_state = TCP_CLOSE;\r\nsk->sk_shutdown |= SEND_SHUTDOWN;\r\nsk->sk_state_change(sk);\r\nif (self->tsap) {\r\nirttp_close_tsap(self->tsap);\r\nself->tsap = NULL;\r\n}\r\n}\r\nbh_unlock_sock(sk);\r\n}\r\nstatic void irda_connect_confirm(void *instance, void *sap,\r\nstruct qos_info *qos,\r\n__u32 max_sdu_size, __u8 max_header_size,\r\nstruct sk_buff *skb)\r\n{\r\nstruct irda_sock *self;\r\nstruct sock *sk;\r\nself = instance;\r\npr_debug("%s(%p)\n", __func__, self);\r\nsk = instance;\r\nif (sk == NULL) {\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\ndev_kfree_skb(skb);\r\nself->max_header_size = max_header_size;\r\nself->max_sdu_size_tx = max_sdu_size;\r\nswitch (sk->sk_type) {\r\ncase SOCK_STREAM:\r\nif (max_sdu_size != 0) {\r\nnet_err_ratelimited("%s: max_sdu_size must be 0\n",\r\n__func__);\r\nreturn;\r\n}\r\nself->max_data_size = irttp_get_max_seg_size(self->tsap);\r\nbreak;\r\ncase SOCK_SEQPACKET:\r\nif (max_sdu_size == 0) {\r\nnet_err_ratelimited("%s: max_sdu_size cannot be 0\n",\r\n__func__);\r\nreturn;\r\n}\r\nself->max_data_size = max_sdu_size;\r\nbreak;\r\ndefault:\r\nself->max_data_size = irttp_get_max_seg_size(self->tsap);\r\n}\r\npr_debug("%s(), max_data_size=%d\n", __func__,\r\nself->max_data_size);\r\nmemcpy(&self->qos_tx, qos, sizeof(struct qos_info));\r\nsk->sk_state = TCP_ESTABLISHED;\r\nsk->sk_state_change(sk);\r\n}\r\nstatic void irda_connect_indication(void *instance, void *sap,\r\nstruct qos_info *qos, __u32 max_sdu_size,\r\n__u8 max_header_size, struct sk_buff *skb)\r\n{\r\nstruct irda_sock *self;\r\nstruct sock *sk;\r\nself = instance;\r\npr_debug("%s(%p)\n", __func__, self);\r\nsk = instance;\r\nif (sk == NULL) {\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nself->max_header_size = max_header_size;\r\nself->max_sdu_size_tx = max_sdu_size;\r\nswitch (sk->sk_type) {\r\ncase SOCK_STREAM:\r\nif (max_sdu_size != 0) {\r\nnet_err_ratelimited("%s: max_sdu_size must be 0\n",\r\n__func__);\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nself->max_data_size = irttp_get_max_seg_size(self->tsap);\r\nbreak;\r\ncase SOCK_SEQPACKET:\r\nif (max_sdu_size == 0) {\r\nnet_err_ratelimited("%s: max_sdu_size cannot be 0\n",\r\n__func__);\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nself->max_data_size = max_sdu_size;\r\nbreak;\r\ndefault:\r\nself->max_data_size = irttp_get_max_seg_size(self->tsap);\r\n}\r\npr_debug("%s(), max_data_size=%d\n", __func__,\r\nself->max_data_size);\r\nmemcpy(&self->qos_tx, qos, sizeof(struct qos_info));\r\nskb_queue_tail(&sk->sk_receive_queue, skb);\r\nsk->sk_state_change(sk);\r\n}\r\nstatic void irda_connect_response(struct irda_sock *self)\r\n{\r\nstruct sk_buff *skb;\r\nskb = alloc_skb(TTP_MAX_HEADER + TTP_SAR_HEADER, GFP_KERNEL);\r\nif (skb == NULL) {\r\npr_debug("%s() Unable to allocate sk_buff!\n",\r\n__func__);\r\nreturn;\r\n}\r\nskb_reserve(skb, IRDA_MAX_HEADER);\r\nirttp_connect_response(self->tsap, self->max_sdu_size_rx, skb);\r\n}\r\nstatic void irda_flow_indication(void *instance, void *sap, LOCAL_FLOW flow)\r\n{\r\nstruct irda_sock *self;\r\nstruct sock *sk;\r\nself = instance;\r\nsk = instance;\r\nBUG_ON(sk == NULL);\r\nswitch (flow) {\r\ncase FLOW_STOP:\r\npr_debug("%s(), IrTTP wants us to slow down\n",\r\n__func__);\r\nself->tx_flow = flow;\r\nbreak;\r\ncase FLOW_START:\r\nself->tx_flow = flow;\r\npr_debug("%s(), IrTTP wants us to start again\n",\r\n__func__);\r\nwake_up_interruptible(sk_sleep(sk));\r\nbreak;\r\ndefault:\r\npr_debug("%s(), Unknown flow command!\n", __func__);\r\nself->tx_flow = flow;\r\nbreak;\r\n}\r\n}\r\nstatic void irda_getvalue_confirm(int result, __u16 obj_id,\r\nstruct ias_value *value, void *priv)\r\n{\r\nstruct irda_sock *self;\r\nself = priv;\r\nif (!self) {\r\nnet_warn_ratelimited("%s: lost myself!\n", __func__);\r\nreturn;\r\n}\r\npr_debug("%s(%p)\n", __func__, self);\r\niriap_close(self->iriap);\r\nself->iriap = NULL;\r\nif (result != IAS_SUCCESS) {\r\npr_debug("%s(), IAS query failed! (%d)\n", __func__,\r\nresult);\r\nself->errno = result;\r\nwake_up_interruptible(&self->query_wait);\r\nreturn;\r\n}\r\nself->ias_result = value;\r\nself->errno = 0;\r\nwake_up_interruptible(&self->query_wait);\r\n}\r\nstatic void irda_selective_discovery_indication(discinfo_t *discovery,\r\nDISCOVERY_MODE mode,\r\nvoid *priv)\r\n{\r\nstruct irda_sock *self;\r\nself = priv;\r\nif (!self) {\r\nnet_warn_ratelimited("%s: lost myself!\n", __func__);\r\nreturn;\r\n}\r\nself->cachedaddr = discovery->daddr;\r\nwake_up_interruptible(&self->query_wait);\r\n}\r\nstatic void irda_discovery_timeout(u_long priv)\r\n{\r\nstruct irda_sock *self;\r\nself = (struct irda_sock *) priv;\r\nBUG_ON(self == NULL);\r\nself->cachelog = NULL;\r\nself->cachedaddr = 0;\r\nself->errno = -ETIME;\r\nwake_up_interruptible(&self->query_wait);\r\n}\r\nstatic int irda_open_tsap(struct irda_sock *self, __u8 tsap_sel, char *name)\r\n{\r\nnotify_t notify;\r\nif (self->tsap) {\r\npr_debug("%s: busy!\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nirda_notify_init(&notify);\r\nnotify.connect_confirm = irda_connect_confirm;\r\nnotify.connect_indication = irda_connect_indication;\r\nnotify.disconnect_indication = irda_disconnect_indication;\r\nnotify.data_indication = irda_data_indication;\r\nnotify.udata_indication = irda_data_indication;\r\nnotify.flow_indication = irda_flow_indication;\r\nnotify.instance = self;\r\nstrncpy(notify.name, name, NOTIFY_MAX_NAME);\r\nself->tsap = irttp_open_tsap(tsap_sel, DEFAULT_INITIAL_CREDIT,\r\n&notify);\r\nif (self->tsap == NULL) {\r\npr_debug("%s(), Unable to allocate TSAP!\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nself->stsap_sel = self->tsap->stsap_sel;\r\nreturn 0;\r\n}\r\nstatic int irda_open_lsap(struct irda_sock *self, int pid)\r\n{\r\nnotify_t notify;\r\nif (self->lsap) {\r\nnet_warn_ratelimited("%s(), busy!\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nirda_notify_init(&notify);\r\nnotify.udata_indication = irda_data_indication;\r\nnotify.instance = self;\r\nstrncpy(notify.name, "Ultra", NOTIFY_MAX_NAME);\r\nself->lsap = irlmp_open_lsap(LSAP_CONNLESS, &notify, pid);\r\nif (self->lsap == NULL) {\r\npr_debug("%s(), Unable to allocate LSAP!\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int irda_find_lsap_sel(struct irda_sock *self, char *name)\r\n{\r\npr_debug("%s(%p, %s)\n", __func__, self, name);\r\nif (self->iriap) {\r\nnet_warn_ratelimited("%s(): busy with a previous query\n",\r\n__func__);\r\nreturn -EBUSY;\r\n}\r\nself->iriap = iriap_open(LSAP_ANY, IAS_CLIENT, self,\r\nirda_getvalue_confirm);\r\nif(self->iriap == NULL)\r\nreturn -ENOMEM;\r\nself->errno = -EHOSTUNREACH;\r\niriap_getvaluebyclass_request(self->iriap, self->saddr, self->daddr,\r\nname, "IrDA:TinyTP:LsapSel");\r\nif (wait_event_interruptible(self->query_wait, (self->iriap==NULL)))\r\nreturn -EHOSTUNREACH;\r\nif (self->errno)\r\n{\r\nif((self->errno == IAS_CLASS_UNKNOWN) ||\r\n(self->errno == IAS_ATTRIB_UNKNOWN))\r\nreturn -EADDRNOTAVAIL;\r\nelse\r\nreturn -EHOSTUNREACH;\r\n}\r\nswitch (self->ias_result->type) {\r\ncase IAS_INTEGER:\r\npr_debug("%s() int=%d\n",\r\n__func__, self->ias_result->t.integer);\r\nif (self->ias_result->t.integer != -1)\r\nself->dtsap_sel = self->ias_result->t.integer;\r\nelse\r\nself->dtsap_sel = 0;\r\nbreak;\r\ndefault:\r\nself->dtsap_sel = 0;\r\npr_debug("%s(), bad type!\n", __func__);\r\nbreak;\r\n}\r\nif (self->ias_result)\r\nirias_delete_value(self->ias_result);\r\nif (self->dtsap_sel)\r\nreturn 0;\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nstatic int irda_discover_daddr_and_lsap_sel(struct irda_sock *self, char *name)\r\n{\r\ndiscinfo_t *discoveries;\r\nint number;\r\nint i;\r\nint err = -ENETUNREACH;\r\n__u32 daddr = DEV_ADDR_ANY;\r\n__u8 dtsap_sel = 0x0;\r\npr_debug("%s(), name=%s\n", __func__, name);\r\ndiscoveries = irlmp_get_discoveries(&number, self->mask.word,\r\nself->nslots);\r\nif (discoveries == NULL)\r\nreturn -ENETUNREACH;\r\nfor(i = 0; i < number; i++) {\r\nself->daddr = discoveries[i].daddr;\r\nself->saddr = 0x0;\r\npr_debug("%s(), trying daddr = %08x\n",\r\n__func__, self->daddr);\r\nerr = irda_find_lsap_sel(self, name);\r\nswitch (err) {\r\ncase 0:\r\nif(daddr != DEV_ADDR_ANY) {\r\npr_debug("%s(), discovered service ''%s'' in two different devices !!!\n",\r\n__func__, name);\r\nself->daddr = DEV_ADDR_ANY;\r\nkfree(discoveries);\r\nreturn -ENOTUNIQ;\r\n}\r\ndaddr = self->daddr;\r\ndtsap_sel = self->dtsap_sel;\r\nbreak;\r\ncase -EADDRNOTAVAIL:\r\nbreak;\r\ndefault:\r\npr_debug("%s(), unexpected IAS query failure\n",\r\n__func__);\r\nself->daddr = DEV_ADDR_ANY;\r\nkfree(discoveries);\r\nreturn -EHOSTUNREACH;\r\n}\r\n}\r\nkfree(discoveries);\r\nif(daddr == DEV_ADDR_ANY) {\r\npr_debug("%s(), cannot discover service ''%s'' in any device !!!\n",\r\n__func__, name);\r\nself->daddr = DEV_ADDR_ANY;\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nself->daddr = daddr;\r\nself->saddr = 0x0;\r\nself->dtsap_sel = dtsap_sel;\r\npr_debug("%s(), discovered requested service ''%s'' at address %08x\n",\r\n__func__, name, self->daddr);\r\nreturn 0;\r\n}\r\nstatic int irda_getname(struct socket *sock, struct sockaddr *uaddr,\r\nint *uaddr_len, int peer)\r\n{\r\nstruct sockaddr_irda saddr;\r\nstruct sock *sk = sock->sk;\r\nstruct irda_sock *self = irda_sk(sk);\r\nmemset(&saddr, 0, sizeof(saddr));\r\nif (peer) {\r\nif (sk->sk_state != TCP_ESTABLISHED)\r\nreturn -ENOTCONN;\r\nsaddr.sir_family = AF_IRDA;\r\nsaddr.sir_lsap_sel = self->dtsap_sel;\r\nsaddr.sir_addr = self->daddr;\r\n} else {\r\nsaddr.sir_family = AF_IRDA;\r\nsaddr.sir_lsap_sel = self->stsap_sel;\r\nsaddr.sir_addr = self->saddr;\r\n}\r\npr_debug("%s(), tsap_sel = %#x\n", __func__, saddr.sir_lsap_sel);\r\npr_debug("%s(), addr = %08x\n", __func__, saddr.sir_addr);\r\n*uaddr_len = sizeof (struct sockaddr_irda);\r\nmemcpy(uaddr, &saddr, *uaddr_len);\r\nreturn 0;\r\n}\r\nstatic int irda_listen(struct socket *sock, int backlog)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint err = -EOPNOTSUPP;\r\nlock_sock(sk);\r\nif ((sk->sk_type != SOCK_STREAM) && (sk->sk_type != SOCK_SEQPACKET) &&\r\n(sk->sk_type != SOCK_DGRAM))\r\ngoto out;\r\nif (sk->sk_state != TCP_LISTEN) {\r\nsk->sk_max_ack_backlog = backlog;\r\nsk->sk_state = TCP_LISTEN;\r\nerr = 0;\r\n}\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int irda_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct sockaddr_irda *addr = (struct sockaddr_irda *) uaddr;\r\nstruct irda_sock *self = irda_sk(sk);\r\nint err;\r\npr_debug("%s(%p)\n", __func__, self);\r\nif (addr_len != sizeof(struct sockaddr_irda))\r\nreturn -EINVAL;\r\nlock_sock(sk);\r\n#ifdef CONFIG_IRDA_ULTRA\r\nif ((sk->sk_type == SOCK_DGRAM) &&\r\n(sk->sk_protocol == IRDAPROTO_ULTRA)) {\r\nself->pid = addr->sir_lsap_sel;\r\nerr = -EOPNOTSUPP;\r\nif (self->pid & 0x80) {\r\npr_debug("%s(), extension in PID not supp!\n",\r\n__func__);\r\ngoto out;\r\n}\r\nerr = irda_open_lsap(self, self->pid);\r\nif (err < 0)\r\ngoto out;\r\nsock->state = SS_CONNECTED;\r\nsk->sk_state = TCP_ESTABLISHED;\r\nerr = 0;\r\ngoto out;\r\n}\r\n#endif\r\nself->ias_obj = irias_new_object(addr->sir_name, jiffies);\r\nerr = -ENOMEM;\r\nif (self->ias_obj == NULL)\r\ngoto out;\r\nerr = irda_open_tsap(self, addr->sir_lsap_sel, addr->sir_name);\r\nif (err < 0) {\r\nirias_delete_object(self->ias_obj);\r\nself->ias_obj = NULL;\r\ngoto out;\r\n}\r\nirias_add_integer_attrib(self->ias_obj, "IrDA:TinyTP:LsapSel",\r\nself->stsap_sel, IAS_KERNEL_ATTR);\r\nirias_insert_object(self->ias_obj);\r\nerr = 0;\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int irda_accept(struct socket *sock, struct socket *newsock, int flags,\r\nbool kern)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct irda_sock *new, *self = irda_sk(sk);\r\nstruct sock *newsk;\r\nstruct sk_buff *skb = NULL;\r\nint err;\r\nerr = irda_create(sock_net(sk), newsock, sk->sk_protocol, kern);\r\nif (err)\r\nreturn err;\r\nerr = -EINVAL;\r\nlock_sock(sk);\r\nif (sock->state != SS_UNCONNECTED)\r\ngoto out;\r\nerr = -EOPNOTSUPP;\r\nif ((sk->sk_type != SOCK_STREAM) && (sk->sk_type != SOCK_SEQPACKET) &&\r\n(sk->sk_type != SOCK_DGRAM))\r\ngoto out;\r\nerr = -EINVAL;\r\nif (sk->sk_state != TCP_LISTEN)\r\ngoto out;\r\nwhile (1) {\r\nskb = skb_dequeue(&sk->sk_receive_queue);\r\nif (skb)\r\nbreak;\r\nerr = -EWOULDBLOCK;\r\nif (flags & O_NONBLOCK)\r\ngoto out;\r\nerr = wait_event_interruptible(*(sk_sleep(sk)),\r\nskb_peek(&sk->sk_receive_queue));\r\nif (err)\r\ngoto out;\r\n}\r\nnewsk = newsock->sk;\r\nerr = -EIO;\r\nif (newsk == NULL)\r\ngoto out;\r\nnewsk->sk_state = TCP_ESTABLISHED;\r\nnew = irda_sk(newsk);\r\nnew->tsap = irttp_dup(self->tsap, new);\r\nerr = -EPERM;\r\nif (!new->tsap) {\r\npr_debug("%s(), dup failed!\n", __func__);\r\ngoto out;\r\n}\r\nnew->stsap_sel = new->tsap->stsap_sel;\r\nnew->dtsap_sel = new->tsap->dtsap_sel;\r\nnew->saddr = irttp_get_saddr(new->tsap);\r\nnew->daddr = irttp_get_daddr(new->tsap);\r\nnew->max_sdu_size_tx = self->max_sdu_size_tx;\r\nnew->max_sdu_size_rx = self->max_sdu_size_rx;\r\nnew->max_data_size = self->max_data_size;\r\nnew->max_header_size = self->max_header_size;\r\nmemcpy(&new->qos_tx, &self->qos_tx, sizeof(struct qos_info));\r\nirttp_listen(self->tsap);\r\nsk->sk_ack_backlog--;\r\nnewsock->state = SS_CONNECTED;\r\nirda_connect_response(new);\r\nerr = 0;\r\nout:\r\nkfree_skb(skb);\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int irda_connect(struct socket *sock, struct sockaddr *uaddr,\r\nint addr_len, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct sockaddr_irda *addr = (struct sockaddr_irda *) uaddr;\r\nstruct irda_sock *self = irda_sk(sk);\r\nint err;\r\npr_debug("%s(%p)\n", __func__, self);\r\nlock_sock(sk);\r\nerr = -ESOCKTNOSUPPORT;\r\nif ((sk->sk_type == SOCK_DGRAM) && (sk->sk_protocol == IRDAPROTO_ULTRA))\r\ngoto out;\r\nif (sk->sk_state == TCP_ESTABLISHED && sock->state == SS_CONNECTING) {\r\nsock->state = SS_CONNECTED;\r\nerr = 0;\r\ngoto out;\r\n}\r\nif (sk->sk_state == TCP_CLOSE && sock->state == SS_CONNECTING) {\r\nsock->state = SS_UNCONNECTED;\r\nerr = -ECONNREFUSED;\r\ngoto out;\r\n}\r\nerr = -EISCONN;\r\nif (sk->sk_state == TCP_ESTABLISHED)\r\ngoto out;\r\nsk->sk_state = TCP_CLOSE;\r\nsock->state = SS_UNCONNECTED;\r\nerr = -EINVAL;\r\nif (addr_len != sizeof(struct sockaddr_irda))\r\ngoto out;\r\nif ((!addr->sir_addr) || (addr->sir_addr == DEV_ADDR_ANY)) {\r\nerr = irda_discover_daddr_and_lsap_sel(self, addr->sir_name);\r\nif (err) {\r\npr_debug("%s(), auto-connect failed!\n", __func__);\r\ngoto out;\r\n}\r\n} else {\r\nself->daddr = addr->sir_addr;\r\npr_debug("%s(), daddr = %08x\n", __func__, self->daddr);\r\nif((addr->sir_name[0] != '\0') ||\r\n(addr->sir_lsap_sel >= 0x70)) {\r\nerr = irda_find_lsap_sel(self, addr->sir_name);\r\nif (err) {\r\npr_debug("%s(), connect failed!\n", __func__);\r\ngoto out;\r\n}\r\n} else {\r\nself->dtsap_sel = addr->sir_lsap_sel;\r\n}\r\n}\r\nif (!self->tsap) {\r\nerr = irda_open_tsap(self, LSAP_ANY, addr->sir_name);\r\nif (err)\r\ngoto out;\r\n}\r\nsock->state = SS_CONNECTING;\r\nsk->sk_state = TCP_SYN_SENT;\r\nerr = irttp_connect_request(self->tsap, self->dtsap_sel,\r\nself->saddr, self->daddr, NULL,\r\nself->max_sdu_size_rx, NULL);\r\nif (err) {\r\npr_debug("%s(), connect failed!\n", __func__);\r\ngoto out;\r\n}\r\nerr = -EINPROGRESS;\r\nif (sk->sk_state != TCP_ESTABLISHED && (flags & O_NONBLOCK))\r\ngoto out;\r\nerr = -ERESTARTSYS;\r\nif (wait_event_interruptible(*(sk_sleep(sk)),\r\n(sk->sk_state != TCP_SYN_SENT)))\r\ngoto out;\r\nif (sk->sk_state != TCP_ESTABLISHED) {\r\nsock->state = SS_UNCONNECTED;\r\nerr = sock_error(sk);\r\nif (!err)\r\nerr = -ECONNRESET;\r\ngoto out;\r\n}\r\nsock->state = SS_CONNECTED;\r\nself->saddr = irttp_get_saddr(self->tsap);\r\nerr = 0;\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int irda_create(struct net *net, struct socket *sock, int protocol,\r\nint kern)\r\n{\r\nstruct sock *sk;\r\nstruct irda_sock *self;\r\nif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\r\nreturn -EINVAL;\r\nif (net != &init_net)\r\nreturn -EAFNOSUPPORT;\r\nswitch (sock->type) {\r\ncase SOCK_STREAM:\r\ncase SOCK_SEQPACKET:\r\ncase SOCK_DGRAM:\r\nbreak;\r\ndefault:\r\nreturn -ESOCKTNOSUPPORT;\r\n}\r\nsk = sk_alloc(net, PF_IRDA, GFP_KERNEL, &irda_proto, kern);\r\nif (sk == NULL)\r\nreturn -ENOMEM;\r\nself = irda_sk(sk);\r\npr_debug("%s() : self is %p\n", __func__, self);\r\ninit_waitqueue_head(&self->query_wait);\r\nswitch (sock->type) {\r\ncase SOCK_STREAM:\r\nsock->ops = &irda_stream_ops;\r\nself->max_sdu_size_rx = TTP_SAR_DISABLE;\r\nbreak;\r\ncase SOCK_SEQPACKET:\r\nsock->ops = &irda_seqpacket_ops;\r\nself->max_sdu_size_rx = TTP_SAR_UNBOUND;\r\nbreak;\r\ncase SOCK_DGRAM:\r\nswitch (protocol) {\r\n#ifdef CONFIG_IRDA_ULTRA\r\ncase IRDAPROTO_ULTRA:\r\nsock->ops = &irda_ultra_ops;\r\nself->max_data_size = ULTRA_MAX_DATA - LMP_PID_HEADER;\r\nself->max_header_size = IRDA_MAX_HEADER + LMP_PID_HEADER;\r\nbreak;\r\n#endif\r\ncase IRDAPROTO_UNITDATA:\r\nsock->ops = &irda_dgram_ops;\r\nself->max_sdu_size_rx = TTP_SAR_UNBOUND;\r\nbreak;\r\ndefault:\r\nsk_free(sk);\r\nreturn -ESOCKTNOSUPPORT;\r\n}\r\nbreak;\r\ndefault:\r\nsk_free(sk);\r\nreturn -ESOCKTNOSUPPORT;\r\n}\r\nsock_init_data(sock, sk);\r\nsk->sk_family = PF_IRDA;\r\nsk->sk_protocol = protocol;\r\nself->ckey = irlmp_register_client(0, NULL, NULL, NULL);\r\nself->mask.word = 0xffff;\r\nself->rx_flow = self->tx_flow = FLOW_START;\r\nself->nslots = DISCOVERY_DEFAULT_SLOTS;\r\nself->daddr = DEV_ADDR_ANY;\r\nself->saddr = 0x0;\r\nreturn 0;\r\n}\r\nstatic void irda_destroy_socket(struct irda_sock *self)\r\n{\r\npr_debug("%s(%p)\n", __func__, self);\r\nirlmp_unregister_client(self->ckey);\r\nirlmp_unregister_service(self->skey);\r\nif (self->ias_obj) {\r\nirias_delete_object(self->ias_obj);\r\nself->ias_obj = NULL;\r\n}\r\nif (self->iriap) {\r\niriap_close(self->iriap);\r\nself->iriap = NULL;\r\n}\r\nif (self->tsap) {\r\nirttp_disconnect_request(self->tsap, NULL, P_NORMAL);\r\nirttp_close_tsap(self->tsap);\r\nself->tsap = NULL;\r\n}\r\n#ifdef CONFIG_IRDA_ULTRA\r\nif (self->lsap) {\r\nirlmp_close_lsap(self->lsap);\r\nself->lsap = NULL;\r\n}\r\n#endif\r\n}\r\nstatic int irda_release(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nif (sk == NULL)\r\nreturn 0;\r\nlock_sock(sk);\r\nsk->sk_state = TCP_CLOSE;\r\nsk->sk_shutdown |= SEND_SHUTDOWN;\r\nsk->sk_state_change(sk);\r\nirda_destroy_socket(irda_sk(sk));\r\nsock_orphan(sk);\r\nsock->sk = NULL;\r\nrelease_sock(sk);\r\nskb_queue_purge(&sk->sk_receive_queue);\r\nsock_put(sk);\r\nreturn 0;\r\n}\r\nstatic int irda_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct irda_sock *self;\r\nstruct sk_buff *skb;\r\nint err = -EPIPE;\r\npr_debug("%s(), len=%zd\n", __func__, len);\r\nif (msg->msg_flags & ~(MSG_DONTWAIT | MSG_EOR | MSG_CMSG_COMPAT |\r\nMSG_NOSIGNAL)) {\r\nreturn -EINVAL;\r\n}\r\nlock_sock(sk);\r\nif (sk->sk_shutdown & SEND_SHUTDOWN)\r\ngoto out_err;\r\nif (sk->sk_state != TCP_ESTABLISHED) {\r\nerr = -ENOTCONN;\r\ngoto out;\r\n}\r\nself = irda_sk(sk);\r\nif (wait_event_interruptible(*(sk_sleep(sk)),\r\n(self->tx_flow != FLOW_STOP || sk->sk_state != TCP_ESTABLISHED))) {\r\nerr = -ERESTARTSYS;\r\ngoto out;\r\n}\r\nif (sk->sk_state != TCP_ESTABLISHED) {\r\nerr = -ENOTCONN;\r\ngoto out;\r\n}\r\nif (len > self->max_data_size) {\r\npr_debug("%s(), Chopping frame from %zd to %d bytes!\n",\r\n__func__, len, self->max_data_size);\r\nlen = self->max_data_size;\r\n}\r\nskb = sock_alloc_send_skb(sk, len + self->max_header_size + 16,\r\nmsg->msg_flags & MSG_DONTWAIT, &err);\r\nif (!skb)\r\ngoto out_err;\r\nskb_reserve(skb, self->max_header_size + 16);\r\nskb_reset_transport_header(skb);\r\nskb_put(skb, len);\r\nerr = memcpy_from_msg(skb_transport_header(skb), msg, len);\r\nif (err) {\r\nkfree_skb(skb);\r\ngoto out_err;\r\n}\r\nerr = irttp_data_request(self->tsap, skb);\r\nif (err) {\r\npr_debug("%s(), err=%d\n", __func__, err);\r\ngoto out_err;\r\n}\r\nrelease_sock(sk);\r\nreturn len;\r\nout_err:\r\nerr = sk_stream_error(sk, msg->msg_flags, err);\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int irda_recvmsg_dgram(struct socket *sock, struct msghdr *msg,\r\nsize_t size, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct irda_sock *self = irda_sk(sk);\r\nstruct sk_buff *skb;\r\nsize_t copied;\r\nint err;\r\nskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\r\nflags & MSG_DONTWAIT, &err);\r\nif (!skb)\r\nreturn err;\r\nskb_reset_transport_header(skb);\r\ncopied = skb->len;\r\nif (copied > size) {\r\npr_debug("%s(), Received truncated frame (%zd < %zd)!\n",\r\n__func__, copied, size);\r\ncopied = size;\r\nmsg->msg_flags |= MSG_TRUNC;\r\n}\r\nskb_copy_datagram_msg(skb, 0, msg, copied);\r\nskb_free_datagram(sk, skb);\r\nif (self->rx_flow == FLOW_STOP) {\r\nif ((atomic_read(&sk->sk_rmem_alloc) << 2) <= sk->sk_rcvbuf) {\r\npr_debug("%s(), Starting IrTTP\n", __func__);\r\nself->rx_flow = FLOW_START;\r\nirttp_flow_request(self->tsap, FLOW_START);\r\n}\r\n}\r\nreturn copied;\r\n}\r\nstatic int irda_recvmsg_stream(struct socket *sock, struct msghdr *msg,\r\nsize_t size, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct irda_sock *self = irda_sk(sk);\r\nint noblock = flags & MSG_DONTWAIT;\r\nsize_t copied = 0;\r\nint target, err;\r\nlong timeo;\r\nif ((err = sock_error(sk)) < 0)\r\nreturn err;\r\nif (sock->flags & __SO_ACCEPTCON)\r\nreturn -EINVAL;\r\nerr =-EOPNOTSUPP;\r\nif (flags & MSG_OOB)\r\nreturn -EOPNOTSUPP;\r\nerr = 0;\r\ntarget = sock_rcvlowat(sk, flags & MSG_WAITALL, size);\r\ntimeo = sock_rcvtimeo(sk, noblock);\r\ndo {\r\nint chunk;\r\nstruct sk_buff *skb = skb_dequeue(&sk->sk_receive_queue);\r\nif (skb == NULL) {\r\nDEFINE_WAIT(wait);\r\nerr = 0;\r\nif (copied >= target)\r\nbreak;\r\nprepare_to_wait_exclusive(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\r\nerr = sock_error(sk);\r\nif (err)\r\n;\r\nelse if (sk->sk_shutdown & RCV_SHUTDOWN)\r\n;\r\nelse if (noblock)\r\nerr = -EAGAIN;\r\nelse if (signal_pending(current))\r\nerr = sock_intr_errno(timeo);\r\nelse if (sk->sk_state != TCP_ESTABLISHED)\r\nerr = -ENOTCONN;\r\nelse if (skb_peek(&sk->sk_receive_queue) == NULL)\r\nschedule();\r\nfinish_wait(sk_sleep(sk), &wait);\r\nif (err)\r\nreturn err;\r\nif (sk->sk_shutdown & RCV_SHUTDOWN)\r\nbreak;\r\ncontinue;\r\n}\r\nchunk = min_t(unsigned int, skb->len, size);\r\nif (memcpy_to_msg(msg, skb->data, chunk)) {\r\nskb_queue_head(&sk->sk_receive_queue, skb);\r\nif (copied == 0)\r\ncopied = -EFAULT;\r\nbreak;\r\n}\r\ncopied += chunk;\r\nsize -= chunk;\r\nif (!(flags & MSG_PEEK)) {\r\nskb_pull(skb, chunk);\r\nif (skb->len) {\r\npr_debug("%s(), back on q!\n",\r\n__func__);\r\nskb_queue_head(&sk->sk_receive_queue, skb);\r\nbreak;\r\n}\r\nkfree_skb(skb);\r\n} else {\r\npr_debug("%s() questionable!?\n", __func__);\r\nskb_queue_head(&sk->sk_receive_queue, skb);\r\nbreak;\r\n}\r\n} while (size);\r\nif (self->rx_flow == FLOW_STOP) {\r\nif ((atomic_read(&sk->sk_rmem_alloc) << 2) <= sk->sk_rcvbuf) {\r\npr_debug("%s(), Starting IrTTP\n", __func__);\r\nself->rx_flow = FLOW_START;\r\nirttp_flow_request(self->tsap, FLOW_START);\r\n}\r\n}\r\nreturn copied;\r\n}\r\nstatic int irda_sendmsg_dgram(struct socket *sock, struct msghdr *msg,\r\nsize_t len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct irda_sock *self;\r\nstruct sk_buff *skb;\r\nint err;\r\npr_debug("%s(), len=%zd\n", __func__, len);\r\nif (msg->msg_flags & ~(MSG_DONTWAIT|MSG_CMSG_COMPAT))\r\nreturn -EINVAL;\r\nlock_sock(sk);\r\nif (sk->sk_shutdown & SEND_SHUTDOWN) {\r\nsend_sig(SIGPIPE, current, 0);\r\nerr = -EPIPE;\r\ngoto out;\r\n}\r\nerr = -ENOTCONN;\r\nif (sk->sk_state != TCP_ESTABLISHED)\r\ngoto out;\r\nself = irda_sk(sk);\r\nif (len > self->max_data_size) {\r\npr_debug("%s(), Warning too much data! Chopping frame from %zd to %d bytes!\n",\r\n__func__, len, self->max_data_size);\r\nlen = self->max_data_size;\r\n}\r\nskb = sock_alloc_send_skb(sk, len + self->max_header_size,\r\nmsg->msg_flags & MSG_DONTWAIT, &err);\r\nerr = -ENOBUFS;\r\nif (!skb)\r\ngoto out;\r\nskb_reserve(skb, self->max_header_size);\r\nskb_reset_transport_header(skb);\r\npr_debug("%s(), appending user data\n", __func__);\r\nskb_put(skb, len);\r\nerr = memcpy_from_msg(skb_transport_header(skb), msg, len);\r\nif (err) {\r\nkfree_skb(skb);\r\ngoto out;\r\n}\r\nerr = irttp_udata_request(self->tsap, skb);\r\nif (err) {\r\npr_debug("%s(), err=%d\n", __func__, err);\r\ngoto out;\r\n}\r\nrelease_sock(sk);\r\nreturn len;\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int irda_sendmsg_ultra(struct socket *sock, struct msghdr *msg,\r\nsize_t len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct irda_sock *self;\r\n__u8 pid = 0;\r\nint bound = 0;\r\nstruct sk_buff *skb;\r\nint err;\r\npr_debug("%s(), len=%zd\n", __func__, len);\r\nerr = -EINVAL;\r\nif (msg->msg_flags & ~(MSG_DONTWAIT|MSG_CMSG_COMPAT))\r\nreturn -EINVAL;\r\nlock_sock(sk);\r\nerr = -EPIPE;\r\nif (sk->sk_shutdown & SEND_SHUTDOWN) {\r\nsend_sig(SIGPIPE, current, 0);\r\ngoto out;\r\n}\r\nself = irda_sk(sk);\r\nif (msg->msg_name) {\r\nDECLARE_SOCKADDR(struct sockaddr_irda *, addr, msg->msg_name);\r\nerr = -EINVAL;\r\nif (msg->msg_namelen < sizeof(*addr))\r\ngoto out;\r\nif (addr->sir_family != AF_IRDA)\r\ngoto out;\r\npid = addr->sir_lsap_sel;\r\nif (pid & 0x80) {\r\npr_debug("%s(), extension in PID not supp!\n",\r\n__func__);\r\nerr = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\n} else {\r\nif ((self->lsap == NULL) ||\r\n(sk->sk_state != TCP_ESTABLISHED)) {\r\npr_debug("%s(), socket not bound to Ultra PID.\n",\r\n__func__);\r\nerr = -ENOTCONN;\r\ngoto out;\r\n}\r\nbound = 1;\r\n}\r\nif (len > self->max_data_size) {\r\npr_debug("%s(), Warning too much data! Chopping frame from %zd to %d bytes!\n",\r\n__func__, len, self->max_data_size);\r\nlen = self->max_data_size;\r\n}\r\nskb = sock_alloc_send_skb(sk, len + self->max_header_size,\r\nmsg->msg_flags & MSG_DONTWAIT, &err);\r\nerr = -ENOBUFS;\r\nif (!skb)\r\ngoto out;\r\nskb_reserve(skb, self->max_header_size);\r\nskb_reset_transport_header(skb);\r\npr_debug("%s(), appending user data\n", __func__);\r\nskb_put(skb, len);\r\nerr = memcpy_from_msg(skb_transport_header(skb), msg, len);\r\nif (err) {\r\nkfree_skb(skb);\r\ngoto out;\r\n}\r\nerr = irlmp_connless_data_request((bound ? self->lsap : NULL),\r\nskb, pid);\r\nif (err)\r\npr_debug("%s(), err=%d\n", __func__, err);\r\nout:\r\nrelease_sock(sk);\r\nreturn err ? : len;\r\n}\r\nstatic int irda_shutdown(struct socket *sock, int how)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct irda_sock *self = irda_sk(sk);\r\npr_debug("%s(%p)\n", __func__, self);\r\nlock_sock(sk);\r\nsk->sk_state = TCP_CLOSE;\r\nsk->sk_shutdown |= SEND_SHUTDOWN;\r\nsk->sk_state_change(sk);\r\nif (self->iriap) {\r\niriap_close(self->iriap);\r\nself->iriap = NULL;\r\n}\r\nif (self->tsap) {\r\nirttp_disconnect_request(self->tsap, NULL, P_NORMAL);\r\nirttp_close_tsap(self->tsap);\r\nself->tsap = NULL;\r\n}\r\nself->rx_flow = self->tx_flow = FLOW_START;\r\nself->daddr = DEV_ADDR_ANY;\r\nself->saddr = 0x0;\r\nrelease_sock(sk);\r\nreturn 0;\r\n}\r\nstatic unsigned int irda_poll(struct file * file, struct socket *sock,\r\npoll_table *wait)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct irda_sock *self = irda_sk(sk);\r\nunsigned int mask;\r\npoll_wait(file, sk_sleep(sk), wait);\r\nmask = 0;\r\nif (sk->sk_err)\r\nmask |= POLLERR;\r\nif (sk->sk_shutdown & RCV_SHUTDOWN) {\r\npr_debug("%s(), POLLHUP\n", __func__);\r\nmask |= POLLHUP;\r\n}\r\nif (!skb_queue_empty(&sk->sk_receive_queue)) {\r\npr_debug("Socket is readable\n");\r\nmask |= POLLIN | POLLRDNORM;\r\n}\r\nswitch (sk->sk_type) {\r\ncase SOCK_STREAM:\r\nif (sk->sk_state == TCP_CLOSE) {\r\npr_debug("%s(), POLLHUP\n", __func__);\r\nmask |= POLLHUP;\r\n}\r\nif (sk->sk_state == TCP_ESTABLISHED) {\r\nif ((self->tx_flow == FLOW_START) &&\r\nsock_writeable(sk))\r\n{\r\nmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\r\n}\r\n}\r\nbreak;\r\ncase SOCK_SEQPACKET:\r\nif ((self->tx_flow == FLOW_START) &&\r\nsock_writeable(sk))\r\n{\r\nmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\r\n}\r\nbreak;\r\ncase SOCK_DGRAM:\r\nif (sock_writeable(sk))\r\nmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn mask;\r\n}\r\nstatic int irda_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint err;\r\npr_debug("%s(), cmd=%#x\n", __func__, cmd);\r\nerr = -EINVAL;\r\nswitch (cmd) {\r\ncase TIOCOUTQ: {\r\nlong amount;\r\namount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\r\nif (amount < 0)\r\namount = 0;\r\nerr = put_user(amount, (unsigned int __user *)arg);\r\nbreak;\r\n}\r\ncase TIOCINQ: {\r\nstruct sk_buff *skb;\r\nlong amount = 0L;\r\nif ((skb = skb_peek(&sk->sk_receive_queue)) != NULL)\r\namount = skb->len;\r\nerr = put_user(amount, (unsigned int __user *)arg);\r\nbreak;\r\n}\r\ncase SIOCGSTAMP:\r\nif (sk != NULL)\r\nerr = sock_get_timestamp(sk, (struct timeval __user *)arg);\r\nbreak;\r\ncase SIOCGIFADDR:\r\ncase SIOCSIFADDR:\r\ncase SIOCGIFDSTADDR:\r\ncase SIOCSIFDSTADDR:\r\ncase SIOCGIFBRDADDR:\r\ncase SIOCSIFBRDADDR:\r\ncase SIOCGIFNETMASK:\r\ncase SIOCSIFNETMASK:\r\ncase SIOCGIFMETRIC:\r\ncase SIOCSIFMETRIC:\r\nbreak;\r\ndefault:\r\npr_debug("%s(), doing device ioctl!\n", __func__);\r\nerr = -ENOIOCTLCMD;\r\n}\r\nreturn err;\r\n}\r\nstatic int irda_compat_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\r\n{\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int irda_setsockopt(struct socket *sock, int level, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct irda_sock *self = irda_sk(sk);\r\nstruct irda_ias_set *ias_opt;\r\nstruct ias_object *ias_obj;\r\nstruct ias_attrib * ias_attr;\r\nint opt, free_ias = 0, err = 0;\r\npr_debug("%s(%p)\n", __func__, self);\r\nif (level != SOL_IRLMP)\r\nreturn -ENOPROTOOPT;\r\nlock_sock(sk);\r\nswitch (optname) {\r\ncase IRLMP_IAS_SET:\r\nif (optlen != sizeof(struct irda_ias_set)) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nias_opt = kmalloc(sizeof(struct irda_ias_set), GFP_ATOMIC);\r\nif (ias_opt == NULL) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nif (copy_from_user(ias_opt, optval, optlen)) {\r\nkfree(ias_opt);\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\nif(ias_opt->irda_class_name[0] == '\0') {\r\nif(self->ias_obj == NULL) {\r\nkfree(ias_opt);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nias_obj = self->ias_obj;\r\n} else\r\nias_obj = irias_find_object(ias_opt->irda_class_name);\r\nif((!capable(CAP_NET_ADMIN)) &&\r\n((ias_obj == NULL) || (ias_obj != self->ias_obj))) {\r\nkfree(ias_opt);\r\nerr = -EPERM;\r\ngoto out;\r\n}\r\nif(ias_obj == (struct ias_object *) NULL) {\r\nias_obj = irias_new_object(ias_opt->irda_class_name,\r\njiffies);\r\nif (ias_obj == NULL) {\r\nkfree(ias_opt);\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nfree_ias = 1;\r\n}\r\nif(irias_find_attrib(ias_obj, ias_opt->irda_attrib_name)) {\r\nkfree(ias_opt);\r\nif (free_ias) {\r\nkfree(ias_obj->name);\r\nkfree(ias_obj);\r\n}\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nswitch(ias_opt->irda_attrib_type) {\r\ncase IAS_INTEGER:\r\nirias_add_integer_attrib(\r\nias_obj,\r\nias_opt->irda_attrib_name,\r\nias_opt->attribute.irda_attrib_int,\r\nIAS_USER_ATTR);\r\nbreak;\r\ncase IAS_OCT_SEQ:\r\nif(ias_opt->attribute.irda_attrib_octet_seq.len >\r\nIAS_MAX_OCTET_STRING) {\r\nkfree(ias_opt);\r\nif (free_ias) {\r\nkfree(ias_obj->name);\r\nkfree(ias_obj);\r\n}\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nirias_add_octseq_attrib(\r\nias_obj,\r\nias_opt->irda_attrib_name,\r\nias_opt->attribute.irda_attrib_octet_seq.octet_seq,\r\nias_opt->attribute.irda_attrib_octet_seq.len,\r\nIAS_USER_ATTR);\r\nbreak;\r\ncase IAS_STRING:\r\nias_opt->attribute.irda_attrib_string.string[ias_opt->attribute.irda_attrib_string.len] = '\0';\r\nirias_add_string_attrib(\r\nias_obj,\r\nias_opt->irda_attrib_name,\r\nias_opt->attribute.irda_attrib_string.string,\r\nIAS_USER_ATTR);\r\nbreak;\r\ndefault :\r\nkfree(ias_opt);\r\nif (free_ias) {\r\nkfree(ias_obj->name);\r\nkfree(ias_obj);\r\n}\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nirias_insert_object(ias_obj);\r\nkfree(ias_opt);\r\nbreak;\r\ncase IRLMP_IAS_DEL:\r\nif (optlen != sizeof(struct irda_ias_set)) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nias_opt = kmalloc(sizeof(struct irda_ias_set), GFP_ATOMIC);\r\nif (ias_opt == NULL) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nif (copy_from_user(ias_opt, optval, optlen)) {\r\nkfree(ias_opt);\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\nif(ias_opt->irda_class_name[0] == '\0')\r\nias_obj = self->ias_obj;\r\nelse\r\nias_obj = irias_find_object(ias_opt->irda_class_name);\r\nif(ias_obj == (struct ias_object *) NULL) {\r\nkfree(ias_opt);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif((!capable(CAP_NET_ADMIN)) &&\r\n((ias_obj == NULL) || (ias_obj != self->ias_obj))) {\r\nkfree(ias_opt);\r\nerr = -EPERM;\r\ngoto out;\r\n}\r\nias_attr = irias_find_attrib(ias_obj,\r\nias_opt->irda_attrib_name);\r\nif(ias_attr == (struct ias_attrib *) NULL) {\r\nkfree(ias_opt);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif(ias_attr->value->owner != IAS_USER_ATTR) {\r\npr_debug("%s(), attempting to delete a kernel attribute\n",\r\n__func__);\r\nkfree(ias_opt);\r\nerr = -EPERM;\r\ngoto out;\r\n}\r\nirias_delete_attrib(ias_obj, ias_attr, 1);\r\nkfree(ias_opt);\r\nbreak;\r\ncase IRLMP_MAX_SDU_SIZE:\r\nif (optlen < sizeof(int)) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (get_user(opt, (int __user *)optval)) {\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\nif (sk->sk_type != SOCK_SEQPACKET) {\r\npr_debug("%s(), setting max_sdu_size = %d\n",\r\n__func__, opt);\r\nself->max_sdu_size_rx = opt;\r\n} else {\r\nnet_warn_ratelimited("%s: not allowed to set MAXSDUSIZE for this socket type!\n",\r\n__func__);\r\nerr = -ENOPROTOOPT;\r\ngoto out;\r\n}\r\nbreak;\r\ncase IRLMP_HINTS_SET:\r\nif (optlen < sizeof(int)) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (get_user(opt, (int __user *)optval)) {\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\nirlmp_unregister_service(self->skey);\r\nself->skey = irlmp_register_service((__u16) opt);\r\nbreak;\r\ncase IRLMP_HINT_MASK_SET:\r\nif (optlen < sizeof(int)) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (get_user(opt, (int __user *)optval)) {\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\nself->mask.word = (__u16) opt;\r\nself->mask.word &= 0x7f7f;\r\nif(!self->mask.word)\r\nself->mask.word = 0xFFFF;\r\nbreak;\r\ndefault:\r\nerr = -ENOPROTOOPT;\r\nbreak;\r\n}\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int irda_extract_ias_value(struct irda_ias_set *ias_opt,\r\nstruct ias_value *ias_value)\r\n{\r\nswitch (ias_value->type) {\r\ncase IAS_INTEGER:\r\nias_opt->attribute.irda_attrib_int = ias_value->t.integer;\r\nbreak;\r\ncase IAS_OCT_SEQ:\r\nias_opt->attribute.irda_attrib_octet_seq.len = ias_value->len;\r\nmemcpy(ias_opt->attribute.irda_attrib_octet_seq.octet_seq,\r\nias_value->t.oct_seq, ias_value->len);\r\nbreak;\r\ncase IAS_STRING:\r\nias_opt->attribute.irda_attrib_string.len = ias_value->len;\r\nias_opt->attribute.irda_attrib_string.charset = ias_value->charset;\r\nmemcpy(ias_opt->attribute.irda_attrib_string.string,\r\nias_value->t.string, ias_value->len);\r\nias_opt->attribute.irda_attrib_string.string[ias_value->len] = '\0';\r\nbreak;\r\ncase IAS_MISSING:\r\ndefault :\r\nreturn -EINVAL;\r\n}\r\nias_opt->irda_attrib_type = ias_value->type;\r\nreturn 0;\r\n}\r\nstatic int irda_getsockopt(struct socket *sock, int level, int optname,\r\nchar __user *optval, int __user *optlen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct irda_sock *self = irda_sk(sk);\r\nstruct irda_device_list list;\r\nstruct irda_device_info *discoveries;\r\nstruct irda_ias_set * ias_opt;\r\nstruct ias_object * ias_obj;\r\nstruct ias_attrib * ias_attr;\r\nint daddr = DEV_ADDR_ANY;\r\nint val = 0;\r\nint len = 0;\r\nint err = 0;\r\nint offset, total;\r\npr_debug("%s(%p)\n", __func__, self);\r\nif (level != SOL_IRLMP)\r\nreturn -ENOPROTOOPT;\r\nif (get_user(len, optlen))\r\nreturn -EFAULT;\r\nif(len < 0)\r\nreturn -EINVAL;\r\nlock_sock(sk);\r\nswitch (optname) {\r\ncase IRLMP_ENUMDEVICES:\r\noffset = sizeof(struct irda_device_list) -\r\nsizeof(struct irda_device_info);\r\nif (len < offset) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\ndiscoveries = irlmp_get_discoveries(&list.len, self->mask.word,\r\nself->nslots);\r\nif (discoveries == NULL) {\r\nerr = -EAGAIN;\r\ngoto out;\r\n}\r\nif (copy_to_user(optval, &list, offset))\r\nerr = -EFAULT;\r\nif (list.len > 2048) {\r\nerr = -EINVAL;\r\ngoto bed;\r\n}\r\ntotal = offset + (list.len * sizeof(struct irda_device_info));\r\nif (total > len)\r\ntotal = len;\r\nif (copy_to_user(optval+offset, discoveries, total - offset))\r\nerr = -EFAULT;\r\nif (put_user(total, optlen))\r\nerr = -EFAULT;\r\nbed:\r\nkfree(discoveries);\r\nbreak;\r\ncase IRLMP_MAX_SDU_SIZE:\r\nval = self->max_data_size;\r\nlen = sizeof(int);\r\nif (put_user(len, optlen)) {\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\nif (copy_to_user(optval, &val, len)) {\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\nbreak;\r\ncase IRLMP_IAS_GET:\r\nif (len != sizeof(struct irda_ias_set)) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nias_opt = kmalloc(sizeof(struct irda_ias_set), GFP_ATOMIC);\r\nif (ias_opt == NULL) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nif (copy_from_user(ias_opt, optval, len)) {\r\nkfree(ias_opt);\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\nif(ias_opt->irda_class_name[0] == '\0')\r\nias_obj = self->ias_obj;\r\nelse\r\nias_obj = irias_find_object(ias_opt->irda_class_name);\r\nif(ias_obj == (struct ias_object *) NULL) {\r\nkfree(ias_opt);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nias_attr = irias_find_attrib(ias_obj,\r\nias_opt->irda_attrib_name);\r\nif(ias_attr == (struct ias_attrib *) NULL) {\r\nkfree(ias_opt);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nerr = irda_extract_ias_value(ias_opt, ias_attr->value);\r\nif(err) {\r\nkfree(ias_opt);\r\ngoto out;\r\n}\r\nif (copy_to_user(optval, ias_opt,\r\nsizeof(struct irda_ias_set))) {\r\nkfree(ias_opt);\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\nkfree(ias_opt);\r\nbreak;\r\ncase IRLMP_IAS_QUERY:\r\nif (len != sizeof(struct irda_ias_set)) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nias_opt = kmalloc(sizeof(struct irda_ias_set), GFP_ATOMIC);\r\nif (ias_opt == NULL) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nif (copy_from_user(ias_opt, optval, len)) {\r\nkfree(ias_opt);\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\nif(self->daddr != DEV_ADDR_ANY) {\r\ndaddr = self->daddr;\r\n} else {\r\ndaddr = ias_opt->daddr;\r\nif((!daddr) || (daddr == DEV_ADDR_ANY)) {\r\nkfree(ias_opt);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nif (self->iriap) {\r\nnet_warn_ratelimited("%s: busy with a previous query\n",\r\n__func__);\r\nkfree(ias_opt);\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\nself->iriap = iriap_open(LSAP_ANY, IAS_CLIENT, self,\r\nirda_getvalue_confirm);\r\nif (self->iriap == NULL) {\r\nkfree(ias_opt);\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nself->errno = -EHOSTUNREACH;\r\niriap_getvaluebyclass_request(self->iriap,\r\nself->saddr, daddr,\r\nias_opt->irda_class_name,\r\nias_opt->irda_attrib_name);\r\nif (wait_event_interruptible(self->query_wait,\r\n(self->iriap == NULL))) {\r\nkfree(ias_opt);\r\nerr = -EHOSTUNREACH;\r\ngoto out;\r\n}\r\nif (self->errno)\r\n{\r\nkfree(ias_opt);\r\nif((self->errno == IAS_CLASS_UNKNOWN) ||\r\n(self->errno == IAS_ATTRIB_UNKNOWN))\r\nerr = -EADDRNOTAVAIL;\r\nelse\r\nerr = -EHOSTUNREACH;\r\ngoto out;\r\n}\r\nerr = irda_extract_ias_value(ias_opt, self->ias_result);\r\nif (self->ias_result)\r\nirias_delete_value(self->ias_result);\r\nif (err) {\r\nkfree(ias_opt);\r\ngoto out;\r\n}\r\nif (copy_to_user(optval, ias_opt,\r\nsizeof(struct irda_ias_set))) {\r\nkfree(ias_opt);\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\nkfree(ias_opt);\r\nbreak;\r\ncase IRLMP_WAITDEVICE:\r\nif (len != sizeof(int)) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (get_user(val, (int __user *)optval)) {\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\nirlmp_update_client(self->ckey, self->mask.word,\r\nirda_selective_discovery_indication,\r\nNULL, (void *) self);\r\nirlmp_discovery_request(self->nslots);\r\nif (!self->cachedaddr) {\r\npr_debug("%s(), nothing discovered yet, going to sleep...\n",\r\n__func__);\r\nself->errno = 0;\r\nsetup_timer(&self->watchdog, irda_discovery_timeout,\r\n(unsigned long)self);\r\nmod_timer(&self->watchdog,\r\njiffies + msecs_to_jiffies(val));\r\nerr = __wait_event_interruptible(self->query_wait,\r\n(self->cachedaddr != 0 || self->errno == -ETIME));\r\ndel_timer(&(self->watchdog));\r\npr_debug("%s(), ...waking up !\n", __func__);\r\nif (err != 0)\r\ngoto out;\r\n}\r\nelse\r\npr_debug("%s(), found immediately !\n",\r\n__func__);\r\nirlmp_update_client(self->ckey, self->mask.word,\r\nNULL, NULL, NULL);\r\nif (!self->cachedaddr) {\r\nerr = -EAGAIN;\r\ngoto out;\r\n}\r\ndaddr = self->cachedaddr;\r\nself->cachedaddr = 0;\r\nif (put_user(daddr, (int __user *)optval)) {\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\nbreak;\r\ndefault:\r\nerr = -ENOPROTOOPT;\r\n}\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nint __init irsock_init(void)\r\n{\r\nint rc = proto_register(&irda_proto, 0);\r\nif (rc == 0)\r\nrc = sock_register(&irda_family_ops);\r\nreturn rc;\r\n}\r\nvoid irsock_cleanup(void)\r\n{\r\nsock_unregister(PF_IRDA);\r\nproto_unregister(&irda_proto);\r\n}
