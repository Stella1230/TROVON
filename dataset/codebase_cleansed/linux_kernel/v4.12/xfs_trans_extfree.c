struct xfs_efd_log_item *\r\nxfs_trans_get_efd(struct xfs_trans *tp,\r\nstruct xfs_efi_log_item *efip,\r\nuint nextents)\r\n{\r\nstruct xfs_efd_log_item *efdp;\r\nASSERT(tp != NULL);\r\nASSERT(nextents > 0);\r\nefdp = xfs_efd_init(tp->t_mountp, efip, nextents);\r\nASSERT(efdp != NULL);\r\nxfs_trans_add_item(tp, &efdp->efd_item);\r\nreturn efdp;\r\n}\r\nint\r\nxfs_trans_free_extent(\r\nstruct xfs_trans *tp,\r\nstruct xfs_efd_log_item *efdp,\r\nxfs_fsblock_t start_block,\r\nxfs_extlen_t ext_len,\r\nstruct xfs_owner_info *oinfo)\r\n{\r\nstruct xfs_mount *mp = tp->t_mountp;\r\nuint next_extent;\r\nxfs_agnumber_t agno = XFS_FSB_TO_AGNO(mp, start_block);\r\nxfs_agblock_t agbno = XFS_FSB_TO_AGBNO(mp, start_block);\r\nstruct xfs_extent *extp;\r\nint error;\r\ntrace_xfs_bmap_free_deferred(tp->t_mountp, agno, 0, agbno, ext_len);\r\nerror = xfs_free_extent(tp, start_block, ext_len, oinfo,\r\nXFS_AG_RESV_NONE);\r\ntp->t_flags |= XFS_TRANS_DIRTY;\r\nefdp->efd_item.li_desc->lid_flags |= XFS_LID_DIRTY;\r\nnext_extent = efdp->efd_next_extent;\r\nASSERT(next_extent < efdp->efd_format.efd_nextents);\r\nextp = &(efdp->efd_format.efd_extents[next_extent]);\r\nextp->ext_start = start_block;\r\nextp->ext_len = ext_len;\r\nefdp->efd_next_extent++;\r\nreturn error;\r\n}\r\nstatic int\r\nxfs_extent_free_diff_items(\r\nvoid *priv,\r\nstruct list_head *a,\r\nstruct list_head *b)\r\n{\r\nstruct xfs_mount *mp = priv;\r\nstruct xfs_extent_free_item *ra;\r\nstruct xfs_extent_free_item *rb;\r\nra = container_of(a, struct xfs_extent_free_item, xefi_list);\r\nrb = container_of(b, struct xfs_extent_free_item, xefi_list);\r\nreturn XFS_FSB_TO_AGNO(mp, ra->xefi_startblock) -\r\nXFS_FSB_TO_AGNO(mp, rb->xefi_startblock);\r\n}\r\nSTATIC void *\r\nxfs_extent_free_create_intent(\r\nstruct xfs_trans *tp,\r\nunsigned int count)\r\n{\r\nstruct xfs_efi_log_item *efip;\r\nASSERT(tp != NULL);\r\nASSERT(count > 0);\r\nefip = xfs_efi_init(tp->t_mountp, count);\r\nASSERT(efip != NULL);\r\nxfs_trans_add_item(tp, &efip->efi_item);\r\nreturn efip;\r\n}\r\nSTATIC void\r\nxfs_extent_free_log_item(\r\nstruct xfs_trans *tp,\r\nvoid *intent,\r\nstruct list_head *item)\r\n{\r\nstruct xfs_efi_log_item *efip = intent;\r\nstruct xfs_extent_free_item *free;\r\nuint next_extent;\r\nstruct xfs_extent *extp;\r\nfree = container_of(item, struct xfs_extent_free_item, xefi_list);\r\ntp->t_flags |= XFS_TRANS_DIRTY;\r\nefip->efi_item.li_desc->lid_flags |= XFS_LID_DIRTY;\r\nnext_extent = atomic_inc_return(&efip->efi_next_extent) - 1;\r\nASSERT(next_extent < efip->efi_format.efi_nextents);\r\nextp = &efip->efi_format.efi_extents[next_extent];\r\nextp->ext_start = free->xefi_startblock;\r\nextp->ext_len = free->xefi_blockcount;\r\n}\r\nSTATIC void *\r\nxfs_extent_free_create_done(\r\nstruct xfs_trans *tp,\r\nvoid *intent,\r\nunsigned int count)\r\n{\r\nreturn xfs_trans_get_efd(tp, intent, count);\r\n}\r\nSTATIC int\r\nxfs_extent_free_finish_item(\r\nstruct xfs_trans *tp,\r\nstruct xfs_defer_ops *dop,\r\nstruct list_head *item,\r\nvoid *done_item,\r\nvoid **state)\r\n{\r\nstruct xfs_extent_free_item *free;\r\nint error;\r\nfree = container_of(item, struct xfs_extent_free_item, xefi_list);\r\nerror = xfs_trans_free_extent(tp, done_item,\r\nfree->xefi_startblock,\r\nfree->xefi_blockcount,\r\n&free->xefi_oinfo);\r\nkmem_free(free);\r\nreturn error;\r\n}\r\nSTATIC void\r\nxfs_extent_free_abort_intent(\r\nvoid *intent)\r\n{\r\nxfs_efi_release(intent);\r\n}\r\nSTATIC void\r\nxfs_extent_free_cancel_item(\r\nstruct list_head *item)\r\n{\r\nstruct xfs_extent_free_item *free;\r\nfree = container_of(item, struct xfs_extent_free_item, xefi_list);\r\nkmem_free(free);\r\n}\r\nvoid\r\nxfs_extent_free_init_defer_op(void)\r\n{\r\nxfs_defer_init_op_type(&xfs_extent_free_defer_type);\r\n}
