static bool max98090_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase M98090_REG_SOFTWARE_RESET:\r\ncase M98090_REG_DEVICE_STATUS:\r\ncase M98090_REG_JACK_STATUS:\r\ncase M98090_REG_REVISION_ID:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool max98090_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase M98090_REG_DEVICE_STATUS ... M98090_REG_INTERRUPT_S:\r\ncase M98090_REG_LINE_INPUT_CONFIG ... 0xD1:\r\ncase M98090_REG_REVISION_ID:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int max98090_reset(struct max98090_priv *max98090)\r\n{\r\nint ret;\r\nret = regmap_write(max98090->regmap, M98090_REG_SOFTWARE_RESET,\r\nM98090_SWRESET_MASK);\r\nif (ret < 0) {\r\ndev_err(max98090->codec->dev,\r\n"Failed to reset codec: %d\n", ret);\r\nreturn ret;\r\n}\r\nmsleep(20);\r\nreturn ret;\r\n}\r\nstatic int max98090_get_enab_tlv(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nunsigned int mask = (1 << fls(mc->max)) - 1;\r\nunsigned int val = snd_soc_read(codec, mc->reg);\r\nunsigned int *select;\r\nswitch (mc->reg) {\r\ncase M98090_REG_MIC1_INPUT_LEVEL:\r\nselect = &(max98090->pa1en);\r\nbreak;\r\ncase M98090_REG_MIC2_INPUT_LEVEL:\r\nselect = &(max98090->pa2en);\r\nbreak;\r\ncase M98090_REG_ADC_SIDETONE:\r\nselect = &(max98090->sidetone);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nval = (val >> mc->shift) & mask;\r\nif (val >= 1) {\r\nval = val - 1;\r\n*select = val;\r\n} else {\r\nval = *select;\r\n}\r\nucontrol->value.integer.value[0] = val;\r\nreturn 0;\r\n}\r\nstatic int max98090_put_enab_tlv(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nunsigned int mask = (1 << fls(mc->max)) - 1;\r\nunsigned int sel = ucontrol->value.integer.value[0];\r\nunsigned int val = snd_soc_read(codec, mc->reg);\r\nunsigned int *select;\r\nswitch (mc->reg) {\r\ncase M98090_REG_MIC1_INPUT_LEVEL:\r\nselect = &(max98090->pa1en);\r\nbreak;\r\ncase M98090_REG_MIC2_INPUT_LEVEL:\r\nselect = &(max98090->pa2en);\r\nbreak;\r\ncase M98090_REG_ADC_SIDETONE:\r\nselect = &(max98090->sidetone);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nval = (val >> mc->shift) & mask;\r\n*select = sel;\r\nif (val >= 1) {\r\nsel = sel + 1;\r\n} else {\r\nsel = val;\r\n}\r\nsnd_soc_update_bits(codec, mc->reg,\r\nmask << mc->shift,\r\nsel << mc->shift);\r\nreturn 0;\r\n}\r\nstatic int max98090_micinput_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int val = snd_soc_read(codec, w->reg);\r\nif (w->reg == M98090_REG_MIC1_INPUT_LEVEL)\r\nval = (val & M98090_MIC_PA1EN_MASK) >> M98090_MIC_PA1EN_SHIFT;\r\nelse\r\nval = (val & M98090_MIC_PA2EN_MASK) >> M98090_MIC_PA2EN_SHIFT;\r\nif (val >= 1) {\r\nif (w->reg == M98090_REG_MIC1_INPUT_LEVEL) {\r\nmax98090->pa1en = val - 1;\r\n} else {\r\nmax98090->pa2en = val - 1;\r\n}\r\n}\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nif (w->reg == M98090_REG_MIC1_INPUT_LEVEL)\r\nval = max98090->pa1en + 1;\r\nelse\r\nval = max98090->pa2en + 1;\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nval = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (w->reg == M98090_REG_MIC1_INPUT_LEVEL)\r\nsnd_soc_update_bits(codec, w->reg, M98090_MIC_PA1EN_MASK,\r\nval << M98090_MIC_PA1EN_SHIFT);\r\nelse\r\nsnd_soc_update_bits(codec, w->reg, M98090_MIC_PA2EN_MASK,\r\nval << M98090_MIC_PA2EN_SHIFT);\r\nreturn 0;\r\n}\r\nstatic int max98090_shdn_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\nif (event & SND_SOC_DAPM_POST_PMU)\r\nmax98090->shdn_pending = true;\r\nreturn 0;\r\n}\r\nstatic int max98090_add_widgets(struct snd_soc_codec *codec)\r\n{\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nsnd_soc_add_codec_controls(codec, max98090_snd_controls,\r\nARRAY_SIZE(max98090_snd_controls));\r\nif (max98090->devtype == MAX98091) {\r\nsnd_soc_add_codec_controls(codec, max98091_snd_controls,\r\nARRAY_SIZE(max98091_snd_controls));\r\n}\r\nsnd_soc_dapm_new_controls(dapm, max98090_dapm_widgets,\r\nARRAY_SIZE(max98090_dapm_widgets));\r\nsnd_soc_dapm_add_routes(dapm, max98090_dapm_routes,\r\nARRAY_SIZE(max98090_dapm_routes));\r\nif (max98090->devtype == MAX98091) {\r\nsnd_soc_dapm_new_controls(dapm, max98091_dapm_widgets,\r\nARRAY_SIZE(max98091_dapm_widgets));\r\nsnd_soc_dapm_add_routes(dapm, max98091_dapm_routes,\r\nARRAY_SIZE(max98091_dapm_routes));\r\n}\r\nreturn 0;\r\n}\r\nstatic void max98090_configure_bclk(struct snd_soc_codec *codec)\r\n{\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\nunsigned long long ni;\r\nint i;\r\nif (!max98090->sysclk) {\r\ndev_err(codec->dev, "No SYSCLK configured\n");\r\nreturn;\r\n}\r\nif (!max98090->bclk || !max98090->lrclk) {\r\ndev_err(codec->dev, "No audio clocks configured\n");\r\nreturn;\r\n}\r\nif (!(snd_soc_read(codec, M98090_REG_MASTER_MODE) &\r\nM98090_MAS_MASK)) {\r\nreturn;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(pclk_rates); i++) {\r\nif ((pclk_rates[i] == max98090->sysclk) &&\r\n(lrclk_rates[i] == max98090->lrclk)) {\r\ndev_dbg(codec->dev,\r\n"Found supported PCLK to LRCLK rates 0x%x\n",\r\ni + 0x8);\r\nsnd_soc_update_bits(codec, M98090_REG_CLOCK_MODE,\r\nM98090_FREQ_MASK,\r\n(i + 0x8) << M98090_FREQ_SHIFT);\r\nsnd_soc_update_bits(codec, M98090_REG_CLOCK_MODE,\r\nM98090_USE_M1_MASK, 0);\r\nreturn;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(user_pclk_rates); i++) {\r\nif ((user_pclk_rates[i] == max98090->sysclk) &&\r\n(user_lrclk_rates[i] == max98090->lrclk)) {\r\ndev_dbg(codec->dev,\r\n"Found user supported PCLK to LRCLK rates\n");\r\ndev_dbg(codec->dev, "i %d ni %lld mi %lld\n",\r\ni, ni_value[i], mi_value[i]);\r\nsnd_soc_update_bits(codec, M98090_REG_CLOCK_MODE,\r\nM98090_FREQ_MASK, 0);\r\nsnd_soc_update_bits(codec, M98090_REG_CLOCK_MODE,\r\nM98090_USE_M1_MASK,\r\n1 << M98090_USE_M1_SHIFT);\r\nsnd_soc_write(codec, M98090_REG_CLOCK_RATIO_NI_MSB,\r\n(ni_value[i] >> 8) & 0x7F);\r\nsnd_soc_write(codec, M98090_REG_CLOCK_RATIO_NI_LSB,\r\nni_value[i] & 0xFF);\r\nsnd_soc_write(codec, M98090_REG_CLOCK_RATIO_MI_MSB,\r\n(mi_value[i] >> 8) & 0x7F);\r\nsnd_soc_write(codec, M98090_REG_CLOCK_RATIO_MI_LSB,\r\nmi_value[i] & 0xFF);\r\nreturn;\r\n}\r\n}\r\nsnd_soc_update_bits(codec, M98090_REG_CLOCK_MODE,\r\nM98090_FREQ_MASK, 0);\r\nsnd_soc_update_bits(codec, M98090_REG_CLOCK_MODE,\r\nM98090_USE_M1_MASK, 0);\r\nni = 65536ULL * (max98090->lrclk < 50000 ? 96ULL : 48ULL)\r\n* (unsigned long long int)max98090->lrclk;\r\ndo_div(ni, (unsigned long long int)max98090->sysclk);\r\ndev_info(codec->dev, "No better method found\n");\r\ndev_info(codec->dev, "Calculating ni %lld with mi 65536\n", ni);\r\nsnd_soc_write(codec, M98090_REG_CLOCK_RATIO_NI_MSB,\r\n(ni >> 8) & 0x7F);\r\nsnd_soc_write(codec, M98090_REG_CLOCK_RATIO_NI_LSB, ni & 0xFF);\r\n}\r\nstatic int max98090_dai_set_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98090_cdata *cdata;\r\nu8 regval;\r\nmax98090->dai_fmt = fmt;\r\ncdata = &max98090->dai[0];\r\nif (fmt != cdata->fmt) {\r\ncdata->fmt = fmt;\r\nregval = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nsnd_soc_write(codec,\r\nM98090_REG_CLOCK_RATIO_NI_MSB, 0x00);\r\nsnd_soc_write(codec,\r\nM98090_REG_CLOCK_RATIO_NI_LSB, 0x00);\r\nsnd_soc_update_bits(codec, M98090_REG_CLOCK_MODE,\r\nM98090_USE_M1_MASK, 0);\r\nmax98090->master = false;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nif (max98090->tdm_slots == 4) {\r\nregval |= M98090_MAS_MASK |\r\nM98090_BSEL_64;\r\n} else if (max98090->tdm_slots == 3) {\r\nregval |= M98090_MAS_MASK |\r\nM98090_BSEL_48;\r\n} else {\r\nregval |= M98090_MAS_MASK |\r\nM98090_BSEL_32;\r\n}\r\nmax98090->master = true;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\ndefault:\r\ndev_err(codec->dev, "DAI clock mode unsupported");\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, M98090_REG_MASTER_MODE, regval);\r\nregval = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nregval |= M98090_DLY_MASK;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nregval |= M98090_RJ_MASK;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\ndefault:\r\ndev_err(codec->dev, "DAI format unsupported");\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nregval |= M98090_WCI_MASK;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nregval |= M98090_BCI_MASK;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nregval |= M98090_BCI_MASK|M98090_WCI_MASK;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "DAI invert mode unsupported");\r\nreturn -EINVAL;\r\n}\r\nif (max98090->tdm_slots > 1)\r\nregval ^= M98090_BCI_MASK;\r\nsnd_soc_write(codec,\r\nM98090_REG_INTERFACE_FORMAT, regval);\r\n}\r\nreturn 0;\r\n}\r\nstatic int max98090_set_tdm_slot(struct snd_soc_dai *codec_dai,\r\nunsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98090_cdata *cdata;\r\ncdata = &max98090->dai[0];\r\nif (slots < 0 || slots > 4)\r\nreturn -EINVAL;\r\nmax98090->tdm_slots = slots;\r\nmax98090->tdm_width = slot_width;\r\nif (max98090->tdm_slots > 1) {\r\nsnd_soc_write(codec, M98090_REG_TDM_FORMAT,\r\n0 << M98090_TDM_SLOTL_SHIFT |\r\n1 << M98090_TDM_SLOTR_SHIFT |\r\n0 << M98090_TDM_SLOTDLY_SHIFT);\r\nsnd_soc_update_bits(codec, M98090_REG_TDM_CONTROL,\r\nM98090_TDM_MASK,\r\nM98090_TDM_MASK);\r\n}\r\ncdata->fmt = 0;\r\nmax98090_dai_set_fmt(codec_dai, max98090->dai_fmt);\r\nreturn 0;\r\n}\r\nstatic int max98090_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nif (IS_ERR(max98090->mclk))\r\nbreak;\r\nif (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_ON) {\r\nclk_disable_unprepare(max98090->mclk);\r\n} else {\r\nret = clk_prepare_enable(max98090->mclk);\r\nif (ret)\r\nreturn ret;\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {\r\nret = regcache_sync(max98090->regmap);\r\nif (ret != 0) {\r\ndev_err(codec->dev,\r\n"Failed to sync cache: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_update_bits(codec, M98090_REG_JACK_DETECT,\r\nM98090_JDWK_MASK, M98090_JDWK_MASK);\r\nregcache_mark_dirty(max98090->regmap);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max98090_find_divisor(int target_freq, int pclk)\r\n{\r\nint current_diff = INT_MAX;\r\nint test_diff = INT_MAX;\r\nint divisor_index = 0;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(dmic_divisors); i++) {\r\ntest_diff = abs(target_freq - (pclk / dmic_divisors[i]));\r\nif (test_diff < current_diff) {\r\ncurrent_diff = test_diff;\r\ndivisor_index = i;\r\n}\r\n}\r\nreturn divisor_index;\r\n}\r\nstatic int max98090_find_closest_pclk(int pclk)\r\n{\r\nint m1;\r\nint m2;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(dmic_table); i++) {\r\nif (pclk == dmic_table[i].pclk)\r\nreturn i;\r\nif (pclk < dmic_table[i].pclk) {\r\nif (i == 0)\r\nreturn i;\r\nm1 = pclk - dmic_table[i-1].pclk;\r\nm2 = dmic_table[i].pclk - pclk;\r\nif (m1 < m2)\r\nreturn i - 1;\r\nelse\r\nreturn i;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int max98090_configure_dmic(struct max98090_priv *max98090,\r\nint target_dmic_clk, int pclk, int fs)\r\n{\r\nint micclk_index;\r\nint pclk_index;\r\nint dmic_freq;\r\nint dmic_comp;\r\nint i;\r\npclk_index = max98090_find_closest_pclk(pclk);\r\nif (pclk_index < 0)\r\nreturn pclk_index;\r\nmicclk_index = max98090_find_divisor(target_dmic_clk, pclk);\r\nfor (i = 0; i < ARRAY_SIZE(comp_lrclk_rates) - 1; i++) {\r\nif (fs <= (comp_lrclk_rates[i] + comp_lrclk_rates[i+1]) / 2)\r\nbreak;\r\n}\r\ndmic_freq = dmic_table[pclk_index].settings[micclk_index].freq;\r\ndmic_comp = dmic_table[pclk_index].settings[micclk_index].comp[i];\r\nregmap_update_bits(max98090->regmap, M98090_REG_DIGITAL_MIC_ENABLE,\r\nM98090_MICCLK_MASK,\r\nmicclk_index << M98090_MICCLK_SHIFT);\r\nregmap_update_bits(max98090->regmap, M98090_REG_DIGITAL_MIC_CONFIG,\r\nM98090_DMIC_COMP_MASK | M98090_DMIC_FREQ_MASK,\r\ndmic_comp << M98090_DMIC_COMP_SHIFT |\r\ndmic_freq << M98090_DMIC_FREQ_SHIFT);\r\nreturn 0;\r\n}\r\nstatic int max98090_dai_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98090_cdata *cdata;\r\ncdata = &max98090->dai[0];\r\nmax98090->bclk = snd_soc_params_to_bclk(params);\r\nif (params_channels(params) == 1)\r\nmax98090->bclk *= 2;\r\nmax98090->lrclk = params_rate(params);\r\nswitch (params_width(params)) {\r\ncase 16:\r\nsnd_soc_update_bits(codec, M98090_REG_INTERFACE_FORMAT,\r\nM98090_WS_MASK, 0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (max98090->master)\r\nmax98090_configure_bclk(codec);\r\ncdata->rate = max98090->lrclk;\r\nif (max98090->lrclk < 24000)\r\nsnd_soc_update_bits(codec, M98090_REG_FILTER_CONFIG,\r\nM98090_MODE_MASK, 0);\r\nelse\r\nsnd_soc_update_bits(codec, M98090_REG_FILTER_CONFIG,\r\nM98090_MODE_MASK, M98090_MODE_MASK);\r\nif (max98090->lrclk < 50000)\r\nsnd_soc_update_bits(codec, M98090_REG_FILTER_CONFIG,\r\nM98090_DHF_MASK, 0);\r\nelse\r\nsnd_soc_update_bits(codec, M98090_REG_FILTER_CONFIG,\r\nM98090_DHF_MASK, M98090_DHF_MASK);\r\nmax98090_configure_dmic(max98090, max98090->dmic_freq, max98090->pclk,\r\nmax98090->lrclk);\r\nreturn 0;\r\n}\r\nstatic int max98090_dai_set_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\nif (freq == max98090->sysclk)\r\nreturn 0;\r\nif (!IS_ERR(max98090->mclk)) {\r\nfreq = clk_round_rate(max98090->mclk, freq);\r\nclk_set_rate(max98090->mclk, freq);\r\n}\r\nif ((freq >= 10000000) && (freq <= 20000000)) {\r\nsnd_soc_write(codec, M98090_REG_SYSTEM_CLOCK,\r\nM98090_PSCLK_DIV1);\r\nmax98090->pclk = freq;\r\n} else if ((freq > 20000000) && (freq <= 40000000)) {\r\nsnd_soc_write(codec, M98090_REG_SYSTEM_CLOCK,\r\nM98090_PSCLK_DIV2);\r\nmax98090->pclk = freq >> 1;\r\n} else if ((freq > 40000000) && (freq <= 60000000)) {\r\nsnd_soc_write(codec, M98090_REG_SYSTEM_CLOCK,\r\nM98090_PSCLK_DIV4);\r\nmax98090->pclk = freq >> 2;\r\n} else {\r\ndev_err(codec->dev, "Invalid master clock frequency\n");\r\nreturn -EINVAL;\r\n}\r\nmax98090->sysclk = freq;\r\nreturn 0;\r\n}\r\nstatic int max98090_dai_digital_mute(struct snd_soc_dai *codec_dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nint regval;\r\nregval = mute ? M98090_DVM_MASK : 0;\r\nsnd_soc_update_bits(codec, M98090_REG_DAI_PLAYBACK_LEVEL,\r\nM98090_DVM_MASK, regval);\r\nreturn 0;\r\n}\r\nstatic int max98090_dai_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif (!max98090->master && dai->active == 1)\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&max98090->pll_det_enable_work,\r\nmsecs_to_jiffies(10));\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nif (!max98090->master && dai->active == 1)\r\nschedule_work(&max98090->pll_det_disable_work);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void max98090_pll_det_enable_work(struct work_struct *work)\r\n{\r\nstruct max98090_priv *max98090 =\r\ncontainer_of(work, struct max98090_priv,\r\npll_det_enable_work.work);\r\nstruct snd_soc_codec *codec = max98090->codec;\r\nunsigned int status, mask;\r\nregmap_read(max98090->regmap, M98090_REG_DEVICE_STATUS, &status);\r\nregmap_read(max98090->regmap, M98090_REG_INTERRUPT_S, &mask);\r\nstatus &= mask;\r\nif (status & M98090_JDET_MASK)\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&max98090->jack_work,\r\nmsecs_to_jiffies(100));\r\nsnd_soc_update_bits(codec, M98090_REG_INTERRUPT_S,\r\nM98090_IULK_MASK,\r\n1 << M98090_IULK_SHIFT);\r\n}\r\nstatic void max98090_pll_det_disable_work(struct work_struct *work)\r\n{\r\nstruct max98090_priv *max98090 =\r\ncontainer_of(work, struct max98090_priv, pll_det_disable_work);\r\nstruct snd_soc_codec *codec = max98090->codec;\r\ncancel_delayed_work_sync(&max98090->pll_det_enable_work);\r\nsnd_soc_update_bits(codec, M98090_REG_INTERRUPT_S,\r\nM98090_IULK_MASK, 0);\r\n}\r\nstatic void max98090_pll_work(struct work_struct *work)\r\n{\r\nstruct max98090_priv *max98090 =\r\ncontainer_of(work, struct max98090_priv, pll_work);\r\nstruct snd_soc_codec *codec = max98090->codec;\r\nif (!snd_soc_codec_is_active(codec))\r\nreturn;\r\ndev_info(codec->dev, "PLL unlocked\n");\r\nsnd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,\r\nM98090_SHDNN_MASK, 0);\r\nmsleep(10);\r\nsnd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,\r\nM98090_SHDNN_MASK, M98090_SHDNN_MASK);\r\nmsleep(10);\r\n}\r\nstatic void max98090_jack_work(struct work_struct *work)\r\n{\r\nstruct max98090_priv *max98090 = container_of(work,\r\nstruct max98090_priv,\r\njack_work.work);\r\nstruct snd_soc_codec *codec = max98090->codec;\r\nint status = 0;\r\nint reg;\r\nif (max98090->jack_state == M98090_JACK_STATE_NO_HEADSET) {\r\nsnd_soc_update_bits(codec, M98090_REG_JACK_DETECT,\r\nM98090_JDWK_MASK, 0);\r\nmsleep(50);\r\nreg = snd_soc_read(codec, M98090_REG_JACK_STATUS);\r\nsnd_soc_update_bits(codec, M98090_REG_JACK_DETECT,\r\nM98090_JDWK_MASK, M98090_JDWK_MASK);\r\n} else {\r\nreg = snd_soc_read(codec, M98090_REG_JACK_STATUS);\r\n}\r\nreg = snd_soc_read(codec, M98090_REG_JACK_STATUS);\r\nswitch (reg & (M98090_LSNS_MASK | M98090_JKSNS_MASK)) {\r\ncase M98090_LSNS_MASK | M98090_JKSNS_MASK:\r\ndev_dbg(codec->dev, "No Headset Detected\n");\r\nmax98090->jack_state = M98090_JACK_STATE_NO_HEADSET;\r\nstatus |= 0;\r\nbreak;\r\ncase 0:\r\nif (max98090->jack_state ==\r\nM98090_JACK_STATE_HEADSET) {\r\ndev_dbg(codec->dev,\r\n"Headset Button Down Detected\n");\r\nstatus |= SND_JACK_HEADSET;\r\nstatus |= SND_JACK_BTN_0;\r\nbreak;\r\n}\r\ndev_dbg(codec->dev, "Headphone Detected\n");\r\nmax98090->jack_state = M98090_JACK_STATE_HEADPHONE;\r\nstatus |= SND_JACK_HEADPHONE;\r\nbreak;\r\ncase M98090_JKSNS_MASK:\r\ndev_dbg(codec->dev, "Headset Detected\n");\r\nmax98090->jack_state = M98090_JACK_STATE_HEADSET;\r\nstatus |= SND_JACK_HEADSET;\r\nbreak;\r\ndefault:\r\ndev_dbg(codec->dev, "Unrecognized Jack Status\n");\r\nbreak;\r\n}\r\nsnd_soc_jack_report(max98090->jack, status,\r\nSND_JACK_HEADSET | SND_JACK_BTN_0);\r\n}\r\nstatic irqreturn_t max98090_interrupt(int irq, void *data)\r\n{\r\nstruct max98090_priv *max98090 = data;\r\nstruct snd_soc_codec *codec = max98090->codec;\r\nint ret;\r\nunsigned int mask;\r\nunsigned int active;\r\nif (codec == NULL)\r\nreturn IRQ_NONE;\r\ndev_dbg(codec->dev, "***** max98090_interrupt *****\n");\r\nret = regmap_read(max98090->regmap, M98090_REG_INTERRUPT_S, &mask);\r\nif (ret != 0) {\r\ndev_err(codec->dev,\r\n"failed to read M98090_REG_INTERRUPT_S: %d\n",\r\nret);\r\nreturn IRQ_NONE;\r\n}\r\nret = regmap_read(max98090->regmap, M98090_REG_DEVICE_STATUS, &active);\r\nif (ret != 0) {\r\ndev_err(codec->dev,\r\n"failed to read M98090_REG_DEVICE_STATUS: %d\n",\r\nret);\r\nreturn IRQ_NONE;\r\n}\r\ndev_dbg(codec->dev, "active=0x%02x mask=0x%02x -> active=0x%02x\n",\r\nactive, mask, active & mask);\r\nactive &= mask;\r\nif (!active)\r\nreturn IRQ_NONE;\r\nif (active & M98090_CLD_MASK)\r\ndev_err(codec->dev, "M98090_CLD_MASK\n");\r\nif (active & M98090_SLD_MASK)\r\ndev_dbg(codec->dev, "M98090_SLD_MASK\n");\r\nif (active & M98090_ULK_MASK) {\r\ndev_dbg(codec->dev, "M98090_ULK_MASK\n");\r\nschedule_work(&max98090->pll_work);\r\n}\r\nif (active & M98090_JDET_MASK) {\r\ndev_dbg(codec->dev, "M98090_JDET_MASK\n");\r\npm_wakeup_event(codec->dev, 100);\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&max98090->jack_work,\r\nmsecs_to_jiffies(100));\r\n}\r\nif (active & M98090_DRCACT_MASK)\r\ndev_dbg(codec->dev, "M98090_DRCACT_MASK\n");\r\nif (active & M98090_DRCCLP_MASK)\r\ndev_err(codec->dev, "M98090_DRCCLP_MASK\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nint max98090_mic_detect(struct snd_soc_codec *codec,\r\nstruct snd_soc_jack *jack)\r\n{\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\ndev_dbg(codec->dev, "max98090_mic_detect\n");\r\nmax98090->jack = jack;\r\nif (jack) {\r\nsnd_soc_update_bits(codec, M98090_REG_INTERRUPT_S,\r\nM98090_IJDET_MASK,\r\n1 << M98090_IJDET_SHIFT);\r\n} else {\r\nsnd_soc_update_bits(codec, M98090_REG_INTERRUPT_S,\r\nM98090_IJDET_MASK,\r\n0);\r\n}\r\nsnd_soc_jack_report(max98090->jack, 0,\r\nSND_JACK_HEADSET | SND_JACK_BTN_0);\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&max98090->jack_work,\r\nmsecs_to_jiffies(100));\r\nreturn 0;\r\n}\r\nstatic int max98090_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98090_cdata *cdata;\r\nenum max98090_type devtype;\r\nint ret = 0;\r\nint err;\r\nunsigned int micbias;\r\ndev_dbg(codec->dev, "max98090_probe\n");\r\nmax98090->mclk = devm_clk_get(codec->dev, "mclk");\r\nif (PTR_ERR(max98090->mclk) == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\nmax98090->codec = codec;\r\nmax98090_reset(max98090);\r\nmax98090->sysclk = (unsigned)-1;\r\nmax98090->pclk = (unsigned)-1;\r\nmax98090->master = false;\r\ncdata = &max98090->dai[0];\r\ncdata->rate = (unsigned)-1;\r\ncdata->fmt = (unsigned)-1;\r\nmax98090->lin_state = 0;\r\nmax98090->pa1en = 0;\r\nmax98090->pa2en = 0;\r\nret = snd_soc_read(codec, M98090_REG_REVISION_ID);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to read device revision: %d\n",\r\nret);\r\ngoto err_access;\r\n}\r\nif ((ret >= M98090_REVA) && (ret <= M98090_REVA + 0x0f)) {\r\ndevtype = MAX98090;\r\ndev_info(codec->dev, "MAX98090 REVID=0x%02x\n", ret);\r\n} else if ((ret >= M98091_REVA) && (ret <= M98091_REVA + 0x0f)) {\r\ndevtype = MAX98091;\r\ndev_info(codec->dev, "MAX98091 REVID=0x%02x\n", ret);\r\n} else {\r\ndevtype = MAX98090;\r\ndev_err(codec->dev, "Unrecognized revision 0x%02x\n", ret);\r\n}\r\nif (max98090->devtype != devtype) {\r\ndev_warn(codec->dev, "Mismatch in DT specified CODEC type.\n");\r\nmax98090->devtype = devtype;\r\n}\r\nmax98090->jack_state = M98090_JACK_STATE_NO_HEADSET;\r\nINIT_DELAYED_WORK(&max98090->jack_work, max98090_jack_work);\r\nINIT_DELAYED_WORK(&max98090->pll_det_enable_work,\r\nmax98090_pll_det_enable_work);\r\nINIT_WORK(&max98090->pll_det_disable_work,\r\nmax98090_pll_det_disable_work);\r\nINIT_WORK(&max98090->pll_work, max98090_pll_work);\r\nsnd_soc_write(codec, M98090_REG_JACK_DETECT,\r\nM98090_JDETEN_MASK | M98090_JDEB_25MS);\r\nsnd_soc_read(codec, M98090_REG_DEVICE_STATUS);\r\nsnd_soc_update_bits(codec, M98090_REG_DAC_CONTROL,\r\nM98090_DACHP_MASK,\r\n1 << M98090_DACHP_SHIFT);\r\nsnd_soc_update_bits(codec, M98090_REG_DAC_CONTROL,\r\nM98090_PERFMODE_MASK,\r\n0 << M98090_PERFMODE_SHIFT);\r\nsnd_soc_update_bits(codec, M98090_REG_ADC_CONTROL,\r\nM98090_ADCHP_MASK,\r\n1 << M98090_ADCHP_SHIFT);\r\nsnd_soc_write(codec, M98090_REG_BIAS_CONTROL,\r\nM98090_VCM_MODE_MASK);\r\nerr = device_property_read_u32(codec->dev, "maxim,micbias", &micbias);\r\nif (err) {\r\nmicbias = M98090_MBVSEL_2V8;\r\ndev_info(codec->dev, "use default 2.8v micbias\n");\r\n} else if (micbias > M98090_MBVSEL_2V8) {\r\ndev_err(codec->dev, "micbias out of range 0x%x\n", micbias);\r\nmicbias = M98090_MBVSEL_2V8;\r\n}\r\nsnd_soc_update_bits(codec, M98090_REG_MIC_BIAS_VOLTAGE,\r\nM98090_MBVSEL_MASK, micbias);\r\nmax98090_add_widgets(codec);\r\nerr_access:\r\nreturn ret;\r\n}\r\nstatic int max98090_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\ncancel_delayed_work_sync(&max98090->jack_work);\r\ncancel_delayed_work_sync(&max98090->pll_det_enable_work);\r\ncancel_work_sync(&max98090->pll_det_disable_work);\r\ncancel_work_sync(&max98090->pll_work);\r\nmax98090->codec = NULL;\r\nreturn 0;\r\n}\r\nstatic void max98090_seq_notifier(struct snd_soc_dapm_context *dapm,\r\nenum snd_soc_dapm_type event, int subseq)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(dapm);\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\nif (max98090->shdn_pending) {\r\nsnd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,\r\nM98090_SHDNN_MASK, 0);\r\nmsleep(40);\r\nsnd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,\r\nM98090_SHDNN_MASK, M98090_SHDNN_MASK);\r\nmax98090->shdn_pending = false;\r\n}\r\n}\r\nstatic int max98090_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *i2c_id)\r\n{\r\nstruct max98090_priv *max98090;\r\nconst struct acpi_device_id *acpi_id;\r\nkernel_ulong_t driver_data = 0;\r\nint ret;\r\npr_debug("max98090_i2c_probe\n");\r\nmax98090 = devm_kzalloc(&i2c->dev, sizeof(struct max98090_priv),\r\nGFP_KERNEL);\r\nif (max98090 == NULL)\r\nreturn -ENOMEM;\r\nif (ACPI_HANDLE(&i2c->dev)) {\r\nacpi_id = acpi_match_device(i2c->dev.driver->acpi_match_table,\r\n&i2c->dev);\r\nif (!acpi_id) {\r\ndev_err(&i2c->dev, "No driver data\n");\r\nreturn -EINVAL;\r\n}\r\ndriver_data = acpi_id->driver_data;\r\n} else if (i2c_id) {\r\ndriver_data = i2c_id->driver_data;\r\n}\r\nmax98090->devtype = driver_data;\r\ni2c_set_clientdata(i2c, max98090);\r\nmax98090->pdata = i2c->dev.platform_data;\r\nret = of_property_read_u32(i2c->dev.of_node, "maxim,dmic-freq",\r\n&max98090->dmic_freq);\r\nif (ret < 0)\r\nmax98090->dmic_freq = MAX98090_DEFAULT_DMIC_FREQ;\r\nmax98090->regmap = devm_regmap_init_i2c(i2c, &max98090_regmap);\r\nif (IS_ERR(max98090->regmap)) {\r\nret = PTR_ERR(max98090->regmap);\r\ndev_err(&i2c->dev, "Failed to allocate regmap: %d\n", ret);\r\ngoto err_enable;\r\n}\r\nret = devm_request_threaded_irq(&i2c->dev, i2c->irq, NULL,\r\nmax98090_interrupt, IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\n"max98090_interrupt", max98090);\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "request_irq failed: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_max98090, max98090_dai,\r\nARRAY_SIZE(max98090_dai));\r\nerr_enable:\r\nreturn ret;\r\n}\r\nstatic void max98090_i2c_shutdown(struct i2c_client *i2c)\r\n{\r\nstruct max98090_priv *max98090 = dev_get_drvdata(&i2c->dev);\r\nregmap_write(max98090->regmap,\r\nM98090_REG_LEVEL_CONTROL, M98090_VSENN_MASK);\r\nregmap_write(max98090->regmap,\r\nM98090_REG_DEVICE_SHUTDOWN, 0x00);\r\nmsleep(40);\r\n}\r\nstatic int max98090_i2c_remove(struct i2c_client *client)\r\n{\r\nmax98090_i2c_shutdown(client);\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}\r\nstatic int max98090_runtime_resume(struct device *dev)\r\n{\r\nstruct max98090_priv *max98090 = dev_get_drvdata(dev);\r\nregcache_cache_only(max98090->regmap, false);\r\nmax98090_reset(max98090);\r\nregcache_sync(max98090->regmap);\r\nreturn 0;\r\n}\r\nstatic int max98090_runtime_suspend(struct device *dev)\r\n{\r\nstruct max98090_priv *max98090 = dev_get_drvdata(dev);\r\nregcache_cache_only(max98090->regmap, true);\r\nreturn 0;\r\n}\r\nstatic int max98090_resume(struct device *dev)\r\n{\r\nstruct max98090_priv *max98090 = dev_get_drvdata(dev);\r\nunsigned int status;\r\nregcache_mark_dirty(max98090->regmap);\r\nmax98090_reset(max98090);\r\nregmap_read(max98090->regmap, M98090_REG_DEVICE_STATUS, &status);\r\nregcache_sync(max98090->regmap);\r\nreturn 0;\r\n}\r\nstatic int max98090_suspend(struct device *dev)\r\n{\r\nreturn 0;\r\n}
