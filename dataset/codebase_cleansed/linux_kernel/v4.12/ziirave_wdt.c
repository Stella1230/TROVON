static int ziirave_wdt_revision(struct i2c_client *client,\r\nstruct ziirave_wdt_rev *rev, u8 command)\r\n{\r\nint ret;\r\nret = i2c_smbus_read_byte_data(client, command);\r\nif (ret < 0)\r\nreturn ret;\r\nrev->major = ret;\r\nret = i2c_smbus_read_byte_data(client, command + 1);\r\nif (ret < 0)\r\nreturn ret;\r\nrev->minor = ret;\r\nreturn 0;\r\n}\r\nstatic int ziirave_wdt_set_state(struct watchdog_device *wdd, int state)\r\n{\r\nstruct i2c_client *client = to_i2c_client(wdd->parent);\r\nreturn i2c_smbus_write_byte_data(client, ZIIRAVE_WDT_STATE, state);\r\n}\r\nstatic int ziirave_wdt_start(struct watchdog_device *wdd)\r\n{\r\nreturn ziirave_wdt_set_state(wdd, ZIIRAVE_STATE_ON);\r\n}\r\nstatic int ziirave_wdt_stop(struct watchdog_device *wdd)\r\n{\r\nreturn ziirave_wdt_set_state(wdd, ZIIRAVE_STATE_OFF);\r\n}\r\nstatic int ziirave_wdt_ping(struct watchdog_device *wdd)\r\n{\r\nstruct i2c_client *client = to_i2c_client(wdd->parent);\r\nreturn i2c_smbus_write_byte_data(client, ZIIRAVE_WDT_PING,\r\nZIIRAVE_PING_VALUE);\r\n}\r\nstatic int ziirave_wdt_set_timeout(struct watchdog_device *wdd,\r\nunsigned int timeout)\r\n{\r\nstruct i2c_client *client = to_i2c_client(wdd->parent);\r\nint ret;\r\nret = i2c_smbus_write_byte_data(client, ZIIRAVE_WDT_TIMEOUT, timeout);\r\nif (!ret)\r\nwdd->timeout = timeout;\r\nreturn ret;\r\n}\r\nstatic unsigned int ziirave_wdt_get_timeleft(struct watchdog_device *wdd)\r\n{\r\nstruct i2c_client *client = to_i2c_client(wdd->parent);\r\nint ret;\r\nret = i2c_smbus_read_byte_data(client, ZIIRAVE_WDT_TIME_LEFT);\r\nif (ret < 0)\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic int ziirave_firm_wait_for_ack(struct watchdog_device *wdd)\r\n{\r\nstruct i2c_client *client = to_i2c_client(wdd->parent);\r\nint ret;\r\nunsigned long timeout;\r\ntimeout = jiffies + msecs_to_jiffies(ZIIRAVE_FIRM_WAIT_FOR_ACK_TIMEOUT);\r\ndo {\r\nif (time_after(jiffies, timeout))\r\nreturn -ETIMEDOUT;\r\nusleep_range(5000, 10000);\r\nret = i2c_smbus_read_byte(client);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Failed to read byte\n");\r\nreturn ret;\r\n}\r\n} while (ret == ZIIRAVE_FIRM_DOWNLOAD_BUSY);\r\nreturn ret == ZIIRAVE_FIRM_DOWNLOAD_ACK ? 0 : -EIO;\r\n}\r\nstatic int ziirave_firm_set_read_addr(struct watchdog_device *wdd, u16 addr)\r\n{\r\nstruct i2c_client *client = to_i2c_client(wdd->parent);\r\nu8 address[2];\r\naddress[0] = addr & 0xff;\r\naddress[1] = (addr >> 8) & 0xff;\r\nreturn i2c_smbus_write_block_data(client,\r\nZIIRAVE_CMD_DOWNLOAD_SET_READ_ADDR,\r\nARRAY_SIZE(address), address);\r\n}\r\nstatic int ziirave_firm_write_block_data(struct watchdog_device *wdd,\r\nu8 command, u8 length, const u8 *data,\r\nbool wait_for_ack)\r\n{\r\nstruct i2c_client *client = to_i2c_client(wdd->parent);\r\nint ret;\r\nret = i2c_smbus_write_block_data(client, command, length, data);\r\nif (ret) {\r\ndev_err(&client->dev,\r\n"Failed to send command 0x%02x: %d\n", command, ret);\r\nreturn ret;\r\n}\r\nif (wait_for_ack)\r\nret = ziirave_firm_wait_for_ack(wdd);\r\nreturn ret;\r\n}\r\nstatic int ziirave_firm_write_byte(struct watchdog_device *wdd, u8 command,\r\nu8 byte, bool wait_for_ack)\r\n{\r\nreturn ziirave_firm_write_block_data(wdd, command, 1, &byte,\r\nwait_for_ack);\r\n}\r\nstatic int ziirave_firm_write_pkt(struct watchdog_device *wdd,\r\nconst struct ihex_binrec *rec)\r\n{\r\nstruct i2c_client *client = to_i2c_client(wdd->parent);\r\nu8 i, checksum = 0, packet[ZIIRAVE_FIRM_PKT_TOTAL_SIZE];\r\nint ret;\r\nu16 addr;\r\nmemset(packet, 0, ARRAY_SIZE(packet));\r\npacket[0] = (u8)be16_to_cpu(rec->len);\r\naddr = (be32_to_cpu(rec->addr) & 0xffff) >> 1;\r\npacket[1] = addr & 0xff;\r\npacket[2] = (addr & 0xff00) >> 8;\r\nif (be16_to_cpu(rec->len) > ZIIRAVE_FIRM_PKT_DATA_SIZE)\r\nreturn -EMSGSIZE;\r\nmemcpy(packet + 3, rec->data, be16_to_cpu(rec->len));\r\nfor (i = 0; i < ZIIRAVE_FIRM_PKT_TOTAL_SIZE - 1; i++)\r\nchecksum += packet[i];\r\npacket[ZIIRAVE_FIRM_PKT_TOTAL_SIZE - 1] = checksum;\r\nret = ziirave_firm_write_block_data(wdd, ZIIRAVE_CMD_DOWNLOAD_PACKET,\r\nARRAY_SIZE(packet), packet, true);\r\nif (ret)\r\ndev_err(&client->dev,\r\n"Failed to write firmware packet at address 0x%04x: %d\n",\r\naddr, ret);\r\nreturn ret;\r\n}\r\nstatic int ziirave_firm_verify(struct watchdog_device *wdd,\r\nconst struct firmware *fw)\r\n{\r\nstruct i2c_client *client = to_i2c_client(wdd->parent);\r\nconst struct ihex_binrec *rec;\r\nint i, ret;\r\nu8 data[ZIIRAVE_FIRM_PKT_DATA_SIZE];\r\nu16 addr;\r\nfor (rec = (void *)fw->data; rec; rec = ihex_next_binrec(rec)) {\r\nif (!be16_to_cpu(rec->len))\r\nbreak;\r\naddr = (be32_to_cpu(rec->addr) & 0xffff) >> 1;\r\nif (addr < ZIIRAVE_FIRM_FLASH_MEMORY_START ||\r\naddr > ZIIRAVE_FIRM_FLASH_MEMORY_END)\r\ncontinue;\r\nret = ziirave_firm_set_read_addr(wdd, addr);\r\nif (ret) {\r\ndev_err(&client->dev,\r\n"Failed to send SET_READ_ADDR command: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(data); i++) {\r\nret = i2c_smbus_read_byte_data(client,\r\nZIIRAVE_CMD_DOWNLOAD_READ_BYTE);\r\nif (ret < 0) {\r\ndev_err(&client->dev,\r\n"Failed to READ DATA: %d\n", ret);\r\nreturn ret;\r\n}\r\ndata[i] = ret;\r\n}\r\nif (memcmp(data, rec->data, be16_to_cpu(rec->len))) {\r\ndev_err(&client->dev,\r\n"Firmware mismatch at address 0x%04x\n", addr);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ziirave_firm_upload(struct watchdog_device *wdd,\r\nconst struct firmware *fw)\r\n{\r\nstruct i2c_client *client = to_i2c_client(wdd->parent);\r\nint ret, words_till_page_break;\r\nconst struct ihex_binrec *rec;\r\nstruct ihex_binrec *rec_new;\r\nret = ziirave_firm_write_byte(wdd, ZIIRAVE_CMD_JUMP_TO_BOOTLOADER, 1,\r\nfalse);\r\nif (ret)\r\nreturn ret;\r\nmsleep(500);\r\nret = ziirave_firm_write_byte(wdd, ZIIRAVE_CMD_DOWNLOAD_START, 1, true);\r\nif (ret)\r\nreturn ret;\r\nmsleep(500);\r\nfor (rec = (void *)fw->data; rec; rec = ihex_next_binrec(rec)) {\r\nif (!be16_to_cpu(rec->len))\r\nbreak;\r\nif (be16_to_cpu(rec->len) > ZIIRAVE_FIRM_PKT_DATA_SIZE) {\r\ndev_err(&client->dev, "Firmware packet too long (%d)\n",\r\nbe16_to_cpu(rec->len));\r\nreturn -EMSGSIZE;\r\n}\r\nwords_till_page_break = (64 - ((be32_to_cpu(rec->addr) >> 1) &\r\n0x3f));\r\nif ((be16_to_cpu(rec->len) >> 1) > words_till_page_break) {\r\nrec_new = kzalloc(sizeof(struct ihex_binrec) +\r\n(words_till_page_break << 1),\r\nGFP_KERNEL);\r\nif (!rec_new)\r\nreturn -ENOMEM;\r\nrec_new->len = cpu_to_be16(words_till_page_break << 1);\r\nrec_new->addr = rec->addr;\r\nmemcpy(rec_new->data, rec->data,\r\nbe16_to_cpu(rec_new->len));\r\nret = ziirave_firm_write_pkt(wdd, rec_new);\r\nkfree(rec_new);\r\nif (ret)\r\nreturn ret;\r\nrec_new = kzalloc(sizeof(struct ihex_binrec) +\r\nbe16_to_cpu(rec->len) -\r\n(words_till_page_break << 1),\r\nGFP_KERNEL);\r\nif (!rec_new)\r\nreturn -ENOMEM;\r\nrec_new->len = rec->len -\r\ncpu_to_be16(words_till_page_break << 1);\r\nrec_new->addr = cpu_to_be32(be32_to_cpu(rec->addr) +\r\n(words_till_page_break << 1));\r\nmemcpy(rec_new->data,\r\nrec->data + (words_till_page_break << 1),\r\nbe16_to_cpu(rec_new->len));\r\nret = ziirave_firm_write_pkt(wdd, rec_new);\r\nkfree(rec_new);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nret = ziirave_firm_write_pkt(wdd, rec);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nrec_new = kzalloc(sizeof(struct ihex_binrec) + 1, GFP_KERNEL);\r\nif (!rec_new)\r\nreturn -ENOMEM;\r\nret = ziirave_firm_write_pkt(wdd, rec_new);\r\nkfree(rec_new);\r\nif (ret) {\r\ndev_err(&client->dev, "Failed to send EMPTY packet: %d\n", ret);\r\nreturn ret;\r\n}\r\nmsleep(20);\r\nret = ziirave_firm_verify(wdd, fw);\r\nif (ret) {\r\ndev_err(&client->dev,\r\n"Failed to verify firmware: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = ziirave_firm_write_byte(wdd, ZIIRAVE_CMD_DOWNLOAD_END, 1, false);\r\nif (ret)\r\nreturn ret;\r\nret = ziirave_firm_write_byte(wdd, ZIIRAVE_CMD_RESET_PROCESSOR, 1,\r\nfalse);\r\nif (ret)\r\nreturn ret;\r\nmsleep(500);\r\nreturn 0;\r\n}\r\nstatic ssize_t ziirave_wdt_sysfs_show_firm(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev->parent);\r\nstruct ziirave_wdt_data *w_priv = i2c_get_clientdata(client);\r\nint ret;\r\nret = mutex_lock_interruptible(&w_priv->sysfs_mutex);\r\nif (ret)\r\nreturn ret;\r\nret = sprintf(buf, "02.%02u.%02u", w_priv->firmware_rev.major,\r\nw_priv->firmware_rev.minor);\r\nmutex_unlock(&w_priv->sysfs_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t ziirave_wdt_sysfs_show_boot(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev->parent);\r\nstruct ziirave_wdt_data *w_priv = i2c_get_clientdata(client);\r\nint ret;\r\nret = mutex_lock_interruptible(&w_priv->sysfs_mutex);\r\nif (ret)\r\nreturn ret;\r\nret = sprintf(buf, "01.%02u.%02u", w_priv->bootloader_rev.major,\r\nw_priv->bootloader_rev.minor);\r\nmutex_unlock(&w_priv->sysfs_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t ziirave_wdt_sysfs_show_reason(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev->parent);\r\nstruct ziirave_wdt_data *w_priv = i2c_get_clientdata(client);\r\nint ret;\r\nret = mutex_lock_interruptible(&w_priv->sysfs_mutex);\r\nif (ret)\r\nreturn ret;\r\nret = sprintf(buf, "%s", ziirave_reasons[w_priv->reset_reason]);\r\nmutex_unlock(&w_priv->sysfs_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t ziirave_wdt_sysfs_store_firm(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev->parent);\r\nstruct ziirave_wdt_data *w_priv = i2c_get_clientdata(client);\r\nconst struct firmware *fw;\r\nint err;\r\nerr = request_ihex_firmware(&fw, ZIIRAVE_FW_NAME, dev);\r\nif (err) {\r\ndev_err(&client->dev, "Failed to request ihex firmware\n");\r\nreturn err;\r\n}\r\nerr = mutex_lock_interruptible(&w_priv->sysfs_mutex);\r\nif (err)\r\ngoto release_firmware;\r\nerr = ziirave_firm_upload(&w_priv->wdd, fw);\r\nif (err) {\r\ndev_err(&client->dev, "The firmware update failed: %d\n", err);\r\ngoto unlock_mutex;\r\n}\r\nerr = ziirave_wdt_revision(client, &w_priv->firmware_rev,\r\nZIIRAVE_WDT_FIRM_VER_MAJOR);\r\nif (err) {\r\ndev_err(&client->dev, "Failed to read firmware version: %d\n",\r\nerr);\r\ngoto unlock_mutex;\r\n}\r\ndev_info(&client->dev, "Firmware updated to version 02.%02u.%02u\n",\r\nw_priv->firmware_rev.major, w_priv->firmware_rev.minor);\r\nerr = ziirave_wdt_set_timeout(&w_priv->wdd, w_priv->wdd.timeout);\r\nif (err)\r\ndev_err(&client->dev, "Failed to set timeout: %d\n", err);\r\nunlock_mutex:\r\nmutex_unlock(&w_priv->sysfs_mutex);\r\nrelease_firmware:\r\nrelease_firmware(fw);\r\nreturn err ? err : count;\r\n}\r\nstatic int ziirave_wdt_init_duration(struct i2c_client *client)\r\n{\r\nint ret;\r\nif (!reset_duration) {\r\nif (!client->dev.of_node)\r\nret = -ENODEV;\r\nelse\r\nret = of_property_read_u32(client->dev.of_node,\r\n"reset-duration-ms",\r\n&reset_duration);\r\nif (ret) {\r\ndev_info(&client->dev,\r\n"Unable to set reset pulse duration, using default\n");\r\nreturn 0;\r\n}\r\n}\r\nif (reset_duration < 1 || reset_duration > 255)\r\nreturn -EINVAL;\r\ndev_info(&client->dev, "Setting reset duration to %dms",\r\nreset_duration);\r\nreturn i2c_smbus_write_byte_data(client, ZIIRAVE_WDT_RESET_DURATION,\r\nreset_duration);\r\n}\r\nstatic int ziirave_wdt_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret;\r\nstruct ziirave_wdt_data *w_priv;\r\nint val;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nw_priv = devm_kzalloc(&client->dev, sizeof(*w_priv), GFP_KERNEL);\r\nif (!w_priv)\r\nreturn -ENOMEM;\r\nmutex_init(&w_priv->sysfs_mutex);\r\nw_priv->wdd.info = &ziirave_wdt_info;\r\nw_priv->wdd.ops = &ziirave_wdt_ops;\r\nw_priv->wdd.min_timeout = ZIIRAVE_TIMEOUT_MIN;\r\nw_priv->wdd.max_timeout = ZIIRAVE_TIMEOUT_MAX;\r\nw_priv->wdd.parent = &client->dev;\r\nw_priv->wdd.groups = ziirave_wdt_groups;\r\nret = watchdog_init_timeout(&w_priv->wdd, wdt_timeout, &client->dev);\r\nif (ret) {\r\ndev_info(&client->dev,\r\n"Unable to select timeout value, using default\n");\r\n}\r\nif (w_priv->wdd.timeout == 0) {\r\nval = i2c_smbus_read_byte_data(client, ZIIRAVE_WDT_TIMEOUT);\r\nif (val < 0)\r\nreturn val;\r\nif (val < ZIIRAVE_TIMEOUT_MIN)\r\nreturn -ENODEV;\r\nw_priv->wdd.timeout = val;\r\n} else {\r\nret = ziirave_wdt_set_timeout(&w_priv->wdd,\r\nw_priv->wdd.timeout);\r\nif (ret)\r\nreturn ret;\r\ndev_info(&client->dev, "Timeout set to %ds.",\r\nw_priv->wdd.timeout);\r\n}\r\nwatchdog_set_nowayout(&w_priv->wdd, nowayout);\r\ni2c_set_clientdata(client, w_priv);\r\nval = i2c_smbus_read_byte_data(client, ZIIRAVE_WDT_STATE);\r\nif (val < 0)\r\nreturn val;\r\nif (val == ZIIRAVE_STATE_INITIAL)\r\nziirave_wdt_stop(&w_priv->wdd);\r\nret = ziirave_wdt_init_duration(client);\r\nif (ret)\r\nreturn ret;\r\nret = ziirave_wdt_revision(client, &w_priv->firmware_rev,\r\nZIIRAVE_WDT_FIRM_VER_MAJOR);\r\nif (ret)\r\nreturn ret;\r\nret = ziirave_wdt_revision(client, &w_priv->bootloader_rev,\r\nZIIRAVE_WDT_BOOT_VER_MAJOR);\r\nif (ret)\r\nreturn ret;\r\nw_priv->reset_reason = i2c_smbus_read_byte_data(client,\r\nZIIRAVE_WDT_RESET_REASON);\r\nif (w_priv->reset_reason < 0)\r\nreturn w_priv->reset_reason;\r\nif (w_priv->reset_reason >= ARRAY_SIZE(ziirave_reasons) ||\r\n!ziirave_reasons[w_priv->reset_reason])\r\nreturn -ENODEV;\r\nret = watchdog_register_device(&w_priv->wdd);\r\nreturn ret;\r\n}\r\nstatic int ziirave_wdt_remove(struct i2c_client *client)\r\n{\r\nstruct ziirave_wdt_data *w_priv = i2c_get_clientdata(client);\r\nwatchdog_unregister_device(&w_priv->wdd);\r\nreturn 0;\r\n}
