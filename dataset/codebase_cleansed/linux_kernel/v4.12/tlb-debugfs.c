static int tlb_seq_show(struct seq_file *file, void *iter)\r\n{\r\nunsigned int tlb_type = (unsigned int)file->private;\r\nunsigned long addr1, addr2, data1, data2;\r\nunsigned long flags;\r\nunsigned long mmucr;\r\nunsigned int nentries, entry;\r\nunsigned int urb;\r\nmmucr = __raw_readl(MMUCR);\r\nif ((mmucr & 0x1) == 0) {\r\nseq_printf(file, "address translation disabled\n");\r\nreturn 0;\r\n}\r\nif (tlb_type == TLB_TYPE_ITLB) {\r\naddr1 = MMU_ITLB_ADDRESS_ARRAY;\r\naddr2 = MMU_ITLB_ADDRESS_ARRAY2;\r\ndata1 = MMU_ITLB_DATA_ARRAY;\r\ndata2 = MMU_ITLB_DATA_ARRAY2;\r\nnentries = 4;\r\n} else {\r\naddr1 = MMU_UTLB_ADDRESS_ARRAY;\r\naddr2 = MMU_UTLB_ADDRESS_ARRAY2;\r\ndata1 = MMU_UTLB_DATA_ARRAY;\r\ndata2 = MMU_UTLB_DATA_ARRAY2;\r\nnentries = 64;\r\n}\r\nlocal_irq_save(flags);\r\njump_to_uncached();\r\nurb = (mmucr & MMUCR_URB) >> MMUCR_URB_SHIFT;\r\nif (urb == 0)\r\nurb = MMUCR_URB_NENTRIES + 1;\r\nif (tlb_type == TLB_TYPE_ITLB) {\r\naddr1 = MMU_ITLB_ADDRESS_ARRAY;\r\naddr2 = MMU_ITLB_ADDRESS_ARRAY2;\r\ndata1 = MMU_ITLB_DATA_ARRAY;\r\ndata2 = MMU_ITLB_DATA_ARRAY2;\r\nnentries = 4;\r\n} else {\r\naddr1 = MMU_UTLB_ADDRESS_ARRAY;\r\naddr2 = MMU_UTLB_ADDRESS_ARRAY2;\r\ndata1 = MMU_UTLB_DATA_ARRAY;\r\ndata2 = MMU_UTLB_DATA_ARRAY2;\r\nnentries = 64;\r\n}\r\nseq_printf(file, "entry: vpn ppn asid size valid wired\n");\r\nfor (entry = 0; entry < nentries; entry++) {\r\nunsigned long vpn, ppn, asid, size;\r\nunsigned long valid;\r\nunsigned long val;\r\nconst char *sz = " ?";\r\nint i;\r\nval = __raw_readl(addr1 | (entry << MMU_TLB_ENTRY_SHIFT));\r\nctrl_barrier();\r\nvpn = val & 0xfffffc00;\r\nvalid = val & 0x100;\r\nval = __raw_readl(addr2 | (entry << MMU_TLB_ENTRY_SHIFT));\r\nctrl_barrier();\r\nasid = val & MMU_CONTEXT_ASID_MASK;\r\nval = __raw_readl(data1 | (entry << MMU_TLB_ENTRY_SHIFT));\r\nctrl_barrier();\r\nppn = (val & 0x0ffffc00) << 4;\r\nval = __raw_readl(data2 | (entry << MMU_TLB_ENTRY_SHIFT));\r\nctrl_barrier();\r\nsize = (val & 0xf0) >> 4;\r\nfor (i = 0; i < ARRAY_SIZE(tlb_sizes); i++) {\r\nif (tlb_sizes[i].bits == size)\r\nbreak;\r\n}\r\nif (i != ARRAY_SIZE(tlb_sizes))\r\nsz = tlb_sizes[i].size;\r\nseq_printf(file, "%2d: 0x%08lx 0x%08lx %5lu %s %s %s\n",\r\nentry, vpn, ppn, asid,\r\nsz, valid ? "V" : "-",\r\n(urb <= entry) ? "W" : "-");\r\n}\r\nback_to_cached();\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic int tlb_debugfs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, tlb_seq_show, inode->i_private);\r\n}\r\nstatic int __init tlb_debugfs_init(void)\r\n{\r\nstruct dentry *itlb, *utlb;\r\nitlb = debugfs_create_file("itlb", S_IRUSR, arch_debugfs_dir,\r\n(unsigned int *)TLB_TYPE_ITLB,\r\n&tlb_debugfs_fops);\r\nif (unlikely(!itlb))\r\nreturn -ENOMEM;\r\nutlb = debugfs_create_file("utlb", S_IRUSR, arch_debugfs_dir,\r\n(unsigned int *)TLB_TYPE_UTLB,\r\n&tlb_debugfs_fops);\r\nif (unlikely(!utlb)) {\r\ndebugfs_remove(itlb);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}
