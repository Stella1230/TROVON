static unsigned long cdce925_pll_calculate_rate(unsigned long parent_rate,\r\nu16 n, u16 m)\r\n{\r\nif ((!m || !n) || (m == n))\r\nreturn parent_rate;\r\nreturn mult_frac(parent_rate, (unsigned long)n, (unsigned long)m);\r\n}\r\nstatic unsigned long cdce925_pll_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_cdce925_pll *data = to_clk_cdce925_pll(hw);\r\nreturn cdce925_pll_calculate_rate(parent_rate, data->n, data->m);\r\n}\r\nstatic void cdce925_pll_find_rate(unsigned long rate,\r\nunsigned long parent_rate, u16 *n, u16 *m)\r\n{\r\nunsigned long un;\r\nunsigned long um;\r\nunsigned long g;\r\nif (rate <= parent_rate) {\r\nrate = parent_rate;\r\n*n = 0;\r\n*m = 0;\r\n} else {\r\nif (rate < CDCE925_PLL_FREQUENCY_MIN)\r\nrate = CDCE925_PLL_FREQUENCY_MIN;\r\nelse if (rate > CDCE925_PLL_FREQUENCY_MAX)\r\nrate = CDCE925_PLL_FREQUENCY_MAX;\r\ng = gcd(rate, parent_rate);\r\num = parent_rate / g;\r\nun = rate / g;\r\nwhile ((un > 4095) || (um > 511)) {\r\nun >>= 1;\r\num >>= 1;\r\n}\r\nif (un == 0)\r\nun = 1;\r\nif (um == 0)\r\num = 1;\r\n*n = un;\r\n*m = um;\r\n}\r\n}\r\nstatic long cdce925_pll_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nu16 n, m;\r\ncdce925_pll_find_rate(rate, *parent_rate, &n, &m);\r\nreturn (long)cdce925_pll_calculate_rate(*parent_rate, n, m);\r\n}\r\nstatic int cdce925_pll_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_cdce925_pll *data = to_clk_cdce925_pll(hw);\r\nif (!rate || (rate == parent_rate)) {\r\ndata->m = 0;\r\ndata->n = 0;\r\nreturn 0;\r\n}\r\nif ((rate < CDCE925_PLL_FREQUENCY_MIN) ||\r\n(rate > CDCE925_PLL_FREQUENCY_MAX)) {\r\npr_debug("%s: rate %lu outside PLL range.\n", __func__, rate);\r\nreturn -EINVAL;\r\n}\r\nif (rate < parent_rate) {\r\npr_debug("%s: rate %lu less than parent rate %lu.\n", __func__,\r\nrate, parent_rate);\r\nreturn -EINVAL;\r\n}\r\ncdce925_pll_find_rate(rate, parent_rate, &data->n, &data->m);\r\nreturn 0;\r\n}\r\nstatic u8 cdce925_pll_calc_p(u16 n, u16 m)\r\n{\r\nu8 p;\r\nu16 r = n / m;\r\nif (r >= 16)\r\nreturn 0;\r\np = 4;\r\nwhile (r > 1) {\r\nr >>= 1;\r\n--p;\r\n}\r\nreturn p;\r\n}\r\nstatic u8 cdce925_pll_calc_range_bits(struct clk_hw *hw, u16 n, u16 m)\r\n{\r\nstruct clk *parent = clk_get_parent(hw->clk);\r\nunsigned long rate = clk_get_rate(parent);\r\nrate = mult_frac(rate, (unsigned long)n, (unsigned long)m);\r\nif (rate >= 175000000)\r\nreturn 0x3;\r\nif (rate >= 150000000)\r\nreturn 0x02;\r\nif (rate >= 125000000)\r\nreturn 0x01;\r\nreturn 0x00;\r\n}\r\nstatic int cdce925_pll_prepare(struct clk_hw *hw)\r\n{\r\nstruct clk_cdce925_pll *data = to_clk_cdce925_pll(hw);\r\nu16 n = data->n;\r\nu16 m = data->m;\r\nu16 r;\r\nu8 q;\r\nu8 p;\r\nu16 nn;\r\nu8 pll[4];\r\nu8 reg_ofs = data->index * CDCE925_OFFSET_PLL;\r\nunsigned i;\r\nif ((!m || !n) || (m == n)) {\r\nregmap_update_bits(data->chip->regmap,\r\nreg_ofs + CDCE925_PLL_MUX_OUTPUTS, 0x80, 0x80);\r\n} else {\r\np = cdce925_pll_calc_p(n, m);\r\nnn = n * BIT(p);\r\nq = nn / m;\r\nif ((q < 16) || (q > 63)) {\r\npr_debug("%s invalid q=%d\n", __func__, q);\r\nreturn -EINVAL;\r\n}\r\nr = nn - (m*q);\r\nif (r > 511) {\r\npr_debug("%s invalid r=%d\n", __func__, r);\r\nreturn -EINVAL;\r\n}\r\npr_debug("%s n=%d m=%d p=%d q=%d r=%d\n", __func__,\r\nn, m, p, q, r);\r\npll[0] = n >> 4;\r\npll[1] = ((n & 0x0F) << 4) | ((r >> 5) & 0x0F);\r\npll[2] = ((r & 0x1F) << 3) | ((q >> 3) & 0x07);\r\npll[3] = ((q & 0x07) << 5) | (p << 2) |\r\ncdce925_pll_calc_range_bits(hw, n, m);\r\nfor (i = 0; i < ARRAY_SIZE(pll); ++i)\r\nregmap_write(data->chip->regmap,\r\nreg_ofs + CDCE925_PLL_MULDIV + i, pll[i]);\r\nregmap_update_bits(data->chip->regmap,\r\nreg_ofs + CDCE925_PLL_MUX_OUTPUTS, 0x80, 0x00);\r\n}\r\nreturn 0;\r\n}\r\nstatic void cdce925_pll_unprepare(struct clk_hw *hw)\r\n{\r\nstruct clk_cdce925_pll *data = to_clk_cdce925_pll(hw);\r\nu8 reg_ofs = data->index * CDCE925_OFFSET_PLL;\r\nregmap_update_bits(data->chip->regmap,\r\nreg_ofs + CDCE925_PLL_MUX_OUTPUTS, 0x80, 0x80);\r\n}\r\nstatic void cdce925_clk_set_pdiv(struct clk_cdce925_output *data, u16 pdiv)\r\n{\r\nswitch (data->index) {\r\ncase 0:\r\nregmap_update_bits(data->chip->regmap,\r\nCDCE925_REG_Y1SPIPDIVH,\r\n0x03, (pdiv >> 8) & 0x03);\r\nregmap_write(data->chip->regmap, 0x03, pdiv & 0xFF);\r\nbreak;\r\ncase 1:\r\nregmap_update_bits(data->chip->regmap, 0x16, 0x7F, pdiv);\r\nbreak;\r\ncase 2:\r\nregmap_update_bits(data->chip->regmap, 0x17, 0x7F, pdiv);\r\nbreak;\r\ncase 3:\r\nregmap_update_bits(data->chip->regmap, 0x26, 0x7F, pdiv);\r\nbreak;\r\ncase 4:\r\nregmap_update_bits(data->chip->regmap, 0x27, 0x7F, pdiv);\r\nbreak;\r\ncase 5:\r\nregmap_update_bits(data->chip->regmap, 0x36, 0x7F, pdiv);\r\nbreak;\r\ncase 6:\r\nregmap_update_bits(data->chip->regmap, 0x37, 0x7F, pdiv);\r\nbreak;\r\ncase 7:\r\nregmap_update_bits(data->chip->regmap, 0x46, 0x7F, pdiv);\r\nbreak;\r\ncase 8:\r\nregmap_update_bits(data->chip->regmap, 0x47, 0x7F, pdiv);\r\nbreak;\r\n}\r\n}\r\nstatic void cdce925_clk_activate(struct clk_cdce925_output *data)\r\n{\r\nswitch (data->index) {\r\ncase 0:\r\nregmap_update_bits(data->chip->regmap,\r\nCDCE925_REG_Y1SPIPDIVH, 0x0c, 0x0c);\r\nbreak;\r\ncase 1:\r\ncase 2:\r\nregmap_update_bits(data->chip->regmap, 0x14, 0x03, 0x03);\r\nbreak;\r\ncase 3:\r\ncase 4:\r\nregmap_update_bits(data->chip->regmap, 0x24, 0x03, 0x03);\r\nbreak;\r\ncase 5:\r\ncase 6:\r\nregmap_update_bits(data->chip->regmap, 0x34, 0x03, 0x03);\r\nbreak;\r\ncase 7:\r\ncase 8:\r\nregmap_update_bits(data->chip->regmap, 0x44, 0x03, 0x03);\r\nbreak;\r\n}\r\n}\r\nstatic int cdce925_clk_prepare(struct clk_hw *hw)\r\n{\r\nstruct clk_cdce925_output *data = to_clk_cdce925_output(hw);\r\ncdce925_clk_set_pdiv(data, data->pdiv);\r\ncdce925_clk_activate(data);\r\nreturn 0;\r\n}\r\nstatic void cdce925_clk_unprepare(struct clk_hw *hw)\r\n{\r\nstruct clk_cdce925_output *data = to_clk_cdce925_output(hw);\r\ncdce925_clk_set_pdiv(data, 0);\r\n}\r\nstatic unsigned long cdce925_clk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_cdce925_output *data = to_clk_cdce925_output(hw);\r\nif (data->pdiv)\r\nreturn parent_rate / data->pdiv;\r\nreturn 0;\r\n}\r\nstatic u16 cdce925_calc_divider(unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nunsigned long divider;\r\nif (!rate)\r\nreturn 0;\r\nif (rate >= parent_rate)\r\nreturn 1;\r\ndivider = DIV_ROUND_CLOSEST(parent_rate, rate);\r\nif (divider > 0x7F)\r\ndivider = 0x7F;\r\nreturn (u16)divider;\r\n}\r\nstatic unsigned long cdce925_clk_best_parent_rate(\r\nstruct clk_hw *hw, unsigned long rate)\r\n{\r\nstruct clk *pll = clk_get_parent(hw->clk);\r\nstruct clk *root = clk_get_parent(pll);\r\nunsigned long root_rate = clk_get_rate(root);\r\nunsigned long best_rate_error = rate;\r\nu16 pdiv_min;\r\nu16 pdiv_max;\r\nu16 pdiv_best;\r\nu16 pdiv_now;\r\nif (root_rate % rate == 0)\r\nreturn root_rate;\r\npdiv_min = (u16)max(1ul, DIV_ROUND_UP(CDCE925_PLL_FREQUENCY_MIN, rate));\r\npdiv_max = (u16)min(127ul, CDCE925_PLL_FREQUENCY_MAX / rate);\r\nif (pdiv_min > pdiv_max)\r\nreturn 0;\r\npdiv_best = pdiv_min;\r\nfor (pdiv_now = pdiv_min; pdiv_now < pdiv_max; ++pdiv_now) {\r\nunsigned long target_rate = rate * pdiv_now;\r\nlong pll_rate = clk_round_rate(pll, target_rate);\r\nunsigned long actual_rate;\r\nunsigned long rate_error;\r\nif (pll_rate <= 0)\r\ncontinue;\r\nactual_rate = pll_rate / pdiv_now;\r\nrate_error = abs((long)actual_rate - (long)rate);\r\nif (rate_error < best_rate_error) {\r\npdiv_best = pdiv_now;\r\nbest_rate_error = rate_error;\r\n}\r\n}\r\nreturn rate * pdiv_best;\r\n}\r\nstatic long cdce925_clk_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nunsigned long l_parent_rate = *parent_rate;\r\nu16 divider = cdce925_calc_divider(rate, l_parent_rate);\r\nif (l_parent_rate / divider != rate) {\r\nl_parent_rate = cdce925_clk_best_parent_rate(hw, rate);\r\ndivider = cdce925_calc_divider(rate, l_parent_rate);\r\n*parent_rate = l_parent_rate;\r\n}\r\nif (divider)\r\nreturn (long)(l_parent_rate / divider);\r\nreturn 0;\r\n}\r\nstatic int cdce925_clk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_cdce925_output *data = to_clk_cdce925_output(hw);\r\ndata->pdiv = cdce925_calc_divider(rate, parent_rate);\r\nreturn 0;\r\n}\r\nstatic u16 cdce925_y1_calc_divider(unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nunsigned long divider;\r\nif (!rate)\r\nreturn 0;\r\nif (rate >= parent_rate)\r\nreturn 1;\r\ndivider = DIV_ROUND_CLOSEST(parent_rate, rate);\r\nif (divider > 0x3FF)\r\ndivider = 0x3FF;\r\nreturn (u16)divider;\r\n}\r\nstatic long cdce925_clk_y1_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nunsigned long l_parent_rate = *parent_rate;\r\nu16 divider = cdce925_y1_calc_divider(rate, l_parent_rate);\r\nif (divider)\r\nreturn (long)(l_parent_rate / divider);\r\nreturn 0;\r\n}\r\nstatic int cdce925_clk_y1_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_cdce925_output *data = to_clk_cdce925_output(hw);\r\ndata->pdiv = cdce925_y1_calc_divider(rate, parent_rate);\r\nreturn 0;\r\n}\r\nstatic int cdce925_regmap_i2c_write(\r\nvoid *context, const void *data, size_t count)\r\n{\r\nstruct device *dev = context;\r\nstruct i2c_client *i2c = to_i2c_client(dev);\r\nint ret;\r\nu8 reg_data[2];\r\nif (count != 2)\r\nreturn -ENOTSUPP;\r\nreg_data[0] = CDCE925_I2C_COMMAND_BYTE_TRANSFER | ((u8 *)data)[0];\r\nreg_data[1] = ((u8 *)data)[1];\r\ndev_dbg(&i2c->dev, "%s(%zu) %#x %#x\n", __func__, count,\r\nreg_data[0], reg_data[1]);\r\nret = i2c_master_send(i2c, reg_data, count);\r\nif (likely(ret == count))\r\nreturn 0;\r\nelse if (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn -EIO;\r\n}\r\nstatic int cdce925_regmap_i2c_read(void *context,\r\nconst void *reg, size_t reg_size, void *val, size_t val_size)\r\n{\r\nstruct device *dev = context;\r\nstruct i2c_client *i2c = to_i2c_client(dev);\r\nstruct i2c_msg xfer[2];\r\nint ret;\r\nu8 reg_data[2];\r\nif (reg_size != 1)\r\nreturn -ENOTSUPP;\r\nxfer[0].addr = i2c->addr;\r\nxfer[0].flags = 0;\r\nxfer[0].buf = reg_data;\r\nif (val_size == 1) {\r\nreg_data[0] =\r\nCDCE925_I2C_COMMAND_BYTE_TRANSFER | ((u8 *)reg)[0];\r\nxfer[0].len = 1;\r\n} else {\r\nreg_data[0] =\r\nCDCE925_I2C_COMMAND_BLOCK_TRANSFER | ((u8 *)reg)[0];\r\nreg_data[1] = val_size;\r\nxfer[0].len = 2;\r\n}\r\nxfer[1].addr = i2c->addr;\r\nxfer[1].flags = I2C_M_RD;\r\nxfer[1].len = val_size;\r\nxfer[1].buf = val;\r\nret = i2c_transfer(i2c->adapter, xfer, 2);\r\nif (likely(ret == 2)) {\r\ndev_dbg(&i2c->dev, "%s(%zu, %zu) %#x %#x\n", __func__,\r\nreg_size, val_size, reg_data[0], *((u8 *)val));\r\nreturn 0;\r\n} else if (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn -EIO;\r\n}\r\nstatic struct clk_hw *\r\nof_clk_cdce925_get(struct of_phandle_args *clkspec, void *_data)\r\n{\r\nstruct clk_cdce925_chip *data = _data;\r\nunsigned int idx = clkspec->args[0];\r\nif (idx >= ARRAY_SIZE(data->clk)) {\r\npr_err("%s: invalid index %u\n", __func__, idx);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nreturn &data->clk[idx].hw;\r\n}\r\nstatic int cdce925_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct clk_cdce925_chip *data;\r\nstruct device_node *node = client->dev.of_node;\r\nconst char *parent_name;\r\nconst char *pll_clk_name[MAX_NUMBER_OF_PLLS] = {NULL,};\r\nstruct clk_init_data init;\r\nu32 value;\r\nint i;\r\nint err;\r\nstruct device_node *np_output;\r\nchar child_name[6];\r\nstruct regmap_config config = {\r\n.name = "configuration0",\r\n.reg_bits = 8,\r\n.val_bits = 8,\r\n.cache_type = REGCACHE_RBTREE,\r\n};\r\ndev_dbg(&client->dev, "%s\n", __func__);\r\ndata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->i2c_client = client;\r\ndata->chip_info = &clk_cdce925_chip_info_tbl[id->driver_data];\r\nconfig.max_register = CDCE925_OFFSET_PLL +\r\ndata->chip_info->num_plls * 0x10 - 1;\r\ndata->regmap = devm_regmap_init(&client->dev, &regmap_cdce925_bus,\r\n&client->dev, &config);\r\nif (IS_ERR(data->regmap)) {\r\ndev_err(&client->dev, "failed to allocate register map\n");\r\nreturn PTR_ERR(data->regmap);\r\n}\r\ni2c_set_clientdata(client, data);\r\nparent_name = of_clk_get_parent_name(node, 0);\r\nif (!parent_name) {\r\ndev_err(&client->dev, "missing parent clock\n");\r\nreturn -ENODEV;\r\n}\r\ndev_dbg(&client->dev, "parent is: %s\n", parent_name);\r\nif (of_property_read_u32(node, "xtal-load-pf", &value) == 0)\r\nregmap_write(data->regmap,\r\nCDCE925_REG_XCSEL, (value << 3) & 0xF8);\r\nregmap_update_bits(data->regmap, CDCE925_REG_GLOBAL1, BIT(4), 0);\r\nregmap_update_bits(data->regmap, 0x02, BIT(7), 0);\r\ninit.ops = &cdce925_pll_ops;\r\ninit.flags = 0;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = parent_name ? 1 : 0;\r\nfor (i = 0; i < data->chip_info->num_plls; ++i) {\r\npll_clk_name[i] = kasprintf(GFP_KERNEL, "%s.pll%d",\r\nclient->dev.of_node->name, i);\r\ninit.name = pll_clk_name[i];\r\ndata->pll[i].chip = data;\r\ndata->pll[i].hw.init = &init;\r\ndata->pll[i].index = i;\r\nerr = devm_clk_hw_register(&client->dev, &data->pll[i].hw);\r\nif (err) {\r\ndev_err(&client->dev, "Failed register PLL %d\n", i);\r\ngoto error;\r\n}\r\nsprintf(child_name, "PLL%d", i+1);\r\nnp_output = of_get_child_by_name(node, child_name);\r\nif (!np_output)\r\ncontinue;\r\nif (!of_property_read_u32(np_output,\r\n"clock-frequency", &value)) {\r\nerr = clk_set_rate(data->pll[i].hw.clk, value);\r\nif (err)\r\ndev_err(&client->dev,\r\n"unable to set PLL frequency %ud\n",\r\nvalue);\r\n}\r\nif (!of_property_read_u32(np_output,\r\n"spread-spectrum", &value)) {\r\nu8 flag = of_property_read_bool(np_output,\r\n"spread-spectrum-center") ? 0x80 : 0x00;\r\nregmap_update_bits(data->regmap,\r\n0x16 + (i*CDCE925_OFFSET_PLL),\r\n0x80, flag);\r\nregmap_update_bits(data->regmap,\r\n0x12 + (i*CDCE925_OFFSET_PLL),\r\n0x07, value & 0x07);\r\n}\r\n}\r\ninit.ops = &cdce925_clk_y1_ops;\r\ninit.flags = 0;\r\ninit.num_parents = 1;\r\ninit.parent_names = &parent_name;\r\ninit.name = kasprintf(GFP_KERNEL, "%s.Y1", client->dev.of_node->name);\r\ndata->clk[0].chip = data;\r\ndata->clk[0].hw.init = &init;\r\ndata->clk[0].index = 0;\r\ndata->clk[0].pdiv = 1;\r\nerr = devm_clk_hw_register(&client->dev, &data->clk[0].hw);\r\nkfree(init.name);\r\nif (err) {\r\ndev_err(&client->dev, "clock registration Y1 failed\n");\r\ngoto error;\r\n}\r\ninit.ops = &cdce925_clk_ops;\r\ninit.flags = CLK_SET_RATE_PARENT;\r\ninit.num_parents = 1;\r\nfor (i = 1; i < data->chip_info->num_outputs; ++i) {\r\ninit.name = kasprintf(GFP_KERNEL, "%s.Y%d",\r\nclient->dev.of_node->name, i+1);\r\ndata->clk[i].chip = data;\r\ndata->clk[i].hw.init = &init;\r\ndata->clk[i].index = i;\r\ndata->clk[i].pdiv = 1;\r\nswitch (i) {\r\ncase 1:\r\ncase 2:\r\ninit.parent_names = &pll_clk_name[0];\r\nbreak;\r\ncase 3:\r\ncase 4:\r\ninit.parent_names = &pll_clk_name[1];\r\nbreak;\r\ncase 5:\r\ncase 6:\r\ninit.parent_names = &pll_clk_name[2];\r\nbreak;\r\ncase 7:\r\ncase 8:\r\ninit.parent_names = &pll_clk_name[3];\r\nbreak;\r\n}\r\nerr = devm_clk_hw_register(&client->dev, &data->clk[i].hw);\r\nkfree(init.name);\r\nif (err) {\r\ndev_err(&client->dev, "clock registration failed\n");\r\ngoto error;\r\n}\r\n}\r\nerr = of_clk_add_hw_provider(client->dev.of_node, of_clk_cdce925_get,\r\ndata);\r\nif (err)\r\ndev_err(&client->dev, "unable to add OF clock provider\n");\r\nerr = 0;\r\nerror:\r\nfor (i = 0; i < data->chip_info->num_plls; ++i)\r\nkfree(pll_clk_name[i]);\r\nreturn err;\r\n}
