static int octeon_console_debug_enabled(u32 console)\r\n{\r\nreturn (console_bitmask >> (console)) & 0x1;\r\n}\r\nstatic inline u64 __cvmx_bootmem_desc_get(struct octeon_device *oct,\r\nu64 base,\r\nu32 offset,\r\nu32 size)\r\n{\r\nbase = (1ull << 63) | (base + offset);\r\nswitch (size) {\r\ncase 4:\r\nreturn octeon_read_device_mem32(oct, base);\r\ncase 8:\r\nreturn octeon_read_device_mem64(oct, base);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void CVMX_BOOTMEM_NAMED_GET_NAME(struct octeon_device *oct,\r\nu64 addr,\r\nchar *str,\r\nu32 len)\r\n{\r\naddr += offsetof(struct cvmx_bootmem_named_block_desc, name);\r\nocteon_pci_read_core_mem(oct, addr, (u8 *)str, len);\r\nstr[len] = 0;\r\n}\r\nstatic int __cvmx_bootmem_check_version(struct octeon_device *oct,\r\nu32 exact_match)\r\n{\r\nu32 major_version;\r\nu32 minor_version;\r\nif (!oct->bootmem_desc_addr)\r\noct->bootmem_desc_addr =\r\nocteon_read_device_mem64(oct,\r\nBOOTLOADER_PCI_READ_DESC_ADDR);\r\nmajor_version = (u32)__cvmx_bootmem_desc_get(\r\noct, oct->bootmem_desc_addr,\r\noffsetof(struct cvmx_bootmem_desc, major_version),\r\nFIELD_SIZEOF(struct cvmx_bootmem_desc, major_version));\r\nminor_version = (u32)__cvmx_bootmem_desc_get(\r\noct, oct->bootmem_desc_addr,\r\noffsetof(struct cvmx_bootmem_desc, minor_version),\r\nFIELD_SIZEOF(struct cvmx_bootmem_desc, minor_version));\r\ndev_dbg(&oct->pci_dev->dev, "%s: major_version=%d\n", __func__,\r\nmajor_version);\r\nif ((major_version > 3) ||\r\n(exact_match && major_version != exact_match)) {\r\ndev_err(&oct->pci_dev->dev, "bootmem ver mismatch %d.%d addr:0x%llx\n",\r\nmajor_version, minor_version,\r\nCAST_ULL(oct->bootmem_desc_addr));\r\nreturn -1;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nstatic const struct cvmx_bootmem_named_block_desc\r\n*__cvmx_bootmem_find_named_block_flags(struct octeon_device *oct,\r\nconst char *name, u32 flags)\r\n{\r\nstruct cvmx_bootmem_named_block_desc *desc =\r\n&oct->bootmem_named_block_desc;\r\nu64 named_addr = cvmx_bootmem_phy_named_block_find(oct, name, flags);\r\nif (named_addr) {\r\ndesc->base_addr = __cvmx_bootmem_desc_get(\r\noct, named_addr,\r\noffsetof(struct cvmx_bootmem_named_block_desc,\r\nbase_addr),\r\nFIELD_SIZEOF(\r\nstruct cvmx_bootmem_named_block_desc,\r\nbase_addr));\r\ndesc->size = __cvmx_bootmem_desc_get(oct, named_addr,\r\noffsetof(struct cvmx_bootmem_named_block_desc,\r\nsize),\r\nFIELD_SIZEOF(\r\nstruct cvmx_bootmem_named_block_desc,\r\nsize));\r\nstrncpy(desc->name, name, sizeof(desc->name));\r\ndesc->name[sizeof(desc->name) - 1] = 0;\r\nreturn &oct->bootmem_named_block_desc;\r\n} else {\r\nreturn NULL;\r\n}\r\n}\r\nstatic u64 cvmx_bootmem_phy_named_block_find(struct octeon_device *oct,\r\nconst char *name,\r\nu32 flags)\r\n{\r\nu64 result = 0;\r\nif (!__cvmx_bootmem_check_version(oct, 3)) {\r\nu32 i;\r\nu64 named_block_array_addr = __cvmx_bootmem_desc_get(\r\noct, oct->bootmem_desc_addr,\r\noffsetof(struct cvmx_bootmem_desc,\r\nnamed_block_array_addr),\r\nFIELD_SIZEOF(struct cvmx_bootmem_desc,\r\nnamed_block_array_addr));\r\nu32 num_blocks = (u32)__cvmx_bootmem_desc_get(\r\noct, oct->bootmem_desc_addr,\r\noffsetof(struct cvmx_bootmem_desc,\r\nnb_num_blocks),\r\nFIELD_SIZEOF(struct cvmx_bootmem_desc,\r\nnb_num_blocks));\r\nu32 name_length = (u32)__cvmx_bootmem_desc_get(\r\noct, oct->bootmem_desc_addr,\r\noffsetof(struct cvmx_bootmem_desc,\r\nnamed_block_name_len),\r\nFIELD_SIZEOF(struct cvmx_bootmem_desc,\r\nnamed_block_name_len));\r\nu64 named_addr = named_block_array_addr;\r\nfor (i = 0; i < num_blocks; i++) {\r\nu64 named_size = __cvmx_bootmem_desc_get(\r\noct, named_addr,\r\noffsetof(\r\nstruct cvmx_bootmem_named_block_desc,\r\nsize),\r\nFIELD_SIZEOF(\r\nstruct cvmx_bootmem_named_block_desc,\r\nsize));\r\nif (name && named_size) {\r\nchar *name_tmp =\r\nkmalloc(name_length + 1, GFP_KERNEL);\r\nif (!name_tmp)\r\nbreak;\r\nCVMX_BOOTMEM_NAMED_GET_NAME(oct, named_addr,\r\nname_tmp,\r\nname_length);\r\nif (!strncmp(name, name_tmp, name_length)) {\r\nresult = named_addr;\r\nkfree(name_tmp);\r\nbreak;\r\n}\r\nkfree(name_tmp);\r\n} else if (!name && !named_size) {\r\nresult = named_addr;\r\nbreak;\r\n}\r\nnamed_addr +=\r\nsizeof(struct cvmx_bootmem_named_block_desc);\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic int octeon_named_block_find(struct octeon_device *oct, const char *name,\r\nu64 *base_addr, u64 *size)\r\n{\r\nconst struct cvmx_bootmem_named_block_desc *named_block;\r\nocteon_remote_lock();\r\nnamed_block = __cvmx_bootmem_find_named_block_flags(oct, name, 0);\r\nocteon_remote_unlock();\r\nif (named_block) {\r\n*base_addr = named_block->base_addr;\r\n*size = named_block->size;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void octeon_remote_lock(void)\r\n{\r\n}\r\nstatic void octeon_remote_unlock(void)\r\n{\r\n}\r\nint octeon_console_send_cmd(struct octeon_device *oct, char *cmd_str,\r\nu32 wait_hundredths)\r\n{\r\nu32 len = (u32)strlen(cmd_str);\r\ndev_dbg(&oct->pci_dev->dev, "sending \"%s\" to bootloader\n", cmd_str);\r\nif (len > BOOTLOADER_PCI_WRITE_BUFFER_STR_LEN - 1) {\r\ndev_err(&oct->pci_dev->dev, "Command string too long, max length is: %d\n",\r\nBOOTLOADER_PCI_WRITE_BUFFER_STR_LEN - 1);\r\nreturn -1;\r\n}\r\nif (octeon_wait_for_bootloader(oct, wait_hundredths) != 0) {\r\ndev_err(&oct->pci_dev->dev, "Bootloader not ready for command.\n");\r\nreturn -1;\r\n}\r\nocteon_remote_lock();\r\nocteon_pci_write_core_mem(oct, BOOTLOADER_PCI_READ_BUFFER_DATA_ADDR,\r\n(u8 *)cmd_str, len);\r\nocteon_write_device_mem32(oct, BOOTLOADER_PCI_READ_BUFFER_LEN_ADDR,\r\nlen);\r\nocteon_write_device_mem32(oct, BOOTLOADER_PCI_READ_BUFFER_OWNER_ADDR,\r\nOCTEON_PCI_IO_BUF_OWNER_OCTEON);\r\nif (octeon_wait_for_bootloader(oct, 200) != 0) {\r\nocteon_remote_unlock();\r\ndev_err(&oct->pci_dev->dev, "Bootloader did not accept command.\n");\r\nreturn -1;\r\n}\r\nocteon_remote_unlock();\r\nreturn 0;\r\n}\r\nint octeon_wait_for_bootloader(struct octeon_device *oct,\r\nu32 wait_time_hundredths)\r\n{\r\ndev_dbg(&oct->pci_dev->dev, "waiting %d0 ms for bootloader\n",\r\nwait_time_hundredths);\r\nif (octeon_mem_access_ok(oct))\r\nreturn -1;\r\nwhile (wait_time_hundredths > 0 &&\r\nocteon_read_device_mem32(oct,\r\nBOOTLOADER_PCI_READ_BUFFER_OWNER_ADDR)\r\n!= OCTEON_PCI_IO_BUF_OWNER_HOST) {\r\nif (--wait_time_hundredths <= 0)\r\nreturn -1;\r\nschedule_timeout_uninterruptible(HZ / 100);\r\n}\r\nreturn 0;\r\n}\r\nstatic void octeon_console_handle_result(struct octeon_device *oct,\r\nsize_t console_num)\r\n{\r\nstruct octeon_console *console;\r\nconsole = &oct->console[console_num];\r\nconsole->waiting = 0;\r\n}\r\nstatic void output_console_line(struct octeon_device *oct,\r\nstruct octeon_console *console,\r\nsize_t console_num,\r\nchar *console_buffer,\r\ns32 bytes_read)\r\n{\r\nchar *line;\r\ns32 i;\r\nline = console_buffer;\r\nfor (i = 0; i < bytes_read; i++) {\r\nif (console_buffer[i] == '\n') {\r\nconsole_buffer[i] = '\0';\r\nif (console->leftover[0]) {\r\ndev_info(&oct->pci_dev->dev, "%lu: %s%s\n",\r\nconsole_num, console->leftover,\r\nline);\r\nconsole->leftover[0] = '\0';\r\n} else {\r\ndev_info(&oct->pci_dev->dev, "%lu: %s\n",\r\nconsole_num, line);\r\n}\r\nline = &console_buffer[i + 1];\r\n}\r\n}\r\nif (line != &console_buffer[bytes_read]) {\r\nconsole_buffer[bytes_read] = '\0';\r\nstrcpy(console->leftover, line);\r\n}\r\n}\r\nstatic void check_console(struct work_struct *work)\r\n{\r\ns32 bytes_read, tries, total_read;\r\nstruct octeon_console *console;\r\nstruct cavium_wk *wk = (struct cavium_wk *)work;\r\nstruct octeon_device *oct = (struct octeon_device *)wk->ctxptr;\r\nu32 console_num = (u32)wk->ctxul;\r\nu32 delay;\r\nconsole = &oct->console[console_num];\r\ntries = 0;\r\ntotal_read = 0;\r\ndo {\r\nbytes_read =\r\nocteon_console_read(oct, console_num, console_buffer,\r\nsizeof(console_buffer) - 1);\r\nif (bytes_read > 0) {\r\ntotal_read += bytes_read;\r\nif (console->waiting)\r\nocteon_console_handle_result(oct, console_num);\r\nif (octeon_console_debug_enabled(console_num)) {\r\noutput_console_line(oct, console, console_num,\r\nconsole_buffer, bytes_read);\r\n}\r\n} else if (bytes_read < 0) {\r\ndev_err(&oct->pci_dev->dev, "Error reading console %u, ret=%d\n",\r\nconsole_num, bytes_read);\r\n}\r\ntries++;\r\n} while ((bytes_read > 0) && (tries < 16));\r\nif (octeon_console_debug_enabled(console_num) &&\r\n(total_read == 0) && (console->leftover[0])) {\r\ndev_info(&oct->pci_dev->dev, "%u: %s\n",\r\nconsole_num, console->leftover);\r\nconsole->leftover[0] = '\0';\r\n}\r\ndelay = OCTEON_CONSOLE_POLL_INTERVAL_MS;\r\nschedule_delayed_work(&wk->work, msecs_to_jiffies(delay));\r\n}\r\nint octeon_init_consoles(struct octeon_device *oct)\r\n{\r\nint ret = 0;\r\nu64 addr, size;\r\nret = octeon_mem_access_ok(oct);\r\nif (ret) {\r\ndev_err(&oct->pci_dev->dev, "Memory access not okay'\n");\r\nreturn ret;\r\n}\r\nret = octeon_named_block_find(oct, OCTEON_PCI_CONSOLE_BLOCK_NAME, &addr,\r\n&size);\r\nif (ret) {\r\ndev_err(&oct->pci_dev->dev, "Could not find console '%s'\n",\r\nOCTEON_PCI_CONSOLE_BLOCK_NAME);\r\nreturn ret;\r\n}\r\noct->console_nb_info.bar1_index = BAR1_INDEX_STATIC_MAP;\r\noct->fn_list.bar1_idx_setup(oct, addr, oct->console_nb_info.bar1_index,\r\ntrue);\r\noct->console_nb_info.dram_region_base = addr\r\n& ~(OCTEON_BAR1_ENTRY_SIZE - 1ULL);\r\noct->num_consoles = octeon_read_device_mem32(oct,\r\naddr + offsetof(struct octeon_pci_console_desc,\r\nnum_consoles));\r\noct->console_desc_addr = addr;\r\ndev_dbg(&oct->pci_dev->dev, "Initialized consoles. %d available\n",\r\noct->num_consoles);\r\nreturn ret;\r\n}\r\nint octeon_add_console(struct octeon_device *oct, u32 console_num)\r\n{\r\nint ret = 0;\r\nu32 delay;\r\nu64 coreaddr;\r\nstruct delayed_work *work;\r\nstruct octeon_console *console;\r\nif (console_num >= oct->num_consoles) {\r\ndev_err(&oct->pci_dev->dev,\r\n"trying to read from console number %d when only 0 to %d exist\n",\r\nconsole_num, oct->num_consoles);\r\n} else {\r\nconsole = &oct->console[console_num];\r\nconsole->waiting = 0;\r\ncoreaddr = oct->console_desc_addr + console_num * 8 +\r\noffsetof(struct octeon_pci_console_desc,\r\nconsole_addr_array);\r\nconsole->addr = octeon_read_device_mem64(oct, coreaddr);\r\ncoreaddr = console->addr + offsetof(struct octeon_pci_console,\r\nbuf_size);\r\nconsole->buffer_size = octeon_read_device_mem32(oct, coreaddr);\r\ncoreaddr = console->addr + offsetof(struct octeon_pci_console,\r\ninput_base_addr);\r\nconsole->input_base_addr =\r\nocteon_read_device_mem64(oct, coreaddr);\r\ncoreaddr = console->addr + offsetof(struct octeon_pci_console,\r\noutput_base_addr);\r\nconsole->output_base_addr =\r\nocteon_read_device_mem64(oct, coreaddr);\r\nconsole->leftover[0] = '\0';\r\nwork = &oct->console_poll_work[console_num].work;\r\nINIT_DELAYED_WORK(work, check_console);\r\noct->console_poll_work[console_num].ctxptr = (void *)oct;\r\noct->console_poll_work[console_num].ctxul = console_num;\r\ndelay = OCTEON_CONSOLE_POLL_INTERVAL_MS;\r\nschedule_delayed_work(work, msecs_to_jiffies(delay));\r\nif (octeon_console_debug_enabled(console_num)) {\r\nret = octeon_console_send_cmd(oct,\r\n"setenv pci_console_active 1",\r\n2000);\r\n}\r\nconsole->active = 1;\r\n}\r\nreturn ret;\r\n}\r\nvoid octeon_remove_consoles(struct octeon_device *oct)\r\n{\r\nu32 i;\r\nstruct octeon_console *console;\r\nfor (i = 0; i < oct->num_consoles; i++) {\r\nconsole = &oct->console[i];\r\nif (!console->active)\r\ncontinue;\r\ncancel_delayed_work_sync(&oct->console_poll_work[i].\r\nwork);\r\nconsole->addr = 0;\r\nconsole->buffer_size = 0;\r\nconsole->input_base_addr = 0;\r\nconsole->output_base_addr = 0;\r\n}\r\noct->num_consoles = 0;\r\n}\r\nstatic inline int octeon_console_free_bytes(u32 buffer_size,\r\nu32 wr_idx,\r\nu32 rd_idx)\r\n{\r\nif (rd_idx >= buffer_size || wr_idx >= buffer_size)\r\nreturn -1;\r\nreturn ((buffer_size - 1) - (wr_idx - rd_idx)) % buffer_size;\r\n}\r\nstatic inline int octeon_console_avail_bytes(u32 buffer_size,\r\nu32 wr_idx,\r\nu32 rd_idx)\r\n{\r\nif (rd_idx >= buffer_size || wr_idx >= buffer_size)\r\nreturn -1;\r\nreturn buffer_size - 1 -\r\nocteon_console_free_bytes(buffer_size, wr_idx, rd_idx);\r\n}\r\nstatic int octeon_console_read(struct octeon_device *oct, u32 console_num,\r\nchar *buffer, u32 buf_size)\r\n{\r\nint bytes_to_read;\r\nu32 rd_idx, wr_idx;\r\nstruct octeon_console *console;\r\nif (console_num >= oct->num_consoles) {\r\ndev_err(&oct->pci_dev->dev, "Attempted to read from disabled console %d\n",\r\nconsole_num);\r\nreturn 0;\r\n}\r\nconsole = &oct->console[console_num];\r\nrd_idx = octeon_read_device_mem32(oct, console->addr +\r\noffsetof(struct octeon_pci_console, output_read_index));\r\nwr_idx = octeon_read_device_mem32(oct, console->addr +\r\noffsetof(struct octeon_pci_console, output_write_index));\r\nbytes_to_read = octeon_console_avail_bytes(console->buffer_size,\r\nwr_idx, rd_idx);\r\nif (bytes_to_read <= 0)\r\nreturn bytes_to_read;\r\nbytes_to_read = MIN(bytes_to_read, (s32)buf_size);\r\nif (rd_idx + bytes_to_read >= console->buffer_size)\r\nbytes_to_read = console->buffer_size - rd_idx;\r\nocteon_pci_read_core_mem(oct, console->output_base_addr + rd_idx,\r\n(u8 *)buffer, bytes_to_read);\r\nocteon_write_device_mem32(oct, console->addr +\r\noffsetof(struct octeon_pci_console,\r\noutput_read_index),\r\n(rd_idx + bytes_to_read) %\r\nconsole->buffer_size);\r\nreturn bytes_to_read;\r\n}\r\nint octeon_download_firmware(struct octeon_device *oct, const u8 *data,\r\nsize_t size)\r\n{\r\nint ret = 0;\r\nu8 *p = fbuf;\r\nu32 crc32_result;\r\nu64 load_addr;\r\nu32 image_len;\r\nstruct octeon_firmware_file_header *h;\r\nu32 i, rem;\r\nif (size < sizeof(struct octeon_firmware_file_header)) {\r\ndev_err(&oct->pci_dev->dev, "Firmware file too small (%d < %d).\n",\r\n(u32)size,\r\n(u32)sizeof(struct octeon_firmware_file_header));\r\nreturn -EINVAL;\r\n}\r\nh = (struct octeon_firmware_file_header *)data;\r\nif (be32_to_cpu(h->magic) != LIO_NIC_MAGIC) {\r\ndev_err(&oct->pci_dev->dev, "Unrecognized firmware file.\n");\r\nreturn -EINVAL;\r\n}\r\ncrc32_result = crc32((unsigned int)~0, data,\r\nsizeof(struct octeon_firmware_file_header) -\r\nsizeof(u32)) ^ ~0U;\r\nif (crc32_result != be32_to_cpu(h->crc32)) {\r\ndev_err(&oct->pci_dev->dev, "Firmware CRC mismatch (0x%08x != 0x%08x).\n",\r\ncrc32_result, be32_to_cpu(h->crc32));\r\nreturn -EINVAL;\r\n}\r\nif (strncmp(LIQUIDIO_PACKAGE, h->version, strlen(LIQUIDIO_PACKAGE))) {\r\ndev_err(&oct->pci_dev->dev, "Unmatched firmware package type. Expected %s, got %s.\n",\r\nLIQUIDIO_PACKAGE, h->version);\r\nreturn -EINVAL;\r\n}\r\nif (memcmp(LIQUIDIO_BASE_VERSION, h->version + strlen(LIQUIDIO_PACKAGE),\r\nstrlen(LIQUIDIO_BASE_VERSION))) {\r\ndev_err(&oct->pci_dev->dev, "Unmatched firmware version. Expected %s.x, got %s.\n",\r\nLIQUIDIO_BASE_VERSION,\r\nh->version + strlen(LIQUIDIO_PACKAGE));\r\nreturn -EINVAL;\r\n}\r\nif (be32_to_cpu(h->num_images) > LIO_MAX_IMAGES) {\r\ndev_err(&oct->pci_dev->dev, "Too many images in firmware file (%d).\n",\r\nbe32_to_cpu(h->num_images));\r\nreturn -EINVAL;\r\n}\r\ndev_info(&oct->pci_dev->dev, "Firmware version: %s\n", h->version);\r\nsnprintf(oct->fw_info.liquidio_firmware_version, 32, "LIQUIDIO: %s",\r\nh->version);\r\ndata += sizeof(struct octeon_firmware_file_header);\r\ndev_info(&oct->pci_dev->dev, "%s: Loading %d images\n", __func__,\r\nbe32_to_cpu(h->num_images));\r\nfor (i = 0; i < be32_to_cpu(h->num_images); i++) {\r\nload_addr = be64_to_cpu(h->desc[i].addr);\r\nimage_len = be32_to_cpu(h->desc[i].len);\r\ndev_info(&oct->pci_dev->dev, "Loading firmware %d at %llx\n",\r\nimage_len, load_addr);\r\nrem = image_len;\r\nwhile (rem) {\r\nif (rem < FBUF_SIZE)\r\nsize = rem;\r\nelse\r\nsize = FBUF_SIZE;\r\nmemcpy(p, data, size);\r\nocteon_pci_write_core_mem(oct, load_addr, p, (u32)size);\r\ndata += size;\r\nrem -= (u32)size;\r\nload_addr += size;\r\n}\r\n}\r\ndev_info(&oct->pci_dev->dev, "Writing boot command: %s\n",\r\nh->bootcmd);\r\nret = octeon_console_send_cmd(oct, h->bootcmd, 50);\r\nreturn 0;\r\n}
