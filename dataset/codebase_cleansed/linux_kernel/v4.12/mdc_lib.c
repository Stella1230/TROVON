static void __mdc_pack_body(struct mdt_body *b, __u32 suppgid)\r\n{\r\nb->mbo_suppgid = suppgid;\r\nb->mbo_uid = from_kuid(&init_user_ns, current_uid());\r\nb->mbo_gid = from_kgid(&init_user_ns, current_gid());\r\nb->mbo_fsuid = from_kuid(&init_user_ns, current_fsuid());\r\nb->mbo_fsgid = from_kgid(&init_user_ns, current_fsgid());\r\nb->mbo_capability = cfs_curproc_cap_pack();\r\n}\r\nvoid mdc_swap_layouts_pack(struct ptlrpc_request *req,\r\nstruct md_op_data *op_data)\r\n{\r\nstruct mdt_body *b = req_capsule_client_get(&req->rq_pill,\r\n&RMF_MDT_BODY);\r\n__mdc_pack_body(b, op_data->op_suppgids[0]);\r\nb->mbo_fid1 = op_data->op_fid1;\r\nb->mbo_fid2 = op_data->op_fid2;\r\nb->mbo_valid |= OBD_MD_FLID;\r\n}\r\nvoid mdc_pack_body(struct ptlrpc_request *req, const struct lu_fid *fid,\r\n__u64 valid, size_t ea_size, __u32 suppgid, u32 flags)\r\n{\r\nstruct mdt_body *b = req_capsule_client_get(&req->rq_pill,\r\n&RMF_MDT_BODY);\r\nb->mbo_valid = valid;\r\nb->mbo_eadatasize = ea_size;\r\nb->mbo_flags = flags;\r\n__mdc_pack_body(b, suppgid);\r\nif (fid) {\r\nb->mbo_fid1 = *fid;\r\nb->mbo_valid |= OBD_MD_FLID;\r\n}\r\n}\r\nstatic void mdc_pack_name(struct ptlrpc_request *req,\r\nconst struct req_msg_field *field,\r\nconst char *name, size_t name_len)\r\n{\r\nsize_t buf_size;\r\nsize_t cpy_len;\r\nchar *buf;\r\nbuf = req_capsule_client_get(&req->rq_pill, field);\r\nbuf_size = req_capsule_get_size(&req->rq_pill, field, RCL_CLIENT);\r\nLASSERT(name && name_len && buf && buf_size == name_len + 1);\r\ncpy_len = strlcpy(buf, name, buf_size);\r\nLASSERT(cpy_len == name_len && lu_name_is_valid_2(buf, cpy_len));\r\n}\r\nvoid mdc_readdir_pack(struct ptlrpc_request *req, __u64 pgoff, size_t size,\r\nconst struct lu_fid *fid)\r\n{\r\nstruct mdt_body *b = req_capsule_client_get(&req->rq_pill,\r\n&RMF_MDT_BODY);\r\nb->mbo_fid1 = *fid;\r\nb->mbo_valid |= OBD_MD_FLID;\r\nb->mbo_size = pgoff;\r\nb->mbo_nlink = size;\r\n__mdc_pack_body(b, -1);\r\nb->mbo_mode = LUDA_FID | LUDA_TYPE;\r\n}\r\nvoid mdc_create_pack(struct ptlrpc_request *req, struct md_op_data *op_data,\r\nconst void *data, size_t datalen, umode_t mode,\r\nuid_t uid, gid_t gid, cfs_cap_t cap_effective, __u64 rdev)\r\n{\r\nstruct mdt_rec_create *rec;\r\nchar *tmp;\r\n__u64 flags;\r\nBUILD_BUG_ON(sizeof(struct mdt_rec_reint) != sizeof(struct mdt_rec_create));\r\nrec = req_capsule_client_get(&req->rq_pill, &RMF_REC_REINT);\r\nrec->cr_opcode = REINT_CREATE;\r\nrec->cr_fsuid = uid;\r\nrec->cr_fsgid = gid;\r\nrec->cr_cap = cap_effective;\r\nrec->cr_fid1 = op_data->op_fid1;\r\nrec->cr_fid2 = op_data->op_fid2;\r\nrec->cr_mode = mode;\r\nrec->cr_rdev = rdev;\r\nrec->cr_time = op_data->op_mod_time;\r\nrec->cr_suppgid1 = op_data->op_suppgids[0];\r\nrec->cr_suppgid2 = op_data->op_suppgids[1];\r\nflags = 0;\r\nif (op_data->op_bias & MDS_CREATE_VOLATILE)\r\nflags |= MDS_OPEN_VOLATILE;\r\nset_mrc_cr_flags(rec, flags);\r\nrec->cr_bias = op_data->op_bias;\r\nrec->cr_umask = current_umask();\r\nmdc_pack_name(req, &RMF_NAME, op_data->op_name, op_data->op_namelen);\r\nif (data) {\r\ntmp = req_capsule_client_get(&req->rq_pill, &RMF_EADATA);\r\nmemcpy(tmp, data, datalen);\r\n}\r\n}\r\nstatic inline __u64 mds_pack_open_flags(__u64 flags)\r\n{\r\n__u64 cr_flags = (flags & (FMODE_READ | FMODE_WRITE |\r\nMDS_OPEN_FL_INTERNAL));\r\nif (flags & O_CREAT)\r\ncr_flags |= MDS_OPEN_CREAT;\r\nif (flags & O_EXCL)\r\ncr_flags |= MDS_OPEN_EXCL;\r\nif (flags & O_TRUNC)\r\ncr_flags |= MDS_OPEN_TRUNC;\r\nif (flags & O_APPEND)\r\ncr_flags |= MDS_OPEN_APPEND;\r\nif (flags & O_SYNC)\r\ncr_flags |= MDS_OPEN_SYNC;\r\nif (flags & O_DIRECTORY)\r\ncr_flags |= MDS_OPEN_DIRECTORY;\r\nif (flags & __FMODE_EXEC)\r\ncr_flags |= MDS_FMODE_EXEC;\r\nif (cl_is_lov_delay_create(flags))\r\ncr_flags |= MDS_OPEN_DELAY_CREATE;\r\nif (flags & O_NONBLOCK)\r\ncr_flags |= MDS_OPEN_NORESTORE;\r\nreturn cr_flags;\r\n}\r\nvoid mdc_open_pack(struct ptlrpc_request *req, struct md_op_data *op_data,\r\numode_t mode, __u64 rdev, __u64 flags, const void *lmm,\r\nsize_t lmmlen)\r\n{\r\nstruct mdt_rec_create *rec;\r\nchar *tmp;\r\n__u64 cr_flags;\r\nBUILD_BUG_ON(sizeof(struct mdt_rec_reint) != sizeof(struct mdt_rec_create));\r\nrec = req_capsule_client_get(&req->rq_pill, &RMF_REC_REINT);\r\nrec->cr_opcode = REINT_OPEN;\r\nrec->cr_fsuid = from_kuid(&init_user_ns, current_fsuid());\r\nrec->cr_fsgid = from_kgid(&init_user_ns, current_fsgid());\r\nrec->cr_cap = cfs_curproc_cap_pack();\r\nrec->cr_fid1 = op_data->op_fid1;\r\nrec->cr_fid2 = op_data->op_fid2;\r\nrec->cr_mode = mode;\r\ncr_flags = mds_pack_open_flags(flags);\r\nrec->cr_rdev = rdev;\r\nrec->cr_time = op_data->op_mod_time;\r\nrec->cr_suppgid1 = op_data->op_suppgids[0];\r\nrec->cr_suppgid2 = op_data->op_suppgids[1];\r\nrec->cr_bias = op_data->op_bias;\r\nrec->cr_umask = current_umask();\r\nrec->cr_old_handle = op_data->op_handle;\r\nif (op_data->op_name) {\r\nmdc_pack_name(req, &RMF_NAME, op_data->op_name,\r\nop_data->op_namelen);\r\nif (op_data->op_bias & MDS_CREATE_VOLATILE)\r\ncr_flags |= MDS_OPEN_VOLATILE;\r\n}\r\nif (lmm) {\r\ncr_flags |= MDS_OPEN_HAS_EA;\r\ntmp = req_capsule_client_get(&req->rq_pill, &RMF_EADATA);\r\nmemcpy(tmp, lmm, lmmlen);\r\n}\r\nset_mrc_cr_flags(rec, cr_flags);\r\n}\r\nstatic inline __u64 attr_pack(unsigned int ia_valid)\r\n{\r\n__u64 sa_valid = 0;\r\nif (ia_valid & ATTR_MODE)\r\nsa_valid |= MDS_ATTR_MODE;\r\nif (ia_valid & ATTR_UID)\r\nsa_valid |= MDS_ATTR_UID;\r\nif (ia_valid & ATTR_GID)\r\nsa_valid |= MDS_ATTR_GID;\r\nif (ia_valid & ATTR_SIZE)\r\nsa_valid |= MDS_ATTR_SIZE;\r\nif (ia_valid & ATTR_ATIME)\r\nsa_valid |= MDS_ATTR_ATIME;\r\nif (ia_valid & ATTR_MTIME)\r\nsa_valid |= MDS_ATTR_MTIME;\r\nif (ia_valid & ATTR_CTIME)\r\nsa_valid |= MDS_ATTR_CTIME;\r\nif (ia_valid & ATTR_ATIME_SET)\r\nsa_valid |= MDS_ATTR_ATIME_SET;\r\nif (ia_valid & ATTR_MTIME_SET)\r\nsa_valid |= MDS_ATTR_MTIME_SET;\r\nif (ia_valid & ATTR_FORCE)\r\nsa_valid |= MDS_ATTR_FORCE;\r\nif (ia_valid & ATTR_ATTR_FLAG)\r\nsa_valid |= MDS_ATTR_ATTR_FLAG;\r\nif (ia_valid & ATTR_KILL_SUID)\r\nsa_valid |= MDS_ATTR_KILL_SUID;\r\nif (ia_valid & ATTR_KILL_SGID)\r\nsa_valid |= MDS_ATTR_KILL_SGID;\r\nif (ia_valid & ATTR_CTIME_SET)\r\nsa_valid |= MDS_ATTR_CTIME_SET;\r\nif (ia_valid & ATTR_OPEN)\r\nsa_valid |= MDS_ATTR_FROM_OPEN;\r\nif (ia_valid & ATTR_BLOCKS)\r\nsa_valid |= MDS_ATTR_BLOCKS;\r\nif (ia_valid & MDS_OPEN_OWNEROVERRIDE)\r\nsa_valid |= MDS_OPEN_OWNEROVERRIDE;\r\nreturn sa_valid;\r\n}\r\nstatic void mdc_setattr_pack_rec(struct mdt_rec_setattr *rec,\r\nstruct md_op_data *op_data)\r\n{\r\nrec->sa_opcode = REINT_SETATTR;\r\nrec->sa_fsuid = from_kuid(&init_user_ns, current_fsuid());\r\nrec->sa_fsgid = from_kgid(&init_user_ns, current_fsgid());\r\nrec->sa_cap = cfs_curproc_cap_pack();\r\nrec->sa_suppgid = -1;\r\nrec->sa_fid = op_data->op_fid1;\r\nrec->sa_valid = attr_pack(op_data->op_attr.ia_valid);\r\nrec->sa_mode = op_data->op_attr.ia_mode;\r\nrec->sa_uid = from_kuid(&init_user_ns, op_data->op_attr.ia_uid);\r\nrec->sa_gid = from_kgid(&init_user_ns, op_data->op_attr.ia_gid);\r\nrec->sa_size = op_data->op_attr.ia_size;\r\nrec->sa_blocks = op_data->op_attr_blocks;\r\nrec->sa_atime = LTIME_S(op_data->op_attr.ia_atime);\r\nrec->sa_mtime = LTIME_S(op_data->op_attr.ia_mtime);\r\nrec->sa_ctime = LTIME_S(op_data->op_attr.ia_ctime);\r\nrec->sa_attr_flags = op_data->op_attr_flags;\r\nif ((op_data->op_attr.ia_valid & ATTR_GID) &&\r\nin_group_p(op_data->op_attr.ia_gid))\r\nrec->sa_suppgid =\r\nfrom_kgid(&init_user_ns, op_data->op_attr.ia_gid);\r\nelse\r\nrec->sa_suppgid = op_data->op_suppgids[0];\r\nrec->sa_bias = op_data->op_bias;\r\n}\r\nstatic void mdc_ioepoch_pack(struct mdt_ioepoch *epoch,\r\nstruct md_op_data *op_data)\r\n{\r\nepoch->mio_handle = op_data->op_handle;\r\nepoch->mio_unused1 = 0;\r\nepoch->mio_unused2 = 0;\r\nepoch->mio_padding = 0;\r\n}\r\nvoid mdc_setattr_pack(struct ptlrpc_request *req, struct md_op_data *op_data,\r\nvoid *ea, size_t ealen)\r\n{\r\nstruct mdt_rec_setattr *rec;\r\nstruct lov_user_md *lum = NULL;\r\nBUILD_BUG_ON(sizeof(struct mdt_rec_reint) !=\r\nsizeof(struct mdt_rec_setattr));\r\nrec = req_capsule_client_get(&req->rq_pill, &RMF_REC_REINT);\r\nmdc_setattr_pack_rec(rec, op_data);\r\nif (ealen == 0)\r\nreturn;\r\nlum = req_capsule_client_get(&req->rq_pill, &RMF_EADATA);\r\nif (!ea) {\r\nlum->lmm_magic = cpu_to_le32(LOV_USER_MAGIC_V1);\r\nlum->lmm_stripe_size = 0;\r\nlum->lmm_stripe_count = 0;\r\nlum->lmm_stripe_offset = (typeof(lum->lmm_stripe_offset))(-1);\r\n} else {\r\nmemcpy(lum, ea, ealen);\r\n}\r\n}\r\nvoid mdc_unlink_pack(struct ptlrpc_request *req, struct md_op_data *op_data)\r\n{\r\nstruct mdt_rec_unlink *rec;\r\nBUILD_BUG_ON(sizeof(struct mdt_rec_reint) != sizeof(struct mdt_rec_unlink));\r\nrec = req_capsule_client_get(&req->rq_pill, &RMF_REC_REINT);\r\nrec->ul_opcode = op_data->op_cli_flags & CLI_RM_ENTRY ?\r\nREINT_RMENTRY : REINT_UNLINK;\r\nrec->ul_fsuid = op_data->op_fsuid;\r\nrec->ul_fsgid = op_data->op_fsgid;\r\nrec->ul_cap = op_data->op_cap;\r\nrec->ul_mode = op_data->op_mode;\r\nrec->ul_suppgid1 = op_data->op_suppgids[0];\r\nrec->ul_suppgid2 = -1;\r\nrec->ul_fid1 = op_data->op_fid1;\r\nrec->ul_fid2 = op_data->op_fid2;\r\nrec->ul_time = op_data->op_mod_time;\r\nrec->ul_bias = op_data->op_bias;\r\nmdc_pack_name(req, &RMF_NAME, op_data->op_name, op_data->op_namelen);\r\n}\r\nvoid mdc_link_pack(struct ptlrpc_request *req, struct md_op_data *op_data)\r\n{\r\nstruct mdt_rec_link *rec;\r\nBUILD_BUG_ON(sizeof(struct mdt_rec_reint) != sizeof(struct mdt_rec_link));\r\nrec = req_capsule_client_get(&req->rq_pill, &RMF_REC_REINT);\r\nrec->lk_opcode = REINT_LINK;\r\nrec->lk_fsuid = op_data->op_fsuid;\r\nrec->lk_fsgid = op_data->op_fsgid;\r\nrec->lk_cap = op_data->op_cap;\r\nrec->lk_suppgid1 = op_data->op_suppgids[0];\r\nrec->lk_suppgid2 = op_data->op_suppgids[1];\r\nrec->lk_fid1 = op_data->op_fid1;\r\nrec->lk_fid2 = op_data->op_fid2;\r\nrec->lk_time = op_data->op_mod_time;\r\nrec->lk_bias = op_data->op_bias;\r\nmdc_pack_name(req, &RMF_NAME, op_data->op_name, op_data->op_namelen);\r\n}\r\nstatic void mdc_intent_close_pack(struct ptlrpc_request *req,\r\nstruct md_op_data *op_data)\r\n{\r\nenum mds_op_bias bias = op_data->op_bias;\r\nstruct close_data *data;\r\nstruct ldlm_lock *lock;\r\nif (!(bias & (MDS_HSM_RELEASE | MDS_CLOSE_LAYOUT_SWAP |\r\nMDS_RENAME_MIGRATE)))\r\nreturn;\r\ndata = req_capsule_client_get(&req->rq_pill, &RMF_CLOSE_DATA);\r\nLASSERT(data);\r\nlock = ldlm_handle2lock(&op_data->op_lease_handle);\r\nif (lock) {\r\ndata->cd_handle = lock->l_remote_handle;\r\nLDLM_LOCK_PUT(lock);\r\n}\r\nldlm_cli_cancel(&op_data->op_lease_handle, LCF_LOCAL);\r\ndata->cd_data_version = op_data->op_data_version;\r\ndata->cd_fid = op_data->op_fid2;\r\n}\r\nvoid mdc_rename_pack(struct ptlrpc_request *req, struct md_op_data *op_data,\r\nconst char *old, size_t oldlen,\r\nconst char *new, size_t newlen)\r\n{\r\nstruct mdt_rec_rename *rec;\r\nBUILD_BUG_ON(sizeof(struct mdt_rec_reint) != sizeof(struct mdt_rec_rename));\r\nrec = req_capsule_client_get(&req->rq_pill, &RMF_REC_REINT);\r\nrec->rn_opcode = op_data->op_cli_flags & CLI_MIGRATE ?\r\nREINT_MIGRATE : REINT_RENAME;\r\nrec->rn_opcode = REINT_RENAME;\r\nrec->rn_fsuid = op_data->op_fsuid;\r\nrec->rn_fsgid = op_data->op_fsgid;\r\nrec->rn_cap = op_data->op_cap;\r\nrec->rn_suppgid1 = op_data->op_suppgids[0];\r\nrec->rn_suppgid2 = op_data->op_suppgids[1];\r\nrec->rn_fid1 = op_data->op_fid1;\r\nrec->rn_fid2 = op_data->op_fid2;\r\nrec->rn_time = op_data->op_mod_time;\r\nrec->rn_mode = op_data->op_mode;\r\nrec->rn_bias = op_data->op_bias;\r\nmdc_pack_name(req, &RMF_NAME, old, oldlen);\r\nif (new)\r\nmdc_pack_name(req, &RMF_SYMTGT, new, newlen);\r\nif (op_data->op_cli_flags & CLI_MIGRATE &&\r\nop_data->op_bias & MDS_RENAME_MIGRATE) {\r\nstruct mdt_ioepoch *epoch;\r\nmdc_intent_close_pack(req, op_data);\r\nepoch = req_capsule_client_get(&req->rq_pill, &RMF_MDT_EPOCH);\r\nmdc_ioepoch_pack(epoch, op_data);\r\n}\r\n}\r\nvoid mdc_getattr_pack(struct ptlrpc_request *req, __u64 valid, u32 flags,\r\nstruct md_op_data *op_data, size_t ea_size)\r\n{\r\nstruct mdt_body *b = req_capsule_client_get(&req->rq_pill,\r\n&RMF_MDT_BODY);\r\nb->mbo_valid = valid;\r\nif (op_data->op_bias & MDS_CHECK_SPLIT)\r\nb->mbo_valid |= OBD_MD_FLCKSPLIT;\r\nif (op_data->op_bias & MDS_CROSS_REF)\r\nb->mbo_valid |= OBD_MD_FLCROSSREF;\r\nb->mbo_eadatasize = ea_size;\r\nb->mbo_flags = flags;\r\n__mdc_pack_body(b, op_data->op_suppgids[0]);\r\nb->mbo_fid1 = op_data->op_fid1;\r\nb->mbo_fid2 = op_data->op_fid2;\r\nb->mbo_valid |= OBD_MD_FLID;\r\nif (op_data->op_name)\r\nmdc_pack_name(req, &RMF_NAME, op_data->op_name,\r\nop_data->op_namelen);\r\n}\r\nvoid mdc_close_pack(struct ptlrpc_request *req, struct md_op_data *op_data)\r\n{\r\nstruct mdt_ioepoch *epoch;\r\nstruct mdt_rec_setattr *rec;\r\nepoch = req_capsule_client_get(&req->rq_pill, &RMF_MDT_EPOCH);\r\nrec = req_capsule_client_get(&req->rq_pill, &RMF_REC_REINT);\r\nmdc_setattr_pack_rec(rec, op_data);\r\nif (rec->sa_atime == 0)\r\nrec->sa_valid &= ~MDS_ATTR_ATIME;\r\nmdc_ioepoch_pack(epoch, op_data);\r\nmdc_intent_close_pack(req, op_data);\r\n}
