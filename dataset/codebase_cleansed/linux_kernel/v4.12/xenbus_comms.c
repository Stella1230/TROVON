static irqreturn_t wake_waiting(int irq, void *unused)\r\n{\r\nif (unlikely(xenstored_ready == 0)) {\r\nxenstored_ready = 1;\r\nschedule_work(&probe_work);\r\n}\r\nwake_up(&xb_waitq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int check_indexes(XENSTORE_RING_IDX cons, XENSTORE_RING_IDX prod)\r\n{\r\nreturn ((prod - cons) <= XENSTORE_RING_SIZE);\r\n}\r\nstatic void *get_output_chunk(XENSTORE_RING_IDX cons,\r\nXENSTORE_RING_IDX prod,\r\nchar *buf, uint32_t *len)\r\n{\r\n*len = XENSTORE_RING_SIZE - MASK_XENSTORE_IDX(prod);\r\nif ((XENSTORE_RING_SIZE - (prod - cons)) < *len)\r\n*len = XENSTORE_RING_SIZE - (prod - cons);\r\nreturn buf + MASK_XENSTORE_IDX(prod);\r\n}\r\nstatic const void *get_input_chunk(XENSTORE_RING_IDX cons,\r\nXENSTORE_RING_IDX prod,\r\nconst char *buf, uint32_t *len)\r\n{\r\n*len = XENSTORE_RING_SIZE - MASK_XENSTORE_IDX(cons);\r\nif ((prod - cons) < *len)\r\n*len = prod - cons;\r\nreturn buf + MASK_XENSTORE_IDX(cons);\r\n}\r\nstatic int xb_data_to_write(void)\r\n{\r\nstruct xenstore_domain_interface *intf = xen_store_interface;\r\nreturn (intf->req_prod - intf->req_cons) != XENSTORE_RING_SIZE &&\r\n!list_empty(&xb_write_list);\r\n}\r\nstatic int xb_write(const void *data, unsigned int len)\r\n{\r\nstruct xenstore_domain_interface *intf = xen_store_interface;\r\nXENSTORE_RING_IDX cons, prod;\r\nunsigned int bytes = 0;\r\nwhile (len != 0) {\r\nvoid *dst;\r\nunsigned int avail;\r\ncons = intf->req_cons;\r\nprod = intf->req_prod;\r\nif (!check_indexes(cons, prod)) {\r\nintf->req_cons = intf->req_prod = 0;\r\nreturn -EIO;\r\n}\r\nif (!xb_data_to_write())\r\nreturn bytes;\r\nvirt_mb();\r\ndst = get_output_chunk(cons, prod, intf->req, &avail);\r\nif (avail == 0)\r\ncontinue;\r\nif (avail > len)\r\navail = len;\r\nmemcpy(dst, data, avail);\r\ndata += avail;\r\nlen -= avail;\r\nbytes += avail;\r\nvirt_wmb();\r\nintf->req_prod += avail;\r\nif (prod <= intf->req_cons)\r\nnotify_remote_via_evtchn(xen_store_evtchn);\r\n}\r\nreturn bytes;\r\n}\r\nstatic int xb_data_to_read(void)\r\n{\r\nstruct xenstore_domain_interface *intf = xen_store_interface;\r\nreturn (intf->rsp_cons != intf->rsp_prod);\r\n}\r\nstatic int xb_read(void *data, unsigned int len)\r\n{\r\nstruct xenstore_domain_interface *intf = xen_store_interface;\r\nXENSTORE_RING_IDX cons, prod;\r\nunsigned int bytes = 0;\r\nwhile (len != 0) {\r\nunsigned int avail;\r\nconst char *src;\r\ncons = intf->rsp_cons;\r\nprod = intf->rsp_prod;\r\nif (cons == prod)\r\nreturn bytes;\r\nif (!check_indexes(cons, prod)) {\r\nintf->rsp_cons = intf->rsp_prod = 0;\r\nreturn -EIO;\r\n}\r\nsrc = get_input_chunk(cons, prod, intf->rsp, &avail);\r\nif (avail == 0)\r\ncontinue;\r\nif (avail > len)\r\navail = len;\r\nvirt_rmb();\r\nmemcpy(data, src, avail);\r\ndata += avail;\r\nlen -= avail;\r\nbytes += avail;\r\nvirt_mb();\r\nintf->rsp_cons += avail;\r\nif (intf->rsp_prod - cons >= XENSTORE_RING_SIZE)\r\nnotify_remote_via_evtchn(xen_store_evtchn);\r\n}\r\nreturn bytes;\r\n}\r\nstatic int process_msg(void)\r\n{\r\nstatic struct {\r\nstruct xsd_sockmsg msg;\r\nchar *body;\r\nunion {\r\nvoid *alloc;\r\nstruct xs_watch_event *watch;\r\n};\r\nbool in_msg;\r\nbool in_hdr;\r\nunsigned int read;\r\n} state;\r\nstruct xb_req_data *req;\r\nint err;\r\nunsigned int len;\r\nif (!state.in_msg) {\r\nstate.in_msg = true;\r\nstate.in_hdr = true;\r\nstate.read = 0;\r\nmutex_lock(&xs_response_mutex);\r\nif (!xb_data_to_read()) {\r\nmutex_unlock(&xs_response_mutex);\r\nstate.in_msg = false;\r\nreturn 0;\r\n}\r\n}\r\nif (state.in_hdr) {\r\nif (state.read != sizeof(state.msg)) {\r\nerr = xb_read((void *)&state.msg + state.read,\r\nsizeof(state.msg) - state.read);\r\nif (err < 0)\r\ngoto out;\r\nstate.read += err;\r\nif (state.read != sizeof(state.msg))\r\nreturn 0;\r\nif (state.msg.len > XENSTORE_PAYLOAD_MAX) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nlen = state.msg.len + 1;\r\nif (state.msg.type == XS_WATCH_EVENT)\r\nlen += sizeof(*state.watch);\r\nstate.alloc = kmalloc(len, GFP_NOIO | __GFP_HIGH);\r\nif (!state.alloc)\r\nreturn -ENOMEM;\r\nif (state.msg.type == XS_WATCH_EVENT)\r\nstate.body = state.watch->body;\r\nelse\r\nstate.body = state.alloc;\r\nstate.in_hdr = false;\r\nstate.read = 0;\r\n}\r\nerr = xb_read(state.body + state.read, state.msg.len - state.read);\r\nif (err < 0)\r\ngoto out;\r\nstate.read += err;\r\nif (state.read != state.msg.len)\r\nreturn 0;\r\nstate.body[state.msg.len] = '\0';\r\nif (state.msg.type == XS_WATCH_EVENT) {\r\nstate.watch->len = state.msg.len;\r\nerr = xs_watch_msg(state.watch);\r\n} else {\r\nerr = -ENOENT;\r\nmutex_lock(&xb_write_mutex);\r\nlist_for_each_entry(req, &xs_reply_list, list) {\r\nif (req->msg.req_id == state.msg.req_id) {\r\nif (req->state == xb_req_state_wait_reply) {\r\nreq->msg.type = state.msg.type;\r\nreq->msg.len = state.msg.len;\r\nreq->body = state.body;\r\nreq->state = xb_req_state_got_reply;\r\nlist_del(&req->list);\r\nreq->cb(req);\r\n} else {\r\nlist_del(&req->list);\r\nkfree(req);\r\n}\r\nerr = 0;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&xb_write_mutex);\r\nif (err)\r\ngoto out;\r\n}\r\nmutex_unlock(&xs_response_mutex);\r\nstate.in_msg = false;\r\nstate.alloc = NULL;\r\nreturn err;\r\nout:\r\nmutex_unlock(&xs_response_mutex);\r\nstate.in_msg = false;\r\nkfree(state.alloc);\r\nstate.alloc = NULL;\r\nreturn err;\r\n}\r\nstatic int process_writes(void)\r\n{\r\nstatic struct {\r\nstruct xb_req_data *req;\r\nint idx;\r\nunsigned int written;\r\n} state;\r\nvoid *base;\r\nunsigned int len;\r\nint err = 0;\r\nif (!xb_data_to_write())\r\nreturn 0;\r\nmutex_lock(&xb_write_mutex);\r\nif (!state.req) {\r\nstate.req = list_first_entry(&xb_write_list,\r\nstruct xb_req_data, list);\r\nstate.idx = -1;\r\nstate.written = 0;\r\n}\r\nif (state.req->state == xb_req_state_aborted)\r\ngoto out_err;\r\nwhile (state.idx < state.req->num_vecs) {\r\nif (state.idx < 0) {\r\nbase = &state.req->msg;\r\nlen = sizeof(state.req->msg);\r\n} else {\r\nbase = state.req->vec[state.idx].iov_base;\r\nlen = state.req->vec[state.idx].iov_len;\r\n}\r\nerr = xb_write(base + state.written, len - state.written);\r\nif (err < 0)\r\ngoto out_err;\r\nstate.written += err;\r\nif (state.written != len)\r\ngoto out;\r\nstate.idx++;\r\nstate.written = 0;\r\n}\r\nlist_del(&state.req->list);\r\nstate.req->state = xb_req_state_wait_reply;\r\nlist_add_tail(&state.req->list, &xs_reply_list);\r\nstate.req = NULL;\r\nout:\r\nmutex_unlock(&xb_write_mutex);\r\nreturn 0;\r\nout_err:\r\nstate.req->msg.type = XS_ERROR;\r\nstate.req->err = err;\r\nlist_del(&state.req->list);\r\nif (state.req->state == xb_req_state_aborted)\r\nkfree(state.req);\r\nelse {\r\nstate.req->state = xb_req_state_got_reply;\r\nwake_up(&state.req->wq);\r\n}\r\nmutex_unlock(&xb_write_mutex);\r\nstate.req = NULL;\r\nreturn err;\r\n}\r\nstatic int xb_thread_work(void)\r\n{\r\nreturn xb_data_to_read() || xb_data_to_write();\r\n}\r\nstatic int xenbus_thread(void *unused)\r\n{\r\nint err;\r\nwhile (!kthread_should_stop()) {\r\nif (wait_event_interruptible(xb_waitq, xb_thread_work()))\r\ncontinue;\r\nerr = process_msg();\r\nif (err == -ENOMEM)\r\nschedule();\r\nelse if (err)\r\npr_warn_ratelimited("error %d while reading message\n",\r\nerr);\r\nerr = process_writes();\r\nif (err)\r\npr_warn_ratelimited("error %d while writing message\n",\r\nerr);\r\n}\r\nxenbus_task = NULL;\r\nreturn 0;\r\n}\r\nint xb_init_comms(void)\r\n{\r\nstruct xenstore_domain_interface *intf = xen_store_interface;\r\nif (intf->req_prod != intf->req_cons)\r\npr_err("request ring is not quiescent (%08x:%08x)!\n",\r\nintf->req_cons, intf->req_prod);\r\nif (intf->rsp_prod != intf->rsp_cons) {\r\npr_warn("response ring is not quiescent (%08x:%08x): fixing up\n",\r\nintf->rsp_cons, intf->rsp_prod);\r\nif (!reset_devices)\r\nintf->rsp_cons = intf->rsp_prod;\r\n}\r\nif (xenbus_irq) {\r\nrebind_evtchn_irq(xen_store_evtchn, xenbus_irq);\r\n} else {\r\nint err;\r\nerr = bind_evtchn_to_irqhandler(xen_store_evtchn, wake_waiting,\r\n0, "xenbus", &xb_waitq);\r\nif (err < 0) {\r\npr_err("request irq failed %i\n", err);\r\nreturn err;\r\n}\r\nxenbus_irq = err;\r\nif (!xenbus_task) {\r\nxenbus_task = kthread_run(xenbus_thread, NULL,\r\n"xenbus");\r\nif (IS_ERR(xenbus_task))\r\nreturn PTR_ERR(xenbus_task);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid xb_deinit_comms(void)\r\n{\r\nunbind_from_irqhandler(xenbus_irq, &xb_waitq);\r\nxenbus_irq = 0;\r\n}
