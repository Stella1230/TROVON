static inline s32 linear_inter(s32 tmax, s32 tmin, s32 percent,\r\ns32 min_result, bool even)\r\n{\r\ns32 v;\r\nv = (tmax - tmin) * percent;\r\nv = S_DIV_ROUND_UP(v, 100) + tmin;\r\nif (even && (v & 0x1))\r\nreturn max_t(s32, min_result, v - 1);\r\nelse\r\nreturn max_t(s32, min_result, v);\r\n}\r\nstatic void dsi_dphy_timing_calc_clk_zero(struct msm_dsi_dphy_timing *timing,\r\ns32 ui, s32 coeff, s32 pcnt)\r\n{\r\ns32 tmax, tmin, clk_z;\r\ns32 temp;\r\ntemp = 300 * coeff - ((timing->clk_prepare >> 1) + 1) * 2 * ui;\r\ntmin = S_DIV_ROUND_UP(temp, ui) - 2;\r\nif (tmin > 255) {\r\ntmax = 511;\r\nclk_z = linear_inter(2 * tmin, tmin, pcnt, 0, true);\r\n} else {\r\ntmax = 255;\r\nclk_z = linear_inter(tmax, tmin, pcnt, 0, true);\r\n}\r\ntemp = (timing->hs_rqst + timing->clk_prepare + clk_z) & 0x7;\r\ntiming->clk_zero = clk_z + 8 - temp;\r\n}\r\nint msm_dsi_dphy_timing_calc(struct msm_dsi_dphy_timing *timing,\r\nstruct msm_dsi_phy_clk_request *clk_req)\r\n{\r\nconst unsigned long bit_rate = clk_req->bitclk_rate;\r\nconst unsigned long esc_rate = clk_req->escclk_rate;\r\ns32 ui, lpx;\r\ns32 tmax, tmin;\r\ns32 pcnt0 = 10;\r\ns32 pcnt1 = (bit_rate > 1200000000) ? 15 : 10;\r\ns32 pcnt2 = 10;\r\ns32 pcnt3 = (bit_rate > 180000000) ? 10 : 40;\r\ns32 coeff = 1000;\r\ns32 temp;\r\nif (!bit_rate || !esc_rate)\r\nreturn -EINVAL;\r\nui = mult_frac(NSEC_PER_MSEC, coeff, bit_rate / 1000);\r\nlpx = mult_frac(NSEC_PER_MSEC, coeff, esc_rate / 1000);\r\ntmax = S_DIV_ROUND_UP(95 * coeff, ui) - 2;\r\ntmin = S_DIV_ROUND_UP(38 * coeff, ui) - 2;\r\ntiming->clk_prepare = linear_inter(tmax, tmin, pcnt0, 0, true);\r\ntemp = lpx / ui;\r\nif (temp & 0x1)\r\ntiming->hs_rqst = temp;\r\nelse\r\ntiming->hs_rqst = max_t(s32, 0, temp - 2);\r\ndsi_dphy_timing_calc_clk_zero(timing, ui, coeff, pcnt2);\r\ntemp = 105 * coeff + 12 * ui - 20 * coeff;\r\ntmax = S_DIV_ROUND_UP(temp, ui) - 2;\r\ntmin = S_DIV_ROUND_UP(60 * coeff, ui) - 2;\r\ntiming->clk_trail = linear_inter(tmax, tmin, pcnt3, 0, true);\r\ntemp = 85 * coeff + 6 * ui;\r\ntmax = S_DIV_ROUND_UP(temp, ui) - 2;\r\ntemp = 40 * coeff + 4 * ui;\r\ntmin = S_DIV_ROUND_UP(temp, ui) - 2;\r\ntiming->hs_prepare = linear_inter(tmax, tmin, pcnt1, 0, true);\r\ntmax = 255;\r\ntemp = ((timing->hs_prepare >> 1) + 1) * 2 * ui + 2 * ui;\r\ntemp = 145 * coeff + 10 * ui - temp;\r\ntmin = S_DIV_ROUND_UP(temp, ui) - 2;\r\ntiming->hs_zero = linear_inter(tmax, tmin, pcnt2, 24, true);\r\ntemp = 105 * coeff + 12 * ui - 20 * coeff;\r\ntmax = S_DIV_ROUND_UP(temp, ui) - 2;\r\ntemp = 60 * coeff + 4 * ui;\r\ntmin = DIV_ROUND_UP(temp, ui) - 2;\r\ntiming->hs_trail = linear_inter(tmax, tmin, pcnt3, 0, true);\r\ntmax = 255;\r\ntmin = S_DIV_ROUND_UP(100 * coeff, ui) - 2;\r\ntiming->hs_exit = linear_inter(tmax, tmin, pcnt2, 0, true);\r\ntmax = 63;\r\ntemp = ((timing->hs_exit >> 1) + 1) * 2 * ui;\r\ntemp = 60 * coeff + 52 * ui - 24 * ui - temp;\r\ntmin = S_DIV_ROUND_UP(temp, 8 * ui) - 1;\r\ntiming->shared_timings.clk_post = linear_inter(tmax, tmin, pcnt2, 0,\r\nfalse);\r\ntmax = 63;\r\ntemp = ((timing->clk_prepare >> 1) + 1) * 2 * ui;\r\ntemp += ((timing->clk_zero >> 1) + 1) * 2 * ui;\r\ntemp += 8 * ui + lpx;\r\ntmin = S_DIV_ROUND_UP(temp, 8 * ui) - 1;\r\nif (tmin > tmax) {\r\ntemp = linear_inter(2 * tmax, tmin, pcnt2, 0, false);\r\ntiming->shared_timings.clk_pre = temp >> 1;\r\ntiming->shared_timings.clk_pre_inc_by_2 = true;\r\n} else {\r\ntiming->shared_timings.clk_pre =\r\nlinear_inter(tmax, tmin, pcnt2, 0, false);\r\ntiming->shared_timings.clk_pre_inc_by_2 = false;\r\n}\r\ntiming->ta_go = 3;\r\ntiming->ta_sure = 0;\r\ntiming->ta_get = 4;\r\nDBG("PHY timings: %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d",\r\ntiming->shared_timings.clk_pre, timing->shared_timings.clk_post,\r\ntiming->shared_timings.clk_pre_inc_by_2, timing->clk_zero,\r\ntiming->clk_trail, timing->clk_prepare, timing->hs_exit,\r\ntiming->hs_zero, timing->hs_prepare, timing->hs_trail,\r\ntiming->hs_rqst);\r\nreturn 0;\r\n}\r\nint msm_dsi_dphy_timing_calc_v2(struct msm_dsi_dphy_timing *timing,\r\nstruct msm_dsi_phy_clk_request *clk_req)\r\n{\r\nconst unsigned long bit_rate = clk_req->bitclk_rate;\r\nconst unsigned long esc_rate = clk_req->escclk_rate;\r\ns32 ui, ui_x8, lpx;\r\ns32 tmax, tmin;\r\ns32 pcnt0 = 50;\r\ns32 pcnt1 = 50;\r\ns32 pcnt2 = 10;\r\ns32 pcnt3 = 30;\r\ns32 pcnt4 = 10;\r\ns32 pcnt5 = 2;\r\ns32 coeff = 1000;\r\ns32 hb_en, hb_en_ckln, pd_ckln, pd;\r\ns32 val, val_ckln;\r\ns32 temp;\r\nif (!bit_rate || !esc_rate)\r\nreturn -EINVAL;\r\ntiming->hs_halfbyte_en = 0;\r\nhb_en = 0;\r\ntiming->hs_halfbyte_en_ckln = 0;\r\nhb_en_ckln = 0;\r\ntiming->hs_prep_dly_ckln = (bit_rate > 100000000) ? 0 : 3;\r\npd_ckln = timing->hs_prep_dly_ckln;\r\ntiming->hs_prep_dly = (bit_rate > 120000000) ? 0 : 1;\r\npd = timing->hs_prep_dly;\r\nval = (hb_en << 2) + (pd << 1);\r\nval_ckln = (hb_en_ckln << 2) + (pd_ckln << 1);\r\nui = mult_frac(NSEC_PER_MSEC, coeff, bit_rate / 1000);\r\nui_x8 = ui << 3;\r\nlpx = mult_frac(NSEC_PER_MSEC, coeff, esc_rate / 1000);\r\ntemp = S_DIV_ROUND_UP(38 * coeff - val_ckln * ui, ui_x8);\r\ntmin = max_t(s32, temp, 0);\r\ntemp = (95 * coeff - val_ckln * ui) / ui_x8;\r\ntmax = max_t(s32, temp, 0);\r\ntiming->clk_prepare = linear_inter(tmax, tmin, pcnt0, 0, false);\r\ntemp = 300 * coeff - ((timing->clk_prepare << 3) + val_ckln) * ui;\r\ntmin = S_DIV_ROUND_UP(temp - 11 * ui, ui_x8) - 3;\r\ntmax = (tmin > 255) ? 511 : 255;\r\ntiming->clk_zero = linear_inter(tmax, tmin, pcnt5, 0, false);\r\ntmin = DIV_ROUND_UP(60 * coeff + 3 * ui, ui_x8);\r\ntemp = 105 * coeff + 12 * ui - 20 * coeff;\r\ntmax = (temp + 3 * ui) / ui_x8;\r\ntiming->clk_trail = linear_inter(tmax, tmin, pcnt3, 0, false);\r\ntemp = S_DIV_ROUND_UP(40 * coeff + 4 * ui - val * ui, ui_x8);\r\ntmin = max_t(s32, temp, 0);\r\ntemp = (85 * coeff + 6 * ui - val * ui) / ui_x8;\r\ntmax = max_t(s32, temp, 0);\r\ntiming->hs_prepare = linear_inter(tmax, tmin, pcnt1, 0, false);\r\ntemp = 145 * coeff + 10 * ui - ((timing->hs_prepare << 3) + val) * ui;\r\ntmin = S_DIV_ROUND_UP(temp - 11 * ui, ui_x8) - 3;\r\ntmax = 255;\r\ntiming->hs_zero = linear_inter(tmax, tmin, pcnt4, 0, false);\r\ntmin = DIV_ROUND_UP(60 * coeff + 4 * ui + 3 * ui, ui_x8);\r\ntemp = 105 * coeff + 12 * ui - 20 * coeff;\r\ntmax = (temp + 3 * ui) / ui_x8;\r\ntiming->hs_trail = linear_inter(tmax, tmin, pcnt3, 0, false);\r\ntemp = 50 * coeff + ((hb_en << 2) - 8) * ui;\r\ntiming->hs_rqst = S_DIV_ROUND_UP(temp, ui_x8);\r\ntmin = DIV_ROUND_UP(100 * coeff, ui_x8) - 1;\r\ntmax = 255;\r\ntiming->hs_exit = linear_inter(tmax, tmin, pcnt2, 0, false);\r\ntemp = 50 * coeff + ((hb_en_ckln << 2) - 8) * ui;\r\ntiming->hs_rqst_ckln = S_DIV_ROUND_UP(temp, ui_x8);\r\ntemp = 60 * coeff + 52 * ui - 43 * ui;\r\ntmin = DIV_ROUND_UP(temp, ui_x8) - 1;\r\ntmax = 63;\r\ntiming->shared_timings.clk_post =\r\nlinear_inter(tmax, tmin, pcnt2, 0, false);\r\ntemp = 8 * ui + ((timing->clk_prepare << 3) + val_ckln) * ui;\r\ntemp += (((timing->clk_zero + 3) << 3) + 11 - (pd_ckln << 1)) * ui;\r\ntemp += hb_en_ckln ? (((timing->hs_rqst_ckln << 3) + 4) * ui) :\r\n(((timing->hs_rqst_ckln << 3) + 8) * ui);\r\ntmin = S_DIV_ROUND_UP(temp, ui_x8) - 1;\r\ntmax = 63;\r\nif (tmin > tmax) {\r\ntemp = linear_inter(tmax << 1, tmin, pcnt2, 0, false);\r\ntiming->shared_timings.clk_pre = temp >> 1;\r\ntiming->shared_timings.clk_pre_inc_by_2 = 1;\r\n} else {\r\ntiming->shared_timings.clk_pre =\r\nlinear_inter(tmax, tmin, pcnt2, 0, false);\r\ntiming->shared_timings.clk_pre_inc_by_2 = 0;\r\n}\r\ntiming->ta_go = 3;\r\ntiming->ta_sure = 0;\r\ntiming->ta_get = 4;\r\nDBG("%d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d",\r\ntiming->shared_timings.clk_pre, timing->shared_timings.clk_post,\r\ntiming->shared_timings.clk_pre_inc_by_2, timing->clk_zero,\r\ntiming->clk_trail, timing->clk_prepare, timing->hs_exit,\r\ntiming->hs_zero, timing->hs_prepare, timing->hs_trail,\r\ntiming->hs_rqst, timing->hs_rqst_ckln, timing->hs_halfbyte_en,\r\ntiming->hs_halfbyte_en_ckln, timing->hs_prep_dly,\r\ntiming->hs_prep_dly_ckln);\r\nreturn 0;\r\n}\r\nvoid msm_dsi_phy_set_src_pll(struct msm_dsi_phy *phy, int pll_id, u32 reg,\r\nu32 bit_mask)\r\n{\r\nint phy_id = phy->id;\r\nu32 val;\r\nif ((phy_id >= DSI_MAX) || (pll_id >= DSI_MAX))\r\nreturn;\r\nval = dsi_phy_read(phy->base + reg);\r\nif (phy->cfg->src_pll_truthtable[phy_id][pll_id])\r\ndsi_phy_write(phy->base + reg, val | bit_mask);\r\nelse\r\ndsi_phy_write(phy->base + reg, val & (~bit_mask));\r\n}\r\nstatic int dsi_phy_regulator_init(struct msm_dsi_phy *phy)\r\n{\r\nstruct regulator_bulk_data *s = phy->supplies;\r\nconst struct dsi_reg_entry *regs = phy->cfg->reg_cfg.regs;\r\nstruct device *dev = &phy->pdev->dev;\r\nint num = phy->cfg->reg_cfg.num;\r\nint i, ret;\r\nfor (i = 0; i < num; i++)\r\ns[i].supply = regs[i].name;\r\nret = devm_regulator_bulk_get(dev, num, s);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: failed to init regulator, ret=%d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dsi_phy_regulator_disable(struct msm_dsi_phy *phy)\r\n{\r\nstruct regulator_bulk_data *s = phy->supplies;\r\nconst struct dsi_reg_entry *regs = phy->cfg->reg_cfg.regs;\r\nint num = phy->cfg->reg_cfg.num;\r\nint i;\r\nDBG("");\r\nfor (i = num - 1; i >= 0; i--)\r\nif (regs[i].disable_load >= 0)\r\nregulator_set_load(s[i].consumer, regs[i].disable_load);\r\nregulator_bulk_disable(num, s);\r\n}\r\nstatic int dsi_phy_regulator_enable(struct msm_dsi_phy *phy)\r\n{\r\nstruct regulator_bulk_data *s = phy->supplies;\r\nconst struct dsi_reg_entry *regs = phy->cfg->reg_cfg.regs;\r\nstruct device *dev = &phy->pdev->dev;\r\nint num = phy->cfg->reg_cfg.num;\r\nint ret, i;\r\nDBG("");\r\nfor (i = 0; i < num; i++) {\r\nif (regs[i].enable_load >= 0) {\r\nret = regulator_set_load(s[i].consumer,\r\nregs[i].enable_load);\r\nif (ret < 0) {\r\ndev_err(dev,\r\n"regulator %d set op mode failed, %d\n",\r\ni, ret);\r\ngoto fail;\r\n}\r\n}\r\n}\r\nret = regulator_bulk_enable(num, s);\r\nif (ret < 0) {\r\ndev_err(dev, "regulator enable failed, %d\n", ret);\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\nfor (i--; i >= 0; i--)\r\nregulator_set_load(s[i].consumer, regs[i].disable_load);\r\nreturn ret;\r\n}\r\nstatic int dsi_phy_enable_resource(struct msm_dsi_phy *phy)\r\n{\r\nstruct device *dev = &phy->pdev->dev;\r\nint ret;\r\npm_runtime_get_sync(dev);\r\nret = clk_prepare_enable(phy->ahb_clk);\r\nif (ret) {\r\ndev_err(dev, "%s: can't enable ahb clk, %d\n", __func__, ret);\r\npm_runtime_put_sync(dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic void dsi_phy_disable_resource(struct msm_dsi_phy *phy)\r\n{\r\nclk_disable_unprepare(phy->ahb_clk);\r\npm_runtime_put_sync(&phy->pdev->dev);\r\n}\r\nstatic int dsi_phy_get_id(struct msm_dsi_phy *phy)\r\n{\r\nstruct platform_device *pdev = phy->pdev;\r\nconst struct msm_dsi_phy_cfg *cfg = phy->cfg;\r\nstruct resource *res;\r\nint i;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "dsi_phy");\r\nif (!res)\r\nreturn -EINVAL;\r\nfor (i = 0; i < cfg->num_dsi_phy; i++) {\r\nif (cfg->io_start[i] == res->start)\r\nreturn i;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint msm_dsi_phy_init_common(struct msm_dsi_phy *phy)\r\n{\r\nstruct platform_device *pdev = phy->pdev;\r\nint ret = 0;\r\nphy->reg_base = msm_ioremap(pdev, "dsi_phy_regulator",\r\n"DSI_PHY_REG");\r\nif (IS_ERR(phy->reg_base)) {\r\ndev_err(&pdev->dev, "%s: failed to map phy regulator base\n",\r\n__func__);\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int dsi_phy_driver_probe(struct platform_device *pdev)\r\n{\r\nstruct msm_dsi_phy *phy;\r\nstruct device *dev = &pdev->dev;\r\nconst struct of_device_id *match;\r\nint ret;\r\nphy = devm_kzalloc(dev, sizeof(*phy), GFP_KERNEL);\r\nif (!phy)\r\nreturn -ENOMEM;\r\nmatch = of_match_node(dsi_phy_dt_match, dev->of_node);\r\nif (!match)\r\nreturn -ENODEV;\r\nphy->cfg = match->data;\r\nphy->pdev = pdev;\r\nphy->id = dsi_phy_get_id(phy);\r\nif (phy->id < 0) {\r\nret = phy->id;\r\ndev_err(dev, "%s: couldn't identify PHY index, %d\n",\r\n__func__, ret);\r\ngoto fail;\r\n}\r\nphy->regulator_ldo_mode = of_property_read_bool(dev->of_node,\r\n"qcom,dsi-phy-regulator-ldo-mode");\r\nphy->base = msm_ioremap(pdev, "dsi_phy", "DSI_PHY");\r\nif (IS_ERR(phy->base)) {\r\ndev_err(dev, "%s: failed to map phy base\n", __func__);\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nret = dsi_phy_regulator_init(phy);\r\nif (ret) {\r\ndev_err(dev, "%s: failed to init regulator\n", __func__);\r\ngoto fail;\r\n}\r\nphy->ahb_clk = devm_clk_get(dev, "iface_clk");\r\nif (IS_ERR(phy->ahb_clk)) {\r\ndev_err(dev, "%s: Unable to get ahb clk\n", __func__);\r\nret = PTR_ERR(phy->ahb_clk);\r\ngoto fail;\r\n}\r\nif (phy->cfg->ops.init) {\r\nret = phy->cfg->ops.init(phy);\r\nif (ret)\r\ngoto fail;\r\n}\r\nret = dsi_phy_enable_resource(phy);\r\nif (ret)\r\ngoto fail;\r\nphy->pll = msm_dsi_pll_init(pdev, phy->cfg->type, phy->id);\r\nif (!phy->pll)\r\ndev_info(dev,\r\n"%s: pll init failed, need separate pll clk driver\n",\r\n__func__);\r\ndsi_phy_disable_resource(phy);\r\nplatform_set_drvdata(pdev, phy);\r\nreturn 0;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int dsi_phy_driver_remove(struct platform_device *pdev)\r\n{\r\nstruct msm_dsi_phy *phy = platform_get_drvdata(pdev);\r\nif (phy && phy->pll) {\r\nmsm_dsi_pll_destroy(phy->pll);\r\nphy->pll = NULL;\r\n}\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nvoid __init msm_dsi_phy_driver_register(void)\r\n{\r\nplatform_driver_register(&dsi_phy_platform_driver);\r\n}\r\nvoid __exit msm_dsi_phy_driver_unregister(void)\r\n{\r\nplatform_driver_unregister(&dsi_phy_platform_driver);\r\n}\r\nint msm_dsi_phy_enable(struct msm_dsi_phy *phy, int src_pll_id,\r\nstruct msm_dsi_phy_clk_request *clk_req)\r\n{\r\nstruct device *dev = &phy->pdev->dev;\r\nint ret;\r\nif (!phy || !phy->cfg->ops.enable)\r\nreturn -EINVAL;\r\nret = dsi_phy_enable_resource(phy);\r\nif (ret) {\r\ndev_err(dev, "%s: resource enable failed, %d\n",\r\n__func__, ret);\r\ngoto res_en_fail;\r\n}\r\nret = dsi_phy_regulator_enable(phy);\r\nif (ret) {\r\ndev_err(dev, "%s: regulator enable failed, %d\n",\r\n__func__, ret);\r\ngoto reg_en_fail;\r\n}\r\nret = phy->cfg->ops.enable(phy, src_pll_id, clk_req);\r\nif (ret) {\r\ndev_err(dev, "%s: phy enable failed, %d\n", __func__, ret);\r\ngoto phy_en_fail;\r\n}\r\nif (phy->usecase != MSM_DSI_PHY_SLAVE) {\r\nret = msm_dsi_pll_restore_state(phy->pll);\r\nif (ret) {\r\ndev_err(dev, "%s: failed to restore pll state, %d\n",\r\n__func__, ret);\r\ngoto pll_restor_fail;\r\n}\r\n}\r\nreturn 0;\r\npll_restor_fail:\r\nif (phy->cfg->ops.disable)\r\nphy->cfg->ops.disable(phy);\r\nphy_en_fail:\r\ndsi_phy_regulator_disable(phy);\r\nreg_en_fail:\r\ndsi_phy_disable_resource(phy);\r\nres_en_fail:\r\nreturn ret;\r\n}\r\nvoid msm_dsi_phy_disable(struct msm_dsi_phy *phy)\r\n{\r\nif (!phy || !phy->cfg->ops.disable)\r\nreturn;\r\nif (phy->usecase != MSM_DSI_PHY_SLAVE)\r\nmsm_dsi_pll_save_state(phy->pll);\r\nphy->cfg->ops.disable(phy);\r\ndsi_phy_regulator_disable(phy);\r\ndsi_phy_disable_resource(phy);\r\n}\r\nvoid msm_dsi_phy_get_shared_timings(struct msm_dsi_phy *phy,\r\nstruct msm_dsi_phy_shared_timings *shared_timings)\r\n{\r\nmemcpy(shared_timings, &phy->timing.shared_timings,\r\nsizeof(*shared_timings));\r\n}\r\nstruct msm_dsi_pll *msm_dsi_phy_get_pll(struct msm_dsi_phy *phy)\r\n{\r\nif (!phy)\r\nreturn NULL;\r\nreturn phy->pll;\r\n}\r\nvoid msm_dsi_phy_set_usecase(struct msm_dsi_phy *phy,\r\nenum msm_dsi_phy_usecase uc)\r\n{\r\nif (phy)\r\nphy->usecase = uc;\r\n}
