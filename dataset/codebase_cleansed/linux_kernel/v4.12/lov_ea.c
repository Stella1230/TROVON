static int lsm_lmm_verify_common(struct lov_mds_md *lmm, int lmm_bytes,\r\n__u16 stripe_count)\r\n{\r\nif (stripe_count > LOV_V1_INSANE_STRIPE_COUNT) {\r\nCERROR("bad stripe count %d\n", stripe_count);\r\nlov_dump_lmm_common(D_WARNING, lmm);\r\nreturn -EINVAL;\r\n}\r\nif (lmm_oi_id(&lmm->lmm_oi) == 0) {\r\nCERROR("zero object id\n");\r\nlov_dump_lmm_common(D_WARNING, lmm);\r\nreturn -EINVAL;\r\n}\r\nif (lov_pattern(le32_to_cpu(lmm->lmm_pattern)) != LOV_PATTERN_RAID0) {\r\nCERROR("bad striping pattern\n");\r\nlov_dump_lmm_common(D_WARNING, lmm);\r\nreturn -EINVAL;\r\n}\r\nif (lmm->lmm_stripe_size == 0 ||\r\n(le32_to_cpu(lmm->lmm_stripe_size) &\r\n(LOV_MIN_STRIPE_SIZE - 1)) != 0) {\r\nCERROR("bad stripe size %u\n",\r\nle32_to_cpu(lmm->lmm_stripe_size));\r\nlov_dump_lmm_common(D_WARNING, lmm);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstruct lov_stripe_md *lsm_alloc_plain(u16 stripe_count)\r\n{\r\nsize_t oinfo_ptrs_size, lsm_size;\r\nstruct lov_stripe_md *lsm;\r\nstruct lov_oinfo *loi;\r\nint i;\r\nLASSERT(stripe_count <= LOV_MAX_STRIPE_COUNT);\r\noinfo_ptrs_size = sizeof(struct lov_oinfo *) * stripe_count;\r\nlsm_size = sizeof(*lsm) + oinfo_ptrs_size;\r\nlsm = libcfs_kvzalloc(lsm_size, GFP_NOFS);\r\nif (!lsm)\r\nreturn NULL;\r\nfor (i = 0; i < stripe_count; i++) {\r\nloi = kmem_cache_zalloc(lov_oinfo_slab, GFP_NOFS);\r\nif (!loi)\r\ngoto err;\r\nlsm->lsm_oinfo[i] = loi;\r\n}\r\nlsm->lsm_stripe_count = stripe_count;\r\nreturn lsm;\r\nerr:\r\nwhile (--i >= 0)\r\nkmem_cache_free(lov_oinfo_slab, lsm->lsm_oinfo[i]);\r\nkvfree(lsm);\r\nreturn NULL;\r\n}\r\nvoid lsm_free_plain(struct lov_stripe_md *lsm)\r\n{\r\n__u16 stripe_count = lsm->lsm_stripe_count;\r\nint i;\r\nfor (i = 0; i < stripe_count; i++)\r\nkmem_cache_free(lov_oinfo_slab, lsm->lsm_oinfo[i]);\r\nkvfree(lsm);\r\n}\r\nstatic loff_t lov_tgt_maxbytes(struct lov_tgt_desc *tgt)\r\n{\r\nloff_t maxbytes = LUSTRE_EXT3_STRIPE_MAXBYTES;\r\nstruct obd_import *imp;\r\nif (!tgt->ltd_active)\r\nreturn maxbytes;\r\nimp = tgt->ltd_obd->u.cli.cl_import;\r\nif (!imp)\r\nreturn maxbytes;\r\nspin_lock(&imp->imp_lock);\r\nif (imp->imp_state == LUSTRE_IMP_FULL &&\r\n(imp->imp_connect_data.ocd_connect_flags & OBD_CONNECT_MAXBYTES) &&\r\nimp->imp_connect_data.ocd_maxbytes > 0)\r\nmaxbytes = imp->imp_connect_data.ocd_maxbytes;\r\nspin_unlock(&imp->imp_lock);\r\nreturn maxbytes;\r\n}\r\nstatic int lsm_unpackmd_common(struct lov_obd *lov,\r\nstruct lov_stripe_md *lsm,\r\nstruct lov_mds_md *lmm,\r\nstruct lov_ost_data_v1 *objects)\r\n{\r\nloff_t stripe_maxbytes = LLONG_MAX;\r\nunsigned int stripe_count;\r\nstruct lov_oinfo *loi;\r\nunsigned int i;\r\nlmm_oi_le_to_cpu(&lsm->lsm_oi, &lmm->lmm_oi);\r\nlsm->lsm_stripe_size = le32_to_cpu(lmm->lmm_stripe_size);\r\nlsm->lsm_pattern = le32_to_cpu(lmm->lmm_pattern);\r\nlsm->lsm_layout_gen = le16_to_cpu(lmm->lmm_layout_gen);\r\nlsm->lsm_pool_name[0] = '\0';\r\nstripe_count = lsm_is_released(lsm) ? 0 : lsm->lsm_stripe_count;\r\nfor (i = 0; i < stripe_count; i++) {\r\nloff_t tgt_bytes;\r\nloi = lsm->lsm_oinfo[i];\r\nostid_le_to_cpu(&objects[i].l_ost_oi, &loi->loi_oi);\r\nloi->loi_ost_idx = le32_to_cpu(objects[i].l_ost_idx);\r\nloi->loi_ost_gen = le32_to_cpu(objects[i].l_ost_gen);\r\nif (lov_oinfo_is_dummy(loi))\r\ncontinue;\r\nif (loi->loi_ost_idx >= lov->desc.ld_tgt_count &&\r\n!lov2obd(lov)->obd_process_conf) {\r\nCERROR("%s: OST index %d more than OST count %d\n",\r\n(char *)lov->desc.ld_uuid.uuid,\r\nloi->loi_ost_idx, lov->desc.ld_tgt_count);\r\nlov_dump_lmm_v1(D_WARNING, lmm);\r\nreturn -EINVAL;\r\n}\r\nif (!lov->lov_tgts[loi->loi_ost_idx]) {\r\nCERROR("%s: OST index %d missing\n",\r\n(char *)lov->desc.ld_uuid.uuid,\r\nloi->loi_ost_idx);\r\nlov_dump_lmm_v1(D_WARNING, lmm);\r\ncontinue;\r\n}\r\ntgt_bytes = lov_tgt_maxbytes(lov->lov_tgts[loi->loi_ost_idx]);\r\nstripe_maxbytes = min_t(loff_t, stripe_maxbytes, tgt_bytes);\r\n}\r\nif (stripe_maxbytes == LLONG_MAX)\r\nstripe_maxbytes = LUSTRE_EXT3_STRIPE_MAXBYTES;\r\nif (!lsm->lsm_stripe_count)\r\nlsm->lsm_maxbytes = stripe_maxbytes * lov->desc.ld_tgt_count;\r\nelse\r\nlsm->lsm_maxbytes = stripe_maxbytes * lsm->lsm_stripe_count;\r\nreturn 0;\r\n}\r\nstatic void\r\nlsm_stripe_by_index_plain(struct lov_stripe_md *lsm, int *stripeno,\r\nloff_t *lov_off, loff_t *swidth)\r\n{\r\nif (swidth)\r\n*swidth = (u64)lsm->lsm_stripe_size * lsm->lsm_stripe_count;\r\n}\r\nstatic void\r\nlsm_stripe_by_offset_plain(struct lov_stripe_md *lsm, int *stripeno,\r\nloff_t *lov_off, loff_t *swidth)\r\n{\r\nif (swidth)\r\n*swidth = (u64)lsm->lsm_stripe_size * lsm->lsm_stripe_count;\r\n}\r\nstatic int lsm_lmm_verify_v1(struct lov_mds_md_v1 *lmm, int lmm_bytes,\r\n__u16 *stripe_count)\r\n{\r\nif (lmm_bytes < sizeof(*lmm)) {\r\nCERROR("lov_mds_md_v1 too small: %d, need at least %d\n",\r\nlmm_bytes, (int)sizeof(*lmm));\r\nreturn -EINVAL;\r\n}\r\n*stripe_count = le16_to_cpu(lmm->lmm_stripe_count);\r\nif (le32_to_cpu(lmm->lmm_pattern) & LOV_PATTERN_F_RELEASED)\r\n*stripe_count = 0;\r\nif (lmm_bytes < lov_mds_md_size(*stripe_count, LOV_MAGIC_V1)) {\r\nCERROR("LOV EA V1 too small: %d, need %d\n",\r\nlmm_bytes, lov_mds_md_size(*stripe_count, LOV_MAGIC_V1));\r\nlov_dump_lmm_common(D_WARNING, lmm);\r\nreturn -EINVAL;\r\n}\r\nreturn lsm_lmm_verify_common(lmm, lmm_bytes, *stripe_count);\r\n}\r\nstatic int lsm_unpackmd_v1(struct lov_obd *lov, struct lov_stripe_md *lsm,\r\nstruct lov_mds_md_v1 *lmm)\r\n{\r\nreturn lsm_unpackmd_common(lov, lsm, lmm, lmm->lmm_objects);\r\n}\r\nstatic int lsm_lmm_verify_v3(struct lov_mds_md *lmmv1, int lmm_bytes,\r\n__u16 *stripe_count)\r\n{\r\nstruct lov_mds_md_v3 *lmm;\r\nlmm = (struct lov_mds_md_v3 *)lmmv1;\r\nif (lmm_bytes < sizeof(*lmm)) {\r\nCERROR("lov_mds_md_v3 too small: %d, need at least %d\n",\r\nlmm_bytes, (int)sizeof(*lmm));\r\nreturn -EINVAL;\r\n}\r\n*stripe_count = le16_to_cpu(lmm->lmm_stripe_count);\r\nif (le32_to_cpu(lmm->lmm_pattern) & LOV_PATTERN_F_RELEASED)\r\n*stripe_count = 0;\r\nif (lmm_bytes < lov_mds_md_size(*stripe_count, LOV_MAGIC_V3)) {\r\nCERROR("LOV EA V3 too small: %d, need %d\n",\r\nlmm_bytes, lov_mds_md_size(*stripe_count, LOV_MAGIC_V3));\r\nlov_dump_lmm_common(D_WARNING, lmm);\r\nreturn -EINVAL;\r\n}\r\nreturn lsm_lmm_verify_common((struct lov_mds_md_v1 *)lmm, lmm_bytes,\r\n*stripe_count);\r\n}\r\nstatic int lsm_unpackmd_v3(struct lov_obd *lov, struct lov_stripe_md *lsm,\r\nstruct lov_mds_md *lmm)\r\n{\r\nstruct lov_mds_md_v3 *lmm_v3 = (struct lov_mds_md_v3 *)lmm;\r\nsize_t cplen = 0;\r\nint rc;\r\nrc = lsm_unpackmd_common(lov, lsm, lmm, lmm_v3->lmm_objects);\r\nif (rc)\r\nreturn rc;\r\ncplen = strlcpy(lsm->lsm_pool_name, lmm_v3->lmm_pool_name,\r\nsizeof(lsm->lsm_pool_name));\r\nif (cplen >= sizeof(lsm->lsm_pool_name))\r\nreturn -E2BIG;\r\nreturn 0;\r\n}\r\nvoid dump_lsm(unsigned int level, const struct lov_stripe_md *lsm)\r\n{\r\nCDEBUG(level, "lsm %p, objid " DOSTID ", maxbytes %#llx, magic 0x%08X, stripe_size %u, stripe_count %u, refc: %d, layout_gen %u, pool [" LOV_POOLNAMEF "]\n",\r\nlsm,\r\nPOSTID(&lsm->lsm_oi), lsm->lsm_maxbytes, lsm->lsm_magic,\r\nlsm->lsm_stripe_size, lsm->lsm_stripe_count,\r\natomic_read(&lsm->lsm_refc), lsm->lsm_layout_gen,\r\nlsm->lsm_pool_name);\r\n}
