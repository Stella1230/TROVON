void ocrdma_get_guid(struct ocrdma_dev *dev, u8 *guid)\r\n{\r\nu8 mac_addr[6];\r\nmemcpy(&mac_addr[0], &dev->nic_info.mac_addr[0], ETH_ALEN);\r\nguid[0] = mac_addr[0] ^ 2;\r\nguid[1] = mac_addr[1];\r\nguid[2] = mac_addr[2];\r\nguid[3] = 0xff;\r\nguid[4] = 0xfe;\r\nguid[5] = mac_addr[3];\r\nguid[6] = mac_addr[4];\r\nguid[7] = mac_addr[5];\r\n}\r\nstatic enum rdma_link_layer ocrdma_link_layer(struct ib_device *device,\r\nu8 port_num)\r\n{\r\nreturn IB_LINK_LAYER_ETHERNET;\r\n}\r\nstatic int ocrdma_port_immutable(struct ib_device *ibdev, u8 port_num,\r\nstruct ib_port_immutable *immutable)\r\n{\r\nstruct ib_port_attr attr;\r\nstruct ocrdma_dev *dev;\r\nint err;\r\ndev = get_ocrdma_dev(ibdev);\r\nimmutable->core_cap_flags = RDMA_CORE_PORT_IBA_ROCE;\r\nif (ocrdma_is_udp_encap_supported(dev))\r\nimmutable->core_cap_flags |= RDMA_CORE_CAP_PROT_ROCE_UDP_ENCAP;\r\nerr = ib_query_port(ibdev, port_num, &attr);\r\nif (err)\r\nreturn err;\r\nimmutable->pkey_tbl_len = attr.pkey_tbl_len;\r\nimmutable->gid_tbl_len = attr.gid_tbl_len;\r\nimmutable->max_mad_size = IB_MGMT_MAD_SIZE;\r\nreturn 0;\r\n}\r\nstatic void get_dev_fw_str(struct ib_device *device, char *str,\r\nsize_t str_len)\r\n{\r\nstruct ocrdma_dev *dev = get_ocrdma_dev(device);\r\nsnprintf(str, str_len, "%s", &dev->attr.fw_ver[0]);\r\n}\r\nstatic int ocrdma_register_device(struct ocrdma_dev *dev)\r\n{\r\nstrlcpy(dev->ibdev.name, "ocrdma%d", IB_DEVICE_NAME_MAX);\r\nocrdma_get_guid(dev, (u8 *)&dev->ibdev.node_guid);\r\nBUILD_BUG_ON(sizeof(OCRDMA_NODE_DESC) > IB_DEVICE_NODE_DESC_MAX);\r\nmemcpy(dev->ibdev.node_desc, OCRDMA_NODE_DESC,\r\nsizeof(OCRDMA_NODE_DESC));\r\ndev->ibdev.owner = THIS_MODULE;\r\ndev->ibdev.uverbs_abi_ver = OCRDMA_ABI_VERSION;\r\ndev->ibdev.uverbs_cmd_mask =\r\nOCRDMA_UVERBS(GET_CONTEXT) |\r\nOCRDMA_UVERBS(QUERY_DEVICE) |\r\nOCRDMA_UVERBS(QUERY_PORT) |\r\nOCRDMA_UVERBS(ALLOC_PD) |\r\nOCRDMA_UVERBS(DEALLOC_PD) |\r\nOCRDMA_UVERBS(REG_MR) |\r\nOCRDMA_UVERBS(DEREG_MR) |\r\nOCRDMA_UVERBS(CREATE_COMP_CHANNEL) |\r\nOCRDMA_UVERBS(CREATE_CQ) |\r\nOCRDMA_UVERBS(RESIZE_CQ) |\r\nOCRDMA_UVERBS(DESTROY_CQ) |\r\nOCRDMA_UVERBS(REQ_NOTIFY_CQ) |\r\nOCRDMA_UVERBS(CREATE_QP) |\r\nOCRDMA_UVERBS(MODIFY_QP) |\r\nOCRDMA_UVERBS(QUERY_QP) |\r\nOCRDMA_UVERBS(DESTROY_QP) |\r\nOCRDMA_UVERBS(POLL_CQ) |\r\nOCRDMA_UVERBS(POST_SEND) |\r\nOCRDMA_UVERBS(POST_RECV);\r\ndev->ibdev.uverbs_cmd_mask |=\r\nOCRDMA_UVERBS(CREATE_AH) |\r\nOCRDMA_UVERBS(MODIFY_AH) |\r\nOCRDMA_UVERBS(QUERY_AH) |\r\nOCRDMA_UVERBS(DESTROY_AH);\r\ndev->ibdev.node_type = RDMA_NODE_IB_CA;\r\ndev->ibdev.phys_port_cnt = 1;\r\ndev->ibdev.num_comp_vectors = dev->eq_cnt;\r\ndev->ibdev.query_device = ocrdma_query_device;\r\ndev->ibdev.query_port = ocrdma_query_port;\r\ndev->ibdev.modify_port = ocrdma_modify_port;\r\ndev->ibdev.query_gid = ocrdma_query_gid;\r\ndev->ibdev.get_netdev = ocrdma_get_netdev;\r\ndev->ibdev.add_gid = ocrdma_add_gid;\r\ndev->ibdev.del_gid = ocrdma_del_gid;\r\ndev->ibdev.get_link_layer = ocrdma_link_layer;\r\ndev->ibdev.alloc_pd = ocrdma_alloc_pd;\r\ndev->ibdev.dealloc_pd = ocrdma_dealloc_pd;\r\ndev->ibdev.create_cq = ocrdma_create_cq;\r\ndev->ibdev.destroy_cq = ocrdma_destroy_cq;\r\ndev->ibdev.resize_cq = ocrdma_resize_cq;\r\ndev->ibdev.create_qp = ocrdma_create_qp;\r\ndev->ibdev.modify_qp = ocrdma_modify_qp;\r\ndev->ibdev.query_qp = ocrdma_query_qp;\r\ndev->ibdev.destroy_qp = ocrdma_destroy_qp;\r\ndev->ibdev.query_pkey = ocrdma_query_pkey;\r\ndev->ibdev.create_ah = ocrdma_create_ah;\r\ndev->ibdev.destroy_ah = ocrdma_destroy_ah;\r\ndev->ibdev.query_ah = ocrdma_query_ah;\r\ndev->ibdev.modify_ah = ocrdma_modify_ah;\r\ndev->ibdev.poll_cq = ocrdma_poll_cq;\r\ndev->ibdev.post_send = ocrdma_post_send;\r\ndev->ibdev.post_recv = ocrdma_post_recv;\r\ndev->ibdev.req_notify_cq = ocrdma_arm_cq;\r\ndev->ibdev.get_dma_mr = ocrdma_get_dma_mr;\r\ndev->ibdev.dereg_mr = ocrdma_dereg_mr;\r\ndev->ibdev.reg_user_mr = ocrdma_reg_user_mr;\r\ndev->ibdev.alloc_mr = ocrdma_alloc_mr;\r\ndev->ibdev.map_mr_sg = ocrdma_map_mr_sg;\r\ndev->ibdev.alloc_ucontext = ocrdma_alloc_ucontext;\r\ndev->ibdev.dealloc_ucontext = ocrdma_dealloc_ucontext;\r\ndev->ibdev.mmap = ocrdma_mmap;\r\ndev->ibdev.dev.parent = &dev->nic_info.pdev->dev;\r\ndev->ibdev.process_mad = ocrdma_process_mad;\r\ndev->ibdev.get_port_immutable = ocrdma_port_immutable;\r\ndev->ibdev.get_dev_fw_str = get_dev_fw_str;\r\nif (ocrdma_get_asic_type(dev) == OCRDMA_ASIC_GEN_SKH_R) {\r\ndev->ibdev.uverbs_cmd_mask |=\r\nOCRDMA_UVERBS(CREATE_SRQ) |\r\nOCRDMA_UVERBS(MODIFY_SRQ) |\r\nOCRDMA_UVERBS(QUERY_SRQ) |\r\nOCRDMA_UVERBS(DESTROY_SRQ) |\r\nOCRDMA_UVERBS(POST_SRQ_RECV);\r\ndev->ibdev.create_srq = ocrdma_create_srq;\r\ndev->ibdev.modify_srq = ocrdma_modify_srq;\r\ndev->ibdev.query_srq = ocrdma_query_srq;\r\ndev->ibdev.destroy_srq = ocrdma_destroy_srq;\r\ndev->ibdev.post_srq_recv = ocrdma_post_srq_recv;\r\n}\r\nreturn ib_register_device(&dev->ibdev, NULL);\r\n}\r\nstatic int ocrdma_alloc_resources(struct ocrdma_dev *dev)\r\n{\r\nmutex_init(&dev->dev_lock);\r\ndev->cq_tbl = kzalloc(sizeof(struct ocrdma_cq *) *\r\nOCRDMA_MAX_CQ, GFP_KERNEL);\r\nif (!dev->cq_tbl)\r\ngoto alloc_err;\r\nif (dev->attr.max_qp) {\r\ndev->qp_tbl = kzalloc(sizeof(struct ocrdma_qp *) *\r\nOCRDMA_MAX_QP, GFP_KERNEL);\r\nif (!dev->qp_tbl)\r\ngoto alloc_err;\r\n}\r\ndev->stag_arr = kzalloc(sizeof(u64) * OCRDMA_MAX_STAG, GFP_KERNEL);\r\nif (dev->stag_arr == NULL)\r\ngoto alloc_err;\r\nocrdma_alloc_pd_pool(dev);\r\nif (!ocrdma_alloc_stats_resources(dev)) {\r\npr_err("%s: stats resource allocation failed\n", __func__);\r\ngoto alloc_err;\r\n}\r\nspin_lock_init(&dev->av_tbl.lock);\r\nspin_lock_init(&dev->flush_q_lock);\r\nreturn 0;\r\nalloc_err:\r\npr_err("%s(%d) error.\n", __func__, dev->id);\r\nreturn -ENOMEM;\r\n}\r\nstatic void ocrdma_free_resources(struct ocrdma_dev *dev)\r\n{\r\nocrdma_release_stats_resources(dev);\r\nkfree(dev->stag_arr);\r\nkfree(dev->qp_tbl);\r\nkfree(dev->cq_tbl);\r\n}\r\nstatic ssize_t show_rev(struct device *device, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ocrdma_dev *dev = dev_get_drvdata(device);\r\nreturn scnprintf(buf, PAGE_SIZE, "0x%x\n", dev->nic_info.pdev->vendor);\r\n}\r\nstatic ssize_t show_hca_type(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ocrdma_dev *dev = dev_get_drvdata(device);\r\nreturn scnprintf(buf, PAGE_SIZE, "%s\n", &dev->model_number[0]);\r\n}\r\nstatic void ocrdma_remove_sysfiles(struct ocrdma_dev *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(ocrdma_attributes); i++)\r\ndevice_remove_file(&dev->ibdev.dev, ocrdma_attributes[i]);\r\n}\r\nstatic struct ocrdma_dev *ocrdma_add(struct be_dev_info *dev_info)\r\n{\r\nint status = 0, i;\r\nu8 lstate = 0;\r\nstruct ocrdma_dev *dev;\r\ndev = (struct ocrdma_dev *)ib_alloc_device(sizeof(struct ocrdma_dev));\r\nif (!dev) {\r\npr_err("Unable to allocate ib device\n");\r\nreturn NULL;\r\n}\r\ndev->mbx_cmd = kzalloc(sizeof(struct ocrdma_mqe_emb_cmd), GFP_KERNEL);\r\nif (!dev->mbx_cmd)\r\ngoto idr_err;\r\nmemcpy(&dev->nic_info, dev_info, sizeof(*dev_info));\r\ndev->id = idr_alloc(&ocrdma_dev_id, NULL, 0, 0, GFP_KERNEL);\r\nif (dev->id < 0)\r\ngoto idr_err;\r\nstatus = ocrdma_init_hw(dev);\r\nif (status)\r\ngoto init_err;\r\nstatus = ocrdma_alloc_resources(dev);\r\nif (status)\r\ngoto alloc_err;\r\nocrdma_init_service_level(dev);\r\nstatus = ocrdma_register_device(dev);\r\nif (status)\r\ngoto alloc_err;\r\nstatus = ocrdma_mbx_get_link_speed(dev, NULL, &lstate);\r\nif (!status)\r\nocrdma_update_link_state(dev, lstate);\r\nfor (i = 0; i < ARRAY_SIZE(ocrdma_attributes); i++)\r\nif (device_create_file(&dev->ibdev.dev, ocrdma_attributes[i]))\r\ngoto sysfs_err;\r\nocrdma_add_port_stats(dev);\r\nINIT_DELAYED_WORK(&dev->eqd_work, ocrdma_eqd_set_task);\r\nschedule_delayed_work(&dev->eqd_work, msecs_to_jiffies(1000));\r\npr_info("%s %s: %s \"%s\" port %d\n",\r\ndev_name(&dev->nic_info.pdev->dev), hca_name(dev),\r\nport_speed_string(dev), dev->model_number,\r\ndev->hba_port_num);\r\npr_info("%s ocrdma%d driver loaded successfully\n",\r\ndev_name(&dev->nic_info.pdev->dev), dev->id);\r\nreturn dev;\r\nsysfs_err:\r\nocrdma_remove_sysfiles(dev);\r\nalloc_err:\r\nocrdma_free_resources(dev);\r\nocrdma_cleanup_hw(dev);\r\ninit_err:\r\nidr_remove(&ocrdma_dev_id, dev->id);\r\nidr_err:\r\nkfree(dev->mbx_cmd);\r\nib_dealloc_device(&dev->ibdev);\r\npr_err("%s() leaving. ret=%d\n", __func__, status);\r\nreturn NULL;\r\n}\r\nstatic void ocrdma_remove_free(struct ocrdma_dev *dev)\r\n{\r\nidr_remove(&ocrdma_dev_id, dev->id);\r\nkfree(dev->mbx_cmd);\r\nib_dealloc_device(&dev->ibdev);\r\n}\r\nstatic void ocrdma_remove(struct ocrdma_dev *dev)\r\n{\r\ncancel_delayed_work_sync(&dev->eqd_work);\r\nocrdma_remove_sysfiles(dev);\r\nib_unregister_device(&dev->ibdev);\r\nocrdma_rem_port_stats(dev);\r\nocrdma_free_resources(dev);\r\nocrdma_cleanup_hw(dev);\r\nocrdma_remove_free(dev);\r\n}\r\nstatic int ocrdma_dispatch_port_active(struct ocrdma_dev *dev)\r\n{\r\nstruct ib_event port_event;\r\nport_event.event = IB_EVENT_PORT_ACTIVE;\r\nport_event.element.port_num = 1;\r\nport_event.device = &dev->ibdev;\r\nib_dispatch_event(&port_event);\r\nreturn 0;\r\n}\r\nstatic int ocrdma_dispatch_port_error(struct ocrdma_dev *dev)\r\n{\r\nstruct ib_event err_event;\r\nerr_event.event = IB_EVENT_PORT_ERR;\r\nerr_event.element.port_num = 1;\r\nerr_event.device = &dev->ibdev;\r\nib_dispatch_event(&err_event);\r\nreturn 0;\r\n}\r\nstatic void ocrdma_shutdown(struct ocrdma_dev *dev)\r\n{\r\nocrdma_dispatch_port_error(dev);\r\nocrdma_remove(dev);\r\n}\r\nstatic void ocrdma_event_handler(struct ocrdma_dev *dev, u32 event)\r\n{\r\nswitch (event) {\r\ncase BE_DEV_SHUTDOWN:\r\nocrdma_shutdown(dev);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid ocrdma_update_link_state(struct ocrdma_dev *dev, u8 lstate)\r\n{\r\nif (!(dev->flags & OCRDMA_FLAGS_LINK_STATUS_INIT)) {\r\ndev->flags |= OCRDMA_FLAGS_LINK_STATUS_INIT;\r\nif (!lstate)\r\nreturn;\r\n}\r\nif (!lstate)\r\nocrdma_dispatch_port_error(dev);\r\nelse\r\nocrdma_dispatch_port_active(dev);\r\n}\r\nstatic int __init ocrdma_init_module(void)\r\n{\r\nint status;\r\nocrdma_init_debugfs();\r\nstatus = be_roce_register_driver(&ocrdma_drv);\r\nif (status)\r\ngoto err_be_reg;\r\nreturn 0;\r\nerr_be_reg:\r\nreturn status;\r\n}\r\nstatic void __exit ocrdma_exit_module(void)\r\n{\r\nbe_roce_unregister_driver(&ocrdma_drv);\r\nocrdma_rem_debugfs();\r\nidr_destroy(&ocrdma_dev_id);\r\n}
