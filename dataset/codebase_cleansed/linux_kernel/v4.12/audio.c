static void\r\nactivate_substream(struct snd_usb_caiaqdev *cdev,\r\nstruct snd_pcm_substream *sub)\r\n{\r\nspin_lock(&cdev->spinlock);\r\nif (sub->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ncdev->sub_playback[sub->number] = sub;\r\nelse\r\ncdev->sub_capture[sub->number] = sub;\r\nspin_unlock(&cdev->spinlock);\r\n}\r\nstatic void\r\ndeactivate_substream(struct snd_usb_caiaqdev *cdev,\r\nstruct snd_pcm_substream *sub)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cdev->spinlock, flags);\r\nif (sub->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ncdev->sub_playback[sub->number] = NULL;\r\nelse\r\ncdev->sub_capture[sub->number] = NULL;\r\nspin_unlock_irqrestore(&cdev->spinlock, flags);\r\n}\r\nstatic int\r\nall_substreams_zero(struct snd_pcm_substream **subs)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_STREAMS; i++)\r\nif (subs[i] != NULL)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int stream_start(struct snd_usb_caiaqdev *cdev)\r\n{\r\nint i, ret;\r\nstruct device *dev = caiaqdev_to_dev(cdev);\r\ndev_dbg(dev, "%s(%p)\n", __func__, cdev);\r\nif (cdev->streaming)\r\nreturn -EINVAL;\r\nmemset(cdev->sub_playback, 0, sizeof(cdev->sub_playback));\r\nmemset(cdev->sub_capture, 0, sizeof(cdev->sub_capture));\r\ncdev->input_panic = 0;\r\ncdev->output_panic = 0;\r\ncdev->first_packet = 4;\r\ncdev->streaming = 1;\r\ncdev->warned = 0;\r\nfor (i = 0; i < N_URBS; i++) {\r\nret = usb_submit_urb(cdev->data_urbs_in[i], GFP_ATOMIC);\r\nif (ret) {\r\ndev_err(dev, "unable to trigger read #%d! (ret %d)\n",\r\ni, ret);\r\ncdev->streaming = 0;\r\nreturn -EPIPE;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void stream_stop(struct snd_usb_caiaqdev *cdev)\r\n{\r\nint i;\r\nstruct device *dev = caiaqdev_to_dev(cdev);\r\ndev_dbg(dev, "%s(%p)\n", __func__, cdev);\r\nif (!cdev->streaming)\r\nreturn;\r\ncdev->streaming = 0;\r\nfor (i = 0; i < N_URBS; i++) {\r\nusb_kill_urb(cdev->data_urbs_in[i]);\r\nif (test_bit(i, &cdev->outurb_active_mask))\r\nusb_kill_urb(cdev->data_urbs_out[i]);\r\n}\r\ncdev->outurb_active_mask = 0;\r\n}\r\nstatic int snd_usb_caiaq_substream_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_usb_caiaqdev *cdev = snd_pcm_substream_chip(substream);\r\nstruct device *dev = caiaqdev_to_dev(cdev);\r\ndev_dbg(dev, "%s(%p)\n", __func__, substream);\r\nsubstream->runtime->hw = cdev->pcm_info;\r\nsnd_pcm_limit_hw_rates(substream->runtime);\r\nreturn 0;\r\n}\r\nstatic int snd_usb_caiaq_substream_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_usb_caiaqdev *cdev = snd_pcm_substream_chip(substream);\r\nstruct device *dev = caiaqdev_to_dev(cdev);\r\ndev_dbg(dev, "%s(%p)\n", __func__, substream);\r\nif (all_substreams_zero(cdev->sub_playback) &&\r\nall_substreams_zero(cdev->sub_capture)) {\r\nstream_stop(cdev);\r\ncdev->pcm_info.rates = cdev->samplerates;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_usb_caiaq_pcm_hw_params(struct snd_pcm_substream *sub,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_pcm_lib_alloc_vmalloc_buffer(sub,\r\nparams_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_usb_caiaq_pcm_hw_free(struct snd_pcm_substream *sub)\r\n{\r\nstruct snd_usb_caiaqdev *cdev = snd_pcm_substream_chip(sub);\r\ndeactivate_substream(cdev, sub);\r\nreturn snd_pcm_lib_free_vmalloc_buffer(sub);\r\n}\r\nstatic int snd_usb_caiaq_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nint bytes_per_sample, bpp, ret, i;\r\nint index = substream->number;\r\nstruct snd_usb_caiaqdev *cdev = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct device *dev = caiaqdev_to_dev(cdev);\r\ndev_dbg(dev, "%s(%p)\n", __func__, substream);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nint out_pos;\r\nswitch (cdev->spec.data_alignment) {\r\ncase 0:\r\ncase 2:\r\nout_pos = BYTES_PER_SAMPLE + 1;\r\nbreak;\r\ncase 3:\r\ndefault:\r\nout_pos = 0;\r\nbreak;\r\n}\r\ncdev->period_out_count[index] = out_pos;\r\ncdev->audio_out_buf_pos[index] = out_pos;\r\n} else {\r\nint in_pos;\r\nswitch (cdev->spec.data_alignment) {\r\ncase 0:\r\nin_pos = BYTES_PER_SAMPLE + 2;\r\nbreak;\r\ncase 2:\r\nin_pos = BYTES_PER_SAMPLE;\r\nbreak;\r\ncase 3:\r\ndefault:\r\nin_pos = 0;\r\nbreak;\r\n}\r\ncdev->period_in_count[index] = in_pos;\r\ncdev->audio_in_buf_pos[index] = in_pos;\r\n}\r\nif (cdev->streaming)\r\nreturn 0;\r\nfor (i=0; i < ARRAY_SIZE(rates); i++)\r\nif (runtime->rate == rates[i])\r\ncdev->pcm_info.rates = 1 << i;\r\nsnd_pcm_limit_hw_rates(runtime);\r\nbytes_per_sample = BYTES_PER_SAMPLE;\r\nif (cdev->spec.data_alignment >= 2)\r\nbytes_per_sample++;\r\nbpp = ((runtime->rate / 8000) + CLOCK_DRIFT_TOLERANCE)\r\n* bytes_per_sample * CHANNELS_PER_STREAM * cdev->n_streams;\r\nif (bpp > MAX_ENDPOINT_SIZE)\r\nbpp = MAX_ENDPOINT_SIZE;\r\nret = snd_usb_caiaq_set_audio_params(cdev, runtime->rate,\r\nruntime->sample_bits, bpp);\r\nif (ret)\r\nreturn ret;\r\nret = stream_start(cdev);\r\nif (ret)\r\nreturn ret;\r\ncdev->output_running = 0;\r\nwait_event_timeout(cdev->prepare_wait_queue, cdev->output_running, HZ);\r\nif (!cdev->output_running) {\r\nstream_stop(cdev);\r\nreturn -EPIPE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_usb_caiaq_pcm_trigger(struct snd_pcm_substream *sub, int cmd)\r\n{\r\nstruct snd_usb_caiaqdev *cdev = snd_pcm_substream_chip(sub);\r\nstruct device *dev = caiaqdev_to_dev(cdev);\r\ndev_dbg(dev, "%s(%p) cmd %d\n", __func__, sub, cmd);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nactivate_substream(cdev, sub);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ndeactivate_substream(cdev, sub);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_usb_caiaq_pcm_pointer(struct snd_pcm_substream *sub)\r\n{\r\nint index = sub->number;\r\nstruct snd_usb_caiaqdev *cdev = snd_pcm_substream_chip(sub);\r\nsnd_pcm_uframes_t ptr;\r\nspin_lock(&cdev->spinlock);\r\nif (cdev->input_panic || cdev->output_panic) {\r\nptr = SNDRV_PCM_POS_XRUN;\r\ngoto unlock;\r\n}\r\nif (sub->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nptr = bytes_to_frames(sub->runtime,\r\ncdev->audio_out_buf_pos[index]);\r\nelse\r\nptr = bytes_to_frames(sub->runtime,\r\ncdev->audio_in_buf_pos[index]);\r\nunlock:\r\nspin_unlock(&cdev->spinlock);\r\nreturn ptr;\r\n}\r\nstatic void check_for_elapsed_periods(struct snd_usb_caiaqdev *cdev,\r\nstruct snd_pcm_substream **subs)\r\n{\r\nint stream, pb, *cnt;\r\nstruct snd_pcm_substream *sub;\r\nfor (stream = 0; stream < cdev->n_streams; stream++) {\r\nsub = subs[stream];\r\nif (!sub)\r\ncontinue;\r\npb = snd_pcm_lib_period_bytes(sub);\r\ncnt = (sub->stream == SNDRV_PCM_STREAM_PLAYBACK) ?\r\n&cdev->period_out_count[stream] :\r\n&cdev->period_in_count[stream];\r\nif (*cnt >= pb) {\r\nsnd_pcm_period_elapsed(sub);\r\n*cnt %= pb;\r\n}\r\n}\r\n}\r\nstatic void read_in_urb_mode0(struct snd_usb_caiaqdev *cdev,\r\nconst struct urb *urb,\r\nconst struct usb_iso_packet_descriptor *iso)\r\n{\r\nunsigned char *usb_buf = urb->transfer_buffer + iso->offset;\r\nstruct snd_pcm_substream *sub;\r\nint stream, i;\r\nif (all_substreams_zero(cdev->sub_capture))\r\nreturn;\r\nfor (i = 0; i < iso->actual_length;) {\r\nfor (stream = 0; stream < cdev->n_streams; stream++, i++) {\r\nsub = cdev->sub_capture[stream];\r\nif (sub) {\r\nstruct snd_pcm_runtime *rt = sub->runtime;\r\nchar *audio_buf = rt->dma_area;\r\nint sz = frames_to_bytes(rt, rt->buffer_size);\r\naudio_buf[cdev->audio_in_buf_pos[stream]++]\r\n= usb_buf[i];\r\ncdev->period_in_count[stream]++;\r\nif (cdev->audio_in_buf_pos[stream] == sz)\r\ncdev->audio_in_buf_pos[stream] = 0;\r\n}\r\n}\r\n}\r\n}\r\nstatic void read_in_urb_mode2(struct snd_usb_caiaqdev *cdev,\r\nconst struct urb *urb,\r\nconst struct usb_iso_packet_descriptor *iso)\r\n{\r\nunsigned char *usb_buf = urb->transfer_buffer + iso->offset;\r\nunsigned char check_byte;\r\nstruct snd_pcm_substream *sub;\r\nint stream, i;\r\nfor (i = 0; i < iso->actual_length;) {\r\nif (i % (cdev->n_streams * BYTES_PER_SAMPLE_USB) == 0) {\r\nfor (stream = 0;\r\nstream < cdev->n_streams;\r\nstream++, i++) {\r\nif (cdev->first_packet)\r\ncontinue;\r\ncheck_byte = MAKE_CHECKBYTE(cdev, stream, i);\r\nif ((usb_buf[i] & 0x3f) != check_byte)\r\ncdev->input_panic = 1;\r\nif (usb_buf[i] & 0x80)\r\ncdev->output_panic = 1;\r\n}\r\n}\r\ncdev->first_packet = 0;\r\nfor (stream = 0; stream < cdev->n_streams; stream++, i++) {\r\nsub = cdev->sub_capture[stream];\r\nif (cdev->input_panic)\r\nusb_buf[i] = 0;\r\nif (sub) {\r\nstruct snd_pcm_runtime *rt = sub->runtime;\r\nchar *audio_buf = rt->dma_area;\r\nint sz = frames_to_bytes(rt, rt->buffer_size);\r\naudio_buf[cdev->audio_in_buf_pos[stream]++] =\r\nusb_buf[i];\r\ncdev->period_in_count[stream]++;\r\nif (cdev->audio_in_buf_pos[stream] == sz)\r\ncdev->audio_in_buf_pos[stream] = 0;\r\n}\r\n}\r\n}\r\n}\r\nstatic void read_in_urb_mode3(struct snd_usb_caiaqdev *cdev,\r\nconst struct urb *urb,\r\nconst struct usb_iso_packet_descriptor *iso)\r\n{\r\nunsigned char *usb_buf = urb->transfer_buffer + iso->offset;\r\nstruct device *dev = caiaqdev_to_dev(cdev);\r\nint stream, i;\r\nif (iso->actual_length % (BYTES_PER_SAMPLE_USB * CHANNELS_PER_STREAM))\r\nreturn;\r\nfor (i = 0; i < iso->actual_length;) {\r\nfor (stream = 0; stream < cdev->n_streams; stream++) {\r\nstruct snd_pcm_substream *sub = cdev->sub_capture[stream];\r\nchar *audio_buf = NULL;\r\nint c, n, sz = 0;\r\nif (sub && !cdev->input_panic) {\r\nstruct snd_pcm_runtime *rt = sub->runtime;\r\naudio_buf = rt->dma_area;\r\nsz = frames_to_bytes(rt, rt->buffer_size);\r\n}\r\nfor (c = 0; c < CHANNELS_PER_STREAM; c++) {\r\nif (audio_buf) {\r\nfor (n = 0; n < BYTES_PER_SAMPLE; n++) {\r\naudio_buf[cdev->audio_in_buf_pos[stream]++] = usb_buf[i+n];\r\nif (cdev->audio_in_buf_pos[stream] == sz)\r\ncdev->audio_in_buf_pos[stream] = 0;\r\n}\r\ncdev->period_in_count[stream] += BYTES_PER_SAMPLE;\r\n}\r\ni += BYTES_PER_SAMPLE;\r\nif (usb_buf[i] != ((stream << 1) | c) &&\r\n!cdev->first_packet) {\r\nif (!cdev->input_panic)\r\ndev_warn(dev, " EXPECTED: %02x got %02x, c %d, stream %d, i %d\n",\r\n((stream << 1) | c), usb_buf[i], c, stream, i);\r\ncdev->input_panic = 1;\r\n}\r\ni++;\r\n}\r\n}\r\n}\r\nif (cdev->first_packet > 0)\r\ncdev->first_packet--;\r\n}\r\nstatic void read_in_urb(struct snd_usb_caiaqdev *cdev,\r\nconst struct urb *urb,\r\nconst struct usb_iso_packet_descriptor *iso)\r\n{\r\nstruct device *dev = caiaqdev_to_dev(cdev);\r\nif (!cdev->streaming)\r\nreturn;\r\nif (iso->actual_length < cdev->bpp)\r\nreturn;\r\nswitch (cdev->spec.data_alignment) {\r\ncase 0:\r\nread_in_urb_mode0(cdev, urb, iso);\r\nbreak;\r\ncase 2:\r\nread_in_urb_mode2(cdev, urb, iso);\r\nbreak;\r\ncase 3:\r\nread_in_urb_mode3(cdev, urb, iso);\r\nbreak;\r\n}\r\nif ((cdev->input_panic || cdev->output_panic) && !cdev->warned) {\r\ndev_warn(dev, "streaming error detected %s %s\n",\r\ncdev->input_panic ? "(input)" : "",\r\ncdev->output_panic ? "(output)" : "");\r\ncdev->warned = 1;\r\n}\r\n}\r\nstatic void fill_out_urb_mode_0(struct snd_usb_caiaqdev *cdev,\r\nstruct urb *urb,\r\nconst struct usb_iso_packet_descriptor *iso)\r\n{\r\nunsigned char *usb_buf = urb->transfer_buffer + iso->offset;\r\nstruct snd_pcm_substream *sub;\r\nint stream, i;\r\nfor (i = 0; i < iso->length;) {\r\nfor (stream = 0; stream < cdev->n_streams; stream++, i++) {\r\nsub = cdev->sub_playback[stream];\r\nif (sub) {\r\nstruct snd_pcm_runtime *rt = sub->runtime;\r\nchar *audio_buf = rt->dma_area;\r\nint sz = frames_to_bytes(rt, rt->buffer_size);\r\nusb_buf[i] =\r\naudio_buf[cdev->audio_out_buf_pos[stream]];\r\ncdev->period_out_count[stream]++;\r\ncdev->audio_out_buf_pos[stream]++;\r\nif (cdev->audio_out_buf_pos[stream] == sz)\r\ncdev->audio_out_buf_pos[stream] = 0;\r\n} else\r\nusb_buf[i] = 0;\r\n}\r\nif (cdev->spec.data_alignment == 2 &&\r\ni % (cdev->n_streams * BYTES_PER_SAMPLE_USB) ==\r\n(cdev->n_streams * CHANNELS_PER_STREAM))\r\nfor (stream = 0; stream < cdev->n_streams; stream++, i++)\r\nusb_buf[i] = MAKE_CHECKBYTE(cdev, stream, i);\r\n}\r\n}\r\nstatic void fill_out_urb_mode_3(struct snd_usb_caiaqdev *cdev,\r\nstruct urb *urb,\r\nconst struct usb_iso_packet_descriptor *iso)\r\n{\r\nunsigned char *usb_buf = urb->transfer_buffer + iso->offset;\r\nint stream, i;\r\nfor (i = 0; i < iso->length;) {\r\nfor (stream = 0; stream < cdev->n_streams; stream++) {\r\nstruct snd_pcm_substream *sub = cdev->sub_playback[stream];\r\nchar *audio_buf = NULL;\r\nint c, n, sz = 0;\r\nif (sub) {\r\nstruct snd_pcm_runtime *rt = sub->runtime;\r\naudio_buf = rt->dma_area;\r\nsz = frames_to_bytes(rt, rt->buffer_size);\r\n}\r\nfor (c = 0; c < CHANNELS_PER_STREAM; c++) {\r\nfor (n = 0; n < BYTES_PER_SAMPLE; n++) {\r\nif (audio_buf) {\r\nusb_buf[i+n] = audio_buf[cdev->audio_out_buf_pos[stream]++];\r\nif (cdev->audio_out_buf_pos[stream] == sz)\r\ncdev->audio_out_buf_pos[stream] = 0;\r\n} else {\r\nusb_buf[i+n] = 0;\r\n}\r\n}\r\nif (audio_buf)\r\ncdev->period_out_count[stream] += BYTES_PER_SAMPLE;\r\ni += BYTES_PER_SAMPLE;\r\nusb_buf[i++] = (stream << 1) | c;\r\n}\r\n}\r\n}\r\n}\r\nstatic inline void fill_out_urb(struct snd_usb_caiaqdev *cdev,\r\nstruct urb *urb,\r\nconst struct usb_iso_packet_descriptor *iso)\r\n{\r\nswitch (cdev->spec.data_alignment) {\r\ncase 0:\r\ncase 2:\r\nfill_out_urb_mode_0(cdev, urb, iso);\r\nbreak;\r\ncase 3:\r\nfill_out_urb_mode_3(cdev, urb, iso);\r\nbreak;\r\n}\r\n}\r\nstatic void read_completed(struct urb *urb)\r\n{\r\nstruct snd_usb_caiaq_cb_info *info = urb->context;\r\nstruct snd_usb_caiaqdev *cdev;\r\nstruct device *dev;\r\nstruct urb *out = NULL;\r\nint i, frame, len, send_it = 0, outframe = 0;\r\nsize_t offset = 0;\r\nif (urb->status || !info)\r\nreturn;\r\ncdev = info->cdev;\r\ndev = caiaqdev_to_dev(cdev);\r\nif (!cdev->streaming)\r\nreturn;\r\nfor (i = 0; i < N_URBS; i++)\r\nif (test_and_set_bit(i, &cdev->outurb_active_mask) == 0) {\r\nout = cdev->data_urbs_out[i];\r\nbreak;\r\n}\r\nif (!out) {\r\ndev_err(dev, "Unable to find an output urb to use\n");\r\ngoto requeue;\r\n}\r\nfor (frame = 0; frame < FRAMES_PER_URB; frame++) {\r\nif (urb->iso_frame_desc[frame].status)\r\ncontinue;\r\nlen = urb->iso_frame_desc[outframe].actual_length;\r\nout->iso_frame_desc[outframe].length = len;\r\nout->iso_frame_desc[outframe].actual_length = 0;\r\nout->iso_frame_desc[outframe].offset = offset;\r\noffset += len;\r\nif (len > 0) {\r\nspin_lock(&cdev->spinlock);\r\nfill_out_urb(cdev, out, &out->iso_frame_desc[outframe]);\r\nread_in_urb(cdev, urb, &urb->iso_frame_desc[frame]);\r\nspin_unlock(&cdev->spinlock);\r\ncheck_for_elapsed_periods(cdev, cdev->sub_playback);\r\ncheck_for_elapsed_periods(cdev, cdev->sub_capture);\r\nsend_it = 1;\r\n}\r\noutframe++;\r\n}\r\nif (send_it) {\r\nout->number_of_packets = outframe;\r\nusb_submit_urb(out, GFP_ATOMIC);\r\n} else {\r\nstruct snd_usb_caiaq_cb_info *oinfo = out->context;\r\nclear_bit(oinfo->index, &cdev->outurb_active_mask);\r\n}\r\nrequeue:\r\nfor (frame = 0; frame < FRAMES_PER_URB; frame++) {\r\nurb->iso_frame_desc[frame].offset = BYTES_PER_FRAME * frame;\r\nurb->iso_frame_desc[frame].length = BYTES_PER_FRAME;\r\nurb->iso_frame_desc[frame].actual_length = 0;\r\n}\r\nurb->number_of_packets = FRAMES_PER_URB;\r\nusb_submit_urb(urb, GFP_ATOMIC);\r\n}\r\nstatic void write_completed(struct urb *urb)\r\n{\r\nstruct snd_usb_caiaq_cb_info *info = urb->context;\r\nstruct snd_usb_caiaqdev *cdev = info->cdev;\r\nif (!cdev->output_running) {\r\ncdev->output_running = 1;\r\nwake_up(&cdev->prepare_wait_queue);\r\n}\r\nclear_bit(info->index, &cdev->outurb_active_mask);\r\n}\r\nstatic struct urb **alloc_urbs(struct snd_usb_caiaqdev *cdev, int dir, int *ret)\r\n{\r\nint i, frame;\r\nstruct urb **urbs;\r\nstruct usb_device *usb_dev = cdev->chip.dev;\r\nstruct device *dev = caiaqdev_to_dev(cdev);\r\nunsigned int pipe;\r\npipe = (dir == SNDRV_PCM_STREAM_PLAYBACK) ?\r\nusb_sndisocpipe(usb_dev, ENDPOINT_PLAYBACK) :\r\nusb_rcvisocpipe(usb_dev, ENDPOINT_CAPTURE);\r\nurbs = kmalloc(N_URBS * sizeof(*urbs), GFP_KERNEL);\r\nif (!urbs) {\r\ndev_err(dev, "unable to kmalloc() urbs, OOM!?\n");\r\n*ret = -ENOMEM;\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < N_URBS; i++) {\r\nurbs[i] = usb_alloc_urb(FRAMES_PER_URB, GFP_KERNEL);\r\nif (!urbs[i]) {\r\n*ret = -ENOMEM;\r\nreturn urbs;\r\n}\r\nurbs[i]->transfer_buffer =\r\nkmalloc(FRAMES_PER_URB * BYTES_PER_FRAME, GFP_KERNEL);\r\nif (!urbs[i]->transfer_buffer) {\r\ndev_err(dev, "unable to kmalloc() transfer buffer, OOM!?\n");\r\n*ret = -ENOMEM;\r\nreturn urbs;\r\n}\r\nfor (frame = 0; frame < FRAMES_PER_URB; frame++) {\r\nstruct usb_iso_packet_descriptor *iso =\r\n&urbs[i]->iso_frame_desc[frame];\r\niso->offset = BYTES_PER_FRAME * frame;\r\niso->length = BYTES_PER_FRAME;\r\n}\r\nurbs[i]->dev = usb_dev;\r\nurbs[i]->pipe = pipe;\r\nurbs[i]->transfer_buffer_length = FRAMES_PER_URB\r\n* BYTES_PER_FRAME;\r\nurbs[i]->context = &cdev->data_cb_info[i];\r\nurbs[i]->interval = 1;\r\nurbs[i]->number_of_packets = FRAMES_PER_URB;\r\nurbs[i]->complete = (dir == SNDRV_PCM_STREAM_CAPTURE) ?\r\nread_completed : write_completed;\r\n}\r\n*ret = 0;\r\nreturn urbs;\r\n}\r\nstatic void free_urbs(struct urb **urbs)\r\n{\r\nint i;\r\nif (!urbs)\r\nreturn;\r\nfor (i = 0; i < N_URBS; i++) {\r\nif (!urbs[i])\r\ncontinue;\r\nusb_kill_urb(urbs[i]);\r\nkfree(urbs[i]->transfer_buffer);\r\nusb_free_urb(urbs[i]);\r\n}\r\nkfree(urbs);\r\n}\r\nint snd_usb_caiaq_audio_init(struct snd_usb_caiaqdev *cdev)\r\n{\r\nint i, ret;\r\nstruct device *dev = caiaqdev_to_dev(cdev);\r\ncdev->n_audio_in = max(cdev->spec.num_analog_audio_in,\r\ncdev->spec.num_digital_audio_in) /\r\nCHANNELS_PER_STREAM;\r\ncdev->n_audio_out = max(cdev->spec.num_analog_audio_out,\r\ncdev->spec.num_digital_audio_out) /\r\nCHANNELS_PER_STREAM;\r\ncdev->n_streams = max(cdev->n_audio_in, cdev->n_audio_out);\r\ndev_dbg(dev, "cdev->n_audio_in = %d\n", cdev->n_audio_in);\r\ndev_dbg(dev, "cdev->n_audio_out = %d\n", cdev->n_audio_out);\r\ndev_dbg(dev, "cdev->n_streams = %d\n", cdev->n_streams);\r\nif (cdev->n_streams > MAX_STREAMS) {\r\ndev_err(dev, "unable to initialize device, too many streams.\n");\r\nreturn -EINVAL;\r\n}\r\nif (cdev->n_streams < 1) {\r\ndev_err(dev, "bogus number of streams: %d\n", cdev->n_streams);\r\nreturn -EINVAL;\r\n}\r\nret = snd_pcm_new(cdev->chip.card, cdev->product_name, 0,\r\ncdev->n_audio_out, cdev->n_audio_in, &cdev->pcm);\r\nif (ret < 0) {\r\ndev_err(dev, "snd_pcm_new() returned %d\n", ret);\r\nreturn ret;\r\n}\r\ncdev->pcm->private_data = cdev;\r\nstrlcpy(cdev->pcm->name, cdev->product_name, sizeof(cdev->pcm->name));\r\nmemset(cdev->sub_playback, 0, sizeof(cdev->sub_playback));\r\nmemset(cdev->sub_capture, 0, sizeof(cdev->sub_capture));\r\nmemcpy(&cdev->pcm_info, &snd_usb_caiaq_pcm_hardware,\r\nsizeof(snd_usb_caiaq_pcm_hardware));\r\ncdev->samplerates = cdev->pcm_info.rates;\r\nswitch (cdev->chip.usb_id) {\r\ncase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AK1):\r\ncase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_RIGKONTROL3):\r\ncase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_SESSIONIO):\r\ncase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_GUITARRIGMOBILE):\r\ncdev->samplerates |= SNDRV_PCM_RATE_192000;\r\ncase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO2DJ):\r\ncase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO4DJ):\r\ncase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_AUDIO8DJ):\r\ncase USB_ID(USB_VID_NATIVEINSTRUMENTS, USB_PID_TRAKTORAUDIO2):\r\ncdev->samplerates |= SNDRV_PCM_RATE_88200;\r\nbreak;\r\n}\r\nsnd_pcm_set_ops(cdev->pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&snd_usb_caiaq_ops);\r\nsnd_pcm_set_ops(cdev->pcm, SNDRV_PCM_STREAM_CAPTURE,\r\n&snd_usb_caiaq_ops);\r\ncdev->data_cb_info =\r\nkmalloc(sizeof(struct snd_usb_caiaq_cb_info) * N_URBS,\r\nGFP_KERNEL);\r\nif (!cdev->data_cb_info)\r\nreturn -ENOMEM;\r\ncdev->outurb_active_mask = 0;\r\nBUILD_BUG_ON(N_URBS > (sizeof(cdev->outurb_active_mask) * 8));\r\nfor (i = 0; i < N_URBS; i++) {\r\ncdev->data_cb_info[i].cdev = cdev;\r\ncdev->data_cb_info[i].index = i;\r\n}\r\ncdev->data_urbs_in = alloc_urbs(cdev, SNDRV_PCM_STREAM_CAPTURE, &ret);\r\nif (ret < 0) {\r\nkfree(cdev->data_cb_info);\r\nfree_urbs(cdev->data_urbs_in);\r\nreturn ret;\r\n}\r\ncdev->data_urbs_out = alloc_urbs(cdev, SNDRV_PCM_STREAM_PLAYBACK, &ret);\r\nif (ret < 0) {\r\nkfree(cdev->data_cb_info);\r\nfree_urbs(cdev->data_urbs_in);\r\nfree_urbs(cdev->data_urbs_out);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid snd_usb_caiaq_audio_free(struct snd_usb_caiaqdev *cdev)\r\n{\r\nstruct device *dev = caiaqdev_to_dev(cdev);\r\ndev_dbg(dev, "%s(%p)\n", __func__, cdev);\r\nstream_stop(cdev);\r\nfree_urbs(cdev->data_urbs_in);\r\nfree_urbs(cdev->data_urbs_out);\r\nkfree(cdev->data_cb_info);\r\n}
