int _gre_set_tunnel(struct __sk_buff *skb)\r\n{\r\nint ret;\r\nstruct bpf_tunnel_key key;\r\n__builtin_memset(&key, 0x0, sizeof(key));\r\nkey.remote_ipv4 = 0xac100164;\r\nkey.tunnel_id = 2;\r\nkey.tunnel_tos = 0;\r\nkey.tunnel_ttl = 64;\r\nret = bpf_skb_set_tunnel_key(skb, &key, sizeof(key), BPF_F_ZERO_CSUM_TX);\r\nif (ret < 0) {\r\nERROR(ret);\r\nreturn TC_ACT_SHOT;\r\n}\r\nreturn TC_ACT_OK;\r\n}\r\nint _gre_get_tunnel(struct __sk_buff *skb)\r\n{\r\nint ret;\r\nstruct bpf_tunnel_key key;\r\nchar fmt[] = "key %d remote ip 0x%x\n";\r\nret = bpf_skb_get_tunnel_key(skb, &key, sizeof(key), 0);\r\nif (ret < 0) {\r\nERROR(ret);\r\nreturn TC_ACT_SHOT;\r\n}\r\nbpf_trace_printk(fmt, sizeof(fmt), key.tunnel_id, key.remote_ipv4);\r\nreturn TC_ACT_OK;\r\n}\r\nint _vxlan_set_tunnel(struct __sk_buff *skb)\r\n{\r\nint ret;\r\nstruct bpf_tunnel_key key;\r\nstruct vxlan_metadata md;\r\n__builtin_memset(&key, 0x0, sizeof(key));\r\nkey.remote_ipv4 = 0xac100164;\r\nkey.tunnel_id = 2;\r\nkey.tunnel_tos = 0;\r\nkey.tunnel_ttl = 64;\r\nret = bpf_skb_set_tunnel_key(skb, &key, sizeof(key), BPF_F_ZERO_CSUM_TX);\r\nif (ret < 0) {\r\nERROR(ret);\r\nreturn TC_ACT_SHOT;\r\n}\r\nmd.gbp = 0x800FF;\r\nret = bpf_skb_set_tunnel_opt(skb, &md, sizeof(md));\r\nif (ret < 0) {\r\nERROR(ret);\r\nreturn TC_ACT_SHOT;\r\n}\r\nreturn TC_ACT_OK;\r\n}\r\nint _vxlan_get_tunnel(struct __sk_buff *skb)\r\n{\r\nint ret;\r\nstruct bpf_tunnel_key key;\r\nstruct vxlan_metadata md;\r\nchar fmt[] = "key %d remote ip 0x%x vxlan gbp 0x%x\n";\r\nret = bpf_skb_get_tunnel_key(skb, &key, sizeof(key), 0);\r\nif (ret < 0) {\r\nERROR(ret);\r\nreturn TC_ACT_SHOT;\r\n}\r\nret = bpf_skb_get_tunnel_opt(skb, &md, sizeof(md));\r\nif (ret < 0) {\r\nERROR(ret);\r\nreturn TC_ACT_SHOT;\r\n}\r\nbpf_trace_printk(fmt, sizeof(fmt),\r\nkey.tunnel_id, key.remote_ipv4, md.gbp);\r\nreturn TC_ACT_OK;\r\n}\r\nint _geneve_set_tunnel(struct __sk_buff *skb)\r\n{\r\nint ret, ret2;\r\nstruct bpf_tunnel_key key;\r\nstruct geneve_opt gopt;\r\n__builtin_memset(&key, 0x0, sizeof(key));\r\nkey.remote_ipv4 = 0xac100164;\r\nkey.tunnel_id = 2;\r\nkey.tunnel_tos = 0;\r\nkey.tunnel_ttl = 64;\r\n__builtin_memset(&gopt, 0x0, sizeof(gopt));\r\ngopt.opt_class = 0x102;\r\ngopt.type = 0x08;\r\ngopt.r1 = 1;\r\ngopt.r2 = 0;\r\ngopt.r3 = 1;\r\ngopt.length = 2;\r\n*(int *) &gopt.opt_data = 0xdeadbeef;\r\nret = bpf_skb_set_tunnel_key(skb, &key, sizeof(key), BPF_F_ZERO_CSUM_TX);\r\nif (ret < 0) {\r\nERROR(ret);\r\nreturn TC_ACT_SHOT;\r\n}\r\nret = bpf_skb_set_tunnel_opt(skb, &gopt, sizeof(gopt));\r\nif (ret < 0) {\r\nERROR(ret);\r\nreturn TC_ACT_SHOT;\r\n}\r\nreturn TC_ACT_OK;\r\n}\r\nint _geneve_get_tunnel(struct __sk_buff *skb)\r\n{\r\nint ret;\r\nstruct bpf_tunnel_key key;\r\nstruct geneve_opt gopt;\r\nchar fmt[] = "key %d remote ip 0x%x geneve class 0x%x\n";\r\nret = bpf_skb_get_tunnel_key(skb, &key, sizeof(key), 0);\r\nif (ret < 0) {\r\nERROR(ret);\r\nreturn TC_ACT_SHOT;\r\n}\r\nret = bpf_skb_get_tunnel_opt(skb, &gopt, sizeof(gopt));\r\nif (ret < 0) {\r\nERROR(ret);\r\nreturn TC_ACT_SHOT;\r\n}\r\nbpf_trace_printk(fmt, sizeof(fmt),\r\nkey.tunnel_id, key.remote_ipv4, gopt.opt_class);\r\nreturn TC_ACT_OK;\r\n}\r\nint _ipip_set_tunnel(struct __sk_buff *skb)\r\n{\r\nstruct bpf_tunnel_key key = {};\r\nvoid *data = (void *)(long)skb->data;\r\nstruct iphdr *iph = data;\r\nstruct tcphdr *tcp = data + sizeof(*iph);\r\nvoid *data_end = (void *)(long)skb->data_end;\r\nint ret;\r\nif (data + sizeof(*iph) + sizeof(*tcp) > data_end) {\r\nERROR(1);\r\nreturn TC_ACT_SHOT;\r\n}\r\nkey.tunnel_ttl = 64;\r\nif (iph->protocol == IPPROTO_ICMP) {\r\nkey.remote_ipv4 = 0xac100164;\r\n} else {\r\nif (iph->protocol != IPPROTO_TCP || iph->ihl != 5)\r\nreturn TC_ACT_SHOT;\r\nif (tcp->dest == htons(5200))\r\nkey.remote_ipv4 = 0xac100164;\r\nelse if (tcp->dest == htons(5201))\r\nkey.remote_ipv4 = 0xac100165;\r\nelse\r\nreturn TC_ACT_SHOT;\r\n}\r\nret = bpf_skb_set_tunnel_key(skb, &key, sizeof(key), 0);\r\nif (ret < 0) {\r\nERROR(ret);\r\nreturn TC_ACT_SHOT;\r\n}\r\nreturn TC_ACT_OK;\r\n}\r\nint _ipip_get_tunnel(struct __sk_buff *skb)\r\n{\r\nint ret;\r\nstruct bpf_tunnel_key key;\r\nchar fmt[] = "remote ip 0x%x\n";\r\nret = bpf_skb_get_tunnel_key(skb, &key, sizeof(key), 0);\r\nif (ret < 0) {\r\nERROR(ret);\r\nreturn TC_ACT_SHOT;\r\n}\r\nbpf_trace_printk(fmt, sizeof(fmt), key.remote_ipv4);\r\nreturn TC_ACT_OK;\r\n}\r\nint _ipip6_set_tunnel(struct __sk_buff *skb)\r\n{\r\nstruct bpf_tunnel_key key = {};\r\nvoid *data = (void *)(long)skb->data;\r\nstruct iphdr *iph = data;\r\nstruct tcphdr *tcp = data + sizeof(*iph);\r\nvoid *data_end = (void *)(long)skb->data_end;\r\nint ret;\r\nif (data + sizeof(*iph) + sizeof(*tcp) > data_end) {\r\nERROR(1);\r\nreturn TC_ACT_SHOT;\r\n}\r\nkey.remote_ipv6[0] = _htonl(0x2401db00);\r\nkey.tunnel_ttl = 64;\r\nif (iph->protocol == IPPROTO_ICMP) {\r\nkey.remote_ipv6[3] = _htonl(1);\r\n} else {\r\nif (iph->protocol != IPPROTO_TCP || iph->ihl != 5) {\r\nERROR(iph->protocol);\r\nreturn TC_ACT_SHOT;\r\n}\r\nif (tcp->dest == htons(5200)) {\r\nkey.remote_ipv6[3] = _htonl(1);\r\n} else if (tcp->dest == htons(5201)) {\r\nkey.remote_ipv6[3] = _htonl(2);\r\n} else {\r\nERROR(tcp->dest);\r\nreturn TC_ACT_SHOT;\r\n}\r\n}\r\nret = bpf_skb_set_tunnel_key(skb, &key, sizeof(key), BPF_F_TUNINFO_IPV6);\r\nif (ret < 0) {\r\nERROR(ret);\r\nreturn TC_ACT_SHOT;\r\n}\r\nreturn TC_ACT_OK;\r\n}\r\nint _ipip6_get_tunnel(struct __sk_buff *skb)\r\n{\r\nint ret;\r\nstruct bpf_tunnel_key key;\r\nchar fmt[] = "remote ip6 %x::%x\n";\r\nret = bpf_skb_get_tunnel_key(skb, &key, sizeof(key), BPF_F_TUNINFO_IPV6);\r\nif (ret < 0) {\r\nERROR(ret);\r\nreturn TC_ACT_SHOT;\r\n}\r\nbpf_trace_printk(fmt, sizeof(fmt), _htonl(key.remote_ipv6[0]),\r\n_htonl(key.remote_ipv6[3]));\r\nreturn TC_ACT_OK;\r\n}\r\nint _ip6ip6_set_tunnel(struct __sk_buff *skb)\r\n{\r\nstruct bpf_tunnel_key key = {};\r\nvoid *data = (void *)(long)skb->data;\r\nstruct ipv6hdr *iph = data;\r\nstruct tcphdr *tcp = data + sizeof(*iph);\r\nvoid *data_end = (void *)(long)skb->data_end;\r\nint ret;\r\nif (data + sizeof(*iph) + sizeof(*tcp) > data_end) {\r\nERROR(1);\r\nreturn TC_ACT_SHOT;\r\n}\r\nkey.remote_ipv6[0] = _htonl(0x2401db00);\r\nkey.tunnel_ttl = 64;\r\nif (iph->nexthdr == NEXTHDR_ICMP) {\r\nkey.remote_ipv6[3] = _htonl(1);\r\n} else {\r\nif (iph->nexthdr != NEXTHDR_TCP) {\r\nERROR(iph->nexthdr);\r\nreturn TC_ACT_SHOT;\r\n}\r\nif (tcp->dest == htons(5200)) {\r\nkey.remote_ipv6[3] = _htonl(1);\r\n} else if (tcp->dest == htons(5201)) {\r\nkey.remote_ipv6[3] = _htonl(2);\r\n} else {\r\nERROR(tcp->dest);\r\nreturn TC_ACT_SHOT;\r\n}\r\n}\r\nret = bpf_skb_set_tunnel_key(skb, &key, sizeof(key), BPF_F_TUNINFO_IPV6);\r\nif (ret < 0) {\r\nERROR(ret);\r\nreturn TC_ACT_SHOT;\r\n}\r\nreturn TC_ACT_OK;\r\n}\r\nint _ip6ip6_get_tunnel(struct __sk_buff *skb)\r\n{\r\nint ret;\r\nstruct bpf_tunnel_key key;\r\nchar fmt[] = "remote ip6 %x::%x\n";\r\nret = bpf_skb_get_tunnel_key(skb, &key, sizeof(key), BPF_F_TUNINFO_IPV6);\r\nif (ret < 0) {\r\nERROR(ret);\r\nreturn TC_ACT_SHOT;\r\n}\r\nbpf_trace_printk(fmt, sizeof(fmt), _htonl(key.remote_ipv6[0]),\r\n_htonl(key.remote_ipv6[3]));\r\nreturn TC_ACT_OK;\r\n}
