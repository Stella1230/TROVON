static void update_attr(u8 *dst, u8 *src, int attribute,\r\nstruct vc_data *vc)\r\n{\r\nint i, offset = (vc->vc_font.height < 10) ? 1 : 2;\r\nint width = DIV_ROUND_UP(vc->vc_font.width, 8);\r\nunsigned int cellsize = vc->vc_font.height * width;\r\nu8 c;\r\noffset = cellsize - (offset * width);\r\nfor (i = 0; i < cellsize; i++) {\r\nc = src[i];\r\nif (attribute & FBCON_ATTRIBUTE_UNDERLINE && i >= offset)\r\nc = 0xff;\r\nif (attribute & FBCON_ATTRIBUTE_BOLD)\r\nc |= c >> 1;\r\nif (attribute & FBCON_ATTRIBUTE_REVERSE)\r\nc = ~c;\r\ndst[i] = c;\r\n}\r\n}\r\nstatic void bit_bmove(struct vc_data *vc, struct fb_info *info, int sy,\r\nint sx, int dy, int dx, int height, int width)\r\n{\r\nstruct fb_copyarea area;\r\narea.sx = sx * vc->vc_font.width;\r\narea.sy = sy * vc->vc_font.height;\r\narea.dx = dx * vc->vc_font.width;\r\narea.dy = dy * vc->vc_font.height;\r\narea.height = height * vc->vc_font.height;\r\narea.width = width * vc->vc_font.width;\r\ninfo->fbops->fb_copyarea(info, &area);\r\n}\r\nstatic void bit_clear(struct vc_data *vc, struct fb_info *info, int sy,\r\nint sx, int height, int width)\r\n{\r\nint bgshift = (vc->vc_hi_font_mask) ? 13 : 12;\r\nstruct fb_fillrect region;\r\nregion.color = attr_bgcol_ec(bgshift, vc, info);\r\nregion.dx = sx * vc->vc_font.width;\r\nregion.dy = sy * vc->vc_font.height;\r\nregion.width = width * vc->vc_font.width;\r\nregion.height = height * vc->vc_font.height;\r\nregion.rop = ROP_COPY;\r\ninfo->fbops->fb_fillrect(info, &region);\r\n}\r\nstatic inline void bit_putcs_aligned(struct vc_data *vc, struct fb_info *info,\r\nconst u16 *s, u32 attr, u32 cnt,\r\nu32 d_pitch, u32 s_pitch, u32 cellsize,\r\nstruct fb_image *image, u8 *buf, u8 *dst)\r\n{\r\nu16 charmask = vc->vc_hi_font_mask ? 0x1ff : 0xff;\r\nu32 idx = vc->vc_font.width >> 3;\r\nu8 *src;\r\nwhile (cnt--) {\r\nsrc = vc->vc_font.data + (scr_readw(s++)&\r\ncharmask)*cellsize;\r\nif (attr) {\r\nupdate_attr(buf, src, attr, vc);\r\nsrc = buf;\r\n}\r\nif (likely(idx == 1))\r\n__fb_pad_aligned_buffer(dst, d_pitch, src, idx,\r\nimage->height);\r\nelse\r\nfb_pad_aligned_buffer(dst, d_pitch, src, idx,\r\nimage->height);\r\ndst += s_pitch;\r\n}\r\ninfo->fbops->fb_imageblit(info, image);\r\n}\r\nstatic inline void bit_putcs_unaligned(struct vc_data *vc,\r\nstruct fb_info *info, const u16 *s,\r\nu32 attr, u32 cnt, u32 d_pitch,\r\nu32 s_pitch, u32 cellsize,\r\nstruct fb_image *image, u8 *buf,\r\nu8 *dst)\r\n{\r\nu16 charmask = vc->vc_hi_font_mask ? 0x1ff : 0xff;\r\nu32 shift_low = 0, mod = vc->vc_font.width % 8;\r\nu32 shift_high = 8;\r\nu32 idx = vc->vc_font.width >> 3;\r\nu8 *src;\r\nwhile (cnt--) {\r\nsrc = vc->vc_font.data + (scr_readw(s++)&\r\ncharmask)*cellsize;\r\nif (attr) {\r\nupdate_attr(buf, src, attr, vc);\r\nsrc = buf;\r\n}\r\nfb_pad_unaligned_buffer(dst, d_pitch, src, idx,\r\nimage->height, shift_high,\r\nshift_low, mod);\r\nshift_low += mod;\r\ndst += (shift_low >= 8) ? s_pitch : s_pitch - 1;\r\nshift_low &= 7;\r\nshift_high = 8 - shift_low;\r\n}\r\ninfo->fbops->fb_imageblit(info, image);\r\n}\r\nstatic void bit_putcs(struct vc_data *vc, struct fb_info *info,\r\nconst unsigned short *s, int count, int yy, int xx,\r\nint fg, int bg)\r\n{\r\nstruct fb_image image;\r\nu32 width = DIV_ROUND_UP(vc->vc_font.width, 8);\r\nu32 cellsize = width * vc->vc_font.height;\r\nu32 maxcnt = info->pixmap.size/cellsize;\r\nu32 scan_align = info->pixmap.scan_align - 1;\r\nu32 buf_align = info->pixmap.buf_align - 1;\r\nu32 mod = vc->vc_font.width % 8, cnt, pitch, size;\r\nu32 attribute = get_attribute(info, scr_readw(s));\r\nu8 *dst, *buf = NULL;\r\nimage.fg_color = fg;\r\nimage.bg_color = bg;\r\nimage.dx = xx * vc->vc_font.width;\r\nimage.dy = yy * vc->vc_font.height;\r\nimage.height = vc->vc_font.height;\r\nimage.depth = 1;\r\nif (attribute) {\r\nbuf = kmalloc(cellsize, GFP_ATOMIC);\r\nif (!buf)\r\nreturn;\r\n}\r\nwhile (count) {\r\nif (count > maxcnt)\r\ncnt = maxcnt;\r\nelse\r\ncnt = count;\r\nimage.width = vc->vc_font.width * cnt;\r\npitch = DIV_ROUND_UP(image.width, 8) + scan_align;\r\npitch &= ~scan_align;\r\nsize = pitch * image.height + buf_align;\r\nsize &= ~buf_align;\r\ndst = fb_get_buffer_offset(info, &info->pixmap, size);\r\nimage.data = dst;\r\nif (!mod)\r\nbit_putcs_aligned(vc, info, s, attribute, cnt, pitch,\r\nwidth, cellsize, &image, buf, dst);\r\nelse\r\nbit_putcs_unaligned(vc, info, s, attribute, cnt,\r\npitch, width, cellsize, &image,\r\nbuf, dst);\r\nimage.dx += cnt * vc->vc_font.width;\r\ncount -= cnt;\r\ns += cnt;\r\n}\r\nif (unlikely(buf))\r\nkfree(buf);\r\n}\r\nstatic void bit_clear_margins(struct vc_data *vc, struct fb_info *info,\r\nint bottom_only)\r\n{\r\nunsigned int cw = vc->vc_font.width;\r\nunsigned int ch = vc->vc_font.height;\r\nunsigned int rw = info->var.xres - (vc->vc_cols*cw);\r\nunsigned int bh = info->var.yres - (vc->vc_rows*ch);\r\nunsigned int rs = info->var.xres - rw;\r\nunsigned int bs = info->var.yres - bh;\r\nstruct fb_fillrect region;\r\nregion.color = 0;\r\nregion.rop = ROP_COPY;\r\nif (rw && !bottom_only) {\r\nregion.dx = info->var.xoffset + rs;\r\nregion.dy = 0;\r\nregion.width = rw;\r\nregion.height = info->var.yres_virtual;\r\ninfo->fbops->fb_fillrect(info, &region);\r\n}\r\nif (bh) {\r\nregion.dx = info->var.xoffset;\r\nregion.dy = info->var.yoffset + bs;\r\nregion.width = rs;\r\nregion.height = bh;\r\ninfo->fbops->fb_fillrect(info, &region);\r\n}\r\n}\r\nstatic void bit_cursor(struct vc_data *vc, struct fb_info *info, int mode,\r\nint softback_lines, int fg, int bg)\r\n{\r\nstruct fb_cursor cursor;\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nunsigned short charmask = vc->vc_hi_font_mask ? 0x1ff : 0xff;\r\nint w = DIV_ROUND_UP(vc->vc_font.width, 8), c;\r\nint y = real_y(ops->p, vc->vc_y);\r\nint attribute, use_sw = (vc->vc_cursor_type & 0x10);\r\nint err = 1;\r\nchar *src;\r\ncursor.set = 0;\r\nif (softback_lines) {\r\nif (y + softback_lines >= vc->vc_rows) {\r\nmode = CM_ERASE;\r\nops->cursor_flash = 0;\r\nreturn;\r\n} else\r\ny += softback_lines;\r\n}\r\nc = scr_readw((u16 *) vc->vc_pos);\r\nattribute = get_attribute(info, c);\r\nsrc = vc->vc_font.data + ((c & charmask) * (w * vc->vc_font.height));\r\nif (ops->cursor_state.image.data != src ||\r\nops->cursor_reset) {\r\nops->cursor_state.image.data = src;\r\ncursor.set |= FB_CUR_SETIMAGE;\r\n}\r\nif (attribute) {\r\nu8 *dst;\r\ndst = kmalloc(w * vc->vc_font.height, GFP_ATOMIC);\r\nif (!dst)\r\nreturn;\r\nkfree(ops->cursor_data);\r\nops->cursor_data = dst;\r\nupdate_attr(dst, src, attribute, vc);\r\nsrc = dst;\r\n}\r\nif (ops->cursor_state.image.fg_color != fg ||\r\nops->cursor_state.image.bg_color != bg ||\r\nops->cursor_reset) {\r\nops->cursor_state.image.fg_color = fg;\r\nops->cursor_state.image.bg_color = bg;\r\ncursor.set |= FB_CUR_SETCMAP;\r\n}\r\nif ((ops->cursor_state.image.dx != (vc->vc_font.width * vc->vc_x)) ||\r\n(ops->cursor_state.image.dy != (vc->vc_font.height * y)) ||\r\nops->cursor_reset) {\r\nops->cursor_state.image.dx = vc->vc_font.width * vc->vc_x;\r\nops->cursor_state.image.dy = vc->vc_font.height * y;\r\ncursor.set |= FB_CUR_SETPOS;\r\n}\r\nif (ops->cursor_state.image.height != vc->vc_font.height ||\r\nops->cursor_state.image.width != vc->vc_font.width ||\r\nops->cursor_reset) {\r\nops->cursor_state.image.height = vc->vc_font.height;\r\nops->cursor_state.image.width = vc->vc_font.width;\r\ncursor.set |= FB_CUR_SETSIZE;\r\n}\r\nif (ops->cursor_state.hot.x || ops->cursor_state.hot.y ||\r\nops->cursor_reset) {\r\nops->cursor_state.hot.x = cursor.hot.y = 0;\r\ncursor.set |= FB_CUR_SETHOT;\r\n}\r\nif (cursor.set & FB_CUR_SETSIZE ||\r\nvc->vc_cursor_type != ops->p->cursor_shape ||\r\nops->cursor_state.mask == NULL ||\r\nops->cursor_reset) {\r\nchar *mask = kmalloc(w*vc->vc_font.height, GFP_ATOMIC);\r\nint cur_height, size, i = 0;\r\nu8 msk = 0xff;\r\nif (!mask)\r\nreturn;\r\nkfree(ops->cursor_state.mask);\r\nops->cursor_state.mask = mask;\r\nops->p->cursor_shape = vc->vc_cursor_type;\r\ncursor.set |= FB_CUR_SETSHAPE;\r\nswitch (ops->p->cursor_shape & CUR_HWMASK) {\r\ncase CUR_NONE:\r\ncur_height = 0;\r\nbreak;\r\ncase CUR_UNDERLINE:\r\ncur_height = (vc->vc_font.height < 10) ? 1 : 2;\r\nbreak;\r\ncase CUR_LOWER_THIRD:\r\ncur_height = vc->vc_font.height/3;\r\nbreak;\r\ncase CUR_LOWER_HALF:\r\ncur_height = vc->vc_font.height >> 1;\r\nbreak;\r\ncase CUR_TWO_THIRDS:\r\ncur_height = (vc->vc_font.height << 1)/3;\r\nbreak;\r\ncase CUR_BLOCK:\r\ndefault:\r\ncur_height = vc->vc_font.height;\r\nbreak;\r\n}\r\nsize = (vc->vc_font.height - cur_height) * w;\r\nwhile (size--)\r\nmask[i++] = ~msk;\r\nsize = cur_height * w;\r\nwhile (size--)\r\nmask[i++] = msk;\r\n}\r\nswitch (mode) {\r\ncase CM_ERASE:\r\nops->cursor_state.enable = 0;\r\nbreak;\r\ncase CM_DRAW:\r\ncase CM_MOVE:\r\ndefault:\r\nops->cursor_state.enable = (use_sw) ? 0 : 1;\r\nbreak;\r\n}\r\ncursor.image.data = src;\r\ncursor.image.fg_color = ops->cursor_state.image.fg_color;\r\ncursor.image.bg_color = ops->cursor_state.image.bg_color;\r\ncursor.image.dx = ops->cursor_state.image.dx;\r\ncursor.image.dy = ops->cursor_state.image.dy;\r\ncursor.image.height = ops->cursor_state.image.height;\r\ncursor.image.width = ops->cursor_state.image.width;\r\ncursor.hot.x = ops->cursor_state.hot.x;\r\ncursor.hot.y = ops->cursor_state.hot.y;\r\ncursor.mask = ops->cursor_state.mask;\r\ncursor.enable = ops->cursor_state.enable;\r\ncursor.image.depth = 1;\r\ncursor.rop = ROP_XOR;\r\nif (info->fbops->fb_cursor)\r\nerr = info->fbops->fb_cursor(info, &cursor);\r\nif (err)\r\nsoft_cursor(info, &cursor);\r\nops->cursor_reset = 0;\r\n}\r\nstatic int bit_update_start(struct fb_info *info)\r\n{\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nint err;\r\nerr = fb_pan_display(info, &ops->var);\r\nops->var.xoffset = info->var.xoffset;\r\nops->var.yoffset = info->var.yoffset;\r\nops->var.vmode = info->var.vmode;\r\nreturn err;\r\n}\r\nvoid fbcon_set_bitops(struct fbcon_ops *ops)\r\n{\r\nops->bmove = bit_bmove;\r\nops->clear = bit_clear;\r\nops->putcs = bit_putcs;\r\nops->clear_margins = bit_clear_margins;\r\nops->cursor = bit_cursor;\r\nops->update_start = bit_update_start;\r\nops->rotate_font = NULL;\r\nif (ops->rotate)\r\nfbcon_set_rotate(ops);\r\n}
