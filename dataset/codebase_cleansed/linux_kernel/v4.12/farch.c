static inline void ef4_write_buf_tbl(struct ef4_nic *efx, ef4_qword_t *value,\r\nunsigned int index)\r\n{\r\nef4_sram_writeq(efx, efx->membase + efx->type->buf_tbl_base,\r\nvalue, index);\r\n}\r\nstatic bool ef4_masked_compare_oword(const ef4_oword_t *a, const ef4_oword_t *b,\r\nconst ef4_oword_t *mask)\r\n{\r\nreturn ((a->u64[0] ^ b->u64[0]) & mask->u64[0]) ||\r\n((a->u64[1] ^ b->u64[1]) & mask->u64[1]);\r\n}\r\nint ef4_farch_test_registers(struct ef4_nic *efx,\r\nconst struct ef4_farch_register_test *regs,\r\nsize_t n_regs)\r\n{\r\nunsigned address = 0;\r\nint i, j;\r\nef4_oword_t mask, imask, original, reg, buf;\r\nfor (i = 0; i < n_regs; ++i) {\r\naddress = regs[i].address;\r\nmask = imask = regs[i].mask;\r\nEF4_INVERT_OWORD(imask);\r\nef4_reado(efx, &original, address);\r\nfor (j = 0; j < 128; j++) {\r\nif (!EF4_EXTRACT_OWORD32(mask, j, j))\r\ncontinue;\r\nEF4_AND_OWORD(reg, original, mask);\r\nEF4_SET_OWORD32(reg, j, j, 1);\r\nef4_writeo(efx, &reg, address);\r\nef4_reado(efx, &buf, address);\r\nif (ef4_masked_compare_oword(&reg, &buf, &mask))\r\ngoto fail;\r\nEF4_OR_OWORD(reg, original, mask);\r\nEF4_SET_OWORD32(reg, j, j, 0);\r\nef4_writeo(efx, &reg, address);\r\nef4_reado(efx, &buf, address);\r\nif (ef4_masked_compare_oword(&reg, &buf, &mask))\r\ngoto fail;\r\n}\r\nef4_writeo(efx, &original, address);\r\n}\r\nreturn 0;\r\nfail:\r\nnetif_err(efx, hw, efx->net_dev,\r\n"wrote "EF4_OWORD_FMT" read "EF4_OWORD_FMT\r\n" at address 0x%x mask "EF4_OWORD_FMT"\n", EF4_OWORD_VAL(reg),\r\nEF4_OWORD_VAL(buf), address, EF4_OWORD_VAL(mask));\r\nreturn -EIO;\r\n}\r\nstatic void\r\nef4_init_special_buffer(struct ef4_nic *efx, struct ef4_special_buffer *buffer)\r\n{\r\nef4_qword_t buf_desc;\r\nunsigned int index;\r\ndma_addr_t dma_addr;\r\nint i;\r\nEF4_BUG_ON_PARANOID(!buffer->buf.addr);\r\nfor (i = 0; i < buffer->entries; i++) {\r\nindex = buffer->index + i;\r\ndma_addr = buffer->buf.dma_addr + (i * EF4_BUF_SIZE);\r\nnetif_dbg(efx, probe, efx->net_dev,\r\n"mapping special buffer %d at %llx\n",\r\nindex, (unsigned long long)dma_addr);\r\nEF4_POPULATE_QWORD_3(buf_desc,\r\nFRF_AZ_BUF_ADR_REGION, 0,\r\nFRF_AZ_BUF_ADR_FBUF, dma_addr >> 12,\r\nFRF_AZ_BUF_OWNER_ID_FBUF, 0);\r\nef4_write_buf_tbl(efx, &buf_desc, index);\r\n}\r\n}\r\nstatic void\r\nef4_fini_special_buffer(struct ef4_nic *efx, struct ef4_special_buffer *buffer)\r\n{\r\nef4_oword_t buf_tbl_upd;\r\nunsigned int start = buffer->index;\r\nunsigned int end = (buffer->index + buffer->entries - 1);\r\nif (!buffer->entries)\r\nreturn;\r\nnetif_dbg(efx, hw, efx->net_dev, "unmapping special buffers %d-%d\n",\r\nbuffer->index, buffer->index + buffer->entries - 1);\r\nEF4_POPULATE_OWORD_4(buf_tbl_upd,\r\nFRF_AZ_BUF_UPD_CMD, 0,\r\nFRF_AZ_BUF_CLR_CMD, 1,\r\nFRF_AZ_BUF_CLR_END_ID, end,\r\nFRF_AZ_BUF_CLR_START_ID, start);\r\nef4_writeo(efx, &buf_tbl_upd, FR_AZ_BUF_TBL_UPD);\r\n}\r\nstatic int ef4_alloc_special_buffer(struct ef4_nic *efx,\r\nstruct ef4_special_buffer *buffer,\r\nunsigned int len)\r\n{\r\nlen = ALIGN(len, EF4_BUF_SIZE);\r\nif (ef4_nic_alloc_buffer(efx, &buffer->buf, len, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nbuffer->entries = len / EF4_BUF_SIZE;\r\nBUG_ON(buffer->buf.dma_addr & (EF4_BUF_SIZE - 1));\r\nbuffer->index = efx->next_buffer_table;\r\nefx->next_buffer_table += buffer->entries;\r\nnetif_dbg(efx, probe, efx->net_dev,\r\n"allocating special buffers %d-%d at %llx+%x "\r\n"(virt %p phys %llx)\n", buffer->index,\r\nbuffer->index + buffer->entries - 1,\r\n(u64)buffer->buf.dma_addr, len,\r\nbuffer->buf.addr, (u64)virt_to_phys(buffer->buf.addr));\r\nreturn 0;\r\n}\r\nstatic void\r\nef4_free_special_buffer(struct ef4_nic *efx, struct ef4_special_buffer *buffer)\r\n{\r\nif (!buffer->buf.addr)\r\nreturn;\r\nnetif_dbg(efx, hw, efx->net_dev,\r\n"deallocating special buffers %d-%d at %llx+%x "\r\n"(virt %p phys %llx)\n", buffer->index,\r\nbuffer->index + buffer->entries - 1,\r\n(u64)buffer->buf.dma_addr, buffer->buf.len,\r\nbuffer->buf.addr, (u64)virt_to_phys(buffer->buf.addr));\r\nef4_nic_free_buffer(efx, &buffer->buf);\r\nbuffer->entries = 0;\r\n}\r\nstatic inline void ef4_farch_notify_tx_desc(struct ef4_tx_queue *tx_queue)\r\n{\r\nunsigned write_ptr;\r\nef4_dword_t reg;\r\nwrite_ptr = tx_queue->write_count & tx_queue->ptr_mask;\r\nEF4_POPULATE_DWORD_1(reg, FRF_AZ_TX_DESC_WPTR_DWORD, write_ptr);\r\nef4_writed_page(tx_queue->efx, &reg,\r\nFR_AZ_TX_DESC_UPD_DWORD_P0, tx_queue->queue);\r\n}\r\nstatic inline void ef4_farch_push_tx_desc(struct ef4_tx_queue *tx_queue,\r\nconst ef4_qword_t *txd)\r\n{\r\nunsigned write_ptr;\r\nef4_oword_t reg;\r\nBUILD_BUG_ON(FRF_AZ_TX_DESC_LBN != 0);\r\nBUILD_BUG_ON(FR_AA_TX_DESC_UPD_KER != FR_BZ_TX_DESC_UPD_P0);\r\nwrite_ptr = tx_queue->write_count & tx_queue->ptr_mask;\r\nEF4_POPULATE_OWORD_2(reg, FRF_AZ_TX_DESC_PUSH_CMD, true,\r\nFRF_AZ_TX_DESC_WPTR, write_ptr);\r\nreg.qword[0] = *txd;\r\nef4_writeo_page(tx_queue->efx, &reg,\r\nFR_BZ_TX_DESC_UPD_P0, tx_queue->queue);\r\n}\r\nvoid ef4_farch_tx_write(struct ef4_tx_queue *tx_queue)\r\n{\r\nstruct ef4_tx_buffer *buffer;\r\nef4_qword_t *txd;\r\nunsigned write_ptr;\r\nunsigned old_write_count = tx_queue->write_count;\r\ntx_queue->xmit_more_available = false;\r\nif (unlikely(tx_queue->write_count == tx_queue->insert_count))\r\nreturn;\r\ndo {\r\nwrite_ptr = tx_queue->write_count & tx_queue->ptr_mask;\r\nbuffer = &tx_queue->buffer[write_ptr];\r\ntxd = ef4_tx_desc(tx_queue, write_ptr);\r\n++tx_queue->write_count;\r\nEF4_BUG_ON_PARANOID(buffer->flags & EF4_TX_BUF_OPTION);\r\nBUILD_BUG_ON(EF4_TX_BUF_CONT != 1);\r\nEF4_POPULATE_QWORD_4(*txd,\r\nFSF_AZ_TX_KER_CONT,\r\nbuffer->flags & EF4_TX_BUF_CONT,\r\nFSF_AZ_TX_KER_BYTE_COUNT, buffer->len,\r\nFSF_AZ_TX_KER_BUF_REGION, 0,\r\nFSF_AZ_TX_KER_BUF_ADDR, buffer->dma_addr);\r\n} while (tx_queue->write_count != tx_queue->insert_count);\r\nwmb();\r\nif (ef4_nic_may_push_tx_desc(tx_queue, old_write_count)) {\r\ntxd = ef4_tx_desc(tx_queue,\r\nold_write_count & tx_queue->ptr_mask);\r\nef4_farch_push_tx_desc(tx_queue, txd);\r\n++tx_queue->pushes;\r\n} else {\r\nef4_farch_notify_tx_desc(tx_queue);\r\n}\r\n}\r\nunsigned int ef4_farch_tx_limit_len(struct ef4_tx_queue *tx_queue,\r\ndma_addr_t dma_addr, unsigned int len)\r\n{\r\nunsigned int limit = (~dma_addr & (EF4_PAGE_SIZE - 1)) + 1;\r\nlen = min(limit, len);\r\nif (EF4_WORKAROUND_5391(tx_queue->efx) && (dma_addr & 0xf))\r\nlen = min_t(unsigned int, len, 512 - (dma_addr & 0xf));\r\nreturn len;\r\n}\r\nint ef4_farch_tx_probe(struct ef4_tx_queue *tx_queue)\r\n{\r\nstruct ef4_nic *efx = tx_queue->efx;\r\nunsigned entries;\r\nentries = tx_queue->ptr_mask + 1;\r\nreturn ef4_alloc_special_buffer(efx, &tx_queue->txd,\r\nentries * sizeof(ef4_qword_t));\r\n}\r\nvoid ef4_farch_tx_init(struct ef4_tx_queue *tx_queue)\r\n{\r\nstruct ef4_nic *efx = tx_queue->efx;\r\nef4_oword_t reg;\r\nef4_init_special_buffer(efx, &tx_queue->txd);\r\nEF4_POPULATE_OWORD_10(reg,\r\nFRF_AZ_TX_DESCQ_EN, 1,\r\nFRF_AZ_TX_ISCSI_DDIG_EN, 0,\r\nFRF_AZ_TX_ISCSI_HDIG_EN, 0,\r\nFRF_AZ_TX_DESCQ_BUF_BASE_ID, tx_queue->txd.index,\r\nFRF_AZ_TX_DESCQ_EVQ_ID,\r\ntx_queue->channel->channel,\r\nFRF_AZ_TX_DESCQ_OWNER_ID, 0,\r\nFRF_AZ_TX_DESCQ_LABEL, tx_queue->queue,\r\nFRF_AZ_TX_DESCQ_SIZE,\r\n__ffs(tx_queue->txd.entries),\r\nFRF_AZ_TX_DESCQ_TYPE, 0,\r\nFRF_BZ_TX_NON_IP_DROP_DIS, 1);\r\nif (ef4_nic_rev(efx) >= EF4_REV_FALCON_B0) {\r\nint csum = tx_queue->queue & EF4_TXQ_TYPE_OFFLOAD;\r\nEF4_SET_OWORD_FIELD(reg, FRF_BZ_TX_IP_CHKSM_DIS, !csum);\r\nEF4_SET_OWORD_FIELD(reg, FRF_BZ_TX_TCP_CHKSM_DIS,\r\n!csum);\r\n}\r\nef4_writeo_table(efx, &reg, efx->type->txd_ptr_tbl_base,\r\ntx_queue->queue);\r\nif (ef4_nic_rev(efx) < EF4_REV_FALCON_B0) {\r\nBUILD_BUG_ON(EF4_MAX_TX_QUEUES > 128);\r\nef4_reado(efx, &reg, FR_AA_TX_CHKSM_CFG);\r\nif (tx_queue->queue & EF4_TXQ_TYPE_OFFLOAD)\r\n__clear_bit_le(tx_queue->queue, &reg);\r\nelse\r\n__set_bit_le(tx_queue->queue, &reg);\r\nef4_writeo(efx, &reg, FR_AA_TX_CHKSM_CFG);\r\n}\r\nif (ef4_nic_rev(efx) >= EF4_REV_FALCON_B0) {\r\nEF4_POPULATE_OWORD_1(reg,\r\nFRF_BZ_TX_PACE,\r\n(tx_queue->queue & EF4_TXQ_TYPE_HIGHPRI) ?\r\nFFE_BZ_TX_PACE_OFF :\r\nFFE_BZ_TX_PACE_RESERVED);\r\nef4_writeo_table(efx, &reg, FR_BZ_TX_PACE_TBL,\r\ntx_queue->queue);\r\n}\r\n}\r\nstatic void ef4_farch_flush_tx_queue(struct ef4_tx_queue *tx_queue)\r\n{\r\nstruct ef4_nic *efx = tx_queue->efx;\r\nef4_oword_t tx_flush_descq;\r\nWARN_ON(atomic_read(&tx_queue->flush_outstanding));\r\natomic_set(&tx_queue->flush_outstanding, 1);\r\nEF4_POPULATE_OWORD_2(tx_flush_descq,\r\nFRF_AZ_TX_FLUSH_DESCQ_CMD, 1,\r\nFRF_AZ_TX_FLUSH_DESCQ, tx_queue->queue);\r\nef4_writeo(efx, &tx_flush_descq, FR_AZ_TX_FLUSH_DESCQ);\r\n}\r\nvoid ef4_farch_tx_fini(struct ef4_tx_queue *tx_queue)\r\n{\r\nstruct ef4_nic *efx = tx_queue->efx;\r\nef4_oword_t tx_desc_ptr;\r\nEF4_ZERO_OWORD(tx_desc_ptr);\r\nef4_writeo_table(efx, &tx_desc_ptr, efx->type->txd_ptr_tbl_base,\r\ntx_queue->queue);\r\nef4_fini_special_buffer(efx, &tx_queue->txd);\r\n}\r\nvoid ef4_farch_tx_remove(struct ef4_tx_queue *tx_queue)\r\n{\r\nef4_free_special_buffer(tx_queue->efx, &tx_queue->txd);\r\n}\r\nstatic inline void\r\nef4_farch_build_rx_desc(struct ef4_rx_queue *rx_queue, unsigned index)\r\n{\r\nstruct ef4_rx_buffer *rx_buf;\r\nef4_qword_t *rxd;\r\nrxd = ef4_rx_desc(rx_queue, index);\r\nrx_buf = ef4_rx_buffer(rx_queue, index);\r\nEF4_POPULATE_QWORD_3(*rxd,\r\nFSF_AZ_RX_KER_BUF_SIZE,\r\nrx_buf->len -\r\nrx_queue->efx->type->rx_buffer_padding,\r\nFSF_AZ_RX_KER_BUF_REGION, 0,\r\nFSF_AZ_RX_KER_BUF_ADDR, rx_buf->dma_addr);\r\n}\r\nvoid ef4_farch_rx_write(struct ef4_rx_queue *rx_queue)\r\n{\r\nstruct ef4_nic *efx = rx_queue->efx;\r\nef4_dword_t reg;\r\nunsigned write_ptr;\r\nwhile (rx_queue->notified_count != rx_queue->added_count) {\r\nef4_farch_build_rx_desc(\r\nrx_queue,\r\nrx_queue->notified_count & rx_queue->ptr_mask);\r\n++rx_queue->notified_count;\r\n}\r\nwmb();\r\nwrite_ptr = rx_queue->added_count & rx_queue->ptr_mask;\r\nEF4_POPULATE_DWORD_1(reg, FRF_AZ_RX_DESC_WPTR_DWORD, write_ptr);\r\nef4_writed_page(efx, &reg, FR_AZ_RX_DESC_UPD_DWORD_P0,\r\nef4_rx_queue_index(rx_queue));\r\n}\r\nint ef4_farch_rx_probe(struct ef4_rx_queue *rx_queue)\r\n{\r\nstruct ef4_nic *efx = rx_queue->efx;\r\nunsigned entries;\r\nentries = rx_queue->ptr_mask + 1;\r\nreturn ef4_alloc_special_buffer(efx, &rx_queue->rxd,\r\nentries * sizeof(ef4_qword_t));\r\n}\r\nvoid ef4_farch_rx_init(struct ef4_rx_queue *rx_queue)\r\n{\r\nef4_oword_t rx_desc_ptr;\r\nstruct ef4_nic *efx = rx_queue->efx;\r\nbool is_b0 = ef4_nic_rev(efx) >= EF4_REV_FALCON_B0;\r\nbool iscsi_digest_en = is_b0;\r\nbool jumbo_en;\r\njumbo_en = !is_b0 || efx->rx_scatter;\r\nnetif_dbg(efx, hw, efx->net_dev,\r\n"RX queue %d ring in special buffers %d-%d\n",\r\nef4_rx_queue_index(rx_queue), rx_queue->rxd.index,\r\nrx_queue->rxd.index + rx_queue->rxd.entries - 1);\r\nrx_queue->scatter_n = 0;\r\nef4_init_special_buffer(efx, &rx_queue->rxd);\r\nEF4_POPULATE_OWORD_10(rx_desc_ptr,\r\nFRF_AZ_RX_ISCSI_DDIG_EN, iscsi_digest_en,\r\nFRF_AZ_RX_ISCSI_HDIG_EN, iscsi_digest_en,\r\nFRF_AZ_RX_DESCQ_BUF_BASE_ID, rx_queue->rxd.index,\r\nFRF_AZ_RX_DESCQ_EVQ_ID,\r\nef4_rx_queue_channel(rx_queue)->channel,\r\nFRF_AZ_RX_DESCQ_OWNER_ID, 0,\r\nFRF_AZ_RX_DESCQ_LABEL,\r\nef4_rx_queue_index(rx_queue),\r\nFRF_AZ_RX_DESCQ_SIZE,\r\n__ffs(rx_queue->rxd.entries),\r\nFRF_AZ_RX_DESCQ_TYPE, 0 ,\r\nFRF_AZ_RX_DESCQ_JUMBO, jumbo_en,\r\nFRF_AZ_RX_DESCQ_EN, 1);\r\nef4_writeo_table(efx, &rx_desc_ptr, efx->type->rxd_ptr_tbl_base,\r\nef4_rx_queue_index(rx_queue));\r\n}\r\nstatic void ef4_farch_flush_rx_queue(struct ef4_rx_queue *rx_queue)\r\n{\r\nstruct ef4_nic *efx = rx_queue->efx;\r\nef4_oword_t rx_flush_descq;\r\nEF4_POPULATE_OWORD_2(rx_flush_descq,\r\nFRF_AZ_RX_FLUSH_DESCQ_CMD, 1,\r\nFRF_AZ_RX_FLUSH_DESCQ,\r\nef4_rx_queue_index(rx_queue));\r\nef4_writeo(efx, &rx_flush_descq, FR_AZ_RX_FLUSH_DESCQ);\r\n}\r\nvoid ef4_farch_rx_fini(struct ef4_rx_queue *rx_queue)\r\n{\r\nef4_oword_t rx_desc_ptr;\r\nstruct ef4_nic *efx = rx_queue->efx;\r\nEF4_ZERO_OWORD(rx_desc_ptr);\r\nef4_writeo_table(efx, &rx_desc_ptr, efx->type->rxd_ptr_tbl_base,\r\nef4_rx_queue_index(rx_queue));\r\nef4_fini_special_buffer(efx, &rx_queue->rxd);\r\n}\r\nvoid ef4_farch_rx_remove(struct ef4_rx_queue *rx_queue)\r\n{\r\nef4_free_special_buffer(rx_queue->efx, &rx_queue->rxd);\r\n}\r\nstatic bool ef4_farch_flush_wake(struct ef4_nic *efx)\r\n{\r\nsmp_mb();\r\nreturn (atomic_read(&efx->active_queues) == 0 ||\r\n(atomic_read(&efx->rxq_flush_outstanding) < EF4_RX_FLUSH_COUNT\r\n&& atomic_read(&efx->rxq_flush_pending) > 0));\r\n}\r\nstatic bool ef4_check_tx_flush_complete(struct ef4_nic *efx)\r\n{\r\nbool i = true;\r\nef4_oword_t txd_ptr_tbl;\r\nstruct ef4_channel *channel;\r\nstruct ef4_tx_queue *tx_queue;\r\nef4_for_each_channel(channel, efx) {\r\nef4_for_each_channel_tx_queue(tx_queue, channel) {\r\nef4_reado_table(efx, &txd_ptr_tbl,\r\nFR_BZ_TX_DESC_PTR_TBL, tx_queue->queue);\r\nif (EF4_OWORD_FIELD(txd_ptr_tbl,\r\nFRF_AZ_TX_DESCQ_FLUSH) ||\r\nEF4_OWORD_FIELD(txd_ptr_tbl,\r\nFRF_AZ_TX_DESCQ_EN)) {\r\nnetif_dbg(efx, hw, efx->net_dev,\r\n"flush did not complete on TXQ %d\n",\r\ntx_queue->queue);\r\ni = false;\r\n} else if (atomic_cmpxchg(&tx_queue->flush_outstanding,\r\n1, 0)) {\r\nnetif_dbg(efx, hw, efx->net_dev,\r\n"flush complete on TXQ %d, so drain "\r\n"the queue\n", tx_queue->queue);\r\nef4_farch_magic_event(channel,\r\nEF4_CHANNEL_MAGIC_TX_DRAIN(\r\ntx_queue));\r\n}\r\n}\r\n}\r\nreturn i;\r\n}\r\nstatic int ef4_farch_do_flush(struct ef4_nic *efx)\r\n{\r\nunsigned timeout = msecs_to_jiffies(5000);\r\nstruct ef4_channel *channel;\r\nstruct ef4_rx_queue *rx_queue;\r\nstruct ef4_tx_queue *tx_queue;\r\nint rc = 0;\r\nef4_for_each_channel(channel, efx) {\r\nef4_for_each_channel_tx_queue(tx_queue, channel) {\r\nef4_farch_flush_tx_queue(tx_queue);\r\n}\r\nef4_for_each_channel_rx_queue(rx_queue, channel) {\r\nrx_queue->flush_pending = true;\r\natomic_inc(&efx->rxq_flush_pending);\r\n}\r\n}\r\nwhile (timeout && atomic_read(&efx->active_queues) > 0) {\r\nef4_for_each_channel(channel, efx) {\r\nef4_for_each_channel_rx_queue(rx_queue, channel) {\r\nif (atomic_read(&efx->rxq_flush_outstanding) >=\r\nEF4_RX_FLUSH_COUNT)\r\nbreak;\r\nif (rx_queue->flush_pending) {\r\nrx_queue->flush_pending = false;\r\natomic_dec(&efx->rxq_flush_pending);\r\natomic_inc(&efx->rxq_flush_outstanding);\r\nef4_farch_flush_rx_queue(rx_queue);\r\n}\r\n}\r\n}\r\ntimeout = wait_event_timeout(efx->flush_wq,\r\nef4_farch_flush_wake(efx),\r\ntimeout);\r\n}\r\nif (atomic_read(&efx->active_queues) &&\r\n!ef4_check_tx_flush_complete(efx)) {\r\nnetif_err(efx, hw, efx->net_dev, "failed to flush %d queues "\r\n"(rx %d+%d)\n", atomic_read(&efx->active_queues),\r\natomic_read(&efx->rxq_flush_outstanding),\r\natomic_read(&efx->rxq_flush_pending));\r\nrc = -ETIMEDOUT;\r\natomic_set(&efx->active_queues, 0);\r\natomic_set(&efx->rxq_flush_pending, 0);\r\natomic_set(&efx->rxq_flush_outstanding, 0);\r\n}\r\nreturn rc;\r\n}\r\nint ef4_farch_fini_dmaq(struct ef4_nic *efx)\r\n{\r\nstruct ef4_channel *channel;\r\nstruct ef4_tx_queue *tx_queue;\r\nstruct ef4_rx_queue *rx_queue;\r\nint rc = 0;\r\nif (efx->state != STATE_RECOVERY) {\r\nif (efx->pci_dev->is_busmaster) {\r\nefx->type->prepare_flush(efx);\r\nrc = ef4_farch_do_flush(efx);\r\nefx->type->finish_flush(efx);\r\n}\r\nef4_for_each_channel(channel, efx) {\r\nef4_for_each_channel_rx_queue(rx_queue, channel)\r\nef4_farch_rx_fini(rx_queue);\r\nef4_for_each_channel_tx_queue(tx_queue, channel)\r\nef4_farch_tx_fini(tx_queue);\r\n}\r\n}\r\nreturn rc;\r\n}\r\nvoid ef4_farch_finish_flr(struct ef4_nic *efx)\r\n{\r\natomic_set(&efx->rxq_flush_pending, 0);\r\natomic_set(&efx->rxq_flush_outstanding, 0);\r\natomic_set(&efx->active_queues, 0);\r\n}\r\nvoid ef4_farch_ev_read_ack(struct ef4_channel *channel)\r\n{\r\nef4_dword_t reg;\r\nstruct ef4_nic *efx = channel->efx;\r\nEF4_POPULATE_DWORD_1(reg, FRF_AZ_EVQ_RPTR,\r\nchannel->eventq_read_ptr & channel->eventq_mask);\r\nef4_writed(efx, &reg,\r\nefx->type->evq_rptr_tbl_base +\r\nFR_BZ_EVQ_RPTR_STEP * channel->channel);\r\n}\r\nvoid ef4_farch_generate_event(struct ef4_nic *efx, unsigned int evq,\r\nef4_qword_t *event)\r\n{\r\nef4_oword_t drv_ev_reg;\r\nBUILD_BUG_ON(FRF_AZ_DRV_EV_DATA_LBN != 0 ||\r\nFRF_AZ_DRV_EV_DATA_WIDTH != 64);\r\ndrv_ev_reg.u32[0] = event->u32[0];\r\ndrv_ev_reg.u32[1] = event->u32[1];\r\ndrv_ev_reg.u32[2] = 0;\r\ndrv_ev_reg.u32[3] = 0;\r\nEF4_SET_OWORD_FIELD(drv_ev_reg, FRF_AZ_DRV_EV_QID, evq);\r\nef4_writeo(efx, &drv_ev_reg, FR_AZ_DRV_EV);\r\n}\r\nstatic void ef4_farch_magic_event(struct ef4_channel *channel, u32 magic)\r\n{\r\nef4_qword_t event;\r\nEF4_POPULATE_QWORD_2(event, FSF_AZ_EV_CODE,\r\nFSE_AZ_EV_CODE_DRV_GEN_EV,\r\nFSF_AZ_DRV_GEN_EV_MAGIC, magic);\r\nef4_farch_generate_event(channel->efx, channel->channel, &event);\r\n}\r\nstatic int\r\nef4_farch_handle_tx_event(struct ef4_channel *channel, ef4_qword_t *event)\r\n{\r\nunsigned int tx_ev_desc_ptr;\r\nunsigned int tx_ev_q_label;\r\nstruct ef4_tx_queue *tx_queue;\r\nstruct ef4_nic *efx = channel->efx;\r\nint tx_packets = 0;\r\nif (unlikely(ACCESS_ONCE(efx->reset_pending)))\r\nreturn 0;\r\nif (likely(EF4_QWORD_FIELD(*event, FSF_AZ_TX_EV_COMP))) {\r\ntx_ev_desc_ptr = EF4_QWORD_FIELD(*event, FSF_AZ_TX_EV_DESC_PTR);\r\ntx_ev_q_label = EF4_QWORD_FIELD(*event, FSF_AZ_TX_EV_Q_LABEL);\r\ntx_queue = ef4_channel_get_tx_queue(\r\nchannel, tx_ev_q_label % EF4_TXQ_TYPES);\r\ntx_packets = ((tx_ev_desc_ptr - tx_queue->read_count) &\r\ntx_queue->ptr_mask);\r\nef4_xmit_done(tx_queue, tx_ev_desc_ptr);\r\n} else if (EF4_QWORD_FIELD(*event, FSF_AZ_TX_EV_WQ_FF_FULL)) {\r\ntx_ev_q_label = EF4_QWORD_FIELD(*event, FSF_AZ_TX_EV_Q_LABEL);\r\ntx_queue = ef4_channel_get_tx_queue(\r\nchannel, tx_ev_q_label % EF4_TXQ_TYPES);\r\nnetif_tx_lock(efx->net_dev);\r\nef4_farch_notify_tx_desc(tx_queue);\r\nnetif_tx_unlock(efx->net_dev);\r\n} else if (EF4_QWORD_FIELD(*event, FSF_AZ_TX_EV_PKT_ERR)) {\r\nef4_schedule_reset(efx, RESET_TYPE_DMA_ERROR);\r\n} else {\r\nnetif_err(efx, tx_err, efx->net_dev,\r\n"channel %d unexpected TX event "\r\nEF4_QWORD_FMT"\n", channel->channel,\r\nEF4_QWORD_VAL(*event));\r\n}\r\nreturn tx_packets;\r\n}\r\nstatic u16 ef4_farch_handle_rx_not_ok(struct ef4_rx_queue *rx_queue,\r\nconst ef4_qword_t *event)\r\n{\r\nstruct ef4_channel *channel = ef4_rx_queue_channel(rx_queue);\r\nstruct ef4_nic *efx = rx_queue->efx;\r\nbool rx_ev_buf_owner_id_err, rx_ev_ip_hdr_chksum_err;\r\nbool rx_ev_tcp_udp_chksum_err, rx_ev_eth_crc_err;\r\nbool rx_ev_frm_trunc, rx_ev_drib_nib, rx_ev_tobe_disc;\r\nbool rx_ev_other_err, rx_ev_pause_frm;\r\nbool rx_ev_hdr_type, rx_ev_mcast_pkt;\r\nunsigned rx_ev_pkt_type;\r\nrx_ev_hdr_type = EF4_QWORD_FIELD(*event, FSF_AZ_RX_EV_HDR_TYPE);\r\nrx_ev_mcast_pkt = EF4_QWORD_FIELD(*event, FSF_AZ_RX_EV_MCAST_PKT);\r\nrx_ev_tobe_disc = EF4_QWORD_FIELD(*event, FSF_AZ_RX_EV_TOBE_DISC);\r\nrx_ev_pkt_type = EF4_QWORD_FIELD(*event, FSF_AZ_RX_EV_PKT_TYPE);\r\nrx_ev_buf_owner_id_err = EF4_QWORD_FIELD(*event,\r\nFSF_AZ_RX_EV_BUF_OWNER_ID_ERR);\r\nrx_ev_ip_hdr_chksum_err = EF4_QWORD_FIELD(*event,\r\nFSF_AZ_RX_EV_IP_HDR_CHKSUM_ERR);\r\nrx_ev_tcp_udp_chksum_err = EF4_QWORD_FIELD(*event,\r\nFSF_AZ_RX_EV_TCP_UDP_CHKSUM_ERR);\r\nrx_ev_eth_crc_err = EF4_QWORD_FIELD(*event, FSF_AZ_RX_EV_ETH_CRC_ERR);\r\nrx_ev_frm_trunc = EF4_QWORD_FIELD(*event, FSF_AZ_RX_EV_FRM_TRUNC);\r\nrx_ev_drib_nib = ((ef4_nic_rev(efx) >= EF4_REV_FALCON_B0) ?\r\n0 : EF4_QWORD_FIELD(*event, FSF_AA_RX_EV_DRIB_NIB));\r\nrx_ev_pause_frm = EF4_QWORD_FIELD(*event, FSF_AZ_RX_EV_PAUSE_FRM_ERR);\r\nrx_ev_other_err = (rx_ev_drib_nib | rx_ev_tcp_udp_chksum_err |\r\nrx_ev_buf_owner_id_err | rx_ev_eth_crc_err |\r\nrx_ev_frm_trunc | rx_ev_ip_hdr_chksum_err);\r\nif (rx_ev_frm_trunc)\r\n++channel->n_rx_frm_trunc;\r\nelse if (rx_ev_tobe_disc)\r\n++channel->n_rx_tobe_disc;\r\nelse if (!efx->loopback_selftest) {\r\nif (rx_ev_ip_hdr_chksum_err)\r\n++channel->n_rx_ip_hdr_chksum_err;\r\nelse if (rx_ev_tcp_udp_chksum_err)\r\n++channel->n_rx_tcp_udp_chksum_err;\r\n}\r\n#ifdef DEBUG\r\nif (rx_ev_other_err && net_ratelimit()) {\r\nnetif_dbg(efx, rx_err, efx->net_dev,\r\n" RX queue %d unexpected RX event "\r\nEF4_QWORD_FMT "%s%s%s%s%s%s%s%s\n",\r\nef4_rx_queue_index(rx_queue), EF4_QWORD_VAL(*event),\r\nrx_ev_buf_owner_id_err ? " [OWNER_ID_ERR]" : "",\r\nrx_ev_ip_hdr_chksum_err ?\r\n" [IP_HDR_CHKSUM_ERR]" : "",\r\nrx_ev_tcp_udp_chksum_err ?\r\n" [TCP_UDP_CHKSUM_ERR]" : "",\r\nrx_ev_eth_crc_err ? " [ETH_CRC_ERR]" : "",\r\nrx_ev_frm_trunc ? " [FRM_TRUNC]" : "",\r\nrx_ev_drib_nib ? " [DRIB_NIB]" : "",\r\nrx_ev_tobe_disc ? " [TOBE_DISC]" : "",\r\nrx_ev_pause_frm ? " [PAUSE]" : "");\r\n}\r\n#endif\r\nreturn (rx_ev_eth_crc_err | rx_ev_frm_trunc | rx_ev_drib_nib |\r\nrx_ev_tobe_disc | rx_ev_pause_frm) ?\r\nEF4_RX_PKT_DISCARD : 0;\r\n}\r\nstatic bool\r\nef4_farch_handle_rx_bad_index(struct ef4_rx_queue *rx_queue, unsigned index)\r\n{\r\nstruct ef4_channel *channel = ef4_rx_queue_channel(rx_queue);\r\nstruct ef4_nic *efx = rx_queue->efx;\r\nunsigned expected, dropped;\r\nif (rx_queue->scatter_n &&\r\nindex == ((rx_queue->removed_count + rx_queue->scatter_n - 1) &\r\nrx_queue->ptr_mask)) {\r\n++channel->n_rx_nodesc_trunc;\r\nreturn true;\r\n}\r\nexpected = rx_queue->removed_count & rx_queue->ptr_mask;\r\ndropped = (index - expected) & rx_queue->ptr_mask;\r\nnetif_info(efx, rx_err, efx->net_dev,\r\n"dropped %d events (index=%d expected=%d)\n",\r\ndropped, index, expected);\r\nef4_schedule_reset(efx, EF4_WORKAROUND_5676(efx) ?\r\nRESET_TYPE_RX_RECOVERY : RESET_TYPE_DISABLE);\r\nreturn false;\r\n}\r\nstatic void\r\nef4_farch_handle_rx_event(struct ef4_channel *channel, const ef4_qword_t *event)\r\n{\r\nunsigned int rx_ev_desc_ptr, rx_ev_byte_cnt;\r\nunsigned int rx_ev_hdr_type, rx_ev_mcast_pkt;\r\nunsigned expected_ptr;\r\nbool rx_ev_pkt_ok, rx_ev_sop, rx_ev_cont;\r\nu16 flags;\r\nstruct ef4_rx_queue *rx_queue;\r\nstruct ef4_nic *efx = channel->efx;\r\nif (unlikely(ACCESS_ONCE(efx->reset_pending)))\r\nreturn;\r\nrx_ev_cont = EF4_QWORD_FIELD(*event, FSF_AZ_RX_EV_JUMBO_CONT);\r\nrx_ev_sop = EF4_QWORD_FIELD(*event, FSF_AZ_RX_EV_SOP);\r\nWARN_ON(EF4_QWORD_FIELD(*event, FSF_AZ_RX_EV_Q_LABEL) !=\r\nchannel->channel);\r\nrx_queue = ef4_channel_get_rx_queue(channel);\r\nrx_ev_desc_ptr = EF4_QWORD_FIELD(*event, FSF_AZ_RX_EV_DESC_PTR);\r\nexpected_ptr = ((rx_queue->removed_count + rx_queue->scatter_n) &\r\nrx_queue->ptr_mask);\r\nif (unlikely(rx_ev_desc_ptr != expected_ptr) ||\r\nunlikely(rx_ev_sop != (rx_queue->scatter_n == 0))) {\r\nif (rx_ev_desc_ptr != expected_ptr &&\r\n!ef4_farch_handle_rx_bad_index(rx_queue, rx_ev_desc_ptr))\r\nreturn;\r\nif (rx_queue->scatter_n) {\r\nef4_rx_packet(\r\nrx_queue,\r\nrx_queue->removed_count & rx_queue->ptr_mask,\r\nrx_queue->scatter_n, 0, EF4_RX_PKT_DISCARD);\r\nrx_queue->removed_count += rx_queue->scatter_n;\r\nrx_queue->scatter_n = 0;\r\n}\r\nif (rx_ev_desc_ptr != expected_ptr)\r\nreturn;\r\nif (!rx_ev_sop) {\r\nef4_rx_packet(\r\nrx_queue,\r\nrx_queue->removed_count & rx_queue->ptr_mask,\r\n1, 0, EF4_RX_PKT_DISCARD);\r\n++rx_queue->removed_count;\r\nreturn;\r\n}\r\n}\r\n++rx_queue->scatter_n;\r\nif (rx_ev_cont)\r\nreturn;\r\nrx_ev_byte_cnt = EF4_QWORD_FIELD(*event, FSF_AZ_RX_EV_BYTE_CNT);\r\nrx_ev_pkt_ok = EF4_QWORD_FIELD(*event, FSF_AZ_RX_EV_PKT_OK);\r\nrx_ev_hdr_type = EF4_QWORD_FIELD(*event, FSF_AZ_RX_EV_HDR_TYPE);\r\nif (likely(rx_ev_pkt_ok)) {\r\nflags = 0;\r\nswitch (rx_ev_hdr_type) {\r\ncase FSE_CZ_RX_EV_HDR_TYPE_IPV4V6_TCP:\r\nflags |= EF4_RX_PKT_TCP;\r\ncase FSE_CZ_RX_EV_HDR_TYPE_IPV4V6_UDP:\r\nflags |= EF4_RX_PKT_CSUMMED;\r\ncase FSE_CZ_RX_EV_HDR_TYPE_IPV4V6_OTHER:\r\ncase FSE_AZ_RX_EV_HDR_TYPE_OTHER:\r\nbreak;\r\n}\r\n} else {\r\nflags = ef4_farch_handle_rx_not_ok(rx_queue, event);\r\n}\r\nrx_ev_mcast_pkt = EF4_QWORD_FIELD(*event, FSF_AZ_RX_EV_MCAST_PKT);\r\nif (rx_ev_mcast_pkt) {\r\nunsigned int rx_ev_mcast_hash_match =\r\nEF4_QWORD_FIELD(*event, FSF_AZ_RX_EV_MCAST_HASH_MATCH);\r\nif (unlikely(!rx_ev_mcast_hash_match)) {\r\n++channel->n_rx_mcast_mismatch;\r\nflags |= EF4_RX_PKT_DISCARD;\r\n}\r\n}\r\nchannel->irq_mod_score += 2;\r\nef4_rx_packet(rx_queue,\r\nrx_queue->removed_count & rx_queue->ptr_mask,\r\nrx_queue->scatter_n, rx_ev_byte_cnt, flags);\r\nrx_queue->removed_count += rx_queue->scatter_n;\r\nrx_queue->scatter_n = 0;\r\n}\r\nstatic void\r\nef4_farch_handle_tx_flush_done(struct ef4_nic *efx, ef4_qword_t *event)\r\n{\r\nstruct ef4_tx_queue *tx_queue;\r\nint qid;\r\nqid = EF4_QWORD_FIELD(*event, FSF_AZ_DRIVER_EV_SUBDATA);\r\nif (qid < EF4_TXQ_TYPES * efx->n_tx_channels) {\r\ntx_queue = ef4_get_tx_queue(efx, qid / EF4_TXQ_TYPES,\r\nqid % EF4_TXQ_TYPES);\r\nif (atomic_cmpxchg(&tx_queue->flush_outstanding, 1, 0)) {\r\nef4_farch_magic_event(tx_queue->channel,\r\nEF4_CHANNEL_MAGIC_TX_DRAIN(tx_queue));\r\n}\r\n}\r\n}\r\nstatic void\r\nef4_farch_handle_rx_flush_done(struct ef4_nic *efx, ef4_qword_t *event)\r\n{\r\nstruct ef4_channel *channel;\r\nstruct ef4_rx_queue *rx_queue;\r\nint qid;\r\nbool failed;\r\nqid = EF4_QWORD_FIELD(*event, FSF_AZ_DRIVER_EV_RX_DESCQ_ID);\r\nfailed = EF4_QWORD_FIELD(*event, FSF_AZ_DRIVER_EV_RX_FLUSH_FAIL);\r\nif (qid >= efx->n_channels)\r\nreturn;\r\nchannel = ef4_get_channel(efx, qid);\r\nif (!ef4_channel_has_rx_queue(channel))\r\nreturn;\r\nrx_queue = ef4_channel_get_rx_queue(channel);\r\nif (failed) {\r\nnetif_info(efx, hw, efx->net_dev,\r\n"RXQ %d flush retry\n", qid);\r\nrx_queue->flush_pending = true;\r\natomic_inc(&efx->rxq_flush_pending);\r\n} else {\r\nef4_farch_magic_event(ef4_rx_queue_channel(rx_queue),\r\nEF4_CHANNEL_MAGIC_RX_DRAIN(rx_queue));\r\n}\r\natomic_dec(&efx->rxq_flush_outstanding);\r\nif (ef4_farch_flush_wake(efx))\r\nwake_up(&efx->flush_wq);\r\n}\r\nstatic void\r\nef4_farch_handle_drain_event(struct ef4_channel *channel)\r\n{\r\nstruct ef4_nic *efx = channel->efx;\r\nWARN_ON(atomic_read(&efx->active_queues) == 0);\r\natomic_dec(&efx->active_queues);\r\nif (ef4_farch_flush_wake(efx))\r\nwake_up(&efx->flush_wq);\r\n}\r\nstatic void ef4_farch_handle_generated_event(struct ef4_channel *channel,\r\nef4_qword_t *event)\r\n{\r\nstruct ef4_nic *efx = channel->efx;\r\nstruct ef4_rx_queue *rx_queue =\r\nef4_channel_has_rx_queue(channel) ?\r\nef4_channel_get_rx_queue(channel) : NULL;\r\nunsigned magic, code;\r\nmagic = EF4_QWORD_FIELD(*event, FSF_AZ_DRV_GEN_EV_MAGIC);\r\ncode = _EF4_CHANNEL_MAGIC_CODE(magic);\r\nif (magic == EF4_CHANNEL_MAGIC_TEST(channel)) {\r\nchannel->event_test_cpu = raw_smp_processor_id();\r\n} else if (rx_queue && magic == EF4_CHANNEL_MAGIC_FILL(rx_queue)) {\r\nef4_fast_push_rx_descriptors(rx_queue, true);\r\n} else if (rx_queue && magic == EF4_CHANNEL_MAGIC_RX_DRAIN(rx_queue)) {\r\nef4_farch_handle_drain_event(channel);\r\n} else if (code == _EF4_CHANNEL_MAGIC_TX_DRAIN) {\r\nef4_farch_handle_drain_event(channel);\r\n} else {\r\nnetif_dbg(efx, hw, efx->net_dev, "channel %d received "\r\n"generated event "EF4_QWORD_FMT"\n",\r\nchannel->channel, EF4_QWORD_VAL(*event));\r\n}\r\n}\r\nstatic void\r\nef4_farch_handle_driver_event(struct ef4_channel *channel, ef4_qword_t *event)\r\n{\r\nstruct ef4_nic *efx = channel->efx;\r\nunsigned int ev_sub_code;\r\nunsigned int ev_sub_data;\r\nev_sub_code = EF4_QWORD_FIELD(*event, FSF_AZ_DRIVER_EV_SUBCODE);\r\nev_sub_data = EF4_QWORD_FIELD(*event, FSF_AZ_DRIVER_EV_SUBDATA);\r\nswitch (ev_sub_code) {\r\ncase FSE_AZ_TX_DESCQ_FLS_DONE_EV:\r\nnetif_vdbg(efx, hw, efx->net_dev, "channel %d TXQ %d flushed\n",\r\nchannel->channel, ev_sub_data);\r\nef4_farch_handle_tx_flush_done(efx, event);\r\nbreak;\r\ncase FSE_AZ_RX_DESCQ_FLS_DONE_EV:\r\nnetif_vdbg(efx, hw, efx->net_dev, "channel %d RXQ %d flushed\n",\r\nchannel->channel, ev_sub_data);\r\nef4_farch_handle_rx_flush_done(efx, event);\r\nbreak;\r\ncase FSE_AZ_EVQ_INIT_DONE_EV:\r\nnetif_dbg(efx, hw, efx->net_dev,\r\n"channel %d EVQ %d initialised\n",\r\nchannel->channel, ev_sub_data);\r\nbreak;\r\ncase FSE_AZ_SRM_UPD_DONE_EV:\r\nnetif_vdbg(efx, hw, efx->net_dev,\r\n"channel %d SRAM update done\n", channel->channel);\r\nbreak;\r\ncase FSE_AZ_WAKE_UP_EV:\r\nnetif_vdbg(efx, hw, efx->net_dev,\r\n"channel %d RXQ %d wakeup event\n",\r\nchannel->channel, ev_sub_data);\r\nbreak;\r\ncase FSE_AZ_TIMER_EV:\r\nnetif_vdbg(efx, hw, efx->net_dev,\r\n"channel %d RX queue %d timer expired\n",\r\nchannel->channel, ev_sub_data);\r\nbreak;\r\ncase FSE_AA_RX_RECOVER_EV:\r\nnetif_err(efx, rx_err, efx->net_dev,\r\n"channel %d seen DRIVER RX_RESET event. "\r\n"Resetting.\n", channel->channel);\r\natomic_inc(&efx->rx_reset);\r\nef4_schedule_reset(efx,\r\nEF4_WORKAROUND_6555(efx) ?\r\nRESET_TYPE_RX_RECOVERY :\r\nRESET_TYPE_DISABLE);\r\nbreak;\r\ncase FSE_BZ_RX_DSC_ERROR_EV:\r\nnetif_err(efx, rx_err, efx->net_dev,\r\n"RX DMA Q %d reports descriptor fetch error."\r\n" RX Q %d is disabled.\n", ev_sub_data,\r\nev_sub_data);\r\nef4_schedule_reset(efx, RESET_TYPE_DMA_ERROR);\r\nbreak;\r\ncase FSE_BZ_TX_DSC_ERROR_EV:\r\nnetif_err(efx, tx_err, efx->net_dev,\r\n"TX DMA Q %d reports descriptor fetch error."\r\n" TX Q %d is disabled.\n", ev_sub_data,\r\nev_sub_data);\r\nef4_schedule_reset(efx, RESET_TYPE_DMA_ERROR);\r\nbreak;\r\ndefault:\r\nnetif_vdbg(efx, hw, efx->net_dev,\r\n"channel %d unknown driver event code %d "\r\n"data %04x\n", channel->channel, ev_sub_code,\r\nev_sub_data);\r\nbreak;\r\n}\r\n}\r\nint ef4_farch_ev_process(struct ef4_channel *channel, int budget)\r\n{\r\nstruct ef4_nic *efx = channel->efx;\r\nunsigned int read_ptr;\r\nef4_qword_t event, *p_event;\r\nint ev_code;\r\nint tx_packets = 0;\r\nint spent = 0;\r\nif (budget <= 0)\r\nreturn spent;\r\nread_ptr = channel->eventq_read_ptr;\r\nfor (;;) {\r\np_event = ef4_event(channel, read_ptr);\r\nevent = *p_event;\r\nif (!ef4_event_present(&event))\r\nbreak;\r\nnetif_vdbg(channel->efx, intr, channel->efx->net_dev,\r\n"channel %d event is "EF4_QWORD_FMT"\n",\r\nchannel->channel, EF4_QWORD_VAL(event));\r\nEF4_SET_QWORD(*p_event);\r\n++read_ptr;\r\nev_code = EF4_QWORD_FIELD(event, FSF_AZ_EV_CODE);\r\nswitch (ev_code) {\r\ncase FSE_AZ_EV_CODE_RX_EV:\r\nef4_farch_handle_rx_event(channel, &event);\r\nif (++spent == budget)\r\ngoto out;\r\nbreak;\r\ncase FSE_AZ_EV_CODE_TX_EV:\r\ntx_packets += ef4_farch_handle_tx_event(channel,\r\n&event);\r\nif (tx_packets > efx->txq_entries) {\r\nspent = budget;\r\ngoto out;\r\n}\r\nbreak;\r\ncase FSE_AZ_EV_CODE_DRV_GEN_EV:\r\nef4_farch_handle_generated_event(channel, &event);\r\nbreak;\r\ncase FSE_AZ_EV_CODE_DRIVER_EV:\r\nef4_farch_handle_driver_event(channel, &event);\r\nbreak;\r\ncase FSE_AZ_EV_CODE_GLOBAL_EV:\r\nif (efx->type->handle_global_event &&\r\nefx->type->handle_global_event(channel, &event))\r\nbreak;\r\ndefault:\r\nnetif_err(channel->efx, hw, channel->efx->net_dev,\r\n"channel %d unknown event type %d (data "\r\nEF4_QWORD_FMT ")\n", channel->channel,\r\nev_code, EF4_QWORD_VAL(event));\r\n}\r\n}\r\nout:\r\nchannel->eventq_read_ptr = read_ptr;\r\nreturn spent;\r\n}\r\nint ef4_farch_ev_probe(struct ef4_channel *channel)\r\n{\r\nstruct ef4_nic *efx = channel->efx;\r\nunsigned entries;\r\nentries = channel->eventq_mask + 1;\r\nreturn ef4_alloc_special_buffer(efx, &channel->eventq,\r\nentries * sizeof(ef4_qword_t));\r\n}\r\nint ef4_farch_ev_init(struct ef4_channel *channel)\r\n{\r\nef4_oword_t reg;\r\nstruct ef4_nic *efx = channel->efx;\r\nnetif_dbg(efx, hw, efx->net_dev,\r\n"channel %d event queue in special buffers %d-%d\n",\r\nchannel->channel, channel->eventq.index,\r\nchannel->eventq.index + channel->eventq.entries - 1);\r\nef4_init_special_buffer(efx, &channel->eventq);\r\nmemset(channel->eventq.buf.addr, 0xff, channel->eventq.buf.len);\r\nEF4_POPULATE_OWORD_3(reg,\r\nFRF_AZ_EVQ_EN, 1,\r\nFRF_AZ_EVQ_SIZE, __ffs(channel->eventq.entries),\r\nFRF_AZ_EVQ_BUF_BASE_ID, channel->eventq.index);\r\nef4_writeo_table(efx, &reg, efx->type->evq_ptr_tbl_base,\r\nchannel->channel);\r\nreturn 0;\r\n}\r\nvoid ef4_farch_ev_fini(struct ef4_channel *channel)\r\n{\r\nef4_oword_t reg;\r\nstruct ef4_nic *efx = channel->efx;\r\nEF4_ZERO_OWORD(reg);\r\nef4_writeo_table(efx, &reg, efx->type->evq_ptr_tbl_base,\r\nchannel->channel);\r\nef4_fini_special_buffer(efx, &channel->eventq);\r\n}\r\nvoid ef4_farch_ev_remove(struct ef4_channel *channel)\r\n{\r\nef4_free_special_buffer(channel->efx, &channel->eventq);\r\n}\r\nvoid ef4_farch_ev_test_generate(struct ef4_channel *channel)\r\n{\r\nef4_farch_magic_event(channel, EF4_CHANNEL_MAGIC_TEST(channel));\r\n}\r\nvoid ef4_farch_rx_defer_refill(struct ef4_rx_queue *rx_queue)\r\n{\r\nef4_farch_magic_event(ef4_rx_queue_channel(rx_queue),\r\nEF4_CHANNEL_MAGIC_FILL(rx_queue));\r\n}\r\nstatic inline void ef4_farch_interrupts(struct ef4_nic *efx,\r\nbool enabled, bool force)\r\n{\r\nef4_oword_t int_en_reg_ker;\r\nEF4_POPULATE_OWORD_3(int_en_reg_ker,\r\nFRF_AZ_KER_INT_LEVE_SEL, efx->irq_level,\r\nFRF_AZ_KER_INT_KER, force,\r\nFRF_AZ_DRV_INT_EN_KER, enabled);\r\nef4_writeo(efx, &int_en_reg_ker, FR_AZ_INT_EN_KER);\r\n}\r\nvoid ef4_farch_irq_enable_master(struct ef4_nic *efx)\r\n{\r\nEF4_ZERO_OWORD(*((ef4_oword_t *) efx->irq_status.addr));\r\nwmb();\r\nef4_farch_interrupts(efx, true, false);\r\n}\r\nvoid ef4_farch_irq_disable_master(struct ef4_nic *efx)\r\n{\r\nef4_farch_interrupts(efx, false, false);\r\n}\r\nint ef4_farch_irq_test_generate(struct ef4_nic *efx)\r\n{\r\nef4_farch_interrupts(efx, true, true);\r\nreturn 0;\r\n}\r\nirqreturn_t ef4_farch_fatal_interrupt(struct ef4_nic *efx)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nef4_oword_t *int_ker = efx->irq_status.addr;\r\nef4_oword_t fatal_intr;\r\nint error, mem_perr;\r\nef4_reado(efx, &fatal_intr, FR_AZ_FATAL_INTR_KER);\r\nerror = EF4_OWORD_FIELD(fatal_intr, FRF_AZ_FATAL_INTR);\r\nnetif_err(efx, hw, efx->net_dev, "SYSTEM ERROR "EF4_OWORD_FMT" status "\r\nEF4_OWORD_FMT ": %s\n", EF4_OWORD_VAL(*int_ker),\r\nEF4_OWORD_VAL(fatal_intr),\r\nerror ? "disabling bus mastering" : "no recognised error");\r\nmem_perr = (EF4_OWORD_FIELD(fatal_intr, FRF_AZ_MEM_PERR_INT_KER) ||\r\nEF4_OWORD_FIELD(fatal_intr, FRF_AZ_SRM_PERR_INT_KER));\r\nif (mem_perr) {\r\nef4_oword_t reg;\r\nef4_reado(efx, &reg, FR_AZ_MEM_STAT);\r\nnetif_err(efx, hw, efx->net_dev,\r\n"SYSTEM ERROR: memory parity error "EF4_OWORD_FMT"\n",\r\nEF4_OWORD_VAL(reg));\r\n}\r\npci_clear_master(efx->pci_dev);\r\nif (ef4_nic_is_dual_func(efx))\r\npci_clear_master(nic_data->pci_dev2);\r\nef4_farch_irq_disable_master(efx);\r\nif (efx->int_error_count == 0 ||\r\ntime_after(jiffies, efx->int_error_expire)) {\r\nefx->int_error_count = 0;\r\nefx->int_error_expire =\r\njiffies + EF4_INT_ERROR_EXPIRE * HZ;\r\n}\r\nif (++efx->int_error_count < EF4_MAX_INT_ERRORS) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"SYSTEM ERROR - reset scheduled\n");\r\nef4_schedule_reset(efx, RESET_TYPE_INT_ERROR);\r\n} else {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"SYSTEM ERROR - max number of errors seen."\r\n"NIC will be disabled\n");\r\nef4_schedule_reset(efx, RESET_TYPE_DISABLE);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nirqreturn_t ef4_farch_legacy_interrupt(int irq, void *dev_id)\r\n{\r\nstruct ef4_nic *efx = dev_id;\r\nbool soft_enabled = ACCESS_ONCE(efx->irq_soft_enabled);\r\nef4_oword_t *int_ker = efx->irq_status.addr;\r\nirqreturn_t result = IRQ_NONE;\r\nstruct ef4_channel *channel;\r\nef4_dword_t reg;\r\nu32 queues;\r\nint syserr;\r\nef4_readd(efx, &reg, FR_BZ_INT_ISR0);\r\nqueues = EF4_EXTRACT_DWORD(reg, 0, 31);\r\nif (EF4_DWORD_IS_ALL_ONES(reg) && ef4_try_recovery(efx) &&\r\n!efx->eeh_disabled_legacy_irq) {\r\ndisable_irq_nosync(efx->legacy_irq);\r\nefx->eeh_disabled_legacy_irq = true;\r\n}\r\nif (queues & (1U << efx->irq_level) && soft_enabled) {\r\nsyserr = EF4_OWORD_FIELD(*int_ker, FSF_AZ_NET_IVEC_FATAL_INT);\r\nif (unlikely(syserr))\r\nreturn ef4_farch_fatal_interrupt(efx);\r\nefx->last_irq_cpu = raw_smp_processor_id();\r\n}\r\nif (queues != 0) {\r\nefx->irq_zero_count = 0;\r\nif (likely(soft_enabled)) {\r\nef4_for_each_channel(channel, efx) {\r\nif (queues & 1)\r\nef4_schedule_channel_irq(channel);\r\nqueues >>= 1;\r\n}\r\n}\r\nresult = IRQ_HANDLED;\r\n} else {\r\nef4_qword_t *event;\r\nif (efx->irq_zero_count++ == 0)\r\nresult = IRQ_HANDLED;\r\nif (likely(soft_enabled)) {\r\nef4_for_each_channel(channel, efx) {\r\nevent = ef4_event(channel,\r\nchannel->eventq_read_ptr);\r\nif (ef4_event_present(event))\r\nef4_schedule_channel_irq(channel);\r\nelse\r\nef4_farch_ev_read_ack(channel);\r\n}\r\n}\r\n}\r\nif (result == IRQ_HANDLED)\r\nnetif_vdbg(efx, intr, efx->net_dev,\r\n"IRQ %d on CPU %d status " EF4_DWORD_FMT "\n",\r\nirq, raw_smp_processor_id(), EF4_DWORD_VAL(reg));\r\nreturn result;\r\n}\r\nirqreturn_t ef4_farch_msi_interrupt(int irq, void *dev_id)\r\n{\r\nstruct ef4_msi_context *context = dev_id;\r\nstruct ef4_nic *efx = context->efx;\r\nef4_oword_t *int_ker = efx->irq_status.addr;\r\nint syserr;\r\nnetif_vdbg(efx, intr, efx->net_dev,\r\n"IRQ %d on CPU %d status " EF4_OWORD_FMT "\n",\r\nirq, raw_smp_processor_id(), EF4_OWORD_VAL(*int_ker));\r\nif (!likely(ACCESS_ONCE(efx->irq_soft_enabled)))\r\nreturn IRQ_HANDLED;\r\nif (context->index == efx->irq_level) {\r\nsyserr = EF4_OWORD_FIELD(*int_ker, FSF_AZ_NET_IVEC_FATAL_INT);\r\nif (unlikely(syserr))\r\nreturn ef4_farch_fatal_interrupt(efx);\r\nefx->last_irq_cpu = raw_smp_processor_id();\r\n}\r\nef4_schedule_channel_irq(efx->channel[context->index]);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid ef4_farch_rx_push_indir_table(struct ef4_nic *efx)\r\n{\r\nsize_t i = 0;\r\nef4_dword_t dword;\r\nBUG_ON(ef4_nic_rev(efx) < EF4_REV_FALCON_B0);\r\nBUILD_BUG_ON(ARRAY_SIZE(efx->rx_indir_table) !=\r\nFR_BZ_RX_INDIRECTION_TBL_ROWS);\r\nfor (i = 0; i < FR_BZ_RX_INDIRECTION_TBL_ROWS; i++) {\r\nEF4_POPULATE_DWORD_1(dword, FRF_BZ_IT_QUEUE,\r\nefx->rx_indir_table[i]);\r\nef4_writed(efx, &dword,\r\nFR_BZ_RX_INDIRECTION_TBL +\r\nFR_BZ_RX_INDIRECTION_TBL_STEP * i);\r\n}\r\n}\r\nvoid ef4_farch_dimension_resources(struct ef4_nic *efx, unsigned sram_lim_qw)\r\n{\r\nunsigned vi_count, buftbl_min;\r\nbuftbl_min = ((efx->n_rx_channels * EF4_MAX_DMAQ_SIZE +\r\nefx->n_tx_channels * EF4_TXQ_TYPES * EF4_MAX_DMAQ_SIZE +\r\nefx->n_channels * EF4_MAX_EVQ_SIZE)\r\n* sizeof(ef4_qword_t) / EF4_BUF_SIZE);\r\nvi_count = max(efx->n_channels, efx->n_tx_channels * EF4_TXQ_TYPES);\r\nefx->tx_dc_base = sram_lim_qw - vi_count * TX_DC_ENTRIES;\r\nefx->rx_dc_base = efx->tx_dc_base - vi_count * RX_DC_ENTRIES;\r\n}\r\nu32 ef4_farch_fpga_ver(struct ef4_nic *efx)\r\n{\r\nef4_oword_t altera_build;\r\nef4_reado(efx, &altera_build, FR_AZ_ALTERA_BUILD);\r\nreturn EF4_OWORD_FIELD(altera_build, FRF_AZ_ALTERA_BUILD_VER);\r\n}\r\nvoid ef4_farch_init_common(struct ef4_nic *efx)\r\n{\r\nef4_oword_t temp;\r\nEF4_POPULATE_OWORD_1(temp, FRF_AZ_SRM_TX_DC_BASE_ADR, efx->tx_dc_base);\r\nef4_writeo(efx, &temp, FR_AZ_SRM_TX_DC_CFG);\r\nEF4_POPULATE_OWORD_1(temp, FRF_AZ_SRM_RX_DC_BASE_ADR, efx->rx_dc_base);\r\nef4_writeo(efx, &temp, FR_AZ_SRM_RX_DC_CFG);\r\nBUILD_BUG_ON(TX_DC_ENTRIES != (8 << TX_DC_ENTRIES_ORDER));\r\nEF4_POPULATE_OWORD_1(temp, FRF_AZ_TX_DC_SIZE, TX_DC_ENTRIES_ORDER);\r\nef4_writeo(efx, &temp, FR_AZ_TX_DC_CFG);\r\nBUILD_BUG_ON(RX_DC_ENTRIES != (8 << RX_DC_ENTRIES_ORDER));\r\nEF4_POPULATE_OWORD_1(temp, FRF_AZ_RX_DC_SIZE, RX_DC_ENTRIES_ORDER);\r\nef4_writeo(efx, &temp, FR_AZ_RX_DC_CFG);\r\nEF4_POPULATE_OWORD_1(temp, FRF_AZ_RX_DC_PF_LWM, RX_DC_ENTRIES - 8);\r\nef4_writeo(efx, &temp, FR_AZ_RX_DC_PF_WM);\r\nEF4_POPULATE_OWORD_2(temp,\r\nFRF_AZ_NORM_INT_VEC_DIS_KER,\r\nEF4_INT_MODE_USE_MSI(efx),\r\nFRF_AZ_INT_ADR_KER, efx->irq_status.dma_addr);\r\nef4_writeo(efx, &temp, FR_AZ_INT_ADR_KER);\r\nefx->irq_level = 0;\r\nEF4_POPULATE_OWORD_3(temp,\r\nFRF_AZ_ILL_ADR_INT_KER_EN, 1,\r\nFRF_AZ_RBUF_OWN_INT_KER_EN, 1,\r\nFRF_AZ_TBUF_OWN_INT_KER_EN, 1);\r\nEF4_INVERT_OWORD(temp);\r\nef4_writeo(efx, &temp, FR_AZ_FATAL_INTR_KER);\r\nef4_reado(efx, &temp, FR_AZ_TX_RESERVED);\r\nEF4_SET_OWORD_FIELD(temp, FRF_AZ_TX_RX_SPACER, 0xfe);\r\nEF4_SET_OWORD_FIELD(temp, FRF_AZ_TX_RX_SPACER_EN, 1);\r\nEF4_SET_OWORD_FIELD(temp, FRF_AZ_TX_ONE_PKT_PER_Q, 1);\r\nEF4_SET_OWORD_FIELD(temp, FRF_AZ_TX_PUSH_EN, 1);\r\nEF4_SET_OWORD_FIELD(temp, FRF_AZ_TX_DIS_NON_IP_EV, 1);\r\nEF4_SET_OWORD_FIELD(temp, FRF_AZ_TX_SOFT_EVT_EN, 1);\r\nEF4_SET_OWORD_FIELD(temp, FRF_AZ_TX_PREF_THRESHOLD, 2);\r\nEF4_SET_OWORD_FIELD(temp, FRF_AZ_TX_PREF_WD_TMR, 0x3fffff);\r\nif (ef4_nic_rev(efx) >= EF4_REV_FALCON_B0)\r\nEF4_SET_OWORD_FIELD(temp, FRF_BZ_TX_FLUSH_MIN_LEN_EN, 1);\r\nef4_writeo(efx, &temp, FR_AZ_TX_RESERVED);\r\nif (ef4_nic_rev(efx) >= EF4_REV_FALCON_B0) {\r\nEF4_POPULATE_OWORD_4(temp,\r\nFRF_BZ_TX_PACE_SB_NOT_AF, 0x15,\r\nFRF_BZ_TX_PACE_SB_AF, 0xb,\r\nFRF_BZ_TX_PACE_FB_BASE, 0,\r\nFRF_BZ_TX_PACE_BIN_TH,\r\nFFE_BZ_TX_PACE_RESERVED);\r\nef4_writeo(efx, &temp, FR_BZ_TX_PACE);\r\n}\r\n}\r\nstatic u16 ef4_farch_filter_hash(u32 key)\r\n{\r\nu16 tmp;\r\ntmp = 0x1fff ^ key >> 16;\r\ntmp = tmp ^ tmp >> 3 ^ tmp >> 6;\r\ntmp = tmp ^ tmp >> 9;\r\ntmp = tmp ^ tmp << 13 ^ key;\r\ntmp = tmp ^ tmp >> 3 ^ tmp >> 6;\r\nreturn tmp ^ tmp >> 9;\r\n}\r\nstatic u16 ef4_farch_filter_increment(u32 key)\r\n{\r\nreturn key * 2 - 1;\r\n}\r\nstatic enum ef4_farch_filter_table_id\r\nef4_farch_filter_spec_table_id(const struct ef4_farch_filter_spec *spec)\r\n{\r\nBUILD_BUG_ON(EF4_FARCH_FILTER_TABLE_RX_IP !=\r\n(EF4_FARCH_FILTER_TCP_FULL >> 2));\r\nBUILD_BUG_ON(EF4_FARCH_FILTER_TABLE_RX_IP !=\r\n(EF4_FARCH_FILTER_TCP_WILD >> 2));\r\nBUILD_BUG_ON(EF4_FARCH_FILTER_TABLE_RX_IP !=\r\n(EF4_FARCH_FILTER_UDP_FULL >> 2));\r\nBUILD_BUG_ON(EF4_FARCH_FILTER_TABLE_RX_IP !=\r\n(EF4_FARCH_FILTER_UDP_WILD >> 2));\r\nBUILD_BUG_ON(EF4_FARCH_FILTER_TABLE_RX_MAC !=\r\n(EF4_FARCH_FILTER_MAC_FULL >> 2));\r\nBUILD_BUG_ON(EF4_FARCH_FILTER_TABLE_RX_MAC !=\r\n(EF4_FARCH_FILTER_MAC_WILD >> 2));\r\nBUILD_BUG_ON(EF4_FARCH_FILTER_TABLE_TX_MAC !=\r\nEF4_FARCH_FILTER_TABLE_RX_MAC + 2);\r\nreturn (spec->type >> 2) + ((spec->flags & EF4_FILTER_FLAG_TX) ? 2 : 0);\r\n}\r\nstatic void ef4_farch_filter_push_rx_config(struct ef4_nic *efx)\r\n{\r\nstruct ef4_farch_filter_state *state = efx->filter_state;\r\nstruct ef4_farch_filter_table *table;\r\nef4_oword_t filter_ctl;\r\nef4_reado(efx, &filter_ctl, FR_BZ_RX_FILTER_CTL);\r\ntable = &state->table[EF4_FARCH_FILTER_TABLE_RX_IP];\r\nEF4_SET_OWORD_FIELD(filter_ctl, FRF_BZ_TCP_FULL_SRCH_LIMIT,\r\ntable->search_limit[EF4_FARCH_FILTER_TCP_FULL] +\r\nEF4_FARCH_FILTER_CTL_SRCH_FUDGE_FULL);\r\nEF4_SET_OWORD_FIELD(filter_ctl, FRF_BZ_TCP_WILD_SRCH_LIMIT,\r\ntable->search_limit[EF4_FARCH_FILTER_TCP_WILD] +\r\nEF4_FARCH_FILTER_CTL_SRCH_FUDGE_WILD);\r\nEF4_SET_OWORD_FIELD(filter_ctl, FRF_BZ_UDP_FULL_SRCH_LIMIT,\r\ntable->search_limit[EF4_FARCH_FILTER_UDP_FULL] +\r\nEF4_FARCH_FILTER_CTL_SRCH_FUDGE_FULL);\r\nEF4_SET_OWORD_FIELD(filter_ctl, FRF_BZ_UDP_WILD_SRCH_LIMIT,\r\ntable->search_limit[EF4_FARCH_FILTER_UDP_WILD] +\r\nEF4_FARCH_FILTER_CTL_SRCH_FUDGE_WILD);\r\ntable = &state->table[EF4_FARCH_FILTER_TABLE_RX_MAC];\r\nif (table->size) {\r\nEF4_SET_OWORD_FIELD(\r\nfilter_ctl, FRF_CZ_ETHERNET_FULL_SEARCH_LIMIT,\r\ntable->search_limit[EF4_FARCH_FILTER_MAC_FULL] +\r\nEF4_FARCH_FILTER_CTL_SRCH_FUDGE_FULL);\r\nEF4_SET_OWORD_FIELD(\r\nfilter_ctl, FRF_CZ_ETHERNET_WILDCARD_SEARCH_LIMIT,\r\ntable->search_limit[EF4_FARCH_FILTER_MAC_WILD] +\r\nEF4_FARCH_FILTER_CTL_SRCH_FUDGE_WILD);\r\n}\r\ntable = &state->table[EF4_FARCH_FILTER_TABLE_RX_DEF];\r\nif (table->size) {\r\nEF4_SET_OWORD_FIELD(\r\nfilter_ctl, FRF_CZ_UNICAST_NOMATCH_Q_ID,\r\ntable->spec[EF4_FARCH_FILTER_INDEX_UC_DEF].dmaq_id);\r\nEF4_SET_OWORD_FIELD(\r\nfilter_ctl, FRF_CZ_UNICAST_NOMATCH_RSS_ENABLED,\r\n!!(table->spec[EF4_FARCH_FILTER_INDEX_UC_DEF].flags &\r\nEF4_FILTER_FLAG_RX_RSS));\r\nEF4_SET_OWORD_FIELD(\r\nfilter_ctl, FRF_CZ_MULTICAST_NOMATCH_Q_ID,\r\ntable->spec[EF4_FARCH_FILTER_INDEX_MC_DEF].dmaq_id);\r\nEF4_SET_OWORD_FIELD(\r\nfilter_ctl, FRF_CZ_MULTICAST_NOMATCH_RSS_ENABLED,\r\n!!(table->spec[EF4_FARCH_FILTER_INDEX_MC_DEF].flags &\r\nEF4_FILTER_FLAG_RX_RSS));\r\nEF4_SET_OWORD_FIELD(\r\nfilter_ctl, FRF_BZ_SCATTER_ENBL_NO_MATCH_Q,\r\n!!(table->spec[EF4_FARCH_FILTER_INDEX_UC_DEF].flags &\r\ntable->spec[EF4_FARCH_FILTER_INDEX_MC_DEF].flags &\r\nEF4_FILTER_FLAG_RX_SCATTER));\r\n} else if (ef4_nic_rev(efx) >= EF4_REV_FALCON_B0) {\r\nEF4_SET_OWORD_FIELD(\r\nfilter_ctl, FRF_BZ_SCATTER_ENBL_NO_MATCH_Q,\r\nefx->rx_scatter);\r\n}\r\nef4_writeo(efx, &filter_ctl, FR_BZ_RX_FILTER_CTL);\r\n}\r\nstatic void ef4_farch_filter_push_tx_limits(struct ef4_nic *efx)\r\n{\r\nstruct ef4_farch_filter_state *state = efx->filter_state;\r\nstruct ef4_farch_filter_table *table;\r\nef4_oword_t tx_cfg;\r\nef4_reado(efx, &tx_cfg, FR_AZ_TX_CFG);\r\ntable = &state->table[EF4_FARCH_FILTER_TABLE_TX_MAC];\r\nif (table->size) {\r\nEF4_SET_OWORD_FIELD(\r\ntx_cfg, FRF_CZ_TX_ETH_FILTER_FULL_SEARCH_RANGE,\r\ntable->search_limit[EF4_FARCH_FILTER_MAC_FULL] +\r\nEF4_FARCH_FILTER_CTL_SRCH_FUDGE_FULL);\r\nEF4_SET_OWORD_FIELD(\r\ntx_cfg, FRF_CZ_TX_ETH_FILTER_WILD_SEARCH_RANGE,\r\ntable->search_limit[EF4_FARCH_FILTER_MAC_WILD] +\r\nEF4_FARCH_FILTER_CTL_SRCH_FUDGE_WILD);\r\n}\r\nef4_writeo(efx, &tx_cfg, FR_AZ_TX_CFG);\r\n}\r\nstatic int\r\nef4_farch_filter_from_gen_spec(struct ef4_farch_filter_spec *spec,\r\nconst struct ef4_filter_spec *gen_spec)\r\n{\r\nbool is_full = false;\r\nif ((gen_spec->flags & EF4_FILTER_FLAG_RX_RSS) &&\r\ngen_spec->rss_context != EF4_FILTER_RSS_CONTEXT_DEFAULT)\r\nreturn -EINVAL;\r\nspec->priority = gen_spec->priority;\r\nspec->flags = gen_spec->flags;\r\nspec->dmaq_id = gen_spec->dmaq_id;\r\nswitch (gen_spec->match_flags) {\r\ncase (EF4_FILTER_MATCH_ETHER_TYPE | EF4_FILTER_MATCH_IP_PROTO |\r\nEF4_FILTER_MATCH_LOC_HOST | EF4_FILTER_MATCH_LOC_PORT |\r\nEF4_FILTER_MATCH_REM_HOST | EF4_FILTER_MATCH_REM_PORT):\r\nis_full = true;\r\ncase (EF4_FILTER_MATCH_ETHER_TYPE | EF4_FILTER_MATCH_IP_PROTO |\r\nEF4_FILTER_MATCH_LOC_HOST | EF4_FILTER_MATCH_LOC_PORT): {\r\n__be32 rhost, host1, host2;\r\n__be16 rport, port1, port2;\r\nEF4_BUG_ON_PARANOID(!(gen_spec->flags & EF4_FILTER_FLAG_RX));\r\nif (gen_spec->ether_type != htons(ETH_P_IP))\r\nreturn -EPROTONOSUPPORT;\r\nif (gen_spec->loc_port == 0 ||\r\n(is_full && gen_spec->rem_port == 0))\r\nreturn -EADDRNOTAVAIL;\r\nswitch (gen_spec->ip_proto) {\r\ncase IPPROTO_TCP:\r\nspec->type = (is_full ? EF4_FARCH_FILTER_TCP_FULL :\r\nEF4_FARCH_FILTER_TCP_WILD);\r\nbreak;\r\ncase IPPROTO_UDP:\r\nspec->type = (is_full ? EF4_FARCH_FILTER_UDP_FULL :\r\nEF4_FARCH_FILTER_UDP_WILD);\r\nbreak;\r\ndefault:\r\nreturn -EPROTONOSUPPORT;\r\n}\r\nrhost = is_full ? gen_spec->rem_host[0] : 0;\r\nrport = is_full ? gen_spec->rem_port : 0;\r\nhost1 = rhost;\r\nhost2 = gen_spec->loc_host[0];\r\nif (!is_full && gen_spec->ip_proto == IPPROTO_UDP) {\r\nport1 = gen_spec->loc_port;\r\nport2 = rport;\r\n} else {\r\nport1 = rport;\r\nport2 = gen_spec->loc_port;\r\n}\r\nspec->data[0] = ntohl(host1) << 16 | ntohs(port1);\r\nspec->data[1] = ntohs(port2) << 16 | ntohl(host1) >> 16;\r\nspec->data[2] = ntohl(host2);\r\nbreak;\r\n}\r\ncase EF4_FILTER_MATCH_LOC_MAC | EF4_FILTER_MATCH_OUTER_VID:\r\nis_full = true;\r\ncase EF4_FILTER_MATCH_LOC_MAC:\r\nspec->type = (is_full ? EF4_FARCH_FILTER_MAC_FULL :\r\nEF4_FARCH_FILTER_MAC_WILD);\r\nspec->data[0] = is_full ? ntohs(gen_spec->outer_vid) : 0;\r\nspec->data[1] = (gen_spec->loc_mac[2] << 24 |\r\ngen_spec->loc_mac[3] << 16 |\r\ngen_spec->loc_mac[4] << 8 |\r\ngen_spec->loc_mac[5]);\r\nspec->data[2] = (gen_spec->loc_mac[0] << 8 |\r\ngen_spec->loc_mac[1]);\r\nbreak;\r\ncase EF4_FILTER_MATCH_LOC_MAC_IG:\r\nspec->type = (is_multicast_ether_addr(gen_spec->loc_mac) ?\r\nEF4_FARCH_FILTER_MC_DEF :\r\nEF4_FARCH_FILTER_UC_DEF);\r\nmemset(spec->data, 0, sizeof(spec->data));\r\nbreak;\r\ndefault:\r\nreturn -EPROTONOSUPPORT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nef4_farch_filter_to_gen_spec(struct ef4_filter_spec *gen_spec,\r\nconst struct ef4_farch_filter_spec *spec)\r\n{\r\nbool is_full = false;\r\nmemset(gen_spec, 0, sizeof(*gen_spec));\r\ngen_spec->priority = spec->priority;\r\ngen_spec->flags = spec->flags;\r\ngen_spec->dmaq_id = spec->dmaq_id;\r\nswitch (spec->type) {\r\ncase EF4_FARCH_FILTER_TCP_FULL:\r\ncase EF4_FARCH_FILTER_UDP_FULL:\r\nis_full = true;\r\ncase EF4_FARCH_FILTER_TCP_WILD:\r\ncase EF4_FARCH_FILTER_UDP_WILD: {\r\n__be32 host1, host2;\r\n__be16 port1, port2;\r\ngen_spec->match_flags =\r\nEF4_FILTER_MATCH_ETHER_TYPE |\r\nEF4_FILTER_MATCH_IP_PROTO |\r\nEF4_FILTER_MATCH_LOC_HOST | EF4_FILTER_MATCH_LOC_PORT;\r\nif (is_full)\r\ngen_spec->match_flags |= (EF4_FILTER_MATCH_REM_HOST |\r\nEF4_FILTER_MATCH_REM_PORT);\r\ngen_spec->ether_type = htons(ETH_P_IP);\r\ngen_spec->ip_proto =\r\n(spec->type == EF4_FARCH_FILTER_TCP_FULL ||\r\nspec->type == EF4_FARCH_FILTER_TCP_WILD) ?\r\nIPPROTO_TCP : IPPROTO_UDP;\r\nhost1 = htonl(spec->data[0] >> 16 | spec->data[1] << 16);\r\nport1 = htons(spec->data[0]);\r\nhost2 = htonl(spec->data[2]);\r\nport2 = htons(spec->data[1] >> 16);\r\nif (spec->flags & EF4_FILTER_FLAG_TX) {\r\ngen_spec->loc_host[0] = host1;\r\ngen_spec->rem_host[0] = host2;\r\n} else {\r\ngen_spec->loc_host[0] = host2;\r\ngen_spec->rem_host[0] = host1;\r\n}\r\nif (!!(gen_spec->flags & EF4_FILTER_FLAG_TX) ^\r\n(!is_full && gen_spec->ip_proto == IPPROTO_UDP)) {\r\ngen_spec->loc_port = port1;\r\ngen_spec->rem_port = port2;\r\n} else {\r\ngen_spec->loc_port = port2;\r\ngen_spec->rem_port = port1;\r\n}\r\nbreak;\r\n}\r\ncase EF4_FARCH_FILTER_MAC_FULL:\r\nis_full = true;\r\ncase EF4_FARCH_FILTER_MAC_WILD:\r\ngen_spec->match_flags = EF4_FILTER_MATCH_LOC_MAC;\r\nif (is_full)\r\ngen_spec->match_flags |= EF4_FILTER_MATCH_OUTER_VID;\r\ngen_spec->loc_mac[0] = spec->data[2] >> 8;\r\ngen_spec->loc_mac[1] = spec->data[2];\r\ngen_spec->loc_mac[2] = spec->data[1] >> 24;\r\ngen_spec->loc_mac[3] = spec->data[1] >> 16;\r\ngen_spec->loc_mac[4] = spec->data[1] >> 8;\r\ngen_spec->loc_mac[5] = spec->data[1];\r\ngen_spec->outer_vid = htons(spec->data[0]);\r\nbreak;\r\ncase EF4_FARCH_FILTER_UC_DEF:\r\ncase EF4_FARCH_FILTER_MC_DEF:\r\ngen_spec->match_flags = EF4_FILTER_MATCH_LOC_MAC_IG;\r\ngen_spec->loc_mac[0] = spec->type == EF4_FARCH_FILTER_MC_DEF;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nef4_farch_filter_init_rx_auto(struct ef4_nic *efx,\r\nstruct ef4_farch_filter_spec *spec)\r\n{\r\nspec->priority = EF4_FILTER_PRI_AUTO;\r\nspec->flags = (EF4_FILTER_FLAG_RX |\r\n(ef4_rss_enabled(efx) ? EF4_FILTER_FLAG_RX_RSS : 0) |\r\n(efx->rx_scatter ? EF4_FILTER_FLAG_RX_SCATTER : 0));\r\nspec->dmaq_id = 0;\r\n}\r\nstatic u32 ef4_farch_filter_build(ef4_oword_t *filter,\r\nstruct ef4_farch_filter_spec *spec)\r\n{\r\nu32 data3;\r\nswitch (ef4_farch_filter_spec_table_id(spec)) {\r\ncase EF4_FARCH_FILTER_TABLE_RX_IP: {\r\nbool is_udp = (spec->type == EF4_FARCH_FILTER_UDP_FULL ||\r\nspec->type == EF4_FARCH_FILTER_UDP_WILD);\r\nEF4_POPULATE_OWORD_7(\r\n*filter,\r\nFRF_BZ_RSS_EN,\r\n!!(spec->flags & EF4_FILTER_FLAG_RX_RSS),\r\nFRF_BZ_SCATTER_EN,\r\n!!(spec->flags & EF4_FILTER_FLAG_RX_SCATTER),\r\nFRF_BZ_TCP_UDP, is_udp,\r\nFRF_BZ_RXQ_ID, spec->dmaq_id,\r\nEF4_DWORD_2, spec->data[2],\r\nEF4_DWORD_1, spec->data[1],\r\nEF4_DWORD_0, spec->data[0]);\r\ndata3 = is_udp;\r\nbreak;\r\n}\r\ncase EF4_FARCH_FILTER_TABLE_RX_MAC: {\r\nbool is_wild = spec->type == EF4_FARCH_FILTER_MAC_WILD;\r\nEF4_POPULATE_OWORD_7(\r\n*filter,\r\nFRF_CZ_RMFT_RSS_EN,\r\n!!(spec->flags & EF4_FILTER_FLAG_RX_RSS),\r\nFRF_CZ_RMFT_SCATTER_EN,\r\n!!(spec->flags & EF4_FILTER_FLAG_RX_SCATTER),\r\nFRF_CZ_RMFT_RXQ_ID, spec->dmaq_id,\r\nFRF_CZ_RMFT_WILDCARD_MATCH, is_wild,\r\nFRF_CZ_RMFT_DEST_MAC_HI, spec->data[2],\r\nFRF_CZ_RMFT_DEST_MAC_LO, spec->data[1],\r\nFRF_CZ_RMFT_VLAN_ID, spec->data[0]);\r\ndata3 = is_wild;\r\nbreak;\r\n}\r\ncase EF4_FARCH_FILTER_TABLE_TX_MAC: {\r\nbool is_wild = spec->type == EF4_FARCH_FILTER_MAC_WILD;\r\nEF4_POPULATE_OWORD_5(*filter,\r\nFRF_CZ_TMFT_TXQ_ID, spec->dmaq_id,\r\nFRF_CZ_TMFT_WILDCARD_MATCH, is_wild,\r\nFRF_CZ_TMFT_SRC_MAC_HI, spec->data[2],\r\nFRF_CZ_TMFT_SRC_MAC_LO, spec->data[1],\r\nFRF_CZ_TMFT_VLAN_ID, spec->data[0]);\r\ndata3 = is_wild | spec->dmaq_id << 1;\r\nbreak;\r\n}\r\ndefault:\r\nBUG();\r\n}\r\nreturn spec->data[0] ^ spec->data[1] ^ spec->data[2] ^ data3;\r\n}\r\nstatic bool ef4_farch_filter_equal(const struct ef4_farch_filter_spec *left,\r\nconst struct ef4_farch_filter_spec *right)\r\n{\r\nif (left->type != right->type ||\r\nmemcmp(left->data, right->data, sizeof(left->data)))\r\nreturn false;\r\nif (left->flags & EF4_FILTER_FLAG_TX &&\r\nleft->dmaq_id != right->dmaq_id)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic inline u32\r\nef4_farch_filter_make_id(const struct ef4_farch_filter_spec *spec,\r\nunsigned int index)\r\n{\r\nunsigned int range;\r\nrange = ef4_farch_filter_type_match_pri[spec->type];\r\nif (!(spec->flags & EF4_FILTER_FLAG_RX))\r\nrange += EF4_FARCH_FILTER_MATCH_PRI_COUNT;\r\nreturn range << EF4_FARCH_FILTER_INDEX_WIDTH | index;\r\n}\r\nstatic inline enum ef4_farch_filter_table_id\r\nef4_farch_filter_id_table_id(u32 id)\r\n{\r\nunsigned int range = id >> EF4_FARCH_FILTER_INDEX_WIDTH;\r\nif (range < ARRAY_SIZE(ef4_farch_filter_range_table))\r\nreturn ef4_farch_filter_range_table[range];\r\nelse\r\nreturn EF4_FARCH_FILTER_TABLE_COUNT;\r\n}\r\nstatic inline unsigned int ef4_farch_filter_id_index(u32 id)\r\n{\r\nreturn id & EF4_FARCH_FILTER_INDEX_MASK;\r\n}\r\nu32 ef4_farch_filter_get_rx_id_limit(struct ef4_nic *efx)\r\n{\r\nstruct ef4_farch_filter_state *state = efx->filter_state;\r\nunsigned int range = EF4_FARCH_FILTER_MATCH_PRI_COUNT - 1;\r\nenum ef4_farch_filter_table_id table_id;\r\ndo {\r\ntable_id = ef4_farch_filter_range_table[range];\r\nif (state->table[table_id].size != 0)\r\nreturn range << EF4_FARCH_FILTER_INDEX_WIDTH |\r\nstate->table[table_id].size;\r\n} while (range--);\r\nreturn 0;\r\n}\r\ns32 ef4_farch_filter_insert(struct ef4_nic *efx,\r\nstruct ef4_filter_spec *gen_spec,\r\nbool replace_equal)\r\n{\r\nstruct ef4_farch_filter_state *state = efx->filter_state;\r\nstruct ef4_farch_filter_table *table;\r\nstruct ef4_farch_filter_spec spec;\r\nef4_oword_t filter;\r\nint rep_index, ins_index;\r\nunsigned int depth = 0;\r\nint rc;\r\nrc = ef4_farch_filter_from_gen_spec(&spec, gen_spec);\r\nif (rc)\r\nreturn rc;\r\ntable = &state->table[ef4_farch_filter_spec_table_id(&spec)];\r\nif (table->size == 0)\r\nreturn -EINVAL;\r\nnetif_vdbg(efx, hw, efx->net_dev,\r\n"%s: type %d search_limit=%d", __func__, spec.type,\r\ntable->search_limit[spec.type]);\r\nif (table->id == EF4_FARCH_FILTER_TABLE_RX_DEF) {\r\nBUILD_BUG_ON(EF4_FARCH_FILTER_INDEX_UC_DEF != 0);\r\nBUILD_BUG_ON(EF4_FARCH_FILTER_INDEX_MC_DEF !=\r\nEF4_FARCH_FILTER_MC_DEF - EF4_FARCH_FILTER_UC_DEF);\r\nrep_index = spec.type - EF4_FARCH_FILTER_UC_DEF;\r\nins_index = rep_index;\r\nspin_lock_bh(&efx->filter_lock);\r\n} else {\r\nu32 key = ef4_farch_filter_build(&filter, &spec);\r\nunsigned int hash = ef4_farch_filter_hash(key);\r\nunsigned int incr = ef4_farch_filter_increment(key);\r\nunsigned int max_rep_depth = table->search_limit[spec.type];\r\nunsigned int max_ins_depth =\r\nspec.priority <= EF4_FILTER_PRI_HINT ?\r\nEF4_FARCH_FILTER_CTL_SRCH_HINT_MAX :\r\nEF4_FARCH_FILTER_CTL_SRCH_MAX;\r\nunsigned int i = hash & (table->size - 1);\r\nins_index = -1;\r\ndepth = 1;\r\nspin_lock_bh(&efx->filter_lock);\r\nfor (;;) {\r\nif (!test_bit(i, table->used_bitmap)) {\r\nif (ins_index < 0)\r\nins_index = i;\r\n} else if (ef4_farch_filter_equal(&spec,\r\n&table->spec[i])) {\r\nif (ins_index < 0)\r\nins_index = i;\r\nrep_index = i;\r\nbreak;\r\n}\r\nif (depth >= max_rep_depth &&\r\n(ins_index >= 0 || depth >= max_ins_depth)) {\r\nif (ins_index < 0) {\r\nrc = -EBUSY;\r\ngoto out;\r\n}\r\nrep_index = -1;\r\nbreak;\r\n}\r\ni = (i + incr) & (table->size - 1);\r\n++depth;\r\n}\r\n}\r\nif (rep_index >= 0) {\r\nstruct ef4_farch_filter_spec *saved_spec =\r\n&table->spec[rep_index];\r\nif (spec.priority == saved_spec->priority && !replace_equal) {\r\nrc = -EEXIST;\r\ngoto out;\r\n}\r\nif (spec.priority < saved_spec->priority) {\r\nrc = -EPERM;\r\ngoto out;\r\n}\r\nif (saved_spec->priority == EF4_FILTER_PRI_AUTO ||\r\nsaved_spec->flags & EF4_FILTER_FLAG_RX_OVER_AUTO)\r\nspec.flags |= EF4_FILTER_FLAG_RX_OVER_AUTO;\r\n}\r\nif (ins_index != rep_index) {\r\n__set_bit(ins_index, table->used_bitmap);\r\n++table->used;\r\n}\r\ntable->spec[ins_index] = spec;\r\nif (table->id == EF4_FARCH_FILTER_TABLE_RX_DEF) {\r\nef4_farch_filter_push_rx_config(efx);\r\n} else {\r\nif (table->search_limit[spec.type] < depth) {\r\ntable->search_limit[spec.type] = depth;\r\nif (spec.flags & EF4_FILTER_FLAG_TX)\r\nef4_farch_filter_push_tx_limits(efx);\r\nelse\r\nef4_farch_filter_push_rx_config(efx);\r\n}\r\nef4_writeo(efx, &filter,\r\ntable->offset + table->step * ins_index);\r\nif (ins_index != rep_index && rep_index >= 0)\r\nef4_farch_filter_table_clear_entry(efx, table,\r\nrep_index);\r\n}\r\nnetif_vdbg(efx, hw, efx->net_dev,\r\n"%s: filter type %d index %d rxq %u set",\r\n__func__, spec.type, ins_index, spec.dmaq_id);\r\nrc = ef4_farch_filter_make_id(&spec, ins_index);\r\nout:\r\nspin_unlock_bh(&efx->filter_lock);\r\nreturn rc;\r\n}\r\nstatic void\r\nef4_farch_filter_table_clear_entry(struct ef4_nic *efx,\r\nstruct ef4_farch_filter_table *table,\r\nunsigned int filter_idx)\r\n{\r\nstatic ef4_oword_t filter;\r\nEF4_WARN_ON_PARANOID(!test_bit(filter_idx, table->used_bitmap));\r\nBUG_ON(table->offset == 0);\r\n__clear_bit(filter_idx, table->used_bitmap);\r\n--table->used;\r\nmemset(&table->spec[filter_idx], 0, sizeof(table->spec[0]));\r\nef4_writeo(efx, &filter, table->offset + table->step * filter_idx);\r\nif (unlikely(table->used == 0)) {\r\nmemset(table->search_limit, 0, sizeof(table->search_limit));\r\nif (table->id == EF4_FARCH_FILTER_TABLE_TX_MAC)\r\nef4_farch_filter_push_tx_limits(efx);\r\nelse\r\nef4_farch_filter_push_rx_config(efx);\r\n}\r\n}\r\nstatic int ef4_farch_filter_remove(struct ef4_nic *efx,\r\nstruct ef4_farch_filter_table *table,\r\nunsigned int filter_idx,\r\nenum ef4_filter_priority priority)\r\n{\r\nstruct ef4_farch_filter_spec *spec = &table->spec[filter_idx];\r\nif (!test_bit(filter_idx, table->used_bitmap) ||\r\nspec->priority != priority)\r\nreturn -ENOENT;\r\nif (spec->flags & EF4_FILTER_FLAG_RX_OVER_AUTO) {\r\nef4_farch_filter_init_rx_auto(efx, spec);\r\nef4_farch_filter_push_rx_config(efx);\r\n} else {\r\nef4_farch_filter_table_clear_entry(efx, table, filter_idx);\r\n}\r\nreturn 0;\r\n}\r\nint ef4_farch_filter_remove_safe(struct ef4_nic *efx,\r\nenum ef4_filter_priority priority,\r\nu32 filter_id)\r\n{\r\nstruct ef4_farch_filter_state *state = efx->filter_state;\r\nenum ef4_farch_filter_table_id table_id;\r\nstruct ef4_farch_filter_table *table;\r\nunsigned int filter_idx;\r\nstruct ef4_farch_filter_spec *spec;\r\nint rc;\r\ntable_id = ef4_farch_filter_id_table_id(filter_id);\r\nif ((unsigned int)table_id >= EF4_FARCH_FILTER_TABLE_COUNT)\r\nreturn -ENOENT;\r\ntable = &state->table[table_id];\r\nfilter_idx = ef4_farch_filter_id_index(filter_id);\r\nif (filter_idx >= table->size)\r\nreturn -ENOENT;\r\nspec = &table->spec[filter_idx];\r\nspin_lock_bh(&efx->filter_lock);\r\nrc = ef4_farch_filter_remove(efx, table, filter_idx, priority);\r\nspin_unlock_bh(&efx->filter_lock);\r\nreturn rc;\r\n}\r\nint ef4_farch_filter_get_safe(struct ef4_nic *efx,\r\nenum ef4_filter_priority priority,\r\nu32 filter_id, struct ef4_filter_spec *spec_buf)\r\n{\r\nstruct ef4_farch_filter_state *state = efx->filter_state;\r\nenum ef4_farch_filter_table_id table_id;\r\nstruct ef4_farch_filter_table *table;\r\nstruct ef4_farch_filter_spec *spec;\r\nunsigned int filter_idx;\r\nint rc;\r\ntable_id = ef4_farch_filter_id_table_id(filter_id);\r\nif ((unsigned int)table_id >= EF4_FARCH_FILTER_TABLE_COUNT)\r\nreturn -ENOENT;\r\ntable = &state->table[table_id];\r\nfilter_idx = ef4_farch_filter_id_index(filter_id);\r\nif (filter_idx >= table->size)\r\nreturn -ENOENT;\r\nspec = &table->spec[filter_idx];\r\nspin_lock_bh(&efx->filter_lock);\r\nif (test_bit(filter_idx, table->used_bitmap) &&\r\nspec->priority == priority) {\r\nef4_farch_filter_to_gen_spec(spec_buf, spec);\r\nrc = 0;\r\n} else {\r\nrc = -ENOENT;\r\n}\r\nspin_unlock_bh(&efx->filter_lock);\r\nreturn rc;\r\n}\r\nstatic void\r\nef4_farch_filter_table_clear(struct ef4_nic *efx,\r\nenum ef4_farch_filter_table_id table_id,\r\nenum ef4_filter_priority priority)\r\n{\r\nstruct ef4_farch_filter_state *state = efx->filter_state;\r\nstruct ef4_farch_filter_table *table = &state->table[table_id];\r\nunsigned int filter_idx;\r\nspin_lock_bh(&efx->filter_lock);\r\nfor (filter_idx = 0; filter_idx < table->size; ++filter_idx) {\r\nif (table->spec[filter_idx].priority != EF4_FILTER_PRI_AUTO)\r\nef4_farch_filter_remove(efx, table,\r\nfilter_idx, priority);\r\n}\r\nspin_unlock_bh(&efx->filter_lock);\r\n}\r\nint ef4_farch_filter_clear_rx(struct ef4_nic *efx,\r\nenum ef4_filter_priority priority)\r\n{\r\nef4_farch_filter_table_clear(efx, EF4_FARCH_FILTER_TABLE_RX_IP,\r\npriority);\r\nef4_farch_filter_table_clear(efx, EF4_FARCH_FILTER_TABLE_RX_MAC,\r\npriority);\r\nef4_farch_filter_table_clear(efx, EF4_FARCH_FILTER_TABLE_RX_DEF,\r\npriority);\r\nreturn 0;\r\n}\r\nu32 ef4_farch_filter_count_rx_used(struct ef4_nic *efx,\r\nenum ef4_filter_priority priority)\r\n{\r\nstruct ef4_farch_filter_state *state = efx->filter_state;\r\nenum ef4_farch_filter_table_id table_id;\r\nstruct ef4_farch_filter_table *table;\r\nunsigned int filter_idx;\r\nu32 count = 0;\r\nspin_lock_bh(&efx->filter_lock);\r\nfor (table_id = EF4_FARCH_FILTER_TABLE_RX_IP;\r\ntable_id <= EF4_FARCH_FILTER_TABLE_RX_DEF;\r\ntable_id++) {\r\ntable = &state->table[table_id];\r\nfor (filter_idx = 0; filter_idx < table->size; filter_idx++) {\r\nif (test_bit(filter_idx, table->used_bitmap) &&\r\ntable->spec[filter_idx].priority == priority)\r\n++count;\r\n}\r\n}\r\nspin_unlock_bh(&efx->filter_lock);\r\nreturn count;\r\n}\r\ns32 ef4_farch_filter_get_rx_ids(struct ef4_nic *efx,\r\nenum ef4_filter_priority priority,\r\nu32 *buf, u32 size)\r\n{\r\nstruct ef4_farch_filter_state *state = efx->filter_state;\r\nenum ef4_farch_filter_table_id table_id;\r\nstruct ef4_farch_filter_table *table;\r\nunsigned int filter_idx;\r\ns32 count = 0;\r\nspin_lock_bh(&efx->filter_lock);\r\nfor (table_id = EF4_FARCH_FILTER_TABLE_RX_IP;\r\ntable_id <= EF4_FARCH_FILTER_TABLE_RX_DEF;\r\ntable_id++) {\r\ntable = &state->table[table_id];\r\nfor (filter_idx = 0; filter_idx < table->size; filter_idx++) {\r\nif (test_bit(filter_idx, table->used_bitmap) &&\r\ntable->spec[filter_idx].priority == priority) {\r\nif (count == size) {\r\ncount = -EMSGSIZE;\r\ngoto out;\r\n}\r\nbuf[count++] = ef4_farch_filter_make_id(\r\n&table->spec[filter_idx], filter_idx);\r\n}\r\n}\r\n}\r\nout:\r\nspin_unlock_bh(&efx->filter_lock);\r\nreturn count;\r\n}\r\nvoid ef4_farch_filter_table_restore(struct ef4_nic *efx)\r\n{\r\nstruct ef4_farch_filter_state *state = efx->filter_state;\r\nenum ef4_farch_filter_table_id table_id;\r\nstruct ef4_farch_filter_table *table;\r\nef4_oword_t filter;\r\nunsigned int filter_idx;\r\nspin_lock_bh(&efx->filter_lock);\r\nfor (table_id = 0; table_id < EF4_FARCH_FILTER_TABLE_COUNT; table_id++) {\r\ntable = &state->table[table_id];\r\nif (table->step == 0)\r\ncontinue;\r\nfor (filter_idx = 0; filter_idx < table->size; filter_idx++) {\r\nif (!test_bit(filter_idx, table->used_bitmap))\r\ncontinue;\r\nef4_farch_filter_build(&filter, &table->spec[filter_idx]);\r\nef4_writeo(efx, &filter,\r\ntable->offset + table->step * filter_idx);\r\n}\r\n}\r\nef4_farch_filter_push_rx_config(efx);\r\nef4_farch_filter_push_tx_limits(efx);\r\nspin_unlock_bh(&efx->filter_lock);\r\n}\r\nvoid ef4_farch_filter_table_remove(struct ef4_nic *efx)\r\n{\r\nstruct ef4_farch_filter_state *state = efx->filter_state;\r\nenum ef4_farch_filter_table_id table_id;\r\nfor (table_id = 0; table_id < EF4_FARCH_FILTER_TABLE_COUNT; table_id++) {\r\nkfree(state->table[table_id].used_bitmap);\r\nvfree(state->table[table_id].spec);\r\n}\r\nkfree(state);\r\n}\r\nint ef4_farch_filter_table_probe(struct ef4_nic *efx)\r\n{\r\nstruct ef4_farch_filter_state *state;\r\nstruct ef4_farch_filter_table *table;\r\nunsigned table_id;\r\nstate = kzalloc(sizeof(struct ef4_farch_filter_state), GFP_KERNEL);\r\nif (!state)\r\nreturn -ENOMEM;\r\nefx->filter_state = state;\r\nif (ef4_nic_rev(efx) >= EF4_REV_FALCON_B0) {\r\ntable = &state->table[EF4_FARCH_FILTER_TABLE_RX_IP];\r\ntable->id = EF4_FARCH_FILTER_TABLE_RX_IP;\r\ntable->offset = FR_BZ_RX_FILTER_TBL0;\r\ntable->size = FR_BZ_RX_FILTER_TBL0_ROWS;\r\ntable->step = FR_BZ_RX_FILTER_TBL0_STEP;\r\n}\r\nfor (table_id = 0; table_id < EF4_FARCH_FILTER_TABLE_COUNT; table_id++) {\r\ntable = &state->table[table_id];\r\nif (table->size == 0)\r\ncontinue;\r\ntable->used_bitmap = kcalloc(BITS_TO_LONGS(table->size),\r\nsizeof(unsigned long),\r\nGFP_KERNEL);\r\nif (!table->used_bitmap)\r\ngoto fail;\r\ntable->spec = vzalloc(table->size * sizeof(*table->spec));\r\nif (!table->spec)\r\ngoto fail;\r\n}\r\ntable = &state->table[EF4_FARCH_FILTER_TABLE_RX_DEF];\r\nif (table->size) {\r\nstruct ef4_farch_filter_spec *spec;\r\nunsigned i;\r\nfor (i = 0; i < EF4_FARCH_FILTER_SIZE_RX_DEF; i++) {\r\nspec = &table->spec[i];\r\nspec->type = EF4_FARCH_FILTER_UC_DEF + i;\r\nef4_farch_filter_init_rx_auto(efx, spec);\r\n__set_bit(i, table->used_bitmap);\r\n}\r\n}\r\nef4_farch_filter_push_rx_config(efx);\r\nreturn 0;\r\nfail:\r\nef4_farch_filter_table_remove(efx);\r\nreturn -ENOMEM;\r\n}\r\nvoid ef4_farch_filter_update_rx_scatter(struct ef4_nic *efx)\r\n{\r\nstruct ef4_farch_filter_state *state = efx->filter_state;\r\nenum ef4_farch_filter_table_id table_id;\r\nstruct ef4_farch_filter_table *table;\r\nef4_oword_t filter;\r\nunsigned int filter_idx;\r\nspin_lock_bh(&efx->filter_lock);\r\nfor (table_id = EF4_FARCH_FILTER_TABLE_RX_IP;\r\ntable_id <= EF4_FARCH_FILTER_TABLE_RX_DEF;\r\ntable_id++) {\r\ntable = &state->table[table_id];\r\nfor (filter_idx = 0; filter_idx < table->size; filter_idx++) {\r\nif (!test_bit(filter_idx, table->used_bitmap) ||\r\ntable->spec[filter_idx].dmaq_id >=\r\nefx->n_rx_channels)\r\ncontinue;\r\nif (efx->rx_scatter)\r\ntable->spec[filter_idx].flags |=\r\nEF4_FILTER_FLAG_RX_SCATTER;\r\nelse\r\ntable->spec[filter_idx].flags &=\r\n~EF4_FILTER_FLAG_RX_SCATTER;\r\nif (table_id == EF4_FARCH_FILTER_TABLE_RX_DEF)\r\ncontinue;\r\nef4_farch_filter_build(&filter, &table->spec[filter_idx]);\r\nef4_writeo(efx, &filter,\r\ntable->offset + table->step * filter_idx);\r\n}\r\n}\r\nef4_farch_filter_push_rx_config(efx);\r\nspin_unlock_bh(&efx->filter_lock);\r\n}\r\ns32 ef4_farch_filter_rfs_insert(struct ef4_nic *efx,\r\nstruct ef4_filter_spec *gen_spec)\r\n{\r\nreturn ef4_farch_filter_insert(efx, gen_spec, true);\r\n}\r\nbool ef4_farch_filter_rfs_expire_one(struct ef4_nic *efx, u32 flow_id,\r\nunsigned int index)\r\n{\r\nstruct ef4_farch_filter_state *state = efx->filter_state;\r\nstruct ef4_farch_filter_table *table =\r\n&state->table[EF4_FARCH_FILTER_TABLE_RX_IP];\r\nif (test_bit(index, table->used_bitmap) &&\r\ntable->spec[index].priority == EF4_FILTER_PRI_HINT &&\r\nrps_may_expire_flow(efx->net_dev, table->spec[index].dmaq_id,\r\nflow_id, index)) {\r\nef4_farch_filter_table_clear_entry(efx, table, index);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nvoid ef4_farch_filter_sync_rx_mode(struct ef4_nic *efx)\r\n{\r\nstruct net_device *net_dev = efx->net_dev;\r\nstruct netdev_hw_addr *ha;\r\nunion ef4_multicast_hash *mc_hash = &efx->multicast_hash;\r\nu32 crc;\r\nint bit;\r\nif (!ef4_dev_registered(efx))\r\nreturn;\r\nnetif_addr_lock_bh(net_dev);\r\nefx->unicast_filter = !(net_dev->flags & IFF_PROMISC);\r\nif (net_dev->flags & (IFF_PROMISC | IFF_ALLMULTI)) {\r\nmemset(mc_hash, 0xff, sizeof(*mc_hash));\r\n} else {\r\nmemset(mc_hash, 0x00, sizeof(*mc_hash));\r\nnetdev_for_each_mc_addr(ha, net_dev) {\r\ncrc = ether_crc_le(ETH_ALEN, ha->addr);\r\nbit = crc & (EF4_MCAST_HASH_ENTRIES - 1);\r\n__set_bit_le(bit, mc_hash);\r\n}\r\n__set_bit_le(0xff, mc_hash);\r\n}\r\nnetif_addr_unlock_bh(net_dev);\r\n}
