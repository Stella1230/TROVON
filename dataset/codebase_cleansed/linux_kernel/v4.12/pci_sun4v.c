static inline void iommu_batch_start(struct device *dev, unsigned long prot, unsigned long entry)\r\n{\r\nstruct iommu_batch *p = this_cpu_ptr(&iommu_batch);\r\np->dev = dev;\r\np->prot = prot;\r\np->entry = entry;\r\np->npages = 0;\r\n}\r\nstatic long iommu_batch_flush(struct iommu_batch *p, u64 mask)\r\n{\r\nstruct pci_pbm_info *pbm = p->dev->archdata.host_controller;\r\nu64 *pglist = p->pglist;\r\nu64 index_count;\r\nunsigned long devhandle = pbm->devhandle;\r\nunsigned long prot = p->prot;\r\nunsigned long entry = p->entry;\r\nunsigned long npages = p->npages;\r\nunsigned long iotsb_num;\r\nunsigned long ret;\r\nlong num;\r\nif (vpci_major < 2)\r\nprot &= (HV_PCI_MAP_ATTR_READ | HV_PCI_MAP_ATTR_WRITE);\r\nwhile (npages != 0) {\r\nif (mask <= DMA_BIT_MASK(32)) {\r\nnum = pci_sun4v_iommu_map(devhandle,\r\nHV_PCI_TSBID(0, entry),\r\nnpages,\r\nprot,\r\n__pa(pglist));\r\nif (unlikely(num < 0)) {\r\npr_err_ratelimited("%s: IOMMU map of [%08lx:%08llx:%lx:%lx:%lx] failed with status %ld\n",\r\n__func__,\r\ndevhandle,\r\nHV_PCI_TSBID(0, entry),\r\nnpages, prot, __pa(pglist),\r\nnum);\r\nreturn -1;\r\n}\r\n} else {\r\nindex_count = HV_PCI_IOTSB_INDEX_COUNT(npages, entry),\r\niotsb_num = pbm->iommu->atu->iotsb->iotsb_num;\r\nret = pci_sun4v_iotsb_map(devhandle,\r\niotsb_num,\r\nindex_count,\r\nprot,\r\n__pa(pglist),\r\n&num);\r\nif (unlikely(ret != HV_EOK)) {\r\npr_err_ratelimited("%s: ATU map of [%08lx:%lx:%llx:%lx:%lx] failed with status %ld\n",\r\n__func__,\r\ndevhandle, iotsb_num,\r\nindex_count, prot,\r\n__pa(pglist), ret);\r\nreturn -1;\r\n}\r\n}\r\nentry += num;\r\nnpages -= num;\r\npglist += num;\r\n}\r\np->entry = entry;\r\np->npages = 0;\r\nreturn 0;\r\n}\r\nstatic inline void iommu_batch_new_entry(unsigned long entry, u64 mask)\r\n{\r\nstruct iommu_batch *p = this_cpu_ptr(&iommu_batch);\r\nif (p->entry + p->npages == entry)\r\nreturn;\r\nif (p->entry != ~0UL)\r\niommu_batch_flush(p, mask);\r\np->entry = entry;\r\n}\r\nstatic inline long iommu_batch_add(u64 phys_page, u64 mask)\r\n{\r\nstruct iommu_batch *p = this_cpu_ptr(&iommu_batch);\r\nBUG_ON(p->npages >= PGLIST_NENTS);\r\np->pglist[p->npages++] = phys_page;\r\nif (p->npages == PGLIST_NENTS)\r\nreturn iommu_batch_flush(p, mask);\r\nreturn 0;\r\n}\r\nstatic inline long iommu_batch_end(u64 mask)\r\n{\r\nstruct iommu_batch *p = this_cpu_ptr(&iommu_batch);\r\nBUG_ON(p->npages >= PGLIST_NENTS);\r\nreturn iommu_batch_flush(p, mask);\r\n}\r\nstatic void *dma_4v_alloc_coherent(struct device *dev, size_t size,\r\ndma_addr_t *dma_addrp, gfp_t gfp,\r\nunsigned long attrs)\r\n{\r\nu64 mask;\r\nunsigned long flags, order, first_page, npages, n;\r\nunsigned long prot = 0;\r\nstruct iommu *iommu;\r\nstruct atu *atu;\r\nstruct iommu_map_table *tbl;\r\nstruct page *page;\r\nvoid *ret;\r\nlong entry;\r\nint nid;\r\nsize = IO_PAGE_ALIGN(size);\r\norder = get_order(size);\r\nif (unlikely(order >= MAX_ORDER))\r\nreturn NULL;\r\nnpages = size >> IO_PAGE_SHIFT;\r\nif (attrs & DMA_ATTR_WEAK_ORDERING)\r\nprot = HV_PCI_MAP_ATTR_RELAXED_ORDER;\r\nnid = dev->archdata.numa_node;\r\npage = alloc_pages_node(nid, gfp, order);\r\nif (unlikely(!page))\r\nreturn NULL;\r\nfirst_page = (unsigned long) page_address(page);\r\nmemset((char *)first_page, 0, PAGE_SIZE << order);\r\niommu = dev->archdata.iommu;\r\natu = iommu->atu;\r\nmask = dev->coherent_dma_mask;\r\nif (mask <= DMA_BIT_MASK(32))\r\ntbl = &iommu->tbl;\r\nelse\r\ntbl = &atu->tbl;\r\nentry = iommu_tbl_range_alloc(dev, tbl, npages, NULL,\r\n(unsigned long)(-1), 0);\r\nif (unlikely(entry == IOMMU_ERROR_CODE))\r\ngoto range_alloc_fail;\r\n*dma_addrp = (tbl->table_map_base + (entry << IO_PAGE_SHIFT));\r\nret = (void *) first_page;\r\nfirst_page = __pa(first_page);\r\nlocal_irq_save(flags);\r\niommu_batch_start(dev,\r\n(HV_PCI_MAP_ATTR_READ | prot |\r\nHV_PCI_MAP_ATTR_WRITE),\r\nentry);\r\nfor (n = 0; n < npages; n++) {\r\nlong err = iommu_batch_add(first_page + (n * PAGE_SIZE), mask);\r\nif (unlikely(err < 0L))\r\ngoto iommu_map_fail;\r\n}\r\nif (unlikely(iommu_batch_end(mask) < 0L))\r\ngoto iommu_map_fail;\r\nlocal_irq_restore(flags);\r\nreturn ret;\r\niommu_map_fail:\r\nlocal_irq_restore(flags);\r\niommu_tbl_range_free(tbl, *dma_addrp, npages, IOMMU_ERROR_CODE);\r\nrange_alloc_fail:\r\nfree_pages(first_page, order);\r\nreturn NULL;\r\n}\r\nunsigned long dma_4v_iotsb_bind(unsigned long devhandle,\r\nunsigned long iotsb_num,\r\nstruct pci_bus *bus_dev)\r\n{\r\nstruct pci_dev *pdev;\r\nunsigned long err;\r\nunsigned int bus;\r\nunsigned int device;\r\nunsigned int fun;\r\nlist_for_each_entry(pdev, &bus_dev->devices, bus_list) {\r\nif (pdev->subordinate) {\r\ndma_4v_iotsb_bind(devhandle, iotsb_num,\r\npdev->subordinate);\r\n} else {\r\nbus = bus_dev->number;\r\ndevice = PCI_SLOT(pdev->devfn);\r\nfun = PCI_FUNC(pdev->devfn);\r\nerr = pci_sun4v_iotsb_bind(devhandle, iotsb_num,\r\nHV_PCI_DEVICE_BUILD(bus,\r\ndevice,\r\nfun));\r\nif (err)\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void dma_4v_iommu_demap(struct device *dev, unsigned long devhandle,\r\ndma_addr_t dvma, unsigned long iotsb_num,\r\nunsigned long entry, unsigned long npages)\r\n{\r\nunsigned long num, flags;\r\nunsigned long ret;\r\nlocal_irq_save(flags);\r\ndo {\r\nif (dvma <= DMA_BIT_MASK(32)) {\r\nnum = pci_sun4v_iommu_demap(devhandle,\r\nHV_PCI_TSBID(0, entry),\r\nnpages);\r\n} else {\r\nret = pci_sun4v_iotsb_demap(devhandle, iotsb_num,\r\nentry, npages, &num);\r\nif (unlikely(ret != HV_EOK)) {\r\npr_err_ratelimited("pci_iotsb_demap() failed with error: %ld\n",\r\nret);\r\n}\r\n}\r\nentry += num;\r\nnpages -= num;\r\n} while (npages != 0);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void dma_4v_free_coherent(struct device *dev, size_t size, void *cpu,\r\ndma_addr_t dvma, unsigned long attrs)\r\n{\r\nstruct pci_pbm_info *pbm;\r\nstruct iommu *iommu;\r\nstruct atu *atu;\r\nstruct iommu_map_table *tbl;\r\nunsigned long order, npages, entry;\r\nunsigned long iotsb_num;\r\nu32 devhandle;\r\nnpages = IO_PAGE_ALIGN(size) >> IO_PAGE_SHIFT;\r\niommu = dev->archdata.iommu;\r\npbm = dev->archdata.host_controller;\r\natu = iommu->atu;\r\ndevhandle = pbm->devhandle;\r\nif (dvma <= DMA_BIT_MASK(32)) {\r\ntbl = &iommu->tbl;\r\niotsb_num = 0;\r\n} else {\r\ntbl = &atu->tbl;\r\niotsb_num = atu->iotsb->iotsb_num;\r\n}\r\nentry = ((dvma - tbl->table_map_base) >> IO_PAGE_SHIFT);\r\ndma_4v_iommu_demap(dev, devhandle, dvma, iotsb_num, entry, npages);\r\niommu_tbl_range_free(tbl, dvma, npages, IOMMU_ERROR_CODE);\r\norder = get_order(size);\r\nif (order < 10)\r\nfree_pages((unsigned long)cpu, order);\r\n}\r\nstatic dma_addr_t dma_4v_map_page(struct device *dev, struct page *page,\r\nunsigned long offset, size_t sz,\r\nenum dma_data_direction direction,\r\nunsigned long attrs)\r\n{\r\nstruct iommu *iommu;\r\nstruct atu *atu;\r\nstruct iommu_map_table *tbl;\r\nu64 mask;\r\nunsigned long flags, npages, oaddr;\r\nunsigned long i, base_paddr;\r\nunsigned long prot;\r\ndma_addr_t bus_addr, ret;\r\nlong entry;\r\niommu = dev->archdata.iommu;\r\natu = iommu->atu;\r\nif (unlikely(direction == DMA_NONE))\r\ngoto bad;\r\noaddr = (unsigned long)(page_address(page) + offset);\r\nnpages = IO_PAGE_ALIGN(oaddr + sz) - (oaddr & IO_PAGE_MASK);\r\nnpages >>= IO_PAGE_SHIFT;\r\nmask = *dev->dma_mask;\r\nif (mask <= DMA_BIT_MASK(32))\r\ntbl = &iommu->tbl;\r\nelse\r\ntbl = &atu->tbl;\r\nentry = iommu_tbl_range_alloc(dev, tbl, npages, NULL,\r\n(unsigned long)(-1), 0);\r\nif (unlikely(entry == IOMMU_ERROR_CODE))\r\ngoto bad;\r\nbus_addr = (tbl->table_map_base + (entry << IO_PAGE_SHIFT));\r\nret = bus_addr | (oaddr & ~IO_PAGE_MASK);\r\nbase_paddr = __pa(oaddr & IO_PAGE_MASK);\r\nprot = HV_PCI_MAP_ATTR_READ;\r\nif (direction != DMA_TO_DEVICE)\r\nprot |= HV_PCI_MAP_ATTR_WRITE;\r\nif (attrs & DMA_ATTR_WEAK_ORDERING)\r\nprot |= HV_PCI_MAP_ATTR_RELAXED_ORDER;\r\nlocal_irq_save(flags);\r\niommu_batch_start(dev, prot, entry);\r\nfor (i = 0; i < npages; i++, base_paddr += IO_PAGE_SIZE) {\r\nlong err = iommu_batch_add(base_paddr, mask);\r\nif (unlikely(err < 0L))\r\ngoto iommu_map_fail;\r\n}\r\nif (unlikely(iommu_batch_end(mask) < 0L))\r\ngoto iommu_map_fail;\r\nlocal_irq_restore(flags);\r\nreturn ret;\r\nbad:\r\nif (printk_ratelimit())\r\nWARN_ON(1);\r\nreturn DMA_ERROR_CODE;\r\niommu_map_fail:\r\nlocal_irq_restore(flags);\r\niommu_tbl_range_free(tbl, bus_addr, npages, IOMMU_ERROR_CODE);\r\nreturn DMA_ERROR_CODE;\r\n}\r\nstatic void dma_4v_unmap_page(struct device *dev, dma_addr_t bus_addr,\r\nsize_t sz, enum dma_data_direction direction,\r\nunsigned long attrs)\r\n{\r\nstruct pci_pbm_info *pbm;\r\nstruct iommu *iommu;\r\nstruct atu *atu;\r\nstruct iommu_map_table *tbl;\r\nunsigned long npages;\r\nunsigned long iotsb_num;\r\nlong entry;\r\nu32 devhandle;\r\nif (unlikely(direction == DMA_NONE)) {\r\nif (printk_ratelimit())\r\nWARN_ON(1);\r\nreturn;\r\n}\r\niommu = dev->archdata.iommu;\r\npbm = dev->archdata.host_controller;\r\natu = iommu->atu;\r\ndevhandle = pbm->devhandle;\r\nnpages = IO_PAGE_ALIGN(bus_addr + sz) - (bus_addr & IO_PAGE_MASK);\r\nnpages >>= IO_PAGE_SHIFT;\r\nbus_addr &= IO_PAGE_MASK;\r\nif (bus_addr <= DMA_BIT_MASK(32)) {\r\niotsb_num = 0;\r\ntbl = &iommu->tbl;\r\n} else {\r\niotsb_num = atu->iotsb->iotsb_num;\r\ntbl = &atu->tbl;\r\n}\r\nentry = (bus_addr - tbl->table_map_base) >> IO_PAGE_SHIFT;\r\ndma_4v_iommu_demap(dev, devhandle, bus_addr, iotsb_num, entry, npages);\r\niommu_tbl_range_free(tbl, bus_addr, npages, IOMMU_ERROR_CODE);\r\n}\r\nstatic int dma_4v_map_sg(struct device *dev, struct scatterlist *sglist,\r\nint nelems, enum dma_data_direction direction,\r\nunsigned long attrs)\r\n{\r\nstruct scatterlist *s, *outs, *segstart;\r\nunsigned long flags, handle, prot;\r\ndma_addr_t dma_next = 0, dma_addr;\r\nunsigned int max_seg_size;\r\nunsigned long seg_boundary_size;\r\nint outcount, incount, i;\r\nstruct iommu *iommu;\r\nstruct atu *atu;\r\nstruct iommu_map_table *tbl;\r\nu64 mask;\r\nunsigned long base_shift;\r\nlong err;\r\nBUG_ON(direction == DMA_NONE);\r\niommu = dev->archdata.iommu;\r\nif (nelems == 0 || !iommu)\r\nreturn 0;\r\natu = iommu->atu;\r\nprot = HV_PCI_MAP_ATTR_READ;\r\nif (direction != DMA_TO_DEVICE)\r\nprot |= HV_PCI_MAP_ATTR_WRITE;\r\nif (attrs & DMA_ATTR_WEAK_ORDERING)\r\nprot |= HV_PCI_MAP_ATTR_RELAXED_ORDER;\r\nouts = s = segstart = &sglist[0];\r\noutcount = 1;\r\nincount = nelems;\r\nhandle = 0;\r\nouts->dma_length = 0;\r\nlocal_irq_save(flags);\r\niommu_batch_start(dev, prot, ~0UL);\r\nmax_seg_size = dma_get_max_seg_size(dev);\r\nseg_boundary_size = ALIGN(dma_get_seg_boundary(dev) + 1,\r\nIO_PAGE_SIZE) >> IO_PAGE_SHIFT;\r\nmask = *dev->dma_mask;\r\nif (mask <= DMA_BIT_MASK(32))\r\ntbl = &iommu->tbl;\r\nelse\r\ntbl = &atu->tbl;\r\nbase_shift = tbl->table_map_base >> IO_PAGE_SHIFT;\r\nfor_each_sg(sglist, s, nelems, i) {\r\nunsigned long paddr, npages, entry, out_entry = 0, slen;\r\nslen = s->length;\r\nif (slen == 0) {\r\ndma_next = 0;\r\ncontinue;\r\n}\r\npaddr = (unsigned long) SG_ENT_PHYS_ADDRESS(s);\r\nnpages = iommu_num_pages(paddr, slen, IO_PAGE_SIZE);\r\nentry = iommu_tbl_range_alloc(dev, tbl, npages,\r\n&handle, (unsigned long)(-1), 0);\r\nif (unlikely(entry == IOMMU_ERROR_CODE)) {\r\npr_err_ratelimited("iommu_alloc failed, iommu %p paddr %lx npages %lx\n",\r\ntbl, paddr, npages);\r\ngoto iommu_map_failed;\r\n}\r\niommu_batch_new_entry(entry, mask);\r\ndma_addr = tbl->table_map_base + (entry << IO_PAGE_SHIFT);\r\ndma_addr |= (s->offset & ~IO_PAGE_MASK);\r\npaddr &= IO_PAGE_MASK;\r\nwhile (npages--) {\r\nerr = iommu_batch_add(paddr, mask);\r\nif (unlikely(err < 0L))\r\ngoto iommu_map_failed;\r\npaddr += IO_PAGE_SIZE;\r\n}\r\nif (segstart != s) {\r\nif ((dma_addr != dma_next) ||\r\n(outs->dma_length + s->length > max_seg_size) ||\r\n(is_span_boundary(out_entry, base_shift,\r\nseg_boundary_size, outs, s))) {\r\nsegstart = s;\r\noutcount++;\r\nouts = sg_next(outs);\r\n} else {\r\nouts->dma_length += s->length;\r\n}\r\n}\r\nif (segstart == s) {\r\nouts->dma_address = dma_addr;\r\nouts->dma_length = slen;\r\nout_entry = entry;\r\n}\r\ndma_next = dma_addr + slen;\r\n}\r\nerr = iommu_batch_end(mask);\r\nif (unlikely(err < 0L))\r\ngoto iommu_map_failed;\r\nlocal_irq_restore(flags);\r\nif (outcount < incount) {\r\nouts = sg_next(outs);\r\nouts->dma_address = DMA_ERROR_CODE;\r\nouts->dma_length = 0;\r\n}\r\nreturn outcount;\r\niommu_map_failed:\r\nfor_each_sg(sglist, s, nelems, i) {\r\nif (s->dma_length != 0) {\r\nunsigned long vaddr, npages;\r\nvaddr = s->dma_address & IO_PAGE_MASK;\r\nnpages = iommu_num_pages(s->dma_address, s->dma_length,\r\nIO_PAGE_SIZE);\r\niommu_tbl_range_free(tbl, vaddr, npages,\r\nIOMMU_ERROR_CODE);\r\ns->dma_address = DMA_ERROR_CODE;\r\ns->dma_length = 0;\r\n}\r\nif (s == outs)\r\nbreak;\r\n}\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic void dma_4v_unmap_sg(struct device *dev, struct scatterlist *sglist,\r\nint nelems, enum dma_data_direction direction,\r\nunsigned long attrs)\r\n{\r\nstruct pci_pbm_info *pbm;\r\nstruct scatterlist *sg;\r\nstruct iommu *iommu;\r\nstruct atu *atu;\r\nunsigned long flags, entry;\r\nunsigned long iotsb_num;\r\nu32 devhandle;\r\nBUG_ON(direction == DMA_NONE);\r\niommu = dev->archdata.iommu;\r\npbm = dev->archdata.host_controller;\r\natu = iommu->atu;\r\ndevhandle = pbm->devhandle;\r\nlocal_irq_save(flags);\r\nsg = sglist;\r\nwhile (nelems--) {\r\ndma_addr_t dma_handle = sg->dma_address;\r\nunsigned int len = sg->dma_length;\r\nunsigned long npages;\r\nstruct iommu_map_table *tbl;\r\nunsigned long shift = IO_PAGE_SHIFT;\r\nif (!len)\r\nbreak;\r\nnpages = iommu_num_pages(dma_handle, len, IO_PAGE_SIZE);\r\nif (dma_handle <= DMA_BIT_MASK(32)) {\r\niotsb_num = 0;\r\ntbl = &iommu->tbl;\r\n} else {\r\niotsb_num = atu->iotsb->iotsb_num;\r\ntbl = &atu->tbl;\r\n}\r\nentry = ((dma_handle - tbl->table_map_base) >> shift);\r\ndma_4v_iommu_demap(dev, devhandle, dma_handle, iotsb_num,\r\nentry, npages);\r\niommu_tbl_range_free(tbl, dma_handle, npages,\r\nIOMMU_ERROR_CODE);\r\nsg = sg_next(sg);\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void pci_sun4v_scan_bus(struct pci_pbm_info *pbm, struct device *parent)\r\n{\r\nstruct property *prop;\r\nstruct device_node *dp;\r\ndp = pbm->op->dev.of_node;\r\nprop = of_find_property(dp, "66mhz-capable", NULL);\r\npbm->is_66mhz_capable = (prop != NULL);\r\npbm->pci_bus = pci_scan_one_pbm(pbm, parent);\r\n}\r\nstatic unsigned long probe_existing_entries(struct pci_pbm_info *pbm,\r\nstruct iommu_map_table *iommu)\r\n{\r\nstruct iommu_pool *pool;\r\nunsigned long i, pool_nr, cnt = 0;\r\nu32 devhandle;\r\ndevhandle = pbm->devhandle;\r\nfor (pool_nr = 0; pool_nr < iommu->nr_pools; pool_nr++) {\r\npool = &(iommu->pools[pool_nr]);\r\nfor (i = pool->start; i <= pool->end; i++) {\r\nunsigned long ret, io_attrs, ra;\r\nret = pci_sun4v_iommu_getmap(devhandle,\r\nHV_PCI_TSBID(0, i),\r\n&io_attrs, &ra);\r\nif (ret == HV_EOK) {\r\nif (page_in_phys_avail(ra)) {\r\npci_sun4v_iommu_demap(devhandle,\r\nHV_PCI_TSBID(0,\r\ni), 1);\r\n} else {\r\ncnt++;\r\n__set_bit(i, iommu->map);\r\n}\r\n}\r\n}\r\n}\r\nreturn cnt;\r\n}\r\nstatic int pci_sun4v_atu_alloc_iotsb(struct pci_pbm_info *pbm)\r\n{\r\nstruct atu *atu = pbm->iommu->atu;\r\nstruct atu_iotsb *iotsb;\r\nvoid *table;\r\nu64 table_size;\r\nu64 iotsb_num;\r\nunsigned long order;\r\nunsigned long err;\r\niotsb = kzalloc(sizeof(*iotsb), GFP_KERNEL);\r\nif (!iotsb) {\r\nerr = -ENOMEM;\r\ngoto out_err;\r\n}\r\natu->iotsb = iotsb;\r\ntable_size = (atu->size / IO_PAGE_SIZE) * 8;\r\norder = get_order(table_size);\r\ntable = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, order);\r\nif (!table) {\r\nerr = -ENOMEM;\r\ngoto table_failed;\r\n}\r\niotsb->table = table;\r\niotsb->ra = __pa(table);\r\niotsb->dvma_size = atu->size;\r\niotsb->dvma_base = atu->base;\r\niotsb->table_size = table_size;\r\niotsb->page_size = IO_PAGE_SIZE;\r\nerr = pci_sun4v_iotsb_conf(pbm->devhandle,\r\niotsb->ra,\r\niotsb->table_size,\r\niotsb->page_size,\r\niotsb->dvma_base,\r\n&iotsb_num);\r\nif (err) {\r\npr_err(PFX "pci_iotsb_conf failed error: %ld\n", err);\r\ngoto iotsb_conf_failed;\r\n}\r\niotsb->iotsb_num = iotsb_num;\r\nerr = dma_4v_iotsb_bind(pbm->devhandle, iotsb_num, pbm->pci_bus);\r\nif (err) {\r\npr_err(PFX "pci_iotsb_bind failed error: %ld\n", err);\r\ngoto iotsb_conf_failed;\r\n}\r\nreturn 0;\r\niotsb_conf_failed:\r\nfree_pages((unsigned long)table, order);\r\ntable_failed:\r\nkfree(iotsb);\r\nout_err:\r\nreturn err;\r\n}\r\nstatic int pci_sun4v_atu_init(struct pci_pbm_info *pbm)\r\n{\r\nstruct atu *atu = pbm->iommu->atu;\r\nunsigned long err;\r\nconst u64 *ranges;\r\nu64 map_size, num_iotte;\r\nu64 dma_mask;\r\nconst u32 *page_size;\r\nint len;\r\nranges = of_get_property(pbm->op->dev.of_node, "iommu-address-ranges",\r\n&len);\r\nif (!ranges) {\r\npr_err(PFX "No iommu-address-ranges\n");\r\nreturn -EINVAL;\r\n}\r\npage_size = of_get_property(pbm->op->dev.of_node, "iommu-pagesizes",\r\nNULL);\r\nif (!page_size) {\r\npr_err(PFX "No iommu-pagesizes\n");\r\nreturn -EINVAL;\r\n}\r\natu->ranges = (struct atu_ranges *)ranges;\r\natu->base = atu->ranges[3].base;\r\natu->size = ATU_64_SPACE_SIZE;\r\nerr = pci_sun4v_atu_alloc_iotsb(pbm);\r\nif (err) {\r\npr_err(PFX "Error creating ATU IOTSB\n");\r\nreturn err;\r\n}\r\ndma_mask = (roundup_pow_of_two(atu->size) - 1UL);\r\nnum_iotte = atu->size / IO_PAGE_SIZE;\r\nmap_size = num_iotte / 8;\r\natu->tbl.table_map_base = atu->base;\r\natu->dma_addr_mask = dma_mask;\r\natu->tbl.map = kzalloc(map_size, GFP_KERNEL);\r\nif (!atu->tbl.map)\r\nreturn -ENOMEM;\r\niommu_tbl_pool_init(&atu->tbl, num_iotte, IO_PAGE_SHIFT,\r\nNULL, false ,\r\n0 ,\r\nfalse );\r\nreturn 0;\r\n}\r\nstatic int pci_sun4v_iommu_init(struct pci_pbm_info *pbm)\r\n{\r\nstatic const u32 vdma_default[] = { 0x80000000, 0x80000000 };\r\nstruct iommu *iommu = pbm->iommu;\r\nunsigned long num_tsb_entries, sz;\r\nu32 dma_mask, dma_offset;\r\nconst u32 *vdma;\r\nvdma = of_get_property(pbm->op->dev.of_node, "virtual-dma", NULL);\r\nif (!vdma)\r\nvdma = vdma_default;\r\nif ((vdma[0] | vdma[1]) & ~IO_PAGE_MASK) {\r\nprintk(KERN_ERR PFX "Strange virtual-dma[%08x:%08x].\n",\r\nvdma[0], vdma[1]);\r\nreturn -EINVAL;\r\n}\r\ndma_mask = (roundup_pow_of_two(vdma[1]) - 1UL);\r\nnum_tsb_entries = vdma[1] / IO_PAGE_SIZE;\r\ndma_offset = vdma[0];\r\nspin_lock_init(&iommu->lock);\r\niommu->ctx_lowest_free = 1;\r\niommu->tbl.table_map_base = dma_offset;\r\niommu->dma_addr_mask = dma_mask;\r\nsz = (num_tsb_entries + 7) / 8;\r\nsz = (sz + 7UL) & ~7UL;\r\niommu->tbl.map = kzalloc(sz, GFP_KERNEL);\r\nif (!iommu->tbl.map) {\r\nprintk(KERN_ERR PFX "Error, kmalloc(arena.map) failed.\n");\r\nreturn -ENOMEM;\r\n}\r\niommu_tbl_pool_init(&iommu->tbl, num_tsb_entries, IO_PAGE_SHIFT,\r\nNULL, false ,\r\n0 ,\r\nfalse );\r\nsz = probe_existing_entries(pbm, &iommu->tbl);\r\nif (sz)\r\nprintk("%s: Imported %lu TSB entries from OBP\n",\r\npbm->name, sz);\r\nreturn 0;\r\n}\r\nstatic int pci_sun4v_get_head(struct pci_pbm_info *pbm, unsigned long msiqid,\r\nunsigned long *head)\r\n{\r\nunsigned long err, limit;\r\nerr = pci_sun4v_msiq_gethead(pbm->devhandle, msiqid, head);\r\nif (unlikely(err))\r\nreturn -ENXIO;\r\nlimit = pbm->msiq_ent_count * sizeof(struct pci_sun4v_msiq_entry);\r\nif (unlikely(*head >= limit))\r\nreturn -EFBIG;\r\nreturn 0;\r\n}\r\nstatic int pci_sun4v_dequeue_msi(struct pci_pbm_info *pbm,\r\nunsigned long msiqid, unsigned long *head,\r\nunsigned long *msi)\r\n{\r\nstruct pci_sun4v_msiq_entry *ep;\r\nunsigned long err, type;\r\nep = (pbm->msi_queues + ((msiqid - pbm->msiq_first) *\r\n(pbm->msiq_ent_count *\r\nsizeof(struct pci_sun4v_msiq_entry))) +\r\n*head);\r\nif ((ep->version_type & MSIQ_TYPE_MASK) == 0)\r\nreturn 0;\r\ntype = (ep->version_type & MSIQ_TYPE_MASK) >> MSIQ_TYPE_SHIFT;\r\nif (unlikely(type != MSIQ_TYPE_MSI32 &&\r\ntype != MSIQ_TYPE_MSI64))\r\nreturn -EINVAL;\r\n*msi = ep->msi_data;\r\nerr = pci_sun4v_msi_setstate(pbm->devhandle,\r\nep->msi_data ,\r\nHV_MSISTATE_IDLE);\r\nif (unlikely(err))\r\nreturn -ENXIO;\r\nep->version_type &= ~MSIQ_TYPE_MASK;\r\n(*head) += sizeof(struct pci_sun4v_msiq_entry);\r\nif (*head >=\r\n(pbm->msiq_ent_count * sizeof(struct pci_sun4v_msiq_entry)))\r\n*head = 0;\r\nreturn 1;\r\n}\r\nstatic int pci_sun4v_set_head(struct pci_pbm_info *pbm, unsigned long msiqid,\r\nunsigned long head)\r\n{\r\nunsigned long err;\r\nerr = pci_sun4v_msiq_sethead(pbm->devhandle, msiqid, head);\r\nif (unlikely(err))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int pci_sun4v_msi_setup(struct pci_pbm_info *pbm, unsigned long msiqid,\r\nunsigned long msi, int is_msi64)\r\n{\r\nif (pci_sun4v_msi_setmsiq(pbm->devhandle, msi, msiqid,\r\n(is_msi64 ?\r\nHV_MSITYPE_MSI64 : HV_MSITYPE_MSI32)))\r\nreturn -ENXIO;\r\nif (pci_sun4v_msi_setstate(pbm->devhandle, msi, HV_MSISTATE_IDLE))\r\nreturn -ENXIO;\r\nif (pci_sun4v_msi_setvalid(pbm->devhandle, msi, HV_MSIVALID_VALID))\r\nreturn -ENXIO;\r\nreturn 0;\r\n}\r\nstatic int pci_sun4v_msi_teardown(struct pci_pbm_info *pbm, unsigned long msi)\r\n{\r\nunsigned long err, msiqid;\r\nerr = pci_sun4v_msi_getmsiq(pbm->devhandle, msi, &msiqid);\r\nif (err)\r\nreturn -ENXIO;\r\npci_sun4v_msi_setvalid(pbm->devhandle, msi, HV_MSIVALID_INVALID);\r\nreturn 0;\r\n}\r\nstatic int pci_sun4v_msiq_alloc(struct pci_pbm_info *pbm)\r\n{\r\nunsigned long q_size, alloc_size, pages, order;\r\nint i;\r\nq_size = pbm->msiq_ent_count * sizeof(struct pci_sun4v_msiq_entry);\r\nalloc_size = (pbm->msiq_num * q_size);\r\norder = get_order(alloc_size);\r\npages = __get_free_pages(GFP_KERNEL | __GFP_COMP, order);\r\nif (pages == 0UL) {\r\nprintk(KERN_ERR "MSI: Cannot allocate MSI queues (o=%lu).\n",\r\norder);\r\nreturn -ENOMEM;\r\n}\r\nmemset((char *)pages, 0, PAGE_SIZE << order);\r\npbm->msi_queues = (void *) pages;\r\nfor (i = 0; i < pbm->msiq_num; i++) {\r\nunsigned long err, base = __pa(pages + (i * q_size));\r\nunsigned long ret1, ret2;\r\nerr = pci_sun4v_msiq_conf(pbm->devhandle,\r\npbm->msiq_first + i,\r\nbase, pbm->msiq_ent_count);\r\nif (err) {\r\nprintk(KERN_ERR "MSI: msiq register fails (err=%lu)\n",\r\nerr);\r\ngoto h_error;\r\n}\r\nerr = pci_sun4v_msiq_info(pbm->devhandle,\r\npbm->msiq_first + i,\r\n&ret1, &ret2);\r\nif (err) {\r\nprintk(KERN_ERR "MSI: Cannot read msiq (err=%lu)\n",\r\nerr);\r\ngoto h_error;\r\n}\r\nif (ret1 != base || ret2 != pbm->msiq_ent_count) {\r\nprintk(KERN_ERR "MSI: Bogus qconf "\r\n"expected[%lx:%x] got[%lx:%lx]\n",\r\nbase, pbm->msiq_ent_count,\r\nret1, ret2);\r\ngoto h_error;\r\n}\r\n}\r\nreturn 0;\r\nh_error:\r\nfree_pages(pages, order);\r\nreturn -EINVAL;\r\n}\r\nstatic void pci_sun4v_msiq_free(struct pci_pbm_info *pbm)\r\n{\r\nunsigned long q_size, alloc_size, pages, order;\r\nint i;\r\nfor (i = 0; i < pbm->msiq_num; i++) {\r\nunsigned long msiqid = pbm->msiq_first + i;\r\n(void) pci_sun4v_msiq_conf(pbm->devhandle, msiqid, 0UL, 0);\r\n}\r\nq_size = pbm->msiq_ent_count * sizeof(struct pci_sun4v_msiq_entry);\r\nalloc_size = (pbm->msiq_num * q_size);\r\norder = get_order(alloc_size);\r\npages = (unsigned long) pbm->msi_queues;\r\nfree_pages(pages, order);\r\npbm->msi_queues = NULL;\r\n}\r\nstatic int pci_sun4v_msiq_build_irq(struct pci_pbm_info *pbm,\r\nunsigned long msiqid,\r\nunsigned long devino)\r\n{\r\nunsigned int irq = sun4v_build_irq(pbm->devhandle, devino);\r\nif (!irq)\r\nreturn -ENOMEM;\r\nif (pci_sun4v_msiq_setvalid(pbm->devhandle, msiqid, HV_MSIQ_VALID))\r\nreturn -EINVAL;\r\nif (pci_sun4v_msiq_setstate(pbm->devhandle, msiqid, HV_MSIQSTATE_IDLE))\r\nreturn -EINVAL;\r\nreturn irq;\r\n}\r\nstatic void pci_sun4v_msi_init(struct pci_pbm_info *pbm)\r\n{\r\nsparc64_pbm_msi_init(pbm, &pci_sun4v_msiq_ops);\r\n}\r\nstatic void pci_sun4v_msi_init(struct pci_pbm_info *pbm)\r\n{\r\n}\r\nstatic int pci_sun4v_pbm_init(struct pci_pbm_info *pbm,\r\nstruct platform_device *op, u32 devhandle)\r\n{\r\nstruct device_node *dp = op->dev.of_node;\r\nint err;\r\npbm->numa_node = of_node_to_nid(dp);\r\npbm->pci_ops = &sun4v_pci_ops;\r\npbm->config_space_reg_bits = 12;\r\npbm->index = pci_num_pbms++;\r\npbm->op = op;\r\npbm->devhandle = devhandle;\r\npbm->name = dp->full_name;\r\nprintk("%s: SUN4V PCI Bus Module\n", pbm->name);\r\nprintk("%s: On NUMA node %d\n", pbm->name, pbm->numa_node);\r\npci_determine_mem_io_space(pbm);\r\npci_get_pbm_props(pbm);\r\nerr = pci_sun4v_iommu_init(pbm);\r\nif (err)\r\nreturn err;\r\npci_sun4v_msi_init(pbm);\r\npci_sun4v_scan_bus(pbm, &op->dev);\r\nif (pbm->iommu->atu) {\r\nerr = pci_sun4v_atu_init(pbm);\r\nif (err) {\r\nkfree(pbm->iommu->atu);\r\npbm->iommu->atu = NULL;\r\npr_err(PFX "ATU init failed, err=%d\n", err);\r\n}\r\n}\r\npbm->next = pci_pbm_root;\r\npci_pbm_root = pbm;\r\nreturn 0;\r\n}\r\nstatic int pci_sun4v_probe(struct platform_device *op)\r\n{\r\nconst struct linux_prom64_registers *regs;\r\nstatic int hvapi_negotiated = 0;\r\nstruct pci_pbm_info *pbm;\r\nstruct device_node *dp;\r\nstruct iommu *iommu;\r\nstruct atu *atu;\r\nu32 devhandle;\r\nint i, err = -ENODEV;\r\nstatic bool hv_atu = true;\r\ndp = op->dev.of_node;\r\nif (!hvapi_negotiated++) {\r\nfor (i = 0; i < ARRAY_SIZE(vpci_versions); i++) {\r\nvpci_major = vpci_versions[i].major;\r\nvpci_minor = vpci_versions[i].minor;\r\nerr = sun4v_hvapi_register(HV_GRP_PCI, vpci_major,\r\n&vpci_minor);\r\nif (!err)\r\nbreak;\r\n}\r\nif (err) {\r\npr_err(PFX "Could not register hvapi, err=%d\n", err);\r\nreturn err;\r\n}\r\npr_info(PFX "Registered hvapi major[%lu] minor[%lu]\n",\r\nvpci_major, vpci_minor);\r\nerr = sun4v_hvapi_register(HV_GRP_ATU, vatu_major, &vatu_minor);\r\nif (err) {\r\nhv_atu = false;\r\npr_err(PFX "Could not register hvapi ATU err=%d\n",\r\nerr);\r\n} else {\r\npr_info(PFX "Registered hvapi ATU major[%lu] minor[%lu]\n",\r\nvatu_major, vatu_minor);\r\n}\r\ndma_ops = &sun4v_dma_ops;\r\n}\r\nregs = of_get_property(dp, "reg", NULL);\r\nerr = -ENODEV;\r\nif (!regs) {\r\nprintk(KERN_ERR PFX "Could not find config registers\n");\r\ngoto out_err;\r\n}\r\ndevhandle = (regs->phys_addr >> 32UL) & 0x0fffffff;\r\nerr = -ENOMEM;\r\nif (!iommu_batch_initialized) {\r\nfor_each_possible_cpu(i) {\r\nunsigned long page = get_zeroed_page(GFP_KERNEL);\r\nif (!page)\r\ngoto out_err;\r\nper_cpu(iommu_batch, i).pglist = (u64 *) page;\r\n}\r\niommu_batch_initialized = 1;\r\n}\r\npbm = kzalloc(sizeof(*pbm), GFP_KERNEL);\r\nif (!pbm) {\r\nprintk(KERN_ERR PFX "Could not allocate pci_pbm_info\n");\r\ngoto out_err;\r\n}\r\niommu = kzalloc(sizeof(struct iommu), GFP_KERNEL);\r\nif (!iommu) {\r\nprintk(KERN_ERR PFX "Could not allocate pbm iommu\n");\r\ngoto out_free_controller;\r\n}\r\npbm->iommu = iommu;\r\niommu->atu = NULL;\r\nif (hv_atu) {\r\natu = kzalloc(sizeof(*atu), GFP_KERNEL);\r\nif (!atu)\r\npr_err(PFX "Could not allocate atu\n");\r\nelse\r\niommu->atu = atu;\r\n}\r\nerr = pci_sun4v_pbm_init(pbm, op, devhandle);\r\nif (err)\r\ngoto out_free_iommu;\r\ndev_set_drvdata(&op->dev, pbm);\r\nreturn 0;\r\nout_free_iommu:\r\nkfree(iommu->atu);\r\nkfree(pbm->iommu);\r\nout_free_controller:\r\nkfree(pbm);\r\nout_err:\r\nreturn err;\r\n}\r\nstatic int __init pci_sun4v_init(void)\r\n{\r\nreturn platform_driver_register(&pci_sun4v_driver);\r\n}
