static inline struct tegra_hsp *\r\nto_tegra_hsp(struct mbox_controller *mbox)\r\n{\r\nreturn container_of(mbox, struct tegra_hsp, mbox);\r\n}\r\nstatic inline u32 tegra_hsp_readl(struct tegra_hsp *hsp, unsigned int offset)\r\n{\r\nreturn readl(hsp->regs + offset);\r\n}\r\nstatic inline void tegra_hsp_writel(struct tegra_hsp *hsp, u32 value,\r\nunsigned int offset)\r\n{\r\nwritel(value, hsp->regs + offset);\r\n}\r\nstatic inline u32 tegra_hsp_channel_readl(struct tegra_hsp_channel *channel,\r\nunsigned int offset)\r\n{\r\nreturn readl(channel->regs + offset);\r\n}\r\nstatic inline void tegra_hsp_channel_writel(struct tegra_hsp_channel *channel,\r\nu32 value, unsigned int offset)\r\n{\r\nwritel(value, channel->regs + offset);\r\n}\r\nstatic bool tegra_hsp_doorbell_can_ring(struct tegra_hsp_doorbell *db)\r\n{\r\nu32 value;\r\nvalue = tegra_hsp_channel_readl(&db->channel, HSP_DB_ENABLE);\r\nreturn (value & BIT(TEGRA_HSP_DB_MASTER_CCPLEX)) != 0;\r\n}\r\nstatic struct tegra_hsp_doorbell *\r\n__tegra_hsp_doorbell_get(struct tegra_hsp *hsp, unsigned int master)\r\n{\r\nstruct tegra_hsp_doorbell *entry;\r\nlist_for_each_entry(entry, &hsp->doorbells, list)\r\nif (entry->master == master)\r\nreturn entry;\r\nreturn NULL;\r\n}\r\nstatic struct tegra_hsp_doorbell *\r\ntegra_hsp_doorbell_get(struct tegra_hsp *hsp, unsigned int master)\r\n{\r\nstruct tegra_hsp_doorbell *db;\r\nunsigned long flags;\r\nspin_lock_irqsave(&hsp->lock, flags);\r\ndb = __tegra_hsp_doorbell_get(hsp, master);\r\nspin_unlock_irqrestore(&hsp->lock, flags);\r\nreturn db;\r\n}\r\nstatic irqreturn_t tegra_hsp_doorbell_irq(int irq, void *data)\r\n{\r\nstruct tegra_hsp *hsp = data;\r\nstruct tegra_hsp_doorbell *db;\r\nunsigned long master, value;\r\ndb = tegra_hsp_doorbell_get(hsp, TEGRA_HSP_DB_MASTER_CCPLEX);\r\nif (!db)\r\nreturn IRQ_NONE;\r\nvalue = tegra_hsp_channel_readl(&db->channel, HSP_DB_PENDING);\r\ntegra_hsp_channel_writel(&db->channel, value, HSP_DB_PENDING);\r\nspin_lock(&hsp->lock);\r\nfor_each_set_bit(master, &value, hsp->mbox.num_chans) {\r\nstruct tegra_hsp_doorbell *db;\r\ndb = __tegra_hsp_doorbell_get(hsp, master);\r\nif (db && db->channel.chan)\r\nmbox_chan_received_data(db->channel.chan, NULL);\r\n}\r\nspin_unlock(&hsp->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic struct tegra_hsp_channel *\r\ntegra_hsp_doorbell_create(struct tegra_hsp *hsp, const char *name,\r\nunsigned int master, unsigned int index)\r\n{\r\nstruct tegra_hsp_doorbell *db;\r\nunsigned int offset;\r\nunsigned long flags;\r\ndb = kzalloc(sizeof(*db), GFP_KERNEL);\r\nif (!db)\r\nreturn ERR_PTR(-ENOMEM);\r\noffset = (1 + (hsp->num_sm / 2) + hsp->num_ss + hsp->num_as) << 16;\r\noffset += index * 0x100;\r\ndb->channel.regs = hsp->regs + offset;\r\ndb->channel.hsp = hsp;\r\ndb->name = kstrdup_const(name, GFP_KERNEL);\r\ndb->master = master;\r\ndb->index = index;\r\nspin_lock_irqsave(&hsp->lock, flags);\r\nlist_add_tail(&db->list, &hsp->doorbells);\r\nspin_unlock_irqrestore(&hsp->lock, flags);\r\nreturn &db->channel;\r\n}\r\nstatic void __tegra_hsp_doorbell_destroy(struct tegra_hsp_doorbell *db)\r\n{\r\nlist_del(&db->list);\r\nkfree_const(db->name);\r\nkfree(db);\r\n}\r\nstatic int tegra_hsp_doorbell_send_data(struct mbox_chan *chan, void *data)\r\n{\r\nstruct tegra_hsp_doorbell *db = chan->con_priv;\r\ntegra_hsp_channel_writel(&db->channel, 1, HSP_DB_TRIGGER);\r\nreturn 0;\r\n}\r\nstatic int tegra_hsp_doorbell_startup(struct mbox_chan *chan)\r\n{\r\nstruct tegra_hsp_doorbell *db = chan->con_priv;\r\nstruct tegra_hsp *hsp = db->channel.hsp;\r\nstruct tegra_hsp_doorbell *ccplex;\r\nunsigned long flags;\r\nu32 value;\r\nif (db->master >= hsp->mbox.num_chans) {\r\ndev_err(hsp->mbox.dev,\r\n"invalid master ID %u for HSP channel\n",\r\ndb->master);\r\nreturn -EINVAL;\r\n}\r\nccplex = tegra_hsp_doorbell_get(hsp, TEGRA_HSP_DB_MASTER_CCPLEX);\r\nif (!ccplex)\r\nreturn -ENODEV;\r\nif (!tegra_hsp_doorbell_can_ring(db))\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&hsp->lock, flags);\r\nvalue = tegra_hsp_channel_readl(&ccplex->channel, HSP_DB_ENABLE);\r\nvalue |= BIT(db->master);\r\ntegra_hsp_channel_writel(&ccplex->channel, value, HSP_DB_ENABLE);\r\nspin_unlock_irqrestore(&hsp->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void tegra_hsp_doorbell_shutdown(struct mbox_chan *chan)\r\n{\r\nstruct tegra_hsp_doorbell *db = chan->con_priv;\r\nstruct tegra_hsp *hsp = db->channel.hsp;\r\nstruct tegra_hsp_doorbell *ccplex;\r\nunsigned long flags;\r\nu32 value;\r\nccplex = tegra_hsp_doorbell_get(hsp, TEGRA_HSP_DB_MASTER_CCPLEX);\r\nif (!ccplex)\r\nreturn;\r\nspin_lock_irqsave(&hsp->lock, flags);\r\nvalue = tegra_hsp_channel_readl(&ccplex->channel, HSP_DB_ENABLE);\r\nvalue &= ~BIT(db->master);\r\ntegra_hsp_channel_writel(&ccplex->channel, value, HSP_DB_ENABLE);\r\nspin_unlock_irqrestore(&hsp->lock, flags);\r\n}\r\nstatic struct mbox_chan *of_tegra_hsp_xlate(struct mbox_controller *mbox,\r\nconst struct of_phandle_args *args)\r\n{\r\nstruct tegra_hsp_channel *channel = ERR_PTR(-ENODEV);\r\nstruct tegra_hsp *hsp = to_tegra_hsp(mbox);\r\nunsigned int type = args->args[0];\r\nunsigned int master = args->args[1];\r\nstruct tegra_hsp_doorbell *db;\r\nstruct mbox_chan *chan;\r\nunsigned long flags;\r\nunsigned int i;\r\nswitch (type) {\r\ncase TEGRA_HSP_MBOX_TYPE_DB:\r\ndb = tegra_hsp_doorbell_get(hsp, master);\r\nif (db)\r\nchannel = &db->channel;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (IS_ERR(channel))\r\nreturn ERR_CAST(channel);\r\nspin_lock_irqsave(&hsp->lock, flags);\r\nfor (i = 0; i < hsp->mbox.num_chans; i++) {\r\nchan = &hsp->mbox.chans[i];\r\nif (!chan->con_priv) {\r\nchan->con_priv = channel;\r\nchannel->chan = chan;\r\nbreak;\r\n}\r\nchan = NULL;\r\n}\r\nspin_unlock_irqrestore(&hsp->lock, flags);\r\nreturn chan ?: ERR_PTR(-EBUSY);\r\n}\r\nstatic void tegra_hsp_remove_doorbells(struct tegra_hsp *hsp)\r\n{\r\nstruct tegra_hsp_doorbell *db, *tmp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&hsp->lock, flags);\r\nlist_for_each_entry_safe(db, tmp, &hsp->doorbells, list)\r\n__tegra_hsp_doorbell_destroy(db);\r\nspin_unlock_irqrestore(&hsp->lock, flags);\r\n}\r\nstatic int tegra_hsp_add_doorbells(struct tegra_hsp *hsp)\r\n{\r\nconst struct tegra_hsp_db_map *map = hsp->soc->map;\r\nstruct tegra_hsp_channel *channel;\r\nwhile (map->name) {\r\nchannel = tegra_hsp_doorbell_create(hsp, map->name,\r\nmap->master, map->index);\r\nif (IS_ERR(channel)) {\r\ntegra_hsp_remove_doorbells(hsp);\r\nreturn PTR_ERR(channel);\r\n}\r\nmap++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tegra_hsp_probe(struct platform_device *pdev)\r\n{\r\nstruct tegra_hsp *hsp;\r\nstruct resource *res;\r\nu32 value;\r\nint err;\r\nhsp = devm_kzalloc(&pdev->dev, sizeof(*hsp), GFP_KERNEL);\r\nif (!hsp)\r\nreturn -ENOMEM;\r\nhsp->soc = of_device_get_match_data(&pdev->dev);\r\nINIT_LIST_HEAD(&hsp->doorbells);\r\nspin_lock_init(&hsp->lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nhsp->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(hsp->regs))\r\nreturn PTR_ERR(hsp->regs);\r\nvalue = tegra_hsp_readl(hsp, HSP_INT_DIMENSIONING);\r\nhsp->num_sm = (value >> HSP_nSM_SHIFT) & HSP_nINT_MASK;\r\nhsp->num_ss = (value >> HSP_nSS_SHIFT) & HSP_nINT_MASK;\r\nhsp->num_as = (value >> HSP_nAS_SHIFT) & HSP_nINT_MASK;\r\nhsp->num_db = (value >> HSP_nDB_SHIFT) & HSP_nINT_MASK;\r\nhsp->num_si = (value >> HSP_nSI_SHIFT) & HSP_nINT_MASK;\r\nerr = platform_get_irq_byname(pdev, "doorbell");\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to get doorbell IRQ: %d\n", err);\r\nreturn err;\r\n}\r\nhsp->irq = err;\r\nhsp->mbox.of_xlate = of_tegra_hsp_xlate;\r\nhsp->mbox.num_chans = 32;\r\nhsp->mbox.dev = &pdev->dev;\r\nhsp->mbox.txdone_irq = false;\r\nhsp->mbox.txdone_poll = false;\r\nhsp->mbox.ops = &tegra_hsp_doorbell_ops;\r\nhsp->mbox.chans = devm_kcalloc(&pdev->dev, hsp->mbox.num_chans,\r\nsizeof(*hsp->mbox.chans),\r\nGFP_KERNEL);\r\nif (!hsp->mbox.chans)\r\nreturn -ENOMEM;\r\nerr = tegra_hsp_add_doorbells(hsp);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to add doorbells: %d\n", err);\r\nreturn err;\r\n}\r\nplatform_set_drvdata(pdev, hsp);\r\nerr = mbox_controller_register(&hsp->mbox);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to register mailbox: %d\n", err);\r\ntegra_hsp_remove_doorbells(hsp);\r\nreturn err;\r\n}\r\nerr = devm_request_irq(&pdev->dev, hsp->irq, tegra_hsp_doorbell_irq,\r\nIRQF_NO_SUSPEND, dev_name(&pdev->dev), hsp);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to request IRQ#%u: %d\n",\r\nhsp->irq, err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tegra_hsp_remove(struct platform_device *pdev)\r\n{\r\nstruct tegra_hsp *hsp = platform_get_drvdata(pdev);\r\nmbox_controller_unregister(&hsp->mbox);\r\ntegra_hsp_remove_doorbells(hsp);\r\nreturn 0;\r\n}\r\nstatic int __init tegra_hsp_init(void)\r\n{\r\nreturn platform_driver_register(&tegra_hsp_driver);\r\n}
