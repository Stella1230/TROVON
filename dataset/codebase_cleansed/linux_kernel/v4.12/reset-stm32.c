static int stm32_reset_assert(struct reset_controller_dev *rcdev,\r\nunsigned long id)\r\n{\r\nstruct stm32_reset_data *data = container_of(rcdev,\r\nstruct stm32_reset_data,\r\nrcdev);\r\nint bank = id / BITS_PER_LONG;\r\nint offset = id % BITS_PER_LONG;\r\nunsigned long flags;\r\nu32 reg;\r\nspin_lock_irqsave(&data->lock, flags);\r\nreg = readl(data->membase + (bank * 4));\r\nwritel(reg | BIT(offset), data->membase + (bank * 4));\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int stm32_reset_deassert(struct reset_controller_dev *rcdev,\r\nunsigned long id)\r\n{\r\nstruct stm32_reset_data *data = container_of(rcdev,\r\nstruct stm32_reset_data,\r\nrcdev);\r\nint bank = id / BITS_PER_LONG;\r\nint offset = id % BITS_PER_LONG;\r\nunsigned long flags;\r\nu32 reg;\r\nspin_lock_irqsave(&data->lock, flags);\r\nreg = readl(data->membase + (bank * 4));\r\nwritel(reg & ~BIT(offset), data->membase + (bank * 4));\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int stm32_reset_probe(struct platform_device *pdev)\r\n{\r\nstruct stm32_reset_data *data;\r\nstruct resource *res;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndata->membase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(data->membase))\r\nreturn PTR_ERR(data->membase);\r\nspin_lock_init(&data->lock);\r\ndata->rcdev.owner = THIS_MODULE;\r\ndata->rcdev.nr_resets = resource_size(res) * 8;\r\ndata->rcdev.ops = &stm32_reset_ops;\r\ndata->rcdev.of_node = pdev->dev.of_node;\r\nreturn devm_reset_controller_register(&pdev->dev, &data->rcdev);\r\n}
