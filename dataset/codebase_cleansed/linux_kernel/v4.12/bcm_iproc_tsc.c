static void ts_reg_dump(struct iproc_ts_priv *priv)\r\n{\r\nstruct device *dev = &priv->pdev->dev;\r\ndbg_reg(dev, priv, REGCTL1);\r\ndbg_reg(dev, priv, REGCTL2);\r\ndbg_reg(dev, priv, INTERRUPT_THRES);\r\ndbg_reg(dev, priv, INTERRUPT_MASK);\r\ndbg_reg(dev, priv, INTERRUPT_STATUS);\r\ndbg_reg(dev, priv, CONTROLLER_STATUS);\r\ndbg_reg(dev, priv, FIFO_DATA);\r\ndbg_reg(dev, priv, ANALOG_CONTROL);\r\ndbg_reg(dev, priv, AUX_DATA);\r\ndbg_reg(dev, priv, DEBOUNCE_CNTR_STAT);\r\ndbg_reg(dev, priv, SCAN_CNTR_STAT);\r\ndbg_reg(dev, priv, REM_CNTR_STAT);\r\ndbg_reg(dev, priv, SETTLING_TIMER_STAT);\r\ndbg_reg(dev, priv, SPARE_REG);\r\ndbg_reg(dev, priv, SOFT_BYPASS_CONTROL);\r\ndbg_reg(dev, priv, SOFT_BYPASS_DATA);\r\n}\r\nstatic irqreturn_t iproc_touchscreen_interrupt(int irq, void *data)\r\n{\r\nstruct platform_device *pdev = data;\r\nstruct iproc_ts_priv *priv = platform_get_drvdata(pdev);\r\nu32 intr_status;\r\nu32 raw_coordinate;\r\nu16 x;\r\nu16 y;\r\nint i;\r\nbool needs_sync = false;\r\nregmap_read(priv->regmap, INTERRUPT_STATUS, &intr_status);\r\nintr_status &= TS_PEN_INTR_MASK | TS_FIFO_INTR_MASK;\r\nif (intr_status == 0)\r\nreturn IRQ_NONE;\r\nregmap_write(priv->regmap, INTERRUPT_STATUS, intr_status);\r\nif (intr_status & TS_PEN_INTR_MASK) {\r\nregmap_read(priv->regmap, CONTROLLER_STATUS, &priv->pen_status);\r\nif (priv->pen_status & TS_PEN_DOWN)\r\npriv->pen_status = PEN_DOWN_STATUS;\r\nelse\r\npriv->pen_status = PEN_UP_STATUS;\r\ninput_report_key(priv->idev, BTN_TOUCH, priv->pen_status);\r\nneeds_sync = true;\r\ndev_dbg(&priv->pdev->dev,\r\n"pen up-down (%d)\n", priv->pen_status);\r\n}\r\nif (intr_status & TS_FIFO_INTR_MASK) {\r\nfor (i = 0; i < priv->cfg_params.fifo_threshold; i++) {\r\nregmap_read(priv->regmap, FIFO_DATA, &raw_coordinate);\r\nif (raw_coordinate == INVALID_COORD)\r\ncontinue;\r\nx = (raw_coordinate >> X_COORD_SHIFT) &\r\nFIFO_DATA_X_Y_MASK;\r\ny = (raw_coordinate >> Y_COORD_SHIFT) &\r\nFIFO_DATA_X_Y_MASK;\r\nx = (x >> 4) & 0x0FFF;\r\ny = (y >> 4) & 0x0FFF;\r\nif (priv->cfg_params.invert_x)\r\nx = priv->cfg_params.max_x - x;\r\nif (priv->cfg_params.invert_y)\r\ny = priv->cfg_params.max_y - y;\r\ninput_report_abs(priv->idev, ABS_X, x);\r\ninput_report_abs(priv->idev, ABS_Y, y);\r\nneeds_sync = true;\r\ndev_dbg(&priv->pdev->dev, "xy (0x%x 0x%x)\n", x, y);\r\n}\r\n}\r\nif (needs_sync)\r\ninput_sync(priv->idev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int iproc_ts_start(struct input_dev *idev)\r\n{\r\nu32 val;\r\nu32 mask;\r\nint error;\r\nstruct iproc_ts_priv *priv = input_get_drvdata(idev);\r\nerror = clk_prepare_enable(priv->tsc_clk);\r\nif (error) {\r\ndev_err(&priv->pdev->dev, "%s clk_prepare_enable failed %d\n",\r\n__func__, error);\r\nreturn error;\r\n}\r\nval = TS_PEN_INTR_MASK | TS_FIFO_INTR_MASK;\r\nregmap_update_bits(priv->regmap, INTERRUPT_MASK, val, val);\r\nval = priv->cfg_params.fifo_threshold;\r\nregmap_write(priv->regmap, INTERRUPT_THRES, val);\r\nval = 0;\r\nval |= priv->cfg_params.scanning_period << SCANNING_PERIOD_SHIFT;\r\nval |= priv->cfg_params.debounce_timeout << DEBOUNCE_TIMEOUT_SHIFT;\r\nval |= priv->cfg_params.settling_timeout << SETTLING_TIMEOUT_SHIFT;\r\nval |= priv->cfg_params.touch_timeout << TOUCH_TIMEOUT_SHIFT;\r\nregmap_write(priv->regmap, REGCTL1, val);\r\nval = TS_FIFO_INTR_MASK | TS_PEN_INTR_MASK;\r\nregmap_update_bits(priv->regmap, INTERRUPT_STATUS, val, val);\r\nval = TS_CONTROLLER_EN_BIT | TS_WIRE_MODE_BIT;\r\nval |= priv->cfg_params.average_data << TS_CONTROLLER_AVGDATA_SHIFT;\r\nmask = (TS_CONTROLLER_AVGDATA_MASK);\r\nmask |= (TS_CONTROLLER_PWR_LDO |\r\nTS_CONTROLLER_PWR_ADC |\r\nTS_CONTROLLER_PWR_BGP |\r\nTS_CONTROLLER_PWR_TS);\r\nmask |= val;\r\nregmap_update_bits(priv->regmap, REGCTL2, mask, val);\r\nts_reg_dump(priv);\r\nreturn 0;\r\n}\r\nstatic void iproc_ts_stop(struct input_dev *dev)\r\n{\r\nu32 val;\r\nstruct iproc_ts_priv *priv = input_get_drvdata(dev);\r\nval = TS_PEN_INTR_MASK | TS_FIFO_INTR_MASK;\r\nregmap_update_bits(priv->regmap, INTERRUPT_MASK, val, 0);\r\nval = TS_CONTROLLER_PWR_TS;\r\nregmap_update_bits(priv->regmap, REGCTL2, val, val);\r\nclk_disable(priv->tsc_clk);\r\n}\r\nstatic int iproc_get_tsc_config(struct device *dev, struct iproc_ts_priv *priv)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nu32 val;\r\npriv->cfg_params = iproc_default_config;\r\nif (!np)\r\nreturn 0;\r\nif (of_property_read_u32(np, "scanning_period", &val) >= 0) {\r\nif (val < 1 || val > 256) {\r\ndev_err(dev, "scanning_period (%u) must be [1-256]\n",\r\nval);\r\nreturn -EINVAL;\r\n}\r\npriv->cfg_params.scanning_period = val;\r\n}\r\nif (of_property_read_u32(np, "debounce_timeout", &val) >= 0) {\r\nif (val > 255) {\r\ndev_err(dev, "debounce_timeout (%u) must be [0-255]\n",\r\nval);\r\nreturn -EINVAL;\r\n}\r\npriv->cfg_params.debounce_timeout = val;\r\n}\r\nif (of_property_read_u32(np, "settling_timeout", &val) >= 0) {\r\nif (val > 11) {\r\ndev_err(dev, "settling_timeout (%u) must be [0-11]\n",\r\nval);\r\nreturn -EINVAL;\r\n}\r\npriv->cfg_params.settling_timeout = val;\r\n}\r\nif (of_property_read_u32(np, "touch_timeout", &val) >= 0) {\r\nif (val > 255) {\r\ndev_err(dev, "touch_timeout (%u) must be [0-255]\n",\r\nval);\r\nreturn -EINVAL;\r\n}\r\npriv->cfg_params.touch_timeout = val;\r\n}\r\nif (of_property_read_u32(np, "average_data", &val) >= 0) {\r\nif (val > 8) {\r\ndev_err(dev, "average_data (%u) must be [0-8]\n", val);\r\nreturn -EINVAL;\r\n}\r\npriv->cfg_params.average_data = val;\r\n}\r\nif (of_property_read_u32(np, "fifo_threshold", &val) >= 0) {\r\nif (val > 31) {\r\ndev_err(dev, "fifo_threshold (%u)) must be [0-31]\n",\r\nval);\r\nreturn -EINVAL;\r\n}\r\npriv->cfg_params.fifo_threshold = val;\r\n}\r\nof_property_read_u32(np, "touchscreen-size-x", &priv->cfg_params.max_x);\r\nof_property_read_u32(np, "touchscreen-size-y", &priv->cfg_params.max_y);\r\nof_property_read_u32(np, "touchscreen-fuzz-x",\r\n&priv->cfg_params.fuzz_x);\r\nof_property_read_u32(np, "touchscreen-fuzz-y",\r\n&priv->cfg_params.fuzz_y);\r\npriv->cfg_params.invert_x =\r\nof_property_read_bool(np, "touchscreen-inverted-x");\r\npriv->cfg_params.invert_y =\r\nof_property_read_bool(np, "touchscreen-inverted-y");\r\nreturn 0;\r\n}\r\nstatic int iproc_ts_probe(struct platform_device *pdev)\r\n{\r\nstruct iproc_ts_priv *priv;\r\nstruct input_dev *idev;\r\nint irq;\r\nint error;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->regmap = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\r\n"ts_syscon");\r\nif (IS_ERR(priv->regmap)) {\r\nerror = PTR_ERR(priv->regmap);\r\ndev_err(&pdev->dev, "unable to map I/O memory:%d\n", error);\r\nreturn error;\r\n}\r\npriv->tsc_clk = devm_clk_get(&pdev->dev, "tsc_clk");\r\nif (IS_ERR(priv->tsc_clk)) {\r\nerror = PTR_ERR(priv->tsc_clk);\r\ndev_err(&pdev->dev,\r\n"failed getting clock tsc_clk: %d\n", error);\r\nreturn error;\r\n}\r\npriv->pdev = pdev;\r\nerror = iproc_get_tsc_config(&pdev->dev, priv);\r\nif (error) {\r\ndev_err(&pdev->dev, "get_tsc_config failed: %d\n", error);\r\nreturn error;\r\n}\r\nidev = devm_input_allocate_device(&pdev->dev);\r\nif (!idev) {\r\ndev_err(&pdev->dev, "failed to allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\npriv->idev = idev;\r\npriv->pen_status = PEN_UP_STATUS;\r\nidev->name = IPROC_TS_NAME;\r\nidev->dev.parent = &pdev->dev;\r\nidev->id.bustype = BUS_HOST;\r\nidev->id.vendor = SERIO_UNKNOWN;\r\nidev->id.product = 0;\r\nidev->id.version = 0;\r\nidev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\n__set_bit(BTN_TOUCH, idev->keybit);\r\ninput_set_abs_params(idev, ABS_X, X_MIN, priv->cfg_params.max_x,\r\npriv->cfg_params.fuzz_x, 0);\r\ninput_set_abs_params(idev, ABS_Y, Y_MIN, priv->cfg_params.max_y,\r\npriv->cfg_params.fuzz_y, 0);\r\nidev->open = iproc_ts_start;\r\nidev->close = iproc_ts_stop;\r\ninput_set_drvdata(idev, priv);\r\nplatform_set_drvdata(pdev, priv);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "platform_get_irq failed: %d\n", irq);\r\nreturn irq;\r\n}\r\nerror = devm_request_irq(&pdev->dev, irq,\r\niproc_touchscreen_interrupt,\r\nIRQF_SHARED, IPROC_TS_NAME, pdev);\r\nif (error)\r\nreturn error;\r\nerror = input_register_device(priv->idev);\r\nif (error) {\r\ndev_err(&pdev->dev,\r\n"failed to register input device: %d\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}
