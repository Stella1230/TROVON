static unsigned long sun6i_rtc_osc_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct sun6i_rtc_dev *rtc = container_of(hw, struct sun6i_rtc_dev, hw);\r\nu32 val;\r\nval = readl(rtc->base + SUN6I_LOSC_CTRL);\r\nif (val & SUN6I_LOSC_CTRL_EXT_OSC)\r\nreturn parent_rate;\r\nval = readl(rtc->base + SUN6I_LOSC_CLK_PRESCAL);\r\nval &= GENMASK(4, 0);\r\nreturn parent_rate / (val + 1);\r\n}\r\nstatic u8 sun6i_rtc_osc_get_parent(struct clk_hw *hw)\r\n{\r\nstruct sun6i_rtc_dev *rtc = container_of(hw, struct sun6i_rtc_dev, hw);\r\nreturn readl(rtc->base + SUN6I_LOSC_CTRL) & SUN6I_LOSC_CTRL_EXT_OSC;\r\n}\r\nstatic int sun6i_rtc_osc_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct sun6i_rtc_dev *rtc = container_of(hw, struct sun6i_rtc_dev, hw);\r\nunsigned long flags;\r\nu32 val;\r\nif (index > 1)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&rtc->lock, flags);\r\nval = readl(rtc->base + SUN6I_LOSC_CTRL);\r\nval &= ~SUN6I_LOSC_CTRL_EXT_OSC;\r\nval |= SUN6I_LOSC_CTRL_KEY;\r\nval |= index ? SUN6I_LOSC_CTRL_EXT_OSC : 0;\r\nwritel(val, rtc->base + SUN6I_LOSC_CTRL);\r\nspin_unlock_irqrestore(&rtc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void __init sun6i_rtc_clk_init(struct device_node *node)\r\n{\r\nstruct clk_hw_onecell_data *clk_data;\r\nstruct sun6i_rtc_dev *rtc;\r\nstruct clk_init_data init = {\r\n.ops = &sun6i_rtc_osc_ops,\r\n};\r\nconst char *parents[2];\r\nrtc = kzalloc(sizeof(*rtc), GFP_KERNEL);\r\nif (!rtc)\r\nreturn;\r\nspin_lock_init(&rtc->lock);\r\nclk_data = kzalloc(sizeof(*clk_data) + sizeof(*clk_data->hws),\r\nGFP_KERNEL);\r\nif (!clk_data)\r\nreturn;\r\nspin_lock_init(&rtc->lock);\r\nrtc->base = of_io_request_and_map(node, 0, of_node_full_name(node));\r\nif (IS_ERR(rtc->base)) {\r\npr_crit("Can't map RTC registers");\r\nreturn;\r\n}\r\nwritel(SUN6I_LOSC_CTRL_KEY | SUN6I_LOSC_CTRL_EXT_OSC,\r\nrtc->base + SUN6I_LOSC_CTRL);\r\nsun6i_rtc = rtc;\r\nif (!of_get_property(node, "clocks", NULL))\r\nreturn;\r\nrtc->int_osc = clk_hw_register_fixed_rate_with_accuracy(NULL,\r\n"rtc-int-osc",\r\nNULL, 0,\r\n667000,\r\n300000000);\r\nif (IS_ERR(rtc->int_osc)) {\r\npr_crit("Couldn't register the internal oscillator\n");\r\nreturn;\r\n}\r\nparents[0] = clk_hw_get_name(rtc->int_osc);\r\nparents[1] = of_clk_get_parent_name(node, 0);\r\nrtc->hw.init = &init;\r\ninit.parent_names = parents;\r\ninit.num_parents = of_clk_get_parent_count(node) + 1;\r\nof_property_read_string(node, "clock-output-names", &init.name);\r\nrtc->losc = clk_register(NULL, &rtc->hw);\r\nif (IS_ERR(rtc->losc)) {\r\npr_crit("Couldn't register the LOSC clock\n");\r\nreturn;\r\n}\r\nclk_data->num = 1;\r\nclk_data->hws[0] = &rtc->hw;\r\nof_clk_add_hw_provider(node, of_clk_hw_onecell_get, clk_data);\r\n}\r\nstatic irqreturn_t sun6i_rtc_alarmirq(int irq, void *id)\r\n{\r\nstruct sun6i_rtc_dev *chip = (struct sun6i_rtc_dev *) id;\r\nirqreturn_t ret = IRQ_NONE;\r\nu32 val;\r\nspin_lock(&chip->lock);\r\nval = readl(chip->base + SUN6I_ALRM_IRQ_STA);\r\nif (val & SUN6I_ALRM_IRQ_STA_CNT_IRQ_PEND) {\r\nval |= SUN6I_ALRM_IRQ_STA_CNT_IRQ_PEND;\r\nwritel(val, chip->base + SUN6I_ALRM_IRQ_STA);\r\nrtc_update_irq(chip->rtc, 1, RTC_AF | RTC_IRQF);\r\nret = IRQ_HANDLED;\r\n}\r\nspin_unlock(&chip->lock);\r\nreturn ret;\r\n}\r\nstatic void sun6i_rtc_setaie(int to, struct sun6i_rtc_dev *chip)\r\n{\r\nu32 alrm_val = 0;\r\nu32 alrm_irq_val = 0;\r\nu32 alrm_wake_val = 0;\r\nunsigned long flags;\r\nif (to) {\r\nalrm_val = SUN6I_ALRM_EN_CNT_EN;\r\nalrm_irq_val = SUN6I_ALRM_IRQ_EN_CNT_IRQ_EN;\r\nalrm_wake_val = SUN6I_ALARM_CONFIG_WAKEUP;\r\n} else {\r\nwritel(SUN6I_ALRM_IRQ_STA_CNT_IRQ_PEND,\r\nchip->base + SUN6I_ALRM_IRQ_STA);\r\n}\r\nspin_lock_irqsave(&chip->lock, flags);\r\nwritel(alrm_val, chip->base + SUN6I_ALRM_EN);\r\nwritel(alrm_irq_val, chip->base + SUN6I_ALRM_IRQ_EN);\r\nwritel(alrm_wake_val, chip->base + SUN6I_ALARM_CONFIG);\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\n}\r\nstatic int sun6i_rtc_gettime(struct device *dev, struct rtc_time *rtc_tm)\r\n{\r\nstruct sun6i_rtc_dev *chip = dev_get_drvdata(dev);\r\nu32 date, time;\r\ndo {\r\ndate = readl(chip->base + SUN6I_RTC_YMD);\r\ntime = readl(chip->base + SUN6I_RTC_HMS);\r\n} while ((date != readl(chip->base + SUN6I_RTC_YMD)) ||\r\n(time != readl(chip->base + SUN6I_RTC_HMS)));\r\nrtc_tm->tm_sec = SUN6I_TIME_GET_SEC_VALUE(time);\r\nrtc_tm->tm_min = SUN6I_TIME_GET_MIN_VALUE(time);\r\nrtc_tm->tm_hour = SUN6I_TIME_GET_HOUR_VALUE(time);\r\nrtc_tm->tm_mday = SUN6I_DATE_GET_DAY_VALUE(date);\r\nrtc_tm->tm_mon = SUN6I_DATE_GET_MON_VALUE(date);\r\nrtc_tm->tm_year = SUN6I_DATE_GET_YEAR_VALUE(date);\r\nrtc_tm->tm_mon -= 1;\r\nrtc_tm->tm_year += SUN6I_YEAR_OFF;\r\nreturn rtc_valid_tm(rtc_tm);\r\n}\r\nstatic int sun6i_rtc_getalarm(struct device *dev, struct rtc_wkalrm *wkalrm)\r\n{\r\nstruct sun6i_rtc_dev *chip = dev_get_drvdata(dev);\r\nunsigned long flags;\r\nu32 alrm_st;\r\nu32 alrm_en;\r\nspin_lock_irqsave(&chip->lock, flags);\r\nalrm_en = readl(chip->base + SUN6I_ALRM_IRQ_EN);\r\nalrm_st = readl(chip->base + SUN6I_ALRM_IRQ_STA);\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nwkalrm->enabled = !!(alrm_en & SUN6I_ALRM_EN_CNT_EN);\r\nwkalrm->pending = !!(alrm_st & SUN6I_ALRM_EN_CNT_EN);\r\nrtc_time_to_tm(chip->alarm, &wkalrm->time);\r\nreturn 0;\r\n}\r\nstatic int sun6i_rtc_setalarm(struct device *dev, struct rtc_wkalrm *wkalrm)\r\n{\r\nstruct sun6i_rtc_dev *chip = dev_get_drvdata(dev);\r\nstruct rtc_time *alrm_tm = &wkalrm->time;\r\nstruct rtc_time tm_now;\r\nunsigned long time_now = 0;\r\nunsigned long time_set = 0;\r\nunsigned long time_gap = 0;\r\nint ret = 0;\r\nret = sun6i_rtc_gettime(dev, &tm_now);\r\nif (ret < 0) {\r\ndev_err(dev, "Error in getting time\n");\r\nreturn -EINVAL;\r\n}\r\nrtc_tm_to_time(alrm_tm, &time_set);\r\nrtc_tm_to_time(&tm_now, &time_now);\r\nif (time_set <= time_now) {\r\ndev_err(dev, "Date to set in the past\n");\r\nreturn -EINVAL;\r\n}\r\ntime_gap = time_set - time_now;\r\nif (time_gap > U32_MAX) {\r\ndev_err(dev, "Date too far in the future\n");\r\nreturn -EINVAL;\r\n}\r\nsun6i_rtc_setaie(0, chip);\r\nwritel(0, chip->base + SUN6I_ALRM_COUNTER);\r\nusleep_range(100, 300);\r\nwritel(time_gap, chip->base + SUN6I_ALRM_COUNTER);\r\nchip->alarm = time_set;\r\nsun6i_rtc_setaie(wkalrm->enabled, chip);\r\nreturn 0;\r\n}\r\nstatic int sun6i_rtc_wait(struct sun6i_rtc_dev *chip, int offset,\r\nunsigned int mask, unsigned int ms_timeout)\r\n{\r\nconst unsigned long timeout = jiffies + msecs_to_jiffies(ms_timeout);\r\nu32 reg;\r\ndo {\r\nreg = readl(chip->base + offset);\r\nreg &= mask;\r\nif (!reg)\r\nreturn 0;\r\n} while (time_before(jiffies, timeout));\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int sun6i_rtc_settime(struct device *dev, struct rtc_time *rtc_tm)\r\n{\r\nstruct sun6i_rtc_dev *chip = dev_get_drvdata(dev);\r\nu32 date = 0;\r\nu32 time = 0;\r\nint year;\r\nyear = rtc_tm->tm_year + 1900;\r\nif (year < SUN6I_YEAR_MIN || year > SUN6I_YEAR_MAX) {\r\ndev_err(dev, "rtc only supports year in range %d - %d\n",\r\nSUN6I_YEAR_MIN, SUN6I_YEAR_MAX);\r\nreturn -EINVAL;\r\n}\r\nrtc_tm->tm_year -= SUN6I_YEAR_OFF;\r\nrtc_tm->tm_mon += 1;\r\ndate = SUN6I_DATE_SET_DAY_VALUE(rtc_tm->tm_mday) |\r\nSUN6I_DATE_SET_MON_VALUE(rtc_tm->tm_mon) |\r\nSUN6I_DATE_SET_YEAR_VALUE(rtc_tm->tm_year);\r\nif (is_leap_year(year))\r\ndate |= SUN6I_LEAP_SET_VALUE(1);\r\ntime = SUN6I_TIME_SET_SEC_VALUE(rtc_tm->tm_sec) |\r\nSUN6I_TIME_SET_MIN_VALUE(rtc_tm->tm_min) |\r\nSUN6I_TIME_SET_HOUR_VALUE(rtc_tm->tm_hour);\r\nif (sun6i_rtc_wait(chip, SUN6I_LOSC_CTRL,\r\nSUN6I_LOSC_CTRL_ACC_MASK, 50)) {\r\ndev_err(dev, "rtc is still busy.\n");\r\nreturn -EBUSY;\r\n}\r\nwritel(time, chip->base + SUN6I_RTC_HMS);\r\nif (sun6i_rtc_wait(chip, SUN6I_LOSC_CTRL,\r\nSUN6I_LOSC_CTRL_RTC_HMS_ACC, 50)) {\r\ndev_err(dev, "Failed to set rtc time.\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nwritel(date, chip->base + SUN6I_RTC_YMD);\r\nif (sun6i_rtc_wait(chip, SUN6I_LOSC_CTRL,\r\nSUN6I_LOSC_CTRL_RTC_YMD_ACC, 50)) {\r\ndev_err(dev, "Failed to set rtc time.\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sun6i_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct sun6i_rtc_dev *chip = dev_get_drvdata(dev);\r\nif (!enabled)\r\nsun6i_rtc_setaie(enabled, chip);\r\nreturn 0;\r\n}\r\nstatic int sun6i_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct sun6i_rtc_dev *chip = sun6i_rtc;\r\nint ret;\r\nif (!chip)\r\nreturn -ENODEV;\r\nplatform_set_drvdata(pdev, chip);\r\nchip->dev = &pdev->dev;\r\nchip->irq = platform_get_irq(pdev, 0);\r\nif (chip->irq < 0) {\r\ndev_err(&pdev->dev, "No IRQ resource\n");\r\nreturn chip->irq;\r\n}\r\nret = devm_request_irq(&pdev->dev, chip->irq, sun6i_rtc_alarmirq,\r\n0, dev_name(&pdev->dev), chip);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Could not request IRQ\n");\r\nreturn ret;\r\n}\r\nwritel(0, chip->base + SUN6I_ALRM_COUNTER);\r\nwritel(0, chip->base + SUN6I_ALRM_EN);\r\nwritel(0, chip->base + SUN6I_ALRM_IRQ_EN);\r\nwritel(0, chip->base + SUN6I_ALRM1_EN);\r\nwritel(0, chip->base + SUN6I_ALRM1_IRQ_EN);\r\nwritel(SUN6I_ALRM_IRQ_STA_CNT_IRQ_PEND,\r\nchip->base + SUN6I_ALRM_IRQ_STA);\r\nwritel(SUN6I_ALRM1_IRQ_STA_WEEK_IRQ_PEND,\r\nchip->base + SUN6I_ALRM1_IRQ_STA);\r\nwritel(0, chip->base + SUN6I_ALARM_CONFIG);\r\nclk_prepare_enable(chip->losc);\r\nchip->rtc = devm_rtc_device_register(&pdev->dev, "rtc-sun6i",\r\n&sun6i_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(chip->rtc)) {\r\ndev_err(&pdev->dev, "unable to register device\n");\r\nreturn PTR_ERR(chip->rtc);\r\n}\r\ndev_info(&pdev->dev, "RTC enabled\n");\r\nreturn 0;\r\n}
