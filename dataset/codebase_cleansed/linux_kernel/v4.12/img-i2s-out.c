static int img_i2s_out_suspend(struct device *dev)\r\n{\r\nstruct img_i2s_out *i2s = dev_get_drvdata(dev);\r\nif (!i2s->force_clk_active)\r\nclk_disable_unprepare(i2s->clk_ref);\r\nreturn 0;\r\n}\r\nstatic int img_i2s_out_resume(struct device *dev)\r\n{\r\nstruct img_i2s_out *i2s = dev_get_drvdata(dev);\r\nint ret;\r\nif (!i2s->force_clk_active) {\r\nret = clk_prepare_enable(i2s->clk_ref);\r\nif (ret) {\r\ndev_err(dev, "clk_enable failed: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void img_i2s_out_writel(struct img_i2s_out *i2s, u32 val,\r\nu32 reg)\r\n{\r\nwritel(val, i2s->base + reg);\r\n}\r\nstatic inline u32 img_i2s_out_readl(struct img_i2s_out *i2s, u32 reg)\r\n{\r\nreturn readl(i2s->base + reg);\r\n}\r\nstatic inline void img_i2s_out_ch_writel(struct img_i2s_out *i2s,\r\nu32 chan, u32 val, u32 reg)\r\n{\r\nwritel(val, i2s->channel_base + (chan * IMG_I2S_OUT_CH_STRIDE) + reg);\r\n}\r\nstatic inline u32 img_i2s_out_ch_readl(struct img_i2s_out *i2s, u32 chan,\r\nu32 reg)\r\n{\r\nreturn readl(i2s->channel_base + (chan * IMG_I2S_OUT_CH_STRIDE) + reg);\r\n}\r\nstatic inline void img_i2s_out_ch_disable(struct img_i2s_out *i2s, u32 chan)\r\n{\r\nu32 reg;\r\nreg = img_i2s_out_ch_readl(i2s, chan, IMG_I2S_OUT_CH_CTL);\r\nreg &= ~IMG_I2S_OUT_CHAN_CTL_ME_MASK;\r\nimg_i2s_out_ch_writel(i2s, chan, reg, IMG_I2S_OUT_CH_CTL);\r\n}\r\nstatic inline void img_i2s_out_ch_enable(struct img_i2s_out *i2s, u32 chan)\r\n{\r\nu32 reg;\r\nreg = img_i2s_out_ch_readl(i2s, chan, IMG_I2S_OUT_CH_CTL);\r\nreg |= IMG_I2S_OUT_CHAN_CTL_ME_MASK;\r\nimg_i2s_out_ch_writel(i2s, chan, reg, IMG_I2S_OUT_CH_CTL);\r\n}\r\nstatic inline void img_i2s_out_disable(struct img_i2s_out *i2s)\r\n{\r\nu32 reg;\r\nreg = img_i2s_out_readl(i2s, IMG_I2S_OUT_CTL);\r\nreg &= ~IMG_I2S_OUT_CTL_ME_MASK;\r\nimg_i2s_out_writel(i2s, reg, IMG_I2S_OUT_CTL);\r\n}\r\nstatic inline void img_i2s_out_enable(struct img_i2s_out *i2s)\r\n{\r\nu32 reg;\r\nreg = img_i2s_out_readl(i2s, IMG_I2S_OUT_CTL);\r\nreg |= IMG_I2S_OUT_CTL_ME_MASK;\r\nimg_i2s_out_writel(i2s, reg, IMG_I2S_OUT_CTL);\r\n}\r\nstatic void img_i2s_out_reset(struct img_i2s_out *i2s)\r\n{\r\nint i;\r\nu32 core_ctl, chan_ctl;\r\ncore_ctl = img_i2s_out_readl(i2s, IMG_I2S_OUT_CTL) &\r\n~IMG_I2S_OUT_CTL_ME_MASK &\r\n~IMG_I2S_OUT_CTL_DATA_EN_MASK;\r\nif (!i2s->force_clk_active)\r\ncore_ctl &= ~IMG_I2S_OUT_CTL_CLK_EN_MASK;\r\nchan_ctl = img_i2s_out_ch_readl(i2s, 0, IMG_I2S_OUT_CH_CTL) &\r\n~IMG_I2S_OUT_CHAN_CTL_ME_MASK;\r\nreset_control_assert(i2s->rst);\r\nreset_control_deassert(i2s->rst);\r\nfor (i = 0; i < i2s->max_i2s_chan; i++)\r\nimg_i2s_out_ch_writel(i2s, i, chan_ctl, IMG_I2S_OUT_CH_CTL);\r\nfor (i = 0; i < i2s->active_channels; i++)\r\nimg_i2s_out_ch_enable(i2s, i);\r\nimg_i2s_out_writel(i2s, core_ctl, IMG_I2S_OUT_CTL);\r\nimg_i2s_out_enable(i2s);\r\n}\r\nstatic int img_i2s_out_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct img_i2s_out *i2s = snd_soc_dai_get_drvdata(dai);\r\nu32 reg;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nreg = img_i2s_out_readl(i2s, IMG_I2S_OUT_CTL);\r\nif (!i2s->force_clk_active)\r\nreg |= IMG_I2S_OUT_CTL_CLK_EN_MASK;\r\nreg |= IMG_I2S_OUT_CTL_DATA_EN_MASK;\r\nimg_i2s_out_writel(i2s, reg, IMG_I2S_OUT_CTL);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nimg_i2s_out_reset(i2s);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int img_i2s_out_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\r\n{\r\nstruct img_i2s_out *i2s = snd_soc_dai_get_drvdata(dai);\r\nunsigned int channels, i2s_channels;\r\nlong pre_div_a, pre_div_b, diff_a, diff_b, rate, clk_rate;\r\nint i;\r\nu32 reg, control_mask, control_set = 0;\r\nsnd_pcm_format_t format;\r\nrate = params_rate(params);\r\nformat = params_format(params);\r\nchannels = params_channels(params);\r\ni2s_channels = channels / 2;\r\nif (format != SNDRV_PCM_FORMAT_S32_LE)\r\nreturn -EINVAL;\r\nif ((channels < 2) ||\r\n(channels > (i2s->max_i2s_chan * 2)) ||\r\n(channels % 2))\r\nreturn -EINVAL;\r\npre_div_a = clk_round_rate(i2s->clk_ref, rate * 256);\r\nif (pre_div_a < 0)\r\nreturn pre_div_a;\r\npre_div_b = clk_round_rate(i2s->clk_ref, rate * 384);\r\nif (pre_div_b < 0)\r\nreturn pre_div_b;\r\ndiff_a = abs((pre_div_a / 256) - rate);\r\ndiff_b = abs((pre_div_b / 384) - rate);\r\nif (diff_a > diff_b)\r\nclk_set_rate(i2s->clk_ref, pre_div_b);\r\nelse\r\nclk_set_rate(i2s->clk_ref, pre_div_a);\r\nclk_rate = clk_get_rate(i2s->clk_ref);\r\ndiff_a = abs((clk_rate / 256) - rate);\r\ndiff_b = abs((clk_rate / 384) - rate);\r\nif (diff_a > diff_b)\r\ncontrol_set |= IMG_I2S_OUT_CTL_CLK_MASK;\r\ncontrol_set |= ((i2s_channels - 1) <<\r\nIMG_I2S_OUT_CTL_ACTIVE_CHAN_SHIFT) &\r\nIMG_I2S_OUT_CTL_ACTIVE_CHAN_MASK;\r\ncontrol_mask = IMG_I2S_OUT_CTL_CLK_MASK |\r\nIMG_I2S_OUT_CTL_ACTIVE_CHAN_MASK;\r\nimg_i2s_out_disable(i2s);\r\nreg = img_i2s_out_readl(i2s, IMG_I2S_OUT_CTL);\r\nreg = (reg & ~control_mask) | control_set;\r\nimg_i2s_out_writel(i2s, reg, IMG_I2S_OUT_CTL);\r\nfor (i = 0; i < i2s_channels; i++)\r\nimg_i2s_out_ch_enable(i2s, i);\r\nfor (; i < i2s->max_i2s_chan; i++)\r\nimg_i2s_out_ch_disable(i2s, i);\r\nimg_i2s_out_enable(i2s);\r\ni2s->active_channels = i2s_channels;\r\nreturn 0;\r\n}\r\nstatic int img_i2s_out_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct img_i2s_out *i2s = snd_soc_dai_get_drvdata(dai);\r\nint i;\r\nbool force_clk_active;\r\nu32 chan_control_mask, control_mask, chan_control_set = 0;\r\nu32 reg, control_set = 0;\r\nforce_clk_active = ((fmt & SND_SOC_DAIFMT_CLOCK_MASK) ==\r\nSND_SOC_DAIFMT_CONT);\r\nif (force_clk_active)\r\ncontrol_set |= IMG_I2S_OUT_CTL_CLK_EN_MASK;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\ncontrol_set |= IMG_I2S_OUT_CTL_MASTER_MASK;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\ncontrol_set |= IMG_I2S_OUT_CTL_BCLK_POL_MASK;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\ncontrol_set |= IMG_I2S_OUT_CTL_BCLK_POL_MASK;\r\ncontrol_set |= IMG_I2S_OUT_CTL_FRM_CLK_POL_MASK;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\ncontrol_set |= IMG_I2S_OUT_CTL_FRM_CLK_POL_MASK;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nchan_control_set |= IMG_I2S_OUT_CHAN_CTL_CLKT_MASK;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncontrol_mask = IMG_I2S_OUT_CTL_CLK_EN_MASK |\r\nIMG_I2S_OUT_CTL_MASTER_MASK |\r\nIMG_I2S_OUT_CTL_BCLK_POL_MASK |\r\nIMG_I2S_OUT_CTL_FRM_CLK_POL_MASK;\r\nchan_control_mask = IMG_I2S_OUT_CHAN_CTL_CLKT_MASK;\r\nimg_i2s_out_disable(i2s);\r\nreg = img_i2s_out_readl(i2s, IMG_I2S_OUT_CTL);\r\nreg = (reg & ~control_mask) | control_set;\r\nimg_i2s_out_writel(i2s, reg, IMG_I2S_OUT_CTL);\r\nfor (i = 0; i < i2s->active_channels; i++)\r\nimg_i2s_out_ch_disable(i2s, i);\r\nfor (i = 0; i < i2s->max_i2s_chan; i++) {\r\nreg = img_i2s_out_ch_readl(i2s, i, IMG_I2S_OUT_CH_CTL);\r\nreg = (reg & ~chan_control_mask) | chan_control_set;\r\nimg_i2s_out_ch_writel(i2s, i, reg, IMG_I2S_OUT_CH_CTL);\r\n}\r\nfor (i = 0; i < i2s->active_channels; i++)\r\nimg_i2s_out_ch_enable(i2s, i);\r\nimg_i2s_out_enable(i2s);\r\ni2s->force_clk_active = force_clk_active;\r\nreturn 0;\r\n}\r\nstatic int img_i2s_out_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct img_i2s_out *i2s = snd_soc_dai_get_drvdata(dai);\r\nsnd_soc_dai_init_dma_data(dai, &i2s->dma_data, NULL);\r\nreturn 0;\r\n}\r\nstatic int img_i2s_out_dma_prepare_slave_config(struct snd_pcm_substream *st,\r\nstruct snd_pcm_hw_params *params, struct dma_slave_config *sc)\r\n{\r\nunsigned int i2s_channels = params_channels(params) / 2;\r\nstruct snd_soc_pcm_runtime *rtd = st->private_data;\r\nstruct snd_dmaengine_dai_dma_data *dma_data;\r\nint ret;\r\ndma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, st);\r\nret = snd_hwparams_to_dma_slave_config(st, params, sc);\r\nif (ret)\r\nreturn ret;\r\nsc->dst_addr = dma_data->addr;\r\nsc->dst_addr_width = dma_data->addr_width;\r\nsc->dst_maxburst = 4 * i2s_channels;\r\nreturn 0;\r\n}\r\nstatic int img_i2s_out_probe(struct platform_device *pdev)\r\n{\r\nstruct img_i2s_out *i2s;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nint i, ret;\r\nunsigned int max_i2s_chan_pow_2;\r\nu32 reg;\r\nstruct device *dev = &pdev->dev;\r\ni2s = devm_kzalloc(&pdev->dev, sizeof(*i2s), GFP_KERNEL);\r\nif (!i2s)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, i2s);\r\ni2s->dev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\ni2s->base = base;\r\nif (of_property_read_u32(pdev->dev.of_node, "img,i2s-channels",\r\n&i2s->max_i2s_chan)) {\r\ndev_err(&pdev->dev, "No img,i2s-channels property\n");\r\nreturn -EINVAL;\r\n}\r\nmax_i2s_chan_pow_2 = 1 << get_count_order(i2s->max_i2s_chan);\r\ni2s->channel_base = base + (max_i2s_chan_pow_2 * 0x20);\r\ni2s->rst = devm_reset_control_get(&pdev->dev, "rst");\r\nif (IS_ERR(i2s->rst)) {\r\nif (PTR_ERR(i2s->rst) != -EPROBE_DEFER)\r\ndev_err(&pdev->dev, "No top level reset found\n");\r\nreturn PTR_ERR(i2s->rst);\r\n}\r\ni2s->clk_sys = devm_clk_get(&pdev->dev, "sys");\r\nif (IS_ERR(i2s->clk_sys)) {\r\nif (PTR_ERR(i2s->clk_sys) != -EPROBE_DEFER)\r\ndev_err(dev, "Failed to acquire clock 'sys'\n");\r\nreturn PTR_ERR(i2s->clk_sys);\r\n}\r\ni2s->clk_ref = devm_clk_get(&pdev->dev, "ref");\r\nif (IS_ERR(i2s->clk_ref)) {\r\nif (PTR_ERR(i2s->clk_ref) != -EPROBE_DEFER)\r\ndev_err(dev, "Failed to acquire clock 'ref'\n");\r\nreturn PTR_ERR(i2s->clk_ref);\r\n}\r\nret = clk_prepare_enable(i2s->clk_sys);\r\nif (ret)\r\nreturn ret;\r\nreg = IMG_I2S_OUT_CTL_FRM_SIZE_MASK;\r\nimg_i2s_out_writel(i2s, reg, IMG_I2S_OUT_CTL);\r\nreg = IMG_I2S_OUT_CHAN_CTL_JUST_MASK |\r\nIMG_I2S_OUT_CHAN_CTL_LT_MASK |\r\nIMG_I2S_OUT_CHAN_CTL_CH_MASK |\r\n(8 << IMG_I2S_OUT_CHAN_CTL_FMT_SHIFT);\r\nfor (i = 0; i < i2s->max_i2s_chan; i++)\r\nimg_i2s_out_ch_writel(i2s, i, reg, IMG_I2S_OUT_CH_CTL);\r\nimg_i2s_out_reset(i2s);\r\npm_runtime_enable(&pdev->dev);\r\nif (!pm_runtime_enabled(&pdev->dev)) {\r\nret = img_i2s_out_resume(&pdev->dev);\r\nif (ret)\r\ngoto err_pm_disable;\r\n}\r\ni2s->active_channels = 1;\r\ni2s->dma_data.addr = res->start + IMG_I2S_OUT_TX_FIFO;\r\ni2s->dma_data.addr_width = 4;\r\ni2s->dma_data.maxburst = 4;\r\ni2s->dai_driver.probe = img_i2s_out_dai_probe;\r\ni2s->dai_driver.playback.channels_min = 2;\r\ni2s->dai_driver.playback.channels_max = i2s->max_i2s_chan * 2;\r\ni2s->dai_driver.playback.rates = SNDRV_PCM_RATE_8000_192000;\r\ni2s->dai_driver.playback.formats = SNDRV_PCM_FMTBIT_S32_LE;\r\ni2s->dai_driver.ops = &img_i2s_out_dai_ops;\r\nret = devm_snd_soc_register_component(&pdev->dev,\r\n&img_i2s_out_component, &i2s->dai_driver, 1);\r\nif (ret)\r\ngoto err_suspend;\r\nret = devm_snd_dmaengine_pcm_register(&pdev->dev,\r\n&img_i2s_out_dma_config, 0);\r\nif (ret)\r\ngoto err_suspend;\r\nreturn 0;\r\nerr_suspend:\r\nif (!pm_runtime_status_suspended(&pdev->dev))\r\nimg_i2s_out_suspend(&pdev->dev);\r\nerr_pm_disable:\r\npm_runtime_disable(&pdev->dev);\r\nclk_disable_unprepare(i2s->clk_sys);\r\nreturn ret;\r\n}\r\nstatic int img_i2s_out_dev_remove(struct platform_device *pdev)\r\n{\r\nstruct img_i2s_out *i2s = platform_get_drvdata(pdev);\r\npm_runtime_disable(&pdev->dev);\r\nif (!pm_runtime_status_suspended(&pdev->dev))\r\nimg_i2s_out_suspend(&pdev->dev);\r\nclk_disable_unprepare(i2s->clk_sys);\r\nreturn 0;\r\n}
