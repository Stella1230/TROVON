static void report_key_event(struct input_dev *input, int keycode)\r\n{\r\ninput_report_key(input, keycode, 1);\r\ninput_sync(input);\r\ninput_report_key(input, keycode, 0);\r\ninput_sync(input);\r\n}\r\nstatic void report_rotary_event(struct bfin_rot *rotary, int delta)\r\n{\r\nstruct input_dev *input = rotary->input;\r\nif (rotary->up_key) {\r\nreport_key_event(input,\r\ndelta > 0 ? rotary->up_key : rotary->down_key);\r\n} else {\r\ninput_report_rel(input, rotary->rel_code, delta);\r\ninput_sync(input);\r\n}\r\n}\r\nstatic irqreturn_t bfin_rotary_isr(int irq, void *dev_id)\r\n{\r\nstruct bfin_rot *rotary = dev_id;\r\nint delta;\r\nswitch (readw(rotary->base + CNT_STATUS_OFF)) {\r\ncase ICII:\r\nbreak;\r\ncase UCII:\r\ncase DCII:\r\ndelta = readl(rotary->base + CNT_COUNTER_OFF);\r\nif (delta)\r\nreport_rotary_event(rotary, delta);\r\nbreak;\r\ncase CZMII:\r\nreport_key_event(rotary->input, rotary->button_key);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nwritew(W1LCNT_ZERO, rotary->base + CNT_COMMAND_OFF);\r\nwritew(-1, rotary->base + CNT_STATUS_OFF);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bfin_rotary_open(struct input_dev *input)\r\n{\r\nstruct bfin_rot *rotary = input_get_drvdata(input);\r\nunsigned short val;\r\nif (rotary->mode & ROT_DEBE)\r\nwritew(rotary->debounce & DPRESCALE,\r\nrotary->base + CNT_DEBOUNCE_OFF);\r\nwritew(rotary->mode & ~CNTE, rotary->base + CNT_CONFIG_OFF);\r\nval = UCIE | DCIE;\r\nif (rotary->button_key)\r\nval |= CZMIE;\r\nwritew(val, rotary->base + CNT_IMASK_OFF);\r\nwritew(rotary->mode | CNTE, rotary->base + CNT_CONFIG_OFF);\r\nreturn 0;\r\n}\r\nstatic void bfin_rotary_close(struct input_dev *input)\r\n{\r\nstruct bfin_rot *rotary = input_get_drvdata(input);\r\nwritew(0, rotary->base + CNT_CONFIG_OFF);\r\nwritew(0, rotary->base + CNT_IMASK_OFF);\r\n}\r\nstatic void bfin_rotary_free_action(void *data)\r\n{\r\nperipheral_free_list(data);\r\n}\r\nstatic int bfin_rotary_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nconst struct bfin_rotary_platform_data *pdata = dev_get_platdata(dev);\r\nstruct bfin_rot *rotary;\r\nstruct resource *res;\r\nstruct input_dev *input;\r\nint error;\r\nif ((pdata->rotary_up_key && !pdata->rotary_down_key) ||\r\n(!pdata->rotary_up_key && pdata->rotary_down_key)) {\r\nreturn -EINVAL;\r\n}\r\nif (pdata->pin_list) {\r\nerror = peripheral_request_list(pdata->pin_list,\r\ndev_name(dev));\r\nif (error) {\r\ndev_err(dev, "requesting peripherals failed: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = devm_add_action_or_reset(dev, bfin_rotary_free_action,\r\npdata->pin_list);\r\nif (error) {\r\ndev_err(dev, "setting cleanup action failed: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\n}\r\nrotary = devm_kzalloc(dev, sizeof(struct bfin_rot), GFP_KERNEL);\r\nif (!rotary)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrotary->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(rotary->base))\r\nreturn PTR_ERR(rotary->base);\r\ninput = devm_input_allocate_device(dev);\r\nif (!input)\r\nreturn -ENOMEM;\r\nrotary->input = input;\r\nrotary->up_key = pdata->rotary_up_key;\r\nrotary->down_key = pdata->rotary_down_key;\r\nrotary->button_key = pdata->rotary_button_key;\r\nrotary->rel_code = pdata->rotary_rel_code;\r\nrotary->mode = pdata->mode;\r\nrotary->debounce = pdata->debounce;\r\ninput->name = pdev->name;\r\ninput->phys = "bfin-rotary/input0";\r\ninput->dev.parent = dev;\r\ninput_set_drvdata(input, rotary);\r\ninput->id.bustype = BUS_HOST;\r\ninput->id.vendor = 0x0001;\r\ninput->id.product = 0x0001;\r\ninput->id.version = 0x0100;\r\ninput->open = bfin_rotary_open;\r\ninput->close = bfin_rotary_close;\r\nif (rotary->up_key) {\r\n__set_bit(EV_KEY, input->evbit);\r\n__set_bit(rotary->up_key, input->keybit);\r\n__set_bit(rotary->down_key, input->keybit);\r\n} else {\r\n__set_bit(EV_REL, input->evbit);\r\n__set_bit(rotary->rel_code, input->relbit);\r\n}\r\nif (rotary->button_key) {\r\n__set_bit(EV_KEY, input->evbit);\r\n__set_bit(rotary->button_key, input->keybit);\r\n}\r\nbfin_rotary_close(input);\r\nrotary->irq = platform_get_irq(pdev, 0);\r\nif (rotary->irq < 0) {\r\ndev_err(dev, "No rotary IRQ specified\n");\r\nreturn -ENOENT;\r\n}\r\nerror = devm_request_irq(dev, rotary->irq, bfin_rotary_isr,\r\n0, dev_name(dev), rotary);\r\nif (error) {\r\ndev_err(dev, "unable to claim irq %d; error %d\n",\r\nrotary->irq, error);\r\nreturn error;\r\n}\r\nerror = input_register_device(input);\r\nif (error) {\r\ndev_err(dev, "unable to register input device (%d)\n", error);\r\nreturn error;\r\n}\r\nplatform_set_drvdata(pdev, rotary);\r\ndevice_init_wakeup(dev, 1);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused bfin_rotary_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct bfin_rot *rotary = platform_get_drvdata(pdev);\r\nrotary->cnt_config = readw(rotary->base + CNT_CONFIG_OFF);\r\nrotary->cnt_imask = readw(rotary->base + CNT_IMASK_OFF);\r\nrotary->cnt_debounce = readw(rotary->base + CNT_DEBOUNCE_OFF);\r\nif (device_may_wakeup(&pdev->dev))\r\nenable_irq_wake(rotary->irq);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused bfin_rotary_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct bfin_rot *rotary = platform_get_drvdata(pdev);\r\nwritew(rotary->cnt_debounce, rotary->base + CNT_DEBOUNCE_OFF);\r\nwritew(rotary->cnt_imask, rotary->base + CNT_IMASK_OFF);\r\nwritew(rotary->cnt_config & ~CNTE, rotary->base + CNT_CONFIG_OFF);\r\nif (device_may_wakeup(&pdev->dev))\r\ndisable_irq_wake(rotary->irq);\r\nif (rotary->cnt_config & CNTE)\r\nwritew(rotary->cnt_config, rotary->base + CNT_CONFIG_OFF);\r\nreturn 0;\r\n}
