static inline void rtllib_monitor_rx(struct rtllib_device *ieee,\r\nstruct sk_buff *skb,\r\nstruct rtllib_rx_stats *rx_status,\r\nsize_t hdr_length)\r\n{\r\nskb->dev = ieee->dev;\r\nskb_reset_mac_header(skb);\r\nskb_pull(skb, hdr_length);\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nskb->protocol = htons(ETH_P_80211_RAW);\r\nmemset(skb->cb, 0, sizeof(skb->cb));\r\nnetif_rx(skb);\r\n}\r\nstatic struct rtllib_frag_entry *\r\nrtllib_frag_cache_find(struct rtllib_device *ieee, unsigned int seq,\r\nunsigned int frag, u8 tid, u8 *src, u8 *dst)\r\n{\r\nstruct rtllib_frag_entry *entry;\r\nint i;\r\nfor (i = 0; i < RTLLIB_FRAG_CACHE_LEN; i++) {\r\nentry = &ieee->frag_cache[tid][i];\r\nif (entry->skb != NULL &&\r\ntime_after(jiffies, entry->first_frag_time + 2 * HZ)) {\r\nnetdev_dbg(ieee->dev,\r\n"expiring fragment cache entry seq=%u last_frag=%u\n",\r\nentry->seq, entry->last_frag);\r\ndev_kfree_skb_any(entry->skb);\r\nentry->skb = NULL;\r\n}\r\nif (entry->skb != NULL && entry->seq == seq &&\r\n(entry->last_frag + 1 == frag || frag == -1) &&\r\nmemcmp(entry->src_addr, src, ETH_ALEN) == 0 &&\r\nmemcmp(entry->dst_addr, dst, ETH_ALEN) == 0)\r\nreturn entry;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct sk_buff *\r\nrtllib_frag_cache_get(struct rtllib_device *ieee,\r\nstruct rtllib_hdr_4addr *hdr)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nu16 fc = le16_to_cpu(hdr->frame_ctl);\r\nu16 sc = le16_to_cpu(hdr->seq_ctl);\r\nunsigned int frag = WLAN_GET_SEQ_FRAG(sc);\r\nunsigned int seq = WLAN_GET_SEQ_SEQ(sc);\r\nstruct rtllib_frag_entry *entry;\r\nstruct rtllib_hdr_3addrqos *hdr_3addrqos;\r\nstruct rtllib_hdr_4addrqos *hdr_4addrqos;\r\nu8 tid;\r\nif (((fc & RTLLIB_FCTL_DSTODS) == RTLLIB_FCTL_DSTODS) &&\r\nRTLLIB_QOS_HAS_SEQ(fc)) {\r\nhdr_4addrqos = (struct rtllib_hdr_4addrqos *)hdr;\r\ntid = le16_to_cpu(hdr_4addrqos->qos_ctl) & RTLLIB_QCTL_TID;\r\ntid = UP2AC(tid);\r\ntid++;\r\n} else if (RTLLIB_QOS_HAS_SEQ(fc)) {\r\nhdr_3addrqos = (struct rtllib_hdr_3addrqos *)hdr;\r\ntid = le16_to_cpu(hdr_3addrqos->qos_ctl) & RTLLIB_QCTL_TID;\r\ntid = UP2AC(tid);\r\ntid++;\r\n} else {\r\ntid = 0;\r\n}\r\nif (frag == 0) {\r\nskb = dev_alloc_skb(ieee->dev->mtu +\r\nsizeof(struct rtllib_hdr_4addr) +\r\n8 +\r\n2 +\r\n8 +\r\nETH_ALEN +\r\n(RTLLIB_QOS_HAS_SEQ(fc) ? 2 : 0));\r\nif (!skb)\r\nreturn NULL;\r\nentry = &ieee->frag_cache[tid][ieee->frag_next_idx[tid]];\r\nieee->frag_next_idx[tid]++;\r\nif (ieee->frag_next_idx[tid] >= RTLLIB_FRAG_CACHE_LEN)\r\nieee->frag_next_idx[tid] = 0;\r\nif (entry->skb != NULL)\r\ndev_kfree_skb_any(entry->skb);\r\nentry->first_frag_time = jiffies;\r\nentry->seq = seq;\r\nentry->last_frag = frag;\r\nentry->skb = skb;\r\nether_addr_copy(entry->src_addr, hdr->addr2);\r\nether_addr_copy(entry->dst_addr, hdr->addr1);\r\n} else {\r\nentry = rtllib_frag_cache_find(ieee, seq, frag, tid, hdr->addr2,\r\nhdr->addr1);\r\nif (entry != NULL) {\r\nentry->last_frag = frag;\r\nskb = entry->skb;\r\n}\r\n}\r\nreturn skb;\r\n}\r\nstatic int rtllib_frag_cache_invalidate(struct rtllib_device *ieee,\r\nstruct rtllib_hdr_4addr *hdr)\r\n{\r\nu16 fc = le16_to_cpu(hdr->frame_ctl);\r\nu16 sc = le16_to_cpu(hdr->seq_ctl);\r\nunsigned int seq = WLAN_GET_SEQ_SEQ(sc);\r\nstruct rtllib_frag_entry *entry;\r\nstruct rtllib_hdr_3addrqos *hdr_3addrqos;\r\nstruct rtllib_hdr_4addrqos *hdr_4addrqos;\r\nu8 tid;\r\nif (((fc & RTLLIB_FCTL_DSTODS) == RTLLIB_FCTL_DSTODS) &&\r\nRTLLIB_QOS_HAS_SEQ(fc)) {\r\nhdr_4addrqos = (struct rtllib_hdr_4addrqos *)hdr;\r\ntid = le16_to_cpu(hdr_4addrqos->qos_ctl) & RTLLIB_QCTL_TID;\r\ntid = UP2AC(tid);\r\ntid++;\r\n} else if (RTLLIB_QOS_HAS_SEQ(fc)) {\r\nhdr_3addrqos = (struct rtllib_hdr_3addrqos *)hdr;\r\ntid = le16_to_cpu(hdr_3addrqos->qos_ctl) & RTLLIB_QCTL_TID;\r\ntid = UP2AC(tid);\r\ntid++;\r\n} else {\r\ntid = 0;\r\n}\r\nentry = rtllib_frag_cache_find(ieee, seq, -1, tid, hdr->addr2,\r\nhdr->addr1);\r\nif (entry == NULL) {\r\nnetdev_dbg(ieee->dev,\r\n"Couldn't invalidate fragment cache entry (seq=%u)\n",\r\nseq);\r\nreturn -1;\r\n}\r\nentry->skb = NULL;\r\nreturn 0;\r\n}\r\nstatic inline int\r\nrtllib_rx_frame_mgmt(struct rtllib_device *ieee, struct sk_buff *skb,\r\nstruct rtllib_rx_stats *rx_stats, u16 type,\r\nu16 stype)\r\n{\r\nstruct rtllib_hdr_3addr *hdr = (struct rtllib_hdr_3addr *)skb->data;\r\nrx_stats->len = skb->len;\r\nrtllib_rx_mgt(ieee, skb, rx_stats);\r\nif ((memcmp(hdr->addr1, ieee->dev->dev_addr, ETH_ALEN))) {\r\ndev_kfree_skb_any(skb);\r\nreturn 0;\r\n}\r\nrtllib_rx_frame_softmac(ieee, skb, rx_stats, type, stype);\r\ndev_kfree_skb_any(skb);\r\nreturn 0;\r\n}\r\nstatic int rtllib_is_eapol_frame(struct rtllib_device *ieee,\r\nstruct sk_buff *skb, size_t hdrlen)\r\n{\r\nstruct net_device *dev = ieee->dev;\r\nu16 fc, ethertype;\r\nstruct rtllib_hdr_4addr *hdr;\r\nu8 *pos;\r\nif (skb->len < 24)\r\nreturn 0;\r\nhdr = (struct rtllib_hdr_4addr *) skb->data;\r\nfc = le16_to_cpu(hdr->frame_ctl);\r\nif ((fc & (RTLLIB_FCTL_TODS | RTLLIB_FCTL_FROMDS)) ==\r\nRTLLIB_FCTL_TODS &&\r\nmemcmp(hdr->addr1, dev->dev_addr, ETH_ALEN) == 0 &&\r\nmemcmp(hdr->addr3, dev->dev_addr, ETH_ALEN) == 0) {\r\n} else if ((fc & (RTLLIB_FCTL_TODS | RTLLIB_FCTL_FROMDS)) ==\r\nRTLLIB_FCTL_FROMDS &&\r\nmemcmp(hdr->addr1, dev->dev_addr, ETH_ALEN) == 0) {\r\n} else\r\nreturn 0;\r\nif (skb->len < 24 + 8)\r\nreturn 0;\r\npos = skb->data + hdrlen;\r\nethertype = (pos[6] << 8) | pos[7];\r\nif (ethertype == ETH_P_PAE)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline int\r\nrtllib_rx_frame_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,\r\nstruct lib80211_crypt_data *crypt)\r\n{\r\nstruct rtllib_hdr_4addr *hdr;\r\nint res, hdrlen;\r\nif (crypt == NULL || crypt->ops->decrypt_mpdu == NULL)\r\nreturn 0;\r\nif (ieee->hwsec_active) {\r\nstruct cb_desc *tcb_desc = (struct cb_desc *)\r\n(skb->cb + MAX_DEV_ADDR_SIZE);\r\ntcb_desc->bHwSec = 1;\r\nif (ieee->need_sw_enc)\r\ntcb_desc->bHwSec = 0;\r\n}\r\nhdr = (struct rtllib_hdr_4addr *) skb->data;\r\nhdrlen = rtllib_get_hdrlen(le16_to_cpu(hdr->frame_ctl));\r\natomic_inc(&crypt->refcnt);\r\nres = crypt->ops->decrypt_mpdu(skb, hdrlen, crypt->priv);\r\natomic_dec(&crypt->refcnt);\r\nif (res < 0) {\r\nnetdev_dbg(ieee->dev, "decryption failed (SA= %pM) res=%d\n",\r\nhdr->addr2, res);\r\nif (res == -2)\r\nnetdev_dbg(ieee->dev,\r\n"Decryption failed ICV mismatch (key %d)\n",\r\nskb->data[hdrlen + 3] >> 6);\r\nreturn -1;\r\n}\r\nreturn res;\r\n}\r\nstatic inline int\r\nrtllib_rx_frame_decrypt_msdu(struct rtllib_device *ieee, struct sk_buff *skb,\r\nint keyidx, struct lib80211_crypt_data *crypt)\r\n{\r\nstruct rtllib_hdr_4addr *hdr;\r\nint res, hdrlen;\r\nif (crypt == NULL || crypt->ops->decrypt_msdu == NULL)\r\nreturn 0;\r\nif (ieee->hwsec_active) {\r\nstruct cb_desc *tcb_desc = (struct cb_desc *)\r\n(skb->cb + MAX_DEV_ADDR_SIZE);\r\ntcb_desc->bHwSec = 1;\r\nif (ieee->need_sw_enc)\r\ntcb_desc->bHwSec = 0;\r\n}\r\nhdr = (struct rtllib_hdr_4addr *) skb->data;\r\nhdrlen = rtllib_get_hdrlen(le16_to_cpu(hdr->frame_ctl));\r\natomic_inc(&crypt->refcnt);\r\nres = crypt->ops->decrypt_msdu(skb, keyidx, hdrlen, crypt->priv);\r\natomic_dec(&crypt->refcnt);\r\nif (res < 0) {\r\nnetdev_dbg(ieee->dev,\r\n"MSDU decryption/MIC verification failed (SA= %pM keyidx=%d)\n",\r\nhdr->addr2, keyidx);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int is_duplicate_packet(struct rtllib_device *ieee,\r\nstruct rtllib_hdr_4addr *header)\r\n{\r\nu16 fc = le16_to_cpu(header->frame_ctl);\r\nu16 sc = le16_to_cpu(header->seq_ctl);\r\nu16 seq = WLAN_GET_SEQ_SEQ(sc);\r\nu16 frag = WLAN_GET_SEQ_FRAG(sc);\r\nu16 *last_seq, *last_frag;\r\nunsigned long *last_time;\r\nstruct rtllib_hdr_3addrqos *hdr_3addrqos;\r\nstruct rtllib_hdr_4addrqos *hdr_4addrqos;\r\nu8 tid;\r\nif (((fc & RTLLIB_FCTL_DSTODS) == RTLLIB_FCTL_DSTODS) &&\r\nRTLLIB_QOS_HAS_SEQ(fc)) {\r\nhdr_4addrqos = (struct rtllib_hdr_4addrqos *)header;\r\ntid = le16_to_cpu(hdr_4addrqos->qos_ctl) & RTLLIB_QCTL_TID;\r\ntid = UP2AC(tid);\r\ntid++;\r\n} else if (RTLLIB_QOS_HAS_SEQ(fc)) {\r\nhdr_3addrqos = (struct rtllib_hdr_3addrqos *)header;\r\ntid = le16_to_cpu(hdr_3addrqos->qos_ctl) & RTLLIB_QCTL_TID;\r\ntid = UP2AC(tid);\r\ntid++;\r\n} else {\r\ntid = 0;\r\n}\r\nswitch (ieee->iw_mode) {\r\ncase IW_MODE_ADHOC:\r\n{\r\nstruct list_head *p;\r\nstruct ieee_ibss_seq *entry = NULL;\r\nu8 *mac = header->addr2;\r\nint index = mac[5] % IEEE_IBSS_MAC_HASH_SIZE;\r\nlist_for_each(p, &ieee->ibss_mac_hash[index]) {\r\nentry = list_entry(p, struct ieee_ibss_seq, list);\r\nif (!memcmp(entry->mac, mac, ETH_ALEN))\r\nbreak;\r\n}\r\nif (p == &ieee->ibss_mac_hash[index]) {\r\nentry = kmalloc(sizeof(struct ieee_ibss_seq),\r\nGFP_ATOMIC);\r\nif (!entry)\r\nreturn 0;\r\nether_addr_copy(entry->mac, mac);\r\nentry->seq_num[tid] = seq;\r\nentry->frag_num[tid] = frag;\r\nentry->packet_time[tid] = jiffies;\r\nlist_add(&entry->list, &ieee->ibss_mac_hash[index]);\r\nreturn 0;\r\n}\r\nlast_seq = &entry->seq_num[tid];\r\nlast_frag = &entry->frag_num[tid];\r\nlast_time = &entry->packet_time[tid];\r\nbreak;\r\n}\r\ncase IW_MODE_INFRA:\r\nlast_seq = &ieee->last_rxseq_num[tid];\r\nlast_frag = &ieee->last_rxfrag_num[tid];\r\nlast_time = &ieee->last_packet_time[tid];\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif ((*last_seq == seq) &&\r\ntime_after(*last_time + IEEE_PACKET_RETRY_TIME, jiffies)) {\r\nif (*last_frag == frag)\r\ngoto drop;\r\nif (*last_frag + 1 != frag)\r\ngoto drop;\r\n} else\r\n*last_seq = seq;\r\n*last_frag = frag;\r\n*last_time = jiffies;\r\nreturn 0;\r\ndrop:\r\nreturn 1;\r\n}\r\nstatic bool AddReorderEntry(struct rx_ts_record *pTS,\r\nstruct rx_reorder_entry *pReorderEntry)\r\n{\r\nstruct list_head *pList = &pTS->RxPendingPktList;\r\nwhile (pList->next != &pTS->RxPendingPktList) {\r\nif (SN_LESS(pReorderEntry->SeqNum, ((struct rx_reorder_entry *)\r\nlist_entry(pList->next, struct rx_reorder_entry,\r\nList))->SeqNum))\r\npList = pList->next;\r\nelse if (SN_EQUAL(pReorderEntry->SeqNum,\r\n((struct rx_reorder_entry *)list_entry(pList->next,\r\nstruct rx_reorder_entry, List))->SeqNum))\r\nreturn false;\r\nelse\r\nbreak;\r\n}\r\npReorderEntry->List.next = pList->next;\r\npReorderEntry->List.next->prev = &pReorderEntry->List;\r\npReorderEntry->List.prev = pList;\r\npList->next = &pReorderEntry->List;\r\nreturn true;\r\n}\r\nvoid rtllib_indicate_packets(struct rtllib_device *ieee,\r\nstruct rtllib_rxb **prxbIndicateArray, u8 index)\r\n{\r\nstruct net_device_stats *stats = &ieee->stats;\r\nu8 i = 0, j = 0;\r\nu16 ethertype;\r\nfor (j = 0; j < index; j++) {\r\nstruct rtllib_rxb *prxb = prxbIndicateArray[j];\r\nfor (i = 0; i < prxb->nr_subframes; i++) {\r\nstruct sk_buff *sub_skb = prxb->subframes[i];\r\nethertype = (sub_skb->data[6] << 8) | sub_skb->data[7];\r\nif (sub_skb->len >= 8 &&\r\n((memcmp(sub_skb->data, rfc1042_header,\r\nSNAP_SIZE) == 0 &&\r\nethertype != ETH_P_AARP &&\r\nethertype != ETH_P_IPX) ||\r\nmemcmp(sub_skb->data, bridge_tunnel_header,\r\nSNAP_SIZE) == 0)) {\r\nskb_pull(sub_skb, SNAP_SIZE);\r\nmemcpy(skb_push(sub_skb, ETH_ALEN), prxb->src, ETH_ALEN);\r\nmemcpy(skb_push(sub_skb, ETH_ALEN), prxb->dst, ETH_ALEN);\r\n} else {\r\nu16 len;\r\nlen = sub_skb->len;\r\nmemcpy(skb_push(sub_skb, 2), &len, 2);\r\nmemcpy(skb_push(sub_skb, ETH_ALEN), prxb->src, ETH_ALEN);\r\nmemcpy(skb_push(sub_skb, ETH_ALEN), prxb->dst, ETH_ALEN);\r\n}\r\nif (sub_skb) {\r\nstats->rx_packets++;\r\nstats->rx_bytes += sub_skb->len;\r\nmemset(sub_skb->cb, 0, sizeof(sub_skb->cb));\r\nsub_skb->protocol = eth_type_trans(sub_skb,\r\nieee->dev);\r\nsub_skb->dev = ieee->dev;\r\nsub_skb->dev->stats.rx_packets++;\r\nsub_skb->dev->stats.rx_bytes += sub_skb->len;\r\nsub_skb->ip_summed = CHECKSUM_NONE;\r\nieee->last_rx_ps_time = jiffies;\r\nnetif_rx(sub_skb);\r\n}\r\n}\r\nkfree(prxb);\r\nprxb = NULL;\r\n}\r\n}\r\nvoid rtllib_FlushRxTsPendingPkts(struct rtllib_device *ieee,\r\nstruct rx_ts_record *pTS)\r\n{\r\nstruct rx_reorder_entry *pRxReorderEntry;\r\nu8 RfdCnt = 0;\r\ndel_timer_sync(&pTS->RxPktPendingTimer);\r\nwhile (!list_empty(&pTS->RxPendingPktList)) {\r\nif (RfdCnt >= REORDER_WIN_SIZE) {\r\nnetdev_info(ieee->dev,\r\n"-------------->%s() error! RfdCnt >= REORDER_WIN_SIZE\n",\r\n__func__);\r\nbreak;\r\n}\r\npRxReorderEntry = (struct rx_reorder_entry *)\r\nlist_entry(pTS->RxPendingPktList.prev,\r\nstruct rx_reorder_entry, List);\r\nnetdev_dbg(ieee->dev, "%s(): Indicate SeqNum %d!\n", __func__,\r\npRxReorderEntry->SeqNum);\r\nlist_del_init(&pRxReorderEntry->List);\r\nieee->RfdArray[RfdCnt] = pRxReorderEntry->prxb;\r\nRfdCnt = RfdCnt + 1;\r\nlist_add_tail(&pRxReorderEntry->List,\r\n&ieee->RxReorder_Unused_List);\r\n}\r\nrtllib_indicate_packets(ieee, ieee->RfdArray, RfdCnt);\r\npTS->RxIndicateSeq = 0xffff;\r\n}\r\nstatic void RxReorderIndicatePacket(struct rtllib_device *ieee,\r\nstruct rtllib_rxb *prxb,\r\nstruct rx_ts_record *pTS, u16 SeqNum)\r\n{\r\nstruct rt_hi_throughput *pHTInfo = ieee->pHTInfo;\r\nstruct rx_reorder_entry *pReorderEntry = NULL;\r\nu8 WinSize = pHTInfo->RxReorderWinSize;\r\nu16 WinEnd = 0;\r\nu8 index = 0;\r\nbool bMatchWinStart = false, bPktInBuf = false;\r\nunsigned long flags;\r\nnetdev_dbg(ieee->dev,\r\n"%s(): Seq is %d, pTS->RxIndicateSeq is %d, WinSize is %d\n",\r\n__func__, SeqNum, pTS->RxIndicateSeq, WinSize);\r\nspin_lock_irqsave(&(ieee->reorder_spinlock), flags);\r\nWinEnd = (pTS->RxIndicateSeq + WinSize - 1) % 4096;\r\nif (pTS->RxIndicateSeq == 0xffff)\r\npTS->RxIndicateSeq = SeqNum;\r\nif (SN_LESS(SeqNum, pTS->RxIndicateSeq)) {\r\nnetdev_dbg(ieee->dev,\r\n"Packet Drop! IndicateSeq: %d, NewSeq: %d\n",\r\npTS->RxIndicateSeq, SeqNum);\r\npHTInfo->RxReorderDropCounter++;\r\n{\r\nint i;\r\nfor (i = 0; i < prxb->nr_subframes; i++)\r\ndev_kfree_skb(prxb->subframes[i]);\r\nkfree(prxb);\r\nprxb = NULL;\r\n}\r\nspin_unlock_irqrestore(&(ieee->reorder_spinlock), flags);\r\nreturn;\r\n}\r\nif (SN_EQUAL(SeqNum, pTS->RxIndicateSeq)) {\r\npTS->RxIndicateSeq = (pTS->RxIndicateSeq + 1) % 4096;\r\nbMatchWinStart = true;\r\n} else if (SN_LESS(WinEnd, SeqNum)) {\r\nif (SeqNum >= (WinSize - 1))\r\npTS->RxIndicateSeq = SeqNum + 1 - WinSize;\r\nelse\r\npTS->RxIndicateSeq = 4095 -\r\n(WinSize - (SeqNum + 1)) + 1;\r\nnetdev_dbg(ieee->dev,\r\n"Window Shift! IndicateSeq: %d, NewSeq: %d\n",\r\npTS->RxIndicateSeq, SeqNum);\r\n}\r\nif (bMatchWinStart) {\r\nnetdev_dbg(ieee->dev,\r\n"Packets indication! IndicateSeq: %d, NewSeq: %d\n",\r\npTS->RxIndicateSeq, SeqNum);\r\nieee->prxbIndicateArray[0] = prxb;\r\nindex = 1;\r\n} else {\r\nif (!list_empty(&ieee->RxReorder_Unused_List)) {\r\npReorderEntry = (struct rx_reorder_entry *)\r\nlist_entry(ieee->RxReorder_Unused_List.next,\r\nstruct rx_reorder_entry, List);\r\nlist_del_init(&pReorderEntry->List);\r\npReorderEntry->SeqNum = SeqNum;\r\npReorderEntry->prxb = prxb;\r\nif (!AddReorderEntry(pTS, pReorderEntry)) {\r\nint i;\r\nnetdev_dbg(ieee->dev,\r\n"%s(): Duplicate packet is dropped. IndicateSeq: %d, NewSeq: %d\n",\r\n__func__, pTS->RxIndicateSeq,\r\nSeqNum);\r\nlist_add_tail(&pReorderEntry->List,\r\n&ieee->RxReorder_Unused_List);\r\nfor (i = 0; i < prxb->nr_subframes; i++)\r\ndev_kfree_skb(prxb->subframes[i]);\r\nkfree(prxb);\r\nprxb = NULL;\r\n} else {\r\nnetdev_dbg(ieee->dev,\r\n"Pkt insert into struct buffer. IndicateSeq: %d, NewSeq: %d\n",\r\npTS->RxIndicateSeq, SeqNum);\r\n}\r\n} else {\r\nnetdev_err(ieee->dev,\r\n"%s(): There is no reorder entry! Packet is dropped!\n",\r\n__func__);\r\n{\r\nint i;\r\nfor (i = 0; i < prxb->nr_subframes; i++)\r\ndev_kfree_skb(prxb->subframes[i]);\r\nkfree(prxb);\r\nprxb = NULL;\r\n}\r\n}\r\n}\r\nwhile (!list_empty(&pTS->RxPendingPktList)) {\r\nnetdev_dbg(ieee->dev, "%s(): start RREORDER indicate\n",\r\n__func__);\r\npReorderEntry = (struct rx_reorder_entry *)\r\nlist_entry(pTS->RxPendingPktList.prev,\r\nstruct rx_reorder_entry,\r\nList);\r\nif (SN_LESS(pReorderEntry->SeqNum, pTS->RxIndicateSeq) ||\r\nSN_EQUAL(pReorderEntry->SeqNum, pTS->RxIndicateSeq)) {\r\nif (index >= REORDER_WIN_SIZE) {\r\nnetdev_err(ieee->dev,\r\n"%s(): Buffer overflow!\n",\r\n__func__);\r\nbPktInBuf = true;\r\nbreak;\r\n}\r\nlist_del_init(&pReorderEntry->List);\r\nif (SN_EQUAL(pReorderEntry->SeqNum, pTS->RxIndicateSeq))\r\npTS->RxIndicateSeq = (pTS->RxIndicateSeq + 1) %\r\n4096;\r\nieee->prxbIndicateArray[index] = pReorderEntry->prxb;\r\nnetdev_dbg(ieee->dev, "%s(): Indicate SeqNum %d!\n",\r\n__func__, pReorderEntry->SeqNum);\r\nindex++;\r\nlist_add_tail(&pReorderEntry->List,\r\n&ieee->RxReorder_Unused_List);\r\n} else {\r\nbPktInBuf = true;\r\nbreak;\r\n}\r\n}\r\nif (index > 0) {\r\nif (timer_pending(&pTS->RxPktPendingTimer))\r\ndel_timer_sync(&pTS->RxPktPendingTimer);\r\npTS->RxTimeoutIndicateSeq = 0xffff;\r\nif (index > REORDER_WIN_SIZE) {\r\nnetdev_err(ieee->dev,\r\n"%s(): Rx Reorder struct buffer full!\n",\r\n__func__);\r\nspin_unlock_irqrestore(&(ieee->reorder_spinlock),\r\nflags);\r\nreturn;\r\n}\r\nrtllib_indicate_packets(ieee, ieee->prxbIndicateArray, index);\r\nbPktInBuf = false;\r\n}\r\nif (bPktInBuf && pTS->RxTimeoutIndicateSeq == 0xffff) {\r\nnetdev_dbg(ieee->dev, "%s(): SET rx timeout timer\n", __func__);\r\npTS->RxTimeoutIndicateSeq = pTS->RxIndicateSeq;\r\nmod_timer(&pTS->RxPktPendingTimer, jiffies +\r\nmsecs_to_jiffies(pHTInfo->RxReorderPendingTime));\r\n}\r\nspin_unlock_irqrestore(&(ieee->reorder_spinlock), flags);\r\n}\r\nstatic u8 parse_subframe(struct rtllib_device *ieee, struct sk_buff *skb,\r\nstruct rtllib_rx_stats *rx_stats,\r\nstruct rtllib_rxb *rxb, u8 *src, u8 *dst)\r\n{\r\nstruct rtllib_hdr_3addr *hdr = (struct rtllib_hdr_3addr *)skb->data;\r\nu16 fc = le16_to_cpu(hdr->frame_ctl);\r\nu16 LLCOffset = sizeof(struct rtllib_hdr_3addr);\r\nu16 ChkLength;\r\nbool bIsAggregateFrame = false;\r\nu16 nSubframe_Length;\r\nu8 nPadding_Length = 0;\r\nu16 SeqNum = 0;\r\nstruct sk_buff *sub_skb;\r\nu8 *data_ptr;\r\nSeqNum = WLAN_GET_SEQ_SEQ(le16_to_cpu(hdr->seq_ctl));\r\nif ((RTLLIB_QOS_HAS_SEQ(fc)) &&\r\n(((union frameqos *)(skb->data + RTLLIB_3ADDR_LEN))->field.reserved))\r\nbIsAggregateFrame = true;\r\nif (RTLLIB_QOS_HAS_SEQ(fc))\r\nLLCOffset += 2;\r\nif (rx_stats->bContainHTC)\r\nLLCOffset += sHTCLng;\r\nChkLength = LLCOffset;\r\nif (skb->len <= ChkLength)\r\nreturn 0;\r\nskb_pull(skb, LLCOffset);\r\nieee->bIsAggregateFrame = bIsAggregateFrame;\r\nif (!bIsAggregateFrame) {\r\nrxb->nr_subframes = 1;\r\nsub_skb = dev_alloc_skb(RTLLIB_SKBBUFFER_SIZE);\r\nif (!sub_skb)\r\nreturn 0;\r\nskb_reserve(sub_skb, 12);\r\ndata_ptr = (u8 *)skb_put(sub_skb, skb->len);\r\nmemcpy(data_ptr, skb->data, skb->len);\r\nsub_skb->dev = ieee->dev;\r\nrxb->subframes[0] = sub_skb;\r\nmemcpy(rxb->src, src, ETH_ALEN);\r\nmemcpy(rxb->dst, dst, ETH_ALEN);\r\nrxb->subframes[0]->dev = ieee->dev;\r\nreturn 1;\r\n}\r\nrxb->nr_subframes = 0;\r\nmemcpy(rxb->src, src, ETH_ALEN);\r\nmemcpy(rxb->dst, dst, ETH_ALEN);\r\nwhile (skb->len > ETHERNET_HEADER_SIZE) {\r\nnSubframe_Length = *((u16 *)(skb->data + 12));\r\nnSubframe_Length = (nSubframe_Length >> 8) +\r\n(nSubframe_Length << 8);\r\nif (skb->len < (ETHERNET_HEADER_SIZE + nSubframe_Length)) {\r\nnetdev_info(ieee->dev,\r\n"%s: A-MSDU parse error!! pRfd->nTotalSubframe : %d\n",\r\n__func__, rxb->nr_subframes);\r\nnetdev_info(ieee->dev,\r\n"%s: A-MSDU parse error!! Subframe Length: %d\n",\r\n__func__, nSubframe_Length);\r\nnetdev_info(ieee->dev,\r\n"nRemain_Length is %d and nSubframe_Length is : %d\n",\r\nskb->len, nSubframe_Length);\r\nnetdev_info(ieee->dev,\r\n"The Packet SeqNum is %d\n",\r\nSeqNum);\r\nreturn 0;\r\n}\r\nskb_pull(skb, ETHERNET_HEADER_SIZE);\r\nsub_skb = dev_alloc_skb(nSubframe_Length + 12);\r\nif (!sub_skb)\r\nreturn 0;\r\nskb_reserve(sub_skb, 12);\r\ndata_ptr = (u8 *)skb_put(sub_skb, nSubframe_Length);\r\nmemcpy(data_ptr, skb->data, nSubframe_Length);\r\nsub_skb->dev = ieee->dev;\r\nrxb->subframes[rxb->nr_subframes++] = sub_skb;\r\nif (rxb->nr_subframes >= MAX_SUBFRAME_COUNT) {\r\nnetdev_dbg(ieee->dev,\r\n"ParseSubframe(): Too many Subframes! Packets dropped!\n");\r\nbreak;\r\n}\r\nskb_pull(skb, nSubframe_Length);\r\nif (skb->len != 0) {\r\nnPadding_Length = 4 - ((nSubframe_Length +\r\nETHERNET_HEADER_SIZE) % 4);\r\nif (nPadding_Length == 4)\r\nnPadding_Length = 0;\r\nif (skb->len < nPadding_Length)\r\nreturn 0;\r\nskb_pull(skb, nPadding_Length);\r\n}\r\n}\r\nreturn rxb->nr_subframes;\r\n}\r\nstatic size_t rtllib_rx_get_hdrlen(struct rtllib_device *ieee,\r\nstruct sk_buff *skb,\r\nstruct rtllib_rx_stats *rx_stats)\r\n{\r\nstruct rtllib_hdr_4addr *hdr = (struct rtllib_hdr_4addr *)skb->data;\r\nu16 fc = le16_to_cpu(hdr->frame_ctl);\r\nsize_t hdrlen;\r\nhdrlen = rtllib_get_hdrlen(fc);\r\nif (HTCCheck(ieee, skb->data)) {\r\nif (net_ratelimit())\r\nnetdev_info(ieee->dev, "%s: find HTCControl!\n",\r\n__func__);\r\nhdrlen += 4;\r\nrx_stats->bContainHTC = true;\r\n}\r\nif (RTLLIB_QOS_HAS_SEQ(fc))\r\nrx_stats->bIsQosData = true;\r\nreturn hdrlen;\r\n}\r\nstatic int rtllib_rx_check_duplicate(struct rtllib_device *ieee,\r\nstruct sk_buff *skb, u8 multicast)\r\n{\r\nstruct rtllib_hdr_4addr *hdr = (struct rtllib_hdr_4addr *)skb->data;\r\nu16 fc, sc;\r\nu8 frag, type, stype;\r\nfc = le16_to_cpu(hdr->frame_ctl);\r\ntype = WLAN_FC_GET_TYPE(fc);\r\nstype = WLAN_FC_GET_STYPE(fc);\r\nsc = le16_to_cpu(hdr->seq_ctl);\r\nfrag = WLAN_GET_SEQ_FRAG(sc);\r\nif ((ieee->pHTInfo->bCurRxReorderEnable == false) ||\r\n!ieee->current_network.qos_data.active ||\r\n!IsDataFrame(skb->data) ||\r\nIsLegacyDataFrame(skb->data)) {\r\nif (!((type == RTLLIB_FTYPE_MGMT) &&\r\n(stype == RTLLIB_STYPE_BEACON))) {\r\nif (is_duplicate_packet(ieee, hdr))\r\nreturn -1;\r\n}\r\n} else {\r\nstruct rx_ts_record *pRxTS = NULL;\r\nif (GetTs(ieee, (struct ts_common_info **) &pRxTS, hdr->addr2,\r\n(u8)Frame_QoSTID((u8 *)(skb->data)), RX_DIR, true)) {\r\nif ((fc & (1<<11)) && (frag == pRxTS->RxLastFragNum) &&\r\n(WLAN_GET_SEQ_SEQ(sc) == pRxTS->RxLastSeqNum))\r\nreturn -1;\r\npRxTS->RxLastFragNum = frag;\r\npRxTS->RxLastSeqNum = WLAN_GET_SEQ_SEQ(sc);\r\n} else {\r\nnetdev_warn(ieee->dev, "%s(): No TS! Skip the check!\n",\r\n__func__);\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void rtllib_rx_extract_addr(struct rtllib_device *ieee,\r\nstruct rtllib_hdr_4addr *hdr, u8 *dst,\r\nu8 *src, u8 *bssid)\r\n{\r\nu16 fc = le16_to_cpu(hdr->frame_ctl);\r\nswitch (fc & (RTLLIB_FCTL_FROMDS | RTLLIB_FCTL_TODS)) {\r\ncase RTLLIB_FCTL_FROMDS:\r\nether_addr_copy(dst, hdr->addr1);\r\nether_addr_copy(src, hdr->addr3);\r\nether_addr_copy(bssid, hdr->addr2);\r\nbreak;\r\ncase RTLLIB_FCTL_TODS:\r\nether_addr_copy(dst, hdr->addr3);\r\nether_addr_copy(src, hdr->addr2);\r\nether_addr_copy(bssid, hdr->addr1);\r\nbreak;\r\ncase RTLLIB_FCTL_FROMDS | RTLLIB_FCTL_TODS:\r\nether_addr_copy(dst, hdr->addr3);\r\nether_addr_copy(src, hdr->addr4);\r\nether_addr_copy(bssid, ieee->current_network.bssid);\r\nbreak;\r\ndefault:\r\nether_addr_copy(dst, hdr->addr1);\r\nether_addr_copy(src, hdr->addr2);\r\nether_addr_copy(bssid, hdr->addr3);\r\nbreak;\r\n}\r\n}\r\nstatic int rtllib_rx_data_filter(struct rtllib_device *ieee, u16 fc,\r\nu8 *dst, u8 *src, u8 *bssid, u8 *addr2)\r\n{\r\nu8 type, stype;\r\ntype = WLAN_FC_GET_TYPE(fc);\r\nstype = WLAN_FC_GET_STYPE(fc);\r\nif (((fc & RTLLIB_FCTL_DSTODS) != RTLLIB_FCTL_DSTODS) &&\r\n!ether_addr_equal(ieee->current_network.bssid, bssid) &&\r\n!is_zero_ether_addr(ieee->current_network.bssid)) {\r\nreturn -1;\r\n}\r\nif (ieee->IntelPromiscuousModeInfo.bPromiscuousOn &&\r\nieee->IntelPromiscuousModeInfo.bFilterSourceStationFrame) {\r\nif ((fc & RTLLIB_FCTL_TODS) && !(fc & RTLLIB_FCTL_FROMDS) &&\r\n!ether_addr_equal(dst, ieee->current_network.bssid) &&\r\nether_addr_equal(bssid, ieee->current_network.bssid)) {\r\nreturn -1;\r\n}\r\n}\r\nif (!ieee->IntelPromiscuousModeInfo.bPromiscuousOn) {\r\nif (stype != RTLLIB_STYPE_DATA &&\r\nstype != RTLLIB_STYPE_DATA_CFACK &&\r\nstype != RTLLIB_STYPE_DATA_CFPOLL &&\r\nstype != RTLLIB_STYPE_DATA_CFACKPOLL &&\r\nstype != RTLLIB_STYPE_QOS_DATA) {\r\nif (stype != RTLLIB_STYPE_NULLFUNC)\r\nnetdev_dbg(ieee->dev,\r\n"RX: dropped data frame with no data (type=0x%02x, subtype=0x%02x)\n",\r\ntype, stype);\r\nreturn -1;\r\n}\r\n}\r\nif (ieee->iw_mode != IW_MODE_MESH) {\r\nif (!memcmp(src, ieee->dev->dev_addr, ETH_ALEN))\r\nreturn -1;\r\nif (is_multicast_ether_addr(dst)) {\r\nif (memcmp(bssid, ieee->current_network.bssid,\r\nETH_ALEN))\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtllib_rx_get_crypt(struct rtllib_device *ieee, struct sk_buff *skb,\r\nstruct lib80211_crypt_data **crypt, size_t hdrlen)\r\n{\r\nstruct rtllib_hdr_4addr *hdr = (struct rtllib_hdr_4addr *)skb->data;\r\nu16 fc = le16_to_cpu(hdr->frame_ctl);\r\nint idx = 0;\r\nif (ieee->host_decrypt) {\r\nif (skb->len >= hdrlen + 3)\r\nidx = skb->data[hdrlen + 3] >> 6;\r\n*crypt = ieee->crypt_info.crypt[idx];\r\nif (*crypt && ((*crypt)->ops == NULL ||\r\n(*crypt)->ops->decrypt_mpdu == NULL))\r\n*crypt = NULL;\r\nif (!*crypt && (fc & RTLLIB_FCTL_WEP)) {\r\nnetdev_dbg(ieee->dev,\r\n"Decryption failed (not set) (SA= %pM)\n",\r\nhdr->addr2);\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtllib_rx_decrypt(struct rtllib_device *ieee, struct sk_buff *skb,\r\nstruct rtllib_rx_stats *rx_stats,\r\nstruct lib80211_crypt_data *crypt, size_t hdrlen)\r\n{\r\nstruct rtllib_hdr_4addr *hdr;\r\nint keyidx = 0;\r\nu16 fc, sc;\r\nu8 frag;\r\nhdr = (struct rtllib_hdr_4addr *)skb->data;\r\nfc = le16_to_cpu(hdr->frame_ctl);\r\nsc = le16_to_cpu(hdr->seq_ctl);\r\nfrag = WLAN_GET_SEQ_FRAG(sc);\r\nif ((!rx_stats->Decrypted))\r\nieee->need_sw_enc = 1;\r\nelse\r\nieee->need_sw_enc = 0;\r\nkeyidx = rtllib_rx_frame_decrypt(ieee, skb, crypt);\r\nif (ieee->host_decrypt && (fc & RTLLIB_FCTL_WEP) && (keyidx < 0)) {\r\nnetdev_info(ieee->dev, "%s: decrypt frame error\n", __func__);\r\nreturn -1;\r\n}\r\nhdr = (struct rtllib_hdr_4addr *) skb->data;\r\nif ((frag != 0 || (fc & RTLLIB_FCTL_MOREFRAGS))) {\r\nint flen;\r\nstruct sk_buff *frag_skb = rtllib_frag_cache_get(ieee, hdr);\r\nnetdev_dbg(ieee->dev, "Rx Fragment received (%u)\n", frag);\r\nif (!frag_skb) {\r\nnetdev_dbg(ieee->dev,\r\n"Rx cannot get skb from fragment cache (morefrag=%d seq=%u frag=%u)\n",\r\n(fc & RTLLIB_FCTL_MOREFRAGS) != 0,\r\nWLAN_GET_SEQ_SEQ(sc), frag);\r\nreturn -1;\r\n}\r\nflen = skb->len;\r\nif (frag != 0)\r\nflen -= hdrlen;\r\nif (frag_skb->tail + flen > frag_skb->end) {\r\nnetdev_warn(ieee->dev,\r\n"%s: host decrypted and reassembled frame did not fit skb\n",\r\n__func__);\r\nrtllib_frag_cache_invalidate(ieee, hdr);\r\nreturn -1;\r\n}\r\nif (frag == 0) {\r\nmemcpy(skb_put(frag_skb, flen), skb->data, flen);\r\n} else {\r\nmemcpy(skb_put(frag_skb, flen), skb->data + hdrlen,\r\nflen);\r\n}\r\ndev_kfree_skb_any(skb);\r\nskb = NULL;\r\nif (fc & RTLLIB_FCTL_MOREFRAGS) {\r\nreturn -2;\r\n}\r\nskb = frag_skb;\r\nhdr = (struct rtllib_hdr_4addr *) skb->data;\r\nrtllib_frag_cache_invalidate(ieee, hdr);\r\n}\r\nif (ieee->host_decrypt && (fc & RTLLIB_FCTL_WEP) &&\r\nrtllib_rx_frame_decrypt_msdu(ieee, skb, keyidx, crypt)) {\r\nnetdev_info(ieee->dev, "%s: ==>decrypt msdu error\n", __func__);\r\nreturn -1;\r\n}\r\nhdr = (struct rtllib_hdr_4addr *) skb->data;\r\nif (crypt && !(fc & RTLLIB_FCTL_WEP) && !ieee->open_wep) {\r\nif (\r\nrtllib_is_eapol_frame(ieee, skb, hdrlen)) {\r\nstruct eapol *eap = (struct eapol *)(skb->data +\r\n24);\r\nnetdev_dbg(ieee->dev,\r\n"RX: IEEE 802.1X EAPOL frame: %s\n",\r\neap_get_type(eap->type));\r\n} else {\r\nnetdev_dbg(ieee->dev,\r\n"encryption configured, but RX frame not encrypted (SA= %pM)\n",\r\nhdr->addr2);\r\nreturn -1;\r\n}\r\n}\r\nif (crypt && !(fc & RTLLIB_FCTL_WEP) &&\r\nrtllib_is_eapol_frame(ieee, skb, hdrlen)) {\r\nstruct eapol *eap = (struct eapol *)(skb->data + 24);\r\nnetdev_dbg(ieee->dev, "RX: IEEE 802.1X EAPOL frame: %s\n",\r\neap_get_type(eap->type));\r\n}\r\nif (crypt && !(fc & RTLLIB_FCTL_WEP) && !ieee->open_wep &&\r\n!rtllib_is_eapol_frame(ieee, skb, hdrlen)) {\r\nnetdev_dbg(ieee->dev,\r\n"dropped unencrypted RX data frame from %pM (drop_unencrypted=1)\n",\r\nhdr->addr2);\r\nreturn -1;\r\n}\r\nif (rtllib_is_eapol_frame(ieee, skb, hdrlen))\r\nnetdev_warn(ieee->dev, "RX: IEEE802.1X EAPOL frame!\n");\r\nreturn 0;\r\n}\r\nstatic void rtllib_rx_check_leave_lps(struct rtllib_device *ieee, u8 unicast,\r\nu8 nr_subframes)\r\n{\r\nif (unicast) {\r\nif (ieee->state == RTLLIB_LINKED) {\r\nif (((ieee->LinkDetectInfo.NumRxUnicastOkInPeriod +\r\nieee->LinkDetectInfo.NumTxOkInPeriod) > 8) ||\r\n(ieee->LinkDetectInfo.NumRxUnicastOkInPeriod > 2)) {\r\nif (ieee->LeisurePSLeave)\r\nieee->LeisurePSLeave(ieee->dev);\r\n}\r\n}\r\n}\r\nieee->last_rx_ps_time = jiffies;\r\n}\r\nstatic void rtllib_rx_indicate_pkt_legacy(struct rtllib_device *ieee,\r\nstruct rtllib_rx_stats *rx_stats,\r\nstruct rtllib_rxb *rxb,\r\nu8 *dst,\r\nu8 *src)\r\n{\r\nstruct net_device *dev = ieee->dev;\r\nu16 ethertype;\r\nint i = 0;\r\nif (rxb == NULL) {\r\nnetdev_info(dev, "%s: rxb is NULL!!\n", __func__);\r\nreturn;\r\n}\r\nfor (i = 0; i < rxb->nr_subframes; i++) {\r\nstruct sk_buff *sub_skb = rxb->subframes[i];\r\nif (sub_skb) {\r\nethertype = (sub_skb->data[6] << 8) | sub_skb->data[7];\r\nif (sub_skb->len >= 8 &&\r\n((memcmp(sub_skb->data, rfc1042_header, SNAP_SIZE) == 0 &&\r\nethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||\r\nmemcmp(sub_skb->data, bridge_tunnel_header, SNAP_SIZE) == 0)) {\r\nskb_pull(sub_skb, SNAP_SIZE);\r\nether_addr_copy(skb_push(sub_skb, ETH_ALEN),\r\nsrc);\r\nether_addr_copy(skb_push(sub_skb, ETH_ALEN),\r\ndst);\r\n} else {\r\nu16 len;\r\nlen = sub_skb->len;\r\nmemcpy(skb_push(sub_skb, 2), &len, 2);\r\nether_addr_copy(skb_push(sub_skb, ETH_ALEN),\r\nsrc);\r\nether_addr_copy(skb_push(sub_skb, ETH_ALEN),\r\ndst);\r\n}\r\nieee->stats.rx_packets++;\r\nieee->stats.rx_bytes += sub_skb->len;\r\nif (is_multicast_ether_addr(dst))\r\nieee->stats.multicast++;\r\nmemset(sub_skb->cb, 0, sizeof(sub_skb->cb));\r\nsub_skb->protocol = eth_type_trans(sub_skb, dev);\r\nsub_skb->dev = dev;\r\nsub_skb->dev->stats.rx_packets++;\r\nsub_skb->dev->stats.rx_bytes += sub_skb->len;\r\nsub_skb->ip_summed = CHECKSUM_NONE;\r\nnetif_rx(sub_skb);\r\n}\r\n}\r\nkfree(rxb);\r\n}\r\nstatic int rtllib_rx_InfraAdhoc(struct rtllib_device *ieee, struct sk_buff *skb,\r\nstruct rtllib_rx_stats *rx_stats)\r\n{\r\nstruct net_device *dev = ieee->dev;\r\nstruct rtllib_hdr_4addr *hdr = (struct rtllib_hdr_4addr *)skb->data;\r\nstruct lib80211_crypt_data *crypt = NULL;\r\nstruct rtllib_rxb *rxb = NULL;\r\nstruct rx_ts_record *pTS = NULL;\r\nu16 fc, sc, SeqNum = 0;\r\nu8 type, stype, multicast = 0, unicast = 0, nr_subframes = 0, TID = 0;\r\nu8 *payload;\r\nu8 dst[ETH_ALEN];\r\nu8 src[ETH_ALEN];\r\nu8 bssid[ETH_ALEN] = {0};\r\nsize_t hdrlen = 0;\r\nbool bToOtherSTA = false;\r\nint ret = 0, i = 0;\r\nhdr = (struct rtllib_hdr_4addr *)skb->data;\r\nfc = le16_to_cpu(hdr->frame_ctl);\r\ntype = WLAN_FC_GET_TYPE(fc);\r\nstype = WLAN_FC_GET_STYPE(fc);\r\nsc = le16_to_cpu(hdr->seq_ctl);\r\nmulticast = is_multicast_ether_addr(hdr->addr1);\r\nunicast = !multicast;\r\nif (unicast && !ether_addr_equal(dev->dev_addr, hdr->addr1)) {\r\nif (ieee->bNetPromiscuousMode)\r\nbToOtherSTA = true;\r\nelse\r\ngoto rx_dropped;\r\n}\r\nhdrlen = rtllib_rx_get_hdrlen(ieee, skb, rx_stats);\r\nif (skb->len < hdrlen) {\r\nnetdev_info(dev,\r\n"%s():ERR!!! skb->len is smaller than hdrlen\n",\r\n__func__);\r\ngoto rx_dropped;\r\n}\r\nret = rtllib_rx_check_duplicate(ieee, skb, multicast);\r\nif (ret < 0)\r\ngoto rx_dropped;\r\nif (type == RTLLIB_FTYPE_CTL)\r\ngoto rx_dropped;\r\nif (type == RTLLIB_FTYPE_MGMT) {\r\nif (bToOtherSTA)\r\ngoto rx_dropped;\r\nif (rtllib_rx_frame_mgmt(ieee, skb, rx_stats, type, stype))\r\ngoto rx_dropped;\r\nelse\r\ngoto rx_exit;\r\n}\r\nif (!bToOtherSTA) {\r\nieee->LinkDetectInfo.NumRecvDataInPeriod++;\r\nieee->LinkDetectInfo.NumRxOkInPeriod++;\r\n}\r\nrtllib_rx_extract_addr(ieee, hdr, dst, src, bssid);\r\nret = rtllib_rx_data_filter(ieee, fc, dst, src, bssid, hdr->addr2);\r\nif (ret < 0)\r\ngoto rx_dropped;\r\nif (skb->len == hdrlen)\r\ngoto rx_dropped;\r\nif ((ieee->iw_mode == IW_MODE_INFRA) &&\r\n(ieee->sta_sleep == LPS_IS_SLEEP) &&\r\n(ieee->polling) && (!bToOtherSTA)) {\r\nif (WLAN_FC_MORE_DATA(fc)) {\r\nrtllib_sta_ps_send_pspoll_frame(ieee);\r\n} else {\r\nieee->polling = false;\r\n}\r\n}\r\nret = rtllib_rx_get_crypt(ieee, skb, &crypt, hdrlen);\r\nif (ret == -1)\r\ngoto rx_dropped;\r\nret = rtllib_rx_decrypt(ieee, skb, rx_stats, crypt, hdrlen);\r\nif (ret == -1)\r\ngoto rx_dropped;\r\nelse if (ret == -2)\r\ngoto rx_exit;\r\nhdr = (struct rtllib_hdr_4addr *) skb->data;\r\nif (ieee->current_network.qos_data.active && IsQoSDataFrame(skb->data)\r\n&& !is_multicast_ether_addr(hdr->addr1)\r\n&& (!bToOtherSTA)) {\r\nTID = Frame_QoSTID(skb->data);\r\nSeqNum = WLAN_GET_SEQ_SEQ(sc);\r\nGetTs(ieee, (struct ts_common_info **) &pTS, hdr->addr2, TID,\r\nRX_DIR, true);\r\nif (TID != 0 && TID != 3)\r\nieee->bis_any_nonbepkts = true;\r\n}\r\npayload = skb->data + hdrlen;\r\nrxb = kmalloc(sizeof(struct rtllib_rxb), GFP_ATOMIC);\r\nif (!rxb)\r\ngoto rx_dropped;\r\nif (parse_subframe(ieee, skb, rx_stats, rxb, src, dst) == 0) {\r\nfor (i = 0; i < rxb->nr_subframes; i++)\r\ndev_kfree_skb(rxb->subframes[i]);\r\nkfree(rxb);\r\nrxb = NULL;\r\ngoto rx_dropped;\r\n}\r\nif (!bToOtherSTA) {\r\nif (ieee->bIsAggregateFrame)\r\nnr_subframes = rxb->nr_subframes;\r\nelse\r\nnr_subframes = 1;\r\nif (unicast)\r\nieee->LinkDetectInfo.NumRxUnicastOkInPeriod += nr_subframes;\r\nrtllib_rx_check_leave_lps(ieee, unicast, nr_subframes);\r\n}\r\nif (ieee->pHTInfo->bCurRxReorderEnable == false || pTS == NULL ||\r\nbToOtherSTA)\r\nrtllib_rx_indicate_pkt_legacy(ieee, rx_stats, rxb, dst, src);\r\nelse\r\nRxReorderIndicatePacket(ieee, rxb, pTS, SeqNum);\r\ndev_kfree_skb(skb);\r\nrx_exit:\r\nreturn 1;\r\nrx_dropped:\r\nieee->stats.rx_dropped++;\r\nreturn 0;\r\n}\r\nstatic int rtllib_rx_Master(struct rtllib_device *ieee, struct sk_buff *skb,\r\nstruct rtllib_rx_stats *rx_stats)\r\n{\r\nreturn 0;\r\n}\r\nstatic int rtllib_rx_Monitor(struct rtllib_device *ieee, struct sk_buff *skb,\r\nstruct rtllib_rx_stats *rx_stats)\r\n{\r\nstruct rtllib_hdr_4addr *hdr = (struct rtllib_hdr_4addr *)skb->data;\r\nu16 fc = le16_to_cpu(hdr->frame_ctl);\r\nsize_t hdrlen = rtllib_get_hdrlen(fc);\r\nif (skb->len < hdrlen) {\r\nnetdev_info(ieee->dev,\r\n"%s():ERR!!! skb->len is smaller than hdrlen\n",\r\n__func__);\r\nreturn 0;\r\n}\r\nif (HTCCheck(ieee, skb->data)) {\r\nif (net_ratelimit())\r\nnetdev_info(ieee->dev, "%s: Find HTCControl!\n",\r\n__func__);\r\nhdrlen += 4;\r\n}\r\nrtllib_monitor_rx(ieee, skb, rx_stats, hdrlen);\r\nieee->stats.rx_packets++;\r\nieee->stats.rx_bytes += skb->len;\r\nreturn 1;\r\n}\r\nstatic int rtllib_rx_Mesh(struct rtllib_device *ieee, struct sk_buff *skb,\r\nstruct rtllib_rx_stats *rx_stats)\r\n{\r\nreturn 0;\r\n}\r\nint rtllib_rx(struct rtllib_device *ieee, struct sk_buff *skb,\r\nstruct rtllib_rx_stats *rx_stats)\r\n{\r\nint ret = 0;\r\nif (!ieee || !skb || !rx_stats) {\r\npr_info("%s: Input parameters NULL!\n", __func__);\r\ngoto rx_dropped;\r\n}\r\nif (skb->len < 10) {\r\nnetdev_info(ieee->dev, "%s: SKB length < 10\n", __func__);\r\ngoto rx_dropped;\r\n}\r\nswitch (ieee->iw_mode) {\r\ncase IW_MODE_ADHOC:\r\ncase IW_MODE_INFRA:\r\nret = rtllib_rx_InfraAdhoc(ieee, skb, rx_stats);\r\nbreak;\r\ncase IW_MODE_MASTER:\r\ncase IW_MODE_REPEAT:\r\nret = rtllib_rx_Master(ieee, skb, rx_stats);\r\nbreak;\r\ncase IW_MODE_MONITOR:\r\nret = rtllib_rx_Monitor(ieee, skb, rx_stats);\r\nbreak;\r\ncase IW_MODE_MESH:\r\nret = rtllib_rx_Mesh(ieee, skb, rx_stats);\r\nbreak;\r\ndefault:\r\nnetdev_info(ieee->dev, "%s: ERR iw mode!!!\n", __func__);\r\nbreak;\r\n}\r\nreturn ret;\r\nrx_dropped:\r\nif (ieee)\r\nieee->stats.rx_dropped++;\r\nreturn 0;\r\n}\r\nstatic int rtllib_verify_qos_info(struct rtllib_qos_information_element\r\n*info_element, int sub_type)\r\n{\r\nif (info_element->qui_subtype != sub_type)\r\nreturn -1;\r\nif (memcmp(info_element->qui, qos_oui, QOS_OUI_LEN))\r\nreturn -1;\r\nif (info_element->qui_type != QOS_OUI_TYPE)\r\nreturn -1;\r\nif (info_element->version != QOS_VERSION_1)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int rtllib_read_qos_param_element(struct rtllib_qos_parameter_info\r\n*element_param,\r\nstruct rtllib_info_element\r\n*info_element)\r\n{\r\nint ret = 0;\r\nu16 size = sizeof(struct rtllib_qos_parameter_info) - 2;\r\nif ((info_element == NULL) || (element_param == NULL))\r\nreturn -1;\r\nif (info_element->id == QOS_ELEMENT_ID && info_element->len == size) {\r\nmemcpy(element_param->info_element.qui, info_element->data,\r\ninfo_element->len);\r\nelement_param->info_element.elementID = info_element->id;\r\nelement_param->info_element.length = info_element->len;\r\n} else\r\nret = -1;\r\nif (ret == 0)\r\nret = rtllib_verify_qos_info(&element_param->info_element,\r\nQOS_OUI_PARAM_SUB_TYPE);\r\nreturn ret;\r\n}\r\nstatic int rtllib_read_qos_info_element(struct rtllib_qos_information_element\r\n*element_info,\r\nstruct rtllib_info_element\r\n*info_element)\r\n{\r\nint ret = 0;\r\nu16 size = sizeof(struct rtllib_qos_information_element) - 2;\r\nif (element_info == NULL)\r\nreturn -1;\r\nif (info_element == NULL)\r\nreturn -1;\r\nif ((info_element->id == QOS_ELEMENT_ID) &&\r\n(info_element->len == size)) {\r\nmemcpy(element_info->qui, info_element->data,\r\ninfo_element->len);\r\nelement_info->elementID = info_element->id;\r\nelement_info->length = info_element->len;\r\n} else\r\nret = -1;\r\nif (ret == 0)\r\nret = rtllib_verify_qos_info(element_info,\r\nQOS_OUI_INFO_SUB_TYPE);\r\nreturn ret;\r\n}\r\nstatic int rtllib_qos_convert_ac_to_parameters(struct rtllib_qos_parameter_info *param_elm,\r\nstruct rtllib_qos_data *qos_data)\r\n{\r\nstruct rtllib_qos_ac_parameter *ac_params;\r\nstruct rtllib_qos_parameters *qos_param = &(qos_data->parameters);\r\nint i;\r\nu8 aci;\r\nu8 acm;\r\nqos_data->wmm_acm = 0;\r\nfor (i = 0; i < QOS_QUEUE_NUM; i++) {\r\nac_params = &(param_elm->ac_params_record[i]);\r\naci = (ac_params->aci_aifsn & 0x60) >> 5;\r\nacm = (ac_params->aci_aifsn & 0x10) >> 4;\r\nif (aci >= QOS_QUEUE_NUM)\r\ncontinue;\r\nswitch (aci) {\r\ncase 1:\r\nif (acm)\r\nqos_data->wmm_acm |= (0x01<<0)|(0x01<<3);\r\nbreak;\r\ncase 2:\r\nif (acm)\r\nqos_data->wmm_acm |= (0x01<<4)|(0x01<<5);\r\nbreak;\r\ncase 3:\r\nif (acm)\r\nqos_data->wmm_acm |= (0x01<<6)|(0x01<<7);\r\nbreak;\r\ncase 0:\r\ndefault:\r\nif (acm)\r\nqos_data->wmm_acm |= (0x01<<1)|(0x01<<2);\r\nbreak;\r\n}\r\nqos_param->aifs[aci] = (ac_params->aci_aifsn) & 0x0f;\r\nqos_param->aifs[aci] = max_t(u8, qos_param->aifs[aci], 2);\r\nqos_param->cw_min[aci] = cpu_to_le16(ac_params->ecw_min_max &\r\n0x0F);\r\nqos_param->cw_max[aci] = cpu_to_le16((ac_params->ecw_min_max &\r\n0xF0) >> 4);\r\nqos_param->flag[aci] =\r\n(ac_params->aci_aifsn & 0x10) ? 0x01 : 0x00;\r\nqos_param->tx_op_limit[aci] = ac_params->tx_op_limit;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtllib_parse_qos_info_param_IE(struct rtllib_device *ieee,\r\nstruct rtllib_info_element\r\n*info_element,\r\nstruct rtllib_network *network)\r\n{\r\nint rc = 0;\r\nstruct rtllib_qos_information_element qos_info_element;\r\nrc = rtllib_read_qos_info_element(&qos_info_element, info_element);\r\nif (rc == 0) {\r\nnetwork->qos_data.param_count = qos_info_element.ac_info & 0x0F;\r\nnetwork->flags |= NETWORK_HAS_QOS_INFORMATION;\r\n} else {\r\nstruct rtllib_qos_parameter_info param_element;\r\nrc = rtllib_read_qos_param_element(&param_element,\r\ninfo_element);\r\nif (rc == 0) {\r\nrtllib_qos_convert_ac_to_parameters(&param_element,\r\n&(network->qos_data));\r\nnetwork->flags |= NETWORK_HAS_QOS_PARAMETERS;\r\nnetwork->qos_data.param_count =\r\nparam_element.info_element.ac_info & 0x0F;\r\n}\r\n}\r\nif (rc == 0) {\r\nnetdev_dbg(ieee->dev, "QoS is supported\n");\r\nnetwork->qos_data.supported = 1;\r\n}\r\nreturn rc;\r\n}\r\nstatic const char *get_info_element_string(u16 id)\r\n{\r\nswitch (id) {\r\ncase MFIE_TYPE_SSID:\r\nreturn "SSID";\r\ncase MFIE_TYPE_RATES:\r\nreturn "RATES";\r\ncase MFIE_TYPE_FH_SET:\r\nreturn "FH_SET";\r\ncase MFIE_TYPE_DS_SET:\r\nreturn "DS_SET";\r\ncase MFIE_TYPE_CF_SET:\r\nreturn "CF_SET";\r\ncase MFIE_TYPE_TIM:\r\nreturn "TIM";\r\ncase MFIE_TYPE_IBSS_SET:\r\nreturn "IBSS_SET";\r\ncase MFIE_TYPE_COUNTRY:\r\nreturn "COUNTRY";\r\ncase MFIE_TYPE_HOP_PARAMS:\r\nreturn "HOP_PARAMS";\r\ncase MFIE_TYPE_HOP_TABLE:\r\nreturn "HOP_TABLE";\r\ncase MFIE_TYPE_REQUEST:\r\nreturn "REQUEST";\r\ncase MFIE_TYPE_CHALLENGE:\r\nreturn "CHALLENGE";\r\ncase MFIE_TYPE_POWER_CONSTRAINT:\r\nreturn "POWER_CONSTRAINT";\r\ncase MFIE_TYPE_POWER_CAPABILITY:\r\nreturn "POWER_CAPABILITY";\r\ncase MFIE_TYPE_TPC_REQUEST:\r\nreturn "TPC_REQUEST";\r\ncase MFIE_TYPE_TPC_REPORT:\r\nreturn "TPC_REPORT";\r\ncase MFIE_TYPE_SUPP_CHANNELS:\r\nreturn "SUPP_CHANNELS";\r\ncase MFIE_TYPE_CSA:\r\nreturn "CSA";\r\ncase MFIE_TYPE_MEASURE_REQUEST:\r\nreturn "MEASURE_REQUEST";\r\ncase MFIE_TYPE_MEASURE_REPORT:\r\nreturn "MEASURE_REPORT";\r\ncase MFIE_TYPE_QUIET:\r\nreturn "QUIET";\r\ncase MFIE_TYPE_IBSS_DFS:\r\nreturn "IBSS_DFS";\r\ncase MFIE_TYPE_RSN:\r\nreturn "RSN";\r\ncase MFIE_TYPE_RATES_EX:\r\nreturn "RATES_EX";\r\ncase MFIE_TYPE_GENERIC:\r\nreturn "GENERIC";\r\ncase MFIE_TYPE_QOS_PARAMETER:\r\nreturn "QOS_PARAMETER";\r\ndefault:\r\nreturn "UNKNOWN";\r\n}\r\n}\r\nstatic inline void rtllib_extract_country_ie(\r\nstruct rtllib_device *ieee,\r\nstruct rtllib_info_element *info_element,\r\nstruct rtllib_network *network,\r\nu8 *addr2)\r\n{\r\nif (IS_DOT11D_ENABLE(ieee)) {\r\nif (info_element->len != 0) {\r\nmemcpy(network->CountryIeBuf, info_element->data,\r\ninfo_element->len);\r\nnetwork->CountryIeLen = info_element->len;\r\nif (!IS_COUNTRY_IE_VALID(ieee)) {\r\nif (rtllib_act_scanning(ieee, false) &&\r\nieee->FirstIe_InScan)\r\nnetdev_info(ieee->dev,\r\n"Received beacon ContryIE, SSID: <%s>\n",\r\nnetwork->ssid);\r\nDot11d_UpdateCountryIe(ieee, addr2,\r\ninfo_element->len,\r\ninfo_element->data);\r\n}\r\n}\r\nif (IS_EQUAL_CIE_SRC(ieee, addr2))\r\nUPDATE_CIE_WATCHDOG(ieee);\r\n}\r\n}\r\nstatic void rtllib_parse_mife_generic(struct rtllib_device *ieee,\r\nstruct rtllib_info_element *info_element,\r\nstruct rtllib_network *network,\r\nu16 *tmp_htcap_len,\r\nu16 *tmp_htinfo_len)\r\n{\r\nu16 ht_realtek_agg_len = 0;\r\nu8 ht_realtek_agg_buf[MAX_IE_LEN];\r\nif (!rtllib_parse_qos_info_param_IE(ieee, info_element, network))\r\nreturn;\r\nif (info_element->len >= 4 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x50 &&\r\ninfo_element->data[2] == 0xf2 &&\r\ninfo_element->data[3] == 0x01) {\r\nnetwork->wpa_ie_len = min(info_element->len + 2,\r\nMAX_WPA_IE_LEN);\r\nmemcpy(network->wpa_ie, info_element, network->wpa_ie_len);\r\nreturn;\r\n}\r\nif (info_element->len == 7 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0xe0 &&\r\ninfo_element->data[2] == 0x4c &&\r\ninfo_element->data[3] == 0x01 &&\r\ninfo_element->data[4] == 0x02)\r\nnetwork->Turbo_Enable = 1;\r\nif (*tmp_htcap_len == 0) {\r\nif (info_element->len >= 4 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x90 &&\r\ninfo_element->data[2] == 0x4c &&\r\ninfo_element->data[3] == 0x033) {\r\n*tmp_htcap_len = min_t(u8, info_element->len,\r\nMAX_IE_LEN);\r\nif (*tmp_htcap_len != 0) {\r\nnetwork->bssht.bdHTSpecVer = HT_SPEC_VER_EWC;\r\nnetwork->bssht.bdHTCapLen = min_t(u16, *tmp_htcap_len, sizeof(network->bssht.bdHTCapBuf));\r\nmemcpy(network->bssht.bdHTCapBuf,\r\ninfo_element->data,\r\nnetwork->bssht.bdHTCapLen);\r\n}\r\n}\r\nif (*tmp_htcap_len != 0) {\r\nnetwork->bssht.bdSupportHT = true;\r\nnetwork->bssht.bdHT1R = ((((struct ht_capab_ele *)(network->bssht.bdHTCapBuf))->MCS[1]) == 0);\r\n} else {\r\nnetwork->bssht.bdSupportHT = false;\r\nnetwork->bssht.bdHT1R = false;\r\n}\r\n}\r\nif (*tmp_htinfo_len == 0) {\r\nif (info_element->len >= 4 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x90 &&\r\ninfo_element->data[2] == 0x4c &&\r\ninfo_element->data[3] == 0x034) {\r\n*tmp_htinfo_len = min_t(u8, info_element->len,\r\nMAX_IE_LEN);\r\nif (*tmp_htinfo_len != 0) {\r\nnetwork->bssht.bdHTSpecVer = HT_SPEC_VER_EWC;\r\nnetwork->bssht.bdHTInfoLen = min_t(u16, *tmp_htinfo_len, sizeof(network->bssht.bdHTInfoBuf));\r\nmemcpy(network->bssht.bdHTInfoBuf,\r\ninfo_element->data,\r\nnetwork->bssht.bdHTInfoLen);\r\n}\r\n}\r\n}\r\nif (network->bssht.bdSupportHT) {\r\nif (info_element->len >= 4 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0xe0 &&\r\ninfo_element->data[2] == 0x4c &&\r\ninfo_element->data[3] == 0x02) {\r\nht_realtek_agg_len = min_t(u8, info_element->len,\r\nMAX_IE_LEN);\r\nmemcpy(ht_realtek_agg_buf, info_element->data,\r\ninfo_element->len);\r\n}\r\nif (ht_realtek_agg_len >= 5) {\r\nnetwork->realtek_cap_exit = true;\r\nnetwork->bssht.bdRT2RTAggregation = true;\r\nif ((ht_realtek_agg_buf[4] == 1) &&\r\n(ht_realtek_agg_buf[5] & 0x02))\r\nnetwork->bssht.bdRT2RTLongSlotTime = true;\r\nif ((ht_realtek_agg_buf[4] == 1) &&\r\n(ht_realtek_agg_buf[5] & RT_HT_CAP_USE_92SE))\r\nnetwork->bssht.RT2RT_HT_Mode |= RT_HT_CAP_USE_92SE;\r\n}\r\n}\r\nif (ht_realtek_agg_len >= 5) {\r\nif ((ht_realtek_agg_buf[5] & RT_HT_CAP_USE_SOFTAP))\r\nnetwork->bssht.RT2RT_HT_Mode |= RT_HT_CAP_USE_SOFTAP;\r\n}\r\nif ((info_element->len >= 3 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x05 &&\r\ninfo_element->data[2] == 0xb5) ||\r\n(info_element->len >= 3 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x0a &&\r\ninfo_element->data[2] == 0xf7) ||\r\n(info_element->len >= 3 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x10 &&\r\ninfo_element->data[2] == 0x18)) {\r\nnetwork->broadcom_cap_exist = true;\r\n}\r\nif (info_element->len >= 3 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x0c &&\r\ninfo_element->data[2] == 0x43)\r\nnetwork->ralink_cap_exist = true;\r\nif ((info_element->len >= 3 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x03 &&\r\ninfo_element->data[2] == 0x7f) ||\r\n(info_element->len >= 3 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x13 &&\r\ninfo_element->data[2] == 0x74))\r\nnetwork->atheros_cap_exist = true;\r\nif ((info_element->len >= 3 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x50 &&\r\ninfo_element->data[2] == 0x43))\r\nnetwork->marvell_cap_exist = true;\r\nif (info_element->len >= 3 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x40 &&\r\ninfo_element->data[2] == 0x96)\r\nnetwork->cisco_cap_exist = true;\r\nif (info_element->len >= 3 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x0a &&\r\ninfo_element->data[2] == 0xf5)\r\nnetwork->airgo_cap_exist = true;\r\nif (info_element->len > 4 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x40 &&\r\ninfo_element->data[2] == 0x96 &&\r\ninfo_element->data[3] == 0x01) {\r\nif (info_element->len == 6) {\r\nmemcpy(network->CcxRmState, &info_element[4], 2);\r\nif (network->CcxRmState[0] != 0)\r\nnetwork->bCcxRmEnable = true;\r\nelse\r\nnetwork->bCcxRmEnable = false;\r\nnetwork->MBssidMask = network->CcxRmState[1] & 0x07;\r\nif (network->MBssidMask != 0) {\r\nnetwork->bMBssidValid = true;\r\nnetwork->MBssidMask = 0xff <<\r\n(network->MBssidMask);\r\nether_addr_copy(network->MBssid,\r\nnetwork->bssid);\r\nnetwork->MBssid[5] &= network->MBssidMask;\r\n} else {\r\nnetwork->bMBssidValid = false;\r\n}\r\n} else {\r\nnetwork->bCcxRmEnable = false;\r\n}\r\n}\r\nif (info_element->len > 4 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x40 &&\r\ninfo_element->data[2] == 0x96 &&\r\ninfo_element->data[3] == 0x03) {\r\nif (info_element->len == 5) {\r\nnetwork->bWithCcxVerNum = true;\r\nnetwork->BssCcxVerNumber = info_element->data[4];\r\n} else {\r\nnetwork->bWithCcxVerNum = false;\r\nnetwork->BssCcxVerNumber = 0;\r\n}\r\n}\r\nif (info_element->len > 4 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x50 &&\r\ninfo_element->data[2] == 0xf2 &&\r\ninfo_element->data[3] == 0x04) {\r\nnetdev_dbg(ieee->dev, "MFIE_TYPE_WZC: %d bytes\n",\r\ninfo_element->len);\r\nnetwork->wzc_ie_len = min(info_element->len+2, MAX_WZC_IE_LEN);\r\nmemcpy(network->wzc_ie, info_element, network->wzc_ie_len);\r\n}\r\n}\r\nstatic void rtllib_parse_mfie_ht_cap(struct rtllib_info_element *info_element,\r\nstruct rtllib_network *network,\r\nu16 *tmp_htcap_len)\r\n{\r\nstruct bss_ht *ht = &network->bssht;\r\n*tmp_htcap_len = min_t(u8, info_element->len, MAX_IE_LEN);\r\nif (*tmp_htcap_len != 0) {\r\nht->bdHTSpecVer = HT_SPEC_VER_EWC;\r\nht->bdHTCapLen = min_t(u16, *tmp_htcap_len,\r\nsizeof(ht->bdHTCapBuf));\r\nmemcpy(ht->bdHTCapBuf, info_element->data, ht->bdHTCapLen);\r\nht->bdSupportHT = true;\r\nht->bdHT1R = ((((struct ht_capab_ele *)\r\nht->bdHTCapBuf))->MCS[1]) == 0;\r\nht->bdBandWidth = (enum ht_channel_width)\r\n(((struct ht_capab_ele *)\r\n(ht->bdHTCapBuf))->ChlWidth);\r\n} else {\r\nht->bdSupportHT = false;\r\nht->bdHT1R = false;\r\nht->bdBandWidth = HT_CHANNEL_WIDTH_20;\r\n}\r\n}\r\nint rtllib_parse_info_param(struct rtllib_device *ieee,\r\nstruct rtllib_info_element *info_element,\r\nu16 length,\r\nstruct rtllib_network *network,\r\nstruct rtllib_rx_stats *stats)\r\n{\r\nu8 i;\r\nshort offset;\r\nu16 tmp_htcap_len = 0;\r\nu16 tmp_htinfo_len = 0;\r\nchar rates_str[64];\r\nchar *p;\r\nwhile (length >= sizeof(*info_element)) {\r\nif (sizeof(*info_element) + info_element->len > length) {\r\nnetdev_dbg(ieee->dev,\r\n"Info elem: parse failed: info_element->len + 2 > left : info_element->len+2=%zd left=%d, id=%d.\n",\r\ninfo_element->len + sizeof(*info_element),\r\nlength, info_element->id);\r\nbreak;\r\n}\r\nswitch (info_element->id) {\r\ncase MFIE_TYPE_SSID:\r\nif (rtllib_is_empty_essid(info_element->data,\r\ninfo_element->len)) {\r\nnetwork->flags |= NETWORK_EMPTY_ESSID;\r\nbreak;\r\n}\r\nnetwork->ssid_len = min(info_element->len,\r\n(u8) IW_ESSID_MAX_SIZE);\r\nmemcpy(network->ssid, info_element->data,\r\nnetwork->ssid_len);\r\nif (network->ssid_len < IW_ESSID_MAX_SIZE)\r\nmemset(network->ssid + network->ssid_len, 0,\r\nIW_ESSID_MAX_SIZE - network->ssid_len);\r\nnetdev_dbg(ieee->dev, "MFIE_TYPE_SSID: '%s' len=%d.\n",\r\nnetwork->ssid, network->ssid_len);\r\nbreak;\r\ncase MFIE_TYPE_RATES:\r\np = rates_str;\r\nnetwork->rates_len = min(info_element->len,\r\nMAX_RATES_LENGTH);\r\nfor (i = 0; i < network->rates_len; i++) {\r\nnetwork->rates[i] = info_element->data[i];\r\np += snprintf(p, sizeof(rates_str) -\r\n(p - rates_str), "%02X ",\r\nnetwork->rates[i]);\r\nif (rtllib_is_ofdm_rate\r\n(info_element->data[i])) {\r\nnetwork->flags |= NETWORK_HAS_OFDM;\r\nif (info_element->data[i] &\r\nRTLLIB_BASIC_RATE_MASK)\r\nnetwork->flags &=\r\n~NETWORK_HAS_CCK;\r\n}\r\nif (rtllib_is_cck_rate\r\n(info_element->data[i])) {\r\nnetwork->flags |= NETWORK_HAS_CCK;\r\n}\r\n}\r\nnetdev_dbg(ieee->dev, "MFIE_TYPE_RATES: '%s' (%d)\n",\r\nrates_str, network->rates_len);\r\nbreak;\r\ncase MFIE_TYPE_RATES_EX:\r\np = rates_str;\r\nnetwork->rates_ex_len = min(info_element->len,\r\nMAX_RATES_EX_LENGTH);\r\nfor (i = 0; i < network->rates_ex_len; i++) {\r\nnetwork->rates_ex[i] = info_element->data[i];\r\np += snprintf(p, sizeof(rates_str) -\r\n(p - rates_str), "%02X ",\r\nnetwork->rates_ex[i]);\r\nif (rtllib_is_ofdm_rate\r\n(info_element->data[i])) {\r\nnetwork->flags |= NETWORK_HAS_OFDM;\r\nif (info_element->data[i] &\r\nRTLLIB_BASIC_RATE_MASK)\r\nnetwork->flags &=\r\n~NETWORK_HAS_CCK;\r\n}\r\n}\r\nnetdev_dbg(ieee->dev, "MFIE_TYPE_RATES_EX: '%s' (%d)\n",\r\nrates_str, network->rates_ex_len);\r\nbreak;\r\ncase MFIE_TYPE_DS_SET:\r\nnetdev_dbg(ieee->dev, "MFIE_TYPE_DS_SET: %d\n",\r\ninfo_element->data[0]);\r\nnetwork->channel = info_element->data[0];\r\nbreak;\r\ncase MFIE_TYPE_FH_SET:\r\nnetdev_dbg(ieee->dev, "MFIE_TYPE_FH_SET: ignored\n");\r\nbreak;\r\ncase MFIE_TYPE_CF_SET:\r\nnetdev_dbg(ieee->dev, "MFIE_TYPE_CF_SET: ignored\n");\r\nbreak;\r\ncase MFIE_TYPE_TIM:\r\nif (info_element->len < 4)\r\nbreak;\r\nnetwork->tim.tim_count = info_element->data[0];\r\nnetwork->tim.tim_period = info_element->data[1];\r\nnetwork->dtim_period = info_element->data[1];\r\nif (ieee->state != RTLLIB_LINKED)\r\nbreak;\r\nnetwork->last_dtim_sta_time = jiffies;\r\nnetwork->dtim_data = RTLLIB_DTIM_VALID;\r\nif (info_element->data[2] & 1)\r\nnetwork->dtim_data |= RTLLIB_DTIM_MBCAST;\r\noffset = (info_element->data[2] >> 1)*2;\r\nif (ieee->assoc_id < 8*offset ||\r\nieee->assoc_id > 8*(offset + info_element->len - 3))\r\nbreak;\r\noffset = (ieee->assoc_id / 8) - offset;\r\nif (info_element->data[3 + offset] &\r\n(1 << (ieee->assoc_id % 8)))\r\nnetwork->dtim_data |= RTLLIB_DTIM_UCAST;\r\nnetwork->listen_interval = network->dtim_period;\r\nbreak;\r\ncase MFIE_TYPE_ERP:\r\nnetwork->erp_value = info_element->data[0];\r\nnetwork->flags |= NETWORK_HAS_ERP_VALUE;\r\nnetdev_dbg(ieee->dev, "MFIE_TYPE_ERP_SET: %d\n",\r\nnetwork->erp_value);\r\nbreak;\r\ncase MFIE_TYPE_IBSS_SET:\r\nnetwork->atim_window = info_element->data[0];\r\nnetdev_dbg(ieee->dev, "MFIE_TYPE_IBSS_SET: %d\n",\r\nnetwork->atim_window);\r\nbreak;\r\ncase MFIE_TYPE_CHALLENGE:\r\nnetdev_dbg(ieee->dev, "MFIE_TYPE_CHALLENGE: ignored\n");\r\nbreak;\r\ncase MFIE_TYPE_GENERIC:\r\nnetdev_dbg(ieee->dev, "MFIE_TYPE_GENERIC: %d bytes\n",\r\ninfo_element->len);\r\nrtllib_parse_mife_generic(ieee, info_element, network,\r\n&tmp_htcap_len,\r\n&tmp_htinfo_len);\r\nbreak;\r\ncase MFIE_TYPE_RSN:\r\nnetdev_dbg(ieee->dev, "MFIE_TYPE_RSN: %d bytes\n",\r\ninfo_element->len);\r\nnetwork->rsn_ie_len = min(info_element->len + 2,\r\nMAX_WPA_IE_LEN);\r\nmemcpy(network->rsn_ie, info_element,\r\nnetwork->rsn_ie_len);\r\nbreak;\r\ncase MFIE_TYPE_HT_CAP:\r\nnetdev_dbg(ieee->dev, "MFIE_TYPE_HT_CAP: %d bytes\n",\r\ninfo_element->len);\r\nrtllib_parse_mfie_ht_cap(info_element, network,\r\n&tmp_htcap_len);\r\nbreak;\r\ncase MFIE_TYPE_HT_INFO:\r\nnetdev_dbg(ieee->dev, "MFIE_TYPE_HT_INFO: %d bytes\n",\r\ninfo_element->len);\r\ntmp_htinfo_len = min_t(u8, info_element->len,\r\nMAX_IE_LEN);\r\nif (tmp_htinfo_len) {\r\nnetwork->bssht.bdHTSpecVer = HT_SPEC_VER_IEEE;\r\nnetwork->bssht.bdHTInfoLen = tmp_htinfo_len >\r\nsizeof(network->bssht.bdHTInfoBuf) ?\r\nsizeof(network->bssht.bdHTInfoBuf) :\r\ntmp_htinfo_len;\r\nmemcpy(network->bssht.bdHTInfoBuf,\r\ninfo_element->data,\r\nnetwork->bssht.bdHTInfoLen);\r\n}\r\nbreak;\r\ncase MFIE_TYPE_AIRONET:\r\nnetdev_dbg(ieee->dev, "MFIE_TYPE_AIRONET: %d bytes\n",\r\ninfo_element->len);\r\nif (info_element->len > IE_CISCO_FLAG_POSITION) {\r\nnetwork->bWithAironetIE = true;\r\nif ((info_element->data[IE_CISCO_FLAG_POSITION]\r\n& SUPPORT_CKIP_MIC) ||\r\n(info_element->data[IE_CISCO_FLAG_POSITION]\r\n& SUPPORT_CKIP_PK))\r\nnetwork->bCkipSupported = true;\r\nelse\r\nnetwork->bCkipSupported = false;\r\n} else {\r\nnetwork->bWithAironetIE = false;\r\nnetwork->bCkipSupported = false;\r\n}\r\nbreak;\r\ncase MFIE_TYPE_QOS_PARAMETER:\r\nnetdev_err(ieee->dev,\r\n"QoS Error need to parse QOS_PARAMETER IE\n");\r\nbreak;\r\ncase MFIE_TYPE_COUNTRY:\r\nnetdev_dbg(ieee->dev, "MFIE_TYPE_COUNTRY: %d bytes\n",\r\ninfo_element->len);\r\nrtllib_extract_country_ie(ieee, info_element, network,\r\nnetwork->bssid);\r\nbreak;\r\ndefault:\r\nnetdev_dbg(ieee->dev,\r\n"Unsupported info element: %s (%d)\n",\r\nget_info_element_string(info_element->id),\r\ninfo_element->id);\r\nbreak;\r\n}\r\nlength -= sizeof(*info_element) + info_element->len;\r\ninfo_element =\r\n(struct rtllib_info_element *)&info_element->\r\ndata[info_element->len];\r\n}\r\nif (!network->atheros_cap_exist && !network->broadcom_cap_exist &&\r\n!network->cisco_cap_exist && !network->ralink_cap_exist &&\r\n!network->bssht.bdRT2RTAggregation)\r\nnetwork->unknown_cap_exist = true;\r\nelse\r\nnetwork->unknown_cap_exist = false;\r\nreturn 0;\r\n}\r\nstatic long rtllib_translate_todbm(u8 signal_strength_index)\r\n{\r\nlong signal_power;\r\nsignal_power = (long)((signal_strength_index + 1) >> 1);\r\nsignal_power -= 95;\r\nreturn signal_power;\r\n}\r\nstatic inline int rtllib_network_init(\r\nstruct rtllib_device *ieee,\r\nstruct rtllib_probe_response *beacon,\r\nstruct rtllib_network *network,\r\nstruct rtllib_rx_stats *stats)\r\n{\r\nmemset(&network->qos_data, 0, sizeof(struct rtllib_qos_data));\r\nether_addr_copy(network->bssid, beacon->header.addr3);\r\nnetwork->capability = le16_to_cpu(beacon->capability);\r\nnetwork->last_scanned = jiffies;\r\nnetwork->time_stamp[0] = beacon->time_stamp[0];\r\nnetwork->time_stamp[1] = beacon->time_stamp[1];\r\nnetwork->beacon_interval = le16_to_cpu(beacon->beacon_interval);\r\nnetwork->listen_interval = 0x0A;\r\nnetwork->rates_len = network->rates_ex_len = 0;\r\nnetwork->ssid_len = 0;\r\nnetwork->hidden_ssid_len = 0;\r\nmemset(network->hidden_ssid, 0, sizeof(network->hidden_ssid));\r\nnetwork->flags = 0;\r\nnetwork->atim_window = 0;\r\nnetwork->erp_value = (network->capability & WLAN_CAPABILITY_IBSS) ?\r\n0x3 : 0x0;\r\nnetwork->berp_info_valid = false;\r\nnetwork->broadcom_cap_exist = false;\r\nnetwork->ralink_cap_exist = false;\r\nnetwork->atheros_cap_exist = false;\r\nnetwork->cisco_cap_exist = false;\r\nnetwork->unknown_cap_exist = false;\r\nnetwork->realtek_cap_exit = false;\r\nnetwork->marvell_cap_exist = false;\r\nnetwork->airgo_cap_exist = false;\r\nnetwork->Turbo_Enable = 0;\r\nnetwork->SignalStrength = stats->SignalStrength;\r\nnetwork->RSSI = stats->SignalStrength;\r\nnetwork->CountryIeLen = 0;\r\nmemset(network->CountryIeBuf, 0, MAX_IE_LEN);\r\nHTInitializeBssDesc(&network->bssht);\r\nif (stats->freq == RTLLIB_52GHZ_BAND) {\r\nnetwork->channel = stats->received_channel;\r\n} else\r\nnetwork->flags |= NETWORK_HAS_CCK;\r\nnetwork->wpa_ie_len = 0;\r\nnetwork->rsn_ie_len = 0;\r\nnetwork->wzc_ie_len = 0;\r\nif (rtllib_parse_info_param(ieee,\r\nbeacon->info_element,\r\n(stats->len - sizeof(*beacon)),\r\nnetwork,\r\nstats))\r\nreturn 1;\r\nnetwork->mode = 0;\r\nif (stats->freq == RTLLIB_52GHZ_BAND)\r\nnetwork->mode = IEEE_A;\r\nelse {\r\nif (network->flags & NETWORK_HAS_OFDM)\r\nnetwork->mode |= IEEE_G;\r\nif (network->flags & NETWORK_HAS_CCK)\r\nnetwork->mode |= IEEE_B;\r\n}\r\nif (network->mode == 0) {\r\nnetdev_dbg(ieee->dev, "Filtered out '%s (%pM)' network.\n",\r\nescape_essid(network->ssid, network->ssid_len),\r\nnetwork->bssid);\r\nreturn 1;\r\n}\r\nif (network->bssht.bdSupportHT) {\r\nif (network->mode == IEEE_A)\r\nnetwork->mode = IEEE_N_5G;\r\nelse if (network->mode & (IEEE_G | IEEE_B))\r\nnetwork->mode = IEEE_N_24G;\r\n}\r\nif (rtllib_is_empty_essid(network->ssid, network->ssid_len))\r\nnetwork->flags |= NETWORK_EMPTY_ESSID;\r\nstats->signal = 30 + (stats->SignalStrength * 70) / 100;\r\nstats->noise = rtllib_translate_todbm((u8)(100-stats->signal)) - 25;\r\nmemcpy(&network->stats, stats, sizeof(network->stats));\r\nreturn 0;\r\n}\r\nstatic inline int is_same_network(struct rtllib_network *src,\r\nstruct rtllib_network *dst, u8 ssidbroad)\r\n{\r\nreturn (((src->ssid_len == dst->ssid_len) || (!ssidbroad)) &&\r\n(src->channel == dst->channel) &&\r\n!memcmp(src->bssid, dst->bssid, ETH_ALEN) &&\r\n(!memcmp(src->ssid, dst->ssid, src->ssid_len) ||\r\n(!ssidbroad)) &&\r\n((src->capability & WLAN_CAPABILITY_IBSS) ==\r\n(dst->capability & WLAN_CAPABILITY_IBSS)) &&\r\n((src->capability & WLAN_CAPABILITY_ESS) ==\r\n(dst->capability & WLAN_CAPABILITY_ESS)));\r\n}\r\nstatic inline void update_network(struct rtllib_device *ieee,\r\nstruct rtllib_network *dst,\r\nstruct rtllib_network *src)\r\n{\r\nint qos_active;\r\nu8 old_param;\r\nmemcpy(&dst->stats, &src->stats, sizeof(struct rtllib_rx_stats));\r\ndst->capability = src->capability;\r\nmemcpy(dst->rates, src->rates, src->rates_len);\r\ndst->rates_len = src->rates_len;\r\nmemcpy(dst->rates_ex, src->rates_ex, src->rates_ex_len);\r\ndst->rates_ex_len = src->rates_ex_len;\r\nif (src->ssid_len > 0) {\r\nif (dst->ssid_len == 0) {\r\nmemset(dst->hidden_ssid, 0, sizeof(dst->hidden_ssid));\r\ndst->hidden_ssid_len = src->ssid_len;\r\nmemcpy(dst->hidden_ssid, src->ssid, src->ssid_len);\r\n} else {\r\nmemset(dst->ssid, 0, dst->ssid_len);\r\ndst->ssid_len = src->ssid_len;\r\nmemcpy(dst->ssid, src->ssid, src->ssid_len);\r\n}\r\n}\r\ndst->mode = src->mode;\r\ndst->flags = src->flags;\r\ndst->time_stamp[0] = src->time_stamp[0];\r\ndst->time_stamp[1] = src->time_stamp[1];\r\nif (src->flags & NETWORK_HAS_ERP_VALUE) {\r\ndst->erp_value = src->erp_value;\r\ndst->berp_info_valid = src->berp_info_valid = true;\r\n}\r\ndst->beacon_interval = src->beacon_interval;\r\ndst->listen_interval = src->listen_interval;\r\ndst->atim_window = src->atim_window;\r\ndst->dtim_period = src->dtim_period;\r\ndst->dtim_data = src->dtim_data;\r\ndst->last_dtim_sta_time = src->last_dtim_sta_time;\r\nmemcpy(&dst->tim, &src->tim, sizeof(struct rtllib_tim_parameters));\r\ndst->bssht.bdSupportHT = src->bssht.bdSupportHT;\r\ndst->bssht.bdRT2RTAggregation = src->bssht.bdRT2RTAggregation;\r\ndst->bssht.bdHTCapLen = src->bssht.bdHTCapLen;\r\nmemcpy(dst->bssht.bdHTCapBuf, src->bssht.bdHTCapBuf,\r\nsrc->bssht.bdHTCapLen);\r\ndst->bssht.bdHTInfoLen = src->bssht.bdHTInfoLen;\r\nmemcpy(dst->bssht.bdHTInfoBuf, src->bssht.bdHTInfoBuf,\r\nsrc->bssht.bdHTInfoLen);\r\ndst->bssht.bdHTSpecVer = src->bssht.bdHTSpecVer;\r\ndst->bssht.bdRT2RTLongSlotTime = src->bssht.bdRT2RTLongSlotTime;\r\ndst->broadcom_cap_exist = src->broadcom_cap_exist;\r\ndst->ralink_cap_exist = src->ralink_cap_exist;\r\ndst->atheros_cap_exist = src->atheros_cap_exist;\r\ndst->realtek_cap_exit = src->realtek_cap_exit;\r\ndst->marvell_cap_exist = src->marvell_cap_exist;\r\ndst->cisco_cap_exist = src->cisco_cap_exist;\r\ndst->airgo_cap_exist = src->airgo_cap_exist;\r\ndst->unknown_cap_exist = src->unknown_cap_exist;\r\nmemcpy(dst->wpa_ie, src->wpa_ie, src->wpa_ie_len);\r\ndst->wpa_ie_len = src->wpa_ie_len;\r\nmemcpy(dst->rsn_ie, src->rsn_ie, src->rsn_ie_len);\r\ndst->rsn_ie_len = src->rsn_ie_len;\r\nmemcpy(dst->wzc_ie, src->wzc_ie, src->wzc_ie_len);\r\ndst->wzc_ie_len = src->wzc_ie_len;\r\ndst->last_scanned = jiffies;\r\nqos_active = dst->qos_data.active;\r\nold_param = dst->qos_data.param_count;\r\ndst->qos_data.supported = src->qos_data.supported;\r\nif (dst->flags & NETWORK_HAS_QOS_PARAMETERS)\r\nmemcpy(&dst->qos_data, &src->qos_data,\r\nsizeof(struct rtllib_qos_data));\r\nif (dst->qos_data.supported == 1) {\r\nif (dst->ssid_len)\r\nnetdev_dbg(ieee->dev,\r\n"QoS the network %s is QoS supported\n",\r\ndst->ssid);\r\nelse\r\nnetdev_dbg(ieee->dev,\r\n"QoS the network is QoS supported\n");\r\n}\r\ndst->qos_data.active = qos_active;\r\ndst->qos_data.old_param_count = old_param;\r\ndst->wmm_info = src->wmm_info;\r\nif (src->wmm_param[0].ac_aci_acm_aifsn ||\r\nsrc->wmm_param[1].ac_aci_acm_aifsn ||\r\nsrc->wmm_param[2].ac_aci_acm_aifsn ||\r\nsrc->wmm_param[3].ac_aci_acm_aifsn)\r\nmemcpy(dst->wmm_param, src->wmm_param, WME_AC_PRAM_LEN);\r\ndst->SignalStrength = src->SignalStrength;\r\ndst->RSSI = src->RSSI;\r\ndst->Turbo_Enable = src->Turbo_Enable;\r\ndst->CountryIeLen = src->CountryIeLen;\r\nmemcpy(dst->CountryIeBuf, src->CountryIeBuf, src->CountryIeLen);\r\ndst->bWithAironetIE = src->bWithAironetIE;\r\ndst->bCkipSupported = src->bCkipSupported;\r\nmemcpy(dst->CcxRmState, src->CcxRmState, 2);\r\ndst->bCcxRmEnable = src->bCcxRmEnable;\r\ndst->MBssidMask = src->MBssidMask;\r\ndst->bMBssidValid = src->bMBssidValid;\r\nmemcpy(dst->MBssid, src->MBssid, 6);\r\ndst->bWithCcxVerNum = src->bWithCcxVerNum;\r\ndst->BssCcxVerNumber = src->BssCcxVerNumber;\r\n}\r\nstatic inline int is_beacon(u16 fc)\r\n{\r\nreturn (WLAN_FC_GET_STYPE(fc) == RTLLIB_STYPE_BEACON);\r\n}\r\nstatic int IsPassiveChannel(struct rtllib_device *rtllib, u8 channel)\r\n{\r\nif (channel > MAX_CHANNEL_NUMBER) {\r\nnetdev_info(rtllib->dev, "%s(): Invalid Channel\n", __func__);\r\nreturn 0;\r\n}\r\nif (rtllib->active_channel_map[channel] == 2)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint rtllib_legal_channel(struct rtllib_device *rtllib, u8 channel)\r\n{\r\nif (channel > MAX_CHANNEL_NUMBER) {\r\nnetdev_info(rtllib->dev, "%s(): Invalid Channel\n", __func__);\r\nreturn 0;\r\n}\r\nif (rtllib->active_channel_map[channel] > 0)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline void rtllib_process_probe_response(\r\nstruct rtllib_device *ieee,\r\nstruct rtllib_probe_response *beacon,\r\nstruct rtllib_rx_stats *stats)\r\n{\r\nstruct rtllib_network *target;\r\nstruct rtllib_network *oldest = NULL;\r\nstruct rtllib_info_element *info_element = &beacon->info_element[0];\r\nunsigned long flags;\r\nshort renew;\r\nstruct rtllib_network *network = kzalloc(sizeof(struct rtllib_network),\r\nGFP_ATOMIC);\r\nu16 frame_ctl = le16_to_cpu(beacon->header.frame_ctl);\r\nif (!network)\r\nreturn;\r\nnetdev_dbg(ieee->dev,\r\n"'%s' ( %pM ): %c%c%c%c %c%c%c%c-%c%c%c%c %c%c%c%c\n",\r\nescape_essid(info_element->data, info_element->len),\r\nbeacon->header.addr3,\r\n(le16_to_cpu(beacon->capability) & (1<<0xf)) ? '1' : '0',\r\n(le16_to_cpu(beacon->capability) & (1<<0xe)) ? '1' : '0',\r\n(le16_to_cpu(beacon->capability) & (1<<0xd)) ? '1' : '0',\r\n(le16_to_cpu(beacon->capability) & (1<<0xc)) ? '1' : '0',\r\n(le16_to_cpu(beacon->capability) & (1<<0xb)) ? '1' : '0',\r\n(le16_to_cpu(beacon->capability) & (1<<0xa)) ? '1' : '0',\r\n(le16_to_cpu(beacon->capability) & (1<<0x9)) ? '1' : '0',\r\n(le16_to_cpu(beacon->capability) & (1<<0x8)) ? '1' : '0',\r\n(le16_to_cpu(beacon->capability) & (1<<0x7)) ? '1' : '0',\r\n(le16_to_cpu(beacon->capability) & (1<<0x6)) ? '1' : '0',\r\n(le16_to_cpu(beacon->capability) & (1<<0x5)) ? '1' : '0',\r\n(le16_to_cpu(beacon->capability) & (1<<0x4)) ? '1' : '0',\r\n(le16_to_cpu(beacon->capability) & (1<<0x3)) ? '1' : '0',\r\n(le16_to_cpu(beacon->capability) & (1<<0x2)) ? '1' : '0',\r\n(le16_to_cpu(beacon->capability) & (1<<0x1)) ? '1' : '0',\r\n(le16_to_cpu(beacon->capability) & (1<<0x0)) ? '1' : '0');\r\nif (rtllib_network_init(ieee, beacon, network, stats)) {\r\nnetdev_dbg(ieee->dev, "Dropped '%s' ( %pM) via %s.\n",\r\nescape_essid(info_element->data, info_element->len),\r\nbeacon->header.addr3,\r\nis_beacon(frame_ctl) ? "BEACON" : "PROBE RESPONSE");\r\ngoto free_network;\r\n}\r\nif (!rtllib_legal_channel(ieee, network->channel))\r\ngoto free_network;\r\nif (WLAN_FC_GET_STYPE(frame_ctl) == RTLLIB_STYPE_PROBE_RESP) {\r\nif (IsPassiveChannel(ieee, network->channel)) {\r\nnetdev_info(ieee->dev,\r\n"GetScanInfo(): For Global Domain, filter probe response at channel(%d).\n",\r\nnetwork->channel);\r\ngoto free_network;\r\n}\r\n}\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nif (is_same_network(&ieee->current_network, network,\r\n(network->ssid_len ? 1 : 0))) {\r\nupdate_network(ieee, &ieee->current_network, network);\r\nif ((ieee->current_network.mode == IEEE_N_24G ||\r\nieee->current_network.mode == IEEE_G)\r\n&& ieee->current_network.berp_info_valid) {\r\nif (ieee->current_network.erp_value & ERP_UseProtection)\r\nieee->current_network.buseprotection = true;\r\nelse\r\nieee->current_network.buseprotection = false;\r\n}\r\nif (is_beacon(frame_ctl)) {\r\nif (ieee->state >= RTLLIB_LINKED)\r\nieee->LinkDetectInfo.NumRecvBcnInPeriod++;\r\n}\r\n}\r\nlist_for_each_entry(target, &ieee->network_list, list) {\r\nif (is_same_network(target, network,\r\n(target->ssid_len ? 1 : 0)))\r\nbreak;\r\nif ((oldest == NULL) ||\r\n(target->last_scanned < oldest->last_scanned))\r\noldest = target;\r\n}\r\nif (&target->list == &ieee->network_list) {\r\nif (list_empty(&ieee->network_free_list)) {\r\nlist_del(&oldest->list);\r\ntarget = oldest;\r\nnetdev_dbg(ieee->dev,\r\n"Expired '%s' ( %pM) from network list.\n",\r\nescape_essid(target->ssid, target->ssid_len),\r\ntarget->bssid);\r\n} else {\r\ntarget = list_entry(ieee->network_free_list.next,\r\nstruct rtllib_network, list);\r\nlist_del(ieee->network_free_list.next);\r\n}\r\nnetdev_dbg(ieee->dev, "Adding '%s' ( %pM) via %s.\n",\r\nescape_essid(network->ssid, network->ssid_len),\r\nnetwork->bssid,\r\nis_beacon(frame_ctl) ? "BEACON" : "PROBE RESPONSE");\r\nmemcpy(target, network, sizeof(*target));\r\nlist_add_tail(&target->list, &ieee->network_list);\r\nif (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE)\r\nrtllib_softmac_new_net(ieee, network);\r\n} else {\r\nnetdev_dbg(ieee->dev, "Updating '%s' ( %pM) via %s.\n",\r\nescape_essid(target->ssid, target->ssid_len),\r\ntarget->bssid,\r\nis_beacon(frame_ctl) ? "BEACON" : "PROBE RESPONSE");\r\nrenew = !time_after(target->last_scanned + ieee->scan_age,\r\njiffies);\r\nif ((!target->ssid_len) &&\r\n(((network->ssid_len > 0) && (target->hidden_ssid_len == 0))\r\n|| ((ieee->current_network.ssid_len == network->ssid_len) &&\r\n(strncmp(ieee->current_network.ssid, network->ssid,\r\nnetwork->ssid_len) == 0) &&\r\n(ieee->state == RTLLIB_NOLINK))))\r\nrenew = 1;\r\nupdate_network(ieee, target, network);\r\nif (renew && (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE))\r\nrtllib_softmac_new_net(ieee, network);\r\n}\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\nif (is_beacon(frame_ctl) &&\r\nis_same_network(&ieee->current_network, network,\r\n(network->ssid_len ? 1 : 0)) &&\r\n(ieee->state == RTLLIB_LINKED)) {\r\nif (ieee->handle_beacon != NULL)\r\nieee->handle_beacon(ieee->dev, beacon,\r\n&ieee->current_network);\r\n}\r\nfree_network:\r\nkfree(network);\r\n}\r\nstatic void rtllib_rx_mgt(struct rtllib_device *ieee,\r\nstruct sk_buff *skb,\r\nstruct rtllib_rx_stats *stats)\r\n{\r\nstruct rtllib_hdr_4addr *header = (struct rtllib_hdr_4addr *)skb->data;\r\nif ((WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl)) !=\r\nRTLLIB_STYPE_PROBE_RESP) &&\r\n(WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl)) !=\r\nRTLLIB_STYPE_BEACON))\r\nieee->last_rx_ps_time = jiffies;\r\nswitch (WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl))) {\r\ncase RTLLIB_STYPE_BEACON:\r\nnetdev_dbg(ieee->dev, "received BEACON (%d)\n",\r\nWLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl)));\r\nrtllib_process_probe_response(\r\nieee, (struct rtllib_probe_response *)header,\r\nstats);\r\nif (ieee->sta_sleep || (ieee->ps != RTLLIB_PS_DISABLED &&\r\nieee->iw_mode == IW_MODE_INFRA &&\r\nieee->state == RTLLIB_LINKED))\r\ntasklet_schedule(&ieee->ps_task);\r\nbreak;\r\ncase RTLLIB_STYPE_PROBE_RESP:\r\nnetdev_dbg(ieee->dev, "received PROBE RESPONSE (%d)\n",\r\nWLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl)));\r\nrtllib_process_probe_response(ieee,\r\n(struct rtllib_probe_response *)header, stats);\r\nbreak;\r\ncase RTLLIB_STYPE_PROBE_REQ:\r\nnetdev_dbg(ieee->dev, "received PROBE RESQUEST (%d)\n",\r\nWLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl)));\r\nif ((ieee->softmac_features & IEEE_SOFTMAC_PROBERS) &&\r\n((ieee->iw_mode == IW_MODE_ADHOC ||\r\nieee->iw_mode == IW_MODE_MASTER) &&\r\nieee->state == RTLLIB_LINKED))\r\nrtllib_rx_probe_rq(ieee, skb);\r\nbreak;\r\n}\r\n}
