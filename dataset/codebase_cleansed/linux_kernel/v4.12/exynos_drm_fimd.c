static int fimd_enable_vblank(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct fimd_context *ctx = crtc->ctx;\r\nu32 val;\r\nif (ctx->suspended)\r\nreturn -EPERM;\r\nif (!test_and_set_bit(0, &ctx->irq_flags)) {\r\nval = readl(ctx->regs + VIDINTCON0);\r\nval |= VIDINTCON0_INT_ENABLE;\r\nif (ctx->i80_if) {\r\nval |= VIDINTCON0_INT_I80IFDONE;\r\nval |= VIDINTCON0_INT_SYSMAINCON;\r\nval &= ~VIDINTCON0_INT_SYSSUBCON;\r\n} else {\r\nval |= VIDINTCON0_INT_FRAME;\r\nval &= ~VIDINTCON0_FRAMESEL0_MASK;\r\nval |= VIDINTCON0_FRAMESEL0_FRONTPORCH;\r\nval &= ~VIDINTCON0_FRAMESEL1_MASK;\r\nval |= VIDINTCON0_FRAMESEL1_NONE;\r\n}\r\nwritel(val, ctx->regs + VIDINTCON0);\r\n}\r\nreturn 0;\r\n}\r\nstatic void fimd_disable_vblank(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct fimd_context *ctx = crtc->ctx;\r\nu32 val;\r\nif (ctx->suspended)\r\nreturn;\r\nif (test_and_clear_bit(0, &ctx->irq_flags)) {\r\nval = readl(ctx->regs + VIDINTCON0);\r\nval &= ~VIDINTCON0_INT_ENABLE;\r\nif (ctx->i80_if) {\r\nval &= ~VIDINTCON0_INT_I80IFDONE;\r\nval &= ~VIDINTCON0_INT_SYSMAINCON;\r\nval &= ~VIDINTCON0_INT_SYSSUBCON;\r\n} else\r\nval &= ~VIDINTCON0_INT_FRAME;\r\nwritel(val, ctx->regs + VIDINTCON0);\r\n}\r\n}\r\nstatic void fimd_wait_for_vblank(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct fimd_context *ctx = crtc->ctx;\r\nif (ctx->suspended)\r\nreturn;\r\natomic_set(&ctx->wait_vsync_event, 1);\r\nif (!wait_event_timeout(ctx->wait_vsync_queue,\r\n!atomic_read(&ctx->wait_vsync_event),\r\nHZ/20))\r\nDRM_DEBUG_KMS("vblank wait timed out.\n");\r\n}\r\nstatic void fimd_enable_video_output(struct fimd_context *ctx, unsigned int win,\r\nbool enable)\r\n{\r\nu32 val = readl(ctx->regs + WINCON(win));\r\nif (enable)\r\nval |= WINCONx_ENWIN;\r\nelse\r\nval &= ~WINCONx_ENWIN;\r\nwritel(val, ctx->regs + WINCON(win));\r\n}\r\nstatic void fimd_enable_shadow_channel_path(struct fimd_context *ctx,\r\nunsigned int win,\r\nbool enable)\r\n{\r\nu32 val = readl(ctx->regs + SHADOWCON);\r\nif (enable)\r\nval |= SHADOWCON_CHx_ENABLE(win);\r\nelse\r\nval &= ~SHADOWCON_CHx_ENABLE(win);\r\nwritel(val, ctx->regs + SHADOWCON);\r\n}\r\nstatic void fimd_clear_channels(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct fimd_context *ctx = crtc->ctx;\r\nunsigned int win, ch_enabled = 0;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\npm_runtime_get_sync(ctx->dev);\r\nclk_prepare_enable(ctx->bus_clk);\r\nclk_prepare_enable(ctx->lcd_clk);\r\nfor (win = 0; win < WINDOWS_NR; win++) {\r\nu32 val = readl(ctx->regs + WINCON(win));\r\nif (val & WINCONx_ENWIN) {\r\nfimd_enable_video_output(ctx, win, false);\r\nif (ctx->driver_data->has_shadowcon)\r\nfimd_enable_shadow_channel_path(ctx, win,\r\nfalse);\r\nch_enabled = 1;\r\n}\r\n}\r\nif (ch_enabled) {\r\nint pipe = ctx->pipe;\r\nctx->suspended = false;\r\nctx->pipe = -1;\r\nfimd_enable_vblank(ctx->crtc);\r\nfimd_wait_for_vblank(ctx->crtc);\r\nfimd_disable_vblank(ctx->crtc);\r\nctx->suspended = true;\r\nctx->pipe = pipe;\r\n}\r\nclk_disable_unprepare(ctx->lcd_clk);\r\nclk_disable_unprepare(ctx->bus_clk);\r\npm_runtime_put(ctx->dev);\r\n}\r\nstatic int fimd_atomic_check(struct exynos_drm_crtc *crtc,\r\nstruct drm_crtc_state *state)\r\n{\r\nstruct drm_display_mode *mode = &state->adjusted_mode;\r\nstruct fimd_context *ctx = crtc->ctx;\r\nunsigned long ideal_clk, lcd_rate;\r\nu32 clkdiv;\r\nif (mode->clock == 0) {\r\nDRM_INFO("Mode has zero clock value.\n");\r\nreturn -EINVAL;\r\n}\r\nideal_clk = mode->clock * 1000;\r\nif (ctx->i80_if) {\r\nideal_clk *= 2;\r\n}\r\nlcd_rate = clk_get_rate(ctx->lcd_clk);\r\nif (2 * lcd_rate < ideal_clk) {\r\nDRM_INFO("sclk_fimd clock too low(%lu) for requested pixel clock(%lu)\n",\r\nlcd_rate, ideal_clk);\r\nreturn -EINVAL;\r\n}\r\nclkdiv = DIV_ROUND_CLOSEST(lcd_rate, ideal_clk);\r\nif (clkdiv >= 0x200) {\r\nDRM_INFO("requested pixel clock(%lu) too low\n", ideal_clk);\r\nreturn -EINVAL;\r\n}\r\nctx->clkdiv = (clkdiv < 0x100) ? clkdiv : 0xff;\r\nreturn 0;\r\n}\r\nstatic void fimd_setup_trigger(struct fimd_context *ctx)\r\n{\r\nvoid __iomem *timing_base = ctx->regs + ctx->driver_data->timing_base;\r\nu32 trg_type = ctx->driver_data->trg_type;\r\nu32 val = readl(timing_base + TRIGCON);\r\nval &= ~(TRGMODE_ENABLE);\r\nif (trg_type == I80_HW_TRG) {\r\nif (ctx->driver_data->has_hw_trigger)\r\nval |= HWTRGEN_ENABLE | HWTRGMASK_ENABLE;\r\nif (ctx->driver_data->has_trigger_per_te)\r\nval |= HWTRIGEN_PER_ENABLE;\r\n} else {\r\nval |= TRGMODE_ENABLE;\r\n}\r\nwritel(val, timing_base + TRIGCON);\r\n}\r\nstatic void fimd_commit(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct fimd_context *ctx = crtc->ctx;\r\nstruct drm_display_mode *mode = &crtc->base.state->adjusted_mode;\r\nconst struct fimd_driver_data *driver_data = ctx->driver_data;\r\nvoid *timing_base = ctx->regs + driver_data->timing_base;\r\nu32 val;\r\nif (ctx->suspended)\r\nreturn;\r\nif (mode->htotal == 0 || mode->vtotal == 0)\r\nreturn;\r\nif (ctx->i80_if) {\r\nval = ctx->i80ifcon | I80IFEN_ENABLE;\r\nwritel(val, timing_base + I80IFCONFAx(0));\r\nwritel(0, timing_base + I80IFCONFBx(0));\r\nif (driver_data->has_vtsel && ctx->sysreg &&\r\nregmap_update_bits(ctx->sysreg,\r\ndriver_data->lcdblk_offset,\r\n0x3 << driver_data->lcdblk_vt_shift,\r\n0x1 << driver_data->lcdblk_vt_shift)) {\r\nDRM_ERROR("Failed to update sysreg for I80 i/f.\n");\r\nreturn;\r\n}\r\n} else {\r\nint vsync_len, vbpd, vfpd, hsync_len, hbpd, hfpd;\r\nu32 vidcon1;\r\nvidcon1 = ctx->vidcon1;\r\nif (mode->flags & DRM_MODE_FLAG_NVSYNC)\r\nvidcon1 |= VIDCON1_INV_VSYNC;\r\nif (mode->flags & DRM_MODE_FLAG_NHSYNC)\r\nvidcon1 |= VIDCON1_INV_HSYNC;\r\nwritel(vidcon1, ctx->regs + driver_data->timing_base + VIDCON1);\r\nvsync_len = mode->crtc_vsync_end - mode->crtc_vsync_start;\r\nvbpd = mode->crtc_vtotal - mode->crtc_vsync_end;\r\nvfpd = mode->crtc_vsync_start - mode->crtc_vdisplay;\r\nval = VIDTCON0_VBPD(vbpd - 1) |\r\nVIDTCON0_VFPD(vfpd - 1) |\r\nVIDTCON0_VSPW(vsync_len - 1);\r\nwritel(val, ctx->regs + driver_data->timing_base + VIDTCON0);\r\nhsync_len = mode->crtc_hsync_end - mode->crtc_hsync_start;\r\nhbpd = mode->crtc_htotal - mode->crtc_hsync_end;\r\nhfpd = mode->crtc_hsync_start - mode->crtc_hdisplay;\r\nval = VIDTCON1_HBPD(hbpd - 1) |\r\nVIDTCON1_HFPD(hfpd - 1) |\r\nVIDTCON1_HSPW(hsync_len - 1);\r\nwritel(val, ctx->regs + driver_data->timing_base + VIDTCON1);\r\n}\r\nif (driver_data->has_vidoutcon)\r\nwritel(ctx->vidout_con, timing_base + VIDOUT_CON);\r\nif (ctx->sysreg && regmap_update_bits(ctx->sysreg,\r\ndriver_data->lcdblk_offset,\r\n0x1 << driver_data->lcdblk_bypass_shift,\r\n0x1 << driver_data->lcdblk_bypass_shift)) {\r\nDRM_ERROR("Failed to update sysreg for bypass setting.\n");\r\nreturn;\r\n}\r\nif (driver_data->has_mic_bypass && ctx->sysreg &&\r\nregmap_update_bits(ctx->sysreg,\r\ndriver_data->lcdblk_offset,\r\n0x1 << driver_data->lcdblk_mic_bypass_shift,\r\n0x1 << driver_data->lcdblk_mic_bypass_shift)) {\r\nDRM_ERROR("Failed to update sysreg for bypass mic.\n");\r\nreturn;\r\n}\r\nval = VIDTCON2_LINEVAL(mode->vdisplay - 1) |\r\nVIDTCON2_HOZVAL(mode->hdisplay - 1) |\r\nVIDTCON2_LINEVAL_E(mode->vdisplay - 1) |\r\nVIDTCON2_HOZVAL_E(mode->hdisplay - 1);\r\nwritel(val, ctx->regs + driver_data->timing_base + VIDTCON2);\r\nfimd_setup_trigger(ctx);\r\nval = ctx->vidcon0;\r\nval |= VIDCON0_ENVID | VIDCON0_ENVID_F;\r\nif (ctx->driver_data->has_clksel)\r\nval |= VIDCON0_CLKSEL_LCD;\r\nif (ctx->clkdiv > 1)\r\nval |= VIDCON0_CLKVAL_F(ctx->clkdiv - 1) | VIDCON0_CLKDIR;\r\nwritel(val, ctx->regs + VIDCON0);\r\n}\r\nstatic void fimd_win_set_pixfmt(struct fimd_context *ctx, unsigned int win,\r\nuint32_t pixel_format, int width)\r\n{\r\nunsigned long val;\r\nval = WINCONx_ENWIN;\r\nif (ctx->driver_data->has_limited_fmt && !win) {\r\nif (pixel_format == DRM_FORMAT_ARGB8888)\r\npixel_format = DRM_FORMAT_XRGB8888;\r\n}\r\nswitch (pixel_format) {\r\ncase DRM_FORMAT_C8:\r\nval |= WINCON0_BPPMODE_8BPP_PALETTE;\r\nval |= WINCONx_BURSTLEN_8WORD;\r\nval |= WINCONx_BYTSWP;\r\nbreak;\r\ncase DRM_FORMAT_XRGB1555:\r\nval |= WINCON0_BPPMODE_16BPP_1555;\r\nval |= WINCONx_HAWSWP;\r\nval |= WINCONx_BURSTLEN_16WORD;\r\nbreak;\r\ncase DRM_FORMAT_RGB565:\r\nval |= WINCON0_BPPMODE_16BPP_565;\r\nval |= WINCONx_HAWSWP;\r\nval |= WINCONx_BURSTLEN_16WORD;\r\nbreak;\r\ncase DRM_FORMAT_XRGB8888:\r\nval |= WINCON0_BPPMODE_24BPP_888;\r\nval |= WINCONx_WSWP;\r\nval |= WINCONx_BURSTLEN_16WORD;\r\nbreak;\r\ncase DRM_FORMAT_ARGB8888:\r\nval |= WINCON1_BPPMODE_25BPP_A1888\r\n| WINCON1_BLD_PIX | WINCON1_ALPHA_SEL;\r\nval |= WINCONx_WSWP;\r\nval |= WINCONx_BURSTLEN_16WORD;\r\nbreak;\r\ndefault:\r\nDRM_DEBUG_KMS("invalid pixel size so using unpacked 24bpp.\n");\r\nval |= WINCON0_BPPMODE_24BPP_888;\r\nval |= WINCONx_WSWP;\r\nval |= WINCONx_BURSTLEN_16WORD;\r\nbreak;\r\n}\r\nif (width < MIN_FB_WIDTH_FOR_16WORD_BURST) {\r\nval &= ~WINCONx_BURSTLEN_MASK;\r\nval |= WINCONx_BURSTLEN_4WORD;\r\n}\r\nwritel(val, ctx->regs + WINCON(win));\r\nif (win != 0) {\r\nval = VIDISD14C_ALPHA0_R(0xf) |\r\nVIDISD14C_ALPHA0_G(0xf) |\r\nVIDISD14C_ALPHA0_B(0xf) |\r\nVIDISD14C_ALPHA1_R(0xf) |\r\nVIDISD14C_ALPHA1_G(0xf) |\r\nVIDISD14C_ALPHA1_B(0xf);\r\nwritel(val, ctx->regs + VIDOSD_C(win));\r\nval = VIDW_ALPHA_R(0xf) | VIDW_ALPHA_G(0xf) |\r\nVIDW_ALPHA_G(0xf);\r\nwritel(val, ctx->regs + VIDWnALPHA0(win));\r\nwritel(val, ctx->regs + VIDWnALPHA1(win));\r\n}\r\n}\r\nstatic void fimd_win_set_colkey(struct fimd_context *ctx, unsigned int win)\r\n{\r\nunsigned int keycon0 = 0, keycon1 = 0;\r\nkeycon0 = ~(WxKEYCON0_KEYBL_EN | WxKEYCON0_KEYEN_F |\r\nWxKEYCON0_DIRCON) | WxKEYCON0_COMPKEY(0);\r\nkeycon1 = WxKEYCON1_COLVAL(0xffffffff);\r\nwritel(keycon0, ctx->regs + WKEYCON0_BASE(win));\r\nwritel(keycon1, ctx->regs + WKEYCON1_BASE(win));\r\n}\r\nstatic void fimd_shadow_protect_win(struct fimd_context *ctx,\r\nunsigned int win, bool protect)\r\n{\r\nu32 reg, bits, val;\r\nif (ctx->driver_data->has_shadowcon) {\r\nreg = SHADOWCON;\r\nbits = SHADOWCON_WINx_PROTECT(win);\r\n} else {\r\nreg = PRTCON;\r\nbits = PRTCON_PROTECT;\r\n}\r\nval = readl(ctx->regs + reg);\r\nif (protect)\r\nval |= bits;\r\nelse\r\nval &= ~bits;\r\nwritel(val, ctx->regs + reg);\r\n}\r\nstatic void fimd_atomic_begin(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct fimd_context *ctx = crtc->ctx;\r\nint i;\r\nif (ctx->suspended)\r\nreturn;\r\nfor (i = 0; i < WINDOWS_NR; i++)\r\nfimd_shadow_protect_win(ctx, i, true);\r\n}\r\nstatic void fimd_atomic_flush(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct fimd_context *ctx = crtc->ctx;\r\nint i;\r\nif (ctx->suspended)\r\nreturn;\r\nfor (i = 0; i < WINDOWS_NR; i++)\r\nfimd_shadow_protect_win(ctx, i, false);\r\nexynos_crtc_handle_event(crtc);\r\n}\r\nstatic void fimd_update_plane(struct exynos_drm_crtc *crtc,\r\nstruct exynos_drm_plane *plane)\r\n{\r\nstruct exynos_drm_plane_state *state =\r\nto_exynos_plane_state(plane->base.state);\r\nstruct fimd_context *ctx = crtc->ctx;\r\nstruct drm_framebuffer *fb = state->base.fb;\r\ndma_addr_t dma_addr;\r\nunsigned long val, size, offset;\r\nunsigned int last_x, last_y, buf_offsize, line_size;\r\nunsigned int win = plane->index;\r\nunsigned int bpp = fb->format->cpp[0];\r\nunsigned int pitch = fb->pitches[0];\r\nif (ctx->suspended)\r\nreturn;\r\noffset = state->src.x * bpp;\r\noffset += state->src.y * pitch;\r\ndma_addr = exynos_drm_fb_dma_addr(fb, 0) + offset;\r\nval = (unsigned long)dma_addr;\r\nwritel(val, ctx->regs + VIDWx_BUF_START(win, 0));\r\nsize = pitch * state->crtc.h;\r\nval = (unsigned long)(dma_addr + size);\r\nwritel(val, ctx->regs + VIDWx_BUF_END(win, 0));\r\nDRM_DEBUG_KMS("start addr = 0x%lx, end addr = 0x%lx, size = 0x%lx\n",\r\n(unsigned long)dma_addr, val, size);\r\nDRM_DEBUG_KMS("ovl_width = %d, ovl_height = %d\n",\r\nstate->crtc.w, state->crtc.h);\r\nbuf_offsize = pitch - (state->crtc.w * bpp);\r\nline_size = state->crtc.w * bpp;\r\nval = VIDW_BUF_SIZE_OFFSET(buf_offsize) |\r\nVIDW_BUF_SIZE_PAGEWIDTH(line_size) |\r\nVIDW_BUF_SIZE_OFFSET_E(buf_offsize) |\r\nVIDW_BUF_SIZE_PAGEWIDTH_E(line_size);\r\nwritel(val, ctx->regs + VIDWx_BUF_SIZE(win, 0));\r\nval = VIDOSDxA_TOPLEFT_X(state->crtc.x) |\r\nVIDOSDxA_TOPLEFT_Y(state->crtc.y) |\r\nVIDOSDxA_TOPLEFT_X_E(state->crtc.x) |\r\nVIDOSDxA_TOPLEFT_Y_E(state->crtc.y);\r\nwritel(val, ctx->regs + VIDOSD_A(win));\r\nlast_x = state->crtc.x + state->crtc.w;\r\nif (last_x)\r\nlast_x--;\r\nlast_y = state->crtc.y + state->crtc.h;\r\nif (last_y)\r\nlast_y--;\r\nval = VIDOSDxB_BOTRIGHT_X(last_x) | VIDOSDxB_BOTRIGHT_Y(last_y) |\r\nVIDOSDxB_BOTRIGHT_X_E(last_x) | VIDOSDxB_BOTRIGHT_Y_E(last_y);\r\nwritel(val, ctx->regs + VIDOSD_B(win));\r\nDRM_DEBUG_KMS("osd pos: tx = %d, ty = %d, bx = %d, by = %d\n",\r\nstate->crtc.x, state->crtc.y, last_x, last_y);\r\nif (win != 3 && win != 4) {\r\nu32 offset = VIDOSD_D(win);\r\nif (win == 0)\r\noffset = VIDOSD_C(win);\r\nval = state->crtc.w * state->crtc.h;\r\nwritel(val, ctx->regs + offset);\r\nDRM_DEBUG_KMS("osd size = 0x%x\n", (unsigned int)val);\r\n}\r\nfimd_win_set_pixfmt(ctx, win, fb->format->format, state->src.w);\r\nif (win != 0)\r\nfimd_win_set_colkey(ctx, win);\r\nfimd_enable_video_output(ctx, win, true);\r\nif (ctx->driver_data->has_shadowcon)\r\nfimd_enable_shadow_channel_path(ctx, win, true);\r\nif (ctx->i80_if)\r\natomic_set(&ctx->win_updated, 1);\r\n}\r\nstatic void fimd_disable_plane(struct exynos_drm_crtc *crtc,\r\nstruct exynos_drm_plane *plane)\r\n{\r\nstruct fimd_context *ctx = crtc->ctx;\r\nunsigned int win = plane->index;\r\nif (ctx->suspended)\r\nreturn;\r\nfimd_enable_video_output(ctx, win, false);\r\nif (ctx->driver_data->has_shadowcon)\r\nfimd_enable_shadow_channel_path(ctx, win, false);\r\n}\r\nstatic void fimd_enable(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct fimd_context *ctx = crtc->ctx;\r\nif (!ctx->suspended)\r\nreturn;\r\nctx->suspended = false;\r\npm_runtime_get_sync(ctx->dev);\r\nif (test_and_clear_bit(0, &ctx->irq_flags))\r\nfimd_enable_vblank(ctx->crtc);\r\nfimd_commit(ctx->crtc);\r\n}\r\nstatic void fimd_disable(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct fimd_context *ctx = crtc->ctx;\r\nint i;\r\nif (ctx->suspended)\r\nreturn;\r\nfor (i = 0; i < WINDOWS_NR; i++)\r\nfimd_disable_plane(crtc, &ctx->planes[i]);\r\nfimd_enable_vblank(crtc);\r\nfimd_wait_for_vblank(crtc);\r\nfimd_disable_vblank(crtc);\r\nwritel(0, ctx->regs + VIDCON0);\r\npm_runtime_put_sync(ctx->dev);\r\nctx->suspended = true;\r\n}\r\nstatic void fimd_trigger(struct device *dev)\r\n{\r\nstruct fimd_context *ctx = dev_get_drvdata(dev);\r\nconst struct fimd_driver_data *driver_data = ctx->driver_data;\r\nvoid *timing_base = ctx->regs + driver_data->timing_base;\r\nu32 reg;\r\nif (atomic_read(&ctx->triggering))\r\nreturn;\r\natomic_set(&ctx->triggering, 1);\r\nreg = readl(timing_base + TRIGCON);\r\nreg |= (TRGMODE_ENABLE | SWTRGCMD_ENABLE);\r\nwritel(reg, timing_base + TRIGCON);\r\nif (!test_bit(0, &ctx->irq_flags))\r\natomic_set(&ctx->triggering, 0);\r\n}\r\nstatic void fimd_te_handler(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct fimd_context *ctx = crtc->ctx;\r\nu32 trg_type = ctx->driver_data->trg_type;\r\nif (ctx->pipe < 0 || !ctx->drm_dev)\r\nreturn;\r\nif (trg_type == I80_HW_TRG)\r\ngoto out;\r\nif (atomic_add_unless(&ctx->win_updated, -1, 0))\r\nfimd_trigger(ctx->dev);\r\nout:\r\nif (atomic_read(&ctx->wait_vsync_event)) {\r\natomic_set(&ctx->wait_vsync_event, 0);\r\nwake_up(&ctx->wait_vsync_queue);\r\n}\r\nif (test_bit(0, &ctx->irq_flags))\r\ndrm_crtc_handle_vblank(&ctx->crtc->base);\r\n}\r\nstatic void fimd_dp_clock_enable(struct exynos_drm_clk *clk, bool enable)\r\n{\r\nstruct fimd_context *ctx = container_of(clk, struct fimd_context,\r\ndp_clk);\r\nu32 val = enable ? DP_MIE_CLK_DP_ENABLE : DP_MIE_CLK_DISABLE;\r\nwritel(val, ctx->regs + DP_MIE_CLKCON);\r\n}\r\nstatic irqreturn_t fimd_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct fimd_context *ctx = (struct fimd_context *)dev_id;\r\nu32 val, clear_bit;\r\nval = readl(ctx->regs + VIDINTCON1);\r\nclear_bit = ctx->i80_if ? VIDINTCON1_INT_I80 : VIDINTCON1_INT_FRAME;\r\nif (val & clear_bit)\r\nwritel(clear_bit, ctx->regs + VIDINTCON1);\r\nif (ctx->pipe < 0 || !ctx->drm_dev)\r\ngoto out;\r\nif (!ctx->i80_if)\r\ndrm_crtc_handle_vblank(&ctx->crtc->base);\r\nif (ctx->i80_if) {\r\natomic_set(&ctx->triggering, 0);\r\n} else {\r\nif (atomic_read(&ctx->wait_vsync_event)) {\r\natomic_set(&ctx->wait_vsync_event, 0);\r\nwake_up(&ctx->wait_vsync_queue);\r\n}\r\n}\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int fimd_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct fimd_context *ctx = dev_get_drvdata(dev);\r\nstruct drm_device *drm_dev = data;\r\nstruct exynos_drm_private *priv = drm_dev->dev_private;\r\nstruct exynos_drm_plane *exynos_plane;\r\nunsigned int i;\r\nint ret;\r\nctx->drm_dev = drm_dev;\r\nctx->pipe = priv->pipe++;\r\nfor (i = 0; i < WINDOWS_NR; i++) {\r\nctx->configs[i].pixel_formats = fimd_formats;\r\nctx->configs[i].num_pixel_formats = ARRAY_SIZE(fimd_formats);\r\nctx->configs[i].zpos = i;\r\nctx->configs[i].type = fimd_win_types[i];\r\nret = exynos_plane_init(drm_dev, &ctx->planes[i], i,\r\n1 << ctx->pipe, &ctx->configs[i]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nexynos_plane = &ctx->planes[DEFAULT_WIN];\r\nctx->crtc = exynos_drm_crtc_create(drm_dev, &exynos_plane->base,\r\nctx->pipe, EXYNOS_DISPLAY_TYPE_LCD,\r\n&fimd_crtc_ops, ctx);\r\nif (IS_ERR(ctx->crtc))\r\nreturn PTR_ERR(ctx->crtc);\r\nif (ctx->driver_data->has_dp_clk) {\r\nctx->dp_clk.enable = fimd_dp_clock_enable;\r\nctx->crtc->pipe_clk = &ctx->dp_clk;\r\n}\r\nif (ctx->encoder)\r\nexynos_dpi_bind(drm_dev, ctx->encoder);\r\nif (is_drm_iommu_supported(drm_dev))\r\nfimd_clear_channels(ctx->crtc);\r\nret = drm_iommu_attach_device(drm_dev, dev);\r\nif (ret)\r\npriv->pipe--;\r\nreturn ret;\r\n}\r\nstatic void fimd_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct fimd_context *ctx = dev_get_drvdata(dev);\r\nfimd_disable(ctx->crtc);\r\ndrm_iommu_detach_device(ctx->drm_dev, ctx->dev);\r\nif (ctx->encoder)\r\nexynos_dpi_remove(ctx->encoder);\r\n}\r\nstatic int fimd_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct fimd_context *ctx;\r\nstruct device_node *i80_if_timings;\r\nstruct resource *res;\r\nint ret;\r\nif (!dev->of_node)\r\nreturn -ENODEV;\r\nctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nctx->dev = dev;\r\nctx->suspended = true;\r\nctx->driver_data = of_device_get_match_data(dev);\r\nif (of_property_read_bool(dev->of_node, "samsung,invert-vden"))\r\nctx->vidcon1 |= VIDCON1_INV_VDEN;\r\nif (of_property_read_bool(dev->of_node, "samsung,invert-vclk"))\r\nctx->vidcon1 |= VIDCON1_INV_VCLK;\r\ni80_if_timings = of_get_child_by_name(dev->of_node, "i80-if-timings");\r\nif (i80_if_timings) {\r\nu32 val;\r\nctx->i80_if = true;\r\nif (ctx->driver_data->has_vidoutcon)\r\nctx->vidout_con |= VIDOUT_CON_F_I80_LDI0;\r\nelse\r\nctx->vidcon0 |= VIDCON0_VIDOUT_I80_LDI0;\r\nctx->vidcon0 |= VIDCON0_DSI_EN;\r\nif (of_property_read_u32(i80_if_timings, "cs-setup", &val))\r\nval = 0;\r\nctx->i80ifcon = LCD_CS_SETUP(val);\r\nif (of_property_read_u32(i80_if_timings, "wr-setup", &val))\r\nval = 0;\r\nctx->i80ifcon |= LCD_WR_SETUP(val);\r\nif (of_property_read_u32(i80_if_timings, "wr-active", &val))\r\nval = 1;\r\nctx->i80ifcon |= LCD_WR_ACTIVE(val);\r\nif (of_property_read_u32(i80_if_timings, "wr-hold", &val))\r\nval = 0;\r\nctx->i80ifcon |= LCD_WR_HOLD(val);\r\n}\r\nof_node_put(i80_if_timings);\r\nctx->sysreg = syscon_regmap_lookup_by_phandle(dev->of_node,\r\n"samsung,sysreg");\r\nif (IS_ERR(ctx->sysreg)) {\r\ndev_warn(dev, "failed to get system register.\n");\r\nctx->sysreg = NULL;\r\n}\r\nctx->bus_clk = devm_clk_get(dev, "fimd");\r\nif (IS_ERR(ctx->bus_clk)) {\r\ndev_err(dev, "failed to get bus clock\n");\r\nreturn PTR_ERR(ctx->bus_clk);\r\n}\r\nctx->lcd_clk = devm_clk_get(dev, "sclk_fimd");\r\nif (IS_ERR(ctx->lcd_clk)) {\r\ndev_err(dev, "failed to get lcd clock\n");\r\nreturn PTR_ERR(ctx->lcd_clk);\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nctx->regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(ctx->regs))\r\nreturn PTR_ERR(ctx->regs);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_IRQ,\r\nctx->i80_if ? "lcd_sys" : "vsync");\r\nif (!res) {\r\ndev_err(dev, "irq request failed.\n");\r\nreturn -ENXIO;\r\n}\r\nret = devm_request_irq(dev, res->start, fimd_irq_handler,\r\n0, "drm_fimd", ctx);\r\nif (ret) {\r\ndev_err(dev, "irq request failed.\n");\r\nreturn ret;\r\n}\r\ninit_waitqueue_head(&ctx->wait_vsync_queue);\r\natomic_set(&ctx->wait_vsync_event, 0);\r\nplatform_set_drvdata(pdev, ctx);\r\nctx->encoder = exynos_dpi_probe(dev);\r\nif (IS_ERR(ctx->encoder))\r\nreturn PTR_ERR(ctx->encoder);\r\npm_runtime_enable(dev);\r\nret = component_add(dev, &fimd_component_ops);\r\nif (ret)\r\ngoto err_disable_pm_runtime;\r\nreturn ret;\r\nerr_disable_pm_runtime:\r\npm_runtime_disable(dev);\r\nreturn ret;\r\n}\r\nstatic int fimd_remove(struct platform_device *pdev)\r\n{\r\npm_runtime_disable(&pdev->dev);\r\ncomponent_del(&pdev->dev, &fimd_component_ops);\r\nreturn 0;\r\n}\r\nstatic int exynos_fimd_suspend(struct device *dev)\r\n{\r\nstruct fimd_context *ctx = dev_get_drvdata(dev);\r\nclk_disable_unprepare(ctx->lcd_clk);\r\nclk_disable_unprepare(ctx->bus_clk);\r\nreturn 0;\r\n}\r\nstatic int exynos_fimd_resume(struct device *dev)\r\n{\r\nstruct fimd_context *ctx = dev_get_drvdata(dev);\r\nint ret;\r\nret = clk_prepare_enable(ctx->bus_clk);\r\nif (ret < 0) {\r\nDRM_ERROR("Failed to prepare_enable the bus clk [%d]\n", ret);\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(ctx->lcd_clk);\r\nif (ret < 0) {\r\nDRM_ERROR("Failed to prepare_enable the lcd clk [%d]\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
