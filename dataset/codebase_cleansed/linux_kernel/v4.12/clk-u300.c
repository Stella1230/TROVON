static void syscon_block_reset_enable(struct clk_syscon *sclk)\r\n{\r\nunsigned long iflags;\r\nu16 val;\r\nif (!sclk->res_reg)\r\nreturn;\r\nspin_lock_irqsave(&syscon_resetreg_lock, iflags);\r\nval = readw(sclk->res_reg);\r\nval |= BIT(sclk->res_bit);\r\nwritew(val, sclk->res_reg);\r\nspin_unlock_irqrestore(&syscon_resetreg_lock, iflags);\r\nsclk->reset = true;\r\n}\r\nstatic void syscon_block_reset_disable(struct clk_syscon *sclk)\r\n{\r\nunsigned long iflags;\r\nu16 val;\r\nif (!sclk->res_reg)\r\nreturn;\r\nspin_lock_irqsave(&syscon_resetreg_lock, iflags);\r\nval = readw(sclk->res_reg);\r\nval &= ~BIT(sclk->res_bit);\r\nwritew(val, sclk->res_reg);\r\nspin_unlock_irqrestore(&syscon_resetreg_lock, iflags);\r\nsclk->reset = false;\r\n}\r\nstatic int syscon_clk_prepare(struct clk_hw *hw)\r\n{\r\nstruct clk_syscon *sclk = to_syscon(hw);\r\nif (sclk->reset)\r\nsyscon_block_reset_disable(sclk);\r\nreturn 0;\r\n}\r\nstatic void syscon_clk_unprepare(struct clk_hw *hw)\r\n{\r\nstruct clk_syscon *sclk = to_syscon(hw);\r\nif (sclk->clk_val == U300_SYSCON_SBCER_UART_CLK_EN)\r\nreturn;\r\nif (!sclk->reset)\r\nsyscon_block_reset_enable(sclk);\r\n}\r\nstatic int syscon_clk_enable(struct clk_hw *hw)\r\n{\r\nstruct clk_syscon *sclk = to_syscon(hw);\r\nif (sclk->hw_ctrld)\r\nreturn 0;\r\nif (sclk->clk_val == 0xFFFFU)\r\nreturn 0;\r\nwritew(sclk->clk_val, syscon_vbase + U300_SYSCON_SBCER);\r\nreturn 0;\r\n}\r\nstatic void syscon_clk_disable(struct clk_hw *hw)\r\n{\r\nstruct clk_syscon *sclk = to_syscon(hw);\r\nif (sclk->hw_ctrld)\r\nreturn;\r\nif (sclk->clk_val == 0xFFFFU)\r\nreturn;\r\nif (sclk->clk_val == U300_SYSCON_SBCER_UART_CLK_EN)\r\nreturn;\r\nwritew(sclk->clk_val, syscon_vbase + U300_SYSCON_SBCDR);\r\n}\r\nstatic int syscon_clk_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct clk_syscon *sclk = to_syscon(hw);\r\nu16 val;\r\nif (!sclk->en_reg)\r\nreturn 1;\r\nval = readw(sclk->en_reg);\r\nval &= BIT(sclk->en_bit);\r\nreturn val ? 1 : 0;\r\n}\r\nstatic u16 syscon_get_perf(void)\r\n{\r\nu16 val;\r\nval = readw(syscon_vbase + U300_SYSCON_CCR);\r\nval &= U300_SYSCON_CCR_CLKING_PERFORMANCE_MASK;\r\nreturn val;\r\n}\r\nstatic unsigned long\r\nsyscon_clk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_syscon *sclk = to_syscon(hw);\r\nu16 perf = syscon_get_perf();\r\nswitch(sclk->clk_val) {\r\ncase U300_SYSCON_SBCER_FAST_BRIDGE_CLK_EN:\r\ncase U300_SYSCON_SBCER_I2C0_CLK_EN:\r\ncase U300_SYSCON_SBCER_I2C1_CLK_EN:\r\ncase U300_SYSCON_SBCER_MMC_CLK_EN:\r\ncase U300_SYSCON_SBCER_SPI_CLK_EN:\r\nswitch(perf) {\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_LOW_POWER:\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_LOW:\r\nreturn 13000000;\r\ndefault:\r\nreturn parent_rate;\r\n}\r\ncase U300_SYSCON_SBCER_DMAC_CLK_EN:\r\ncase U300_SYSCON_SBCER_NANDIF_CLK_EN:\r\ncase U300_SYSCON_SBCER_XGAM_CLK_EN:\r\nswitch(perf) {\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_LOW_POWER:\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_LOW:\r\nreturn 6500000;\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_INTERMEDIATE:\r\nreturn 26000000;\r\ndefault:\r\nreturn parent_rate;\r\n}\r\ncase U300_SYSCON_SBCER_SEMI_CLK_EN:\r\ncase U300_SYSCON_SBCER_EMIF_CLK_EN:\r\nswitch(perf) {\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_LOW_POWER:\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_LOW:\r\nreturn 13000000;\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_INTERMEDIATE:\r\nreturn 52000000;\r\ndefault:\r\nreturn 104000000;\r\n}\r\ncase U300_SYSCON_SBCER_CPU_CLK_EN:\r\nswitch(perf) {\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_LOW_POWER:\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_LOW:\r\nreturn 13000000;\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_INTERMEDIATE:\r\nreturn 52000000;\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_HIGH:\r\nreturn 104000000;\r\ndefault:\r\nreturn parent_rate;\r\n}\r\ndefault:\r\nreturn parent_rate;\r\n}\r\n}\r\nstatic long\r\nsyscon_clk_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nstruct clk_syscon *sclk = to_syscon(hw);\r\nif (sclk->clk_val != U300_SYSCON_SBCER_CPU_CLK_EN)\r\nreturn *prate;\r\nif (rate <= 13000000)\r\nreturn 13000000;\r\nif (rate <= 52000000)\r\nreturn 52000000;\r\nif (rate <= 104000000)\r\nreturn 104000000;\r\nreturn 208000000;\r\n}\r\nstatic int syscon_clk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_syscon *sclk = to_syscon(hw);\r\nu16 val;\r\nif (sclk->clk_val != U300_SYSCON_SBCER_CPU_CLK_EN)\r\nreturn -EINVAL;\r\nswitch (rate) {\r\ncase 13000000:\r\nval = U300_SYSCON_CCR_CLKING_PERFORMANCE_LOW_POWER;\r\nbreak;\r\ncase 52000000:\r\nval = U300_SYSCON_CCR_CLKING_PERFORMANCE_INTERMEDIATE;\r\nbreak;\r\ncase 104000000:\r\nval = U300_SYSCON_CCR_CLKING_PERFORMANCE_HIGH;\r\nbreak;\r\ncase 208000000:\r\nval = U300_SYSCON_CCR_CLKING_PERFORMANCE_BEST;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nval |= readw(syscon_vbase + U300_SYSCON_CCR) &\r\n~U300_SYSCON_CCR_CLKING_PERFORMANCE_MASK ;\r\nwritew(val, syscon_vbase + U300_SYSCON_CCR);\r\nreturn 0;\r\n}\r\nstatic struct clk_hw * __init\r\nsyscon_clk_register(struct device *dev, const char *name,\r\nconst char *parent_name, unsigned long flags,\r\nbool hw_ctrld,\r\nvoid __iomem *res_reg, u8 res_bit,\r\nvoid __iomem *en_reg, u8 en_bit,\r\nu16 clk_val)\r\n{\r\nstruct clk_hw *hw;\r\nstruct clk_syscon *sclk;\r\nstruct clk_init_data init;\r\nint ret;\r\nsclk = kzalloc(sizeof(struct clk_syscon), GFP_KERNEL);\r\nif (!sclk) {\r\npr_err("could not allocate syscon clock %s\n",\r\nname);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ninit.name = name;\r\ninit.ops = &syscon_clk_ops;\r\ninit.flags = flags;\r\ninit.parent_names = (parent_name ? &parent_name : NULL);\r\ninit.num_parents = (parent_name ? 1 : 0);\r\nsclk->hw.init = &init;\r\nsclk->hw_ctrld = hw_ctrld;\r\nsclk->reset = true;\r\nsclk->res_reg = res_reg;\r\nsclk->res_bit = res_bit;\r\nsclk->en_reg = en_reg;\r\nsclk->en_bit = en_bit;\r\nsclk->clk_val = clk_val;\r\nhw = &sclk->hw;\r\nret = clk_hw_register(dev, hw);\r\nif (ret) {\r\nkfree(sclk);\r\nhw = ERR_PTR(ret);\r\n}\r\nreturn hw;\r\n}\r\nstatic void __init of_u300_syscon_clk_init(struct device_node *np)\r\n{\r\nstruct clk_hw *hw = ERR_PTR(-EINVAL);\r\nconst char *clk_name = np->name;\r\nconst char *parent_name;\r\nvoid __iomem *res_reg;\r\nvoid __iomem *en_reg;\r\nu32 clk_type;\r\nu32 clk_id;\r\nint i;\r\nif (of_property_read_u32(np, "clock-type", &clk_type)) {\r\npr_err("%s: syscon clock \"%s\" missing clock-type property\n",\r\n__func__, clk_name);\r\nreturn;\r\n}\r\nif (of_property_read_u32(np, "clock-id", &clk_id)) {\r\npr_err("%s: syscon clock \"%s\" missing clock-id property\n",\r\n__func__, clk_name);\r\nreturn;\r\n}\r\nparent_name = of_clk_get_parent_name(np, 0);\r\nswitch (clk_type) {\r\ncase U300_CLK_TYPE_SLOW:\r\nres_reg = syscon_vbase + U300_SYSCON_RSR;\r\nen_reg = syscon_vbase + U300_SYSCON_CESR;\r\nbreak;\r\ncase U300_CLK_TYPE_FAST:\r\nres_reg = syscon_vbase + U300_SYSCON_RFR;\r\nen_reg = syscon_vbase + U300_SYSCON_CEFR;\r\nbreak;\r\ncase U300_CLK_TYPE_REST:\r\nres_reg = syscon_vbase + U300_SYSCON_RRR;\r\nen_reg = syscon_vbase + U300_SYSCON_CERR;\r\nbreak;\r\ndefault:\r\npr_err("unknown clock type %x specified\n", clk_type);\r\nreturn;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(u300_clk_lookup); i++) {\r\nconst struct u300_clock *u3clk = &u300_clk_lookup[i];\r\nif (u3clk->type == clk_type && u3clk->id == clk_id)\r\nhw = syscon_clk_register(NULL, clk_name, parent_name,\r\n0, u3clk->hw_ctrld,\r\nres_reg, u3clk->id,\r\nen_reg, u3clk->id,\r\nu3clk->clk_val);\r\n}\r\nif (!IS_ERR(hw)) {\r\nof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\r\nif (clk_type == U300_CLK_TYPE_REST && clk_id == 5)\r\nclk_hw_register_clkdev(hw, NULL, "pl172");\r\nif (clk_type == U300_CLK_TYPE_REST && clk_id == 9)\r\nclk_hw_register_clkdev(hw, NULL, "semi");\r\nif (clk_type == U300_CLK_TYPE_REST && clk_id == 12)\r\nclk_hw_register_clkdev(hw, NULL, "intcon");\r\n}\r\n}\r\nstatic int mclk_clk_prepare(struct clk_hw *hw)\r\n{\r\nstruct clk_mclk *mclk = to_mclk(hw);\r\nu16 val;\r\nif (!mclk->is_mspro) {\r\nwritew(0x0054U, syscon_vbase + U300_SYSCON_MMF0R);\r\nval = readw(syscon_vbase + U300_SYSCON_MMCR);\r\nval &= ~U300_SYSCON_MMCR_MMC_FB_CLK_SEL_ENABLE;\r\nval &= ~U300_SYSCON_MMCR_MSPRO_FREQSEL_ENABLE;\r\nwritew(val, syscon_vbase + U300_SYSCON_MMCR);\r\n} else {\r\nval = readw(syscon_vbase + U300_SYSCON_MMCR);\r\nval &= ~U300_SYSCON_MMCR_MMC_FB_CLK_SEL_ENABLE;\r\nval |= U300_SYSCON_MMCR_MSPRO_FREQSEL_ENABLE;\r\nwritew(val, syscon_vbase + U300_SYSCON_MMCR);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned long\r\nmclk_clk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nu16 perf = syscon_get_perf();\r\nswitch (perf) {\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_LOW_POWER:\r\nreturn 13000000;\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_LOW:\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_INTERMEDIATE:\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_HIGH:\r\ncase U300_SYSCON_CCR_CLKING_PERFORMANCE_BEST:\r\n{\r\nu16 val = readw(syscon_vbase + U300_SYSCON_MMF0R) &\r\nU300_SYSCON_MMF0R_MASK;\r\nswitch (val) {\r\ncase 0x0054:\r\nreturn 18900000;\r\ncase 0x0044:\r\nreturn 20800000;\r\ncase 0x0043:\r\nreturn 23100000;\r\ncase 0x0033:\r\nreturn 26000000;\r\ncase 0x0032:\r\nreturn 29700000;\r\ncase 0x0022:\r\nreturn 34700000;\r\ncase 0x0021:\r\nreturn 41600000;\r\ncase 0x0011:\r\nreturn 52000000;\r\ncase 0x0000:\r\nreturn 104000000;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nreturn parent_rate;\r\n}\r\nstatic long\r\nmclk_clk_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nif (rate <= 18900000)\r\nreturn 18900000;\r\nif (rate <= 20800000)\r\nreturn 20800000;\r\nif (rate <= 23100000)\r\nreturn 23100000;\r\nif (rate <= 26000000)\r\nreturn 26000000;\r\nif (rate <= 29700000)\r\nreturn 29700000;\r\nif (rate <= 34700000)\r\nreturn 34700000;\r\nif (rate <= 41600000)\r\nreturn 41600000;\r\nreturn 52000000;\r\n}\r\nstatic int mclk_clk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nu16 val;\r\nu16 reg;\r\nswitch (rate) {\r\ncase 18900000:\r\nval = 0x0054;\r\nbreak;\r\ncase 20800000:\r\nval = 0x0044;\r\nbreak;\r\ncase 23100000:\r\nval = 0x0043;\r\nbreak;\r\ncase 26000000:\r\nval = 0x0033;\r\nbreak;\r\ncase 29700000:\r\nval = 0x0032;\r\nbreak;\r\ncase 34700000:\r\nval = 0x0022;\r\nbreak;\r\ncase 41600000:\r\nval = 0x0021;\r\nbreak;\r\ncase 52000000:\r\nval = 0x0011;\r\nbreak;\r\ncase 104000000:\r\nval = 0x0000;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreg = readw(syscon_vbase + U300_SYSCON_MMF0R) &\r\n~U300_SYSCON_MMF0R_MASK;\r\nwritew(reg | val, syscon_vbase + U300_SYSCON_MMF0R);\r\nreturn 0;\r\n}\r\nstatic struct clk_hw * __init\r\nmclk_clk_register(struct device *dev, const char *name,\r\nconst char *parent_name, bool is_mspro)\r\n{\r\nstruct clk_hw *hw;\r\nstruct clk_mclk *mclk;\r\nstruct clk_init_data init;\r\nint ret;\r\nmclk = kzalloc(sizeof(struct clk_mclk), GFP_KERNEL);\r\nif (!mclk) {\r\npr_err("could not allocate MMC/SD clock %s\n",\r\nname);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ninit.name = "mclk";\r\ninit.ops = &mclk_ops;\r\ninit.flags = 0;\r\ninit.parent_names = (parent_name ? &parent_name : NULL);\r\ninit.num_parents = (parent_name ? 1 : 0);\r\nmclk->hw.init = &init;\r\nmclk->is_mspro = is_mspro;\r\nhw = &mclk->hw;\r\nret = clk_hw_register(dev, hw);\r\nif (ret) {\r\nkfree(mclk);\r\nhw = ERR_PTR(ret);\r\n}\r\nreturn hw;\r\n}\r\nstatic void __init of_u300_syscon_mclk_init(struct device_node *np)\r\n{\r\nstruct clk_hw *hw;\r\nconst char *clk_name = np->name;\r\nconst char *parent_name;\r\nparent_name = of_clk_get_parent_name(np, 0);\r\nhw = mclk_clk_register(NULL, clk_name, parent_name, false);\r\nif (!IS_ERR(hw))\r\nof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\r\n}\r\nvoid __init u300_clk_init(void __iomem *base)\r\n{\r\nu16 val;\r\nsyscon_vbase = base;\r\nval = readw(syscon_vbase + U300_SYSCON_CCR);\r\nval &= ~U300_SYSCON_CCR_CLKING_PERFORMANCE_MASK;\r\nwritew(val, syscon_vbase + U300_SYSCON_CCR);\r\nwhile (!(readw(syscon_vbase + U300_SYSCON_CSR) &\r\nU300_SYSCON_CSR_PLL208_LOCK_IND));\r\nval = readw(syscon_vbase + U300_SYSCON_PMCR);\r\nval |= U300_SYSCON_PMCR_PWR_MGNT_ENABLE;\r\nwritew(val, syscon_vbase + U300_SYSCON_PMCR);\r\nof_clk_init(u300_clk_match);\r\n}
