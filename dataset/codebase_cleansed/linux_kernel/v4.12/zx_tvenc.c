static const struct zx_tvenc_mode *\r\nzx_tvenc_find_zmode(struct drm_display_mode *mode)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(tvenc_modes); i++) {\r\nconst struct zx_tvenc_mode *zmode = tvenc_modes[i];\r\nif (drm_mode_equal(mode, &zmode->mode))\r\nreturn zmode;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void zx_tvenc_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adj_mode)\r\n{\r\nstruct zx_tvenc *tvenc = to_zx_tvenc(encoder);\r\nconst struct zx_tvenc_mode *zmode;\r\nstruct vou_div_config configs[] = {\r\n{ VOU_DIV_INF, VOU_DIV_4 },\r\n{ VOU_DIV_TVENC, VOU_DIV_1 },\r\n{ VOU_DIV_LAYER, VOU_DIV_2 },\r\n};\r\nzx_vou_config_dividers(encoder->crtc, configs, ARRAY_SIZE(configs));\r\nzmode = zx_tvenc_find_zmode(mode);\r\nif (!zmode) {\r\nDRM_DEV_ERROR(tvenc->dev, "failed to find zmode\n");\r\nreturn;\r\n}\r\nzx_writel(tvenc->mmio + VENC_VIDEO_INFO, zmode->video_info);\r\nzx_writel(tvenc->mmio + VENC_VIDEO_RES, zmode->video_res);\r\nzx_writel(tvenc->mmio + VENC_FIELD1_PARAM, zmode->field1_param);\r\nzx_writel(tvenc->mmio + VENC_FIELD2_PARAM, zmode->field2_param);\r\nzx_writel(tvenc->mmio + VENC_LINE_O_1, zmode->burst_line_odd1);\r\nzx_writel(tvenc->mmio + VENC_LINE_E_1, zmode->burst_line_even1);\r\nzx_writel(tvenc->mmio + VENC_LINE_O_2, zmode->burst_line_odd2);\r\nzx_writel(tvenc->mmio + VENC_LINE_E_2, zmode->burst_line_even2);\r\nzx_writel(tvenc->mmio + VENC_LINE_TIMING_PARAM,\r\nzmode->line_timing_param);\r\nzx_writel(tvenc->mmio + VENC_WEIGHT_VALUE, zmode->weight_value);\r\nzx_writel(tvenc->mmio + VENC_BLANK_BLACK_LEVEL,\r\nzmode->blank_black_level);\r\nzx_writel(tvenc->mmio + VENC_BURST_LEVEL, zmode->burst_level);\r\nzx_writel(tvenc->mmio + VENC_CONTROL_PARAM, zmode->control_param);\r\nzx_writel(tvenc->mmio + VENC_SUB_CARRIER_PHASE1,\r\nzmode->sub_carrier_phase1);\r\nzx_writel(tvenc->mmio + VENC_PHASE_LINE_INCR_CVBS,\r\nzmode->phase_line_incr_cvbs);\r\n}\r\nstatic void zx_tvenc_encoder_enable(struct drm_encoder *encoder)\r\n{\r\nstruct zx_tvenc *tvenc = to_zx_tvenc(encoder);\r\nstruct zx_tvenc_pwrctrl *pwrctrl = &tvenc->pwrctrl;\r\nregmap_update_bits(pwrctrl->regmap, pwrctrl->reg, pwrctrl->mask,\r\npwrctrl->mask);\r\nvou_inf_enable(VOU_TV_ENC, encoder->crtc);\r\nzx_writel(tvenc->mmio + VENC_ENABLE, 1);\r\n}\r\nstatic void zx_tvenc_encoder_disable(struct drm_encoder *encoder)\r\n{\r\nstruct zx_tvenc *tvenc = to_zx_tvenc(encoder);\r\nstruct zx_tvenc_pwrctrl *pwrctrl = &tvenc->pwrctrl;\r\nzx_writel(tvenc->mmio + VENC_ENABLE, 0);\r\nvou_inf_disable(VOU_TV_ENC, encoder->crtc);\r\nregmap_update_bits(pwrctrl->regmap, pwrctrl->reg, pwrctrl->mask, 0);\r\n}\r\nstatic int zx_tvenc_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct zx_tvenc *tvenc = to_zx_tvenc(connector);\r\nstruct device *dev = tvenc->dev;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(tvenc_modes); i++) {\r\nconst struct zx_tvenc_mode *zmode = tvenc_modes[i];\r\nstruct drm_display_mode *mode;\r\nmode = drm_mode_duplicate(connector->dev, &zmode->mode);\r\nif (!mode) {\r\nDRM_DEV_ERROR(dev, "failed to duplicate drm mode\n");\r\ncontinue;\r\n}\r\ndrm_mode_set_name(mode);\r\ndrm_mode_probed_add(connector, mode);\r\n}\r\nreturn i;\r\n}\r\nstatic enum drm_mode_status\r\nzx_tvenc_connector_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct zx_tvenc *tvenc = to_zx_tvenc(connector);\r\nconst struct zx_tvenc_mode *zmode;\r\nzmode = zx_tvenc_find_zmode(mode);\r\nif (!zmode) {\r\nDRM_DEV_ERROR(tvenc->dev, "unsupported mode: %s\n", mode->name);\r\nreturn MODE_NOMODE;\r\n}\r\nreturn MODE_OK;\r\n}\r\nstatic int zx_tvenc_register(struct drm_device *drm, struct zx_tvenc *tvenc)\r\n{\r\nstruct drm_encoder *encoder = &tvenc->encoder;\r\nstruct drm_connector *connector = &tvenc->connector;\r\nencoder->possible_crtcs = BIT(1);\r\ndrm_encoder_init(drm, encoder, &zx_tvenc_encoder_funcs,\r\nDRM_MODE_ENCODER_TVDAC, NULL);\r\ndrm_encoder_helper_add(encoder, &zx_tvenc_encoder_helper_funcs);\r\nconnector->interlace_allowed = true;\r\ndrm_connector_init(drm, connector, &zx_tvenc_connector_funcs,\r\nDRM_MODE_CONNECTOR_Composite);\r\ndrm_connector_helper_add(connector, &zx_tvenc_connector_helper_funcs);\r\ndrm_mode_connector_attach_encoder(connector, encoder);\r\nreturn 0;\r\n}\r\nstatic int zx_tvenc_pwrctrl_init(struct zx_tvenc *tvenc)\r\n{\r\nstruct zx_tvenc_pwrctrl *pwrctrl = &tvenc->pwrctrl;\r\nstruct device *dev = tvenc->dev;\r\nstruct of_phandle_args out_args;\r\nstruct regmap *regmap;\r\nint ret;\r\nret = of_parse_phandle_with_fixed_args(dev->of_node,\r\n"zte,tvenc-power-control", 2, 0, &out_args);\r\nif (ret)\r\nreturn ret;\r\nregmap = syscon_node_to_regmap(out_args.np);\r\nif (IS_ERR(regmap)) {\r\nret = PTR_ERR(regmap);\r\ngoto out;\r\n}\r\npwrctrl->regmap = regmap;\r\npwrctrl->reg = out_args.args[0];\r\npwrctrl->mask = out_args.args[1];\r\nout:\r\nof_node_put(out_args.np);\r\nreturn ret;\r\n}\r\nstatic int zx_tvenc_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct drm_device *drm = data;\r\nstruct resource *res;\r\nstruct zx_tvenc *tvenc;\r\nint ret;\r\ntvenc = devm_kzalloc(dev, sizeof(*tvenc), GFP_KERNEL);\r\nif (!tvenc)\r\nreturn -ENOMEM;\r\ntvenc->dev = dev;\r\ndev_set_drvdata(dev, tvenc);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ntvenc->mmio = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(tvenc->mmio)) {\r\nret = PTR_ERR(tvenc->mmio);\r\nDRM_DEV_ERROR(dev, "failed to remap tvenc region: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = zx_tvenc_pwrctrl_init(tvenc);\r\nif (ret) {\r\nDRM_DEV_ERROR(dev, "failed to init power control: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = zx_tvenc_register(drm, tvenc);\r\nif (ret) {\r\nDRM_DEV_ERROR(dev, "failed to register tvenc: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void zx_tvenc_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\n}\r\nstatic int zx_tvenc_probe(struct platform_device *pdev)\r\n{\r\nreturn component_add(&pdev->dev, &zx_tvenc_component_ops);\r\n}\r\nstatic int zx_tvenc_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &zx_tvenc_component_ops);\r\nreturn 0;\r\n}
