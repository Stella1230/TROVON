int lustre_process_log(struct super_block *sb, char *logname,\r\nstruct config_llog_instance *cfg)\r\n{\r\nstruct lustre_cfg *lcfg;\r\nstruct lustre_cfg_bufs *bufs;\r\nstruct lustre_sb_info *lsi = s2lsi(sb);\r\nstruct obd_device *mgc = lsi->lsi_mgc;\r\nint rc;\r\nLASSERT(mgc);\r\nLASSERT(cfg);\r\nbufs = kzalloc(sizeof(*bufs), GFP_NOFS);\r\nif (!bufs)\r\nreturn -ENOMEM;\r\nlustre_cfg_bufs_reset(bufs, mgc->obd_name);\r\nlustre_cfg_bufs_set_string(bufs, 1, logname);\r\nlustre_cfg_bufs_set(bufs, 2, cfg, sizeof(*cfg));\r\nlustre_cfg_bufs_set(bufs, 3, &sb, sizeof(sb));\r\nlcfg = lustre_cfg_new(LCFG_LOG_START, bufs);\r\nrc = obd_process_config(mgc, sizeof(*lcfg), lcfg);\r\nlustre_cfg_free(lcfg);\r\nkfree(bufs);\r\nif (rc == -EINVAL)\r\nLCONSOLE_ERROR_MSG(0x15b, "%s: The configuration from log '%s' failed from the MGS (%d). Make sure this client and the MGS are running compatible versions of Lustre.\n",\r\nmgc->obd_name, logname, rc);\r\nelse if (rc)\r\nLCONSOLE_ERROR_MSG(0x15c, "%s: The configuration from log '%s' failed (%d). This may be the result of communication errors between this node and the MGS, a bad configuration, or other errors. See the syslog for more information.\n",\r\nmgc->obd_name, logname,\r\nrc);\r\nreturn rc;\r\n}\r\nint lustre_end_log(struct super_block *sb, char *logname,\r\nstruct config_llog_instance *cfg)\r\n{\r\nstruct lustre_cfg *lcfg;\r\nstruct lustre_cfg_bufs bufs;\r\nstruct lustre_sb_info *lsi = s2lsi(sb);\r\nstruct obd_device *mgc = lsi->lsi_mgc;\r\nint rc;\r\nif (!mgc)\r\nreturn -ENOENT;\r\nlustre_cfg_bufs_reset(&bufs, mgc->obd_name);\r\nlustre_cfg_bufs_set_string(&bufs, 1, logname);\r\nif (cfg)\r\nlustre_cfg_bufs_set(&bufs, 2, cfg, sizeof(*cfg));\r\nlcfg = lustre_cfg_new(LCFG_LOG_END, &bufs);\r\nrc = obd_process_config(mgc, sizeof(*lcfg), lcfg);\r\nlustre_cfg_free(lcfg);\r\nreturn rc;\r\n}\r\nstatic int do_lcfg(char *cfgname, lnet_nid_t nid, int cmd,\r\nchar *s1, char *s2, char *s3, char *s4)\r\n{\r\nstruct lustre_cfg_bufs bufs;\r\nstruct lustre_cfg *lcfg = NULL;\r\nint rc;\r\nCDEBUG(D_TRACE, "lcfg %s %#x %s %s %s %s\n", cfgname,\r\ncmd, s1, s2, s3, s4);\r\nlustre_cfg_bufs_reset(&bufs, cfgname);\r\nif (s1)\r\nlustre_cfg_bufs_set_string(&bufs, 1, s1);\r\nif (s2)\r\nlustre_cfg_bufs_set_string(&bufs, 2, s2);\r\nif (s3)\r\nlustre_cfg_bufs_set_string(&bufs, 3, s3);\r\nif (s4)\r\nlustre_cfg_bufs_set_string(&bufs, 4, s4);\r\nlcfg = lustre_cfg_new(cmd, &bufs);\r\nlcfg->lcfg_nid = nid;\r\nrc = class_process_config(lcfg);\r\nlustre_cfg_free(lcfg);\r\nreturn rc;\r\n}\r\nstatic int lustre_start_simple(char *obdname, char *type, char *uuid,\r\nchar *s1, char *s2, char *s3, char *s4)\r\n{\r\nint rc;\r\nCDEBUG(D_MOUNT, "Starting obd %s (typ=%s)\n", obdname, type);\r\nrc = do_lcfg(obdname, 0, LCFG_ATTACH, type, uuid, NULL, NULL);\r\nif (rc) {\r\nCERROR("%s attach error %d\n", obdname, rc);\r\nreturn rc;\r\n}\r\nrc = do_lcfg(obdname, 0, LCFG_SETUP, s1, s2, s3, s4);\r\nif (rc) {\r\nCERROR("%s setup error %d\n", obdname, rc);\r\ndo_lcfg(obdname, 0, LCFG_DETACH, NULL, NULL, NULL, NULL);\r\n}\r\nreturn rc;\r\n}\r\nint lustre_start_mgc(struct super_block *sb)\r\n{\r\nstruct obd_connect_data *data = NULL;\r\nstruct lustre_sb_info *lsi = s2lsi(sb);\r\nstruct obd_device *obd;\r\nstruct obd_export *exp;\r\nstruct obd_uuid *uuid;\r\nclass_uuid_t uuidc;\r\nlnet_nid_t nid;\r\nchar nidstr[LNET_NIDSTR_SIZE];\r\nchar *mgcname = NULL, *niduuid = NULL, *mgssec = NULL;\r\nchar *ptr;\r\nint rc = 0, i = 0, j;\r\nLASSERT(lsi->lsi_lmd);\r\nptr = lsi->lsi_lmd->lmd_dev;\r\nif (class_parse_nid(ptr, &nid, &ptr) == 0)\r\ni++;\r\nif (i == 0) {\r\nCERROR("No valid MGS nids found.\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&mgc_start_lock);\r\nlibcfs_nid2str_r(nid, nidstr, sizeof(nidstr));\r\nmgcname = kasprintf(GFP_NOFS,\r\n"%s%s", LUSTRE_MGC_OBDNAME, nidstr);\r\nniduuid = kasprintf(GFP_NOFS, "%s_%x", mgcname, i);\r\nif (!mgcname || !niduuid) {\r\nrc = -ENOMEM;\r\ngoto out_free;\r\n}\r\nmgssec = lsi->lsi_lmd->lmd_mgssec ? lsi->lsi_lmd->lmd_mgssec : "";\r\ndata = kzalloc(sizeof(*data), GFP_NOFS);\r\nif (!data) {\r\nrc = -ENOMEM;\r\ngoto out_free;\r\n}\r\nobd = class_name2obd(mgcname);\r\nif (obd && !obd->obd_stopping) {\r\nint recov_bk;\r\nrc = obd_set_info_async(NULL, obd->obd_self_export,\r\nstrlen(KEY_MGSSEC), KEY_MGSSEC,\r\nstrlen(mgssec), mgssec, NULL);\r\nif (rc)\r\ngoto out_free;\r\natomic_inc(&obd->u.cli.cl_mgc_refcount);\r\nif (lmd_is_client(lsi->lsi_lmd)) {\r\nint has_ir;\r\nint vallen = sizeof(*data);\r\n__u32 *flags = &lsi->lsi_lmd->lmd_flags;\r\nrc = obd_get_info(NULL, obd->obd_self_export,\r\nstrlen(KEY_CONN_DATA), KEY_CONN_DATA,\r\n&vallen, data);\r\nLASSERT(rc == 0);\r\nhas_ir = OCD_HAS_FLAG(data, IMP_RECOV);\r\nif (has_ir ^ !(*flags & LMD_FLG_NOIR)) {\r\nLCONSOLE_WARN(\r\n"Trying to mount a client with IR setting not compatible with current mgc. Force to use current mgc setting that is IR %s.\n",\r\nhas_ir ? "enabled" : "disabled");\r\nif (has_ir)\r\n*flags &= ~LMD_FLG_NOIR;\r\nelse\r\n*flags |= LMD_FLG_NOIR;\r\n}\r\n}\r\nrecov_bk = 0;\r\nrecov_bk++;\r\nCDEBUG(D_MOUNT, "%s: Set MGC reconnect %d\n", mgcname,\r\nrecov_bk);\r\nrc = obd_set_info_async(NULL, obd->obd_self_export,\r\nsizeof(KEY_INIT_RECOV_BACKUP),\r\nKEY_INIT_RECOV_BACKUP,\r\nsizeof(recov_bk), &recov_bk, NULL);\r\nrc = 0;\r\ngoto out;\r\n}\r\nCDEBUG(D_MOUNT, "Start MGC '%s'\n", mgcname);\r\ni = 0;\r\nptr = lsi->lsi_lmd->lmd_dev;\r\nwhile (class_parse_nid(ptr, &nid, &ptr) == 0) {\r\nrc = do_lcfg(mgcname, nid,\r\nLCFG_ADD_UUID, niduuid, NULL, NULL, NULL);\r\nif (!rc)\r\ni++;\r\nif (*ptr == ':')\r\nbreak;\r\n}\r\nif (i == 0) {\r\nCERROR("No valid MGS nids found.\n");\r\nrc = -EINVAL;\r\ngoto out_free;\r\n}\r\nlsi->lsi_lmd->lmd_mgs_failnodes = 1;\r\nuuid = kzalloc(sizeof(*uuid), GFP_NOFS);\r\nif (!uuid) {\r\nrc = -ENOMEM;\r\ngoto out_free;\r\n}\r\nll_generate_random_uuid(uuidc);\r\nclass_uuid_unparse(uuidc, uuid);\r\nrc = lustre_start_simple(mgcname, LUSTRE_MGC_NAME,\r\n(char *)uuid->uuid, LUSTRE_MGS_OBDNAME,\r\nniduuid, NULL, NULL);\r\nkfree(uuid);\r\nif (rc)\r\ngoto out_free;\r\ni = 1;\r\nwhile (ptr && ((*ptr == ':' ||\r\nclass_find_param(ptr, PARAM_MGSNODE, &ptr) == 0))) {\r\nsprintf(niduuid, "%s_%x", mgcname, i);\r\nj = 0;\r\nwhile (class_parse_nid_quiet(ptr, &nid, &ptr) == 0) {\r\nrc = do_lcfg(mgcname, nid, LCFG_ADD_UUID, niduuid,\r\nNULL, NULL, NULL);\r\nif (!rc)\r\n++j;\r\nif (*ptr == ':')\r\nbreak;\r\n}\r\nif (j > 0) {\r\nrc = do_lcfg(mgcname, 0, LCFG_ADD_CONN,\r\nniduuid, NULL, NULL, NULL);\r\nif (!rc)\r\ni++;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nlsi->lsi_lmd->lmd_mgs_failnodes = i;\r\nobd = class_name2obd(mgcname);\r\nif (!obd) {\r\nCERROR("Can't find mgcobd %s\n", mgcname);\r\nrc = -ENOTCONN;\r\ngoto out_free;\r\n}\r\nrc = obd_set_info_async(NULL, obd->obd_self_export,\r\nstrlen(KEY_MGSSEC), KEY_MGSSEC,\r\nstrlen(mgssec), mgssec, NULL);\r\nif (rc)\r\ngoto out_free;\r\natomic_set(&obd->u.cli.cl_mgc_refcount, 1);\r\ndata->ocd_connect_flags = OBD_CONNECT_VERSION | OBD_CONNECT_AT |\r\nOBD_CONNECT_FULL20 | OBD_CONNECT_IMP_RECOV |\r\nOBD_CONNECT_LVB_TYPE | OBD_CONNECT_BULK_MBITS;\r\n#if OBD_OCD_VERSION(3, 0, 53, 0) > LUSTRE_VERSION_CODE\r\ndata->ocd_connect_flags |= OBD_CONNECT_MNE_SWAB;\r\n#endif\r\nif (lmd_is_client(lsi->lsi_lmd) &&\r\nlsi->lsi_lmd->lmd_flags & LMD_FLG_NOIR)\r\ndata->ocd_connect_flags &= ~OBD_CONNECT_IMP_RECOV;\r\ndata->ocd_version = LUSTRE_VERSION_CODE;\r\nrc = obd_connect(NULL, &exp, obd, &obd->obd_uuid, data, NULL);\r\nif (rc) {\r\nCERROR("connect failed %d\n", rc);\r\ngoto out;\r\n}\r\nobd->u.cli.cl_mgc_mgsexp = exp;\r\nout:\r\nlsi->lsi_mgc = obd;\r\nout_free:\r\nmutex_unlock(&mgc_start_lock);\r\nkfree(data);\r\nkfree(mgcname);\r\nkfree(niduuid);\r\nreturn rc;\r\n}\r\nstatic int lustre_stop_mgc(struct super_block *sb)\r\n{\r\nstruct lustre_sb_info *lsi = s2lsi(sb);\r\nstruct obd_device *obd;\r\nchar *niduuid = NULL, *ptr = NULL;\r\nint i, rc = 0, len = 0;\r\nif (!lsi)\r\nreturn -ENOENT;\r\nobd = lsi->lsi_mgc;\r\nif (!obd)\r\nreturn -ENOENT;\r\nlsi->lsi_mgc = NULL;\r\nmutex_lock(&mgc_start_lock);\r\nLASSERT(atomic_read(&obd->u.cli.cl_mgc_refcount) > 0);\r\nif (!atomic_dec_and_test(&obd->u.cli.cl_mgc_refcount)) {\r\nCDEBUG(D_MOUNT, "mgc still has %d references.\n",\r\natomic_read(&obd->u.cli.cl_mgc_refcount));\r\nrc = -EBUSY;\r\ngoto out;\r\n}\r\nobd->obd_no_recov = 1;\r\nif (obd->u.cli.cl_mgc_mgsexp) {\r\nrc = obd_disconnect(obd->u.cli.cl_mgc_mgsexp);\r\nif (rc)\r\nCDEBUG(D_MOUNT, "disconnect failed %d\n", rc);\r\n}\r\nlen = strlen(obd->obd_name) + 6;\r\nniduuid = kzalloc(len, GFP_NOFS);\r\nif (niduuid) {\r\nstrcpy(niduuid, obd->obd_name);\r\nptr = niduuid + strlen(niduuid);\r\n}\r\nrc = class_manual_cleanup(obd);\r\nif (rc)\r\ngoto out;\r\nif (!niduuid) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nfor (i = 0; i < lsi->lsi_lmd->lmd_mgs_failnodes; i++) {\r\nsprintf(ptr, "_%x", i);\r\nrc = do_lcfg(LUSTRE_MGC_OBDNAME, 0, LCFG_DEL_UUID,\r\nniduuid, NULL, NULL, NULL);\r\nif (rc)\r\nCERROR("del MDC UUID %s failed: rc = %d\n",\r\nniduuid, rc);\r\n}\r\nout:\r\nkfree(niduuid);\r\nmutex_unlock(&mgc_start_lock);\r\nreturn rc;\r\n}\r\nstatic struct lustre_sb_info *lustre_init_lsi(struct super_block *sb)\r\n{\r\nstruct lustre_sb_info *lsi;\r\nlsi = kzalloc(sizeof(*lsi), GFP_NOFS);\r\nif (!lsi)\r\nreturn NULL;\r\nlsi->lsi_lmd = kzalloc(sizeof(*lsi->lsi_lmd), GFP_NOFS);\r\nif (!lsi->lsi_lmd) {\r\nkfree(lsi);\r\nreturn NULL;\r\n}\r\nlsi->lsi_lmd->lmd_exclude_count = 0;\r\nlsi->lsi_lmd->lmd_recovery_time_soft = 0;\r\nlsi->lsi_lmd->lmd_recovery_time_hard = 0;\r\ns2lsi_nocast(sb) = lsi;\r\natomic_set(&lsi->lsi_mounts, 1);\r\nlsi->lsi_flags = LSI_UMOUNT_FAILOVER;\r\nreturn lsi;\r\n}\r\nstatic int lustre_free_lsi(struct super_block *sb)\r\n{\r\nstruct lustre_sb_info *lsi = s2lsi(sb);\r\nCDEBUG(D_MOUNT, "Freeing lsi %p\n", lsi);\r\nLASSERT(atomic_read(&lsi->lsi_mounts) == 0);\r\nif (lsi->lsi_lmd) {\r\nkfree(lsi->lsi_lmd->lmd_dev);\r\nkfree(lsi->lsi_lmd->lmd_profile);\r\nkfree(lsi->lsi_lmd->lmd_mgssec);\r\nkfree(lsi->lsi_lmd->lmd_opts);\r\nif (lsi->lsi_lmd->lmd_exclude_count)\r\nkfree(lsi->lsi_lmd->lmd_exclude);\r\nkfree(lsi->lsi_lmd->lmd_mgs);\r\nkfree(lsi->lsi_lmd->lmd_osd_type);\r\nkfree(lsi->lsi_lmd->lmd_params);\r\nkfree(lsi->lsi_lmd);\r\n}\r\nLASSERT(!lsi->lsi_llsbi);\r\nkfree(lsi);\r\ns2lsi_nocast(sb) = NULL;\r\nreturn 0;\r\n}\r\nstatic int lustre_put_lsi(struct super_block *sb)\r\n{\r\nstruct lustre_sb_info *lsi = s2lsi(sb);\r\nCDEBUG(D_MOUNT, "put %p %d\n", sb, atomic_read(&lsi->lsi_mounts));\r\nif (atomic_dec_and_test(&lsi->lsi_mounts)) {\r\nlustre_free_lsi(sb);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int server_name2fsname(const char *svname, char *fsname,\r\nconst char **endptr)\r\n{\r\nconst char *dash;\r\ndash = svname + strnlen(svname, 8);\r\nfor (; dash > svname && *dash != '-' && *dash != ':'; dash--)\r\n;\r\nif (dash == svname)\r\nreturn -EINVAL;\r\nif (fsname) {\r\nstrncpy(fsname, svname, dash - svname);\r\nfsname[dash - svname] = '\0';\r\n}\r\nif (endptr)\r\n*endptr = dash;\r\nreturn 0;\r\n}\r\nstatic int server_name2index(const char *svname, __u32 *idx,\r\nconst char **endptr)\r\n{\r\nunsigned long index;\r\nint rc;\r\nconst char *dash;\r\nrc = server_name2fsname(svname, NULL, &dash);\r\nif (rc != 0)\r\nreturn rc;\r\ndash++;\r\nif (strncmp(dash, "MDT", 3) == 0)\r\nrc = LDD_F_SV_TYPE_MDT;\r\nelse if (strncmp(dash, "OST", 3) == 0)\r\nrc = LDD_F_SV_TYPE_OST;\r\nelse\r\nreturn -EINVAL;\r\ndash += 3;\r\nif (strncmp(dash, "all", 3) == 0) {\r\nif (endptr)\r\n*endptr = dash + 3;\r\nreturn rc | LDD_F_SV_ALL;\r\n}\r\nindex = simple_strtoul(dash, (char **)endptr, 16);\r\nif (idx)\r\n*idx = index;\r\nif (endptr && strncmp(LUSTRE_MDC_NAME, *endptr + 1,\r\nsizeof(LUSTRE_MDC_NAME) - 1) == 0)\r\n*endptr += sizeof(LUSTRE_MDC_NAME);\r\nreturn rc;\r\n}\r\nint lustre_common_put_super(struct super_block *sb)\r\n{\r\nint rc;\r\nCDEBUG(D_MOUNT, "dropping sb %p\n", sb);\r\nrc = lustre_stop_mgc(sb);\r\nif (rc && (rc != -ENOENT)) {\r\nif (rc != -EBUSY) {\r\nCERROR("Can't stop MGC: %d\n", rc);\r\nreturn rc;\r\n}\r\nCDEBUG(D_MOUNT, "MGC still in use\n");\r\n}\r\nlustre_put_lsi(sb);\r\nreturn rc;\r\n}\r\nstatic void lmd_print(struct lustre_mount_data *lmd)\r\n{\r\nint i;\r\nPRINT_CMD(D_MOUNT, " mount data:\n");\r\nif (lmd_is_client(lmd))\r\nPRINT_CMD(D_MOUNT, "profile: %s\n", lmd->lmd_profile);\r\nPRINT_CMD(D_MOUNT, "device: %s\n", lmd->lmd_dev);\r\nPRINT_CMD(D_MOUNT, "flags: %x\n", lmd->lmd_flags);\r\nif (lmd->lmd_opts)\r\nPRINT_CMD(D_MOUNT, "options: %s\n", lmd->lmd_opts);\r\nif (lmd->lmd_recovery_time_soft)\r\nPRINT_CMD(D_MOUNT, "recovery time soft: %d\n",\r\nlmd->lmd_recovery_time_soft);\r\nif (lmd->lmd_recovery_time_hard)\r\nPRINT_CMD(D_MOUNT, "recovery time hard: %d\n",\r\nlmd->lmd_recovery_time_hard);\r\nfor (i = 0; i < lmd->lmd_exclude_count; i++) {\r\nPRINT_CMD(D_MOUNT, "exclude %d: OST%04x\n", i,\r\nlmd->lmd_exclude[i]);\r\n}\r\n}\r\nint lustre_check_exclusion(struct super_block *sb, char *svname)\r\n{\r\nstruct lustre_sb_info *lsi = s2lsi(sb);\r\nstruct lustre_mount_data *lmd = lsi->lsi_lmd;\r\n__u32 index;\r\nint i, rc;\r\nrc = server_name2index(svname, &index, NULL);\r\nif (rc != LDD_F_SV_TYPE_OST)\r\nreturn 0;\r\nCDEBUG(D_MOUNT, "Check exclusion %s (%d) in %d of %s\n", svname,\r\nindex, lmd->lmd_exclude_count, lmd->lmd_dev);\r\nfor (i = 0; i < lmd->lmd_exclude_count; i++) {\r\nif (index == lmd->lmd_exclude[i]) {\r\nCWARN("Excluding %s (on exclusion list)\n", svname);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int lmd_make_exclusion(struct lustre_mount_data *lmd, const char *ptr)\r\n{\r\nconst char *s1 = ptr, *s2;\r\n__u32 index = 0, *exclude_list;\r\nint rc = 0, devmax;\r\ndevmax = strlen(ptr) / 8 + 1;\r\nexclude_list = kcalloc(devmax, sizeof(index), GFP_NOFS);\r\nif (!exclude_list)\r\nreturn -ENOMEM;\r\nwhile (*s1 && *s1 != ' ' && *s1 != ',') {\r\ns1++;\r\nrc = server_name2index(s1, &index, &s2);\r\nif (rc < 0) {\r\nCERROR("Can't parse server name '%s': rc = %d\n",\r\ns1, rc);\r\nbreak;\r\n}\r\nif (rc == LDD_F_SV_TYPE_OST)\r\nexclude_list[lmd->lmd_exclude_count++] = index;\r\nelse\r\nCDEBUG(D_MOUNT, "ignoring exclude %.*s: type = %#x\n",\r\n(uint)(s2 - s1), s1, rc);\r\ns1 = s2;\r\nif (lmd->lmd_exclude_count >= devmax)\r\nbreak;\r\n}\r\nif (rc >= 0)\r\nrc = 0;\r\nif (lmd->lmd_exclude_count) {\r\nlmd->lmd_exclude = kcalloc(lmd->lmd_exclude_count,\r\nsizeof(index), GFP_NOFS);\r\nif (lmd->lmd_exclude) {\r\nmemcpy(lmd->lmd_exclude, exclude_list,\r\nsizeof(index) * lmd->lmd_exclude_count);\r\n} else {\r\nrc = -ENOMEM;\r\nlmd->lmd_exclude_count = 0;\r\n}\r\n}\r\nkfree(exclude_list);\r\nreturn rc;\r\n}\r\nstatic int lmd_parse_mgssec(struct lustre_mount_data *lmd, char *ptr)\r\n{\r\nchar *tail;\r\nint length;\r\nkfree(lmd->lmd_mgssec);\r\nlmd->lmd_mgssec = NULL;\r\ntail = strchr(ptr, ',');\r\nif (!tail)\r\nlength = strlen(ptr);\r\nelse\r\nlength = tail - ptr;\r\nlmd->lmd_mgssec = kzalloc(length + 1, GFP_NOFS);\r\nif (!lmd->lmd_mgssec)\r\nreturn -ENOMEM;\r\nmemcpy(lmd->lmd_mgssec, ptr, length);\r\nlmd->lmd_mgssec[length] = '\0';\r\nreturn 0;\r\n}\r\nstatic int lmd_parse_string(char **handle, char *ptr)\r\n{\r\nchar *tail;\r\nint length;\r\nif (!handle || !ptr)\r\nreturn -EINVAL;\r\nkfree(*handle);\r\n*handle = NULL;\r\ntail = strchr(ptr, ',');\r\nif (!tail)\r\nlength = strlen(ptr);\r\nelse\r\nlength = tail - ptr;\r\n*handle = kzalloc(length + 1, GFP_NOFS);\r\nif (!*handle)\r\nreturn -ENOMEM;\r\nmemcpy(*handle, ptr, length);\r\n(*handle)[length] = '\0';\r\nreturn 0;\r\n}\r\nstatic int lmd_parse_mgs(struct lustre_mount_data *lmd, char **ptr)\r\n{\r\nlnet_nid_t nid;\r\nchar *tail = *ptr;\r\nchar *mgsnid;\r\nint length;\r\nint oldlen = 0;\r\nwhile (class_parse_nid_quiet(tail, &nid, &tail) == 0)\r\n;\r\nlength = tail - *ptr;\r\nif (length == 0) {\r\nLCONSOLE_ERROR_MSG(0x159, "Can't parse NID '%s'\n", *ptr);\r\nreturn -EINVAL;\r\n}\r\nif (lmd->lmd_mgs)\r\noldlen = strlen(lmd->lmd_mgs) + 1;\r\nmgsnid = kzalloc(oldlen + length + 1, GFP_NOFS);\r\nif (!mgsnid)\r\nreturn -ENOMEM;\r\nif (lmd->lmd_mgs) {\r\nmemcpy(mgsnid, lmd->lmd_mgs, oldlen);\r\nmgsnid[oldlen - 1] = ':';\r\nkfree(lmd->lmd_mgs);\r\n}\r\nmemcpy(mgsnid + oldlen, *ptr, length);\r\nmgsnid[oldlen + length] = '\0';\r\nlmd->lmd_mgs = mgsnid;\r\n*ptr = tail;\r\nreturn 0;\r\n}\r\nstatic int lmd_parse(char *options, struct lustre_mount_data *lmd)\r\n{\r\nchar *s1, *s2, *devname = NULL;\r\nstruct lustre_mount_data *raw = (struct lustre_mount_data *)options;\r\nint rc = 0;\r\nLASSERT(lmd);\r\nif (!options) {\r\nLCONSOLE_ERROR_MSG(0x162, "Missing mount data: check that /sbin/mount.lustre is installed.\n");\r\nreturn -EINVAL;\r\n}\r\nif ((raw->lmd_magic & 0xffffff00) == (LMD_MAGIC & 0xffffff00)) {\r\nLCONSOLE_ERROR_MSG(0x163, "You're using an old version of /sbin/mount.lustre. Please install version %s\n",\r\nLUSTRE_VERSION_STRING);\r\nreturn -EINVAL;\r\n}\r\nlmd->lmd_magic = LMD_MAGIC;\r\nlmd->lmd_params = kzalloc(LMD_PARAMS_MAXLEN, GFP_NOFS);\r\nif (!lmd->lmd_params)\r\nreturn -ENOMEM;\r\nlmd->lmd_params[0] = '\0';\r\ns1 = options;\r\nwhile (*s1) {\r\nint clear = 0;\r\nint time_min = OBD_RECOVERY_TIME_MIN;\r\nchar *s3;\r\nwhile (*s1 == ' ' || *s1 == ',')\r\ns1++;\r\ns3 = s1;\r\nif (strncmp(s1, "abort_recov", 11) == 0) {\r\nlmd->lmd_flags |= LMD_FLG_ABORT_RECOV;\r\nclear++;\r\n} else if (strncmp(s1, "recovery_time_soft=", 19) == 0) {\r\nlmd->lmd_recovery_time_soft = max_t(int,\r\nsimple_strtoul(s1 + 19, NULL, 10), time_min);\r\nclear++;\r\n} else if (strncmp(s1, "recovery_time_hard=", 19) == 0) {\r\nlmd->lmd_recovery_time_hard = max_t(int,\r\nsimple_strtoul(s1 + 19, NULL, 10), time_min);\r\nclear++;\r\n} else if (strncmp(s1, "noir", 4) == 0) {\r\nlmd->lmd_flags |= LMD_FLG_NOIR;\r\nclear++;\r\n} else if (strncmp(s1, "nosvc", 5) == 0) {\r\nlmd->lmd_flags |= LMD_FLG_NOSVC;\r\nclear++;\r\n} else if (strncmp(s1, "nomgs", 5) == 0) {\r\nlmd->lmd_flags |= LMD_FLG_NOMGS;\r\nclear++;\r\n} else if (strncmp(s1, "noscrub", 7) == 0) {\r\nlmd->lmd_flags |= LMD_FLG_NOSCRUB;\r\nclear++;\r\n} else if (strncmp(s1, PARAM_MGSNODE,\r\nsizeof(PARAM_MGSNODE) - 1) == 0) {\r\ns2 = s1 + sizeof(PARAM_MGSNODE) - 1;\r\nrc = lmd_parse_mgs(lmd, &s2);\r\nif (rc)\r\ngoto invalid;\r\nclear++;\r\n} else if (strncmp(s1, "writeconf", 9) == 0) {\r\nlmd->lmd_flags |= LMD_FLG_WRITECONF;\r\nclear++;\r\n} else if (strncmp(s1, "update", 6) == 0) {\r\nlmd->lmd_flags |= LMD_FLG_UPDATE;\r\nclear++;\r\n} else if (strncmp(s1, "virgin", 6) == 0) {\r\nlmd->lmd_flags |= LMD_FLG_VIRGIN;\r\nclear++;\r\n} else if (strncmp(s1, "noprimnode", 10) == 0) {\r\nlmd->lmd_flags |= LMD_FLG_NO_PRIMNODE;\r\nclear++;\r\n} else if (strncmp(s1, "mgssec=", 7) == 0) {\r\nrc = lmd_parse_mgssec(lmd, s1 + 7);\r\nif (rc)\r\ngoto invalid;\r\ns3 = s2;\r\nclear++;\r\n} else if (strncmp(s1, "exclude=", 8) == 0) {\r\nrc = lmd_make_exclusion(lmd, s1 + 7);\r\nif (rc)\r\ngoto invalid;\r\nclear++;\r\n} else if (strncmp(s1, "mgs", 3) == 0) {\r\nlmd->lmd_flags |= LMD_FLG_MGS;\r\nclear++;\r\n} else if (strncmp(s1, "svname=", 7) == 0) {\r\nrc = lmd_parse_string(&lmd->lmd_profile, s1 + 7);\r\nif (rc)\r\ngoto invalid;\r\nclear++;\r\n} else if (strncmp(s1, "param=", 6) == 0) {\r\nsize_t length, params_length;\r\nchar *tail = strchr(s1 + 6, ',');\r\nif (!tail) {\r\nlength = strlen(s1);\r\n} else {\r\nlnet_nid_t nid;\r\nchar *param_str = tail + 1;\r\nint supplementary = 1;\r\nwhile (!class_parse_nid_quiet(param_str, &nid,\r\n&param_str)) {\r\nsupplementary = 0;\r\n}\r\nlength = param_str - s1 - supplementary;\r\n}\r\nlength -= 6;\r\nparams_length = strlen(lmd->lmd_params);\r\nif (params_length + length + 1 >= LMD_PARAMS_MAXLEN)\r\nreturn -E2BIG;\r\nstrncat(lmd->lmd_params, s1 + 6, length);\r\nlmd->lmd_params[params_length + length] = '\0';\r\nstrlcat(lmd->lmd_params, " ", LMD_PARAMS_MAXLEN);\r\ns3 = s1 + 6 + length;\r\nclear++;\r\n} else if (strncmp(s1, "osd=", 4) == 0) {\r\nrc = lmd_parse_string(&lmd->lmd_osd_type, s1 + 4);\r\nif (rc)\r\ngoto invalid;\r\nclear++;\r\n}\r\nelse if (strncmp(s1, "device=", 7) == 0) {\r\ndevname = s1 + 7;\r\n*s1 = '\0';\r\nbreak;\r\n}\r\ns2 = strchr(s1, ',');\r\nif (!s2) {\r\nif (clear)\r\n*s1 = '\0';\r\nbreak;\r\n}\r\ns2++;\r\nif (clear)\r\nmemmove(s1, s2, strlen(s2) + 1);\r\nelse\r\ns1 = s2;\r\n}\r\nif (!devname) {\r\nLCONSOLE_ERROR_MSG(0x164, "Can't find the device name (need mount option 'device=...')\n");\r\ngoto invalid;\r\n}\r\ns1 = strstr(devname, ":/");\r\nif (s1) {\r\n++s1;\r\nlmd->lmd_flags |= LMD_FLG_CLIENT;\r\nwhile (*++s1 == '/')\r\n;\r\nlmd->lmd_profile = kasprintf(GFP_NOFS, "%s-client", s1);\r\nif (!lmd->lmd_profile)\r\nreturn -ENOMEM;\r\n}\r\nlmd->lmd_dev = kzalloc(strlen(devname) + 1, GFP_NOFS);\r\nif (!lmd->lmd_dev)\r\nreturn -ENOMEM;\r\nstrcpy(lmd->lmd_dev, devname);\r\ns1 = options + strlen(options) - 1;\r\nwhile (s1 >= options && (*s1 == ',' || *s1 == ' '))\r\n*s1-- = 0;\r\nif (*options != 0) {\r\nlmd->lmd_opts = kzalloc(strlen(options) + 1, GFP_NOFS);\r\nif (!lmd->lmd_opts)\r\nreturn -ENOMEM;\r\nstrcpy(lmd->lmd_opts, options);\r\n}\r\nlmd_print(lmd);\r\nlmd->lmd_magic = LMD_MAGIC;\r\nreturn rc;\r\ninvalid:\r\nCERROR("Bad mount options %s\n", options);\r\nreturn -EINVAL;\r\n}\r\nstatic int lustre_fill_super(struct super_block *sb, void *data, int silent)\r\n{\r\nstruct lustre_mount_data *lmd;\r\nstruct lustre_mount_data2 *lmd2 = data;\r\nstruct lustre_sb_info *lsi;\r\nint rc;\r\nCDEBUG(D_MOUNT | D_VFSTRACE, "VFS Op: sb %p\n", sb);\r\nlsi = lustre_init_lsi(sb);\r\nif (!lsi)\r\nreturn -ENOMEM;\r\nlmd = lsi->lsi_lmd;\r\nlockdep_off();\r\nobd_zombie_barrier();\r\nif (lmd_parse((lmd2->lmd2_data), lmd)) {\r\nlustre_put_lsi(sb);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (lmd_is_client(lmd)) {\r\nCDEBUG(D_MOUNT, "Mounting client %s\n", lmd->lmd_profile);\r\nif (!client_fill_super)\r\nrequest_module("lustre");\r\nif (!client_fill_super) {\r\nLCONSOLE_ERROR_MSG(0x165, "Nothing registered for client mount! Is the 'lustre' module loaded?\n");\r\nlustre_put_lsi(sb);\r\nrc = -ENODEV;\r\n} else {\r\nrc = lustre_start_mgc(sb);\r\nif (rc) {\r\nlustre_common_put_super(sb);\r\ngoto out;\r\n}\r\nrc = (*client_fill_super)(sb, lmd2->lmd2_mnt);\r\n}\r\n} else {\r\nCERROR("This is client-side-only module, cannot handle server mount.\n");\r\nrc = -EINVAL;\r\n}\r\ngoto out;\r\nout:\r\nif (rc) {\r\nCERROR("Unable to mount %s (%d)\n",\r\ns2lsi(sb) ? lmd->lmd_dev : "", rc);\r\n} else {\r\nCDEBUG(D_SUPER, "Mount %s complete\n",\r\nlmd->lmd_dev);\r\n}\r\nlockdep_on();\r\nreturn rc;\r\n}\r\nvoid lustre_register_client_fill_super(int (*cfs)(struct super_block *sb,\r\nstruct vfsmount *mnt))\r\n{\r\nclient_fill_super = cfs;\r\n}\r\nvoid lustre_register_kill_super_cb(void (*cfs)(struct super_block *sb))\r\n{\r\nkill_super_cb = cfs;\r\n}\r\nstatic struct dentry *lustre_mount(struct file_system_type *fs_type, int flags,\r\nconst char *devname, void *data)\r\n{\r\nstruct lustre_mount_data2 lmd2 = {\r\n.lmd2_data = data,\r\n.lmd2_mnt = NULL\r\n};\r\nreturn mount_nodev(fs_type, flags, &lmd2, lustre_fill_super);\r\n}\r\nstatic void lustre_kill_super(struct super_block *sb)\r\n{\r\nstruct lustre_sb_info *lsi = s2lsi(sb);\r\nif (kill_super_cb && lsi)\r\n(*kill_super_cb)(sb);\r\nkill_anon_super(sb);\r\n}\r\nint lustre_register_fs(void)\r\n{\r\nreturn register_filesystem(&lustre_fs_type);\r\n}\r\nint lustre_unregister_fs(void)\r\n{\r\nreturn unregister_filesystem(&lustre_fs_type);\r\n}
