static bool\r\nlnet_fault_nid_match(lnet_nid_t nid, lnet_nid_t msg_nid)\r\n{\r\nif (nid == msg_nid || nid == LNET_NID_ANY)\r\nreturn true;\r\nif (LNET_NIDNET(nid) != LNET_NIDNET(msg_nid))\r\nreturn false;\r\nreturn LNET_NIDADDR(nid) == LNET_NIDADDR(LNET_NID_ANY);\r\n}\r\nstatic bool\r\nlnet_fault_attr_match(struct lnet_fault_attr *attr, lnet_nid_t src,\r\nlnet_nid_t dst, unsigned int type, unsigned int portal)\r\n{\r\nif (!lnet_fault_nid_match(attr->fa_src, src) ||\r\n!lnet_fault_nid_match(attr->fa_dst, dst))\r\nreturn false;\r\nif (!(attr->fa_msg_mask & (1 << type)))\r\nreturn false;\r\nif (attr->fa_ptl_mask &&\r\n!(attr->fa_ptl_mask & (1ULL << portal)))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int\r\nlnet_fault_attr_validate(struct lnet_fault_attr *attr)\r\n{\r\nif (!attr->fa_msg_mask)\r\nattr->fa_msg_mask = LNET_MSG_MASK;\r\nif (!attr->fa_ptl_mask)\r\nreturn 0;\r\nattr->fa_msg_mask &= LNET_GET_BIT | LNET_PUT_BIT;\r\nif (!attr->fa_msg_mask) {\r\nCDEBUG(D_NET, "can't find valid message type bits %x\n",\r\nattr->fa_msg_mask);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nlnet_fault_stat_inc(struct lnet_fault_stat *stat, unsigned int type)\r\n{\r\nswitch (type) {\r\ncase LNET_MSG_PUT:\r\nstat->fs_put++;\r\nreturn;\r\ncase LNET_MSG_ACK:\r\nstat->fs_ack++;\r\nreturn;\r\ncase LNET_MSG_GET:\r\nstat->fs_get++;\r\nreturn;\r\ncase LNET_MSG_REPLY:\r\nstat->fs_reply++;\r\nreturn;\r\n}\r\n}\r\nstatic int\r\nlnet_drop_rule_add(struct lnet_fault_attr *attr)\r\n{\r\nstruct lnet_drop_rule *rule;\r\nif (attr->u.drop.da_rate & attr->u.drop.da_interval) {\r\nCDEBUG(D_NET, "please provide either drop rate or drop interval, but not both at the same time %d/%d\n",\r\nattr->u.drop.da_rate, attr->u.drop.da_interval);\r\nreturn -EINVAL;\r\n}\r\nif (lnet_fault_attr_validate(attr))\r\nreturn -EINVAL;\r\nCFS_ALLOC_PTR(rule);\r\nif (!rule)\r\nreturn -ENOMEM;\r\nspin_lock_init(&rule->dr_lock);\r\nrule->dr_attr = *attr;\r\nif (attr->u.drop.da_interval) {\r\nrule->dr_time_base = cfs_time_shift(attr->u.drop.da_interval);\r\nrule->dr_drop_time = cfs_time_shift(cfs_rand() %\r\nattr->u.drop.da_interval);\r\n} else {\r\nrule->dr_drop_at = cfs_rand() % attr->u.drop.da_rate;\r\n}\r\nlnet_net_lock(LNET_LOCK_EX);\r\nlist_add(&rule->dr_link, &the_lnet.ln_drop_rules);\r\nlnet_net_unlock(LNET_LOCK_EX);\r\nCDEBUG(D_NET, "Added drop rule: src %s, dst %s, rate %d, interval %d\n",\r\nlibcfs_nid2str(attr->fa_src), libcfs_nid2str(attr->fa_src),\r\nattr->u.drop.da_rate, attr->u.drop.da_interval);\r\nreturn 0;\r\n}\r\nstatic int\r\nlnet_drop_rule_del(lnet_nid_t src, lnet_nid_t dst)\r\n{\r\nstruct lnet_drop_rule *rule;\r\nstruct lnet_drop_rule *tmp;\r\nstruct list_head zombies;\r\nint n = 0;\r\nINIT_LIST_HEAD(&zombies);\r\nlnet_net_lock(LNET_LOCK_EX);\r\nlist_for_each_entry_safe(rule, tmp, &the_lnet.ln_drop_rules, dr_link) {\r\nif (rule->dr_attr.fa_src != src && src)\r\ncontinue;\r\nif (rule->dr_attr.fa_dst != dst && dst)\r\ncontinue;\r\nlist_move(&rule->dr_link, &zombies);\r\n}\r\nlnet_net_unlock(LNET_LOCK_EX);\r\nlist_for_each_entry_safe(rule, tmp, &zombies, dr_link) {\r\nCDEBUG(D_NET, "Remove drop rule: src %s->dst: %s (1/%d, %d)\n",\r\nlibcfs_nid2str(rule->dr_attr.fa_src),\r\nlibcfs_nid2str(rule->dr_attr.fa_dst),\r\nrule->dr_attr.u.drop.da_rate,\r\nrule->dr_attr.u.drop.da_interval);\r\nlist_del(&rule->dr_link);\r\nCFS_FREE_PTR(rule);\r\nn++;\r\n}\r\nreturn n;\r\n}\r\nstatic int\r\nlnet_drop_rule_list(int pos, struct lnet_fault_attr *attr,\r\nstruct lnet_fault_stat *stat)\r\n{\r\nstruct lnet_drop_rule *rule;\r\nint cpt;\r\nint i = 0;\r\nint rc = -ENOENT;\r\ncpt = lnet_net_lock_current();\r\nlist_for_each_entry(rule, &the_lnet.ln_drop_rules, dr_link) {\r\nif (i++ < pos)\r\ncontinue;\r\nspin_lock(&rule->dr_lock);\r\n*attr = rule->dr_attr;\r\n*stat = rule->dr_stat;\r\nspin_unlock(&rule->dr_lock);\r\nrc = 0;\r\nbreak;\r\n}\r\nlnet_net_unlock(cpt);\r\nreturn rc;\r\n}\r\nstatic void\r\nlnet_drop_rule_reset(void)\r\n{\r\nstruct lnet_drop_rule *rule;\r\nint cpt;\r\ncpt = lnet_net_lock_current();\r\nlist_for_each_entry(rule, &the_lnet.ln_drop_rules, dr_link) {\r\nstruct lnet_fault_attr *attr = &rule->dr_attr;\r\nspin_lock(&rule->dr_lock);\r\nmemset(&rule->dr_stat, 0, sizeof(rule->dr_stat));\r\nif (attr->u.drop.da_rate) {\r\nrule->dr_drop_at = cfs_rand() % attr->u.drop.da_rate;\r\n} else {\r\nrule->dr_drop_time = cfs_time_shift(cfs_rand() %\r\nattr->u.drop.da_interval);\r\nrule->dr_time_base = cfs_time_shift(attr->u.drop.da_interval);\r\n}\r\nspin_unlock(&rule->dr_lock);\r\n}\r\nlnet_net_unlock(cpt);\r\n}\r\nstatic bool\r\ndrop_rule_match(struct lnet_drop_rule *rule, lnet_nid_t src,\r\nlnet_nid_t dst, unsigned int type, unsigned int portal)\r\n{\r\nstruct lnet_fault_attr *attr = &rule->dr_attr;\r\nbool drop;\r\nif (!lnet_fault_attr_match(attr, src, dst, type, portal))\r\nreturn false;\r\nspin_lock(&rule->dr_lock);\r\nif (rule->dr_drop_time) {\r\nunsigned long now = cfs_time_current();\r\nrule->dr_stat.fs_count++;\r\ndrop = cfs_time_aftereq(now, rule->dr_drop_time);\r\nif (drop) {\r\nif (cfs_time_after(now, rule->dr_time_base))\r\nrule->dr_time_base = now;\r\nrule->dr_drop_time = rule->dr_time_base +\r\ncfs_time_seconds(cfs_rand() %\r\nattr->u.drop.da_interval);\r\nrule->dr_time_base += cfs_time_seconds(attr->u.drop.da_interval);\r\nCDEBUG(D_NET, "Drop Rule %s->%s: next drop : %lu\n",\r\nlibcfs_nid2str(attr->fa_src),\r\nlibcfs_nid2str(attr->fa_dst),\r\nrule->dr_drop_time);\r\n}\r\n} else {\r\ndrop = rule->dr_stat.fs_count++ == rule->dr_drop_at;\r\nif (!do_div(rule->dr_stat.fs_count, attr->u.drop.da_rate)) {\r\nrule->dr_drop_at = rule->dr_stat.fs_count +\r\ncfs_rand() % attr->u.drop.da_rate;\r\nCDEBUG(D_NET, "Drop Rule %s->%s: next drop: %lu\n",\r\nlibcfs_nid2str(attr->fa_src),\r\nlibcfs_nid2str(attr->fa_dst), rule->dr_drop_at);\r\n}\r\n}\r\nif (drop) {\r\nlnet_fault_stat_inc(&rule->dr_stat, type);\r\nrule->dr_stat.u.drop.ds_dropped++;\r\n}\r\nspin_unlock(&rule->dr_lock);\r\nreturn drop;\r\n}\r\nbool\r\nlnet_drop_rule_match(struct lnet_hdr *hdr)\r\n{\r\nstruct lnet_drop_rule *rule;\r\nlnet_nid_t src = le64_to_cpu(hdr->src_nid);\r\nlnet_nid_t dst = le64_to_cpu(hdr->dest_nid);\r\nunsigned int typ = le32_to_cpu(hdr->type);\r\nunsigned int ptl = -1;\r\nbool drop = false;\r\nint cpt;\r\nif (typ == LNET_MSG_PUT)\r\nptl = le32_to_cpu(hdr->msg.put.ptl_index);\r\nelse if (typ == LNET_MSG_GET)\r\nptl = le32_to_cpu(hdr->msg.get.ptl_index);\r\ncpt = lnet_net_lock_current();\r\nlist_for_each_entry(rule, &the_lnet.ln_drop_rules, dr_link) {\r\ndrop = drop_rule_match(rule, src, dst, typ, ptl);\r\nif (drop)\r\nbreak;\r\n}\r\nlnet_net_unlock(cpt);\r\nreturn drop;\r\n}\r\nstatic unsigned long\r\nround_timeout(unsigned long timeout)\r\n{\r\nreturn cfs_time_seconds((unsigned int)\r\ncfs_duration_sec(cfs_time_sub(timeout, 0)) + 1);\r\n}\r\nstatic void\r\ndelay_rule_decref(struct lnet_delay_rule *rule)\r\n{\r\nif (atomic_dec_and_test(&rule->dl_refcount)) {\r\nLASSERT(list_empty(&rule->dl_sched_link));\r\nLASSERT(list_empty(&rule->dl_msg_list));\r\nLASSERT(list_empty(&rule->dl_link));\r\nCFS_FREE_PTR(rule);\r\n}\r\n}\r\nstatic bool\r\ndelay_rule_match(struct lnet_delay_rule *rule, lnet_nid_t src,\r\nlnet_nid_t dst, unsigned int type, unsigned int portal,\r\nstruct lnet_msg *msg)\r\n{\r\nstruct lnet_fault_attr *attr = &rule->dl_attr;\r\nbool delay;\r\nif (!lnet_fault_attr_match(attr, src, dst, type, portal))\r\nreturn false;\r\nspin_lock(&rule->dl_lock);\r\nif (rule->dl_delay_time) {\r\nunsigned long now = cfs_time_current();\r\nrule->dl_stat.fs_count++;\r\ndelay = cfs_time_aftereq(now, rule->dl_delay_time);\r\nif (delay) {\r\nif (cfs_time_after(now, rule->dl_time_base))\r\nrule->dl_time_base = now;\r\nrule->dl_delay_time = rule->dl_time_base +\r\ncfs_time_seconds(cfs_rand() %\r\nattr->u.delay.la_interval);\r\nrule->dl_time_base += cfs_time_seconds(attr->u.delay.la_interval);\r\nCDEBUG(D_NET, "Delay Rule %s->%s: next delay : %lu\n",\r\nlibcfs_nid2str(attr->fa_src),\r\nlibcfs_nid2str(attr->fa_dst),\r\nrule->dl_delay_time);\r\n}\r\n} else {\r\ndelay = rule->dl_stat.fs_count++ == rule->dl_delay_at;\r\nif (!do_div(rule->dl_stat.fs_count, attr->u.delay.la_rate)) {\r\nrule->dl_delay_at = rule->dl_stat.fs_count +\r\ncfs_rand() % attr->u.delay.la_rate;\r\nCDEBUG(D_NET, "Delay Rule %s->%s: next delay: %lu\n",\r\nlibcfs_nid2str(attr->fa_src),\r\nlibcfs_nid2str(attr->fa_dst), rule->dl_delay_at);\r\n}\r\n}\r\nif (!delay) {\r\nspin_unlock(&rule->dl_lock);\r\nreturn false;\r\n}\r\nlnet_fault_stat_inc(&rule->dl_stat, type);\r\nrule->dl_stat.u.delay.ls_delayed++;\r\nlist_add_tail(&msg->msg_list, &rule->dl_msg_list);\r\nmsg->msg_delay_send = round_timeout(\r\ncfs_time_shift(attr->u.delay.la_latency));\r\nif (rule->dl_msg_send == -1) {\r\nrule->dl_msg_send = msg->msg_delay_send;\r\nmod_timer(&rule->dl_timer, rule->dl_msg_send);\r\n}\r\nspin_unlock(&rule->dl_lock);\r\nreturn true;\r\n}\r\nbool\r\nlnet_delay_rule_match_locked(struct lnet_hdr *hdr, struct lnet_msg *msg)\r\n{\r\nstruct lnet_delay_rule *rule;\r\nlnet_nid_t src = le64_to_cpu(hdr->src_nid);\r\nlnet_nid_t dst = le64_to_cpu(hdr->dest_nid);\r\nunsigned int typ = le32_to_cpu(hdr->type);\r\nunsigned int ptl = -1;\r\nif (typ == LNET_MSG_PUT)\r\nptl = le32_to_cpu(hdr->msg.put.ptl_index);\r\nelse if (typ == LNET_MSG_GET)\r\nptl = le32_to_cpu(hdr->msg.get.ptl_index);\r\nlist_for_each_entry(rule, &the_lnet.ln_delay_rules, dl_link) {\r\nif (delay_rule_match(rule, src, dst, typ, ptl, msg))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void\r\ndelayed_msg_check(struct lnet_delay_rule *rule, bool all,\r\nstruct list_head *msg_list)\r\n{\r\nstruct lnet_msg *msg;\r\nstruct lnet_msg *tmp;\r\nunsigned long now = cfs_time_current();\r\nif (!all && rule->dl_msg_send > now)\r\nreturn;\r\nspin_lock(&rule->dl_lock);\r\nlist_for_each_entry_safe(msg, tmp, &rule->dl_msg_list, msg_list) {\r\nif (!all && msg->msg_delay_send > now)\r\nbreak;\r\nmsg->msg_delay_send = 0;\r\nlist_move_tail(&msg->msg_list, msg_list);\r\n}\r\nif (list_empty(&rule->dl_msg_list)) {\r\ndel_timer(&rule->dl_timer);\r\nrule->dl_msg_send = -1;\r\n} else if (!list_empty(msg_list)) {\r\nmsg = list_entry(rule->dl_msg_list.next,\r\nstruct lnet_msg, msg_list);\r\nrule->dl_msg_send = msg->msg_delay_send;\r\nmod_timer(&rule->dl_timer, rule->dl_msg_send);\r\n}\r\nspin_unlock(&rule->dl_lock);\r\n}\r\nstatic void\r\ndelayed_msg_process(struct list_head *msg_list, bool drop)\r\n{\r\nstruct lnet_msg *msg;\r\nwhile (!list_empty(msg_list)) {\r\nstruct lnet_ni *ni;\r\nint cpt;\r\nint rc;\r\nmsg = list_entry(msg_list->next, struct lnet_msg, msg_list);\r\nLASSERT(msg->msg_rxpeer);\r\nni = msg->msg_rxpeer->lp_ni;\r\ncpt = msg->msg_rx_cpt;\r\nlist_del_init(&msg->msg_list);\r\nif (drop) {\r\nrc = -ECANCELED;\r\n} else if (!msg->msg_routing) {\r\nrc = lnet_parse_local(ni, msg);\r\nif (!rc)\r\ncontinue;\r\n} else {\r\nlnet_net_lock(cpt);\r\nrc = lnet_parse_forward_locked(ni, msg);\r\nlnet_net_unlock(cpt);\r\nswitch (rc) {\r\ncase LNET_CREDIT_OK:\r\nlnet_ni_recv(ni, msg->msg_private, msg, 0,\r\n0, msg->msg_len, msg->msg_len);\r\ncase LNET_CREDIT_WAIT:\r\ncontinue;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nlnet_drop_message(ni, cpt, msg->msg_private, msg->msg_len);\r\nlnet_finalize(ni, msg, rc);\r\n}\r\n}\r\nvoid\r\nlnet_delay_rule_check(void)\r\n{\r\nstruct lnet_delay_rule *rule;\r\nstruct list_head msgs;\r\nINIT_LIST_HEAD(&msgs);\r\nwhile (1) {\r\nif (list_empty(&delay_dd.dd_sched_rules))\r\nbreak;\r\nspin_lock_bh(&delay_dd.dd_lock);\r\nif (list_empty(&delay_dd.dd_sched_rules)) {\r\nspin_unlock_bh(&delay_dd.dd_lock);\r\nbreak;\r\n}\r\nrule = list_entry(delay_dd.dd_sched_rules.next,\r\nstruct lnet_delay_rule, dl_sched_link);\r\nlist_del_init(&rule->dl_sched_link);\r\nspin_unlock_bh(&delay_dd.dd_lock);\r\ndelayed_msg_check(rule, false, &msgs);\r\ndelay_rule_decref(rule);\r\n}\r\nif (!list_empty(&msgs))\r\ndelayed_msg_process(&msgs, false);\r\n}\r\nstatic int\r\nlnet_delay_rule_daemon(void *arg)\r\n{\r\ndelay_dd.dd_running = 1;\r\nwake_up(&delay_dd.dd_ctl_waitq);\r\nwhile (delay_dd.dd_running) {\r\nwait_event_interruptible(delay_dd.dd_waitq,\r\n!delay_dd.dd_running ||\r\n!list_empty(&delay_dd.dd_sched_rules));\r\nlnet_delay_rule_check();\r\n}\r\nlnet_delay_rule_check();\r\ndelay_dd.dd_stopped = 1;\r\nwake_up(&delay_dd.dd_ctl_waitq);\r\nreturn 0;\r\n}\r\nstatic void\r\ndelay_timer_cb(unsigned long arg)\r\n{\r\nstruct lnet_delay_rule *rule = (struct lnet_delay_rule *)arg;\r\nspin_lock_bh(&delay_dd.dd_lock);\r\nif (list_empty(&rule->dl_sched_link) && delay_dd.dd_running) {\r\natomic_inc(&rule->dl_refcount);\r\nlist_add_tail(&rule->dl_sched_link, &delay_dd.dd_sched_rules);\r\nwake_up(&delay_dd.dd_waitq);\r\n}\r\nspin_unlock_bh(&delay_dd.dd_lock);\r\n}\r\nint\r\nlnet_delay_rule_add(struct lnet_fault_attr *attr)\r\n{\r\nstruct lnet_delay_rule *rule;\r\nint rc = 0;\r\nif (attr->u.delay.la_rate & attr->u.delay.la_interval) {\r\nCDEBUG(D_NET, "please provide either delay rate or delay interval, but not both at the same time %d/%d\n",\r\nattr->u.delay.la_rate, attr->u.delay.la_interval);\r\nreturn -EINVAL;\r\n}\r\nif (!attr->u.delay.la_latency) {\r\nCDEBUG(D_NET, "delay latency cannot be zero\n");\r\nreturn -EINVAL;\r\n}\r\nif (lnet_fault_attr_validate(attr))\r\nreturn -EINVAL;\r\nCFS_ALLOC_PTR(rule);\r\nif (!rule)\r\nreturn -ENOMEM;\r\nmutex_lock(&delay_dd.dd_mutex);\r\nif (!delay_dd.dd_running) {\r\nstruct task_struct *task;\r\ntask = kthread_run(lnet_delay_rule_daemon, NULL, "lnet_dd");\r\nif (IS_ERR(task)) {\r\nrc = PTR_ERR(task);\r\ngoto failed;\r\n}\r\nwait_event(delay_dd.dd_ctl_waitq, delay_dd.dd_running);\r\n}\r\nsetup_timer(&rule->dl_timer, delay_timer_cb, (unsigned long)rule);\r\nspin_lock_init(&rule->dl_lock);\r\nINIT_LIST_HEAD(&rule->dl_msg_list);\r\nINIT_LIST_HEAD(&rule->dl_sched_link);\r\nrule->dl_attr = *attr;\r\nif (attr->u.delay.la_interval) {\r\nrule->dl_time_base = cfs_time_shift(attr->u.delay.la_interval);\r\nrule->dl_delay_time = cfs_time_shift(cfs_rand() %\r\nattr->u.delay.la_interval);\r\n} else {\r\nrule->dl_delay_at = cfs_rand() % attr->u.delay.la_rate;\r\n}\r\nrule->dl_msg_send = -1;\r\nlnet_net_lock(LNET_LOCK_EX);\r\natomic_set(&rule->dl_refcount, 1);\r\nlist_add(&rule->dl_link, &the_lnet.ln_delay_rules);\r\nlnet_net_unlock(LNET_LOCK_EX);\r\nCDEBUG(D_NET, "Added delay rule: src %s, dst %s, rate %d\n",\r\nlibcfs_nid2str(attr->fa_src), libcfs_nid2str(attr->fa_src),\r\nattr->u.delay.la_rate);\r\nmutex_unlock(&delay_dd.dd_mutex);\r\nreturn 0;\r\nfailed:\r\nmutex_unlock(&delay_dd.dd_mutex);\r\nCFS_FREE_PTR(rule);\r\nreturn rc;\r\n}\r\nint\r\nlnet_delay_rule_del(lnet_nid_t src, lnet_nid_t dst, bool shutdown)\r\n{\r\nstruct lnet_delay_rule *rule;\r\nstruct lnet_delay_rule *tmp;\r\nstruct list_head rule_list;\r\nstruct list_head msg_list;\r\nint n = 0;\r\nbool cleanup;\r\nINIT_LIST_HEAD(&rule_list);\r\nINIT_LIST_HEAD(&msg_list);\r\nif (shutdown) {\r\nsrc = 0;\r\ndst = 0;\r\n}\r\nmutex_lock(&delay_dd.dd_mutex);\r\nlnet_net_lock(LNET_LOCK_EX);\r\nlist_for_each_entry_safe(rule, tmp, &the_lnet.ln_delay_rules, dl_link) {\r\nif (rule->dl_attr.fa_src != src && src)\r\ncontinue;\r\nif (rule->dl_attr.fa_dst != dst && dst)\r\ncontinue;\r\nCDEBUG(D_NET, "Remove delay rule: src %s->dst: %s (1/%d, %d)\n",\r\nlibcfs_nid2str(rule->dl_attr.fa_src),\r\nlibcfs_nid2str(rule->dl_attr.fa_dst),\r\nrule->dl_attr.u.delay.la_rate,\r\nrule->dl_attr.u.delay.la_interval);\r\nlist_move(&rule->dl_link, &rule_list);\r\n}\r\ncleanup = list_empty(&the_lnet.ln_delay_rules) &&\r\n!list_empty(&rule_list);\r\nlnet_net_unlock(LNET_LOCK_EX);\r\nlist_for_each_entry_safe(rule, tmp, &rule_list, dl_link) {\r\nlist_del_init(&rule->dl_link);\r\ndel_timer_sync(&rule->dl_timer);\r\ndelayed_msg_check(rule, true, &msg_list);\r\ndelay_rule_decref(rule);\r\nn++;\r\n}\r\nif (cleanup) {\r\nLASSERT(delay_dd.dd_running);\r\ndelay_dd.dd_running = 0;\r\nwake_up(&delay_dd.dd_waitq);\r\nwhile (!delay_dd.dd_stopped)\r\nwait_event(delay_dd.dd_ctl_waitq, delay_dd.dd_stopped);\r\n}\r\nmutex_unlock(&delay_dd.dd_mutex);\r\nif (!list_empty(&msg_list))\r\ndelayed_msg_process(&msg_list, shutdown);\r\nreturn n;\r\n}\r\nint\r\nlnet_delay_rule_list(int pos, struct lnet_fault_attr *attr,\r\nstruct lnet_fault_stat *stat)\r\n{\r\nstruct lnet_delay_rule *rule;\r\nint cpt;\r\nint i = 0;\r\nint rc = -ENOENT;\r\ncpt = lnet_net_lock_current();\r\nlist_for_each_entry(rule, &the_lnet.ln_delay_rules, dl_link) {\r\nif (i++ < pos)\r\ncontinue;\r\nspin_lock(&rule->dl_lock);\r\n*attr = rule->dl_attr;\r\n*stat = rule->dl_stat;\r\nspin_unlock(&rule->dl_lock);\r\nrc = 0;\r\nbreak;\r\n}\r\nlnet_net_unlock(cpt);\r\nreturn rc;\r\n}\r\nvoid\r\nlnet_delay_rule_reset(void)\r\n{\r\nstruct lnet_delay_rule *rule;\r\nint cpt;\r\ncpt = lnet_net_lock_current();\r\nlist_for_each_entry(rule, &the_lnet.ln_delay_rules, dl_link) {\r\nstruct lnet_fault_attr *attr = &rule->dl_attr;\r\nspin_lock(&rule->dl_lock);\r\nmemset(&rule->dl_stat, 0, sizeof(rule->dl_stat));\r\nif (attr->u.delay.la_rate) {\r\nrule->dl_delay_at = cfs_rand() % attr->u.delay.la_rate;\r\n} else {\r\nrule->dl_delay_time = cfs_time_shift(cfs_rand() %\r\nattr->u.delay.la_interval);\r\nrule->dl_time_base = cfs_time_shift(attr->u.delay.la_interval);\r\n}\r\nspin_unlock(&rule->dl_lock);\r\n}\r\nlnet_net_unlock(cpt);\r\n}\r\nint\r\nlnet_fault_ctl(int opc, struct libcfs_ioctl_data *data)\r\n{\r\nstruct lnet_fault_attr *attr;\r\nstruct lnet_fault_stat *stat;\r\nattr = (struct lnet_fault_attr *)data->ioc_inlbuf1;\r\nswitch (opc) {\r\ndefault:\r\nreturn -EINVAL;\r\ncase LNET_CTL_DROP_ADD:\r\nif (!attr)\r\nreturn -EINVAL;\r\nreturn lnet_drop_rule_add(attr);\r\ncase LNET_CTL_DROP_DEL:\r\nif (!attr)\r\nreturn -EINVAL;\r\ndata->ioc_count = lnet_drop_rule_del(attr->fa_src,\r\nattr->fa_dst);\r\nreturn 0;\r\ncase LNET_CTL_DROP_RESET:\r\nlnet_drop_rule_reset();\r\nreturn 0;\r\ncase LNET_CTL_DROP_LIST:\r\nstat = (struct lnet_fault_stat *)data->ioc_inlbuf2;\r\nif (!attr || !stat)\r\nreturn -EINVAL;\r\nreturn lnet_drop_rule_list(data->ioc_count, attr, stat);\r\ncase LNET_CTL_DELAY_ADD:\r\nif (!attr)\r\nreturn -EINVAL;\r\nreturn lnet_delay_rule_add(attr);\r\ncase LNET_CTL_DELAY_DEL:\r\nif (!attr)\r\nreturn -EINVAL;\r\ndata->ioc_count = lnet_delay_rule_del(attr->fa_src,\r\nattr->fa_dst, false);\r\nreturn 0;\r\ncase LNET_CTL_DELAY_RESET:\r\nlnet_delay_rule_reset();\r\nreturn 0;\r\ncase LNET_CTL_DELAY_LIST:\r\nstat = (struct lnet_fault_stat *)data->ioc_inlbuf2;\r\nif (!attr || !stat)\r\nreturn -EINVAL;\r\nreturn lnet_delay_rule_list(data->ioc_count, attr, stat);\r\n}\r\n}\r\nint\r\nlnet_fault_init(void)\r\n{\r\nBUILD_BUG_ON(LNET_PUT_BIT != 1 << LNET_MSG_PUT);\r\nBUILD_BUG_ON(LNET_ACK_BIT != 1 << LNET_MSG_ACK);\r\nBUILD_BUG_ON(LNET_GET_BIT != 1 << LNET_MSG_GET);\r\nBUILD_BUG_ON(LNET_REPLY_BIT != 1 << LNET_MSG_REPLY);\r\nmutex_init(&delay_dd.dd_mutex);\r\nspin_lock_init(&delay_dd.dd_lock);\r\ninit_waitqueue_head(&delay_dd.dd_waitq);\r\ninit_waitqueue_head(&delay_dd.dd_ctl_waitq);\r\nINIT_LIST_HEAD(&delay_dd.dd_sched_rules);\r\nreturn 0;\r\n}\r\nvoid\r\nlnet_fault_fini(void)\r\n{\r\nlnet_drop_rule_del(0, 0);\r\nlnet_delay_rule_del(0, 0, true);\r\nLASSERT(list_empty(&the_lnet.ln_drop_rules));\r\nLASSERT(list_empty(&the_lnet.ln_delay_rules));\r\nLASSERT(list_empty(&delay_dd.dd_sched_rules));\r\n}
