static struct imx_usbmisc_data *usbmisc_get_init_data(struct device *dev)\r\n{\r\nstruct platform_device *misc_pdev;\r\nstruct device_node *np = dev->of_node;\r\nstruct of_phandle_args args;\r\nstruct imx_usbmisc_data *data;\r\nint ret;\r\nif (!of_get_property(np, "fsl,usbmisc", NULL))\r\nreturn NULL;\r\ndata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = of_parse_phandle_with_args(np, "fsl,usbmisc", "#index-cells",\r\n0, &args);\r\nif (ret) {\r\ndev_err(dev, "Failed to parse property fsl,usbmisc, errno %d\n",\r\nret);\r\nreturn ERR_PTR(ret);\r\n}\r\ndata->index = args.args[0];\r\nmisc_pdev = of_find_device_by_node(args.np);\r\nof_node_put(args.np);\r\nif (!misc_pdev || !platform_get_drvdata(misc_pdev))\r\nreturn ERR_PTR(-EPROBE_DEFER);\r\ndata->dev = &misc_pdev->dev;\r\nif (of_find_property(np, "disable-over-current", NULL))\r\ndata->disable_oc = 1;\r\nif (of_find_property(np, "over-current-active-high", NULL))\r\ndata->oc_polarity = 1;\r\nif (of_find_property(np, "external-vbus-divider", NULL))\r\ndata->evdo = 1;\r\nif (of_usb_get_phy_mode(np) == USBPHY_INTERFACE_MODE_ULPI)\r\ndata->ulpi = 1;\r\nreturn data;\r\n}\r\nstatic int imx_get_clks(struct device *dev)\r\n{\r\nstruct ci_hdrc_imx_data *data = dev_get_drvdata(dev);\r\nint ret = 0;\r\ndata->clk_ipg = devm_clk_get(dev, "ipg");\r\nif (IS_ERR(data->clk_ipg)) {\r\ndata->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(data->clk)) {\r\nret = PTR_ERR(data->clk);\r\ndev_err(dev,\r\n"Failed to get clks, err=%ld,%ld\n",\r\nPTR_ERR(data->clk), PTR_ERR(data->clk_ipg));\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\ndata->clk_ahb = devm_clk_get(dev, "ahb");\r\nif (IS_ERR(data->clk_ahb)) {\r\nret = PTR_ERR(data->clk_ahb);\r\ndev_err(dev,\r\n"Failed to get ahb clock, err=%d\n", ret);\r\nreturn ret;\r\n}\r\ndata->clk_per = devm_clk_get(dev, "per");\r\nif (IS_ERR(data->clk_per)) {\r\nret = PTR_ERR(data->clk_per);\r\ndev_err(dev,\r\n"Failed to get per clock, err=%d\n", ret);\r\nreturn ret;\r\n}\r\ndata->need_three_clks = true;\r\nreturn ret;\r\n}\r\nstatic int imx_prepare_enable_clks(struct device *dev)\r\n{\r\nstruct ci_hdrc_imx_data *data = dev_get_drvdata(dev);\r\nint ret = 0;\r\nif (data->need_three_clks) {\r\nret = clk_prepare_enable(data->clk_ipg);\r\nif (ret) {\r\ndev_err(dev,\r\n"Failed to prepare/enable ipg clk, err=%d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(data->clk_ahb);\r\nif (ret) {\r\ndev_err(dev,\r\n"Failed to prepare/enable ahb clk, err=%d\n",\r\nret);\r\nclk_disable_unprepare(data->clk_ipg);\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(data->clk_per);\r\nif (ret) {\r\ndev_err(dev,\r\n"Failed to prepare/enable per clk, err=%d\n",\r\nret);\r\nclk_disable_unprepare(data->clk_ahb);\r\nclk_disable_unprepare(data->clk_ipg);\r\nreturn ret;\r\n}\r\n} else {\r\nret = clk_prepare_enable(data->clk);\r\nif (ret) {\r\ndev_err(dev,\r\n"Failed to prepare/enable clk, err=%d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void imx_disable_unprepare_clks(struct device *dev)\r\n{\r\nstruct ci_hdrc_imx_data *data = dev_get_drvdata(dev);\r\nif (data->need_three_clks) {\r\nclk_disable_unprepare(data->clk_per);\r\nclk_disable_unprepare(data->clk_ahb);\r\nclk_disable_unprepare(data->clk_ipg);\r\n} else {\r\nclk_disable_unprepare(data->clk);\r\n}\r\n}\r\nstatic int ci_hdrc_imx_probe(struct platform_device *pdev)\r\n{\r\nstruct ci_hdrc_imx_data *data;\r\nstruct ci_hdrc_platform_data pdata = {\r\n.name = dev_name(&pdev->dev),\r\n.capoffset = DEF_CAPOFFSET,\r\n};\r\nint ret;\r\nconst struct of_device_id *of_id;\r\nconst struct ci_hdrc_imx_platform_flag *imx_platform_flag;\r\nof_id = of_match_device(ci_hdrc_imx_dt_ids, &pdev->dev);\r\nif (!of_id)\r\nreturn -ENODEV;\r\nimx_platform_flag = of_id->data;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, data);\r\ndata->usbmisc_data = usbmisc_get_init_data(&pdev->dev);\r\nif (IS_ERR(data->usbmisc_data))\r\nreturn PTR_ERR(data->usbmisc_data);\r\nret = imx_get_clks(&pdev->dev);\r\nif (ret)\r\nreturn ret;\r\nret = imx_prepare_enable_clks(&pdev->dev);\r\nif (ret)\r\nreturn ret;\r\ndata->phy = devm_usb_get_phy_by_phandle(&pdev->dev, "fsl,usbphy", 0);\r\nif (IS_ERR(data->phy)) {\r\nret = PTR_ERR(data->phy);\r\nif (ret == -ENODEV)\r\nret = -EINVAL;\r\ngoto err_clk;\r\n}\r\npdata.usb_phy = data->phy;\r\npdata.flags |= imx_platform_flag->flags;\r\nif (pdata.flags & CI_HDRC_SUPPORTS_RUNTIME_PM)\r\ndata->supports_runtime_pm = true;\r\nret = imx_usbmisc_init(data->usbmisc_data);\r\nif (ret) {\r\ndev_err(&pdev->dev, "usbmisc init failed, ret=%d\n", ret);\r\ngoto err_clk;\r\n}\r\ndata->ci_pdev = ci_hdrc_add_device(&pdev->dev,\r\npdev->resource, pdev->num_resources,\r\n&pdata);\r\nif (IS_ERR(data->ci_pdev)) {\r\nret = PTR_ERR(data->ci_pdev);\r\nif (ret != -EPROBE_DEFER)\r\ndev_err(&pdev->dev,\r\n"ci_hdrc_add_device failed, err=%d\n", ret);\r\ngoto err_clk;\r\n}\r\nret = imx_usbmisc_init_post(data->usbmisc_data);\r\nif (ret) {\r\ndev_err(&pdev->dev, "usbmisc post failed, ret=%d\n", ret);\r\ngoto disable_device;\r\n}\r\nif (data->supports_runtime_pm) {\r\npm_runtime_set_active(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\n}\r\ndevice_set_wakeup_capable(&pdev->dev, true);\r\nreturn 0;\r\ndisable_device:\r\nci_hdrc_remove_device(data->ci_pdev);\r\nerr_clk:\r\nimx_disable_unprepare_clks(&pdev->dev);\r\nreturn ret;\r\n}\r\nstatic int ci_hdrc_imx_remove(struct platform_device *pdev)\r\n{\r\nstruct ci_hdrc_imx_data *data = platform_get_drvdata(pdev);\r\nif (data->supports_runtime_pm) {\r\npm_runtime_get_sync(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\npm_runtime_put_noidle(&pdev->dev);\r\n}\r\nci_hdrc_remove_device(data->ci_pdev);\r\nimx_disable_unprepare_clks(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic void ci_hdrc_imx_shutdown(struct platform_device *pdev)\r\n{\r\nci_hdrc_imx_remove(pdev);\r\n}\r\nstatic int imx_controller_suspend(struct device *dev)\r\n{\r\nstruct ci_hdrc_imx_data *data = dev_get_drvdata(dev);\r\ndev_dbg(dev, "at %s\n", __func__);\r\nimx_disable_unprepare_clks(dev);\r\ndata->in_lpm = true;\r\nreturn 0;\r\n}\r\nstatic int imx_controller_resume(struct device *dev)\r\n{\r\nstruct ci_hdrc_imx_data *data = dev_get_drvdata(dev);\r\nint ret = 0;\r\ndev_dbg(dev, "at %s\n", __func__);\r\nif (!data->in_lpm) {\r\nWARN_ON(1);\r\nreturn 0;\r\n}\r\nret = imx_prepare_enable_clks(dev);\r\nif (ret)\r\nreturn ret;\r\ndata->in_lpm = false;\r\nret = imx_usbmisc_set_wakeup(data->usbmisc_data, false);\r\nif (ret) {\r\ndev_err(dev, "usbmisc set_wakeup failed, ret=%d\n", ret);\r\ngoto clk_disable;\r\n}\r\nreturn 0;\r\nclk_disable:\r\nimx_disable_unprepare_clks(dev);\r\nreturn ret;\r\n}\r\nstatic int ci_hdrc_imx_suspend(struct device *dev)\r\n{\r\nint ret;\r\nstruct ci_hdrc_imx_data *data = dev_get_drvdata(dev);\r\nif (data->in_lpm)\r\nreturn 0;\r\nif (device_may_wakeup(dev)) {\r\nret = imx_usbmisc_set_wakeup(data->usbmisc_data, true);\r\nif (ret) {\r\ndev_err(dev, "usbmisc set_wakeup failed, ret=%d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nreturn imx_controller_suspend(dev);\r\n}\r\nstatic int ci_hdrc_imx_resume(struct device *dev)\r\n{\r\nstruct ci_hdrc_imx_data *data = dev_get_drvdata(dev);\r\nint ret;\r\nret = imx_controller_resume(dev);\r\nif (!ret && data->supports_runtime_pm) {\r\npm_runtime_disable(dev);\r\npm_runtime_set_active(dev);\r\npm_runtime_enable(dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ci_hdrc_imx_runtime_suspend(struct device *dev)\r\n{\r\nstruct ci_hdrc_imx_data *data = dev_get_drvdata(dev);\r\nint ret;\r\nif (data->in_lpm) {\r\nWARN_ON(1);\r\nreturn 0;\r\n}\r\nret = imx_usbmisc_set_wakeup(data->usbmisc_data, true);\r\nif (ret) {\r\ndev_err(dev, "usbmisc set_wakeup failed, ret=%d\n", ret);\r\nreturn ret;\r\n}\r\nreturn imx_controller_suspend(dev);\r\n}\r\nstatic int ci_hdrc_imx_runtime_resume(struct device *dev)\r\n{\r\nreturn imx_controller_resume(dev);\r\n}
