static bool be_cmd_allowed(struct be_adapter *adapter, u8 opcode, u8 subsystem)\r\n{\r\nint i;\r\nint num_entries = sizeof(cmd_priv_map)/sizeof(struct be_cmd_priv_map);\r\nu32 cmd_privileges = adapter->cmd_privileges;\r\nfor (i = 0; i < num_entries; i++)\r\nif (opcode == cmd_priv_map[i].opcode &&\r\nsubsystem == cmd_priv_map[i].subsystem)\r\nif (!(cmd_privileges & cmd_priv_map[i].priv_mask))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic inline void *embedded_payload(struct be_mcc_wrb *wrb)\r\n{\r\nreturn wrb->payload.embedded_payload;\r\n}\r\nstatic int be_mcc_notify(struct be_adapter *adapter)\r\n{\r\nstruct be_queue_info *mccq = &adapter->mcc_obj.q;\r\nu32 val = 0;\r\nif (be_check_error(adapter, BE_ERROR_ANY))\r\nreturn -EIO;\r\nval |= mccq->id & DB_MCCQ_RING_ID_MASK;\r\nval |= 1 << DB_MCCQ_NUM_POSTED_SHIFT;\r\nwmb();\r\niowrite32(val, adapter->db + DB_MCCQ_OFFSET);\r\nreturn 0;\r\n}\r\nstatic inline bool be_mcc_compl_is_new(struct be_mcc_compl *compl)\r\n{\r\nu32 flags;\r\nif (compl->flags != 0) {\r\nflags = le32_to_cpu(compl->flags);\r\nif (flags & CQE_FLAGS_VALID_MASK) {\r\ncompl->flags = flags;\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic inline void be_mcc_compl_use(struct be_mcc_compl *compl)\r\n{\r\ncompl->flags = 0;\r\n}\r\nstatic struct be_cmd_resp_hdr *be_decode_resp_hdr(u32 tag0, u32 tag1)\r\n{\r\nunsigned long addr;\r\naddr = tag1;\r\naddr = ((addr << 16) << 16) | tag0;\r\nreturn (void *)addr;\r\n}\r\nstatic bool be_skip_err_log(u8 opcode, u16 base_status, u16 addl_status)\r\n{\r\nif (base_status == MCC_STATUS_NOT_SUPPORTED ||\r\nbase_status == MCC_STATUS_ILLEGAL_REQUEST ||\r\naddl_status == MCC_ADDL_STATUS_TOO_MANY_INTERFACES ||\r\naddl_status == MCC_ADDL_STATUS_INSUFFICIENT_VLANS ||\r\n(opcode == OPCODE_COMMON_WRITE_FLASHROM &&\r\n(base_status == MCC_STATUS_ILLEGAL_FIELD ||\r\naddl_status == MCC_ADDL_STATUS_FLASH_IMAGE_CRC_MISMATCH)))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic void be_async_cmd_process(struct be_adapter *adapter,\r\nstruct be_mcc_compl *compl,\r\nstruct be_cmd_resp_hdr *resp_hdr)\r\n{\r\nenum mcc_base_status base_status = base_status(compl->status);\r\nu8 opcode = 0, subsystem = 0;\r\nif (resp_hdr) {\r\nopcode = resp_hdr->opcode;\r\nsubsystem = resp_hdr->subsystem;\r\n}\r\nif (opcode == OPCODE_LOWLEVEL_LOOPBACK_TEST &&\r\nsubsystem == CMD_SUBSYSTEM_LOWLEVEL) {\r\ncomplete(&adapter->et_cmd_compl);\r\nreturn;\r\n}\r\nif (opcode == OPCODE_LOWLEVEL_SET_LOOPBACK_MODE &&\r\nsubsystem == CMD_SUBSYSTEM_LOWLEVEL) {\r\ncomplete(&adapter->et_cmd_compl);\r\nreturn;\r\n}\r\nif ((opcode == OPCODE_COMMON_WRITE_FLASHROM ||\r\nopcode == OPCODE_COMMON_WRITE_OBJECT) &&\r\nsubsystem == CMD_SUBSYSTEM_COMMON) {\r\nadapter->flash_status = compl->status;\r\ncomplete(&adapter->et_cmd_compl);\r\nreturn;\r\n}\r\nif ((opcode == OPCODE_ETH_GET_STATISTICS ||\r\nopcode == OPCODE_ETH_GET_PPORT_STATS) &&\r\nsubsystem == CMD_SUBSYSTEM_ETH &&\r\nbase_status == MCC_STATUS_SUCCESS) {\r\nbe_parse_stats(adapter);\r\nadapter->stats_cmd_sent = false;\r\nreturn;\r\n}\r\nif (opcode == OPCODE_COMMON_GET_CNTL_ADDITIONAL_ATTRIBUTES &&\r\nsubsystem == CMD_SUBSYSTEM_COMMON) {\r\nif (base_status == MCC_STATUS_SUCCESS) {\r\nstruct be_cmd_resp_get_cntl_addnl_attribs *resp =\r\n(void *)resp_hdr;\r\nadapter->hwmon_info.be_on_die_temp =\r\nresp->on_die_temperature;\r\n} else {\r\nadapter->be_get_temp_freq = 0;\r\nadapter->hwmon_info.be_on_die_temp =\r\nBE_INVALID_DIE_TEMP;\r\n}\r\nreturn;\r\n}\r\n}\r\nstatic int be_mcc_compl_process(struct be_adapter *adapter,\r\nstruct be_mcc_compl *compl)\r\n{\r\nenum mcc_base_status base_status;\r\nenum mcc_addl_status addl_status;\r\nstruct be_cmd_resp_hdr *resp_hdr;\r\nu8 opcode = 0, subsystem = 0;\r\nbe_dws_le_to_cpu(compl, 4);\r\nbase_status = base_status(compl->status);\r\naddl_status = addl_status(compl->status);\r\nresp_hdr = be_decode_resp_hdr(compl->tag0, compl->tag1);\r\nif (resp_hdr) {\r\nopcode = resp_hdr->opcode;\r\nsubsystem = resp_hdr->subsystem;\r\n}\r\nbe_async_cmd_process(adapter, compl, resp_hdr);\r\nif (base_status != MCC_STATUS_SUCCESS &&\r\n!be_skip_err_log(opcode, base_status, addl_status)) {\r\nif (base_status == MCC_STATUS_UNAUTHORIZED_REQUEST ||\r\naddl_status == MCC_ADDL_STATUS_INSUFFICIENT_PRIVILEGES) {\r\ndev_warn(&adapter->pdev->dev,\r\n"VF is not privileged to issue opcode %d-%d\n",\r\nopcode, subsystem);\r\n} else {\r\ndev_err(&adapter->pdev->dev,\r\n"opcode %d-%d failed:status %d-%d\n",\r\nopcode, subsystem, base_status, addl_status);\r\n}\r\n}\r\nreturn compl->status;\r\n}\r\nstatic void be_async_link_state_process(struct be_adapter *adapter,\r\nstruct be_mcc_compl *compl)\r\n{\r\nstruct be_async_event_link_state *evt =\r\n(struct be_async_event_link_state *)compl;\r\nadapter->phy.link_speed = -1;\r\nif (!BEx_chip(adapter) &&\r\n!(evt->port_link_status & LOGICAL_LINK_STATUS_MASK))\r\nreturn;\r\nif (adapter->flags & BE_FLAGS_LINK_STATUS_INIT)\r\nbe_link_status_update(adapter,\r\nevt->port_link_status & LINK_STATUS_MASK);\r\n}\r\nstatic void be_async_port_misconfig_event_process(struct be_adapter *adapter,\r\nstruct be_mcc_compl *compl)\r\n{\r\nstruct be_async_event_misconfig_port *evt =\r\n(struct be_async_event_misconfig_port *)compl;\r\nu32 sfp_misconfig_evt_word1 = le32_to_cpu(evt->event_data_word1);\r\nu32 sfp_misconfig_evt_word2 = le32_to_cpu(evt->event_data_word2);\r\nu8 phy_oper_state = PHY_STATE_OPER_MSG_NONE;\r\nstruct device *dev = &adapter->pdev->dev;\r\nu8 msg_severity = DEFAULT_MSG_SEVERITY;\r\nu8 phy_state_info;\r\nu8 new_phy_state;\r\nnew_phy_state =\r\n(sfp_misconfig_evt_word1 >> (adapter->hba_port_num * 8)) & 0xff;\r\nif (new_phy_state == adapter->phy_state)\r\nreturn;\r\nadapter->phy_state = new_phy_state;\r\nif (!sfp_misconfig_evt_word2)\r\ngoto log_message;\r\nphy_state_info =\r\n(sfp_misconfig_evt_word2 >> (adapter->hba_port_num * 8)) & 0xff;\r\nif (phy_state_info & PHY_STATE_INFO_VALID) {\r\nmsg_severity = (phy_state_info & PHY_STATE_MSG_SEVERITY) >> 1;\r\nif (be_phy_unqualified(new_phy_state))\r\nphy_oper_state = (phy_state_info & PHY_STATE_OPER);\r\n}\r\nlog_message:\r\nif (be_phy_state_unknown(new_phy_state))\r\ndev_printk(be_port_misconfig_evt_severity[msg_severity], dev,\r\n"Port %c: Unrecognized Optics state: 0x%x. %s",\r\nadapter->port_name,\r\nnew_phy_state,\r\nphy_state_oper_desc[phy_oper_state]);\r\nelse\r\ndev_printk(be_port_misconfig_evt_severity[msg_severity], dev,\r\n"Port %c: %s %s",\r\nadapter->port_name,\r\nbe_misconfig_evt_port_state[new_phy_state],\r\nphy_state_oper_desc[phy_oper_state]);\r\nif (be_phy_misconfigured(new_phy_state))\r\nadapter->flags |= BE_FLAGS_PHY_MISCONFIGURED;\r\n}\r\nstatic void be_async_grp5_cos_priority_process(struct be_adapter *adapter,\r\nstruct be_mcc_compl *compl)\r\n{\r\nstruct be_async_event_grp5_cos_priority *evt =\r\n(struct be_async_event_grp5_cos_priority *)compl;\r\nif (evt->valid) {\r\nadapter->vlan_prio_bmap = evt->available_priority_bmap;\r\nadapter->recommended_prio_bits =\r\nevt->reco_default_priority << VLAN_PRIO_SHIFT;\r\n}\r\n}\r\nstatic void be_async_grp5_qos_speed_process(struct be_adapter *adapter,\r\nstruct be_mcc_compl *compl)\r\n{\r\nstruct be_async_event_grp5_qos_link_speed *evt =\r\n(struct be_async_event_grp5_qos_link_speed *)compl;\r\nif (adapter->phy.link_speed >= 0 &&\r\nevt->physical_port == adapter->port_num)\r\nadapter->phy.link_speed = le16_to_cpu(evt->qos_link_speed) * 10;\r\n}\r\nstatic void be_async_grp5_pvid_state_process(struct be_adapter *adapter,\r\nstruct be_mcc_compl *compl)\r\n{\r\nstruct be_async_event_grp5_pvid_state *evt =\r\n(struct be_async_event_grp5_pvid_state *)compl;\r\nif (evt->enabled) {\r\nadapter->pvid = le16_to_cpu(evt->tag) & VLAN_VID_MASK;\r\ndev_info(&adapter->pdev->dev, "LPVID: %d\n", adapter->pvid);\r\n} else {\r\nadapter->pvid = 0;\r\n}\r\n}\r\nstatic void be_async_grp5_fw_control_process(struct be_adapter *adapter,\r\nstruct be_mcc_compl *compl)\r\n{\r\nstruct be_async_fw_control *evt = (struct be_async_fw_control *)compl;\r\nu32 evt_dw1 = le32_to_cpu(evt->event_data_word1);\r\nif (evt_dw1 & MGMT_ENABLE_MASK) {\r\nadapter->flags |= BE_FLAGS_OS2BMC;\r\nadapter->bmc_filt_mask = le32_to_cpu(evt->event_data_word2);\r\n} else {\r\nadapter->flags &= ~BE_FLAGS_OS2BMC;\r\n}\r\n}\r\nstatic void be_async_grp5_evt_process(struct be_adapter *adapter,\r\nstruct be_mcc_compl *compl)\r\n{\r\nu8 event_type = (compl->flags >> ASYNC_EVENT_TYPE_SHIFT) &\r\nASYNC_EVENT_TYPE_MASK;\r\nswitch (event_type) {\r\ncase ASYNC_EVENT_COS_PRIORITY:\r\nbe_async_grp5_cos_priority_process(adapter, compl);\r\nbreak;\r\ncase ASYNC_EVENT_QOS_SPEED:\r\nbe_async_grp5_qos_speed_process(adapter, compl);\r\nbreak;\r\ncase ASYNC_EVENT_PVID_STATE:\r\nbe_async_grp5_pvid_state_process(adapter, compl);\r\nbreak;\r\ncase ASYNC_EVENT_FW_CONTROL:\r\nbe_async_grp5_fw_control_process(adapter, compl);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void be_async_dbg_evt_process(struct be_adapter *adapter,\r\nstruct be_mcc_compl *cmp)\r\n{\r\nu8 event_type = 0;\r\nstruct be_async_event_qnq *evt = (struct be_async_event_qnq *)cmp;\r\nevent_type = (cmp->flags >> ASYNC_EVENT_TYPE_SHIFT) &\r\nASYNC_EVENT_TYPE_MASK;\r\nswitch (event_type) {\r\ncase ASYNC_DEBUG_EVENT_TYPE_QNQ:\r\nif (evt->valid)\r\nadapter->qnq_vid = le16_to_cpu(evt->vlan_tag);\r\nadapter->flags |= BE_FLAGS_QNQ_ASYNC_EVT_RCVD;\r\nbreak;\r\ndefault:\r\ndev_warn(&adapter->pdev->dev, "Unknown debug event 0x%x!\n",\r\nevent_type);\r\nbreak;\r\n}\r\n}\r\nstatic void be_async_sliport_evt_process(struct be_adapter *adapter,\r\nstruct be_mcc_compl *cmp)\r\n{\r\nu8 event_type = (cmp->flags >> ASYNC_EVENT_TYPE_SHIFT) &\r\nASYNC_EVENT_TYPE_MASK;\r\nif (event_type == ASYNC_EVENT_PORT_MISCONFIG)\r\nbe_async_port_misconfig_event_process(adapter, cmp);\r\n}\r\nstatic inline bool is_link_state_evt(u32 flags)\r\n{\r\nreturn ((flags >> ASYNC_EVENT_CODE_SHIFT) & ASYNC_EVENT_CODE_MASK) ==\r\nASYNC_EVENT_CODE_LINK_STATE;\r\n}\r\nstatic inline bool is_grp5_evt(u32 flags)\r\n{\r\nreturn ((flags >> ASYNC_EVENT_CODE_SHIFT) & ASYNC_EVENT_CODE_MASK) ==\r\nASYNC_EVENT_CODE_GRP_5;\r\n}\r\nstatic inline bool is_dbg_evt(u32 flags)\r\n{\r\nreturn ((flags >> ASYNC_EVENT_CODE_SHIFT) & ASYNC_EVENT_CODE_MASK) ==\r\nASYNC_EVENT_CODE_QNQ;\r\n}\r\nstatic inline bool is_sliport_evt(u32 flags)\r\n{\r\nreturn ((flags >> ASYNC_EVENT_CODE_SHIFT) & ASYNC_EVENT_CODE_MASK) ==\r\nASYNC_EVENT_CODE_SLIPORT;\r\n}\r\nstatic void be_mcc_event_process(struct be_adapter *adapter,\r\nstruct be_mcc_compl *compl)\r\n{\r\nif (is_link_state_evt(compl->flags))\r\nbe_async_link_state_process(adapter, compl);\r\nelse if (is_grp5_evt(compl->flags))\r\nbe_async_grp5_evt_process(adapter, compl);\r\nelse if (is_dbg_evt(compl->flags))\r\nbe_async_dbg_evt_process(adapter, compl);\r\nelse if (is_sliport_evt(compl->flags))\r\nbe_async_sliport_evt_process(adapter, compl);\r\n}\r\nstatic struct be_mcc_compl *be_mcc_compl_get(struct be_adapter *adapter)\r\n{\r\nstruct be_queue_info *mcc_cq = &adapter->mcc_obj.cq;\r\nstruct be_mcc_compl *compl = queue_tail_node(mcc_cq);\r\nif (be_mcc_compl_is_new(compl)) {\r\nqueue_tail_inc(mcc_cq);\r\nreturn compl;\r\n}\r\nreturn NULL;\r\n}\r\nvoid be_async_mcc_enable(struct be_adapter *adapter)\r\n{\r\nspin_lock_bh(&adapter->mcc_cq_lock);\r\nbe_cq_notify(adapter, adapter->mcc_obj.cq.id, true, 0);\r\nadapter->mcc_obj.rearm_cq = true;\r\nspin_unlock_bh(&adapter->mcc_cq_lock);\r\n}\r\nvoid be_async_mcc_disable(struct be_adapter *adapter)\r\n{\r\nspin_lock_bh(&adapter->mcc_cq_lock);\r\nadapter->mcc_obj.rearm_cq = false;\r\nbe_cq_notify(adapter, adapter->mcc_obj.cq.id, false, 0);\r\nspin_unlock_bh(&adapter->mcc_cq_lock);\r\n}\r\nint be_process_mcc(struct be_adapter *adapter)\r\n{\r\nstruct be_mcc_compl *compl;\r\nint num = 0, status = 0;\r\nstruct be_mcc_obj *mcc_obj = &adapter->mcc_obj;\r\nspin_lock(&adapter->mcc_cq_lock);\r\nwhile ((compl = be_mcc_compl_get(adapter))) {\r\nif (compl->flags & CQE_FLAGS_ASYNC_MASK) {\r\nbe_mcc_event_process(adapter, compl);\r\n} else if (compl->flags & CQE_FLAGS_COMPLETED_MASK) {\r\nstatus = be_mcc_compl_process(adapter, compl);\r\natomic_dec(&mcc_obj->q.used);\r\n}\r\nbe_mcc_compl_use(compl);\r\nnum++;\r\n}\r\nif (num)\r\nbe_cq_notify(adapter, mcc_obj->cq.id, mcc_obj->rearm_cq, num);\r\nspin_unlock(&adapter->mcc_cq_lock);\r\nreturn status;\r\n}\r\nstatic int be_mcc_wait_compl(struct be_adapter *adapter)\r\n{\r\n#define mcc_timeout 12000\r\nint i, status = 0;\r\nstruct be_mcc_obj *mcc_obj = &adapter->mcc_obj;\r\nfor (i = 0; i < mcc_timeout; i++) {\r\nif (be_check_error(adapter, BE_ERROR_ANY))\r\nreturn -EIO;\r\nlocal_bh_disable();\r\nstatus = be_process_mcc(adapter);\r\nlocal_bh_enable();\r\nif (atomic_read(&mcc_obj->q.used) == 0)\r\nbreak;\r\nusleep_range(500, 1000);\r\n}\r\nif (i == mcc_timeout) {\r\ndev_err(&adapter->pdev->dev, "FW not responding\n");\r\nbe_set_error(adapter, BE_ERROR_FW);\r\nreturn -EIO;\r\n}\r\nreturn status;\r\n}\r\nstatic int be_mcc_notify_wait(struct be_adapter *adapter)\r\n{\r\nint status;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_mcc_obj *mcc_obj = &adapter->mcc_obj;\r\nu32 index = mcc_obj->q.head;\r\nstruct be_cmd_resp_hdr *resp;\r\nindex_dec(&index, mcc_obj->q.len);\r\nwrb = queue_index_node(&mcc_obj->q, index);\r\nresp = be_decode_resp_hdr(wrb->tag0, wrb->tag1);\r\nstatus = be_mcc_notify(adapter);\r\nif (status)\r\ngoto out;\r\nstatus = be_mcc_wait_compl(adapter);\r\nif (status == -EIO)\r\ngoto out;\r\nstatus = (resp->base_status |\r\n((resp->addl_status & CQE_ADDL_STATUS_MASK) <<\r\nCQE_ADDL_STATUS_SHIFT));\r\nout:\r\nreturn status;\r\n}\r\nstatic int be_mbox_db_ready_wait(struct be_adapter *adapter, void __iomem *db)\r\n{\r\nint msecs = 0;\r\nu32 ready;\r\ndo {\r\nif (be_check_error(adapter, BE_ERROR_ANY))\r\nreturn -EIO;\r\nready = ioread32(db);\r\nif (ready == 0xffffffff)\r\nreturn -1;\r\nready &= MPU_MAILBOX_DB_RDY_MASK;\r\nif (ready)\r\nbreak;\r\nif (msecs > 4000) {\r\ndev_err(&adapter->pdev->dev, "FW not responding\n");\r\nbe_set_error(adapter, BE_ERROR_FW);\r\nbe_detect_error(adapter);\r\nreturn -1;\r\n}\r\nmsleep(1);\r\nmsecs++;\r\n} while (true);\r\nreturn 0;\r\n}\r\nstatic int be_mbox_notify_wait(struct be_adapter *adapter)\r\n{\r\nint status;\r\nu32 val = 0;\r\nvoid __iomem *db = adapter->db + MPU_MAILBOX_DB_OFFSET;\r\nstruct be_dma_mem *mbox_mem = &adapter->mbox_mem;\r\nstruct be_mcc_mailbox *mbox = mbox_mem->va;\r\nstruct be_mcc_compl *compl = &mbox->compl;\r\nstatus = be_mbox_db_ready_wait(adapter, db);\r\nif (status != 0)\r\nreturn status;\r\nval |= MPU_MAILBOX_DB_HI_MASK;\r\nval |= (upper_32_bits(mbox_mem->dma) >> 2) << 2;\r\niowrite32(val, db);\r\nstatus = be_mbox_db_ready_wait(adapter, db);\r\nif (status != 0)\r\nreturn status;\r\nval = 0;\r\nval |= (u32)(mbox_mem->dma >> 4) << 2;\r\niowrite32(val, db);\r\nstatus = be_mbox_db_ready_wait(adapter, db);\r\nif (status != 0)\r\nreturn status;\r\nif (be_mcc_compl_is_new(compl)) {\r\nstatus = be_mcc_compl_process(adapter, &mbox->compl);\r\nbe_mcc_compl_use(compl);\r\nif (status)\r\nreturn status;\r\n} else {\r\ndev_err(&adapter->pdev->dev, "invalid mailbox completion\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nu16 be_POST_stage_get(struct be_adapter *adapter)\r\n{\r\nu32 sem;\r\nif (BEx_chip(adapter))\r\nsem = ioread32(adapter->csr + SLIPORT_SEMAPHORE_OFFSET_BEx);\r\nelse\r\npci_read_config_dword(adapter->pdev,\r\nSLIPORT_SEMAPHORE_OFFSET_SH, &sem);\r\nreturn sem & POST_STAGE_MASK;\r\n}\r\nstatic int lancer_wait_ready(struct be_adapter *adapter)\r\n{\r\n#define SLIPORT_READY_TIMEOUT 30\r\nu32 sliport_status;\r\nint i;\r\nfor (i = 0; i < SLIPORT_READY_TIMEOUT; i++) {\r\nsliport_status = ioread32(adapter->db + SLIPORT_STATUS_OFFSET);\r\nif (sliport_status & SLIPORT_STATUS_RDY_MASK)\r\nreturn 0;\r\nif (sliport_status & SLIPORT_STATUS_ERR_MASK &&\r\n!(sliport_status & SLIPORT_STATUS_RN_MASK))\r\nreturn -EIO;\r\nmsleep(1000);\r\n}\r\nreturn sliport_status ? : -1;\r\n}\r\nint be_fw_wait_ready(struct be_adapter *adapter)\r\n{\r\nu16 stage;\r\nint status, timeout = 0;\r\nstruct device *dev = &adapter->pdev->dev;\r\nif (lancer_chip(adapter)) {\r\nstatus = lancer_wait_ready(adapter);\r\nif (status) {\r\nstage = status;\r\ngoto err;\r\n}\r\nreturn 0;\r\n}\r\ndo {\r\nif (BEx_chip(adapter) && be_virtfn(adapter))\r\nreturn 0;\r\nstage = be_POST_stage_get(adapter);\r\nif (stage == POST_STAGE_ARMFW_RDY)\r\nreturn 0;\r\ndev_info(dev, "Waiting for POST, %ds elapsed\n", timeout);\r\nif (msleep_interruptible(2000)) {\r\ndev_err(dev, "Waiting for POST aborted\n");\r\nreturn -EINTR;\r\n}\r\ntimeout += 2;\r\n} while (timeout < 60);\r\nerr:\r\ndev_err(dev, "POST timeout; stage=%#x\n", stage);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic inline struct be_sge *nonembedded_sgl(struct be_mcc_wrb *wrb)\r\n{\r\nreturn &wrb->payload.sgl[0];\r\n}\r\nstatic inline void fill_wrb_tags(struct be_mcc_wrb *wrb, unsigned long addr)\r\n{\r\nwrb->tag0 = addr & 0xFFFFFFFF;\r\nwrb->tag1 = upper_32_bits(addr);\r\n}\r\nstatic void be_wrb_cmd_hdr_prepare(struct be_cmd_req_hdr *req_hdr,\r\nu8 subsystem, u8 opcode, int cmd_len,\r\nstruct be_mcc_wrb *wrb,\r\nstruct be_dma_mem *mem)\r\n{\r\nstruct be_sge *sge;\r\nreq_hdr->opcode = opcode;\r\nreq_hdr->subsystem = subsystem;\r\nreq_hdr->request_length = cpu_to_le32(cmd_len - sizeof(*req_hdr));\r\nreq_hdr->version = 0;\r\nfill_wrb_tags(wrb, (ulong) req_hdr);\r\nwrb->payload_length = cmd_len;\r\nif (mem) {\r\nwrb->embedded |= (1 & MCC_WRB_SGE_CNT_MASK) <<\r\nMCC_WRB_SGE_CNT_SHIFT;\r\nsge = nonembedded_sgl(wrb);\r\nsge->pa_hi = cpu_to_le32(upper_32_bits(mem->dma));\r\nsge->pa_lo = cpu_to_le32(mem->dma & 0xFFFFFFFF);\r\nsge->len = cpu_to_le32(mem->size);\r\n} else\r\nwrb->embedded |= MCC_WRB_EMBEDDED_MASK;\r\nbe_dws_cpu_to_le(wrb, 8);\r\n}\r\nstatic void be_cmd_page_addrs_prepare(struct phys_addr *pages, u32 max_pages,\r\nstruct be_dma_mem *mem)\r\n{\r\nint i, buf_pages = min(PAGES_4K_SPANNED(mem->va, mem->size), max_pages);\r\nu64 dma = (u64)mem->dma;\r\nfor (i = 0; i < buf_pages; i++) {\r\npages[i].lo = cpu_to_le32(dma & 0xFFFFFFFF);\r\npages[i].hi = cpu_to_le32(upper_32_bits(dma));\r\ndma += PAGE_SIZE_4K;\r\n}\r\n}\r\nstatic inline struct be_mcc_wrb *wrb_from_mbox(struct be_adapter *adapter)\r\n{\r\nstruct be_dma_mem *mbox_mem = &adapter->mbox_mem;\r\nstruct be_mcc_wrb *wrb\r\n= &((struct be_mcc_mailbox *)(mbox_mem->va))->wrb;\r\nmemset(wrb, 0, sizeof(*wrb));\r\nreturn wrb;\r\n}\r\nstatic struct be_mcc_wrb *wrb_from_mccq(struct be_adapter *adapter)\r\n{\r\nstruct be_queue_info *mccq = &adapter->mcc_obj.q;\r\nstruct be_mcc_wrb *wrb;\r\nif (!mccq->created)\r\nreturn NULL;\r\nif (atomic_read(&mccq->used) >= mccq->len)\r\nreturn NULL;\r\nwrb = queue_head_node(mccq);\r\nqueue_head_inc(mccq);\r\natomic_inc(&mccq->used);\r\nmemset(wrb, 0, sizeof(*wrb));\r\nreturn wrb;\r\n}\r\nstatic bool use_mcc(struct be_adapter *adapter)\r\n{\r\nreturn adapter->mcc_obj.q.created;\r\n}\r\nstatic int be_cmd_lock(struct be_adapter *adapter)\r\n{\r\nif (use_mcc(adapter)) {\r\nmutex_lock(&adapter->mcc_lock);\r\nreturn 0;\r\n} else {\r\nreturn mutex_lock_interruptible(&adapter->mbox_lock);\r\n}\r\n}\r\nstatic void be_cmd_unlock(struct be_adapter *adapter)\r\n{\r\nif (use_mcc(adapter))\r\nreturn mutex_unlock(&adapter->mcc_lock);\r\nelse\r\nreturn mutex_unlock(&adapter->mbox_lock);\r\n}\r\nstatic struct be_mcc_wrb *be_cmd_copy(struct be_adapter *adapter,\r\nstruct be_mcc_wrb *wrb)\r\n{\r\nstruct be_mcc_wrb *dest_wrb;\r\nif (use_mcc(adapter)) {\r\ndest_wrb = wrb_from_mccq(adapter);\r\nif (!dest_wrb)\r\nreturn NULL;\r\n} else {\r\ndest_wrb = wrb_from_mbox(adapter);\r\n}\r\nmemcpy(dest_wrb, wrb, sizeof(*wrb));\r\nif (wrb->embedded & cpu_to_le32(MCC_WRB_EMBEDDED_MASK))\r\nfill_wrb_tags(dest_wrb, (ulong) embedded_payload(wrb));\r\nreturn dest_wrb;\r\n}\r\nstatic int be_cmd_notify_wait(struct be_adapter *adapter,\r\nstruct be_mcc_wrb *wrb)\r\n{\r\nstruct be_mcc_wrb *dest_wrb;\r\nint status;\r\nstatus = be_cmd_lock(adapter);\r\nif (status)\r\nreturn status;\r\ndest_wrb = be_cmd_copy(adapter, wrb);\r\nif (!dest_wrb) {\r\nstatus = -EBUSY;\r\ngoto unlock;\r\n}\r\nif (use_mcc(adapter))\r\nstatus = be_mcc_notify_wait(adapter);\r\nelse\r\nstatus = be_mbox_notify_wait(adapter);\r\nif (!status)\r\nmemcpy(wrb, dest_wrb, sizeof(*wrb));\r\nunlock:\r\nbe_cmd_unlock(adapter);\r\nreturn status;\r\n}\r\nint be_cmd_fw_init(struct be_adapter *adapter)\r\n{\r\nu8 *wrb;\r\nint status;\r\nif (lancer_chip(adapter))\r\nreturn 0;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nwrb = (u8 *)wrb_from_mbox(adapter);\r\n*wrb++ = 0xFF;\r\n*wrb++ = 0x12;\r\n*wrb++ = 0x34;\r\n*wrb++ = 0xFF;\r\n*wrb++ = 0xFF;\r\n*wrb++ = 0x56;\r\n*wrb++ = 0x78;\r\n*wrb = 0xFF;\r\nstatus = be_mbox_notify_wait(adapter);\r\nmutex_unlock(&adapter->mbox_lock);\r\nreturn status;\r\n}\r\nint be_cmd_fw_clean(struct be_adapter *adapter)\r\n{\r\nu8 *wrb;\r\nint status;\r\nif (lancer_chip(adapter))\r\nreturn 0;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nwrb = (u8 *)wrb_from_mbox(adapter);\r\n*wrb++ = 0xFF;\r\n*wrb++ = 0xAA;\r\n*wrb++ = 0xBB;\r\n*wrb++ = 0xFF;\r\n*wrb++ = 0xFF;\r\n*wrb++ = 0xCC;\r\n*wrb++ = 0xDD;\r\n*wrb = 0xFF;\r\nstatus = be_mbox_notify_wait(adapter);\r\nmutex_unlock(&adapter->mbox_lock);\r\nreturn status;\r\n}\r\nint be_cmd_eq_create(struct be_adapter *adapter, struct be_eq_obj *eqo)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_eq_create *req;\r\nstruct be_dma_mem *q_mem = &eqo->q.dma_mem;\r\nint status, ver = 0;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nwrb = wrb_from_mbox(adapter);\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_EQ_CREATE, sizeof(*req), wrb,\r\nNULL);\r\nif (!(BEx_chip(adapter) || lancer_chip(adapter)))\r\nver = 2;\r\nreq->hdr.version = ver;\r\nreq->num_pages = cpu_to_le16(PAGES_4K_SPANNED(q_mem->va, q_mem->size));\r\nAMAP_SET_BITS(struct amap_eq_context, valid, req->context, 1);\r\nAMAP_SET_BITS(struct amap_eq_context, size, req->context, 0);\r\nAMAP_SET_BITS(struct amap_eq_context, count, req->context,\r\n__ilog2_u32(eqo->q.len / 256));\r\nbe_dws_cpu_to_le(req->context, sizeof(req->context));\r\nbe_cmd_page_addrs_prepare(req->pages, ARRAY_SIZE(req->pages), q_mem);\r\nstatus = be_mbox_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_eq_create *resp = embedded_payload(wrb);\r\neqo->q.id = le16_to_cpu(resp->eq_id);\r\neqo->msix_idx =\r\n(ver == 2) ? le16_to_cpu(resp->msix_idx) : eqo->idx;\r\neqo->q.created = true;\r\n}\r\nmutex_unlock(&adapter->mbox_lock);\r\nreturn status;\r\n}\r\nint be_cmd_mac_addr_query(struct be_adapter *adapter, u8 *mac_addr,\r\nbool permanent, u32 if_handle, u32 pmac_id)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_mac_query *req;\r\nint status;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_NTWK_MAC_QUERY, sizeof(*req), wrb,\r\nNULL);\r\nreq->type = MAC_ADDRESS_TYPE_NETWORK;\r\nif (permanent) {\r\nreq->permanent = 1;\r\n} else {\r\nreq->if_id = cpu_to_le16((u16)if_handle);\r\nreq->pmac_id = cpu_to_le32(pmac_id);\r\nreq->permanent = 0;\r\n}\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_mac_query *resp = embedded_payload(wrb);\r\nmemcpy(mac_addr, resp->mac.addr, ETH_ALEN);\r\n}\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_pmac_add(struct be_adapter *adapter, u8 *mac_addr,\r\nu32 if_id, u32 *pmac_id, u32 domain)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_pmac_add *req;\r\nint status;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_NTWK_PMAC_ADD, sizeof(*req), wrb,\r\nNULL);\r\nreq->hdr.domain = domain;\r\nreq->if_id = cpu_to_le32(if_id);\r\nmemcpy(req->mac_address, mac_addr, ETH_ALEN);\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_pmac_add *resp = embedded_payload(wrb);\r\n*pmac_id = le32_to_cpu(resp->pmac_id);\r\n}\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nif (base_status(status) == MCC_STATUS_UNAUTHORIZED_REQUEST)\r\nstatus = -EPERM;\r\nreturn status;\r\n}\r\nint be_cmd_pmac_del(struct be_adapter *adapter, u32 if_id, int pmac_id, u32 dom)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_pmac_del *req;\r\nint status;\r\nif (pmac_id == -1)\r\nreturn 0;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_NTWK_PMAC_DEL, sizeof(*req),\r\nwrb, NULL);\r\nreq->hdr.domain = dom;\r\nreq->if_id = cpu_to_le32(if_id);\r\nreq->pmac_id = cpu_to_le32(pmac_id);\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_cq_create(struct be_adapter *adapter, struct be_queue_info *cq,\r\nstruct be_queue_info *eq, bool no_delay, int coalesce_wm)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_cq_create *req;\r\nstruct be_dma_mem *q_mem = &cq->dma_mem;\r\nvoid *ctxt;\r\nint status;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nwrb = wrb_from_mbox(adapter);\r\nreq = embedded_payload(wrb);\r\nctxt = &req->context;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_CQ_CREATE, sizeof(*req), wrb,\r\nNULL);\r\nreq->num_pages = cpu_to_le16(PAGES_4K_SPANNED(q_mem->va, q_mem->size));\r\nif (BEx_chip(adapter)) {\r\nAMAP_SET_BITS(struct amap_cq_context_be, coalescwm, ctxt,\r\ncoalesce_wm);\r\nAMAP_SET_BITS(struct amap_cq_context_be, nodelay,\r\nctxt, no_delay);\r\nAMAP_SET_BITS(struct amap_cq_context_be, count, ctxt,\r\n__ilog2_u32(cq->len / 256));\r\nAMAP_SET_BITS(struct amap_cq_context_be, valid, ctxt, 1);\r\nAMAP_SET_BITS(struct amap_cq_context_be, eventable, ctxt, 1);\r\nAMAP_SET_BITS(struct amap_cq_context_be, eqid, ctxt, eq->id);\r\n} else {\r\nreq->hdr.version = 2;\r\nreq->page_size = 1;\r\nif (!lancer_chip(adapter))\r\nAMAP_SET_BITS(struct amap_cq_context_v2, coalescwm,\r\nctxt, coalesce_wm);\r\nAMAP_SET_BITS(struct amap_cq_context_v2, nodelay, ctxt,\r\nno_delay);\r\nAMAP_SET_BITS(struct amap_cq_context_v2, count, ctxt,\r\n__ilog2_u32(cq->len / 256));\r\nAMAP_SET_BITS(struct amap_cq_context_v2, valid, ctxt, 1);\r\nAMAP_SET_BITS(struct amap_cq_context_v2, eventable, ctxt, 1);\r\nAMAP_SET_BITS(struct amap_cq_context_v2, eqid, ctxt, eq->id);\r\n}\r\nbe_dws_cpu_to_le(ctxt, sizeof(req->context));\r\nbe_cmd_page_addrs_prepare(req->pages, ARRAY_SIZE(req->pages), q_mem);\r\nstatus = be_mbox_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_cq_create *resp = embedded_payload(wrb);\r\ncq->id = le16_to_cpu(resp->cq_id);\r\ncq->created = true;\r\n}\r\nmutex_unlock(&adapter->mbox_lock);\r\nreturn status;\r\n}\r\nstatic u32 be_encoded_q_len(int q_len)\r\n{\r\nu32 len_encoded = fls(q_len);\r\nif (len_encoded == 16)\r\nlen_encoded = 0;\r\nreturn len_encoded;\r\n}\r\nstatic int be_cmd_mccq_ext_create(struct be_adapter *adapter,\r\nstruct be_queue_info *mccq,\r\nstruct be_queue_info *cq)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_mcc_ext_create *req;\r\nstruct be_dma_mem *q_mem = &mccq->dma_mem;\r\nvoid *ctxt;\r\nint status;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nwrb = wrb_from_mbox(adapter);\r\nreq = embedded_payload(wrb);\r\nctxt = &req->context;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_MCC_CREATE_EXT, sizeof(*req), wrb,\r\nNULL);\r\nreq->num_pages = cpu_to_le16(PAGES_4K_SPANNED(q_mem->va, q_mem->size));\r\nif (BEx_chip(adapter)) {\r\nAMAP_SET_BITS(struct amap_mcc_context_be, valid, ctxt, 1);\r\nAMAP_SET_BITS(struct amap_mcc_context_be, ring_size, ctxt,\r\nbe_encoded_q_len(mccq->len));\r\nAMAP_SET_BITS(struct amap_mcc_context_be, cq_id, ctxt, cq->id);\r\n} else {\r\nreq->hdr.version = 1;\r\nreq->cq_id = cpu_to_le16(cq->id);\r\nAMAP_SET_BITS(struct amap_mcc_context_v1, ring_size, ctxt,\r\nbe_encoded_q_len(mccq->len));\r\nAMAP_SET_BITS(struct amap_mcc_context_v1, valid, ctxt, 1);\r\nAMAP_SET_BITS(struct amap_mcc_context_v1, async_cq_id,\r\nctxt, cq->id);\r\nAMAP_SET_BITS(struct amap_mcc_context_v1, async_cq_valid,\r\nctxt, 1);\r\n}\r\nreq->async_event_bitmap[0] =\r\ncpu_to_le32(BIT(ASYNC_EVENT_CODE_LINK_STATE) |\r\nBIT(ASYNC_EVENT_CODE_GRP_5) |\r\nBIT(ASYNC_EVENT_CODE_QNQ) |\r\nBIT(ASYNC_EVENT_CODE_SLIPORT));\r\nbe_dws_cpu_to_le(ctxt, sizeof(req->context));\r\nbe_cmd_page_addrs_prepare(req->pages, ARRAY_SIZE(req->pages), q_mem);\r\nstatus = be_mbox_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_mcc_create *resp = embedded_payload(wrb);\r\nmccq->id = le16_to_cpu(resp->id);\r\nmccq->created = true;\r\n}\r\nmutex_unlock(&adapter->mbox_lock);\r\nreturn status;\r\n}\r\nstatic int be_cmd_mccq_org_create(struct be_adapter *adapter,\r\nstruct be_queue_info *mccq,\r\nstruct be_queue_info *cq)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_mcc_create *req;\r\nstruct be_dma_mem *q_mem = &mccq->dma_mem;\r\nvoid *ctxt;\r\nint status;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nwrb = wrb_from_mbox(adapter);\r\nreq = embedded_payload(wrb);\r\nctxt = &req->context;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_MCC_CREATE, sizeof(*req), wrb,\r\nNULL);\r\nreq->num_pages = cpu_to_le16(PAGES_4K_SPANNED(q_mem->va, q_mem->size));\r\nAMAP_SET_BITS(struct amap_mcc_context_be, valid, ctxt, 1);\r\nAMAP_SET_BITS(struct amap_mcc_context_be, ring_size, ctxt,\r\nbe_encoded_q_len(mccq->len));\r\nAMAP_SET_BITS(struct amap_mcc_context_be, cq_id, ctxt, cq->id);\r\nbe_dws_cpu_to_le(ctxt, sizeof(req->context));\r\nbe_cmd_page_addrs_prepare(req->pages, ARRAY_SIZE(req->pages), q_mem);\r\nstatus = be_mbox_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_mcc_create *resp = embedded_payload(wrb);\r\nmccq->id = le16_to_cpu(resp->id);\r\nmccq->created = true;\r\n}\r\nmutex_unlock(&adapter->mbox_lock);\r\nreturn status;\r\n}\r\nint be_cmd_mccq_create(struct be_adapter *adapter,\r\nstruct be_queue_info *mccq, struct be_queue_info *cq)\r\n{\r\nint status;\r\nstatus = be_cmd_mccq_ext_create(adapter, mccq, cq);\r\nif (status && BEx_chip(adapter)) {\r\ndev_warn(&adapter->pdev->dev, "Upgrade to F/W ver 2.102.235.0 "\r\n"or newer to avoid conflicting priorities between NIC "\r\n"and FCoE traffic");\r\nstatus = be_cmd_mccq_org_create(adapter, mccq, cq);\r\n}\r\nreturn status;\r\n}\r\nint be_cmd_txq_create(struct be_adapter *adapter, struct be_tx_obj *txo)\r\n{\r\nstruct be_mcc_wrb wrb = {0};\r\nstruct be_cmd_req_eth_tx_create *req;\r\nstruct be_queue_info *txq = &txo->q;\r\nstruct be_queue_info *cq = &txo->cq;\r\nstruct be_dma_mem *q_mem = &txq->dma_mem;\r\nint status, ver = 0;\r\nreq = embedded_payload(&wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ETH,\r\nOPCODE_ETH_TX_CREATE, sizeof(*req), &wrb, NULL);\r\nif (lancer_chip(adapter)) {\r\nreq->hdr.version = 1;\r\n} else if (BEx_chip(adapter)) {\r\nif (adapter->function_caps & BE_FUNCTION_CAPS_SUPER_NIC)\r\nreq->hdr.version = 2;\r\n} else {\r\nreq->hdr.version = 2;\r\n}\r\nif (req->hdr.version > 0)\r\nreq->if_id = cpu_to_le16(adapter->if_handle);\r\nreq->num_pages = PAGES_4K_SPANNED(q_mem->va, q_mem->size);\r\nreq->ulp_num = BE_ULP1_NUM;\r\nreq->type = BE_ETH_TX_RING_TYPE_STANDARD;\r\nreq->cq_id = cpu_to_le16(cq->id);\r\nreq->queue_size = be_encoded_q_len(txq->len);\r\nbe_cmd_page_addrs_prepare(req->pages, ARRAY_SIZE(req->pages), q_mem);\r\nver = req->hdr.version;\r\nstatus = be_cmd_notify_wait(adapter, &wrb);\r\nif (!status) {\r\nstruct be_cmd_resp_eth_tx_create *resp = embedded_payload(&wrb);\r\ntxq->id = le16_to_cpu(resp->cid);\r\nif (ver == 2)\r\ntxo->db_offset = le32_to_cpu(resp->db_offset);\r\nelse\r\ntxo->db_offset = DB_TXULP1_OFFSET;\r\ntxq->created = true;\r\n}\r\nreturn status;\r\n}\r\nint be_cmd_rxq_create(struct be_adapter *adapter,\r\nstruct be_queue_info *rxq, u16 cq_id, u16 frag_size,\r\nu32 if_id, u32 rss, u8 *rss_id)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_eth_rx_create *req;\r\nstruct be_dma_mem *q_mem = &rxq->dma_mem;\r\nint status;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ETH,\r\nOPCODE_ETH_RX_CREATE, sizeof(*req), wrb, NULL);\r\nreq->cq_id = cpu_to_le16(cq_id);\r\nreq->frag_size = fls(frag_size) - 1;\r\nreq->num_pages = 2;\r\nbe_cmd_page_addrs_prepare(req->pages, ARRAY_SIZE(req->pages), q_mem);\r\nreq->interface_id = cpu_to_le32(if_id);\r\nreq->max_frame_size = cpu_to_le16(BE_MAX_JUMBO_FRAME_SIZE);\r\nreq->rss_queue = cpu_to_le32(rss);\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_eth_rx_create *resp = embedded_payload(wrb);\r\nrxq->id = le16_to_cpu(resp->id);\r\nrxq->created = true;\r\n*rss_id = resp->rss_id;\r\n}\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_q_destroy(struct be_adapter *adapter, struct be_queue_info *q,\r\nint queue_type)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_q_destroy *req;\r\nu8 subsys = 0, opcode = 0;\r\nint status;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nwrb = wrb_from_mbox(adapter);\r\nreq = embedded_payload(wrb);\r\nswitch (queue_type) {\r\ncase QTYPE_EQ:\r\nsubsys = CMD_SUBSYSTEM_COMMON;\r\nopcode = OPCODE_COMMON_EQ_DESTROY;\r\nbreak;\r\ncase QTYPE_CQ:\r\nsubsys = CMD_SUBSYSTEM_COMMON;\r\nopcode = OPCODE_COMMON_CQ_DESTROY;\r\nbreak;\r\ncase QTYPE_TXQ:\r\nsubsys = CMD_SUBSYSTEM_ETH;\r\nopcode = OPCODE_ETH_TX_DESTROY;\r\nbreak;\r\ncase QTYPE_RXQ:\r\nsubsys = CMD_SUBSYSTEM_ETH;\r\nopcode = OPCODE_ETH_RX_DESTROY;\r\nbreak;\r\ncase QTYPE_MCCQ:\r\nsubsys = CMD_SUBSYSTEM_COMMON;\r\nopcode = OPCODE_COMMON_MCC_DESTROY;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, subsys, opcode, sizeof(*req), wrb,\r\nNULL);\r\nreq->id = cpu_to_le16(q->id);\r\nstatus = be_mbox_notify_wait(adapter);\r\nq->created = false;\r\nmutex_unlock(&adapter->mbox_lock);\r\nreturn status;\r\n}\r\nint be_cmd_rxq_destroy(struct be_adapter *adapter, struct be_queue_info *q)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_q_destroy *req;\r\nint status;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ETH,\r\nOPCODE_ETH_RX_DESTROY, sizeof(*req), wrb, NULL);\r\nreq->id = cpu_to_le16(q->id);\r\nstatus = be_mcc_notify_wait(adapter);\r\nq->created = false;\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_if_create(struct be_adapter *adapter, u32 cap_flags, u32 en_flags,\r\nu32 *if_handle, u32 domain)\r\n{\r\nstruct be_mcc_wrb wrb = {0};\r\nstruct be_cmd_req_if_create *req;\r\nint status;\r\nreq = embedded_payload(&wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_NTWK_INTERFACE_CREATE,\r\nsizeof(*req), &wrb, NULL);\r\nreq->hdr.domain = domain;\r\nreq->capability_flags = cpu_to_le32(cap_flags);\r\nreq->enable_flags = cpu_to_le32(en_flags);\r\nreq->pmac_invalid = true;\r\nstatus = be_cmd_notify_wait(adapter, &wrb);\r\nif (!status) {\r\nstruct be_cmd_resp_if_create *resp = embedded_payload(&wrb);\r\n*if_handle = le32_to_cpu(resp->interface_id);\r\nif (BE3_chip(adapter) && be_virtfn(adapter))\r\nadapter->pmac_id[0] = le32_to_cpu(resp->pmac_id);\r\n}\r\nreturn status;\r\n}\r\nint be_cmd_if_destroy(struct be_adapter *adapter, int interface_id, u32 domain)\r\n{\r\nstruct be_mcc_wrb wrb = {0};\r\nstruct be_cmd_req_if_destroy *req;\r\nint status;\r\nif (interface_id == -1)\r\nreturn 0;\r\nreq = embedded_payload(&wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_NTWK_INTERFACE_DESTROY,\r\nsizeof(*req), &wrb, NULL);\r\nreq->hdr.domain = domain;\r\nreq->interface_id = cpu_to_le32(interface_id);\r\nstatus = be_cmd_notify_wait(adapter, &wrb);\r\nreturn status;\r\n}\r\nint be_cmd_get_stats(struct be_adapter *adapter, struct be_dma_mem *nonemb_cmd)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_hdr *hdr;\r\nint status = 0;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nhdr = nonemb_cmd->va;\r\nbe_wrb_cmd_hdr_prepare(hdr, CMD_SUBSYSTEM_ETH,\r\nOPCODE_ETH_GET_STATISTICS, nonemb_cmd->size, wrb,\r\nnonemb_cmd);\r\nif (BE2_chip(adapter))\r\nhdr->version = 0;\r\nif (BE3_chip(adapter) || lancer_chip(adapter))\r\nhdr->version = 1;\r\nelse\r\nhdr->version = 2;\r\nstatus = be_mcc_notify(adapter);\r\nif (status)\r\ngoto err;\r\nadapter->stats_cmd_sent = true;\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint lancer_cmd_get_pport_stats(struct be_adapter *adapter,\r\nstruct be_dma_mem *nonemb_cmd)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct lancer_cmd_req_pport_stats *req;\r\nint status = 0;\r\nif (!be_cmd_allowed(adapter, OPCODE_ETH_GET_PPORT_STATS,\r\nCMD_SUBSYSTEM_ETH))\r\nreturn -EPERM;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = nonemb_cmd->va;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ETH,\r\nOPCODE_ETH_GET_PPORT_STATS, nonemb_cmd->size,\r\nwrb, nonemb_cmd);\r\nreq->cmd_params.params.pport_num = cpu_to_le16(adapter->hba_port_num);\r\nreq->cmd_params.params.reset_stats = 0;\r\nstatus = be_mcc_notify(adapter);\r\nif (status)\r\ngoto err;\r\nadapter->stats_cmd_sent = true;\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nstatic int be_mac_to_link_speed(int mac_speed)\r\n{\r\nswitch (mac_speed) {\r\ncase PHY_LINK_SPEED_ZERO:\r\nreturn 0;\r\ncase PHY_LINK_SPEED_10MBPS:\r\nreturn 10;\r\ncase PHY_LINK_SPEED_100MBPS:\r\nreturn 100;\r\ncase PHY_LINK_SPEED_1GBPS:\r\nreturn 1000;\r\ncase PHY_LINK_SPEED_10GBPS:\r\nreturn 10000;\r\ncase PHY_LINK_SPEED_20GBPS:\r\nreturn 20000;\r\ncase PHY_LINK_SPEED_25GBPS:\r\nreturn 25000;\r\ncase PHY_LINK_SPEED_40GBPS:\r\nreturn 40000;\r\n}\r\nreturn 0;\r\n}\r\nint be_cmd_link_status_query(struct be_adapter *adapter, u16 *link_speed,\r\nu8 *link_status, u32 dom)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_link_status *req;\r\nint status;\r\nmutex_lock(&adapter->mcc_lock);\r\nif (link_status)\r\n*link_status = LINK_DOWN;\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_NTWK_LINK_STATUS_QUERY,\r\nsizeof(*req), wrb, NULL);\r\nif (!BE2_chip(adapter))\r\nreq->hdr.version = 1;\r\nreq->hdr.domain = dom;\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_link_status *resp = embedded_payload(wrb);\r\nif (link_speed) {\r\n*link_speed = resp->link_speed ?\r\nle16_to_cpu(resp->link_speed) * 10 :\r\nbe_mac_to_link_speed(resp->mac_speed);\r\nif (!resp->logical_link_status)\r\n*link_speed = 0;\r\n}\r\nif (link_status)\r\n*link_status = resp->logical_link_status;\r\n}\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_get_die_temperature(struct be_adapter *adapter)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_get_cntl_addnl_attribs *req;\r\nint status = 0;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_CNTL_ADDITIONAL_ATTRIBUTES,\r\nsizeof(*req), wrb, NULL);\r\nstatus = be_mcc_notify(adapter);\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_get_fat_dump_len(struct be_adapter *adapter, u32 *dump_size)\r\n{\r\nstruct be_mcc_wrb wrb = {0};\r\nstruct be_cmd_req_get_fat *req;\r\nint status;\r\nreq = embedded_payload(&wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_MANAGE_FAT, sizeof(*req),\r\n&wrb, NULL);\r\nreq->fat_operation = cpu_to_le32(QUERY_FAT);\r\nstatus = be_cmd_notify_wait(adapter, &wrb);\r\nif (!status) {\r\nstruct be_cmd_resp_get_fat *resp = embedded_payload(&wrb);\r\nif (dump_size && resp->log_size)\r\n*dump_size = le32_to_cpu(resp->log_size) -\r\nsizeof(u32);\r\n}\r\nreturn status;\r\n}\r\nint be_cmd_get_fat_dump(struct be_adapter *adapter, u32 buf_len, void *buf)\r\n{\r\nstruct be_dma_mem get_fat_cmd;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_get_fat *req;\r\nu32 offset = 0, total_size, buf_size,\r\nlog_offset = sizeof(u32), payload_len;\r\nint status;\r\nif (buf_len == 0)\r\nreturn 0;\r\ntotal_size = buf_len;\r\nget_fat_cmd.size = sizeof(struct be_cmd_req_get_fat) + 60*1024;\r\nget_fat_cmd.va = dma_zalloc_coherent(&adapter->pdev->dev,\r\nget_fat_cmd.size,\r\n&get_fat_cmd.dma, GFP_ATOMIC);\r\nif (!get_fat_cmd.va)\r\nreturn -ENOMEM;\r\nmutex_lock(&adapter->mcc_lock);\r\nwhile (total_size) {\r\nbuf_size = min(total_size, (u32)60*1024);\r\ntotal_size -= buf_size;\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = get_fat_cmd.va;\r\npayload_len = sizeof(struct be_cmd_req_get_fat) + buf_size;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_MANAGE_FAT, payload_len,\r\nwrb, &get_fat_cmd);\r\nreq->fat_operation = cpu_to_le32(RETRIEVE_FAT);\r\nreq->read_log_offset = cpu_to_le32(log_offset);\r\nreq->read_log_length = cpu_to_le32(buf_size);\r\nreq->data_buffer_size = cpu_to_le32(buf_size);\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_get_fat *resp = get_fat_cmd.va;\r\nmemcpy(buf + offset,\r\nresp->data_buffer,\r\nle32_to_cpu(resp->read_log_length));\r\n} else {\r\ndev_err(&adapter->pdev->dev, "FAT Table Retrieve error\n");\r\ngoto err;\r\n}\r\noffset += buf_size;\r\nlog_offset += buf_size;\r\n}\r\nerr:\r\ndma_free_coherent(&adapter->pdev->dev, get_fat_cmd.size,\r\nget_fat_cmd.va, get_fat_cmd.dma);\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_get_fw_ver(struct be_adapter *adapter)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_get_fw_version *req;\r\nint status;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_FW_VERSION, sizeof(*req), wrb,\r\nNULL);\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_get_fw_version *resp = embedded_payload(wrb);\r\nstrlcpy(adapter->fw_ver, resp->firmware_version_string,\r\nsizeof(adapter->fw_ver));\r\nstrlcpy(adapter->fw_on_flash, resp->fw_on_flash_version_string,\r\nsizeof(adapter->fw_on_flash));\r\n}\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nstatic int __be_cmd_modify_eqd(struct be_adapter *adapter,\r\nstruct be_set_eqd *set_eqd, int num)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_modify_eq_delay *req;\r\nint status = 0, i;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_MODIFY_EQ_DELAY, sizeof(*req), wrb,\r\nNULL);\r\nreq->num_eq = cpu_to_le32(num);\r\nfor (i = 0; i < num; i++) {\r\nreq->set_eqd[i].eq_id = cpu_to_le32(set_eqd[i].eq_id);\r\nreq->set_eqd[i].phase = 0;\r\nreq->set_eqd[i].delay_multiplier =\r\ncpu_to_le32(set_eqd[i].delay_multiplier);\r\n}\r\nstatus = be_mcc_notify(adapter);\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_modify_eqd(struct be_adapter *adapter, struct be_set_eqd *set_eqd,\r\nint num)\r\n{\r\nint num_eqs, i = 0;\r\nwhile (num) {\r\nnum_eqs = min(num, 8);\r\n__be_cmd_modify_eqd(adapter, &set_eqd[i], num_eqs);\r\ni += num_eqs;\r\nnum -= num_eqs;\r\n}\r\nreturn 0;\r\n}\r\nint be_cmd_vlan_config(struct be_adapter *adapter, u32 if_id, u16 *vtag_array,\r\nu32 num, u32 domain)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_vlan_config *req;\r\nint status;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_NTWK_VLAN_CONFIG, sizeof(*req),\r\nwrb, NULL);\r\nreq->hdr.domain = domain;\r\nreq->interface_id = if_id;\r\nreq->untagged = BE_IF_FLAGS_UNTAGGED & be_if_cap_flags(adapter) ? 1 : 0;\r\nreq->num_vlan = num;\r\nmemcpy(req->normal_vlan, vtag_array,\r\nreq->num_vlan * sizeof(vtag_array[0]));\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nstatic int __be_cmd_rx_filter(struct be_adapter *adapter, u32 flags, u32 value)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_dma_mem *mem = &adapter->rx_filter;\r\nstruct be_cmd_req_rx_filter *req = mem->va;\r\nint status;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nmemset(req, 0, sizeof(*req));\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_NTWK_RX_FILTER, sizeof(*req),\r\nwrb, mem);\r\nreq->if_id = cpu_to_le32(adapter->if_handle);\r\nreq->if_flags_mask = cpu_to_le32(flags);\r\nreq->if_flags = (value == ON) ? req->if_flags_mask : 0;\r\nif (flags & BE_IF_FLAGS_MULTICAST) {\r\nint i;\r\nreq->if_flags_mask |=\r\ncpu_to_le32(BE_IF_FLAGS_MCAST_PROMISCUOUS &\r\nbe_if_cap_flags(adapter));\r\nreq->mcast_num = cpu_to_le32(adapter->mc_count);\r\nfor (i = 0; i < adapter->mc_count; i++)\r\nether_addr_copy(req->mcast_mac[i].byte,\r\nadapter->mc_list[i].mac);\r\n}\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_rx_filter(struct be_adapter *adapter, u32 flags, u32 value)\r\n{\r\nstruct device *dev = &adapter->pdev->dev;\r\nif ((flags & be_if_cap_flags(adapter)) != flags) {\r\ndev_warn(dev, "Cannot set rx filter flags 0x%x\n", flags);\r\ndev_warn(dev, "Interface is capable of 0x%x flags only\n",\r\nbe_if_cap_flags(adapter));\r\n}\r\nflags &= be_if_cap_flags(adapter);\r\nif (!flags)\r\nreturn -ENOTSUPP;\r\nreturn __be_cmd_rx_filter(adapter, flags, value);\r\n}\r\nint be_cmd_set_flow_control(struct be_adapter *adapter, u32 tx_fc, u32 rx_fc)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_set_flow_control *req;\r\nint status;\r\nif (!be_cmd_allowed(adapter, OPCODE_COMMON_SET_FLOW_CONTROL,\r\nCMD_SUBSYSTEM_COMMON))\r\nreturn -EPERM;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_SET_FLOW_CONTROL, sizeof(*req),\r\nwrb, NULL);\r\nreq->hdr.version = 1;\r\nreq->tx_flow_control = cpu_to_le16((u16)tx_fc);\r\nreq->rx_flow_control = cpu_to_le16((u16)rx_fc);\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nif (base_status(status) == MCC_STATUS_FEATURE_NOT_SUPPORTED)\r\nreturn -EOPNOTSUPP;\r\nreturn status;\r\n}\r\nint be_cmd_get_flow_control(struct be_adapter *adapter, u32 *tx_fc, u32 *rx_fc)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_get_flow_control *req;\r\nint status;\r\nif (!be_cmd_allowed(adapter, OPCODE_COMMON_GET_FLOW_CONTROL,\r\nCMD_SUBSYSTEM_COMMON))\r\nreturn -EPERM;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_FLOW_CONTROL, sizeof(*req),\r\nwrb, NULL);\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_get_flow_control *resp =\r\nembedded_payload(wrb);\r\n*tx_fc = le16_to_cpu(resp->tx_flow_control);\r\n*rx_fc = le16_to_cpu(resp->rx_flow_control);\r\n}\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_query_fw_cfg(struct be_adapter *adapter)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_query_fw_cfg *req;\r\nint status;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nwrb = wrb_from_mbox(adapter);\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_QUERY_FIRMWARE_CONFIG,\r\nsizeof(*req), wrb, NULL);\r\nstatus = be_mbox_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_query_fw_cfg *resp = embedded_payload(wrb);\r\nadapter->port_num = le32_to_cpu(resp->phys_port);\r\nadapter->function_mode = le32_to_cpu(resp->function_mode);\r\nadapter->function_caps = le32_to_cpu(resp->function_caps);\r\nadapter->asic_rev = le32_to_cpu(resp->asic_revision) & 0xFF;\r\ndev_info(&adapter->pdev->dev,\r\n"FW config: function_mode=0x%x, function_caps=0x%x\n",\r\nadapter->function_mode, adapter->function_caps);\r\n}\r\nmutex_unlock(&adapter->mbox_lock);\r\nreturn status;\r\n}\r\nint be_cmd_reset_function(struct be_adapter *adapter)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_hdr *req;\r\nint status;\r\nif (lancer_chip(adapter)) {\r\niowrite32(SLI_PORT_CONTROL_IP_MASK,\r\nadapter->db + SLIPORT_CONTROL_OFFSET);\r\nstatus = lancer_wait_ready(adapter);\r\nif (status)\r\ndev_err(&adapter->pdev->dev,\r\n"Adapter in non recoverable error\n");\r\nreturn status;\r\n}\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nwrb = wrb_from_mbox(adapter);\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(req, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_FUNCTION_RESET, sizeof(*req), wrb,\r\nNULL);\r\nstatus = be_mbox_notify_wait(adapter);\r\nmutex_unlock(&adapter->mbox_lock);\r\nreturn status;\r\n}\r\nint be_cmd_rss_config(struct be_adapter *adapter, u8 *rsstable,\r\nu32 rss_hash_opts, u16 table_size, const u8 *rss_hkey)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_rss_config *req;\r\nint status;\r\nif (!(be_if_cap_flags(adapter) & BE_IF_FLAGS_RSS))\r\nreturn 0;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ETH,\r\nOPCODE_ETH_RSS_CONFIG, sizeof(*req), wrb, NULL);\r\nreq->if_id = cpu_to_le32(adapter->if_handle);\r\nreq->enable_rss = cpu_to_le16(rss_hash_opts);\r\nreq->cpu_table_size_log2 = cpu_to_le16(fls(table_size) - 1);\r\nif (!BEx_chip(adapter))\r\nreq->hdr.version = 1;\r\nmemcpy(req->cpu_table, rsstable, table_size);\r\nmemcpy(req->hash, rss_hkey, RSS_HASH_KEY_LEN);\r\nbe_dws_cpu_to_le(req->hash, sizeof(req->hash));\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_set_beacon_state(struct be_adapter *adapter, u8 port_num,\r\nu8 bcn, u8 sts, u8 state)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_enable_disable_beacon *req;\r\nint status;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_ENABLE_DISABLE_BEACON,\r\nsizeof(*req), wrb, NULL);\r\nreq->port_num = port_num;\r\nreq->beacon_state = state;\r\nreq->beacon_duration = bcn;\r\nreq->status_duration = sts;\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_get_beacon_state(struct be_adapter *adapter, u8 port_num, u32 *state)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_get_beacon_state *req;\r\nint status;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_BEACON_STATE, sizeof(*req),\r\nwrb, NULL);\r\nreq->port_num = port_num;\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_get_beacon_state *resp =\r\nembedded_payload(wrb);\r\n*state = resp->beacon_state;\r\n}\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_read_port_transceiver_data(struct be_adapter *adapter,\r\nu8 page_num, u8 *data)\r\n{\r\nstruct be_dma_mem cmd;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_port_type *req;\r\nint status;\r\nif (page_num > TR_PAGE_A2)\r\nreturn -EINVAL;\r\ncmd.size = sizeof(struct be_cmd_resp_port_type);\r\ncmd.va = dma_zalloc_coherent(&adapter->pdev->dev, cmd.size, &cmd.dma,\r\nGFP_ATOMIC);\r\nif (!cmd.va) {\r\ndev_err(&adapter->pdev->dev, "Memory allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = cmd.va;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_READ_TRANSRECV_DATA,\r\ncmd.size, wrb, &cmd);\r\nreq->port = cpu_to_le32(adapter->hba_port_num);\r\nreq->page_num = cpu_to_le32(page_num);\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_port_type *resp = cmd.va;\r\nmemcpy(data, resp->page_data, PAGE_DATA_LEN);\r\n}\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\ndma_free_coherent(&adapter->pdev->dev, cmd.size, cmd.va, cmd.dma);\r\nreturn status;\r\n}\r\nstatic int lancer_cmd_write_object(struct be_adapter *adapter,\r\nstruct be_dma_mem *cmd, u32 data_size,\r\nu32 data_offset, const char *obj_name,\r\nu32 *data_written, u8 *change_status,\r\nu8 *addn_status)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct lancer_cmd_req_write_object *req;\r\nstruct lancer_cmd_resp_write_object *resp;\r\nvoid *ctxt = NULL;\r\nint status;\r\nmutex_lock(&adapter->mcc_lock);\r\nadapter->flash_status = 0;\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err_unlock;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_WRITE_OBJECT,\r\nsizeof(struct lancer_cmd_req_write_object), wrb,\r\nNULL);\r\nctxt = &req->context;\r\nAMAP_SET_BITS(struct amap_lancer_write_obj_context,\r\nwrite_length, ctxt, data_size);\r\nif (data_size == 0)\r\nAMAP_SET_BITS(struct amap_lancer_write_obj_context,\r\neof, ctxt, 1);\r\nelse\r\nAMAP_SET_BITS(struct amap_lancer_write_obj_context,\r\neof, ctxt, 0);\r\nbe_dws_cpu_to_le(ctxt, sizeof(req->context));\r\nreq->write_offset = cpu_to_le32(data_offset);\r\nstrlcpy(req->object_name, obj_name, sizeof(req->object_name));\r\nreq->descriptor_count = cpu_to_le32(1);\r\nreq->buf_len = cpu_to_le32(data_size);\r\nreq->addr_low = cpu_to_le32((cmd->dma +\r\nsizeof(struct lancer_cmd_req_write_object))\r\n& 0xFFFFFFFF);\r\nreq->addr_high = cpu_to_le32(upper_32_bits(cmd->dma +\r\nsizeof(struct lancer_cmd_req_write_object)));\r\nstatus = be_mcc_notify(adapter);\r\nif (status)\r\ngoto err_unlock;\r\nmutex_unlock(&adapter->mcc_lock);\r\nif (!wait_for_completion_timeout(&adapter->et_cmd_compl,\r\nmsecs_to_jiffies(60000)))\r\nstatus = -ETIMEDOUT;\r\nelse\r\nstatus = adapter->flash_status;\r\nresp = embedded_payload(wrb);\r\nif (!status) {\r\n*data_written = le32_to_cpu(resp->actual_write_len);\r\n*change_status = resp->change_status;\r\n} else {\r\n*addn_status = resp->additional_status;\r\n}\r\nreturn status;\r\nerr_unlock:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_query_cable_type(struct be_adapter *adapter)\r\n{\r\nu8 page_data[PAGE_DATA_LEN];\r\nint status;\r\nstatus = be_cmd_read_port_transceiver_data(adapter, TR_PAGE_A0,\r\npage_data);\r\nif (!status) {\r\nswitch (adapter->phy.interface_type) {\r\ncase PHY_TYPE_QSFP:\r\nadapter->phy.cable_type =\r\npage_data[QSFP_PLUS_CABLE_TYPE_OFFSET];\r\nbreak;\r\ncase PHY_TYPE_SFP_PLUS_10GB:\r\nadapter->phy.cable_type =\r\npage_data[SFP_PLUS_CABLE_TYPE_OFFSET];\r\nbreak;\r\ndefault:\r\nadapter->phy.cable_type = 0;\r\nbreak;\r\n}\r\n}\r\nreturn status;\r\n}\r\nint be_cmd_query_sfp_info(struct be_adapter *adapter)\r\n{\r\nu8 page_data[PAGE_DATA_LEN];\r\nint status;\r\nstatus = be_cmd_read_port_transceiver_data(adapter, TR_PAGE_A0,\r\npage_data);\r\nif (!status) {\r\nstrlcpy(adapter->phy.vendor_name, page_data +\r\nSFP_VENDOR_NAME_OFFSET, SFP_VENDOR_NAME_LEN - 1);\r\nstrlcpy(adapter->phy.vendor_pn,\r\npage_data + SFP_VENDOR_PN_OFFSET,\r\nSFP_VENDOR_NAME_LEN - 1);\r\n}\r\nreturn status;\r\n}\r\nstatic int lancer_cmd_delete_object(struct be_adapter *adapter,\r\nconst char *obj_name)\r\n{\r\nstruct lancer_cmd_req_delete_object *req;\r\nstruct be_mcc_wrb *wrb;\r\nint status;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_DELETE_OBJECT,\r\nsizeof(*req), wrb, NULL);\r\nstrlcpy(req->object_name, obj_name, sizeof(req->object_name));\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint lancer_cmd_read_object(struct be_adapter *adapter, struct be_dma_mem *cmd,\r\nu32 data_size, u32 data_offset, const char *obj_name,\r\nu32 *data_read, u32 *eof, u8 *addn_status)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct lancer_cmd_req_read_object *req;\r\nstruct lancer_cmd_resp_read_object *resp;\r\nint status;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err_unlock;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_READ_OBJECT,\r\nsizeof(struct lancer_cmd_req_read_object), wrb,\r\nNULL);\r\nreq->desired_read_len = cpu_to_le32(data_size);\r\nreq->read_offset = cpu_to_le32(data_offset);\r\nstrcpy(req->object_name, obj_name);\r\nreq->descriptor_count = cpu_to_le32(1);\r\nreq->buf_len = cpu_to_le32(data_size);\r\nreq->addr_low = cpu_to_le32((cmd->dma & 0xFFFFFFFF));\r\nreq->addr_high = cpu_to_le32(upper_32_bits(cmd->dma));\r\nstatus = be_mcc_notify_wait(adapter);\r\nresp = embedded_payload(wrb);\r\nif (!status) {\r\n*data_read = le32_to_cpu(resp->actual_read_len);\r\n*eof = le32_to_cpu(resp->eof);\r\n} else {\r\n*addn_status = resp->additional_status;\r\n}\r\nerr_unlock:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nstatic int be_cmd_write_flashrom(struct be_adapter *adapter,\r\nstruct be_dma_mem *cmd, u32 flash_type,\r\nu32 flash_opcode, u32 img_offset, u32 buf_size)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_write_flashrom *req;\r\nint status;\r\nmutex_lock(&adapter->mcc_lock);\r\nadapter->flash_status = 0;\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err_unlock;\r\n}\r\nreq = cmd->va;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_WRITE_FLASHROM, cmd->size, wrb,\r\ncmd);\r\nreq->params.op_type = cpu_to_le32(flash_type);\r\nif (flash_type == OPTYPE_OFFSET_SPECIFIED)\r\nreq->params.offset = cpu_to_le32(img_offset);\r\nreq->params.op_code = cpu_to_le32(flash_opcode);\r\nreq->params.data_buf_size = cpu_to_le32(buf_size);\r\nstatus = be_mcc_notify(adapter);\r\nif (status)\r\ngoto err_unlock;\r\nmutex_unlock(&adapter->mcc_lock);\r\nif (!wait_for_completion_timeout(&adapter->et_cmd_compl,\r\nmsecs_to_jiffies(40000)))\r\nstatus = -ETIMEDOUT;\r\nelse\r\nstatus = adapter->flash_status;\r\nreturn status;\r\nerr_unlock:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nstatic int be_cmd_get_flash_crc(struct be_adapter *adapter, u8 *flashed_crc,\r\nu16 img_optype, u32 img_offset, u32 crc_offset)\r\n{\r\nstruct be_cmd_read_flash_crc *req;\r\nstruct be_mcc_wrb *wrb;\r\nint status;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_READ_FLASHROM, sizeof(*req),\r\nwrb, NULL);\r\nreq->params.op_type = cpu_to_le32(img_optype);\r\nif (img_optype == OPTYPE_OFFSET_SPECIFIED)\r\nreq->params.offset = cpu_to_le32(img_offset + crc_offset);\r\nelse\r\nreq->params.offset = cpu_to_le32(crc_offset);\r\nreq->params.op_code = cpu_to_le32(FLASHROM_OPER_REPORT);\r\nreq->params.data_buf_size = cpu_to_le32(0x4);\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status)\r\nmemcpy(flashed_crc, req->crc, 4);\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nstatic bool phy_flashing_required(struct be_adapter *adapter)\r\n{\r\nreturn (adapter->phy.phy_type == PHY_TYPE_TN_8022 &&\r\nadapter->phy.interface_type == PHY_TYPE_BASET_10GB);\r\n}\r\nstatic bool is_comp_in_ufi(struct be_adapter *adapter,\r\nstruct flash_section_info *fsec, int type)\r\n{\r\nint i = 0, img_type = 0;\r\nstruct flash_section_info_g2 *fsec_g2 = NULL;\r\nif (BE2_chip(adapter))\r\nfsec_g2 = (struct flash_section_info_g2 *)fsec;\r\nfor (i = 0; i < MAX_FLASH_COMP; i++) {\r\nif (fsec_g2)\r\nimg_type = le32_to_cpu(fsec_g2->fsec_entry[i].type);\r\nelse\r\nimg_type = le32_to_cpu(fsec->fsec_entry[i].type);\r\nif (img_type == type)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic struct flash_section_info *get_fsec_info(struct be_adapter *adapter,\r\nint header_size,\r\nconst struct firmware *fw)\r\n{\r\nstruct flash_section_info *fsec = NULL;\r\nconst u8 *p = fw->data;\r\np += header_size;\r\nwhile (p < (fw->data + fw->size)) {\r\nfsec = (struct flash_section_info *)p;\r\nif (!memcmp(flash_cookie, fsec->cookie, sizeof(flash_cookie)))\r\nreturn fsec;\r\np += 32;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int be_check_flash_crc(struct be_adapter *adapter, const u8 *p,\r\nu32 img_offset, u32 img_size, int hdr_size,\r\nu16 img_optype, bool *crc_match)\r\n{\r\nu32 crc_offset;\r\nint status;\r\nu8 crc[4];\r\nstatus = be_cmd_get_flash_crc(adapter, crc, img_optype, img_offset,\r\nimg_size - 4);\r\nif (status)\r\nreturn status;\r\ncrc_offset = hdr_size + img_offset + img_size - 4;\r\nif (!memcmp(crc, p + crc_offset, 4))\r\n*crc_match = true;\r\nelse\r\n*crc_match = false;\r\nreturn status;\r\n}\r\nstatic int be_flash(struct be_adapter *adapter, const u8 *img,\r\nstruct be_dma_mem *flash_cmd, int optype, int img_size,\r\nu32 img_offset)\r\n{\r\nu32 flash_op, num_bytes, total_bytes = img_size, bytes_sent = 0;\r\nstruct be_cmd_write_flashrom *req = flash_cmd->va;\r\nint status;\r\nwhile (total_bytes) {\r\nnum_bytes = min_t(u32, 32 * 1024, total_bytes);\r\ntotal_bytes -= num_bytes;\r\nif (!total_bytes) {\r\nif (optype == OPTYPE_PHY_FW)\r\nflash_op = FLASHROM_OPER_PHY_FLASH;\r\nelse\r\nflash_op = FLASHROM_OPER_FLASH;\r\n} else {\r\nif (optype == OPTYPE_PHY_FW)\r\nflash_op = FLASHROM_OPER_PHY_SAVE;\r\nelse\r\nflash_op = FLASHROM_OPER_SAVE;\r\n}\r\nmemcpy(req->data_buf, img, num_bytes);\r\nimg += num_bytes;\r\nstatus = be_cmd_write_flashrom(adapter, flash_cmd, optype,\r\nflash_op, img_offset +\r\nbytes_sent, num_bytes);\r\nif (base_status(status) == MCC_STATUS_ILLEGAL_REQUEST &&\r\noptype == OPTYPE_PHY_FW)\r\nbreak;\r\nelse if (status)\r\nreturn status;\r\nbytes_sent += num_bytes;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool be_fw_ncsi_supported(char *ver)\r\n{\r\nint v1[4] = {3, 102, 148, 0};\r\nint v2[4];\r\nint i;\r\nif (sscanf(ver, "%d.%d.%d.%d", &v2[0], &v2[1], &v2[2], &v2[3]) != 4)\r\nreturn false;\r\nfor (i = 0; i < 4; i++) {\r\nif (v1[i] < v2[i])\r\nreturn true;\r\nelse if (v1[i] > v2[i])\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int be_flash_BEx(struct be_adapter *adapter,\r\nconst struct firmware *fw,\r\nstruct be_dma_mem *flash_cmd, int num_of_images)\r\n{\r\nint img_hdrs_size = (num_of_images * sizeof(struct image_hdr));\r\nstruct device *dev = &adapter->pdev->dev;\r\nstruct flash_section_info *fsec = NULL;\r\nint status, i, filehdr_size, num_comp;\r\nconst struct flash_comp *pflashcomp;\r\nbool crc_match;\r\nconst u8 *p;\r\nstruct flash_comp gen3_flash_types[] = {\r\n{ BE3_ISCSI_PRIMARY_IMAGE_START, OPTYPE_ISCSI_ACTIVE,\r\nBE3_COMP_MAX_SIZE, IMAGE_FIRMWARE_ISCSI},\r\n{ BE3_REDBOOT_START, OPTYPE_REDBOOT,\r\nBE3_REDBOOT_COMP_MAX_SIZE, IMAGE_BOOT_CODE},\r\n{ BE3_ISCSI_BIOS_START, OPTYPE_BIOS,\r\nBE3_BIOS_COMP_MAX_SIZE, IMAGE_OPTION_ROM_ISCSI},\r\n{ BE3_PXE_BIOS_START, OPTYPE_PXE_BIOS,\r\nBE3_BIOS_COMP_MAX_SIZE, IMAGE_OPTION_ROM_PXE},\r\n{ BE3_FCOE_BIOS_START, OPTYPE_FCOE_BIOS,\r\nBE3_BIOS_COMP_MAX_SIZE, IMAGE_OPTION_ROM_FCOE},\r\n{ BE3_ISCSI_BACKUP_IMAGE_START, OPTYPE_ISCSI_BACKUP,\r\nBE3_COMP_MAX_SIZE, IMAGE_FIRMWARE_BACKUP_ISCSI},\r\n{ BE3_FCOE_PRIMARY_IMAGE_START, OPTYPE_FCOE_FW_ACTIVE,\r\nBE3_COMP_MAX_SIZE, IMAGE_FIRMWARE_FCOE},\r\n{ BE3_FCOE_BACKUP_IMAGE_START, OPTYPE_FCOE_FW_BACKUP,\r\nBE3_COMP_MAX_SIZE, IMAGE_FIRMWARE_BACKUP_FCOE},\r\n{ BE3_NCSI_START, OPTYPE_NCSI_FW,\r\nBE3_NCSI_COMP_MAX_SIZE, IMAGE_NCSI},\r\n{ BE3_PHY_FW_START, OPTYPE_PHY_FW,\r\nBE3_PHY_FW_COMP_MAX_SIZE, IMAGE_FIRMWARE_PHY}\r\n};\r\nstruct flash_comp gen2_flash_types[] = {\r\n{ BE2_ISCSI_PRIMARY_IMAGE_START, OPTYPE_ISCSI_ACTIVE,\r\nBE2_COMP_MAX_SIZE, IMAGE_FIRMWARE_ISCSI},\r\n{ BE2_REDBOOT_START, OPTYPE_REDBOOT,\r\nBE2_REDBOOT_COMP_MAX_SIZE, IMAGE_BOOT_CODE},\r\n{ BE2_ISCSI_BIOS_START, OPTYPE_BIOS,\r\nBE2_BIOS_COMP_MAX_SIZE, IMAGE_OPTION_ROM_ISCSI},\r\n{ BE2_PXE_BIOS_START, OPTYPE_PXE_BIOS,\r\nBE2_BIOS_COMP_MAX_SIZE, IMAGE_OPTION_ROM_PXE},\r\n{ BE2_FCOE_BIOS_START, OPTYPE_FCOE_BIOS,\r\nBE2_BIOS_COMP_MAX_SIZE, IMAGE_OPTION_ROM_FCOE},\r\n{ BE2_ISCSI_BACKUP_IMAGE_START, OPTYPE_ISCSI_BACKUP,\r\nBE2_COMP_MAX_SIZE, IMAGE_FIRMWARE_BACKUP_ISCSI},\r\n{ BE2_FCOE_PRIMARY_IMAGE_START, OPTYPE_FCOE_FW_ACTIVE,\r\nBE2_COMP_MAX_SIZE, IMAGE_FIRMWARE_FCOE},\r\n{ BE2_FCOE_BACKUP_IMAGE_START, OPTYPE_FCOE_FW_BACKUP,\r\nBE2_COMP_MAX_SIZE, IMAGE_FIRMWARE_BACKUP_FCOE}\r\n};\r\nif (BE3_chip(adapter)) {\r\npflashcomp = gen3_flash_types;\r\nfilehdr_size = sizeof(struct flash_file_hdr_g3);\r\nnum_comp = ARRAY_SIZE(gen3_flash_types);\r\n} else {\r\npflashcomp = gen2_flash_types;\r\nfilehdr_size = sizeof(struct flash_file_hdr_g2);\r\nnum_comp = ARRAY_SIZE(gen2_flash_types);\r\nimg_hdrs_size = 0;\r\n}\r\nfsec = get_fsec_info(adapter, filehdr_size + img_hdrs_size, fw);\r\nif (!fsec) {\r\ndev_err(dev, "Invalid Cookie. FW image may be corrupted\n");\r\nreturn -1;\r\n}\r\nfor (i = 0; i < num_comp; i++) {\r\nif (!is_comp_in_ufi(adapter, fsec, pflashcomp[i].img_type))\r\ncontinue;\r\nif ((pflashcomp[i].optype == OPTYPE_NCSI_FW) &&\r\n!be_fw_ncsi_supported(adapter->fw_ver)) {\r\ndev_info(dev, NCSI_UPDATE_LOG, adapter->fw_ver);\r\ncontinue;\r\n}\r\nif (pflashcomp[i].optype == OPTYPE_PHY_FW &&\r\n!phy_flashing_required(adapter))\r\ncontinue;\r\nif (pflashcomp[i].optype == OPTYPE_REDBOOT) {\r\nstatus = be_check_flash_crc(adapter, fw->data,\r\npflashcomp[i].offset,\r\npflashcomp[i].size,\r\nfilehdr_size +\r\nimg_hdrs_size,\r\nOPTYPE_REDBOOT, &crc_match);\r\nif (status) {\r\ndev_err(dev,\r\n"Could not get CRC for 0x%x region\n",\r\npflashcomp[i].optype);\r\ncontinue;\r\n}\r\nif (crc_match)\r\ncontinue;\r\n}\r\np = fw->data + filehdr_size + pflashcomp[i].offset +\r\nimg_hdrs_size;\r\nif (p + pflashcomp[i].size > fw->data + fw->size)\r\nreturn -1;\r\nstatus = be_flash(adapter, p, flash_cmd, pflashcomp[i].optype,\r\npflashcomp[i].size, 0);\r\nif (status) {\r\ndev_err(dev, "Flashing section type 0x%x failed\n",\r\npflashcomp[i].img_type);\r\nreturn status;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic u16 be_get_img_optype(struct flash_section_entry fsec_entry)\r\n{\r\nu32 img_type = le32_to_cpu(fsec_entry.type);\r\nu16 img_optype = le16_to_cpu(fsec_entry.optype);\r\nif (img_optype != 0xFFFF)\r\nreturn img_optype;\r\nswitch (img_type) {\r\ncase IMAGE_FIRMWARE_ISCSI:\r\nimg_optype = OPTYPE_ISCSI_ACTIVE;\r\nbreak;\r\ncase IMAGE_BOOT_CODE:\r\nimg_optype = OPTYPE_REDBOOT;\r\nbreak;\r\ncase IMAGE_OPTION_ROM_ISCSI:\r\nimg_optype = OPTYPE_BIOS;\r\nbreak;\r\ncase IMAGE_OPTION_ROM_PXE:\r\nimg_optype = OPTYPE_PXE_BIOS;\r\nbreak;\r\ncase IMAGE_OPTION_ROM_FCOE:\r\nimg_optype = OPTYPE_FCOE_BIOS;\r\nbreak;\r\ncase IMAGE_FIRMWARE_BACKUP_ISCSI:\r\nimg_optype = OPTYPE_ISCSI_BACKUP;\r\nbreak;\r\ncase IMAGE_NCSI:\r\nimg_optype = OPTYPE_NCSI_FW;\r\nbreak;\r\ncase IMAGE_FLASHISM_JUMPVECTOR:\r\nimg_optype = OPTYPE_FLASHISM_JUMPVECTOR;\r\nbreak;\r\ncase IMAGE_FIRMWARE_PHY:\r\nimg_optype = OPTYPE_SH_PHY_FW;\r\nbreak;\r\ncase IMAGE_REDBOOT_DIR:\r\nimg_optype = OPTYPE_REDBOOT_DIR;\r\nbreak;\r\ncase IMAGE_REDBOOT_CONFIG:\r\nimg_optype = OPTYPE_REDBOOT_CONFIG;\r\nbreak;\r\ncase IMAGE_UFI_DIR:\r\nimg_optype = OPTYPE_UFI_DIR;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn img_optype;\r\n}\r\nstatic int be_flash_skyhawk(struct be_adapter *adapter,\r\nconst struct firmware *fw,\r\nstruct be_dma_mem *flash_cmd, int num_of_images)\r\n{\r\nint img_hdrs_size = num_of_images * sizeof(struct image_hdr);\r\nbool crc_match, old_fw_img, flash_offset_support = true;\r\nstruct device *dev = &adapter->pdev->dev;\r\nstruct flash_section_info *fsec = NULL;\r\nu32 img_offset, img_size, img_type;\r\nu16 img_optype, flash_optype;\r\nint status, i, filehdr_size;\r\nconst u8 *p;\r\nfilehdr_size = sizeof(struct flash_file_hdr_g3);\r\nfsec = get_fsec_info(adapter, filehdr_size + img_hdrs_size, fw);\r\nif (!fsec) {\r\ndev_err(dev, "Invalid Cookie. FW image may be corrupted\n");\r\nreturn -EINVAL;\r\n}\r\nretry_flash:\r\nfor (i = 0; i < le32_to_cpu(fsec->fsec_hdr.num_images); i++) {\r\nimg_offset = le32_to_cpu(fsec->fsec_entry[i].offset);\r\nimg_size = le32_to_cpu(fsec->fsec_entry[i].pad_size);\r\nimg_type = le32_to_cpu(fsec->fsec_entry[i].type);\r\nimg_optype = be_get_img_optype(fsec->fsec_entry[i]);\r\nold_fw_img = fsec->fsec_entry[i].optype == 0xFFFF;\r\nif (img_optype == 0xFFFF)\r\ncontinue;\r\nif (flash_offset_support)\r\nflash_optype = OPTYPE_OFFSET_SPECIFIED;\r\nelse\r\nflash_optype = img_optype;\r\nif (old_fw_img)\r\ngoto flash;\r\nstatus = be_check_flash_crc(adapter, fw->data, img_offset,\r\nimg_size, filehdr_size +\r\nimg_hdrs_size, flash_optype,\r\n&crc_match);\r\nif (base_status(status) == MCC_STATUS_ILLEGAL_REQUEST ||\r\nbase_status(status) == MCC_STATUS_ILLEGAL_FIELD) {\r\nif (flash_optype == OPTYPE_OFFSET_SPECIFIED) {\r\nflash_offset_support = false;\r\ngoto retry_flash;\r\n}\r\ndev_err(dev, "Flash incomplete. Reset the server\n");\r\ndev_err(dev, "Download FW image again after reset\n");\r\nreturn -EAGAIN;\r\n} else if (status) {\r\ndev_err(dev, "Could not get CRC for 0x%x region\n",\r\nimg_optype);\r\nreturn -EFAULT;\r\n}\r\nif (crc_match)\r\ncontinue;\r\nflash:\r\np = fw->data + filehdr_size + img_offset + img_hdrs_size;\r\nif (p + img_size > fw->data + fw->size)\r\nreturn -1;\r\nstatus = be_flash(adapter, p, flash_cmd, flash_optype, img_size,\r\nimg_offset);\r\nif (base_status(status) == MCC_STATUS_ILLEGAL_FIELD &&\r\nflash_optype == OPTYPE_OFFSET_SPECIFIED) {\r\nflash_offset_support = false;\r\ngoto retry_flash;\r\n}\r\nif (old_fw_img &&\r\n(base_status(status) == MCC_STATUS_ILLEGAL_FIELD ||\r\n(img_optype == OPTYPE_UFI_DIR &&\r\nbase_status(status) == MCC_STATUS_FAILED))) {\r\ncontinue;\r\n} else if (status) {\r\ndev_err(dev, "Flashing section type 0x%x failed\n",\r\nimg_type);\r\nswitch (addl_status(status)) {\r\ncase MCC_ADDL_STATUS_MISSING_SIGNATURE:\r\ndev_err(dev,\r\n"Digital signature missing in FW\n");\r\nreturn -EINVAL;\r\ncase MCC_ADDL_STATUS_INVALID_SIGNATURE:\r\ndev_err(dev,\r\n"Invalid digital signature in FW\n");\r\nreturn -EINVAL;\r\ndefault:\r\nreturn -EFAULT;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint lancer_fw_download(struct be_adapter *adapter,\r\nconst struct firmware *fw)\r\n{\r\nstruct device *dev = &adapter->pdev->dev;\r\nstruct be_dma_mem flash_cmd;\r\nconst u8 *data_ptr = NULL;\r\nu8 *dest_image_ptr = NULL;\r\nsize_t image_size = 0;\r\nu32 chunk_size = 0;\r\nu32 data_written = 0;\r\nu32 offset = 0;\r\nint status = 0;\r\nu8 add_status = 0;\r\nu8 change_status;\r\nif (!IS_ALIGNED(fw->size, sizeof(u32))) {\r\ndev_err(dev, "FW image size should be multiple of 4\n");\r\nreturn -EINVAL;\r\n}\r\nflash_cmd.size = sizeof(struct lancer_cmd_req_write_object)\r\n+ LANCER_FW_DOWNLOAD_CHUNK;\r\nflash_cmd.va = dma_zalloc_coherent(dev, flash_cmd.size,\r\n&flash_cmd.dma, GFP_KERNEL);\r\nif (!flash_cmd.va)\r\nreturn -ENOMEM;\r\ndest_image_ptr = flash_cmd.va +\r\nsizeof(struct lancer_cmd_req_write_object);\r\nimage_size = fw->size;\r\ndata_ptr = fw->data;\r\nwhile (image_size) {\r\nchunk_size = min_t(u32, image_size, LANCER_FW_DOWNLOAD_CHUNK);\r\nmemcpy(dest_image_ptr, data_ptr, chunk_size);\r\nstatus = lancer_cmd_write_object(adapter, &flash_cmd,\r\nchunk_size, offset,\r\nLANCER_FW_DOWNLOAD_LOCATION,\r\n&data_written, &change_status,\r\n&add_status);\r\nif (status)\r\nbreak;\r\noffset += data_written;\r\ndata_ptr += data_written;\r\nimage_size -= data_written;\r\n}\r\nif (!status) {\r\nstatus = lancer_cmd_write_object(adapter, &flash_cmd,\r\n0, offset,\r\nLANCER_FW_DOWNLOAD_LOCATION,\r\n&data_written, &change_status,\r\n&add_status);\r\n}\r\ndma_free_coherent(dev, flash_cmd.size, flash_cmd.va, flash_cmd.dma);\r\nif (status) {\r\ndev_err(dev, "Firmware load error\n");\r\nreturn be_cmd_status(status);\r\n}\r\ndev_info(dev, "Firmware flashed successfully\n");\r\nif (change_status == LANCER_FW_RESET_NEEDED) {\r\ndev_info(dev, "Resetting adapter to activate new FW\n");\r\nstatus = lancer_physdev_ctrl(adapter,\r\nPHYSDEV_CONTROL_FW_RESET_MASK);\r\nif (status) {\r\ndev_err(dev, "Adapter busy, could not reset FW\n");\r\ndev_err(dev, "Reboot server to activate new FW\n");\r\n}\r\n} else if (change_status != LANCER_NO_RESET_NEEDED) {\r\ndev_info(dev, "Reboot server to activate new FW\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic bool be_check_ufi_compatibility(struct be_adapter *adapter,\r\nstruct flash_file_hdr_g3 *fhdr)\r\n{\r\nif (!fhdr) {\r\ndev_err(&adapter->pdev->dev, "Invalid FW UFI file");\r\nreturn false;\r\n}\r\nswitch (fhdr->build[0]) {\r\ncase BLD_STR_UFI_TYPE_SH:\r\nif (!skyhawk_chip(adapter))\r\nreturn false;\r\nbreak;\r\ncase BLD_STR_UFI_TYPE_BE3:\r\nif (!BE3_chip(adapter))\r\nreturn false;\r\nbreak;\r\ncase BLD_STR_UFI_TYPE_BE2:\r\nif (!BE2_chip(adapter))\r\nreturn false;\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\nif (BEx_chip(adapter) && fhdr->asic_type_rev == 0)\r\nreturn adapter->asic_rev < 0x10;\r\nelse\r\nreturn (fhdr->asic_type_rev >= adapter->asic_rev);\r\n}\r\nint be_fw_download(struct be_adapter *adapter, const struct firmware *fw)\r\n{\r\nstruct device *dev = &adapter->pdev->dev;\r\nstruct flash_file_hdr_g3 *fhdr3;\r\nstruct image_hdr *img_hdr_ptr;\r\nint status = 0, i, num_imgs;\r\nstruct be_dma_mem flash_cmd;\r\nfhdr3 = (struct flash_file_hdr_g3 *)fw->data;\r\nif (!be_check_ufi_compatibility(adapter, fhdr3)) {\r\ndev_err(dev, "Flash image is not compatible with adapter\n");\r\nreturn -EINVAL;\r\n}\r\nflash_cmd.size = sizeof(struct be_cmd_write_flashrom);\r\nflash_cmd.va = dma_zalloc_coherent(dev, flash_cmd.size, &flash_cmd.dma,\r\nGFP_KERNEL);\r\nif (!flash_cmd.va)\r\nreturn -ENOMEM;\r\nnum_imgs = le32_to_cpu(fhdr3->num_imgs);\r\nfor (i = 0; i < num_imgs; i++) {\r\nimg_hdr_ptr = (struct image_hdr *)(fw->data +\r\n(sizeof(struct flash_file_hdr_g3) +\r\ni * sizeof(struct image_hdr)));\r\nif (!BE2_chip(adapter) &&\r\nle32_to_cpu(img_hdr_ptr->imageid) != 1)\r\ncontinue;\r\nif (skyhawk_chip(adapter))\r\nstatus = be_flash_skyhawk(adapter, fw, &flash_cmd,\r\nnum_imgs);\r\nelse\r\nstatus = be_flash_BEx(adapter, fw, &flash_cmd,\r\nnum_imgs);\r\n}\r\ndma_free_coherent(dev, flash_cmd.size, flash_cmd.va, flash_cmd.dma);\r\nif (!status)\r\ndev_info(dev, "Firmware flashed successfully\n");\r\nreturn status;\r\n}\r\nint be_cmd_enable_magic_wol(struct be_adapter *adapter, u8 *mac,\r\nstruct be_dma_mem *nonemb_cmd)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_acpi_wol_magic_config *req;\r\nint status;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = nonemb_cmd->va;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ETH,\r\nOPCODE_ETH_ACPI_WOL_MAGIC_CONFIG, sizeof(*req),\r\nwrb, nonemb_cmd);\r\nmemcpy(req->magic_mac, mac, ETH_ALEN);\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_set_loopback(struct be_adapter *adapter, u8 port_num,\r\nu8 loopback_type, u8 enable)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_set_lmode *req;\r\nint status;\r\nif (!be_cmd_allowed(adapter, OPCODE_LOWLEVEL_SET_LOOPBACK_MODE,\r\nCMD_SUBSYSTEM_LOWLEVEL))\r\nreturn -EPERM;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err_unlock;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_LOWLEVEL,\r\nOPCODE_LOWLEVEL_SET_LOOPBACK_MODE, sizeof(*req),\r\nwrb, NULL);\r\nreq->src_port = port_num;\r\nreq->dest_port = port_num;\r\nreq->loopback_type = loopback_type;\r\nreq->loopback_state = enable;\r\nstatus = be_mcc_notify(adapter);\r\nif (status)\r\ngoto err_unlock;\r\nmutex_unlock(&adapter->mcc_lock);\r\nif (!wait_for_completion_timeout(&adapter->et_cmd_compl,\r\nmsecs_to_jiffies(SET_LB_MODE_TIMEOUT)))\r\nstatus = -ETIMEDOUT;\r\nreturn status;\r\nerr_unlock:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_loopback_test(struct be_adapter *adapter, u32 port_num,\r\nu32 loopback_type, u32 pkt_size, u32 num_pkts,\r\nu64 pattern)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_loopback_test *req;\r\nstruct be_cmd_resp_loopback_test *resp;\r\nint status;\r\nif (!be_cmd_allowed(adapter, OPCODE_LOWLEVEL_LOOPBACK_TEST,\r\nCMD_SUBSYSTEM_LOWLEVEL))\r\nreturn -EPERM;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_LOWLEVEL,\r\nOPCODE_LOWLEVEL_LOOPBACK_TEST, sizeof(*req), wrb,\r\nNULL);\r\nreq->hdr.timeout = cpu_to_le32(15);\r\nreq->pattern = cpu_to_le64(pattern);\r\nreq->src_port = cpu_to_le32(port_num);\r\nreq->dest_port = cpu_to_le32(port_num);\r\nreq->pkt_size = cpu_to_le32(pkt_size);\r\nreq->num_pkts = cpu_to_le32(num_pkts);\r\nreq->loopback_type = cpu_to_le32(loopback_type);\r\nstatus = be_mcc_notify(adapter);\r\nif (status)\r\ngoto err;\r\nmutex_unlock(&adapter->mcc_lock);\r\nwait_for_completion(&adapter->et_cmd_compl);\r\nresp = embedded_payload(wrb);\r\nstatus = le32_to_cpu(resp->status);\r\nreturn status;\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_ddr_dma_test(struct be_adapter *adapter, u64 pattern,\r\nu32 byte_cnt, struct be_dma_mem *cmd)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_ddrdma_test *req;\r\nint status;\r\nint i, j = 0;\r\nif (!be_cmd_allowed(adapter, OPCODE_LOWLEVEL_HOST_DDR_DMA,\r\nCMD_SUBSYSTEM_LOWLEVEL))\r\nreturn -EPERM;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = cmd->va;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_LOWLEVEL,\r\nOPCODE_LOWLEVEL_HOST_DDR_DMA, cmd->size, wrb,\r\ncmd);\r\nreq->pattern = cpu_to_le64(pattern);\r\nreq->byte_count = cpu_to_le32(byte_cnt);\r\nfor (i = 0; i < byte_cnt; i++) {\r\nreq->snd_buff[i] = (u8)(pattern >> (j*8));\r\nj++;\r\nif (j > 7)\r\nj = 0;\r\n}\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_ddrdma_test *resp;\r\nresp = cmd->va;\r\nif ((memcmp(resp->rcv_buff, req->snd_buff, byte_cnt) != 0) ||\r\nresp->snd_err) {\r\nstatus = -1;\r\n}\r\n}\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_get_seeprom_data(struct be_adapter *adapter,\r\nstruct be_dma_mem *nonemb_cmd)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_seeprom_read *req;\r\nint status;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = nonemb_cmd->va;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_SEEPROM_READ, sizeof(*req), wrb,\r\nnonemb_cmd);\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_get_phy_info(struct be_adapter *adapter)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_get_phy_info *req;\r\nstruct be_dma_mem cmd;\r\nint status;\r\nif (!be_cmd_allowed(adapter, OPCODE_COMMON_GET_PHY_DETAILS,\r\nCMD_SUBSYSTEM_COMMON))\r\nreturn -EPERM;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\ncmd.size = sizeof(struct be_cmd_req_get_phy_info);\r\ncmd.va = dma_zalloc_coherent(&adapter->pdev->dev, cmd.size, &cmd.dma,\r\nGFP_ATOMIC);\r\nif (!cmd.va) {\r\ndev_err(&adapter->pdev->dev, "Memory alloc failure\n");\r\nstatus = -ENOMEM;\r\ngoto err;\r\n}\r\nreq = cmd.va;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_PHY_DETAILS, sizeof(*req),\r\nwrb, &cmd);\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_phy_info *resp_phy_info =\r\ncmd.va + sizeof(struct be_cmd_req_hdr);\r\nadapter->phy.phy_type = le16_to_cpu(resp_phy_info->phy_type);\r\nadapter->phy.interface_type =\r\nle16_to_cpu(resp_phy_info->interface_type);\r\nadapter->phy.auto_speeds_supported =\r\nle16_to_cpu(resp_phy_info->auto_speeds_supported);\r\nadapter->phy.fixed_speeds_supported =\r\nle16_to_cpu(resp_phy_info->fixed_speeds_supported);\r\nadapter->phy.misc_params =\r\nle32_to_cpu(resp_phy_info->misc_params);\r\nif (BE2_chip(adapter)) {\r\nadapter->phy.fixed_speeds_supported =\r\nBE_SUPPORTED_SPEED_10GBPS |\r\nBE_SUPPORTED_SPEED_1GBPS;\r\n}\r\n}\r\ndma_free_coherent(&adapter->pdev->dev, cmd.size, cmd.va, cmd.dma);\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nstatic int be_cmd_set_qos(struct be_adapter *adapter, u32 bps, u32 domain)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_set_qos *req;\r\nint status;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_SET_QOS, sizeof(*req), wrb, NULL);\r\nreq->hdr.domain = domain;\r\nreq->valid_bits = cpu_to_le32(BE_QOS_BITS_NIC);\r\nreq->max_bps_nic = cpu_to_le32(bps);\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_get_cntl_attributes(struct be_adapter *adapter)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_cntl_attribs *req;\r\nstruct be_cmd_resp_cntl_attribs *resp;\r\nint status, i;\r\nint payload_len = max(sizeof(*req), sizeof(*resp));\r\nstruct mgmt_controller_attrib *attribs;\r\nstruct be_dma_mem attribs_cmd;\r\nu32 *serial_num;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nmemset(&attribs_cmd, 0, sizeof(struct be_dma_mem));\r\nattribs_cmd.size = sizeof(struct be_cmd_resp_cntl_attribs);\r\nattribs_cmd.va = dma_zalloc_coherent(&adapter->pdev->dev,\r\nattribs_cmd.size,\r\n&attribs_cmd.dma, GFP_ATOMIC);\r\nif (!attribs_cmd.va) {\r\ndev_err(&adapter->pdev->dev, "Memory allocation failure\n");\r\nstatus = -ENOMEM;\r\ngoto err;\r\n}\r\nwrb = wrb_from_mbox(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = attribs_cmd.va;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_CNTL_ATTRIBUTES, payload_len,\r\nwrb, &attribs_cmd);\r\nstatus = be_mbox_notify_wait(adapter);\r\nif (!status) {\r\nattribs = attribs_cmd.va + sizeof(struct be_cmd_resp_hdr);\r\nadapter->hba_port_num = attribs->hba_attribs.phy_port;\r\nserial_num = attribs->hba_attribs.controller_serial_number;\r\nfor (i = 0; i < CNTL_SERIAL_NUM_WORDS; i++)\r\nadapter->serial_num[i] = le32_to_cpu(serial_num[i]) &\r\n(BIT_MASK(16) - 1);\r\nif (BEx_chip(adapter))\r\nadapter->pf_num = attribs->hba_attribs.pci_funcnum;\r\n}\r\nerr:\r\nmutex_unlock(&adapter->mbox_lock);\r\nif (attribs_cmd.va)\r\ndma_free_coherent(&adapter->pdev->dev, attribs_cmd.size,\r\nattribs_cmd.va, attribs_cmd.dma);\r\nreturn status;\r\n}\r\nint be_cmd_req_native_mode(struct be_adapter *adapter)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_set_func_cap *req;\r\nint status;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nwrb = wrb_from_mbox(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_SET_DRIVER_FUNCTION_CAP,\r\nsizeof(*req), wrb, NULL);\r\nreq->valid_cap_flags = cpu_to_le32(CAPABILITY_SW_TIMESTAMPS |\r\nCAPABILITY_BE3_NATIVE_ERX_API);\r\nreq->cap_flags = cpu_to_le32(CAPABILITY_BE3_NATIVE_ERX_API);\r\nstatus = be_mbox_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_set_func_cap *resp = embedded_payload(wrb);\r\nadapter->be3_native = le32_to_cpu(resp->cap_flags) &\r\nCAPABILITY_BE3_NATIVE_ERX_API;\r\nif (!adapter->be3_native)\r\ndev_warn(&adapter->pdev->dev,\r\n"adapter not in advanced mode\n");\r\n}\r\nerr:\r\nmutex_unlock(&adapter->mbox_lock);\r\nreturn status;\r\n}\r\nint be_cmd_get_fn_privileges(struct be_adapter *adapter, u32 *privilege,\r\nu32 domain)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_get_fn_privileges *req;\r\nint status;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_FN_PRIVILEGES, sizeof(*req),\r\nwrb, NULL);\r\nreq->hdr.domain = domain;\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_get_fn_privileges *resp =\r\nembedded_payload(wrb);\r\n*privilege = le32_to_cpu(resp->privilege_mask);\r\nif (BEx_chip(adapter) && be_is_mc(adapter) &&\r\nbe_physfn(adapter))\r\n*privilege = MAX_PRIVILEGES;\r\n}\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_set_fn_privileges(struct be_adapter *adapter, u32 privileges,\r\nu32 domain)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_set_fn_privileges *req;\r\nint status;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_SET_FN_PRIVILEGES, sizeof(*req),\r\nwrb, NULL);\r\nreq->hdr.domain = domain;\r\nif (lancer_chip(adapter))\r\nreq->privileges_lancer = cpu_to_le32(privileges);\r\nelse\r\nreq->privileges = cpu_to_le32(privileges);\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_get_mac_from_list(struct be_adapter *adapter, u8 *mac,\r\nbool *pmac_id_valid, u32 *pmac_id, u32 if_handle,\r\nu8 domain)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_get_mac_list *req;\r\nint status;\r\nint mac_count;\r\nstruct be_dma_mem get_mac_list_cmd;\r\nint i;\r\nmemset(&get_mac_list_cmd, 0, sizeof(struct be_dma_mem));\r\nget_mac_list_cmd.size = sizeof(struct be_cmd_resp_get_mac_list);\r\nget_mac_list_cmd.va = dma_zalloc_coherent(&adapter->pdev->dev,\r\nget_mac_list_cmd.size,\r\n&get_mac_list_cmd.dma,\r\nGFP_ATOMIC);\r\nif (!get_mac_list_cmd.va) {\r\ndev_err(&adapter->pdev->dev,\r\n"Memory allocation failure during GET_MAC_LIST\n");\r\nreturn -ENOMEM;\r\n}\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto out;\r\n}\r\nreq = get_mac_list_cmd.va;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_MAC_LIST,\r\nget_mac_list_cmd.size, wrb, &get_mac_list_cmd);\r\nreq->hdr.domain = domain;\r\nreq->mac_type = MAC_ADDRESS_TYPE_NETWORK;\r\nif (*pmac_id_valid) {\r\nreq->mac_id = cpu_to_le32(*pmac_id);\r\nreq->iface_id = cpu_to_le16(if_handle);\r\nreq->perm_override = 0;\r\n} else {\r\nreq->perm_override = 1;\r\n}\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_get_mac_list *resp =\r\nget_mac_list_cmd.va;\r\nif (*pmac_id_valid) {\r\nmemcpy(mac, resp->macid_macaddr.mac_addr_id.macaddr,\r\nETH_ALEN);\r\ngoto out;\r\n}\r\nmac_count = resp->true_mac_count + resp->pseudo_mac_count;\r\nfor (i = 0; i < mac_count; i++) {\r\nstruct get_list_macaddr *mac_entry;\r\nu16 mac_addr_size;\r\nu32 mac_id;\r\nmac_entry = &resp->macaddr_list[i];\r\nmac_addr_size = le16_to_cpu(mac_entry->mac_addr_size);\r\nif (mac_addr_size == sizeof(u32)) {\r\n*pmac_id_valid = true;\r\nmac_id = mac_entry->mac_addr_id.s_mac_id.mac_id;\r\n*pmac_id = le32_to_cpu(mac_id);\r\ngoto out;\r\n}\r\n}\r\n*pmac_id_valid = false;\r\nmemcpy(mac, resp->macaddr_list[0].mac_addr_id.macaddr,\r\nETH_ALEN);\r\n}\r\nout:\r\nmutex_unlock(&adapter->mcc_lock);\r\ndma_free_coherent(&adapter->pdev->dev, get_mac_list_cmd.size,\r\nget_mac_list_cmd.va, get_mac_list_cmd.dma);\r\nreturn status;\r\n}\r\nint be_cmd_get_active_mac(struct be_adapter *adapter, u32 curr_pmac_id,\r\nu8 *mac, u32 if_handle, bool active, u32 domain)\r\n{\r\nif (!active)\r\nbe_cmd_get_mac_from_list(adapter, mac, &active, &curr_pmac_id,\r\nif_handle, domain);\r\nif (BEx_chip(adapter))\r\nreturn be_cmd_mac_addr_query(adapter, mac, false,\r\nif_handle, curr_pmac_id);\r\nelse\r\nreturn be_cmd_get_mac_from_list(adapter, mac, &active,\r\n&curr_pmac_id,\r\nif_handle, domain);\r\n}\r\nint be_cmd_get_perm_mac(struct be_adapter *adapter, u8 *mac)\r\n{\r\nint status;\r\nbool pmac_valid = false;\r\neth_zero_addr(mac);\r\nif (BEx_chip(adapter)) {\r\nif (be_physfn(adapter))\r\nstatus = be_cmd_mac_addr_query(adapter, mac, true, 0,\r\n0);\r\nelse\r\nstatus = be_cmd_mac_addr_query(adapter, mac, false,\r\nadapter->if_handle, 0);\r\n} else {\r\nstatus = be_cmd_get_mac_from_list(adapter, mac, &pmac_valid,\r\nNULL, adapter->if_handle, 0);\r\n}\r\nreturn status;\r\n}\r\nint be_cmd_set_mac_list(struct be_adapter *adapter, u8 *mac_array,\r\nu8 mac_count, u32 domain)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_set_mac_list *req;\r\nint status;\r\nstruct be_dma_mem cmd;\r\nmemset(&cmd, 0, sizeof(struct be_dma_mem));\r\ncmd.size = sizeof(struct be_cmd_req_set_mac_list);\r\ncmd.va = dma_zalloc_coherent(&adapter->pdev->dev, cmd.size, &cmd.dma,\r\nGFP_KERNEL);\r\nif (!cmd.va)\r\nreturn -ENOMEM;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = cmd.va;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_SET_MAC_LIST, sizeof(*req),\r\nwrb, &cmd);\r\nreq->hdr.domain = domain;\r\nreq->mac_count = mac_count;\r\nif (mac_count)\r\nmemcpy(req->mac, mac_array, ETH_ALEN*mac_count);\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\ndma_free_coherent(&adapter->pdev->dev, cmd.size, cmd.va, cmd.dma);\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_set_mac(struct be_adapter *adapter, u8 *mac, int if_id, u32 dom)\r\n{\r\nbool active_mac = false;\r\nu8 old_mac[ETH_ALEN];\r\nu32 pmac_id;\r\nint status;\r\nstatus = be_cmd_get_mac_from_list(adapter, old_mac, &active_mac,\r\n&pmac_id, if_id, dom);\r\nif (!status && active_mac)\r\nbe_cmd_pmac_del(adapter, if_id, pmac_id, dom);\r\nreturn be_cmd_set_mac_list(adapter, mac, mac ? 1 : 0, dom);\r\n}\r\nint be_cmd_set_hsw_config(struct be_adapter *adapter, u16 pvid,\r\nu32 domain, u16 intf_id, u16 hsw_mode, u8 spoofchk)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_set_hsw_config *req;\r\nvoid *ctxt;\r\nint status;\r\nif (!be_cmd_allowed(adapter, OPCODE_COMMON_SET_HSW_CONFIG,\r\nCMD_SUBSYSTEM_COMMON))\r\nreturn -EPERM;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nctxt = &req->context;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_SET_HSW_CONFIG, sizeof(*req), wrb,\r\nNULL);\r\nreq->hdr.domain = domain;\r\nAMAP_SET_BITS(struct amap_set_hsw_context, interface_id, ctxt, intf_id);\r\nif (pvid) {\r\nAMAP_SET_BITS(struct amap_set_hsw_context, pvid_valid, ctxt, 1);\r\nAMAP_SET_BITS(struct amap_set_hsw_context, pvid, ctxt, pvid);\r\n}\r\nif (hsw_mode) {\r\nAMAP_SET_BITS(struct amap_set_hsw_context, interface_id,\r\nctxt, adapter->hba_port_num);\r\nAMAP_SET_BITS(struct amap_set_hsw_context, pport, ctxt, 1);\r\nAMAP_SET_BITS(struct amap_set_hsw_context, port_fwd_type,\r\nctxt, hsw_mode);\r\n}\r\nif (!BEx_chip(adapter) && spoofchk) {\r\nAMAP_SET_BITS(struct amap_set_hsw_context, mac_spoofchk,\r\nctxt, spoofchk);\r\nAMAP_SET_BITS(struct amap_set_hsw_context, vlan_spoofchk,\r\nctxt, spoofchk);\r\n}\r\nbe_dws_cpu_to_le(req->context, sizeof(req->context));\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_get_hsw_config(struct be_adapter *adapter, u16 *pvid,\r\nu32 domain, u16 intf_id, u8 *mode, bool *spoofchk)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_get_hsw_config *req;\r\nvoid *ctxt;\r\nint status;\r\nu16 vid;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nctxt = &req->context;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_HSW_CONFIG, sizeof(*req), wrb,\r\nNULL);\r\nreq->hdr.domain = domain;\r\nAMAP_SET_BITS(struct amap_get_hsw_req_context, interface_id,\r\nctxt, intf_id);\r\nAMAP_SET_BITS(struct amap_get_hsw_req_context, pvid_valid, ctxt, 1);\r\nif (!BEx_chip(adapter) && mode) {\r\nAMAP_SET_BITS(struct amap_get_hsw_req_context, interface_id,\r\nctxt, adapter->hba_port_num);\r\nAMAP_SET_BITS(struct amap_get_hsw_req_context, pport, ctxt, 1);\r\n}\r\nbe_dws_cpu_to_le(req->context, sizeof(req->context));\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_get_hsw_config *resp =\r\nembedded_payload(wrb);\r\nbe_dws_le_to_cpu(&resp->context, sizeof(resp->context));\r\nvid = AMAP_GET_BITS(struct amap_get_hsw_resp_context,\r\npvid, &resp->context);\r\nif (pvid)\r\n*pvid = le16_to_cpu(vid);\r\nif (mode)\r\n*mode = AMAP_GET_BITS(struct amap_get_hsw_resp_context,\r\nport_fwd_type, &resp->context);\r\nif (spoofchk)\r\n*spoofchk =\r\nAMAP_GET_BITS(struct amap_get_hsw_resp_context,\r\nspoofchk, &resp->context);\r\n}\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nstatic bool be_is_wol_excluded(struct be_adapter *adapter)\r\n{\r\nstruct pci_dev *pdev = adapter->pdev;\r\nif (be_virtfn(adapter))\r\nreturn true;\r\nswitch (pdev->subsystem_device) {\r\ncase OC_SUBSYS_DEVICE_ID1:\r\ncase OC_SUBSYS_DEVICE_ID2:\r\ncase OC_SUBSYS_DEVICE_ID3:\r\ncase OC_SUBSYS_DEVICE_ID4:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nint be_cmd_get_acpi_wol_cap(struct be_adapter *adapter)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_acpi_wol_magic_config_v1 *req;\r\nint status = 0;\r\nstruct be_dma_mem cmd;\r\nif (!be_cmd_allowed(adapter, OPCODE_ETH_ACPI_WOL_MAGIC_CONFIG,\r\nCMD_SUBSYSTEM_ETH))\r\nreturn -EPERM;\r\nif (be_is_wol_excluded(adapter))\r\nreturn status;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nmemset(&cmd, 0, sizeof(struct be_dma_mem));\r\ncmd.size = sizeof(struct be_cmd_resp_acpi_wol_magic_config_v1);\r\ncmd.va = dma_zalloc_coherent(&adapter->pdev->dev, cmd.size, &cmd.dma,\r\nGFP_ATOMIC);\r\nif (!cmd.va) {\r\ndev_err(&adapter->pdev->dev, "Memory allocation failure\n");\r\nstatus = -ENOMEM;\r\ngoto err;\r\n}\r\nwrb = wrb_from_mbox(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = cmd.va;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ETH,\r\nOPCODE_ETH_ACPI_WOL_MAGIC_CONFIG,\r\nsizeof(*req), wrb, &cmd);\r\nreq->hdr.version = 1;\r\nreq->query_options = BE_GET_WOL_CAP;\r\nstatus = be_mbox_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_acpi_wol_magic_config_v1 *resp;\r\nresp = (struct be_cmd_resp_acpi_wol_magic_config_v1 *)cmd.va;\r\nadapter->wol_cap = resp->wol_settings;\r\nif (adapter->wol_cap & BE_WOL_CAP &&\r\n!is_zero_ether_addr(resp->magic_mac))\r\nadapter->wol_en = true;\r\n}\r\nerr:\r\nmutex_unlock(&adapter->mbox_lock);\r\nif (cmd.va)\r\ndma_free_coherent(&adapter->pdev->dev, cmd.size, cmd.va,\r\ncmd.dma);\r\nreturn status;\r\n}\r\nint be_cmd_set_fw_log_level(struct be_adapter *adapter, u32 level)\r\n{\r\nstruct be_dma_mem extfat_cmd;\r\nstruct be_fat_conf_params *cfgs;\r\nint status;\r\nint i, j;\r\nmemset(&extfat_cmd, 0, sizeof(struct be_dma_mem));\r\nextfat_cmd.size = sizeof(struct be_cmd_resp_get_ext_fat_caps);\r\nextfat_cmd.va = dma_zalloc_coherent(&adapter->pdev->dev,\r\nextfat_cmd.size, &extfat_cmd.dma,\r\nGFP_ATOMIC);\r\nif (!extfat_cmd.va)\r\nreturn -ENOMEM;\r\nstatus = be_cmd_get_ext_fat_capabilites(adapter, &extfat_cmd);\r\nif (status)\r\ngoto err;\r\ncfgs = (struct be_fat_conf_params *)\r\n(extfat_cmd.va + sizeof(struct be_cmd_resp_hdr));\r\nfor (i = 0; i < le32_to_cpu(cfgs->num_modules); i++) {\r\nu32 num_modes = le32_to_cpu(cfgs->module[i].num_modes);\r\nfor (j = 0; j < num_modes; j++) {\r\nif (cfgs->module[i].trace_lvl[j].mode == MODE_UART)\r\ncfgs->module[i].trace_lvl[j].dbg_lvl =\r\ncpu_to_le32(level);\r\n}\r\n}\r\nstatus = be_cmd_set_ext_fat_capabilites(adapter, &extfat_cmd, cfgs);\r\nerr:\r\ndma_free_coherent(&adapter->pdev->dev, extfat_cmd.size, extfat_cmd.va,\r\nextfat_cmd.dma);\r\nreturn status;\r\n}\r\nint be_cmd_get_fw_log_level(struct be_adapter *adapter)\r\n{\r\nstruct be_dma_mem extfat_cmd;\r\nstruct be_fat_conf_params *cfgs;\r\nint status, j;\r\nint level = 0;\r\nmemset(&extfat_cmd, 0, sizeof(struct be_dma_mem));\r\nextfat_cmd.size = sizeof(struct be_cmd_resp_get_ext_fat_caps);\r\nextfat_cmd.va = dma_zalloc_coherent(&adapter->pdev->dev,\r\nextfat_cmd.size, &extfat_cmd.dma,\r\nGFP_ATOMIC);\r\nif (!extfat_cmd.va) {\r\ndev_err(&adapter->pdev->dev, "%s: Memory allocation failure\n",\r\n__func__);\r\ngoto err;\r\n}\r\nstatus = be_cmd_get_ext_fat_capabilites(adapter, &extfat_cmd);\r\nif (!status) {\r\ncfgs = (struct be_fat_conf_params *)(extfat_cmd.va +\r\nsizeof(struct be_cmd_resp_hdr));\r\nfor (j = 0; j < le32_to_cpu(cfgs->module[0].num_modes); j++) {\r\nif (cfgs->module[0].trace_lvl[j].mode == MODE_UART)\r\nlevel = cfgs->module[0].trace_lvl[j].dbg_lvl;\r\n}\r\n}\r\ndma_free_coherent(&adapter->pdev->dev, extfat_cmd.size, extfat_cmd.va,\r\nextfat_cmd.dma);\r\nerr:\r\nreturn level;\r\n}\r\nint be_cmd_get_ext_fat_capabilites(struct be_adapter *adapter,\r\nstruct be_dma_mem *cmd)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_get_ext_fat_caps *req;\r\nint status;\r\nif (!be_cmd_allowed(adapter, OPCODE_COMMON_GET_EXT_FAT_CAPABILITIES,\r\nCMD_SUBSYSTEM_COMMON))\r\nreturn -EPERM;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nwrb = wrb_from_mbox(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = cmd->va;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_EXT_FAT_CAPABILITIES,\r\ncmd->size, wrb, cmd);\r\nreq->parameter_type = cpu_to_le32(1);\r\nstatus = be_mbox_notify_wait(adapter);\r\nerr:\r\nmutex_unlock(&adapter->mbox_lock);\r\nreturn status;\r\n}\r\nint be_cmd_set_ext_fat_capabilites(struct be_adapter *adapter,\r\nstruct be_dma_mem *cmd,\r\nstruct be_fat_conf_params *configs)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_set_ext_fat_caps *req;\r\nint status;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = cmd->va;\r\nmemcpy(&req->set_params, configs, sizeof(struct be_fat_conf_params));\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_SET_EXT_FAT_CAPABILITIES,\r\ncmd->size, wrb, cmd);\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_query_port_name(struct be_adapter *adapter)\r\n{\r\nstruct be_cmd_req_get_port_name *req;\r\nstruct be_mcc_wrb *wrb;\r\nint status;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nwrb = wrb_from_mbox(adapter);\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_PORT_NAME, sizeof(*req), wrb,\r\nNULL);\r\nif (!BEx_chip(adapter))\r\nreq->hdr.version = 1;\r\nstatus = be_mbox_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_get_port_name *resp = embedded_payload(wrb);\r\nadapter->port_name = resp->port_name[adapter->hba_port_num];\r\n} else {\r\nadapter->port_name = adapter->hba_port_num + '0';\r\n}\r\nmutex_unlock(&adapter->mbox_lock);\r\nreturn status;\r\n}\r\nstatic struct be_nic_res_desc *be_get_nic_desc(u8 *buf, u32 desc_count,\r\nbool get_vft, u8 pf_num)\r\n{\r\nstruct be_res_desc_hdr *hdr = (struct be_res_desc_hdr *)buf;\r\nstruct be_nic_res_desc *nic;\r\nint i;\r\nfor (i = 0; i < desc_count; i++) {\r\nif (hdr->desc_type == NIC_RESOURCE_DESC_TYPE_V0 ||\r\nhdr->desc_type == NIC_RESOURCE_DESC_TYPE_V1) {\r\nnic = (struct be_nic_res_desc *)hdr;\r\nif ((pf_num == PF_NUM_IGNORE ||\r\nnic->pf_num == pf_num) &&\r\n(!get_vft || nic->flags & BIT(VFT_SHIFT)))\r\nreturn nic;\r\n}\r\nhdr->desc_len = hdr->desc_len ? : RESOURCE_DESC_SIZE_V0;\r\nhdr = (void *)hdr + hdr->desc_len;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct be_nic_res_desc *be_get_vft_desc(u8 *buf, u32 desc_count,\r\nu8 pf_num)\r\n{\r\nreturn be_get_nic_desc(buf, desc_count, true, pf_num);\r\n}\r\nstatic struct be_nic_res_desc *be_get_func_nic_desc(u8 *buf, u32 desc_count,\r\nu8 pf_num)\r\n{\r\nreturn be_get_nic_desc(buf, desc_count, false, pf_num);\r\n}\r\nstatic struct be_pcie_res_desc *be_get_pcie_desc(u8 *buf, u32 desc_count,\r\nu8 pf_num)\r\n{\r\nstruct be_res_desc_hdr *hdr = (struct be_res_desc_hdr *)buf;\r\nstruct be_pcie_res_desc *pcie;\r\nint i;\r\nfor (i = 0; i < desc_count; i++) {\r\nif (hdr->desc_type == PCIE_RESOURCE_DESC_TYPE_V0 ||\r\nhdr->desc_type == PCIE_RESOURCE_DESC_TYPE_V1) {\r\npcie = (struct be_pcie_res_desc *)hdr;\r\nif (pcie->pf_num == pf_num)\r\nreturn pcie;\r\n}\r\nhdr->desc_len = hdr->desc_len ? : RESOURCE_DESC_SIZE_V0;\r\nhdr = (void *)hdr + hdr->desc_len;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct be_port_res_desc *be_get_port_desc(u8 *buf, u32 desc_count)\r\n{\r\nstruct be_res_desc_hdr *hdr = (struct be_res_desc_hdr *)buf;\r\nint i;\r\nfor (i = 0; i < desc_count; i++) {\r\nif (hdr->desc_type == PORT_RESOURCE_DESC_TYPE_V1)\r\nreturn (struct be_port_res_desc *)hdr;\r\nhdr->desc_len = hdr->desc_len ? : RESOURCE_DESC_SIZE_V0;\r\nhdr = (void *)hdr + hdr->desc_len;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void be_copy_nic_desc(struct be_resources *res,\r\nstruct be_nic_res_desc *desc)\r\n{\r\nres->max_uc_mac = le16_to_cpu(desc->unicast_mac_count);\r\nres->max_vlans = le16_to_cpu(desc->vlan_count);\r\nres->max_mcast_mac = le16_to_cpu(desc->mcast_mac_count);\r\nres->max_tx_qs = le16_to_cpu(desc->txq_count);\r\nres->max_rss_qs = le16_to_cpu(desc->rssq_count);\r\nres->max_rx_qs = le16_to_cpu(desc->rq_count);\r\nres->max_evt_qs = le16_to_cpu(desc->eq_count);\r\nres->max_cq_count = le16_to_cpu(desc->cq_count);\r\nres->max_iface_count = le16_to_cpu(desc->iface_count);\r\nres->max_mcc_count = le16_to_cpu(desc->mcc_count);\r\nres->if_cap_flags = le32_to_cpu(desc->cap_flags) &\r\nBE_IF_CAP_FLAGS_WANT;\r\n}\r\nint be_cmd_get_func_config(struct be_adapter *adapter, struct be_resources *res)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_get_func_config *req;\r\nint status;\r\nstruct be_dma_mem cmd;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nmemset(&cmd, 0, sizeof(struct be_dma_mem));\r\ncmd.size = sizeof(struct be_cmd_resp_get_func_config);\r\ncmd.va = dma_zalloc_coherent(&adapter->pdev->dev, cmd.size, &cmd.dma,\r\nGFP_ATOMIC);\r\nif (!cmd.va) {\r\ndev_err(&adapter->pdev->dev, "Memory alloc failure\n");\r\nstatus = -ENOMEM;\r\ngoto err;\r\n}\r\nwrb = wrb_from_mbox(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = cmd.va;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_FUNC_CONFIG,\r\ncmd.size, wrb, &cmd);\r\nif (skyhawk_chip(adapter))\r\nreq->hdr.version = 1;\r\nstatus = be_mbox_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_get_func_config *resp = cmd.va;\r\nu32 desc_count = le32_to_cpu(resp->desc_count);\r\nstruct be_nic_res_desc *desc;\r\ndesc = be_get_func_nic_desc(resp->func_param, desc_count,\r\nPF_NUM_IGNORE);\r\nif (!desc) {\r\nstatus = -EINVAL;\r\ngoto err;\r\n}\r\nadapter->pf_num = desc->pf_num;\r\nadapter->vf_num = desc->vf_num;\r\nif (res)\r\nbe_copy_nic_desc(res, desc);\r\n}\r\nerr:\r\nmutex_unlock(&adapter->mbox_lock);\r\nif (cmd.va)\r\ndma_free_coherent(&adapter->pdev->dev, cmd.size, cmd.va,\r\ncmd.dma);\r\nreturn status;\r\n}\r\nstatic u16 be_get_nic_pf_num_list(u8 *buf, u32 desc_count, u16 *nic_pf_nums)\r\n{\r\nstruct be_res_desc_hdr *hdr = (struct be_res_desc_hdr *)buf;\r\nstruct be_pcie_res_desc *pcie = NULL;\r\nint i;\r\nu16 nic_pf_count = 0;\r\nfor (i = 0; i < desc_count; i++) {\r\nif (hdr->desc_type == PCIE_RESOURCE_DESC_TYPE_V0 ||\r\nhdr->desc_type == PCIE_RESOURCE_DESC_TYPE_V1) {\r\npcie = (struct be_pcie_res_desc *)hdr;\r\nif (pcie->pf_state && (pcie->pf_type == MISSION_NIC ||\r\npcie->pf_type == MISSION_RDMA)) {\r\nnic_pf_nums[nic_pf_count++] = pcie->pf_num;\r\n}\r\n}\r\nhdr->desc_len = hdr->desc_len ? : RESOURCE_DESC_SIZE_V0;\r\nhdr = (void *)hdr + hdr->desc_len;\r\n}\r\nreturn nic_pf_count;\r\n}\r\nint be_cmd_get_profile_config(struct be_adapter *adapter,\r\nstruct be_resources *res,\r\nstruct be_port_resources *port_res,\r\nu8 profile_type, u8 query, u8 domain)\r\n{\r\nstruct be_cmd_resp_get_profile_config *resp;\r\nstruct be_cmd_req_get_profile_config *req;\r\nstruct be_nic_res_desc *vf_res;\r\nstruct be_pcie_res_desc *pcie;\r\nstruct be_port_res_desc *port;\r\nstruct be_nic_res_desc *nic;\r\nstruct be_mcc_wrb wrb = {0};\r\nstruct be_dma_mem cmd;\r\nu16 desc_count;\r\nint status;\r\nmemset(&cmd, 0, sizeof(struct be_dma_mem));\r\ncmd.size = sizeof(struct be_cmd_resp_get_profile_config);\r\ncmd.va = dma_zalloc_coherent(&adapter->pdev->dev, cmd.size, &cmd.dma,\r\nGFP_ATOMIC);\r\nif (!cmd.va)\r\nreturn -ENOMEM;\r\nreq = cmd.va;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_PROFILE_CONFIG,\r\ncmd.size, &wrb, &cmd);\r\nif (!lancer_chip(adapter))\r\nreq->hdr.version = 1;\r\nreq->type = profile_type;\r\nreq->hdr.domain = domain;\r\nif (query == RESOURCE_MODIFIABLE)\r\nreq->type |= QUERY_MODIFIABLE_FIELDS_TYPE;\r\nstatus = be_cmd_notify_wait(adapter, &wrb);\r\nif (status)\r\ngoto err;\r\nresp = cmd.va;\r\ndesc_count = le16_to_cpu(resp->desc_count);\r\nif (port_res) {\r\nu16 nic_pf_cnt = 0, i;\r\nu16 nic_pf_num_list[MAX_NIC_FUNCS];\r\nnic_pf_cnt = be_get_nic_pf_num_list(resp->func_param,\r\ndesc_count,\r\nnic_pf_num_list);\r\nfor (i = 0; i < nic_pf_cnt; i++) {\r\nnic = be_get_func_nic_desc(resp->func_param, desc_count,\r\nnic_pf_num_list[i]);\r\nif (nic->link_param == adapter->port_num) {\r\nport_res->nic_pfs++;\r\npcie = be_get_pcie_desc(resp->func_param,\r\ndesc_count,\r\nnic_pf_num_list[i]);\r\nport_res->max_vfs += le16_to_cpu(pcie->num_vfs);\r\n}\r\n}\r\nreturn status;\r\n}\r\npcie = be_get_pcie_desc(resp->func_param, desc_count,\r\nadapter->pf_num);\r\nif (pcie)\r\nres->max_vfs = le16_to_cpu(pcie->num_vfs);\r\nport = be_get_port_desc(resp->func_param, desc_count);\r\nif (port)\r\nadapter->mc_type = port->mc_type;\r\nnic = be_get_func_nic_desc(resp->func_param, desc_count,\r\nadapter->pf_num);\r\nif (nic)\r\nbe_copy_nic_desc(res, nic);\r\nvf_res = be_get_vft_desc(resp->func_param, desc_count,\r\nadapter->pf_num);\r\nif (vf_res)\r\nres->vf_if_cap_flags = vf_res->cap_flags;\r\nerr:\r\nif (cmd.va)\r\ndma_free_coherent(&adapter->pdev->dev, cmd.size, cmd.va,\r\ncmd.dma);\r\nreturn status;\r\n}\r\nstatic int be_cmd_set_profile_config(struct be_adapter *adapter, void *desc,\r\nint size, int count, u8 version, u8 domain)\r\n{\r\nstruct be_cmd_req_set_profile_config *req;\r\nstruct be_mcc_wrb wrb = {0};\r\nstruct be_dma_mem cmd;\r\nint status;\r\nmemset(&cmd, 0, sizeof(struct be_dma_mem));\r\ncmd.size = sizeof(struct be_cmd_req_set_profile_config);\r\ncmd.va = dma_zalloc_coherent(&adapter->pdev->dev, cmd.size, &cmd.dma,\r\nGFP_ATOMIC);\r\nif (!cmd.va)\r\nreturn -ENOMEM;\r\nreq = cmd.va;\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_SET_PROFILE_CONFIG, cmd.size,\r\n&wrb, &cmd);\r\nreq->hdr.version = version;\r\nreq->hdr.domain = domain;\r\nreq->desc_count = cpu_to_le32(count);\r\nmemcpy(req->desc, desc, size);\r\nstatus = be_cmd_notify_wait(adapter, &wrb);\r\nif (cmd.va)\r\ndma_free_coherent(&adapter->pdev->dev, cmd.size, cmd.va,\r\ncmd.dma);\r\nreturn status;\r\n}\r\nstatic void be_reset_nic_desc(struct be_nic_res_desc *nic)\r\n{\r\nmemset(nic, 0, sizeof(*nic));\r\nnic->unicast_mac_count = 0xFFFF;\r\nnic->mcc_count = 0xFFFF;\r\nnic->vlan_count = 0xFFFF;\r\nnic->mcast_mac_count = 0xFFFF;\r\nnic->txq_count = 0xFFFF;\r\nnic->rq_count = 0xFFFF;\r\nnic->rssq_count = 0xFFFF;\r\nnic->lro_count = 0xFFFF;\r\nnic->cq_count = 0xFFFF;\r\nnic->toe_conn_count = 0xFFFF;\r\nnic->eq_count = 0xFFFF;\r\nnic->iface_count = 0xFFFF;\r\nnic->link_param = 0xFF;\r\nnic->channel_id_param = cpu_to_le16(0xF000);\r\nnic->acpi_params = 0xFF;\r\nnic->wol_param = 0x0F;\r\nnic->tunnel_iface_count = 0xFFFF;\r\nnic->direct_tenant_iface_count = 0xFFFF;\r\nnic->bw_min = 0xFFFFFFFF;\r\nnic->bw_max = 0xFFFFFFFF;\r\n}\r\nstatic void be_reset_pcie_desc(struct be_pcie_res_desc *pcie)\r\n{\r\nmemset(pcie, 0, sizeof(*pcie));\r\npcie->sriov_state = 0xFF;\r\npcie->pf_state = 0xFF;\r\npcie->pf_type = 0xFF;\r\npcie->num_vfs = 0xFFFF;\r\n}\r\nint be_cmd_config_qos(struct be_adapter *adapter, u32 max_rate, u16 link_speed,\r\nu8 domain)\r\n{\r\nstruct be_nic_res_desc nic_desc;\r\nu32 bw_percent;\r\nu16 version = 0;\r\nif (BE3_chip(adapter))\r\nreturn be_cmd_set_qos(adapter, max_rate / 10, domain);\r\nbe_reset_nic_desc(&nic_desc);\r\nnic_desc.pf_num = adapter->pf_num;\r\nnic_desc.vf_num = domain;\r\nnic_desc.bw_min = 0;\r\nif (lancer_chip(adapter)) {\r\nnic_desc.hdr.desc_type = NIC_RESOURCE_DESC_TYPE_V0;\r\nnic_desc.hdr.desc_len = RESOURCE_DESC_SIZE_V0;\r\nnic_desc.flags = (1 << QUN_SHIFT) | (1 << IMM_SHIFT) |\r\n(1 << NOSV_SHIFT);\r\nnic_desc.bw_max = cpu_to_le32(max_rate / 10);\r\n} else {\r\nversion = 1;\r\nnic_desc.hdr.desc_type = NIC_RESOURCE_DESC_TYPE_V1;\r\nnic_desc.hdr.desc_len = RESOURCE_DESC_SIZE_V1;\r\nnic_desc.flags = (1 << IMM_SHIFT) | (1 << NOSV_SHIFT);\r\nbw_percent = max_rate ? (max_rate * 100) / link_speed : 100;\r\nnic_desc.bw_max = cpu_to_le32(bw_percent);\r\n}\r\nreturn be_cmd_set_profile_config(adapter, &nic_desc,\r\nnic_desc.hdr.desc_len,\r\n1, version, domain);\r\n}\r\nint be_cmd_set_sriov_config(struct be_adapter *adapter,\r\nstruct be_resources pool_res, u16 num_vfs,\r\nstruct be_resources *vft_res)\r\n{\r\nstruct {\r\nstruct be_pcie_res_desc pcie;\r\nstruct be_nic_res_desc nic_vft;\r\n} __packed desc;\r\nbe_reset_pcie_desc(&desc.pcie);\r\ndesc.pcie.hdr.desc_type = PCIE_RESOURCE_DESC_TYPE_V1;\r\ndesc.pcie.hdr.desc_len = RESOURCE_DESC_SIZE_V1;\r\ndesc.pcie.flags = BIT(IMM_SHIFT) | BIT(NOSV_SHIFT);\r\ndesc.pcie.pf_num = adapter->pdev->devfn;\r\ndesc.pcie.sriov_state = num_vfs ? 1 : 0;\r\ndesc.pcie.num_vfs = cpu_to_le16(num_vfs);\r\nbe_reset_nic_desc(&desc.nic_vft);\r\ndesc.nic_vft.hdr.desc_type = NIC_RESOURCE_DESC_TYPE_V1;\r\ndesc.nic_vft.hdr.desc_len = RESOURCE_DESC_SIZE_V1;\r\ndesc.nic_vft.flags = vft_res->flags | BIT(VFT_SHIFT) |\r\nBIT(IMM_SHIFT) | BIT(NOSV_SHIFT);\r\ndesc.nic_vft.pf_num = adapter->pdev->devfn;\r\ndesc.nic_vft.vf_num = 0;\r\ndesc.nic_vft.cap_flags = cpu_to_le32(vft_res->vf_if_cap_flags);\r\ndesc.nic_vft.rq_count = cpu_to_le16(vft_res->max_rx_qs);\r\ndesc.nic_vft.txq_count = cpu_to_le16(vft_res->max_tx_qs);\r\ndesc.nic_vft.rssq_count = cpu_to_le16(vft_res->max_rss_qs);\r\ndesc.nic_vft.cq_count = cpu_to_le16(vft_res->max_cq_count);\r\nif (vft_res->max_uc_mac)\r\ndesc.nic_vft.unicast_mac_count =\r\ncpu_to_le16(vft_res->max_uc_mac);\r\nif (vft_res->max_vlans)\r\ndesc.nic_vft.vlan_count = cpu_to_le16(vft_res->max_vlans);\r\nif (vft_res->max_iface_count)\r\ndesc.nic_vft.iface_count =\r\ncpu_to_le16(vft_res->max_iface_count);\r\nif (vft_res->max_mcc_count)\r\ndesc.nic_vft.mcc_count = cpu_to_le16(vft_res->max_mcc_count);\r\nreturn be_cmd_set_profile_config(adapter, &desc,\r\n2 * RESOURCE_DESC_SIZE_V1, 2, 1, 0);\r\n}\r\nint be_cmd_manage_iface(struct be_adapter *adapter, u32 iface, u8 op)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_manage_iface_filters *req;\r\nint status;\r\nif (iface == 0xFFFFFFFF)\r\nreturn -1;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_MANAGE_IFACE_FILTERS, sizeof(*req),\r\nwrb, NULL);\r\nreq->op = op;\r\nreq->target_iface_id = cpu_to_le32(iface);\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_set_vxlan_port(struct be_adapter *adapter, __be16 port)\r\n{\r\nstruct be_port_res_desc port_desc;\r\nmemset(&port_desc, 0, sizeof(port_desc));\r\nport_desc.hdr.desc_type = PORT_RESOURCE_DESC_TYPE_V1;\r\nport_desc.hdr.desc_len = RESOURCE_DESC_SIZE_V1;\r\nport_desc.flags = (1 << IMM_SHIFT) | (1 << NOSV_SHIFT);\r\nport_desc.link_num = adapter->hba_port_num;\r\nif (port) {\r\nport_desc.nv_flags = NV_TYPE_VXLAN | (1 << SOCVID_SHIFT) |\r\n(1 << RCVID_SHIFT);\r\nport_desc.nv_port = swab16(port);\r\n} else {\r\nport_desc.nv_flags = NV_TYPE_DISABLED;\r\nport_desc.nv_port = 0;\r\n}\r\nreturn be_cmd_set_profile_config(adapter, &port_desc,\r\nRESOURCE_DESC_SIZE_V1, 1, 1, 0);\r\n}\r\nint be_cmd_get_if_id(struct be_adapter *adapter, struct be_vf_cfg *vf_cfg,\r\nint vf_num)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_get_iface_list *req;\r\nstruct be_cmd_resp_get_iface_list *resp;\r\nint status;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_IFACE_LIST, sizeof(*resp),\r\nwrb, NULL);\r\nreq->hdr.domain = vf_num + 1;\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (!status) {\r\nresp = (struct be_cmd_resp_get_iface_list *)req;\r\nvf_cfg->if_handle = le32_to_cpu(resp->if_desc.if_id);\r\n}\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nstatic int lancer_wait_idle(struct be_adapter *adapter)\r\n{\r\n#define SLIPORT_IDLE_TIMEOUT 30\r\nu32 reg_val;\r\nint status = 0, i;\r\nfor (i = 0; i < SLIPORT_IDLE_TIMEOUT; i++) {\r\nreg_val = ioread32(adapter->db + PHYSDEV_CONTROL_OFFSET);\r\nif ((reg_val & PHYSDEV_CONTROL_INP_MASK) == 0)\r\nbreak;\r\nssleep(1);\r\n}\r\nif (i == SLIPORT_IDLE_TIMEOUT)\r\nstatus = -1;\r\nreturn status;\r\n}\r\nint lancer_physdev_ctrl(struct be_adapter *adapter, u32 mask)\r\n{\r\nint status = 0;\r\nstatus = lancer_wait_idle(adapter);\r\nif (status)\r\nreturn status;\r\niowrite32(mask, adapter->db + PHYSDEV_CONTROL_OFFSET);\r\nreturn status;\r\n}\r\nbool dump_present(struct be_adapter *adapter)\r\n{\r\nu32 sliport_status = 0;\r\nsliport_status = ioread32(adapter->db + SLIPORT_STATUS_OFFSET);\r\nreturn !!(sliport_status & SLIPORT_STATUS_DIP_MASK);\r\n}\r\nint lancer_initiate_dump(struct be_adapter *adapter)\r\n{\r\nstruct device *dev = &adapter->pdev->dev;\r\nint status;\r\nif (dump_present(adapter)) {\r\ndev_info(dev, "Previous dump not cleared, not forcing dump\n");\r\nreturn -EEXIST;\r\n}\r\nstatus = lancer_physdev_ctrl(adapter, PHYSDEV_CONTROL_FW_RESET_MASK |\r\nPHYSDEV_CONTROL_DD_MASK);\r\nif (status < 0) {\r\ndev_err(dev, "FW reset failed\n");\r\nreturn status;\r\n}\r\nstatus = lancer_wait_idle(adapter);\r\nif (status)\r\nreturn status;\r\nif (!dump_present(adapter)) {\r\ndev_err(dev, "FW dump not generated\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint lancer_delete_dump(struct be_adapter *adapter)\r\n{\r\nint status;\r\nstatus = lancer_cmd_delete_object(adapter, LANCER_FW_DUMP_FILE);\r\nreturn be_cmd_status(status);\r\n}\r\nint be_cmd_enable_vf(struct be_adapter *adapter, u8 domain)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_enable_disable_vf *req;\r\nint status;\r\nif (BEx_chip(adapter))\r\nreturn 0;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_ENABLE_DISABLE_VF, sizeof(*req),\r\nwrb, NULL);\r\nreq->hdr.domain = domain;\r\nreq->enable = 1;\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_intr_set(struct be_adapter *adapter, bool intr_enable)\r\n{\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_intr_set *req;\r\nint status;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nwrb = wrb_from_mbox(adapter);\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_SET_INTERRUPT_ENABLE, sizeof(*req),\r\nwrb, NULL);\r\nreq->intr_enabled = intr_enable;\r\nstatus = be_mbox_notify_wait(adapter);\r\nmutex_unlock(&adapter->mbox_lock);\r\nreturn status;\r\n}\r\nint be_cmd_get_active_profile(struct be_adapter *adapter, u16 *profile_id)\r\n{\r\nstruct be_cmd_req_get_active_profile *req;\r\nstruct be_mcc_wrb *wrb;\r\nint status;\r\nif (mutex_lock_interruptible(&adapter->mbox_lock))\r\nreturn -1;\r\nwrb = wrb_from_mbox(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_ACTIVE_PROFILE, sizeof(*req),\r\nwrb, NULL);\r\nstatus = be_mbox_notify_wait(adapter);\r\nif (!status) {\r\nstruct be_cmd_resp_get_active_profile *resp =\r\nembedded_payload(wrb);\r\n*profile_id = le16_to_cpu(resp->active_profile_id);\r\n}\r\nerr:\r\nmutex_unlock(&adapter->mbox_lock);\r\nreturn status;\r\n}\r\nstatic int\r\n__be_cmd_set_logical_link_config(struct be_adapter *adapter,\r\nint link_state, int version, u8 domain)\r\n{\r\nstruct be_cmd_req_set_ll_link *req;\r\nstruct be_mcc_wrb *wrb;\r\nu32 link_config = 0;\r\nint status;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_SET_LOGICAL_LINK_CONFIG,\r\nsizeof(*req), wrb, NULL);\r\nreq->hdr.version = version;\r\nreq->hdr.domain = domain;\r\nif (link_state == IFLA_VF_LINK_STATE_ENABLE ||\r\nlink_state == IFLA_VF_LINK_STATE_AUTO)\r\nlink_config |= PLINK_ENABLE;\r\nif (link_state == IFLA_VF_LINK_STATE_AUTO)\r\nlink_config |= PLINK_TRACK;\r\nreq->link_config = cpu_to_le32(link_config);\r\nstatus = be_mcc_notify_wait(adapter);\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_cmd_set_logical_link_config(struct be_adapter *adapter,\r\nint link_state, u8 domain)\r\n{\r\nint status;\r\nif (BE2_chip(adapter))\r\nreturn -EOPNOTSUPP;\r\nstatus = __be_cmd_set_logical_link_config(adapter, link_state,\r\n2, domain);\r\nif (base_status(status) == MCC_STATUS_ILLEGAL_REQUEST)\r\nstatus = __be_cmd_set_logical_link_config(adapter, link_state,\r\n1, domain);\r\nreturn status;\r\n}\r\nint be_cmd_set_features(struct be_adapter *adapter)\r\n{\r\nstruct be_cmd_resp_set_features *resp;\r\nstruct be_cmd_req_set_features *req;\r\nstruct be_mcc_wrb *wrb;\r\nint status;\r\nif (mutex_lock_interruptible(&adapter->mcc_lock))\r\nreturn -1;\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_SET_FEATURES,\r\nsizeof(*req), wrb, NULL);\r\nreq->features = cpu_to_le32(BE_FEATURE_UE_RECOVERY);\r\nreq->parameter_len = cpu_to_le32(sizeof(struct be_req_ue_recovery));\r\nreq->parameter.req.uer = cpu_to_le32(BE_UE_RECOVERY_UER_MASK);\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (status)\r\ngoto err;\r\nresp = embedded_payload(wrb);\r\nadapter->error_recovery.ue_to_poll_time =\r\nle16_to_cpu(resp->parameter.resp.ue2rp);\r\nadapter->error_recovery.ue_to_reset_time =\r\nle16_to_cpu(resp->parameter.resp.ue2sr);\r\nadapter->error_recovery.recovery_supported = true;\r\nerr:\r\nif (base_status(status) == MCC_STATUS_ILLEGAL_REQUEST ||\r\nbase_status(status) == MCC_STATUS_INVALID_LENGTH)\r\ndev_info(&adapter->pdev->dev,\r\n"Adapter does not support HW error recovery\n");\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}\r\nint be_roce_mcc_cmd(void *netdev_handle, void *wrb_payload,\r\nint wrb_payload_size, u16 *cmd_status, u16 *ext_status)\r\n{\r\nstruct be_adapter *adapter = netdev_priv(netdev_handle);\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_hdr *hdr = (struct be_cmd_req_hdr *)wrb_payload;\r\nstruct be_cmd_req_hdr *req;\r\nstruct be_cmd_resp_hdr *resp;\r\nint status;\r\nmutex_lock(&adapter->mcc_lock);\r\nwrb = wrb_from_mccq(adapter);\r\nif (!wrb) {\r\nstatus = -EBUSY;\r\ngoto err;\r\n}\r\nreq = embedded_payload(wrb);\r\nresp = embedded_payload(wrb);\r\nbe_wrb_cmd_hdr_prepare(req, hdr->subsystem,\r\nhdr->opcode, wrb_payload_size, wrb, NULL);\r\nmemcpy(req, wrb_payload, wrb_payload_size);\r\nbe_dws_cpu_to_le(req, wrb_payload_size);\r\nstatus = be_mcc_notify_wait(adapter);\r\nif (cmd_status)\r\n*cmd_status = (status & 0xffff);\r\nif (ext_status)\r\n*ext_status = 0;\r\nmemcpy(wrb_payload, resp, sizeof(*resp) + resp->response_length);\r\nbe_dws_le_to_cpu(wrb_payload, sizeof(*resp) + resp->response_length);\r\nerr:\r\nmutex_unlock(&adapter->mcc_lock);\r\nreturn status;\r\n}
