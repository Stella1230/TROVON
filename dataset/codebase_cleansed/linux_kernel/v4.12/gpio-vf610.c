static inline void vf610_gpio_writel(u32 val, void __iomem *reg)\r\n{\r\nwritel_relaxed(val, reg);\r\n}\r\nstatic inline u32 vf610_gpio_readl(void __iomem *reg)\r\n{\r\nreturn readl_relaxed(reg);\r\n}\r\nstatic int vf610_gpio_get(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nstruct vf610_gpio_port *port = gpiochip_get_data(gc);\r\nreturn !!(vf610_gpio_readl(port->gpio_base + GPIO_PDIR) & BIT(gpio));\r\n}\r\nstatic void vf610_gpio_set(struct gpio_chip *gc, unsigned int gpio, int val)\r\n{\r\nstruct vf610_gpio_port *port = gpiochip_get_data(gc);\r\nunsigned long mask = BIT(gpio);\r\nif (val)\r\nvf610_gpio_writel(mask, port->gpio_base + GPIO_PSOR);\r\nelse\r\nvf610_gpio_writel(mask, port->gpio_base + GPIO_PCOR);\r\n}\r\nstatic int vf610_gpio_direction_input(struct gpio_chip *chip, unsigned gpio)\r\n{\r\nreturn pinctrl_gpio_direction_input(chip->base + gpio);\r\n}\r\nstatic int vf610_gpio_direction_output(struct gpio_chip *chip, unsigned gpio,\r\nint value)\r\n{\r\nvf610_gpio_set(chip, gpio, value);\r\nreturn pinctrl_gpio_direction_output(chip->base + gpio);\r\n}\r\nstatic void vf610_gpio_irq_handler(struct irq_desc *desc)\r\n{\r\nstruct vf610_gpio_port *port =\r\ngpiochip_get_data(irq_desc_get_handler_data(desc));\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nint pin;\r\nunsigned long irq_isfr;\r\nchained_irq_enter(chip, desc);\r\nirq_isfr = vf610_gpio_readl(port->base + PORT_ISFR);\r\nfor_each_set_bit(pin, &irq_isfr, VF610_GPIO_PER_PORT) {\r\nvf610_gpio_writel(BIT(pin), port->base + PORT_ISFR);\r\ngeneric_handle_irq(irq_find_mapping(port->gc.irqdomain, pin));\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic void vf610_gpio_irq_ack(struct irq_data *d)\r\n{\r\nstruct vf610_gpio_port *port =\r\ngpiochip_get_data(irq_data_get_irq_chip_data(d));\r\nint gpio = d->hwirq;\r\nvf610_gpio_writel(BIT(gpio), port->base + PORT_ISFR);\r\n}\r\nstatic int vf610_gpio_irq_set_type(struct irq_data *d, u32 type)\r\n{\r\nstruct vf610_gpio_port *port =\r\ngpiochip_get_data(irq_data_get_irq_chip_data(d));\r\nu8 irqc;\r\nswitch (type) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\nirqc = PORT_INT_RISING_EDGE;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nirqc = PORT_INT_FALLING_EDGE;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nirqc = PORT_INT_EITHER_EDGE;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nirqc = PORT_INT_LOGIC_ZERO;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nirqc = PORT_INT_LOGIC_ONE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nport->irqc[d->hwirq] = irqc;\r\nif (type & IRQ_TYPE_LEVEL_MASK)\r\nirq_set_handler_locked(d, handle_level_irq);\r\nelse\r\nirq_set_handler_locked(d, handle_edge_irq);\r\nreturn 0;\r\n}\r\nstatic void vf610_gpio_irq_mask(struct irq_data *d)\r\n{\r\nstruct vf610_gpio_port *port =\r\ngpiochip_get_data(irq_data_get_irq_chip_data(d));\r\nvoid __iomem *pcr_base = port->base + PORT_PCR(d->hwirq);\r\nvf610_gpio_writel(0, pcr_base);\r\n}\r\nstatic void vf610_gpio_irq_unmask(struct irq_data *d)\r\n{\r\nstruct vf610_gpio_port *port =\r\ngpiochip_get_data(irq_data_get_irq_chip_data(d));\r\nvoid __iomem *pcr_base = port->base + PORT_PCR(d->hwirq);\r\nvf610_gpio_writel(port->irqc[d->hwirq] << PORT_PCR_IRQC_OFFSET,\r\npcr_base);\r\n}\r\nstatic int vf610_gpio_irq_set_wake(struct irq_data *d, u32 enable)\r\n{\r\nstruct vf610_gpio_port *port =\r\ngpiochip_get_data(irq_data_get_irq_chip_data(d));\r\nif (enable)\r\nenable_irq_wake(port->irq);\r\nelse\r\ndisable_irq_wake(port->irq);\r\nreturn 0;\r\n}\r\nstatic int vf610_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct vf610_gpio_port *port;\r\nstruct resource *iores;\r\nstruct gpio_chip *gc;\r\nint ret;\r\nport = devm_kzalloc(&pdev->dev, sizeof(*port), GFP_KERNEL);\r\nif (!port)\r\nreturn -ENOMEM;\r\niores = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nport->base = devm_ioremap_resource(dev, iores);\r\nif (IS_ERR(port->base))\r\nreturn PTR_ERR(port->base);\r\niores = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nport->gpio_base = devm_ioremap_resource(dev, iores);\r\nif (IS_ERR(port->gpio_base))\r\nreturn PTR_ERR(port->gpio_base);\r\nport->irq = platform_get_irq(pdev, 0);\r\nif (port->irq < 0)\r\nreturn port->irq;\r\ngc = &port->gc;\r\ngc->of_node = np;\r\ngc->parent = dev;\r\ngc->label = "vf610-gpio";\r\ngc->ngpio = VF610_GPIO_PER_PORT;\r\ngc->base = of_alias_get_id(np, "gpio") * VF610_GPIO_PER_PORT;\r\ngc->request = gpiochip_generic_request;\r\ngc->free = gpiochip_generic_free;\r\ngc->direction_input = vf610_gpio_direction_input;\r\ngc->get = vf610_gpio_get;\r\ngc->direction_output = vf610_gpio_direction_output;\r\ngc->set = vf610_gpio_set;\r\nret = gpiochip_add_data(gc, port);\r\nif (ret < 0)\r\nreturn ret;\r\nvf610_gpio_writel(~0, port->base + PORT_ISFR);\r\nret = gpiochip_irqchip_add(gc, &vf610_gpio_irq_chip, 0,\r\nhandle_edge_irq, IRQ_TYPE_NONE);\r\nif (ret) {\r\ndev_err(dev, "failed to add irqchip\n");\r\ngpiochip_remove(gc);\r\nreturn ret;\r\n}\r\ngpiochip_set_chained_irqchip(gc, &vf610_gpio_irq_chip, port->irq,\r\nvf610_gpio_irq_handler);\r\nreturn 0;\r\n}
