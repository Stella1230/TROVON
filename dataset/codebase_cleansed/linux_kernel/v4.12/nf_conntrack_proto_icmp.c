static inline struct nf_icmp_net *icmp_pernet(struct net *net)\r\n{\r\nreturn &net->ct.nf_ct_proto.icmp;\r\n}\r\nstatic bool icmp_pkt_to_tuple(const struct sk_buff *skb, unsigned int dataoff,\r\nstruct net *net, struct nf_conntrack_tuple *tuple)\r\n{\r\nconst struct icmphdr *hp;\r\nstruct icmphdr _hdr;\r\nhp = skb_header_pointer(skb, dataoff, sizeof(_hdr), &_hdr);\r\nif (hp == NULL)\r\nreturn false;\r\ntuple->dst.u.icmp.type = hp->type;\r\ntuple->src.u.icmp.id = hp->un.echo.id;\r\ntuple->dst.u.icmp.code = hp->code;\r\nreturn true;\r\n}\r\nstatic bool icmp_invert_tuple(struct nf_conntrack_tuple *tuple,\r\nconst struct nf_conntrack_tuple *orig)\r\n{\r\nif (orig->dst.u.icmp.type >= sizeof(invmap) ||\r\n!invmap[orig->dst.u.icmp.type])\r\nreturn false;\r\ntuple->src.u.icmp.id = orig->src.u.icmp.id;\r\ntuple->dst.u.icmp.type = invmap[orig->dst.u.icmp.type] - 1;\r\ntuple->dst.u.icmp.code = orig->dst.u.icmp.code;\r\nreturn true;\r\n}\r\nstatic void icmp_print_tuple(struct seq_file *s,\r\nconst struct nf_conntrack_tuple *tuple)\r\n{\r\nseq_printf(s, "type=%u code=%u id=%u ",\r\ntuple->dst.u.icmp.type,\r\ntuple->dst.u.icmp.code,\r\nntohs(tuple->src.u.icmp.id));\r\n}\r\nstatic unsigned int *icmp_get_timeouts(struct net *net)\r\n{\r\nreturn &icmp_pernet(net)->timeout;\r\n}\r\nstatic int icmp_packet(struct nf_conn *ct,\r\nconst struct sk_buff *skb,\r\nunsigned int dataoff,\r\nenum ip_conntrack_info ctinfo,\r\nu_int8_t pf,\r\nunsigned int hooknum,\r\nunsigned int *timeout)\r\n{\r\nnf_ct_refresh_acct(ct, ctinfo, skb, *timeout);\r\nreturn NF_ACCEPT;\r\n}\r\nstatic bool icmp_new(struct nf_conn *ct, const struct sk_buff *skb,\r\nunsigned int dataoff, unsigned int *timeouts)\r\n{\r\nstatic const u_int8_t valid_new[] = {\r\n[ICMP_ECHO] = 1,\r\n[ICMP_TIMESTAMP] = 1,\r\n[ICMP_INFO_REQUEST] = 1,\r\n[ICMP_ADDRESS] = 1\r\n};\r\nif (ct->tuplehash[0].tuple.dst.u.icmp.type >= sizeof(valid_new) ||\r\n!valid_new[ct->tuplehash[0].tuple.dst.u.icmp.type]) {\r\npr_debug("icmp: can't create new conn with type %u\n",\r\nct->tuplehash[0].tuple.dst.u.icmp.type);\r\nnf_ct_dump_tuple_ip(&ct->tuplehash[0].tuple);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int\r\nicmp_error_message(struct net *net, struct nf_conn *tmpl, struct sk_buff *skb,\r\nunsigned int hooknum)\r\n{\r\nstruct nf_conntrack_tuple innertuple, origtuple;\r\nconst struct nf_conntrack_l4proto *innerproto;\r\nconst struct nf_conntrack_tuple_hash *h;\r\nconst struct nf_conntrack_zone *zone;\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conntrack_zone tmp;\r\nNF_CT_ASSERT(!skb_nfct(skb));\r\nzone = nf_ct_zone_tmpl(tmpl, skb, &tmp);\r\nif (!nf_ct_get_tuplepr(skb,\r\nskb_network_offset(skb) + ip_hdrlen(skb)\r\n+ sizeof(struct icmphdr),\r\nPF_INET, net, &origtuple)) {\r\npr_debug("icmp_error_message: failed to get tuple\n");\r\nreturn -NF_ACCEPT;\r\n}\r\ninnerproto = __nf_ct_l4proto_find(PF_INET, origtuple.dst.protonum);\r\nif (!nf_ct_invert_tuple(&innertuple, &origtuple,\r\n&nf_conntrack_l3proto_ipv4, innerproto)) {\r\npr_debug("icmp_error_message: no match\n");\r\nreturn -NF_ACCEPT;\r\n}\r\nctinfo = IP_CT_RELATED;\r\nh = nf_conntrack_find_get(net, zone, &innertuple);\r\nif (!h) {\r\npr_debug("icmp_error_message: no match\n");\r\nreturn -NF_ACCEPT;\r\n}\r\nif (NF_CT_DIRECTION(h) == IP_CT_DIR_REPLY)\r\nctinfo += IP_CT_IS_REPLY;\r\nnf_ct_set(skb, nf_ct_tuplehash_to_ctrack(h), ctinfo);\r\nreturn NF_ACCEPT;\r\n}\r\nstatic int\r\nicmp_error(struct net *net, struct nf_conn *tmpl,\r\nstruct sk_buff *skb, unsigned int dataoff,\r\nu8 pf, unsigned int hooknum)\r\n{\r\nconst struct icmphdr *icmph;\r\nstruct icmphdr _ih;\r\nicmph = skb_header_pointer(skb, ip_hdrlen(skb), sizeof(_ih), &_ih);\r\nif (icmph == NULL) {\r\nif (LOG_INVALID(net, IPPROTO_ICMP))\r\nnf_log_packet(net, PF_INET, 0, skb, NULL, NULL,\r\nNULL, "nf_ct_icmp: short packet ");\r\nreturn -NF_ACCEPT;\r\n}\r\nif (net->ct.sysctl_checksum && hooknum == NF_INET_PRE_ROUTING &&\r\nnf_ip_checksum(skb, hooknum, dataoff, 0)) {\r\nif (LOG_INVALID(net, IPPROTO_ICMP))\r\nnf_log_packet(net, PF_INET, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_icmp: bad HW ICMP checksum ");\r\nreturn -NF_ACCEPT;\r\n}\r\nif (icmph->type > NR_ICMP_TYPES) {\r\nif (LOG_INVALID(net, IPPROTO_ICMP))\r\nnf_log_packet(net, PF_INET, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_icmp: invalid ICMP type ");\r\nreturn -NF_ACCEPT;\r\n}\r\nif (icmph->type != ICMP_DEST_UNREACH &&\r\nicmph->type != ICMP_SOURCE_QUENCH &&\r\nicmph->type != ICMP_TIME_EXCEEDED &&\r\nicmph->type != ICMP_PARAMETERPROB &&\r\nicmph->type != ICMP_REDIRECT)\r\nreturn NF_ACCEPT;\r\nreturn icmp_error_message(net, tmpl, skb, hooknum);\r\n}\r\nstatic int icmp_tuple_to_nlattr(struct sk_buff *skb,\r\nconst struct nf_conntrack_tuple *t)\r\n{\r\nif (nla_put_be16(skb, CTA_PROTO_ICMP_ID, t->src.u.icmp.id) ||\r\nnla_put_u8(skb, CTA_PROTO_ICMP_TYPE, t->dst.u.icmp.type) ||\r\nnla_put_u8(skb, CTA_PROTO_ICMP_CODE, t->dst.u.icmp.code))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int icmp_nlattr_to_tuple(struct nlattr *tb[],\r\nstruct nf_conntrack_tuple *tuple)\r\n{\r\nif (!tb[CTA_PROTO_ICMP_TYPE] ||\r\n!tb[CTA_PROTO_ICMP_CODE] ||\r\n!tb[CTA_PROTO_ICMP_ID])\r\nreturn -EINVAL;\r\ntuple->dst.u.icmp.type = nla_get_u8(tb[CTA_PROTO_ICMP_TYPE]);\r\ntuple->dst.u.icmp.code = nla_get_u8(tb[CTA_PROTO_ICMP_CODE]);\r\ntuple->src.u.icmp.id = nla_get_be16(tb[CTA_PROTO_ICMP_ID]);\r\nif (tuple->dst.u.icmp.type >= sizeof(invmap) ||\r\n!invmap[tuple->dst.u.icmp.type])\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int icmp_nlattr_tuple_size(void)\r\n{\r\nreturn nla_policy_len(icmp_nla_policy, CTA_PROTO_MAX + 1);\r\n}\r\nstatic int icmp_timeout_nlattr_to_obj(struct nlattr *tb[],\r\nstruct net *net, void *data)\r\n{\r\nunsigned int *timeout = data;\r\nstruct nf_icmp_net *in = icmp_pernet(net);\r\nif (tb[CTA_TIMEOUT_ICMP_TIMEOUT]) {\r\n*timeout =\r\nntohl(nla_get_be32(tb[CTA_TIMEOUT_ICMP_TIMEOUT])) * HZ;\r\n} else {\r\n*timeout = in->timeout;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nicmp_timeout_obj_to_nlattr(struct sk_buff *skb, const void *data)\r\n{\r\nconst unsigned int *timeout = data;\r\nif (nla_put_be32(skb, CTA_TIMEOUT_ICMP_TIMEOUT, htonl(*timeout / HZ)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -ENOSPC;\r\n}\r\nstatic int icmp_kmemdup_sysctl_table(struct nf_proto_net *pn,\r\nstruct nf_icmp_net *in)\r\n{\r\n#ifdef CONFIG_SYSCTL\r\npn->ctl_table = kmemdup(icmp_sysctl_table,\r\nsizeof(icmp_sysctl_table),\r\nGFP_KERNEL);\r\nif (!pn->ctl_table)\r\nreturn -ENOMEM;\r\npn->ctl_table[0].data = &in->timeout;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int icmp_init_net(struct net *net, u_int16_t proto)\r\n{\r\nstruct nf_icmp_net *in = icmp_pernet(net);\r\nstruct nf_proto_net *pn = &in->pn;\r\nin->timeout = nf_ct_icmp_timeout;\r\nreturn icmp_kmemdup_sysctl_table(pn, in);\r\n}\r\nstatic struct nf_proto_net *icmp_get_net_proto(struct net *net)\r\n{\r\nreturn &net->ct.nf_ct_proto.icmp.pn;\r\n}
