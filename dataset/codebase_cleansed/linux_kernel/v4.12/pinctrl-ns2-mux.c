static int ns2_get_groups_count(struct pinctrl_dev *pctrl_dev)\r\n{\r\nstruct ns2_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\r\nreturn pinctrl->num_groups;\r\n}\r\nstatic const char *ns2_get_group_name(struct pinctrl_dev *pctrl_dev,\r\nunsigned int selector)\r\n{\r\nstruct ns2_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\r\nreturn pinctrl->groups[selector].name;\r\n}\r\nstatic int ns2_get_group_pins(struct pinctrl_dev *pctrl_dev,\r\nunsigned int selector, const unsigned int **pins,\r\nunsigned int *num_pins)\r\n{\r\nstruct ns2_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\r\n*pins = pinctrl->groups[selector].pins;\r\n*num_pins = pinctrl->groups[selector].num_pins;\r\nreturn 0;\r\n}\r\nstatic void ns2_pin_dbg_show(struct pinctrl_dev *pctrl_dev,\r\nstruct seq_file *s, unsigned int offset)\r\n{\r\nseq_printf(s, " %s", dev_name(pctrl_dev->dev));\r\n}\r\nstatic int ns2_get_functions_count(struct pinctrl_dev *pctrl_dev)\r\n{\r\nstruct ns2_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\r\nreturn pinctrl->num_functions;\r\n}\r\nstatic const char *ns2_get_function_name(struct pinctrl_dev *pctrl_dev,\r\nunsigned int selector)\r\n{\r\nstruct ns2_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\r\nreturn pinctrl->functions[selector].name;\r\n}\r\nstatic int ns2_get_function_groups(struct pinctrl_dev *pctrl_dev,\r\nunsigned int selector,\r\nconst char * const **groups,\r\nunsigned int * const num_groups)\r\n{\r\nstruct ns2_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\r\n*groups = pinctrl->functions[selector].groups;\r\n*num_groups = pinctrl->functions[selector].num_groups;\r\nreturn 0;\r\n}\r\nstatic int ns2_pinmux_set(struct ns2_pinctrl *pinctrl,\r\nconst struct ns2_pin_function *func,\r\nconst struct ns2_pin_group *grp,\r\nstruct ns2_mux_log *mux_log)\r\n{\r\nconst struct ns2_mux *mux = &grp->mux;\r\nint i;\r\nu32 val, mask;\r\nunsigned long flags;\r\nvoid __iomem *base_address;\r\nfor (i = 0; i < NS2_NUM_IOMUX; i++) {\r\nif ((mux->shift != mux_log[i].mux.shift) ||\r\n(mux->base != mux_log[i].mux.base) ||\r\n(mux->offset != mux_log[i].mux.offset))\r\ncontinue;\r\nif (!mux_log[i].is_configured)\r\nbreak;\r\nif (mux_log[i].mux.alt != mux->alt) {\r\ndev_err(pinctrl->dev,\r\n"double configuration error detected!\n");\r\ndev_err(pinctrl->dev, "func:%s grp:%s\n",\r\nfunc->name, grp->name);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nif (i == NS2_NUM_IOMUX)\r\nreturn -EINVAL;\r\nmask = mux->mask;\r\nmux_log[i].mux.alt = mux->alt;\r\nmux_log[i].is_configured = true;\r\nswitch (mux->base) {\r\ncase NS2_PIN_MUX_BASE0:\r\nbase_address = pinctrl->base0;\r\nbreak;\r\ncase NS2_PIN_MUX_BASE1:\r\nbase_address = pinctrl->base1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&pinctrl->lock, flags);\r\nval = readl(base_address + grp->mux.offset);\r\nval &= ~(mask << grp->mux.shift);\r\nval |= grp->mux.alt << grp->mux.shift;\r\nwritel(val, (base_address + grp->mux.offset));\r\nspin_unlock_irqrestore(&pinctrl->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ns2_pinmux_enable(struct pinctrl_dev *pctrl_dev,\r\nunsigned int func_select, unsigned int grp_select)\r\n{\r\nstruct ns2_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\r\nconst struct ns2_pin_function *func;\r\nconst struct ns2_pin_group *grp;\r\nif (grp_select > pinctrl->num_groups ||\r\nfunc_select > pinctrl->num_functions)\r\nreturn -EINVAL;\r\nfunc = &pinctrl->functions[func_select];\r\ngrp = &pinctrl->groups[grp_select];\r\ndev_dbg(pctrl_dev->dev, "func:%u name:%s grp:%u name:%s\n",\r\nfunc_select, func->name, grp_select, grp->name);\r\ndev_dbg(pctrl_dev->dev, "offset:0x%08x shift:%u alt:%u\n",\r\ngrp->mux.offset, grp->mux.shift, grp->mux.alt);\r\nreturn ns2_pinmux_set(pinctrl, func, grp, pinctrl->mux_log);\r\n}\r\nstatic int ns2_pin_set_enable(struct pinctrl_dev *pctrldev, unsigned int pin,\r\nu16 enable)\r\n{\r\nstruct ns2_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrldev);\r\nstruct ns2_pin *pin_data = pctrldev->desc->pins[pin].drv_data;\r\nunsigned long flags;\r\nu32 val;\r\nvoid __iomem *base_address;\r\nbase_address = pinctrl->pinconf_base;\r\nspin_lock_irqsave(&pinctrl->lock, flags);\r\nval = readl(base_address + pin_data->pin_conf.offset);\r\nval &= ~(NS2_PIN_SRC_MASK << pin_data->pin_conf.input_en);\r\nif (!enable)\r\nval |= NS2_PIN_INPUT_EN_MASK << pin_data->pin_conf.input_en;\r\nwritel(val, (base_address + pin_data->pin_conf.offset));\r\nspin_unlock_irqrestore(&pinctrl->lock, flags);\r\ndev_dbg(pctrldev->dev, "pin:%u set enable:%d\n", pin, enable);\r\nreturn 0;\r\n}\r\nstatic int ns2_pin_get_enable(struct pinctrl_dev *pctrldev, unsigned int pin)\r\n{\r\nstruct ns2_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrldev);\r\nstruct ns2_pin *pin_data = pctrldev->desc->pins[pin].drv_data;\r\nunsigned long flags;\r\nint enable;\r\nspin_lock_irqsave(&pinctrl->lock, flags);\r\nenable = readl(pinctrl->pinconf_base + pin_data->pin_conf.offset);\r\nenable = (enable >> pin_data->pin_conf.input_en) &\r\nNS2_PIN_INPUT_EN_MASK;\r\nspin_unlock_irqrestore(&pinctrl->lock, flags);\r\nif (!enable)\r\nenable = NS2_PIN_INPUT_EN_MASK;\r\nelse\r\nenable = 0;\r\ndev_dbg(pctrldev->dev, "pin:%u get disable:%d\n", pin, enable);\r\nreturn enable;\r\n}\r\nstatic int ns2_pin_set_slew(struct pinctrl_dev *pctrldev, unsigned int pin,\r\nu32 slew)\r\n{\r\nstruct ns2_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrldev);\r\nstruct ns2_pin *pin_data = pctrldev->desc->pins[pin].drv_data;\r\nunsigned long flags;\r\nu32 val;\r\nvoid __iomem *base_address;\r\nbase_address = pinctrl->pinconf_base;\r\nspin_lock_irqsave(&pinctrl->lock, flags);\r\nval = readl(base_address + pin_data->pin_conf.offset);\r\nval &= ~(NS2_PIN_SRC_MASK << pin_data->pin_conf.src_shift);\r\nif (slew)\r\nval |= NS2_PIN_SRC_MASK << pin_data->pin_conf.src_shift;\r\nwritel(val, (base_address + pin_data->pin_conf.offset));\r\nspin_unlock_irqrestore(&pinctrl->lock, flags);\r\ndev_dbg(pctrldev->dev, "pin:%u set slew:%d\n", pin, slew);\r\nreturn 0;\r\n}\r\nstatic int ns2_pin_get_slew(struct pinctrl_dev *pctrldev, unsigned int pin,\r\nu16 *slew)\r\n{\r\nstruct ns2_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrldev);\r\nstruct ns2_pin *pin_data = pctrldev->desc->pins[pin].drv_data;\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&pinctrl->lock, flags);\r\nval = readl(pinctrl->pinconf_base + pin_data->pin_conf.offset);\r\n*slew = (val >> pin_data->pin_conf.src_shift) & NS2_PIN_SRC_MASK;\r\nspin_unlock_irqrestore(&pinctrl->lock, flags);\r\ndev_dbg(pctrldev->dev, "pin:%u get slew:%d\n", pin, *slew);\r\nreturn 0;\r\n}\r\nstatic int ns2_pin_set_pull(struct pinctrl_dev *pctrldev, unsigned int pin,\r\nbool pull_up, bool pull_down)\r\n{\r\nstruct ns2_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrldev);\r\nstruct ns2_pin *pin_data = pctrldev->desc->pins[pin].drv_data;\r\nunsigned long flags;\r\nu32 val;\r\nvoid __iomem *base_address;\r\nbase_address = pinctrl->pinconf_base;\r\nspin_lock_irqsave(&pinctrl->lock, flags);\r\nval = readl(base_address + pin_data->pin_conf.offset);\r\nval &= ~(NS2_PIN_PULL_MASK << pin_data->pin_conf.pull_shift);\r\nif (pull_up == true)\r\nval |= NS2_PIN_PULL_UP << pin_data->pin_conf.pull_shift;\r\nif (pull_down == true)\r\nval |= NS2_PIN_PULL_DOWN << pin_data->pin_conf.pull_shift;\r\nwritel(val, (base_address + pin_data->pin_conf.offset));\r\nspin_unlock_irqrestore(&pinctrl->lock, flags);\r\ndev_dbg(pctrldev->dev, "pin:%u set pullup:%d pulldown: %d\n",\r\npin, pull_up, pull_down);\r\nreturn 0;\r\n}\r\nstatic void ns2_pin_get_pull(struct pinctrl_dev *pctrldev,\r\nunsigned int pin, bool *pull_up,\r\nbool *pull_down)\r\n{\r\nstruct ns2_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrldev);\r\nstruct ns2_pin *pin_data = pctrldev->desc->pins[pin].drv_data;\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&pinctrl->lock, flags);\r\nval = readl(pinctrl->pinconf_base + pin_data->pin_conf.offset);\r\nval = (val >> pin_data->pin_conf.pull_shift) & NS2_PIN_PULL_MASK;\r\n*pull_up = false;\r\n*pull_down = false;\r\nif (val == NS2_PIN_PULL_UP)\r\n*pull_up = true;\r\nif (val == NS2_PIN_PULL_DOWN)\r\n*pull_down = true;\r\nspin_unlock_irqrestore(&pinctrl->lock, flags);\r\n}\r\nstatic int ns2_pin_set_strength(struct pinctrl_dev *pctrldev, unsigned int pin,\r\nu32 strength)\r\n{\r\nstruct ns2_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrldev);\r\nstruct ns2_pin *pin_data = pctrldev->desc->pins[pin].drv_data;\r\nu32 val;\r\nunsigned long flags;\r\nvoid __iomem *base_address;\r\nif (strength < 2 || strength > 16 || (strength % 2))\r\nreturn -ENOTSUPP;\r\nbase_address = pinctrl->pinconf_base;\r\nspin_lock_irqsave(&pinctrl->lock, flags);\r\nval = readl(base_address + pin_data->pin_conf.offset);\r\nval &= ~(NS2_PIN_DRIVE_STRENGTH_MASK << pin_data->pin_conf.drive_shift);\r\nval |= ((strength / 2) - 1) << pin_data->pin_conf.drive_shift;\r\nwritel(val, (base_address + pin_data->pin_conf.offset));\r\nspin_unlock_irqrestore(&pinctrl->lock, flags);\r\ndev_dbg(pctrldev->dev, "pin:%u set drive strength:%d mA\n",\r\npin, strength);\r\nreturn 0;\r\n}\r\nstatic int ns2_pin_get_strength(struct pinctrl_dev *pctrldev, unsigned int pin,\r\nu16 *strength)\r\n{\r\nstruct ns2_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrldev);\r\nstruct ns2_pin *pin_data = pctrldev->desc->pins[pin].drv_data;\r\nu32 val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&pinctrl->lock, flags);\r\nval = readl(pinctrl->pinconf_base + pin_data->pin_conf.offset);\r\n*strength = (val >> pin_data->pin_conf.drive_shift) &\r\nNS2_PIN_DRIVE_STRENGTH_MASK;\r\n*strength = (*strength + 1) * 2;\r\nspin_unlock_irqrestore(&pinctrl->lock, flags);\r\ndev_dbg(pctrldev->dev, "pin:%u get drive strength:%d mA\n",\r\npin, *strength);\r\nreturn 0;\r\n}\r\nstatic int ns2_pin_config_get(struct pinctrl_dev *pctldev, unsigned int pin,\r\nunsigned long *config)\r\n{\r\nstruct ns2_pin *pin_data = pctldev->desc->pins[pin].drv_data;\r\nenum pin_config_param param = pinconf_to_config_param(*config);\r\nbool pull_up, pull_down;\r\nu16 arg = 0;\r\nint ret;\r\nif (pin_data->pin_conf.base == -1)\r\nreturn -ENOTSUPP;\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nns2_pin_get_pull(pctldev, pin, &pull_up, &pull_down);\r\nif ((pull_up == false) && (pull_down == false))\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nns2_pin_get_pull(pctldev, pin, &pull_up, &pull_down);\r\nif (pull_up)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nns2_pin_get_pull(pctldev, pin, &pull_up, &pull_down);\r\nif (pull_down)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\nret = ns2_pin_get_strength(pctldev, pin, &arg);\r\nif (ret)\r\nreturn ret;\r\n*config = pinconf_to_config_packed(param, arg);\r\nreturn 0;\r\ncase PIN_CONFIG_SLEW_RATE:\r\nret = ns2_pin_get_slew(pctldev, pin, &arg);\r\nif (ret)\r\nreturn ret;\r\n*config = pinconf_to_config_packed(param, arg);\r\nreturn 0;\r\ncase PIN_CONFIG_INPUT_ENABLE:\r\nret = ns2_pin_get_enable(pctldev, pin);\r\nif (ret)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\n}\r\nstatic int ns2_pin_config_set(struct pinctrl_dev *pctrldev, unsigned int pin,\r\nunsigned long *configs, unsigned int num_configs)\r\n{\r\nstruct ns2_pin *pin_data = pctrldev->desc->pins[pin].drv_data;\r\nenum pin_config_param param;\r\nunsigned int i;\r\nu32 arg;\r\nint ret = -ENOTSUPP;\r\nif (pin_data->pin_conf.base == -1)\r\nreturn -ENOTSUPP;\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = pinconf_to_config_param(configs[i]);\r\narg = pinconf_to_config_argument(configs[i]);\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nret = ns2_pin_set_pull(pctrldev, pin, false, false);\r\nif (ret < 0)\r\ngoto out;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nret = ns2_pin_set_pull(pctrldev, pin, true, false);\r\nif (ret < 0)\r\ngoto out;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nret = ns2_pin_set_pull(pctrldev, pin, false, true);\r\nif (ret < 0)\r\ngoto out;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\nret = ns2_pin_set_strength(pctrldev, pin, arg);\r\nif (ret < 0)\r\ngoto out;\r\nbreak;\r\ncase PIN_CONFIG_SLEW_RATE:\r\nret = ns2_pin_set_slew(pctrldev, pin, arg);\r\nif (ret < 0)\r\ngoto out;\r\nbreak;\r\ncase PIN_CONFIG_INPUT_ENABLE:\r\nret = ns2_pin_set_enable(pctrldev, pin, arg);\r\nif (ret < 0)\r\ngoto out;\r\nbreak;\r\ndefault:\r\ndev_err(pctrldev->dev, "invalid configuration\n");\r\nreturn -ENOTSUPP;\r\n}\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int ns2_mux_log_init(struct ns2_pinctrl *pinctrl)\r\n{\r\nstruct ns2_mux_log *log;\r\nunsigned int i;\r\npinctrl->mux_log = devm_kcalloc(pinctrl->dev, NS2_NUM_IOMUX,\r\nsizeof(struct ns2_mux_log),\r\nGFP_KERNEL);\r\nif (!pinctrl->mux_log)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < NS2_NUM_IOMUX; i++)\r\npinctrl->mux_log[i].is_configured = false;\r\nlog = &pinctrl->mux_log[0];\r\nlog->mux.base = NS2_PIN_MUX_BASE0;\r\nlog->mux.offset = 0;\r\nlog->mux.shift = 31;\r\nlog->mux.alt = 0;\r\nfor (i = 1; i < (NS2_NUM_IOMUX - NS2_NUM_PWM_MUX); i++) {\r\nlog = &pinctrl->mux_log[i];\r\nlog->mux.base = NS2_PIN_MUX_BASE0;\r\nlog->mux.offset = NS2_MUX_PAD_FUNC1_OFFSET;\r\nlog->mux.shift = 32 - (i * 2);\r\nlog->mux.alt = 0;\r\n}\r\nfor (i = 0; i < NS2_NUM_PWM_MUX; i++) {\r\nlog = &pinctrl->mux_log[(NS2_NUM_IOMUX - NS2_NUM_PWM_MUX) + i];\r\nlog->mux.base = NS2_PIN_MUX_BASE1;\r\nlog->mux.offset = 0;\r\nlog->mux.shift = i;\r\nlog->mux.alt = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ns2_pinmux_probe(struct platform_device *pdev)\r\n{\r\nstruct ns2_pinctrl *pinctrl;\r\nstruct resource *res;\r\nint i, ret;\r\nstruct pinctrl_pin_desc *pins;\r\nunsigned int num_pins = ARRAY_SIZE(ns2_pins);\r\npinctrl = devm_kzalloc(&pdev->dev, sizeof(*pinctrl), GFP_KERNEL);\r\nif (!pinctrl)\r\nreturn -ENOMEM;\r\npinctrl->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, pinctrl);\r\nspin_lock_init(&pinctrl->lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npinctrl->base0 = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pinctrl->base0))\r\nreturn PTR_ERR(pinctrl->base0);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\npinctrl->base1 = devm_ioremap_nocache(&pdev->dev, res->start,\r\nresource_size(res));\r\nif (!pinctrl->base1) {\r\ndev_err(&pdev->dev, "unable to map I/O space\n");\r\nreturn -ENOMEM;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 2);\r\npinctrl->pinconf_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pinctrl->pinconf_base))\r\nreturn PTR_ERR(pinctrl->pinconf_base);\r\nret = ns2_mux_log_init(pinctrl);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to initialize IOMUX log\n");\r\nreturn ret;\r\n}\r\npins = devm_kcalloc(&pdev->dev, num_pins, sizeof(*pins), GFP_KERNEL);\r\nif (!pins)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < num_pins; i++) {\r\npins[i].number = ns2_pins[i].pin;\r\npins[i].name = ns2_pins[i].name;\r\npins[i].drv_data = &ns2_pins[i];\r\n}\r\npinctrl->groups = ns2_pin_groups;\r\npinctrl->num_groups = ARRAY_SIZE(ns2_pin_groups);\r\npinctrl->functions = ns2_pin_functions;\r\npinctrl->num_functions = ARRAY_SIZE(ns2_pin_functions);\r\nns2_pinctrl_desc.pins = pins;\r\nns2_pinctrl_desc.npins = num_pins;\r\npinctrl->pctl = pinctrl_register(&ns2_pinctrl_desc, &pdev->dev,\r\npinctrl);\r\nif (IS_ERR(pinctrl->pctl)) {\r\ndev_err(&pdev->dev, "unable to register IOMUX pinctrl\n");\r\nreturn PTR_ERR(pinctrl->pctl);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init ns2_pinmux_init(void)\r\n{\r\nreturn platform_driver_register(&ns2_pinmux_driver);\r\n}
