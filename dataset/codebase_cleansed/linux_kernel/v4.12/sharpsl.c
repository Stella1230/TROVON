static inline struct sharpsl_nand *mtd_to_sharpsl(struct mtd_info *mtd)\r\n{\r\nreturn container_of(mtd_to_nand(mtd), struct sharpsl_nand, chip);\r\n}\r\nstatic void sharpsl_nand_hwcontrol(struct mtd_info *mtd, int cmd,\r\nunsigned int ctrl)\r\n{\r\nstruct sharpsl_nand *sharpsl = mtd_to_sharpsl(mtd);\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nif (ctrl & NAND_CTRL_CHANGE) {\r\nunsigned char bits = ctrl & 0x07;\r\nbits |= (ctrl & 0x01) << 4;\r\nbits ^= 0x11;\r\nwriteb((readb(sharpsl->io + FLASHCTL) & ~0x17) | bits, sharpsl->io + FLASHCTL);\r\n}\r\nif (cmd != NAND_CMD_NONE)\r\nwriteb(cmd, chip->IO_ADDR_W);\r\n}\r\nstatic int sharpsl_nand_dev_ready(struct mtd_info *mtd)\r\n{\r\nstruct sharpsl_nand *sharpsl = mtd_to_sharpsl(mtd);\r\nreturn !((readb(sharpsl->io + FLASHCTL) & FLRYBY) == 0);\r\n}\r\nstatic void sharpsl_nand_enable_hwecc(struct mtd_info *mtd, int mode)\r\n{\r\nstruct sharpsl_nand *sharpsl = mtd_to_sharpsl(mtd);\r\nwriteb(0, sharpsl->io + ECCCLRR);\r\n}\r\nstatic int sharpsl_nand_calculate_ecc(struct mtd_info *mtd, const u_char * dat, u_char * ecc_code)\r\n{\r\nstruct sharpsl_nand *sharpsl = mtd_to_sharpsl(mtd);\r\necc_code[0] = ~readb(sharpsl->io + ECCLPUB);\r\necc_code[1] = ~readb(sharpsl->io + ECCLPLB);\r\necc_code[2] = (~readb(sharpsl->io + ECCCP) << 2) | 0x03;\r\nreturn readb(sharpsl->io + ECCCNTR) != 0;\r\n}\r\nstatic int sharpsl_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct nand_chip *this;\r\nstruct mtd_info *mtd;\r\nstruct resource *r;\r\nint err = 0;\r\nstruct sharpsl_nand *sharpsl;\r\nstruct sharpsl_nand_platform_data *data = dev_get_platdata(&pdev->dev);\r\nif (!data) {\r\ndev_err(&pdev->dev, "no platform data!\n");\r\nreturn -EINVAL;\r\n}\r\nsharpsl = kzalloc(sizeof(struct sharpsl_nand), GFP_KERNEL);\r\nif (!sharpsl)\r\nreturn -ENOMEM;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\ndev_err(&pdev->dev, "no io memory resource defined!\n");\r\nerr = -ENODEV;\r\ngoto err_get_res;\r\n}\r\nsharpsl->io = ioremap(r->start, resource_size(r));\r\nif (!sharpsl->io) {\r\ndev_err(&pdev->dev, "ioremap to access Sharp SL NAND chip failed\n");\r\nerr = -EIO;\r\ngoto err_ioremap;\r\n}\r\nthis = (struct nand_chip *)(&sharpsl->chip);\r\nmtd = nand_to_mtd(this);\r\nmtd->dev.parent = &pdev->dev;\r\nmtd_set_ooblayout(mtd, data->ecc_layout);\r\nplatform_set_drvdata(pdev, sharpsl);\r\nwriteb(readb(sharpsl->io + FLASHCTL) | FLWP, sharpsl->io + FLASHCTL);\r\nthis->IO_ADDR_R = sharpsl->io + FLASHIO;\r\nthis->IO_ADDR_W = sharpsl->io + FLASHIO;\r\nthis->cmd_ctrl = sharpsl_nand_hwcontrol;\r\nthis->dev_ready = sharpsl_nand_dev_ready;\r\nthis->chip_delay = 15;\r\nthis->ecc.mode = NAND_ECC_HW;\r\nthis->ecc.size = 256;\r\nthis->ecc.bytes = 3;\r\nthis->ecc.strength = 1;\r\nthis->badblock_pattern = data->badblock_pattern;\r\nthis->ecc.hwctl = sharpsl_nand_enable_hwecc;\r\nthis->ecc.calculate = sharpsl_nand_calculate_ecc;\r\nthis->ecc.correct = nand_correct_data;\r\nerr = nand_scan(mtd, 1);\r\nif (err)\r\ngoto err_scan;\r\nmtd->name = "sharpsl-nand";\r\nerr = mtd_device_parse_register(mtd, NULL, NULL,\r\ndata->partitions, data->nr_partitions);\r\nif (err)\r\ngoto err_add;\r\nreturn 0;\r\nerr_add:\r\nnand_release(mtd);\r\nerr_scan:\r\niounmap(sharpsl->io);\r\nerr_ioremap:\r\nerr_get_res:\r\nkfree(sharpsl);\r\nreturn err;\r\n}\r\nstatic int sharpsl_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct sharpsl_nand *sharpsl = platform_get_drvdata(pdev);\r\nnand_release(nand_to_mtd(&sharpsl->chip));\r\niounmap(sharpsl->io);\r\nkfree(sharpsl);\r\nreturn 0;\r\n}
