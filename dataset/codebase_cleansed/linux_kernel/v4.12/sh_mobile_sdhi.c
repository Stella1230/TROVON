static void sh_mobile_sdhi_sdbuf_width(struct tmio_mmc_host *host, int width)\r\n{\r\nu32 val;\r\nswitch (sd_ctrl_read16(host, CTL_VERSION)) {\r\ncase SDHI_VER_GEN2_SDR50:\r\nval = (width == 32) ? 0x0001 : 0x0000;\r\nbreak;\r\ncase SDHI_VER_GEN2_SDR104:\r\nval = (width == 32) ? 0x0000 : 0x0001;\r\nbreak;\r\ncase SDHI_VER_GEN3_SD:\r\ncase SDHI_VER_GEN3_SDMMC:\r\nif (width == 64)\r\nval = 0x0000;\r\nelse if (width == 32)\r\nval = 0x0101;\r\nelse\r\nval = 0x0001;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nsd_ctrl_write16(host, EXT_ACC, val);\r\n}\r\nstatic int sh_mobile_sdhi_clk_enable(struct tmio_mmc_host *host)\r\n{\r\nstruct mmc_host *mmc = host->mmc;\r\nstruct sh_mobile_sdhi *priv = host_to_priv(host);\r\nint ret = clk_prepare_enable(priv->clk);\r\nif (ret < 0)\r\nreturn ret;\r\nret = clk_prepare_enable(priv->clk_cd);\r\nif (ret < 0) {\r\nclk_disable_unprepare(priv->clk);\r\nreturn ret;\r\n}\r\nif (!mmc->f_max)\r\nmmc->f_max = clk_get_rate(priv->clk);\r\nmmc->f_min = max(clk_round_rate(priv->clk, 1) / 512, 1L);\r\nsh_mobile_sdhi_sdbuf_width(host, 16);\r\nreturn 0;\r\n}\r\nstatic unsigned int sh_mobile_sdhi_clk_update(struct tmio_mmc_host *host,\r\nunsigned int new_clock)\r\n{\r\nstruct sh_mobile_sdhi *priv = host_to_priv(host);\r\nunsigned int freq, diff, best_freq = 0, diff_min = ~0;\r\nint i, ret;\r\nif (!(host->pdata->flags & TMIO_MMC_MIN_RCAR2))\r\nreturn clk_get_rate(priv->clk);\r\nfor (i = min(9, ilog2(UINT_MAX / new_clock)); i >= 0; i--) {\r\nfreq = clk_round_rate(priv->clk, new_clock << i);\r\nif (freq > (new_clock << i)) {\r\nfreq = clk_round_rate(priv->clk,\r\n(new_clock << i) / 4 * 3);\r\nif (freq > (new_clock << i))\r\ncontinue;\r\n}\r\ndiff = new_clock - (freq >> i);\r\nif (diff <= diff_min) {\r\nbest_freq = freq;\r\ndiff_min = diff;\r\n}\r\n}\r\nret = clk_set_rate(priv->clk, best_freq);\r\nreturn ret == 0 ? best_freq : clk_get_rate(priv->clk);\r\n}\r\nstatic void sh_mobile_sdhi_clk_disable(struct tmio_mmc_host *host)\r\n{\r\nstruct sh_mobile_sdhi *priv = host_to_priv(host);\r\nclk_disable_unprepare(priv->clk);\r\nclk_disable_unprepare(priv->clk_cd);\r\n}\r\nstatic int sh_mobile_sdhi_card_busy(struct mmc_host *mmc)\r\n{\r\nstruct tmio_mmc_host *host = mmc_priv(mmc);\r\nreturn !(sd_ctrl_read16_and_16_as_32(host, CTL_STATUS) & TMIO_STAT_DAT0);\r\n}\r\nstatic int sh_mobile_sdhi_start_signal_voltage_switch(struct mmc_host *mmc,\r\nstruct mmc_ios *ios)\r\n{\r\nstruct tmio_mmc_host *host = mmc_priv(mmc);\r\nstruct sh_mobile_sdhi *priv = host_to_priv(host);\r\nstruct pinctrl_state *pin_state;\r\nint ret;\r\nswitch (ios->signal_voltage) {\r\ncase MMC_SIGNAL_VOLTAGE_330:\r\npin_state = priv->pins_default;\r\nbreak;\r\ncase MMC_SIGNAL_VOLTAGE_180:\r\npin_state = priv->pins_uhs;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (IS_ERR(priv->pinctrl) || IS_ERR(pin_state))\r\nreturn ios->signal_voltage ==\r\nMMC_SIGNAL_VOLTAGE_330 ? 0 : -EINVAL;\r\nret = mmc_regulator_set_vqmmc(host->mmc, ios);\r\nif (ret)\r\nreturn ret;\r\nreturn pinctrl_select_state(priv->pinctrl, pin_state);\r\n}\r\nstatic inline u32 sd_scc_read32(struct tmio_mmc_host *host,\r\nstruct sh_mobile_sdhi *priv, int addr)\r\n{\r\nreturn readl(priv->scc_ctl + (addr << host->bus_shift));\r\n}\r\nstatic inline void sd_scc_write32(struct tmio_mmc_host *host,\r\nstruct sh_mobile_sdhi *priv,\r\nint addr, u32 val)\r\n{\r\nwritel(val, priv->scc_ctl + (addr << host->bus_shift));\r\n}\r\nstatic unsigned int sh_mobile_sdhi_init_tuning(struct tmio_mmc_host *host)\r\n{\r\nstruct sh_mobile_sdhi *priv;\r\npriv = host_to_priv(host);\r\nsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_DTCNTL,\r\n0x8 << SH_MOBILE_SDHI_SCC_DTCNTL_TAPNUM_SHIFT);\r\nsd_ctrl_write32_as_16_and_16(host, CTL_STATUS, 0x0);\r\nsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_DTCNTL,\r\nSH_MOBILE_SDHI_SCC_DTCNTL_TAPEN |\r\nsd_scc_read32(host, priv, SH_MOBILE_SDHI_SCC_DTCNTL));\r\nsd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, ~CLK_CTL_SCLKEN &\r\nsd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL));\r\nsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_CKSEL,\r\nSH_MOBILE_SDHI_SCC_CKSEL_DTSEL |\r\nsd_scc_read32(host, priv, SH_MOBILE_SDHI_SCC_CKSEL));\r\nsd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, CLK_CTL_SCLKEN |\r\nsd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL));\r\nsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_RVSCNTL,\r\n~SH_MOBILE_SDHI_SCC_RVSCNTL_RVSEN &\r\nsd_scc_read32(host, priv, SH_MOBILE_SDHI_SCC_RVSCNTL));\r\nsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_DT2FF, host->scc_tappos);\r\nreturn (sd_scc_read32(host, priv, SH_MOBILE_SDHI_SCC_DTCNTL) >>\r\nSH_MOBILE_SDHI_SCC_DTCNTL_TAPNUM_SHIFT) &\r\nSH_MOBILE_SDHI_SCC_DTCNTL_TAPNUM_MASK;\r\n}\r\nstatic void sh_mobile_sdhi_prepare_tuning(struct tmio_mmc_host *host,\r\nunsigned long tap)\r\n{\r\nstruct sh_mobile_sdhi *priv = host_to_priv(host);\r\nsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_TAPSET, tap);\r\n}\r\nstatic int sh_mobile_sdhi_select_tuning(struct tmio_mmc_host *host)\r\n{\r\nstruct sh_mobile_sdhi *priv = host_to_priv(host);\r\nunsigned long tap_cnt;\r\nunsigned long tap_set;\r\nunsigned long tap_start;\r\nunsigned long tap_end;\r\nunsigned long ntap;\r\nunsigned long i;\r\nsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_RVSREQ, 0);\r\ntap_cnt = 0;\r\nntap = 0;\r\ntap_start = 0;\r\ntap_end = 0;\r\nfor (i = 0; i < host->tap_num * 2; i++) {\r\nif (test_bit(i, host->taps))\r\nntap++;\r\nelse {\r\nif (ntap > tap_cnt) {\r\ntap_start = i - ntap;\r\ntap_end = i - 1;\r\ntap_cnt = ntap;\r\n}\r\nntap = 0;\r\n}\r\n}\r\nif (ntap > tap_cnt) {\r\ntap_start = i - ntap;\r\ntap_end = i - 1;\r\ntap_cnt = ntap;\r\n}\r\nif (tap_cnt >= SH_MOBILE_SDHI_MAX_TAP)\r\ntap_set = (tap_start + tap_end) / 2 % host->tap_num;\r\nelse\r\nreturn -EIO;\r\nsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_TAPSET, tap_set);\r\nsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_RVSCNTL,\r\nSH_MOBILE_SDHI_SCC_RVSCNTL_RVSEN |\r\nsd_scc_read32(host, priv, SH_MOBILE_SDHI_SCC_RVSCNTL));\r\nreturn 0;\r\n}\r\nstatic bool sh_mobile_sdhi_check_scc_error(struct tmio_mmc_host *host)\r\n{\r\nstruct sh_mobile_sdhi *priv = host_to_priv(host);\r\nif (sd_scc_read32(host, priv, SH_MOBILE_SDHI_SCC_RVSCNTL) &\r\nSH_MOBILE_SDHI_SCC_RVSCNTL_RVSEN &&\r\nsd_scc_read32(host, priv, SH_MOBILE_SDHI_SCC_RVSREQ) &\r\nSH_MOBILE_SDHI_SCC_RVSREQ_RVSERR) {\r\nsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_RVSREQ, 0);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void sh_mobile_sdhi_hw_reset(struct tmio_mmc_host *host)\r\n{\r\nstruct sh_mobile_sdhi *priv;\r\npriv = host_to_priv(host);\r\nsd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, ~CLK_CTL_SCLKEN &\r\nsd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL));\r\nsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_CKSEL,\r\n~SH_MOBILE_SDHI_SCC_CKSEL_DTSEL &\r\nsd_scc_read32(host, priv, SH_MOBILE_SDHI_SCC_CKSEL));\r\nsd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, CLK_CTL_SCLKEN |\r\nsd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL));\r\nsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_RVSCNTL,\r\n~SH_MOBILE_SDHI_SCC_RVSCNTL_RVSEN &\r\nsd_scc_read32(host, priv, SH_MOBILE_SDHI_SCC_RVSCNTL));\r\nsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_RVSCNTL,\r\n~SH_MOBILE_SDHI_SCC_RVSCNTL_RVSEN &\r\nsd_scc_read32(host, priv, SH_MOBILE_SDHI_SCC_RVSCNTL));\r\n}\r\nstatic int sh_mobile_sdhi_wait_idle(struct tmio_mmc_host *host)\r\n{\r\nint timeout = 1000;\r\nwhile (--timeout && !(sd_ctrl_read16_and_16_as_32(host, CTL_STATUS)\r\n& TMIO_STAT_SCLKDIVEN))\r\nudelay(1);\r\nif (!timeout) {\r\ndev_warn(&host->pdev->dev, "timeout waiting for SD bus idle\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_sdhi_write16_hook(struct tmio_mmc_host *host, int addr)\r\n{\r\nswitch (addr)\r\n{\r\ncase CTL_SD_CMD:\r\ncase CTL_STOP_INTERNAL_ACTION:\r\ncase CTL_XFER_BLK_COUNT:\r\ncase CTL_SD_CARD_CLK_CTL:\r\ncase CTL_SD_XFER_LEN:\r\ncase CTL_SD_MEM_CARD_OPT:\r\ncase CTL_TRANSACTION_CTL:\r\ncase CTL_DMA_ENABLE:\r\ncase EXT_ACC:\r\nreturn sh_mobile_sdhi_wait_idle(host);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_sdhi_multi_io_quirk(struct mmc_card *card,\r\nunsigned int direction, int blk_size)\r\n{\r\nif ((direction == MMC_DATA_READ) &&\r\nblk_size == 2)\r\nreturn 1;\r\nreturn blk_size;\r\n}\r\nstatic void sh_mobile_sdhi_enable_dma(struct tmio_mmc_host *host, bool enable)\r\n{\r\nsd_ctrl_write16(host, CTL_DMA_ENABLE, enable ? 2 : 0);\r\nsh_mobile_sdhi_sdbuf_width(host, enable ? 32 : 16);\r\n}\r\nstatic int sh_mobile_sdhi_probe(struct platform_device *pdev)\r\n{\r\nconst struct sh_mobile_sdhi_of_data *of_data = of_device_get_match_data(&pdev->dev);\r\nstruct sh_mobile_sdhi *priv;\r\nstruct tmio_mmc_data *mmc_data;\r\nstruct tmio_mmc_data *mmd = pdev->dev.platform_data;\r\nstruct tmio_mmc_host *host;\r\nstruct resource *res;\r\nint irq, ret, i;\r\nstruct tmio_mmc_dma *dma_priv;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -EINVAL;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(struct sh_mobile_sdhi), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nmmc_data = &priv->mmc_data;\r\ndma_priv = &priv->dma_priv;\r\npriv->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(priv->clk)) {\r\nret = PTR_ERR(priv->clk);\r\ndev_err(&pdev->dev, "cannot get clock: %d\n", ret);\r\ngoto eprobe;\r\n}\r\npriv->clk_cd = devm_clk_get(&pdev->dev, "cd");\r\nif (IS_ERR(priv->clk_cd))\r\npriv->clk_cd = NULL;\r\npriv->pinctrl = devm_pinctrl_get(&pdev->dev);\r\nif (!IS_ERR(priv->pinctrl)) {\r\npriv->pins_default = pinctrl_lookup_state(priv->pinctrl,\r\nPINCTRL_STATE_DEFAULT);\r\npriv->pins_uhs = pinctrl_lookup_state(priv->pinctrl,\r\n"state_uhs");\r\n}\r\nhost = tmio_mmc_host_alloc(pdev);\r\nif (!host) {\r\nret = -ENOMEM;\r\ngoto eprobe;\r\n}\r\nif (of_data) {\r\nmmc_data->flags |= of_data->tmio_flags;\r\nmmc_data->ocr_mask = of_data->tmio_ocr_mask;\r\nmmc_data->capabilities |= of_data->capabilities;\r\nmmc_data->capabilities2 |= of_data->capabilities2;\r\nmmc_data->dma_rx_offset = of_data->dma_rx_offset;\r\ndma_priv->dma_buswidth = of_data->dma_buswidth;\r\nhost->bus_shift = of_data->bus_shift;\r\n}\r\nhost->dma = dma_priv;\r\nhost->write16_hook = sh_mobile_sdhi_write16_hook;\r\nhost->clk_enable = sh_mobile_sdhi_clk_enable;\r\nhost->clk_update = sh_mobile_sdhi_clk_update;\r\nhost->clk_disable = sh_mobile_sdhi_clk_disable;\r\nhost->multi_io_quirk = sh_mobile_sdhi_multi_io_quirk;\r\nif (mmc_data->flags & TMIO_MMC_MIN_RCAR2) {\r\nhost->card_busy = sh_mobile_sdhi_card_busy;\r\nhost->start_signal_voltage_switch =\r\nsh_mobile_sdhi_start_signal_voltage_switch;\r\n}\r\nif (!host->bus_shift && resource_size(res) > 0x100)\r\nhost->bus_shift = 1;\r\nif (mmd)\r\n*mmc_data = *mmd;\r\ndma_priv->filter = shdma_chan_filter;\r\ndma_priv->enable = sh_mobile_sdhi_enable_dma;\r\nmmc_data->alignment_shift = 1;\r\nmmc_data->capabilities |= MMC_CAP_MMC_HIGHSPEED;\r\nmmc_data->flags |= TMIO_MMC_BLKSZ_2BYTES;\r\nmmc_data->flags |= TMIO_MMC_SDIO_IRQ;\r\nmmc_data->flags |= TMIO_MMC_HAVE_CMD12_CTRL;\r\nmmc_data->flags |= TMIO_MMC_SDIO_STATUS_SETBITS;\r\nret = tmio_mmc_host_probe(host, mmc_data);\r\nif (ret < 0)\r\ngoto efree;\r\nif (of_data && of_data->scc_offset &&\r\n(host->mmc->caps & MMC_CAP_UHS_SDR104 ||\r\nhost->mmc->caps2 & MMC_CAP2_HS200_1_8V_SDR)) {\r\nconst struct sh_mobile_sdhi_scc *taps = of_data->taps;\r\nbool hit = false;\r\nhost->mmc->caps |= MMC_CAP_HW_RESET;\r\nfor (i = 0; i < of_data->taps_num; i++) {\r\nif (taps[i].clk_rate == 0 ||\r\ntaps[i].clk_rate == host->mmc->f_max) {\r\nhost->scc_tappos = taps->tap;\r\nhit = true;\r\nbreak;\r\n}\r\n}\r\nif (!hit)\r\ndev_warn(&host->pdev->dev, "Unknown clock rate for SDR104\n");\r\npriv->scc_ctl = host->ctl + of_data->scc_offset;\r\nhost->init_tuning = sh_mobile_sdhi_init_tuning;\r\nhost->prepare_tuning = sh_mobile_sdhi_prepare_tuning;\r\nhost->select_tuning = sh_mobile_sdhi_select_tuning;\r\nhost->check_scc_error = sh_mobile_sdhi_check_scc_error;\r\nhost->hw_reset = sh_mobile_sdhi_hw_reset;\r\n}\r\ni = 0;\r\nwhile (1) {\r\nirq = platform_get_irq(pdev, i);\r\nif (irq < 0)\r\nbreak;\r\ni++;\r\nret = devm_request_irq(&pdev->dev, irq, tmio_mmc_irq, 0,\r\ndev_name(&pdev->dev), host);\r\nif (ret)\r\ngoto eirq;\r\n}\r\nif (!i) {\r\nret = irq;\r\ngoto eirq;\r\n}\r\ndev_info(&pdev->dev, "%s base at 0x%08lx max clock rate %u MHz\n",\r\nmmc_hostname(host->mmc), (unsigned long)\r\n(platform_get_resource(pdev, IORESOURCE_MEM, 0)->start),\r\nhost->mmc->f_max / 1000000);\r\nreturn ret;\r\neirq:\r\ntmio_mmc_host_remove(host);\r\nefree:\r\ntmio_mmc_host_free(host);\r\neprobe:\r\nreturn ret;\r\n}\r\nstatic int sh_mobile_sdhi_remove(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(pdev);\r\nstruct tmio_mmc_host *host = mmc_priv(mmc);\r\ntmio_mmc_host_remove(host);\r\nreturn 0;\r\n}
