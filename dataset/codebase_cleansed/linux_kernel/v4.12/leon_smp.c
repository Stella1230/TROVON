static inline unsigned long do_swap(volatile unsigned long *ptr,\r\nunsigned long val)\r\n{\r\n__asm__ __volatile__("swapa [%2] %3, %0\n\t" : "=&r"(val)\r\n: "0"(val), "r"(ptr), "i"(ASI_LEON_DCACHE_MISS)\r\n: "memory");\r\nreturn val;\r\n}\r\nvoid leon_cpu_pre_starting(void *arg)\r\n{\r\nleon_configure_cache_smp();\r\n}\r\nvoid leon_cpu_pre_online(void *arg)\r\n{\r\nint cpuid = hard_smp_processor_id();\r\ndo_swap(&cpu_callin_map[cpuid], 1);\r\nlocal_ops->cache_all();\r\nlocal_ops->tlb_all();\r\n__asm__ __volatile__("ld [%0], %%g6\n\t" : : "r"(&current_set[cpuid])\r\n: "memory" );\r\nmmgrab(&init_mm);\r\ncurrent->active_mm = &init_mm;\r\nwhile (!cpumask_test_cpu(cpuid, &smp_commenced_mask))\r\nmb();\r\n}\r\nvoid leon_configure_cache_smp(void)\r\n{\r\nunsigned long cfg = sparc_leon3_get_dcachecfg();\r\nint me = smp_processor_id();\r\nif (ASI_LEON3_SYSCTRL_CFG_SSIZE(cfg) > 4) {\r\nprintk(KERN_INFO "Note: SMP with snooping only works on 4k cache, found %dk(0x%x) on cpu %d, disabling caches\n",\r\n(unsigned int)ASI_LEON3_SYSCTRL_CFG_SSIZE(cfg),\r\n(unsigned int)cfg, (unsigned int)me);\r\nsparc_leon3_disable_cache();\r\n} else {\r\nif (cfg & ASI_LEON3_SYSCTRL_CFG_SNOOPING) {\r\nsparc_leon3_enable_snooping();\r\n} else {\r\nprintk(KERN_INFO "Note: You have to enable snooping in the vhdl model cpu %d, disabling caches\n",\r\nme);\r\nsparc_leon3_disable_cache();\r\n}\r\n}\r\nlocal_ops->cache_all();\r\nlocal_ops->tlb_all();\r\n}\r\nstatic void leon_smp_setbroadcast(unsigned int mask)\r\n{\r\nint broadcast =\r\n((LEON3_BYPASS_LOAD_PA(&(leon3_irqctrl_regs->mpstatus)) >>\r\nLEON3_IRQMPSTATUS_BROADCAST) & 1);\r\nif (!broadcast) {\r\nprom_printf("######## !!!! The irqmp-ctrl must have broadcast enabled, smp wont work !!!!! ####### nr cpus: %d\n",\r\nleon_smp_nrcpus());\r\nif (leon_smp_nrcpus() > 1) {\r\nBUG();\r\n} else {\r\nprom_printf("continue anyway\n");\r\nreturn;\r\n}\r\n}\r\nLEON_BYPASS_STORE_PA(&(leon3_irqctrl_regs->mpbroadcast), mask);\r\n}\r\nint leon_smp_nrcpus(void)\r\n{\r\nint nrcpu =\r\n((LEON3_BYPASS_LOAD_PA(&(leon3_irqctrl_regs->mpstatus)) >>\r\nLEON3_IRQMPSTATUS_CPUNR) & 0xf) + 1;\r\nreturn nrcpu;\r\n}\r\nvoid __init leon_boot_cpus(void)\r\n{\r\nint nrcpu = leon_smp_nrcpus();\r\nint me = smp_processor_id();\r\nleon_ipi_init();\r\nprintk(KERN_INFO "%d:(%d:%d) cpus mpirq at 0x%x\n", (unsigned int)me,\r\n(unsigned int)nrcpu, (unsigned int)NR_CPUS,\r\n(unsigned int)&(leon3_irqctrl_regs->mpstatus));\r\nleon_enable_irq_cpu(LEON3_IRQ_CROSS_CALL, me);\r\nleon_enable_irq_cpu(LEON3_IRQ_TICKER, me);\r\nleon_enable_irq_cpu(leon_ipi_irq, me);\r\nleon_smp_setbroadcast(1 << LEON3_IRQ_TICKER);\r\nleon_configure_cache_smp();\r\nlocal_ops->cache_all();\r\n}\r\nint leon_boot_one_cpu(int i, struct task_struct *idle)\r\n{\r\nint timeout;\r\ncurrent_set[i] = task_thread_info(idle);\r\nsmp_penguin_ctable.which_io = 0;\r\nsmp_penguin_ctable.phys_addr = (unsigned int)srmmu_ctx_table_phys;\r\nsmp_penguin_ctable.reg_size = 0;\r\nprintk(KERN_INFO "Starting CPU %d : (irqmp: 0x%x)\n", (unsigned int)i,\r\n(unsigned int)&leon3_irqctrl_regs->mpstatus);\r\nlocal_ops->cache_all();\r\nLEON_BYPASS_STORE_PA(&leon3_irqctrl_regs->mask[i], 0);\r\nLEON_BYPASS_STORE_PA(&(leon3_irqctrl_regs->mpstatus), 1 << i);\r\nfor (timeout = 0; timeout < 10000; timeout++) {\r\nif (cpu_callin_map[i])\r\nbreak;\r\nudelay(200);\r\n}\r\nprintk(KERN_INFO "Started CPU %d\n", (unsigned int)i);\r\nif (!(cpu_callin_map[i])) {\r\nprintk(KERN_ERR "Processor %d is stuck.\n", i);\r\nreturn -ENODEV;\r\n} else {\r\nleon_enable_irq_cpu(LEON3_IRQ_CROSS_CALL, i);\r\nleon_enable_irq_cpu(LEON3_IRQ_TICKER, i);\r\nleon_enable_irq_cpu(leon_ipi_irq, i);\r\n}\r\nlocal_ops->cache_all();\r\nreturn 0;\r\n}\r\nvoid __init leon_smp_done(void)\r\n{\r\nint i, first;\r\nint *prev;\r\nfirst = 0;\r\nprev = &first;\r\nfor (i = 0; i < NR_CPUS; i++) {\r\nif (cpu_online(i)) {\r\n*prev = i;\r\nprev = &cpu_data(i).next;\r\n}\r\n}\r\n*prev = first;\r\nlocal_ops->cache_all();\r\nif (!cpu_present(1)) {\r\nfree_reserved_page(virt_to_page(&trapbase_cpu1));\r\n}\r\nif (!cpu_present(2)) {\r\nfree_reserved_page(virt_to_page(&trapbase_cpu2));\r\n}\r\nif (!cpu_present(3)) {\r\nfree_reserved_page(virt_to_page(&trapbase_cpu3));\r\n}\r\nsmp_processors_ready = 1;\r\n}\r\nstatic void __init leon_ipi_init(void)\r\n{\r\nint cpu, len;\r\nstruct leon_ipi_work *work;\r\nstruct property *pp;\r\nstruct device_node *rootnp;\r\nstruct tt_entry *trap_table;\r\nunsigned long flags;\r\nrootnp = of_find_node_by_path("/ambapp0");\r\nif (rootnp) {\r\npp = of_find_property(rootnp, "ipi_num", &len);\r\nif (pp && (*(int *)pp->value))\r\nleon_ipi_irq = *(int *)pp->value;\r\n}\r\nprintk(KERN_INFO "leon: SMP IPIs at IRQ %d\n", leon_ipi_irq);\r\nlocal_irq_save(flags);\r\ntrap_table = &sparc_ttable[SP_TRAP_IRQ1 + (leon_ipi_irq - 1)];\r\ntrap_table->inst_three += smpleon_ipi - real_irq_entry;\r\nlocal_ops->cache_all();\r\nlocal_irq_restore(flags);\r\nfor_each_possible_cpu(cpu) {\r\nwork = &per_cpu(leon_ipi_work, cpu);\r\nwork->single = work->msk = work->resched = 0;\r\n}\r\n}\r\nstatic void leon_send_ipi(int cpu, int level)\r\n{\r\nunsigned long mask;\r\nmask = leon_get_irqmask(level);\r\nLEON3_BYPASS_STORE_PA(&leon3_irqctrl_regs->force[cpu], mask);\r\n}\r\nstatic void leon_ipi_single(int cpu)\r\n{\r\nstruct leon_ipi_work *work = &per_cpu(leon_ipi_work, cpu);\r\nwork->single = 1;\r\nleon_send_ipi(cpu, leon_ipi_irq);\r\n}\r\nstatic void leon_ipi_mask_one(int cpu)\r\n{\r\nstruct leon_ipi_work *work = &per_cpu(leon_ipi_work, cpu);\r\nwork->msk = 1;\r\nleon_send_ipi(cpu, leon_ipi_irq);\r\n}\r\nstatic void leon_ipi_resched(int cpu)\r\n{\r\nstruct leon_ipi_work *work = &per_cpu(leon_ipi_work, cpu);\r\nwork->resched = 1;\r\nleon_send_ipi(cpu, leon_ipi_irq);\r\n}\r\nvoid leonsmp_ipi_interrupt(void)\r\n{\r\nstruct leon_ipi_work *work = this_cpu_ptr(&leon_ipi_work);\r\nif (work->single) {\r\nwork->single = 0;\r\nsmp_call_function_single_interrupt();\r\n}\r\nif (work->msk) {\r\nwork->msk = 0;\r\nsmp_call_function_interrupt();\r\n}\r\nif (work->resched) {\r\nwork->resched = 0;\r\nsmp_resched_interrupt();\r\n}\r\n}\r\nstatic void leon_cross_call(smpfunc_t func, cpumask_t mask, unsigned long arg1,\r\nunsigned long arg2, unsigned long arg3,\r\nunsigned long arg4)\r\n{\r\nif (smp_processors_ready) {\r\nregister int high = NR_CPUS - 1;\r\nunsigned long flags;\r\nspin_lock_irqsave(&cross_call_lock, flags);\r\n{\r\nregister smpfunc_t f asm("i0") = func;\r\nregister unsigned long a1 asm("i1") = arg1;\r\nregister unsigned long a2 asm("i2") = arg2;\r\nregister unsigned long a3 asm("i3") = arg3;\r\nregister unsigned long a4 asm("i4") = arg4;\r\nregister unsigned long a5 asm("i5") = 0;\r\n__asm__ __volatile__("std %0, [%6]\n\t"\r\n"std %2, [%6 + 8]\n\t"\r\n"std %4, [%6 + 16]\n\t" : :\r\n"r"(f), "r"(a1), "r"(a2), "r"(a3),\r\n"r"(a4), "r"(a5),\r\n"r"(&ccall_info.func));\r\n}\r\n{\r\nregister int i;\r\ncpumask_clear_cpu(smp_processor_id(), &mask);\r\ncpumask_and(&mask, cpu_online_mask, &mask);\r\nfor (i = 0; i <= high; i++) {\r\nif (cpumask_test_cpu(i, &mask)) {\r\nccall_info.processors_in[i] = 0;\r\nccall_info.processors_out[i] = 0;\r\nleon_send_ipi(i, LEON3_IRQ_CROSS_CALL);\r\n}\r\n}\r\n}\r\n{\r\nregister int i;\r\ni = 0;\r\ndo {\r\nif (!cpumask_test_cpu(i, &mask))\r\ncontinue;\r\nwhile (!ccall_info.processors_in[i])\r\nbarrier();\r\n} while (++i <= high);\r\ni = 0;\r\ndo {\r\nif (!cpumask_test_cpu(i, &mask))\r\ncontinue;\r\nwhile (!ccall_info.processors_out[i])\r\nbarrier();\r\n} while (++i <= high);\r\n}\r\nspin_unlock_irqrestore(&cross_call_lock, flags);\r\n}\r\n}\r\nvoid leon_cross_call_irq(void)\r\n{\r\nint i = smp_processor_id();\r\nccall_info.processors_in[i] = 1;\r\nccall_info.func(ccall_info.arg1, ccall_info.arg2, ccall_info.arg3,\r\nccall_info.arg4, ccall_info.arg5);\r\nccall_info.processors_out[i] = 1;\r\n}\r\nvoid __init leon_init_smp(void)\r\n{\r\nt_nmi[1] = t_nmi[1] + (linux_trap_ipi15_leon - linux_trap_ipi15_sun4m);\r\nsparc32_ipi_ops = &leon_ipi_ops;\r\n}
