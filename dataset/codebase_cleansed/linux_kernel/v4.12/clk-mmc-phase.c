static unsigned long rockchip_mmc_recalc(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nreturn parent_rate / RK3288_MMC_CLKGEN_DIV;\r\n}\r\nstatic int rockchip_mmc_get_phase(struct clk_hw *hw)\r\n{\r\nstruct rockchip_mmc_clock *mmc_clock = to_mmc_clock(hw);\r\nunsigned long rate = clk_get_rate(hw->clk);\r\nu32 raw_value;\r\nu16 degrees;\r\nu32 delay_num = 0;\r\nraw_value = readl(mmc_clock->reg) >> (mmc_clock->shift);\r\ndegrees = (raw_value & ROCKCHIP_MMC_DEGREE_MASK) * 90;\r\nif (raw_value & ROCKCHIP_MMC_DELAY_SEL) {\r\nunsigned long factor = (ROCKCHIP_MMC_DELAY_ELEMENT_PSEC / 10) *\r\n36 * (rate / 1000000);\r\ndelay_num = (raw_value & ROCKCHIP_MMC_DELAYNUM_MASK);\r\ndelay_num >>= ROCKCHIP_MMC_DELAYNUM_OFFSET;\r\ndegrees += DIV_ROUND_CLOSEST(delay_num * factor, 10000);\r\n}\r\nreturn degrees % 360;\r\n}\r\nstatic int rockchip_mmc_set_phase(struct clk_hw *hw, int degrees)\r\n{\r\nstruct rockchip_mmc_clock *mmc_clock = to_mmc_clock(hw);\r\nunsigned long rate = clk_get_rate(hw->clk);\r\nu8 nineties, remainder;\r\nu8 delay_num;\r\nu32 raw_value;\r\nu32 delay;\r\nnineties = degrees / 90;\r\nremainder = (degrees % 90);\r\ndelay = 10000000;\r\ndelay *= remainder;\r\ndelay = DIV_ROUND_CLOSEST(delay,\r\n(rate / 1000) * 36 *\r\n(ROCKCHIP_MMC_DELAY_ELEMENT_PSEC / 10));\r\ndelay_num = (u8) min_t(u32, delay, 255);\r\nraw_value = delay_num ? ROCKCHIP_MMC_DELAY_SEL : 0;\r\nraw_value |= delay_num << ROCKCHIP_MMC_DELAYNUM_OFFSET;\r\nraw_value |= nineties;\r\nwritel(HIWORD_UPDATE(raw_value, 0x07ff, mmc_clock->shift),\r\nmmc_clock->reg);\r\npr_debug("%s->set_phase(%d) delay_nums=%u reg[0x%p]=0x%03x actual_degrees=%d\n",\r\nclk_hw_get_name(hw), degrees, delay_num,\r\nmmc_clock->reg, raw_value>>(mmc_clock->shift),\r\nrockchip_mmc_get_phase(hw)\r\n);\r\nreturn 0;\r\n}\r\nstruct clk *rockchip_clk_register_mmc(const char *name,\r\nconst char *const *parent_names, u8 num_parents,\r\nvoid __iomem *reg, int shift)\r\n{\r\nstruct clk_init_data init;\r\nstruct rockchip_mmc_clock *mmc_clock;\r\nstruct clk *clk;\r\nmmc_clock = kmalloc(sizeof(*mmc_clock), GFP_KERNEL);\r\nif (!mmc_clock)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.flags = 0;\r\ninit.num_parents = num_parents;\r\ninit.parent_names = parent_names;\r\ninit.ops = &rockchip_mmc_clk_ops;\r\nmmc_clock->hw.init = &init;\r\nmmc_clock->reg = reg;\r\nmmc_clock->shift = shift;\r\nclk = clk_register(NULL, &mmc_clock->hw);\r\nif (IS_ERR(clk))\r\nkfree(mmc_clock);\r\nreturn clk;\r\n}
