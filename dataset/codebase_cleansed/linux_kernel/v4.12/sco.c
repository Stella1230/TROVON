static void sco_sock_timeout(unsigned long arg)\r\n{\r\nstruct sock *sk = (struct sock *)arg;\r\nBT_DBG("sock %p state %d", sk, sk->sk_state);\r\nbh_lock_sock(sk);\r\nsk->sk_err = ETIMEDOUT;\r\nsk->sk_state_change(sk);\r\nbh_unlock_sock(sk);\r\nsco_sock_kill(sk);\r\nsock_put(sk);\r\n}\r\nstatic void sco_sock_set_timer(struct sock *sk, long timeout)\r\n{\r\nBT_DBG("sock %p state %d timeout %ld", sk, sk->sk_state, timeout);\r\nsk_reset_timer(sk, &sk->sk_timer, jiffies + timeout);\r\n}\r\nstatic void sco_sock_clear_timer(struct sock *sk)\r\n{\r\nBT_DBG("sock %p state %d", sk, sk->sk_state);\r\nsk_stop_timer(sk, &sk->sk_timer);\r\n}\r\nstatic struct sco_conn *sco_conn_add(struct hci_conn *hcon)\r\n{\r\nstruct hci_dev *hdev = hcon->hdev;\r\nstruct sco_conn *conn = hcon->sco_data;\r\nif (conn)\r\nreturn conn;\r\nconn = kzalloc(sizeof(struct sco_conn), GFP_KERNEL);\r\nif (!conn)\r\nreturn NULL;\r\nspin_lock_init(&conn->lock);\r\nhcon->sco_data = conn;\r\nconn->hcon = hcon;\r\nif (hdev->sco_mtu > 0)\r\nconn->mtu = hdev->sco_mtu;\r\nelse\r\nconn->mtu = 60;\r\nBT_DBG("hcon %p conn %p", hcon, conn);\r\nreturn conn;\r\n}\r\nstatic void sco_chan_del(struct sock *sk, int err)\r\n{\r\nstruct sco_conn *conn;\r\nconn = sco_pi(sk)->conn;\r\nBT_DBG("sk %p, conn %p, err %d", sk, conn, err);\r\nif (conn) {\r\nsco_conn_lock(conn);\r\nconn->sk = NULL;\r\nsco_pi(sk)->conn = NULL;\r\nsco_conn_unlock(conn);\r\nif (conn->hcon)\r\nhci_conn_drop(conn->hcon);\r\n}\r\nsk->sk_state = BT_CLOSED;\r\nsk->sk_err = err;\r\nsk->sk_state_change(sk);\r\nsock_set_flag(sk, SOCK_ZAPPED);\r\n}\r\nstatic void sco_conn_del(struct hci_conn *hcon, int err)\r\n{\r\nstruct sco_conn *conn = hcon->sco_data;\r\nstruct sock *sk;\r\nif (!conn)\r\nreturn;\r\nBT_DBG("hcon %p conn %p, err %d", hcon, conn, err);\r\nsco_conn_lock(conn);\r\nsk = conn->sk;\r\nsco_conn_unlock(conn);\r\nif (sk) {\r\nsock_hold(sk);\r\nbh_lock_sock(sk);\r\nsco_sock_clear_timer(sk);\r\nsco_chan_del(sk, err);\r\nbh_unlock_sock(sk);\r\nsco_sock_kill(sk);\r\nsock_put(sk);\r\n}\r\nhcon->sco_data = NULL;\r\nkfree(conn);\r\n}\r\nstatic void __sco_chan_add(struct sco_conn *conn, struct sock *sk,\r\nstruct sock *parent)\r\n{\r\nBT_DBG("conn %p", conn);\r\nsco_pi(sk)->conn = conn;\r\nconn->sk = sk;\r\nif (parent)\r\nbt_accept_enqueue(parent, sk);\r\n}\r\nstatic int sco_chan_add(struct sco_conn *conn, struct sock *sk,\r\nstruct sock *parent)\r\n{\r\nint err = 0;\r\nsco_conn_lock(conn);\r\nif (conn->sk)\r\nerr = -EBUSY;\r\nelse\r\n__sco_chan_add(conn, sk, parent);\r\nsco_conn_unlock(conn);\r\nreturn err;\r\n}\r\nstatic int sco_connect(struct sock *sk)\r\n{\r\nstruct sco_conn *conn;\r\nstruct hci_conn *hcon;\r\nstruct hci_dev *hdev;\r\nint err, type;\r\nBT_DBG("%pMR -> %pMR", &sco_pi(sk)->src, &sco_pi(sk)->dst);\r\nhdev = hci_get_route(&sco_pi(sk)->dst, &sco_pi(sk)->src, BDADDR_BREDR);\r\nif (!hdev)\r\nreturn -EHOSTUNREACH;\r\nhci_dev_lock(hdev);\r\nif (lmp_esco_capable(hdev) && !disable_esco)\r\ntype = ESCO_LINK;\r\nelse\r\ntype = SCO_LINK;\r\nif (sco_pi(sk)->setting == BT_VOICE_TRANSPARENT &&\r\n(!lmp_transp_capable(hdev) || !lmp_esco_capable(hdev))) {\r\nerr = -EOPNOTSUPP;\r\ngoto done;\r\n}\r\nhcon = hci_connect_sco(hdev, type, &sco_pi(sk)->dst,\r\nsco_pi(sk)->setting);\r\nif (IS_ERR(hcon)) {\r\nerr = PTR_ERR(hcon);\r\ngoto done;\r\n}\r\nconn = sco_conn_add(hcon);\r\nif (!conn) {\r\nhci_conn_drop(hcon);\r\nerr = -ENOMEM;\r\ngoto done;\r\n}\r\nbacpy(&sco_pi(sk)->src, &hcon->src);\r\nerr = sco_chan_add(conn, sk, NULL);\r\nif (err)\r\ngoto done;\r\nif (hcon->state == BT_CONNECTED) {\r\nsco_sock_clear_timer(sk);\r\nsk->sk_state = BT_CONNECTED;\r\n} else {\r\nsk->sk_state = BT_CONNECT;\r\nsco_sock_set_timer(sk, sk->sk_sndtimeo);\r\n}\r\ndone:\r\nhci_dev_unlock(hdev);\r\nhci_dev_put(hdev);\r\nreturn err;\r\n}\r\nstatic int sco_send_frame(struct sock *sk, struct msghdr *msg, int len)\r\n{\r\nstruct sco_conn *conn = sco_pi(sk)->conn;\r\nstruct sk_buff *skb;\r\nint err;\r\nif (len > conn->mtu)\r\nreturn -EINVAL;\r\nBT_DBG("sk %p len %d", sk, len);\r\nskb = bt_skb_send_alloc(sk, len, msg->msg_flags & MSG_DONTWAIT, &err);\r\nif (!skb)\r\nreturn err;\r\nif (memcpy_from_msg(skb_put(skb, len), msg, len)) {\r\nkfree_skb(skb);\r\nreturn -EFAULT;\r\n}\r\nhci_send_sco(conn->hcon, skb);\r\nreturn len;\r\n}\r\nstatic void sco_recv_frame(struct sco_conn *conn, struct sk_buff *skb)\r\n{\r\nstruct sock *sk;\r\nsco_conn_lock(conn);\r\nsk = conn->sk;\r\nsco_conn_unlock(conn);\r\nif (!sk)\r\ngoto drop;\r\nBT_DBG("sk %p len %d", sk, skb->len);\r\nif (sk->sk_state != BT_CONNECTED)\r\ngoto drop;\r\nif (!sock_queue_rcv_skb(sk, skb))\r\nreturn;\r\ndrop:\r\nkfree_skb(skb);\r\n}\r\nstatic struct sock *__sco_get_sock_listen_by_addr(bdaddr_t *ba)\r\n{\r\nstruct sock *sk;\r\nsk_for_each(sk, &sco_sk_list.head) {\r\nif (sk->sk_state != BT_LISTEN)\r\ncontinue;\r\nif (!bacmp(&sco_pi(sk)->src, ba))\r\nreturn sk;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct sock *sco_get_sock_listen(bdaddr_t *src)\r\n{\r\nstruct sock *sk = NULL, *sk1 = NULL;\r\nread_lock(&sco_sk_list.lock);\r\nsk_for_each(sk, &sco_sk_list.head) {\r\nif (sk->sk_state != BT_LISTEN)\r\ncontinue;\r\nif (!bacmp(&sco_pi(sk)->src, src))\r\nbreak;\r\nif (!bacmp(&sco_pi(sk)->src, BDADDR_ANY))\r\nsk1 = sk;\r\n}\r\nread_unlock(&sco_sk_list.lock);\r\nreturn sk ? sk : sk1;\r\n}\r\nstatic void sco_sock_destruct(struct sock *sk)\r\n{\r\nBT_DBG("sk %p", sk);\r\nskb_queue_purge(&sk->sk_receive_queue);\r\nskb_queue_purge(&sk->sk_write_queue);\r\n}\r\nstatic void sco_sock_cleanup_listen(struct sock *parent)\r\n{\r\nstruct sock *sk;\r\nBT_DBG("parent %p", parent);\r\nwhile ((sk = bt_accept_dequeue(parent, NULL))) {\r\nsco_sock_close(sk);\r\nsco_sock_kill(sk);\r\n}\r\nparent->sk_state = BT_CLOSED;\r\nsock_set_flag(parent, SOCK_ZAPPED);\r\n}\r\nstatic void sco_sock_kill(struct sock *sk)\r\n{\r\nif (!sock_flag(sk, SOCK_ZAPPED) || sk->sk_socket)\r\nreturn;\r\nBT_DBG("sk %p state %d", sk, sk->sk_state);\r\nbt_sock_unlink(&sco_sk_list, sk);\r\nsock_set_flag(sk, SOCK_DEAD);\r\nsock_put(sk);\r\n}\r\nstatic void __sco_sock_close(struct sock *sk)\r\n{\r\nBT_DBG("sk %p state %d socket %p", sk, sk->sk_state, sk->sk_socket);\r\nswitch (sk->sk_state) {\r\ncase BT_LISTEN:\r\nsco_sock_cleanup_listen(sk);\r\nbreak;\r\ncase BT_CONNECTED:\r\ncase BT_CONFIG:\r\nif (sco_pi(sk)->conn->hcon) {\r\nsk->sk_state = BT_DISCONN;\r\nsco_sock_set_timer(sk, SCO_DISCONN_TIMEOUT);\r\nsco_conn_lock(sco_pi(sk)->conn);\r\nhci_conn_drop(sco_pi(sk)->conn->hcon);\r\nsco_pi(sk)->conn->hcon = NULL;\r\nsco_conn_unlock(sco_pi(sk)->conn);\r\n} else\r\nsco_chan_del(sk, ECONNRESET);\r\nbreak;\r\ncase BT_CONNECT2:\r\ncase BT_CONNECT:\r\ncase BT_DISCONN:\r\nsco_chan_del(sk, ECONNRESET);\r\nbreak;\r\ndefault:\r\nsock_set_flag(sk, SOCK_ZAPPED);\r\nbreak;\r\n}\r\n}\r\nstatic void sco_sock_close(struct sock *sk)\r\n{\r\nsco_sock_clear_timer(sk);\r\nlock_sock(sk);\r\n__sco_sock_close(sk);\r\nrelease_sock(sk);\r\nsco_sock_kill(sk);\r\n}\r\nstatic void sco_sock_init(struct sock *sk, struct sock *parent)\r\n{\r\nBT_DBG("sk %p", sk);\r\nif (parent) {\r\nsk->sk_type = parent->sk_type;\r\nbt_sk(sk)->flags = bt_sk(parent)->flags;\r\nsecurity_sk_clone(parent, sk);\r\n}\r\n}\r\nstatic struct sock *sco_sock_alloc(struct net *net, struct socket *sock,\r\nint proto, gfp_t prio, int kern)\r\n{\r\nstruct sock *sk;\r\nsk = sk_alloc(net, PF_BLUETOOTH, prio, &sco_proto, kern);\r\nif (!sk)\r\nreturn NULL;\r\nsock_init_data(sock, sk);\r\nINIT_LIST_HEAD(&bt_sk(sk)->accept_q);\r\nsk->sk_destruct = sco_sock_destruct;\r\nsk->sk_sndtimeo = SCO_CONN_TIMEOUT;\r\nsock_reset_flag(sk, SOCK_ZAPPED);\r\nsk->sk_protocol = proto;\r\nsk->sk_state = BT_OPEN;\r\nsco_pi(sk)->setting = BT_VOICE_CVSD_16BIT;\r\nsetup_timer(&sk->sk_timer, sco_sock_timeout, (unsigned long)sk);\r\nbt_sock_link(&sco_sk_list, sk);\r\nreturn sk;\r\n}\r\nstatic int sco_sock_create(struct net *net, struct socket *sock, int protocol,\r\nint kern)\r\n{\r\nstruct sock *sk;\r\nBT_DBG("sock %p", sock);\r\nsock->state = SS_UNCONNECTED;\r\nif (sock->type != SOCK_SEQPACKET)\r\nreturn -ESOCKTNOSUPPORT;\r\nsock->ops = &sco_sock_ops;\r\nsk = sco_sock_alloc(net, sock, protocol, GFP_ATOMIC, kern);\r\nif (!sk)\r\nreturn -ENOMEM;\r\nsco_sock_init(sk, NULL);\r\nreturn 0;\r\n}\r\nstatic int sco_sock_bind(struct socket *sock, struct sockaddr *addr,\r\nint addr_len)\r\n{\r\nstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\r\nstruct sock *sk = sock->sk;\r\nint err = 0;\r\nBT_DBG("sk %p %pMR", sk, &sa->sco_bdaddr);\r\nif (!addr || addr->sa_family != AF_BLUETOOTH)\r\nreturn -EINVAL;\r\nif (addr_len < sizeof(struct sockaddr_sco))\r\nreturn -EINVAL;\r\nlock_sock(sk);\r\nif (sk->sk_state != BT_OPEN) {\r\nerr = -EBADFD;\r\ngoto done;\r\n}\r\nif (sk->sk_type != SOCK_SEQPACKET) {\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\nbacpy(&sco_pi(sk)->src, &sa->sco_bdaddr);\r\nsk->sk_state = BT_BOUND;\r\ndone:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int sco_sock_connect(struct socket *sock, struct sockaddr *addr, int alen, int flags)\r\n{\r\nstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\r\nstruct sock *sk = sock->sk;\r\nint err;\r\nBT_DBG("sk %p", sk);\r\nif (alen < sizeof(struct sockaddr_sco) ||\r\naddr->sa_family != AF_BLUETOOTH)\r\nreturn -EINVAL;\r\nif (sk->sk_state != BT_OPEN && sk->sk_state != BT_BOUND)\r\nreturn -EBADFD;\r\nif (sk->sk_type != SOCK_SEQPACKET)\r\nreturn -EINVAL;\r\nlock_sock(sk);\r\nbacpy(&sco_pi(sk)->dst, &sa->sco_bdaddr);\r\nerr = sco_connect(sk);\r\nif (err)\r\ngoto done;\r\nerr = bt_sock_wait_state(sk, BT_CONNECTED,\r\nsock_sndtimeo(sk, flags & O_NONBLOCK));\r\ndone:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int sco_sock_listen(struct socket *sock, int backlog)\r\n{\r\nstruct sock *sk = sock->sk;\r\nbdaddr_t *src = &sco_pi(sk)->src;\r\nint err = 0;\r\nBT_DBG("sk %p backlog %d", sk, backlog);\r\nlock_sock(sk);\r\nif (sk->sk_state != BT_BOUND) {\r\nerr = -EBADFD;\r\ngoto done;\r\n}\r\nif (sk->sk_type != SOCK_SEQPACKET) {\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\nwrite_lock(&sco_sk_list.lock);\r\nif (__sco_get_sock_listen_by_addr(src)) {\r\nerr = -EADDRINUSE;\r\ngoto unlock;\r\n}\r\nsk->sk_max_ack_backlog = backlog;\r\nsk->sk_ack_backlog = 0;\r\nsk->sk_state = BT_LISTEN;\r\nunlock:\r\nwrite_unlock(&sco_sk_list.lock);\r\ndone:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int sco_sock_accept(struct socket *sock, struct socket *newsock,\r\nint flags, bool kern)\r\n{\r\nDEFINE_WAIT_FUNC(wait, woken_wake_function);\r\nstruct sock *sk = sock->sk, *ch;\r\nlong timeo;\r\nint err = 0;\r\nlock_sock(sk);\r\ntimeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);\r\nBT_DBG("sk %p timeo %ld", sk, timeo);\r\nadd_wait_queue_exclusive(sk_sleep(sk), &wait);\r\nwhile (1) {\r\nif (sk->sk_state != BT_LISTEN) {\r\nerr = -EBADFD;\r\nbreak;\r\n}\r\nch = bt_accept_dequeue(sk, newsock);\r\nif (ch)\r\nbreak;\r\nif (!timeo) {\r\nerr = -EAGAIN;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nerr = sock_intr_errno(timeo);\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\ntimeo = wait_woken(&wait, TASK_INTERRUPTIBLE, timeo);\r\nlock_sock(sk);\r\n}\r\nremove_wait_queue(sk_sleep(sk), &wait);\r\nif (err)\r\ngoto done;\r\nnewsock->state = SS_CONNECTED;\r\nBT_DBG("new socket %p", ch);\r\ndone:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int sco_sock_getname(struct socket *sock, struct sockaddr *addr,\r\nint *len, int peer)\r\n{\r\nstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\r\nstruct sock *sk = sock->sk;\r\nBT_DBG("sock %p, sk %p", sock, sk);\r\naddr->sa_family = AF_BLUETOOTH;\r\n*len = sizeof(struct sockaddr_sco);\r\nif (peer)\r\nbacpy(&sa->sco_bdaddr, &sco_pi(sk)->dst);\r\nelse\r\nbacpy(&sa->sco_bdaddr, &sco_pi(sk)->src);\r\nreturn 0;\r\n}\r\nstatic int sco_sock_sendmsg(struct socket *sock, struct msghdr *msg,\r\nsize_t len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint err;\r\nBT_DBG("sock %p, sk %p", sock, sk);\r\nerr = sock_error(sk);\r\nif (err)\r\nreturn err;\r\nif (msg->msg_flags & MSG_OOB)\r\nreturn -EOPNOTSUPP;\r\nlock_sock(sk);\r\nif (sk->sk_state == BT_CONNECTED)\r\nerr = sco_send_frame(sk, msg, len);\r\nelse\r\nerr = -ENOTCONN;\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic void sco_conn_defer_accept(struct hci_conn *conn, u16 setting)\r\n{\r\nstruct hci_dev *hdev = conn->hdev;\r\nBT_DBG("conn %p", conn);\r\nconn->state = BT_CONFIG;\r\nif (!lmp_esco_capable(hdev)) {\r\nstruct hci_cp_accept_conn_req cp;\r\nbacpy(&cp.bdaddr, &conn->dst);\r\ncp.role = 0x00;\r\nhci_send_cmd(hdev, HCI_OP_ACCEPT_CONN_REQ, sizeof(cp), &cp);\r\n} else {\r\nstruct hci_cp_accept_sync_conn_req cp;\r\nbacpy(&cp.bdaddr, &conn->dst);\r\ncp.pkt_type = cpu_to_le16(conn->pkt_type);\r\ncp.tx_bandwidth = cpu_to_le32(0x00001f40);\r\ncp.rx_bandwidth = cpu_to_le32(0x00001f40);\r\ncp.content_format = cpu_to_le16(setting);\r\nswitch (setting & SCO_AIRMODE_MASK) {\r\ncase SCO_AIRMODE_TRANSP:\r\nif (conn->pkt_type & ESCO_2EV3)\r\ncp.max_latency = cpu_to_le16(0x0008);\r\nelse\r\ncp.max_latency = cpu_to_le16(0x000D);\r\ncp.retrans_effort = 0x02;\r\nbreak;\r\ncase SCO_AIRMODE_CVSD:\r\ncp.max_latency = cpu_to_le16(0xffff);\r\ncp.retrans_effort = 0xff;\r\nbreak;\r\n}\r\nhci_send_cmd(hdev, HCI_OP_ACCEPT_SYNC_CONN_REQ,\r\nsizeof(cp), &cp);\r\n}\r\n}\r\nstatic int sco_sock_recvmsg(struct socket *sock, struct msghdr *msg,\r\nsize_t len, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct sco_pinfo *pi = sco_pi(sk);\r\nlock_sock(sk);\r\nif (sk->sk_state == BT_CONNECT2 &&\r\ntest_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\r\nsco_conn_defer_accept(pi->conn->hcon, pi->setting);\r\nsk->sk_state = BT_CONFIG;\r\nrelease_sock(sk);\r\nreturn 0;\r\n}\r\nrelease_sock(sk);\r\nreturn bt_sock_recvmsg(sock, msg, len, flags);\r\n}\r\nstatic int sco_sock_setsockopt(struct socket *sock, int level, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint len, err = 0;\r\nstruct bt_voice voice;\r\nu32 opt;\r\nBT_DBG("sk %p", sk);\r\nlock_sock(sk);\r\nswitch (optname) {\r\ncase BT_DEFER_SETUP:\r\nif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (get_user(opt, (u32 __user *) optval)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nif (opt)\r\nset_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\r\nelse\r\nclear_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\r\nbreak;\r\ncase BT_VOICE:\r\nif (sk->sk_state != BT_OPEN && sk->sk_state != BT_BOUND &&\r\nsk->sk_state != BT_CONNECT2) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nvoice.setting = sco_pi(sk)->setting;\r\nlen = min_t(unsigned int, sizeof(voice), optlen);\r\nif (copy_from_user((char *)&voice, optval, len)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nif (voice.setting != BT_VOICE_TRANSPARENT &&\r\nvoice.setting != BT_VOICE_CVSD_16BIT) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nsco_pi(sk)->setting = voice.setting;\r\nbreak;\r\ndefault:\r\nerr = -ENOPROTOOPT;\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int sco_sock_getsockopt_old(struct socket *sock, int optname,\r\nchar __user *optval, int __user *optlen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct sco_options opts;\r\nstruct sco_conninfo cinfo;\r\nint len, err = 0;\r\nBT_DBG("sk %p", sk);\r\nif (get_user(len, optlen))\r\nreturn -EFAULT;\r\nlock_sock(sk);\r\nswitch (optname) {\r\ncase SCO_OPTIONS:\r\nif (sk->sk_state != BT_CONNECTED &&\r\n!(sk->sk_state == BT_CONNECT2 &&\r\ntest_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags))) {\r\nerr = -ENOTCONN;\r\nbreak;\r\n}\r\nopts.mtu = sco_pi(sk)->conn->mtu;\r\nBT_DBG("mtu %d", opts.mtu);\r\nlen = min_t(unsigned int, len, sizeof(opts));\r\nif (copy_to_user(optval, (char *)&opts, len))\r\nerr = -EFAULT;\r\nbreak;\r\ncase SCO_CONNINFO:\r\nif (sk->sk_state != BT_CONNECTED &&\r\n!(sk->sk_state == BT_CONNECT2 &&\r\ntest_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags))) {\r\nerr = -ENOTCONN;\r\nbreak;\r\n}\r\nmemset(&cinfo, 0, sizeof(cinfo));\r\ncinfo.hci_handle = sco_pi(sk)->conn->hcon->handle;\r\nmemcpy(cinfo.dev_class, sco_pi(sk)->conn->hcon->dev_class, 3);\r\nlen = min_t(unsigned int, len, sizeof(cinfo));\r\nif (copy_to_user(optval, (char *)&cinfo, len))\r\nerr = -EFAULT;\r\nbreak;\r\ndefault:\r\nerr = -ENOPROTOOPT;\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int sco_sock_getsockopt(struct socket *sock, int level, int optname,\r\nchar __user *optval, int __user *optlen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint len, err = 0;\r\nstruct bt_voice voice;\r\nBT_DBG("sk %p", sk);\r\nif (level == SOL_SCO)\r\nreturn sco_sock_getsockopt_old(sock, optname, optval, optlen);\r\nif (get_user(len, optlen))\r\nreturn -EFAULT;\r\nlock_sock(sk);\r\nswitch (optname) {\r\ncase BT_DEFER_SETUP:\r\nif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),\r\n(u32 __user *)optval))\r\nerr = -EFAULT;\r\nbreak;\r\ncase BT_VOICE:\r\nvoice.setting = sco_pi(sk)->setting;\r\nlen = min_t(unsigned int, len, sizeof(voice));\r\nif (copy_to_user(optval, (char *)&voice, len))\r\nerr = -EFAULT;\r\nbreak;\r\ndefault:\r\nerr = -ENOPROTOOPT;\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int sco_sock_shutdown(struct socket *sock, int how)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint err = 0;\r\nBT_DBG("sock %p, sk %p", sock, sk);\r\nif (!sk)\r\nreturn 0;\r\nsock_hold(sk);\r\nlock_sock(sk);\r\nif (!sk->sk_shutdown) {\r\nsk->sk_shutdown = SHUTDOWN_MASK;\r\nsco_sock_clear_timer(sk);\r\n__sco_sock_close(sk);\r\nif (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime &&\r\n!(current->flags & PF_EXITING))\r\nerr = bt_sock_wait_state(sk, BT_CLOSED,\r\nsk->sk_lingertime);\r\n}\r\nrelease_sock(sk);\r\nsock_put(sk);\r\nreturn err;\r\n}\r\nstatic int sco_sock_release(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint err = 0;\r\nBT_DBG("sock %p, sk %p", sock, sk);\r\nif (!sk)\r\nreturn 0;\r\nsco_sock_close(sk);\r\nif (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime &&\r\n!(current->flags & PF_EXITING)) {\r\nlock_sock(sk);\r\nerr = bt_sock_wait_state(sk, BT_CLOSED, sk->sk_lingertime);\r\nrelease_sock(sk);\r\n}\r\nsock_orphan(sk);\r\nsco_sock_kill(sk);\r\nreturn err;\r\n}\r\nstatic void sco_conn_ready(struct sco_conn *conn)\r\n{\r\nstruct sock *parent;\r\nstruct sock *sk = conn->sk;\r\nBT_DBG("conn %p", conn);\r\nif (sk) {\r\nsco_sock_clear_timer(sk);\r\nbh_lock_sock(sk);\r\nsk->sk_state = BT_CONNECTED;\r\nsk->sk_state_change(sk);\r\nbh_unlock_sock(sk);\r\n} else {\r\nsco_conn_lock(conn);\r\nif (!conn->hcon) {\r\nsco_conn_unlock(conn);\r\nreturn;\r\n}\r\nparent = sco_get_sock_listen(&conn->hcon->src);\r\nif (!parent) {\r\nsco_conn_unlock(conn);\r\nreturn;\r\n}\r\nbh_lock_sock(parent);\r\nsk = sco_sock_alloc(sock_net(parent), NULL,\r\nBTPROTO_SCO, GFP_ATOMIC, 0);\r\nif (!sk) {\r\nbh_unlock_sock(parent);\r\nsco_conn_unlock(conn);\r\nreturn;\r\n}\r\nsco_sock_init(sk, parent);\r\nbacpy(&sco_pi(sk)->src, &conn->hcon->src);\r\nbacpy(&sco_pi(sk)->dst, &conn->hcon->dst);\r\nhci_conn_hold(conn->hcon);\r\n__sco_chan_add(conn, sk, parent);\r\nif (test_bit(BT_SK_DEFER_SETUP, &bt_sk(parent)->flags))\r\nsk->sk_state = BT_CONNECT2;\r\nelse\r\nsk->sk_state = BT_CONNECTED;\r\nparent->sk_data_ready(parent);\r\nbh_unlock_sock(parent);\r\nsco_conn_unlock(conn);\r\n}\r\n}\r\nint sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 *flags)\r\n{\r\nstruct sock *sk;\r\nint lm = 0;\r\nBT_DBG("hdev %s, bdaddr %pMR", hdev->name, bdaddr);\r\nread_lock(&sco_sk_list.lock);\r\nsk_for_each(sk, &sco_sk_list.head) {\r\nif (sk->sk_state != BT_LISTEN)\r\ncontinue;\r\nif (!bacmp(&sco_pi(sk)->src, &hdev->bdaddr) ||\r\n!bacmp(&sco_pi(sk)->src, BDADDR_ANY)) {\r\nlm |= HCI_LM_ACCEPT;\r\nif (test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags))\r\n*flags |= HCI_PROTO_DEFER;\r\nbreak;\r\n}\r\n}\r\nread_unlock(&sco_sk_list.lock);\r\nreturn lm;\r\n}\r\nstatic void sco_connect_cfm(struct hci_conn *hcon, __u8 status)\r\n{\r\nif (hcon->type != SCO_LINK && hcon->type != ESCO_LINK)\r\nreturn;\r\nBT_DBG("hcon %p bdaddr %pMR status %d", hcon, &hcon->dst, status);\r\nif (!status) {\r\nstruct sco_conn *conn;\r\nconn = sco_conn_add(hcon);\r\nif (conn)\r\nsco_conn_ready(conn);\r\n} else\r\nsco_conn_del(hcon, bt_to_errno(status));\r\n}\r\nstatic void sco_disconn_cfm(struct hci_conn *hcon, __u8 reason)\r\n{\r\nif (hcon->type != SCO_LINK && hcon->type != ESCO_LINK)\r\nreturn;\r\nBT_DBG("hcon %p reason %d", hcon, reason);\r\nsco_conn_del(hcon, bt_to_errno(reason));\r\n}\r\nvoid sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb)\r\n{\r\nstruct sco_conn *conn = hcon->sco_data;\r\nif (!conn)\r\ngoto drop;\r\nBT_DBG("conn %p len %d", conn, skb->len);\r\nif (skb->len) {\r\nsco_recv_frame(conn, skb);\r\nreturn;\r\n}\r\ndrop:\r\nkfree_skb(skb);\r\n}\r\nstatic int sco_debugfs_show(struct seq_file *f, void *p)\r\n{\r\nstruct sock *sk;\r\nread_lock(&sco_sk_list.lock);\r\nsk_for_each(sk, &sco_sk_list.head) {\r\nseq_printf(f, "%pMR %pMR %d\n", &sco_pi(sk)->src,\r\n&sco_pi(sk)->dst, sk->sk_state);\r\n}\r\nread_unlock(&sco_sk_list.lock);\r\nreturn 0;\r\n}\r\nstatic int sco_debugfs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, sco_debugfs_show, inode->i_private);\r\n}\r\nint __init sco_init(void)\r\n{\r\nint err;\r\nBUILD_BUG_ON(sizeof(struct sockaddr_sco) > sizeof(struct sockaddr));\r\nerr = proto_register(&sco_proto, 0);\r\nif (err < 0)\r\nreturn err;\r\nerr = bt_sock_register(BTPROTO_SCO, &sco_sock_family_ops);\r\nif (err < 0) {\r\nBT_ERR("SCO socket registration failed");\r\ngoto error;\r\n}\r\nerr = bt_procfs_init(&init_net, "sco", &sco_sk_list, NULL);\r\nif (err < 0) {\r\nBT_ERR("Failed to create SCO proc file");\r\nbt_sock_unregister(BTPROTO_SCO);\r\ngoto error;\r\n}\r\nBT_INFO("SCO socket layer initialized");\r\nhci_register_cb(&sco_cb);\r\nif (IS_ERR_OR_NULL(bt_debugfs))\r\nreturn 0;\r\nsco_debugfs = debugfs_create_file("sco", 0444, bt_debugfs,\r\nNULL, &sco_debugfs_fops);\r\nreturn 0;\r\nerror:\r\nproto_unregister(&sco_proto);\r\nreturn err;\r\n}\r\nvoid sco_exit(void)\r\n{\r\nbt_procfs_cleanup(&init_net, "sco");\r\ndebugfs_remove(sco_debugfs);\r\nhci_unregister_cb(&sco_cb);\r\nbt_sock_unregister(BTPROTO_SCO);\r\nproto_unregister(&sco_proto);\r\n}
