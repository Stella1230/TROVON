static struct clk_hw *uniphier_clk_register(struct device *dev,\r\nstruct regmap *regmap,\r\nconst struct uniphier_clk_data *data)\r\n{\r\nswitch (data->type) {\r\ncase UNIPHIER_CLK_TYPE_CPUGEAR:\r\nreturn uniphier_clk_register_cpugear(dev, regmap, data->name,\r\n&data->data.cpugear);\r\ncase UNIPHIER_CLK_TYPE_FIXED_FACTOR:\r\nreturn uniphier_clk_register_fixed_factor(dev, data->name,\r\n&data->data.factor);\r\ncase UNIPHIER_CLK_TYPE_FIXED_RATE:\r\nreturn uniphier_clk_register_fixed_rate(dev, data->name,\r\n&data->data.rate);\r\ncase UNIPHIER_CLK_TYPE_GATE:\r\nreturn uniphier_clk_register_gate(dev, regmap, data->name,\r\n&data->data.gate);\r\ncase UNIPHIER_CLK_TYPE_MUX:\r\nreturn uniphier_clk_register_mux(dev, regmap, data->name,\r\n&data->data.mux);\r\ndefault:\r\ndev_err(dev, "unsupported clock type\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n}\r\nstatic int uniphier_clk_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct clk_hw_onecell_data *hw_data;\r\nconst struct uniphier_clk_data *p, *data;\r\nstruct regmap *regmap;\r\nstruct device_node *parent;\r\nint clk_num = 0;\r\ndata = of_device_get_match_data(dev);\r\nif (WARN_ON(!data))\r\nreturn -EINVAL;\r\nparent = of_get_parent(dev->of_node);\r\nregmap = syscon_node_to_regmap(parent);\r\nof_node_put(parent);\r\nif (IS_ERR(regmap)) {\r\ndev_err(dev, "failed to get regmap (error %ld)\n",\r\nPTR_ERR(regmap));\r\nreturn PTR_ERR(regmap);\r\n}\r\nfor (p = data; p->name; p++)\r\nclk_num = max(clk_num, p->idx + 1);\r\nhw_data = devm_kzalloc(dev,\r\nsizeof(*hw_data) + clk_num * sizeof(struct clk_hw *),\r\nGFP_KERNEL);\r\nif (!hw_data)\r\nreturn -ENOMEM;\r\nhw_data->num = clk_num;\r\nwhile (--clk_num >= 0)\r\nhw_data->hws[clk_num] = ERR_PTR(-EINVAL);\r\nfor (p = data; p->name; p++) {\r\nstruct clk_hw *hw;\r\ndev_dbg(dev, "register %s (index=%d)\n", p->name, p->idx);\r\nhw = uniphier_clk_register(dev, regmap, p);\r\nif (WARN(IS_ERR(hw), "failed to register %s", p->name))\r\ncontinue;\r\nif (p->idx >= 0)\r\nhw_data->hws[p->idx] = hw;\r\n}\r\nreturn of_clk_add_hw_provider(dev->of_node, of_clk_hw_onecell_get,\r\nhw_data);\r\n}\r\nstatic int uniphier_clk_remove(struct platform_device *pdev)\r\n{\r\nof_clk_del_provider(pdev->dev.of_node);\r\nreturn 0;\r\n}
