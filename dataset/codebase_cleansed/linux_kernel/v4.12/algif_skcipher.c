static void skcipher_free_async_sgls(struct skcipher_async_req *sreq)\r\n{\r\nstruct skcipher_async_rsgl *rsgl, *tmp;\r\nstruct scatterlist *sgl;\r\nstruct scatterlist *sg;\r\nint i, n;\r\nlist_for_each_entry_safe(rsgl, tmp, &sreq->list, list) {\r\naf_alg_free_sg(&rsgl->sgl);\r\nif (rsgl != &sreq->first_sgl)\r\nkfree(rsgl);\r\n}\r\nsgl = sreq->tsg;\r\nn = sg_nents(sgl);\r\nfor_each_sg(sgl, sg, n, i)\r\nput_page(sg_page(sg));\r\nkfree(sreq->tsg);\r\n}\r\nstatic void skcipher_async_cb(struct crypto_async_request *req, int err)\r\n{\r\nstruct skcipher_async_req *sreq = req->data;\r\nstruct kiocb *iocb = sreq->iocb;\r\natomic_dec(sreq->inflight);\r\nskcipher_free_async_sgls(sreq);\r\nkzfree(sreq);\r\niocb->ki_complete(iocb, err, err);\r\n}\r\nstatic inline int skcipher_sndbuf(struct sock *sk)\r\n{\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct skcipher_ctx *ctx = ask->private;\r\nreturn max_t(int, max_t(int, sk->sk_sndbuf & PAGE_MASK, PAGE_SIZE) -\r\nctx->used, 0);\r\n}\r\nstatic inline bool skcipher_writable(struct sock *sk)\r\n{\r\nreturn PAGE_SIZE <= skcipher_sndbuf(sk);\r\n}\r\nstatic int skcipher_alloc_sgl(struct sock *sk)\r\n{\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct skcipher_ctx *ctx = ask->private;\r\nstruct skcipher_sg_list *sgl;\r\nstruct scatterlist *sg = NULL;\r\nsgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);\r\nif (!list_empty(&ctx->tsgl))\r\nsg = sgl->sg;\r\nif (!sg || sgl->cur >= MAX_SGL_ENTS) {\r\nsgl = sock_kmalloc(sk, sizeof(*sgl) +\r\nsizeof(sgl->sg[0]) * (MAX_SGL_ENTS + 1),\r\nGFP_KERNEL);\r\nif (!sgl)\r\nreturn -ENOMEM;\r\nsg_init_table(sgl->sg, MAX_SGL_ENTS + 1);\r\nsgl->cur = 0;\r\nif (sg)\r\nsg_chain(sg, MAX_SGL_ENTS + 1, sgl->sg);\r\nlist_add_tail(&sgl->list, &ctx->tsgl);\r\n}\r\nreturn 0;\r\n}\r\nstatic void skcipher_pull_sgl(struct sock *sk, size_t used, int put)\r\n{\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct skcipher_ctx *ctx = ask->private;\r\nstruct skcipher_sg_list *sgl;\r\nstruct scatterlist *sg;\r\nint i;\r\nwhile (!list_empty(&ctx->tsgl)) {\r\nsgl = list_first_entry(&ctx->tsgl, struct skcipher_sg_list,\r\nlist);\r\nsg = sgl->sg;\r\nfor (i = 0; i < sgl->cur; i++) {\r\nsize_t plen = min_t(size_t, used, sg[i].length);\r\nif (!sg_page(sg + i))\r\ncontinue;\r\nsg[i].length -= plen;\r\nsg[i].offset += plen;\r\nused -= plen;\r\nctx->used -= plen;\r\nif (sg[i].length)\r\nreturn;\r\nif (put)\r\nput_page(sg_page(sg + i));\r\nsg_assign_page(sg + i, NULL);\r\n}\r\nlist_del(&sgl->list);\r\nsock_kfree_s(sk, sgl,\r\nsizeof(*sgl) + sizeof(sgl->sg[0]) *\r\n(MAX_SGL_ENTS + 1));\r\n}\r\nif (!ctx->used)\r\nctx->merge = 0;\r\n}\r\nstatic void skcipher_free_sgl(struct sock *sk)\r\n{\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct skcipher_ctx *ctx = ask->private;\r\nskcipher_pull_sgl(sk, ctx->used, 1);\r\n}\r\nstatic int skcipher_wait_for_wmem(struct sock *sk, unsigned flags)\r\n{\r\nDEFINE_WAIT_FUNC(wait, woken_wake_function);\r\nint err = -ERESTARTSYS;\r\nlong timeout;\r\nif (flags & MSG_DONTWAIT)\r\nreturn -EAGAIN;\r\nsk_set_bit(SOCKWQ_ASYNC_NOSPACE, sk);\r\nadd_wait_queue(sk_sleep(sk), &wait);\r\nfor (;;) {\r\nif (signal_pending(current))\r\nbreak;\r\ntimeout = MAX_SCHEDULE_TIMEOUT;\r\nif (sk_wait_event(sk, &timeout, skcipher_writable(sk), &wait)) {\r\nerr = 0;\r\nbreak;\r\n}\r\n}\r\nremove_wait_queue(sk_sleep(sk), &wait);\r\nreturn err;\r\n}\r\nstatic void skcipher_wmem_wakeup(struct sock *sk)\r\n{\r\nstruct socket_wq *wq;\r\nif (!skcipher_writable(sk))\r\nreturn;\r\nrcu_read_lock();\r\nwq = rcu_dereference(sk->sk_wq);\r\nif (skwq_has_sleeper(wq))\r\nwake_up_interruptible_sync_poll(&wq->wait, POLLIN |\r\nPOLLRDNORM |\r\nPOLLRDBAND);\r\nsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);\r\nrcu_read_unlock();\r\n}\r\nstatic int skcipher_wait_for_data(struct sock *sk, unsigned flags)\r\n{\r\nDEFINE_WAIT_FUNC(wait, woken_wake_function);\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct skcipher_ctx *ctx = ask->private;\r\nlong timeout;\r\nint err = -ERESTARTSYS;\r\nif (flags & MSG_DONTWAIT) {\r\nreturn -EAGAIN;\r\n}\r\nsk_set_bit(SOCKWQ_ASYNC_WAITDATA, sk);\r\nadd_wait_queue(sk_sleep(sk), &wait);\r\nfor (;;) {\r\nif (signal_pending(current))\r\nbreak;\r\ntimeout = MAX_SCHEDULE_TIMEOUT;\r\nif (sk_wait_event(sk, &timeout, ctx->used, &wait)) {\r\nerr = 0;\r\nbreak;\r\n}\r\n}\r\nremove_wait_queue(sk_sleep(sk), &wait);\r\nsk_clear_bit(SOCKWQ_ASYNC_WAITDATA, sk);\r\nreturn err;\r\n}\r\nstatic void skcipher_data_wakeup(struct sock *sk)\r\n{\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct skcipher_ctx *ctx = ask->private;\r\nstruct socket_wq *wq;\r\nif (!ctx->used)\r\nreturn;\r\nrcu_read_lock();\r\nwq = rcu_dereference(sk->sk_wq);\r\nif (skwq_has_sleeper(wq))\r\nwake_up_interruptible_sync_poll(&wq->wait, POLLOUT |\r\nPOLLRDNORM |\r\nPOLLRDBAND);\r\nsk_wake_async(sk, SOCK_WAKE_SPACE, POLL_OUT);\r\nrcu_read_unlock();\r\n}\r\nstatic int skcipher_sendmsg(struct socket *sock, struct msghdr *msg,\r\nsize_t size)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct sock *psk = ask->parent;\r\nstruct alg_sock *pask = alg_sk(psk);\r\nstruct skcipher_ctx *ctx = ask->private;\r\nstruct skcipher_tfm *skc = pask->private;\r\nstruct crypto_skcipher *tfm = skc->skcipher;\r\nunsigned ivsize = crypto_skcipher_ivsize(tfm);\r\nstruct skcipher_sg_list *sgl;\r\nstruct af_alg_control con = {};\r\nlong copied = 0;\r\nbool enc = 0;\r\nbool init = 0;\r\nint err;\r\nint i;\r\nif (msg->msg_controllen) {\r\nerr = af_alg_cmsg_send(msg, &con);\r\nif (err)\r\nreturn err;\r\ninit = 1;\r\nswitch (con.op) {\r\ncase ALG_OP_ENCRYPT:\r\nenc = 1;\r\nbreak;\r\ncase ALG_OP_DECRYPT:\r\nenc = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (con.iv && con.iv->ivlen != ivsize)\r\nreturn -EINVAL;\r\n}\r\nerr = -EINVAL;\r\nlock_sock(sk);\r\nif (!ctx->more && ctx->used)\r\ngoto unlock;\r\nif (init) {\r\nctx->enc = enc;\r\nif (con.iv)\r\nmemcpy(ctx->iv, con.iv->iv, ivsize);\r\n}\r\nwhile (size) {\r\nstruct scatterlist *sg;\r\nunsigned long len = size;\r\nsize_t plen;\r\nif (ctx->merge) {\r\nsgl = list_entry(ctx->tsgl.prev,\r\nstruct skcipher_sg_list, list);\r\nsg = sgl->sg + sgl->cur - 1;\r\nlen = min_t(unsigned long, len,\r\nPAGE_SIZE - sg->offset - sg->length);\r\nerr = memcpy_from_msg(page_address(sg_page(sg)) +\r\nsg->offset + sg->length,\r\nmsg, len);\r\nif (err)\r\ngoto unlock;\r\nsg->length += len;\r\nctx->merge = (sg->offset + sg->length) &\r\n(PAGE_SIZE - 1);\r\nctx->used += len;\r\ncopied += len;\r\nsize -= len;\r\ncontinue;\r\n}\r\nif (!skcipher_writable(sk)) {\r\nerr = skcipher_wait_for_wmem(sk, msg->msg_flags);\r\nif (err)\r\ngoto unlock;\r\n}\r\nlen = min_t(unsigned long, len, skcipher_sndbuf(sk));\r\nerr = skcipher_alloc_sgl(sk);\r\nif (err)\r\ngoto unlock;\r\nsgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);\r\nsg = sgl->sg;\r\nif (sgl->cur)\r\nsg_unmark_end(sg + sgl->cur - 1);\r\ndo {\r\ni = sgl->cur;\r\nplen = min_t(size_t, len, PAGE_SIZE);\r\nsg_assign_page(sg + i, alloc_page(GFP_KERNEL));\r\nerr = -ENOMEM;\r\nif (!sg_page(sg + i))\r\ngoto unlock;\r\nerr = memcpy_from_msg(page_address(sg_page(sg + i)),\r\nmsg, plen);\r\nif (err) {\r\n__free_page(sg_page(sg + i));\r\nsg_assign_page(sg + i, NULL);\r\ngoto unlock;\r\n}\r\nsg[i].length = plen;\r\nlen -= plen;\r\nctx->used += plen;\r\ncopied += plen;\r\nsize -= plen;\r\nsgl->cur++;\r\n} while (len && sgl->cur < MAX_SGL_ENTS);\r\nif (!size)\r\nsg_mark_end(sg + sgl->cur - 1);\r\nctx->merge = plen & (PAGE_SIZE - 1);\r\n}\r\nerr = 0;\r\nctx->more = msg->msg_flags & MSG_MORE;\r\nunlock:\r\nskcipher_data_wakeup(sk);\r\nrelease_sock(sk);\r\nreturn copied ?: err;\r\n}\r\nstatic ssize_t skcipher_sendpage(struct socket *sock, struct page *page,\r\nint offset, size_t size, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct skcipher_ctx *ctx = ask->private;\r\nstruct skcipher_sg_list *sgl;\r\nint err = -EINVAL;\r\nif (flags & MSG_SENDPAGE_NOTLAST)\r\nflags |= MSG_MORE;\r\nlock_sock(sk);\r\nif (!ctx->more && ctx->used)\r\ngoto unlock;\r\nif (!size)\r\ngoto done;\r\nif (!skcipher_writable(sk)) {\r\nerr = skcipher_wait_for_wmem(sk, flags);\r\nif (err)\r\ngoto unlock;\r\n}\r\nerr = skcipher_alloc_sgl(sk);\r\nif (err)\r\ngoto unlock;\r\nctx->merge = 0;\r\nsgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);\r\nif (sgl->cur)\r\nsg_unmark_end(sgl->sg + sgl->cur - 1);\r\nsg_mark_end(sgl->sg + sgl->cur);\r\nget_page(page);\r\nsg_set_page(sgl->sg + sgl->cur, page, size, offset);\r\nsgl->cur++;\r\nctx->used += size;\r\ndone:\r\nctx->more = flags & MSG_MORE;\r\nunlock:\r\nskcipher_data_wakeup(sk);\r\nrelease_sock(sk);\r\nreturn err ?: size;\r\n}\r\nstatic int skcipher_all_sg_nents(struct skcipher_ctx *ctx)\r\n{\r\nstruct skcipher_sg_list *sgl;\r\nstruct scatterlist *sg;\r\nint nents = 0;\r\nlist_for_each_entry(sgl, &ctx->tsgl, list) {\r\nsg = sgl->sg;\r\nwhile (!sg->length)\r\nsg++;\r\nnents += sg_nents(sg);\r\n}\r\nreturn nents;\r\n}\r\nstatic int skcipher_recvmsg_async(struct socket *sock, struct msghdr *msg,\r\nint flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct sock *psk = ask->parent;\r\nstruct alg_sock *pask = alg_sk(psk);\r\nstruct skcipher_ctx *ctx = ask->private;\r\nstruct skcipher_tfm *skc = pask->private;\r\nstruct crypto_skcipher *tfm = skc->skcipher;\r\nstruct skcipher_sg_list *sgl;\r\nstruct scatterlist *sg;\r\nstruct skcipher_async_req *sreq;\r\nstruct skcipher_request *req;\r\nstruct skcipher_async_rsgl *last_rsgl = NULL;\r\nunsigned int txbufs = 0, len = 0, tx_nents;\r\nunsigned int reqsize = crypto_skcipher_reqsize(tfm);\r\nunsigned int ivsize = crypto_skcipher_ivsize(tfm);\r\nint err = -ENOMEM;\r\nbool mark = false;\r\nchar *iv;\r\nsreq = kzalloc(sizeof(*sreq) + reqsize + ivsize, GFP_KERNEL);\r\nif (unlikely(!sreq))\r\ngoto out;\r\nreq = &sreq->req;\r\niv = (char *)(req + 1) + reqsize;\r\nsreq->iocb = msg->msg_iocb;\r\nINIT_LIST_HEAD(&sreq->list);\r\nsreq->inflight = &ctx->inflight;\r\nlock_sock(sk);\r\ntx_nents = skcipher_all_sg_nents(ctx);\r\nsreq->tsg = kcalloc(tx_nents, sizeof(*sg), GFP_KERNEL);\r\nif (unlikely(!sreq->tsg))\r\ngoto unlock;\r\nsg_init_table(sreq->tsg, tx_nents);\r\nmemcpy(iv, ctx->iv, ivsize);\r\nskcipher_request_set_tfm(req, tfm);\r\nskcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_SLEEP,\r\nskcipher_async_cb, sreq);\r\nwhile (iov_iter_count(&msg->msg_iter)) {\r\nstruct skcipher_async_rsgl *rsgl;\r\nint used;\r\nif (!ctx->used) {\r\nerr = skcipher_wait_for_data(sk, flags);\r\nif (err)\r\ngoto free;\r\n}\r\nsgl = list_first_entry(&ctx->tsgl,\r\nstruct skcipher_sg_list, list);\r\nsg = sgl->sg;\r\nwhile (!sg->length)\r\nsg++;\r\nused = min_t(unsigned long, ctx->used,\r\niov_iter_count(&msg->msg_iter));\r\nused = min_t(unsigned long, used, sg->length);\r\nif (txbufs == tx_nents) {\r\nstruct scatterlist *tmp;\r\nint x;\r\ntmp = kcalloc(tx_nents * 2, sizeof(*tmp),\r\nGFP_KERNEL);\r\nif (!tmp) {\r\nerr = -ENOMEM;\r\ngoto free;\r\n}\r\nsg_init_table(tmp, tx_nents * 2);\r\nfor (x = 0; x < tx_nents; x++)\r\nsg_set_page(&tmp[x], sg_page(&sreq->tsg[x]),\r\nsreq->tsg[x].length,\r\nsreq->tsg[x].offset);\r\nkfree(sreq->tsg);\r\nsreq->tsg = tmp;\r\ntx_nents *= 2;\r\nmark = true;\r\n}\r\nsg_set_page(sreq->tsg + txbufs++, sg_page(sg), sg->length,\r\nsg->offset);\r\nif (list_empty(&sreq->list)) {\r\nrsgl = &sreq->first_sgl;\r\nlist_add_tail(&rsgl->list, &sreq->list);\r\n} else {\r\nrsgl = kmalloc(sizeof(*rsgl), GFP_KERNEL);\r\nif (!rsgl) {\r\nerr = -ENOMEM;\r\ngoto free;\r\n}\r\nlist_add_tail(&rsgl->list, &sreq->list);\r\n}\r\nused = af_alg_make_sg(&rsgl->sgl, &msg->msg_iter, used);\r\nerr = used;\r\nif (used < 0)\r\ngoto free;\r\nif (last_rsgl)\r\naf_alg_link_sg(&last_rsgl->sgl, &rsgl->sgl);\r\nlast_rsgl = rsgl;\r\nlen += used;\r\nskcipher_pull_sgl(sk, used, 0);\r\niov_iter_advance(&msg->msg_iter, used);\r\n}\r\nif (mark)\r\nsg_mark_end(sreq->tsg + txbufs - 1);\r\nskcipher_request_set_crypt(req, sreq->tsg, sreq->first_sgl.sgl.sg,\r\nlen, iv);\r\nerr = ctx->enc ? crypto_skcipher_encrypt(req) :\r\ncrypto_skcipher_decrypt(req);\r\nif (err == -EINPROGRESS) {\r\natomic_inc(&ctx->inflight);\r\nerr = -EIOCBQUEUED;\r\nsreq = NULL;\r\ngoto unlock;\r\n}\r\nfree:\r\nskcipher_free_async_sgls(sreq);\r\nunlock:\r\nskcipher_wmem_wakeup(sk);\r\nrelease_sock(sk);\r\nkzfree(sreq);\r\nout:\r\nreturn err;\r\n}\r\nstatic int skcipher_recvmsg_sync(struct socket *sock, struct msghdr *msg,\r\nint flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct sock *psk = ask->parent;\r\nstruct alg_sock *pask = alg_sk(psk);\r\nstruct skcipher_ctx *ctx = ask->private;\r\nstruct skcipher_tfm *skc = pask->private;\r\nstruct crypto_skcipher *tfm = skc->skcipher;\r\nunsigned bs = crypto_skcipher_blocksize(tfm);\r\nstruct skcipher_sg_list *sgl;\r\nstruct scatterlist *sg;\r\nint err = -EAGAIN;\r\nint used;\r\nlong copied = 0;\r\nlock_sock(sk);\r\nwhile (msg_data_left(msg)) {\r\nif (!ctx->used) {\r\nerr = skcipher_wait_for_data(sk, flags);\r\nif (err)\r\ngoto unlock;\r\n}\r\nused = min_t(unsigned long, ctx->used, msg_data_left(msg));\r\nused = af_alg_make_sg(&ctx->rsgl, &msg->msg_iter, used);\r\nerr = used;\r\nif (err < 0)\r\ngoto unlock;\r\nif (ctx->more || used < ctx->used)\r\nused -= used % bs;\r\nerr = -EINVAL;\r\nif (!used)\r\ngoto free;\r\nsgl = list_first_entry(&ctx->tsgl,\r\nstruct skcipher_sg_list, list);\r\nsg = sgl->sg;\r\nwhile (!sg->length)\r\nsg++;\r\nskcipher_request_set_crypt(&ctx->req, sg, ctx->rsgl.sg, used,\r\nctx->iv);\r\nerr = af_alg_wait_for_completion(\r\nctx->enc ?\r\ncrypto_skcipher_encrypt(&ctx->req) :\r\ncrypto_skcipher_decrypt(&ctx->req),\r\n&ctx->completion);\r\nfree:\r\naf_alg_free_sg(&ctx->rsgl);\r\nif (err)\r\ngoto unlock;\r\ncopied += used;\r\nskcipher_pull_sgl(sk, used, 1);\r\niov_iter_advance(&msg->msg_iter, used);\r\n}\r\nerr = 0;\r\nunlock:\r\nskcipher_wmem_wakeup(sk);\r\nrelease_sock(sk);\r\nreturn copied ?: err;\r\n}\r\nstatic int skcipher_recvmsg(struct socket *sock, struct msghdr *msg,\r\nsize_t ignored, int flags)\r\n{\r\nreturn (msg->msg_iocb && !is_sync_kiocb(msg->msg_iocb)) ?\r\nskcipher_recvmsg_async(sock, msg, flags) :\r\nskcipher_recvmsg_sync(sock, msg, flags);\r\n}\r\nstatic unsigned int skcipher_poll(struct file *file, struct socket *sock,\r\npoll_table *wait)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct skcipher_ctx *ctx = ask->private;\r\nunsigned int mask;\r\nsock_poll_wait(file, sk_sleep(sk), wait);\r\nmask = 0;\r\nif (ctx->used)\r\nmask |= POLLIN | POLLRDNORM;\r\nif (skcipher_writable(sk))\r\nmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\r\nreturn mask;\r\n}\r\nstatic int skcipher_check_key(struct socket *sock)\r\n{\r\nint err = 0;\r\nstruct sock *psk;\r\nstruct alg_sock *pask;\r\nstruct skcipher_tfm *tfm;\r\nstruct sock *sk = sock->sk;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nlock_sock(sk);\r\nif (ask->refcnt)\r\ngoto unlock_child;\r\npsk = ask->parent;\r\npask = alg_sk(ask->parent);\r\ntfm = pask->private;\r\nerr = -ENOKEY;\r\nlock_sock_nested(psk, SINGLE_DEPTH_NESTING);\r\nif (!tfm->has_key)\r\ngoto unlock;\r\nif (!pask->refcnt++)\r\nsock_hold(psk);\r\nask->refcnt = 1;\r\nsock_put(psk);\r\nerr = 0;\r\nunlock:\r\nrelease_sock(psk);\r\nunlock_child:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int skcipher_sendmsg_nokey(struct socket *sock, struct msghdr *msg,\r\nsize_t size)\r\n{\r\nint err;\r\nerr = skcipher_check_key(sock);\r\nif (err)\r\nreturn err;\r\nreturn skcipher_sendmsg(sock, msg, size);\r\n}\r\nstatic ssize_t skcipher_sendpage_nokey(struct socket *sock, struct page *page,\r\nint offset, size_t size, int flags)\r\n{\r\nint err;\r\nerr = skcipher_check_key(sock);\r\nif (err)\r\nreturn err;\r\nreturn skcipher_sendpage(sock, page, offset, size, flags);\r\n}\r\nstatic int skcipher_recvmsg_nokey(struct socket *sock, struct msghdr *msg,\r\nsize_t ignored, int flags)\r\n{\r\nint err;\r\nerr = skcipher_check_key(sock);\r\nif (err)\r\nreturn err;\r\nreturn skcipher_recvmsg(sock, msg, ignored, flags);\r\n}\r\nstatic void *skcipher_bind(const char *name, u32 type, u32 mask)\r\n{\r\nstruct skcipher_tfm *tfm;\r\nstruct crypto_skcipher *skcipher;\r\ntfm = kzalloc(sizeof(*tfm), GFP_KERNEL);\r\nif (!tfm)\r\nreturn ERR_PTR(-ENOMEM);\r\nskcipher = crypto_alloc_skcipher(name, type, mask);\r\nif (IS_ERR(skcipher)) {\r\nkfree(tfm);\r\nreturn ERR_CAST(skcipher);\r\n}\r\ntfm->skcipher = skcipher;\r\nreturn tfm;\r\n}\r\nstatic void skcipher_release(void *private)\r\n{\r\nstruct skcipher_tfm *tfm = private;\r\ncrypto_free_skcipher(tfm->skcipher);\r\nkfree(tfm);\r\n}\r\nstatic int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)\r\n{\r\nstruct skcipher_tfm *tfm = private;\r\nint err;\r\nerr = crypto_skcipher_setkey(tfm->skcipher, key, keylen);\r\ntfm->has_key = !err;\r\nreturn err;\r\n}\r\nstatic void skcipher_wait(struct sock *sk)\r\n{\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct skcipher_ctx *ctx = ask->private;\r\nint ctr = 0;\r\nwhile (atomic_read(&ctx->inflight) && ctr++ < 100)\r\nmsleep(100);\r\n}\r\nstatic void skcipher_sock_destruct(struct sock *sk)\r\n{\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct skcipher_ctx *ctx = ask->private;\r\nstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(&ctx->req);\r\nif (atomic_read(&ctx->inflight))\r\nskcipher_wait(sk);\r\nskcipher_free_sgl(sk);\r\nsock_kzfree_s(sk, ctx->iv, crypto_skcipher_ivsize(tfm));\r\nsock_kfree_s(sk, ctx, ctx->len);\r\naf_alg_release_parent(sk);\r\n}\r\nstatic int skcipher_accept_parent_nokey(void *private, struct sock *sk)\r\n{\r\nstruct skcipher_ctx *ctx;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct skcipher_tfm *tfm = private;\r\nstruct crypto_skcipher *skcipher = tfm->skcipher;\r\nunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(skcipher);\r\nctx = sock_kmalloc(sk, len, GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(skcipher),\r\nGFP_KERNEL);\r\nif (!ctx->iv) {\r\nsock_kfree_s(sk, ctx, len);\r\nreturn -ENOMEM;\r\n}\r\nmemset(ctx->iv, 0, crypto_skcipher_ivsize(skcipher));\r\nINIT_LIST_HEAD(&ctx->tsgl);\r\nctx->len = len;\r\nctx->used = 0;\r\nctx->more = 0;\r\nctx->merge = 0;\r\nctx->enc = 0;\r\natomic_set(&ctx->inflight, 0);\r\naf_alg_init_completion(&ctx->completion);\r\nask->private = ctx;\r\nskcipher_request_set_tfm(&ctx->req, skcipher);\r\nskcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_SLEEP |\r\nCRYPTO_TFM_REQ_MAY_BACKLOG,\r\naf_alg_complete, &ctx->completion);\r\nsk->sk_destruct = skcipher_sock_destruct;\r\nreturn 0;\r\n}\r\nstatic int skcipher_accept_parent(void *private, struct sock *sk)\r\n{\r\nstruct skcipher_tfm *tfm = private;\r\nif (!tfm->has_key && crypto_skcipher_has_setkey(tfm->skcipher))\r\nreturn -ENOKEY;\r\nreturn skcipher_accept_parent_nokey(private, sk);\r\n}\r\nstatic int __init algif_skcipher_init(void)\r\n{\r\nreturn af_alg_register_type(&algif_type_skcipher);\r\n}\r\nstatic void __exit algif_skcipher_exit(void)\r\n{\r\nint err = af_alg_unregister_type(&algif_type_skcipher);\r\nBUG_ON(err);\r\n}
