static inline int ux500_enter_idle(struct cpuidle_device *dev,\r\nstruct cpuidle_driver *drv, int index)\r\n{\r\nint this_cpu = smp_processor_id();\r\nbool recouple = false;\r\nif (atomic_inc_return(&master) == num_online_cpus()) {\r\nif (!spin_trylock(&master_lock))\r\ngoto wfi;\r\nif (prcmu_gic_decouple()) {\r\nspin_unlock(&master_lock);\r\ngoto out;\r\n}\r\nrecouple = true;\r\nif (!prcmu_is_cpu_in_wfi(this_cpu ? 0 : 1))\r\ngoto out;\r\nif (prcmu_copy_gic_settings())\r\ngoto out;\r\nif (prcmu_gic_pending_irq())\r\ngoto out;\r\nif (prcmu_pending_irq())\r\ngoto out;\r\nif (prcmu_set_power_state(PRCMU_AP_IDLE, true, true))\r\ngoto out;\r\nrecouple = false;\r\nspin_unlock(&master_lock);\r\n}\r\nwfi:\r\ncpu_do_idle();\r\nout:\r\natomic_dec(&master);\r\nif (recouple) {\r\nprcmu_gic_recouple();\r\nspin_unlock(&master_lock);\r\n}\r\nreturn index;\r\n}\r\nstatic int dbx500_cpuidle_probe(struct platform_device *pdev)\r\n{\r\nprcmu_enable_wakeups(PRCMU_WAKEUP(ARM) | PRCMU_WAKEUP(RTC) |\r\nPRCMU_WAKEUP(ABB));\r\nreturn cpuidle_register(&ux500_idle_driver, NULL);\r\n}
