static inline void\r\niscsi_tcp_segment_init_sg(struct iscsi_segment *segment,\r\nstruct scatterlist *sg, unsigned int offset)\r\n{\r\nsegment->sg = sg;\r\nsegment->sg_offset = offset;\r\nsegment->size = min(sg->length - offset,\r\nsegment->total_size - segment->total_copied);\r\nsegment->data = NULL;\r\n}\r\nstatic void iscsi_tcp_segment_map(struct iscsi_segment *segment, int recv)\r\n{\r\nstruct scatterlist *sg;\r\nif (segment->data != NULL || !segment->sg)\r\nreturn;\r\nsg = segment->sg;\r\nBUG_ON(segment->sg_mapped);\r\nBUG_ON(sg->length == 0);\r\nif (page_count(sg_page(sg)) >= 1 && !recv)\r\nreturn;\r\nif (recv) {\r\nsegment->atomic_mapped = true;\r\nsegment->sg_mapped = kmap_atomic(sg_page(sg));\r\n} else {\r\nsegment->atomic_mapped = false;\r\nsegment->sg_mapped = kmap(sg_page(sg));\r\n}\r\nsegment->data = segment->sg_mapped + sg->offset + segment->sg_offset;\r\n}\r\nvoid iscsi_tcp_segment_unmap(struct iscsi_segment *segment)\r\n{\r\nif (segment->sg_mapped) {\r\nif (segment->atomic_mapped)\r\nkunmap_atomic(segment->sg_mapped);\r\nelse\r\nkunmap(sg_page(segment->sg));\r\nsegment->sg_mapped = NULL;\r\nsegment->data = NULL;\r\n}\r\n}\r\nstatic inline void\r\niscsi_tcp_segment_splice_digest(struct iscsi_segment *segment, void *digest)\r\n{\r\nsegment->data = digest;\r\nsegment->digest_len = ISCSI_DIGEST_SIZE;\r\nsegment->total_size += ISCSI_DIGEST_SIZE;\r\nsegment->size = ISCSI_DIGEST_SIZE;\r\nsegment->copied = 0;\r\nsegment->sg = NULL;\r\nsegment->hash = NULL;\r\n}\r\nint iscsi_tcp_segment_done(struct iscsi_tcp_conn *tcp_conn,\r\nstruct iscsi_segment *segment, int recv,\r\nunsigned copied)\r\n{\r\nstruct scatterlist sg;\r\nunsigned int pad;\r\nISCSI_DBG_TCP(tcp_conn->iscsi_conn, "copied %u %u size %u %s\n",\r\nsegment->copied, copied, segment->size,\r\nrecv ? "recv" : "xmit");\r\nif (segment->hash && copied) {\r\niscsi_tcp_segment_unmap(segment);\r\nif (!segment->data) {\r\nsg_init_table(&sg, 1);\r\nsg_set_page(&sg, sg_page(segment->sg), copied,\r\nsegment->copied + segment->sg_offset +\r\nsegment->sg->offset);\r\n} else\r\nsg_init_one(&sg, segment->data + segment->copied,\r\ncopied);\r\nahash_request_set_crypt(segment->hash, &sg, NULL, copied);\r\ncrypto_ahash_update(segment->hash);\r\n}\r\nsegment->copied += copied;\r\nif (segment->copied < segment->size) {\r\niscsi_tcp_segment_map(segment, recv);\r\nreturn 0;\r\n}\r\nsegment->total_copied += segment->copied;\r\nsegment->copied = 0;\r\nsegment->size = 0;\r\niscsi_tcp_segment_unmap(segment);\r\nISCSI_DBG_TCP(tcp_conn->iscsi_conn, "total copied %u total size %u\n",\r\nsegment->total_copied, segment->total_size);\r\nif (segment->total_copied < segment->total_size) {\r\niscsi_tcp_segment_init_sg(segment, sg_next(segment->sg),\r\n0);\r\niscsi_tcp_segment_map(segment, recv);\r\nBUG_ON(segment->size == 0);\r\nreturn 0;\r\n}\r\nif (!(tcp_conn->iscsi_conn->session->tt->caps & CAP_PADDING_OFFLOAD)) {\r\npad = iscsi_padding(segment->total_copied);\r\nif (pad != 0) {\r\nISCSI_DBG_TCP(tcp_conn->iscsi_conn,\r\n"consume %d pad bytes\n", pad);\r\nsegment->total_size += pad;\r\nsegment->size = pad;\r\nsegment->data = segment->padbuf;\r\nreturn 0;\r\n}\r\n}\r\nif (segment->hash) {\r\nahash_request_set_crypt(segment->hash, NULL,\r\nsegment->digest, 0);\r\ncrypto_ahash_final(segment->hash);\r\niscsi_tcp_segment_splice_digest(segment,\r\nrecv ? segment->recv_digest : segment->digest);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int\r\niscsi_tcp_segment_recv(struct iscsi_tcp_conn *tcp_conn,\r\nstruct iscsi_segment *segment, const void *ptr,\r\nunsigned int len)\r\n{\r\nunsigned int copy = 0, copied = 0;\r\nwhile (!iscsi_tcp_segment_done(tcp_conn, segment, 1, copy)) {\r\nif (copied == len) {\r\nISCSI_DBG_TCP(tcp_conn->iscsi_conn,\r\n"copied %d bytes\n", len);\r\nbreak;\r\n}\r\ncopy = min(len - copied, segment->size - segment->copied);\r\nISCSI_DBG_TCP(tcp_conn->iscsi_conn, "copying %d\n", copy);\r\nmemcpy(segment->data + segment->copied, ptr + copied, copy);\r\ncopied += copy;\r\n}\r\nreturn copied;\r\n}\r\ninline void\r\niscsi_tcp_dgst_header(struct ahash_request *hash, const void *hdr,\r\nsize_t hdrlen, unsigned char digest[ISCSI_DIGEST_SIZE])\r\n{\r\nstruct scatterlist sg;\r\nsg_init_one(&sg, hdr, hdrlen);\r\nahash_request_set_crypt(hash, &sg, digest, hdrlen);\r\ncrypto_ahash_digest(hash);\r\n}\r\nstatic inline int\r\niscsi_tcp_dgst_verify(struct iscsi_tcp_conn *tcp_conn,\r\nstruct iscsi_segment *segment)\r\n{\r\nif (!segment->digest_len)\r\nreturn 1;\r\nif (memcmp(segment->recv_digest, segment->digest,\r\nsegment->digest_len)) {\r\nISCSI_DBG_TCP(tcp_conn->iscsi_conn, "digest mismatch\n");\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic inline void\r\n__iscsi_segment_init(struct iscsi_segment *segment, size_t size,\r\niscsi_segment_done_fn_t *done, struct ahash_request *hash)\r\n{\r\nmemset(segment, 0, sizeof(*segment));\r\nsegment->total_size = size;\r\nsegment->done = done;\r\nif (hash) {\r\nsegment->hash = hash;\r\ncrypto_ahash_init(hash);\r\n}\r\n}\r\ninline void\r\niscsi_segment_init_linear(struct iscsi_segment *segment, void *data,\r\nsize_t size, iscsi_segment_done_fn_t *done,\r\nstruct ahash_request *hash)\r\n{\r\n__iscsi_segment_init(segment, size, done, hash);\r\nsegment->data = data;\r\nsegment->size = size;\r\n}\r\ninline int\r\niscsi_segment_seek_sg(struct iscsi_segment *segment,\r\nstruct scatterlist *sg_list, unsigned int sg_count,\r\nunsigned int offset, size_t size,\r\niscsi_segment_done_fn_t *done,\r\nstruct ahash_request *hash)\r\n{\r\nstruct scatterlist *sg;\r\nunsigned int i;\r\n__iscsi_segment_init(segment, size, done, hash);\r\nfor_each_sg(sg_list, sg, sg_count, i) {\r\nif (offset < sg->length) {\r\niscsi_tcp_segment_init_sg(segment, sg, offset);\r\nreturn 0;\r\n}\r\noffset -= sg->length;\r\n}\r\nreturn ISCSI_ERR_DATA_OFFSET;\r\n}\r\nvoid iscsi_tcp_hdr_recv_prep(struct iscsi_tcp_conn *tcp_conn)\r\n{\r\nISCSI_DBG_TCP(tcp_conn->iscsi_conn,\r\n"(%s)\n", tcp_conn->iscsi_conn->hdrdgst_en ?\r\n"digest enabled" : "digest disabled");\r\niscsi_segment_init_linear(&tcp_conn->in.segment,\r\ntcp_conn->in.hdr_buf, sizeof(struct iscsi_hdr),\r\niscsi_tcp_hdr_recv_done, NULL);\r\n}\r\nstatic int\r\niscsi_tcp_data_recv_done(struct iscsi_tcp_conn *tcp_conn,\r\nstruct iscsi_segment *segment)\r\n{\r\nstruct iscsi_conn *conn = tcp_conn->iscsi_conn;\r\nint rc = 0;\r\nif (!iscsi_tcp_dgst_verify(tcp_conn, segment))\r\nreturn ISCSI_ERR_DATA_DGST;\r\nrc = iscsi_complete_pdu(conn, tcp_conn->in.hdr,\r\nconn->data, tcp_conn->in.datalen);\r\nif (rc)\r\nreturn rc;\r\niscsi_tcp_hdr_recv_prep(tcp_conn);\r\nreturn 0;\r\n}\r\nstatic void\r\niscsi_tcp_data_recv_prep(struct iscsi_tcp_conn *tcp_conn)\r\n{\r\nstruct iscsi_conn *conn = tcp_conn->iscsi_conn;\r\nstruct ahash_request *rx_hash = NULL;\r\nif (conn->datadgst_en &&\r\n!(conn->session->tt->caps & CAP_DIGEST_OFFLOAD))\r\nrx_hash = tcp_conn->rx_hash;\r\niscsi_segment_init_linear(&tcp_conn->in.segment,\r\nconn->data, tcp_conn->in.datalen,\r\niscsi_tcp_data_recv_done, rx_hash);\r\n}\r\nvoid iscsi_tcp_cleanup_task(struct iscsi_task *task)\r\n{\r\nstruct iscsi_tcp_task *tcp_task = task->dd_data;\r\nstruct iscsi_r2t_info *r2t;\r\nif (!task->sc)\r\nreturn;\r\nspin_lock_bh(&tcp_task->queue2pool);\r\nwhile (kfifo_out(&tcp_task->r2tqueue, (void*)&r2t, sizeof(void*))) {\r\nkfifo_in(&tcp_task->r2tpool.queue, (void*)&r2t,\r\nsizeof(void*));\r\nISCSI_DBG_TCP(task->conn, "pending r2t dropped\n");\r\n}\r\nr2t = tcp_task->r2t;\r\nif (r2t != NULL) {\r\nkfifo_in(&tcp_task->r2tpool.queue, (void*)&r2t,\r\nsizeof(void*));\r\ntcp_task->r2t = NULL;\r\n}\r\nspin_unlock_bh(&tcp_task->queue2pool);\r\n}\r\nstatic int iscsi_tcp_data_in(struct iscsi_conn *conn, struct iscsi_task *task)\r\n{\r\nstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\r\nstruct iscsi_tcp_task *tcp_task = task->dd_data;\r\nstruct iscsi_data_rsp *rhdr = (struct iscsi_data_rsp *)tcp_conn->in.hdr;\r\nint datasn = be32_to_cpu(rhdr->datasn);\r\nunsigned total_in_length = scsi_in(task->sc)->length;\r\nif (!(rhdr->flags & ISCSI_FLAG_DATA_STATUS))\r\niscsi_update_cmdsn(conn->session, (struct iscsi_nopin*)rhdr);\r\nif (tcp_conn->in.datalen == 0)\r\nreturn 0;\r\nif (tcp_task->exp_datasn != datasn) {\r\nISCSI_DBG_TCP(conn, "task->exp_datasn(%d) != rhdr->datasn(%d)"\r\n"\n", tcp_task->exp_datasn, datasn);\r\nreturn ISCSI_ERR_DATASN;\r\n}\r\ntcp_task->exp_datasn++;\r\ntcp_task->data_offset = be32_to_cpu(rhdr->offset);\r\nif (tcp_task->data_offset + tcp_conn->in.datalen > total_in_length) {\r\nISCSI_DBG_TCP(conn, "data_offset(%d) + data_len(%d) > "\r\n"total_length_in(%d)\n", tcp_task->data_offset,\r\ntcp_conn->in.datalen, total_in_length);\r\nreturn ISCSI_ERR_DATA_OFFSET;\r\n}\r\nconn->datain_pdus_cnt++;\r\nreturn 0;\r\n}\r\nstatic int iscsi_tcp_r2t_rsp(struct iscsi_conn *conn, struct iscsi_task *task)\r\n{\r\nstruct iscsi_session *session = conn->session;\r\nstruct iscsi_tcp_task *tcp_task = task->dd_data;\r\nstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\r\nstruct iscsi_r2t_rsp *rhdr = (struct iscsi_r2t_rsp *)tcp_conn->in.hdr;\r\nstruct iscsi_r2t_info *r2t;\r\nint r2tsn = be32_to_cpu(rhdr->r2tsn);\r\nu32 data_length;\r\nu32 data_offset;\r\nint rc;\r\nif (tcp_conn->in.datalen) {\r\niscsi_conn_printk(KERN_ERR, conn,\r\n"invalid R2t with datalen %d\n",\r\ntcp_conn->in.datalen);\r\nreturn ISCSI_ERR_DATALEN;\r\n}\r\nif (tcp_task->exp_datasn != r2tsn){\r\nISCSI_DBG_TCP(conn, "task->exp_datasn(%d) != rhdr->r2tsn(%d)\n",\r\ntcp_task->exp_datasn, r2tsn);\r\nreturn ISCSI_ERR_R2TSN;\r\n}\r\niscsi_update_cmdsn(session, (struct iscsi_nopin*)rhdr);\r\nif (!task->sc || session->state != ISCSI_STATE_LOGGED_IN) {\r\niscsi_conn_printk(KERN_INFO, conn,\r\n"dropping R2T itt %d in recovery.\n",\r\ntask->itt);\r\nreturn 0;\r\n}\r\ndata_length = be32_to_cpu(rhdr->data_length);\r\nif (data_length == 0) {\r\niscsi_conn_printk(KERN_ERR, conn,\r\n"invalid R2T with zero data len\n");\r\nreturn ISCSI_ERR_DATALEN;\r\n}\r\nif (data_length > session->max_burst)\r\nISCSI_DBG_TCP(conn, "invalid R2T with data len %u and max "\r\n"burst %u. Attempting to execute request.\n",\r\ndata_length, session->max_burst);\r\ndata_offset = be32_to_cpu(rhdr->data_offset);\r\nif (data_offset + data_length > scsi_out(task->sc)->length) {\r\niscsi_conn_printk(KERN_ERR, conn,\r\n"invalid R2T with data len %u at offset %u "\r\n"and total length %d\n", data_length,\r\ndata_offset, scsi_out(task->sc)->length);\r\nreturn ISCSI_ERR_DATALEN;\r\n}\r\nspin_lock(&tcp_task->pool2queue);\r\nrc = kfifo_out(&tcp_task->r2tpool.queue, (void *)&r2t, sizeof(void *));\r\nif (!rc) {\r\niscsi_conn_printk(KERN_ERR, conn, "Could not allocate R2T. "\r\n"Target has sent more R2Ts than it "\r\n"negotiated for or driver has leaked.\n");\r\nspin_unlock(&tcp_task->pool2queue);\r\nreturn ISCSI_ERR_PROTO;\r\n}\r\nr2t->exp_statsn = rhdr->statsn;\r\nr2t->data_length = data_length;\r\nr2t->data_offset = data_offset;\r\nr2t->ttt = rhdr->ttt;\r\nr2t->datasn = 0;\r\nr2t->sent = 0;\r\ntcp_task->exp_datasn = r2tsn + 1;\r\nkfifo_in(&tcp_task->r2tqueue, (void*)&r2t, sizeof(void*));\r\nconn->r2t_pdus_cnt++;\r\nspin_unlock(&tcp_task->pool2queue);\r\niscsi_requeue_task(task);\r\nreturn 0;\r\n}\r\nstatic int\r\niscsi_tcp_process_data_in(struct iscsi_tcp_conn *tcp_conn,\r\nstruct iscsi_segment *segment)\r\n{\r\nstruct iscsi_conn *conn = tcp_conn->iscsi_conn;\r\nstruct iscsi_hdr *hdr = tcp_conn->in.hdr;\r\nint rc;\r\nif (!iscsi_tcp_dgst_verify(tcp_conn, segment))\r\nreturn ISCSI_ERR_DATA_DGST;\r\nif (hdr->flags & ISCSI_FLAG_DATA_STATUS) {\r\nrc = iscsi_complete_pdu(conn, tcp_conn->in.hdr, NULL, 0);\r\nif (rc)\r\nreturn rc;\r\n}\r\niscsi_tcp_hdr_recv_prep(tcp_conn);\r\nreturn 0;\r\n}\r\nstatic int\r\niscsi_tcp_hdr_dissect(struct iscsi_conn *conn, struct iscsi_hdr *hdr)\r\n{\r\nint rc = 0, opcode, ahslen;\r\nstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\r\nstruct iscsi_task *task;\r\ntcp_conn->in.datalen = ntoh24(hdr->dlength);\r\nif (tcp_conn->in.datalen > conn->max_recv_dlength) {\r\niscsi_conn_printk(KERN_ERR, conn,\r\n"iscsi_tcp: datalen %d > %d\n",\r\ntcp_conn->in.datalen, conn->max_recv_dlength);\r\nreturn ISCSI_ERR_DATALEN;\r\n}\r\nahslen = hdr->hlength << 2;\r\nopcode = hdr->opcode & ISCSI_OPCODE_MASK;\r\nrc = iscsi_verify_itt(conn, hdr->itt);\r\nif (rc)\r\nreturn rc;\r\nISCSI_DBG_TCP(conn, "opcode 0x%x ahslen %d datalen %d\n",\r\nopcode, ahslen, tcp_conn->in.datalen);\r\nswitch(opcode) {\r\ncase ISCSI_OP_SCSI_DATA_IN:\r\nspin_lock(&conn->session->back_lock);\r\ntask = iscsi_itt_to_ctask(conn, hdr->itt);\r\nif (!task)\r\nrc = ISCSI_ERR_BAD_ITT;\r\nelse\r\nrc = iscsi_tcp_data_in(conn, task);\r\nif (rc) {\r\nspin_unlock(&conn->session->back_lock);\r\nbreak;\r\n}\r\nif (tcp_conn->in.datalen) {\r\nstruct iscsi_tcp_task *tcp_task = task->dd_data;\r\nstruct ahash_request *rx_hash = NULL;\r\nstruct scsi_data_buffer *sdb = scsi_in(task->sc);\r\nif (conn->datadgst_en &&\r\n!(conn->session->tt->caps & CAP_DIGEST_OFFLOAD))\r\nrx_hash = tcp_conn->rx_hash;\r\nISCSI_DBG_TCP(conn, "iscsi_tcp_begin_data_in( "\r\n"offset=%d, datalen=%d)\n",\r\ntcp_task->data_offset,\r\ntcp_conn->in.datalen);\r\ntask->last_xfer = jiffies;\r\nrc = iscsi_segment_seek_sg(&tcp_conn->in.segment,\r\nsdb->table.sgl,\r\nsdb->table.nents,\r\ntcp_task->data_offset,\r\ntcp_conn->in.datalen,\r\niscsi_tcp_process_data_in,\r\nrx_hash);\r\nspin_unlock(&conn->session->back_lock);\r\nreturn rc;\r\n}\r\nrc = __iscsi_complete_pdu(conn, hdr, NULL, 0);\r\nspin_unlock(&conn->session->back_lock);\r\nbreak;\r\ncase ISCSI_OP_SCSI_CMD_RSP:\r\nif (tcp_conn->in.datalen) {\r\niscsi_tcp_data_recv_prep(tcp_conn);\r\nreturn 0;\r\n}\r\nrc = iscsi_complete_pdu(conn, hdr, NULL, 0);\r\nbreak;\r\ncase ISCSI_OP_R2T:\r\nspin_lock(&conn->session->back_lock);\r\ntask = iscsi_itt_to_ctask(conn, hdr->itt);\r\nspin_unlock(&conn->session->back_lock);\r\nif (!task)\r\nrc = ISCSI_ERR_BAD_ITT;\r\nelse if (ahslen)\r\nrc = ISCSI_ERR_AHSLEN;\r\nelse if (task->sc->sc_data_direction == DMA_TO_DEVICE) {\r\ntask->last_xfer = jiffies;\r\nspin_lock(&conn->session->frwd_lock);\r\nrc = iscsi_tcp_r2t_rsp(conn, task);\r\nspin_unlock(&conn->session->frwd_lock);\r\n} else\r\nrc = ISCSI_ERR_PROTO;\r\nbreak;\r\ncase ISCSI_OP_LOGIN_RSP:\r\ncase ISCSI_OP_TEXT_RSP:\r\ncase ISCSI_OP_REJECT:\r\ncase ISCSI_OP_ASYNC_EVENT:\r\nif (ISCSI_DEF_MAX_RECV_SEG_LEN < tcp_conn->in.datalen) {\r\niscsi_conn_printk(KERN_ERR, conn,\r\n"iscsi_tcp: received buffer of "\r\n"len %u but conn buffer is only %u "\r\n"(opcode %0x)\n",\r\ntcp_conn->in.datalen,\r\nISCSI_DEF_MAX_RECV_SEG_LEN, opcode);\r\nrc = ISCSI_ERR_PROTO;\r\nbreak;\r\n}\r\nif (tcp_conn->in.datalen) {\r\niscsi_tcp_data_recv_prep(tcp_conn);\r\nreturn 0;\r\n}\r\ncase ISCSI_OP_LOGOUT_RSP:\r\ncase ISCSI_OP_NOOP_IN:\r\ncase ISCSI_OP_SCSI_TMFUNC_RSP:\r\nrc = iscsi_complete_pdu(conn, hdr, NULL, 0);\r\nbreak;\r\ndefault:\r\nrc = ISCSI_ERR_BAD_OPCODE;\r\nbreak;\r\n}\r\nif (rc == 0) {\r\nif (tcp_conn->in.datalen)\r\nreturn ISCSI_ERR_PROTO;\r\niscsi_tcp_hdr_recv_prep(tcp_conn);\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\niscsi_tcp_hdr_recv_done(struct iscsi_tcp_conn *tcp_conn,\r\nstruct iscsi_segment *segment)\r\n{\r\nstruct iscsi_conn *conn = tcp_conn->iscsi_conn;\r\nstruct iscsi_hdr *hdr;\r\nhdr = (struct iscsi_hdr *) tcp_conn->in.hdr_buf;\r\nif (segment->copied == sizeof(struct iscsi_hdr) && hdr->hlength) {\r\nunsigned int ahslen = hdr->hlength << 2;\r\nif (sizeof(*hdr) + ahslen > sizeof(tcp_conn->in.hdr_buf))\r\nreturn ISCSI_ERR_AHSLEN;\r\nsegment->total_size += ahslen;\r\nsegment->size += ahslen;\r\nreturn 0;\r\n}\r\nif (conn->hdrdgst_en &&\r\n!(conn->session->tt->caps & CAP_DIGEST_OFFLOAD)) {\r\nif (segment->digest_len == 0) {\r\niscsi_tcp_segment_splice_digest(segment,\r\nsegment->recv_digest);\r\nreturn 0;\r\n}\r\niscsi_tcp_dgst_header(tcp_conn->rx_hash, hdr,\r\nsegment->total_copied - ISCSI_DIGEST_SIZE,\r\nsegment->digest);\r\nif (!iscsi_tcp_dgst_verify(tcp_conn, segment))\r\nreturn ISCSI_ERR_HDR_DGST;\r\n}\r\ntcp_conn->in.hdr = hdr;\r\nreturn iscsi_tcp_hdr_dissect(conn, hdr);\r\n}\r\ninline int iscsi_tcp_recv_segment_is_hdr(struct iscsi_tcp_conn *tcp_conn)\r\n{\r\nreturn tcp_conn->in.segment.done == iscsi_tcp_hdr_recv_done;\r\n}\r\nint iscsi_tcp_recv_skb(struct iscsi_conn *conn, struct sk_buff *skb,\r\nunsigned int offset, bool offloaded, int *status)\r\n{\r\nstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\r\nstruct iscsi_segment *segment = &tcp_conn->in.segment;\r\nstruct skb_seq_state seq;\r\nunsigned int consumed = 0;\r\nint rc = 0;\r\nISCSI_DBG_TCP(conn, "in %d bytes\n", skb->len - offset);\r\nconn->last_recv = jiffies;\r\nif (unlikely(conn->suspend_rx)) {\r\nISCSI_DBG_TCP(conn, "Rx suspended!\n");\r\n*status = ISCSI_TCP_SUSPENDED;\r\nreturn 0;\r\n}\r\nif (offloaded) {\r\nsegment->total_copied = segment->total_size;\r\ngoto segment_done;\r\n}\r\nskb_prepare_seq_read(skb, offset, skb->len, &seq);\r\nwhile (1) {\r\nunsigned int avail;\r\nconst u8 *ptr;\r\navail = skb_seq_read(consumed, &ptr, &seq);\r\nif (avail == 0) {\r\nISCSI_DBG_TCP(conn, "no more data avail. Consumed %d\n",\r\nconsumed);\r\n*status = ISCSI_TCP_SKB_DONE;\r\ngoto skb_done;\r\n}\r\nBUG_ON(segment->copied >= segment->size);\r\nISCSI_DBG_TCP(conn, "skb %p ptr=%p avail=%u\n", skb, ptr,\r\navail);\r\nrc = iscsi_tcp_segment_recv(tcp_conn, segment, ptr, avail);\r\nBUG_ON(rc == 0);\r\nconsumed += rc;\r\nif (segment->total_copied >= segment->total_size) {\r\nskb_abort_seq_read(&seq);\r\ngoto segment_done;\r\n}\r\n}\r\nsegment_done:\r\n*status = ISCSI_TCP_SEGMENT_DONE;\r\nISCSI_DBG_TCP(conn, "segment done\n");\r\nrc = segment->done(tcp_conn, segment);\r\nif (rc != 0) {\r\n*status = ISCSI_TCP_CONN_ERR;\r\nISCSI_DBG_TCP(conn, "Error receiving PDU, errno=%d\n", rc);\r\niscsi_conn_failure(conn, rc);\r\nreturn 0;\r\n}\r\nskb_done:\r\nconn->rxdata_octets += consumed;\r\nreturn consumed;\r\n}\r\nint iscsi_tcp_task_init(struct iscsi_task *task)\r\n{\r\nstruct iscsi_tcp_task *tcp_task = task->dd_data;\r\nstruct iscsi_conn *conn = task->conn;\r\nstruct scsi_cmnd *sc = task->sc;\r\nint err;\r\nif (!sc) {\r\nISCSI_DBG_TCP(conn, "mtask deq [itt 0x%x]\n", task->itt);\r\nreturn conn->session->tt->init_pdu(task, 0, task->data_count);\r\n}\r\nBUG_ON(kfifo_len(&tcp_task->r2tqueue));\r\ntcp_task->exp_datasn = 0;\r\nISCSI_DBG_TCP(conn, "task deq [itt 0x%x imm %d unsol %d]\n",\r\ntask->itt, task->imm_count, task->unsol_r2t.data_length);\r\nerr = conn->session->tt->init_pdu(task, 0, task->imm_count);\r\nif (err)\r\nreturn err;\r\ntask->imm_count = 0;\r\nreturn 0;\r\n}\r\nstatic struct iscsi_r2t_info *iscsi_tcp_get_curr_r2t(struct iscsi_task *task)\r\n{\r\nstruct iscsi_tcp_task *tcp_task = task->dd_data;\r\nstruct iscsi_r2t_info *r2t = NULL;\r\nif (iscsi_task_has_unsol_data(task))\r\nr2t = &task->unsol_r2t;\r\nelse {\r\nspin_lock_bh(&tcp_task->queue2pool);\r\nif (tcp_task->r2t) {\r\nr2t = tcp_task->r2t;\r\nif (r2t->data_length <= r2t->sent) {\r\nISCSI_DBG_TCP(task->conn,\r\n" done with r2t %p\n", r2t);\r\nkfifo_in(&tcp_task->r2tpool.queue,\r\n(void *)&tcp_task->r2t,\r\nsizeof(void *));\r\ntcp_task->r2t = r2t = NULL;\r\n}\r\n}\r\nif (r2t == NULL) {\r\nif (kfifo_out(&tcp_task->r2tqueue,\r\n(void *)&tcp_task->r2t, sizeof(void *)) !=\r\nsizeof(void *))\r\nr2t = NULL;\r\nelse\r\nr2t = tcp_task->r2t;\r\n}\r\nspin_unlock_bh(&tcp_task->queue2pool);\r\n}\r\nreturn r2t;\r\n}\r\nint iscsi_tcp_task_xmit(struct iscsi_task *task)\r\n{\r\nstruct iscsi_conn *conn = task->conn;\r\nstruct iscsi_session *session = conn->session;\r\nstruct iscsi_r2t_info *r2t;\r\nint rc = 0;\r\nflush:\r\nrc = session->tt->xmit_pdu(task);\r\nif (rc < 0)\r\nreturn rc;\r\nif (!task->sc) {\r\nif (task->hdr->itt == RESERVED_ITT)\r\niscsi_put_task(task);\r\nreturn 0;\r\n}\r\nif (task->sc->sc_data_direction != DMA_TO_DEVICE)\r\nreturn 0;\r\nr2t = iscsi_tcp_get_curr_r2t(task);\r\nif (r2t == NULL) {\r\nISCSI_DBG_TCP(conn, "no R2Ts yet\n");\r\nreturn 0;\r\n}\r\nrc = conn->session->tt->alloc_pdu(task, ISCSI_OP_SCSI_DATA_OUT);\r\nif (rc)\r\nreturn rc;\r\niscsi_prep_data_out_pdu(task, r2t, (struct iscsi_data *) task->hdr);\r\nISCSI_DBG_TCP(conn, "sol dout %p [dsn %d itt 0x%x doff %d dlen %d]\n",\r\nr2t, r2t->datasn - 1, task->hdr->itt,\r\nr2t->data_offset + r2t->sent, r2t->data_count);\r\nrc = conn->session->tt->init_pdu(task, r2t->data_offset + r2t->sent,\r\nr2t->data_count);\r\nif (rc) {\r\niscsi_conn_failure(conn, ISCSI_ERR_XMIT_FAILED);\r\nreturn rc;\r\n}\r\nr2t->sent += r2t->data_count;\r\ngoto flush;\r\n}\r\nstruct iscsi_cls_conn *\r\niscsi_tcp_conn_setup(struct iscsi_cls_session *cls_session, int dd_data_size,\r\nuint32_t conn_idx)\r\n{\r\nstruct iscsi_conn *conn;\r\nstruct iscsi_cls_conn *cls_conn;\r\nstruct iscsi_tcp_conn *tcp_conn;\r\ncls_conn = iscsi_conn_setup(cls_session,\r\nsizeof(*tcp_conn) + dd_data_size, conn_idx);\r\nif (!cls_conn)\r\nreturn NULL;\r\nconn = cls_conn->dd_data;\r\nconn->max_recv_dlength = ISCSI_DEF_MAX_RECV_SEG_LEN;\r\ntcp_conn = conn->dd_data;\r\ntcp_conn->iscsi_conn = conn;\r\ntcp_conn->dd_data = conn->dd_data + sizeof(*tcp_conn);\r\nreturn cls_conn;\r\n}\r\nvoid iscsi_tcp_conn_teardown(struct iscsi_cls_conn *cls_conn)\r\n{\r\niscsi_conn_teardown(cls_conn);\r\n}\r\nint iscsi_tcp_r2tpool_alloc(struct iscsi_session *session)\r\n{\r\nint i;\r\nint cmd_i;\r\nfor (cmd_i = 0; cmd_i < session->cmds_max; cmd_i++) {\r\nstruct iscsi_task *task = session->cmds[cmd_i];\r\nstruct iscsi_tcp_task *tcp_task = task->dd_data;\r\nif (iscsi_pool_init(&tcp_task->r2tpool,\r\nsession->max_r2t * 2, NULL,\r\nsizeof(struct iscsi_r2t_info))) {\r\ngoto r2t_alloc_fail;\r\n}\r\nif (kfifo_alloc(&tcp_task->r2tqueue,\r\nsession->max_r2t * 4 * sizeof(void*), GFP_KERNEL)) {\r\niscsi_pool_free(&tcp_task->r2tpool);\r\ngoto r2t_alloc_fail;\r\n}\r\nspin_lock_init(&tcp_task->pool2queue);\r\nspin_lock_init(&tcp_task->queue2pool);\r\n}\r\nreturn 0;\r\nr2t_alloc_fail:\r\nfor (i = 0; i < cmd_i; i++) {\r\nstruct iscsi_task *task = session->cmds[i];\r\nstruct iscsi_tcp_task *tcp_task = task->dd_data;\r\nkfifo_free(&tcp_task->r2tqueue);\r\niscsi_pool_free(&tcp_task->r2tpool);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nvoid iscsi_tcp_r2tpool_free(struct iscsi_session *session)\r\n{\r\nint i;\r\nfor (i = 0; i < session->cmds_max; i++) {\r\nstruct iscsi_task *task = session->cmds[i];\r\nstruct iscsi_tcp_task *tcp_task = task->dd_data;\r\nkfifo_free(&tcp_task->r2tqueue);\r\niscsi_pool_free(&tcp_task->r2tpool);\r\n}\r\n}\r\nint iscsi_tcp_set_max_r2t(struct iscsi_conn *conn, char *buf)\r\n{\r\nstruct iscsi_session *session = conn->session;\r\nunsigned short r2ts = 0;\r\nsscanf(buf, "%hu", &r2ts);\r\nif (session->max_r2t == r2ts)\r\nreturn 0;\r\nif (!r2ts || !is_power_of_2(r2ts))\r\nreturn -EINVAL;\r\nsession->max_r2t = r2ts;\r\niscsi_tcp_r2tpool_free(session);\r\nreturn iscsi_tcp_r2tpool_alloc(session);\r\n}\r\nvoid iscsi_tcp_conn_get_stats(struct iscsi_cls_conn *cls_conn,\r\nstruct iscsi_stats *stats)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nstats->txdata_octets = conn->txdata_octets;\r\nstats->rxdata_octets = conn->rxdata_octets;\r\nstats->scsicmd_pdus = conn->scsicmd_pdus_cnt;\r\nstats->dataout_pdus = conn->dataout_pdus_cnt;\r\nstats->scsirsp_pdus = conn->scsirsp_pdus_cnt;\r\nstats->datain_pdus = conn->datain_pdus_cnt;\r\nstats->r2t_pdus = conn->r2t_pdus_cnt;\r\nstats->tmfcmd_pdus = conn->tmfcmd_pdus_cnt;\r\nstats->tmfrsp_pdus = conn->tmfrsp_pdus_cnt;\r\n}
