static int __init vsyscall_setup(char *str)\r\n{\r\nif (str) {\r\nif (!strcmp("emulate", str))\r\nvsyscall_mode = EMULATE;\r\nelse if (!strcmp("native", str))\r\nvsyscall_mode = NATIVE;\r\nelse if (!strcmp("none", str))\r\nvsyscall_mode = NONE;\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void warn_bad_vsyscall(const char *level, struct pt_regs *regs,\r\nconst char *message)\r\n{\r\nif (!show_unhandled_signals)\r\nreturn;\r\nprintk_ratelimited("%s%s[%d] %s ip:%lx cs:%lx sp:%lx ax:%lx si:%lx di:%lx\n",\r\nlevel, current->comm, task_pid_nr(current),\r\nmessage, regs->ip, regs->cs,\r\nregs->sp, regs->ax, regs->si, regs->di);\r\n}\r\nstatic int addr_to_vsyscall_nr(unsigned long addr)\r\n{\r\nint nr;\r\nif ((addr & ~0xC00UL) != VSYSCALL_ADDR)\r\nreturn -EINVAL;\r\nnr = (addr & 0xC00UL) >> 10;\r\nif (nr >= 3)\r\nreturn -EINVAL;\r\nreturn nr;\r\n}\r\nstatic bool write_ok_or_segv(unsigned long ptr, size_t size)\r\n{\r\nif (!access_ok(VERIFY_WRITE, (void __user *)ptr, size)) {\r\nsiginfo_t info;\r\nstruct thread_struct *thread = &current->thread;\r\nthread->error_code = 6;\r\nthread->cr2 = ptr;\r\nthread->trap_nr = X86_TRAP_PF;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.si_signo = SIGSEGV;\r\ninfo.si_errno = 0;\r\ninfo.si_code = SEGV_MAPERR;\r\ninfo.si_addr = (void __user *)ptr;\r\nforce_sig_info(SIGSEGV, &info, current);\r\nreturn false;\r\n} else {\r\nreturn true;\r\n}\r\n}\r\nbool emulate_vsyscall(struct pt_regs *regs, unsigned long address)\r\n{\r\nstruct task_struct *tsk;\r\nunsigned long caller;\r\nint vsyscall_nr, syscall_nr, tmp;\r\nint prev_sig_on_uaccess_err;\r\nlong ret;\r\nWARN_ON_ONCE(address != regs->ip);\r\nif (vsyscall_mode == NONE) {\r\nwarn_bad_vsyscall(KERN_INFO, regs,\r\n"vsyscall attempted with vsyscall=none");\r\nreturn false;\r\n}\r\nvsyscall_nr = addr_to_vsyscall_nr(address);\r\ntrace_emulate_vsyscall(vsyscall_nr);\r\nif (vsyscall_nr < 0) {\r\nwarn_bad_vsyscall(KERN_WARNING, regs,\r\n"misaligned vsyscall (exploit attempt or buggy program) -- look up the vsyscall kernel parameter if you need a workaround");\r\ngoto sigsegv;\r\n}\r\nif (get_user(caller, (unsigned long __user *)regs->sp) != 0) {\r\nwarn_bad_vsyscall(KERN_WARNING, regs,\r\n"vsyscall with bad stack (exploit attempt?)");\r\ngoto sigsegv;\r\n}\r\ntsk = current;\r\nswitch (vsyscall_nr) {\r\ncase 0:\r\nif (!write_ok_or_segv(regs->di, sizeof(struct timeval)) ||\r\n!write_ok_or_segv(regs->si, sizeof(struct timezone))) {\r\nret = -EFAULT;\r\ngoto check_fault;\r\n}\r\nsyscall_nr = __NR_gettimeofday;\r\nbreak;\r\ncase 1:\r\nif (!write_ok_or_segv(regs->di, sizeof(time_t))) {\r\nret = -EFAULT;\r\ngoto check_fault;\r\n}\r\nsyscall_nr = __NR_time;\r\nbreak;\r\ncase 2:\r\nif (!write_ok_or_segv(regs->di, sizeof(unsigned)) ||\r\n!write_ok_or_segv(regs->si, sizeof(unsigned))) {\r\nret = -EFAULT;\r\ngoto check_fault;\r\n}\r\nsyscall_nr = __NR_getcpu;\r\nbreak;\r\n}\r\nregs->orig_ax = syscall_nr;\r\nregs->ax = -ENOSYS;\r\ntmp = secure_computing(NULL);\r\nif ((!tmp && regs->orig_ax != syscall_nr) || regs->ip != address) {\r\nwarn_bad_vsyscall(KERN_DEBUG, regs,\r\n"seccomp tried to change syscall nr or ip");\r\ndo_exit(SIGSYS);\r\n}\r\nregs->orig_ax = -1;\r\nif (tmp)\r\ngoto do_ret;\r\nprev_sig_on_uaccess_err = current->thread.sig_on_uaccess_err;\r\ncurrent->thread.sig_on_uaccess_err = 1;\r\nret = -EFAULT;\r\nswitch (vsyscall_nr) {\r\ncase 0:\r\nret = sys_gettimeofday(\r\n(struct timeval __user *)regs->di,\r\n(struct timezone __user *)regs->si);\r\nbreak;\r\ncase 1:\r\nret = sys_time((time_t __user *)regs->di);\r\nbreak;\r\ncase 2:\r\nret = sys_getcpu((unsigned __user *)regs->di,\r\n(unsigned __user *)regs->si,\r\nNULL);\r\nbreak;\r\n}\r\ncurrent->thread.sig_on_uaccess_err = prev_sig_on_uaccess_err;\r\ncheck_fault:\r\nif (ret == -EFAULT) {\r\nwarn_bad_vsyscall(KERN_INFO, regs,\r\n"vsyscall fault (exploit attempt?)");\r\nif (WARN_ON_ONCE(!sigismember(&tsk->pending.signal, SIGBUS) &&\r\n!sigismember(&tsk->pending.signal, SIGSEGV)))\r\ngoto sigsegv;\r\nreturn true;\r\n}\r\nregs->ax = ret;\r\ndo_ret:\r\nregs->ip = caller;\r\nregs->sp += 8;\r\nreturn true;\r\nsigsegv:\r\nforce_sig(SIGSEGV, current);\r\nreturn true;\r\n}\r\nstatic const char *gate_vma_name(struct vm_area_struct *vma)\r\n{\r\nreturn "[vsyscall]";\r\n}\r\nstruct vm_area_struct *get_gate_vma(struct mm_struct *mm)\r\n{\r\n#ifdef CONFIG_COMPAT\r\nif (!mm || mm->context.ia32_compat)\r\nreturn NULL;\r\n#endif\r\nif (vsyscall_mode == NONE)\r\nreturn NULL;\r\nreturn &gate_vma;\r\n}\r\nint in_gate_area(struct mm_struct *mm, unsigned long addr)\r\n{\r\nstruct vm_area_struct *vma = get_gate_vma(mm);\r\nif (!vma)\r\nreturn 0;\r\nreturn (addr >= vma->vm_start) && (addr < vma->vm_end);\r\n}\r\nint in_gate_area_no_mm(unsigned long addr)\r\n{\r\nreturn vsyscall_mode != NONE && (addr & PAGE_MASK) == VSYSCALL_ADDR;\r\n}\r\nvoid __init map_vsyscall(void)\r\n{\r\nextern char __vsyscall_page;\r\nunsigned long physaddr_vsyscall = __pa_symbol(&__vsyscall_page);\r\nif (vsyscall_mode != NONE)\r\n__set_fixmap(VSYSCALL_PAGE, physaddr_vsyscall,\r\nvsyscall_mode == NATIVE\r\n? PAGE_KERNEL_VSYSCALL\r\n: PAGE_KERNEL_VVAR);\r\nBUILD_BUG_ON((unsigned long)__fix_to_virt(VSYSCALL_PAGE) !=\r\n(unsigned long)VSYSCALL_ADDR);\r\n}
