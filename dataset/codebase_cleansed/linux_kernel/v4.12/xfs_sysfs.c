static inline struct xfs_sysfs_attr *\r\nto_attr(struct attribute *attr)\r\n{\r\nreturn container_of(attr, struct xfs_sysfs_attr, attr);\r\n}\r\nSTATIC ssize_t\r\nxfs_sysfs_object_show(\r\nstruct kobject *kobject,\r\nstruct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct xfs_sysfs_attr *xfs_attr = to_attr(attr);\r\nreturn xfs_attr->show ? xfs_attr->show(kobject, buf) : 0;\r\n}\r\nSTATIC ssize_t\r\nxfs_sysfs_object_store(\r\nstruct kobject *kobject,\r\nstruct attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct xfs_sysfs_attr *xfs_attr = to_attr(attr);\r\nreturn xfs_attr->store ? xfs_attr->store(kobject, buf, count) : 0;\r\n}\r\nstatic inline struct xfs_mount *\r\nto_mp(struct kobject *kobject)\r\n{\r\nstruct xfs_kobj *kobj = to_kobj(kobject);\r\nreturn container_of(kobj, struct xfs_mount, m_kobj);\r\n}\r\nSTATIC ssize_t\r\ndrop_writes_store(\r\nstruct kobject *kobject,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct xfs_mount *mp = to_mp(kobject);\r\nint ret;\r\nint val;\r\nret = kstrtoint(buf, 0, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val == 1)\r\nmp->m_drop_writes = true;\r\nelse if (val == 0)\r\nmp->m_drop_writes = false;\r\nelse\r\nreturn -EINVAL;\r\nreturn count;\r\n}\r\nSTATIC ssize_t\r\ndrop_writes_show(\r\nstruct kobject *kobject,\r\nchar *buf)\r\n{\r\nstruct xfs_mount *mp = to_mp(kobject);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", mp->m_drop_writes ? 1 : 0);\r\n}\r\nSTATIC ssize_t\r\nlog_recovery_delay_store(\r\nstruct kobject *kobject,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nint ret;\r\nint val;\r\nret = kstrtoint(buf, 0, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val < 0 || val > 60)\r\nreturn -EINVAL;\r\nxfs_globals.log_recovery_delay = val;\r\nreturn count;\r\n}\r\nSTATIC ssize_t\r\nlog_recovery_delay_show(\r\nstruct kobject *kobject,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", xfs_globals.log_recovery_delay);\r\n}\r\nstatic inline struct xstats *\r\nto_xstats(struct kobject *kobject)\r\n{\r\nstruct xfs_kobj *kobj = to_kobj(kobject);\r\nreturn container_of(kobj, struct xstats, xs_kobj);\r\n}\r\nSTATIC ssize_t\r\nstats_show(\r\nstruct kobject *kobject,\r\nchar *buf)\r\n{\r\nstruct xstats *stats = to_xstats(kobject);\r\nreturn xfs_stats_format(stats->xs_stats, buf);\r\n}\r\nSTATIC ssize_t\r\nstats_clear_store(\r\nstruct kobject *kobject,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nint ret;\r\nint val;\r\nstruct xstats *stats = to_xstats(kobject);\r\nret = kstrtoint(buf, 0, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val != 1)\r\nreturn -EINVAL;\r\nxfs_stats_clearall(stats->xs_stats);\r\nreturn count;\r\n}\r\nstatic inline struct xlog *\r\nto_xlog(struct kobject *kobject)\r\n{\r\nstruct xfs_kobj *kobj = to_kobj(kobject);\r\nreturn container_of(kobj, struct xlog, l_kobj);\r\n}\r\nSTATIC ssize_t\r\nlog_head_lsn_show(\r\nstruct kobject *kobject,\r\nchar *buf)\r\n{\r\nint cycle;\r\nint block;\r\nstruct xlog *log = to_xlog(kobject);\r\nspin_lock(&log->l_icloglock);\r\ncycle = log->l_curr_cycle;\r\nblock = log->l_curr_block;\r\nspin_unlock(&log->l_icloglock);\r\nreturn snprintf(buf, PAGE_SIZE, "%d:%d\n", cycle, block);\r\n}\r\nSTATIC ssize_t\r\nlog_tail_lsn_show(\r\nstruct kobject *kobject,\r\nchar *buf)\r\n{\r\nint cycle;\r\nint block;\r\nstruct xlog *log = to_xlog(kobject);\r\nxlog_crack_atomic_lsn(&log->l_tail_lsn, &cycle, &block);\r\nreturn snprintf(buf, PAGE_SIZE, "%d:%d\n", cycle, block);\r\n}\r\nSTATIC ssize_t\r\nreserve_grant_head_show(\r\nstruct kobject *kobject,\r\nchar *buf)\r\n{\r\nint cycle;\r\nint bytes;\r\nstruct xlog *log = to_xlog(kobject);\r\nxlog_crack_grant_head(&log->l_reserve_head.grant, &cycle, &bytes);\r\nreturn snprintf(buf, PAGE_SIZE, "%d:%d\n", cycle, bytes);\r\n}\r\nSTATIC ssize_t\r\nwrite_grant_head_show(\r\nstruct kobject *kobject,\r\nchar *buf)\r\n{\r\nint cycle;\r\nint bytes;\r\nstruct xlog *log = to_xlog(kobject);\r\nxlog_crack_grant_head(&log->l_write_head.grant, &cycle, &bytes);\r\nreturn snprintf(buf, PAGE_SIZE, "%d:%d\n", cycle, bytes);\r\n}\r\nSTATIC ssize_t\r\nlog_badcrc_factor_store(\r\nstruct kobject *kobject,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct xlog *log = to_xlog(kobject);\r\nint ret;\r\nuint32_t val;\r\nret = kstrtouint(buf, 0, &val);\r\nif (ret)\r\nreturn ret;\r\nlog->l_badcrc_factor = val;\r\nreturn count;\r\n}\r\nSTATIC ssize_t\r\nlog_badcrc_factor_show(\r\nstruct kobject *kobject,\r\nchar *buf)\r\n{\r\nstruct xlog *log = to_xlog(kobject);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", log->l_badcrc_factor);\r\n}\r\nstatic inline struct xfs_error_cfg *\r\nto_error_cfg(struct kobject *kobject)\r\n{\r\nstruct xfs_kobj *kobj = to_kobj(kobject);\r\nreturn container_of(kobj, struct xfs_error_cfg, kobj);\r\n}\r\nstatic inline struct xfs_mount *\r\nerr_to_mp(struct kobject *kobject)\r\n{\r\nstruct xfs_kobj *kobj = to_kobj(kobject);\r\nreturn container_of(kobj, struct xfs_mount, m_error_kobj);\r\n}\r\nstatic ssize_t\r\nmax_retries_show(\r\nstruct kobject *kobject,\r\nchar *buf)\r\n{\r\nint retries;\r\nstruct xfs_error_cfg *cfg = to_error_cfg(kobject);\r\nif (cfg->max_retries == XFS_ERR_RETRY_FOREVER)\r\nretries = -1;\r\nelse\r\nretries = cfg->max_retries;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", retries);\r\n}\r\nstatic ssize_t\r\nmax_retries_store(\r\nstruct kobject *kobject,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct xfs_error_cfg *cfg = to_error_cfg(kobject);\r\nint ret;\r\nint val;\r\nret = kstrtoint(buf, 0, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val < -1)\r\nreturn -EINVAL;\r\nif (val == -1)\r\ncfg->max_retries = XFS_ERR_RETRY_FOREVER;\r\nelse\r\ncfg->max_retries = val;\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nretry_timeout_seconds_show(\r\nstruct kobject *kobject,\r\nchar *buf)\r\n{\r\nint timeout;\r\nstruct xfs_error_cfg *cfg = to_error_cfg(kobject);\r\nif (cfg->retry_timeout == XFS_ERR_RETRY_FOREVER)\r\ntimeout = -1;\r\nelse\r\ntimeout = jiffies_to_msecs(cfg->retry_timeout) / MSEC_PER_SEC;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", timeout);\r\n}\r\nstatic ssize_t\r\nretry_timeout_seconds_store(\r\nstruct kobject *kobject,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct xfs_error_cfg *cfg = to_error_cfg(kobject);\r\nint ret;\r\nint val;\r\nret = kstrtoint(buf, 0, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val < -1 || val > 86400)\r\nreturn -EINVAL;\r\nif (val == -1)\r\ncfg->retry_timeout = XFS_ERR_RETRY_FOREVER;\r\nelse {\r\ncfg->retry_timeout = msecs_to_jiffies(val * MSEC_PER_SEC);\r\nASSERT(msecs_to_jiffies(val * MSEC_PER_SEC) < LONG_MAX);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nfail_at_unmount_show(\r\nstruct kobject *kobject,\r\nchar *buf)\r\n{\r\nstruct xfs_mount *mp = err_to_mp(kobject);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", mp->m_fail_unmount);\r\n}\r\nstatic ssize_t\r\nfail_at_unmount_store(\r\nstruct kobject *kobject,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct xfs_mount *mp = err_to_mp(kobject);\r\nint ret;\r\nint val;\r\nret = kstrtoint(buf, 0, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val < 0 || val > 1)\r\nreturn -EINVAL;\r\nmp->m_fail_unmount = val;\r\nreturn count;\r\n}\r\nstatic int\r\nxfs_error_sysfs_init_class(\r\nstruct xfs_mount *mp,\r\nint class,\r\nconst char *parent_name,\r\nstruct xfs_kobj *parent_kobj,\r\nconst struct xfs_error_init init[])\r\n{\r\nstruct xfs_error_cfg *cfg;\r\nint error;\r\nint i;\r\nASSERT(class < XFS_ERR_CLASS_MAX);\r\nerror = xfs_sysfs_init(parent_kobj, &xfs_error_ktype,\r\n&mp->m_error_kobj, parent_name);\r\nif (error)\r\nreturn error;\r\nfor (i = 0; i < XFS_ERR_ERRNO_MAX; i++) {\r\ncfg = &mp->m_error_cfg[class][i];\r\nerror = xfs_sysfs_init(&cfg->kobj, &xfs_error_cfg_ktype,\r\nparent_kobj, init[i].name);\r\nif (error)\r\ngoto out_error;\r\ncfg->max_retries = init[i].max_retries;\r\nif (init[i].retry_timeout == XFS_ERR_RETRY_FOREVER)\r\ncfg->retry_timeout = XFS_ERR_RETRY_FOREVER;\r\nelse\r\ncfg->retry_timeout = msecs_to_jiffies(\r\ninit[i].retry_timeout * MSEC_PER_SEC);\r\n}\r\nreturn 0;\r\nout_error:\r\nfor (i--; i >= 0; i--) {\r\ncfg = &mp->m_error_cfg[class][i];\r\nxfs_sysfs_del(&cfg->kobj);\r\n}\r\nxfs_sysfs_del(parent_kobj);\r\nreturn error;\r\n}\r\nint\r\nxfs_error_sysfs_init(\r\nstruct xfs_mount *mp)\r\n{\r\nint error;\r\nerror = xfs_sysfs_init(&mp->m_error_kobj, &xfs_error_ktype,\r\n&mp->m_kobj, "error");\r\nif (error)\r\nreturn error;\r\nerror = sysfs_create_file(&mp->m_error_kobj.kobject,\r\nATTR_LIST(fail_at_unmount));\r\nif (error)\r\ngoto out_error;\r\nerror = xfs_error_sysfs_init_class(mp, XFS_ERR_METADATA,\r\n"metadata", &mp->m_error_meta_kobj,\r\nxfs_error_meta_init);\r\nif (error)\r\ngoto out_error;\r\nreturn 0;\r\nout_error:\r\nxfs_sysfs_del(&mp->m_error_kobj);\r\nreturn error;\r\n}\r\nvoid\r\nxfs_error_sysfs_del(\r\nstruct xfs_mount *mp)\r\n{\r\nstruct xfs_error_cfg *cfg;\r\nint i, j;\r\nfor (i = 0; i < XFS_ERR_CLASS_MAX; i++) {\r\nfor (j = 0; j < XFS_ERR_ERRNO_MAX; j++) {\r\ncfg = &mp->m_error_cfg[i][j];\r\nxfs_sysfs_del(&cfg->kobj);\r\n}\r\n}\r\nxfs_sysfs_del(&mp->m_error_meta_kobj);\r\nxfs_sysfs_del(&mp->m_error_kobj);\r\n}\r\nstruct xfs_error_cfg *\r\nxfs_error_get_cfg(\r\nstruct xfs_mount *mp,\r\nint error_class,\r\nint error)\r\n{\r\nstruct xfs_error_cfg *cfg;\r\nif (error < 0)\r\nerror = -error;\r\nswitch (error) {\r\ncase EIO:\r\ncfg = &mp->m_error_cfg[error_class][XFS_ERR_EIO];\r\nbreak;\r\ncase ENOSPC:\r\ncfg = &mp->m_error_cfg[error_class][XFS_ERR_ENOSPC];\r\nbreak;\r\ncase ENODEV:\r\ncfg = &mp->m_error_cfg[error_class][XFS_ERR_ENODEV];\r\nbreak;\r\ndefault:\r\ncfg = &mp->m_error_cfg[error_class][XFS_ERR_DEFAULT];\r\nbreak;\r\n}\r\nreturn cfg;\r\n}
