irqreturn_t octeon_i2c_isr(int irq, void *dev_id)\r\n{\r\nstruct octeon_i2c *i2c = dev_id;\r\ni2c->int_disable(i2c);\r\nwake_up(&i2c->queue);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic bool octeon_i2c_test_iflg(struct octeon_i2c *i2c)\r\n{\r\nreturn (octeon_i2c_ctl_read(i2c) & TWSI_CTL_IFLG);\r\n}\r\nstatic int octeon_i2c_wait(struct octeon_i2c *i2c)\r\n{\r\nlong time_left;\r\nif (i2c->broken_irq_mode) {\r\nu64 end = get_jiffies_64() + i2c->adap.timeout;\r\nwhile (!octeon_i2c_test_iflg(i2c) &&\r\ntime_before64(get_jiffies_64(), end))\r\nusleep_range(I2C_OCTEON_EVENT_WAIT / 2, I2C_OCTEON_EVENT_WAIT);\r\nreturn octeon_i2c_test_iflg(i2c) ? 0 : -ETIMEDOUT;\r\n}\r\ni2c->int_enable(i2c);\r\ntime_left = wait_event_timeout(i2c->queue, octeon_i2c_test_iflg(i2c),\r\ni2c->adap.timeout);\r\ni2c->int_disable(i2c);\r\nif (i2c->broken_irq_check && !time_left &&\r\nocteon_i2c_test_iflg(i2c)) {\r\ndev_err(i2c->dev, "broken irq connection detected, switching to polling mode.\n");\r\ni2c->broken_irq_mode = true;\r\nreturn 0;\r\n}\r\nif (!time_left)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic bool octeon_i2c_hlc_test_valid(struct octeon_i2c *i2c)\r\n{\r\nreturn (__raw_readq(i2c->twsi_base + SW_TWSI(i2c)) & SW_TWSI_V) == 0;\r\n}\r\nstatic void octeon_i2c_hlc_int_clear(struct octeon_i2c *i2c)\r\n{\r\nocteon_i2c_write_int(i2c, TWSI_INT_ST_INT | TWSI_INT_TS_INT);\r\n}\r\nstatic void octeon_i2c_hlc_enable(struct octeon_i2c *i2c)\r\n{\r\nint try = 0;\r\nu64 val;\r\nif (i2c->hlc_enabled)\r\nreturn;\r\ni2c->hlc_enabled = true;\r\nwhile (1) {\r\nval = octeon_i2c_ctl_read(i2c);\r\nif (!(val & (TWSI_CTL_STA | TWSI_CTL_STP)))\r\nbreak;\r\nif (val & TWSI_CTL_IFLG)\r\nocteon_i2c_ctl_write(i2c, TWSI_CTL_ENAB);\r\nif (try++ > 100) {\r\npr_err("%s: giving up\n", __func__);\r\nbreak;\r\n}\r\nudelay(10);\r\n}\r\nocteon_i2c_ctl_write(i2c, TWSI_CTL_CE | TWSI_CTL_AAK | TWSI_CTL_ENAB);\r\n}\r\nstatic void octeon_i2c_hlc_disable(struct octeon_i2c *i2c)\r\n{\r\nif (!i2c->hlc_enabled)\r\nreturn;\r\ni2c->hlc_enabled = false;\r\nocteon_i2c_ctl_write(i2c, TWSI_CTL_ENAB);\r\n}\r\nstatic int octeon_i2c_hlc_wait(struct octeon_i2c *i2c)\r\n{\r\nint time_left;\r\nif (i2c->broken_irq_mode) {\r\nu64 end = get_jiffies_64() + i2c->adap.timeout;\r\nwhile (!octeon_i2c_hlc_test_valid(i2c) &&\r\ntime_before64(get_jiffies_64(), end))\r\nusleep_range(I2C_OCTEON_EVENT_WAIT / 2, I2C_OCTEON_EVENT_WAIT);\r\nreturn octeon_i2c_hlc_test_valid(i2c) ? 0 : -ETIMEDOUT;\r\n}\r\ni2c->hlc_int_enable(i2c);\r\ntime_left = wait_event_timeout(i2c->queue,\r\nocteon_i2c_hlc_test_valid(i2c),\r\ni2c->adap.timeout);\r\ni2c->hlc_int_disable(i2c);\r\nif (!time_left)\r\nocteon_i2c_hlc_int_clear(i2c);\r\nif (i2c->broken_irq_check && !time_left &&\r\nocteon_i2c_hlc_test_valid(i2c)) {\r\ndev_err(i2c->dev, "broken irq connection detected, switching to polling mode.\n");\r\ni2c->broken_irq_mode = true;\r\nreturn 0;\r\n}\r\nif (!time_left)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int octeon_i2c_check_status(struct octeon_i2c *i2c, int final_read)\r\n{\r\nu8 stat;\r\nif (i2c->hlc_enabled)\r\nstat = __raw_readq(i2c->twsi_base + SW_TWSI(i2c));\r\nelse\r\nstat = octeon_i2c_stat_read(i2c);\r\nswitch (stat) {\r\ncase STAT_IDLE:\r\ncase STAT_AD2W_ACK:\r\ncase STAT_RXADDR_ACK:\r\ncase STAT_TXADDR_ACK:\r\ncase STAT_TXDATA_ACK:\r\nreturn 0;\r\ncase STAT_RXDATA_ACK:\r\nif (!final_read)\r\nreturn 0;\r\nreturn -EIO;\r\ncase STAT_RXDATA_NAK:\r\nif (final_read)\r\nreturn 0;\r\nreturn -EIO;\r\ncase STAT_LOST_ARB_38:\r\ncase STAT_LOST_ARB_68:\r\ncase STAT_LOST_ARB_78:\r\ncase STAT_LOST_ARB_B0:\r\nreturn -EAGAIN;\r\ncase STAT_SLAVE_60:\r\ncase STAT_SLAVE_70:\r\ncase STAT_GENDATA_ACK:\r\ncase STAT_GENDATA_NAK:\r\nreturn -EOPNOTSUPP;\r\ncase STAT_SLAVE_80:\r\ncase STAT_SLAVE_88:\r\ncase STAT_SLAVE_A0:\r\ncase STAT_SLAVE_A8:\r\ncase STAT_SLAVE_LOST:\r\ncase STAT_SLAVE_NAK:\r\ncase STAT_SLAVE_ACK:\r\nreturn -EOPNOTSUPP;\r\ncase STAT_TXDATA_NAK:\r\nreturn -EIO;\r\ncase STAT_TXADDR_NAK:\r\ncase STAT_RXADDR_NAK:\r\ncase STAT_AD2W_NAK:\r\nreturn -ENXIO;\r\ndefault:\r\ndev_err(i2c->dev, "unhandled state: %d\n", stat);\r\nreturn -EIO;\r\n}\r\n}\r\nstatic int octeon_i2c_recovery(struct octeon_i2c *i2c)\r\n{\r\nint ret;\r\nret = i2c_recover_bus(&i2c->adap);\r\nif (ret)\r\nret = octeon_i2c_init_lowlevel(i2c);\r\nreturn ret;\r\n}\r\nstatic int octeon_i2c_start(struct octeon_i2c *i2c)\r\n{\r\nint ret;\r\nu8 stat;\r\nocteon_i2c_hlc_disable(i2c);\r\nocteon_i2c_ctl_write(i2c, TWSI_CTL_ENAB | TWSI_CTL_STA);\r\nret = octeon_i2c_wait(i2c);\r\nif (ret)\r\ngoto error;\r\nstat = octeon_i2c_stat_read(i2c);\r\nif (stat == STAT_START || stat == STAT_REP_START)\r\nreturn 0;\r\nerror:\r\nret = octeon_i2c_recovery(i2c);\r\nreturn (ret) ? ret : -EAGAIN;\r\n}\r\nstatic void octeon_i2c_stop(struct octeon_i2c *i2c)\r\n{\r\nocteon_i2c_ctl_write(i2c, TWSI_CTL_ENAB | TWSI_CTL_STP);\r\n}\r\nstatic int octeon_i2c_read(struct octeon_i2c *i2c, int target,\r\nu8 *data, u16 *rlength, bool recv_len)\r\n{\r\nint i, result, length = *rlength;\r\nbool final_read = false;\r\nocteon_i2c_data_write(i2c, (target << 1) | 1);\r\nocteon_i2c_ctl_write(i2c, TWSI_CTL_ENAB);\r\nresult = octeon_i2c_wait(i2c);\r\nif (result)\r\nreturn result;\r\nresult = octeon_i2c_check_status(i2c, false);\r\nif (result)\r\nreturn result;\r\nfor (i = 0; i < length; i++) {\r\nif ((i + 1 == length) && !(recv_len && i == 0))\r\nfinal_read = true;\r\nif (final_read)\r\nocteon_i2c_ctl_write(i2c, TWSI_CTL_ENAB);\r\nelse\r\nocteon_i2c_ctl_write(i2c, TWSI_CTL_ENAB | TWSI_CTL_AAK);\r\nresult = octeon_i2c_wait(i2c);\r\nif (result)\r\nreturn result;\r\ndata[i] = octeon_i2c_data_read(i2c, &result);\r\nif (result)\r\nreturn result;\r\nif (recv_len && i == 0) {\r\nif (data[i] > I2C_SMBUS_BLOCK_MAX + 1)\r\nreturn -EPROTO;\r\nlength += data[i];\r\n}\r\nresult = octeon_i2c_check_status(i2c, final_read);\r\nif (result)\r\nreturn result;\r\n}\r\n*rlength = length;\r\nreturn 0;\r\n}\r\nstatic int octeon_i2c_write(struct octeon_i2c *i2c, int target,\r\nconst u8 *data, int length)\r\n{\r\nint i, result;\r\nocteon_i2c_data_write(i2c, target << 1);\r\nocteon_i2c_ctl_write(i2c, TWSI_CTL_ENAB);\r\nresult = octeon_i2c_wait(i2c);\r\nif (result)\r\nreturn result;\r\nfor (i = 0; i < length; i++) {\r\nresult = octeon_i2c_check_status(i2c, false);\r\nif (result)\r\nreturn result;\r\nocteon_i2c_data_write(i2c, data[i]);\r\nocteon_i2c_ctl_write(i2c, TWSI_CTL_ENAB);\r\nresult = octeon_i2c_wait(i2c);\r\nif (result)\r\nreturn result;\r\n}\r\nreturn 0;\r\n}\r\nstatic int octeon_i2c_hlc_read(struct octeon_i2c *i2c, struct i2c_msg *msgs)\r\n{\r\nint i, j, ret = 0;\r\nu64 cmd;\r\nocteon_i2c_hlc_enable(i2c);\r\nocteon_i2c_hlc_int_clear(i2c);\r\ncmd = SW_TWSI_V | SW_TWSI_R | SW_TWSI_SOVR;\r\ncmd |= (u64)(msgs[0].len - 1) << SW_TWSI_SIZE_SHIFT;\r\ncmd |= (u64)(msgs[0].addr & 0x7full) << SW_TWSI_ADDR_SHIFT;\r\nif (msgs[0].flags & I2C_M_TEN)\r\ncmd |= SW_TWSI_OP_10;\r\nelse\r\ncmd |= SW_TWSI_OP_7;\r\nocteon_i2c_writeq_flush(cmd, i2c->twsi_base + SW_TWSI(i2c));\r\nret = octeon_i2c_hlc_wait(i2c);\r\nif (ret)\r\ngoto err;\r\ncmd = __raw_readq(i2c->twsi_base + SW_TWSI(i2c));\r\nif ((cmd & SW_TWSI_R) == 0)\r\nreturn octeon_i2c_check_status(i2c, false);\r\nfor (i = 0, j = msgs[0].len - 1; i < msgs[0].len && i < 4; i++, j--)\r\nmsgs[0].buf[j] = (cmd >> (8 * i)) & 0xff;\r\nif (msgs[0].len > 4) {\r\ncmd = __raw_readq(i2c->twsi_base + SW_TWSI_EXT(i2c));\r\nfor (i = 0; i < msgs[0].len - 4 && i < 4; i++, j--)\r\nmsgs[0].buf[j] = (cmd >> (8 * i)) & 0xff;\r\n}\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int octeon_i2c_hlc_write(struct octeon_i2c *i2c, struct i2c_msg *msgs)\r\n{\r\nint i, j, ret = 0;\r\nu64 cmd;\r\nocteon_i2c_hlc_enable(i2c);\r\nocteon_i2c_hlc_int_clear(i2c);\r\ncmd = SW_TWSI_V | SW_TWSI_SOVR;\r\ncmd |= (u64)(msgs[0].len - 1) << SW_TWSI_SIZE_SHIFT;\r\ncmd |= (u64)(msgs[0].addr & 0x7full) << SW_TWSI_ADDR_SHIFT;\r\nif (msgs[0].flags & I2C_M_TEN)\r\ncmd |= SW_TWSI_OP_10;\r\nelse\r\ncmd |= SW_TWSI_OP_7;\r\nfor (i = 0, j = msgs[0].len - 1; i < msgs[0].len && i < 4; i++, j--)\r\ncmd |= (u64)msgs[0].buf[j] << (8 * i);\r\nif (msgs[0].len > 4) {\r\nu64 ext = 0;\r\nfor (i = 0; i < msgs[0].len - 4 && i < 4; i++, j--)\r\next |= (u64)msgs[0].buf[j] << (8 * i);\r\nocteon_i2c_writeq_flush(ext, i2c->twsi_base + SW_TWSI_EXT(i2c));\r\n}\r\nocteon_i2c_writeq_flush(cmd, i2c->twsi_base + SW_TWSI(i2c));\r\nret = octeon_i2c_hlc_wait(i2c);\r\nif (ret)\r\ngoto err;\r\ncmd = __raw_readq(i2c->twsi_base + SW_TWSI(i2c));\r\nif ((cmd & SW_TWSI_R) == 0)\r\nreturn octeon_i2c_check_status(i2c, false);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int octeon_i2c_hlc_comp_read(struct octeon_i2c *i2c, struct i2c_msg *msgs)\r\n{\r\nint i, j, ret = 0;\r\nu64 cmd;\r\nocteon_i2c_hlc_enable(i2c);\r\ncmd = SW_TWSI_V | SW_TWSI_R | SW_TWSI_SOVR;\r\ncmd |= (u64)(msgs[1].len - 1) << SW_TWSI_SIZE_SHIFT;\r\ncmd |= (u64)(msgs[0].addr & 0x7full) << SW_TWSI_ADDR_SHIFT;\r\nif (msgs[0].flags & I2C_M_TEN)\r\ncmd |= SW_TWSI_OP_10_IA;\r\nelse\r\ncmd |= SW_TWSI_OP_7_IA;\r\nif (msgs[0].len == 2) {\r\nu64 ext = 0;\r\ncmd |= SW_TWSI_EIA;\r\next = (u64)msgs[0].buf[0] << SW_TWSI_IA_SHIFT;\r\ncmd |= (u64)msgs[0].buf[1] << SW_TWSI_IA_SHIFT;\r\nocteon_i2c_writeq_flush(ext, i2c->twsi_base + SW_TWSI_EXT(i2c));\r\n} else {\r\ncmd |= (u64)msgs[0].buf[0] << SW_TWSI_IA_SHIFT;\r\n}\r\nocteon_i2c_hlc_int_clear(i2c);\r\nocteon_i2c_writeq_flush(cmd, i2c->twsi_base + SW_TWSI(i2c));\r\nret = octeon_i2c_hlc_wait(i2c);\r\nif (ret)\r\ngoto err;\r\ncmd = __raw_readq(i2c->twsi_base + SW_TWSI(i2c));\r\nif ((cmd & SW_TWSI_R) == 0)\r\nreturn octeon_i2c_check_status(i2c, false);\r\nfor (i = 0, j = msgs[1].len - 1; i < msgs[1].len && i < 4; i++, j--)\r\nmsgs[1].buf[j] = (cmd >> (8 * i)) & 0xff;\r\nif (msgs[1].len > 4) {\r\ncmd = __raw_readq(i2c->twsi_base + SW_TWSI_EXT(i2c));\r\nfor (i = 0; i < msgs[1].len - 4 && i < 4; i++, j--)\r\nmsgs[1].buf[j] = (cmd >> (8 * i)) & 0xff;\r\n}\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int octeon_i2c_hlc_comp_write(struct octeon_i2c *i2c, struct i2c_msg *msgs)\r\n{\r\nbool set_ext = false;\r\nint i, j, ret = 0;\r\nu64 cmd, ext = 0;\r\nocteon_i2c_hlc_enable(i2c);\r\ncmd = SW_TWSI_V | SW_TWSI_SOVR;\r\ncmd |= (u64)(msgs[1].len - 1) << SW_TWSI_SIZE_SHIFT;\r\ncmd |= (u64)(msgs[0].addr & 0x7full) << SW_TWSI_ADDR_SHIFT;\r\nif (msgs[0].flags & I2C_M_TEN)\r\ncmd |= SW_TWSI_OP_10_IA;\r\nelse\r\ncmd |= SW_TWSI_OP_7_IA;\r\nif (msgs[0].len == 2) {\r\ncmd |= SW_TWSI_EIA;\r\next |= (u64)msgs[0].buf[0] << SW_TWSI_IA_SHIFT;\r\nset_ext = true;\r\ncmd |= (u64)msgs[0].buf[1] << SW_TWSI_IA_SHIFT;\r\n} else {\r\ncmd |= (u64)msgs[0].buf[0] << SW_TWSI_IA_SHIFT;\r\n}\r\nfor (i = 0, j = msgs[1].len - 1; i < msgs[1].len && i < 4; i++, j--)\r\ncmd |= (u64)msgs[1].buf[j] << (8 * i);\r\nif (msgs[1].len > 4) {\r\nfor (i = 0; i < msgs[1].len - 4 && i < 4; i++, j--)\r\next |= (u64)msgs[1].buf[j] << (8 * i);\r\nset_ext = true;\r\n}\r\nif (set_ext)\r\nocteon_i2c_writeq_flush(ext, i2c->twsi_base + SW_TWSI_EXT(i2c));\r\nocteon_i2c_hlc_int_clear(i2c);\r\nocteon_i2c_writeq_flush(cmd, i2c->twsi_base + SW_TWSI(i2c));\r\nret = octeon_i2c_hlc_wait(i2c);\r\nif (ret)\r\ngoto err;\r\ncmd = __raw_readq(i2c->twsi_base + SW_TWSI(i2c));\r\nif ((cmd & SW_TWSI_R) == 0)\r\nreturn octeon_i2c_check_status(i2c, false);\r\nerr:\r\nreturn ret;\r\n}\r\nint octeon_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\r\n{\r\nstruct octeon_i2c *i2c = i2c_get_adapdata(adap);\r\nint i, ret = 0;\r\nif (num == 1) {\r\nif (msgs[0].len > 0 && msgs[0].len <= 8) {\r\nif (msgs[0].flags & I2C_M_RD)\r\nret = octeon_i2c_hlc_read(i2c, msgs);\r\nelse\r\nret = octeon_i2c_hlc_write(i2c, msgs);\r\ngoto out;\r\n}\r\n} else if (num == 2) {\r\nif ((msgs[0].flags & I2C_M_RD) == 0 &&\r\n(msgs[1].flags & I2C_M_RECV_LEN) == 0 &&\r\nmsgs[0].len > 0 && msgs[0].len <= 2 &&\r\nmsgs[1].len > 0 && msgs[1].len <= 8 &&\r\nmsgs[0].addr == msgs[1].addr) {\r\nif (msgs[1].flags & I2C_M_RD)\r\nret = octeon_i2c_hlc_comp_read(i2c, msgs);\r\nelse\r\nret = octeon_i2c_hlc_comp_write(i2c, msgs);\r\ngoto out;\r\n}\r\n}\r\nfor (i = 0; ret == 0 && i < num; i++) {\r\nstruct i2c_msg *pmsg = &msgs[i];\r\nif (!pmsg->len) {\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nret = octeon_i2c_start(i2c);\r\nif (ret)\r\nreturn ret;\r\nif (pmsg->flags & I2C_M_RD)\r\nret = octeon_i2c_read(i2c, pmsg->addr, pmsg->buf,\r\n&pmsg->len, pmsg->flags & I2C_M_RECV_LEN);\r\nelse\r\nret = octeon_i2c_write(i2c, pmsg->addr, pmsg->buf,\r\npmsg->len);\r\n}\r\nocteon_i2c_stop(i2c);\r\nout:\r\nreturn (ret != 0) ? ret : num;\r\n}\r\nvoid octeon_i2c_set_clock(struct octeon_i2c *i2c)\r\n{\r\nint tclk, thp_base, inc, thp_idx, mdiv_idx, ndiv_idx, foscl, diff;\r\nint thp = 0x18, mdiv = 2, ndiv = 0, delta_hz = 1000000;\r\nfor (ndiv_idx = 0; ndiv_idx < 8 && delta_hz != 0; ndiv_idx++) {\r\nfor (mdiv_idx = 15; mdiv_idx >= 2 && delta_hz != 0; mdiv_idx--) {\r\ntclk = i2c->twsi_freq * (mdiv_idx + 1) * 10;\r\ntclk *= (1 << ndiv_idx);\r\nthp_base = (i2c->sys_freq / (tclk * 2)) - 1;\r\nfor (inc = 0; inc <= 1; inc++) {\r\nthp_idx = thp_base + inc;\r\nif (thp_idx < 5 || thp_idx > 0xff)\r\ncontinue;\r\nfoscl = i2c->sys_freq / (2 * (thp_idx + 1));\r\nfoscl = foscl / (1 << ndiv_idx);\r\nfoscl = foscl / (mdiv_idx + 1) / 10;\r\ndiff = abs(foscl - i2c->twsi_freq);\r\nif (diff < delta_hz) {\r\ndelta_hz = diff;\r\nthp = thp_idx;\r\nmdiv = mdiv_idx;\r\nndiv = ndiv_idx;\r\n}\r\n}\r\n}\r\n}\r\nocteon_i2c_reg_write(i2c, SW_TWSI_OP_TWSI_CLK, thp);\r\nocteon_i2c_reg_write(i2c, SW_TWSI_EOP_TWSI_CLKCTL, (mdiv << 3) | ndiv);\r\n}\r\nint octeon_i2c_init_lowlevel(struct octeon_i2c *i2c)\r\n{\r\nu8 status = 0;\r\nint tries;\r\nocteon_i2c_reg_write(i2c, SW_TWSI_EOP_TWSI_RST, 0);\r\nfor (tries = 10; tries && status != STAT_IDLE; tries--) {\r\nudelay(1);\r\nstatus = octeon_i2c_stat_read(i2c);\r\nif (status == STAT_IDLE)\r\nbreak;\r\n}\r\nif (status != STAT_IDLE) {\r\ndev_err(i2c->dev, "%s: TWSI_RST failed! (0x%x)\n",\r\n__func__, status);\r\nreturn -EIO;\r\n}\r\nocteon_i2c_hlc_enable(i2c);\r\nocteon_i2c_hlc_disable(i2c);\r\nreturn 0;\r\n}\r\nstatic int octeon_i2c_get_scl(struct i2c_adapter *adap)\r\n{\r\nstruct octeon_i2c *i2c = i2c_get_adapdata(adap);\r\nu64 state;\r\nstate = octeon_i2c_read_int(i2c);\r\nreturn state & TWSI_INT_SCL;\r\n}\r\nstatic void octeon_i2c_set_scl(struct i2c_adapter *adap, int val)\r\n{\r\nstruct octeon_i2c *i2c = i2c_get_adapdata(adap);\r\nocteon_i2c_write_int(i2c, val ? 0 : TWSI_INT_SCL_OVR);\r\n}\r\nstatic int octeon_i2c_get_sda(struct i2c_adapter *adap)\r\n{\r\nstruct octeon_i2c *i2c = i2c_get_adapdata(adap);\r\nu64 state;\r\nstate = octeon_i2c_read_int(i2c);\r\nreturn state & TWSI_INT_SDA;\r\n}\r\nstatic void octeon_i2c_prepare_recovery(struct i2c_adapter *adap)\r\n{\r\nstruct octeon_i2c *i2c = i2c_get_adapdata(adap);\r\nocteon_i2c_hlc_disable(i2c);\r\nocteon_i2c_reg_write(i2c, SW_TWSI_EOP_TWSI_RST, 0);\r\nudelay(5);\r\nocteon_i2c_ctl_write(i2c, TWSI_CTL_ENAB);\r\nocteon_i2c_write_int(i2c, 0);\r\n}\r\nstatic void octeon_i2c_unprepare_recovery(struct i2c_adapter *adap)\r\n{\r\nstruct octeon_i2c *i2c = i2c_get_adapdata(adap);\r\nocteon_i2c_write_int(i2c, TWSI_INT_SDA_OVR | TWSI_INT_SCL_OVR);\r\nudelay(5);\r\nocteon_i2c_write_int(i2c, TWSI_INT_SDA_OVR);\r\nudelay(5);\r\nocteon_i2c_write_int(i2c, 0);\r\n}
