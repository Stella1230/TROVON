static int mt8173_afe_i2s_fs(unsigned int sample_rate)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(mt8173_afe_i2s_rates); i++)\r\nif (mt8173_afe_i2s_rates[i].rate == sample_rate)\r\nreturn mt8173_afe_i2s_rates[i].regvalue;\r\nreturn -EINVAL;\r\n}\r\nstatic int mt8173_afe_set_i2s(struct mtk_base_afe *afe, unsigned int rate)\r\n{\r\nunsigned int val;\r\nint fs = mt8173_afe_i2s_fs(rate);\r\nif (fs < 0)\r\nreturn -EINVAL;\r\nregmap_update_bits(afe->regmap, AFE_ADDA_TOP_CON0, 0x1, 0x1);\r\nregmap_update_bits(afe->regmap, AFE_ADDA2_TOP_CON0, 0x1, 0x1);\r\nval = AFE_I2S_CON2_LOW_JITTER_CLK |\r\nAFE_I2S_CON2_RATE(fs) |\r\nAFE_I2S_CON2_FORMAT_I2S;\r\nregmap_update_bits(afe->regmap, AFE_I2S_CON2, ~AFE_I2S_CON2_EN, val);\r\nval = AFE_I2S_CON1_LOW_JITTER_CLK |\r\nAFE_I2S_CON1_RATE(fs) |\r\nAFE_I2S_CON1_FORMAT_I2S;\r\nregmap_update_bits(afe->regmap, AFE_I2S_CON1, ~AFE_I2S_CON1_EN, val);\r\nreturn 0;\r\n}\r\nstatic void mt8173_afe_set_i2s_enable(struct mtk_base_afe *afe, bool enable)\r\n{\r\nunsigned int val;\r\nregmap_read(afe->regmap, AFE_I2S_CON2, &val);\r\nif (!!(val & AFE_I2S_CON2_EN) == enable)\r\nreturn;\r\nregmap_update_bits(afe->regmap, AFE_I2S_CON2, 0x1, enable);\r\nregmap_update_bits(afe->regmap, AFE_I2S_CON1, 0x1, enable);\r\n}\r\nstatic int mt8173_afe_dais_enable_clks(struct mtk_base_afe *afe,\r\nstruct clk *m_ck, struct clk *b_ck)\r\n{\r\nint ret;\r\nif (m_ck) {\r\nret = clk_prepare_enable(m_ck);\r\nif (ret) {\r\ndev_err(afe->dev, "Failed to enable m_ck\n");\r\nreturn ret;\r\n}\r\n}\r\nif (b_ck) {\r\nret = clk_prepare_enable(b_ck);\r\nif (ret) {\r\ndev_err(afe->dev, "Failed to enable b_ck\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mt8173_afe_dais_set_clks(struct mtk_base_afe *afe,\r\nstruct clk *m_ck, unsigned int mck_rate,\r\nstruct clk *b_ck, unsigned int bck_rate)\r\n{\r\nint ret;\r\nif (m_ck) {\r\nret = clk_set_rate(m_ck, mck_rate);\r\nif (ret) {\r\ndev_err(afe->dev, "Failed to set m_ck rate\n");\r\nreturn ret;\r\n}\r\n}\r\nif (b_ck) {\r\nret = clk_set_rate(b_ck, bck_rate);\r\nif (ret) {\r\ndev_err(afe->dev, "Failed to set b_ck rate\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void mt8173_afe_dais_disable_clks(struct mtk_base_afe *afe,\r\nstruct clk *m_ck, struct clk *b_ck)\r\n{\r\nif (m_ck)\r\nclk_disable_unprepare(m_ck);\r\nif (b_ck)\r\nclk_disable_unprepare(b_ck);\r\n}\r\nstatic int mt8173_afe_i2s_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_base_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nif (dai->active)\r\nreturn 0;\r\nregmap_update_bits(afe->regmap, AUDIO_TOP_CON0,\r\nAUD_TCON0_PDN_22M | AUD_TCON0_PDN_24M, 0);\r\nreturn 0;\r\n}\r\nstatic void mt8173_afe_i2s_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_base_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nif (dai->active)\r\nreturn;\r\nmt8173_afe_set_i2s_enable(afe, false);\r\nregmap_update_bits(afe->regmap, AUDIO_TOP_CON0,\r\nAUD_TCON0_PDN_22M | AUD_TCON0_PDN_24M,\r\nAUD_TCON0_PDN_22M | AUD_TCON0_PDN_24M);\r\n}\r\nstatic int mt8173_afe_i2s_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_pcm_runtime * const runtime = substream->runtime;\r\nstruct mtk_base_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nstruct mt8173_afe_private *afe_priv = afe->platform_priv;\r\nint ret;\r\nmt8173_afe_dais_set_clks(afe, afe_priv->clocks[MT8173_CLK_I2S1_M],\r\nruntime->rate * 256, NULL, 0);\r\nmt8173_afe_dais_set_clks(afe, afe_priv->clocks[MT8173_CLK_I2S2_M],\r\nruntime->rate * 256, NULL, 0);\r\nret = mt8173_afe_set_i2s(afe, substream->runtime->rate);\r\nif (ret)\r\nreturn ret;\r\nmt8173_afe_set_i2s_enable(afe, true);\r\nreturn 0;\r\n}\r\nstatic int mt8173_afe_hdmi_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_base_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nstruct mt8173_afe_private *afe_priv = afe->platform_priv;\r\nif (dai->active)\r\nreturn 0;\r\nmt8173_afe_dais_enable_clks(afe, afe_priv->clocks[MT8173_CLK_I2S3_M],\r\nafe_priv->clocks[MT8173_CLK_I2S3_B]);\r\nreturn 0;\r\n}\r\nstatic void mt8173_afe_hdmi_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_base_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nstruct mt8173_afe_private *afe_priv = afe->platform_priv;\r\nif (dai->active)\r\nreturn;\r\nmt8173_afe_dais_disable_clks(afe, afe_priv->clocks[MT8173_CLK_I2S3_M],\r\nafe_priv->clocks[MT8173_CLK_I2S3_B]);\r\n}\r\nstatic int mt8173_afe_hdmi_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_pcm_runtime * const runtime = substream->runtime;\r\nstruct mtk_base_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nstruct mt8173_afe_private *afe_priv = afe->platform_priv;\r\nunsigned int val;\r\nmt8173_afe_dais_set_clks(afe, afe_priv->clocks[MT8173_CLK_I2S3_M],\r\nruntime->rate * 128,\r\nafe_priv->clocks[MT8173_CLK_I2S3_B],\r\nruntime->rate * runtime->channels * 32);\r\nval = AFE_TDM_CON1_BCK_INV |\r\nAFE_TDM_CON1_LRCK_INV |\r\nAFE_TDM_CON1_1_BCK_DELAY |\r\nAFE_TDM_CON1_MSB_ALIGNED |\r\nAFE_TDM_CON1_WLEN_32BIT |\r\nAFE_TDM_CON1_32_BCK_CYCLES |\r\nAFE_TDM_CON1_LRCK_WIDTH(32);\r\nregmap_update_bits(afe->regmap, AFE_TDM_CON1, ~AFE_TDM_CON1_EN, val);\r\nswitch (runtime->channels) {\r\ncase 1:\r\ncase 2:\r\nval = AFE_TDM_CH_START_O30_O31;\r\nval |= (AFE_TDM_CH_ZERO << 4);\r\nval |= (AFE_TDM_CH_ZERO << 8);\r\nval |= (AFE_TDM_CH_ZERO << 12);\r\nbreak;\r\ncase 3:\r\ncase 4:\r\nval = AFE_TDM_CH_START_O30_O31;\r\nval |= (AFE_TDM_CH_START_O32_O33 << 4);\r\nval |= (AFE_TDM_CH_ZERO << 8);\r\nval |= (AFE_TDM_CH_ZERO << 12);\r\nbreak;\r\ncase 5:\r\ncase 6:\r\nval = AFE_TDM_CH_START_O30_O31;\r\nval |= (AFE_TDM_CH_START_O32_O33 << 4);\r\nval |= (AFE_TDM_CH_START_O34_O35 << 8);\r\nval |= (AFE_TDM_CH_ZERO << 12);\r\nbreak;\r\ncase 7:\r\ncase 8:\r\nval = AFE_TDM_CH_START_O30_O31;\r\nval |= (AFE_TDM_CH_START_O32_O33 << 4);\r\nval |= (AFE_TDM_CH_START_O34_O35 << 8);\r\nval |= (AFE_TDM_CH_START_O36_O37 << 12);\r\nbreak;\r\ndefault:\r\nval = 0;\r\n}\r\nregmap_update_bits(afe->regmap, AFE_TDM_CON2, 0x0000ffff, val);\r\nregmap_update_bits(afe->regmap, AFE_HDMI_OUT_CON0,\r\n0x000000f0, runtime->channels << 4);\r\nreturn 0;\r\n}\r\nstatic int mt8173_afe_hdmi_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_base_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\ndev_info(afe->dev, "%s cmd=%d %s\n", __func__, cmd, dai->name);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nregmap_update_bits(afe->regmap, AUDIO_TOP_CON0,\r\nAUD_TCON0_PDN_HDMI | AUD_TCON0_PDN_SPDF, 0);\r\nregmap_write(afe->regmap, AFE_HDMI_CONN0,\r\nAFE_HDMI_CONN0_O30_I30 |\r\nAFE_HDMI_CONN0_O31_I31 |\r\nAFE_HDMI_CONN0_O32_I34 |\r\nAFE_HDMI_CONN0_O33_I35 |\r\nAFE_HDMI_CONN0_O34_I32 |\r\nAFE_HDMI_CONN0_O35_I33 |\r\nAFE_HDMI_CONN0_O36_I36 |\r\nAFE_HDMI_CONN0_O37_I37);\r\nregmap_update_bits(afe->regmap, AFE_HDMI_OUT_CON0, 0x1, 0x1);\r\nregmap_update_bits(afe->regmap, AFE_TDM_CON1, 0x1, 0x1);\r\nreturn 0;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nregmap_update_bits(afe->regmap, AFE_TDM_CON1, 0x1, 0);\r\nregmap_update_bits(afe->regmap, AFE_HDMI_OUT_CON0, 0x1, 0);\r\nregmap_update_bits(afe->regmap, AUDIO_TOP_CON0,\r\nAUD_TCON0_PDN_HDMI | AUD_TCON0_PDN_SPDF,\r\nAUD_TCON0_PDN_HDMI | AUD_TCON0_PDN_SPDF);\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int mt8173_memif_fs(struct snd_pcm_substream *substream,\r\nunsigned int rate)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_base_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nstruct mtk_base_afe_memif *memif = &afe->memif[rtd->cpu_dai->id];\r\nint fs;\r\nif (memif->data->id == MT8173_AFE_MEMIF_DAI ||\r\nmemif->data->id == MT8173_AFE_MEMIF_MOD_DAI) {\r\nswitch (rate) {\r\ncase 8000:\r\nfs = 0;\r\nbreak;\r\ncase 16000:\r\nfs = 1;\r\nbreak;\r\ncase 32000:\r\nfs = 2;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nfs = mt8173_afe_i2s_fs(rate);\r\n}\r\nreturn fs;\r\n}\r\nstatic int mt8173_irq_fs(struct snd_pcm_substream *substream, unsigned int rate)\r\n{\r\nreturn mt8173_afe_i2s_fs(rate);\r\n}\r\nstatic irqreturn_t mt8173_afe_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct mtk_base_afe *afe = dev_id;\r\nunsigned int reg_value;\r\nint i, ret;\r\nret = regmap_read(afe->regmap, AFE_IRQ_STATUS, &reg_value);\r\nif (ret) {\r\ndev_err(afe->dev, "%s irq status err\n", __func__);\r\nreg_value = AFE_IRQ_STATUS_BITS;\r\ngoto err_irq;\r\n}\r\nfor (i = 0; i < MT8173_AFE_MEMIF_NUM; i++) {\r\nstruct mtk_base_afe_memif *memif = &afe->memif[i];\r\nstruct mtk_base_afe_irq *irq;\r\nif (memif->irq_usage < 0)\r\ncontinue;\r\nirq = &afe->irqs[memif->irq_usage];\r\nif (!(reg_value & (1 << irq->irq_data->irq_clr_shift)))\r\ncontinue;\r\nsnd_pcm_period_elapsed(memif->substream);\r\n}\r\nerr_irq:\r\nregmap_write(afe->regmap, AFE_IRQ_CLR,\r\nreg_value & AFE_IRQ_STATUS_BITS);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mt8173_afe_runtime_suspend(struct device *dev)\r\n{\r\nstruct mtk_base_afe *afe = dev_get_drvdata(dev);\r\nstruct mt8173_afe_private *afe_priv = afe->platform_priv;\r\nregmap_update_bits(afe->regmap, AFE_DAC_CON0, 0x1, 0);\r\nregmap_update_bits(afe->regmap, AUDIO_TOP_CON0,\r\nAUD_TCON0_PDN_AFE, AUD_TCON0_PDN_AFE);\r\nclk_disable_unprepare(afe_priv->clocks[MT8173_CLK_I2S1_M]);\r\nclk_disable_unprepare(afe_priv->clocks[MT8173_CLK_I2S2_M]);\r\nclk_disable_unprepare(afe_priv->clocks[MT8173_CLK_BCK0]);\r\nclk_disable_unprepare(afe_priv->clocks[MT8173_CLK_BCK1]);\r\nclk_disable_unprepare(afe_priv->clocks[MT8173_CLK_TOP_PDN_AUD]);\r\nclk_disable_unprepare(afe_priv->clocks[MT8173_CLK_TOP_PDN_AUD_BUS]);\r\nclk_disable_unprepare(afe_priv->clocks[MT8173_CLK_INFRASYS_AUD]);\r\nreturn 0;\r\n}\r\nstatic int mt8173_afe_runtime_resume(struct device *dev)\r\n{\r\nstruct mtk_base_afe *afe = dev_get_drvdata(dev);\r\nstruct mt8173_afe_private *afe_priv = afe->platform_priv;\r\nint ret;\r\nret = clk_prepare_enable(afe_priv->clocks[MT8173_CLK_INFRASYS_AUD]);\r\nif (ret)\r\nreturn ret;\r\nret = clk_prepare_enable(afe_priv->clocks[MT8173_CLK_TOP_PDN_AUD_BUS]);\r\nif (ret)\r\ngoto err_infra;\r\nret = clk_prepare_enable(afe_priv->clocks[MT8173_CLK_TOP_PDN_AUD]);\r\nif (ret)\r\ngoto err_top_aud_bus;\r\nret = clk_prepare_enable(afe_priv->clocks[MT8173_CLK_BCK0]);\r\nif (ret)\r\ngoto err_top_aud;\r\nret = clk_prepare_enable(afe_priv->clocks[MT8173_CLK_BCK1]);\r\nif (ret)\r\ngoto err_bck0;\r\nret = clk_prepare_enable(afe_priv->clocks[MT8173_CLK_I2S1_M]);\r\nif (ret)\r\ngoto err_i2s1_m;\r\nret = clk_prepare_enable(afe_priv->clocks[MT8173_CLK_I2S2_M]);\r\nif (ret)\r\ngoto err_i2s2_m;\r\nregmap_update_bits(afe->regmap, AUDIO_TOP_CON0, AUD_TCON0_PDN_AFE, 0);\r\nregmap_update_bits(afe->regmap, AFE_CONN_24BIT,\r\nAFE_CONN_24BIT_O03 | AFE_CONN_24BIT_O04, 0);\r\nregmap_update_bits(afe->regmap, AFE_IRQ_MCU_EN, 0xff, 0xff);\r\nregmap_update_bits(afe->regmap, AFE_DAC_CON0, 0x1, 0x1);\r\nreturn 0;\r\nerr_i2s1_m:\r\nclk_disable_unprepare(afe_priv->clocks[MT8173_CLK_I2S1_M]);\r\nerr_i2s2_m:\r\nclk_disable_unprepare(afe_priv->clocks[MT8173_CLK_I2S2_M]);\r\nerr_bck0:\r\nclk_disable_unprepare(afe_priv->clocks[MT8173_CLK_BCK0]);\r\nerr_top_aud:\r\nclk_disable_unprepare(afe_priv->clocks[MT8173_CLK_TOP_PDN_AUD]);\r\nerr_top_aud_bus:\r\nclk_disable_unprepare(afe_priv->clocks[MT8173_CLK_TOP_PDN_AUD_BUS]);\r\nerr_infra:\r\nclk_disable_unprepare(afe_priv->clocks[MT8173_CLK_INFRASYS_AUD]);\r\nreturn ret;\r\n}\r\nstatic int mt8173_afe_init_audio_clk(struct mtk_base_afe *afe)\r\n{\r\nsize_t i;\r\nstruct mt8173_afe_private *afe_priv = afe->platform_priv;\r\nfor (i = 0; i < ARRAY_SIZE(aud_clks); i++) {\r\nafe_priv->clocks[i] = devm_clk_get(afe->dev, aud_clks[i]);\r\nif (IS_ERR(afe_priv->clocks[i])) {\r\ndev_err(afe->dev, "%s devm_clk_get %s fail\n",\r\n__func__, aud_clks[i]);\r\nreturn PTR_ERR(afe_priv->clocks[i]);\r\n}\r\n}\r\nclk_set_rate(afe_priv->clocks[MT8173_CLK_BCK0], 22579200);\r\nclk_set_rate(afe_priv->clocks[MT8173_CLK_BCK1], 24576000);\r\nreturn 0;\r\n}\r\nstatic int mt8173_afe_pcm_dev_probe(struct platform_device *pdev)\r\n{\r\nint ret, i;\r\nunsigned int irq_id;\r\nstruct mtk_base_afe *afe;\r\nstruct mt8173_afe_private *afe_priv;\r\nstruct resource *res;\r\nret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(33));\r\nif (ret)\r\nreturn ret;\r\nafe = devm_kzalloc(&pdev->dev, sizeof(*afe), GFP_KERNEL);\r\nif (!afe)\r\nreturn -ENOMEM;\r\nafe->platform_priv = devm_kzalloc(&pdev->dev, sizeof(*afe_priv),\r\nGFP_KERNEL);\r\nafe_priv = afe->platform_priv;\r\nif (!afe_priv)\r\nreturn -ENOMEM;\r\nafe->dev = &pdev->dev;\r\nirq_id = platform_get_irq(pdev, 0);\r\nif (!irq_id) {\r\ndev_err(afe->dev, "np %s no irq\n", afe->dev->of_node->name);\r\nreturn -ENXIO;\r\n}\r\nret = devm_request_irq(afe->dev, irq_id, mt8173_afe_irq_handler,\r\n0, "Afe_ISR_Handle", (void *)afe);\r\nif (ret) {\r\ndev_err(afe->dev, "could not request_irq\n");\r\nreturn ret;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nafe->base_addr = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(afe->base_addr))\r\nreturn PTR_ERR(afe->base_addr);\r\nafe->regmap = devm_regmap_init_mmio(&pdev->dev, afe->base_addr,\r\n&mt8173_afe_regmap_config);\r\nif (IS_ERR(afe->regmap))\r\nreturn PTR_ERR(afe->regmap);\r\nret = mt8173_afe_init_audio_clk(afe);\r\nif (ret) {\r\ndev_err(afe->dev, "mt8173_afe_init_audio_clk fail\n");\r\nreturn ret;\r\n}\r\nafe->memif_size = MT8173_AFE_MEMIF_NUM;\r\nafe->memif = devm_kcalloc(afe->dev, afe->memif_size,\r\nsizeof(*afe->memif), GFP_KERNEL);\r\nif (!afe->memif)\r\nreturn -ENOMEM;\r\nafe->irqs_size = MT8173_AFE_IRQ_NUM;\r\nafe->irqs = devm_kcalloc(afe->dev, afe->irqs_size,\r\nsizeof(*afe->irqs), GFP_KERNEL);\r\nif (!afe->irqs)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < afe->irqs_size; i++) {\r\nafe->memif[i].data = &memif_data[i];\r\nafe->irqs[i].irq_data = &irq_data[i];\r\nafe->irqs[i].irq_occupyed = true;\r\nafe->memif[i].irq_usage = i;\r\nafe->memif[i].const_irq = 1;\r\n}\r\nafe->mtk_afe_hardware = &mt8173_afe_hardware;\r\nafe->memif_fs = mt8173_memif_fs;\r\nafe->irq_fs = mt8173_irq_fs;\r\nplatform_set_drvdata(pdev, afe);\r\npm_runtime_enable(&pdev->dev);\r\nif (!pm_runtime_enabled(&pdev->dev)) {\r\nret = mt8173_afe_runtime_resume(&pdev->dev);\r\nif (ret)\r\ngoto err_pm_disable;\r\n}\r\nafe->reg_back_up_list = mt8173_afe_backup_list;\r\nafe->reg_back_up_list_num = ARRAY_SIZE(mt8173_afe_backup_list);\r\nafe->runtime_resume = mt8173_afe_runtime_resume;\r\nafe->runtime_suspend = mt8173_afe_runtime_suspend;\r\nret = snd_soc_register_platform(&pdev->dev, &mtk_afe_pcm_platform);\r\nif (ret)\r\ngoto err_pm_disable;\r\nret = snd_soc_register_component(&pdev->dev,\r\n&mt8173_afe_pcm_dai_component,\r\nmt8173_afe_pcm_dais,\r\nARRAY_SIZE(mt8173_afe_pcm_dais));\r\nif (ret)\r\ngoto err_platform;\r\nret = snd_soc_register_component(&pdev->dev,\r\n&mt8173_afe_hdmi_dai_component,\r\nmt8173_afe_hdmi_dais,\r\nARRAY_SIZE(mt8173_afe_hdmi_dais));\r\nif (ret)\r\ngoto err_comp;\r\ndev_info(&pdev->dev, "MT8173 AFE driver initialized.\n");\r\nreturn 0;\r\nerr_comp:\r\nsnd_soc_unregister_component(&pdev->dev);\r\nerr_platform:\r\nsnd_soc_unregister_platform(&pdev->dev);\r\nerr_pm_disable:\r\npm_runtime_disable(&pdev->dev);\r\nreturn ret;\r\n}\r\nstatic int mt8173_afe_pcm_dev_remove(struct platform_device *pdev)\r\n{\r\npm_runtime_disable(&pdev->dev);\r\nif (!pm_runtime_status_suspended(&pdev->dev))\r\nmt8173_afe_runtime_suspend(&pdev->dev);\r\nsnd_soc_unregister_component(&pdev->dev);\r\nsnd_soc_unregister_platform(&pdev->dev);\r\nreturn 0;\r\n}
