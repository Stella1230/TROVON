static inline int rxrpc_writable(struct sock *sk)\r\n{\r\nreturn atomic_read(&sk->sk_wmem_alloc) < (size_t) sk->sk_sndbuf;\r\n}\r\nstatic void rxrpc_write_space(struct sock *sk)\r\n{\r\n_enter("%p", sk);\r\nrcu_read_lock();\r\nif (rxrpc_writable(sk)) {\r\nstruct socket_wq *wq = rcu_dereference(sk->sk_wq);\r\nif (skwq_has_sleeper(wq))\r\nwake_up_interruptible(&wq->wait);\r\nsk_wake_async(sk, SOCK_WAKE_SPACE, POLL_OUT);\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic int rxrpc_validate_address(struct rxrpc_sock *rx,\r\nstruct sockaddr_rxrpc *srx,\r\nint len)\r\n{\r\nunsigned int tail;\r\nif (len < sizeof(struct sockaddr_rxrpc))\r\nreturn -EINVAL;\r\nif (srx->srx_family != AF_RXRPC)\r\nreturn -EAFNOSUPPORT;\r\nif (srx->transport_type != SOCK_DGRAM)\r\nreturn -ESOCKTNOSUPPORT;\r\nlen -= offsetof(struct sockaddr_rxrpc, transport);\r\nif (srx->transport_len < sizeof(sa_family_t) ||\r\nsrx->transport_len > len)\r\nreturn -EINVAL;\r\nif (srx->transport.family != rx->family)\r\nreturn -EAFNOSUPPORT;\r\nswitch (srx->transport.family) {\r\ncase AF_INET:\r\nif (srx->transport_len < sizeof(struct sockaddr_in))\r\nreturn -EINVAL;\r\ntail = offsetof(struct sockaddr_rxrpc, transport.sin.__pad);\r\nbreak;\r\n#ifdef CONFIG_AF_RXRPC_IPV6\r\ncase AF_INET6:\r\nif (srx->transport_len < sizeof(struct sockaddr_in6))\r\nreturn -EINVAL;\r\ntail = offsetof(struct sockaddr_rxrpc, transport) +\r\nsizeof(struct sockaddr_in6);\r\nbreak;\r\n#endif\r\ndefault:\r\nreturn -EAFNOSUPPORT;\r\n}\r\nif (tail < len)\r\nmemset((void *)srx + tail, 0, len - tail);\r\n_debug("INET: %pISp", &srx->transport);\r\nreturn 0;\r\n}\r\nstatic int rxrpc_bind(struct socket *sock, struct sockaddr *saddr, int len)\r\n{\r\nstruct sockaddr_rxrpc *srx = (struct sockaddr_rxrpc *)saddr;\r\nstruct sock *sk = sock->sk;\r\nstruct rxrpc_local *local;\r\nstruct rxrpc_sock *rx = rxrpc_sk(sk);\r\nu16 service_id = srx->srx_service;\r\nint ret;\r\n_enter("%p,%p,%d", rx, saddr, len);\r\nret = rxrpc_validate_address(rx, srx, len);\r\nif (ret < 0)\r\ngoto error;\r\nlock_sock(&rx->sk);\r\nif (rx->sk.sk_state != RXRPC_UNBOUND) {\r\nret = -EINVAL;\r\ngoto error_unlock;\r\n}\r\nmemcpy(&rx->srx, srx, sizeof(rx->srx));\r\nlocal = rxrpc_lookup_local(&rx->srx);\r\nif (IS_ERR(local)) {\r\nret = PTR_ERR(local);\r\ngoto error_unlock;\r\n}\r\nif (service_id) {\r\nwrite_lock(&local->services_lock);\r\nif (rcu_access_pointer(local->service))\r\ngoto service_in_use;\r\nrx->local = local;\r\nrcu_assign_pointer(local->service, rx);\r\nwrite_unlock(&local->services_lock);\r\nrx->sk.sk_state = RXRPC_SERVER_BOUND;\r\n} else {\r\nrx->local = local;\r\nrx->sk.sk_state = RXRPC_CLIENT_BOUND;\r\n}\r\nrelease_sock(&rx->sk);\r\n_leave(" = 0");\r\nreturn 0;\r\nservice_in_use:\r\nwrite_unlock(&local->services_lock);\r\nrxrpc_put_local(local);\r\nret = -EADDRINUSE;\r\nerror_unlock:\r\nrelease_sock(&rx->sk);\r\nerror:\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstatic int rxrpc_listen(struct socket *sock, int backlog)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct rxrpc_sock *rx = rxrpc_sk(sk);\r\nunsigned int max, old;\r\nint ret;\r\n_enter("%p,%d", rx, backlog);\r\nlock_sock(&rx->sk);\r\nswitch (rx->sk.sk_state) {\r\ncase RXRPC_UNBOUND:\r\nret = -EADDRNOTAVAIL;\r\nbreak;\r\ncase RXRPC_SERVER_BOUND:\r\nASSERT(rx->local != NULL);\r\nmax = READ_ONCE(rxrpc_max_backlog);\r\nret = -EINVAL;\r\nif (backlog == INT_MAX)\r\nbacklog = max;\r\nelse if (backlog < 0 || backlog > max)\r\nbreak;\r\nold = sk->sk_max_ack_backlog;\r\nsk->sk_max_ack_backlog = backlog;\r\nret = rxrpc_service_prealloc(rx, GFP_KERNEL);\r\nif (ret == 0)\r\nrx->sk.sk_state = RXRPC_SERVER_LISTENING;\r\nelse\r\nsk->sk_max_ack_backlog = old;\r\nbreak;\r\ncase RXRPC_SERVER_LISTENING:\r\nif (backlog == 0) {\r\nrx->sk.sk_state = RXRPC_SERVER_LISTEN_DISABLED;\r\nsk->sk_max_ack_backlog = 0;\r\nrxrpc_discard_prealloc(rx);\r\nret = 0;\r\nbreak;\r\n}\r\ndefault:\r\nret = -EBUSY;\r\nbreak;\r\n}\r\nrelease_sock(&rx->sk);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstruct rxrpc_call *rxrpc_kernel_begin_call(struct socket *sock,\r\nstruct sockaddr_rxrpc *srx,\r\nstruct key *key,\r\nunsigned long user_call_ID,\r\ngfp_t gfp,\r\nrxrpc_notify_rx_t notify_rx)\r\n{\r\nstruct rxrpc_conn_parameters cp;\r\nstruct rxrpc_call *call;\r\nstruct rxrpc_sock *rx = rxrpc_sk(sock->sk);\r\nint ret;\r\n_enter(",,%x,%lx", key_serial(key), user_call_ID);\r\nret = rxrpc_validate_address(rx, srx, sizeof(*srx));\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\nlock_sock(&rx->sk);\r\nif (!key)\r\nkey = rx->key;\r\nif (key && !key->payload.data[0])\r\nkey = NULL;\r\nmemset(&cp, 0, sizeof(cp));\r\ncp.local = rx->local;\r\ncp.key = key;\r\ncp.security_level = 0;\r\ncp.exclusive = false;\r\ncp.service_id = srx->srx_service;\r\ncall = rxrpc_new_client_call(rx, &cp, srx, user_call_ID, gfp);\r\nif (!IS_ERR(call))\r\ncall->notify_rx = notify_rx;\r\nmutex_unlock(&call->user_mutex);\r\n_leave(" = %p", call);\r\nreturn call;\r\n}\r\nvoid rxrpc_kernel_end_call(struct socket *sock, struct rxrpc_call *call)\r\n{\r\n_enter("%d{%d}", call->debug_id, atomic_read(&call->usage));\r\nmutex_lock(&call->user_mutex);\r\nrxrpc_release_call(rxrpc_sk(sock->sk), call);\r\nmutex_unlock(&call->user_mutex);\r\nrxrpc_put_call(call, rxrpc_call_put_kernel);\r\n}\r\nvoid rxrpc_kernel_new_call_notification(\r\nstruct socket *sock,\r\nrxrpc_notify_new_call_t notify_new_call,\r\nrxrpc_discard_new_call_t discard_new_call)\r\n{\r\nstruct rxrpc_sock *rx = rxrpc_sk(sock->sk);\r\nrx->notify_new_call = notify_new_call;\r\nrx->discard_new_call = discard_new_call;\r\n}\r\nstatic int rxrpc_connect(struct socket *sock, struct sockaddr *addr,\r\nint addr_len, int flags)\r\n{\r\nstruct sockaddr_rxrpc *srx = (struct sockaddr_rxrpc *)addr;\r\nstruct rxrpc_sock *rx = rxrpc_sk(sock->sk);\r\nint ret;\r\n_enter("%p,%p,%d,%d", rx, addr, addr_len, flags);\r\nret = rxrpc_validate_address(rx, srx, addr_len);\r\nif (ret < 0) {\r\n_leave(" = %d [bad addr]", ret);\r\nreturn ret;\r\n}\r\nlock_sock(&rx->sk);\r\nret = -EISCONN;\r\nif (test_bit(RXRPC_SOCK_CONNECTED, &rx->flags))\r\ngoto error;\r\nswitch (rx->sk.sk_state) {\r\ncase RXRPC_UNBOUND:\r\nrx->sk.sk_state = RXRPC_CLIENT_UNBOUND;\r\ncase RXRPC_CLIENT_UNBOUND:\r\ncase RXRPC_CLIENT_BOUND:\r\nbreak;\r\ndefault:\r\nret = -EBUSY;\r\ngoto error;\r\n}\r\nrx->connect_srx = *srx;\r\nset_bit(RXRPC_SOCK_CONNECTED, &rx->flags);\r\nret = 0;\r\nerror:\r\nrelease_sock(&rx->sk);\r\nreturn ret;\r\n}\r\nstatic int rxrpc_sendmsg(struct socket *sock, struct msghdr *m, size_t len)\r\n{\r\nstruct rxrpc_local *local;\r\nstruct rxrpc_sock *rx = rxrpc_sk(sock->sk);\r\nint ret;\r\n_enter(",{%d},,%zu", rx->sk.sk_state, len);\r\nif (m->msg_flags & MSG_OOB)\r\nreturn -EOPNOTSUPP;\r\nif (m->msg_name) {\r\nret = rxrpc_validate_address(rx, m->msg_name, m->msg_namelen);\r\nif (ret < 0) {\r\n_leave(" = %d [bad addr]", ret);\r\nreturn ret;\r\n}\r\n}\r\nlock_sock(&rx->sk);\r\nswitch (rx->sk.sk_state) {\r\ncase RXRPC_UNBOUND:\r\nrx->srx.srx_family = AF_RXRPC;\r\nrx->srx.srx_service = 0;\r\nrx->srx.transport_type = SOCK_DGRAM;\r\nrx->srx.transport.family = rx->family;\r\nswitch (rx->family) {\r\ncase AF_INET:\r\nrx->srx.transport_len = sizeof(struct sockaddr_in);\r\nbreak;\r\n#ifdef CONFIG_AF_RXRPC_IPV6\r\ncase AF_INET6:\r\nrx->srx.transport_len = sizeof(struct sockaddr_in6);\r\nbreak;\r\n#endif\r\ndefault:\r\nret = -EAFNOSUPPORT;\r\ngoto error_unlock;\r\n}\r\nlocal = rxrpc_lookup_local(&rx->srx);\r\nif (IS_ERR(local)) {\r\nret = PTR_ERR(local);\r\ngoto error_unlock;\r\n}\r\nrx->local = local;\r\nrx->sk.sk_state = RXRPC_CLIENT_UNBOUND;\r\ncase RXRPC_CLIENT_UNBOUND:\r\ncase RXRPC_CLIENT_BOUND:\r\nif (!m->msg_name &&\r\ntest_bit(RXRPC_SOCK_CONNECTED, &rx->flags)) {\r\nm->msg_name = &rx->connect_srx;\r\nm->msg_namelen = sizeof(rx->connect_srx);\r\n}\r\ncase RXRPC_SERVER_BOUND:\r\ncase RXRPC_SERVER_LISTENING:\r\nret = rxrpc_do_sendmsg(rx, m, len);\r\ngoto out;\r\ndefault:\r\nret = -EINVAL;\r\ngoto error_unlock;\r\n}\r\nerror_unlock:\r\nrelease_sock(&rx->sk);\r\nout:\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstatic int rxrpc_setsockopt(struct socket *sock, int level, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nstruct rxrpc_sock *rx = rxrpc_sk(sock->sk);\r\nunsigned int min_sec_level;\r\nint ret;\r\n_enter(",%d,%d,,%d", level, optname, optlen);\r\nlock_sock(&rx->sk);\r\nret = -EOPNOTSUPP;\r\nif (level == SOL_RXRPC) {\r\nswitch (optname) {\r\ncase RXRPC_EXCLUSIVE_CONNECTION:\r\nret = -EINVAL;\r\nif (optlen != 0)\r\ngoto error;\r\nret = -EISCONN;\r\nif (rx->sk.sk_state != RXRPC_UNBOUND)\r\ngoto error;\r\nrx->exclusive = true;\r\ngoto success;\r\ncase RXRPC_SECURITY_KEY:\r\nret = -EINVAL;\r\nif (rx->key)\r\ngoto error;\r\nret = -EISCONN;\r\nif (rx->sk.sk_state != RXRPC_UNBOUND)\r\ngoto error;\r\nret = rxrpc_request_key(rx, optval, optlen);\r\ngoto error;\r\ncase RXRPC_SECURITY_KEYRING:\r\nret = -EINVAL;\r\nif (rx->key)\r\ngoto error;\r\nret = -EISCONN;\r\nif (rx->sk.sk_state != RXRPC_UNBOUND)\r\ngoto error;\r\nret = rxrpc_server_keyring(rx, optval, optlen);\r\ngoto error;\r\ncase RXRPC_MIN_SECURITY_LEVEL:\r\nret = -EINVAL;\r\nif (optlen != sizeof(unsigned int))\r\ngoto error;\r\nret = -EISCONN;\r\nif (rx->sk.sk_state != RXRPC_UNBOUND)\r\ngoto error;\r\nret = get_user(min_sec_level,\r\n(unsigned int __user *) optval);\r\nif (ret < 0)\r\ngoto error;\r\nret = -EINVAL;\r\nif (min_sec_level > RXRPC_SECURITY_MAX)\r\ngoto error;\r\nrx->min_sec_level = min_sec_level;\r\ngoto success;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nsuccess:\r\nret = 0;\r\nerror:\r\nrelease_sock(&rx->sk);\r\nreturn ret;\r\n}\r\nstatic unsigned int rxrpc_poll(struct file *file, struct socket *sock,\r\npoll_table *wait)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct rxrpc_sock *rx = rxrpc_sk(sk);\r\nunsigned int mask;\r\nsock_poll_wait(file, sk_sleep(sk), wait);\r\nmask = 0;\r\nif (!list_empty(&rx->recvmsg_q))\r\nmask |= POLLIN | POLLRDNORM;\r\nif (rxrpc_writable(sk))\r\nmask |= POLLOUT | POLLWRNORM;\r\nreturn mask;\r\n}\r\nstatic int rxrpc_create(struct net *net, struct socket *sock, int protocol,\r\nint kern)\r\n{\r\nstruct rxrpc_sock *rx;\r\nstruct sock *sk;\r\n_enter("%p,%d", sock, protocol);\r\nif (!net_eq(net, &init_net))\r\nreturn -EAFNOSUPPORT;\r\nif (protocol != PF_INET &&\r\nIS_ENABLED(CONFIG_AF_RXRPC_IPV6) && protocol != PF_INET6)\r\nreturn -EPROTONOSUPPORT;\r\nif (sock->type != SOCK_DGRAM)\r\nreturn -ESOCKTNOSUPPORT;\r\nsock->ops = &rxrpc_rpc_ops;\r\nsock->state = SS_UNCONNECTED;\r\nsk = sk_alloc(net, PF_RXRPC, GFP_KERNEL, &rxrpc_proto, kern);\r\nif (!sk)\r\nreturn -ENOMEM;\r\nsock_init_data(sock, sk);\r\nsock_set_flag(sk, SOCK_RCU_FREE);\r\nsk->sk_state = RXRPC_UNBOUND;\r\nsk->sk_write_space = rxrpc_write_space;\r\nsk->sk_max_ack_backlog = 0;\r\nsk->sk_destruct = rxrpc_sock_destructor;\r\nrx = rxrpc_sk(sk);\r\nrx->family = protocol;\r\nrx->calls = RB_ROOT;\r\nspin_lock_init(&rx->incoming_lock);\r\nINIT_LIST_HEAD(&rx->sock_calls);\r\nINIT_LIST_HEAD(&rx->to_be_accepted);\r\nINIT_LIST_HEAD(&rx->recvmsg_q);\r\nrwlock_init(&rx->recvmsg_lock);\r\nrwlock_init(&rx->call_lock);\r\nmemset(&rx->srx, 0, sizeof(rx->srx));\r\n_leave(" = 0 [%p]", rx);\r\nreturn 0;\r\n}\r\nstatic int rxrpc_shutdown(struct socket *sock, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct rxrpc_sock *rx = rxrpc_sk(sk);\r\nint ret = 0;\r\n_enter("%p,%d", sk, flags);\r\nif (flags != SHUT_RDWR)\r\nreturn -EOPNOTSUPP;\r\nif (sk->sk_state == RXRPC_CLOSE)\r\nreturn -ESHUTDOWN;\r\nlock_sock(sk);\r\nspin_lock_bh(&sk->sk_receive_queue.lock);\r\nif (sk->sk_state < RXRPC_CLOSE) {\r\nsk->sk_state = RXRPC_CLOSE;\r\nsk->sk_shutdown = SHUTDOWN_MASK;\r\n} else {\r\nret = -ESHUTDOWN;\r\n}\r\nspin_unlock_bh(&sk->sk_receive_queue.lock);\r\nrxrpc_discard_prealloc(rx);\r\nrelease_sock(sk);\r\nreturn ret;\r\n}\r\nstatic void rxrpc_sock_destructor(struct sock *sk)\r\n{\r\n_enter("%p", sk);\r\nrxrpc_purge_queue(&sk->sk_receive_queue);\r\nWARN_ON(atomic_read(&sk->sk_wmem_alloc));\r\nWARN_ON(!sk_unhashed(sk));\r\nWARN_ON(sk->sk_socket);\r\nif (!sock_flag(sk, SOCK_DEAD)) {\r\nprintk("Attempt to release alive rxrpc socket: %p\n", sk);\r\nreturn;\r\n}\r\n}\r\nstatic int rxrpc_release_sock(struct sock *sk)\r\n{\r\nstruct rxrpc_sock *rx = rxrpc_sk(sk);\r\n_enter("%p{%d,%d}", sk, sk->sk_state, atomic_read(&sk->sk_refcnt));\r\nsock_orphan(sk);\r\nsk->sk_shutdown = SHUTDOWN_MASK;\r\nspin_lock_bh(&sk->sk_receive_queue.lock);\r\nsk->sk_state = RXRPC_CLOSE;\r\nspin_unlock_bh(&sk->sk_receive_queue.lock);\r\nif (rx->local && rcu_access_pointer(rx->local->service) == rx) {\r\nwrite_lock(&rx->local->services_lock);\r\nrcu_assign_pointer(rx->local->service, NULL);\r\nwrite_unlock(&rx->local->services_lock);\r\n}\r\nrxrpc_discard_prealloc(rx);\r\nrxrpc_release_calls_on_socket(rx);\r\nflush_workqueue(rxrpc_workqueue);\r\nrxrpc_purge_queue(&sk->sk_receive_queue);\r\nrxrpc_put_local(rx->local);\r\nrx->local = NULL;\r\nkey_put(rx->key);\r\nrx->key = NULL;\r\nkey_put(rx->securities);\r\nrx->securities = NULL;\r\nsock_put(sk);\r\n_leave(" = 0");\r\nreturn 0;\r\n}\r\nstatic int rxrpc_release(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\n_enter("%p{%p}", sock, sk);\r\nif (!sk)\r\nreturn 0;\r\nsock->sk = NULL;\r\nreturn rxrpc_release_sock(sk);\r\n}\r\nstatic int __init af_rxrpc_init(void)\r\n{\r\nint ret = -1;\r\nunsigned int tmp;\r\nBUILD_BUG_ON(sizeof(struct rxrpc_skb_priv) > FIELD_SIZEOF(struct sk_buff, cb));\r\nget_random_bytes(&rxrpc_epoch, sizeof(rxrpc_epoch));\r\nrxrpc_epoch |= RXRPC_RANDOM_EPOCH;\r\nget_random_bytes(&tmp, sizeof(tmp));\r\ntmp &= 0x3fffffff;\r\nif (tmp == 0)\r\ntmp = 1;\r\nidr_set_cursor(&rxrpc_client_conn_ids, tmp);\r\nret = -ENOMEM;\r\nrxrpc_call_jar = kmem_cache_create(\r\n"rxrpc_call_jar", sizeof(struct rxrpc_call), 0,\r\nSLAB_HWCACHE_ALIGN, NULL);\r\nif (!rxrpc_call_jar) {\r\npr_notice("Failed to allocate call jar\n");\r\ngoto error_call_jar;\r\n}\r\nrxrpc_workqueue = alloc_workqueue("krxrpcd", 0, 1);\r\nif (!rxrpc_workqueue) {\r\npr_notice("Failed to allocate work queue\n");\r\ngoto error_work_queue;\r\n}\r\nret = rxrpc_init_security();\r\nif (ret < 0) {\r\npr_crit("Cannot initialise security\n");\r\ngoto error_security;\r\n}\r\nret = proto_register(&rxrpc_proto, 1);\r\nif (ret < 0) {\r\npr_crit("Cannot register protocol\n");\r\ngoto error_proto;\r\n}\r\nret = sock_register(&rxrpc_family_ops);\r\nif (ret < 0) {\r\npr_crit("Cannot register socket family\n");\r\ngoto error_sock;\r\n}\r\nret = register_key_type(&key_type_rxrpc);\r\nif (ret < 0) {\r\npr_crit("Cannot register client key type\n");\r\ngoto error_key_type;\r\n}\r\nret = register_key_type(&key_type_rxrpc_s);\r\nif (ret < 0) {\r\npr_crit("Cannot register server key type\n");\r\ngoto error_key_type_s;\r\n}\r\nret = rxrpc_sysctl_init();\r\nif (ret < 0) {\r\npr_crit("Cannot register sysctls\n");\r\ngoto error_sysctls;\r\n}\r\n#ifdef CONFIG_PROC_FS\r\nproc_create("rxrpc_calls", 0, init_net.proc_net, &rxrpc_call_seq_fops);\r\nproc_create("rxrpc_conns", 0, init_net.proc_net,\r\n&rxrpc_connection_seq_fops);\r\n#endif\r\nreturn 0;\r\nerror_sysctls:\r\nunregister_key_type(&key_type_rxrpc_s);\r\nerror_key_type_s:\r\nunregister_key_type(&key_type_rxrpc);\r\nerror_key_type:\r\nsock_unregister(PF_RXRPC);\r\nerror_sock:\r\nproto_unregister(&rxrpc_proto);\r\nerror_proto:\r\nrxrpc_exit_security();\r\nerror_security:\r\ndestroy_workqueue(rxrpc_workqueue);\r\nerror_work_queue:\r\nkmem_cache_destroy(rxrpc_call_jar);\r\nerror_call_jar:\r\nreturn ret;\r\n}\r\nstatic void __exit af_rxrpc_exit(void)\r\n{\r\n_enter("");\r\nrxrpc_sysctl_exit();\r\nunregister_key_type(&key_type_rxrpc_s);\r\nunregister_key_type(&key_type_rxrpc);\r\nsock_unregister(PF_RXRPC);\r\nproto_unregister(&rxrpc_proto);\r\nrxrpc_destroy_all_calls();\r\nrxrpc_destroy_all_connections();\r\nASSERTCMP(atomic_read(&rxrpc_n_tx_skbs), ==, 0);\r\nASSERTCMP(atomic_read(&rxrpc_n_rx_skbs), ==, 0);\r\nrxrpc_destroy_all_locals();\r\nremove_proc_entry("rxrpc_conns", init_net.proc_net);\r\nremove_proc_entry("rxrpc_calls", init_net.proc_net);\r\ndestroy_workqueue(rxrpc_workqueue);\r\nrxrpc_exit_security();\r\nkmem_cache_destroy(rxrpc_call_jar);\r\n_leave("");\r\n}
