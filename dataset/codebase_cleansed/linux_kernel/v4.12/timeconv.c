static int __isleap(long year)\r\n{\r\nreturn (year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0);\r\n}\r\nstatic long math_div(long a, long b)\r\n{\r\nreturn a / b - (a % b < 0);\r\n}\r\nstatic long leaps_between(long y1, long y2)\r\n{\r\nlong leaps1 = math_div(y1 - 1, 4) - math_div(y1 - 1, 100)\r\n+ math_div(y1 - 1, 400);\r\nlong leaps2 = math_div(y2 - 1, 4) - math_div(y2 - 1, 100)\r\n+ math_div(y2 - 1, 400);\r\nreturn leaps2 - leaps1;\r\n}\r\nvoid time64_to_tm(time64_t totalsecs, int offset, struct tm *result)\r\n{\r\nlong days, rem, y;\r\nint remainder;\r\nconst unsigned short *ip;\r\ndays = div_s64_rem(totalsecs, SECS_PER_DAY, &remainder);\r\nrem = remainder;\r\nrem += offset;\r\nwhile (rem < 0) {\r\nrem += SECS_PER_DAY;\r\n--days;\r\n}\r\nwhile (rem >= SECS_PER_DAY) {\r\nrem -= SECS_PER_DAY;\r\n++days;\r\n}\r\nresult->tm_hour = rem / SECS_PER_HOUR;\r\nrem %= SECS_PER_HOUR;\r\nresult->tm_min = rem / 60;\r\nresult->tm_sec = rem % 60;\r\nresult->tm_wday = (4 + days) % 7;\r\nif (result->tm_wday < 0)\r\nresult->tm_wday += 7;\r\ny = 1970;\r\nwhile (days < 0 || days >= (__isleap(y) ? 366 : 365)) {\r\nlong yg = y + math_div(days, 365);\r\ndays -= (yg - y) * 365 + leaps_between(y, yg);\r\ny = yg;\r\n}\r\nresult->tm_year = y - 1900;\r\nresult->tm_yday = days;\r\nip = __mon_yday[__isleap(y)];\r\nfor (y = 11; days < ip[y]; y--)\r\ncontinue;\r\ndays -= ip[y];\r\nresult->tm_mon = y;\r\nresult->tm_mday = days + 1;\r\n}
