static int __stmpe_reset_fifo(struct stmpe *stmpe)\r\n{\r\nint ret;\r\nret = stmpe_set_bits(stmpe, STMPE_REG_FIFO_STA,\r\nSTMPE_FIFO_STA_RESET, STMPE_FIFO_STA_RESET);\r\nif (ret)\r\nreturn ret;\r\nreturn stmpe_set_bits(stmpe, STMPE_REG_FIFO_STA,\r\nSTMPE_FIFO_STA_RESET, 0);\r\n}\r\nstatic void stmpe_work(struct work_struct *work)\r\n{\r\nint int_sta;\r\nu32 timeout = 40;\r\nstruct stmpe_touch *ts =\r\ncontainer_of(work, struct stmpe_touch, work.work);\r\nint_sta = stmpe_reg_read(ts->stmpe, STMPE_REG_INT_STA);\r\nwhile ((int_sta & (1 << STMPE_IRQ_TOUCH_DET)) && (timeout > 0)) {\r\ntimeout--;\r\nint_sta = stmpe_reg_read(ts->stmpe, STMPE_REG_INT_STA);\r\nudelay(100);\r\n}\r\n__stmpe_reset_fifo(ts->stmpe);\r\ninput_report_abs(ts->idev, ABS_PRESSURE, 0);\r\ninput_report_key(ts->idev, BTN_TOUCH, 0);\r\ninput_sync(ts->idev);\r\n}\r\nstatic irqreturn_t stmpe_ts_handler(int irq, void *data)\r\n{\r\nu8 data_set[4];\r\nint x, y, z;\r\nstruct stmpe_touch *ts = data;\r\ncancel_delayed_work_sync(&ts->work);\r\nstmpe_set_bits(ts->stmpe, STMPE_REG_TSC_CTRL,\r\nSTMPE_TSC_CTRL_TSC_EN, 0);\r\nstmpe_block_read(ts->stmpe, STMPE_REG_TSC_DATA_XYZ, 4, data_set);\r\nx = (data_set[0] << 4) | (data_set[1] >> 4);\r\ny = ((data_set[1] & 0xf) << 8) | data_set[2];\r\nz = data_set[3];\r\ninput_report_abs(ts->idev, ABS_X, x);\r\ninput_report_abs(ts->idev, ABS_Y, y);\r\ninput_report_abs(ts->idev, ABS_PRESSURE, z);\r\ninput_report_key(ts->idev, BTN_TOUCH, 1);\r\ninput_sync(ts->idev);\r\n__stmpe_reset_fifo(ts->stmpe);\r\nstmpe_set_bits(ts->stmpe, STMPE_REG_TSC_CTRL,\r\nSTMPE_TSC_CTRL_TSC_EN, STMPE_TSC_CTRL_TSC_EN);\r\nschedule_delayed_work(&ts->work, msecs_to_jiffies(50));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int stmpe_init_hw(struct stmpe_touch *ts)\r\n{\r\nint ret;\r\nu8 adc_ctrl1, adc_ctrl1_mask, tsc_cfg, tsc_cfg_mask;\r\nstruct stmpe *stmpe = ts->stmpe;\r\nstruct device *dev = ts->dev;\r\nret = stmpe_enable(stmpe, STMPE_BLOCK_TOUCHSCREEN | STMPE_BLOCK_ADC);\r\nif (ret) {\r\ndev_err(dev, "Could not enable clock for ADC and TS\n");\r\nreturn ret;\r\n}\r\nadc_ctrl1 = SAMPLE_TIME(ts->sample_time) | MOD_12B(ts->mod_12b) |\r\nREF_SEL(ts->ref_sel);\r\nadc_ctrl1_mask = SAMPLE_TIME(0xff) | MOD_12B(0xff) | REF_SEL(0xff);\r\nret = stmpe_set_bits(stmpe, STMPE_REG_ADC_CTRL1,\r\nadc_ctrl1_mask, adc_ctrl1);\r\nif (ret) {\r\ndev_err(dev, "Could not setup ADC\n");\r\nreturn ret;\r\n}\r\nret = stmpe_set_bits(stmpe, STMPE_REG_ADC_CTRL2,\r\nADC_FREQ(0xff), ADC_FREQ(ts->adc_freq));\r\nif (ret) {\r\ndev_err(dev, "Could not setup ADC\n");\r\nreturn ret;\r\n}\r\ntsc_cfg = AVE_CTRL(ts->ave_ctrl) | DET_DELAY(ts->touch_det_delay) |\r\nSETTLING(ts->settling);\r\ntsc_cfg_mask = AVE_CTRL(0xff) | DET_DELAY(0xff) | SETTLING(0xff);\r\nret = stmpe_set_bits(stmpe, STMPE_REG_TSC_CFG, tsc_cfg_mask, tsc_cfg);\r\nif (ret) {\r\ndev_err(dev, "Could not config touch\n");\r\nreturn ret;\r\n}\r\nret = stmpe_set_bits(stmpe, STMPE_REG_TSC_FRACTION_Z,\r\nFRACTION_Z(0xff), FRACTION_Z(ts->fraction_z));\r\nif (ret) {\r\ndev_err(dev, "Could not config touch\n");\r\nreturn ret;\r\n}\r\nret = stmpe_set_bits(stmpe, STMPE_REG_TSC_I_DRIVE,\r\nI_DRIVE(0xff), I_DRIVE(ts->i_drive));\r\nif (ret) {\r\ndev_err(dev, "Could not config touch\n");\r\nreturn ret;\r\n}\r\nret = stmpe_reg_write(stmpe, STMPE_REG_FIFO_TH, 1);\r\nif (ret) {\r\ndev_err(dev, "Could not set FIFO\n");\r\nreturn ret;\r\n}\r\nret = stmpe_set_bits(stmpe, STMPE_REG_TSC_CTRL,\r\nOP_MODE(0xff), OP_MODE(OP_MOD_XYZ));\r\nif (ret) {\r\ndev_err(dev, "Could not set mode\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int stmpe_ts_open(struct input_dev *dev)\r\n{\r\nstruct stmpe_touch *ts = input_get_drvdata(dev);\r\nint ret = 0;\r\nret = __stmpe_reset_fifo(ts->stmpe);\r\nif (ret)\r\nreturn ret;\r\nreturn stmpe_set_bits(ts->stmpe, STMPE_REG_TSC_CTRL,\r\nSTMPE_TSC_CTRL_TSC_EN, STMPE_TSC_CTRL_TSC_EN);\r\n}\r\nstatic void stmpe_ts_close(struct input_dev *dev)\r\n{\r\nstruct stmpe_touch *ts = input_get_drvdata(dev);\r\ncancel_delayed_work_sync(&ts->work);\r\nstmpe_set_bits(ts->stmpe, STMPE_REG_TSC_CTRL,\r\nSTMPE_TSC_CTRL_TSC_EN, 0);\r\n}\r\nstatic void stmpe_ts_get_platform_info(struct platform_device *pdev,\r\nstruct stmpe_touch *ts)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nu32 val;\r\nif (np) {\r\nif (!of_property_read_u32(np, "st,sample-time", &val))\r\nts->sample_time = val;\r\nif (!of_property_read_u32(np, "st,mod-12b", &val))\r\nts->mod_12b = val;\r\nif (!of_property_read_u32(np, "st,ref-sel", &val))\r\nts->ref_sel = val;\r\nif (!of_property_read_u32(np, "st,adc-freq", &val))\r\nts->adc_freq = val;\r\nif (!of_property_read_u32(np, "st,ave-ctrl", &val))\r\nts->ave_ctrl = val;\r\nif (!of_property_read_u32(np, "st,touch-det-delay", &val))\r\nts->touch_det_delay = val;\r\nif (!of_property_read_u32(np, "st,settling", &val))\r\nts->settling = val;\r\nif (!of_property_read_u32(np, "st,fraction-z", &val))\r\nts->fraction_z = val;\r\nif (!of_property_read_u32(np, "st,i-drive", &val))\r\nts->i_drive = val;\r\n}\r\n}\r\nstatic int stmpe_input_probe(struct platform_device *pdev)\r\n{\r\nstruct stmpe *stmpe = dev_get_drvdata(pdev->dev.parent);\r\nstruct stmpe_touch *ts;\r\nstruct input_dev *idev;\r\nint error;\r\nint ts_irq;\r\nts_irq = platform_get_irq_byname(pdev, "FIFO_TH");\r\nif (ts_irq < 0)\r\nreturn ts_irq;\r\nts = devm_kzalloc(&pdev->dev, sizeof(*ts), GFP_KERNEL);\r\nif (!ts)\r\nreturn -ENOMEM;\r\nidev = devm_input_allocate_device(&pdev->dev);\r\nif (!idev)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, ts);\r\nts->stmpe = stmpe;\r\nts->idev = idev;\r\nts->dev = &pdev->dev;\r\nstmpe_ts_get_platform_info(pdev, ts);\r\nINIT_DELAYED_WORK(&ts->work, stmpe_work);\r\nerror = devm_request_threaded_irq(&pdev->dev, ts_irq,\r\nNULL, stmpe_ts_handler,\r\nIRQF_ONESHOT, STMPE_TS_NAME, ts);\r\nif (error) {\r\ndev_err(&pdev->dev, "Failed to request IRQ %d\n", ts_irq);\r\nreturn error;\r\n}\r\nerror = stmpe_init_hw(ts);\r\nif (error)\r\nreturn error;\r\nidev->name = STMPE_TS_NAME;\r\nidev->phys = STMPE_TS_NAME"/input0";\r\nidev->id.bustype = BUS_I2C;\r\nidev->open = stmpe_ts_open;\r\nidev->close = stmpe_ts_close;\r\ninput_set_drvdata(idev, ts);\r\ninput_set_capability(idev, EV_KEY, BTN_TOUCH);\r\ninput_set_abs_params(idev, ABS_X, 0, XY_MASK, 0, 0);\r\ninput_set_abs_params(idev, ABS_Y, 0, XY_MASK, 0, 0);\r\ninput_set_abs_params(idev, ABS_PRESSURE, 0x0, 0xff, 0, 0);\r\nerror = input_register_device(idev);\r\nif (error) {\r\ndev_err(&pdev->dev, "Could not register input device\n");\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int stmpe_ts_remove(struct platform_device *pdev)\r\n{\r\nstruct stmpe_touch *ts = platform_get_drvdata(pdev);\r\nstmpe_disable(ts->stmpe, STMPE_BLOCK_TOUCHSCREEN);\r\nreturn 0;\r\n}
