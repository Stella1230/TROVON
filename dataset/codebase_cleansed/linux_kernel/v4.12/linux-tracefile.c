int cfs_tracefile_init_arch(void)\r\n{\r\nint i;\r\nint j;\r\nstruct cfs_trace_cpu_data *tcd;\r\nmemset(cfs_trace_data, 0, sizeof(cfs_trace_data));\r\nfor (i = 0; i < CFS_TCD_TYPE_MAX; i++) {\r\ncfs_trace_data[i] =\r\nkmalloc(sizeof(union cfs_trace_data_union) *\r\nnum_possible_cpus(), GFP_KERNEL);\r\nif (!cfs_trace_data[i])\r\ngoto out;\r\n}\r\ncfs_tcd_for_each(tcd, i, j) {\r\nspin_lock_init(&tcd->tcd_lock);\r\ntcd->tcd_pages_factor = pages_factor[i];\r\ntcd->tcd_type = i;\r\ntcd->tcd_cpu = j;\r\n}\r\nfor (i = 0; i < num_possible_cpus(); i++)\r\nfor (j = 0; j < 3; j++) {\r\ncfs_trace_console_buffers[i][j] =\r\nkmalloc(CFS_TRACE_CONSOLE_BUFFER_SIZE,\r\nGFP_KERNEL);\r\nif (!cfs_trace_console_buffers[i][j])\r\ngoto out;\r\n}\r\nreturn 0;\r\nout:\r\ncfs_tracefile_fini_arch();\r\npr_err("lnet: Not enough memory\n");\r\nreturn -ENOMEM;\r\n}\r\nvoid cfs_tracefile_fini_arch(void)\r\n{\r\nint i;\r\nint j;\r\nfor (i = 0; i < num_possible_cpus(); i++)\r\nfor (j = 0; j < 3; j++) {\r\nkfree(cfs_trace_console_buffers[i][j]);\r\ncfs_trace_console_buffers[i][j] = NULL;\r\n}\r\nfor (i = 0; cfs_trace_data[i]; i++) {\r\nkfree(cfs_trace_data[i]);\r\ncfs_trace_data[i] = NULL;\r\n}\r\n}\r\nvoid cfs_tracefile_read_lock(void)\r\n{\r\ndown_read(&cfs_tracefile_sem);\r\n}\r\nvoid cfs_tracefile_read_unlock(void)\r\n{\r\nup_read(&cfs_tracefile_sem);\r\n}\r\nvoid cfs_tracefile_write_lock(void)\r\n{\r\ndown_write(&cfs_tracefile_sem);\r\n}\r\nvoid cfs_tracefile_write_unlock(void)\r\n{\r\nup_write(&cfs_tracefile_sem);\r\n}\r\nenum cfs_trace_buf_type cfs_trace_buf_idx_get(void)\r\n{\r\nif (in_irq())\r\nreturn CFS_TCD_TYPE_IRQ;\r\nif (in_softirq())\r\nreturn CFS_TCD_TYPE_SOFTIRQ;\r\nreturn CFS_TCD_TYPE_PROC;\r\n}\r\nint cfs_trace_lock_tcd(struct cfs_trace_cpu_data *tcd, int walking)\r\n__acquires(&tcd->tc_lock\r\nvoid cfs_trace_unlock_tcd(struct cfs_trace_cpu_data *tcd, int walking)\r\n__releases(&tcd->tcd_lock\r\nvoid\r\ncfs_set_ptldebug_header(struct ptldebug_header *header,\r\nstruct libcfs_debug_msg_data *msgdata,\r\nunsigned long stack)\r\n{\r\nstruct timespec64 ts;\r\nktime_get_real_ts64(&ts);\r\nheader->ph_subsys = msgdata->msg_subsys;\r\nheader->ph_mask = msgdata->msg_mask;\r\nheader->ph_cpu_id = smp_processor_id();\r\nheader->ph_type = cfs_trace_buf_idx_get();\r\nheader->ph_sec = (u32)ts.tv_sec;\r\nheader->ph_usec = ts.tv_nsec / NSEC_PER_USEC;\r\nheader->ph_stack = stack;\r\nheader->ph_pid = current->pid;\r\nheader->ph_line_num = msgdata->msg_line;\r\nheader->ph_extern_pid = 0;\r\n}\r\nstatic char *\r\ndbghdr_to_err_string(struct ptldebug_header *hdr)\r\n{\r\nswitch (hdr->ph_subsys) {\r\ncase S_LND:\r\ncase S_LNET:\r\nreturn "LNetError";\r\ndefault:\r\nreturn "LustreError";\r\n}\r\n}\r\nstatic char *\r\ndbghdr_to_info_string(struct ptldebug_header *hdr)\r\n{\r\nswitch (hdr->ph_subsys) {\r\ncase S_LND:\r\ncase S_LNET:\r\nreturn "LNet";\r\ndefault:\r\nreturn "Lustre";\r\n}\r\n}\r\nvoid cfs_print_to_console(struct ptldebug_header *hdr, int mask,\r\nconst char *buf, int len, const char *file,\r\nconst char *fn)\r\n{\r\nchar *prefix = "Lustre", *ptype = NULL;\r\nif (mask & D_EMERG) {\r\nprefix = dbghdr_to_err_string(hdr);\r\nptype = KERN_EMERG;\r\n} else if (mask & D_ERROR) {\r\nprefix = dbghdr_to_err_string(hdr);\r\nptype = KERN_ERR;\r\n} else if (mask & D_WARNING) {\r\nprefix = dbghdr_to_info_string(hdr);\r\nptype = KERN_WARNING;\r\n} else if (mask & (D_CONSOLE | libcfs_printk)) {\r\nprefix = dbghdr_to_info_string(hdr);\r\nptype = KERN_INFO;\r\n}\r\nif (mask & D_CONSOLE) {\r\npr_info("%s%s: %.*s", ptype, prefix, len, buf);\r\n} else {\r\npr_info("%s%s: %d:%d:(%s:%d:%s()) %.*s", ptype, prefix,\r\nhdr->ph_pid, hdr->ph_extern_pid, file,\r\nhdr->ph_line_num, fn, len, buf);\r\n}\r\n}\r\nint cfs_trace_max_debug_mb(void)\r\n{\r\nint total_mb = (totalram_pages >> (20 - PAGE_SHIFT));\r\nreturn max(512, (total_mb * 80) / 100);\r\n}
