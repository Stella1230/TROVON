static int memstick_dev_match(struct memstick_dev *card,\r\nstruct memstick_device_id *id)\r\n{\r\nif (id->match_flags & MEMSTICK_MATCH_ALL) {\r\nif ((id->type == card->id.type)\r\n&& (id->category == card->id.category)\r\n&& (id->class == card->id.class))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int memstick_bus_match(struct device *dev, struct device_driver *drv)\r\n{\r\nstruct memstick_dev *card = container_of(dev, struct memstick_dev,\r\ndev);\r\nstruct memstick_driver *ms_drv = container_of(drv,\r\nstruct memstick_driver,\r\ndriver);\r\nstruct memstick_device_id *ids = ms_drv->id_table;\r\nif (ids) {\r\nwhile (ids->match_flags) {\r\nif (memstick_dev_match(card, ids))\r\nreturn 1;\r\n++ids;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int memstick_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nstruct memstick_dev *card = container_of(dev, struct memstick_dev,\r\ndev);\r\nif (add_uevent_var(env, "MEMSTICK_TYPE=%02X", card->id.type))\r\nreturn -ENOMEM;\r\nif (add_uevent_var(env, "MEMSTICK_CATEGORY=%02X", card->id.category))\r\nreturn -ENOMEM;\r\nif (add_uevent_var(env, "MEMSTICK_CLASS=%02X", card->id.class))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int memstick_device_probe(struct device *dev)\r\n{\r\nstruct memstick_dev *card = container_of(dev, struct memstick_dev,\r\ndev);\r\nstruct memstick_driver *drv = container_of(dev->driver,\r\nstruct memstick_driver,\r\ndriver);\r\nint rc = -ENODEV;\r\nif (dev->driver && drv->probe) {\r\nrc = drv->probe(card);\r\nif (!rc)\r\nget_device(dev);\r\n}\r\nreturn rc;\r\n}\r\nstatic int memstick_device_remove(struct device *dev)\r\n{\r\nstruct memstick_dev *card = container_of(dev, struct memstick_dev,\r\ndev);\r\nstruct memstick_driver *drv = container_of(dev->driver,\r\nstruct memstick_driver,\r\ndriver);\r\nif (dev->driver && drv->remove) {\r\ndrv->remove(card);\r\ncard->dev.driver = NULL;\r\n}\r\nput_device(dev);\r\nreturn 0;\r\n}\r\nstatic int memstick_device_suspend(struct device *dev, pm_message_t state)\r\n{\r\nstruct memstick_dev *card = container_of(dev, struct memstick_dev,\r\ndev);\r\nstruct memstick_driver *drv = container_of(dev->driver,\r\nstruct memstick_driver,\r\ndriver);\r\nif (dev->driver && drv->suspend)\r\nreturn drv->suspend(card, state);\r\nreturn 0;\r\n}\r\nstatic int memstick_device_resume(struct device *dev)\r\n{\r\nstruct memstick_dev *card = container_of(dev, struct memstick_dev,\r\ndev);\r\nstruct memstick_driver *drv = container_of(dev->driver,\r\nstruct memstick_driver,\r\ndriver);\r\nif (dev->driver && drv->resume)\r\nreturn drv->resume(card);\r\nreturn 0;\r\n}\r\nstatic void memstick_free(struct device *dev)\r\n{\r\nstruct memstick_host *host = container_of(dev, struct memstick_host,\r\ndev);\r\nkfree(host);\r\n}\r\nstatic void memstick_free_card(struct device *dev)\r\n{\r\nstruct memstick_dev *card = container_of(dev, struct memstick_dev,\r\ndev);\r\nkfree(card);\r\n}\r\nstatic int memstick_dummy_check(struct memstick_dev *card)\r\n{\r\nreturn 0;\r\n}\r\nvoid memstick_detect_change(struct memstick_host *host)\r\n{\r\nqueue_work(workqueue, &host->media_checker);\r\n}\r\nint memstick_next_req(struct memstick_host *host, struct memstick_request **mrq)\r\n{\r\nint rc = -ENXIO;\r\nif ((*mrq) && (*mrq)->error && host->retries) {\r\n(*mrq)->error = rc;\r\nhost->retries--;\r\nreturn 0;\r\n}\r\nif (host->card && host->card->next_request)\r\nrc = host->card->next_request(host->card, mrq);\r\nif (!rc)\r\nhost->retries = cmd_retries > 1 ? cmd_retries - 1 : 1;\r\nelse\r\n*mrq = NULL;\r\nreturn rc;\r\n}\r\nvoid memstick_new_req(struct memstick_host *host)\r\n{\r\nif (host->card) {\r\nhost->retries = cmd_retries;\r\nreinit_completion(&host->card->mrq_complete);\r\nhost->request(host);\r\n}\r\n}\r\nvoid memstick_init_req_sg(struct memstick_request *mrq, unsigned char tpc,\r\nconst struct scatterlist *sg)\r\n{\r\nmrq->tpc = tpc;\r\nif (tpc & 8)\r\nmrq->data_dir = WRITE;\r\nelse\r\nmrq->data_dir = READ;\r\nmrq->sg = *sg;\r\nmrq->long_data = 1;\r\nif (tpc == MS_TPC_SET_CMD || tpc == MS_TPC_EX_SET_CMD)\r\nmrq->need_card_int = 1;\r\nelse\r\nmrq->need_card_int = 0;\r\n}\r\nvoid memstick_init_req(struct memstick_request *mrq, unsigned char tpc,\r\nconst void *buf, size_t length)\r\n{\r\nmrq->tpc = tpc;\r\nif (tpc & 8)\r\nmrq->data_dir = WRITE;\r\nelse\r\nmrq->data_dir = READ;\r\nmrq->data_len = length > sizeof(mrq->data) ? sizeof(mrq->data) : length;\r\nif (mrq->data_dir == WRITE)\r\nmemcpy(mrq->data, buf, mrq->data_len);\r\nmrq->long_data = 0;\r\nif (tpc == MS_TPC_SET_CMD || tpc == MS_TPC_EX_SET_CMD)\r\nmrq->need_card_int = 1;\r\nelse\r\nmrq->need_card_int = 0;\r\n}\r\nstatic int h_memstick_read_dev_id(struct memstick_dev *card,\r\nstruct memstick_request **mrq)\r\n{\r\nstruct ms_id_register id_reg;\r\nif (!(*mrq)) {\r\nmemstick_init_req(&card->current_mrq, MS_TPC_READ_REG, &id_reg,\r\nsizeof(struct ms_id_register));\r\n*mrq = &card->current_mrq;\r\nreturn 0;\r\n} else {\r\nif (!(*mrq)->error) {\r\nmemcpy(&id_reg, (*mrq)->data, sizeof(id_reg));\r\ncard->id.match_flags = MEMSTICK_MATCH_ALL;\r\ncard->id.type = id_reg.type;\r\ncard->id.category = id_reg.category;\r\ncard->id.class = id_reg.class;\r\ndev_dbg(&card->dev, "if_mode = %02x\n", id_reg.if_mode);\r\n}\r\ncomplete(&card->mrq_complete);\r\nreturn -EAGAIN;\r\n}\r\n}\r\nstatic int h_memstick_set_rw_addr(struct memstick_dev *card,\r\nstruct memstick_request **mrq)\r\n{\r\nif (!(*mrq)) {\r\nmemstick_init_req(&card->current_mrq, MS_TPC_SET_RW_REG_ADRS,\r\n(char *)&card->reg_addr,\r\nsizeof(card->reg_addr));\r\n*mrq = &card->current_mrq;\r\nreturn 0;\r\n} else {\r\ncomplete(&card->mrq_complete);\r\nreturn -EAGAIN;\r\n}\r\n}\r\nint memstick_set_rw_addr(struct memstick_dev *card)\r\n{\r\ncard->next_request = h_memstick_set_rw_addr;\r\nmemstick_new_req(card->host);\r\nwait_for_completion(&card->mrq_complete);\r\nreturn card->current_mrq.error;\r\n}\r\nstatic struct memstick_dev *memstick_alloc_card(struct memstick_host *host)\r\n{\r\nstruct memstick_dev *card = kzalloc(sizeof(struct memstick_dev),\r\nGFP_KERNEL);\r\nstruct memstick_dev *old_card = host->card;\r\nstruct ms_id_register id_reg;\r\nif (card) {\r\ncard->host = host;\r\ndev_set_name(&card->dev, "%s", dev_name(&host->dev));\r\ncard->dev.parent = &host->dev;\r\ncard->dev.bus = &memstick_bus_type;\r\ncard->dev.release = memstick_free_card;\r\ncard->check = memstick_dummy_check;\r\ncard->reg_addr.r_offset = offsetof(struct ms_register, id);\r\ncard->reg_addr.r_length = sizeof(id_reg);\r\ncard->reg_addr.w_offset = offsetof(struct ms_register, id);\r\ncard->reg_addr.w_length = sizeof(id_reg);\r\ninit_completion(&card->mrq_complete);\r\nhost->card = card;\r\nif (memstick_set_rw_addr(card))\r\ngoto err_out;\r\ncard->next_request = h_memstick_read_dev_id;\r\nmemstick_new_req(host);\r\nwait_for_completion(&card->mrq_complete);\r\nif (card->current_mrq.error)\r\ngoto err_out;\r\n}\r\nhost->card = old_card;\r\nreturn card;\r\nerr_out:\r\nhost->card = old_card;\r\nkfree(card);\r\nreturn NULL;\r\n}\r\nstatic int memstick_power_on(struct memstick_host *host)\r\n{\r\nint rc = host->set_param(host, MEMSTICK_POWER, MEMSTICK_POWER_ON);\r\nif (!rc)\r\nrc = host->set_param(host, MEMSTICK_INTERFACE, MEMSTICK_SERIAL);\r\nreturn rc;\r\n}\r\nstatic void memstick_check(struct work_struct *work)\r\n{\r\nstruct memstick_host *host = container_of(work, struct memstick_host,\r\nmedia_checker);\r\nstruct memstick_dev *card;\r\ndev_dbg(&host->dev, "memstick_check started\n");\r\nmutex_lock(&host->lock);\r\nif (!host->card) {\r\nif (memstick_power_on(host))\r\ngoto out_power_off;\r\n} else if (host->card->stop)\r\nhost->card->stop(host->card);\r\ncard = memstick_alloc_card(host);\r\nif (!card) {\r\nif (host->card) {\r\ndevice_unregister(&host->card->dev);\r\nhost->card = NULL;\r\n}\r\n} else {\r\ndev_dbg(&host->dev, "new card %02x, %02x, %02x\n",\r\ncard->id.type, card->id.category, card->id.class);\r\nif (host->card) {\r\nif (memstick_set_rw_addr(host->card)\r\n|| !memstick_dev_match(host->card, &card->id)\r\n|| !(host->card->check(host->card))) {\r\ndevice_unregister(&host->card->dev);\r\nhost->card = NULL;\r\n} else if (host->card->start)\r\nhost->card->start(host->card);\r\n}\r\nif (!host->card) {\r\nhost->card = card;\r\nif (device_register(&card->dev)) {\r\nput_device(&card->dev);\r\nkfree(host->card);\r\nhost->card = NULL;\r\n}\r\n} else\r\nkfree(card);\r\n}\r\nout_power_off:\r\nif (!host->card)\r\nhost->set_param(host, MEMSTICK_POWER, MEMSTICK_POWER_OFF);\r\nmutex_unlock(&host->lock);\r\ndev_dbg(&host->dev, "memstick_check finished\n");\r\n}\r\nstruct memstick_host *memstick_alloc_host(unsigned int extra,\r\nstruct device *dev)\r\n{\r\nstruct memstick_host *host;\r\nhost = kzalloc(sizeof(struct memstick_host) + extra, GFP_KERNEL);\r\nif (host) {\r\nmutex_init(&host->lock);\r\nINIT_WORK(&host->media_checker, memstick_check);\r\nhost->dev.class = &memstick_host_class;\r\nhost->dev.parent = dev;\r\ndevice_initialize(&host->dev);\r\n}\r\nreturn host;\r\n}\r\nint memstick_add_host(struct memstick_host *host)\r\n{\r\nint rc;\r\nidr_preload(GFP_KERNEL);\r\nspin_lock(&memstick_host_lock);\r\nrc = idr_alloc(&memstick_host_idr, host, 0, 0, GFP_NOWAIT);\r\nif (rc >= 0)\r\nhost->id = rc;\r\nspin_unlock(&memstick_host_lock);\r\nidr_preload_end();\r\nif (rc < 0)\r\nreturn rc;\r\ndev_set_name(&host->dev, "memstick%u", host->id);\r\nrc = device_add(&host->dev);\r\nif (rc) {\r\nspin_lock(&memstick_host_lock);\r\nidr_remove(&memstick_host_idr, host->id);\r\nspin_unlock(&memstick_host_lock);\r\nreturn rc;\r\n}\r\nhost->set_param(host, MEMSTICK_POWER, MEMSTICK_POWER_OFF);\r\nmemstick_detect_change(host);\r\nreturn 0;\r\n}\r\nvoid memstick_remove_host(struct memstick_host *host)\r\n{\r\nflush_workqueue(workqueue);\r\nmutex_lock(&host->lock);\r\nif (host->card)\r\ndevice_unregister(&host->card->dev);\r\nhost->card = NULL;\r\nhost->set_param(host, MEMSTICK_POWER, MEMSTICK_POWER_OFF);\r\nmutex_unlock(&host->lock);\r\nspin_lock(&memstick_host_lock);\r\nidr_remove(&memstick_host_idr, host->id);\r\nspin_unlock(&memstick_host_lock);\r\ndevice_del(&host->dev);\r\n}\r\nvoid memstick_free_host(struct memstick_host *host)\r\n{\r\nmutex_destroy(&host->lock);\r\nput_device(&host->dev);\r\n}\r\nvoid memstick_suspend_host(struct memstick_host *host)\r\n{\r\nmutex_lock(&host->lock);\r\nhost->set_param(host, MEMSTICK_POWER, MEMSTICK_POWER_OFF);\r\nmutex_unlock(&host->lock);\r\n}\r\nvoid memstick_resume_host(struct memstick_host *host)\r\n{\r\nint rc = 0;\r\nmutex_lock(&host->lock);\r\nif (host->card)\r\nrc = memstick_power_on(host);\r\nmutex_unlock(&host->lock);\r\nif (!rc)\r\nmemstick_detect_change(host);\r\n}\r\nint memstick_register_driver(struct memstick_driver *drv)\r\n{\r\ndrv->driver.bus = &memstick_bus_type;\r\nreturn driver_register(&drv->driver);\r\n}\r\nvoid memstick_unregister_driver(struct memstick_driver *drv)\r\n{\r\ndriver_unregister(&drv->driver);\r\n}\r\nstatic int __init memstick_init(void)\r\n{\r\nint rc;\r\nworkqueue = create_freezable_workqueue("kmemstick");\r\nif (!workqueue)\r\nreturn -ENOMEM;\r\nrc = bus_register(&memstick_bus_type);\r\nif (!rc)\r\nrc = class_register(&memstick_host_class);\r\nif (!rc)\r\nreturn 0;\r\nbus_unregister(&memstick_bus_type);\r\ndestroy_workqueue(workqueue);\r\nreturn rc;\r\n}\r\nstatic void __exit memstick_exit(void)\r\n{\r\nclass_unregister(&memstick_host_class);\r\nbus_unregister(&memstick_bus_type);\r\ndestroy_workqueue(workqueue);\r\nidr_destroy(&memstick_host_idr);\r\n}
