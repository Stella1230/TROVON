static unsigned long\r\ndc21285_base_address(struct pci_bus *bus, unsigned int devfn)\r\n{\r\nunsigned long addr = 0;\r\nif (bus->number == 0) {\r\nif (PCI_SLOT(devfn) == 0)\r\naddr = ARMCSR_BASE;\r\nelse {\r\ndevfn -= 1 << 3;\r\nif (devfn < PCI_DEVFN(MAX_SLOTS, 0))\r\naddr = PCICFG0_BASE | 0xc00000 | (devfn << 8);\r\n}\r\n} else\r\naddr = PCICFG1_BASE | (bus->number << 16) | (devfn << 8);\r\nreturn addr;\r\n}\r\nstatic int\r\ndc21285_read_config(struct pci_bus *bus, unsigned int devfn, int where,\r\nint size, u32 *value)\r\n{\r\nunsigned long addr = dc21285_base_address(bus, devfn);\r\nu32 v = 0xffffffff;\r\nif (addr)\r\nswitch (size) {\r\ncase 1:\r\nasm("ldrb %0, [%1, %2]"\r\n: "=r" (v) : "r" (addr), "r" (where) : "cc");\r\nbreak;\r\ncase 2:\r\nasm("ldrh %0, [%1, %2]"\r\n: "=r" (v) : "r" (addr), "r" (where) : "cc");\r\nbreak;\r\ncase 4:\r\nasm("ldr %0, [%1, %2]"\r\n: "=r" (v) : "r" (addr), "r" (where) : "cc");\r\nbreak;\r\n}\r\n*value = v;\r\nv = *CSR_PCICMD;\r\nif (v & PCICMD_ABORT) {\r\n*CSR_PCICMD = v & (0xffff|PCICMD_ABORT);\r\nreturn -1;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int\r\ndc21285_write_config(struct pci_bus *bus, unsigned int devfn, int where,\r\nint size, u32 value)\r\n{\r\nunsigned long addr = dc21285_base_address(bus, devfn);\r\nu32 v;\r\nif (addr)\r\nswitch (size) {\r\ncase 1:\r\nasm("strb %0, [%1, %2]"\r\n: : "r" (value), "r" (addr), "r" (where)\r\n: "cc");\r\nbreak;\r\ncase 2:\r\nasm("strh %0, [%1, %2]"\r\n: : "r" (value), "r" (addr), "r" (where)\r\n: "cc");\r\nbreak;\r\ncase 4:\r\nasm("str %0, [%1, %2]"\r\n: : "r" (value), "r" (addr), "r" (where)\r\n: "cc");\r\nbreak;\r\n}\r\nv = *CSR_PCICMD;\r\nif (v & PCICMD_ABORT) {\r\n*CSR_PCICMD = v & (0xffff|PCICMD_ABORT);\r\nreturn -1;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic void dc21285_enable_error(unsigned long __data)\r\n{\r\nswitch (__data) {\r\ncase IRQ_PCI_SERR:\r\ndel_timer(&serr_timer);\r\nbreak;\r\ncase IRQ_PCI_PERR:\r\ndel_timer(&perr_timer);\r\nbreak;\r\n}\r\nenable_irq(__data);\r\n}\r\nstatic irqreturn_t dc21285_abort_irq(int irq, void *dev_id)\r\n{\r\nunsigned int cmd;\r\nunsigned int status;\r\ncmd = *CSR_PCICMD;\r\nstatus = cmd >> 16;\r\ncmd = cmd & 0xffff;\r\nif (status & PCI_STATUS_REC_MASTER_ABORT) {\r\nprintk(KERN_DEBUG "PCI: master abort, pc=0x%08lx\n",\r\ninstruction_pointer(get_irq_regs()));\r\ncmd |= PCI_STATUS_REC_MASTER_ABORT << 16;\r\n}\r\nif (status & PCI_STATUS_REC_TARGET_ABORT) {\r\nprintk(KERN_DEBUG "PCI: target abort: ");\r\npcibios_report_status(PCI_STATUS_REC_MASTER_ABORT |\r\nPCI_STATUS_SIG_TARGET_ABORT |\r\nPCI_STATUS_REC_TARGET_ABORT, 1);\r\nprintk("\n");\r\ncmd |= PCI_STATUS_REC_TARGET_ABORT << 16;\r\n}\r\n*CSR_PCICMD = cmd;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t dc21285_serr_irq(int irq, void *dev_id)\r\n{\r\nstruct timer_list *timer = dev_id;\r\nunsigned int cntl;\r\nprintk(KERN_DEBUG "PCI: system error received: ");\r\npcibios_report_status(PCI_STATUS_SIG_SYSTEM_ERROR, 1);\r\nprintk("\n");\r\ncntl = *CSR_SA110_CNTL & 0xffffdf07;\r\n*CSR_SA110_CNTL = cntl | SA110_CNTL_RXSERR;\r\ndisable_irq(irq);\r\ntimer->expires = jiffies + HZ;\r\nadd_timer(timer);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t dc21285_discard_irq(int irq, void *dev_id)\r\n{\r\nprintk(KERN_DEBUG "PCI: discard timer expired\n");\r\n*CSR_SA110_CNTL &= 0xffffde07;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t dc21285_dparity_irq(int irq, void *dev_id)\r\n{\r\nunsigned int cmd;\r\nprintk(KERN_DEBUG "PCI: data parity error detected: ");\r\npcibios_report_status(PCI_STATUS_PARITY | PCI_STATUS_DETECTED_PARITY, 1);\r\nprintk("\n");\r\ncmd = *CSR_PCICMD & 0xffff;\r\n*CSR_PCICMD = cmd | 1 << 24;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t dc21285_parity_irq(int irq, void *dev_id)\r\n{\r\nstruct timer_list *timer = dev_id;\r\nunsigned int cmd;\r\nprintk(KERN_DEBUG "PCI: parity error detected: ");\r\npcibios_report_status(PCI_STATUS_PARITY | PCI_STATUS_DETECTED_PARITY, 1);\r\nprintk("\n");\r\ncmd = *CSR_PCICMD & 0xffff;\r\n*CSR_PCICMD = cmd | 1 << 31;\r\ndisable_irq(irq);\r\ntimer->expires = jiffies + HZ;\r\nadd_timer(timer);\r\nreturn IRQ_HANDLED;\r\n}\r\nint __init dc21285_setup(int nr, struct pci_sys_data *sys)\r\n{\r\nstruct resource *res;\r\nif (nr || !footbridge_cfn_mode())\r\nreturn 0;\r\nres = kzalloc(sizeof(struct resource) * 2, GFP_KERNEL);\r\nif (!res) {\r\nprintk("out of memory for root bus resources");\r\nreturn 0;\r\n}\r\nres[0].flags = IORESOURCE_MEM;\r\nres[0].name = "Footbridge non-prefetch";\r\nres[1].flags = IORESOURCE_MEM | IORESOURCE_PREFETCH;\r\nres[1].name = "Footbridge prefetch";\r\nallocate_resource(&iomem_resource, &res[1], 0x20000000,\r\n0xa0000000, 0xffffffff, 0x20000000, NULL, NULL);\r\nallocate_resource(&iomem_resource, &res[0], 0x40000000,\r\n0x80000000, 0xffffffff, 0x40000000, NULL, NULL);\r\nsys->mem_offset = DC21285_PCI_MEM;\r\npci_add_resource_offset(&sys->resources, &res[0], sys->mem_offset);\r\npci_add_resource_offset(&sys->resources, &res[1], sys->mem_offset);\r\nreturn 1;\r\n}\r\nvoid __init dc21285_preinit(void)\r\n{\r\nunsigned int mem_size, mem_mask;\r\nint cfn_mode;\r\npcibios_min_mem = 0x81000000;\r\nmem_size = (unsigned int)high_memory - PAGE_OFFSET;\r\nfor (mem_mask = 0x00100000; mem_mask < 0x10000000; mem_mask <<= 1)\r\nif (mem_mask >= mem_size)\r\nbreak;\r\n*CSR_SDRAMBASEMASK = (mem_mask - 1) & 0x0ffc0000;\r\n*CSR_SDRAMBASEOFFSET = 0;\r\n*CSR_ROMBASEMASK = 0x80000000;\r\n*CSR_CSRBASEMASK = 0;\r\n*CSR_CSRBASEOFFSET = 0;\r\n*CSR_PCIADDR_EXTN = 0;\r\ncfn_mode = __footbridge_cfn_mode();\r\nprintk(KERN_INFO "PCI: DC21285 footbridge, revision %02lX, in "\r\n"%s mode\n", *CSR_CLASSREV & 0xff, cfn_mode ?\r\n"central function" : "addin");\r\nif (footbridge_cfn_mode()) {\r\n*CSR_SA110_CNTL = (*CSR_SA110_CNTL & 0xffffde07) |\r\nSA110_CNTL_RXSERR;\r\n*CSR_PCICMD = (*CSR_PCICMD & 0xffff) | PCICMD_ERROR_BITS;\r\n}\r\ninit_timer(&serr_timer);\r\ninit_timer(&perr_timer);\r\nserr_timer.data = IRQ_PCI_SERR;\r\nserr_timer.function = dc21285_enable_error;\r\nperr_timer.data = IRQ_PCI_PERR;\r\nperr_timer.function = dc21285_enable_error;\r\ndc21285_request_irq(IRQ_PCI_SERR, dc21285_serr_irq, 0,\r\n"PCI system error", &serr_timer);\r\ndc21285_request_irq(IRQ_PCI_PERR, dc21285_parity_irq, 0,\r\n"PCI parity error", &perr_timer);\r\ndc21285_request_irq(IRQ_PCI_ABORT, dc21285_abort_irq, 0,\r\n"PCI abort", NULL);\r\ndc21285_request_irq(IRQ_DISCARD_TIMER, dc21285_discard_irq, 0,\r\n"Discard timer", NULL);\r\ndc21285_request_irq(IRQ_PCI_DPERR, dc21285_dparity_irq, 0,\r\n"PCI data parity", NULL);\r\nif (cfn_mode) {\r\n*CSR_PCICSRBASE = 0xf4000000;\r\n*CSR_PCICSRIOBASE = 0;\r\n*CSR_PCISDRAMBASE = __virt_to_bus(PAGE_OFFSET);\r\n*CSR_PCIROMBASE = 0;\r\n*CSR_PCICMD = PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER |\r\nPCI_COMMAND_INVALIDATE | PCICMD_ERROR_BITS;\r\n} else if (footbridge_cfn_mode() != 0) {\r\npanic("PCI: this kernel is compiled for central "\r\n"function mode only");\r\n}\r\n}\r\nvoid __init dc21285_postinit(void)\r\n{\r\nregister_isa_ports(DC21285_PCI_MEM, DC21285_PCI_IO, 0);\r\n}
