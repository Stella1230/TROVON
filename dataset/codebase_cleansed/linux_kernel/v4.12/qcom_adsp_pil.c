static int adsp_load(struct rproc *rproc, const struct firmware *fw)\r\n{\r\nstruct qcom_adsp *adsp = (struct qcom_adsp *)rproc->priv;\r\nreturn qcom_mdt_load(adsp->dev, fw, rproc->firmware, adsp->pas_id,\r\nadsp->mem_region, adsp->mem_phys, adsp->mem_size);\r\n}\r\nstatic int adsp_start(struct rproc *rproc)\r\n{\r\nstruct qcom_adsp *adsp = (struct qcom_adsp *)rproc->priv;\r\nint ret;\r\nret = clk_prepare_enable(adsp->xo);\r\nif (ret)\r\nreturn ret;\r\nret = clk_prepare_enable(adsp->aggre2_clk);\r\nif (ret)\r\ngoto disable_xo_clk;\r\nret = regulator_enable(adsp->cx_supply);\r\nif (ret)\r\ngoto disable_aggre2_clk;\r\nret = regulator_enable(adsp->px_supply);\r\nif (ret)\r\ngoto disable_cx_supply;\r\nret = qcom_scm_pas_auth_and_reset(adsp->pas_id);\r\nif (ret) {\r\ndev_err(adsp->dev,\r\n"failed to authenticate image and release reset\n");\r\ngoto disable_px_supply;\r\n}\r\nret = wait_for_completion_timeout(&adsp->start_done,\r\nmsecs_to_jiffies(5000));\r\nif (!ret) {\r\ndev_err(adsp->dev, "start timed out\n");\r\nqcom_scm_pas_shutdown(adsp->pas_id);\r\nret = -ETIMEDOUT;\r\ngoto disable_px_supply;\r\n}\r\nret = 0;\r\ndisable_px_supply:\r\nregulator_disable(adsp->px_supply);\r\ndisable_cx_supply:\r\nregulator_disable(adsp->cx_supply);\r\ndisable_aggre2_clk:\r\nclk_disable_unprepare(adsp->aggre2_clk);\r\ndisable_xo_clk:\r\nclk_disable_unprepare(adsp->xo);\r\nreturn ret;\r\n}\r\nstatic int adsp_stop(struct rproc *rproc)\r\n{\r\nstruct qcom_adsp *adsp = (struct qcom_adsp *)rproc->priv;\r\nint ret;\r\nqcom_smem_state_update_bits(adsp->state,\r\nBIT(adsp->stop_bit),\r\nBIT(adsp->stop_bit));\r\nret = wait_for_completion_timeout(&adsp->stop_done,\r\nmsecs_to_jiffies(5000));\r\nif (ret == 0)\r\ndev_err(adsp->dev, "timed out on wait\n");\r\nqcom_smem_state_update_bits(adsp->state,\r\nBIT(adsp->stop_bit),\r\n0);\r\nret = qcom_scm_pas_shutdown(adsp->pas_id);\r\nif (ret)\r\ndev_err(adsp->dev, "failed to shutdown: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void *adsp_da_to_va(struct rproc *rproc, u64 da, int len)\r\n{\r\nstruct qcom_adsp *adsp = (struct qcom_adsp *)rproc->priv;\r\nint offset;\r\noffset = da - adsp->mem_reloc;\r\nif (offset < 0 || offset + len > adsp->mem_size)\r\nreturn NULL;\r\nreturn adsp->mem_region + offset;\r\n}\r\nstatic irqreturn_t adsp_wdog_interrupt(int irq, void *dev)\r\n{\r\nstruct qcom_adsp *adsp = dev;\r\nrproc_report_crash(adsp->rproc, RPROC_WATCHDOG);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t adsp_fatal_interrupt(int irq, void *dev)\r\n{\r\nstruct qcom_adsp *adsp = dev;\r\nsize_t len;\r\nchar *msg;\r\nmsg = qcom_smem_get(QCOM_SMEM_HOST_ANY, adsp->crash_reason_smem, &len);\r\nif (!IS_ERR(msg) && len > 0 && msg[0])\r\ndev_err(adsp->dev, "fatal error received: %s\n", msg);\r\nrproc_report_crash(adsp->rproc, RPROC_FATAL_ERROR);\r\nif (!IS_ERR(msg))\r\nmsg[0] = '\0';\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t adsp_ready_interrupt(int irq, void *dev)\r\n{\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t adsp_handover_interrupt(int irq, void *dev)\r\n{\r\nstruct qcom_adsp *adsp = dev;\r\ncomplete(&adsp->start_done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t adsp_stop_ack_interrupt(int irq, void *dev)\r\n{\r\nstruct qcom_adsp *adsp = dev;\r\ncomplete(&adsp->stop_done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int adsp_init_clock(struct qcom_adsp *adsp)\r\n{\r\nint ret;\r\nadsp->xo = devm_clk_get(adsp->dev, "xo");\r\nif (IS_ERR(adsp->xo)) {\r\nret = PTR_ERR(adsp->xo);\r\nif (ret != -EPROBE_DEFER)\r\ndev_err(adsp->dev, "failed to get xo clock");\r\nreturn ret;\r\n}\r\nif (adsp->has_aggre2_clk) {\r\nadsp->aggre2_clk = devm_clk_get(adsp->dev, "aggre2");\r\nif (IS_ERR(adsp->aggre2_clk)) {\r\nret = PTR_ERR(adsp->aggre2_clk);\r\nif (ret != -EPROBE_DEFER)\r\ndev_err(adsp->dev,\r\n"failed to get aggre2 clock");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int adsp_init_regulator(struct qcom_adsp *adsp)\r\n{\r\nadsp->cx_supply = devm_regulator_get(adsp->dev, "cx");\r\nif (IS_ERR(adsp->cx_supply))\r\nreturn PTR_ERR(adsp->cx_supply);\r\nregulator_set_load(adsp->cx_supply, 100000);\r\nadsp->px_supply = devm_regulator_get(adsp->dev, "px");\r\nif (IS_ERR(adsp->px_supply))\r\nreturn PTR_ERR(adsp->px_supply);\r\nreturn 0;\r\n}\r\nstatic int adsp_request_irq(struct qcom_adsp *adsp,\r\nstruct platform_device *pdev,\r\nconst char *name,\r\nirq_handler_t thread_fn)\r\n{\r\nint ret;\r\nret = platform_get_irq_byname(pdev, name);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "no %s IRQ defined\n", name);\r\nreturn ret;\r\n}\r\nret = devm_request_threaded_irq(&pdev->dev, ret,\r\nNULL, thread_fn,\r\nIRQF_ONESHOT,\r\n"adsp", adsp);\r\nif (ret)\r\ndev_err(&pdev->dev, "request %s IRQ failed\n", name);\r\nreturn ret;\r\n}\r\nstatic int adsp_alloc_memory_region(struct qcom_adsp *adsp)\r\n{\r\nstruct device_node *node;\r\nstruct resource r;\r\nint ret;\r\nnode = of_parse_phandle(adsp->dev->of_node, "memory-region", 0);\r\nif (!node) {\r\ndev_err(adsp->dev, "no memory-region specified\n");\r\nreturn -EINVAL;\r\n}\r\nret = of_address_to_resource(node, 0, &r);\r\nif (ret)\r\nreturn ret;\r\nadsp->mem_phys = adsp->mem_reloc = r.start;\r\nadsp->mem_size = resource_size(&r);\r\nadsp->mem_region = devm_ioremap_wc(adsp->dev, adsp->mem_phys, adsp->mem_size);\r\nif (!adsp->mem_region) {\r\ndev_err(adsp->dev, "unable to map memory region: %pa+%zx\n",\r\n&r.start, adsp->mem_size);\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adsp_probe(struct platform_device *pdev)\r\n{\r\nconst struct adsp_data *desc;\r\nstruct qcom_adsp *adsp;\r\nstruct rproc *rproc;\r\nint ret;\r\ndesc = of_device_get_match_data(&pdev->dev);\r\nif (!desc)\r\nreturn -EINVAL;\r\nif (!qcom_scm_is_available())\r\nreturn -EPROBE_DEFER;\r\nrproc = rproc_alloc(&pdev->dev, pdev->name, &adsp_ops,\r\ndesc->firmware_name, sizeof(*adsp));\r\nif (!rproc) {\r\ndev_err(&pdev->dev, "unable to allocate remoteproc\n");\r\nreturn -ENOMEM;\r\n}\r\nrproc->fw_ops = &adsp_fw_ops;\r\nadsp = (struct qcom_adsp *)rproc->priv;\r\nadsp->dev = &pdev->dev;\r\nadsp->rproc = rproc;\r\nadsp->pas_id = desc->pas_id;\r\nadsp->crash_reason_smem = desc->crash_reason_smem;\r\nadsp->has_aggre2_clk = desc->has_aggre2_clk;\r\nplatform_set_drvdata(pdev, adsp);\r\ninit_completion(&adsp->start_done);\r\ninit_completion(&adsp->stop_done);\r\nret = adsp_alloc_memory_region(adsp);\r\nif (ret)\r\ngoto free_rproc;\r\nret = adsp_init_clock(adsp);\r\nif (ret)\r\ngoto free_rproc;\r\nret = adsp_init_regulator(adsp);\r\nif (ret)\r\ngoto free_rproc;\r\nret = adsp_request_irq(adsp, pdev, "wdog", adsp_wdog_interrupt);\r\nif (ret < 0)\r\ngoto free_rproc;\r\nadsp->wdog_irq = ret;\r\nret = adsp_request_irq(adsp, pdev, "fatal", adsp_fatal_interrupt);\r\nif (ret < 0)\r\ngoto free_rproc;\r\nadsp->fatal_irq = ret;\r\nret = adsp_request_irq(adsp, pdev, "ready", adsp_ready_interrupt);\r\nif (ret < 0)\r\ngoto free_rproc;\r\nadsp->ready_irq = ret;\r\nret = adsp_request_irq(adsp, pdev, "handover", adsp_handover_interrupt);\r\nif (ret < 0)\r\ngoto free_rproc;\r\nadsp->handover_irq = ret;\r\nret = adsp_request_irq(adsp, pdev, "stop-ack", adsp_stop_ack_interrupt);\r\nif (ret < 0)\r\ngoto free_rproc;\r\nadsp->stop_ack_irq = ret;\r\nadsp->state = qcom_smem_state_get(&pdev->dev, "stop",\r\n&adsp->stop_bit);\r\nif (IS_ERR(adsp->state)) {\r\nret = PTR_ERR(adsp->state);\r\ngoto free_rproc;\r\n}\r\nqcom_add_smd_subdev(rproc, &adsp->smd_subdev);\r\nret = rproc_add(rproc);\r\nif (ret)\r\ngoto free_rproc;\r\nreturn 0;\r\nfree_rproc:\r\nrproc_free(rproc);\r\nreturn ret;\r\n}\r\nstatic int adsp_remove(struct platform_device *pdev)\r\n{\r\nstruct qcom_adsp *adsp = platform_get_drvdata(pdev);\r\nqcom_smem_state_put(adsp->state);\r\nrproc_del(adsp->rproc);\r\nqcom_remove_smd_subdev(adsp->rproc, &adsp->smd_subdev);\r\nrproc_free(adsp->rproc);\r\nreturn 0;\r\n}
