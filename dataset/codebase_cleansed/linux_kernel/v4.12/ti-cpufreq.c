static unsigned long amx3_efuse_xlate(struct ti_cpufreq_data *opp_data,\r\nunsigned long efuse)\r\n{\r\nif (!efuse)\r\nefuse = opp_data->soc_data->efuse_fallback;\r\nreturn ~efuse;\r\n}\r\nstatic unsigned long dra7_efuse_xlate(struct ti_cpufreq_data *opp_data,\r\nunsigned long efuse)\r\n{\r\nunsigned long calculated_efuse = DRA7_EFUSE_NOM_MPU_OPP;\r\nswitch (efuse) {\r\ncase DRA7_EFUSE_HAS_ALL_MPU_OPP:\r\ncase DRA7_EFUSE_HAS_HIGH_MPU_OPP:\r\ncalculated_efuse |= DRA7_EFUSE_HIGH_MPU_OPP;\r\ncase DRA7_EFUSE_HAS_OD_MPU_OPP:\r\ncalculated_efuse |= DRA7_EFUSE_OD_MPU_OPP;\r\n}\r\nreturn calculated_efuse;\r\n}\r\nstatic int ti_cpufreq_get_efuse(struct ti_cpufreq_data *opp_data,\r\nu32 *efuse_value)\r\n{\r\nstruct device *dev = opp_data->cpu_dev;\r\nu32 efuse;\r\nint ret;\r\nret = regmap_read(opp_data->syscon, opp_data->soc_data->efuse_offset,\r\n&efuse);\r\nif (ret) {\r\ndev_err(dev,\r\n"Failed to read the efuse value from syscon: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nefuse = (efuse & opp_data->soc_data->efuse_mask);\r\nefuse >>= opp_data->soc_data->efuse_shift;\r\n*efuse_value = opp_data->soc_data->efuse_xlate(opp_data, efuse);\r\nreturn 0;\r\n}\r\nstatic int ti_cpufreq_get_rev(struct ti_cpufreq_data *opp_data,\r\nu32 *revision_value)\r\n{\r\nstruct device *dev = opp_data->cpu_dev;\r\nu32 revision;\r\nint ret;\r\nret = regmap_read(opp_data->syscon, opp_data->soc_data->rev_offset,\r\n&revision);\r\nif (ret) {\r\ndev_err(dev,\r\n"Failed to read the revision number from syscon: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n*revision_value = BIT((revision >> REVISION_SHIFT) & REVISION_MASK);\r\nreturn 0;\r\n}\r\nstatic int ti_cpufreq_setup_syscon_register(struct ti_cpufreq_data *opp_data)\r\n{\r\nstruct device *dev = opp_data->cpu_dev;\r\nstruct device_node *np = opp_data->opp_node;\r\nopp_data->syscon = syscon_regmap_lookup_by_phandle(np,\r\n"syscon");\r\nif (IS_ERR(opp_data->syscon)) {\r\ndev_err(dev,\r\n"\"syscon\" is missing, cannot use OPPv2 table.\n");\r\nreturn PTR_ERR(opp_data->syscon);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ti_cpufreq_init(void)\r\n{\r\nu32 version[VERSION_COUNT];\r\nstruct device_node *np;\r\nconst struct of_device_id *match;\r\nstruct ti_cpufreq_data *opp_data;\r\nint ret;\r\nnp = of_find_node_by_path("/");\r\nmatch = of_match_node(ti_cpufreq_of_match, np);\r\nif (!match)\r\nreturn -ENODEV;\r\nopp_data = kzalloc(sizeof(*opp_data), GFP_KERNEL);\r\nif (!opp_data)\r\nreturn -ENOMEM;\r\nopp_data->soc_data = match->data;\r\nopp_data->cpu_dev = get_cpu_device(0);\r\nif (!opp_data->cpu_dev) {\r\npr_err("%s: Failed to get device for CPU0\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nopp_data->opp_node = dev_pm_opp_of_get_opp_desc_node(opp_data->cpu_dev);\r\nif (!opp_data->opp_node) {\r\ndev_info(opp_data->cpu_dev,\r\n"OPP-v2 not supported, cpufreq-dt will attempt to use legacy tables.\n");\r\ngoto register_cpufreq_dt;\r\n}\r\nret = ti_cpufreq_setup_syscon_register(opp_data);\r\nif (ret)\r\ngoto fail_put_node;\r\nret = ti_cpufreq_get_rev(opp_data, &version[0]);\r\nif (ret)\r\ngoto fail_put_node;\r\nret = ti_cpufreq_get_efuse(opp_data, &version[1]);\r\nif (ret)\r\ngoto fail_put_node;\r\nof_node_put(opp_data->opp_node);\r\nret = PTR_ERR_OR_ZERO(dev_pm_opp_set_supported_hw(opp_data->cpu_dev,\r\nversion, VERSION_COUNT));\r\nif (ret) {\r\ndev_err(opp_data->cpu_dev,\r\n"Failed to set supported hardware\n");\r\ngoto fail_put_node;\r\n}\r\nregister_cpufreq_dt:\r\nplatform_device_register_simple("cpufreq-dt", -1, NULL, 0);\r\nreturn 0;\r\nfail_put_node:\r\nof_node_put(opp_data->opp_node);\r\nreturn ret;\r\n}
