static int ak8974_set_power(struct ak8974 *ak8974, bool mode)\r\n{\r\nint ret;\r\nu8 val;\r\nval = mode ? AK8974_CTRL1_POWER : 0;\r\nval |= AK8974_CTRL1_FORCE_EN;\r\nret = regmap_write(ak8974->map, AK8974_CTRL1, val);\r\nif (ret < 0)\r\nreturn ret;\r\nif (mode)\r\nmsleep(AK8974_ACTIVATE_DELAY);\r\nreturn 0;\r\n}\r\nstatic int ak8974_reset(struct ak8974 *ak8974)\r\n{\r\nint ret;\r\nret = ak8974_set_power(ak8974, AK8974_PWR_ON);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_write(ak8974->map, AK8974_CTRL2, AK8974_CTRL2_RESDEF);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_write(ak8974->map, AK8974_CTRL3, AK8974_CTRL3_RESDEF);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_write(ak8974->map, AK8974_INT_CTRL,\r\nAK8974_INT_CTRL_RESDEF);\r\nif (ret)\r\nreturn ret;\r\nreturn ak8974_set_power(ak8974, AK8974_PWR_OFF);\r\n}\r\nstatic int ak8974_configure(struct ak8974 *ak8974)\r\n{\r\nint ret;\r\nret = regmap_write(ak8974->map, AK8974_CTRL2, AK8974_CTRL2_DRDY_EN |\r\nAK8974_CTRL2_INT_EN);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_write(ak8974->map, AK8974_CTRL3, 0);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_write(ak8974->map, AK8974_INT_CTRL, AK8974_INT_CTRL_POL);\r\nif (ret)\r\nreturn ret;\r\nreturn regmap_write(ak8974->map, AK8974_PRESET, 0);\r\n}\r\nstatic int ak8974_trigmeas(struct ak8974 *ak8974)\r\n{\r\nunsigned int clear;\r\nu8 mask;\r\nu8 val;\r\nint ret;\r\nret = regmap_read(ak8974->map, AK8974_INT_CLEAR, &clear);\r\nif (ret)\r\nreturn ret;\r\nif (ak8974->drdy_irq) {\r\nmask = AK8974_CTRL2_INT_EN |\r\nAK8974_CTRL2_DRDY_EN |\r\nAK8974_CTRL2_DRDY_POL;\r\nval = AK8974_CTRL2_DRDY_EN;\r\nif (!ak8974->drdy_active_low)\r\nval |= AK8974_CTRL2_DRDY_POL;\r\ninit_completion(&ak8974->drdy_complete);\r\nret = regmap_update_bits(ak8974->map, AK8974_CTRL2,\r\nmask, val);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn regmap_update_bits(ak8974->map,\r\nAK8974_CTRL3,\r\nAK8974_CTRL3_FORCE,\r\nAK8974_CTRL3_FORCE);\r\n}\r\nstatic int ak8974_await_drdy(struct ak8974 *ak8974)\r\n{\r\nint timeout = 2;\r\nunsigned int val;\r\nint ret;\r\nif (ak8974->drdy_irq) {\r\nret = wait_for_completion_timeout(&ak8974->drdy_complete,\r\n1 + msecs_to_jiffies(1000));\r\nif (!ret) {\r\ndev_err(&ak8974->i2c->dev,\r\n"timeout waiting for DRDY IRQ\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\ndo {\r\nmsleep(AK8974_MEASTIME);\r\nret = regmap_read(ak8974->map, AK8974_STATUS, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nif (val & AK8974_STATUS_DRDY)\r\nreturn 0;\r\n} while (--timeout);\r\ndev_err(&ak8974->i2c->dev, "timeout waiting for DRDY\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int ak8974_getresult(struct ak8974 *ak8974, __le16 *result)\r\n{\r\nunsigned int src;\r\nint ret;\r\nret = ak8974_await_drdy(ak8974);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_read(ak8974->map, AK8974_INT_SRC, &src);\r\nif (ret < 0)\r\nreturn ret;\r\nif (src & AK8974_INT_RANGE) {\r\ndev_err(&ak8974->i2c->dev,\r\n"range overflow in sensor\n");\r\nreturn -ERANGE;\r\n}\r\nret = regmap_bulk_read(ak8974->map, AK8974_DATA_X, result, 6);\r\nif (ret)\r\nreturn ret;\r\nreturn ret;\r\n}\r\nstatic irqreturn_t ak8974_drdy_irq(int irq, void *d)\r\n{\r\nstruct ak8974 *ak8974 = d;\r\nif (!ak8974->drdy_irq)\r\nreturn IRQ_NONE;\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic irqreturn_t ak8974_drdy_irq_thread(int irq, void *d)\r\n{\r\nstruct ak8974 *ak8974 = d;\r\nunsigned int val;\r\nint ret;\r\nret = regmap_read(ak8974->map, AK8974_STATUS, &val);\r\nif (ret < 0) {\r\ndev_err(&ak8974->i2c->dev, "error reading DRDY status\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nif (val & AK8974_STATUS_DRDY) {\r\ncomplete(&ak8974->drdy_complete);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic int ak8974_selftest(struct ak8974 *ak8974)\r\n{\r\nstruct device *dev = &ak8974->i2c->dev;\r\nunsigned int val;\r\nint ret;\r\nret = regmap_read(ak8974->map, AK8974_SELFTEST, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val != AK8974_SELFTEST_IDLE) {\r\ndev_err(dev, "selftest not idle before test\n");\r\nreturn -EIO;\r\n}\r\nret = regmap_update_bits(ak8974->map,\r\nAK8974_CTRL3,\r\nAK8974_CTRL3_SELFTEST,\r\nAK8974_CTRL3_SELFTEST);\r\nif (ret) {\r\ndev_err(dev, "could not write CTRL3\n");\r\nreturn ret;\r\n}\r\nmsleep(AK8974_SELFTEST_DELAY);\r\nret = regmap_read(ak8974->map, AK8974_SELFTEST, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val != AK8974_SELFTEST_OK) {\r\ndev_err(dev, "selftest result NOT OK (%02x)\n", val);\r\nreturn -EIO;\r\n}\r\nret = regmap_read(ak8974->map, AK8974_SELFTEST, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val != AK8974_SELFTEST_IDLE) {\r\ndev_err(dev, "selftest not idle after test (%02x)\n", val);\r\nreturn -EIO;\r\n}\r\ndev_dbg(dev, "passed self-test\n");\r\nreturn 0;\r\n}\r\nstatic int ak8974_get_u16_val(struct ak8974 *ak8974, u8 reg, u16 *val)\r\n{\r\nint ret;\r\n__le16 bulk;\r\nret = regmap_bulk_read(ak8974->map, reg, &bulk, 2);\r\nif (ret)\r\nreturn ret;\r\n*val = le16_to_cpu(bulk);\r\nreturn 0;\r\n}\r\nstatic int ak8974_detect(struct ak8974 *ak8974)\r\n{\r\nunsigned int whoami;\r\nconst char *name;\r\nint ret;\r\nunsigned int fw;\r\nu16 sn;\r\nret = regmap_read(ak8974->map, AK8974_WHOAMI, &whoami);\r\nif (ret)\r\nreturn ret;\r\nswitch (whoami) {\r\ncase AK8974_WHOAMI_VALUE_AMI305:\r\nname = "ami305";\r\nret = regmap_read(ak8974->map, AMI305_VER, &fw);\r\nif (ret)\r\nreturn ret;\r\nfw &= 0x7f;\r\nret = ak8974_get_u16_val(ak8974, AMI305_SN, &sn);\r\nif (ret)\r\nreturn ret;\r\ndev_info(&ak8974->i2c->dev,\r\n"detected %s, FW ver %02x, S/N: %04x\n",\r\nname, fw, sn);\r\nbreak;\r\ncase AK8974_WHOAMI_VALUE_AK8974:\r\nname = "ak8974";\r\ndev_info(&ak8974->i2c->dev, "detected AK8974\n");\r\nbreak;\r\ndefault:\r\ndev_err(&ak8974->i2c->dev, "unsupported device (%02x) ",\r\nwhoami);\r\nreturn -ENODEV;\r\n}\r\nak8974->name = name;\r\nak8974->variant = whoami;\r\nreturn 0;\r\n}\r\nstatic int ak8974_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2,\r\nlong mask)\r\n{\r\nstruct ak8974 *ak8974 = iio_priv(indio_dev);\r\n__le16 hw_values[3];\r\nint ret = -EINVAL;\r\npm_runtime_get_sync(&ak8974->i2c->dev);\r\nmutex_lock(&ak8974->lock);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nif (chan->address > 2) {\r\ndev_err(&ak8974->i2c->dev, "faulty channel address\n");\r\nret = -EIO;\r\ngoto out_unlock;\r\n}\r\nret = ak8974_trigmeas(ak8974);\r\nif (ret)\r\ngoto out_unlock;\r\nret = ak8974_getresult(ak8974, hw_values);\r\nif (ret)\r\ngoto out_unlock;\r\n*val = le16_to_cpu(hw_values[chan->address]);\r\nret = IIO_VAL_INT;\r\n}\r\nout_unlock:\r\nmutex_unlock(&ak8974->lock);\r\npm_runtime_mark_last_busy(&ak8974->i2c->dev);\r\npm_runtime_put_autosuspend(&ak8974->i2c->dev);\r\nreturn ret;\r\n}\r\nstatic void ak8974_fill_buffer(struct iio_dev *indio_dev)\r\n{\r\nstruct ak8974 *ak8974 = iio_priv(indio_dev);\r\nint ret;\r\n__le16 hw_values[8];\r\npm_runtime_get_sync(&ak8974->i2c->dev);\r\nmutex_lock(&ak8974->lock);\r\nret = ak8974_trigmeas(ak8974);\r\nif (ret) {\r\ndev_err(&ak8974->i2c->dev, "error triggering measure\n");\r\ngoto out_unlock;\r\n}\r\nret = ak8974_getresult(ak8974, hw_values);\r\nif (ret) {\r\ndev_err(&ak8974->i2c->dev, "error getting measures\n");\r\ngoto out_unlock;\r\n}\r\niio_push_to_buffers_with_timestamp(indio_dev, hw_values,\r\niio_get_time_ns(indio_dev));\r\nout_unlock:\r\nmutex_unlock(&ak8974->lock);\r\npm_runtime_mark_last_busy(&ak8974->i2c->dev);\r\npm_runtime_put_autosuspend(&ak8974->i2c->dev);\r\n}\r\nstatic irqreturn_t ak8974_handle_trigger(int irq, void *p)\r\n{\r\nconst struct iio_poll_func *pf = p;\r\nstruct iio_dev *indio_dev = pf->indio_dev;\r\nak8974_fill_buffer(indio_dev);\r\niio_trigger_notify_done(indio_dev->trig);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic const struct iio_mount_matrix *\r\nak8974_get_mount_matrix(const struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan)\r\n{\r\nstruct ak8974 *ak8974 = iio_priv(indio_dev);\r\nreturn &ak8974->orientation;\r\n}\r\nstatic bool ak8974_writeable_reg(struct device *dev, unsigned int reg)\r\n{\r\nstruct i2c_client *i2c = to_i2c_client(dev);\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(i2c);\r\nstruct ak8974 *ak8974 = iio_priv(indio_dev);\r\nswitch (reg) {\r\ncase AK8974_CTRL1:\r\ncase AK8974_CTRL2:\r\ncase AK8974_CTRL3:\r\ncase AK8974_INT_CTRL:\r\ncase AK8974_INT_THRES:\r\ncase AK8974_INT_THRES + 1:\r\ncase AK8974_PRESET:\r\ncase AK8974_PRESET + 1:\r\nreturn true;\r\ncase AK8974_OFFSET_X:\r\ncase AK8974_OFFSET_X + 1:\r\ncase AK8974_OFFSET_Y:\r\ncase AK8974_OFFSET_Y + 1:\r\ncase AK8974_OFFSET_Z:\r\ncase AK8974_OFFSET_Z + 1:\r\nif (ak8974->variant == AK8974_WHOAMI_VALUE_AK8974)\r\nreturn true;\r\nreturn false;\r\ncase AMI305_OFFSET_X:\r\ncase AMI305_OFFSET_X + 1:\r\ncase AMI305_OFFSET_Y:\r\ncase AMI305_OFFSET_Y + 1:\r\ncase AMI305_OFFSET_Z:\r\ncase AMI305_OFFSET_Z + 1:\r\nif (ak8974->variant == AK8974_WHOAMI_VALUE_AMI305)\r\nreturn true;\r\nreturn false;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int ak8974_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct iio_dev *indio_dev;\r\nstruct ak8974 *ak8974;\r\nunsigned long irq_trig;\r\nint irq = i2c->irq;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(&i2c->dev, sizeof(*ak8974));\r\nif (indio_dev == NULL)\r\nreturn -ENOMEM;\r\nak8974 = iio_priv(indio_dev);\r\ni2c_set_clientdata(i2c, indio_dev);\r\nak8974->i2c = i2c;\r\nmutex_init(&ak8974->lock);\r\nret = of_iio_read_mount_matrix(&i2c->dev,\r\n"mount-matrix",\r\n&ak8974->orientation);\r\nif (ret)\r\nreturn ret;\r\nak8974->regs[0].supply = ak8974_reg_avdd;\r\nak8974->regs[1].supply = ak8974_reg_dvdd;\r\nret = devm_regulator_bulk_get(&i2c->dev,\r\nARRAY_SIZE(ak8974->regs),\r\nak8974->regs);\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "cannot get regulators\n");\r\nreturn ret;\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(ak8974->regs), ak8974->regs);\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "cannot enable regulators\n");\r\nreturn ret;\r\n}\r\npm_runtime_get_noresume(&i2c->dev);\r\npm_runtime_set_active(&i2c->dev);\r\npm_runtime_enable(&i2c->dev);\r\nak8974->map = devm_regmap_init_i2c(i2c, &ak8974_regmap_config);\r\nif (IS_ERR(ak8974->map)) {\r\ndev_err(&i2c->dev, "failed to allocate register map\n");\r\nreturn PTR_ERR(ak8974->map);\r\n}\r\nret = ak8974_set_power(ak8974, AK8974_PWR_ON);\r\nif (ret) {\r\ndev_err(&i2c->dev, "could not power on\n");\r\ngoto power_off;\r\n}\r\nret = ak8974_detect(ak8974);\r\nif (ret) {\r\ndev_err(&i2c->dev, "neither AK8974 nor AMI305 found\n");\r\ngoto power_off;\r\n}\r\nret = ak8974_selftest(ak8974);\r\nif (ret)\r\ndev_err(&i2c->dev, "selftest failed (continuing anyway)\n");\r\nret = ak8974_reset(ak8974);\r\nif (ret) {\r\ndev_err(&i2c->dev, "AK8974 reset failed\n");\r\ngoto power_off;\r\n}\r\npm_runtime_set_autosuspend_delay(&i2c->dev,\r\nAK8974_AUTOSUSPEND_DELAY);\r\npm_runtime_use_autosuspend(&i2c->dev);\r\npm_runtime_put(&i2c->dev);\r\nindio_dev->dev.parent = &i2c->dev;\r\nindio_dev->channels = ak8974_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(ak8974_channels);\r\nindio_dev->info = &ak8974_info;\r\nindio_dev->available_scan_masks = ak8974_scan_masks;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->name = ak8974->name;\r\nret = iio_triggered_buffer_setup(indio_dev, NULL,\r\nak8974_handle_trigger,\r\nNULL);\r\nif (ret) {\r\ndev_err(&i2c->dev, "triggered buffer setup failed\n");\r\ngoto disable_pm;\r\n}\r\nif (irq > 0) {\r\nirq_trig = irqd_get_trigger_type(irq_get_irq_data(irq));\r\nif (irq_trig == IRQF_TRIGGER_RISING) {\r\ndev_info(&i2c->dev, "enable rising edge DRDY IRQ\n");\r\n} else if (irq_trig == IRQF_TRIGGER_FALLING) {\r\nak8974->drdy_active_low = true;\r\ndev_info(&i2c->dev, "enable falling edge DRDY IRQ\n");\r\n} else {\r\nirq_trig = IRQF_TRIGGER_RISING;\r\n}\r\nirq_trig |= IRQF_ONESHOT;\r\nirq_trig |= IRQF_SHARED;\r\nret = devm_request_threaded_irq(&i2c->dev,\r\nirq,\r\nak8974_drdy_irq,\r\nak8974_drdy_irq_thread,\r\nirq_trig,\r\nak8974->name,\r\nak8974);\r\nif (ret) {\r\ndev_err(&i2c->dev, "unable to request DRDY IRQ "\r\n"- proceeding without IRQ\n");\r\ngoto no_irq;\r\n}\r\nak8974->drdy_irq = true;\r\n}\r\nno_irq:\r\nret = iio_device_register(indio_dev);\r\nif (ret) {\r\ndev_err(&i2c->dev, "device register failed\n");\r\ngoto cleanup_buffer;\r\n}\r\nreturn 0;\r\ncleanup_buffer:\r\niio_triggered_buffer_cleanup(indio_dev);\r\ndisable_pm:\r\npm_runtime_put_noidle(&i2c->dev);\r\npm_runtime_disable(&i2c->dev);\r\nak8974_set_power(ak8974, AK8974_PWR_OFF);\r\npower_off:\r\nregulator_bulk_disable(ARRAY_SIZE(ak8974->regs), ak8974->regs);\r\nreturn ret;\r\n}\r\nstatic int ak8974_remove(struct i2c_client *i2c)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(i2c);\r\nstruct ak8974 *ak8974 = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\niio_triggered_buffer_cleanup(indio_dev);\r\npm_runtime_get_sync(&i2c->dev);\r\npm_runtime_put_noidle(&i2c->dev);\r\npm_runtime_disable(&i2c->dev);\r\nak8974_set_power(ak8974, AK8974_PWR_OFF);\r\nregulator_bulk_disable(ARRAY_SIZE(ak8974->regs), ak8974->regs);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused ak8974_runtime_suspend(struct device *dev)\r\n{\r\nstruct ak8974 *ak8974 =\r\niio_priv(i2c_get_clientdata(to_i2c_client(dev)));\r\nak8974_set_power(ak8974, AK8974_PWR_OFF);\r\nregulator_bulk_disable(ARRAY_SIZE(ak8974->regs), ak8974->regs);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused ak8974_runtime_resume(struct device *dev)\r\n{\r\nstruct ak8974 *ak8974 =\r\niio_priv(i2c_get_clientdata(to_i2c_client(dev)));\r\nint ret;\r\nret = regulator_bulk_enable(ARRAY_SIZE(ak8974->regs), ak8974->regs);\r\nif (ret)\r\nreturn ret;\r\nmsleep(AK8974_POWERON_DELAY);\r\nret = ak8974_set_power(ak8974, AK8974_PWR_ON);\r\nif (ret)\r\ngoto out_regulator_disable;\r\nret = ak8974_configure(ak8974);\r\nif (ret)\r\ngoto out_disable_power;\r\nreturn 0;\r\nout_disable_power:\r\nak8974_set_power(ak8974, AK8974_PWR_OFF);\r\nout_regulator_disable:\r\nregulator_bulk_disable(ARRAY_SIZE(ak8974->regs), ak8974->regs);\r\nreturn ret;\r\n}
