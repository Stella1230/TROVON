static int hw_to_current(const unsigned int *tbl, size_t size, unsigned int val)\r\n{\r\nif (val >= size)\r\nreturn -EINVAL;\r\nreturn tbl[val];\r\n}\r\nstatic int current_to_hw(const unsigned int *tbl, size_t size, unsigned int val)\r\n{\r\nsize_t i;\r\nfor (i = 0; i < size; i++)\r\nif (val < tbl[i])\r\nbreak;\r\nreturn i > 0 ? i - 1 : -EINVAL;\r\n}\r\nstatic int smb347_update_ps_status(struct smb347_charger *smb)\r\n{\r\nbool usb = false;\r\nbool dc = false;\r\nunsigned int val;\r\nint ret;\r\nret = regmap_read(smb->regmap, IRQSTAT_E, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nif (smb->pdata->use_mains)\r\ndc = !(val & IRQSTAT_E_DCIN_UV_STAT);\r\nif (smb->pdata->use_usb)\r\nusb = !(val & IRQSTAT_E_USBIN_UV_STAT);\r\nmutex_lock(&smb->lock);\r\nret = smb->mains_online != dc || smb->usb_online != usb;\r\nsmb->mains_online = dc;\r\nsmb->usb_online = usb;\r\nmutex_unlock(&smb->lock);\r\nreturn ret;\r\n}\r\nstatic bool smb347_is_ps_online(struct smb347_charger *smb)\r\n{\r\nbool ret;\r\nmutex_lock(&smb->lock);\r\nret = smb->usb_online || smb->mains_online;\r\nmutex_unlock(&smb->lock);\r\nreturn ret;\r\n}\r\nstatic int smb347_charging_status(struct smb347_charger *smb)\r\n{\r\nunsigned int val;\r\nint ret;\r\nif (!smb347_is_ps_online(smb))\r\nreturn 0;\r\nret = regmap_read(smb->regmap, STAT_C, &val);\r\nif (ret < 0)\r\nreturn 0;\r\nreturn (val & STAT_C_CHG_MASK) >> STAT_C_CHG_SHIFT;\r\n}\r\nstatic int smb347_charging_set(struct smb347_charger *smb, bool enable)\r\n{\r\nint ret = 0;\r\nif (smb->pdata->enable_control != SMB347_CHG_ENABLE_SW) {\r\ndev_dbg(smb->dev, "charging enable/disable in SW disabled\n");\r\nreturn 0;\r\n}\r\nmutex_lock(&smb->lock);\r\nif (smb->charging_enabled != enable) {\r\nret = regmap_update_bits(smb->regmap, CMD_A, CMD_A_CHG_ENABLED,\r\nenable ? CMD_A_CHG_ENABLED : 0);\r\nif (!ret)\r\nsmb->charging_enabled = enable;\r\n}\r\nmutex_unlock(&smb->lock);\r\nreturn ret;\r\n}\r\nstatic inline int smb347_charging_enable(struct smb347_charger *smb)\r\n{\r\nreturn smb347_charging_set(smb, true);\r\n}\r\nstatic inline int smb347_charging_disable(struct smb347_charger *smb)\r\n{\r\nreturn smb347_charging_set(smb, false);\r\n}\r\nstatic int smb347_start_stop_charging(struct smb347_charger *smb)\r\n{\r\nint ret;\r\nif (smb347_is_ps_online(smb)) {\r\nret = smb347_charging_enable(smb);\r\nif (ret < 0)\r\ndev_err(smb->dev, "failed to enable charging\n");\r\n} else {\r\nret = smb347_charging_disable(smb);\r\nif (ret < 0)\r\ndev_err(smb->dev, "failed to disable charging\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic int smb347_set_charge_current(struct smb347_charger *smb)\r\n{\r\nint ret;\r\nif (smb->pdata->max_charge_current) {\r\nret = current_to_hw(fcc_tbl, ARRAY_SIZE(fcc_tbl),\r\nsmb->pdata->max_charge_current);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_update_bits(smb->regmap, CFG_CHARGE_CURRENT,\r\nCFG_CHARGE_CURRENT_FCC_MASK,\r\nret << CFG_CHARGE_CURRENT_FCC_SHIFT);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (smb->pdata->pre_charge_current) {\r\nret = current_to_hw(pcc_tbl, ARRAY_SIZE(pcc_tbl),\r\nsmb->pdata->pre_charge_current);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_update_bits(smb->regmap, CFG_CHARGE_CURRENT,\r\nCFG_CHARGE_CURRENT_PCC_MASK,\r\nret << CFG_CHARGE_CURRENT_PCC_SHIFT);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (smb->pdata->termination_current) {\r\nret = current_to_hw(tc_tbl, ARRAY_SIZE(tc_tbl),\r\nsmb->pdata->termination_current);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_update_bits(smb->regmap, CFG_CHARGE_CURRENT,\r\nCFG_CHARGE_CURRENT_TC_MASK, ret);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smb347_set_current_limits(struct smb347_charger *smb)\r\n{\r\nint ret;\r\nif (smb->pdata->mains_current_limit) {\r\nret = current_to_hw(icl_tbl, ARRAY_SIZE(icl_tbl),\r\nsmb->pdata->mains_current_limit);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_update_bits(smb->regmap, CFG_CURRENT_LIMIT,\r\nCFG_CURRENT_LIMIT_DC_MASK,\r\nret << CFG_CURRENT_LIMIT_DC_SHIFT);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (smb->pdata->usb_hc_current_limit) {\r\nret = current_to_hw(icl_tbl, ARRAY_SIZE(icl_tbl),\r\nsmb->pdata->usb_hc_current_limit);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_update_bits(smb->regmap, CFG_CURRENT_LIMIT,\r\nCFG_CURRENT_LIMIT_USB_MASK, ret);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smb347_set_voltage_limits(struct smb347_charger *smb)\r\n{\r\nint ret;\r\nif (smb->pdata->pre_to_fast_voltage) {\r\nret = smb->pdata->pre_to_fast_voltage;\r\nret = clamp_val(ret, 2400000, 3000000) - 2400000;\r\nret /= 200000;\r\nret = regmap_update_bits(smb->regmap, CFG_FLOAT_VOLTAGE,\r\nCFG_FLOAT_VOLTAGE_THRESHOLD_MASK,\r\nret << CFG_FLOAT_VOLTAGE_THRESHOLD_SHIFT);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (smb->pdata->max_charge_voltage) {\r\nret = smb->pdata->max_charge_voltage;\r\nret = clamp_val(ret, 3500000, 4500000) - 3500000;\r\nret /= 20000;\r\nret = regmap_update_bits(smb->regmap, CFG_FLOAT_VOLTAGE,\r\nCFG_FLOAT_VOLTAGE_FLOAT_MASK, ret);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smb347_set_temp_limits(struct smb347_charger *smb)\r\n{\r\nbool enable_therm_monitor = false;\r\nint ret = 0;\r\nint val;\r\nif (smb->pdata->chip_temp_threshold) {\r\nval = smb->pdata->chip_temp_threshold;\r\nval = clamp_val(val, 100, 130) - 100;\r\nval /= 10;\r\nret = regmap_update_bits(smb->regmap, CFG_OTG,\r\nCFG_OTG_TEMP_THRESHOLD_MASK,\r\nval << CFG_OTG_TEMP_THRESHOLD_SHIFT);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (smb->pdata->soft_cold_temp_limit != SMB347_TEMP_USE_DEFAULT) {\r\nval = smb->pdata->soft_cold_temp_limit;\r\nval = clamp_val(val, 0, 15);\r\nval /= 5;\r\nval = ~val & 0x3;\r\nret = regmap_update_bits(smb->regmap, CFG_TEMP_LIMIT,\r\nCFG_TEMP_LIMIT_SOFT_COLD_MASK,\r\nval << CFG_TEMP_LIMIT_SOFT_COLD_SHIFT);\r\nif (ret < 0)\r\nreturn ret;\r\nenable_therm_monitor = true;\r\n}\r\nif (smb->pdata->soft_hot_temp_limit != SMB347_TEMP_USE_DEFAULT) {\r\nval = smb->pdata->soft_hot_temp_limit;\r\nval = clamp_val(val, 40, 55) - 40;\r\nval /= 5;\r\nret = regmap_update_bits(smb->regmap, CFG_TEMP_LIMIT,\r\nCFG_TEMP_LIMIT_SOFT_HOT_MASK,\r\nval << CFG_TEMP_LIMIT_SOFT_HOT_SHIFT);\r\nif (ret < 0)\r\nreturn ret;\r\nenable_therm_monitor = true;\r\n}\r\nif (smb->pdata->hard_cold_temp_limit != SMB347_TEMP_USE_DEFAULT) {\r\nval = smb->pdata->hard_cold_temp_limit;\r\nval = clamp_val(val, -5, 10) + 5;\r\nval /= 5;\r\nval = ~val & 0x3;\r\nret = regmap_update_bits(smb->regmap, CFG_TEMP_LIMIT,\r\nCFG_TEMP_LIMIT_HARD_COLD_MASK,\r\nval << CFG_TEMP_LIMIT_HARD_COLD_SHIFT);\r\nif (ret < 0)\r\nreturn ret;\r\nenable_therm_monitor = true;\r\n}\r\nif (smb->pdata->hard_hot_temp_limit != SMB347_TEMP_USE_DEFAULT) {\r\nval = smb->pdata->hard_hot_temp_limit;\r\nval = clamp_val(val, 50, 65) - 50;\r\nval /= 5;\r\nret = regmap_update_bits(smb->regmap, CFG_TEMP_LIMIT,\r\nCFG_TEMP_LIMIT_HARD_HOT_MASK,\r\nval << CFG_TEMP_LIMIT_HARD_HOT_SHIFT);\r\nif (ret < 0)\r\nreturn ret;\r\nenable_therm_monitor = true;\r\n}\r\nif (enable_therm_monitor) {\r\nret = regmap_update_bits(smb->regmap, CFG_THERM,\r\nCFG_THERM_MONITOR_DISABLED, 0);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (smb->pdata->suspend_on_hard_temp_limit) {\r\nret = regmap_update_bits(smb->regmap, CFG_SYSOK,\r\nCFG_SYSOK_SUSPEND_HARD_LIMIT_DISABLED, 0);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (smb->pdata->soft_temp_limit_compensation !=\r\nSMB347_SOFT_TEMP_COMPENSATE_DEFAULT) {\r\nval = smb->pdata->soft_temp_limit_compensation & 0x3;\r\nret = regmap_update_bits(smb->regmap, CFG_THERM,\r\nCFG_THERM_SOFT_HOT_COMPENSATION_MASK,\r\nval << CFG_THERM_SOFT_HOT_COMPENSATION_SHIFT);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_update_bits(smb->regmap, CFG_THERM,\r\nCFG_THERM_SOFT_COLD_COMPENSATION_MASK,\r\nval << CFG_THERM_SOFT_COLD_COMPENSATION_SHIFT);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (smb->pdata->charge_current_compensation) {\r\nval = current_to_hw(ccc_tbl, ARRAY_SIZE(ccc_tbl),\r\nsmb->pdata->charge_current_compensation);\r\nif (val < 0)\r\nreturn val;\r\nret = regmap_update_bits(smb->regmap, CFG_OTG,\r\nCFG_OTG_CC_COMPENSATION_MASK,\r\n(val & 0x3) << CFG_OTG_CC_COMPENSATION_SHIFT);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int smb347_set_writable(struct smb347_charger *smb, bool writable)\r\n{\r\nreturn regmap_update_bits(smb->regmap, CMD_A, CMD_A_ALLOW_WRITE,\r\nwritable ? CMD_A_ALLOW_WRITE : 0);\r\n}\r\nstatic int smb347_hw_init(struct smb347_charger *smb)\r\n{\r\nunsigned int val;\r\nint ret;\r\nret = smb347_set_writable(smb, true);\r\nif (ret < 0)\r\nreturn ret;\r\nret = smb347_set_charge_current(smb);\r\nif (ret < 0)\r\ngoto fail;\r\nret = smb347_set_current_limits(smb);\r\nif (ret < 0)\r\ngoto fail;\r\nret = smb347_set_voltage_limits(smb);\r\nif (ret < 0)\r\ngoto fail;\r\nret = smb347_set_temp_limits(smb);\r\nif (ret < 0)\r\ngoto fail;\r\nif (!smb->pdata->use_usb) {\r\nret = regmap_update_bits(smb->regmap, CMD_A,\r\nCMD_A_SUSPEND_ENABLED,\r\nCMD_A_SUSPEND_ENABLED);\r\nif (ret < 0)\r\ngoto fail;\r\n}\r\nret = regmap_update_bits(smb->regmap, CFG_OTHER, CFG_OTHER_RID_MASK,\r\nsmb->pdata->use_usb_otg ? CFG_OTHER_RID_ENABLED_AUTO_OTG : 0);\r\nif (ret < 0)\r\ngoto fail;\r\nswitch (smb->pdata->enable_control) {\r\ncase SMB347_CHG_ENABLE_PIN_ACTIVE_LOW:\r\nval = CFG_PIN_EN_CTRL_ACTIVE_LOW;\r\nbreak;\r\ncase SMB347_CHG_ENABLE_PIN_ACTIVE_HIGH:\r\nval = CFG_PIN_EN_CTRL_ACTIVE_HIGH;\r\nbreak;\r\ndefault:\r\nval = 0;\r\nbreak;\r\n}\r\nret = regmap_update_bits(smb->regmap, CFG_PIN, CFG_PIN_EN_CTRL_MASK,\r\nval);\r\nif (ret < 0)\r\ngoto fail;\r\nret = regmap_update_bits(smb->regmap, CFG_PIN, CFG_PIN_EN_APSD_IRQ, 0);\r\nif (ret < 0)\r\ngoto fail;\r\nret = smb347_update_ps_status(smb);\r\nif (ret < 0)\r\ngoto fail;\r\nret = smb347_start_stop_charging(smb);\r\nfail:\r\nsmb347_set_writable(smb, false);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t smb347_interrupt(int irq, void *data)\r\n{\r\nstruct smb347_charger *smb = data;\r\nunsigned int stat_c, irqstat_c, irqstat_d, irqstat_e;\r\nbool handled = false;\r\nint ret;\r\nret = regmap_read(smb->regmap, STAT_C, &stat_c);\r\nif (ret < 0) {\r\ndev_warn(smb->dev, "reading STAT_C failed\n");\r\nreturn IRQ_NONE;\r\n}\r\nret = regmap_read(smb->regmap, IRQSTAT_C, &irqstat_c);\r\nif (ret < 0) {\r\ndev_warn(smb->dev, "reading IRQSTAT_C failed\n");\r\nreturn IRQ_NONE;\r\n}\r\nret = regmap_read(smb->regmap, IRQSTAT_D, &irqstat_d);\r\nif (ret < 0) {\r\ndev_warn(smb->dev, "reading IRQSTAT_D failed\n");\r\nreturn IRQ_NONE;\r\n}\r\nret = regmap_read(smb->regmap, IRQSTAT_E, &irqstat_e);\r\nif (ret < 0) {\r\ndev_warn(smb->dev, "reading IRQSTAT_E failed\n");\r\nreturn IRQ_NONE;\r\n}\r\nif (stat_c & STAT_C_CHARGER_ERROR) {\r\ndev_err(smb->dev, "charging stopped due to charger error\n");\r\npower_supply_changed(smb->battery);\r\nhandled = true;\r\n}\r\nif (irqstat_c & (IRQSTAT_C_TERMINATION_IRQ | IRQSTAT_C_TAPER_IRQ)) {\r\nif (irqstat_c & IRQSTAT_C_TERMINATION_STAT)\r\npower_supply_changed(smb->battery);\r\ndev_dbg(smb->dev, "going to HW maintenance mode\n");\r\nhandled = true;\r\n}\r\nif (irqstat_d & IRQSTAT_D_CHARGE_TIMEOUT_IRQ) {\r\ndev_dbg(smb->dev, "total Charge Timeout INT received\n");\r\nif (irqstat_d & IRQSTAT_D_CHARGE_TIMEOUT_STAT)\r\ndev_warn(smb->dev, "charging stopped due to timeout\n");\r\npower_supply_changed(smb->battery);\r\nhandled = true;\r\n}\r\nif (irqstat_e & (IRQSTAT_E_USBIN_UV_IRQ | IRQSTAT_E_DCIN_UV_IRQ)) {\r\nif (smb347_update_ps_status(smb) > 0) {\r\nsmb347_start_stop_charging(smb);\r\nif (smb->pdata->use_mains)\r\npower_supply_changed(smb->mains);\r\nif (smb->pdata->use_usb)\r\npower_supply_changed(smb->usb);\r\n}\r\nhandled = true;\r\n}\r\nreturn handled ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic int smb347_irq_set(struct smb347_charger *smb, bool enable)\r\n{\r\nint ret;\r\nret = smb347_set_writable(smb, true);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_update_bits(smb->regmap, CFG_FAULT_IRQ, 0xff,\r\nenable ? CFG_FAULT_IRQ_DCIN_UV : 0);\r\nif (ret < 0)\r\ngoto fail;\r\nret = regmap_update_bits(smb->regmap, CFG_STATUS_IRQ, 0xff,\r\nenable ? (CFG_STATUS_IRQ_TERMINATION_OR_TAPER |\r\nCFG_STATUS_IRQ_CHARGE_TIMEOUT) : 0);\r\nif (ret < 0)\r\ngoto fail;\r\nret = regmap_update_bits(smb->regmap, CFG_PIN, CFG_PIN_EN_CHARGER_ERROR,\r\nenable ? CFG_PIN_EN_CHARGER_ERROR : 0);\r\nfail:\r\nsmb347_set_writable(smb, false);\r\nreturn ret;\r\n}\r\nstatic inline int smb347_irq_enable(struct smb347_charger *smb)\r\n{\r\nreturn smb347_irq_set(smb, true);\r\n}\r\nstatic inline int smb347_irq_disable(struct smb347_charger *smb)\r\n{\r\nreturn smb347_irq_set(smb, false);\r\n}\r\nstatic int smb347_irq_init(struct smb347_charger *smb,\r\nstruct i2c_client *client)\r\n{\r\nconst struct smb347_charger_platform_data *pdata = smb->pdata;\r\nint ret, irq = gpio_to_irq(pdata->irq_gpio);\r\nret = gpio_request_one(pdata->irq_gpio, GPIOF_IN, client->name);\r\nif (ret < 0)\r\ngoto fail;\r\nret = request_threaded_irq(irq, NULL, smb347_interrupt,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\nclient->name, smb);\r\nif (ret < 0)\r\ngoto fail_gpio;\r\nret = smb347_set_writable(smb, true);\r\nif (ret < 0)\r\ngoto fail_irq;\r\nret = regmap_update_bits(smb->regmap, CFG_STAT,\r\nCFG_STAT_ACTIVE_HIGH | CFG_STAT_DISABLED,\r\nCFG_STAT_DISABLED);\r\nif (ret < 0)\r\ngoto fail_readonly;\r\nsmb347_set_writable(smb, false);\r\nclient->irq = irq;\r\nreturn 0;\r\nfail_readonly:\r\nsmb347_set_writable(smb, false);\r\nfail_irq:\r\nfree_irq(irq, smb);\r\nfail_gpio:\r\ngpio_free(pdata->irq_gpio);\r\nfail:\r\nclient->irq = 0;\r\nreturn ret;\r\n}\r\nstatic int get_const_charge_current(struct smb347_charger *smb)\r\n{\r\nint ret, intval;\r\nunsigned int v;\r\nif (!smb347_is_ps_online(smb))\r\nreturn -ENODATA;\r\nret = regmap_read(smb->regmap, STAT_B, &v);\r\nif (ret < 0)\r\nreturn ret;\r\nif (v & 0x20) {\r\nintval = hw_to_current(fcc_tbl, ARRAY_SIZE(fcc_tbl), v & 7);\r\n} else {\r\nv >>= 3;\r\nintval = hw_to_current(pcc_tbl, ARRAY_SIZE(pcc_tbl), v & 7);\r\n}\r\nreturn intval;\r\n}\r\nstatic int get_const_charge_voltage(struct smb347_charger *smb)\r\n{\r\nint ret, intval;\r\nunsigned int v;\r\nif (!smb347_is_ps_online(smb))\r\nreturn -ENODATA;\r\nret = regmap_read(smb->regmap, STAT_A, &v);\r\nif (ret < 0)\r\nreturn ret;\r\nv &= STAT_A_FLOAT_VOLTAGE_MASK;\r\nif (v > 0x3d)\r\nv = 0x3d;\r\nintval = 3500000 + v * 20000;\r\nreturn intval;\r\n}\r\nstatic int smb347_mains_get_property(struct power_supply *psy,\r\nenum power_supply_property prop,\r\nunion power_supply_propval *val)\r\n{\r\nstruct smb347_charger *smb = power_supply_get_drvdata(psy);\r\nint ret;\r\nswitch (prop) {\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nval->intval = smb->mains_online;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\r\nret = get_const_charge_voltage(smb);\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nval->intval = ret;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\r\nret = get_const_charge_current(smb);\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nval->intval = ret;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smb347_usb_get_property(struct power_supply *psy,\r\nenum power_supply_property prop,\r\nunion power_supply_propval *val)\r\n{\r\nstruct smb347_charger *smb = power_supply_get_drvdata(psy);\r\nint ret;\r\nswitch (prop) {\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nval->intval = smb->usb_online;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\r\nret = get_const_charge_voltage(smb);\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nval->intval = ret;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\r\nret = get_const_charge_current(smb);\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nval->intval = ret;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smb347_get_charging_status(struct smb347_charger *smb)\r\n{\r\nint ret, status;\r\nunsigned int val;\r\nif (!smb347_is_ps_online(smb))\r\nreturn POWER_SUPPLY_STATUS_DISCHARGING;\r\nret = regmap_read(smb->regmap, STAT_C, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nif ((val & STAT_C_CHARGER_ERROR) ||\r\n(val & STAT_C_HOLDOFF_STAT)) {\r\nstatus = POWER_SUPPLY_STATUS_NOT_CHARGING;\r\n} else {\r\nif ((val & STAT_C_CHG_MASK) >> STAT_C_CHG_SHIFT) {\r\nstatus = POWER_SUPPLY_STATUS_CHARGING;\r\n} else if (val & STAT_C_CHG_TERM) {\r\nstatus = POWER_SUPPLY_STATUS_FULL;\r\n} else {\r\nstatus = POWER_SUPPLY_STATUS_NOT_CHARGING;\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic int smb347_battery_get_property(struct power_supply *psy,\r\nenum power_supply_property prop,\r\nunion power_supply_propval *val)\r\n{\r\nstruct smb347_charger *smb = power_supply_get_drvdata(psy);\r\nconst struct smb347_charger_platform_data *pdata = smb->pdata;\r\nint ret;\r\nret = smb347_update_ps_status(smb);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (prop) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nret = smb347_get_charging_status(smb);\r\nif (ret < 0)\r\nreturn ret;\r\nval->intval = ret;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_TYPE:\r\nif (!smb347_is_ps_online(smb))\r\nreturn -ENODATA;\r\nswitch (smb347_charging_status(smb)) {\r\ncase 1:\r\nval->intval = POWER_SUPPLY_CHARGE_TYPE_TRICKLE;\r\nbreak;\r\ncase 2:\r\nval->intval = POWER_SUPPLY_CHARGE_TYPE_FAST;\r\nbreak;\r\ndefault:\r\nval->intval = POWER_SUPPLY_CHARGE_TYPE_NONE;\r\nbreak;\r\n}\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TECHNOLOGY:\r\nval->intval = pdata->battery_info.technology;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\r\nval->intval = pdata->battery_info.voltage_min_design;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\r\nval->intval = pdata->battery_info.voltage_max_design;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\r\nval->intval = pdata->battery_info.charge_full_design;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_MODEL_NAME:\r\nval->strval = pdata->battery_info.name;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool smb347_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase IRQSTAT_A:\r\ncase IRQSTAT_C:\r\ncase IRQSTAT_E:\r\ncase IRQSTAT_F:\r\ncase STAT_A:\r\ncase STAT_B:\r\ncase STAT_C:\r\ncase STAT_E:\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool smb347_readable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase CFG_CHARGE_CURRENT:\r\ncase CFG_CURRENT_LIMIT:\r\ncase CFG_FLOAT_VOLTAGE:\r\ncase CFG_STAT:\r\ncase CFG_PIN:\r\ncase CFG_THERM:\r\ncase CFG_SYSOK:\r\ncase CFG_OTHER:\r\ncase CFG_OTG:\r\ncase CFG_TEMP_LIMIT:\r\ncase CFG_FAULT_IRQ:\r\ncase CFG_STATUS_IRQ:\r\ncase CFG_ADDRESS:\r\ncase CMD_A:\r\ncase CMD_B:\r\ncase CMD_C:\r\nreturn true;\r\n}\r\nreturn smb347_volatile_reg(dev, reg);\r\n}\r\nstatic int smb347_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstatic char *battery[] = { "smb347-battery" };\r\nconst struct smb347_charger_platform_data *pdata;\r\nstruct power_supply_config mains_usb_cfg = {}, battery_cfg = {};\r\nstruct device *dev = &client->dev;\r\nstruct smb347_charger *smb;\r\nint ret;\r\npdata = dev->platform_data;\r\nif (!pdata)\r\nreturn -EINVAL;\r\nif (!pdata->use_mains && !pdata->use_usb)\r\nreturn -EINVAL;\r\nsmb = devm_kzalloc(dev, sizeof(*smb), GFP_KERNEL);\r\nif (!smb)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, smb);\r\nmutex_init(&smb->lock);\r\nsmb->dev = &client->dev;\r\nsmb->pdata = pdata;\r\nsmb->regmap = devm_regmap_init_i2c(client, &smb347_regmap);\r\nif (IS_ERR(smb->regmap))\r\nreturn PTR_ERR(smb->regmap);\r\nret = smb347_hw_init(smb);\r\nif (ret < 0)\r\nreturn ret;\r\nmains_usb_cfg.supplied_to = battery;\r\nmains_usb_cfg.num_supplicants = ARRAY_SIZE(battery);\r\nmains_usb_cfg.drv_data = smb;\r\nif (smb->pdata->use_mains) {\r\nsmb->mains = power_supply_register(dev, &smb347_mains_desc,\r\n&mains_usb_cfg);\r\nif (IS_ERR(smb->mains))\r\nreturn PTR_ERR(smb->mains);\r\n}\r\nif (smb->pdata->use_usb) {\r\nsmb->usb = power_supply_register(dev, &smb347_usb_desc,\r\n&mains_usb_cfg);\r\nif (IS_ERR(smb->usb)) {\r\nif (smb->pdata->use_mains)\r\npower_supply_unregister(smb->mains);\r\nreturn PTR_ERR(smb->usb);\r\n}\r\n}\r\nbattery_cfg.drv_data = smb;\r\nsmb->battery = power_supply_register(dev, &smb347_battery_desc,\r\n&battery_cfg);\r\nif (IS_ERR(smb->battery)) {\r\nif (smb->pdata->use_usb)\r\npower_supply_unregister(smb->usb);\r\nif (smb->pdata->use_mains)\r\npower_supply_unregister(smb->mains);\r\nreturn PTR_ERR(smb->battery);\r\n}\r\nif (pdata->irq_gpio >= 0) {\r\nret = smb347_irq_init(smb, client);\r\nif (ret < 0) {\r\ndev_warn(dev, "failed to initialize IRQ: %d\n", ret);\r\ndev_warn(dev, "disabling IRQ support\n");\r\n} else {\r\nsmb347_irq_enable(smb);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int smb347_remove(struct i2c_client *client)\r\n{\r\nstruct smb347_charger *smb = i2c_get_clientdata(client);\r\nif (client->irq) {\r\nsmb347_irq_disable(smb);\r\nfree_irq(client->irq, smb);\r\ngpio_free(smb->pdata->irq_gpio);\r\n}\r\npower_supply_unregister(smb->battery);\r\nif (smb->pdata->use_usb)\r\npower_supply_unregister(smb->usb);\r\nif (smb->pdata->use_mains)\r\npower_supply_unregister(smb->mains);\r\nreturn 0;\r\n}
