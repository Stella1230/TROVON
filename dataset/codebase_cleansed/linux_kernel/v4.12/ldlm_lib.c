static int import_set_conn(struct obd_import *imp, struct obd_uuid *uuid,\r\nint priority, int create)\r\n{\r\nstruct ptlrpc_connection *ptlrpc_conn;\r\nstruct obd_import_conn *imp_conn = NULL, *item;\r\nint rc = 0;\r\nif (!create && !priority) {\r\nCDEBUG(D_HA, "Nothing to do\n");\r\nreturn -EINVAL;\r\n}\r\nptlrpc_conn = ptlrpc_uuid_to_connection(uuid);\r\nif (!ptlrpc_conn) {\r\nCDEBUG(D_HA, "can't find connection %s\n", uuid->uuid);\r\nreturn -ENOENT;\r\n}\r\nif (create) {\r\nimp_conn = kzalloc(sizeof(*imp_conn), GFP_NOFS);\r\nif (!imp_conn) {\r\nrc = -ENOMEM;\r\ngoto out_put;\r\n}\r\n}\r\nspin_lock(&imp->imp_lock);\r\nlist_for_each_entry(item, &imp->imp_conn_list, oic_item) {\r\nif (obd_uuid_equals(uuid, &item->oic_uuid)) {\r\nif (priority) {\r\nlist_del(&item->oic_item);\r\nlist_add(&item->oic_item,\r\n&imp->imp_conn_list);\r\nitem->oic_last_attempt = 0;\r\n}\r\nCDEBUG(D_HA, "imp %p@%s: found existing conn %s%s\n",\r\nimp, imp->imp_obd->obd_name, uuid->uuid,\r\n(priority ? ", moved to head" : ""));\r\nspin_unlock(&imp->imp_lock);\r\nrc = 0;\r\ngoto out_free;\r\n}\r\n}\r\nif (create) {\r\nimp_conn->oic_conn = ptlrpc_conn;\r\nimp_conn->oic_uuid = *uuid;\r\nimp_conn->oic_last_attempt = 0;\r\nif (priority)\r\nlist_add(&imp_conn->oic_item, &imp->imp_conn_list);\r\nelse\r\nlist_add_tail(&imp_conn->oic_item,\r\n&imp->imp_conn_list);\r\nCDEBUG(D_HA, "imp %p@%s: add connection %s at %s\n",\r\nimp, imp->imp_obd->obd_name, uuid->uuid,\r\n(priority ? "head" : "tail"));\r\n} else {\r\nspin_unlock(&imp->imp_lock);\r\nrc = -ENOENT;\r\ngoto out_free;\r\n}\r\nspin_unlock(&imp->imp_lock);\r\nreturn 0;\r\nout_free:\r\nkfree(imp_conn);\r\nout_put:\r\nptlrpc_connection_put(ptlrpc_conn);\r\nreturn rc;\r\n}\r\nint import_set_conn_priority(struct obd_import *imp, struct obd_uuid *uuid)\r\n{\r\nreturn import_set_conn(imp, uuid, 1, 0);\r\n}\r\nint client_import_add_conn(struct obd_import *imp, struct obd_uuid *uuid,\r\nint priority)\r\n{\r\nreturn import_set_conn(imp, uuid, priority, 1);\r\n}\r\nint client_import_del_conn(struct obd_import *imp, struct obd_uuid *uuid)\r\n{\r\nstruct obd_import_conn *imp_conn;\r\nstruct obd_export *dlmexp;\r\nint rc = -ENOENT;\r\nspin_lock(&imp->imp_lock);\r\nif (list_empty(&imp->imp_conn_list)) {\r\nLASSERT(!imp->imp_connection);\r\ngoto out;\r\n}\r\nlist_for_each_entry(imp_conn, &imp->imp_conn_list, oic_item) {\r\nif (!obd_uuid_equals(uuid, &imp_conn->oic_uuid))\r\ncontinue;\r\nLASSERT(imp_conn->oic_conn);\r\nif (imp_conn == imp->imp_conn_current) {\r\nLASSERT(imp_conn->oic_conn == imp->imp_connection);\r\nif (imp->imp_state != LUSTRE_IMP_CLOSED &&\r\nimp->imp_state != LUSTRE_IMP_DISCON) {\r\nCERROR("can't remove current connection\n");\r\nrc = -EBUSY;\r\ngoto out;\r\n}\r\nptlrpc_connection_put(imp->imp_connection);\r\nimp->imp_connection = NULL;\r\ndlmexp = class_conn2export(&imp->imp_dlm_handle);\r\nif (dlmexp && dlmexp->exp_connection) {\r\nLASSERT(dlmexp->exp_connection ==\r\nimp_conn->oic_conn);\r\nptlrpc_connection_put(dlmexp->exp_connection);\r\ndlmexp->exp_connection = NULL;\r\n}\r\nif (dlmexp)\r\nclass_export_put(dlmexp);\r\n}\r\nlist_del(&imp_conn->oic_item);\r\nptlrpc_connection_put(imp_conn->oic_conn);\r\nkfree(imp_conn);\r\nCDEBUG(D_HA, "imp %p@%s: remove connection %s\n",\r\nimp, imp->imp_obd->obd_name, uuid->uuid);\r\nrc = 0;\r\nbreak;\r\n}\r\nout:\r\nspin_unlock(&imp->imp_lock);\r\nif (rc == -ENOENT)\r\nCERROR("connection %s not found\n", uuid->uuid);\r\nreturn rc;\r\n}\r\nint client_import_find_conn(struct obd_import *imp, lnet_nid_t peer,\r\nstruct obd_uuid *uuid)\r\n{\r\nstruct obd_import_conn *conn;\r\nint rc = -ENOENT;\r\nspin_lock(&imp->imp_lock);\r\nlist_for_each_entry(conn, &imp->imp_conn_list, oic_item) {\r\nif (class_check_uuid(&conn->oic_uuid, peer)) {\r\n*uuid = conn->oic_uuid;\r\nrc = 0;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&imp->imp_lock);\r\nreturn rc;\r\n}\r\nvoid client_destroy_import(struct obd_import *imp)\r\n{\r\nclass_import_get(imp);\r\nclass_destroy_import(imp);\r\nsptlrpc_import_sec_put(imp);\r\nclass_import_put(imp);\r\n}\r\nint client_obd_setup(struct obd_device *obddev, struct lustre_cfg *lcfg)\r\n{\r\nstruct client_obd *cli = &obddev->u.cli;\r\nstruct obd_import *imp;\r\nstruct obd_uuid server_uuid;\r\nint rq_portal, rp_portal, connect_op;\r\nchar *name = obddev->obd_type->typ_name;\r\nenum ldlm_ns_type ns_type = LDLM_NS_TYPE_UNKNOWN;\r\nint rc;\r\nif (!strcmp(name, LUSTRE_OSC_NAME)) {\r\nrq_portal = OST_REQUEST_PORTAL;\r\nrp_portal = OSC_REPLY_PORTAL;\r\nconnect_op = OST_CONNECT;\r\ncli->cl_sp_me = LUSTRE_SP_CLI;\r\ncli->cl_sp_to = LUSTRE_SP_OST;\r\nns_type = LDLM_NS_TYPE_OSC;\r\n} else if (!strcmp(name, LUSTRE_MDC_NAME) ||\r\n!strcmp(name, LUSTRE_LWP_NAME)) {\r\nrq_portal = MDS_REQUEST_PORTAL;\r\nrp_portal = MDC_REPLY_PORTAL;\r\nconnect_op = MDS_CONNECT;\r\ncli->cl_sp_me = LUSTRE_SP_CLI;\r\ncli->cl_sp_to = LUSTRE_SP_MDT;\r\nns_type = LDLM_NS_TYPE_MDC;\r\n} else if (!strcmp(name, LUSTRE_MGC_NAME)) {\r\nrq_portal = MGS_REQUEST_PORTAL;\r\nrp_portal = MGC_REPLY_PORTAL;\r\nconnect_op = MGS_CONNECT;\r\ncli->cl_sp_me = LUSTRE_SP_MGC;\r\ncli->cl_sp_to = LUSTRE_SP_MGS;\r\ncli->cl_flvr_mgc.sf_rpc = SPTLRPC_FLVR_INVALID;\r\nns_type = LDLM_NS_TYPE_MGC;\r\n} else {\r\nCERROR("unknown client OBD type \"%s\", can't setup\n",\r\nname);\r\nreturn -EINVAL;\r\n}\r\nif (LUSTRE_CFG_BUFLEN(lcfg, 1) < 1) {\r\nCERROR("requires a TARGET UUID\n");\r\nreturn -EINVAL;\r\n}\r\nif (LUSTRE_CFG_BUFLEN(lcfg, 1) > 37) {\r\nCERROR("client UUID must be less than 38 characters\n");\r\nreturn -EINVAL;\r\n}\r\nif (LUSTRE_CFG_BUFLEN(lcfg, 2) < 1) {\r\nCERROR("setup requires a SERVER UUID\n");\r\nreturn -EINVAL;\r\n}\r\nif (LUSTRE_CFG_BUFLEN(lcfg, 2) > 37) {\r\nCERROR("target UUID must be less than 38 characters\n");\r\nreturn -EINVAL;\r\n}\r\ninit_rwsem(&cli->cl_sem);\r\ncli->cl_conn_count = 0;\r\nmemcpy(server_uuid.uuid, lustre_cfg_buf(lcfg, 2),\r\nmin_t(unsigned int, LUSTRE_CFG_BUFLEN(lcfg, 2),\r\nsizeof(server_uuid)));\r\ncli->cl_dirty_pages = 0;\r\ncli->cl_avail_grant = 0;\r\nclient_adjust_max_dirty(cli);\r\nINIT_LIST_HEAD(&cli->cl_cache_waiters);\r\nINIT_LIST_HEAD(&cli->cl_loi_ready_list);\r\nINIT_LIST_HEAD(&cli->cl_loi_hp_ready_list);\r\nINIT_LIST_HEAD(&cli->cl_loi_write_list);\r\nINIT_LIST_HEAD(&cli->cl_loi_read_list);\r\nspin_lock_init(&cli->cl_loi_list_lock);\r\natomic_set(&cli->cl_pending_w_pages, 0);\r\natomic_set(&cli->cl_pending_r_pages, 0);\r\ncli->cl_r_in_flight = 0;\r\ncli->cl_w_in_flight = 0;\r\nspin_lock_init(&cli->cl_read_rpc_hist.oh_lock);\r\nspin_lock_init(&cli->cl_write_rpc_hist.oh_lock);\r\nspin_lock_init(&cli->cl_read_page_hist.oh_lock);\r\nspin_lock_init(&cli->cl_write_page_hist.oh_lock);\r\nspin_lock_init(&cli->cl_read_offset_hist.oh_lock);\r\nspin_lock_init(&cli->cl_write_offset_hist.oh_lock);\r\nINIT_LIST_HEAD(&cli->cl_lru_osc);\r\natomic_set(&cli->cl_lru_shrinkers, 0);\r\natomic_long_set(&cli->cl_lru_busy, 0);\r\natomic_long_set(&cli->cl_lru_in_list, 0);\r\nINIT_LIST_HEAD(&cli->cl_lru_list);\r\nspin_lock_init(&cli->cl_lru_list_lock);\r\natomic_long_set(&cli->cl_unstable_count, 0);\r\nINIT_LIST_HEAD(&cli->cl_shrink_list);\r\ninit_waitqueue_head(&cli->cl_destroy_waitq);\r\natomic_set(&cli->cl_destroy_in_flight, 0);\r\ncli->cl_checksum = 1;\r\ncli->cl_cksum_type = OBD_CKSUM_CRC32;\r\ncli->cl_supp_cksum_types = OBD_CKSUM_CRC32;\r\natomic_set(&cli->cl_resends, OSC_DEFAULT_RESENDS);\r\ncli->cl_max_pages_per_rpc = PTLRPC_MAX_BRW_PAGES;\r\ncli->cl_chunkbits = PAGE_SHIFT;\r\nif (!strcmp(name, LUSTRE_MDC_NAME)) {\r\ncli->cl_max_rpcs_in_flight = OBD_MAX_RIF_DEFAULT;\r\n} else if (totalram_pages >> (20 - PAGE_SHIFT) <= 128 ) {\r\ncli->cl_max_rpcs_in_flight = 2;\r\n} else if (totalram_pages >> (20 - PAGE_SHIFT) <= 256 ) {\r\ncli->cl_max_rpcs_in_flight = 3;\r\n} else if (totalram_pages >> (20 - PAGE_SHIFT) <= 512 ) {\r\ncli->cl_max_rpcs_in_flight = 4;\r\n} else {\r\ncli->cl_max_rpcs_in_flight = OBD_MAX_RIF_DEFAULT;\r\n}\r\nspin_lock_init(&cli->cl_mod_rpcs_lock);\r\nspin_lock_init(&cli->cl_mod_rpcs_hist.oh_lock);\r\ncli->cl_max_mod_rpcs_in_flight = 0;\r\ncli->cl_mod_rpcs_in_flight = 0;\r\ncli->cl_close_rpcs_in_flight = 0;\r\ninit_waitqueue_head(&cli->cl_mod_rpcs_waitq);\r\ncli->cl_mod_tag_bitmap = NULL;\r\nif (connect_op == MDS_CONNECT) {\r\ncli->cl_max_mod_rpcs_in_flight = cli->cl_max_rpcs_in_flight - 1;\r\ncli->cl_mod_tag_bitmap = kcalloc(BITS_TO_LONGS(OBD_MAX_RIF_MAX),\r\nsizeof(long), GFP_NOFS);\r\nif (!cli->cl_mod_tag_bitmap) {\r\nrc = -ENOMEM;\r\ngoto err;\r\n}\r\n}\r\nrc = ldlm_get_ref();\r\nif (rc) {\r\nCERROR("ldlm_get_ref failed: %d\n", rc);\r\ngoto err;\r\n}\r\nptlrpc_init_client(rq_portal, rp_portal, name,\r\n&obddev->obd_ldlm_client);\r\nimp = class_new_import(obddev);\r\nif (!imp) {\r\nrc = -ENOENT;\r\ngoto err_ldlm;\r\n}\r\nimp->imp_client = &obddev->obd_ldlm_client;\r\nimp->imp_connect_op = connect_op;\r\nmemcpy(cli->cl_target_uuid.uuid, lustre_cfg_buf(lcfg, 1),\r\nLUSTRE_CFG_BUFLEN(lcfg, 1));\r\nclass_import_put(imp);\r\nrc = client_import_add_conn(imp, &server_uuid, 1);\r\nif (rc) {\r\nCERROR("can't add initial connection\n");\r\ngoto err_import;\r\n}\r\ncli->cl_import = imp;\r\ncli->cl_max_mds_easize = sizeof(struct lov_mds_md_v3);\r\nif (LUSTRE_CFG_BUFLEN(lcfg, 3) > 0) {\r\nif (!strcmp(lustre_cfg_string(lcfg, 3), "inactive")) {\r\nCDEBUG(D_HA, "marking %s %s->%s as inactive\n",\r\nname, obddev->obd_name,\r\ncli->cl_target_uuid.uuid);\r\nspin_lock(&imp->imp_lock);\r\nimp->imp_deactive = 1;\r\nspin_unlock(&imp->imp_lock);\r\n}\r\n}\r\nobddev->obd_namespace = ldlm_namespace_new(obddev, obddev->obd_name,\r\nLDLM_NAMESPACE_CLIENT,\r\nLDLM_NAMESPACE_GREEDY,\r\nns_type);\r\nif (!obddev->obd_namespace) {\r\nCERROR("Unable to create client namespace - %s\n",\r\nobddev->obd_name);\r\nrc = -ENOMEM;\r\ngoto err_import;\r\n}\r\nreturn rc;\r\nerr_import:\r\nclass_destroy_import(imp);\r\nerr_ldlm:\r\nldlm_put_ref();\r\nerr:\r\nkfree(cli->cl_mod_tag_bitmap);\r\ncli->cl_mod_tag_bitmap = NULL;\r\nreturn rc;\r\n}\r\nint client_obd_cleanup(struct obd_device *obddev)\r\n{\r\nstruct client_obd *cli = &obddev->u.cli;\r\nldlm_namespace_free_post(obddev->obd_namespace);\r\nobddev->obd_namespace = NULL;\r\nobd_cleanup_client_import(obddev);\r\nLASSERT(!obddev->u.cli.cl_import);\r\nldlm_put_ref();\r\nkfree(cli->cl_mod_tag_bitmap);\r\ncli->cl_mod_tag_bitmap = NULL;\r\nreturn 0;\r\n}\r\nint client_connect_import(const struct lu_env *env,\r\nstruct obd_export **exp,\r\nstruct obd_device *obd, struct obd_uuid *cluuid,\r\nstruct obd_connect_data *data, void *localdata)\r\n{\r\nstruct client_obd *cli = &obd->u.cli;\r\nstruct obd_import *imp = cli->cl_import;\r\nstruct obd_connect_data *ocd;\r\nstruct lustre_handle conn = { 0 };\r\nbool is_mdc = false;\r\nint rc;\r\n*exp = NULL;\r\ndown_write(&cli->cl_sem);\r\nif (cli->cl_conn_count > 0) {\r\nrc = -EALREADY;\r\ngoto out_sem;\r\n}\r\nrc = class_connect(&conn, obd, cluuid);\r\nif (rc)\r\ngoto out_sem;\r\ncli->cl_conn_count++;\r\n*exp = class_conn2export(&conn);\r\nLASSERT(obd->obd_namespace);\r\nimp->imp_dlm_handle = conn;\r\nrc = ptlrpc_init_import(imp);\r\nif (rc != 0)\r\ngoto out_ldlm;\r\nocd = &imp->imp_connect_data;\r\nif (data) {\r\n*ocd = *data;\r\nis_mdc = !strncmp(imp->imp_obd->obd_type->typ_name,\r\nLUSTRE_MDC_NAME, 3);\r\nif (is_mdc)\r\ndata->ocd_connect_flags |= OBD_CONNECT_MULTIMODRPCS;\r\nimp->imp_connect_flags_orig = data->ocd_connect_flags;\r\n}\r\nrc = ptlrpc_connect_import(imp);\r\nif (rc != 0) {\r\nif (data && is_mdc)\r\ndata->ocd_connect_flags &= ~OBD_CONNECT_MULTIMODRPCS;\r\nLASSERT(imp->imp_state == LUSTRE_IMP_DISCON);\r\ngoto out_ldlm;\r\n}\r\nLASSERT(*exp && (*exp)->exp_connection);\r\nif (data) {\r\nLASSERTF((ocd->ocd_connect_flags & data->ocd_connect_flags) ==\r\nocd->ocd_connect_flags, "old %#llx, new %#llx\n",\r\ndata->ocd_connect_flags, ocd->ocd_connect_flags);\r\ndata->ocd_connect_flags = ocd->ocd_connect_flags;\r\nif (is_mdc)\r\ndata->ocd_connect_flags &= ~OBD_CONNECT_MULTIMODRPCS;\r\n}\r\nptlrpc_pinger_add_import(imp);\r\nif (rc) {\r\nout_ldlm:\r\ncli->cl_conn_count--;\r\nclass_disconnect(*exp);\r\n*exp = NULL;\r\n}\r\nout_sem:\r\nup_write(&cli->cl_sem);\r\nreturn rc;\r\n}\r\nint client_disconnect_export(struct obd_export *exp)\r\n{\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nstruct client_obd *cli;\r\nstruct obd_import *imp;\r\nint rc = 0, err;\r\nif (!obd) {\r\nCERROR("invalid export for disconnect: exp %p cookie %#llx\n",\r\nexp, exp ? exp->exp_handle.h_cookie : -1);\r\nreturn -EINVAL;\r\n}\r\ncli = &obd->u.cli;\r\nimp = cli->cl_import;\r\ndown_write(&cli->cl_sem);\r\nCDEBUG(D_INFO, "disconnect %s - %zu\n", obd->obd_name,\r\ncli->cl_conn_count);\r\nif (!cli->cl_conn_count) {\r\nCERROR("disconnecting disconnected device (%s)\n",\r\nobd->obd_name);\r\nrc = -EINVAL;\r\ngoto out_disconnect;\r\n}\r\ncli->cl_conn_count--;\r\nif (cli->cl_conn_count) {\r\nrc = 0;\r\ngoto out_disconnect;\r\n}\r\nspin_lock(&imp->imp_lock);\r\nimp->imp_deactive = 1;\r\nspin_unlock(&imp->imp_lock);\r\n(void)ptlrpc_pinger_del_import(imp);\r\nif (obd->obd_namespace) {\r\nldlm_cli_cancel_unused(obd->obd_namespace, NULL,\r\nobd->obd_force ? LCF_LOCAL : 0, NULL);\r\nldlm_namespace_free_prior(obd->obd_namespace, imp,\r\nobd->obd_force);\r\n}\r\nup_write(&cli->cl_sem);\r\nrc = ptlrpc_disconnect_import(imp, 0);\r\ndown_write(&cli->cl_sem);\r\nptlrpc_invalidate_import(imp);\r\nout_disconnect:\r\nerr = class_disconnect(exp);\r\nif (!rc && err)\r\nrc = err;\r\nup_write(&cli->cl_sem);\r\nreturn rc;\r\n}\r\nint target_pack_pool_reply(struct ptlrpc_request *req)\r\n{\r\nstruct obd_device *obd;\r\nif (unlikely(!req->rq_export || !req->rq_export->exp_obd ||\r\n!exp_connect_lru_resize(req->rq_export))) {\r\nlustre_msg_set_slv(req->rq_repmsg, 0);\r\nlustre_msg_set_limit(req->rq_repmsg, 0);\r\nreturn 0;\r\n}\r\nobd = req->rq_export->exp_obd;\r\nread_lock(&obd->obd_pool_lock);\r\nlustre_msg_set_slv(req->rq_repmsg, obd->obd_pool_slv);\r\nlustre_msg_set_limit(req->rq_repmsg, obd->obd_pool_limit);\r\nread_unlock(&obd->obd_pool_lock);\r\nreturn 0;\r\n}\r\nstatic int\r\ntarget_send_reply_msg(struct ptlrpc_request *req, int rc, int fail_id)\r\n{\r\nif (OBD_FAIL_CHECK_ORSET(fail_id & ~OBD_FAIL_ONCE, OBD_FAIL_ONCE)) {\r\nDEBUG_REQ(D_ERROR, req, "dropping reply");\r\nreturn -ECOMM;\r\n}\r\nif (unlikely(rc)) {\r\nDEBUG_REQ(D_NET, req, "processing error (%d)", rc);\r\nreq->rq_status = rc;\r\nreturn ptlrpc_send_error(req, 1);\r\n}\r\nDEBUG_REQ(D_NET, req, "sending reply");\r\nreturn ptlrpc_send_reply(req, PTLRPC_REPLY_MAYBE_DIFFICULT);\r\n}\r\nvoid target_send_reply(struct ptlrpc_request *req, int rc, int fail_id)\r\n{\r\nstruct ptlrpc_service_part *svcpt;\r\nint netrc;\r\nstruct ptlrpc_reply_state *rs;\r\nstruct obd_export *exp;\r\nif (req->rq_no_reply)\r\nreturn;\r\nsvcpt = req->rq_rqbd->rqbd_svcpt;\r\nrs = req->rq_reply_state;\r\nif (!rs || !rs->rs_difficult) {\r\ntarget_send_reply_msg(req, rc, fail_id);\r\nreturn;\r\n}\r\nLASSERT(req->rq_export);\r\nLASSERT(rs->rs_svcpt == svcpt);\r\nLASSERT(!rs->rs_scheduled);\r\nLASSERT(!rs->rs_scheduled_ever);\r\nLASSERT(!rs->rs_handled);\r\nLASSERT(!rs->rs_on_net);\r\nLASSERT(!rs->rs_export);\r\nLASSERT(list_empty(&rs->rs_obd_list));\r\nLASSERT(list_empty(&rs->rs_exp_list));\r\nexp = class_export_get(req->rq_export);\r\nrs->rs_scheduled = 1;\r\nrs->rs_on_net = 1;\r\nrs->rs_xid = req->rq_xid;\r\nrs->rs_transno = req->rq_transno;\r\nrs->rs_export = exp;\r\nrs->rs_opc = lustre_msg_get_opc(req->rq_reqmsg);\r\nspin_lock(&exp->exp_uncommitted_replies_lock);\r\nCDEBUG(D_NET, "rs transno = %llu, last committed = %llu\n",\r\nrs->rs_transno, exp->exp_last_committed);\r\nif (rs->rs_transno > exp->exp_last_committed) {\r\nlist_add_tail(&rs->rs_obd_list,\r\n&exp->exp_uncommitted_replies);\r\n}\r\nspin_unlock(&exp->exp_uncommitted_replies_lock);\r\nspin_lock(&exp->exp_lock);\r\nlist_add_tail(&rs->rs_exp_list, &exp->exp_outstanding_replies);\r\nspin_unlock(&exp->exp_lock);\r\nnetrc = target_send_reply_msg(req, rc, fail_id);\r\nspin_lock(&svcpt->scp_rep_lock);\r\natomic_inc(&svcpt->scp_nreps_difficult);\r\nif (netrc != 0) {\r\nrs->rs_on_net = 0;\r\nptlrpc_rs_addref(rs);\r\n}\r\nspin_lock(&rs->rs_lock);\r\nif (rs->rs_transno <= exp->exp_last_committed ||\r\n(!rs->rs_on_net && !rs->rs_no_ack) ||\r\nlist_empty(&rs->rs_exp_list) ||\r\nlist_empty(&rs->rs_obd_list)) {\r\nCDEBUG(D_HA, "Schedule reply immediately\n");\r\nptlrpc_dispatch_difficult_reply(rs);\r\n} else {\r\nlist_add(&rs->rs_list, &svcpt->scp_rep_active);\r\nrs->rs_scheduled = 0;\r\n}\r\nspin_unlock(&rs->rs_lock);\r\nspin_unlock(&svcpt->scp_rep_lock);\r\n}\r\nint ldlm_error2errno(enum ldlm_error error)\r\n{\r\nint result;\r\nswitch (error) {\r\ncase ELDLM_OK:\r\ncase ELDLM_LOCK_MATCHED:\r\nresult = 0;\r\nbreak;\r\ncase ELDLM_LOCK_CHANGED:\r\nresult = -ESTALE;\r\nbreak;\r\ncase ELDLM_LOCK_ABORTED:\r\nresult = -ENAVAIL;\r\nbreak;\r\ncase ELDLM_LOCK_REPLACED:\r\nresult = -ESRCH;\r\nbreak;\r\ncase ELDLM_NO_LOCK_DATA:\r\nresult = -ENOENT;\r\nbreak;\r\ncase ELDLM_NAMESPACE_EXISTS:\r\nresult = -EEXIST;\r\nbreak;\r\ncase ELDLM_BAD_NAMESPACE:\r\nresult = -EBADF;\r\nbreak;\r\ndefault:\r\nif (((int)error) < 0)\r\nresult = error;\r\nelse {\r\nCERROR("Invalid DLM result code: %d\n", error);\r\nresult = -EPROTO;\r\n}\r\n}\r\nreturn result;\r\n}\r\nvoid ldlm_dump_export_locks(struct obd_export *exp)\r\n{\r\nspin_lock(&exp->exp_locks_list_guard);\r\nif (!list_empty(&exp->exp_locks_list)) {\r\nstruct ldlm_lock *lock;\r\nCERROR("dumping locks for export %p,ignore if the unmount doesn't hang\n",\r\nexp);\r\nlist_for_each_entry(lock, &exp->exp_locks_list,\r\nl_exp_refs_link)\r\nLDLM_ERROR(lock, "lock:");\r\n}\r\nspin_unlock(&exp->exp_locks_list_guard);\r\n}
