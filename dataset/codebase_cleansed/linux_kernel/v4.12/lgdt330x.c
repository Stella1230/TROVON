static int i2c_write_demod_bytes (struct lgdt330x_state* state,\r\nu8 *buf,\r\nint len )\r\n{\r\nstruct i2c_msg msg =\r\n{ .addr = state->config->demod_address,\r\n.flags = 0,\r\n.buf = buf,\r\n.len = 2 };\r\nint i;\r\nint err;\r\nfor (i=0; i<len-1; i+=2){\r\nif ((err = i2c_transfer(state->i2c, &msg, 1)) != 1) {\r\nprintk(KERN_WARNING "lgdt330x: %s error (addr %02x <- %02x, err = %i)\n", __func__, msg.buf[0], msg.buf[1], err);\r\nif (err < 0)\r\nreturn err;\r\nelse\r\nreturn -EREMOTEIO;\r\n}\r\nmsg.buf += 2;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2c_read_demod_bytes(struct lgdt330x_state *state,\r\nenum I2C_REG reg, u8 *buf, int len)\r\n{\r\nu8 wr [] = { reg };\r\nstruct i2c_msg msg [] = {\r\n{ .addr = state->config->demod_address,\r\n.flags = 0, .buf = wr, .len = 1 },\r\n{ .addr = state->config->demod_address,\r\n.flags = I2C_M_RD, .buf = buf, .len = len },\r\n};\r\nint ret;\r\nret = i2c_transfer(state->i2c, msg, 2);\r\nif (ret != 2) {\r\nprintk(KERN_WARNING "lgdt330x: %s: addr 0x%02x select 0x%02x error (ret == %i)\n", __func__, state->config->demod_address, reg, ret);\r\nif (ret >= 0)\r\nret = -EIO;\r\n} else {\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int lgdt3302_SwReset(struct lgdt330x_state* state)\r\n{\r\nu8 ret;\r\nu8 reset[] = {\r\nIRQ_MASK,\r\n0x00\r\n};\r\nret = i2c_write_demod_bytes(state,\r\nreset, sizeof(reset));\r\nif (ret == 0) {\r\nreset[1] = 0x7f;\r\nret = i2c_write_demod_bytes(state,\r\nreset, sizeof(reset));\r\n}\r\nreturn ret;\r\n}\r\nstatic int lgdt3303_SwReset(struct lgdt330x_state* state)\r\n{\r\nu8 ret;\r\nu8 reset[] = {\r\n0x02,\r\n0x00\r\n};\r\nret = i2c_write_demod_bytes(state,\r\nreset, sizeof(reset));\r\nif (ret == 0) {\r\nreset[1] = 0x01;\r\nret = i2c_write_demod_bytes(state,\r\nreset, sizeof(reset));\r\n}\r\nreturn ret;\r\n}\r\nstatic int lgdt330x_SwReset(struct lgdt330x_state* state)\r\n{\r\nswitch (state->config->demod_chip) {\r\ncase LGDT3302:\r\nreturn lgdt3302_SwReset(state);\r\ncase LGDT3303:\r\nreturn lgdt3303_SwReset(state);\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\n}\r\nstatic int lgdt330x_init(struct dvb_frontend* fe)\r\n{\r\nstatic u8 lgdt3302_init_data[] = {\r\nVSB_CARRIER_FREQ0, 0x00,\r\nVSB_CARRIER_FREQ1, 0x87,\r\nVSB_CARRIER_FREQ2, 0x8e,\r\nVSB_CARRIER_FREQ3, 0x01,\r\nDEMUX_CONTROL, 0xfb,\r\nAGC_RF_BANDWIDTH0, 0x40,\r\nAGC_RF_BANDWIDTH1, 0x93,\r\nAGC_RF_BANDWIDTH2, 0x00,\r\nAGC_FUNC_CTRL2, 0xc6,\r\nAGC_FUNC_CTRL3, 0x40,\r\nAGC_DELAY0, 0x07,\r\nAGC_DELAY2, 0xfe,\r\nAGC_LOOP_BANDWIDTH0, 0x08,\r\nAGC_LOOP_BANDWIDTH1, 0x9a\r\n};\r\nstatic u8 lgdt3303_init_data[] = {\r\n0x4c, 0x14\r\n};\r\nstatic u8 flip_1_lgdt3303_init_data[] = {\r\n0x4c, 0x14,\r\n0x87, 0xf3\r\n};\r\nstatic u8 flip_2_lgdt3303_init_data[] = {\r\n0x4c, 0x14,\r\n0x87, 0xda\r\n};\r\nstruct lgdt330x_state* state = fe->demodulator_priv;\r\nchar *chip_name;\r\nint err;\r\nswitch (state->config->demod_chip) {\r\ncase LGDT3302:\r\nchip_name = "LGDT3302";\r\nerr = i2c_write_demod_bytes(state, lgdt3302_init_data,\r\nsizeof(lgdt3302_init_data));\r\nbreak;\r\ncase LGDT3303:\r\nchip_name = "LGDT3303";\r\nswitch (state->config->clock_polarity_flip) {\r\ncase 2:\r\nerr = i2c_write_demod_bytes(state,\r\nflip_2_lgdt3303_init_data,\r\nsizeof(flip_2_lgdt3303_init_data));\r\nbreak;\r\ncase 1:\r\nerr = i2c_write_demod_bytes(state,\r\nflip_1_lgdt3303_init_data,\r\nsizeof(flip_1_lgdt3303_init_data));\r\nbreak;\r\ncase 0:\r\ndefault:\r\nerr = i2c_write_demod_bytes(state, lgdt3303_init_data,\r\nsizeof(lgdt3303_init_data));\r\n}\r\nbreak;\r\ndefault:\r\nchip_name = "undefined";\r\nprintk (KERN_WARNING "Only LGDT3302 and LGDT3303 are supported chips.\n");\r\nerr = -ENODEV;\r\n}\r\ndprintk("%s entered as %s\n", __func__, chip_name);\r\nif (err < 0)\r\nreturn err;\r\nreturn lgdt330x_SwReset(state);\r\n}\r\nstatic int lgdt330x_read_ber(struct dvb_frontend* fe, u32* ber)\r\n{\r\n*ber = 0;\r\nreturn 0;\r\n}\r\nstatic int lgdt330x_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\r\n{\r\nstruct lgdt330x_state* state = fe->demodulator_priv;\r\nint err;\r\nu8 buf[2];\r\n*ucblocks = 0;\r\nswitch (state->config->demod_chip) {\r\ncase LGDT3302:\r\nerr = i2c_read_demod_bytes(state, LGDT3302_PACKET_ERR_COUNTER1,\r\nbuf, sizeof(buf));\r\nbreak;\r\ncase LGDT3303:\r\nerr = i2c_read_demod_bytes(state, LGDT3303_PACKET_ERR_COUNTER1,\r\nbuf, sizeof(buf));\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING\r\n"Only LGDT3302 and LGDT3303 are supported chips.\n");\r\nerr = -ENODEV;\r\n}\r\nif (err < 0)\r\nreturn err;\r\n*ucblocks = (buf[0] << 8) | buf[1];\r\nreturn 0;\r\n}\r\nstatic int lgdt330x_set_parameters(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstatic u8 lgdt3303_8vsb_44_data[] = {\r\n0x04, 0x00,\r\n0x0d, 0x40,\r\n0x0e, 0x87,\r\n0x0f, 0x8e,\r\n0x10, 0x01,\r\n0x47, 0x8b };\r\nstatic u8 lgdt3303_qam_data[] = {\r\n0x04, 0x00,\r\n0x0d, 0x00,\r\n0x0e, 0x00,\r\n0x0f, 0x00,\r\n0x10, 0x00,\r\n0x51, 0x63,\r\n0x47, 0x66,\r\n0x48, 0x66,\r\n0x4d, 0x1a,\r\n0x49, 0x08,\r\n0x4a, 0x9b };\r\nstruct lgdt330x_state* state = fe->demodulator_priv;\r\nstatic u8 top_ctrl_cfg[] = { TOP_CONTROL, 0x03 };\r\nint err = 0;\r\nif (state->current_modulation != p->modulation) {\r\nswitch (p->modulation) {\r\ncase VSB_8:\r\ndprintk("%s: VSB_8 MODE\n", __func__);\r\ntop_ctrl_cfg[1] = 0x03;\r\nif (state->config->pll_rf_set)\r\nstate->config->pll_rf_set(fe, 1);\r\nif (state->config->demod_chip == LGDT3303) {\r\nerr = i2c_write_demod_bytes(state, lgdt3303_8vsb_44_data,\r\nsizeof(lgdt3303_8vsb_44_data));\r\n}\r\nbreak;\r\ncase QAM_64:\r\ndprintk("%s: QAM_64 MODE\n", __func__);\r\ntop_ctrl_cfg[1] = 0x00;\r\nif (state->config->pll_rf_set)\r\nstate->config->pll_rf_set(fe, 0);\r\nif (state->config->demod_chip == LGDT3303) {\r\nerr = i2c_write_demod_bytes(state, lgdt3303_qam_data,\r\nsizeof(lgdt3303_qam_data));\r\n}\r\nbreak;\r\ncase QAM_256:\r\ndprintk("%s: QAM_256 MODE\n", __func__);\r\ntop_ctrl_cfg[1] = 0x01;\r\nif (state->config->pll_rf_set)\r\nstate->config->pll_rf_set(fe, 0);\r\nif (state->config->demod_chip == LGDT3303) {\r\nerr = i2c_write_demod_bytes(state, lgdt3303_qam_data,\r\nsizeof(lgdt3303_qam_data));\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "lgdt330x: %s: Modulation type(%d) UNSUPPORTED\n", __func__, p->modulation);\r\nreturn -1;\r\n}\r\nif (err < 0)\r\nprintk(KERN_WARNING "lgdt330x: %s: error blasting bytes to lgdt3303 for modulation type(%d)\n",\r\n__func__, p->modulation);\r\ntop_ctrl_cfg[1] |= state->config->serial_mpeg;\r\ni2c_write_demod_bytes(state, top_ctrl_cfg,\r\nsizeof(top_ctrl_cfg));\r\nif (state->config->set_ts_params)\r\nstate->config->set_ts_params(fe, 0);\r\nstate->current_modulation = p->modulation;\r\n}\r\nif (fe->ops.tuner_ops.set_params) {\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\nstate->current_frequency = p->frequency;\r\nlgdt330x_SwReset(state);\r\nreturn 0;\r\n}\r\nstatic int lgdt330x_get_frontend(struct dvb_frontend *fe,\r\nstruct dtv_frontend_properties *p)\r\n{\r\nstruct lgdt330x_state *state = fe->demodulator_priv;\r\np->frequency = state->current_frequency;\r\nreturn 0;\r\n}\r\nstatic int lgdt3302_read_status(struct dvb_frontend *fe,\r\nenum fe_status *status)\r\n{\r\nstruct lgdt330x_state* state = fe->demodulator_priv;\r\nu8 buf[3];\r\n*status = 0;\r\ni2c_read_demod_bytes(state, AGC_STATUS, buf, 1);\r\ndprintk("%s: AGC_STATUS = 0x%02x\n", __func__, buf[0]);\r\nif ((buf[0] & 0x0c) == 0x8){\r\n*status |= FE_HAS_SIGNAL;\r\n}\r\ni2c_read_demod_bytes(state, TOP_CONTROL, buf, sizeof(buf));\r\ndprintk("%s: TOP_CONTROL = 0x%02x, IRO_MASK = 0x%02x, IRQ_STATUS = 0x%02x\n", __func__, buf[0], buf[1], buf[2]);\r\nif ((buf[2] & 0x03) == 0x01) {\r\n*status |= FE_HAS_SYNC;\r\n}\r\nif ((buf[2] & 0x0c) == 0x08) {\r\n*status |= FE_HAS_LOCK;\r\n*status |= FE_HAS_VITERBI;\r\n}\r\ni2c_read_demod_bytes(state, CARRIER_LOCK, buf, 1);\r\ndprintk("%s: CARRIER_LOCK = 0x%02x\n", __func__, buf[0]);\r\nswitch (state->current_modulation) {\r\ncase QAM_256:\r\ncase QAM_64:\r\nif ((buf[0] & 0x07) == 0x07)\r\n*status |= FE_HAS_CARRIER;\r\nbreak;\r\ncase VSB_8:\r\nif ((buf[0] & 0x80) == 0x80)\r\n*status |= FE_HAS_CARRIER;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "lgdt330x: %s: Modulation set to unsupported value\n", __func__);\r\n}\r\nreturn 0;\r\n}\r\nstatic int lgdt3303_read_status(struct dvb_frontend *fe,\r\nenum fe_status *status)\r\n{\r\nstruct lgdt330x_state* state = fe->demodulator_priv;\r\nint err;\r\nu8 buf[3];\r\n*status = 0;\r\nerr = i2c_read_demod_bytes(state, 0x58, buf, 1);\r\nif (err < 0)\r\nreturn err;\r\ndprintk("%s: AGC_STATUS = 0x%02x\n", __func__, buf[0]);\r\nif ((buf[0] & 0x21) == 0x01){\r\n*status |= FE_HAS_SIGNAL;\r\n}\r\ni2c_read_demod_bytes(state, CARRIER_LOCK, buf, 1);\r\ndprintk("%s: CARRIER_LOCK = 0x%02x\n", __func__, buf[0]);\r\nswitch (state->current_modulation) {\r\ncase QAM_256:\r\ncase QAM_64:\r\nif ((buf[0] & 0x07) == 0x07)\r\n*status |= FE_HAS_CARRIER;\r\nelse\r\nbreak;\r\ni2c_read_demod_bytes(state, 0x8a, buf, 1);\r\nif ((buf[0] & 0x04) == 0x04)\r\n*status |= FE_HAS_SYNC;\r\nif ((buf[0] & 0x01) == 0x01)\r\n*status |= FE_HAS_LOCK;\r\nif ((buf[0] & 0x08) == 0x08)\r\n*status |= FE_HAS_VITERBI;\r\nbreak;\r\ncase VSB_8:\r\nif ((buf[0] & 0x80) == 0x80)\r\n*status |= FE_HAS_CARRIER;\r\nelse\r\nbreak;\r\ni2c_read_demod_bytes(state, 0x38, buf, 1);\r\nif ((buf[0] & 0x02) == 0x00)\r\n*status |= FE_HAS_SYNC;\r\nif ((buf[0] & 0x01) == 0x01) {\r\n*status |= FE_HAS_LOCK;\r\n*status |= FE_HAS_VITERBI;\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "lgdt330x: %s: Modulation set to unsupported value\n", __func__);\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 calculate_snr(u32 mse, u32 c)\r\n{\r\nif (mse == 0)\r\nreturn 0;\r\nmse = intlog10(mse);\r\nif (mse > c) {\r\nreturn 0;\r\n}\r\nreturn 10*(c - mse);\r\n}\r\nstatic int lgdt3302_read_snr(struct dvb_frontend* fe, u16* snr)\r\n{\r\nstruct lgdt330x_state* state = (struct lgdt330x_state*) fe->demodulator_priv;\r\nu8 buf[5];\r\nu32 noise;\r\nu32 c;\r\nswitch(state->current_modulation) {\r\ncase VSB_8:\r\ni2c_read_demod_bytes(state, LGDT3302_EQPH_ERR0, buf, 5);\r\n#ifdef USE_EQMSE\r\nnoise = ((buf[0] & 7) << 16) | (buf[1] << 8) | buf[2];\r\nc = 69765745;\r\n#else\r\nnoise = ((buf[0] & 7<<3) << 13) | (buf[3] << 8) | buf[4];\r\nc = 73957994;\r\n#endif\r\nbreak;\r\ncase QAM_64:\r\ncase QAM_256:\r\ni2c_read_demod_bytes(state, CARRIER_MSEQAM1, buf, 2);\r\nnoise = ((buf[0] & 3) << 8) | buf[1];\r\nc = state->current_modulation == QAM_64 ? 97939837 : 98026066;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "lgdt330x: %s: Modulation set to unsupported value\n",\r\n__func__);\r\nreturn -EREMOTEIO;\r\n}\r\nstate->snr = calculate_snr(noise, c);\r\n*snr = (state->snr) >> 16;\r\ndprintk("%s: noise = 0x%08x, snr = %d.%02d dB\n", __func__, noise,\r\nstate->snr >> 24, (((state->snr>>8) & 0xffff) * 100) >> 16);\r\nreturn 0;\r\n}\r\nstatic int lgdt3303_read_snr(struct dvb_frontend* fe, u16* snr)\r\n{\r\nstruct lgdt330x_state* state = (struct lgdt330x_state*) fe->demodulator_priv;\r\nu8 buf[5];\r\nu32 noise;\r\nu32 c;\r\nswitch(state->current_modulation) {\r\ncase VSB_8:\r\ni2c_read_demod_bytes(state, LGDT3303_EQPH_ERR0, buf, 5);\r\n#ifdef USE_EQMSE\r\nnoise = ((buf[0] & 0x78) << 13) | (buf[1] << 8) | buf[2];\r\nc = 73957994;\r\n#else\r\nnoise = ((buf[0] & 7) << 16) | (buf[3] << 8) | buf[4];\r\nc = 73957994;\r\n#endif\r\nbreak;\r\ncase QAM_64:\r\ncase QAM_256:\r\ni2c_read_demod_bytes(state, CARRIER_MSEQAM1, buf, 2);\r\nnoise = (buf[0] << 8) | buf[1];\r\nc = state->current_modulation == QAM_64 ? 97939837 : 98026066;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "lgdt330x: %s: Modulation set to unsupported value\n",\r\n__func__);\r\nreturn -EREMOTEIO;\r\n}\r\nstate->snr = calculate_snr(noise, c);\r\n*snr = (state->snr) >> 16;\r\ndprintk("%s: noise = 0x%08x, snr = %d.%02d dB\n", __func__, noise,\r\nstate->snr >> 24, (((state->snr >> 8) & 0xffff) * 100) >> 16);\r\nreturn 0;\r\n}\r\nstatic int lgdt330x_read_signal_strength(struct dvb_frontend* fe, u16* strength)\r\n{\r\nstruct lgdt330x_state* state = (struct lgdt330x_state*) fe->demodulator_priv;\r\nu16 snr;\r\nint ret;\r\nret = fe->ops.read_snr(fe, &snr);\r\nif (ret != 0)\r\nreturn ret;\r\nif (state->snr >= 8960 * 0x10000)\r\n*strength = 0xffff;\r\nelse\r\n*strength = state->snr / 8960;\r\nreturn 0;\r\n}\r\nstatic int lgdt330x_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* fe_tune_settings)\r\n{\r\nfe_tune_settings->min_delay_ms = 500;\r\nfe_tune_settings->step_size = 0;\r\nfe_tune_settings->max_drift = 0;\r\nreturn 0;\r\n}\r\nstatic void lgdt330x_release(struct dvb_frontend* fe)\r\n{\r\nstruct lgdt330x_state* state = (struct lgdt330x_state*) fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend* lgdt330x_attach(const struct lgdt330x_config* config,\r\nstruct i2c_adapter* i2c)\r\n{\r\nstruct lgdt330x_state* state = NULL;\r\nu8 buf[1];\r\nstate = kzalloc(sizeof(struct lgdt330x_state), GFP_KERNEL);\r\nif (state == NULL)\r\ngoto error;\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nswitch (config->demod_chip) {\r\ncase LGDT3302:\r\nmemcpy(&state->frontend.ops, &lgdt3302_ops, sizeof(struct dvb_frontend_ops));\r\nbreak;\r\ncase LGDT3303:\r\nmemcpy(&state->frontend.ops, &lgdt3303_ops, sizeof(struct dvb_frontend_ops));\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nstate->frontend.demodulator_priv = state;\r\nif (i2c_read_demod_bytes(state, 2, buf, 1))\r\ngoto error;\r\nstate->current_frequency = -1;\r\nstate->current_modulation = -1;\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\ndprintk("%s: ERROR\n",__func__);\r\nreturn NULL;\r\n}
