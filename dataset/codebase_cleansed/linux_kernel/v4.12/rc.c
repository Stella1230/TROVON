__be32 rvt_compute_aeth(struct rvt_qp *qp)\r\n{\r\nu32 aeth = qp->r_msn & IB_MSN_MASK;\r\nif (qp->ibqp.srq) {\r\naeth |= IB_AETH_CREDIT_INVAL << IB_AETH_CREDIT_SHIFT;\r\n} else {\r\nu32 min, max, x;\r\nu32 credits;\r\nstruct rvt_rwq *wq = qp->r_rq.wq;\r\nu32 head;\r\nu32 tail;\r\nhead = wq->head;\r\nif (head >= qp->r_rq.size)\r\nhead = 0;\r\ntail = wq->tail;\r\nif (tail >= qp->r_rq.size)\r\ntail = 0;\r\ncredits = head - tail;\r\nif ((int)credits < 0)\r\ncredits += qp->r_rq.size;\r\nmin = 0;\r\nmax = 31;\r\nfor (;;) {\r\nx = (min + max) / 2;\r\nif (credit_table[x] == credits)\r\nbreak;\r\nif (credit_table[x] > credits) {\r\nmax = x;\r\n} else {\r\nif (min == x)\r\nbreak;\r\nmin = x;\r\n}\r\n}\r\naeth |= x << IB_AETH_CREDIT_SHIFT;\r\n}\r\nreturn cpu_to_be32(aeth);\r\n}\r\nvoid rvt_get_credit(struct rvt_qp *qp, u32 aeth)\r\n{\r\nstruct rvt_dev_info *rdi = ib_to_rvt(qp->ibqp.device);\r\nu32 credit = (aeth >> IB_AETH_CREDIT_SHIFT) & IB_AETH_CREDIT_MASK;\r\nlockdep_assert_held(&qp->s_lock);\r\nif (credit == IB_AETH_CREDIT_INVAL) {\r\nif (!(qp->s_flags & RVT_S_UNLIMITED_CREDIT)) {\r\nqp->s_flags |= RVT_S_UNLIMITED_CREDIT;\r\nif (qp->s_flags & RVT_S_WAIT_SSN_CREDIT) {\r\nqp->s_flags &= ~RVT_S_WAIT_SSN_CREDIT;\r\nrdi->driver_f.schedule_send(qp);\r\n}\r\n}\r\n} else if (!(qp->s_flags & RVT_S_UNLIMITED_CREDIT)) {\r\ncredit = (aeth + credit_table[credit]) & IB_MSN_MASK;\r\nif (rvt_cmp_msn(credit, qp->s_lsn) > 0) {\r\nqp->s_lsn = credit;\r\nif (qp->s_flags & RVT_S_WAIT_SSN_CREDIT) {\r\nqp->s_flags &= ~RVT_S_WAIT_SSN_CREDIT;\r\nrdi->driver_f.schedule_send(qp);\r\n}\r\n}\r\n}\r\n}
