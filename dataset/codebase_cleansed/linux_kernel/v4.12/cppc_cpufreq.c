static void cppc_find_dmi_mhz(const struct dmi_header *dm, void *private)\r\n{\r\nconst u8 *dmi_data = (const u8 *)dm;\r\nu16 *mhz = (u16 *)private;\r\nif (dm->type == DMI_ENTRY_PROCESSOR &&\r\ndm->length >= DMI_ENTRY_PROCESSOR_MIN_LENGTH) {\r\nu16 val = (u16)get_unaligned((const u16 *)\r\n(dmi_data + DMI_PROCESSOR_MAX_SPEED));\r\n*mhz = val > *mhz ? val : *mhz;\r\n}\r\n}\r\nstatic u64 cppc_get_dmi_max_khz(void)\r\n{\r\nu16 mhz = 0;\r\ndmi_walk(cppc_find_dmi_mhz, &mhz);\r\nmhz = mhz ? mhz : 1;\r\nreturn (1000 * mhz);\r\n}\r\nstatic int cppc_cpufreq_set_target(struct cpufreq_policy *policy,\r\nunsigned int target_freq,\r\nunsigned int relation)\r\n{\r\nstruct cppc_cpudata *cpu;\r\nstruct cpufreq_freqs freqs;\r\nu32 desired_perf;\r\nint ret = 0;\r\ncpu = all_cpu_data[policy->cpu];\r\ndesired_perf = (u64)target_freq * cpu->perf_caps.highest_perf / cppc_dmi_max_khz;\r\nif (desired_perf == cpu->perf_ctrls.desired_perf)\r\nreturn ret;\r\ncpu->perf_ctrls.desired_perf = desired_perf;\r\nfreqs.old = policy->cur;\r\nfreqs.new = target_freq;\r\ncpufreq_freq_transition_begin(policy, &freqs);\r\nret = cppc_set_perf(cpu->cpu, &cpu->perf_ctrls);\r\ncpufreq_freq_transition_end(policy, &freqs, ret != 0);\r\nif (ret)\r\npr_debug("Failed to set target on CPU:%d. ret:%d\n",\r\ncpu->cpu, ret);\r\nreturn ret;\r\n}\r\nstatic int cppc_verify_policy(struct cpufreq_policy *policy)\r\n{\r\ncpufreq_verify_within_cpu_limits(policy);\r\nreturn 0;\r\n}\r\nstatic void cppc_cpufreq_stop_cpu(struct cpufreq_policy *policy)\r\n{\r\nint cpu_num = policy->cpu;\r\nstruct cppc_cpudata *cpu = all_cpu_data[cpu_num];\r\nint ret;\r\ncpu->perf_ctrls.desired_perf = cpu->perf_caps.lowest_perf;\r\nret = cppc_set_perf(cpu_num, &cpu->perf_ctrls);\r\nif (ret)\r\npr_debug("Err setting perf value:%d on CPU:%d. ret:%d\n",\r\ncpu->perf_caps.lowest_perf, cpu_num, ret);\r\n}\r\nstatic int cppc_cpufreq_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nstruct cppc_cpudata *cpu;\r\nunsigned int cpu_num = policy->cpu;\r\nint ret = 0;\r\ncpu = all_cpu_data[policy->cpu];\r\ncpu->cpu = cpu_num;\r\nret = cppc_get_perf_caps(policy->cpu, &cpu->perf_caps);\r\nif (ret) {\r\npr_debug("Err reading CPU%d perf capabilities. ret:%d\n",\r\ncpu_num, ret);\r\nreturn ret;\r\n}\r\ncppc_dmi_max_khz = cppc_get_dmi_max_khz();\r\npolicy->min = cpu->perf_caps.lowest_perf * cppc_dmi_max_khz / cpu->perf_caps.highest_perf;\r\npolicy->max = cppc_dmi_max_khz;\r\npolicy->cpuinfo.min_freq = policy->min;\r\npolicy->cpuinfo.max_freq = policy->max;\r\npolicy->cpuinfo.transition_latency = cppc_get_transition_latency(cpu_num);\r\npolicy->shared_type = cpu->shared_type;\r\nif (policy->shared_type == CPUFREQ_SHARED_TYPE_ANY)\r\ncpumask_copy(policy->cpus, cpu->shared_cpu_map);\r\nelse if (policy->shared_type == CPUFREQ_SHARED_TYPE_ALL) {\r\npr_debug("Unsupported CPU co-ord type\n");\r\nreturn -EFAULT;\r\n}\r\ncpumask_set_cpu(policy->cpu, policy->cpus);\r\ncpu->cur_policy = policy;\r\npolicy->cur = cppc_dmi_max_khz;\r\ncpu->perf_ctrls.desired_perf = cpu->perf_caps.highest_perf;\r\nret = cppc_set_perf(cpu_num, &cpu->perf_ctrls);\r\nif (ret)\r\npr_debug("Err setting perf value:%d on CPU:%d. ret:%d\n",\r\ncpu->perf_caps.highest_perf, cpu_num, ret);\r\nreturn ret;\r\n}\r\nstatic int __init cppc_cpufreq_init(void)\r\n{\r\nint i, ret = 0;\r\nstruct cppc_cpudata *cpu;\r\nif (acpi_disabled)\r\nreturn -ENODEV;\r\nall_cpu_data = kzalloc(sizeof(void *) * num_possible_cpus(), GFP_KERNEL);\r\nif (!all_cpu_data)\r\nreturn -ENOMEM;\r\nfor_each_possible_cpu(i) {\r\nall_cpu_data[i] = kzalloc(sizeof(struct cppc_cpudata), GFP_KERNEL);\r\nif (!all_cpu_data[i])\r\ngoto out;\r\ncpu = all_cpu_data[i];\r\nif (!zalloc_cpumask_var(&cpu->shared_cpu_map, GFP_KERNEL))\r\ngoto out;\r\n}\r\nret = acpi_get_psd_map(all_cpu_data);\r\nif (ret) {\r\npr_debug("Error parsing PSD data. Aborting cpufreq registration.\n");\r\ngoto out;\r\n}\r\nret = cpufreq_register_driver(&cppc_cpufreq_driver);\r\nif (ret)\r\ngoto out;\r\nreturn ret;\r\nout:\r\nfor_each_possible_cpu(i)\r\nkfree(all_cpu_data[i]);\r\nkfree(all_cpu_data);\r\nreturn -ENODEV;\r\n}\r\nstatic void __exit cppc_cpufreq_exit(void)\r\n{\r\nstruct cppc_cpudata *cpu;\r\nint i;\r\ncpufreq_unregister_driver(&cppc_cpufreq_driver);\r\nfor_each_possible_cpu(i) {\r\ncpu = all_cpu_data[i];\r\nfree_cpumask_var(cpu->shared_cpu_map);\r\nkfree(cpu);\r\n}\r\nkfree(all_cpu_data);\r\n}
