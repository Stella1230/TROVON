static void dvb_filter_pes2ts_init(struct dvb_filter_pes2ts *p2ts,\r\nunsigned short pid,\r\ndvb_filter_pes2ts_cb_t *cb, void *priv)\r\n{\r\nunsigned char *buf=p2ts->buf;\r\nbuf[0]=0x47;\r\nbuf[1]=(pid>>8);\r\nbuf[2]=pid&0xff;\r\np2ts->cc=0;\r\np2ts->cb=cb;\r\np2ts->priv=priv;\r\n}\r\nstatic int dvb_filter_pes2ts(struct dvb_filter_pes2ts *p2ts,\r\nunsigned char *pes, int len, int payload_start)\r\n{\r\nunsigned char *buf=p2ts->buf;\r\nint ret=0, rest;\r\nif (payload_start)\r\nbuf[1]|=0x40;\r\nelse\r\nbuf[1]&=~0x40;\r\nwhile (len>=184) {\r\nbuf[3]=0x10|((p2ts->cc++)&0x0f);\r\nmemcpy(buf+4, pes, 184);\r\nif ((ret=p2ts->cb(p2ts->priv, buf)))\r\nreturn ret;\r\nlen-=184; pes+=184;\r\nbuf[1]&=~0x40;\r\n}\r\nif (!len)\r\nreturn 0;\r\nbuf[3]=0x30|((p2ts->cc++)&0x0f);\r\nrest=183-len;\r\nif (rest) {\r\nbuf[5]=0x00;\r\nif (rest-1)\r\nmemset(buf+6, 0xff, rest-1);\r\n}\r\nbuf[4]=rest;\r\nmemcpy(buf+5+rest, pes, len);\r\nreturn p2ts->cb(p2ts->priv, buf);\r\n}\r\nstatic void ttusb_dec_handle_irq( struct urb *urb)\r\n{\r\nstruct ttusb_dec *dec = urb->context;\r\nchar *buffer = dec->irq_buffer;\r\nint retval;\r\nswitch(urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ncase -ETIME:\r\ndprintk("%s:urb shutting down with status: %d\n",\r\n__func__, urb->status);\r\nreturn;\r\ndefault:\r\ndprintk("%s:nonzero status received: %d\n",\r\n__func__,urb->status);\r\ngoto exit;\r\n}\r\nif ((buffer[0] == 0x1) && (buffer[2] == 0x15)) {\r\nif (buffer[4] - 1 < ARRAY_SIZE(rc_keys)) {\r\ndprintk("%s:rc signal:%d\n", __func__, buffer[4]);\r\ninput_report_key(dec->rc_input_dev, rc_keys[buffer[4] - 1], 1);\r\ninput_sync(dec->rc_input_dev);\r\ninput_report_key(dec->rc_input_dev, rc_keys[buffer[4] - 1], 0);\r\ninput_sync(dec->rc_input_dev);\r\n}\r\n}\r\nexit:\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval)\r\nprintk("%s - usb_commit_urb failed with result: %d\n",\r\n__func__, retval);\r\n}\r\nstatic u16 crc16(u16 crc, const u8 *buf, size_t len)\r\n{\r\nu16 tmp;\r\nwhile (len--) {\r\ncrc ^= *buf++;\r\ncrc ^= (u8)crc >> 4;\r\ntmp = (u8)crc;\r\ncrc ^= (tmp ^ (tmp << 1)) << 4;\r\n}\r\nreturn crc;\r\n}\r\nstatic int ttusb_dec_send_command(struct ttusb_dec *dec, const u8 command,\r\nint param_length, const u8 params[],\r\nint *result_length, u8 cmd_result[])\r\n{\r\nint result, actual_len;\r\nu8 *b;\r\ndprintk("%s\n", __func__);\r\nb = kmalloc(COMMAND_PACKET_SIZE + 4, GFP_KERNEL);\r\nif (!b)\r\nreturn -ENOMEM;\r\nif ((result = mutex_lock_interruptible(&dec->usb_mutex))) {\r\nkfree(b);\r\nprintk("%s: Failed to lock usb mutex.\n", __func__);\r\nreturn result;\r\n}\r\nb[0] = 0xaa;\r\nb[1] = ++dec->trans_count;\r\nb[2] = command;\r\nb[3] = param_length;\r\nif (params)\r\nmemcpy(&b[4], params, param_length);\r\nif (debug) {\r\nprintk(KERN_DEBUG "%s: command: %*ph\n",\r\n__func__, param_length, b);\r\n}\r\nresult = usb_bulk_msg(dec->udev, dec->command_pipe, b,\r\nCOMMAND_PACKET_SIZE + 4, &actual_len, 1000);\r\nif (result) {\r\nprintk("%s: command bulk message failed: error %d\n",\r\n__func__, result);\r\nmutex_unlock(&dec->usb_mutex);\r\nkfree(b);\r\nreturn result;\r\n}\r\nresult = usb_bulk_msg(dec->udev, dec->result_pipe, b,\r\nCOMMAND_PACKET_SIZE + 4, &actual_len, 1000);\r\nif (result) {\r\nprintk("%s: result bulk message failed: error %d\n",\r\n__func__, result);\r\nmutex_unlock(&dec->usb_mutex);\r\nkfree(b);\r\nreturn result;\r\n} else {\r\nif (debug) {\r\nprintk(KERN_DEBUG "%s: result: %*ph\n",\r\n__func__, actual_len, b);\r\n}\r\nif (result_length)\r\n*result_length = b[3];\r\nif (cmd_result && b[3] > 0)\r\nmemcpy(cmd_result, &b[4], b[3]);\r\nmutex_unlock(&dec->usb_mutex);\r\nkfree(b);\r\nreturn 0;\r\n}\r\n}\r\nstatic int ttusb_dec_get_stb_state (struct ttusb_dec *dec, unsigned int *mode,\r\nunsigned int *model, unsigned int *version)\r\n{\r\nu8 c[COMMAND_PACKET_SIZE];\r\nint c_length;\r\nint result;\r\n__be32 tmp;\r\ndprintk("%s\n", __func__);\r\nresult = ttusb_dec_send_command(dec, 0x08, 0, NULL, &c_length, c);\r\nif (result)\r\nreturn result;\r\nif (c_length >= 0x0c) {\r\nif (mode != NULL) {\r\nmemcpy(&tmp, c, 4);\r\n*mode = ntohl(tmp);\r\n}\r\nif (model != NULL) {\r\nmemcpy(&tmp, &c[4], 4);\r\n*model = ntohl(tmp);\r\n}\r\nif (version != NULL) {\r\nmemcpy(&tmp, &c[8], 4);\r\n*version = ntohl(tmp);\r\n}\r\nreturn 0;\r\n} else {\r\nreturn -ENOENT;\r\n}\r\n}\r\nstatic int ttusb_dec_audio_pes2ts_cb(void *priv, unsigned char *data)\r\n{\r\nstruct ttusb_dec *dec = priv;\r\ndec->audio_filter->feed->cb.ts(data, 188, NULL, 0,\r\n&dec->audio_filter->feed->feed.ts);\r\nreturn 0;\r\n}\r\nstatic int ttusb_dec_video_pes2ts_cb(void *priv, unsigned char *data)\r\n{\r\nstruct ttusb_dec *dec = priv;\r\ndec->video_filter->feed->cb.ts(data, 188, NULL, 0,\r\n&dec->video_filter->feed->feed.ts);\r\nreturn 0;\r\n}\r\nstatic void ttusb_dec_set_pids(struct ttusb_dec *dec)\r\n{\r\nu8 b[] = { 0x00, 0x00, 0x00, 0x00,\r\n0x00, 0x00, 0xff, 0xff,\r\n0xff, 0xff, 0xff, 0xff };\r\n__be16 pcr = htons(dec->pid[DMX_PES_PCR]);\r\n__be16 audio = htons(dec->pid[DMX_PES_AUDIO]);\r\n__be16 video = htons(dec->pid[DMX_PES_VIDEO]);\r\ndprintk("%s\n", __func__);\r\nmemcpy(&b[0], &pcr, 2);\r\nmemcpy(&b[2], &audio, 2);\r\nmemcpy(&b[4], &video, 2);\r\nttusb_dec_send_command(dec, 0x50, sizeof(b), b, NULL, NULL);\r\ndvb_filter_pes2ts_init(&dec->a_pes2ts, dec->pid[DMX_PES_AUDIO],\r\nttusb_dec_audio_pes2ts_cb, dec);\r\ndvb_filter_pes2ts_init(&dec->v_pes2ts, dec->pid[DMX_PES_VIDEO],\r\nttusb_dec_video_pes2ts_cb, dec);\r\ndec->v_pes_length = 0;\r\ndec->v_pes_postbytes = 0;\r\n}\r\nstatic void ttusb_dec_process_pva(struct ttusb_dec *dec, u8 *pva, int length)\r\n{\r\nif (length < 8) {\r\nprintk("%s: packet too short - discarding\n", __func__);\r\nreturn;\r\n}\r\nif (length > 8 + MAX_PVA_LENGTH) {\r\nprintk("%s: packet too long - discarding\n", __func__);\r\nreturn;\r\n}\r\nswitch (pva[2]) {\r\ncase 0x01: {\r\nint prebytes = pva[5] & 0x03;\r\nint postbytes = (pva[5] & 0x0c) >> 2;\r\n__be16 v_pes_payload_length;\r\nif (output_pva) {\r\ndec->video_filter->feed->cb.ts(pva, length, NULL, 0,\r\n&dec->video_filter->feed->feed.ts);\r\nreturn;\r\n}\r\nif (dec->v_pes_postbytes > 0 &&\r\ndec->v_pes_postbytes == prebytes) {\r\nmemcpy(&dec->v_pes[dec->v_pes_length],\r\n&pva[12], prebytes);\r\ndvb_filter_pes2ts(&dec->v_pes2ts, dec->v_pes,\r\ndec->v_pes_length + prebytes, 1);\r\n}\r\nif (pva[5] & 0x10) {\r\ndec->v_pes[7] = 0x80;\r\ndec->v_pes[8] = 0x05;\r\ndec->v_pes[9] = 0x21 | ((pva[8] & 0xc0) >> 5);\r\ndec->v_pes[10] = ((pva[8] & 0x3f) << 2) |\r\n((pva[9] & 0xc0) >> 6);\r\ndec->v_pes[11] = 0x01 |\r\n((pva[9] & 0x3f) << 2) |\r\n((pva[10] & 0x80) >> 6);\r\ndec->v_pes[12] = ((pva[10] & 0x7f) << 1) |\r\n((pva[11] & 0xc0) >> 7);\r\ndec->v_pes[13] = 0x01 | ((pva[11] & 0x7f) << 1);\r\nmemcpy(&dec->v_pes[14], &pva[12 + prebytes],\r\nlength - 12 - prebytes);\r\ndec->v_pes_length = 14 + length - 12 - prebytes;\r\n} else {\r\ndec->v_pes[7] = 0x00;\r\ndec->v_pes[8] = 0x00;\r\nmemcpy(&dec->v_pes[9], &pva[8], length - 8);\r\ndec->v_pes_length = 9 + length - 8;\r\n}\r\ndec->v_pes_postbytes = postbytes;\r\nif (dec->v_pes[9 + dec->v_pes[8]] == 0x00 &&\r\ndec->v_pes[10 + dec->v_pes[8]] == 0x00 &&\r\ndec->v_pes[11 + dec->v_pes[8]] == 0x01)\r\ndec->v_pes[6] = 0x84;\r\nelse\r\ndec->v_pes[6] = 0x80;\r\nv_pes_payload_length = htons(dec->v_pes_length - 6 +\r\npostbytes);\r\nmemcpy(&dec->v_pes[4], &v_pes_payload_length, 2);\r\nif (postbytes == 0)\r\ndvb_filter_pes2ts(&dec->v_pes2ts, dec->v_pes,\r\ndec->v_pes_length, 1);\r\nbreak;\r\n}\r\ncase 0x02:\r\nif (output_pva) {\r\ndec->audio_filter->feed->cb.ts(pva, length, NULL, 0,\r\n&dec->audio_filter->feed->feed.ts);\r\nreturn;\r\n}\r\ndvb_filter_pes2ts(&dec->a_pes2ts, &pva[8], length - 8,\r\npva[5] & 0x10);\r\nbreak;\r\ndefault:\r\nprintk("%s: unknown PVA type: %02x.\n", __func__,\r\npva[2]);\r\nbreak;\r\n}\r\n}\r\nstatic void ttusb_dec_process_filter(struct ttusb_dec *dec, u8 *packet,\r\nint length)\r\n{\r\nstruct list_head *item;\r\nstruct filter_info *finfo;\r\nstruct dvb_demux_filter *filter = NULL;\r\nunsigned long flags;\r\nu8 sid;\r\nsid = packet[1];\r\nspin_lock_irqsave(&dec->filter_info_list_lock, flags);\r\nfor (item = dec->filter_info_list.next; item != &dec->filter_info_list;\r\nitem = item->next) {\r\nfinfo = list_entry(item, struct filter_info, filter_info_list);\r\nif (finfo->stream_id == sid) {\r\nfilter = finfo->filter;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&dec->filter_info_list_lock, flags);\r\nif (filter)\r\nfilter->feed->cb.sec(&packet[2], length - 2, NULL, 0,\r\n&filter->filter);\r\n}\r\nstatic void ttusb_dec_process_packet(struct ttusb_dec *dec)\r\n{\r\nint i;\r\nu16 csum = 0;\r\nu16 packet_id;\r\nif (dec->packet_length % 2) {\r\nprintk("%s: odd sized packet - discarding\n", __func__);\r\nreturn;\r\n}\r\nfor (i = 0; i < dec->packet_length; i += 2)\r\ncsum ^= ((dec->packet[i] << 8) + dec->packet[i + 1]);\r\nif (csum) {\r\nprintk("%s: checksum failed - discarding\n", __func__);\r\nreturn;\r\n}\r\npacket_id = dec->packet[dec->packet_length - 4] << 8;\r\npacket_id += dec->packet[dec->packet_length - 3];\r\nif ((packet_id != dec->next_packet_id) && dec->next_packet_id) {\r\nprintk("%s: warning: lost packets between %u and %u\n",\r\n__func__, dec->next_packet_id - 1, packet_id);\r\n}\r\nif (packet_id == 0xffff)\r\ndec->next_packet_id = 0x8000;\r\nelse\r\ndec->next_packet_id = packet_id + 1;\r\nswitch (dec->packet_type) {\r\ncase TTUSB_DEC_PACKET_PVA:\r\nif (dec->pva_stream_count)\r\nttusb_dec_process_pva(dec, dec->packet,\r\ndec->packet_payload_length);\r\nbreak;\r\ncase TTUSB_DEC_PACKET_SECTION:\r\nif (dec->filter_stream_count)\r\nttusb_dec_process_filter(dec, dec->packet,\r\ndec->packet_payload_length);\r\nbreak;\r\ncase TTUSB_DEC_PACKET_EMPTY:\r\nbreak;\r\n}\r\n}\r\nstatic void swap_bytes(u8 *b, int length)\r\n{\r\nlength -= length % 2;\r\nfor (; length; b += 2, length -= 2)\r\nswap(*b, *(b + 1));\r\n}\r\nstatic void ttusb_dec_process_urb_frame(struct ttusb_dec *dec, u8 *b,\r\nint length)\r\n{\r\nswap_bytes(b, length);\r\nwhile (length) {\r\nswitch (dec->packet_state) {\r\ncase 0:\r\ncase 1:\r\ncase 2:\r\nif (*b++ == 0xaa)\r\ndec->packet_state++;\r\nelse\r\ndec->packet_state = 0;\r\nlength--;\r\nbreak;\r\ncase 3:\r\nif (*b == 0x00) {\r\ndec->packet_state++;\r\ndec->packet_length = 0;\r\n} else if (*b != 0xaa) {\r\ndec->packet_state = 0;\r\n}\r\nb++;\r\nlength--;\r\nbreak;\r\ncase 4:\r\ndec->packet[dec->packet_length++] = *b++;\r\nif (dec->packet_length == 2) {\r\nif (dec->packet[0] == 'A' &&\r\ndec->packet[1] == 'V') {\r\ndec->packet_type =\r\nTTUSB_DEC_PACKET_PVA;\r\ndec->packet_state++;\r\n} else if (dec->packet[0] == 'S') {\r\ndec->packet_type =\r\nTTUSB_DEC_PACKET_SECTION;\r\ndec->packet_state++;\r\n} else if (dec->packet[0] == 0x00) {\r\ndec->packet_type =\r\nTTUSB_DEC_PACKET_EMPTY;\r\ndec->packet_payload_length = 2;\r\ndec->packet_state = 7;\r\n} else {\r\nprintk("%s: unknown packet type: %02x%02x\n",\r\n__func__,\r\ndec->packet[0], dec->packet[1]);\r\ndec->packet_state = 0;\r\n}\r\n}\r\nlength--;\r\nbreak;\r\ncase 5:\r\ndec->packet[dec->packet_length++] = *b++;\r\nif (dec->packet_type == TTUSB_DEC_PACKET_PVA &&\r\ndec->packet_length == 8) {\r\ndec->packet_state++;\r\ndec->packet_payload_length = 8 +\r\n(dec->packet[6] << 8) +\r\ndec->packet[7];\r\n} else if (dec->packet_type ==\r\nTTUSB_DEC_PACKET_SECTION &&\r\ndec->packet_length == 5) {\r\ndec->packet_state++;\r\ndec->packet_payload_length = 5 +\r\n((dec->packet[3] & 0x0f) << 8) +\r\ndec->packet[4];\r\n}\r\nlength--;\r\nbreak;\r\ncase 6: {\r\nint remainder = dec->packet_payload_length -\r\ndec->packet_length;\r\nif (length >= remainder) {\r\nmemcpy(dec->packet + dec->packet_length,\r\nb, remainder);\r\ndec->packet_length += remainder;\r\nb += remainder;\r\nlength -= remainder;\r\ndec->packet_state++;\r\n} else {\r\nmemcpy(&dec->packet[dec->packet_length],\r\nb, length);\r\ndec->packet_length += length;\r\nlength = 0;\r\n}\r\nbreak;\r\n}\r\ncase 7: {\r\nint tail = 4;\r\ndec->packet[dec->packet_length++] = *b++;\r\nif (dec->packet_type == TTUSB_DEC_PACKET_SECTION &&\r\ndec->packet_payload_length % 2)\r\ntail++;\r\nif (dec->packet_length ==\r\ndec->packet_payload_length + tail) {\r\nttusb_dec_process_packet(dec);\r\ndec->packet_state = 0;\r\n}\r\nlength--;\r\nbreak;\r\n}\r\ndefault:\r\nprintk("%s: illegal packet state encountered.\n",\r\n__func__);\r\ndec->packet_state = 0;\r\n}\r\n}\r\n}\r\nstatic void ttusb_dec_process_urb_frame_list(unsigned long data)\r\n{\r\nstruct ttusb_dec *dec = (struct ttusb_dec *)data;\r\nstruct list_head *item;\r\nstruct urb_frame *frame;\r\nunsigned long flags;\r\nwhile (1) {\r\nspin_lock_irqsave(&dec->urb_frame_list_lock, flags);\r\nif ((item = dec->urb_frame_list.next) != &dec->urb_frame_list) {\r\nframe = list_entry(item, struct urb_frame,\r\nurb_frame_list);\r\nlist_del(&frame->urb_frame_list);\r\n} else {\r\nspin_unlock_irqrestore(&dec->urb_frame_list_lock,\r\nflags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&dec->urb_frame_list_lock, flags);\r\nttusb_dec_process_urb_frame(dec, frame->data, frame->length);\r\nkfree(frame);\r\n}\r\n}\r\nstatic void ttusb_dec_process_urb(struct urb *urb)\r\n{\r\nstruct ttusb_dec *dec = urb->context;\r\nif (!urb->status) {\r\nint i;\r\nfor (i = 0; i < FRAMES_PER_ISO_BUF; i++) {\r\nstruct usb_iso_packet_descriptor *d;\r\nu8 *b;\r\nint length;\r\nstruct urb_frame *frame;\r\nd = &urb->iso_frame_desc[i];\r\nb = urb->transfer_buffer + d->offset;\r\nlength = d->actual_length;\r\nif ((frame = kmalloc(sizeof(struct urb_frame),\r\nGFP_ATOMIC))) {\r\nunsigned long flags;\r\nmemcpy(frame->data, b, length);\r\nframe->length = length;\r\nspin_lock_irqsave(&dec->urb_frame_list_lock,\r\nflags);\r\nlist_add_tail(&frame->urb_frame_list,\r\n&dec->urb_frame_list);\r\nspin_unlock_irqrestore(&dec->urb_frame_list_lock,\r\nflags);\r\ntasklet_schedule(&dec->urb_tasklet);\r\n}\r\n}\r\n} else {\r\nif (urb->status != -ENOENT)\r\ndprintk("%s: urb error: %d\n", __func__,\r\nurb->status);\r\n}\r\nif (dec->iso_stream_count)\r\nusb_submit_urb(urb, GFP_ATOMIC);\r\n}\r\nstatic void ttusb_dec_setup_urbs(struct ttusb_dec *dec)\r\n{\r\nint i, j, buffer_offset = 0;\r\ndprintk("%s\n", __func__);\r\nfor (i = 0; i < ISO_BUF_COUNT; i++) {\r\nint frame_offset = 0;\r\nstruct urb *urb = dec->iso_urb[i];\r\nurb->dev = dec->udev;\r\nurb->context = dec;\r\nurb->complete = ttusb_dec_process_urb;\r\nurb->pipe = dec->in_pipe;\r\nurb->transfer_flags = URB_ISO_ASAP;\r\nurb->interval = 1;\r\nurb->number_of_packets = FRAMES_PER_ISO_BUF;\r\nurb->transfer_buffer_length = ISO_FRAME_SIZE *\r\nFRAMES_PER_ISO_BUF;\r\nurb->transfer_buffer = dec->iso_buffer + buffer_offset;\r\nbuffer_offset += ISO_FRAME_SIZE * FRAMES_PER_ISO_BUF;\r\nfor (j = 0; j < FRAMES_PER_ISO_BUF; j++) {\r\nurb->iso_frame_desc[j].offset = frame_offset;\r\nurb->iso_frame_desc[j].length = ISO_FRAME_SIZE;\r\nframe_offset += ISO_FRAME_SIZE;\r\n}\r\n}\r\n}\r\nstatic void ttusb_dec_stop_iso_xfer(struct ttusb_dec *dec)\r\n{\r\nint i;\r\ndprintk("%s\n", __func__);\r\nif (mutex_lock_interruptible(&dec->iso_mutex))\r\nreturn;\r\ndec->iso_stream_count--;\r\nif (!dec->iso_stream_count) {\r\nfor (i = 0; i < ISO_BUF_COUNT; i++)\r\nusb_kill_urb(dec->iso_urb[i]);\r\n}\r\nmutex_unlock(&dec->iso_mutex);\r\n}\r\nstatic int ttusb_dec_set_interface(struct ttusb_dec *dec,\r\nenum ttusb_dec_interface interface)\r\n{\r\nint result = 0;\r\nu8 b[] = { 0x05 };\r\nif (interface != dec->interface) {\r\nswitch (interface) {\r\ncase TTUSB_DEC_INTERFACE_INITIAL:\r\nresult = usb_set_interface(dec->udev, 0, 0);\r\nbreak;\r\ncase TTUSB_DEC_INTERFACE_IN:\r\nresult = ttusb_dec_send_command(dec, 0x80, sizeof(b),\r\nb, NULL, NULL);\r\nif (result)\r\nreturn result;\r\nresult = usb_set_interface(dec->udev, 0, 8);\r\nbreak;\r\ncase TTUSB_DEC_INTERFACE_OUT:\r\nresult = usb_set_interface(dec->udev, 0, 1);\r\nbreak;\r\n}\r\nif (result)\r\nreturn result;\r\ndec->interface = interface;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ttusb_dec_start_iso_xfer(struct ttusb_dec *dec)\r\n{\r\nint i, result;\r\ndprintk("%s\n", __func__);\r\nif (mutex_lock_interruptible(&dec->iso_mutex))\r\nreturn -EAGAIN;\r\nif (!dec->iso_stream_count) {\r\nttusb_dec_setup_urbs(dec);\r\ndec->packet_state = 0;\r\ndec->v_pes_postbytes = 0;\r\ndec->next_packet_id = 0;\r\nfor (i = 0; i < ISO_BUF_COUNT; i++) {\r\nif ((result = usb_submit_urb(dec->iso_urb[i],\r\nGFP_ATOMIC))) {\r\nprintk("%s: failed urb submission %d: error %d\n",\r\n__func__, i, result);\r\nwhile (i) {\r\nusb_kill_urb(dec->iso_urb[i - 1]);\r\ni--;\r\n}\r\nmutex_unlock(&dec->iso_mutex);\r\nreturn result;\r\n}\r\n}\r\n}\r\ndec->iso_stream_count++;\r\nmutex_unlock(&dec->iso_mutex);\r\nreturn 0;\r\n}\r\nstatic int ttusb_dec_start_ts_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\nstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\r\nstruct ttusb_dec *dec = dvbdmx->priv;\r\nu8 b0[] = { 0x05 };\r\nint result = 0;\r\ndprintk("%s\n", __func__);\r\ndprintk(" ts_type:");\r\nif (dvbdmxfeed->ts_type & TS_DECODER)\r\ndprintk(" TS_DECODER");\r\nif (dvbdmxfeed->ts_type & TS_PACKET)\r\ndprintk(" TS_PACKET");\r\nif (dvbdmxfeed->ts_type & TS_PAYLOAD_ONLY)\r\ndprintk(" TS_PAYLOAD_ONLY");\r\ndprintk("\n");\r\nswitch (dvbdmxfeed->pes_type) {\r\ncase DMX_PES_VIDEO:\r\ndprintk(" pes_type: DMX_PES_VIDEO\n");\r\ndec->pid[DMX_PES_PCR] = dvbdmxfeed->pid;\r\ndec->pid[DMX_PES_VIDEO] = dvbdmxfeed->pid;\r\ndec->video_filter = dvbdmxfeed->filter;\r\nttusb_dec_set_pids(dec);\r\nbreak;\r\ncase DMX_PES_AUDIO:\r\ndprintk(" pes_type: DMX_PES_AUDIO\n");\r\ndec->pid[DMX_PES_AUDIO] = dvbdmxfeed->pid;\r\ndec->audio_filter = dvbdmxfeed->filter;\r\nttusb_dec_set_pids(dec);\r\nbreak;\r\ncase DMX_PES_TELETEXT:\r\ndec->pid[DMX_PES_TELETEXT] = dvbdmxfeed->pid;\r\ndprintk(" pes_type: DMX_PES_TELETEXT(not supported)\n");\r\nreturn -ENOSYS;\r\ncase DMX_PES_PCR:\r\ndprintk(" pes_type: DMX_PES_PCR\n");\r\ndec->pid[DMX_PES_PCR] = dvbdmxfeed->pid;\r\nttusb_dec_set_pids(dec);\r\nbreak;\r\ncase DMX_PES_OTHER:\r\ndprintk(" pes_type: DMX_PES_OTHER(not supported)\n");\r\nreturn -ENOSYS;\r\ndefault:\r\ndprintk(" pes_type: unknown (%d)\n", dvbdmxfeed->pes_type);\r\nreturn -EINVAL;\r\n}\r\nresult = ttusb_dec_send_command(dec, 0x80, sizeof(b0), b0, NULL, NULL);\r\nif (result)\r\nreturn result;\r\ndec->pva_stream_count++;\r\nreturn ttusb_dec_start_iso_xfer(dec);\r\n}\r\nstatic int ttusb_dec_start_sec_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\nstruct ttusb_dec *dec = dvbdmxfeed->demux->priv;\r\nu8 b0[] = { 0x00, 0x00, 0x00, 0x01,\r\n0x00, 0x00, 0x00, 0x00,\r\n0x00, 0x00, 0x00, 0x00,\r\n0x00, 0x00, 0x00, 0x00,\r\n0x00, 0xff, 0x00, 0x00,\r\n0x00, 0x00, 0x00, 0x00,\r\n0x00, 0x00, 0x00, 0x00,\r\n0x00 };\r\n__be16 pid;\r\nu8 c[COMMAND_PACKET_SIZE];\r\nint c_length;\r\nint result;\r\nstruct filter_info *finfo;\r\nunsigned long flags;\r\nu8 x = 1;\r\ndprintk("%s\n", __func__);\r\npid = htons(dvbdmxfeed->pid);\r\nmemcpy(&b0[0], &pid, 2);\r\nmemcpy(&b0[4], &x, 1);\r\nmemcpy(&b0[5], &dvbdmxfeed->filter->filter.filter_value[0], 1);\r\nresult = ttusb_dec_send_command(dec, 0x60, sizeof(b0), b0,\r\n&c_length, c);\r\nif (!result) {\r\nif (c_length == 2) {\r\nif (!(finfo = kmalloc(sizeof(struct filter_info),\r\nGFP_ATOMIC)))\r\nreturn -ENOMEM;\r\nfinfo->stream_id = c[1];\r\nfinfo->filter = dvbdmxfeed->filter;\r\nspin_lock_irqsave(&dec->filter_info_list_lock, flags);\r\nlist_add_tail(&finfo->filter_info_list,\r\n&dec->filter_info_list);\r\nspin_unlock_irqrestore(&dec->filter_info_list_lock,\r\nflags);\r\ndvbdmxfeed->priv = finfo;\r\ndec->filter_stream_count++;\r\nreturn ttusb_dec_start_iso_xfer(dec);\r\n}\r\nreturn -EAGAIN;\r\n} else\r\nreturn result;\r\n}\r\nstatic int ttusb_dec_start_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\nstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\r\ndprintk("%s\n", __func__);\r\nif (!dvbdmx->dmx.frontend)\r\nreturn -EINVAL;\r\ndprintk(" pid: 0x%04X\n", dvbdmxfeed->pid);\r\nswitch (dvbdmxfeed->type) {\r\ncase DMX_TYPE_TS:\r\nreturn ttusb_dec_start_ts_feed(dvbdmxfeed);\r\nbreak;\r\ncase DMX_TYPE_SEC:\r\nreturn ttusb_dec_start_sec_feed(dvbdmxfeed);\r\nbreak;\r\ndefault:\r\ndprintk(" type: unknown (%d)\n", dvbdmxfeed->type);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int ttusb_dec_stop_ts_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\nstruct ttusb_dec *dec = dvbdmxfeed->demux->priv;\r\nu8 b0[] = { 0x00 };\r\nttusb_dec_send_command(dec, 0x81, sizeof(b0), b0, NULL, NULL);\r\ndec->pva_stream_count--;\r\nttusb_dec_stop_iso_xfer(dec);\r\nreturn 0;\r\n}\r\nstatic int ttusb_dec_stop_sec_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\nstruct ttusb_dec *dec = dvbdmxfeed->demux->priv;\r\nu8 b0[] = { 0x00, 0x00 };\r\nstruct filter_info *finfo = (struct filter_info *)dvbdmxfeed->priv;\r\nunsigned long flags;\r\nb0[1] = finfo->stream_id;\r\nspin_lock_irqsave(&dec->filter_info_list_lock, flags);\r\nlist_del(&finfo->filter_info_list);\r\nspin_unlock_irqrestore(&dec->filter_info_list_lock, flags);\r\nkfree(finfo);\r\nttusb_dec_send_command(dec, 0x62, sizeof(b0), b0, NULL, NULL);\r\ndec->filter_stream_count--;\r\nttusb_dec_stop_iso_xfer(dec);\r\nreturn 0;\r\n}\r\nstatic int ttusb_dec_stop_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\ndprintk("%s\n", __func__);\r\nswitch (dvbdmxfeed->type) {\r\ncase DMX_TYPE_TS:\r\nreturn ttusb_dec_stop_ts_feed(dvbdmxfeed);\r\nbreak;\r\ncase DMX_TYPE_SEC:\r\nreturn ttusb_dec_stop_sec_feed(dvbdmxfeed);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ttusb_dec_free_iso_urbs(struct ttusb_dec *dec)\r\n{\r\nint i;\r\ndprintk("%s\n", __func__);\r\nfor (i = 0; i < ISO_BUF_COUNT; i++)\r\nusb_free_urb(dec->iso_urb[i]);\r\npci_free_consistent(NULL,\r\nISO_FRAME_SIZE * (FRAMES_PER_ISO_BUF *\r\nISO_BUF_COUNT),\r\ndec->iso_buffer, dec->iso_dma_handle);\r\n}\r\nstatic int ttusb_dec_alloc_iso_urbs(struct ttusb_dec *dec)\r\n{\r\nint i;\r\ndprintk("%s\n", __func__);\r\ndec->iso_buffer = pci_zalloc_consistent(NULL,\r\nISO_FRAME_SIZE * (FRAMES_PER_ISO_BUF * ISO_BUF_COUNT),\r\n&dec->iso_dma_handle);\r\nif (!dec->iso_buffer) {\r\ndprintk("%s: pci_alloc_consistent - not enough memory\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < ISO_BUF_COUNT; i++) {\r\nstruct urb *urb;\r\nif (!(urb = usb_alloc_urb(FRAMES_PER_ISO_BUF, GFP_ATOMIC))) {\r\nttusb_dec_free_iso_urbs(dec);\r\nreturn -ENOMEM;\r\n}\r\ndec->iso_urb[i] = urb;\r\n}\r\nttusb_dec_setup_urbs(dec);\r\nreturn 0;\r\n}\r\nstatic void ttusb_dec_init_tasklet(struct ttusb_dec *dec)\r\n{\r\nspin_lock_init(&dec->urb_frame_list_lock);\r\nINIT_LIST_HEAD(&dec->urb_frame_list);\r\ntasklet_init(&dec->urb_tasklet, ttusb_dec_process_urb_frame_list,\r\n(unsigned long)dec);\r\n}\r\nstatic int ttusb_init_rc( struct ttusb_dec *dec)\r\n{\r\nstruct input_dev *input_dev;\r\nu8 b[] = { 0x00, 0x01 };\r\nint i;\r\nint err;\r\nusb_make_path(dec->udev, dec->rc_phys, sizeof(dec->rc_phys));\r\nstrlcat(dec->rc_phys, "/input0", sizeof(dec->rc_phys));\r\ninput_dev = input_allocate_device();\r\nif (!input_dev)\r\nreturn -ENOMEM;\r\ninput_dev->name = "ttusb_dec remote control";\r\ninput_dev->phys = dec->rc_phys;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY);\r\ninput_dev->keycodesize = sizeof(u16);\r\ninput_dev->keycodemax = 0x1a;\r\ninput_dev->keycode = rc_keys;\r\nfor (i = 0; i < ARRAY_SIZE(rc_keys); i++)\r\nset_bit(rc_keys[i], input_dev->keybit);\r\nerr = input_register_device(input_dev);\r\nif (err) {\r\ninput_free_device(input_dev);\r\nreturn err;\r\n}\r\ndec->rc_input_dev = input_dev;\r\nif (usb_submit_urb(dec->irq_urb, GFP_KERNEL))\r\nprintk("%s: usb_submit_urb failed\n",__func__);\r\nttusb_dec_send_command(dec,0xb0,sizeof(b),b,NULL,NULL);\r\nreturn 0;\r\n}\r\nstatic void ttusb_dec_init_v_pes(struct ttusb_dec *dec)\r\n{\r\ndprintk("%s\n", __func__);\r\ndec->v_pes[0] = 0x00;\r\ndec->v_pes[1] = 0x00;\r\ndec->v_pes[2] = 0x01;\r\ndec->v_pes[3] = 0xe0;\r\n}\r\nstatic int ttusb_dec_init_usb(struct ttusb_dec *dec)\r\n{\r\nint result;\r\ndprintk("%s\n", __func__);\r\nmutex_init(&dec->usb_mutex);\r\nmutex_init(&dec->iso_mutex);\r\ndec->command_pipe = usb_sndbulkpipe(dec->udev, COMMAND_PIPE);\r\ndec->result_pipe = usb_rcvbulkpipe(dec->udev, RESULT_PIPE);\r\ndec->in_pipe = usb_rcvisocpipe(dec->udev, IN_PIPE);\r\ndec->out_pipe = usb_sndisocpipe(dec->udev, OUT_PIPE);\r\ndec->irq_pipe = usb_rcvintpipe(dec->udev, IRQ_PIPE);\r\nif(enable_rc) {\r\ndec->irq_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif(!dec->irq_urb) {\r\nreturn -ENOMEM;\r\n}\r\ndec->irq_buffer = usb_alloc_coherent(dec->udev,IRQ_PACKET_SIZE,\r\nGFP_KERNEL, &dec->irq_dma_handle);\r\nif(!dec->irq_buffer) {\r\nusb_free_urb(dec->irq_urb);\r\nreturn -ENOMEM;\r\n}\r\nusb_fill_int_urb(dec->irq_urb, dec->udev,dec->irq_pipe,\r\ndec->irq_buffer, IRQ_PACKET_SIZE,\r\nttusb_dec_handle_irq, dec, 1);\r\ndec->irq_urb->transfer_dma = dec->irq_dma_handle;\r\ndec->irq_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\n}\r\nresult = ttusb_dec_alloc_iso_urbs(dec);\r\nif (result) {\r\nusb_free_urb(dec->irq_urb);\r\nusb_free_coherent(dec->udev, IRQ_PACKET_SIZE,\r\ndec->irq_buffer, dec->irq_dma_handle);\r\n}\r\nreturn result;\r\n}\r\nstatic int ttusb_dec_boot_dsp(struct ttusb_dec *dec)\r\n{\r\nint i, j, actual_len, result, size, trans_count;\r\nu8 b0[] = { 0x00, 0x00, 0x00, 0x00,\r\n0x00, 0x00, 0x00, 0x00,\r\n0x61, 0x00 };\r\nu8 b1[] = { 0x61 };\r\nu8 *b;\r\nchar idstring[21];\r\nconst u8 *firmware = NULL;\r\nsize_t firmware_size = 0;\r\nu16 firmware_csum = 0;\r\n__be16 firmware_csum_ns;\r\n__be32 firmware_size_nl;\r\nu32 crc32_csum, crc32_check;\r\n__be32 tmp;\r\nconst struct firmware *fw_entry = NULL;\r\ndprintk("%s\n", __func__);\r\nresult = request_firmware(&fw_entry, dec->firmware_name, &dec->udev->dev);\r\nif (result) {\r\nprintk(KERN_ERR "%s: Firmware (%s) unavailable.\n",\r\n__func__, dec->firmware_name);\r\nreturn result;\r\n}\r\nfirmware = fw_entry->data;\r\nfirmware_size = fw_entry->size;\r\nif (firmware_size < 60) {\r\nprintk("%s: firmware size too small for DSP code (%zu < 60).\n",\r\n__func__, firmware_size);\r\nrelease_firmware(fw_entry);\r\nreturn -ENOENT;\r\n}\r\ncrc32_csum = crc32(~0L, firmware, 56) ^ ~0L;\r\nmemcpy(&tmp, &firmware[56], 4);\r\ncrc32_check = ntohl(tmp);\r\nif (crc32_csum != crc32_check) {\r\nprintk("%s: crc32 check of DSP code failed (calculated 0x%08x != 0x%08x in file), file invalid.\n",\r\n__func__, crc32_csum, crc32_check);\r\nrelease_firmware(fw_entry);\r\nreturn -ENOENT;\r\n}\r\nmemcpy(idstring, &firmware[36], 20);\r\nidstring[20] = '\0';\r\nprintk(KERN_INFO "ttusb_dec: found DSP code \"%s\".\n", idstring);\r\nfirmware_size_nl = htonl(firmware_size);\r\nmemcpy(b0, &firmware_size_nl, 4);\r\nfirmware_csum = crc16(~0, firmware, firmware_size) ^ ~0;\r\nfirmware_csum_ns = htons(firmware_csum);\r\nmemcpy(&b0[6], &firmware_csum_ns, 2);\r\nresult = ttusb_dec_send_command(dec, 0x41, sizeof(b0), b0, NULL, NULL);\r\nif (result) {\r\nrelease_firmware(fw_entry);\r\nreturn result;\r\n}\r\ntrans_count = 0;\r\nj = 0;\r\nb = kmalloc(ARM_PACKET_SIZE, GFP_KERNEL);\r\nif (b == NULL) {\r\nrelease_firmware(fw_entry);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < firmware_size; i += COMMAND_PACKET_SIZE) {\r\nsize = firmware_size - i;\r\nif (size > COMMAND_PACKET_SIZE)\r\nsize = COMMAND_PACKET_SIZE;\r\nb[j + 0] = 0xaa;\r\nb[j + 1] = trans_count++;\r\nb[j + 2] = 0xf0;\r\nb[j + 3] = size;\r\nmemcpy(&b[j + 4], &firmware[i], size);\r\nj += COMMAND_PACKET_SIZE + 4;\r\nif (j >= ARM_PACKET_SIZE) {\r\nresult = usb_bulk_msg(dec->udev, dec->command_pipe, b,\r\nARM_PACKET_SIZE, &actual_len,\r\n100);\r\nj = 0;\r\n} else if (size < COMMAND_PACKET_SIZE) {\r\nresult = usb_bulk_msg(dec->udev, dec->command_pipe, b,\r\nj - COMMAND_PACKET_SIZE + size,\r\n&actual_len, 100);\r\n}\r\n}\r\nresult = ttusb_dec_send_command(dec, 0x43, sizeof(b1), b1, NULL, NULL);\r\nrelease_firmware(fw_entry);\r\nkfree(b);\r\nreturn result;\r\n}\r\nstatic int ttusb_dec_init_stb(struct ttusb_dec *dec)\r\n{\r\nint result;\r\nunsigned int mode = 0, model = 0, version = 0;\r\ndprintk("%s\n", __func__);\r\nresult = ttusb_dec_get_stb_state(dec, &mode, &model, &version);\r\nif (result)\r\nreturn result;\r\nif (!mode) {\r\nif (version == 0xABCDEFAB)\r\nprintk(KERN_INFO "ttusb_dec: no version info in Firmware\n");\r\nelse\r\nprintk(KERN_INFO "ttusb_dec: Firmware %x.%02x%c%c\n",\r\nversion >> 24, (version >> 16) & 0xff,\r\n(version >> 8) & 0xff, version & 0xff);\r\nresult = ttusb_dec_boot_dsp(dec);\r\nif (result)\r\nreturn result;\r\n} else {\r\nswitch (model) {\r\ncase 0x00070001:\r\ncase 0x00070008:\r\ncase 0x0007000c:\r\nttusb_dec_set_model(dec, TTUSB_DEC3000S);\r\nbreak;\r\ncase 0x00070009:\r\ncase 0x00070013:\r\nttusb_dec_set_model(dec, TTUSB_DEC2000T);\r\nbreak;\r\ncase 0x00070011:\r\nttusb_dec_set_model(dec, TTUSB_DEC2540T);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s: unknown model returned by firmware (%08x) - please report\n",\r\n__func__, model);\r\nreturn -ENOENT;\r\n}\r\nif (version >= 0x01770000)\r\ndec->can_playback = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ttusb_dec_init_dvb(struct ttusb_dec *dec)\r\n{\r\nint result;\r\ndprintk("%s\n", __func__);\r\nif ((result = dvb_register_adapter(&dec->adapter,\r\ndec->model_name, THIS_MODULE,\r\n&dec->udev->dev,\r\nadapter_nr)) < 0) {\r\nprintk("%s: dvb_register_adapter failed: error %d\n",\r\n__func__, result);\r\nreturn result;\r\n}\r\ndec->demux.dmx.capabilities = DMX_TS_FILTERING | DMX_SECTION_FILTERING;\r\ndec->demux.priv = (void *)dec;\r\ndec->demux.filternum = 31;\r\ndec->demux.feednum = 31;\r\ndec->demux.start_feed = ttusb_dec_start_feed;\r\ndec->demux.stop_feed = ttusb_dec_stop_feed;\r\ndec->demux.write_to_decoder = NULL;\r\nif ((result = dvb_dmx_init(&dec->demux)) < 0) {\r\nprintk("%s: dvb_dmx_init failed: error %d\n", __func__,\r\nresult);\r\ndvb_unregister_adapter(&dec->adapter);\r\nreturn result;\r\n}\r\ndec->dmxdev.filternum = 32;\r\ndec->dmxdev.demux = &dec->demux.dmx;\r\ndec->dmxdev.capabilities = 0;\r\nif ((result = dvb_dmxdev_init(&dec->dmxdev, &dec->adapter)) < 0) {\r\nprintk("%s: dvb_dmxdev_init failed: error %d\n",\r\n__func__, result);\r\ndvb_dmx_release(&dec->demux);\r\ndvb_unregister_adapter(&dec->adapter);\r\nreturn result;\r\n}\r\ndec->frontend.source = DMX_FRONTEND_0;\r\nif ((result = dec->demux.dmx.add_frontend(&dec->demux.dmx,\r\n&dec->frontend)) < 0) {\r\nprintk("%s: dvb_dmx_init failed: error %d\n", __func__,\r\nresult);\r\ndvb_dmxdev_release(&dec->dmxdev);\r\ndvb_dmx_release(&dec->demux);\r\ndvb_unregister_adapter(&dec->adapter);\r\nreturn result;\r\n}\r\nif ((result = dec->demux.dmx.connect_frontend(&dec->demux.dmx,\r\n&dec->frontend)) < 0) {\r\nprintk("%s: dvb_dmx_init failed: error %d\n", __func__,\r\nresult);\r\ndec->demux.dmx.remove_frontend(&dec->demux.dmx, &dec->frontend);\r\ndvb_dmxdev_release(&dec->dmxdev);\r\ndvb_dmx_release(&dec->demux);\r\ndvb_unregister_adapter(&dec->adapter);\r\nreturn result;\r\n}\r\ndvb_net_init(&dec->adapter, &dec->dvb_net, &dec->demux.dmx);\r\nreturn 0;\r\n}\r\nstatic void ttusb_dec_exit_dvb(struct ttusb_dec *dec)\r\n{\r\ndprintk("%s\n", __func__);\r\ndvb_net_release(&dec->dvb_net);\r\ndec->demux.dmx.close(&dec->demux.dmx);\r\ndec->demux.dmx.remove_frontend(&dec->demux.dmx, &dec->frontend);\r\ndvb_dmxdev_release(&dec->dmxdev);\r\ndvb_dmx_release(&dec->demux);\r\nif (dec->fe) {\r\ndvb_unregister_frontend(dec->fe);\r\nif (dec->fe->ops.release)\r\ndec->fe->ops.release(dec->fe);\r\n}\r\ndvb_unregister_adapter(&dec->adapter);\r\n}\r\nstatic void ttusb_dec_exit_rc(struct ttusb_dec *dec)\r\n{\r\ndprintk("%s\n", __func__);\r\nif (dec->rc_input_dev) {\r\ninput_unregister_device(dec->rc_input_dev);\r\ndec->rc_input_dev = NULL;\r\n}\r\n}\r\nstatic void ttusb_dec_exit_usb(struct ttusb_dec *dec)\r\n{\r\nint i;\r\ndprintk("%s\n", __func__);\r\nif (enable_rc) {\r\nif (dec->interface == TTUSB_DEC_INTERFACE_IN)\r\nusb_kill_urb(dec->irq_urb);\r\nusb_free_urb(dec->irq_urb);\r\nusb_free_coherent(dec->udev, IRQ_PACKET_SIZE,\r\ndec->irq_buffer, dec->irq_dma_handle);\r\n}\r\ndec->iso_stream_count = 0;\r\nfor (i = 0; i < ISO_BUF_COUNT; i++)\r\nusb_kill_urb(dec->iso_urb[i]);\r\nttusb_dec_free_iso_urbs(dec);\r\n}\r\nstatic void ttusb_dec_exit_tasklet(struct ttusb_dec *dec)\r\n{\r\nstruct list_head *item;\r\nstruct urb_frame *frame;\r\ntasklet_kill(&dec->urb_tasklet);\r\nwhile ((item = dec->urb_frame_list.next) != &dec->urb_frame_list) {\r\nframe = list_entry(item, struct urb_frame, urb_frame_list);\r\nlist_del(&frame->urb_frame_list);\r\nkfree(frame);\r\n}\r\n}\r\nstatic void ttusb_dec_init_filters(struct ttusb_dec *dec)\r\n{\r\nINIT_LIST_HEAD(&dec->filter_info_list);\r\nspin_lock_init(&dec->filter_info_list_lock);\r\n}\r\nstatic void ttusb_dec_exit_filters(struct ttusb_dec *dec)\r\n{\r\nstruct list_head *item;\r\nstruct filter_info *finfo;\r\nwhile ((item = dec->filter_info_list.next) != &dec->filter_info_list) {\r\nfinfo = list_entry(item, struct filter_info, filter_info_list);\r\nlist_del(&finfo->filter_info_list);\r\nkfree(finfo);\r\n}\r\n}\r\nstatic int fe_send_command(struct dvb_frontend* fe, const u8 command,\r\nint param_length, const u8 params[],\r\nint *result_length, u8 cmd_result[])\r\n{\r\nstruct ttusb_dec* dec = fe->dvb->priv;\r\nreturn ttusb_dec_send_command(dec, command, param_length, params, result_length, cmd_result);\r\n}\r\nstatic int ttusb_dec_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev;\r\nstruct ttusb_dec *dec;\r\nint result;\r\ndprintk("%s\n", __func__);\r\nudev = interface_to_usbdev(intf);\r\nif (!(dec = kzalloc(sizeof(struct ttusb_dec), GFP_KERNEL))) {\r\nprintk("%s: couldn't allocate memory.\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nusb_set_intfdata(intf, (void *)dec);\r\nswitch (id->idProduct) {\r\ncase 0x1006:\r\nttusb_dec_set_model(dec, TTUSB_DEC3000S);\r\nbreak;\r\ncase 0x1008:\r\nttusb_dec_set_model(dec, TTUSB_DEC2000T);\r\nbreak;\r\ncase 0x1009:\r\nttusb_dec_set_model(dec, TTUSB_DEC2540T);\r\nbreak;\r\n}\r\ndec->udev = udev;\r\nresult = ttusb_dec_init_usb(dec);\r\nif (result)\r\ngoto err_usb;\r\nresult = ttusb_dec_init_stb(dec);\r\nif (result)\r\ngoto err_stb;\r\nresult = ttusb_dec_init_dvb(dec);\r\nif (result)\r\ngoto err_stb;\r\ndec->adapter.priv = dec;\r\nswitch (id->idProduct) {\r\ncase 0x1006:\r\ndec->fe = ttusbdecfe_dvbs_attach(&fe_config);\r\nbreak;\r\ncase 0x1008:\r\ncase 0x1009:\r\ndec->fe = ttusbdecfe_dvbt_attach(&fe_config);\r\nbreak;\r\n}\r\nif (dec->fe == NULL) {\r\nprintk("dvb-ttusb-dec: A frontend driver was not found for device [%04x:%04x]\n",\r\nle16_to_cpu(dec->udev->descriptor.idVendor),\r\nle16_to_cpu(dec->udev->descriptor.idProduct));\r\n} else {\r\nif (dvb_register_frontend(&dec->adapter, dec->fe)) {\r\nprintk("budget-ci: Frontend registration failed!\n");\r\nif (dec->fe->ops.release)\r\ndec->fe->ops.release(dec->fe);\r\ndec->fe = NULL;\r\n}\r\n}\r\nttusb_dec_init_v_pes(dec);\r\nttusb_dec_init_filters(dec);\r\nttusb_dec_init_tasklet(dec);\r\ndec->active = 1;\r\nttusb_dec_set_interface(dec, TTUSB_DEC_INTERFACE_IN);\r\nif (enable_rc)\r\nttusb_init_rc(dec);\r\nreturn 0;\r\nerr_stb:\r\nttusb_dec_exit_usb(dec);\r\nerr_usb:\r\nkfree(dec);\r\nreturn result;\r\n}\r\nstatic void ttusb_dec_disconnect(struct usb_interface *intf)\r\n{\r\nstruct ttusb_dec *dec = usb_get_intfdata(intf);\r\nusb_set_intfdata(intf, NULL);\r\ndprintk("%s\n", __func__);\r\nif (dec->active) {\r\nttusb_dec_exit_tasklet(dec);\r\nttusb_dec_exit_filters(dec);\r\nif(enable_rc)\r\nttusb_dec_exit_rc(dec);\r\nttusb_dec_exit_usb(dec);\r\nttusb_dec_exit_dvb(dec);\r\n}\r\nkfree(dec);\r\n}\r\nstatic void ttusb_dec_set_model(struct ttusb_dec *dec,\r\nenum ttusb_dec_model model)\r\n{\r\ndec->model = model;\r\nswitch (model) {\r\ncase TTUSB_DEC2000T:\r\ndec->model_name = "DEC2000-t";\r\ndec->firmware_name = "dvb-ttusb-dec-2000t.fw";\r\nbreak;\r\ncase TTUSB_DEC2540T:\r\ndec->model_name = "DEC2540-t";\r\ndec->firmware_name = "dvb-ttusb-dec-2540t.fw";\r\nbreak;\r\ncase TTUSB_DEC3000S:\r\ndec->model_name = "DEC3000-s";\r\ndec->firmware_name = "dvb-ttusb-dec-3000s.fw";\r\nbreak;\r\n}\r\n}
