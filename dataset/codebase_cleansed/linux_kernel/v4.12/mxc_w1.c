static u8 mxc_w1_ds2_reset_bus(void *data)\r\n{\r\nstruct mxc_w1_device *dev = data;\r\nunsigned long timeout;\r\nwriteb(MXC_W1_CONTROL_RPP, dev->regs + MXC_W1_CONTROL);\r\ntimeout = jiffies + usecs_to_jiffies(1500);\r\nudelay(511 + 512);\r\ndo {\r\nu8 ctrl = readb(dev->regs + MXC_W1_CONTROL);\r\nif (!(ctrl & MXC_W1_CONTROL_RPP))\r\nreturn !(ctrl & MXC_W1_CONTROL_PST);\r\n} while (time_is_after_jiffies(timeout));\r\nreturn 1;\r\n}\r\nstatic u8 mxc_w1_ds2_touch_bit(void *data, u8 bit)\r\n{\r\nstruct mxc_w1_device *dev = data;\r\nunsigned long timeout;\r\nwriteb(MXC_W1_CONTROL_WR(bit), dev->regs + MXC_W1_CONTROL);\r\ntimeout = jiffies + usecs_to_jiffies(200);\r\nudelay(60);\r\ndo {\r\nu8 ctrl = readb(dev->regs + MXC_W1_CONTROL);\r\nif (!(ctrl & MXC_W1_CONTROL_WR(bit)))\r\nreturn !!(ctrl & MXC_W1_CONTROL_RDST);\r\n} while (time_is_after_jiffies(timeout));\r\nreturn 0;\r\n}\r\nstatic int mxc_w1_probe(struct platform_device *pdev)\r\n{\r\nstruct mxc_w1_device *mdev;\r\nunsigned long clkrate;\r\nstruct resource *res;\r\nunsigned int clkdiv;\r\nint err;\r\nmdev = devm_kzalloc(&pdev->dev, sizeof(struct mxc_w1_device),\r\nGFP_KERNEL);\r\nif (!mdev)\r\nreturn -ENOMEM;\r\nmdev->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(mdev->clk))\r\nreturn PTR_ERR(mdev->clk);\r\nclkrate = clk_get_rate(mdev->clk);\r\nif (clkrate < 10000000)\r\ndev_warn(&pdev->dev,\r\n"Low clock frequency causes improper function\n");\r\nclkdiv = DIV_ROUND_CLOSEST(clkrate, 1000000);\r\nclkrate /= clkdiv;\r\nif ((clkrate < 980000) || (clkrate > 1020000))\r\ndev_warn(&pdev->dev,\r\n"Incorrect time base frequency %lu Hz\n", clkrate);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmdev->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(mdev->regs))\r\nreturn PTR_ERR(mdev->regs);\r\nerr = clk_prepare_enable(mdev->clk);\r\nif (err)\r\nreturn err;\r\nwriteb(MXC_W1_RESET_RST, mdev->regs + MXC_W1_RESET);\r\nwriteb(0, mdev->regs + MXC_W1_RESET);\r\nwriteb(clkdiv - 1, mdev->regs + MXC_W1_TIME_DIVIDER);\r\nmdev->bus_master.data = mdev;\r\nmdev->bus_master.reset_bus = mxc_w1_ds2_reset_bus;\r\nmdev->bus_master.touch_bit = mxc_w1_ds2_touch_bit;\r\nplatform_set_drvdata(pdev, mdev);\r\nerr = w1_add_master_device(&mdev->bus_master);\r\nif (err)\r\nclk_disable_unprepare(mdev->clk);\r\nreturn err;\r\n}\r\nstatic int mxc_w1_remove(struct platform_device *pdev)\r\n{\r\nstruct mxc_w1_device *mdev = platform_get_drvdata(pdev);\r\nw1_remove_master_device(&mdev->bus_master);\r\nclk_disable_unprepare(mdev->clk);\r\nreturn 0;\r\n}
