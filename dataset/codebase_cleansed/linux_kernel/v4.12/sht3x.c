static u8 get_mode_from_update_interval(u16 value)\r\n{\r\nsize_t index;\r\nu8 number_of_modes = ARRAY_SIZE(mode_to_update_interval);\r\nif (value == 0)\r\nreturn 0;\r\nfor (index = 1; index < number_of_modes; index++) {\r\nif (mode_to_update_interval[index] <= value)\r\nreturn index;\r\n}\r\nreturn number_of_modes - 1;\r\n}\r\nstatic int sht3x_read_from_command(struct i2c_client *client,\r\nstruct sht3x_data *data,\r\nconst char *command,\r\nchar *buf, int length, u32 wait_time)\r\n{\r\nint ret;\r\nmutex_lock(&data->i2c_lock);\r\nret = i2c_master_send(client, command, SHT3X_CMD_LENGTH);\r\nif (ret != SHT3X_CMD_LENGTH) {\r\nret = ret < 0 ? ret : -EIO;\r\ngoto out;\r\n}\r\nif (wait_time)\r\nusleep_range(wait_time, wait_time + 1000);\r\nret = i2c_master_recv(client, buf, length);\r\nif (ret != length) {\r\nret = ret < 0 ? ret : -EIO;\r\ngoto out;\r\n}\r\nret = 0;\r\nout:\r\nmutex_unlock(&data->i2c_lock);\r\nreturn ret;\r\n}\r\nstatic int sht3x_extract_temperature(u16 raw)\r\n{\r\nreturn ((21875 * (int)raw) >> 13) - 45000;\r\n}\r\nstatic u32 sht3x_extract_humidity(u16 raw)\r\n{\r\nreturn (12500 * (u32)raw) >> 13;\r\n}\r\nstatic struct sht3x_data *sht3x_update_client(struct device *dev)\r\n{\r\nstruct sht3x_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nu16 interval_ms = mode_to_update_interval[data->mode];\r\nunsigned long interval_jiffies = msecs_to_jiffies(interval_ms);\r\nunsigned char buf[SHT3X_RESPONSE_LENGTH];\r\nu16 val;\r\nint ret = 0;\r\nmutex_lock(&data->data_lock);\r\nif (time_after(jiffies, data->last_update + interval_jiffies)) {\r\nret = sht3x_read_from_command(client, data, data->command, buf,\r\nsizeof(buf), data->wait_time);\r\nif (ret)\r\ngoto out;\r\nval = be16_to_cpup((__be16 *)buf);\r\ndata->temperature = sht3x_extract_temperature(val);\r\nval = be16_to_cpup((__be16 *)(buf + 3));\r\ndata->humidity = sht3x_extract_humidity(val);\r\ndata->last_update = jiffies;\r\n}\r\nout:\r\nmutex_unlock(&data->data_lock);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nreturn data;\r\n}\r\nstatic ssize_t temp1_input_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct sht3x_data *data = sht3x_update_client(dev);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nreturn sprintf(buf, "%d\n", data->temperature);\r\n}\r\nstatic ssize_t humidity1_input_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct sht3x_data *data = sht3x_update_client(dev);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nreturn sprintf(buf, "%u\n", data->humidity);\r\n}\r\nstatic int limits_update(struct sht3x_data *data)\r\n{\r\nint ret;\r\nu8 index;\r\nint temperature;\r\nu32 humidity;\r\nu16 raw;\r\nchar buffer[SHT3X_RESPONSE_LENGTH];\r\nconst struct sht3x_limit_commands *commands;\r\nstruct i2c_client *client = data->client;\r\nfor (index = 0; index < SHT3X_NUM_LIMIT_CMD; index++) {\r\ncommands = &limit_commands[index];\r\nret = sht3x_read_from_command(client, data,\r\ncommands->read_command, buffer,\r\nSHT3X_RESPONSE_LENGTH, 0);\r\nif (ret)\r\nreturn ret;\r\nraw = be16_to_cpup((__be16 *)buffer);\r\ntemperature = sht3x_extract_temperature((raw & 0x01ff) << 7);\r\nhumidity = sht3x_extract_humidity(raw & 0xfe00);\r\ndata->temperature_limits[index] = temperature;\r\ndata->humidity_limits[index] = humidity;\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t temp1_limit_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sht3x_data *data = dev_get_drvdata(dev);\r\nu8 index = to_sensor_dev_attr(attr)->index;\r\nint temperature_limit = data->temperature_limits[index];\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", temperature_limit);\r\n}\r\nstatic ssize_t humidity1_limit_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sht3x_data *data = dev_get_drvdata(dev);\r\nu8 index = to_sensor_dev_attr(attr)->index;\r\nu32 humidity_limit = data->humidity_limits[index];\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", humidity_limit);\r\n}\r\nstatic size_t limit_store(struct device *dev,\r\nsize_t count,\r\nu8 index,\r\nint temperature,\r\nu32 humidity)\r\n{\r\nchar buffer[SHT3X_CMD_LENGTH + SHT3X_WORD_LEN + SHT3X_CRC8_LEN];\r\nchar *position = buffer;\r\nint ret;\r\nu16 raw;\r\nstruct sht3x_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nconst struct sht3x_limit_commands *commands;\r\ncommands = &limit_commands[index];\r\nmemcpy(position, commands->write_command, SHT3X_CMD_LENGTH);\r\nposition += SHT3X_CMD_LENGTH;\r\nraw = ((u32)(temperature + 45000) * 24543) >> (16 + 7);\r\nraw |= ((humidity * 42950) >> 16) & 0xfe00;\r\n*((__be16 *)position) = cpu_to_be16(raw);\r\nposition += SHT3X_WORD_LEN;\r\n*position = crc8(sht3x_crc8_table,\r\nposition - SHT3X_WORD_LEN,\r\nSHT3X_WORD_LEN,\r\nSHT3X_CRC8_INIT);\r\nmutex_lock(&data->i2c_lock);\r\nret = i2c_master_send(client, buffer, sizeof(buffer));\r\nmutex_unlock(&data->i2c_lock);\r\nif (ret != sizeof(buffer))\r\nreturn ret < 0 ? ret : -EIO;\r\ndata->temperature_limits[index] = temperature;\r\ndata->humidity_limits[index] = humidity;\r\nreturn count;\r\n}\r\nstatic ssize_t temp1_limit_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nint temperature;\r\nint ret;\r\nstruct sht3x_data *data = dev_get_drvdata(dev);\r\nu8 index = to_sensor_dev_attr(attr)->index;\r\nret = kstrtoint(buf, 0, &temperature);\r\nif (ret)\r\nreturn ret;\r\ntemperature = clamp_val(temperature, SHT3X_MIN_TEMPERATURE,\r\nSHT3X_MAX_TEMPERATURE);\r\nmutex_lock(&data->data_lock);\r\nret = limit_store(dev, count, index, temperature,\r\ndata->humidity_limits[index]);\r\nmutex_unlock(&data->data_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t humidity1_limit_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nu32 humidity;\r\nint ret;\r\nstruct sht3x_data *data = dev_get_drvdata(dev);\r\nu8 index = to_sensor_dev_attr(attr)->index;\r\nret = kstrtou32(buf, 0, &humidity);\r\nif (ret)\r\nreturn ret;\r\nhumidity = clamp_val(humidity, SHT3X_MIN_HUMIDITY, SHT3X_MAX_HUMIDITY);\r\nmutex_lock(&data->data_lock);\r\nret = limit_store(dev, count, index, data->temperature_limits[index],\r\nhumidity);\r\nmutex_unlock(&data->data_lock);\r\nreturn ret;\r\n}\r\nstatic void sht3x_select_command(struct sht3x_data *data)\r\n{\r\nif (data->mode > 0) {\r\ndata->command = sht3x_cmd_measure_periodic_mode;\r\ndata->wait_time = 0;\r\n} else if (data->setup.blocking_io) {\r\ndata->command = data->setup.high_precision ?\r\nsht3x_cmd_measure_blocking_hpm :\r\nsht3x_cmd_measure_blocking_lpm;\r\ndata->wait_time = 0;\r\n} else {\r\nif (data->setup.high_precision) {\r\ndata->command = sht3x_cmd_measure_nonblocking_hpm;\r\ndata->wait_time = SHT3X_NONBLOCKING_WAIT_TIME_HPM;\r\n} else {\r\ndata->command = sht3x_cmd_measure_nonblocking_lpm;\r\ndata->wait_time = SHT3X_NONBLOCKING_WAIT_TIME_LPM;\r\n}\r\n}\r\n}\r\nstatic int status_register_read(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buffer, int length)\r\n{\r\nint ret;\r\nstruct sht3x_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nret = sht3x_read_from_command(client, data, sht3x_cmd_read_status_reg,\r\nbuffer, length, 0);\r\nreturn ret;\r\n}\r\nstatic ssize_t temp1_alarm_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nchar buffer[SHT3X_WORD_LEN + SHT3X_CRC8_LEN];\r\nint ret;\r\nret = status_register_read(dev, attr, buffer,\r\nSHT3X_WORD_LEN + SHT3X_CRC8_LEN);\r\nif (ret)\r\nreturn ret;\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", !!(buffer[0] & 0x04));\r\n}\r\nstatic ssize_t humidity1_alarm_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nchar buffer[SHT3X_WORD_LEN + SHT3X_CRC8_LEN];\r\nint ret;\r\nret = status_register_read(dev, attr, buffer,\r\nSHT3X_WORD_LEN + SHT3X_CRC8_LEN);\r\nif (ret)\r\nreturn ret;\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", !!(buffer[0] & 0x08));\r\n}\r\nstatic ssize_t heater_enable_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nchar buffer[SHT3X_WORD_LEN + SHT3X_CRC8_LEN];\r\nint ret;\r\nret = status_register_read(dev, attr, buffer,\r\nSHT3X_WORD_LEN + SHT3X_CRC8_LEN);\r\nif (ret)\r\nreturn ret;\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", !!(buffer[0] & 0x20));\r\n}\r\nstatic ssize_t heater_enable_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct sht3x_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint ret;\r\nbool status;\r\nret = kstrtobool(buf, &status);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&data->i2c_lock);\r\nif (status)\r\nret = i2c_master_send(client, (char *)&sht3x_cmd_heater_on,\r\nSHT3X_CMD_LENGTH);\r\nelse\r\nret = i2c_master_send(client, (char *)&sht3x_cmd_heater_off,\r\nSHT3X_CMD_LENGTH);\r\nmutex_unlock(&data->i2c_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t update_interval_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sht3x_data *data = dev_get_drvdata(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n",\r\nmode_to_update_interval[data->mode]);\r\n}\r\nstatic ssize_t update_interval_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nu16 update_interval;\r\nu8 mode;\r\nint ret;\r\nconst char *command;\r\nstruct sht3x_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nret = kstrtou16(buf, 0, &update_interval);\r\nif (ret)\r\nreturn ret;\r\nmode = get_mode_from_update_interval(update_interval);\r\nmutex_lock(&data->data_lock);\r\nif (mode == data->mode) {\r\nmutex_unlock(&data->data_lock);\r\nreturn count;\r\n}\r\nmutex_lock(&data->i2c_lock);\r\nif (data->mode > 0) {\r\nret = i2c_master_send(client, sht3x_cmd_break,\r\nSHT3X_CMD_LENGTH);\r\nif (ret != SHT3X_CMD_LENGTH)\r\ngoto out;\r\ndata->mode = 0;\r\n}\r\nif (mode > 0) {\r\nif (data->setup.high_precision)\r\ncommand = periodic_measure_commands_hpm[mode - 1];\r\nelse\r\ncommand = periodic_measure_commands_lpm[mode - 1];\r\nret = i2c_master_send(client, command, SHT3X_CMD_LENGTH);\r\nif (ret != SHT3X_CMD_LENGTH)\r\ngoto out;\r\n}\r\ndata->mode = mode;\r\nsht3x_select_command(data);\r\nout:\r\nmutex_unlock(&data->i2c_lock);\r\nmutex_unlock(&data->data_lock);\r\nif (ret != SHT3X_CMD_LENGTH)\r\nreturn ret < 0 ? ret : -EIO;\r\nreturn count;\r\n}\r\nstatic int sht3x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret;\r\nstruct sht3x_data *data;\r\nstruct device *hwmon_dev;\r\nstruct i2c_adapter *adap = client->adapter;\r\nstruct device *dev = &client->dev;\r\nconst struct attribute_group **attribute_groups;\r\nif (!i2c_check_functionality(adap, I2C_FUNC_I2C))\r\nreturn -ENODEV;\r\nret = i2c_master_send(client, sht3x_cmd_clear_status_reg,\r\nSHT3X_CMD_LENGTH);\r\nif (ret != SHT3X_CMD_LENGTH)\r\nreturn ret < 0 ? ret : -ENODEV;\r\ndata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->setup.blocking_io = false;\r\ndata->setup.high_precision = true;\r\ndata->mode = 0;\r\ndata->last_update = jiffies - msecs_to_jiffies(3000);\r\ndata->client = client;\r\ncrc8_populate_msb(sht3x_crc8_table, SHT3X_CRC8_POLYNOMIAL);\r\nif (client->dev.platform_data)\r\ndata->setup = *(struct sht3x_platform_data *)dev->platform_data;\r\nsht3x_select_command(data);\r\nmutex_init(&data->i2c_lock);\r\nmutex_init(&data->data_lock);\r\nret = limits_update(data);\r\nif (ret)\r\nreturn ret;\r\nif (id->driver_data == sts3x)\r\nattribute_groups = sts3x_groups;\r\nelse\r\nattribute_groups = sht3x_groups;\r\nhwmon_dev = devm_hwmon_device_register_with_groups(dev,\r\nclient->name,\r\ndata,\r\nattribute_groups);\r\nif (IS_ERR(hwmon_dev))\r\ndev_dbg(dev, "unable to register hwmon device\n");\r\nreturn PTR_ERR_OR_ZERO(hwmon_dev);\r\n}
