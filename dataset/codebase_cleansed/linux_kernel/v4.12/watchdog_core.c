static int watchdog_deferred_registration_add(struct watchdog_device *wdd)\r\n{\r\nlist_add_tail(&wdd->deferred,\r\n&wtd_deferred_reg_list);\r\nreturn 0;\r\n}\r\nstatic void watchdog_deferred_registration_del(struct watchdog_device *wdd)\r\n{\r\nstruct list_head *p, *n;\r\nstruct watchdog_device *wdd_tmp;\r\nlist_for_each_safe(p, n, &wtd_deferred_reg_list) {\r\nwdd_tmp = list_entry(p, struct watchdog_device,\r\ndeferred);\r\nif (wdd_tmp == wdd) {\r\nlist_del(&wdd_tmp->deferred);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void watchdog_check_min_max_timeout(struct watchdog_device *wdd)\r\n{\r\nif (!wdd->max_hw_heartbeat_ms && wdd->min_timeout > wdd->max_timeout) {\r\npr_info("Invalid min and max timeout values, resetting to 0!\n");\r\nwdd->min_timeout = 0;\r\nwdd->max_timeout = 0;\r\n}\r\n}\r\nint watchdog_init_timeout(struct watchdog_device *wdd,\r\nunsigned int timeout_parm, struct device *dev)\r\n{\r\nunsigned int t = 0;\r\nint ret = 0;\r\nwatchdog_check_min_max_timeout(wdd);\r\nif (!watchdog_timeout_invalid(wdd, timeout_parm) && timeout_parm) {\r\nwdd->timeout = timeout_parm;\r\nreturn ret;\r\n}\r\nif (timeout_parm)\r\nret = -EINVAL;\r\nif (dev == NULL || dev->of_node == NULL)\r\nreturn ret;\r\nof_property_read_u32(dev->of_node, "timeout-sec", &t);\r\nif (!watchdog_timeout_invalid(wdd, t) && t)\r\nwdd->timeout = t;\r\nelse\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int watchdog_reboot_notifier(struct notifier_block *nb,\r\nunsigned long code, void *data)\r\n{\r\nstruct watchdog_device *wdd = container_of(nb, struct watchdog_device,\r\nreboot_nb);\r\nif (code == SYS_DOWN || code == SYS_HALT) {\r\nif (watchdog_active(wdd)) {\r\nint ret;\r\nret = wdd->ops->stop(wdd);\r\nif (ret)\r\nreturn NOTIFY_BAD;\r\n}\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int watchdog_restart_notifier(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nstruct watchdog_device *wdd = container_of(nb, struct watchdog_device,\r\nrestart_nb);\r\nint ret;\r\nret = wdd->ops->restart(wdd, action, data);\r\nif (ret)\r\nreturn NOTIFY_BAD;\r\nreturn NOTIFY_DONE;\r\n}\r\nvoid watchdog_set_restart_priority(struct watchdog_device *wdd, int priority)\r\n{\r\nwdd->restart_nb.priority = priority;\r\n}\r\nstatic int __watchdog_register_device(struct watchdog_device *wdd)\r\n{\r\nint ret, id = -1;\r\nif (wdd == NULL || wdd->info == NULL || wdd->ops == NULL)\r\nreturn -EINVAL;\r\nif (!wdd->ops->start || (!wdd->ops->stop && !wdd->max_hw_heartbeat_ms))\r\nreturn -EINVAL;\r\nwatchdog_check_min_max_timeout(wdd);\r\nif (wdd->parent) {\r\nret = of_alias_get_id(wdd->parent->of_node, "watchdog");\r\nif (ret >= 0)\r\nid = ida_simple_get(&watchdog_ida, ret,\r\nret + 1, GFP_KERNEL);\r\n}\r\nif (id < 0)\r\nid = ida_simple_get(&watchdog_ida, 0, MAX_DOGS, GFP_KERNEL);\r\nif (id < 0)\r\nreturn id;\r\nwdd->id = id;\r\nret = watchdog_dev_register(wdd);\r\nif (ret) {\r\nida_simple_remove(&watchdog_ida, id);\r\nif (!(id == 0 && ret == -EBUSY))\r\nreturn ret;\r\nid = ida_simple_get(&watchdog_ida, 1, MAX_DOGS, GFP_KERNEL);\r\nif (id < 0)\r\nreturn id;\r\nwdd->id = id;\r\nret = watchdog_dev_register(wdd);\r\nif (ret) {\r\nida_simple_remove(&watchdog_ida, id);\r\nreturn ret;\r\n}\r\n}\r\nif (test_bit(WDOG_STOP_ON_REBOOT, &wdd->status)) {\r\nwdd->reboot_nb.notifier_call = watchdog_reboot_notifier;\r\nret = register_reboot_notifier(&wdd->reboot_nb);\r\nif (ret) {\r\npr_err("watchdog%d: Cannot register reboot notifier (%d)\n",\r\nwdd->id, ret);\r\nwatchdog_dev_unregister(wdd);\r\nida_simple_remove(&watchdog_ida, wdd->id);\r\nreturn ret;\r\n}\r\n}\r\nif (wdd->ops->restart) {\r\nwdd->restart_nb.notifier_call = watchdog_restart_notifier;\r\nret = register_restart_handler(&wdd->restart_nb);\r\nif (ret)\r\npr_warn("watchdog%d: Cannot register restart handler (%d)\n",\r\nwdd->id, ret);\r\n}\r\nreturn 0;\r\n}\r\nint watchdog_register_device(struct watchdog_device *wdd)\r\n{\r\nint ret;\r\nmutex_lock(&wtd_deferred_reg_mutex);\r\nif (wtd_deferred_reg_done)\r\nret = __watchdog_register_device(wdd);\r\nelse\r\nret = watchdog_deferred_registration_add(wdd);\r\nmutex_unlock(&wtd_deferred_reg_mutex);\r\nreturn ret;\r\n}\r\nstatic void __watchdog_unregister_device(struct watchdog_device *wdd)\r\n{\r\nif (wdd == NULL)\r\nreturn;\r\nif (wdd->ops->restart)\r\nunregister_restart_handler(&wdd->restart_nb);\r\nif (test_bit(WDOG_STOP_ON_REBOOT, &wdd->status))\r\nunregister_reboot_notifier(&wdd->reboot_nb);\r\nwatchdog_dev_unregister(wdd);\r\nida_simple_remove(&watchdog_ida, wdd->id);\r\n}\r\nvoid watchdog_unregister_device(struct watchdog_device *wdd)\r\n{\r\nmutex_lock(&wtd_deferred_reg_mutex);\r\nif (wtd_deferred_reg_done)\r\n__watchdog_unregister_device(wdd);\r\nelse\r\nwatchdog_deferred_registration_del(wdd);\r\nmutex_unlock(&wtd_deferred_reg_mutex);\r\n}\r\nstatic void devm_watchdog_unregister_device(struct device *dev, void *res)\r\n{\r\nwatchdog_unregister_device(*(struct watchdog_device **)res);\r\n}\r\nint devm_watchdog_register_device(struct device *dev,\r\nstruct watchdog_device *wdd)\r\n{\r\nstruct watchdog_device **rcwdd;\r\nint ret;\r\nrcwdd = devres_alloc(devm_watchdog_unregister_device, sizeof(*rcwdd),\r\nGFP_KERNEL);\r\nif (!rcwdd)\r\nreturn -ENOMEM;\r\nret = watchdog_register_device(wdd);\r\nif (!ret) {\r\n*rcwdd = wdd;\r\ndevres_add(dev, rcwdd);\r\n} else {\r\ndevres_free(rcwdd);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init watchdog_deferred_registration(void)\r\n{\r\nmutex_lock(&wtd_deferred_reg_mutex);\r\nwtd_deferred_reg_done = true;\r\nwhile (!list_empty(&wtd_deferred_reg_list)) {\r\nstruct watchdog_device *wdd;\r\nwdd = list_first_entry(&wtd_deferred_reg_list,\r\nstruct watchdog_device, deferred);\r\nlist_del(&wdd->deferred);\r\n__watchdog_register_device(wdd);\r\n}\r\nmutex_unlock(&wtd_deferred_reg_mutex);\r\nreturn 0;\r\n}\r\nstatic int __init watchdog_init(void)\r\n{\r\nint err;\r\nerr = watchdog_dev_init();\r\nif (err < 0)\r\nreturn err;\r\nwatchdog_deferred_registration();\r\nreturn 0;\r\n}\r\nstatic void __exit watchdog_exit(void)\r\n{\r\nwatchdog_dev_exit();\r\nida_destroy(&watchdog_ida);\r\n}
