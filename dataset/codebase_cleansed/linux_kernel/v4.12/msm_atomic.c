static int start_atomic(struct msm_drm_private *priv, uint32_t crtc_mask)\r\n{\r\nint ret;\r\nspin_lock(&priv->pending_crtcs_event.lock);\r\nret = wait_event_interruptible_locked(priv->pending_crtcs_event,\r\n!(priv->pending_crtcs & crtc_mask));\r\nif (ret == 0) {\r\nDBG("start: %08x", crtc_mask);\r\npriv->pending_crtcs |= crtc_mask;\r\n}\r\nspin_unlock(&priv->pending_crtcs_event.lock);\r\nreturn ret;\r\n}\r\nstatic void end_atomic(struct msm_drm_private *priv, uint32_t crtc_mask)\r\n{\r\nspin_lock(&priv->pending_crtcs_event.lock);\r\nDBG("end: %08x", crtc_mask);\r\npriv->pending_crtcs &= ~crtc_mask;\r\nwake_up_all_locked(&priv->pending_crtcs_event);\r\nspin_unlock(&priv->pending_crtcs_event.lock);\r\n}\r\nstatic struct msm_commit *commit_init(struct drm_atomic_state *state)\r\n{\r\nstruct msm_commit *c = kzalloc(sizeof(*c), GFP_KERNEL);\r\nif (!c)\r\nreturn NULL;\r\nc->dev = state->dev;\r\nc->state = state;\r\nINIT_WORK(&c->work, commit_worker);\r\nreturn c;\r\n}\r\nstatic void commit_destroy(struct msm_commit *c)\r\n{\r\nend_atomic(c->dev->dev_private, c->crtc_mask);\r\nkfree(c);\r\n}\r\nstatic void msm_atomic_wait_for_commit_done(struct drm_device *dev,\r\nstruct drm_atomic_state *old_state)\r\n{\r\nstruct drm_crtc *crtc;\r\nstruct drm_crtc_state *crtc_state;\r\nstruct msm_drm_private *priv = old_state->dev->dev_private;\r\nstruct msm_kms *kms = priv->kms;\r\nint i;\r\nfor_each_crtc_in_state(old_state, crtc, crtc_state, i) {\r\nif (!crtc->state->enable)\r\ncontinue;\r\nkms->funcs->wait_for_crtc_commit_done(kms, crtc);\r\n}\r\n}\r\nstatic void complete_commit(struct msm_commit *c, bool async)\r\n{\r\nstruct drm_atomic_state *state = c->state;\r\nstruct drm_device *dev = state->dev;\r\nstruct msm_drm_private *priv = dev->dev_private;\r\nstruct msm_kms *kms = priv->kms;\r\ndrm_atomic_helper_wait_for_fences(dev, state, false);\r\nkms->funcs->prepare_commit(kms, state);\r\ndrm_atomic_helper_commit_modeset_disables(dev, state);\r\ndrm_atomic_helper_commit_planes(dev, state, 0);\r\ndrm_atomic_helper_commit_modeset_enables(dev, state);\r\nmsm_atomic_wait_for_commit_done(dev, state);\r\ndrm_atomic_helper_cleanup_planes(dev, state);\r\nkms->funcs->complete_commit(kms, state);\r\ndrm_atomic_state_put(state);\r\ncommit_destroy(c);\r\n}\r\nstatic void commit_worker(struct work_struct *work)\r\n{\r\ncomplete_commit(container_of(work, struct msm_commit, work), true);\r\n}\r\nint msm_atomic_check(struct drm_device *dev,\r\nstruct drm_atomic_state *state)\r\n{\r\nint ret;\r\nret = drm_atomic_helper_check_modeset(dev, state);\r\nif (ret)\r\nreturn ret;\r\nret = drm_atomic_helper_check_planes(dev, state);\r\nif (ret)\r\nreturn ret;\r\nreturn ret;\r\n}\r\nint msm_atomic_commit(struct drm_device *dev,\r\nstruct drm_atomic_state *state, bool nonblock)\r\n{\r\nstruct msm_drm_private *priv = dev->dev_private;\r\nstruct msm_commit *c;\r\nstruct drm_crtc *crtc;\r\nstruct drm_crtc_state *crtc_state;\r\nstruct drm_plane *plane;\r\nstruct drm_plane_state *plane_state;\r\nint i, ret;\r\nret = drm_atomic_helper_prepare_planes(dev, state);\r\nif (ret)\r\nreturn ret;\r\nc = commit_init(state);\r\nif (!c) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nfor_each_crtc_in_state(state, crtc, crtc_state, i)\r\nc->crtc_mask |= drm_crtc_mask(crtc);\r\nfor_each_plane_in_state(state, plane, plane_state, i) {\r\nif ((plane->state->fb != plane_state->fb) && plane_state->fb) {\r\nstruct drm_gem_object *obj = msm_framebuffer_bo(plane_state->fb, 0);\r\nstruct msm_gem_object *msm_obj = to_msm_bo(obj);\r\nstruct dma_fence *fence = reservation_object_get_excl_rcu(msm_obj->resv);\r\ndrm_atomic_set_fence_for_plane(plane_state, fence);\r\n}\r\n}\r\nret = start_atomic(dev->dev_private, c->crtc_mask);\r\nif (ret) {\r\nkfree(c);\r\ngoto error;\r\n}\r\ndrm_atomic_helper_swap_state(state, true);\r\nif (to_kms_state(state)->state)\r\npriv->kms->funcs->swap_state(priv->kms, state);\r\ndrm_atomic_state_get(state);\r\nif (nonblock) {\r\nqueue_work(priv->atomic_wq, &c->work);\r\nreturn 0;\r\n}\r\ncomplete_commit(c, false);\r\nreturn 0;\r\nerror:\r\ndrm_atomic_helper_cleanup_planes(dev, state);\r\nreturn ret;\r\n}\r\nstruct drm_atomic_state *msm_atomic_state_alloc(struct drm_device *dev)\r\n{\r\nstruct msm_kms_state *state = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (!state || drm_atomic_state_init(dev, &state->base) < 0) {\r\nkfree(state);\r\nreturn NULL;\r\n}\r\nreturn &state->base;\r\n}\r\nvoid msm_atomic_state_clear(struct drm_atomic_state *s)\r\n{\r\nstruct msm_kms_state *state = to_kms_state(s);\r\ndrm_atomic_state_default_clear(&state->base);\r\nkfree(state->state);\r\nstate->state = NULL;\r\n}\r\nvoid msm_atomic_state_free(struct drm_atomic_state *state)\r\n{\r\nkfree(to_kms_state(state)->state);\r\ndrm_atomic_state_default_release(state);\r\nkfree(state);\r\n}
