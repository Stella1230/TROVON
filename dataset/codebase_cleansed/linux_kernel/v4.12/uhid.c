static void uhid_device_add_worker(struct work_struct *work)\r\n{\r\nstruct uhid_device *uhid = container_of(work, struct uhid_device, worker);\r\nint ret;\r\nret = hid_add_device(uhid->hid);\r\nif (ret) {\r\nhid_err(uhid->hid, "Cannot register HID device: error %d\n", ret);\r\nhid_destroy_device(uhid->hid);\r\nuhid->hid = NULL;\r\nuhid->running = false;\r\n}\r\n}\r\nstatic void uhid_queue(struct uhid_device *uhid, struct uhid_event *ev)\r\n{\r\n__u8 newhead;\r\nnewhead = (uhid->head + 1) % UHID_BUFSIZE;\r\nif (newhead != uhid->tail) {\r\nuhid->outq[uhid->head] = ev;\r\nuhid->head = newhead;\r\nwake_up_interruptible(&uhid->waitq);\r\n} else {\r\nhid_warn(uhid->hid, "Output queue is full\n");\r\nkfree(ev);\r\n}\r\n}\r\nstatic int uhid_queue_event(struct uhid_device *uhid, __u32 event)\r\n{\r\nunsigned long flags;\r\nstruct uhid_event *ev;\r\nev = kzalloc(sizeof(*ev), GFP_KERNEL);\r\nif (!ev)\r\nreturn -ENOMEM;\r\nev->type = event;\r\nspin_lock_irqsave(&uhid->qlock, flags);\r\nuhid_queue(uhid, ev);\r\nspin_unlock_irqrestore(&uhid->qlock, flags);\r\nreturn 0;\r\n}\r\nstatic int uhid_hid_start(struct hid_device *hid)\r\n{\r\nstruct uhid_device *uhid = hid->driver_data;\r\nstruct uhid_event *ev;\r\nunsigned long flags;\r\nev = kzalloc(sizeof(*ev), GFP_KERNEL);\r\nif (!ev)\r\nreturn -ENOMEM;\r\nev->type = UHID_START;\r\nif (hid->report_enum[HID_FEATURE_REPORT].numbered)\r\nev->u.start.dev_flags |= UHID_DEV_NUMBERED_FEATURE_REPORTS;\r\nif (hid->report_enum[HID_OUTPUT_REPORT].numbered)\r\nev->u.start.dev_flags |= UHID_DEV_NUMBERED_OUTPUT_REPORTS;\r\nif (hid->report_enum[HID_INPUT_REPORT].numbered)\r\nev->u.start.dev_flags |= UHID_DEV_NUMBERED_INPUT_REPORTS;\r\nspin_lock_irqsave(&uhid->qlock, flags);\r\nuhid_queue(uhid, ev);\r\nspin_unlock_irqrestore(&uhid->qlock, flags);\r\nreturn 0;\r\n}\r\nstatic void uhid_hid_stop(struct hid_device *hid)\r\n{\r\nstruct uhid_device *uhid = hid->driver_data;\r\nhid->claimed = 0;\r\nuhid_queue_event(uhid, UHID_STOP);\r\n}\r\nstatic int uhid_hid_open(struct hid_device *hid)\r\n{\r\nstruct uhid_device *uhid = hid->driver_data;\r\nreturn uhid_queue_event(uhid, UHID_OPEN);\r\n}\r\nstatic void uhid_hid_close(struct hid_device *hid)\r\n{\r\nstruct uhid_device *uhid = hid->driver_data;\r\nuhid_queue_event(uhid, UHID_CLOSE);\r\n}\r\nstatic int uhid_hid_parse(struct hid_device *hid)\r\n{\r\nstruct uhid_device *uhid = hid->driver_data;\r\nreturn hid_parse_report(hid, uhid->rd_data, uhid->rd_size);\r\n}\r\nstatic int __uhid_report_queue_and_wait(struct uhid_device *uhid,\r\nstruct uhid_event *ev,\r\n__u32 *report_id)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&uhid->qlock, flags);\r\n*report_id = ++uhid->report_id;\r\nuhid->report_type = ev->type + 1;\r\nuhid->report_running = true;\r\nuhid_queue(uhid, ev);\r\nspin_unlock_irqrestore(&uhid->qlock, flags);\r\nret = wait_event_interruptible_timeout(uhid->report_wait,\r\n!uhid->report_running || !uhid->running,\r\n5 * HZ);\r\nif (!ret || !uhid->running || uhid->report_running)\r\nret = -EIO;\r\nelse if (ret < 0)\r\nret = -ERESTARTSYS;\r\nelse\r\nret = 0;\r\nuhid->report_running = false;\r\nreturn ret;\r\n}\r\nstatic void uhid_report_wake_up(struct uhid_device *uhid, u32 id,\r\nconst struct uhid_event *ev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&uhid->qlock, flags);\r\nif (uhid->report_type != ev->type || uhid->report_id != id)\r\ngoto unlock;\r\nif (!uhid->report_running)\r\ngoto unlock;\r\nmemcpy(&uhid->report_buf, ev, sizeof(*ev));\r\nuhid->report_running = false;\r\nwake_up_interruptible(&uhid->report_wait);\r\nunlock:\r\nspin_unlock_irqrestore(&uhid->qlock, flags);\r\n}\r\nstatic int uhid_hid_get_report(struct hid_device *hid, unsigned char rnum,\r\nu8 *buf, size_t count, u8 rtype)\r\n{\r\nstruct uhid_device *uhid = hid->driver_data;\r\nstruct uhid_get_report_reply_req *req;\r\nstruct uhid_event *ev;\r\nint ret;\r\nif (!uhid->running)\r\nreturn -EIO;\r\nev = kzalloc(sizeof(*ev), GFP_KERNEL);\r\nif (!ev)\r\nreturn -ENOMEM;\r\nev->type = UHID_GET_REPORT;\r\nev->u.get_report.rnum = rnum;\r\nev->u.get_report.rtype = rtype;\r\nret = mutex_lock_interruptible(&uhid->report_lock);\r\nif (ret) {\r\nkfree(ev);\r\nreturn ret;\r\n}\r\nret = __uhid_report_queue_and_wait(uhid, ev, &ev->u.get_report.id);\r\nif (ret)\r\ngoto unlock;\r\nreq = &uhid->report_buf.u.get_report_reply;\r\nif (req->err) {\r\nret = -EIO;\r\n} else {\r\nret = min3(count, (size_t)req->size, (size_t)UHID_DATA_MAX);\r\nmemcpy(buf, req->data, ret);\r\n}\r\nunlock:\r\nmutex_unlock(&uhid->report_lock);\r\nreturn ret;\r\n}\r\nstatic int uhid_hid_set_report(struct hid_device *hid, unsigned char rnum,\r\nconst u8 *buf, size_t count, u8 rtype)\r\n{\r\nstruct uhid_device *uhid = hid->driver_data;\r\nstruct uhid_event *ev;\r\nint ret;\r\nif (!uhid->running || count > UHID_DATA_MAX)\r\nreturn -EIO;\r\nev = kzalloc(sizeof(*ev), GFP_KERNEL);\r\nif (!ev)\r\nreturn -ENOMEM;\r\nev->type = UHID_SET_REPORT;\r\nev->u.set_report.rnum = rnum;\r\nev->u.set_report.rtype = rtype;\r\nev->u.set_report.size = count;\r\nmemcpy(ev->u.set_report.data, buf, count);\r\nret = mutex_lock_interruptible(&uhid->report_lock);\r\nif (ret) {\r\nkfree(ev);\r\nreturn ret;\r\n}\r\nret = __uhid_report_queue_and_wait(uhid, ev, &ev->u.set_report.id);\r\nif (ret)\r\ngoto unlock;\r\nif (uhid->report_buf.u.set_report_reply.err)\r\nret = -EIO;\r\nelse\r\nret = count;\r\nunlock:\r\nmutex_unlock(&uhid->report_lock);\r\nreturn ret;\r\n}\r\nstatic int uhid_hid_raw_request(struct hid_device *hid, unsigned char reportnum,\r\n__u8 *buf, size_t len, unsigned char rtype,\r\nint reqtype)\r\n{\r\nu8 u_rtype;\r\nswitch (rtype) {\r\ncase HID_FEATURE_REPORT:\r\nu_rtype = UHID_FEATURE_REPORT;\r\nbreak;\r\ncase HID_OUTPUT_REPORT:\r\nu_rtype = UHID_OUTPUT_REPORT;\r\nbreak;\r\ncase HID_INPUT_REPORT:\r\nu_rtype = UHID_INPUT_REPORT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (reqtype) {\r\ncase HID_REQ_GET_REPORT:\r\nreturn uhid_hid_get_report(hid, reportnum, buf, len, u_rtype);\r\ncase HID_REQ_SET_REPORT:\r\nreturn uhid_hid_set_report(hid, reportnum, buf, len, u_rtype);\r\ndefault:\r\nreturn -EIO;\r\n}\r\n}\r\nstatic int uhid_hid_output_raw(struct hid_device *hid, __u8 *buf, size_t count,\r\nunsigned char report_type)\r\n{\r\nstruct uhid_device *uhid = hid->driver_data;\r\n__u8 rtype;\r\nunsigned long flags;\r\nstruct uhid_event *ev;\r\nswitch (report_type) {\r\ncase HID_FEATURE_REPORT:\r\nrtype = UHID_FEATURE_REPORT;\r\nbreak;\r\ncase HID_OUTPUT_REPORT:\r\nrtype = UHID_OUTPUT_REPORT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (count < 1 || count > UHID_DATA_MAX)\r\nreturn -EINVAL;\r\nev = kzalloc(sizeof(*ev), GFP_KERNEL);\r\nif (!ev)\r\nreturn -ENOMEM;\r\nev->type = UHID_OUTPUT;\r\nev->u.output.size = count;\r\nev->u.output.rtype = rtype;\r\nmemcpy(ev->u.output.data, buf, count);\r\nspin_lock_irqsave(&uhid->qlock, flags);\r\nuhid_queue(uhid, ev);\r\nspin_unlock_irqrestore(&uhid->qlock, flags);\r\nreturn count;\r\n}\r\nstatic int uhid_hid_output_report(struct hid_device *hid, __u8 *buf,\r\nsize_t count)\r\n{\r\nreturn uhid_hid_output_raw(hid, buf, count, HID_OUTPUT_REPORT);\r\n}\r\nstatic int uhid_event_from_user(const char __user *buffer, size_t len,\r\nstruct uhid_event *event)\r\n{\r\nif (in_compat_syscall()) {\r\nu32 type;\r\nif (get_user(type, buffer))\r\nreturn -EFAULT;\r\nif (type == UHID_CREATE) {\r\nstruct uhid_create_req_compat *compat;\r\ncompat = kzalloc(sizeof(*compat), GFP_KERNEL);\r\nif (!compat)\r\nreturn -ENOMEM;\r\nbuffer += sizeof(type);\r\nlen -= sizeof(type);\r\nif (copy_from_user(compat, buffer,\r\nmin(len, sizeof(*compat)))) {\r\nkfree(compat);\r\nreturn -EFAULT;\r\n}\r\nevent->type = type;\r\nmemcpy(event->u.create.name, compat->name,\r\nsizeof(compat->name));\r\nmemcpy(event->u.create.phys, compat->phys,\r\nsizeof(compat->phys));\r\nmemcpy(event->u.create.uniq, compat->uniq,\r\nsizeof(compat->uniq));\r\nevent->u.create.rd_data = compat_ptr(compat->rd_data);\r\nevent->u.create.rd_size = compat->rd_size;\r\nevent->u.create.bus = compat->bus;\r\nevent->u.create.vendor = compat->vendor;\r\nevent->u.create.product = compat->product;\r\nevent->u.create.version = compat->version;\r\nevent->u.create.country = compat->country;\r\nkfree(compat);\r\nreturn 0;\r\n}\r\n}\r\nif (copy_from_user(event, buffer, min(len, sizeof(*event))))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int uhid_event_from_user(const char __user *buffer, size_t len,\r\nstruct uhid_event *event)\r\n{\r\nif (copy_from_user(event, buffer, min(len, sizeof(*event))))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int uhid_dev_create2(struct uhid_device *uhid,\r\nconst struct uhid_event *ev)\r\n{\r\nstruct hid_device *hid;\r\nsize_t rd_size, len;\r\nvoid *rd_data;\r\nint ret;\r\nif (uhid->running)\r\nreturn -EALREADY;\r\nrd_size = ev->u.create2.rd_size;\r\nif (rd_size <= 0 || rd_size > HID_MAX_DESCRIPTOR_SIZE)\r\nreturn -EINVAL;\r\nrd_data = kmemdup(ev->u.create2.rd_data, rd_size, GFP_KERNEL);\r\nif (!rd_data)\r\nreturn -ENOMEM;\r\nuhid->rd_size = rd_size;\r\nuhid->rd_data = rd_data;\r\nhid = hid_allocate_device();\r\nif (IS_ERR(hid)) {\r\nret = PTR_ERR(hid);\r\ngoto err_free;\r\n}\r\nlen = min(sizeof(hid->name), sizeof(ev->u.create2.name)) - 1;\r\nstrncpy(hid->name, ev->u.create2.name, len);\r\nlen = min(sizeof(hid->phys), sizeof(ev->u.create2.phys)) - 1;\r\nstrncpy(hid->phys, ev->u.create2.phys, len);\r\nlen = min(sizeof(hid->uniq), sizeof(ev->u.create2.uniq)) - 1;\r\nstrncpy(hid->uniq, ev->u.create2.uniq, len);\r\nhid->ll_driver = &uhid_hid_driver;\r\nhid->bus = ev->u.create2.bus;\r\nhid->vendor = ev->u.create2.vendor;\r\nhid->product = ev->u.create2.product;\r\nhid->version = ev->u.create2.version;\r\nhid->country = ev->u.create2.country;\r\nhid->driver_data = uhid;\r\nhid->dev.parent = uhid_misc.this_device;\r\nuhid->hid = hid;\r\nuhid->running = true;\r\nschedule_work(&uhid->worker);\r\nreturn 0;\r\nerr_free:\r\nkfree(uhid->rd_data);\r\nuhid->rd_data = NULL;\r\nuhid->rd_size = 0;\r\nreturn ret;\r\n}\r\nstatic int uhid_dev_create(struct uhid_device *uhid,\r\nstruct uhid_event *ev)\r\n{\r\nstruct uhid_create_req orig;\r\norig = ev->u.create;\r\nif (orig.rd_size <= 0 || orig.rd_size > HID_MAX_DESCRIPTOR_SIZE)\r\nreturn -EINVAL;\r\nif (copy_from_user(&ev->u.create2.rd_data, orig.rd_data, orig.rd_size))\r\nreturn -EFAULT;\r\nmemcpy(ev->u.create2.name, orig.name, sizeof(orig.name));\r\nmemcpy(ev->u.create2.phys, orig.phys, sizeof(orig.phys));\r\nmemcpy(ev->u.create2.uniq, orig.uniq, sizeof(orig.uniq));\r\nev->u.create2.rd_size = orig.rd_size;\r\nev->u.create2.bus = orig.bus;\r\nev->u.create2.vendor = orig.vendor;\r\nev->u.create2.product = orig.product;\r\nev->u.create2.version = orig.version;\r\nev->u.create2.country = orig.country;\r\nreturn uhid_dev_create2(uhid, ev);\r\n}\r\nstatic int uhid_dev_destroy(struct uhid_device *uhid)\r\n{\r\nif (!uhid->running)\r\nreturn -EINVAL;\r\nuhid->running = false;\r\nwake_up_interruptible(&uhid->report_wait);\r\ncancel_work_sync(&uhid->worker);\r\nhid_destroy_device(uhid->hid);\r\nkfree(uhid->rd_data);\r\nreturn 0;\r\n}\r\nstatic int uhid_dev_input(struct uhid_device *uhid, struct uhid_event *ev)\r\n{\r\nif (!uhid->running)\r\nreturn -EINVAL;\r\nhid_input_report(uhid->hid, HID_INPUT_REPORT, ev->u.input.data,\r\nmin_t(size_t, ev->u.input.size, UHID_DATA_MAX), 0);\r\nreturn 0;\r\n}\r\nstatic int uhid_dev_input2(struct uhid_device *uhid, struct uhid_event *ev)\r\n{\r\nif (!uhid->running)\r\nreturn -EINVAL;\r\nhid_input_report(uhid->hid, HID_INPUT_REPORT, ev->u.input2.data,\r\nmin_t(size_t, ev->u.input2.size, UHID_DATA_MAX), 0);\r\nreturn 0;\r\n}\r\nstatic int uhid_dev_get_report_reply(struct uhid_device *uhid,\r\nstruct uhid_event *ev)\r\n{\r\nif (!uhid->running)\r\nreturn -EINVAL;\r\nuhid_report_wake_up(uhid, ev->u.get_report_reply.id, ev);\r\nreturn 0;\r\n}\r\nstatic int uhid_dev_set_report_reply(struct uhid_device *uhid,\r\nstruct uhid_event *ev)\r\n{\r\nif (!uhid->running)\r\nreturn -EINVAL;\r\nuhid_report_wake_up(uhid, ev->u.set_report_reply.id, ev);\r\nreturn 0;\r\n}\r\nstatic int uhid_char_open(struct inode *inode, struct file *file)\r\n{\r\nstruct uhid_device *uhid;\r\nuhid = kzalloc(sizeof(*uhid), GFP_KERNEL);\r\nif (!uhid)\r\nreturn -ENOMEM;\r\nmutex_init(&uhid->devlock);\r\nmutex_init(&uhid->report_lock);\r\nspin_lock_init(&uhid->qlock);\r\ninit_waitqueue_head(&uhid->waitq);\r\ninit_waitqueue_head(&uhid->report_wait);\r\nuhid->running = false;\r\nINIT_WORK(&uhid->worker, uhid_device_add_worker);\r\nfile->private_data = uhid;\r\nnonseekable_open(inode, file);\r\nreturn 0;\r\n}\r\nstatic int uhid_char_release(struct inode *inode, struct file *file)\r\n{\r\nstruct uhid_device *uhid = file->private_data;\r\nunsigned int i;\r\nuhid_dev_destroy(uhid);\r\nfor (i = 0; i < UHID_BUFSIZE; ++i)\r\nkfree(uhid->outq[i]);\r\nkfree(uhid);\r\nreturn 0;\r\n}\r\nstatic ssize_t uhid_char_read(struct file *file, char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct uhid_device *uhid = file->private_data;\r\nint ret;\r\nunsigned long flags;\r\nsize_t len;\r\nif (count < sizeof(__u32))\r\nreturn -EINVAL;\r\ntry_again:\r\nif (file->f_flags & O_NONBLOCK) {\r\nif (uhid->head == uhid->tail)\r\nreturn -EAGAIN;\r\n} else {\r\nret = wait_event_interruptible(uhid->waitq,\r\nuhid->head != uhid->tail);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = mutex_lock_interruptible(&uhid->devlock);\r\nif (ret)\r\nreturn ret;\r\nif (uhid->head == uhid->tail) {\r\nmutex_unlock(&uhid->devlock);\r\ngoto try_again;\r\n} else {\r\nlen = min(count, sizeof(**uhid->outq));\r\nif (copy_to_user(buffer, uhid->outq[uhid->tail], len)) {\r\nret = -EFAULT;\r\n} else {\r\nkfree(uhid->outq[uhid->tail]);\r\nuhid->outq[uhid->tail] = NULL;\r\nspin_lock_irqsave(&uhid->qlock, flags);\r\nuhid->tail = (uhid->tail + 1) % UHID_BUFSIZE;\r\nspin_unlock_irqrestore(&uhid->qlock, flags);\r\n}\r\n}\r\nmutex_unlock(&uhid->devlock);\r\nreturn ret ? ret : len;\r\n}\r\nstatic ssize_t uhid_char_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct uhid_device *uhid = file->private_data;\r\nint ret;\r\nsize_t len;\r\nif (count < sizeof(__u32))\r\nreturn -EINVAL;\r\nret = mutex_lock_interruptible(&uhid->devlock);\r\nif (ret)\r\nreturn ret;\r\nmemset(&uhid->input_buf, 0, sizeof(uhid->input_buf));\r\nlen = min(count, sizeof(uhid->input_buf));\r\nret = uhid_event_from_user(buffer, len, &uhid->input_buf);\r\nif (ret)\r\ngoto unlock;\r\nswitch (uhid->input_buf.type) {\r\ncase UHID_CREATE:\r\nret = uhid_dev_create(uhid, &uhid->input_buf);\r\nbreak;\r\ncase UHID_CREATE2:\r\nret = uhid_dev_create2(uhid, &uhid->input_buf);\r\nbreak;\r\ncase UHID_DESTROY:\r\nret = uhid_dev_destroy(uhid);\r\nbreak;\r\ncase UHID_INPUT:\r\nret = uhid_dev_input(uhid, &uhid->input_buf);\r\nbreak;\r\ncase UHID_INPUT2:\r\nret = uhid_dev_input2(uhid, &uhid->input_buf);\r\nbreak;\r\ncase UHID_GET_REPORT_REPLY:\r\nret = uhid_dev_get_report_reply(uhid, &uhid->input_buf);\r\nbreak;\r\ncase UHID_SET_REPORT_REPLY:\r\nret = uhid_dev_set_report_reply(uhid, &uhid->input_buf);\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\n}\r\nunlock:\r\nmutex_unlock(&uhid->devlock);\r\nreturn ret ? ret : count;\r\n}\r\nstatic unsigned int uhid_char_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct uhid_device *uhid = file->private_data;\r\npoll_wait(file, &uhid->waitq, wait);\r\nif (uhid->head != uhid->tail)\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}
