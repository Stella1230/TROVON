static int gb_hid_get_desc(struct gb_hid *ghid)\r\n{\r\nreturn gb_operation_sync(ghid->connection, GB_HID_TYPE_GET_DESC, NULL,\r\n0, &ghid->hdesc, sizeof(ghid->hdesc));\r\n}\r\nstatic int gb_hid_get_report_desc(struct gb_hid *ghid, char *rdesc)\r\n{\r\nint ret;\r\nret = gb_pm_runtime_get_sync(ghid->bundle);\r\nif (ret)\r\nreturn ret;\r\nret = gb_operation_sync(ghid->connection, GB_HID_TYPE_GET_REPORT_DESC,\r\nNULL, 0, rdesc,\r\nle16_to_cpu(ghid->hdesc.wReportDescLength));\r\ngb_pm_runtime_put_autosuspend(ghid->bundle);\r\nreturn ret;\r\n}\r\nstatic int gb_hid_set_power(struct gb_hid *ghid, int type)\r\n{\r\nint ret;\r\nret = gb_pm_runtime_get_sync(ghid->bundle);\r\nif (ret)\r\nreturn ret;\r\nret = gb_operation_sync(ghid->connection, type, NULL, 0, NULL, 0);\r\ngb_pm_runtime_put_autosuspend(ghid->bundle);\r\nreturn ret;\r\n}\r\nstatic int gb_hid_get_report(struct gb_hid *ghid, u8 report_type, u8 report_id,\r\nunsigned char *buf, int len)\r\n{\r\nstruct gb_hid_get_report_request request;\r\nint ret;\r\nret = gb_pm_runtime_get_sync(ghid->bundle);\r\nif (ret)\r\nreturn ret;\r\nrequest.report_type = report_type;\r\nrequest.report_id = report_id;\r\nret = gb_operation_sync(ghid->connection, GB_HID_TYPE_GET_REPORT,\r\n&request, sizeof(request), buf, len);\r\ngb_pm_runtime_put_autosuspend(ghid->bundle);\r\nreturn ret;\r\n}\r\nstatic int gb_hid_set_report(struct gb_hid *ghid, u8 report_type, u8 report_id,\r\nunsigned char *buf, int len)\r\n{\r\nstruct gb_hid_set_report_request *request;\r\nstruct gb_operation *operation;\r\nint ret, size = sizeof(*request) + len - 1;\r\nret = gb_pm_runtime_get_sync(ghid->bundle);\r\nif (ret)\r\nreturn ret;\r\noperation = gb_operation_create(ghid->connection,\r\nGB_HID_TYPE_SET_REPORT, size, 0,\r\nGFP_KERNEL);\r\nif (!operation) {\r\ngb_pm_runtime_put_autosuspend(ghid->bundle);\r\nreturn -ENOMEM;\r\n}\r\nrequest = operation->request->payload;\r\nrequest->report_type = report_type;\r\nrequest->report_id = report_id;\r\nmemcpy(request->report, buf, len);\r\nret = gb_operation_request_send_sync(operation);\r\nif (ret) {\r\ndev_err(&operation->connection->bundle->dev,\r\n"failed to set report: %d\n", ret);\r\n} else {\r\nret = len;\r\n}\r\ngb_operation_put(operation);\r\ngb_pm_runtime_put_autosuspend(ghid->bundle);\r\nreturn ret;\r\n}\r\nstatic int gb_hid_request_handler(struct gb_operation *op)\r\n{\r\nstruct gb_connection *connection = op->connection;\r\nstruct gb_hid *ghid = gb_connection_get_data(connection);\r\nstruct gb_hid_input_report_request *request = op->request->payload;\r\nif (op->type != GB_HID_TYPE_IRQ_EVENT) {\r\ndev_err(&connection->bundle->dev,\r\n"unsupported unsolicited request\n");\r\nreturn -EINVAL;\r\n}\r\nif (test_bit(GB_HID_STARTED, &ghid->flags))\r\nhid_input_report(ghid->hid, HID_INPUT_REPORT,\r\nrequest->report, op->request->payload_size, 1);\r\nreturn 0;\r\n}\r\nstatic int gb_hid_report_len(struct hid_report *report)\r\n{\r\nreturn ((report->size - 1) >> 3) + 1 +\r\nreport->device->report_enum[report->type].numbered;\r\n}\r\nstatic void gb_hid_find_max_report(struct hid_device *hid, unsigned int type,\r\nunsigned int *max)\r\n{\r\nstruct hid_report *report;\r\nunsigned int size;\r\nlist_for_each_entry(report, &hid->report_enum[type].report_list, list) {\r\nsize = gb_hid_report_len(report);\r\nif (*max < size)\r\n*max = size;\r\n}\r\n}\r\nstatic void gb_hid_free_buffers(struct gb_hid *ghid)\r\n{\r\nkfree(ghid->inbuf);\r\nghid->inbuf = NULL;\r\nghid->bufsize = 0;\r\n}\r\nstatic int gb_hid_alloc_buffers(struct gb_hid *ghid, size_t bufsize)\r\n{\r\nghid->inbuf = kzalloc(bufsize, GFP_KERNEL);\r\nif (!ghid->inbuf)\r\nreturn -ENOMEM;\r\nghid->bufsize = bufsize;\r\nreturn 0;\r\n}\r\nstatic void gb_hid_init_report(struct gb_hid *ghid, struct hid_report *report)\r\n{\r\nunsigned int size;\r\nsize = gb_hid_report_len(report);\r\nif (gb_hid_get_report(ghid, report->type, report->id, ghid->inbuf,\r\nsize))\r\nreturn;\r\nhid_report_raw_event(ghid->hid, report->type, ghid->inbuf, size, 1);\r\n}\r\nstatic void gb_hid_init_reports(struct gb_hid *ghid)\r\n{\r\nstruct hid_device *hid = ghid->hid;\r\nstruct hid_report *report;\r\nlist_for_each_entry(report,\r\n&hid->report_enum[HID_INPUT_REPORT].report_list, list)\r\ngb_hid_init_report(ghid, report);\r\nlist_for_each_entry(report,\r\n&hid->report_enum[HID_FEATURE_REPORT].report_list, list)\r\ngb_hid_init_report(ghid, report);\r\n}\r\nstatic int __gb_hid_get_raw_report(struct hid_device *hid,\r\nunsigned char report_number, __u8 *buf, size_t count,\r\nunsigned char report_type)\r\n{\r\nstruct gb_hid *ghid = hid->driver_data;\r\nint ret;\r\nif (report_type == HID_OUTPUT_REPORT)\r\nreturn -EINVAL;\r\nret = gb_hid_get_report(ghid, report_type, report_number, buf, count);\r\nif (!ret)\r\nret = count;\r\nreturn ret;\r\n}\r\nstatic int __gb_hid_output_raw_report(struct hid_device *hid, __u8 *buf,\r\nsize_t len, unsigned char report_type)\r\n{\r\nstruct gb_hid *ghid = hid->driver_data;\r\nint report_id = buf[0];\r\nint ret;\r\nif (report_type == HID_INPUT_REPORT)\r\nreturn -EINVAL;\r\nif (report_id) {\r\nbuf++;\r\nlen--;\r\n}\r\nret = gb_hid_set_report(ghid, report_type, report_id, buf, len);\r\nif (report_id && ret >= 0)\r\nret++;\r\nreturn 0;\r\n}\r\nstatic int gb_hid_raw_request(struct hid_device *hid, unsigned char reportnum,\r\n__u8 *buf, size_t len, unsigned char rtype,\r\nint reqtype)\r\n{\r\nswitch (reqtype) {\r\ncase HID_REQ_GET_REPORT:\r\nreturn __gb_hid_get_raw_report(hid, reportnum, buf, len, rtype);\r\ncase HID_REQ_SET_REPORT:\r\nif (buf[0] != reportnum)\r\nreturn -EINVAL;\r\nreturn __gb_hid_output_raw_report(hid, buf, len, rtype);\r\ndefault:\r\nreturn -EIO;\r\n}\r\n}\r\nstatic int gb_hid_parse(struct hid_device *hid)\r\n{\r\nstruct gb_hid *ghid = hid->driver_data;\r\nunsigned int rsize;\r\nchar *rdesc;\r\nint ret;\r\nrsize = le16_to_cpu(ghid->hdesc.wReportDescLength);\r\nif (!rsize || rsize > HID_MAX_DESCRIPTOR_SIZE) {\r\ndbg_hid("weird size of report descriptor (%u)\n", rsize);\r\nreturn -EINVAL;\r\n}\r\nrdesc = kzalloc(rsize, GFP_KERNEL);\r\nif (!rdesc) {\r\ndbg_hid("couldn't allocate rdesc memory\n");\r\nreturn -ENOMEM;\r\n}\r\nret = gb_hid_get_report_desc(ghid, rdesc);\r\nif (ret) {\r\nhid_err(hid, "reading report descriptor failed\n");\r\ngoto free_rdesc;\r\n}\r\nret = hid_parse_report(hid, rdesc, rsize);\r\nif (ret)\r\ndbg_hid("parsing report descriptor failed\n");\r\nfree_rdesc:\r\nkfree(rdesc);\r\nreturn ret;\r\n}\r\nstatic int gb_hid_start(struct hid_device *hid)\r\n{\r\nstruct gb_hid *ghid = hid->driver_data;\r\nunsigned int bufsize = HID_MIN_BUFFER_SIZE;\r\nint ret;\r\ngb_hid_find_max_report(hid, HID_INPUT_REPORT, &bufsize);\r\ngb_hid_find_max_report(hid, HID_OUTPUT_REPORT, &bufsize);\r\ngb_hid_find_max_report(hid, HID_FEATURE_REPORT, &bufsize);\r\nif (bufsize > HID_MAX_BUFFER_SIZE)\r\nbufsize = HID_MAX_BUFFER_SIZE;\r\nret = gb_hid_alloc_buffers(ghid, bufsize);\r\nif (ret)\r\nreturn ret;\r\nif (!(hid->quirks & HID_QUIRK_NO_INIT_REPORTS))\r\ngb_hid_init_reports(ghid);\r\nreturn 0;\r\n}\r\nstatic void gb_hid_stop(struct hid_device *hid)\r\n{\r\nstruct gb_hid *ghid = hid->driver_data;\r\ngb_hid_free_buffers(ghid);\r\n}\r\nstatic int gb_hid_open(struct hid_device *hid)\r\n{\r\nstruct gb_hid *ghid = hid->driver_data;\r\nint ret = 0;\r\nmutex_lock(&gb_hid_open_mutex);\r\nif (!hid->open++) {\r\nret = gb_hid_set_power(ghid, GB_HID_TYPE_PWR_ON);\r\nif (ret < 0)\r\nhid->open--;\r\nelse\r\nset_bit(GB_HID_STARTED, &ghid->flags);\r\n}\r\nmutex_unlock(&gb_hid_open_mutex);\r\nreturn ret;\r\n}\r\nstatic void gb_hid_close(struct hid_device *hid)\r\n{\r\nstruct gb_hid *ghid = hid->driver_data;\r\nint ret;\r\nmutex_lock(&gb_hid_open_mutex);\r\nif (!--hid->open) {\r\nclear_bit(GB_HID_STARTED, &ghid->flags);\r\nret = gb_hid_set_power(ghid, GB_HID_TYPE_PWR_OFF);\r\nif (ret)\r\ndev_err(&ghid->connection->bundle->dev,\r\n"failed to power off (%d)\n", ret);\r\n}\r\nmutex_unlock(&gb_hid_open_mutex);\r\n}\r\nstatic int gb_hid_power(struct hid_device *hid, int lvl)\r\n{\r\nstruct gb_hid *ghid = hid->driver_data;\r\nswitch (lvl) {\r\ncase PM_HINT_FULLON:\r\nreturn gb_hid_set_power(ghid, GB_HID_TYPE_PWR_ON);\r\ncase PM_HINT_NORMAL:\r\nreturn gb_hid_set_power(ghid, GB_HID_TYPE_PWR_OFF);\r\n}\r\nreturn 0;\r\n}\r\nstatic int gb_hid_init(struct gb_hid *ghid)\r\n{\r\nstruct hid_device *hid = ghid->hid;\r\nint ret;\r\nret = gb_hid_get_desc(ghid);\r\nif (ret)\r\nreturn ret;\r\nhid->version = le16_to_cpu(ghid->hdesc.bcdHID);\r\nhid->vendor = le16_to_cpu(ghid->hdesc.wVendorID);\r\nhid->product = le16_to_cpu(ghid->hdesc.wProductID);\r\nhid->country = ghid->hdesc.bCountryCode;\r\nhid->driver_data = ghid;\r\nhid->ll_driver = &gb_hid_ll_driver;\r\nhid->dev.parent = &ghid->connection->bundle->dev;\r\nsnprintf(hid->name, sizeof(hid->name), "%s %04X:%04X",\r\ndev_name(&ghid->connection->bundle->dev),\r\nhid->vendor, hid->product);\r\nreturn 0;\r\n}\r\nstatic int gb_hid_probe(struct gb_bundle *bundle,\r\nconst struct greybus_bundle_id *id)\r\n{\r\nstruct greybus_descriptor_cport *cport_desc;\r\nstruct gb_connection *connection;\r\nstruct hid_device *hid;\r\nstruct gb_hid *ghid;\r\nint ret;\r\nif (bundle->num_cports != 1)\r\nreturn -ENODEV;\r\ncport_desc = &bundle->cport_desc[0];\r\nif (cport_desc->protocol_id != GREYBUS_PROTOCOL_HID)\r\nreturn -ENODEV;\r\nghid = kzalloc(sizeof(*ghid), GFP_KERNEL);\r\nif (!ghid)\r\nreturn -ENOMEM;\r\nconnection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id),\r\ngb_hid_request_handler);\r\nif (IS_ERR(connection)) {\r\nret = PTR_ERR(connection);\r\ngoto err_free_ghid;\r\n}\r\ngb_connection_set_data(connection, ghid);\r\nghid->connection = connection;\r\nhid = hid_allocate_device();\r\nif (IS_ERR(hid)) {\r\nret = PTR_ERR(hid);\r\ngoto err_connection_destroy;\r\n}\r\nghid->hid = hid;\r\nghid->bundle = bundle;\r\ngreybus_set_drvdata(bundle, ghid);\r\nret = gb_connection_enable(connection);\r\nif (ret)\r\ngoto err_destroy_hid;\r\nret = gb_hid_init(ghid);\r\nif (ret)\r\ngoto err_connection_disable;\r\nret = hid_add_device(hid);\r\nif (ret) {\r\nhid_err(hid, "can't add hid device: %d\n", ret);\r\ngoto err_connection_disable;\r\n}\r\ngb_pm_runtime_put_autosuspend(bundle);\r\nreturn 0;\r\nerr_connection_disable:\r\ngb_connection_disable(connection);\r\nerr_destroy_hid:\r\nhid_destroy_device(hid);\r\nerr_connection_destroy:\r\ngb_connection_destroy(connection);\r\nerr_free_ghid:\r\nkfree(ghid);\r\nreturn ret;\r\n}\r\nstatic void gb_hid_disconnect(struct gb_bundle *bundle)\r\n{\r\nstruct gb_hid *ghid = greybus_get_drvdata(bundle);\r\nif (gb_pm_runtime_get_sync(bundle))\r\ngb_pm_runtime_get_noresume(bundle);\r\nhid_destroy_device(ghid->hid);\r\ngb_connection_disable(ghid->connection);\r\ngb_connection_destroy(ghid->connection);\r\nkfree(ghid);\r\n}
