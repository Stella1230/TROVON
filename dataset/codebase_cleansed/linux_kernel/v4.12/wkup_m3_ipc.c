static void am33xx_txev_eoi(struct wkup_m3_ipc *m3_ipc)\r\n{\r\nwritel(AM33XX_M3_TXEV_ACK,\r\nm3_ipc->ipc_mem_base + AM33XX_CONTROL_M3_TXEV_EOI);\r\n}\r\nstatic void am33xx_txev_enable(struct wkup_m3_ipc *m3_ipc)\r\n{\r\nwritel(AM33XX_M3_TXEV_ENABLE,\r\nm3_ipc->ipc_mem_base + AM33XX_CONTROL_M3_TXEV_EOI);\r\n}\r\nstatic void wkup_m3_ctrl_ipc_write(struct wkup_m3_ipc *m3_ipc,\r\nu32 val, int ipc_reg_num)\r\n{\r\nif (WARN(ipc_reg_num < 0 || ipc_reg_num > AM33XX_CTRL_IPC_REG_COUNT,\r\n"ipc register operation out of range"))\r\nreturn;\r\nwritel(val, m3_ipc->ipc_mem_base +\r\nAM33XX_CTRL_IPC_REG_OFFSET(ipc_reg_num));\r\n}\r\nstatic unsigned int wkup_m3_ctrl_ipc_read(struct wkup_m3_ipc *m3_ipc,\r\nint ipc_reg_num)\r\n{\r\nif (WARN(ipc_reg_num < 0 || ipc_reg_num > AM33XX_CTRL_IPC_REG_COUNT,\r\n"ipc register operation out of range"))\r\nreturn 0;\r\nreturn readl(m3_ipc->ipc_mem_base +\r\nAM33XX_CTRL_IPC_REG_OFFSET(ipc_reg_num));\r\n}\r\nstatic int wkup_m3_fw_version_read(struct wkup_m3_ipc *m3_ipc)\r\n{\r\nint val;\r\nval = wkup_m3_ctrl_ipc_read(m3_ipc, 2);\r\nreturn val & M3_FW_VERSION_MASK;\r\n}\r\nstatic irqreturn_t wkup_m3_txev_handler(int irq, void *ipc_data)\r\n{\r\nstruct wkup_m3_ipc *m3_ipc = ipc_data;\r\nstruct device *dev = m3_ipc->dev;\r\nint ver = 0;\r\nam33xx_txev_eoi(m3_ipc);\r\nswitch (m3_ipc->state) {\r\ncase M3_STATE_RESET:\r\nver = wkup_m3_fw_version_read(m3_ipc);\r\nif (ver == M3_VERSION_UNKNOWN ||\r\nver < M3_BASELINE_VERSION) {\r\ndev_warn(dev, "CM3 Firmware Version %x not supported\n",\r\nver);\r\n} else {\r\ndev_info(dev, "CM3 Firmware Version = 0x%x\n", ver);\r\n}\r\nm3_ipc->state = M3_STATE_INITED;\r\ncomplete(&m3_ipc->sync_complete);\r\nbreak;\r\ncase M3_STATE_MSG_FOR_RESET:\r\nm3_ipc->state = M3_STATE_INITED;\r\ncomplete(&m3_ipc->sync_complete);\r\nbreak;\r\ncase M3_STATE_MSG_FOR_LP:\r\ncomplete(&m3_ipc->sync_complete);\r\nbreak;\r\ncase M3_STATE_UNKNOWN:\r\ndev_warn(dev, "Unknown CM3 State\n");\r\n}\r\nam33xx_txev_enable(m3_ipc);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int wkup_m3_ping(struct wkup_m3_ipc *m3_ipc)\r\n{\r\nstruct device *dev = m3_ipc->dev;\r\nmbox_msg_t dummy_msg = 0;\r\nint ret;\r\nif (!m3_ipc->mbox) {\r\ndev_err(dev,\r\n"No IPC channel to communicate with wkup_m3!\n");\r\nreturn -EIO;\r\n}\r\nret = mbox_send_message(m3_ipc->mbox, &dummy_msg);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: mbox_send_message() failed: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nret = wait_for_completion_timeout(&m3_ipc->sync_complete,\r\nmsecs_to_jiffies(500));\r\nif (!ret) {\r\ndev_err(dev, "MPU<->CM3 sync failure\n");\r\nm3_ipc->state = M3_STATE_UNKNOWN;\r\nreturn -EIO;\r\n}\r\nmbox_client_txdone(m3_ipc->mbox, 0);\r\nreturn 0;\r\n}\r\nstatic int wkup_m3_ping_noirq(struct wkup_m3_ipc *m3_ipc)\r\n{\r\nstruct device *dev = m3_ipc->dev;\r\nmbox_msg_t dummy_msg = 0;\r\nint ret;\r\nif (!m3_ipc->mbox) {\r\ndev_err(dev,\r\n"No IPC channel to communicate with wkup_m3!\n");\r\nreturn -EIO;\r\n}\r\nret = mbox_send_message(m3_ipc->mbox, &dummy_msg);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: mbox_send_message() failed: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nmbox_client_txdone(m3_ipc->mbox, 0);\r\nreturn 0;\r\n}\r\nstatic int wkup_m3_is_available(struct wkup_m3_ipc *m3_ipc)\r\n{\r\nreturn ((m3_ipc->state != M3_STATE_RESET) &&\r\n(m3_ipc->state != M3_STATE_UNKNOWN));\r\n}\r\nstatic void wkup_m3_set_mem_type(struct wkup_m3_ipc *m3_ipc, int mem_type)\r\n{\r\nm3_ipc->mem_type = mem_type;\r\n}\r\nstatic void wkup_m3_set_resume_address(struct wkup_m3_ipc *m3_ipc, void *addr)\r\n{\r\nm3_ipc->resume_addr = (unsigned long)addr;\r\n}\r\nstatic int wkup_m3_request_pm_status(struct wkup_m3_ipc *m3_ipc)\r\n{\r\nunsigned int i;\r\nint val;\r\nval = wkup_m3_ctrl_ipc_read(m3_ipc, 1);\r\ni = M3_STATUS_RESP_MASK & val;\r\ni >>= __ffs(M3_STATUS_RESP_MASK);\r\nreturn i;\r\n}\r\nstatic int wkup_m3_prepare_low_power(struct wkup_m3_ipc *m3_ipc, int state)\r\n{\r\nstruct device *dev = m3_ipc->dev;\r\nint m3_power_state;\r\nint ret = 0;\r\nif (!wkup_m3_is_available(m3_ipc))\r\nreturn -ENODEV;\r\nswitch (state) {\r\ncase WKUP_M3_DEEPSLEEP:\r\nm3_power_state = IPC_CMD_DS0;\r\nbreak;\r\ncase WKUP_M3_STANDBY:\r\nm3_power_state = IPC_CMD_STANDBY;\r\nbreak;\r\ncase WKUP_M3_IDLE:\r\nm3_power_state = IPC_CMD_IDLE;\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nwkup_m3_ctrl_ipc_write(m3_ipc, m3_ipc->resume_addr, 0);\r\nwkup_m3_ctrl_ipc_write(m3_ipc, m3_power_state, 1);\r\nwkup_m3_ctrl_ipc_write(m3_ipc, m3_ipc->mem_type, 4);\r\nwkup_m3_ctrl_ipc_write(m3_ipc, DS_IPC_DEFAULT, 2);\r\nwkup_m3_ctrl_ipc_write(m3_ipc, DS_IPC_DEFAULT, 3);\r\nwkup_m3_ctrl_ipc_write(m3_ipc, DS_IPC_DEFAULT, 5);\r\nwkup_m3_ctrl_ipc_write(m3_ipc, DS_IPC_DEFAULT, 6);\r\nwkup_m3_ctrl_ipc_write(m3_ipc, DS_IPC_DEFAULT, 7);\r\nm3_ipc->state = M3_STATE_MSG_FOR_LP;\r\nif (state == WKUP_M3_IDLE)\r\nret = wkup_m3_ping_noirq(m3_ipc);\r\nelse\r\nret = wkup_m3_ping(m3_ipc);\r\nif (ret) {\r\ndev_err(dev, "Unable to ping CM3\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wkup_m3_finish_low_power(struct wkup_m3_ipc *m3_ipc)\r\n{\r\nstruct device *dev = m3_ipc->dev;\r\nint ret = 0;\r\nif (!wkup_m3_is_available(m3_ipc))\r\nreturn -ENODEV;\r\nwkup_m3_ctrl_ipc_write(m3_ipc, IPC_CMD_RESET, 1);\r\nwkup_m3_ctrl_ipc_write(m3_ipc, DS_IPC_DEFAULT, 2);\r\nm3_ipc->state = M3_STATE_MSG_FOR_RESET;\r\nret = wkup_m3_ping(m3_ipc);\r\nif (ret) {\r\ndev_err(dev, "Unable to ping CM3\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstruct wkup_m3_ipc *wkup_m3_ipc_get(void)\r\n{\r\nif (m3_ipc_state)\r\nget_device(m3_ipc_state->dev);\r\nelse\r\nreturn NULL;\r\nreturn m3_ipc_state;\r\n}\r\nvoid wkup_m3_ipc_put(struct wkup_m3_ipc *m3_ipc)\r\n{\r\nif (m3_ipc_state)\r\nput_device(m3_ipc_state->dev);\r\n}\r\nstatic void wkup_m3_rproc_boot_thread(struct wkup_m3_ipc *m3_ipc)\r\n{\r\nstruct device *dev = m3_ipc->dev;\r\nint ret;\r\ninit_completion(&m3_ipc->sync_complete);\r\nret = rproc_boot(m3_ipc->rproc);\r\nif (ret)\r\ndev_err(dev, "rproc_boot failed\n");\r\ndo_exit(0);\r\n}\r\nstatic int wkup_m3_ipc_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nint irq, ret;\r\nphandle rproc_phandle;\r\nstruct rproc *m3_rproc;\r\nstruct resource *res;\r\nstruct task_struct *task;\r\nstruct wkup_m3_ipc *m3_ipc;\r\nm3_ipc = devm_kzalloc(dev, sizeof(*m3_ipc), GFP_KERNEL);\r\nif (!m3_ipc)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nm3_ipc->ipc_mem_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(m3_ipc->ipc_mem_base)) {\r\ndev_err(dev, "could not ioremap ipc_mem\n");\r\nreturn PTR_ERR(m3_ipc->ipc_mem_base);\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (!irq) {\r\ndev_err(&pdev->dev, "no irq resource\n");\r\nreturn -ENXIO;\r\n}\r\nret = devm_request_irq(dev, irq, wkup_m3_txev_handler,\r\n0, "wkup_m3_txev", m3_ipc);\r\nif (ret) {\r\ndev_err(dev, "request_irq failed\n");\r\nreturn ret;\r\n}\r\nm3_ipc->mbox_client.dev = dev;\r\nm3_ipc->mbox_client.tx_done = NULL;\r\nm3_ipc->mbox_client.tx_prepare = NULL;\r\nm3_ipc->mbox_client.rx_callback = NULL;\r\nm3_ipc->mbox_client.tx_block = false;\r\nm3_ipc->mbox_client.knows_txdone = false;\r\nm3_ipc->mbox = mbox_request_channel(&m3_ipc->mbox_client, 0);\r\nif (IS_ERR(m3_ipc->mbox)) {\r\ndev_err(dev, "IPC Request for A8->M3 Channel failed! %ld\n",\r\nPTR_ERR(m3_ipc->mbox));\r\nreturn PTR_ERR(m3_ipc->mbox);\r\n}\r\nif (of_property_read_u32(dev->of_node, "ti,rproc", &rproc_phandle)) {\r\ndev_err(&pdev->dev, "could not get rproc phandle\n");\r\nret = -ENODEV;\r\ngoto err_free_mbox;\r\n}\r\nm3_rproc = rproc_get_by_phandle(rproc_phandle);\r\nif (!m3_rproc) {\r\ndev_err(&pdev->dev, "could not get rproc handle\n");\r\nret = -EPROBE_DEFER;\r\ngoto err_free_mbox;\r\n}\r\nm3_ipc->rproc = m3_rproc;\r\nm3_ipc->dev = dev;\r\nm3_ipc->state = M3_STATE_RESET;\r\nm3_ipc->ops = &ipc_ops;\r\ntask = kthread_run((void *)wkup_m3_rproc_boot_thread, m3_ipc,\r\n"wkup_m3_rproc_loader");\r\nif (IS_ERR(task)) {\r\ndev_err(dev, "can't create rproc_boot thread\n");\r\nret = PTR_ERR(task);\r\ngoto err_put_rproc;\r\n}\r\nm3_ipc_state = m3_ipc;\r\nreturn 0;\r\nerr_put_rproc:\r\nrproc_put(m3_rproc);\r\nerr_free_mbox:\r\nmbox_free_channel(m3_ipc->mbox);\r\nreturn ret;\r\n}\r\nstatic int wkup_m3_ipc_remove(struct platform_device *pdev)\r\n{\r\nmbox_free_channel(m3_ipc_state->mbox);\r\nrproc_shutdown(m3_ipc_state->rproc);\r\nrproc_put(m3_ipc_state->rproc);\r\nm3_ipc_state = NULL;\r\nreturn 0;\r\n}
