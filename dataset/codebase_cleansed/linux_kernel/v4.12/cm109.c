static unsigned short special_keymap(int code)\r\n{\r\nif (code > 0xff) {\r\nswitch (code - 0xff) {\r\ncase RECORD_MUTE: return KEY_MICMUTE;\r\ncase PLAYBACK_MUTE: return KEY_MUTE;\r\ncase VOLUME_DOWN: return KEY_VOLUMEDOWN;\r\ncase VOLUME_UP: return KEY_VOLUMEUP;\r\n}\r\n}\r\nreturn KEY_RESERVED;\r\n}\r\nstatic unsigned short keymap_kip1000(int scancode)\r\n{\r\nswitch (scancode) {\r\ncase 0x82: return KEY_NUMERIC_0;\r\ncase 0x14: return KEY_NUMERIC_1;\r\ncase 0x12: return KEY_NUMERIC_2;\r\ncase 0x11: return KEY_NUMERIC_3;\r\ncase 0x24: return KEY_NUMERIC_4;\r\ncase 0x22: return KEY_NUMERIC_5;\r\ncase 0x21: return KEY_NUMERIC_6;\r\ncase 0x44: return KEY_NUMERIC_7;\r\ncase 0x42: return KEY_NUMERIC_8;\r\ncase 0x41: return KEY_NUMERIC_9;\r\ncase 0x81: return KEY_NUMERIC_POUND;\r\ncase 0x84: return KEY_NUMERIC_STAR;\r\ncase 0x88: return KEY_ENTER;\r\ncase 0x48: return KEY_ESC;\r\ncase 0x28: return KEY_LEFT;\r\ncase 0x18: return KEY_RIGHT;\r\ndefault: return special_keymap(scancode);\r\n}\r\n}\r\nstatic unsigned short keymap_gtalk(int scancode)\r\n{\r\nswitch (scancode) {\r\ncase 0x11: return KEY_NUMERIC_0;\r\ncase 0x21: return KEY_NUMERIC_1;\r\ncase 0x41: return KEY_NUMERIC_2;\r\ncase 0x81: return KEY_NUMERIC_3;\r\ncase 0x12: return KEY_NUMERIC_4;\r\ncase 0x22: return KEY_NUMERIC_5;\r\ncase 0x42: return KEY_NUMERIC_6;\r\ncase 0x82: return KEY_NUMERIC_7;\r\ncase 0x14: return KEY_NUMERIC_8;\r\ncase 0x24: return KEY_NUMERIC_9;\r\ncase 0x44: return KEY_NUMERIC_POUND;\r\ncase 0x84: return KEY_NUMERIC_STAR;\r\ncase 0x18: return KEY_ENTER;\r\ncase 0x28: return KEY_ESC;\r\ncase 0x48: return KEY_UP;\r\ncase 0x88: return KEY_DOWN;\r\ndefault: return special_keymap(scancode);\r\n}\r\n}\r\nstatic unsigned short keymap_usbph01(int scancode)\r\n{\r\nswitch (scancode) {\r\ncase 0x11: return KEY_NUMERIC_0;\r\ncase 0x21: return KEY_NUMERIC_1;\r\ncase 0x41: return KEY_NUMERIC_2;\r\ncase 0x81: return KEY_NUMERIC_3;\r\ncase 0x12: return KEY_NUMERIC_4;\r\ncase 0x22: return KEY_NUMERIC_5;\r\ncase 0x42: return KEY_NUMERIC_6;\r\ncase 0x82: return KEY_NUMERIC_7;\r\ncase 0x14: return KEY_NUMERIC_8;\r\ncase 0x24: return KEY_NUMERIC_9;\r\ncase 0x44: return KEY_NUMERIC_POUND;\r\ncase 0x84: return KEY_NUMERIC_STAR;\r\ncase 0x18: return KEY_ENTER;\r\ncase 0x28: return KEY_ESC;\r\ncase 0x48: return KEY_LEFT;\r\ncase 0x88: return KEY_RIGHT;\r\ndefault: return special_keymap(scancode);\r\n}\r\n}\r\nstatic unsigned short keymap_atcom(int scancode)\r\n{\r\nswitch (scancode) {\r\ncase 0x82: return KEY_NUMERIC_0;\r\ncase 0x11: return KEY_NUMERIC_1;\r\ncase 0x12: return KEY_NUMERIC_2;\r\ncase 0x14: return KEY_NUMERIC_3;\r\ncase 0x21: return KEY_NUMERIC_4;\r\ncase 0x22: return KEY_NUMERIC_5;\r\ncase 0x24: return KEY_NUMERIC_6;\r\ncase 0x41: return KEY_NUMERIC_7;\r\ncase 0x42: return KEY_NUMERIC_8;\r\ncase 0x44: return KEY_NUMERIC_9;\r\ncase 0x84: return KEY_NUMERIC_POUND;\r\ncase 0x81: return KEY_NUMERIC_STAR;\r\ncase 0x18: return KEY_ENTER;\r\ncase 0x28: return KEY_ESC;\r\ncase 0x48: return KEY_LEFT;\r\ncase 0x88: return KEY_RIGHT;\r\ndefault: return special_keymap(scancode);\r\n}\r\n}\r\nstatic void report_key(struct cm109_dev *dev, int key)\r\n{\r\nstruct input_dev *idev = dev->idev;\r\nif (dev->key_code >= 0) {\r\ninput_report_key(idev, dev->key_code, 0);\r\n}\r\ndev->key_code = key;\r\nif (key >= 0) {\r\ninput_report_key(idev, key, 1);\r\n}\r\ninput_sync(idev);\r\n}\r\nstatic void cm109_report_special(struct cm109_dev *dev)\r\n{\r\nstatic const u8 autorelease = RECORD_MUTE | PLAYBACK_MUTE;\r\nstruct input_dev *idev = dev->idev;\r\nu8 data = dev->irq_data->byte[HID_IR0];\r\nunsigned short keycode;\r\nint i;\r\nfor (i = 0; i < 4; i++) {\r\nkeycode = dev->keymap[0xff + BIT(i)];\r\nif (keycode == KEY_RESERVED)\r\ncontinue;\r\ninput_report_key(idev, keycode, data & BIT(i));\r\nif (data & autorelease & BIT(i)) {\r\ninput_sync(idev);\r\ninput_report_key(idev, keycode, 0);\r\n}\r\n}\r\ninput_sync(idev);\r\n}\r\nstatic void cm109_submit_buzz_toggle(struct cm109_dev *dev)\r\n{\r\nint error;\r\nif (dev->buzzer_state)\r\ndev->ctl_data->byte[HID_OR0] |= BUZZER_ON;\r\nelse\r\ndev->ctl_data->byte[HID_OR0] &= ~BUZZER_ON;\r\nerror = usb_submit_urb(dev->urb_ctl, GFP_ATOMIC);\r\nif (error)\r\ndev_err(&dev->intf->dev,\r\n"%s: usb_submit_urb (urb_ctl) failed %d\n",\r\n__func__, error);\r\n}\r\nstatic void cm109_urb_irq_callback(struct urb *urb)\r\n{\r\nstruct cm109_dev *dev = urb->context;\r\nconst int status = urb->status;\r\nint error;\r\nunsigned long flags;\r\ndev_dbg(&dev->intf->dev, "### URB IRQ: [0x%02x 0x%02x 0x%02x 0x%02x] keybit=0x%02x\n",\r\ndev->irq_data->byte[0],\r\ndev->irq_data->byte[1],\r\ndev->irq_data->byte[2],\r\ndev->irq_data->byte[3],\r\ndev->keybit);\r\nif (status) {\r\nif (status == -ESHUTDOWN)\r\nreturn;\r\ndev_err_ratelimited(&dev->intf->dev, "%s: urb status %d\n",\r\n__func__, status);\r\ngoto out;\r\n}\r\ncm109_report_special(dev);\r\nif (dev->keybit == 0xf) {\r\nif ((dev->gpi & 0xf0) == (dev->irq_data->byte[HID_IR1] & 0xf0))\r\ngoto out;\r\ndev->gpi = dev->irq_data->byte[HID_IR1] & 0xf0;\r\ndev->keybit = 0x1;\r\n} else {\r\nreport_key(dev, dev->keymap[dev->irq_data->byte[HID_IR1]]);\r\ndev->keybit <<= 1;\r\nif (dev->keybit > 0x8)\r\ndev->keybit = 0xf;\r\n}\r\nout:\r\nspin_lock_irqsave(&dev->ctl_submit_lock, flags);\r\ndev->irq_urb_pending = 0;\r\nif (likely(!dev->shutdown)) {\r\nif (dev->buzzer_state)\r\ndev->ctl_data->byte[HID_OR0] |= BUZZER_ON;\r\nelse\r\ndev->ctl_data->byte[HID_OR0] &= ~BUZZER_ON;\r\ndev->ctl_data->byte[HID_OR1] = dev->keybit;\r\ndev->ctl_data->byte[HID_OR2] = dev->keybit;\r\ndev->buzzer_pending = 0;\r\ndev->ctl_urb_pending = 1;\r\nerror = usb_submit_urb(dev->urb_ctl, GFP_ATOMIC);\r\nif (error)\r\ndev_err(&dev->intf->dev,\r\n"%s: usb_submit_urb (urb_ctl) failed %d\n",\r\n__func__, error);\r\n}\r\nspin_unlock_irqrestore(&dev->ctl_submit_lock, flags);\r\n}\r\nstatic void cm109_urb_ctl_callback(struct urb *urb)\r\n{\r\nstruct cm109_dev *dev = urb->context;\r\nconst int status = urb->status;\r\nint error;\r\nunsigned long flags;\r\ndev_dbg(&dev->intf->dev, "### URB CTL: [0x%02x 0x%02x 0x%02x 0x%02x]\n",\r\ndev->ctl_data->byte[0],\r\ndev->ctl_data->byte[1],\r\ndev->ctl_data->byte[2],\r\ndev->ctl_data->byte[3]);\r\nif (status) {\r\nif (status == -ESHUTDOWN)\r\nreturn;\r\ndev_err_ratelimited(&dev->intf->dev, "%s: urb status %d\n",\r\n__func__, status);\r\n}\r\nspin_lock_irqsave(&dev->ctl_submit_lock, flags);\r\ndev->ctl_urb_pending = 0;\r\nif (likely(!dev->shutdown)) {\r\nif (dev->buzzer_pending || status) {\r\ndev->buzzer_pending = 0;\r\ndev->ctl_urb_pending = 1;\r\ncm109_submit_buzz_toggle(dev);\r\n} else if (likely(!dev->irq_urb_pending)) {\r\ndev->irq_urb_pending = 1;\r\nerror = usb_submit_urb(dev->urb_irq, GFP_ATOMIC);\r\nif (error)\r\ndev_err(&dev->intf->dev,\r\n"%s: usb_submit_urb (urb_irq) failed %d\n",\r\n__func__, error);\r\n}\r\n}\r\nspin_unlock_irqrestore(&dev->ctl_submit_lock, flags);\r\n}\r\nstatic void cm109_toggle_buzzer_async(struct cm109_dev *dev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->ctl_submit_lock, flags);\r\nif (dev->ctl_urb_pending) {\r\ndev->buzzer_pending = 1;\r\n} else {\r\ndev->ctl_urb_pending = 1;\r\ncm109_submit_buzz_toggle(dev);\r\n}\r\nspin_unlock_irqrestore(&dev->ctl_submit_lock, flags);\r\n}\r\nstatic void cm109_toggle_buzzer_sync(struct cm109_dev *dev, int on)\r\n{\r\nint error;\r\nif (on)\r\ndev->ctl_data->byte[HID_OR0] |= BUZZER_ON;\r\nelse\r\ndev->ctl_data->byte[HID_OR0] &= ~BUZZER_ON;\r\nerror = usb_control_msg(dev->udev,\r\nusb_sndctrlpipe(dev->udev, 0),\r\ndev->ctl_req->bRequest,\r\ndev->ctl_req->bRequestType,\r\nle16_to_cpu(dev->ctl_req->wValue),\r\nle16_to_cpu(dev->ctl_req->wIndex),\r\ndev->ctl_data,\r\nUSB_PKT_LEN, USB_CTRL_SET_TIMEOUT);\r\nif (error < 0 && error != -EINTR)\r\ndev_err(&dev->intf->dev, "%s: usb_control_msg() failed %d\n",\r\n__func__, error);\r\n}\r\nstatic void cm109_stop_traffic(struct cm109_dev *dev)\r\n{\r\ndev->shutdown = 1;\r\nsmp_wmb();\r\nusb_kill_urb(dev->urb_ctl);\r\nusb_kill_urb(dev->urb_irq);\r\ncm109_toggle_buzzer_sync(dev, 0);\r\ndev->shutdown = 0;\r\nsmp_wmb();\r\n}\r\nstatic void cm109_restore_state(struct cm109_dev *dev)\r\n{\r\nif (dev->open) {\r\ncm109_toggle_buzzer_async(dev);\r\n}\r\n}\r\nstatic int cm109_input_open(struct input_dev *idev)\r\n{\r\nstruct cm109_dev *dev = input_get_drvdata(idev);\r\nint error;\r\nerror = usb_autopm_get_interface(dev->intf);\r\nif (error < 0) {\r\ndev_err(&idev->dev, "%s - cannot autoresume, result %d\n",\r\n__func__, error);\r\nreturn error;\r\n}\r\nmutex_lock(&dev->pm_mutex);\r\ndev->buzzer_state = 0;\r\ndev->key_code = -1;\r\ndev->keybit = 0xf;\r\ndev->ctl_data->byte[HID_OR0] = HID_OR_GPO_BUZ_SPDIF;\r\ndev->ctl_data->byte[HID_OR1] = dev->keybit;\r\ndev->ctl_data->byte[HID_OR2] = dev->keybit;\r\ndev->ctl_data->byte[HID_OR3] = 0x00;\r\nerror = usb_submit_urb(dev->urb_ctl, GFP_KERNEL);\r\nif (error)\r\ndev_err(&dev->intf->dev, "%s: usb_submit_urb (urb_ctl) failed %d\n",\r\n__func__, error);\r\nelse\r\ndev->open = 1;\r\nmutex_unlock(&dev->pm_mutex);\r\nif (error)\r\nusb_autopm_put_interface(dev->intf);\r\nreturn error;\r\n}\r\nstatic void cm109_input_close(struct input_dev *idev)\r\n{\r\nstruct cm109_dev *dev = input_get_drvdata(idev);\r\nmutex_lock(&dev->pm_mutex);\r\ncm109_stop_traffic(dev);\r\ndev->open = 0;\r\nmutex_unlock(&dev->pm_mutex);\r\nusb_autopm_put_interface(dev->intf);\r\n}\r\nstatic int cm109_input_ev(struct input_dev *idev, unsigned int type,\r\nunsigned int code, int value)\r\n{\r\nstruct cm109_dev *dev = input_get_drvdata(idev);\r\ndev_dbg(&dev->intf->dev,\r\n"input_ev: type=%u code=%u value=%d\n", type, code, value);\r\nif (type != EV_SND)\r\nreturn -EINVAL;\r\nswitch (code) {\r\ncase SND_TONE:\r\ncase SND_BELL:\r\ndev->buzzer_state = !!value;\r\nif (!dev->resetting)\r\ncm109_toggle_buzzer_async(dev);\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void cm109_usb_cleanup(struct cm109_dev *dev)\r\n{\r\nkfree(dev->ctl_req);\r\nif (dev->ctl_data)\r\nusb_free_coherent(dev->udev, USB_PKT_LEN,\r\ndev->ctl_data, dev->ctl_dma);\r\nif (dev->irq_data)\r\nusb_free_coherent(dev->udev, USB_PKT_LEN,\r\ndev->irq_data, dev->irq_dma);\r\nusb_free_urb(dev->urb_irq);\r\nusb_free_urb(dev->urb_ctl);\r\nkfree(dev);\r\n}\r\nstatic void cm109_usb_disconnect(struct usb_interface *interface)\r\n{\r\nstruct cm109_dev *dev = usb_get_intfdata(interface);\r\nusb_set_intfdata(interface, NULL);\r\ninput_unregister_device(dev->idev);\r\ncm109_usb_cleanup(dev);\r\n}\r\nstatic int cm109_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct driver_info *nfo = (struct driver_info *)id->driver_info;\r\nstruct usb_host_interface *interface;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nstruct cm109_dev *dev;\r\nstruct input_dev *input_dev = NULL;\r\nint ret, pipe, i;\r\nint error = -ENOMEM;\r\ninterface = intf->cur_altsetting;\r\nif (interface->desc.bNumEndpoints < 1)\r\nreturn -ENODEV;\r\nendpoint = &interface->endpoint[0].desc;\r\nif (!usb_endpoint_is_int_in(endpoint))\r\nreturn -ENODEV;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nspin_lock_init(&dev->ctl_submit_lock);\r\nmutex_init(&dev->pm_mutex);\r\ndev->udev = udev;\r\ndev->intf = intf;\r\ndev->idev = input_dev = input_allocate_device();\r\nif (!input_dev)\r\ngoto err_out;\r\ndev->irq_data = usb_alloc_coherent(udev, USB_PKT_LEN,\r\nGFP_KERNEL, &dev->irq_dma);\r\nif (!dev->irq_data)\r\ngoto err_out;\r\ndev->ctl_data = usb_alloc_coherent(udev, USB_PKT_LEN,\r\nGFP_KERNEL, &dev->ctl_dma);\r\nif (!dev->ctl_data)\r\ngoto err_out;\r\ndev->ctl_req = kmalloc(sizeof(*(dev->ctl_req)), GFP_KERNEL);\r\nif (!dev->ctl_req)\r\ngoto err_out;\r\ndev->urb_irq = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!dev->urb_irq)\r\ngoto err_out;\r\ndev->urb_ctl = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!dev->urb_ctl)\r\ngoto err_out;\r\npipe = usb_rcvintpipe(udev, endpoint->bEndpointAddress);\r\nret = usb_maxpacket(udev, pipe, usb_pipeout(pipe));\r\nif (ret != USB_PKT_LEN)\r\ndev_err(&intf->dev, "invalid payload size %d, expected %d\n",\r\nret, USB_PKT_LEN);\r\nusb_fill_int_urb(dev->urb_irq, udev, pipe, dev->irq_data,\r\nUSB_PKT_LEN,\r\ncm109_urb_irq_callback, dev, endpoint->bInterval);\r\ndev->urb_irq->transfer_dma = dev->irq_dma;\r\ndev->urb_irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\ndev->urb_irq->dev = udev;\r\ndev->ctl_req->bRequestType = USB_TYPE_CLASS | USB_RECIP_INTERFACE |\r\nUSB_DIR_OUT;\r\ndev->ctl_req->bRequest = USB_REQ_SET_CONFIGURATION;\r\ndev->ctl_req->wValue = cpu_to_le16(0x200);\r\ndev->ctl_req->wIndex = cpu_to_le16(interface->desc.bInterfaceNumber);\r\ndev->ctl_req->wLength = cpu_to_le16(USB_PKT_LEN);\r\nusb_fill_control_urb(dev->urb_ctl, udev, usb_sndctrlpipe(udev, 0),\r\n(void *)dev->ctl_req, dev->ctl_data, USB_PKT_LEN,\r\ncm109_urb_ctl_callback, dev);\r\ndev->urb_ctl->transfer_dma = dev->ctl_dma;\r\ndev->urb_ctl->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\ndev->urb_ctl->dev = udev;\r\nusb_make_path(udev, dev->phys, sizeof(dev->phys));\r\nstrlcat(dev->phys, "/input0", sizeof(dev->phys));\r\ninput_dev->name = nfo->name;\r\ninput_dev->phys = dev->phys;\r\nusb_to_input_id(udev, &input_dev->id);\r\ninput_dev->dev.parent = &intf->dev;\r\ninput_set_drvdata(input_dev, dev);\r\ninput_dev->open = cm109_input_open;\r\ninput_dev->close = cm109_input_close;\r\ninput_dev->event = cm109_input_ev;\r\ninput_dev->keycode = dev->keymap;\r\ninput_dev->keycodesize = sizeof(unsigned char);\r\ninput_dev->keycodemax = ARRAY_SIZE(dev->keymap);\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_SND);\r\ninput_dev->sndbit[0] = BIT_MASK(SND_BELL) | BIT_MASK(SND_TONE);\r\nfor (i = 0; i < KEYMAP_SIZE; i++) {\r\nunsigned short k = keymap(i);\r\ndev->keymap[i] = k;\r\n__set_bit(k, input_dev->keybit);\r\n}\r\n__clear_bit(KEY_RESERVED, input_dev->keybit);\r\nerror = input_register_device(dev->idev);\r\nif (error)\r\ngoto err_out;\r\nusb_set_intfdata(intf, dev);\r\nreturn 0;\r\nerr_out:\r\ninput_free_device(input_dev);\r\ncm109_usb_cleanup(dev);\r\nreturn error;\r\n}\r\nstatic int cm109_usb_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct cm109_dev *dev = usb_get_intfdata(intf);\r\ndev_info(&intf->dev, "cm109: usb_suspend (event=%d)\n", message.event);\r\nmutex_lock(&dev->pm_mutex);\r\ncm109_stop_traffic(dev);\r\nmutex_unlock(&dev->pm_mutex);\r\nreturn 0;\r\n}\r\nstatic int cm109_usb_resume(struct usb_interface *intf)\r\n{\r\nstruct cm109_dev *dev = usb_get_intfdata(intf);\r\ndev_info(&intf->dev, "cm109: usb_resume\n");\r\nmutex_lock(&dev->pm_mutex);\r\ncm109_restore_state(dev);\r\nmutex_unlock(&dev->pm_mutex);\r\nreturn 0;\r\n}\r\nstatic int cm109_usb_pre_reset(struct usb_interface *intf)\r\n{\r\nstruct cm109_dev *dev = usb_get_intfdata(intf);\r\nmutex_lock(&dev->pm_mutex);\r\ndev->resetting = 1;\r\nsmp_wmb();\r\ncm109_stop_traffic(dev);\r\nreturn 0;\r\n}\r\nstatic int cm109_usb_post_reset(struct usb_interface *intf)\r\n{\r\nstruct cm109_dev *dev = usb_get_intfdata(intf);\r\ndev->resetting = 0;\r\nsmp_wmb();\r\ncm109_restore_state(dev);\r\nmutex_unlock(&dev->pm_mutex);\r\nreturn 0;\r\n}\r\nstatic int __init cm109_select_keymap(void)\r\n{\r\nif (!strcasecmp(phone, "kip1000")) {\r\nkeymap = keymap_kip1000;\r\nprintk(KERN_INFO KBUILD_MODNAME ": "\r\n"Keymap for Komunikate KIP1000 phone loaded\n");\r\n} else if (!strcasecmp(phone, "gtalk")) {\r\nkeymap = keymap_gtalk;\r\nprintk(KERN_INFO KBUILD_MODNAME ": "\r\n"Keymap for Genius G-talk phone loaded\n");\r\n} else if (!strcasecmp(phone, "usbph01")) {\r\nkeymap = keymap_usbph01;\r\nprintk(KERN_INFO KBUILD_MODNAME ": "\r\n"Keymap for Allied-Telesis Corega USBPH01 phone loaded\n");\r\n} else if (!strcasecmp(phone, "atcom")) {\r\nkeymap = keymap_atcom;\r\nprintk(KERN_INFO KBUILD_MODNAME ": "\r\n"Keymap for ATCom AU-100 phone loaded\n");\r\n} else {\r\nprintk(KERN_ERR KBUILD_MODNAME ": "\r\n"Unsupported phone: %s\n", phone);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init cm109_init(void)\r\n{\r\nint err;\r\nerr = cm109_select_keymap();\r\nif (err)\r\nreturn err;\r\nerr = usb_register(&cm109_driver);\r\nif (err)\r\nreturn err;\r\nprintk(KERN_INFO KBUILD_MODNAME ": "\r\nDRIVER_DESC ": " DRIVER_VERSION " (C) " DRIVER_AUTHOR "\n");\r\nreturn 0;\r\n}\r\nstatic void __exit cm109_exit(void)\r\n{\r\nusb_deregister(&cm109_driver);\r\n}
