static int da850_pupd_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nreturn ARRAY_SIZE(da850_pupd_group_names);\r\n}\r\nstatic const char *da850_pupd_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned int selector)\r\n{\r\nreturn da850_pupd_group_names[selector];\r\n}\r\nstatic int da850_pupd_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned int selector,\r\nconst unsigned int **pins,\r\nunsigned int *num_pins)\r\n{\r\n*num_pins = 0;\r\nreturn 0;\r\n}\r\nstatic int da850_pupd_pin_config_group_get(struct pinctrl_dev *pctldev,\r\nunsigned int selector,\r\nunsigned long *config)\r\n{\r\nstruct da850_pupd_data *data = pinctrl_dev_get_drvdata(pctldev);\r\nenum pin_config_param param = pinconf_to_config_param(*config);\r\nu32 val;\r\nu16 arg;\r\nval = readl(data->base + DA850_PUPD_ENA);\r\narg = !!(~val & BIT(selector));\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nif (arg) {\r\narg = 0;\r\nbreak;\r\n}\r\nval = readl(data->base + DA850_PUPD_SEL);\r\nif (param == PIN_CONFIG_BIAS_PULL_DOWN)\r\nval = ~val;\r\narg = !!(val & BIT(selector));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n*config = pinconf_to_config_packed(param, arg);\r\nreturn 0;\r\n}\r\nstatic int da850_pupd_pin_config_group_set(struct pinctrl_dev *pctldev,\r\nunsigned int selector,\r\nunsigned long *configs,\r\nunsigned int num_configs)\r\n{\r\nstruct da850_pupd_data *data = pinctrl_dev_get_drvdata(pctldev);\r\nu32 ena, sel;\r\nenum pin_config_param param;\r\nint i;\r\nena = readl(data->base + DA850_PUPD_ENA);\r\nsel = readl(data->base + DA850_PUPD_SEL);\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = pinconf_to_config_param(configs[i]);\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nena &= ~BIT(selector);\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nena |= BIT(selector);\r\nsel |= BIT(selector);\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nena |= BIT(selector);\r\nsel &= ~BIT(selector);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nwritel(sel, data->base + DA850_PUPD_SEL);\r\nwritel(ena, data->base + DA850_PUPD_ENA);\r\nreturn 0;\r\n}\r\nstatic int da850_pupd_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct da850_pupd_data *data;\r\nstruct resource *res;\r\ndata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndata->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(data->base)) {\r\ndev_err(dev, "Could not map resource\n");\r\nreturn PTR_ERR(data->base);\r\n}\r\ndata->desc.name = dev_name(dev);\r\ndata->desc.pctlops = &da850_pupd_pctlops;\r\ndata->desc.confops = &da850_pupd_confops;\r\ndata->desc.owner = THIS_MODULE;\r\ndata->pinctrl = devm_pinctrl_register(dev, &data->desc, data);\r\nif (IS_ERR(data->pinctrl)) {\r\ndev_err(dev, "Failed to register pinctrl\n");\r\nreturn PTR_ERR(data->pinctrl);\r\n}\r\nplatform_set_drvdata(pdev, data);\r\nreturn 0;\r\n}\r\nstatic int da850_pupd_remove(struct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}
