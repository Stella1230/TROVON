void\r\ncifs_dump_mem(char *label, void *data, int length)\r\n{\r\npr_debug("%s: dump of %d bytes of data at 0x%p\n", label, length, data);\r\nprint_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_OFFSET, 16, 4,\r\ndata, length, true);\r\n}\r\nvoid cifs_vfs_err(const char *fmt, ...)\r\n{\r\nstruct va_format vaf;\r\nva_list args;\r\nva_start(args, fmt);\r\nvaf.fmt = fmt;\r\nvaf.va = &args;\r\npr_err_ratelimited("CIFS VFS: %pV", &vaf);\r\nva_end(args);\r\n}\r\nvoid cifs_dump_detail(void *buf)\r\n{\r\n#ifdef CONFIG_CIFS_DEBUG2\r\nstruct smb_hdr *smb = (struct smb_hdr *)buf;\r\ncifs_dbg(VFS, "Cmd: %d Err: 0x%x Flags: 0x%x Flgs2: 0x%x Mid: %d Pid: %d\n",\r\nsmb->Command, smb->Status.CifsError,\r\nsmb->Flags, smb->Flags2, smb->Mid, smb->Pid);\r\ncifs_dbg(VFS, "smb buf %p len %u\n", smb, smbCalcSize(smb));\r\n#endif\r\n}\r\nvoid cifs_dump_mids(struct TCP_Server_Info *server)\r\n{\r\n#ifdef CONFIG_CIFS_DEBUG2\r\nstruct list_head *tmp;\r\nstruct mid_q_entry *mid_entry;\r\nif (server == NULL)\r\nreturn;\r\ncifs_dbg(VFS, "Dump pending requests:\n");\r\nspin_lock(&GlobalMid_Lock);\r\nlist_for_each(tmp, &server->pending_mid_q) {\r\nmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\r\ncifs_dbg(VFS, "State: %d Cmd: %d Pid: %d Cbdata: %p Mid %llu\n",\r\nmid_entry->mid_state,\r\nle16_to_cpu(mid_entry->command),\r\nmid_entry->pid,\r\nmid_entry->callback_data,\r\nmid_entry->mid);\r\n#ifdef CONFIG_CIFS_STATS2\r\ncifs_dbg(VFS, "IsLarge: %d buf: %p time rcv: %ld now: %ld\n",\r\nmid_entry->large_buf,\r\nmid_entry->resp_buf,\r\nmid_entry->when_received,\r\njiffies);\r\n#endif\r\ncifs_dbg(VFS, "IsMult: %d IsEnd: %d\n",\r\nmid_entry->multiRsp, mid_entry->multiEnd);\r\nif (mid_entry->resp_buf) {\r\ncifs_dump_detail(mid_entry->resp_buf);\r\ncifs_dump_mem("existing buf: ",\r\nmid_entry->resp_buf, 62);\r\n}\r\n}\r\nspin_unlock(&GlobalMid_Lock);\r\n#endif\r\n}\r\nstatic int cifs_debug_data_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct list_head *tmp1, *tmp2, *tmp3;\r\nstruct mid_q_entry *mid_entry;\r\nstruct TCP_Server_Info *server;\r\nstruct cifs_ses *ses;\r\nstruct cifs_tcon *tcon;\r\nint i, j;\r\n__u32 dev_type;\r\nseq_puts(m,\r\n"Display Internal CIFS Data Structures for Debugging\n"\r\n"---------------------------------------------------\n");\r\nseq_printf(m, "CIFS Version %s\n", CIFS_VERSION);\r\nseq_printf(m, "Features:");\r\n#ifdef CONFIG_CIFS_DFS_UPCALL\r\nseq_printf(m, " dfs");\r\n#endif\r\n#ifdef CONFIG_CIFS_FSCACHE\r\nseq_printf(m, " fscache");\r\n#endif\r\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\r\nseq_printf(m, " lanman");\r\n#endif\r\n#ifdef CONFIG_CIFS_POSIX\r\nseq_printf(m, " posix");\r\n#endif\r\n#ifdef CONFIG_CIFS_UPCALL\r\nseq_printf(m, " spnego");\r\n#endif\r\n#ifdef CONFIG_CIFS_XATTR\r\nseq_printf(m, " xattr");\r\n#endif\r\n#ifdef CONFIG_CIFS_ACL\r\nseq_printf(m, " acl");\r\n#endif\r\nseq_putc(m, '\n');\r\nseq_printf(m, "Active VFS Requests: %d\n", GlobalTotalActiveXid);\r\nseq_printf(m, "Servers:");\r\ni = 0;\r\nspin_lock(&cifs_tcp_ses_lock);\r\nlist_for_each(tmp1, &cifs_tcp_ses_list) {\r\nserver = list_entry(tmp1, struct TCP_Server_Info,\r\ntcp_ses_list);\r\nseq_printf(m, "\nNumber of credits: %d", server->credits);\r\ni++;\r\nlist_for_each(tmp2, &server->smb_ses_list) {\r\nses = list_entry(tmp2, struct cifs_ses,\r\nsmb_ses_list);\r\nif ((ses->serverDomain == NULL) ||\r\n(ses->serverOS == NULL) ||\r\n(ses->serverNOS == NULL)) {\r\nseq_printf(m, "\n%d) entry for %s not fully "\r\n"displayed\n\t", i, ses->serverName);\r\n} else {\r\nseq_printf(m,\r\n"\n%d) Name: %s Domain: %s Uses: %d OS:"\r\n" %s\n\tNOS: %s\tCapability: 0x%x\n\tSMB"\r\n" session status: %d\t",\r\ni, ses->serverName, ses->serverDomain,\r\nses->ses_count, ses->serverOS, ses->serverNOS,\r\nses->capabilities, ses->status);\r\n}\r\nseq_printf(m, "TCP status: %d\n\tLocal Users To "\r\n"Server: %d SecMode: 0x%x Req On Wire: %d",\r\nserver->tcpStatus, server->srv_count,\r\nserver->sec_mode, in_flight(server));\r\n#ifdef CONFIG_CIFS_STATS2\r\nseq_printf(m, " In Send: %d In MaxReq Wait: %d",\r\natomic_read(&server->in_send),\r\natomic_read(&server->num_waiters));\r\n#endif\r\nseq_puts(m, "\n\tShares:");\r\nj = 0;\r\nlist_for_each(tmp3, &ses->tcon_list) {\r\ntcon = list_entry(tmp3, struct cifs_tcon,\r\ntcon_list);\r\n++j;\r\ndev_type = le32_to_cpu(tcon->fsDevInfo.DeviceType);\r\nseq_printf(m, "\n\t%d) %s Mounts: %d ", j,\r\ntcon->treeName, tcon->tc_count);\r\nif (tcon->nativeFileSystem) {\r\nseq_printf(m, "Type: %s ",\r\ntcon->nativeFileSystem);\r\n}\r\nseq_printf(m, "DevInfo: 0x%x Attributes: 0x%x"\r\n"\n\tPathComponentMax: %d Status: %d",\r\nle32_to_cpu(tcon->fsDevInfo.DeviceCharacteristics),\r\nle32_to_cpu(tcon->fsAttrInfo.Attributes),\r\nle32_to_cpu(tcon->fsAttrInfo.MaxPathNameComponentLength),\r\ntcon->tidStatus);\r\nif (dev_type == FILE_DEVICE_DISK)\r\nseq_puts(m, " type: DISK ");\r\nelse if (dev_type == FILE_DEVICE_CD_ROM)\r\nseq_puts(m, " type: CDROM ");\r\nelse\r\nseq_printf(m, " type: %d ", dev_type);\r\nif (server->ops->dump_share_caps)\r\nserver->ops->dump_share_caps(m, tcon);\r\nif (tcon->need_reconnect)\r\nseq_puts(m, "\tDISCONNECTED ");\r\nseq_putc(m, '\n');\r\n}\r\nseq_puts(m, "\n\tMIDs:\n");\r\nspin_lock(&GlobalMid_Lock);\r\nlist_for_each(tmp3, &server->pending_mid_q) {\r\nmid_entry = list_entry(tmp3, struct mid_q_entry,\r\nqhead);\r\nseq_printf(m, "\tState: %d com: %d pid:"\r\n" %d cbdata: %p mid %llu\n",\r\nmid_entry->mid_state,\r\nle16_to_cpu(mid_entry->command),\r\nmid_entry->pid,\r\nmid_entry->callback_data,\r\nmid_entry->mid);\r\n}\r\nspin_unlock(&GlobalMid_Lock);\r\n}\r\n}\r\nspin_unlock(&cifs_tcp_ses_lock);\r\nseq_putc(m, '\n');\r\nreturn 0;\r\n}\r\nstatic int cifs_debug_data_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, cifs_debug_data_proc_show, NULL);\r\n}\r\nstatic ssize_t cifs_stats_proc_write(struct file *file,\r\nconst char __user *buffer, size_t count, loff_t *ppos)\r\n{\r\nbool bv;\r\nint rc;\r\nstruct list_head *tmp1, *tmp2, *tmp3;\r\nstruct TCP_Server_Info *server;\r\nstruct cifs_ses *ses;\r\nstruct cifs_tcon *tcon;\r\nrc = kstrtobool_from_user(buffer, count, &bv);\r\nif (rc == 0) {\r\n#ifdef CONFIG_CIFS_STATS2\r\natomic_set(&totBufAllocCount, 0);\r\natomic_set(&totSmBufAllocCount, 0);\r\n#endif\r\nspin_lock(&cifs_tcp_ses_lock);\r\nlist_for_each(tmp1, &cifs_tcp_ses_list) {\r\nserver = list_entry(tmp1, struct TCP_Server_Info,\r\ntcp_ses_list);\r\nlist_for_each(tmp2, &server->smb_ses_list) {\r\nses = list_entry(tmp2, struct cifs_ses,\r\nsmb_ses_list);\r\nlist_for_each(tmp3, &ses->tcon_list) {\r\ntcon = list_entry(tmp3,\r\nstruct cifs_tcon,\r\ntcon_list);\r\natomic_set(&tcon->num_smbs_sent, 0);\r\nif (server->ops->clear_stats)\r\nserver->ops->clear_stats(tcon);\r\n}\r\n}\r\n}\r\nspin_unlock(&cifs_tcp_ses_lock);\r\n} else {\r\nreturn rc;\r\n}\r\nreturn count;\r\n}\r\nstatic int cifs_stats_proc_show(struct seq_file *m, void *v)\r\n{\r\nint i;\r\nstruct list_head *tmp1, *tmp2, *tmp3;\r\nstruct TCP_Server_Info *server;\r\nstruct cifs_ses *ses;\r\nstruct cifs_tcon *tcon;\r\nseq_printf(m,\r\n"Resources in use\nCIFS Session: %d\n",\r\nsesInfoAllocCount.counter);\r\nseq_printf(m, "Share (unique mount targets): %d\n",\r\ntconInfoAllocCount.counter);\r\nseq_printf(m, "SMB Request/Response Buffer: %d Pool size: %d\n",\r\nbufAllocCount.counter,\r\ncifs_min_rcv + tcpSesAllocCount.counter);\r\nseq_printf(m, "SMB Small Req/Resp Buffer: %d Pool size: %d\n",\r\nsmBufAllocCount.counter, cifs_min_small);\r\n#ifdef CONFIG_CIFS_STATS2\r\nseq_printf(m, "Total Large %d Small %d Allocations\n",\r\natomic_read(&totBufAllocCount),\r\natomic_read(&totSmBufAllocCount));\r\n#endif\r\nseq_printf(m, "Operations (MIDs): %d\n", atomic_read(&midCount));\r\nseq_printf(m,\r\n"\n%d session %d share reconnects\n",\r\ntcpSesReconnectCount.counter, tconInfoReconnectCount.counter);\r\nseq_printf(m,\r\n"Total vfs operations: %d maximum at one time: %d\n",\r\nGlobalCurrentXid, GlobalMaxActiveXid);\r\ni = 0;\r\nspin_lock(&cifs_tcp_ses_lock);\r\nlist_for_each(tmp1, &cifs_tcp_ses_list) {\r\nserver = list_entry(tmp1, struct TCP_Server_Info,\r\ntcp_ses_list);\r\nlist_for_each(tmp2, &server->smb_ses_list) {\r\nses = list_entry(tmp2, struct cifs_ses,\r\nsmb_ses_list);\r\nlist_for_each(tmp3, &ses->tcon_list) {\r\ntcon = list_entry(tmp3,\r\nstruct cifs_tcon,\r\ntcon_list);\r\ni++;\r\nseq_printf(m, "\n%d) %s", i, tcon->treeName);\r\nif (tcon->need_reconnect)\r\nseq_puts(m, "\tDISCONNECTED ");\r\nseq_printf(m, "\nSMBs: %d",\r\natomic_read(&tcon->num_smbs_sent));\r\nif (server->ops->print_stats)\r\nserver->ops->print_stats(m, tcon);\r\n}\r\n}\r\n}\r\nspin_unlock(&cifs_tcp_ses_lock);\r\nseq_putc(m, '\n');\r\nreturn 0;\r\n}\r\nstatic int cifs_stats_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, cifs_stats_proc_show, NULL);\r\n}\r\nvoid\r\ncifs_proc_init(void)\r\n{\r\nproc_fs_cifs = proc_mkdir("fs/cifs", NULL);\r\nif (proc_fs_cifs == NULL)\r\nreturn;\r\nproc_create("DebugData", 0, proc_fs_cifs, &cifs_debug_data_proc_fops);\r\n#ifdef CONFIG_CIFS_STATS\r\nproc_create("Stats", 0, proc_fs_cifs, &cifs_stats_proc_fops);\r\n#endif\r\nproc_create("cifsFYI", 0, proc_fs_cifs, &cifsFYI_proc_fops);\r\nproc_create("traceSMB", 0, proc_fs_cifs, &traceSMB_proc_fops);\r\nproc_create("LinuxExtensionsEnabled", 0, proc_fs_cifs,\r\n&cifs_linux_ext_proc_fops);\r\nproc_create("SecurityFlags", 0, proc_fs_cifs,\r\n&cifs_security_flags_proc_fops);\r\nproc_create("LookupCacheEnabled", 0, proc_fs_cifs,\r\n&cifs_lookup_cache_proc_fops);\r\n}\r\nvoid\r\ncifs_proc_clean(void)\r\n{\r\nif (proc_fs_cifs == NULL)\r\nreturn;\r\nremove_proc_entry("DebugData", proc_fs_cifs);\r\nremove_proc_entry("cifsFYI", proc_fs_cifs);\r\nremove_proc_entry("traceSMB", proc_fs_cifs);\r\n#ifdef CONFIG_CIFS_STATS\r\nremove_proc_entry("Stats", proc_fs_cifs);\r\n#endif\r\nremove_proc_entry("SecurityFlags", proc_fs_cifs);\r\nremove_proc_entry("LinuxExtensionsEnabled", proc_fs_cifs);\r\nremove_proc_entry("LookupCacheEnabled", proc_fs_cifs);\r\nremove_proc_entry("fs/cifs", NULL);\r\n}\r\nstatic int cifsFYI_proc_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "%d\n", cifsFYI);\r\nreturn 0;\r\n}\r\nstatic int cifsFYI_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, cifsFYI_proc_show, NULL);\r\n}\r\nstatic ssize_t cifsFYI_proc_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar c[2] = { '\0' };\r\nbool bv;\r\nint rc;\r\nrc = get_user(c[0], buffer);\r\nif (rc)\r\nreturn rc;\r\nif (strtobool(c, &bv) == 0)\r\ncifsFYI = bv;\r\nelse if ((c[0] > '1') && (c[0] <= '9'))\r\ncifsFYI = (int) (c[0] - '0');\r\nreturn count;\r\n}\r\nstatic int cifs_linux_ext_proc_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "%d\n", linuxExtEnabled);\r\nreturn 0;\r\n}\r\nstatic int cifs_linux_ext_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, cifs_linux_ext_proc_show, NULL);\r\n}\r\nstatic ssize_t cifs_linux_ext_proc_write(struct file *file,\r\nconst char __user *buffer, size_t count, loff_t *ppos)\r\n{\r\nint rc;\r\nrc = kstrtobool_from_user(buffer, count, &linuxExtEnabled);\r\nif (rc)\r\nreturn rc;\r\nreturn count;\r\n}\r\nstatic int cifs_lookup_cache_proc_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "%d\n", lookupCacheEnabled);\r\nreturn 0;\r\n}\r\nstatic int cifs_lookup_cache_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, cifs_lookup_cache_proc_show, NULL);\r\n}\r\nstatic ssize_t cifs_lookup_cache_proc_write(struct file *file,\r\nconst char __user *buffer, size_t count, loff_t *ppos)\r\n{\r\nint rc;\r\nrc = kstrtobool_from_user(buffer, count, &lookupCacheEnabled);\r\nif (rc)\r\nreturn rc;\r\nreturn count;\r\n}\r\nstatic int traceSMB_proc_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "%d\n", traceSMB);\r\nreturn 0;\r\n}\r\nstatic int traceSMB_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, traceSMB_proc_show, NULL);\r\n}\r\nstatic ssize_t traceSMB_proc_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint rc;\r\nrc = kstrtobool_from_user(buffer, count, &traceSMB);\r\nif (rc)\r\nreturn rc;\r\nreturn count;\r\n}\r\nstatic int cifs_security_flags_proc_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "0x%x\n", global_secflags);\r\nreturn 0;\r\n}\r\nstatic int cifs_security_flags_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, cifs_security_flags_proc_show, NULL);\r\n}\r\nstatic void\r\ncifs_security_flags_handle_must_flags(unsigned int *flags)\r\n{\r\nunsigned int signflags = *flags & CIFSSEC_MUST_SIGN;\r\nif ((*flags & CIFSSEC_MUST_KRB5) == CIFSSEC_MUST_KRB5)\r\n*flags = CIFSSEC_MUST_KRB5;\r\nelse if ((*flags & CIFSSEC_MUST_NTLMSSP) == CIFSSEC_MUST_NTLMSSP)\r\n*flags = CIFSSEC_MUST_NTLMSSP;\r\nelse if ((*flags & CIFSSEC_MUST_NTLMV2) == CIFSSEC_MUST_NTLMV2)\r\n*flags = CIFSSEC_MUST_NTLMV2;\r\nelse if ((*flags & CIFSSEC_MUST_NTLM) == CIFSSEC_MUST_NTLM)\r\n*flags = CIFSSEC_MUST_NTLM;\r\nelse if (CIFSSEC_MUST_LANMAN &&\r\n(*flags & CIFSSEC_MUST_LANMAN) == CIFSSEC_MUST_LANMAN)\r\n*flags = CIFSSEC_MUST_LANMAN;\r\nelse if (CIFSSEC_MUST_PLNTXT &&\r\n(*flags & CIFSSEC_MUST_PLNTXT) == CIFSSEC_MUST_PLNTXT)\r\n*flags = CIFSSEC_MUST_PLNTXT;\r\n*flags |= signflags;\r\n}\r\nstatic ssize_t cifs_security_flags_proc_write(struct file *file,\r\nconst char __user *buffer, size_t count, loff_t *ppos)\r\n{\r\nint rc;\r\nunsigned int flags;\r\nchar flags_string[12];\r\nbool bv;\r\nif ((count < 1) || (count > 11))\r\nreturn -EINVAL;\r\nmemset(flags_string, 0, 12);\r\nif (copy_from_user(flags_string, buffer, count))\r\nreturn -EFAULT;\r\nif (count < 3) {\r\nif (strtobool(flags_string, &bv) == 0) {\r\nglobal_secflags = bv ? CIFSSEC_MAX : CIFSSEC_DEF;\r\nreturn count;\r\n} else if (!isdigit(flags_string[0])) {\r\ncifs_dbg(VFS, "Invalid SecurityFlags: %s\n",\r\nflags_string);\r\nreturn -EINVAL;\r\n}\r\n}\r\nrc = kstrtouint(flags_string, 0, &flags);\r\nif (rc) {\r\ncifs_dbg(VFS, "Invalid SecurityFlags: %s\n",\r\nflags_string);\r\nreturn rc;\r\n}\r\ncifs_dbg(FYI, "sec flags 0x%x\n", flags);\r\nif (flags == 0) {\r\ncifs_dbg(VFS, "Invalid SecurityFlags: %s\n", flags_string);\r\nreturn -EINVAL;\r\n}\r\nif (flags & ~CIFSSEC_MASK) {\r\ncifs_dbg(VFS, "Unsupported security flags: 0x%x\n",\r\nflags & ~CIFSSEC_MASK);\r\nreturn -EINVAL;\r\n}\r\ncifs_security_flags_handle_must_flags(&flags);\r\nglobal_secflags = flags;\r\nif (global_secflags & CIFSSEC_MUST_SIGN) {\r\nglobal_secflags |= CIFSSEC_MAY_SIGN;\r\ncifs_dbg(FYI, "packet signing now required\n");\r\n} else if ((global_secflags & CIFSSEC_MAY_SIGN) == 0) {\r\ncifs_dbg(FYI, "packet signing disabled\n");\r\n}\r\nreturn count;\r\n}\r\ninline void cifs_proc_init(void)\r\n{\r\n}\r\ninline void cifs_proc_clean(void)\r\n{\r\n}
