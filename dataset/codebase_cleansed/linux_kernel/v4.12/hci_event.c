static void hci_cc_inquiry_cancel(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\n__u8 status = *((__u8 *) skb->data);\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (status)\r\nreturn;\r\nclear_bit(HCI_INQUIRY, &hdev->flags);\r\nsmp_mb__after_atomic();\r\nwake_up_bit(&hdev->flags, HCI_INQUIRY);\r\nhci_dev_lock(hdev);\r\nif (!hci_dev_test_flag(hdev, HCI_LE_SCAN) ||\r\nhdev->le_scan_type != LE_SCAN_ACTIVE)\r\nhci_discovery_set_state(hdev, DISCOVERY_STOPPED);\r\nhci_dev_unlock(hdev);\r\nhci_conn_check_pending(hdev);\r\n}\r\nstatic void hci_cc_periodic_inq(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\n__u8 status = *((__u8 *) skb->data);\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (status)\r\nreturn;\r\nhci_dev_set_flag(hdev, HCI_PERIODIC_INQ);\r\n}\r\nstatic void hci_cc_exit_periodic_inq(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\n__u8 status = *((__u8 *) skb->data);\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (status)\r\nreturn;\r\nhci_dev_clear_flag(hdev, HCI_PERIODIC_INQ);\r\nhci_conn_check_pending(hdev);\r\n}\r\nstatic void hci_cc_remote_name_req_cancel(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nBT_DBG("%s", hdev->name);\r\n}\r\nstatic void hci_cc_role_discovery(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_rp_role_discovery *rp = (void *) skb->data;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nif (rp->status)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(rp->handle));\r\nif (conn)\r\nconn->role = rp->role;\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cc_read_link_policy(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_rp_read_link_policy *rp = (void *) skb->data;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nif (rp->status)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(rp->handle));\r\nif (conn)\r\nconn->link_policy = __le16_to_cpu(rp->policy);\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cc_write_link_policy(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_rp_write_link_policy *rp = (void *) skb->data;\r\nstruct hci_conn *conn;\r\nvoid *sent;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nif (rp->status)\r\nreturn;\r\nsent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_LINK_POLICY);\r\nif (!sent)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(rp->handle));\r\nif (conn)\r\nconn->link_policy = get_unaligned_le16(sent + 2);\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cc_read_def_link_policy(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_rp_read_def_link_policy *rp = (void *) skb->data;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nif (rp->status)\r\nreturn;\r\nhdev->link_policy = __le16_to_cpu(rp->policy);\r\n}\r\nstatic void hci_cc_write_def_link_policy(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\n__u8 status = *((__u8 *) skb->data);\r\nvoid *sent;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (status)\r\nreturn;\r\nsent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_DEF_LINK_POLICY);\r\nif (!sent)\r\nreturn;\r\nhdev->link_policy = get_unaligned_le16(sent);\r\n}\r\nstatic void hci_cc_reset(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\n__u8 status = *((__u8 *) skb->data);\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nclear_bit(HCI_RESET, &hdev->flags);\r\nif (status)\r\nreturn;\r\nhci_dev_clear_volatile_flags(hdev);\r\nhci_discovery_set_state(hdev, DISCOVERY_STOPPED);\r\nhdev->inq_tx_power = HCI_TX_POWER_INVALID;\r\nhdev->adv_tx_power = HCI_TX_POWER_INVALID;\r\nmemset(hdev->adv_data, 0, sizeof(hdev->adv_data));\r\nhdev->adv_data_len = 0;\r\nmemset(hdev->scan_rsp_data, 0, sizeof(hdev->scan_rsp_data));\r\nhdev->scan_rsp_data_len = 0;\r\nhdev->le_scan_type = LE_SCAN_PASSIVE;\r\nhdev->ssp_debug_mode = 0;\r\nhci_bdaddr_list_clear(&hdev->le_white_list);\r\n}\r\nstatic void hci_cc_read_stored_link_key(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_rp_read_stored_link_key *rp = (void *)skb->data;\r\nstruct hci_cp_read_stored_link_key *sent;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nsent = hci_sent_cmd_data(hdev, HCI_OP_READ_STORED_LINK_KEY);\r\nif (!sent)\r\nreturn;\r\nif (!rp->status && sent->read_all == 0x01) {\r\nhdev->stored_max_keys = rp->max_keys;\r\nhdev->stored_num_keys = rp->num_keys;\r\n}\r\n}\r\nstatic void hci_cc_delete_stored_link_key(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_rp_delete_stored_link_key *rp = (void *)skb->data;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nif (rp->status)\r\nreturn;\r\nif (rp->num_keys <= hdev->stored_num_keys)\r\nhdev->stored_num_keys -= rp->num_keys;\r\nelse\r\nhdev->stored_num_keys = 0;\r\n}\r\nstatic void hci_cc_write_local_name(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\n__u8 status = *((__u8 *) skb->data);\r\nvoid *sent;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nsent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_LOCAL_NAME);\r\nif (!sent)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nif (hci_dev_test_flag(hdev, HCI_MGMT))\r\nmgmt_set_local_name_complete(hdev, sent, status);\r\nelse if (!status)\r\nmemcpy(hdev->dev_name, sent, HCI_MAX_NAME_LENGTH);\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cc_read_local_name(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_rp_read_local_name *rp = (void *) skb->data;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nif (rp->status)\r\nreturn;\r\nif (hci_dev_test_flag(hdev, HCI_SETUP) ||\r\nhci_dev_test_flag(hdev, HCI_CONFIG))\r\nmemcpy(hdev->dev_name, rp->name, HCI_MAX_NAME_LENGTH);\r\n}\r\nstatic void hci_cc_write_auth_enable(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\n__u8 status = *((__u8 *) skb->data);\r\nvoid *sent;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nsent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_AUTH_ENABLE);\r\nif (!sent)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nif (!status) {\r\n__u8 param = *((__u8 *) sent);\r\nif (param == AUTH_ENABLED)\r\nset_bit(HCI_AUTH, &hdev->flags);\r\nelse\r\nclear_bit(HCI_AUTH, &hdev->flags);\r\n}\r\nif (hci_dev_test_flag(hdev, HCI_MGMT))\r\nmgmt_auth_enable_complete(hdev, status);\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cc_write_encrypt_mode(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\n__u8 status = *((__u8 *) skb->data);\r\n__u8 param;\r\nvoid *sent;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (status)\r\nreturn;\r\nsent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_ENCRYPT_MODE);\r\nif (!sent)\r\nreturn;\r\nparam = *((__u8 *) sent);\r\nif (param)\r\nset_bit(HCI_ENCRYPT, &hdev->flags);\r\nelse\r\nclear_bit(HCI_ENCRYPT, &hdev->flags);\r\n}\r\nstatic void hci_cc_write_scan_enable(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\n__u8 status = *((__u8 *) skb->data);\r\n__u8 param;\r\nvoid *sent;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nsent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_SCAN_ENABLE);\r\nif (!sent)\r\nreturn;\r\nparam = *((__u8 *) sent);\r\nhci_dev_lock(hdev);\r\nif (status) {\r\nhdev->discov_timeout = 0;\r\ngoto done;\r\n}\r\nif (param & SCAN_INQUIRY)\r\nset_bit(HCI_ISCAN, &hdev->flags);\r\nelse\r\nclear_bit(HCI_ISCAN, &hdev->flags);\r\nif (param & SCAN_PAGE)\r\nset_bit(HCI_PSCAN, &hdev->flags);\r\nelse\r\nclear_bit(HCI_PSCAN, &hdev->flags);\r\ndone:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cc_read_class_of_dev(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_rp_read_class_of_dev *rp = (void *) skb->data;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nif (rp->status)\r\nreturn;\r\nmemcpy(hdev->dev_class, rp->dev_class, 3);\r\nBT_DBG("%s class 0x%.2x%.2x%.2x", hdev->name,\r\nhdev->dev_class[2], hdev->dev_class[1], hdev->dev_class[0]);\r\n}\r\nstatic void hci_cc_write_class_of_dev(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\n__u8 status = *((__u8 *) skb->data);\r\nvoid *sent;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nsent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_CLASS_OF_DEV);\r\nif (!sent)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nif (status == 0)\r\nmemcpy(hdev->dev_class, sent, 3);\r\nif (hci_dev_test_flag(hdev, HCI_MGMT))\r\nmgmt_set_class_of_dev_complete(hdev, sent, status);\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cc_read_voice_setting(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_rp_read_voice_setting *rp = (void *) skb->data;\r\n__u16 setting;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nif (rp->status)\r\nreturn;\r\nsetting = __le16_to_cpu(rp->voice_setting);\r\nif (hdev->voice_setting == setting)\r\nreturn;\r\nhdev->voice_setting = setting;\r\nBT_DBG("%s voice setting 0x%4.4x", hdev->name, setting);\r\nif (hdev->notify)\r\nhdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);\r\n}\r\nstatic void hci_cc_write_voice_setting(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\n__u8 status = *((__u8 *) skb->data);\r\n__u16 setting;\r\nvoid *sent;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (status)\r\nreturn;\r\nsent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);\r\nif (!sent)\r\nreturn;\r\nsetting = get_unaligned_le16(sent);\r\nif (hdev->voice_setting == setting)\r\nreturn;\r\nhdev->voice_setting = setting;\r\nBT_DBG("%s voice setting 0x%4.4x", hdev->name, setting);\r\nif (hdev->notify)\r\nhdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);\r\n}\r\nstatic void hci_cc_read_num_supported_iac(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_rp_read_num_supported_iac *rp = (void *) skb->data;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nif (rp->status)\r\nreturn;\r\nhdev->num_iac = rp->num_iac;\r\nBT_DBG("%s num iac %d", hdev->name, hdev->num_iac);\r\n}\r\nstatic void hci_cc_write_ssp_mode(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\n__u8 status = *((__u8 *) skb->data);\r\nstruct hci_cp_write_ssp_mode *sent;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nsent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_SSP_MODE);\r\nif (!sent)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nif (!status) {\r\nif (sent->mode)\r\nhdev->features[1][0] |= LMP_HOST_SSP;\r\nelse\r\nhdev->features[1][0] &= ~LMP_HOST_SSP;\r\n}\r\nif (hci_dev_test_flag(hdev, HCI_MGMT))\r\nmgmt_ssp_enable_complete(hdev, sent->mode, status);\r\nelse if (!status) {\r\nif (sent->mode)\r\nhci_dev_set_flag(hdev, HCI_SSP_ENABLED);\r\nelse\r\nhci_dev_clear_flag(hdev, HCI_SSP_ENABLED);\r\n}\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cc_write_sc_support(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nu8 status = *((u8 *) skb->data);\r\nstruct hci_cp_write_sc_support *sent;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nsent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_SC_SUPPORT);\r\nif (!sent)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nif (!status) {\r\nif (sent->support)\r\nhdev->features[1][0] |= LMP_HOST_SC;\r\nelse\r\nhdev->features[1][0] &= ~LMP_HOST_SC;\r\n}\r\nif (!hci_dev_test_flag(hdev, HCI_MGMT) && !status) {\r\nif (sent->support)\r\nhci_dev_set_flag(hdev, HCI_SC_ENABLED);\r\nelse\r\nhci_dev_clear_flag(hdev, HCI_SC_ENABLED);\r\n}\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cc_read_local_version(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_rp_read_local_version *rp = (void *) skb->data;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nif (rp->status)\r\nreturn;\r\nif (hci_dev_test_flag(hdev, HCI_SETUP) ||\r\nhci_dev_test_flag(hdev, HCI_CONFIG)) {\r\nhdev->hci_ver = rp->hci_ver;\r\nhdev->hci_rev = __le16_to_cpu(rp->hci_rev);\r\nhdev->lmp_ver = rp->lmp_ver;\r\nhdev->manufacturer = __le16_to_cpu(rp->manufacturer);\r\nhdev->lmp_subver = __le16_to_cpu(rp->lmp_subver);\r\n}\r\n}\r\nstatic void hci_cc_read_local_commands(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_rp_read_local_commands *rp = (void *) skb->data;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nif (rp->status)\r\nreturn;\r\nif (hci_dev_test_flag(hdev, HCI_SETUP) ||\r\nhci_dev_test_flag(hdev, HCI_CONFIG))\r\nmemcpy(hdev->commands, rp->commands, sizeof(hdev->commands));\r\n}\r\nstatic void hci_cc_read_local_features(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_rp_read_local_features *rp = (void *) skb->data;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nif (rp->status)\r\nreturn;\r\nmemcpy(hdev->features, rp->features, 8);\r\nif (hdev->features[0][0] & LMP_3SLOT)\r\nhdev->pkt_type |= (HCI_DM3 | HCI_DH3);\r\nif (hdev->features[0][0] & LMP_5SLOT)\r\nhdev->pkt_type |= (HCI_DM5 | HCI_DH5);\r\nif (hdev->features[0][1] & LMP_HV2) {\r\nhdev->pkt_type |= (HCI_HV2);\r\nhdev->esco_type |= (ESCO_HV2);\r\n}\r\nif (hdev->features[0][1] & LMP_HV3) {\r\nhdev->pkt_type |= (HCI_HV3);\r\nhdev->esco_type |= (ESCO_HV3);\r\n}\r\nif (lmp_esco_capable(hdev))\r\nhdev->esco_type |= (ESCO_EV3);\r\nif (hdev->features[0][4] & LMP_EV4)\r\nhdev->esco_type |= (ESCO_EV4);\r\nif (hdev->features[0][4] & LMP_EV5)\r\nhdev->esco_type |= (ESCO_EV5);\r\nif (hdev->features[0][5] & LMP_EDR_ESCO_2M)\r\nhdev->esco_type |= (ESCO_2EV3);\r\nif (hdev->features[0][5] & LMP_EDR_ESCO_3M)\r\nhdev->esco_type |= (ESCO_3EV3);\r\nif (hdev->features[0][5] & LMP_EDR_3S_ESCO)\r\nhdev->esco_type |= (ESCO_2EV5 | ESCO_3EV5);\r\n}\r\nstatic void hci_cc_read_local_ext_features(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_rp_read_local_ext_features *rp = (void *) skb->data;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nif (rp->status)\r\nreturn;\r\nif (hdev->max_page < rp->max_page)\r\nhdev->max_page = rp->max_page;\r\nif (rp->page < HCI_MAX_PAGES)\r\nmemcpy(hdev->features[rp->page], rp->features, 8);\r\n}\r\nstatic void hci_cc_read_flow_control_mode(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_rp_read_flow_control_mode *rp = (void *) skb->data;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nif (rp->status)\r\nreturn;\r\nhdev->flow_ctl_mode = rp->mode;\r\n}\r\nstatic void hci_cc_read_buffer_size(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_rp_read_buffer_size *rp = (void *) skb->data;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nif (rp->status)\r\nreturn;\r\nhdev->acl_mtu = __le16_to_cpu(rp->acl_mtu);\r\nhdev->sco_mtu = rp->sco_mtu;\r\nhdev->acl_pkts = __le16_to_cpu(rp->acl_max_pkt);\r\nhdev->sco_pkts = __le16_to_cpu(rp->sco_max_pkt);\r\nif (test_bit(HCI_QUIRK_FIXUP_BUFFER_SIZE, &hdev->quirks)) {\r\nhdev->sco_mtu = 64;\r\nhdev->sco_pkts = 8;\r\n}\r\nhdev->acl_cnt = hdev->acl_pkts;\r\nhdev->sco_cnt = hdev->sco_pkts;\r\nBT_DBG("%s acl mtu %d:%d sco mtu %d:%d", hdev->name, hdev->acl_mtu,\r\nhdev->acl_pkts, hdev->sco_mtu, hdev->sco_pkts);\r\n}\r\nstatic void hci_cc_read_bd_addr(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_rp_read_bd_addr *rp = (void *) skb->data;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nif (rp->status)\r\nreturn;\r\nif (test_bit(HCI_INIT, &hdev->flags))\r\nbacpy(&hdev->bdaddr, &rp->bdaddr);\r\nif (hci_dev_test_flag(hdev, HCI_SETUP))\r\nbacpy(&hdev->setup_addr, &rp->bdaddr);\r\n}\r\nstatic void hci_cc_read_page_scan_activity(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_rp_read_page_scan_activity *rp = (void *) skb->data;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nif (rp->status)\r\nreturn;\r\nif (test_bit(HCI_INIT, &hdev->flags)) {\r\nhdev->page_scan_interval = __le16_to_cpu(rp->interval);\r\nhdev->page_scan_window = __le16_to_cpu(rp->window);\r\n}\r\n}\r\nstatic void hci_cc_write_page_scan_activity(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nu8 status = *((u8 *) skb->data);\r\nstruct hci_cp_write_page_scan_activity *sent;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (status)\r\nreturn;\r\nsent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_PAGE_SCAN_ACTIVITY);\r\nif (!sent)\r\nreturn;\r\nhdev->page_scan_interval = __le16_to_cpu(sent->interval);\r\nhdev->page_scan_window = __le16_to_cpu(sent->window);\r\n}\r\nstatic void hci_cc_read_page_scan_type(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_rp_read_page_scan_type *rp = (void *) skb->data;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nif (rp->status)\r\nreturn;\r\nif (test_bit(HCI_INIT, &hdev->flags))\r\nhdev->page_scan_type = rp->type;\r\n}\r\nstatic void hci_cc_write_page_scan_type(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nu8 status = *((u8 *) skb->data);\r\nu8 *type;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (status)\r\nreturn;\r\ntype = hci_sent_cmd_data(hdev, HCI_OP_WRITE_PAGE_SCAN_TYPE);\r\nif (type)\r\nhdev->page_scan_type = *type;\r\n}\r\nstatic void hci_cc_read_data_block_size(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_rp_read_data_block_size *rp = (void *) skb->data;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nif (rp->status)\r\nreturn;\r\nhdev->block_mtu = __le16_to_cpu(rp->max_acl_len);\r\nhdev->block_len = __le16_to_cpu(rp->block_len);\r\nhdev->num_blocks = __le16_to_cpu(rp->num_blocks);\r\nhdev->block_cnt = hdev->num_blocks;\r\nBT_DBG("%s blk mtu %d cnt %d len %d", hdev->name, hdev->block_mtu,\r\nhdev->block_cnt, hdev->block_len);\r\n}\r\nstatic void hci_cc_read_clock(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_rp_read_clock *rp = (void *) skb->data;\r\nstruct hci_cp_read_clock *cp;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s", hdev->name);\r\nif (skb->len < sizeof(*rp))\r\nreturn;\r\nif (rp->status)\r\nreturn;\r\nhci_dev_lock(hdev);\r\ncp = hci_sent_cmd_data(hdev, HCI_OP_READ_CLOCK);\r\nif (!cp)\r\ngoto unlock;\r\nif (cp->which == 0x00) {\r\nhdev->clock = le32_to_cpu(rp->clock);\r\ngoto unlock;\r\n}\r\nconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(rp->handle));\r\nif (conn) {\r\nconn->clock = le32_to_cpu(rp->clock);\r\nconn->clock_accuracy = le16_to_cpu(rp->accuracy);\r\n}\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cc_read_local_amp_info(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_rp_read_local_amp_info *rp = (void *) skb->data;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nif (rp->status)\r\nreturn;\r\nhdev->amp_status = rp->amp_status;\r\nhdev->amp_total_bw = __le32_to_cpu(rp->total_bw);\r\nhdev->amp_max_bw = __le32_to_cpu(rp->max_bw);\r\nhdev->amp_min_latency = __le32_to_cpu(rp->min_latency);\r\nhdev->amp_max_pdu = __le32_to_cpu(rp->max_pdu);\r\nhdev->amp_type = rp->amp_type;\r\nhdev->amp_pal_cap = __le16_to_cpu(rp->pal_cap);\r\nhdev->amp_assoc_size = __le16_to_cpu(rp->max_assoc_size);\r\nhdev->amp_be_flush_to = __le32_to_cpu(rp->be_flush_to);\r\nhdev->amp_max_flush_to = __le32_to_cpu(rp->max_flush_to);\r\n}\r\nstatic void hci_cc_read_inq_rsp_tx_power(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_rp_read_inq_rsp_tx_power *rp = (void *) skb->data;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nif (rp->status)\r\nreturn;\r\nhdev->inq_tx_power = rp->tx_power;\r\n}\r\nstatic void hci_cc_pin_code_reply(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_rp_pin_code_reply *rp = (void *) skb->data;\r\nstruct hci_cp_pin_code_reply *cp;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nhci_dev_lock(hdev);\r\nif (hci_dev_test_flag(hdev, HCI_MGMT))\r\nmgmt_pin_code_reply_complete(hdev, &rp->bdaddr, rp->status);\r\nif (rp->status)\r\ngoto unlock;\r\ncp = hci_sent_cmd_data(hdev, HCI_OP_PIN_CODE_REPLY);\r\nif (!cp)\r\ngoto unlock;\r\nconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->bdaddr);\r\nif (conn)\r\nconn->pin_length = cp->pin_len;\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cc_pin_code_neg_reply(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_rp_pin_code_neg_reply *rp = (void *) skb->data;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nhci_dev_lock(hdev);\r\nif (hci_dev_test_flag(hdev, HCI_MGMT))\r\nmgmt_pin_code_neg_reply_complete(hdev, &rp->bdaddr,\r\nrp->status);\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cc_le_read_buffer_size(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_rp_le_read_buffer_size *rp = (void *) skb->data;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nif (rp->status)\r\nreturn;\r\nhdev->le_mtu = __le16_to_cpu(rp->le_mtu);\r\nhdev->le_pkts = rp->le_max_pkt;\r\nhdev->le_cnt = hdev->le_pkts;\r\nBT_DBG("%s le mtu %d:%d", hdev->name, hdev->le_mtu, hdev->le_pkts);\r\n}\r\nstatic void hci_cc_le_read_local_features(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_rp_le_read_local_features *rp = (void *) skb->data;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nif (rp->status)\r\nreturn;\r\nmemcpy(hdev->le_features, rp->features, 8);\r\n}\r\nstatic void hci_cc_le_read_adv_tx_power(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_rp_le_read_adv_tx_power *rp = (void *) skb->data;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nif (rp->status)\r\nreturn;\r\nhdev->adv_tx_power = rp->tx_power;\r\n}\r\nstatic void hci_cc_user_confirm_reply(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_rp_user_confirm_reply *rp = (void *) skb->data;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nhci_dev_lock(hdev);\r\nif (hci_dev_test_flag(hdev, HCI_MGMT))\r\nmgmt_user_confirm_reply_complete(hdev, &rp->bdaddr, ACL_LINK, 0,\r\nrp->status);\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cc_user_confirm_neg_reply(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_rp_user_confirm_reply *rp = (void *) skb->data;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nhci_dev_lock(hdev);\r\nif (hci_dev_test_flag(hdev, HCI_MGMT))\r\nmgmt_user_confirm_neg_reply_complete(hdev, &rp->bdaddr,\r\nACL_LINK, 0, rp->status);\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cc_user_passkey_reply(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_rp_user_confirm_reply *rp = (void *) skb->data;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nhci_dev_lock(hdev);\r\nif (hci_dev_test_flag(hdev, HCI_MGMT))\r\nmgmt_user_passkey_reply_complete(hdev, &rp->bdaddr, ACL_LINK,\r\n0, rp->status);\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cc_user_passkey_neg_reply(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_rp_user_confirm_reply *rp = (void *) skb->data;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nhci_dev_lock(hdev);\r\nif (hci_dev_test_flag(hdev, HCI_MGMT))\r\nmgmt_user_passkey_neg_reply_complete(hdev, &rp->bdaddr,\r\nACL_LINK, 0, rp->status);\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cc_read_local_oob_data(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_rp_read_local_oob_data *rp = (void *) skb->data;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\n}\r\nstatic void hci_cc_read_local_oob_ext_data(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_rp_read_local_oob_ext_data *rp = (void *) skb->data;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\n}\r\nstatic void hci_cc_le_set_random_addr(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\n__u8 status = *((__u8 *) skb->data);\r\nbdaddr_t *sent;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (status)\r\nreturn;\r\nsent = hci_sent_cmd_data(hdev, HCI_OP_LE_SET_RANDOM_ADDR);\r\nif (!sent)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nbacpy(&hdev->random_addr, sent);\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cc_le_set_adv_enable(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\n__u8 *sent, status = *((__u8 *) skb->data);\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (status)\r\nreturn;\r\nsent = hci_sent_cmd_data(hdev, HCI_OP_LE_SET_ADV_ENABLE);\r\nif (!sent)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nif (*sent) {\r\nstruct hci_conn *conn;\r\nhci_dev_set_flag(hdev, HCI_LE_ADV);\r\nconn = hci_lookup_le_connect(hdev);\r\nif (conn)\r\nqueue_delayed_work(hdev->workqueue,\r\n&conn->le_conn_timeout,\r\nconn->conn_timeout);\r\n} else {\r\nhci_dev_clear_flag(hdev, HCI_LE_ADV);\r\n}\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cc_le_set_scan_param(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_cp_le_set_scan_param *cp;\r\n__u8 status = *((__u8 *) skb->data);\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (status)\r\nreturn;\r\ncp = hci_sent_cmd_data(hdev, HCI_OP_LE_SET_SCAN_PARAM);\r\nif (!cp)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nhdev->le_scan_type = cp->type;\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic bool has_pending_adv_report(struct hci_dev *hdev)\r\n{\r\nstruct discovery_state *d = &hdev->discovery;\r\nreturn bacmp(&d->last_adv_addr, BDADDR_ANY);\r\n}\r\nstatic void clear_pending_adv_report(struct hci_dev *hdev)\r\n{\r\nstruct discovery_state *d = &hdev->discovery;\r\nbacpy(&d->last_adv_addr, BDADDR_ANY);\r\nd->last_adv_data_len = 0;\r\n}\r\nstatic void store_pending_adv_report(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 bdaddr_type, s8 rssi, u32 flags,\r\nu8 *data, u8 len)\r\n{\r\nstruct discovery_state *d = &hdev->discovery;\r\nbacpy(&d->last_adv_addr, bdaddr);\r\nd->last_adv_addr_type = bdaddr_type;\r\nd->last_adv_rssi = rssi;\r\nd->last_adv_flags = flags;\r\nmemcpy(d->last_adv_data, data, len);\r\nd->last_adv_data_len = len;\r\n}\r\nstatic void hci_cc_le_set_scan_enable(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_cp_le_set_scan_enable *cp;\r\n__u8 status = *((__u8 *) skb->data);\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (status)\r\nreturn;\r\ncp = hci_sent_cmd_data(hdev, HCI_OP_LE_SET_SCAN_ENABLE);\r\nif (!cp)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nswitch (cp->enable) {\r\ncase LE_SCAN_ENABLE:\r\nhci_dev_set_flag(hdev, HCI_LE_SCAN);\r\nif (hdev->le_scan_type == LE_SCAN_ACTIVE)\r\nclear_pending_adv_report(hdev);\r\nbreak;\r\ncase LE_SCAN_DISABLE:\r\nif (has_pending_adv_report(hdev)) {\r\nstruct discovery_state *d = &hdev->discovery;\r\nmgmt_device_found(hdev, &d->last_adv_addr, LE_LINK,\r\nd->last_adv_addr_type, NULL,\r\nd->last_adv_rssi, d->last_adv_flags,\r\nd->last_adv_data,\r\nd->last_adv_data_len, NULL, 0);\r\n}\r\ncancel_delayed_work(&hdev->le_scan_disable);\r\nhci_dev_clear_flag(hdev, HCI_LE_SCAN);\r\nif (hci_dev_test_and_clear_flag(hdev, HCI_LE_SCAN_INTERRUPTED))\r\nhci_discovery_set_state(hdev, DISCOVERY_STOPPED);\r\nelse if (!hci_dev_test_flag(hdev, HCI_LE_ADV) &&\r\nhdev->discovery.state == DISCOVERY_FINDING)\r\nhci_req_reenable_advertising(hdev);\r\nbreak;\r\ndefault:\r\nBT_ERR("Used reserved LE_Scan_Enable param %d", cp->enable);\r\nbreak;\r\n}\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cc_le_read_white_list_size(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_rp_le_read_white_list_size *rp = (void *) skb->data;\r\nBT_DBG("%s status 0x%2.2x size %u", hdev->name, rp->status, rp->size);\r\nif (rp->status)\r\nreturn;\r\nhdev->le_white_list_size = rp->size;\r\n}\r\nstatic void hci_cc_le_clear_white_list(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\n__u8 status = *((__u8 *) skb->data);\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (status)\r\nreturn;\r\nhci_bdaddr_list_clear(&hdev->le_white_list);\r\n}\r\nstatic void hci_cc_le_add_to_white_list(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_cp_le_add_to_white_list *sent;\r\n__u8 status = *((__u8 *) skb->data);\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (status)\r\nreturn;\r\nsent = hci_sent_cmd_data(hdev, HCI_OP_LE_ADD_TO_WHITE_LIST);\r\nif (!sent)\r\nreturn;\r\nhci_bdaddr_list_add(&hdev->le_white_list, &sent->bdaddr,\r\nsent->bdaddr_type);\r\n}\r\nstatic void hci_cc_le_del_from_white_list(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_cp_le_del_from_white_list *sent;\r\n__u8 status = *((__u8 *) skb->data);\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (status)\r\nreturn;\r\nsent = hci_sent_cmd_data(hdev, HCI_OP_LE_DEL_FROM_WHITE_LIST);\r\nif (!sent)\r\nreturn;\r\nhci_bdaddr_list_del(&hdev->le_white_list, &sent->bdaddr,\r\nsent->bdaddr_type);\r\n}\r\nstatic void hci_cc_le_read_supported_states(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_rp_le_read_supported_states *rp = (void *) skb->data;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nif (rp->status)\r\nreturn;\r\nmemcpy(hdev->le_states, rp->le_states, 8);\r\n}\r\nstatic void hci_cc_le_read_def_data_len(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_rp_le_read_def_data_len *rp = (void *) skb->data;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nif (rp->status)\r\nreturn;\r\nhdev->le_def_tx_len = le16_to_cpu(rp->tx_len);\r\nhdev->le_def_tx_time = le16_to_cpu(rp->tx_time);\r\n}\r\nstatic void hci_cc_le_write_def_data_len(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_cp_le_write_def_data_len *sent;\r\n__u8 status = *((__u8 *) skb->data);\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (status)\r\nreturn;\r\nsent = hci_sent_cmd_data(hdev, HCI_OP_LE_WRITE_DEF_DATA_LEN);\r\nif (!sent)\r\nreturn;\r\nhdev->le_def_tx_len = le16_to_cpu(sent->tx_len);\r\nhdev->le_def_tx_time = le16_to_cpu(sent->tx_time);\r\n}\r\nstatic void hci_cc_le_read_max_data_len(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_rp_le_read_max_data_len *rp = (void *) skb->data;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nif (rp->status)\r\nreturn;\r\nhdev->le_max_tx_len = le16_to_cpu(rp->tx_len);\r\nhdev->le_max_tx_time = le16_to_cpu(rp->tx_time);\r\nhdev->le_max_rx_len = le16_to_cpu(rp->rx_len);\r\nhdev->le_max_rx_time = le16_to_cpu(rp->rx_time);\r\n}\r\nstatic void hci_cc_write_le_host_supported(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_cp_write_le_host_supported *sent;\r\n__u8 status = *((__u8 *) skb->data);\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (status)\r\nreturn;\r\nsent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_LE_HOST_SUPPORTED);\r\nif (!sent)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nif (sent->le) {\r\nhdev->features[1][0] |= LMP_HOST_LE;\r\nhci_dev_set_flag(hdev, HCI_LE_ENABLED);\r\n} else {\r\nhdev->features[1][0] &= ~LMP_HOST_LE;\r\nhci_dev_clear_flag(hdev, HCI_LE_ENABLED);\r\nhci_dev_clear_flag(hdev, HCI_ADVERTISING);\r\n}\r\nif (sent->simul)\r\nhdev->features[1][0] |= LMP_HOST_LE_BREDR;\r\nelse\r\nhdev->features[1][0] &= ~LMP_HOST_LE_BREDR;\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cc_set_adv_param(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_cp_le_set_adv_param *cp;\r\nu8 status = *((u8 *) skb->data);\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (status)\r\nreturn;\r\ncp = hci_sent_cmd_data(hdev, HCI_OP_LE_SET_ADV_PARAM);\r\nif (!cp)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nhdev->adv_addr_type = cp->own_address_type;\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cc_read_rssi(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_rp_read_rssi *rp = (void *) skb->data;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nif (rp->status)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(rp->handle));\r\nif (conn)\r\nconn->rssi = rp->rssi;\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cc_read_tx_power(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_cp_read_tx_power *sent;\r\nstruct hci_rp_read_tx_power *rp = (void *) skb->data;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, rp->status);\r\nif (rp->status)\r\nreturn;\r\nsent = hci_sent_cmd_data(hdev, HCI_OP_READ_TX_POWER);\r\nif (!sent)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(rp->handle));\r\nif (!conn)\r\ngoto unlock;\r\nswitch (sent->type) {\r\ncase 0x00:\r\nconn->tx_power = rp->tx_power;\r\nbreak;\r\ncase 0x01:\r\nconn->max_tx_power = rp->tx_power;\r\nbreak;\r\n}\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cc_write_ssp_debug_mode(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nu8 status = *((u8 *) skb->data);\r\nu8 *mode;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (status)\r\nreturn;\r\nmode = hci_sent_cmd_data(hdev, HCI_OP_WRITE_SSP_DEBUG_MODE);\r\nif (mode)\r\nhdev->ssp_debug_mode = *mode;\r\n}\r\nstatic void hci_cs_inquiry(struct hci_dev *hdev, __u8 status)\r\n{\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (status) {\r\nhci_conn_check_pending(hdev);\r\nreturn;\r\n}\r\nset_bit(HCI_INQUIRY, &hdev->flags);\r\n}\r\nstatic void hci_cs_create_conn(struct hci_dev *hdev, __u8 status)\r\n{\r\nstruct hci_cp_create_conn *cp;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\ncp = hci_sent_cmd_data(hdev, HCI_OP_CREATE_CONN);\r\nif (!cp)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->bdaddr);\r\nBT_DBG("%s bdaddr %pMR hcon %p", hdev->name, &cp->bdaddr, conn);\r\nif (status) {\r\nif (conn && conn->state == BT_CONNECT) {\r\nif (status != 0x0c || conn->attempt > 2) {\r\nconn->state = BT_CLOSED;\r\nhci_connect_cfm(conn, status);\r\nhci_conn_del(conn);\r\n} else\r\nconn->state = BT_CONNECT2;\r\n}\r\n} else {\r\nif (!conn) {\r\nconn = hci_conn_add(hdev, ACL_LINK, &cp->bdaddr,\r\nHCI_ROLE_MASTER);\r\nif (!conn)\r\nBT_ERR("No memory for new connection");\r\n}\r\n}\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cs_add_sco(struct hci_dev *hdev, __u8 status)\r\n{\r\nstruct hci_cp_add_sco *cp;\r\nstruct hci_conn *acl, *sco;\r\n__u16 handle;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (!status)\r\nreturn;\r\ncp = hci_sent_cmd_data(hdev, HCI_OP_ADD_SCO);\r\nif (!cp)\r\nreturn;\r\nhandle = __le16_to_cpu(cp->handle);\r\nBT_DBG("%s handle 0x%4.4x", hdev->name, handle);\r\nhci_dev_lock(hdev);\r\nacl = hci_conn_hash_lookup_handle(hdev, handle);\r\nif (acl) {\r\nsco = acl->link;\r\nif (sco) {\r\nsco->state = BT_CLOSED;\r\nhci_connect_cfm(sco, status);\r\nhci_conn_del(sco);\r\n}\r\n}\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cs_auth_requested(struct hci_dev *hdev, __u8 status)\r\n{\r\nstruct hci_cp_auth_requested *cp;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (!status)\r\nreturn;\r\ncp = hci_sent_cmd_data(hdev, HCI_OP_AUTH_REQUESTED);\r\nif (!cp)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(cp->handle));\r\nif (conn) {\r\nif (conn->state == BT_CONFIG) {\r\nhci_connect_cfm(conn, status);\r\nhci_conn_drop(conn);\r\n}\r\n}\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cs_set_conn_encrypt(struct hci_dev *hdev, __u8 status)\r\n{\r\nstruct hci_cp_set_conn_encrypt *cp;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (!status)\r\nreturn;\r\ncp = hci_sent_cmd_data(hdev, HCI_OP_SET_CONN_ENCRYPT);\r\nif (!cp)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(cp->handle));\r\nif (conn) {\r\nif (conn->state == BT_CONFIG) {\r\nhci_connect_cfm(conn, status);\r\nhci_conn_drop(conn);\r\n}\r\n}\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic int hci_outgoing_auth_needed(struct hci_dev *hdev,\r\nstruct hci_conn *conn)\r\n{\r\nif (conn->state != BT_CONFIG || !conn->out)\r\nreturn 0;\r\nif (conn->pending_sec_level == BT_SECURITY_SDP)\r\nreturn 0;\r\nif (!hci_conn_ssp_enabled(conn) && !(conn->auth_type & 0x01) &&\r\nconn->pending_sec_level != BT_SECURITY_FIPS &&\r\nconn->pending_sec_level != BT_SECURITY_HIGH &&\r\nconn->pending_sec_level != BT_SECURITY_MEDIUM)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int hci_resolve_name(struct hci_dev *hdev,\r\nstruct inquiry_entry *e)\r\n{\r\nstruct hci_cp_remote_name_req cp;\r\nmemset(&cp, 0, sizeof(cp));\r\nbacpy(&cp.bdaddr, &e->data.bdaddr);\r\ncp.pscan_rep_mode = e->data.pscan_rep_mode;\r\ncp.pscan_mode = e->data.pscan_mode;\r\ncp.clock_offset = e->data.clock_offset;\r\nreturn hci_send_cmd(hdev, HCI_OP_REMOTE_NAME_REQ, sizeof(cp), &cp);\r\n}\r\nstatic bool hci_resolve_next_name(struct hci_dev *hdev)\r\n{\r\nstruct discovery_state *discov = &hdev->discovery;\r\nstruct inquiry_entry *e;\r\nif (list_empty(&discov->resolve))\r\nreturn false;\r\ne = hci_inquiry_cache_lookup_resolve(hdev, BDADDR_ANY, NAME_NEEDED);\r\nif (!e)\r\nreturn false;\r\nif (hci_resolve_name(hdev, e) == 0) {\r\ne->name_state = NAME_PENDING;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void hci_check_pending_name(struct hci_dev *hdev, struct hci_conn *conn,\r\nbdaddr_t *bdaddr, u8 *name, u8 name_len)\r\n{\r\nstruct discovery_state *discov = &hdev->discovery;\r\nstruct inquiry_entry *e;\r\nif (conn &&\r\n(conn->state == BT_CONFIG || conn->state == BT_CONNECTED) &&\r\n!test_and_set_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags))\r\nmgmt_device_connected(hdev, conn, 0, name, name_len);\r\nif (discov->state == DISCOVERY_STOPPED)\r\nreturn;\r\nif (discov->state == DISCOVERY_STOPPING)\r\ngoto discov_complete;\r\nif (discov->state != DISCOVERY_RESOLVING)\r\nreturn;\r\ne = hci_inquiry_cache_lookup_resolve(hdev, bdaddr, NAME_PENDING);\r\nif (!e)\r\nreturn;\r\nlist_del(&e->list);\r\nif (name) {\r\ne->name_state = NAME_KNOWN;\r\nmgmt_remote_name(hdev, bdaddr, ACL_LINK, 0x00,\r\ne->data.rssi, name, name_len);\r\n} else {\r\ne->name_state = NAME_NOT_KNOWN;\r\n}\r\nif (hci_resolve_next_name(hdev))\r\nreturn;\r\ndiscov_complete:\r\nhci_discovery_set_state(hdev, DISCOVERY_STOPPED);\r\n}\r\nstatic void hci_cs_remote_name_req(struct hci_dev *hdev, __u8 status)\r\n{\r\nstruct hci_cp_remote_name_req *cp;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (!status)\r\nreturn;\r\ncp = hci_sent_cmd_data(hdev, HCI_OP_REMOTE_NAME_REQ);\r\nif (!cp)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->bdaddr);\r\nif (hci_dev_test_flag(hdev, HCI_MGMT))\r\nhci_check_pending_name(hdev, conn, &cp->bdaddr, NULL, 0);\r\nif (!conn)\r\ngoto unlock;\r\nif (!hci_outgoing_auth_needed(hdev, conn))\r\ngoto unlock;\r\nif (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->flags)) {\r\nstruct hci_cp_auth_requested auth_cp;\r\nset_bit(HCI_CONN_AUTH_INITIATOR, &conn->flags);\r\nauth_cp.handle = __cpu_to_le16(conn->handle);\r\nhci_send_cmd(hdev, HCI_OP_AUTH_REQUESTED,\r\nsizeof(auth_cp), &auth_cp);\r\n}\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cs_read_remote_features(struct hci_dev *hdev, __u8 status)\r\n{\r\nstruct hci_cp_read_remote_features *cp;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (!status)\r\nreturn;\r\ncp = hci_sent_cmd_data(hdev, HCI_OP_READ_REMOTE_FEATURES);\r\nif (!cp)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(cp->handle));\r\nif (conn) {\r\nif (conn->state == BT_CONFIG) {\r\nhci_connect_cfm(conn, status);\r\nhci_conn_drop(conn);\r\n}\r\n}\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cs_read_remote_ext_features(struct hci_dev *hdev, __u8 status)\r\n{\r\nstruct hci_cp_read_remote_ext_features *cp;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (!status)\r\nreturn;\r\ncp = hci_sent_cmd_data(hdev, HCI_OP_READ_REMOTE_EXT_FEATURES);\r\nif (!cp)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(cp->handle));\r\nif (conn) {\r\nif (conn->state == BT_CONFIG) {\r\nhci_connect_cfm(conn, status);\r\nhci_conn_drop(conn);\r\n}\r\n}\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cs_setup_sync_conn(struct hci_dev *hdev, __u8 status)\r\n{\r\nstruct hci_cp_setup_sync_conn *cp;\r\nstruct hci_conn *acl, *sco;\r\n__u16 handle;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (!status)\r\nreturn;\r\ncp = hci_sent_cmd_data(hdev, HCI_OP_SETUP_SYNC_CONN);\r\nif (!cp)\r\nreturn;\r\nhandle = __le16_to_cpu(cp->handle);\r\nBT_DBG("%s handle 0x%4.4x", hdev->name, handle);\r\nhci_dev_lock(hdev);\r\nacl = hci_conn_hash_lookup_handle(hdev, handle);\r\nif (acl) {\r\nsco = acl->link;\r\nif (sco) {\r\nsco->state = BT_CLOSED;\r\nhci_connect_cfm(sco, status);\r\nhci_conn_del(sco);\r\n}\r\n}\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cs_sniff_mode(struct hci_dev *hdev, __u8 status)\r\n{\r\nstruct hci_cp_sniff_mode *cp;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (!status)\r\nreturn;\r\ncp = hci_sent_cmd_data(hdev, HCI_OP_SNIFF_MODE);\r\nif (!cp)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(cp->handle));\r\nif (conn) {\r\nclear_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->flags);\r\nif (test_and_clear_bit(HCI_CONN_SCO_SETUP_PEND, &conn->flags))\r\nhci_sco_setup(conn, status);\r\n}\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cs_exit_sniff_mode(struct hci_dev *hdev, __u8 status)\r\n{\r\nstruct hci_cp_exit_sniff_mode *cp;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (!status)\r\nreturn;\r\ncp = hci_sent_cmd_data(hdev, HCI_OP_EXIT_SNIFF_MODE);\r\nif (!cp)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(cp->handle));\r\nif (conn) {\r\nclear_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->flags);\r\nif (test_and_clear_bit(HCI_CONN_SCO_SETUP_PEND, &conn->flags))\r\nhci_sco_setup(conn, status);\r\n}\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cs_disconnect(struct hci_dev *hdev, u8 status)\r\n{\r\nstruct hci_cp_disconnect *cp;\r\nstruct hci_conn *conn;\r\nif (!status)\r\nreturn;\r\ncp = hci_sent_cmd_data(hdev, HCI_OP_DISCONNECT);\r\nif (!cp)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(cp->handle));\r\nif (conn)\r\nmgmt_disconnect_failed(hdev, &conn->dst, conn->type,\r\nconn->dst_type, status);\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cs_le_create_conn(struct hci_dev *hdev, u8 status)\r\n{\r\nstruct hci_cp_le_create_conn *cp;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (status)\r\nreturn;\r\ncp = hci_sent_cmd_data(hdev, HCI_OP_LE_CREATE_CONN);\r\nif (!cp)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_le(hdev, &cp->peer_addr,\r\ncp->peer_addr_type);\r\nif (!conn)\r\ngoto unlock;\r\nconn->init_addr_type = cp->own_address_type;\r\nif (cp->own_address_type == ADDR_LE_DEV_RANDOM)\r\nbacpy(&conn->init_addr, &hdev->random_addr);\r\nelse\r\nbacpy(&conn->init_addr, &hdev->bdaddr);\r\nconn->resp_addr_type = cp->peer_addr_type;\r\nbacpy(&conn->resp_addr, &cp->peer_addr);\r\nif (cp->filter_policy == HCI_LE_USE_PEER_ADDR)\r\nqueue_delayed_work(conn->hdev->workqueue,\r\n&conn->le_conn_timeout,\r\nconn->conn_timeout);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cs_le_read_remote_features(struct hci_dev *hdev, u8 status)\r\n{\r\nstruct hci_cp_le_read_remote_features *cp;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (!status)\r\nreturn;\r\ncp = hci_sent_cmd_data(hdev, HCI_OP_LE_READ_REMOTE_FEATURES);\r\nif (!cp)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(cp->handle));\r\nif (conn) {\r\nif (conn->state == BT_CONFIG) {\r\nhci_connect_cfm(conn, status);\r\nhci_conn_drop(conn);\r\n}\r\n}\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cs_le_start_enc(struct hci_dev *hdev, u8 status)\r\n{\r\nstruct hci_cp_le_start_enc *cp;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (!status)\r\nreturn;\r\nhci_dev_lock(hdev);\r\ncp = hci_sent_cmd_data(hdev, HCI_OP_LE_START_ENC);\r\nif (!cp)\r\ngoto unlock;\r\nconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(cp->handle));\r\nif (!conn)\r\ngoto unlock;\r\nif (conn->state != BT_CONNECTED)\r\ngoto unlock;\r\nhci_disconnect(conn, HCI_ERROR_AUTH_FAILURE);\r\nhci_conn_drop(conn);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cs_switch_role(struct hci_dev *hdev, u8 status)\r\n{\r\nstruct hci_cp_switch_role *cp;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nif (!status)\r\nreturn;\r\ncp = hci_sent_cmd_data(hdev, HCI_OP_SWITCH_ROLE);\r\nif (!cp)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->bdaddr);\r\nif (conn)\r\nclear_bit(HCI_CONN_RSWITCH_PEND, &conn->flags);\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_inquiry_complete_evt(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\n__u8 status = *((__u8 *) skb->data);\r\nstruct discovery_state *discov = &hdev->discovery;\r\nstruct inquiry_entry *e;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, status);\r\nhci_conn_check_pending(hdev);\r\nif (!test_and_clear_bit(HCI_INQUIRY, &hdev->flags))\r\nreturn;\r\nsmp_mb__after_atomic();\r\nwake_up_bit(&hdev->flags, HCI_INQUIRY);\r\nif (!hci_dev_test_flag(hdev, HCI_MGMT))\r\nreturn;\r\nhci_dev_lock(hdev);\r\nif (discov->state != DISCOVERY_FINDING)\r\ngoto unlock;\r\nif (list_empty(&discov->resolve)) {\r\nif (!hci_dev_test_flag(hdev, HCI_LE_SCAN) ||\r\n!test_bit(HCI_QUIRK_SIMULTANEOUS_DISCOVERY, &hdev->quirks))\r\nhci_discovery_set_state(hdev, DISCOVERY_STOPPED);\r\ngoto unlock;\r\n}\r\ne = hci_inquiry_cache_lookup_resolve(hdev, BDADDR_ANY, NAME_NEEDED);\r\nif (e && hci_resolve_name(hdev, e) == 0) {\r\ne->name_state = NAME_PENDING;\r\nhci_discovery_set_state(hdev, DISCOVERY_RESOLVING);\r\n} else {\r\nif (!hci_dev_test_flag(hdev, HCI_LE_SCAN) ||\r\n!test_bit(HCI_QUIRK_SIMULTANEOUS_DISCOVERY, &hdev->quirks))\r\nhci_discovery_set_state(hdev, DISCOVERY_STOPPED);\r\n}\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_inquiry_result_evt(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct inquiry_data data;\r\nstruct inquiry_info *info = (void *) (skb->data + 1);\r\nint num_rsp = *((__u8 *) skb->data);\r\nBT_DBG("%s num_rsp %d", hdev->name, num_rsp);\r\nif (!num_rsp)\r\nreturn;\r\nif (hci_dev_test_flag(hdev, HCI_PERIODIC_INQ))\r\nreturn;\r\nhci_dev_lock(hdev);\r\nfor (; num_rsp; num_rsp--, info++) {\r\nu32 flags;\r\nbacpy(&data.bdaddr, &info->bdaddr);\r\ndata.pscan_rep_mode = info->pscan_rep_mode;\r\ndata.pscan_period_mode = info->pscan_period_mode;\r\ndata.pscan_mode = info->pscan_mode;\r\nmemcpy(data.dev_class, info->dev_class, 3);\r\ndata.clock_offset = info->clock_offset;\r\ndata.rssi = HCI_RSSI_INVALID;\r\ndata.ssp_mode = 0x00;\r\nflags = hci_inquiry_cache_update(hdev, &data, false);\r\nmgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,\r\ninfo->dev_class, HCI_RSSI_INVALID,\r\nflags, NULL, 0, NULL, 0);\r\n}\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_conn_complete_evt(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_ev_conn_complete *ev = (void *) skb->data;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s", hdev->name);\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_ba(hdev, ev->link_type, &ev->bdaddr);\r\nif (!conn) {\r\nif (ev->link_type != SCO_LINK)\r\ngoto unlock;\r\nconn = hci_conn_hash_lookup_ba(hdev, ESCO_LINK, &ev->bdaddr);\r\nif (!conn)\r\ngoto unlock;\r\nconn->type = SCO_LINK;\r\n}\r\nif (!ev->status) {\r\nconn->handle = __le16_to_cpu(ev->handle);\r\nif (conn->type == ACL_LINK) {\r\nconn->state = BT_CONFIG;\r\nhci_conn_hold(conn);\r\nif (!conn->out && !hci_conn_ssp_enabled(conn) &&\r\n!hci_find_link_key(hdev, &ev->bdaddr))\r\nconn->disc_timeout = HCI_PAIRING_TIMEOUT;\r\nelse\r\nconn->disc_timeout = HCI_DISCONN_TIMEOUT;\r\n} else\r\nconn->state = BT_CONNECTED;\r\nhci_debugfs_create_conn(conn);\r\nhci_conn_add_sysfs(conn);\r\nif (test_bit(HCI_AUTH, &hdev->flags))\r\nset_bit(HCI_CONN_AUTH, &conn->flags);\r\nif (test_bit(HCI_ENCRYPT, &hdev->flags))\r\nset_bit(HCI_CONN_ENCRYPT, &conn->flags);\r\nif (conn->type == ACL_LINK) {\r\nstruct hci_cp_read_remote_features cp;\r\ncp.handle = ev->handle;\r\nhci_send_cmd(hdev, HCI_OP_READ_REMOTE_FEATURES,\r\nsizeof(cp), &cp);\r\nhci_req_update_scan(hdev);\r\n}\r\nif (!conn->out && hdev->hci_ver < BLUETOOTH_VER_2_0) {\r\nstruct hci_cp_change_conn_ptype cp;\r\ncp.handle = ev->handle;\r\ncp.pkt_type = cpu_to_le16(conn->pkt_type);\r\nhci_send_cmd(hdev, HCI_OP_CHANGE_CONN_PTYPE, sizeof(cp),\r\n&cp);\r\n}\r\n} else {\r\nconn->state = BT_CLOSED;\r\nif (conn->type == ACL_LINK)\r\nmgmt_connect_failed(hdev, &conn->dst, conn->type,\r\nconn->dst_type, ev->status);\r\n}\r\nif (conn->type == ACL_LINK)\r\nhci_sco_setup(conn, ev->status);\r\nif (ev->status) {\r\nhci_connect_cfm(conn, ev->status);\r\nhci_conn_del(conn);\r\n} else if (ev->link_type != ACL_LINK)\r\nhci_connect_cfm(conn, ev->status);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\nhci_conn_check_pending(hdev);\r\n}\r\nstatic void hci_reject_conn(struct hci_dev *hdev, bdaddr_t *bdaddr)\r\n{\r\nstruct hci_cp_reject_conn_req cp;\r\nbacpy(&cp.bdaddr, bdaddr);\r\ncp.reason = HCI_ERROR_REJ_BAD_ADDR;\r\nhci_send_cmd(hdev, HCI_OP_REJECT_CONN_REQ, sizeof(cp), &cp);\r\n}\r\nstatic void hci_conn_request_evt(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_ev_conn_request *ev = (void *) skb->data;\r\nint mask = hdev->link_mode;\r\nstruct inquiry_entry *ie;\r\nstruct hci_conn *conn;\r\n__u8 flags = 0;\r\nBT_DBG("%s bdaddr %pMR type 0x%x", hdev->name, &ev->bdaddr,\r\nev->link_type);\r\nmask |= hci_proto_connect_ind(hdev, &ev->bdaddr, ev->link_type,\r\n&flags);\r\nif (!(mask & HCI_LM_ACCEPT)) {\r\nhci_reject_conn(hdev, &ev->bdaddr);\r\nreturn;\r\n}\r\nif (hci_bdaddr_list_lookup(&hdev->blacklist, &ev->bdaddr,\r\nBDADDR_BREDR)) {\r\nhci_reject_conn(hdev, &ev->bdaddr);\r\nreturn;\r\n}\r\nif (hci_dev_test_flag(hdev, HCI_MGMT) &&\r\n!hci_dev_test_flag(hdev, HCI_CONNECTABLE) &&\r\n!hci_bdaddr_list_lookup(&hdev->whitelist, &ev->bdaddr,\r\nBDADDR_BREDR)) {\r\nhci_reject_conn(hdev, &ev->bdaddr);\r\nreturn;\r\n}\r\nhci_dev_lock(hdev);\r\nie = hci_inquiry_cache_lookup(hdev, &ev->bdaddr);\r\nif (ie)\r\nmemcpy(ie->data.dev_class, ev->dev_class, 3);\r\nconn = hci_conn_hash_lookup_ba(hdev, ev->link_type,\r\n&ev->bdaddr);\r\nif (!conn) {\r\nconn = hci_conn_add(hdev, ev->link_type, &ev->bdaddr,\r\nHCI_ROLE_SLAVE);\r\nif (!conn) {\r\nBT_ERR("No memory for new connection");\r\nhci_dev_unlock(hdev);\r\nreturn;\r\n}\r\n}\r\nmemcpy(conn->dev_class, ev->dev_class, 3);\r\nhci_dev_unlock(hdev);\r\nif (ev->link_type == ACL_LINK ||\r\n(!(flags & HCI_PROTO_DEFER) && !lmp_esco_capable(hdev))) {\r\nstruct hci_cp_accept_conn_req cp;\r\nconn->state = BT_CONNECT;\r\nbacpy(&cp.bdaddr, &ev->bdaddr);\r\nif (lmp_rswitch_capable(hdev) && (mask & HCI_LM_MASTER))\r\ncp.role = 0x00;\r\nelse\r\ncp.role = 0x01;\r\nhci_send_cmd(hdev, HCI_OP_ACCEPT_CONN_REQ, sizeof(cp), &cp);\r\n} else if (!(flags & HCI_PROTO_DEFER)) {\r\nstruct hci_cp_accept_sync_conn_req cp;\r\nconn->state = BT_CONNECT;\r\nbacpy(&cp.bdaddr, &ev->bdaddr);\r\ncp.pkt_type = cpu_to_le16(conn->pkt_type);\r\ncp.tx_bandwidth = cpu_to_le32(0x00001f40);\r\ncp.rx_bandwidth = cpu_to_le32(0x00001f40);\r\ncp.max_latency = cpu_to_le16(0xffff);\r\ncp.content_format = cpu_to_le16(hdev->voice_setting);\r\ncp.retrans_effort = 0xff;\r\nhci_send_cmd(hdev, HCI_OP_ACCEPT_SYNC_CONN_REQ, sizeof(cp),\r\n&cp);\r\n} else {\r\nconn->state = BT_CONNECT2;\r\nhci_connect_cfm(conn, 0);\r\n}\r\n}\r\nstatic u8 hci_to_mgmt_reason(u8 err)\r\n{\r\nswitch (err) {\r\ncase HCI_ERROR_CONNECTION_TIMEOUT:\r\nreturn MGMT_DEV_DISCONN_TIMEOUT;\r\ncase HCI_ERROR_REMOTE_USER_TERM:\r\ncase HCI_ERROR_REMOTE_LOW_RESOURCES:\r\ncase HCI_ERROR_REMOTE_POWER_OFF:\r\nreturn MGMT_DEV_DISCONN_REMOTE;\r\ncase HCI_ERROR_LOCAL_HOST_TERM:\r\nreturn MGMT_DEV_DISCONN_LOCAL_HOST;\r\ndefault:\r\nreturn MGMT_DEV_DISCONN_UNKNOWN;\r\n}\r\n}\r\nstatic void hci_disconn_complete_evt(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_ev_disconn_complete *ev = (void *) skb->data;\r\nu8 reason;\r\nstruct hci_conn_params *params;\r\nstruct hci_conn *conn;\r\nbool mgmt_connected;\r\nu8 type;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, ev->status);\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));\r\nif (!conn)\r\ngoto unlock;\r\nif (ev->status) {\r\nmgmt_disconnect_failed(hdev, &conn->dst, conn->type,\r\nconn->dst_type, ev->status);\r\ngoto unlock;\r\n}\r\nconn->state = BT_CLOSED;\r\nmgmt_connected = test_and_clear_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags);\r\nif (test_bit(HCI_CONN_AUTH_FAILURE, &conn->flags))\r\nreason = MGMT_DEV_DISCONN_AUTH_FAILURE;\r\nelse\r\nreason = hci_to_mgmt_reason(ev->reason);\r\nmgmt_device_disconnected(hdev, &conn->dst, conn->type, conn->dst_type,\r\nreason, mgmt_connected);\r\nif (conn->type == ACL_LINK) {\r\nif (test_bit(HCI_CONN_FLUSH_KEY, &conn->flags))\r\nhci_remove_link_key(hdev, &conn->dst);\r\nhci_req_update_scan(hdev);\r\n}\r\nparams = hci_conn_params_lookup(hdev, &conn->dst, conn->dst_type);\r\nif (params) {\r\nswitch (params->auto_connect) {\r\ncase HCI_AUTO_CONN_LINK_LOSS:\r\nif (ev->reason != HCI_ERROR_CONNECTION_TIMEOUT)\r\nbreak;\r\ncase HCI_AUTO_CONN_DIRECT:\r\ncase HCI_AUTO_CONN_ALWAYS:\r\nlist_del_init(&params->action);\r\nlist_add(&params->action, &hdev->pend_le_conns);\r\nhci_update_background_scan(hdev);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\ntype = conn->type;\r\nhci_disconn_cfm(conn, ev->reason);\r\nhci_conn_del(conn);\r\nif (type == LE_LINK)\r\nhci_req_reenable_advertising(hdev);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_auth_complete_evt(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_ev_auth_complete *ev = (void *) skb->data;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, ev->status);\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));\r\nif (!conn)\r\ngoto unlock;\r\nif (!ev->status) {\r\nclear_bit(HCI_CONN_AUTH_FAILURE, &conn->flags);\r\nif (!hci_conn_ssp_enabled(conn) &&\r\ntest_bit(HCI_CONN_REAUTH_PEND, &conn->flags)) {\r\nBT_INFO("re-auth of legacy device is not possible.");\r\n} else {\r\nset_bit(HCI_CONN_AUTH, &conn->flags);\r\nconn->sec_level = conn->pending_sec_level;\r\n}\r\n} else {\r\nif (ev->status == HCI_ERROR_PIN_OR_KEY_MISSING)\r\nset_bit(HCI_CONN_AUTH_FAILURE, &conn->flags);\r\nmgmt_auth_failed(conn, ev->status);\r\n}\r\nclear_bit(HCI_CONN_AUTH_PEND, &conn->flags);\r\nclear_bit(HCI_CONN_REAUTH_PEND, &conn->flags);\r\nif (conn->state == BT_CONFIG) {\r\nif (!ev->status && hci_conn_ssp_enabled(conn)) {\r\nstruct hci_cp_set_conn_encrypt cp;\r\ncp.handle = ev->handle;\r\ncp.encrypt = 0x01;\r\nhci_send_cmd(hdev, HCI_OP_SET_CONN_ENCRYPT, sizeof(cp),\r\n&cp);\r\n} else {\r\nconn->state = BT_CONNECTED;\r\nhci_connect_cfm(conn, ev->status);\r\nhci_conn_drop(conn);\r\n}\r\n} else {\r\nhci_auth_cfm(conn, ev->status);\r\nhci_conn_hold(conn);\r\nconn->disc_timeout = HCI_DISCONN_TIMEOUT;\r\nhci_conn_drop(conn);\r\n}\r\nif (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags)) {\r\nif (!ev->status) {\r\nstruct hci_cp_set_conn_encrypt cp;\r\ncp.handle = ev->handle;\r\ncp.encrypt = 0x01;\r\nhci_send_cmd(hdev, HCI_OP_SET_CONN_ENCRYPT, sizeof(cp),\r\n&cp);\r\n} else {\r\nclear_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags);\r\nhci_encrypt_cfm(conn, ev->status, 0x00);\r\n}\r\n}\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_remote_name_evt(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_ev_remote_name *ev = (void *) skb->data;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s", hdev->name);\r\nhci_conn_check_pending(hdev);\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);\r\nif (!hci_dev_test_flag(hdev, HCI_MGMT))\r\ngoto check_auth;\r\nif (ev->status == 0)\r\nhci_check_pending_name(hdev, conn, &ev->bdaddr, ev->name,\r\nstrnlen(ev->name, HCI_MAX_NAME_LENGTH));\r\nelse\r\nhci_check_pending_name(hdev, conn, &ev->bdaddr, NULL, 0);\r\ncheck_auth:\r\nif (!conn)\r\ngoto unlock;\r\nif (!hci_outgoing_auth_needed(hdev, conn))\r\ngoto unlock;\r\nif (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->flags)) {\r\nstruct hci_cp_auth_requested cp;\r\nset_bit(HCI_CONN_AUTH_INITIATOR, &conn->flags);\r\ncp.handle = __cpu_to_le16(conn->handle);\r\nhci_send_cmd(hdev, HCI_OP_AUTH_REQUESTED, sizeof(cp), &cp);\r\n}\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void read_enc_key_size_complete(struct hci_dev *hdev, u8 status,\r\nu16 opcode, struct sk_buff *skb)\r\n{\r\nconst struct hci_rp_read_enc_key_size *rp;\r\nstruct hci_conn *conn;\r\nu16 handle;\r\nBT_DBG("%s status 0x%02x", hdev->name, status);\r\nif (!skb || skb->len < sizeof(*rp)) {\r\nBT_ERR("%s invalid HCI Read Encryption Key Size response",\r\nhdev->name);\r\nreturn;\r\n}\r\nrp = (void *)skb->data;\r\nhandle = le16_to_cpu(rp->handle);\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_handle(hdev, handle);\r\nif (!conn)\r\ngoto unlock;\r\nif (rp->status) {\r\nBT_ERR("%s failed to read key size for handle %u", hdev->name,\r\nhandle);\r\nconn->enc_key_size = HCI_LINK_KEY_SIZE;\r\n} else {\r\nconn->enc_key_size = rp->key_size;\r\n}\r\nif (conn->state == BT_CONFIG) {\r\nconn->state = BT_CONNECTED;\r\nhci_connect_cfm(conn, 0);\r\nhci_conn_drop(conn);\r\n} else {\r\nu8 encrypt;\r\nif (!test_bit(HCI_CONN_ENCRYPT, &conn->flags))\r\nencrypt = 0x00;\r\nelse if (test_bit(HCI_CONN_AES_CCM, &conn->flags))\r\nencrypt = 0x02;\r\nelse\r\nencrypt = 0x01;\r\nhci_encrypt_cfm(conn, 0, encrypt);\r\n}\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_encrypt_change_evt(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_ev_encrypt_change *ev = (void *) skb->data;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, ev->status);\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));\r\nif (!conn)\r\ngoto unlock;\r\nif (!ev->status) {\r\nif (ev->encrypt) {\r\nset_bit(HCI_CONN_AUTH, &conn->flags);\r\nset_bit(HCI_CONN_ENCRYPT, &conn->flags);\r\nconn->sec_level = conn->pending_sec_level;\r\nif (conn->key_type == HCI_LK_AUTH_COMBINATION_P256)\r\nset_bit(HCI_CONN_FIPS, &conn->flags);\r\nif ((conn->type == ACL_LINK && ev->encrypt == 0x02) ||\r\nconn->type == LE_LINK)\r\nset_bit(HCI_CONN_AES_CCM, &conn->flags);\r\n} else {\r\nclear_bit(HCI_CONN_ENCRYPT, &conn->flags);\r\nclear_bit(HCI_CONN_AES_CCM, &conn->flags);\r\n}\r\n}\r\nif (ev->status && conn->type == LE_LINK)\r\nhci_dev_set_flag(hdev, HCI_RPA_EXPIRED);\r\nclear_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags);\r\nif (ev->status && conn->state == BT_CONNECTED) {\r\nif (ev->status == HCI_ERROR_PIN_OR_KEY_MISSING)\r\nset_bit(HCI_CONN_AUTH_FAILURE, &conn->flags);\r\nhci_disconnect(conn, HCI_ERROR_AUTH_FAILURE);\r\nhci_conn_drop(conn);\r\ngoto unlock;\r\n}\r\nif (hci_dev_test_flag(hdev, HCI_SC_ONLY) &&\r\n(!test_bit(HCI_CONN_AES_CCM, &conn->flags) ||\r\nconn->key_type != HCI_LK_AUTH_COMBINATION_P256)) {\r\nhci_connect_cfm(conn, HCI_ERROR_AUTH_FAILURE);\r\nhci_conn_drop(conn);\r\ngoto unlock;\r\n}\r\nif (!ev->status && ev->encrypt && conn->type == ACL_LINK) {\r\nstruct hci_cp_read_enc_key_size cp;\r\nstruct hci_request req;\r\nif (!(hdev->commands[20] & 0x10)) {\r\nconn->enc_key_size = HCI_LINK_KEY_SIZE;\r\ngoto notify;\r\n}\r\nhci_req_init(&req, hdev);\r\ncp.handle = cpu_to_le16(conn->handle);\r\nhci_req_add(&req, HCI_OP_READ_ENC_KEY_SIZE, sizeof(cp), &cp);\r\nif (hci_req_run_skb(&req, read_enc_key_size_complete)) {\r\nBT_ERR("Sending HCI Read Encryption Key Size failed");\r\nconn->enc_key_size = HCI_LINK_KEY_SIZE;\r\ngoto notify;\r\n}\r\ngoto unlock;\r\n}\r\nnotify:\r\nif (conn->state == BT_CONFIG) {\r\nif (!ev->status)\r\nconn->state = BT_CONNECTED;\r\nhci_connect_cfm(conn, ev->status);\r\nhci_conn_drop(conn);\r\n} else\r\nhci_encrypt_cfm(conn, ev->status, ev->encrypt);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_change_link_key_complete_evt(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_ev_change_link_key_complete *ev = (void *) skb->data;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, ev->status);\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));\r\nif (conn) {\r\nif (!ev->status)\r\nset_bit(HCI_CONN_SECURE, &conn->flags);\r\nclear_bit(HCI_CONN_AUTH_PEND, &conn->flags);\r\nhci_key_change_cfm(conn, ev->status);\r\n}\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_remote_features_evt(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_ev_remote_features *ev = (void *) skb->data;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, ev->status);\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));\r\nif (!conn)\r\ngoto unlock;\r\nif (!ev->status)\r\nmemcpy(conn->features[0], ev->features, 8);\r\nif (conn->state != BT_CONFIG)\r\ngoto unlock;\r\nif (!ev->status && lmp_ext_feat_capable(hdev) &&\r\nlmp_ext_feat_capable(conn)) {\r\nstruct hci_cp_read_remote_ext_features cp;\r\ncp.handle = ev->handle;\r\ncp.page = 0x01;\r\nhci_send_cmd(hdev, HCI_OP_READ_REMOTE_EXT_FEATURES,\r\nsizeof(cp), &cp);\r\ngoto unlock;\r\n}\r\nif (!ev->status && !test_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags)) {\r\nstruct hci_cp_remote_name_req cp;\r\nmemset(&cp, 0, sizeof(cp));\r\nbacpy(&cp.bdaddr, &conn->dst);\r\ncp.pscan_rep_mode = 0x02;\r\nhci_send_cmd(hdev, HCI_OP_REMOTE_NAME_REQ, sizeof(cp), &cp);\r\n} else if (!test_and_set_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags))\r\nmgmt_device_connected(hdev, conn, 0, NULL, 0);\r\nif (!hci_outgoing_auth_needed(hdev, conn)) {\r\nconn->state = BT_CONNECTED;\r\nhci_connect_cfm(conn, ev->status);\r\nhci_conn_drop(conn);\r\n}\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_cmd_complete_evt(struct hci_dev *hdev, struct sk_buff *skb,\r\nu16 *opcode, u8 *status,\r\nhci_req_complete_t *req_complete,\r\nhci_req_complete_skb_t *req_complete_skb)\r\n{\r\nstruct hci_ev_cmd_complete *ev = (void *) skb->data;\r\n*opcode = __le16_to_cpu(ev->opcode);\r\n*status = skb->data[sizeof(*ev)];\r\nskb_pull(skb, sizeof(*ev));\r\nswitch (*opcode) {\r\ncase HCI_OP_INQUIRY_CANCEL:\r\nhci_cc_inquiry_cancel(hdev, skb);\r\nbreak;\r\ncase HCI_OP_PERIODIC_INQ:\r\nhci_cc_periodic_inq(hdev, skb);\r\nbreak;\r\ncase HCI_OP_EXIT_PERIODIC_INQ:\r\nhci_cc_exit_periodic_inq(hdev, skb);\r\nbreak;\r\ncase HCI_OP_REMOTE_NAME_REQ_CANCEL:\r\nhci_cc_remote_name_req_cancel(hdev, skb);\r\nbreak;\r\ncase HCI_OP_ROLE_DISCOVERY:\r\nhci_cc_role_discovery(hdev, skb);\r\nbreak;\r\ncase HCI_OP_READ_LINK_POLICY:\r\nhci_cc_read_link_policy(hdev, skb);\r\nbreak;\r\ncase HCI_OP_WRITE_LINK_POLICY:\r\nhci_cc_write_link_policy(hdev, skb);\r\nbreak;\r\ncase HCI_OP_READ_DEF_LINK_POLICY:\r\nhci_cc_read_def_link_policy(hdev, skb);\r\nbreak;\r\ncase HCI_OP_WRITE_DEF_LINK_POLICY:\r\nhci_cc_write_def_link_policy(hdev, skb);\r\nbreak;\r\ncase HCI_OP_RESET:\r\nhci_cc_reset(hdev, skb);\r\nbreak;\r\ncase HCI_OP_READ_STORED_LINK_KEY:\r\nhci_cc_read_stored_link_key(hdev, skb);\r\nbreak;\r\ncase HCI_OP_DELETE_STORED_LINK_KEY:\r\nhci_cc_delete_stored_link_key(hdev, skb);\r\nbreak;\r\ncase HCI_OP_WRITE_LOCAL_NAME:\r\nhci_cc_write_local_name(hdev, skb);\r\nbreak;\r\ncase HCI_OP_READ_LOCAL_NAME:\r\nhci_cc_read_local_name(hdev, skb);\r\nbreak;\r\ncase HCI_OP_WRITE_AUTH_ENABLE:\r\nhci_cc_write_auth_enable(hdev, skb);\r\nbreak;\r\ncase HCI_OP_WRITE_ENCRYPT_MODE:\r\nhci_cc_write_encrypt_mode(hdev, skb);\r\nbreak;\r\ncase HCI_OP_WRITE_SCAN_ENABLE:\r\nhci_cc_write_scan_enable(hdev, skb);\r\nbreak;\r\ncase HCI_OP_READ_CLASS_OF_DEV:\r\nhci_cc_read_class_of_dev(hdev, skb);\r\nbreak;\r\ncase HCI_OP_WRITE_CLASS_OF_DEV:\r\nhci_cc_write_class_of_dev(hdev, skb);\r\nbreak;\r\ncase HCI_OP_READ_VOICE_SETTING:\r\nhci_cc_read_voice_setting(hdev, skb);\r\nbreak;\r\ncase HCI_OP_WRITE_VOICE_SETTING:\r\nhci_cc_write_voice_setting(hdev, skb);\r\nbreak;\r\ncase HCI_OP_READ_NUM_SUPPORTED_IAC:\r\nhci_cc_read_num_supported_iac(hdev, skb);\r\nbreak;\r\ncase HCI_OP_WRITE_SSP_MODE:\r\nhci_cc_write_ssp_mode(hdev, skb);\r\nbreak;\r\ncase HCI_OP_WRITE_SC_SUPPORT:\r\nhci_cc_write_sc_support(hdev, skb);\r\nbreak;\r\ncase HCI_OP_READ_LOCAL_VERSION:\r\nhci_cc_read_local_version(hdev, skb);\r\nbreak;\r\ncase HCI_OP_READ_LOCAL_COMMANDS:\r\nhci_cc_read_local_commands(hdev, skb);\r\nbreak;\r\ncase HCI_OP_READ_LOCAL_FEATURES:\r\nhci_cc_read_local_features(hdev, skb);\r\nbreak;\r\ncase HCI_OP_READ_LOCAL_EXT_FEATURES:\r\nhci_cc_read_local_ext_features(hdev, skb);\r\nbreak;\r\ncase HCI_OP_READ_BUFFER_SIZE:\r\nhci_cc_read_buffer_size(hdev, skb);\r\nbreak;\r\ncase HCI_OP_READ_BD_ADDR:\r\nhci_cc_read_bd_addr(hdev, skb);\r\nbreak;\r\ncase HCI_OP_READ_PAGE_SCAN_ACTIVITY:\r\nhci_cc_read_page_scan_activity(hdev, skb);\r\nbreak;\r\ncase HCI_OP_WRITE_PAGE_SCAN_ACTIVITY:\r\nhci_cc_write_page_scan_activity(hdev, skb);\r\nbreak;\r\ncase HCI_OP_READ_PAGE_SCAN_TYPE:\r\nhci_cc_read_page_scan_type(hdev, skb);\r\nbreak;\r\ncase HCI_OP_WRITE_PAGE_SCAN_TYPE:\r\nhci_cc_write_page_scan_type(hdev, skb);\r\nbreak;\r\ncase HCI_OP_READ_DATA_BLOCK_SIZE:\r\nhci_cc_read_data_block_size(hdev, skb);\r\nbreak;\r\ncase HCI_OP_READ_FLOW_CONTROL_MODE:\r\nhci_cc_read_flow_control_mode(hdev, skb);\r\nbreak;\r\ncase HCI_OP_READ_LOCAL_AMP_INFO:\r\nhci_cc_read_local_amp_info(hdev, skb);\r\nbreak;\r\ncase HCI_OP_READ_CLOCK:\r\nhci_cc_read_clock(hdev, skb);\r\nbreak;\r\ncase HCI_OP_READ_INQ_RSP_TX_POWER:\r\nhci_cc_read_inq_rsp_tx_power(hdev, skb);\r\nbreak;\r\ncase HCI_OP_PIN_CODE_REPLY:\r\nhci_cc_pin_code_reply(hdev, skb);\r\nbreak;\r\ncase HCI_OP_PIN_CODE_NEG_REPLY:\r\nhci_cc_pin_code_neg_reply(hdev, skb);\r\nbreak;\r\ncase HCI_OP_READ_LOCAL_OOB_DATA:\r\nhci_cc_read_local_oob_data(hdev, skb);\r\nbreak;\r\ncase HCI_OP_READ_LOCAL_OOB_EXT_DATA:\r\nhci_cc_read_local_oob_ext_data(hdev, skb);\r\nbreak;\r\ncase HCI_OP_LE_READ_BUFFER_SIZE:\r\nhci_cc_le_read_buffer_size(hdev, skb);\r\nbreak;\r\ncase HCI_OP_LE_READ_LOCAL_FEATURES:\r\nhci_cc_le_read_local_features(hdev, skb);\r\nbreak;\r\ncase HCI_OP_LE_READ_ADV_TX_POWER:\r\nhci_cc_le_read_adv_tx_power(hdev, skb);\r\nbreak;\r\ncase HCI_OP_USER_CONFIRM_REPLY:\r\nhci_cc_user_confirm_reply(hdev, skb);\r\nbreak;\r\ncase HCI_OP_USER_CONFIRM_NEG_REPLY:\r\nhci_cc_user_confirm_neg_reply(hdev, skb);\r\nbreak;\r\ncase HCI_OP_USER_PASSKEY_REPLY:\r\nhci_cc_user_passkey_reply(hdev, skb);\r\nbreak;\r\ncase HCI_OP_USER_PASSKEY_NEG_REPLY:\r\nhci_cc_user_passkey_neg_reply(hdev, skb);\r\nbreak;\r\ncase HCI_OP_LE_SET_RANDOM_ADDR:\r\nhci_cc_le_set_random_addr(hdev, skb);\r\nbreak;\r\ncase HCI_OP_LE_SET_ADV_ENABLE:\r\nhci_cc_le_set_adv_enable(hdev, skb);\r\nbreak;\r\ncase HCI_OP_LE_SET_SCAN_PARAM:\r\nhci_cc_le_set_scan_param(hdev, skb);\r\nbreak;\r\ncase HCI_OP_LE_SET_SCAN_ENABLE:\r\nhci_cc_le_set_scan_enable(hdev, skb);\r\nbreak;\r\ncase HCI_OP_LE_READ_WHITE_LIST_SIZE:\r\nhci_cc_le_read_white_list_size(hdev, skb);\r\nbreak;\r\ncase HCI_OP_LE_CLEAR_WHITE_LIST:\r\nhci_cc_le_clear_white_list(hdev, skb);\r\nbreak;\r\ncase HCI_OP_LE_ADD_TO_WHITE_LIST:\r\nhci_cc_le_add_to_white_list(hdev, skb);\r\nbreak;\r\ncase HCI_OP_LE_DEL_FROM_WHITE_LIST:\r\nhci_cc_le_del_from_white_list(hdev, skb);\r\nbreak;\r\ncase HCI_OP_LE_READ_SUPPORTED_STATES:\r\nhci_cc_le_read_supported_states(hdev, skb);\r\nbreak;\r\ncase HCI_OP_LE_READ_DEF_DATA_LEN:\r\nhci_cc_le_read_def_data_len(hdev, skb);\r\nbreak;\r\ncase HCI_OP_LE_WRITE_DEF_DATA_LEN:\r\nhci_cc_le_write_def_data_len(hdev, skb);\r\nbreak;\r\ncase HCI_OP_LE_READ_MAX_DATA_LEN:\r\nhci_cc_le_read_max_data_len(hdev, skb);\r\nbreak;\r\ncase HCI_OP_WRITE_LE_HOST_SUPPORTED:\r\nhci_cc_write_le_host_supported(hdev, skb);\r\nbreak;\r\ncase HCI_OP_LE_SET_ADV_PARAM:\r\nhci_cc_set_adv_param(hdev, skb);\r\nbreak;\r\ncase HCI_OP_READ_RSSI:\r\nhci_cc_read_rssi(hdev, skb);\r\nbreak;\r\ncase HCI_OP_READ_TX_POWER:\r\nhci_cc_read_tx_power(hdev, skb);\r\nbreak;\r\ncase HCI_OP_WRITE_SSP_DEBUG_MODE:\r\nhci_cc_write_ssp_debug_mode(hdev, skb);\r\nbreak;\r\ndefault:\r\nBT_DBG("%s opcode 0x%4.4x", hdev->name, *opcode);\r\nbreak;\r\n}\r\nif (*opcode != HCI_OP_NOP)\r\ncancel_delayed_work(&hdev->cmd_timer);\r\nif (ev->ncmd && !test_bit(HCI_RESET, &hdev->flags))\r\natomic_set(&hdev->cmd_cnt, 1);\r\nhci_req_cmd_complete(hdev, *opcode, *status, req_complete,\r\nreq_complete_skb);\r\nif (atomic_read(&hdev->cmd_cnt) && !skb_queue_empty(&hdev->cmd_q))\r\nqueue_work(hdev->workqueue, &hdev->cmd_work);\r\n}\r\nstatic void hci_cmd_status_evt(struct hci_dev *hdev, struct sk_buff *skb,\r\nu16 *opcode, u8 *status,\r\nhci_req_complete_t *req_complete,\r\nhci_req_complete_skb_t *req_complete_skb)\r\n{\r\nstruct hci_ev_cmd_status *ev = (void *) skb->data;\r\nskb_pull(skb, sizeof(*ev));\r\n*opcode = __le16_to_cpu(ev->opcode);\r\n*status = ev->status;\r\nswitch (*opcode) {\r\ncase HCI_OP_INQUIRY:\r\nhci_cs_inquiry(hdev, ev->status);\r\nbreak;\r\ncase HCI_OP_CREATE_CONN:\r\nhci_cs_create_conn(hdev, ev->status);\r\nbreak;\r\ncase HCI_OP_DISCONNECT:\r\nhci_cs_disconnect(hdev, ev->status);\r\nbreak;\r\ncase HCI_OP_ADD_SCO:\r\nhci_cs_add_sco(hdev, ev->status);\r\nbreak;\r\ncase HCI_OP_AUTH_REQUESTED:\r\nhci_cs_auth_requested(hdev, ev->status);\r\nbreak;\r\ncase HCI_OP_SET_CONN_ENCRYPT:\r\nhci_cs_set_conn_encrypt(hdev, ev->status);\r\nbreak;\r\ncase HCI_OP_REMOTE_NAME_REQ:\r\nhci_cs_remote_name_req(hdev, ev->status);\r\nbreak;\r\ncase HCI_OP_READ_REMOTE_FEATURES:\r\nhci_cs_read_remote_features(hdev, ev->status);\r\nbreak;\r\ncase HCI_OP_READ_REMOTE_EXT_FEATURES:\r\nhci_cs_read_remote_ext_features(hdev, ev->status);\r\nbreak;\r\ncase HCI_OP_SETUP_SYNC_CONN:\r\nhci_cs_setup_sync_conn(hdev, ev->status);\r\nbreak;\r\ncase HCI_OP_SNIFF_MODE:\r\nhci_cs_sniff_mode(hdev, ev->status);\r\nbreak;\r\ncase HCI_OP_EXIT_SNIFF_MODE:\r\nhci_cs_exit_sniff_mode(hdev, ev->status);\r\nbreak;\r\ncase HCI_OP_SWITCH_ROLE:\r\nhci_cs_switch_role(hdev, ev->status);\r\nbreak;\r\ncase HCI_OP_LE_CREATE_CONN:\r\nhci_cs_le_create_conn(hdev, ev->status);\r\nbreak;\r\ncase HCI_OP_LE_READ_REMOTE_FEATURES:\r\nhci_cs_le_read_remote_features(hdev, ev->status);\r\nbreak;\r\ncase HCI_OP_LE_START_ENC:\r\nhci_cs_le_start_enc(hdev, ev->status);\r\nbreak;\r\ndefault:\r\nBT_DBG("%s opcode 0x%4.4x", hdev->name, *opcode);\r\nbreak;\r\n}\r\nif (*opcode != HCI_OP_NOP)\r\ncancel_delayed_work(&hdev->cmd_timer);\r\nif (ev->ncmd && !test_bit(HCI_RESET, &hdev->flags))\r\natomic_set(&hdev->cmd_cnt, 1);\r\nif (ev->status ||\r\n(hdev->sent_cmd && !bt_cb(hdev->sent_cmd)->hci.req_event))\r\nhci_req_cmd_complete(hdev, *opcode, ev->status, req_complete,\r\nreq_complete_skb);\r\nif (atomic_read(&hdev->cmd_cnt) && !skb_queue_empty(&hdev->cmd_q))\r\nqueue_work(hdev->workqueue, &hdev->cmd_work);\r\n}\r\nstatic void hci_hardware_error_evt(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_ev_hardware_error *ev = (void *) skb->data;\r\nhdev->hw_error_code = ev->code;\r\nqueue_work(hdev->req_workqueue, &hdev->error_reset);\r\n}\r\nstatic void hci_role_change_evt(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_ev_role_change *ev = (void *) skb->data;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, ev->status);\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);\r\nif (conn) {\r\nif (!ev->status)\r\nconn->role = ev->role;\r\nclear_bit(HCI_CONN_RSWITCH_PEND, &conn->flags);\r\nhci_role_switch_cfm(conn, ev->status, ev->role);\r\n}\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_num_comp_pkts_evt(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_ev_num_comp_pkts *ev = (void *) skb->data;\r\nint i;\r\nif (hdev->flow_ctl_mode != HCI_FLOW_CTL_MODE_PACKET_BASED) {\r\nBT_ERR("Wrong event for mode %d", hdev->flow_ctl_mode);\r\nreturn;\r\n}\r\nif (skb->len < sizeof(*ev) || skb->len < sizeof(*ev) +\r\nev->num_hndl * sizeof(struct hci_comp_pkts_info)) {\r\nBT_DBG("%s bad parameters", hdev->name);\r\nreturn;\r\n}\r\nBT_DBG("%s num_hndl %d", hdev->name, ev->num_hndl);\r\nfor (i = 0; i < ev->num_hndl; i++) {\r\nstruct hci_comp_pkts_info *info = &ev->handles[i];\r\nstruct hci_conn *conn;\r\n__u16 handle, count;\r\nhandle = __le16_to_cpu(info->handle);\r\ncount = __le16_to_cpu(info->count);\r\nconn = hci_conn_hash_lookup_handle(hdev, handle);\r\nif (!conn)\r\ncontinue;\r\nconn->sent -= count;\r\nswitch (conn->type) {\r\ncase ACL_LINK:\r\nhdev->acl_cnt += count;\r\nif (hdev->acl_cnt > hdev->acl_pkts)\r\nhdev->acl_cnt = hdev->acl_pkts;\r\nbreak;\r\ncase LE_LINK:\r\nif (hdev->le_pkts) {\r\nhdev->le_cnt += count;\r\nif (hdev->le_cnt > hdev->le_pkts)\r\nhdev->le_cnt = hdev->le_pkts;\r\n} else {\r\nhdev->acl_cnt += count;\r\nif (hdev->acl_cnt > hdev->acl_pkts)\r\nhdev->acl_cnt = hdev->acl_pkts;\r\n}\r\nbreak;\r\ncase SCO_LINK:\r\nhdev->sco_cnt += count;\r\nif (hdev->sco_cnt > hdev->sco_pkts)\r\nhdev->sco_cnt = hdev->sco_pkts;\r\nbreak;\r\ndefault:\r\nBT_ERR("Unknown type %d conn %p", conn->type, conn);\r\nbreak;\r\n}\r\n}\r\nqueue_work(hdev->workqueue, &hdev->tx_work);\r\n}\r\nstatic struct hci_conn *__hci_conn_lookup_handle(struct hci_dev *hdev,\r\n__u16 handle)\r\n{\r\nstruct hci_chan *chan;\r\nswitch (hdev->dev_type) {\r\ncase HCI_PRIMARY:\r\nreturn hci_conn_hash_lookup_handle(hdev, handle);\r\ncase HCI_AMP:\r\nchan = hci_chan_lookup_handle(hdev, handle);\r\nif (chan)\r\nreturn chan->conn;\r\nbreak;\r\ndefault:\r\nBT_ERR("%s unknown dev_type %d", hdev->name, hdev->dev_type);\r\nbreak;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void hci_num_comp_blocks_evt(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_ev_num_comp_blocks *ev = (void *) skb->data;\r\nint i;\r\nif (hdev->flow_ctl_mode != HCI_FLOW_CTL_MODE_BLOCK_BASED) {\r\nBT_ERR("Wrong event for mode %d", hdev->flow_ctl_mode);\r\nreturn;\r\n}\r\nif (skb->len < sizeof(*ev) || skb->len < sizeof(*ev) +\r\nev->num_hndl * sizeof(struct hci_comp_blocks_info)) {\r\nBT_DBG("%s bad parameters", hdev->name);\r\nreturn;\r\n}\r\nBT_DBG("%s num_blocks %d num_hndl %d", hdev->name, ev->num_blocks,\r\nev->num_hndl);\r\nfor (i = 0; i < ev->num_hndl; i++) {\r\nstruct hci_comp_blocks_info *info = &ev->handles[i];\r\nstruct hci_conn *conn = NULL;\r\n__u16 handle, block_count;\r\nhandle = __le16_to_cpu(info->handle);\r\nblock_count = __le16_to_cpu(info->blocks);\r\nconn = __hci_conn_lookup_handle(hdev, handle);\r\nif (!conn)\r\ncontinue;\r\nconn->sent -= block_count;\r\nswitch (conn->type) {\r\ncase ACL_LINK:\r\ncase AMP_LINK:\r\nhdev->block_cnt += block_count;\r\nif (hdev->block_cnt > hdev->num_blocks)\r\nhdev->block_cnt = hdev->num_blocks;\r\nbreak;\r\ndefault:\r\nBT_ERR("Unknown type %d conn %p", conn->type, conn);\r\nbreak;\r\n}\r\n}\r\nqueue_work(hdev->workqueue, &hdev->tx_work);\r\n}\r\nstatic void hci_mode_change_evt(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_ev_mode_change *ev = (void *) skb->data;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, ev->status);\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));\r\nif (conn) {\r\nconn->mode = ev->mode;\r\nif (!test_and_clear_bit(HCI_CONN_MODE_CHANGE_PEND,\r\n&conn->flags)) {\r\nif (conn->mode == HCI_CM_ACTIVE)\r\nset_bit(HCI_CONN_POWER_SAVE, &conn->flags);\r\nelse\r\nclear_bit(HCI_CONN_POWER_SAVE, &conn->flags);\r\n}\r\nif (test_and_clear_bit(HCI_CONN_SCO_SETUP_PEND, &conn->flags))\r\nhci_sco_setup(conn, ev->status);\r\n}\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_pin_code_request_evt(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_ev_pin_code_req *ev = (void *) skb->data;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s", hdev->name);\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);\r\nif (!conn)\r\ngoto unlock;\r\nif (conn->state == BT_CONNECTED) {\r\nhci_conn_hold(conn);\r\nconn->disc_timeout = HCI_PAIRING_TIMEOUT;\r\nhci_conn_drop(conn);\r\n}\r\nif (!hci_dev_test_flag(hdev, HCI_BONDABLE) &&\r\n!test_bit(HCI_CONN_AUTH_INITIATOR, &conn->flags)) {\r\nhci_send_cmd(hdev, HCI_OP_PIN_CODE_NEG_REPLY,\r\nsizeof(ev->bdaddr), &ev->bdaddr);\r\n} else if (hci_dev_test_flag(hdev, HCI_MGMT)) {\r\nu8 secure;\r\nif (conn->pending_sec_level == BT_SECURITY_HIGH)\r\nsecure = 1;\r\nelse\r\nsecure = 0;\r\nmgmt_pin_code_request(hdev, &ev->bdaddr, secure);\r\n}\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void conn_set_key(struct hci_conn *conn, u8 key_type, u8 pin_len)\r\n{\r\nif (key_type == HCI_LK_CHANGED_COMBINATION)\r\nreturn;\r\nconn->pin_length = pin_len;\r\nconn->key_type = key_type;\r\nswitch (key_type) {\r\ncase HCI_LK_LOCAL_UNIT:\r\ncase HCI_LK_REMOTE_UNIT:\r\ncase HCI_LK_DEBUG_COMBINATION:\r\nreturn;\r\ncase HCI_LK_COMBINATION:\r\nif (pin_len == 16)\r\nconn->pending_sec_level = BT_SECURITY_HIGH;\r\nelse\r\nconn->pending_sec_level = BT_SECURITY_MEDIUM;\r\nbreak;\r\ncase HCI_LK_UNAUTH_COMBINATION_P192:\r\ncase HCI_LK_UNAUTH_COMBINATION_P256:\r\nconn->pending_sec_level = BT_SECURITY_MEDIUM;\r\nbreak;\r\ncase HCI_LK_AUTH_COMBINATION_P192:\r\nconn->pending_sec_level = BT_SECURITY_HIGH;\r\nbreak;\r\ncase HCI_LK_AUTH_COMBINATION_P256:\r\nconn->pending_sec_level = BT_SECURITY_FIPS;\r\nbreak;\r\n}\r\n}\r\nstatic void hci_link_key_request_evt(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_ev_link_key_req *ev = (void *) skb->data;\r\nstruct hci_cp_link_key_reply cp;\r\nstruct hci_conn *conn;\r\nstruct link_key *key;\r\nBT_DBG("%s", hdev->name);\r\nif (!hci_dev_test_flag(hdev, HCI_MGMT))\r\nreturn;\r\nhci_dev_lock(hdev);\r\nkey = hci_find_link_key(hdev, &ev->bdaddr);\r\nif (!key) {\r\nBT_DBG("%s link key not found for %pMR", hdev->name,\r\n&ev->bdaddr);\r\ngoto not_found;\r\n}\r\nBT_DBG("%s found key type %u for %pMR", hdev->name, key->type,\r\n&ev->bdaddr);\r\nconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);\r\nif (conn) {\r\nclear_bit(HCI_CONN_NEW_LINK_KEY, &conn->flags);\r\nif ((key->type == HCI_LK_UNAUTH_COMBINATION_P192 ||\r\nkey->type == HCI_LK_UNAUTH_COMBINATION_P256) &&\r\nconn->auth_type != 0xff && (conn->auth_type & 0x01)) {\r\nBT_DBG("%s ignoring unauthenticated key", hdev->name);\r\ngoto not_found;\r\n}\r\nif (key->type == HCI_LK_COMBINATION && key->pin_len < 16 &&\r\n(conn->pending_sec_level == BT_SECURITY_HIGH ||\r\nconn->pending_sec_level == BT_SECURITY_FIPS)) {\r\nBT_DBG("%s ignoring key unauthenticated for high security",\r\nhdev->name);\r\ngoto not_found;\r\n}\r\nconn_set_key(conn, key->type, key->pin_len);\r\n}\r\nbacpy(&cp.bdaddr, &ev->bdaddr);\r\nmemcpy(cp.link_key, key->val, HCI_LINK_KEY_SIZE);\r\nhci_send_cmd(hdev, HCI_OP_LINK_KEY_REPLY, sizeof(cp), &cp);\r\nhci_dev_unlock(hdev);\r\nreturn;\r\nnot_found:\r\nhci_send_cmd(hdev, HCI_OP_LINK_KEY_NEG_REPLY, 6, &ev->bdaddr);\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_link_key_notify_evt(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_ev_link_key_notify *ev = (void *) skb->data;\r\nstruct hci_conn *conn;\r\nstruct link_key *key;\r\nbool persistent;\r\nu8 pin_len = 0;\r\nBT_DBG("%s", hdev->name);\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);\r\nif (!conn)\r\ngoto unlock;\r\nhci_conn_hold(conn);\r\nconn->disc_timeout = HCI_DISCONN_TIMEOUT;\r\nhci_conn_drop(conn);\r\nset_bit(HCI_CONN_NEW_LINK_KEY, &conn->flags);\r\nconn_set_key(conn, ev->key_type, conn->pin_length);\r\nif (!hci_dev_test_flag(hdev, HCI_MGMT))\r\ngoto unlock;\r\nkey = hci_add_link_key(hdev, conn, &ev->bdaddr, ev->link_key,\r\nev->key_type, pin_len, &persistent);\r\nif (!key)\r\ngoto unlock;\r\nif (ev->key_type == HCI_LK_CHANGED_COMBINATION)\r\nconn_set_key(conn, key->type, key->pin_len);\r\nmgmt_new_link_key(hdev, key, persistent);\r\nif (key->type == HCI_LK_DEBUG_COMBINATION &&\r\n!hci_dev_test_flag(hdev, HCI_KEEP_DEBUG_KEYS)) {\r\nlist_del_rcu(&key->list);\r\nkfree_rcu(key, rcu);\r\ngoto unlock;\r\n}\r\nif (persistent)\r\nclear_bit(HCI_CONN_FLUSH_KEY, &conn->flags);\r\nelse\r\nset_bit(HCI_CONN_FLUSH_KEY, &conn->flags);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_clock_offset_evt(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_ev_clock_offset *ev = (void *) skb->data;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, ev->status);\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));\r\nif (conn && !ev->status) {\r\nstruct inquiry_entry *ie;\r\nie = hci_inquiry_cache_lookup(hdev, &conn->dst);\r\nif (ie) {\r\nie->data.clock_offset = ev->clock_offset;\r\nie->timestamp = jiffies;\r\n}\r\n}\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_pkt_type_change_evt(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_ev_pkt_type_change *ev = (void *) skb->data;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, ev->status);\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));\r\nif (conn && !ev->status)\r\nconn->pkt_type = __le16_to_cpu(ev->pkt_type);\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_pscan_rep_mode_evt(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_ev_pscan_rep_mode *ev = (void *) skb->data;\r\nstruct inquiry_entry *ie;\r\nBT_DBG("%s", hdev->name);\r\nhci_dev_lock(hdev);\r\nie = hci_inquiry_cache_lookup(hdev, &ev->bdaddr);\r\nif (ie) {\r\nie->data.pscan_rep_mode = ev->pscan_rep_mode;\r\nie->timestamp = jiffies;\r\n}\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_inquiry_result_with_rssi_evt(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct inquiry_data data;\r\nint num_rsp = *((__u8 *) skb->data);\r\nBT_DBG("%s num_rsp %d", hdev->name, num_rsp);\r\nif (!num_rsp)\r\nreturn;\r\nif (hci_dev_test_flag(hdev, HCI_PERIODIC_INQ))\r\nreturn;\r\nhci_dev_lock(hdev);\r\nif ((skb->len - 1) / num_rsp != sizeof(struct inquiry_info_with_rssi)) {\r\nstruct inquiry_info_with_rssi_and_pscan_mode *info;\r\ninfo = (void *) (skb->data + 1);\r\nfor (; num_rsp; num_rsp--, info++) {\r\nu32 flags;\r\nbacpy(&data.bdaddr, &info->bdaddr);\r\ndata.pscan_rep_mode = info->pscan_rep_mode;\r\ndata.pscan_period_mode = info->pscan_period_mode;\r\ndata.pscan_mode = info->pscan_mode;\r\nmemcpy(data.dev_class, info->dev_class, 3);\r\ndata.clock_offset = info->clock_offset;\r\ndata.rssi = info->rssi;\r\ndata.ssp_mode = 0x00;\r\nflags = hci_inquiry_cache_update(hdev, &data, false);\r\nmgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,\r\ninfo->dev_class, info->rssi,\r\nflags, NULL, 0, NULL, 0);\r\n}\r\n} else {\r\nstruct inquiry_info_with_rssi *info = (void *) (skb->data + 1);\r\nfor (; num_rsp; num_rsp--, info++) {\r\nu32 flags;\r\nbacpy(&data.bdaddr, &info->bdaddr);\r\ndata.pscan_rep_mode = info->pscan_rep_mode;\r\ndata.pscan_period_mode = info->pscan_period_mode;\r\ndata.pscan_mode = 0x00;\r\nmemcpy(data.dev_class, info->dev_class, 3);\r\ndata.clock_offset = info->clock_offset;\r\ndata.rssi = info->rssi;\r\ndata.ssp_mode = 0x00;\r\nflags = hci_inquiry_cache_update(hdev, &data, false);\r\nmgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,\r\ninfo->dev_class, info->rssi,\r\nflags, NULL, 0, NULL, 0);\r\n}\r\n}\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_remote_ext_features_evt(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_ev_remote_ext_features *ev = (void *) skb->data;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s", hdev->name);\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));\r\nif (!conn)\r\ngoto unlock;\r\nif (ev->page < HCI_MAX_PAGES)\r\nmemcpy(conn->features[ev->page], ev->features, 8);\r\nif (!ev->status && ev->page == 0x01) {\r\nstruct inquiry_entry *ie;\r\nie = hci_inquiry_cache_lookup(hdev, &conn->dst);\r\nif (ie)\r\nie->data.ssp_mode = (ev->features[0] & LMP_HOST_SSP);\r\nif (ev->features[0] & LMP_HOST_SSP) {\r\nset_bit(HCI_CONN_SSP_ENABLED, &conn->flags);\r\n} else {\r\nclear_bit(HCI_CONN_SSP_ENABLED, &conn->flags);\r\n}\r\nif (ev->features[0] & LMP_HOST_SC)\r\nset_bit(HCI_CONN_SC_ENABLED, &conn->flags);\r\n}\r\nif (conn->state != BT_CONFIG)\r\ngoto unlock;\r\nif (!ev->status && !test_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags)) {\r\nstruct hci_cp_remote_name_req cp;\r\nmemset(&cp, 0, sizeof(cp));\r\nbacpy(&cp.bdaddr, &conn->dst);\r\ncp.pscan_rep_mode = 0x02;\r\nhci_send_cmd(hdev, HCI_OP_REMOTE_NAME_REQ, sizeof(cp), &cp);\r\n} else if (!test_and_set_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags))\r\nmgmt_device_connected(hdev, conn, 0, NULL, 0);\r\nif (!hci_outgoing_auth_needed(hdev, conn)) {\r\nconn->state = BT_CONNECTED;\r\nhci_connect_cfm(conn, ev->status);\r\nhci_conn_drop(conn);\r\n}\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_sync_conn_complete_evt(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_ev_sync_conn_complete *ev = (void *) skb->data;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, ev->status);\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_ba(hdev, ev->link_type, &ev->bdaddr);\r\nif (!conn) {\r\nif (ev->link_type == ESCO_LINK)\r\ngoto unlock;\r\nconn = hci_conn_hash_lookup_ba(hdev, ESCO_LINK, &ev->bdaddr);\r\nif (!conn)\r\ngoto unlock;\r\n}\r\nswitch (ev->status) {\r\ncase 0x00:\r\nconn->handle = __le16_to_cpu(ev->handle);\r\nconn->state = BT_CONNECTED;\r\nconn->type = ev->link_type;\r\nhci_debugfs_create_conn(conn);\r\nhci_conn_add_sysfs(conn);\r\nbreak;\r\ncase 0x10:\r\ncase 0x0d:\r\ncase 0x11:\r\ncase 0x1c:\r\ncase 0x1a:\r\ncase 0x1f:\r\ncase 0x20:\r\nif (conn->out) {\r\nconn->pkt_type = (hdev->esco_type & SCO_ESCO_MASK) |\r\n(hdev->esco_type & EDR_ESCO_MASK);\r\nif (hci_setup_sync(conn, conn->link->handle))\r\ngoto unlock;\r\n}\r\ndefault:\r\nconn->state = BT_CLOSED;\r\nbreak;\r\n}\r\nhci_connect_cfm(conn, ev->status);\r\nif (ev->status)\r\nhci_conn_del(conn);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic inline size_t eir_get_length(u8 *eir, size_t eir_len)\r\n{\r\nsize_t parsed = 0;\r\nwhile (parsed < eir_len) {\r\nu8 field_len = eir[0];\r\nif (field_len == 0)\r\nreturn parsed;\r\nparsed += field_len + 1;\r\neir += field_len + 1;\r\n}\r\nreturn eir_len;\r\n}\r\nstatic void hci_extended_inquiry_result_evt(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct inquiry_data data;\r\nstruct extended_inquiry_info *info = (void *) (skb->data + 1);\r\nint num_rsp = *((__u8 *) skb->data);\r\nsize_t eir_len;\r\nBT_DBG("%s num_rsp %d", hdev->name, num_rsp);\r\nif (!num_rsp)\r\nreturn;\r\nif (hci_dev_test_flag(hdev, HCI_PERIODIC_INQ))\r\nreturn;\r\nhci_dev_lock(hdev);\r\nfor (; num_rsp; num_rsp--, info++) {\r\nu32 flags;\r\nbool name_known;\r\nbacpy(&data.bdaddr, &info->bdaddr);\r\ndata.pscan_rep_mode = info->pscan_rep_mode;\r\ndata.pscan_period_mode = info->pscan_period_mode;\r\ndata.pscan_mode = 0x00;\r\nmemcpy(data.dev_class, info->dev_class, 3);\r\ndata.clock_offset = info->clock_offset;\r\ndata.rssi = info->rssi;\r\ndata.ssp_mode = 0x01;\r\nif (hci_dev_test_flag(hdev, HCI_MGMT))\r\nname_known = eir_get_data(info->data,\r\nsizeof(info->data),\r\nEIR_NAME_COMPLETE, NULL);\r\nelse\r\nname_known = true;\r\nflags = hci_inquiry_cache_update(hdev, &data, name_known);\r\neir_len = eir_get_length(info->data, sizeof(info->data));\r\nmgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,\r\ninfo->dev_class, info->rssi,\r\nflags, info->data, eir_len, NULL, 0);\r\n}\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_key_refresh_complete_evt(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_ev_key_refresh_complete *ev = (void *) skb->data;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s status 0x%2.2x handle 0x%4.4x", hdev->name, ev->status,\r\n__le16_to_cpu(ev->handle));\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));\r\nif (!conn)\r\ngoto unlock;\r\nif (conn->type != LE_LINK)\r\ngoto unlock;\r\nif (!ev->status)\r\nconn->sec_level = conn->pending_sec_level;\r\nclear_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags);\r\nif (ev->status && conn->state == BT_CONNECTED) {\r\nhci_disconnect(conn, HCI_ERROR_AUTH_FAILURE);\r\nhci_conn_drop(conn);\r\ngoto unlock;\r\n}\r\nif (conn->state == BT_CONFIG) {\r\nif (!ev->status)\r\nconn->state = BT_CONNECTED;\r\nhci_connect_cfm(conn, ev->status);\r\nhci_conn_drop(conn);\r\n} else {\r\nhci_auth_cfm(conn, ev->status);\r\nhci_conn_hold(conn);\r\nconn->disc_timeout = HCI_DISCONN_TIMEOUT;\r\nhci_conn_drop(conn);\r\n}\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic u8 hci_get_auth_req(struct hci_conn *conn)\r\n{\r\nif (conn->remote_auth == HCI_AT_NO_BONDING ||\r\nconn->remote_auth == HCI_AT_NO_BONDING_MITM)\r\nreturn conn->remote_auth | (conn->auth_type & 0x01);\r\nif (conn->remote_cap != HCI_IO_NO_INPUT_OUTPUT &&\r\nconn->io_capability != HCI_IO_NO_INPUT_OUTPUT)\r\nreturn conn->remote_auth | 0x01;\r\nreturn (conn->remote_auth & ~0x01) | (conn->auth_type & 0x01);\r\n}\r\nstatic u8 bredr_oob_data_present(struct hci_conn *conn)\r\n{\r\nstruct hci_dev *hdev = conn->hdev;\r\nstruct oob_data *data;\r\ndata = hci_find_remote_oob_data(hdev, &conn->dst, BDADDR_BREDR);\r\nif (!data)\r\nreturn 0x00;\r\nif (bredr_sc_enabled(hdev)) {\r\nif (!hci_dev_test_flag(hdev, HCI_SC_ONLY))\r\nreturn data->present;\r\nif (!memcmp(data->rand256, ZERO_KEY, 16) ||\r\n!memcmp(data->hash256, ZERO_KEY, 16))\r\nreturn 0x00;\r\nreturn 0x02;\r\n}\r\nif (!memcmp(data->rand192, ZERO_KEY, 16) ||\r\n!memcmp(data->hash192, ZERO_KEY, 16))\r\nreturn 0x00;\r\nreturn 0x01;\r\n}\r\nstatic void hci_io_capa_request_evt(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_ev_io_capa_request *ev = (void *) skb->data;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s", hdev->name);\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);\r\nif (!conn)\r\ngoto unlock;\r\nhci_conn_hold(conn);\r\nif (!hci_dev_test_flag(hdev, HCI_MGMT))\r\ngoto unlock;\r\nif (hci_dev_test_flag(hdev, HCI_BONDABLE) ||\r\ntest_bit(HCI_CONN_AUTH_INITIATOR, &conn->flags) ||\r\n(conn->remote_auth & ~0x01) == HCI_AT_NO_BONDING) {\r\nstruct hci_cp_io_capability_reply cp;\r\nbacpy(&cp.bdaddr, &ev->bdaddr);\r\ncp.capability = (conn->io_capability == 0x04) ?\r\nHCI_IO_DISPLAY_YESNO : conn->io_capability;\r\nif (conn->remote_auth == 0xff) {\r\nif (conn->io_capability != HCI_IO_NO_INPUT_OUTPUT &&\r\nconn->auth_type != HCI_AT_NO_BONDING)\r\nconn->auth_type |= 0x01;\r\n} else {\r\nconn->auth_type = hci_get_auth_req(conn);\r\n}\r\nif (!hci_dev_test_flag(hdev, HCI_BONDABLE))\r\nconn->auth_type &= HCI_AT_NO_BONDING_MITM;\r\ncp.authentication = conn->auth_type;\r\ncp.oob_data = bredr_oob_data_present(conn);\r\nhci_send_cmd(hdev, HCI_OP_IO_CAPABILITY_REPLY,\r\nsizeof(cp), &cp);\r\n} else {\r\nstruct hci_cp_io_capability_neg_reply cp;\r\nbacpy(&cp.bdaddr, &ev->bdaddr);\r\ncp.reason = HCI_ERROR_PAIRING_NOT_ALLOWED;\r\nhci_send_cmd(hdev, HCI_OP_IO_CAPABILITY_NEG_REPLY,\r\nsizeof(cp), &cp);\r\n}\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_io_capa_reply_evt(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_ev_io_capa_reply *ev = (void *) skb->data;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s", hdev->name);\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);\r\nif (!conn)\r\ngoto unlock;\r\nconn->remote_cap = ev->capability;\r\nconn->remote_auth = ev->authentication;\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_user_confirm_request_evt(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_ev_user_confirm_req *ev = (void *) skb->data;\r\nint loc_mitm, rem_mitm, confirm_hint = 0;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s", hdev->name);\r\nhci_dev_lock(hdev);\r\nif (!hci_dev_test_flag(hdev, HCI_MGMT))\r\ngoto unlock;\r\nconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);\r\nif (!conn)\r\ngoto unlock;\r\nloc_mitm = (conn->auth_type & 0x01);\r\nrem_mitm = (conn->remote_auth & 0x01);\r\nif (conn->pending_sec_level > BT_SECURITY_MEDIUM &&\r\nconn->remote_cap == HCI_IO_NO_INPUT_OUTPUT) {\r\nBT_DBG("Rejecting request: remote device can't provide MITM");\r\nhci_send_cmd(hdev, HCI_OP_USER_CONFIRM_NEG_REPLY,\r\nsizeof(ev->bdaddr), &ev->bdaddr);\r\ngoto unlock;\r\n}\r\nif ((!loc_mitm || conn->remote_cap == HCI_IO_NO_INPUT_OUTPUT) &&\r\n(!rem_mitm || conn->io_capability == HCI_IO_NO_INPUT_OUTPUT)) {\r\nif (!test_bit(HCI_CONN_AUTH_PEND, &conn->flags) &&\r\nconn->io_capability != HCI_IO_NO_INPUT_OUTPUT &&\r\n(loc_mitm || rem_mitm)) {\r\nBT_DBG("Confirming auto-accept as acceptor");\r\nconfirm_hint = 1;\r\ngoto confirm;\r\n}\r\nBT_DBG("Auto-accept of user confirmation with %ums delay",\r\nhdev->auto_accept_delay);\r\nif (hdev->auto_accept_delay > 0) {\r\nint delay = msecs_to_jiffies(hdev->auto_accept_delay);\r\nqueue_delayed_work(conn->hdev->workqueue,\r\n&conn->auto_accept_work, delay);\r\ngoto unlock;\r\n}\r\nhci_send_cmd(hdev, HCI_OP_USER_CONFIRM_REPLY,\r\nsizeof(ev->bdaddr), &ev->bdaddr);\r\ngoto unlock;\r\n}\r\nconfirm:\r\nmgmt_user_confirm_request(hdev, &ev->bdaddr, ACL_LINK, 0,\r\nle32_to_cpu(ev->passkey), confirm_hint);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_user_passkey_request_evt(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_ev_user_passkey_req *ev = (void *) skb->data;\r\nBT_DBG("%s", hdev->name);\r\nif (hci_dev_test_flag(hdev, HCI_MGMT))\r\nmgmt_user_passkey_request(hdev, &ev->bdaddr, ACL_LINK, 0);\r\n}\r\nstatic void hci_user_passkey_notify_evt(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_ev_user_passkey_notify *ev = (void *) skb->data;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s", hdev->name);\r\nconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);\r\nif (!conn)\r\nreturn;\r\nconn->passkey_notify = __le32_to_cpu(ev->passkey);\r\nconn->passkey_entered = 0;\r\nif (hci_dev_test_flag(hdev, HCI_MGMT))\r\nmgmt_user_passkey_notify(hdev, &conn->dst, conn->type,\r\nconn->dst_type, conn->passkey_notify,\r\nconn->passkey_entered);\r\n}\r\nstatic void hci_keypress_notify_evt(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_ev_keypress_notify *ev = (void *) skb->data;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s", hdev->name);\r\nconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);\r\nif (!conn)\r\nreturn;\r\nswitch (ev->type) {\r\ncase HCI_KEYPRESS_STARTED:\r\nconn->passkey_entered = 0;\r\nreturn;\r\ncase HCI_KEYPRESS_ENTERED:\r\nconn->passkey_entered++;\r\nbreak;\r\ncase HCI_KEYPRESS_ERASED:\r\nconn->passkey_entered--;\r\nbreak;\r\ncase HCI_KEYPRESS_CLEARED:\r\nconn->passkey_entered = 0;\r\nbreak;\r\ncase HCI_KEYPRESS_COMPLETED:\r\nreturn;\r\n}\r\nif (hci_dev_test_flag(hdev, HCI_MGMT))\r\nmgmt_user_passkey_notify(hdev, &conn->dst, conn->type,\r\nconn->dst_type, conn->passkey_notify,\r\nconn->passkey_entered);\r\n}\r\nstatic void hci_simple_pair_complete_evt(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_ev_simple_pair_complete *ev = (void *) skb->data;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s", hdev->name);\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);\r\nif (!conn)\r\ngoto unlock;\r\nconn->remote_auth = 0xff;\r\nif (!test_bit(HCI_CONN_AUTH_PEND, &conn->flags) && ev->status)\r\nmgmt_auth_failed(conn, ev->status);\r\nhci_conn_drop(conn);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_remote_host_features_evt(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_ev_remote_host_features *ev = (void *) skb->data;\r\nstruct inquiry_entry *ie;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s", hdev->name);\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);\r\nif (conn)\r\nmemcpy(conn->features[1], ev->features, 8);\r\nie = hci_inquiry_cache_lookup(hdev, &ev->bdaddr);\r\nif (ie)\r\nie->data.ssp_mode = (ev->features[0] & LMP_HOST_SSP);\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_remote_oob_data_request_evt(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_ev_remote_oob_data_request *ev = (void *) skb->data;\r\nstruct oob_data *data;\r\nBT_DBG("%s", hdev->name);\r\nhci_dev_lock(hdev);\r\nif (!hci_dev_test_flag(hdev, HCI_MGMT))\r\ngoto unlock;\r\ndata = hci_find_remote_oob_data(hdev, &ev->bdaddr, BDADDR_BREDR);\r\nif (!data) {\r\nstruct hci_cp_remote_oob_data_neg_reply cp;\r\nbacpy(&cp.bdaddr, &ev->bdaddr);\r\nhci_send_cmd(hdev, HCI_OP_REMOTE_OOB_DATA_NEG_REPLY,\r\nsizeof(cp), &cp);\r\ngoto unlock;\r\n}\r\nif (bredr_sc_enabled(hdev)) {\r\nstruct hci_cp_remote_oob_ext_data_reply cp;\r\nbacpy(&cp.bdaddr, &ev->bdaddr);\r\nif (hci_dev_test_flag(hdev, HCI_SC_ONLY)) {\r\nmemset(cp.hash192, 0, sizeof(cp.hash192));\r\nmemset(cp.rand192, 0, sizeof(cp.rand192));\r\n} else {\r\nmemcpy(cp.hash192, data->hash192, sizeof(cp.hash192));\r\nmemcpy(cp.rand192, data->rand192, sizeof(cp.rand192));\r\n}\r\nmemcpy(cp.hash256, data->hash256, sizeof(cp.hash256));\r\nmemcpy(cp.rand256, data->rand256, sizeof(cp.rand256));\r\nhci_send_cmd(hdev, HCI_OP_REMOTE_OOB_EXT_DATA_REPLY,\r\nsizeof(cp), &cp);\r\n} else {\r\nstruct hci_cp_remote_oob_data_reply cp;\r\nbacpy(&cp.bdaddr, &ev->bdaddr);\r\nmemcpy(cp.hash, data->hash192, sizeof(cp.hash));\r\nmemcpy(cp.rand, data->rand192, sizeof(cp.rand));\r\nhci_send_cmd(hdev, HCI_OP_REMOTE_OOB_DATA_REPLY,\r\nsizeof(cp), &cp);\r\n}\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_chan_selected_evt(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_ev_channel_selected *ev = (void *)skb->data;\r\nstruct hci_conn *hcon;\r\nBT_DBG("%s handle 0x%2.2x", hdev->name, ev->phy_handle);\r\nskb_pull(skb, sizeof(*ev));\r\nhcon = hci_conn_hash_lookup_handle(hdev, ev->phy_handle);\r\nif (!hcon)\r\nreturn;\r\namp_read_loc_assoc_final_data(hdev, hcon);\r\n}\r\nstatic void hci_phy_link_complete_evt(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_ev_phy_link_complete *ev = (void *) skb->data;\r\nstruct hci_conn *hcon, *bredr_hcon;\r\nBT_DBG("%s handle 0x%2.2x status 0x%2.2x", hdev->name, ev->phy_handle,\r\nev->status);\r\nhci_dev_lock(hdev);\r\nhcon = hci_conn_hash_lookup_handle(hdev, ev->phy_handle);\r\nif (!hcon) {\r\nhci_dev_unlock(hdev);\r\nreturn;\r\n}\r\nif (ev->status) {\r\nhci_conn_del(hcon);\r\nhci_dev_unlock(hdev);\r\nreturn;\r\n}\r\nbredr_hcon = hcon->amp_mgr->l2cap_conn->hcon;\r\nhcon->state = BT_CONNECTED;\r\nbacpy(&hcon->dst, &bredr_hcon->dst);\r\nhci_conn_hold(hcon);\r\nhcon->disc_timeout = HCI_DISCONN_TIMEOUT;\r\nhci_conn_drop(hcon);\r\nhci_debugfs_create_conn(hcon);\r\nhci_conn_add_sysfs(hcon);\r\namp_physical_cfm(bredr_hcon, hcon);\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_loglink_complete_evt(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_ev_logical_link_complete *ev = (void *) skb->data;\r\nstruct hci_conn *hcon;\r\nstruct hci_chan *hchan;\r\nstruct amp_mgr *mgr;\r\nBT_DBG("%s log_handle 0x%4.4x phy_handle 0x%2.2x status 0x%2.2x",\r\nhdev->name, le16_to_cpu(ev->handle), ev->phy_handle,\r\nev->status);\r\nhcon = hci_conn_hash_lookup_handle(hdev, ev->phy_handle);\r\nif (!hcon)\r\nreturn;\r\nhchan = hci_chan_create(hcon);\r\nif (!hchan)\r\nreturn;\r\nhchan->handle = le16_to_cpu(ev->handle);\r\nBT_DBG("hcon %p mgr %p hchan %p", hcon, hcon->amp_mgr, hchan);\r\nmgr = hcon->amp_mgr;\r\nif (mgr && mgr->bredr_chan) {\r\nstruct l2cap_chan *bredr_chan = mgr->bredr_chan;\r\nl2cap_chan_lock(bredr_chan);\r\nbredr_chan->conn->mtu = hdev->block_mtu;\r\nl2cap_logical_cfm(bredr_chan, hchan, 0);\r\nhci_conn_hold(hcon);\r\nl2cap_chan_unlock(bredr_chan);\r\n}\r\n}\r\nstatic void hci_disconn_loglink_complete_evt(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_ev_disconn_logical_link_complete *ev = (void *) skb->data;\r\nstruct hci_chan *hchan;\r\nBT_DBG("%s log handle 0x%4.4x status 0x%2.2x", hdev->name,\r\nle16_to_cpu(ev->handle), ev->status);\r\nif (ev->status)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nhchan = hci_chan_lookup_handle(hdev, le16_to_cpu(ev->handle));\r\nif (!hchan)\r\ngoto unlock;\r\namp_destroy_logical_link(hchan, ev->reason);\r\nunlock:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_disconn_phylink_complete_evt(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_ev_disconn_phy_link_complete *ev = (void *) skb->data;\r\nstruct hci_conn *hcon;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, ev->status);\r\nif (ev->status)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nhcon = hci_conn_hash_lookup_handle(hdev, ev->phy_handle);\r\nif (hcon) {\r\nhcon->state = BT_CLOSED;\r\nhci_conn_del(hcon);\r\n}\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_le_conn_complete_evt(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_ev_le_conn_complete *ev = (void *) skb->data;\r\nstruct hci_conn_params *params;\r\nstruct hci_conn *conn;\r\nstruct smp_irk *irk;\r\nu8 addr_type;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, ev->status);\r\nhci_dev_lock(hdev);\r\nhci_dev_clear_flag(hdev, HCI_LE_ADV);\r\nconn = hci_lookup_le_connect(hdev);\r\nif (!conn) {\r\nconn = hci_conn_add(hdev, LE_LINK, &ev->bdaddr, ev->role);\r\nif (!conn) {\r\nBT_ERR("No memory for new connection");\r\ngoto unlock;\r\n}\r\nconn->dst_type = ev->bdaddr_type;\r\nif (conn->out) {\r\nconn->resp_addr_type = ev->bdaddr_type;\r\nbacpy(&conn->resp_addr, &ev->bdaddr);\r\nif (hci_dev_test_flag(hdev, HCI_PRIVACY)) {\r\nconn->init_addr_type = ADDR_LE_DEV_RANDOM;\r\nbacpy(&conn->init_addr, &hdev->rpa);\r\n} else {\r\nhci_copy_identity_address(hdev,\r\n&conn->init_addr,\r\n&conn->init_addr_type);\r\n}\r\n}\r\n} else {\r\ncancel_delayed_work(&conn->le_conn_timeout);\r\n}\r\nif (!conn->out) {\r\nconn->resp_addr_type = hdev->adv_addr_type;\r\nif (hdev->adv_addr_type == ADDR_LE_DEV_RANDOM)\r\nbacpy(&conn->resp_addr, &hdev->random_addr);\r\nelse\r\nbacpy(&conn->resp_addr, &hdev->bdaddr);\r\nconn->init_addr_type = ev->bdaddr_type;\r\nbacpy(&conn->init_addr, &ev->bdaddr);\r\nconn->le_conn_min_interval = hdev->le_conn_min_interval;\r\nconn->le_conn_max_interval = hdev->le_conn_max_interval;\r\n}\r\nirk = hci_get_irk(hdev, &conn->dst, conn->dst_type);\r\nif (irk) {\r\nbacpy(&conn->dst, &irk->bdaddr);\r\nconn->dst_type = irk->addr_type;\r\n}\r\nif (ev->status) {\r\nhci_le_conn_failed(conn, ev->status);\r\ngoto unlock;\r\n}\r\nif (conn->dst_type == ADDR_LE_DEV_PUBLIC)\r\naddr_type = BDADDR_LE_PUBLIC;\r\nelse\r\naddr_type = BDADDR_LE_RANDOM;\r\nif (hci_bdaddr_list_lookup(&hdev->blacklist, &conn->dst, addr_type)) {\r\nhci_conn_drop(conn);\r\ngoto unlock;\r\n}\r\nif (!test_and_set_bit(HCI_CONN_MGMT_CONNECTED, &conn->flags))\r\nmgmt_device_connected(hdev, conn, 0, NULL, 0);\r\nconn->sec_level = BT_SECURITY_LOW;\r\nconn->handle = __le16_to_cpu(ev->handle);\r\nconn->state = BT_CONFIG;\r\nconn->le_conn_interval = le16_to_cpu(ev->interval);\r\nconn->le_conn_latency = le16_to_cpu(ev->latency);\r\nconn->le_supv_timeout = le16_to_cpu(ev->supervision_timeout);\r\nhci_debugfs_create_conn(conn);\r\nhci_conn_add_sysfs(conn);\r\nif (!ev->status) {\r\nif (conn->out ||\r\n(hdev->le_features[0] & HCI_LE_SLAVE_FEATURES)) {\r\nstruct hci_cp_le_read_remote_features cp;\r\ncp.handle = __cpu_to_le16(conn->handle);\r\nhci_send_cmd(hdev, HCI_OP_LE_READ_REMOTE_FEATURES,\r\nsizeof(cp), &cp);\r\nhci_conn_hold(conn);\r\n} else {\r\nconn->state = BT_CONNECTED;\r\nhci_connect_cfm(conn, ev->status);\r\n}\r\n} else {\r\nhci_connect_cfm(conn, ev->status);\r\n}\r\nparams = hci_pend_le_action_lookup(&hdev->pend_le_conns, &conn->dst,\r\nconn->dst_type);\r\nif (params) {\r\nlist_del_init(&params->action);\r\nif (params->conn) {\r\nhci_conn_drop(params->conn);\r\nhci_conn_put(params->conn);\r\nparams->conn = NULL;\r\n}\r\n}\r\nunlock:\r\nhci_update_background_scan(hdev);\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_le_conn_update_complete_evt(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_ev_le_conn_update_complete *ev = (void *) skb->data;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, ev->status);\r\nif (ev->status)\r\nreturn;\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));\r\nif (conn) {\r\nconn->le_conn_interval = le16_to_cpu(ev->interval);\r\nconn->le_conn_latency = le16_to_cpu(ev->latency);\r\nconn->le_supv_timeout = le16_to_cpu(ev->supervision_timeout);\r\n}\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic struct hci_conn *check_pending_le_conn(struct hci_dev *hdev,\r\nbdaddr_t *addr,\r\nu8 addr_type, u8 adv_type)\r\n{\r\nstruct hci_conn *conn;\r\nstruct hci_conn_params *params;\r\nif (adv_type != LE_ADV_IND && adv_type != LE_ADV_DIRECT_IND)\r\nreturn NULL;\r\nif (hci_bdaddr_list_lookup(&hdev->blacklist, addr, addr_type))\r\nreturn NULL;\r\nif (hdev->conn_hash.le_num_slave > 0)\r\nreturn NULL;\r\nparams = hci_pend_le_action_lookup(&hdev->pend_le_conns, addr,\r\naddr_type);\r\nif (!params)\r\nreturn NULL;\r\nif (!params->explicit_connect) {\r\nswitch (params->auto_connect) {\r\ncase HCI_AUTO_CONN_DIRECT:\r\nif (adv_type != LE_ADV_DIRECT_IND)\r\nreturn NULL;\r\nbreak;\r\ncase HCI_AUTO_CONN_ALWAYS:\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nconn = hci_connect_le(hdev, addr, addr_type, BT_SECURITY_LOW,\r\nHCI_LE_AUTOCONN_TIMEOUT, HCI_ROLE_MASTER);\r\nif (!IS_ERR(conn)) {\r\nif (!params->explicit_connect)\r\nparams->conn = hci_conn_get(conn);\r\nreturn conn;\r\n}\r\nswitch (PTR_ERR(conn)) {\r\ncase -EBUSY:\r\nbreak;\r\ndefault:\r\nBT_DBG("Failed to connect: err %ld", PTR_ERR(conn));\r\nreturn NULL;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void process_adv_report(struct hci_dev *hdev, u8 type, bdaddr_t *bdaddr,\r\nu8 bdaddr_type, bdaddr_t *direct_addr,\r\nu8 direct_addr_type, s8 rssi, u8 *data, u8 len)\r\n{\r\nstruct discovery_state *d = &hdev->discovery;\r\nstruct smp_irk *irk;\r\nstruct hci_conn *conn;\r\nbool match;\r\nu32 flags;\r\nu8 *ptr, real_len;\r\nswitch (type) {\r\ncase LE_ADV_IND:\r\ncase LE_ADV_DIRECT_IND:\r\ncase LE_ADV_SCAN_IND:\r\ncase LE_ADV_NONCONN_IND:\r\ncase LE_ADV_SCAN_RSP:\r\nbreak;\r\ndefault:\r\nBT_ERR_RATELIMITED("Unknown advertising packet type: 0x%02x",\r\ntype);\r\nreturn;\r\n}\r\nfor (ptr = data; ptr < data + len && *ptr; ptr += *ptr + 1) {\r\nif (ptr + 1 + *ptr > data + len)\r\nbreak;\r\n}\r\nreal_len = ptr - data;\r\nif (len != real_len) {\r\nBT_ERR_RATELIMITED("%s advertising data length corrected",\r\nhdev->name);\r\nlen = real_len;\r\n}\r\nif (direct_addr) {\r\nif (!hci_bdaddr_is_rpa(direct_addr, direct_addr_type))\r\nreturn;\r\nif (!hci_dev_test_flag(hdev, HCI_PRIVACY))\r\nreturn;\r\nif (!smp_irk_matches(hdev, hdev->irk, direct_addr))\r\nreturn;\r\n}\r\nirk = hci_get_irk(hdev, bdaddr, bdaddr_type);\r\nif (irk) {\r\nbdaddr = &irk->bdaddr;\r\nbdaddr_type = irk->addr_type;\r\n}\r\nconn = check_pending_le_conn(hdev, bdaddr, bdaddr_type, type);\r\nif (conn && type == LE_ADV_IND) {\r\nmemcpy(conn->le_adv_data, data, len);\r\nconn->le_adv_data_len = len;\r\n}\r\nif (hdev->le_scan_type == LE_SCAN_PASSIVE) {\r\nif (type == LE_ADV_DIRECT_IND)\r\nreturn;\r\nif (!hci_pend_le_action_lookup(&hdev->pend_le_reports,\r\nbdaddr, bdaddr_type))\r\nreturn;\r\nif (type == LE_ADV_NONCONN_IND || type == LE_ADV_SCAN_IND)\r\nflags = MGMT_DEV_FOUND_NOT_CONNECTABLE;\r\nelse\r\nflags = 0;\r\nmgmt_device_found(hdev, bdaddr, LE_LINK, bdaddr_type, NULL,\r\nrssi, flags, data, len, NULL, 0);\r\nreturn;\r\n}\r\nif (type == LE_ADV_NONCONN_IND || type == LE_ADV_SCAN_IND ||\r\ntype == LE_ADV_SCAN_RSP)\r\nflags = MGMT_DEV_FOUND_NOT_CONNECTABLE;\r\nelse\r\nflags = 0;\r\nif (!has_pending_adv_report(hdev)) {\r\nif (type == LE_ADV_IND || type == LE_ADV_SCAN_IND) {\r\nstore_pending_adv_report(hdev, bdaddr, bdaddr_type,\r\nrssi, flags, data, len);\r\nreturn;\r\n}\r\nmgmt_device_found(hdev, bdaddr, LE_LINK, bdaddr_type, NULL,\r\nrssi, flags, data, len, NULL, 0);\r\nreturn;\r\n}\r\nmatch = (!bacmp(bdaddr, &d->last_adv_addr) &&\r\nbdaddr_type == d->last_adv_addr_type);\r\nif (type != LE_ADV_SCAN_RSP || !match) {\r\nif (!match)\r\nmgmt_device_found(hdev, &d->last_adv_addr, LE_LINK,\r\nd->last_adv_addr_type, NULL,\r\nd->last_adv_rssi, d->last_adv_flags,\r\nd->last_adv_data,\r\nd->last_adv_data_len, NULL, 0);\r\nif (type == LE_ADV_IND || type == LE_ADV_SCAN_IND) {\r\nstore_pending_adv_report(hdev, bdaddr, bdaddr_type,\r\nrssi, flags, data, len);\r\nreturn;\r\n}\r\nclear_pending_adv_report(hdev);\r\nmgmt_device_found(hdev, bdaddr, LE_LINK, bdaddr_type, NULL,\r\nrssi, flags, data, len, NULL, 0);\r\nreturn;\r\n}\r\nmgmt_device_found(hdev, &d->last_adv_addr, LE_LINK,\r\nd->last_adv_addr_type, NULL, rssi, d->last_adv_flags,\r\nd->last_adv_data, d->last_adv_data_len, data, len);\r\nclear_pending_adv_report(hdev);\r\n}\r\nstatic void hci_le_adv_report_evt(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nu8 num_reports = skb->data[0];\r\nvoid *ptr = &skb->data[1];\r\nhci_dev_lock(hdev);\r\nwhile (num_reports--) {\r\nstruct hci_ev_le_advertising_info *ev = ptr;\r\ns8 rssi;\r\nrssi = ev->data[ev->length];\r\nprocess_adv_report(hdev, ev->evt_type, &ev->bdaddr,\r\nev->bdaddr_type, NULL, 0, rssi,\r\nev->data, ev->length);\r\nptr += sizeof(*ev) + ev->length + 1;\r\n}\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_le_remote_feat_complete_evt(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_ev_le_remote_feat_complete *ev = (void *)skb->data;\r\nstruct hci_conn *conn;\r\nBT_DBG("%s status 0x%2.2x", hdev->name, ev->status);\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));\r\nif (conn) {\r\nif (!ev->status)\r\nmemcpy(conn->features[0], ev->features, 8);\r\nif (conn->state == BT_CONFIG) {\r\n__u8 status;\r\nif ((hdev->le_features[0] & HCI_LE_SLAVE_FEATURES) &&\r\n!conn->out && ev->status == 0x1a)\r\nstatus = 0x00;\r\nelse\r\nstatus = ev->status;\r\nconn->state = BT_CONNECTED;\r\nhci_connect_cfm(conn, status);\r\nhci_conn_drop(conn);\r\n}\r\n}\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_le_ltk_request_evt(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_ev_le_ltk_req *ev = (void *) skb->data;\r\nstruct hci_cp_le_ltk_reply cp;\r\nstruct hci_cp_le_ltk_neg_reply neg;\r\nstruct hci_conn *conn;\r\nstruct smp_ltk *ltk;\r\nBT_DBG("%s handle 0x%4.4x", hdev->name, __le16_to_cpu(ev->handle));\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));\r\nif (conn == NULL)\r\ngoto not_found;\r\nltk = hci_find_ltk(hdev, &conn->dst, conn->dst_type, conn->role);\r\nif (!ltk)\r\ngoto not_found;\r\nif (smp_ltk_is_sc(ltk)) {\r\nif (ev->ediv || ev->rand)\r\ngoto not_found;\r\n} else {\r\nif (ev->ediv != ltk->ediv || ev->rand != ltk->rand)\r\ngoto not_found;\r\n}\r\nmemcpy(cp.ltk, ltk->val, ltk->enc_size);\r\nmemset(cp.ltk + ltk->enc_size, 0, sizeof(cp.ltk) - ltk->enc_size);\r\ncp.handle = cpu_to_le16(conn->handle);\r\nconn->pending_sec_level = smp_ltk_sec_level(ltk);\r\nconn->enc_key_size = ltk->enc_size;\r\nhci_send_cmd(hdev, HCI_OP_LE_LTK_REPLY, sizeof(cp), &cp);\r\nif (ltk->type == SMP_STK) {\r\nset_bit(HCI_CONN_STK_ENCRYPT, &conn->flags);\r\nlist_del_rcu(&ltk->list);\r\nkfree_rcu(ltk, rcu);\r\n} else {\r\nclear_bit(HCI_CONN_STK_ENCRYPT, &conn->flags);\r\n}\r\nhci_dev_unlock(hdev);\r\nreturn;\r\nnot_found:\r\nneg.handle = ev->handle;\r\nhci_send_cmd(hdev, HCI_OP_LE_LTK_NEG_REPLY, sizeof(neg), &neg);\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void send_conn_param_neg_reply(struct hci_dev *hdev, u16 handle,\r\nu8 reason)\r\n{\r\nstruct hci_cp_le_conn_param_req_neg_reply cp;\r\ncp.handle = cpu_to_le16(handle);\r\ncp.reason = reason;\r\nhci_send_cmd(hdev, HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY, sizeof(cp),\r\n&cp);\r\n}\r\nstatic void hci_le_remote_conn_param_req_evt(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct hci_ev_le_remote_conn_param_req *ev = (void *) skb->data;\r\nstruct hci_cp_le_conn_param_req_reply cp;\r\nstruct hci_conn *hcon;\r\nu16 handle, min, max, latency, timeout;\r\nhandle = le16_to_cpu(ev->handle);\r\nmin = le16_to_cpu(ev->interval_min);\r\nmax = le16_to_cpu(ev->interval_max);\r\nlatency = le16_to_cpu(ev->latency);\r\ntimeout = le16_to_cpu(ev->timeout);\r\nhcon = hci_conn_hash_lookup_handle(hdev, handle);\r\nif (!hcon || hcon->state != BT_CONNECTED)\r\nreturn send_conn_param_neg_reply(hdev, handle,\r\nHCI_ERROR_UNKNOWN_CONN_ID);\r\nif (hci_check_conn_params(min, max, latency, timeout))\r\nreturn send_conn_param_neg_reply(hdev, handle,\r\nHCI_ERROR_INVALID_LL_PARAMS);\r\nif (hcon->role == HCI_ROLE_MASTER) {\r\nstruct hci_conn_params *params;\r\nu8 store_hint;\r\nhci_dev_lock(hdev);\r\nparams = hci_conn_params_lookup(hdev, &hcon->dst,\r\nhcon->dst_type);\r\nif (params) {\r\nparams->conn_min_interval = min;\r\nparams->conn_max_interval = max;\r\nparams->conn_latency = latency;\r\nparams->supervision_timeout = timeout;\r\nstore_hint = 0x01;\r\n} else{\r\nstore_hint = 0x00;\r\n}\r\nhci_dev_unlock(hdev);\r\nmgmt_new_conn_param(hdev, &hcon->dst, hcon->dst_type,\r\nstore_hint, min, max, latency, timeout);\r\n}\r\ncp.handle = ev->handle;\r\ncp.interval_min = ev->interval_min;\r\ncp.interval_max = ev->interval_max;\r\ncp.latency = ev->latency;\r\ncp.timeout = ev->timeout;\r\ncp.min_ce_len = 0;\r\ncp.max_ce_len = 0;\r\nhci_send_cmd(hdev, HCI_OP_LE_CONN_PARAM_REQ_REPLY, sizeof(cp), &cp);\r\n}\r\nstatic void hci_le_direct_adv_report_evt(struct hci_dev *hdev,\r\nstruct sk_buff *skb)\r\n{\r\nu8 num_reports = skb->data[0];\r\nvoid *ptr = &skb->data[1];\r\nhci_dev_lock(hdev);\r\nwhile (num_reports--) {\r\nstruct hci_ev_le_direct_adv_info *ev = ptr;\r\nprocess_adv_report(hdev, ev->evt_type, &ev->bdaddr,\r\nev->bdaddr_type, &ev->direct_addr,\r\nev->direct_addr_type, ev->rssi, NULL, 0);\r\nptr += sizeof(*ev);\r\n}\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic void hci_le_meta_evt(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_ev_le_meta *le_ev = (void *) skb->data;\r\nskb_pull(skb, sizeof(*le_ev));\r\nswitch (le_ev->subevent) {\r\ncase HCI_EV_LE_CONN_COMPLETE:\r\nhci_le_conn_complete_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_LE_CONN_UPDATE_COMPLETE:\r\nhci_le_conn_update_complete_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_LE_ADVERTISING_REPORT:\r\nhci_le_adv_report_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_LE_REMOTE_FEAT_COMPLETE:\r\nhci_le_remote_feat_complete_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_LE_LTK_REQ:\r\nhci_le_ltk_request_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_LE_REMOTE_CONN_PARAM_REQ:\r\nhci_le_remote_conn_param_req_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_LE_DIRECT_ADV_REPORT:\r\nhci_le_direct_adv_report_evt(hdev, skb);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic bool hci_get_cmd_complete(struct hci_dev *hdev, u16 opcode,\r\nu8 event, struct sk_buff *skb)\r\n{\r\nstruct hci_ev_cmd_complete *ev;\r\nstruct hci_event_hdr *hdr;\r\nif (!skb)\r\nreturn false;\r\nif (skb->len < sizeof(*hdr)) {\r\nBT_ERR("Too short HCI event");\r\nreturn false;\r\n}\r\nhdr = (void *) skb->data;\r\nskb_pull(skb, HCI_EVENT_HDR_SIZE);\r\nif (event) {\r\nif (hdr->evt != event)\r\nreturn false;\r\nreturn true;\r\n}\r\nif (hdr->evt != HCI_EV_CMD_COMPLETE) {\r\nBT_DBG("Last event is not cmd complete (0x%2.2x)", hdr->evt);\r\nreturn false;\r\n}\r\nif (skb->len < sizeof(*ev)) {\r\nBT_ERR("Too short cmd_complete event");\r\nreturn false;\r\n}\r\nev = (void *) skb->data;\r\nskb_pull(skb, sizeof(*ev));\r\nif (opcode != __le16_to_cpu(ev->opcode)) {\r\nBT_DBG("opcode doesn't match (0x%2.2x != 0x%2.2x)", opcode,\r\n__le16_to_cpu(ev->opcode));\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nvoid hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_event_hdr *hdr = (void *) skb->data;\r\nhci_req_complete_t req_complete = NULL;\r\nhci_req_complete_skb_t req_complete_skb = NULL;\r\nstruct sk_buff *orig_skb = NULL;\r\nu8 status = 0, event = hdr->evt, req_evt = 0;\r\nu16 opcode = HCI_OP_NOP;\r\nif (hdev->sent_cmd && bt_cb(hdev->sent_cmd)->hci.req_event == event) {\r\nstruct hci_command_hdr *cmd_hdr = (void *) hdev->sent_cmd->data;\r\nopcode = __le16_to_cpu(cmd_hdr->opcode);\r\nhci_req_cmd_complete(hdev, opcode, status, &req_complete,\r\n&req_complete_skb);\r\nreq_evt = event;\r\n}\r\nif (req_complete_skb || event == HCI_EV_CMD_STATUS ||\r\nevent == HCI_EV_CMD_COMPLETE)\r\norig_skb = skb_clone(skb, GFP_KERNEL);\r\nskb_pull(skb, HCI_EVENT_HDR_SIZE);\r\nswitch (event) {\r\ncase HCI_EV_INQUIRY_COMPLETE:\r\nhci_inquiry_complete_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_INQUIRY_RESULT:\r\nhci_inquiry_result_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_CONN_COMPLETE:\r\nhci_conn_complete_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_CONN_REQUEST:\r\nhci_conn_request_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_DISCONN_COMPLETE:\r\nhci_disconn_complete_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_AUTH_COMPLETE:\r\nhci_auth_complete_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_REMOTE_NAME:\r\nhci_remote_name_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_ENCRYPT_CHANGE:\r\nhci_encrypt_change_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_CHANGE_LINK_KEY_COMPLETE:\r\nhci_change_link_key_complete_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_REMOTE_FEATURES:\r\nhci_remote_features_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_CMD_COMPLETE:\r\nhci_cmd_complete_evt(hdev, skb, &opcode, &status,\r\n&req_complete, &req_complete_skb);\r\nbreak;\r\ncase HCI_EV_CMD_STATUS:\r\nhci_cmd_status_evt(hdev, skb, &opcode, &status, &req_complete,\r\n&req_complete_skb);\r\nbreak;\r\ncase HCI_EV_HARDWARE_ERROR:\r\nhci_hardware_error_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_ROLE_CHANGE:\r\nhci_role_change_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_NUM_COMP_PKTS:\r\nhci_num_comp_pkts_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_MODE_CHANGE:\r\nhci_mode_change_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_PIN_CODE_REQ:\r\nhci_pin_code_request_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_LINK_KEY_REQ:\r\nhci_link_key_request_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_LINK_KEY_NOTIFY:\r\nhci_link_key_notify_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_CLOCK_OFFSET:\r\nhci_clock_offset_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_PKT_TYPE_CHANGE:\r\nhci_pkt_type_change_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_PSCAN_REP_MODE:\r\nhci_pscan_rep_mode_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_INQUIRY_RESULT_WITH_RSSI:\r\nhci_inquiry_result_with_rssi_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_REMOTE_EXT_FEATURES:\r\nhci_remote_ext_features_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_SYNC_CONN_COMPLETE:\r\nhci_sync_conn_complete_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_EXTENDED_INQUIRY_RESULT:\r\nhci_extended_inquiry_result_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_KEY_REFRESH_COMPLETE:\r\nhci_key_refresh_complete_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_IO_CAPA_REQUEST:\r\nhci_io_capa_request_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_IO_CAPA_REPLY:\r\nhci_io_capa_reply_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_USER_CONFIRM_REQUEST:\r\nhci_user_confirm_request_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_USER_PASSKEY_REQUEST:\r\nhci_user_passkey_request_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_USER_PASSKEY_NOTIFY:\r\nhci_user_passkey_notify_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_KEYPRESS_NOTIFY:\r\nhci_keypress_notify_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_SIMPLE_PAIR_COMPLETE:\r\nhci_simple_pair_complete_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_REMOTE_HOST_FEATURES:\r\nhci_remote_host_features_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_LE_META:\r\nhci_le_meta_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_REMOTE_OOB_DATA_REQUEST:\r\nhci_remote_oob_data_request_evt(hdev, skb);\r\nbreak;\r\n#if IS_ENABLED(CONFIG_BT_HS)\r\ncase HCI_EV_CHANNEL_SELECTED:\r\nhci_chan_selected_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_PHY_LINK_COMPLETE:\r\nhci_phy_link_complete_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_LOGICAL_LINK_COMPLETE:\r\nhci_loglink_complete_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_DISCONN_LOGICAL_LINK_COMPLETE:\r\nhci_disconn_loglink_complete_evt(hdev, skb);\r\nbreak;\r\ncase HCI_EV_DISCONN_PHY_LINK_COMPLETE:\r\nhci_disconn_phylink_complete_evt(hdev, skb);\r\nbreak;\r\n#endif\r\ncase HCI_EV_NUM_COMP_BLOCKS:\r\nhci_num_comp_blocks_evt(hdev, skb);\r\nbreak;\r\ndefault:\r\nBT_DBG("%s event 0x%2.2x", hdev->name, event);\r\nbreak;\r\n}\r\nif (req_complete) {\r\nreq_complete(hdev, status, opcode);\r\n} else if (req_complete_skb) {\r\nif (!hci_get_cmd_complete(hdev, opcode, req_evt, orig_skb)) {\r\nkfree_skb(orig_skb);\r\norig_skb = NULL;\r\n}\r\nreq_complete_skb(hdev, status, opcode, orig_skb);\r\n}\r\nkfree_skb(orig_skb);\r\nkfree_skb(skb);\r\nhdev->stat.evt_rx++;\r\n}
