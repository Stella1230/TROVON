static struct jpu_buffer *vb2_to_jpu_buffer(struct vb2_v4l2_buffer *vb)\r\n{\r\nstruct v4l2_m2m_buffer *b =\r\ncontainer_of(vb, struct v4l2_m2m_buffer, vb);\r\nreturn container_of(b, struct jpu_buffer, buf);\r\n}\r\nstatic u32 jpu_read(struct jpu *jpu, unsigned int reg)\r\n{\r\nreturn ioread32(jpu->regs + reg);\r\n}\r\nstatic void jpu_write(struct jpu *jpu, u32 val, unsigned int reg)\r\n{\r\niowrite32(val, jpu->regs + reg);\r\n}\r\nstatic struct jpu_ctx *ctrl_to_ctx(struct v4l2_ctrl *c)\r\n{\r\nreturn container_of(c->handler, struct jpu_ctx, ctrl_handler);\r\n}\r\nstatic struct jpu_ctx *fh_to_ctx(struct v4l2_fh *fh)\r\n{\r\nreturn container_of(fh, struct jpu_ctx, fh);\r\n}\r\nstatic void jpu_set_tbl(struct jpu *jpu, u32 reg, const unsigned int *tbl,\r\nunsigned int len) {\r\nunsigned int i;\r\nfor (i = 0; i < len; i++)\r\njpu_write(jpu, tbl[i], reg + (i << 2));\r\n}\r\nstatic void jpu_set_qtbl(struct jpu *jpu, unsigned short quality)\r\n{\r\njpu_set_tbl(jpu, JCQTBL(0), qtbl_lum[quality], QTBL_SIZE);\r\njpu_set_tbl(jpu, JCQTBL(1), qtbl_chr[quality], QTBL_SIZE);\r\n}\r\nstatic void jpu_set_htbl(struct jpu *jpu)\r\n{\r\njpu_set_tbl(jpu, JCHTBD(0), hdctbl_lum, HDCTBL_SIZE);\r\njpu_set_tbl(jpu, JCHTBA(0), hactbl_lum, HACTBL_SIZE);\r\njpu_set_tbl(jpu, JCHTBD(1), hdctbl_chr, HDCTBL_SIZE);\r\njpu_set_tbl(jpu, JCHTBA(1), hactbl_chr, HACTBL_SIZE);\r\n}\r\nstatic int jpu_wait_reset(struct jpu *jpu)\r\n{\r\nunsigned long timeout;\r\ntimeout = jiffies + msecs_to_jiffies(JPU_RESET_TIMEOUT);\r\nwhile (jpu_read(jpu, JCCMD) & JCCMD_SRST) {\r\nif (time_after(jiffies, timeout)) {\r\ndev_err(jpu->dev, "timed out in reset\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nschedule();\r\n}\r\nreturn 0;\r\n}\r\nstatic int jpu_reset(struct jpu *jpu)\r\n{\r\njpu_write(jpu, JCCMD_SRST, JCCMD);\r\nreturn jpu_wait_reset(jpu);\r\n}\r\nstatic void put_qtbl(u8 *p, const u8 *qtbl)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(zigzag); i++)\r\np[i] = *(qtbl + zigzag[i]);\r\n}\r\nstatic void put_htbl(u8 *p, const u8 *htbl, unsigned int len)\r\n{\r\nunsigned int i, j;\r\nfor (i = 0; i < len; i += 4)\r\nfor (j = 0; j < 4 && (i + j) < len; ++j)\r\np[i + j] = htbl[i + 3 - j];\r\n}\r\nstatic void jpu_generate_hdr(unsigned short quality, unsigned char *p)\r\n{\r\nput_qtbl(p + JPU_JPEG_QTBL_LUM_OFFSET, (const u8 *)qtbl_lum[quality]);\r\nput_qtbl(p + JPU_JPEG_QTBL_CHR_OFFSET, (const u8 *)qtbl_chr[quality]);\r\nput_htbl(p + JPU_JPEG_HDCTBL_LUM_OFFSET, (const u8 *)hdctbl_lum,\r\nJPU_JPEG_HDCTBL_SIZE);\r\nput_htbl(p + JPU_JPEG_HACTBL_LUM_OFFSET, (const u8 *)hactbl_lum,\r\nJPU_JPEG_HACTBL_SIZE);\r\nput_htbl(p + JPU_JPEG_HDCTBL_CHR_OFFSET, (const u8 *)hdctbl_chr,\r\nJPU_JPEG_HDCTBL_SIZE);\r\nput_htbl(p + JPU_JPEG_HACTBL_CHR_OFFSET, (const u8 *)hactbl_chr,\r\nJPU_JPEG_HACTBL_SIZE);\r\n}\r\nstatic int get_byte(struct jpeg_buffer *buf)\r\n{\r\nif (buf->curr >= buf->end)\r\nreturn -1;\r\nreturn *(u8 *)buf->curr++;\r\n}\r\nstatic int get_word_be(struct jpeg_buffer *buf, unsigned int *word)\r\n{\r\nif (buf->end - buf->curr < 2)\r\nreturn -1;\r\n*word = get_unaligned_be16(buf->curr);\r\nbuf->curr += 2;\r\nreturn 0;\r\n}\r\nstatic void skip(struct jpeg_buffer *buf, unsigned long len)\r\n{\r\nbuf->curr += min((unsigned long)(buf->end - buf->curr), len);\r\n}\r\nstatic u8 jpu_parse_hdr(void *buffer, unsigned long size, unsigned int *width,\r\nunsigned int *height)\r\n{\r\nstruct jpeg_buffer jpeg_buffer;\r\nunsigned int word;\r\nbool soi = false;\r\njpeg_buffer.end = buffer + size;\r\njpeg_buffer.curr = buffer;\r\nif (size < JPU_JPEG_MIN_SIZE || *(u8 *)(buffer + size - 1) != EOI)\r\nreturn 0;\r\nfor (;;) {\r\nint c;\r\ndo\r\nc = get_byte(&jpeg_buffer);\r\nwhile (c == 0xff || c == 0);\r\nif (!soi && c == SOI) {\r\nsoi = true;\r\ncontinue;\r\n} else if (soi != (c != SOI))\r\nreturn 0;\r\nswitch (c) {\r\ncase SOF0:\r\nskip(&jpeg_buffer, 3);\r\nif (get_word_be(&jpeg_buffer, height) ||\r\nget_word_be(&jpeg_buffer, width) ||\r\nget_byte(&jpeg_buffer) != 3)\r\nreturn 0;\r\nskip(&jpeg_buffer, 1);\r\nreturn get_byte(&jpeg_buffer);\r\ncase DHT:\r\ncase DQT:\r\ncase COM:\r\ncase DRI:\r\ncase APP0 ... APP0 + 0x0f:\r\nif (get_word_be(&jpeg_buffer, &word))\r\nreturn 0;\r\nskip(&jpeg_buffer, (long)word - 2);\r\ncase 0:\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int jpu_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct jpu_ctx *ctx = fh_to_ctx(priv);\r\nif (ctx->encoder)\r\nstrlcpy(cap->card, DRV_NAME " encoder", sizeof(cap->card));\r\nelse\r\nstrlcpy(cap->card, DRV_NAME " decoder", sizeof(cap->card));\r\nstrlcpy(cap->driver, DRV_NAME, sizeof(cap->driver));\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s",\r\ndev_name(ctx->jpu->dev));\r\ncap->device_caps |= V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_M2M_MPLANE;\r\ncap->capabilities = V4L2_CAP_DEVICE_CAPS | cap->device_caps;\r\nmemset(cap->reserved, 0, sizeof(cap->reserved));\r\nreturn 0;\r\n}\r\nstatic struct jpu_fmt *jpu_find_format(bool encoder, u32 pixelformat,\r\nunsigned int fmt_type)\r\n{\r\nunsigned int i, fmt_flag;\r\nif (encoder)\r\nfmt_flag = fmt_type == JPU_FMT_TYPE_OUTPUT ? JPU_ENC_OUTPUT :\r\nJPU_ENC_CAPTURE;\r\nelse\r\nfmt_flag = fmt_type == JPU_FMT_TYPE_OUTPUT ? JPU_DEC_OUTPUT :\r\nJPU_DEC_CAPTURE;\r\nfor (i = 0; i < ARRAY_SIZE(jpu_formats); i++) {\r\nstruct jpu_fmt *fmt = &jpu_formats[i];\r\nif (fmt->fourcc == pixelformat && fmt->types & fmt_flag)\r\nreturn fmt;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int jpu_enum_fmt(struct v4l2_fmtdesc *f, u32 type)\r\n{\r\nunsigned int i, num = 0;\r\nfor (i = 0; i < ARRAY_SIZE(jpu_formats); ++i) {\r\nif (jpu_formats[i].types & type) {\r\nif (num == f->index)\r\nbreak;\r\n++num;\r\n}\r\n}\r\nif (i >= ARRAY_SIZE(jpu_formats))\r\nreturn -EINVAL;\r\nf->pixelformat = jpu_formats[i].fourcc;\r\nreturn 0;\r\n}\r\nstatic int jpu_enum_fmt_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct jpu_ctx *ctx = fh_to_ctx(priv);\r\nreturn jpu_enum_fmt(f, ctx->encoder ? JPU_ENC_CAPTURE :\r\nJPU_DEC_CAPTURE);\r\n}\r\nstatic int jpu_enum_fmt_out(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct jpu_ctx *ctx = fh_to_ctx(priv);\r\nreturn jpu_enum_fmt(f, ctx->encoder ? JPU_ENC_OUTPUT : JPU_DEC_OUTPUT);\r\n}\r\nstatic struct jpu_q_data *jpu_get_q_data(struct jpu_ctx *ctx,\r\nenum v4l2_buf_type type)\r\n{\r\nif (V4L2_TYPE_IS_OUTPUT(type))\r\nreturn &ctx->out_q;\r\nelse\r\nreturn &ctx->cap_q;\r\n}\r\nstatic void jpu_bound_align_image(u32 *w, unsigned int w_min,\r\nunsigned int w_max, unsigned int w_align,\r\nu32 *h, unsigned int h_min,\r\nunsigned int h_max, unsigned int h_align)\r\n{\r\nunsigned int width, height, w_step, h_step;\r\nwidth = *w;\r\nheight = *h;\r\nw_step = 1U << w_align;\r\nh_step = 1U << h_align;\r\nv4l_bound_align_image(w, w_min, w_max, w_align, h, h_min, h_max,\r\nh_align, 3);\r\nif (*w < width && *w + w_step < w_max)\r\n*w += w_step;\r\nif (*h < height && *h + h_step < h_max)\r\n*h += h_step;\r\n}\r\nstatic int __jpu_try_fmt(struct jpu_ctx *ctx, struct jpu_fmt **fmtinfo,\r\nstruct v4l2_pix_format_mplane *pix,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct jpu_fmt *fmt;\r\nunsigned int f_type, w, h;\r\nf_type = V4L2_TYPE_IS_OUTPUT(type) ? JPU_FMT_TYPE_OUTPUT :\r\nJPU_FMT_TYPE_CAPTURE;\r\nfmt = jpu_find_format(ctx->encoder, pix->pixelformat, f_type);\r\nif (!fmt) {\r\nunsigned int pixelformat;\r\ndev_dbg(ctx->jpu->dev, "unknown format; set default format\n");\r\nif (ctx->encoder)\r\npixelformat = f_type == JPU_FMT_TYPE_OUTPUT ?\r\nV4L2_PIX_FMT_NV16M : V4L2_PIX_FMT_JPEG;\r\nelse\r\npixelformat = f_type == JPU_FMT_TYPE_CAPTURE ?\r\nV4L2_PIX_FMT_NV16M : V4L2_PIX_FMT_JPEG;\r\nfmt = jpu_find_format(ctx->encoder, pixelformat, f_type);\r\n}\r\npix->pixelformat = fmt->fourcc;\r\npix->colorspace = fmt->colorspace;\r\npix->field = V4L2_FIELD_NONE;\r\npix->num_planes = fmt->num_planes;\r\nmemset(pix->reserved, 0, sizeof(pix->reserved));\r\njpu_bound_align_image(&pix->width, JPU_WIDTH_MIN, JPU_WIDTH_MAX,\r\nfmt->h_align, &pix->height, JPU_HEIGHT_MIN,\r\nJPU_HEIGHT_MAX, fmt->v_align);\r\nw = pix->width;\r\nh = pix->height;\r\nif (fmt->fourcc == V4L2_PIX_FMT_JPEG) {\r\nif (pix->plane_fmt[0].sizeimage <= 0 || ctx->encoder)\r\npix->plane_fmt[0].sizeimage = JPU_JPEG_HDR_SIZE +\r\n(JPU_JPEG_MAX_BYTES_PER_PIXEL * w * h);\r\npix->plane_fmt[0].bytesperline = 0;\r\nmemset(pix->plane_fmt[0].reserved, 0,\r\nsizeof(pix->plane_fmt[0].reserved));\r\n} else {\r\nunsigned int i, bpl = 0;\r\nfor (i = 0; i < pix->num_planes; ++i)\r\nbpl = max(bpl, pix->plane_fmt[i].bytesperline);\r\nbpl = clamp_t(unsigned int, bpl, w, JPU_WIDTH_MAX);\r\nbpl = round_up(bpl, JPU_MEMALIGN);\r\nfor (i = 0; i < pix->num_planes; ++i) {\r\npix->plane_fmt[i].bytesperline = bpl;\r\npix->plane_fmt[i].sizeimage = bpl * h * fmt->bpp[i] / 8;\r\nmemset(pix->plane_fmt[i].reserved, 0,\r\nsizeof(pix->plane_fmt[i].reserved));\r\n}\r\n}\r\nif (fmtinfo)\r\n*fmtinfo = fmt;\r\nreturn 0;\r\n}\r\nstatic int jpu_try_fmt(struct file *file, void *priv, struct v4l2_format *f)\r\n{\r\nstruct jpu_ctx *ctx = fh_to_ctx(priv);\r\nif (!v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type))\r\nreturn -EINVAL;\r\nreturn __jpu_try_fmt(ctx, NULL, &f->fmt.pix_mp, f->type);\r\n}\r\nstatic int jpu_s_fmt(struct file *file, void *priv, struct v4l2_format *f)\r\n{\r\nstruct vb2_queue *vq;\r\nstruct jpu_ctx *ctx = fh_to_ctx(priv);\r\nstruct v4l2_m2m_ctx *m2m_ctx = ctx->fh.m2m_ctx;\r\nstruct jpu_fmt *fmtinfo;\r\nstruct jpu_q_data *q_data;\r\nint ret;\r\nvq = v4l2_m2m_get_vq(m2m_ctx, f->type);\r\nif (!vq)\r\nreturn -EINVAL;\r\nif (vb2_is_busy(vq)) {\r\nv4l2_err(&ctx->jpu->v4l2_dev, "%s queue busy\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nret = __jpu_try_fmt(ctx, &fmtinfo, &f->fmt.pix_mp, f->type);\r\nif (ret < 0)\r\nreturn ret;\r\nq_data = jpu_get_q_data(ctx, f->type);\r\nq_data->format = f->fmt.pix_mp;\r\nq_data->fmtinfo = fmtinfo;\r\nreturn 0;\r\n}\r\nstatic int jpu_g_fmt(struct file *file, void *priv, struct v4l2_format *f)\r\n{\r\nstruct jpu_q_data *q_data;\r\nstruct jpu_ctx *ctx = fh_to_ctx(priv);\r\nif (!v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type))\r\nreturn -EINVAL;\r\nq_data = jpu_get_q_data(ctx, f->type);\r\nf->fmt.pix_mp = q_data->format;\r\nreturn 0;\r\n}\r\nstatic int jpu_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct jpu_ctx *ctx = ctrl_to_ctx(ctrl);\r\nunsigned long flags;\r\nspin_lock_irqsave(&ctx->jpu->lock, flags);\r\nif (ctrl->id == V4L2_CID_JPEG_COMPRESSION_QUALITY)\r\nctx->compr_quality = ctrl->val;\r\nspin_unlock_irqrestore(&ctx->jpu->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int jpu_streamon(struct file *file, void *priv, enum v4l2_buf_type type)\r\n{\r\nstruct jpu_ctx *ctx = fh_to_ctx(priv);\r\nstruct jpu_q_data *src_q_data, *dst_q_data, *orig, adj, *ref;\r\nenum v4l2_buf_type adj_type;\r\nsrc_q_data = jpu_get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\r\ndst_q_data = jpu_get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\r\nif (ctx->encoder) {\r\nadj = *src_q_data;\r\norig = src_q_data;\r\nref = dst_q_data;\r\nadj_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\r\n} else {\r\nadj = *dst_q_data;\r\norig = dst_q_data;\r\nref = src_q_data;\r\nadj_type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\r\n}\r\nadj.format.width = ref->format.width;\r\nadj.format.height = ref->format.height;\r\n__jpu_try_fmt(ctx, NULL, &adj.format, adj_type);\r\nif (adj.format.width != orig->format.width ||\r\nadj.format.height != orig->format.height) {\r\ndev_err(ctx->jpu->dev, "src and dst formats do not match.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn v4l2_m2m_streamon(file, ctx->fh.m2m_ctx, type);\r\n}\r\nstatic int jpu_controls_create(struct jpu_ctx *ctx)\r\n{\r\nstruct v4l2_ctrl *ctrl;\r\nint ret;\r\nv4l2_ctrl_handler_init(&ctx->ctrl_handler, 1);\r\nctrl = v4l2_ctrl_new_std(&ctx->ctrl_handler, &jpu_ctrl_ops,\r\nV4L2_CID_JPEG_COMPRESSION_QUALITY,\r\n0, JPU_MAX_QUALITY - 1, 1, 0);\r\nif (ctx->ctrl_handler.error) {\r\nret = ctx->ctrl_handler.error;\r\ngoto error_free;\r\n}\r\nif (!ctx->encoder)\r\nctrl->flags |= V4L2_CTRL_FLAG_VOLATILE |\r\nV4L2_CTRL_FLAG_READ_ONLY;\r\nret = v4l2_ctrl_handler_setup(&ctx->ctrl_handler);\r\nif (ret < 0)\r\ngoto error_free;\r\nreturn 0;\r\nerror_free:\r\nv4l2_ctrl_handler_free(&ctx->ctrl_handler);\r\nreturn ret;\r\n}\r\nstatic int jpu_queue_setup(struct vb2_queue *vq,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], struct device *alloc_devs[])\r\n{\r\nstruct jpu_ctx *ctx = vb2_get_drv_priv(vq);\r\nstruct jpu_q_data *q_data;\r\nunsigned int i;\r\nq_data = jpu_get_q_data(ctx, vq->type);\r\nif (*nplanes) {\r\nif (*nplanes != q_data->format.num_planes)\r\nreturn -EINVAL;\r\nfor (i = 0; i < *nplanes; i++) {\r\nunsigned int q_size = q_data->format.plane_fmt[i].sizeimage;\r\nif (sizes[i] < q_size)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\n*nplanes = q_data->format.num_planes;\r\nfor (i = 0; i < *nplanes; i++)\r\nsizes[i] = q_data->format.plane_fmt[i].sizeimage;\r\nreturn 0;\r\n}\r\nstatic int jpu_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct jpu_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct jpu_q_data *q_data;\r\nunsigned int i;\r\nq_data = jpu_get_q_data(ctx, vb->vb2_queue->type);\r\nif (V4L2_TYPE_IS_OUTPUT(vb->vb2_queue->type)) {\r\nif (vbuf->field == V4L2_FIELD_ANY)\r\nvbuf->field = V4L2_FIELD_NONE;\r\nif (vbuf->field != V4L2_FIELD_NONE) {\r\ndev_err(ctx->jpu->dev, "%s field isn't supported\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\n}\r\nfor (i = 0; i < q_data->format.num_planes; i++) {\r\nunsigned long size = q_data->format.plane_fmt[i].sizeimage;\r\nif (vb2_plane_size(vb, i) < size) {\r\ndev_err(ctx->jpu->dev,\r\n"%s: data will not fit into plane (%lu < %lu)\n",\r\n__func__, vb2_plane_size(vb, i), size);\r\nreturn -EINVAL;\r\n}\r\nif (!ctx->encoder && !V4L2_TYPE_IS_OUTPUT(vb->vb2_queue->type))\r\nvb2_set_plane_payload(vb, i, size);\r\n}\r\nreturn 0;\r\n}\r\nstatic void jpu_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct jpu_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nif (!ctx->encoder && V4L2_TYPE_IS_OUTPUT(vb->vb2_queue->type)) {\r\nstruct jpu_buffer *jpu_buf = vb2_to_jpu_buffer(vbuf);\r\nstruct jpu_q_data *q_data, adjust;\r\nvoid *buffer = vb2_plane_vaddr(vb, 0);\r\nunsigned long buf_size = vb2_get_plane_payload(vb, 0);\r\nunsigned int width, height;\r\nu8 subsampling = jpu_parse_hdr(buffer, buf_size, &width,\r\n&height);\r\nif (subsampling != JPU_JPEG_422 && subsampling != JPU_JPEG_420)\r\ngoto format_error;\r\nq_data = &ctx->out_q;\r\nadjust = *q_data;\r\nadjust.format.width = width;\r\nadjust.format.height = height;\r\n__jpu_try_fmt(ctx, &adjust.fmtinfo, &adjust.format,\r\nV4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\r\nif (adjust.format.width != q_data->format.width ||\r\nadjust.format.height != q_data->format.height)\r\ngoto format_error;\r\njpu_buf->subsampling = subsampling;\r\n}\r\nif (ctx->fh.m2m_ctx)\r\nv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\r\nreturn;\r\nformat_error:\r\ndev_err(ctx->jpu->dev, "incompatible or corrupted JPEG data\n");\r\nvb2_buffer_done(vb, VB2_BUF_STATE_ERROR);\r\n}\r\nstatic void jpu_buf_finish(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct jpu_buffer *jpu_buf = vb2_to_jpu_buffer(vbuf);\r\nstruct jpu_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct jpu_q_data *q_data = &ctx->out_q;\r\nenum v4l2_buf_type type = vb->vb2_queue->type;\r\nu8 *buffer;\r\nif (vb->state == VB2_BUF_STATE_DONE)\r\nvbuf->sequence = jpu_get_q_data(ctx, type)->sequence++;\r\nif (!ctx->encoder || vb->state != VB2_BUF_STATE_DONE ||\r\nV4L2_TYPE_IS_OUTPUT(type))\r\nreturn;\r\nbuffer = vb2_plane_vaddr(vb, 0);\r\nmemcpy(buffer, jpeg_hdrs[jpu_buf->compr_quality], JPU_JPEG_HDR_SIZE);\r\n*(__be16 *)(buffer + JPU_JPEG_HEIGHT_OFFSET) =\r\ncpu_to_be16(q_data->format.height);\r\n*(__be16 *)(buffer + JPU_JPEG_WIDTH_OFFSET) =\r\ncpu_to_be16(q_data->format.width);\r\n*(buffer + JPU_JPEG_SUBS_OFFSET) = q_data->fmtinfo->subsampling;\r\n}\r\nstatic int jpu_start_streaming(struct vb2_queue *vq, unsigned count)\r\n{\r\nstruct jpu_ctx *ctx = vb2_get_drv_priv(vq);\r\nstruct jpu_q_data *q_data = jpu_get_q_data(ctx, vq->type);\r\nq_data->sequence = 0;\r\nreturn 0;\r\n}\r\nstatic void jpu_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct jpu_ctx *ctx = vb2_get_drv_priv(vq);\r\nstruct vb2_v4l2_buffer *vb;\r\nunsigned long flags;\r\nfor (;;) {\r\nif (V4L2_TYPE_IS_OUTPUT(vq->type))\r\nvb = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\r\nelse\r\nvb = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\r\nif (vb == NULL)\r\nreturn;\r\nspin_lock_irqsave(&ctx->jpu->lock, flags);\r\nv4l2_m2m_buf_done(vb, VB2_BUF_STATE_ERROR);\r\nspin_unlock_irqrestore(&ctx->jpu->lock, flags);\r\n}\r\n}\r\nstatic int jpu_queue_init(void *priv, struct vb2_queue *src_vq,\r\nstruct vb2_queue *dst_vq)\r\n{\r\nstruct jpu_ctx *ctx = priv;\r\nint ret;\r\nmemset(src_vq, 0, sizeof(*src_vq));\r\nsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\r\nsrc_vq->io_modes = VB2_MMAP | VB2_DMABUF;\r\nsrc_vq->drv_priv = ctx;\r\nsrc_vq->buf_struct_size = sizeof(struct jpu_buffer);\r\nsrc_vq->ops = &jpu_qops;\r\nsrc_vq->mem_ops = &vb2_dma_contig_memops;\r\nsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\nsrc_vq->lock = &ctx->jpu->mutex;\r\nsrc_vq->dev = ctx->jpu->v4l2_dev.dev;\r\nret = vb2_queue_init(src_vq);\r\nif (ret)\r\nreturn ret;\r\nmemset(dst_vq, 0, sizeof(*dst_vq));\r\ndst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\r\ndst_vq->io_modes = VB2_MMAP | VB2_DMABUF;\r\ndst_vq->drv_priv = ctx;\r\ndst_vq->buf_struct_size = sizeof(struct jpu_buffer);\r\ndst_vq->ops = &jpu_qops;\r\ndst_vq->mem_ops = &vb2_dma_contig_memops;\r\ndst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\ndst_vq->lock = &ctx->jpu->mutex;\r\ndst_vq->dev = ctx->jpu->v4l2_dev.dev;\r\nreturn vb2_queue_init(dst_vq);\r\n}\r\nstatic int jpu_open(struct file *file)\r\n{\r\nstruct jpu *jpu = video_drvdata(file);\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct jpu_ctx *ctx;\r\nint ret;\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nv4l2_fh_init(&ctx->fh, vfd);\r\nctx->fh.ctrl_handler = &ctx->ctrl_handler;\r\nfile->private_data = &ctx->fh;\r\nv4l2_fh_add(&ctx->fh);\r\nctx->jpu = jpu;\r\nctx->encoder = vfd == &jpu->vfd_encoder;\r\n__jpu_try_fmt(ctx, &ctx->out_q.fmtinfo, &ctx->out_q.format,\r\nV4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\r\n__jpu_try_fmt(ctx, &ctx->cap_q.fmtinfo, &ctx->cap_q.format,\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\r\nctx->fh.m2m_ctx = v4l2_m2m_ctx_init(jpu->m2m_dev, ctx, jpu_queue_init);\r\nif (IS_ERR(ctx->fh.m2m_ctx)) {\r\nret = PTR_ERR(ctx->fh.m2m_ctx);\r\ngoto v4l_prepare_rollback;\r\n}\r\nret = jpu_controls_create(ctx);\r\nif (ret < 0)\r\ngoto v4l_prepare_rollback;\r\nif (mutex_lock_interruptible(&jpu->mutex)) {\r\nret = -ERESTARTSYS;\r\ngoto v4l_prepare_rollback;\r\n}\r\nif (jpu->ref_count == 0) {\r\nret = clk_prepare_enable(jpu->clk);\r\nif (ret < 0)\r\ngoto device_prepare_rollback;\r\nret = jpu_reset(jpu);\r\nif (ret)\r\ngoto device_prepare_rollback;\r\n}\r\njpu->ref_count++;\r\nmutex_unlock(&jpu->mutex);\r\nreturn 0;\r\ndevice_prepare_rollback:\r\nmutex_unlock(&jpu->mutex);\r\nv4l_prepare_rollback:\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nkfree(ctx);\r\nreturn ret;\r\n}\r\nstatic int jpu_release(struct file *file)\r\n{\r\nstruct jpu *jpu = video_drvdata(file);\r\nstruct jpu_ctx *ctx = fh_to_ctx(file->private_data);\r\nv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\r\nv4l2_ctrl_handler_free(&ctx->ctrl_handler);\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nkfree(ctx);\r\nmutex_lock(&jpu->mutex);\r\nif (--jpu->ref_count == 0)\r\nclk_disable_unprepare(jpu->clk);\r\nmutex_unlock(&jpu->mutex);\r\nreturn 0;\r\n}\r\nstatic void jpu_cleanup(struct jpu_ctx *ctx, bool reset)\r\n{\r\nstruct vb2_v4l2_buffer *src_buf, *dst_buf;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ctx->jpu->lock, flags);\r\nsrc_buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\r\ndst_buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\r\nv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_ERROR);\r\nv4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_ERROR);\r\nif (reset)\r\njpu_write(ctx->jpu, JCCMD_SRST, JCCMD);\r\nspin_unlock_irqrestore(&ctx->jpu->lock, flags);\r\nv4l2_m2m_job_finish(ctx->jpu->m2m_dev, ctx->fh.m2m_ctx);\r\n}\r\nstatic void jpu_device_run(void *priv)\r\n{\r\nstruct jpu_ctx *ctx = priv;\r\nstruct jpu *jpu = ctx->jpu;\r\nstruct jpu_buffer *jpu_buf;\r\nstruct jpu_q_data *q_data;\r\nstruct vb2_v4l2_buffer *src_buf, *dst_buf;\r\nunsigned int w, h, bpl;\r\nunsigned char num_planes, subsampling;\r\nunsigned long flags;\r\nif (jpu_wait_reset(jpu)) {\r\njpu_cleanup(ctx, true);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&ctx->jpu->lock, flags);\r\njpu->curr = ctx;\r\nsrc_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);\r\ndst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);\r\nif (ctx->encoder) {\r\njpu_buf = vb2_to_jpu_buffer(dst_buf);\r\nq_data = &ctx->out_q;\r\n} else {\r\njpu_buf = vb2_to_jpu_buffer(src_buf);\r\nq_data = &ctx->cap_q;\r\n}\r\nw = q_data->format.width;\r\nh = q_data->format.height;\r\nbpl = q_data->format.plane_fmt[0].bytesperline;\r\nnum_planes = q_data->fmtinfo->num_planes;\r\nsubsampling = q_data->fmtinfo->subsampling;\r\nif (ctx->encoder) {\r\nunsigned long src_1_addr, src_2_addr, dst_addr;\r\nunsigned int redu, inft;\r\ndst_addr = vb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 0);\r\nsrc_1_addr =\r\nvb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, 0);\r\nif (num_planes > 1)\r\nsrc_2_addr = vb2_dma_contig_plane_dma_addr(\r\n&src_buf->vb2_buf, 1);\r\nelse\r\nsrc_2_addr = src_1_addr + w * h;\r\njpu_buf->compr_quality = ctx->compr_quality;\r\nif (subsampling == JPU_JPEG_420) {\r\nredu = JCMOD_REDU_420;\r\ninft = JIFECNT_INFT_420;\r\n} else {\r\nredu = JCMOD_REDU_422;\r\ninft = JIFECNT_INFT_422;\r\n}\r\njpu_write(jpu, JCMOD_DSP_ENC | JCMOD_PCTR | redu |\r\nJCMOD_MSKIP_ENABLE, JCMOD);\r\njpu_write(jpu, JIFECNT_SWAP_WB | inft, JIFECNT);\r\njpu_write(jpu, JIFDCNT_SWAP_WB, JIFDCNT);\r\njpu_write(jpu, JINTE_TRANSF_COMPL, JINTE);\r\njpu_write(jpu, src_1_addr, JIFESYA1);\r\njpu_write(jpu, src_2_addr, JIFESCA1);\r\njpu_write(jpu, bpl, JIFESMW);\r\njpu_write(jpu, (w >> 8) & JCSZ_MASK, JCHSZU);\r\njpu_write(jpu, w & JCSZ_MASK, JCHSZD);\r\njpu_write(jpu, (h >> 8) & JCSZ_MASK, JCVSZU);\r\njpu_write(jpu, h & JCSZ_MASK, JCVSZD);\r\njpu_write(jpu, w, JIFESHSZ);\r\njpu_write(jpu, h, JIFESVSZ);\r\njpu_write(jpu, dst_addr + JPU_JPEG_HDR_SIZE, JIFEDA1);\r\njpu_write(jpu, 0 << JCQTN_SHIFT(1) | 1 << JCQTN_SHIFT(2) |\r\n1 << JCQTN_SHIFT(3), JCQTN);\r\njpu_write(jpu, 0 << JCHTN_AC_SHIFT(1) | 0 << JCHTN_DC_SHIFT(1) |\r\n1 << JCHTN_AC_SHIFT(2) | 1 << JCHTN_DC_SHIFT(2) |\r\n1 << JCHTN_AC_SHIFT(3) | 1 << JCHTN_DC_SHIFT(3),\r\nJCHTN);\r\njpu_set_qtbl(jpu, ctx->compr_quality);\r\njpu_set_htbl(jpu);\r\n} else {\r\nunsigned long src_addr, dst_1_addr, dst_2_addr;\r\nif (jpu_buf->subsampling != subsampling) {\r\ndev_err(ctx->jpu->dev,\r\n"src and dst formats do not match.\n");\r\nspin_unlock_irqrestore(&ctx->jpu->lock, flags);\r\njpu_cleanup(ctx, false);\r\nreturn;\r\n}\r\nsrc_addr = vb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, 0);\r\ndst_1_addr =\r\nvb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 0);\r\nif (q_data->fmtinfo->num_planes > 1)\r\ndst_2_addr = vb2_dma_contig_plane_dma_addr(\r\n&dst_buf->vb2_buf, 1);\r\nelse\r\ndst_2_addr = dst_1_addr + w * h;\r\njpu_write(jpu, JCMOD_DSP_DEC | JCMOD_PCTR, JCMOD);\r\njpu_write(jpu, JIFECNT_SWAP_WB, JIFECNT);\r\njpu_write(jpu, JIFDCNT_SWAP_WB, JIFDCNT);\r\njpu_write(jpu, JINTE_TRANSF_COMPL | JINTE_ERR, JINTE);\r\njpu_write(jpu, src_addr, JIFDSA1);\r\njpu_write(jpu, dst_1_addr, JIFDDYA1);\r\njpu_write(jpu, dst_2_addr, JIFDDCA1);\r\njpu_write(jpu, bpl, JIFDDMW);\r\n}\r\njpu_write(jpu, JCCMD_JSRT, JCCMD);\r\nspin_unlock_irqrestore(&ctx->jpu->lock, flags);\r\n}\r\nstatic int jpu_job_ready(void *priv)\r\n{\r\nreturn 1;\r\n}\r\nstatic void jpu_job_abort(void *priv)\r\n{\r\nstruct jpu_ctx *ctx = priv;\r\nif (!wait_event_timeout(ctx->jpu->irq_queue, !ctx->jpu->curr,\r\nmsecs_to_jiffies(JPU_JOB_TIMEOUT)))\r\njpu_cleanup(ctx, true);\r\n}\r\nstatic irqreturn_t jpu_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct jpu *jpu = dev_id;\r\nstruct jpu_ctx *curr_ctx;\r\nstruct vb2_v4l2_buffer *src_buf, *dst_buf;\r\nunsigned int int_status;\r\nint_status = jpu_read(jpu, JINTS);\r\nif (!((JINTS_TRANSF_COMPL | JINTS_PROCESS_COMPL | JINTS_ERR) &\r\nint_status))\r\nreturn IRQ_NONE;\r\njpu_write(jpu, ~(int_status & JINTS_MASK), JINTS);\r\nif (int_status & (JINTS_ERR | JINTS_PROCESS_COMPL))\r\njpu_write(jpu, JCCMD_JEND, JCCMD);\r\nspin_lock(&jpu->lock);\r\nif ((int_status & JINTS_PROCESS_COMPL) &&\r\n!(int_status & JINTS_TRANSF_COMPL))\r\ngoto handled;\r\ncurr_ctx = v4l2_m2m_get_curr_priv(jpu->m2m_dev);\r\nif (!curr_ctx) {\r\ndev_err(jpu->dev, "no active context for m2m\n");\r\ngoto handled;\r\n}\r\nsrc_buf = v4l2_m2m_src_buf_remove(curr_ctx->fh.m2m_ctx);\r\ndst_buf = v4l2_m2m_dst_buf_remove(curr_ctx->fh.m2m_ctx);\r\nif (int_status & JINTS_TRANSF_COMPL) {\r\nif (curr_ctx->encoder) {\r\nunsigned long payload_size = jpu_read(jpu, JCDTCU) << 16\r\n| jpu_read(jpu, JCDTCM) << 8\r\n| jpu_read(jpu, JCDTCD);\r\nvb2_set_plane_payload(&dst_buf->vb2_buf, 0,\r\npayload_size + JPU_JPEG_HDR_SIZE);\r\n}\r\ndst_buf->field = src_buf->field;\r\ndst_buf->vb2_buf.timestamp = src_buf->vb2_buf.timestamp;\r\nif (src_buf->flags & V4L2_BUF_FLAG_TIMECODE)\r\ndst_buf->timecode = src_buf->timecode;\r\ndst_buf->flags = src_buf->flags &\r\n(V4L2_BUF_FLAG_TIMECODE | V4L2_BUF_FLAG_KEYFRAME |\r\nV4L2_BUF_FLAG_PFRAME | V4L2_BUF_FLAG_BFRAME |\r\nV4L2_BUF_FLAG_TSTAMP_SRC_MASK);\r\nv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);\r\nv4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_DONE);\r\n} else if (int_status & JINTS_ERR) {\r\nunsigned char error = jpu_read(jpu, JCDERR) & JCDERR_MASK;\r\ndev_dbg(jpu->dev, "processing error: %#X: %s\n", error,\r\nerror_to_text[error]);\r\nv4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_ERROR);\r\nv4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_ERROR);\r\n}\r\njpu->curr = NULL;\r\njpu_write(jpu, JCCMD_SRST, JCCMD);\r\nspin_unlock(&jpu->lock);\r\nv4l2_m2m_job_finish(jpu->m2m_dev, curr_ctx->fh.m2m_ctx);\r\nwake_up(&jpu->irq_queue);\r\nreturn IRQ_HANDLED;\r\nhandled:\r\nspin_unlock(&jpu->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int jpu_probe(struct platform_device *pdev)\r\n{\r\nstruct jpu *jpu;\r\nstruct resource *res;\r\nint ret;\r\nunsigned int i;\r\njpu = devm_kzalloc(&pdev->dev, sizeof(*jpu), GFP_KERNEL);\r\nif (!jpu)\r\nreturn -ENOMEM;\r\ninit_waitqueue_head(&jpu->irq_queue);\r\nmutex_init(&jpu->mutex);\r\nspin_lock_init(&jpu->lock);\r\njpu->dev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\njpu->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(jpu->regs))\r\nreturn PTR_ERR(jpu->regs);\r\njpu->irq = ret = platform_get_irq(pdev, 0);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "cannot find IRQ\n");\r\nreturn ret;\r\n}\r\nret = devm_request_irq(&pdev->dev, jpu->irq, jpu_irq_handler, 0,\r\ndev_name(&pdev->dev), jpu);\r\nif (ret) {\r\ndev_err(&pdev->dev, "cannot claim IRQ %d\n", jpu->irq);\r\nreturn ret;\r\n}\r\njpu->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(jpu->clk)) {\r\ndev_err(&pdev->dev, "cannot get clock\n");\r\nreturn PTR_ERR(jpu->clk);\r\n}\r\nret = v4l2_device_register(&pdev->dev, &jpu->v4l2_dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to register v4l2 device\n");\r\nreturn ret;\r\n}\r\njpu->m2m_dev = v4l2_m2m_init(&jpu_m2m_ops);\r\nif (IS_ERR(jpu->m2m_dev)) {\r\nv4l2_err(&jpu->v4l2_dev, "Failed to init mem2mem device\n");\r\nret = PTR_ERR(jpu->m2m_dev);\r\ngoto device_register_rollback;\r\n}\r\nfor (i = 0; i < JPU_MAX_QUALITY; i++)\r\njpu_generate_hdr(i, (unsigned char *)jpeg_hdrs[i]);\r\nstrlcpy(jpu->vfd_encoder.name, DRV_NAME, sizeof(jpu->vfd_encoder.name));\r\njpu->vfd_encoder.fops = &jpu_fops;\r\njpu->vfd_encoder.ioctl_ops = &jpu_ioctl_ops;\r\njpu->vfd_encoder.minor = -1;\r\njpu->vfd_encoder.release = video_device_release_empty;\r\njpu->vfd_encoder.lock = &jpu->mutex;\r\njpu->vfd_encoder.v4l2_dev = &jpu->v4l2_dev;\r\njpu->vfd_encoder.vfl_dir = VFL_DIR_M2M;\r\nret = video_register_device(&jpu->vfd_encoder, VFL_TYPE_GRABBER, -1);\r\nif (ret) {\r\nv4l2_err(&jpu->v4l2_dev, "Failed to register video device\n");\r\ngoto m2m_init_rollback;\r\n}\r\nvideo_set_drvdata(&jpu->vfd_encoder, jpu);\r\nstrlcpy(jpu->vfd_decoder.name, DRV_NAME, sizeof(jpu->vfd_decoder.name));\r\njpu->vfd_decoder.fops = &jpu_fops;\r\njpu->vfd_decoder.ioctl_ops = &jpu_ioctl_ops;\r\njpu->vfd_decoder.minor = -1;\r\njpu->vfd_decoder.release = video_device_release_empty;\r\njpu->vfd_decoder.lock = &jpu->mutex;\r\njpu->vfd_decoder.v4l2_dev = &jpu->v4l2_dev;\r\njpu->vfd_decoder.vfl_dir = VFL_DIR_M2M;\r\nret = video_register_device(&jpu->vfd_decoder, VFL_TYPE_GRABBER, -1);\r\nif (ret) {\r\nv4l2_err(&jpu->v4l2_dev, "Failed to register video device\n");\r\ngoto enc_vdev_register_rollback;\r\n}\r\nvideo_set_drvdata(&jpu->vfd_decoder, jpu);\r\nplatform_set_drvdata(pdev, jpu);\r\nv4l2_info(&jpu->v4l2_dev, "encoder device registered as /dev/video%d\n",\r\njpu->vfd_encoder.num);\r\nv4l2_info(&jpu->v4l2_dev, "decoder device registered as /dev/video%d\n",\r\njpu->vfd_decoder.num);\r\nreturn 0;\r\nenc_vdev_register_rollback:\r\nvideo_unregister_device(&jpu->vfd_encoder);\r\nm2m_init_rollback:\r\nv4l2_m2m_release(jpu->m2m_dev);\r\ndevice_register_rollback:\r\nv4l2_device_unregister(&jpu->v4l2_dev);\r\nreturn ret;\r\n}\r\nstatic int jpu_remove(struct platform_device *pdev)\r\n{\r\nstruct jpu *jpu = platform_get_drvdata(pdev);\r\nvideo_unregister_device(&jpu->vfd_decoder);\r\nvideo_unregister_device(&jpu->vfd_encoder);\r\nv4l2_m2m_release(jpu->m2m_dev);\r\nv4l2_device_unregister(&jpu->v4l2_dev);\r\nreturn 0;\r\n}\r\nstatic int jpu_suspend(struct device *dev)\r\n{\r\nstruct jpu *jpu = dev_get_drvdata(dev);\r\nif (jpu->ref_count == 0)\r\nreturn 0;\r\nclk_disable_unprepare(jpu->clk);\r\nreturn 0;\r\n}\r\nstatic int jpu_resume(struct device *dev)\r\n{\r\nstruct jpu *jpu = dev_get_drvdata(dev);\r\nif (jpu->ref_count == 0)\r\nreturn 0;\r\nclk_prepare_enable(jpu->clk);\r\nreturn 0;\r\n}
