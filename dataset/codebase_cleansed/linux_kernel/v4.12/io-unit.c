static void __init iounit_iommu_init(struct platform_device *op)\r\n{\r\nstruct iounit_struct *iounit;\r\niopte_t __iomem *xpt;\r\niopte_t __iomem *xptend;\r\niounit = kzalloc(sizeof(struct iounit_struct), GFP_ATOMIC);\r\nif (!iounit) {\r\nprom_printf("SUN4D: Cannot alloc iounit, halting.\n");\r\nprom_halt();\r\n}\r\niounit->limit[0] = IOUNIT_BMAP1_START;\r\niounit->limit[1] = IOUNIT_BMAP2_START;\r\niounit->limit[2] = IOUNIT_BMAPM_START;\r\niounit->limit[3] = IOUNIT_BMAPM_END;\r\niounit->rotor[1] = IOUNIT_BMAP2_START;\r\niounit->rotor[2] = IOUNIT_BMAPM_START;\r\nxpt = of_ioremap(&op->resource[2], 0, PAGE_SIZE * 16, "XPT");\r\nif (!xpt) {\r\nprom_printf("SUN4D: Cannot map External Page Table.");\r\nprom_halt();\r\n}\r\nop->dev.archdata.iommu = iounit;\r\niounit->page_table = xpt;\r\nspin_lock_init(&iounit->lock);\r\nxptend = iounit->page_table + (16 * PAGE_SIZE) / sizeof(iopte_t);\r\nfor (; xpt < xptend; xpt++)\r\nsbus_writel(0, xpt);\r\n}\r\nstatic int __init iounit_init(void)\r\n{\r\nextern void sun4d_init_sbi_irq(void);\r\nstruct device_node *dp;\r\nfor_each_node_by_name(dp, "sbi") {\r\nstruct platform_device *op = of_find_device_by_node(dp);\r\niounit_iommu_init(op);\r\nof_propagate_archdata(op);\r\n}\r\nsun4d_init_sbi_irq();\r\nreturn 0;\r\n}\r\nstatic unsigned long iounit_get_area(struct iounit_struct *iounit, unsigned long vaddr, int size)\r\n{\r\nint i, j, k, npages;\r\nunsigned long rotor, scan, limit;\r\niopte_t iopte;\r\nnpages = ((vaddr & ~PAGE_MASK) + size + (PAGE_SIZE-1)) >> PAGE_SHIFT;\r\nswitch (npages) {\r\ncase 1: i = 0x0231; break;\r\ncase 2: i = 0x0132; break;\r\ndefault: i = 0x0213; break;\r\n}\r\nIOD(("iounit_get_area(%08lx,%d[%d])=", vaddr, size, npages));\r\nnext: j = (i & 15);\r\nrotor = iounit->rotor[j - 1];\r\nlimit = iounit->limit[j];\r\nscan = rotor;\r\nnexti: scan = find_next_zero_bit(iounit->bmap, limit, scan);\r\nif (scan + npages > limit) {\r\nif (limit != rotor) {\r\nlimit = rotor;\r\nscan = iounit->limit[j - 1];\r\ngoto nexti;\r\n}\r\ni >>= 4;\r\nif (!(i & 15))\r\npanic("iounit_get_area: Couldn't find free iopte slots for (%08lx,%d)\n", vaddr, size);\r\ngoto next;\r\n}\r\nfor (k = 1, scan++; k < npages; k++)\r\nif (test_bit(scan++, iounit->bmap))\r\ngoto nexti;\r\niounit->rotor[j - 1] = (scan < limit) ? scan : iounit->limit[j - 1];\r\nscan -= npages;\r\niopte = MKIOPTE(__pa(vaddr & PAGE_MASK));\r\nvaddr = IOUNIT_DMA_BASE + (scan << PAGE_SHIFT) + (vaddr & ~PAGE_MASK);\r\nfor (k = 0; k < npages; k++, iopte = __iopte(iopte_val(iopte) + 0x100), scan++) {\r\nset_bit(scan, iounit->bmap);\r\nsbus_writel(iopte_val(iopte), &iounit->page_table[scan]);\r\n}\r\nIOD(("%08lx\n", vaddr));\r\nreturn vaddr;\r\n}\r\nstatic __u32 iounit_get_scsi_one(struct device *dev, char *vaddr, unsigned long len)\r\n{\r\nstruct iounit_struct *iounit = dev->archdata.iommu;\r\nunsigned long ret, flags;\r\nspin_lock_irqsave(&iounit->lock, flags);\r\nret = iounit_get_area(iounit, (unsigned long)vaddr, len);\r\nspin_unlock_irqrestore(&iounit->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void iounit_get_scsi_sgl(struct device *dev, struct scatterlist *sg, int sz)\r\n{\r\nstruct iounit_struct *iounit = dev->archdata.iommu;\r\nunsigned long flags;\r\nspin_lock_irqsave(&iounit->lock, flags);\r\nwhile (sz != 0) {\r\n--sz;\r\nsg->dma_address = iounit_get_area(iounit, (unsigned long) sg_virt(sg), sg->length);\r\nsg->dma_length = sg->length;\r\nsg = sg_next(sg);\r\n}\r\nspin_unlock_irqrestore(&iounit->lock, flags);\r\n}\r\nstatic void iounit_release_scsi_one(struct device *dev, __u32 vaddr, unsigned long len)\r\n{\r\nstruct iounit_struct *iounit = dev->archdata.iommu;\r\nunsigned long flags;\r\nspin_lock_irqsave(&iounit->lock, flags);\r\nlen = ((vaddr & ~PAGE_MASK) + len + (PAGE_SIZE-1)) >> PAGE_SHIFT;\r\nvaddr = (vaddr - IOUNIT_DMA_BASE) >> PAGE_SHIFT;\r\nIOD(("iounit_release %08lx-%08lx\n", (long)vaddr, (long)len+vaddr));\r\nfor (len += vaddr; vaddr < len; vaddr++)\r\nclear_bit(vaddr, iounit->bmap);\r\nspin_unlock_irqrestore(&iounit->lock, flags);\r\n}\r\nstatic void iounit_release_scsi_sgl(struct device *dev, struct scatterlist *sg, int sz)\r\n{\r\nstruct iounit_struct *iounit = dev->archdata.iommu;\r\nunsigned long flags;\r\nunsigned long vaddr, len;\r\nspin_lock_irqsave(&iounit->lock, flags);\r\nwhile (sz != 0) {\r\n--sz;\r\nlen = ((sg->dma_address & ~PAGE_MASK) + sg->length + (PAGE_SIZE-1)) >> PAGE_SHIFT;\r\nvaddr = (sg->dma_address - IOUNIT_DMA_BASE) >> PAGE_SHIFT;\r\nIOD(("iounit_release %08lx-%08lx\n", (long)vaddr, (long)len+vaddr));\r\nfor (len += vaddr; vaddr < len; vaddr++)\r\nclear_bit(vaddr, iounit->bmap);\r\nsg = sg_next(sg);\r\n}\r\nspin_unlock_irqrestore(&iounit->lock, flags);\r\n}\r\nstatic int iounit_map_dma_area(struct device *dev, dma_addr_t *pba, unsigned long va, unsigned long addr, int len)\r\n{\r\nstruct iounit_struct *iounit = dev->archdata.iommu;\r\nunsigned long page, end;\r\npgprot_t dvma_prot;\r\niopte_t __iomem *iopte;\r\n*pba = addr;\r\ndvma_prot = __pgprot(SRMMU_CACHE | SRMMU_ET_PTE | SRMMU_PRIV);\r\nend = PAGE_ALIGN((addr + len));\r\nwhile(addr < end) {\r\npage = va;\r\n{\r\npgd_t *pgdp;\r\npmd_t *pmdp;\r\npte_t *ptep;\r\nlong i;\r\npgdp = pgd_offset(&init_mm, addr);\r\npmdp = pmd_offset(pgdp, addr);\r\nptep = pte_offset_map(pmdp, addr);\r\nset_pte(ptep, mk_pte(virt_to_page(page), dvma_prot));\r\ni = ((addr - IOUNIT_DMA_BASE) >> PAGE_SHIFT);\r\niopte = iounit->page_table + i;\r\nsbus_writel(iopte_val(MKIOPTE(__pa(page))), iopte);\r\n}\r\naddr += PAGE_SIZE;\r\nva += PAGE_SIZE;\r\n}\r\nflush_cache_all();\r\nflush_tlb_all();\r\nreturn 0;\r\n}\r\nstatic void iounit_unmap_dma_area(struct device *dev, unsigned long addr, int len)\r\n{\r\n}\r\nvoid __init ld_mmu_iounit(void)\r\n{\r\nsparc32_dma_ops = &iounit_dma_ops;\r\n}
