static void\r\ngen_build_id(struct buildid_note *note,\r\nunsigned long load_addr __maybe_unused,\r\nconst void *code __maybe_unused,\r\nsize_t csize __maybe_unused)\r\n{\r\nint fd;\r\nsize_t sz = sizeof(note->build_id);\r\nssize_t sret;\r\nfd = open("/dev/urandom", O_RDONLY);\r\nif (fd == -1)\r\nerr(1, "cannot access /dev/urandom for builid");\r\nsret = read(fd, note->build_id, sz);\r\nclose(fd);\r\nif (sret != (ssize_t)sz)\r\nmemset(note->build_id, 0, sz);\r\n}\r\nstatic void\r\ngen_build_id(struct buildid_note *note,\r\nunsigned long load_addr __maybe_unused,\r\nconst void *code,\r\nsize_t csize)\r\n{\r\nif (sizeof(note->build_id) < SHA_DIGEST_LENGTH)\r\nerrx(1, "build_id too small for SHA1");\r\nSHA1(code, csize, (unsigned char *)note->build_id);\r\n}\r\nstatic void\r\ngen_build_id(struct buildid_note *note, unsigned long load_addr, const void *code, size_t csize)\r\n{\r\nMD5_CTX context;\r\nif (sizeof(note->build_id) < 16)\r\nerrx(1, "build_id too small for MD5");\r\nMD5_Init(&context);\r\nMD5_Update(&context, &load_addr, sizeof(load_addr));\r\nMD5_Update(&context, code, csize);\r\nMD5_Final((unsigned char *)note->build_id, &context);\r\n}\r\nstatic int\r\njit_add_eh_frame_info(Elf *e, void* unwinding, uint64_t unwinding_header_size,\r\nuint64_t unwinding_size, uint64_t base_offset)\r\n{\r\nElf_Data *d;\r\nElf_Scn *scn;\r\nElf_Shdr *shdr;\r\nuint64_t unwinding_table_size = unwinding_size - unwinding_header_size;\r\nscn = elf_newscn(e);\r\nif (!scn) {\r\nwarnx("cannot create section");\r\nreturn -1;\r\n}\r\nd = elf_newdata(scn);\r\nif (!d) {\r\nwarnx("cannot get new data");\r\nreturn -1;\r\n}\r\nd->d_align = 8;\r\nd->d_off = 0LL;\r\nd->d_buf = unwinding;\r\nd->d_type = ELF_T_BYTE;\r\nd->d_size = unwinding_table_size;\r\nd->d_version = EV_CURRENT;\r\nshdr = elf_getshdr(scn);\r\nif (!shdr) {\r\nwarnx("cannot get section header");\r\nreturn -1;\r\n}\r\nshdr->sh_name = 104;\r\nshdr->sh_type = SHT_PROGBITS;\r\nshdr->sh_addr = base_offset;\r\nshdr->sh_flags = SHF_ALLOC;\r\nshdr->sh_entsize = 0;\r\nscn = elf_newscn(e);\r\nif (!scn) {\r\nwarnx("cannot create section");\r\nreturn -1;\r\n}\r\nd = elf_newdata(scn);\r\nif (!d) {\r\nwarnx("cannot get new data");\r\nreturn -1;\r\n}\r\nd->d_align = 4;\r\nd->d_off = 0LL;\r\nd->d_buf = unwinding + unwinding_table_size;\r\nd->d_type = ELF_T_BYTE;\r\nd->d_size = unwinding_header_size;\r\nd->d_version = EV_CURRENT;\r\nshdr = elf_getshdr(scn);\r\nif (!shdr) {\r\nwarnx("cannot get section header");\r\nreturn -1;\r\n}\r\nshdr->sh_name = 90;\r\nshdr->sh_type = SHT_PROGBITS;\r\nshdr->sh_addr = base_offset + unwinding_table_size;\r\nshdr->sh_flags = SHF_ALLOC;\r\nshdr->sh_entsize = 0;\r\nreturn 0;\r\n}\r\nint\r\njit_write_elf(int fd, uint64_t load_addr, const char *sym,\r\nconst void *code, int csize,\r\nvoid *debug __maybe_unused, int nr_debug_entries __maybe_unused,\r\nvoid *unwinding, uint64_t unwinding_header_size, uint64_t unwinding_size)\r\n{\r\nElf *e;\r\nElf_Data *d;\r\nElf_Scn *scn;\r\nElf_Ehdr *ehdr;\r\nElf_Shdr *shdr;\r\nuint64_t eh_frame_base_offset;\r\nchar *strsym = NULL;\r\nint symlen;\r\nint retval = -1;\r\nif (elf_version(EV_CURRENT) == EV_NONE) {\r\nwarnx("ELF initialization failed");\r\nreturn -1;\r\n}\r\ne = elf_begin(fd, ELF_C_WRITE, NULL);\r\nif (!e) {\r\nwarnx("elf_begin failed");\r\ngoto error;\r\n}\r\nehdr = elf_newehdr(e);\r\nif (!ehdr) {\r\nwarnx("cannot get ehdr");\r\ngoto error;\r\n}\r\nehdr->e_ident[EI_DATA] = GEN_ELF_ENDIAN;\r\nehdr->e_ident[EI_CLASS] = GEN_ELF_CLASS;\r\nehdr->e_machine = GEN_ELF_ARCH;\r\nehdr->e_type = ET_DYN;\r\nehdr->e_entry = GEN_ELF_TEXT_OFFSET;\r\nehdr->e_version = EV_CURRENT;\r\nehdr->e_shstrndx= unwinding ? 4 : 2;\r\nscn = elf_newscn(e);\r\nif (!scn) {\r\nwarnx("cannot create section");\r\ngoto error;\r\n}\r\nd = elf_newdata(scn);\r\nif (!d) {\r\nwarnx("cannot get new data");\r\ngoto error;\r\n}\r\nd->d_align = 16;\r\nd->d_off = 0LL;\r\nd->d_buf = (void *)code;\r\nd->d_type = ELF_T_BYTE;\r\nd->d_size = csize;\r\nd->d_version = EV_CURRENT;\r\nshdr = elf_getshdr(scn);\r\nif (!shdr) {\r\nwarnx("cannot get section header");\r\ngoto error;\r\n}\r\nshdr->sh_name = 1;\r\nshdr->sh_type = SHT_PROGBITS;\r\nshdr->sh_addr = GEN_ELF_TEXT_OFFSET;\r\nshdr->sh_flags = SHF_EXECINSTR | SHF_ALLOC;\r\nshdr->sh_entsize = 0;\r\nif (unwinding) {\r\neh_frame_base_offset = ALIGN_8(GEN_ELF_TEXT_OFFSET + csize);\r\nretval = jit_add_eh_frame_info(e, unwinding,\r\nunwinding_header_size, unwinding_size,\r\neh_frame_base_offset);\r\nif (retval)\r\ngoto error;\r\n}\r\nscn = elf_newscn(e);\r\nif (!scn) {\r\nwarnx("cannot create section");\r\ngoto error;\r\n}\r\nd = elf_newdata(scn);\r\nif (!d) {\r\nwarnx("cannot get new data");\r\ngoto error;\r\n}\r\nd->d_align = 1;\r\nd->d_off = 0LL;\r\nd->d_buf = shd_string_table;\r\nd->d_type = ELF_T_BYTE;\r\nd->d_size = sizeof(shd_string_table);\r\nd->d_version = EV_CURRENT;\r\nshdr = elf_getshdr(scn);\r\nif (!shdr) {\r\nwarnx("cannot get section header");\r\ngoto error;\r\n}\r\nshdr->sh_name = 7;\r\nshdr->sh_type = SHT_STRTAB;\r\nshdr->sh_flags = 0;\r\nshdr->sh_entsize = 0;\r\nsymtab[1].st_size = csize;\r\nsymtab[1].st_value = GEN_ELF_TEXT_OFFSET;\r\nscn = elf_newscn(e);\r\nif (!scn) {\r\nwarnx("cannot create section");\r\ngoto error;\r\n}\r\nd = elf_newdata(scn);\r\nif (!d) {\r\nwarnx("cannot get new data");\r\ngoto error;\r\n}\r\nd->d_align = 8;\r\nd->d_off = 0LL;\r\nd->d_buf = symtab;\r\nd->d_type = ELF_T_SYM;\r\nd->d_size = sizeof(symtab);\r\nd->d_version = EV_CURRENT;\r\nshdr = elf_getshdr(scn);\r\nif (!shdr) {\r\nwarnx("cannot get section header");\r\ngoto error;\r\n}\r\nshdr->sh_name = 17;\r\nshdr->sh_type = SHT_SYMTAB;\r\nshdr->sh_flags = 0;\r\nshdr->sh_entsize = sizeof(Elf_Sym);\r\nshdr->sh_link = unwinding ? 6 : 4;\r\nsymlen = 2 + strlen(sym);\r\nstrsym = calloc(1, symlen);\r\nif (!strsym) {\r\nwarnx("cannot allocate strsym");\r\ngoto error;\r\n}\r\nstrcpy(strsym + 1, sym);\r\nscn = elf_newscn(e);\r\nif (!scn) {\r\nwarnx("cannot create section");\r\ngoto error;\r\n}\r\nd = elf_newdata(scn);\r\nif (!d) {\r\nwarnx("cannot get new data");\r\ngoto error;\r\n}\r\nd->d_align = 1;\r\nd->d_off = 0LL;\r\nd->d_buf = strsym;\r\nd->d_type = ELF_T_BYTE;\r\nd->d_size = symlen;\r\nd->d_version = EV_CURRENT;\r\nshdr = elf_getshdr(scn);\r\nif (!shdr) {\r\nwarnx("cannot get section header");\r\ngoto error;\r\n}\r\nshdr->sh_name = 25;\r\nshdr->sh_type = SHT_STRTAB;\r\nshdr->sh_flags = 0;\r\nshdr->sh_entsize = 0;\r\nscn = elf_newscn(e);\r\nif (!scn) {\r\nwarnx("cannot create section");\r\ngoto error;\r\n}\r\nd = elf_newdata(scn);\r\nif (!d) {\r\nwarnx("cannot get new data");\r\ngoto error;\r\n}\r\ngen_build_id(&bnote, load_addr, code, csize);\r\nbnote.desc.namesz = sizeof(bnote.name);\r\nbnote.desc.descsz = sizeof(bnote.build_id);\r\nbnote.desc.type = NT_GNU_BUILD_ID;\r\nstrcpy(bnote.name, "GNU");\r\nd->d_align = 4;\r\nd->d_off = 0LL;\r\nd->d_buf = &bnote;\r\nd->d_type = ELF_T_BYTE;\r\nd->d_size = sizeof(bnote);\r\nd->d_version = EV_CURRENT;\r\nshdr = elf_getshdr(scn);\r\nif (!shdr) {\r\nwarnx("cannot get section header");\r\ngoto error;\r\n}\r\nshdr->sh_name = 33;\r\nshdr->sh_type = SHT_NOTE;\r\nshdr->sh_addr = 0x0;\r\nshdr->sh_flags = SHF_ALLOC;\r\nshdr->sh_size = sizeof(bnote);\r\nshdr->sh_entsize = 0;\r\n#ifdef HAVE_DWARF_SUPPORT\r\nif (debug && nr_debug_entries) {\r\nretval = jit_add_debug_info(e, load_addr, debug, nr_debug_entries);\r\nif (retval)\r\ngoto error;\r\n} else\r\n#endif\r\n{\r\nif (elf_update(e, ELF_C_WRITE) < 0) {\r\nwarnx("elf_update 4 failed");\r\ngoto error;\r\n}\r\n}\r\nretval = 0;\r\nerror:\r\n(void)elf_end(e);\r\nfree(strsym);\r\nreturn retval;\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nint c, fd, ret;\r\nwhile ((c = getopt(argc, argv, "o:h")) != -1) {\r\nswitch (c) {\r\ncase 'o':\r\noptions.output = optarg;\r\nbreak;\r\ncase 'h':\r\nprintf("Usage: genelf -o output_file [-h]\n");\r\nreturn 0;\r\ndefault:\r\nerrx(1, "unknown option");\r\n}\r\n}\r\nfd = open(options.output, O_CREAT|O_TRUNC|O_RDWR, 0666);\r\nif (fd == -1)\r\nerr(1, "cannot create file %s", options.output);\r\nret = jit_write_elf(fd, "main", x86_code, sizeof(x86_code));\r\nclose(fd);\r\nif (ret != 0)\r\nunlink(options.output);\r\nreturn ret;\r\n}
