static int pio2_gpio_get(struct gpio_chip *chip, unsigned int offset)\r\n{\r\nu8 reg;\r\nint retval;\r\nstruct pio2_card *card = gpiochip_get_data(chip);\r\nif ((card->bank[PIO2_CHANNEL_BANK[offset]].config == OUTPUT) |\r\n(card->bank[PIO2_CHANNEL_BANK[offset]].config == NOFIT)) {\r\ndev_err(&card->vdev->dev, "Channel not available as input\n");\r\nreturn 0;\r\n}\r\nretval = vme_master_read(card->window, &reg, 1,\r\nPIO2_REGS_DATA[PIO2_CHANNEL_BANK[offset]]);\r\nif (retval < 0) {\r\ndev_err(&card->vdev->dev, "Unable to read from GPIO\n");\r\nreturn 0;\r\n}\r\nif (reg & PIO2_CHANNEL_BIT[offset]) {\r\nif (card->bank[PIO2_CHANNEL_BANK[offset]].config != BOTH)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nif (card->bank[PIO2_CHANNEL_BANK[offset]].config != BOTH)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void pio2_gpio_set(struct gpio_chip *chip,\r\nunsigned int offset, int value)\r\n{\r\nu8 reg;\r\nint retval;\r\nstruct pio2_card *card = gpiochip_get_data(chip);\r\nif ((card->bank[PIO2_CHANNEL_BANK[offset]].config == INPUT) |\r\n(card->bank[PIO2_CHANNEL_BANK[offset]].config == NOFIT)) {\r\ndev_err(&card->vdev->dev, "Channel not available as output\n");\r\nreturn;\r\n}\r\nif (value)\r\nreg = card->bank[PIO2_CHANNEL_BANK[offset]].value |\r\nPIO2_CHANNEL_BIT[offset];\r\nelse\r\nreg = card->bank[PIO2_CHANNEL_BANK[offset]].value &\r\n~PIO2_CHANNEL_BIT[offset];\r\nretval = vme_master_write(card->window, &reg, 1,\r\nPIO2_REGS_DATA[PIO2_CHANNEL_BANK[offset]]);\r\nif (retval < 0) {\r\ndev_err(&card->vdev->dev, "Unable to write to GPIO\n");\r\nreturn;\r\n}\r\ncard->bank[PIO2_CHANNEL_BANK[offset]].value = reg;\r\n}\r\nstatic int pio2_gpio_dir_in(struct gpio_chip *chip, unsigned int offset)\r\n{\r\nint data;\r\nstruct pio2_card *card = gpiochip_get_data(chip);\r\nif ((card->bank[PIO2_CHANNEL_BANK[offset]].config == OUTPUT) |\r\n(card->bank[PIO2_CHANNEL_BANK[offset]].config == NOFIT)) {\r\ndev_err(&card->vdev->dev,\r\n"Channel directionality not configurable at runtime\n");\r\ndata = -EINVAL;\r\n} else {\r\ndata = 0;\r\n}\r\nreturn data;\r\n}\r\nstatic int pio2_gpio_dir_out(struct gpio_chip *chip,\r\nunsigned int offset, int value)\r\n{\r\nint data;\r\nstruct pio2_card *card = gpiochip_get_data(chip);\r\nif ((card->bank[PIO2_CHANNEL_BANK[offset]].config == INPUT) |\r\n(card->bank[PIO2_CHANNEL_BANK[offset]].config == NOFIT)) {\r\ndev_err(&card->vdev->dev,\r\n"Channel directionality not configurable at runtime\n");\r\ndata = -EINVAL;\r\n} else {\r\ndata = 0;\r\n}\r\nreturn data;\r\n}\r\nint pio2_gpio_reset(struct pio2_card *card)\r\n{\r\nint retval = 0;\r\nint i, j;\r\nu8 data = 0;\r\nfor (i = 0; i < 4; i++) {\r\nretval = vme_master_write(card->window, &data, 1,\r\nPIO2_REGS_DATA[i]);\r\nif (retval < 0)\r\nreturn retval;\r\ncard->bank[i].value = 0;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nretval = vme_master_write(card->window, &data, 1,\r\nPIO2_REGS_INT_MASK[i * 2]);\r\nif (retval < 0)\r\nreturn retval;\r\nretval = vme_master_write(card->window, &data, 1,\r\nPIO2_REGS_INT_MASK[(i * 2) + 1]);\r\nif (retval < 0)\r\nreturn retval;\r\nfor (j = 0; j < 8; j++)\r\ncard->bank[i].irq[j] = NONE;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\ndo {\r\nretval = vme_master_read(card->window, &data, 1,\r\nPIO2_REGS_INT_STAT[i]);\r\nif (retval < 0)\r\nreturn retval;\r\n} while (data != 0);\r\n}\r\nreturn 0;\r\n}\r\nint pio2_gpio_init(struct pio2_card *card)\r\n{\r\nint retval = 0;\r\nchar *label;\r\nlabel = kasprintf(GFP_KERNEL,\r\n"%s@%s", driver_name, dev_name(&card->vdev->dev));\r\nif (!label)\r\nreturn -ENOMEM;\r\ncard->gc.label = label;\r\ncard->gc.ngpio = PIO2_NUM_CHANNELS;\r\ncard->gc.base = -1;\r\ncard->gc.direction_input = pio2_gpio_dir_in;\r\ncard->gc.direction_output = pio2_gpio_dir_out;\r\ncard->gc.get = pio2_gpio_get;\r\ncard->gc.set = pio2_gpio_set;\r\nretval = gpiochip_add_data(&card->gc, card);\r\nif (retval) {\r\ndev_err(&card->vdev->dev, "Unable to register GPIO\n");\r\nkfree(card->gc.label);\r\n}\r\nreturn retval;\r\n}\r\nvoid pio2_gpio_exit(struct pio2_card *card)\r\n{\r\nconst char *label = card->gc.label;\r\ngpiochip_remove(&card->gc);\r\nkfree(label);\r\n}
