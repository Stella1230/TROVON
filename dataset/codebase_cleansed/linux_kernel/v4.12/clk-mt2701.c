static int mtk_topckgen_init(struct platform_device *pdev)\r\n{\r\nstruct clk_onecell_data *clk_data;\r\nvoid __iomem *base;\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nclk_data = mtk_alloc_clk_data(CLK_TOP_NR);\r\nmtk_clk_register_fixed_clks(top_fixed_clks, ARRAY_SIZE(top_fixed_clks),\r\nclk_data);\r\nmtk_clk_register_factors(top_fixed_divs, ARRAY_SIZE(top_fixed_divs),\r\nclk_data);\r\nmtk_clk_register_composites(top_muxes, ARRAY_SIZE(top_muxes),\r\nbase, &mt2701_clk_lock, clk_data);\r\nmtk_clk_register_dividers(top_adj_divs, ARRAY_SIZE(top_adj_divs),\r\nbase, &mt2701_clk_lock, clk_data);\r\nmtk_clk_register_gates(node, top_clks, ARRAY_SIZE(top_clks),\r\nclk_data);\r\nreturn of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);\r\n}\r\nstatic void mtk_infrasys_init_early(struct device_node *node)\r\n{\r\nint r, i;\r\nif (!infra_clk_data) {\r\ninfra_clk_data = mtk_alloc_clk_data(CLK_INFRA_NR);\r\nfor (i = 0; i < CLK_INFRA_NR; i++)\r\ninfra_clk_data->clks[i] = ERR_PTR(-EPROBE_DEFER);\r\n}\r\nmtk_clk_register_factors(infra_fixed_divs, ARRAY_SIZE(infra_fixed_divs),\r\ninfra_clk_data);\r\nr = of_clk_add_provider(node, of_clk_src_onecell_get, infra_clk_data);\r\nif (r)\r\npr_err("%s(): could not register clock provider: %d\n",\r\n__func__, r);\r\n}\r\nstatic int mtk_infrasys_init(struct platform_device *pdev)\r\n{\r\nint r, i;\r\nstruct device_node *node = pdev->dev.of_node;\r\nif (!infra_clk_data) {\r\ninfra_clk_data = mtk_alloc_clk_data(CLK_INFRA_NR);\r\n} else {\r\nfor (i = 0; i < CLK_INFRA_NR; i++) {\r\nif (infra_clk_data->clks[i] == ERR_PTR(-EPROBE_DEFER))\r\ninfra_clk_data->clks[i] = ERR_PTR(-ENOENT);\r\n}\r\n}\r\nmtk_clk_register_gates(node, infra_clks, ARRAY_SIZE(infra_clks),\r\ninfra_clk_data);\r\nmtk_clk_register_factors(infra_fixed_divs, ARRAY_SIZE(infra_fixed_divs),\r\ninfra_clk_data);\r\nr = of_clk_add_provider(node, of_clk_src_onecell_get, infra_clk_data);\r\nif (r)\r\nreturn r;\r\nmtk_register_reset_controller(node, 2, 0x30);\r\nreturn 0;\r\n}\r\nstatic int mtk_pericfg_init(struct platform_device *pdev)\r\n{\r\nstruct clk_onecell_data *clk_data;\r\nvoid __iomem *base;\r\nint r;\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nclk_data = mtk_alloc_clk_data(CLK_PERI_NR);\r\nmtk_clk_register_gates(node, peri_clks, ARRAY_SIZE(peri_clks),\r\nclk_data);\r\nmtk_clk_register_composites(peri_muxs, ARRAY_SIZE(peri_muxs), base,\r\n&mt2701_clk_lock, clk_data);\r\nr = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);\r\nif (r)\r\nreturn r;\r\nmtk_register_reset_controller(node, 2, 0x0);\r\nreturn 0;\r\n}\r\nstatic int mtk_apmixedsys_init(struct platform_device *pdev)\r\n{\r\nstruct clk_onecell_data *clk_data;\r\nstruct device_node *node = pdev->dev.of_node;\r\nclk_data = mtk_alloc_clk_data(CLK_APMIXED_NR);\r\nif (!clk_data)\r\nreturn -ENOMEM;\r\nmtk_clk_register_plls(node, apmixed_plls, ARRAY_SIZE(apmixed_plls),\r\nclk_data);\r\nreturn of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);\r\n}\r\nstatic int clk_mt2701_probe(struct platform_device *pdev)\r\n{\r\nint (*clk_init)(struct platform_device *);\r\nint r;\r\nclk_init = of_device_get_match_data(&pdev->dev);\r\nif (!clk_init)\r\nreturn -EINVAL;\r\nr = clk_init(pdev);\r\nif (r)\r\ndev_err(&pdev->dev,\r\n"could not register clock provider: %s: %d\n",\r\npdev->name, r);\r\nreturn r;\r\n}\r\nstatic int __init clk_mt2701_init(void)\r\n{\r\nreturn platform_driver_register(&clk_mt2701_drv);\r\n}
