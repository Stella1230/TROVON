static void nfs_free_delegation(struct nfs_delegation *delegation)\r\n{\r\nif (delegation->cred) {\r\nput_rpccred(delegation->cred);\r\ndelegation->cred = NULL;\r\n}\r\nkfree_rcu(delegation, rcu);\r\n}\r\nvoid nfs_mark_delegation_referenced(struct nfs_delegation *delegation)\r\n{\r\nset_bit(NFS_DELEGATION_REFERENCED, &delegation->flags);\r\n}\r\nstatic bool\r\nnfs4_is_valid_delegation(const struct nfs_delegation *delegation,\r\nfmode_t flags)\r\n{\r\nif (delegation != NULL && (delegation->type & flags) == flags &&\r\n!test_bit(NFS_DELEGATION_REVOKED, &delegation->flags) &&\r\n!test_bit(NFS_DELEGATION_RETURNING, &delegation->flags))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int\r\nnfs4_do_check_delegation(struct inode *inode, fmode_t flags, bool mark)\r\n{\r\nstruct nfs_delegation *delegation;\r\nint ret = 0;\r\nflags &= FMODE_READ|FMODE_WRITE;\r\nrcu_read_lock();\r\ndelegation = rcu_dereference(NFS_I(inode)->delegation);\r\nif (nfs4_is_valid_delegation(delegation, flags)) {\r\nif (mark)\r\nnfs_mark_delegation_referenced(delegation);\r\nret = 1;\r\n}\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nint nfs4_have_delegation(struct inode *inode, fmode_t flags)\r\n{\r\nreturn nfs4_do_check_delegation(inode, flags, true);\r\n}\r\nint nfs4_check_delegation(struct inode *inode, fmode_t flags)\r\n{\r\nreturn nfs4_do_check_delegation(inode, flags, false);\r\n}\r\nstatic int nfs_delegation_claim_locks(struct nfs_open_context *ctx, struct nfs4_state *state, const nfs4_stateid *stateid)\r\n{\r\nstruct inode *inode = state->inode;\r\nstruct file_lock *fl;\r\nstruct file_lock_context *flctx = inode->i_flctx;\r\nstruct list_head *list;\r\nint status = 0;\r\nif (flctx == NULL)\r\ngoto out;\r\nlist = &flctx->flc_posix;\r\nspin_lock(&flctx->flc_lock);\r\nrestart:\r\nlist_for_each_entry(fl, list, fl_list) {\r\nif (nfs_file_open_context(fl->fl_file) != ctx)\r\ncontinue;\r\nspin_unlock(&flctx->flc_lock);\r\nstatus = nfs4_lock_delegation_recall(fl, state, stateid);\r\nif (status < 0)\r\ngoto out;\r\nspin_lock(&flctx->flc_lock);\r\n}\r\nif (list == &flctx->flc_posix) {\r\nlist = &flctx->flc_flock;\r\ngoto restart;\r\n}\r\nspin_unlock(&flctx->flc_lock);\r\nout:\r\nreturn status;\r\n}\r\nstatic int nfs_delegation_claim_opens(struct inode *inode,\r\nconst nfs4_stateid *stateid, fmode_t type)\r\n{\r\nstruct nfs_inode *nfsi = NFS_I(inode);\r\nstruct nfs_open_context *ctx;\r\nstruct nfs4_state_owner *sp;\r\nstruct nfs4_state *state;\r\nunsigned int seq;\r\nint err;\r\nagain:\r\nspin_lock(&inode->i_lock);\r\nlist_for_each_entry(ctx, &nfsi->open_files, list) {\r\nstate = ctx->state;\r\nif (state == NULL)\r\ncontinue;\r\nif (!test_bit(NFS_DELEGATED_STATE, &state->flags))\r\ncontinue;\r\nif (!nfs4_valid_open_stateid(state))\r\ncontinue;\r\nif (!nfs4_stateid_match(&state->stateid, stateid))\r\ncontinue;\r\nget_nfs_open_context(ctx);\r\nspin_unlock(&inode->i_lock);\r\nsp = state->owner;\r\nmutex_lock(&sp->so_delegreturn_mutex);\r\nseq = raw_seqcount_begin(&sp->so_reclaim_seqcount);\r\nerr = nfs4_open_delegation_recall(ctx, state, stateid, type);\r\nif (!err)\r\nerr = nfs_delegation_claim_locks(ctx, state, stateid);\r\nif (!err && read_seqcount_retry(&sp->so_reclaim_seqcount, seq))\r\nerr = -EAGAIN;\r\nmutex_unlock(&sp->so_delegreturn_mutex);\r\nput_nfs_open_context(ctx);\r\nif (err != 0)\r\nreturn err;\r\ngoto again;\r\n}\r\nspin_unlock(&inode->i_lock);\r\nreturn 0;\r\n}\r\nvoid nfs_inode_reclaim_delegation(struct inode *inode, struct rpc_cred *cred,\r\nstruct nfs_openres *res)\r\n{\r\nstruct nfs_delegation *delegation;\r\nstruct rpc_cred *oldcred = NULL;\r\nrcu_read_lock();\r\ndelegation = rcu_dereference(NFS_I(inode)->delegation);\r\nif (delegation != NULL) {\r\nspin_lock(&delegation->lock);\r\nif (delegation->inode != NULL) {\r\nnfs4_stateid_copy(&delegation->stateid, &res->delegation);\r\ndelegation->type = res->delegation_type;\r\ndelegation->pagemod_limit = res->pagemod_limit;\r\noldcred = delegation->cred;\r\ndelegation->cred = get_rpccred(cred);\r\nclear_bit(NFS_DELEGATION_NEED_RECLAIM,\r\n&delegation->flags);\r\nspin_unlock(&delegation->lock);\r\nrcu_read_unlock();\r\nput_rpccred(oldcred);\r\ntrace_nfs4_reclaim_delegation(inode, res->delegation_type);\r\nreturn;\r\n}\r\nspin_unlock(&delegation->lock);\r\n}\r\nrcu_read_unlock();\r\nnfs_inode_set_delegation(inode, cred, res);\r\n}\r\nstatic int nfs_do_return_delegation(struct inode *inode, struct nfs_delegation *delegation, int issync)\r\n{\r\nint res = 0;\r\nif (!test_bit(NFS_DELEGATION_REVOKED, &delegation->flags))\r\nres = nfs4_proc_delegreturn(inode,\r\ndelegation->cred,\r\n&delegation->stateid,\r\nissync);\r\nnfs_free_delegation(delegation);\r\nreturn res;\r\n}\r\nstatic struct inode *nfs_delegation_grab_inode(struct nfs_delegation *delegation)\r\n{\r\nstruct inode *inode = NULL;\r\nspin_lock(&delegation->lock);\r\nif (delegation->inode != NULL)\r\ninode = igrab(delegation->inode);\r\nspin_unlock(&delegation->lock);\r\nreturn inode;\r\n}\r\nstatic struct nfs_delegation *\r\nnfs_start_delegation_return_locked(struct nfs_inode *nfsi)\r\n{\r\nstruct nfs_delegation *ret = NULL;\r\nstruct nfs_delegation *delegation = rcu_dereference(nfsi->delegation);\r\nif (delegation == NULL)\r\ngoto out;\r\nspin_lock(&delegation->lock);\r\nif (!test_and_set_bit(NFS_DELEGATION_RETURNING, &delegation->flags))\r\nret = delegation;\r\nspin_unlock(&delegation->lock);\r\nout:\r\nreturn ret;\r\n}\r\nstatic struct nfs_delegation *\r\nnfs_start_delegation_return(struct nfs_inode *nfsi)\r\n{\r\nstruct nfs_delegation *delegation;\r\nrcu_read_lock();\r\ndelegation = nfs_start_delegation_return_locked(nfsi);\r\nrcu_read_unlock();\r\nreturn delegation;\r\n}\r\nstatic void\r\nnfs_abort_delegation_return(struct nfs_delegation *delegation,\r\nstruct nfs_client *clp)\r\n{\r\nspin_lock(&delegation->lock);\r\nclear_bit(NFS_DELEGATION_RETURNING, &delegation->flags);\r\nset_bit(NFS_DELEGATION_RETURN, &delegation->flags);\r\nspin_unlock(&delegation->lock);\r\nset_bit(NFS4CLNT_DELEGRETURN, &clp->cl_state);\r\n}\r\nstatic struct nfs_delegation *\r\nnfs_detach_delegation_locked(struct nfs_inode *nfsi,\r\nstruct nfs_delegation *delegation,\r\nstruct nfs_client *clp)\r\n{\r\nstruct nfs_delegation *deleg_cur =\r\nrcu_dereference_protected(nfsi->delegation,\r\nlockdep_is_held(&clp->cl_lock));\r\nif (deleg_cur == NULL || delegation != deleg_cur)\r\nreturn NULL;\r\nspin_lock(&delegation->lock);\r\nset_bit(NFS_DELEGATION_RETURNING, &delegation->flags);\r\nlist_del_rcu(&delegation->super_list);\r\ndelegation->inode = NULL;\r\nrcu_assign_pointer(nfsi->delegation, NULL);\r\nspin_unlock(&delegation->lock);\r\nreturn delegation;\r\n}\r\nstatic struct nfs_delegation *nfs_detach_delegation(struct nfs_inode *nfsi,\r\nstruct nfs_delegation *delegation,\r\nstruct nfs_server *server)\r\n{\r\nstruct nfs_client *clp = server->nfs_client;\r\nspin_lock(&clp->cl_lock);\r\ndelegation = nfs_detach_delegation_locked(nfsi, delegation, clp);\r\nspin_unlock(&clp->cl_lock);\r\nreturn delegation;\r\n}\r\nstatic struct nfs_delegation *\r\nnfs_inode_detach_delegation(struct inode *inode)\r\n{\r\nstruct nfs_inode *nfsi = NFS_I(inode);\r\nstruct nfs_server *server = NFS_SERVER(inode);\r\nstruct nfs_delegation *delegation;\r\ndelegation = nfs_start_delegation_return(nfsi);\r\nif (delegation == NULL)\r\nreturn NULL;\r\nreturn nfs_detach_delegation(nfsi, delegation, server);\r\n}\r\nstatic void\r\nnfs_update_inplace_delegation(struct nfs_delegation *delegation,\r\nconst struct nfs_delegation *update)\r\n{\r\nif (nfs4_stateid_is_newer(&update->stateid, &delegation->stateid)) {\r\ndelegation->stateid.seqid = update->stateid.seqid;\r\nsmp_wmb();\r\ndelegation->type = update->type;\r\n}\r\n}\r\nint nfs_inode_set_delegation(struct inode *inode, struct rpc_cred *cred, struct nfs_openres *res)\r\n{\r\nstruct nfs_server *server = NFS_SERVER(inode);\r\nstruct nfs_client *clp = server->nfs_client;\r\nstruct nfs_inode *nfsi = NFS_I(inode);\r\nstruct nfs_delegation *delegation, *old_delegation;\r\nstruct nfs_delegation *freeme = NULL;\r\nint status = 0;\r\ndelegation = kmalloc(sizeof(*delegation), GFP_NOFS);\r\nif (delegation == NULL)\r\nreturn -ENOMEM;\r\nnfs4_stateid_copy(&delegation->stateid, &res->delegation);\r\ndelegation->type = res->delegation_type;\r\ndelegation->pagemod_limit = res->pagemod_limit;\r\ndelegation->change_attr = inode->i_version;\r\ndelegation->cred = get_rpccred(cred);\r\ndelegation->inode = inode;\r\ndelegation->flags = 1<<NFS_DELEGATION_REFERENCED;\r\nspin_lock_init(&delegation->lock);\r\nspin_lock(&clp->cl_lock);\r\nold_delegation = rcu_dereference_protected(nfsi->delegation,\r\nlockdep_is_held(&clp->cl_lock));\r\nif (old_delegation != NULL) {\r\nif (nfs4_stateid_match_other(&old_delegation->stateid,\r\n&delegation->stateid)) {\r\nnfs_update_inplace_delegation(old_delegation,\r\ndelegation);\r\ngoto out;\r\n}\r\ndfprintk(FILE, "%s: server %s handed out "\r\n"a duplicate delegation!\n",\r\n__func__, clp->cl_hostname);\r\nif (delegation->type == old_delegation->type ||\r\n!(delegation->type & FMODE_WRITE)) {\r\nfreeme = delegation;\r\ndelegation = NULL;\r\ngoto out;\r\n}\r\nif (test_and_set_bit(NFS_DELEGATION_RETURNING,\r\n&old_delegation->flags))\r\ngoto out;\r\nfreeme = nfs_detach_delegation_locked(nfsi,\r\nold_delegation, clp);\r\nif (freeme == NULL)\r\ngoto out;\r\n}\r\nlist_add_tail_rcu(&delegation->super_list, &server->delegations);\r\nrcu_assign_pointer(nfsi->delegation, delegation);\r\ndelegation = NULL;\r\ntrace_nfs4_set_delegation(inode, res->delegation_type);\r\nout:\r\nspin_unlock(&clp->cl_lock);\r\nif (delegation != NULL)\r\nnfs_free_delegation(delegation);\r\nif (freeme != NULL)\r\nnfs_do_return_delegation(inode, freeme, 0);\r\nreturn status;\r\n}\r\nstatic int nfs_end_delegation_return(struct inode *inode, struct nfs_delegation *delegation, int issync)\r\n{\r\nstruct nfs_client *clp = NFS_SERVER(inode)->nfs_client;\r\nstruct nfs_inode *nfsi = NFS_I(inode);\r\nint err = 0;\r\nif (delegation == NULL)\r\nreturn 0;\r\ndo {\r\nif (test_bit(NFS_DELEGATION_REVOKED, &delegation->flags))\r\nbreak;\r\nerr = nfs_delegation_claim_opens(inode, &delegation->stateid,\r\ndelegation->type);\r\nif (!issync || err != -EAGAIN)\r\nbreak;\r\nerr = nfs4_wait_clnt_recover(clp);\r\n} while (err == 0);\r\nif (err) {\r\nnfs_abort_delegation_return(delegation, clp);\r\ngoto out;\r\n}\r\nif (!nfs_detach_delegation(nfsi, delegation, NFS_SERVER(inode)))\r\ngoto out;\r\nerr = nfs_do_return_delegation(inode, delegation, issync);\r\nout:\r\nreturn err;\r\n}\r\nstatic bool nfs_delegation_need_return(struct nfs_delegation *delegation)\r\n{\r\nbool ret = false;\r\nif (test_bit(NFS_DELEGATION_RETURNING, &delegation->flags))\r\ngoto out;\r\nif (test_and_clear_bit(NFS_DELEGATION_RETURN, &delegation->flags))\r\nret = true;\r\nif (test_and_clear_bit(NFS_DELEGATION_RETURN_IF_CLOSED, &delegation->flags) && !ret) {\r\nstruct inode *inode;\r\nspin_lock(&delegation->lock);\r\ninode = delegation->inode;\r\nif (inode && list_empty(&NFS_I(inode)->open_files))\r\nret = true;\r\nspin_unlock(&delegation->lock);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nint nfs_client_return_marked_delegations(struct nfs_client *clp)\r\n{\r\nstruct nfs_delegation *delegation;\r\nstruct nfs_server *server;\r\nstruct inode *inode;\r\nint err = 0;\r\nrestart:\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\r\nlist_for_each_entry_rcu(delegation, &server->delegations,\r\nsuper_list) {\r\nif (!nfs_delegation_need_return(delegation))\r\ncontinue;\r\nif (!nfs_sb_active(server->super))\r\ncontinue;\r\ninode = nfs_delegation_grab_inode(delegation);\r\nif (inode == NULL) {\r\nrcu_read_unlock();\r\nnfs_sb_deactive(server->super);\r\ngoto restart;\r\n}\r\ndelegation = nfs_start_delegation_return_locked(NFS_I(inode));\r\nrcu_read_unlock();\r\nerr = nfs_end_delegation_return(inode, delegation, 0);\r\niput(inode);\r\nnfs_sb_deactive(server->super);\r\nif (!err)\r\ngoto restart;\r\nset_bit(NFS4CLNT_DELEGRETURN, &clp->cl_state);\r\nreturn err;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nvoid nfs_inode_return_delegation_noreclaim(struct inode *inode)\r\n{\r\nstruct nfs_delegation *delegation;\r\ndelegation = nfs_inode_detach_delegation(inode);\r\nif (delegation != NULL)\r\nnfs_do_return_delegation(inode, delegation, 1);\r\n}\r\nint nfs4_inode_return_delegation(struct inode *inode)\r\n{\r\nstruct nfs_inode *nfsi = NFS_I(inode);\r\nstruct nfs_delegation *delegation;\r\nint err = 0;\r\nnfs_wb_all(inode);\r\ndelegation = nfs_start_delegation_return(nfsi);\r\nif (delegation != NULL)\r\nerr = nfs_end_delegation_return(inode, delegation, 1);\r\nreturn err;\r\n}\r\nstatic void nfs_mark_return_if_closed_delegation(struct nfs_server *server,\r\nstruct nfs_delegation *delegation)\r\n{\r\nset_bit(NFS_DELEGATION_RETURN_IF_CLOSED, &delegation->flags);\r\nset_bit(NFS4CLNT_DELEGRETURN, &server->nfs_client->cl_state);\r\n}\r\nstatic void nfs_mark_return_delegation(struct nfs_server *server,\r\nstruct nfs_delegation *delegation)\r\n{\r\nset_bit(NFS_DELEGATION_RETURN, &delegation->flags);\r\nset_bit(NFS4CLNT_DELEGRETURN, &server->nfs_client->cl_state);\r\n}\r\nstatic bool nfs_server_mark_return_all_delegations(struct nfs_server *server)\r\n{\r\nstruct nfs_delegation *delegation;\r\nbool ret = false;\r\nlist_for_each_entry_rcu(delegation, &server->delegations, super_list) {\r\nnfs_mark_return_delegation(server, delegation);\r\nret = true;\r\n}\r\nreturn ret;\r\n}\r\nstatic void nfs_client_mark_return_all_delegations(struct nfs_client *clp)\r\n{\r\nstruct nfs_server *server;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\r\nnfs_server_mark_return_all_delegations(server);\r\nrcu_read_unlock();\r\n}\r\nstatic void nfs_delegation_run_state_manager(struct nfs_client *clp)\r\n{\r\nif (test_bit(NFS4CLNT_DELEGRETURN, &clp->cl_state))\r\nnfs4_schedule_state_manager(clp);\r\n}\r\nvoid nfs_expire_all_delegations(struct nfs_client *clp)\r\n{\r\nnfs_client_mark_return_all_delegations(clp);\r\nnfs_delegation_run_state_manager(clp);\r\n}\r\nvoid nfs_server_return_all_delegations(struct nfs_server *server)\r\n{\r\nstruct nfs_client *clp = server->nfs_client;\r\nbool need_wait;\r\nif (clp == NULL)\r\nreturn;\r\nrcu_read_lock();\r\nneed_wait = nfs_server_mark_return_all_delegations(server);\r\nrcu_read_unlock();\r\nif (need_wait) {\r\nnfs4_schedule_state_manager(clp);\r\nnfs4_wait_clnt_recover(clp);\r\n}\r\n}\r\nstatic void nfs_mark_return_unused_delegation_types(struct nfs_server *server,\r\nfmode_t flags)\r\n{\r\nstruct nfs_delegation *delegation;\r\nlist_for_each_entry_rcu(delegation, &server->delegations, super_list) {\r\nif ((delegation->type == (FMODE_READ|FMODE_WRITE)) && !(flags & FMODE_WRITE))\r\ncontinue;\r\nif (delegation->type & flags)\r\nnfs_mark_return_if_closed_delegation(server, delegation);\r\n}\r\n}\r\nstatic void nfs_client_mark_return_unused_delegation_types(struct nfs_client *clp,\r\nfmode_t flags)\r\n{\r\nstruct nfs_server *server;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\r\nnfs_mark_return_unused_delegation_types(server, flags);\r\nrcu_read_unlock();\r\n}\r\nstatic void nfs_mark_delegation_revoked(struct nfs_server *server,\r\nstruct nfs_delegation *delegation)\r\n{\r\nset_bit(NFS_DELEGATION_REVOKED, &delegation->flags);\r\ndelegation->stateid.type = NFS4_INVALID_STATEID_TYPE;\r\nnfs_mark_return_delegation(server, delegation);\r\n}\r\nstatic bool nfs_revoke_delegation(struct inode *inode,\r\nconst nfs4_stateid *stateid)\r\n{\r\nstruct nfs_delegation *delegation;\r\nnfs4_stateid tmp;\r\nbool ret = false;\r\nrcu_read_lock();\r\ndelegation = rcu_dereference(NFS_I(inode)->delegation);\r\nif (delegation == NULL)\r\ngoto out;\r\nif (stateid == NULL) {\r\nnfs4_stateid_copy(&tmp, &delegation->stateid);\r\nstateid = &tmp;\r\n} else if (!nfs4_stateid_match(stateid, &delegation->stateid))\r\ngoto out;\r\nnfs_mark_delegation_revoked(NFS_SERVER(inode), delegation);\r\nret = true;\r\nout:\r\nrcu_read_unlock();\r\nif (ret)\r\nnfs_inode_find_state_and_recover(inode, stateid);\r\nreturn ret;\r\n}\r\nvoid nfs_remove_bad_delegation(struct inode *inode,\r\nconst nfs4_stateid *stateid)\r\n{\r\nstruct nfs_delegation *delegation;\r\nif (!nfs_revoke_delegation(inode, stateid))\r\nreturn;\r\ndelegation = nfs_inode_detach_delegation(inode);\r\nif (delegation)\r\nnfs_free_delegation(delegation);\r\n}\r\nvoid nfs_expire_unused_delegation_types(struct nfs_client *clp, fmode_t flags)\r\n{\r\nnfs_client_mark_return_unused_delegation_types(clp, flags);\r\nnfs_delegation_run_state_manager(clp);\r\n}\r\nstatic void nfs_mark_return_unreferenced_delegations(struct nfs_server *server)\r\n{\r\nstruct nfs_delegation *delegation;\r\nlist_for_each_entry_rcu(delegation, &server->delegations, super_list) {\r\nif (test_and_clear_bit(NFS_DELEGATION_REFERENCED, &delegation->flags))\r\ncontinue;\r\nnfs_mark_return_if_closed_delegation(server, delegation);\r\n}\r\n}\r\nvoid nfs_expire_unreferenced_delegations(struct nfs_client *clp)\r\n{\r\nstruct nfs_server *server;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\r\nnfs_mark_return_unreferenced_delegations(server);\r\nrcu_read_unlock();\r\nnfs_delegation_run_state_manager(clp);\r\n}\r\nint nfs_async_inode_return_delegation(struct inode *inode,\r\nconst nfs4_stateid *stateid)\r\n{\r\nstruct nfs_server *server = NFS_SERVER(inode);\r\nstruct nfs_client *clp = server->nfs_client;\r\nstruct nfs_delegation *delegation;\r\nrcu_read_lock();\r\ndelegation = rcu_dereference(NFS_I(inode)->delegation);\r\nif (delegation == NULL)\r\ngoto out_enoent;\r\nif (stateid != NULL &&\r\n!clp->cl_mvops->match_stateid(&delegation->stateid, stateid))\r\ngoto out_enoent;\r\nnfs_mark_return_delegation(server, delegation);\r\nrcu_read_unlock();\r\nnfs_delegation_run_state_manager(clp);\r\nreturn 0;\r\nout_enoent:\r\nrcu_read_unlock();\r\nreturn -ENOENT;\r\n}\r\nstatic struct inode *\r\nnfs_delegation_find_inode_server(struct nfs_server *server,\r\nconst struct nfs_fh *fhandle)\r\n{\r\nstruct nfs_delegation *delegation;\r\nstruct inode *res = NULL;\r\nlist_for_each_entry_rcu(delegation, &server->delegations, super_list) {\r\nspin_lock(&delegation->lock);\r\nif (delegation->inode != NULL &&\r\nnfs_compare_fh(fhandle, &NFS_I(delegation->inode)->fh) == 0) {\r\nres = igrab(delegation->inode);\r\n}\r\nspin_unlock(&delegation->lock);\r\nif (res != NULL)\r\nbreak;\r\n}\r\nreturn res;\r\n}\r\nstruct inode *nfs_delegation_find_inode(struct nfs_client *clp,\r\nconst struct nfs_fh *fhandle)\r\n{\r\nstruct nfs_server *server;\r\nstruct inode *res = NULL;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\r\nres = nfs_delegation_find_inode_server(server, fhandle);\r\nif (res != NULL)\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn res;\r\n}\r\nstatic void nfs_delegation_mark_reclaim_server(struct nfs_server *server)\r\n{\r\nstruct nfs_delegation *delegation;\r\nlist_for_each_entry_rcu(delegation, &server->delegations, super_list) {\r\nif (test_bit(NFS_DELEGATION_TEST_EXPIRED, &delegation->flags))\r\ncontinue;\r\nset_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags);\r\n}\r\n}\r\nvoid nfs_delegation_mark_reclaim(struct nfs_client *clp)\r\n{\r\nstruct nfs_server *server;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\r\nnfs_delegation_mark_reclaim_server(server);\r\nrcu_read_unlock();\r\n}\r\nvoid nfs_delegation_reap_unclaimed(struct nfs_client *clp)\r\n{\r\nstruct nfs_delegation *delegation;\r\nstruct nfs_server *server;\r\nstruct inode *inode;\r\nrestart:\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\r\nlist_for_each_entry_rcu(delegation, &server->delegations,\r\nsuper_list) {\r\nif (test_bit(NFS_DELEGATION_RETURNING,\r\n&delegation->flags))\r\ncontinue;\r\nif (test_bit(NFS_DELEGATION_NEED_RECLAIM,\r\n&delegation->flags) == 0)\r\ncontinue;\r\nif (!nfs_sb_active(server->super))\r\ncontinue;\r\ninode = nfs_delegation_grab_inode(delegation);\r\nif (inode == NULL) {\r\nrcu_read_unlock();\r\nnfs_sb_deactive(server->super);\r\ngoto restart;\r\n}\r\ndelegation = nfs_start_delegation_return_locked(NFS_I(inode));\r\nrcu_read_unlock();\r\nif (delegation != NULL) {\r\ndelegation = nfs_detach_delegation(NFS_I(inode),\r\ndelegation, server);\r\nif (delegation != NULL)\r\nnfs_free_delegation(delegation);\r\n}\r\niput(inode);\r\nnfs_sb_deactive(server->super);\r\ngoto restart;\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic inline bool nfs4_server_rebooted(const struct nfs_client *clp)\r\n{\r\nreturn (clp->cl_state & (BIT(NFS4CLNT_CHECK_LEASE) |\r\nBIT(NFS4CLNT_LEASE_EXPIRED) |\r\nBIT(NFS4CLNT_SESSION_RESET))) != 0;\r\n}\r\nstatic void nfs_mark_test_expired_delegation(struct nfs_server *server,\r\nstruct nfs_delegation *delegation)\r\n{\r\nif (delegation->stateid.type == NFS4_INVALID_STATEID_TYPE)\r\nreturn;\r\nclear_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags);\r\nset_bit(NFS_DELEGATION_TEST_EXPIRED, &delegation->flags);\r\nset_bit(NFS4CLNT_DELEGATION_EXPIRED, &server->nfs_client->cl_state);\r\n}\r\nstatic void nfs_inode_mark_test_expired_delegation(struct nfs_server *server,\r\nstruct inode *inode)\r\n{\r\nstruct nfs_delegation *delegation;\r\nrcu_read_lock();\r\ndelegation = rcu_dereference(NFS_I(inode)->delegation);\r\nif (delegation)\r\nnfs_mark_test_expired_delegation(server, delegation);\r\nrcu_read_unlock();\r\n}\r\nstatic void nfs_delegation_mark_test_expired_server(struct nfs_server *server)\r\n{\r\nstruct nfs_delegation *delegation;\r\nlist_for_each_entry_rcu(delegation, &server->delegations, super_list)\r\nnfs_mark_test_expired_delegation(server, delegation);\r\n}\r\nvoid nfs_mark_test_expired_all_delegations(struct nfs_client *clp)\r\n{\r\nstruct nfs_server *server;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\r\nnfs_delegation_mark_test_expired_server(server);\r\nrcu_read_unlock();\r\n}\r\nvoid nfs_reap_expired_delegations(struct nfs_client *clp)\r\n{\r\nconst struct nfs4_minor_version_ops *ops = clp->cl_mvops;\r\nstruct nfs_delegation *delegation;\r\nstruct nfs_server *server;\r\nstruct inode *inode;\r\nstruct rpc_cred *cred;\r\nnfs4_stateid stateid;\r\nrestart:\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\r\nlist_for_each_entry_rcu(delegation, &server->delegations,\r\nsuper_list) {\r\nif (test_bit(NFS_DELEGATION_RETURNING,\r\n&delegation->flags))\r\ncontinue;\r\nif (test_bit(NFS_DELEGATION_TEST_EXPIRED,\r\n&delegation->flags) == 0)\r\ncontinue;\r\nif (!nfs_sb_active(server->super))\r\ncontinue;\r\ninode = nfs_delegation_grab_inode(delegation);\r\nif (inode == NULL) {\r\nrcu_read_unlock();\r\nnfs_sb_deactive(server->super);\r\ngoto restart;\r\n}\r\ncred = get_rpccred_rcu(delegation->cred);\r\nnfs4_stateid_copy(&stateid, &delegation->stateid);\r\nclear_bit(NFS_DELEGATION_TEST_EXPIRED, &delegation->flags);\r\nrcu_read_unlock();\r\nif (cred != NULL &&\r\nops->test_and_free_expired(server, &stateid, cred) < 0) {\r\nnfs_revoke_delegation(inode, &stateid);\r\nnfs_inode_find_state_and_recover(inode, &stateid);\r\n}\r\nput_rpccred(cred);\r\nif (nfs4_server_rebooted(clp)) {\r\nnfs_inode_mark_test_expired_delegation(server,inode);\r\niput(inode);\r\nnfs_sb_deactive(server->super);\r\nreturn;\r\n}\r\niput(inode);\r\nnfs_sb_deactive(server->super);\r\ngoto restart;\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nvoid nfs_inode_find_delegation_state_and_recover(struct inode *inode,\r\nconst nfs4_stateid *stateid)\r\n{\r\nstruct nfs_client *clp = NFS_SERVER(inode)->nfs_client;\r\nstruct nfs_delegation *delegation;\r\nbool found = false;\r\nrcu_read_lock();\r\ndelegation = rcu_dereference(NFS_I(inode)->delegation);\r\nif (delegation &&\r\nnfs4_stateid_match_other(&delegation->stateid, stateid)) {\r\nnfs_mark_test_expired_delegation(NFS_SERVER(inode), delegation);\r\nfound = true;\r\n}\r\nrcu_read_unlock();\r\nif (found)\r\nnfs4_schedule_state_manager(clp);\r\n}\r\nint nfs_delegations_present(struct nfs_client *clp)\r\n{\r\nstruct nfs_server *server;\r\nint ret = 0;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\r\nif (!list_empty(&server->delegations)) {\r\nret = 1;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nbool nfs4_copy_delegation_stateid(struct inode *inode, fmode_t flags,\r\nnfs4_stateid *dst, struct rpc_cred **cred)\r\n{\r\nstruct nfs_inode *nfsi = NFS_I(inode);\r\nstruct nfs_delegation *delegation;\r\nbool ret;\r\nflags &= FMODE_READ|FMODE_WRITE;\r\nrcu_read_lock();\r\ndelegation = rcu_dereference(nfsi->delegation);\r\nret = nfs4_is_valid_delegation(delegation, flags);\r\nif (ret) {\r\nnfs4_stateid_copy(dst, &delegation->stateid);\r\nnfs_mark_delegation_referenced(delegation);\r\nif (cred)\r\n*cred = get_rpccred(delegation->cred);\r\n}\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nbool nfs4_delegation_flush_on_close(const struct inode *inode)\r\n{\r\nstruct nfs_inode *nfsi = NFS_I(inode);\r\nstruct nfs_delegation *delegation;\r\nbool ret = true;\r\nrcu_read_lock();\r\ndelegation = rcu_dereference(nfsi->delegation);\r\nif (delegation == NULL || !(delegation->type & FMODE_WRITE))\r\ngoto out;\r\nif (nfsi->nrequests < delegation->pagemod_limit)\r\nret = false;\r\nout:\r\nrcu_read_unlock();\r\nreturn ret;\r\n}
