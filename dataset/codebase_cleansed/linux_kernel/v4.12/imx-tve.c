static inline struct imx_tve *con_to_tve(struct drm_connector *c)\r\n{\r\nreturn container_of(c, struct imx_tve, connector);\r\n}\r\nstatic inline struct imx_tve *enc_to_tve(struct drm_encoder *e)\r\n{\r\nreturn container_of(e, struct imx_tve, encoder);\r\n}\r\nstatic void tve_lock(void *__tve)\r\n__acquires(&tve->lock\r\nstatic void tve_unlock(void *__tve)\r\n__releases(&tve->lock\r\nstatic void tve_enable(struct imx_tve *tve)\r\n{\r\nif (!tve->enabled) {\r\ntve->enabled = true;\r\nclk_prepare_enable(tve->clk);\r\nregmap_update_bits(tve->regmap, TVE_COM_CONF_REG,\r\nTVE_EN, TVE_EN);\r\n}\r\nregmap_write(tve->regmap, TVE_STAT_REG, 0xffffffff);\r\nif (tve->mode == TVE_MODE_VGA)\r\nregmap_write(tve->regmap, TVE_INT_CONT_REG, 0);\r\nelse\r\nregmap_write(tve->regmap, TVE_INT_CONT_REG,\r\nTVE_CD_SM_IEN |\r\nTVE_CD_LM_IEN |\r\nTVE_CD_MON_END_IEN);\r\n}\r\nstatic void tve_disable(struct imx_tve *tve)\r\n{\r\nif (tve->enabled) {\r\ntve->enabled = false;\r\nregmap_update_bits(tve->regmap, TVE_COM_CONF_REG, TVE_EN, 0);\r\nclk_disable_unprepare(tve->clk);\r\n}\r\n}\r\nstatic int tve_setup_tvout(struct imx_tve *tve)\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int tve_setup_vga(struct imx_tve *tve)\r\n{\r\nunsigned int mask;\r\nunsigned int val;\r\nint ret;\r\nret = regmap_update_bits(tve->regmap, TVE_TVDAC0_CONT_REG,\r\nTVE_TVDAC_GAIN_MASK, 0x0a);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_update_bits(tve->regmap, TVE_TVDAC1_CONT_REG,\r\nTVE_TVDAC_GAIN_MASK, 0x0a);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_update_bits(tve->regmap, TVE_TVDAC2_CONT_REG,\r\nTVE_TVDAC_GAIN_MASK, 0x0a);\r\nif (ret)\r\nreturn ret;\r\nmask = TVE_DATA_SOURCE_MASK | TVE_INP_VIDEO_FORM;\r\nval = TVE_DATA_SOURCE_BUS2 | TVE_INP_YCBCR_444;\r\nmask |= TVE_TV_STAND_MASK | TVE_P2I_CONV_EN;\r\nval |= TVE_TV_STAND_HD_1080P30 | 0;\r\nmask |= TVE_TV_OUT_MODE_MASK | TVE_SYNC_CH_0_EN;\r\nval |= TVE_TV_OUT_RGB | TVE_SYNC_CH_0_EN;\r\nret = regmap_update_bits(tve->regmap, TVE_COM_CONF_REG, mask, val);\r\nif (ret)\r\nreturn ret;\r\nreturn regmap_update_bits(tve->regmap, TVE_TST_MODE_REG,\r\nTVE_TVDAC_TEST_MODE_MASK, 1);\r\n}\r\nstatic int imx_tve_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct imx_tve *tve = con_to_tve(connector);\r\nstruct edid *edid;\r\nint ret = 0;\r\nif (!tve->ddc)\r\nreturn 0;\r\nedid = drm_get_edid(connector, tve->ddc);\r\nif (edid) {\r\ndrm_mode_connector_update_edid_property(connector, edid);\r\nret = drm_add_edid_modes(connector, edid);\r\nkfree(edid);\r\n}\r\nreturn ret;\r\n}\r\nstatic int imx_tve_connector_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct imx_tve *tve = con_to_tve(connector);\r\nunsigned long rate;\r\nrate = clk_round_rate(tve->clk, 2000UL * mode->clock) / 2000;\r\nif (rate == mode->clock)\r\nreturn MODE_OK;\r\nrate = clk_round_rate(tve->clk, 1000UL * mode->clock) / 1000;\r\nif (rate == mode->clock)\r\nreturn MODE_OK;\r\ndev_warn(tve->dev, "ignoring mode %dx%d\n",\r\nmode->hdisplay, mode->vdisplay);\r\nreturn MODE_BAD;\r\n}\r\nstatic struct drm_encoder *imx_tve_connector_best_encoder(\r\nstruct drm_connector *connector)\r\n{\r\nstruct imx_tve *tve = con_to_tve(connector);\r\nreturn &tve->encoder;\r\n}\r\nstatic void imx_tve_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *orig_mode,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct imx_tve *tve = enc_to_tve(encoder);\r\nunsigned long rounded_rate;\r\nunsigned long rate;\r\nint div = 1;\r\nint ret;\r\nrate = 2000UL * mode->clock;\r\nclk_set_rate(tve->clk, rate);\r\nrounded_rate = clk_get_rate(tve->clk);\r\nif (rounded_rate >= rate)\r\ndiv = 2;\r\nclk_set_rate(tve->di_clk, rounded_rate / div);\r\nret = clk_set_parent(tve->di_sel_clk, tve->di_clk);\r\nif (ret < 0) {\r\ndev_err(tve->dev, "failed to set di_sel parent to tve_di: %d\n",\r\nret);\r\n}\r\nregmap_update_bits(tve->regmap, TVE_COM_CONF_REG,\r\nTVE_IPU_CLK_EN, TVE_IPU_CLK_EN);\r\nif (tve->mode == TVE_MODE_VGA)\r\nret = tve_setup_vga(tve);\r\nelse\r\nret = tve_setup_tvout(tve);\r\nif (ret)\r\ndev_err(tve->dev, "failed to set configuration: %d\n", ret);\r\n}\r\nstatic void imx_tve_encoder_enable(struct drm_encoder *encoder)\r\n{\r\nstruct imx_tve *tve = enc_to_tve(encoder);\r\ntve_enable(tve);\r\n}\r\nstatic void imx_tve_encoder_disable(struct drm_encoder *encoder)\r\n{\r\nstruct imx_tve *tve = enc_to_tve(encoder);\r\ntve_disable(tve);\r\n}\r\nstatic int imx_tve_atomic_check(struct drm_encoder *encoder,\r\nstruct drm_crtc_state *crtc_state,\r\nstruct drm_connector_state *conn_state)\r\n{\r\nstruct imx_crtc_state *imx_crtc_state = to_imx_crtc_state(crtc_state);\r\nstruct imx_tve *tve = enc_to_tve(encoder);\r\nimx_crtc_state->bus_format = MEDIA_BUS_FMT_GBR888_1X24;\r\nimx_crtc_state->di_hsync_pin = tve->di_hsync_pin;\r\nimx_crtc_state->di_vsync_pin = tve->di_vsync_pin;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t imx_tve_irq_handler(int irq, void *data)\r\n{\r\nstruct imx_tve *tve = data;\r\nunsigned int val;\r\nregmap_read(tve->regmap, TVE_STAT_REG, &val);\r\nregmap_write(tve->regmap, TVE_STAT_REG, 0xffffffff);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned long clk_tve_di_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct imx_tve *tve = container_of(hw, struct imx_tve, clk_hw_di);\r\nunsigned int val;\r\nint ret;\r\nret = regmap_read(tve->regmap, TVE_COM_CONF_REG, &val);\r\nif (ret < 0)\r\nreturn 0;\r\nswitch (val & TVE_DAC_SAMP_RATE_MASK) {\r\ncase TVE_DAC_DIV4_RATE:\r\nreturn parent_rate / 4;\r\ncase TVE_DAC_DIV2_RATE:\r\nreturn parent_rate / 2;\r\ncase TVE_DAC_FULL_RATE:\r\ndefault:\r\nreturn parent_rate;\r\n}\r\nreturn 0;\r\n}\r\nstatic long clk_tve_di_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nunsigned long div;\r\ndiv = *prate / rate;\r\nif (div >= 4)\r\nreturn *prate / 4;\r\nelse if (div >= 2)\r\nreturn *prate / 2;\r\nreturn *prate;\r\n}\r\nstatic int clk_tve_di_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct imx_tve *tve = container_of(hw, struct imx_tve, clk_hw_di);\r\nunsigned long div;\r\nu32 val;\r\nint ret;\r\ndiv = parent_rate / rate;\r\nif (div >= 4)\r\nval = TVE_DAC_DIV4_RATE;\r\nelse if (div >= 2)\r\nval = TVE_DAC_DIV2_RATE;\r\nelse\r\nval = TVE_DAC_FULL_RATE;\r\nret = regmap_update_bits(tve->regmap, TVE_COM_CONF_REG,\r\nTVE_DAC_SAMP_RATE_MASK, val);\r\nif (ret < 0) {\r\ndev_err(tve->dev, "failed to set divider: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tve_clk_init(struct imx_tve *tve, void __iomem *base)\r\n{\r\nconst char *tve_di_parent[1];\r\nstruct clk_init_data init = {\r\n.name = "tve_di",\r\n.ops = &clk_tve_di_ops,\r\n.num_parents = 1,\r\n.flags = 0,\r\n};\r\ntve_di_parent[0] = __clk_get_name(tve->clk);\r\ninit.parent_names = (const char **)&tve_di_parent;\r\ntve->clk_hw_di.init = &init;\r\ntve->di_clk = clk_register(tve->dev, &tve->clk_hw_di);\r\nif (IS_ERR(tve->di_clk)) {\r\ndev_err(tve->dev, "failed to register TVE output clock: %ld\n",\r\nPTR_ERR(tve->di_clk));\r\nreturn PTR_ERR(tve->di_clk);\r\n}\r\nreturn 0;\r\n}\r\nstatic int imx_tve_register(struct drm_device *drm, struct imx_tve *tve)\r\n{\r\nint encoder_type;\r\nint ret;\r\nencoder_type = tve->mode == TVE_MODE_VGA ?\r\nDRM_MODE_ENCODER_DAC : DRM_MODE_ENCODER_TVDAC;\r\nret = imx_drm_encoder_parse_of(drm, &tve->encoder, tve->dev->of_node);\r\nif (ret)\r\nreturn ret;\r\ndrm_encoder_helper_add(&tve->encoder, &imx_tve_encoder_helper_funcs);\r\ndrm_encoder_init(drm, &tve->encoder, &imx_tve_encoder_funcs,\r\nencoder_type, NULL);\r\ndrm_connector_helper_add(&tve->connector,\r\n&imx_tve_connector_helper_funcs);\r\ndrm_connector_init(drm, &tve->connector, &imx_tve_connector_funcs,\r\nDRM_MODE_CONNECTOR_VGA);\r\ndrm_mode_connector_attach_encoder(&tve->connector, &tve->encoder);\r\nreturn 0;\r\n}\r\nstatic bool imx_tve_readable_reg(struct device *dev, unsigned int reg)\r\n{\r\nreturn (reg % 4 == 0) && (reg <= 0xdc);\r\n}\r\nstatic const int of_get_tve_mode(struct device_node *np)\r\n{\r\nconst char *bm;\r\nint ret, i;\r\nret = of_property_read_string(np, "fsl,tve-mode", &bm);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < ARRAY_SIZE(imx_tve_modes); i++)\r\nif (!strcasecmp(bm, imx_tve_modes[i]))\r\nreturn i;\r\nreturn -EINVAL;\r\n}\r\nstatic int imx_tve_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct drm_device *drm = data;\r\nstruct device_node *np = dev->of_node;\r\nstruct device_node *ddc_node;\r\nstruct imx_tve *tve;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nunsigned int val;\r\nint irq;\r\nint ret;\r\ntve = devm_kzalloc(dev, sizeof(*tve), GFP_KERNEL);\r\nif (!tve)\r\nreturn -ENOMEM;\r\ntve->dev = dev;\r\nspin_lock_init(&tve->lock);\r\nddc_node = of_parse_phandle(np, "ddc-i2c-bus", 0);\r\nif (ddc_node) {\r\ntve->ddc = of_find_i2c_adapter_by_node(ddc_node);\r\nof_node_put(ddc_node);\r\n}\r\ntve->mode = of_get_tve_mode(np);\r\nif (tve->mode != TVE_MODE_VGA) {\r\ndev_err(dev, "only VGA mode supported, currently\n");\r\nreturn -EINVAL;\r\n}\r\nif (tve->mode == TVE_MODE_VGA) {\r\nret = of_property_read_u32(np, "fsl,hsync-pin",\r\n&tve->di_hsync_pin);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to get hsync pin\n");\r\nreturn ret;\r\n}\r\nret = of_property_read_u32(np, "fsl,vsync-pin",\r\n&tve->di_vsync_pin);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to get vsync pin\n");\r\nreturn ret;\r\n}\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\ntve_regmap_config.lock_arg = tve;\r\ntve->regmap = devm_regmap_init_mmio_clk(dev, "tve", base,\r\n&tve_regmap_config);\r\nif (IS_ERR(tve->regmap)) {\r\ndev_err(dev, "failed to init regmap: %ld\n",\r\nPTR_ERR(tve->regmap));\r\nreturn PTR_ERR(tve->regmap);\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(dev, "failed to get irq\n");\r\nreturn irq;\r\n}\r\nret = devm_request_threaded_irq(dev, irq, NULL,\r\nimx_tve_irq_handler, IRQF_ONESHOT,\r\n"imx-tve", tve);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to request irq: %d\n", ret);\r\nreturn ret;\r\n}\r\ntve->dac_reg = devm_regulator_get(dev, "dac");\r\nif (!IS_ERR(tve->dac_reg)) {\r\nif (regulator_get_voltage(tve->dac_reg) != IMX_TVE_DAC_VOLTAGE)\r\ndev_warn(dev, "dac voltage is not %d uV\n", IMX_TVE_DAC_VOLTAGE);\r\nret = regulator_enable(tve->dac_reg);\r\nif (ret)\r\nreturn ret;\r\n}\r\ntve->clk = devm_clk_get(dev, "tve");\r\nif (IS_ERR(tve->clk)) {\r\ndev_err(dev, "failed to get high speed tve clock: %ld\n",\r\nPTR_ERR(tve->clk));\r\nreturn PTR_ERR(tve->clk);\r\n}\r\ntve->di_sel_clk = devm_clk_get(dev, "di_sel");\r\nif (IS_ERR(tve->di_sel_clk)) {\r\ndev_err(dev, "failed to get ipu di mux clock: %ld\n",\r\nPTR_ERR(tve->di_sel_clk));\r\nreturn PTR_ERR(tve->di_sel_clk);\r\n}\r\nret = tve_clk_init(tve, base);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_read(tve->regmap, TVE_COM_CONF_REG, &val);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to read configuration register: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nif (val != 0x00100000) {\r\ndev_err(dev, "configuration register default value indicates this is not a TVEv2\n");\r\nreturn -ENODEV;\r\n}\r\nret = regmap_write(tve->regmap, TVE_CD_CONT_REG, 0);\r\nif (ret)\r\nreturn ret;\r\nret = imx_tve_register(drm, tve);\r\nif (ret)\r\nreturn ret;\r\ndev_set_drvdata(dev, tve);\r\nreturn 0;\r\n}\r\nstatic void imx_tve_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct imx_tve *tve = dev_get_drvdata(dev);\r\nif (!IS_ERR(tve->dac_reg))\r\nregulator_disable(tve->dac_reg);\r\n}\r\nstatic int imx_tve_probe(struct platform_device *pdev)\r\n{\r\nreturn component_add(&pdev->dev, &imx_tve_ops);\r\n}\r\nstatic int imx_tve_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &imx_tve_ops);\r\nreturn 0;\r\n}
