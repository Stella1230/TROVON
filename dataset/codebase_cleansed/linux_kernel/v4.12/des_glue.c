static void encrypt_to_decrypt(u64 *d, const u64 *e)\r\n{\r\nconst u64 *s = e + (DES_EXPKEY_WORDS / 2) - 1;\r\nint i;\r\nfor (i = 0; i < DES_EXPKEY_WORDS / 2; i++)\r\n*d++ = *s--;\r\n}\r\nstatic int des_set_key(struct crypto_tfm *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct des_sparc64_ctx *dctx = crypto_tfm_ctx(tfm);\r\nu32 *flags = &tfm->crt_flags;\r\nu32 tmp[DES_EXPKEY_WORDS];\r\nint ret;\r\nret = des_ekey(tmp, key);\r\nif (unlikely(ret == 0) && (*flags & CRYPTO_TFM_REQ_WEAK_KEY)) {\r\n*flags |= CRYPTO_TFM_RES_WEAK_KEY;\r\nreturn -EINVAL;\r\n}\r\ndes_sparc64_key_expand((const u32 *) key, &dctx->encrypt_expkey[0]);\r\nencrypt_to_decrypt(&dctx->decrypt_expkey[0], &dctx->encrypt_expkey[0]);\r\nreturn 0;\r\n}\r\nstatic void des_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\r\n{\r\nstruct des_sparc64_ctx *ctx = crypto_tfm_ctx(tfm);\r\nconst u64 *K = ctx->encrypt_expkey;\r\ndes_sparc64_crypt(K, (const u64 *) src, (u64 *) dst);\r\n}\r\nstatic void des_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\r\n{\r\nstruct des_sparc64_ctx *ctx = crypto_tfm_ctx(tfm);\r\nconst u64 *K = ctx->decrypt_expkey;\r\ndes_sparc64_crypt(K, (const u64 *) src, (u64 *) dst);\r\n}\r\nstatic int __ecb_crypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes, bool encrypt)\r\n{\r\nstruct des_sparc64_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nstruct blkcipher_walk walk;\r\nint err;\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nerr = blkcipher_walk_virt(desc, &walk);\r\ndesc->flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;\r\nif (encrypt)\r\ndes_sparc64_load_keys(&ctx->encrypt_expkey[0]);\r\nelse\r\ndes_sparc64_load_keys(&ctx->decrypt_expkey[0]);\r\nwhile ((nbytes = walk.nbytes)) {\r\nunsigned int block_len = nbytes & DES_BLOCK_MASK;\r\nif (likely(block_len)) {\r\ndes_sparc64_ecb_crypt((const u64 *)walk.src.virt.addr,\r\n(u64 *) walk.dst.virt.addr,\r\nblock_len);\r\n}\r\nnbytes &= DES_BLOCK_SIZE - 1;\r\nerr = blkcipher_walk_done(desc, &walk, nbytes);\r\n}\r\nfprs_write(0);\r\nreturn err;\r\n}\r\nstatic int ecb_encrypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nreturn __ecb_crypt(desc, dst, src, nbytes, true);\r\n}\r\nstatic int ecb_decrypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nreturn __ecb_crypt(desc, dst, src, nbytes, false);\r\n}\r\nstatic int cbc_encrypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nstruct des_sparc64_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nstruct blkcipher_walk walk;\r\nint err;\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nerr = blkcipher_walk_virt(desc, &walk);\r\ndesc->flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;\r\ndes_sparc64_load_keys(&ctx->encrypt_expkey[0]);\r\nwhile ((nbytes = walk.nbytes)) {\r\nunsigned int block_len = nbytes & DES_BLOCK_MASK;\r\nif (likely(block_len)) {\r\ndes_sparc64_cbc_encrypt((const u64 *)walk.src.virt.addr,\r\n(u64 *) walk.dst.virt.addr,\r\nblock_len, (u64 *) walk.iv);\r\n}\r\nnbytes &= DES_BLOCK_SIZE - 1;\r\nerr = blkcipher_walk_done(desc, &walk, nbytes);\r\n}\r\nfprs_write(0);\r\nreturn err;\r\n}\r\nstatic int cbc_decrypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nstruct des_sparc64_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nstruct blkcipher_walk walk;\r\nint err;\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nerr = blkcipher_walk_virt(desc, &walk);\r\ndesc->flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;\r\ndes_sparc64_load_keys(&ctx->decrypt_expkey[0]);\r\nwhile ((nbytes = walk.nbytes)) {\r\nunsigned int block_len = nbytes & DES_BLOCK_MASK;\r\nif (likely(block_len)) {\r\ndes_sparc64_cbc_decrypt((const u64 *)walk.src.virt.addr,\r\n(u64 *) walk.dst.virt.addr,\r\nblock_len, (u64 *) walk.iv);\r\n}\r\nnbytes &= DES_BLOCK_SIZE - 1;\r\nerr = blkcipher_walk_done(desc, &walk, nbytes);\r\n}\r\nfprs_write(0);\r\nreturn err;\r\n}\r\nstatic int des3_ede_set_key(struct crypto_tfm *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct des3_ede_sparc64_ctx *dctx = crypto_tfm_ctx(tfm);\r\nconst u32 *K = (const u32 *)key;\r\nu32 *flags = &tfm->crt_flags;\r\nu64 k1[DES_EXPKEY_WORDS / 2];\r\nu64 k2[DES_EXPKEY_WORDS / 2];\r\nu64 k3[DES_EXPKEY_WORDS / 2];\r\nif (unlikely(!((K[0] ^ K[2]) | (K[1] ^ K[3])) ||\r\n!((K[2] ^ K[4]) | (K[3] ^ K[5]))) &&\r\n(*flags & CRYPTO_TFM_REQ_WEAK_KEY)) {\r\n*flags |= CRYPTO_TFM_RES_WEAK_KEY;\r\nreturn -EINVAL;\r\n}\r\ndes_sparc64_key_expand((const u32 *)key, k1);\r\nkey += DES_KEY_SIZE;\r\ndes_sparc64_key_expand((const u32 *)key, k2);\r\nkey += DES_KEY_SIZE;\r\ndes_sparc64_key_expand((const u32 *)key, k3);\r\nmemcpy(&dctx->encrypt_expkey[0], &k1[0], sizeof(k1));\r\nencrypt_to_decrypt(&dctx->encrypt_expkey[DES_EXPKEY_WORDS / 2], &k2[0]);\r\nmemcpy(&dctx->encrypt_expkey[(DES_EXPKEY_WORDS / 2) * 2],\r\n&k3[0], sizeof(k3));\r\nencrypt_to_decrypt(&dctx->decrypt_expkey[0], &k3[0]);\r\nmemcpy(&dctx->decrypt_expkey[DES_EXPKEY_WORDS / 2],\r\n&k2[0], sizeof(k2));\r\nencrypt_to_decrypt(&dctx->decrypt_expkey[(DES_EXPKEY_WORDS / 2) * 2],\r\n&k1[0]);\r\nreturn 0;\r\n}\r\nstatic void des3_ede_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\r\n{\r\nstruct des3_ede_sparc64_ctx *ctx = crypto_tfm_ctx(tfm);\r\nconst u64 *K = ctx->encrypt_expkey;\r\ndes3_ede_sparc64_crypt(K, (const u64 *) src, (u64 *) dst);\r\n}\r\nstatic void des3_ede_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\r\n{\r\nstruct des3_ede_sparc64_ctx *ctx = crypto_tfm_ctx(tfm);\r\nconst u64 *K = ctx->decrypt_expkey;\r\ndes3_ede_sparc64_crypt(K, (const u64 *) src, (u64 *) dst);\r\n}\r\nstatic int __ecb3_crypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes, bool encrypt)\r\n{\r\nstruct des3_ede_sparc64_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nstruct blkcipher_walk walk;\r\nconst u64 *K;\r\nint err;\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nerr = blkcipher_walk_virt(desc, &walk);\r\ndesc->flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;\r\nif (encrypt)\r\nK = &ctx->encrypt_expkey[0];\r\nelse\r\nK = &ctx->decrypt_expkey[0];\r\ndes3_ede_sparc64_load_keys(K);\r\nwhile ((nbytes = walk.nbytes)) {\r\nunsigned int block_len = nbytes & DES_BLOCK_MASK;\r\nif (likely(block_len)) {\r\nconst u64 *src64 = (const u64 *)walk.src.virt.addr;\r\ndes3_ede_sparc64_ecb_crypt(K, src64,\r\n(u64 *) walk.dst.virt.addr,\r\nblock_len);\r\n}\r\nnbytes &= DES_BLOCK_SIZE - 1;\r\nerr = blkcipher_walk_done(desc, &walk, nbytes);\r\n}\r\nfprs_write(0);\r\nreturn err;\r\n}\r\nstatic int ecb3_encrypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nreturn __ecb3_crypt(desc, dst, src, nbytes, true);\r\n}\r\nstatic int ecb3_decrypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nreturn __ecb3_crypt(desc, dst, src, nbytes, false);\r\n}\r\nstatic int cbc3_encrypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nstruct des3_ede_sparc64_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nstruct blkcipher_walk walk;\r\nconst u64 *K;\r\nint err;\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nerr = blkcipher_walk_virt(desc, &walk);\r\ndesc->flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;\r\nK = &ctx->encrypt_expkey[0];\r\ndes3_ede_sparc64_load_keys(K);\r\nwhile ((nbytes = walk.nbytes)) {\r\nunsigned int block_len = nbytes & DES_BLOCK_MASK;\r\nif (likely(block_len)) {\r\nconst u64 *src64 = (const u64 *)walk.src.virt.addr;\r\ndes3_ede_sparc64_cbc_encrypt(K, src64,\r\n(u64 *) walk.dst.virt.addr,\r\nblock_len,\r\n(u64 *) walk.iv);\r\n}\r\nnbytes &= DES_BLOCK_SIZE - 1;\r\nerr = blkcipher_walk_done(desc, &walk, nbytes);\r\n}\r\nfprs_write(0);\r\nreturn err;\r\n}\r\nstatic int cbc3_decrypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nstruct des3_ede_sparc64_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nstruct blkcipher_walk walk;\r\nconst u64 *K;\r\nint err;\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nerr = blkcipher_walk_virt(desc, &walk);\r\ndesc->flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;\r\nK = &ctx->decrypt_expkey[0];\r\ndes3_ede_sparc64_load_keys(K);\r\nwhile ((nbytes = walk.nbytes)) {\r\nunsigned int block_len = nbytes & DES_BLOCK_MASK;\r\nif (likely(block_len)) {\r\nconst u64 *src64 = (const u64 *)walk.src.virt.addr;\r\ndes3_ede_sparc64_cbc_decrypt(K, src64,\r\n(u64 *) walk.dst.virt.addr,\r\nblock_len,\r\n(u64 *) walk.iv);\r\n}\r\nnbytes &= DES_BLOCK_SIZE - 1;\r\nerr = blkcipher_walk_done(desc, &walk, nbytes);\r\n}\r\nfprs_write(0);\r\nreturn err;\r\n}\r\nstatic bool __init sparc64_has_des_opcode(void)\r\n{\r\nunsigned long cfr;\r\nif (!(sparc64_elf_hwcap & HWCAP_SPARC_CRYPTO))\r\nreturn false;\r\n__asm__ __volatile__("rd %%asr26, %0" : "=r" (cfr));\r\nif (!(cfr & CFR_DES))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int __init des_sparc64_mod_init(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(algs); i++)\r\nINIT_LIST_HEAD(&algs[i].cra_list);\r\nif (sparc64_has_des_opcode()) {\r\npr_info("Using sparc64 des opcodes optimized DES implementation\n");\r\nreturn crypto_register_algs(algs, ARRAY_SIZE(algs));\r\n}\r\npr_info("sparc64 des opcodes not available.\n");\r\nreturn -ENODEV;\r\n}\r\nstatic void __exit des_sparc64_mod_fini(void)\r\n{\r\ncrypto_unregister_algs(algs, ARRAY_SIZE(algs));\r\n}
