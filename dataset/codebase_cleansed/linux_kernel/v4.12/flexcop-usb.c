static int flexcop_usb_readwrite_dw(struct flexcop_device *fc, u16 wRegOffsPCI, u32 *val, u8 read)\r\n{\r\nstruct flexcop_usb *fc_usb = fc->bus_specific;\r\nu8 request = read ? B2C2_USB_READ_REG : B2C2_USB_WRITE_REG;\r\nu8 request_type = (read ? USB_DIR_IN : USB_DIR_OUT) | USB_TYPE_VENDOR;\r\nu8 wAddress = B2C2_FLEX_PCIOFFSET_TO_INTERNALADDR(wRegOffsPCI) |\r\n(read ? 0x80 : 0);\r\nint ret;\r\nmutex_lock(&fc_usb->data_mutex);\r\nif (!read)\r\nmemcpy(fc_usb->data, val, sizeof(*val));\r\nret = usb_control_msg(fc_usb->udev,\r\nread ? B2C2_USB_CTRL_PIPE_IN : B2C2_USB_CTRL_PIPE_OUT,\r\nrequest,\r\nrequest_type,\r\nwAddress,\r\n0,\r\nfc_usb->data,\r\nsizeof(u32),\r\nB2C2_WAIT_FOR_OPERATION_RDW * HZ);\r\nif (ret != sizeof(u32)) {\r\nerr("error while %s dword from %d (%d).", read ? "reading" :\r\n"writing", wAddress, wRegOffsPCI);\r\nif (ret >= 0)\r\nret = -EIO;\r\n}\r\nif (read && ret >= 0)\r\nmemcpy(val, fc_usb->data, sizeof(*val));\r\nmutex_unlock(&fc_usb->data_mutex);\r\nreturn ret;\r\n}\r\nstatic int flexcop_usb_v8_memory_req(struct flexcop_usb *fc_usb,\r\nflexcop_usb_request_t req, u8 page, u16 wAddress,\r\nu8 *pbBuffer, u32 buflen)\r\n{\r\nu8 request_type = USB_TYPE_VENDOR;\r\nu16 wIndex;\r\nint nWaitTime, pipe, ret;\r\nwIndex = page << 8;\r\nif (buflen > sizeof(fc_usb->data)) {\r\nerr("Buffer size bigger than max URB control message\n");\r\nreturn -EIO;\r\n}\r\nswitch (req) {\r\ncase B2C2_USB_READ_V8_MEM:\r\nnWaitTime = B2C2_WAIT_FOR_OPERATION_V8READ;\r\nrequest_type |= USB_DIR_IN;\r\npipe = B2C2_USB_CTRL_PIPE_IN;\r\nbreak;\r\ncase B2C2_USB_WRITE_V8_MEM:\r\nwIndex |= pbBuffer[0];\r\nrequest_type |= USB_DIR_OUT;\r\nnWaitTime = B2C2_WAIT_FOR_OPERATION_V8WRITE;\r\npipe = B2C2_USB_CTRL_PIPE_OUT;\r\nbreak;\r\ncase B2C2_USB_FLASH_BLOCK:\r\nrequest_type |= USB_DIR_OUT;\r\nnWaitTime = B2C2_WAIT_FOR_OPERATION_V8FLASH;\r\npipe = B2C2_USB_CTRL_PIPE_OUT;\r\nbreak;\r\ndefault:\r\ndeb_info("unsupported request for v8_mem_req %x.\n", req);\r\nreturn -EINVAL;\r\n}\r\ndeb_v8("v8mem: %02x %02x %04x %04x, len: %d\n", request_type, req,\r\nwAddress, wIndex, buflen);\r\nmutex_lock(&fc_usb->data_mutex);\r\nif ((request_type & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT)\r\nmemcpy(fc_usb->data, pbBuffer, buflen);\r\nret = usb_control_msg(fc_usb->udev, pipe,\r\nreq,\r\nrequest_type,\r\nwAddress,\r\nwIndex,\r\nfc_usb->data,\r\nbuflen,\r\nnWaitTime * HZ);\r\nif (ret != buflen)\r\nret = -EIO;\r\nif (ret >= 0) {\r\nret = 0;\r\nif ((request_type & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN)\r\nmemcpy(pbBuffer, fc_usb->data, buflen);\r\n}\r\nmutex_unlock(&fc_usb->data_mutex);\r\ndebug_dump(pbBuffer, ret, deb_v8);\r\nreturn ret;\r\n}\r\nstatic int flexcop_usb_memory_req(struct flexcop_usb *fc_usb,\r\nflexcop_usb_request_t req, flexcop_usb_mem_page_t page_start,\r\nu32 addr, int extended, u8 *buf, u32 len)\r\n{\r\nint i,ret = 0;\r\nu16 wMax;\r\nu32 pagechunk = 0;\r\nswitch(req) {\r\ncase B2C2_USB_READ_V8_MEM:\r\nwMax = USB_MEM_READ_MAX;\r\nbreak;\r\ncase B2C2_USB_WRITE_V8_MEM:\r\nwMax = USB_MEM_WRITE_MAX;\r\nbreak;\r\ncase B2C2_USB_FLASH_BLOCK:\r\nwMax = USB_FLASH_MAX;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nfor (i = 0; i < len;) {\r\npagechunk =\r\nwMax < bytes_left_to_read_on_page(addr, len) ?\r\nwMax :\r\nbytes_left_to_read_on_page(addr, len);\r\ndeb_info("%x\n",\r\n(addr & V8_MEMORY_PAGE_MASK) |\r\n(V8_MEMORY_EXTENDED*extended));\r\nret = flexcop_usb_v8_memory_req(fc_usb, req,\r\npage_start + (addr / V8_MEMORY_PAGE_SIZE),\r\n(addr & V8_MEMORY_PAGE_MASK) |\r\n(V8_MEMORY_EXTENDED*extended),\r\n&buf[i], pagechunk);\r\nif (ret < 0)\r\nreturn ret;\r\naddr += pagechunk;\r\nlen -= pagechunk;\r\n}\r\nreturn 0;\r\n}\r\nstatic int flexcop_usb_get_mac_addr(struct flexcop_device *fc, int extended)\r\n{\r\nreturn flexcop_usb_memory_req(fc->bus_specific, B2C2_USB_READ_V8_MEM,\r\nV8_MEMORY_PAGE_FLASH, 0x1f010, 1,\r\nfc->dvb_adapter.proposed_mac, 6);\r\n}\r\nstatic int flexcop_usb_i2c_req(struct flexcop_i2c_adapter *i2c,\r\nflexcop_usb_request_t req, flexcop_usb_i2c_function_t func,\r\nu8 chipaddr, u8 addr, u8 *buf, u8 buflen)\r\n{\r\nstruct flexcop_usb *fc_usb = i2c->fc->bus_specific;\r\nu16 wValue, wIndex;\r\nint nWaitTime, pipe, ret;\r\nu8 request_type = USB_TYPE_VENDOR;\r\nif (buflen > sizeof(fc_usb->data)) {\r\nerr("Buffer size bigger than max URB control message\n");\r\nreturn -EIO;\r\n}\r\nswitch (func) {\r\ncase USB_FUNC_I2C_WRITE:\r\ncase USB_FUNC_I2C_MULTIWRITE:\r\ncase USB_FUNC_I2C_REPEATWRITE:\r\ncase USB_FUNC_I2C_CHECKWRITE:\r\npipe = B2C2_USB_CTRL_PIPE_OUT;\r\nnWaitTime = 2;\r\nrequest_type |= USB_DIR_OUT;\r\nbreak;\r\ncase USB_FUNC_I2C_READ:\r\ncase USB_FUNC_I2C_REPEATREAD:\r\npipe = B2C2_USB_CTRL_PIPE_IN;\r\nnWaitTime = 2;\r\nrequest_type |= USB_DIR_IN;\r\nbreak;\r\ndefault:\r\ndeb_info("unsupported function for i2c_req %x\n", func);\r\nreturn -EINVAL;\r\n}\r\nwValue = (func << 8) | (i2c->port << 4);\r\nwIndex = (chipaddr << 8 ) | addr;\r\ndeb_i2c("i2c %2d: %02x %02x %02x %02x %02x %02x\n",\r\nfunc, request_type, req,\r\nwValue & 0xff, wValue >> 8,\r\nwIndex & 0xff, wIndex >> 8);\r\nmutex_lock(&fc_usb->data_mutex);\r\nif ((request_type & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT)\r\nmemcpy(fc_usb->data, buf, buflen);\r\nret = usb_control_msg(fc_usb->udev, pipe,\r\nreq,\r\nrequest_type,\r\nwValue,\r\nwIndex,\r\nfc_usb->data,\r\nbuflen,\r\nnWaitTime * HZ);\r\nif (ret != buflen)\r\nret = -EIO;\r\nif (ret >= 0) {\r\nret = 0;\r\nif ((request_type & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN)\r\nmemcpy(buf, fc_usb->data, buflen);\r\n}\r\nmutex_unlock(&fc_usb->data_mutex);\r\nreturn 0;\r\n}\r\nstatic flexcop_ibi_value flexcop_usb_read_ibi_reg(struct flexcop_device *fc,\r\nflexcop_ibi_register reg)\r\n{\r\nflexcop_ibi_value val;\r\nval.raw = 0;\r\nflexcop_usb_readwrite_dw(fc, reg, &val.raw, 1);\r\nreturn val;\r\n}\r\nstatic int flexcop_usb_write_ibi_reg(struct flexcop_device *fc,\r\nflexcop_ibi_register reg, flexcop_ibi_value val)\r\n{\r\nreturn flexcop_usb_readwrite_dw(fc, reg, &val.raw, 0);\r\n}\r\nstatic int flexcop_usb_i2c_request(struct flexcop_i2c_adapter *i2c,\r\nflexcop_access_op_t op, u8 chipaddr, u8 addr, u8 *buf, u16 len)\r\n{\r\nif (op == FC_READ)\r\nreturn flexcop_usb_i2c_req(i2c, B2C2_USB_I2C_REQUEST,\r\nUSB_FUNC_I2C_READ, chipaddr, addr, buf, len);\r\nelse\r\nreturn flexcop_usb_i2c_req(i2c, B2C2_USB_I2C_REQUEST,\r\nUSB_FUNC_I2C_WRITE, chipaddr, addr, buf, len);\r\n}\r\nstatic void flexcop_usb_process_frame(struct flexcop_usb *fc_usb,\r\nu8 *buffer, int buffer_length)\r\n{\r\nu8 *b;\r\nint l;\r\ndeb_ts("tmp_buffer_length=%d, buffer_length=%d\n",\r\nfc_usb->tmp_buffer_length, buffer_length);\r\nif (fc_usb->tmp_buffer_length > 0) {\r\nmemcpy(fc_usb->tmp_buffer+fc_usb->tmp_buffer_length, buffer,\r\nbuffer_length);\r\nfc_usb->tmp_buffer_length += buffer_length;\r\nb = fc_usb->tmp_buffer;\r\nl = fc_usb->tmp_buffer_length;\r\n} else {\r\nb=buffer;\r\nl=buffer_length;\r\n}\r\nwhile (l >= 190) {\r\nif (*b == 0xff) {\r\nswitch (*(b+1) & 0x03) {\r\ncase 0x01:\r\nif (*(b+2) == 0x47)\r\nflexcop_pass_dmx_packets(\r\nfc_usb->fc_dev, b+2, 1);\r\nelse\r\ndeb_ts("not ts packet %*ph\n", 4, b+2);\r\nb += 190;\r\nl -= 190;\r\nbreak;\r\ndefault:\r\ndeb_ts("wrong packet type\n");\r\nl = 0;\r\nbreak;\r\n}\r\n} else {\r\ndeb_ts("wrong header\n");\r\nl = 0;\r\n}\r\n}\r\nif (l>0)\r\nmemcpy(fc_usb->tmp_buffer, b, l);\r\nfc_usb->tmp_buffer_length = l;\r\n}\r\nstatic void flexcop_usb_urb_complete(struct urb *urb)\r\n{\r\nstruct flexcop_usb *fc_usb = urb->context;\r\nint i;\r\nif (urb->actual_length > 0)\r\ndeb_ts("urb completed, bufsize: %d actlen; %d\n",\r\nurb->transfer_buffer_length, urb->actual_length);\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nif (urb->iso_frame_desc[i].status < 0) {\r\nerr("iso frame descriptor %d has an error: %d\n", i,\r\nurb->iso_frame_desc[i].status);\r\n} else\r\nif (urb->iso_frame_desc[i].actual_length > 0) {\r\ndeb_ts("passed %d bytes to the demux\n",\r\nurb->iso_frame_desc[i].actual_length);\r\nflexcop_usb_process_frame(fc_usb,\r\nurb->transfer_buffer +\r\nurb->iso_frame_desc[i].offset,\r\nurb->iso_frame_desc[i].actual_length);\r\n}\r\nurb->iso_frame_desc[i].status = 0;\r\nurb->iso_frame_desc[i].actual_length = 0;\r\n}\r\nusb_submit_urb(urb,GFP_ATOMIC);\r\n}\r\nstatic int flexcop_usb_stream_control(struct flexcop_device *fc, int onoff)\r\n{\r\nreturn 0;\r\n}\r\nstatic void flexcop_usb_transfer_exit(struct flexcop_usb *fc_usb)\r\n{\r\nint i;\r\nfor (i = 0; i < B2C2_USB_NUM_ISO_URB; i++)\r\nif (fc_usb->iso_urb[i] != NULL) {\r\ndeb_ts("unlinking/killing urb no. %d\n",i);\r\nusb_kill_urb(fc_usb->iso_urb[i]);\r\nusb_free_urb(fc_usb->iso_urb[i]);\r\n}\r\nif (fc_usb->iso_buffer != NULL)\r\nusb_free_coherent(fc_usb->udev,\r\nfc_usb->buffer_size, fc_usb->iso_buffer,\r\nfc_usb->dma_addr);\r\n}\r\nstatic int flexcop_usb_transfer_init(struct flexcop_usb *fc_usb)\r\n{\r\nu16 frame_size = le16_to_cpu(\r\nfc_usb->uintf->cur_altsetting->endpoint[0].desc.wMaxPacketSize);\r\nint bufsize = B2C2_USB_NUM_ISO_URB * B2C2_USB_FRAMES_PER_ISO *\r\nframe_size, i, j, ret;\r\nint buffer_offset = 0;\r\ndeb_ts("creating %d iso-urbs with %d frames each of %d bytes size = %d.\n",\r\nB2C2_USB_NUM_ISO_URB,\r\nB2C2_USB_FRAMES_PER_ISO, frame_size, bufsize);\r\nfc_usb->iso_buffer = usb_alloc_coherent(fc_usb->udev,\r\nbufsize, GFP_KERNEL, &fc_usb->dma_addr);\r\nif (fc_usb->iso_buffer == NULL)\r\nreturn -ENOMEM;\r\nmemset(fc_usb->iso_buffer, 0, bufsize);\r\nfc_usb->buffer_size = bufsize;\r\nfor (i = 0; i < B2C2_USB_NUM_ISO_URB; i++) {\r\nfc_usb->iso_urb[i] = usb_alloc_urb(B2C2_USB_FRAMES_PER_ISO,\r\nGFP_ATOMIC);\r\nif (fc_usb->iso_urb[i] == NULL) {\r\nret = -ENOMEM;\r\ngoto urb_error;\r\n}\r\n}\r\nfor (i = 0; i < B2C2_USB_NUM_ISO_URB; i++) {\r\nint frame_offset = 0;\r\nstruct urb *urb = fc_usb->iso_urb[i];\r\ndeb_ts("initializing and submitting urb no. %d (buf_offset: %d).\n",\r\ni, buffer_offset);\r\nurb->dev = fc_usb->udev;\r\nurb->context = fc_usb;\r\nurb->complete = flexcop_usb_urb_complete;\r\nurb->pipe = B2C2_USB_DATA_PIPE;\r\nurb->transfer_flags = URB_ISO_ASAP;\r\nurb->interval = 1;\r\nurb->number_of_packets = B2C2_USB_FRAMES_PER_ISO;\r\nurb->transfer_buffer_length = frame_size * B2C2_USB_FRAMES_PER_ISO;\r\nurb->transfer_buffer = fc_usb->iso_buffer + buffer_offset;\r\nbuffer_offset += frame_size * B2C2_USB_FRAMES_PER_ISO;\r\nfor (j = 0; j < B2C2_USB_FRAMES_PER_ISO; j++) {\r\ndeb_ts("urb no: %d, frame: %d, frame_offset: %d\n",\r\ni, j, frame_offset);\r\nurb->iso_frame_desc[j].offset = frame_offset;\r\nurb->iso_frame_desc[j].length = frame_size;\r\nframe_offset += frame_size;\r\n}\r\nif ((ret = usb_submit_urb(fc_usb->iso_urb[i],GFP_ATOMIC))) {\r\nerr("submitting urb %d failed with %d.", i, ret);\r\ngoto urb_error;\r\n}\r\ndeb_ts("submitted urb no. %d.\n",i);\r\n}\r\nflexcop_sram_set_dest(fc_usb->fc_dev, FC_SRAM_DEST_MEDIA |\r\nFC_SRAM_DEST_NET | FC_SRAM_DEST_CAO | FC_SRAM_DEST_CAI,\r\nFC_SRAM_DEST_TARGET_WAN_USB);\r\nflexcop_wan_set_speed(fc_usb->fc_dev, FC_WAN_SPEED_8MBITS);\r\nflexcop_sram_ctrl(fc_usb->fc_dev, 1, 1, 1);\r\nreturn 0;\r\nurb_error:\r\nflexcop_usb_transfer_exit(fc_usb);\r\nreturn ret;\r\n}\r\nstatic int flexcop_usb_init(struct flexcop_usb *fc_usb)\r\n{\r\nusb_set_interface(fc_usb->udev,0,1);\r\nswitch (fc_usb->udev->speed) {\r\ncase USB_SPEED_LOW:\r\nerr("cannot handle USB speed because it is too slow.");\r\nreturn -ENODEV;\r\nbreak;\r\ncase USB_SPEED_FULL:\r\ninfo("running at FULL speed.");\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\ninfo("running at HIGH speed.");\r\nbreak;\r\ncase USB_SPEED_UNKNOWN:\r\ndefault:\r\nerr("cannot handle USB speed because it is unknown.");\r\nreturn -ENODEV;\r\n}\r\nusb_set_intfdata(fc_usb->uintf, fc_usb);\r\nreturn 0;\r\n}\r\nstatic void flexcop_usb_exit(struct flexcop_usb *fc_usb)\r\n{\r\nusb_set_intfdata(fc_usb->uintf, NULL);\r\n}\r\nstatic int flexcop_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct flexcop_usb *fc_usb = NULL;\r\nstruct flexcop_device *fc = NULL;\r\nint ret;\r\nif ((fc = flexcop_device_kmalloc(sizeof(struct flexcop_usb))) == NULL) {\r\nerr("out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nfc_usb = fc->bus_specific;\r\nfc_usb->fc_dev = fc;\r\nmutex_init(&fc_usb->data_mutex);\r\nfc->read_ibi_reg = flexcop_usb_read_ibi_reg;\r\nfc->write_ibi_reg = flexcop_usb_write_ibi_reg;\r\nfc->i2c_request = flexcop_usb_i2c_request;\r\nfc->get_mac_addr = flexcop_usb_get_mac_addr;\r\nfc->stream_control = flexcop_usb_stream_control;\r\nfc->pid_filtering = 1;\r\nfc->bus_type = FC_USB;\r\nfc->dev = &udev->dev;\r\nfc->owner = THIS_MODULE;\r\nfc_usb->udev = udev;\r\nfc_usb->uintf = intf;\r\nif ((ret = flexcop_usb_init(fc_usb)) != 0)\r\ngoto err_kfree;\r\nif ((ret = flexcop_device_initialize(fc)) != 0)\r\ngoto err_usb_exit;\r\nif ((ret = flexcop_usb_transfer_init(fc_usb)) != 0)\r\ngoto err_fc_exit;\r\ninfo("%s successfully initialized and connected.", DRIVER_NAME);\r\nreturn 0;\r\nerr_fc_exit:\r\nflexcop_device_exit(fc);\r\nerr_usb_exit:\r\nflexcop_usb_exit(fc_usb);\r\nerr_kfree:\r\nflexcop_device_kfree(fc);\r\nreturn ret;\r\n}\r\nstatic void flexcop_usb_disconnect(struct usb_interface *intf)\r\n{\r\nstruct flexcop_usb *fc_usb = usb_get_intfdata(intf);\r\nflexcop_usb_transfer_exit(fc_usb);\r\nflexcop_device_exit(fc_usb->fc_dev);\r\nflexcop_usb_exit(fc_usb);\r\nflexcop_device_kfree(fc_usb->fc_dev);\r\ninfo("%s successfully deinitialized and disconnected.", DRIVER_NAME);\r\n}
