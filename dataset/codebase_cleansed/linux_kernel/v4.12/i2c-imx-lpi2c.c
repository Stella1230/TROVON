static void lpi2c_imx_intctrl(struct lpi2c_imx_struct *lpi2c_imx,\r\nunsigned int enable)\r\n{\r\nwritel(enable, lpi2c_imx->base + LPI2C_MIER);\r\n}\r\nstatic int lpi2c_imx_bus_busy(struct lpi2c_imx_struct *lpi2c_imx)\r\n{\r\nunsigned long orig_jiffies = jiffies;\r\nunsigned int temp;\r\nwhile (1) {\r\ntemp = readl(lpi2c_imx->base + LPI2C_MSR);\r\nif (temp & MSR_ALF) {\r\nwritel(temp, lpi2c_imx->base + LPI2C_MSR);\r\nreturn -EAGAIN;\r\n}\r\nif (temp & (MSR_BBF | MSR_MBF))\r\nbreak;\r\nif (time_after(jiffies, orig_jiffies + msecs_to_jiffies(500))) {\r\ndev_dbg(&lpi2c_imx->adapter.dev, "bus not work\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nschedule();\r\n}\r\nreturn 0;\r\n}\r\nstatic void lpi2c_imx_set_mode(struct lpi2c_imx_struct *lpi2c_imx)\r\n{\r\nunsigned int bitrate = lpi2c_imx->bitrate;\r\nenum lpi2c_imx_mode mode;\r\nif (bitrate < STARDARD_MAX_BITRATE)\r\nmode = STANDARD;\r\nelse if (bitrate < FAST_MAX_BITRATE)\r\nmode = FAST;\r\nelse if (bitrate < FAST_PLUS_MAX_BITRATE)\r\nmode = FAST_PLUS;\r\nelse if (bitrate < HIGHSPEED_MAX_BITRATE)\r\nmode = HS;\r\nelse\r\nmode = ULTRA_FAST;\r\nlpi2c_imx->mode = mode;\r\n}\r\nstatic int lpi2c_imx_start(struct lpi2c_imx_struct *lpi2c_imx,\r\nstruct i2c_msg *msgs)\r\n{\r\nunsigned int temp;\r\nu8 read;\r\ntemp = readl(lpi2c_imx->base + LPI2C_MCR);\r\ntemp |= MCR_RRF | MCR_RTF;\r\nwritel(temp, lpi2c_imx->base + LPI2C_MCR);\r\nwritel(0x7f00, lpi2c_imx->base + LPI2C_MSR);\r\nread = msgs->flags & I2C_M_RD;\r\ntemp = (msgs->addr << 1 | read) | (GEN_START << 8);\r\nwritel(temp, lpi2c_imx->base + LPI2C_MTDR);\r\nreturn lpi2c_imx_bus_busy(lpi2c_imx);\r\n}\r\nstatic void lpi2c_imx_stop(struct lpi2c_imx_struct *lpi2c_imx)\r\n{\r\nunsigned long orig_jiffies = jiffies;\r\nunsigned int temp;\r\nwritel(GEN_STOP << 8, lpi2c_imx->base + LPI2C_MTDR);\r\ndo {\r\ntemp = readl(lpi2c_imx->base + LPI2C_MSR);\r\nif (temp & MSR_SDF)\r\nbreak;\r\nif (time_after(jiffies, orig_jiffies + msecs_to_jiffies(500))) {\r\ndev_dbg(&lpi2c_imx->adapter.dev, "stop timeout\n");\r\nbreak;\r\n}\r\nschedule();\r\n} while (1);\r\n}\r\nstatic int lpi2c_imx_config(struct lpi2c_imx_struct *lpi2c_imx)\r\n{\r\nu8 prescale, filt, sethold, clkhi, clklo, datavd;\r\nunsigned int clk_rate, clk_cycle;\r\nenum lpi2c_imx_pincfg pincfg;\r\nunsigned int temp;\r\nlpi2c_imx_set_mode(lpi2c_imx);\r\nclk_rate = clk_get_rate(lpi2c_imx->clk);\r\nif (lpi2c_imx->mode == HS || lpi2c_imx->mode == ULTRA_FAST)\r\nfilt = 0;\r\nelse\r\nfilt = 2;\r\nfor (prescale = 0; prescale <= 7; prescale++) {\r\nclk_cycle = clk_rate / ((1 << prescale) * lpi2c_imx->bitrate)\r\n- 3 - (filt >> 1);\r\nclkhi = (clk_cycle + I2C_CLK_RATIO) / (I2C_CLK_RATIO + 1);\r\nclklo = clk_cycle - clkhi;\r\nif (clklo < 64)\r\nbreak;\r\n}\r\nif (prescale > 7)\r\nreturn -EINVAL;\r\nif (lpi2c_imx->mode == ULTRA_FAST)\r\npincfg = TWO_PIN_OO;\r\nelse\r\npincfg = TWO_PIN_OD;\r\ntemp = prescale | pincfg << 24;\r\nif (lpi2c_imx->mode == ULTRA_FAST)\r\ntemp |= MCFGR1_IGNACK;\r\nwritel(temp, lpi2c_imx->base + LPI2C_MCFGR1);\r\ntemp = (filt << 16) | (filt << 24);\r\nwritel(temp, lpi2c_imx->base + LPI2C_MCFGR2);\r\nsethold = clkhi;\r\ndatavd = clkhi >> 1;\r\ntemp = datavd << 24 | sethold << 16 | clkhi << 8 | clklo;\r\nif (lpi2c_imx->mode == HS)\r\nwritel(temp, lpi2c_imx->base + LPI2C_MCCR1);\r\nelse\r\nwritel(temp, lpi2c_imx->base + LPI2C_MCCR0);\r\nreturn 0;\r\n}\r\nstatic int lpi2c_imx_master_enable(struct lpi2c_imx_struct *lpi2c_imx)\r\n{\r\nunsigned int temp;\r\nint ret;\r\nret = clk_enable(lpi2c_imx->clk);\r\nif (ret)\r\nreturn ret;\r\ntemp = MCR_RST;\r\nwritel(temp, lpi2c_imx->base + LPI2C_MCR);\r\nwritel(0, lpi2c_imx->base + LPI2C_MCR);\r\nret = lpi2c_imx_config(lpi2c_imx);\r\nif (ret)\r\ngoto clk_disable;\r\ntemp = readl(lpi2c_imx->base + LPI2C_MCR);\r\ntemp |= MCR_MEN;\r\nwritel(temp, lpi2c_imx->base + LPI2C_MCR);\r\nreturn 0;\r\nclk_disable:\r\nclk_disable(lpi2c_imx->clk);\r\nreturn ret;\r\n}\r\nstatic int lpi2c_imx_master_disable(struct lpi2c_imx_struct *lpi2c_imx)\r\n{\r\nu32 temp;\r\ntemp = readl(lpi2c_imx->base + LPI2C_MCR);\r\ntemp &= ~MCR_MEN;\r\nwritel(temp, lpi2c_imx->base + LPI2C_MCR);\r\nclk_disable(lpi2c_imx->clk);\r\nreturn 0;\r\n}\r\nstatic int lpi2c_imx_msg_complete(struct lpi2c_imx_struct *lpi2c_imx)\r\n{\r\nunsigned long timeout;\r\ntimeout = wait_for_completion_timeout(&lpi2c_imx->complete, HZ);\r\nreturn timeout ? 0 : -ETIMEDOUT;\r\n}\r\nstatic int lpi2c_imx_txfifo_empty(struct lpi2c_imx_struct *lpi2c_imx)\r\n{\r\nunsigned long orig_jiffies = jiffies;\r\nu32 txcnt;\r\ndo {\r\ntxcnt = readl(lpi2c_imx->base + LPI2C_MFSR) & 0xff;\r\nif (readl(lpi2c_imx->base + LPI2C_MSR) & MSR_NDF) {\r\ndev_dbg(&lpi2c_imx->adapter.dev, "NDF detected\n");\r\nreturn -EIO;\r\n}\r\nif (time_after(jiffies, orig_jiffies + msecs_to_jiffies(500))) {\r\ndev_dbg(&lpi2c_imx->adapter.dev, "txfifo empty timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nschedule();\r\n} while (txcnt);\r\nreturn 0;\r\n}\r\nstatic void lpi2c_imx_set_tx_watermark(struct lpi2c_imx_struct *lpi2c_imx)\r\n{\r\nwritel(lpi2c_imx->txfifosize >> 1, lpi2c_imx->base + LPI2C_MFCR);\r\n}\r\nstatic void lpi2c_imx_set_rx_watermark(struct lpi2c_imx_struct *lpi2c_imx)\r\n{\r\nunsigned int temp, remaining;\r\nremaining = lpi2c_imx->msglen - lpi2c_imx->delivered;\r\nif (remaining > (lpi2c_imx->rxfifosize >> 1))\r\ntemp = lpi2c_imx->rxfifosize >> 1;\r\nelse\r\ntemp = 0;\r\nwritel(temp << 16, lpi2c_imx->base + LPI2C_MFCR);\r\n}\r\nstatic void lpi2c_imx_write_txfifo(struct lpi2c_imx_struct *lpi2c_imx)\r\n{\r\nunsigned int data, txcnt;\r\ntxcnt = readl(lpi2c_imx->base + LPI2C_MFSR) & 0xff;\r\nwhile (txcnt < lpi2c_imx->txfifosize) {\r\nif (lpi2c_imx->delivered == lpi2c_imx->msglen)\r\nbreak;\r\ndata = lpi2c_imx->tx_buf[lpi2c_imx->delivered++];\r\nwritel(data, lpi2c_imx->base + LPI2C_MTDR);\r\ntxcnt++;\r\n}\r\nif (lpi2c_imx->delivered < lpi2c_imx->msglen)\r\nlpi2c_imx_intctrl(lpi2c_imx, MIER_TDIE | MIER_NDIE);\r\nelse\r\ncomplete(&lpi2c_imx->complete);\r\n}\r\nstatic void lpi2c_imx_read_rxfifo(struct lpi2c_imx_struct *lpi2c_imx)\r\n{\r\nunsigned int blocklen, remaining;\r\nunsigned int temp, data;\r\ndo {\r\ndata = readl(lpi2c_imx->base + LPI2C_MRDR);\r\nif (data & MRDR_RXEMPTY)\r\nbreak;\r\nlpi2c_imx->rx_buf[lpi2c_imx->delivered++] = data & 0xff;\r\n} while (1);\r\nif (lpi2c_imx->block_data) {\r\nblocklen = lpi2c_imx->rx_buf[0];\r\nlpi2c_imx->msglen += blocklen;\r\n}\r\nremaining = lpi2c_imx->msglen - lpi2c_imx->delivered;\r\nif (!remaining) {\r\ncomplete(&lpi2c_imx->complete);\r\nreturn;\r\n}\r\nlpi2c_imx_set_rx_watermark(lpi2c_imx);\r\nif (lpi2c_imx->block_data) {\r\nlpi2c_imx->block_data = 0;\r\ntemp = remaining;\r\ntemp |= (RECV_DATA << 8);\r\nwritel(temp, lpi2c_imx->base + LPI2C_MTDR);\r\n} else if (!(lpi2c_imx->delivered & 0xff)) {\r\ntemp = (remaining > CHUNK_DATA ? CHUNK_DATA : remaining) - 1;\r\ntemp |= (RECV_DATA << 8);\r\nwritel(temp, lpi2c_imx->base + LPI2C_MTDR);\r\n}\r\nlpi2c_imx_intctrl(lpi2c_imx, MIER_RDIE);\r\n}\r\nstatic void lpi2c_imx_write(struct lpi2c_imx_struct *lpi2c_imx,\r\nstruct i2c_msg *msgs)\r\n{\r\nlpi2c_imx->tx_buf = msgs->buf;\r\nlpi2c_imx_set_tx_watermark(lpi2c_imx);\r\nlpi2c_imx_write_txfifo(lpi2c_imx);\r\n}\r\nstatic void lpi2c_imx_read(struct lpi2c_imx_struct *lpi2c_imx,\r\nstruct i2c_msg *msgs)\r\n{\r\nunsigned int temp;\r\nlpi2c_imx->rx_buf = msgs->buf;\r\nlpi2c_imx->block_data = msgs->flags & I2C_M_RECV_LEN;\r\nlpi2c_imx_set_rx_watermark(lpi2c_imx);\r\ntemp = msgs->len > CHUNK_DATA ? CHUNK_DATA - 1 : msgs->len - 1;\r\ntemp |= (RECV_DATA << 8);\r\nwritel(temp, lpi2c_imx->base + LPI2C_MTDR);\r\nlpi2c_imx_intctrl(lpi2c_imx, MIER_RDIE | MIER_NDIE);\r\n}\r\nstatic int lpi2c_imx_xfer(struct i2c_adapter *adapter,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nstruct lpi2c_imx_struct *lpi2c_imx = i2c_get_adapdata(adapter);\r\nunsigned int temp;\r\nint i, result;\r\nresult = lpi2c_imx_master_enable(lpi2c_imx);\r\nif (result)\r\nreturn result;\r\nfor (i = 0; i < num; i++) {\r\nresult = lpi2c_imx_start(lpi2c_imx, &msgs[i]);\r\nif (result)\r\ngoto disable;\r\nif (num == 1 && msgs[0].len == 0)\r\ngoto stop;\r\nlpi2c_imx->delivered = 0;\r\nlpi2c_imx->msglen = msgs[i].len;\r\ninit_completion(&lpi2c_imx->complete);\r\nif (msgs[i].flags & I2C_M_RD)\r\nlpi2c_imx_read(lpi2c_imx, &msgs[i]);\r\nelse\r\nlpi2c_imx_write(lpi2c_imx, &msgs[i]);\r\nresult = lpi2c_imx_msg_complete(lpi2c_imx);\r\nif (result)\r\ngoto stop;\r\nif (!(msgs[i].flags & I2C_M_RD)) {\r\nresult = lpi2c_imx_txfifo_empty(lpi2c_imx);\r\nif (result)\r\ngoto stop;\r\n}\r\n}\r\nstop:\r\nlpi2c_imx_stop(lpi2c_imx);\r\ntemp = readl(lpi2c_imx->base + LPI2C_MSR);\r\nif ((temp & MSR_NDF) && !result)\r\nresult = -EIO;\r\ndisable:\r\nlpi2c_imx_master_disable(lpi2c_imx);\r\ndev_dbg(&lpi2c_imx->adapter.dev, "<%s> exit with: %s: %d\n", __func__,\r\n(result < 0) ? "error" : "success msg",\r\n(result < 0) ? result : num);\r\nreturn (result < 0) ? result : num;\r\n}\r\nstatic irqreturn_t lpi2c_imx_isr(int irq, void *dev_id)\r\n{\r\nstruct lpi2c_imx_struct *lpi2c_imx = dev_id;\r\nunsigned int temp;\r\nlpi2c_imx_intctrl(lpi2c_imx, 0);\r\ntemp = readl(lpi2c_imx->base + LPI2C_MSR);\r\nif (temp & MSR_RDF)\r\nlpi2c_imx_read_rxfifo(lpi2c_imx);\r\nif (temp & MSR_TDF)\r\nlpi2c_imx_write_txfifo(lpi2c_imx);\r\nif (temp & MSR_NDF)\r\ncomplete(&lpi2c_imx->complete);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic u32 lpi2c_imx_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL |\r\nI2C_FUNC_SMBUS_READ_BLOCK_DATA;\r\n}\r\nstatic int lpi2c_imx_probe(struct platform_device *pdev)\r\n{\r\nstruct lpi2c_imx_struct *lpi2c_imx;\r\nstruct resource *res;\r\nunsigned int temp;\r\nint irq, ret;\r\nlpi2c_imx = devm_kzalloc(&pdev->dev, sizeof(*lpi2c_imx), GFP_KERNEL);\r\nif (!lpi2c_imx)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nlpi2c_imx->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(lpi2c_imx->base))\r\nreturn PTR_ERR(lpi2c_imx->base);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "can't get irq number\n");\r\nreturn irq;\r\n}\r\nlpi2c_imx->adapter.owner = THIS_MODULE;\r\nlpi2c_imx->adapter.algo = &lpi2c_imx_algo;\r\nlpi2c_imx->adapter.dev.parent = &pdev->dev;\r\nlpi2c_imx->adapter.dev.of_node = pdev->dev.of_node;\r\nstrlcpy(lpi2c_imx->adapter.name, pdev->name,\r\nsizeof(lpi2c_imx->adapter.name));\r\nlpi2c_imx->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(lpi2c_imx->clk)) {\r\ndev_err(&pdev->dev, "can't get I2C peripheral clock\n");\r\nreturn PTR_ERR(lpi2c_imx->clk);\r\n}\r\nret = of_property_read_u32(pdev->dev.of_node,\r\n"clock-frequency", &lpi2c_imx->bitrate);\r\nif (ret)\r\nlpi2c_imx->bitrate = LPI2C_DEFAULT_RATE;\r\nret = devm_request_irq(&pdev->dev, irq, lpi2c_imx_isr, 0,\r\npdev->name, lpi2c_imx);\r\nif (ret) {\r\ndev_err(&pdev->dev, "can't claim irq %d\n", irq);\r\nreturn ret;\r\n}\r\ni2c_set_adapdata(&lpi2c_imx->adapter, lpi2c_imx);\r\nplatform_set_drvdata(pdev, lpi2c_imx);\r\nret = clk_prepare_enable(lpi2c_imx->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "clk enable failed %d\n", ret);\r\nreturn ret;\r\n}\r\ntemp = readl(lpi2c_imx->base + LPI2C_PARAM);\r\nlpi2c_imx->txfifosize = 1 << (temp & 0x0f);\r\nlpi2c_imx->rxfifosize = 1 << ((temp >> 8) & 0x0f);\r\nclk_disable(lpi2c_imx->clk);\r\nret = i2c_add_adapter(&lpi2c_imx->adapter);\r\nif (ret)\r\ngoto clk_unprepare;\r\ndev_info(&lpi2c_imx->adapter.dev, "LPI2C adapter registered\n");\r\nreturn 0;\r\nclk_unprepare:\r\nclk_unprepare(lpi2c_imx->clk);\r\nreturn ret;\r\n}\r\nstatic int lpi2c_imx_remove(struct platform_device *pdev)\r\n{\r\nstruct lpi2c_imx_struct *lpi2c_imx = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&lpi2c_imx->adapter);\r\nclk_unprepare(lpi2c_imx->clk);\r\nreturn 0;\r\n}\r\nstatic int lpi2c_imx_suspend(struct device *dev)\r\n{\r\npinctrl_pm_select_sleep_state(dev);\r\nreturn 0;\r\n}\r\nstatic int lpi2c_imx_resume(struct device *dev)\r\n{\r\npinctrl_pm_select_default_state(dev);\r\nreturn 0;\r\n}
