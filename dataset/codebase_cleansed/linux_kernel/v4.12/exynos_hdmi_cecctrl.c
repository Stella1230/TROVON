void s5p_cec_set_divider(struct s5p_cec_dev *cec)\r\n{\r\nu32 div_ratio, div_val;\r\nunsigned int reg;\r\ndiv_ratio = S5P_HDMI_FIN / CEC_DIV_RATIO - 1;\r\nif (regmap_read(cec->pmu, EXYNOS_HDMI_PHY_CONTROL, &reg)) {\r\ndev_err(cec->dev, "failed to read phy control\n");\r\nreturn;\r\n}\r\nreg = (reg & ~(0x3FF << 16)) | (div_ratio << 16);\r\nif (regmap_write(cec->pmu, EXYNOS_HDMI_PHY_CONTROL, reg)) {\r\ndev_err(cec->dev, "failed to write phy control\n");\r\nreturn;\r\n}\r\ndiv_val = CEC_DIV_RATIO * 0.00005 - 1;\r\nwriteb(0x0, cec->reg + S5P_CEC_DIVISOR_3);\r\nwriteb(0x0, cec->reg + S5P_CEC_DIVISOR_2);\r\nwriteb(0x0, cec->reg + S5P_CEC_DIVISOR_1);\r\nwriteb(div_val, cec->reg + S5P_CEC_DIVISOR_0);\r\n}\r\nvoid s5p_cec_enable_rx(struct s5p_cec_dev *cec)\r\n{\r\nu8 reg;\r\nreg = readb(cec->reg + S5P_CEC_RX_CTRL);\r\nreg |= S5P_CEC_RX_CTRL_ENABLE;\r\nwriteb(reg, cec->reg + S5P_CEC_RX_CTRL);\r\n}\r\nvoid s5p_cec_mask_rx_interrupts(struct s5p_cec_dev *cec)\r\n{\r\nu8 reg;\r\nreg = readb(cec->reg + S5P_CEC_IRQ_MASK);\r\nreg |= S5P_CEC_IRQ_RX_DONE;\r\nreg |= S5P_CEC_IRQ_RX_ERROR;\r\nwriteb(reg, cec->reg + S5P_CEC_IRQ_MASK);\r\n}\r\nvoid s5p_cec_unmask_rx_interrupts(struct s5p_cec_dev *cec)\r\n{\r\nu8 reg;\r\nreg = readb(cec->reg + S5P_CEC_IRQ_MASK);\r\nreg &= ~S5P_CEC_IRQ_RX_DONE;\r\nreg &= ~S5P_CEC_IRQ_RX_ERROR;\r\nwriteb(reg, cec->reg + S5P_CEC_IRQ_MASK);\r\n}\r\nvoid s5p_cec_mask_tx_interrupts(struct s5p_cec_dev *cec)\r\n{\r\nu8 reg;\r\nreg = readb(cec->reg + S5P_CEC_IRQ_MASK);\r\nreg |= S5P_CEC_IRQ_TX_DONE;\r\nreg |= S5P_CEC_IRQ_TX_ERROR;\r\nwriteb(reg, cec->reg + S5P_CEC_IRQ_MASK);\r\n}\r\nvoid s5p_cec_unmask_tx_interrupts(struct s5p_cec_dev *cec)\r\n{\r\nu8 reg;\r\nreg = readb(cec->reg + S5P_CEC_IRQ_MASK);\r\nreg &= ~S5P_CEC_IRQ_TX_DONE;\r\nreg &= ~S5P_CEC_IRQ_TX_ERROR;\r\nwriteb(reg, cec->reg + S5P_CEC_IRQ_MASK);\r\n}\r\nvoid s5p_cec_reset(struct s5p_cec_dev *cec)\r\n{\r\nu8 reg;\r\nwriteb(S5P_CEC_RX_CTRL_RESET, cec->reg + S5P_CEC_RX_CTRL);\r\nwriteb(S5P_CEC_TX_CTRL_RESET, cec->reg + S5P_CEC_TX_CTRL);\r\nreg = readb(cec->reg + 0xc4);\r\nreg &= ~0x1;\r\nwriteb(reg, cec->reg + 0xc4);\r\n}\r\nvoid s5p_cec_tx_reset(struct s5p_cec_dev *cec)\r\n{\r\nwriteb(S5P_CEC_TX_CTRL_RESET, cec->reg + S5P_CEC_TX_CTRL);\r\n}\r\nvoid s5p_cec_rx_reset(struct s5p_cec_dev *cec)\r\n{\r\nu8 reg;\r\nwriteb(S5P_CEC_RX_CTRL_RESET, cec->reg + S5P_CEC_RX_CTRL);\r\nreg = readb(cec->reg + 0xc4);\r\nreg &= ~0x1;\r\nwriteb(reg, cec->reg + 0xc4);\r\n}\r\nvoid s5p_cec_threshold(struct s5p_cec_dev *cec)\r\n{\r\nwriteb(CEC_FILTER_THRESHOLD, cec->reg + S5P_CEC_RX_FILTER_TH);\r\nwriteb(0, cec->reg + S5P_CEC_RX_FILTER_CTRL);\r\n}\r\nvoid s5p_cec_copy_packet(struct s5p_cec_dev *cec, char *data,\r\nsize_t count, u8 retries)\r\n{\r\nint i = 0;\r\nu8 reg;\r\nwhile (i < count) {\r\nwriteb(data[i], cec->reg + (S5P_CEC_TX_BUFF0 + (i * 4)));\r\ni++;\r\n}\r\nwriteb(count, cec->reg + S5P_CEC_TX_BYTES);\r\nreg = readb(cec->reg + S5P_CEC_TX_CTRL);\r\nreg |= S5P_CEC_TX_CTRL_START;\r\nreg &= ~0x70;\r\nreg |= retries << 4;\r\nif ((data[0] & CEC_MESSAGE_BROADCAST_MASK) == CEC_MESSAGE_BROADCAST) {\r\ndev_dbg(cec->dev, "Broadcast");\r\nreg |= S5P_CEC_TX_CTRL_BCAST;\r\n} else {\r\ndev_dbg(cec->dev, "No Broadcast");\r\nreg &= ~S5P_CEC_TX_CTRL_BCAST;\r\n}\r\nwriteb(reg, cec->reg + S5P_CEC_TX_CTRL);\r\ndev_dbg(cec->dev, "cec-tx: cec count (%zu): %*ph", count,\r\n(int)count, data);\r\n}\r\nvoid s5p_cec_set_addr(struct s5p_cec_dev *cec, u32 addr)\r\n{\r\nwriteb(addr & 0x0F, cec->reg + S5P_CEC_LOGIC_ADDR);\r\n}\r\nu32 s5p_cec_get_status(struct s5p_cec_dev *cec)\r\n{\r\nu32 status = 0;\r\nstatus = readb(cec->reg + S5P_CEC_STATUS_0);\r\nstatus |= readb(cec->reg + S5P_CEC_STATUS_1) << 8;\r\nstatus |= readb(cec->reg + S5P_CEC_STATUS_2) << 16;\r\nstatus |= readb(cec->reg + S5P_CEC_STATUS_3) << 24;\r\ndev_dbg(cec->dev, "status = 0x%x!\n", status);\r\nreturn status;\r\n}\r\nvoid s5p_clr_pending_tx(struct s5p_cec_dev *cec)\r\n{\r\nwriteb(S5P_CEC_IRQ_TX_DONE | S5P_CEC_IRQ_TX_ERROR,\r\ncec->reg + S5P_CEC_IRQ_CLEAR);\r\n}\r\nvoid s5p_clr_pending_rx(struct s5p_cec_dev *cec)\r\n{\r\nwriteb(S5P_CEC_IRQ_RX_DONE | S5P_CEC_IRQ_RX_ERROR,\r\ncec->reg + S5P_CEC_IRQ_CLEAR);\r\n}\r\nvoid s5p_cec_get_rx_buf(struct s5p_cec_dev *cec, u32 size, u8 *buffer)\r\n{\r\nu32 i = 0;\r\nchar debug[40];\r\nwhile (i < size) {\r\nbuffer[i] = readb(cec->reg + S5P_CEC_RX_BUFF0 + (i * 4));\r\nsprintf(debug + i * 2, "%02x ", buffer[i]);\r\ni++;\r\n}\r\ndev_dbg(cec->dev, "cec-rx: cec size(%d): %s", size, debug);\r\n}
