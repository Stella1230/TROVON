struct fc_seq *fc_elsct_send(struct fc_lport *lport, u32 did,\r\nstruct fc_frame *fp, unsigned int op,\r\nvoid (*resp)(struct fc_seq *,\r\nstruct fc_frame *,\r\nvoid *),\r\nvoid *arg, u32 timer_msec)\r\n{\r\nenum fc_rctl r_ctl;\r\nenum fc_fh_type fh_type;\r\nint rc;\r\nif ((op >= ELS_LS_RJT) && (op <= ELS_AUTH_ELS))\r\nrc = fc_els_fill(lport, did, fp, op, &r_ctl, &fh_type);\r\nelse {\r\nrc = fc_ct_fill(lport, did, fp, op, &r_ctl, &fh_type, &did);\r\n}\r\nif (rc) {\r\nfc_frame_free(fp);\r\nreturn NULL;\r\n}\r\nfc_fill_fc_hdr(fp, r_ctl, did, lport->port_id, fh_type,\r\nFC_FCTL_REQ, 0);\r\nreturn fc_exch_seq_send(lport, fp, resp, NULL, arg, timer_msec);\r\n}\r\nint fc_elsct_init(struct fc_lport *lport)\r\n{\r\nif (!lport->tt.elsct_send)\r\nlport->tt.elsct_send = fc_elsct_send;\r\nreturn 0;\r\n}\r\nconst char *fc_els_resp_type(struct fc_frame *fp)\r\n{\r\nconst char *msg;\r\nstruct fc_frame_header *fh;\r\nstruct fc_ct_hdr *ct;\r\nif (IS_ERR(fp)) {\r\nswitch (-PTR_ERR(fp)) {\r\ncase FC_NO_ERR:\r\nmsg = "response no error";\r\nbreak;\r\ncase FC_EX_TIMEOUT:\r\nmsg = "response timeout";\r\nbreak;\r\ncase FC_EX_CLOSED:\r\nmsg = "response closed";\r\nbreak;\r\ndefault:\r\nmsg = "response unknown error";\r\nbreak;\r\n}\r\n} else {\r\nfh = fc_frame_header_get(fp);\r\nswitch (fh->fh_type) {\r\ncase FC_TYPE_ELS:\r\nswitch (fc_frame_payload_op(fp)) {\r\ncase ELS_LS_ACC:\r\nmsg = "accept";\r\nbreak;\r\ncase ELS_LS_RJT:\r\nmsg = "reject";\r\nbreak;\r\ndefault:\r\nmsg = "response unknown ELS";\r\nbreak;\r\n}\r\nbreak;\r\ncase FC_TYPE_CT:\r\nct = fc_frame_payload_get(fp, sizeof(*ct));\r\nif (ct) {\r\nswitch (ntohs(ct->ct_cmd)) {\r\ncase FC_FS_ACC:\r\nmsg = "CT accept";\r\nbreak;\r\ncase FC_FS_RJT:\r\nmsg = "CT reject";\r\nbreak;\r\ndefault:\r\nmsg = "response unknown CT";\r\nbreak;\r\n}\r\n} else {\r\nmsg = "short CT response";\r\n}\r\nbreak;\r\ndefault:\r\nmsg = "response not ELS or CT";\r\nbreak;\r\n}\r\n}\r\nreturn msg;\r\n}
