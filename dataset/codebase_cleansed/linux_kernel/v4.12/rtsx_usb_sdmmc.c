static inline struct device *sdmmc_dev(struct rtsx_usb_sdmmc *host)\r\n{\r\nreturn &(host->pdev->dev);\r\n}\r\nstatic inline void sd_clear_error(struct rtsx_usb_sdmmc *host)\r\n{\r\nstruct rtsx_ucr *ucr = host->ucr;\r\nrtsx_usb_ep0_write_register(ucr, CARD_STOP,\r\nSD_STOP | SD_CLR_ERR,\r\nSD_STOP | SD_CLR_ERR);\r\nrtsx_usb_clear_dma_err(ucr);\r\nrtsx_usb_clear_fsm_err(ucr);\r\n}\r\nstatic void sd_print_debug_regs(struct rtsx_usb_sdmmc *host)\r\n{\r\nstruct rtsx_ucr *ucr = host->ucr;\r\nu8 val = 0;\r\nrtsx_usb_ep0_read_register(ucr, SD_STAT1, &val);\r\ndev_dbg(sdmmc_dev(host), "SD_STAT1: 0x%x\n", val);\r\nrtsx_usb_ep0_read_register(ucr, SD_STAT2, &val);\r\ndev_dbg(sdmmc_dev(host), "SD_STAT2: 0x%x\n", val);\r\nrtsx_usb_ep0_read_register(ucr, SD_BUS_STAT, &val);\r\ndev_dbg(sdmmc_dev(host), "SD_BUS_STAT: 0x%x\n", val);\r\n}\r\nstatic int sd_read_data(struct rtsx_usb_sdmmc *host, struct mmc_command *cmd,\r\nu16 byte_cnt, u8 *buf, int buf_len, int timeout)\r\n{\r\nstruct rtsx_ucr *ucr = host->ucr;\r\nint err;\r\nu8 trans_mode;\r\nif (!buf)\r\nbuf_len = 0;\r\nrtsx_usb_init_cmd(ucr);\r\nif (cmd != NULL) {\r\ndev_dbg(sdmmc_dev(host), "%s: SD/MMC CMD%d\n", __func__\r\n, cmd->opcode);\r\nif (cmd->opcode == MMC_SEND_TUNING_BLOCK)\r\ntrans_mode = SD_TM_AUTO_TUNING;\r\nelse\r\ntrans_mode = SD_TM_NORMAL_READ;\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\r\nSD_CMD0, 0xFF, (u8)(cmd->opcode) | 0x40);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\r\nSD_CMD1, 0xFF, (u8)(cmd->arg >> 24));\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\r\nSD_CMD2, 0xFF, (u8)(cmd->arg >> 16));\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\r\nSD_CMD3, 0xFF, (u8)(cmd->arg >> 8));\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\r\nSD_CMD4, 0xFF, (u8)cmd->arg);\r\n} else {\r\ntrans_mode = SD_TM_AUTO_READ_3;\r\n}\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_BYTE_CNT_L, 0xFF, (u8)byte_cnt);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_BYTE_CNT_H,\r\n0xFF, (u8)(byte_cnt >> 8));\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_BLOCK_CNT_L, 0xFF, 1);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_BLOCK_CNT_H, 0xFF, 0);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_CFG2, 0xFF,\r\nSD_CALCULATE_CRC7 | SD_CHECK_CRC16 |\r\nSD_NO_WAIT_BUSY_END | SD_CHECK_CRC7 | SD_RSP_LEN_6);\r\nif (trans_mode != SD_TM_AUTO_TUNING)\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\r\nCARD_DATA_SOURCE, 0x01, PINGPONG_BUFFER);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_TRANSFER,\r\n0xFF, trans_mode | SD_TRANSFER_START);\r\nrtsx_usb_add_cmd(ucr, CHECK_REG_CMD, SD_TRANSFER,\r\nSD_TRANSFER_END, SD_TRANSFER_END);\r\nif (cmd != NULL) {\r\nrtsx_usb_add_cmd(ucr, READ_REG_CMD, SD_CMD1, 0, 0);\r\nrtsx_usb_add_cmd(ucr, READ_REG_CMD, SD_CMD2, 0, 0);\r\nrtsx_usb_add_cmd(ucr, READ_REG_CMD, SD_CMD3, 0, 0);\r\nrtsx_usb_add_cmd(ucr, READ_REG_CMD, SD_CMD4, 0, 0);\r\n}\r\nerr = rtsx_usb_send_cmd(ucr, MODE_CR, timeout);\r\nif (err) {\r\ndev_dbg(sdmmc_dev(host),\r\n"rtsx_usb_send_cmd failed (err = %d)\n", err);\r\nreturn err;\r\n}\r\nerr = rtsx_usb_get_rsp(ucr, !cmd ? 1 : 5, timeout);\r\nif (err || (ucr->rsp_buf[0] & SD_TRANSFER_ERR)) {\r\nsd_print_debug_regs(host);\r\nif (!err) {\r\ndev_dbg(sdmmc_dev(host),\r\n"Transfer failed (SD_TRANSFER = %02x)\n",\r\nucr->rsp_buf[0]);\r\nerr = -EIO;\r\n} else {\r\ndev_dbg(sdmmc_dev(host),\r\n"rtsx_usb_get_rsp failed (err = %d)\n", err);\r\n}\r\nreturn err;\r\n}\r\nif (cmd != NULL) {\r\ncmd->resp[0] = get_unaligned_be32(ucr->rsp_buf + 1);\r\ndev_dbg(sdmmc_dev(host), "cmd->resp[0] = 0x%08x\n",\r\ncmd->resp[0]);\r\n}\r\nif (buf && buf_len) {\r\nerr = rtsx_usb_read_ppbuf(ucr, buf, byte_cnt - (byte_cnt % 2));\r\nif (err) {\r\ndev_dbg(sdmmc_dev(host),\r\n"rtsx_usb_read_ppbuf failed (err = %d)\n", err);\r\nreturn err;\r\n}\r\nif (byte_cnt % 2)\r\nreturn rtsx_usb_read_register(ucr,\r\nPPBUF_BASE2 + byte_cnt,\r\nbuf + byte_cnt - 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sd_write_data(struct rtsx_usb_sdmmc *host, struct mmc_command *cmd,\r\nu16 byte_cnt, u8 *buf, int buf_len, int timeout)\r\n{\r\nstruct rtsx_ucr *ucr = host->ucr;\r\nint err;\r\nu8 trans_mode;\r\nif (!buf)\r\nbuf_len = 0;\r\nif (buf && buf_len) {\r\nerr = rtsx_usb_write_ppbuf(ucr, buf, buf_len);\r\nif (err) {\r\ndev_dbg(sdmmc_dev(host),\r\n"rtsx_usb_write_ppbuf failed (err = %d)\n",\r\nerr);\r\nreturn err;\r\n}\r\n}\r\ntrans_mode = (cmd != NULL) ? SD_TM_AUTO_WRITE_2 : SD_TM_AUTO_WRITE_3;\r\nrtsx_usb_init_cmd(ucr);\r\nif (cmd != NULL) {\r\ndev_dbg(sdmmc_dev(host), "%s: SD/MMC CMD%d\n", __func__,\r\ncmd->opcode);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\r\nSD_CMD0, 0xFF, (u8)(cmd->opcode) | 0x40);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\r\nSD_CMD1, 0xFF, (u8)(cmd->arg >> 24));\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\r\nSD_CMD2, 0xFF, (u8)(cmd->arg >> 16));\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\r\nSD_CMD3, 0xFF, (u8)(cmd->arg >> 8));\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\r\nSD_CMD4, 0xFF, (u8)cmd->arg);\r\n}\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_BYTE_CNT_L, 0xFF, (u8)byte_cnt);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_BYTE_CNT_H,\r\n0xFF, (u8)(byte_cnt >> 8));\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_BLOCK_CNT_L, 0xFF, 1);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_BLOCK_CNT_H, 0xFF, 0);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_CFG2, 0xFF,\r\nSD_CALCULATE_CRC7 | SD_CHECK_CRC16 |\r\nSD_NO_WAIT_BUSY_END | SD_CHECK_CRC7 | SD_RSP_LEN_6);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\r\nCARD_DATA_SOURCE, 0x01, PINGPONG_BUFFER);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_TRANSFER, 0xFF,\r\ntrans_mode | SD_TRANSFER_START);\r\nrtsx_usb_add_cmd(ucr, CHECK_REG_CMD, SD_TRANSFER,\r\nSD_TRANSFER_END, SD_TRANSFER_END);\r\nif (cmd != NULL) {\r\nrtsx_usb_add_cmd(ucr, READ_REG_CMD, SD_CMD1, 0, 0);\r\nrtsx_usb_add_cmd(ucr, READ_REG_CMD, SD_CMD2, 0, 0);\r\nrtsx_usb_add_cmd(ucr, READ_REG_CMD, SD_CMD3, 0, 0);\r\nrtsx_usb_add_cmd(ucr, READ_REG_CMD, SD_CMD4, 0, 0);\r\n}\r\nerr = rtsx_usb_send_cmd(ucr, MODE_CR, timeout);\r\nif (err) {\r\ndev_dbg(sdmmc_dev(host),\r\n"rtsx_usb_send_cmd failed (err = %d)\n", err);\r\nreturn err;\r\n}\r\nerr = rtsx_usb_get_rsp(ucr, !cmd ? 1 : 5, timeout);\r\nif (err) {\r\nsd_print_debug_regs(host);\r\ndev_dbg(sdmmc_dev(host),\r\n"rtsx_usb_get_rsp failed (err = %d)\n", err);\r\nreturn err;\r\n}\r\nif (cmd != NULL) {\r\ncmd->resp[0] = get_unaligned_be32(ucr->rsp_buf + 1);\r\ndev_dbg(sdmmc_dev(host), "cmd->resp[0] = 0x%08x\n",\r\ncmd->resp[0]);\r\n}\r\nreturn 0;\r\n}\r\nstatic void sd_send_cmd_get_rsp(struct rtsx_usb_sdmmc *host,\r\nstruct mmc_command *cmd)\r\n{\r\nstruct rtsx_ucr *ucr = host->ucr;\r\nu8 cmd_idx = (u8)cmd->opcode;\r\nu32 arg = cmd->arg;\r\nint err = 0;\r\nint timeout = 100;\r\nint i;\r\nu8 *ptr;\r\nint stat_idx = 0;\r\nint len = 2;\r\nu8 rsp_type;\r\ndev_dbg(sdmmc_dev(host), "%s: SD/MMC CMD %d, arg = 0x%08x\n",\r\n__func__, cmd_idx, arg);\r\nswitch (mmc_resp_type(cmd)) {\r\ncase MMC_RSP_NONE:\r\nrsp_type = SD_RSP_TYPE_R0;\r\nbreak;\r\ncase MMC_RSP_R1:\r\nrsp_type = SD_RSP_TYPE_R1;\r\nbreak;\r\ncase MMC_RSP_R1_NO_CRC:\r\nrsp_type = SD_RSP_TYPE_R1 | SD_NO_CHECK_CRC7;\r\nbreak;\r\ncase MMC_RSP_R1B:\r\nrsp_type = SD_RSP_TYPE_R1b;\r\nbreak;\r\ncase MMC_RSP_R2:\r\nrsp_type = SD_RSP_TYPE_R2;\r\nbreak;\r\ncase MMC_RSP_R3:\r\nrsp_type = SD_RSP_TYPE_R3;\r\nbreak;\r\ndefault:\r\ndev_dbg(sdmmc_dev(host), "cmd->flag is not valid\n");\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (rsp_type == SD_RSP_TYPE_R1b)\r\ntimeout = 3000;\r\nif (cmd->opcode == SD_SWITCH_VOLTAGE) {\r\nerr = rtsx_usb_write_register(ucr, SD_BUS_STAT,\r\nSD_CLK_TOGGLE_EN | SD_CLK_FORCE_STOP,\r\nSD_CLK_TOGGLE_EN);\r\nif (err)\r\ngoto out;\r\n}\r\nrtsx_usb_init_cmd(ucr);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_CMD0, 0xFF, 0x40 | cmd_idx);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_CMD1, 0xFF, (u8)(arg >> 24));\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_CMD2, 0xFF, (u8)(arg >> 16));\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_CMD3, 0xFF, (u8)(arg >> 8));\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_CMD4, 0xFF, (u8)arg);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_CFG2, 0xFF, rsp_type);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_DATA_SOURCE,\r\n0x01, PINGPONG_BUFFER);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_TRANSFER,\r\n0xFF, SD_TM_CMD_RSP | SD_TRANSFER_START);\r\nrtsx_usb_add_cmd(ucr, CHECK_REG_CMD, SD_TRANSFER,\r\nSD_TRANSFER_END | SD_STAT_IDLE,\r\nSD_TRANSFER_END | SD_STAT_IDLE);\r\nif (rsp_type == SD_RSP_TYPE_R2) {\r\nfor (i = PPBUF_BASE2; i < PPBUF_BASE2 + 16; i++)\r\nrtsx_usb_add_cmd(ucr, READ_REG_CMD, (u16)i, 0, 0);\r\nstat_idx = 16;\r\n} else if (rsp_type != SD_RSP_TYPE_R0) {\r\nfor (i = SD_CMD0; i <= SD_CMD4; i++)\r\nrtsx_usb_add_cmd(ucr, READ_REG_CMD, (u16)i, 0, 0);\r\nstat_idx = 5;\r\n}\r\nlen += stat_idx;\r\nrtsx_usb_add_cmd(ucr, READ_REG_CMD, SD_STAT1, 0, 0);\r\nerr = rtsx_usb_send_cmd(ucr, MODE_CR, 100);\r\nif (err) {\r\ndev_dbg(sdmmc_dev(host),\r\n"rtsx_usb_send_cmd error (err = %d)\n", err);\r\ngoto out;\r\n}\r\nerr = rtsx_usb_get_rsp(ucr, len, timeout);\r\nif (err || (ucr->rsp_buf[0] & SD_TRANSFER_ERR)) {\r\nsd_print_debug_regs(host);\r\nsd_clear_error(host);\r\nif (!err) {\r\ndev_dbg(sdmmc_dev(host),\r\n"Transfer failed (SD_TRANSFER = %02x)\n",\r\nucr->rsp_buf[0]);\r\nerr = -EIO;\r\n} else {\r\ndev_dbg(sdmmc_dev(host),\r\n"rtsx_usb_get_rsp failed (err = %d)\n", err);\r\n}\r\ngoto out;\r\n}\r\nif (rsp_type == SD_RSP_TYPE_R0) {\r\nerr = 0;\r\ngoto out;\r\n}\r\nptr = ucr->rsp_buf + 1;\r\nif ((ptr[0] & 0xC0) != 0) {\r\nerr = -EILSEQ;\r\ndev_dbg(sdmmc_dev(host), "Invalid response bit\n");\r\ngoto out;\r\n}\r\nif (!(rsp_type & SD_NO_CHECK_CRC7)) {\r\nif (ptr[stat_idx] & SD_CRC7_ERR) {\r\nerr = -EILSEQ;\r\ndev_dbg(sdmmc_dev(host), "CRC7 error\n");\r\ngoto out;\r\n}\r\n}\r\nif (rsp_type == SD_RSP_TYPE_R2) {\r\nptr[16] = 1;\r\nfor (i = 0; i < 4; i++) {\r\ncmd->resp[i] = get_unaligned_be32(ptr + 1 + i * 4);\r\ndev_dbg(sdmmc_dev(host), "cmd->resp[%d] = 0x%08x\n",\r\ni, cmd->resp[i]);\r\n}\r\n} else {\r\ncmd->resp[0] = get_unaligned_be32(ptr + 1);\r\ndev_dbg(sdmmc_dev(host), "cmd->resp[0] = 0x%08x\n",\r\ncmd->resp[0]);\r\n}\r\nout:\r\ncmd->error = err;\r\n}\r\nstatic int sd_rw_multi(struct rtsx_usb_sdmmc *host, struct mmc_request *mrq)\r\n{\r\nstruct rtsx_ucr *ucr = host->ucr;\r\nstruct mmc_data *data = mrq->data;\r\nint read = (data->flags & MMC_DATA_READ) ? 1 : 0;\r\nu8 cfg2, trans_mode;\r\nint err;\r\nu8 flag;\r\nsize_t data_len = data->blksz * data->blocks;\r\nunsigned int pipe;\r\nif (read) {\r\ndev_dbg(sdmmc_dev(host), "%s: read %zu bytes\n",\r\n__func__, data_len);\r\ncfg2 = SD_CALCULATE_CRC7 | SD_CHECK_CRC16 |\r\nSD_NO_WAIT_BUSY_END | SD_CHECK_CRC7 | SD_RSP_LEN_0;\r\ntrans_mode = SD_TM_AUTO_READ_3;\r\n} else {\r\ndev_dbg(sdmmc_dev(host), "%s: write %zu bytes\n",\r\n__func__, data_len);\r\ncfg2 = SD_NO_CALCULATE_CRC7 | SD_CHECK_CRC16 |\r\nSD_NO_WAIT_BUSY_END | SD_NO_CHECK_CRC7 | SD_RSP_LEN_0;\r\ntrans_mode = SD_TM_AUTO_WRITE_3;\r\n}\r\nrtsx_usb_init_cmd(ucr);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_BYTE_CNT_L, 0xFF, 0x00);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_BYTE_CNT_H, 0xFF, 0x02);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_BLOCK_CNT_L,\r\n0xFF, (u8)data->blocks);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_BLOCK_CNT_H,\r\n0xFF, (u8)(data->blocks >> 8));\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_DATA_SOURCE,\r\n0x01, RING_BUFFER);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MC_DMA_TC3,\r\n0xFF, (u8)(data_len >> 24));\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MC_DMA_TC2,\r\n0xFF, (u8)(data_len >> 16));\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MC_DMA_TC1,\r\n0xFF, (u8)(data_len >> 8));\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MC_DMA_TC0,\r\n0xFF, (u8)data_len);\r\nif (read) {\r\nflag = MODE_CDIR;\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MC_DMA_CTL,\r\n0x03 | DMA_PACK_SIZE_MASK,\r\nDMA_DIR_FROM_CARD | DMA_EN | DMA_512);\r\n} else {\r\nflag = MODE_CDOR;\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MC_DMA_CTL,\r\n0x03 | DMA_PACK_SIZE_MASK,\r\nDMA_DIR_TO_CARD | DMA_EN | DMA_512);\r\n}\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_CFG2, 0xFF, cfg2);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_TRANSFER, 0xFF,\r\ntrans_mode | SD_TRANSFER_START);\r\nrtsx_usb_add_cmd(ucr, CHECK_REG_CMD, SD_TRANSFER,\r\nSD_TRANSFER_END, SD_TRANSFER_END);\r\nerr = rtsx_usb_send_cmd(ucr, flag, 100);\r\nif (err)\r\nreturn err;\r\nif (read)\r\npipe = usb_rcvbulkpipe(ucr->pusb_dev, EP_BULK_IN);\r\nelse\r\npipe = usb_sndbulkpipe(ucr->pusb_dev, EP_BULK_OUT);\r\nerr = rtsx_usb_transfer_data(ucr, pipe, data->sg, data_len,\r\ndata->sg_len, NULL, 10000);\r\nif (err) {\r\ndev_dbg(sdmmc_dev(host), "rtsx_usb_transfer_data error %d\n"\r\n, err);\r\nsd_clear_error(host);\r\nreturn err;\r\n}\r\nreturn rtsx_usb_get_rsp(ucr, 1, 2000);\r\n}\r\nstatic inline void sd_enable_initial_mode(struct rtsx_usb_sdmmc *host)\r\n{\r\nrtsx_usb_write_register(host->ucr, SD_CFG1,\r\nSD_CLK_DIVIDE_MASK, SD_CLK_DIVIDE_128);\r\n}\r\nstatic inline void sd_disable_initial_mode(struct rtsx_usb_sdmmc *host)\r\n{\r\nrtsx_usb_write_register(host->ucr, SD_CFG1,\r\nSD_CLK_DIVIDE_MASK, SD_CLK_DIVIDE_0);\r\n}\r\nstatic void sd_normal_rw(struct rtsx_usb_sdmmc *host,\r\nstruct mmc_request *mrq)\r\n{\r\nstruct mmc_command *cmd = mrq->cmd;\r\nstruct mmc_data *data = mrq->data;\r\nu8 *buf;\r\nbuf = kzalloc(data->blksz, GFP_NOIO);\r\nif (!buf) {\r\ncmd->error = -ENOMEM;\r\nreturn;\r\n}\r\nif (data->flags & MMC_DATA_READ) {\r\nif (host->initial_mode)\r\nsd_disable_initial_mode(host);\r\ncmd->error = sd_read_data(host, cmd, (u16)data->blksz, buf,\r\ndata->blksz, 200);\r\nif (host->initial_mode)\r\nsd_enable_initial_mode(host);\r\nsg_copy_from_buffer(data->sg, data->sg_len, buf, data->blksz);\r\n} else {\r\nsg_copy_to_buffer(data->sg, data->sg_len, buf, data->blksz);\r\ncmd->error = sd_write_data(host, cmd, (u16)data->blksz, buf,\r\ndata->blksz, 200);\r\n}\r\nkfree(buf);\r\n}\r\nstatic int sd_change_phase(struct rtsx_usb_sdmmc *host, u8 sample_point, int tx)\r\n{\r\nstruct rtsx_ucr *ucr = host->ucr;\r\nint err;\r\ndev_dbg(sdmmc_dev(host), "%s: %s sample_point = %d\n",\r\n__func__, tx ? "TX" : "RX", sample_point);\r\nrtsx_usb_init_cmd(ucr);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CLK_DIV, CLK_CHANGE, CLK_CHANGE);\r\nif (tx)\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_VPCLK0_CTL,\r\n0x0F, sample_point);\r\nelse\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_VPCLK1_CTL,\r\n0x0F, sample_point);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_VPCLK0_CTL, PHASE_NOT_RESET, 0);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_VPCLK0_CTL,\r\nPHASE_NOT_RESET, PHASE_NOT_RESET);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CLK_DIV, CLK_CHANGE, 0);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_CFG1, SD_ASYNC_FIFO_RST, 0);\r\nerr = rtsx_usb_send_cmd(ucr, MODE_C, 100);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic inline u32 get_phase_point(u32 phase_map, unsigned int idx)\r\n{\r\nidx &= MAX_PHASE;\r\nreturn phase_map & (1 << idx);\r\n}\r\nstatic int get_phase_len(u32 phase_map, unsigned int idx)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_PHASE + 1; i++) {\r\nif (get_phase_point(phase_map, idx + i) == 0)\r\nreturn i;\r\n}\r\nreturn MAX_PHASE + 1;\r\n}\r\nstatic u8 sd_search_final_phase(struct rtsx_usb_sdmmc *host, u32 phase_map)\r\n{\r\nint start = 0, len = 0;\r\nint start_final = 0, len_final = 0;\r\nu8 final_phase = 0xFF;\r\nif (phase_map == 0) {\r\ndev_dbg(sdmmc_dev(host), "Phase: [map:%x]\n", phase_map);\r\nreturn final_phase;\r\n}\r\nwhile (start < MAX_PHASE + 1) {\r\nlen = get_phase_len(phase_map, start);\r\nif (len_final < len) {\r\nstart_final = start;\r\nlen_final = len;\r\n}\r\nstart += len ? len : 1;\r\n}\r\nfinal_phase = (start_final + len_final / 2) & MAX_PHASE;\r\ndev_dbg(sdmmc_dev(host), "Phase: [map:%x] [maxlen:%d] [final:%d]\n",\r\nphase_map, len_final, final_phase);\r\nreturn final_phase;\r\n}\r\nstatic void sd_wait_data_idle(struct rtsx_usb_sdmmc *host)\r\n{\r\nint err, i;\r\nu8 val = 0;\r\nfor (i = 0; i < 100; i++) {\r\nerr = rtsx_usb_ep0_read_register(host->ucr,\r\nSD_DATA_STATE, &val);\r\nif (val & SD_DATA_IDLE)\r\nreturn;\r\nusleep_range(100, 1000);\r\n}\r\n}\r\nstatic int sd_tuning_rx_cmd(struct rtsx_usb_sdmmc *host,\r\nu8 opcode, u8 sample_point)\r\n{\r\nint err;\r\nstruct mmc_command cmd = {};\r\nerr = sd_change_phase(host, sample_point, 0);\r\nif (err)\r\nreturn err;\r\ncmd.opcode = MMC_SEND_TUNING_BLOCK;\r\nerr = sd_read_data(host, &cmd, 0x40, NULL, 0, 100);\r\nif (err) {\r\nsd_wait_data_idle(host);\r\nsd_clear_error(host);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sd_tuning_phase(struct rtsx_usb_sdmmc *host,\r\nu8 opcode, u16 *phase_map)\r\n{\r\nint err, i;\r\nu16 raw_phase_map = 0;\r\nfor (i = MAX_PHASE; i >= 0; i--) {\r\nerr = sd_tuning_rx_cmd(host, opcode, (u8)i);\r\nif (!err)\r\nraw_phase_map |= 1 << i;\r\n}\r\nif (phase_map)\r\n*phase_map = raw_phase_map;\r\n}\r\nstatic int sd_tuning_rx(struct rtsx_usb_sdmmc *host, u8 opcode)\r\n{\r\nint err, i;\r\nu16 raw_phase_map[RX_TUNING_CNT] = {0}, phase_map;\r\nu8 final_phase;\r\nerr = sd_change_phase(host, 0x01, 1);\r\nif (err) {\r\ndev_dbg(sdmmc_dev(host), "TX phase setting failed\n");\r\nreturn err;\r\n}\r\nfor (i = 0; i < RX_TUNING_CNT; i++) {\r\nsd_tuning_phase(host, opcode, &(raw_phase_map[i]));\r\nif (raw_phase_map[i] == 0)\r\nbreak;\r\n}\r\nphase_map = 0xFFFF;\r\nfor (i = 0; i < RX_TUNING_CNT; i++) {\r\ndev_dbg(sdmmc_dev(host), "RX raw_phase_map[%d] = 0x%04x\n",\r\ni, raw_phase_map[i]);\r\nphase_map &= raw_phase_map[i];\r\n}\r\ndev_dbg(sdmmc_dev(host), "RX phase_map = 0x%04x\n", phase_map);\r\nif (phase_map) {\r\nfinal_phase = sd_search_final_phase(host, phase_map);\r\nif (final_phase == 0xFF)\r\nreturn -EINVAL;\r\nerr = sd_change_phase(host, final_phase, 0);\r\nif (err)\r\nreturn err;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sdmmc_get_ro(struct mmc_host *mmc)\r\n{\r\nstruct rtsx_usb_sdmmc *host = mmc_priv(mmc);\r\nstruct rtsx_ucr *ucr = host->ucr;\r\nint err;\r\nu16 val;\r\nif (host->host_removal)\r\nreturn -ENOMEDIUM;\r\nmutex_lock(&ucr->dev_mutex);\r\nerr = rtsx_usb_get_card_status(ucr, &val);\r\nmutex_unlock(&ucr->dev_mutex);\r\nif (err)\r\nreturn 0;\r\nif (val & SD_WP)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int sdmmc_get_cd(struct mmc_host *mmc)\r\n{\r\nstruct rtsx_usb_sdmmc *host = mmc_priv(mmc);\r\nstruct rtsx_ucr *ucr = host->ucr;\r\nint err;\r\nu16 val;\r\nif (host->host_removal)\r\nreturn -ENOMEDIUM;\r\nmutex_lock(&ucr->dev_mutex);\r\nerr = rtsx_usb_get_card_status(ucr, &val);\r\nmutex_unlock(&ucr->dev_mutex);\r\nif (err)\r\ngoto no_card;\r\nif (val & SD_CD) {\r\nhost->card_exist = true;\r\nreturn 1;\r\n}\r\nno_card:\r\nhost->card_exist = false;\r\nreturn 0;\r\n}\r\nstatic void sdmmc_request(struct mmc_host *mmc, struct mmc_request *mrq)\r\n{\r\nstruct rtsx_usb_sdmmc *host = mmc_priv(mmc);\r\nstruct rtsx_ucr *ucr = host->ucr;\r\nstruct mmc_command *cmd = mrq->cmd;\r\nstruct mmc_data *data = mrq->data;\r\nunsigned int data_size = 0;\r\ndev_dbg(sdmmc_dev(host), "%s\n", __func__);\r\nif (host->host_removal) {\r\ncmd->error = -ENOMEDIUM;\r\ngoto finish;\r\n}\r\nif ((!host->card_exist)) {\r\ncmd->error = -ENOMEDIUM;\r\ngoto finish_detect_card;\r\n}\r\nif (cmd->opcode == SD_IO_SEND_OP_COND ||\r\ncmd->opcode == SD_IO_RW_DIRECT ||\r\ncmd->opcode == SD_IO_RW_EXTENDED) {\r\ncmd->error = -EINVAL;\r\ngoto finish;\r\n}\r\nmutex_lock(&ucr->dev_mutex);\r\nmutex_lock(&host->host_mutex);\r\nhost->mrq = mrq;\r\nmutex_unlock(&host->host_mutex);\r\nif (mrq->data)\r\ndata_size = data->blocks * data->blksz;\r\nif (!data_size) {\r\nsd_send_cmd_get_rsp(host, cmd);\r\n} else if ((!(data_size % 512) && cmd->opcode != MMC_SEND_EXT_CSD) ||\r\nmmc_op_multi(cmd->opcode)) {\r\nsd_send_cmd_get_rsp(host, cmd);\r\nif (!cmd->error) {\r\nsd_rw_multi(host, mrq);\r\nif (mmc_op_multi(cmd->opcode) && mrq->stop) {\r\nsd_send_cmd_get_rsp(host, mrq->stop);\r\nrtsx_usb_write_register(ucr, MC_FIFO_CTL,\r\nFIFO_FLUSH, FIFO_FLUSH);\r\n}\r\n}\r\n} else {\r\nsd_normal_rw(host, mrq);\r\n}\r\nif (mrq->data) {\r\nif (cmd->error || data->error)\r\ndata->bytes_xfered = 0;\r\nelse\r\ndata->bytes_xfered = data->blocks * data->blksz;\r\n}\r\nmutex_unlock(&ucr->dev_mutex);\r\nfinish_detect_card:\r\nif (cmd->error) {\r\nsdmmc_get_cd(mmc);\r\ndev_dbg(sdmmc_dev(host), "cmd->error = %d\n", cmd->error);\r\n}\r\nfinish:\r\nmutex_lock(&host->host_mutex);\r\nhost->mrq = NULL;\r\nmutex_unlock(&host->host_mutex);\r\nmmc_request_done(mmc, mrq);\r\n}\r\nstatic int sd_set_bus_width(struct rtsx_usb_sdmmc *host,\r\nunsigned char bus_width)\r\n{\r\nint err = 0;\r\nu8 width[] = {\r\n[MMC_BUS_WIDTH_1] = SD_BUS_WIDTH_1BIT,\r\n[MMC_BUS_WIDTH_4] = SD_BUS_WIDTH_4BIT,\r\n[MMC_BUS_WIDTH_8] = SD_BUS_WIDTH_8BIT,\r\n};\r\nif (bus_width <= MMC_BUS_WIDTH_8)\r\nerr = rtsx_usb_write_register(host->ucr, SD_CFG1,\r\n0x03, width[bus_width]);\r\nreturn err;\r\n}\r\nstatic int sd_pull_ctl_disable_lqfp48(struct rtsx_ucr *ucr)\r\n{\r\nrtsx_usb_init_cmd(ucr);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL1, 0xFF, 0x55);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL2, 0xFF, 0x55);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL3, 0xFF, 0x95);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL4, 0xFF, 0x55);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL5, 0xFF, 0x55);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL6, 0xFF, 0xA5);\r\nreturn rtsx_usb_send_cmd(ucr, MODE_C, 100);\r\n}\r\nstatic int sd_pull_ctl_disable_qfn24(struct rtsx_ucr *ucr)\r\n{\r\nrtsx_usb_init_cmd(ucr);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL1, 0xFF, 0x65);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL2, 0xFF, 0x55);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL3, 0xFF, 0x95);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL4, 0xFF, 0x55);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL5, 0xFF, 0x56);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL6, 0xFF, 0x59);\r\nreturn rtsx_usb_send_cmd(ucr, MODE_C, 100);\r\n}\r\nstatic int sd_pull_ctl_enable_lqfp48(struct rtsx_ucr *ucr)\r\n{\r\nrtsx_usb_init_cmd(ucr);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL1, 0xFF, 0xAA);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL2, 0xFF, 0xAA);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL3, 0xFF, 0xA9);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL4, 0xFF, 0x55);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL5, 0xFF, 0x55);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL6, 0xFF, 0xA5);\r\nreturn rtsx_usb_send_cmd(ucr, MODE_C, 100);\r\n}\r\nstatic int sd_pull_ctl_enable_qfn24(struct rtsx_ucr *ucr)\r\n{\r\nrtsx_usb_init_cmd(ucr);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL1, 0xFF, 0xA5);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL2, 0xFF, 0x9A);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL3, 0xFF, 0xA5);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL4, 0xFF, 0x9A);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL5, 0xFF, 0x65);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL6, 0xFF, 0x5A);\r\nreturn rtsx_usb_send_cmd(ucr, MODE_C, 100);\r\n}\r\nstatic int sd_power_on(struct rtsx_usb_sdmmc *host)\r\n{\r\nstruct rtsx_ucr *ucr = host->ucr;\r\nint err;\r\ndev_dbg(sdmmc_dev(host), "%s\n", __func__);\r\nrtsx_usb_init_cmd(ucr);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_SELECT, 0x07, SD_MOD_SEL);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_SHARE_MODE,\r\nCARD_SHARE_MASK, CARD_SHARE_SD);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_CLK_EN,\r\nSD_CLK_EN, SD_CLK_EN);\r\nerr = rtsx_usb_send_cmd(ucr, MODE_C, 100);\r\nif (err)\r\nreturn err;\r\nif (CHECK_PKG(ucr, LQFP48))\r\nerr = sd_pull_ctl_enable_lqfp48(ucr);\r\nelse\r\nerr = sd_pull_ctl_enable_qfn24(ucr);\r\nif (err)\r\nreturn err;\r\nerr = rtsx_usb_write_register(ucr, CARD_PWR_CTL,\r\nPOWER_MASK, PARTIAL_POWER_ON);\r\nif (err)\r\nreturn err;\r\nusleep_range(800, 1000);\r\nrtsx_usb_init_cmd(ucr);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PWR_CTL,\r\nPOWER_MASK|LDO3318_PWR_MASK, POWER_ON|LDO_ON);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_OE,\r\nSD_OUTPUT_EN, SD_OUTPUT_EN);\r\nreturn rtsx_usb_send_cmd(ucr, MODE_C, 100);\r\n}\r\nstatic int sd_power_off(struct rtsx_usb_sdmmc *host)\r\n{\r\nstruct rtsx_ucr *ucr = host->ucr;\r\nint err;\r\ndev_dbg(sdmmc_dev(host), "%s\n", __func__);\r\nrtsx_usb_init_cmd(ucr);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_CLK_EN, SD_CLK_EN, 0);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_OE, SD_OUTPUT_EN, 0);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PWR_CTL,\r\nPOWER_MASK, POWER_OFF);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PWR_CTL,\r\nPOWER_MASK|LDO3318_PWR_MASK, POWER_OFF|LDO_SUSPEND);\r\nerr = rtsx_usb_send_cmd(ucr, MODE_C, 100);\r\nif (err)\r\nreturn err;\r\nif (CHECK_PKG(ucr, LQFP48))\r\nreturn sd_pull_ctl_disable_lqfp48(ucr);\r\nreturn sd_pull_ctl_disable_qfn24(ucr);\r\n}\r\nstatic int sd_set_power_mode(struct rtsx_usb_sdmmc *host,\r\nunsigned char power_mode)\r\n{\r\nint err;\r\nif (power_mode != MMC_POWER_OFF)\r\npower_mode = MMC_POWER_ON;\r\nif (power_mode == host->power_mode)\r\nreturn 0;\r\nif (power_mode == MMC_POWER_OFF) {\r\nerr = sd_power_off(host);\r\npm_runtime_put(sdmmc_dev(host));\r\n} else {\r\npm_runtime_get_sync(sdmmc_dev(host));\r\nerr = sd_power_on(host);\r\n}\r\nif (!err)\r\nhost->power_mode = power_mode;\r\nreturn err;\r\n}\r\nstatic int sd_set_timing(struct rtsx_usb_sdmmc *host,\r\nunsigned char timing, bool *ddr_mode)\r\n{\r\nstruct rtsx_ucr *ucr = host->ucr;\r\nint err;\r\n*ddr_mode = false;\r\nrtsx_usb_init_cmd(ucr);\r\nswitch (timing) {\r\ncase MMC_TIMING_UHS_SDR104:\r\ncase MMC_TIMING_UHS_SDR50:\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_CFG1,\r\n0x0C | SD_ASYNC_FIFO_RST,\r\nSD_30_MODE | SD_ASYNC_FIFO_RST);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_CLK_SOURCE, 0xFF,\r\nCRC_VAR_CLK0 | SD30_FIX_CLK | SAMPLE_VAR_CLK1);\r\nbreak;\r\ncase MMC_TIMING_UHS_DDR50:\r\n*ddr_mode = true;\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_CFG1,\r\n0x0C | SD_ASYNC_FIFO_RST,\r\nSD_DDR_MODE | SD_ASYNC_FIFO_RST);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_CLK_SOURCE, 0xFF,\r\nCRC_VAR_CLK0 | SD30_FIX_CLK | SAMPLE_VAR_CLK1);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_PUSH_POINT_CTL,\r\nDDR_VAR_TX_CMD_DAT, DDR_VAR_TX_CMD_DAT);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_SAMPLE_POINT_CTL,\r\nDDR_VAR_RX_DAT | DDR_VAR_RX_CMD,\r\nDDR_VAR_RX_DAT | DDR_VAR_RX_CMD);\r\nbreak;\r\ncase MMC_TIMING_MMC_HS:\r\ncase MMC_TIMING_SD_HS:\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_CFG1,\r\n0x0C, SD_20_MODE);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_CLK_SOURCE, 0xFF,\r\nCRC_FIX_CLK | SD30_VAR_CLK0 | SAMPLE_VAR_CLK1);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_PUSH_POINT_CTL,\r\nSD20_TX_SEL_MASK, SD20_TX_14_AHEAD);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_SAMPLE_POINT_CTL,\r\nSD20_RX_SEL_MASK, SD20_RX_14_DELAY);\r\nbreak;\r\ndefault:\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\r\nSD_CFG1, 0x0C, SD_20_MODE);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_CLK_SOURCE, 0xFF,\r\nCRC_FIX_CLK | SD30_VAR_CLK0 | SAMPLE_VAR_CLK1);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\r\nSD_PUSH_POINT_CTL, 0xFF, 0);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_SAMPLE_POINT_CTL,\r\nSD20_RX_SEL_MASK, SD20_RX_POS_EDGE);\r\nbreak;\r\n}\r\nerr = rtsx_usb_send_cmd(ucr, MODE_C, 100);\r\nreturn err;\r\n}\r\nstatic void sdmmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct rtsx_usb_sdmmc *host = mmc_priv(mmc);\r\nstruct rtsx_ucr *ucr = host->ucr;\r\ndev_dbg(sdmmc_dev(host), "%s\n", __func__);\r\nmutex_lock(&ucr->dev_mutex);\r\nsd_set_power_mode(host, ios->power_mode);\r\nsd_set_bus_width(host, ios->bus_width);\r\nsd_set_timing(host, ios->timing, &host->ddr_mode);\r\nhost->vpclk = false;\r\nhost->double_clk = true;\r\nswitch (ios->timing) {\r\ncase MMC_TIMING_UHS_SDR104:\r\ncase MMC_TIMING_UHS_SDR50:\r\nhost->ssc_depth = SSC_DEPTH_2M;\r\nhost->vpclk = true;\r\nhost->double_clk = false;\r\nbreak;\r\ncase MMC_TIMING_UHS_DDR50:\r\ncase MMC_TIMING_UHS_SDR25:\r\nhost->ssc_depth = SSC_DEPTH_1M;\r\nbreak;\r\ndefault:\r\nhost->ssc_depth = SSC_DEPTH_512K;\r\nbreak;\r\n}\r\nhost->initial_mode = (ios->clock <= 1000000) ? true : false;\r\nhost->clock = ios->clock;\r\nrtsx_usb_switch_clock(host->ucr, host->clock, host->ssc_depth,\r\nhost->initial_mode, host->double_clk, host->vpclk);\r\nmutex_unlock(&ucr->dev_mutex);\r\ndev_dbg(sdmmc_dev(host), "%s end\n", __func__);\r\n}\r\nstatic int sdmmc_switch_voltage(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct rtsx_usb_sdmmc *host = mmc_priv(mmc);\r\nstruct rtsx_ucr *ucr = host->ucr;\r\nint err = 0;\r\ndev_dbg(sdmmc_dev(host), "%s: signal_voltage = %d\n",\r\n__func__, ios->signal_voltage);\r\nif (host->host_removal)\r\nreturn -ENOMEDIUM;\r\nif (ios->signal_voltage == MMC_SIGNAL_VOLTAGE_120)\r\nreturn -EPERM;\r\nmutex_lock(&ucr->dev_mutex);\r\nerr = rtsx_usb_card_exclusive_check(ucr, RTSX_USB_SD_CARD);\r\nif (err) {\r\nmutex_unlock(&ucr->dev_mutex);\r\nreturn err;\r\n}\r\nrtsx_usb_init_cmd(ucr);\r\nif (ios->signal_voltage == MMC_SIGNAL_VOLTAGE_330) {\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_PAD_CTL,\r\nSD_IO_USING_1V8, SD_IO_USING_3V3);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, LDO_POWER_CFG,\r\nTUNE_SD18_MASK, TUNE_SD18_3V3);\r\n} else {\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_BUS_STAT,\r\nSD_CLK_TOGGLE_EN | SD_CLK_FORCE_STOP,\r\nSD_CLK_FORCE_STOP);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_PAD_CTL,\r\nSD_IO_USING_1V8, SD_IO_USING_1V8);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, LDO_POWER_CFG,\r\nTUNE_SD18_MASK, TUNE_SD18_1V8);\r\n}\r\nerr = rtsx_usb_send_cmd(ucr, MODE_C, 100);\r\nmutex_unlock(&ucr->dev_mutex);\r\nreturn err;\r\n}\r\nstatic int sdmmc_card_busy(struct mmc_host *mmc)\r\n{\r\nstruct rtsx_usb_sdmmc *host = mmc_priv(mmc);\r\nstruct rtsx_ucr *ucr = host->ucr;\r\nint err;\r\nu8 stat;\r\nu8 mask = SD_DAT3_STATUS | SD_DAT2_STATUS | SD_DAT1_STATUS\r\n| SD_DAT0_STATUS;\r\ndev_dbg(sdmmc_dev(host), "%s\n", __func__);\r\nmutex_lock(&ucr->dev_mutex);\r\nerr = rtsx_usb_write_register(ucr, SD_BUS_STAT,\r\nSD_CLK_TOGGLE_EN | SD_CLK_FORCE_STOP,\r\nSD_CLK_TOGGLE_EN);\r\nif (err)\r\ngoto out;\r\nmdelay(1);\r\nerr = rtsx_usb_read_register(ucr, SD_BUS_STAT, &stat);\r\nif (err)\r\ngoto out;\r\nerr = rtsx_usb_write_register(ucr, SD_BUS_STAT,\r\nSD_CLK_TOGGLE_EN | SD_CLK_FORCE_STOP, 0);\r\nout:\r\nmutex_unlock(&ucr->dev_mutex);\r\nif (err)\r\nreturn err;\r\nif ((stat & mask) != mask)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int sdmmc_execute_tuning(struct mmc_host *mmc, u32 opcode)\r\n{\r\nstruct rtsx_usb_sdmmc *host = mmc_priv(mmc);\r\nstruct rtsx_ucr *ucr = host->ucr;\r\nint err = 0;\r\nif (host->host_removal)\r\nreturn -ENOMEDIUM;\r\nmutex_lock(&ucr->dev_mutex);\r\nif (!host->ddr_mode)\r\nerr = sd_tuning_rx(host, MMC_SEND_TUNING_BLOCK);\r\nmutex_unlock(&ucr->dev_mutex);\r\nreturn err;\r\n}\r\nstatic void rtsx_usb_led_control(struct led_classdev *led,\r\nenum led_brightness brightness)\r\n{\r\nstruct rtsx_usb_sdmmc *host = container_of(led,\r\nstruct rtsx_usb_sdmmc, led);\r\nif (host->host_removal)\r\nreturn;\r\nhost->led.brightness = brightness;\r\nschedule_work(&host->led_work);\r\n}\r\nstatic void rtsx_usb_update_led(struct work_struct *work)\r\n{\r\nstruct rtsx_usb_sdmmc *host =\r\ncontainer_of(work, struct rtsx_usb_sdmmc, led_work);\r\nstruct rtsx_ucr *ucr = host->ucr;\r\npm_runtime_get_sync(sdmmc_dev(host));\r\nmutex_lock(&ucr->dev_mutex);\r\nif (host->led.brightness == LED_OFF)\r\nrtsx_usb_turn_off_led(ucr);\r\nelse\r\nrtsx_usb_turn_on_led(ucr);\r\nmutex_unlock(&ucr->dev_mutex);\r\npm_runtime_put(sdmmc_dev(host));\r\n}\r\nstatic void rtsx_usb_init_host(struct rtsx_usb_sdmmc *host)\r\n{\r\nstruct mmc_host *mmc = host->mmc;\r\nmmc->f_min = 250000;\r\nmmc->f_max = 208000000;\r\nmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34 | MMC_VDD_165_195;\r\nmmc->caps = MMC_CAP_4_BIT_DATA | MMC_CAP_SD_HIGHSPEED |\r\nMMC_CAP_MMC_HIGHSPEED | MMC_CAP_BUS_WIDTH_TEST |\r\nMMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 | MMC_CAP_UHS_SDR50 |\r\nMMC_CAP_NEEDS_POLL;\r\nmmc->caps2 = MMC_CAP2_NO_PRESCAN_POWERUP | MMC_CAP2_FULL_PWR_CYCLE;\r\nmmc->max_current_330 = 400;\r\nmmc->max_current_180 = 800;\r\nmmc->ops = &rtsx_usb_sdmmc_ops;\r\nmmc->max_segs = 256;\r\nmmc->max_seg_size = 65536;\r\nmmc->max_blk_size = 512;\r\nmmc->max_blk_count = 65535;\r\nmmc->max_req_size = 524288;\r\nhost->power_mode = MMC_POWER_OFF;\r\n}\r\nstatic int rtsx_usb_sdmmc_drv_probe(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc;\r\nstruct rtsx_usb_sdmmc *host;\r\nstruct rtsx_ucr *ucr;\r\n#ifdef RTSX_USB_USE_LEDS_CLASS\r\nint err;\r\n#endif\r\nucr = usb_get_intfdata(to_usb_interface(pdev->dev.parent));\r\nif (!ucr)\r\nreturn -ENXIO;\r\ndev_dbg(&(pdev->dev), ": Realtek USB SD/MMC controller found\n");\r\nmmc = mmc_alloc_host(sizeof(*host), &pdev->dev);\r\nif (!mmc)\r\nreturn -ENOMEM;\r\nhost = mmc_priv(mmc);\r\nhost->ucr = ucr;\r\nhost->mmc = mmc;\r\nhost->pdev = pdev;\r\nplatform_set_drvdata(pdev, host);\r\nmutex_init(&host->host_mutex);\r\nrtsx_usb_init_host(host);\r\npm_runtime_use_autosuspend(&pdev->dev);\r\npm_runtime_set_autosuspend_delay(&pdev->dev, 50);\r\npm_runtime_enable(&pdev->dev);\r\n#ifdef RTSX_USB_USE_LEDS_CLASS\r\nsnprintf(host->led_name, sizeof(host->led_name),\r\n"%s::", mmc_hostname(mmc));\r\nhost->led.name = host->led_name;\r\nhost->led.brightness = LED_OFF;\r\nhost->led.default_trigger = mmc_hostname(mmc);\r\nhost->led.brightness_set = rtsx_usb_led_control;\r\nerr = led_classdev_register(mmc_dev(mmc), &host->led);\r\nif (err)\r\ndev_err(&(pdev->dev),\r\n"Failed to register LED device: %d\n", err);\r\nINIT_WORK(&host->led_work, rtsx_usb_update_led);\r\n#endif\r\nmmc_add_host(mmc);\r\nreturn 0;\r\n}\r\nstatic int rtsx_usb_sdmmc_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct rtsx_usb_sdmmc *host = platform_get_drvdata(pdev);\r\nstruct mmc_host *mmc;\r\nif (!host)\r\nreturn 0;\r\nmmc = host->mmc;\r\nhost->host_removal = true;\r\nmutex_lock(&host->host_mutex);\r\nif (host->mrq) {\r\ndev_dbg(&(pdev->dev),\r\n"%s: Controller removed during transfer\n",\r\nmmc_hostname(mmc));\r\nhost->mrq->cmd->error = -ENOMEDIUM;\r\nif (host->mrq->stop)\r\nhost->mrq->stop->error = -ENOMEDIUM;\r\nmmc_request_done(mmc, host->mrq);\r\n}\r\nmutex_unlock(&host->host_mutex);\r\nmmc_remove_host(mmc);\r\n#ifdef RTSX_USB_USE_LEDS_CLASS\r\ncancel_work_sync(&host->led_work);\r\nled_classdev_unregister(&host->led);\r\n#endif\r\nmmc_free_host(mmc);\r\npm_runtime_disable(&pdev->dev);\r\npm_runtime_dont_use_autosuspend(&pdev->dev);\r\nplatform_set_drvdata(pdev, NULL);\r\ndev_dbg(&(pdev->dev),\r\n": Realtek USB SD/MMC module has been removed\n");\r\nreturn 0;\r\n}
