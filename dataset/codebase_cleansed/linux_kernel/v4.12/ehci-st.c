static int st_ehci_platform_reset(struct usb_hcd *hcd)\r\n{\r\nstruct platform_device *pdev = to_platform_device(hcd->self.controller);\r\nstruct usb_ehci_pdata *pdata = dev_get_platdata(&pdev->dev);\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nu32 threshold;\r\nthreshold = 128 | (128 << 16);\r\nwritel(threshold, hcd->regs + AHB2STBUS_INSREG01);\r\nehci->caps = hcd->regs + pdata->caps_offset;\r\nreturn ehci_setup(hcd);\r\n}\r\nstatic int st_ehci_platform_power_on(struct platform_device *dev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(dev);\r\nstruct st_ehci_platform_priv *priv = hcd_to_ehci_priv(hcd);\r\nint clk, ret;\r\nret = reset_control_deassert(priv->pwr);\r\nif (ret)\r\nreturn ret;\r\nret = reset_control_deassert(priv->rst);\r\nif (ret)\r\ngoto err_assert_power;\r\nif (priv->clk48) {\r\nret = clk_set_rate(priv->clk48, 48000000);\r\nif (ret)\r\ngoto err_assert_reset;\r\n}\r\nfor (clk = 0; clk < USB_MAX_CLKS && priv->clks[clk]; clk++) {\r\nret = clk_prepare_enable(priv->clks[clk]);\r\nif (ret)\r\ngoto err_disable_clks;\r\n}\r\nret = phy_init(priv->phy);\r\nif (ret)\r\ngoto err_disable_clks;\r\nret = phy_power_on(priv->phy);\r\nif (ret)\r\ngoto err_exit_phy;\r\nreturn 0;\r\nerr_exit_phy:\r\nphy_exit(priv->phy);\r\nerr_disable_clks:\r\nwhile (--clk >= 0)\r\nclk_disable_unprepare(priv->clks[clk]);\r\nerr_assert_reset:\r\nreset_control_assert(priv->rst);\r\nerr_assert_power:\r\nreset_control_assert(priv->pwr);\r\nreturn ret;\r\n}\r\nstatic void st_ehci_platform_power_off(struct platform_device *dev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(dev);\r\nstruct st_ehci_platform_priv *priv = hcd_to_ehci_priv(hcd);\r\nint clk;\r\nreset_control_assert(priv->pwr);\r\nreset_control_assert(priv->rst);\r\nphy_power_off(priv->phy);\r\nphy_exit(priv->phy);\r\nfor (clk = USB_MAX_CLKS - 1; clk >= 0; clk--)\r\nif (priv->clks[clk])\r\nclk_disable_unprepare(priv->clks[clk]);\r\n}\r\nstatic int st_ehci_platform_probe(struct platform_device *dev)\r\n{\r\nstruct usb_hcd *hcd;\r\nstruct resource *res_mem;\r\nstruct usb_ehci_pdata *pdata = &ehci_platform_defaults;\r\nstruct st_ehci_platform_priv *priv;\r\nstruct ehci_hcd *ehci;\r\nint err, irq, clk = 0;\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\nirq = platform_get_irq(dev, 0);\r\nif (irq < 0) {\r\ndev_err(&dev->dev, "no irq provided");\r\nreturn irq;\r\n}\r\nres_mem = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nif (!res_mem) {\r\ndev_err(&dev->dev, "no memory resource provided");\r\nreturn -ENXIO;\r\n}\r\nhcd = usb_create_hcd(&ehci_platform_hc_driver, &dev->dev,\r\ndev_name(&dev->dev));\r\nif (!hcd)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(dev, hcd);\r\ndev->dev.platform_data = pdata;\r\npriv = hcd_to_ehci_priv(hcd);\r\nehci = hcd_to_ehci(hcd);\r\npriv->phy = devm_phy_get(&dev->dev, "usb");\r\nif (IS_ERR(priv->phy)) {\r\nerr = PTR_ERR(priv->phy);\r\ngoto err_put_hcd;\r\n}\r\nfor (clk = 0; clk < USB_MAX_CLKS; clk++) {\r\npriv->clks[clk] = of_clk_get(dev->dev.of_node, clk);\r\nif (IS_ERR(priv->clks[clk])) {\r\nerr = PTR_ERR(priv->clks[clk]);\r\nif (err == -EPROBE_DEFER)\r\ngoto err_put_clks;\r\npriv->clks[clk] = NULL;\r\nbreak;\r\n}\r\n}\r\npriv->clk48 = devm_clk_get(&dev->dev, "clk48");\r\nif (IS_ERR(priv->clk48)) {\r\ndev_info(&dev->dev, "48MHz clk not found\n");\r\npriv->clk48 = NULL;\r\n}\r\npriv->pwr =\r\ndevm_reset_control_get_optional_shared(&dev->dev, "power");\r\nif (IS_ERR(priv->pwr)) {\r\nerr = PTR_ERR(priv->pwr);\r\nif (err == -EPROBE_DEFER)\r\ngoto err_put_clks;\r\npriv->pwr = NULL;\r\n}\r\npriv->rst =\r\ndevm_reset_control_get_optional_shared(&dev->dev, "softreset");\r\nif (IS_ERR(priv->rst)) {\r\nerr = PTR_ERR(priv->rst);\r\nif (err == -EPROBE_DEFER)\r\ngoto err_put_clks;\r\npriv->rst = NULL;\r\n}\r\nif (pdata->power_on) {\r\nerr = pdata->power_on(dev);\r\nif (err < 0)\r\ngoto err_put_clks;\r\n}\r\nhcd->rsrc_start = res_mem->start;\r\nhcd->rsrc_len = resource_size(res_mem);\r\nhcd->regs = devm_ioremap_resource(&dev->dev, res_mem);\r\nif (IS_ERR(hcd->regs)) {\r\nerr = PTR_ERR(hcd->regs);\r\ngoto err_put_clks;\r\n}\r\nerr = usb_add_hcd(hcd, irq, IRQF_SHARED);\r\nif (err)\r\ngoto err_put_clks;\r\ndevice_wakeup_enable(hcd->self.controller);\r\nplatform_set_drvdata(dev, hcd);\r\nreturn err;\r\nerr_put_clks:\r\nwhile (--clk >= 0)\r\nclk_put(priv->clks[clk]);\r\nerr_put_hcd:\r\nif (pdata == &ehci_platform_defaults)\r\ndev->dev.platform_data = NULL;\r\nusb_put_hcd(hcd);\r\nreturn err;\r\n}\r\nstatic int st_ehci_platform_remove(struct platform_device *dev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(dev);\r\nstruct usb_ehci_pdata *pdata = dev_get_platdata(&dev->dev);\r\nstruct st_ehci_platform_priv *priv = hcd_to_ehci_priv(hcd);\r\nint clk;\r\nusb_remove_hcd(hcd);\r\nif (pdata->power_off)\r\npdata->power_off(dev);\r\nfor (clk = 0; clk < USB_MAX_CLKS && priv->clks[clk]; clk++)\r\nclk_put(priv->clks[clk]);\r\nusb_put_hcd(hcd);\r\nif (pdata == &ehci_platform_defaults)\r\ndev->dev.platform_data = NULL;\r\nreturn 0;\r\n}\r\nstatic int st_ehci_suspend(struct device *dev)\r\n{\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nstruct usb_ehci_pdata *pdata = dev_get_platdata(dev);\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nbool do_wakeup = device_may_wakeup(dev);\r\nint ret;\r\nret = ehci_suspend(hcd, do_wakeup);\r\nif (ret)\r\nreturn ret;\r\nif (pdata->power_suspend)\r\npdata->power_suspend(pdev);\r\npinctrl_pm_select_sleep_state(dev);\r\nreturn ret;\r\n}\r\nstatic int st_ehci_resume(struct device *dev)\r\n{\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nstruct usb_ehci_pdata *pdata = dev_get_platdata(dev);\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nint err;\r\npinctrl_pm_select_default_state(dev);\r\nif (pdata->power_on) {\r\nerr = pdata->power_on(pdev);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nehci_resume(hcd, false);\r\nreturn 0;\r\n}\r\nstatic int __init ehci_platform_init(void)\r\n{\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\npr_info("%s: " DRIVER_DESC "\n", hcd_name);\r\nehci_init_driver(&ehci_platform_hc_driver, &platform_overrides);\r\nreturn platform_driver_register(&ehci_platform_driver);\r\n}\r\nstatic void __exit ehci_platform_cleanup(void)\r\n{\r\nplatform_driver_unregister(&ehci_platform_driver);\r\n}
