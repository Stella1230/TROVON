static void pnv_php_disable_irq(struct pnv_php_slot *php_slot,\r\nbool disable_device)\r\n{\r\nstruct pci_dev *pdev = php_slot->pdev;\r\nint irq = php_slot->irq;\r\nu16 ctrl;\r\nif (php_slot->irq > 0) {\r\npcie_capability_read_word(pdev, PCI_EXP_SLTCTL, &ctrl);\r\nctrl &= ~(PCI_EXP_SLTCTL_HPIE |\r\nPCI_EXP_SLTCTL_PDCE |\r\nPCI_EXP_SLTCTL_DLLSCE);\r\npcie_capability_write_word(pdev, PCI_EXP_SLTCTL, ctrl);\r\nfree_irq(php_slot->irq, php_slot);\r\nphp_slot->irq = 0;\r\n}\r\nif (php_slot->wq) {\r\ndestroy_workqueue(php_slot->wq);\r\nphp_slot->wq = NULL;\r\n}\r\nif (disable_device || irq > 0) {\r\nif (pdev->msix_enabled)\r\npci_disable_msix(pdev);\r\nelse if (pdev->msi_enabled)\r\npci_disable_msi(pdev);\r\npci_disable_device(pdev);\r\n}\r\n}\r\nstatic void pnv_php_free_slot(struct kref *kref)\r\n{\r\nstruct pnv_php_slot *php_slot = container_of(kref,\r\nstruct pnv_php_slot, kref);\r\nWARN_ON(!list_empty(&php_slot->children));\r\npnv_php_disable_irq(php_slot, false);\r\nkfree(php_slot->name);\r\nkfree(php_slot);\r\n}\r\nstatic inline void pnv_php_put_slot(struct pnv_php_slot *php_slot)\r\n{\r\nif (!php_slot)\r\nreturn;\r\nkref_put(&php_slot->kref, pnv_php_free_slot);\r\n}\r\nstatic struct pnv_php_slot *pnv_php_match(struct device_node *dn,\r\nstruct pnv_php_slot *php_slot)\r\n{\r\nstruct pnv_php_slot *target, *tmp;\r\nif (php_slot->dn == dn) {\r\nkref_get(&php_slot->kref);\r\nreturn php_slot;\r\n}\r\nlist_for_each_entry(tmp, &php_slot->children, link) {\r\ntarget = pnv_php_match(dn, tmp);\r\nif (target)\r\nreturn target;\r\n}\r\nreturn NULL;\r\n}\r\nstruct pnv_php_slot *pnv_php_find_slot(struct device_node *dn)\r\n{\r\nstruct pnv_php_slot *php_slot, *tmp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&pnv_php_lock, flags);\r\nlist_for_each_entry(tmp, &pnv_php_slot_list, link) {\r\nphp_slot = pnv_php_match(dn, tmp);\r\nif (php_slot) {\r\nspin_unlock_irqrestore(&pnv_php_lock, flags);\r\nreturn php_slot;\r\n}\r\n}\r\nspin_unlock_irqrestore(&pnv_php_lock, flags);\r\nreturn NULL;\r\n}\r\nstatic void pnv_php_rmv_pdns(struct device_node *dn)\r\n{\r\nstruct device_node *child;\r\nfor_each_child_of_node(dn, child) {\r\npnv_php_rmv_pdns(child);\r\npci_remove_device_node_info(child);\r\n}\r\n}\r\nstatic void pnv_php_detach_device_nodes(struct device_node *parent)\r\n{\r\nstruct device_node *dn;\r\nint refcount;\r\nfor_each_child_of_node(parent, dn) {\r\npnv_php_detach_device_nodes(dn);\r\nof_node_put(dn);\r\nrefcount = kref_read(&dn->kobj.kref);\r\nif (refcount != 1)\r\npr_warn("Invalid refcount %d on <%s>\n",\r\nrefcount, of_node_full_name(dn));\r\nof_detach_node(dn);\r\n}\r\n}\r\nstatic void pnv_php_rmv_devtree(struct pnv_php_slot *php_slot)\r\n{\r\npnv_php_rmv_pdns(php_slot->dn);\r\nif (php_slot->fdt)\r\nof_changeset_destroy(&php_slot->ocs);\r\npnv_php_detach_device_nodes(php_slot->dn);\r\nif (php_slot->fdt) {\r\nkfree(php_slot->dt);\r\nkfree(php_slot->fdt);\r\nphp_slot->dt = NULL;\r\nphp_slot->dn->child = NULL;\r\nphp_slot->fdt = NULL;\r\n}\r\n}\r\nstatic void pnv_php_reverse_nodes(struct device_node *parent)\r\n{\r\nstruct device_node *child, *next;\r\nfor_each_child_of_node(parent, child)\r\npnv_php_reverse_nodes(child);\r\nchild = parent->child;\r\nparent->child = NULL;\r\nwhile (child) {\r\nnext = child->sibling;\r\nchild->sibling = parent->child;\r\nparent->child = child;\r\nchild = next;\r\n}\r\n}\r\nstatic int pnv_php_populate_changeset(struct of_changeset *ocs,\r\nstruct device_node *dn)\r\n{\r\nstruct device_node *child;\r\nint ret = 0;\r\nfor_each_child_of_node(dn, child) {\r\nret = of_changeset_attach_node(ocs, child);\r\nif (ret)\r\nbreak;\r\nret = pnv_php_populate_changeset(ocs, child);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void *pnv_php_add_one_pdn(struct device_node *dn, void *data)\r\n{\r\nstruct pci_controller *hose = (struct pci_controller *)data;\r\nstruct pci_dn *pdn;\r\npdn = pci_add_device_node_info(hose, dn);\r\nif (!pdn)\r\nreturn ERR_PTR(-ENOMEM);\r\nreturn NULL;\r\n}\r\nstatic void pnv_php_add_pdns(struct pnv_php_slot *slot)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(slot->bus);\r\npci_traverse_device_nodes(slot->dn, pnv_php_add_one_pdn, hose);\r\n}\r\nstatic int pnv_php_add_devtree(struct pnv_php_slot *php_slot)\r\n{\r\nvoid *fdt, *fdt1, *dt;\r\nint ret;\r\nfdt1 = kzalloc(0x10000, GFP_KERNEL);\r\nif (!fdt1) {\r\nret = -ENOMEM;\r\ndev_warn(&php_slot->pdev->dev, "Cannot alloc FDT blob\n");\r\ngoto out;\r\n}\r\nret = pnv_pci_get_device_tree(php_slot->dn->phandle, fdt1, 0x10000);\r\nif (ret) {\r\ndev_warn(&php_slot->pdev->dev, "Error %d getting FDT blob\n",\r\nret);\r\ngoto free_fdt1;\r\n}\r\nfdt = kzalloc(fdt_totalsize(fdt1), GFP_KERNEL);\r\nif (!fdt) {\r\nret = -ENOMEM;\r\ndev_warn(&php_slot->pdev->dev, "Cannot %d bytes memory\n",\r\nfdt_totalsize(fdt1));\r\ngoto free_fdt1;\r\n}\r\nmemcpy(fdt, fdt1, fdt_totalsize(fdt1));\r\ndt = of_fdt_unflatten_tree(fdt, php_slot->dn, NULL);\r\nif (!dt) {\r\nret = -EINVAL;\r\ndev_warn(&php_slot->pdev->dev, "Cannot unflatten FDT\n");\r\ngoto free_fdt;\r\n}\r\nof_changeset_init(&php_slot->ocs);\r\npnv_php_reverse_nodes(php_slot->dn);\r\nret = pnv_php_populate_changeset(&php_slot->ocs, php_slot->dn);\r\nif (ret) {\r\npnv_php_reverse_nodes(php_slot->dn);\r\ndev_warn(&php_slot->pdev->dev, "Error %d populating changeset\n",\r\nret);\r\ngoto free_dt;\r\n}\r\nphp_slot->dn->child = NULL;\r\nret = of_changeset_apply(&php_slot->ocs);\r\nif (ret) {\r\ndev_warn(&php_slot->pdev->dev, "Error %d applying changeset\n",\r\nret);\r\ngoto destroy_changeset;\r\n}\r\npnv_php_add_pdns(php_slot);\r\nphp_slot->fdt = fdt;\r\nphp_slot->dt = dt;\r\nkfree(fdt1);\r\ngoto out;\r\ndestroy_changeset:\r\nof_changeset_destroy(&php_slot->ocs);\r\nfree_dt:\r\nkfree(dt);\r\nphp_slot->dn->child = NULL;\r\nfree_fdt:\r\nkfree(fdt);\r\nfree_fdt1:\r\nkfree(fdt1);\r\nout:\r\nreturn ret;\r\n}\r\nint pnv_php_set_slot_power_state(struct hotplug_slot *slot,\r\nuint8_t state)\r\n{\r\nstruct pnv_php_slot *php_slot = slot->private;\r\nstruct opal_msg msg;\r\nint ret;\r\nret = pnv_pci_set_power_state(php_slot->id, state, &msg);\r\nif (ret > 0) {\r\nif (be64_to_cpu(msg.params[1]) != php_slot->dn->phandle ||\r\nbe64_to_cpu(msg.params[2]) != state ||\r\nbe64_to_cpu(msg.params[3]) != OPAL_SUCCESS) {\r\ndev_warn(&php_slot->pdev->dev, "Wrong msg (%lld, %lld, %lld)\n",\r\nbe64_to_cpu(msg.params[1]),\r\nbe64_to_cpu(msg.params[2]),\r\nbe64_to_cpu(msg.params[3]));\r\nreturn -ENOMSG;\r\n}\r\n} else if (ret < 0) {\r\ndev_warn(&php_slot->pdev->dev, "Error %d powering %s\n",\r\nret, (state == OPAL_PCI_SLOT_POWER_ON) ? "on" : "off");\r\nreturn ret;\r\n}\r\nif (state == OPAL_PCI_SLOT_POWER_OFF || state == OPAL_PCI_SLOT_OFFLINE)\r\npnv_php_rmv_devtree(php_slot);\r\nelse\r\nret = pnv_php_add_devtree(php_slot);\r\nreturn ret;\r\n}\r\nstatic int pnv_php_get_power_state(struct hotplug_slot *slot, u8 *state)\r\n{\r\nstruct pnv_php_slot *php_slot = slot->private;\r\nuint8_t power_state = OPAL_PCI_SLOT_POWER_ON;\r\nint ret;\r\nret = pnv_pci_get_power_state(php_slot->id, &power_state);\r\nif (ret) {\r\ndev_warn(&php_slot->pdev->dev, "Error %d getting power status\n",\r\nret);\r\n} else {\r\n*state = power_state;\r\nslot->info->power_status = power_state;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pnv_php_get_adapter_state(struct hotplug_slot *slot, u8 *state)\r\n{\r\nstruct pnv_php_slot *php_slot = slot->private;\r\nuint8_t presence = OPAL_PCI_SLOT_EMPTY;\r\nint ret;\r\nret = pnv_pci_get_presence_state(php_slot->id, &presence);\r\nif (ret >= 0) {\r\n*state = presence;\r\nslot->info->adapter_status = presence;\r\nret = 0;\r\n} else {\r\ndev_warn(&php_slot->pdev->dev, "Error %d getting presence\n",\r\nret);\r\n}\r\nreturn ret;\r\n}\r\nstatic int pnv_php_set_attention_state(struct hotplug_slot *slot, u8 state)\r\n{\r\nslot->info->attention_status = state;\r\nreturn 0;\r\n}\r\nstatic int pnv_php_enable(struct pnv_php_slot *php_slot, bool rescan)\r\n{\r\nstruct hotplug_slot *slot = &php_slot->slot;\r\nuint8_t presence = OPAL_PCI_SLOT_EMPTY;\r\nuint8_t power_status = OPAL_PCI_SLOT_POWER_ON;\r\nint ret;\r\nif (php_slot->state != PNV_PHP_STATE_REGISTERED)\r\nreturn 0;\r\nret = pnv_php_get_adapter_state(slot, &presence);\r\nif (ret)\r\nreturn ret;\r\nif (presence == OPAL_PCI_SLOT_EMPTY) {\r\nif (!php_slot->power_state_check) {\r\nphp_slot->power_state_check = true;\r\nreturn 0;\r\n}\r\ngoto scan;\r\n}\r\nif (!php_slot->power_state_check) {\r\nphp_slot->power_state_check = true;\r\nret = pnv_php_get_power_state(slot, &power_status);\r\nif (ret)\r\nreturn ret;\r\nif (power_status != OPAL_PCI_SLOT_POWER_ON)\r\nreturn 0;\r\n}\r\nret = pnv_php_get_power_state(slot, &power_status);\r\nif (ret)\r\nreturn ret;\r\nif (power_status == OPAL_PCI_SLOT_POWER_ON)\r\ngoto scan;\r\nret = pnv_php_set_slot_power_state(slot, OPAL_PCI_SLOT_POWER_ON);\r\nif (ret)\r\nreturn ret;\r\nscan:\r\nif (presence == OPAL_PCI_SLOT_PRESENT) {\r\nif (rescan) {\r\npci_lock_rescan_remove();\r\npci_hp_add_devices(php_slot->bus);\r\npci_unlock_rescan_remove();\r\n}\r\nphp_slot->state = PNV_PHP_STATE_POPULATED;\r\nif (rescan)\r\npnv_php_register(php_slot->dn);\r\n} else {\r\nphp_slot->state = PNV_PHP_STATE_POPULATED;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pnv_php_enable_slot(struct hotplug_slot *slot)\r\n{\r\nstruct pnv_php_slot *php_slot = container_of(slot,\r\nstruct pnv_php_slot, slot);\r\nreturn pnv_php_enable(php_slot, true);\r\n}\r\nstatic int pnv_php_disable_slot(struct hotplug_slot *slot)\r\n{\r\nstruct pnv_php_slot *php_slot = slot->private;\r\nint ret;\r\nif (php_slot->state != PNV_PHP_STATE_POPULATED)\r\nreturn 0;\r\npci_lock_rescan_remove();\r\npci_hp_remove_devices(php_slot->bus);\r\npci_unlock_rescan_remove();\r\npnv_php_unregister(php_slot->dn);\r\nret = pnv_php_set_slot_power_state(slot, OPAL_PCI_SLOT_POWER_OFF);\r\nphp_slot->state = PNV_PHP_STATE_REGISTERED;\r\nreturn ret;\r\n}\r\nstatic void pnv_php_release(struct hotplug_slot *slot)\r\n{\r\nstruct pnv_php_slot *php_slot = slot->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&pnv_php_lock, flags);\r\nlist_del(&php_slot->link);\r\nspin_unlock_irqrestore(&pnv_php_lock, flags);\r\npnv_php_put_slot(php_slot);\r\npnv_php_put_slot(php_slot->parent);\r\n}\r\nstatic struct pnv_php_slot *pnv_php_alloc_slot(struct device_node *dn)\r\n{\r\nstruct pnv_php_slot *php_slot;\r\nstruct pci_bus *bus;\r\nconst char *label;\r\nuint64_t id;\r\nint ret;\r\nret = of_property_read_string(dn, "ibm,slot-label", &label);\r\nif (ret)\r\nreturn NULL;\r\nif (pnv_pci_get_slot_id(dn, &id))\r\nreturn NULL;\r\nbus = pci_find_bus_by_node(dn);\r\nif (!bus)\r\nreturn NULL;\r\nphp_slot = kzalloc(sizeof(*php_slot), GFP_KERNEL);\r\nif (!php_slot)\r\nreturn NULL;\r\nphp_slot->name = kstrdup(label, GFP_KERNEL);\r\nif (!php_slot->name) {\r\nkfree(php_slot);\r\nreturn NULL;\r\n}\r\nif (dn->child && PCI_DN(dn->child))\r\nphp_slot->slot_no = PCI_SLOT(PCI_DN(dn->child)->devfn);\r\nelse\r\nphp_slot->slot_no = -1;\r\nkref_init(&php_slot->kref);\r\nphp_slot->state = PNV_PHP_STATE_INITIALIZED;\r\nphp_slot->dn = dn;\r\nphp_slot->pdev = bus->self;\r\nphp_slot->bus = bus;\r\nphp_slot->id = id;\r\nphp_slot->power_state_check = false;\r\nphp_slot->slot.ops = &php_slot_ops;\r\nphp_slot->slot.info = &php_slot->slot_info;\r\nphp_slot->slot.release = pnv_php_release;\r\nphp_slot->slot.private = php_slot;\r\nINIT_LIST_HEAD(&php_slot->children);\r\nINIT_LIST_HEAD(&php_slot->link);\r\nreturn php_slot;\r\n}\r\nstatic int pnv_php_register_slot(struct pnv_php_slot *php_slot)\r\n{\r\nstruct pnv_php_slot *parent;\r\nstruct device_node *dn = php_slot->dn;\r\nunsigned long flags;\r\nint ret;\r\nparent = pnv_php_find_slot(php_slot->dn);\r\nif (parent) {\r\npnv_php_put_slot(parent);\r\nreturn -EEXIST;\r\n}\r\nret = pci_hp_register(&php_slot->slot, php_slot->bus,\r\nphp_slot->slot_no, php_slot->name);\r\nif (ret) {\r\ndev_warn(&php_slot->pdev->dev, "Error %d registering slot\n",\r\nret);\r\nreturn ret;\r\n}\r\nwhile ((dn = of_get_parent(dn))) {\r\nif (!PCI_DN(dn)) {\r\nof_node_put(dn);\r\nbreak;\r\n}\r\nparent = pnv_php_find_slot(dn);\r\nif (parent) {\r\nof_node_put(dn);\r\nbreak;\r\n}\r\nof_node_put(dn);\r\n}\r\nspin_lock_irqsave(&pnv_php_lock, flags);\r\nphp_slot->parent = parent;\r\nif (parent)\r\nlist_add_tail(&php_slot->link, &parent->children);\r\nelse\r\nlist_add_tail(&php_slot->link, &pnv_php_slot_list);\r\nspin_unlock_irqrestore(&pnv_php_lock, flags);\r\nphp_slot->state = PNV_PHP_STATE_REGISTERED;\r\nreturn 0;\r\n}\r\nstatic int pnv_php_enable_msix(struct pnv_php_slot *php_slot)\r\n{\r\nstruct pci_dev *pdev = php_slot->pdev;\r\nstruct msix_entry entry;\r\nint nr_entries, ret;\r\nu16 pcie_flag;\r\nnr_entries = pci_msix_vec_count(pdev);\r\nif (nr_entries < 0)\r\nreturn nr_entries;\r\npcie_capability_read_word(pdev, PCI_EXP_FLAGS, &pcie_flag);\r\nentry.entry = (pcie_flag & PCI_EXP_FLAGS_IRQ) >> 9;\r\nif (entry.entry >= nr_entries)\r\nreturn -ERANGE;\r\nret = pci_enable_msix_exact(pdev, &entry, 1);\r\nif (ret) {\r\ndev_warn(&pdev->dev, "Error %d enabling MSIx\n", ret);\r\nreturn ret;\r\n}\r\nreturn entry.vector;\r\n}\r\nstatic void pnv_php_event_handler(struct work_struct *work)\r\n{\r\nstruct pnv_php_event *event =\r\ncontainer_of(work, struct pnv_php_event, work);\r\nstruct pnv_php_slot *php_slot = event->php_slot;\r\nif (event->added)\r\npnv_php_enable_slot(&php_slot->slot);\r\nelse\r\npnv_php_disable_slot(&php_slot->slot);\r\nkfree(event);\r\n}\r\nstatic irqreturn_t pnv_php_interrupt(int irq, void *data)\r\n{\r\nstruct pnv_php_slot *php_slot = data;\r\nstruct pci_dev *pchild, *pdev = php_slot->pdev;\r\nstruct eeh_dev *edev;\r\nstruct eeh_pe *pe;\r\nstruct pnv_php_event *event;\r\nu16 sts, lsts;\r\nu8 presence;\r\nbool added;\r\nunsigned long flags;\r\nint ret;\r\npcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &sts);\r\nsts &= (PCI_EXP_SLTSTA_PDC | PCI_EXP_SLTSTA_DLLSC);\r\npcie_capability_write_word(pdev, PCI_EXP_SLTSTA, sts);\r\nif (sts & PCI_EXP_SLTSTA_DLLSC) {\r\npcie_capability_read_word(pdev, PCI_EXP_LNKSTA, &lsts);\r\nadded = !!(lsts & PCI_EXP_LNKSTA_DLLLA);\r\n} else if (!(php_slot->flags & PNV_PHP_FLAG_BROKEN_PDC) &&\r\n(sts & PCI_EXP_SLTSTA_PDC)) {\r\nret = pnv_pci_get_presence_state(php_slot->id, &presence);\r\nif (ret) {\r\ndev_warn(&pdev->dev, "PCI slot [%s] error %d getting presence (0x%04x), to retry the operation.\n",\r\nphp_slot->name, ret, sts);\r\nreturn IRQ_HANDLED;\r\n}\r\nadded = !!(presence == OPAL_PCI_SLOT_PRESENT);\r\n} else {\r\nreturn IRQ_NONE;\r\n}\r\nif (!added) {\r\npchild = list_first_entry_or_null(&php_slot->bus->devices,\r\nstruct pci_dev, bus_list);\r\nedev = pchild ? pci_dev_to_eeh_dev(pchild) : NULL;\r\npe = edev ? edev->pe : NULL;\r\nif (pe) {\r\neeh_serialize_lock(&flags);\r\neeh_pe_state_mark(pe, EEH_PE_ISOLATED);\r\neeh_serialize_unlock(flags);\r\neeh_pe_set_option(pe, EEH_OPT_FREEZE_PE);\r\n}\r\n}\r\nevent = kzalloc(sizeof(*event), GFP_ATOMIC);\r\nif (!event) {\r\ndev_warn(&pdev->dev, "PCI slot [%s] missed hotplug event 0x%04x\n",\r\nphp_slot->name, sts);\r\nreturn IRQ_HANDLED;\r\n}\r\ndev_info(&pdev->dev, "PCI slot [%s] %s (IRQ: %d)\n",\r\nphp_slot->name, added ? "added" : "removed", irq);\r\nINIT_WORK(&event->work, pnv_php_event_handler);\r\nevent->added = added;\r\nevent->php_slot = php_slot;\r\nqueue_work(php_slot->wq, &event->work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void pnv_php_init_irq(struct pnv_php_slot *php_slot, int irq)\r\n{\r\nstruct pci_dev *pdev = php_slot->pdev;\r\nu32 broken_pdc = 0;\r\nu16 sts, ctrl;\r\nint ret;\r\nphp_slot->wq = alloc_workqueue("pciehp-%s", 0, 0, php_slot->name);\r\nif (!php_slot->wq) {\r\ndev_warn(&pdev->dev, "Cannot alloc workqueue\n");\r\npnv_php_disable_irq(php_slot, true);\r\nreturn;\r\n}\r\nret = of_property_read_u32(php_slot->dn, "ibm,slot-broken-pdc",\r\n&broken_pdc);\r\nif (!ret && broken_pdc)\r\nphp_slot->flags |= PNV_PHP_FLAG_BROKEN_PDC;\r\npcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &sts);\r\nif (php_slot->flags & PNV_PHP_FLAG_BROKEN_PDC)\r\nsts |= PCI_EXP_SLTSTA_DLLSC;\r\nelse\r\nsts |= (PCI_EXP_SLTSTA_PDC | PCI_EXP_SLTSTA_DLLSC);\r\npcie_capability_write_word(pdev, PCI_EXP_SLTSTA, sts);\r\nret = request_irq(irq, pnv_php_interrupt, IRQF_SHARED,\r\nphp_slot->name, php_slot);\r\nif (ret) {\r\npnv_php_disable_irq(php_slot, true);\r\ndev_warn(&pdev->dev, "Error %d enabling IRQ %d\n", ret, irq);\r\nreturn;\r\n}\r\npcie_capability_read_word(pdev, PCI_EXP_SLTCTL, &ctrl);\r\nif (php_slot->flags & PNV_PHP_FLAG_BROKEN_PDC) {\r\nctrl &= ~PCI_EXP_SLTCTL_PDCE;\r\nctrl |= (PCI_EXP_SLTCTL_HPIE |\r\nPCI_EXP_SLTCTL_DLLSCE);\r\n} else {\r\nctrl |= (PCI_EXP_SLTCTL_HPIE |\r\nPCI_EXP_SLTCTL_PDCE |\r\nPCI_EXP_SLTCTL_DLLSCE);\r\n}\r\npcie_capability_write_word(pdev, PCI_EXP_SLTCTL, ctrl);\r\nphp_slot->irq = irq;\r\n}\r\nstatic void pnv_php_enable_irq(struct pnv_php_slot *php_slot)\r\n{\r\nstruct pci_dev *pdev = php_slot->pdev;\r\nint irq, ret;\r\nif (pci_dev_msi_enabled(pdev))\r\nreturn;\r\nret = pci_enable_device(pdev);\r\nif (ret) {\r\ndev_warn(&pdev->dev, "Error %d enabling device\n", ret);\r\nreturn;\r\n}\r\npci_set_master(pdev);\r\nirq = pnv_php_enable_msix(php_slot);\r\nif (irq > 0) {\r\npnv_php_init_irq(php_slot, irq);\r\nreturn;\r\n}\r\nret = pci_enable_msi(pdev);\r\nif (!ret || pdev->irq) {\r\nirq = pdev->irq;\r\npnv_php_init_irq(php_slot, irq);\r\n}\r\n}\r\nstatic int pnv_php_register_one(struct device_node *dn)\r\n{\r\nstruct pnv_php_slot *php_slot;\r\nu32 prop32;\r\nint ret;\r\nret = of_property_read_u32(dn, "ibm,slot-pluggable", &prop32);\r\nif (ret || !prop32)\r\nreturn -ENXIO;\r\nret = of_property_read_u32(dn, "ibm,reset-by-firmware", &prop32);\r\nif (ret || !prop32)\r\nreturn -ENXIO;\r\nphp_slot = pnv_php_alloc_slot(dn);\r\nif (!php_slot)\r\nreturn -ENODEV;\r\nret = pnv_php_register_slot(php_slot);\r\nif (ret)\r\ngoto free_slot;\r\nret = pnv_php_enable(php_slot, false);\r\nif (ret)\r\ngoto unregister_slot;\r\nret = of_property_read_u32(dn, "ibm,slot-surprise-pluggable", &prop32);\r\nif (!ret && prop32)\r\npnv_php_enable_irq(php_slot);\r\nreturn 0;\r\nunregister_slot:\r\npnv_php_unregister_one(php_slot->dn);\r\nfree_slot:\r\npnv_php_put_slot(php_slot);\r\nreturn ret;\r\n}\r\nstatic void pnv_php_register(struct device_node *dn)\r\n{\r\nstruct device_node *child;\r\nfor_each_child_of_node(dn, child) {\r\npnv_php_register_one(child);\r\npnv_php_register(child);\r\n}\r\n}\r\nstatic void pnv_php_unregister_one(struct device_node *dn)\r\n{\r\nstruct pnv_php_slot *php_slot;\r\nphp_slot = pnv_php_find_slot(dn);\r\nif (!php_slot)\r\nreturn;\r\nphp_slot->state = PNV_PHP_STATE_OFFLINE;\r\npnv_php_put_slot(php_slot);\r\npci_hp_deregister(&php_slot->slot);\r\n}\r\nstatic void pnv_php_unregister(struct device_node *dn)\r\n{\r\nstruct device_node *child;\r\nfor_each_child_of_node(dn, child) {\r\npnv_php_unregister(child);\r\npnv_php_unregister_one(child);\r\n}\r\n}\r\nstatic int __init pnv_php_init(void)\r\n{\r\nstruct device_node *dn;\r\npr_info(DRIVER_DESC " version: " DRIVER_VERSION "\n");\r\nfor_each_compatible_node(dn, NULL, "ibm,ioda2-phb")\r\npnv_php_register(dn);\r\nreturn 0;\r\n}\r\nstatic void __exit pnv_php_exit(void)\r\n{\r\nstruct device_node *dn;\r\nfor_each_compatible_node(dn, NULL, "ibm,ioda2-phb")\r\npnv_php_unregister(dn);\r\n}
