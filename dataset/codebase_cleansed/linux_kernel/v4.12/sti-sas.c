static int sti_sas_read_reg(void *context, unsigned int reg,\r\nunsigned int *value)\r\n{\r\nstruct sti_sas_data *drvdata = context;\r\nint status;\r\nu32 val;\r\nstatus = regmap_read(drvdata->dac.regmap, reg, &val);\r\n*value = (unsigned int)val;\r\nreturn status;\r\n}\r\nstatic int sti_sas_write_reg(void *context, unsigned int reg,\r\nunsigned int value)\r\n{\r\nstruct sti_sas_data *drvdata = context;\r\nint status;\r\nstatus = regmap_write(drvdata->dac.regmap, reg, value);\r\nreturn status;\r\n}\r\nstatic int sti_sas_init_sas_registers(struct snd_soc_codec *codec,\r\nstruct sti_sas_data *data)\r\n{\r\nint ret;\r\nret = snd_soc_update_bits(codec, STIH407_AUDIO_GLUE_CTRL,\r\nSPDIF_BIPHASE_ENABLE_MASK, 0);\r\nif (!ret)\r\nret = snd_soc_update_bits(codec, STIH407_AUDIO_GLUE_CTRL,\r\nSPDIF_BIPHASE_IDLE_MASK, 0);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to update SPDIF registers\n");\r\nreturn ret;\r\n}\r\nret = snd_soc_update_bits(codec, STIH407_AUDIO_DAC_CTRL,\r\nSTIH407_DAC_STANDBY_MASK,\r\nSTIH407_DAC_STANDBY_MASK);\r\nif (!ret)\r\nret = snd_soc_update_bits(codec, STIH407_AUDIO_DAC_CTRL,\r\nSTIH407_DAC_STANDBY_ANA_MASK,\r\nSTIH407_DAC_STANDBY_ANA_MASK);\r\nif (!ret)\r\nret = snd_soc_update_bits(codec, STIH407_AUDIO_DAC_CTRL,\r\nSTIH407_DAC_SOFTMUTE_MASK,\r\nSTIH407_DAC_SOFTMUTE_MASK);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to update DAC registers\n");\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int sti_sas_dac_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nif ((fmt & SND_SOC_DAIFMT_MASTER_MASK) != SND_SOC_DAIFMT_CBS_CFS) {\r\ndev_err(dai->codec->dev,\r\n"%s: ERROR: Unsupporter master mask 0x%x\n",\r\n__func__, fmt & SND_SOC_DAIFMT_MASTER_MASK);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int stih407_sas_dac_mute(struct snd_soc_dai *dai, int mute, int stream)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nif (mute) {\r\nreturn snd_soc_update_bits(codec, STIH407_AUDIO_DAC_CTRL,\r\nSTIH407_DAC_SOFTMUTE_MASK,\r\nSTIH407_DAC_SOFTMUTE_MASK);\r\n} else {\r\nreturn snd_soc_update_bits(codec, STIH407_AUDIO_DAC_CTRL,\r\nSTIH407_DAC_SOFTMUTE_MASK,\r\n0);\r\n}\r\n}\r\nstatic int sti_sas_spdif_set_fmt(struct snd_soc_dai *dai,\r\nunsigned int fmt)\r\n{\r\nif ((fmt & SND_SOC_DAIFMT_MASTER_MASK) != SND_SOC_DAIFMT_CBS_CFS) {\r\ndev_err(dai->codec->dev,\r\n"%s: ERROR: Unsupporter master mask 0x%x\n",\r\n__func__, fmt & SND_SOC_DAIFMT_MASTER_MASK);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sti_sas_spdif_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nreturn snd_soc_update_bits(codec, STIH407_AUDIO_GLUE_CTRL,\r\nSPDIF_BIPHASE_ENABLE_MASK,\r\nSPDIF_BIPHASE_ENABLE_MASK);\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nreturn snd_soc_update_bits(codec, STIH407_AUDIO_GLUE_CTRL,\r\nSPDIF_BIPHASE_ENABLE_MASK,\r\n0);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic bool sti_sas_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nif (reg == STIH407_AUDIO_GLUE_CTRL)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int sti_sas_set_sysclk(struct snd_soc_dai *dai, int clk_id,\r\nunsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct sti_sas_data *drvdata = dev_get_drvdata(codec->dev);\r\nif (dir == SND_SOC_CLOCK_OUT)\r\nreturn 0;\r\nif (clk_id != 0)\r\nreturn -EINVAL;\r\nswitch (dai->id) {\r\ncase STI_SAS_DAI_SPDIF_OUT:\r\ndrvdata->spdif.mclk = freq;\r\nbreak;\r\ncase STI_SAS_DAI_ANALOG_OUT:\r\ndrvdata->dac.mclk = freq;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sti_sas_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct sti_sas_data *drvdata = dev_get_drvdata(codec->dev);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nswitch (dai->id) {\r\ncase STI_SAS_DAI_SPDIF_OUT:\r\nif ((drvdata->spdif.mclk / runtime->rate) != 128) {\r\ndev_err(codec->dev, "unexpected mclk-fs ratio\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase STI_SAS_DAI_ANALOG_OUT:\r\nif ((drvdata->dac.mclk / runtime->rate) != 256) {\r\ndev_err(codec->dev, "unexpected mclk-fs ratio\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sti_sas_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct sti_sas_data *drvdata = dev_get_drvdata(codec->dev);\r\nreturn sti_sas_init_sas_registers(codec, drvdata);\r\n}\r\nstatic int sti_sas_codec_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct sti_sas_data *drvdata = dev_get_drvdata(codec->dev);\r\nint ret;\r\nret = sti_sas_init_sas_registers(codec, drvdata);\r\nreturn ret;\r\n}\r\nstatic int sti_sas_driver_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *pnode = pdev->dev.of_node;\r\nstruct sti_sas_data *drvdata;\r\nconst struct of_device_id *of_id;\r\ndrvdata = devm_kzalloc(&pdev->dev, sizeof(struct sti_sas_data),\r\nGFP_KERNEL);\r\nif (!drvdata)\r\nreturn -ENOMEM;\r\nof_id = of_match_node(sti_sas_dev_match, pnode);\r\nif (!of_id->data) {\r\ndev_err(&pdev->dev, "data associated to device is missing\n");\r\nreturn -EINVAL;\r\n}\r\ndrvdata->dev_data = (struct sti_sas_dev_data *)of_id->data;\r\ndrvdata->dev = &pdev->dev;\r\ndrvdata->dac.virt_regmap = devm_regmap_init(&pdev->dev, NULL, drvdata,\r\ndrvdata->dev_data->regmap);\r\nif (IS_ERR(drvdata->dac.virt_regmap)) {\r\ndev_err(&pdev->dev, "audio registers not enabled\n");\r\nreturn PTR_ERR(drvdata->dac.virt_regmap);\r\n}\r\ndrvdata->dac.regmap =\r\nsyscon_regmap_lookup_by_phandle(pnode, "st,syscfg");\r\nif (IS_ERR(drvdata->dac.regmap)) {\r\ndev_err(&pdev->dev, "syscon registers not available\n");\r\nreturn PTR_ERR(drvdata->dac.regmap);\r\n}\r\ndrvdata->spdif.regmap = drvdata->dac.regmap;\r\nsti_sas_dai[STI_SAS_DAI_ANALOG_OUT].ops = drvdata->dev_data->dac_ops;\r\nsti_sas_driver.component_driver.dapm_widgets = drvdata->dev_data->dapm_widgets;\r\nsti_sas_driver.component_driver.num_dapm_widgets = drvdata->dev_data->num_dapm_widgets;\r\nsti_sas_driver.component_driver.dapm_routes = drvdata->dev_data->dapm_routes;\r\nsti_sas_driver.component_driver.num_dapm_routes = drvdata->dev_data->num_dapm_routes;\r\ndev_set_drvdata(&pdev->dev, drvdata);\r\nreturn snd_soc_register_codec(&pdev->dev, &sti_sas_driver,\r\nsti_sas_dai,\r\nARRAY_SIZE(sti_sas_dai));\r\n}\r\nstatic int sti_sas_driver_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_codec(&pdev->dev);\r\nreturn 0;\r\n}
