static void shadow_store(struct r820t_priv *priv, u8 reg, const u8 *val,\r\nint len)\r\n{\r\nint r = reg - REG_SHADOW_START;\r\nif (r < 0) {\r\nlen += r;\r\nr = 0;\r\n}\r\nif (len <= 0)\r\nreturn;\r\nif (len > NUM_REGS - r)\r\nlen = NUM_REGS - r;\r\ntuner_dbg("%s: prev reg=%02x len=%d: %*ph\n",\r\n__func__, r + REG_SHADOW_START, len, len, val);\r\nmemcpy(&priv->regs[r], val, len);\r\n}\r\nstatic int r820t_write(struct r820t_priv *priv, u8 reg, const u8 *val,\r\nint len)\r\n{\r\nint rc, size, pos = 0;\r\nshadow_store(priv, reg, val, len);\r\ndo {\r\nif (len > priv->cfg->max_i2c_msg_len - 1)\r\nsize = priv->cfg->max_i2c_msg_len - 1;\r\nelse\r\nsize = len;\r\npriv->buf[0] = reg;\r\nmemcpy(&priv->buf[1], &val[pos], size);\r\nrc = tuner_i2c_xfer_send(&priv->i2c_props, priv->buf, size + 1);\r\nif (rc != size + 1) {\r\ntuner_info("%s: i2c wr failed=%d reg=%02x len=%d: %*ph\n",\r\n__func__, rc, reg, size, size, &priv->buf[1]);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn -EREMOTEIO;\r\n}\r\ntuner_dbg("%s: i2c wr reg=%02x len=%d: %*ph\n",\r\n__func__, reg, size, size, &priv->buf[1]);\r\nreg += size;\r\nlen -= size;\r\npos += size;\r\n} while (len > 0);\r\nreturn 0;\r\n}\r\nstatic int r820t_write_reg(struct r820t_priv *priv, u8 reg, u8 val)\r\n{\r\nreturn r820t_write(priv, reg, &val, 1);\r\n}\r\nstatic int r820t_read_cache_reg(struct r820t_priv *priv, int reg)\r\n{\r\nreg -= REG_SHADOW_START;\r\nif (reg >= 0 && reg < NUM_REGS)\r\nreturn priv->regs[reg];\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic int r820t_write_reg_mask(struct r820t_priv *priv, u8 reg, u8 val,\r\nu8 bit_mask)\r\n{\r\nint rc = r820t_read_cache_reg(priv, reg);\r\nif (rc < 0)\r\nreturn rc;\r\nval = (rc & ~bit_mask) | (val & bit_mask);\r\nreturn r820t_write(priv, reg, &val, 1);\r\n}\r\nstatic int r820t_read(struct r820t_priv *priv, u8 reg, u8 *val, int len)\r\n{\r\nint rc, i;\r\nu8 *p = &priv->buf[1];\r\npriv->buf[0] = reg;\r\nrc = tuner_i2c_xfer_send_recv(&priv->i2c_props, priv->buf, 1, p, len);\r\nif (rc != len) {\r\ntuner_info("%s: i2c rd failed=%d reg=%02x len=%d: %*ph\n",\r\n__func__, rc, reg, len, len, p);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn -EREMOTEIO;\r\n}\r\nfor (i = 0; i < len; i++)\r\nval[i] = bitrev8(p[i]);\r\ntuner_dbg("%s: i2c rd reg=%02x len=%d: %*ph\n",\r\n__func__, reg, len, len, val);\r\nreturn 0;\r\n}\r\nstatic int r820t_set_mux(struct r820t_priv *priv, u32 freq)\r\n{\r\nconst struct r820t_freq_range *range;\r\nint i, rc;\r\nu8 val, reg08, reg09;\r\nfreq = freq / 1000000;\r\nfor (i = 0; i < ARRAY_SIZE(freq_ranges) - 1; i++) {\r\nif (freq < freq_ranges[i + 1].freq)\r\nbreak;\r\n}\r\nrange = &freq_ranges[i];\r\ntuner_dbg("set r820t range#%d for frequency %d MHz\n", i, freq);\r\nrc = r820t_write_reg_mask(priv, 0x17, range->open_d, 0x08);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x1a, range->rf_mux_ploy, 0xc3);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg(priv, 0x1b, range->tf_c);\r\nif (rc < 0)\r\nreturn rc;\r\nswitch (priv->xtal_cap_sel) {\r\ncase XTAL_LOW_CAP_30P:\r\ncase XTAL_LOW_CAP_20P:\r\nval = range->xtal_cap20p | 0x08;\r\nbreak;\r\ncase XTAL_LOW_CAP_10P:\r\nval = range->xtal_cap10p | 0x08;\r\nbreak;\r\ncase XTAL_HIGH_CAP_0P:\r\nval = range->xtal_cap0p | 0x00;\r\nbreak;\r\ndefault:\r\ncase XTAL_LOW_CAP_0P:\r\nval = range->xtal_cap0p | 0x08;\r\nbreak;\r\n}\r\nrc = r820t_write_reg_mask(priv, 0x10, val, 0x0b);\r\nif (rc < 0)\r\nreturn rc;\r\nif (priv->imr_done) {\r\nreg08 = priv->imr_data[range->imr_mem].gain_x;\r\nreg09 = priv->imr_data[range->imr_mem].phase_y;\r\n} else {\r\nreg08 = 0;\r\nreg09 = 0;\r\n}\r\nrc = r820t_write_reg_mask(priv, 0x08, reg08, 0x3f);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x09, reg09, 0x3f);\r\nreturn rc;\r\n}\r\nstatic int r820t_set_pll(struct r820t_priv *priv, enum v4l2_tuner_type type,\r\nu32 freq)\r\n{\r\nu32 vco_freq;\r\nint rc, i;\r\nunsigned sleep_time = 10000;\r\nu32 vco_fra;\r\nu32 vco_min = 1770000;\r\nu32 vco_max = vco_min * 2;\r\nu32 pll_ref;\r\nu16 n_sdm = 2;\r\nu16 sdm = 0;\r\nu8 mix_div = 2;\r\nu8 div_buf = 0;\r\nu8 div_num = 0;\r\nu8 refdiv2 = 0;\r\nu8 ni, si, nint, vco_fine_tune, val;\r\nu8 data[5];\r\nfreq = freq / 1000;\r\npll_ref = priv->cfg->xtal / 1000;\r\n#if 0\r\nif ((priv->cfg->rafael_chip == CHIP_R620D) ||\r\n(priv->cfg->rafael_chip == CHIP_R828D) ||\r\n(priv->cfg->rafael_chip == CHIP_R828)) {\r\nif (type != V4L2_TUNER_DIGITAL_TV) {\r\npll_ref /= 2;\r\nrefdiv2 = 0x10;\r\nsleep_time = 20000;\r\n}\r\n} else {\r\nif (priv->cfg->xtal > 24000000) {\r\npll_ref /= 2;\r\nrefdiv2 = 0x10;\r\n}\r\n}\r\n#endif\r\nrc = r820t_write_reg_mask(priv, 0x10, refdiv2, 0x10);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x1a, 0x00, 0x0c);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x12, 0x80, 0xe0);\r\nif (rc < 0)\r\nreturn rc;\r\nwhile (mix_div <= 64) {\r\nif (((freq * mix_div) >= vco_min) &&\r\n((freq * mix_div) < vco_max)) {\r\ndiv_buf = mix_div;\r\nwhile (div_buf > 2) {\r\ndiv_buf = div_buf >> 1;\r\ndiv_num++;\r\n}\r\nbreak;\r\n}\r\nmix_div = mix_div << 1;\r\n}\r\nrc = r820t_read(priv, 0x00, data, sizeof(data));\r\nif (rc < 0)\r\nreturn rc;\r\nvco_fine_tune = (data[4] & 0x30) >> 4;\r\ntuner_dbg("mix_div=%d div_num=%d vco_fine_tune=%d\n",\r\nmix_div, div_num, vco_fine_tune);\r\nif (priv->cfg->rafael_chip != CHIP_R828D) {\r\nif (vco_fine_tune > VCO_POWER_REF)\r\ndiv_num = div_num - 1;\r\nelse if (vco_fine_tune < VCO_POWER_REF)\r\ndiv_num = div_num + 1;\r\n}\r\nrc = r820t_write_reg_mask(priv, 0x10, div_num << 5, 0xe0);\r\nif (rc < 0)\r\nreturn rc;\r\nvco_freq = freq * mix_div;\r\nnint = vco_freq / (2 * pll_ref);\r\nvco_fra = vco_freq - 2 * pll_ref * nint;\r\nif (vco_fra < pll_ref / 64) {\r\nvco_fra = 0;\r\n} else if (vco_fra > pll_ref * 127 / 64) {\r\nvco_fra = 0;\r\nnint++;\r\n} else if ((vco_fra > pll_ref * 127 / 128) && (vco_fra < pll_ref)) {\r\nvco_fra = pll_ref * 127 / 128;\r\n} else if ((vco_fra > pll_ref) && (vco_fra < pll_ref * 129 / 128)) {\r\nvco_fra = pll_ref * 129 / 128;\r\n}\r\nni = (nint - 13) / 4;\r\nsi = nint - 4 * ni - 13;\r\nrc = r820t_write_reg(priv, 0x14, ni + (si << 6));\r\nif (rc < 0)\r\nreturn rc;\r\nif (!vco_fra)\r\nval = 0x08;\r\nelse\r\nval = 0x00;\r\nrc = r820t_write_reg_mask(priv, 0x12, val, 0x08);\r\nif (rc < 0)\r\nreturn rc;\r\nwhile (vco_fra > 1) {\r\nif (vco_fra > (2 * pll_ref / n_sdm)) {\r\nsdm = sdm + 32768 / (n_sdm / 2);\r\nvco_fra = vco_fra - 2 * pll_ref / n_sdm;\r\nif (n_sdm >= 0x8000)\r\nbreak;\r\n}\r\nn_sdm = n_sdm << 1;\r\n}\r\ntuner_dbg("freq %d kHz, pll ref %d%s, sdm=0x%04x\n",\r\nfreq, pll_ref, refdiv2 ? " / 2" : "", sdm);\r\nrc = r820t_write_reg(priv, 0x16, sdm >> 8);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg(priv, 0x15, sdm & 0xff);\r\nif (rc < 0)\r\nreturn rc;\r\nfor (i = 0; i < 2; i++) {\r\nusleep_range(sleep_time, sleep_time + 1000);\r\nrc = r820t_read(priv, 0x00, data, 3);\r\nif (rc < 0)\r\nreturn rc;\r\nif (data[2] & 0x40)\r\nbreak;\r\nif (!i) {\r\nrc = r820t_write_reg_mask(priv, 0x12, 0x60, 0xe0);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\n}\r\nif (!(data[2] & 0x40)) {\r\npriv->has_lock = false;\r\nreturn 0;\r\n}\r\npriv->has_lock = true;\r\ntuner_dbg("tuner has lock at frequency %d kHz\n", freq);\r\nrc = r820t_write_reg_mask(priv, 0x1a, 0x08, 0x08);\r\nreturn rc;\r\n}\r\nstatic int r820t_sysfreq_sel(struct r820t_priv *priv, u32 freq,\r\nenum v4l2_tuner_type type,\r\nv4l2_std_id std,\r\nu32 delsys)\r\n{\r\nint rc;\r\nu8 mixer_top, lna_top, cp_cur, div_buf_cur, lna_vth_l, mixer_vth_l;\r\nu8 air_cable1_in, cable2_in, pre_dect, lna_discharge, filter_cur;\r\ntuner_dbg("adjusting tuner parameters for the standard\n");\r\nswitch (delsys) {\r\ncase SYS_DVBT:\r\nif ((freq == 506000000) || (freq == 666000000) ||\r\n(freq == 818000000)) {\r\nmixer_top = 0x14;\r\nlna_top = 0xe5;\r\ncp_cur = 0x28;\r\ndiv_buf_cur = 0x20;\r\n} else {\r\nmixer_top = 0x24;\r\nlna_top = 0xe5;\r\ncp_cur = 0x38;\r\ndiv_buf_cur = 0x30;\r\n}\r\nlna_vth_l = 0x53;\r\nmixer_vth_l = 0x75;\r\nair_cable1_in = 0x00;\r\ncable2_in = 0x00;\r\npre_dect = 0x40;\r\nlna_discharge = 14;\r\nfilter_cur = 0x40;\r\nbreak;\r\ncase SYS_DVBT2:\r\nmixer_top = 0x24;\r\nlna_top = 0xe5;\r\nlna_vth_l = 0x53;\r\nmixer_vth_l = 0x75;\r\nair_cable1_in = 0x00;\r\ncable2_in = 0x00;\r\npre_dect = 0x40;\r\nlna_discharge = 14;\r\ncp_cur = 0x38;\r\ndiv_buf_cur = 0x30;\r\nfilter_cur = 0x40;\r\nbreak;\r\ncase SYS_ISDBT:\r\nmixer_top = 0x24;\r\nlna_top = 0xe5;\r\nlna_vth_l = 0x75;\r\nmixer_vth_l = 0x75;\r\nair_cable1_in = 0x00;\r\ncable2_in = 0x00;\r\npre_dect = 0x40;\r\nlna_discharge = 14;\r\ncp_cur = 0x38;\r\ndiv_buf_cur = 0x30;\r\nfilter_cur = 0x40;\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nmixer_top = 0x24;\r\nlna_top = 0xe5;\r\nlna_vth_l = 0x62;\r\nmixer_vth_l = 0x75;\r\nair_cable1_in = 0x60;\r\ncable2_in = 0x00;\r\npre_dect = 0x40;\r\nlna_discharge = 14;\r\ncp_cur = 0x38;\r\ndiv_buf_cur = 0x30;\r\nfilter_cur = 0x40;\r\nbreak;\r\ndefault:\r\nmixer_top = 0x24;\r\nlna_top = 0xe5;\r\nlna_vth_l = 0x53;\r\nmixer_vth_l = 0x75;\r\nair_cable1_in = 0x00;\r\ncable2_in = 0x00;\r\npre_dect = 0x40;\r\nlna_discharge = 14;\r\ncp_cur = 0x38;\r\ndiv_buf_cur = 0x30;\r\nfilter_cur = 0x40;\r\nbreak;\r\n}\r\nif (priv->cfg->use_diplexer &&\r\n((priv->cfg->rafael_chip == CHIP_R820T) ||\r\n(priv->cfg->rafael_chip == CHIP_R828S) ||\r\n(priv->cfg->rafael_chip == CHIP_R820C))) {\r\nif (freq > DIP_FREQ)\r\nair_cable1_in = 0x00;\r\nelse\r\nair_cable1_in = 0x60;\r\ncable2_in = 0x00;\r\n}\r\nif (priv->cfg->use_predetect) {\r\nrc = r820t_write_reg_mask(priv, 0x06, pre_dect, 0x40);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nrc = r820t_write_reg_mask(priv, 0x1d, lna_top, 0xc7);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x1c, mixer_top, 0xf8);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg(priv, 0x0d, lna_vth_l);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg(priv, 0x0e, mixer_vth_l);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x05, air_cable1_in, 0x60);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x06, cable2_in, 0x08);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x11, cp_cur, 0x38);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x17, div_buf_cur, 0x30);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x0a, filter_cur, 0x60);\r\nif (rc < 0)\r\nreturn rc;\r\ntuner_dbg("adjusting LNA parameters\n");\r\nif (type != V4L2_TUNER_ANALOG_TV) {\r\nrc = r820t_write_reg_mask(priv, 0x1d, 0, 0x38);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x1c, 0, 0x04);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x06, 0, 0x40);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x1a, 0x30, 0x30);\r\nif (rc < 0)\r\nreturn rc;\r\nmsleep(250);\r\nrc = r820t_write_reg_mask(priv, 0x1d, 0x18, 0x38);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x1c, mixer_top, 0x04);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x1e, lna_discharge, 0x1f);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x1a, 0x20, 0x30);\r\nif (rc < 0)\r\nreturn rc;\r\n} else {\r\nrc = r820t_write_reg_mask(priv, 0x06, 0, 0x40);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x1d, lna_top, 0x38);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x1c, mixer_top, 0x04);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x1e, lna_discharge, 0x1f);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x1a, 0x00, 0x30);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x10, 0x00, 0x04);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int r820t_set_tv_standard(struct r820t_priv *priv,\r\nunsigned bw,\r\nenum v4l2_tuner_type type,\r\nv4l2_std_id std, u32 delsys)\r\n{\r\nint rc, i;\r\nu32 if_khz, filt_cal_lo;\r\nu8 data[5], val;\r\nu8 filt_gain, img_r, filt_q, hp_cor, ext_enable, loop_through;\r\nu8 lt_att, flt_ext_widest, polyfil_cur;\r\nbool need_calibration;\r\ntuner_dbg("selecting the delivery system\n");\r\nif (delsys == SYS_ISDBT) {\r\nif_khz = 4063;\r\nfilt_cal_lo = 59000;\r\nfilt_gain = 0x10;\r\nimg_r = 0x00;\r\nfilt_q = 0x10;\r\nhp_cor = 0x6a;\r\next_enable = 0x40;\r\nloop_through = 0x00;\r\nlt_att = 0x00;\r\nflt_ext_widest = 0x80;\r\npolyfil_cur = 0x60;\r\n} else if (delsys == SYS_DVBC_ANNEX_A) {\r\nif_khz = 5070;\r\nfilt_cal_lo = 73500;\r\nfilt_gain = 0x10;\r\nimg_r = 0x00;\r\nfilt_q = 0x10;\r\nhp_cor = 0x0b;\r\next_enable = 0x40;\r\nloop_through = 0x00;\r\nlt_att = 0x00;\r\nflt_ext_widest = 0x00;\r\npolyfil_cur = 0x60;\r\n} else if (delsys == SYS_DVBC_ANNEX_C) {\r\nif_khz = 4063;\r\nfilt_cal_lo = 55000;\r\nfilt_gain = 0x10;\r\nimg_r = 0x00;\r\nfilt_q = 0x10;\r\nhp_cor = 0x6a;\r\next_enable = 0x40;\r\nloop_through = 0x00;\r\nlt_att = 0x00;\r\nflt_ext_widest = 0x80;\r\npolyfil_cur = 0x60;\r\n} else {\r\nif (bw <= 6) {\r\nif_khz = 3570;\r\nfilt_cal_lo = 56000;\r\nfilt_gain = 0x10;\r\nimg_r = 0x00;\r\nfilt_q = 0x10;\r\nhp_cor = 0x6b;\r\next_enable = 0x60;\r\nloop_through = 0x00;\r\nlt_att = 0x00;\r\nflt_ext_widest = 0x00;\r\npolyfil_cur = 0x60;\r\n} else if (bw == 7) {\r\n#if 0\r\nif_khz = 4070;\r\nfilt_cal_lo = 60000;\r\nfilt_gain = 0x10;\r\nimg_r = 0x00;\r\nfilt_q = 0x10;\r\nhp_cor = 0x2b;\r\next_enable = 0x60;\r\nloop_through = 0x00;\r\nlt_att = 0x00;\r\nflt_ext_widest = 0x00;\r\npolyfil_cur = 0x60;\r\n#endif\r\nif_khz = 4570;\r\nfilt_cal_lo = 63000;\r\nfilt_gain = 0x10;\r\nimg_r = 0x00;\r\nfilt_q = 0x10;\r\nhp_cor = 0x2a;\r\next_enable = 0x60;\r\nloop_through = 0x00;\r\nlt_att = 0x00;\r\nflt_ext_widest = 0x00;\r\npolyfil_cur = 0x60;\r\n} else {\r\nif_khz = 4570;\r\nfilt_cal_lo = 68500;\r\nfilt_gain = 0x10;\r\nimg_r = 0x00;\r\nfilt_q = 0x10;\r\nhp_cor = 0x0b;\r\next_enable = 0x60;\r\nloop_through = 0x00;\r\nlt_att = 0x00;\r\nflt_ext_widest = 0x00;\r\npolyfil_cur = 0x60;\r\n}\r\n}\r\nmemcpy(priv->regs, r820t_init_array, sizeof(r820t_init_array));\r\nif (priv->imr_done)\r\nval = 1 | priv->xtal_cap_sel << 1;\r\nelse\r\nval = 0;\r\nrc = r820t_write_reg_mask(priv, 0x0c, val, 0x0f);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x13, VER_NUM, 0x3f);\r\nif (rc < 0)\r\nreturn rc;\r\nif (type != V4L2_TUNER_ANALOG_TV) {\r\nrc = r820t_write_reg_mask(priv, 0x1d, 0x00, 0x38);\r\nif (rc < 0)\r\nreturn rc;\r\nusleep_range(1000, 2000);\r\n}\r\npriv->int_freq = if_khz * 1000;\r\nif (type != priv->type)\r\nneed_calibration = true;\r\nelse if ((type == V4L2_TUNER_ANALOG_TV) && (std != priv->std))\r\nneed_calibration = true;\r\nelse if ((type == V4L2_TUNER_DIGITAL_TV) &&\r\n((delsys != priv->delsys) || bw != priv->bw))\r\nneed_calibration = true;\r\nelse\r\nneed_calibration = false;\r\nif (need_calibration) {\r\ntuner_dbg("calibrating the tuner\n");\r\nfor (i = 0; i < 2; i++) {\r\nrc = r820t_write_reg_mask(priv, 0x0b, hp_cor, 0x60);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x0f, 0x04, 0x04);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x10, 0x00, 0x03);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_set_pll(priv, type, filt_cal_lo * 1000);\r\nif (rc < 0 || !priv->has_lock)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x0b, 0x10, 0x10);\r\nif (rc < 0)\r\nreturn rc;\r\nusleep_range(1000, 2000);\r\nrc = r820t_write_reg_mask(priv, 0x0b, 0x00, 0x10);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x0f, 0x00, 0x04);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_read(priv, 0x00, data, sizeof(data));\r\nif (rc < 0)\r\nreturn rc;\r\npriv->fil_cal_code = data[4] & 0x0f;\r\nif (priv->fil_cal_code && priv->fil_cal_code != 0x0f)\r\nbreak;\r\n}\r\nif (priv->fil_cal_code == 0x0f)\r\npriv->fil_cal_code = 0;\r\n}\r\nrc = r820t_write_reg_mask(priv, 0x0a,\r\nfilt_q | priv->fil_cal_code, 0x1f);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x0b, hp_cor, 0xef);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x07, img_r, 0x80);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x06, filt_gain, 0x30);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x1e, ext_enable, 0x60);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x05, loop_through, 0x80);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x1f, lt_att, 0x80);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x0f, flt_ext_widest, 0x80);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x19, polyfil_cur, 0x60);\r\nif (rc < 0)\r\nreturn rc;\r\npriv->delsys = delsys;\r\npriv->type = type;\r\npriv->std = std;\r\npriv->bw = bw;\r\nreturn 0;\r\n}\r\nstatic int r820t_read_gain(struct r820t_priv *priv)\r\n{\r\nu8 data[4];\r\nint rc;\r\nrc = r820t_read(priv, 0x00, data, sizeof(data));\r\nif (rc < 0)\r\nreturn rc;\r\nreturn ((data[3] & 0x08) << 1) + ((data[3] & 0xf0) >> 4);\r\n}\r\nstatic int generic_set_freq(struct dvb_frontend *fe,\r\nu32 freq ,\r\nunsigned bw,\r\nenum v4l2_tuner_type type,\r\nv4l2_std_id std, u32 delsys)\r\n{\r\nstruct r820t_priv *priv = fe->tuner_priv;\r\nint rc;\r\nu32 lo_freq;\r\ntuner_dbg("should set frequency to %d kHz, bw %d MHz\n",\r\nfreq / 1000, bw);\r\nrc = r820t_set_tv_standard(priv, bw, type, std, delsys);\r\nif (rc < 0)\r\ngoto err;\r\nif ((type == V4L2_TUNER_ANALOG_TV) && (std == V4L2_STD_SECAM_LC))\r\nlo_freq = freq - priv->int_freq;\r\nelse\r\nlo_freq = freq + priv->int_freq;\r\nrc = r820t_set_mux(priv, lo_freq);\r\nif (rc < 0)\r\ngoto err;\r\nrc = r820t_set_pll(priv, type, lo_freq);\r\nif (rc < 0 || !priv->has_lock)\r\ngoto err;\r\nrc = r820t_sysfreq_sel(priv, freq, type, std, delsys);\r\nif (rc < 0)\r\ngoto err;\r\ntuner_dbg("%s: PLL locked on frequency %d Hz, gain=%d\n",\r\n__func__, freq, r820t_read_gain(priv));\r\nerr:\r\nif (rc < 0)\r\ntuner_dbg("%s: failed=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nstatic int r820t_standby(struct r820t_priv *priv)\r\n{\r\nint rc;\r\nif (!priv->init_done)\r\nreturn 0;\r\nrc = r820t_write_reg(priv, 0x06, 0xb1);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg(priv, 0x05, 0x03);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg(priv, 0x07, 0x3a);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg(priv, 0x08, 0x40);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg(priv, 0x09, 0xc0);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg(priv, 0x0a, 0x36);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg(priv, 0x0c, 0x35);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg(priv, 0x0f, 0x68);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg(priv, 0x11, 0x03);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg(priv, 0x17, 0xf4);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg(priv, 0x19, 0x0c);\r\npriv->type = -1;\r\nreturn rc;\r\n}\r\nstatic int r820t_xtal_check(struct r820t_priv *priv)\r\n{\r\nint rc, i;\r\nu8 data[3], val;\r\nmemcpy(priv->regs, r820t_init_array, sizeof(r820t_init_array));\r\nrc = r820t_write_reg_mask(priv, 0x10, 0x0b, 0x0b);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x1a, 0x00, 0x0c);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x13, 0x7f, 0x7f);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x13, 0x00, 0x40);\r\nif (rc < 0)\r\nreturn rc;\r\nfor (i = 0; i < ARRAY_SIZE(r820t_xtal_capacitor); i++) {\r\nrc = r820t_write_reg_mask(priv, 0x10,\r\nr820t_xtal_capacitor[i][0], 0x1b);\r\nif (rc < 0)\r\nreturn rc;\r\nusleep_range(5000, 6000);\r\nrc = r820t_read(priv, 0x00, data, sizeof(data));\r\nif (rc < 0)\r\nreturn rc;\r\nif (!(data[2] & 0x40))\r\ncontinue;\r\nval = data[2] & 0x3f;\r\nif (priv->cfg->xtal == 16000000 && (val > 29 || val < 23))\r\nbreak;\r\nif (val != 0x3f)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(r820t_xtal_capacitor))\r\nreturn -EINVAL;\r\nreturn r820t_xtal_capacitor[i][1];\r\n}\r\nstatic int r820t_imr_prepare(struct r820t_priv *priv)\r\n{\r\nint rc;\r\nmemcpy(priv->regs, r820t_init_array, sizeof(r820t_init_array));\r\nrc = r820t_write_reg_mask(priv, 0x05, 0x20, 0x20);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x07, 0, 0x10);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x0a, 0x0f, 0x0f);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x0b, 0x60, 0x6f);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x0c, 0x0b, 0x9f);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x0f, 0, 0x08);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x18, 0x10, 0x10);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x1c, 0x02, 0x02);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x1e, 0x80, 0x80);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x06, 0x20, 0x20);\r\nreturn rc;\r\n}\r\nstatic int r820t_multi_read(struct r820t_priv *priv)\r\n{\r\nint rc, i;\r\nu16 sum = 0;\r\nu8 data[2], min = 255, max = 0;\r\nusleep_range(5000, 6000);\r\nfor (i = 0; i < 6; i++) {\r\nrc = r820t_read(priv, 0x00, data, sizeof(data));\r\nif (rc < 0)\r\nreturn rc;\r\nsum += data[1];\r\nif (data[1] < min)\r\nmin = data[1];\r\nif (data[1] > max)\r\nmax = data[1];\r\n}\r\nrc = sum - max - min;\r\nreturn rc;\r\n}\r\nstatic int r820t_imr_cross(struct r820t_priv *priv,\r\nstruct r820t_sect_type iq_point[3],\r\nu8 *x_direct)\r\n{\r\nstruct r820t_sect_type cross[5];\r\nstruct r820t_sect_type tmp;\r\nint i, rc;\r\nu8 reg08, reg09;\r\nreg08 = r820t_read_cache_reg(priv, 8) & 0xc0;\r\nreg09 = r820t_read_cache_reg(priv, 9) & 0xc0;\r\ntmp.gain_x = 0;\r\ntmp.phase_y = 0;\r\ntmp.value = 255;\r\nfor (i = 0; i < 5; i++) {\r\nswitch (i) {\r\ncase 0:\r\ncross[i].gain_x = reg08;\r\ncross[i].phase_y = reg09;\r\nbreak;\r\ncase 1:\r\ncross[i].gain_x = reg08;\r\ncross[i].phase_y = reg09 + 1;\r\nbreak;\r\ncase 2:\r\ncross[i].gain_x = reg08;\r\ncross[i].phase_y = (reg09 | 0x20) + 1;\r\nbreak;\r\ncase 3:\r\ncross[i].gain_x = reg08 + 1;\r\ncross[i].phase_y = reg09;\r\nbreak;\r\ndefault:\r\ncross[i].gain_x = (reg08 | 0x20) + 1;\r\ncross[i].phase_y = reg09;\r\n}\r\nrc = r820t_write_reg(priv, 0x08, cross[i].gain_x);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg(priv, 0x09, cross[i].phase_y);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_multi_read(priv);\r\nif (rc < 0)\r\nreturn rc;\r\ncross[i].value = rc;\r\nif (cross[i].value < tmp.value)\r\ntmp = cross[i];\r\n}\r\nif ((tmp.phase_y & 0x1f) == 1) {\r\n*x_direct = 0;\r\niq_point[0] = cross[0];\r\niq_point[1] = cross[1];\r\niq_point[2] = cross[2];\r\n} else {\r\n*x_direct = 1;\r\niq_point[0] = cross[0];\r\niq_point[1] = cross[3];\r\niq_point[2] = cross[4];\r\n}\r\nreturn 0;\r\n}\r\nstatic void r820t_compre_cor(struct r820t_sect_type iq[3])\r\n{\r\nint i;\r\nfor (i = 3; i > 0; i--) {\r\nif (iq[0].value > iq[i - 1].value)\r\nswap(iq[0], iq[i - 1]);\r\n}\r\n}\r\nstatic int r820t_compre_step(struct r820t_priv *priv,\r\nstruct r820t_sect_type iq[3], u8 reg)\r\n{\r\nint rc;\r\nstruct r820t_sect_type tmp;\r\ntmp.phase_y = iq[0].phase_y;\r\ntmp.gain_x = iq[0].gain_x;\r\nwhile (((tmp.gain_x & 0x1f) < IMR_TRIAL) &&\r\n((tmp.phase_y & 0x1f) < IMR_TRIAL)) {\r\nif (reg == 0x08)\r\ntmp.gain_x++;\r\nelse\r\ntmp.phase_y++;\r\nrc = r820t_write_reg(priv, 0x08, tmp.gain_x);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg(priv, 0x09, tmp.phase_y);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_multi_read(priv);\r\nif (rc < 0)\r\nreturn rc;\r\ntmp.value = rc;\r\nif (tmp.value <= iq[0].value) {\r\niq[0].gain_x = tmp.gain_x;\r\niq[0].phase_y = tmp.phase_y;\r\niq[0].value = tmp.value;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int r820t_iq_tree(struct r820t_priv *priv,\r\nstruct r820t_sect_type iq[3],\r\nu8 fix_val, u8 var_val, u8 fix_reg)\r\n{\r\nint rc, i;\r\nu8 tmp, var_reg;\r\nif (fix_reg == 0x08)\r\nvar_reg = 0x09;\r\nelse\r\nvar_reg = 0x08;\r\nfor (i = 0; i < 3; i++) {\r\nrc = r820t_write_reg(priv, fix_reg, fix_val);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg(priv, var_reg, var_val);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_multi_read(priv);\r\nif (rc < 0)\r\nreturn rc;\r\niq[i].value = rc;\r\nif (fix_reg == 0x08) {\r\niq[i].gain_x = fix_val;\r\niq[i].phase_y = var_val;\r\n} else {\r\niq[i].phase_y = fix_val;\r\niq[i].gain_x = var_val;\r\n}\r\nif (i == 0) {\r\nvar_val++;\r\n} else if (i == 1) {\r\nif ((var_val & 0x1f) < 0x02) {\r\ntmp = 2 - (var_val & 0x1f);\r\nif (var_val & 0x20) {\r\nvar_val &= 0xc0;\r\nvar_val |= tmp;\r\n} else {\r\nvar_val |= 0x20 | tmp;\r\n}\r\n} else {\r\nvar_val -= 2;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int r820t_section(struct r820t_priv *priv,\r\nstruct r820t_sect_type *iq_point)\r\n{\r\nint rc;\r\nstruct r820t_sect_type compare_iq[3], compare_bet[3];\r\nif (!(iq_point->gain_x & 0x1f))\r\ncompare_iq[0].gain_x = ((iq_point->gain_x) & 0xdf) + 1;\r\nelse\r\ncompare_iq[0].gain_x = iq_point->gain_x - 1;\r\ncompare_iq[0].phase_y = iq_point->phase_y;\r\nrc = r820t_iq_tree(priv, compare_iq, compare_iq[0].gain_x,\r\ncompare_iq[0].phase_y, 0x08);\r\nif (rc < 0)\r\nreturn rc;\r\nr820t_compre_cor(compare_iq);\r\ncompare_bet[0] = compare_iq[0];\r\ncompare_iq[0].gain_x = iq_point->gain_x;\r\ncompare_iq[0].phase_y = iq_point->phase_y;\r\nrc = r820t_iq_tree(priv, compare_iq, compare_iq[0].gain_x,\r\ncompare_iq[0].phase_y, 0x08);\r\nif (rc < 0)\r\nreturn rc;\r\nr820t_compre_cor(compare_iq);\r\ncompare_bet[1] = compare_iq[0];\r\nif ((iq_point->gain_x & 0x1f) == 0x00)\r\ncompare_iq[0].gain_x = ((iq_point->gain_x) | 0x20) + 1;\r\nelse\r\ncompare_iq[0].gain_x = iq_point->gain_x + 1;\r\ncompare_iq[0].phase_y = iq_point->phase_y;\r\nrc = r820t_iq_tree(priv, compare_iq, compare_iq[0].gain_x,\r\ncompare_iq[0].phase_y, 0x08);\r\nif (rc < 0)\r\nreturn rc;\r\nr820t_compre_cor(compare_iq);\r\ncompare_bet[2] = compare_iq[0];\r\nr820t_compre_cor(compare_bet);\r\n*iq_point = compare_bet[0];\r\nreturn 0;\r\n}\r\nstatic int r820t_vga_adjust(struct r820t_priv *priv)\r\n{\r\nint rc;\r\nu8 vga_count;\r\nfor (vga_count = 12; vga_count < 16; vga_count++) {\r\nrc = r820t_write_reg_mask(priv, 0x0c, vga_count, 0x0f);\r\nif (rc < 0)\r\nreturn rc;\r\nusleep_range(10000, 11000);\r\nrc = r820t_multi_read(priv);\r\nif (rc < 0)\r\nreturn rc;\r\nif (rc > 40 * 4)\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int r820t_iq(struct r820t_priv *priv, struct r820t_sect_type *iq_pont)\r\n{\r\nstruct r820t_sect_type compare_iq[3];\r\nint rc;\r\nu8 x_direction = 0;\r\nu8 dir_reg, other_reg;\r\nr820t_vga_adjust(priv);\r\nrc = r820t_imr_cross(priv, compare_iq, &x_direction);\r\nif (rc < 0)\r\nreturn rc;\r\nif (x_direction == 1) {\r\ndir_reg = 0x08;\r\nother_reg = 0x09;\r\n} else {\r\ndir_reg = 0x09;\r\nother_reg = 0x08;\r\n}\r\nr820t_compre_cor(compare_iq);\r\nrc = r820t_compre_step(priv, compare_iq, dir_reg);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_iq_tree(priv, compare_iq, compare_iq[0].gain_x,\r\ncompare_iq[0].phase_y, dir_reg);\r\nif (rc < 0)\r\nreturn rc;\r\nr820t_compre_cor(compare_iq);\r\nrc = r820t_compre_step(priv, compare_iq, other_reg);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_iq_tree(priv, compare_iq, compare_iq[0].gain_x,\r\ncompare_iq[0].phase_y, other_reg);\r\nif (rc < 0)\r\nreturn rc;\r\nr820t_compre_cor(compare_iq);\r\nrc = r820t_section(priv, compare_iq);\r\n*iq_pont = compare_iq[0];\r\nrc = r820t_write_reg_mask(priv, 0x08, 0, 0x3f);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg_mask(priv, 0x09, 0, 0x3f);\r\nreturn rc;\r\n}\r\nstatic int r820t_f_imr(struct r820t_priv *priv, struct r820t_sect_type *iq_pont)\r\n{\r\nint rc;\r\nr820t_vga_adjust(priv);\r\nrc = r820t_section(priv, iq_pont);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int r820t_imr(struct r820t_priv *priv, unsigned imr_mem, bool im_flag)\r\n{\r\nstruct r820t_sect_type imr_point;\r\nint rc;\r\nu32 ring_vco, ring_freq, ring_ref;\r\nu8 n_ring, n;\r\nint reg18, reg19, reg1f;\r\nif (priv->cfg->xtal > 24000000)\r\nring_ref = priv->cfg->xtal / 2000;\r\nelse\r\nring_ref = priv->cfg->xtal / 1000;\r\nn_ring = 15;\r\nfor (n = 0; n < 16; n++) {\r\nif ((16 + n) * 8 * ring_ref >= 3100000) {\r\nn_ring = n;\r\nbreak;\r\n}\r\n}\r\nreg18 = r820t_read_cache_reg(priv, 0x18);\r\nreg19 = r820t_read_cache_reg(priv, 0x19);\r\nreg1f = r820t_read_cache_reg(priv, 0x1f);\r\nreg18 &= 0xf0;\r\nreg18 |= n_ring;\r\nring_vco = (16 + n_ring) * 8 * ring_ref;\r\nreg18 &= 0xdf;\r\nreg19 &= 0xfc;\r\nreg1f &= 0xfc;\r\nswitch (imr_mem) {\r\ncase 0:\r\nring_freq = ring_vco / 48;\r\nreg18 |= 0x20;\r\nreg19 |= 0x03;\r\nreg1f |= 0x02;\r\nbreak;\r\ncase 1:\r\nring_freq = ring_vco / 16;\r\nreg18 |= 0x00;\r\nreg19 |= 0x02;\r\nreg1f |= 0x00;\r\nbreak;\r\ncase 2:\r\nring_freq = ring_vco / 8;\r\nreg18 |= 0x00;\r\nreg19 |= 0x01;\r\nreg1f |= 0x03;\r\nbreak;\r\ncase 3:\r\nring_freq = ring_vco / 6;\r\nreg18 |= 0x20;\r\nreg19 |= 0x00;\r\nreg1f |= 0x03;\r\nbreak;\r\ncase 4:\r\nring_freq = ring_vco / 4;\r\nreg18 |= 0x00;\r\nreg19 |= 0x00;\r\nreg1f |= 0x01;\r\nbreak;\r\ndefault:\r\nring_freq = ring_vco / 4;\r\nreg18 |= 0x00;\r\nreg19 |= 0x00;\r\nreg1f |= 0x01;\r\nbreak;\r\n}\r\nrc = r820t_write_reg(priv, 0x18, reg18);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg(priv, 0x19, reg19);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_write_reg(priv, 0x1f, reg1f);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_set_mux(priv, (ring_freq - 5300) * 1000);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_set_pll(priv, V4L2_TUNER_DIGITAL_TV,\r\n(ring_freq - 5300) * 1000);\r\nif (!priv->has_lock)\r\nrc = -EINVAL;\r\nif (rc < 0)\r\nreturn rc;\r\nif (im_flag) {\r\nrc = r820t_iq(priv, &imr_point);\r\n} else {\r\nimr_point.gain_x = priv->imr_data[3].gain_x;\r\nimr_point.phase_y = priv->imr_data[3].phase_y;\r\nimr_point.value = priv->imr_data[3].value;\r\nrc = r820t_f_imr(priv, &imr_point);\r\n}\r\nif (rc < 0)\r\nreturn rc;\r\nswitch (imr_mem) {\r\ncase 0:\r\npriv->imr_data[0].gain_x = imr_point.gain_x;\r\npriv->imr_data[0].phase_y = imr_point.phase_y;\r\npriv->imr_data[0].value = imr_point.value;\r\nbreak;\r\ncase 1:\r\npriv->imr_data[1].gain_x = imr_point.gain_x;\r\npriv->imr_data[1].phase_y = imr_point.phase_y;\r\npriv->imr_data[1].value = imr_point.value;\r\nbreak;\r\ncase 2:\r\npriv->imr_data[2].gain_x = imr_point.gain_x;\r\npriv->imr_data[2].phase_y = imr_point.phase_y;\r\npriv->imr_data[2].value = imr_point.value;\r\nbreak;\r\ncase 3:\r\npriv->imr_data[3].gain_x = imr_point.gain_x;\r\npriv->imr_data[3].phase_y = imr_point.phase_y;\r\npriv->imr_data[3].value = imr_point.value;\r\nbreak;\r\ncase 4:\r\npriv->imr_data[4].gain_x = imr_point.gain_x;\r\npriv->imr_data[4].phase_y = imr_point.phase_y;\r\npriv->imr_data[4].value = imr_point.value;\r\nbreak;\r\ndefault:\r\npriv->imr_data[4].gain_x = imr_point.gain_x;\r\npriv->imr_data[4].phase_y = imr_point.phase_y;\r\npriv->imr_data[4].value = imr_point.value;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int r820t_imr_callibrate(struct r820t_priv *priv)\r\n{\r\nint rc, i;\r\nint xtal_cap = 0;\r\nif (priv->init_done)\r\nreturn 0;\r\nif ((priv->cfg->rafael_chip == CHIP_R820T) ||\r\n(priv->cfg->rafael_chip == CHIP_R828S) ||\r\n(priv->cfg->rafael_chip == CHIP_R820C)) {\r\npriv->xtal_cap_sel = XTAL_HIGH_CAP_0P;\r\n} else {\r\nrc = r820t_write(priv, 0x05,\r\nr820t_init_array, sizeof(r820t_init_array));\r\nif (rc < 0)\r\nreturn rc;\r\nfor (i = 0; i < 3; i++) {\r\nrc = r820t_xtal_check(priv);\r\nif (rc < 0)\r\nreturn rc;\r\nif (!i || rc > xtal_cap)\r\nxtal_cap = rc;\r\n}\r\npriv->xtal_cap_sel = xtal_cap;\r\n}\r\nif (no_imr_cal) {\r\npriv->init_done = true;\r\nreturn 0;\r\n}\r\nrc = r820t_write(priv, 0x05,\r\nr820t_init_array, sizeof(r820t_init_array));\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_imr_prepare(priv);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_imr(priv, 3, true);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_imr(priv, 1, false);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_imr(priv, 0, false);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_imr(priv, 2, false);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = r820t_imr(priv, 4, false);\r\nif (rc < 0)\r\nreturn rc;\r\npriv->init_done = true;\r\npriv->imr_done = true;\r\nreturn 0;\r\n}\r\nstatic int r820t_init(struct dvb_frontend *fe)\r\n{\r\nstruct r820t_priv *priv = fe->tuner_priv;\r\nint rc;\r\ntuner_dbg("%s:\n", __func__);\r\nmutex_lock(&priv->lock);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nrc = r820t_imr_callibrate(priv);\r\nif (rc < 0)\r\ngoto err;\r\nrc = r820t_write(priv, 0x05,\r\nr820t_init_array, sizeof(r820t_init_array));\r\nerr:\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nmutex_unlock(&priv->lock);\r\nif (rc < 0)\r\ntuner_dbg("%s: failed=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nstatic int r820t_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct r820t_priv *priv = fe->tuner_priv;\r\nint rc;\r\ntuner_dbg("%s:\n", __func__);\r\nmutex_lock(&priv->lock);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nrc = r820t_standby(priv);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nmutex_unlock(&priv->lock);\r\ntuner_dbg("%s: failed=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nstatic int r820t_set_analog_freq(struct dvb_frontend *fe,\r\nstruct analog_parameters *p)\r\n{\r\nstruct r820t_priv *priv = fe->tuner_priv;\r\nunsigned bw;\r\nint rc;\r\ntuner_dbg("%s called\n", __func__);\r\nif (!p->std)\r\np->std = V4L2_STD_MN;\r\nif ((p->std == V4L2_STD_PAL_M) || (p->std == V4L2_STD_NTSC))\r\nbw = 6;\r\nelse\r\nbw = 8;\r\nmutex_lock(&priv->lock);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nrc = generic_set_freq(fe, 62500l * p->frequency, bw,\r\nV4L2_TUNER_ANALOG_TV, p->std, SYS_UNDEFINED);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nmutex_unlock(&priv->lock);\r\nreturn rc;\r\n}\r\nstatic int r820t_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct r820t_priv *priv = fe->tuner_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint rc;\r\nunsigned bw;\r\ntuner_dbg("%s: delivery_system=%d frequency=%d bandwidth_hz=%d\n",\r\n__func__, c->delivery_system, c->frequency, c->bandwidth_hz);\r\nmutex_lock(&priv->lock);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nbw = (c->bandwidth_hz + 500000) / 1000000;\r\nif (!bw)\r\nbw = 8;\r\nrc = generic_set_freq(fe, c->frequency, bw,\r\nV4L2_TUNER_DIGITAL_TV, 0, c->delivery_system);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nmutex_unlock(&priv->lock);\r\nif (rc)\r\ntuner_dbg("%s: failed=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nstatic int r820t_signal(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct r820t_priv *priv = fe->tuner_priv;\r\nint rc = 0;\r\nmutex_lock(&priv->lock);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (priv->has_lock) {\r\nrc = r820t_read_gain(priv);\r\nif (rc < 0)\r\ngoto err;\r\n*strength = (45 - rc) << 4 | 0xff;\r\nif (*strength == 0xff)\r\n*strength = 0;\r\n} else {\r\n*strength = 0;\r\n}\r\nerr:\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nmutex_unlock(&priv->lock);\r\ntuner_dbg("%s: %s, gain=%d strength=%d\n",\r\n__func__,\r\npriv->has_lock ? "PLL locked" : "no signal",\r\nrc, *strength);\r\nreturn 0;\r\n}\r\nstatic int r820t_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct r820t_priv *priv = fe->tuner_priv;\r\ntuner_dbg("%s:\n", __func__);\r\n*frequency = priv->int_freq;\r\nreturn 0;\r\n}\r\nstatic void r820t_release(struct dvb_frontend *fe)\r\n{\r\nstruct r820t_priv *priv = fe->tuner_priv;\r\ntuner_dbg("%s:\n", __func__);\r\nmutex_lock(&r820t_list_mutex);\r\nif (priv)\r\nhybrid_tuner_release_state(priv);\r\nmutex_unlock(&r820t_list_mutex);\r\nfe->tuner_priv = NULL;\r\n}\r\nstruct dvb_frontend *r820t_attach(struct dvb_frontend *fe,\r\nstruct i2c_adapter *i2c,\r\nconst struct r820t_config *cfg)\r\n{\r\nstruct r820t_priv *priv;\r\nint rc = -ENODEV;\r\nu8 data[5];\r\nint instance;\r\nmutex_lock(&r820t_list_mutex);\r\ninstance = hybrid_tuner_request_state(struct r820t_priv, priv,\r\nhybrid_tuner_instance_list,\r\ni2c, cfg->i2c_addr,\r\n"r820t");\r\nswitch (instance) {\r\ncase 0:\r\ngoto err_no_gate;\r\ncase 1:\r\npriv->cfg = cfg;\r\nmutex_init(&priv->lock);\r\nfe->tuner_priv = priv;\r\nbreak;\r\ncase 2:\r\nfe->tuner_priv = priv;\r\nbreak;\r\n}\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nrc = r820t_read(priv, 0x00, data, sizeof(data));\r\nif (rc < 0)\r\ngoto err;\r\nrc = r820t_sleep(fe);\r\nif (rc < 0)\r\ngoto err;\r\ntuner_info("Rafael Micro r820t successfully identified\n");\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nmutex_unlock(&r820t_list_mutex);\r\nmemcpy(&fe->ops.tuner_ops, &r820t_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\nreturn fe;\r\nerr:\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nerr_no_gate:\r\nmutex_unlock(&r820t_list_mutex);\r\ntuner_info("%s: failed=%d\n", __func__, rc);\r\nr820t_release(fe);\r\nreturn NULL;\r\n}
