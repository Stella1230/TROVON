static inline struct spi_gpio *__pure\r\nspi_to_spi_gpio(const struct spi_device *spi)\r\n{\r\nconst struct spi_bitbang *bang;\r\nstruct spi_gpio *spi_gpio;\r\nbang = spi_master_get_devdata(spi->master);\r\nspi_gpio = container_of(bang, struct spi_gpio, bitbang);\r\nreturn spi_gpio;\r\n}\r\nstatic inline struct spi_gpio_platform_data *__pure\r\nspi_to_pdata(const struct spi_device *spi)\r\n{\r\nreturn &spi_to_spi_gpio(spi)->pdata;\r\n}\r\nstatic inline void setsck(const struct spi_device *spi, int is_on)\r\n{\r\ngpio_set_value_cansleep(SPI_SCK_GPIO, is_on);\r\n}\r\nstatic inline void setmosi(const struct spi_device *spi, int is_on)\r\n{\r\ngpio_set_value_cansleep(SPI_MOSI_GPIO, is_on);\r\n}\r\nstatic inline int getmiso(const struct spi_device *spi)\r\n{\r\nreturn !!gpio_get_value_cansleep(SPI_MISO_GPIO);\r\n}\r\nstatic u32 spi_gpio_txrx_word_mode0(struct spi_device *spi,\r\nunsigned nsecs, u32 word, u8 bits)\r\n{\r\nreturn bitbang_txrx_be_cpha0(spi, nsecs, 0, 0, word, bits);\r\n}\r\nstatic u32 spi_gpio_txrx_word_mode1(struct spi_device *spi,\r\nunsigned nsecs, u32 word, u8 bits)\r\n{\r\nreturn bitbang_txrx_be_cpha1(spi, nsecs, 0, 0, word, bits);\r\n}\r\nstatic u32 spi_gpio_txrx_word_mode2(struct spi_device *spi,\r\nunsigned nsecs, u32 word, u8 bits)\r\n{\r\nreturn bitbang_txrx_be_cpha0(spi, nsecs, 1, 0, word, bits);\r\n}\r\nstatic u32 spi_gpio_txrx_word_mode3(struct spi_device *spi,\r\nunsigned nsecs, u32 word, u8 bits)\r\n{\r\nreturn bitbang_txrx_be_cpha1(spi, nsecs, 1, 0, word, bits);\r\n}\r\nstatic u32 spi_gpio_spec_txrx_word_mode0(struct spi_device *spi,\r\nunsigned nsecs, u32 word, u8 bits)\r\n{\r\nunsigned flags = spi->master->flags;\r\nreturn bitbang_txrx_be_cpha0(spi, nsecs, 0, flags, word, bits);\r\n}\r\nstatic u32 spi_gpio_spec_txrx_word_mode1(struct spi_device *spi,\r\nunsigned nsecs, u32 word, u8 bits)\r\n{\r\nunsigned flags = spi->master->flags;\r\nreturn bitbang_txrx_be_cpha1(spi, nsecs, 0, flags, word, bits);\r\n}\r\nstatic u32 spi_gpio_spec_txrx_word_mode2(struct spi_device *spi,\r\nunsigned nsecs, u32 word, u8 bits)\r\n{\r\nunsigned flags = spi->master->flags;\r\nreturn bitbang_txrx_be_cpha0(spi, nsecs, 1, flags, word, bits);\r\n}\r\nstatic u32 spi_gpio_spec_txrx_word_mode3(struct spi_device *spi,\r\nunsigned nsecs, u32 word, u8 bits)\r\n{\r\nunsigned flags = spi->master->flags;\r\nreturn bitbang_txrx_be_cpha1(spi, nsecs, 1, flags, word, bits);\r\n}\r\nstatic void spi_gpio_chipselect(struct spi_device *spi, int is_active)\r\n{\r\nstruct spi_gpio *spi_gpio = spi_to_spi_gpio(spi);\r\nunsigned long cs = spi_gpio->cs_gpios[spi->chip_select];\r\nif (is_active)\r\nsetsck(spi, spi->mode & SPI_CPOL);\r\nif (cs != SPI_GPIO_NO_CHIPSELECT) {\r\ngpio_set_value_cansleep(cs, (spi->mode & SPI_CS_HIGH) ? is_active : !is_active);\r\n}\r\n}\r\nstatic int spi_gpio_setup(struct spi_device *spi)\r\n{\r\nunsigned long cs;\r\nint status = 0;\r\nstruct spi_gpio *spi_gpio = spi_to_spi_gpio(spi);\r\nstruct device_node *np = spi->master->dev.of_node;\r\nif (np) {\r\ncs = spi_gpio->cs_gpios[spi->chip_select];\r\n} else {\r\ncs = (uintptr_t) spi->controller_data;\r\n}\r\nif (!spi->controller_state) {\r\nif (cs != SPI_GPIO_NO_CHIPSELECT) {\r\nstatus = gpio_request(cs, dev_name(&spi->dev));\r\nif (status)\r\nreturn status;\r\nstatus = gpio_direction_output(cs,\r\n!(spi->mode & SPI_CS_HIGH));\r\n}\r\n}\r\nif (!status) {\r\nspi_gpio->cs_gpios[spi->chip_select] = cs;\r\nstatus = spi_bitbang_setup(spi);\r\n}\r\nif (status) {\r\nif (!spi->controller_state && cs != SPI_GPIO_NO_CHIPSELECT)\r\ngpio_free(cs);\r\n}\r\nreturn status;\r\n}\r\nstatic void spi_gpio_cleanup(struct spi_device *spi)\r\n{\r\nstruct spi_gpio *spi_gpio = spi_to_spi_gpio(spi);\r\nunsigned long cs = spi_gpio->cs_gpios[spi->chip_select];\r\nif (cs != SPI_GPIO_NO_CHIPSELECT)\r\ngpio_free(cs);\r\nspi_bitbang_cleanup(spi);\r\n}\r\nstatic int spi_gpio_alloc(unsigned pin, const char *label, bool is_in)\r\n{\r\nint value;\r\nvalue = gpio_request(pin, label);\r\nif (value == 0) {\r\nif (is_in)\r\nvalue = gpio_direction_input(pin);\r\nelse\r\nvalue = gpio_direction_output(pin, 0);\r\n}\r\nreturn value;\r\n}\r\nstatic int spi_gpio_request(struct spi_gpio_platform_data *pdata,\r\nconst char *label, u16 *res_flags)\r\n{\r\nint value;\r\nif (SPI_MOSI_GPIO != SPI_GPIO_NO_MOSI) {\r\nvalue = spi_gpio_alloc(SPI_MOSI_GPIO, label, false);\r\nif (value)\r\ngoto done;\r\n} else {\r\n*res_flags |= SPI_MASTER_NO_TX;\r\n}\r\nif (SPI_MISO_GPIO != SPI_GPIO_NO_MISO) {\r\nvalue = spi_gpio_alloc(SPI_MISO_GPIO, label, true);\r\nif (value)\r\ngoto free_mosi;\r\n} else {\r\n*res_flags |= SPI_MASTER_NO_RX;\r\n}\r\nvalue = spi_gpio_alloc(SPI_SCK_GPIO, label, false);\r\nif (value)\r\ngoto free_miso;\r\ngoto done;\r\nfree_miso:\r\nif (SPI_MISO_GPIO != SPI_GPIO_NO_MISO)\r\ngpio_free(SPI_MISO_GPIO);\r\nfree_mosi:\r\nif (SPI_MOSI_GPIO != SPI_GPIO_NO_MOSI)\r\ngpio_free(SPI_MOSI_GPIO);\r\ndone:\r\nreturn value;\r\n}\r\nstatic int spi_gpio_probe_dt(struct platform_device *pdev)\r\n{\r\nint ret;\r\nu32 tmp;\r\nstruct spi_gpio_platform_data *pdata;\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst struct of_device_id *of_id =\r\nof_match_device(spi_gpio_dt_ids, &pdev->dev);\r\nif (!of_id)\r\nreturn 0;\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nret = of_get_named_gpio(np, "gpio-sck", 0);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "gpio-sck property not found\n");\r\ngoto error_free;\r\n}\r\npdata->sck = ret;\r\nret = of_get_named_gpio(np, "gpio-miso", 0);\r\nif (ret < 0) {\r\ndev_info(&pdev->dev, "gpio-miso property not found, switching to no-rx mode\n");\r\npdata->miso = SPI_GPIO_NO_MISO;\r\n} else\r\npdata->miso = ret;\r\nret = of_get_named_gpio(np, "gpio-mosi", 0);\r\nif (ret < 0) {\r\ndev_info(&pdev->dev, "gpio-mosi property not found, switching to no-tx mode\n");\r\npdata->mosi = SPI_GPIO_NO_MOSI;\r\n} else\r\npdata->mosi = ret;\r\nret = of_property_read_u32(np, "num-chipselects", &tmp);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "num-chipselects property not found\n");\r\ngoto error_free;\r\n}\r\npdata->num_chipselect = tmp;\r\npdev->dev.platform_data = pdata;\r\nreturn 1;\r\nerror_free:\r\ndevm_kfree(&pdev->dev, pdata);\r\nreturn ret;\r\n}\r\nstatic inline int spi_gpio_probe_dt(struct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int spi_gpio_probe(struct platform_device *pdev)\r\n{\r\nint status;\r\nstruct spi_master *master;\r\nstruct spi_gpio *spi_gpio;\r\nstruct spi_gpio_platform_data *pdata;\r\nu16 master_flags = 0;\r\nbool use_of = 0;\r\nint num_devices;\r\nstatus = spi_gpio_probe_dt(pdev);\r\nif (status < 0)\r\nreturn status;\r\nif (status > 0)\r\nuse_of = 1;\r\npdata = dev_get_platdata(&pdev->dev);\r\n#ifdef GENERIC_BITBANG\r\nif (!pdata || (!use_of && !pdata->num_chipselect))\r\nreturn -ENODEV;\r\n#endif\r\nif (use_of && !SPI_N_CHIPSEL)\r\nnum_devices = 1;\r\nelse\r\nnum_devices = SPI_N_CHIPSEL;\r\nstatus = spi_gpio_request(pdata, dev_name(&pdev->dev), &master_flags);\r\nif (status < 0)\r\nreturn status;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*spi_gpio) +\r\n(sizeof(unsigned long) * num_devices));\r\nif (!master) {\r\nstatus = -ENOMEM;\r\ngoto gpio_free;\r\n}\r\nspi_gpio = spi_master_get_devdata(master);\r\nplatform_set_drvdata(pdev, spi_gpio);\r\nspi_gpio->pdev = pdev;\r\nif (pdata)\r\nspi_gpio->pdata = *pdata;\r\nmaster->bits_per_word_mask = SPI_BPW_RANGE_MASK(1, 32);\r\nmaster->flags = master_flags;\r\nmaster->bus_num = pdev->id;\r\nmaster->num_chipselect = num_devices;\r\nmaster->setup = spi_gpio_setup;\r\nmaster->cleanup = spi_gpio_cleanup;\r\n#ifdef CONFIG_OF\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nif (use_of) {\r\nint i;\r\nstruct device_node *np = pdev->dev.of_node;\r\nif (!SPI_N_CHIPSEL)\r\nspi_gpio->cs_gpios[0] = SPI_GPIO_NO_CHIPSELECT;\r\nelse\r\nfor (i = 0; i < SPI_N_CHIPSEL; i++) {\r\nstatus = of_get_named_gpio(np, "cs-gpios", i);\r\nif (status < 0) {\r\ndev_err(&pdev->dev,\r\n"invalid cs-gpios property\n");\r\ngoto gpio_free;\r\n}\r\nspi_gpio->cs_gpios[i] = status;\r\n}\r\n}\r\n#endif\r\nspi_gpio->bitbang.master = master;\r\nspi_gpio->bitbang.chipselect = spi_gpio_chipselect;\r\nif ((master_flags & (SPI_MASTER_NO_TX | SPI_MASTER_NO_RX)) == 0) {\r\nspi_gpio->bitbang.txrx_word[SPI_MODE_0] = spi_gpio_txrx_word_mode0;\r\nspi_gpio->bitbang.txrx_word[SPI_MODE_1] = spi_gpio_txrx_word_mode1;\r\nspi_gpio->bitbang.txrx_word[SPI_MODE_2] = spi_gpio_txrx_word_mode2;\r\nspi_gpio->bitbang.txrx_word[SPI_MODE_3] = spi_gpio_txrx_word_mode3;\r\n} else {\r\nspi_gpio->bitbang.txrx_word[SPI_MODE_0] = spi_gpio_spec_txrx_word_mode0;\r\nspi_gpio->bitbang.txrx_word[SPI_MODE_1] = spi_gpio_spec_txrx_word_mode1;\r\nspi_gpio->bitbang.txrx_word[SPI_MODE_2] = spi_gpio_spec_txrx_word_mode2;\r\nspi_gpio->bitbang.txrx_word[SPI_MODE_3] = spi_gpio_spec_txrx_word_mode3;\r\n}\r\nspi_gpio->bitbang.setup_transfer = spi_bitbang_setup_transfer;\r\nspi_gpio->bitbang.flags = SPI_CS_HIGH;\r\nstatus = spi_bitbang_start(&spi_gpio->bitbang);\r\nif (status < 0) {\r\ngpio_free:\r\nif (SPI_MISO_GPIO != SPI_GPIO_NO_MISO)\r\ngpio_free(SPI_MISO_GPIO);\r\nif (SPI_MOSI_GPIO != SPI_GPIO_NO_MOSI)\r\ngpio_free(SPI_MOSI_GPIO);\r\ngpio_free(SPI_SCK_GPIO);\r\nspi_master_put(master);\r\n}\r\nreturn status;\r\n}\r\nstatic int spi_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_gpio *spi_gpio;\r\nstruct spi_gpio_platform_data *pdata;\r\nspi_gpio = platform_get_drvdata(pdev);\r\npdata = dev_get_platdata(&pdev->dev);\r\nspi_bitbang_stop(&spi_gpio->bitbang);\r\nif (SPI_MISO_GPIO != SPI_GPIO_NO_MISO)\r\ngpio_free(SPI_MISO_GPIO);\r\nif (SPI_MOSI_GPIO != SPI_GPIO_NO_MOSI)\r\ngpio_free(SPI_MOSI_GPIO);\r\ngpio_free(SPI_SCK_GPIO);\r\nspi_master_put(spi_gpio->bitbang.master);\r\nreturn 0;\r\n}
