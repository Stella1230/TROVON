static bool acpi_ec_started(struct acpi_ec *ec)\r\n{\r\nreturn test_bit(EC_FLAGS_STARTED, &ec->flags) &&\r\n!test_bit(EC_FLAGS_STOPPED, &ec->flags);\r\n}\r\nstatic bool acpi_ec_event_enabled(struct acpi_ec *ec)\r\n{\r\nif (!test_bit(EC_FLAGS_QUERY_ENABLED, &ec->flags))\r\nreturn false;\r\nif (ec_freeze_events)\r\nreturn acpi_ec_started(ec);\r\nelse\r\nreturn test_bit(EC_FLAGS_STARTED, &ec->flags);\r\n}\r\nstatic bool acpi_ec_flushed(struct acpi_ec *ec)\r\n{\r\nreturn ec->reference_count == 1;\r\n}\r\nstatic inline u8 acpi_ec_read_status(struct acpi_ec *ec)\r\n{\r\nu8 x = inb(ec->command_addr);\r\nec_dbg_raw("EC_SC(R) = 0x%2.2x "\r\n"SCI_EVT=%d BURST=%d CMD=%d IBF=%d OBF=%d",\r\nx,\r\n!!(x & ACPI_EC_FLAG_SCI),\r\n!!(x & ACPI_EC_FLAG_BURST),\r\n!!(x & ACPI_EC_FLAG_CMD),\r\n!!(x & ACPI_EC_FLAG_IBF),\r\n!!(x & ACPI_EC_FLAG_OBF));\r\nreturn x;\r\n}\r\nstatic inline u8 acpi_ec_read_data(struct acpi_ec *ec)\r\n{\r\nu8 x = inb(ec->data_addr);\r\nec->timestamp = jiffies;\r\nec_dbg_raw("EC_DATA(R) = 0x%2.2x", x);\r\nreturn x;\r\n}\r\nstatic inline void acpi_ec_write_cmd(struct acpi_ec *ec, u8 command)\r\n{\r\nec_dbg_raw("EC_SC(W) = 0x%2.2x", command);\r\noutb(command, ec->command_addr);\r\nec->timestamp = jiffies;\r\n}\r\nstatic inline void acpi_ec_write_data(struct acpi_ec *ec, u8 data)\r\n{\r\nec_dbg_raw("EC_DATA(W) = 0x%2.2x", data);\r\noutb(data, ec->data_addr);\r\nec->timestamp = jiffies;\r\n}\r\nstatic const char *acpi_ec_cmd_string(u8 cmd)\r\n{\r\nswitch (cmd) {\r\ncase 0x80:\r\nreturn "RD_EC";\r\ncase 0x81:\r\nreturn "WR_EC";\r\ncase 0x82:\r\nreturn "BE_EC";\r\ncase 0x83:\r\nreturn "BD_EC";\r\ncase 0x84:\r\nreturn "QR_EC";\r\n}\r\nreturn "UNKNOWN";\r\n}\r\nstatic inline bool acpi_ec_is_gpe_raised(struct acpi_ec *ec)\r\n{\r\nacpi_event_status gpe_status = 0;\r\n(void)acpi_get_gpe_status(NULL, ec->gpe, &gpe_status);\r\nreturn (gpe_status & ACPI_EVENT_FLAG_STATUS_SET) ? true : false;\r\n}\r\nstatic inline void acpi_ec_enable_gpe(struct acpi_ec *ec, bool open)\r\n{\r\nif (open)\r\nacpi_enable_gpe(NULL, ec->gpe);\r\nelse {\r\nBUG_ON(ec->reference_count < 1);\r\nacpi_set_gpe(NULL, ec->gpe, ACPI_GPE_ENABLE);\r\n}\r\nif (acpi_ec_is_gpe_raised(ec)) {\r\nec_dbg_raw("Polling quirk");\r\nadvance_transaction(ec);\r\n}\r\n}\r\nstatic inline void acpi_ec_disable_gpe(struct acpi_ec *ec, bool close)\r\n{\r\nif (close)\r\nacpi_disable_gpe(NULL, ec->gpe);\r\nelse {\r\nBUG_ON(ec->reference_count < 1);\r\nacpi_set_gpe(NULL, ec->gpe, ACPI_GPE_DISABLE);\r\n}\r\n}\r\nstatic inline void acpi_ec_clear_gpe(struct acpi_ec *ec)\r\n{\r\nif (!acpi_ec_is_gpe_raised(ec))\r\nreturn;\r\nacpi_clear_gpe(NULL, ec->gpe);\r\n}\r\nstatic void acpi_ec_submit_request(struct acpi_ec *ec)\r\n{\r\nec->reference_count++;\r\nif (test_bit(EC_FLAGS_GPE_HANDLER_INSTALLED, &ec->flags) &&\r\nec->reference_count == 1)\r\nacpi_ec_enable_gpe(ec, true);\r\n}\r\nstatic void acpi_ec_complete_request(struct acpi_ec *ec)\r\n{\r\nbool flushed = false;\r\nec->reference_count--;\r\nif (test_bit(EC_FLAGS_GPE_HANDLER_INSTALLED, &ec->flags) &&\r\nec->reference_count == 0)\r\nacpi_ec_disable_gpe(ec, true);\r\nflushed = acpi_ec_flushed(ec);\r\nif (flushed)\r\nwake_up(&ec->wait);\r\n}\r\nstatic void acpi_ec_set_storm(struct acpi_ec *ec, u8 flag)\r\n{\r\nif (!test_bit(flag, &ec->flags)) {\r\nacpi_ec_disable_gpe(ec, false);\r\nec_dbg_drv("Polling enabled");\r\nset_bit(flag, &ec->flags);\r\n}\r\n}\r\nstatic void acpi_ec_clear_storm(struct acpi_ec *ec, u8 flag)\r\n{\r\nif (test_bit(flag, &ec->flags)) {\r\nclear_bit(flag, &ec->flags);\r\nacpi_ec_enable_gpe(ec, false);\r\nec_dbg_drv("Polling disabled");\r\n}\r\n}\r\nstatic bool acpi_ec_submit_flushable_request(struct acpi_ec *ec)\r\n{\r\nif (!acpi_ec_started(ec))\r\nreturn false;\r\nacpi_ec_submit_request(ec);\r\nreturn true;\r\n}\r\nstatic void acpi_ec_submit_query(struct acpi_ec *ec)\r\n{\r\nif (acpi_ec_event_enabled(ec) &&\r\n!test_and_set_bit(EC_FLAGS_QUERY_PENDING, &ec->flags)) {\r\nec_dbg_evt("Command(%s) submitted/blocked",\r\nacpi_ec_cmd_string(ACPI_EC_COMMAND_QUERY));\r\nec->nr_pending_queries++;\r\nschedule_work(&ec->work);\r\n}\r\n}\r\nstatic void acpi_ec_complete_query(struct acpi_ec *ec)\r\n{\r\nif (test_bit(EC_FLAGS_QUERY_PENDING, &ec->flags)) {\r\nclear_bit(EC_FLAGS_QUERY_PENDING, &ec->flags);\r\nec_dbg_evt("Command(%s) unblocked",\r\nacpi_ec_cmd_string(ACPI_EC_COMMAND_QUERY));\r\n}\r\n}\r\nstatic inline void __acpi_ec_enable_event(struct acpi_ec *ec)\r\n{\r\nif (!test_and_set_bit(EC_FLAGS_QUERY_ENABLED, &ec->flags))\r\nec_log_drv("event unblocked");\r\nif (!test_bit(EC_FLAGS_QUERY_PENDING, &ec->flags))\r\nadvance_transaction(ec);\r\n}\r\nstatic inline void __acpi_ec_disable_event(struct acpi_ec *ec)\r\n{\r\nif (test_and_clear_bit(EC_FLAGS_QUERY_ENABLED, &ec->flags))\r\nec_log_drv("event blocked");\r\n}\r\nstatic void acpi_ec_enable_event(struct acpi_ec *ec)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ec->lock, flags);\r\nif (acpi_ec_started(ec))\r\n__acpi_ec_enable_event(ec);\r\nspin_unlock_irqrestore(&ec->lock, flags);\r\n}\r\nstatic bool acpi_ec_query_flushed(struct acpi_ec *ec)\r\n{\r\nbool flushed;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ec->lock, flags);\r\nflushed = !ec->nr_pending_queries;\r\nspin_unlock_irqrestore(&ec->lock, flags);\r\nreturn flushed;\r\n}\r\nstatic void __acpi_ec_flush_event(struct acpi_ec *ec)\r\n{\r\nwait_event(ec->wait, acpi_ec_query_flushed(ec));\r\nif (ec_query_wq)\r\nflush_workqueue(ec_query_wq);\r\n}\r\nstatic void acpi_ec_disable_event(struct acpi_ec *ec)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ec->lock, flags);\r\n__acpi_ec_disable_event(ec);\r\nspin_unlock_irqrestore(&ec->lock, flags);\r\n__acpi_ec_flush_event(ec);\r\n}\r\nstatic bool acpi_ec_guard_event(struct acpi_ec *ec)\r\n{\r\nbool guarded = true;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ec->lock, flags);\r\nif (ec_event_clearing == ACPI_EC_EVT_TIMING_STATUS ||\r\nec_event_clearing == ACPI_EC_EVT_TIMING_QUERY ||\r\n!test_bit(EC_FLAGS_QUERY_PENDING, &ec->flags) ||\r\n(ec->curr && ec->curr->command == ACPI_EC_COMMAND_QUERY))\r\nguarded = false;\r\nspin_unlock_irqrestore(&ec->lock, flags);\r\nreturn guarded;\r\n}\r\nstatic int ec_transaction_polled(struct acpi_ec *ec)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&ec->lock, flags);\r\nif (ec->curr && (ec->curr->flags & ACPI_EC_COMMAND_POLL))\r\nret = 1;\r\nspin_unlock_irqrestore(&ec->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int ec_transaction_completed(struct acpi_ec *ec)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&ec->lock, flags);\r\nif (ec->curr && (ec->curr->flags & ACPI_EC_COMMAND_COMPLETE))\r\nret = 1;\r\nspin_unlock_irqrestore(&ec->lock, flags);\r\nreturn ret;\r\n}\r\nstatic inline void ec_transaction_transition(struct acpi_ec *ec, unsigned long flag)\r\n{\r\nec->curr->flags |= flag;\r\nif (ec->curr->command == ACPI_EC_COMMAND_QUERY) {\r\nif (ec_event_clearing == ACPI_EC_EVT_TIMING_STATUS &&\r\nflag == ACPI_EC_COMMAND_POLL)\r\nacpi_ec_complete_query(ec);\r\nif (ec_event_clearing == ACPI_EC_EVT_TIMING_QUERY &&\r\nflag == ACPI_EC_COMMAND_COMPLETE)\r\nacpi_ec_complete_query(ec);\r\nif (ec_event_clearing == ACPI_EC_EVT_TIMING_EVENT &&\r\nflag == ACPI_EC_COMMAND_COMPLETE)\r\nset_bit(EC_FLAGS_QUERY_GUARDING, &ec->flags);\r\n}\r\n}\r\nstatic void advance_transaction(struct acpi_ec *ec)\r\n{\r\nstruct transaction *t;\r\nu8 status;\r\nbool wakeup = false;\r\nec_dbg_stm("%s (%d)", in_interrupt() ? "IRQ" : "TASK",\r\nsmp_processor_id());\r\nacpi_ec_clear_gpe(ec);\r\nstatus = acpi_ec_read_status(ec);\r\nt = ec->curr;\r\nif (!t || !(t->flags & ACPI_EC_COMMAND_POLL)) {\r\nif (ec_event_clearing == ACPI_EC_EVT_TIMING_EVENT &&\r\n(!ec->nr_pending_queries ||\r\ntest_bit(EC_FLAGS_QUERY_GUARDING, &ec->flags))) {\r\nclear_bit(EC_FLAGS_QUERY_GUARDING, &ec->flags);\r\nacpi_ec_complete_query(ec);\r\n}\r\n}\r\nif (!t)\r\ngoto err;\r\nif (t->flags & ACPI_EC_COMMAND_POLL) {\r\nif (t->wlen > t->wi) {\r\nif ((status & ACPI_EC_FLAG_IBF) == 0)\r\nacpi_ec_write_data(ec, t->wdata[t->wi++]);\r\nelse\r\ngoto err;\r\n} else if (t->rlen > t->ri) {\r\nif ((status & ACPI_EC_FLAG_OBF) == 1) {\r\nt->rdata[t->ri++] = acpi_ec_read_data(ec);\r\nif (t->rlen == t->ri) {\r\nec_transaction_transition(ec, ACPI_EC_COMMAND_COMPLETE);\r\nif (t->command == ACPI_EC_COMMAND_QUERY)\r\nec_dbg_evt("Command(%s) completed by hardware",\r\nacpi_ec_cmd_string(ACPI_EC_COMMAND_QUERY));\r\nwakeup = true;\r\n}\r\n} else\r\ngoto err;\r\n} else if (t->wlen == t->wi &&\r\n(status & ACPI_EC_FLAG_IBF) == 0) {\r\nec_transaction_transition(ec, ACPI_EC_COMMAND_COMPLETE);\r\nwakeup = true;\r\n}\r\ngoto out;\r\n} else {\r\nif (EC_FLAGS_QUERY_HANDSHAKE &&\r\n!(status & ACPI_EC_FLAG_SCI) &&\r\n(t->command == ACPI_EC_COMMAND_QUERY)) {\r\nec_transaction_transition(ec, ACPI_EC_COMMAND_POLL);\r\nt->rdata[t->ri++] = 0x00;\r\nec_transaction_transition(ec, ACPI_EC_COMMAND_COMPLETE);\r\nec_dbg_evt("Command(%s) completed by software",\r\nacpi_ec_cmd_string(ACPI_EC_COMMAND_QUERY));\r\nwakeup = true;\r\n} else if ((status & ACPI_EC_FLAG_IBF) == 0) {\r\nacpi_ec_write_cmd(ec, t->command);\r\nec_transaction_transition(ec, ACPI_EC_COMMAND_POLL);\r\n} else\r\ngoto err;\r\ngoto out;\r\n}\r\nerr:\r\nif (!(status & ACPI_EC_FLAG_SCI)) {\r\nif (in_interrupt() && t) {\r\nif (t->irq_count < ec_storm_threshold)\r\n++t->irq_count;\r\nif (t->irq_count == ec_storm_threshold)\r\nacpi_ec_set_storm(ec, EC_FLAGS_COMMAND_STORM);\r\n}\r\n}\r\nout:\r\nif (status & ACPI_EC_FLAG_SCI)\r\nacpi_ec_submit_query(ec);\r\nif (wakeup && in_interrupt())\r\nwake_up(&ec->wait);\r\n}\r\nstatic void start_transaction(struct acpi_ec *ec)\r\n{\r\nec->curr->irq_count = ec->curr->wi = ec->curr->ri = 0;\r\nec->curr->flags = 0;\r\n}\r\nstatic int ec_guard(struct acpi_ec *ec)\r\n{\r\nunsigned long guard = usecs_to_jiffies(ec->polling_guard);\r\nunsigned long timeout = ec->timestamp + guard;\r\ndo {\r\nif (ec->busy_polling) {\r\nif (ec_transaction_completed(ec))\r\nreturn 0;\r\nudelay(jiffies_to_usecs(guard));\r\n} else {\r\nif (!ec_transaction_polled(ec) &&\r\n!acpi_ec_guard_event(ec))\r\nbreak;\r\nif (wait_event_timeout(ec->wait,\r\nec_transaction_completed(ec),\r\nguard))\r\nreturn 0;\r\n}\r\n} while (time_before(jiffies, timeout));\r\nreturn -ETIME;\r\n}\r\nstatic int ec_poll(struct acpi_ec *ec)\r\n{\r\nunsigned long flags;\r\nint repeat = 5;\r\nwhile (repeat--) {\r\nunsigned long delay = jiffies +\r\nmsecs_to_jiffies(ec_delay);\r\ndo {\r\nif (!ec_guard(ec))\r\nreturn 0;\r\nspin_lock_irqsave(&ec->lock, flags);\r\nadvance_transaction(ec);\r\nspin_unlock_irqrestore(&ec->lock, flags);\r\n} while (time_before(jiffies, delay));\r\npr_debug("controller reset, restart transaction\n");\r\nspin_lock_irqsave(&ec->lock, flags);\r\nstart_transaction(ec);\r\nspin_unlock_irqrestore(&ec->lock, flags);\r\n}\r\nreturn -ETIME;\r\n}\r\nstatic int acpi_ec_transaction_unlocked(struct acpi_ec *ec,\r\nstruct transaction *t)\r\n{\r\nunsigned long tmp;\r\nint ret = 0;\r\nspin_lock_irqsave(&ec->lock, tmp);\r\nif (!acpi_ec_submit_flushable_request(ec)) {\r\nret = -EINVAL;\r\ngoto unlock;\r\n}\r\nec_dbg_ref(ec, "Increase command");\r\nec->curr = t;\r\nec_dbg_req("Command(%s) started", acpi_ec_cmd_string(t->command));\r\nstart_transaction(ec);\r\nspin_unlock_irqrestore(&ec->lock, tmp);\r\nret = ec_poll(ec);\r\nspin_lock_irqsave(&ec->lock, tmp);\r\nif (t->irq_count == ec_storm_threshold)\r\nacpi_ec_clear_storm(ec, EC_FLAGS_COMMAND_STORM);\r\nec_dbg_req("Command(%s) stopped", acpi_ec_cmd_string(t->command));\r\nec->curr = NULL;\r\nacpi_ec_complete_request(ec);\r\nec_dbg_ref(ec, "Decrease command");\r\nunlock:\r\nspin_unlock_irqrestore(&ec->lock, tmp);\r\nreturn ret;\r\n}\r\nstatic int acpi_ec_transaction(struct acpi_ec *ec, struct transaction *t)\r\n{\r\nint status;\r\nu32 glk;\r\nif (!ec || (!t) || (t->wlen && !t->wdata) || (t->rlen && !t->rdata))\r\nreturn -EINVAL;\r\nif (t->rdata)\r\nmemset(t->rdata, 0, t->rlen);\r\nmutex_lock(&ec->mutex);\r\nif (ec->global_lock) {\r\nstatus = acpi_acquire_global_lock(ACPI_EC_UDELAY_GLK, &glk);\r\nif (ACPI_FAILURE(status)) {\r\nstatus = -ENODEV;\r\ngoto unlock;\r\n}\r\n}\r\nstatus = acpi_ec_transaction_unlocked(ec, t);\r\nif (ec->global_lock)\r\nacpi_release_global_lock(glk);\r\nunlock:\r\nmutex_unlock(&ec->mutex);\r\nreturn status;\r\n}\r\nstatic int acpi_ec_burst_enable(struct acpi_ec *ec)\r\n{\r\nu8 d;\r\nstruct transaction t = {.command = ACPI_EC_BURST_ENABLE,\r\n.wdata = NULL, .rdata = &d,\r\n.wlen = 0, .rlen = 1};\r\nreturn acpi_ec_transaction(ec, &t);\r\n}\r\nstatic int acpi_ec_burst_disable(struct acpi_ec *ec)\r\n{\r\nstruct transaction t = {.command = ACPI_EC_BURST_DISABLE,\r\n.wdata = NULL, .rdata = NULL,\r\n.wlen = 0, .rlen = 0};\r\nreturn (acpi_ec_read_status(ec) & ACPI_EC_FLAG_BURST) ?\r\nacpi_ec_transaction(ec, &t) : 0;\r\n}\r\nstatic int acpi_ec_read(struct acpi_ec *ec, u8 address, u8 *data)\r\n{\r\nint result;\r\nu8 d;\r\nstruct transaction t = {.command = ACPI_EC_COMMAND_READ,\r\n.wdata = &address, .rdata = &d,\r\n.wlen = 1, .rlen = 1};\r\nresult = acpi_ec_transaction(ec, &t);\r\n*data = d;\r\nreturn result;\r\n}\r\nstatic int acpi_ec_write(struct acpi_ec *ec, u8 address, u8 data)\r\n{\r\nu8 wdata[2] = { address, data };\r\nstruct transaction t = {.command = ACPI_EC_COMMAND_WRITE,\r\n.wdata = wdata, .rdata = NULL,\r\n.wlen = 2, .rlen = 0};\r\nreturn acpi_ec_transaction(ec, &t);\r\n}\r\nint ec_read(u8 addr, u8 *val)\r\n{\r\nint err;\r\nu8 temp_data;\r\nif (!first_ec)\r\nreturn -ENODEV;\r\nerr = acpi_ec_read(first_ec, addr, &temp_data);\r\nif (!err) {\r\n*val = temp_data;\r\nreturn 0;\r\n}\r\nreturn err;\r\n}\r\nint ec_write(u8 addr, u8 val)\r\n{\r\nint err;\r\nif (!first_ec)\r\nreturn -ENODEV;\r\nerr = acpi_ec_write(first_ec, addr, val);\r\nreturn err;\r\n}\r\nint ec_transaction(u8 command,\r\nconst u8 *wdata, unsigned wdata_len,\r\nu8 *rdata, unsigned rdata_len)\r\n{\r\nstruct transaction t = {.command = command,\r\n.wdata = wdata, .rdata = rdata,\r\n.wlen = wdata_len, .rlen = rdata_len};\r\nif (!first_ec)\r\nreturn -ENODEV;\r\nreturn acpi_ec_transaction(first_ec, &t);\r\n}\r\nacpi_handle ec_get_handle(void)\r\n{\r\nif (!first_ec)\r\nreturn NULL;\r\nreturn first_ec->handle;\r\n}\r\nstatic void acpi_ec_start(struct acpi_ec *ec, bool resuming)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ec->lock, flags);\r\nif (!test_and_set_bit(EC_FLAGS_STARTED, &ec->flags)) {\r\nec_dbg_drv("Starting EC");\r\nif (!resuming) {\r\nacpi_ec_submit_request(ec);\r\nec_dbg_ref(ec, "Increase driver");\r\n}\r\nec_log_drv("EC started");\r\n}\r\nspin_unlock_irqrestore(&ec->lock, flags);\r\n}\r\nstatic bool acpi_ec_stopped(struct acpi_ec *ec)\r\n{\r\nunsigned long flags;\r\nbool flushed;\r\nspin_lock_irqsave(&ec->lock, flags);\r\nflushed = acpi_ec_flushed(ec);\r\nspin_unlock_irqrestore(&ec->lock, flags);\r\nreturn flushed;\r\n}\r\nstatic void acpi_ec_stop(struct acpi_ec *ec, bool suspending)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ec->lock, flags);\r\nif (acpi_ec_started(ec)) {\r\nec_dbg_drv("Stopping EC");\r\nset_bit(EC_FLAGS_STOPPED, &ec->flags);\r\nspin_unlock_irqrestore(&ec->lock, flags);\r\nwait_event(ec->wait, acpi_ec_stopped(ec));\r\nspin_lock_irqsave(&ec->lock, flags);\r\nif (!suspending) {\r\nacpi_ec_complete_request(ec);\r\nec_dbg_ref(ec, "Decrease driver");\r\n} else if (!ec_freeze_events)\r\n__acpi_ec_disable_event(ec);\r\nclear_bit(EC_FLAGS_STARTED, &ec->flags);\r\nclear_bit(EC_FLAGS_STOPPED, &ec->flags);\r\nec_log_drv("EC stopped");\r\n}\r\nspin_unlock_irqrestore(&ec->lock, flags);\r\n}\r\nstatic void acpi_ec_enter_noirq(struct acpi_ec *ec)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ec->lock, flags);\r\nec->busy_polling = true;\r\nec->polling_guard = 0;\r\nec_log_drv("interrupt blocked");\r\nspin_unlock_irqrestore(&ec->lock, flags);\r\n}\r\nstatic void acpi_ec_leave_noirq(struct acpi_ec *ec)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ec->lock, flags);\r\nec->busy_polling = ec_busy_polling;\r\nec->polling_guard = ec_polling_guard;\r\nec_log_drv("interrupt unblocked");\r\nspin_unlock_irqrestore(&ec->lock, flags);\r\n}\r\nvoid acpi_ec_block_transactions(void)\r\n{\r\nstruct acpi_ec *ec = first_ec;\r\nif (!ec)\r\nreturn;\r\nmutex_lock(&ec->mutex);\r\nacpi_ec_stop(ec, true);\r\nmutex_unlock(&ec->mutex);\r\n}\r\nvoid acpi_ec_unblock_transactions(void)\r\n{\r\nif (first_ec)\r\nacpi_ec_start(first_ec, true);\r\n}\r\nstatic struct acpi_ec_query_handler *\r\nacpi_ec_get_query_handler(struct acpi_ec_query_handler *handler)\r\n{\r\nif (handler)\r\nkref_get(&handler->kref);\r\nreturn handler;\r\n}\r\nstatic struct acpi_ec_query_handler *\r\nacpi_ec_get_query_handler_by_value(struct acpi_ec *ec, u8 value)\r\n{\r\nstruct acpi_ec_query_handler *handler;\r\nbool found = false;\r\nmutex_lock(&ec->mutex);\r\nlist_for_each_entry(handler, &ec->list, node) {\r\nif (value == handler->query_bit) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&ec->mutex);\r\nreturn found ? acpi_ec_get_query_handler(handler) : NULL;\r\n}\r\nstatic void acpi_ec_query_handler_release(struct kref *kref)\r\n{\r\nstruct acpi_ec_query_handler *handler =\r\ncontainer_of(kref, struct acpi_ec_query_handler, kref);\r\nkfree(handler);\r\n}\r\nstatic void acpi_ec_put_query_handler(struct acpi_ec_query_handler *handler)\r\n{\r\nkref_put(&handler->kref, acpi_ec_query_handler_release);\r\n}\r\nint acpi_ec_add_query_handler(struct acpi_ec *ec, u8 query_bit,\r\nacpi_handle handle, acpi_ec_query_func func,\r\nvoid *data)\r\n{\r\nstruct acpi_ec_query_handler *handler =\r\nkzalloc(sizeof(struct acpi_ec_query_handler), GFP_KERNEL);\r\nif (!handler)\r\nreturn -ENOMEM;\r\nhandler->query_bit = query_bit;\r\nhandler->handle = handle;\r\nhandler->func = func;\r\nhandler->data = data;\r\nmutex_lock(&ec->mutex);\r\nkref_init(&handler->kref);\r\nlist_add(&handler->node, &ec->list);\r\nmutex_unlock(&ec->mutex);\r\nreturn 0;\r\n}\r\nstatic void acpi_ec_remove_query_handlers(struct acpi_ec *ec,\r\nbool remove_all, u8 query_bit)\r\n{\r\nstruct acpi_ec_query_handler *handler, *tmp;\r\nLIST_HEAD(free_list);\r\nmutex_lock(&ec->mutex);\r\nlist_for_each_entry_safe(handler, tmp, &ec->list, node) {\r\nif (remove_all || query_bit == handler->query_bit) {\r\nlist_del_init(&handler->node);\r\nlist_add(&handler->node, &free_list);\r\n}\r\n}\r\nmutex_unlock(&ec->mutex);\r\nlist_for_each_entry_safe(handler, tmp, &free_list, node)\r\nacpi_ec_put_query_handler(handler);\r\n}\r\nvoid acpi_ec_remove_query_handler(struct acpi_ec *ec, u8 query_bit)\r\n{\r\nacpi_ec_remove_query_handlers(ec, false, query_bit);\r\n}\r\nstatic struct acpi_ec_query *acpi_ec_create_query(u8 *pval)\r\n{\r\nstruct acpi_ec_query *q;\r\nstruct transaction *t;\r\nq = kzalloc(sizeof (struct acpi_ec_query), GFP_KERNEL);\r\nif (!q)\r\nreturn NULL;\r\nINIT_WORK(&q->work, acpi_ec_event_processor);\r\nt = &q->transaction;\r\nt->command = ACPI_EC_COMMAND_QUERY;\r\nt->rdata = pval;\r\nt->rlen = 1;\r\nreturn q;\r\n}\r\nstatic void acpi_ec_delete_query(struct acpi_ec_query *q)\r\n{\r\nif (q) {\r\nif (q->handler)\r\nacpi_ec_put_query_handler(q->handler);\r\nkfree(q);\r\n}\r\n}\r\nstatic void acpi_ec_event_processor(struct work_struct *work)\r\n{\r\nstruct acpi_ec_query *q = container_of(work, struct acpi_ec_query, work);\r\nstruct acpi_ec_query_handler *handler = q->handler;\r\nec_dbg_evt("Query(0x%02x) started", handler->query_bit);\r\nif (handler->func)\r\nhandler->func(handler->data);\r\nelse if (handler->handle)\r\nacpi_evaluate_object(handler->handle, NULL, NULL, NULL);\r\nec_dbg_evt("Query(0x%02x) stopped", handler->query_bit);\r\nacpi_ec_delete_query(q);\r\n}\r\nstatic int acpi_ec_query(struct acpi_ec *ec, u8 *data)\r\n{\r\nu8 value = 0;\r\nint result;\r\nstruct acpi_ec_query *q;\r\nq = acpi_ec_create_query(&value);\r\nif (!q)\r\nreturn -ENOMEM;\r\nresult = acpi_ec_transaction(ec, &q->transaction);\r\nif (!value)\r\nresult = -ENODATA;\r\nif (result)\r\ngoto err_exit;\r\nq->handler = acpi_ec_get_query_handler_by_value(ec, value);\r\nif (!q->handler) {\r\nresult = -ENODATA;\r\ngoto err_exit;\r\n}\r\nec_dbg_evt("Query(0x%02x) scheduled", value);\r\nif (!queue_work(ec_query_wq, &q->work)) {\r\nec_dbg_evt("Query(0x%02x) overlapped", value);\r\nresult = -EBUSY;\r\n}\r\nerr_exit:\r\nif (result)\r\nacpi_ec_delete_query(q);\r\nif (data)\r\n*data = value;\r\nreturn result;\r\n}\r\nstatic void acpi_ec_check_event(struct acpi_ec *ec)\r\n{\r\nunsigned long flags;\r\nif (ec_event_clearing == ACPI_EC_EVT_TIMING_EVENT) {\r\nif (ec_guard(ec)) {\r\nspin_lock_irqsave(&ec->lock, flags);\r\nif (!ec->curr)\r\nadvance_transaction(ec);\r\nspin_unlock_irqrestore(&ec->lock, flags);\r\n}\r\n}\r\n}\r\nstatic void acpi_ec_event_handler(struct work_struct *work)\r\n{\r\nunsigned long flags;\r\nstruct acpi_ec *ec = container_of(work, struct acpi_ec, work);\r\nec_dbg_evt("Event started");\r\nspin_lock_irqsave(&ec->lock, flags);\r\nwhile (ec->nr_pending_queries) {\r\nspin_unlock_irqrestore(&ec->lock, flags);\r\n(void)acpi_ec_query(ec, NULL);\r\nspin_lock_irqsave(&ec->lock, flags);\r\nec->nr_pending_queries--;\r\nif (!ec->nr_pending_queries) {\r\nif (ec_event_clearing == ACPI_EC_EVT_TIMING_STATUS ||\r\nec_event_clearing == ACPI_EC_EVT_TIMING_QUERY)\r\nacpi_ec_complete_query(ec);\r\n}\r\n}\r\nspin_unlock_irqrestore(&ec->lock, flags);\r\nec_dbg_evt("Event stopped");\r\nacpi_ec_check_event(ec);\r\n}\r\nstatic u32 acpi_ec_gpe_handler(acpi_handle gpe_device,\r\nu32 gpe_number, void *data)\r\n{\r\nunsigned long flags;\r\nstruct acpi_ec *ec = data;\r\nspin_lock_irqsave(&ec->lock, flags);\r\nadvance_transaction(ec);\r\nspin_unlock_irqrestore(&ec->lock, flags);\r\nreturn ACPI_INTERRUPT_HANDLED;\r\n}\r\nstatic acpi_status\r\nacpi_ec_space_handler(u32 function, acpi_physical_address address,\r\nu32 bits, u64 *value64,\r\nvoid *handler_context, void *region_context)\r\n{\r\nstruct acpi_ec *ec = handler_context;\r\nint result = 0, i, bytes = bits / 8;\r\nu8 *value = (u8 *)value64;\r\nif ((address > 0xFF) || !value || !handler_context)\r\nreturn AE_BAD_PARAMETER;\r\nif (function != ACPI_READ && function != ACPI_WRITE)\r\nreturn AE_BAD_PARAMETER;\r\nif (ec->busy_polling || bits > 8)\r\nacpi_ec_burst_enable(ec);\r\nfor (i = 0; i < bytes; ++i, ++address, ++value)\r\nresult = (function == ACPI_READ) ?\r\nacpi_ec_read(ec, address, value) :\r\nacpi_ec_write(ec, address, *value);\r\nif (ec->busy_polling || bits > 8)\r\nacpi_ec_burst_disable(ec);\r\nswitch (result) {\r\ncase -EINVAL:\r\nreturn AE_BAD_PARAMETER;\r\ncase -ENODEV:\r\nreturn AE_NOT_FOUND;\r\ncase -ETIME:\r\nreturn AE_TIME;\r\ndefault:\r\nreturn AE_OK;\r\n}\r\n}\r\nstatic void acpi_ec_free(struct acpi_ec *ec)\r\n{\r\nif (first_ec == ec)\r\nfirst_ec = NULL;\r\nif (boot_ec == ec)\r\nboot_ec = NULL;\r\nkfree(ec);\r\n}\r\nstatic struct acpi_ec *acpi_ec_alloc(void)\r\n{\r\nstruct acpi_ec *ec = kzalloc(sizeof(struct acpi_ec), GFP_KERNEL);\r\nif (!ec)\r\nreturn NULL;\r\nmutex_init(&ec->mutex);\r\ninit_waitqueue_head(&ec->wait);\r\nINIT_LIST_HEAD(&ec->list);\r\nspin_lock_init(&ec->lock);\r\nINIT_WORK(&ec->work, acpi_ec_event_handler);\r\nec->timestamp = jiffies;\r\nec->busy_polling = true;\r\nec->polling_guard = 0;\r\nreturn ec;\r\n}\r\nstatic acpi_status\r\nacpi_ec_register_query_methods(acpi_handle handle, u32 level,\r\nvoid *context, void **return_value)\r\n{\r\nchar node_name[5];\r\nstruct acpi_buffer buffer = { sizeof(node_name), node_name };\r\nstruct acpi_ec *ec = context;\r\nint value = 0;\r\nacpi_status status;\r\nstatus = acpi_get_name(handle, ACPI_SINGLE_NAME, &buffer);\r\nif (ACPI_SUCCESS(status) && sscanf(node_name, "_Q%x", &value) == 1)\r\nacpi_ec_add_query_handler(ec, value, handle, NULL, NULL);\r\nreturn AE_OK;\r\n}\r\nstatic acpi_status\r\nec_parse_device(acpi_handle handle, u32 Level, void *context, void **retval)\r\n{\r\nacpi_status status;\r\nunsigned long long tmp = 0;\r\nstruct acpi_ec *ec = context;\r\nec->command_addr = ec->data_addr = 0;\r\nstatus = acpi_walk_resources(handle, METHOD_NAME__CRS,\r\nec_parse_io_ports, ec);\r\nif (ACPI_FAILURE(status))\r\nreturn status;\r\nstatus = acpi_evaluate_integer(handle, "_GPE", NULL, &tmp);\r\nif (ACPI_FAILURE(status))\r\nreturn status;\r\nec->gpe = tmp;\r\ntmp = 0;\r\nacpi_evaluate_integer(handle, "_GLK", NULL, &tmp);\r\nec->global_lock = tmp;\r\nec->handle = handle;\r\nreturn AE_CTRL_TERMINATE;\r\n}\r\nstatic int ec_install_handlers(struct acpi_ec *ec, bool handle_events)\r\n{\r\nacpi_status status;\r\nacpi_ec_start(ec, false);\r\nif (!test_bit(EC_FLAGS_EC_HANDLER_INSTALLED, &ec->flags)) {\r\nacpi_ec_enter_noirq(ec);\r\nstatus = acpi_install_address_space_handler(ec->handle,\r\nACPI_ADR_SPACE_EC,\r\n&acpi_ec_space_handler,\r\nNULL, ec);\r\nif (ACPI_FAILURE(status)) {\r\nif (status == AE_NOT_FOUND) {\r\npr_err("Fail in evaluating the _REG object"\r\n" of EC device. Broken bios is suspected.\n");\r\n} else {\r\nacpi_ec_stop(ec, false);\r\nreturn -ENODEV;\r\n}\r\n}\r\nset_bit(EC_FLAGS_EC_HANDLER_INSTALLED, &ec->flags);\r\n}\r\nif (!handle_events)\r\nreturn 0;\r\nif (!test_bit(EC_FLAGS_EVT_HANDLER_INSTALLED, &ec->flags)) {\r\nacpi_walk_namespace(ACPI_TYPE_METHOD, ec->handle, 1,\r\nacpi_ec_register_query_methods,\r\nNULL, ec, NULL);\r\nset_bit(EC_FLAGS_EVT_HANDLER_INSTALLED, &ec->flags);\r\n}\r\nif (!test_bit(EC_FLAGS_GPE_HANDLER_INSTALLED, &ec->flags)) {\r\nstatus = acpi_install_gpe_raw_handler(NULL, ec->gpe,\r\nACPI_GPE_EDGE_TRIGGERED,\r\n&acpi_ec_gpe_handler, ec);\r\nif (ACPI_SUCCESS(status)) {\r\nset_bit(EC_FLAGS_GPE_HANDLER_INSTALLED, &ec->flags);\r\nacpi_ec_leave_noirq(ec);\r\nif (test_bit(EC_FLAGS_STARTED, &ec->flags) &&\r\nec->reference_count >= 1)\r\nacpi_ec_enable_gpe(ec, true);\r\nacpi_ec_enable_event(ec);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void ec_remove_handlers(struct acpi_ec *ec)\r\n{\r\nif (test_bit(EC_FLAGS_EC_HANDLER_INSTALLED, &ec->flags)) {\r\nif (ACPI_FAILURE(acpi_remove_address_space_handler(ec->handle,\r\nACPI_ADR_SPACE_EC, &acpi_ec_space_handler)))\r\npr_err("failed to remove space handler\n");\r\nclear_bit(EC_FLAGS_EC_HANDLER_INSTALLED, &ec->flags);\r\n}\r\nacpi_ec_stop(ec, false);\r\nif (test_bit(EC_FLAGS_GPE_HANDLER_INSTALLED, &ec->flags)) {\r\nif (ACPI_FAILURE(acpi_remove_gpe_handler(NULL, ec->gpe,\r\n&acpi_ec_gpe_handler)))\r\npr_err("failed to remove gpe handler\n");\r\nclear_bit(EC_FLAGS_GPE_HANDLER_INSTALLED, &ec->flags);\r\n}\r\nif (test_bit(EC_FLAGS_EVT_HANDLER_INSTALLED, &ec->flags)) {\r\nacpi_ec_remove_query_handlers(ec, true, 0);\r\nclear_bit(EC_FLAGS_EVT_HANDLER_INSTALLED, &ec->flags);\r\n}\r\n}\r\nstatic int acpi_ec_setup(struct acpi_ec *ec, bool handle_events)\r\n{\r\nint ret;\r\nret = ec_install_handlers(ec, handle_events);\r\nif (ret)\r\nreturn ret;\r\nif (!first_ec) {\r\nfirst_ec = ec;\r\nacpi_handle_info(first_ec->handle, "Used as first EC\n");\r\n}\r\nacpi_handle_info(ec->handle,\r\n"GPE=0x%lx, EC_CMD/EC_SC=0x%lx, EC_DATA=0x%lx\n",\r\nec->gpe, ec->command_addr, ec->data_addr);\r\nreturn ret;\r\n}\r\nstatic int acpi_config_boot_ec(struct acpi_ec *ec, acpi_handle handle,\r\nbool handle_events, bool is_ecdt)\r\n{\r\nint ret;\r\nif (boot_ec && boot_ec->handle != handle)\r\nec_remove_handlers(boot_ec);\r\nif (boot_ec != ec)\r\nacpi_ec_free(boot_ec);\r\nif (ec->handle != handle)\r\nec->handle = handle;\r\nret = acpi_ec_setup(ec, handle_events);\r\nif (ret)\r\nreturn ret;\r\nif (!boot_ec) {\r\nboot_ec = ec;\r\nboot_ec_is_ecdt = is_ecdt;\r\n}\r\nacpi_handle_info(boot_ec->handle,\r\n"Used as boot %s EC to handle transactions%s\n",\r\nis_ecdt ? "ECDT" : "DSDT",\r\nhandle_events ? " and events" : "");\r\nreturn ret;\r\n}\r\nstatic bool acpi_ec_ecdt_get_handle(acpi_handle *phandle)\r\n{\r\nstruct acpi_table_ecdt *ecdt_ptr;\r\nacpi_status status;\r\nacpi_handle handle;\r\nstatus = acpi_get_table(ACPI_SIG_ECDT, 1,\r\n(struct acpi_table_header **)&ecdt_ptr);\r\nif (ACPI_FAILURE(status))\r\nreturn false;\r\nstatus = acpi_get_handle(NULL, ecdt_ptr->id, &handle);\r\nif (ACPI_FAILURE(status))\r\nreturn false;\r\n*phandle = handle;\r\nreturn true;\r\n}\r\nstatic bool acpi_is_boot_ec(struct acpi_ec *ec)\r\n{\r\nif (!boot_ec)\r\nreturn false;\r\nif (ec->handle == boot_ec->handle &&\r\nec->gpe == boot_ec->gpe &&\r\nec->command_addr == boot_ec->command_addr &&\r\nec->data_addr == boot_ec->data_addr)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int acpi_ec_add(struct acpi_device *device)\r\n{\r\nstruct acpi_ec *ec = NULL;\r\nint ret;\r\nstrcpy(acpi_device_name(device), ACPI_EC_DEVICE_NAME);\r\nstrcpy(acpi_device_class(device), ACPI_EC_CLASS);\r\nec = acpi_ec_alloc();\r\nif (!ec)\r\nreturn -ENOMEM;\r\nif (ec_parse_device(device->handle, 0, ec, NULL) !=\r\nAE_CTRL_TERMINATE) {\r\nret = -EINVAL;\r\ngoto err_alloc;\r\n}\r\nif (acpi_is_boot_ec(ec)) {\r\nboot_ec_is_ecdt = false;\r\nacpi_handle_debug(ec->handle, "duplicated.\n");\r\nacpi_ec_free(ec);\r\nec = boot_ec;\r\nret = acpi_config_boot_ec(ec, ec->handle, true, false);\r\n} else\r\nret = acpi_ec_setup(ec, true);\r\nif (ret)\r\ngoto err_query;\r\ndevice->driver_data = ec;\r\nret = !!request_region(ec->data_addr, 1, "EC data");\r\nWARN(!ret, "Could not request EC data io port 0x%lx", ec->data_addr);\r\nret = !!request_region(ec->command_addr, 1, "EC cmd");\r\nWARN(!ret, "Could not request EC cmd io port 0x%lx", ec->command_addr);\r\nacpi_walk_dep_device_list(ec->handle);\r\nacpi_handle_debug(ec->handle, "enumerated.\n");\r\nreturn 0;\r\nerr_query:\r\nif (ec != boot_ec)\r\nacpi_ec_remove_query_handlers(ec, true, 0);\r\nerr_alloc:\r\nif (ec != boot_ec)\r\nacpi_ec_free(ec);\r\nreturn ret;\r\n}\r\nstatic int acpi_ec_remove(struct acpi_device *device)\r\n{\r\nstruct acpi_ec *ec;\r\nif (!device)\r\nreturn -EINVAL;\r\nec = acpi_driver_data(device);\r\nrelease_region(ec->data_addr, 1);\r\nrelease_region(ec->command_addr, 1);\r\ndevice->driver_data = NULL;\r\nif (ec != boot_ec) {\r\nec_remove_handlers(ec);\r\nacpi_ec_free(ec);\r\n}\r\nreturn 0;\r\n}\r\nstatic acpi_status\r\nec_parse_io_ports(struct acpi_resource *resource, void *context)\r\n{\r\nstruct acpi_ec *ec = context;\r\nif (resource->type != ACPI_RESOURCE_TYPE_IO)\r\nreturn AE_OK;\r\nif (ec->data_addr == 0)\r\nec->data_addr = resource->data.io.minimum;\r\nelse if (ec->command_addr == 0)\r\nec->command_addr = resource->data.io.minimum;\r\nelse\r\nreturn AE_CTRL_TERMINATE;\r\nreturn AE_OK;\r\n}\r\nint __init acpi_ec_dsdt_probe(void)\r\n{\r\nacpi_status status;\r\nstruct acpi_ec *ec;\r\nint ret;\r\nec = acpi_ec_alloc();\r\nif (!ec)\r\nreturn -ENOMEM;\r\nstatus = acpi_get_devices(ec_device_ids[0].id,\r\nec_parse_device, ec, NULL);\r\nif (ACPI_FAILURE(status) || !ec->handle) {\r\nret = -ENODEV;\r\ngoto error;\r\n}\r\nret = acpi_config_boot_ec(ec, ec->handle, false, false);\r\nerror:\r\nif (ret)\r\nacpi_ec_free(ec);\r\nreturn ret;\r\n}\r\nint __init acpi_ec_ecdt_start(void)\r\n{\r\nacpi_handle handle;\r\nif (!boot_ec)\r\nreturn -ENODEV;\r\nif (!boot_ec_is_ecdt)\r\nreturn -ENODEV;\r\nif (!acpi_ec_ecdt_get_handle(&handle))\r\nreturn -ENODEV;\r\nreturn acpi_config_boot_ec(boot_ec, handle, true, true);\r\n}\r\nstatic int ec_correct_ecdt(const struct dmi_system_id *id)\r\n{\r\npr_debug("Detected system needing ECDT address correction.\n");\r\nEC_FLAGS_CORRECT_ECDT = 1;\r\nreturn 0;\r\n}\r\nint __init acpi_ec_ecdt_probe(void)\r\n{\r\nint ret;\r\nacpi_status status;\r\nstruct acpi_table_ecdt *ecdt_ptr;\r\nstruct acpi_ec *ec;\r\nec = acpi_ec_alloc();\r\nif (!ec)\r\nreturn -ENOMEM;\r\ndmi_check_system(ec_dmi_table);\r\nstatus = acpi_get_table(ACPI_SIG_ECDT, 1,\r\n(struct acpi_table_header **)&ecdt_ptr);\r\nif (ACPI_FAILURE(status)) {\r\nret = -ENODEV;\r\ngoto error;\r\n}\r\nif (!ecdt_ptr->control.address || !ecdt_ptr->data.address) {\r\nret = -ENODEV;\r\ngoto error;\r\n}\r\nif (EC_FLAGS_CORRECT_ECDT) {\r\nec->command_addr = ecdt_ptr->data.address;\r\nec->data_addr = ecdt_ptr->control.address;\r\n} else {\r\nec->command_addr = ecdt_ptr->control.address;\r\nec->data_addr = ecdt_ptr->data.address;\r\n}\r\nec->gpe = ecdt_ptr->gpe;\r\nret = acpi_config_boot_ec(ec, ACPI_ROOT_OBJECT, false, true);\r\nerror:\r\nif (ret)\r\nacpi_ec_free(ec);\r\nreturn ret;\r\n}\r\nstatic int acpi_ec_suspend_noirq(struct device *dev)\r\n{\r\nstruct acpi_ec *ec =\r\nacpi_driver_data(to_acpi_device(dev));\r\nacpi_ec_enter_noirq(ec);\r\nreturn 0;\r\n}\r\nstatic int acpi_ec_resume_noirq(struct device *dev)\r\n{\r\nstruct acpi_ec *ec =\r\nacpi_driver_data(to_acpi_device(dev));\r\nacpi_ec_leave_noirq(ec);\r\nreturn 0;\r\n}\r\nstatic int acpi_ec_suspend(struct device *dev)\r\n{\r\nstruct acpi_ec *ec =\r\nacpi_driver_data(to_acpi_device(dev));\r\nif (ec_freeze_events)\r\nacpi_ec_disable_event(ec);\r\nreturn 0;\r\n}\r\nstatic int acpi_ec_resume(struct device *dev)\r\n{\r\nstruct acpi_ec *ec =\r\nacpi_driver_data(to_acpi_device(dev));\r\nacpi_ec_enable_event(ec);\r\nreturn 0;\r\n}\r\nstatic int param_set_event_clearing(const char *val, struct kernel_param *kp)\r\n{\r\nint result = 0;\r\nif (!strncmp(val, "status", sizeof("status") - 1)) {\r\nec_event_clearing = ACPI_EC_EVT_TIMING_STATUS;\r\npr_info("Assuming SCI_EVT clearing on EC_SC accesses\n");\r\n} else if (!strncmp(val, "query", sizeof("query") - 1)) {\r\nec_event_clearing = ACPI_EC_EVT_TIMING_QUERY;\r\npr_info("Assuming SCI_EVT clearing on QR_EC writes\n");\r\n} else if (!strncmp(val, "event", sizeof("event") - 1)) {\r\nec_event_clearing = ACPI_EC_EVT_TIMING_EVENT;\r\npr_info("Assuming SCI_EVT clearing on event reads\n");\r\n} else\r\nresult = -EINVAL;\r\nreturn result;\r\n}\r\nstatic int param_get_event_clearing(char *buffer, struct kernel_param *kp)\r\n{\r\nswitch (ec_event_clearing) {\r\ncase ACPI_EC_EVT_TIMING_STATUS:\r\nreturn sprintf(buffer, "status");\r\ncase ACPI_EC_EVT_TIMING_QUERY:\r\nreturn sprintf(buffer, "query");\r\ncase ACPI_EC_EVT_TIMING_EVENT:\r\nreturn sprintf(buffer, "event");\r\ndefault:\r\nreturn sprintf(buffer, "invalid");\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int acpi_ec_query_init(void)\r\n{\r\nif (!ec_query_wq) {\r\nec_query_wq = alloc_workqueue("kec_query", 0,\r\nec_max_queries);\r\nif (!ec_query_wq)\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void acpi_ec_query_exit(void)\r\n{\r\nif (ec_query_wq) {\r\ndestroy_workqueue(ec_query_wq);\r\nec_query_wq = NULL;\r\n}\r\n}\r\nint __init acpi_ec_init(void)\r\n{\r\nint result;\r\nresult = acpi_ec_query_init();\r\nif (result)\r\ngoto err_exit;\r\nresult = acpi_bus_register_driver(&acpi_ec_driver);\r\nif (result)\r\ngoto err_exit;\r\nerr_exit:\r\nif (result)\r\nacpi_ec_query_exit();\r\nreturn result;\r\n}
