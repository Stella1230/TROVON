static inline bool\r\nisert_prot_cmd(struct isert_conn *conn, struct se_cmd *cmd)\r\n{\r\nreturn (conn->pi_support &&\r\ncmd->prot_op != TARGET_PROT_NORMAL);\r\n}\r\nstatic void\r\nisert_qp_event_callback(struct ib_event *e, void *context)\r\n{\r\nstruct isert_conn *isert_conn = context;\r\nisert_err("%s (%d): conn %p\n",\r\nib_event_msg(e->event), e->event, isert_conn);\r\nswitch (e->event) {\r\ncase IB_EVENT_COMM_EST:\r\nrdma_notify(isert_conn->cm_id, IB_EVENT_COMM_EST);\r\nbreak;\r\ncase IB_EVENT_QP_LAST_WQE_REACHED:\r\nisert_warn("Reached TX IB_EVENT_QP_LAST_WQE_REACHED\n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic struct isert_comp *\r\nisert_comp_get(struct isert_conn *isert_conn)\r\n{\r\nstruct isert_device *device = isert_conn->device;\r\nstruct isert_comp *comp;\r\nint i, min = 0;\r\nmutex_lock(&device_list_mutex);\r\nfor (i = 0; i < device->comps_used; i++)\r\nif (device->comps[i].active_qps <\r\ndevice->comps[min].active_qps)\r\nmin = i;\r\ncomp = &device->comps[min];\r\ncomp->active_qps++;\r\nmutex_unlock(&device_list_mutex);\r\nisert_info("conn %p, using comp %p min_index: %d\n",\r\nisert_conn, comp, min);\r\nreturn comp;\r\n}\r\nstatic void\r\nisert_comp_put(struct isert_comp *comp)\r\n{\r\nmutex_lock(&device_list_mutex);\r\ncomp->active_qps--;\r\nmutex_unlock(&device_list_mutex);\r\n}\r\nstatic struct ib_qp *\r\nisert_create_qp(struct isert_conn *isert_conn,\r\nstruct isert_comp *comp,\r\nstruct rdma_cm_id *cma_id)\r\n{\r\nstruct isert_device *device = isert_conn->device;\r\nstruct ib_qp_init_attr attr;\r\nint ret;\r\nmemset(&attr, 0, sizeof(struct ib_qp_init_attr));\r\nattr.event_handler = isert_qp_event_callback;\r\nattr.qp_context = isert_conn;\r\nattr.send_cq = comp->cq;\r\nattr.recv_cq = comp->cq;\r\nattr.cap.max_send_wr = ISERT_QP_MAX_REQ_DTOS + 1;\r\nattr.cap.max_recv_wr = ISERT_QP_MAX_RECV_DTOS + 1;\r\nattr.cap.max_rdma_ctxs = ISCSI_DEF_XMIT_CMDS_MAX;\r\nattr.cap.max_send_sge = device->ib_device->attrs.max_sge;\r\nattr.cap.max_recv_sge = 1;\r\nattr.sq_sig_type = IB_SIGNAL_REQ_WR;\r\nattr.qp_type = IB_QPT_RC;\r\nif (device->pi_capable)\r\nattr.create_flags |= IB_QP_CREATE_SIGNATURE_EN;\r\nret = rdma_create_qp(cma_id, device->pd, &attr);\r\nif (ret) {\r\nisert_err("rdma_create_qp failed for cma_id %d\n", ret);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn cma_id->qp;\r\n}\r\nstatic int\r\nisert_conn_setup_qp(struct isert_conn *isert_conn, struct rdma_cm_id *cma_id)\r\n{\r\nstruct isert_comp *comp;\r\nint ret;\r\ncomp = isert_comp_get(isert_conn);\r\nisert_conn->qp = isert_create_qp(isert_conn, comp, cma_id);\r\nif (IS_ERR(isert_conn->qp)) {\r\nret = PTR_ERR(isert_conn->qp);\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nisert_comp_put(comp);\r\nreturn ret;\r\n}\r\nstatic int\r\nisert_alloc_rx_descriptors(struct isert_conn *isert_conn)\r\n{\r\nstruct isert_device *device = isert_conn->device;\r\nstruct ib_device *ib_dev = device->ib_device;\r\nstruct iser_rx_desc *rx_desc;\r\nstruct ib_sge *rx_sg;\r\nu64 dma_addr;\r\nint i, j;\r\nisert_conn->rx_descs = kzalloc(ISERT_QP_MAX_RECV_DTOS *\r\nsizeof(struct iser_rx_desc), GFP_KERNEL);\r\nif (!isert_conn->rx_descs)\r\nreturn -ENOMEM;\r\nrx_desc = isert_conn->rx_descs;\r\nfor (i = 0; i < ISERT_QP_MAX_RECV_DTOS; i++, rx_desc++) {\r\ndma_addr = ib_dma_map_single(ib_dev, (void *)rx_desc,\r\nISER_RX_PAYLOAD_SIZE, DMA_FROM_DEVICE);\r\nif (ib_dma_mapping_error(ib_dev, dma_addr))\r\ngoto dma_map_fail;\r\nrx_desc->dma_addr = dma_addr;\r\nrx_sg = &rx_desc->rx_sg;\r\nrx_sg->addr = rx_desc->dma_addr;\r\nrx_sg->length = ISER_RX_PAYLOAD_SIZE;\r\nrx_sg->lkey = device->pd->local_dma_lkey;\r\nrx_desc->rx_cqe.done = isert_recv_done;\r\n}\r\nreturn 0;\r\ndma_map_fail:\r\nrx_desc = isert_conn->rx_descs;\r\nfor (j = 0; j < i; j++, rx_desc++) {\r\nib_dma_unmap_single(ib_dev, rx_desc->dma_addr,\r\nISER_RX_PAYLOAD_SIZE, DMA_FROM_DEVICE);\r\n}\r\nkfree(isert_conn->rx_descs);\r\nisert_conn->rx_descs = NULL;\r\nisert_err("conn %p failed to allocate rx descriptors\n", isert_conn);\r\nreturn -ENOMEM;\r\n}\r\nstatic void\r\nisert_free_rx_descriptors(struct isert_conn *isert_conn)\r\n{\r\nstruct ib_device *ib_dev = isert_conn->device->ib_device;\r\nstruct iser_rx_desc *rx_desc;\r\nint i;\r\nif (!isert_conn->rx_descs)\r\nreturn;\r\nrx_desc = isert_conn->rx_descs;\r\nfor (i = 0; i < ISERT_QP_MAX_RECV_DTOS; i++, rx_desc++) {\r\nib_dma_unmap_single(ib_dev, rx_desc->dma_addr,\r\nISER_RX_PAYLOAD_SIZE, DMA_FROM_DEVICE);\r\n}\r\nkfree(isert_conn->rx_descs);\r\nisert_conn->rx_descs = NULL;\r\n}\r\nstatic void\r\nisert_free_comps(struct isert_device *device)\r\n{\r\nint i;\r\nfor (i = 0; i < device->comps_used; i++) {\r\nstruct isert_comp *comp = &device->comps[i];\r\nif (comp->cq)\r\nib_free_cq(comp->cq);\r\n}\r\nkfree(device->comps);\r\n}\r\nstatic int\r\nisert_alloc_comps(struct isert_device *device)\r\n{\r\nint i, max_cqe, ret = 0;\r\ndevice->comps_used = min(ISERT_MAX_CQ, min_t(int, num_online_cpus(),\r\ndevice->ib_device->num_comp_vectors));\r\nisert_info("Using %d CQs, %s supports %d vectors support "\r\n"pi_capable %d\n",\r\ndevice->comps_used, device->ib_device->name,\r\ndevice->ib_device->num_comp_vectors,\r\ndevice->pi_capable);\r\ndevice->comps = kcalloc(device->comps_used, sizeof(struct isert_comp),\r\nGFP_KERNEL);\r\nif (!device->comps)\r\nreturn -ENOMEM;\r\nmax_cqe = min(ISER_MAX_CQ_LEN, device->ib_device->attrs.max_cqe);\r\nfor (i = 0; i < device->comps_used; i++) {\r\nstruct isert_comp *comp = &device->comps[i];\r\ncomp->device = device;\r\ncomp->cq = ib_alloc_cq(device->ib_device, comp, max_cqe, i,\r\nIB_POLL_WORKQUEUE);\r\nif (IS_ERR(comp->cq)) {\r\nisert_err("Unable to allocate cq\n");\r\nret = PTR_ERR(comp->cq);\r\ncomp->cq = NULL;\r\ngoto out_cq;\r\n}\r\n}\r\nreturn 0;\r\nout_cq:\r\nisert_free_comps(device);\r\nreturn ret;\r\n}\r\nstatic int\r\nisert_create_device_ib_res(struct isert_device *device)\r\n{\r\nstruct ib_device *ib_dev = device->ib_device;\r\nint ret;\r\nisert_dbg("devattr->max_sge: %d\n", ib_dev->attrs.max_sge);\r\nisert_dbg("devattr->max_sge_rd: %d\n", ib_dev->attrs.max_sge_rd);\r\nret = isert_alloc_comps(device);\r\nif (ret)\r\ngoto out;\r\ndevice->pd = ib_alloc_pd(ib_dev, 0);\r\nif (IS_ERR(device->pd)) {\r\nret = PTR_ERR(device->pd);\r\nisert_err("failed to allocate pd, device %p, ret=%d\n",\r\ndevice, ret);\r\ngoto out_cq;\r\n}\r\ndevice->pi_capable = ib_dev->attrs.device_cap_flags &\r\nIB_DEVICE_SIGNATURE_HANDOVER ? true : false;\r\nreturn 0;\r\nout_cq:\r\nisert_free_comps(device);\r\nout:\r\nif (ret > 0)\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic void\r\nisert_free_device_ib_res(struct isert_device *device)\r\n{\r\nisert_info("device %p\n", device);\r\nib_dealloc_pd(device->pd);\r\nisert_free_comps(device);\r\n}\r\nstatic void\r\nisert_device_put(struct isert_device *device)\r\n{\r\nmutex_lock(&device_list_mutex);\r\ndevice->refcount--;\r\nisert_info("device %p refcount %d\n", device, device->refcount);\r\nif (!device->refcount) {\r\nisert_free_device_ib_res(device);\r\nlist_del(&device->dev_node);\r\nkfree(device);\r\n}\r\nmutex_unlock(&device_list_mutex);\r\n}\r\nstatic struct isert_device *\r\nisert_device_get(struct rdma_cm_id *cma_id)\r\n{\r\nstruct isert_device *device;\r\nint ret;\r\nmutex_lock(&device_list_mutex);\r\nlist_for_each_entry(device, &device_list, dev_node) {\r\nif (device->ib_device->node_guid == cma_id->device->node_guid) {\r\ndevice->refcount++;\r\nisert_info("Found iser device %p refcount %d\n",\r\ndevice, device->refcount);\r\nmutex_unlock(&device_list_mutex);\r\nreturn device;\r\n}\r\n}\r\ndevice = kzalloc(sizeof(struct isert_device), GFP_KERNEL);\r\nif (!device) {\r\nmutex_unlock(&device_list_mutex);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nINIT_LIST_HEAD(&device->dev_node);\r\ndevice->ib_device = cma_id->device;\r\nret = isert_create_device_ib_res(device);\r\nif (ret) {\r\nkfree(device);\r\nmutex_unlock(&device_list_mutex);\r\nreturn ERR_PTR(ret);\r\n}\r\ndevice->refcount++;\r\nlist_add_tail(&device->dev_node, &device_list);\r\nisert_info("Created a new iser device %p refcount %d\n",\r\ndevice, device->refcount);\r\nmutex_unlock(&device_list_mutex);\r\nreturn device;\r\n}\r\nstatic void\r\nisert_init_conn(struct isert_conn *isert_conn)\r\n{\r\nisert_conn->state = ISER_CONN_INIT;\r\nINIT_LIST_HEAD(&isert_conn->node);\r\ninit_completion(&isert_conn->login_comp);\r\ninit_completion(&isert_conn->login_req_comp);\r\ninit_waitqueue_head(&isert_conn->rem_wait);\r\nkref_init(&isert_conn->kref);\r\nmutex_init(&isert_conn->mutex);\r\nINIT_WORK(&isert_conn->release_work, isert_release_work);\r\n}\r\nstatic void\r\nisert_free_login_buf(struct isert_conn *isert_conn)\r\n{\r\nstruct ib_device *ib_dev = isert_conn->device->ib_device;\r\nib_dma_unmap_single(ib_dev, isert_conn->login_rsp_dma,\r\nISER_RX_PAYLOAD_SIZE, DMA_TO_DEVICE);\r\nkfree(isert_conn->login_rsp_buf);\r\nib_dma_unmap_single(ib_dev, isert_conn->login_req_dma,\r\nISER_RX_PAYLOAD_SIZE,\r\nDMA_FROM_DEVICE);\r\nkfree(isert_conn->login_req_buf);\r\n}\r\nstatic int\r\nisert_alloc_login_buf(struct isert_conn *isert_conn,\r\nstruct ib_device *ib_dev)\r\n{\r\nint ret;\r\nisert_conn->login_req_buf = kzalloc(sizeof(*isert_conn->login_req_buf),\r\nGFP_KERNEL);\r\nif (!isert_conn->login_req_buf)\r\nreturn -ENOMEM;\r\nisert_conn->login_req_dma = ib_dma_map_single(ib_dev,\r\nisert_conn->login_req_buf,\r\nISER_RX_PAYLOAD_SIZE, DMA_FROM_DEVICE);\r\nret = ib_dma_mapping_error(ib_dev, isert_conn->login_req_dma);\r\nif (ret) {\r\nisert_err("login_req_dma mapping error: %d\n", ret);\r\nisert_conn->login_req_dma = 0;\r\ngoto out_free_login_req_buf;\r\n}\r\nisert_conn->login_rsp_buf = kzalloc(ISER_RX_PAYLOAD_SIZE, GFP_KERNEL);\r\nif (!isert_conn->login_rsp_buf) {\r\nret = -ENOMEM;\r\ngoto out_unmap_login_req_buf;\r\n}\r\nisert_conn->login_rsp_dma = ib_dma_map_single(ib_dev,\r\nisert_conn->login_rsp_buf,\r\nISER_RX_PAYLOAD_SIZE, DMA_TO_DEVICE);\r\nret = ib_dma_mapping_error(ib_dev, isert_conn->login_rsp_dma);\r\nif (ret) {\r\nisert_err("login_rsp_dma mapping error: %d\n", ret);\r\nisert_conn->login_rsp_dma = 0;\r\ngoto out_free_login_rsp_buf;\r\n}\r\nreturn 0;\r\nout_free_login_rsp_buf:\r\nkfree(isert_conn->login_rsp_buf);\r\nout_unmap_login_req_buf:\r\nib_dma_unmap_single(ib_dev, isert_conn->login_req_dma,\r\nISER_RX_PAYLOAD_SIZE, DMA_FROM_DEVICE);\r\nout_free_login_req_buf:\r\nkfree(isert_conn->login_req_buf);\r\nreturn ret;\r\n}\r\nstatic void\r\nisert_set_nego_params(struct isert_conn *isert_conn,\r\nstruct rdma_conn_param *param)\r\n{\r\nstruct ib_device_attr *attr = &isert_conn->device->ib_device->attrs;\r\nisert_conn->initiator_depth = min_t(u8, param->initiator_depth,\r\nattr->max_qp_init_rd_atom);\r\nisert_dbg("Using initiator_depth: %u\n", isert_conn->initiator_depth);\r\nif (param->private_data) {\r\nu8 flags = *(u8 *)param->private_data;\r\nisert_conn->snd_w_inv = !(flags & ISER_SEND_W_INV_NOT_SUP) &&\r\n(attr->device_cap_flags &\r\nIB_DEVICE_MEM_MGT_EXTENSIONS);\r\nif (isert_conn->snd_w_inv)\r\nisert_info("Using remote invalidation\n");\r\n}\r\n}\r\nstatic int\r\nisert_connect_request(struct rdma_cm_id *cma_id, struct rdma_cm_event *event)\r\n{\r\nstruct isert_np *isert_np = cma_id->context;\r\nstruct iscsi_np *np = isert_np->np;\r\nstruct isert_conn *isert_conn;\r\nstruct isert_device *device;\r\nint ret = 0;\r\nspin_lock_bh(&np->np_thread_lock);\r\nif (!np->enabled) {\r\nspin_unlock_bh(&np->np_thread_lock);\r\nisert_dbg("iscsi_np is not enabled, reject connect request\n");\r\nreturn rdma_reject(cma_id, NULL, 0);\r\n}\r\nspin_unlock_bh(&np->np_thread_lock);\r\nisert_dbg("cma_id: %p, portal: %p\n",\r\ncma_id, cma_id->context);\r\nisert_conn = kzalloc(sizeof(struct isert_conn), GFP_KERNEL);\r\nif (!isert_conn)\r\nreturn -ENOMEM;\r\nisert_init_conn(isert_conn);\r\nisert_conn->cm_id = cma_id;\r\nret = isert_alloc_login_buf(isert_conn, cma_id->device);\r\nif (ret)\r\ngoto out;\r\ndevice = isert_device_get(cma_id);\r\nif (IS_ERR(device)) {\r\nret = PTR_ERR(device);\r\ngoto out_rsp_dma_map;\r\n}\r\nisert_conn->device = device;\r\nisert_set_nego_params(isert_conn, &event->param.conn);\r\nret = isert_conn_setup_qp(isert_conn, cma_id);\r\nif (ret)\r\ngoto out_conn_dev;\r\nret = isert_login_post_recv(isert_conn);\r\nif (ret)\r\ngoto out_conn_dev;\r\nret = isert_rdma_accept(isert_conn);\r\nif (ret)\r\ngoto out_conn_dev;\r\nmutex_lock(&isert_np->mutex);\r\nlist_add_tail(&isert_conn->node, &isert_np->accepted);\r\nmutex_unlock(&isert_np->mutex);\r\nreturn 0;\r\nout_conn_dev:\r\nisert_device_put(device);\r\nout_rsp_dma_map:\r\nisert_free_login_buf(isert_conn);\r\nout:\r\nkfree(isert_conn);\r\nrdma_reject(cma_id, NULL, 0);\r\nreturn ret;\r\n}\r\nstatic void\r\nisert_connect_release(struct isert_conn *isert_conn)\r\n{\r\nstruct isert_device *device = isert_conn->device;\r\nisert_dbg("conn %p\n", isert_conn);\r\nBUG_ON(!device);\r\nisert_free_rx_descriptors(isert_conn);\r\nif (isert_conn->cm_id &&\r\n!isert_conn->dev_removed)\r\nrdma_destroy_id(isert_conn->cm_id);\r\nif (isert_conn->qp) {\r\nstruct isert_comp *comp = isert_conn->qp->recv_cq->cq_context;\r\nisert_comp_put(comp);\r\nib_destroy_qp(isert_conn->qp);\r\n}\r\nif (isert_conn->login_req_buf)\r\nisert_free_login_buf(isert_conn);\r\nisert_device_put(device);\r\nif (isert_conn->dev_removed)\r\nwake_up_interruptible(&isert_conn->rem_wait);\r\nelse\r\nkfree(isert_conn);\r\n}\r\nstatic void\r\nisert_connected_handler(struct rdma_cm_id *cma_id)\r\n{\r\nstruct isert_conn *isert_conn = cma_id->qp->qp_context;\r\nstruct isert_np *isert_np = cma_id->context;\r\nisert_info("conn %p\n", isert_conn);\r\nmutex_lock(&isert_conn->mutex);\r\nisert_conn->state = ISER_CONN_UP;\r\nkref_get(&isert_conn->kref);\r\nmutex_unlock(&isert_conn->mutex);\r\nmutex_lock(&isert_np->mutex);\r\nlist_move_tail(&isert_conn->node, &isert_np->pending);\r\nmutex_unlock(&isert_np->mutex);\r\nisert_info("np %p: Allow accept_np to continue\n", isert_np);\r\nup(&isert_np->sem);\r\n}\r\nstatic void\r\nisert_release_kref(struct kref *kref)\r\n{\r\nstruct isert_conn *isert_conn = container_of(kref,\r\nstruct isert_conn, kref);\r\nisert_info("conn %p final kref %s/%d\n", isert_conn, current->comm,\r\ncurrent->pid);\r\nisert_connect_release(isert_conn);\r\n}\r\nstatic void\r\nisert_put_conn(struct isert_conn *isert_conn)\r\n{\r\nkref_put(&isert_conn->kref, isert_release_kref);\r\n}\r\nstatic void\r\nisert_handle_unbound_conn(struct isert_conn *isert_conn)\r\n{\r\nstruct isert_np *isert_np = isert_conn->cm_id->context;\r\nmutex_lock(&isert_np->mutex);\r\nif (!list_empty(&isert_conn->node)) {\r\nlist_del_init(&isert_conn->node);\r\nisert_put_conn(isert_conn);\r\nqueue_work(isert_release_wq, &isert_conn->release_work);\r\n}\r\nmutex_unlock(&isert_np->mutex);\r\n}\r\nstatic void\r\nisert_conn_terminate(struct isert_conn *isert_conn)\r\n{\r\nint err;\r\nif (isert_conn->state >= ISER_CONN_TERMINATING)\r\nreturn;\r\nisert_info("Terminating conn %p state %d\n",\r\nisert_conn, isert_conn->state);\r\nisert_conn->state = ISER_CONN_TERMINATING;\r\nerr = rdma_disconnect(isert_conn->cm_id);\r\nif (err)\r\nisert_warn("Failed rdma_disconnect isert_conn %p\n",\r\nisert_conn);\r\n}\r\nstatic int\r\nisert_np_cma_handler(struct isert_np *isert_np,\r\nenum rdma_cm_event_type event)\r\n{\r\nisert_dbg("%s (%d): isert np %p\n",\r\nrdma_event_msg(event), event, isert_np);\r\nswitch (event) {\r\ncase RDMA_CM_EVENT_DEVICE_REMOVAL:\r\nisert_np->cm_id = NULL;\r\nbreak;\r\ncase RDMA_CM_EVENT_ADDR_CHANGE:\r\nisert_np->cm_id = isert_setup_id(isert_np);\r\nif (IS_ERR(isert_np->cm_id)) {\r\nisert_err("isert np %p setup id failed: %ld\n",\r\nisert_np, PTR_ERR(isert_np->cm_id));\r\nisert_np->cm_id = NULL;\r\n}\r\nbreak;\r\ndefault:\r\nisert_err("isert np %p Unexpected event %d\n",\r\nisert_np, event);\r\n}\r\nreturn -1;\r\n}\r\nstatic int\r\nisert_disconnected_handler(struct rdma_cm_id *cma_id,\r\nenum rdma_cm_event_type event)\r\n{\r\nstruct isert_conn *isert_conn = cma_id->qp->qp_context;\r\nmutex_lock(&isert_conn->mutex);\r\nswitch (isert_conn->state) {\r\ncase ISER_CONN_TERMINATING:\r\nbreak;\r\ncase ISER_CONN_UP:\r\nisert_conn_terminate(isert_conn);\r\nib_drain_qp(isert_conn->qp);\r\nisert_handle_unbound_conn(isert_conn);\r\nbreak;\r\ncase ISER_CONN_BOUND:\r\ncase ISER_CONN_FULL_FEATURE:\r\niscsit_cause_connection_reinstatement(isert_conn->conn, 0);\r\nbreak;\r\ndefault:\r\nisert_warn("conn %p terminating in state %d\n",\r\nisert_conn, isert_conn->state);\r\n}\r\nmutex_unlock(&isert_conn->mutex);\r\nreturn 0;\r\n}\r\nstatic int\r\nisert_connect_error(struct rdma_cm_id *cma_id)\r\n{\r\nstruct isert_conn *isert_conn = cma_id->qp->qp_context;\r\nlist_del_init(&isert_conn->node);\r\nisert_conn->cm_id = NULL;\r\nisert_put_conn(isert_conn);\r\nreturn -1;\r\n}\r\nstatic int\r\nisert_cma_handler(struct rdma_cm_id *cma_id, struct rdma_cm_event *event)\r\n{\r\nstruct isert_np *isert_np = cma_id->context;\r\nstruct isert_conn *isert_conn;\r\nint ret = 0;\r\nisert_info("%s (%d): status %d id %p np %p\n",\r\nrdma_event_msg(event->event), event->event,\r\nevent->status, cma_id, cma_id->context);\r\nif (isert_np->cm_id == cma_id)\r\nreturn isert_np_cma_handler(cma_id->context, event->event);\r\nswitch (event->event) {\r\ncase RDMA_CM_EVENT_CONNECT_REQUEST:\r\nret = isert_connect_request(cma_id, event);\r\nif (ret)\r\nisert_err("failed handle connect request %d\n", ret);\r\nbreak;\r\ncase RDMA_CM_EVENT_ESTABLISHED:\r\nisert_connected_handler(cma_id);\r\nbreak;\r\ncase RDMA_CM_EVENT_ADDR_CHANGE:\r\ncase RDMA_CM_EVENT_DISCONNECTED:\r\ncase RDMA_CM_EVENT_TIMEWAIT_EXIT:\r\nret = isert_disconnected_handler(cma_id, event->event);\r\nbreak;\r\ncase RDMA_CM_EVENT_DEVICE_REMOVAL:\r\nisert_conn = cma_id->qp->qp_context;\r\nisert_conn->dev_removed = true;\r\nisert_disconnected_handler(cma_id, event->event);\r\nwait_event_interruptible(isert_conn->rem_wait,\r\nisert_conn->state == ISER_CONN_DOWN);\r\nkfree(isert_conn);\r\nreturn 1;\r\ncase RDMA_CM_EVENT_REJECTED:\r\nisert_info("Connection rejected: %s\n",\r\nrdma_reject_msg(cma_id, event->status));\r\ncase RDMA_CM_EVENT_UNREACHABLE:\r\ncase RDMA_CM_EVENT_CONNECT_ERROR:\r\nret = isert_connect_error(cma_id);\r\nbreak;\r\ndefault:\r\nisert_err("Unhandled RDMA CMA event: %d\n", event->event);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nisert_post_recvm(struct isert_conn *isert_conn, u32 count)\r\n{\r\nstruct ib_recv_wr *rx_wr, *rx_wr_failed;\r\nint i, ret;\r\nstruct iser_rx_desc *rx_desc;\r\nfor (rx_wr = isert_conn->rx_wr, i = 0; i < count; i++, rx_wr++) {\r\nrx_desc = &isert_conn->rx_descs[i];\r\nrx_wr->wr_cqe = &rx_desc->rx_cqe;\r\nrx_wr->sg_list = &rx_desc->rx_sg;\r\nrx_wr->num_sge = 1;\r\nrx_wr->next = rx_wr + 1;\r\nrx_desc->in_use = false;\r\n}\r\nrx_wr--;\r\nrx_wr->next = NULL;\r\nret = ib_post_recv(isert_conn->qp, isert_conn->rx_wr,\r\n&rx_wr_failed);\r\nif (ret)\r\nisert_err("ib_post_recv() failed with ret: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int\r\nisert_post_recv(struct isert_conn *isert_conn, struct iser_rx_desc *rx_desc)\r\n{\r\nstruct ib_recv_wr *rx_wr_failed, rx_wr;\r\nint ret;\r\nif (!rx_desc->in_use) {\r\nreturn 0;\r\n}\r\nrx_desc->in_use = false;\r\nrx_wr.wr_cqe = &rx_desc->rx_cqe;\r\nrx_wr.sg_list = &rx_desc->rx_sg;\r\nrx_wr.num_sge = 1;\r\nrx_wr.next = NULL;\r\nret = ib_post_recv(isert_conn->qp, &rx_wr, &rx_wr_failed);\r\nif (ret)\r\nisert_err("ib_post_recv() failed with ret: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int\r\nisert_login_post_send(struct isert_conn *isert_conn, struct iser_tx_desc *tx_desc)\r\n{\r\nstruct ib_device *ib_dev = isert_conn->cm_id->device;\r\nstruct ib_send_wr send_wr, *send_wr_failed;\r\nint ret;\r\nib_dma_sync_single_for_device(ib_dev, tx_desc->dma_addr,\r\nISER_HEADERS_LEN, DMA_TO_DEVICE);\r\ntx_desc->tx_cqe.done = isert_login_send_done;\r\nsend_wr.next = NULL;\r\nsend_wr.wr_cqe = &tx_desc->tx_cqe;\r\nsend_wr.sg_list = tx_desc->tx_sg;\r\nsend_wr.num_sge = tx_desc->num_sge;\r\nsend_wr.opcode = IB_WR_SEND;\r\nsend_wr.send_flags = IB_SEND_SIGNALED;\r\nret = ib_post_send(isert_conn->qp, &send_wr, &send_wr_failed);\r\nif (ret)\r\nisert_err("ib_post_send() failed, ret: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void\r\nisert_create_send_desc(struct isert_conn *isert_conn,\r\nstruct isert_cmd *isert_cmd,\r\nstruct iser_tx_desc *tx_desc)\r\n{\r\nstruct isert_device *device = isert_conn->device;\r\nstruct ib_device *ib_dev = device->ib_device;\r\nib_dma_sync_single_for_cpu(ib_dev, tx_desc->dma_addr,\r\nISER_HEADERS_LEN, DMA_TO_DEVICE);\r\nmemset(&tx_desc->iser_header, 0, sizeof(struct iser_ctrl));\r\ntx_desc->iser_header.flags = ISCSI_CTRL;\r\ntx_desc->num_sge = 1;\r\nif (tx_desc->tx_sg[0].lkey != device->pd->local_dma_lkey) {\r\ntx_desc->tx_sg[0].lkey = device->pd->local_dma_lkey;\r\nisert_dbg("tx_desc %p lkey mismatch, fixing\n", tx_desc);\r\n}\r\n}\r\nstatic int\r\nisert_init_tx_hdrs(struct isert_conn *isert_conn,\r\nstruct iser_tx_desc *tx_desc)\r\n{\r\nstruct isert_device *device = isert_conn->device;\r\nstruct ib_device *ib_dev = device->ib_device;\r\nu64 dma_addr;\r\ndma_addr = ib_dma_map_single(ib_dev, (void *)tx_desc,\r\nISER_HEADERS_LEN, DMA_TO_DEVICE);\r\nif (ib_dma_mapping_error(ib_dev, dma_addr)) {\r\nisert_err("ib_dma_mapping_error() failed\n");\r\nreturn -ENOMEM;\r\n}\r\ntx_desc->dma_addr = dma_addr;\r\ntx_desc->tx_sg[0].addr = tx_desc->dma_addr;\r\ntx_desc->tx_sg[0].length = ISER_HEADERS_LEN;\r\ntx_desc->tx_sg[0].lkey = device->pd->local_dma_lkey;\r\nisert_dbg("Setup tx_sg[0].addr: 0x%llx length: %u lkey: 0x%x\n",\r\ntx_desc->tx_sg[0].addr, tx_desc->tx_sg[0].length,\r\ntx_desc->tx_sg[0].lkey);\r\nreturn 0;\r\n}\r\nstatic void\r\nisert_init_send_wr(struct isert_conn *isert_conn, struct isert_cmd *isert_cmd,\r\nstruct ib_send_wr *send_wr)\r\n{\r\nstruct iser_tx_desc *tx_desc = &isert_cmd->tx_desc;\r\ntx_desc->tx_cqe.done = isert_send_done;\r\nsend_wr->wr_cqe = &tx_desc->tx_cqe;\r\nif (isert_conn->snd_w_inv && isert_cmd->inv_rkey) {\r\nsend_wr->opcode = IB_WR_SEND_WITH_INV;\r\nsend_wr->ex.invalidate_rkey = isert_cmd->inv_rkey;\r\n} else {\r\nsend_wr->opcode = IB_WR_SEND;\r\n}\r\nsend_wr->sg_list = &tx_desc->tx_sg[0];\r\nsend_wr->num_sge = isert_cmd->tx_desc.num_sge;\r\nsend_wr->send_flags = IB_SEND_SIGNALED;\r\n}\r\nstatic int\r\nisert_login_post_recv(struct isert_conn *isert_conn)\r\n{\r\nstruct ib_recv_wr rx_wr, *rx_wr_fail;\r\nstruct ib_sge sge;\r\nint ret;\r\nmemset(&sge, 0, sizeof(struct ib_sge));\r\nsge.addr = isert_conn->login_req_dma;\r\nsge.length = ISER_RX_PAYLOAD_SIZE;\r\nsge.lkey = isert_conn->device->pd->local_dma_lkey;\r\nisert_dbg("Setup sge: addr: %llx length: %d 0x%08x\n",\r\nsge.addr, sge.length, sge.lkey);\r\nisert_conn->login_req_buf->rx_cqe.done = isert_login_recv_done;\r\nmemset(&rx_wr, 0, sizeof(struct ib_recv_wr));\r\nrx_wr.wr_cqe = &isert_conn->login_req_buf->rx_cqe;\r\nrx_wr.sg_list = &sge;\r\nrx_wr.num_sge = 1;\r\nret = ib_post_recv(isert_conn->qp, &rx_wr, &rx_wr_fail);\r\nif (ret)\r\nisert_err("ib_post_recv() failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int\r\nisert_put_login_tx(struct iscsi_conn *conn, struct iscsi_login *login,\r\nu32 length)\r\n{\r\nstruct isert_conn *isert_conn = conn->context;\r\nstruct isert_device *device = isert_conn->device;\r\nstruct ib_device *ib_dev = device->ib_device;\r\nstruct iser_tx_desc *tx_desc = &isert_conn->login_tx_desc;\r\nint ret;\r\nisert_create_send_desc(isert_conn, NULL, tx_desc);\r\nmemcpy(&tx_desc->iscsi_header, &login->rsp[0],\r\nsizeof(struct iscsi_hdr));\r\nisert_init_tx_hdrs(isert_conn, tx_desc);\r\nif (length > 0) {\r\nstruct ib_sge *tx_dsg = &tx_desc->tx_sg[1];\r\nib_dma_sync_single_for_cpu(ib_dev, isert_conn->login_rsp_dma,\r\nlength, DMA_TO_DEVICE);\r\nmemcpy(isert_conn->login_rsp_buf, login->rsp_buf, length);\r\nib_dma_sync_single_for_device(ib_dev, isert_conn->login_rsp_dma,\r\nlength, DMA_TO_DEVICE);\r\ntx_dsg->addr = isert_conn->login_rsp_dma;\r\ntx_dsg->length = length;\r\ntx_dsg->lkey = isert_conn->device->pd->local_dma_lkey;\r\ntx_desc->num_sge = 2;\r\n}\r\nif (!login->login_failed) {\r\nif (login->login_complete) {\r\nret = isert_alloc_rx_descriptors(isert_conn);\r\nif (ret)\r\nreturn ret;\r\nret = isert_post_recvm(isert_conn,\r\nISERT_QP_MAX_RECV_DTOS);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&isert_conn->mutex);\r\nisert_conn->state = ISER_CONN_FULL_FEATURE;\r\nmutex_unlock(&isert_conn->mutex);\r\ngoto post_send;\r\n}\r\nret = isert_login_post_recv(isert_conn);\r\nif (ret)\r\nreturn ret;\r\n}\r\npost_send:\r\nret = isert_login_post_send(isert_conn, tx_desc);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void\r\nisert_rx_login_req(struct isert_conn *isert_conn)\r\n{\r\nstruct iser_rx_desc *rx_desc = isert_conn->login_req_buf;\r\nint rx_buflen = isert_conn->login_req_len;\r\nstruct iscsi_conn *conn = isert_conn->conn;\r\nstruct iscsi_login *login = conn->conn_login;\r\nint size;\r\nisert_info("conn %p\n", isert_conn);\r\nWARN_ON_ONCE(!login);\r\nif (login->first_request) {\r\nstruct iscsi_login_req *login_req =\r\n(struct iscsi_login_req *)&rx_desc->iscsi_header;\r\nlogin->leading_connection = (!login_req->tsih) ? 1 : 0;\r\nlogin->current_stage =\r\n(login_req->flags & ISCSI_FLAG_LOGIN_CURRENT_STAGE_MASK)\r\n>> 2;\r\nlogin->version_min = login_req->min_version;\r\nlogin->version_max = login_req->max_version;\r\nmemcpy(login->isid, login_req->isid, 6);\r\nlogin->cmd_sn = be32_to_cpu(login_req->cmdsn);\r\nlogin->init_task_tag = login_req->itt;\r\nlogin->initial_exp_statsn = be32_to_cpu(login_req->exp_statsn);\r\nlogin->cid = be16_to_cpu(login_req->cid);\r\nlogin->tsih = be16_to_cpu(login_req->tsih);\r\n}\r\nmemcpy(&login->req[0], (void *)&rx_desc->iscsi_header, ISCSI_HDR_LEN);\r\nsize = min(rx_buflen, MAX_KEY_VALUE_PAIRS);\r\nisert_dbg("Using login payload size: %d, rx_buflen: %d "\r\n"MAX_KEY_VALUE_PAIRS: %d\n", size, rx_buflen,\r\nMAX_KEY_VALUE_PAIRS);\r\nmemcpy(login->req_buf, &rx_desc->data[0], size);\r\nif (login->first_request) {\r\ncomplete(&isert_conn->login_comp);\r\nreturn;\r\n}\r\nschedule_delayed_work(&conn->login_work, 0);\r\n}\r\nstatic struct iscsi_cmd\r\n*isert_allocate_cmd(struct iscsi_conn *conn, struct iser_rx_desc *rx_desc)\r\n{\r\nstruct isert_conn *isert_conn = conn->context;\r\nstruct isert_cmd *isert_cmd;\r\nstruct iscsi_cmd *cmd;\r\ncmd = iscsit_allocate_cmd(conn, TASK_INTERRUPTIBLE);\r\nif (!cmd) {\r\nisert_err("Unable to allocate iscsi_cmd + isert_cmd\n");\r\nreturn NULL;\r\n}\r\nisert_cmd = iscsit_priv_cmd(cmd);\r\nisert_cmd->conn = isert_conn;\r\nisert_cmd->iscsi_cmd = cmd;\r\nisert_cmd->rx_desc = rx_desc;\r\nreturn cmd;\r\n}\r\nstatic int\r\nisert_handle_scsi_cmd(struct isert_conn *isert_conn,\r\nstruct isert_cmd *isert_cmd, struct iscsi_cmd *cmd,\r\nstruct iser_rx_desc *rx_desc, unsigned char *buf)\r\n{\r\nstruct iscsi_conn *conn = isert_conn->conn;\r\nstruct iscsi_scsi_req *hdr = (struct iscsi_scsi_req *)buf;\r\nint imm_data, imm_data_len, unsol_data, sg_nents, rc;\r\nbool dump_payload = false;\r\nunsigned int data_len;\r\nrc = iscsit_setup_scsi_cmd(conn, cmd, buf);\r\nif (rc < 0)\r\nreturn rc;\r\nimm_data = cmd->immediate_data;\r\nimm_data_len = cmd->first_burst_len;\r\nunsol_data = cmd->unsolicited_data;\r\ndata_len = cmd->se_cmd.data_length;\r\nif (imm_data && imm_data_len == data_len)\r\ncmd->se_cmd.se_cmd_flags |= SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC;\r\nrc = iscsit_process_scsi_cmd(conn, cmd, hdr);\r\nif (rc < 0) {\r\nreturn 0;\r\n} else if (rc > 0) {\r\ndump_payload = true;\r\ngoto sequence_cmd;\r\n}\r\nif (!imm_data)\r\nreturn 0;\r\nif (imm_data_len != data_len) {\r\nsg_nents = max(1UL, DIV_ROUND_UP(imm_data_len, PAGE_SIZE));\r\nsg_copy_from_buffer(cmd->se_cmd.t_data_sg, sg_nents,\r\n&rx_desc->data[0], imm_data_len);\r\nisert_dbg("Copy Immediate sg_nents: %u imm_data_len: %d\n",\r\nsg_nents, imm_data_len);\r\n} else {\r\nsg_init_table(&isert_cmd->sg, 1);\r\ncmd->se_cmd.t_data_sg = &isert_cmd->sg;\r\ncmd->se_cmd.t_data_nents = 1;\r\nsg_set_buf(&isert_cmd->sg, &rx_desc->data[0], imm_data_len);\r\nisert_dbg("Transfer Immediate imm_data_len: %d\n",\r\nimm_data_len);\r\n}\r\ncmd->write_data_done += imm_data_len;\r\nif (cmd->write_data_done == cmd->se_cmd.data_length) {\r\nspin_lock_bh(&cmd->istate_lock);\r\ncmd->cmd_flags |= ICF_GOT_LAST_DATAOUT;\r\ncmd->i_state = ISTATE_RECEIVED_LAST_DATAOUT;\r\nspin_unlock_bh(&cmd->istate_lock);\r\n}\r\nsequence_cmd:\r\nrc = iscsit_sequence_cmd(conn, cmd, buf, hdr->cmdsn);\r\nif (!rc && dump_payload == false && unsol_data)\r\niscsit_set_unsoliticed_dataout(cmd);\r\nelse if (dump_payload && imm_data)\r\ntarget_put_sess_cmd(&cmd->se_cmd);\r\nreturn 0;\r\n}\r\nstatic int\r\nisert_handle_iscsi_dataout(struct isert_conn *isert_conn,\r\nstruct iser_rx_desc *rx_desc, unsigned char *buf)\r\n{\r\nstruct scatterlist *sg_start;\r\nstruct iscsi_conn *conn = isert_conn->conn;\r\nstruct iscsi_cmd *cmd = NULL;\r\nstruct iscsi_data *hdr = (struct iscsi_data *)buf;\r\nu32 unsol_data_len = ntoh24(hdr->dlength);\r\nint rc, sg_nents, sg_off, page_off;\r\nrc = iscsit_check_dataout_hdr(conn, buf, &cmd);\r\nif (rc < 0)\r\nreturn rc;\r\nelse if (!cmd)\r\nreturn 0;\r\nif (!cmd->unsolicited_data) {\r\nisert_err("Received unexpected solicited data payload\n");\r\ndump_stack();\r\nreturn -1;\r\n}\r\nisert_dbg("Unsolicited DataOut unsol_data_len: %u, "\r\n"write_data_done: %u, data_length: %u\n",\r\nunsol_data_len, cmd->write_data_done,\r\ncmd->se_cmd.data_length);\r\nsg_off = cmd->write_data_done / PAGE_SIZE;\r\nsg_start = &cmd->se_cmd.t_data_sg[sg_off];\r\nsg_nents = max(1UL, DIV_ROUND_UP(unsol_data_len, PAGE_SIZE));\r\npage_off = cmd->write_data_done % PAGE_SIZE;\r\nif (page_off) {\r\nisert_err("unexpected non-page aligned data payload\n");\r\ndump_stack();\r\nreturn -1;\r\n}\r\nisert_dbg("Copying DataOut: sg_start: %p, sg_off: %u "\r\n"sg_nents: %u from %p %u\n", sg_start, sg_off,\r\nsg_nents, &rx_desc->data[0], unsol_data_len);\r\nsg_copy_from_buffer(sg_start, sg_nents, &rx_desc->data[0],\r\nunsol_data_len);\r\nrc = iscsit_check_dataout_payload(cmd, hdr, false);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = isert_post_recv(isert_conn, rx_desc);\r\nif (rc) {\r\nisert_err("ib_post_recv failed with %d\n", rc);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nisert_handle_nop_out(struct isert_conn *isert_conn, struct isert_cmd *isert_cmd,\r\nstruct iscsi_cmd *cmd, struct iser_rx_desc *rx_desc,\r\nunsigned char *buf)\r\n{\r\nstruct iscsi_conn *conn = isert_conn->conn;\r\nstruct iscsi_nopout *hdr = (struct iscsi_nopout *)buf;\r\nint rc;\r\nrc = iscsit_setup_nop_out(conn, cmd, hdr);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn iscsit_process_nop_out(conn, cmd, hdr);\r\n}\r\nstatic int\r\nisert_handle_text_cmd(struct isert_conn *isert_conn, struct isert_cmd *isert_cmd,\r\nstruct iscsi_cmd *cmd, struct iser_rx_desc *rx_desc,\r\nstruct iscsi_text *hdr)\r\n{\r\nstruct iscsi_conn *conn = isert_conn->conn;\r\nu32 payload_length = ntoh24(hdr->dlength);\r\nint rc;\r\nunsigned char *text_in = NULL;\r\nrc = iscsit_setup_text_cmd(conn, cmd, hdr);\r\nif (rc < 0)\r\nreturn rc;\r\nif (payload_length) {\r\ntext_in = kzalloc(payload_length, GFP_KERNEL);\r\nif (!text_in)\r\nreturn -ENOMEM;\r\n}\r\ncmd->text_in_ptr = text_in;\r\nmemcpy(cmd->text_in_ptr, &rx_desc->data[0], payload_length);\r\nreturn iscsit_process_text_cmd(conn, cmd, hdr);\r\n}\r\nstatic int\r\nisert_rx_opcode(struct isert_conn *isert_conn, struct iser_rx_desc *rx_desc,\r\nuint32_t read_stag, uint64_t read_va,\r\nuint32_t write_stag, uint64_t write_va)\r\n{\r\nstruct iscsi_hdr *hdr = &rx_desc->iscsi_header;\r\nstruct iscsi_conn *conn = isert_conn->conn;\r\nstruct iscsi_cmd *cmd;\r\nstruct isert_cmd *isert_cmd;\r\nint ret = -EINVAL;\r\nu8 opcode = (hdr->opcode & ISCSI_OPCODE_MASK);\r\nif (conn->sess->sess_ops->SessionType &&\r\n(!(opcode & ISCSI_OP_TEXT) || !(opcode & ISCSI_OP_LOGOUT))) {\r\nisert_err("Got illegal opcode: 0x%02x in SessionType=Discovery,"\r\n" ignoring\n", opcode);\r\nreturn 0;\r\n}\r\nswitch (opcode) {\r\ncase ISCSI_OP_SCSI_CMD:\r\ncmd = isert_allocate_cmd(conn, rx_desc);\r\nif (!cmd)\r\nbreak;\r\nisert_cmd = iscsit_priv_cmd(cmd);\r\nisert_cmd->read_stag = read_stag;\r\nisert_cmd->read_va = read_va;\r\nisert_cmd->write_stag = write_stag;\r\nisert_cmd->write_va = write_va;\r\nisert_cmd->inv_rkey = read_stag ? read_stag : write_stag;\r\nret = isert_handle_scsi_cmd(isert_conn, isert_cmd, cmd,\r\nrx_desc, (unsigned char *)hdr);\r\nbreak;\r\ncase ISCSI_OP_NOOP_OUT:\r\ncmd = isert_allocate_cmd(conn, rx_desc);\r\nif (!cmd)\r\nbreak;\r\nisert_cmd = iscsit_priv_cmd(cmd);\r\nret = isert_handle_nop_out(isert_conn, isert_cmd, cmd,\r\nrx_desc, (unsigned char *)hdr);\r\nbreak;\r\ncase ISCSI_OP_SCSI_DATA_OUT:\r\nret = isert_handle_iscsi_dataout(isert_conn, rx_desc,\r\n(unsigned char *)hdr);\r\nbreak;\r\ncase ISCSI_OP_SCSI_TMFUNC:\r\ncmd = isert_allocate_cmd(conn, rx_desc);\r\nif (!cmd)\r\nbreak;\r\nret = iscsit_handle_task_mgt_cmd(conn, cmd,\r\n(unsigned char *)hdr);\r\nbreak;\r\ncase ISCSI_OP_LOGOUT:\r\ncmd = isert_allocate_cmd(conn, rx_desc);\r\nif (!cmd)\r\nbreak;\r\nret = iscsit_handle_logout_cmd(conn, cmd, (unsigned char *)hdr);\r\nbreak;\r\ncase ISCSI_OP_TEXT:\r\nif (be32_to_cpu(hdr->ttt) != 0xFFFFFFFF)\r\ncmd = iscsit_find_cmd_from_itt(conn, hdr->itt);\r\nelse\r\ncmd = isert_allocate_cmd(conn, rx_desc);\r\nif (!cmd)\r\nbreak;\r\nisert_cmd = iscsit_priv_cmd(cmd);\r\nret = isert_handle_text_cmd(isert_conn, isert_cmd, cmd,\r\nrx_desc, (struct iscsi_text *)hdr);\r\nbreak;\r\ndefault:\r\nisert_err("Got unknown iSCSI OpCode: 0x%02x\n", opcode);\r\ndump_stack();\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nisert_print_wc(struct ib_wc *wc, const char *type)\r\n{\r\nif (wc->status != IB_WC_WR_FLUSH_ERR)\r\nisert_err("%s failure: %s (%d) vend_err %x\n", type,\r\nib_wc_status_msg(wc->status), wc->status,\r\nwc->vendor_err);\r\nelse\r\nisert_dbg("%s failure: %s (%d)\n", type,\r\nib_wc_status_msg(wc->status), wc->status);\r\n}\r\nstatic void\r\nisert_recv_done(struct ib_cq *cq, struct ib_wc *wc)\r\n{\r\nstruct isert_conn *isert_conn = wc->qp->qp_context;\r\nstruct ib_device *ib_dev = isert_conn->cm_id->device;\r\nstruct iser_rx_desc *rx_desc = cqe_to_rx_desc(wc->wr_cqe);\r\nstruct iscsi_hdr *hdr = &rx_desc->iscsi_header;\r\nstruct iser_ctrl *iser_ctrl = &rx_desc->iser_header;\r\nuint64_t read_va = 0, write_va = 0;\r\nuint32_t read_stag = 0, write_stag = 0;\r\nif (unlikely(wc->status != IB_WC_SUCCESS)) {\r\nisert_print_wc(wc, "recv");\r\nif (wc->status != IB_WC_WR_FLUSH_ERR)\r\niscsit_cause_connection_reinstatement(isert_conn->conn, 0);\r\nreturn;\r\n}\r\nrx_desc->in_use = true;\r\nib_dma_sync_single_for_cpu(ib_dev, rx_desc->dma_addr,\r\nISER_RX_PAYLOAD_SIZE, DMA_FROM_DEVICE);\r\nisert_dbg("DMA: 0x%llx, iSCSI opcode: 0x%02x, ITT: 0x%08x, flags: 0x%02x dlen: %d\n",\r\nrx_desc->dma_addr, hdr->opcode, hdr->itt, hdr->flags,\r\n(int)(wc->byte_len - ISER_HEADERS_LEN));\r\nswitch (iser_ctrl->flags & 0xF0) {\r\ncase ISCSI_CTRL:\r\nif (iser_ctrl->flags & ISER_RSV) {\r\nread_stag = be32_to_cpu(iser_ctrl->read_stag);\r\nread_va = be64_to_cpu(iser_ctrl->read_va);\r\nisert_dbg("ISER_RSV: read_stag: 0x%x read_va: 0x%llx\n",\r\nread_stag, (unsigned long long)read_va);\r\n}\r\nif (iser_ctrl->flags & ISER_WSV) {\r\nwrite_stag = be32_to_cpu(iser_ctrl->write_stag);\r\nwrite_va = be64_to_cpu(iser_ctrl->write_va);\r\nisert_dbg("ISER_WSV: write_stag: 0x%x write_va: 0x%llx\n",\r\nwrite_stag, (unsigned long long)write_va);\r\n}\r\nisert_dbg("ISER ISCSI_CTRL PDU\n");\r\nbreak;\r\ncase ISER_HELLO:\r\nisert_err("iSER Hello message\n");\r\nbreak;\r\ndefault:\r\nisert_warn("Unknown iSER hdr flags: 0x%02x\n", iser_ctrl->flags);\r\nbreak;\r\n}\r\nisert_rx_opcode(isert_conn, rx_desc,\r\nread_stag, read_va, write_stag, write_va);\r\nib_dma_sync_single_for_device(ib_dev, rx_desc->dma_addr,\r\nISER_RX_PAYLOAD_SIZE, DMA_FROM_DEVICE);\r\n}\r\nstatic void\r\nisert_login_recv_done(struct ib_cq *cq, struct ib_wc *wc)\r\n{\r\nstruct isert_conn *isert_conn = wc->qp->qp_context;\r\nstruct ib_device *ib_dev = isert_conn->cm_id->device;\r\nif (unlikely(wc->status != IB_WC_SUCCESS)) {\r\nisert_print_wc(wc, "login recv");\r\nreturn;\r\n}\r\nib_dma_sync_single_for_cpu(ib_dev, isert_conn->login_req_dma,\r\nISER_RX_PAYLOAD_SIZE, DMA_FROM_DEVICE);\r\nisert_conn->login_req_len = wc->byte_len - ISER_HEADERS_LEN;\r\nif (isert_conn->conn) {\r\nstruct iscsi_login *login = isert_conn->conn->conn_login;\r\nif (login && !login->first_request)\r\nisert_rx_login_req(isert_conn);\r\n}\r\nmutex_lock(&isert_conn->mutex);\r\ncomplete(&isert_conn->login_req_comp);\r\nmutex_unlock(&isert_conn->mutex);\r\nib_dma_sync_single_for_device(ib_dev, isert_conn->login_req_dma,\r\nISER_RX_PAYLOAD_SIZE, DMA_FROM_DEVICE);\r\n}\r\nstatic void\r\nisert_rdma_rw_ctx_destroy(struct isert_cmd *cmd, struct isert_conn *conn)\r\n{\r\nstruct se_cmd *se_cmd = &cmd->iscsi_cmd->se_cmd;\r\nenum dma_data_direction dir = target_reverse_dma_direction(se_cmd);\r\nif (!cmd->rw.nr_ops)\r\nreturn;\r\nif (isert_prot_cmd(conn, se_cmd)) {\r\nrdma_rw_ctx_destroy_signature(&cmd->rw, conn->qp,\r\nconn->cm_id->port_num, se_cmd->t_data_sg,\r\nse_cmd->t_data_nents, se_cmd->t_prot_sg,\r\nse_cmd->t_prot_nents, dir);\r\n} else {\r\nrdma_rw_ctx_destroy(&cmd->rw, conn->qp, conn->cm_id->port_num,\r\nse_cmd->t_data_sg, se_cmd->t_data_nents, dir);\r\n}\r\ncmd->rw.nr_ops = 0;\r\n}\r\nstatic void\r\nisert_put_cmd(struct isert_cmd *isert_cmd, bool comp_err)\r\n{\r\nstruct iscsi_cmd *cmd = isert_cmd->iscsi_cmd;\r\nstruct isert_conn *isert_conn = isert_cmd->conn;\r\nstruct iscsi_conn *conn = isert_conn->conn;\r\nstruct iscsi_text_rsp *hdr;\r\nisert_dbg("Cmd %p\n", isert_cmd);\r\nswitch (cmd->iscsi_opcode) {\r\ncase ISCSI_OP_SCSI_CMD:\r\nspin_lock_bh(&conn->cmd_lock);\r\nif (!list_empty(&cmd->i_conn_node))\r\nlist_del_init(&cmd->i_conn_node);\r\nspin_unlock_bh(&conn->cmd_lock);\r\nif (cmd->data_direction == DMA_TO_DEVICE) {\r\niscsit_stop_dataout_timer(cmd);\r\nif (comp_err &&\r\ncmd->se_cmd.t_state == TRANSPORT_WRITE_PENDING) {\r\nstruct se_cmd *se_cmd = &cmd->se_cmd;\r\ntarget_put_sess_cmd(se_cmd);\r\n}\r\n}\r\nisert_rdma_rw_ctx_destroy(isert_cmd, isert_conn);\r\ntransport_generic_free_cmd(&cmd->se_cmd, 0);\r\nbreak;\r\ncase ISCSI_OP_SCSI_TMFUNC:\r\nspin_lock_bh(&conn->cmd_lock);\r\nif (!list_empty(&cmd->i_conn_node))\r\nlist_del_init(&cmd->i_conn_node);\r\nspin_unlock_bh(&conn->cmd_lock);\r\ntransport_generic_free_cmd(&cmd->se_cmd, 0);\r\nbreak;\r\ncase ISCSI_OP_REJECT:\r\ncase ISCSI_OP_NOOP_OUT:\r\ncase ISCSI_OP_TEXT:\r\nhdr = (struct iscsi_text_rsp *)&isert_cmd->tx_desc.iscsi_header;\r\nif (hdr->flags & ISCSI_FLAG_TEXT_CONTINUE)\r\nbreak;\r\nspin_lock_bh(&conn->cmd_lock);\r\nif (!list_empty(&cmd->i_conn_node))\r\nlist_del_init(&cmd->i_conn_node);\r\nspin_unlock_bh(&conn->cmd_lock);\r\nif (cmd->se_cmd.se_tfo != NULL) {\r\nisert_dbg("Calling transport_generic_free_cmd for 0x%02x\n",\r\ncmd->iscsi_opcode);\r\ntransport_generic_free_cmd(&cmd->se_cmd, 0);\r\nbreak;\r\n}\r\ndefault:\r\niscsit_release_cmd(cmd);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nisert_unmap_tx_desc(struct iser_tx_desc *tx_desc, struct ib_device *ib_dev)\r\n{\r\nif (tx_desc->dma_addr != 0) {\r\nisert_dbg("unmap single for tx_desc->dma_addr\n");\r\nib_dma_unmap_single(ib_dev, tx_desc->dma_addr,\r\nISER_HEADERS_LEN, DMA_TO_DEVICE);\r\ntx_desc->dma_addr = 0;\r\n}\r\n}\r\nstatic void\r\nisert_completion_put(struct iser_tx_desc *tx_desc, struct isert_cmd *isert_cmd,\r\nstruct ib_device *ib_dev, bool comp_err)\r\n{\r\nif (isert_cmd->pdu_buf_dma != 0) {\r\nisert_dbg("unmap single for isert_cmd->pdu_buf_dma\n");\r\nib_dma_unmap_single(ib_dev, isert_cmd->pdu_buf_dma,\r\nisert_cmd->pdu_buf_len, DMA_TO_DEVICE);\r\nisert_cmd->pdu_buf_dma = 0;\r\n}\r\nisert_unmap_tx_desc(tx_desc, ib_dev);\r\nisert_put_cmd(isert_cmd, comp_err);\r\n}\r\nstatic int\r\nisert_check_pi_status(struct se_cmd *se_cmd, struct ib_mr *sig_mr)\r\n{\r\nstruct ib_mr_status mr_status;\r\nint ret;\r\nret = ib_check_mr_status(sig_mr, IB_MR_CHECK_SIG_STATUS, &mr_status);\r\nif (ret) {\r\nisert_err("ib_check_mr_status failed, ret %d\n", ret);\r\ngoto fail_mr_status;\r\n}\r\nif (mr_status.fail_status & IB_MR_CHECK_SIG_STATUS) {\r\nu64 sec_offset_err;\r\nu32 block_size = se_cmd->se_dev->dev_attrib.block_size + 8;\r\nswitch (mr_status.sig_err.err_type) {\r\ncase IB_SIG_BAD_GUARD:\r\nse_cmd->pi_err = TCM_LOGICAL_BLOCK_GUARD_CHECK_FAILED;\r\nbreak;\r\ncase IB_SIG_BAD_REFTAG:\r\nse_cmd->pi_err = TCM_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED;\r\nbreak;\r\ncase IB_SIG_BAD_APPTAG:\r\nse_cmd->pi_err = TCM_LOGICAL_BLOCK_APP_TAG_CHECK_FAILED;\r\nbreak;\r\n}\r\nsec_offset_err = mr_status.sig_err.sig_err_offset;\r\ndo_div(sec_offset_err, block_size);\r\nse_cmd->bad_sector = sec_offset_err + se_cmd->t_task_lba;\r\nisert_err("PI error found type %d at sector 0x%llx "\r\n"expected 0x%x vs actual 0x%x\n",\r\nmr_status.sig_err.err_type,\r\n(unsigned long long)se_cmd->bad_sector,\r\nmr_status.sig_err.expected,\r\nmr_status.sig_err.actual);\r\nret = 1;\r\n}\r\nfail_mr_status:\r\nreturn ret;\r\n}\r\nstatic void\r\nisert_rdma_write_done(struct ib_cq *cq, struct ib_wc *wc)\r\n{\r\nstruct isert_conn *isert_conn = wc->qp->qp_context;\r\nstruct isert_device *device = isert_conn->device;\r\nstruct iser_tx_desc *desc = cqe_to_tx_desc(wc->wr_cqe);\r\nstruct isert_cmd *isert_cmd = tx_desc_to_cmd(desc);\r\nstruct se_cmd *cmd = &isert_cmd->iscsi_cmd->se_cmd;\r\nint ret = 0;\r\nif (unlikely(wc->status != IB_WC_SUCCESS)) {\r\nisert_print_wc(wc, "rdma write");\r\nif (wc->status != IB_WC_WR_FLUSH_ERR)\r\niscsit_cause_connection_reinstatement(isert_conn->conn, 0);\r\nisert_completion_put(desc, isert_cmd, device->ib_device, true);\r\nreturn;\r\n}\r\nisert_dbg("Cmd %p\n", isert_cmd);\r\nret = isert_check_pi_status(cmd, isert_cmd->rw.sig->sig_mr);\r\nisert_rdma_rw_ctx_destroy(isert_cmd, isert_conn);\r\nif (ret) {\r\nkref_get(&cmd->cmd_kref);\r\ntransport_generic_request_failure(cmd, cmd->pi_err);\r\n} else {\r\nret = isert_put_response(isert_conn->conn, isert_cmd->iscsi_cmd);\r\nif (ret)\r\npr_warn_ratelimited("isert_put_response() ret: %d\n", ret);\r\n}\r\n}\r\nstatic void\r\nisert_rdma_read_done(struct ib_cq *cq, struct ib_wc *wc)\r\n{\r\nstruct isert_conn *isert_conn = wc->qp->qp_context;\r\nstruct isert_device *device = isert_conn->device;\r\nstruct iser_tx_desc *desc = cqe_to_tx_desc(wc->wr_cqe);\r\nstruct isert_cmd *isert_cmd = tx_desc_to_cmd(desc);\r\nstruct iscsi_cmd *cmd = isert_cmd->iscsi_cmd;\r\nstruct se_cmd *se_cmd = &cmd->se_cmd;\r\nint ret = 0;\r\nif (unlikely(wc->status != IB_WC_SUCCESS)) {\r\nisert_print_wc(wc, "rdma read");\r\nif (wc->status != IB_WC_WR_FLUSH_ERR)\r\niscsit_cause_connection_reinstatement(isert_conn->conn, 0);\r\nisert_completion_put(desc, isert_cmd, device->ib_device, true);\r\nreturn;\r\n}\r\nisert_dbg("Cmd %p\n", isert_cmd);\r\niscsit_stop_dataout_timer(cmd);\r\nif (isert_prot_cmd(isert_conn, se_cmd))\r\nret = isert_check_pi_status(se_cmd, isert_cmd->rw.sig->sig_mr);\r\nisert_rdma_rw_ctx_destroy(isert_cmd, isert_conn);\r\ncmd->write_data_done = 0;\r\nisert_dbg("Cmd: %p RDMA_READ comp calling execute_cmd\n", isert_cmd);\r\nspin_lock_bh(&cmd->istate_lock);\r\ncmd->cmd_flags |= ICF_GOT_LAST_DATAOUT;\r\ncmd->i_state = ISTATE_RECEIVED_LAST_DATAOUT;\r\nspin_unlock_bh(&cmd->istate_lock);\r\nif (ret)\r\ntransport_generic_request_failure(se_cmd, se_cmd->pi_err);\r\nelse\r\ntarget_execute_cmd(se_cmd);\r\n}\r\nstatic void\r\nisert_do_control_comp(struct work_struct *work)\r\n{\r\nstruct isert_cmd *isert_cmd = container_of(work,\r\nstruct isert_cmd, comp_work);\r\nstruct isert_conn *isert_conn = isert_cmd->conn;\r\nstruct ib_device *ib_dev = isert_conn->cm_id->device;\r\nstruct iscsi_cmd *cmd = isert_cmd->iscsi_cmd;\r\nisert_dbg("Cmd %p i_state %d\n", isert_cmd, cmd->i_state);\r\nswitch (cmd->i_state) {\r\ncase ISTATE_SEND_TASKMGTRSP:\r\niscsit_tmr_post_handler(cmd, cmd->conn);\r\ncase ISTATE_SEND_REJECT:\r\ncase ISTATE_SEND_TEXTRSP:\r\ncmd->i_state = ISTATE_SENT_STATUS;\r\nisert_completion_put(&isert_cmd->tx_desc, isert_cmd,\r\nib_dev, false);\r\nbreak;\r\ncase ISTATE_SEND_LOGOUTRSP:\r\niscsit_logout_post_handler(cmd, cmd->conn);\r\nbreak;\r\ndefault:\r\nisert_err("Unknown i_state %d\n", cmd->i_state);\r\ndump_stack();\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nisert_login_send_done(struct ib_cq *cq, struct ib_wc *wc)\r\n{\r\nstruct isert_conn *isert_conn = wc->qp->qp_context;\r\nstruct ib_device *ib_dev = isert_conn->cm_id->device;\r\nstruct iser_tx_desc *tx_desc = cqe_to_tx_desc(wc->wr_cqe);\r\nif (unlikely(wc->status != IB_WC_SUCCESS)) {\r\nisert_print_wc(wc, "login send");\r\nif (wc->status != IB_WC_WR_FLUSH_ERR)\r\niscsit_cause_connection_reinstatement(isert_conn->conn, 0);\r\n}\r\nisert_unmap_tx_desc(tx_desc, ib_dev);\r\n}\r\nstatic void\r\nisert_send_done(struct ib_cq *cq, struct ib_wc *wc)\r\n{\r\nstruct isert_conn *isert_conn = wc->qp->qp_context;\r\nstruct ib_device *ib_dev = isert_conn->cm_id->device;\r\nstruct iser_tx_desc *tx_desc = cqe_to_tx_desc(wc->wr_cqe);\r\nstruct isert_cmd *isert_cmd = tx_desc_to_cmd(tx_desc);\r\nif (unlikely(wc->status != IB_WC_SUCCESS)) {\r\nisert_print_wc(wc, "send");\r\nif (wc->status != IB_WC_WR_FLUSH_ERR)\r\niscsit_cause_connection_reinstatement(isert_conn->conn, 0);\r\nisert_completion_put(tx_desc, isert_cmd, ib_dev, true);\r\nreturn;\r\n}\r\nisert_dbg("Cmd %p\n", isert_cmd);\r\nswitch (isert_cmd->iscsi_cmd->i_state) {\r\ncase ISTATE_SEND_TASKMGTRSP:\r\ncase ISTATE_SEND_LOGOUTRSP:\r\ncase ISTATE_SEND_REJECT:\r\ncase ISTATE_SEND_TEXTRSP:\r\nisert_unmap_tx_desc(tx_desc, ib_dev);\r\nINIT_WORK(&isert_cmd->comp_work, isert_do_control_comp);\r\nqueue_work(isert_comp_wq, &isert_cmd->comp_work);\r\nreturn;\r\ndefault:\r\nisert_cmd->iscsi_cmd->i_state = ISTATE_SENT_STATUS;\r\nisert_completion_put(tx_desc, isert_cmd, ib_dev, false);\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nisert_post_response(struct isert_conn *isert_conn, struct isert_cmd *isert_cmd)\r\n{\r\nstruct ib_send_wr *wr_failed;\r\nint ret;\r\nret = isert_post_recv(isert_conn, isert_cmd->rx_desc);\r\nif (ret) {\r\nisert_err("ib_post_recv failed with %d\n", ret);\r\nreturn ret;\r\n}\r\nret = ib_post_send(isert_conn->qp, &isert_cmd->tx_desc.send_wr,\r\n&wr_failed);\r\nif (ret) {\r\nisert_err("ib_post_send failed with %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nisert_put_response(struct iscsi_conn *conn, struct iscsi_cmd *cmd)\r\n{\r\nstruct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);\r\nstruct isert_conn *isert_conn = conn->context;\r\nstruct ib_send_wr *send_wr = &isert_cmd->tx_desc.send_wr;\r\nstruct iscsi_scsi_rsp *hdr = (struct iscsi_scsi_rsp *)\r\n&isert_cmd->tx_desc.iscsi_header;\r\nisert_create_send_desc(isert_conn, isert_cmd, &isert_cmd->tx_desc);\r\niscsit_build_rsp_pdu(cmd, conn, true, hdr);\r\nisert_init_tx_hdrs(isert_conn, &isert_cmd->tx_desc);\r\nif (cmd->se_cmd.sense_buffer &&\r\n((cmd->se_cmd.se_cmd_flags & SCF_TRANSPORT_TASK_SENSE) ||\r\n(cmd->se_cmd.se_cmd_flags & SCF_EMULATED_TASK_SENSE))) {\r\nstruct isert_device *device = isert_conn->device;\r\nstruct ib_device *ib_dev = device->ib_device;\r\nstruct ib_sge *tx_dsg = &isert_cmd->tx_desc.tx_sg[1];\r\nu32 padding, pdu_len;\r\nput_unaligned_be16(cmd->se_cmd.scsi_sense_length,\r\ncmd->sense_buffer);\r\ncmd->se_cmd.scsi_sense_length += sizeof(__be16);\r\npadding = -(cmd->se_cmd.scsi_sense_length) & 3;\r\nhton24(hdr->dlength, (u32)cmd->se_cmd.scsi_sense_length);\r\npdu_len = cmd->se_cmd.scsi_sense_length + padding;\r\nisert_cmd->pdu_buf_dma = ib_dma_map_single(ib_dev,\r\n(void *)cmd->sense_buffer, pdu_len,\r\nDMA_TO_DEVICE);\r\nif (ib_dma_mapping_error(ib_dev, isert_cmd->pdu_buf_dma))\r\nreturn -ENOMEM;\r\nisert_cmd->pdu_buf_len = pdu_len;\r\ntx_dsg->addr = isert_cmd->pdu_buf_dma;\r\ntx_dsg->length = pdu_len;\r\ntx_dsg->lkey = device->pd->local_dma_lkey;\r\nisert_cmd->tx_desc.num_sge = 2;\r\n}\r\nisert_init_send_wr(isert_conn, isert_cmd, send_wr);\r\nisert_dbg("Posting SCSI Response\n");\r\nreturn isert_post_response(isert_conn, isert_cmd);\r\n}\r\nstatic void\r\nisert_aborted_task(struct iscsi_conn *conn, struct iscsi_cmd *cmd)\r\n{\r\nstruct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);\r\nstruct isert_conn *isert_conn = conn->context;\r\nspin_lock_bh(&conn->cmd_lock);\r\nif (!list_empty(&cmd->i_conn_node))\r\nlist_del_init(&cmd->i_conn_node);\r\nspin_unlock_bh(&conn->cmd_lock);\r\nif (cmd->data_direction == DMA_TO_DEVICE)\r\niscsit_stop_dataout_timer(cmd);\r\nisert_rdma_rw_ctx_destroy(isert_cmd, isert_conn);\r\n}\r\nstatic enum target_prot_op\r\nisert_get_sup_prot_ops(struct iscsi_conn *conn)\r\n{\r\nstruct isert_conn *isert_conn = conn->context;\r\nstruct isert_device *device = isert_conn->device;\r\nif (conn->tpg->tpg_attrib.t10_pi) {\r\nif (device->pi_capable) {\r\nisert_info("conn %p PI offload enabled\n", isert_conn);\r\nisert_conn->pi_support = true;\r\nreturn TARGET_PROT_ALL;\r\n}\r\n}\r\nisert_info("conn %p PI offload disabled\n", isert_conn);\r\nisert_conn->pi_support = false;\r\nreturn TARGET_PROT_NORMAL;\r\n}\r\nstatic int\r\nisert_put_nopin(struct iscsi_cmd *cmd, struct iscsi_conn *conn,\r\nbool nopout_response)\r\n{\r\nstruct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);\r\nstruct isert_conn *isert_conn = conn->context;\r\nstruct ib_send_wr *send_wr = &isert_cmd->tx_desc.send_wr;\r\nisert_create_send_desc(isert_conn, isert_cmd, &isert_cmd->tx_desc);\r\niscsit_build_nopin_rsp(cmd, conn, (struct iscsi_nopin *)\r\n&isert_cmd->tx_desc.iscsi_header,\r\nnopout_response);\r\nisert_init_tx_hdrs(isert_conn, &isert_cmd->tx_desc);\r\nisert_init_send_wr(isert_conn, isert_cmd, send_wr);\r\nisert_dbg("conn %p Posting NOPIN Response\n", isert_conn);\r\nreturn isert_post_response(isert_conn, isert_cmd);\r\n}\r\nstatic int\r\nisert_put_logout_rsp(struct iscsi_cmd *cmd, struct iscsi_conn *conn)\r\n{\r\nstruct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);\r\nstruct isert_conn *isert_conn = conn->context;\r\nstruct ib_send_wr *send_wr = &isert_cmd->tx_desc.send_wr;\r\nisert_create_send_desc(isert_conn, isert_cmd, &isert_cmd->tx_desc);\r\niscsit_build_logout_rsp(cmd, conn, (struct iscsi_logout_rsp *)\r\n&isert_cmd->tx_desc.iscsi_header);\r\nisert_init_tx_hdrs(isert_conn, &isert_cmd->tx_desc);\r\nisert_init_send_wr(isert_conn, isert_cmd, send_wr);\r\nisert_dbg("conn %p Posting Logout Response\n", isert_conn);\r\nreturn isert_post_response(isert_conn, isert_cmd);\r\n}\r\nstatic int\r\nisert_put_tm_rsp(struct iscsi_cmd *cmd, struct iscsi_conn *conn)\r\n{\r\nstruct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);\r\nstruct isert_conn *isert_conn = conn->context;\r\nstruct ib_send_wr *send_wr = &isert_cmd->tx_desc.send_wr;\r\nisert_create_send_desc(isert_conn, isert_cmd, &isert_cmd->tx_desc);\r\niscsit_build_task_mgt_rsp(cmd, conn, (struct iscsi_tm_rsp *)\r\n&isert_cmd->tx_desc.iscsi_header);\r\nisert_init_tx_hdrs(isert_conn, &isert_cmd->tx_desc);\r\nisert_init_send_wr(isert_conn, isert_cmd, send_wr);\r\nisert_dbg("conn %p Posting Task Management Response\n", isert_conn);\r\nreturn isert_post_response(isert_conn, isert_cmd);\r\n}\r\nstatic int\r\nisert_put_reject(struct iscsi_cmd *cmd, struct iscsi_conn *conn)\r\n{\r\nstruct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);\r\nstruct isert_conn *isert_conn = conn->context;\r\nstruct ib_send_wr *send_wr = &isert_cmd->tx_desc.send_wr;\r\nstruct isert_device *device = isert_conn->device;\r\nstruct ib_device *ib_dev = device->ib_device;\r\nstruct ib_sge *tx_dsg = &isert_cmd->tx_desc.tx_sg[1];\r\nstruct iscsi_reject *hdr =\r\n(struct iscsi_reject *)&isert_cmd->tx_desc.iscsi_header;\r\nisert_create_send_desc(isert_conn, isert_cmd, &isert_cmd->tx_desc);\r\niscsit_build_reject(cmd, conn, hdr);\r\nisert_init_tx_hdrs(isert_conn, &isert_cmd->tx_desc);\r\nhton24(hdr->dlength, ISCSI_HDR_LEN);\r\nisert_cmd->pdu_buf_dma = ib_dma_map_single(ib_dev,\r\n(void *)cmd->buf_ptr, ISCSI_HDR_LEN,\r\nDMA_TO_DEVICE);\r\nif (ib_dma_mapping_error(ib_dev, isert_cmd->pdu_buf_dma))\r\nreturn -ENOMEM;\r\nisert_cmd->pdu_buf_len = ISCSI_HDR_LEN;\r\ntx_dsg->addr = isert_cmd->pdu_buf_dma;\r\ntx_dsg->length = ISCSI_HDR_LEN;\r\ntx_dsg->lkey = device->pd->local_dma_lkey;\r\nisert_cmd->tx_desc.num_sge = 2;\r\nisert_init_send_wr(isert_conn, isert_cmd, send_wr);\r\nisert_dbg("conn %p Posting Reject\n", isert_conn);\r\nreturn isert_post_response(isert_conn, isert_cmd);\r\n}\r\nstatic int\r\nisert_put_text_rsp(struct iscsi_cmd *cmd, struct iscsi_conn *conn)\r\n{\r\nstruct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);\r\nstruct isert_conn *isert_conn = conn->context;\r\nstruct ib_send_wr *send_wr = &isert_cmd->tx_desc.send_wr;\r\nstruct iscsi_text_rsp *hdr =\r\n(struct iscsi_text_rsp *)&isert_cmd->tx_desc.iscsi_header;\r\nu32 txt_rsp_len;\r\nint rc;\r\nisert_create_send_desc(isert_conn, isert_cmd, &isert_cmd->tx_desc);\r\nrc = iscsit_build_text_rsp(cmd, conn, hdr, ISCSI_INFINIBAND);\r\nif (rc < 0)\r\nreturn rc;\r\ntxt_rsp_len = rc;\r\nisert_init_tx_hdrs(isert_conn, &isert_cmd->tx_desc);\r\nif (txt_rsp_len) {\r\nstruct isert_device *device = isert_conn->device;\r\nstruct ib_device *ib_dev = device->ib_device;\r\nstruct ib_sge *tx_dsg = &isert_cmd->tx_desc.tx_sg[1];\r\nvoid *txt_rsp_buf = cmd->buf_ptr;\r\nisert_cmd->pdu_buf_dma = ib_dma_map_single(ib_dev,\r\ntxt_rsp_buf, txt_rsp_len, DMA_TO_DEVICE);\r\nif (ib_dma_mapping_error(ib_dev, isert_cmd->pdu_buf_dma))\r\nreturn -ENOMEM;\r\nisert_cmd->pdu_buf_len = txt_rsp_len;\r\ntx_dsg->addr = isert_cmd->pdu_buf_dma;\r\ntx_dsg->length = txt_rsp_len;\r\ntx_dsg->lkey = device->pd->local_dma_lkey;\r\nisert_cmd->tx_desc.num_sge = 2;\r\n}\r\nisert_init_send_wr(isert_conn, isert_cmd, send_wr);\r\nisert_dbg("conn %p Text Response\n", isert_conn);\r\nreturn isert_post_response(isert_conn, isert_cmd);\r\n}\r\nstatic inline void\r\nisert_set_dif_domain(struct se_cmd *se_cmd, struct ib_sig_attrs *sig_attrs,\r\nstruct ib_sig_domain *domain)\r\n{\r\ndomain->sig_type = IB_SIG_TYPE_T10_DIF;\r\ndomain->sig.dif.bg_type = IB_T10DIF_CRC;\r\ndomain->sig.dif.pi_interval = se_cmd->se_dev->dev_attrib.block_size;\r\ndomain->sig.dif.ref_tag = se_cmd->reftag_seed;\r\ndomain->sig.dif.apptag_check_mask = 0xffff;\r\ndomain->sig.dif.app_escape = true;\r\ndomain->sig.dif.ref_escape = true;\r\nif (se_cmd->prot_type == TARGET_DIF_TYPE1_PROT ||\r\nse_cmd->prot_type == TARGET_DIF_TYPE2_PROT)\r\ndomain->sig.dif.ref_remap = true;\r\n}\r\nstatic int\r\nisert_set_sig_attrs(struct se_cmd *se_cmd, struct ib_sig_attrs *sig_attrs)\r\n{\r\nmemset(sig_attrs, 0, sizeof(*sig_attrs));\r\nswitch (se_cmd->prot_op) {\r\ncase TARGET_PROT_DIN_INSERT:\r\ncase TARGET_PROT_DOUT_STRIP:\r\nsig_attrs->mem.sig_type = IB_SIG_TYPE_NONE;\r\nisert_set_dif_domain(se_cmd, sig_attrs, &sig_attrs->wire);\r\nbreak;\r\ncase TARGET_PROT_DOUT_INSERT:\r\ncase TARGET_PROT_DIN_STRIP:\r\nsig_attrs->wire.sig_type = IB_SIG_TYPE_NONE;\r\nisert_set_dif_domain(se_cmd, sig_attrs, &sig_attrs->mem);\r\nbreak;\r\ncase TARGET_PROT_DIN_PASS:\r\ncase TARGET_PROT_DOUT_PASS:\r\nisert_set_dif_domain(se_cmd, sig_attrs, &sig_attrs->wire);\r\nisert_set_dif_domain(se_cmd, sig_attrs, &sig_attrs->mem);\r\nbreak;\r\ndefault:\r\nisert_err("Unsupported PI operation %d\n", se_cmd->prot_op);\r\nreturn -EINVAL;\r\n}\r\nsig_attrs->check_mask =\r\n(se_cmd->prot_checks & TARGET_DIF_CHECK_GUARD ? 0xc0 : 0) |\r\n(se_cmd->prot_checks & TARGET_DIF_CHECK_REFTAG ? 0x30 : 0) |\r\n(se_cmd->prot_checks & TARGET_DIF_CHECK_REFTAG ? 0x0f : 0);\r\nreturn 0;\r\n}\r\nstatic int\r\nisert_rdma_rw_ctx_post(struct isert_cmd *cmd, struct isert_conn *conn,\r\nstruct ib_cqe *cqe, struct ib_send_wr *chain_wr)\r\n{\r\nstruct se_cmd *se_cmd = &cmd->iscsi_cmd->se_cmd;\r\nenum dma_data_direction dir = target_reverse_dma_direction(se_cmd);\r\nu8 port_num = conn->cm_id->port_num;\r\nu64 addr;\r\nu32 rkey, offset;\r\nint ret;\r\nif (dir == DMA_FROM_DEVICE) {\r\naddr = cmd->write_va;\r\nrkey = cmd->write_stag;\r\noffset = cmd->iscsi_cmd->write_data_done;\r\n} else {\r\naddr = cmd->read_va;\r\nrkey = cmd->read_stag;\r\noffset = 0;\r\n}\r\nif (isert_prot_cmd(conn, se_cmd)) {\r\nstruct ib_sig_attrs sig_attrs;\r\nret = isert_set_sig_attrs(se_cmd, &sig_attrs);\r\nif (ret)\r\nreturn ret;\r\nWARN_ON_ONCE(offset);\r\nret = rdma_rw_ctx_signature_init(&cmd->rw, conn->qp, port_num,\r\nse_cmd->t_data_sg, se_cmd->t_data_nents,\r\nse_cmd->t_prot_sg, se_cmd->t_prot_nents,\r\n&sig_attrs, addr, rkey, dir);\r\n} else {\r\nret = rdma_rw_ctx_init(&cmd->rw, conn->qp, port_num,\r\nse_cmd->t_data_sg, se_cmd->t_data_nents,\r\noffset, addr, rkey, dir);\r\n}\r\nif (ret < 0) {\r\nisert_err("Cmd: %p failed to prepare RDMA res\n", cmd);\r\nreturn ret;\r\n}\r\nret = rdma_rw_ctx_post(&cmd->rw, conn->qp, port_num, cqe, chain_wr);\r\nif (ret < 0)\r\nisert_err("Cmd: %p failed to post RDMA res\n", cmd);\r\nreturn ret;\r\n}\r\nstatic int\r\nisert_put_datain(struct iscsi_conn *conn, struct iscsi_cmd *cmd)\r\n{\r\nstruct se_cmd *se_cmd = &cmd->se_cmd;\r\nstruct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);\r\nstruct isert_conn *isert_conn = conn->context;\r\nstruct ib_cqe *cqe = NULL;\r\nstruct ib_send_wr *chain_wr = NULL;\r\nint rc;\r\nisert_dbg("Cmd: %p RDMA_WRITE data_length: %u\n",\r\nisert_cmd, se_cmd->data_length);\r\nif (isert_prot_cmd(isert_conn, se_cmd)) {\r\nisert_cmd->tx_desc.tx_cqe.done = isert_rdma_write_done;\r\ncqe = &isert_cmd->tx_desc.tx_cqe;\r\n} else {\r\nisert_create_send_desc(isert_conn, isert_cmd,\r\n&isert_cmd->tx_desc);\r\niscsit_build_rsp_pdu(cmd, conn, true, (struct iscsi_scsi_rsp *)\r\n&isert_cmd->tx_desc.iscsi_header);\r\nisert_init_tx_hdrs(isert_conn, &isert_cmd->tx_desc);\r\nisert_init_send_wr(isert_conn, isert_cmd,\r\n&isert_cmd->tx_desc.send_wr);\r\nrc = isert_post_recv(isert_conn, isert_cmd->rx_desc);\r\nif (rc) {\r\nisert_err("ib_post_recv failed with %d\n", rc);\r\nreturn rc;\r\n}\r\nchain_wr = &isert_cmd->tx_desc.send_wr;\r\n}\r\nrc = isert_rdma_rw_ctx_post(isert_cmd, isert_conn, cqe, chain_wr);\r\nisert_dbg("Cmd: %p posted RDMA_WRITE for iSER Data READ rc: %d\n",\r\nisert_cmd, rc);\r\nreturn rc;\r\n}\r\nstatic int\r\nisert_get_dataout(struct iscsi_conn *conn, struct iscsi_cmd *cmd, bool recovery)\r\n{\r\nstruct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);\r\nint ret;\r\nisert_dbg("Cmd: %p RDMA_READ data_length: %u write_data_done: %u\n",\r\nisert_cmd, cmd->se_cmd.data_length, cmd->write_data_done);\r\nisert_cmd->tx_desc.tx_cqe.done = isert_rdma_read_done;\r\nret = isert_rdma_rw_ctx_post(isert_cmd, conn->context,\r\n&isert_cmd->tx_desc.tx_cqe, NULL);\r\nisert_dbg("Cmd: %p posted RDMA_READ memory for ISER Data WRITE rc: %d\n",\r\nisert_cmd, ret);\r\nreturn ret;\r\n}\r\nstatic int\r\nisert_immediate_queue(struct iscsi_conn *conn, struct iscsi_cmd *cmd, int state)\r\n{\r\nstruct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);\r\nint ret = 0;\r\nswitch (state) {\r\ncase ISTATE_REMOVE:\r\nspin_lock_bh(&conn->cmd_lock);\r\nlist_del_init(&cmd->i_conn_node);\r\nspin_unlock_bh(&conn->cmd_lock);\r\nisert_put_cmd(isert_cmd, true);\r\nbreak;\r\ncase ISTATE_SEND_NOPIN_WANT_RESPONSE:\r\nret = isert_put_nopin(cmd, conn, false);\r\nbreak;\r\ndefault:\r\nisert_err("Unknown immediate state: 0x%02x\n", state);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nisert_response_queue(struct iscsi_conn *conn, struct iscsi_cmd *cmd, int state)\r\n{\r\nstruct isert_conn *isert_conn = conn->context;\r\nint ret;\r\nswitch (state) {\r\ncase ISTATE_SEND_LOGOUTRSP:\r\nret = isert_put_logout_rsp(cmd, conn);\r\nif (!ret)\r\nisert_conn->logout_posted = true;\r\nbreak;\r\ncase ISTATE_SEND_NOPIN:\r\nret = isert_put_nopin(cmd, conn, true);\r\nbreak;\r\ncase ISTATE_SEND_TASKMGTRSP:\r\nret = isert_put_tm_rsp(cmd, conn);\r\nbreak;\r\ncase ISTATE_SEND_REJECT:\r\nret = isert_put_reject(cmd, conn);\r\nbreak;\r\ncase ISTATE_SEND_TEXTRSP:\r\nret = isert_put_text_rsp(cmd, conn);\r\nbreak;\r\ncase ISTATE_SEND_STATUS:\r\nret = isert_put_response(conn, cmd);\r\nbreak;\r\ndefault:\r\nisert_err("Unknown response state: 0x%02x\n", state);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstruct rdma_cm_id *\r\nisert_setup_id(struct isert_np *isert_np)\r\n{\r\nstruct iscsi_np *np = isert_np->np;\r\nstruct rdma_cm_id *id;\r\nstruct sockaddr *sa;\r\nint ret;\r\nsa = (struct sockaddr *)&np->np_sockaddr;\r\nisert_dbg("ksockaddr: %p, sa: %p\n", &np->np_sockaddr, sa);\r\nid = rdma_create_id(&init_net, isert_cma_handler, isert_np,\r\nRDMA_PS_TCP, IB_QPT_RC);\r\nif (IS_ERR(id)) {\r\nisert_err("rdma_create_id() failed: %ld\n", PTR_ERR(id));\r\nret = PTR_ERR(id);\r\ngoto out;\r\n}\r\nisert_dbg("id %p context %p\n", id, id->context);\r\nret = rdma_bind_addr(id, sa);\r\nif (ret) {\r\nisert_err("rdma_bind_addr() failed: %d\n", ret);\r\ngoto out_id;\r\n}\r\nret = rdma_listen(id, 0);\r\nif (ret) {\r\nisert_err("rdma_listen() failed: %d\n", ret);\r\ngoto out_id;\r\n}\r\nreturn id;\r\nout_id:\r\nrdma_destroy_id(id);\r\nout:\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic int\r\nisert_setup_np(struct iscsi_np *np,\r\nstruct sockaddr_storage *ksockaddr)\r\n{\r\nstruct isert_np *isert_np;\r\nstruct rdma_cm_id *isert_lid;\r\nint ret;\r\nisert_np = kzalloc(sizeof(struct isert_np), GFP_KERNEL);\r\nif (!isert_np)\r\nreturn -ENOMEM;\r\nsema_init(&isert_np->sem, 0);\r\nmutex_init(&isert_np->mutex);\r\nINIT_LIST_HEAD(&isert_np->accepted);\r\nINIT_LIST_HEAD(&isert_np->pending);\r\nisert_np->np = np;\r\nmemcpy(&np->np_sockaddr, ksockaddr,\r\nsizeof(struct sockaddr_storage));\r\nisert_lid = isert_setup_id(isert_np);\r\nif (IS_ERR(isert_lid)) {\r\nret = PTR_ERR(isert_lid);\r\ngoto out;\r\n}\r\nisert_np->cm_id = isert_lid;\r\nnp->np_context = isert_np;\r\nreturn 0;\r\nout:\r\nkfree(isert_np);\r\nreturn ret;\r\n}\r\nstatic int\r\nisert_rdma_accept(struct isert_conn *isert_conn)\r\n{\r\nstruct rdma_cm_id *cm_id = isert_conn->cm_id;\r\nstruct rdma_conn_param cp;\r\nint ret;\r\nstruct iser_cm_hdr rsp_hdr;\r\nmemset(&cp, 0, sizeof(struct rdma_conn_param));\r\ncp.initiator_depth = isert_conn->initiator_depth;\r\ncp.retry_count = 7;\r\ncp.rnr_retry_count = 7;\r\nmemset(&rsp_hdr, 0, sizeof(rsp_hdr));\r\nrsp_hdr.flags = ISERT_ZBVA_NOT_USED;\r\nif (!isert_conn->snd_w_inv)\r\nrsp_hdr.flags = rsp_hdr.flags | ISERT_SEND_W_INV_NOT_USED;\r\ncp.private_data = (void *)&rsp_hdr;\r\ncp.private_data_len = sizeof(rsp_hdr);\r\nret = rdma_accept(cm_id, &cp);\r\nif (ret) {\r\nisert_err("rdma_accept() failed with: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nisert_get_login_rx(struct iscsi_conn *conn, struct iscsi_login *login)\r\n{\r\nstruct isert_conn *isert_conn = conn->context;\r\nint ret;\r\nisert_info("before login_req comp conn: %p\n", isert_conn);\r\nret = wait_for_completion_interruptible(&isert_conn->login_req_comp);\r\nif (ret) {\r\nisert_err("isert_conn %p interrupted before got login req\n",\r\nisert_conn);\r\nreturn ret;\r\n}\r\nreinit_completion(&isert_conn->login_req_comp);\r\nif (!login->first_request)\r\nreturn 0;\r\nisert_rx_login_req(isert_conn);\r\nisert_info("before login_comp conn: %p\n", conn);\r\nret = wait_for_completion_interruptible(&isert_conn->login_comp);\r\nif (ret)\r\nreturn ret;\r\nisert_info("processing login->req: %p\n", login->req);\r\nreturn 0;\r\n}\r\nstatic void\r\nisert_set_conn_info(struct iscsi_np *np, struct iscsi_conn *conn,\r\nstruct isert_conn *isert_conn)\r\n{\r\nstruct rdma_cm_id *cm_id = isert_conn->cm_id;\r\nstruct rdma_route *cm_route = &cm_id->route;\r\nconn->login_family = np->np_sockaddr.ss_family;\r\nconn->login_sockaddr = cm_route->addr.dst_addr;\r\nconn->local_sockaddr = cm_route->addr.src_addr;\r\n}\r\nstatic int\r\nisert_accept_np(struct iscsi_np *np, struct iscsi_conn *conn)\r\n{\r\nstruct isert_np *isert_np = np->np_context;\r\nstruct isert_conn *isert_conn;\r\nint ret;\r\naccept_wait:\r\nret = down_interruptible(&isert_np->sem);\r\nif (ret)\r\nreturn -ENODEV;\r\nspin_lock_bh(&np->np_thread_lock);\r\nif (np->np_thread_state >= ISCSI_NP_THREAD_RESET) {\r\nspin_unlock_bh(&np->np_thread_lock);\r\nisert_dbg("np_thread_state %d\n",\r\nnp->np_thread_state);\r\nreturn -ENODEV;\r\n}\r\nspin_unlock_bh(&np->np_thread_lock);\r\nmutex_lock(&isert_np->mutex);\r\nif (list_empty(&isert_np->pending)) {\r\nmutex_unlock(&isert_np->mutex);\r\ngoto accept_wait;\r\n}\r\nisert_conn = list_first_entry(&isert_np->pending,\r\nstruct isert_conn, node);\r\nlist_del_init(&isert_conn->node);\r\nmutex_unlock(&isert_np->mutex);\r\nconn->context = isert_conn;\r\nisert_conn->conn = conn;\r\nisert_conn->state = ISER_CONN_BOUND;\r\nisert_set_conn_info(np, conn, isert_conn);\r\nisert_dbg("Processing isert_conn: %p\n", isert_conn);\r\nreturn 0;\r\n}\r\nstatic void\r\nisert_free_np(struct iscsi_np *np)\r\n{\r\nstruct isert_np *isert_np = np->np_context;\r\nstruct isert_conn *isert_conn, *n;\r\nif (isert_np->cm_id)\r\nrdma_destroy_id(isert_np->cm_id);\r\nmutex_lock(&isert_np->mutex);\r\nif (!list_empty(&isert_np->pending)) {\r\nisert_info("Still have isert pending connections\n");\r\nlist_for_each_entry_safe(isert_conn, n,\r\n&isert_np->pending,\r\nnode) {\r\nisert_info("cleaning isert_conn %p state (%d)\n",\r\nisert_conn, isert_conn->state);\r\nisert_connect_release(isert_conn);\r\n}\r\n}\r\nif (!list_empty(&isert_np->accepted)) {\r\nisert_info("Still have isert accepted connections\n");\r\nlist_for_each_entry_safe(isert_conn, n,\r\n&isert_np->accepted,\r\nnode) {\r\nisert_info("cleaning isert_conn %p state (%d)\n",\r\nisert_conn, isert_conn->state);\r\nisert_connect_release(isert_conn);\r\n}\r\n}\r\nmutex_unlock(&isert_np->mutex);\r\nnp->np_context = NULL;\r\nkfree(isert_np);\r\n}\r\nstatic void isert_release_work(struct work_struct *work)\r\n{\r\nstruct isert_conn *isert_conn = container_of(work,\r\nstruct isert_conn,\r\nrelease_work);\r\nisert_info("Starting release conn %p\n", isert_conn);\r\nmutex_lock(&isert_conn->mutex);\r\nisert_conn->state = ISER_CONN_DOWN;\r\nmutex_unlock(&isert_conn->mutex);\r\nisert_info("Destroying conn %p\n", isert_conn);\r\nisert_put_conn(isert_conn);\r\n}\r\nstatic void\r\nisert_wait4logout(struct isert_conn *isert_conn)\r\n{\r\nstruct iscsi_conn *conn = isert_conn->conn;\r\nisert_info("conn %p\n", isert_conn);\r\nif (isert_conn->logout_posted) {\r\nisert_info("conn %p wait for conn_logout_comp\n", isert_conn);\r\nwait_for_completion_timeout(&conn->conn_logout_comp,\r\nSECONDS_FOR_LOGOUT_COMP * HZ);\r\n}\r\n}\r\nstatic void\r\nisert_wait4cmds(struct iscsi_conn *conn)\r\n{\r\nisert_info("iscsi_conn %p\n", conn);\r\nif (conn->sess) {\r\ntarget_sess_cmd_list_set_waiting(conn->sess->se_sess);\r\ntarget_wait_for_sess_cmds(conn->sess->se_sess);\r\n}\r\n}\r\nstatic void\r\nisert_put_unsol_pending_cmds(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_cmd *cmd, *tmp;\r\nstatic LIST_HEAD(drop_cmd_list);\r\nspin_lock_bh(&conn->cmd_lock);\r\nlist_for_each_entry_safe(cmd, tmp, &conn->conn_cmd_list, i_conn_node) {\r\nif ((cmd->cmd_flags & ICF_NON_IMMEDIATE_UNSOLICITED_DATA) &&\r\n(cmd->write_data_done < conn->sess->sess_ops->FirstBurstLength) &&\r\n(cmd->write_data_done < cmd->se_cmd.data_length))\r\nlist_move_tail(&cmd->i_conn_node, &drop_cmd_list);\r\n}\r\nspin_unlock_bh(&conn->cmd_lock);\r\nlist_for_each_entry_safe(cmd, tmp, &drop_cmd_list, i_conn_node) {\r\nlist_del_init(&cmd->i_conn_node);\r\nif (cmd->i_state != ISTATE_REMOVE) {\r\nstruct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);\r\nisert_info("conn %p dropping cmd %p\n", conn, cmd);\r\nisert_put_cmd(isert_cmd, true);\r\n}\r\n}\r\n}\r\nstatic void isert_wait_conn(struct iscsi_conn *conn)\r\n{\r\nstruct isert_conn *isert_conn = conn->context;\r\nisert_info("Starting conn %p\n", isert_conn);\r\nmutex_lock(&isert_conn->mutex);\r\nisert_conn_terminate(isert_conn);\r\nmutex_unlock(&isert_conn->mutex);\r\nib_drain_qp(isert_conn->qp);\r\nisert_put_unsol_pending_cmds(conn);\r\nisert_wait4cmds(conn);\r\nisert_wait4logout(isert_conn);\r\nqueue_work(isert_release_wq, &isert_conn->release_work);\r\n}\r\nstatic void isert_free_conn(struct iscsi_conn *conn)\r\n{\r\nstruct isert_conn *isert_conn = conn->context;\r\nib_drain_qp(isert_conn->qp);\r\nisert_put_conn(isert_conn);\r\n}\r\nstatic void isert_get_rx_pdu(struct iscsi_conn *conn)\r\n{\r\nstruct completion comp;\r\ninit_completion(&comp);\r\nwait_for_completion_interruptible(&comp);\r\n}\r\nstatic int __init isert_init(void)\r\n{\r\nint ret;\r\nisert_comp_wq = alloc_workqueue("isert_comp_wq",\r\nWQ_UNBOUND | WQ_HIGHPRI, 0);\r\nif (!isert_comp_wq) {\r\nisert_err("Unable to allocate isert_comp_wq\n");\r\nreturn -ENOMEM;\r\n}\r\nisert_release_wq = alloc_workqueue("isert_release_wq", WQ_UNBOUND,\r\nWQ_UNBOUND_MAX_ACTIVE);\r\nif (!isert_release_wq) {\r\nisert_err("Unable to allocate isert_release_wq\n");\r\nret = -ENOMEM;\r\ngoto destroy_comp_wq;\r\n}\r\niscsit_register_transport(&iser_target_transport);\r\nisert_info("iSER_TARGET[0] - Loaded iser_target_transport\n");\r\nreturn 0;\r\ndestroy_comp_wq:\r\ndestroy_workqueue(isert_comp_wq);\r\nreturn ret;\r\n}\r\nstatic void __exit isert_exit(void)\r\n{\r\nflush_scheduled_work();\r\ndestroy_workqueue(isert_release_wq);\r\ndestroy_workqueue(isert_comp_wq);\r\niscsit_unregister_transport(&iser_target_transport);\r\nisert_info("iSER_TARGET[0] - Released iser_target_transport\n");\r\n}
