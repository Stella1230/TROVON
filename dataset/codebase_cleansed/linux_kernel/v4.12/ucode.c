static int iwl_set_Xtal_calib(struct iwl_priv *priv)\r\n{\r\nstruct iwl_calib_xtal_freq_cmd cmd;\r\n__le16 *xtal_calib = priv->nvm_data->xtal_calib;\r\niwl_set_calib_hdr(&cmd.hdr, IWL_PHY_CALIBRATE_CRYSTAL_FRQ_CMD);\r\ncmd.cap_pin1 = le16_to_cpu(xtal_calib[0]);\r\ncmd.cap_pin2 = le16_to_cpu(xtal_calib[1]);\r\nreturn iwl_calib_set(priv, (void *)&cmd, sizeof(cmd));\r\n}\r\nstatic int iwl_set_temperature_offset_calib(struct iwl_priv *priv)\r\n{\r\nstruct iwl_calib_temperature_offset_cmd cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\niwl_set_calib_hdr(&cmd.hdr, IWL_PHY_CALIBRATE_TEMP_OFFSET_CMD);\r\ncmd.radio_sensor_offset = priv->nvm_data->raw_temperature;\r\nif (!(cmd.radio_sensor_offset))\r\ncmd.radio_sensor_offset = DEFAULT_RADIO_SENSOR_OFFSET;\r\nIWL_DEBUG_CALIB(priv, "Radio sensor offset: %d\n",\r\nle16_to_cpu(cmd.radio_sensor_offset));\r\nreturn iwl_calib_set(priv, (void *)&cmd, sizeof(cmd));\r\n}\r\nstatic int iwl_set_temperature_offset_calib_v2(struct iwl_priv *priv)\r\n{\r\nstruct iwl_calib_temperature_offset_v2_cmd cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\niwl_set_calib_hdr(&cmd.hdr, IWL_PHY_CALIBRATE_TEMP_OFFSET_CMD);\r\ncmd.radio_sensor_offset_high = priv->nvm_data->kelvin_temperature;\r\ncmd.radio_sensor_offset_low = priv->nvm_data->raw_temperature;\r\nif (!cmd.radio_sensor_offset_low) {\r\nIWL_DEBUG_CALIB(priv, "no info in EEPROM, use default\n");\r\ncmd.radio_sensor_offset_low = DEFAULT_RADIO_SENSOR_OFFSET;\r\ncmd.radio_sensor_offset_high = DEFAULT_RADIO_SENSOR_OFFSET;\r\n}\r\ncmd.burntVoltageRef = priv->nvm_data->calib_voltage;\r\nIWL_DEBUG_CALIB(priv, "Radio sensor offset high: %d\n",\r\nle16_to_cpu(cmd.radio_sensor_offset_high));\r\nIWL_DEBUG_CALIB(priv, "Radio sensor offset low: %d\n",\r\nle16_to_cpu(cmd.radio_sensor_offset_low));\r\nIWL_DEBUG_CALIB(priv, "Voltage Ref: %d\n",\r\nle16_to_cpu(cmd.burntVoltageRef));\r\nreturn iwl_calib_set(priv, (void *)&cmd, sizeof(cmd));\r\n}\r\nstatic int iwl_send_calib_cfg(struct iwl_priv *priv)\r\n{\r\nstruct iwl_calib_cfg_cmd calib_cfg_cmd;\r\nstruct iwl_host_cmd cmd = {\r\n.id = CALIBRATION_CFG_CMD,\r\n.len = { sizeof(struct iwl_calib_cfg_cmd), },\r\n.data = { &calib_cfg_cmd, },\r\n};\r\nmemset(&calib_cfg_cmd, 0, sizeof(calib_cfg_cmd));\r\ncalib_cfg_cmd.ucd_calib_cfg.once.is_enable = IWL_CALIB_INIT_CFG_ALL;\r\ncalib_cfg_cmd.ucd_calib_cfg.once.start = IWL_CALIB_INIT_CFG_ALL;\r\ncalib_cfg_cmd.ucd_calib_cfg.once.send_res = IWL_CALIB_INIT_CFG_ALL;\r\ncalib_cfg_cmd.ucd_calib_cfg.flags =\r\nIWL_CALIB_CFG_FLAG_SEND_COMPLETE_NTFY_MSK;\r\nreturn iwl_dvm_send_cmd(priv, &cmd);\r\n}\r\nint iwl_init_alive_start(struct iwl_priv *priv)\r\n{\r\nint ret;\r\nif (priv->lib->bt_params &&\r\npriv->lib->bt_params->advanced_bt_coexist) {\r\nret = iwl_send_bt_env(priv, IWL_BT_COEX_ENV_OPEN,\r\nBT_COEX_PRIO_TBL_EVT_INIT_CALIB2);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = iwl_send_calib_cfg(priv);\r\nif (ret)\r\nreturn ret;\r\nif (priv->lib->need_temp_offset_calib) {\r\nif (priv->lib->temp_offset_v2)\r\nreturn iwl_set_temperature_offset_calib_v2(priv);\r\nelse\r\nreturn iwl_set_temperature_offset_calib(priv);\r\n}\r\nreturn 0;\r\n}\r\nstatic int iwl_send_wimax_coex(struct iwl_priv *priv)\r\n{\r\nstruct iwl_wimax_coex_cmd coex_cmd;\r\nmemset(&coex_cmd, 0, sizeof(coex_cmd));\r\nreturn iwl_dvm_send_cmd_pdu(priv,\r\nCOEX_PRIORITY_TABLE_CMD, 0,\r\nsizeof(coex_cmd), &coex_cmd);\r\n}\r\nvoid iwl_send_prio_tbl(struct iwl_priv *priv)\r\n{\r\nstruct iwl_bt_coex_prio_table_cmd prio_tbl_cmd;\r\nmemcpy(prio_tbl_cmd.prio_tbl, iwl_bt_prio_tbl,\r\nsizeof(iwl_bt_prio_tbl));\r\nif (iwl_dvm_send_cmd_pdu(priv,\r\nREPLY_BT_COEX_PRIO_TABLE, 0,\r\nsizeof(prio_tbl_cmd), &prio_tbl_cmd))\r\nIWL_ERR(priv, "failed to send BT prio tbl command\n");\r\n}\r\nint iwl_send_bt_env(struct iwl_priv *priv, u8 action, u8 type)\r\n{\r\nstruct iwl_bt_coex_prot_env_cmd env_cmd;\r\nint ret;\r\nenv_cmd.action = action;\r\nenv_cmd.type = type;\r\nret = iwl_dvm_send_cmd_pdu(priv,\r\nREPLY_BT_COEX_PROT_ENV, 0,\r\nsizeof(env_cmd), &env_cmd);\r\nif (ret)\r\nIWL_ERR(priv, "failed to send BT env command\n");\r\nreturn ret;\r\n}\r\nstatic int iwl_alive_notify(struct iwl_priv *priv)\r\n{\r\nconst u8 *queue_to_txf;\r\nu8 n_queues;\r\nint ret;\r\nint i;\r\niwl_trans_fw_alive(priv->trans, 0);\r\nif (priv->fw->ucode_capa.flags & IWL_UCODE_TLV_FLAGS_PAN &&\r\npriv->nvm_data->sku_cap_ipan_enable) {\r\nn_queues = ARRAY_SIZE(iwlagn_ipan_queue_to_tx_fifo);\r\nqueue_to_txf = iwlagn_ipan_queue_to_tx_fifo;\r\n} else {\r\nn_queues = ARRAY_SIZE(iwlagn_default_queue_to_tx_fifo);\r\nqueue_to_txf = iwlagn_default_queue_to_tx_fifo;\r\n}\r\nfor (i = 0; i < n_queues; i++)\r\nif (queue_to_txf[i] != IWL_TX_FIFO_UNUSED)\r\niwl_trans_ac_txq_enable(priv->trans, i,\r\nqueue_to_txf[i], 0);\r\npriv->passive_no_rx = false;\r\npriv->transport_queue_stop = 0;\r\nret = iwl_send_wimax_coex(priv);\r\nif (ret)\r\nreturn ret;\r\nif (!priv->lib->no_xtal_calib) {\r\nret = iwl_set_Xtal_calib(priv);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn iwl_send_calib_results(priv);\r\n}\r\nstatic bool iwl_alive_fn(struct iwl_notif_wait_data *notif_wait,\r\nstruct iwl_rx_packet *pkt, void *data)\r\n{\r\nstruct iwl_priv *priv =\r\ncontainer_of(notif_wait, struct iwl_priv, notif_wait);\r\nstruct iwl_alive_data *alive_data = data;\r\nstruct iwl_alive_resp *palive;\r\npalive = (void *)pkt->data;\r\nIWL_DEBUG_FW(priv, "Alive ucode status 0x%08X revision "\r\n"0x%01X 0x%01X\n",\r\npalive->is_valid, palive->ver_type,\r\npalive->ver_subtype);\r\npriv->device_pointers.error_event_table =\r\nle32_to_cpu(palive->error_event_table_ptr);\r\npriv->device_pointers.log_event_table =\r\nle32_to_cpu(palive->log_event_table_ptr);\r\nalive_data->subtype = palive->ver_subtype;\r\nalive_data->valid = palive->is_valid == UCODE_VALID_OK;\r\nreturn true;\r\n}\r\nint iwl_load_ucode_wait_alive(struct iwl_priv *priv,\r\nenum iwl_ucode_type ucode_type)\r\n{\r\nstruct iwl_notification_wait alive_wait;\r\nstruct iwl_alive_data alive_data;\r\nconst struct fw_img *fw;\r\nint ret;\r\nenum iwl_ucode_type old_type;\r\nstatic const u16 alive_cmd[] = { REPLY_ALIVE };\r\nfw = iwl_get_ucode_image(priv->fw, ucode_type);\r\nif (WARN_ON(!fw))\r\nreturn -EINVAL;\r\nold_type = priv->cur_ucode;\r\npriv->cur_ucode = ucode_type;\r\npriv->ucode_loaded = false;\r\niwl_init_notification_wait(&priv->notif_wait, &alive_wait,\r\nalive_cmd, ARRAY_SIZE(alive_cmd),\r\niwl_alive_fn, &alive_data);\r\nret = iwl_trans_start_fw(priv->trans, fw, false);\r\nif (ret) {\r\npriv->cur_ucode = old_type;\r\niwl_remove_notification(&priv->notif_wait, &alive_wait);\r\nreturn ret;\r\n}\r\nret = iwl_wait_notification(&priv->notif_wait, &alive_wait,\r\nUCODE_ALIVE_TIMEOUT);\r\nif (ret) {\r\npriv->cur_ucode = old_type;\r\nreturn ret;\r\n}\r\nif (!alive_data.valid) {\r\nIWL_ERR(priv, "Loaded ucode is not valid!\n");\r\npriv->cur_ucode = old_type;\r\nreturn -EIO;\r\n}\r\npriv->ucode_loaded = true;\r\nif (ucode_type != IWL_UCODE_WOWLAN) {\r\nmsleep(5);\r\n}\r\nret = iwl_alive_notify(priv);\r\nif (ret) {\r\nIWL_WARN(priv,\r\n"Could not complete ALIVE transition: %d\n", ret);\r\npriv->cur_ucode = old_type;\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool iwlagn_wait_calib(struct iwl_notif_wait_data *notif_wait,\r\nstruct iwl_rx_packet *pkt, void *data)\r\n{\r\nstruct iwl_priv *priv = data;\r\nstruct iwl_calib_hdr *hdr;\r\nif (pkt->hdr.cmd != CALIBRATION_RES_NOTIFICATION) {\r\nWARN_ON(pkt->hdr.cmd != CALIBRATION_COMPLETE_NOTIFICATION);\r\nreturn true;\r\n}\r\nhdr = (struct iwl_calib_hdr *)pkt->data;\r\nif (iwl_calib_set(priv, hdr, iwl_rx_packet_payload_len(pkt)))\r\nIWL_ERR(priv, "Failed to record calibration data %d\n",\r\nhdr->op_code);\r\nreturn false;\r\n}\r\nint iwl_run_init_ucode(struct iwl_priv *priv)\r\n{\r\nstruct iwl_notification_wait calib_wait;\r\nstatic const u16 calib_complete[] = {\r\nCALIBRATION_RES_NOTIFICATION,\r\nCALIBRATION_COMPLETE_NOTIFICATION\r\n};\r\nint ret;\r\nlockdep_assert_held(&priv->mutex);\r\nif (!priv->fw->img[IWL_UCODE_INIT].num_sec)\r\nreturn 0;\r\niwl_init_notification_wait(&priv->notif_wait, &calib_wait,\r\ncalib_complete, ARRAY_SIZE(calib_complete),\r\niwlagn_wait_calib, priv);\r\nret = iwl_load_ucode_wait_alive(priv, IWL_UCODE_INIT);\r\nif (ret)\r\ngoto error;\r\nret = iwl_init_alive_start(priv);\r\nif (ret)\r\ngoto error;\r\nret = iwl_wait_notification(&priv->notif_wait, &calib_wait,\r\nUCODE_CALIB_TIMEOUT);\r\ngoto out;\r\nerror:\r\niwl_remove_notification(&priv->notif_wait, &calib_wait);\r\nout:\r\niwl_trans_stop_device(priv->trans);\r\npriv->ucode_loaded = false;\r\nreturn ret;\r\n}
