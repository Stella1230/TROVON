static int meson_plane_atomic_check(struct drm_plane *plane,\r\nstruct drm_plane_state *state)\r\n{\r\nstruct drm_crtc_state *crtc_state;\r\nstruct drm_rect clip = { 0, };\r\nif (!state->crtc)\r\nreturn 0;\r\ncrtc_state = drm_atomic_get_crtc_state(state->state, state->crtc);\r\nif (IS_ERR(crtc_state))\r\nreturn PTR_ERR(crtc_state);\r\nclip.x2 = crtc_state->mode.hdisplay;\r\nclip.y2 = crtc_state->mode.vdisplay;\r\nreturn drm_plane_helper_check_state(state, &clip,\r\nDRM_PLANE_HELPER_NO_SCALING,\r\nDRM_PLANE_HELPER_NO_SCALING,\r\ntrue, true);\r\n}\r\nstatic inline int64_t fixed16_to_int(int64_t value)\r\n{\r\nreturn value >> 16;\r\n}\r\nstatic void meson_plane_atomic_update(struct drm_plane *plane,\r\nstruct drm_plane_state *old_state)\r\n{\r\nstruct meson_plane *meson_plane = to_meson_plane(plane);\r\nstruct drm_plane_state *state = plane->state;\r\nstruct drm_framebuffer *fb = state->fb;\r\nstruct meson_drm *priv = meson_plane->priv;\r\nstruct drm_gem_cma_object *gem;\r\nstruct drm_rect src = {\r\n.x1 = (state->src_x),\r\n.y1 = (state->src_y),\r\n.x2 = (state->src_x + state->src_w),\r\n.y2 = (state->src_y + state->src_h),\r\n};\r\nstruct drm_rect dest = {\r\n.x1 = state->crtc_x,\r\n.y1 = state->crtc_y,\r\n.x2 = state->crtc_x + state->crtc_w,\r\n.y2 = state->crtc_y + state->crtc_h,\r\n};\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->drm->event_lock, flags);\r\npriv->viu.osd1_ctrl_stat = OSD_ENABLE |\r\n(0xFF << OSD_GLOBAL_ALPHA_SHIFT) |\r\nOSD_BLK0_ENABLE;\r\npriv->viu.osd1_blk0_cfg[0] = ((MESON_CANVAS_ID_OSD1 << OSD_CANVAS_SEL) |\r\nOSD_ENDIANNESS_LE);\r\nif (meson_vpu_is_compatible(priv, "amlogic,meson-gxbb-vpu"))\r\npriv->viu.osd1_blk0_cfg[0] |= OSD_OUTPUT_COLOR_RGB;\r\nswitch (fb->format->format) {\r\ncase DRM_FORMAT_XRGB8888:\r\nwritel_bits_relaxed(OSD_REPLACE_EN, OSD_REPLACE_EN,\r\npriv->io_base + _REG(VIU_OSD1_CTRL_STAT2));\r\npriv->viu.osd1_blk0_cfg[0] |= OSD_BLK_MODE_32 |\r\nOSD_COLOR_MATRIX_32_ARGB;\r\nbreak;\r\ncase DRM_FORMAT_ARGB8888:\r\nwritel_bits_relaxed(OSD_REPLACE_EN, 0,\r\npriv->io_base + _REG(VIU_OSD1_CTRL_STAT2));\r\npriv->viu.osd1_blk0_cfg[0] |= OSD_BLK_MODE_32 |\r\nOSD_COLOR_MATRIX_32_ARGB;\r\nbreak;\r\ncase DRM_FORMAT_RGB888:\r\npriv->viu.osd1_blk0_cfg[0] |= OSD_BLK_MODE_24 |\r\nOSD_COLOR_MATRIX_24_RGB;\r\nbreak;\r\ncase DRM_FORMAT_RGB565:\r\npriv->viu.osd1_blk0_cfg[0] |= OSD_BLK_MODE_16 |\r\nOSD_COLOR_MATRIX_16_RGB565;\r\nbreak;\r\n};\r\nif (state->crtc->mode.flags & DRM_MODE_FLAG_INTERLACE) {\r\npriv->viu.osd1_interlace = true;\r\ndest.y1 /= 2;\r\ndest.y2 /= 2;\r\n} else\r\npriv->viu.osd1_interlace = false;\r\npriv->viu.osd1_blk0_cfg[1] = ((fixed16_to_int(src.x2) - 1) << 16) |\r\nfixed16_to_int(src.x1);\r\npriv->viu.osd1_blk0_cfg[2] = ((fixed16_to_int(src.y2) - 1) << 16) |\r\nfixed16_to_int(src.y1);\r\npriv->viu.osd1_blk0_cfg[3] = ((dest.x2 - 1) << 16) | dest.x1;\r\npriv->viu.osd1_blk0_cfg[4] = ((dest.y2 - 1) << 16) | dest.y1;\r\ngem = drm_fb_cma_get_gem_obj(fb, 0);\r\nmeson_canvas_setup(priv, MESON_CANVAS_ID_OSD1,\r\ngem->paddr, fb->pitches[0],\r\nfb->height, MESON_CANVAS_WRAP_NONE,\r\nMESON_CANVAS_BLKMODE_LINEAR);\r\nspin_unlock_irqrestore(&priv->drm->event_lock, flags);\r\n}\r\nstatic void meson_plane_atomic_disable(struct drm_plane *plane,\r\nstruct drm_plane_state *old_state)\r\n{\r\nstruct meson_plane *meson_plane = to_meson_plane(plane);\r\nstruct meson_drm *priv = meson_plane->priv;\r\nwritel_bits_relaxed(VPP_OSD1_POSTBLEND, 0,\r\npriv->io_base + _REG(VPP_MISC));\r\n}\r\nint meson_plane_create(struct meson_drm *priv)\r\n{\r\nstruct meson_plane *meson_plane;\r\nstruct drm_plane *plane;\r\nmeson_plane = devm_kzalloc(priv->drm->dev, sizeof(*meson_plane),\r\nGFP_KERNEL);\r\nif (!meson_plane)\r\nreturn -ENOMEM;\r\nmeson_plane->priv = priv;\r\nplane = &meson_plane->base;\r\ndrm_universal_plane_init(priv->drm, plane, 0xFF,\r\n&meson_plane_funcs,\r\nsupported_drm_formats,\r\nARRAY_SIZE(supported_drm_formats),\r\nDRM_PLANE_TYPE_PRIMARY, "meson_primary_plane");\r\ndrm_plane_helper_add(plane, &meson_plane_helper_funcs);\r\npriv->primary_plane = plane;\r\nreturn 0;\r\n}
