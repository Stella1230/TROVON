static void update_mcs_stats(enum mcs_op op, unsigned long clks)\r\n{\r\nunsigned long nsec;\r\nnsec = CLKS2NSEC(clks);\r\natomic_long_inc(&mcs_op_statistics[op].count);\r\natomic_long_add(nsec, &mcs_op_statistics[op].total);\r\nif (mcs_op_statistics[op].max < nsec)\r\nmcs_op_statistics[op].max = nsec;\r\n}\r\nstatic void start_instruction(void *h)\r\n{\r\nunsigned long *w0 = h;\r\nwmb();\r\n*w0 = *w0 | 0x20001;\r\ngru_flush_cache(h);\r\n}\r\nstatic void report_instruction_timeout(void *h)\r\n{\r\nunsigned long goff = GSEGPOFF((unsigned long)h);\r\nchar *id = "???";\r\nif (TYPE_IS(CCH, goff))\r\nid = "CCH";\r\nelse if (TYPE_IS(TGH, goff))\r\nid = "TGH";\r\nelse if (TYPE_IS(TFH, goff))\r\nid = "TFH";\r\npanic(KERN_ALERT "GRU %p (%s) is malfunctioning\n", h, id);\r\n}\r\nstatic int wait_instruction_complete(void *h, enum mcs_op opc)\r\n{\r\nint status;\r\nunsigned long start_time = get_cycles();\r\nwhile (1) {\r\ncpu_relax();\r\nstatus = GET_MSEG_HANDLE_STATUS(h);\r\nif (status != CCHSTATUS_ACTIVE)\r\nbreak;\r\nif (GRU_OPERATION_TIMEOUT < (get_cycles() - start_time)) {\r\nreport_instruction_timeout(h);\r\nstart_time = get_cycles();\r\n}\r\n}\r\nif (gru_options & OPT_STATS)\r\nupdate_mcs_stats(opc, get_cycles() - start_time);\r\nreturn status;\r\n}\r\nint cch_allocate(struct gru_context_configuration_handle *cch)\r\n{\r\nint ret;\r\ncch->opc = CCHOP_ALLOCATE;\r\nstart_instruction(cch);\r\nret = wait_instruction_complete(cch, cchop_allocate);\r\nsync_core();\r\nreturn ret;\r\n}\r\nint cch_start(struct gru_context_configuration_handle *cch)\r\n{\r\ncch->opc = CCHOP_START;\r\nstart_instruction(cch);\r\nreturn wait_instruction_complete(cch, cchop_start);\r\n}\r\nint cch_interrupt(struct gru_context_configuration_handle *cch)\r\n{\r\ncch->opc = CCHOP_INTERRUPT;\r\nstart_instruction(cch);\r\nreturn wait_instruction_complete(cch, cchop_interrupt);\r\n}\r\nint cch_deallocate(struct gru_context_configuration_handle *cch)\r\n{\r\nint ret;\r\ncch->opc = CCHOP_DEALLOCATE;\r\nstart_instruction(cch);\r\nret = wait_instruction_complete(cch, cchop_deallocate);\r\nsync_core();\r\nreturn ret;\r\n}\r\nint cch_interrupt_sync(struct gru_context_configuration_handle\r\n*cch)\r\n{\r\ncch->opc = CCHOP_INTERRUPT_SYNC;\r\nstart_instruction(cch);\r\nreturn wait_instruction_complete(cch, cchop_interrupt_sync);\r\n}\r\nint tgh_invalidate(struct gru_tlb_global_handle *tgh,\r\nunsigned long vaddr, unsigned long vaddrmask,\r\nint asid, int pagesize, int global, int n,\r\nunsigned short ctxbitmap)\r\n{\r\ntgh->vaddr = vaddr;\r\ntgh->asid = asid;\r\ntgh->pagesize = pagesize;\r\ntgh->n = n;\r\ntgh->global = global;\r\ntgh->vaddrmask = vaddrmask;\r\ntgh->ctxbitmap = ctxbitmap;\r\ntgh->opc = TGHOP_TLBINV;\r\nstart_instruction(tgh);\r\nreturn wait_instruction_complete(tgh, tghop_invalidate);\r\n}\r\nint tfh_write_only(struct gru_tlb_fault_handle *tfh,\r\nunsigned long paddr, int gaa,\r\nunsigned long vaddr, int asid, int dirty,\r\nint pagesize)\r\n{\r\ntfh->fillasid = asid;\r\ntfh->fillvaddr = vaddr;\r\ntfh->pfn = paddr >> GRU_PADDR_SHIFT;\r\ntfh->gaa = gaa;\r\ntfh->dirty = dirty;\r\ntfh->pagesize = pagesize;\r\ntfh->opc = TFHOP_WRITE_ONLY;\r\nstart_instruction(tfh);\r\nreturn wait_instruction_complete(tfh, tfhop_write_only);\r\n}\r\nvoid tfh_write_restart(struct gru_tlb_fault_handle *tfh,\r\nunsigned long paddr, int gaa,\r\nunsigned long vaddr, int asid, int dirty,\r\nint pagesize)\r\n{\r\ntfh->fillasid = asid;\r\ntfh->fillvaddr = vaddr;\r\ntfh->pfn = paddr >> GRU_PADDR_SHIFT;\r\ntfh->gaa = gaa;\r\ntfh->dirty = dirty;\r\ntfh->pagesize = pagesize;\r\ntfh->opc = TFHOP_WRITE_RESTART;\r\nstart_instruction(tfh);\r\n}\r\nvoid tfh_user_polling_mode(struct gru_tlb_fault_handle *tfh)\r\n{\r\ntfh->opc = TFHOP_USER_POLLING_MODE;\r\nstart_instruction(tfh);\r\n}\r\nvoid tfh_exception(struct gru_tlb_fault_handle *tfh)\r\n{\r\ntfh->opc = TFHOP_EXCEPTION;\r\nstart_instruction(tfh);\r\n}
