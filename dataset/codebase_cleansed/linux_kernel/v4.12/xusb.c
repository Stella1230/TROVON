static struct phy *tegra_xusb_pad_of_xlate(struct device *dev,\r\nstruct of_phandle_args *args)\r\n{\r\nstruct tegra_xusb_pad *pad = dev_get_drvdata(dev);\r\nstruct phy *phy = NULL;\r\nunsigned int i;\r\nif (args->args_count != 0)\r\nreturn ERR_PTR(-EINVAL);\r\nfor (i = 0; i < pad->soc->num_lanes; i++) {\r\nif (!pad->lanes[i])\r\ncontinue;\r\nif (pad->lanes[i]->dev.of_node == args->np) {\r\nphy = pad->lanes[i];\r\nbreak;\r\n}\r\n}\r\nif (phy == NULL)\r\nphy = ERR_PTR(-ENODEV);\r\nreturn phy;\r\n}\r\nstatic struct device_node *\r\ntegra_xusb_find_pad_node(struct tegra_xusb_padctl *padctl, const char *name)\r\n{\r\nstruct device_node *np = of_node_get(padctl->dev->of_node);\r\nnp = of_find_node_by_name(np, "pads");\r\nif (np)\r\nnp = of_find_node_by_name(np, name);\r\nreturn np;\r\n}\r\nstatic struct device_node *\r\ntegra_xusb_pad_find_phy_node(struct tegra_xusb_pad *pad, unsigned int index)\r\n{\r\nstruct device_node *np = of_node_get(pad->dev.of_node);\r\nnp = of_find_node_by_name(np, "lanes");\r\nif (!np)\r\nreturn NULL;\r\nreturn of_find_node_by_name(np, pad->soc->lanes[index].name);\r\n}\r\nstatic int\r\ntegra_xusb_lane_lookup_function(struct tegra_xusb_lane *lane,\r\nconst char *function)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < lane->soc->num_funcs; i++)\r\nif (strcmp(function, lane->soc->funcs[i]) == 0)\r\nreturn i;\r\nreturn -EINVAL;\r\n}\r\nint tegra_xusb_lane_parse_dt(struct tegra_xusb_lane *lane,\r\nstruct device_node *np)\r\n{\r\nstruct device *dev = &lane->pad->dev;\r\nconst char *function;\r\nint err;\r\nerr = of_property_read_string(np, "nvidia,function", &function);\r\nif (err < 0)\r\nreturn err;\r\nerr = tegra_xusb_lane_lookup_function(lane, function);\r\nif (err < 0) {\r\ndev_err(dev, "invalid function \"%s\" for lane \"%s\"\n",\r\nfunction, np->name);\r\nreturn err;\r\n}\r\nlane->function = err;\r\nreturn 0;\r\n}\r\nstatic void tegra_xusb_lane_destroy(struct phy *phy)\r\n{\r\nif (phy) {\r\nstruct tegra_xusb_lane *lane = phy_get_drvdata(phy);\r\nlane->pad->ops->remove(lane);\r\nphy_destroy(phy);\r\n}\r\n}\r\nstatic void tegra_xusb_pad_release(struct device *dev)\r\n{\r\nstruct tegra_xusb_pad *pad = to_tegra_xusb_pad(dev);\r\npad->soc->ops->remove(pad);\r\n}\r\nint tegra_xusb_pad_init(struct tegra_xusb_pad *pad,\r\nstruct tegra_xusb_padctl *padctl,\r\nstruct device_node *np)\r\n{\r\nint err;\r\ndevice_initialize(&pad->dev);\r\nINIT_LIST_HEAD(&pad->list);\r\npad->dev.parent = padctl->dev;\r\npad->dev.type = &tegra_xusb_pad_type;\r\npad->dev.of_node = np;\r\npad->padctl = padctl;\r\nerr = dev_set_name(&pad->dev, "%s", pad->soc->name);\r\nif (err < 0)\r\ngoto unregister;\r\nerr = device_add(&pad->dev);\r\nif (err < 0)\r\ngoto unregister;\r\nreturn 0;\r\nunregister:\r\ndevice_unregister(&pad->dev);\r\nreturn err;\r\n}\r\nint tegra_xusb_pad_register(struct tegra_xusb_pad *pad,\r\nconst struct phy_ops *ops)\r\n{\r\nstruct device_node *children;\r\nstruct phy *lane;\r\nunsigned int i;\r\nint err;\r\nchildren = of_find_node_by_name(pad->dev.of_node, "lanes");\r\nif (!children)\r\nreturn -ENODEV;\r\npad->lanes = devm_kcalloc(&pad->dev, pad->soc->num_lanes, sizeof(lane),\r\nGFP_KERNEL);\r\nif (!pad->lanes) {\r\nof_node_put(children);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < pad->soc->num_lanes; i++) {\r\nstruct device_node *np = tegra_xusb_pad_find_phy_node(pad, i);\r\nstruct tegra_xusb_lane *lane;\r\nif (!np || !of_device_is_available(np)) {\r\nof_node_put(np);\r\ncontinue;\r\n}\r\npad->lanes[i] = phy_create(&pad->dev, np, ops);\r\nif (IS_ERR(pad->lanes[i])) {\r\nerr = PTR_ERR(pad->lanes[i]);\r\nof_node_put(np);\r\ngoto remove;\r\n}\r\nlane = pad->ops->probe(pad, np, i);\r\nif (IS_ERR(lane)) {\r\nphy_destroy(pad->lanes[i]);\r\nerr = PTR_ERR(lane);\r\ngoto remove;\r\n}\r\nlist_add_tail(&lane->list, &pad->padctl->lanes);\r\nphy_set_drvdata(pad->lanes[i], lane);\r\n}\r\npad->provider = of_phy_provider_register_full(&pad->dev, children,\r\ntegra_xusb_pad_of_xlate);\r\nif (IS_ERR(pad->provider)) {\r\nerr = PTR_ERR(pad->provider);\r\ngoto remove;\r\n}\r\nreturn 0;\r\nremove:\r\nwhile (i--)\r\ntegra_xusb_lane_destroy(pad->lanes[i]);\r\nof_node_put(children);\r\nreturn err;\r\n}\r\nvoid tegra_xusb_pad_unregister(struct tegra_xusb_pad *pad)\r\n{\r\nunsigned int i = pad->soc->num_lanes;\r\nof_phy_provider_unregister(pad->provider);\r\nwhile (i--)\r\ntegra_xusb_lane_destroy(pad->lanes[i]);\r\ndevice_unregister(&pad->dev);\r\n}\r\nstatic struct tegra_xusb_pad *\r\ntegra_xusb_pad_create(struct tegra_xusb_padctl *padctl,\r\nconst struct tegra_xusb_pad_soc *soc)\r\n{\r\nstruct tegra_xusb_pad *pad;\r\nstruct device_node *np;\r\nint err;\r\nnp = tegra_xusb_find_pad_node(padctl, soc->name);\r\nif (!np || !of_device_is_available(np))\r\nreturn NULL;\r\npad = soc->ops->probe(padctl, soc, np);\r\nif (IS_ERR(pad)) {\r\nerr = PTR_ERR(pad);\r\ndev_err(padctl->dev, "failed to create pad %s: %d\n",\r\nsoc->name, err);\r\nreturn ERR_PTR(err);\r\n}\r\nif (strcmp(soc->name, "pcie") == 0)\r\npadctl->pcie = pad;\r\nif (strcmp(soc->name, "sata") == 0)\r\npadctl->sata = pad;\r\nif (strcmp(soc->name, "usb2") == 0)\r\npadctl->usb2 = pad;\r\nif (strcmp(soc->name, "ulpi") == 0)\r\npadctl->ulpi = pad;\r\nif (strcmp(soc->name, "hsic") == 0)\r\npadctl->hsic = pad;\r\nreturn pad;\r\n}\r\nstatic void __tegra_xusb_remove_pads(struct tegra_xusb_padctl *padctl)\r\n{\r\nstruct tegra_xusb_pad *pad, *tmp;\r\nlist_for_each_entry_safe_reverse(pad, tmp, &padctl->pads, list) {\r\nlist_del(&pad->list);\r\ntegra_xusb_pad_unregister(pad);\r\n}\r\n}\r\nstatic void tegra_xusb_remove_pads(struct tegra_xusb_padctl *padctl)\r\n{\r\nmutex_lock(&padctl->lock);\r\n__tegra_xusb_remove_pads(padctl);\r\nmutex_unlock(&padctl->lock);\r\n}\r\nstatic void tegra_xusb_lane_program(struct tegra_xusb_lane *lane)\r\n{\r\nstruct tegra_xusb_padctl *padctl = lane->pad->padctl;\r\nconst struct tegra_xusb_lane_soc *soc = lane->soc;\r\nu32 value;\r\nvalue = padctl_readl(padctl, soc->offset);\r\nvalue &= ~(soc->mask << soc->shift);\r\nvalue |= lane->function << soc->shift;\r\npadctl_writel(padctl, value, soc->offset);\r\n}\r\nstatic void tegra_xusb_pad_program(struct tegra_xusb_pad *pad)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < pad->soc->num_lanes; i++) {\r\nstruct tegra_xusb_lane *lane;\r\nif (pad->lanes[i]) {\r\nlane = phy_get_drvdata(pad->lanes[i]);\r\ntegra_xusb_lane_program(lane);\r\n}\r\n}\r\n}\r\nstatic int tegra_xusb_setup_pads(struct tegra_xusb_padctl *padctl)\r\n{\r\nstruct tegra_xusb_pad *pad;\r\nunsigned int i;\r\nmutex_lock(&padctl->lock);\r\nfor (i = 0; i < padctl->soc->num_pads; i++) {\r\nconst struct tegra_xusb_pad_soc *soc = padctl->soc->pads[i];\r\nint err;\r\npad = tegra_xusb_pad_create(padctl, soc);\r\nif (IS_ERR(pad)) {\r\nerr = PTR_ERR(pad);\r\ndev_err(padctl->dev, "failed to create pad %s: %d\n",\r\nsoc->name, err);\r\n__tegra_xusb_remove_pads(padctl);\r\nmutex_unlock(&padctl->lock);\r\nreturn err;\r\n}\r\nif (!pad)\r\ncontinue;\r\nlist_add_tail(&pad->list, &padctl->pads);\r\n}\r\nlist_for_each_entry(pad, &padctl->pads, list)\r\ntegra_xusb_pad_program(pad);\r\nmutex_unlock(&padctl->lock);\r\nreturn 0;\r\n}\r\nstatic bool tegra_xusb_lane_check(struct tegra_xusb_lane *lane,\r\nconst char *function)\r\n{\r\nconst char *func = lane->soc->funcs[lane->function];\r\nreturn strcmp(function, func) == 0;\r\n}\r\nstruct tegra_xusb_lane *tegra_xusb_find_lane(struct tegra_xusb_padctl *padctl,\r\nconst char *type,\r\nunsigned int index)\r\n{\r\nstruct tegra_xusb_lane *lane, *hit = ERR_PTR(-ENODEV);\r\nchar *name;\r\nname = kasprintf(GFP_KERNEL, "%s-%u", type, index);\r\nif (!name)\r\nreturn ERR_PTR(-ENOMEM);\r\nlist_for_each_entry(lane, &padctl->lanes, list) {\r\nif (strcmp(lane->soc->name, name) == 0) {\r\nhit = lane;\r\nbreak;\r\n}\r\n}\r\nkfree(name);\r\nreturn hit;\r\n}\r\nstruct tegra_xusb_lane *\r\ntegra_xusb_port_find_lane(struct tegra_xusb_port *port,\r\nconst struct tegra_xusb_lane_map *map,\r\nconst char *function)\r\n{\r\nstruct tegra_xusb_lane *lane, *match = ERR_PTR(-ENODEV);\r\nfor (map = map; map->type; map++) {\r\nif (port->index != map->port)\r\ncontinue;\r\nlane = tegra_xusb_find_lane(port->padctl, map->type,\r\nmap->index);\r\nif (IS_ERR(lane))\r\ncontinue;\r\nif (!tegra_xusb_lane_check(lane, function))\r\ncontinue;\r\nif (!IS_ERR(match))\r\ndev_err(&port->dev, "conflicting match: %s-%u / %s\n",\r\nmap->type, map->index, match->soc->name);\r\nelse\r\nmatch = lane;\r\n}\r\nreturn match;\r\n}\r\nstatic struct device_node *\r\ntegra_xusb_find_port_node(struct tegra_xusb_padctl *padctl, const char *type,\r\nunsigned int index)\r\n{\r\nstruct device_node *np = of_node_get(padctl->dev->of_node);\r\nnp = of_find_node_by_name(np, "ports");\r\nif (np) {\r\nchar *name;\r\nname = kasprintf(GFP_KERNEL, "%s-%u", type, index);\r\nnp = of_find_node_by_name(np, name);\r\nkfree(name);\r\n}\r\nreturn np;\r\n}\r\nstruct tegra_xusb_port *\r\ntegra_xusb_find_port(struct tegra_xusb_padctl *padctl, const char *type,\r\nunsigned int index)\r\n{\r\nstruct tegra_xusb_port *port;\r\nstruct device_node *np;\r\nnp = tegra_xusb_find_port_node(padctl, type, index);\r\nif (!np)\r\nreturn NULL;\r\nlist_for_each_entry(port, &padctl->ports, list) {\r\nif (np == port->dev.of_node) {\r\nof_node_put(np);\r\nreturn port;\r\n}\r\n}\r\nof_node_put(np);\r\nreturn NULL;\r\n}\r\nstruct tegra_xusb_usb2_port *\r\ntegra_xusb_find_usb2_port(struct tegra_xusb_padctl *padctl, unsigned int index)\r\n{\r\nstruct tegra_xusb_port *port;\r\nport = tegra_xusb_find_port(padctl, "usb2", index);\r\nif (port)\r\nreturn to_usb2_port(port);\r\nreturn NULL;\r\n}\r\nstruct tegra_xusb_usb3_port *\r\ntegra_xusb_find_usb3_port(struct tegra_xusb_padctl *padctl, unsigned int index)\r\n{\r\nstruct tegra_xusb_port *port;\r\nport = tegra_xusb_find_port(padctl, "usb3", index);\r\nif (port)\r\nreturn to_usb3_port(port);\r\nreturn NULL;\r\n}\r\nstatic void tegra_xusb_port_release(struct device *dev)\r\n{\r\n}\r\nstatic int tegra_xusb_port_init(struct tegra_xusb_port *port,\r\nstruct tegra_xusb_padctl *padctl,\r\nstruct device_node *np,\r\nconst char *name,\r\nunsigned int index)\r\n{\r\nint err;\r\nINIT_LIST_HEAD(&port->list);\r\nport->padctl = padctl;\r\nport->index = index;\r\ndevice_initialize(&port->dev);\r\nport->dev.type = &tegra_xusb_port_type;\r\nport->dev.of_node = of_node_get(np);\r\nport->dev.parent = padctl->dev;\r\nerr = dev_set_name(&port->dev, "%s-%u", name, index);\r\nif (err < 0)\r\ngoto unregister;\r\nerr = device_add(&port->dev);\r\nif (err < 0)\r\ngoto unregister;\r\nreturn 0;\r\nunregister:\r\ndevice_unregister(&port->dev);\r\nreturn err;\r\n}\r\nstatic void tegra_xusb_port_unregister(struct tegra_xusb_port *port)\r\n{\r\ndevice_unregister(&port->dev);\r\n}\r\nstatic int tegra_xusb_usb2_port_parse_dt(struct tegra_xusb_usb2_port *usb2)\r\n{\r\nstruct tegra_xusb_port *port = &usb2->base;\r\nstruct device_node *np = port->dev.of_node;\r\nusb2->internal = of_property_read_bool(np, "nvidia,internal");\r\nusb2->supply = devm_regulator_get(&port->dev, "vbus");\r\nreturn PTR_ERR_OR_ZERO(usb2->supply);\r\n}\r\nstatic int tegra_xusb_add_usb2_port(struct tegra_xusb_padctl *padctl,\r\nunsigned int index)\r\n{\r\nstruct tegra_xusb_usb2_port *usb2;\r\nstruct device_node *np;\r\nint err = 0;\r\nnp = tegra_xusb_find_port_node(padctl, "usb2", index);\r\nif (!np || !of_device_is_available(np))\r\ngoto out;\r\nusb2 = devm_kzalloc(padctl->dev, sizeof(*usb2), GFP_KERNEL);\r\nif (!usb2) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nerr = tegra_xusb_port_init(&usb2->base, padctl, np, "usb2", index);\r\nif (err < 0)\r\ngoto out;\r\nusb2->base.ops = padctl->soc->ports.usb2.ops;\r\nusb2->base.lane = usb2->base.ops->map(&usb2->base);\r\nif (IS_ERR(usb2->base.lane)) {\r\nerr = PTR_ERR(usb2->base.lane);\r\ngoto out;\r\n}\r\nerr = tegra_xusb_usb2_port_parse_dt(usb2);\r\nif (err < 0) {\r\ntegra_xusb_port_unregister(&usb2->base);\r\ngoto out;\r\n}\r\nlist_add_tail(&usb2->base.list, &padctl->ports);\r\nout:\r\nof_node_put(np);\r\nreturn err;\r\n}\r\nstatic int tegra_xusb_ulpi_port_parse_dt(struct tegra_xusb_ulpi_port *ulpi)\r\n{\r\nstruct tegra_xusb_port *port = &ulpi->base;\r\nstruct device_node *np = port->dev.of_node;\r\nulpi->internal = of_property_read_bool(np, "nvidia,internal");\r\nreturn 0;\r\n}\r\nstatic int tegra_xusb_add_ulpi_port(struct tegra_xusb_padctl *padctl,\r\nunsigned int index)\r\n{\r\nstruct tegra_xusb_ulpi_port *ulpi;\r\nstruct device_node *np;\r\nint err = 0;\r\nnp = tegra_xusb_find_port_node(padctl, "ulpi", index);\r\nif (!np || !of_device_is_available(np))\r\ngoto out;\r\nulpi = devm_kzalloc(padctl->dev, sizeof(*ulpi), GFP_KERNEL);\r\nif (!ulpi) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nerr = tegra_xusb_port_init(&ulpi->base, padctl, np, "ulpi", index);\r\nif (err < 0)\r\ngoto out;\r\nulpi->base.ops = padctl->soc->ports.ulpi.ops;\r\nulpi->base.lane = ulpi->base.ops->map(&ulpi->base);\r\nif (IS_ERR(ulpi->base.lane)) {\r\nerr = PTR_ERR(ulpi->base.lane);\r\ngoto out;\r\n}\r\nerr = tegra_xusb_ulpi_port_parse_dt(ulpi);\r\nif (err < 0) {\r\ntegra_xusb_port_unregister(&ulpi->base);\r\ngoto out;\r\n}\r\nlist_add_tail(&ulpi->base.list, &padctl->ports);\r\nout:\r\nof_node_put(np);\r\nreturn err;\r\n}\r\nstatic int tegra_xusb_hsic_port_parse_dt(struct tegra_xusb_hsic_port *hsic)\r\n{\r\nreturn 0;\r\n}\r\nstatic int tegra_xusb_add_hsic_port(struct tegra_xusb_padctl *padctl,\r\nunsigned int index)\r\n{\r\nstruct tegra_xusb_hsic_port *hsic;\r\nstruct device_node *np;\r\nint err = 0;\r\nnp = tegra_xusb_find_port_node(padctl, "hsic", index);\r\nif (!np || !of_device_is_available(np))\r\ngoto out;\r\nhsic = devm_kzalloc(padctl->dev, sizeof(*hsic), GFP_KERNEL);\r\nif (!hsic) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nerr = tegra_xusb_port_init(&hsic->base, padctl, np, "hsic", index);\r\nif (err < 0)\r\ngoto out;\r\nhsic->base.ops = padctl->soc->ports.hsic.ops;\r\nhsic->base.lane = hsic->base.ops->map(&hsic->base);\r\nif (IS_ERR(hsic->base.lane)) {\r\nerr = PTR_ERR(hsic->base.lane);\r\ngoto out;\r\n}\r\nerr = tegra_xusb_hsic_port_parse_dt(hsic);\r\nif (err < 0) {\r\ntegra_xusb_port_unregister(&hsic->base);\r\ngoto out;\r\n}\r\nlist_add_tail(&hsic->base.list, &padctl->ports);\r\nout:\r\nof_node_put(np);\r\nreturn err;\r\n}\r\nstatic int tegra_xusb_usb3_port_parse_dt(struct tegra_xusb_usb3_port *usb3)\r\n{\r\nstruct tegra_xusb_port *port = &usb3->base;\r\nstruct device_node *np = port->dev.of_node;\r\nu32 value;\r\nint err;\r\nerr = of_property_read_u32(np, "nvidia,usb2-companion", &value);\r\nif (err < 0) {\r\ndev_err(&port->dev, "failed to read port: %d\n", err);\r\nreturn err;\r\n}\r\nusb3->port = value;\r\nusb3->internal = of_property_read_bool(np, "nvidia,internal");\r\nusb3->supply = devm_regulator_get(&port->dev, "vbus");\r\nreturn PTR_ERR_OR_ZERO(usb3->supply);\r\n}\r\nstatic int tegra_xusb_add_usb3_port(struct tegra_xusb_padctl *padctl,\r\nunsigned int index)\r\n{\r\nstruct tegra_xusb_usb3_port *usb3;\r\nstruct device_node *np;\r\nint err = 0;\r\nnp = tegra_xusb_find_port_node(padctl, "usb3", index);\r\nif (!np || !of_device_is_available(np))\r\ngoto out;\r\nusb3 = devm_kzalloc(padctl->dev, sizeof(*usb3), GFP_KERNEL);\r\nif (!usb3) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nerr = tegra_xusb_port_init(&usb3->base, padctl, np, "usb3", index);\r\nif (err < 0)\r\ngoto out;\r\nusb3->base.ops = padctl->soc->ports.usb3.ops;\r\nusb3->base.lane = usb3->base.ops->map(&usb3->base);\r\nif (IS_ERR(usb3->base.lane)) {\r\nerr = PTR_ERR(usb3->base.lane);\r\ngoto out;\r\n}\r\nerr = tegra_xusb_usb3_port_parse_dt(usb3);\r\nif (err < 0) {\r\ntegra_xusb_port_unregister(&usb3->base);\r\ngoto out;\r\n}\r\nlist_add_tail(&usb3->base.list, &padctl->ports);\r\nout:\r\nof_node_put(np);\r\nreturn err;\r\n}\r\nstatic void __tegra_xusb_remove_ports(struct tegra_xusb_padctl *padctl)\r\n{\r\nstruct tegra_xusb_port *port, *tmp;\r\nlist_for_each_entry_safe_reverse(port, tmp, &padctl->ports, list) {\r\nlist_del(&port->list);\r\ntegra_xusb_port_unregister(port);\r\n}\r\n}\r\nstatic int tegra_xusb_setup_ports(struct tegra_xusb_padctl *padctl)\r\n{\r\nstruct tegra_xusb_port *port;\r\nunsigned int i;\r\nint err = 0;\r\nmutex_lock(&padctl->lock);\r\nfor (i = 0; i < padctl->soc->ports.usb2.count; i++) {\r\nerr = tegra_xusb_add_usb2_port(padctl, i);\r\nif (err < 0)\r\ngoto remove_ports;\r\n}\r\nfor (i = 0; i < padctl->soc->ports.ulpi.count; i++) {\r\nerr = tegra_xusb_add_ulpi_port(padctl, i);\r\nif (err < 0)\r\ngoto remove_ports;\r\n}\r\nfor (i = 0; i < padctl->soc->ports.hsic.count; i++) {\r\nerr = tegra_xusb_add_hsic_port(padctl, i);\r\nif (err < 0)\r\ngoto remove_ports;\r\n}\r\nfor (i = 0; i < padctl->soc->ports.usb3.count; i++) {\r\nerr = tegra_xusb_add_usb3_port(padctl, i);\r\nif (err < 0)\r\ngoto remove_ports;\r\n}\r\nlist_for_each_entry(port, &padctl->ports, list) {\r\nerr = port->ops->enable(port);\r\nif (err < 0)\r\ndev_err(padctl->dev, "failed to enable port %s: %d\n",\r\ndev_name(&port->dev), err);\r\n}\r\ngoto unlock;\r\nremove_ports:\r\n__tegra_xusb_remove_ports(padctl);\r\nunlock:\r\nmutex_unlock(&padctl->lock);\r\nreturn err;\r\n}\r\nstatic void tegra_xusb_remove_ports(struct tegra_xusb_padctl *padctl)\r\n{\r\nmutex_lock(&padctl->lock);\r\n__tegra_xusb_remove_ports(padctl);\r\nmutex_unlock(&padctl->lock);\r\n}\r\nstatic int tegra_xusb_padctl_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = of_node_get(pdev->dev.of_node);\r\nconst struct tegra_xusb_padctl_soc *soc;\r\nstruct tegra_xusb_padctl *padctl;\r\nconst struct of_device_id *match;\r\nstruct resource *res;\r\nint err;\r\nnp = of_find_node_by_name(np, "pads");\r\nif (!np) {\r\ndev_warn(&pdev->dev, "deprecated DT, using legacy driver\n");\r\nreturn tegra_xusb_padctl_legacy_probe(pdev);\r\n}\r\nof_node_put(np);\r\nmatch = of_match_node(tegra_xusb_padctl_of_match, pdev->dev.of_node);\r\nsoc = match->data;\r\npadctl = soc->ops->probe(&pdev->dev, soc);\r\nif (IS_ERR(padctl))\r\nreturn PTR_ERR(padctl);\r\nplatform_set_drvdata(pdev, padctl);\r\nINIT_LIST_HEAD(&padctl->ports);\r\nINIT_LIST_HEAD(&padctl->lanes);\r\nINIT_LIST_HEAD(&padctl->pads);\r\nmutex_init(&padctl->lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npadctl->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(padctl->regs)) {\r\nerr = PTR_ERR(padctl->regs);\r\ngoto remove;\r\n}\r\npadctl->rst = devm_reset_control_get(&pdev->dev, NULL);\r\nif (IS_ERR(padctl->rst)) {\r\nerr = PTR_ERR(padctl->rst);\r\ngoto remove;\r\n}\r\nerr = reset_control_deassert(padctl->rst);\r\nif (err < 0)\r\ngoto remove;\r\nerr = tegra_xusb_setup_pads(padctl);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to setup pads: %d\n", err);\r\ngoto reset;\r\n}\r\nerr = tegra_xusb_setup_ports(padctl);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to setup XUSB ports: %d\n", err);\r\ngoto remove_pads;\r\n}\r\nreturn 0;\r\nremove_pads:\r\ntegra_xusb_remove_pads(padctl);\r\nreset:\r\nreset_control_assert(padctl->rst);\r\nremove:\r\nsoc->ops->remove(padctl);\r\nreturn err;\r\n}\r\nstatic int tegra_xusb_padctl_remove(struct platform_device *pdev)\r\n{\r\nstruct tegra_xusb_padctl *padctl = platform_get_drvdata(pdev);\r\nint err;\r\ntegra_xusb_remove_ports(padctl);\r\ntegra_xusb_remove_pads(padctl);\r\nerr = reset_control_assert(padctl->rst);\r\nif (err < 0)\r\ndev_err(&pdev->dev, "failed to assert reset: %d\n", err);\r\npadctl->soc->ops->remove(padctl);\r\nreturn err;\r\n}\r\nstruct tegra_xusb_padctl *tegra_xusb_padctl_get(struct device *dev)\r\n{\r\nstruct tegra_xusb_padctl *padctl;\r\nstruct platform_device *pdev;\r\nstruct device_node *np;\r\nnp = of_parse_phandle(dev->of_node, "nvidia,xusb-padctl", 0);\r\nif (!np)\r\nreturn ERR_PTR(-EINVAL);\r\npdev = of_find_device_by_node(np);\r\nif (!pdev) {\r\nof_node_put(np);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nof_node_put(np);\r\npadctl = platform_get_drvdata(pdev);\r\nif (!padctl) {\r\nput_device(&pdev->dev);\r\nreturn ERR_PTR(-EPROBE_DEFER);\r\n}\r\nreturn padctl;\r\n}\r\nvoid tegra_xusb_padctl_put(struct tegra_xusb_padctl *padctl)\r\n{\r\nif (padctl)\r\nput_device(padctl->dev);\r\n}\r\nint tegra_xusb_padctl_usb3_save_context(struct tegra_xusb_padctl *padctl,\r\nunsigned int port)\r\n{\r\nif (padctl->soc->ops->usb3_save_context)\r\nreturn padctl->soc->ops->usb3_save_context(padctl, port);\r\nreturn -ENOSYS;\r\n}\r\nint tegra_xusb_padctl_hsic_set_idle(struct tegra_xusb_padctl *padctl,\r\nunsigned int port, bool idle)\r\n{\r\nif (padctl->soc->ops->hsic_set_idle)\r\nreturn padctl->soc->ops->hsic_set_idle(padctl, port, idle);\r\nreturn -ENOSYS;\r\n}\r\nint tegra_xusb_padctl_usb3_set_lfps_detect(struct tegra_xusb_padctl *padctl,\r\nunsigned int port, bool enable)\r\n{\r\nif (padctl->soc->ops->usb3_set_lfps_detect)\r\nreturn padctl->soc->ops->usb3_set_lfps_detect(padctl, port,\r\nenable);\r\nreturn -ENOSYS;\r\n}
