static void ifi_canfd_irq_enable(struct net_device *ndev, bool enable)\r\n{\r\nstruct ifi_canfd_priv *priv = netdev_priv(ndev);\r\nu32 enirq = 0;\r\nif (enable) {\r\nenirq = IFI_CANFD_IRQMASK_TXFIFO_EMPTY |\r\nIFI_CANFD_IRQMASK_RXFIFO_NEMPTY;\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING)\r\nenirq |= IFI_CANFD_INTERRUPT_ERROR_COUNTER;\r\n}\r\nwritel(IFI_CANFD_IRQMASK_SET_ERR |\r\nIFI_CANFD_IRQMASK_SET_TS |\r\nIFI_CANFD_IRQMASK_SET_TX |\r\nIFI_CANFD_IRQMASK_SET_RX | enirq,\r\npriv->base + IFI_CANFD_IRQMASK);\r\n}\r\nstatic void ifi_canfd_read_fifo(struct net_device *ndev)\r\n{\r\nstruct net_device_stats *stats = &ndev->stats;\r\nstruct ifi_canfd_priv *priv = netdev_priv(ndev);\r\nstruct canfd_frame *cf;\r\nstruct sk_buff *skb;\r\nconst u32 rx_irq_mask = IFI_CANFD_INTERRUPT_RXFIFO_NEMPTY |\r\nIFI_CANFD_INTERRUPT_RXFIFO_NEMPTY_PER;\r\nu32 rxdlc, rxid;\r\nu32 dlc, id;\r\nint i;\r\nrxdlc = readl(priv->base + IFI_CANFD_RXFIFO_DLC);\r\nif (rxdlc & IFI_CANFD_RXFIFO_DLC_EDL)\r\nskb = alloc_canfd_skb(ndev, &cf);\r\nelse\r\nskb = alloc_can_skb(ndev, (struct can_frame **)&cf);\r\nif (!skb) {\r\nstats->rx_dropped++;\r\nreturn;\r\n}\r\ndlc = (rxdlc >> IFI_CANFD_RXFIFO_DLC_DLC_OFFSET) &\r\nIFI_CANFD_RXFIFO_DLC_DLC_MASK;\r\nif (rxdlc & IFI_CANFD_RXFIFO_DLC_EDL)\r\ncf->len = can_dlc2len(dlc);\r\nelse\r\ncf->len = get_can_dlc(dlc);\r\nrxid = readl(priv->base + IFI_CANFD_RXFIFO_ID);\r\nid = (rxid >> IFI_CANFD_RXFIFO_ID_ID_OFFSET);\r\nif (id & IFI_CANFD_RXFIFO_ID_IDE) {\r\nid &= IFI_CANFD_RXFIFO_ID_ID_XTD_MASK;\r\nid = (id >> IFI_CANFD_RXFIFO_ID_ID_XTD_OFFSET) |\r\n((id & IFI_CANFD_RXFIFO_ID_ID_STD_MASK) <<\r\nIFI_CANFD_RXFIFO_ID_ID_XTD_WIDTH);\r\nid |= CAN_EFF_FLAG;\r\n} else {\r\nid &= IFI_CANFD_RXFIFO_ID_ID_STD_MASK;\r\n}\r\ncf->can_id = id;\r\nif (rxdlc & IFI_CANFD_RXFIFO_DLC_ESI) {\r\ncf->flags |= CANFD_ESI;\r\nnetdev_dbg(ndev, "ESI Error\n");\r\n}\r\nif (!(rxdlc & IFI_CANFD_RXFIFO_DLC_EDL) &&\r\n(rxdlc & IFI_CANFD_RXFIFO_DLC_RTR)) {\r\ncf->can_id |= CAN_RTR_FLAG;\r\n} else {\r\nif (rxdlc & IFI_CANFD_RXFIFO_DLC_BRS)\r\ncf->flags |= CANFD_BRS;\r\nfor (i = 0; i < cf->len; i += 4) {\r\n*(u32 *)(cf->data + i) =\r\nreadl(priv->base + IFI_CANFD_RXFIFO_DATA + i);\r\n}\r\n}\r\nwritel(IFI_CANFD_RXSTCMD_REMOVE_MSG, priv->base + IFI_CANFD_RXSTCMD);\r\nwritel(rx_irq_mask, priv->base + IFI_CANFD_INTERRUPT);\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->len;\r\nnetif_receive_skb(skb);\r\n}\r\nstatic int ifi_canfd_do_rx_poll(struct net_device *ndev, int quota)\r\n{\r\nstruct ifi_canfd_priv *priv = netdev_priv(ndev);\r\nu32 pkts = 0;\r\nu32 rxst;\r\nrxst = readl(priv->base + IFI_CANFD_RXSTCMD);\r\nif (rxst & IFI_CANFD_RXSTCMD_EMPTY) {\r\nnetdev_dbg(ndev, "No messages in RX FIFO\n");\r\nreturn 0;\r\n}\r\nfor (;;) {\r\nif (rxst & IFI_CANFD_RXSTCMD_EMPTY)\r\nbreak;\r\nif (quota <= 0)\r\nbreak;\r\nifi_canfd_read_fifo(ndev);\r\nquota--;\r\npkts++;\r\nrxst = readl(priv->base + IFI_CANFD_RXSTCMD);\r\n}\r\nif (pkts)\r\ncan_led_event(ndev, CAN_LED_EVENT_RX);\r\nreturn pkts;\r\n}\r\nstatic int ifi_canfd_handle_lost_msg(struct net_device *ndev)\r\n{\r\nstruct net_device_stats *stats = &ndev->stats;\r\nstruct sk_buff *skb;\r\nstruct can_frame *frame;\r\nnetdev_err(ndev, "RX FIFO overflow, message(s) lost.\n");\r\nstats->rx_errors++;\r\nstats->rx_over_errors++;\r\nskb = alloc_can_err_skb(ndev, &frame);\r\nif (unlikely(!skb))\r\nreturn 0;\r\nframe->can_id |= CAN_ERR_CRTL;\r\nframe->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\r\nnetif_receive_skb(skb);\r\nreturn 1;\r\n}\r\nstatic int ifi_canfd_handle_lec_err(struct net_device *ndev, const u32 errctr)\r\n{\r\nstruct ifi_canfd_priv *priv = netdev_priv(ndev);\r\nstruct net_device_stats *stats = &ndev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nconst u32 errmask = IFI_CANFD_ERROR_CTR_OVERLOAD_FIRST |\r\nIFI_CANFD_ERROR_CTR_ACK_ERROR_FIRST |\r\nIFI_CANFD_ERROR_CTR_BIT0_ERROR_FIRST |\r\nIFI_CANFD_ERROR_CTR_BIT1_ERROR_FIRST |\r\nIFI_CANFD_ERROR_CTR_STUFF_ERROR_FIRST |\r\nIFI_CANFD_ERROR_CTR_CRC_ERROR_FIRST |\r\nIFI_CANFD_ERROR_CTR_FORM_ERROR_FIRST;\r\nif (!(errctr & errmask))\r\nreturn 0;\r\npriv->can.can_stats.bus_error++;\r\nstats->rx_errors++;\r\nskb = alloc_can_err_skb(ndev, &cf);\r\nif (unlikely(!skb))\r\nreturn 0;\r\ncf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\r\nif (errctr & IFI_CANFD_ERROR_CTR_OVERLOAD_FIRST)\r\ncf->data[2] |= CAN_ERR_PROT_OVERLOAD;\r\nif (errctr & IFI_CANFD_ERROR_CTR_ACK_ERROR_FIRST)\r\ncf->data[3] = CAN_ERR_PROT_LOC_ACK;\r\nif (errctr & IFI_CANFD_ERROR_CTR_BIT0_ERROR_FIRST)\r\ncf->data[2] |= CAN_ERR_PROT_BIT0;\r\nif (errctr & IFI_CANFD_ERROR_CTR_BIT1_ERROR_FIRST)\r\ncf->data[2] |= CAN_ERR_PROT_BIT1;\r\nif (errctr & IFI_CANFD_ERROR_CTR_STUFF_ERROR_FIRST)\r\ncf->data[2] |= CAN_ERR_PROT_STUFF;\r\nif (errctr & IFI_CANFD_ERROR_CTR_CRC_ERROR_FIRST)\r\ncf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;\r\nif (errctr & IFI_CANFD_ERROR_CTR_FORM_ERROR_FIRST)\r\ncf->data[2] |= CAN_ERR_PROT_FORM;\r\nwritel(IFI_CANFD_ERROR_CTR_ER_RESET, priv->base + IFI_CANFD_ERROR_CTR);\r\nwritel(IFI_CANFD_INTERRUPT_ERROR_COUNTER,\r\npriv->base + IFI_CANFD_INTERRUPT);\r\nwritel(IFI_CANFD_ERROR_CTR_ER_ENABLE, priv->base + IFI_CANFD_ERROR_CTR);\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nnetif_receive_skb(skb);\r\nreturn 1;\r\n}\r\nstatic int ifi_canfd_get_berr_counter(const struct net_device *ndev,\r\nstruct can_berr_counter *bec)\r\n{\r\nstruct ifi_canfd_priv *priv = netdev_priv(ndev);\r\nu32 err;\r\nerr = readl(priv->base + IFI_CANFD_ERROR);\r\nbec->rxerr = (err >> IFI_CANFD_ERROR_RX_OFFSET) &\r\nIFI_CANFD_ERROR_RX_MASK;\r\nbec->txerr = (err >> IFI_CANFD_ERROR_TX_OFFSET) &\r\nIFI_CANFD_ERROR_TX_MASK;\r\nreturn 0;\r\n}\r\nstatic int ifi_canfd_handle_state_change(struct net_device *ndev,\r\nenum can_state new_state)\r\n{\r\nstruct ifi_canfd_priv *priv = netdev_priv(ndev);\r\nstruct net_device_stats *stats = &ndev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nstruct can_berr_counter bec;\r\nswitch (new_state) {\r\ncase CAN_STATE_ERROR_ACTIVE:\r\npriv->can.can_stats.error_warning++;\r\npriv->can.state = CAN_STATE_ERROR_WARNING;\r\nbreak;\r\ncase CAN_STATE_ERROR_PASSIVE:\r\npriv->can.can_stats.error_passive++;\r\npriv->can.state = CAN_STATE_ERROR_PASSIVE;\r\nbreak;\r\ncase CAN_STATE_BUS_OFF:\r\npriv->can.state = CAN_STATE_BUS_OFF;\r\nifi_canfd_irq_enable(ndev, 0);\r\npriv->can.can_stats.bus_off++;\r\ncan_bus_off(ndev);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nskb = alloc_can_err_skb(ndev, &cf);\r\nif (unlikely(!skb))\r\nreturn 0;\r\nifi_canfd_get_berr_counter(ndev, &bec);\r\nswitch (new_state) {\r\ncase CAN_STATE_ERROR_ACTIVE:\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] = (bec.txerr > bec.rxerr) ?\r\nCAN_ERR_CRTL_TX_WARNING :\r\nCAN_ERR_CRTL_RX_WARNING;\r\ncf->data[6] = bec.txerr;\r\ncf->data[7] = bec.rxerr;\r\nbreak;\r\ncase CAN_STATE_ERROR_PASSIVE:\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] |= CAN_ERR_CRTL_RX_PASSIVE;\r\nif (bec.txerr > 127)\r\ncf->data[1] |= CAN_ERR_CRTL_TX_PASSIVE;\r\ncf->data[6] = bec.txerr;\r\ncf->data[7] = bec.rxerr;\r\nbreak;\r\ncase CAN_STATE_BUS_OFF:\r\ncf->can_id |= CAN_ERR_BUSOFF;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nnetif_receive_skb(skb);\r\nreturn 1;\r\n}\r\nstatic int ifi_canfd_handle_state_errors(struct net_device *ndev, u32 stcmd)\r\n{\r\nstruct ifi_canfd_priv *priv = netdev_priv(ndev);\r\nint work_done = 0;\r\nu32 isr;\r\nisr = readl(priv->base + IFI_CANFD_INTERRUPT);\r\nif ((isr & IFI_CANFD_INTERRUPT_ERROR_WARNING) &&\r\n(priv->can.state != CAN_STATE_ERROR_WARNING)) {\r\nwritel(IFI_CANFD_INTERRUPT_ERROR_WARNING,\r\npriv->base + IFI_CANFD_INTERRUPT);\r\nnetdev_dbg(ndev, "Error, entered warning state\n");\r\nwork_done += ifi_canfd_handle_state_change(ndev,\r\nCAN_STATE_ERROR_WARNING);\r\n}\r\nif ((stcmd & IFI_CANFD_STCMD_ERROR_PASSIVE) &&\r\n(priv->can.state != CAN_STATE_ERROR_PASSIVE)) {\r\nnetdev_dbg(ndev, "Error, entered passive state\n");\r\nwork_done += ifi_canfd_handle_state_change(ndev,\r\nCAN_STATE_ERROR_PASSIVE);\r\n}\r\nif ((stcmd & IFI_CANFD_STCMD_BUSOFF) &&\r\n(priv->can.state != CAN_STATE_BUS_OFF)) {\r\nnetdev_dbg(ndev, "Error, entered bus-off state\n");\r\nwork_done += ifi_canfd_handle_state_change(ndev,\r\nCAN_STATE_BUS_OFF);\r\n}\r\nreturn work_done;\r\n}\r\nstatic int ifi_canfd_poll(struct napi_struct *napi, int quota)\r\n{\r\nstruct net_device *ndev = napi->dev;\r\nstruct ifi_canfd_priv *priv = netdev_priv(ndev);\r\nconst u32 stcmd_state_mask = IFI_CANFD_STCMD_ERROR_PASSIVE |\r\nIFI_CANFD_STCMD_BUSOFF;\r\nint work_done = 0;\r\nu32 stcmd = readl(priv->base + IFI_CANFD_STCMD);\r\nu32 rxstcmd = readl(priv->base + IFI_CANFD_RXSTCMD);\r\nu32 errctr = readl(priv->base + IFI_CANFD_ERROR_CTR);\r\nif ((stcmd & stcmd_state_mask) ||\r\n((stcmd & IFI_CANFD_STCMD_ERROR_ACTIVE) == 0))\r\nwork_done += ifi_canfd_handle_state_errors(ndev, stcmd);\r\nif (rxstcmd & IFI_CANFD_RXSTCMD_OVERFLOW)\r\nwork_done += ifi_canfd_handle_lost_msg(ndev);\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING)\r\nwork_done += ifi_canfd_handle_lec_err(ndev, errctr);\r\nif (!(rxstcmd & IFI_CANFD_RXSTCMD_EMPTY))\r\nwork_done += ifi_canfd_do_rx_poll(ndev, quota - work_done);\r\nif (work_done < quota) {\r\nnapi_complete_done(napi, work_done);\r\nifi_canfd_irq_enable(ndev, 1);\r\n}\r\nreturn work_done;\r\n}\r\nstatic irqreturn_t ifi_canfd_isr(int irq, void *dev_id)\r\n{\r\nstruct net_device *ndev = (struct net_device *)dev_id;\r\nstruct ifi_canfd_priv *priv = netdev_priv(ndev);\r\nstruct net_device_stats *stats = &ndev->stats;\r\nconst u32 rx_irq_mask = IFI_CANFD_INTERRUPT_RXFIFO_NEMPTY |\r\nIFI_CANFD_INTERRUPT_RXFIFO_NEMPTY_PER |\r\nIFI_CANFD_INTERRUPT_ERROR_WARNING |\r\nIFI_CANFD_INTERRUPT_ERROR_COUNTER;\r\nconst u32 tx_irq_mask = IFI_CANFD_INTERRUPT_TXFIFO_EMPTY |\r\nIFI_CANFD_INTERRUPT_TXFIFO_REMOVE;\r\nconst u32 clr_irq_mask = ~((u32)(IFI_CANFD_INTERRUPT_SET_IRQ |\r\nIFI_CANFD_INTERRUPT_ERROR_WARNING));\r\nu32 isr;\r\nisr = readl(priv->base + IFI_CANFD_INTERRUPT);\r\nif (isr == 0)\r\nreturn IRQ_NONE;\r\nwritel(clr_irq_mask, priv->base + IFI_CANFD_INTERRUPT);\r\nif (isr & rx_irq_mask) {\r\nifi_canfd_irq_enable(ndev, 0);\r\nnapi_schedule(&priv->napi);\r\n}\r\nif (isr & IFI_CANFD_INTERRUPT_TXFIFO_REMOVE) {\r\nstats->tx_bytes += can_get_echo_skb(ndev, 0);\r\nstats->tx_packets++;\r\ncan_led_event(ndev, CAN_LED_EVENT_TX);\r\n}\r\nif (isr & tx_irq_mask)\r\nnetif_wake_queue(ndev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void ifi_canfd_set_bittiming(struct net_device *ndev)\r\n{\r\nstruct ifi_canfd_priv *priv = netdev_priv(ndev);\r\nconst struct can_bittiming *bt = &priv->can.bittiming;\r\nconst struct can_bittiming *dbt = &priv->can.data_bittiming;\r\nu16 brp, sjw, tseg1, tseg2, tdc;\r\nbrp = bt->brp - 2;\r\nsjw = bt->sjw - 1;\r\ntseg1 = bt->prop_seg + bt->phase_seg1 - 1;\r\ntseg2 = bt->phase_seg2 - 2;\r\nwritel((tseg2 << IFI_CANFD_TIME_TIMEB_OFF) |\r\n(tseg1 << IFI_CANFD_TIME_TIMEA_OFF) |\r\n(brp << IFI_CANFD_TIME_PRESCALE_OFF) |\r\n(sjw << IFI_CANFD_TIME_SJW_OFF_7_9_8_8),\r\npriv->base + IFI_CANFD_TIME);\r\nbrp = dbt->brp - 2;\r\nsjw = dbt->sjw - 1;\r\ntseg1 = dbt->prop_seg + dbt->phase_seg1 - 1;\r\ntseg2 = dbt->phase_seg2 - 2;\r\nwritel((tseg2 << IFI_CANFD_TIME_TIMEB_OFF) |\r\n(tseg1 << IFI_CANFD_TIME_TIMEA_OFF) |\r\n(brp << IFI_CANFD_TIME_PRESCALE_OFF) |\r\n(sjw << IFI_CANFD_TIME_SJW_OFF_7_9_8_8),\r\npriv->base + IFI_CANFD_FTIME);\r\ntdc = (dbt->brp * (dbt->phase_seg1 + 1)) & IFI_CANFD_TDELAY_MASK;\r\nwritel(IFI_CANFD_TDELAY_EN | IFI_CANFD_TDELAY_ABS | tdc,\r\npriv->base + IFI_CANFD_TDELAY);\r\n}\r\nstatic void ifi_canfd_set_filter(struct net_device *ndev, const u32 id,\r\nconst u32 mask, const u32 ident)\r\n{\r\nstruct ifi_canfd_priv *priv = netdev_priv(ndev);\r\nwritel(mask, priv->base + IFI_CANFD_FILTER_MASK(id));\r\nwritel(ident, priv->base + IFI_CANFD_FILTER_IDENT(id));\r\n}\r\nstatic void ifi_canfd_set_filters(struct net_device *ndev)\r\n{\r\nifi_canfd_set_filter(ndev, 0,\r\nIFI_CANFD_FILTER_MASK_VALID |\r\nIFI_CANFD_FILTER_MASK_EXT,\r\nIFI_CANFD_FILTER_IDENT_VALID);\r\nifi_canfd_set_filter(ndev, 1,\r\nIFI_CANFD_FILTER_MASK_VALID |\r\nIFI_CANFD_FILTER_MASK_EXT,\r\nIFI_CANFD_FILTER_IDENT_VALID |\r\nIFI_CANFD_FILTER_IDENT_IDE);\r\nifi_canfd_set_filter(ndev, 2,\r\nIFI_CANFD_FILTER_MASK_VALID |\r\nIFI_CANFD_FILTER_MASK_EDL |\r\nIFI_CANFD_FILTER_MASK_EXT,\r\nIFI_CANFD_FILTER_IDENT_VALID |\r\nIFI_CANFD_FILTER_IDENT_CANFD |\r\nIFI_CANFD_FILTER_IDENT_IDE);\r\n}\r\nstatic void ifi_canfd_start(struct net_device *ndev)\r\n{\r\nstruct ifi_canfd_priv *priv = netdev_priv(ndev);\r\nu32 stcmd;\r\nwritel(IFI_CANFD_STCMD_HARDRESET, priv->base + IFI_CANFD_STCMD);\r\nwritel(IFI_CANFD_STCMD_ENABLE_7_9_8_8_TIMING,\r\npriv->base + IFI_CANFD_STCMD);\r\nifi_canfd_set_bittiming(ndev);\r\nifi_canfd_set_filters(ndev);\r\nwritel(IFI_CANFD_RXSTCMD_RESET, priv->base + IFI_CANFD_RXSTCMD);\r\nwritel(0, priv->base + IFI_CANFD_RXSTCMD);\r\nwritel(IFI_CANFD_TXSTCMD_RESET, priv->base + IFI_CANFD_TXSTCMD);\r\nwritel(0, priv->base + IFI_CANFD_TXSTCMD);\r\nwritel(0, priv->base + IFI_CANFD_REPEAT);\r\nwritel(0, priv->base + IFI_CANFD_SUSPEND);\r\nwritel((u32)(~IFI_CANFD_INTERRUPT_SET_IRQ),\r\npriv->base + IFI_CANFD_INTERRUPT);\r\nstcmd = IFI_CANFD_STCMD_ENABLE | IFI_CANFD_STCMD_NORMAL_MODE |\r\nIFI_CANFD_STCMD_ENABLE_7_9_8_8_TIMING;\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\r\nstcmd |= IFI_CANFD_STCMD_BUSMONITOR;\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)\r\nstcmd |= IFI_CANFD_STCMD_LOOPBACK;\r\nif ((priv->can.ctrlmode & CAN_CTRLMODE_FD) &&\r\n!(priv->can.ctrlmode & CAN_CTRLMODE_FD_NON_ISO))\r\nstcmd |= IFI_CANFD_STCMD_ENABLE_ISO;\r\nif (!(priv->can.ctrlmode & CAN_CTRLMODE_FD))\r\nstcmd |= IFI_CANFD_STCMD_DISABLE_CANFD;\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nifi_canfd_irq_enable(ndev, 1);\r\nwritel(IFI_CANFD_ERROR_CTR_UNLOCK_MAGIC,\r\npriv->base + IFI_CANFD_ERROR_CTR);\r\nwritel(IFI_CANFD_ERROR_CTR_ER_RESET, priv->base + IFI_CANFD_ERROR_CTR);\r\nwritel(IFI_CANFD_ERROR_CTR_ER_ENABLE, priv->base + IFI_CANFD_ERROR_CTR);\r\nwritel(stcmd, priv->base + IFI_CANFD_STCMD);\r\n}\r\nstatic void ifi_canfd_stop(struct net_device *ndev)\r\n{\r\nstruct ifi_canfd_priv *priv = netdev_priv(ndev);\r\nwritel(IFI_CANFD_ERROR_CTR_ER_RESET, priv->base + IFI_CANFD_ERROR_CTR);\r\nwritel(0, priv->base + IFI_CANFD_ERROR_CTR);\r\nwritel(IFI_CANFD_STCMD_HARDRESET, priv->base + IFI_CANFD_STCMD);\r\nwritel(~0, priv->base + IFI_CANFD_IRQMASK);\r\nwritel((u32)(~IFI_CANFD_INTERRUPT_SET_IRQ),\r\npriv->base + IFI_CANFD_INTERRUPT);\r\npriv->can.state = CAN_STATE_STOPPED;\r\n}\r\nstatic int ifi_canfd_set_mode(struct net_device *ndev, enum can_mode mode)\r\n{\r\nswitch (mode) {\r\ncase CAN_MODE_START:\r\nifi_canfd_start(ndev);\r\nnetif_wake_queue(ndev);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ifi_canfd_open(struct net_device *ndev)\r\n{\r\nstruct ifi_canfd_priv *priv = netdev_priv(ndev);\r\nint ret;\r\nret = open_candev(ndev);\r\nif (ret) {\r\nnetdev_err(ndev, "Failed to open CAN device\n");\r\nreturn ret;\r\n}\r\nret = request_irq(ndev->irq, ifi_canfd_isr, IRQF_SHARED,\r\nndev->name, ndev);\r\nif (ret < 0) {\r\nnetdev_err(ndev, "Failed to request interrupt\n");\r\ngoto err_irq;\r\n}\r\nifi_canfd_start(ndev);\r\ncan_led_event(ndev, CAN_LED_EVENT_OPEN);\r\nnapi_enable(&priv->napi);\r\nnetif_start_queue(ndev);\r\nreturn 0;\r\nerr_irq:\r\nclose_candev(ndev);\r\nreturn ret;\r\n}\r\nstatic int ifi_canfd_close(struct net_device *ndev)\r\n{\r\nstruct ifi_canfd_priv *priv = netdev_priv(ndev);\r\nnetif_stop_queue(ndev);\r\nnapi_disable(&priv->napi);\r\nifi_canfd_stop(ndev);\r\nfree_irq(ndev->irq, ndev);\r\nclose_candev(ndev);\r\ncan_led_event(ndev, CAN_LED_EVENT_STOP);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t ifi_canfd_start_xmit(struct sk_buff *skb,\r\nstruct net_device *ndev)\r\n{\r\nstruct ifi_canfd_priv *priv = netdev_priv(ndev);\r\nstruct canfd_frame *cf = (struct canfd_frame *)skb->data;\r\nu32 txst, txid, txdlc;\r\nint i;\r\nif (can_dropped_invalid_skb(ndev, skb))\r\nreturn NETDEV_TX_OK;\r\ntxst = readl(priv->base + IFI_CANFD_TXSTCMD);\r\nif (txst & IFI_CANFD_TXSTCMD_FULL) {\r\nnetif_stop_queue(ndev);\r\nnetdev_err(ndev, "BUG! TX FIFO full when queue awake!\n");\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nnetif_stop_queue(ndev);\r\nif (cf->can_id & CAN_EFF_FLAG) {\r\ntxid = cf->can_id & CAN_EFF_MASK;\r\ntxid = (txid >> IFI_CANFD_TXFIFO_ID_ID_XTD_WIDTH) |\r\n((txid & IFI_CANFD_TXFIFO_ID_ID_XTD_MASK) <<\r\nIFI_CANFD_TXFIFO_ID_ID_XTD_OFFSET);\r\ntxid |= IFI_CANFD_TXFIFO_ID_IDE;\r\n} else {\r\ntxid = cf->can_id & CAN_SFF_MASK;\r\n}\r\ntxdlc = can_len2dlc(cf->len);\r\nif ((priv->can.ctrlmode & CAN_CTRLMODE_FD) && can_is_canfd_skb(skb)) {\r\ntxdlc |= IFI_CANFD_TXFIFO_DLC_EDL;\r\nif (cf->flags & CANFD_BRS)\r\ntxdlc |= IFI_CANFD_TXFIFO_DLC_BRS;\r\n}\r\nif (cf->can_id & CAN_RTR_FLAG)\r\ntxdlc |= IFI_CANFD_TXFIFO_DLC_RTR;\r\nwritel(txid, priv->base + IFI_CANFD_TXFIFO_ID);\r\nwritel(txdlc, priv->base + IFI_CANFD_TXFIFO_DLC);\r\nfor (i = 0; i < cf->len; i += 4) {\r\nwritel(*(u32 *)(cf->data + i),\r\npriv->base + IFI_CANFD_TXFIFO_DATA + i);\r\n}\r\nwritel(0, priv->base + IFI_CANFD_TXFIFO_REPEATCOUNT);\r\nwritel(0, priv->base + IFI_CANFD_TXFIFO_SUSPEND_US);\r\ncan_put_echo_skb(skb, ndev, 0);\r\nwritel(IFI_CANFD_TXSTCMD_ADD_MSG, priv->base + IFI_CANFD_TXSTCMD);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int ifi_canfd_plat_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct net_device *ndev;\r\nstruct ifi_canfd_priv *priv;\r\nstruct resource *res;\r\nvoid __iomem *addr;\r\nint irq, ret;\r\nu32 id;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\naddr = devm_ioremap_resource(dev, res);\r\nirq = platform_get_irq(pdev, 0);\r\nif (IS_ERR(addr) || irq < 0)\r\nreturn -EINVAL;\r\nid = readl(addr + IFI_CANFD_IP_ID);\r\nif (id != IFI_CANFD_IP_ID_VALUE) {\r\ndev_err(dev, "This block is not IFI CANFD, id=%08x\n", id);\r\nreturn -EINVAL;\r\n}\r\nndev = alloc_candev(sizeof(*priv), 1);\r\nif (!ndev)\r\nreturn -ENOMEM;\r\nndev->irq = irq;\r\nndev->flags |= IFF_ECHO;\r\nndev->netdev_ops = &ifi_canfd_netdev_ops;\r\npriv = netdev_priv(ndev);\r\npriv->ndev = ndev;\r\npriv->base = addr;\r\nnetif_napi_add(ndev, &priv->napi, ifi_canfd_poll, 64);\r\npriv->can.state = CAN_STATE_STOPPED;\r\npriv->can.clock.freq = readl(addr + IFI_CANFD_CANCLOCK);\r\npriv->can.bittiming_const = &ifi_canfd_bittiming_const;\r\npriv->can.data_bittiming_const = &ifi_canfd_bittiming_const;\r\npriv->can.do_set_mode = ifi_canfd_set_mode;\r\npriv->can.do_get_berr_counter = ifi_canfd_get_berr_counter;\r\npriv->can.ctrlmode = CAN_CTRLMODE_FD;\r\npriv->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |\r\nCAN_CTRLMODE_LISTENONLY |\r\nCAN_CTRLMODE_FD |\r\nCAN_CTRLMODE_FD_NON_ISO |\r\nCAN_CTRLMODE_BERR_REPORTING;\r\nplatform_set_drvdata(pdev, ndev);\r\nSET_NETDEV_DEV(ndev, dev);\r\nret = register_candev(ndev);\r\nif (ret) {\r\ndev_err(dev, "Failed to register (ret=%d)\n", ret);\r\ngoto err_reg;\r\n}\r\ndevm_can_led_init(ndev);\r\ndev_info(dev, "Driver registered: regs=%p, irq=%d, clock=%d\n",\r\npriv->base, ndev->irq, priv->can.clock.freq);\r\nreturn 0;\r\nerr_reg:\r\nfree_candev(ndev);\r\nreturn ret;\r\n}\r\nstatic int ifi_canfd_plat_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nunregister_candev(ndev);\r\nplatform_set_drvdata(pdev, NULL);\r\nfree_candev(ndev);\r\nreturn 0;\r\n}
