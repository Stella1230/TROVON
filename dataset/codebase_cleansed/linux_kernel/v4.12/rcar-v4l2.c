const struct rvin_video_format *rvin_format_from_pixel(u32 pixelformat)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(rvin_formats); i++)\r\nif (rvin_formats[i].fourcc == pixelformat)\r\nreturn rvin_formats + i;\r\nreturn NULL;\r\n}\r\nstatic u32 rvin_format_bytesperline(struct v4l2_pix_format *pix)\r\n{\r\nconst struct rvin_video_format *fmt;\r\nfmt = rvin_format_from_pixel(pix->pixelformat);\r\nif (WARN_ON(!fmt))\r\nreturn -EINVAL;\r\nreturn pix->width * fmt->bpp;\r\n}\r\nstatic u32 rvin_format_sizeimage(struct v4l2_pix_format *pix)\r\n{\r\nif (pix->pixelformat == V4L2_PIX_FMT_NV16)\r\nreturn pix->bytesperline * pix->height * 2;\r\nreturn pix->bytesperline * pix->height;\r\n}\r\nstatic void rvin_reset_crop_compose(struct rvin_dev *vin)\r\n{\r\nvin->crop.top = vin->crop.left = 0;\r\nvin->crop.width = vin->source.width;\r\nvin->crop.height = vin->source.height;\r\nvin->compose.top = vin->compose.left = 0;\r\nvin->compose.width = vin->format.width;\r\nvin->compose.height = vin->format.height;\r\n}\r\nstatic int rvin_reset_format(struct rvin_dev *vin)\r\n{\r\nstruct v4l2_subdev_format fmt = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n};\r\nstruct v4l2_mbus_framefmt *mf = &fmt.format;\r\nint ret;\r\nfmt.pad = vin->src_pad_idx;\r\nret = v4l2_subdev_call(vin_to_source(vin), pad, get_fmt, NULL, &fmt);\r\nif (ret)\r\nreturn ret;\r\nvin->format.width = mf->width;\r\nvin->format.height = mf->height;\r\nvin->format.colorspace = mf->colorspace;\r\nvin->format.field = mf->field;\r\nif (vin->format.field == V4L2_FIELD_ALTERNATE &&\r\nv4l2_subdev_has_op(vin_to_source(vin), video, g_std))\r\nvin->format.field = V4L2_FIELD_INTERLACED;\r\nswitch (vin->format.field) {\r\ncase V4L2_FIELD_TOP:\r\ncase V4L2_FIELD_BOTTOM:\r\ncase V4L2_FIELD_ALTERNATE:\r\nvin->format.height /= 2;\r\nbreak;\r\ncase V4L2_FIELD_NONE:\r\ncase V4L2_FIELD_INTERLACED_TB:\r\ncase V4L2_FIELD_INTERLACED_BT:\r\ncase V4L2_FIELD_INTERLACED:\r\nbreak;\r\ndefault:\r\nvin->format.field = V4L2_FIELD_NONE;\r\nbreak;\r\n}\r\nrvin_reset_crop_compose(vin);\r\nreturn 0;\r\n}\r\nstatic int __rvin_try_format_source(struct rvin_dev *vin,\r\nu32 which,\r\nstruct v4l2_pix_format *pix,\r\nstruct rvin_source_fmt *source)\r\n{\r\nstruct v4l2_subdev *sd;\r\nstruct v4l2_subdev_pad_config *pad_cfg;\r\nstruct v4l2_subdev_format format = {\r\n.which = which,\r\n};\r\nenum v4l2_field field;\r\nint ret;\r\nsd = vin_to_source(vin);\r\nv4l2_fill_mbus_format(&format.format, pix, vin->digital.code);\r\npad_cfg = v4l2_subdev_alloc_pad_config(sd);\r\nif (pad_cfg == NULL)\r\nreturn -ENOMEM;\r\nformat.pad = vin->src_pad_idx;\r\nfield = pix->field;\r\nret = v4l2_subdev_call(sd, pad, set_fmt, pad_cfg, &format);\r\nif (ret < 0 && ret != -ENOIOCTLCMD)\r\ngoto done;\r\nv4l2_fill_pix_format(pix, &format.format);\r\npix->field = field;\r\nsource->width = pix->width;\r\nsource->height = pix->height;\r\nvin_dbg(vin, "Source resolution: %ux%u\n", source->width,\r\nsource->height);\r\ndone:\r\nv4l2_subdev_free_pad_config(pad_cfg);\r\nreturn ret;\r\n}\r\nstatic int __rvin_try_format(struct rvin_dev *vin,\r\nu32 which,\r\nstruct v4l2_pix_format *pix,\r\nstruct rvin_source_fmt *source)\r\n{\r\nconst struct rvin_video_format *info;\r\nu32 rwidth, rheight, walign;\r\nrwidth = pix->width;\r\nrheight = pix->height;\r\nif (pix->field == V4L2_FIELD_ANY)\r\npix->field = vin->format.field;\r\ninfo = rvin_format_from_pixel(pix->pixelformat);\r\nif (!info) {\r\nvin_dbg(vin, "Format %x not found, keeping %x\n",\r\npix->pixelformat, vin->format.pixelformat);\r\n*pix = vin->format;\r\npix->width = rwidth;\r\npix->height = rheight;\r\n}\r\npix->bytesperline = 0;\r\npix->sizeimage = 0;\r\n__rvin_try_format_source(vin, which, pix, source);\r\nswitch (pix->field) {\r\ncase V4L2_FIELD_TOP:\r\ncase V4L2_FIELD_BOTTOM:\r\ncase V4L2_FIELD_ALTERNATE:\r\npix->height /= 2;\r\nsource->height /= 2;\r\nbreak;\r\ncase V4L2_FIELD_NONE:\r\ncase V4L2_FIELD_INTERLACED_TB:\r\ncase V4L2_FIELD_INTERLACED_BT:\r\ncase V4L2_FIELD_INTERLACED:\r\nbreak;\r\ndefault:\r\npix->field = V4L2_FIELD_NONE;\r\nbreak;\r\n}\r\nif (source->width != rwidth || source->height != rheight)\r\nrvin_scale_try(vin, pix, rwidth, rheight);\r\nwalign = vin->format.pixelformat == V4L2_PIX_FMT_NV16 ? 5 : 1;\r\nv4l_bound_align_image(&pix->width, 2, RVIN_MAX_WIDTH, walign,\r\n&pix->height, 4, RVIN_MAX_HEIGHT, 2, 0);\r\npix->bytesperline = max_t(u32, pix->bytesperline,\r\nrvin_format_bytesperline(pix));\r\npix->sizeimage = max_t(u32, pix->sizeimage,\r\nrvin_format_sizeimage(pix));\r\nif (vin->chip == RCAR_M1 && pix->pixelformat == V4L2_PIX_FMT_XBGR32) {\r\nvin_err(vin, "pixel format XBGR32 not supported on M1\n");\r\nreturn -EINVAL;\r\n}\r\nvin_dbg(vin, "Requested %ux%u Got %ux%u bpl: %d size: %d\n",\r\nrwidth, rheight, pix->width, pix->height,\r\npix->bytesperline, pix->sizeimage);\r\nreturn 0;\r\n}\r\nstatic int rvin_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct rvin_dev *vin = video_drvdata(file);\r\nstrlcpy(cap->driver, KBUILD_MODNAME, sizeof(cap->driver));\r\nstrlcpy(cap->card, "R_Car_VIN", sizeof(cap->card));\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s",\r\ndev_name(vin->dev));\r\nreturn 0;\r\n}\r\nstatic int rvin_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct rvin_dev *vin = video_drvdata(file);\r\nstruct rvin_source_fmt source;\r\nreturn __rvin_try_format(vin, V4L2_SUBDEV_FORMAT_TRY, &f->fmt.pix,\r\n&source);\r\n}\r\nstatic int rvin_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct rvin_dev *vin = video_drvdata(file);\r\nstruct rvin_source_fmt source;\r\nint ret;\r\nif (vb2_is_busy(&vin->queue))\r\nreturn -EBUSY;\r\nret = __rvin_try_format(vin, V4L2_SUBDEV_FORMAT_ACTIVE, &f->fmt.pix,\r\n&source);\r\nif (ret)\r\nreturn ret;\r\nvin->source.width = source.width;\r\nvin->source.height = source.height;\r\nvin->format = f->fmt.pix;\r\nrvin_reset_crop_compose(vin);\r\nreturn 0;\r\n}\r\nstatic int rvin_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct rvin_dev *vin = video_drvdata(file);\r\nf->fmt.pix = vin->format;\r\nreturn 0;\r\n}\r\nstatic int rvin_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (f->index >= ARRAY_SIZE(rvin_formats))\r\nreturn -EINVAL;\r\nf->pixelformat = rvin_formats[f->index].fourcc;\r\nreturn 0;\r\n}\r\nstatic int rvin_g_selection(struct file *file, void *fh,\r\nstruct v4l2_selection *s)\r\n{\r\nstruct rvin_dev *vin = video_drvdata(file);\r\nif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nswitch (s->target) {\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\ncase V4L2_SEL_TGT_CROP_DEFAULT:\r\ns->r.left = s->r.top = 0;\r\ns->r.width = vin->source.width;\r\ns->r.height = vin->source.height;\r\nbreak;\r\ncase V4L2_SEL_TGT_CROP:\r\ns->r = vin->crop;\r\nbreak;\r\ncase V4L2_SEL_TGT_COMPOSE_BOUNDS:\r\ncase V4L2_SEL_TGT_COMPOSE_DEFAULT:\r\ns->r.left = s->r.top = 0;\r\ns->r.width = vin->format.width;\r\ns->r.height = vin->format.height;\r\nbreak;\r\ncase V4L2_SEL_TGT_COMPOSE:\r\ns->r = vin->compose;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rvin_s_selection(struct file *file, void *fh,\r\nstruct v4l2_selection *s)\r\n{\r\nstruct rvin_dev *vin = video_drvdata(file);\r\nconst struct rvin_video_format *fmt;\r\nstruct v4l2_rect r = s->r;\r\nstruct v4l2_rect max_rect;\r\nstruct v4l2_rect min_rect = {\r\n.width = 6,\r\n.height = 2,\r\n};\r\nif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nv4l2_rect_set_min_size(&r, &min_rect);\r\nswitch (s->target) {\r\ncase V4L2_SEL_TGT_CROP:\r\nmax_rect.top = max_rect.left = 0;\r\nmax_rect.width = vin->source.width;\r\nmax_rect.height = vin->source.height;\r\nv4l2_rect_map_inside(&r, &max_rect);\r\nv4l_bound_align_image(&r.width, 2, vin->source.width, 1,\r\n&r.height, 4, vin->source.height, 2, 0);\r\nr.top = clamp_t(s32, r.top, 0, vin->source.height - r.height);\r\nr.left = clamp_t(s32, r.left, 0, vin->source.width - r.width);\r\nvin->crop = s->r = r;\r\nvin_dbg(vin, "Cropped %dx%d@%d:%d of %dx%d\n",\r\nr.width, r.height, r.left, r.top,\r\nvin->source.width, vin->source.height);\r\nbreak;\r\ncase V4L2_SEL_TGT_COMPOSE:\r\nmax_rect.top = max_rect.left = 0;\r\nmax_rect.width = vin->format.width;\r\nmax_rect.height = vin->format.height;\r\nv4l2_rect_map_inside(&r, &max_rect);\r\nwhile ((r.top * vin->format.bytesperline) & HW_BUFFER_MASK)\r\nr.top--;\r\nfmt = rvin_format_from_pixel(vin->format.pixelformat);\r\nwhile ((r.left * fmt->bpp) & HW_BUFFER_MASK)\r\nr.left--;\r\nvin->compose = s->r = r;\r\nvin_dbg(vin, "Compose %dx%d@%d:%d in %dx%d\n",\r\nr.width, r.height, r.left, r.top,\r\nvin->format.width, vin->format.height);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nrvin_crop_scale_comp(vin);\r\nreturn 0;\r\n}\r\nstatic int rvin_cropcap(struct file *file, void *priv,\r\nstruct v4l2_cropcap *crop)\r\n{\r\nstruct rvin_dev *vin = video_drvdata(file);\r\nstruct v4l2_subdev *sd = vin_to_source(vin);\r\nif (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nreturn v4l2_subdev_call(sd, video, g_pixelaspect, &crop->pixelaspect);\r\n}\r\nstatic int rvin_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nstruct rvin_dev *vin = video_drvdata(file);\r\nstruct v4l2_subdev *sd = vin_to_source(vin);\r\nint ret;\r\nif (i->index != 0)\r\nreturn -EINVAL;\r\nret = v4l2_subdev_call(sd, video, g_input_status, &i->status);\r\nif (ret < 0 && ret != -ENOIOCTLCMD && ret != -ENODEV)\r\nreturn ret;\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\ni->std = vin->vdev.tvnorms;\r\nif (v4l2_subdev_has_op(sd, pad, dv_timings_cap))\r\ni->capabilities = V4L2_IN_CAP_DV_TIMINGS;\r\nstrlcpy(i->name, "Camera", sizeof(i->name));\r\nreturn 0;\r\n}\r\nstatic int rvin_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int rvin_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nif (i > 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int rvin_querystd(struct file *file, void *priv, v4l2_std_id *a)\r\n{\r\nstruct rvin_dev *vin = video_drvdata(file);\r\nstruct v4l2_subdev *sd = vin_to_source(vin);\r\nreturn v4l2_subdev_call(sd, video, querystd, a);\r\n}\r\nstatic int rvin_s_std(struct file *file, void *priv, v4l2_std_id a)\r\n{\r\nstruct rvin_dev *vin = video_drvdata(file);\r\nint ret;\r\nret = v4l2_subdev_call(vin_to_source(vin), video, s_std, a);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn rvin_reset_format(vin);\r\n}\r\nstatic int rvin_g_std(struct file *file, void *priv, v4l2_std_id *a)\r\n{\r\nstruct rvin_dev *vin = video_drvdata(file);\r\nstruct v4l2_subdev *sd = vin_to_source(vin);\r\nreturn v4l2_subdev_call(sd, video, g_std, a);\r\n}\r\nstatic int rvin_subscribe_event(struct v4l2_fh *fh,\r\nconst struct v4l2_event_subscription *sub)\r\n{\r\nswitch (sub->type) {\r\ncase V4L2_EVENT_SOURCE_CHANGE:\r\nreturn v4l2_event_subscribe(fh, sub, 4, NULL);\r\n}\r\nreturn v4l2_ctrl_subscribe_event(fh, sub);\r\n}\r\nstatic int rvin_enum_dv_timings(struct file *file, void *priv_fh,\r\nstruct v4l2_enum_dv_timings *timings)\r\n{\r\nstruct rvin_dev *vin = video_drvdata(file);\r\nstruct v4l2_subdev *sd = vin_to_source(vin);\r\nint pad, ret;\r\npad = timings->pad;\r\ntimings->pad = vin->sink_pad_idx;\r\nret = v4l2_subdev_call(sd, pad, enum_dv_timings, timings);\r\ntimings->pad = pad;\r\nreturn ret;\r\n}\r\nstatic int rvin_s_dv_timings(struct file *file, void *priv_fh,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct rvin_dev *vin = video_drvdata(file);\r\nstruct v4l2_subdev *sd = vin_to_source(vin);\r\nint ret;\r\nret = v4l2_subdev_call(sd, video, s_dv_timings, timings);\r\nif (ret)\r\nreturn ret;\r\nvin->source.width = timings->bt.width;\r\nvin->source.height = timings->bt.height;\r\nvin->format.width = timings->bt.width;\r\nvin->format.height = timings->bt.height;\r\nreturn 0;\r\n}\r\nstatic int rvin_g_dv_timings(struct file *file, void *priv_fh,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct rvin_dev *vin = video_drvdata(file);\r\nstruct v4l2_subdev *sd = vin_to_source(vin);\r\nreturn v4l2_subdev_call(sd, video, g_dv_timings, timings);\r\n}\r\nstatic int rvin_query_dv_timings(struct file *file, void *priv_fh,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct rvin_dev *vin = video_drvdata(file);\r\nstruct v4l2_subdev *sd = vin_to_source(vin);\r\nreturn v4l2_subdev_call(sd, video, query_dv_timings, timings);\r\n}\r\nstatic int rvin_dv_timings_cap(struct file *file, void *priv_fh,\r\nstruct v4l2_dv_timings_cap *cap)\r\n{\r\nstruct rvin_dev *vin = video_drvdata(file);\r\nstruct v4l2_subdev *sd = vin_to_source(vin);\r\nint pad, ret;\r\npad = cap->pad;\r\ncap->pad = vin->sink_pad_idx;\r\nret = v4l2_subdev_call(sd, pad, dv_timings_cap, cap);\r\ncap->pad = pad;\r\nreturn ret;\r\n}\r\nstatic int rvin_g_edid(struct file *file, void *fh, struct v4l2_edid *edid)\r\n{\r\nstruct rvin_dev *vin = video_drvdata(file);\r\nstruct v4l2_subdev *sd = vin_to_source(vin);\r\nint input, ret;\r\nif (edid->pad)\r\nreturn -EINVAL;\r\ninput = edid->pad;\r\nedid->pad = vin->sink_pad_idx;\r\nret = v4l2_subdev_call(sd, pad, get_edid, edid);\r\nedid->pad = input;\r\nreturn ret;\r\n}\r\nstatic int rvin_s_edid(struct file *file, void *fh, struct v4l2_edid *edid)\r\n{\r\nstruct rvin_dev *vin = video_drvdata(file);\r\nstruct v4l2_subdev *sd = vin_to_source(vin);\r\nint input, ret;\r\nif (edid->pad)\r\nreturn -EINVAL;\r\ninput = edid->pad;\r\nedid->pad = vin->sink_pad_idx;\r\nret = v4l2_subdev_call(sd, pad, set_edid, edid);\r\nedid->pad = input;\r\nreturn ret;\r\n}\r\nstatic int rvin_power_on(struct rvin_dev *vin)\r\n{\r\nint ret;\r\nstruct v4l2_subdev *sd = vin_to_source(vin);\r\npm_runtime_get_sync(vin->v4l2_dev.dev);\r\nret = v4l2_subdev_call(sd, core, s_power, 1);\r\nif (ret < 0 && ret != -ENOIOCTLCMD && ret != -ENODEV)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int rvin_power_off(struct rvin_dev *vin)\r\n{\r\nint ret;\r\nstruct v4l2_subdev *sd = vin_to_source(vin);\r\nret = v4l2_subdev_call(sd, core, s_power, 0);\r\npm_runtime_put(vin->v4l2_dev.dev);\r\nif (ret < 0 && ret != -ENOIOCTLCMD && ret != -ENODEV)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int rvin_initialize_device(struct file *file)\r\n{\r\nstruct rvin_dev *vin = video_drvdata(file);\r\nint ret;\r\nstruct v4l2_format f = {\r\n.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,\r\n.fmt.pix = {\r\n.width = vin->format.width,\r\n.height = vin->format.height,\r\n.field = vin->format.field,\r\n.colorspace = vin->format.colorspace,\r\n.pixelformat = vin->format.pixelformat,\r\n},\r\n};\r\nret = rvin_power_on(vin);\r\nif (ret < 0)\r\nreturn ret;\r\npm_runtime_enable(&vin->vdev.dev);\r\nret = pm_runtime_resume(&vin->vdev.dev);\r\nif (ret < 0 && ret != -ENOSYS)\r\ngoto eresume;\r\nret = rvin_s_fmt_vid_cap(file, NULL, &f);\r\nif (ret < 0)\r\ngoto esfmt;\r\nv4l2_ctrl_handler_setup(&vin->ctrl_handler);\r\nreturn 0;\r\nesfmt:\r\npm_runtime_disable(&vin->vdev.dev);\r\neresume:\r\nrvin_power_off(vin);\r\nreturn ret;\r\n}\r\nstatic int rvin_open(struct file *file)\r\n{\r\nstruct rvin_dev *vin = video_drvdata(file);\r\nint ret;\r\nmutex_lock(&vin->lock);\r\nfile->private_data = vin;\r\nret = v4l2_fh_open(file);\r\nif (ret)\r\ngoto unlock;\r\nif (!v4l2_fh_is_singular_file(file))\r\ngoto unlock;\r\nif (rvin_initialize_device(file)) {\r\nv4l2_fh_release(file);\r\nret = -ENODEV;\r\n}\r\nunlock:\r\nmutex_unlock(&vin->lock);\r\nreturn ret;\r\n}\r\nstatic int rvin_release(struct file *file)\r\n{\r\nstruct rvin_dev *vin = video_drvdata(file);\r\nbool fh_singular;\r\nint ret;\r\nmutex_lock(&vin->lock);\r\nfh_singular = v4l2_fh_is_singular_file(file);\r\nret = _vb2_fop_release(file, NULL);\r\nif (fh_singular) {\r\npm_runtime_suspend(&vin->vdev.dev);\r\npm_runtime_disable(&vin->vdev.dev);\r\nrvin_power_off(vin);\r\n}\r\nmutex_unlock(&vin->lock);\r\nreturn ret;\r\n}\r\nvoid rvin_v4l2_remove(struct rvin_dev *vin)\r\n{\r\nv4l2_info(&vin->v4l2_dev, "Removing %s\n",\r\nvideo_device_node_name(&vin->vdev));\r\nv4l2_ctrl_handler_free(&vin->ctrl_handler);\r\nvideo_unregister_device(&vin->vdev);\r\n}\r\nstatic void rvin_notify(struct v4l2_subdev *sd,\r\nunsigned int notification, void *arg)\r\n{\r\nstruct rvin_dev *vin =\r\ncontainer_of(sd->v4l2_dev, struct rvin_dev, v4l2_dev);\r\nswitch (notification) {\r\ncase V4L2_DEVICE_NOTIFY_EVENT:\r\nv4l2_event_queue(&vin->vdev, arg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nint rvin_v4l2_probe(struct rvin_dev *vin)\r\n{\r\nstruct video_device *vdev = &vin->vdev;\r\nstruct v4l2_subdev *sd = vin_to_source(vin);\r\nint pad_idx, ret;\r\nv4l2_set_subdev_hostdata(sd, vin);\r\nvin->v4l2_dev.notify = rvin_notify;\r\nret = v4l2_subdev_call(sd, video, g_tvnorms, &vin->vdev.tvnorms);\r\nif (ret < 0 && ret != -ENOIOCTLCMD && ret != -ENODEV)\r\nreturn ret;\r\nif (vin->vdev.tvnorms == 0) {\r\nv4l2_disable_ioctl(&vin->vdev, VIDIOC_G_STD);\r\nv4l2_disable_ioctl(&vin->vdev, VIDIOC_S_STD);\r\nv4l2_disable_ioctl(&vin->vdev, VIDIOC_QUERYSTD);\r\nv4l2_disable_ioctl(&vin->vdev, VIDIOC_ENUMSTD);\r\n}\r\nret = v4l2_ctrl_handler_init(&vin->ctrl_handler, 16);\r\nif (ret < 0)\r\nreturn ret;\r\nret = v4l2_ctrl_add_handler(&vin->ctrl_handler, sd->ctrl_handler, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nvdev->fops = &rvin_fops;\r\nvdev->v4l2_dev = &vin->v4l2_dev;\r\nvdev->queue = &vin->queue;\r\nstrlcpy(vdev->name, KBUILD_MODNAME, sizeof(vdev->name));\r\nvdev->release = video_device_release_empty;\r\nvdev->ioctl_ops = &rvin_ioctl_ops;\r\nvdev->lock = &vin->lock;\r\nvdev->ctrl_handler = &vin->ctrl_handler;\r\nvdev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING |\r\nV4L2_CAP_READWRITE;\r\nvin->src_pad_idx = 0;\r\nfor (pad_idx = 0; pad_idx < sd->entity.num_pads; pad_idx++)\r\nif (sd->entity.pads[pad_idx].flags == MEDIA_PAD_FL_SOURCE)\r\nbreak;\r\nif (pad_idx >= sd->entity.num_pads)\r\nreturn -EINVAL;\r\nvin->src_pad_idx = pad_idx;\r\nvin->sink_pad_idx = 0;\r\nfor (pad_idx = 0; pad_idx < sd->entity.num_pads; pad_idx++)\r\nif (sd->entity.pads[pad_idx].flags == MEDIA_PAD_FL_SINK) {\r\nvin->sink_pad_idx = pad_idx;\r\nbreak;\r\n}\r\nvin->format.pixelformat = RVIN_DEFAULT_FORMAT;\r\nrvin_reset_format(vin);\r\nret = video_register_device(&vin->vdev, VFL_TYPE_GRABBER, -1);\r\nif (ret) {\r\nvin_err(vin, "Failed to register video device\n");\r\nreturn ret;\r\n}\r\nvideo_set_drvdata(&vin->vdev, vin);\r\nv4l2_info(&vin->v4l2_dev, "Device registered as %s\n",\r\nvideo_device_node_name(&vin->vdev));\r\nreturn ret;\r\n}
