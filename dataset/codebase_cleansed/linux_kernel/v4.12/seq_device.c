static int snd_seq_bus_match(struct device *dev, struct device_driver *drv)\r\n{\r\nstruct snd_seq_device *sdev = to_seq_dev(dev);\r\nstruct snd_seq_driver *sdrv = to_seq_drv(drv);\r\nreturn strcmp(sdrv->id, sdev->id) == 0 &&\r\nsdrv->argsize == sdev->argsize;\r\n}\r\nstatic int print_dev_info(struct device *dev, void *data)\r\n{\r\nstruct snd_seq_device *sdev = to_seq_dev(dev);\r\nstruct snd_info_buffer *buffer = data;\r\nsnd_iprintf(buffer, "snd-%s,%s,%d\n", sdev->id,\r\ndev->driver ? "loaded" : "empty",\r\ndev->driver ? 1 : 0);\r\nreturn 0;\r\n}\r\nstatic void snd_seq_device_info(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nbus_for_each_dev(&snd_seq_bus_type, NULL, buffer, print_dev_info);\r\n}\r\nstatic int request_seq_drv(struct device *dev, void *data)\r\n{\r\nstruct snd_seq_device *sdev = to_seq_dev(dev);\r\nif (!dev->driver)\r\nrequest_module("snd-%s", sdev->id);\r\nreturn 0;\r\n}\r\nstatic void autoload_drivers(struct work_struct *work)\r\n{\r\nif (atomic_inc_return(&snd_seq_in_init) == 1)\r\nbus_for_each_dev(&snd_seq_bus_type, NULL, NULL,\r\nrequest_seq_drv);\r\natomic_dec(&snd_seq_in_init);\r\n}\r\nstatic void queue_autoload_drivers(void)\r\n{\r\nschedule_work(&autoload_work);\r\n}\r\nvoid snd_seq_autoload_init(void)\r\n{\r\natomic_dec(&snd_seq_in_init);\r\n#ifdef CONFIG_SND_SEQUENCER_MODULE\r\nqueue_autoload_drivers();\r\n#endif\r\n}\r\nvoid snd_seq_autoload_exit(void)\r\n{\r\natomic_inc(&snd_seq_in_init);\r\n}\r\nvoid snd_seq_device_load_drivers(void)\r\n{\r\nqueue_autoload_drivers();\r\nflush_work(&autoload_work);\r\n}\r\nstatic int snd_seq_device_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_seq_device *dev = device->device_data;\r\nput_device(&dev->dev);\r\nreturn 0;\r\n}\r\nstatic int snd_seq_device_dev_register(struct snd_device *device)\r\n{\r\nstruct snd_seq_device *dev = device->device_data;\r\nint err;\r\nerr = device_add(&dev->dev);\r\nif (err < 0)\r\nreturn err;\r\nif (!dev->dev.driver)\r\nqueue_autoload_drivers();\r\nreturn 0;\r\n}\r\nstatic int snd_seq_device_dev_disconnect(struct snd_device *device)\r\n{\r\nstruct snd_seq_device *dev = device->device_data;\r\ndevice_del(&dev->dev);\r\nreturn 0;\r\n}\r\nstatic void snd_seq_dev_release(struct device *dev)\r\n{\r\nstruct snd_seq_device *sdev = to_seq_dev(dev);\r\nif (sdev->private_free)\r\nsdev->private_free(sdev);\r\nkfree(sdev);\r\n}\r\nint snd_seq_device_new(struct snd_card *card, int device, const char *id,\r\nint argsize, struct snd_seq_device **result)\r\n{\r\nstruct snd_seq_device *dev;\r\nint err;\r\nstatic struct snd_device_ops dops = {\r\n.dev_free = snd_seq_device_dev_free,\r\n.dev_register = snd_seq_device_dev_register,\r\n.dev_disconnect = snd_seq_device_dev_disconnect,\r\n};\r\nif (result)\r\n*result = NULL;\r\nif (snd_BUG_ON(!id))\r\nreturn -EINVAL;\r\ndev = kzalloc(sizeof(*dev) + argsize, GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->card = card;\r\ndev->device = device;\r\ndev->id = id;\r\ndev->argsize = argsize;\r\ndevice_initialize(&dev->dev);\r\ndev->dev.parent = &card->card_dev;\r\ndev->dev.bus = &snd_seq_bus_type;\r\ndev->dev.release = snd_seq_dev_release;\r\ndev_set_name(&dev->dev, "%s-%d-%d", dev->id, card->number, device);\r\nerr = snd_device_new(card, SNDRV_DEV_SEQUENCER, dev, &dops);\r\nif (err < 0) {\r\nput_device(&dev->dev);\r\nreturn err;\r\n}\r\nif (result)\r\n*result = dev;\r\nreturn 0;\r\n}\r\nint __snd_seq_driver_register(struct snd_seq_driver *drv, struct module *mod)\r\n{\r\nif (WARN_ON(!drv->driver.name || !drv->id))\r\nreturn -EINVAL;\r\ndrv->driver.bus = &snd_seq_bus_type;\r\ndrv->driver.owner = mod;\r\nreturn driver_register(&drv->driver);\r\n}\r\nvoid snd_seq_driver_unregister(struct snd_seq_driver *drv)\r\n{\r\ndriver_unregister(&drv->driver);\r\n}\r\nstatic int __init seq_dev_proc_init(void)\r\n{\r\n#ifdef CONFIG_SND_PROC_FS\r\ninfo_entry = snd_info_create_module_entry(THIS_MODULE, "drivers",\r\nsnd_seq_root);\r\nif (info_entry == NULL)\r\nreturn -ENOMEM;\r\ninfo_entry->content = SNDRV_INFO_CONTENT_TEXT;\r\ninfo_entry->c.text.read = snd_seq_device_info;\r\nif (snd_info_register(info_entry) < 0) {\r\nsnd_info_free_entry(info_entry);\r\nreturn -ENOMEM;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int __init alsa_seq_device_init(void)\r\n{\r\nint err;\r\nerr = bus_register(&snd_seq_bus_type);\r\nif (err < 0)\r\nreturn err;\r\nerr = seq_dev_proc_init();\r\nif (err < 0)\r\nbus_unregister(&snd_seq_bus_type);\r\nreturn err;\r\n}\r\nstatic void __exit alsa_seq_device_exit(void)\r\n{\r\n#ifdef CONFIG_MODULES\r\ncancel_work_sync(&autoload_work);\r\n#endif\r\n#ifdef CONFIG_SND_PROC_FS\r\nsnd_info_free_entry(info_entry);\r\n#endif\r\nbus_unregister(&snd_seq_bus_type);\r\n}
