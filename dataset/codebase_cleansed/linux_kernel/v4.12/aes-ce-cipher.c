static int num_rounds(struct crypto_aes_ctx *ctx)\r\n{\r\nreturn 6 + ctx->key_length / 4;\r\n}\r\nstatic void aes_cipher_encrypt(struct crypto_tfm *tfm, u8 dst[], u8 const src[])\r\n{\r\nstruct crypto_aes_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct aes_block *out = (struct aes_block *)dst;\r\nstruct aes_block const *in = (struct aes_block *)src;\r\nvoid *dummy0;\r\nint dummy1;\r\nkernel_neon_begin_partial(4);\r\n__asm__(" ld1 {v0.16b}, %[in] ;"\r\n" ld1 {v1.16b}, [%[key]], #16 ;"\r\n" cmp %w[rounds], #10 ;"\r\n" bmi 0f ;"\r\n" bne 3f ;"\r\n" mov v3.16b, v1.16b ;"\r\n" b 2f ;"\r\n"0: mov v2.16b, v1.16b ;"\r\n" ld1 {v3.16b}, [%[key]], #16 ;"\r\n"1: aese v0.16b, v2.16b ;"\r\n" aesmc v0.16b, v0.16b ;"\r\n"2: ld1 {v1.16b}, [%[key]], #16 ;"\r\n" aese v0.16b, v3.16b ;"\r\n" aesmc v0.16b, v0.16b ;"\r\n"3: ld1 {v2.16b}, [%[key]], #16 ;"\r\n" subs %w[rounds], %w[rounds], #3 ;"\r\n" aese v0.16b, v1.16b ;"\r\n" aesmc v0.16b, v0.16b ;"\r\n" ld1 {v3.16b}, [%[key]], #16 ;"\r\n" bpl 1b ;"\r\n" aese v0.16b, v2.16b ;"\r\n" eor v0.16b, v0.16b, v3.16b ;"\r\n" st1 {v0.16b}, %[out] ;"\r\n: [out] "=Q"(*out),\r\n[key] "=r"(dummy0),\r\n[rounds] "=r"(dummy1)\r\n: [in] "Q"(*in),\r\n"1"(ctx->key_enc),\r\n"2"(num_rounds(ctx) - 2)\r\n: "cc");\r\nkernel_neon_end();\r\n}\r\nstatic void aes_cipher_decrypt(struct crypto_tfm *tfm, u8 dst[], u8 const src[])\r\n{\r\nstruct crypto_aes_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct aes_block *out = (struct aes_block *)dst;\r\nstruct aes_block const *in = (struct aes_block *)src;\r\nvoid *dummy0;\r\nint dummy1;\r\nkernel_neon_begin_partial(4);\r\n__asm__(" ld1 {v0.16b}, %[in] ;"\r\n" ld1 {v1.16b}, [%[key]], #16 ;"\r\n" cmp %w[rounds], #10 ;"\r\n" bmi 0f ;"\r\n" bne 3f ;"\r\n" mov v3.16b, v1.16b ;"\r\n" b 2f ;"\r\n"0: mov v2.16b, v1.16b ;"\r\n" ld1 {v3.16b}, [%[key]], #16 ;"\r\n"1: aesd v0.16b, v2.16b ;"\r\n" aesimc v0.16b, v0.16b ;"\r\n"2: ld1 {v1.16b}, [%[key]], #16 ;"\r\n" aesd v0.16b, v3.16b ;"\r\n" aesimc v0.16b, v0.16b ;"\r\n"3: ld1 {v2.16b}, [%[key]], #16 ;"\r\n" subs %w[rounds], %w[rounds], #3 ;"\r\n" aesd v0.16b, v1.16b ;"\r\n" aesimc v0.16b, v0.16b ;"\r\n" ld1 {v3.16b}, [%[key]], #16 ;"\r\n" bpl 1b ;"\r\n" aesd v0.16b, v2.16b ;"\r\n" eor v0.16b, v0.16b, v3.16b ;"\r\n" st1 {v0.16b}, %[out] ;"\r\n: [out] "=Q"(*out),\r\n[key] "=r"(dummy0),\r\n[rounds] "=r"(dummy1)\r\n: [in] "Q"(*in),\r\n"1"(ctx->key_dec),\r\n"2"(num_rounds(ctx) - 2)\r\n: "cc");\r\nkernel_neon_end();\r\n}\r\nstatic u32 aes_sub(u32 input)\r\n{\r\nu32 ret;\r\n__asm__("dup v1.4s, %w[in] ;"\r\n"movi v0.16b, #0 ;"\r\n"aese v0.16b, v1.16b ;"\r\n"umov %w[out], v0.4s[0] ;"\r\n: [out] "=r"(ret)\r\n: [in] "r"(input)\r\n: "v0","v1");\r\nreturn ret;\r\n}\r\nint ce_aes_expandkey(struct crypto_aes_ctx *ctx, const u8 *in_key,\r\nunsigned int key_len)\r\n{\r\nstatic u8 const rcon[] = {\r\n0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36,\r\n};\r\nu32 kwords = key_len / sizeof(u32);\r\nstruct aes_block *key_enc, *key_dec;\r\nint i, j;\r\nif (key_len != AES_KEYSIZE_128 &&\r\nkey_len != AES_KEYSIZE_192 &&\r\nkey_len != AES_KEYSIZE_256)\r\nreturn -EINVAL;\r\nmemcpy(ctx->key_enc, in_key, key_len);\r\nctx->key_length = key_len;\r\nkernel_neon_begin_partial(2);\r\nfor (i = 0; i < sizeof(rcon); i++) {\r\nu32 *rki = ctx->key_enc + (i * kwords);\r\nu32 *rko = rki + kwords;\r\n#ifndef CONFIG_CPU_BIG_ENDIAN\r\nrko[0] = ror32(aes_sub(rki[kwords - 1]), 8) ^ rcon[i] ^ rki[0];\r\n#else\r\nrko[0] = rol32(aes_sub(rki[kwords - 1]), 8) ^ (rcon[i] << 24) ^\r\nrki[0];\r\n#endif\r\nrko[1] = rko[0] ^ rki[1];\r\nrko[2] = rko[1] ^ rki[2];\r\nrko[3] = rko[2] ^ rki[3];\r\nif (key_len == AES_KEYSIZE_192) {\r\nif (i >= 7)\r\nbreak;\r\nrko[4] = rko[3] ^ rki[4];\r\nrko[5] = rko[4] ^ rki[5];\r\n} else if (key_len == AES_KEYSIZE_256) {\r\nif (i >= 6)\r\nbreak;\r\nrko[4] = aes_sub(rko[3]) ^ rki[4];\r\nrko[5] = rko[4] ^ rki[5];\r\nrko[6] = rko[5] ^ rki[6];\r\nrko[7] = rko[6] ^ rki[7];\r\n}\r\n}\r\nkey_enc = (struct aes_block *)ctx->key_enc;\r\nkey_dec = (struct aes_block *)ctx->key_dec;\r\nj = num_rounds(ctx);\r\nkey_dec[0] = key_enc[j];\r\nfor (i = 1, j--; j > 0; i++, j--)\r\n__asm__("ld1 {v0.16b}, %[in] ;"\r\n"aesimc v1.16b, v0.16b ;"\r\n"st1 {v1.16b}, %[out] ;"\r\n: [out] "=Q"(key_dec[i])\r\n: [in] "Q"(key_enc[j])\r\n: "v0","v1");\r\nkey_dec[i] = key_enc[0];\r\nkernel_neon_end();\r\nreturn 0;\r\n}\r\nint ce_aes_setkey(struct crypto_tfm *tfm, const u8 *in_key,\r\nunsigned int key_len)\r\n{\r\nstruct crypto_aes_ctx *ctx = crypto_tfm_ctx(tfm);\r\nint ret;\r\nret = ce_aes_expandkey(ctx, in_key, key_len);\r\nif (!ret)\r\nreturn 0;\r\ntfm->crt_flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;\r\nreturn -EINVAL;\r\n}\r\nstatic int __init aes_mod_init(void)\r\n{\r\nreturn crypto_register_alg(&aes_alg);\r\n}\r\nstatic void __exit aes_mod_exit(void)\r\n{\r\ncrypto_unregister_alg(&aes_alg);\r\n}
