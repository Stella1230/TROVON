static ssize_t bMaxPower_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_device *udev;\r\nstruct usb_host_config *actconfig;\r\nssize_t rc;\r\nudev = to_usb_device(dev);\r\nrc = usb_lock_device_interruptible(udev);\r\nif (rc < 0)\r\nreturn -EINTR;\r\nactconfig = udev->actconfig;\r\nif (actconfig)\r\nrc = sprintf(buf, "%dmA\n", usb_get_max_power(udev, actconfig));\r\nusb_unlock_device(udev);\r\nreturn rc;\r\n}\r\nstatic ssize_t configuration_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_device *udev;\r\nstruct usb_host_config *actconfig;\r\nssize_t rc;\r\nudev = to_usb_device(dev);\r\nrc = usb_lock_device_interruptible(udev);\r\nif (rc < 0)\r\nreturn -EINTR;\r\nactconfig = udev->actconfig;\r\nif (actconfig && actconfig->string)\r\nrc = sprintf(buf, "%s\n", actconfig->string);\r\nusb_unlock_device(udev);\r\nreturn rc;\r\n}\r\nstatic ssize_t bConfigurationValue_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_device *udev = to_usb_device(dev);\r\nint config, value, rc;\r\nif (sscanf(buf, "%d", &config) != 1 || config < -1 || config > 255)\r\nreturn -EINVAL;\r\nrc = usb_lock_device_interruptible(udev);\r\nif (rc < 0)\r\nreturn -EINTR;\r\nvalue = usb_set_configuration(udev, config);\r\nusb_unlock_device(udev);\r\nreturn (value < 0) ? value : count;\r\n}\r\nstatic ssize_t devspec_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct device_node *of_node = dev->of_node;\r\nreturn sprintf(buf, "%s\n", of_node_full_name(of_node));\r\n}\r\nstatic ssize_t speed_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_device *udev;\r\nchar *speed;\r\nudev = to_usb_device(dev);\r\nswitch (udev->speed) {\r\ncase USB_SPEED_LOW:\r\nspeed = "1.5";\r\nbreak;\r\ncase USB_SPEED_UNKNOWN:\r\ncase USB_SPEED_FULL:\r\nspeed = "12";\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\nspeed = "480";\r\nbreak;\r\ncase USB_SPEED_WIRELESS:\r\nspeed = "480";\r\nbreak;\r\ncase USB_SPEED_SUPER:\r\nspeed = "5000";\r\nbreak;\r\ncase USB_SPEED_SUPER_PLUS:\r\nspeed = "10000";\r\nbreak;\r\ndefault:\r\nspeed = "unknown";\r\n}\r\nreturn sprintf(buf, "%s\n", speed);\r\n}\r\nstatic ssize_t busnum_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_device *udev;\r\nudev = to_usb_device(dev);\r\nreturn sprintf(buf, "%d\n", udev->bus->busnum);\r\n}\r\nstatic ssize_t devnum_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_device *udev;\r\nudev = to_usb_device(dev);\r\nreturn sprintf(buf, "%d\n", udev->devnum);\r\n}\r\nstatic ssize_t devpath_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_device *udev;\r\nudev = to_usb_device(dev);\r\nreturn sprintf(buf, "%s\n", udev->devpath);\r\n}\r\nstatic ssize_t version_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_device *udev;\r\nu16 bcdUSB;\r\nudev = to_usb_device(dev);\r\nbcdUSB = le16_to_cpu(udev->descriptor.bcdUSB);\r\nreturn sprintf(buf, "%2x.%02x\n", bcdUSB >> 8, bcdUSB & 0xff);\r\n}\r\nstatic ssize_t maxchild_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_device *udev;\r\nudev = to_usb_device(dev);\r\nreturn sprintf(buf, "%d\n", udev->maxchild);\r\n}\r\nstatic ssize_t quirks_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_device *udev;\r\nudev = to_usb_device(dev);\r\nreturn sprintf(buf, "0x%x\n", udev->quirks);\r\n}\r\nstatic ssize_t avoid_reset_quirk_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_device *udev;\r\nudev = to_usb_device(dev);\r\nreturn sprintf(buf, "%d\n", !!(udev->quirks & USB_QUIRK_RESET));\r\n}\r\nstatic ssize_t avoid_reset_quirk_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_device *udev = to_usb_device(dev);\r\nint val, rc;\r\nif (sscanf(buf, "%d", &val) != 1 || val < 0 || val > 1)\r\nreturn -EINVAL;\r\nrc = usb_lock_device_interruptible(udev);\r\nif (rc < 0)\r\nreturn -EINTR;\r\nif (val)\r\nudev->quirks |= USB_QUIRK_RESET;\r\nelse\r\nudev->quirks &= ~USB_QUIRK_RESET;\r\nusb_unlock_device(udev);\r\nreturn count;\r\n}\r\nstatic ssize_t urbnum_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_device *udev;\r\nudev = to_usb_device(dev);\r\nreturn sprintf(buf, "%d\n", atomic_read(&udev->urbnum));\r\n}\r\nstatic ssize_t removable_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_device *udev;\r\nchar *state;\r\nudev = to_usb_device(dev);\r\nswitch (udev->removable) {\r\ncase USB_DEVICE_REMOVABLE:\r\nstate = "removable";\r\nbreak;\r\ncase USB_DEVICE_FIXED:\r\nstate = "fixed";\r\nbreak;\r\ndefault:\r\nstate = "unknown";\r\n}\r\nreturn sprintf(buf, "%s\n", state);\r\n}\r\nstatic ssize_t ltm_capable_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nif (usb_device_supports_ltm(to_usb_device(dev)))\r\nreturn sprintf(buf, "%s\n", "yes");\r\nreturn sprintf(buf, "%s\n", "no");\r\n}\r\nstatic ssize_t persist_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_device *udev = to_usb_device(dev);\r\nreturn sprintf(buf, "%d\n", udev->persist_enabled);\r\n}\r\nstatic ssize_t persist_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_device *udev = to_usb_device(dev);\r\nint value, rc;\r\nif (udev->descriptor.bDeviceClass == USB_CLASS_HUB)\r\nreturn -EPERM;\r\nif (sscanf(buf, "%d", &value) != 1)\r\nreturn -EINVAL;\r\nrc = usb_lock_device_interruptible(udev);\r\nif (rc < 0)\r\nreturn -EINTR;\r\nudev->persist_enabled = !!value;\r\nusb_unlock_device(udev);\r\nreturn count;\r\n}\r\nstatic int add_persist_attributes(struct device *dev)\r\n{\r\nint rc = 0;\r\nif (is_usb_device(dev)) {\r\nstruct usb_device *udev = to_usb_device(dev);\r\nif (udev->descriptor.bDeviceClass != USB_CLASS_HUB)\r\nrc = sysfs_add_file_to_group(&dev->kobj,\r\n&dev_attr_persist.attr,\r\npower_group_name);\r\n}\r\nreturn rc;\r\n}\r\nstatic void remove_persist_attributes(struct device *dev)\r\n{\r\nsysfs_remove_file_from_group(&dev->kobj,\r\n&dev_attr_persist.attr,\r\npower_group_name);\r\n}\r\nstatic ssize_t connected_duration_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_device *udev = to_usb_device(dev);\r\nreturn sprintf(buf, "%u\n",\r\njiffies_to_msecs(jiffies - udev->connect_time));\r\n}\r\nstatic ssize_t active_duration_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_device *udev = to_usb_device(dev);\r\nint duration;\r\nif (udev->state != USB_STATE_SUSPENDED)\r\nduration = jiffies_to_msecs(jiffies + udev->active_duration);\r\nelse\r\nduration = jiffies_to_msecs(udev->active_duration);\r\nreturn sprintf(buf, "%u\n", duration);\r\n}\r\nstatic ssize_t autosuspend_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", dev->power.autosuspend_delay / 1000);\r\n}\r\nstatic ssize_t autosuspend_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nint value;\r\nif (sscanf(buf, "%d", &value) != 1 || value >= INT_MAX/1000 ||\r\nvalue <= -INT_MAX/1000)\r\nreturn -EINVAL;\r\npm_runtime_set_autosuspend_delay(dev, value * 1000);\r\nreturn count;\r\n}\r\nstatic void warn_level(void)\r\n{\r\nstatic int level_warned;\r\nif (!level_warned) {\r\nlevel_warned = 1;\r\nprintk(KERN_WARNING "WARNING! power/level is deprecated; "\r\n"use power/control instead\n");\r\n}\r\n}\r\nstatic ssize_t level_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_device *udev = to_usb_device(dev);\r\nconst char *p = auto_string;\r\nwarn_level();\r\nif (udev->state != USB_STATE_SUSPENDED && !udev->dev.power.runtime_auto)\r\np = on_string;\r\nreturn sprintf(buf, "%s\n", p);\r\n}\r\nstatic ssize_t level_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_device *udev = to_usb_device(dev);\r\nint len = count;\r\nchar *cp;\r\nint rc = count;\r\nint rv;\r\nwarn_level();\r\ncp = memchr(buf, '\n', count);\r\nif (cp)\r\nlen = cp - buf;\r\nrv = usb_lock_device_interruptible(udev);\r\nif (rv < 0)\r\nreturn -EINTR;\r\nif (len == sizeof on_string - 1 &&\r\nstrncmp(buf, on_string, len) == 0)\r\nusb_disable_autosuspend(udev);\r\nelse if (len == sizeof auto_string - 1 &&\r\nstrncmp(buf, auto_string, len) == 0)\r\nusb_enable_autosuspend(udev);\r\nelse\r\nrc = -EINVAL;\r\nusb_unlock_device(udev);\r\nreturn rc;\r\n}\r\nstatic ssize_t usb2_hardware_lpm_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_device *udev = to_usb_device(dev);\r\nconst char *p;\r\nif (udev->usb2_hw_lpm_allowed == 1)\r\np = "enabled";\r\nelse\r\np = "disabled";\r\nreturn sprintf(buf, "%s\n", p);\r\n}\r\nstatic ssize_t usb2_hardware_lpm_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_device *udev = to_usb_device(dev);\r\nbool value;\r\nint ret;\r\nret = usb_lock_device_interruptible(udev);\r\nif (ret < 0)\r\nreturn -EINTR;\r\nret = strtobool(buf, &value);\r\nif (!ret) {\r\nudev->usb2_hw_lpm_allowed = value;\r\nret = usb_set_usb2_hardware_lpm(udev, value);\r\n}\r\nusb_unlock_device(udev);\r\nif (!ret)\r\nreturn count;\r\nreturn ret;\r\n}\r\nstatic ssize_t usb2_lpm_l1_timeout_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_device *udev = to_usb_device(dev);\r\nreturn sprintf(buf, "%d\n", udev->l1_params.timeout);\r\n}\r\nstatic ssize_t usb2_lpm_l1_timeout_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_device *udev = to_usb_device(dev);\r\nu16 timeout;\r\nif (kstrtou16(buf, 0, &timeout))\r\nreturn -EINVAL;\r\nudev->l1_params.timeout = timeout;\r\nreturn count;\r\n}\r\nstatic ssize_t usb2_lpm_besl_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_device *udev = to_usb_device(dev);\r\nreturn sprintf(buf, "%d\n", udev->l1_params.besl);\r\n}\r\nstatic ssize_t usb2_lpm_besl_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_device *udev = to_usb_device(dev);\r\nu8 besl;\r\nif (kstrtou8(buf, 0, &besl) || besl > 15)\r\nreturn -EINVAL;\r\nudev->l1_params.besl = besl;\r\nreturn count;\r\n}\r\nstatic ssize_t usb3_hardware_lpm_u1_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_device *udev = to_usb_device(dev);\r\nconst char *p;\r\nint rc;\r\nrc = usb_lock_device_interruptible(udev);\r\nif (rc < 0)\r\nreturn -EINTR;\r\nif (udev->usb3_lpm_u1_enabled)\r\np = "enabled";\r\nelse\r\np = "disabled";\r\nusb_unlock_device(udev);\r\nreturn sprintf(buf, "%s\n", p);\r\n}\r\nstatic ssize_t usb3_hardware_lpm_u2_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_device *udev = to_usb_device(dev);\r\nconst char *p;\r\nint rc;\r\nrc = usb_lock_device_interruptible(udev);\r\nif (rc < 0)\r\nreturn -EINTR;\r\nif (udev->usb3_lpm_u2_enabled)\r\np = "enabled";\r\nelse\r\np = "disabled";\r\nusb_unlock_device(udev);\r\nreturn sprintf(buf, "%s\n", p);\r\n}\r\nstatic int add_power_attributes(struct device *dev)\r\n{\r\nint rc = 0;\r\nif (is_usb_device(dev)) {\r\nstruct usb_device *udev = to_usb_device(dev);\r\nrc = sysfs_merge_group(&dev->kobj, &power_attr_group);\r\nif (udev->usb2_hw_lpm_capable == 1)\r\nrc = sysfs_merge_group(&dev->kobj,\r\n&usb2_hardware_lpm_attr_group);\r\nif (udev->speed == USB_SPEED_SUPER &&\r\nudev->lpm_capable == 1)\r\nrc = sysfs_merge_group(&dev->kobj,\r\n&usb3_hardware_lpm_attr_group);\r\n}\r\nreturn rc;\r\n}\r\nstatic void remove_power_attributes(struct device *dev)\r\n{\r\nsysfs_unmerge_group(&dev->kobj, &usb2_hardware_lpm_attr_group);\r\nsysfs_unmerge_group(&dev->kobj, &power_attr_group);\r\n}\r\nstatic ssize_t authorized_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_device *usb_dev = to_usb_device(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", usb_dev->authorized);\r\n}\r\nstatic ssize_t authorized_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t size)\r\n{\r\nssize_t result;\r\nstruct usb_device *usb_dev = to_usb_device(dev);\r\nunsigned val;\r\nresult = sscanf(buf, "%u\n", &val);\r\nif (result != 1)\r\nresult = -EINVAL;\r\nelse if (val == 0)\r\nresult = usb_deauthorize_device(usb_dev);\r\nelse\r\nresult = usb_authorize_device(usb_dev);\r\nreturn result < 0 ? result : size;\r\n}\r\nstatic ssize_t remove_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_device *udev = to_usb_device(dev);\r\nint rc = 0;\r\nusb_lock_device(udev);\r\nif (udev->state != USB_STATE_NOTATTACHED) {\r\nusb_set_configuration(udev, -1);\r\nrc = usb_remove_device(udev);\r\n}\r\nif (rc == 0)\r\nrc = count;\r\nusb_unlock_device(udev);\r\nreturn rc;\r\n}\r\nstatic umode_t dev_string_attrs_are_visible(struct kobject *kobj,\r\nstruct attribute *a, int n)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct usb_device *udev = to_usb_device(dev);\r\nif (a == &dev_attr_manufacturer.attr) {\r\nif (udev->manufacturer == NULL)\r\nreturn 0;\r\n} else if (a == &dev_attr_product.attr) {\r\nif (udev->product == NULL)\r\nreturn 0;\r\n} else if (a == &dev_attr_serial.attr) {\r\nif (udev->serial == NULL)\r\nreturn 0;\r\n}\r\nreturn a->mode;\r\n}\r\nstatic ssize_t\r\nread_descriptors(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct usb_device *udev = to_usb_device(dev);\r\nsize_t nleft = count;\r\nsize_t srclen, n;\r\nint cfgno;\r\nvoid *src;\r\nfor (cfgno = -1; cfgno < udev->descriptor.bNumConfigurations &&\r\nnleft > 0; ++cfgno) {\r\nif (cfgno < 0) {\r\nsrc = &udev->descriptor;\r\nsrclen = sizeof(struct usb_device_descriptor);\r\n} else {\r\nsrc = udev->rawdescriptors[cfgno];\r\nsrclen = __le16_to_cpu(udev->config[cfgno].desc.\r\nwTotalLength);\r\n}\r\nif (off < srclen) {\r\nn = min(nleft, srclen - (size_t) off);\r\nmemcpy(buf, src + off, n);\r\nnleft -= n;\r\nbuf += n;\r\noff = 0;\r\n} else {\r\noff -= srclen;\r\n}\r\n}\r\nreturn count - nleft;\r\n}\r\nint usb_create_sysfs_dev_files(struct usb_device *udev)\r\n{\r\nstruct device *dev = &udev->dev;\r\nint retval;\r\nretval = device_create_bin_file(dev, &dev_bin_attr_descriptors);\r\nif (retval)\r\ngoto error;\r\nretval = add_persist_attributes(dev);\r\nif (retval)\r\ngoto error;\r\nretval = add_power_attributes(dev);\r\nif (retval)\r\ngoto error;\r\nreturn retval;\r\nerror:\r\nusb_remove_sysfs_dev_files(udev);\r\nreturn retval;\r\n}\r\nvoid usb_remove_sysfs_dev_files(struct usb_device *udev)\r\n{\r\nstruct device *dev = &udev->dev;\r\nremove_power_attributes(dev);\r\nremove_persist_attributes(dev);\r\ndevice_remove_bin_file(dev, &dev_bin_attr_descriptors);\r\n}\r\nstatic ssize_t interface_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_interface *intf;\r\nchar *string;\r\nintf = to_usb_interface(dev);\r\nstring = ACCESS_ONCE(intf->cur_altsetting->string);\r\nif (!string)\r\nreturn 0;\r\nreturn sprintf(buf, "%s\n", string);\r\n}\r\nstatic ssize_t modalias_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_interface *intf;\r\nstruct usb_device *udev;\r\nstruct usb_host_interface *alt;\r\nintf = to_usb_interface(dev);\r\nudev = interface_to_usbdev(intf);\r\nalt = ACCESS_ONCE(intf->cur_altsetting);\r\nreturn sprintf(buf, "usb:v%04Xp%04Xd%04Xdc%02Xdsc%02Xdp%02X"\r\n"ic%02Xisc%02Xip%02Xin%02X\n",\r\nle16_to_cpu(udev->descriptor.idVendor),\r\nle16_to_cpu(udev->descriptor.idProduct),\r\nle16_to_cpu(udev->descriptor.bcdDevice),\r\nudev->descriptor.bDeviceClass,\r\nudev->descriptor.bDeviceSubClass,\r\nudev->descriptor.bDeviceProtocol,\r\nalt->desc.bInterfaceClass,\r\nalt->desc.bInterfaceSubClass,\r\nalt->desc.bInterfaceProtocol,\r\nalt->desc.bInterfaceNumber);\r\n}\r\nstatic ssize_t supports_autosuspend_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint s;\r\ns = device_lock_interruptible(dev);\r\nif (s < 0)\r\nreturn -EINTR;\r\ns = (!dev->driver || to_usb_driver(dev->driver)->supports_autosuspend);\r\ndevice_unlock(dev);\r\nreturn sprintf(buf, "%u\n", s);\r\n}\r\nstatic ssize_t interface_authorized_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nreturn sprintf(buf, "%u\n", intf->authorized);\r\n}\r\nstatic ssize_t interface_authorized_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nbool val;\r\nif (strtobool(buf, &val) != 0)\r\nreturn -EINVAL;\r\nif (val)\r\nusb_authorize_interface(intf);\r\nelse\r\nusb_deauthorize_interface(intf);\r\nreturn count;\r\n}\r\nstatic umode_t intf_assoc_attrs_are_visible(struct kobject *kobj,\r\nstruct attribute *a, int n)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nif (intf->intf_assoc == NULL)\r\nreturn 0;\r\nreturn a->mode;\r\n}\r\nvoid usb_create_sysfs_intf_files(struct usb_interface *intf)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct usb_host_interface *alt = intf->cur_altsetting;\r\nif (intf->sysfs_files_created || intf->unregistering)\r\nreturn;\r\nif (!alt->string && !(udev->quirks & USB_QUIRK_CONFIG_INTF_STRINGS))\r\nalt->string = usb_cache_string(udev, alt->desc.iInterface);\r\nif (alt->string && device_create_file(&intf->dev, &dev_attr_interface))\r\n;\r\nintf->sysfs_files_created = 1;\r\n}\r\nvoid usb_remove_sysfs_intf_files(struct usb_interface *intf)\r\n{\r\nif (!intf->sysfs_files_created)\r\nreturn;\r\ndevice_remove_file(&intf->dev, &dev_attr_interface);\r\nintf->sysfs_files_created = 0;\r\n}
