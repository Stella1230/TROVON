static void completion_pages(struct work_struct *work)\r\n{\r\nstruct fscrypt_ctx *ctx =\r\ncontainer_of(work, struct fscrypt_ctx, r.work);\r\nstruct bio *bio = ctx->r.bio;\r\nstruct bio_vec *bv;\r\nint i;\r\nbio_for_each_segment_all(bv, bio, i) {\r\nstruct page *page = bv->bv_page;\r\nint ret = fscrypt_decrypt_page(page->mapping->host, page,\r\nPAGE_SIZE, 0, page->index);\r\nif (ret) {\r\nWARN_ON_ONCE(1);\r\nSetPageError(page);\r\n} else {\r\nSetPageUptodate(page);\r\n}\r\nunlock_page(page);\r\n}\r\nfscrypt_release_ctx(ctx);\r\nbio_put(bio);\r\n}\r\nvoid fscrypt_decrypt_bio_pages(struct fscrypt_ctx *ctx, struct bio *bio)\r\n{\r\nINIT_WORK(&ctx->r.work, completion_pages);\r\nctx->r.bio = bio;\r\nqueue_work(fscrypt_read_workqueue, &ctx->r.work);\r\n}\r\nvoid fscrypt_pullback_bio_page(struct page **page, bool restore)\r\n{\r\nstruct fscrypt_ctx *ctx;\r\nstruct page *bounce_page;\r\nif ((*page)->mapping)\r\nreturn;\r\nbounce_page = *page;\r\nctx = (struct fscrypt_ctx *)page_private(bounce_page);\r\n*page = ctx->w.control_page;\r\nif (restore)\r\nfscrypt_restore_control_page(bounce_page);\r\n}\r\nint fscrypt_zeroout_range(const struct inode *inode, pgoff_t lblk,\r\nsector_t pblk, unsigned int len)\r\n{\r\nstruct fscrypt_ctx *ctx;\r\nstruct page *ciphertext_page = NULL;\r\nstruct bio *bio;\r\nint ret, err = 0;\r\nBUG_ON(inode->i_sb->s_blocksize != PAGE_SIZE);\r\nctx = fscrypt_get_ctx(inode, GFP_NOFS);\r\nif (IS_ERR(ctx))\r\nreturn PTR_ERR(ctx);\r\nciphertext_page = fscrypt_alloc_bounce_page(ctx, GFP_NOWAIT);\r\nif (IS_ERR(ciphertext_page)) {\r\nerr = PTR_ERR(ciphertext_page);\r\ngoto errout;\r\n}\r\nwhile (len--) {\r\nerr = fscrypt_do_page_crypto(inode, FS_ENCRYPT, lblk,\r\nZERO_PAGE(0), ciphertext_page,\r\nPAGE_SIZE, 0, GFP_NOFS);\r\nif (err)\r\ngoto errout;\r\nbio = bio_alloc(GFP_NOWAIT, 1);\r\nif (!bio) {\r\nerr = -ENOMEM;\r\ngoto errout;\r\n}\r\nbio->bi_bdev = inode->i_sb->s_bdev;\r\nbio->bi_iter.bi_sector =\r\npblk << (inode->i_sb->s_blocksize_bits - 9);\r\nbio_set_op_attrs(bio, REQ_OP_WRITE, 0);\r\nret = bio_add_page(bio, ciphertext_page,\r\ninode->i_sb->s_blocksize, 0);\r\nif (ret != inode->i_sb->s_blocksize) {\r\nWARN_ON(1);\r\nbio_put(bio);\r\nerr = -EIO;\r\ngoto errout;\r\n}\r\nerr = submit_bio_wait(bio);\r\nif ((err == 0) && bio->bi_error)\r\nerr = -EIO;\r\nbio_put(bio);\r\nif (err)\r\ngoto errout;\r\nlblk++;\r\npblk++;\r\n}\r\nerr = 0;\r\nerrout:\r\nfscrypt_release_ctx(ctx);\r\nreturn err;\r\n}
