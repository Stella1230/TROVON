static inline struct stmpe_pwm *to_stmpe_pwm(struct pwm_chip *chip)\r\n{\r\nreturn container_of(chip, struct stmpe_pwm, chip);\r\n}\r\nstatic int stmpe_24xx_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct stmpe_pwm *stmpe_pwm = to_stmpe_pwm(chip);\r\nu8 value;\r\nint ret;\r\nret = stmpe_reg_read(stmpe_pwm->stmpe, STMPE24XX_PWMCS);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "error reading PWM#%u control\n",\r\npwm->hwpwm);\r\nreturn ret;\r\n}\r\nvalue = ret | BIT(pwm->hwpwm);\r\nret = stmpe_reg_write(stmpe_pwm->stmpe, STMPE24XX_PWMCS, value);\r\nif (ret) {\r\ndev_err(chip->dev, "error writing PWM#%u control\n",\r\npwm->hwpwm);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void stmpe_24xx_pwm_disable(struct pwm_chip *chip,\r\nstruct pwm_device *pwm)\r\n{\r\nstruct stmpe_pwm *stmpe_pwm = to_stmpe_pwm(chip);\r\nu8 value;\r\nint ret;\r\nret = stmpe_reg_read(stmpe_pwm->stmpe, STMPE24XX_PWMCS);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "error reading PWM#%u control\n",\r\npwm->hwpwm);\r\nreturn;\r\n}\r\nvalue = ret & ~BIT(pwm->hwpwm);\r\nret = stmpe_reg_write(stmpe_pwm->stmpe, STMPE24XX_PWMCS, value);\r\nif (ret) {\r\ndev_err(chip->dev, "error writing PWM#%u control\n",\r\npwm->hwpwm);\r\nreturn;\r\n}\r\n}\r\nstatic int stmpe_24xx_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\r\nint duty_ns, int period_ns)\r\n{\r\nstruct stmpe_pwm *stmpe_pwm = to_stmpe_pwm(chip);\r\nunsigned int i, pin;\r\nu16 program[3] = {\r\nSMAX,\r\nGTS,\r\nGTS,\r\n};\r\nu8 offset;\r\nint ret;\r\nif (pwm_is_enabled(pwm)) {\r\nstmpe_24xx_pwm_disable(chip, pwm);\r\n} else {\r\npin = pwm->hwpwm;\r\nif (stmpe_pwm->stmpe->partnum == STMPE2401 ||\r\nstmpe_pwm->stmpe->partnum == STMPE2403)\r\npin += STMPE_PWM_24XX_PINBASE;\r\nret = stmpe_set_altfunc(stmpe_pwm->stmpe, BIT(pin),\r\nSTMPE_BLOCK_PWM);\r\nif (ret) {\r\ndev_err(chip->dev, "unable to connect PWM#%u to pin\n",\r\npwm->hwpwm);\r\nreturn ret;\r\n}\r\n}\r\nswitch (pwm->hwpwm) {\r\ncase 0:\r\noffset = STMPE24XX_PWMIC0;\r\nbreak;\r\ncase 1:\r\noffset = STMPE24XX_PWMIC1;\r\nbreak;\r\ncase 2:\r\noffset = STMPE24XX_PWMIC1;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\ndev_dbg(chip->dev, "PWM#%u: config duty %d ns, period %d ns\n",\r\npwm->hwpwm, duty_ns, period_ns);\r\nif (duty_ns == 0) {\r\nif (stmpe_pwm->stmpe->partnum == STMPE2401)\r\nprogram[0] = SMAX;\r\nif (stmpe_pwm->stmpe->partnum == STMPE2403)\r\nprogram[0] = LOAD | 0xff;\r\nstmpe_pwm->last_duty = 0x00;\r\n} else if (duty_ns == period_ns) {\r\nif (stmpe_pwm->stmpe->partnum == STMPE2401)\r\nprogram[0] = SMIN;\r\nif (stmpe_pwm->stmpe->partnum == STMPE2403)\r\nprogram[0] = LOAD | 0x00;\r\nstmpe_pwm->last_duty = 0xff;\r\n} else {\r\nu8 value, last = stmpe_pwm->last_duty;\r\nunsigned long duty;\r\nduty = duty_ns * 256;\r\nduty = DIV_ROUND_CLOSEST(duty, period_ns);\r\nvalue = duty;\r\nif (value == last) {\r\nif (pwm_is_enabled(pwm))\r\nstmpe_24xx_pwm_enable(chip, pwm);\r\nreturn 0;\r\n} else if (stmpe_pwm->stmpe->partnum == STMPE2403) {\r\nprogram[0] = LOAD | value;\r\nprogram[1] = 0x0000;\r\n} else if (stmpe_pwm->stmpe->partnum == STMPE2401) {\r\nu16 incdec = 0x0000;\r\nif (last < value)\r\nincdec = RAMPUP | (value - last);\r\nelse\r\nincdec = RAMPDOWN | (last - value);\r\nprogram[0] = PRESCALE_512 | STEPTIME_1 | incdec;\r\nprogram[1] = BRANCH;\r\n}\r\ndev_dbg(chip->dev,\r\n"PWM#%u: value = %02x, last_duty = %02x, program=%04x,%04x,%04x\n",\r\npwm->hwpwm, value, last, program[0], program[1],\r\nprogram[2]);\r\nstmpe_pwm->last_duty = value;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(program); i++) {\r\nu8 value;\r\nvalue = (program[i] >> 8) & 0xff;\r\nret = stmpe_reg_write(stmpe_pwm->stmpe, offset, value);\r\nif (ret) {\r\ndev_err(chip->dev, "error writing register %02x: %d\n",\r\noffset, ret);\r\nreturn ret;\r\n}\r\nvalue = program[i] & 0xff;\r\nret = stmpe_reg_write(stmpe_pwm->stmpe, offset, value);\r\nif (ret) {\r\ndev_err(chip->dev, "error writing register %02x: %d\n",\r\noffset, ret);\r\nreturn ret;\r\n}\r\n}\r\nif (pwm_is_enabled(pwm))\r\nstmpe_24xx_pwm_enable(chip, pwm);\r\nmsleep(200);\r\ndev_dbg(chip->dev, "programmed PWM#%u, %u bytes\n", pwm->hwpwm, i);\r\nreturn 0;\r\n}\r\nstatic int __init stmpe_pwm_probe(struct platform_device *pdev)\r\n{\r\nstruct stmpe *stmpe = dev_get_drvdata(pdev->dev.parent);\r\nstruct stmpe_pwm *pwm;\r\nint ret;\r\npwm = devm_kzalloc(&pdev->dev, sizeof(*pwm), GFP_KERNEL);\r\nif (!pwm)\r\nreturn -ENOMEM;\r\npwm->stmpe = stmpe;\r\npwm->chip.dev = &pdev->dev;\r\npwm->chip.base = -1;\r\nif (stmpe->partnum == STMPE2401 || stmpe->partnum == STMPE2403) {\r\npwm->chip.ops = &stmpe_24xx_pwm_ops;\r\npwm->chip.npwm = 3;\r\n} else {\r\nif (stmpe->partnum == STMPE1601)\r\ndev_err(&pdev->dev, "STMPE1601 not yet supported\n");\r\nelse\r\ndev_err(&pdev->dev, "Unknown STMPE PWM\n");\r\nreturn -ENODEV;\r\n}\r\nret = stmpe_enable(stmpe, STMPE_BLOCK_PWM);\r\nif (ret)\r\nreturn ret;\r\nret = pwmchip_add(&pwm->chip);\r\nif (ret) {\r\nstmpe_disable(stmpe, STMPE_BLOCK_PWM);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, pwm);\r\nreturn 0;\r\n}
