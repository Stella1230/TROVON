int monitor_device(const char *device_name,\r\nunsigned int line,\r\nu_int32_t handleflags,\r\nu_int32_t eventflags,\r\nunsigned int loops)\r\n{\r\nstruct gpioevent_request req;\r\nstruct gpiohandle_data data;\r\nchar *chrdev_name;\r\nint fd;\r\nint ret;\r\nint i = 0;\r\nret = asprintf(&chrdev_name, "/dev/%s", device_name);\r\nif (ret < 0)\r\nreturn -ENOMEM;\r\nfd = open(chrdev_name, 0);\r\nif (fd == -1) {\r\nret = -errno;\r\nfprintf(stderr, "Failed to open %s\n", chrdev_name);\r\ngoto exit_close_error;\r\n}\r\nreq.lineoffset = line;\r\nreq.handleflags = handleflags;\r\nreq.eventflags = eventflags;\r\nstrcpy(req.consumer_label, "gpio-event-mon");\r\nret = ioctl(fd, GPIO_GET_LINEEVENT_IOCTL, &req);\r\nif (ret == -1) {\r\nret = -errno;\r\nfprintf(stderr, "Failed to issue GET EVENT "\r\n"IOCTL (%d)\n",\r\nret);\r\ngoto exit_close_error;\r\n}\r\nret = ioctl(req.fd, GPIOHANDLE_GET_LINE_VALUES_IOCTL, &data);\r\nif (ret == -1) {\r\nret = -errno;\r\nfprintf(stderr, "Failed to issue GPIOHANDLE GET LINE "\r\n"VALUES IOCTL (%d)\n",\r\nret);\r\ngoto exit_close_error;\r\n}\r\nfprintf(stdout, "Monitoring line %d on %s\n", line, device_name);\r\nfprintf(stdout, "Initial line value: %d\n", data.values[0]);\r\nwhile (1) {\r\nstruct gpioevent_data event;\r\nret = read(req.fd, &event, sizeof(event));\r\nif (ret == -1) {\r\nif (errno == -EAGAIN) {\r\nfprintf(stderr, "nothing available\n");\r\ncontinue;\r\n} else {\r\nret = -errno;\r\nfprintf(stderr, "Failed to read event (%d)\n",\r\nret);\r\nbreak;\r\n}\r\n}\r\nif (ret != sizeof(event)) {\r\nfprintf(stderr, "Reading event failed\n");\r\nret = -EIO;\r\nbreak;\r\n}\r\nfprintf(stdout, "GPIO EVENT %" PRIu64 ": ", event.timestamp);\r\nswitch (event.id) {\r\ncase GPIOEVENT_EVENT_RISING_EDGE:\r\nfprintf(stdout, "rising edge");\r\nbreak;\r\ncase GPIOEVENT_EVENT_FALLING_EDGE:\r\nfprintf(stdout, "falling edge");\r\nbreak;\r\ndefault:\r\nfprintf(stdout, "unknown event");\r\n}\r\nfprintf(stdout, "\n");\r\ni++;\r\nif (i == loops)\r\nbreak;\r\n}\r\nexit_close_error:\r\nif (close(fd) == -1)\r\nperror("Failed to close GPIO character device file");\r\nfree(chrdev_name);\r\nreturn ret;\r\n}\r\nvoid print_usage(void)\r\n{\r\nfprintf(stderr, "Usage: gpio-event-mon [options]...\n"\r\n"Listen to events on GPIO lines, 0->1 1->0\n"\r\n" -n <name> Listen on GPIOs on a named device (must be stated)\n"\r\n" -o <n> Offset to monitor\n"\r\n" -d Set line as open drain\n"\r\n" -s Set line as open source\n"\r\n" -r Listen for rising edges\n"\r\n" -f Listen for falling edges\n"\r\n" [-c <n>] Do <n> loops (optional, infinite loop if not stated)\n"\r\n" -? This helptext\n"\r\n"\n"\r\n"Example:\n"\r\n"gpio-event-mon -n gpiochip0 -o 4 -r -f\n"\r\n);\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nconst char *device_name = NULL;\r\nunsigned int line = -1;\r\nunsigned int loops = 0;\r\nu_int32_t handleflags = GPIOHANDLE_REQUEST_INPUT;\r\nu_int32_t eventflags = 0;\r\nint c;\r\nwhile ((c = getopt(argc, argv, "c:n:o:dsrf?")) != -1) {\r\nswitch (c) {\r\ncase 'c':\r\nloops = strtoul(optarg, NULL, 10);\r\nbreak;\r\ncase 'n':\r\ndevice_name = optarg;\r\nbreak;\r\ncase 'o':\r\nline = strtoul(optarg, NULL, 10);\r\nbreak;\r\ncase 'd':\r\nhandleflags |= GPIOHANDLE_REQUEST_OPEN_DRAIN;\r\nbreak;\r\ncase 's':\r\nhandleflags |= GPIOHANDLE_REQUEST_OPEN_SOURCE;\r\nbreak;\r\ncase 'r':\r\neventflags |= GPIOEVENT_REQUEST_RISING_EDGE;\r\nbreak;\r\ncase 'f':\r\neventflags |= GPIOEVENT_REQUEST_FALLING_EDGE;\r\nbreak;\r\ncase '?':\r\nprint_usage();\r\nreturn -1;\r\n}\r\n}\r\nif (!device_name || line == -1) {\r\nprint_usage();\r\nreturn -1;\r\n}\r\nif (!eventflags) {\r\nprintf("No flags specified, listening on both rising and "\r\n"falling edges\n");\r\neventflags = GPIOEVENT_REQUEST_BOTH_EDGES;\r\n}\r\nreturn monitor_device(device_name, line, handleflags,\r\neventflags, loops);\r\n}
