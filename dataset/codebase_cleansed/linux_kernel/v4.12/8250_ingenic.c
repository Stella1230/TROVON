static uint8_t __init early_in(struct uart_port *port, int offset)\r\n{\r\nreturn readl(port->membase + (offset << 2));\r\n}\r\nstatic void __init early_out(struct uart_port *port, int offset, uint8_t value)\r\n{\r\nwritel(value, port->membase + (offset << 2));\r\n}\r\nstatic void __init ingenic_early_console_putc(struct uart_port *port, int c)\r\n{\r\nuint8_t lsr;\r\ndo {\r\nlsr = early_in(port, UART_LSR);\r\n} while ((lsr & UART_LSR_TEMT) == 0);\r\nearly_out(port, UART_TX, c);\r\n}\r\nstatic void __init ingenic_early_console_write(struct console *console,\r\nconst char *s, unsigned int count)\r\n{\r\nuart_console_write(&early_device->port, s, count,\r\ningenic_early_console_putc);\r\n}\r\nstatic void __init ingenic_early_console_setup_clock(struct earlycon_device *dev)\r\n{\r\nvoid *fdt = initial_boot_params;\r\nconst __be32 *prop;\r\nint offset;\r\noffset = fdt_path_offset(fdt, "/ext");\r\nif (offset < 0)\r\nreturn;\r\nprop = fdt_getprop(fdt, offset, "clock-frequency", NULL);\r\nif (!prop)\r\nreturn;\r\ndev->port.uartclk = be32_to_cpup(prop);\r\n}\r\nstatic int __init ingenic_early_console_setup(struct earlycon_device *dev,\r\nconst char *opt)\r\n{\r\nstruct uart_port *port = &dev->port;\r\nunsigned int baud, divisor;\r\nif (!dev->port.membase)\r\nreturn -ENODEV;\r\ningenic_early_console_setup_clock(dev);\r\nbaud = dev->baud ?: 115200;\r\ndivisor = DIV_ROUND_CLOSEST(port->uartclk, 16 * baud);\r\nearly_out(port, UART_IER, 0);\r\nearly_out(port, UART_LCR, UART_LCR_DLAB | UART_LCR_WLEN8);\r\nearly_out(port, UART_DLL, 0);\r\nearly_out(port, UART_DLM, 0);\r\nearly_out(port, UART_LCR, UART_LCR_WLEN8);\r\nearly_out(port, UART_FCR, UART_FCR_UME | UART_FCR_CLEAR_XMIT |\r\nUART_FCR_CLEAR_RCVR | UART_FCR_ENABLE_FIFO);\r\nearly_out(port, UART_MCR, UART_MCR_RTS | UART_MCR_DTR);\r\nearly_out(port, UART_LCR, UART_LCR_DLAB | UART_LCR_WLEN8);\r\nearly_out(port, UART_DLL, divisor & 0xff);\r\nearly_out(port, UART_DLM, (divisor >> 8) & 0xff);\r\nearly_out(port, UART_LCR, UART_LCR_WLEN8);\r\nearly_device = dev;\r\ndev->con->write = ingenic_early_console_write;\r\nreturn 0;\r\n}\r\nstatic void ingenic_uart_serial_out(struct uart_port *p, int offset, int value)\r\n{\r\nint ier;\r\nswitch (offset) {\r\ncase UART_FCR:\r\nvalue |= UART_FCR_UME;\r\nbreak;\r\ncase UART_IER:\r\nvalue |= (value & 0x4) << 2;\r\nbreak;\r\ncase UART_MCR:\r\nier = p->serial_in(p, UART_IER);\r\nif (ier & UART_IER_MSI)\r\nvalue |= UART_MCR_MDCE | UART_MCR_FCM;\r\nelse\r\nvalue &= ~(UART_MCR_MDCE | UART_MCR_FCM);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nwriteb(value, p->membase + (offset << p->regshift));\r\n}\r\nstatic unsigned int ingenic_uart_serial_in(struct uart_port *p, int offset)\r\n{\r\nunsigned int value;\r\nvalue = readb(p->membase + (offset << p->regshift));\r\nswitch (offset) {\r\ncase UART_FCR:\r\nvalue &= ~UART_FCR_UME;\r\nbreak;\r\ncase UART_MCR:\r\nvalue &= ~(UART_MCR_MDCE | UART_MCR_FCM);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn value;\r\n}\r\nstatic int ingenic_uart_probe(struct platform_device *pdev)\r\n{\r\nstruct uart_8250_port uart = {};\r\nstruct resource *regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nstruct resource *irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nstruct ingenic_uart_data *data;\r\nconst struct ingenic_uart_config *cdata;\r\nconst struct of_device_id *match;\r\nint err, line;\r\nmatch = of_match_device(of_match, &pdev->dev);\r\nif (!match) {\r\ndev_err(&pdev->dev, "Error: No device match found\n");\r\nreturn -ENODEV;\r\n}\r\ncdata = match->data;\r\nif (!regs || !irq) {\r\ndev_err(&pdev->dev, "no registers/irq defined\n");\r\nreturn -EINVAL;\r\n}\r\ndata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nspin_lock_init(&uart.port.lock);\r\nuart.port.type = PORT_16550A;\r\nuart.port.flags = UPF_SKIP_TEST | UPF_IOREMAP | UPF_FIXED_TYPE;\r\nuart.port.iotype = UPIO_MEM;\r\nuart.port.mapbase = regs->start;\r\nuart.port.regshift = 2;\r\nuart.port.serial_out = ingenic_uart_serial_out;\r\nuart.port.serial_in = ingenic_uart_serial_in;\r\nuart.port.irq = irq->start;\r\nuart.port.dev = &pdev->dev;\r\nuart.port.fifosize = cdata->fifosize;\r\nuart.tx_loadsz = cdata->tx_loadsz;\r\nuart.capabilities = UART_CAP_FIFO | UART_CAP_RTOIE;\r\nline = of_alias_get_id(pdev->dev.of_node, "serial");\r\nif (line >= 0)\r\nuart.port.line = line;\r\nuart.port.membase = devm_ioremap(&pdev->dev, regs->start,\r\nresource_size(regs));\r\nif (!uart.port.membase)\r\nreturn -ENOMEM;\r\ndata->clk_module = devm_clk_get(&pdev->dev, "module");\r\nif (IS_ERR(data->clk_module)) {\r\nerr = PTR_ERR(data->clk_module);\r\nif (err != -EPROBE_DEFER)\r\ndev_err(&pdev->dev,\r\n"unable to get module clock: %d\n", err);\r\nreturn err;\r\n}\r\ndata->clk_baud = devm_clk_get(&pdev->dev, "baud");\r\nif (IS_ERR(data->clk_baud)) {\r\nerr = PTR_ERR(data->clk_baud);\r\nif (err != -EPROBE_DEFER)\r\ndev_err(&pdev->dev,\r\n"unable to get baud clock: %d\n", err);\r\nreturn err;\r\n}\r\nerr = clk_prepare_enable(data->clk_module);\r\nif (err) {\r\ndev_err(&pdev->dev, "could not enable module clock: %d\n", err);\r\ngoto out;\r\n}\r\nerr = clk_prepare_enable(data->clk_baud);\r\nif (err) {\r\ndev_err(&pdev->dev, "could not enable baud clock: %d\n", err);\r\ngoto out_disable_moduleclk;\r\n}\r\nuart.port.uartclk = clk_get_rate(data->clk_baud);\r\ndata->line = serial8250_register_8250_port(&uart);\r\nif (data->line < 0) {\r\nerr = data->line;\r\ngoto out_disable_baudclk;\r\n}\r\nplatform_set_drvdata(pdev, data);\r\nreturn 0;\r\nout_disable_baudclk:\r\nclk_disable_unprepare(data->clk_baud);\r\nout_disable_moduleclk:\r\nclk_disable_unprepare(data->clk_module);\r\nout:\r\nreturn err;\r\n}\r\nstatic int ingenic_uart_remove(struct platform_device *pdev)\r\n{\r\nstruct ingenic_uart_data *data = platform_get_drvdata(pdev);\r\nserial8250_unregister_port(data->line);\r\nclk_disable_unprepare(data->clk_module);\r\nclk_disable_unprepare(data->clk_baud);\r\nreturn 0;\r\n}
