static int i801_check_pre(struct i801_priv *priv)\r\n{\r\nint status;\r\nstatus = inb_p(SMBHSTSTS(priv));\r\nif (status & SMBHSTSTS_HOST_BUSY) {\r\ndev_err(&priv->pci_dev->dev, "SMBus is busy, can't use it!\n");\r\nreturn -EBUSY;\r\n}\r\nstatus &= STATUS_FLAGS;\r\nif (status) {\r\ndev_dbg(&priv->pci_dev->dev, "Clearing status flags (%02x)\n",\r\nstatus);\r\noutb_p(status, SMBHSTSTS(priv));\r\nstatus = inb_p(SMBHSTSTS(priv)) & STATUS_FLAGS;\r\nif (status) {\r\ndev_err(&priv->pci_dev->dev,\r\n"Failed clearing status flags (%02x)\n",\r\nstatus);\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (priv->features & FEATURE_SMBUS_PEC) {\r\nstatus = inb_p(SMBAUXSTS(priv)) & SMBAUXSTS_CRCE;\r\nif (status) {\r\ndev_dbg(&priv->pci_dev->dev,\r\n"Clearing aux status flags (%02x)\n", status);\r\noutb_p(status, SMBAUXSTS(priv));\r\nstatus = inb_p(SMBAUXSTS(priv)) & SMBAUXSTS_CRCE;\r\nif (status) {\r\ndev_err(&priv->pci_dev->dev,\r\n"Failed clearing aux status flags (%02x)\n",\r\nstatus);\r\nreturn -EBUSY;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int i801_check_post(struct i801_priv *priv, int status)\r\n{\r\nint result = 0;\r\nif (unlikely(status < 0)) {\r\ndev_err(&priv->pci_dev->dev, "Transaction timeout\n");\r\ndev_dbg(&priv->pci_dev->dev, "Terminating the current operation\n");\r\noutb_p(inb_p(SMBHSTCNT(priv)) | SMBHSTCNT_KILL,\r\nSMBHSTCNT(priv));\r\nusleep_range(1000, 2000);\r\noutb_p(inb_p(SMBHSTCNT(priv)) & (~SMBHSTCNT_KILL),\r\nSMBHSTCNT(priv));\r\nstatus = inb_p(SMBHSTSTS(priv));\r\nif ((status & SMBHSTSTS_HOST_BUSY) ||\r\n!(status & SMBHSTSTS_FAILED))\r\ndev_err(&priv->pci_dev->dev,\r\n"Failed terminating the transaction\n");\r\noutb_p(STATUS_FLAGS, SMBHSTSTS(priv));\r\nreturn -ETIMEDOUT;\r\n}\r\nif (status & SMBHSTSTS_FAILED) {\r\nresult = -EIO;\r\ndev_err(&priv->pci_dev->dev, "Transaction failed\n");\r\n}\r\nif (status & SMBHSTSTS_DEV_ERR) {\r\nif ((priv->features & FEATURE_SMBUS_PEC) &&\r\n(inb_p(SMBAUXSTS(priv)) & SMBAUXSTS_CRCE)) {\r\noutb_p(SMBAUXSTS_CRCE, SMBAUXSTS(priv));\r\nresult = -EBADMSG;\r\ndev_dbg(&priv->pci_dev->dev, "PEC error\n");\r\n} else {\r\nresult = -ENXIO;\r\ndev_dbg(&priv->pci_dev->dev, "No response\n");\r\n}\r\n}\r\nif (status & SMBHSTSTS_BUS_ERR) {\r\nresult = -EAGAIN;\r\ndev_dbg(&priv->pci_dev->dev, "Lost arbitration\n");\r\n}\r\noutb_p(status, SMBHSTSTS(priv));\r\nreturn result;\r\n}\r\nstatic int i801_wait_intr(struct i801_priv *priv)\r\n{\r\nint timeout = 0;\r\nint status;\r\ndo {\r\nusleep_range(250, 500);\r\nstatus = inb_p(SMBHSTSTS(priv));\r\n} while (((status & SMBHSTSTS_HOST_BUSY) ||\r\n!(status & (STATUS_ERROR_FLAGS | SMBHSTSTS_INTR))) &&\r\n(timeout++ < MAX_RETRIES));\r\nif (timeout > MAX_RETRIES) {\r\ndev_dbg(&priv->pci_dev->dev, "INTR Timeout!\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn status & (STATUS_ERROR_FLAGS | SMBHSTSTS_INTR);\r\n}\r\nstatic int i801_wait_byte_done(struct i801_priv *priv)\r\n{\r\nint timeout = 0;\r\nint status;\r\ndo {\r\nusleep_range(250, 500);\r\nstatus = inb_p(SMBHSTSTS(priv));\r\n} while (!(status & (STATUS_ERROR_FLAGS | SMBHSTSTS_BYTE_DONE)) &&\r\n(timeout++ < MAX_RETRIES));\r\nif (timeout > MAX_RETRIES) {\r\ndev_dbg(&priv->pci_dev->dev, "BYTE_DONE Timeout!\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn status & STATUS_ERROR_FLAGS;\r\n}\r\nstatic int i801_transaction(struct i801_priv *priv, int xact)\r\n{\r\nint status;\r\nint result;\r\nconst struct i2c_adapter *adap = &priv->adapter;\r\nresult = i801_check_pre(priv);\r\nif (result < 0)\r\nreturn result;\r\nif (priv->features & FEATURE_IRQ) {\r\noutb_p(xact | SMBHSTCNT_INTREN | SMBHSTCNT_START,\r\nSMBHSTCNT(priv));\r\nresult = wait_event_timeout(priv->waitq,\r\n(status = priv->status),\r\nadap->timeout);\r\nif (!result) {\r\nstatus = -ETIMEDOUT;\r\ndev_warn(&priv->pci_dev->dev,\r\n"Timeout waiting for interrupt!\n");\r\n}\r\npriv->status = 0;\r\nreturn i801_check_post(priv, status);\r\n}\r\noutb_p(xact | SMBHSTCNT_START, SMBHSTCNT(priv));\r\nstatus = i801_wait_intr(priv);\r\nreturn i801_check_post(priv, status);\r\n}\r\nstatic int i801_block_transaction_by_block(struct i801_priv *priv,\r\nunion i2c_smbus_data *data,\r\nchar read_write, int hwpec)\r\n{\r\nint i, len;\r\nint status;\r\ninb_p(SMBHSTCNT(priv));\r\nif (read_write == I2C_SMBUS_WRITE) {\r\nlen = data->block[0];\r\noutb_p(len, SMBHSTDAT0(priv));\r\nfor (i = 0; i < len; i++)\r\noutb_p(data->block[i+1], SMBBLKDAT(priv));\r\n}\r\nstatus = i801_transaction(priv, I801_BLOCK_DATA |\r\n(hwpec ? SMBHSTCNT_PEC_EN : 0));\r\nif (status)\r\nreturn status;\r\nif (read_write == I2C_SMBUS_READ) {\r\nlen = inb_p(SMBHSTDAT0(priv));\r\nif (len < 1 || len > I2C_SMBUS_BLOCK_MAX)\r\nreturn -EPROTO;\r\ndata->block[0] = len;\r\nfor (i = 0; i < len; i++)\r\ndata->block[i + 1] = inb_p(SMBBLKDAT(priv));\r\n}\r\nreturn 0;\r\n}\r\nstatic void i801_isr_byte_done(struct i801_priv *priv)\r\n{\r\nif (priv->is_read) {\r\nif (((priv->cmd & 0x1c) == I801_BLOCK_DATA) &&\r\n(priv->count == 0)) {\r\npriv->len = inb_p(SMBHSTDAT0(priv));\r\nif (priv->len < 1 || priv->len > I2C_SMBUS_BLOCK_MAX) {\r\ndev_err(&priv->pci_dev->dev,\r\n"Illegal SMBus block read size %d\n",\r\npriv->len);\r\npriv->len = I2C_SMBUS_BLOCK_MAX;\r\n} else {\r\ndev_dbg(&priv->pci_dev->dev,\r\n"SMBus block read size is %d\n",\r\npriv->len);\r\n}\r\npriv->data[-1] = priv->len;\r\n}\r\nif (priv->count < priv->len)\r\npriv->data[priv->count++] = inb(SMBBLKDAT(priv));\r\nelse\r\ndev_dbg(&priv->pci_dev->dev,\r\n"Discarding extra byte on block read\n");\r\nif (priv->count == priv->len - 1)\r\noutb_p(priv->cmd | SMBHSTCNT_LAST_BYTE,\r\nSMBHSTCNT(priv));\r\n} else if (priv->count < priv->len - 1) {\r\noutb_p(priv->data[++priv->count], SMBBLKDAT(priv));\r\n}\r\noutb_p(SMBHSTSTS_BYTE_DONE, SMBHSTSTS(priv));\r\n}\r\nstatic irqreturn_t i801_host_notify_isr(struct i801_priv *priv)\r\n{\r\nunsigned short addr;\r\naddr = inb_p(SMBNTFDADD(priv)) >> 1;\r\ni2c_handle_smbus_host_notify(&priv->adapter, addr);\r\noutb_p(SMBSLVSTS_HST_NTFY_STS, SMBSLVSTS(priv));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t i801_isr(int irq, void *dev_id)\r\n{\r\nstruct i801_priv *priv = dev_id;\r\nu16 pcists;\r\nu8 status;\r\npci_read_config_word(priv->pci_dev, SMBPCISTS, &pcists);\r\nif (!(pcists & SMBPCISTS_INTS))\r\nreturn IRQ_NONE;\r\nif (priv->features & FEATURE_HOST_NOTIFY) {\r\nstatus = inb_p(SMBSLVSTS(priv));\r\nif (status & SMBSLVSTS_HST_NTFY_STS)\r\nreturn i801_host_notify_isr(priv);\r\n}\r\nstatus = inb_p(SMBHSTSTS(priv));\r\nif (status & SMBHSTSTS_BYTE_DONE)\r\ni801_isr_byte_done(priv);\r\nstatus &= SMBHSTSTS_INTR | STATUS_ERROR_FLAGS;\r\nif (status) {\r\noutb_p(status, SMBHSTSTS(priv));\r\npriv->status = status;\r\nwake_up(&priv->waitq);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int i801_block_transaction_byte_by_byte(struct i801_priv *priv,\r\nunion i2c_smbus_data *data,\r\nchar read_write, int command,\r\nint hwpec)\r\n{\r\nint i, len;\r\nint smbcmd;\r\nint status;\r\nint result;\r\nconst struct i2c_adapter *adap = &priv->adapter;\r\nresult = i801_check_pre(priv);\r\nif (result < 0)\r\nreturn result;\r\nlen = data->block[0];\r\nif (read_write == I2C_SMBUS_WRITE) {\r\noutb_p(len, SMBHSTDAT0(priv));\r\noutb_p(data->block[1], SMBBLKDAT(priv));\r\n}\r\nif (command == I2C_SMBUS_I2C_BLOCK_DATA &&\r\nread_write == I2C_SMBUS_READ)\r\nsmbcmd = I801_I2C_BLOCK_DATA;\r\nelse\r\nsmbcmd = I801_BLOCK_DATA;\r\nif (priv->features & FEATURE_IRQ) {\r\npriv->is_read = (read_write == I2C_SMBUS_READ);\r\nif (len == 1 && priv->is_read)\r\nsmbcmd |= SMBHSTCNT_LAST_BYTE;\r\npriv->cmd = smbcmd | SMBHSTCNT_INTREN;\r\npriv->len = len;\r\npriv->count = 0;\r\npriv->data = &data->block[1];\r\noutb_p(priv->cmd | SMBHSTCNT_START, SMBHSTCNT(priv));\r\nresult = wait_event_timeout(priv->waitq,\r\n(status = priv->status),\r\nadap->timeout);\r\nif (!result) {\r\nstatus = -ETIMEDOUT;\r\ndev_warn(&priv->pci_dev->dev,\r\n"Timeout waiting for interrupt!\n");\r\n}\r\npriv->status = 0;\r\nreturn i801_check_post(priv, status);\r\n}\r\nfor (i = 1; i <= len; i++) {\r\nif (i == len && read_write == I2C_SMBUS_READ)\r\nsmbcmd |= SMBHSTCNT_LAST_BYTE;\r\noutb_p(smbcmd, SMBHSTCNT(priv));\r\nif (i == 1)\r\noutb_p(inb(SMBHSTCNT(priv)) | SMBHSTCNT_START,\r\nSMBHSTCNT(priv));\r\nstatus = i801_wait_byte_done(priv);\r\nif (status)\r\ngoto exit;\r\nif (i == 1 && read_write == I2C_SMBUS_READ\r\n&& command != I2C_SMBUS_I2C_BLOCK_DATA) {\r\nlen = inb_p(SMBHSTDAT0(priv));\r\nif (len < 1 || len > I2C_SMBUS_BLOCK_MAX) {\r\ndev_err(&priv->pci_dev->dev,\r\n"Illegal SMBus block read size %d\n",\r\nlen);\r\nwhile (inb_p(SMBHSTSTS(priv)) &\r\nSMBHSTSTS_HOST_BUSY)\r\noutb_p(SMBHSTSTS_BYTE_DONE,\r\nSMBHSTSTS(priv));\r\noutb_p(SMBHSTSTS_INTR, SMBHSTSTS(priv));\r\nreturn -EPROTO;\r\n}\r\ndata->block[0] = len;\r\n}\r\nif (read_write == I2C_SMBUS_READ)\r\ndata->block[i] = inb_p(SMBBLKDAT(priv));\r\nif (read_write == I2C_SMBUS_WRITE && i+1 <= len)\r\noutb_p(data->block[i+1], SMBBLKDAT(priv));\r\noutb_p(SMBHSTSTS_BYTE_DONE, SMBHSTSTS(priv));\r\n}\r\nstatus = i801_wait_intr(priv);\r\nexit:\r\nreturn i801_check_post(priv, status);\r\n}\r\nstatic int i801_set_block_buffer_mode(struct i801_priv *priv)\r\n{\r\noutb_p(inb_p(SMBAUXCTL(priv)) | SMBAUXCTL_E32B, SMBAUXCTL(priv));\r\nif ((inb_p(SMBAUXCTL(priv)) & SMBAUXCTL_E32B) == 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int i801_block_transaction(struct i801_priv *priv,\r\nunion i2c_smbus_data *data, char read_write,\r\nint command, int hwpec)\r\n{\r\nint result = 0;\r\nunsigned char hostc;\r\nif (command == I2C_SMBUS_I2C_BLOCK_DATA) {\r\nif (read_write == I2C_SMBUS_WRITE) {\r\npci_read_config_byte(priv->pci_dev, SMBHSTCFG, &hostc);\r\npci_write_config_byte(priv->pci_dev, SMBHSTCFG,\r\nhostc | SMBHSTCFG_I2C_EN);\r\n} else if (!(priv->features & FEATURE_I2C_BLOCK_READ)) {\r\ndev_err(&priv->pci_dev->dev,\r\n"I2C block read is unsupported!\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nif (read_write == I2C_SMBUS_WRITE\r\n|| command == I2C_SMBUS_I2C_BLOCK_DATA) {\r\nif (data->block[0] < 1)\r\ndata->block[0] = 1;\r\nif (data->block[0] > I2C_SMBUS_BLOCK_MAX)\r\ndata->block[0] = I2C_SMBUS_BLOCK_MAX;\r\n} else {\r\ndata->block[0] = 32;\r\n}\r\nif ((priv->features & FEATURE_BLOCK_BUFFER)\r\n&& command != I2C_SMBUS_I2C_BLOCK_DATA\r\n&& i801_set_block_buffer_mode(priv) == 0)\r\nresult = i801_block_transaction_by_block(priv, data,\r\nread_write, hwpec);\r\nelse\r\nresult = i801_block_transaction_byte_by_byte(priv, data,\r\nread_write,\r\ncommand, hwpec);\r\nif (command == I2C_SMBUS_I2C_BLOCK_DATA\r\n&& read_write == I2C_SMBUS_WRITE) {\r\npci_write_config_byte(priv->pci_dev, SMBHSTCFG, hostc);\r\n}\r\nreturn result;\r\n}\r\nstatic s32 i801_access(struct i2c_adapter *adap, u16 addr,\r\nunsigned short flags, char read_write, u8 command,\r\nint size, union i2c_smbus_data *data)\r\n{\r\nint hwpec;\r\nint block = 0;\r\nint ret = 0, xact = 0;\r\nstruct i801_priv *priv = i2c_get_adapdata(adap);\r\nmutex_lock(&priv->acpi_lock);\r\nif (priv->acpi_reserved) {\r\nmutex_unlock(&priv->acpi_lock);\r\nreturn -EBUSY;\r\n}\r\npm_runtime_get_sync(&priv->pci_dev->dev);\r\nhwpec = (priv->features & FEATURE_SMBUS_PEC) && (flags & I2C_CLIENT_PEC)\r\n&& size != I2C_SMBUS_QUICK\r\n&& size != I2C_SMBUS_I2C_BLOCK_DATA;\r\nswitch (size) {\r\ncase I2C_SMBUS_QUICK:\r\noutb_p(((addr & 0x7f) << 1) | (read_write & 0x01),\r\nSMBHSTADD(priv));\r\nxact = I801_QUICK;\r\nbreak;\r\ncase I2C_SMBUS_BYTE:\r\noutb_p(((addr & 0x7f) << 1) | (read_write & 0x01),\r\nSMBHSTADD(priv));\r\nif (read_write == I2C_SMBUS_WRITE)\r\noutb_p(command, SMBHSTCMD(priv));\r\nxact = I801_BYTE;\r\nbreak;\r\ncase I2C_SMBUS_BYTE_DATA:\r\noutb_p(((addr & 0x7f) << 1) | (read_write & 0x01),\r\nSMBHSTADD(priv));\r\noutb_p(command, SMBHSTCMD(priv));\r\nif (read_write == I2C_SMBUS_WRITE)\r\noutb_p(data->byte, SMBHSTDAT0(priv));\r\nxact = I801_BYTE_DATA;\r\nbreak;\r\ncase I2C_SMBUS_WORD_DATA:\r\noutb_p(((addr & 0x7f) << 1) | (read_write & 0x01),\r\nSMBHSTADD(priv));\r\noutb_p(command, SMBHSTCMD(priv));\r\nif (read_write == I2C_SMBUS_WRITE) {\r\noutb_p(data->word & 0xff, SMBHSTDAT0(priv));\r\noutb_p((data->word & 0xff00) >> 8, SMBHSTDAT1(priv));\r\n}\r\nxact = I801_WORD_DATA;\r\nbreak;\r\ncase I2C_SMBUS_BLOCK_DATA:\r\noutb_p(((addr & 0x7f) << 1) | (read_write & 0x01),\r\nSMBHSTADD(priv));\r\noutb_p(command, SMBHSTCMD(priv));\r\nblock = 1;\r\nbreak;\r\ncase I2C_SMBUS_I2C_BLOCK_DATA:\r\noutb_p(((addr & 0x7f) << 1) |\r\n((priv->original_hstcfg & SMBHSTCFG_SPD_WD) ?\r\n(read_write & 0x01) : 0),\r\nSMBHSTADD(priv));\r\nif (read_write == I2C_SMBUS_READ) {\r\noutb_p(command, SMBHSTDAT1(priv));\r\n} else\r\noutb_p(command, SMBHSTCMD(priv));\r\nblock = 1;\r\nbreak;\r\ndefault:\r\ndev_err(&priv->pci_dev->dev, "Unsupported transaction %d\n",\r\nsize);\r\nret = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nif (hwpec)\r\noutb_p(inb_p(SMBAUXCTL(priv)) | SMBAUXCTL_CRC, SMBAUXCTL(priv));\r\nelse\r\noutb_p(inb_p(SMBAUXCTL(priv)) & (~SMBAUXCTL_CRC),\r\nSMBAUXCTL(priv));\r\nif (block)\r\nret = i801_block_transaction(priv, data, read_write, size,\r\nhwpec);\r\nelse\r\nret = i801_transaction(priv, xact);\r\nif (hwpec || block)\r\noutb_p(inb_p(SMBAUXCTL(priv)) &\r\n~(SMBAUXCTL_CRC | SMBAUXCTL_E32B), SMBAUXCTL(priv));\r\nif (block)\r\ngoto out;\r\nif (ret)\r\ngoto out;\r\nif ((read_write == I2C_SMBUS_WRITE) || (xact == I801_QUICK))\r\ngoto out;\r\nswitch (xact & 0x7f) {\r\ncase I801_BYTE:\r\ncase I801_BYTE_DATA:\r\ndata->byte = inb_p(SMBHSTDAT0(priv));\r\nbreak;\r\ncase I801_WORD_DATA:\r\ndata->word = inb_p(SMBHSTDAT0(priv)) +\r\n(inb_p(SMBHSTDAT1(priv)) << 8);\r\nbreak;\r\n}\r\nout:\r\npm_runtime_mark_last_busy(&priv->pci_dev->dev);\r\npm_runtime_put_autosuspend(&priv->pci_dev->dev);\r\nmutex_unlock(&priv->acpi_lock);\r\nreturn ret;\r\n}\r\nstatic u32 i801_func(struct i2c_adapter *adapter)\r\n{\r\nstruct i801_priv *priv = i2c_get_adapdata(adapter);\r\nreturn I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |\r\nI2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |\r\nI2C_FUNC_SMBUS_BLOCK_DATA | I2C_FUNC_SMBUS_WRITE_I2C_BLOCK |\r\n((priv->features & FEATURE_SMBUS_PEC) ? I2C_FUNC_SMBUS_PEC : 0) |\r\n((priv->features & FEATURE_I2C_BLOCK_READ) ?\r\nI2C_FUNC_SMBUS_READ_I2C_BLOCK : 0) |\r\n((priv->features & FEATURE_HOST_NOTIFY) ?\r\nI2C_FUNC_SMBUS_HOST_NOTIFY : 0);\r\n}\r\nstatic void i801_enable_host_notify(struct i2c_adapter *adapter)\r\n{\r\nstruct i801_priv *priv = i2c_get_adapdata(adapter);\r\nif (!(priv->features & FEATURE_HOST_NOTIFY))\r\nreturn;\r\npriv->original_slvcmd = inb_p(SMBSLVCMD(priv));\r\nif (!(SMBSLVCMD_HST_NTFY_INTREN & priv->original_slvcmd))\r\noutb_p(SMBSLVCMD_HST_NTFY_INTREN | priv->original_slvcmd,\r\nSMBSLVCMD(priv));\r\noutb_p(SMBSLVSTS_HST_NTFY_STS, SMBSLVSTS(priv));\r\n}\r\nstatic void i801_disable_host_notify(struct i801_priv *priv)\r\n{\r\nif (!(priv->features & FEATURE_HOST_NOTIFY))\r\nreturn;\r\noutb_p(priv->original_slvcmd, SMBSLVCMD(priv));\r\n}\r\nstatic __init const void __iomem *bios_signature(const void __iomem *bios)\r\n{\r\nssize_t offset;\r\nconst unsigned char signature[] = "FJKEYINF";\r\nfor (offset = 0; offset < 0x10000; offset += 0x10) {\r\nif (check_signature(bios + offset, signature,\r\nsizeof(signature)-1))\r\nreturn bios + offset;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void __init input_apanel_init(void)\r\n{\r\nvoid __iomem *bios;\r\nconst void __iomem *p;\r\nbios = ioremap(0xF0000, 0x10000);\r\np = bios_signature(bios);\r\nif (p) {\r\napanel_addr = readb(p + 8 + 3) >> 1;\r\n}\r\niounmap(bios);\r\n}\r\nstatic void dmi_check_onboard_device(u8 type, const char *name,\r\nstruct i2c_adapter *adap)\r\n{\r\nint i;\r\nstruct i2c_board_info info;\r\nfor (i = 0; i < ARRAY_SIZE(dmi_devices); i++) {\r\nif ((type & ~0x80) != dmi_devices[i].type)\r\ncontinue;\r\nif (strcasecmp(name, dmi_devices[i].name))\r\ncontinue;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\ninfo.addr = dmi_devices[i].i2c_addr;\r\nstrlcpy(info.type, dmi_devices[i].i2c_type, I2C_NAME_SIZE);\r\ni2c_new_device(adap, &info);\r\nbreak;\r\n}\r\n}\r\nstatic void dmi_check_onboard_devices(const struct dmi_header *dm, void *adap)\r\n{\r\nint i, count;\r\nif (dm->type != 10)\r\nreturn;\r\ncount = (dm->length - sizeof(struct dmi_header)) / 2;\r\nfor (i = 0; i < count; i++) {\r\nconst u8 *d = (char *)(dm + 1) + (i * 2);\r\nconst char *name = ((char *) dm) + dm->length;\r\nu8 type = d[0];\r\nu8 s = d[1];\r\nif (!s)\r\ncontinue;\r\ns--;\r\nwhile (s > 0 && name[0]) {\r\nname += strlen(name) + 1;\r\ns--;\r\n}\r\nif (name[0] == 0)\r\ncontinue;\r\ndmi_check_onboard_device(type, name, adap);\r\n}\r\n}\r\nstatic void i801_probe_optional_slaves(struct i801_priv *priv)\r\n{\r\nif (priv->features & FEATURE_IDF)\r\nreturn;\r\nif (apanel_addr) {\r\nstruct i2c_board_info info;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\ninfo.addr = apanel_addr;\r\nstrlcpy(info.type, "fujitsu_apanel", I2C_NAME_SIZE);\r\ni2c_new_device(&priv->adapter, &info);\r\n}\r\nif (dmi_name_in_vendors("FUJITSU"))\r\ndmi_walk(dmi_check_onboard_devices, &priv->adapter);\r\n}\r\nstatic void __init input_apanel_init(void) {}\r\nstatic void i801_probe_optional_slaves(struct i801_priv *priv) {}\r\nstatic int i801_add_mux(struct i801_priv *priv)\r\n{\r\nstruct device *dev = &priv->adapter.dev;\r\nconst struct i801_mux_config *mux_config;\r\nstruct i2c_mux_gpio_platform_data gpio_data;\r\nint err;\r\nif (!priv->mux_drvdata)\r\nreturn 0;\r\nmux_config = priv->mux_drvdata;\r\nmemset(&gpio_data, 0, sizeof(struct i2c_mux_gpio_platform_data));\r\ngpio_data.parent = priv->adapter.nr;\r\ngpio_data.values = mux_config->values;\r\ngpio_data.n_values = mux_config->n_values;\r\ngpio_data.classes = mux_config->classes;\r\ngpio_data.gpio_chip = mux_config->gpio_chip;\r\ngpio_data.gpios = mux_config->gpios;\r\ngpio_data.n_gpios = mux_config->n_gpios;\r\ngpio_data.idle = I2C_MUX_GPIO_NO_IDLE;\r\npriv->mux_pdev = platform_device_register_data(dev, "i2c-mux-gpio",\r\nPLATFORM_DEVID_AUTO, &gpio_data,\r\nsizeof(struct i2c_mux_gpio_platform_data));\r\nif (IS_ERR(priv->mux_pdev)) {\r\nerr = PTR_ERR(priv->mux_pdev);\r\npriv->mux_pdev = NULL;\r\ndev_err(dev, "Failed to register i2c-mux-gpio device\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void i801_del_mux(struct i801_priv *priv)\r\n{\r\nif (priv->mux_pdev)\r\nplatform_device_unregister(priv->mux_pdev);\r\n}\r\nstatic unsigned int i801_get_adapter_class(struct i801_priv *priv)\r\n{\r\nconst struct dmi_system_id *id;\r\nconst struct i801_mux_config *mux_config;\r\nunsigned int class = I2C_CLASS_HWMON | I2C_CLASS_SPD;\r\nint i;\r\nid = dmi_first_match(mux_dmi_table);\r\nif (id) {\r\nmux_config = id->driver_data;\r\nfor (i = 0; i < mux_config->n_values; i++)\r\nclass &= ~mux_config->classes[i];\r\npriv->mux_drvdata = mux_config;\r\n}\r\nreturn class;\r\n}\r\nstatic inline int i801_add_mux(struct i801_priv *priv) { return 0; }\r\nstatic inline void i801_del_mux(struct i801_priv *priv) { }\r\nstatic inline unsigned int i801_get_adapter_class(struct i801_priv *priv)\r\n{\r\nreturn I2C_CLASS_HWMON | I2C_CLASS_SPD;\r\n}\r\nstatic void i801_add_tco(struct i801_priv *priv)\r\n{\r\nstruct pci_dev *pci_dev = priv->pci_dev;\r\nstruct resource tco_res[3], *res;\r\nstruct platform_device *pdev;\r\nunsigned int devfn;\r\nu32 tco_base, tco_ctl;\r\nu32 base_addr, ctrl_val;\r\nu64 base64_addr;\r\nif (!(priv->features & FEATURE_TCO))\r\nreturn;\r\npci_read_config_dword(pci_dev, TCOBASE, &tco_base);\r\npci_read_config_dword(pci_dev, TCOCTL, &tco_ctl);\r\nif (!(tco_ctl & TCOCTL_EN))\r\nreturn;\r\nmemset(tco_res, 0, sizeof(tco_res));\r\nres = &tco_res[ICH_RES_IO_TCO];\r\nres->start = tco_base & ~1;\r\nres->end = res->start + 32 - 1;\r\nres->flags = IORESOURCE_IO;\r\ndevfn = PCI_DEVFN(PCI_SLOT(pci_dev->devfn), 2);\r\npci_bus_read_config_dword(pci_dev->bus, devfn, ACPIBASE, &base_addr);\r\nres = &tco_res[ICH_RES_IO_SMI];\r\nres->start = (base_addr & ~1) + ACPIBASE_SMI_OFF;\r\nres->end = res->start + 3;\r\nres->flags = IORESOURCE_IO;\r\npci_bus_read_config_dword(pci_dev->bus, devfn, ACPICTRL, &ctrl_val);\r\nctrl_val |= ACPICTRL_EN;\r\npci_bus_write_config_dword(pci_dev->bus, devfn, ACPICTRL, ctrl_val);\r\nspin_lock(&p2sb_spinlock);\r\ndevfn = PCI_DEVFN(PCI_SLOT(pci_dev->devfn), 1);\r\npci_bus_write_config_byte(pci_dev->bus, devfn, 0xe1, 0x0);\r\npci_bus_read_config_dword(pci_dev->bus, devfn, SBREG_BAR, &base_addr);\r\nbase64_addr = base_addr & 0xfffffff0;\r\npci_bus_read_config_dword(pci_dev->bus, devfn, SBREG_BAR + 0x4, &base_addr);\r\nbase64_addr |= (u64)base_addr << 32;\r\npci_bus_write_config_byte(pci_dev->bus, devfn, 0xe1, 0x1);\r\nspin_unlock(&p2sb_spinlock);\r\nres = &tco_res[ICH_RES_MEM_OFF];\r\nres->start = (resource_size_t)base64_addr + SBREG_SMBCTRL;\r\nres->end = res->start + 3;\r\nres->flags = IORESOURCE_MEM;\r\npdev = platform_device_register_resndata(&pci_dev->dev, "iTCO_wdt", -1,\r\ntco_res, 3, &tco_platform_data,\r\nsizeof(tco_platform_data));\r\nif (IS_ERR(pdev)) {\r\ndev_warn(&pci_dev->dev, "failed to create iTCO device\n");\r\nreturn;\r\n}\r\npriv->tco_pdev = pdev;\r\n}\r\nstatic acpi_status\r\ni801_acpi_io_handler(u32 function, acpi_physical_address address, u32 bits,\r\nu64 *value, void *handler_context, void *region_context)\r\n{\r\nstruct i801_priv *priv = handler_context;\r\nstruct pci_dev *pdev = priv->pci_dev;\r\nacpi_status status;\r\nmutex_lock(&priv->acpi_lock);\r\nif (!priv->acpi_reserved) {\r\npriv->acpi_reserved = true;\r\ndev_warn(&pdev->dev, "BIOS is accessing SMBus registers\n");\r\ndev_warn(&pdev->dev, "Driver SMBus register access inhibited\n");\r\npm_runtime_get_sync(&pdev->dev);\r\n}\r\nif ((function & ACPI_IO_MASK) == ACPI_READ)\r\nstatus = acpi_os_read_port(address, (u32 *)value, bits);\r\nelse\r\nstatus = acpi_os_write_port(address, (u32)*value, bits);\r\nmutex_unlock(&priv->acpi_lock);\r\nreturn status;\r\n}\r\nstatic int i801_acpi_probe(struct i801_priv *priv)\r\n{\r\nstruct acpi_device *adev;\r\nacpi_status status;\r\nadev = ACPI_COMPANION(&priv->pci_dev->dev);\r\nif (adev) {\r\nstatus = acpi_install_address_space_handler(adev->handle,\r\nACPI_ADR_SPACE_SYSTEM_IO, i801_acpi_io_handler,\r\nNULL, priv);\r\nif (ACPI_SUCCESS(status))\r\nreturn 0;\r\n}\r\nreturn acpi_check_resource_conflict(&priv->pci_dev->resource[SMBBAR]);\r\n}\r\nstatic void i801_acpi_remove(struct i801_priv *priv)\r\n{\r\nstruct acpi_device *adev;\r\nadev = ACPI_COMPANION(&priv->pci_dev->dev);\r\nif (!adev)\r\nreturn;\r\nacpi_remove_address_space_handler(adev->handle,\r\nACPI_ADR_SPACE_SYSTEM_IO, i801_acpi_io_handler);\r\nmutex_lock(&priv->acpi_lock);\r\nif (priv->acpi_reserved)\r\npm_runtime_put(&priv->pci_dev->dev);\r\nmutex_unlock(&priv->acpi_lock);\r\n}\r\nstatic inline int i801_acpi_probe(struct i801_priv *priv) { return 0; }\r\nstatic inline void i801_acpi_remove(struct i801_priv *priv) { }\r\nstatic int i801_probe(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nunsigned char temp;\r\nint err, i;\r\nstruct i801_priv *priv;\r\npriv = devm_kzalloc(&dev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\ni2c_set_adapdata(&priv->adapter, priv);\r\npriv->adapter.owner = THIS_MODULE;\r\npriv->adapter.class = i801_get_adapter_class(priv);\r\npriv->adapter.algo = &smbus_algorithm;\r\npriv->adapter.dev.parent = &dev->dev;\r\nACPI_COMPANION_SET(&priv->adapter.dev, ACPI_COMPANION(&dev->dev));\r\npriv->adapter.retries = 3;\r\nmutex_init(&priv->acpi_lock);\r\npriv->pci_dev = dev;\r\nswitch (dev->device) {\r\ncase PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_SMBUS:\r\ncase PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_SMBUS:\r\ncase PCI_DEVICE_ID_INTEL_LEWISBURG_SMBUS:\r\ncase PCI_DEVICE_ID_INTEL_LEWISBURG_SSKU_SMBUS:\r\ncase PCI_DEVICE_ID_INTEL_DNV_SMBUS:\r\ncase PCI_DEVICE_ID_INTEL_KABYLAKE_PCH_H_SMBUS:\r\npriv->features |= FEATURE_I2C_BLOCK_READ;\r\npriv->features |= FEATURE_IRQ;\r\npriv->features |= FEATURE_SMBUS_PEC;\r\npriv->features |= FEATURE_BLOCK_BUFFER;\r\nif (!acpi_has_watchdog())\r\npriv->features |= FEATURE_TCO;\r\npriv->features |= FEATURE_HOST_NOTIFY;\r\nbreak;\r\ncase PCI_DEVICE_ID_INTEL_PATSBURG_SMBUS_IDF0:\r\ncase PCI_DEVICE_ID_INTEL_PATSBURG_SMBUS_IDF1:\r\ncase PCI_DEVICE_ID_INTEL_PATSBURG_SMBUS_IDF2:\r\ncase PCI_DEVICE_ID_INTEL_WELLSBURG_SMBUS_MS0:\r\ncase PCI_DEVICE_ID_INTEL_WELLSBURG_SMBUS_MS1:\r\ncase PCI_DEVICE_ID_INTEL_WELLSBURG_SMBUS_MS2:\r\npriv->features |= FEATURE_IDF;\r\ndefault:\r\npriv->features |= FEATURE_I2C_BLOCK_READ;\r\npriv->features |= FEATURE_IRQ;\r\ncase PCI_DEVICE_ID_INTEL_82801DB_3:\r\npriv->features |= FEATURE_SMBUS_PEC;\r\npriv->features |= FEATURE_BLOCK_BUFFER;\r\ncase PCI_DEVICE_ID_INTEL_82801CA_3:\r\npriv->features |= FEATURE_HOST_NOTIFY;\r\ncase PCI_DEVICE_ID_INTEL_82801BA_2:\r\ncase PCI_DEVICE_ID_INTEL_82801AB_3:\r\ncase PCI_DEVICE_ID_INTEL_82801AA_3:\r\nbreak;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(i801_feature_names); i++) {\r\nif (priv->features & disable_features & (1 << i))\r\ndev_notice(&dev->dev, "%s disabled by user\n",\r\ni801_feature_names[i]);\r\n}\r\npriv->features &= ~disable_features;\r\nerr = pcim_enable_device(dev);\r\nif (err) {\r\ndev_err(&dev->dev, "Failed to enable SMBus PCI device (%d)\n",\r\nerr);\r\nreturn err;\r\n}\r\npcim_pin_device(dev);\r\npriv->smba = pci_resource_start(dev, SMBBAR);\r\nif (!priv->smba) {\r\ndev_err(&dev->dev,\r\n"SMBus base address uninitialized, upgrade BIOS\n");\r\nreturn -ENODEV;\r\n}\r\nif (i801_acpi_probe(priv))\r\nreturn -ENODEV;\r\nerr = pcim_iomap_regions(dev, 1 << SMBBAR,\r\ndev_driver_string(&dev->dev));\r\nif (err) {\r\ndev_err(&dev->dev,\r\n"Failed to request SMBus region 0x%lx-0x%Lx\n",\r\npriv->smba,\r\n(unsigned long long)pci_resource_end(dev, SMBBAR));\r\ni801_acpi_remove(priv);\r\nreturn err;\r\n}\r\npci_read_config_byte(priv->pci_dev, SMBHSTCFG, &temp);\r\npriv->original_hstcfg = temp;\r\ntemp &= ~SMBHSTCFG_I2C_EN;\r\nif (!(temp & SMBHSTCFG_HST_EN)) {\r\ndev_info(&dev->dev, "Enabling SMBus device\n");\r\ntemp |= SMBHSTCFG_HST_EN;\r\n}\r\npci_write_config_byte(priv->pci_dev, SMBHSTCFG, temp);\r\nif (temp & SMBHSTCFG_SMB_SMI_EN) {\r\ndev_dbg(&dev->dev, "SMBus using interrupt SMI#\n");\r\npriv->features &= ~FEATURE_IRQ;\r\n}\r\nif (temp & SMBHSTCFG_SPD_WD)\r\ndev_info(&dev->dev, "SPD Write Disable is set\n");\r\nif (priv->features & (FEATURE_SMBUS_PEC | FEATURE_BLOCK_BUFFER))\r\noutb_p(inb_p(SMBAUXCTL(priv)) &\r\n~(SMBAUXCTL_CRC | SMBAUXCTL_E32B), SMBAUXCTL(priv));\r\npriv->adapter.timeout = HZ / 5;\r\nif (priv->features & FEATURE_IRQ) {\r\nu16 pcictl, pcists;\r\npci_read_config_word(priv->pci_dev, SMBPCISTS, &pcists);\r\nif (pcists & SMBPCISTS_INTS)\r\ndev_warn(&dev->dev, "An interrupt is pending!\n");\r\npci_read_config_word(priv->pci_dev, SMBPCICTL, &pcictl);\r\nif (pcictl & SMBPCICTL_INTDIS) {\r\ndev_info(&dev->dev, "Interrupts are disabled\n");\r\npriv->features &= ~FEATURE_IRQ;\r\n}\r\n}\r\nif (priv->features & FEATURE_IRQ) {\r\ninit_waitqueue_head(&priv->waitq);\r\nerr = devm_request_irq(&dev->dev, dev->irq, i801_isr,\r\nIRQF_SHARED,\r\ndev_driver_string(&dev->dev), priv);\r\nif (err) {\r\ndev_err(&dev->dev, "Failed to allocate irq %d: %d\n",\r\ndev->irq, err);\r\npriv->features &= ~FEATURE_IRQ;\r\n}\r\n}\r\ndev_info(&dev->dev, "SMBus using %s\n",\r\npriv->features & FEATURE_IRQ ? "PCI interrupt" : "polling");\r\ni801_add_tco(priv);\r\nsnprintf(priv->adapter.name, sizeof(priv->adapter.name),\r\n"SMBus I801 adapter at %04lx", priv->smba);\r\nerr = i2c_add_adapter(&priv->adapter);\r\nif (err) {\r\ni801_acpi_remove(priv);\r\nreturn err;\r\n}\r\ni801_enable_host_notify(&priv->adapter);\r\ni801_probe_optional_slaves(priv);\r\ni801_add_mux(priv);\r\npci_set_drvdata(dev, priv);\r\npm_runtime_set_autosuspend_delay(&dev->dev, 1000);\r\npm_runtime_use_autosuspend(&dev->dev);\r\npm_runtime_put_autosuspend(&dev->dev);\r\npm_runtime_allow(&dev->dev);\r\nreturn 0;\r\n}\r\nstatic void i801_remove(struct pci_dev *dev)\r\n{\r\nstruct i801_priv *priv = pci_get_drvdata(dev);\r\npm_runtime_forbid(&dev->dev);\r\npm_runtime_get_noresume(&dev->dev);\r\ni801_disable_host_notify(priv);\r\ni801_del_mux(priv);\r\ni2c_del_adapter(&priv->adapter);\r\ni801_acpi_remove(priv);\r\npci_write_config_byte(dev, SMBHSTCFG, priv->original_hstcfg);\r\nplatform_device_unregister(priv->tco_pdev);\r\n}\r\nstatic int i801_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nstruct i801_priv *priv = pci_get_drvdata(pci_dev);\r\npci_write_config_byte(pci_dev, SMBHSTCFG, priv->original_hstcfg);\r\nreturn 0;\r\n}\r\nstatic int i801_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nstruct i801_priv *priv = pci_get_drvdata(pci_dev);\r\ni801_enable_host_notify(&priv->adapter);\r\nreturn 0;\r\n}\r\nstatic int __init i2c_i801_init(void)\r\n{\r\nif (dmi_name_in_vendors("FUJITSU"))\r\ninput_apanel_init();\r\nreturn pci_register_driver(&i801_driver);\r\n}\r\nstatic void __exit i2c_i801_exit(void)\r\n{\r\npci_unregister_driver(&i801_driver);\r\n}
