static int cp110_gate_enable(struct clk_hw *hw)\r\n{\r\nstruct cp110_gate_clk *gate = to_cp110_gate_clk(hw);\r\nregmap_update_bits(gate->regmap, CP110_PM_CLOCK_GATING_REG,\r\nBIT(gate->bit_idx), BIT(gate->bit_idx));\r\nreturn 0;\r\n}\r\nstatic void cp110_gate_disable(struct clk_hw *hw)\r\n{\r\nstruct cp110_gate_clk *gate = to_cp110_gate_clk(hw);\r\nregmap_update_bits(gate->regmap, CP110_PM_CLOCK_GATING_REG,\r\nBIT(gate->bit_idx), 0);\r\n}\r\nstatic int cp110_gate_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct cp110_gate_clk *gate = to_cp110_gate_clk(hw);\r\nu32 val;\r\nregmap_read(gate->regmap, CP110_PM_CLOCK_GATING_REG, &val);\r\nreturn val & BIT(gate->bit_idx);\r\n}\r\nstatic struct clk_hw *cp110_register_gate(const char *name,\r\nconst char *parent_name,\r\nstruct regmap *regmap, u8 bit_idx)\r\n{\r\nstruct cp110_gate_clk *gate;\r\nstruct clk_hw *hw;\r\nstruct clk_init_data init;\r\nint ret;\r\ngate = kzalloc(sizeof(*gate), GFP_KERNEL);\r\nif (!gate)\r\nreturn ERR_PTR(-ENOMEM);\r\nmemset(&init, 0, sizeof(init));\r\ninit.name = name;\r\ninit.ops = &cp110_gate_ops;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\ngate->regmap = regmap;\r\ngate->bit_idx = bit_idx;\r\ngate->hw.init = &init;\r\nhw = &gate->hw;\r\nret = clk_hw_register(NULL, hw);\r\nif (ret) {\r\nkfree(gate);\r\nhw = ERR_PTR(ret);\r\n}\r\nreturn hw;\r\n}\r\nstatic void cp110_unregister_gate(struct clk_hw *hw)\r\n{\r\nclk_hw_unregister(hw);\r\nkfree(to_cp110_gate_clk(hw));\r\n}\r\nstatic struct clk_hw *cp110_of_clk_get(struct of_phandle_args *clkspec,\r\nvoid *data)\r\n{\r\nstruct clk_hw_onecell_data *clk_data = data;\r\nunsigned int type = clkspec->args[0];\r\nunsigned int idx = clkspec->args[1];\r\nif (type == CP110_CLK_TYPE_CORE) {\r\nif (idx > CP110_MAX_CORE_CLOCKS)\r\nreturn ERR_PTR(-EINVAL);\r\nreturn clk_data->hws[idx];\r\n} else if (type == CP110_CLK_TYPE_GATABLE) {\r\nif (idx > CP110_MAX_GATABLE_CLOCKS)\r\nreturn ERR_PTR(-EINVAL);\r\nreturn clk_data->hws[CP110_MAX_CORE_CLOCKS + idx];\r\n}\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic int cp110_syscon_clk_probe(struct platform_device *pdev)\r\n{\r\nstruct regmap *regmap;\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst char *ppv2_name, *apll_name, *core_name, *eip_name, *nand_name;\r\nstruct clk_hw_onecell_data *cp110_clk_data;\r\nstruct clk_hw *hw, **cp110_clks;\r\nu32 nand_clk_ctrl;\r\nint i, ret;\r\nregmap = syscon_node_to_regmap(np);\r\nif (IS_ERR(regmap))\r\nreturn PTR_ERR(regmap);\r\nret = regmap_read(regmap, CP110_NAND_FLASH_CLK_CTRL_REG,\r\n&nand_clk_ctrl);\r\nif (ret)\r\nreturn ret;\r\ncp110_clk_data = devm_kzalloc(&pdev->dev, sizeof(*cp110_clk_data) +\r\nsizeof(struct clk_hw *) * CP110_CLK_NUM,\r\nGFP_KERNEL);\r\nif (!cp110_clk_data)\r\nreturn -ENOMEM;\r\ncp110_clks = cp110_clk_data->hws;\r\ncp110_clk_data->num = CP110_CLK_NUM;\r\nof_property_read_string_index(np, "core-clock-output-names",\r\nCP110_CORE_APLL, &apll_name);\r\nhw = clk_hw_register_fixed_rate(NULL, apll_name, NULL, 0,\r\n1000 * 1000 * 1000);\r\nif (IS_ERR(hw)) {\r\nret = PTR_ERR(hw);\r\ngoto fail0;\r\n}\r\ncp110_clks[CP110_CORE_APLL] = hw;\r\nof_property_read_string_index(np, "core-clock-output-names",\r\nCP110_CORE_PPV2, &ppv2_name);\r\nhw = clk_hw_register_fixed_factor(NULL, ppv2_name, apll_name, 0, 1, 3);\r\nif (IS_ERR(hw)) {\r\nret = PTR_ERR(hw);\r\ngoto fail1;\r\n}\r\ncp110_clks[CP110_CORE_PPV2] = hw;\r\nof_property_read_string_index(np, "core-clock-output-names",\r\nCP110_CORE_EIP, &eip_name);\r\nhw = clk_hw_register_fixed_factor(NULL, eip_name, apll_name, 0, 1, 2);\r\nif (IS_ERR(hw)) {\r\nret = PTR_ERR(hw);\r\ngoto fail2;\r\n}\r\ncp110_clks[CP110_CORE_EIP] = hw;\r\nof_property_read_string_index(np, "core-clock-output-names",\r\nCP110_CORE_CORE, &core_name);\r\nhw = clk_hw_register_fixed_factor(NULL, core_name, eip_name, 0, 1, 2);\r\nif (IS_ERR(hw)) {\r\nret = PTR_ERR(hw);\r\ngoto fail3;\r\n}\r\ncp110_clks[CP110_CORE_CORE] = hw;\r\nof_property_read_string_index(np, "core-clock-output-names",\r\nCP110_CORE_NAND, &nand_name);\r\nif (nand_clk_ctrl & NF_CLOCK_SEL_400_MASK)\r\nhw = clk_hw_register_fixed_factor(NULL, nand_name,\r\napll_name, 0, 2, 5);\r\nelse\r\nhw = clk_hw_register_fixed_factor(NULL, nand_name,\r\ncore_name, 0, 1, 1);\r\nif (IS_ERR(hw)) {\r\nret = PTR_ERR(hw);\r\ngoto fail4;\r\n}\r\ncp110_clks[CP110_CORE_NAND] = hw;\r\nfor (i = 0; i < CP110_MAX_GATABLE_CLOCKS; i++) {\r\nconst char *parent, *name;\r\nint ret;\r\nret = of_property_read_string_index(np,\r\n"gate-clock-output-names",\r\ni, &name);\r\nif (ret < 0)\r\nbreak;\r\nif (!strcmp(name, "none"))\r\ncontinue;\r\nswitch (i) {\r\ncase CP110_GATE_AUDIO:\r\ncase CP110_GATE_COMM_UNIT:\r\ncase CP110_GATE_EIP150:\r\ncase CP110_GATE_EIP197:\r\ncase CP110_GATE_SLOW_IO:\r\nof_property_read_string_index(np,\r\n"gate-clock-output-names",\r\nCP110_GATE_MAIN, &parent);\r\nbreak;\r\ncase CP110_GATE_MG:\r\nof_property_read_string_index(np,\r\n"gate-clock-output-names",\r\nCP110_GATE_MG_CORE, &parent);\r\nbreak;\r\ncase CP110_GATE_NAND:\r\nparent = nand_name;\r\nbreak;\r\ncase CP110_GATE_PPV2:\r\nparent = ppv2_name;\r\nbreak;\r\ncase CP110_GATE_SDIO:\r\ncase CP110_GATE_GOP_DP:\r\nof_property_read_string_index(np,\r\n"gate-clock-output-names",\r\nCP110_GATE_SDMMC_GOP, &parent);\r\nbreak;\r\ncase CP110_GATE_XOR1:\r\ncase CP110_GATE_XOR0:\r\ncase CP110_GATE_PCIE_X1_0:\r\ncase CP110_GATE_PCIE_X1_1:\r\ncase CP110_GATE_PCIE_X4:\r\nof_property_read_string_index(np,\r\n"gate-clock-output-names",\r\nCP110_GATE_PCIE_XOR, &parent);\r\nbreak;\r\ncase CP110_GATE_SATA:\r\ncase CP110_GATE_USB3H0:\r\ncase CP110_GATE_USB3H1:\r\ncase CP110_GATE_USB3DEV:\r\nof_property_read_string_index(np,\r\n"gate-clock-output-names",\r\nCP110_GATE_SATA_USB, &parent);\r\nbreak;\r\ndefault:\r\nparent = core_name;\r\nbreak;\r\n}\r\nhw = cp110_register_gate(name, parent, regmap, i);\r\nif (IS_ERR(hw)) {\r\nret = PTR_ERR(hw);\r\ngoto fail_gate;\r\n}\r\ncp110_clks[CP110_MAX_CORE_CLOCKS + i] = hw;\r\n}\r\nret = of_clk_add_hw_provider(np, cp110_of_clk_get, cp110_clk_data);\r\nif (ret)\r\ngoto fail_clk_add;\r\nplatform_set_drvdata(pdev, cp110_clks);\r\nreturn 0;\r\nfail_clk_add:\r\nfail_gate:\r\nfor (i = 0; i < CP110_MAX_GATABLE_CLOCKS; i++) {\r\nhw = cp110_clks[CP110_MAX_CORE_CLOCKS + i];\r\nif (hw)\r\ncp110_unregister_gate(hw);\r\n}\r\nclk_hw_unregister_fixed_factor(cp110_clks[CP110_CORE_NAND]);\r\nfail4:\r\nclk_hw_unregister_fixed_factor(cp110_clks[CP110_CORE_CORE]);\r\nfail3:\r\nclk_hw_unregister_fixed_factor(cp110_clks[CP110_CORE_EIP]);\r\nfail2:\r\nclk_hw_unregister_fixed_factor(cp110_clks[CP110_CORE_PPV2]);\r\nfail1:\r\nclk_hw_unregister_fixed_rate(cp110_clks[CP110_CORE_APLL]);\r\nfail0:\r\nreturn ret;\r\n}
