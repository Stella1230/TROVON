void ax25_clear_queues(ax25_cb *ax25)\r\n{\r\nskb_queue_purge(&ax25->write_queue);\r\nskb_queue_purge(&ax25->ack_queue);\r\nskb_queue_purge(&ax25->reseq_queue);\r\nskb_queue_purge(&ax25->frag_queue);\r\n}\r\nvoid ax25_frames_acked(ax25_cb *ax25, unsigned short nr)\r\n{\r\nstruct sk_buff *skb;\r\nif (ax25->va != nr) {\r\nwhile (skb_peek(&ax25->ack_queue) != NULL && ax25->va != nr) {\r\nskb = skb_dequeue(&ax25->ack_queue);\r\nkfree_skb(skb);\r\nax25->va = (ax25->va + 1) % ax25->modulus;\r\n}\r\n}\r\n}\r\nvoid ax25_requeue_frames(ax25_cb *ax25)\r\n{\r\nstruct sk_buff *skb;\r\nwhile ((skb = skb_dequeue_tail(&ax25->ack_queue)) != NULL)\r\nskb_queue_head(&ax25->write_queue, skb);\r\n}\r\nint ax25_validate_nr(ax25_cb *ax25, unsigned short nr)\r\n{\r\nunsigned short vc = ax25->va;\r\nwhile (vc != ax25->vs) {\r\nif (nr == vc) return 1;\r\nvc = (vc + 1) % ax25->modulus;\r\n}\r\nif (nr == ax25->vs) return 1;\r\nreturn 0;\r\n}\r\nint ax25_decode(ax25_cb *ax25, struct sk_buff *skb, int *ns, int *nr, int *pf)\r\n{\r\nunsigned char *frame;\r\nint frametype = AX25_ILLEGAL;\r\nframe = skb->data;\r\n*ns = *nr = *pf = 0;\r\nif (ax25->modulus == AX25_MODULUS) {\r\nif ((frame[0] & AX25_S) == 0) {\r\nframetype = AX25_I;\r\n*ns = (frame[0] >> 1) & 0x07;\r\n*nr = (frame[0] >> 5) & 0x07;\r\n*pf = frame[0] & AX25_PF;\r\n} else if ((frame[0] & AX25_U) == 1) {\r\nframetype = frame[0] & 0x0F;\r\n*nr = (frame[0] >> 5) & 0x07;\r\n*pf = frame[0] & AX25_PF;\r\n} else if ((frame[0] & AX25_U) == 3) {\r\nframetype = frame[0] & ~AX25_PF;\r\n*pf = frame[0] & AX25_PF;\r\n}\r\nskb_pull(skb, 1);\r\n} else {\r\nif ((frame[0] & AX25_S) == 0) {\r\nframetype = AX25_I;\r\n*ns = (frame[0] >> 1) & 0x7F;\r\n*nr = (frame[1] >> 1) & 0x7F;\r\n*pf = frame[1] & AX25_EPF;\r\nskb_pull(skb, 2);\r\n} else if ((frame[0] & AX25_U) == 1) {\r\nframetype = frame[0] & 0x0F;\r\n*nr = (frame[1] >> 1) & 0x7F;\r\n*pf = frame[1] & AX25_EPF;\r\nskb_pull(skb, 2);\r\n} else if ((frame[0] & AX25_U) == 3) {\r\nframetype = frame[0] & ~AX25_PF;\r\n*pf = frame[0] & AX25_PF;\r\nskb_pull(skb, 1);\r\n}\r\n}\r\nreturn frametype;\r\n}\r\nvoid ax25_send_control(ax25_cb *ax25, int frametype, int poll_bit, int type)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned char *dptr;\r\nif ((skb = alloc_skb(ax25->ax25_dev->dev->hard_header_len + 2, GFP_ATOMIC)) == NULL)\r\nreturn;\r\nskb_reserve(skb, ax25->ax25_dev->dev->hard_header_len);\r\nskb_reset_network_header(skb);\r\nif (ax25->modulus == AX25_MODULUS) {\r\ndptr = skb_put(skb, 1);\r\n*dptr = frametype;\r\n*dptr |= (poll_bit) ? AX25_PF : 0;\r\nif ((frametype & AX25_U) == AX25_S)\r\n*dptr |= (ax25->vr << 5);\r\n} else {\r\nif ((frametype & AX25_U) == AX25_U) {\r\ndptr = skb_put(skb, 1);\r\n*dptr = frametype;\r\n*dptr |= (poll_bit) ? AX25_PF : 0;\r\n} else {\r\ndptr = skb_put(skb, 2);\r\ndptr[0] = frametype;\r\ndptr[1] = (ax25->vr << 1);\r\ndptr[1] |= (poll_bit) ? AX25_EPF : 0;\r\n}\r\n}\r\nax25_transmit_buffer(ax25, skb, type);\r\n}\r\nvoid ax25_return_dm(struct net_device *dev, ax25_address *src, ax25_address *dest, ax25_digi *digi)\r\n{\r\nstruct sk_buff *skb;\r\nchar *dptr;\r\nax25_digi retdigi;\r\nif (dev == NULL)\r\nreturn;\r\nif ((skb = alloc_skb(dev->hard_header_len + 1, GFP_ATOMIC)) == NULL)\r\nreturn;\r\nskb_reserve(skb, dev->hard_header_len);\r\nskb_reset_network_header(skb);\r\nax25_digi_invert(digi, &retdigi);\r\ndptr = skb_put(skb, 1);\r\n*dptr = AX25_DM | AX25_PF;\r\ndptr = skb_push(skb, ax25_addr_size(digi));\r\ndptr += ax25_addr_build(dptr, dest, src, &retdigi, AX25_RESPONSE, AX25_MODULUS);\r\nax25_queue_xmit(skb, dev);\r\n}\r\nvoid ax25_calculate_t1(ax25_cb *ax25)\r\n{\r\nint n, t = 2;\r\nswitch (ax25->backoff) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nt += 2 * ax25->n2count;\r\nbreak;\r\ncase 2:\r\nfor (n = 0; n < ax25->n2count; n++)\r\nt *= 2;\r\nif (t > 8) t = 8;\r\nbreak;\r\n}\r\nax25->t1 = t * ax25->rtt;\r\n}\r\nvoid ax25_calculate_rtt(ax25_cb *ax25)\r\n{\r\nif (ax25->backoff == 0)\r\nreturn;\r\nif (ax25_t1timer_running(ax25) && ax25->n2count == 0)\r\nax25->rtt = (9 * ax25->rtt + ax25->t1 - ax25_display_timer(&ax25->t1timer)) / 10;\r\nif (ax25->rtt < AX25_T1CLAMPLO)\r\nax25->rtt = AX25_T1CLAMPLO;\r\nif (ax25->rtt > AX25_T1CLAMPHI)\r\nax25->rtt = AX25_T1CLAMPHI;\r\n}\r\nvoid ax25_disconnect(ax25_cb *ax25, int reason)\r\n{\r\nax25_clear_queues(ax25);\r\nif (!ax25->sk || !sock_flag(ax25->sk, SOCK_DESTROY))\r\nax25_stop_heartbeat(ax25);\r\nax25_stop_t1timer(ax25);\r\nax25_stop_t2timer(ax25);\r\nax25_stop_t3timer(ax25);\r\nax25_stop_idletimer(ax25);\r\nax25->state = AX25_STATE_0;\r\nax25_link_failed(ax25, reason);\r\nif (ax25->sk != NULL) {\r\nlocal_bh_disable();\r\nbh_lock_sock(ax25->sk);\r\nax25->sk->sk_state = TCP_CLOSE;\r\nax25->sk->sk_err = reason;\r\nax25->sk->sk_shutdown |= SEND_SHUTDOWN;\r\nif (!sock_flag(ax25->sk, SOCK_DEAD)) {\r\nax25->sk->sk_state_change(ax25->sk);\r\nsock_set_flag(ax25->sk, SOCK_DEAD);\r\n}\r\nbh_unlock_sock(ax25->sk);\r\nlocal_bh_enable();\r\n}\r\n}
