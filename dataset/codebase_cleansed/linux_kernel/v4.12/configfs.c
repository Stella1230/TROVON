int check_user_usb_string(const char *name,\r\nstruct usb_gadget_strings *stringtab_dev)\r\n{\r\nunsigned primary_lang;\r\nunsigned sub_lang;\r\nu16 num;\r\nint ret;\r\nret = kstrtou16(name, 0, &num);\r\nif (ret)\r\nreturn ret;\r\nprimary_lang = num & 0x3ff;\r\nsub_lang = num >> 10;\r\nswitch (primary_lang) {\r\ncase 0:\r\ncase 0x62 ... 0xfe:\r\ncase 0x100 ... 0x3ff:\r\nreturn -EINVAL;\r\n}\r\nif (!sub_lang)\r\nreturn -EINVAL;\r\nstringtab_dev->language = num;\r\nreturn 0;\r\n}\r\nstatic inline struct gadget_info *to_gadget_info(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct gadget_info, group);\r\n}\r\nstatic inline struct config_usb_cfg *to_config_usb_cfg(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct config_usb_cfg,\r\ngroup);\r\n}\r\nstatic int usb_string_copy(const char *s, char **s_copy)\r\n{\r\nint ret;\r\nchar *str;\r\nchar *copy = *s_copy;\r\nret = strlen(s);\r\nif (ret > 126)\r\nreturn -EOVERFLOW;\r\nstr = kstrdup(s, GFP_KERNEL);\r\nif (!str)\r\nreturn -ENOMEM;\r\nif (str[ret - 1] == '\n')\r\nstr[ret - 1] = '\0';\r\nkfree(copy);\r\n*s_copy = str;\r\nreturn 0;\r\n}\r\nstatic ssize_t is_valid_bcd(u16 bcd_val)\r\n{\r\nif ((bcd_val & 0xf) > 9)\r\nreturn -EINVAL;\r\nif (((bcd_val >> 4) & 0xf) > 9)\r\nreturn -EINVAL;\r\nif (((bcd_val >> 8) & 0xf) > 9)\r\nreturn -EINVAL;\r\nif (((bcd_val >> 12) & 0xf) > 9)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic ssize_t gadget_dev_desc_bcdDevice_store(struct config_item *item,\r\nconst char *page, size_t len)\r\n{\r\nu16 bcdDevice;\r\nint ret;\r\nret = kstrtou16(page, 0, &bcdDevice);\r\nif (ret)\r\nreturn ret;\r\nret = is_valid_bcd(bcdDevice);\r\nif (ret)\r\nreturn ret;\r\nto_gadget_info(item)->cdev.desc.bcdDevice = cpu_to_le16(bcdDevice);\r\nreturn len;\r\n}\r\nstatic ssize_t gadget_dev_desc_bcdUSB_store(struct config_item *item,\r\nconst char *page, size_t len)\r\n{\r\nu16 bcdUSB;\r\nint ret;\r\nret = kstrtou16(page, 0, &bcdUSB);\r\nif (ret)\r\nreturn ret;\r\nret = is_valid_bcd(bcdUSB);\r\nif (ret)\r\nreturn ret;\r\nto_gadget_info(item)->cdev.desc.bcdUSB = cpu_to_le16(bcdUSB);\r\nreturn len;\r\n}\r\nstatic ssize_t gadget_dev_desc_UDC_show(struct config_item *item, char *page)\r\n{\r\nchar *udc_name = to_gadget_info(item)->composite.gadget_driver.udc_name;\r\nreturn sprintf(page, "%s\n", udc_name ?: "");\r\n}\r\nstatic int unregister_gadget(struct gadget_info *gi)\r\n{\r\nint ret;\r\nif (!gi->composite.gadget_driver.udc_name)\r\nreturn -ENODEV;\r\nret = usb_gadget_unregister_driver(&gi->composite.gadget_driver);\r\nif (ret)\r\nreturn ret;\r\nkfree(gi->composite.gadget_driver.udc_name);\r\ngi->composite.gadget_driver.udc_name = NULL;\r\nreturn 0;\r\n}\r\nstatic ssize_t gadget_dev_desc_UDC_store(struct config_item *item,\r\nconst char *page, size_t len)\r\n{\r\nstruct gadget_info *gi = to_gadget_info(item);\r\nchar *name;\r\nint ret;\r\nname = kstrdup(page, GFP_KERNEL);\r\nif (!name)\r\nreturn -ENOMEM;\r\nif (name[len - 1] == '\n')\r\nname[len - 1] = '\0';\r\nmutex_lock(&gi->lock);\r\nif (!strlen(name)) {\r\nret = unregister_gadget(gi);\r\nif (ret)\r\ngoto err;\r\nkfree(name);\r\n} else {\r\nif (gi->composite.gadget_driver.udc_name) {\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\ngi->composite.gadget_driver.udc_name = name;\r\nret = usb_gadget_probe_driver(&gi->composite.gadget_driver);\r\nif (ret) {\r\ngi->composite.gadget_driver.udc_name = NULL;\r\ngoto err;\r\n}\r\n}\r\nmutex_unlock(&gi->lock);\r\nreturn len;\r\nerr:\r\nkfree(name);\r\nmutex_unlock(&gi->lock);\r\nreturn ret;\r\n}\r\nstatic inline struct gadget_strings *to_gadget_strings(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct gadget_strings,\r\ngroup);\r\n}\r\nstatic inline struct gadget_config_name *to_gadget_config_name(\r\nstruct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct gadget_config_name,\r\ngroup);\r\n}\r\nstatic inline struct usb_function_instance *to_usb_function_instance(\r\nstruct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item),\r\nstruct usb_function_instance, group);\r\n}\r\nstatic void gadget_info_attr_release(struct config_item *item)\r\n{\r\nstruct gadget_info *gi = to_gadget_info(item);\r\nWARN_ON(!list_empty(&gi->cdev.configs));\r\nWARN_ON(!list_empty(&gi->string_list));\r\nWARN_ON(!list_empty(&gi->available_func));\r\nkfree(gi->composite.gadget_driver.function);\r\nkfree(gi);\r\n}\r\nstatic void gadget_config_attr_release(struct config_item *item)\r\n{\r\nstruct config_usb_cfg *cfg = to_config_usb_cfg(item);\r\nWARN_ON(!list_empty(&cfg->c.functions));\r\nlist_del(&cfg->c.list);\r\nkfree(cfg->c.label);\r\nkfree(cfg);\r\n}\r\nstatic int config_usb_cfg_link(\r\nstruct config_item *usb_cfg_ci,\r\nstruct config_item *usb_func_ci)\r\n{\r\nstruct config_usb_cfg *cfg = to_config_usb_cfg(usb_cfg_ci);\r\nstruct usb_composite_dev *cdev = cfg->c.cdev;\r\nstruct gadget_info *gi = container_of(cdev, struct gadget_info, cdev);\r\nstruct config_group *group = to_config_group(usb_func_ci);\r\nstruct usb_function_instance *fi = container_of(group,\r\nstruct usb_function_instance, group);\r\nstruct usb_function_instance *a_fi;\r\nstruct usb_function *f;\r\nint ret;\r\nmutex_lock(&gi->lock);\r\nlist_for_each_entry(a_fi, &gi->available_func, cfs_list) {\r\nif (a_fi == fi)\r\nbreak;\r\n}\r\nif (a_fi != fi) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nlist_for_each_entry(f, &cfg->func_list, list) {\r\nif (f->fi == fi) {\r\nret = -EEXIST;\r\ngoto out;\r\n}\r\n}\r\nf = usb_get_function(fi);\r\nif (IS_ERR(f)) {\r\nret = PTR_ERR(f);\r\ngoto out;\r\n}\r\nlist_add_tail(&f->list, &cfg->func_list);\r\nret = 0;\r\nout:\r\nmutex_unlock(&gi->lock);\r\nreturn ret;\r\n}\r\nstatic void config_usb_cfg_unlink(\r\nstruct config_item *usb_cfg_ci,\r\nstruct config_item *usb_func_ci)\r\n{\r\nstruct config_usb_cfg *cfg = to_config_usb_cfg(usb_cfg_ci);\r\nstruct usb_composite_dev *cdev = cfg->c.cdev;\r\nstruct gadget_info *gi = container_of(cdev, struct gadget_info, cdev);\r\nstruct config_group *group = to_config_group(usb_func_ci);\r\nstruct usb_function_instance *fi = container_of(group,\r\nstruct usb_function_instance, group);\r\nstruct usb_function *f;\r\nmutex_lock(&gi->lock);\r\nif (gi->composite.gadget_driver.udc_name)\r\nunregister_gadget(gi);\r\nWARN_ON(gi->composite.gadget_driver.udc_name);\r\nlist_for_each_entry(f, &cfg->func_list, list) {\r\nif (f->fi == fi) {\r\nlist_del(&f->list);\r\nusb_put_function(f);\r\nmutex_unlock(&gi->lock);\r\nreturn;\r\n}\r\n}\r\nmutex_unlock(&gi->lock);\r\nWARN(1, "Unable to locate function to unbind\n");\r\n}\r\nstatic ssize_t gadget_config_desc_MaxPower_show(struct config_item *item,\r\nchar *page)\r\n{\r\nreturn sprintf(page, "%u\n", to_config_usb_cfg(item)->c.MaxPower);\r\n}\r\nstatic ssize_t gadget_config_desc_MaxPower_store(struct config_item *item,\r\nconst char *page, size_t len)\r\n{\r\nu16 val;\r\nint ret;\r\nret = kstrtou16(page, 0, &val);\r\nif (ret)\r\nreturn ret;\r\nif (DIV_ROUND_UP(val, 8) > 0xff)\r\nreturn -ERANGE;\r\nto_config_usb_cfg(item)->c.MaxPower = val;\r\nreturn len;\r\n}\r\nstatic ssize_t gadget_config_desc_bmAttributes_show(struct config_item *item,\r\nchar *page)\r\n{\r\nreturn sprintf(page, "0x%02x\n",\r\nto_config_usb_cfg(item)->c.bmAttributes);\r\n}\r\nstatic ssize_t gadget_config_desc_bmAttributes_store(struct config_item *item,\r\nconst char *page, size_t len)\r\n{\r\nu8 val;\r\nint ret;\r\nret = kstrtou8(page, 0, &val);\r\nif (ret)\r\nreturn ret;\r\nif (!(val & USB_CONFIG_ATT_ONE))\r\nreturn -EINVAL;\r\nif (val & ~(USB_CONFIG_ATT_ONE | USB_CONFIG_ATT_SELFPOWER |\r\nUSB_CONFIG_ATT_WAKEUP))\r\nreturn -EINVAL;\r\nto_config_usb_cfg(item)->c.bmAttributes = val;\r\nreturn len;\r\n}\r\nstatic void composite_init_dev(struct usb_composite_dev *cdev)\r\n{\r\nspin_lock_init(&cdev->lock);\r\nINIT_LIST_HEAD(&cdev->configs);\r\nINIT_LIST_HEAD(&cdev->gstrings);\r\n}\r\nstatic struct config_group *function_make(\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct gadget_info *gi;\r\nstruct usb_function_instance *fi;\r\nchar buf[MAX_NAME_LEN];\r\nchar *func_name;\r\nchar *instance_name;\r\nint ret;\r\nret = snprintf(buf, MAX_NAME_LEN, "%s", name);\r\nif (ret >= MAX_NAME_LEN)\r\nreturn ERR_PTR(-ENAMETOOLONG);\r\nfunc_name = buf;\r\ninstance_name = strchr(func_name, '.');\r\nif (!instance_name) {\r\npr_err("Unable to locate . in FUNC.INSTANCE\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n*instance_name = '\0';\r\ninstance_name++;\r\nfi = usb_get_function_instance(func_name);\r\nif (IS_ERR(fi))\r\nreturn ERR_CAST(fi);\r\nret = config_item_set_name(&fi->group.cg_item, "%s", name);\r\nif (ret) {\r\nusb_put_function_instance(fi);\r\nreturn ERR_PTR(ret);\r\n}\r\nif (fi->set_inst_name) {\r\nret = fi->set_inst_name(fi, instance_name);\r\nif (ret) {\r\nusb_put_function_instance(fi);\r\nreturn ERR_PTR(ret);\r\n}\r\n}\r\ngi = container_of(group, struct gadget_info, functions_group);\r\nmutex_lock(&gi->lock);\r\nlist_add_tail(&fi->cfs_list, &gi->available_func);\r\nmutex_unlock(&gi->lock);\r\nreturn &fi->group;\r\n}\r\nstatic void function_drop(\r\nstruct config_group *group,\r\nstruct config_item *item)\r\n{\r\nstruct usb_function_instance *fi = to_usb_function_instance(item);\r\nstruct gadget_info *gi;\r\ngi = container_of(group, struct gadget_info, functions_group);\r\nmutex_lock(&gi->lock);\r\nlist_del(&fi->cfs_list);\r\nmutex_unlock(&gi->lock);\r\nconfig_item_put(item);\r\n}\r\nstatic void gadget_config_name_attr_release(struct config_item *item)\r\n{\r\nstruct gadget_config_name *cn = to_gadget_config_name(item);\r\nkfree(cn->configuration);\r\nlist_del(&cn->list);\r\nkfree(cn);\r\n}\r\nstatic struct config_group *config_desc_make(\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct gadget_info *gi;\r\nstruct config_usb_cfg *cfg;\r\nchar buf[MAX_NAME_LEN];\r\nchar *num_str;\r\nu8 num;\r\nint ret;\r\ngi = container_of(group, struct gadget_info, configs_group);\r\nret = snprintf(buf, MAX_NAME_LEN, "%s", name);\r\nif (ret >= MAX_NAME_LEN)\r\nreturn ERR_PTR(-ENAMETOOLONG);\r\nnum_str = strchr(buf, '.');\r\nif (!num_str) {\r\npr_err("Unable to locate . in name.bConfigurationValue\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n*num_str = '\0';\r\nnum_str++;\r\nif (!strlen(buf))\r\nreturn ERR_PTR(-EINVAL);\r\nret = kstrtou8(num_str, 0, &num);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\ncfg = kzalloc(sizeof(*cfg), GFP_KERNEL);\r\nif (!cfg)\r\nreturn ERR_PTR(-ENOMEM);\r\ncfg->c.label = kstrdup(buf, GFP_KERNEL);\r\nif (!cfg->c.label) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ncfg->c.bConfigurationValue = num;\r\ncfg->c.MaxPower = CONFIG_USB_GADGET_VBUS_DRAW;\r\ncfg->c.bmAttributes = USB_CONFIG_ATT_ONE;\r\nINIT_LIST_HEAD(&cfg->string_list);\r\nINIT_LIST_HEAD(&cfg->func_list);\r\nconfig_group_init_type_name(&cfg->group, name,\r\n&gadget_config_type);\r\nconfig_group_init_type_name(&cfg->strings_group, "strings",\r\n&gadget_config_name_strings_type);\r\nconfigfs_add_default_group(&cfg->strings_group, &cfg->group);\r\nret = usb_add_config_only(&gi->cdev, &cfg->c);\r\nif (ret)\r\ngoto err;\r\nreturn &cfg->group;\r\nerr:\r\nkfree(cfg->c.label);\r\nkfree(cfg);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic void config_desc_drop(\r\nstruct config_group *group,\r\nstruct config_item *item)\r\n{\r\nconfig_item_put(item);\r\n}\r\nstatic void gadget_strings_attr_release(struct config_item *item)\r\n{\r\nstruct gadget_strings *gs = to_gadget_strings(item);\r\nkfree(gs->manufacturer);\r\nkfree(gs->product);\r\nkfree(gs->serialnumber);\r\nlist_del(&gs->list);\r\nkfree(gs);\r\n}\r\nstatic inline struct os_desc *to_os_desc(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct os_desc, group);\r\n}\r\nstatic inline struct gadget_info *os_desc_item_to_gadget_info(\r\nstruct config_item *item)\r\n{\r\nreturn to_gadget_info(to_os_desc(item)->group.cg_item.ci_parent);\r\n}\r\nstatic ssize_t os_desc_use_show(struct config_item *item, char *page)\r\n{\r\nreturn sprintf(page, "%d",\r\nos_desc_item_to_gadget_info(item)->use_os_desc);\r\n}\r\nstatic ssize_t os_desc_use_store(struct config_item *item, const char *page,\r\nsize_t len)\r\n{\r\nstruct gadget_info *gi = os_desc_item_to_gadget_info(item);\r\nint ret;\r\nbool use;\r\nmutex_lock(&gi->lock);\r\nret = strtobool(page, &use);\r\nif (!ret) {\r\ngi->use_os_desc = use;\r\nret = len;\r\n}\r\nmutex_unlock(&gi->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t os_desc_b_vendor_code_show(struct config_item *item, char *page)\r\n{\r\nreturn sprintf(page, "%d",\r\nos_desc_item_to_gadget_info(item)->b_vendor_code);\r\n}\r\nstatic ssize_t os_desc_b_vendor_code_store(struct config_item *item,\r\nconst char *page, size_t len)\r\n{\r\nstruct gadget_info *gi = os_desc_item_to_gadget_info(item);\r\nint ret;\r\nu8 b_vendor_code;\r\nmutex_lock(&gi->lock);\r\nret = kstrtou8(page, 0, &b_vendor_code);\r\nif (!ret) {\r\ngi->b_vendor_code = b_vendor_code;\r\nret = len;\r\n}\r\nmutex_unlock(&gi->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t os_desc_qw_sign_show(struct config_item *item, char *page)\r\n{\r\nstruct gadget_info *gi = os_desc_item_to_gadget_info(item);\r\nmemcpy(page, gi->qw_sign, OS_STRING_QW_SIGN_LEN);\r\nreturn OS_STRING_QW_SIGN_LEN;\r\n}\r\nstatic ssize_t os_desc_qw_sign_store(struct config_item *item, const char *page,\r\nsize_t len)\r\n{\r\nstruct gadget_info *gi = os_desc_item_to_gadget_info(item);\r\nint res, l;\r\nl = min((int)len, OS_STRING_QW_SIGN_LEN >> 1);\r\nif (page[l - 1] == '\n')\r\n--l;\r\nmutex_lock(&gi->lock);\r\nres = utf8s_to_utf16s(page, l,\r\nUTF16_LITTLE_ENDIAN, (wchar_t *) gi->qw_sign,\r\nOS_STRING_QW_SIGN_LEN);\r\nif (res > 0)\r\nres = len;\r\nmutex_unlock(&gi->lock);\r\nreturn res;\r\n}\r\nstatic void os_desc_attr_release(struct config_item *item)\r\n{\r\nstruct os_desc *os_desc = to_os_desc(item);\r\nkfree(os_desc);\r\n}\r\nstatic int os_desc_link(struct config_item *os_desc_ci,\r\nstruct config_item *usb_cfg_ci)\r\n{\r\nstruct gadget_info *gi = container_of(to_config_group(os_desc_ci),\r\nstruct gadget_info, os_desc_group);\r\nstruct usb_composite_dev *cdev = &gi->cdev;\r\nstruct config_usb_cfg *c_target =\r\ncontainer_of(to_config_group(usb_cfg_ci),\r\nstruct config_usb_cfg, group);\r\nstruct usb_configuration *c;\r\nint ret;\r\nmutex_lock(&gi->lock);\r\nlist_for_each_entry(c, &cdev->configs, list) {\r\nif (c == &c_target->c)\r\nbreak;\r\n}\r\nif (c != &c_target->c) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (cdev->os_desc_config) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\ncdev->os_desc_config = &c_target->c;\r\nret = 0;\r\nout:\r\nmutex_unlock(&gi->lock);\r\nreturn ret;\r\n}\r\nstatic void os_desc_unlink(struct config_item *os_desc_ci,\r\nstruct config_item *usb_cfg_ci)\r\n{\r\nstruct gadget_info *gi = container_of(to_config_group(os_desc_ci),\r\nstruct gadget_info, os_desc_group);\r\nstruct usb_composite_dev *cdev = &gi->cdev;\r\nmutex_lock(&gi->lock);\r\nif (gi->composite.gadget_driver.udc_name)\r\nunregister_gadget(gi);\r\ncdev->os_desc_config = NULL;\r\nWARN_ON(gi->composite.gadget_driver.udc_name);\r\nmutex_unlock(&gi->lock);\r\n}\r\nstatic inline struct usb_os_desc_ext_prop\r\n*to_usb_os_desc_ext_prop(struct config_item *item)\r\n{\r\nreturn container_of(item, struct usb_os_desc_ext_prop, item);\r\n}\r\nstatic ssize_t ext_prop_type_show(struct config_item *item, char *page)\r\n{\r\nreturn sprintf(page, "%d", to_usb_os_desc_ext_prop(item)->type);\r\n}\r\nstatic ssize_t ext_prop_type_store(struct config_item *item,\r\nconst char *page, size_t len)\r\n{\r\nstruct usb_os_desc_ext_prop *ext_prop = to_usb_os_desc_ext_prop(item);\r\nstruct usb_os_desc *desc = to_usb_os_desc(ext_prop->item.ci_parent);\r\nu8 type;\r\nint ret;\r\nif (desc->opts_mutex)\r\nmutex_lock(desc->opts_mutex);\r\nret = kstrtou8(page, 0, &type);\r\nif (ret)\r\ngoto end;\r\nif (type < USB_EXT_PROP_UNICODE || type > USB_EXT_PROP_UNICODE_MULTI) {\r\nret = -EINVAL;\r\ngoto end;\r\n}\r\nif ((ext_prop->type == USB_EXT_PROP_BINARY ||\r\next_prop->type == USB_EXT_PROP_LE32 ||\r\next_prop->type == USB_EXT_PROP_BE32) &&\r\n(type == USB_EXT_PROP_UNICODE ||\r\ntype == USB_EXT_PROP_UNICODE_ENV ||\r\ntype == USB_EXT_PROP_UNICODE_LINK))\r\next_prop->data_len <<= 1;\r\nelse if ((ext_prop->type == USB_EXT_PROP_UNICODE ||\r\next_prop->type == USB_EXT_PROP_UNICODE_ENV ||\r\next_prop->type == USB_EXT_PROP_UNICODE_LINK) &&\r\n(type == USB_EXT_PROP_BINARY ||\r\ntype == USB_EXT_PROP_LE32 ||\r\ntype == USB_EXT_PROP_BE32))\r\next_prop->data_len >>= 1;\r\next_prop->type = type;\r\nret = len;\r\nend:\r\nif (desc->opts_mutex)\r\nmutex_unlock(desc->opts_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t ext_prop_data_show(struct config_item *item, char *page)\r\n{\r\nstruct usb_os_desc_ext_prop *ext_prop = to_usb_os_desc_ext_prop(item);\r\nint len = ext_prop->data_len;\r\nif (ext_prop->type == USB_EXT_PROP_UNICODE ||\r\next_prop->type == USB_EXT_PROP_UNICODE_ENV ||\r\next_prop->type == USB_EXT_PROP_UNICODE_LINK)\r\nlen >>= 1;\r\nmemcpy(page, ext_prop->data, len);\r\nreturn len;\r\n}\r\nstatic ssize_t ext_prop_data_store(struct config_item *item,\r\nconst char *page, size_t len)\r\n{\r\nstruct usb_os_desc_ext_prop *ext_prop = to_usb_os_desc_ext_prop(item);\r\nstruct usb_os_desc *desc = to_usb_os_desc(ext_prop->item.ci_parent);\r\nchar *new_data;\r\nsize_t ret_len = len;\r\nif (page[len - 1] == '\n' || page[len - 1] == '\0')\r\n--len;\r\nnew_data = kmemdup(page, len, GFP_KERNEL);\r\nif (!new_data)\r\nreturn -ENOMEM;\r\nif (desc->opts_mutex)\r\nmutex_lock(desc->opts_mutex);\r\nkfree(ext_prop->data);\r\next_prop->data = new_data;\r\ndesc->ext_prop_len -= ext_prop->data_len;\r\next_prop->data_len = len;\r\ndesc->ext_prop_len += ext_prop->data_len;\r\nif (ext_prop->type == USB_EXT_PROP_UNICODE ||\r\next_prop->type == USB_EXT_PROP_UNICODE_ENV ||\r\next_prop->type == USB_EXT_PROP_UNICODE_LINK) {\r\ndesc->ext_prop_len -= ext_prop->data_len;\r\next_prop->data_len <<= 1;\r\next_prop->data_len += 2;\r\ndesc->ext_prop_len += ext_prop->data_len;\r\n}\r\nif (desc->opts_mutex)\r\nmutex_unlock(desc->opts_mutex);\r\nreturn ret_len;\r\n}\r\nstatic void usb_os_desc_ext_prop_release(struct config_item *item)\r\n{\r\nstruct usb_os_desc_ext_prop *ext_prop = to_usb_os_desc_ext_prop(item);\r\nkfree(ext_prop);\r\n}\r\nstatic struct config_item *ext_prop_make(\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct usb_os_desc_ext_prop *ext_prop;\r\nstruct config_item_type *ext_prop_type;\r\nstruct usb_os_desc *desc;\r\nchar *vlabuf;\r\nvla_group(data_chunk);\r\nvla_item(data_chunk, struct usb_os_desc_ext_prop, ext_prop, 1);\r\nvla_item(data_chunk, struct config_item_type, ext_prop_type, 1);\r\nvlabuf = kzalloc(vla_group_size(data_chunk), GFP_KERNEL);\r\nif (!vlabuf)\r\nreturn ERR_PTR(-ENOMEM);\r\next_prop = vla_ptr(vlabuf, data_chunk, ext_prop);\r\next_prop_type = vla_ptr(vlabuf, data_chunk, ext_prop_type);\r\ndesc = container_of(group, struct usb_os_desc, group);\r\next_prop_type->ct_item_ops = &ext_prop_ops;\r\next_prop_type->ct_attrs = ext_prop_attrs;\r\next_prop_type->ct_owner = desc->owner;\r\nconfig_item_init_type_name(&ext_prop->item, name, ext_prop_type);\r\next_prop->name = kstrdup(name, GFP_KERNEL);\r\nif (!ext_prop->name) {\r\nkfree(vlabuf);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ndesc->ext_prop_len += 14;\r\next_prop->name_len = 2 * strlen(ext_prop->name) + 2;\r\nif (desc->opts_mutex)\r\nmutex_lock(desc->opts_mutex);\r\ndesc->ext_prop_len += ext_prop->name_len;\r\nlist_add_tail(&ext_prop->entry, &desc->ext_prop);\r\n++desc->ext_prop_count;\r\nif (desc->opts_mutex)\r\nmutex_unlock(desc->opts_mutex);\r\nreturn &ext_prop->item;\r\n}\r\nstatic void ext_prop_drop(struct config_group *group, struct config_item *item)\r\n{\r\nstruct usb_os_desc_ext_prop *ext_prop = to_usb_os_desc_ext_prop(item);\r\nstruct usb_os_desc *desc = to_usb_os_desc(&group->cg_item);\r\nif (desc->opts_mutex)\r\nmutex_lock(desc->opts_mutex);\r\nlist_del(&ext_prop->entry);\r\n--desc->ext_prop_count;\r\nkfree(ext_prop->name);\r\ndesc->ext_prop_len -= (ext_prop->name_len + ext_prop->data_len + 14);\r\nif (desc->opts_mutex)\r\nmutex_unlock(desc->opts_mutex);\r\nconfig_item_put(item);\r\n}\r\nstatic ssize_t interf_grp_compatible_id_show(struct config_item *item,\r\nchar *page)\r\n{\r\nmemcpy(page, to_usb_os_desc(item)->ext_compat_id, 8);\r\nreturn 8;\r\n}\r\nstatic ssize_t interf_grp_compatible_id_store(struct config_item *item,\r\nconst char *page, size_t len)\r\n{\r\nstruct usb_os_desc *desc = to_usb_os_desc(item);\r\nint l;\r\nl = min_t(int, 8, len);\r\nif (page[l - 1] == '\n')\r\n--l;\r\nif (desc->opts_mutex)\r\nmutex_lock(desc->opts_mutex);\r\nmemcpy(desc->ext_compat_id, page, l);\r\nif (desc->opts_mutex)\r\nmutex_unlock(desc->opts_mutex);\r\nreturn len;\r\n}\r\nstatic ssize_t interf_grp_sub_compatible_id_show(struct config_item *item,\r\nchar *page)\r\n{\r\nmemcpy(page, to_usb_os_desc(item)->ext_compat_id + 8, 8);\r\nreturn 8;\r\n}\r\nstatic ssize_t interf_grp_sub_compatible_id_store(struct config_item *item,\r\nconst char *page, size_t len)\r\n{\r\nstruct usb_os_desc *desc = to_usb_os_desc(item);\r\nint l;\r\nl = min_t(int, 8, len);\r\nif (page[l - 1] == '\n')\r\n--l;\r\nif (desc->opts_mutex)\r\nmutex_lock(desc->opts_mutex);\r\nmemcpy(desc->ext_compat_id + 8, page, l);\r\nif (desc->opts_mutex)\r\nmutex_unlock(desc->opts_mutex);\r\nreturn len;\r\n}\r\nint usb_os_desc_prepare_interf_dir(struct config_group *parent,\r\nint n_interf,\r\nstruct usb_os_desc **desc,\r\nchar **names,\r\nstruct module *owner)\r\n{\r\nstruct config_group *os_desc_group;\r\nstruct config_item_type *os_desc_type, *interface_type;\r\nvla_group(data_chunk);\r\nvla_item(data_chunk, struct config_group, os_desc_group, 1);\r\nvla_item(data_chunk, struct config_item_type, os_desc_type, 1);\r\nvla_item(data_chunk, struct config_item_type, interface_type, 1);\r\nchar *vlabuf = kzalloc(vla_group_size(data_chunk), GFP_KERNEL);\r\nif (!vlabuf)\r\nreturn -ENOMEM;\r\nos_desc_group = vla_ptr(vlabuf, data_chunk, os_desc_group);\r\nos_desc_type = vla_ptr(vlabuf, data_chunk, os_desc_type);\r\ninterface_type = vla_ptr(vlabuf, data_chunk, interface_type);\r\nos_desc_type->ct_owner = owner;\r\nconfig_group_init_type_name(os_desc_group, "os_desc", os_desc_type);\r\nconfigfs_add_default_group(os_desc_group, parent);\r\ninterface_type->ct_group_ops = &interf_grp_ops;\r\ninterface_type->ct_attrs = interf_grp_attrs;\r\ninterface_type->ct_owner = owner;\r\nwhile (n_interf--) {\r\nstruct usb_os_desc *d;\r\nd = desc[n_interf];\r\nd->owner = owner;\r\nconfig_group_init_type_name(&d->group, "", interface_type);\r\nconfig_item_set_name(&d->group.cg_item, "interface.%s",\r\nnames[n_interf]);\r\nconfigfs_add_default_group(&d->group, os_desc_group);\r\n}\r\nreturn 0;\r\n}\r\nstatic int configfs_do_nothing(struct usb_composite_dev *cdev)\r\n{\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nstatic void purge_configs_funcs(struct gadget_info *gi)\r\n{\r\nstruct usb_configuration *c;\r\nlist_for_each_entry(c, &gi->cdev.configs, list) {\r\nstruct usb_function *f, *tmp;\r\nstruct config_usb_cfg *cfg;\r\ncfg = container_of(c, struct config_usb_cfg, c);\r\nlist_for_each_entry_safe(f, tmp, &c->functions, list) {\r\nlist_move_tail(&f->list, &cfg->func_list);\r\nif (f->unbind) {\r\ndev_dbg(&gi->cdev.gadget->dev,\r\n"unbind function '%s'/%p\n",\r\nf->name, f);\r\nf->unbind(c, f);\r\n}\r\n}\r\nc->next_interface_id = 0;\r\nmemset(c->interface, 0, sizeof(c->interface));\r\nc->superspeed_plus = 0;\r\nc->superspeed = 0;\r\nc->highspeed = 0;\r\nc->fullspeed = 0;\r\n}\r\n}\r\nstatic int configfs_composite_bind(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *gdriver)\r\n{\r\nstruct usb_composite_driver *composite = to_cdriver(gdriver);\r\nstruct gadget_info *gi = container_of(composite,\r\nstruct gadget_info, composite);\r\nstruct usb_composite_dev *cdev = &gi->cdev;\r\nstruct usb_configuration *c;\r\nstruct usb_string *s;\r\nunsigned i;\r\nint ret;\r\ncdev->gadget = gadget;\r\nset_gadget_data(gadget, cdev);\r\nret = composite_dev_prepare(composite, cdev);\r\nif (ret)\r\nreturn ret;\r\nret = -EINVAL;\r\nif (list_empty(&gi->cdev.configs)) {\r\npr_err("Need at least one configuration in %s.\n",\r\ngi->composite.name);\r\ngoto err_comp_cleanup;\r\n}\r\nlist_for_each_entry(c, &gi->cdev.configs, list) {\r\nstruct config_usb_cfg *cfg;\r\ncfg = container_of(c, struct config_usb_cfg, c);\r\nif (list_empty(&cfg->func_list)) {\r\npr_err("Config %s/%d of %s needs at least one function.\n",\r\nc->label, c->bConfigurationValue,\r\ngi->composite.name);\r\ngoto err_comp_cleanup;\r\n}\r\n}\r\nif (!list_empty(&gi->string_list)) {\r\nstruct gadget_strings *gs;\r\ni = 0;\r\nlist_for_each_entry(gs, &gi->string_list, list) {\r\ngi->gstrings[i] = &gs->stringtab_dev;\r\ngs->stringtab_dev.strings = gs->strings;\r\ngs->strings[USB_GADGET_MANUFACTURER_IDX].s =\r\ngs->manufacturer;\r\ngs->strings[USB_GADGET_PRODUCT_IDX].s = gs->product;\r\ngs->strings[USB_GADGET_SERIAL_IDX].s = gs->serialnumber;\r\ni++;\r\n}\r\ngi->gstrings[i] = NULL;\r\ns = usb_gstrings_attach(&gi->cdev, gi->gstrings,\r\nUSB_GADGET_FIRST_AVAIL_IDX);\r\nif (IS_ERR(s)) {\r\nret = PTR_ERR(s);\r\ngoto err_comp_cleanup;\r\n}\r\ngi->cdev.desc.iManufacturer = s[USB_GADGET_MANUFACTURER_IDX].id;\r\ngi->cdev.desc.iProduct = s[USB_GADGET_PRODUCT_IDX].id;\r\ngi->cdev.desc.iSerialNumber = s[USB_GADGET_SERIAL_IDX].id;\r\n}\r\nif (gi->use_os_desc) {\r\ncdev->use_os_string = true;\r\ncdev->b_vendor_code = gi->b_vendor_code;\r\nmemcpy(cdev->qw_sign, gi->qw_sign, OS_STRING_QW_SIGN_LEN);\r\n}\r\nif (gadget_is_otg(gadget) && !otg_desc[0]) {\r\nstruct usb_descriptor_header *usb_desc;\r\nusb_desc = usb_otg_descriptor_alloc(gadget);\r\nif (!usb_desc) {\r\nret = -ENOMEM;\r\ngoto err_comp_cleanup;\r\n}\r\nusb_otg_descriptor_init(gadget, usb_desc);\r\notg_desc[0] = usb_desc;\r\notg_desc[1] = NULL;\r\n}\r\nlist_for_each_entry(c, &gi->cdev.configs, list) {\r\nstruct config_usb_cfg *cfg;\r\nstruct usb_function *f;\r\nstruct usb_function *tmp;\r\nstruct gadget_config_name *cn;\r\nif (gadget_is_otg(gadget))\r\nc->descriptors = otg_desc;\r\ncfg = container_of(c, struct config_usb_cfg, c);\r\nif (!list_empty(&cfg->string_list)) {\r\ni = 0;\r\nlist_for_each_entry(cn, &cfg->string_list, list) {\r\ncfg->gstrings[i] = &cn->stringtab_dev;\r\ncn->stringtab_dev.strings = &cn->strings;\r\ncn->strings.s = cn->configuration;\r\ni++;\r\n}\r\ncfg->gstrings[i] = NULL;\r\ns = usb_gstrings_attach(&gi->cdev, cfg->gstrings, 1);\r\nif (IS_ERR(s)) {\r\nret = PTR_ERR(s);\r\ngoto err_comp_cleanup;\r\n}\r\nc->iConfiguration = s[0].id;\r\n}\r\nlist_for_each_entry_safe(f, tmp, &cfg->func_list, list) {\r\nlist_del(&f->list);\r\nret = usb_add_function(c, f);\r\nif (ret) {\r\nlist_add(&f->list, &cfg->func_list);\r\ngoto err_purge_funcs;\r\n}\r\n}\r\nusb_ep_autoconfig_reset(cdev->gadget);\r\n}\r\nif (cdev->use_os_string) {\r\nret = composite_os_desc_req_prepare(cdev, gadget->ep0);\r\nif (ret)\r\ngoto err_purge_funcs;\r\n}\r\nusb_ep_autoconfig_reset(cdev->gadget);\r\nreturn 0;\r\nerr_purge_funcs:\r\npurge_configs_funcs(gi);\r\nerr_comp_cleanup:\r\ncomposite_dev_cleanup(cdev);\r\nreturn ret;\r\n}\r\nstatic void configfs_composite_unbind(struct usb_gadget *gadget)\r\n{\r\nstruct usb_composite_dev *cdev;\r\nstruct gadget_info *gi;\r\ncdev = get_gadget_data(gadget);\r\ngi = container_of(cdev, struct gadget_info, cdev);\r\nkfree(otg_desc[0]);\r\notg_desc[0] = NULL;\r\npurge_configs_funcs(gi);\r\ncomposite_dev_cleanup(cdev);\r\nusb_ep_autoconfig_reset(cdev->gadget);\r\ncdev->gadget = NULL;\r\nset_gadget_data(gadget, NULL);\r\n}\r\nstatic struct config_group *gadgets_make(\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct gadget_info *gi;\r\ngi = kzalloc(sizeof(*gi), GFP_KERNEL);\r\nif (!gi)\r\nreturn ERR_PTR(-ENOMEM);\r\nconfig_group_init_type_name(&gi->group, name, &gadget_root_type);\r\nconfig_group_init_type_name(&gi->functions_group, "functions",\r\n&functions_type);\r\nconfigfs_add_default_group(&gi->functions_group, &gi->group);\r\nconfig_group_init_type_name(&gi->configs_group, "configs",\r\n&config_desc_type);\r\nconfigfs_add_default_group(&gi->configs_group, &gi->group);\r\nconfig_group_init_type_name(&gi->strings_group, "strings",\r\n&gadget_strings_strings_type);\r\nconfigfs_add_default_group(&gi->strings_group, &gi->group);\r\nconfig_group_init_type_name(&gi->os_desc_group, "os_desc",\r\n&os_desc_type);\r\nconfigfs_add_default_group(&gi->os_desc_group, &gi->group);\r\ngi->composite.bind = configfs_do_nothing;\r\ngi->composite.unbind = configfs_do_nothing;\r\ngi->composite.suspend = NULL;\r\ngi->composite.resume = NULL;\r\ngi->composite.max_speed = USB_SPEED_SUPER;\r\nmutex_init(&gi->lock);\r\nINIT_LIST_HEAD(&gi->string_list);\r\nINIT_LIST_HEAD(&gi->available_func);\r\ncomposite_init_dev(&gi->cdev);\r\ngi->cdev.desc.bLength = USB_DT_DEVICE_SIZE;\r\ngi->cdev.desc.bDescriptorType = USB_DT_DEVICE;\r\ngi->cdev.desc.bcdDevice = cpu_to_le16(get_default_bcdDevice());\r\ngi->composite.gadget_driver = configfs_driver_template;\r\ngi->composite.gadget_driver.function = kstrdup(name, GFP_KERNEL);\r\ngi->composite.name = gi->composite.gadget_driver.function;\r\nif (!gi->composite.gadget_driver.function)\r\ngoto err;\r\nreturn &gi->group;\r\nerr:\r\nkfree(gi);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nstatic void gadgets_drop(struct config_group *group, struct config_item *item)\r\n{\r\nconfig_item_put(item);\r\n}\r\nvoid unregister_gadget_item(struct config_item *item)\r\n{\r\nstruct gadget_info *gi = to_gadget_info(item);\r\nmutex_lock(&gi->lock);\r\nunregister_gadget(gi);\r\nmutex_unlock(&gi->lock);\r\n}\r\nstatic int __init gadget_cfs_init(void)\r\n{\r\nint ret;\r\nconfig_group_init(&gadget_subsys.su_group);\r\nret = configfs_register_subsystem(&gadget_subsys);\r\nreturn ret;\r\n}\r\nstatic void __exit gadget_cfs_exit(void)\r\n{\r\nconfigfs_unregister_subsystem(&gadget_subsys);\r\n}
