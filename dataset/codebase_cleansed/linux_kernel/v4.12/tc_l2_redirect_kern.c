static __always_inline bool is_vip_addr(__be16 eth_proto, __be32 daddr)\r\n{\r\nif (eth_proto == htons(ETH_P_IP))\r\nreturn (_htonl(0xffffff00) & daddr) == _htonl(0x0a0a0100);\r\nelse if (eth_proto == htons(ETH_P_IPV6))\r\nreturn (daddr == _htonl(0x2401face));\r\nreturn false;\r\n}\r\nint _l2_to_iptun_ingress_forward(struct __sk_buff *skb)\r\n{\r\nstruct bpf_tunnel_key tkey = {};\r\nvoid *data = (void *)(long)skb->data;\r\nstruct eth_hdr *eth = data;\r\nvoid *data_end = (void *)(long)skb->data_end;\r\nint key = 0, *ifindex;\r\nint ret;\r\nif (data + sizeof(*eth) > data_end)\r\nreturn TC_ACT_OK;\r\nifindex = bpf_map_lookup_elem(&tun_iface, &key);\r\nif (!ifindex)\r\nreturn TC_ACT_OK;\r\nif (eth->h_proto == htons(ETH_P_IP)) {\r\nchar fmt4[] = "ingress forward to ifindex:%d daddr4:%x\n";\r\nstruct iphdr *iph = data + sizeof(*eth);\r\nif (data + sizeof(*eth) + sizeof(*iph) > data_end)\r\nreturn TC_ACT_OK;\r\nif (iph->protocol != IPPROTO_IPIP)\r\nreturn TC_ACT_OK;\r\nbpf_trace_printk(fmt4, sizeof(fmt4), *ifindex,\r\n_htonl(iph->daddr));\r\nreturn bpf_redirect(*ifindex, BPF_F_INGRESS);\r\n} else if (eth->h_proto == htons(ETH_P_IPV6)) {\r\nchar fmt6[] = "ingress forward to ifindex:%d daddr6:%x::%x\n";\r\nstruct ipv6hdr *ip6h = data + sizeof(*eth);\r\nif (data + sizeof(*eth) + sizeof(*ip6h) > data_end)\r\nreturn TC_ACT_OK;\r\nif (ip6h->nexthdr != IPPROTO_IPIP &&\r\nip6h->nexthdr != IPPROTO_IPV6)\r\nreturn TC_ACT_OK;\r\nbpf_trace_printk(fmt6, sizeof(fmt6), *ifindex,\r\n_htonl(ip6h->daddr.s6_addr32[0]),\r\n_htonl(ip6h->daddr.s6_addr32[3]));\r\nreturn bpf_redirect(*ifindex, BPF_F_INGRESS);\r\n}\r\nreturn TC_ACT_OK;\r\n}\r\nint _l2_to_iptun_ingress_redirect(struct __sk_buff *skb)\r\n{\r\nstruct bpf_tunnel_key tkey = {};\r\nvoid *data = (void *)(long)skb->data;\r\nstruct eth_hdr *eth = data;\r\nvoid *data_end = (void *)(long)skb->data_end;\r\nint key = 0, *ifindex;\r\nint ret;\r\nif (data + sizeof(*eth) > data_end)\r\nreturn TC_ACT_OK;\r\nifindex = bpf_map_lookup_elem(&tun_iface, &key);\r\nif (!ifindex)\r\nreturn TC_ACT_OK;\r\nif (eth->h_proto == htons(ETH_P_IP)) {\r\nchar fmt4[] = "e/ingress redirect daddr4:%x to ifindex:%d\n";\r\nstruct iphdr *iph = data + sizeof(*eth);\r\n__be32 daddr = iph->daddr;\r\nif (data + sizeof(*eth) + sizeof(*iph) > data_end)\r\nreturn TC_ACT_OK;\r\nif (!is_vip_addr(eth->h_proto, daddr))\r\nreturn TC_ACT_OK;\r\nbpf_trace_printk(fmt4, sizeof(fmt4), _htonl(daddr), *ifindex);\r\n} else {\r\nreturn TC_ACT_OK;\r\n}\r\ntkey.tunnel_id = 10000;\r\ntkey.tunnel_ttl = 64;\r\ntkey.remote_ipv4 = 0x0a020166;\r\nbpf_skb_set_tunnel_key(skb, &tkey, sizeof(tkey), 0);\r\nreturn bpf_redirect(*ifindex, 0);\r\n}\r\nint _l2_to_ip6tun_ingress_redirect(struct __sk_buff *skb)\r\n{\r\nstruct bpf_tunnel_key tkey = {};\r\nvoid *data = (void *)(long)skb->data;\r\nstruct eth_hdr *eth = data;\r\nvoid *data_end = (void *)(long)skb->data_end;\r\nint key = 0, *ifindex;\r\nif (data + sizeof(*eth) > data_end)\r\nreturn TC_ACT_OK;\r\nifindex = bpf_map_lookup_elem(&tun_iface, &key);\r\nif (!ifindex)\r\nreturn TC_ACT_OK;\r\nif (eth->h_proto == htons(ETH_P_IP)) {\r\nchar fmt4[] = "e/ingress redirect daddr4:%x to ifindex:%d\n";\r\nstruct iphdr *iph = data + sizeof(*eth);\r\nif (data + sizeof(*eth) + sizeof(*iph) > data_end)\r\nreturn TC_ACT_OK;\r\nif (!is_vip_addr(eth->h_proto, iph->daddr))\r\nreturn TC_ACT_OK;\r\nbpf_trace_printk(fmt4, sizeof(fmt4), _htonl(iph->daddr),\r\n*ifindex);\r\n} else if (eth->h_proto == htons(ETH_P_IPV6)) {\r\nchar fmt6[] = "e/ingress redirect daddr6:%x to ifindex:%d\n";\r\nstruct ipv6hdr *ip6h = data + sizeof(*eth);\r\nif (data + sizeof(*eth) + sizeof(*ip6h) > data_end)\r\nreturn TC_ACT_OK;\r\nif (!is_vip_addr(eth->h_proto, ip6h->daddr.s6_addr32[0]))\r\nreturn TC_ACT_OK;\r\nbpf_trace_printk(fmt6, sizeof(fmt6),\r\n_htonl(ip6h->daddr.s6_addr32[0]), *ifindex);\r\n} else {\r\nreturn TC_ACT_OK;\r\n}\r\ntkey.tunnel_id = 10000;\r\ntkey.tunnel_ttl = 64;\r\ntkey.remote_ipv6[0] = _htonl(0x2401db02);\r\ntkey.remote_ipv6[1] = 0;\r\ntkey.remote_ipv6[2] = 0;\r\ntkey.remote_ipv6[3] = _htonl(0x00000066);\r\nbpf_skb_set_tunnel_key(skb, &tkey, sizeof(tkey), BPF_F_TUNINFO_IPV6);\r\nreturn bpf_redirect(*ifindex, 0);\r\n}\r\nint _drop_non_tun_vip(struct __sk_buff *skb)\r\n{\r\nstruct bpf_tunnel_key tkey = {};\r\nvoid *data = (void *)(long)skb->data;\r\nstruct eth_hdr *eth = data;\r\nvoid *data_end = (void *)(long)skb->data_end;\r\nif (data + sizeof(*eth) > data_end)\r\nreturn TC_ACT_OK;\r\nif (eth->h_proto == htons(ETH_P_IP)) {\r\nstruct iphdr *iph = data + sizeof(*eth);\r\nif (data + sizeof(*eth) + sizeof(*iph) > data_end)\r\nreturn TC_ACT_OK;\r\nif (is_vip_addr(eth->h_proto, iph->daddr))\r\nreturn TC_ACT_SHOT;\r\n} else if (eth->h_proto == htons(ETH_P_IPV6)) {\r\nstruct ipv6hdr *ip6h = data + sizeof(*eth);\r\nif (data + sizeof(*eth) + sizeof(*ip6h) > data_end)\r\nreturn TC_ACT_OK;\r\nif (is_vip_addr(eth->h_proto, ip6h->daddr.s6_addr32[0]))\r\nreturn TC_ACT_SHOT;\r\n}\r\nreturn TC_ACT_OK;\r\n}
