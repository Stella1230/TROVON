static int\r\nsavage_bci_wait_fifo_shadow(drm_savage_private_t * dev_priv, unsigned int n)\r\n{\r\nuint32_t mask = dev_priv->status_used_mask;\r\nuint32_t threshold = dev_priv->bci_threshold_hi;\r\nuint32_t status;\r\nint i;\r\n#if SAVAGE_BCI_DEBUG\r\nif (n > dev_priv->cob_size + SAVAGE_BCI_FIFO_SIZE - threshold)\r\nDRM_ERROR("Trying to emit %d words "\r\n"(more than guaranteed space in COB)\n", n);\r\n#endif\r\nfor (i = 0; i < SAVAGE_DEFAULT_USEC_TIMEOUT; i++) {\r\nmb();\r\nstatus = dev_priv->status_ptr[0];\r\nif ((status & mask) < threshold)\r\nreturn 0;\r\nDRM_UDELAY(1);\r\n}\r\n#if SAVAGE_BCI_DEBUG\r\nDRM_ERROR("failed!\n");\r\nDRM_INFO(" status=0x%08x, threshold=0x%08x\n", status, threshold);\r\n#endif\r\nreturn -EBUSY;\r\n}\r\nstatic int\r\nsavage_bci_wait_fifo_s3d(drm_savage_private_t * dev_priv, unsigned int n)\r\n{\r\nuint32_t maxUsed = dev_priv->cob_size + SAVAGE_BCI_FIFO_SIZE - n;\r\nuint32_t status;\r\nint i;\r\nfor (i = 0; i < SAVAGE_DEFAULT_USEC_TIMEOUT; i++) {\r\nstatus = SAVAGE_READ(SAVAGE_STATUS_WORD0);\r\nif ((status & SAVAGE_FIFO_USED_MASK_S3D) <= maxUsed)\r\nreturn 0;\r\nDRM_UDELAY(1);\r\n}\r\n#if SAVAGE_BCI_DEBUG\r\nDRM_ERROR("failed!\n");\r\nDRM_INFO(" status=0x%08x\n", status);\r\n#endif\r\nreturn -EBUSY;\r\n}\r\nstatic int\r\nsavage_bci_wait_fifo_s4(drm_savage_private_t * dev_priv, unsigned int n)\r\n{\r\nuint32_t maxUsed = dev_priv->cob_size + SAVAGE_BCI_FIFO_SIZE - n;\r\nuint32_t status;\r\nint i;\r\nfor (i = 0; i < SAVAGE_DEFAULT_USEC_TIMEOUT; i++) {\r\nstatus = SAVAGE_READ(SAVAGE_ALT_STATUS_WORD0);\r\nif ((status & SAVAGE_FIFO_USED_MASK_S4) <= maxUsed)\r\nreturn 0;\r\nDRM_UDELAY(1);\r\n}\r\n#if SAVAGE_BCI_DEBUG\r\nDRM_ERROR("failed!\n");\r\nDRM_INFO(" status=0x%08x\n", status);\r\n#endif\r\nreturn -EBUSY;\r\n}\r\nstatic int\r\nsavage_bci_wait_event_shadow(drm_savage_private_t * dev_priv, uint16_t e)\r\n{\r\nuint32_t status;\r\nint i;\r\nfor (i = 0; i < SAVAGE_EVENT_USEC_TIMEOUT; i++) {\r\nmb();\r\nstatus = dev_priv->status_ptr[1];\r\nif ((((status & 0xffff) - e) & 0xffff) <= 0x7fff ||\r\n(status & 0xffff) == 0)\r\nreturn 0;\r\nDRM_UDELAY(1);\r\n}\r\n#if SAVAGE_BCI_DEBUG\r\nDRM_ERROR("failed!\n");\r\nDRM_INFO(" status=0x%08x, e=0x%04x\n", status, e);\r\n#endif\r\nreturn -EBUSY;\r\n}\r\nstatic int\r\nsavage_bci_wait_event_reg(drm_savage_private_t * dev_priv, uint16_t e)\r\n{\r\nuint32_t status;\r\nint i;\r\nfor (i = 0; i < SAVAGE_EVENT_USEC_TIMEOUT; i++) {\r\nstatus = SAVAGE_READ(SAVAGE_STATUS_WORD1);\r\nif ((((status & 0xffff) - e) & 0xffff) <= 0x7fff ||\r\n(status & 0xffff) == 0)\r\nreturn 0;\r\nDRM_UDELAY(1);\r\n}\r\n#if SAVAGE_BCI_DEBUG\r\nDRM_ERROR("failed!\n");\r\nDRM_INFO(" status=0x%08x, e=0x%04x\n", status, e);\r\n#endif\r\nreturn -EBUSY;\r\n}\r\nuint16_t savage_bci_emit_event(drm_savage_private_t * dev_priv,\r\nunsigned int flags)\r\n{\r\nuint16_t count;\r\nBCI_LOCALS;\r\nif (dev_priv->status_ptr) {\r\ncount = dev_priv->status_ptr[1023];\r\nif (count < dev_priv->event_counter)\r\ndev_priv->event_wrap++;\r\n} else {\r\ncount = dev_priv->event_counter;\r\n}\r\ncount = (count + 1) & 0xffff;\r\nif (count == 0) {\r\ncount++;\r\ndev_priv->event_wrap++;\r\n}\r\ndev_priv->event_counter = count;\r\nif (dev_priv->status_ptr)\r\ndev_priv->status_ptr[1023] = (uint32_t) count;\r\nif ((flags & (SAVAGE_WAIT_2D | SAVAGE_WAIT_3D))) {\r\nunsigned int wait_cmd = BCI_CMD_WAIT;\r\nif ((flags & SAVAGE_WAIT_2D))\r\nwait_cmd |= BCI_CMD_WAIT_2D;\r\nif ((flags & SAVAGE_WAIT_3D))\r\nwait_cmd |= BCI_CMD_WAIT_3D;\r\nBEGIN_BCI(2);\r\nBCI_WRITE(wait_cmd);\r\n} else {\r\nBEGIN_BCI(1);\r\n}\r\nBCI_WRITE(BCI_CMD_UPDATE_EVENT_TAG | (uint32_t) count);\r\nreturn count;\r\n}\r\nstatic int savage_freelist_init(struct drm_device * dev)\r\n{\r\ndrm_savage_private_t *dev_priv = dev->dev_private;\r\nstruct drm_device_dma *dma = dev->dma;\r\nstruct drm_buf *buf;\r\ndrm_savage_buf_priv_t *entry;\r\nint i;\r\nDRM_DEBUG("count=%d\n", dma->buf_count);\r\ndev_priv->head.next = &dev_priv->tail;\r\ndev_priv->head.prev = NULL;\r\ndev_priv->head.buf = NULL;\r\ndev_priv->tail.next = NULL;\r\ndev_priv->tail.prev = &dev_priv->head;\r\ndev_priv->tail.buf = NULL;\r\nfor (i = 0; i < dma->buf_count; i++) {\r\nbuf = dma->buflist[i];\r\nentry = buf->dev_private;\r\nSET_AGE(&entry->age, 0, 0);\r\nentry->buf = buf;\r\nentry->next = dev_priv->head.next;\r\nentry->prev = &dev_priv->head;\r\ndev_priv->head.next->prev = entry;\r\ndev_priv->head.next = entry;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct drm_buf *savage_freelist_get(struct drm_device * dev)\r\n{\r\ndrm_savage_private_t *dev_priv = dev->dev_private;\r\ndrm_savage_buf_priv_t *tail = dev_priv->tail.prev;\r\nuint16_t event;\r\nunsigned int wrap;\r\nDRM_DEBUG("\n");\r\nUPDATE_EVENT_COUNTER();\r\nif (dev_priv->status_ptr)\r\nevent = dev_priv->status_ptr[1] & 0xffff;\r\nelse\r\nevent = SAVAGE_READ(SAVAGE_STATUS_WORD1) & 0xffff;\r\nwrap = dev_priv->event_wrap;\r\nif (event > dev_priv->event_counter)\r\nwrap--;\r\nDRM_DEBUG(" tail=0x%04x %d\n", tail->age.event, tail->age.wrap);\r\nDRM_DEBUG(" head=0x%04x %d\n", event, wrap);\r\nif (tail->buf && (TEST_AGE(&tail->age, event, wrap) || event == 0)) {\r\ndrm_savage_buf_priv_t *next = tail->next;\r\ndrm_savage_buf_priv_t *prev = tail->prev;\r\nprev->next = next;\r\nnext->prev = prev;\r\ntail->next = tail->prev = NULL;\r\nreturn tail->buf;\r\n}\r\nDRM_DEBUG("returning NULL, tail->buf=%p!\n", tail->buf);\r\nreturn NULL;\r\n}\r\nvoid savage_freelist_put(struct drm_device * dev, struct drm_buf * buf)\r\n{\r\ndrm_savage_private_t *dev_priv = dev->dev_private;\r\ndrm_savage_buf_priv_t *entry = buf->dev_private, *prev, *next;\r\nDRM_DEBUG("age=0x%04x wrap=%d\n", entry->age.event, entry->age.wrap);\r\nif (entry->next != NULL || entry->prev != NULL) {\r\nDRM_ERROR("entry already on freelist.\n");\r\nreturn;\r\n}\r\nprev = &dev_priv->head;\r\nnext = prev->next;\r\nprev->next = entry;\r\nnext->prev = entry;\r\nentry->prev = prev;\r\nentry->next = next;\r\n}\r\nstatic int savage_dma_init(drm_savage_private_t * dev_priv)\r\n{\r\nunsigned int i;\r\ndev_priv->nr_dma_pages = dev_priv->cmd_dma->size /\r\n(SAVAGE_DMA_PAGE_SIZE * 4);\r\ndev_priv->dma_pages = kmalloc(sizeof(drm_savage_dma_page_t) *\r\ndev_priv->nr_dma_pages, GFP_KERNEL);\r\nif (dev_priv->dma_pages == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < dev_priv->nr_dma_pages; ++i) {\r\nSET_AGE(&dev_priv->dma_pages[i].age, 0, 0);\r\ndev_priv->dma_pages[i].used = 0;\r\ndev_priv->dma_pages[i].flushed = 0;\r\n}\r\nSET_AGE(&dev_priv->last_dma_age, 0, 0);\r\ndev_priv->first_dma_page = 0;\r\ndev_priv->current_dma_page = 0;\r\nreturn 0;\r\n}\r\nvoid savage_dma_reset(drm_savage_private_t * dev_priv)\r\n{\r\nuint16_t event;\r\nunsigned int wrap, i;\r\nevent = savage_bci_emit_event(dev_priv, 0);\r\nwrap = dev_priv->event_wrap;\r\nfor (i = 0; i < dev_priv->nr_dma_pages; ++i) {\r\nSET_AGE(&dev_priv->dma_pages[i].age, event, wrap);\r\ndev_priv->dma_pages[i].used = 0;\r\ndev_priv->dma_pages[i].flushed = 0;\r\n}\r\nSET_AGE(&dev_priv->last_dma_age, event, wrap);\r\ndev_priv->first_dma_page = dev_priv->current_dma_page = 0;\r\n}\r\nvoid savage_dma_wait(drm_savage_private_t * dev_priv, unsigned int page)\r\n{\r\nuint16_t event;\r\nunsigned int wrap;\r\nif (dev_priv->cmd_dma == &dev_priv->fake_dma)\r\nreturn;\r\nUPDATE_EVENT_COUNTER();\r\nif (dev_priv->status_ptr)\r\nevent = dev_priv->status_ptr[1] & 0xffff;\r\nelse\r\nevent = SAVAGE_READ(SAVAGE_STATUS_WORD1) & 0xffff;\r\nwrap = dev_priv->event_wrap;\r\nif (event > dev_priv->event_counter)\r\nwrap--;\r\nif (dev_priv->dma_pages[page].age.wrap > wrap ||\r\n(dev_priv->dma_pages[page].age.wrap == wrap &&\r\ndev_priv->dma_pages[page].age.event > event)) {\r\nif (dev_priv->wait_evnt(dev_priv,\r\ndev_priv->dma_pages[page].age.event)\r\n< 0)\r\nDRM_ERROR("wait_evnt failed!\n");\r\n}\r\n}\r\nuint32_t *savage_dma_alloc(drm_savage_private_t * dev_priv, unsigned int n)\r\n{\r\nunsigned int cur = dev_priv->current_dma_page;\r\nunsigned int rest = SAVAGE_DMA_PAGE_SIZE -\r\ndev_priv->dma_pages[cur].used;\r\nunsigned int nr_pages = (n - rest + SAVAGE_DMA_PAGE_SIZE - 1) /\r\nSAVAGE_DMA_PAGE_SIZE;\r\nuint32_t *dma_ptr;\r\nunsigned int i;\r\nDRM_DEBUG("cur=%u, cur->used=%u, n=%u, rest=%u, nr_pages=%u\n",\r\ncur, dev_priv->dma_pages[cur].used, n, rest, nr_pages);\r\nif (cur + nr_pages < dev_priv->nr_dma_pages) {\r\ndma_ptr = (uint32_t *) dev_priv->cmd_dma->handle +\r\ncur * SAVAGE_DMA_PAGE_SIZE + dev_priv->dma_pages[cur].used;\r\nif (n < rest)\r\nrest = n;\r\ndev_priv->dma_pages[cur].used += rest;\r\nn -= rest;\r\ncur++;\r\n} else {\r\ndev_priv->dma_flush(dev_priv);\r\nnr_pages =\r\n(n + SAVAGE_DMA_PAGE_SIZE - 1) / SAVAGE_DMA_PAGE_SIZE;\r\nfor (i = cur; i < dev_priv->nr_dma_pages; ++i) {\r\ndev_priv->dma_pages[i].age = dev_priv->last_dma_age;\r\ndev_priv->dma_pages[i].used = 0;\r\ndev_priv->dma_pages[i].flushed = 0;\r\n}\r\ndma_ptr = (uint32_t *) dev_priv->cmd_dma->handle;\r\ndev_priv->first_dma_page = cur = 0;\r\n}\r\nfor (i = cur; nr_pages > 0; ++i, --nr_pages) {\r\n#if SAVAGE_DMA_DEBUG\r\nif (dev_priv->dma_pages[i].used) {\r\nDRM_ERROR("unflushed page %u: used=%u\n",\r\ni, dev_priv->dma_pages[i].used);\r\n}\r\n#endif\r\nif (n > SAVAGE_DMA_PAGE_SIZE)\r\ndev_priv->dma_pages[i].used = SAVAGE_DMA_PAGE_SIZE;\r\nelse\r\ndev_priv->dma_pages[i].used = n;\r\nn -= SAVAGE_DMA_PAGE_SIZE;\r\n}\r\ndev_priv->current_dma_page = --i;\r\nDRM_DEBUG("cur=%u, cur->used=%u, n=%u\n",\r\ni, dev_priv->dma_pages[i].used, n);\r\nsavage_dma_wait(dev_priv, dev_priv->current_dma_page);\r\nreturn dma_ptr;\r\n}\r\nstatic void savage_dma_flush(drm_savage_private_t * dev_priv)\r\n{\r\nunsigned int first = dev_priv->first_dma_page;\r\nunsigned int cur = dev_priv->current_dma_page;\r\nuint16_t event;\r\nunsigned int wrap, pad, align, len, i;\r\nunsigned long phys_addr;\r\nBCI_LOCALS;\r\nif (first == cur &&\r\ndev_priv->dma_pages[cur].used == dev_priv->dma_pages[cur].flushed)\r\nreturn;\r\npad = -dev_priv->dma_pages[cur].used & 1;\r\nalign = -(dev_priv->dma_pages[cur].used + pad) & 7;\r\nDRM_DEBUG("first=%u, cur=%u, first->flushed=%u, cur->used=%u, "\r\n"pad=%u, align=%u\n",\r\nfirst, cur, dev_priv->dma_pages[first].flushed,\r\ndev_priv->dma_pages[cur].used, pad, align);\r\nif (pad) {\r\nuint32_t *dma_ptr = (uint32_t *) dev_priv->cmd_dma->handle +\r\ncur * SAVAGE_DMA_PAGE_SIZE + dev_priv->dma_pages[cur].used;\r\ndev_priv->dma_pages[cur].used += pad;\r\nwhile (pad != 0) {\r\n*dma_ptr++ = BCI_CMD_WAIT;\r\npad--;\r\n}\r\n}\r\nmb();\r\nphys_addr = dev_priv->cmd_dma->offset +\r\n(first * SAVAGE_DMA_PAGE_SIZE +\r\ndev_priv->dma_pages[first].flushed) * 4;\r\nlen = (cur - first) * SAVAGE_DMA_PAGE_SIZE +\r\ndev_priv->dma_pages[cur].used - dev_priv->dma_pages[first].flushed;\r\nDRM_DEBUG("phys_addr=%lx, len=%u\n",\r\nphys_addr | dev_priv->dma_type, len);\r\nBEGIN_BCI(3);\r\nBCI_SET_REGISTERS(SAVAGE_DMABUFADDR, 1);\r\nBCI_WRITE(phys_addr | dev_priv->dma_type);\r\nBCI_DMA(len);\r\ndev_priv->dma_pages[cur].used += align;\r\nevent = savage_bci_emit_event(dev_priv, 0);\r\nwrap = dev_priv->event_wrap;\r\nfor (i = first; i < cur; ++i) {\r\nSET_AGE(&dev_priv->dma_pages[i].age, event, wrap);\r\ndev_priv->dma_pages[i].used = 0;\r\ndev_priv->dma_pages[i].flushed = 0;\r\n}\r\nif (dev_priv->dma_pages[cur].used == SAVAGE_DMA_PAGE_SIZE) {\r\nSET_AGE(&dev_priv->dma_pages[cur].age, event, wrap);\r\ndev_priv->dma_pages[cur].used = 0;\r\ndev_priv->dma_pages[cur].flushed = 0;\r\ncur++;\r\nif (cur == dev_priv->nr_dma_pages)\r\ncur = 0;\r\ndev_priv->first_dma_page = dev_priv->current_dma_page = cur;\r\n} else {\r\ndev_priv->first_dma_page = cur;\r\ndev_priv->dma_pages[cur].flushed = dev_priv->dma_pages[i].used;\r\n}\r\nSET_AGE(&dev_priv->last_dma_age, event, wrap);\r\nDRM_DEBUG("first=cur=%u, cur->used=%u, cur->flushed=%u\n", cur,\r\ndev_priv->dma_pages[cur].used,\r\ndev_priv->dma_pages[cur].flushed);\r\n}\r\nstatic void savage_fake_dma_flush(drm_savage_private_t * dev_priv)\r\n{\r\nunsigned int i, j;\r\nBCI_LOCALS;\r\nif (dev_priv->first_dma_page == dev_priv->current_dma_page &&\r\ndev_priv->dma_pages[dev_priv->current_dma_page].used == 0)\r\nreturn;\r\nDRM_DEBUG("first=%u, cur=%u, cur->used=%u\n",\r\ndev_priv->first_dma_page, dev_priv->current_dma_page,\r\ndev_priv->dma_pages[dev_priv->current_dma_page].used);\r\nfor (i = dev_priv->first_dma_page;\r\ni <= dev_priv->current_dma_page && dev_priv->dma_pages[i].used;\r\n++i) {\r\nuint32_t *dma_ptr = (uint32_t *) dev_priv->cmd_dma->handle +\r\ni * SAVAGE_DMA_PAGE_SIZE;\r\n#if SAVAGE_DMA_DEBUG\r\nif (i < dev_priv->current_dma_page &&\r\ndev_priv->dma_pages[i].used != SAVAGE_DMA_PAGE_SIZE) {\r\nDRM_ERROR("partial DMA page %u: used=%u",\r\ni, dev_priv->dma_pages[i].used);\r\n}\r\n#endif\r\nBEGIN_BCI(dev_priv->dma_pages[i].used);\r\nfor (j = 0; j < dev_priv->dma_pages[i].used; ++j) {\r\nBCI_WRITE(dma_ptr[j]);\r\n}\r\ndev_priv->dma_pages[i].used = 0;\r\n}\r\ndev_priv->first_dma_page = dev_priv->current_dma_page = 0;\r\n}\r\nint savage_driver_load(struct drm_device *dev, unsigned long chipset)\r\n{\r\ndrm_savage_private_t *dev_priv;\r\ndev_priv = kzalloc(sizeof(drm_savage_private_t), GFP_KERNEL);\r\nif (dev_priv == NULL)\r\nreturn -ENOMEM;\r\ndev->dev_private = (void *)dev_priv;\r\ndev_priv->chipset = (enum savage_family)chipset;\r\npci_set_master(dev->pdev);\r\nreturn 0;\r\n}\r\nint savage_driver_firstopen(struct drm_device *dev)\r\n{\r\ndrm_savage_private_t *dev_priv = dev->dev_private;\r\nunsigned long mmio_base, fb_base, fb_size, aperture_base;\r\nunsigned int fb_rsrc, aper_rsrc;\r\nint ret = 0;\r\nif (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {\r\nfb_rsrc = 0;\r\nfb_base = pci_resource_start(dev->pdev, 0);\r\nfb_size = SAVAGE_FB_SIZE_S3;\r\nmmio_base = fb_base + SAVAGE_FB_SIZE_S3;\r\naper_rsrc = 0;\r\naperture_base = fb_base + SAVAGE_APERTURE_OFFSET;\r\nif (pci_resource_len(dev->pdev, 0) == 0x08000000) {\r\ndev_priv->mtrr_handles[0] =\r\narch_phys_wc_add(fb_base, 0x01000000);\r\ndev_priv->mtrr_handles[1] =\r\narch_phys_wc_add(fb_base + 0x02000000,\r\n0x02000000);\r\ndev_priv->mtrr_handles[2] =\r\narch_phys_wc_add(fb_base + 0x04000000,\r\n0x04000000);\r\n} else {\r\nDRM_ERROR("strange pci_resource_len %08llx\n",\r\n(unsigned long long)\r\npci_resource_len(dev->pdev, 0));\r\n}\r\n} else if (dev_priv->chipset != S3_SUPERSAVAGE &&\r\ndev_priv->chipset != S3_SAVAGE2000) {\r\nmmio_base = pci_resource_start(dev->pdev, 0);\r\nfb_rsrc = 1;\r\nfb_base = pci_resource_start(dev->pdev, 1);\r\nfb_size = SAVAGE_FB_SIZE_S4;\r\naper_rsrc = 1;\r\naperture_base = fb_base + SAVAGE_APERTURE_OFFSET;\r\nif (pci_resource_len(dev->pdev, 1) == 0x08000000) {\r\ndev_priv->mtrr_handles[0] =\r\narch_phys_wc_add(fb_base,\r\n0x08000000);\r\n} else {\r\nDRM_ERROR("strange pci_resource_len %08llx\n",\r\n(unsigned long long)\r\npci_resource_len(dev->pdev, 1));\r\n}\r\n} else {\r\nmmio_base = pci_resource_start(dev->pdev, 0);\r\nfb_rsrc = 1;\r\nfb_base = pci_resource_start(dev->pdev, 1);\r\nfb_size = pci_resource_len(dev->pdev, 1);\r\naper_rsrc = 2;\r\naperture_base = pci_resource_start(dev->pdev, 2);\r\n}\r\nret = drm_legacy_addmap(dev, mmio_base, SAVAGE_MMIO_SIZE,\r\n_DRM_REGISTERS, _DRM_READ_ONLY,\r\n&dev_priv->mmio);\r\nif (ret)\r\nreturn ret;\r\nret = drm_legacy_addmap(dev, fb_base, fb_size, _DRM_FRAME_BUFFER,\r\n_DRM_WRITE_COMBINING, &dev_priv->fb);\r\nif (ret)\r\nreturn ret;\r\nret = drm_legacy_addmap(dev, aperture_base, SAVAGE_APERTURE_SIZE,\r\n_DRM_FRAME_BUFFER, _DRM_WRITE_COMBINING,\r\n&dev_priv->aperture);\r\nreturn ret;\r\n}\r\nvoid savage_driver_lastclose(struct drm_device *dev)\r\n{\r\ndrm_savage_private_t *dev_priv = dev->dev_private;\r\nint i;\r\nfor (i = 0; i < 3; ++i) {\r\narch_phys_wc_del(dev_priv->mtrr_handles[i]);\r\ndev_priv->mtrr_handles[i] = 0;\r\n}\r\n}\r\nvoid savage_driver_unload(struct drm_device *dev)\r\n{\r\ndrm_savage_private_t *dev_priv = dev->dev_private;\r\nkfree(dev_priv);\r\n}\r\nstatic int savage_do_init_bci(struct drm_device * dev, drm_savage_init_t * init)\r\n{\r\ndrm_savage_private_t *dev_priv = dev->dev_private;\r\nif (init->fb_bpp != 16 && init->fb_bpp != 32) {\r\nDRM_ERROR("invalid frame buffer bpp %d!\n", init->fb_bpp);\r\nreturn -EINVAL;\r\n}\r\nif (init->depth_bpp != 16 && init->depth_bpp != 32) {\r\nDRM_ERROR("invalid depth buffer bpp %d!\n", init->fb_bpp);\r\nreturn -EINVAL;\r\n}\r\nif (init->dma_type != SAVAGE_DMA_AGP &&\r\ninit->dma_type != SAVAGE_DMA_PCI) {\r\nDRM_ERROR("invalid dma memory type %d!\n", init->dma_type);\r\nreturn -EINVAL;\r\n}\r\ndev_priv->cob_size = init->cob_size;\r\ndev_priv->bci_threshold_lo = init->bci_threshold_lo;\r\ndev_priv->bci_threshold_hi = init->bci_threshold_hi;\r\ndev_priv->dma_type = init->dma_type;\r\ndev_priv->fb_bpp = init->fb_bpp;\r\ndev_priv->front_offset = init->front_offset;\r\ndev_priv->front_pitch = init->front_pitch;\r\ndev_priv->back_offset = init->back_offset;\r\ndev_priv->back_pitch = init->back_pitch;\r\ndev_priv->depth_bpp = init->depth_bpp;\r\ndev_priv->depth_offset = init->depth_offset;\r\ndev_priv->depth_pitch = init->depth_pitch;\r\ndev_priv->texture_offset = init->texture_offset;\r\ndev_priv->texture_size = init->texture_size;\r\ndev_priv->sarea = drm_legacy_getsarea(dev);\r\nif (!dev_priv->sarea) {\r\nDRM_ERROR("could not find sarea!\n");\r\nsavage_do_cleanup_bci(dev);\r\nreturn -EINVAL;\r\n}\r\nif (init->status_offset != 0) {\r\ndev_priv->status = drm_legacy_findmap(dev, init->status_offset);\r\nif (!dev_priv->status) {\r\nDRM_ERROR("could not find shadow status region!\n");\r\nsavage_do_cleanup_bci(dev);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\ndev_priv->status = NULL;\r\n}\r\nif (dev_priv->dma_type == SAVAGE_DMA_AGP && init->buffers_offset) {\r\ndev->agp_buffer_token = init->buffers_offset;\r\ndev->agp_buffer_map = drm_legacy_findmap(dev,\r\ninit->buffers_offset);\r\nif (!dev->agp_buffer_map) {\r\nDRM_ERROR("could not find DMA buffer region!\n");\r\nsavage_do_cleanup_bci(dev);\r\nreturn -EINVAL;\r\n}\r\ndrm_legacy_ioremap(dev->agp_buffer_map, dev);\r\nif (!dev->agp_buffer_map->handle) {\r\nDRM_ERROR("failed to ioremap DMA buffer region!\n");\r\nsavage_do_cleanup_bci(dev);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nif (init->agp_textures_offset) {\r\ndev_priv->agp_textures =\r\ndrm_legacy_findmap(dev, init->agp_textures_offset);\r\nif (!dev_priv->agp_textures) {\r\nDRM_ERROR("could not find agp texture region!\n");\r\nsavage_do_cleanup_bci(dev);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\ndev_priv->agp_textures = NULL;\r\n}\r\nif (init->cmd_dma_offset) {\r\nif (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {\r\nDRM_ERROR("command DMA not supported on "\r\n"Savage3D/MX/IX.\n");\r\nsavage_do_cleanup_bci(dev);\r\nreturn -EINVAL;\r\n}\r\nif (dev->dma && dev->dma->buflist) {\r\nDRM_ERROR("command and vertex DMA not supported "\r\n"at the same time.\n");\r\nsavage_do_cleanup_bci(dev);\r\nreturn -EINVAL;\r\n}\r\ndev_priv->cmd_dma = drm_legacy_findmap(dev, init->cmd_dma_offset);\r\nif (!dev_priv->cmd_dma) {\r\nDRM_ERROR("could not find command DMA region!\n");\r\nsavage_do_cleanup_bci(dev);\r\nreturn -EINVAL;\r\n}\r\nif (dev_priv->dma_type == SAVAGE_DMA_AGP) {\r\nif (dev_priv->cmd_dma->type != _DRM_AGP) {\r\nDRM_ERROR("AGP command DMA region is not a "\r\n"_DRM_AGP map!\n");\r\nsavage_do_cleanup_bci(dev);\r\nreturn -EINVAL;\r\n}\r\ndrm_legacy_ioremap(dev_priv->cmd_dma, dev);\r\nif (!dev_priv->cmd_dma->handle) {\r\nDRM_ERROR("failed to ioremap command "\r\n"DMA region!\n");\r\nsavage_do_cleanup_bci(dev);\r\nreturn -ENOMEM;\r\n}\r\n} else if (dev_priv->cmd_dma->type != _DRM_CONSISTENT) {\r\nDRM_ERROR("PCI command DMA region is not a "\r\n"_DRM_CONSISTENT map!\n");\r\nsavage_do_cleanup_bci(dev);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\ndev_priv->cmd_dma = NULL;\r\n}\r\ndev_priv->dma_flush = savage_dma_flush;\r\nif (!dev_priv->cmd_dma) {\r\nDRM_DEBUG("falling back to faked command DMA.\n");\r\ndev_priv->fake_dma.offset = 0;\r\ndev_priv->fake_dma.size = SAVAGE_FAKE_DMA_SIZE;\r\ndev_priv->fake_dma.type = _DRM_SHM;\r\ndev_priv->fake_dma.handle = kmalloc(SAVAGE_FAKE_DMA_SIZE,\r\nGFP_KERNEL);\r\nif (!dev_priv->fake_dma.handle) {\r\nDRM_ERROR("could not allocate faked DMA buffer!\n");\r\nsavage_do_cleanup_bci(dev);\r\nreturn -ENOMEM;\r\n}\r\ndev_priv->cmd_dma = &dev_priv->fake_dma;\r\ndev_priv->dma_flush = savage_fake_dma_flush;\r\n}\r\ndev_priv->sarea_priv =\r\n(drm_savage_sarea_t *) ((uint8_t *) dev_priv->sarea->handle +\r\ninit->sarea_priv_offset);\r\n{\r\nunsigned int color_tile_format;\r\nunsigned int depth_tile_format;\r\nunsigned int front_stride, back_stride, depth_stride;\r\nif (dev_priv->chipset <= S3_SAVAGE4) {\r\ncolor_tile_format = dev_priv->fb_bpp == 16 ?\r\nSAVAGE_BD_TILE_16BPP : SAVAGE_BD_TILE_32BPP;\r\ndepth_tile_format = dev_priv->depth_bpp == 16 ?\r\nSAVAGE_BD_TILE_16BPP : SAVAGE_BD_TILE_32BPP;\r\n} else {\r\ncolor_tile_format = SAVAGE_BD_TILE_DEST;\r\ndepth_tile_format = SAVAGE_BD_TILE_DEST;\r\n}\r\nfront_stride = dev_priv->front_pitch / (dev_priv->fb_bpp / 8);\r\nback_stride = dev_priv->back_pitch / (dev_priv->fb_bpp / 8);\r\ndepth_stride =\r\ndev_priv->depth_pitch / (dev_priv->depth_bpp / 8);\r\ndev_priv->front_bd = front_stride | SAVAGE_BD_BW_DISABLE |\r\n(dev_priv->fb_bpp << SAVAGE_BD_BPP_SHIFT) |\r\n(color_tile_format << SAVAGE_BD_TILE_SHIFT);\r\ndev_priv->back_bd = back_stride | SAVAGE_BD_BW_DISABLE |\r\n(dev_priv->fb_bpp << SAVAGE_BD_BPP_SHIFT) |\r\n(color_tile_format << SAVAGE_BD_TILE_SHIFT);\r\ndev_priv->depth_bd = depth_stride | SAVAGE_BD_BW_DISABLE |\r\n(dev_priv->depth_bpp << SAVAGE_BD_BPP_SHIFT) |\r\n(depth_tile_format << SAVAGE_BD_TILE_SHIFT);\r\n}\r\ndev_priv->event_counter = 0;\r\ndev_priv->event_wrap = 0;\r\ndev_priv->bci_ptr = (volatile uint32_t *)\r\n((uint8_t *) dev_priv->mmio->handle + SAVAGE_BCI_OFFSET);\r\nif (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {\r\ndev_priv->status_used_mask = SAVAGE_FIFO_USED_MASK_S3D;\r\n} else {\r\ndev_priv->status_used_mask = SAVAGE_FIFO_USED_MASK_S4;\r\n}\r\nif (dev_priv->status != NULL) {\r\ndev_priv->status_ptr =\r\n(volatile uint32_t *)dev_priv->status->handle;\r\ndev_priv->wait_fifo = savage_bci_wait_fifo_shadow;\r\ndev_priv->wait_evnt = savage_bci_wait_event_shadow;\r\ndev_priv->status_ptr[1023] = dev_priv->event_counter;\r\n} else {\r\ndev_priv->status_ptr = NULL;\r\nif (S3_SAVAGE3D_SERIES(dev_priv->chipset)) {\r\ndev_priv->wait_fifo = savage_bci_wait_fifo_s3d;\r\n} else {\r\ndev_priv->wait_fifo = savage_bci_wait_fifo_s4;\r\n}\r\ndev_priv->wait_evnt = savage_bci_wait_event_reg;\r\n}\r\nif (S3_SAVAGE3D_SERIES(dev_priv->chipset))\r\ndev_priv->emit_clip_rect = savage_emit_clip_rect_s3d;\r\nelse\r\ndev_priv->emit_clip_rect = savage_emit_clip_rect_s4;\r\nif (savage_freelist_init(dev) < 0) {\r\nDRM_ERROR("could not initialize freelist\n");\r\nsavage_do_cleanup_bci(dev);\r\nreturn -ENOMEM;\r\n}\r\nif (savage_dma_init(dev_priv) < 0) {\r\nDRM_ERROR("could not initialize command DMA\n");\r\nsavage_do_cleanup_bci(dev);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int savage_do_cleanup_bci(struct drm_device * dev)\r\n{\r\ndrm_savage_private_t *dev_priv = dev->dev_private;\r\nif (dev_priv->cmd_dma == &dev_priv->fake_dma) {\r\nkfree(dev_priv->fake_dma.handle);\r\n} else if (dev_priv->cmd_dma && dev_priv->cmd_dma->handle &&\r\ndev_priv->cmd_dma->type == _DRM_AGP &&\r\ndev_priv->dma_type == SAVAGE_DMA_AGP)\r\ndrm_legacy_ioremapfree(dev_priv->cmd_dma, dev);\r\nif (dev_priv->dma_type == SAVAGE_DMA_AGP &&\r\ndev->agp_buffer_map && dev->agp_buffer_map->handle) {\r\ndrm_legacy_ioremapfree(dev->agp_buffer_map, dev);\r\ndev->agp_buffer_map = NULL;\r\n}\r\nkfree(dev_priv->dma_pages);\r\nreturn 0;\r\n}\r\nstatic int savage_bci_init(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_savage_init_t *init = data;\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nswitch (init->func) {\r\ncase SAVAGE_INIT_BCI:\r\nreturn savage_do_init_bci(dev, init);\r\ncase SAVAGE_CLEANUP_BCI:\r\nreturn savage_do_cleanup_bci(dev);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int savage_bci_event_emit(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_savage_private_t *dev_priv = dev->dev_private;\r\ndrm_savage_event_emit_t *event = data;\r\nDRM_DEBUG("\n");\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nevent->count = savage_bci_emit_event(dev_priv, event->flags);\r\nevent->count |= dev_priv->event_wrap << 16;\r\nreturn 0;\r\n}\r\nstatic int savage_bci_event_wait(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_savage_private_t *dev_priv = dev->dev_private;\r\ndrm_savage_event_wait_t *event = data;\r\nunsigned int event_e, hw_e;\r\nunsigned int event_w, hw_w;\r\nDRM_DEBUG("\n");\r\nUPDATE_EVENT_COUNTER();\r\nif (dev_priv->status_ptr)\r\nhw_e = dev_priv->status_ptr[1] & 0xffff;\r\nelse\r\nhw_e = SAVAGE_READ(SAVAGE_STATUS_WORD1) & 0xffff;\r\nhw_w = dev_priv->event_wrap;\r\nif (hw_e > dev_priv->event_counter)\r\nhw_w--;\r\nevent_e = event->count & 0xffff;\r\nevent_w = event->count >> 16;\r\nif (event_w < hw_w || (event_w == hw_w && event_e <= hw_e))\r\nreturn 0;\r\nelse\r\nreturn dev_priv->wait_evnt(dev_priv, event_e);\r\n}\r\nstatic int savage_bci_get_buffers(struct drm_device *dev,\r\nstruct drm_file *file_priv,\r\nstruct drm_dma *d)\r\n{\r\nstruct drm_buf *buf;\r\nint i;\r\nfor (i = d->granted_count; i < d->request_count; i++) {\r\nbuf = savage_freelist_get(dev);\r\nif (!buf)\r\nreturn -EAGAIN;\r\nbuf->file_priv = file_priv;\r\nif (copy_to_user(&d->request_indices[i],\r\n&buf->idx, sizeof(buf->idx)))\r\nreturn -EFAULT;\r\nif (copy_to_user(&d->request_sizes[i],\r\n&buf->total, sizeof(buf->total)))\r\nreturn -EFAULT;\r\nd->granted_count++;\r\n}\r\nreturn 0;\r\n}\r\nint savage_bci_buffers(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\nstruct drm_device_dma *dma = dev->dma;\r\nstruct drm_dma *d = data;\r\nint ret = 0;\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nif (d->send_count != 0) {\r\nDRM_ERROR("Process %d trying to send %d buffers via drmDMA\n",\r\nDRM_CURRENTPID, d->send_count);\r\nreturn -EINVAL;\r\n}\r\nif (d->request_count < 0 || d->request_count > dma->buf_count) {\r\nDRM_ERROR("Process %d trying to get %d buffers (of %d max)\n",\r\nDRM_CURRENTPID, d->request_count, dma->buf_count);\r\nreturn -EINVAL;\r\n}\r\nd->granted_count = 0;\r\nif (d->request_count) {\r\nret = savage_bci_get_buffers(dev, file_priv, d);\r\n}\r\nreturn ret;\r\n}\r\nvoid savage_reclaim_buffers(struct drm_device *dev, struct drm_file *file_priv)\r\n{\r\nstruct drm_device_dma *dma = dev->dma;\r\ndrm_savage_private_t *dev_priv = dev->dev_private;\r\nint release_idlelock = 0;\r\nint i;\r\nif (!dma)\r\nreturn;\r\nif (!dev_priv)\r\nreturn;\r\nif (!dma->buflist)\r\nreturn;\r\nif (file_priv->master && file_priv->master->lock.hw_lock) {\r\ndrm_legacy_idlelock_take(&file_priv->master->lock);\r\nrelease_idlelock = 1;\r\n}\r\nfor (i = 0; i < dma->buf_count; i++) {\r\nstruct drm_buf *buf = dma->buflist[i];\r\ndrm_savage_buf_priv_t *buf_priv = buf->dev_private;\r\nif (buf->file_priv == file_priv && buf_priv &&\r\nbuf_priv->next == NULL && buf_priv->prev == NULL) {\r\nuint16_t event;\r\nDRM_DEBUG("reclaimed from client\n");\r\nevent = savage_bci_emit_event(dev_priv, SAVAGE_WAIT_3D);\r\nSET_AGE(&buf_priv->age, event, dev_priv->event_wrap);\r\nsavage_freelist_put(dev, buf);\r\n}\r\n}\r\nif (release_idlelock)\r\ndrm_legacy_idlelock_release(&file_priv->master->lock);\r\n}
