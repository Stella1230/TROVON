static void hci_connect_le_scan_cleanup(struct hci_conn *conn)\r\n{\r\nstruct hci_conn_params *params;\r\nstruct hci_dev *hdev = conn->hdev;\r\nstruct smp_irk *irk;\r\nbdaddr_t *bdaddr;\r\nu8 bdaddr_type;\r\nbdaddr = &conn->dst;\r\nbdaddr_type = conn->dst_type;\r\nirk = hci_get_irk(hdev, bdaddr, bdaddr_type);\r\nif (irk) {\r\nbdaddr = &irk->bdaddr;\r\nbdaddr_type = irk->addr_type;\r\n}\r\nparams = hci_pend_le_action_lookup(&hdev->pend_le_conns, bdaddr,\r\nbdaddr_type);\r\nif (!params || !params->explicit_connect)\r\nreturn;\r\nparams->explicit_connect = false;\r\nlist_del_init(&params->action);\r\nswitch (params->auto_connect) {\r\ncase HCI_AUTO_CONN_EXPLICIT:\r\nhci_conn_params_del(hdev, bdaddr, bdaddr_type);\r\nreturn;\r\ncase HCI_AUTO_CONN_DIRECT:\r\ncase HCI_AUTO_CONN_ALWAYS:\r\nlist_add(&params->action, &hdev->pend_le_conns);\r\nbreak;\r\ncase HCI_AUTO_CONN_REPORT:\r\nlist_add(&params->action, &hdev->pend_le_reports);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nhci_update_background_scan(hdev);\r\n}\r\nstatic void hci_conn_cleanup(struct hci_conn *conn)\r\n{\r\nstruct hci_dev *hdev = conn->hdev;\r\nif (test_bit(HCI_CONN_PARAM_REMOVAL_PEND, &conn->flags))\r\nhci_conn_params_del(conn->hdev, &conn->dst, conn->dst_type);\r\nhci_chan_list_flush(conn);\r\nhci_conn_hash_del(hdev, conn);\r\nif (hdev->notify)\r\nhdev->notify(hdev, HCI_NOTIFY_CONN_DEL);\r\nhci_conn_del_sysfs(conn);\r\ndebugfs_remove_recursive(conn->debugfs);\r\nhci_dev_put(hdev);\r\nhci_conn_put(conn);\r\n}\r\nstatic void le_scan_cleanup(struct work_struct *work)\r\n{\r\nstruct hci_conn *conn = container_of(work, struct hci_conn,\r\nle_scan_cleanup);\r\nstruct hci_dev *hdev = conn->hdev;\r\nstruct hci_conn *c = NULL;\r\nBT_DBG("%s hcon %p", hdev->name, conn);\r\nhci_dev_lock(hdev);\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(c, &hdev->conn_hash.list, list) {\r\nif (c == conn)\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nif (c == conn) {\r\nhci_connect_le_scan_cleanup(conn);\r\nhci_conn_cleanup(conn);\r\n}\r\nhci_dev_unlock(hdev);\r\nhci_dev_put(hdev);\r\nhci_conn_put(conn);\r\n}\r\nstatic void hci_connect_le_scan_remove(struct hci_conn *conn)\r\n{\r\nBT_DBG("%s hcon %p", conn->hdev->name, conn);\r\nhci_dev_hold(conn->hdev);\r\nhci_conn_get(conn);\r\nschedule_work(&conn->le_scan_cleanup);\r\n}\r\nstatic void hci_acl_create_connection(struct hci_conn *conn)\r\n{\r\nstruct hci_dev *hdev = conn->hdev;\r\nstruct inquiry_entry *ie;\r\nstruct hci_cp_create_conn cp;\r\nBT_DBG("hcon %p", conn);\r\nconn->state = BT_CONNECT;\r\nconn->out = true;\r\nconn->role = HCI_ROLE_MASTER;\r\nconn->attempt++;\r\nconn->link_policy = hdev->link_policy;\r\nmemset(&cp, 0, sizeof(cp));\r\nbacpy(&cp.bdaddr, &conn->dst);\r\ncp.pscan_rep_mode = 0x02;\r\nie = hci_inquiry_cache_lookup(hdev, &conn->dst);\r\nif (ie) {\r\nif (inquiry_entry_age(ie) <= INQUIRY_ENTRY_AGE_MAX) {\r\ncp.pscan_rep_mode = ie->data.pscan_rep_mode;\r\ncp.pscan_mode = ie->data.pscan_mode;\r\ncp.clock_offset = ie->data.clock_offset |\r\ncpu_to_le16(0x8000);\r\n}\r\nmemcpy(conn->dev_class, ie->data.dev_class, 3);\r\nif (ie->data.ssp_mode > 0)\r\nset_bit(HCI_CONN_SSP_ENABLED, &conn->flags);\r\n}\r\ncp.pkt_type = cpu_to_le16(conn->pkt_type);\r\nif (lmp_rswitch_capable(hdev) && !(hdev->link_mode & HCI_LM_MASTER))\r\ncp.role_switch = 0x01;\r\nelse\r\ncp.role_switch = 0x00;\r\nhci_send_cmd(hdev, HCI_OP_CREATE_CONN, sizeof(cp), &cp);\r\n}\r\nint hci_disconnect(struct hci_conn *conn, __u8 reason)\r\n{\r\nBT_DBG("hcon %p", conn);\r\nif (conn->type == ACL_LINK && conn->role == HCI_ROLE_MASTER &&\r\n(conn->state == BT_CONNECTED || conn->state == BT_CONFIG)) {\r\nstruct hci_dev *hdev = conn->hdev;\r\nstruct hci_cp_read_clock_offset clkoff_cp;\r\nclkoff_cp.handle = cpu_to_le16(conn->handle);\r\nhci_send_cmd(hdev, HCI_OP_READ_CLOCK_OFFSET, sizeof(clkoff_cp),\r\n&clkoff_cp);\r\n}\r\nreturn hci_abort_conn(conn, reason);\r\n}\r\nstatic void hci_add_sco(struct hci_conn *conn, __u16 handle)\r\n{\r\nstruct hci_dev *hdev = conn->hdev;\r\nstruct hci_cp_add_sco cp;\r\nBT_DBG("hcon %p", conn);\r\nconn->state = BT_CONNECT;\r\nconn->out = true;\r\nconn->attempt++;\r\ncp.handle = cpu_to_le16(handle);\r\ncp.pkt_type = cpu_to_le16(conn->pkt_type);\r\nhci_send_cmd(hdev, HCI_OP_ADD_SCO, sizeof(cp), &cp);\r\n}\r\nbool hci_setup_sync(struct hci_conn *conn, __u16 handle)\r\n{\r\nstruct hci_dev *hdev = conn->hdev;\r\nstruct hci_cp_setup_sync_conn cp;\r\nconst struct sco_param *param;\r\nBT_DBG("hcon %p", conn);\r\nconn->state = BT_CONNECT;\r\nconn->out = true;\r\nconn->attempt++;\r\ncp.handle = cpu_to_le16(handle);\r\ncp.tx_bandwidth = cpu_to_le32(0x00001f40);\r\ncp.rx_bandwidth = cpu_to_le32(0x00001f40);\r\ncp.voice_setting = cpu_to_le16(conn->setting);\r\nswitch (conn->setting & SCO_AIRMODE_MASK) {\r\ncase SCO_AIRMODE_TRANSP:\r\nif (conn->attempt > ARRAY_SIZE(esco_param_msbc))\r\nreturn false;\r\nparam = &esco_param_msbc[conn->attempt - 1];\r\nbreak;\r\ncase SCO_AIRMODE_CVSD:\r\nif (lmp_esco_capable(conn->link)) {\r\nif (conn->attempt > ARRAY_SIZE(esco_param_cvsd))\r\nreturn false;\r\nparam = &esco_param_cvsd[conn->attempt - 1];\r\n} else {\r\nif (conn->attempt > ARRAY_SIZE(sco_param_cvsd))\r\nreturn false;\r\nparam = &sco_param_cvsd[conn->attempt - 1];\r\n}\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\ncp.retrans_effort = param->retrans_effort;\r\ncp.pkt_type = __cpu_to_le16(param->pkt_type);\r\ncp.max_latency = __cpu_to_le16(param->max_latency);\r\nif (hci_send_cmd(hdev, HCI_OP_SETUP_SYNC_CONN, sizeof(cp), &cp) < 0)\r\nreturn false;\r\nreturn true;\r\n}\r\nu8 hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max, u16 latency,\r\nu16 to_multiplier)\r\n{\r\nstruct hci_dev *hdev = conn->hdev;\r\nstruct hci_conn_params *params;\r\nstruct hci_cp_le_conn_update cp;\r\nhci_dev_lock(hdev);\r\nparams = hci_conn_params_lookup(hdev, &conn->dst, conn->dst_type);\r\nif (params) {\r\nparams->conn_min_interval = min;\r\nparams->conn_max_interval = max;\r\nparams->conn_latency = latency;\r\nparams->supervision_timeout = to_multiplier;\r\n}\r\nhci_dev_unlock(hdev);\r\nmemset(&cp, 0, sizeof(cp));\r\ncp.handle = cpu_to_le16(conn->handle);\r\ncp.conn_interval_min = cpu_to_le16(min);\r\ncp.conn_interval_max = cpu_to_le16(max);\r\ncp.conn_latency = cpu_to_le16(latency);\r\ncp.supervision_timeout = cpu_to_le16(to_multiplier);\r\ncp.min_ce_len = cpu_to_le16(0x0000);\r\ncp.max_ce_len = cpu_to_le16(0x0000);\r\nhci_send_cmd(hdev, HCI_OP_LE_CONN_UPDATE, sizeof(cp), &cp);\r\nif (params)\r\nreturn 0x01;\r\nreturn 0x00;\r\n}\r\nvoid hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __le64 rand,\r\n__u8 ltk[16], __u8 key_size)\r\n{\r\nstruct hci_dev *hdev = conn->hdev;\r\nstruct hci_cp_le_start_enc cp;\r\nBT_DBG("hcon %p", conn);\r\nmemset(&cp, 0, sizeof(cp));\r\ncp.handle = cpu_to_le16(conn->handle);\r\ncp.rand = rand;\r\ncp.ediv = ediv;\r\nmemcpy(cp.ltk, ltk, key_size);\r\nhci_send_cmd(hdev, HCI_OP_LE_START_ENC, sizeof(cp), &cp);\r\n}\r\nvoid hci_sco_setup(struct hci_conn *conn, __u8 status)\r\n{\r\nstruct hci_conn *sco = conn->link;\r\nif (!sco)\r\nreturn;\r\nBT_DBG("hcon %p", conn);\r\nif (!status) {\r\nif (lmp_esco_capable(conn->hdev))\r\nhci_setup_sync(sco, conn->handle);\r\nelse\r\nhci_add_sco(sco, conn->handle);\r\n} else {\r\nhci_connect_cfm(sco, status);\r\nhci_conn_del(sco);\r\n}\r\n}\r\nstatic void hci_conn_timeout(struct work_struct *work)\r\n{\r\nstruct hci_conn *conn = container_of(work, struct hci_conn,\r\ndisc_work.work);\r\nint refcnt = atomic_read(&conn->refcnt);\r\nBT_DBG("hcon %p state %s", conn, state_to_string(conn->state));\r\nWARN_ON(refcnt < 0);\r\nif (refcnt > 0)\r\nreturn;\r\nif (conn->state == BT_CONNECT && conn->type == LE_LINK &&\r\ntest_bit(HCI_CONN_SCANNING, &conn->flags)) {\r\nhci_connect_le_scan_remove(conn);\r\nreturn;\r\n}\r\nhci_abort_conn(conn, hci_proto_disconn_ind(conn));\r\n}\r\nstatic void hci_conn_idle(struct work_struct *work)\r\n{\r\nstruct hci_conn *conn = container_of(work, struct hci_conn,\r\nidle_work.work);\r\nstruct hci_dev *hdev = conn->hdev;\r\nBT_DBG("hcon %p mode %d", conn, conn->mode);\r\nif (!lmp_sniff_capable(hdev) || !lmp_sniff_capable(conn))\r\nreturn;\r\nif (conn->mode != HCI_CM_ACTIVE || !(conn->link_policy & HCI_LP_SNIFF))\r\nreturn;\r\nif (lmp_sniffsubr_capable(hdev) && lmp_sniffsubr_capable(conn)) {\r\nstruct hci_cp_sniff_subrate cp;\r\ncp.handle = cpu_to_le16(conn->handle);\r\ncp.max_latency = cpu_to_le16(0);\r\ncp.min_remote_timeout = cpu_to_le16(0);\r\ncp.min_local_timeout = cpu_to_le16(0);\r\nhci_send_cmd(hdev, HCI_OP_SNIFF_SUBRATE, sizeof(cp), &cp);\r\n}\r\nif (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->flags)) {\r\nstruct hci_cp_sniff_mode cp;\r\ncp.handle = cpu_to_le16(conn->handle);\r\ncp.max_interval = cpu_to_le16(hdev->sniff_max_interval);\r\ncp.min_interval = cpu_to_le16(hdev->sniff_min_interval);\r\ncp.attempt = cpu_to_le16(4);\r\ncp.timeout = cpu_to_le16(1);\r\nhci_send_cmd(hdev, HCI_OP_SNIFF_MODE, sizeof(cp), &cp);\r\n}\r\n}\r\nstatic void hci_conn_auto_accept(struct work_struct *work)\r\n{\r\nstruct hci_conn *conn = container_of(work, struct hci_conn,\r\nauto_accept_work.work);\r\nhci_send_cmd(conn->hdev, HCI_OP_USER_CONFIRM_REPLY, sizeof(conn->dst),\r\n&conn->dst);\r\n}\r\nstatic void le_conn_timeout(struct work_struct *work)\r\n{\r\nstruct hci_conn *conn = container_of(work, struct hci_conn,\r\nle_conn_timeout.work);\r\nstruct hci_dev *hdev = conn->hdev;\r\nBT_DBG("");\r\nif (conn->role == HCI_ROLE_SLAVE) {\r\nu8 enable = 0x00;\r\nhci_send_cmd(hdev, HCI_OP_LE_SET_ADV_ENABLE, sizeof(enable),\r\n&enable);\r\nhci_le_conn_failed(conn, HCI_ERROR_ADVERTISING_TIMEOUT);\r\nreturn;\r\n}\r\nhci_abort_conn(conn, HCI_ERROR_REMOTE_USER_TERM);\r\n}\r\nstruct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst,\r\nu8 role)\r\n{\r\nstruct hci_conn *conn;\r\nBT_DBG("%s dst %pMR", hdev->name, dst);\r\nconn = kzalloc(sizeof(*conn), GFP_KERNEL);\r\nif (!conn)\r\nreturn NULL;\r\nbacpy(&conn->dst, dst);\r\nbacpy(&conn->src, &hdev->bdaddr);\r\nconn->hdev = hdev;\r\nconn->type = type;\r\nconn->role = role;\r\nconn->mode = HCI_CM_ACTIVE;\r\nconn->state = BT_OPEN;\r\nconn->auth_type = HCI_AT_GENERAL_BONDING;\r\nconn->io_capability = hdev->io_capability;\r\nconn->remote_auth = 0xff;\r\nconn->key_type = 0xff;\r\nconn->rssi = HCI_RSSI_INVALID;\r\nconn->tx_power = HCI_TX_POWER_INVALID;\r\nconn->max_tx_power = HCI_TX_POWER_INVALID;\r\nset_bit(HCI_CONN_POWER_SAVE, &conn->flags);\r\nconn->disc_timeout = HCI_DISCONN_TIMEOUT;\r\nif (conn->role == HCI_ROLE_MASTER)\r\nconn->out = true;\r\nswitch (type) {\r\ncase ACL_LINK:\r\nconn->pkt_type = hdev->pkt_type & ACL_PTYPE_MASK;\r\nbreak;\r\ncase LE_LINK:\r\nhci_copy_identity_address(hdev, &conn->src, &conn->src_type);\r\nbreak;\r\ncase SCO_LINK:\r\nif (lmp_esco_capable(hdev))\r\nconn->pkt_type = (hdev->esco_type & SCO_ESCO_MASK) |\r\n(hdev->esco_type & EDR_ESCO_MASK);\r\nelse\r\nconn->pkt_type = hdev->pkt_type & SCO_PTYPE_MASK;\r\nbreak;\r\ncase ESCO_LINK:\r\nconn->pkt_type = hdev->esco_type & ~EDR_ESCO_MASK;\r\nbreak;\r\n}\r\nskb_queue_head_init(&conn->data_q);\r\nINIT_LIST_HEAD(&conn->chan_list);\r\nINIT_DELAYED_WORK(&conn->disc_work, hci_conn_timeout);\r\nINIT_DELAYED_WORK(&conn->auto_accept_work, hci_conn_auto_accept);\r\nINIT_DELAYED_WORK(&conn->idle_work, hci_conn_idle);\r\nINIT_DELAYED_WORK(&conn->le_conn_timeout, le_conn_timeout);\r\nINIT_WORK(&conn->le_scan_cleanup, le_scan_cleanup);\r\natomic_set(&conn->refcnt, 0);\r\nhci_dev_hold(hdev);\r\nhci_conn_hash_add(hdev, conn);\r\nif (hdev->notify)\r\nhdev->notify(hdev, HCI_NOTIFY_CONN_ADD);\r\nhci_conn_init_sysfs(conn);\r\nreturn conn;\r\n}\r\nint hci_conn_del(struct hci_conn *conn)\r\n{\r\nstruct hci_dev *hdev = conn->hdev;\r\nBT_DBG("%s hcon %p handle %d", hdev->name, conn, conn->handle);\r\ncancel_delayed_work_sync(&conn->disc_work);\r\ncancel_delayed_work_sync(&conn->auto_accept_work);\r\ncancel_delayed_work_sync(&conn->idle_work);\r\nif (conn->type == ACL_LINK) {\r\nstruct hci_conn *sco = conn->link;\r\nif (sco)\r\nsco->link = NULL;\r\nhdev->acl_cnt += conn->sent;\r\n} else if (conn->type == LE_LINK) {\r\ncancel_delayed_work(&conn->le_conn_timeout);\r\nif (hdev->le_pkts)\r\nhdev->le_cnt += conn->sent;\r\nelse\r\nhdev->acl_cnt += conn->sent;\r\n} else {\r\nstruct hci_conn *acl = conn->link;\r\nif (acl) {\r\nacl->link = NULL;\r\nhci_conn_drop(acl);\r\n}\r\n}\r\nif (conn->amp_mgr)\r\namp_mgr_put(conn->amp_mgr);\r\nskb_queue_purge(&conn->data_q);\r\nhci_conn_cleanup(conn);\r\nreturn 0;\r\n}\r\nstruct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src, uint8_t src_type)\r\n{\r\nint use_src = bacmp(src, BDADDR_ANY);\r\nstruct hci_dev *hdev = NULL, *d;\r\nBT_DBG("%pMR -> %pMR", src, dst);\r\nread_lock(&hci_dev_list_lock);\r\nlist_for_each_entry(d, &hci_dev_list, list) {\r\nif (!test_bit(HCI_UP, &d->flags) ||\r\nhci_dev_test_flag(d, HCI_USER_CHANNEL) ||\r\nd->dev_type != HCI_PRIMARY)\r\ncontinue;\r\nif (use_src) {\r\nbdaddr_t id_addr;\r\nu8 id_addr_type;\r\nif (src_type == BDADDR_BREDR) {\r\nif (!lmp_bredr_capable(d))\r\ncontinue;\r\nbacpy(&id_addr, &d->bdaddr);\r\nid_addr_type = BDADDR_BREDR;\r\n} else {\r\nif (!lmp_le_capable(d))\r\ncontinue;\r\nhci_copy_identity_address(d, &id_addr,\r\n&id_addr_type);\r\nif (id_addr_type == ADDR_LE_DEV_PUBLIC)\r\nid_addr_type = BDADDR_LE_PUBLIC;\r\nelse\r\nid_addr_type = BDADDR_LE_RANDOM;\r\n}\r\nif (!bacmp(&id_addr, src) && id_addr_type == src_type) {\r\nhdev = d; break;\r\n}\r\n} else {\r\nif (bacmp(&d->bdaddr, dst)) {\r\nhdev = d; break;\r\n}\r\n}\r\n}\r\nif (hdev)\r\nhdev = hci_dev_hold(hdev);\r\nread_unlock(&hci_dev_list_lock);\r\nreturn hdev;\r\n}\r\nvoid hci_le_conn_failed(struct hci_conn *conn, u8 status)\r\n{\r\nstruct hci_dev *hdev = conn->hdev;\r\nstruct hci_conn_params *params;\r\nparams = hci_pend_le_action_lookup(&hdev->pend_le_conns, &conn->dst,\r\nconn->dst_type);\r\nif (params && params->conn) {\r\nhci_conn_drop(params->conn);\r\nhci_conn_put(params->conn);\r\nparams->conn = NULL;\r\n}\r\nconn->state = BT_CLOSED;\r\nif (status != HCI_ERROR_UNKNOWN_CONN_ID ||\r\n(params && params->explicit_connect))\r\nmgmt_connect_failed(hdev, &conn->dst, conn->type,\r\nconn->dst_type, status);\r\nhci_connect_cfm(conn, status);\r\nhci_conn_del(conn);\r\nhci_update_background_scan(hdev);\r\nhci_req_reenable_advertising(hdev);\r\n}\r\nstatic void create_le_conn_complete(struct hci_dev *hdev, u8 status, u16 opcode)\r\n{\r\nstruct hci_conn *conn;\r\nhci_dev_lock(hdev);\r\nconn = hci_lookup_le_connect(hdev);\r\nif (!status) {\r\nhci_connect_le_scan_cleanup(conn);\r\ngoto done;\r\n}\r\nBT_ERR("HCI request failed to create LE connection: status 0x%2.2x",\r\nstatus);\r\nif (!conn)\r\ngoto done;\r\nhci_le_conn_failed(conn, status);\r\ndone:\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic bool conn_use_rpa(struct hci_conn *conn)\r\n{\r\nstruct hci_dev *hdev = conn->hdev;\r\nreturn hci_dev_test_flag(hdev, HCI_PRIVACY);\r\n}\r\nstatic void hci_req_add_le_create_conn(struct hci_request *req,\r\nstruct hci_conn *conn)\r\n{\r\nstruct hci_cp_le_create_conn cp;\r\nstruct hci_dev *hdev = conn->hdev;\r\nu8 own_addr_type;\r\nif (hci_update_random_address(req, false, conn_use_rpa(conn),\r\n&own_addr_type))\r\nreturn;\r\nmemset(&cp, 0, sizeof(cp));\r\ncp.scan_interval = cpu_to_le16(hdev->le_scan_interval);\r\ncp.scan_window = cp.scan_interval;\r\nbacpy(&cp.peer_addr, &conn->dst);\r\ncp.peer_addr_type = conn->dst_type;\r\ncp.own_address_type = own_addr_type;\r\ncp.conn_interval_min = cpu_to_le16(conn->le_conn_min_interval);\r\ncp.conn_interval_max = cpu_to_le16(conn->le_conn_max_interval);\r\ncp.conn_latency = cpu_to_le16(conn->le_conn_latency);\r\ncp.supervision_timeout = cpu_to_le16(conn->le_supv_timeout);\r\ncp.min_ce_len = cpu_to_le16(0x0000);\r\ncp.max_ce_len = cpu_to_le16(0x0000);\r\nhci_req_add(req, HCI_OP_LE_CREATE_CONN, sizeof(cp), &cp);\r\nconn->state = BT_CONNECT;\r\nclear_bit(HCI_CONN_SCANNING, &conn->flags);\r\n}\r\nstatic void hci_req_directed_advertising(struct hci_request *req,\r\nstruct hci_conn *conn)\r\n{\r\nstruct hci_dev *hdev = req->hdev;\r\nstruct hci_cp_le_set_adv_param cp;\r\nu8 own_addr_type;\r\nu8 enable;\r\nhci_dev_clear_flag(hdev, HCI_LE_ADV);\r\nif (hci_update_random_address(req, false, conn_use_rpa(conn),\r\n&own_addr_type) < 0)\r\nreturn;\r\nmemset(&cp, 0, sizeof(cp));\r\ncp.type = LE_ADV_DIRECT_IND;\r\ncp.own_address_type = own_addr_type;\r\ncp.direct_addr_type = conn->dst_type;\r\nbacpy(&cp.direct_addr, &conn->dst);\r\ncp.channel_map = hdev->le_adv_channel_map;\r\nhci_req_add(req, HCI_OP_LE_SET_ADV_PARAM, sizeof(cp), &cp);\r\nenable = 0x01;\r\nhci_req_add(req, HCI_OP_LE_SET_ADV_ENABLE, sizeof(enable), &enable);\r\nconn->state = BT_CONNECT;\r\n}\r\nstruct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,\r\nu8 dst_type, u8 sec_level, u16 conn_timeout,\r\nu8 role)\r\n{\r\nstruct hci_conn_params *params;\r\nstruct hci_conn *conn;\r\nstruct smp_irk *irk;\r\nstruct hci_request req;\r\nint err;\r\nif (!hci_dev_test_flag(hdev, HCI_LE_ENABLED)) {\r\nif (lmp_le_capable(hdev))\r\nreturn ERR_PTR(-ECONNREFUSED);\r\nreturn ERR_PTR(-EOPNOTSUPP);\r\n}\r\nif (hci_lookup_le_connect(hdev))\r\nreturn ERR_PTR(-EBUSY);\r\nconn = hci_conn_hash_lookup_le(hdev, dst, dst_type);\r\nif (conn && !test_bit(HCI_CONN_SCANNING, &conn->flags)) {\r\nreturn ERR_PTR(-EBUSY);\r\n}\r\nirk = hci_find_irk_by_addr(hdev, dst, dst_type);\r\nif (irk && bacmp(&irk->rpa, BDADDR_ANY)) {\r\ndst = &irk->rpa;\r\ndst_type = ADDR_LE_DEV_RANDOM;\r\n}\r\nif (conn) {\r\nbacpy(&conn->dst, dst);\r\n} else {\r\nconn = hci_conn_add(hdev, LE_LINK, dst, role);\r\nif (!conn)\r\nreturn ERR_PTR(-ENOMEM);\r\nhci_conn_hold(conn);\r\nconn->pending_sec_level = sec_level;\r\n}\r\nconn->dst_type = dst_type;\r\nconn->sec_level = BT_SECURITY_LOW;\r\nconn->conn_timeout = conn_timeout;\r\nhci_req_init(&req, hdev);\r\nif (hci_dev_test_flag(hdev, HCI_LE_ADV)) {\r\nu8 enable = 0x00;\r\nhci_req_add(&req, HCI_OP_LE_SET_ADV_ENABLE, sizeof(enable),\r\n&enable);\r\n}\r\nif (conn->role == HCI_ROLE_SLAVE) {\r\nif (hci_dev_test_flag(hdev, HCI_LE_SCAN) &&\r\nhdev->le_scan_type == LE_SCAN_ACTIVE) {\r\nskb_queue_purge(&req.cmd_q);\r\nhci_conn_del(conn);\r\nreturn ERR_PTR(-EBUSY);\r\n}\r\nhci_req_directed_advertising(&req, conn);\r\ngoto create_conn;\r\n}\r\nparams = hci_conn_params_lookup(hdev, &conn->dst, conn->dst_type);\r\nif (params) {\r\nconn->le_conn_min_interval = params->conn_min_interval;\r\nconn->le_conn_max_interval = params->conn_max_interval;\r\nconn->le_conn_latency = params->conn_latency;\r\nconn->le_supv_timeout = params->supervision_timeout;\r\n} else {\r\nconn->le_conn_min_interval = hdev->le_conn_min_interval;\r\nconn->le_conn_max_interval = hdev->le_conn_max_interval;\r\nconn->le_conn_latency = hdev->le_conn_latency;\r\nconn->le_supv_timeout = hdev->le_supv_timeout;\r\n}\r\nif (hci_dev_test_flag(hdev, HCI_LE_SCAN)) {\r\nhci_req_add_le_scan_disable(&req);\r\nhci_dev_set_flag(hdev, HCI_LE_SCAN_INTERRUPTED);\r\n}\r\nhci_req_add_le_create_conn(&req, conn);\r\ncreate_conn:\r\nerr = hci_req_run(&req, create_le_conn_complete);\r\nif (err) {\r\nhci_conn_del(conn);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn conn;\r\n}\r\nstatic bool is_connected(struct hci_dev *hdev, bdaddr_t *addr, u8 type)\r\n{\r\nstruct hci_conn *conn;\r\nconn = hci_conn_hash_lookup_le(hdev, addr, type);\r\nif (!conn)\r\nreturn false;\r\nif (conn->state != BT_CONNECTED)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int hci_explicit_conn_params_set(struct hci_dev *hdev,\r\nbdaddr_t *addr, u8 addr_type)\r\n{\r\nstruct hci_conn_params *params;\r\nif (is_connected(hdev, addr, addr_type))\r\nreturn -EISCONN;\r\nparams = hci_conn_params_lookup(hdev, addr, addr_type);\r\nif (!params) {\r\nparams = hci_conn_params_add(hdev, addr, addr_type);\r\nif (!params)\r\nreturn -ENOMEM;\r\nparams->auto_connect = HCI_AUTO_CONN_EXPLICIT;\r\n}\r\nif (params->auto_connect == HCI_AUTO_CONN_DISABLED ||\r\nparams->auto_connect == HCI_AUTO_CONN_REPORT ||\r\nparams->auto_connect == HCI_AUTO_CONN_EXPLICIT) {\r\nlist_del_init(&params->action);\r\nlist_add(&params->action, &hdev->pend_le_conns);\r\n}\r\nparams->explicit_connect = true;\r\nBT_DBG("addr %pMR (type %u) auto_connect %u", addr, addr_type,\r\nparams->auto_connect);\r\nreturn 0;\r\n}\r\nstruct hci_conn *hci_connect_le_scan(struct hci_dev *hdev, bdaddr_t *dst,\r\nu8 dst_type, u8 sec_level,\r\nu16 conn_timeout)\r\n{\r\nstruct hci_conn *conn;\r\nif (!hci_dev_test_flag(hdev, HCI_LE_ENABLED)) {\r\nif (lmp_le_capable(hdev))\r\nreturn ERR_PTR(-ECONNREFUSED);\r\nreturn ERR_PTR(-EOPNOTSUPP);\r\n}\r\nconn = hci_conn_hash_lookup_le(hdev, dst, dst_type);\r\nif (conn) {\r\nif (conn->pending_sec_level < sec_level)\r\nconn->pending_sec_level = sec_level;\r\ngoto done;\r\n}\r\nBT_DBG("requesting refresh of dst_addr");\r\nconn = hci_conn_add(hdev, LE_LINK, dst, HCI_ROLE_MASTER);\r\nif (!conn)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (hci_explicit_conn_params_set(hdev, dst, dst_type) < 0)\r\nreturn ERR_PTR(-EBUSY);\r\nconn->state = BT_CONNECT;\r\nset_bit(HCI_CONN_SCANNING, &conn->flags);\r\nconn->dst_type = dst_type;\r\nconn->sec_level = BT_SECURITY_LOW;\r\nconn->pending_sec_level = sec_level;\r\nconn->conn_timeout = conn_timeout;\r\nhci_update_background_scan(hdev);\r\ndone:\r\nhci_conn_hold(conn);\r\nreturn conn;\r\n}\r\nstruct hci_conn *hci_connect_acl(struct hci_dev *hdev, bdaddr_t *dst,\r\nu8 sec_level, u8 auth_type)\r\n{\r\nstruct hci_conn *acl;\r\nif (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED)) {\r\nif (lmp_bredr_capable(hdev))\r\nreturn ERR_PTR(-ECONNREFUSED);\r\nreturn ERR_PTR(-EOPNOTSUPP);\r\n}\r\nacl = hci_conn_hash_lookup_ba(hdev, ACL_LINK, dst);\r\nif (!acl) {\r\nacl = hci_conn_add(hdev, ACL_LINK, dst, HCI_ROLE_MASTER);\r\nif (!acl)\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nhci_conn_hold(acl);\r\nif (acl->state == BT_OPEN || acl->state == BT_CLOSED) {\r\nacl->sec_level = BT_SECURITY_LOW;\r\nacl->pending_sec_level = sec_level;\r\nacl->auth_type = auth_type;\r\nhci_acl_create_connection(acl);\r\n}\r\nreturn acl;\r\n}\r\nstruct hci_conn *hci_connect_sco(struct hci_dev *hdev, int type, bdaddr_t *dst,\r\n__u16 setting)\r\n{\r\nstruct hci_conn *acl;\r\nstruct hci_conn *sco;\r\nacl = hci_connect_acl(hdev, dst, BT_SECURITY_LOW, HCI_AT_NO_BONDING);\r\nif (IS_ERR(acl))\r\nreturn acl;\r\nsco = hci_conn_hash_lookup_ba(hdev, type, dst);\r\nif (!sco) {\r\nsco = hci_conn_add(hdev, type, dst, HCI_ROLE_MASTER);\r\nif (!sco) {\r\nhci_conn_drop(acl);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\n}\r\nacl->link = sco;\r\nsco->link = acl;\r\nhci_conn_hold(sco);\r\nsco->setting = setting;\r\nif (acl->state == BT_CONNECTED &&\r\n(sco->state == BT_OPEN || sco->state == BT_CLOSED)) {\r\nset_bit(HCI_CONN_POWER_SAVE, &acl->flags);\r\nhci_conn_enter_active_mode(acl, BT_POWER_FORCE_ACTIVE_ON);\r\nif (test_bit(HCI_CONN_MODE_CHANGE_PEND, &acl->flags)) {\r\nset_bit(HCI_CONN_SCO_SETUP_PEND, &acl->flags);\r\nreturn sco;\r\n}\r\nhci_sco_setup(acl, 0x00);\r\n}\r\nreturn sco;\r\n}\r\nint hci_conn_check_link_mode(struct hci_conn *conn)\r\n{\r\nBT_DBG("hcon %p", conn);\r\nif (hci_dev_test_flag(conn->hdev, HCI_SC_ONLY)) {\r\nif (!hci_conn_sc_enabled(conn) ||\r\n!test_bit(HCI_CONN_AES_CCM, &conn->flags) ||\r\nconn->key_type != HCI_LK_AUTH_COMBINATION_P256)\r\nreturn 0;\r\n}\r\nif (hci_conn_ssp_enabled(conn) &&\r\n!test_bit(HCI_CONN_ENCRYPT, &conn->flags))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int hci_conn_auth(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)\r\n{\r\nBT_DBG("hcon %p", conn);\r\nif (conn->pending_sec_level > sec_level)\r\nsec_level = conn->pending_sec_level;\r\nif (sec_level > conn->sec_level)\r\nconn->pending_sec_level = sec_level;\r\nelse if (test_bit(HCI_CONN_AUTH, &conn->flags))\r\nreturn 1;\r\nauth_type |= (conn->auth_type & 0x01);\r\nconn->auth_type = auth_type;\r\nif (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->flags)) {\r\nstruct hci_cp_auth_requested cp;\r\ncp.handle = cpu_to_le16(conn->handle);\r\nhci_send_cmd(conn->hdev, HCI_OP_AUTH_REQUESTED,\r\nsizeof(cp), &cp);\r\nif (test_bit(HCI_CONN_ENCRYPT, &conn->flags))\r\nset_bit(HCI_CONN_REAUTH_PEND, &conn->flags);\r\nelse\r\nset_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic void hci_conn_encrypt(struct hci_conn *conn)\r\n{\r\nBT_DBG("hcon %p", conn);\r\nif (!test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags)) {\r\nstruct hci_cp_set_conn_encrypt cp;\r\ncp.handle = cpu_to_le16(conn->handle);\r\ncp.encrypt = 0x01;\r\nhci_send_cmd(conn->hdev, HCI_OP_SET_CONN_ENCRYPT, sizeof(cp),\r\n&cp);\r\n}\r\n}\r\nint hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type,\r\nbool initiator)\r\n{\r\nBT_DBG("hcon %p", conn);\r\nif (conn->type == LE_LINK)\r\nreturn smp_conn_security(conn, sec_level);\r\nif (sec_level == BT_SECURITY_SDP)\r\nreturn 1;\r\nif (sec_level == BT_SECURITY_LOW && !hci_conn_ssp_enabled(conn))\r\nreturn 1;\r\nif (!test_bit(HCI_CONN_AUTH, &conn->flags))\r\ngoto auth;\r\nif (conn->key_type == HCI_LK_AUTH_COMBINATION_P256 &&\r\nsec_level == BT_SECURITY_FIPS)\r\ngoto encrypt;\r\nif ((conn->key_type == HCI_LK_AUTH_COMBINATION_P192 ||\r\nconn->key_type == HCI_LK_AUTH_COMBINATION_P256) &&\r\nsec_level == BT_SECURITY_HIGH)\r\ngoto encrypt;\r\nif ((conn->key_type == HCI_LK_UNAUTH_COMBINATION_P192 ||\r\nconn->key_type == HCI_LK_UNAUTH_COMBINATION_P256) &&\r\n(sec_level == BT_SECURITY_MEDIUM || sec_level == BT_SECURITY_LOW))\r\ngoto encrypt;\r\nif (conn->key_type == HCI_LK_COMBINATION &&\r\n(sec_level == BT_SECURITY_MEDIUM || sec_level == BT_SECURITY_LOW ||\r\nconn->pin_length == 16))\r\ngoto encrypt;\r\nauth:\r\nif (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags))\r\nreturn 0;\r\nif (initiator)\r\nset_bit(HCI_CONN_AUTH_INITIATOR, &conn->flags);\r\nif (!hci_conn_auth(conn, sec_level, auth_type))\r\nreturn 0;\r\nencrypt:\r\nif (test_bit(HCI_CONN_ENCRYPT, &conn->flags))\r\nreturn 1;\r\nhci_conn_encrypt(conn);\r\nreturn 0;\r\n}\r\nint hci_conn_check_secure(struct hci_conn *conn, __u8 sec_level)\r\n{\r\nBT_DBG("hcon %p", conn);\r\nif (sec_level != BT_SECURITY_HIGH && sec_level != BT_SECURITY_FIPS)\r\nreturn 1;\r\nif (conn->sec_level == BT_SECURITY_HIGH ||\r\nconn->sec_level == BT_SECURITY_FIPS)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint hci_conn_switch_role(struct hci_conn *conn, __u8 role)\r\n{\r\nBT_DBG("hcon %p", conn);\r\nif (role == conn->role)\r\nreturn 1;\r\nif (!test_and_set_bit(HCI_CONN_RSWITCH_PEND, &conn->flags)) {\r\nstruct hci_cp_switch_role cp;\r\nbacpy(&cp.bdaddr, &conn->dst);\r\ncp.role = role;\r\nhci_send_cmd(conn->hdev, HCI_OP_SWITCH_ROLE, sizeof(cp), &cp);\r\n}\r\nreturn 0;\r\n}\r\nvoid hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active)\r\n{\r\nstruct hci_dev *hdev = conn->hdev;\r\nBT_DBG("hcon %p mode %d", conn, conn->mode);\r\nif (conn->mode != HCI_CM_SNIFF)\r\ngoto timer;\r\nif (!test_bit(HCI_CONN_POWER_SAVE, &conn->flags) && !force_active)\r\ngoto timer;\r\nif (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->flags)) {\r\nstruct hci_cp_exit_sniff_mode cp;\r\ncp.handle = cpu_to_le16(conn->handle);\r\nhci_send_cmd(hdev, HCI_OP_EXIT_SNIFF_MODE, sizeof(cp), &cp);\r\n}\r\ntimer:\r\nif (hdev->idle_timeout > 0)\r\nqueue_delayed_work(hdev->workqueue, &conn->idle_work,\r\nmsecs_to_jiffies(hdev->idle_timeout));\r\n}\r\nvoid hci_conn_hash_flush(struct hci_dev *hdev)\r\n{\r\nstruct hci_conn_hash *h = &hdev->conn_hash;\r\nstruct hci_conn *c, *n;\r\nBT_DBG("hdev %s", hdev->name);\r\nlist_for_each_entry_safe(c, n, &h->list, list) {\r\nc->state = BT_CLOSED;\r\nhci_disconn_cfm(c, HCI_ERROR_LOCAL_HOST_TERM);\r\nhci_conn_del(c);\r\n}\r\n}\r\nvoid hci_conn_check_pending(struct hci_dev *hdev)\r\n{\r\nstruct hci_conn *conn;\r\nBT_DBG("hdev %s", hdev->name);\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_state(hdev, ACL_LINK, BT_CONNECT2);\r\nif (conn)\r\nhci_acl_create_connection(conn);\r\nhci_dev_unlock(hdev);\r\n}\r\nstatic u32 get_link_mode(struct hci_conn *conn)\r\n{\r\nu32 link_mode = 0;\r\nif (conn->role == HCI_ROLE_MASTER)\r\nlink_mode |= HCI_LM_MASTER;\r\nif (test_bit(HCI_CONN_ENCRYPT, &conn->flags))\r\nlink_mode |= HCI_LM_ENCRYPT;\r\nif (test_bit(HCI_CONN_AUTH, &conn->flags))\r\nlink_mode |= HCI_LM_AUTH;\r\nif (test_bit(HCI_CONN_SECURE, &conn->flags))\r\nlink_mode |= HCI_LM_SECURE;\r\nif (test_bit(HCI_CONN_FIPS, &conn->flags))\r\nlink_mode |= HCI_LM_FIPS;\r\nreturn link_mode;\r\n}\r\nint hci_get_conn_list(void __user *arg)\r\n{\r\nstruct hci_conn *c;\r\nstruct hci_conn_list_req req, *cl;\r\nstruct hci_conn_info *ci;\r\nstruct hci_dev *hdev;\r\nint n = 0, size, err;\r\nif (copy_from_user(&req, arg, sizeof(req)))\r\nreturn -EFAULT;\r\nif (!req.conn_num || req.conn_num > (PAGE_SIZE * 2) / sizeof(*ci))\r\nreturn -EINVAL;\r\nsize = sizeof(req) + req.conn_num * sizeof(*ci);\r\ncl = kmalloc(size, GFP_KERNEL);\r\nif (!cl)\r\nreturn -ENOMEM;\r\nhdev = hci_dev_get(req.dev_id);\r\nif (!hdev) {\r\nkfree(cl);\r\nreturn -ENODEV;\r\n}\r\nci = cl->conn_info;\r\nhci_dev_lock(hdev);\r\nlist_for_each_entry(c, &hdev->conn_hash.list, list) {\r\nbacpy(&(ci + n)->bdaddr, &c->dst);\r\n(ci + n)->handle = c->handle;\r\n(ci + n)->type = c->type;\r\n(ci + n)->out = c->out;\r\n(ci + n)->state = c->state;\r\n(ci + n)->link_mode = get_link_mode(c);\r\nif (++n >= req.conn_num)\r\nbreak;\r\n}\r\nhci_dev_unlock(hdev);\r\ncl->dev_id = hdev->id;\r\ncl->conn_num = n;\r\nsize = sizeof(req) + n * sizeof(*ci);\r\nhci_dev_put(hdev);\r\nerr = copy_to_user(arg, cl, size);\r\nkfree(cl);\r\nreturn err ? -EFAULT : 0;\r\n}\r\nint hci_get_conn_info(struct hci_dev *hdev, void __user *arg)\r\n{\r\nstruct hci_conn_info_req req;\r\nstruct hci_conn_info ci;\r\nstruct hci_conn *conn;\r\nchar __user *ptr = arg + sizeof(req);\r\nif (copy_from_user(&req, arg, sizeof(req)))\r\nreturn -EFAULT;\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_ba(hdev, req.type, &req.bdaddr);\r\nif (conn) {\r\nbacpy(&ci.bdaddr, &conn->dst);\r\nci.handle = conn->handle;\r\nci.type = conn->type;\r\nci.out = conn->out;\r\nci.state = conn->state;\r\nci.link_mode = get_link_mode(conn);\r\n}\r\nhci_dev_unlock(hdev);\r\nif (!conn)\r\nreturn -ENOENT;\r\nreturn copy_to_user(ptr, &ci, sizeof(ci)) ? -EFAULT : 0;\r\n}\r\nint hci_get_auth_info(struct hci_dev *hdev, void __user *arg)\r\n{\r\nstruct hci_auth_info_req req;\r\nstruct hci_conn *conn;\r\nif (copy_from_user(&req, arg, sizeof(req)))\r\nreturn -EFAULT;\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &req.bdaddr);\r\nif (conn)\r\nreq.type = conn->auth_type;\r\nhci_dev_unlock(hdev);\r\nif (!conn)\r\nreturn -ENOENT;\r\nreturn copy_to_user(arg, &req, sizeof(req)) ? -EFAULT : 0;\r\n}\r\nstruct hci_chan *hci_chan_create(struct hci_conn *conn)\r\n{\r\nstruct hci_dev *hdev = conn->hdev;\r\nstruct hci_chan *chan;\r\nBT_DBG("%s hcon %p", hdev->name, conn);\r\nif (test_bit(HCI_CONN_DROP, &conn->flags)) {\r\nBT_DBG("Refusing to create new hci_chan");\r\nreturn NULL;\r\n}\r\nchan = kzalloc(sizeof(*chan), GFP_KERNEL);\r\nif (!chan)\r\nreturn NULL;\r\nchan->conn = hci_conn_get(conn);\r\nskb_queue_head_init(&chan->data_q);\r\nchan->state = BT_CONNECTED;\r\nlist_add_rcu(&chan->list, &conn->chan_list);\r\nreturn chan;\r\n}\r\nvoid hci_chan_del(struct hci_chan *chan)\r\n{\r\nstruct hci_conn *conn = chan->conn;\r\nstruct hci_dev *hdev = conn->hdev;\r\nBT_DBG("%s hcon %p chan %p", hdev->name, conn, chan);\r\nlist_del_rcu(&chan->list);\r\nsynchronize_rcu();\r\nset_bit(HCI_CONN_DROP, &conn->flags);\r\nhci_conn_put(conn);\r\nskb_queue_purge(&chan->data_q);\r\nkfree(chan);\r\n}\r\nvoid hci_chan_list_flush(struct hci_conn *conn)\r\n{\r\nstruct hci_chan *chan, *n;\r\nBT_DBG("hcon %p", conn);\r\nlist_for_each_entry_safe(chan, n, &conn->chan_list, list)\r\nhci_chan_del(chan);\r\n}\r\nstatic struct hci_chan *__hci_chan_lookup_handle(struct hci_conn *hcon,\r\n__u16 handle)\r\n{\r\nstruct hci_chan *hchan;\r\nlist_for_each_entry(hchan, &hcon->chan_list, list) {\r\nif (hchan->handle == handle)\r\nreturn hchan;\r\n}\r\nreturn NULL;\r\n}\r\nstruct hci_chan *hci_chan_lookup_handle(struct hci_dev *hdev, __u16 handle)\r\n{\r\nstruct hci_conn_hash *h = &hdev->conn_hash;\r\nstruct hci_conn *hcon;\r\nstruct hci_chan *hchan = NULL;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hcon, &h->list, list) {\r\nhchan = __hci_chan_lookup_handle(hcon, handle);\r\nif (hchan)\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn hchan;\r\n}
