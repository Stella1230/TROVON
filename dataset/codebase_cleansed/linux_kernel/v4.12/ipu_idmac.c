static u32 __idmac_read_icreg(struct ipu *ipu, unsigned long reg)\r\n{\r\nreturn __raw_readl(ipu->reg_ic + reg);\r\n}\r\nstatic void __idmac_write_icreg(struct ipu *ipu, u32 value, unsigned long reg)\r\n{\r\n__raw_writel(value, ipu->reg_ic + reg);\r\n}\r\nstatic u32 idmac_read_ipureg(struct ipu *ipu, unsigned long reg)\r\n{\r\nreturn __raw_readl(ipu->reg_ipu + reg);\r\n}\r\nstatic void idmac_write_ipureg(struct ipu *ipu, u32 value, unsigned long reg)\r\n{\r\n__raw_writel(value, ipu->reg_ipu + reg);\r\n}\r\nstatic void dump_idmac_reg(struct ipu *ipu)\r\n{\r\ndev_dbg(ipu->dev, "IDMAC_CONF 0x%x, IC_CONF 0x%x, IDMAC_CHA_EN 0x%x, "\r\n"IDMAC_CHA_PRI 0x%x, IDMAC_CHA_BUSY 0x%x\n",\r\nidmac_read_icreg(ipu, IDMAC_CONF),\r\nidmac_read_icreg(ipu, IC_CONF),\r\nidmac_read_icreg(ipu, IDMAC_CHA_EN),\r\nidmac_read_icreg(ipu, IDMAC_CHA_PRI),\r\nidmac_read_icreg(ipu, IDMAC_CHA_BUSY));\r\ndev_dbg(ipu->dev, "BUF0_RDY 0x%x, BUF1_RDY 0x%x, CUR_BUF 0x%x, "\r\n"DB_MODE 0x%x, TASKS_STAT 0x%x\n",\r\nidmac_read_ipureg(ipu, IPU_CHA_BUF0_RDY),\r\nidmac_read_ipureg(ipu, IPU_CHA_BUF1_RDY),\r\nidmac_read_ipureg(ipu, IPU_CHA_CUR_BUF),\r\nidmac_read_ipureg(ipu, IPU_CHA_DB_MODE_SEL),\r\nidmac_read_ipureg(ipu, IPU_TASKS_STAT));\r\n}\r\nstatic uint32_t bytes_per_pixel(enum pixel_fmt fmt)\r\n{\r\nswitch (fmt) {\r\ncase IPU_PIX_FMT_GENERIC:\r\ncase IPU_PIX_FMT_RGB332:\r\ncase IPU_PIX_FMT_YUV420P:\r\ncase IPU_PIX_FMT_YUV422P:\r\ndefault:\r\nreturn 1;\r\ncase IPU_PIX_FMT_RGB565:\r\ncase IPU_PIX_FMT_YUYV:\r\ncase IPU_PIX_FMT_UYVY:\r\nreturn 2;\r\ncase IPU_PIX_FMT_BGR24:\r\ncase IPU_PIX_FMT_RGB24:\r\nreturn 3;\r\ncase IPU_PIX_FMT_GENERIC_32:\r\ncase IPU_PIX_FMT_BGR32:\r\ncase IPU_PIX_FMT_RGB32:\r\ncase IPU_PIX_FMT_ABGR32:\r\nreturn 4;\r\n}\r\n}\r\nstatic void ipu_ic_enable_task(struct ipu *ipu, enum ipu_channel channel)\r\n{\r\nuint32_t ic_conf, mask;\r\nswitch (channel) {\r\ncase IDMAC_IC_0:\r\nmask = IC_CONF_PRPENC_EN;\r\nbreak;\r\ncase IDMAC_IC_7:\r\nmask = IC_CONF_RWS_EN | IC_CONF_PRPENC_EN;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nic_conf = idmac_read_icreg(ipu, IC_CONF) | mask;\r\nidmac_write_icreg(ipu, ic_conf, IC_CONF);\r\n}\r\nstatic void ipu_ic_disable_task(struct ipu *ipu, enum ipu_channel channel)\r\n{\r\nuint32_t ic_conf, mask;\r\nswitch (channel) {\r\ncase IDMAC_IC_0:\r\nmask = IC_CONF_PRPENC_EN;\r\nbreak;\r\ncase IDMAC_IC_7:\r\nmask = IC_CONF_RWS_EN | IC_CONF_PRPENC_EN;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nic_conf = idmac_read_icreg(ipu, IC_CONF) & ~mask;\r\nidmac_write_icreg(ipu, ic_conf, IC_CONF);\r\n}\r\nstatic uint32_t ipu_channel_status(struct ipu *ipu, enum ipu_channel channel)\r\n{\r\nuint32_t stat = TASK_STAT_IDLE;\r\nuint32_t task_stat_reg = idmac_read_ipureg(ipu, IPU_TASKS_STAT);\r\nswitch (channel) {\r\ncase IDMAC_IC_7:\r\nstat = (task_stat_reg & TSTAT_CSI2MEM_MASK) >>\r\nTSTAT_CSI2MEM_OFFSET;\r\nbreak;\r\ncase IDMAC_IC_0:\r\ncase IDMAC_SDC_0:\r\ncase IDMAC_SDC_1:\r\ndefault:\r\nbreak;\r\n}\r\nreturn stat;\r\n}\r\nstatic void ipu_ch_param_set_plane_offset(union chan_param_mem *params,\r\nu32 u_offset, u32 v_offset)\r\n{\r\nparams->pp.ubo_l = u_offset & 0x7ff;\r\nparams->pp.ubo_h = u_offset >> 11;\r\nparams->pp.vbo_l = v_offset & 0x1ffff;\r\nparams->pp.vbo_h = v_offset >> 17;\r\n}\r\nstatic void ipu_ch_param_set_size(union chan_param_mem *params,\r\nuint32_t pixel_fmt, uint16_t width,\r\nuint16_t height, uint16_t stride)\r\n{\r\nu32 u_offset;\r\nu32 v_offset;\r\nparams->pp.fw = width - 1;\r\nparams->pp.fh_l = height - 1;\r\nparams->pp.fh_h = (height - 1) >> 8;\r\nparams->pp.sl = stride - 1;\r\nswitch (pixel_fmt) {\r\ncase IPU_PIX_FMT_GENERIC:\r\nparams->pp.bpp = 3;\r\nparams->pp.pfs = 7;\r\nparams->pp.npb = 31;\r\nparams->pp.sat = 2;\r\nbreak;\r\ncase IPU_PIX_FMT_GENERIC_32:\r\nparams->pp.bpp = 0;\r\nparams->pp.pfs = 7;\r\nparams->pp.npb = 7;\r\nparams->pp.sat = 2;\r\nbreak;\r\ncase IPU_PIX_FMT_RGB565:\r\nparams->ip.bpp = 2;\r\nparams->ip.pfs = 4;\r\nparams->ip.npb = 15;\r\nparams->ip.sat = 2;\r\nparams->ip.ofs0 = 0;\r\nparams->ip.ofs1 = 5;\r\nparams->ip.ofs2 = 11;\r\nparams->ip.ofs3 = 16;\r\nparams->ip.wid0 = 4;\r\nparams->ip.wid1 = 5;\r\nparams->ip.wid2 = 4;\r\nbreak;\r\ncase IPU_PIX_FMT_BGR24:\r\nparams->ip.bpp = 1;\r\nparams->ip.pfs = 4;\r\nparams->ip.npb = 7;\r\nparams->ip.sat = 2;\r\nparams->ip.ofs0 = 0;\r\nparams->ip.ofs1 = 8;\r\nparams->ip.ofs2 = 16;\r\nparams->ip.ofs3 = 24;\r\nparams->ip.wid0 = 7;\r\nparams->ip.wid1 = 7;\r\nparams->ip.wid2 = 7;\r\nbreak;\r\ncase IPU_PIX_FMT_RGB24:\r\nparams->ip.bpp = 1;\r\nparams->ip.pfs = 4;\r\nparams->ip.npb = 7;\r\nparams->ip.sat = 2;\r\nparams->ip.ofs0 = 16;\r\nparams->ip.ofs1 = 8;\r\nparams->ip.ofs2 = 0;\r\nparams->ip.ofs3 = 24;\r\nparams->ip.wid0 = 7;\r\nparams->ip.wid1 = 7;\r\nparams->ip.wid2 = 7;\r\nbreak;\r\ncase IPU_PIX_FMT_BGRA32:\r\ncase IPU_PIX_FMT_BGR32:\r\ncase IPU_PIX_FMT_ABGR32:\r\nparams->ip.bpp = 0;\r\nparams->ip.pfs = 4;\r\nparams->ip.npb = 7;\r\nparams->ip.sat = 2;\r\nparams->ip.ofs0 = 8;\r\nparams->ip.ofs1 = 16;\r\nparams->ip.ofs2 = 24;\r\nparams->ip.ofs3 = 0;\r\nparams->ip.wid0 = 7;\r\nparams->ip.wid1 = 7;\r\nparams->ip.wid2 = 7;\r\nparams->ip.wid3 = 7;\r\nbreak;\r\ncase IPU_PIX_FMT_RGBA32:\r\ncase IPU_PIX_FMT_RGB32:\r\nparams->ip.bpp = 0;\r\nparams->ip.pfs = 4;\r\nparams->ip.npb = 7;\r\nparams->ip.sat = 2;\r\nparams->ip.ofs0 = 24;\r\nparams->ip.ofs1 = 16;\r\nparams->ip.ofs2 = 8;\r\nparams->ip.ofs3 = 0;\r\nparams->ip.wid0 = 7;\r\nparams->ip.wid1 = 7;\r\nparams->ip.wid2 = 7;\r\nparams->ip.wid3 = 7;\r\nbreak;\r\ncase IPU_PIX_FMT_UYVY:\r\nparams->ip.bpp = 2;\r\nparams->ip.pfs = 6;\r\nparams->ip.npb = 7;\r\nparams->ip.sat = 2;\r\nbreak;\r\ncase IPU_PIX_FMT_YUV420P2:\r\ncase IPU_PIX_FMT_YUV420P:\r\nparams->ip.bpp = 3;\r\nparams->ip.pfs = 3;\r\nparams->ip.npb = 7;\r\nparams->ip.sat = 2;\r\nu_offset = stride * height;\r\nv_offset = u_offset + u_offset / 4;\r\nipu_ch_param_set_plane_offset(params, u_offset, v_offset);\r\nbreak;\r\ncase IPU_PIX_FMT_YVU422P:\r\nparams->ip.bpp = 3;\r\nparams->ip.pfs = 2;\r\nparams->ip.npb = 7;\r\nparams->ip.sat = 2;\r\nv_offset = stride * height;\r\nu_offset = v_offset + v_offset / 2;\r\nipu_ch_param_set_plane_offset(params, u_offset, v_offset);\r\nbreak;\r\ncase IPU_PIX_FMT_YUV422P:\r\nparams->ip.bpp = 3;\r\nparams->ip.pfs = 2;\r\nparams->ip.npb = 7;\r\nparams->ip.sat = 2;\r\nu_offset = stride * height;\r\nv_offset = u_offset + u_offset / 2;\r\nipu_ch_param_set_plane_offset(params, u_offset, v_offset);\r\nbreak;\r\ndefault:\r\ndev_err(ipu_data.dev,\r\n"mx3 ipu: unimplemented pixel format %d\n", pixel_fmt);\r\nbreak;\r\n}\r\nparams->pp.nsb = 1;\r\n}\r\nstatic void ipu_ch_param_set_buffer(union chan_param_mem *params,\r\ndma_addr_t buf0, dma_addr_t buf1)\r\n{\r\nparams->pp.eba0 = buf0;\r\nparams->pp.eba1 = buf1;\r\n}\r\nstatic void ipu_ch_param_set_rotation(union chan_param_mem *params,\r\nenum ipu_rotate_mode rotate)\r\n{\r\nparams->pp.bam = rotate;\r\n}\r\nstatic void ipu_write_param_mem(uint32_t addr, uint32_t *data,\r\nuint32_t num_words)\r\n{\r\nfor (; num_words > 0; num_words--) {\r\ndev_dbg(ipu_data.dev,\r\n"write param mem - addr = 0x%08X, data = 0x%08X\n",\r\naddr, *data);\r\nidmac_write_ipureg(&ipu_data, addr, IPU_IMA_ADDR);\r\nidmac_write_ipureg(&ipu_data, *data++, IPU_IMA_DATA);\r\naddr++;\r\nif ((addr & 0x7) == 5) {\r\naddr &= ~0x7;\r\naddr += 8;\r\n}\r\n}\r\n}\r\nstatic int calc_resize_coeffs(uint32_t in_size, uint32_t out_size,\r\nuint32_t *resize_coeff,\r\nuint32_t *downsize_coeff)\r\n{\r\nuint32_t temp_size;\r\nuint32_t temp_downsize;\r\n*resize_coeff = 1 << 13;\r\n*downsize_coeff = 1 << 13;\r\nif (out_size << 3 < in_size)\r\nreturn -EINVAL;\r\ntemp_downsize = 0;\r\ntemp_size = in_size;\r\nwhile (temp_size >= out_size * 2 && temp_downsize < 2) {\r\ntemp_size >>= 1;\r\ntemp_downsize++;\r\n}\r\n*downsize_coeff = temp_downsize;\r\n*resize_coeff = (8192L * (temp_size - 1)) / (out_size - 1);\r\nif (*resize_coeff >= 16384L) {\r\ndev_err(ipu_data.dev, "Warning! Overflow on resize coeff.\n");\r\n*resize_coeff = 0x3FFF;\r\n}\r\ndev_dbg(ipu_data.dev, "resizing from %u -> %u pixels, "\r\n"downsize=%u, resize=%u.%lu (reg=%u)\n", in_size, out_size,\r\n*downsize_coeff, *resize_coeff >= 8192L ? 1 : 0,\r\n((*resize_coeff & 0x1FFF) * 10000L) / 8192L, *resize_coeff);\r\nreturn 0;\r\n}\r\nstatic enum ipu_color_space format_to_colorspace(enum pixel_fmt fmt)\r\n{\r\nswitch (fmt) {\r\ncase IPU_PIX_FMT_RGB565:\r\ncase IPU_PIX_FMT_BGR24:\r\ncase IPU_PIX_FMT_RGB24:\r\ncase IPU_PIX_FMT_BGR32:\r\ncase IPU_PIX_FMT_RGB32:\r\nreturn IPU_COLORSPACE_RGB;\r\ndefault:\r\nreturn IPU_COLORSPACE_YCBCR;\r\n}\r\n}\r\nstatic int ipu_ic_init_prpenc(struct ipu *ipu,\r\nunion ipu_channel_param *params, bool src_is_csi)\r\n{\r\nuint32_t reg, ic_conf;\r\nuint32_t downsize_coeff, resize_coeff;\r\nenum ipu_color_space in_fmt, out_fmt;\r\ncalc_resize_coeffs(params->video.in_height,\r\nparams->video.out_height,\r\n&resize_coeff, &downsize_coeff);\r\nreg = (downsize_coeff << 30) | (resize_coeff << 16);\r\ncalc_resize_coeffs(params->video.in_width,\r\nparams->video.out_width,\r\n&resize_coeff, &downsize_coeff);\r\nreg |= (downsize_coeff << 14) | resize_coeff;\r\nin_fmt = format_to_colorspace(params->video.in_pixel_fmt);\r\nout_fmt = format_to_colorspace(params->video.out_pixel_fmt);\r\nif (in_fmt != out_fmt) {\r\ndev_err(ipu->dev, "Colourspace conversion unsupported!\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nidmac_write_icreg(ipu, reg, IC_PRP_ENC_RSC);\r\nic_conf = idmac_read_icreg(ipu, IC_CONF);\r\nif (src_is_csi)\r\nic_conf &= ~IC_CONF_RWS_EN;\r\nelse\r\nic_conf |= IC_CONF_RWS_EN;\r\nidmac_write_icreg(ipu, ic_conf, IC_CONF);\r\nreturn 0;\r\n}\r\nstatic uint32_t dma_param_addr(uint32_t dma_ch)\r\n{\r\nreturn 0x10000 | (dma_ch << 4);\r\n}\r\nstatic void ipu_channel_set_priority(struct ipu *ipu, enum ipu_channel channel,\r\nbool prio)\r\n{\r\nu32 reg = idmac_read_icreg(ipu, IDMAC_CHA_PRI);\r\nif (prio)\r\nreg |= 1UL << channel;\r\nelse\r\nreg &= ~(1UL << channel);\r\nidmac_write_icreg(ipu, reg, IDMAC_CHA_PRI);\r\ndump_idmac_reg(ipu);\r\n}\r\nstatic uint32_t ipu_channel_conf_mask(enum ipu_channel channel)\r\n{\r\nuint32_t mask;\r\nswitch (channel) {\r\ncase IDMAC_IC_0:\r\ncase IDMAC_IC_7:\r\nmask = IPU_CONF_CSI_EN | IPU_CONF_IC_EN;\r\nbreak;\r\ncase IDMAC_SDC_0:\r\ncase IDMAC_SDC_1:\r\nmask = IPU_CONF_SDC_EN | IPU_CONF_DI_EN;\r\nbreak;\r\ndefault:\r\nmask = 0;\r\nbreak;\r\n}\r\nreturn mask;\r\n}\r\nstatic int ipu_enable_channel(struct idmac *idmac, struct idmac_channel *ichan)\r\n{\r\nstruct ipu *ipu = to_ipu(idmac);\r\nenum ipu_channel channel = ichan->dma_chan.chan_id;\r\nuint32_t reg;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ipu->lock, flags);\r\nidmac_write_ipureg(ipu, 1UL << channel, IPU_CHA_CUR_BUF);\r\nichan->active_buffer = 0;\r\nichan->status = IPU_CHANNEL_ENABLED;\r\nswitch (channel) {\r\ncase IDMAC_SDC_0:\r\ncase IDMAC_SDC_1:\r\ncase IDMAC_IC_7:\r\nipu_channel_set_priority(ipu, channel, true);\r\ndefault:\r\nbreak;\r\n}\r\nreg = idmac_read_icreg(ipu, IDMAC_CHA_EN);\r\nidmac_write_icreg(ipu, reg | (1UL << channel), IDMAC_CHA_EN);\r\nipu_ic_enable_task(ipu, channel);\r\nspin_unlock_irqrestore(&ipu->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ipu_init_channel_buffer(struct idmac_channel *ichan,\r\nenum pixel_fmt pixel_fmt,\r\nuint16_t width, uint16_t height,\r\nuint32_t stride,\r\nenum ipu_rotate_mode rot_mode,\r\ndma_addr_t phyaddr_0, dma_addr_t phyaddr_1)\r\n{\r\nenum ipu_channel channel = ichan->dma_chan.chan_id;\r\nstruct idmac *idmac = to_idmac(ichan->dma_chan.device);\r\nstruct ipu *ipu = to_ipu(idmac);\r\nunion chan_param_mem params = {};\r\nunsigned long flags;\r\nuint32_t reg;\r\nuint32_t stride_bytes;\r\nstride_bytes = stride * bytes_per_pixel(pixel_fmt);\r\nif (stride_bytes % 4) {\r\ndev_err(ipu->dev,\r\n"Stride length must be 32-bit aligned, stride = %d, bytes = %d\n",\r\nstride, stride_bytes);\r\nreturn -EINVAL;\r\n}\r\nif ((channel <= IDMAC_IC_13) && (stride % 8)) {\r\ndev_err(ipu->dev, "Stride must be 8 pixel multiple\n");\r\nreturn -EINVAL;\r\n}\r\nipu_ch_param_set_size(&params, pixel_fmt, width, height, stride_bytes);\r\nipu_ch_param_set_buffer(&params, phyaddr_0, phyaddr_1);\r\nipu_ch_param_set_rotation(&params, rot_mode);\r\nspin_lock_irqsave(&ipu->lock, flags);\r\nipu_write_param_mem(dma_param_addr(channel), (uint32_t *)&params, 10);\r\nreg = idmac_read_ipureg(ipu, IPU_CHA_DB_MODE_SEL);\r\nif (phyaddr_1)\r\nreg |= 1UL << channel;\r\nelse\r\nreg &= ~(1UL << channel);\r\nidmac_write_ipureg(ipu, reg, IPU_CHA_DB_MODE_SEL);\r\nichan->status = IPU_CHANNEL_READY;\r\nspin_unlock_irqrestore(&ipu->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void ipu_select_buffer(enum ipu_channel channel, int buffer_n)\r\n{\r\nif (buffer_n == 0)\r\nidmac_write_ipureg(&ipu_data, 1UL << channel, IPU_CHA_BUF0_RDY);\r\nelse\r\nidmac_write_ipureg(&ipu_data, 1UL << channel, IPU_CHA_BUF1_RDY);\r\n}\r\nstatic void ipu_update_channel_buffer(struct idmac_channel *ichan,\r\nint buffer_n, dma_addr_t phyaddr)\r\n{\r\nenum ipu_channel channel = ichan->dma_chan.chan_id;\r\nuint32_t reg;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ipu_data.lock, flags);\r\nif (buffer_n == 0) {\r\nreg = idmac_read_ipureg(&ipu_data, IPU_CHA_BUF0_RDY);\r\nif (reg & (1UL << channel)) {\r\nipu_ic_disable_task(&ipu_data, channel);\r\nichan->status = IPU_CHANNEL_READY;\r\n}\r\nidmac_write_ipureg(&ipu_data, dma_param_addr(channel) +\r\n0x0008UL, IPU_IMA_ADDR);\r\nidmac_write_ipureg(&ipu_data, phyaddr, IPU_IMA_DATA);\r\n} else {\r\nreg = idmac_read_ipureg(&ipu_data, IPU_CHA_BUF1_RDY);\r\nif (reg & (1UL << channel)) {\r\nipu_ic_disable_task(&ipu_data, channel);\r\nichan->status = IPU_CHANNEL_READY;\r\n}\r\nreg = idmac_read_ipureg(&ipu_data, IPU_CHA_DB_MODE_SEL);\r\nif (!(reg & (1UL << channel)))\r\nidmac_write_ipureg(&ipu_data, reg | (1UL << channel),\r\nIPU_CHA_DB_MODE_SEL);\r\nidmac_write_ipureg(&ipu_data, dma_param_addr(channel) +\r\n0x0009UL, IPU_IMA_ADDR);\r\nidmac_write_ipureg(&ipu_data, phyaddr, IPU_IMA_DATA);\r\n}\r\nspin_unlock_irqrestore(&ipu_data.lock, flags);\r\n}\r\nstatic int ipu_submit_buffer(struct idmac_channel *ichan,\r\nstruct idmac_tx_desc *desc, struct scatterlist *sg, int buf_idx)\r\n{\r\nunsigned int chan_id = ichan->dma_chan.chan_id;\r\nstruct device *dev = &ichan->dma_chan.dev->device;\r\nif (async_tx_test_ack(&desc->txd))\r\nreturn -EINTR;\r\nipu_update_channel_buffer(ichan, buf_idx, sg_dma_address(sg));\r\nipu_select_buffer(chan_id, buf_idx);\r\ndev_dbg(dev, "Updated sg %p on channel 0x%x buffer %d\n",\r\nsg, chan_id, buf_idx);\r\nreturn 0;\r\n}\r\nstatic int ipu_submit_channel_buffers(struct idmac_channel *ichan,\r\nstruct idmac_tx_desc *desc)\r\n{\r\nstruct scatterlist *sg;\r\nint i, ret = 0;\r\nfor (i = 0, sg = desc->sg; i < 2 && sg; i++) {\r\nif (!ichan->sg[i]) {\r\nichan->sg[i] = sg;\r\nret = ipu_submit_buffer(ichan, desc, sg, i);\r\nif (ret < 0)\r\nreturn ret;\r\nsg = sg_next(sg);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic dma_cookie_t idmac_tx_submit(struct dma_async_tx_descriptor *tx)\r\n{\r\nstruct idmac_tx_desc *desc = to_tx_desc(tx);\r\nstruct idmac_channel *ichan = to_idmac_chan(tx->chan);\r\nstruct idmac *idmac = to_idmac(tx->chan->device);\r\nstruct ipu *ipu = to_ipu(idmac);\r\nstruct device *dev = &ichan->dma_chan.dev->device;\r\ndma_cookie_t cookie;\r\nunsigned long flags;\r\nint ret;\r\nif (!list_empty(&desc->list)) {\r\ndev_err(dev, "Descriptor %p not prepared!\n", tx);\r\nreturn -EBUSY;\r\n}\r\nmutex_lock(&ichan->chan_mutex);\r\nasync_tx_clear_ack(tx);\r\nif (ichan->status < IPU_CHANNEL_READY) {\r\nstruct idmac_video_param *video = &ichan->params.video;\r\ndma_addr_t dma_1 = sg_is_last(desc->sg) ? 0 :\r\nsg_dma_address(&desc->sg[1]);\r\nWARN_ON(ichan->sg[0] || ichan->sg[1]);\r\ncookie = ipu_init_channel_buffer(ichan,\r\nvideo->out_pixel_fmt,\r\nvideo->out_width,\r\nvideo->out_height,\r\nvideo->out_stride,\r\nIPU_ROTATE_NONE,\r\nsg_dma_address(&desc->sg[0]),\r\ndma_1);\r\nif (cookie < 0)\r\ngoto out;\r\n}\r\ndev_dbg(dev, "Submitting sg %p\n", &desc->sg[0]);\r\ncookie = dma_cookie_assign(tx);\r\nspin_lock_irqsave(&ichan->lock, flags);\r\nlist_add_tail(&desc->list, &ichan->queue);\r\nret = ipu_submit_channel_buffers(ichan, desc);\r\nspin_unlock_irqrestore(&ichan->lock, flags);\r\nif (ret < 0) {\r\ncookie = ret;\r\ngoto dequeue;\r\n}\r\nif (ichan->status < IPU_CHANNEL_ENABLED) {\r\nret = ipu_enable_channel(idmac, ichan);\r\nif (ret < 0) {\r\ncookie = ret;\r\ngoto dequeue;\r\n}\r\n}\r\ndump_idmac_reg(ipu);\r\ndequeue:\r\nif (cookie < 0) {\r\nspin_lock_irqsave(&ichan->lock, flags);\r\nlist_del_init(&desc->list);\r\nspin_unlock_irqrestore(&ichan->lock, flags);\r\ntx->cookie = cookie;\r\nichan->dma_chan.cookie = cookie;\r\n}\r\nout:\r\nmutex_unlock(&ichan->chan_mutex);\r\nreturn cookie;\r\n}\r\nstatic int idmac_desc_alloc(struct idmac_channel *ichan, int n)\r\n{\r\nstruct idmac_tx_desc *desc = vmalloc(n * sizeof(struct idmac_tx_desc));\r\nstruct idmac *idmac = to_idmac(ichan->dma_chan.device);\r\nif (!desc)\r\nreturn -ENOMEM;\r\ntasklet_disable(&to_ipu(idmac)->tasklet);\r\nichan->n_tx_desc = n;\r\nichan->desc = desc;\r\nINIT_LIST_HEAD(&ichan->queue);\r\nINIT_LIST_HEAD(&ichan->free_list);\r\nwhile (n--) {\r\nstruct dma_async_tx_descriptor *txd = &desc->txd;\r\nmemset(txd, 0, sizeof(*txd));\r\ndma_async_tx_descriptor_init(txd, &ichan->dma_chan);\r\ntxd->tx_submit = idmac_tx_submit;\r\nlist_add(&desc->list, &ichan->free_list);\r\ndesc++;\r\n}\r\ntasklet_enable(&to_ipu(idmac)->tasklet);\r\nreturn 0;\r\n}\r\nstatic int ipu_init_channel(struct idmac *idmac, struct idmac_channel *ichan)\r\n{\r\nunion ipu_channel_param *params = &ichan->params;\r\nuint32_t ipu_conf;\r\nenum ipu_channel channel = ichan->dma_chan.chan_id;\r\nunsigned long flags;\r\nuint32_t reg;\r\nstruct ipu *ipu = to_ipu(idmac);\r\nint ret = 0, n_desc = 0;\r\ndev_dbg(ipu->dev, "init channel = %d\n", channel);\r\nif (channel != IDMAC_SDC_0 && channel != IDMAC_SDC_1 &&\r\nchannel != IDMAC_IC_7)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&ipu->lock, flags);\r\nswitch (channel) {\r\ncase IDMAC_IC_7:\r\nn_desc = 16;\r\nreg = idmac_read_icreg(ipu, IC_CONF);\r\nidmac_write_icreg(ipu, reg & ~IC_CONF_CSI_MEM_WR_EN, IC_CONF);\r\nbreak;\r\ncase IDMAC_IC_0:\r\nn_desc = 16;\r\nreg = idmac_read_ipureg(ipu, IPU_FS_PROC_FLOW);\r\nidmac_write_ipureg(ipu, reg & ~FS_ENC_IN_VALID, IPU_FS_PROC_FLOW);\r\nret = ipu_ic_init_prpenc(ipu, params, true);\r\nbreak;\r\ncase IDMAC_SDC_0:\r\ncase IDMAC_SDC_1:\r\nn_desc = 4;\r\ndefault:\r\nbreak;\r\n}\r\nipu->channel_init_mask |= 1L << channel;\r\nipu_conf = idmac_read_ipureg(ipu, IPU_CONF) |\r\nipu_channel_conf_mask(channel);\r\nidmac_write_ipureg(ipu, ipu_conf, IPU_CONF);\r\nspin_unlock_irqrestore(&ipu->lock, flags);\r\nif (n_desc && !ichan->desc)\r\nret = idmac_desc_alloc(ichan, n_desc);\r\ndump_idmac_reg(ipu);\r\nreturn ret;\r\n}\r\nstatic void ipu_uninit_channel(struct idmac *idmac, struct idmac_channel *ichan)\r\n{\r\nenum ipu_channel channel = ichan->dma_chan.chan_id;\r\nunsigned long flags;\r\nuint32_t reg;\r\nunsigned long chan_mask = 1UL << channel;\r\nuint32_t ipu_conf;\r\nstruct ipu *ipu = to_ipu(idmac);\r\nspin_lock_irqsave(&ipu->lock, flags);\r\nif (!(ipu->channel_init_mask & chan_mask)) {\r\ndev_err(ipu->dev, "Channel already uninitialized %d\n",\r\nchannel);\r\nspin_unlock_irqrestore(&ipu->lock, flags);\r\nreturn;\r\n}\r\nreg = idmac_read_ipureg(ipu, IPU_CHA_DB_MODE_SEL);\r\nidmac_write_ipureg(ipu, reg & ~chan_mask, IPU_CHA_DB_MODE_SEL);\r\nichan->sec_chan_en = false;\r\nswitch (channel) {\r\ncase IDMAC_IC_7:\r\nreg = idmac_read_icreg(ipu, IC_CONF);\r\nidmac_write_icreg(ipu, reg & ~(IC_CONF_RWS_EN | IC_CONF_PRPENC_EN),\r\nIC_CONF);\r\nbreak;\r\ncase IDMAC_IC_0:\r\nreg = idmac_read_icreg(ipu, IC_CONF);\r\nidmac_write_icreg(ipu, reg & ~(IC_CONF_PRPENC_EN | IC_CONF_PRPENC_CSC1),\r\nIC_CONF);\r\nbreak;\r\ncase IDMAC_SDC_0:\r\ncase IDMAC_SDC_1:\r\ndefault:\r\nbreak;\r\n}\r\nipu->channel_init_mask &= ~(1L << channel);\r\nipu_conf = idmac_read_ipureg(ipu, IPU_CONF) &\r\n~ipu_channel_conf_mask(channel);\r\nidmac_write_ipureg(ipu, ipu_conf, IPU_CONF);\r\nspin_unlock_irqrestore(&ipu->lock, flags);\r\nichan->n_tx_desc = 0;\r\nvfree(ichan->desc);\r\nichan->desc = NULL;\r\n}\r\nstatic int ipu_disable_channel(struct idmac *idmac, struct idmac_channel *ichan,\r\nbool wait_for_stop)\r\n{\r\nenum ipu_channel channel = ichan->dma_chan.chan_id;\r\nstruct ipu *ipu = to_ipu(idmac);\r\nuint32_t reg;\r\nunsigned long flags;\r\nunsigned long chan_mask = 1UL << channel;\r\nunsigned int timeout;\r\nif (wait_for_stop && channel != IDMAC_SDC_1 && channel != IDMAC_SDC_0) {\r\ntimeout = 40;\r\nwhile ((idmac_read_icreg(ipu, IDMAC_CHA_BUSY) & chan_mask) ||\r\n(ipu_channel_status(ipu, channel) == TASK_STAT_ACTIVE)) {\r\ntimeout--;\r\nmsleep(10);\r\nif (!timeout) {\r\ndev_dbg(ipu->dev,\r\n"Warning: timeout waiting for channel %u to "\r\n"stop: buf0_rdy = 0x%08X, buf1_rdy = 0x%08X, "\r\n"busy = 0x%08X, tstat = 0x%08X\n", channel,\r\nidmac_read_ipureg(ipu, IPU_CHA_BUF0_RDY),\r\nidmac_read_ipureg(ipu, IPU_CHA_BUF1_RDY),\r\nidmac_read_icreg(ipu, IDMAC_CHA_BUSY),\r\nidmac_read_ipureg(ipu, IPU_TASKS_STAT));\r\nbreak;\r\n}\r\n}\r\ndev_dbg(ipu->dev, "timeout = %d * 10ms\n", 40 - timeout);\r\n}\r\nif (wait_for_stop && (channel == IDMAC_SDC_0 ||\r\nchannel == IDMAC_SDC_1)) {\r\nfor (timeout = 5;\r\ntimeout && !ipu_irq_status(ichan->eof_irq); timeout--)\r\nmsleep(5);\r\n}\r\nspin_lock_irqsave(&ipu->lock, flags);\r\nipu_ic_disable_task(ipu, channel);\r\nreg = idmac_read_icreg(ipu, IDMAC_CHA_EN);\r\nidmac_write_icreg(ipu, reg & ~chan_mask, IDMAC_CHA_EN);\r\nspin_unlock_irqrestore(&ipu->lock, flags);\r\nreturn 0;\r\n}\r\nstatic struct scatterlist *idmac_sg_next(struct idmac_channel *ichan,\r\nstruct idmac_tx_desc **desc, struct scatterlist *sg)\r\n{\r\nstruct scatterlist *sgnew = sg ? sg_next(sg) : NULL;\r\nif (sgnew)\r\nreturn sgnew;\r\nif ((*desc)->list.next == &ichan->queue)\r\nreturn NULL;\r\n*desc = list_entry((*desc)->list.next, struct idmac_tx_desc, list);\r\nreturn (*desc)->sg;\r\n}\r\nstatic irqreturn_t idmac_interrupt(int irq, void *dev_id)\r\n{\r\nstruct idmac_channel *ichan = dev_id;\r\nstruct device *dev = &ichan->dma_chan.dev->device;\r\nunsigned int chan_id = ichan->dma_chan.chan_id;\r\nstruct scatterlist **sg, *sgnext, *sgnew = NULL;\r\nstruct idmac_tx_desc *desc, *descnew;\r\nbool done = false;\r\nu32 ready0, ready1, curbuf, err;\r\nunsigned long flags;\r\nstruct dmaengine_desc_callback cb;\r\ndev_dbg(dev, "IDMAC irq %d, buf %d\n", irq, ichan->active_buffer);\r\nspin_lock_irqsave(&ipu_data.lock, flags);\r\nready0 = idmac_read_ipureg(&ipu_data, IPU_CHA_BUF0_RDY);\r\nready1 = idmac_read_ipureg(&ipu_data, IPU_CHA_BUF1_RDY);\r\ncurbuf = idmac_read_ipureg(&ipu_data, IPU_CHA_CUR_BUF);\r\nerr = idmac_read_ipureg(&ipu_data, IPU_INT_STAT_4);\r\nif (err & (1 << chan_id)) {\r\nidmac_write_ipureg(&ipu_data, 1 << chan_id, IPU_INT_STAT_4);\r\nspin_unlock_irqrestore(&ipu_data.lock, flags);\r\ndev_warn(dev, "NFB4EOF on channel %d, ready %x, %x, cur %x\n",\r\nchan_id, ready0, ready1, curbuf);\r\nreturn IRQ_HANDLED;\r\n}\r\nspin_unlock_irqrestore(&ipu_data.lock, flags);\r\nspin_lock(&ichan->lock);\r\nif (unlikely((ichan->active_buffer && (ready1 >> chan_id) & 1) ||\r\n(!ichan->active_buffer && (ready0 >> chan_id) & 1)\r\n)) {\r\nspin_unlock(&ichan->lock);\r\ndev_dbg(dev,\r\n"IRQ with active buffer still ready on channel %x, "\r\n"active %d, ready %x, %x!\n", chan_id,\r\nichan->active_buffer, ready0, ready1);\r\nreturn IRQ_NONE;\r\n}\r\nif (unlikely(list_empty(&ichan->queue))) {\r\nichan->sg[ichan->active_buffer] = NULL;\r\nspin_unlock(&ichan->lock);\r\ndev_err(dev,\r\n"IRQ without queued buffers on channel %x, active %d, "\r\n"ready %x, %x!\n", chan_id,\r\nichan->active_buffer, ready0, ready1);\r\nreturn IRQ_NONE;\r\n}\r\nsg = &ichan->sg[ichan->active_buffer];\r\nsgnext = ichan->sg[!ichan->active_buffer];\r\nif (!*sg) {\r\nspin_unlock(&ichan->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\ndesc = list_entry(ichan->queue.next, struct idmac_tx_desc, list);\r\ndescnew = desc;\r\ndev_dbg(dev, "IDMAC irq %d, dma %#llx, next dma %#llx, current %d, curbuf %#x\n",\r\nirq, (u64)sg_dma_address(*sg),\r\nsgnext ? (u64)sg_dma_address(sgnext) : 0,\r\nichan->active_buffer, curbuf);\r\nsgnew = idmac_sg_next(ichan, &descnew, *sg);\r\nif (sgnext != sgnew)\r\ndev_err(dev, "Submitted buffer %p, next buffer %p\n", sgnext, sgnew);\r\nif (unlikely(!sgnext)) {\r\nif (!WARN_ON(sg_next(*sg)))\r\ndev_dbg(dev, "Underrun on channel %x\n", chan_id);\r\nichan->sg[!ichan->active_buffer] = sgnew;\r\nif (unlikely(sgnew)) {\r\nipu_submit_buffer(ichan, descnew, sgnew, !ichan->active_buffer);\r\n} else {\r\nspin_lock_irqsave(&ipu_data.lock, flags);\r\nipu_ic_disable_task(&ipu_data, chan_id);\r\nspin_unlock_irqrestore(&ipu_data.lock, flags);\r\nichan->status = IPU_CHANNEL_READY;\r\n}\r\n}\r\nsgnew = idmac_sg_next(ichan, &descnew, sgnew);\r\nif (unlikely(!sg_next(*sg)) || !sgnext) {\r\nlist_del_init(&desc->list);\r\ndone = true;\r\n}\r\n*sg = sgnew;\r\nif (likely(sgnew) &&\r\nipu_submit_buffer(ichan, descnew, sgnew, ichan->active_buffer) < 0) {\r\ndmaengine_desc_get_callback(&descnew->txd, &cb);\r\nlist_del_init(&descnew->list);\r\nspin_unlock(&ichan->lock);\r\ndmaengine_desc_callback_invoke(&cb, NULL);\r\nspin_lock(&ichan->lock);\r\n}\r\nichan->active_buffer = !ichan->active_buffer;\r\nif (done)\r\ndma_cookie_complete(&desc->txd);\r\ndmaengine_desc_get_callback(&desc->txd, &cb);\r\nspin_unlock(&ichan->lock);\r\nif (done && (desc->txd.flags & DMA_PREP_INTERRUPT))\r\ndmaengine_desc_callback_invoke(&cb, NULL);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void ipu_gc_tasklet(unsigned long arg)\r\n{\r\nstruct ipu *ipu = (struct ipu *)arg;\r\nint i;\r\nfor (i = 0; i < IPU_CHANNELS_NUM; i++) {\r\nstruct idmac_channel *ichan = ipu->channel + i;\r\nstruct idmac_tx_desc *desc;\r\nunsigned long flags;\r\nstruct scatterlist *sg;\r\nint j, k;\r\nfor (j = 0; j < ichan->n_tx_desc; j++) {\r\ndesc = ichan->desc + j;\r\nspin_lock_irqsave(&ichan->lock, flags);\r\nif (async_tx_test_ack(&desc->txd)) {\r\nlist_move(&desc->list, &ichan->free_list);\r\nfor_each_sg(desc->sg, sg, desc->sg_len, k) {\r\nif (ichan->sg[0] == sg)\r\nichan->sg[0] = NULL;\r\nelse if (ichan->sg[1] == sg)\r\nichan->sg[1] = NULL;\r\n}\r\nasync_tx_clear_ack(&desc->txd);\r\n}\r\nspin_unlock_irqrestore(&ichan->lock, flags);\r\n}\r\n}\r\n}\r\nstatic struct dma_async_tx_descriptor *idmac_prep_slave_sg(struct dma_chan *chan,\r\nstruct scatterlist *sgl, unsigned int sg_len,\r\nenum dma_transfer_direction direction, unsigned long tx_flags,\r\nvoid *context)\r\n{\r\nstruct idmac_channel *ichan = to_idmac_chan(chan);\r\nstruct idmac_tx_desc *desc = NULL;\r\nstruct dma_async_tx_descriptor *txd = NULL;\r\nunsigned long flags;\r\nif (chan->chan_id != IDMAC_SDC_0 && chan->chan_id != IDMAC_SDC_1 &&\r\nchan->chan_id != IDMAC_IC_7)\r\nreturn NULL;\r\nif (!is_slave_direction(direction)) {\r\ndev_err(chan->device->dev, "Invalid DMA direction %d!\n", direction);\r\nreturn NULL;\r\n}\r\nmutex_lock(&ichan->chan_mutex);\r\nspin_lock_irqsave(&ichan->lock, flags);\r\nif (!list_empty(&ichan->free_list)) {\r\ndesc = list_entry(ichan->free_list.next,\r\nstruct idmac_tx_desc, list);\r\nlist_del_init(&desc->list);\r\ndesc->sg_len = sg_len;\r\ndesc->sg = sgl;\r\ntxd = &desc->txd;\r\ntxd->flags = tx_flags;\r\n}\r\nspin_unlock_irqrestore(&ichan->lock, flags);\r\nmutex_unlock(&ichan->chan_mutex);\r\ntasklet_schedule(&to_ipu(to_idmac(chan->device))->tasklet);\r\nreturn txd;\r\n}\r\nstatic void idmac_issue_pending(struct dma_chan *chan)\r\n{\r\nstruct idmac_channel *ichan = to_idmac_chan(chan);\r\nstruct idmac *idmac = to_idmac(chan->device);\r\nstruct ipu *ipu = to_ipu(idmac);\r\nunsigned long flags;\r\nspin_lock_irqsave(&ipu->lock, flags);\r\nipu_select_buffer(chan->chan_id, ichan->active_buffer);\r\nspin_unlock_irqrestore(&ipu->lock, flags);\r\n}\r\nstatic int idmac_pause(struct dma_chan *chan)\r\n{\r\nstruct idmac_channel *ichan = to_idmac_chan(chan);\r\nstruct idmac *idmac = to_idmac(chan->device);\r\nstruct ipu *ipu = to_ipu(idmac);\r\nstruct list_head *list, *tmp;\r\nunsigned long flags;\r\nmutex_lock(&ichan->chan_mutex);\r\nspin_lock_irqsave(&ipu->lock, flags);\r\nipu_ic_disable_task(ipu, chan->chan_id);\r\nlist_for_each_safe(list, tmp, &ichan->queue)\r\nlist_del_init(list);\r\nichan->sg[0] = NULL;\r\nichan->sg[1] = NULL;\r\nspin_unlock_irqrestore(&ipu->lock, flags);\r\nichan->status = IPU_CHANNEL_INITIALIZED;\r\nmutex_unlock(&ichan->chan_mutex);\r\nreturn 0;\r\n}\r\nstatic int __idmac_terminate_all(struct dma_chan *chan)\r\n{\r\nstruct idmac_channel *ichan = to_idmac_chan(chan);\r\nstruct idmac *idmac = to_idmac(chan->device);\r\nstruct ipu *ipu = to_ipu(idmac);\r\nunsigned long flags;\r\nint i;\r\nipu_disable_channel(idmac, ichan,\r\nichan->status >= IPU_CHANNEL_ENABLED);\r\ntasklet_disable(&ipu->tasklet);\r\nspin_lock_irqsave(&ichan->lock, flags);\r\nlist_splice_init(&ichan->queue, &ichan->free_list);\r\nif (ichan->desc)\r\nfor (i = 0; i < ichan->n_tx_desc; i++) {\r\nstruct idmac_tx_desc *desc = ichan->desc + i;\r\nif (list_empty(&desc->list))\r\nlist_add(&desc->list, &ichan->free_list);\r\nasync_tx_clear_ack(&desc->txd);\r\n}\r\nichan->sg[0] = NULL;\r\nichan->sg[1] = NULL;\r\nspin_unlock_irqrestore(&ichan->lock, flags);\r\ntasklet_enable(&ipu->tasklet);\r\nichan->status = IPU_CHANNEL_INITIALIZED;\r\nreturn 0;\r\n}\r\nstatic int idmac_terminate_all(struct dma_chan *chan)\r\n{\r\nstruct idmac_channel *ichan = to_idmac_chan(chan);\r\nint ret;\r\nmutex_lock(&ichan->chan_mutex);\r\nret = __idmac_terminate_all(chan);\r\nmutex_unlock(&ichan->chan_mutex);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t ic_sof_irq(int irq, void *dev_id)\r\n{\r\nstruct idmac_channel *ichan = dev_id;\r\nprintk(KERN_DEBUG "Got SOF IRQ %d on Channel %d\n",\r\nirq, ichan->dma_chan.chan_id);\r\ndisable_irq_nosync(irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ic_eof_irq(int irq, void *dev_id)\r\n{\r\nstruct idmac_channel *ichan = dev_id;\r\nprintk(KERN_DEBUG "Got EOF IRQ %d on Channel %d\n",\r\nirq, ichan->dma_chan.chan_id);\r\ndisable_irq_nosync(irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int idmac_alloc_chan_resources(struct dma_chan *chan)\r\n{\r\nstruct idmac_channel *ichan = to_idmac_chan(chan);\r\nstruct idmac *idmac = to_idmac(chan->device);\r\nint ret;\r\nBUG_ON(chan->client_count > 1);\r\nWARN_ON(ichan->status != IPU_CHANNEL_FREE);\r\ndma_cookie_init(chan);\r\nret = ipu_irq_map(chan->chan_id);\r\nif (ret < 0)\r\ngoto eimap;\r\nichan->eof_irq = ret;\r\nipu_disable_channel(idmac, ichan, true);\r\nret = ipu_init_channel(idmac, ichan);\r\nif (ret < 0)\r\ngoto eichan;\r\nret = request_irq(ichan->eof_irq, idmac_interrupt, 0,\r\nichan->eof_name, ichan);\r\nif (ret < 0)\r\ngoto erirq;\r\n#ifdef DEBUG\r\nif (chan->chan_id == IDMAC_IC_7) {\r\nic_sof = ipu_irq_map(69);\r\nif (ic_sof > 0) {\r\nret = request_irq(ic_sof, ic_sof_irq, 0, "IC SOF", ichan);\r\nif (ret)\r\ndev_err(&chan->dev->device, "request irq failed for IC SOF");\r\n}\r\nic_eof = ipu_irq_map(70);\r\nif (ic_eof > 0) {\r\nret = request_irq(ic_eof, ic_eof_irq, 0, "IC EOF", ichan);\r\nif (ret)\r\ndev_err(&chan->dev->device, "request irq failed for IC EOF");\r\n}\r\n}\r\n#endif\r\nichan->status = IPU_CHANNEL_INITIALIZED;\r\ndev_dbg(&chan->dev->device, "Found channel 0x%x, irq %d\n",\r\nchan->chan_id, ichan->eof_irq);\r\nreturn ret;\r\nerirq:\r\nipu_uninit_channel(idmac, ichan);\r\neichan:\r\nipu_irq_unmap(chan->chan_id);\r\neimap:\r\nreturn ret;\r\n}\r\nstatic void idmac_free_chan_resources(struct dma_chan *chan)\r\n{\r\nstruct idmac_channel *ichan = to_idmac_chan(chan);\r\nstruct idmac *idmac = to_idmac(chan->device);\r\nmutex_lock(&ichan->chan_mutex);\r\n__idmac_terminate_all(chan);\r\nif (ichan->status > IPU_CHANNEL_FREE) {\r\n#ifdef DEBUG\r\nif (chan->chan_id == IDMAC_IC_7) {\r\nif (ic_sof > 0) {\r\nfree_irq(ic_sof, ichan);\r\nipu_irq_unmap(69);\r\nic_sof = -EINVAL;\r\n}\r\nif (ic_eof > 0) {\r\nfree_irq(ic_eof, ichan);\r\nipu_irq_unmap(70);\r\nic_eof = -EINVAL;\r\n}\r\n}\r\n#endif\r\nfree_irq(ichan->eof_irq, ichan);\r\nipu_irq_unmap(chan->chan_id);\r\n}\r\nichan->status = IPU_CHANNEL_FREE;\r\nipu_uninit_channel(idmac, ichan);\r\nmutex_unlock(&ichan->chan_mutex);\r\ntasklet_schedule(&to_ipu(idmac)->tasklet);\r\n}\r\nstatic enum dma_status idmac_tx_status(struct dma_chan *chan,\r\ndma_cookie_t cookie, struct dma_tx_state *txstate)\r\n{\r\nreturn dma_cookie_status(chan, cookie, txstate);\r\n}\r\nstatic int __init ipu_idmac_init(struct ipu *ipu)\r\n{\r\nstruct idmac *idmac = &ipu->idmac;\r\nstruct dma_device *dma = &idmac->dma;\r\nint i;\r\ndma_cap_set(DMA_SLAVE, dma->cap_mask);\r\ndma_cap_set(DMA_PRIVATE, dma->cap_mask);\r\ndma->dev = ipu->dev;\r\ndma->device_alloc_chan_resources = idmac_alloc_chan_resources;\r\ndma->device_free_chan_resources = idmac_free_chan_resources;\r\ndma->device_tx_status = idmac_tx_status;\r\ndma->device_issue_pending = idmac_issue_pending;\r\ndma->device_prep_slave_sg = idmac_prep_slave_sg;\r\ndma->device_pause = idmac_pause;\r\ndma->device_terminate_all = idmac_terminate_all;\r\nINIT_LIST_HEAD(&dma->channels);\r\nfor (i = 0; i < IPU_CHANNELS_NUM; i++) {\r\nstruct idmac_channel *ichan = ipu->channel + i;\r\nstruct dma_chan *dma_chan = &ichan->dma_chan;\r\nspin_lock_init(&ichan->lock);\r\nmutex_init(&ichan->chan_mutex);\r\nichan->status = IPU_CHANNEL_FREE;\r\nichan->sec_chan_en = false;\r\nsnprintf(ichan->eof_name, sizeof(ichan->eof_name), "IDMAC EOF %d", i);\r\ndma_chan->device = &idmac->dma;\r\ndma_cookie_init(dma_chan);\r\ndma_chan->chan_id = i;\r\nlist_add_tail(&dma_chan->device_node, &dma->channels);\r\n}\r\nidmac_write_icreg(ipu, 0x00000070, IDMAC_CONF);\r\nreturn dma_async_device_register(&idmac->dma);\r\n}\r\nstatic void ipu_idmac_exit(struct ipu *ipu)\r\n{\r\nint i;\r\nstruct idmac *idmac = &ipu->idmac;\r\nfor (i = 0; i < IPU_CHANNELS_NUM; i++) {\r\nstruct idmac_channel *ichan = ipu->channel + i;\r\nidmac_terminate_all(&ichan->dma_chan);\r\n}\r\ndma_async_device_unregister(&idmac->dma);\r\n}\r\nstatic int __init ipu_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *mem_ipu, *mem_ic;\r\nint ret;\r\nspin_lock_init(&ipu_data.lock);\r\nmem_ipu = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmem_ic = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!mem_ipu || !mem_ic)\r\nreturn -EINVAL;\r\nipu_data.dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, &ipu_data);\r\nret = platform_get_irq(pdev, 0);\r\nif (ret < 0)\r\ngoto err_noirq;\r\nipu_data.irq_fn = ret;\r\nret = platform_get_irq(pdev, 1);\r\nif (ret < 0)\r\ngoto err_noirq;\r\nipu_data.irq_err = ret;\r\ndev_dbg(&pdev->dev, "fn irq %u, err irq %u\n",\r\nipu_data.irq_fn, ipu_data.irq_err);\r\nipu_data.reg_ipu = ioremap(mem_ipu->start, resource_size(mem_ipu));\r\nif (!ipu_data.reg_ipu) {\r\nret = -ENOMEM;\r\ngoto err_ioremap_ipu;\r\n}\r\nipu_data.reg_ic = ioremap(mem_ic->start, resource_size(mem_ic));\r\nif (!ipu_data.reg_ic) {\r\nret = -ENOMEM;\r\ngoto err_ioremap_ic;\r\n}\r\nipu_data.ipu_clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(ipu_data.ipu_clk)) {\r\nret = PTR_ERR(ipu_data.ipu_clk);\r\ngoto err_clk_get;\r\n}\r\nclk_prepare_enable(ipu_data.ipu_clk);\r\nidmac_write_ipureg(&ipu_data, 0, IPU_INT_CTRL_1);\r\nidmac_write_ipureg(&ipu_data, 0, IPU_INT_CTRL_2);\r\nidmac_write_ipureg(&ipu_data, 0, IPU_INT_CTRL_3);\r\nidmac_write_ipureg(&ipu_data, 0, IPU_INT_CTRL_4);\r\nidmac_write_ipureg(&ipu_data, 0, IPU_INT_CTRL_5);\r\ndev_dbg(&pdev->dev, "%s @ 0x%08lx, fn irq %u, err irq %u\n", pdev->name,\r\n(unsigned long)mem_ipu->start, ipu_data.irq_fn, ipu_data.irq_err);\r\nret = ipu_irq_attach_irq(&ipu_data, pdev);\r\nif (ret < 0)\r\ngoto err_attach_irq;\r\nret = ipu_idmac_init(&ipu_data);\r\nif (ret < 0)\r\ngoto err_idmac_init;\r\ntasklet_init(&ipu_data.tasklet, ipu_gc_tasklet, (unsigned long)&ipu_data);\r\nipu_data.dev = &pdev->dev;\r\ndev_dbg(ipu_data.dev, "IPU initialized\n");\r\nreturn 0;\r\nerr_idmac_init:\r\nerr_attach_irq:\r\nipu_irq_detach_irq(&ipu_data, pdev);\r\nclk_disable_unprepare(ipu_data.ipu_clk);\r\nclk_put(ipu_data.ipu_clk);\r\nerr_clk_get:\r\niounmap(ipu_data.reg_ic);\r\nerr_ioremap_ic:\r\niounmap(ipu_data.reg_ipu);\r\nerr_ioremap_ipu:\r\nerr_noirq:\r\ndev_err(&pdev->dev, "Failed to probe IPU: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int ipu_remove(struct platform_device *pdev)\r\n{\r\nstruct ipu *ipu = platform_get_drvdata(pdev);\r\nipu_idmac_exit(ipu);\r\nipu_irq_detach_irq(ipu, pdev);\r\nclk_disable_unprepare(ipu->ipu_clk);\r\nclk_put(ipu->ipu_clk);\r\niounmap(ipu->reg_ic);\r\niounmap(ipu->reg_ipu);\r\ntasklet_kill(&ipu->tasklet);\r\nreturn 0;\r\n}\r\nstatic int __init ipu_init(void)\r\n{\r\nreturn platform_driver_probe(&ipu_platform_driver, ipu_probe);\r\n}
