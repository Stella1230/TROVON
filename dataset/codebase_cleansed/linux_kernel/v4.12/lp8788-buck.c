static void lp8788_buck1_set_dvs(struct lp8788_buck *buck)\r\n{\r\nstruct lp8788_buck1_dvs *dvs = (struct lp8788_buck1_dvs *)buck->dvs;\r\nenum lp8788_dvs_state pinstate;\r\nif (!dvs)\r\nreturn;\r\npinstate = dvs->vsel == DVS_SEL_V0 ? DVS_LOW : DVS_HIGH;\r\nif (gpio_is_valid(dvs->gpio))\r\ngpio_set_value(dvs->gpio, pinstate);\r\n}\r\nstatic void lp8788_buck2_set_dvs(struct lp8788_buck *buck)\r\n{\r\nstruct lp8788_buck2_dvs *dvs = (struct lp8788_buck2_dvs *)buck->dvs;\r\nenum lp8788_dvs_state pin1, pin2;\r\nif (!dvs)\r\nreturn;\r\nswitch (dvs->vsel) {\r\ncase DVS_SEL_V0:\r\npin1 = DVS_LOW;\r\npin2 = DVS_LOW;\r\nbreak;\r\ncase DVS_SEL_V1:\r\npin1 = DVS_HIGH;\r\npin2 = DVS_LOW;\r\nbreak;\r\ncase DVS_SEL_V2:\r\npin1 = DVS_LOW;\r\npin2 = DVS_HIGH;\r\nbreak;\r\ncase DVS_SEL_V3:\r\npin1 = DVS_HIGH;\r\npin2 = DVS_HIGH;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nif (gpio_is_valid(dvs->gpio[0]))\r\ngpio_set_value(dvs->gpio[0], pin1);\r\nif (gpio_is_valid(dvs->gpio[1]))\r\ngpio_set_value(dvs->gpio[1], pin2);\r\n}\r\nstatic void lp8788_set_dvs(struct lp8788_buck *buck, enum lp8788_buck_id id)\r\n{\r\nswitch (id) {\r\ncase BUCK1:\r\nlp8788_buck1_set_dvs(buck);\r\nbreak;\r\ncase BUCK2:\r\nlp8788_buck2_set_dvs(buck);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic enum lp8788_dvs_mode\r\nlp8788_get_buck_dvs_ctrl_mode(struct lp8788_buck *buck, enum lp8788_buck_id id)\r\n{\r\nu8 val, mask;\r\nswitch (id) {\r\ncase BUCK1:\r\nmask = LP8788_BUCK1_DVS_SEL_M;\r\nbreak;\r\ncase BUCK2:\r\nmask = LP8788_BUCK2_DVS_SEL_M;\r\nbreak;\r\ndefault:\r\nreturn REGISTER;\r\n}\r\nlp8788_read_byte(buck->lp, LP8788_BUCK_DVS_SEL, &val);\r\nreturn val & mask ? REGISTER : EXTPIN;\r\n}\r\nstatic bool lp8788_is_valid_buck_addr(u8 addr)\r\n{\r\nswitch (addr) {\r\ncase LP8788_BUCK1_VOUT0:\r\ncase LP8788_BUCK1_VOUT1:\r\ncase LP8788_BUCK1_VOUT2:\r\ncase LP8788_BUCK1_VOUT3:\r\ncase LP8788_BUCK2_VOUT0:\r\ncase LP8788_BUCK2_VOUT1:\r\ncase LP8788_BUCK2_VOUT2:\r\ncase LP8788_BUCK2_VOUT3:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic u8 lp8788_select_buck_vout_addr(struct lp8788_buck *buck,\r\nenum lp8788_buck_id id)\r\n{\r\nenum lp8788_dvs_mode mode = lp8788_get_buck_dvs_ctrl_mode(buck, id);\r\nstruct lp8788_buck1_dvs *b1_dvs;\r\nstruct lp8788_buck2_dvs *b2_dvs;\r\nu8 val, idx, addr;\r\nint pin1, pin2;\r\nswitch (id) {\r\ncase BUCK1:\r\nif (mode == EXTPIN) {\r\nb1_dvs = (struct lp8788_buck1_dvs *)buck->dvs;\r\nif (!b1_dvs)\r\ngoto err;\r\nidx = gpio_get_value(b1_dvs->gpio) ? 1 : 0;\r\n} else {\r\nlp8788_read_byte(buck->lp, LP8788_BUCK_DVS_SEL, &val);\r\nidx = (val & LP8788_BUCK1_DVS_M) >> LP8788_BUCK1_DVS_S;\r\n}\r\naddr = LP8788_BUCK1_VOUT0 + idx;\r\nbreak;\r\ncase BUCK2:\r\nif (mode == EXTPIN) {\r\nb2_dvs = (struct lp8788_buck2_dvs *)buck->dvs;\r\nif (!b2_dvs)\r\ngoto err;\r\npin1 = gpio_get_value(b2_dvs->gpio[0]);\r\npin2 = gpio_get_value(b2_dvs->gpio[1]);\r\nif (pin1 == PIN_LOW && pin2 == PIN_LOW)\r\nidx = 0;\r\nelse if (pin1 == PIN_LOW && pin2 == PIN_HIGH)\r\nidx = 2;\r\nelse if (pin1 == PIN_HIGH && pin2 == PIN_LOW)\r\nidx = 1;\r\nelse\r\nidx = 3;\r\n} else {\r\nlp8788_read_byte(buck->lp, LP8788_BUCK_DVS_SEL, &val);\r\nidx = (val & LP8788_BUCK2_DVS_M) >> LP8788_BUCK2_DVS_S;\r\n}\r\naddr = LP8788_BUCK2_VOUT0 + idx;\r\nbreak;\r\ndefault:\r\ngoto err;\r\n}\r\nreturn addr;\r\nerr:\r\nreturn INVALID_ADDR;\r\n}\r\nstatic int lp8788_buck12_set_voltage_sel(struct regulator_dev *rdev,\r\nunsigned selector)\r\n{\r\nstruct lp8788_buck *buck = rdev_get_drvdata(rdev);\r\nenum lp8788_buck_id id = rdev_get_id(rdev);\r\nu8 addr;\r\nif (buck->dvs)\r\nlp8788_set_dvs(buck, id);\r\naddr = lp8788_select_buck_vout_addr(buck, id);\r\nif (!lp8788_is_valid_buck_addr(addr))\r\nreturn -EINVAL;\r\nreturn lp8788_update_bits(buck->lp, addr, LP8788_VOUT_M, selector);\r\n}\r\nstatic int lp8788_buck12_get_voltage_sel(struct regulator_dev *rdev)\r\n{\r\nstruct lp8788_buck *buck = rdev_get_drvdata(rdev);\r\nenum lp8788_buck_id id = rdev_get_id(rdev);\r\nint ret;\r\nu8 val, addr;\r\naddr = lp8788_select_buck_vout_addr(buck, id);\r\nif (!lp8788_is_valid_buck_addr(addr))\r\nreturn -EINVAL;\r\nret = lp8788_read_byte(buck->lp, addr, &val);\r\nif (ret)\r\nreturn ret;\r\nreturn val & LP8788_VOUT_M;\r\n}\r\nstatic int lp8788_buck_enable_time(struct regulator_dev *rdev)\r\n{\r\nstruct lp8788_buck *buck = rdev_get_drvdata(rdev);\r\nenum lp8788_buck_id id = rdev_get_id(rdev);\r\nu8 val, addr = LP8788_BUCK1_TIMESTEP + id;\r\nif (lp8788_read_byte(buck->lp, addr, &val))\r\nreturn -EINVAL;\r\nval = (val & LP8788_STARTUP_TIME_M) >> LP8788_STARTUP_TIME_S;\r\nreturn ENABLE_TIME_USEC * val;\r\n}\r\nstatic int lp8788_buck_set_mode(struct regulator_dev *rdev, unsigned int mode)\r\n{\r\nstruct lp8788_buck *buck = rdev_get_drvdata(rdev);\r\nenum lp8788_buck_id id = rdev_get_id(rdev);\r\nu8 mask, val;\r\nmask = BUCK_FPWM_MASK(id);\r\nswitch (mode) {\r\ncase REGULATOR_MODE_FAST:\r\nval = LP8788_FORCE_PWM << BUCK_FPWM_SHIFT(id);\r\nbreak;\r\ncase REGULATOR_MODE_NORMAL:\r\nval = LP8788_AUTO_PWM << BUCK_FPWM_SHIFT(id);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn lp8788_update_bits(buck->lp, LP8788_BUCK_PWM, mask, val);\r\n}\r\nstatic unsigned int lp8788_buck_get_mode(struct regulator_dev *rdev)\r\n{\r\nstruct lp8788_buck *buck = rdev_get_drvdata(rdev);\r\nenum lp8788_buck_id id = rdev_get_id(rdev);\r\nu8 val;\r\nint ret;\r\nret = lp8788_read_byte(buck->lp, LP8788_BUCK_PWM, &val);\r\nif (ret)\r\nreturn ret;\r\nreturn val & BUCK_FPWM_MASK(id) ?\r\nREGULATOR_MODE_FAST : REGULATOR_MODE_NORMAL;\r\n}\r\nstatic int lp8788_dvs_gpio_request(struct platform_device *pdev,\r\nstruct lp8788_buck *buck,\r\nenum lp8788_buck_id id)\r\n{\r\nstruct lp8788_platform_data *pdata = buck->lp->pdata;\r\nchar *b1_name = "LP8788_B1_DVS";\r\nchar *b2_name[] = { "LP8788_B2_DVS1", "LP8788_B2_DVS2" };\r\nint i, gpio, ret;\r\nswitch (id) {\r\ncase BUCK1:\r\ngpio = pdata->buck1_dvs->gpio;\r\nret = devm_gpio_request_one(&pdev->dev, gpio, DVS_LOW,\r\nb1_name);\r\nif (ret)\r\nreturn ret;\r\nbuck->dvs = pdata->buck1_dvs;\r\nbreak;\r\ncase BUCK2:\r\nfor (i = 0; i < LP8788_NUM_BUCK2_DVS; i++) {\r\ngpio = pdata->buck2_dvs->gpio[i];\r\nret = devm_gpio_request_one(&pdev->dev, gpio,\r\nDVS_LOW, b2_name[i]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nbuck->dvs = pdata->buck2_dvs;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lp8788_init_dvs(struct platform_device *pdev,\r\nstruct lp8788_buck *buck, enum lp8788_buck_id id)\r\n{\r\nstruct lp8788_platform_data *pdata = buck->lp->pdata;\r\nu8 mask[] = { LP8788_BUCK1_DVS_SEL_M, LP8788_BUCK2_DVS_SEL_M };\r\nu8 val[] = { LP8788_BUCK1_DVS_PIN, LP8788_BUCK2_DVS_PIN };\r\nu8 default_dvs_mode[] = { LP8788_BUCK1_DVS_I2C, LP8788_BUCK2_DVS_I2C };\r\nif (id > BUCK2)\r\nreturn 0;\r\nif (!pdata)\r\ngoto set_default_dvs_mode;\r\nif ((id == BUCK1 && !pdata->buck1_dvs) ||\r\n(id == BUCK2 && !pdata->buck2_dvs))\r\ngoto set_default_dvs_mode;\r\nif (lp8788_dvs_gpio_request(pdev, buck, id))\r\ngoto set_default_dvs_mode;\r\nreturn lp8788_update_bits(buck->lp, LP8788_BUCK_DVS_SEL, mask[id],\r\nval[id]);\r\nset_default_dvs_mode:\r\nreturn lp8788_update_bits(buck->lp, LP8788_BUCK_DVS_SEL, mask[id],\r\ndefault_dvs_mode[id]);\r\n}\r\nstatic int lp8788_buck_probe(struct platform_device *pdev)\r\n{\r\nstruct lp8788 *lp = dev_get_drvdata(pdev->dev.parent);\r\nint id = pdev->id;\r\nstruct lp8788_buck *buck;\r\nstruct regulator_config cfg = { };\r\nstruct regulator_dev *rdev;\r\nint ret;\r\nif (id >= LP8788_NUM_BUCKS)\r\nreturn -EINVAL;\r\nbuck = devm_kzalloc(&pdev->dev, sizeof(struct lp8788_buck), GFP_KERNEL);\r\nif (!buck)\r\nreturn -ENOMEM;\r\nbuck->lp = lp;\r\nret = lp8788_init_dvs(pdev, buck, id);\r\nif (ret)\r\nreturn ret;\r\ncfg.dev = pdev->dev.parent;\r\ncfg.init_data = lp->pdata ? lp->pdata->buck_data[id] : NULL;\r\ncfg.driver_data = buck;\r\ncfg.regmap = lp->regmap;\r\nrdev = devm_regulator_register(&pdev->dev, &lp8788_buck_desc[id], &cfg);\r\nif (IS_ERR(rdev)) {\r\nret = PTR_ERR(rdev);\r\ndev_err(&pdev->dev, "BUCK%d regulator register err = %d\n",\r\nid + 1, ret);\r\nreturn ret;\r\n}\r\nbuck->regulator = rdev;\r\nplatform_set_drvdata(pdev, buck);\r\nreturn 0;\r\n}\r\nstatic int __init lp8788_buck_init(void)\r\n{\r\nreturn platform_driver_register(&lp8788_buck_driver);\r\n}\r\nstatic void __exit lp8788_buck_exit(void)\r\n{\r\nplatform_driver_unregister(&lp8788_buck_driver);\r\n}
