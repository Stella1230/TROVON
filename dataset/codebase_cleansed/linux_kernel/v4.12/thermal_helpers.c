int get_tz_trend(struct thermal_zone_device *tz, int trip)\r\n{\r\nenum thermal_trend trend;\r\nif (tz->emul_temperature || !tz->ops->get_trend ||\r\ntz->ops->get_trend(tz, trip, &trend)) {\r\nif (tz->temperature > tz->last_temperature)\r\ntrend = THERMAL_TREND_RAISING;\r\nelse if (tz->temperature < tz->last_temperature)\r\ntrend = THERMAL_TREND_DROPPING;\r\nelse\r\ntrend = THERMAL_TREND_STABLE;\r\n}\r\nreturn trend;\r\n}\r\nstruct thermal_instance *\r\nget_thermal_instance(struct thermal_zone_device *tz,\r\nstruct thermal_cooling_device *cdev, int trip)\r\n{\r\nstruct thermal_instance *pos = NULL;\r\nstruct thermal_instance *target_instance = NULL;\r\nmutex_lock(&tz->lock);\r\nmutex_lock(&cdev->lock);\r\nlist_for_each_entry(pos, &tz->thermal_instances, tz_node) {\r\nif (pos->tz == tz && pos->trip == trip && pos->cdev == cdev) {\r\ntarget_instance = pos;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&cdev->lock);\r\nmutex_unlock(&tz->lock);\r\nreturn target_instance;\r\n}\r\nint thermal_zone_get_temp(struct thermal_zone_device *tz, int *temp)\r\n{\r\nint ret = -EINVAL;\r\nint count;\r\nint crit_temp = INT_MAX;\r\nenum thermal_trip_type type;\r\nif (!tz || IS_ERR(tz) || !tz->ops->get_temp)\r\ngoto exit;\r\nmutex_lock(&tz->lock);\r\nret = tz->ops->get_temp(tz, temp);\r\nif (IS_ENABLED(CONFIG_THERMAL_EMULATION) && tz->emul_temperature) {\r\nfor (count = 0; count < tz->trips; count++) {\r\nret = tz->ops->get_trip_type(tz, count, &type);\r\nif (!ret && type == THERMAL_TRIP_CRITICAL) {\r\nret = tz->ops->get_trip_temp(tz, count,\r\n&crit_temp);\r\nbreak;\r\n}\r\n}\r\nif (!ret && *temp < crit_temp)\r\n*temp = tz->emul_temperature;\r\n}\r\nmutex_unlock(&tz->lock);\r\nexit:\r\nreturn ret;\r\n}\r\nvoid thermal_zone_set_trips(struct thermal_zone_device *tz)\r\n{\r\nint low = -INT_MAX;\r\nint high = INT_MAX;\r\nint trip_temp, hysteresis;\r\nint i, ret;\r\nmutex_lock(&tz->lock);\r\nif (!tz->ops->set_trips || !tz->ops->get_trip_hyst)\r\ngoto exit;\r\nfor (i = 0; i < tz->trips; i++) {\r\nint trip_low;\r\ntz->ops->get_trip_temp(tz, i, &trip_temp);\r\ntz->ops->get_trip_hyst(tz, i, &hysteresis);\r\ntrip_low = trip_temp - hysteresis;\r\nif (trip_low < tz->temperature && trip_low > low)\r\nlow = trip_low;\r\nif (trip_temp > tz->temperature && trip_temp < high)\r\nhigh = trip_temp;\r\n}\r\nif (tz->prev_low_trip == low && tz->prev_high_trip == high)\r\ngoto exit;\r\ntz->prev_low_trip = low;\r\ntz->prev_high_trip = high;\r\ndev_dbg(&tz->device,\r\n"new temperature boundaries: %d < x < %d\n", low, high);\r\nret = tz->ops->set_trips(tz, low, high);\r\nif (ret)\r\ndev_err(&tz->device, "Failed to set trips: %d\n", ret);\r\nexit:\r\nmutex_unlock(&tz->lock);\r\n}\r\nvoid thermal_cdev_update(struct thermal_cooling_device *cdev)\r\n{\r\nstruct thermal_instance *instance;\r\nunsigned long target = 0;\r\nmutex_lock(&cdev->lock);\r\nif (cdev->updated) {\r\nmutex_unlock(&cdev->lock);\r\nreturn;\r\n}\r\nlist_for_each_entry(instance, &cdev->thermal_instances, cdev_node) {\r\ndev_dbg(&cdev->device, "zone%d->target=%lu\n",\r\ninstance->tz->id, instance->target);\r\nif (instance->target == THERMAL_NO_TARGET)\r\ncontinue;\r\nif (instance->target > target)\r\ntarget = instance->target;\r\n}\r\ncdev->ops->set_cur_state(cdev, target);\r\ncdev->updated = true;\r\nmutex_unlock(&cdev->lock);\r\ntrace_cdev_update(cdev, target);\r\ndev_dbg(&cdev->device, "set to state %lu\n", target);\r\n}\r\nint thermal_zone_get_slope(struct thermal_zone_device *tz)\r\n{\r\nif (tz && tz->tzp)\r\nreturn tz->tzp->slope;\r\nreturn 1;\r\n}\r\nint thermal_zone_get_offset(struct thermal_zone_device *tz)\r\n{\r\nif (tz && tz->tzp)\r\nreturn tz->tzp->offset;\r\nreturn 0;\r\n}
