static int tuner_attach_stv6110(struct ngene_channel *chan)\r\n{\r\nstruct i2c_adapter *i2c;\r\nstruct stv090x_config *feconf = (struct stv090x_config *)\r\nchan->dev->card_info->fe_config[chan->number];\r\nstruct stv6110x_config *tunerconf = (struct stv6110x_config *)\r\nchan->dev->card_info->tuner_config[chan->number];\r\nconst struct stv6110x_devctl *ctl;\r\nif (chan->number < 2)\r\ni2c = &chan->dev->channel[0].i2c_adapter;\r\nelse\r\ni2c = &chan->dev->channel[1].i2c_adapter;\r\nctl = dvb_attach(stv6110x_attach, chan->fe, tunerconf, i2c);\r\nif (ctl == NULL) {\r\nprintk(KERN_ERR DEVICE_NAME ": No STV6110X found!\n");\r\nreturn -ENODEV;\r\n}\r\nfeconf->tuner_init = ctl->tuner_init;\r\nfeconf->tuner_sleep = ctl->tuner_sleep;\r\nfeconf->tuner_set_mode = ctl->tuner_set_mode;\r\nfeconf->tuner_set_frequency = ctl->tuner_set_frequency;\r\nfeconf->tuner_get_frequency = ctl->tuner_get_frequency;\r\nfeconf->tuner_set_bandwidth = ctl->tuner_set_bandwidth;\r\nfeconf->tuner_get_bandwidth = ctl->tuner_get_bandwidth;\r\nfeconf->tuner_set_bbgain = ctl->tuner_set_bbgain;\r\nfeconf->tuner_get_bbgain = ctl->tuner_get_bbgain;\r\nfeconf->tuner_set_refclk = ctl->tuner_set_refclk;\r\nfeconf->tuner_get_status = ctl->tuner_get_status;\r\nreturn 0;\r\n}\r\nstatic int drxk_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct ngene_channel *chan = fe->sec_priv;\r\nint status;\r\nif (enable) {\r\ndown(&chan->dev->pll_mutex);\r\nstatus = chan->gate_ctrl(fe, 1);\r\n} else {\r\nstatus = chan->gate_ctrl(fe, 0);\r\nup(&chan->dev->pll_mutex);\r\n}\r\nreturn status;\r\n}\r\nstatic int tuner_attach_tda18271(struct ngene_channel *chan)\r\n{\r\nstruct i2c_adapter *i2c;\r\nstruct dvb_frontend *fe;\r\ni2c = &chan->dev->channel[0].i2c_adapter;\r\nif (chan->fe->ops.i2c_gate_ctrl)\r\nchan->fe->ops.i2c_gate_ctrl(chan->fe, 1);\r\nfe = dvb_attach(tda18271c2dd_attach, chan->fe, i2c, 0x60);\r\nif (chan->fe->ops.i2c_gate_ctrl)\r\nchan->fe->ops.i2c_gate_ctrl(chan->fe, 0);\r\nif (!fe) {\r\nprintk(KERN_ERR "No TDA18271 found!\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tuner_attach_probe(struct ngene_channel *chan)\r\n{\r\nif (chan->demod_type == 0)\r\nreturn tuner_attach_stv6110(chan);\r\nif (chan->demod_type == 1)\r\nreturn tuner_attach_tda18271(chan);\r\nreturn -EINVAL;\r\n}\r\nstatic int demod_attach_stv0900(struct ngene_channel *chan)\r\n{\r\nstruct i2c_adapter *i2c;\r\nstruct stv090x_config *feconf = (struct stv090x_config *)\r\nchan->dev->card_info->fe_config[chan->number];\r\nif (chan->number < 2)\r\ni2c = &chan->dev->channel[0].i2c_adapter;\r\nelse\r\ni2c = &chan->dev->channel[1].i2c_adapter;\r\nchan->fe = dvb_attach(stv090x_attach, feconf, i2c,\r\n(chan->number & 1) == 0 ? STV090x_DEMODULATOR_0\r\n: STV090x_DEMODULATOR_1);\r\nif (chan->fe == NULL) {\r\nprintk(KERN_ERR DEVICE_NAME ": No STV0900 found!\n");\r\nreturn -ENODEV;\r\n}\r\nif (feconf->tuner_i2c_lock)\r\nchan->fe->analog_demod_priv = chan;\r\nif (!dvb_attach(lnbh24_attach, chan->fe, i2c, 0,\r\n0, chan->dev->card_info->lnb[chan->number])) {\r\nprintk(KERN_ERR DEVICE_NAME ": No LNBH24 found!\n");\r\ndvb_frontend_detach(chan->fe);\r\nchan->fe = NULL;\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void cineS2_tuner_i2c_lock(struct dvb_frontend *fe, int lock)\r\n{\r\nstruct ngene_channel *chan = fe->analog_demod_priv;\r\nif (lock)\r\ndown(&chan->dev->pll_mutex);\r\nelse\r\nup(&chan->dev->pll_mutex);\r\n}\r\nstatic int i2c_read(struct i2c_adapter *adapter, u8 adr, u8 *val)\r\n{\r\nstruct i2c_msg msgs[1] = {{.addr = adr, .flags = I2C_M_RD,\r\n.buf = val, .len = 1 } };\r\nreturn (i2c_transfer(adapter, msgs, 1) == 1) ? 0 : -1;\r\n}\r\nstatic int i2c_read_reg16(struct i2c_adapter *adapter, u8 adr,\r\nu16 reg, u8 *val)\r\n{\r\nu8 msg[2] = {reg>>8, reg&0xff};\r\nstruct i2c_msg msgs[2] = {{.addr = adr, .flags = 0,\r\n.buf = msg, .len = 2},\r\n{.addr = adr, .flags = I2C_M_RD,\r\n.buf = val, .len = 1} };\r\nreturn (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;\r\n}\r\nstatic int port_has_stv0900(struct i2c_adapter *i2c, int port)\r\n{\r\nu8 val;\r\nif (i2c_read_reg16(i2c, 0x68+port/2, 0xf100, &val) < 0)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int port_has_drxk(struct i2c_adapter *i2c, int port)\r\n{\r\nu8 val;\r\nif (i2c_read(i2c, 0x29+port, &val) < 0)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int demod_attach_drxk(struct ngene_channel *chan,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct drxk_config config;\r\nmemset(&config, 0, sizeof(config));\r\nconfig.microcode_name = "drxk_a3.mc";\r\nconfig.qam_demod_parameter_count = 4;\r\nconfig.adr = 0x29 + (chan->number ^ 2);\r\nchan->fe = dvb_attach(drxk_attach, &config, i2c);\r\nif (!chan->fe) {\r\nprintk(KERN_ERR "No DRXK found!\n");\r\nreturn -ENODEV;\r\n}\r\nchan->fe->sec_priv = chan;\r\nchan->gate_ctrl = chan->fe->ops.i2c_gate_ctrl;\r\nchan->fe->ops.i2c_gate_ctrl = drxk_gate_ctrl;\r\nreturn 0;\r\n}\r\nstatic int cineS2_probe(struct ngene_channel *chan)\r\n{\r\nstruct i2c_adapter *i2c;\r\nstruct stv090x_config *fe_conf;\r\nu8 buf[3];\r\nstruct i2c_msg i2c_msg = { .flags = 0, .buf = buf };\r\nint rc;\r\nif (chan->number < 2)\r\ni2c = &chan->dev->channel[0].i2c_adapter;\r\nelse\r\ni2c = &chan->dev->channel[1].i2c_adapter;\r\nif (port_has_stv0900(i2c, chan->number)) {\r\nchan->demod_type = 0;\r\nfe_conf = chan->dev->card_info->fe_config[chan->number];\r\nrc = demod_attach_stv0900(chan);\r\nif (rc < 0 || chan->number < 2)\r\nreturn rc;\r\ni2c_msg.addr = fe_conf->address;\r\ni2c_msg.len = 3;\r\nbuf[0] = 0xf1;\r\nswitch (chan->number) {\r\ncase 2:\r\nbuf[1] = 0x5c;\r\nbuf[2] = 0xc2;\r\nbreak;\r\ncase 3:\r\nbuf[1] = 0x61;\r\nbuf[2] = 0xcc;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nrc = i2c_transfer(i2c, &i2c_msg, 1);\r\nif (rc != 1) {\r\nprintk(KERN_ERR DEVICE_NAME ": could not setup DPNx\n");\r\nreturn -EIO;\r\n}\r\n} else if (port_has_drxk(i2c, chan->number^2)) {\r\nchan->demod_type = 1;\r\ndemod_attach_drxk(chan, i2c);\r\n} else {\r\nprintk(KERN_ERR "No demod found on chan %d\n", chan->number);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int demod_attach_lg330x(struct ngene_channel *chan)\r\n{\r\nchan->fe = dvb_attach(lgdt330x_attach, &aver_m780, &chan->i2c_adapter);\r\nif (chan->fe == NULL) {\r\nprintk(KERN_ERR DEVICE_NAME ": No LGDT330x found!\n");\r\nreturn -ENODEV;\r\n}\r\ndvb_attach(mt2131_attach, chan->fe, &chan->i2c_adapter,\r\n&m780_tunerconfig, 0);\r\nreturn (chan->fe) ? 0 : -ENODEV;\r\n}\r\nstatic int demod_attach_drxd(struct ngene_channel *chan)\r\n{\r\nstruct drxd_config *feconf;\r\nfeconf = chan->dev->card_info->fe_config[chan->number];\r\nchan->fe = dvb_attach(drxd_attach, feconf, chan,\r\n&chan->i2c_adapter, &chan->dev->pci_dev->dev);\r\nif (!chan->fe) {\r\npr_err("No DRXD found!\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tuner_attach_dtt7520x(struct ngene_channel *chan)\r\n{\r\nstruct drxd_config *feconf;\r\nfeconf = chan->dev->card_info->fe_config[chan->number];\r\nif (!dvb_attach(dvb_pll_attach, chan->fe, feconf->pll_address,\r\n&chan->i2c_adapter,\r\nfeconf->pll_type)) {\r\npr_err("No pll(%d) found!\n", feconf->pll_type);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2c_write_eeprom(struct i2c_adapter *adapter,\r\nu8 adr, u16 reg, u8 data)\r\n{\r\nu8 m[3] = {(reg >> 8), (reg & 0xff), data};\r\nstruct i2c_msg msg = {.addr = adr, .flags = 0, .buf = m,\r\n.len = sizeof(m)};\r\nif (i2c_transfer(adapter, &msg, 1) != 1) {\r\npr_err(DEVICE_NAME ": Error writing EEPROM!\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2c_read_eeprom(struct i2c_adapter *adapter,\r\nu8 adr, u16 reg, u8 *data, int len)\r\n{\r\nu8 msg[2] = {(reg >> 8), (reg & 0xff)};\r\nstruct i2c_msg msgs[2] = {{.addr = adr, .flags = 0,\r\n.buf = msg, .len = 2 },\r\n{.addr = adr, .flags = I2C_M_RD,\r\n.buf = data, .len = len} };\r\nif (i2c_transfer(adapter, msgs, 2) != 2) {\r\npr_err(DEVICE_NAME ": Error reading EEPROM\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ReadEEProm(struct i2c_adapter *adapter,\r\nu16 Tag, u32 MaxLen, u8 *data, u32 *pLength)\r\n{\r\nint status = 0;\r\nu16 Addr = MICNG_EE_START, Length, tag = 0;\r\nu8 EETag[3];\r\nwhile (Addr + sizeof(u16) + 1 < MICNG_EE_END) {\r\nif (i2c_read_eeprom(adapter, 0x50, Addr, EETag, sizeof(EETag)))\r\nreturn -1;\r\ntag = (EETag[0] << 8) | EETag[1];\r\nif (tag == MICNG_EETAG_END0 || tag == MICNG_EETAG_END1)\r\nreturn -1;\r\nif (tag == Tag)\r\nbreak;\r\nAddr += sizeof(u16) + 1 + EETag[2];\r\n}\r\nif (Addr + sizeof(u16) + 1 + EETag[2] > MICNG_EE_END) {\r\npr_err(DEVICE_NAME\r\n": Reached EOEE @ Tag = %04x Length = %3d\n",\r\ntag, EETag[2]);\r\nreturn -1;\r\n}\r\nLength = EETag[2];\r\nif (Length > MaxLen)\r\nLength = (u16) MaxLen;\r\nif (Length > 0) {\r\nAddr += sizeof(u16) + 1;\r\nstatus = i2c_read_eeprom(adapter, 0x50, Addr, data, Length);\r\nif (!status) {\r\n*pLength = EETag[2];\r\n#if 0\r\nif (Length < EETag[2])\r\nstatus = STATUS_BUFFER_OVERFLOW;\r\n#endif\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic int WriteEEProm(struct i2c_adapter *adapter,\r\nu16 Tag, u32 Length, u8 *data)\r\n{\r\nint status = 0;\r\nu16 Addr = MICNG_EE_START;\r\nu8 EETag[3];\r\nu16 tag = 0;\r\nint retry, i;\r\nwhile (Addr + sizeof(u16) + 1 < MICNG_EE_END) {\r\nif (i2c_read_eeprom(adapter, 0x50, Addr, EETag, sizeof(EETag)))\r\nreturn -1;\r\ntag = (EETag[0] << 8) | EETag[1];\r\nif (tag == MICNG_EETAG_END0 || tag == MICNG_EETAG_END1)\r\nreturn -1;\r\nif (tag == Tag)\r\nbreak;\r\nAddr += sizeof(u16) + 1 + EETag[2];\r\n}\r\nif (Addr + sizeof(u16) + 1 + EETag[2] > MICNG_EE_END) {\r\npr_err(DEVICE_NAME\r\n": Reached EOEE @ Tag = %04x Length = %3d\n",\r\ntag, EETag[2]);\r\nreturn -1;\r\n}\r\nif (Length > EETag[2])\r\nreturn -EINVAL;\r\nAddr += sizeof(u16) + 1;\r\nfor (i = 0; i < Length; i++, Addr++) {\r\nstatus = i2c_write_eeprom(adapter, 0x50, Addr, data[i]);\r\nif (status)\r\nbreak;\r\nretry = 10;\r\nwhile (retry) {\r\nu8 Tmp;\r\nmsleep(50);\r\nstatus = i2c_read_eeprom(adapter, 0x50, Addr, &Tmp, 1);\r\nif (status)\r\nbreak;\r\nif (Tmp != data[i])\r\npr_err(DEVICE_NAME\r\n"eeprom write error\n");\r\nretry -= 1;\r\n}\r\nif (status) {\r\npr_err(DEVICE_NAME\r\n": Timeout polling eeprom\n");\r\nbreak;\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic int eeprom_read_ushort(struct i2c_adapter *adapter, u16 tag, u16 *data)\r\n{\r\nint stat;\r\nu8 buf[2];\r\nu32 len = 0;\r\nstat = ReadEEProm(adapter, tag, 2, buf, &len);\r\nif (stat)\r\nreturn stat;\r\nif (len != 2)\r\nreturn -EINVAL;\r\n*data = (buf[0] << 8) | buf[1];\r\nreturn 0;\r\n}\r\nstatic int eeprom_write_ushort(struct i2c_adapter *adapter, u16 tag, u16 data)\r\n{\r\nint stat;\r\nu8 buf[2];\r\nbuf[0] = data >> 8;\r\nbuf[1] = data & 0xff;\r\nstat = WriteEEProm(adapter, tag, 2, buf);\r\nif (stat)\r\nreturn stat;\r\nreturn 0;\r\n}\r\nstatic s16 osc_deviation(void *priv, s16 deviation, int flag)\r\n{\r\nstruct ngene_channel *chan = priv;\r\nstruct i2c_adapter *adap = &chan->i2c_adapter;\r\nu16 data = 0;\r\nif (flag) {\r\ndata = (u16) deviation;\r\npr_info(DEVICE_NAME ": write deviation %d\n",\r\ndeviation);\r\neeprom_write_ushort(adap, 0x1000 + chan->number, data);\r\n} else {\r\nif (eeprom_read_ushort(adap, 0x1000 + chan->number, &data))\r\ndata = 0;\r\npr_info(DEVICE_NAME ": read deviation %d\n",\r\n(s16) data);\r\n}\r\nreturn (s16) data;\r\n}\r\nstatic pci_ers_result_t ngene_error_detected(struct pci_dev *dev,\r\nenum pci_channel_state state)\r\n{\r\nprintk(KERN_ERR DEVICE_NAME ": PCI error\n");\r\nif (state == pci_channel_io_perm_failure)\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\nif (state == pci_channel_io_frozen)\r\nreturn PCI_ERS_RESULT_NEED_RESET;\r\nreturn PCI_ERS_RESULT_CAN_RECOVER;\r\n}\r\nstatic pci_ers_result_t ngene_slot_reset(struct pci_dev *dev)\r\n{\r\nprintk(KERN_INFO DEVICE_NAME ": slot reset\n");\r\nreturn 0;\r\n}\r\nstatic void ngene_resume(struct pci_dev *dev)\r\n{\r\nprintk(KERN_INFO DEVICE_NAME ": resume\n");\r\n}\r\nstatic __init int module_init_ngene(void)\r\n{\r\nprintk(KERN_INFO\r\n"nGene PCIE bridge driver, Copyright (C) 2005-2007 Micronas\n");\r\nreturn pci_register_driver(&ngene_pci_driver);\r\n}\r\nstatic __exit void module_exit_ngene(void)\r\n{\r\npci_unregister_driver(&ngene_pci_driver);\r\n}
