void btmrvl_interrupt(struct btmrvl_private *priv)\r\n{\r\npriv->adapter->ps_state = PS_AWAKE;\r\npriv->adapter->wakeup_tries = 0;\r\npriv->adapter->int_count++;\r\nif (priv->adapter->hs_state == HS_ACTIVATED) {\r\nBT_DBG("BT: HS DEACTIVATED in ISR!");\r\npriv->adapter->hs_state = HS_DEACTIVATED;\r\n}\r\nwake_up_interruptible(&priv->main_thread.wait_q);\r\n}\r\nbool btmrvl_check_evtpkt(struct btmrvl_private *priv, struct sk_buff *skb)\r\n{\r\nstruct hci_event_hdr *hdr = (void *) skb->data;\r\nif (hdr->evt == HCI_EV_CMD_COMPLETE) {\r\nstruct hci_ev_cmd_complete *ec;\r\nu16 opcode;\r\nec = (void *) (skb->data + HCI_EVENT_HDR_SIZE);\r\nopcode = __le16_to_cpu(ec->opcode);\r\nif (priv->btmrvl_dev.sendcmdflag) {\r\npriv->btmrvl_dev.sendcmdflag = false;\r\npriv->adapter->cmd_complete = true;\r\nwake_up_interruptible(&priv->adapter->cmd_wait_q);\r\nif (hci_opcode_ogf(opcode) == 0x3F) {\r\nBT_DBG("vendor event skipped: opcode=%#4.4x",\r\nopcode);\r\nkfree_skb(skb);\r\nreturn false;\r\n}\r\n}\r\n}\r\nreturn true;\r\n}\r\nint btmrvl_process_event(struct btmrvl_private *priv, struct sk_buff *skb)\r\n{\r\nstruct btmrvl_adapter *adapter = priv->adapter;\r\nstruct btmrvl_event *event;\r\nint ret = 0;\r\nevent = (struct btmrvl_event *) skb->data;\r\nif (event->ec != 0xff) {\r\nBT_DBG("Not Marvell Event=%x", event->ec);\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nswitch (event->data[0]) {\r\ncase BT_EVENT_AUTO_SLEEP_MODE:\r\nif (!event->data[2]) {\r\nif (event->data[1] == BT_PS_ENABLE)\r\nadapter->psmode = 1;\r\nelse\r\nadapter->psmode = 0;\r\nBT_DBG("PS Mode:%s",\r\n(adapter->psmode) ? "Enable" : "Disable");\r\n} else {\r\nBT_DBG("PS Mode command failed");\r\n}\r\nbreak;\r\ncase BT_EVENT_HOST_SLEEP_CONFIG:\r\nif (!event->data[3])\r\nBT_DBG("gpio=%x, gap=%x", event->data[1],\r\nevent->data[2]);\r\nelse\r\nBT_DBG("HSCFG command failed");\r\nbreak;\r\ncase BT_EVENT_HOST_SLEEP_ENABLE:\r\nif (!event->data[1]) {\r\nadapter->hs_state = HS_ACTIVATED;\r\nif (adapter->psmode)\r\nadapter->ps_state = PS_SLEEP;\r\nwake_up_interruptible(&adapter->event_hs_wait_q);\r\nBT_DBG("HS ACTIVATED!");\r\n} else {\r\nBT_DBG("HS Enable failed");\r\n}\r\nbreak;\r\ncase BT_EVENT_MODULE_CFG_REQ:\r\nif (priv->btmrvl_dev.sendcmdflag &&\r\nevent->data[1] == MODULE_BRINGUP_REQ) {\r\nBT_DBG("EVENT:%s",\r\n((event->data[2] == MODULE_BROUGHT_UP) ||\r\n(event->data[2] == MODULE_ALREADY_UP)) ?\r\n"Bring-up succeed" : "Bring-up failed");\r\nif (event->length > 3 && event->data[3])\r\npriv->btmrvl_dev.dev_type = HCI_AMP;\r\nelse\r\npriv->btmrvl_dev.dev_type = HCI_PRIMARY;\r\nBT_DBG("dev_type: %d", priv->btmrvl_dev.dev_type);\r\n} else if (priv->btmrvl_dev.sendcmdflag &&\r\nevent->data[1] == MODULE_SHUTDOWN_REQ) {\r\nBT_DBG("EVENT:%s", (event->data[2]) ?\r\n"Shutdown failed" : "Shutdown succeed");\r\n} else {\r\nBT_DBG("BT_CMD_MODULE_CFG_REQ resp for APP");\r\nret = -EINVAL;\r\n}\r\nbreak;\r\ncase BT_EVENT_POWER_STATE:\r\nif (event->data[1] == BT_PS_SLEEP)\r\nadapter->ps_state = PS_SLEEP;\r\nBT_DBG("EVENT:%s",\r\n(adapter->ps_state) ? "PS_SLEEP" : "PS_AWAKE");\r\nbreak;\r\ndefault:\r\nBT_DBG("Unknown Event=%d", event->data[0]);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nexit:\r\nif (!ret)\r\nkfree_skb(skb);\r\nreturn ret;\r\n}\r\nstatic int btmrvl_send_sync_cmd(struct btmrvl_private *priv, u16 opcode,\r\nconst void *param, u8 len)\r\n{\r\nstruct sk_buff *skb;\r\nstruct hci_command_hdr *hdr;\r\nif (priv->surprise_removed) {\r\nBT_ERR("Card is removed");\r\nreturn -EFAULT;\r\n}\r\nskb = bt_skb_alloc(HCI_COMMAND_HDR_SIZE + len, GFP_ATOMIC);\r\nif (!skb) {\r\nBT_ERR("No free skb");\r\nreturn -ENOMEM;\r\n}\r\nhdr = (struct hci_command_hdr *)skb_put(skb, HCI_COMMAND_HDR_SIZE);\r\nhdr->opcode = cpu_to_le16(opcode);\r\nhdr->plen = len;\r\nif (len)\r\nmemcpy(skb_put(skb, len), param, len);\r\nhci_skb_pkt_type(skb) = MRVL_VENDOR_PKT;\r\nskb_queue_head(&priv->adapter->tx_queue, skb);\r\npriv->btmrvl_dev.sendcmdflag = true;\r\npriv->adapter->cmd_complete = false;\r\nwake_up_interruptible(&priv->main_thread.wait_q);\r\nif (!wait_event_interruptible_timeout(priv->adapter->cmd_wait_q,\r\npriv->adapter->cmd_complete ||\r\npriv->surprise_removed,\r\nWAIT_UNTIL_CMD_RESP))\r\nreturn -ETIMEDOUT;\r\nif (priv->surprise_removed)\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nint btmrvl_send_module_cfg_cmd(struct btmrvl_private *priv, u8 subcmd)\r\n{\r\nint ret;\r\nret = btmrvl_send_sync_cmd(priv, BT_CMD_MODULE_CFG_REQ, &subcmd, 1);\r\nif (ret)\r\nBT_ERR("module_cfg_cmd(%x) failed", subcmd);\r\nreturn ret;\r\n}\r\nstatic int btmrvl_enable_sco_routing_to_host(struct btmrvl_private *priv)\r\n{\r\nint ret;\r\nu8 subcmd = 0;\r\nret = btmrvl_send_sync_cmd(priv, BT_CMD_ROUTE_SCO_TO_HOST, &subcmd, 1);\r\nif (ret)\r\nBT_ERR("BT_CMD_ROUTE_SCO_TO_HOST command failed: %#x", ret);\r\nreturn ret;\r\n}\r\nint btmrvl_pscan_window_reporting(struct btmrvl_private *priv, u8 subcmd)\r\n{\r\nstruct btmrvl_sdio_card *card = priv->btmrvl_dev.card;\r\nint ret;\r\nif (!card->support_pscan_win_report)\r\nreturn 0;\r\nret = btmrvl_send_sync_cmd(priv, BT_CMD_PSCAN_WIN_REPORT_ENABLE,\r\n&subcmd, 1);\r\nif (ret)\r\nBT_ERR("PSCAN_WIN_REPORT_ENABLE command failed: %#x", ret);\r\nreturn ret;\r\n}\r\nint btmrvl_send_hscfg_cmd(struct btmrvl_private *priv)\r\n{\r\nint ret;\r\nu8 param[2];\r\nparam[0] = (priv->btmrvl_dev.gpio_gap & 0xff00) >> 8;\r\nparam[1] = (u8) (priv->btmrvl_dev.gpio_gap & 0x00ff);\r\nBT_DBG("Sending HSCFG Command, gpio=0x%x, gap=0x%x",\r\nparam[0], param[1]);\r\nret = btmrvl_send_sync_cmd(priv, BT_CMD_HOST_SLEEP_CONFIG, param, 2);\r\nif (ret)\r\nBT_ERR("HSCFG command failed");\r\nreturn ret;\r\n}\r\nint btmrvl_enable_ps(struct btmrvl_private *priv)\r\n{\r\nint ret;\r\nu8 param;\r\nif (priv->btmrvl_dev.psmode)\r\nparam = BT_PS_ENABLE;\r\nelse\r\nparam = BT_PS_DISABLE;\r\nret = btmrvl_send_sync_cmd(priv, BT_CMD_AUTO_SLEEP_MODE, &param, 1);\r\nif (ret)\r\nBT_ERR("PSMODE command failed");\r\nreturn 0;\r\n}\r\nint btmrvl_enable_hs(struct btmrvl_private *priv)\r\n{\r\nstruct btmrvl_adapter *adapter = priv->adapter;\r\nint ret;\r\nret = btmrvl_send_sync_cmd(priv, BT_CMD_HOST_SLEEP_ENABLE, NULL, 0);\r\nif (ret) {\r\nBT_ERR("Host sleep enable command failed");\r\nreturn ret;\r\n}\r\nret = wait_event_interruptible_timeout(adapter->event_hs_wait_q,\r\nadapter->hs_state ||\r\npriv->surprise_removed,\r\nWAIT_UNTIL_HS_STATE_CHANGED);\r\nif (ret < 0 || priv->surprise_removed) {\r\nBT_ERR("event_hs_wait_q terminated (%d): %d,%d,%d",\r\nret, adapter->hs_state, adapter->ps_state,\r\nadapter->wakeup_tries);\r\n} else if (!ret) {\r\nBT_ERR("hs_enable timeout: %d,%d,%d", adapter->hs_state,\r\nadapter->ps_state, adapter->wakeup_tries);\r\nret = -ETIMEDOUT;\r\n} else {\r\nBT_DBG("host sleep enabled: %d,%d,%d", adapter->hs_state,\r\nadapter->ps_state, adapter->wakeup_tries);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nint btmrvl_prepare_command(struct btmrvl_private *priv)\r\n{\r\nint ret = 0;\r\nif (priv->btmrvl_dev.hscfgcmd) {\r\npriv->btmrvl_dev.hscfgcmd = 0;\r\nbtmrvl_send_hscfg_cmd(priv);\r\n}\r\nif (priv->btmrvl_dev.pscmd) {\r\npriv->btmrvl_dev.pscmd = 0;\r\nbtmrvl_enable_ps(priv);\r\n}\r\nif (priv->btmrvl_dev.hscmd) {\r\npriv->btmrvl_dev.hscmd = 0;\r\nif (priv->btmrvl_dev.hsmode) {\r\nret = btmrvl_enable_hs(priv);\r\n} else {\r\nret = priv->hw_wakeup_firmware(priv);\r\npriv->adapter->hs_state = HS_DEACTIVATED;\r\nBT_DBG("BT: HS DEACTIVATED due to host activity!");\r\n}\r\n}\r\nreturn ret;\r\n}\r\nvoid btmrvl_firmware_dump(struct btmrvl_private *priv)\r\n{\r\nif (priv->firmware_dump)\r\npriv->firmware_dump(priv);\r\n}\r\nstatic int btmrvl_tx_pkt(struct btmrvl_private *priv, struct sk_buff *skb)\r\n{\r\nint ret = 0;\r\nif (!skb || !skb->data)\r\nreturn -EINVAL;\r\nif (!skb->len || ((skb->len + BTM_HEADER_LEN) > BTM_UPLD_SIZE)) {\r\nBT_ERR("Tx Error: Bad skb length %d : %d",\r\nskb->len, BTM_UPLD_SIZE);\r\nreturn -EINVAL;\r\n}\r\nskb_push(skb, BTM_HEADER_LEN);\r\nskb->data[0] = (skb->len & 0x0000ff);\r\nskb->data[1] = (skb->len & 0x00ff00) >> 8;\r\nskb->data[2] = (skb->len & 0xff0000) >> 16;\r\nskb->data[3] = hci_skb_pkt_type(skb);\r\nif (priv->hw_host_to_card)\r\nret = priv->hw_host_to_card(priv, skb->data, skb->len);\r\nreturn ret;\r\n}\r\nstatic void btmrvl_init_adapter(struct btmrvl_private *priv)\r\n{\r\nint buf_size;\r\nskb_queue_head_init(&priv->adapter->tx_queue);\r\npriv->adapter->ps_state = PS_AWAKE;\r\nbuf_size = ALIGN_SZ(SDIO_BLOCK_SIZE, BTSDIO_DMA_ALIGN);\r\npriv->adapter->hw_regs_buf = kzalloc(buf_size, GFP_KERNEL);\r\nif (!priv->adapter->hw_regs_buf) {\r\npriv->adapter->hw_regs = NULL;\r\nBT_ERR("Unable to allocate buffer for hw_regs.");\r\n} else {\r\npriv->adapter->hw_regs =\r\n(u8 *)ALIGN_ADDR(priv->adapter->hw_regs_buf,\r\nBTSDIO_DMA_ALIGN);\r\nBT_DBG("hw_regs_buf=%p hw_regs=%p",\r\npriv->adapter->hw_regs_buf, priv->adapter->hw_regs);\r\n}\r\ninit_waitqueue_head(&priv->adapter->cmd_wait_q);\r\ninit_waitqueue_head(&priv->adapter->event_hs_wait_q);\r\n}\r\nstatic void btmrvl_free_adapter(struct btmrvl_private *priv)\r\n{\r\nskb_queue_purge(&priv->adapter->tx_queue);\r\nkfree(priv->adapter->hw_regs_buf);\r\nkfree(priv->adapter);\r\npriv->adapter = NULL;\r\n}\r\nstatic int btmrvl_send_frame(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct btmrvl_private *priv = hci_get_drvdata(hdev);\r\nBT_DBG("type=%d, len=%d", hci_skb_pkt_type(skb), skb->len);\r\nif (priv->adapter->is_suspending || priv->adapter->is_suspended) {\r\nBT_ERR("%s: Device is suspending or suspended", __func__);\r\nreturn -EBUSY;\r\n}\r\nswitch (hci_skb_pkt_type(skb)) {\r\ncase HCI_COMMAND_PKT:\r\nhdev->stat.cmd_tx++;\r\nbreak;\r\ncase HCI_ACLDATA_PKT:\r\nhdev->stat.acl_tx++;\r\nbreak;\r\ncase HCI_SCODATA_PKT:\r\nhdev->stat.sco_tx++;\r\nbreak;\r\n}\r\nskb_queue_tail(&priv->adapter->tx_queue, skb);\r\nif (!priv->adapter->is_suspended)\r\nwake_up_interruptible(&priv->main_thread.wait_q);\r\nreturn 0;\r\n}\r\nstatic int btmrvl_flush(struct hci_dev *hdev)\r\n{\r\nstruct btmrvl_private *priv = hci_get_drvdata(hdev);\r\nskb_queue_purge(&priv->adapter->tx_queue);\r\nreturn 0;\r\n}\r\nstatic int btmrvl_close(struct hci_dev *hdev)\r\n{\r\nstruct btmrvl_private *priv = hci_get_drvdata(hdev);\r\nskb_queue_purge(&priv->adapter->tx_queue);\r\nreturn 0;\r\n}\r\nstatic int btmrvl_open(struct hci_dev *hdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int btmrvl_download_cal_data(struct btmrvl_private *priv,\r\nu8 *data, int len)\r\n{\r\nint ret;\r\ndata[0] = 0x00;\r\ndata[1] = 0x00;\r\ndata[2] = 0x00;\r\ndata[3] = len;\r\nprint_hex_dump_bytes("Calibration data: ",\r\nDUMP_PREFIX_OFFSET, data, BT_CAL_HDR_LEN + len);\r\nret = btmrvl_send_sync_cmd(priv, BT_CMD_LOAD_CONFIG_DATA, data,\r\nBT_CAL_HDR_LEN + len);\r\nif (ret)\r\nBT_ERR("Failed to download calibration data");\r\nreturn 0;\r\n}\r\nstatic int btmrvl_check_device_tree(struct btmrvl_private *priv)\r\n{\r\nstruct device_node *dt_node;\r\nstruct btmrvl_sdio_card *card = priv->btmrvl_dev.card;\r\nu8 cal_data[BT_CAL_HDR_LEN + BT_CAL_DATA_SIZE];\r\nint ret = 0;\r\nu16 gpio, gap;\r\nif (card->plt_of_node) {\r\ndt_node = card->plt_of_node;\r\nret = of_property_read_u16(dt_node, "marvell,wakeup-pin",\r\n&gpio);\r\nif (ret)\r\ngpio = (priv->btmrvl_dev.gpio_gap & 0xff00) >> 8;\r\nret = of_property_read_u16(dt_node, "marvell,wakeup-gap-ms",\r\n&gap);\r\nif (ret)\r\ngap = (u8)(priv->btmrvl_dev.gpio_gap & 0x00ff);\r\npriv->btmrvl_dev.gpio_gap = (gpio << 8) + gap;\r\nret = of_property_read_u8_array(dt_node, "marvell,cal-data",\r\ncal_data + BT_CAL_HDR_LEN,\r\nBT_CAL_DATA_SIZE);\r\nif (ret)\r\nreturn ret;\r\nBT_DBG("Use cal data from device tree");\r\nret = btmrvl_download_cal_data(priv, cal_data,\r\nBT_CAL_DATA_SIZE);\r\nif (ret)\r\nBT_ERR("Fail to download calibrate data");\r\n}\r\nreturn ret;\r\n}\r\nstatic int btmrvl_setup(struct hci_dev *hdev)\r\n{\r\nstruct btmrvl_private *priv = hci_get_drvdata(hdev);\r\nint ret;\r\nret = btmrvl_send_module_cfg_cmd(priv, MODULE_BRINGUP_REQ);\r\nif (ret)\r\nreturn ret;\r\npriv->btmrvl_dev.gpio_gap = 0xfffe;\r\nbtmrvl_check_device_tree(priv);\r\nbtmrvl_enable_sco_routing_to_host(priv);\r\nbtmrvl_pscan_window_reporting(priv, 0x01);\r\npriv->btmrvl_dev.psmode = 1;\r\nbtmrvl_enable_ps(priv);\r\nbtmrvl_send_hscfg_cmd(priv);\r\nreturn 0;\r\n}\r\nstatic int btmrvl_set_bdaddr(struct hci_dev *hdev, const bdaddr_t *bdaddr)\r\n{\r\nstruct sk_buff *skb;\r\nlong ret;\r\nu8 buf[8];\r\nbuf[0] = MRVL_VENDOR_PKT;\r\nbuf[1] = sizeof(bdaddr_t);\r\nmemcpy(buf + 2, bdaddr, sizeof(bdaddr_t));\r\nskb = __hci_cmd_sync(hdev, BT_CMD_SET_BDADDR, sizeof(buf), buf,\r\nHCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nret = PTR_ERR(skb);\r\nBT_ERR("%s: changing btmrvl device address failed (%ld)",\r\nhdev->name, ret);\r\nreturn ret;\r\n}\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int btmrvl_service_main_thread(void *data)\r\n{\r\nstruct btmrvl_thread *thread = data;\r\nstruct btmrvl_private *priv = thread->priv;\r\nstruct btmrvl_adapter *adapter = priv->adapter;\r\nwait_queue_t wait;\r\nstruct sk_buff *skb;\r\nulong flags;\r\ninit_waitqueue_entry(&wait, current);\r\nfor (;;) {\r\nadd_wait_queue(&thread->wait_q, &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (kthread_should_stop() || priv->surprise_removed) {\r\nBT_DBG("main_thread: break from main thread");\r\nbreak;\r\n}\r\nif (adapter->wakeup_tries ||\r\n((!adapter->int_count) &&\r\n(!priv->btmrvl_dev.tx_dnld_rdy ||\r\nskb_queue_empty(&adapter->tx_queue)))) {\r\nBT_DBG("main_thread is sleeping...");\r\nschedule();\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&thread->wait_q, &wait);\r\nBT_DBG("main_thread woke up");\r\nif (kthread_should_stop() || priv->surprise_removed) {\r\nBT_DBG("main_thread: break from main thread");\r\nbreak;\r\n}\r\nspin_lock_irqsave(&priv->driver_lock, flags);\r\nif (adapter->int_count) {\r\nadapter->int_count = 0;\r\nspin_unlock_irqrestore(&priv->driver_lock, flags);\r\npriv->hw_process_int_status(priv);\r\n} else if (adapter->ps_state == PS_SLEEP &&\r\n!skb_queue_empty(&adapter->tx_queue)) {\r\nspin_unlock_irqrestore(&priv->driver_lock, flags);\r\nadapter->wakeup_tries++;\r\npriv->hw_wakeup_firmware(priv);\r\ncontinue;\r\n} else {\r\nspin_unlock_irqrestore(&priv->driver_lock, flags);\r\n}\r\nif (adapter->ps_state == PS_SLEEP)\r\ncontinue;\r\nif (!priv->btmrvl_dev.tx_dnld_rdy ||\r\npriv->adapter->is_suspended)\r\ncontinue;\r\nskb = skb_dequeue(&adapter->tx_queue);\r\nif (skb) {\r\nif (btmrvl_tx_pkt(priv, skb))\r\npriv->btmrvl_dev.hcidev->stat.err_tx++;\r\nelse\r\npriv->btmrvl_dev.hcidev->stat.byte_tx += skb->len;\r\nkfree_skb(skb);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint btmrvl_register_hdev(struct btmrvl_private *priv)\r\n{\r\nstruct hci_dev *hdev = NULL;\r\nint ret;\r\nhdev = hci_alloc_dev();\r\nif (!hdev) {\r\nBT_ERR("Can not allocate HCI device");\r\ngoto err_hdev;\r\n}\r\npriv->btmrvl_dev.hcidev = hdev;\r\nhci_set_drvdata(hdev, priv);\r\nhdev->bus = HCI_SDIO;\r\nhdev->open = btmrvl_open;\r\nhdev->close = btmrvl_close;\r\nhdev->flush = btmrvl_flush;\r\nhdev->send = btmrvl_send_frame;\r\nhdev->setup = btmrvl_setup;\r\nhdev->set_bdaddr = btmrvl_set_bdaddr;\r\nhdev->dev_type = priv->btmrvl_dev.dev_type;\r\nret = hci_register_dev(hdev);\r\nif (ret < 0) {\r\nBT_ERR("Can not register HCI device");\r\ngoto err_hci_register_dev;\r\n}\r\n#ifdef CONFIG_DEBUG_FS\r\nbtmrvl_debugfs_init(hdev);\r\n#endif\r\nreturn 0;\r\nerr_hci_register_dev:\r\nhci_free_dev(hdev);\r\nerr_hdev:\r\nkthread_stop(priv->main_thread.task);\r\nbtmrvl_free_adapter(priv);\r\nkfree(priv);\r\nreturn -ENOMEM;\r\n}\r\nstruct btmrvl_private *btmrvl_add_card(void *card)\r\n{\r\nstruct btmrvl_private *priv;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\nBT_ERR("Can not allocate priv");\r\ngoto err_priv;\r\n}\r\npriv->adapter = kzalloc(sizeof(*priv->adapter), GFP_KERNEL);\r\nif (!priv->adapter) {\r\nBT_ERR("Allocate buffer for btmrvl_adapter failed!");\r\ngoto err_adapter;\r\n}\r\nbtmrvl_init_adapter(priv);\r\nBT_DBG("Starting kthread...");\r\npriv->main_thread.priv = priv;\r\nspin_lock_init(&priv->driver_lock);\r\ninit_waitqueue_head(&priv->main_thread.wait_q);\r\npriv->main_thread.task = kthread_run(btmrvl_service_main_thread,\r\n&priv->main_thread, "btmrvl_main_service");\r\nif (IS_ERR(priv->main_thread.task))\r\ngoto err_thread;\r\npriv->btmrvl_dev.card = card;\r\npriv->btmrvl_dev.tx_dnld_rdy = true;\r\nreturn priv;\r\nerr_thread:\r\nbtmrvl_free_adapter(priv);\r\nerr_adapter:\r\nkfree(priv);\r\nerr_priv:\r\nreturn NULL;\r\n}\r\nint btmrvl_remove_card(struct btmrvl_private *priv)\r\n{\r\nstruct hci_dev *hdev;\r\nhdev = priv->btmrvl_dev.hcidev;\r\nwake_up_interruptible(&priv->adapter->cmd_wait_q);\r\nwake_up_interruptible(&priv->adapter->event_hs_wait_q);\r\nkthread_stop(priv->main_thread.task);\r\n#ifdef CONFIG_DEBUG_FS\r\nbtmrvl_debugfs_remove(hdev);\r\n#endif\r\nhci_unregister_dev(hdev);\r\nhci_free_dev(hdev);\r\npriv->btmrvl_dev.hcidev = NULL;\r\nbtmrvl_free_adapter(priv);\r\nkfree(priv);\r\nreturn 0;\r\n}
