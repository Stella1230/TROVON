static int adc_ts_measure(struct iio_channel *channel,\r\nstruct gpio_desc *plate_p, struct gpio_desc *plate_m)\r\n{\r\nint i, value = 0, val = 0;\r\nint error;\r\ngpiod_set_value(plate_p, 1);\r\ngpiod_set_value(plate_m, 1);\r\nusleep_range(COLI_TOUCH_MIN_DELAY_US, COLI_TOUCH_MAX_DELAY_US);\r\nfor (i = 0; i < COLI_TOUCH_NO_OF_AVGS; i++) {\r\nerror = iio_read_channel_raw(channel, &val);\r\nif (error < 0) {\r\nvalue = error;\r\ngoto error_iio_read;\r\n}\r\nvalue += val;\r\n}\r\nvalue /= COLI_TOUCH_NO_OF_AVGS;\r\nerror_iio_read:\r\ngpiod_set_value(plate_p, 0);\r\ngpiod_set_value(plate_m, 0);\r\nreturn value;\r\n}\r\nstatic void vf50_ts_enable_touch_detection(struct vf50_touch_device *vf50_ts)\r\n{\r\ngpiod_set_value(vf50_ts->gpio_ym, 1);\r\npinctrl_pm_select_idle_state(&vf50_ts->pdev->dev);\r\nusleep_range(COLI_PULLUP_MIN_DELAY_US, COLI_PULLUP_MAX_DELAY_US);\r\n}\r\nstatic irqreturn_t vf50_ts_irq_bh(int irq, void *private)\r\n{\r\nstruct vf50_touch_device *vf50_ts = private;\r\nstruct device *dev = &vf50_ts->pdev->dev;\r\nint val_x, val_y, val_z1, val_z2, val_p = 0;\r\nbool discard_val_on_start = true;\r\ngpiod_set_value(vf50_ts->gpio_ym, 0);\r\npinctrl_pm_select_default_state(dev);\r\nwhile (!vf50_ts->stop_touchscreen) {\r\nval_x = adc_ts_measure(&vf50_ts->channels[0],\r\nvf50_ts->gpio_xp, vf50_ts->gpio_xm);\r\nif (val_x < 0)\r\nbreak;\r\nval_y = adc_ts_measure(&vf50_ts->channels[1],\r\nvf50_ts->gpio_yp, vf50_ts->gpio_ym);\r\nif (val_y < 0)\r\nbreak;\r\nval_z1 = adc_ts_measure(&vf50_ts->channels[2],\r\nvf50_ts->gpio_yp, vf50_ts->gpio_xm);\r\nif (val_z1 < 0)\r\nbreak;\r\nval_z2 = adc_ts_measure(&vf50_ts->channels[3],\r\nvf50_ts->gpio_yp, vf50_ts->gpio_xm);\r\nif (val_z2 < 0)\r\nbreak;\r\nif (val_z1 > 64 && val_x > 64) {\r\nint r_x = (1000 * val_x) / VF_ADC_MAX;\r\nval_p = (r_x * val_z2) / val_z1 - r_x;\r\n} else {\r\nval_p = 2000;\r\n}\r\nval_p = 2000 - val_p;\r\ndev_dbg(dev,\r\n"Measured values: x: %d, y: %d, z1: %d, z2: %d, p: %d\n",\r\nval_x, val_y, val_z1, val_z2, val_p);\r\nif (val_p < vf50_ts->min_pressure || val_p > 2000)\r\nbreak;\r\nif (discard_val_on_start) {\r\ndiscard_val_on_start = false;\r\n} else {\r\ninput_report_abs(vf50_ts->ts_input,\r\nABS_X, VF_ADC_MAX - val_x);\r\ninput_report_abs(vf50_ts->ts_input,\r\nABS_Y, VF_ADC_MAX - val_y);\r\ninput_report_abs(vf50_ts->ts_input,\r\nABS_PRESSURE, val_p);\r\ninput_report_key(vf50_ts->ts_input, BTN_TOUCH, 1);\r\ninput_sync(vf50_ts->ts_input);\r\n}\r\nusleep_range(COLI_PULLUP_MIN_DELAY_US,\r\nCOLI_PULLUP_MAX_DELAY_US);\r\n}\r\ninput_report_abs(vf50_ts->ts_input, ABS_PRESSURE, 0);\r\ninput_report_key(vf50_ts->ts_input, BTN_TOUCH, 0);\r\ninput_sync(vf50_ts->ts_input);\r\nvf50_ts_enable_touch_detection(vf50_ts);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int vf50_ts_open(struct input_dev *dev_input)\r\n{\r\nstruct vf50_touch_device *touchdev = input_get_drvdata(dev_input);\r\nstruct device *dev = &touchdev->pdev->dev;\r\ndev_dbg(dev, "Input device %s opened, starting touch detection\n",\r\ndev_input->name);\r\ntouchdev->stop_touchscreen = false;\r\nvf50_ts_enable_touch_detection(touchdev);\r\nreturn 0;\r\n}\r\nstatic void vf50_ts_close(struct input_dev *dev_input)\r\n{\r\nstruct vf50_touch_device *touchdev = input_get_drvdata(dev_input);\r\nstruct device *dev = &touchdev->pdev->dev;\r\ntouchdev->stop_touchscreen = true;\r\nmb();\r\nsynchronize_irq(touchdev->pen_irq);\r\ngpiod_set_value(touchdev->gpio_ym, 0);\r\npinctrl_pm_select_default_state(dev);\r\ndev_dbg(dev, "Input device %s closed, disable touch detection\n",\r\ndev_input->name);\r\n}\r\nstatic int vf50_ts_get_gpiod(struct device *dev, struct gpio_desc **gpio_d,\r\nconst char *con_id, enum gpiod_flags flags)\r\n{\r\nint error;\r\n*gpio_d = devm_gpiod_get(dev, con_id, flags);\r\nif (IS_ERR(*gpio_d)) {\r\nerror = PTR_ERR(*gpio_d);\r\ndev_err(dev, "Could not get gpio_%s %d\n", con_id, error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void vf50_ts_channel_release(void *data)\r\n{\r\nstruct iio_channel *channels = data;\r\niio_channel_release_all(channels);\r\n}\r\nstatic int vf50_ts_probe(struct platform_device *pdev)\r\n{\r\nstruct input_dev *input;\r\nstruct iio_channel *channels;\r\nstruct device *dev = &pdev->dev;\r\nstruct vf50_touch_device *touchdev;\r\nint num_adc_channels;\r\nint error;\r\nchannels = iio_channel_get_all(dev);\r\nif (IS_ERR(channels))\r\nreturn PTR_ERR(channels);\r\nerror = devm_add_action(dev, vf50_ts_channel_release, channels);\r\nif (error) {\r\niio_channel_release_all(channels);\r\ndev_err(dev, "Failed to register iio channel release action");\r\nreturn error;\r\n}\r\nnum_adc_channels = 0;\r\nwhile (channels[num_adc_channels].indio_dev)\r\nnum_adc_channels++;\r\nif (num_adc_channels != COLI_TOUCH_REQ_ADC_CHAN) {\r\ndev_err(dev, "Inadequate ADC channels specified\n");\r\nreturn -EINVAL;\r\n}\r\ntouchdev = devm_kzalloc(dev, sizeof(*touchdev), GFP_KERNEL);\r\nif (!touchdev)\r\nreturn -ENOMEM;\r\ntouchdev->pdev = pdev;\r\ntouchdev->channels = channels;\r\nerror = of_property_read_u32(dev->of_node, "vf50-ts-min-pressure",\r\n&touchdev->min_pressure);\r\nif (error)\r\nreturn error;\r\ninput = devm_input_allocate_device(dev);\r\nif (!input) {\r\ndev_err(dev, "Failed to allocate TS input device\n");\r\nreturn -ENOMEM;\r\n}\r\ninput->name = DRIVER_NAME;\r\ninput->id.bustype = BUS_HOST;\r\ninput->dev.parent = dev;\r\ninput->open = vf50_ts_open;\r\ninput->close = vf50_ts_close;\r\ninput_set_capability(input, EV_KEY, BTN_TOUCH);\r\ninput_set_abs_params(input, ABS_X, 0, VF_ADC_MAX, 0, 0);\r\ninput_set_abs_params(input, ABS_Y, 0, VF_ADC_MAX, 0, 0);\r\ninput_set_abs_params(input, ABS_PRESSURE, 0, VF_ADC_MAX, 0, 0);\r\ntouchdev->ts_input = input;\r\ninput_set_drvdata(input, touchdev);\r\nerror = input_register_device(input);\r\nif (error) {\r\ndev_err(dev, "Failed to register input device\n");\r\nreturn error;\r\n}\r\nerror = vf50_ts_get_gpiod(dev, &touchdev->gpio_xp, "xp", GPIOD_OUT_LOW);\r\nif (error)\r\nreturn error;\r\nerror = vf50_ts_get_gpiod(dev, &touchdev->gpio_xm,\r\n"xm", GPIOD_OUT_LOW);\r\nif (error)\r\nreturn error;\r\nerror = vf50_ts_get_gpiod(dev, &touchdev->gpio_yp, "yp", GPIOD_OUT_LOW);\r\nif (error)\r\nreturn error;\r\nerror = vf50_ts_get_gpiod(dev, &touchdev->gpio_ym, "ym", GPIOD_OUT_LOW);\r\nif (error)\r\nreturn error;\r\ntouchdev->pen_irq = platform_get_irq(pdev, 0);\r\nif (touchdev->pen_irq < 0)\r\nreturn touchdev->pen_irq;\r\nerror = devm_request_threaded_irq(dev, touchdev->pen_irq,\r\nNULL, vf50_ts_irq_bh, IRQF_ONESHOT,\r\n"vf50 touch", touchdev);\r\nif (error) {\r\ndev_err(dev, "Failed to request IRQ %d: %d\n",\r\ntouchdev->pen_irq, error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}
