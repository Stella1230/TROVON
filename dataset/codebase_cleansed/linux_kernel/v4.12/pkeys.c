int __execute_only_pkey(struct mm_struct *mm)\r\n{\r\nbool need_to_set_mm_pkey = false;\r\nint execute_only_pkey = mm->context.execute_only_pkey;\r\nint ret;\r\nif (execute_only_pkey == -1) {\r\nexecute_only_pkey = mm_pkey_alloc(mm);\r\nif (execute_only_pkey < 0)\r\nreturn -1;\r\nneed_to_set_mm_pkey = true;\r\n}\r\npreempt_disable();\r\nif (!need_to_set_mm_pkey &&\r\nfpregs_active() &&\r\n!__pkru_allows_read(read_pkru(), execute_only_pkey)) {\r\npreempt_enable();\r\nreturn execute_only_pkey;\r\n}\r\npreempt_enable();\r\nret = arch_set_user_pkey_access(current, execute_only_pkey,\r\nPKEY_DISABLE_ACCESS);\r\nif (ret) {\r\nmm_set_pkey_free(mm, execute_only_pkey);\r\nreturn -1;\r\n}\r\nif (need_to_set_mm_pkey)\r\nmm->context.execute_only_pkey = execute_only_pkey;\r\nreturn execute_only_pkey;\r\n}\r\nstatic inline bool vma_is_pkey_exec_only(struct vm_area_struct *vma)\r\n{\r\nif ((vma->vm_flags & (VM_READ | VM_WRITE | VM_EXEC)) != VM_EXEC)\r\nreturn false;\r\nif (vma_pkey(vma) != vma->vm_mm->context.execute_only_pkey)\r\nreturn false;\r\nreturn true;\r\n}\r\nint __arch_override_mprotect_pkey(struct vm_area_struct *vma, int prot, int pkey)\r\n{\r\nif (pkey != -1)\r\nreturn pkey;\r\nif (vma_is_pkey_exec_only(vma) &&\r\n(prot & (PROT_READ|PROT_WRITE))) {\r\nreturn 0;\r\n}\r\nif (prot == PROT_EXEC) {\r\npkey = execute_only_pkey(vma->vm_mm);\r\nif (pkey > 0)\r\nreturn pkey;\r\n}\r\nreturn vma_pkey(vma);\r\n}\r\nvoid copy_init_pkru_to_fpregs(void)\r\n{\r\nu32 init_pkru_value_snapshot = READ_ONCE(init_pkru_value);\r\nif (!init_pkru_value_snapshot && !read_pkru())\r\nreturn;\r\nwrite_pkru(init_pkru_value_snapshot);\r\n}\r\nstatic ssize_t init_pkru_read_file(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar buf[32];\r\nunsigned int len;\r\nlen = sprintf(buf, "0x%x\n", init_pkru_value);\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\r\n}\r\nstatic ssize_t init_pkru_write_file(struct file *file,\r\nconst char __user *user_buf, size_t count, loff_t *ppos)\r\n{\r\nchar buf[32];\r\nssize_t len;\r\nu32 new_init_pkru;\r\nlen = min(count, sizeof(buf) - 1);\r\nif (copy_from_user(buf, user_buf, len))\r\nreturn -EFAULT;\r\nbuf[len] = '\0';\r\nif (kstrtouint(buf, 0, &new_init_pkru))\r\nreturn -EINVAL;\r\nif (new_init_pkru & (PKRU_AD_BIT|PKRU_WD_BIT))\r\nreturn -EINVAL;\r\nWRITE_ONCE(init_pkru_value, new_init_pkru);\r\nreturn count;\r\n}\r\nstatic int __init create_init_pkru_value(void)\r\n{\r\ndebugfs_create_file("init_pkru", S_IRUSR | S_IWUSR,\r\narch_debugfs_dir, NULL, &fops_init_pkru);\r\nreturn 0;\r\n}\r\nstatic __init int setup_init_pkru(char *opt)\r\n{\r\nu32 new_init_pkru;\r\nif (kstrtouint(opt, 0, &new_init_pkru))\r\nreturn 1;\r\nWRITE_ONCE(init_pkru_value, new_init_pkru);\r\nreturn 1;\r\n}
