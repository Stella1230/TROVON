static int amd_rng_read(struct hwrng *rng, void *buf, size_t max, bool wait)\r\n{\r\nu32 *data = buf;\r\nstruct amd768_priv *priv = (struct amd768_priv *)rng->priv;\r\nsize_t read = 0;\r\nint timeout = max / 4 + 1;\r\nwhile (read < max) {\r\nif (ioread32(priv->iobase + RNGDONE) == 0) {\r\nif (wait) {\r\nusleep_range(128, 196);\r\nif (timeout-- == 0)\r\nreturn read;\r\n} else {\r\nreturn 0;\r\n}\r\n} else {\r\n*data = ioread32(priv->iobase + RNGDATA);\r\ndata++;\r\nread += 4;\r\n}\r\n}\r\nreturn read;\r\n}\r\nstatic int amd_rng_init(struct hwrng *rng)\r\n{\r\nstruct amd768_priv *priv = (struct amd768_priv *)rng->priv;\r\nu8 rnen;\r\npci_read_config_byte(priv->pcidev, 0x40, &rnen);\r\nrnen |= BIT(7);\r\npci_write_config_byte(priv->pcidev, 0x40, rnen);\r\npci_read_config_byte(priv->pcidev, 0x41, &rnen);\r\nrnen |= BIT(7);\r\npci_write_config_byte(priv->pcidev, 0x41, rnen);\r\nreturn 0;\r\n}\r\nstatic void amd_rng_cleanup(struct hwrng *rng)\r\n{\r\nstruct amd768_priv *priv = (struct amd768_priv *)rng->priv;\r\nu8 rnen;\r\npci_read_config_byte(priv->pcidev, 0x40, &rnen);\r\nrnen &= ~BIT(7);\r\npci_write_config_byte(priv->pcidev, 0x40, rnen);\r\n}\r\nstatic int __init mod_init(void)\r\n{\r\nint err = -ENODEV;\r\nstruct pci_dev *pdev = NULL;\r\nconst struct pci_device_id *ent;\r\nu32 pmbase;\r\nstruct amd768_priv *priv;\r\nfor_each_pci_dev(pdev) {\r\nent = pci_match_id(pci_tbl, pdev);\r\nif (ent)\r\ngoto found;\r\n}\r\nreturn -ENODEV;\r\nfound:\r\nerr = pci_read_config_dword(pdev, 0x58, &pmbase);\r\nif (err)\r\nreturn err;\r\npmbase &= 0x0000FF00;\r\nif (pmbase == 0)\r\nreturn -EIO;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nif (!request_region(pmbase + PMBASE_OFFSET, PMBASE_SIZE, DRV_NAME)) {\r\ndev_err(&pdev->dev, DRV_NAME " region 0x%x already in use!\n",\r\npmbase + 0xF0);\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\npriv->iobase = ioport_map(pmbase + PMBASE_OFFSET, PMBASE_SIZE);\r\nif (!priv->iobase) {\r\npr_err(DRV_NAME "Cannot map ioport\n");\r\nerr = -EINVAL;\r\ngoto err_iomap;\r\n}\r\namd_rng.priv = (unsigned long)priv;\r\npriv->pmbase = pmbase;\r\npriv->pcidev = pdev;\r\npr_info(DRV_NAME " detected\n");\r\nerr = hwrng_register(&amd_rng);\r\nif (err) {\r\npr_err(DRV_NAME " registering failed (%d)\n", err);\r\ngoto err_hwrng;\r\n}\r\nreturn 0;\r\nerr_hwrng:\r\nioport_unmap(priv->iobase);\r\nerr_iomap:\r\nrelease_region(pmbase + PMBASE_OFFSET, PMBASE_SIZE);\r\nout:\r\nkfree(priv);\r\nreturn err;\r\n}\r\nstatic void __exit mod_exit(void)\r\n{\r\nstruct amd768_priv *priv;\r\npriv = (struct amd768_priv *)amd_rng.priv;\r\nhwrng_unregister(&amd_rng);\r\nioport_unmap(priv->iobase);\r\nrelease_region(priv->pmbase + PMBASE_OFFSET, PMBASE_SIZE);\r\nkfree(priv);\r\n}
