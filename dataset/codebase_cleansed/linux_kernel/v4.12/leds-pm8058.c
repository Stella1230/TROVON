static void pm8058_led_set(struct led_classdev *cled,\r\nenum led_brightness value)\r\n{\r\nstruct pm8058_led *led;\r\nint ret = 0;\r\nunsigned int mask = 0;\r\nunsigned int val = 0;\r\nled = container_of(cled, struct pm8058_led, cdev);\r\nswitch (led->ledtype) {\r\ncase PM8058_LED_TYPE_COMMON:\r\nmask = PM8058_LED_TYPE_COMMON_MASK;\r\nval = value << PM8058_LED_TYPE_COMMON_SHIFT;\r\nbreak;\r\ncase PM8058_LED_TYPE_KEYPAD:\r\ncase PM8058_LED_TYPE_FLASH:\r\nmask = PM8058_LED_TYPE_KEYPAD_MASK;\r\nval = value << PM8058_LED_TYPE_KEYPAD_SHIFT;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nret = regmap_update_bits(led->map, led->reg, mask, val);\r\nif (ret)\r\npr_err("Failed to set LED brightness\n");\r\n}\r\nstatic enum led_brightness pm8058_led_get(struct led_classdev *cled)\r\n{\r\nstruct pm8058_led *led;\r\nint ret;\r\nunsigned int val;\r\nled = container_of(cled, struct pm8058_led, cdev);\r\nret = regmap_read(led->map, led->reg, &val);\r\nif (ret) {\r\npr_err("Failed to get LED brightness\n");\r\nreturn LED_OFF;\r\n}\r\nswitch (led->ledtype) {\r\ncase PM8058_LED_TYPE_COMMON:\r\nval &= PM8058_LED_TYPE_COMMON_MASK;\r\nval >>= PM8058_LED_TYPE_COMMON_SHIFT;\r\nbreak;\r\ncase PM8058_LED_TYPE_KEYPAD:\r\ncase PM8058_LED_TYPE_FLASH:\r\nval &= PM8058_LED_TYPE_KEYPAD_MASK;\r\nval >>= PM8058_LED_TYPE_KEYPAD_SHIFT;\r\nbreak;\r\ndefault:\r\nval = LED_OFF;\r\nbreak;\r\n}\r\nreturn val;\r\n}\r\nstatic int pm8058_led_probe(struct platform_device *pdev)\r\n{\r\nstruct pm8058_led *led;\r\nstruct device_node *np = pdev->dev.of_node;\r\nint ret;\r\nstruct regmap *map;\r\nconst char *state;\r\nenum led_brightness maxbright;\r\nled = devm_kzalloc(&pdev->dev, sizeof(*led), GFP_KERNEL);\r\nif (!led)\r\nreturn -ENOMEM;\r\nled->ledtype = (u32)of_device_get_match_data(&pdev->dev);\r\nmap = dev_get_regmap(pdev->dev.parent, NULL);\r\nif (!map) {\r\ndev_err(&pdev->dev, "Parent regmap unavailable.\n");\r\nreturn -ENXIO;\r\n}\r\nled->map = map;\r\nret = of_property_read_u32(np, "reg", &led->reg);\r\nif (ret) {\r\ndev_err(&pdev->dev, "no register offset specified\n");\r\nreturn -EINVAL;\r\n}\r\nled->cdev.name = of_get_property(np, "label", NULL) ? : np->name;\r\nled->cdev.default_trigger =\r\nof_get_property(np, "linux,default-trigger", NULL);\r\nled->cdev.brightness_set = pm8058_led_set;\r\nled->cdev.brightness_get = pm8058_led_get;\r\nif (led->ledtype == PM8058_LED_TYPE_COMMON)\r\nmaxbright = 31;\r\nelse\r\nmaxbright = 15;\r\nled->cdev.max_brightness = maxbright;\r\nstate = of_get_property(np, "default-state", NULL);\r\nif (state) {\r\nif (!strcmp(state, "keep")) {\r\nled->cdev.brightness = pm8058_led_get(&led->cdev);\r\n} else if (!strcmp(state, "on")) {\r\nled->cdev.brightness = maxbright;\r\npm8058_led_set(&led->cdev, maxbright);\r\n} else {\r\nled->cdev.brightness = LED_OFF;\r\npm8058_led_set(&led->cdev, LED_OFF);\r\n}\r\n}\r\nif (led->ledtype == PM8058_LED_TYPE_KEYPAD ||\r\nled->ledtype == PM8058_LED_TYPE_FLASH)\r\nled->cdev.flags = LED_CORE_SUSPENDRESUME;\r\nret = devm_led_classdev_register(&pdev->dev, &led->cdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to register led \"%s\"\n",\r\nled->cdev.name);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
