static inline struct mcryptd_hash_request_ctx\r\n*cast_hash_to_mcryptd_ctx(struct sha512_hash_ctx *hash_ctx)\r\n{\r\nstruct ahash_request *areq;\r\nareq = container_of((void *) hash_ctx, struct ahash_request, __ctx);\r\nreturn container_of(areq, struct mcryptd_hash_request_ctx, areq);\r\n}\r\nstatic inline struct ahash_request\r\n*cast_mcryptd_ctx_to_req(struct mcryptd_hash_request_ctx *ctx)\r\n{\r\nreturn container_of((void *) ctx, struct ahash_request, __ctx);\r\n}\r\nstatic void req_ctx_init(struct mcryptd_hash_request_ctx *rctx,\r\nstruct ahash_request *areq)\r\n{\r\nrctx->flag = HASH_UPDATE;\r\n}\r\ninline void sha512_init_digest(uint64_t *digest)\r\n{\r\nstatic const uint64_t initial_digest[SHA512_DIGEST_LENGTH] = {\r\nSHA512_H0, SHA512_H1, SHA512_H2,\r\nSHA512_H3, SHA512_H4, SHA512_H5,\r\nSHA512_H6, SHA512_H7 };\r\nmemcpy(digest, initial_digest, sizeof(initial_digest));\r\n}\r\ninline uint32_t sha512_pad(uint8_t padblock[SHA512_BLOCK_SIZE * 2],\r\nuint64_t total_len)\r\n{\r\nuint32_t i = total_len & (SHA512_BLOCK_SIZE - 1);\r\nmemset(&padblock[i], 0, SHA512_BLOCK_SIZE);\r\npadblock[i] = 0x80;\r\ni += ((SHA512_BLOCK_SIZE - 1) &\r\n(0 - (total_len + SHA512_PADLENGTHFIELD_SIZE + 1)))\r\n+ 1 + SHA512_PADLENGTHFIELD_SIZE;\r\n#if SHA512_PADLENGTHFIELD_SIZE == 16\r\n*((uint64_t *) &padblock[i - 16]) = 0;\r\n#endif\r\n*((uint64_t *) &padblock[i - 8]) = cpu_to_be64(total_len << 3);\r\nreturn i >> SHA512_LOG2_BLOCK_SIZE;\r\n}\r\nstatic struct sha512_hash_ctx *sha512_ctx_mgr_resubmit\r\n(struct sha512_ctx_mgr *mgr, struct sha512_hash_ctx *ctx)\r\n{\r\nwhile (ctx) {\r\nif (ctx->status & HASH_CTX_STS_COMPLETE) {\r\nctx->status = HASH_CTX_STS_COMPLETE;\r\nreturn ctx;\r\n}\r\nif (ctx->partial_block_buffer_length == 0 &&\r\nctx->incoming_buffer_length) {\r\nconst void *buffer = ctx->incoming_buffer;\r\nuint32_t len = ctx->incoming_buffer_length;\r\nuint32_t copy_len;\r\ncopy_len = len & (SHA512_BLOCK_SIZE-1);\r\nif (copy_len) {\r\nlen -= copy_len;\r\nmemcpy(ctx->partial_block_buffer,\r\n((const char *) buffer + len),\r\ncopy_len);\r\nctx->partial_block_buffer_length = copy_len;\r\n}\r\nctx->incoming_buffer_length = 0;\r\nassert((len % SHA512_BLOCK_SIZE) == 0);\r\nlen >>= SHA512_LOG2_BLOCK_SIZE;\r\nif (len) {\r\nctx->job.buffer = (uint8_t *) buffer;\r\nctx->job.len = len;\r\nctx = (struct sha512_hash_ctx *)\r\nsha512_job_mgr_submit(&mgr->mgr,\r\n&ctx->job);\r\ncontinue;\r\n}\r\n}\r\nif (ctx->status & HASH_CTX_STS_LAST) {\r\nuint8_t *buf = ctx->partial_block_buffer;\r\nuint32_t n_extra_blocks =\r\nsha512_pad(buf, ctx->total_length);\r\nctx->status = (HASH_CTX_STS_PROCESSING |\r\nHASH_CTX_STS_COMPLETE);\r\nctx->job.buffer = buf;\r\nctx->job.len = (uint32_t) n_extra_blocks;\r\nctx = (struct sha512_hash_ctx *)\r\nsha512_job_mgr_submit(&mgr->mgr, &ctx->job);\r\ncontinue;\r\n}\r\nif (ctx)\r\nctx->status = HASH_CTX_STS_IDLE;\r\nreturn ctx;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct sha512_hash_ctx\r\n*sha512_ctx_mgr_get_comp_ctx(struct mcryptd_alg_cstate *cstate)\r\n{\r\nstruct sha512_ctx_mgr *mgr;\r\nstruct sha512_hash_ctx *ctx;\r\nunsigned long flags;\r\nmgr = cstate->mgr;\r\nspin_lock_irqsave(&cstate->work_lock, flags);\r\nctx = (struct sha512_hash_ctx *)\r\nsha512_job_mgr_get_comp_job(&mgr->mgr);\r\nctx = sha512_ctx_mgr_resubmit(mgr, ctx);\r\nspin_unlock_irqrestore(&cstate->work_lock, flags);\r\nreturn ctx;\r\n}\r\nstatic void sha512_ctx_mgr_init(struct sha512_ctx_mgr *mgr)\r\n{\r\nsha512_job_mgr_init(&mgr->mgr);\r\n}\r\nstatic struct sha512_hash_ctx\r\n*sha512_ctx_mgr_submit(struct mcryptd_alg_cstate *cstate,\r\nstruct sha512_hash_ctx *ctx,\r\nconst void *buffer,\r\nuint32_t len,\r\nint flags)\r\n{\r\nstruct sha512_ctx_mgr *mgr;\r\nunsigned long irqflags;\r\nmgr = cstate->mgr;\r\nspin_lock_irqsave(&cstate->work_lock, irqflags);\r\nif (flags & (~HASH_ENTIRE)) {\r\nctx->error = HASH_CTX_ERROR_INVALID_FLAGS;\r\nreturn ctx;\r\n}\r\nif (ctx->status & HASH_CTX_STS_PROCESSING) {\r\nctx->error = HASH_CTX_ERROR_ALREADY_PROCESSING;\r\nreturn ctx;\r\n}\r\nif ((ctx->status & HASH_CTX_STS_COMPLETE) && !(flags & HASH_FIRST)) {\r\nctx->error = HASH_CTX_ERROR_ALREADY_COMPLETED;\r\nreturn ctx;\r\n}\r\nif (flags & HASH_FIRST) {\r\nsha512_init_digest(ctx->job.result_digest);\r\nctx->total_length = 0;\r\nctx->partial_block_buffer_length = 0;\r\n}\r\nctx->error = HASH_CTX_ERROR_NONE;\r\nctx->incoming_buffer = buffer;\r\nctx->incoming_buffer_length = len;\r\nctx->status = (flags & HASH_LAST) ?\r\n(HASH_CTX_STS_PROCESSING | HASH_CTX_STS_LAST) :\r\nHASH_CTX_STS_PROCESSING;\r\nctx->total_length += len;\r\nif (ctx->partial_block_buffer_length || len < SHA512_BLOCK_SIZE) {\r\nuint32_t copy_len = SHA512_BLOCK_SIZE -\r\nctx->partial_block_buffer_length;\r\nif (len < copy_len)\r\ncopy_len = len;\r\nif (copy_len) {\r\nmemcpy\r\n(&ctx->partial_block_buffer[ctx->partial_block_buffer_length],\r\nbuffer, copy_len);\r\nctx->partial_block_buffer_length += copy_len;\r\nctx->incoming_buffer = (const void *)\r\n((const char *)buffer + copy_len);\r\nctx->incoming_buffer_length = len - copy_len;\r\n}\r\nassert(ctx->partial_block_buffer_length <= SHA512_BLOCK_SIZE);\r\nif (ctx->partial_block_buffer_length >= SHA512_BLOCK_SIZE) {\r\nctx->partial_block_buffer_length = 0;\r\nctx->job.buffer = ctx->partial_block_buffer;\r\nctx->job.len = 1;\r\nctx = (struct sha512_hash_ctx *)\r\nsha512_job_mgr_submit(&mgr->mgr, &ctx->job);\r\n}\r\n}\r\nctx = sha512_ctx_mgr_resubmit(mgr, ctx);\r\nspin_unlock_irqrestore(&cstate->work_lock, irqflags);\r\nreturn ctx;\r\n}\r\nstatic struct sha512_hash_ctx *sha512_ctx_mgr_flush(struct mcryptd_alg_cstate *cstate)\r\n{\r\nstruct sha512_ctx_mgr *mgr;\r\nstruct sha512_hash_ctx *ctx;\r\nunsigned long flags;\r\nmgr = cstate->mgr;\r\nspin_lock_irqsave(&cstate->work_lock, flags);\r\nwhile (1) {\r\nctx = (struct sha512_hash_ctx *)\r\nsha512_job_mgr_flush(&mgr->mgr);\r\nif (!ctx)\r\nbreak;\r\nctx = sha512_ctx_mgr_resubmit(mgr, ctx);\r\nif (ctx)\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&cstate->work_lock, flags);\r\nreturn ctx;\r\n}\r\nstatic int sha512_mb_init(struct ahash_request *areq)\r\n{\r\nstruct sha512_hash_ctx *sctx = ahash_request_ctx(areq);\r\nhash_ctx_init(sctx);\r\nsctx->job.result_digest[0] = SHA512_H0;\r\nsctx->job.result_digest[1] = SHA512_H1;\r\nsctx->job.result_digest[2] = SHA512_H2;\r\nsctx->job.result_digest[3] = SHA512_H3;\r\nsctx->job.result_digest[4] = SHA512_H4;\r\nsctx->job.result_digest[5] = SHA512_H5;\r\nsctx->job.result_digest[6] = SHA512_H6;\r\nsctx->job.result_digest[7] = SHA512_H7;\r\nsctx->total_length = 0;\r\nsctx->partial_block_buffer_length = 0;\r\nsctx->status = HASH_CTX_STS_IDLE;\r\nreturn 0;\r\n}\r\nstatic int sha512_mb_set_results(struct mcryptd_hash_request_ctx *rctx)\r\n{\r\nint i;\r\nstruct sha512_hash_ctx *sctx = ahash_request_ctx(&rctx->areq);\r\n__be64 *dst = (__be64 *) rctx->out;\r\nfor (i = 0; i < 8; ++i)\r\ndst[i] = cpu_to_be64(sctx->job.result_digest[i]);\r\nreturn 0;\r\n}\r\nstatic int sha_finish_walk(struct mcryptd_hash_request_ctx **ret_rctx,\r\nstruct mcryptd_alg_cstate *cstate, bool flush)\r\n{\r\nint flag = HASH_UPDATE;\r\nint nbytes, err = 0;\r\nstruct mcryptd_hash_request_ctx *rctx = *ret_rctx;\r\nstruct sha512_hash_ctx *sha_ctx;\r\nwhile (!(rctx->flag & HASH_DONE)) {\r\nnbytes = crypto_ahash_walk_done(&rctx->walk, 0);\r\nif (nbytes < 0) {\r\nerr = nbytes;\r\ngoto out;\r\n}\r\nif (crypto_ahash_walk_last(&rctx->walk)) {\r\nrctx->flag |= HASH_DONE;\r\nif (rctx->flag & HASH_FINAL)\r\nflag |= HASH_LAST;\r\n}\r\nsha_ctx = (struct sha512_hash_ctx *)\r\nahash_request_ctx(&rctx->areq);\r\nkernel_fpu_begin();\r\nsha_ctx = sha512_ctx_mgr_submit(cstate, sha_ctx,\r\nrctx->walk.data, nbytes, flag);\r\nif (!sha_ctx) {\r\nif (flush)\r\nsha_ctx = sha512_ctx_mgr_flush(cstate);\r\n}\r\nkernel_fpu_end();\r\nif (sha_ctx)\r\nrctx = cast_hash_to_mcryptd_ctx(sha_ctx);\r\nelse {\r\nrctx = NULL;\r\ngoto out;\r\n}\r\n}\r\nif (rctx->flag & HASH_FINAL)\r\nsha512_mb_set_results(rctx);\r\nout:\r\n*ret_rctx = rctx;\r\nreturn err;\r\n}\r\nstatic int sha_complete_job(struct mcryptd_hash_request_ctx *rctx,\r\nstruct mcryptd_alg_cstate *cstate,\r\nint err)\r\n{\r\nstruct ahash_request *req = cast_mcryptd_ctx_to_req(rctx);\r\nstruct sha512_hash_ctx *sha_ctx;\r\nstruct mcryptd_hash_request_ctx *req_ctx;\r\nint ret;\r\nunsigned long flags;\r\nspin_lock_irqsave(&cstate->work_lock, flags);\r\nlist_del(&rctx->waiter);\r\nspin_unlock_irqrestore(&cstate->work_lock, flags);\r\nif (irqs_disabled())\r\nrctx->complete(&req->base, err);\r\nelse {\r\nlocal_bh_disable();\r\nrctx->complete(&req->base, err);\r\nlocal_bh_enable();\r\n}\r\nsha_ctx = sha512_ctx_mgr_get_comp_ctx(cstate);\r\nwhile (sha_ctx) {\r\nreq_ctx = cast_hash_to_mcryptd_ctx(sha_ctx);\r\nret = sha_finish_walk(&req_ctx, cstate, false);\r\nif (req_ctx) {\r\nspin_lock_irqsave(&cstate->work_lock, flags);\r\nlist_del(&req_ctx->waiter);\r\nspin_unlock_irqrestore(&cstate->work_lock, flags);\r\nreq = cast_mcryptd_ctx_to_req(req_ctx);\r\nif (irqs_disabled())\r\nreq_ctx->complete(&req->base, ret);\r\nelse {\r\nlocal_bh_disable();\r\nreq_ctx->complete(&req->base, ret);\r\nlocal_bh_enable();\r\n}\r\n}\r\nsha_ctx = sha512_ctx_mgr_get_comp_ctx(cstate);\r\n}\r\nreturn 0;\r\n}\r\nstatic void sha512_mb_add_list(struct mcryptd_hash_request_ctx *rctx,\r\nstruct mcryptd_alg_cstate *cstate)\r\n{\r\nunsigned long next_flush;\r\nunsigned long delay = usecs_to_jiffies(FLUSH_INTERVAL);\r\nunsigned long flags;\r\nrctx->tag.arrival = jiffies;\r\nrctx->tag.seq_num = cstate->next_seq_num++;\r\nnext_flush = rctx->tag.arrival + delay;\r\nrctx->tag.expire = next_flush;\r\nspin_lock_irqsave(&cstate->work_lock, flags);\r\nlist_add_tail(&rctx->waiter, &cstate->work_list);\r\nspin_unlock_irqrestore(&cstate->work_lock, flags);\r\nmcryptd_arm_flusher(cstate, delay);\r\n}\r\nstatic int sha512_mb_update(struct ahash_request *areq)\r\n{\r\nstruct mcryptd_hash_request_ctx *rctx =\r\ncontainer_of(areq, struct mcryptd_hash_request_ctx,\r\nareq);\r\nstruct mcryptd_alg_cstate *cstate =\r\nthis_cpu_ptr(sha512_mb_alg_state.alg_cstate);\r\nstruct ahash_request *req = cast_mcryptd_ctx_to_req(rctx);\r\nstruct sha512_hash_ctx *sha_ctx;\r\nint ret = 0, nbytes;\r\nif (rctx->tag.cpu != smp_processor_id()) {\r\npr_err("mcryptd error: cpu clash\n");\r\ngoto done;\r\n}\r\nreq_ctx_init(rctx, areq);\r\nnbytes = crypto_ahash_walk_first(req, &rctx->walk);\r\nif (nbytes < 0) {\r\nret = nbytes;\r\ngoto done;\r\n}\r\nif (crypto_ahash_walk_last(&rctx->walk))\r\nrctx->flag |= HASH_DONE;\r\nsha_ctx = (struct sha512_hash_ctx *) ahash_request_ctx(areq);\r\nsha512_mb_add_list(rctx, cstate);\r\nkernel_fpu_begin();\r\nsha_ctx = sha512_ctx_mgr_submit(cstate, sha_ctx, rctx->walk.data,\r\nnbytes, HASH_UPDATE);\r\nkernel_fpu_end();\r\nif (!sha_ctx)\r\nreturn -EINPROGRESS;\r\nif (sha_ctx->error) {\r\nret = sha_ctx->error;\r\nrctx = cast_hash_to_mcryptd_ctx(sha_ctx);\r\ngoto done;\r\n}\r\nrctx = cast_hash_to_mcryptd_ctx(sha_ctx);\r\nret = sha_finish_walk(&rctx, cstate, false);\r\nif (!rctx)\r\nreturn -EINPROGRESS;\r\ndone:\r\nsha_complete_job(rctx, cstate, ret);\r\nreturn ret;\r\n}\r\nstatic int sha512_mb_finup(struct ahash_request *areq)\r\n{\r\nstruct mcryptd_hash_request_ctx *rctx =\r\ncontainer_of(areq, struct mcryptd_hash_request_ctx,\r\nareq);\r\nstruct mcryptd_alg_cstate *cstate =\r\nthis_cpu_ptr(sha512_mb_alg_state.alg_cstate);\r\nstruct ahash_request *req = cast_mcryptd_ctx_to_req(rctx);\r\nstruct sha512_hash_ctx *sha_ctx;\r\nint ret = 0, flag = HASH_UPDATE, nbytes;\r\nif (rctx->tag.cpu != smp_processor_id()) {\r\npr_err("mcryptd error: cpu clash\n");\r\ngoto done;\r\n}\r\nreq_ctx_init(rctx, areq);\r\nnbytes = crypto_ahash_walk_first(req, &rctx->walk);\r\nif (nbytes < 0) {\r\nret = nbytes;\r\ngoto done;\r\n}\r\nif (crypto_ahash_walk_last(&rctx->walk)) {\r\nrctx->flag |= HASH_DONE;\r\nflag = HASH_LAST;\r\n}\r\nrctx->flag |= HASH_FINAL;\r\nsha_ctx = (struct sha512_hash_ctx *) ahash_request_ctx(areq);\r\nsha512_mb_add_list(rctx, cstate);\r\nkernel_fpu_begin();\r\nsha_ctx = sha512_ctx_mgr_submit(cstate, sha_ctx, rctx->walk.data,\r\nnbytes, flag);\r\nkernel_fpu_end();\r\nif (!sha_ctx)\r\nreturn -EINPROGRESS;\r\nif (sha_ctx->error) {\r\nret = sha_ctx->error;\r\ngoto done;\r\n}\r\nrctx = cast_hash_to_mcryptd_ctx(sha_ctx);\r\nret = sha_finish_walk(&rctx, cstate, false);\r\nif (!rctx)\r\nreturn -EINPROGRESS;\r\ndone:\r\nsha_complete_job(rctx, cstate, ret);\r\nreturn ret;\r\n}\r\nstatic int sha512_mb_final(struct ahash_request *areq)\r\n{\r\nstruct mcryptd_hash_request_ctx *rctx =\r\ncontainer_of(areq, struct mcryptd_hash_request_ctx,\r\nareq);\r\nstruct mcryptd_alg_cstate *cstate =\r\nthis_cpu_ptr(sha512_mb_alg_state.alg_cstate);\r\nstruct sha512_hash_ctx *sha_ctx;\r\nint ret = 0;\r\nu8 data;\r\nif (rctx->tag.cpu != smp_processor_id()) {\r\npr_err("mcryptd error: cpu clash\n");\r\ngoto done;\r\n}\r\nreq_ctx_init(rctx, areq);\r\nrctx->flag |= HASH_DONE | HASH_FINAL;\r\nsha_ctx = (struct sha512_hash_ctx *) ahash_request_ctx(areq);\r\nsha512_mb_add_list(rctx, cstate);\r\nkernel_fpu_begin();\r\nsha_ctx = sha512_ctx_mgr_submit(cstate, sha_ctx, &data, 0, HASH_LAST);\r\nkernel_fpu_end();\r\nif (!sha_ctx)\r\nreturn -EINPROGRESS;\r\nif (sha_ctx->error) {\r\nret = sha_ctx->error;\r\nrctx = cast_hash_to_mcryptd_ctx(sha_ctx);\r\ngoto done;\r\n}\r\nrctx = cast_hash_to_mcryptd_ctx(sha_ctx);\r\nret = sha_finish_walk(&rctx, cstate, false);\r\nif (!rctx)\r\nreturn -EINPROGRESS;\r\ndone:\r\nsha_complete_job(rctx, cstate, ret);\r\nreturn ret;\r\n}\r\nstatic int sha512_mb_export(struct ahash_request *areq, void *out)\r\n{\r\nstruct sha512_hash_ctx *sctx = ahash_request_ctx(areq);\r\nmemcpy(out, sctx, sizeof(*sctx));\r\nreturn 0;\r\n}\r\nstatic int sha512_mb_import(struct ahash_request *areq, const void *in)\r\n{\r\nstruct sha512_hash_ctx *sctx = ahash_request_ctx(areq);\r\nmemcpy(sctx, in, sizeof(*sctx));\r\nreturn 0;\r\n}\r\nstatic int sha512_mb_async_init_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct mcryptd_ahash *mcryptd_tfm;\r\nstruct sha512_mb_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct mcryptd_hash_ctx *mctx;\r\nmcryptd_tfm = mcryptd_alloc_ahash("__intel_sha512-mb",\r\nCRYPTO_ALG_INTERNAL,\r\nCRYPTO_ALG_INTERNAL);\r\nif (IS_ERR(mcryptd_tfm))\r\nreturn PTR_ERR(mcryptd_tfm);\r\nmctx = crypto_ahash_ctx(&mcryptd_tfm->base);\r\nmctx->alg_state = &sha512_mb_alg_state;\r\nctx->mcryptd_tfm = mcryptd_tfm;\r\ncrypto_ahash_set_reqsize(__crypto_ahash_cast(tfm),\r\nsizeof(struct ahash_request) +\r\ncrypto_ahash_reqsize(&mcryptd_tfm->base));\r\nreturn 0;\r\n}\r\nstatic void sha512_mb_async_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct sha512_mb_ctx *ctx = crypto_tfm_ctx(tfm);\r\nmcryptd_free_ahash(ctx->mcryptd_tfm);\r\n}\r\nstatic int sha512_mb_areq_init_tfm(struct crypto_tfm *tfm)\r\n{\r\ncrypto_ahash_set_reqsize(__crypto_ahash_cast(tfm),\r\nsizeof(struct ahash_request) +\r\nsizeof(struct sha512_hash_ctx));\r\nreturn 0;\r\n}\r\nstatic void sha512_mb_areq_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct sha512_mb_ctx *ctx = crypto_tfm_ctx(tfm);\r\nmcryptd_free_ahash(ctx->mcryptd_tfm);\r\n}\r\nstatic int sha512_mb_async_init(struct ahash_request *req)\r\n{\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\r\nstruct sha512_mb_ctx *ctx = crypto_ahash_ctx(tfm);\r\nstruct ahash_request *mcryptd_req = ahash_request_ctx(req);\r\nstruct mcryptd_ahash *mcryptd_tfm = ctx->mcryptd_tfm;\r\nmemcpy(mcryptd_req, req, sizeof(*req));\r\nahash_request_set_tfm(mcryptd_req, &mcryptd_tfm->base);\r\nreturn crypto_ahash_init(mcryptd_req);\r\n}\r\nstatic int sha512_mb_async_update(struct ahash_request *req)\r\n{\r\nstruct ahash_request *mcryptd_req = ahash_request_ctx(req);\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\r\nstruct sha512_mb_ctx *ctx = crypto_ahash_ctx(tfm);\r\nstruct mcryptd_ahash *mcryptd_tfm = ctx->mcryptd_tfm;\r\nmemcpy(mcryptd_req, req, sizeof(*req));\r\nahash_request_set_tfm(mcryptd_req, &mcryptd_tfm->base);\r\nreturn crypto_ahash_update(mcryptd_req);\r\n}\r\nstatic int sha512_mb_async_finup(struct ahash_request *req)\r\n{\r\nstruct ahash_request *mcryptd_req = ahash_request_ctx(req);\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\r\nstruct sha512_mb_ctx *ctx = crypto_ahash_ctx(tfm);\r\nstruct mcryptd_ahash *mcryptd_tfm = ctx->mcryptd_tfm;\r\nmemcpy(mcryptd_req, req, sizeof(*req));\r\nahash_request_set_tfm(mcryptd_req, &mcryptd_tfm->base);\r\nreturn crypto_ahash_finup(mcryptd_req);\r\n}\r\nstatic int sha512_mb_async_final(struct ahash_request *req)\r\n{\r\nstruct ahash_request *mcryptd_req = ahash_request_ctx(req);\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\r\nstruct sha512_mb_ctx *ctx = crypto_ahash_ctx(tfm);\r\nstruct mcryptd_ahash *mcryptd_tfm = ctx->mcryptd_tfm;\r\nmemcpy(mcryptd_req, req, sizeof(*req));\r\nahash_request_set_tfm(mcryptd_req, &mcryptd_tfm->base);\r\nreturn crypto_ahash_final(mcryptd_req);\r\n}\r\nstatic int sha512_mb_async_digest(struct ahash_request *req)\r\n{\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\r\nstruct sha512_mb_ctx *ctx = crypto_ahash_ctx(tfm);\r\nstruct ahash_request *mcryptd_req = ahash_request_ctx(req);\r\nstruct mcryptd_ahash *mcryptd_tfm = ctx->mcryptd_tfm;\r\nmemcpy(mcryptd_req, req, sizeof(*req));\r\nahash_request_set_tfm(mcryptd_req, &mcryptd_tfm->base);\r\nreturn crypto_ahash_digest(mcryptd_req);\r\n}\r\nstatic int sha512_mb_async_export(struct ahash_request *req, void *out)\r\n{\r\nstruct ahash_request *mcryptd_req = ahash_request_ctx(req);\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\r\nstruct sha512_mb_ctx *ctx = crypto_ahash_ctx(tfm);\r\nstruct mcryptd_ahash *mcryptd_tfm = ctx->mcryptd_tfm;\r\nmemcpy(mcryptd_req, req, sizeof(*req));\r\nahash_request_set_tfm(mcryptd_req, &mcryptd_tfm->base);\r\nreturn crypto_ahash_export(mcryptd_req, out);\r\n}\r\nstatic int sha512_mb_async_import(struct ahash_request *req, const void *in)\r\n{\r\nstruct ahash_request *mcryptd_req = ahash_request_ctx(req);\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\r\nstruct sha512_mb_ctx *ctx = crypto_ahash_ctx(tfm);\r\nstruct mcryptd_ahash *mcryptd_tfm = ctx->mcryptd_tfm;\r\nstruct crypto_ahash *child = mcryptd_ahash_child(mcryptd_tfm);\r\nstruct mcryptd_hash_request_ctx *rctx;\r\nstruct ahash_request *areq;\r\nmemcpy(mcryptd_req, req, sizeof(*req));\r\nahash_request_set_tfm(mcryptd_req, &mcryptd_tfm->base);\r\nrctx = ahash_request_ctx(mcryptd_req);\r\nareq = &rctx->areq;\r\nahash_request_set_tfm(areq, child);\r\nahash_request_set_callback(areq, CRYPTO_TFM_REQ_MAY_SLEEP,\r\nrctx->complete, req);\r\nreturn crypto_ahash_import(mcryptd_req, in);\r\n}\r\nstatic unsigned long sha512_mb_flusher(struct mcryptd_alg_cstate *cstate)\r\n{\r\nstruct mcryptd_hash_request_ctx *rctx;\r\nunsigned long cur_time;\r\nunsigned long next_flush = 0;\r\nstruct sha512_hash_ctx *sha_ctx;\r\ncur_time = jiffies;\r\nwhile (!list_empty(&cstate->work_list)) {\r\nrctx = list_entry(cstate->work_list.next,\r\nstruct mcryptd_hash_request_ctx, waiter);\r\nif time_before(cur_time, rctx->tag.expire)\r\nbreak;\r\nkernel_fpu_begin();\r\nsha_ctx = (struct sha512_hash_ctx *)\r\nsha512_ctx_mgr_flush(cstate);\r\nkernel_fpu_end();\r\nif (!sha_ctx) {\r\npr_err("sha512_mb error: nothing got flushed for"\r\n" non-empty list\n");\r\nbreak;\r\n}\r\nrctx = cast_hash_to_mcryptd_ctx(sha_ctx);\r\nsha_finish_walk(&rctx, cstate, true);\r\nsha_complete_job(rctx, cstate, 0);\r\n}\r\nif (!list_empty(&cstate->work_list)) {\r\nrctx = list_entry(cstate->work_list.next,\r\nstruct mcryptd_hash_request_ctx, waiter);\r\nnext_flush = rctx->tag.expire;\r\nmcryptd_arm_flusher(cstate, get_delay(next_flush));\r\n}\r\nreturn next_flush;\r\n}\r\nstatic int __init sha512_mb_mod_init(void)\r\n{\r\nint cpu;\r\nint err;\r\nstruct mcryptd_alg_cstate *cpu_state;\r\nif (!boot_cpu_has(X86_FEATURE_AVX2) ||\r\n!boot_cpu_has(X86_FEATURE_BMI2))\r\nreturn -ENODEV;\r\nsha512_mb_alg_state.alg_cstate =\r\nalloc_percpu(struct mcryptd_alg_cstate);\r\nsha512_job_mgr_init = sha512_mb_mgr_init_avx2;\r\nsha512_job_mgr_submit = sha512_mb_mgr_submit_avx2;\r\nsha512_job_mgr_flush = sha512_mb_mgr_flush_avx2;\r\nsha512_job_mgr_get_comp_job = sha512_mb_mgr_get_comp_job_avx2;\r\nif (!sha512_mb_alg_state.alg_cstate)\r\nreturn -ENOMEM;\r\nfor_each_possible_cpu(cpu) {\r\ncpu_state = per_cpu_ptr(sha512_mb_alg_state.alg_cstate, cpu);\r\ncpu_state->next_flush = 0;\r\ncpu_state->next_seq_num = 0;\r\ncpu_state->flusher_engaged = false;\r\nINIT_DELAYED_WORK(&cpu_state->flush, mcryptd_flusher);\r\ncpu_state->cpu = cpu;\r\ncpu_state->alg_state = &sha512_mb_alg_state;\r\ncpu_state->mgr = kzalloc(sizeof(struct sha512_ctx_mgr),\r\nGFP_KERNEL);\r\nif (!cpu_state->mgr)\r\ngoto err2;\r\nsha512_ctx_mgr_init(cpu_state->mgr);\r\nINIT_LIST_HEAD(&cpu_state->work_list);\r\nspin_lock_init(&cpu_state->work_lock);\r\n}\r\nsha512_mb_alg_state.flusher = &sha512_mb_flusher;\r\nerr = crypto_register_ahash(&sha512_mb_areq_alg);\r\nif (err)\r\ngoto err2;\r\nerr = crypto_register_ahash(&sha512_mb_async_alg);\r\nif (err)\r\ngoto err1;\r\nreturn 0;\r\nerr1:\r\ncrypto_unregister_ahash(&sha512_mb_areq_alg);\r\nerr2:\r\nfor_each_possible_cpu(cpu) {\r\ncpu_state = per_cpu_ptr(sha512_mb_alg_state.alg_cstate, cpu);\r\nkfree(cpu_state->mgr);\r\n}\r\nfree_percpu(sha512_mb_alg_state.alg_cstate);\r\nreturn -ENODEV;\r\n}\r\nstatic void __exit sha512_mb_mod_fini(void)\r\n{\r\nint cpu;\r\nstruct mcryptd_alg_cstate *cpu_state;\r\ncrypto_unregister_ahash(&sha512_mb_async_alg);\r\ncrypto_unregister_ahash(&sha512_mb_areq_alg);\r\nfor_each_possible_cpu(cpu) {\r\ncpu_state = per_cpu_ptr(sha512_mb_alg_state.alg_cstate, cpu);\r\nkfree(cpu_state->mgr);\r\n}\r\nfree_percpu(sha512_mb_alg_state.alg_cstate);\r\n}
