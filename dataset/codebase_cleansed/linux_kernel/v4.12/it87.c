static inline int superio_inb(int ioreg, int reg)\r\n{\r\noutb(reg, ioreg);\r\nreturn inb(ioreg + 1);\r\n}\r\nstatic inline void superio_outb(int ioreg, int reg, int val)\r\n{\r\noutb(reg, ioreg);\r\noutb(val, ioreg + 1);\r\n}\r\nstatic int superio_inw(int ioreg, int reg)\r\n{\r\nint val;\r\noutb(reg++, ioreg);\r\nval = inb(ioreg + 1) << 8;\r\noutb(reg, ioreg);\r\nval |= inb(ioreg + 1);\r\nreturn val;\r\n}\r\nstatic inline void superio_select(int ioreg, int ldn)\r\n{\r\noutb(DEV, ioreg);\r\noutb(ldn, ioreg + 1);\r\n}\r\nstatic inline int superio_enter(int ioreg)\r\n{\r\nif (!request_muxed_region(ioreg, 2, DRVNAME))\r\nreturn -EBUSY;\r\noutb(0x87, ioreg);\r\noutb(0x01, ioreg);\r\noutb(0x55, ioreg);\r\noutb(ioreg == REG_4E ? 0xaa : 0x55, ioreg);\r\nreturn 0;\r\n}\r\nstatic inline void superio_exit(int ioreg)\r\n{\r\noutb(0x02, ioreg);\r\noutb(0x02, ioreg + 1);\r\nrelease_region(ioreg, 2);\r\n}\r\nstatic int adc_lsb(const struct it87_data *data, int nr)\r\n{\r\nint lsb;\r\nif (has_12mv_adc(data))\r\nlsb = 120;\r\nelse if (has_10_9mv_adc(data))\r\nlsb = 109;\r\nelse\r\nlsb = 160;\r\nif (data->in_scaled & BIT(nr))\r\nlsb <<= 1;\r\nreturn lsb;\r\n}\r\nstatic u8 in_to_reg(const struct it87_data *data, int nr, long val)\r\n{\r\nval = DIV_ROUND_CLOSEST(val * 10, adc_lsb(data, nr));\r\nreturn clamp_val(val, 0, 255);\r\n}\r\nstatic int in_from_reg(const struct it87_data *data, int nr, int val)\r\n{\r\nreturn DIV_ROUND_CLOSEST(val * adc_lsb(data, nr), 10);\r\n}\r\nstatic inline u8 FAN_TO_REG(long rpm, int div)\r\n{\r\nif (rpm == 0)\r\nreturn 255;\r\nrpm = clamp_val(rpm, 1, 1000000);\r\nreturn clamp_val((1350000 + rpm * div / 2) / (rpm * div), 1, 254);\r\n}\r\nstatic inline u16 FAN16_TO_REG(long rpm)\r\n{\r\nif (rpm == 0)\r\nreturn 0xffff;\r\nreturn clamp_val((1350000 + rpm) / (rpm * 2), 1, 0xfffe);\r\n}\r\nstatic u8 pwm_to_reg(const struct it87_data *data, long val)\r\n{\r\nif (has_newer_autopwm(data))\r\nreturn val;\r\nelse\r\nreturn val >> 1;\r\n}\r\nstatic int pwm_from_reg(const struct it87_data *data, u8 reg)\r\n{\r\nif (has_newer_autopwm(data))\r\nreturn reg;\r\nelse\r\nreturn (reg & 0x7f) << 1;\r\n}\r\nstatic int DIV_TO_REG(int val)\r\n{\r\nint answer = 0;\r\nwhile (answer < 7 && (val >>= 1))\r\nanswer++;\r\nreturn answer;\r\n}\r\nstatic int it87_read_value(struct it87_data *data, u8 reg)\r\n{\r\noutb_p(reg, data->addr + IT87_ADDR_REG_OFFSET);\r\nreturn inb_p(data->addr + IT87_DATA_REG_OFFSET);\r\n}\r\nstatic void it87_write_value(struct it87_data *data, u8 reg, u8 value)\r\n{\r\noutb_p(reg, data->addr + IT87_ADDR_REG_OFFSET);\r\noutb_p(value, data->addr + IT87_DATA_REG_OFFSET);\r\n}\r\nstatic void it87_update_pwm_ctrl(struct it87_data *data, int nr)\r\n{\r\ndata->pwm_ctrl[nr] = it87_read_value(data, IT87_REG_PWM[nr]);\r\nif (has_newer_autopwm(data)) {\r\ndata->pwm_temp_map[nr] = data->pwm_ctrl[nr] & 0x03;\r\ndata->pwm_duty[nr] = it87_read_value(data,\r\nIT87_REG_PWM_DUTY[nr]);\r\n} else {\r\nif (data->pwm_ctrl[nr] & 0x80)\r\ndata->pwm_temp_map[nr] = data->pwm_ctrl[nr] & 0x03;\r\nelse\r\ndata->pwm_duty[nr] = data->pwm_ctrl[nr] & 0x7f;\r\n}\r\nif (has_old_autopwm(data)) {\r\nint i;\r\nfor (i = 0; i < 5 ; i++)\r\ndata->auto_temp[nr][i] = it87_read_value(data,\r\nIT87_REG_AUTO_TEMP(nr, i));\r\nfor (i = 0; i < 3 ; i++)\r\ndata->auto_pwm[nr][i] = it87_read_value(data,\r\nIT87_REG_AUTO_PWM(nr, i));\r\n} else if (has_newer_autopwm(data)) {\r\nint i;\r\ndata->auto_temp[nr][0] =\r\nit87_read_value(data, IT87_REG_AUTO_TEMP(nr, 5));\r\nfor (i = 0; i < 3 ; i++)\r\ndata->auto_temp[nr][i + 1] =\r\nit87_read_value(data,\r\nIT87_REG_AUTO_TEMP(nr, i));\r\ndata->auto_pwm[nr][0] =\r\nit87_read_value(data, IT87_REG_AUTO_TEMP(nr, 3));\r\ndata->auto_pwm[nr][1] =\r\nit87_read_value(data, IT87_REG_AUTO_TEMP(nr, 4));\r\n}\r\n}\r\nstatic struct it87_data *it87_update_device(struct device *dev)\r\n{\r\nstruct it87_data *data = dev_get_drvdata(dev);\r\nint i;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + HZ + HZ / 2) ||\r\n!data->valid) {\r\nif (update_vbat) {\r\nit87_write_value(data, IT87_REG_CONFIG,\r\nit87_read_value(data, IT87_REG_CONFIG) | 0x40);\r\n}\r\nfor (i = 0; i < NUM_VIN; i++) {\r\nif (!(data->has_in & BIT(i)))\r\ncontinue;\r\ndata->in[i][0] =\r\nit87_read_value(data, IT87_REG_VIN[i]);\r\nif (i >= NUM_VIN_LIMIT)\r\ncontinue;\r\ndata->in[i][1] =\r\nit87_read_value(data, IT87_REG_VIN_MIN(i));\r\ndata->in[i][2] =\r\nit87_read_value(data, IT87_REG_VIN_MAX(i));\r\n}\r\nfor (i = 0; i < NUM_FAN; i++) {\r\nif (!(data->has_fan & BIT(i)))\r\ncontinue;\r\ndata->fan[i][1] =\r\nit87_read_value(data, IT87_REG_FAN_MIN[i]);\r\ndata->fan[i][0] = it87_read_value(data,\r\nIT87_REG_FAN[i]);\r\nif (has_16bit_fans(data)) {\r\ndata->fan[i][0] |= it87_read_value(data,\r\nIT87_REG_FANX[i]) << 8;\r\ndata->fan[i][1] |= it87_read_value(data,\r\nIT87_REG_FANX_MIN[i]) << 8;\r\n}\r\n}\r\nfor (i = 0; i < NUM_TEMP; i++) {\r\nif (!(data->has_temp & BIT(i)))\r\ncontinue;\r\ndata->temp[i][0] =\r\nit87_read_value(data, IT87_REG_TEMP(i));\r\nif (has_temp_offset(data) && i < NUM_TEMP_OFFSET)\r\ndata->temp[i][3] =\r\nit87_read_value(data,\r\nIT87_REG_TEMP_OFFSET[i]);\r\nif (i >= NUM_TEMP_LIMIT)\r\ncontinue;\r\ndata->temp[i][1] =\r\nit87_read_value(data, IT87_REG_TEMP_LOW(i));\r\ndata->temp[i][2] =\r\nit87_read_value(data, IT87_REG_TEMP_HIGH(i));\r\n}\r\nif ((data->has_fan & 0x07) && !has_16bit_fans(data)) {\r\ni = it87_read_value(data, IT87_REG_FAN_DIV);\r\ndata->fan_div[0] = i & 0x07;\r\ndata->fan_div[1] = (i >> 3) & 0x07;\r\ndata->fan_div[2] = (i & 0x40) ? 3 : 1;\r\n}\r\ndata->alarms =\r\nit87_read_value(data, IT87_REG_ALARM1) |\r\n(it87_read_value(data, IT87_REG_ALARM2) << 8) |\r\n(it87_read_value(data, IT87_REG_ALARM3) << 16);\r\ndata->beeps = it87_read_value(data, IT87_REG_BEEP_ENABLE);\r\ndata->fan_main_ctrl = it87_read_value(data,\r\nIT87_REG_FAN_MAIN_CTRL);\r\ndata->fan_ctl = it87_read_value(data, IT87_REG_FAN_CTL);\r\nfor (i = 0; i < NUM_PWM; i++) {\r\nif (!(data->has_pwm & BIT(i)))\r\ncontinue;\r\nit87_update_pwm_ctrl(data, i);\r\n}\r\ndata->sensor = it87_read_value(data, IT87_REG_TEMP_ENABLE);\r\ndata->extra = it87_read_value(data, IT87_REG_TEMP_EXTRA);\r\nif (data->type == it8712 || data->type == it8716) {\r\ndata->vid = it87_read_value(data, IT87_REG_VID);\r\ndata->vid &= 0x3f;\r\n}\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic ssize_t show_in(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nstruct it87_data *data = it87_update_device(dev);\r\nint index = sattr->index;\r\nint nr = sattr->nr;\r\nreturn sprintf(buf, "%d\n", in_from_reg(data, nr, data->in[nr][index]));\r\n}\r\nstatic ssize_t set_in(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nstruct it87_data *data = dev_get_drvdata(dev);\r\nint index = sattr->index;\r\nint nr = sattr->nr;\r\nunsigned long val;\r\nif (kstrtoul(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->in[nr][index] = in_to_reg(data, nr, val);\r\nit87_write_value(data,\r\nindex == 1 ? IT87_REG_VIN_MIN(nr)\r\n: IT87_REG_VIN_MAX(nr),\r\ndata->in[nr][index]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nint nr = sattr->nr;\r\nint index = sattr->index;\r\nstruct it87_data *data = it87_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp[nr][index]));\r\n}\r\nstatic ssize_t set_temp(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nint nr = sattr->nr;\r\nint index = sattr->index;\r\nstruct it87_data *data = dev_get_drvdata(dev);\r\nlong val;\r\nu8 reg, regval;\r\nif (kstrtol(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nswitch (index) {\r\ndefault:\r\ncase 1:\r\nreg = IT87_REG_TEMP_LOW(nr);\r\nbreak;\r\ncase 2:\r\nreg = IT87_REG_TEMP_HIGH(nr);\r\nbreak;\r\ncase 3:\r\nregval = it87_read_value(data, IT87_REG_BEEP_ENABLE);\r\nif (!(regval & 0x80)) {\r\nregval |= 0x80;\r\nit87_write_value(data, IT87_REG_BEEP_ENABLE, regval);\r\n}\r\ndata->valid = 0;\r\nreg = IT87_REG_TEMP_OFFSET[nr];\r\nbreak;\r\n}\r\ndata->temp[nr][index] = TEMP_TO_REG(val);\r\nit87_write_value(data, reg, data->temp[nr][index]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_type(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct it87_data *data = it87_update_device(dev);\r\nu8 reg = data->sensor;\r\nu8 extra = data->extra;\r\nif ((has_temp_peci(data, nr) && (reg >> 6 == nr + 1)) ||\r\n(has_temp_old_peci(data, nr) && (extra & 0x80)))\r\nreturn sprintf(buf, "6\n");\r\nif (reg & (1 << nr))\r\nreturn sprintf(buf, "3\n");\r\nif (reg & (8 << nr))\r\nreturn sprintf(buf, "4\n");\r\nreturn sprintf(buf, "0\n");\r\n}\r\nstatic ssize_t set_temp_type(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct it87_data *data = dev_get_drvdata(dev);\r\nlong val;\r\nu8 reg, extra;\r\nif (kstrtol(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\nreg = it87_read_value(data, IT87_REG_TEMP_ENABLE);\r\nreg &= ~(1 << nr);\r\nreg &= ~(8 << nr);\r\nif (has_temp_peci(data, nr) && (reg >> 6 == nr + 1 || val == 6))\r\nreg &= 0x3f;\r\nextra = it87_read_value(data, IT87_REG_TEMP_EXTRA);\r\nif (has_temp_old_peci(data, nr) && ((extra & 0x80) || val == 6))\r\nextra &= 0x7f;\r\nif (val == 2) {\r\ndev_warn(dev,\r\n"Sensor type 2 is deprecated, please use 4 instead\n");\r\nval = 4;\r\n}\r\nif (val == 3)\r\nreg |= 1 << nr;\r\nelse if (val == 4)\r\nreg |= 8 << nr;\r\nelse if (has_temp_peci(data, nr) && val == 6)\r\nreg |= (nr + 1) << 6;\r\nelse if (has_temp_old_peci(data, nr) && val == 6)\r\nextra |= 0x80;\r\nelse if (val != 0)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->sensor = reg;\r\ndata->extra = extra;\r\nit87_write_value(data, IT87_REG_TEMP_ENABLE, data->sensor);\r\nif (has_temp_old_peci(data, nr))\r\nit87_write_value(data, IT87_REG_TEMP_EXTRA, data->extra);\r\ndata->valid = 0;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic int pwm_mode(const struct it87_data *data, int nr)\r\n{\r\nif (data->type != it8603 && nr < 3 && !(data->fan_main_ctrl & BIT(nr)))\r\nreturn 0;\r\nif (data->pwm_ctrl[nr] & 0x80)\r\nreturn 2;\r\nif ((data->type == it8603 || nr >= 3) &&\r\ndata->pwm_duty[nr] == pwm_to_reg(data, 0xff))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic ssize_t show_fan(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nint nr = sattr->nr;\r\nint index = sattr->index;\r\nint speed;\r\nstruct it87_data *data = it87_update_device(dev);\r\nspeed = has_16bit_fans(data) ?\r\nFAN16_FROM_REG(data->fan[nr][index]) :\r\nFAN_FROM_REG(data->fan[nr][index],\r\nDIV_FROM_REG(data->fan_div[nr]));\r\nreturn sprintf(buf, "%d\n", speed);\r\n}\r\nstatic ssize_t show_fan_div(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nstruct it87_data *data = it87_update_device(dev);\r\nint nr = sensor_attr->index;\r\nreturn sprintf(buf, "%lu\n", DIV_FROM_REG(data->fan_div[nr]));\r\n}\r\nstatic ssize_t show_pwm_enable(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nstruct it87_data *data = it87_update_device(dev);\r\nint nr = sensor_attr->index;\r\nreturn sprintf(buf, "%d\n", pwm_mode(data, nr));\r\n}\r\nstatic ssize_t show_pwm(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nstruct it87_data *data = it87_update_device(dev);\r\nint nr = sensor_attr->index;\r\nreturn sprintf(buf, "%d\n",\r\npwm_from_reg(data, data->pwm_duty[nr]));\r\n}\r\nstatic ssize_t show_pwm_freq(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nstruct it87_data *data = it87_update_device(dev);\r\nint nr = sensor_attr->index;\r\nunsigned int freq;\r\nint index;\r\nif (has_pwm_freq2(data) && nr == 1)\r\nindex = (data->extra >> 4) & 0x07;\r\nelse\r\nindex = (data->fan_ctl >> 4) & 0x07;\r\nfreq = pwm_freq[index] / (has_newer_autopwm(data) ? 256 : 128);\r\nreturn sprintf(buf, "%u\n", freq);\r\n}\r\nstatic ssize_t set_fan(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nint nr = sattr->nr;\r\nint index = sattr->index;\r\nstruct it87_data *data = dev_get_drvdata(dev);\r\nlong val;\r\nu8 reg;\r\nif (kstrtol(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nif (has_16bit_fans(data)) {\r\ndata->fan[nr][index] = FAN16_TO_REG(val);\r\nit87_write_value(data, IT87_REG_FAN_MIN[nr],\r\ndata->fan[nr][index] & 0xff);\r\nit87_write_value(data, IT87_REG_FANX_MIN[nr],\r\ndata->fan[nr][index] >> 8);\r\n} else {\r\nreg = it87_read_value(data, IT87_REG_FAN_DIV);\r\nswitch (nr) {\r\ncase 0:\r\ndata->fan_div[nr] = reg & 0x07;\r\nbreak;\r\ncase 1:\r\ndata->fan_div[nr] = (reg >> 3) & 0x07;\r\nbreak;\r\ncase 2:\r\ndata->fan_div[nr] = (reg & 0x40) ? 3 : 1;\r\nbreak;\r\n}\r\ndata->fan[nr][index] =\r\nFAN_TO_REG(val, DIV_FROM_REG(data->fan_div[nr]));\r\nit87_write_value(data, IT87_REG_FAN_MIN[nr],\r\ndata->fan[nr][index]);\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_fan_div(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nstruct it87_data *data = dev_get_drvdata(dev);\r\nint nr = sensor_attr->index;\r\nunsigned long val;\r\nint min;\r\nu8 old;\r\nif (kstrtoul(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nold = it87_read_value(data, IT87_REG_FAN_DIV);\r\nmin = FAN_FROM_REG(data->fan[nr][1], DIV_FROM_REG(data->fan_div[nr]));\r\nswitch (nr) {\r\ncase 0:\r\ncase 1:\r\ndata->fan_div[nr] = DIV_TO_REG(val);\r\nbreak;\r\ncase 2:\r\nif (val < 8)\r\ndata->fan_div[nr] = 1;\r\nelse\r\ndata->fan_div[nr] = 3;\r\n}\r\nval = old & 0x80;\r\nval |= (data->fan_div[0] & 0x07);\r\nval |= (data->fan_div[1] & 0x07) << 3;\r\nif (data->fan_div[2] == 3)\r\nval |= 0x1 << 6;\r\nit87_write_value(data, IT87_REG_FAN_DIV, val);\r\ndata->fan[nr][1] = FAN_TO_REG(min, DIV_FROM_REG(data->fan_div[nr]));\r\nit87_write_value(data, IT87_REG_FAN_MIN[nr], data->fan[nr][1]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic int check_trip_points(struct device *dev, int nr)\r\n{\r\nconst struct it87_data *data = dev_get_drvdata(dev);\r\nint i, err = 0;\r\nif (has_old_autopwm(data)) {\r\nfor (i = 0; i < 3; i++) {\r\nif (data->auto_temp[nr][i] > data->auto_temp[nr][i + 1])\r\nerr = -EINVAL;\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nif (data->auto_pwm[nr][i] > data->auto_pwm[nr][i + 1])\r\nerr = -EINVAL;\r\n}\r\n} else if (has_newer_autopwm(data)) {\r\nfor (i = 1; i < 3; i++) {\r\nif (data->auto_temp[nr][i] > data->auto_temp[nr][i + 1])\r\nerr = -EINVAL;\r\n}\r\n}\r\nif (err) {\r\ndev_err(dev,\r\n"Inconsistent trip points, not switching to automatic mode\n");\r\ndev_err(dev, "Adjust the trip points and try again\n");\r\n}\r\nreturn err;\r\n}\r\nstatic ssize_t set_pwm_enable(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nstruct it87_data *data = dev_get_drvdata(dev);\r\nint nr = sensor_attr->index;\r\nlong val;\r\nif (kstrtol(buf, 10, &val) < 0 || val < 0 || val > 2)\r\nreturn -EINVAL;\r\nif (val == 2) {\r\nif (check_trip_points(dev, nr) < 0)\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&data->update_lock);\r\nif (val == 0) {\r\nif (nr < 3 && data->type != it8603) {\r\nint tmp;\r\ntmp = it87_read_value(data, IT87_REG_FAN_CTL);\r\nit87_write_value(data, IT87_REG_FAN_CTL, tmp | BIT(nr));\r\ndata->fan_main_ctrl &= ~BIT(nr);\r\nit87_write_value(data, IT87_REG_FAN_MAIN_CTRL,\r\ndata->fan_main_ctrl);\r\n} else {\r\nu8 ctrl;\r\ndata->pwm_duty[nr] = pwm_to_reg(data, 0xff);\r\nit87_write_value(data, IT87_REG_PWM_DUTY[nr],\r\ndata->pwm_duty[nr]);\r\nif (has_newer_autopwm(data)) {\r\nctrl = (data->pwm_ctrl[nr] & 0x7c) |\r\ndata->pwm_temp_map[nr];\r\n} else {\r\nctrl = data->pwm_duty[nr];\r\n}\r\ndata->pwm_ctrl[nr] = ctrl;\r\nit87_write_value(data, IT87_REG_PWM[nr], ctrl);\r\n}\r\n} else {\r\nu8 ctrl;\r\nif (has_newer_autopwm(data)) {\r\nctrl = (data->pwm_ctrl[nr] & 0x7c) |\r\ndata->pwm_temp_map[nr];\r\nif (val != 1)\r\nctrl |= 0x80;\r\n} else {\r\nctrl = (val == 1 ? data->pwm_duty[nr] : 0x80);\r\n}\r\ndata->pwm_ctrl[nr] = ctrl;\r\nit87_write_value(data, IT87_REG_PWM[nr], ctrl);\r\nif (data->type != it8603 && nr < 3) {\r\ndata->fan_main_ctrl |= BIT(nr);\r\nit87_write_value(data, IT87_REG_FAN_MAIN_CTRL,\r\ndata->fan_main_ctrl);\r\n}\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_pwm(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nstruct it87_data *data = dev_get_drvdata(dev);\r\nint nr = sensor_attr->index;\r\nlong val;\r\nif (kstrtol(buf, 10, &val) < 0 || val < 0 || val > 255)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nit87_update_pwm_ctrl(data, nr);\r\nif (has_newer_autopwm(data)) {\r\nif (data->pwm_ctrl[nr] & 0x80) {\r\nmutex_unlock(&data->update_lock);\r\nreturn -EBUSY;\r\n}\r\ndata->pwm_duty[nr] = pwm_to_reg(data, val);\r\nit87_write_value(data, IT87_REG_PWM_DUTY[nr],\r\ndata->pwm_duty[nr]);\r\n} else {\r\ndata->pwm_duty[nr] = pwm_to_reg(data, val);\r\nif (!(data->pwm_ctrl[nr] & 0x80)) {\r\ndata->pwm_ctrl[nr] = data->pwm_duty[nr];\r\nit87_write_value(data, IT87_REG_PWM[nr],\r\ndata->pwm_ctrl[nr]);\r\n}\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_pwm_freq(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nstruct it87_data *data = dev_get_drvdata(dev);\r\nint nr = sensor_attr->index;\r\nunsigned long val;\r\nint i;\r\nif (kstrtoul(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\nval = clamp_val(val, 0, 1000000);\r\nval *= has_newer_autopwm(data) ? 256 : 128;\r\nfor (i = 0; i < 7; i++) {\r\nif (val > (pwm_freq[i] + pwm_freq[i + 1]) / 2)\r\nbreak;\r\n}\r\nmutex_lock(&data->update_lock);\r\nif (nr == 0) {\r\ndata->fan_ctl = it87_read_value(data, IT87_REG_FAN_CTL) & 0x8f;\r\ndata->fan_ctl |= i << 4;\r\nit87_write_value(data, IT87_REG_FAN_CTL, data->fan_ctl);\r\n} else {\r\ndata->extra = it87_read_value(data, IT87_REG_TEMP_EXTRA) & 0x8f;\r\ndata->extra |= i << 4;\r\nit87_write_value(data, IT87_REG_TEMP_EXTRA, data->extra);\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_temp_map(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nstruct it87_data *data = it87_update_device(dev);\r\nint nr = sensor_attr->index;\r\nint map;\r\nmap = data->pwm_temp_map[nr];\r\nif (map >= 3)\r\nmap = 0;\r\nif (nr >= 3)\r\nmap += 3;\r\nreturn sprintf(buf, "%d\n", (int)BIT(map));\r\n}\r\nstatic ssize_t set_pwm_temp_map(struct device *dev,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nstruct it87_data *data = dev_get_drvdata(dev);\r\nint nr = sensor_attr->index;\r\nlong val;\r\nu8 reg;\r\nif (kstrtol(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\nif (nr >= 3)\r\nval -= 3;\r\nswitch (val) {\r\ncase BIT(0):\r\nreg = 0x00;\r\nbreak;\r\ncase BIT(1):\r\nreg = 0x01;\r\nbreak;\r\ncase BIT(2):\r\nreg = 0x02;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&data->update_lock);\r\nit87_update_pwm_ctrl(data, nr);\r\ndata->pwm_temp_map[nr] = reg;\r\nif (data->pwm_ctrl[nr] & 0x80) {\r\ndata->pwm_ctrl[nr] = (data->pwm_ctrl[nr] & 0xfc) |\r\ndata->pwm_temp_map[nr];\r\nit87_write_value(data, IT87_REG_PWM[nr], data->pwm_ctrl[nr]);\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_auto_pwm(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct it87_data *data = it87_update_device(dev);\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint point = sensor_attr->index;\r\nreturn sprintf(buf, "%d\n",\r\npwm_from_reg(data, data->auto_pwm[nr][point]));\r\n}\r\nstatic ssize_t set_auto_pwm(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct it87_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint point = sensor_attr->index;\r\nint regaddr;\r\nlong val;\r\nif (kstrtol(buf, 10, &val) < 0 || val < 0 || val > 255)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->auto_pwm[nr][point] = pwm_to_reg(data, val);\r\nif (has_newer_autopwm(data))\r\nregaddr = IT87_REG_AUTO_TEMP(nr, 3);\r\nelse\r\nregaddr = IT87_REG_AUTO_PWM(nr, point);\r\nit87_write_value(data, regaddr, data->auto_pwm[nr][point]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_auto_pwm_slope(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct it87_data *data = it87_update_device(dev);\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nreturn sprintf(buf, "%d\n", data->auto_pwm[nr][1] & 0x7f);\r\n}\r\nstatic ssize_t set_auto_pwm_slope(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct it87_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nunsigned long val;\r\nif (kstrtoul(buf, 10, &val) < 0 || val > 127)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->auto_pwm[nr][1] = (data->auto_pwm[nr][1] & 0x80) | val;\r\nit87_write_value(data, IT87_REG_AUTO_TEMP(nr, 4),\r\ndata->auto_pwm[nr][1]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_auto_temp(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct it87_data *data = it87_update_device(dev);\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint point = sensor_attr->index;\r\nint reg;\r\nif (has_old_autopwm(data) || point)\r\nreg = data->auto_temp[nr][point];\r\nelse\r\nreg = data->auto_temp[nr][1] - (data->auto_temp[nr][0] & 0x1f);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(reg));\r\n}\r\nstatic ssize_t set_auto_temp(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct it87_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint point = sensor_attr->index;\r\nlong val;\r\nint reg;\r\nif (kstrtol(buf, 10, &val) < 0 || val < -128000 || val > 127000)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nif (has_newer_autopwm(data) && !point) {\r\nreg = data->auto_temp[nr][1] - TEMP_TO_REG(val);\r\nreg = clamp_val(reg, 0, 0x1f) | (data->auto_temp[nr][0] & 0xe0);\r\ndata->auto_temp[nr][0] = reg;\r\nit87_write_value(data, IT87_REG_AUTO_TEMP(nr, 5), reg);\r\n} else {\r\nreg = TEMP_TO_REG(val);\r\ndata->auto_temp[nr][point] = reg;\r\nif (has_newer_autopwm(data))\r\npoint--;\r\nit87_write_value(data, IT87_REG_AUTO_TEMP(nr, point), reg);\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t alarms_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct it87_data *data = it87_update_device(dev);\r\nreturn sprintf(buf, "%u\n", data->alarms);\r\n}\r\nstatic ssize_t show_alarm(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct it87_data *data = it87_update_device(dev);\r\nint bitnr = to_sensor_dev_attr(attr)->index;\r\nreturn sprintf(buf, "%u\n", (data->alarms >> bitnr) & 1);\r\n}\r\nstatic ssize_t clear_intrusion(struct device *dev,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct it87_data *data = dev_get_drvdata(dev);\r\nint config;\r\nlong val;\r\nif (kstrtol(buf, 10, &val) < 0 || val != 0)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nconfig = it87_read_value(data, IT87_REG_CONFIG);\r\nif (config < 0) {\r\ncount = config;\r\n} else {\r\nconfig |= BIT(5);\r\nit87_write_value(data, IT87_REG_CONFIG, config);\r\ndata->valid = 0;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_beep(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct it87_data *data = it87_update_device(dev);\r\nint bitnr = to_sensor_dev_attr(attr)->index;\r\nreturn sprintf(buf, "%u\n", (data->beeps >> bitnr) & 1);\r\n}\r\nstatic ssize_t set_beep(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint bitnr = to_sensor_dev_attr(attr)->index;\r\nstruct it87_data *data = dev_get_drvdata(dev);\r\nlong val;\r\nif (kstrtol(buf, 10, &val) < 0 || (val != 0 && val != 1))\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->beeps = it87_read_value(data, IT87_REG_BEEP_ENABLE);\r\nif (val)\r\ndata->beeps |= BIT(bitnr);\r\nelse\r\ndata->beeps &= ~BIT(bitnr);\r\nit87_write_value(data, IT87_REG_BEEP_ENABLE, data->beeps);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t vrm_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct it87_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", data->vrm);\r\n}\r\nstatic ssize_t vrm_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct it87_data *data = dev_get_drvdata(dev);\r\nunsigned long val;\r\nif (kstrtoul(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\ndata->vrm = val;\r\nreturn count;\r\n}\r\nstatic ssize_t cpu0_vid_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct it87_data *data = it87_update_device(dev);\r\nreturn sprintf(buf, "%ld\n", (long)vid_from_reg(data->vid, data->vrm));\r\n}\r\nstatic ssize_t show_label(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstatic const char * const labels[] = {\r\n"+5V",\r\n"5VSB",\r\n"Vbat",\r\n"AVCC",\r\n};\r\nstatic const char * const labels_it8721[] = {\r\n"+3.3V",\r\n"3VSB",\r\n"Vbat",\r\n"+3.3V",\r\n};\r\nstruct it87_data *data = dev_get_drvdata(dev);\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nconst char *label;\r\nif (has_vin3_5v(data) && nr == 0)\r\nlabel = labels[0];\r\nelse if (has_12mv_adc(data) || has_10_9mv_adc(data))\r\nlabel = labels_it8721[nr];\r\nelse\r\nlabel = labels[nr];\r\nreturn sprintf(buf, "%s\n", label);\r\n}\r\nstatic umode_t it87_in_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int index)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct it87_data *data = dev_get_drvdata(dev);\r\nint i = index / 5;\r\nint a = index % 5;\r\nif (index >= 40) {\r\ni = index - 40 + 8;\r\na = 0;\r\n}\r\nif (!(data->has_in & BIT(i)))\r\nreturn 0;\r\nif (a == 4 && !data->has_beep)\r\nreturn 0;\r\nreturn attr->mode;\r\n}\r\nstatic umode_t it87_temp_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int index)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct it87_data *data = dev_get_drvdata(dev);\r\nint i = index / 7;\r\nint a = index % 7;\r\nif (index >= 21) {\r\ni = index - 21 + 3;\r\na = 0;\r\n}\r\nif (!(data->has_temp & BIT(i)))\r\nreturn 0;\r\nif (a == 5 && !has_temp_offset(data))\r\nreturn 0;\r\nif (a == 6 && !data->has_beep)\r\nreturn 0;\r\nreturn attr->mode;\r\n}\r\nstatic umode_t it87_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int index)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct it87_data *data = dev_get_drvdata(dev);\r\nif ((index == 2 || index == 3) && !data->has_vid)\r\nreturn 0;\r\nif (index > 3 && !(data->in_internal & BIT(index - 4)))\r\nreturn 0;\r\nreturn attr->mode;\r\n}\r\nstatic umode_t it87_fan_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int index)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct it87_data *data = dev_get_drvdata(dev);\r\nint i = index / 5;\r\nint a = index % 5;\r\nif (index >= 15) {\r\ni = (index - 15) / 4 + 3;\r\na = (index - 15) % 4;\r\n}\r\nif (!(data->has_fan & BIT(i)))\r\nreturn 0;\r\nif (a == 3) {\r\nif (!data->has_beep)\r\nreturn 0;\r\nif (i == __ffs(data->has_fan))\r\nreturn attr->mode | S_IWUSR;\r\n}\r\nif (a == 4 && has_16bit_fans(data))\r\nreturn 0;\r\nreturn attr->mode;\r\n}\r\nstatic umode_t it87_pwm_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int index)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct it87_data *data = dev_get_drvdata(dev);\r\nint i = index / 4;\r\nint a = index % 4;\r\nif (!(data->has_pwm & BIT(i)))\r\nreturn 0;\r\nif (a == 3 && (has_old_autopwm(data) || has_newer_autopwm(data)))\r\nreturn attr->mode | S_IWUSR;\r\nif (has_pwm_freq2(data) && i == 1 && a == 2)\r\nreturn attr->mode | S_IWUSR;\r\nreturn attr->mode;\r\n}\r\nstatic umode_t it87_auto_pwm_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int index)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct it87_data *data = dev_get_drvdata(dev);\r\nint i = index / 11;\r\nint a = index % 11;\r\nif (index >= 33) {\r\ni = (index - 33) / 6 + 3;\r\na = (index - 33) % 6 + 4;\r\n}\r\nif (!(data->has_pwm & BIT(i)))\r\nreturn 0;\r\nif (has_newer_autopwm(data)) {\r\nif (a < 4)\r\nreturn 0;\r\nif (a == 8)\r\nreturn 0;\r\n}\r\nif (has_old_autopwm(data)) {\r\nif (a >= 9)\r\nreturn 0;\r\n}\r\nreturn attr->mode;\r\n}\r\nstatic int __init it87_find(int sioaddr, unsigned short *address,\r\nstruct it87_sio_data *sio_data)\r\n{\r\nint err;\r\nu16 chip_type;\r\nconst char *board_vendor, *board_name;\r\nconst struct it87_devices *config;\r\nerr = superio_enter(sioaddr);\r\nif (err)\r\nreturn err;\r\nerr = -ENODEV;\r\nchip_type = force_id ? force_id : superio_inw(sioaddr, DEVID);\r\nswitch (chip_type) {\r\ncase IT8705F_DEVID:\r\nsio_data->type = it87;\r\nbreak;\r\ncase IT8712F_DEVID:\r\nsio_data->type = it8712;\r\nbreak;\r\ncase IT8716F_DEVID:\r\ncase IT8726F_DEVID:\r\nsio_data->type = it8716;\r\nbreak;\r\ncase IT8718F_DEVID:\r\nsio_data->type = it8718;\r\nbreak;\r\ncase IT8720F_DEVID:\r\nsio_data->type = it8720;\r\nbreak;\r\ncase IT8721F_DEVID:\r\nsio_data->type = it8721;\r\nbreak;\r\ncase IT8728F_DEVID:\r\nsio_data->type = it8728;\r\nbreak;\r\ncase IT8732F_DEVID:\r\nsio_data->type = it8732;\r\nbreak;\r\ncase IT8792E_DEVID:\r\nsio_data->type = it8792;\r\nbreak;\r\ncase IT8771E_DEVID:\r\nsio_data->type = it8771;\r\nbreak;\r\ncase IT8772E_DEVID:\r\nsio_data->type = it8772;\r\nbreak;\r\ncase IT8781F_DEVID:\r\nsio_data->type = it8781;\r\nbreak;\r\ncase IT8782F_DEVID:\r\nsio_data->type = it8782;\r\nbreak;\r\ncase IT8783E_DEVID:\r\nsio_data->type = it8783;\r\nbreak;\r\ncase IT8786E_DEVID:\r\nsio_data->type = it8786;\r\nbreak;\r\ncase IT8790E_DEVID:\r\nsio_data->type = it8790;\r\nbreak;\r\ncase IT8603E_DEVID:\r\ncase IT8623E_DEVID:\r\nsio_data->type = it8603;\r\nbreak;\r\ncase IT8620E_DEVID:\r\nsio_data->type = it8620;\r\nbreak;\r\ncase IT8622E_DEVID:\r\nsio_data->type = it8622;\r\nbreak;\r\ncase IT8628E_DEVID:\r\nsio_data->type = it8628;\r\nbreak;\r\ncase 0xffff:\r\ngoto exit;\r\ndefault:\r\npr_debug("Unsupported chip (DEVID=0x%x)\n", chip_type);\r\ngoto exit;\r\n}\r\nsuperio_select(sioaddr, PME);\r\nif (!(superio_inb(sioaddr, IT87_ACT_REG) & 0x01)) {\r\npr_info("Device not activated, skipping\n");\r\ngoto exit;\r\n}\r\n*address = superio_inw(sioaddr, IT87_BASE_REG) & ~(IT87_EXTENT - 1);\r\nif (*address == 0) {\r\npr_info("Base address not set, skipping\n");\r\ngoto exit;\r\n}\r\nerr = 0;\r\nsio_data->revision = superio_inb(sioaddr, DEVREV) & 0x0f;\r\npr_info("Found IT%04x%s chip at 0x%x, revision %d\n", chip_type,\r\nit87_devices[sio_data->type].suffix,\r\n*address, sio_data->revision);\r\nconfig = &it87_devices[sio_data->type];\r\nif (has_in7_internal(config))\r\nsio_data->internal |= BIT(1);\r\nsio_data->internal |= BIT(2);\r\nif (has_avcc3(config))\r\nsio_data->internal |= BIT(3);\r\nelse\r\nsio_data->skip_in |= BIT(9);\r\nif (!has_five_pwm(config))\r\nsio_data->skip_pwm |= BIT(3) | BIT(4) | BIT(5);\r\nelse if (!has_six_pwm(config))\r\nsio_data->skip_pwm |= BIT(5);\r\nif (!has_vid(config))\r\nsio_data->skip_vid = 1;\r\nif (sio_data->type == it87) {\r\nsuperio_select(sioaddr, 5);\r\nsio_data->beep_pin = superio_inb(sioaddr,\r\nIT87_SIO_BEEP_PIN_REG) & 0x3f;\r\n} else if (sio_data->type == it8783) {\r\nint reg25, reg27, reg2a, reg2c, regef;\r\nsuperio_select(sioaddr, GPIO);\r\nreg25 = superio_inb(sioaddr, IT87_SIO_GPIO1_REG);\r\nreg27 = superio_inb(sioaddr, IT87_SIO_GPIO3_REG);\r\nreg2a = superio_inb(sioaddr, IT87_SIO_PINX1_REG);\r\nreg2c = superio_inb(sioaddr, IT87_SIO_PINX2_REG);\r\nregef = superio_inb(sioaddr, IT87_SIO_SPI_REG);\r\nif ((reg27 & BIT(0)) || !(reg2c & BIT(2)))\r\nsio_data->skip_fan |= BIT(2);\r\nif ((reg25 & BIT(4)) ||\r\n(!(reg2a & BIT(1)) && (regef & BIT(0))))\r\nsio_data->skip_pwm |= BIT(2);\r\nif (reg27 & BIT(7))\r\nsio_data->skip_fan |= BIT(1);\r\nif (reg27 & BIT(3))\r\nsio_data->skip_pwm |= BIT(1);\r\nif ((reg27 & BIT(0)) || (reg2c & BIT(2)))\r\nsio_data->skip_in |= BIT(5);\r\nif (reg27 & BIT(1))\r\nsio_data->skip_in |= BIT(6);\r\nif (reg27 & BIT(2)) {\r\nif (!(reg2c & BIT(1))) {\r\nreg2c |= BIT(1);\r\nsuperio_outb(sioaddr, IT87_SIO_PINX2_REG,\r\nreg2c);\r\npr_notice("Routing internal VCCH5V to in7.\n");\r\n}\r\npr_notice("in7 routed to internal voltage divider, with external pin disabled.\n");\r\npr_notice("Please report if it displays a reasonable voltage.\n");\r\n}\r\nif (reg2c & BIT(0))\r\nsio_data->internal |= BIT(0);\r\nif (reg2c & BIT(1))\r\nsio_data->internal |= BIT(1);\r\nsio_data->beep_pin = superio_inb(sioaddr,\r\nIT87_SIO_BEEP_PIN_REG) & 0x3f;\r\n} else if (sio_data->type == it8603) {\r\nint reg27, reg29;\r\nsuperio_select(sioaddr, GPIO);\r\nreg27 = superio_inb(sioaddr, IT87_SIO_GPIO3_REG);\r\nif (reg27 & BIT(6))\r\nsio_data->skip_pwm |= BIT(2);\r\nif (reg27 & BIT(7))\r\nsio_data->skip_fan |= BIT(2);\r\nreg29 = superio_inb(sioaddr, IT87_SIO_GPIO5_REG);\r\nif (reg29 & BIT(1))\r\nsio_data->skip_pwm |= BIT(1);\r\nif (reg29 & BIT(2))\r\nsio_data->skip_fan |= BIT(1);\r\nsio_data->skip_in |= BIT(5);\r\nsio_data->skip_in |= BIT(6);\r\nsio_data->beep_pin = superio_inb(sioaddr,\r\nIT87_SIO_BEEP_PIN_REG) & 0x3f;\r\n} else if (sio_data->type == it8620 || sio_data->type == it8628) {\r\nint reg;\r\nsuperio_select(sioaddr, GPIO);\r\nreg = superio_inb(sioaddr, IT87_SIO_GPIO1_REG);\r\nif (reg & BIT(6))\r\nsio_data->skip_pwm |= BIT(4);\r\nreg = superio_inb(sioaddr, IT87_SIO_GPIO2_REG);\r\nif (!(reg & BIT(5)))\r\nsio_data->skip_fan |= BIT(3);\r\nif (!(reg & BIT(4)))\r\nsio_data->skip_fan |= BIT(4);\r\nreg = superio_inb(sioaddr, IT87_SIO_GPIO3_REG);\r\nif (reg & BIT(6))\r\nsio_data->skip_pwm |= BIT(2);\r\nif (reg & BIT(7))\r\nsio_data->skip_fan |= BIT(2);\r\nreg = superio_inb(sioaddr, IT87_SIO_GPIO4_REG);\r\nif (reg & BIT(2))\r\nsio_data->skip_pwm |= BIT(3);\r\nreg = superio_inb(sioaddr, IT87_SIO_GPIO5_REG);\r\nif (reg & BIT(1))\r\nsio_data->skip_pwm |= BIT(1);\r\nif (reg & BIT(2))\r\nsio_data->skip_fan |= BIT(1);\r\nif (!(reg & BIT(7))) {\r\nsio_data->skip_pwm |= BIT(5);\r\nsio_data->skip_fan |= BIT(5);\r\n}\r\nreg = superio_inb(sioaddr, IT87_SIO_PINX2_REG);\r\nif (reg & BIT(0))\r\nsio_data->internal |= BIT(0);\r\nelse\r\nsio_data->skip_in |= BIT(9);\r\nsio_data->beep_pin = superio_inb(sioaddr,\r\nIT87_SIO_BEEP_PIN_REG) & 0x3f;\r\n} else if (sio_data->type == it8622) {\r\nint reg;\r\nsuperio_select(sioaddr, GPIO);\r\nreg = superio_inb(sioaddr, IT87_SIO_GPIO1_REG);\r\nif (reg & BIT(6))\r\nsio_data->skip_fan |= BIT(3);\r\nif (reg & BIT(5))\r\nsio_data->skip_pwm |= BIT(3);\r\nreg = superio_inb(sioaddr, IT87_SIO_GPIO3_REG);\r\nif (reg & BIT(6))\r\nsio_data->skip_pwm |= BIT(2);\r\nif (reg & BIT(7))\r\nsio_data->skip_fan |= BIT(2);\r\nif (reg & BIT(3))\r\nsio_data->skip_pwm |= BIT(4);\r\nif (reg & BIT(1))\r\nsio_data->skip_fan |= BIT(4);\r\nreg = superio_inb(sioaddr, IT87_SIO_GPIO5_REG);\r\nif (reg & BIT(1))\r\nsio_data->skip_pwm |= BIT(1);\r\nif (reg & BIT(2))\r\nsio_data->skip_fan |= BIT(1);\r\nreg = superio_inb(sioaddr, IT87_SIO_PINX2_REG);\r\nif (!(reg & BIT(0)))\r\nsio_data->skip_in |= BIT(9);\r\nsio_data->beep_pin = superio_inb(sioaddr,\r\nIT87_SIO_BEEP_PIN_REG) & 0x3f;\r\n} else {\r\nint reg;\r\nbool uart6;\r\nsuperio_select(sioaddr, GPIO);\r\nif (has_five_fans(config)) {\r\nreg = superio_inb(sioaddr, IT87_SIO_GPIO2_REG);\r\nswitch (sio_data->type) {\r\ncase it8718:\r\nif (reg & BIT(5))\r\nsio_data->skip_fan |= BIT(3);\r\nif (reg & BIT(4))\r\nsio_data->skip_fan |= BIT(4);\r\nbreak;\r\ncase it8720:\r\ncase it8721:\r\ncase it8728:\r\nif (!(reg & BIT(5)))\r\nsio_data->skip_fan |= BIT(3);\r\nif (!(reg & BIT(4)))\r\nsio_data->skip_fan |= BIT(4);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreg = superio_inb(sioaddr, IT87_SIO_GPIO3_REG);\r\nif (!sio_data->skip_vid) {\r\nif (reg & 0x0f) {\r\npr_info("VID is disabled (pins used for GPIO)\n");\r\nsio_data->skip_vid = 1;\r\n}\r\n}\r\nif (reg & BIT(6))\r\nsio_data->skip_pwm |= BIT(2);\r\nif (reg & BIT(7))\r\nsio_data->skip_fan |= BIT(2);\r\nreg = superio_inb(sioaddr, IT87_SIO_GPIO5_REG);\r\nif (reg & BIT(1))\r\nsio_data->skip_pwm |= BIT(1);\r\nif (reg & BIT(2))\r\nsio_data->skip_fan |= BIT(1);\r\nif ((sio_data->type == it8718 || sio_data->type == it8720) &&\r\n!(sio_data->skip_vid))\r\nsio_data->vid_value = superio_inb(sioaddr,\r\nIT87_SIO_VID_REG);\r\nreg = superio_inb(sioaddr, IT87_SIO_PINX2_REG);\r\nuart6 = sio_data->type == it8782 && (reg & BIT(2));\r\nif ((sio_data->type == it8720 || uart6) && !(reg & BIT(1))) {\r\nreg |= BIT(1);\r\nsuperio_outb(sioaddr, IT87_SIO_PINX2_REG, reg);\r\npr_notice("Routing internal VCCH to in7\n");\r\n}\r\nif (reg & BIT(0))\r\nsio_data->internal |= BIT(0);\r\nif (reg & BIT(1))\r\nsio_data->internal |= BIT(1);\r\nif (uart6) {\r\nsio_data->skip_in |= BIT(5) | BIT(6);\r\nsio_data->skip_temp |= BIT(2);\r\n}\r\nsio_data->beep_pin = superio_inb(sioaddr,\r\nIT87_SIO_BEEP_PIN_REG) & 0x3f;\r\n}\r\nif (sio_data->beep_pin)\r\npr_info("Beeping is supported\n");\r\nboard_vendor = dmi_get_system_info(DMI_BOARD_VENDOR);\r\nboard_name = dmi_get_system_info(DMI_BOARD_NAME);\r\nif (board_vendor && board_name) {\r\nif (strcmp(board_vendor, "nVIDIA") == 0 &&\r\nstrcmp(board_name, "FN68PT") == 0) {\r\npr_info("Disabling pwm2 due to hardware constraints\n");\r\nsio_data->skip_pwm = BIT(1);\r\n}\r\n}\r\nexit:\r\nsuperio_exit(sioaddr);\r\nreturn err;\r\n}\r\nstatic void it87_init_device(struct platform_device *pdev)\r\n{\r\nstruct it87_sio_data *sio_data = dev_get_platdata(&pdev->dev);\r\nstruct it87_data *data = platform_get_drvdata(pdev);\r\nint tmp, i;\r\nu8 mask;\r\nfor (i = 0; i < NUM_AUTO_PWM; i++) {\r\ndata->pwm_temp_map[i] = i;\r\ndata->pwm_duty[i] = 0x7f;\r\ndata->auto_pwm[i][3] = 0x7f;\r\n}\r\nfor (i = 0; i < NUM_VIN_LIMIT; i++) {\r\ntmp = it87_read_value(data, IT87_REG_VIN_MIN(i));\r\nif (tmp == 0xff)\r\nit87_write_value(data, IT87_REG_VIN_MIN(i), 0);\r\n}\r\nfor (i = 0; i < NUM_TEMP_LIMIT; i++) {\r\ntmp = it87_read_value(data, IT87_REG_TEMP_HIGH(i));\r\nif (tmp == 0xff)\r\nit87_write_value(data, IT87_REG_TEMP_HIGH(i), 127);\r\n}\r\ntmp = it87_read_value(data, IT87_REG_VIN_ENABLE);\r\nif ((tmp & 0xff) == 0) {\r\nit87_write_value(data, IT87_REG_VIN_ENABLE, 0xff);\r\n}\r\nmask = 0x70 & ~(sio_data->skip_fan << 4);\r\ndata->fan_main_ctrl = it87_read_value(data, IT87_REG_FAN_MAIN_CTRL);\r\nif ((data->fan_main_ctrl & mask) == 0) {\r\ndata->fan_main_ctrl |= mask;\r\nit87_write_value(data, IT87_REG_FAN_MAIN_CTRL,\r\ndata->fan_main_ctrl);\r\n}\r\ndata->has_fan = (data->fan_main_ctrl >> 4) & 0x07;\r\ntmp = it87_read_value(data, IT87_REG_FAN_16BIT);\r\nif (has_fan16_config(data)) {\r\nif (~tmp & 0x07 & data->has_fan) {\r\ndev_dbg(&pdev->dev,\r\n"Setting fan1-3 to 16-bit mode\n");\r\nit87_write_value(data, IT87_REG_FAN_16BIT,\r\ntmp | 0x07);\r\n}\r\n}\r\nif (has_five_fans(data)) {\r\nif (tmp & BIT(4))\r\ndata->has_fan |= BIT(3);\r\nif (tmp & BIT(5))\r\ndata->has_fan |= BIT(4);\r\nif (has_six_fans(data) && (tmp & BIT(2)))\r\ndata->has_fan |= BIT(5);\r\n}\r\ndata->has_fan &= ~sio_data->skip_fan;\r\nif (has_six_pwm(data)) {\r\ntmp = it87_read_value(data, IT87_REG_FAN_DIV);\r\nif ((tmp & 0xc0) == 0xc0)\r\nsio_data->skip_pwm |= BIT(4);\r\nif (!(tmp & BIT(3)))\r\nsio_data->skip_pwm |= BIT(5);\r\n}\r\nit87_write_value(data, IT87_REG_CONFIG,\r\n(it87_read_value(data, IT87_REG_CONFIG) & 0x3e)\r\n| (update_vbat ? 0x41 : 0x01));\r\n}\r\nstatic int it87_check_pwm(struct device *dev)\r\n{\r\nstruct it87_data *data = dev_get_drvdata(dev);\r\nint tmp = it87_read_value(data, IT87_REG_FAN_CTL);\r\nif ((tmp & 0x87) == 0) {\r\nif (fix_pwm_polarity) {\r\nint i;\r\nu8 pwm[3];\r\nfor (i = 0; i < ARRAY_SIZE(pwm); i++)\r\npwm[i] = it87_read_value(data,\r\nIT87_REG_PWM[i]);\r\nif (!((pwm[0] | pwm[1] | pwm[2]) & 0x80)) {\r\ndev_info(dev,\r\n"Reconfiguring PWM to active high polarity\n");\r\nit87_write_value(data, IT87_REG_FAN_CTL,\r\ntmp | 0x87);\r\nfor (i = 0; i < 3; i++)\r\nit87_write_value(data,\r\nIT87_REG_PWM[i],\r\n0x7f & ~pwm[i]);\r\nreturn 1;\r\n}\r\ndev_info(dev,\r\n"PWM configuration is too broken to be fixed\n");\r\n}\r\ndev_info(dev,\r\n"Detected broken BIOS defaults, disabling PWM interface\n");\r\nreturn 0;\r\n} else if (fix_pwm_polarity) {\r\ndev_info(dev,\r\n"PWM configuration looks sane, won't touch\n");\r\n}\r\nreturn 1;\r\n}\r\nstatic int it87_probe(struct platform_device *pdev)\r\n{\r\nstruct it87_data *data;\r\nstruct resource *res;\r\nstruct device *dev = &pdev->dev;\r\nstruct it87_sio_data *sio_data = dev_get_platdata(dev);\r\nint enable_pwm_interface;\r\nstruct device *hwmon_dev;\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (!devm_request_region(&pdev->dev, res->start, IT87_EC_EXTENT,\r\nDRVNAME)) {\r\ndev_err(dev, "Failed to request region 0x%lx-0x%lx\n",\r\n(unsigned long)res->start,\r\n(unsigned long)(res->start + IT87_EC_EXTENT - 1));\r\nreturn -EBUSY;\r\n}\r\ndata = devm_kzalloc(&pdev->dev, sizeof(struct it87_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->addr = res->start;\r\ndata->type = sio_data->type;\r\ndata->features = it87_devices[sio_data->type].features;\r\ndata->peci_mask = it87_devices[sio_data->type].peci_mask;\r\ndata->old_peci_mask = it87_devices[sio_data->type].old_peci_mask;\r\nswitch (data->type) {\r\ncase it87:\r\nif (sio_data->revision >= 0x03) {\r\ndata->features &= ~FEAT_OLD_AUTOPWM;\r\ndata->features |= FEAT_FAN16_CONFIG | FEAT_16BIT_FANS;\r\n}\r\nbreak;\r\ncase it8712:\r\nif (sio_data->revision >= 0x08) {\r\ndata->features &= ~FEAT_OLD_AUTOPWM;\r\ndata->features |= FEAT_FAN16_CONFIG | FEAT_16BIT_FANS |\r\nFEAT_FIVE_FANS;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif ((it87_read_value(data, IT87_REG_CONFIG) & 0x80) ||\r\nit87_read_value(data, IT87_REG_CHIPID) != 0x90)\r\nreturn -ENODEV;\r\nplatform_set_drvdata(pdev, data);\r\nmutex_init(&data->update_lock);\r\nenable_pwm_interface = it87_check_pwm(dev);\r\nif (has_12mv_adc(data)) {\r\nif (sio_data->internal & BIT(0))\r\ndata->in_scaled |= BIT(3);\r\nif (sio_data->internal & BIT(1))\r\ndata->in_scaled |= BIT(7);\r\nif (sio_data->internal & BIT(2))\r\ndata->in_scaled |= BIT(8);\r\nif (sio_data->internal & BIT(3))\r\ndata->in_scaled |= BIT(9);\r\n} else if (sio_data->type == it8781 || sio_data->type == it8782 ||\r\nsio_data->type == it8783) {\r\nif (sio_data->internal & BIT(0))\r\ndata->in_scaled |= BIT(3);\r\nif (sio_data->internal & BIT(1))\r\ndata->in_scaled |= BIT(7);\r\n}\r\ndata->has_temp = 0x07;\r\nif (sio_data->skip_temp & BIT(2)) {\r\nif (sio_data->type == it8782 &&\r\n!(it87_read_value(data, IT87_REG_TEMP_EXTRA) & 0x80))\r\ndata->has_temp &= ~BIT(2);\r\n}\r\ndata->in_internal = sio_data->internal;\r\ndata->has_in = 0x3ff & ~sio_data->skip_in;\r\nif (has_six_temp(data)) {\r\nu8 reg = it87_read_value(data, IT87_REG_TEMP456_ENABLE);\r\nif ((reg & 0x03) >= 0x02)\r\ndata->has_temp |= BIT(3);\r\nif (((reg >> 2) & 0x03) >= 0x02)\r\ndata->has_temp |= BIT(4);\r\nif (((reg >> 4) & 0x03) >= 0x02)\r\ndata->has_temp |= BIT(5);\r\nif ((reg & 0x03) == 0x01)\r\ndata->has_in |= BIT(10);\r\nif (((reg >> 2) & 0x03) == 0x01)\r\ndata->has_in |= BIT(11);\r\nif (((reg >> 4) & 0x03) == 0x01)\r\ndata->has_in |= BIT(12);\r\n}\r\ndata->has_beep = !!sio_data->beep_pin;\r\nit87_init_device(pdev);\r\nif (!sio_data->skip_vid) {\r\ndata->has_vid = true;\r\ndata->vrm = vid_which_vrm();\r\ndata->vid = sio_data->vid_value;\r\n}\r\ndata->groups[0] = &it87_group;\r\ndata->groups[1] = &it87_group_in;\r\ndata->groups[2] = &it87_group_temp;\r\ndata->groups[3] = &it87_group_fan;\r\nif (enable_pwm_interface) {\r\ndata->has_pwm = BIT(ARRAY_SIZE(IT87_REG_PWM)) - 1;\r\ndata->has_pwm &= ~sio_data->skip_pwm;\r\ndata->groups[4] = &it87_group_pwm;\r\nif (has_old_autopwm(data) || has_newer_autopwm(data))\r\ndata->groups[5] = &it87_group_auto_pwm;\r\n}\r\nhwmon_dev = devm_hwmon_device_register_with_groups(dev,\r\nit87_devices[sio_data->type].name,\r\ndata, data->groups);\r\nreturn PTR_ERR_OR_ZERO(hwmon_dev);\r\n}\r\nstatic int __init it87_device_add(int index, unsigned short address,\r\nconst struct it87_sio_data *sio_data)\r\n{\r\nstruct platform_device *pdev;\r\nstruct resource res = {\r\n.start = address + IT87_EC_OFFSET,\r\n.end = address + IT87_EC_OFFSET + IT87_EC_EXTENT - 1,\r\n.name = DRVNAME,\r\n.flags = IORESOURCE_IO,\r\n};\r\nint err;\r\nerr = acpi_check_resource_conflict(&res);\r\nif (err)\r\nreturn err;\r\npdev = platform_device_alloc(DRVNAME, address);\r\nif (!pdev)\r\nreturn -ENOMEM;\r\nerr = platform_device_add_resources(pdev, &res, 1);\r\nif (err) {\r\npr_err("Device resource addition failed (%d)\n", err);\r\ngoto exit_device_put;\r\n}\r\nerr = platform_device_add_data(pdev, sio_data,\r\nsizeof(struct it87_sio_data));\r\nif (err) {\r\npr_err("Platform data allocation failed\n");\r\ngoto exit_device_put;\r\n}\r\nerr = platform_device_add(pdev);\r\nif (err) {\r\npr_err("Device addition failed (%d)\n", err);\r\ngoto exit_device_put;\r\n}\r\nit87_pdev[index] = pdev;\r\nreturn 0;\r\nexit_device_put:\r\nplatform_device_put(pdev);\r\nreturn err;\r\n}\r\nstatic int __init sm_it87_init(void)\r\n{\r\nint sioaddr[2] = { REG_2E, REG_4E };\r\nstruct it87_sio_data sio_data;\r\nunsigned short isa_address[2];\r\nbool found = false;\r\nint i, err;\r\nerr = platform_driver_register(&it87_driver);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < ARRAY_SIZE(sioaddr); i++) {\r\nmemset(&sio_data, 0, sizeof(struct it87_sio_data));\r\nisa_address[i] = 0;\r\nerr = it87_find(sioaddr[i], &isa_address[i], &sio_data);\r\nif (err || isa_address[i] == 0)\r\ncontinue;\r\nif (i && isa_address[i] == isa_address[0])\r\nbreak;\r\nerr = it87_device_add(i, isa_address[i], &sio_data);\r\nif (err)\r\ngoto exit_dev_unregister;\r\nfound = true;\r\nif (sio_data.type == it87)\r\nbreak;\r\n}\r\nif (!found) {\r\nerr = -ENODEV;\r\ngoto exit_unregister;\r\n}\r\nreturn 0;\r\nexit_dev_unregister:\r\nplatform_device_unregister(it87_pdev[0]);\r\nexit_unregister:\r\nplatform_driver_unregister(&it87_driver);\r\nreturn err;\r\n}\r\nstatic void __exit sm_it87_exit(void)\r\n{\r\nplatform_device_unregister(it87_pdev[1]);\r\nplatform_device_unregister(it87_pdev[0]);\r\nplatform_driver_unregister(&it87_driver);\r\n}
