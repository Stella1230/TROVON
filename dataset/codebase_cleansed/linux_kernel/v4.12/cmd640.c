static void put_cmd640_reg_pci1(u16 reg, u8 val)\r\n{\r\noutl_p((reg & 0xfc) | cmd640_key, 0xcf8);\r\noutb_p(val, (reg & 3) | 0xcfc);\r\n}\r\nstatic u8 get_cmd640_reg_pci1(u16 reg)\r\n{\r\noutl_p((reg & 0xfc) | cmd640_key, 0xcf8);\r\nreturn inb_p((reg & 3) | 0xcfc);\r\n}\r\nstatic void put_cmd640_reg_pci2(u16 reg, u8 val)\r\n{\r\noutb_p(0x10, 0xcf8);\r\noutb_p(val, cmd640_key + reg);\r\noutb_p(0, 0xcf8);\r\n}\r\nstatic u8 get_cmd640_reg_pci2(u16 reg)\r\n{\r\nu8 b;\r\noutb_p(0x10, 0xcf8);\r\nb = inb_p(cmd640_key + reg);\r\noutb_p(0, 0xcf8);\r\nreturn b;\r\n}\r\nstatic void put_cmd640_reg_vlb(u16 reg, u8 val)\r\n{\r\noutb_p(reg, cmd640_key);\r\noutb_p(val, cmd640_key + 4);\r\n}\r\nstatic u8 get_cmd640_reg_vlb(u16 reg)\r\n{\r\noutb_p(reg, cmd640_key);\r\nreturn inb_p(cmd640_key + 4);\r\n}\r\nstatic u8 get_cmd640_reg(u16 reg)\r\n{\r\nunsigned long flags;\r\nu8 b;\r\nspin_lock_irqsave(&cmd640_lock, flags);\r\nb = __get_cmd640_reg(reg);\r\nspin_unlock_irqrestore(&cmd640_lock, flags);\r\nreturn b;\r\n}\r\nstatic void put_cmd640_reg(u16 reg, u8 val)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cmd640_lock, flags);\r\n__put_cmd640_reg(reg, val);\r\nspin_unlock_irqrestore(&cmd640_lock, flags);\r\n}\r\nstatic int __init match_pci_cmd640_device(void)\r\n{\r\nconst u8 ven_dev[4] = {0x95, 0x10, 0x40, 0x06};\r\nunsigned int i;\r\nfor (i = 0; i < 4; i++) {\r\nif (get_cmd640_reg(i) != ven_dev[i])\r\nreturn 0;\r\n}\r\n#ifdef STUPIDLY_TRUST_BROKEN_PCMD_ENA_BIT\r\nif ((get_cmd640_reg(PCMD) & PCMD_ENA) == 0) {\r\nprintk("ide: cmd640 on PCI disabled by BIOS\n");\r\nreturn 0;\r\n}\r\n#endif\r\nreturn 1;\r\n}\r\nstatic int __init probe_for_cmd640_pci1(void)\r\n{\r\n__get_cmd640_reg = get_cmd640_reg_pci1;\r\n__put_cmd640_reg = put_cmd640_reg_pci1;\r\nfor (cmd640_key = 0x80000000;\r\ncmd640_key <= 0x8000f800;\r\ncmd640_key += 0x800) {\r\nif (match_pci_cmd640_device())\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init probe_for_cmd640_pci2(void)\r\n{\r\n__get_cmd640_reg = get_cmd640_reg_pci2;\r\n__put_cmd640_reg = put_cmd640_reg_pci2;\r\nfor (cmd640_key = 0xc000; cmd640_key <= 0xcf00; cmd640_key += 0x100) {\r\nif (match_pci_cmd640_device())\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init probe_for_cmd640_vlb(void)\r\n{\r\nu8 b;\r\n__get_cmd640_reg = get_cmd640_reg_vlb;\r\n__put_cmd640_reg = put_cmd640_reg_vlb;\r\ncmd640_key = 0x178;\r\nb = get_cmd640_reg(CFR);\r\nif (b == 0xff || b == 0x00 || (b & CFR_AT_VESA_078h)) {\r\ncmd640_key = 0x78;\r\nb = get_cmd640_reg(CFR);\r\nif (b == 0xff || b == 0x00 || !(b & CFR_AT_VESA_078h))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int __init secondary_port_responding(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cmd640_lock, flags);\r\noutb_p(0x0a, 0x176);\r\nudelay(100);\r\nif ((inb_p(0x176) & 0x1f) != 0x0a) {\r\noutb_p(0x1a, 0x176);\r\nudelay(100);\r\nif ((inb_p(0x176) & 0x1f) != 0x1a) {\r\nspin_unlock_irqrestore(&cmd640_lock, flags);\r\nreturn 0;\r\n}\r\n}\r\nspin_unlock_irqrestore(&cmd640_lock, flags);\r\nreturn 1;\r\n}\r\nstatic void cmd640_dump_regs(void)\r\n{\r\nunsigned int reg = cmd640_vlb ? 0x50 : 0x00;\r\nprintk("ide: cmd640 internal register dump:");\r\nfor (; reg <= 0x59; reg++) {\r\nif (!(reg & 0x0f))\r\nprintk("\n%04x:", reg);\r\nprintk(" %02x", get_cmd640_reg(reg));\r\n}\r\nprintk("\n");\r\n}\r\nstatic void __set_prefetch_mode(ide_drive_t *drive, int mode)\r\n{\r\nif (mode) {\r\n#if CMD640_PREFETCH_MASKS\r\ndrive->dev_flags |= IDE_DFLAG_NO_UNMASK;\r\ndrive->dev_flags &= ~IDE_DFLAG_UNMASK;\r\n#endif\r\ndrive->dev_flags &= ~IDE_DFLAG_NO_IO_32BIT;\r\n} else {\r\ndrive->dev_flags &= ~IDE_DFLAG_NO_UNMASK;\r\ndrive->dev_flags |= IDE_DFLAG_NO_IO_32BIT;\r\ndrive->io_32bit = 0;\r\n}\r\n}\r\nstatic void __init check_prefetch(ide_drive_t *drive, unsigned int index)\r\n{\r\nu8 b = get_cmd640_reg(prefetch_regs[index]);\r\n__set_prefetch_mode(drive, (b & prefetch_masks[index]) ? 0 : 1);\r\n}\r\nstatic void set_prefetch_mode(ide_drive_t *drive, unsigned int index, int mode)\r\n{\r\nunsigned long flags;\r\nint reg = prefetch_regs[index];\r\nu8 b;\r\nspin_lock_irqsave(&cmd640_lock, flags);\r\nb = __get_cmd640_reg(reg);\r\n__set_prefetch_mode(drive, mode);\r\nif (mode)\r\nb &= ~prefetch_masks[index];\r\nelse\r\nb |= prefetch_masks[index];\r\n__put_cmd640_reg(reg, b);\r\nspin_unlock_irqrestore(&cmd640_lock, flags);\r\n}\r\nstatic void display_clocks(unsigned int index)\r\n{\r\nu8 active_count, recovery_count;\r\nactive_count = active_counts[index];\r\nif (active_count == 1)\r\n++active_count;\r\nrecovery_count = recovery_counts[index];\r\nif (active_count > 3 && recovery_count == 1)\r\n++recovery_count;\r\nif (cmd640_chip_version > 1)\r\nrecovery_count += 1;\r\nprintk(", clocks=%d/%d/%d\n", setup_counts[index], active_count, recovery_count);\r\n}\r\nstatic inline u8 pack_nibbles(u8 upper, u8 lower)\r\n{\r\nreturn ((upper & 0x0f) << 4) | (lower & 0x0f);\r\n}\r\nstatic void program_drive_counts(ide_drive_t *drive, unsigned int index)\r\n{\r\nunsigned long flags;\r\nu8 setup_count = setup_counts[index];\r\nu8 active_count = active_counts[index];\r\nu8 recovery_count = recovery_counts[index];\r\nif (index > 1) {\r\nide_drive_t *peer = ide_get_pair_dev(drive);\r\nunsigned int mate = index ^ 1;\r\nif (peer) {\r\nif (setup_count < setup_counts[mate])\r\nsetup_count = setup_counts[mate];\r\nif (active_count < active_counts[mate])\r\nactive_count = active_counts[mate];\r\nif (recovery_count < recovery_counts[mate])\r\nrecovery_count = recovery_counts[mate];\r\n}\r\n}\r\nswitch (setup_count) {\r\ncase 4: setup_count = 0x00; break;\r\ncase 3: setup_count = 0x80; break;\r\ncase 1:\r\ncase 2: setup_count = 0x40; break;\r\ndefault: setup_count = 0xc0;\r\n}\r\nspin_lock_irqsave(&cmd640_lock, flags);\r\nsetup_count |= __get_cmd640_reg(arttim_regs[index]) & 0x3f;\r\n__put_cmd640_reg(arttim_regs[index], setup_count);\r\n__put_cmd640_reg(drwtim_regs[index], pack_nibbles(active_count, recovery_count));\r\nspin_unlock_irqrestore(&cmd640_lock, flags);\r\n}\r\nstatic void cmd640_set_mode(ide_drive_t *drive, unsigned int index,\r\nu8 pio_mode, unsigned int cycle_time)\r\n{\r\nstruct ide_timing *t;\r\nint setup_time, active_time, recovery_time, clock_time;\r\nu8 setup_count, active_count, recovery_count, recovery_count2, cycle_count;\r\nint bus_speed;\r\nif (cmd640_vlb)\r\nbus_speed = ide_vlb_clk ? ide_vlb_clk : 50;\r\nelse\r\nbus_speed = ide_pci_clk ? ide_pci_clk : 33;\r\nif (pio_mode > 5)\r\npio_mode = 5;\r\nt = ide_timing_find_mode(XFER_PIO_0 + pio_mode);\r\nsetup_time = t->setup;\r\nactive_time = t->active;\r\nrecovery_time = cycle_time - (setup_time + active_time);\r\nclock_time = 1000 / bus_speed;\r\ncycle_count = DIV_ROUND_UP(cycle_time, clock_time);\r\nsetup_count = DIV_ROUND_UP(setup_time, clock_time);\r\nactive_count = DIV_ROUND_UP(active_time, clock_time);\r\nif (active_count < 2)\r\nactive_count = 2;\r\nrecovery_count = DIV_ROUND_UP(recovery_time, clock_time);\r\nrecovery_count2 = cycle_count - (setup_count + active_count);\r\nif (recovery_count2 > recovery_count)\r\nrecovery_count = recovery_count2;\r\nif (recovery_count < 2)\r\nrecovery_count = 2;\r\nif (recovery_count > 17) {\r\nactive_count += recovery_count - 17;\r\nrecovery_count = 17;\r\n}\r\nif (active_count > 16)\r\nactive_count = 16;\r\nif (cmd640_chip_version > 1)\r\nrecovery_count -= 1;\r\nif (recovery_count > 16)\r\nrecovery_count = 16;\r\nsetup_counts[index] = setup_count;\r\nactive_counts[index] = active_count;\r\nrecovery_counts[index] = recovery_count;\r\nprogram_drive_counts(drive, index);\r\n}\r\nstatic void cmd640_set_pio_mode(ide_hwif_t *hwif, ide_drive_t *drive)\r\n{\r\nunsigned int index = 0, cycle_time;\r\nconst u8 pio = drive->pio_mode - XFER_PIO_0;\r\nu8 b;\r\nswitch (pio) {\r\ncase 6:\r\ncase 7:\r\nb = get_cmd640_reg(CNTRL) & ~0x27;\r\nif (pio & 1)\r\nb |= 0x27;\r\nput_cmd640_reg(CNTRL, b);\r\nprintk("%s: %sabled cmd640 fast host timing (devsel)\n",\r\ndrive->name, (pio & 1) ? "en" : "dis");\r\nreturn;\r\ncase 8:\r\ncase 9:\r\nset_prefetch_mode(drive, index, pio & 1);\r\nprintk("%s: %sabled cmd640 prefetch\n",\r\ndrive->name, (pio & 1) ? "en" : "dis");\r\nreturn;\r\n}\r\ncycle_time = ide_pio_cycle_time(drive, pio);\r\ncmd640_set_mode(drive, index, pio, cycle_time);\r\nprintk("%s: selected cmd640 PIO mode%d (%dns)",\r\ndrive->name, pio, cycle_time);\r\ndisplay_clocks(index);\r\n}\r\nstatic void __init cmd640_init_dev(ide_drive_t *drive)\r\n{\r\nunsigned int i = drive->hwif->channel * 2 + (drive->dn & 1);\r\n#ifdef CONFIG_BLK_DEV_CMD640_ENHANCED\r\nsetup_counts[i] = 4;\r\nactive_counts[i] = 16;\r\nrecovery_counts[i] = 16;\r\nprogram_drive_counts(drive, i);\r\nset_prefetch_mode(drive, i, 0);\r\nprintk(KERN_INFO DRV_NAME ": drive%d timings/prefetch cleared\n", i);\r\n#else\r\ncheck_prefetch(drive, i);\r\nprintk(KERN_INFO DRV_NAME ": drive%d timings/prefetch(%s) preserved\n",\r\ni, (drive->dev_flags & IDE_DFLAG_NO_IO_32BIT) ? "off" : "on");\r\n#endif\r\n}\r\nstatic int cmd640_test_irq(ide_hwif_t *hwif)\r\n{\r\nint irq_reg = hwif->channel ? ARTTIM23 : CFR;\r\nu8 irq_mask = hwif->channel ? ARTTIM23_IDE23INTR :\r\nCFR_IDE01INTR;\r\nu8 irq_stat = get_cmd640_reg(irq_reg);\r\nreturn (irq_stat & irq_mask) ? 1 : 0;\r\n}\r\nstatic int pci_conf1(void)\r\n{\r\nunsigned long flags;\r\nu32 tmp;\r\nspin_lock_irqsave(&cmd640_lock, flags);\r\noutb(0x01, 0xCFB);\r\ntmp = inl(0xCF8);\r\noutl(0x80000000, 0xCF8);\r\nif (inl(0xCF8) == 0x80000000) {\r\noutl(tmp, 0xCF8);\r\nspin_unlock_irqrestore(&cmd640_lock, flags);\r\nreturn 1;\r\n}\r\noutl(tmp, 0xCF8);\r\nspin_unlock_irqrestore(&cmd640_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int pci_conf2(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cmd640_lock, flags);\r\noutb(0x00, 0xCFB);\r\noutb(0x00, 0xCF8);\r\noutb(0x00, 0xCFA);\r\nif (inb(0xCF8) == 0x00 && inb(0xCF8) == 0x00) {\r\nspin_unlock_irqrestore(&cmd640_lock, flags);\r\nreturn 1;\r\n}\r\nspin_unlock_irqrestore(&cmd640_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int __init cmd640x_init_one(unsigned long base, unsigned long ctl)\r\n{\r\nif (!request_region(base, 8, DRV_NAME)) {\r\nprintk(KERN_ERR "%s: I/O resource 0x%lX-0x%lX not free.\n",\r\nDRV_NAME, base, base + 7);\r\nreturn -EBUSY;\r\n}\r\nif (!request_region(ctl, 1, DRV_NAME)) {\r\nprintk(KERN_ERR "%s: I/O resource 0x%lX not free.\n",\r\nDRV_NAME, ctl);\r\nrelease_region(base, 8);\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init cmd640x_init(void)\r\n{\r\nint second_port_cmd640 = 0, rc;\r\nconst char *bus_type, *port2;\r\nu8 b, cfr;\r\nstruct ide_hw hw[2], *hws[2];\r\nif (cmd640_vlb && probe_for_cmd640_vlb()) {\r\nbus_type = "VLB";\r\n} else {\r\ncmd640_vlb = 0;\r\nif (pci_conf1() && probe_for_cmd640_pci1())\r\nbus_type = "PCI (type1)";\r\nelse if (pci_conf2() && probe_for_cmd640_pci2())\r\nbus_type = "PCI (type2)";\r\nelse\r\nreturn 0;\r\n}\r\nput_cmd640_reg(0x5b, 0xbd);\r\nif (get_cmd640_reg(0x5b) != 0xbd) {\r\nprintk(KERN_ERR "ide: cmd640 init failed: wrong value in reg 0x5b\n");\r\nreturn 0;\r\n}\r\nput_cmd640_reg(0x5b, 0);\r\n#ifdef CMD640_DUMP_REGS\r\ncmd640_dump_regs();\r\n#endif\r\ncfr = get_cmd640_reg(CFR);\r\ncmd640_chip_version = cfr & CFR_DEVREV;\r\nif (cmd640_chip_version == 0) {\r\nprintk("ide: bad cmd640 revision: %d\n", cmd640_chip_version);\r\nreturn 0;\r\n}\r\nrc = cmd640x_init_one(0x1f0, 0x3f6);\r\nif (rc)\r\nreturn rc;\r\nrc = cmd640x_init_one(0x170, 0x376);\r\nif (rc) {\r\nrelease_region(0x3f6, 1);\r\nrelease_region(0x1f0, 8);\r\nreturn rc;\r\n}\r\nmemset(&hw, 0, sizeof(hw));\r\nide_std_init_ports(&hw[0], 0x1f0, 0x3f6);\r\nhw[0].irq = 14;\r\nide_std_init_ports(&hw[1], 0x170, 0x376);\r\nhw[1].irq = 15;\r\nprintk(KERN_INFO "cmd640: buggy cmd640%c interface on %s, config=0x%02x"\r\n"\n", 'a' + cmd640_chip_version - 1, bus_type, cfr);\r\nhws[0] = &hw[0];\r\nput_cmd640_reg(CMDTIM, 0);\r\nput_cmd640_reg(BRST, 0x40);\r\nb = get_cmd640_reg(CNTRL);\r\nif (secondary_port_responding()) {\r\nif ((b & CNTRL_ENA_2ND)) {\r\nsecond_port_cmd640 = 1;\r\nport2 = "okay";\r\n} else if (cmd640_vlb) {\r\nsecond_port_cmd640 = 1;\r\nport2 = "alive";\r\n} else\r\nport2 = "not cmd640";\r\n} else {\r\nput_cmd640_reg(CNTRL, b ^ CNTRL_ENA_2ND);\r\nif (secondary_port_responding()) {\r\nsecond_port_cmd640 = 1;\r\nport2 = "enabled";\r\n} else {\r\nput_cmd640_reg(CNTRL, b);\r\nport2 = "not responding";\r\n}\r\n}\r\nif (second_port_cmd640)\r\nhws[1] = &hw[1];\r\nprintk(KERN_INFO "cmd640: %sserialized, secondary interface %s\n",\r\nsecond_port_cmd640 ? "" : "not ", port2);\r\n#ifdef CMD640_DUMP_REGS\r\ncmd640_dump_regs();\r\n#endif\r\nreturn ide_host_add(&cmd640_port_info, hws, second_port_cmd640 ? 2 : 1,\r\nNULL);\r\n}
