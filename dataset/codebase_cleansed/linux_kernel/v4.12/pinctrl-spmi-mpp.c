static int pmic_mpp_read(struct pmic_mpp_state *state,\r\nstruct pmic_mpp_pad *pad, unsigned int addr)\r\n{\r\nunsigned int val;\r\nint ret;\r\nret = regmap_read(state->map, pad->base + addr, &val);\r\nif (ret < 0)\r\ndev_err(state->dev, "read 0x%x failed\n", addr);\r\nelse\r\nret = val;\r\nreturn ret;\r\n}\r\nstatic int pmic_mpp_write(struct pmic_mpp_state *state,\r\nstruct pmic_mpp_pad *pad, unsigned int addr,\r\nunsigned int val)\r\n{\r\nint ret;\r\nret = regmap_write(state->map, pad->base + addr, val);\r\nif (ret < 0)\r\ndev_err(state->dev, "write 0x%x failed\n", addr);\r\nreturn ret;\r\n}\r\nstatic int pmic_mpp_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nreturn pctldev->desc->npins;\r\n}\r\nstatic const char *pmic_mpp_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned pin)\r\n{\r\nreturn pctldev->desc->pins[pin].name;\r\n}\r\nstatic int pmic_mpp_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned pin,\r\nconst unsigned **pins, unsigned *num_pins)\r\n{\r\n*pins = &pctldev->desc->pins[pin].number;\r\n*num_pins = 1;\r\nreturn 0;\r\n}\r\nstatic int pmic_mpp_get_functions_count(struct pinctrl_dev *pctldev)\r\n{\r\nreturn ARRAY_SIZE(pmic_mpp_functions);\r\n}\r\nstatic const char *pmic_mpp_get_function_name(struct pinctrl_dev *pctldev,\r\nunsigned function)\r\n{\r\nreturn pmic_mpp_functions[function];\r\n}\r\nstatic int pmic_mpp_get_function_groups(struct pinctrl_dev *pctldev,\r\nunsigned function,\r\nconst char *const **groups,\r\nunsigned *const num_qgroups)\r\n{\r\n*groups = pmic_mpp_groups;\r\n*num_qgroups = pctldev->desc->npins;\r\nreturn 0;\r\n}\r\nstatic int pmic_mpp_write_mode_ctl(struct pmic_mpp_state *state,\r\nstruct pmic_mpp_pad *pad)\r\n{\r\nunsigned int mode;\r\nunsigned int sel;\r\nunsigned int val;\r\nunsigned int en;\r\nswitch (pad->function) {\r\ncase PMIC_MPP_ANALOG:\r\nif (pad->input_enabled && pad->output_enabled)\r\nmode = PMIC_MPP_MODE_ANALOG_BIDIR;\r\nelse if (pad->input_enabled)\r\nmode = PMIC_MPP_MODE_ANALOG_INPUT;\r\nelse\r\nmode = PMIC_MPP_MODE_ANALOG_OUTPUT;\r\nbreak;\r\ncase PMIC_MPP_DIGITAL:\r\nif (pad->input_enabled && pad->output_enabled)\r\nmode = PMIC_MPP_MODE_DIGITAL_BIDIR;\r\nelse if (pad->input_enabled)\r\nmode = PMIC_MPP_MODE_DIGITAL_INPUT;\r\nelse\r\nmode = PMIC_MPP_MODE_DIGITAL_OUTPUT;\r\nbreak;\r\ncase PMIC_MPP_SINK:\r\ndefault:\r\nmode = PMIC_MPP_MODE_CURRENT_SINK;\r\nbreak;\r\n}\r\nif (pad->dtest)\r\nsel = PMIC_MPP_SELECTOR_DTEST_FIRST + pad->dtest - 1;\r\nelse if (pad->paired)\r\nsel = PMIC_MPP_SELECTOR_PAIRED;\r\nelse\r\nsel = PMIC_MPP_SELECTOR_NORMAL;\r\nen = !!pad->out_value;\r\nval = mode << PMIC_MPP_REG_MODE_DIR_SHIFT |\r\nsel << PMIC_MPP_REG_MODE_FUNCTION_SHIFT |\r\nen;\r\nreturn pmic_mpp_write(state, pad, PMIC_MPP_REG_MODE_CTL, val);\r\n}\r\nstatic int pmic_mpp_set_mux(struct pinctrl_dev *pctldev, unsigned function,\r\nunsigned pin)\r\n{\r\nstruct pmic_mpp_state *state = pinctrl_dev_get_drvdata(pctldev);\r\nstruct pmic_mpp_pad *pad;\r\nunsigned int val;\r\nint ret;\r\npad = pctldev->desc->pins[pin].drv_data;\r\npad->function = function;\r\nret = pmic_mpp_write_mode_ctl(state, pad);\r\nval = pad->is_enabled << PMIC_MPP_REG_MASTER_EN_SHIFT;\r\nreturn pmic_mpp_write(state, pad, PMIC_MPP_REG_EN_CTL, val);\r\n}\r\nstatic int pmic_mpp_config_get(struct pinctrl_dev *pctldev,\r\nunsigned int pin, unsigned long *config)\r\n{\r\nunsigned param = pinconf_to_config_param(*config);\r\nstruct pmic_mpp_pad *pad;\r\nunsigned arg = 0;\r\npad = pctldev->desc->pins[pin].drv_data;\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\narg = pad->pullup == PMIC_MPP_PULL_UP_OPEN;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nswitch (pad->pullup) {\r\ncase PMIC_MPP_PULL_UP_OPEN:\r\narg = 0;\r\nbreak;\r\ncase PMIC_MPP_PULL_UP_0P6KOHM:\r\narg = 600;\r\nbreak;\r\ncase PMIC_MPP_PULL_UP_10KOHM:\r\narg = 10000;\r\nbreak;\r\ncase PMIC_MPP_PULL_UP_30KOHM:\r\narg = 30000;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\r\narg = !pad->is_enabled;\r\nbreak;\r\ncase PIN_CONFIG_POWER_SOURCE:\r\narg = pad->power_source;\r\nbreak;\r\ncase PIN_CONFIG_INPUT_ENABLE:\r\narg = pad->input_enabled;\r\nbreak;\r\ncase PIN_CONFIG_OUTPUT:\r\narg = pad->out_value;\r\nbreak;\r\ncase PMIC_MPP_CONF_DTEST_SELECTOR:\r\narg = pad->dtest;\r\nbreak;\r\ncase PMIC_MPP_CONF_AMUX_ROUTE:\r\narg = pad->amux_input;\r\nbreak;\r\ncase PMIC_MPP_CONF_PAIRED:\r\narg = pad->paired;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\narg = pad->drive_strength;\r\nbreak;\r\ncase PMIC_MPP_CONF_ANALOG_LEVEL:\r\narg = pad->aout_level;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n*config = pinconf_to_config_packed(param, arg);\r\nreturn 0;\r\n}\r\nstatic int pmic_mpp_config_set(struct pinctrl_dev *pctldev, unsigned int pin,\r\nunsigned long *configs, unsigned nconfs)\r\n{\r\nstruct pmic_mpp_state *state = pinctrl_dev_get_drvdata(pctldev);\r\nstruct pmic_mpp_pad *pad;\r\nunsigned param, arg;\r\nunsigned int val;\r\nint i, ret;\r\npad = pctldev->desc->pins[pin].drv_data;\r\npad->is_enabled = true;\r\nfor (i = 0; i < nconfs; i++) {\r\nparam = pinconf_to_config_param(configs[i]);\r\narg = pinconf_to_config_argument(configs[i]);\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\npad->pullup = PMIC_MPP_PULL_UP_OPEN;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nswitch (arg) {\r\ncase 600:\r\npad->pullup = PMIC_MPP_PULL_UP_0P6KOHM;\r\nbreak;\r\ncase 10000:\r\npad->pullup = PMIC_MPP_PULL_UP_10KOHM;\r\nbreak;\r\ncase 30000:\r\npad->pullup = PMIC_MPP_PULL_UP_30KOHM;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\r\npad->is_enabled = false;\r\nbreak;\r\ncase PIN_CONFIG_POWER_SOURCE:\r\nif (arg >= pad->num_sources)\r\nreturn -EINVAL;\r\npad->power_source = arg;\r\nbreak;\r\ncase PIN_CONFIG_INPUT_ENABLE:\r\npad->input_enabled = arg ? true : false;\r\nbreak;\r\ncase PIN_CONFIG_OUTPUT:\r\npad->output_enabled = true;\r\npad->out_value = arg;\r\nbreak;\r\ncase PMIC_MPP_CONF_DTEST_SELECTOR:\r\npad->dtest = arg;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\narg = pad->drive_strength;\r\nbreak;\r\ncase PMIC_MPP_CONF_AMUX_ROUTE:\r\nif (arg >= PMIC_MPP_AMUX_ROUTE_ABUS4)\r\nreturn -EINVAL;\r\npad->amux_input = arg;\r\nbreak;\r\ncase PMIC_MPP_CONF_ANALOG_LEVEL:\r\npad->aout_level = arg;\r\nbreak;\r\ncase PMIC_MPP_CONF_PAIRED:\r\npad->paired = !!arg;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nval = pad->power_source << PMIC_MPP_REG_VIN_SHIFT;\r\nret = pmic_mpp_write(state, pad, PMIC_MPP_REG_DIG_VIN_CTL, val);\r\nif (ret < 0)\r\nreturn ret;\r\nif (pad->has_pullup) {\r\nval = pad->pullup << PMIC_MPP_REG_PULL_SHIFT;\r\nret = pmic_mpp_write(state, pad, PMIC_MPP_REG_DIG_PULL_CTL,\r\nval);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nval = pad->amux_input & PMIC_MPP_REG_AIN_ROUTE_MASK;\r\nret = pmic_mpp_write(state, pad, PMIC_MPP_REG_AIN_CTL, val);\r\nif (ret < 0)\r\nreturn ret;\r\nret = pmic_mpp_write(state, pad, PMIC_MPP_REG_AOUT_CTL, pad->aout_level);\r\nif (ret < 0)\r\nreturn ret;\r\nret = pmic_mpp_write_mode_ctl(state, pad);\r\nif (ret < 0)\r\nreturn ret;\r\nval = pad->is_enabled << PMIC_MPP_REG_MASTER_EN_SHIFT;\r\nreturn pmic_mpp_write(state, pad, PMIC_MPP_REG_EN_CTL, val);\r\n}\r\nstatic void pmic_mpp_config_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned pin)\r\n{\r\nstruct pmic_mpp_state *state = pinctrl_dev_get_drvdata(pctldev);\r\nstruct pmic_mpp_pad *pad;\r\nint ret;\r\nstatic const char *const biases[] = {\r\n"0.6kOhm", "10kOhm", "30kOhm", "Disabled"\r\n};\r\npad = pctldev->desc->pins[pin].drv_data;\r\nseq_printf(s, " mpp%-2d:", pin + PMIC_MPP_PHYSICAL_OFFSET);\r\nif (!pad->is_enabled) {\r\nseq_puts(s, " ---");\r\n} else {\r\nif (pad->input_enabled) {\r\nret = pmic_mpp_read(state, pad, PMIC_MPP_REG_RT_STS);\r\nif (ret < 0)\r\nreturn;\r\nret &= PMIC_MPP_REG_RT_STS_VAL_MASK;\r\npad->out_value = ret;\r\n}\r\nseq_printf(s, " %-4s", pad->output_enabled ? "out" : "in");\r\nseq_printf(s, " %-7s", pmic_mpp_functions[pad->function]);\r\nseq_printf(s, " vin-%d", pad->power_source);\r\nseq_printf(s, " %d", pad->aout_level);\r\nif (pad->has_pullup)\r\nseq_printf(s, " %-8s", biases[pad->pullup]);\r\nseq_printf(s, " %-4s", pad->out_value ? "high" : "low");\r\nif (pad->dtest)\r\nseq_printf(s, " dtest%d", pad->dtest);\r\nif (pad->paired)\r\nseq_puts(s, " paired");\r\n}\r\n}\r\nstatic int pmic_mpp_direction_input(struct gpio_chip *chip, unsigned pin)\r\n{\r\nstruct pmic_mpp_state *state = gpiochip_get_data(chip);\r\nunsigned long config;\r\nconfig = pinconf_to_config_packed(PIN_CONFIG_INPUT_ENABLE, 1);\r\nreturn pmic_mpp_config_set(state->ctrl, pin, &config, 1);\r\n}\r\nstatic int pmic_mpp_direction_output(struct gpio_chip *chip,\r\nunsigned pin, int val)\r\n{\r\nstruct pmic_mpp_state *state = gpiochip_get_data(chip);\r\nunsigned long config;\r\nconfig = pinconf_to_config_packed(PIN_CONFIG_OUTPUT, val);\r\nreturn pmic_mpp_config_set(state->ctrl, pin, &config, 1);\r\n}\r\nstatic int pmic_mpp_get(struct gpio_chip *chip, unsigned pin)\r\n{\r\nstruct pmic_mpp_state *state = gpiochip_get_data(chip);\r\nstruct pmic_mpp_pad *pad;\r\nint ret;\r\npad = state->ctrl->desc->pins[pin].drv_data;\r\nif (pad->input_enabled) {\r\nret = pmic_mpp_read(state, pad, PMIC_MPP_REG_RT_STS);\r\nif (ret < 0)\r\nreturn ret;\r\npad->out_value = ret & PMIC_MPP_REG_RT_STS_VAL_MASK;\r\n}\r\nreturn !!pad->out_value;\r\n}\r\nstatic void pmic_mpp_set(struct gpio_chip *chip, unsigned pin, int value)\r\n{\r\nstruct pmic_mpp_state *state = gpiochip_get_data(chip);\r\nunsigned long config;\r\nconfig = pinconf_to_config_packed(PIN_CONFIG_OUTPUT, value);\r\npmic_mpp_config_set(state->ctrl, pin, &config, 1);\r\n}\r\nstatic int pmic_mpp_of_xlate(struct gpio_chip *chip,\r\nconst struct of_phandle_args *gpio_desc,\r\nu32 *flags)\r\n{\r\nif (chip->of_gpio_n_cells < 2)\r\nreturn -EINVAL;\r\nif (flags)\r\n*flags = gpio_desc->args[1];\r\nreturn gpio_desc->args[0] - PMIC_MPP_PHYSICAL_OFFSET;\r\n}\r\nstatic int pmic_mpp_to_irq(struct gpio_chip *chip, unsigned pin)\r\n{\r\nstruct pmic_mpp_state *state = gpiochip_get_data(chip);\r\nstruct pmic_mpp_pad *pad;\r\npad = state->ctrl->desc->pins[pin].drv_data;\r\nreturn pad->irq;\r\n}\r\nstatic void pmic_mpp_dbg_show(struct seq_file *s, struct gpio_chip *chip)\r\n{\r\nstruct pmic_mpp_state *state = gpiochip_get_data(chip);\r\nunsigned i;\r\nfor (i = 0; i < chip->ngpio; i++) {\r\npmic_mpp_config_dbg_show(state->ctrl, s, i);\r\nseq_puts(s, "\n");\r\n}\r\n}\r\nstatic int pmic_mpp_populate(struct pmic_mpp_state *state,\r\nstruct pmic_mpp_pad *pad)\r\n{\r\nint type, subtype, val, dir;\r\nunsigned int sel;\r\ntype = pmic_mpp_read(state, pad, PMIC_MPP_REG_TYPE);\r\nif (type < 0)\r\nreturn type;\r\nif (type != PMIC_MPP_TYPE) {\r\ndev_err(state->dev, "incorrect block type 0x%x at 0x%x\n",\r\ntype, pad->base);\r\nreturn -ENODEV;\r\n}\r\nsubtype = pmic_mpp_read(state, pad, PMIC_MPP_REG_SUBTYPE);\r\nif (subtype < 0)\r\nreturn subtype;\r\nswitch (subtype) {\r\ncase PMIC_MPP_SUBTYPE_4CH_NO_ANA_OUT:\r\ncase PMIC_MPP_SUBTYPE_ULT_4CH_NO_ANA_OUT:\r\ncase PMIC_MPP_SUBTYPE_4CH_NO_SINK:\r\ncase PMIC_MPP_SUBTYPE_ULT_4CH_NO_SINK:\r\ncase PMIC_MPP_SUBTYPE_4CH_FULL_FUNC:\r\npad->num_sources = 4;\r\nbreak;\r\ncase PMIC_MPP_SUBTYPE_8CH_FULL_FUNC:\r\npad->num_sources = 8;\r\nbreak;\r\ndefault:\r\ndev_err(state->dev, "unknown MPP type 0x%x at 0x%x\n",\r\nsubtype, pad->base);\r\nreturn -ENODEV;\r\n}\r\nval = pmic_mpp_read(state, pad, PMIC_MPP_REG_MODE_CTL);\r\nif (val < 0)\r\nreturn val;\r\npad->out_value = val & PMIC_MPP_REG_MODE_VALUE_MASK;\r\ndir = val >> PMIC_MPP_REG_MODE_DIR_SHIFT;\r\ndir &= PMIC_MPP_REG_MODE_DIR_MASK;\r\nswitch (dir) {\r\ncase PMIC_MPP_MODE_DIGITAL_INPUT:\r\npad->input_enabled = true;\r\npad->output_enabled = false;\r\npad->function = PMIC_MPP_DIGITAL;\r\nbreak;\r\ncase PMIC_MPP_MODE_DIGITAL_OUTPUT:\r\npad->input_enabled = false;\r\npad->output_enabled = true;\r\npad->function = PMIC_MPP_DIGITAL;\r\nbreak;\r\ncase PMIC_MPP_MODE_DIGITAL_BIDIR:\r\npad->input_enabled = true;\r\npad->output_enabled = true;\r\npad->function = PMIC_MPP_DIGITAL;\r\nbreak;\r\ncase PMIC_MPP_MODE_ANALOG_BIDIR:\r\npad->input_enabled = true;\r\npad->output_enabled = true;\r\npad->function = PMIC_MPP_ANALOG;\r\nbreak;\r\ncase PMIC_MPP_MODE_ANALOG_INPUT:\r\npad->input_enabled = true;\r\npad->output_enabled = false;\r\npad->function = PMIC_MPP_ANALOG;\r\nbreak;\r\ncase PMIC_MPP_MODE_ANALOG_OUTPUT:\r\npad->input_enabled = false;\r\npad->output_enabled = true;\r\npad->function = PMIC_MPP_ANALOG;\r\nbreak;\r\ncase PMIC_MPP_MODE_CURRENT_SINK:\r\npad->input_enabled = false;\r\npad->output_enabled = true;\r\npad->function = PMIC_MPP_SINK;\r\nbreak;\r\ndefault:\r\ndev_err(state->dev, "unknown MPP direction\n");\r\nreturn -ENODEV;\r\n}\r\nsel = val >> PMIC_MPP_REG_MODE_FUNCTION_SHIFT;\r\nsel &= PMIC_MPP_REG_MODE_FUNCTION_MASK;\r\nif (sel >= PMIC_MPP_SELECTOR_DTEST_FIRST)\r\npad->dtest = sel + 1;\r\nelse if (sel == PMIC_MPP_SELECTOR_PAIRED)\r\npad->paired = true;\r\nval = pmic_mpp_read(state, pad, PMIC_MPP_REG_DIG_VIN_CTL);\r\nif (val < 0)\r\nreturn val;\r\npad->power_source = val >> PMIC_MPP_REG_VIN_SHIFT;\r\npad->power_source &= PMIC_MPP_REG_VIN_MASK;\r\nif (subtype != PMIC_MPP_SUBTYPE_ULT_4CH_NO_ANA_OUT &&\r\nsubtype != PMIC_MPP_SUBTYPE_ULT_4CH_NO_SINK) {\r\nval = pmic_mpp_read(state, pad, PMIC_MPP_REG_DIG_PULL_CTL);\r\nif (val < 0)\r\nreturn val;\r\npad->pullup = val >> PMIC_MPP_REG_PULL_SHIFT;\r\npad->pullup &= PMIC_MPP_REG_PULL_MASK;\r\npad->has_pullup = true;\r\n}\r\nval = pmic_mpp_read(state, pad, PMIC_MPP_REG_AIN_CTL);\r\nif (val < 0)\r\nreturn val;\r\npad->amux_input = val >> PMIC_MPP_REG_AIN_ROUTE_SHIFT;\r\npad->amux_input &= PMIC_MPP_REG_AIN_ROUTE_MASK;\r\nval = pmic_mpp_read(state, pad, PMIC_MPP_REG_SINK_CTL);\r\nif (val < 0)\r\nreturn val;\r\npad->drive_strength = val;\r\nval = pmic_mpp_read(state, pad, PMIC_MPP_REG_AOUT_CTL);\r\nif (val < 0)\r\nreturn val;\r\npad->aout_level = val;\r\nval = pmic_mpp_read(state, pad, PMIC_MPP_REG_EN_CTL);\r\nif (val < 0)\r\nreturn val;\r\npad->is_enabled = !!val;\r\nreturn 0;\r\n}\r\nstatic int pmic_mpp_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct pinctrl_pin_desc *pindesc;\r\nstruct pinctrl_desc *pctrldesc;\r\nstruct pmic_mpp_pad *pad, *pads;\r\nstruct pmic_mpp_state *state;\r\nint ret, npins, i;\r\nu32 reg;\r\nret = of_property_read_u32(dev->of_node, "reg", &reg);\r\nif (ret < 0) {\r\ndev_err(dev, "missing base address");\r\nreturn ret;\r\n}\r\nnpins = platform_irq_count(pdev);\r\nif (!npins)\r\nreturn -EINVAL;\r\nif (npins < 0)\r\nreturn npins;\r\nBUG_ON(npins > ARRAY_SIZE(pmic_mpp_groups));\r\nstate = devm_kzalloc(dev, sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, state);\r\nstate->dev = &pdev->dev;\r\nstate->map = dev_get_regmap(dev->parent, NULL);\r\npindesc = devm_kcalloc(dev, npins, sizeof(*pindesc), GFP_KERNEL);\r\nif (!pindesc)\r\nreturn -ENOMEM;\r\npads = devm_kcalloc(dev, npins, sizeof(*pads), GFP_KERNEL);\r\nif (!pads)\r\nreturn -ENOMEM;\r\npctrldesc = devm_kzalloc(dev, sizeof(*pctrldesc), GFP_KERNEL);\r\nif (!pctrldesc)\r\nreturn -ENOMEM;\r\npctrldesc->pctlops = &pmic_mpp_pinctrl_ops;\r\npctrldesc->pmxops = &pmic_mpp_pinmux_ops;\r\npctrldesc->confops = &pmic_mpp_pinconf_ops;\r\npctrldesc->owner = THIS_MODULE;\r\npctrldesc->name = dev_name(dev);\r\npctrldesc->pins = pindesc;\r\npctrldesc->npins = npins;\r\npctrldesc->num_custom_params = ARRAY_SIZE(pmic_mpp_bindings);\r\npctrldesc->custom_params = pmic_mpp_bindings;\r\n#ifdef CONFIG_DEBUG_FS\r\npctrldesc->custom_conf_items = pmic_conf_items;\r\n#endif\r\nfor (i = 0; i < npins; i++, pindesc++) {\r\npad = &pads[i];\r\npindesc->drv_data = pad;\r\npindesc->number = i;\r\npindesc->name = pmic_mpp_groups[i];\r\npad->irq = platform_get_irq(pdev, i);\r\nif (pad->irq < 0)\r\nreturn pad->irq;\r\npad->base = reg + i * PMIC_MPP_ADDRESS_RANGE;\r\nret = pmic_mpp_populate(state, pad);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nstate->chip = pmic_mpp_gpio_template;\r\nstate->chip.parent = dev;\r\nstate->chip.base = -1;\r\nstate->chip.ngpio = npins;\r\nstate->chip.label = dev_name(dev);\r\nstate->chip.of_gpio_n_cells = 2;\r\nstate->chip.can_sleep = false;\r\nstate->ctrl = devm_pinctrl_register(dev, pctrldesc, state);\r\nif (IS_ERR(state->ctrl))\r\nreturn PTR_ERR(state->ctrl);\r\nret = gpiochip_add_data(&state->chip, state);\r\nif (ret) {\r\ndev_err(state->dev, "can't add gpio chip\n");\r\nreturn ret;\r\n}\r\nret = gpiochip_add_pin_range(&state->chip, dev_name(dev), 0, 0, npins);\r\nif (ret) {\r\ndev_err(dev, "failed to add pin range\n");\r\ngoto err_range;\r\n}\r\nreturn 0;\r\nerr_range:\r\ngpiochip_remove(&state->chip);\r\nreturn ret;\r\n}\r\nstatic int pmic_mpp_remove(struct platform_device *pdev)\r\n{\r\nstruct pmic_mpp_state *state = platform_get_drvdata(pdev);\r\ngpiochip_remove(&state->chip);\r\nreturn 0;\r\n}
