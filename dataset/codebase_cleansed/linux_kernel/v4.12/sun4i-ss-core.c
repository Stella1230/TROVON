static int sun4i_ss_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nu32 v;\r\nint err, i;\r\nunsigned long cr;\r\nconst unsigned long cr_ahb = 24 * 1000 * 1000;\r\nconst unsigned long cr_mod = 150 * 1000 * 1000;\r\nstruct sun4i_ss_ctx *ss;\r\nif (!pdev->dev.of_node)\r\nreturn -ENODEV;\r\nss = devm_kzalloc(&pdev->dev, sizeof(*ss), GFP_KERNEL);\r\nif (!ss)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nss->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(ss->base)) {\r\ndev_err(&pdev->dev, "Cannot request MMIO\n");\r\nreturn PTR_ERR(ss->base);\r\n}\r\nss->ssclk = devm_clk_get(&pdev->dev, "mod");\r\nif (IS_ERR(ss->ssclk)) {\r\nerr = PTR_ERR(ss->ssclk);\r\ndev_err(&pdev->dev, "Cannot get SS clock err=%d\n", err);\r\nreturn err;\r\n}\r\ndev_dbg(&pdev->dev, "clock ss acquired\n");\r\nss->busclk = devm_clk_get(&pdev->dev, "ahb");\r\nif (IS_ERR(ss->busclk)) {\r\nerr = PTR_ERR(ss->busclk);\r\ndev_err(&pdev->dev, "Cannot get AHB SS clock err=%d\n", err);\r\nreturn err;\r\n}\r\ndev_dbg(&pdev->dev, "clock ahb_ss acquired\n");\r\nss->reset = devm_reset_control_get_optional(&pdev->dev, "ahb");\r\nif (IS_ERR(ss->reset)) {\r\nif (PTR_ERR(ss->reset) == -EPROBE_DEFER)\r\nreturn PTR_ERR(ss->reset);\r\ndev_info(&pdev->dev, "no reset control found\n");\r\nss->reset = NULL;\r\n}\r\nerr = clk_prepare_enable(ss->busclk);\r\nif (err != 0) {\r\ndev_err(&pdev->dev, "Cannot prepare_enable busclk\n");\r\nreturn err;\r\n}\r\nerr = clk_prepare_enable(ss->ssclk);\r\nif (err != 0) {\r\ndev_err(&pdev->dev, "Cannot prepare_enable ssclk\n");\r\ngoto error_ssclk;\r\n}\r\nerr = clk_set_rate(ss->ssclk, cr_mod);\r\nif (err != 0) {\r\ndev_err(&pdev->dev, "Cannot set clock rate to ssclk\n");\r\ngoto error_clk;\r\n}\r\nif (ss->reset) {\r\nerr = reset_control_deassert(ss->reset);\r\nif (err) {\r\ndev_err(&pdev->dev, "Cannot deassert reset control\n");\r\ngoto error_clk;\r\n}\r\n}\r\ncr = clk_get_rate(ss->busclk);\r\nif (cr >= cr_ahb)\r\ndev_dbg(&pdev->dev, "Clock bus %lu (%lu MHz) (must be >= %lu)\n",\r\ncr, cr / 1000000, cr_ahb);\r\nelse\r\ndev_warn(&pdev->dev, "Clock bus %lu (%lu MHz) (must be >= %lu)\n",\r\ncr, cr / 1000000, cr_ahb);\r\ncr = clk_get_rate(ss->ssclk);\r\nif (cr <= cr_mod)\r\nif (cr < cr_mod)\r\ndev_warn(&pdev->dev, "Clock ss %lu (%lu MHz) (must be <= %lu)\n",\r\ncr, cr / 1000000, cr_mod);\r\nelse\r\ndev_dbg(&pdev->dev, "Clock ss %lu (%lu MHz) (must be <= %lu)\n",\r\ncr, cr / 1000000, cr_mod);\r\nelse\r\ndev_warn(&pdev->dev, "Clock ss is at %lu (%lu MHz) (must be <= %lu)\n",\r\ncr, cr / 1000000, cr_mod);\r\nwritel(SS_ENABLED, ss->base + SS_CTL);\r\nv = readl(ss->base + SS_CTL);\r\nv >>= 16;\r\nv &= 0x07;\r\ndev_info(&pdev->dev, "Die ID %d\n", v);\r\nwritel(0, ss->base + SS_CTL);\r\nss->dev = &pdev->dev;\r\nspin_lock_init(&ss->slock);\r\nfor (i = 0; i < ARRAY_SIZE(ss_algs); i++) {\r\nss_algs[i].ss = ss;\r\nswitch (ss_algs[i].type) {\r\ncase CRYPTO_ALG_TYPE_ABLKCIPHER:\r\nerr = crypto_register_alg(&ss_algs[i].alg.crypto);\r\nif (err != 0) {\r\ndev_err(ss->dev, "Fail to register %s\n",\r\nss_algs[i].alg.crypto.cra_name);\r\ngoto error_alg;\r\n}\r\nbreak;\r\ncase CRYPTO_ALG_TYPE_AHASH:\r\nerr = crypto_register_ahash(&ss_algs[i].alg.hash);\r\nif (err != 0) {\r\ndev_err(ss->dev, "Fail to register %s\n",\r\nss_algs[i].alg.hash.halg.base.cra_name);\r\ngoto error_alg;\r\n}\r\nbreak;\r\n}\r\n}\r\nplatform_set_drvdata(pdev, ss);\r\nreturn 0;\r\nerror_alg:\r\ni--;\r\nfor (; i >= 0; i--) {\r\nswitch (ss_algs[i].type) {\r\ncase CRYPTO_ALG_TYPE_ABLKCIPHER:\r\ncrypto_unregister_alg(&ss_algs[i].alg.crypto);\r\nbreak;\r\ncase CRYPTO_ALG_TYPE_AHASH:\r\ncrypto_unregister_ahash(&ss_algs[i].alg.hash);\r\nbreak;\r\n}\r\n}\r\nif (ss->reset)\r\nreset_control_assert(ss->reset);\r\nerror_clk:\r\nclk_disable_unprepare(ss->ssclk);\r\nerror_ssclk:\r\nclk_disable_unprepare(ss->busclk);\r\nreturn err;\r\n}\r\nstatic int sun4i_ss_remove(struct platform_device *pdev)\r\n{\r\nint i;\r\nstruct sun4i_ss_ctx *ss = platform_get_drvdata(pdev);\r\nfor (i = 0; i < ARRAY_SIZE(ss_algs); i++) {\r\nswitch (ss_algs[i].type) {\r\ncase CRYPTO_ALG_TYPE_ABLKCIPHER:\r\ncrypto_unregister_alg(&ss_algs[i].alg.crypto);\r\nbreak;\r\ncase CRYPTO_ALG_TYPE_AHASH:\r\ncrypto_unregister_ahash(&ss_algs[i].alg.hash);\r\nbreak;\r\n}\r\n}\r\nwritel(0, ss->base + SS_CTL);\r\nif (ss->reset)\r\nreset_control_assert(ss->reset);\r\nclk_disable_unprepare(ss->busclk);\r\nclk_disable_unprepare(ss->ssclk);\r\nreturn 0;\r\n}
