static int ir_sharp_decode(struct rc_dev *dev, struct ir_raw_event ev)\r\n{\r\nstruct sharp_dec *data = &dev->raw->sharp;\r\nu32 msg, echo, address, command, scancode;\r\nif (!is_timing_event(ev)) {\r\nif (ev.reset)\r\ndata->state = STATE_INACTIVE;\r\nreturn 0;\r\n}\r\nIR_dprintk(2, "Sharp decode started at state %d (%uus %s)\n",\r\ndata->state, TO_US(ev.duration), TO_STR(ev.pulse));\r\nswitch (data->state) {\r\ncase STATE_INACTIVE:\r\nif (!ev.pulse)\r\nbreak;\r\nif (!eq_margin(ev.duration, SHARP_BIT_PULSE,\r\nSHARP_BIT_PULSE / 2))\r\nbreak;\r\ndata->count = 0;\r\ndata->pulse_len = ev.duration;\r\ndata->state = STATE_BIT_SPACE;\r\nreturn 0;\r\ncase STATE_BIT_PULSE:\r\nif (!ev.pulse)\r\nbreak;\r\nif (!eq_margin(ev.duration, SHARP_BIT_PULSE,\r\nSHARP_BIT_PULSE / 2))\r\nbreak;\r\ndata->pulse_len = ev.duration;\r\ndata->state = STATE_BIT_SPACE;\r\nreturn 0;\r\ncase STATE_BIT_SPACE:\r\nif (ev.pulse)\r\nbreak;\r\ndata->bits <<= 1;\r\nif (eq_margin(data->pulse_len + ev.duration, SHARP_BIT_1_PERIOD,\r\nSHARP_BIT_PULSE * 2))\r\ndata->bits |= 1;\r\nelse if (!eq_margin(data->pulse_len + ev.duration,\r\nSHARP_BIT_0_PERIOD, SHARP_BIT_PULSE * 2))\r\nbreak;\r\ndata->count++;\r\nif (data->count == SHARP_NBITS ||\r\ndata->count == SHARP_NBITS * 2)\r\ndata->state = STATE_TRAILER_PULSE;\r\nelse\r\ndata->state = STATE_BIT_PULSE;\r\nreturn 0;\r\ncase STATE_TRAILER_PULSE:\r\nif (!ev.pulse)\r\nbreak;\r\nif (!eq_margin(ev.duration, SHARP_BIT_PULSE,\r\nSHARP_BIT_PULSE / 2))\r\nbreak;\r\nif (data->count == SHARP_NBITS) {\r\nif ((data->bits & 0x3) != 0x2 &&\r\n(data->bits & 0x3) != 0x0)\r\nbreak;\r\ndata->state = STATE_ECHO_SPACE;\r\n} else {\r\ndata->state = STATE_TRAILER_SPACE;\r\n}\r\nreturn 0;\r\ncase STATE_ECHO_SPACE:\r\nif (ev.pulse)\r\nbreak;\r\nif (!eq_margin(ev.duration, SHARP_ECHO_SPACE,\r\nSHARP_ECHO_SPACE / 4))\r\nbreak;\r\ndata->state = STATE_BIT_PULSE;\r\nreturn 0;\r\ncase STATE_TRAILER_SPACE:\r\nif (ev.pulse)\r\nbreak;\r\nif (!geq_margin(ev.duration, SHARP_TRAILER_SPACE,\r\nSHARP_BIT_PULSE / 2))\r\nbreak;\r\nmsg = (data->bits >> 15) & 0x7fff;\r\necho = data->bits & 0x7fff;\r\nif ((msg ^ echo) != 0x3ff) {\r\nIR_dprintk(1,\r\n"Sharp checksum error: received 0x%04x, 0x%04x\n",\r\nmsg, echo);\r\nbreak;\r\n}\r\naddress = bitrev8((msg >> 7) & 0xf8);\r\ncommand = bitrev8((msg >> 2) & 0xff);\r\nscancode = address << 8 | command;\r\nIR_dprintk(1, "Sharp scancode 0x%04x\n", scancode);\r\nrc_keydown(dev, RC_TYPE_SHARP, scancode, 0);\r\ndata->state = STATE_INACTIVE;\r\nreturn 0;\r\n}\r\nIR_dprintk(1, "Sharp decode failed at count %d state %d (%uus %s)\n",\r\ndata->count, data->state, TO_US(ev.duration),\r\nTO_STR(ev.pulse));\r\ndata->state = STATE_INACTIVE;\r\nreturn -EINVAL;\r\n}\r\nstatic int ir_sharp_encode(enum rc_type protocol, u32 scancode,\r\nstruct ir_raw_event *events, unsigned int max)\r\n{\r\nstruct ir_raw_event *e = events;\r\nint ret;\r\nu32 raw;\r\nraw = (((bitrev8(scancode >> 8) >> 3) << 8) & 0x1f00) |\r\nbitrev8(scancode);\r\nret = ir_raw_gen_pd(&e, max, &ir_sharp_timings, SHARP_NBITS,\r\n(raw << 2) | 2);\r\nif (ret < 0)\r\nreturn ret;\r\nmax -= ret;\r\nraw = (((bitrev8(scancode >> 8) >> 3) << 8) & 0x1f00) |\r\nbitrev8(~scancode);\r\nret = ir_raw_gen_pd(&e, max, &ir_sharp_timings, SHARP_NBITS,\r\n(raw << 2) | 1);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn e - events;\r\n}\r\nstatic int __init ir_sharp_decode_init(void)\r\n{\r\nir_raw_handler_register(&sharp_handler);\r\npr_info("IR Sharp protocol handler initialized\n");\r\nreturn 0;\r\n}\r\nstatic void __exit ir_sharp_decode_exit(void)\r\n{\r\nir_raw_handler_unregister(&sharp_handler);\r\n}
