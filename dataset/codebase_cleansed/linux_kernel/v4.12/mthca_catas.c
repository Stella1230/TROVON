static void catas_reset(struct work_struct *work)\r\n{\r\nstruct mthca_dev *dev, *tmpdev;\r\nLIST_HEAD(tlist);\r\nint ret;\r\nmutex_lock(&mthca_device_mutex);\r\nspin_lock_irq(&catas_lock);\r\nlist_splice_init(&catas_list, &tlist);\r\nspin_unlock_irq(&catas_lock);\r\nlist_for_each_entry_safe(dev, tmpdev, &tlist, catas_err.list) {\r\nstruct pci_dev *pdev = dev->pdev;\r\nret = __mthca_restart_one(dev->pdev);\r\nif (ret)\r\nprintk(KERN_ERR "mthca %s: Reset failed (%d)\n",\r\npci_name(pdev), ret);\r\nelse {\r\nstruct mthca_dev *d = pci_get_drvdata(pdev);\r\nmthca_dbg(d, "Reset succeeded\n");\r\n}\r\n}\r\nmutex_unlock(&mthca_device_mutex);\r\n}\r\nstatic void handle_catas(struct mthca_dev *dev)\r\n{\r\nstruct ib_event event;\r\nunsigned long flags;\r\nconst char *type;\r\nint i;\r\nevent.device = &dev->ib_dev;\r\nevent.event = IB_EVENT_DEVICE_FATAL;\r\nevent.element.port_num = 0;\r\ndev->active = false;\r\nib_dispatch_event(&event);\r\nswitch (swab32(readl(dev->catas_err.map)) >> 24) {\r\ncase MTHCA_CATAS_TYPE_INTERNAL:\r\ntype = "internal error";\r\nbreak;\r\ncase MTHCA_CATAS_TYPE_UPLINK:\r\ntype = "uplink bus error";\r\nbreak;\r\ncase MTHCA_CATAS_TYPE_DDR:\r\ntype = "DDR data error";\r\nbreak;\r\ncase MTHCA_CATAS_TYPE_PARITY:\r\ntype = "internal parity error";\r\nbreak;\r\ndefault:\r\ntype = "unknown error";\r\nbreak;\r\n}\r\nmthca_err(dev, "Catastrophic error detected: %s\n", type);\r\nfor (i = 0; i < dev->catas_err.size; ++i)\r\nmthca_err(dev, " buf[%02x]: %08x\n",\r\ni, swab32(readl(dev->catas_err.map + i)));\r\nif (catas_reset_disable)\r\nreturn;\r\nspin_lock_irqsave(&catas_lock, flags);\r\nlist_add(&dev->catas_err.list, &catas_list);\r\nqueue_work(catas_wq, &catas_work);\r\nspin_unlock_irqrestore(&catas_lock, flags);\r\n}\r\nstatic void poll_catas(unsigned long dev_ptr)\r\n{\r\nstruct mthca_dev *dev = (struct mthca_dev *) dev_ptr;\r\nint i;\r\nfor (i = 0; i < dev->catas_err.size; ++i)\r\nif (readl(dev->catas_err.map + i)) {\r\nhandle_catas(dev);\r\nreturn;\r\n}\r\nmod_timer(&dev->catas_err.timer,\r\nround_jiffies(jiffies + MTHCA_CATAS_POLL_INTERVAL));\r\n}\r\nvoid mthca_start_catas_poll(struct mthca_dev *dev)\r\n{\r\nphys_addr_t addr;\r\ninit_timer(&dev->catas_err.timer);\r\ndev->catas_err.map = NULL;\r\naddr = pci_resource_start(dev->pdev, 0) +\r\n((pci_resource_len(dev->pdev, 0) - 1) &\r\ndev->catas_err.addr);\r\ndev->catas_err.map = ioremap(addr, dev->catas_err.size * 4);\r\nif (!dev->catas_err.map) {\r\nmthca_warn(dev, "couldn't map catastrophic error region "\r\n"at 0x%llx/0x%x\n", (unsigned long long) addr,\r\ndev->catas_err.size * 4);\r\nreturn;\r\n}\r\ndev->catas_err.timer.data = (unsigned long) dev;\r\ndev->catas_err.timer.function = poll_catas;\r\ndev->catas_err.timer.expires = jiffies + MTHCA_CATAS_POLL_INTERVAL;\r\nINIT_LIST_HEAD(&dev->catas_err.list);\r\nadd_timer(&dev->catas_err.timer);\r\n}\r\nvoid mthca_stop_catas_poll(struct mthca_dev *dev)\r\n{\r\ndel_timer_sync(&dev->catas_err.timer);\r\nif (dev->catas_err.map)\r\niounmap(dev->catas_err.map);\r\nspin_lock_irq(&catas_lock);\r\nlist_del(&dev->catas_err.list);\r\nspin_unlock_irq(&catas_lock);\r\n}\r\nint __init mthca_catas_init(void)\r\n{\r\nINIT_WORK(&catas_work, catas_reset);\r\ncatas_wq = alloc_ordered_workqueue("mthca_catas", WQ_MEM_RECLAIM);\r\nif (!catas_wq)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid mthca_catas_cleanup(void)\r\n{\r\ndestroy_workqueue(catas_wq);\r\n}
