static int tda8290_i2c_bridge(struct dvb_frontend *fe, int close)\r\n{\r\nstruct tda8290_priv *priv = fe->analog_demod_priv;\r\nunsigned char enable[2] = { 0x21, 0xC0 };\r\nunsigned char disable[2] = { 0x21, 0x00 };\r\nunsigned char *msg;\r\nif (close) {\r\nmsg = enable;\r\ntuner_i2c_xfer_send(&priv->i2c_props, msg, 2);\r\nmsleep(20);\r\n} else {\r\nmsg = disable;\r\ntuner_i2c_xfer_send(&priv->i2c_props, msg, 2);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tda8295_i2c_bridge(struct dvb_frontend *fe, int close)\r\n{\r\nstruct tda8290_priv *priv = fe->analog_demod_priv;\r\nunsigned char enable[2] = { 0x45, 0xc1 };\r\nunsigned char disable[2] = { 0x46, 0x00 };\r\nunsigned char buf[3] = { 0x45, 0x01, 0x00 };\r\nunsigned char *msg;\r\nif (close) {\r\nmsg = enable;\r\ntuner_i2c_xfer_send(&priv->i2c_props, msg, 2);\r\nmsleep(20);\r\n} else {\r\nmsg = disable;\r\ntuner_i2c_xfer_send_recv(&priv->i2c_props, msg, 1, &msg[1], 1);\r\nbuf[2] = msg[1];\r\nbuf[2] &= ~0x04;\r\ntuner_i2c_xfer_send(&priv->i2c_props, buf, 3);\r\nmsleep(5);\r\nmsg[1] |= 0x04;\r\ntuner_i2c_xfer_send(&priv->i2c_props, msg, 2);\r\n}\r\nreturn 0;\r\n}\r\nstatic void set_audio(struct dvb_frontend *fe,\r\nstruct analog_parameters *params)\r\n{\r\nstruct tda8290_priv *priv = fe->analog_demod_priv;\r\nchar* mode;\r\nif (params->std & V4L2_STD_MN) {\r\npriv->tda8290_easy_mode = 0x01;\r\nmode = "MN";\r\n} else if (params->std & V4L2_STD_B) {\r\npriv->tda8290_easy_mode = 0x02;\r\nmode = "B";\r\n} else if (params->std & V4L2_STD_GH) {\r\npriv->tda8290_easy_mode = 0x04;\r\nmode = "GH";\r\n} else if (params->std & V4L2_STD_PAL_I) {\r\npriv->tda8290_easy_mode = 0x08;\r\nmode = "I";\r\n} else if (params->std & V4L2_STD_DK) {\r\npriv->tda8290_easy_mode = 0x10;\r\nmode = "DK";\r\n} else if (params->std & V4L2_STD_SECAM_L) {\r\npriv->tda8290_easy_mode = 0x20;\r\nmode = "L";\r\n} else if (params->std & V4L2_STD_SECAM_LC) {\r\npriv->tda8290_easy_mode = 0x40;\r\nmode = "LC";\r\n} else {\r\npriv->tda8290_easy_mode = 0x10;\r\nmode = "xx";\r\n}\r\nif (params->mode == V4L2_TUNER_RADIO) {\r\npriv->tda8290_easy_mode = (priv->ver & TDA8295) ? 0x80 : 0x01;\r\ntuner_dbg("setting to radio FM\n");\r\n} else {\r\ntuner_dbg("setting tda829x to system %s\n", mode);\r\n}\r\n}\r\nstatic void tda8290_set_params(struct dvb_frontend *fe,\r\nstruct analog_parameters *params)\r\n{\r\nstruct tda8290_priv *priv = fe->analog_demod_priv;\r\nunsigned char soft_reset[] = { 0x00, 0x00 };\r\nunsigned char easy_mode[] = { 0x01, priv->tda8290_easy_mode };\r\nunsigned char expert_mode[] = { 0x01, 0x80 };\r\nunsigned char agc_out_on[] = { 0x02, 0x00 };\r\nunsigned char gainset_off[] = { 0x28, 0x14 };\r\nunsigned char if_agc_spd[] = { 0x0f, 0x88 };\r\nunsigned char adc_head_6[] = { 0x05, 0x04 };\r\nunsigned char adc_head_9[] = { 0x05, 0x02 };\r\nunsigned char adc_head_12[] = { 0x05, 0x01 };\r\nunsigned char pll_bw_nom[] = { 0x0d, 0x47 };\r\nunsigned char pll_bw_low[] = { 0x0d, 0x27 };\r\nunsigned char gainset_2[] = { 0x28, 0x64 };\r\nunsigned char agc_rst_on[] = { 0x0e, 0x0b };\r\nunsigned char agc_rst_off[] = { 0x0e, 0x09 };\r\nunsigned char if_agc_set[] = { 0x0f, 0x81 };\r\nunsigned char addr_adc_sat = 0x1a;\r\nunsigned char addr_agc_stat = 0x1d;\r\nunsigned char addr_pll_stat = 0x1b;\r\nunsigned char adc_sat, agc_stat,\r\npll_stat;\r\nint i;\r\nset_audio(fe, params);\r\nif (priv->cfg.config)\r\ntuner_dbg("tda827xa config is 0x%02x\n", priv->cfg.config);\r\ntuner_i2c_xfer_send(&priv->i2c_props, easy_mode, 2);\r\ntuner_i2c_xfer_send(&priv->i2c_props, agc_out_on, 2);\r\ntuner_i2c_xfer_send(&priv->i2c_props, soft_reset, 2);\r\nmsleep(1);\r\nif (params->mode == V4L2_TUNER_RADIO) {\r\nunsigned char deemphasis[] = { 0x13, 1 };\r\nif (deemphasis_50)\r\ndeemphasis[1] = 2;\r\nfor (i = 0; i < ARRAY_SIZE(fm_mode); i++)\r\ntuner_i2c_xfer_send(&priv->i2c_props, fm_mode[i].seq, 2);\r\ntuner_i2c_xfer_send(&priv->i2c_props, deemphasis, 2);\r\n} else {\r\nexpert_mode[1] = priv->tda8290_easy_mode + 0x80;\r\ntuner_i2c_xfer_send(&priv->i2c_props, expert_mode, 2);\r\ntuner_i2c_xfer_send(&priv->i2c_props, gainset_off, 2);\r\ntuner_i2c_xfer_send(&priv->i2c_props, if_agc_spd, 2);\r\nif (priv->tda8290_easy_mode & 0x60)\r\ntuner_i2c_xfer_send(&priv->i2c_props, adc_head_9, 2);\r\nelse\r\ntuner_i2c_xfer_send(&priv->i2c_props, adc_head_6, 2);\r\ntuner_i2c_xfer_send(&priv->i2c_props, pll_bw_nom, 2);\r\n}\r\nif (fe->ops.analog_ops.i2c_gate_ctrl)\r\nfe->ops.analog_ops.i2c_gate_ctrl(fe, 1);\r\nif (fe->ops.tuner_ops.set_analog_params)\r\nfe->ops.tuner_ops.set_analog_params(fe, params);\r\nfor (i = 0; i < 3; i++) {\r\ntuner_i2c_xfer_send_recv(&priv->i2c_props,\r\n&addr_pll_stat, 1, &pll_stat, 1);\r\nif (pll_stat & 0x80) {\r\ntuner_i2c_xfer_send_recv(&priv->i2c_props,\r\n&addr_adc_sat, 1,\r\n&adc_sat, 1);\r\ntuner_i2c_xfer_send_recv(&priv->i2c_props,\r\n&addr_agc_stat, 1,\r\n&agc_stat, 1);\r\ntuner_dbg("tda8290 is locked, AGC: %d\n", agc_stat);\r\nbreak;\r\n} else {\r\ntuner_dbg("tda8290 not locked, no signal?\n");\r\nmsleep(100);\r\n}\r\n}\r\nif ((agc_stat > 115) || (!(pll_stat & 0x80) && (adc_sat < 20))) {\r\ntuner_dbg("adjust gain, step 1. Agc: %d, ADC stat: %d, lock: %d\n",\r\nagc_stat, adc_sat, pll_stat & 0x80);\r\ntuner_i2c_xfer_send(&priv->i2c_props, gainset_2, 2);\r\nmsleep(100);\r\ntuner_i2c_xfer_send_recv(&priv->i2c_props,\r\n&addr_agc_stat, 1, &agc_stat, 1);\r\ntuner_i2c_xfer_send_recv(&priv->i2c_props,\r\n&addr_pll_stat, 1, &pll_stat, 1);\r\nif ((agc_stat > 115) || !(pll_stat & 0x80)) {\r\ntuner_dbg("adjust gain, step 2. Agc: %d, lock: %d\n",\r\nagc_stat, pll_stat & 0x80);\r\nif (priv->cfg.agcf)\r\npriv->cfg.agcf(fe);\r\nmsleep(100);\r\ntuner_i2c_xfer_send_recv(&priv->i2c_props,\r\n&addr_agc_stat, 1,\r\n&agc_stat, 1);\r\ntuner_i2c_xfer_send_recv(&priv->i2c_props,\r\n&addr_pll_stat, 1,\r\n&pll_stat, 1);\r\nif((agc_stat > 115) || !(pll_stat & 0x80)) {\r\ntuner_dbg("adjust gain, step 3. Agc: %d\n", agc_stat);\r\ntuner_i2c_xfer_send(&priv->i2c_props, adc_head_12, 2);\r\ntuner_i2c_xfer_send(&priv->i2c_props, pll_bw_low, 2);\r\nmsleep(100);\r\n}\r\n}\r\n}\r\nif(priv->tda8290_easy_mode & 0x60) {\r\ntuner_i2c_xfer_send_recv(&priv->i2c_props,\r\n&addr_adc_sat, 1,\r\n&adc_sat, 1);\r\ntuner_i2c_xfer_send_recv(&priv->i2c_props,\r\n&addr_pll_stat, 1,\r\n&pll_stat, 1);\r\nif ((adc_sat > 20) || !(pll_stat & 0x80)) {\r\ntuner_dbg("trying to resolve SECAM L deadlock\n");\r\ntuner_i2c_xfer_send(&priv->i2c_props, agc_rst_on, 2);\r\nmsleep(40);\r\ntuner_i2c_xfer_send(&priv->i2c_props, agc_rst_off, 2);\r\n}\r\n}\r\nif (fe->ops.analog_ops.i2c_gate_ctrl)\r\nfe->ops.analog_ops.i2c_gate_ctrl(fe, 0);\r\ntuner_i2c_xfer_send(&priv->i2c_props, if_agc_set, 2);\r\n}\r\nstatic void tda8295_power(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct tda8290_priv *priv = fe->analog_demod_priv;\r\nunsigned char buf[] = { 0x30, 0x00 };\r\ntuner_i2c_xfer_send_recv(&priv->i2c_props, &buf[0], 1, &buf[1], 1);\r\nif (enable)\r\nbuf[1] = 0x01;\r\nelse\r\nbuf[1] = 0x03;\r\ntuner_i2c_xfer_send(&priv->i2c_props, buf, 2);\r\n}\r\nstatic void tda8295_set_easy_mode(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct tda8290_priv *priv = fe->analog_demod_priv;\r\nunsigned char buf[] = { 0x01, 0x00 };\r\ntuner_i2c_xfer_send_recv(&priv->i2c_props, &buf[0], 1, &buf[1], 1);\r\nif (enable)\r\nbuf[1] = 0x01;\r\nelse\r\nbuf[1] = 0x00;\r\ntuner_i2c_xfer_send(&priv->i2c_props, buf, 2);\r\n}\r\nstatic void tda8295_set_video_std(struct dvb_frontend *fe)\r\n{\r\nstruct tda8290_priv *priv = fe->analog_demod_priv;\r\nunsigned char buf[] = { 0x00, priv->tda8290_easy_mode };\r\ntuner_i2c_xfer_send(&priv->i2c_props, buf, 2);\r\ntda8295_set_easy_mode(fe, 1);\r\nmsleep(20);\r\ntda8295_set_easy_mode(fe, 0);\r\n}\r\nstatic void tda8295_agc1_out(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct tda8290_priv *priv = fe->analog_demod_priv;\r\nunsigned char buf[] = { 0x02, 0x00 };\r\ntuner_i2c_xfer_send_recv(&priv->i2c_props, &buf[0], 1, &buf[1], 1);\r\nif (enable)\r\nbuf[1] &= ~0x40;\r\nelse\r\nbuf[1] |= 0x40;\r\ntuner_i2c_xfer_send(&priv->i2c_props, buf, 2);\r\n}\r\nstatic void tda8295_agc2_out(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct tda8290_priv *priv = fe->analog_demod_priv;\r\nunsigned char set_gpio_cf[] = { 0x44, 0x00 };\r\nunsigned char set_gpio_val[] = { 0x46, 0x00 };\r\ntuner_i2c_xfer_send_recv(&priv->i2c_props,\r\n&set_gpio_cf[0], 1, &set_gpio_cf[1], 1);\r\ntuner_i2c_xfer_send_recv(&priv->i2c_props,\r\n&set_gpio_val[0], 1, &set_gpio_val[1], 1);\r\nset_gpio_cf[1] &= 0xf0;\r\nif (enable) {\r\nset_gpio_cf[1] |= 0x01;\r\nset_gpio_val[1] &= 0xfe;\r\n}\r\ntuner_i2c_xfer_send(&priv->i2c_props, set_gpio_cf, 2);\r\ntuner_i2c_xfer_send(&priv->i2c_props, set_gpio_val, 2);\r\n}\r\nstatic int tda8295_has_signal(struct dvb_frontend *fe, u16 *signal)\r\n{\r\nstruct tda8290_priv *priv = fe->analog_demod_priv;\r\nunsigned char hvpll_stat = 0x26;\r\nunsigned char ret;\r\ntuner_i2c_xfer_send_recv(&priv->i2c_props, &hvpll_stat, 1, &ret, 1);\r\n*signal = (ret & 0x01) ? 65535 : 0;\r\nreturn 0;\r\n}\r\nstatic void tda8295_set_params(struct dvb_frontend *fe,\r\nstruct analog_parameters *params)\r\n{\r\nstruct tda8290_priv *priv = fe->analog_demod_priv;\r\nu16 signal = 0;\r\nunsigned char blanking_mode[] = { 0x1d, 0x00 };\r\nset_audio(fe, params);\r\ntuner_dbg("%s: freq = %d\n", __func__, params->frequency);\r\ntda8295_power(fe, 1);\r\ntda8295_agc1_out(fe, 1);\r\ntuner_i2c_xfer_send_recv(&priv->i2c_props,\r\n&blanking_mode[0], 1, &blanking_mode[1], 1);\r\ntda8295_set_video_std(fe);\r\nblanking_mode[1] = 0x03;\r\ntuner_i2c_xfer_send(&priv->i2c_props, blanking_mode, 2);\r\nmsleep(20);\r\nif (fe->ops.analog_ops.i2c_gate_ctrl)\r\nfe->ops.analog_ops.i2c_gate_ctrl(fe, 1);\r\nif (fe->ops.tuner_ops.set_analog_params)\r\nfe->ops.tuner_ops.set_analog_params(fe, params);\r\nif (priv->cfg.agcf)\r\npriv->cfg.agcf(fe);\r\ntda8295_has_signal(fe, &signal);\r\nif (signal)\r\ntuner_dbg("tda8295 is locked\n");\r\nelse\r\ntuner_dbg("tda8295 not locked, no signal?\n");\r\nif (fe->ops.analog_ops.i2c_gate_ctrl)\r\nfe->ops.analog_ops.i2c_gate_ctrl(fe, 0);\r\n}\r\nstatic int tda8290_has_signal(struct dvb_frontend *fe, u16 *signal)\r\n{\r\nstruct tda8290_priv *priv = fe->analog_demod_priv;\r\nunsigned char i2c_get_afc[1] = { 0x1B };\r\nunsigned char afc = 0;\r\ntuner_i2c_xfer_send_recv(&priv->i2c_props,\r\ni2c_get_afc, ARRAY_SIZE(i2c_get_afc), &afc, 1);\r\n*signal = (afc & 0x80) ? 65535 : 0;\r\nreturn 0;\r\n}\r\nstatic void tda8290_standby(struct dvb_frontend *fe)\r\n{\r\nstruct tda8290_priv *priv = fe->analog_demod_priv;\r\nunsigned char cb1[] = { 0x30, 0xD0 };\r\nunsigned char tda8290_standby[] = { 0x00, 0x02 };\r\nunsigned char tda8290_agc_tri[] = { 0x02, 0x20 };\r\nstruct i2c_msg msg = {.addr = priv->tda827x_addr, .flags=0, .buf=cb1, .len = 2};\r\nif (fe->ops.analog_ops.i2c_gate_ctrl)\r\nfe->ops.analog_ops.i2c_gate_ctrl(fe, 1);\r\nif (priv->ver & TDA8275A)\r\ncb1[1] = 0x90;\r\ni2c_transfer(priv->i2c_props.adap, &msg, 1);\r\nif (fe->ops.analog_ops.i2c_gate_ctrl)\r\nfe->ops.analog_ops.i2c_gate_ctrl(fe, 0);\r\ntuner_i2c_xfer_send(&priv->i2c_props, tda8290_agc_tri, 2);\r\ntuner_i2c_xfer_send(&priv->i2c_props, tda8290_standby, 2);\r\n}\r\nstatic void tda8295_standby(struct dvb_frontend *fe)\r\n{\r\ntda8295_agc1_out(fe, 0);\r\ntda8295_power(fe, 0);\r\n}\r\nstatic void tda8290_init_if(struct dvb_frontend *fe)\r\n{\r\nstruct tda8290_priv *priv = fe->analog_demod_priv;\r\nunsigned char set_VS[] = { 0x30, 0x6F };\r\nunsigned char set_GP00_CF[] = { 0x20, 0x01 };\r\nunsigned char set_GP01_CF[] = { 0x20, 0x0B };\r\nif ((priv->cfg.config == TDA8290_LNA_GP0_HIGH_ON) ||\r\n(priv->cfg.config == TDA8290_LNA_GP0_HIGH_OFF))\r\ntuner_i2c_xfer_send(&priv->i2c_props, set_GP00_CF, 2);\r\nelse\r\ntuner_i2c_xfer_send(&priv->i2c_props, set_GP01_CF, 2);\r\ntuner_i2c_xfer_send(&priv->i2c_props, set_VS, 2);\r\n}\r\nstatic void tda8295_init_if(struct dvb_frontend *fe)\r\n{\r\nstruct tda8290_priv *priv = fe->analog_demod_priv;\r\nstatic unsigned char set_adc_ctl[] = { 0x33, 0x14 };\r\nstatic unsigned char set_adc_ctl2[] = { 0x34, 0x00 };\r\nstatic unsigned char set_pll_reg6[] = { 0x3e, 0x63 };\r\nstatic unsigned char set_pll_reg0[] = { 0x38, 0x23 };\r\nstatic unsigned char set_pll_reg7[] = { 0x3f, 0x01 };\r\nstatic unsigned char set_pll_reg10[] = { 0x42, 0x61 };\r\nstatic unsigned char set_gpio_reg0[] = { 0x44, 0x0b };\r\ntda8295_power(fe, 1);\r\ntda8295_set_easy_mode(fe, 0);\r\ntda8295_set_video_std(fe);\r\ntuner_i2c_xfer_send(&priv->i2c_props, set_adc_ctl, 2);\r\ntuner_i2c_xfer_send(&priv->i2c_props, set_adc_ctl2, 2);\r\ntuner_i2c_xfer_send(&priv->i2c_props, set_pll_reg6, 2);\r\ntuner_i2c_xfer_send(&priv->i2c_props, set_pll_reg0, 2);\r\ntuner_i2c_xfer_send(&priv->i2c_props, set_pll_reg7, 2);\r\ntuner_i2c_xfer_send(&priv->i2c_props, set_pll_reg10, 2);\r\ntuner_i2c_xfer_send(&priv->i2c_props, set_gpio_reg0, 2);\r\ntda8295_agc1_out(fe, 0);\r\ntda8295_agc2_out(fe, 0);\r\n}\r\nstatic void tda8290_init_tuner(struct dvb_frontend *fe)\r\n{\r\nstruct tda8290_priv *priv = fe->analog_demod_priv;\r\nunsigned char tda8275_init[] = { 0x00, 0x00, 0x00, 0x40, 0xdC, 0x04, 0xAf,\r\n0x3F, 0x2A, 0x04, 0xFF, 0x00, 0x00, 0x40 };\r\nunsigned char tda8275a_init[] = { 0x00, 0x00, 0x00, 0x00, 0xdC, 0x05, 0x8b,\r\n0x0c, 0x04, 0x20, 0xFF, 0x00, 0x00, 0x4b };\r\nstruct i2c_msg msg = {.addr = priv->tda827x_addr, .flags=0,\r\n.buf=tda8275_init, .len = 14};\r\nif (priv->ver & TDA8275A)\r\nmsg.buf = tda8275a_init;\r\nif (fe->ops.analog_ops.i2c_gate_ctrl)\r\nfe->ops.analog_ops.i2c_gate_ctrl(fe, 1);\r\ni2c_transfer(priv->i2c_props.adap, &msg, 1);\r\nif (fe->ops.analog_ops.i2c_gate_ctrl)\r\nfe->ops.analog_ops.i2c_gate_ctrl(fe, 0);\r\n}\r\nstatic void tda829x_release(struct dvb_frontend *fe)\r\n{\r\nstruct tda8290_priv *priv = fe->analog_demod_priv;\r\nif (priv->ver & (TDA18271 | TDA8275 | TDA8275A))\r\nif (fe->ops.tuner_ops.release)\r\nfe->ops.tuner_ops.release(fe);\r\nkfree(fe->analog_demod_priv);\r\nfe->analog_demod_priv = NULL;\r\n}\r\nstatic int tda829x_find_tuner(struct dvb_frontend *fe)\r\n{\r\nstruct tda8290_priv *priv = fe->analog_demod_priv;\r\nint i, ret, tuners_found;\r\nu32 tuner_addrs;\r\nu8 data;\r\nstruct i2c_msg msg = { .flags = I2C_M_RD, .buf = &data, .len = 1 };\r\nif (fe->ops.analog_ops.i2c_gate_ctrl)\r\nfe->ops.analog_ops.i2c_gate_ctrl(fe, 1);\r\ntuners_found = 0;\r\ntuner_addrs = 0;\r\nfor (i = 0x60; i <= 0x63; i++) {\r\nmsg.addr = i;\r\nret = i2c_transfer(priv->i2c_props.adap, &msg, 1);\r\nif (ret == 1) {\r\ntuners_found++;\r\ntuner_addrs = (tuner_addrs << 8) + i;\r\n}\r\n}\r\nif (fe->ops.analog_ops.i2c_gate_ctrl)\r\nfe->ops.analog_ops.i2c_gate_ctrl(fe, 0);\r\nif (tuners_found > 1)\r\nfor (i = 0; i < tuners_found; i++) {\r\nmsg.addr = tuner_addrs & 0xff;\r\nret = i2c_transfer(priv->i2c_props.adap, &msg, 1);\r\nif (ret == 1)\r\ntuner_addrs = tuner_addrs >> 8;\r\nelse\r\nbreak;\r\n}\r\nif (tuner_addrs == 0) {\r\ntuner_addrs = 0x60;\r\ntuner_info("could not clearly identify tuner address, defaulting to %x\n",\r\ntuner_addrs);\r\n} else {\r\ntuner_addrs = tuner_addrs & 0xff;\r\ntuner_info("setting tuner address to %x\n", tuner_addrs);\r\n}\r\npriv->tda827x_addr = tuner_addrs;\r\nmsg.addr = tuner_addrs;\r\nif (fe->ops.analog_ops.i2c_gate_ctrl)\r\nfe->ops.analog_ops.i2c_gate_ctrl(fe, 1);\r\nret = i2c_transfer(priv->i2c_props.adap, &msg, 1);\r\nif (ret != 1) {\r\ntuner_warn("tuner access failed!\n");\r\nif (fe->ops.analog_ops.i2c_gate_ctrl)\r\nfe->ops.analog_ops.i2c_gate_ctrl(fe, 0);\r\nreturn -EREMOTEIO;\r\n}\r\nif ((data == 0x83) || (data == 0x84)) {\r\npriv->ver |= TDA18271;\r\ntda829x_tda18271_config.config = priv->cfg.config;\r\ntda829x_tda18271_config.std_map = priv->tda18271_std_map;\r\ndvb_attach(tda18271_attach, fe, priv->tda827x_addr,\r\npriv->i2c_props.adap, &tda829x_tda18271_config);\r\n} else {\r\nif ((data & 0x3c) == 0)\r\npriv->ver |= TDA8275;\r\nelse\r\npriv->ver |= TDA8275A;\r\ndvb_attach(tda827x_attach, fe, priv->tda827x_addr,\r\npriv->i2c_props.adap, &priv->cfg);\r\npriv->cfg.switch_addr = priv->i2c_props.addr;\r\n}\r\nif (fe->ops.tuner_ops.init)\r\nfe->ops.tuner_ops.init(fe);\r\nif (fe->ops.tuner_ops.sleep)\r\nfe->ops.tuner_ops.sleep(fe);\r\nif (fe->ops.analog_ops.i2c_gate_ctrl)\r\nfe->ops.analog_ops.i2c_gate_ctrl(fe, 0);\r\nreturn 0;\r\n}\r\nstatic int tda8290_probe(struct tuner_i2c_props *i2c_props)\r\n{\r\n#define TDA8290_ID 0x89\r\nu8 reg = 0x1f, id;\r\nstruct i2c_msg msg_read[] = {\r\n{ .addr = i2c_props->addr, .flags = 0, .len = 1, .buf = &reg },\r\n{ .addr = i2c_props->addr, .flags = I2C_M_RD, .len = 1, .buf = &id },\r\n};\r\nif (i2c_transfer(i2c_props->adap, msg_read, 2) != 2) {\r\nprintk(KERN_WARNING "%s: couldn't read register 0x%02x\n",\r\n__func__, reg);\r\nreturn -ENODEV;\r\n}\r\nif (id == TDA8290_ID) {\r\nif (debug)\r\nprintk(KERN_DEBUG "%s: tda8290 detected @ %d-%04x\n",\r\n__func__, i2c_adapter_id(i2c_props->adap),\r\ni2c_props->addr);\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int tda8295_probe(struct tuner_i2c_props *i2c_props)\r\n{\r\n#define TDA8295_ID 0x8a\r\n#define TDA8295C2_ID 0x8b\r\nu8 reg = 0x2f, id;\r\nstruct i2c_msg msg_read[] = {\r\n{ .addr = i2c_props->addr, .flags = 0, .len = 1, .buf = &reg },\r\n{ .addr = i2c_props->addr, .flags = I2C_M_RD, .len = 1, .buf = &id },\r\n};\r\nif (i2c_transfer(i2c_props->adap, msg_read, 2) != 2) {\r\nprintk(KERN_WARNING "%s: couldn't read register 0x%02x\n",\r\n__func__, reg);\r\nreturn -ENODEV;\r\n}\r\nif ((id & 0xfe) == TDA8295_ID) {\r\nif (debug)\r\nprintk(KERN_DEBUG "%s: %s detected @ %d-%04x\n",\r\n__func__, (id == TDA8295_ID) ?\r\n"tda8295c1" : "tda8295c2",\r\ni2c_adapter_id(i2c_props->adap),\r\ni2c_props->addr);\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstruct dvb_frontend *tda829x_attach(struct dvb_frontend *fe,\r\nstruct i2c_adapter *i2c_adap, u8 i2c_addr,\r\nstruct tda829x_config *cfg)\r\n{\r\nstruct tda8290_priv *priv = NULL;\r\nchar *name;\r\npriv = kzalloc(sizeof(struct tda8290_priv), GFP_KERNEL);\r\nif (priv == NULL)\r\nreturn NULL;\r\nfe->analog_demod_priv = priv;\r\npriv->i2c_props.addr = i2c_addr;\r\npriv->i2c_props.adap = i2c_adap;\r\npriv->i2c_props.name = "tda829x";\r\nif (cfg) {\r\npriv->cfg.config = cfg->lna_cfg;\r\npriv->tda18271_std_map = cfg->tda18271_std_map;\r\n}\r\nif (tda8290_probe(&priv->i2c_props) == 0) {\r\npriv->ver = TDA8290;\r\nmemcpy(&fe->ops.analog_ops, &tda8290_ops,\r\nsizeof(struct analog_demod_ops));\r\n}\r\nif (tda8295_probe(&priv->i2c_props) == 0) {\r\npriv->ver = TDA8295;\r\nmemcpy(&fe->ops.analog_ops, &tda8295_ops,\r\nsizeof(struct analog_demod_ops));\r\n}\r\nif (cfg && cfg->no_i2c_gate)\r\nfe->ops.analog_ops.i2c_gate_ctrl = NULL;\r\nif (!(cfg) || (TDA829X_PROBE_TUNER == cfg->probe_tuner)) {\r\ntda8295_power(fe, 1);\r\nif (tda829x_find_tuner(fe) < 0)\r\ngoto fail;\r\n}\r\nswitch (priv->ver) {\r\ncase TDA8290:\r\nname = "tda8290";\r\nbreak;\r\ncase TDA8295:\r\nname = "tda8295";\r\nbreak;\r\ncase TDA8290 | TDA8275:\r\nname = "tda8290+75";\r\nbreak;\r\ncase TDA8295 | TDA8275:\r\nname = "tda8295+75";\r\nbreak;\r\ncase TDA8290 | TDA8275A:\r\nname = "tda8290+75a";\r\nbreak;\r\ncase TDA8295 | TDA8275A:\r\nname = "tda8295+75a";\r\nbreak;\r\ncase TDA8290 | TDA18271:\r\nname = "tda8290+18271";\r\nbreak;\r\ncase TDA8295 | TDA18271:\r\nname = "tda8295+18271";\r\nbreak;\r\ndefault:\r\ngoto fail;\r\n}\r\ntuner_info("type set to %s\n", name);\r\nfe->ops.analog_ops.info.name = name;\r\nif (priv->ver & TDA8290) {\r\nif (priv->ver & (TDA8275 | TDA8275A))\r\ntda8290_init_tuner(fe);\r\ntda8290_init_if(fe);\r\n} else if (priv->ver & TDA8295)\r\ntda8295_init_if(fe);\r\nreturn fe;\r\nfail:\r\nmemset(&fe->ops.analog_ops, 0, sizeof(struct analog_demod_ops));\r\ntda829x_release(fe);\r\nreturn NULL;\r\n}\r\nint tda829x_probe(struct i2c_adapter *i2c_adap, u8 i2c_addr)\r\n{\r\nstruct tuner_i2c_props i2c_props = {\r\n.adap = i2c_adap,\r\n.addr = i2c_addr,\r\n};\r\nunsigned char soft_reset[] = { 0x00, 0x00 };\r\nunsigned char easy_mode_b[] = { 0x01, 0x02 };\r\nunsigned char easy_mode_g[] = { 0x01, 0x04 };\r\nunsigned char restore_9886[] = { 0x00, 0xd6, 0x30 };\r\nunsigned char addr_dto_lsb = 0x07;\r\nunsigned char data;\r\n#define PROBE_BUFFER_SIZE 8\r\nunsigned char buf[PROBE_BUFFER_SIZE];\r\nint i;\r\ntuner_i2c_xfer_send_recv(&i2c_props,\r\nsoft_reset, 1, buf, PROBE_BUFFER_SIZE);\r\nfor (i = 1; i < PROBE_BUFFER_SIZE; i++) {\r\nif (buf[i] != buf[0])\r\nbreak;\r\n}\r\nif (i == PROBE_BUFFER_SIZE)\r\nreturn -ENODEV;\r\nif ((tda8290_probe(&i2c_props) == 0) ||\r\n(tda8295_probe(&i2c_props) == 0))\r\nreturn 0;\r\ntuner_i2c_xfer_send(&i2c_props, easy_mode_b, 2);\r\ntuner_i2c_xfer_send(&i2c_props, soft_reset, 2);\r\ntuner_i2c_xfer_send_recv(&i2c_props, &addr_dto_lsb, 1, &data, 1);\r\nif (data == 0) {\r\ntuner_i2c_xfer_send(&i2c_props, easy_mode_g, 2);\r\ntuner_i2c_xfer_send(&i2c_props, soft_reset, 2);\r\ntuner_i2c_xfer_send_recv(&i2c_props,\r\n&addr_dto_lsb, 1, &data, 1);\r\nif (data == 0x7b) {\r\nreturn 0;\r\n}\r\n}\r\ntuner_i2c_xfer_send(&i2c_props, restore_9886, 3);\r\nreturn -ENODEV;\r\n}
