static void idma_getpos(dma_addr_t *src)\r\n{\r\n*src = idma.lp_tx_addr +\r\n(readl(idma.regs + I2STRNCNT) & 0xffffff) * 4;\r\n}\r\nstatic int idma_enqueue(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct idma_ctrl *prtd = substream->runtime->private_data;\r\nu32 val;\r\nspin_lock(&prtd->lock);\r\nprtd->token = (void *) substream;\r\nspin_unlock(&prtd->lock);\r\nval = idma.lp_tx_addr + prtd->periodsz;\r\nwritel(val, idma.regs + I2SLVL0ADDR);\r\nval = idma.lp_tx_addr;\r\nwritel(val, idma.regs + I2SSTR0);\r\nval = readl(idma.regs + I2SSIZE);\r\nval &= ~(I2SSIZE_TRNMSK << I2SSIZE_SHIFT);\r\nval |= (((runtime->dma_bytes >> 2) &\r\nI2SSIZE_TRNMSK) << I2SSIZE_SHIFT);\r\nwritel(val, idma.regs + I2SSIZE);\r\nval = readl(idma.regs + I2SAHB);\r\nval |= AHB_INTENLVL0;\r\nwritel(val, idma.regs + I2SAHB);\r\nreturn 0;\r\n}\r\nstatic void idma_setcallbk(struct snd_pcm_substream *substream,\r\nvoid (*cb)(void *, int))\r\n{\r\nstruct idma_ctrl *prtd = substream->runtime->private_data;\r\nspin_lock(&prtd->lock);\r\nprtd->cb = cb;\r\nspin_unlock(&prtd->lock);\r\n}\r\nstatic void idma_control(int op)\r\n{\r\nu32 val = readl(idma.regs + I2SAHB);\r\nspin_lock(&idma.lock);\r\nswitch (op) {\r\ncase LPAM_DMA_START:\r\nval |= (AHB_INTENLVL0 | AHB_DMAEN);\r\nbreak;\r\ncase LPAM_DMA_STOP:\r\nval &= ~(AHB_INTENLVL0 | AHB_DMAEN);\r\nbreak;\r\ndefault:\r\nspin_unlock(&idma.lock);\r\nreturn;\r\n}\r\nwritel(val, idma.regs + I2SAHB);\r\nspin_unlock(&idma.lock);\r\n}\r\nstatic void idma_done(void *id, int bytes_xfer)\r\n{\r\nstruct snd_pcm_substream *substream = id;\r\nstruct idma_ctrl *prtd = substream->runtime->private_data;\r\nif (prtd && (prtd->state & ST_RUNNING))\r\nsnd_pcm_period_elapsed(substream);\r\n}\r\nstatic int idma_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct idma_ctrl *prtd = substream->runtime->private_data;\r\nu32 mod = readl(idma.regs + I2SMOD);\r\nu32 ahb = readl(idma.regs + I2SAHB);\r\nahb |= (AHB_DMARLD | AHB_INTMASK);\r\nmod |= MOD_TXS_IDMA;\r\nwritel(ahb, idma.regs + I2SAHB);\r\nwritel(mod, idma.regs + I2SMOD);\r\nsnd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);\r\nruntime->dma_bytes = params_buffer_bytes(params);\r\nprtd->start = prtd->pos = runtime->dma_addr;\r\nprtd->period = params_periods(params);\r\nprtd->periodsz = params_period_bytes(params);\r\nprtd->end = runtime->dma_addr + runtime->dma_bytes;\r\nidma_setcallbk(substream, idma_done);\r\nreturn 0;\r\n}\r\nstatic int idma_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nsnd_pcm_set_runtime_buffer(substream, NULL);\r\nreturn 0;\r\n}\r\nstatic int idma_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct idma_ctrl *prtd = substream->runtime->private_data;\r\nprtd->pos = prtd->start;\r\nidma_control(LPAM_DMA_STOP);\r\nidma_enqueue(substream);\r\nreturn 0;\r\n}\r\nstatic int idma_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct idma_ctrl *prtd = substream->runtime->private_data;\r\nint ret = 0;\r\nspin_lock(&prtd->lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nprtd->state |= ST_RUNNING;\r\nidma_control(LPAM_DMA_START);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nprtd->state &= ~ST_RUNNING;\r\nidma_control(LPAM_DMA_STOP);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nspin_unlock(&prtd->lock);\r\nreturn ret;\r\n}\r\nstatic snd_pcm_uframes_t\r\nidma_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct idma_ctrl *prtd = runtime->private_data;\r\ndma_addr_t src;\r\nunsigned long res;\r\nspin_lock(&prtd->lock);\r\nidma_getpos(&src);\r\nres = src - prtd->start;\r\nspin_unlock(&prtd->lock);\r\nreturn bytes_to_frames(substream->runtime, res);\r\n}\r\nstatic int idma_mmap(struct snd_pcm_substream *substream,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned long size, offset;\r\nint ret;\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\nsize = vma->vm_end - vma->vm_start;\r\noffset = vma->vm_pgoff << PAGE_SHIFT;\r\nret = io_remap_pfn_range(vma, vma->vm_start,\r\n(runtime->dma_addr + offset) >> PAGE_SHIFT,\r\nsize, vma->vm_page_prot);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t iis_irq(int irqno, void *dev_id)\r\n{\r\nstruct idma_ctrl *prtd = (struct idma_ctrl *)dev_id;\r\nu32 iisahb, val, addr;\r\niisahb = readl(idma.regs + I2SAHB);\r\nval = (iisahb & AHB_LVL0INT) ? AHB_CLRLVL0INT : 0;\r\nif (val) {\r\niisahb |= val;\r\nwritel(iisahb, idma.regs + I2SAHB);\r\naddr = readl(idma.regs + I2SLVL0ADDR) - idma.lp_tx_addr;\r\naddr += prtd->periodsz;\r\naddr %= (u32)(prtd->end - prtd->start);\r\naddr += idma.lp_tx_addr;\r\nwritel(addr, idma.regs + I2SLVL0ADDR);\r\nif (prtd->cb)\r\nprtd->cb(prtd->token, prtd->period);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int idma_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct idma_ctrl *prtd;\r\nint ret;\r\nsnd_soc_set_runtime_hwparams(substream, &idma_hardware);\r\nprtd = kzalloc(sizeof(struct idma_ctrl), GFP_KERNEL);\r\nif (prtd == NULL)\r\nreturn -ENOMEM;\r\nret = request_irq(idma_irq, iis_irq, 0, "i2s", prtd);\r\nif (ret < 0) {\r\npr_err("fail to claim i2s irq , ret = %d\n", ret);\r\nkfree(prtd);\r\nreturn ret;\r\n}\r\nspin_lock_init(&prtd->lock);\r\nruntime->private_data = prtd;\r\nreturn 0;\r\n}\r\nstatic int idma_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct idma_ctrl *prtd = runtime->private_data;\r\nfree_irq(idma_irq, prtd);\r\nif (!prtd)\r\npr_err("idma_close called with prtd == NULL\n");\r\nkfree(prtd);\r\nreturn 0;\r\n}\r\nstatic void idma_free(struct snd_pcm *pcm)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_dma_buffer *buf;\r\nsubstream = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream;\r\nif (!substream)\r\nreturn;\r\nbuf = &substream->dma_buffer;\r\nif (!buf->area)\r\nreturn;\r\niounmap((void __iomem *)buf->area);\r\nbuf->area = NULL;\r\nbuf->addr = 0;\r\n}\r\nstatic int preallocate_idma_buffer(struct snd_pcm *pcm, int stream)\r\n{\r\nstruct snd_pcm_substream *substream = pcm->streams[stream].substream;\r\nstruct snd_dma_buffer *buf = &substream->dma_buffer;\r\nbuf->dev.dev = pcm->card->dev;\r\nbuf->private_data = NULL;\r\nbuf->dev.type = SNDRV_DMA_TYPE_CONTINUOUS;\r\nbuf->addr = idma.lp_tx_addr;\r\nbuf->bytes = idma_hardware.buffer_bytes_max;\r\nbuf->area = (unsigned char * __force)ioremap(buf->addr, buf->bytes);\r\nreturn 0;\r\n}\r\nstatic int idma_new(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct snd_card *card = rtd->card->snd_card;\r\nstruct snd_pcm *pcm = rtd->pcm;\r\nint ret;\r\nret = dma_coerce_mask_and_coherent(card->dev, DMA_BIT_MASK(32));\r\nif (ret)\r\nreturn ret;\r\nif (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {\r\nret = preallocate_idma_buffer(pcm,\r\nSNDRV_PCM_STREAM_PLAYBACK);\r\n}\r\nreturn ret;\r\n}\r\nvoid idma_reg_addr_init(void __iomem *regs, dma_addr_t addr)\r\n{\r\nspin_lock_init(&idma.lock);\r\nidma.regs = regs;\r\nidma.lp_tx_addr = addr;\r\n}\r\nstatic int asoc_idma_platform_probe(struct platform_device *pdev)\r\n{\r\nidma_irq = platform_get_irq(pdev, 0);\r\nif (idma_irq < 0)\r\nreturn idma_irq;\r\nreturn devm_snd_soc_register_platform(&pdev->dev, &asoc_idma_platform);\r\n}
