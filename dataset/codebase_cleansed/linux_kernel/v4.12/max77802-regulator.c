static inline unsigned int max77802_map_mode(unsigned int mode)\r\n{\r\nreturn mode == MAX77802_OPMODE_NORMAL ?\r\nREGULATOR_MODE_NORMAL : REGULATOR_MODE_STANDBY;\r\n}\r\nstatic int max77802_get_opmode_shift(int id)\r\n{\r\nif (id == MAX77802_BUCK1 || (id >= MAX77802_BUCK5 &&\r\nid <= MAX77802_BUCK10))\r\nreturn 0;\r\nif (id >= MAX77802_BUCK2 && id <= MAX77802_BUCK4)\r\nreturn MAX77802_OPMODE_BUCK234_SHIFT;\r\nif (id >= MAX77802_LDO1 && id <= MAX77802_LDO35)\r\nreturn MAX77802_OPMODE_SHIFT_LDO;\r\nreturn -EINVAL;\r\n}\r\nstatic int max77802_set_suspend_disable(struct regulator_dev *rdev)\r\n{\r\nunsigned int val = MAX77802_OFF_PWRREQ;\r\nstruct max77802_regulator_prv *max77802 = rdev_get_drvdata(rdev);\r\nint id = rdev_get_id(rdev);\r\nint shift = max77802_get_opmode_shift(id);\r\nmax77802->opmode[id] = val;\r\nreturn regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\r\nrdev->desc->enable_mask, val << shift);\r\n}\r\nstatic int max77802_set_mode(struct regulator_dev *rdev, unsigned int mode)\r\n{\r\nstruct max77802_regulator_prv *max77802 = rdev_get_drvdata(rdev);\r\nint id = rdev_get_id(rdev);\r\nunsigned int val;\r\nint shift = max77802_get_opmode_shift(id);\r\nswitch (mode) {\r\ncase REGULATOR_MODE_STANDBY:\r\nval = MAX77802_OPMODE_LP;\r\nbreak;\r\ncase REGULATOR_MODE_NORMAL:\r\nval = MAX77802_OPMODE_NORMAL;\r\nbreak;\r\ndefault:\r\ndev_warn(&rdev->dev, "%s: regulator mode: 0x%x not supported\n",\r\nrdev->desc->name, mode);\r\nreturn -EINVAL;\r\n}\r\nmax77802->opmode[id] = val;\r\nreturn regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\r\nrdev->desc->enable_mask, val << shift);\r\n}\r\nstatic unsigned max77802_get_mode(struct regulator_dev *rdev)\r\n{\r\nstruct max77802_regulator_prv *max77802 = rdev_get_drvdata(rdev);\r\nint id = rdev_get_id(rdev);\r\nreturn max77802_map_mode(max77802->opmode[id]);\r\n}\r\nstatic int max77802_set_suspend_mode(struct regulator_dev *rdev,\r\nunsigned int mode)\r\n{\r\nstruct max77802_regulator_prv *max77802 = rdev_get_drvdata(rdev);\r\nint id = rdev_get_id(rdev);\r\nunsigned int val;\r\nint shift = max77802_get_opmode_shift(id);\r\nif (max77802->opmode[id] == MAX77802_OFF_PWRREQ) {\r\ndev_warn(&rdev->dev, "%s: is disabled, mode: 0x%x not set\n",\r\nrdev->desc->name, mode);\r\nreturn 0;\r\n}\r\nswitch (mode) {\r\ncase REGULATOR_MODE_STANDBY:\r\nif (max77802->opmode[id] == MAX77802_OPMODE_NORMAL)\r\nval = MAX77802_LP_PWRREQ;\r\nelse\r\nreturn 0;\r\nbreak;\r\ncase REGULATOR_MODE_NORMAL:\r\nif (max77802->opmode[id] == MAX77802_OPMODE_LP)\r\ndev_warn(&rdev->dev, "%s: in Low Power: 0x%x invalid\n",\r\nrdev->desc->name, mode);\r\nreturn 0;\r\ndefault:\r\ndev_warn(&rdev->dev, "%s: regulator mode: 0x%x not supported\n",\r\nrdev->desc->name, mode);\r\nreturn -EINVAL;\r\n}\r\nreturn regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\r\nrdev->desc->enable_mask, val << shift);\r\n}\r\nstatic int max77802_enable(struct regulator_dev *rdev)\r\n{\r\nstruct max77802_regulator_prv *max77802 = rdev_get_drvdata(rdev);\r\nint id = rdev_get_id(rdev);\r\nint shift = max77802_get_opmode_shift(id);\r\nif (max77802->opmode[id] == MAX77802_OFF_PWRREQ)\r\nmax77802->opmode[id] = MAX77802_OPMODE_NORMAL;\r\nreturn regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\r\nrdev->desc->enable_mask,\r\nmax77802->opmode[id] << shift);\r\n}\r\nstatic int max77802_find_ramp_value(struct regulator_dev *rdev,\r\nconst unsigned int limits[], int size,\r\nunsigned int ramp_delay)\r\n{\r\nint i;\r\nfor (i = 0; i < size; i++) {\r\nif (ramp_delay <= limits[i])\r\nreturn i;\r\n}\r\ndev_warn(&rdev->dev, "%s: ramp_delay: %d not supported, setting 100000\n",\r\nrdev->desc->name, ramp_delay);\r\nreturn size - 1;\r\n}\r\nstatic int max77802_set_ramp_delay_2bit(struct regulator_dev *rdev,\r\nint ramp_delay)\r\n{\r\nint id = rdev_get_id(rdev);\r\nunsigned int ramp_value;\r\nif (id > MAX77802_BUCK4) {\r\ndev_warn(&rdev->dev,\r\n"%s: regulator: ramp delay not supported\n",\r\nrdev->desc->name);\r\nreturn -EINVAL;\r\n}\r\nramp_value = max77802_find_ramp_value(rdev, ramp_table_77802_2bit,\r\nARRAY_SIZE(ramp_table_77802_2bit), ramp_delay);\r\nreturn regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\r\nMAX77802_RAMP_RATE_MASK_2BIT,\r\nramp_value << MAX77802_RAMP_RATE_SHIFT_2BIT);\r\n}\r\nstatic int max77802_set_ramp_delay_4bit(struct regulator_dev *rdev,\r\nint ramp_delay)\r\n{\r\nunsigned int ramp_value;\r\nramp_value = max77802_find_ramp_value(rdev, ramp_table_77802_4bit,\r\nARRAY_SIZE(ramp_table_77802_4bit), ramp_delay);\r\nreturn regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\r\nMAX77802_RAMP_RATE_MASK_4BIT,\r\nramp_value << MAX77802_RAMP_RATE_SHIFT_4BIT);\r\n}\r\nstatic int max77802_pmic_probe(struct platform_device *pdev)\r\n{\r\nstruct max77686_dev *iodev = dev_get_drvdata(pdev->dev.parent);\r\nstruct max77802_regulator_prv *max77802;\r\nint i, val;\r\nstruct regulator_config config = { };\r\nmax77802 = devm_kzalloc(&pdev->dev,\r\nsizeof(struct max77802_regulator_prv),\r\nGFP_KERNEL);\r\nif (!max77802)\r\nreturn -ENOMEM;\r\nconfig.dev = iodev->dev;\r\nconfig.regmap = iodev->regmap;\r\nconfig.driver_data = max77802;\r\nplatform_set_drvdata(pdev, max77802);\r\nfor (i = 0; i < MAX77802_REG_MAX; i++) {\r\nstruct regulator_dev *rdev;\r\nint id = regulators[i].id;\r\nint shift = max77802_get_opmode_shift(id);\r\nint ret;\r\nret = regmap_read(iodev->regmap, regulators[i].enable_reg, &val);\r\nif (ret < 0) {\r\ndev_warn(&pdev->dev,\r\n"cannot read current mode for %d\n", i);\r\nval = MAX77802_OPMODE_NORMAL;\r\n} else {\r\nval = val >> shift & MAX77802_OPMODE_MASK;\r\n}\r\nif (val == MAX77802_STATUS_OFF)\r\nmax77802->opmode[id] = MAX77802_OPMODE_NORMAL;\r\nelse\r\nmax77802->opmode[id] = val;\r\nrdev = devm_regulator_register(&pdev->dev,\r\n&regulators[i], &config);\r\nif (IS_ERR(rdev)) {\r\nret = PTR_ERR(rdev);\r\ndev_err(&pdev->dev,\r\n"regulator init failed for %d: %d\n", i, ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}
