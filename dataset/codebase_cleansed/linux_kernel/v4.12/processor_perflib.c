static int acpi_processor_ppc_notifier(struct notifier_block *nb,\r\nunsigned long event, void *data)\r\n{\r\nstruct cpufreq_policy *policy = data;\r\nstruct acpi_processor *pr;\r\nunsigned int ppc = 0;\r\nif (ignore_ppc < 0)\r\nignore_ppc = 0;\r\nif (ignore_ppc)\r\nreturn 0;\r\nif (event != CPUFREQ_ADJUST)\r\nreturn 0;\r\nmutex_lock(&performance_mutex);\r\npr = per_cpu(processors, policy->cpu);\r\nif (!pr || !pr->performance)\r\ngoto out;\r\nppc = (unsigned int)pr->performance_platform_limit;\r\nif (ppc >= pr->performance->state_count)\r\ngoto out;\r\ncpufreq_verify_within_limits(policy, 0,\r\npr->performance->states[ppc].\r\ncore_frequency * 1000);\r\nout:\r\nmutex_unlock(&performance_mutex);\r\nreturn 0;\r\n}\r\nstatic int acpi_processor_get_platform_limit(struct acpi_processor *pr)\r\n{\r\nacpi_status status = 0;\r\nunsigned long long ppc = 0;\r\nif (!pr)\r\nreturn -EINVAL;\r\nstatus = acpi_evaluate_integer(pr->handle, "_PPC", NULL, &ppc);\r\nif (status != AE_NOT_FOUND)\r\nacpi_processor_ppc_status |= PPC_IN_USE;\r\nif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\r\nACPI_EXCEPTION((AE_INFO, status, "Evaluating _PPC"));\r\nreturn -ENODEV;\r\n}\r\npr_debug("CPU %d: _PPC is %d - frequency %s limited\n", pr->id,\r\n(int)ppc, ppc ? "" : "not");\r\npr->performance_platform_limit = (int)ppc;\r\nreturn 0;\r\n}\r\nstatic void acpi_processor_ppc_ost(acpi_handle handle, int status)\r\n{\r\nif (acpi_has_method(handle, "_OST"))\r\nacpi_evaluate_ost(handle, ACPI_PROCESSOR_NOTIFY_PERFORMANCE,\r\nstatus, NULL);\r\n}\r\nvoid acpi_processor_ppc_has_changed(struct acpi_processor *pr, int event_flag)\r\n{\r\nint ret;\r\nif (ignore_ppc) {\r\nif (event_flag)\r\nacpi_processor_ppc_ost(pr->handle, 1);\r\nreturn;\r\n}\r\nret = acpi_processor_get_platform_limit(pr);\r\nif (event_flag) {\r\nif (ret < 0)\r\nacpi_processor_ppc_ost(pr->handle, 1);\r\nelse\r\nacpi_processor_ppc_ost(pr->handle, 0);\r\n}\r\nif (ret >= 0)\r\ncpufreq_update_policy(pr->id);\r\n}\r\nint acpi_processor_get_bios_limit(int cpu, unsigned int *limit)\r\n{\r\nstruct acpi_processor *pr;\r\npr = per_cpu(processors, cpu);\r\nif (!pr || !pr->performance || !pr->performance->state_count)\r\nreturn -ENODEV;\r\n*limit = pr->performance->states[pr->performance_platform_limit].\r\ncore_frequency * 1000;\r\nreturn 0;\r\n}\r\nvoid acpi_processor_ppc_init(void)\r\n{\r\nif (!cpufreq_register_notifier\r\n(&acpi_ppc_notifier_block, CPUFREQ_POLICY_NOTIFIER))\r\nacpi_processor_ppc_status |= PPC_REGISTERED;\r\nelse\r\nprintk(KERN_DEBUG\r\n"Warning: Processor Platform Limit not supported.\n");\r\n}\r\nvoid acpi_processor_ppc_exit(void)\r\n{\r\nif (acpi_processor_ppc_status & PPC_REGISTERED)\r\ncpufreq_unregister_notifier(&acpi_ppc_notifier_block,\r\nCPUFREQ_POLICY_NOTIFIER);\r\nacpi_processor_ppc_status &= ~PPC_REGISTERED;\r\n}\r\nstatic int acpi_processor_get_performance_control(struct acpi_processor *pr)\r\n{\r\nint result = 0;\r\nacpi_status status = 0;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *pct = NULL;\r\nunion acpi_object obj = { 0 };\r\nstatus = acpi_evaluate_object(pr->handle, "_PCT", NULL, &buffer);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "Evaluating _PCT"));\r\nreturn -ENODEV;\r\n}\r\npct = (union acpi_object *)buffer.pointer;\r\nif (!pct || (pct->type != ACPI_TYPE_PACKAGE)\r\n|| (pct->package.count != 2)) {\r\nprintk(KERN_ERR PREFIX "Invalid _PCT data\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\nobj = pct->package.elements[0];\r\nif ((obj.type != ACPI_TYPE_BUFFER)\r\n|| (obj.buffer.length < sizeof(struct acpi_pct_register))\r\n|| (obj.buffer.pointer == NULL)) {\r\nprintk(KERN_ERR PREFIX "Invalid _PCT data (control_register)\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\nmemcpy(&pr->performance->control_register, obj.buffer.pointer,\r\nsizeof(struct acpi_pct_register));\r\nobj = pct->package.elements[1];\r\nif ((obj.type != ACPI_TYPE_BUFFER)\r\n|| (obj.buffer.length < sizeof(struct acpi_pct_register))\r\n|| (obj.buffer.pointer == NULL)) {\r\nprintk(KERN_ERR PREFIX "Invalid _PCT data (status_register)\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\nmemcpy(&pr->performance->status_register, obj.buffer.pointer,\r\nsizeof(struct acpi_pct_register));\r\nend:\r\nkfree(buffer.pointer);\r\nreturn result;\r\n}\r\nstatic void amd_fixup_frequency(struct acpi_processor_px *px, int i)\r\n{\r\nu32 hi, lo, fid, did;\r\nint index = px->control & 0x00000007;\r\nif (boot_cpu_data.x86_vendor != X86_VENDOR_AMD)\r\nreturn;\r\nif ((boot_cpu_data.x86 == 0x10 && boot_cpu_data.x86_model < 10)\r\n|| boot_cpu_data.x86 == 0x11) {\r\nrdmsr(MSR_AMD_PSTATE_DEF_BASE + index, lo, hi);\r\nif (!(hi & BIT(31)))\r\nreturn;\r\nfid = lo & 0x3f;\r\ndid = (lo >> 6) & 7;\r\nif (boot_cpu_data.x86 == 0x10)\r\npx->core_frequency = (100 * (fid + 0x10)) >> did;\r\nelse\r\npx->core_frequency = (100 * (fid + 8)) >> did;\r\n}\r\n}\r\nstatic void amd_fixup_frequency(struct acpi_processor_px *px, int i) {}\r\nstatic int acpi_processor_get_performance_states(struct acpi_processor *pr)\r\n{\r\nint result = 0;\r\nacpi_status status = AE_OK;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nstruct acpi_buffer format = { sizeof("NNNNNN"), "NNNNNN" };\r\nstruct acpi_buffer state = { 0, NULL };\r\nunion acpi_object *pss = NULL;\r\nint i;\r\nint last_invalid = -1;\r\nstatus = acpi_evaluate_object(pr->handle, "_PSS", NULL, &buffer);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "Evaluating _PSS"));\r\nreturn -ENODEV;\r\n}\r\npss = buffer.pointer;\r\nif (!pss || (pss->type != ACPI_TYPE_PACKAGE)) {\r\nprintk(KERN_ERR PREFIX "Invalid _PSS data\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found %d performance states\n",\r\npss->package.count));\r\npr->performance->state_count = pss->package.count;\r\npr->performance->states =\r\nkmalloc(sizeof(struct acpi_processor_px) * pss->package.count,\r\nGFP_KERNEL);\r\nif (!pr->performance->states) {\r\nresult = -ENOMEM;\r\ngoto end;\r\n}\r\nfor (i = 0; i < pr->performance->state_count; i++) {\r\nstruct acpi_processor_px *px = &(pr->performance->states[i]);\r\nstate.length = sizeof(struct acpi_processor_px);\r\nstate.pointer = px;\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Extracting state %d\n", i));\r\nstatus = acpi_extract_package(&(pss->package.elements[i]),\r\n&format, &state);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "Invalid _PSS data"));\r\nresult = -EFAULT;\r\nkfree(pr->performance->states);\r\ngoto end;\r\n}\r\namd_fixup_frequency(px, i);\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"State [%d]: core_frequency[%d] power[%d] transition_latency[%d] bus_master_latency[%d] control[0x%x] status[0x%x]\n",\r\ni,\r\n(u32) px->core_frequency,\r\n(u32) px->power,\r\n(u32) px->transition_latency,\r\n(u32) px->bus_master_latency,\r\n(u32) px->control, (u32) px->status));\r\nif (!px->core_frequency ||\r\n((u32)(px->core_frequency * 1000) !=\r\n(px->core_frequency * 1000))) {\r\nprintk(KERN_ERR FW_BUG PREFIX\r\n"Invalid BIOS _PSS frequency found for processor %d: 0x%llx MHz\n",\r\npr->id, px->core_frequency);\r\nif (last_invalid == -1)\r\nlast_invalid = i;\r\n} else {\r\nif (last_invalid != -1) {\r\nmemcpy(&(pr->performance->states[last_invalid]),\r\npx, sizeof(struct acpi_processor_px));\r\n++last_invalid;\r\n}\r\n}\r\n}\r\nif (last_invalid == 0) {\r\nprintk(KERN_ERR FW_BUG PREFIX\r\n"No valid BIOS _PSS frequency found for processor %d\n", pr->id);\r\nresult = -EFAULT;\r\nkfree(pr->performance->states);\r\npr->performance->states = NULL;\r\n}\r\nif (last_invalid > 0)\r\npr->performance->state_count = last_invalid;\r\nend:\r\nkfree(buffer.pointer);\r\nreturn result;\r\n}\r\nint acpi_processor_get_performance_info(struct acpi_processor *pr)\r\n{\r\nint result = 0;\r\nif (!pr || !pr->performance || !pr->handle)\r\nreturn -EINVAL;\r\nif (!acpi_has_method(pr->handle, "_PCT")) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"ACPI-based processor performance control unavailable\n"));\r\nreturn -ENODEV;\r\n}\r\nresult = acpi_processor_get_performance_control(pr);\r\nif (result)\r\ngoto update_bios;\r\nresult = acpi_processor_get_performance_states(pr);\r\nif (result)\r\ngoto update_bios;\r\nif (ignore_ppc != 1)\r\nresult = acpi_processor_get_platform_limit(pr);\r\nreturn result;\r\nupdate_bios:\r\n#ifdef CONFIG_X86\r\nif (acpi_has_method(pr->handle, "_PPC")) {\r\nif(boot_cpu_has(X86_FEATURE_EST))\r\nprintk(KERN_WARNING FW_BUG "BIOS needs update for CPU "\r\n"frequency support\n");\r\n}\r\n#endif\r\nreturn result;\r\n}\r\nint acpi_processor_pstate_control(void)\r\n{\r\nacpi_status status;\r\nif (!acpi_gbl_FADT.smi_command || !acpi_gbl_FADT.pstate_control)\r\nreturn 0;\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Writing pstate_control [0x%x] to smi_command [0x%x]\n",\r\nacpi_gbl_FADT.pstate_control, acpi_gbl_FADT.smi_command));\r\nstatus = acpi_os_write_port(acpi_gbl_FADT.smi_command,\r\n(u32)acpi_gbl_FADT.pstate_control, 8);\r\nif (ACPI_SUCCESS(status))\r\nreturn 1;\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"Failed to write pstate_control [0x%x] to smi_command [0x%x]",\r\nacpi_gbl_FADT.pstate_control, acpi_gbl_FADT.smi_command));\r\nreturn -EIO;\r\n}\r\nint acpi_processor_notify_smm(struct module *calling_module)\r\n{\r\nstatic int is_done = 0;\r\nint result;\r\nif (!(acpi_processor_ppc_status & PPC_REGISTERED))\r\nreturn -EBUSY;\r\nif (!try_module_get(calling_module))\r\nreturn -EINVAL;\r\nif (is_done > 0) {\r\nmodule_put(calling_module);\r\nreturn 0;\r\n} else if (is_done < 0) {\r\nmodule_put(calling_module);\r\nreturn is_done;\r\n}\r\nis_done = -EIO;\r\nresult = acpi_processor_pstate_control();\r\nif (!result) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "No SMI port or pstate_control\n"));\r\nmodule_put(calling_module);\r\nreturn 0;\r\n}\r\nif (result < 0) {\r\nmodule_put(calling_module);\r\nreturn result;\r\n}\r\nis_done = 1;\r\nif (!(acpi_processor_ppc_status & PPC_IN_USE))\r\nmodule_put(calling_module);\r\nreturn 0;\r\n}\r\nstatic int acpi_processor_get_psd(struct acpi_processor *pr)\r\n{\r\nint result = 0;\r\nacpi_status status = AE_OK;\r\nstruct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};\r\nstruct acpi_buffer format = {sizeof("NNNNN"), "NNNNN"};\r\nstruct acpi_buffer state = {0, NULL};\r\nunion acpi_object *psd = NULL;\r\nstruct acpi_psd_package *pdomain;\r\nstatus = acpi_evaluate_object(pr->handle, "_PSD", NULL, &buffer);\r\nif (ACPI_FAILURE(status)) {\r\nreturn -ENODEV;\r\n}\r\npsd = buffer.pointer;\r\nif (!psd || (psd->type != ACPI_TYPE_PACKAGE)) {\r\nprintk(KERN_ERR PREFIX "Invalid _PSD data\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\nif (psd->package.count != 1) {\r\nprintk(KERN_ERR PREFIX "Invalid _PSD data\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\npdomain = &(pr->performance->domain_info);\r\nstate.length = sizeof(struct acpi_psd_package);\r\nstate.pointer = pdomain;\r\nstatus = acpi_extract_package(&(psd->package.elements[0]),\r\n&format, &state);\r\nif (ACPI_FAILURE(status)) {\r\nprintk(KERN_ERR PREFIX "Invalid _PSD data\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\nif (pdomain->num_entries != ACPI_PSD_REV0_ENTRIES) {\r\nprintk(KERN_ERR PREFIX "Unknown _PSD:num_entries\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\nif (pdomain->revision != ACPI_PSD_REV0_REVISION) {\r\nprintk(KERN_ERR PREFIX "Unknown _PSD:revision\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\nif (pdomain->coord_type != DOMAIN_COORD_TYPE_SW_ALL &&\r\npdomain->coord_type != DOMAIN_COORD_TYPE_SW_ANY &&\r\npdomain->coord_type != DOMAIN_COORD_TYPE_HW_ALL) {\r\nprintk(KERN_ERR PREFIX "Invalid _PSD:coord_type\n");\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\nend:\r\nkfree(buffer.pointer);\r\nreturn result;\r\n}\r\nint acpi_processor_preregister_performance(\r\nstruct acpi_processor_performance __percpu *performance)\r\n{\r\nint count_target;\r\nint retval = 0;\r\nunsigned int i, j;\r\ncpumask_var_t covered_cpus;\r\nstruct acpi_processor *pr;\r\nstruct acpi_psd_package *pdomain;\r\nstruct acpi_processor *match_pr;\r\nstruct acpi_psd_package *match_pdomain;\r\nif (!zalloc_cpumask_var(&covered_cpus, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nmutex_lock(&performance_mutex);\r\nfor_each_possible_cpu(i) {\r\npr = per_cpu(processors, i);\r\nif (!pr) {\r\ncontinue;\r\n}\r\nif (pr->performance) {\r\nretval = -EBUSY;\r\ngoto err_out;\r\n}\r\nif (!performance || !per_cpu_ptr(performance, i)) {\r\nretval = -EINVAL;\r\ngoto err_out;\r\n}\r\n}\r\nfor_each_possible_cpu(i) {\r\npr = per_cpu(processors, i);\r\nif (!pr)\r\ncontinue;\r\npr->performance = per_cpu_ptr(performance, i);\r\ncpumask_set_cpu(i, pr->performance->shared_cpu_map);\r\nif (acpi_processor_get_psd(pr)) {\r\nretval = -EINVAL;\r\ncontinue;\r\n}\r\n}\r\nif (retval)\r\ngoto err_ret;\r\nfor_each_possible_cpu(i) {\r\npr = per_cpu(processors, i);\r\nif (!pr)\r\ncontinue;\r\nif (cpumask_test_cpu(i, covered_cpus))\r\ncontinue;\r\npdomain = &(pr->performance->domain_info);\r\ncpumask_set_cpu(i, pr->performance->shared_cpu_map);\r\ncpumask_set_cpu(i, covered_cpus);\r\nif (pdomain->num_processors <= 1)\r\ncontinue;\r\ncount_target = pdomain->num_processors;\r\nif (pdomain->coord_type == DOMAIN_COORD_TYPE_SW_ALL)\r\npr->performance->shared_type = CPUFREQ_SHARED_TYPE_ALL;\r\nelse if (pdomain->coord_type == DOMAIN_COORD_TYPE_HW_ALL)\r\npr->performance->shared_type = CPUFREQ_SHARED_TYPE_HW;\r\nelse if (pdomain->coord_type == DOMAIN_COORD_TYPE_SW_ANY)\r\npr->performance->shared_type = CPUFREQ_SHARED_TYPE_ANY;\r\nfor_each_possible_cpu(j) {\r\nif (i == j)\r\ncontinue;\r\nmatch_pr = per_cpu(processors, j);\r\nif (!match_pr)\r\ncontinue;\r\nmatch_pdomain = &(match_pr->performance->domain_info);\r\nif (match_pdomain->domain != pdomain->domain)\r\ncontinue;\r\nif (match_pdomain->num_processors != count_target) {\r\nretval = -EINVAL;\r\ngoto err_ret;\r\n}\r\nif (pdomain->coord_type != match_pdomain->coord_type) {\r\nretval = -EINVAL;\r\ngoto err_ret;\r\n}\r\ncpumask_set_cpu(j, covered_cpus);\r\ncpumask_set_cpu(j, pr->performance->shared_cpu_map);\r\n}\r\nfor_each_possible_cpu(j) {\r\nif (i == j)\r\ncontinue;\r\nmatch_pr = per_cpu(processors, j);\r\nif (!match_pr)\r\ncontinue;\r\nmatch_pdomain = &(match_pr->performance->domain_info);\r\nif (match_pdomain->domain != pdomain->domain)\r\ncontinue;\r\nmatch_pr->performance->shared_type =\r\npr->performance->shared_type;\r\ncpumask_copy(match_pr->performance->shared_cpu_map,\r\npr->performance->shared_cpu_map);\r\n}\r\n}\r\nerr_ret:\r\nfor_each_possible_cpu(i) {\r\npr = per_cpu(processors, i);\r\nif (!pr || !pr->performance)\r\ncontinue;\r\nif (retval) {\r\ncpumask_clear(pr->performance->shared_cpu_map);\r\ncpumask_set_cpu(i, pr->performance->shared_cpu_map);\r\npr->performance->shared_type = CPUFREQ_SHARED_TYPE_ALL;\r\n}\r\npr->performance = NULL;\r\n}\r\nerr_out:\r\nmutex_unlock(&performance_mutex);\r\nfree_cpumask_var(covered_cpus);\r\nreturn retval;\r\n}\r\nint\r\nacpi_processor_register_performance(struct acpi_processor_performance\r\n*performance, unsigned int cpu)\r\n{\r\nstruct acpi_processor *pr;\r\nif (!(acpi_processor_ppc_status & PPC_REGISTERED))\r\nreturn -EINVAL;\r\nmutex_lock(&performance_mutex);\r\npr = per_cpu(processors, cpu);\r\nif (!pr) {\r\nmutex_unlock(&performance_mutex);\r\nreturn -ENODEV;\r\n}\r\nif (pr->performance) {\r\nmutex_unlock(&performance_mutex);\r\nreturn -EBUSY;\r\n}\r\nWARN_ON(!performance);\r\npr->performance = performance;\r\nif (acpi_processor_get_performance_info(pr)) {\r\npr->performance = NULL;\r\nmutex_unlock(&performance_mutex);\r\nreturn -EIO;\r\n}\r\nmutex_unlock(&performance_mutex);\r\nreturn 0;\r\n}\r\nvoid acpi_processor_unregister_performance(unsigned int cpu)\r\n{\r\nstruct acpi_processor *pr;\r\nmutex_lock(&performance_mutex);\r\npr = per_cpu(processors, cpu);\r\nif (!pr) {\r\nmutex_unlock(&performance_mutex);\r\nreturn;\r\n}\r\nif (pr->performance)\r\nkfree(pr->performance->states);\r\npr->performance = NULL;\r\nmutex_unlock(&performance_mutex);\r\nreturn;\r\n}
