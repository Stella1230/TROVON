static int dvb_dmxdev_buffer_write(struct dvb_ringbuffer *buf,\r\nconst u8 *src, size_t len)\r\n{\r\nssize_t free;\r\nif (!len)\r\nreturn 0;\r\nif (!buf->data)\r\nreturn 0;\r\nfree = dvb_ringbuffer_free(buf);\r\nif (len > free) {\r\ndprintk("buffer overflow\n");\r\nreturn -EOVERFLOW;\r\n}\r\nreturn dvb_ringbuffer_write(buf, src, len);\r\n}\r\nstatic ssize_t dvb_dmxdev_buffer_read(struct dvb_ringbuffer *src,\r\nint non_blocking, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nsize_t todo;\r\nssize_t avail;\r\nssize_t ret = 0;\r\nif (!src->data)\r\nreturn 0;\r\nif (src->error) {\r\nret = src->error;\r\ndvb_ringbuffer_flush(src);\r\nreturn ret;\r\n}\r\nfor (todo = count; todo > 0; todo -= ret) {\r\nif (non_blocking && dvb_ringbuffer_empty(src)) {\r\nret = -EWOULDBLOCK;\r\nbreak;\r\n}\r\nret = wait_event_interruptible(src->queue,\r\n!dvb_ringbuffer_empty(src) ||\r\n(src->error != 0));\r\nif (ret < 0)\r\nbreak;\r\nif (src->error) {\r\nret = src->error;\r\ndvb_ringbuffer_flush(src);\r\nbreak;\r\n}\r\navail = dvb_ringbuffer_avail(src);\r\nif (avail > todo)\r\navail = todo;\r\nret = dvb_ringbuffer_read_user(src, buf, avail);\r\nif (ret < 0)\r\nbreak;\r\nbuf += ret;\r\n}\r\nreturn (count - todo) ? (count - todo) : ret;\r\n}\r\nstatic struct dmx_frontend *get_fe(struct dmx_demux *demux, int type)\r\n{\r\nstruct list_head *head, *pos;\r\nhead = demux->get_frontends(demux);\r\nif (!head)\r\nreturn NULL;\r\nlist_for_each(pos, head)\r\nif (DMX_FE_ENTRY(pos)->source == type)\r\nreturn DMX_FE_ENTRY(pos);\r\nreturn NULL;\r\n}\r\nstatic int dvb_dvr_open(struct inode *inode, struct file *file)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct dmxdev *dmxdev = dvbdev->priv;\r\nstruct dmx_frontend *front;\r\ndprintk("%s\n", __func__);\r\nif (mutex_lock_interruptible(&dmxdev->mutex))\r\nreturn -ERESTARTSYS;\r\nif (dmxdev->exit) {\r\nmutex_unlock(&dmxdev->mutex);\r\nreturn -ENODEV;\r\n}\r\nif ((file->f_flags & O_ACCMODE) == O_RDWR) {\r\nif (!(dmxdev->capabilities & DMXDEV_CAP_DUPLEX)) {\r\nmutex_unlock(&dmxdev->mutex);\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nif ((file->f_flags & O_ACCMODE) == O_RDONLY) {\r\nvoid *mem;\r\nif (!dvbdev->readers) {\r\nmutex_unlock(&dmxdev->mutex);\r\nreturn -EBUSY;\r\n}\r\nmem = vmalloc(DVR_BUFFER_SIZE);\r\nif (!mem) {\r\nmutex_unlock(&dmxdev->mutex);\r\nreturn -ENOMEM;\r\n}\r\ndvb_ringbuffer_init(&dmxdev->dvr_buffer, mem, DVR_BUFFER_SIZE);\r\ndvbdev->readers--;\r\n}\r\nif ((file->f_flags & O_ACCMODE) == O_WRONLY) {\r\ndmxdev->dvr_orig_fe = dmxdev->demux->frontend;\r\nif (!dmxdev->demux->write) {\r\nmutex_unlock(&dmxdev->mutex);\r\nreturn -EOPNOTSUPP;\r\n}\r\nfront = get_fe(dmxdev->demux, DMX_MEMORY_FE);\r\nif (!front) {\r\nmutex_unlock(&dmxdev->mutex);\r\nreturn -EINVAL;\r\n}\r\ndmxdev->demux->disconnect_frontend(dmxdev->demux);\r\ndmxdev->demux->connect_frontend(dmxdev->demux, front);\r\n}\r\ndvbdev->users++;\r\nmutex_unlock(&dmxdev->mutex);\r\nreturn 0;\r\n}\r\nstatic int dvb_dvr_release(struct inode *inode, struct file *file)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct dmxdev *dmxdev = dvbdev->priv;\r\nmutex_lock(&dmxdev->mutex);\r\nif ((file->f_flags & O_ACCMODE) == O_WRONLY) {\r\ndmxdev->demux->disconnect_frontend(dmxdev->demux);\r\ndmxdev->demux->connect_frontend(dmxdev->demux,\r\ndmxdev->dvr_orig_fe);\r\n}\r\nif ((file->f_flags & O_ACCMODE) == O_RDONLY) {\r\ndvbdev->readers++;\r\nif (dmxdev->dvr_buffer.data) {\r\nvoid *mem = dmxdev->dvr_buffer.data;\r\nmb();\r\nspin_lock_irq(&dmxdev->lock);\r\ndmxdev->dvr_buffer.data = NULL;\r\nspin_unlock_irq(&dmxdev->lock);\r\nvfree(mem);\r\n}\r\n}\r\ndvbdev->users--;\r\nif (dvbdev->users == 1 && dmxdev->exit == 1) {\r\nmutex_unlock(&dmxdev->mutex);\r\nwake_up(&dvbdev->wait_queue);\r\n} else\r\nmutex_unlock(&dmxdev->mutex);\r\nreturn 0;\r\n}\r\nstatic ssize_t dvb_dvr_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct dmxdev *dmxdev = dvbdev->priv;\r\nint ret;\r\nif (!dmxdev->demux->write)\r\nreturn -EOPNOTSUPP;\r\nif ((file->f_flags & O_ACCMODE) != O_WRONLY)\r\nreturn -EINVAL;\r\nif (mutex_lock_interruptible(&dmxdev->mutex))\r\nreturn -ERESTARTSYS;\r\nif (dmxdev->exit) {\r\nmutex_unlock(&dmxdev->mutex);\r\nreturn -ENODEV;\r\n}\r\nret = dmxdev->demux->write(dmxdev->demux, buf, count);\r\nmutex_unlock(&dmxdev->mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t dvb_dvr_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct dmxdev *dmxdev = dvbdev->priv;\r\nif (dmxdev->exit)\r\nreturn -ENODEV;\r\nreturn dvb_dmxdev_buffer_read(&dmxdev->dvr_buffer,\r\nfile->f_flags & O_NONBLOCK,\r\nbuf, count, ppos);\r\n}\r\nstatic int dvb_dvr_set_buffer_size(struct dmxdev *dmxdev,\r\nunsigned long size)\r\n{\r\nstruct dvb_ringbuffer *buf = &dmxdev->dvr_buffer;\r\nvoid *newmem;\r\nvoid *oldmem;\r\ndprintk("%s\n", __func__);\r\nif (buf->size == size)\r\nreturn 0;\r\nif (!size)\r\nreturn -EINVAL;\r\nnewmem = vmalloc(size);\r\nif (!newmem)\r\nreturn -ENOMEM;\r\noldmem = buf->data;\r\nspin_lock_irq(&dmxdev->lock);\r\nbuf->data = newmem;\r\nbuf->size = size;\r\ndvb_ringbuffer_reset(buf);\r\nspin_unlock_irq(&dmxdev->lock);\r\nvfree(oldmem);\r\nreturn 0;\r\n}\r\nstatic inline void dvb_dmxdev_filter_state_set(struct dmxdev_filter\r\n*dmxdevfilter, int state)\r\n{\r\nspin_lock_irq(&dmxdevfilter->dev->lock);\r\ndmxdevfilter->state = state;\r\nspin_unlock_irq(&dmxdevfilter->dev->lock);\r\n}\r\nstatic int dvb_dmxdev_set_buffer_size(struct dmxdev_filter *dmxdevfilter,\r\nunsigned long size)\r\n{\r\nstruct dvb_ringbuffer *buf = &dmxdevfilter->buffer;\r\nvoid *newmem;\r\nvoid *oldmem;\r\nif (buf->size == size)\r\nreturn 0;\r\nif (!size)\r\nreturn -EINVAL;\r\nif (dmxdevfilter->state >= DMXDEV_STATE_GO)\r\nreturn -EBUSY;\r\nnewmem = vmalloc(size);\r\nif (!newmem)\r\nreturn -ENOMEM;\r\noldmem = buf->data;\r\nspin_lock_irq(&dmxdevfilter->dev->lock);\r\nbuf->data = newmem;\r\nbuf->size = size;\r\ndvb_ringbuffer_reset(buf);\r\nspin_unlock_irq(&dmxdevfilter->dev->lock);\r\nvfree(oldmem);\r\nreturn 0;\r\n}\r\nstatic void dvb_dmxdev_filter_timeout(unsigned long data)\r\n{\r\nstruct dmxdev_filter *dmxdevfilter = (struct dmxdev_filter *)data;\r\ndmxdevfilter->buffer.error = -ETIMEDOUT;\r\nspin_lock_irq(&dmxdevfilter->dev->lock);\r\ndmxdevfilter->state = DMXDEV_STATE_TIMEDOUT;\r\nspin_unlock_irq(&dmxdevfilter->dev->lock);\r\nwake_up(&dmxdevfilter->buffer.queue);\r\n}\r\nstatic void dvb_dmxdev_filter_timer(struct dmxdev_filter *dmxdevfilter)\r\n{\r\nstruct dmx_sct_filter_params *para = &dmxdevfilter->params.sec;\r\ndel_timer(&dmxdevfilter->timer);\r\nif (para->timeout) {\r\ndmxdevfilter->timer.function = dvb_dmxdev_filter_timeout;\r\ndmxdevfilter->timer.data = (unsigned long)dmxdevfilter;\r\ndmxdevfilter->timer.expires =\r\njiffies + 1 + (HZ / 2 + HZ * para->timeout) / 1000;\r\nadd_timer(&dmxdevfilter->timer);\r\n}\r\n}\r\nstatic int dvb_dmxdev_section_callback(const u8 *buffer1, size_t buffer1_len,\r\nconst u8 *buffer2, size_t buffer2_len,\r\nstruct dmx_section_filter *filter)\r\n{\r\nstruct dmxdev_filter *dmxdevfilter = filter->priv;\r\nint ret;\r\nif (dmxdevfilter->buffer.error) {\r\nwake_up(&dmxdevfilter->buffer.queue);\r\nreturn 0;\r\n}\r\nspin_lock(&dmxdevfilter->dev->lock);\r\nif (dmxdevfilter->state != DMXDEV_STATE_GO) {\r\nspin_unlock(&dmxdevfilter->dev->lock);\r\nreturn 0;\r\n}\r\ndel_timer(&dmxdevfilter->timer);\r\ndprintk("section callback %*ph\n", 6, buffer1);\r\nret = dvb_dmxdev_buffer_write(&dmxdevfilter->buffer, buffer1,\r\nbuffer1_len);\r\nif (ret == buffer1_len) {\r\nret = dvb_dmxdev_buffer_write(&dmxdevfilter->buffer, buffer2,\r\nbuffer2_len);\r\n}\r\nif (ret < 0)\r\ndmxdevfilter->buffer.error = ret;\r\nif (dmxdevfilter->params.sec.flags & DMX_ONESHOT)\r\ndmxdevfilter->state = DMXDEV_STATE_DONE;\r\nspin_unlock(&dmxdevfilter->dev->lock);\r\nwake_up(&dmxdevfilter->buffer.queue);\r\nreturn 0;\r\n}\r\nstatic int dvb_dmxdev_ts_callback(const u8 *buffer1, size_t buffer1_len,\r\nconst u8 *buffer2, size_t buffer2_len,\r\nstruct dmx_ts_feed *feed)\r\n{\r\nstruct dmxdev_filter *dmxdevfilter = feed->priv;\r\nstruct dvb_ringbuffer *buffer;\r\nint ret;\r\nspin_lock(&dmxdevfilter->dev->lock);\r\nif (dmxdevfilter->params.pes.output == DMX_OUT_DECODER) {\r\nspin_unlock(&dmxdevfilter->dev->lock);\r\nreturn 0;\r\n}\r\nif (dmxdevfilter->params.pes.output == DMX_OUT_TAP\r\n|| dmxdevfilter->params.pes.output == DMX_OUT_TSDEMUX_TAP)\r\nbuffer = &dmxdevfilter->buffer;\r\nelse\r\nbuffer = &dmxdevfilter->dev->dvr_buffer;\r\nif (buffer->error) {\r\nspin_unlock(&dmxdevfilter->dev->lock);\r\nwake_up(&buffer->queue);\r\nreturn 0;\r\n}\r\nret = dvb_dmxdev_buffer_write(buffer, buffer1, buffer1_len);\r\nif (ret == buffer1_len)\r\nret = dvb_dmxdev_buffer_write(buffer, buffer2, buffer2_len);\r\nif (ret < 0)\r\nbuffer->error = ret;\r\nspin_unlock(&dmxdevfilter->dev->lock);\r\nwake_up(&buffer->queue);\r\nreturn 0;\r\n}\r\nstatic int dvb_dmxdev_feed_stop(struct dmxdev_filter *dmxdevfilter)\r\n{\r\nstruct dmxdev_feed *feed;\r\ndvb_dmxdev_filter_state_set(dmxdevfilter, DMXDEV_STATE_SET);\r\nswitch (dmxdevfilter->type) {\r\ncase DMXDEV_TYPE_SEC:\r\ndel_timer(&dmxdevfilter->timer);\r\ndmxdevfilter->feed.sec->stop_filtering(dmxdevfilter->feed.sec);\r\nbreak;\r\ncase DMXDEV_TYPE_PES:\r\nlist_for_each_entry(feed, &dmxdevfilter->feed.ts, next)\r\nfeed->ts->stop_filtering(feed->ts);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dvb_dmxdev_feed_start(struct dmxdev_filter *filter)\r\n{\r\nstruct dmxdev_feed *feed;\r\nint ret;\r\ndvb_dmxdev_filter_state_set(filter, DMXDEV_STATE_GO);\r\nswitch (filter->type) {\r\ncase DMXDEV_TYPE_SEC:\r\nreturn filter->feed.sec->start_filtering(filter->feed.sec);\r\ncase DMXDEV_TYPE_PES:\r\nlist_for_each_entry(feed, &filter->feed.ts, next) {\r\nret = feed->ts->start_filtering(feed->ts);\r\nif (ret < 0) {\r\ndvb_dmxdev_feed_stop(filter);\r\nreturn ret;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dvb_dmxdev_feed_restart(struct dmxdev_filter *filter)\r\n{\r\nint i;\r\nstruct dmxdev *dmxdev = filter->dev;\r\nu16 pid = filter->params.sec.pid;\r\nfor (i = 0; i < dmxdev->filternum; i++)\r\nif (dmxdev->filter[i].state >= DMXDEV_STATE_GO &&\r\ndmxdev->filter[i].type == DMXDEV_TYPE_SEC &&\r\ndmxdev->filter[i].params.sec.pid == pid) {\r\ndvb_dmxdev_feed_start(&dmxdev->filter[i]);\r\nreturn 0;\r\n}\r\nfilter->dev->demux->release_section_feed(dmxdev->demux,\r\nfilter->feed.sec);\r\nreturn 0;\r\n}\r\nstatic int dvb_dmxdev_filter_stop(struct dmxdev_filter *dmxdevfilter)\r\n{\r\nstruct dmxdev_feed *feed;\r\nstruct dmx_demux *demux;\r\nif (dmxdevfilter->state < DMXDEV_STATE_GO)\r\nreturn 0;\r\nswitch (dmxdevfilter->type) {\r\ncase DMXDEV_TYPE_SEC:\r\nif (!dmxdevfilter->feed.sec)\r\nbreak;\r\ndvb_dmxdev_feed_stop(dmxdevfilter);\r\nif (dmxdevfilter->filter.sec)\r\ndmxdevfilter->feed.sec->\r\nrelease_filter(dmxdevfilter->feed.sec,\r\ndmxdevfilter->filter.sec);\r\ndvb_dmxdev_feed_restart(dmxdevfilter);\r\ndmxdevfilter->feed.sec = NULL;\r\nbreak;\r\ncase DMXDEV_TYPE_PES:\r\ndvb_dmxdev_feed_stop(dmxdevfilter);\r\ndemux = dmxdevfilter->dev->demux;\r\nlist_for_each_entry(feed, &dmxdevfilter->feed.ts, next) {\r\ndemux->release_ts_feed(demux, feed->ts);\r\nfeed->ts = NULL;\r\n}\r\nbreak;\r\ndefault:\r\nif (dmxdevfilter->state == DMXDEV_STATE_ALLOCATED)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\ndvb_ringbuffer_flush(&dmxdevfilter->buffer);\r\nreturn 0;\r\n}\r\nstatic void dvb_dmxdev_delete_pids(struct dmxdev_filter *dmxdevfilter)\r\n{\r\nstruct dmxdev_feed *feed, *tmp;\r\nlist_for_each_entry_safe(feed, tmp, &dmxdevfilter->feed.ts, next) {\r\nlist_del(&feed->next);\r\nkfree(feed);\r\n}\r\nBUG_ON(!list_empty(&dmxdevfilter->feed.ts));\r\n}\r\nstatic inline int dvb_dmxdev_filter_reset(struct dmxdev_filter *dmxdevfilter)\r\n{\r\nif (dmxdevfilter->state < DMXDEV_STATE_SET)\r\nreturn 0;\r\nif (dmxdevfilter->type == DMXDEV_TYPE_PES)\r\ndvb_dmxdev_delete_pids(dmxdevfilter);\r\ndmxdevfilter->type = DMXDEV_TYPE_NONE;\r\ndvb_dmxdev_filter_state_set(dmxdevfilter, DMXDEV_STATE_ALLOCATED);\r\nreturn 0;\r\n}\r\nstatic int dvb_dmxdev_start_feed(struct dmxdev *dmxdev,\r\nstruct dmxdev_filter *filter,\r\nstruct dmxdev_feed *feed)\r\n{\r\nktime_t timeout = 0;\r\nstruct dmx_pes_filter_params *para = &filter->params.pes;\r\ndmx_output_t otype;\r\nint ret;\r\nint ts_type;\r\nenum dmx_ts_pes ts_pes;\r\nstruct dmx_ts_feed *tsfeed;\r\nfeed->ts = NULL;\r\notype = para->output;\r\nts_pes = para->pes_type;\r\nif (ts_pes < DMX_PES_OTHER)\r\nts_type = TS_DECODER;\r\nelse\r\nts_type = 0;\r\nif (otype == DMX_OUT_TS_TAP)\r\nts_type |= TS_PACKET;\r\nelse if (otype == DMX_OUT_TSDEMUX_TAP)\r\nts_type |= TS_PACKET | TS_DEMUX;\r\nelse if (otype == DMX_OUT_TAP)\r\nts_type |= TS_PACKET | TS_DEMUX | TS_PAYLOAD_ONLY;\r\nret = dmxdev->demux->allocate_ts_feed(dmxdev->demux, &feed->ts,\r\ndvb_dmxdev_ts_callback);\r\nif (ret < 0)\r\nreturn ret;\r\ntsfeed = feed->ts;\r\ntsfeed->priv = filter;\r\nret = tsfeed->set(tsfeed, feed->pid, ts_type, ts_pes, timeout);\r\nif (ret < 0) {\r\ndmxdev->demux->release_ts_feed(dmxdev->demux, tsfeed);\r\nreturn ret;\r\n}\r\nret = tsfeed->start_filtering(tsfeed);\r\nif (ret < 0) {\r\ndmxdev->demux->release_ts_feed(dmxdev->demux, tsfeed);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dvb_dmxdev_filter_start(struct dmxdev_filter *filter)\r\n{\r\nstruct dmxdev *dmxdev = filter->dev;\r\nstruct dmxdev_feed *feed;\r\nvoid *mem;\r\nint ret, i;\r\nif (filter->state < DMXDEV_STATE_SET)\r\nreturn -EINVAL;\r\nif (filter->state >= DMXDEV_STATE_GO)\r\ndvb_dmxdev_filter_stop(filter);\r\nif (!filter->buffer.data) {\r\nmem = vmalloc(filter->buffer.size);\r\nif (!mem)\r\nreturn -ENOMEM;\r\nspin_lock_irq(&filter->dev->lock);\r\nfilter->buffer.data = mem;\r\nspin_unlock_irq(&filter->dev->lock);\r\n}\r\ndvb_ringbuffer_flush(&filter->buffer);\r\nswitch (filter->type) {\r\ncase DMXDEV_TYPE_SEC:\r\n{\r\nstruct dmx_sct_filter_params *para = &filter->params.sec;\r\nstruct dmx_section_filter **secfilter = &filter->filter.sec;\r\nstruct dmx_section_feed **secfeed = &filter->feed.sec;\r\n*secfilter = NULL;\r\n*secfeed = NULL;\r\nfor (i = 0; i < dmxdev->filternum; i++) {\r\nif (dmxdev->filter[i].state >= DMXDEV_STATE_GO &&\r\ndmxdev->filter[i].type == DMXDEV_TYPE_SEC &&\r\ndmxdev->filter[i].params.sec.pid == para->pid) {\r\n*secfeed = dmxdev->filter[i].feed.sec;\r\nbreak;\r\n}\r\n}\r\nif (!*secfeed) {\r\nret = dmxdev->demux->allocate_section_feed(dmxdev->demux,\r\nsecfeed,\r\ndvb_dmxdev_section_callback);\r\nif (ret < 0) {\r\npr_err("DVB (%s): could not alloc feed\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nret = (*secfeed)->set(*secfeed, para->pid,\r\n(para->flags & DMX_CHECK_CRC) ? 1 : 0);\r\nif (ret < 0) {\r\npr_err("DVB (%s): could not set feed\n",\r\n__func__);\r\ndvb_dmxdev_feed_restart(filter);\r\nreturn ret;\r\n}\r\n} else {\r\ndvb_dmxdev_feed_stop(filter);\r\n}\r\nret = (*secfeed)->allocate_filter(*secfeed, secfilter);\r\nif (ret < 0) {\r\ndvb_dmxdev_feed_restart(filter);\r\nfilter->feed.sec->start_filtering(*secfeed);\r\ndprintk("could not get filter\n");\r\nreturn ret;\r\n}\r\n(*secfilter)->priv = filter;\r\nmemcpy(&((*secfilter)->filter_value[3]),\r\n&(para->filter.filter[1]), DMX_FILTER_SIZE - 1);\r\nmemcpy(&(*secfilter)->filter_mask[3],\r\n&para->filter.mask[1], DMX_FILTER_SIZE - 1);\r\nmemcpy(&(*secfilter)->filter_mode[3],\r\n&para->filter.mode[1], DMX_FILTER_SIZE - 1);\r\n(*secfilter)->filter_value[0] = para->filter.filter[0];\r\n(*secfilter)->filter_mask[0] = para->filter.mask[0];\r\n(*secfilter)->filter_mode[0] = para->filter.mode[0];\r\n(*secfilter)->filter_mask[1] = 0;\r\n(*secfilter)->filter_mask[2] = 0;\r\nfilter->todo = 0;\r\nret = filter->feed.sec->start_filtering(filter->feed.sec);\r\nif (ret < 0)\r\nreturn ret;\r\ndvb_dmxdev_filter_timer(filter);\r\nbreak;\r\n}\r\ncase DMXDEV_TYPE_PES:\r\nlist_for_each_entry(feed, &filter->feed.ts, next) {\r\nret = dvb_dmxdev_start_feed(dmxdev, filter, feed);\r\nif (ret < 0) {\r\ndvb_dmxdev_filter_stop(filter);\r\nreturn ret;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndvb_dmxdev_filter_state_set(filter, DMXDEV_STATE_GO);\r\nreturn 0;\r\n}\r\nstatic int dvb_demux_open(struct inode *inode, struct file *file)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct dmxdev *dmxdev = dvbdev->priv;\r\nint i;\r\nstruct dmxdev_filter *dmxdevfilter;\r\nif (!dmxdev->filter)\r\nreturn -EINVAL;\r\nif (mutex_lock_interruptible(&dmxdev->mutex))\r\nreturn -ERESTARTSYS;\r\nfor (i = 0; i < dmxdev->filternum; i++)\r\nif (dmxdev->filter[i].state == DMXDEV_STATE_FREE)\r\nbreak;\r\nif (i == dmxdev->filternum) {\r\nmutex_unlock(&dmxdev->mutex);\r\nreturn -EMFILE;\r\n}\r\ndmxdevfilter = &dmxdev->filter[i];\r\nmutex_init(&dmxdevfilter->mutex);\r\nfile->private_data = dmxdevfilter;\r\ndvb_ringbuffer_init(&dmxdevfilter->buffer, NULL, 8192);\r\ndmxdevfilter->type = DMXDEV_TYPE_NONE;\r\ndvb_dmxdev_filter_state_set(dmxdevfilter, DMXDEV_STATE_ALLOCATED);\r\ninit_timer(&dmxdevfilter->timer);\r\ndvbdev->users++;\r\nmutex_unlock(&dmxdev->mutex);\r\nreturn 0;\r\n}\r\nstatic int dvb_dmxdev_filter_free(struct dmxdev *dmxdev,\r\nstruct dmxdev_filter *dmxdevfilter)\r\n{\r\nmutex_lock(&dmxdev->mutex);\r\nmutex_lock(&dmxdevfilter->mutex);\r\ndvb_dmxdev_filter_stop(dmxdevfilter);\r\ndvb_dmxdev_filter_reset(dmxdevfilter);\r\nif (dmxdevfilter->buffer.data) {\r\nvoid *mem = dmxdevfilter->buffer.data;\r\nspin_lock_irq(&dmxdev->lock);\r\ndmxdevfilter->buffer.data = NULL;\r\nspin_unlock_irq(&dmxdev->lock);\r\nvfree(mem);\r\n}\r\ndvb_dmxdev_filter_state_set(dmxdevfilter, DMXDEV_STATE_FREE);\r\nwake_up(&dmxdevfilter->buffer.queue);\r\nmutex_unlock(&dmxdevfilter->mutex);\r\nmutex_unlock(&dmxdev->mutex);\r\nreturn 0;\r\n}\r\nstatic inline void invert_mode(dmx_filter_t *filter)\r\n{\r\nint i;\r\nfor (i = 0; i < DMX_FILTER_SIZE; i++)\r\nfilter->mode[i] ^= 0xff;\r\n}\r\nstatic int dvb_dmxdev_add_pid(struct dmxdev *dmxdev,\r\nstruct dmxdev_filter *filter, u16 pid)\r\n{\r\nstruct dmxdev_feed *feed;\r\nif ((filter->type != DMXDEV_TYPE_PES) ||\r\n(filter->state < DMXDEV_STATE_SET))\r\nreturn -EINVAL;\r\nif ((filter->params.pes.output != DMX_OUT_TSDEMUX_TAP) &&\r\n(!list_empty(&filter->feed.ts)))\r\nreturn -EINVAL;\r\nfeed = kzalloc(sizeof(struct dmxdev_feed), GFP_KERNEL);\r\nif (feed == NULL)\r\nreturn -ENOMEM;\r\nfeed->pid = pid;\r\nlist_add(&feed->next, &filter->feed.ts);\r\nif (filter->state >= DMXDEV_STATE_GO)\r\nreturn dvb_dmxdev_start_feed(dmxdev, filter, feed);\r\nreturn 0;\r\n}\r\nstatic int dvb_dmxdev_remove_pid(struct dmxdev *dmxdev,\r\nstruct dmxdev_filter *filter, u16 pid)\r\n{\r\nstruct dmxdev_feed *feed, *tmp;\r\nif ((filter->type != DMXDEV_TYPE_PES) ||\r\n(filter->state < DMXDEV_STATE_SET))\r\nreturn -EINVAL;\r\nlist_for_each_entry_safe(feed, tmp, &filter->feed.ts, next) {\r\nif ((feed->pid == pid) && (feed->ts != NULL)) {\r\nfeed->ts->stop_filtering(feed->ts);\r\nfilter->dev->demux->release_ts_feed(filter->dev->demux,\r\nfeed->ts);\r\nlist_del(&feed->next);\r\nkfree(feed);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dvb_dmxdev_filter_set(struct dmxdev *dmxdev,\r\nstruct dmxdev_filter *dmxdevfilter,\r\nstruct dmx_sct_filter_params *params)\r\n{\r\ndprintk("%s: PID=0x%04x, flags=%02x, timeout=%d\n",\r\n__func__, params->pid, params->flags, params->timeout);\r\ndvb_dmxdev_filter_stop(dmxdevfilter);\r\ndmxdevfilter->type = DMXDEV_TYPE_SEC;\r\nmemcpy(&dmxdevfilter->params.sec,\r\nparams, sizeof(struct dmx_sct_filter_params));\r\ninvert_mode(&dmxdevfilter->params.sec.filter);\r\ndvb_dmxdev_filter_state_set(dmxdevfilter, DMXDEV_STATE_SET);\r\nif (params->flags & DMX_IMMEDIATE_START)\r\nreturn dvb_dmxdev_filter_start(dmxdevfilter);\r\nreturn 0;\r\n}\r\nstatic int dvb_dmxdev_pes_filter_set(struct dmxdev *dmxdev,\r\nstruct dmxdev_filter *dmxdevfilter,\r\nstruct dmx_pes_filter_params *params)\r\n{\r\nint ret;\r\ndvb_dmxdev_filter_stop(dmxdevfilter);\r\ndvb_dmxdev_filter_reset(dmxdevfilter);\r\nif ((unsigned int)params->pes_type > DMX_PES_OTHER)\r\nreturn -EINVAL;\r\ndmxdevfilter->type = DMXDEV_TYPE_PES;\r\nmemcpy(&dmxdevfilter->params, params,\r\nsizeof(struct dmx_pes_filter_params));\r\nINIT_LIST_HEAD(&dmxdevfilter->feed.ts);\r\ndvb_dmxdev_filter_state_set(dmxdevfilter, DMXDEV_STATE_SET);\r\nret = dvb_dmxdev_add_pid(dmxdev, dmxdevfilter,\r\ndmxdevfilter->params.pes.pid);\r\nif (ret < 0)\r\nreturn ret;\r\nif (params->flags & DMX_IMMEDIATE_START)\r\nreturn dvb_dmxdev_filter_start(dmxdevfilter);\r\nreturn 0;\r\n}\r\nstatic ssize_t dvb_dmxdev_read_sec(struct dmxdev_filter *dfil,\r\nstruct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint result, hcount;\r\nint done = 0;\r\nif (dfil->todo <= 0) {\r\nhcount = 3 + dfil->todo;\r\nif (hcount > count)\r\nhcount = count;\r\nresult = dvb_dmxdev_buffer_read(&dfil->buffer,\r\nfile->f_flags & O_NONBLOCK,\r\nbuf, hcount, ppos);\r\nif (result < 0) {\r\ndfil->todo = 0;\r\nreturn result;\r\n}\r\nif (copy_from_user(dfil->secheader - dfil->todo, buf, result))\r\nreturn -EFAULT;\r\nbuf += result;\r\ndone = result;\r\ncount -= result;\r\ndfil->todo -= result;\r\nif (dfil->todo > -3)\r\nreturn done;\r\ndfil->todo = ((dfil->secheader[1] << 8) | dfil->secheader[2]) & 0xfff;\r\nif (!count)\r\nreturn done;\r\n}\r\nif (count > dfil->todo)\r\ncount = dfil->todo;\r\nresult = dvb_dmxdev_buffer_read(&dfil->buffer,\r\nfile->f_flags & O_NONBLOCK,\r\nbuf, count, ppos);\r\nif (result < 0)\r\nreturn result;\r\ndfil->todo -= result;\r\nreturn (result + done);\r\n}\r\nstatic ssize_t\r\ndvb_demux_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct dmxdev_filter *dmxdevfilter = file->private_data;\r\nint ret;\r\nif (mutex_lock_interruptible(&dmxdevfilter->mutex))\r\nreturn -ERESTARTSYS;\r\nif (dmxdevfilter->type == DMXDEV_TYPE_SEC)\r\nret = dvb_dmxdev_read_sec(dmxdevfilter, file, buf, count, ppos);\r\nelse\r\nret = dvb_dmxdev_buffer_read(&dmxdevfilter->buffer,\r\nfile->f_flags & O_NONBLOCK,\r\nbuf, count, ppos);\r\nmutex_unlock(&dmxdevfilter->mutex);\r\nreturn ret;\r\n}\r\nstatic int dvb_demux_do_ioctl(struct file *file,\r\nunsigned int cmd, void *parg)\r\n{\r\nstruct dmxdev_filter *dmxdevfilter = file->private_data;\r\nstruct dmxdev *dmxdev = dmxdevfilter->dev;\r\nunsigned long arg = (unsigned long)parg;\r\nint ret = 0;\r\nif (mutex_lock_interruptible(&dmxdev->mutex))\r\nreturn -ERESTARTSYS;\r\nswitch (cmd) {\r\ncase DMX_START:\r\nif (mutex_lock_interruptible(&dmxdevfilter->mutex)) {\r\nmutex_unlock(&dmxdev->mutex);\r\nreturn -ERESTARTSYS;\r\n}\r\nif (dmxdevfilter->state < DMXDEV_STATE_SET)\r\nret = -EINVAL;\r\nelse\r\nret = dvb_dmxdev_filter_start(dmxdevfilter);\r\nmutex_unlock(&dmxdevfilter->mutex);\r\nbreak;\r\ncase DMX_STOP:\r\nif (mutex_lock_interruptible(&dmxdevfilter->mutex)) {\r\nmutex_unlock(&dmxdev->mutex);\r\nreturn -ERESTARTSYS;\r\n}\r\nret = dvb_dmxdev_filter_stop(dmxdevfilter);\r\nmutex_unlock(&dmxdevfilter->mutex);\r\nbreak;\r\ncase DMX_SET_FILTER:\r\nif (mutex_lock_interruptible(&dmxdevfilter->mutex)) {\r\nmutex_unlock(&dmxdev->mutex);\r\nreturn -ERESTARTSYS;\r\n}\r\nret = dvb_dmxdev_filter_set(dmxdev, dmxdevfilter, parg);\r\nmutex_unlock(&dmxdevfilter->mutex);\r\nbreak;\r\ncase DMX_SET_PES_FILTER:\r\nif (mutex_lock_interruptible(&dmxdevfilter->mutex)) {\r\nmutex_unlock(&dmxdev->mutex);\r\nreturn -ERESTARTSYS;\r\n}\r\nret = dvb_dmxdev_pes_filter_set(dmxdev, dmxdevfilter, parg);\r\nmutex_unlock(&dmxdevfilter->mutex);\r\nbreak;\r\ncase DMX_SET_BUFFER_SIZE:\r\nif (mutex_lock_interruptible(&dmxdevfilter->mutex)) {\r\nmutex_unlock(&dmxdev->mutex);\r\nreturn -ERESTARTSYS;\r\n}\r\nret = dvb_dmxdev_set_buffer_size(dmxdevfilter, arg);\r\nmutex_unlock(&dmxdevfilter->mutex);\r\nbreak;\r\ncase DMX_GET_PES_PIDS:\r\nif (!dmxdev->demux->get_pes_pids) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ndmxdev->demux->get_pes_pids(dmxdev->demux, parg);\r\nbreak;\r\n#if 0\r\ncase DMX_GET_CAPS:\r\nif (!dmxdev->demux->get_caps) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nret = dmxdev->demux->get_caps(dmxdev->demux, parg);\r\nbreak;\r\ncase DMX_SET_SOURCE:\r\nif (!dmxdev->demux->set_source) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nret = dmxdev->demux->set_source(dmxdev->demux, parg);\r\nbreak;\r\n#endif\r\ncase DMX_GET_STC:\r\nif (!dmxdev->demux->get_stc) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nret = dmxdev->demux->get_stc(dmxdev->demux,\r\n((struct dmx_stc *)parg)->num,\r\n&((struct dmx_stc *)parg)->stc,\r\n&((struct dmx_stc *)parg)->base);\r\nbreak;\r\ncase DMX_ADD_PID:\r\nif (mutex_lock_interruptible(&dmxdevfilter->mutex)) {\r\nret = -ERESTARTSYS;\r\nbreak;\r\n}\r\nret = dvb_dmxdev_add_pid(dmxdev, dmxdevfilter, *(u16 *)parg);\r\nmutex_unlock(&dmxdevfilter->mutex);\r\nbreak;\r\ncase DMX_REMOVE_PID:\r\nif (mutex_lock_interruptible(&dmxdevfilter->mutex)) {\r\nret = -ERESTARTSYS;\r\nbreak;\r\n}\r\nret = dvb_dmxdev_remove_pid(dmxdev, dmxdevfilter, *(u16 *)parg);\r\nmutex_unlock(&dmxdevfilter->mutex);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nmutex_unlock(&dmxdev->mutex);\r\nreturn ret;\r\n}\r\nstatic long dvb_demux_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nreturn dvb_usercopy(file, cmd, arg, dvb_demux_do_ioctl);\r\n}\r\nstatic unsigned int dvb_demux_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct dmxdev_filter *dmxdevfilter = file->private_data;\r\nunsigned int mask = 0;\r\nif ((!dmxdevfilter) || dmxdevfilter->dev->exit)\r\nreturn POLLERR;\r\npoll_wait(file, &dmxdevfilter->buffer.queue, wait);\r\nif (dmxdevfilter->state != DMXDEV_STATE_GO &&\r\ndmxdevfilter->state != DMXDEV_STATE_DONE &&\r\ndmxdevfilter->state != DMXDEV_STATE_TIMEDOUT)\r\nreturn 0;\r\nif (dmxdevfilter->buffer.error)\r\nmask |= (POLLIN | POLLRDNORM | POLLPRI | POLLERR);\r\nif (!dvb_ringbuffer_empty(&dmxdevfilter->buffer))\r\nmask |= (POLLIN | POLLRDNORM | POLLPRI);\r\nreturn mask;\r\n}\r\nstatic int dvb_demux_release(struct inode *inode, struct file *file)\r\n{\r\nstruct dmxdev_filter *dmxdevfilter = file->private_data;\r\nstruct dmxdev *dmxdev = dmxdevfilter->dev;\r\nint ret;\r\nret = dvb_dmxdev_filter_free(dmxdev, dmxdevfilter);\r\nmutex_lock(&dmxdev->mutex);\r\ndmxdev->dvbdev->users--;\r\nif (dmxdev->dvbdev->users == 1 && dmxdev->exit == 1) {\r\nmutex_unlock(&dmxdev->mutex);\r\nwake_up(&dmxdev->dvbdev->wait_queue);\r\n} else\r\nmutex_unlock(&dmxdev->mutex);\r\nreturn ret;\r\n}\r\nstatic int dvb_dvr_do_ioctl(struct file *file,\r\nunsigned int cmd, void *parg)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct dmxdev *dmxdev = dvbdev->priv;\r\nunsigned long arg = (unsigned long)parg;\r\nint ret;\r\nif (mutex_lock_interruptible(&dmxdev->mutex))\r\nreturn -ERESTARTSYS;\r\nswitch (cmd) {\r\ncase DMX_SET_BUFFER_SIZE:\r\nret = dvb_dvr_set_buffer_size(dmxdev, arg);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nmutex_unlock(&dmxdev->mutex);\r\nreturn ret;\r\n}\r\nstatic long dvb_dvr_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nreturn dvb_usercopy(file, cmd, arg, dvb_dvr_do_ioctl);\r\n}\r\nstatic unsigned int dvb_dvr_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct dmxdev *dmxdev = dvbdev->priv;\r\nunsigned int mask = 0;\r\ndprintk("%s\n", __func__);\r\nif (dmxdev->exit)\r\nreturn POLLERR;\r\npoll_wait(file, &dmxdev->dvr_buffer.queue, wait);\r\nif ((file->f_flags & O_ACCMODE) == O_RDONLY) {\r\nif (dmxdev->dvr_buffer.error)\r\nmask |= (POLLIN | POLLRDNORM | POLLPRI | POLLERR);\r\nif (!dvb_ringbuffer_empty(&dmxdev->dvr_buffer))\r\nmask |= (POLLIN | POLLRDNORM | POLLPRI);\r\n} else\r\nmask |= (POLLOUT | POLLWRNORM | POLLPRI);\r\nreturn mask;\r\n}\r\nint dvb_dmxdev_init(struct dmxdev *dmxdev, struct dvb_adapter *dvb_adapter)\r\n{\r\nint i;\r\nif (dmxdev->demux->open(dmxdev->demux) < 0)\r\nreturn -EUSERS;\r\ndmxdev->filter = vmalloc(dmxdev->filternum * sizeof(struct dmxdev_filter));\r\nif (!dmxdev->filter)\r\nreturn -ENOMEM;\r\nmutex_init(&dmxdev->mutex);\r\nspin_lock_init(&dmxdev->lock);\r\nfor (i = 0; i < dmxdev->filternum; i++) {\r\ndmxdev->filter[i].dev = dmxdev;\r\ndmxdev->filter[i].buffer.data = NULL;\r\ndvb_dmxdev_filter_state_set(&dmxdev->filter[i],\r\nDMXDEV_STATE_FREE);\r\n}\r\ndvb_register_device(dvb_adapter, &dmxdev->dvbdev, &dvbdev_demux, dmxdev,\r\nDVB_DEVICE_DEMUX, dmxdev->filternum);\r\ndvb_register_device(dvb_adapter, &dmxdev->dvr_dvbdev, &dvbdev_dvr,\r\ndmxdev, DVB_DEVICE_DVR, dmxdev->filternum);\r\ndvb_ringbuffer_init(&dmxdev->dvr_buffer, NULL, 8192);\r\nreturn 0;\r\n}\r\nvoid dvb_dmxdev_release(struct dmxdev *dmxdev)\r\n{\r\ndmxdev->exit = 1;\r\nif (dmxdev->dvbdev->users > 1) {\r\nwait_event(dmxdev->dvbdev->wait_queue,\r\ndmxdev->dvbdev->users == 1);\r\n}\r\nif (dmxdev->dvr_dvbdev->users > 1) {\r\nwait_event(dmxdev->dvr_dvbdev->wait_queue,\r\ndmxdev->dvr_dvbdev->users == 1);\r\n}\r\ndvb_unregister_device(dmxdev->dvbdev);\r\ndvb_unregister_device(dmxdev->dvr_dvbdev);\r\nvfree(dmxdev->filter);\r\ndmxdev->filter = NULL;\r\ndmxdev->demux->close(dmxdev->demux);\r\n}
