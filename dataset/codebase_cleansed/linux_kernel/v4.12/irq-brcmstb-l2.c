static void brcmstb_l2_intc_irq_handle(struct irq_desc *desc)\r\n{\r\nstruct brcmstb_l2_intc_data *b = irq_desc_get_handler_data(desc);\r\nstruct irq_chip_generic *gc = irq_get_domain_generic_chip(b->domain, 0);\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nunsigned int irq;\r\nu32 status;\r\nchained_irq_enter(chip, desc);\r\nstatus = irq_reg_readl(gc, CPU_STATUS) &\r\n~(irq_reg_readl(gc, CPU_MASK_STATUS));\r\nif (status == 0) {\r\nraw_spin_lock(&desc->lock);\r\nhandle_bad_irq(desc);\r\nraw_spin_unlock(&desc->lock);\r\ngoto out;\r\n}\r\ndo {\r\nirq = ffs(status) - 1;\r\nirq_reg_writel(gc, 1 << irq, CPU_CLEAR);\r\nstatus &= ~(1 << irq);\r\ngeneric_handle_irq(irq_find_mapping(b->domain, irq));\r\n} while (status);\r\nout:\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic void brcmstb_l2_intc_suspend(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct brcmstb_l2_intc_data *b = gc->private;\r\nirq_gc_lock(gc);\r\nb->saved_mask = irq_reg_readl(gc, CPU_MASK_STATUS);\r\nif (b->can_wake) {\r\nirq_reg_writel(gc, ~gc->wake_active, CPU_MASK_SET);\r\nirq_reg_writel(gc, gc->wake_active, CPU_MASK_CLEAR);\r\n}\r\nirq_gc_unlock(gc);\r\n}\r\nstatic void brcmstb_l2_intc_resume(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct brcmstb_l2_intc_data *b = gc->private;\r\nirq_gc_lock(gc);\r\nirq_reg_writel(gc, ~b->saved_mask & ~gc->wake_active, CPU_CLEAR);\r\nirq_reg_writel(gc, b->saved_mask, CPU_MASK_SET);\r\nirq_reg_writel(gc, ~b->saved_mask, CPU_MASK_CLEAR);\r\nirq_gc_unlock(gc);\r\n}\r\nstatic int __init brcmstb_l2_intc_of_init(struct device_node *np,\r\nstruct device_node *parent)\r\n{\r\nunsigned int clr = IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN;\r\nstruct brcmstb_l2_intc_data *data;\r\nstruct irq_chip_generic *gc;\r\nstruct irq_chip_type *ct;\r\nint ret;\r\nunsigned int flags;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->base = of_iomap(np, 0);\r\nif (!data->base) {\r\npr_err("failed to remap intc L2 registers\n");\r\nret = -ENOMEM;\r\ngoto out_free;\r\n}\r\nwritel(0xffffffff, data->base + CPU_MASK_SET);\r\ndata->can_wake = of_property_read_bool(np, "brcm,irq-can-wake");\r\nif (!data->can_wake)\r\nwritel(0xffffffff, data->base + CPU_CLEAR);\r\ndata->parent_irq = irq_of_parse_and_map(np, 0);\r\nif (!data->parent_irq) {\r\npr_err("failed to find parent interrupt\n");\r\nret = -EINVAL;\r\ngoto out_unmap;\r\n}\r\ndata->domain = irq_domain_add_linear(np, 32,\r\n&irq_generic_chip_ops, NULL);\r\nif (!data->domain) {\r\nret = -ENOMEM;\r\ngoto out_unmap;\r\n}\r\nflags = 0;\r\nif (IS_ENABLED(CONFIG_MIPS) && IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))\r\nflags |= IRQ_GC_BE_IO;\r\nret = irq_alloc_domain_generic_chips(data->domain, 32, 1,\r\nnp->full_name, handle_edge_irq, clr, 0, flags);\r\nif (ret) {\r\npr_err("failed to allocate generic irq chip\n");\r\ngoto out_free_domain;\r\n}\r\nirq_set_chained_handler_and_data(data->parent_irq,\r\nbrcmstb_l2_intc_irq_handle, data);\r\ngc = irq_get_domain_generic_chip(data->domain, 0);\r\ngc->reg_base = data->base;\r\ngc->private = data;\r\nct = gc->chip_types;\r\nct->chip.irq_ack = irq_gc_ack_set_bit;\r\nct->regs.ack = CPU_CLEAR;\r\nct->chip.irq_mask = irq_gc_mask_disable_reg;\r\nct->regs.disable = CPU_MASK_SET;\r\nct->chip.irq_unmask = irq_gc_unmask_enable_reg;\r\nct->regs.enable = CPU_MASK_CLEAR;\r\nct->chip.irq_suspend = brcmstb_l2_intc_suspend;\r\nct->chip.irq_resume = brcmstb_l2_intc_resume;\r\nif (data->can_wake) {\r\ngc->wake_enabled = 0xffffffff;\r\nct->chip.irq_set_wake = irq_gc_set_wake;\r\n}\r\npr_info("registered L2 intc (mem: 0x%p, parent irq: %d)\n",\r\ndata->base, data->parent_irq);\r\nreturn 0;\r\nout_free_domain:\r\nirq_domain_remove(data->domain);\r\nout_unmap:\r\niounmap(data->base);\r\nout_free:\r\nkfree(data);\r\nreturn ret;\r\n}
