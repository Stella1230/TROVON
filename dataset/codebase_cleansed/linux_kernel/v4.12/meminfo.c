static void show_val_kb(struct seq_file *m, const char *s, unsigned long num)\r\n{\r\nchar v[32];\r\nstatic const char blanks[7] = {' ', ' ', ' ', ' ',' ', ' ', ' '};\r\nint len;\r\nlen = num_to_str(v, sizeof(v), num << (PAGE_SHIFT - 10));\r\nseq_write(m, s, 16);\r\nif (len > 0) {\r\nif (len < 8)\r\nseq_write(m, blanks, 8 - len);\r\nseq_write(m, v, len);\r\n}\r\nseq_write(m, " kB\n", 4);\r\n}\r\nstatic int meminfo_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct sysinfo i;\r\nunsigned long committed;\r\nlong cached;\r\nlong available;\r\nunsigned long pages[NR_LRU_LISTS];\r\nint lru;\r\nsi_meminfo(&i);\r\nsi_swapinfo(&i);\r\ncommitted = percpu_counter_read_positive(&vm_committed_as);\r\ncached = global_node_page_state(NR_FILE_PAGES) -\r\ntotal_swapcache_pages() - i.bufferram;\r\nif (cached < 0)\r\ncached = 0;\r\nfor (lru = LRU_BASE; lru < NR_LRU_LISTS; lru++)\r\npages[lru] = global_node_page_state(NR_LRU_BASE + lru);\r\navailable = si_mem_available();\r\nshow_val_kb(m, "MemTotal: ", i.totalram);\r\nshow_val_kb(m, "MemFree: ", i.freeram);\r\nshow_val_kb(m, "MemAvailable: ", available);\r\nshow_val_kb(m, "Buffers: ", i.bufferram);\r\nshow_val_kb(m, "Cached: ", cached);\r\nshow_val_kb(m, "SwapCached: ", total_swapcache_pages());\r\nshow_val_kb(m, "Active: ", pages[LRU_ACTIVE_ANON] +\r\npages[LRU_ACTIVE_FILE]);\r\nshow_val_kb(m, "Inactive: ", pages[LRU_INACTIVE_ANON] +\r\npages[LRU_INACTIVE_FILE]);\r\nshow_val_kb(m, "Active(anon): ", pages[LRU_ACTIVE_ANON]);\r\nshow_val_kb(m, "Inactive(anon): ", pages[LRU_INACTIVE_ANON]);\r\nshow_val_kb(m, "Active(file): ", pages[LRU_ACTIVE_FILE]);\r\nshow_val_kb(m, "Inactive(file): ", pages[LRU_INACTIVE_FILE]);\r\nshow_val_kb(m, "Unevictable: ", pages[LRU_UNEVICTABLE]);\r\nshow_val_kb(m, "Mlocked: ", global_page_state(NR_MLOCK));\r\n#ifdef CONFIG_HIGHMEM\r\nshow_val_kb(m, "HighTotal: ", i.totalhigh);\r\nshow_val_kb(m, "HighFree: ", i.freehigh);\r\nshow_val_kb(m, "LowTotal: ", i.totalram - i.totalhigh);\r\nshow_val_kb(m, "LowFree: ", i.freeram - i.freehigh);\r\n#endif\r\n#ifndef CONFIG_MMU\r\nshow_val_kb(m, "MmapCopy: ",\r\n(unsigned long)atomic_long_read(&mmap_pages_allocated));\r\n#endif\r\nshow_val_kb(m, "SwapTotal: ", i.totalswap);\r\nshow_val_kb(m, "SwapFree: ", i.freeswap);\r\nshow_val_kb(m, "Dirty: ",\r\nglobal_node_page_state(NR_FILE_DIRTY));\r\nshow_val_kb(m, "Writeback: ",\r\nglobal_node_page_state(NR_WRITEBACK));\r\nshow_val_kb(m, "AnonPages: ",\r\nglobal_node_page_state(NR_ANON_MAPPED));\r\nshow_val_kb(m, "Mapped: ",\r\nglobal_node_page_state(NR_FILE_MAPPED));\r\nshow_val_kb(m, "Shmem: ", i.sharedram);\r\nshow_val_kb(m, "Slab: ",\r\nglobal_page_state(NR_SLAB_RECLAIMABLE) +\r\nglobal_page_state(NR_SLAB_UNRECLAIMABLE));\r\nshow_val_kb(m, "SReclaimable: ",\r\nglobal_page_state(NR_SLAB_RECLAIMABLE));\r\nshow_val_kb(m, "SUnreclaim: ",\r\nglobal_page_state(NR_SLAB_UNRECLAIMABLE));\r\nseq_printf(m, "KernelStack: %8lu kB\n",\r\nglobal_page_state(NR_KERNEL_STACK_KB));\r\nshow_val_kb(m, "PageTables: ",\r\nglobal_page_state(NR_PAGETABLE));\r\n#ifdef CONFIG_QUICKLIST\r\nshow_val_kb(m, "Quicklists: ", quicklist_total_size());\r\n#endif\r\nshow_val_kb(m, "NFS_Unstable: ",\r\nglobal_node_page_state(NR_UNSTABLE_NFS));\r\nshow_val_kb(m, "Bounce: ",\r\nglobal_page_state(NR_BOUNCE));\r\nshow_val_kb(m, "WritebackTmp: ",\r\nglobal_node_page_state(NR_WRITEBACK_TEMP));\r\nshow_val_kb(m, "CommitLimit: ", vm_commit_limit());\r\nshow_val_kb(m, "Committed_AS: ", committed);\r\nseq_printf(m, "VmallocTotal: %8lu kB\n",\r\n(unsigned long)VMALLOC_TOTAL >> 10);\r\nshow_val_kb(m, "VmallocUsed: ", 0ul);\r\nshow_val_kb(m, "VmallocChunk: ", 0ul);\r\n#ifdef CONFIG_MEMORY_FAILURE\r\nseq_printf(m, "HardwareCorrupted: %5lu kB\n",\r\natomic_long_read(&num_poisoned_pages) << (PAGE_SHIFT - 10));\r\n#endif\r\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\r\nshow_val_kb(m, "AnonHugePages: ",\r\nglobal_node_page_state(NR_ANON_THPS) * HPAGE_PMD_NR);\r\nshow_val_kb(m, "ShmemHugePages: ",\r\nglobal_node_page_state(NR_SHMEM_THPS) * HPAGE_PMD_NR);\r\nshow_val_kb(m, "ShmemPmdMapped: ",\r\nglobal_node_page_state(NR_SHMEM_PMDMAPPED) * HPAGE_PMD_NR);\r\n#endif\r\n#ifdef CONFIG_CMA\r\nshow_val_kb(m, "CmaTotal: ", totalcma_pages);\r\nshow_val_kb(m, "CmaFree: ",\r\nglobal_page_state(NR_FREE_CMA_PAGES));\r\n#endif\r\nhugetlb_report_meminfo(m);\r\narch_report_meminfo(m);\r\nreturn 0;\r\n}\r\nstatic int meminfo_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, meminfo_proc_show, NULL);\r\n}\r\nstatic int __init proc_meminfo_init(void)\r\n{\r\nproc_create("meminfo", 0, NULL, &meminfo_proc_fops);\r\nreturn 0;\r\n}
