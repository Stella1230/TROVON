static inline struct uvc_streaming *\r\nuvc_queue_to_stream(struct uvc_video_queue *queue)\r\n{\r\nreturn container_of(queue, struct uvc_streaming, queue);\r\n}\r\nstatic inline struct uvc_buffer *uvc_vbuf_to_buffer(struct vb2_v4l2_buffer *buf)\r\n{\r\nreturn container_of(buf, struct uvc_buffer, buf);\r\n}\r\nstatic void uvc_queue_return_buffers(struct uvc_video_queue *queue,\r\nenum uvc_buffer_state state)\r\n{\r\nenum vb2_buffer_state vb2_state = state == UVC_BUF_STATE_ERROR\r\n? VB2_BUF_STATE_ERROR\r\n: VB2_BUF_STATE_QUEUED;\r\nwhile (!list_empty(&queue->irqqueue)) {\r\nstruct uvc_buffer *buf = list_first_entry(&queue->irqqueue,\r\nstruct uvc_buffer,\r\nqueue);\r\nlist_del(&buf->queue);\r\nbuf->state = state;\r\nvb2_buffer_done(&buf->buf.vb2_buf, vb2_state);\r\n}\r\n}\r\nstatic int uvc_queue_setup(struct vb2_queue *vq,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], struct device *alloc_devs[])\r\n{\r\nstruct uvc_video_queue *queue = vb2_get_drv_priv(vq);\r\nstruct uvc_streaming *stream = uvc_queue_to_stream(queue);\r\nunsigned size = stream->ctrl.dwMaxVideoFrameSize;\r\nif (*nplanes)\r\nreturn sizes[0] < size ? -EINVAL : 0;\r\n*nplanes = 1;\r\nsizes[0] = size;\r\nreturn 0;\r\n}\r\nstatic int uvc_buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct uvc_video_queue *queue = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct uvc_buffer *buf = uvc_vbuf_to_buffer(vbuf);\r\nif (vb->type == V4L2_BUF_TYPE_VIDEO_OUTPUT &&\r\nvb2_get_plane_payload(vb, 0) > vb2_plane_size(vb, 0)) {\r\nuvc_trace(UVC_TRACE_CAPTURE, "[E] Bytes used out of bounds.\n");\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(queue->flags & UVC_QUEUE_DISCONNECTED))\r\nreturn -ENODEV;\r\nbuf->state = UVC_BUF_STATE_QUEUED;\r\nbuf->error = 0;\r\nbuf->mem = vb2_plane_vaddr(vb, 0);\r\nbuf->length = vb2_plane_size(vb, 0);\r\nif (vb->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nbuf->bytesused = 0;\r\nelse\r\nbuf->bytesused = vb2_get_plane_payload(vb, 0);\r\nreturn 0;\r\n}\r\nstatic void uvc_buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct uvc_video_queue *queue = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct uvc_buffer *buf = uvc_vbuf_to_buffer(vbuf);\r\nunsigned long flags;\r\nspin_lock_irqsave(&queue->irqlock, flags);\r\nif (likely(!(queue->flags & UVC_QUEUE_DISCONNECTED))) {\r\nlist_add_tail(&buf->queue, &queue->irqqueue);\r\n} else {\r\nbuf->state = UVC_BUF_STATE_ERROR;\r\nvb2_buffer_done(vb, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irqrestore(&queue->irqlock, flags);\r\n}\r\nstatic void uvc_buffer_finish(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct uvc_video_queue *queue = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct uvc_streaming *stream = uvc_queue_to_stream(queue);\r\nstruct uvc_buffer *buf = uvc_vbuf_to_buffer(vbuf);\r\nif (vb->state == VB2_BUF_STATE_DONE)\r\nuvc_video_clock_update(stream, vbuf, buf);\r\n}\r\nstatic int uvc_start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct uvc_video_queue *queue = vb2_get_drv_priv(vq);\r\nstruct uvc_streaming *stream = uvc_queue_to_stream(queue);\r\nunsigned long flags;\r\nint ret;\r\nqueue->buf_used = 0;\r\nret = uvc_video_enable(stream, 1);\r\nif (ret == 0)\r\nreturn 0;\r\nspin_lock_irqsave(&queue->irqlock, flags);\r\nuvc_queue_return_buffers(queue, UVC_BUF_STATE_QUEUED);\r\nspin_unlock_irqrestore(&queue->irqlock, flags);\r\nreturn ret;\r\n}\r\nstatic void uvc_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct uvc_video_queue *queue = vb2_get_drv_priv(vq);\r\nstruct uvc_streaming *stream = uvc_queue_to_stream(queue);\r\nunsigned long flags;\r\nuvc_video_enable(stream, 0);\r\nspin_lock_irqsave(&queue->irqlock, flags);\r\nuvc_queue_return_buffers(queue, UVC_BUF_STATE_ERROR);\r\nspin_unlock_irqrestore(&queue->irqlock, flags);\r\n}\r\nint uvc_queue_init(struct uvc_video_queue *queue, enum v4l2_buf_type type,\r\nint drop_corrupted)\r\n{\r\nint ret;\r\nqueue->queue.type = type;\r\nqueue->queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\r\nqueue->queue.drv_priv = queue;\r\nqueue->queue.buf_struct_size = sizeof(struct uvc_buffer);\r\nqueue->queue.ops = &uvc_queue_qops;\r\nqueue->queue.mem_ops = &vb2_vmalloc_memops;\r\nqueue->queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC\r\n| V4L2_BUF_FLAG_TSTAMP_SRC_SOE;\r\nqueue->queue.lock = &queue->mutex;\r\nret = vb2_queue_init(&queue->queue);\r\nif (ret)\r\nreturn ret;\r\nmutex_init(&queue->mutex);\r\nspin_lock_init(&queue->irqlock);\r\nINIT_LIST_HEAD(&queue->irqqueue);\r\nqueue->flags = drop_corrupted ? UVC_QUEUE_DROP_CORRUPTED : 0;\r\nreturn 0;\r\n}\r\nvoid uvc_queue_release(struct uvc_video_queue *queue)\r\n{\r\nmutex_lock(&queue->mutex);\r\nvb2_queue_release(&queue->queue);\r\nmutex_unlock(&queue->mutex);\r\n}\r\nint uvc_request_buffers(struct uvc_video_queue *queue,\r\nstruct v4l2_requestbuffers *rb)\r\n{\r\nint ret;\r\nmutex_lock(&queue->mutex);\r\nret = vb2_reqbufs(&queue->queue, rb);\r\nmutex_unlock(&queue->mutex);\r\nreturn ret ? ret : rb->count;\r\n}\r\nint uvc_query_buffer(struct uvc_video_queue *queue, struct v4l2_buffer *buf)\r\n{\r\nint ret;\r\nmutex_lock(&queue->mutex);\r\nret = vb2_querybuf(&queue->queue, buf);\r\nmutex_unlock(&queue->mutex);\r\nreturn ret;\r\n}\r\nint uvc_create_buffers(struct uvc_video_queue *queue,\r\nstruct v4l2_create_buffers *cb)\r\n{\r\nint ret;\r\nmutex_lock(&queue->mutex);\r\nret = vb2_create_bufs(&queue->queue, cb);\r\nmutex_unlock(&queue->mutex);\r\nreturn ret;\r\n}\r\nint uvc_queue_buffer(struct uvc_video_queue *queue, struct v4l2_buffer *buf)\r\n{\r\nint ret;\r\nmutex_lock(&queue->mutex);\r\nret = vb2_qbuf(&queue->queue, buf);\r\nmutex_unlock(&queue->mutex);\r\nreturn ret;\r\n}\r\nint uvc_export_buffer(struct uvc_video_queue *queue,\r\nstruct v4l2_exportbuffer *exp)\r\n{\r\nint ret;\r\nmutex_lock(&queue->mutex);\r\nret = vb2_expbuf(&queue->queue, exp);\r\nmutex_unlock(&queue->mutex);\r\nreturn ret;\r\n}\r\nint uvc_dequeue_buffer(struct uvc_video_queue *queue, struct v4l2_buffer *buf,\r\nint nonblocking)\r\n{\r\nint ret;\r\nmutex_lock(&queue->mutex);\r\nret = vb2_dqbuf(&queue->queue, buf, nonblocking);\r\nmutex_unlock(&queue->mutex);\r\nreturn ret;\r\n}\r\nint uvc_queue_streamon(struct uvc_video_queue *queue, enum v4l2_buf_type type)\r\n{\r\nint ret;\r\nmutex_lock(&queue->mutex);\r\nret = vb2_streamon(&queue->queue, type);\r\nmutex_unlock(&queue->mutex);\r\nreturn ret;\r\n}\r\nint uvc_queue_streamoff(struct uvc_video_queue *queue, enum v4l2_buf_type type)\r\n{\r\nint ret;\r\nmutex_lock(&queue->mutex);\r\nret = vb2_streamoff(&queue->queue, type);\r\nmutex_unlock(&queue->mutex);\r\nreturn ret;\r\n}\r\nint uvc_queue_mmap(struct uvc_video_queue *queue, struct vm_area_struct *vma)\r\n{\r\nreturn vb2_mmap(&queue->queue, vma);\r\n}\r\nunsigned long uvc_queue_get_unmapped_area(struct uvc_video_queue *queue,\r\nunsigned long pgoff)\r\n{\r\nreturn vb2_get_unmapped_area(&queue->queue, 0, 0, pgoff, 0);\r\n}\r\nunsigned int uvc_queue_poll(struct uvc_video_queue *queue, struct file *file,\r\npoll_table *wait)\r\n{\r\nunsigned int ret;\r\nmutex_lock(&queue->mutex);\r\nret = vb2_poll(&queue->queue, file, wait);\r\nmutex_unlock(&queue->mutex);\r\nreturn ret;\r\n}\r\nint uvc_queue_allocated(struct uvc_video_queue *queue)\r\n{\r\nint allocated;\r\nmutex_lock(&queue->mutex);\r\nallocated = vb2_is_busy(&queue->queue);\r\nmutex_unlock(&queue->mutex);\r\nreturn allocated;\r\n}\r\nvoid uvc_queue_cancel(struct uvc_video_queue *queue, int disconnect)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&queue->irqlock, flags);\r\nuvc_queue_return_buffers(queue, UVC_BUF_STATE_ERROR);\r\nif (disconnect)\r\nqueue->flags |= UVC_QUEUE_DISCONNECTED;\r\nspin_unlock_irqrestore(&queue->irqlock, flags);\r\n}\r\nstruct uvc_buffer *uvc_queue_next_buffer(struct uvc_video_queue *queue,\r\nstruct uvc_buffer *buf)\r\n{\r\nstruct uvc_buffer *nextbuf;\r\nunsigned long flags;\r\nif ((queue->flags & UVC_QUEUE_DROP_CORRUPTED) && buf->error) {\r\nbuf->error = 0;\r\nbuf->state = UVC_BUF_STATE_QUEUED;\r\nbuf->bytesused = 0;\r\nvb2_set_plane_payload(&buf->buf.vb2_buf, 0, 0);\r\nreturn buf;\r\n}\r\nspin_lock_irqsave(&queue->irqlock, flags);\r\nlist_del(&buf->queue);\r\nif (!list_empty(&queue->irqqueue))\r\nnextbuf = list_first_entry(&queue->irqqueue, struct uvc_buffer,\r\nqueue);\r\nelse\r\nnextbuf = NULL;\r\nspin_unlock_irqrestore(&queue->irqlock, flags);\r\nbuf->state = buf->error ? UVC_BUF_STATE_ERROR : UVC_BUF_STATE_DONE;\r\nvb2_set_plane_payload(&buf->buf.vb2_buf, 0, buf->bytesused);\r\nvb2_buffer_done(&buf->buf.vb2_buf, VB2_BUF_STATE_DONE);\r\nreturn nextbuf;\r\n}
