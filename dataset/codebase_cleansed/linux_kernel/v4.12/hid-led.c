static int hidled_send(struct hidled_device *ldev, __u8 *buf)\r\n{\r\nint ret;\r\nmutex_lock(&ldev->lock);\r\nmemcpy(ldev->buf, buf, ldev->config->report_size);\r\nif (ldev->config->report_type == RAW_REQUEST)\r\nret = hid_hw_raw_request(ldev->hdev, buf[0], ldev->buf,\r\nldev->config->report_size,\r\nHID_FEATURE_REPORT,\r\nHID_REQ_SET_REPORT);\r\nelse if (ldev->config->report_type == OUTPUT_REPORT)\r\nret = hid_hw_output_report(ldev->hdev, ldev->buf,\r\nldev->config->report_size);\r\nelse\r\nret = -EINVAL;\r\nmutex_unlock(&ldev->lock);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ret == ldev->config->report_size ? 0 : -EMSGSIZE;\r\n}\r\nstatic int hidled_recv(struct hidled_device *ldev, __u8 *buf)\r\n{\r\nint ret;\r\nif (ldev->config->report_type != RAW_REQUEST)\r\nreturn -EINVAL;\r\nmutex_lock(&ldev->lock);\r\nmemcpy(ldev->buf, buf, ldev->config->report_size);\r\nret = hid_hw_raw_request(ldev->hdev, buf[0], ldev->buf,\r\nldev->config->report_size,\r\nHID_FEATURE_REPORT,\r\nHID_REQ_SET_REPORT);\r\nif (ret < 0)\r\ngoto err;\r\nret = hid_hw_raw_request(ldev->hdev, buf[0], ldev->buf,\r\nldev->config->report_size,\r\nHID_FEATURE_REPORT,\r\nHID_REQ_GET_REPORT);\r\nmemcpy(buf, ldev->buf, ldev->config->report_size);\r\nerr:\r\nmutex_unlock(&ldev->lock);\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nstatic u8 riso_kagaku_index(struct hidled_rgb *rgb)\r\n{\r\nenum led_brightness r, g, b;\r\nr = rgb->red.cdev.brightness;\r\ng = rgb->green.cdev.brightness;\r\nb = rgb->blue.cdev.brightness;\r\nif (riso_kagaku_switch_green_blue)\r\nreturn RISO_KAGAKU_IX(r, b, g);\r\nelse\r\nreturn RISO_KAGAKU_IX(r, g, b);\r\n}\r\nstatic int riso_kagaku_write(struct led_classdev *cdev, enum led_brightness br)\r\n{\r\nstruct hidled_led *led = to_hidled_led(cdev);\r\nstruct hidled_rgb *rgb = led->rgb;\r\n__u8 buf[MAX_REPORT_SIZE] = {};\r\nbuf[1] = riso_kagaku_index(rgb);\r\nreturn hidled_send(rgb->ldev, buf);\r\n}\r\nstatic int dream_cheeky_write(struct led_classdev *cdev, enum led_brightness br)\r\n{\r\nstruct hidled_led *led = to_hidled_led(cdev);\r\nstruct hidled_rgb *rgb = led->rgb;\r\n__u8 buf[MAX_REPORT_SIZE] = {};\r\nbuf[1] = rgb->red.cdev.brightness;\r\nbuf[2] = rgb->green.cdev.brightness;\r\nbuf[3] = rgb->blue.cdev.brightness;\r\nbuf[7] = 0x1a;\r\nbuf[8] = 0x05;\r\nreturn hidled_send(rgb->ldev, buf);\r\n}\r\nstatic int dream_cheeky_init(struct hidled_device *ldev)\r\n{\r\n__u8 buf[MAX_REPORT_SIZE] = {};\r\nbuf[1] = 0x1f;\r\nbuf[2] = 0x02;\r\nbuf[4] = 0x5f;\r\nbuf[7] = 0x1a;\r\nbuf[8] = 0x03;\r\nreturn hidled_send(ldev, buf);\r\n}\r\nstatic int _thingm_write(struct led_classdev *cdev, enum led_brightness br,\r\nu8 offset)\r\n{\r\nstruct hidled_led *led = to_hidled_led(cdev);\r\n__u8 buf[MAX_REPORT_SIZE] = { 1, 'c' };\r\nbuf[2] = led->rgb->red.cdev.brightness;\r\nbuf[3] = led->rgb->green.cdev.brightness;\r\nbuf[4] = led->rgb->blue.cdev.brightness;\r\nbuf[7] = led->rgb->num + offset;\r\nreturn hidled_send(led->rgb->ldev, buf);\r\n}\r\nstatic int thingm_write_v1(struct led_classdev *cdev, enum led_brightness br)\r\n{\r\nreturn _thingm_write(cdev, br, 0);\r\n}\r\nstatic int thingm_write(struct led_classdev *cdev, enum led_brightness br)\r\n{\r\nreturn _thingm_write(cdev, br, 1);\r\n}\r\nstatic int thingm_init(struct hidled_device *ldev)\r\n{\r\n__u8 buf[MAX_REPORT_SIZE] = { 1, 'v' };\r\nint ret;\r\nret = hidled_recv(ldev, buf);\r\nif (ret)\r\nreturn ret;\r\nif (buf[3] == '1')\r\nldev->config = &hidled_config_thingm_v1;\r\nreturn 0;\r\n}\r\nstatic inline int delcom_get_lednum(const struct hidled_led *led)\r\n{\r\nif (led == &led->rgb->red)\r\nreturn DELCOM_RED_LED;\r\nelse if (led == &led->rgb->green)\r\nreturn DELCOM_GREEN_LED;\r\nelse\r\nreturn DELCOM_BLUE_LED;\r\n}\r\nstatic int delcom_enable_led(struct hidled_led *led)\r\n{\r\nunion delcom_packet dp = { .tx.major_cmd = 101, .tx.minor_cmd = 12 };\r\ndp.tx.data_lsb = 1 << delcom_get_lednum(led);\r\ndp.tx.data_msb = 0;\r\nreturn hidled_send(led->rgb->ldev, dp.data);\r\n}\r\nstatic int delcom_set_pwm(struct hidled_led *led)\r\n{\r\nunion delcom_packet dp = { .tx.major_cmd = 101, .tx.minor_cmd = 34 };\r\ndp.tx.data_lsb = delcom_get_lednum(led);\r\ndp.tx.data_msb = led->cdev.brightness;\r\nreturn hidled_send(led->rgb->ldev, dp.data);\r\n}\r\nstatic int delcom_write(struct led_classdev *cdev, enum led_brightness br)\r\n{\r\nstruct hidled_led *led = to_hidled_led(cdev);\r\nint ret;\r\nret = delcom_enable_led(led);\r\nif (ret)\r\nreturn ret;\r\nreturn delcom_set_pwm(led);\r\n}\r\nstatic int delcom_init(struct hidled_device *ldev)\r\n{\r\nunion delcom_packet dp = { .rx.cmd = 104 };\r\nint ret;\r\nret = hidled_recv(ldev, dp.data);\r\nif (ret)\r\nreturn ret;\r\nreturn le16_to_cpu(dp.fw.family_code) == 2 ? 0 : -ENODEV;\r\n}\r\nstatic int luxafor_write(struct led_classdev *cdev, enum led_brightness br)\r\n{\r\nstruct hidled_led *led = to_hidled_led(cdev);\r\n__u8 buf[MAX_REPORT_SIZE] = { [1] = 1 };\r\nbuf[2] = led->rgb->num + 1;\r\nbuf[3] = led->rgb->red.cdev.brightness;\r\nbuf[4] = led->rgb->green.cdev.brightness;\r\nbuf[5] = led->rgb->blue.cdev.brightness;\r\nreturn hidled_send(led->rgb->ldev, buf);\r\n}\r\nstatic int hidled_init_led(struct hidled_led *led, const char *color_name,\r\nstruct hidled_rgb *rgb, unsigned int minor)\r\n{\r\nconst struct hidled_config *config = rgb->ldev->config;\r\nif (config->num_leds > 1)\r\nsnprintf(led->name, sizeof(led->name), "%s%u:%s:led%u",\r\nconfig->short_name, minor, color_name, rgb->num);\r\nelse\r\nsnprintf(led->name, sizeof(led->name), "%s%u:%s",\r\nconfig->short_name, minor, color_name);\r\nled->cdev.name = led->name;\r\nled->cdev.max_brightness = config->max_brightness;\r\nled->cdev.brightness_set_blocking = config->write;\r\nled->cdev.flags = LED_HW_PLUGGABLE;\r\nled->rgb = rgb;\r\nreturn devm_led_classdev_register(&rgb->ldev->hdev->dev, &led->cdev);\r\n}\r\nstatic int hidled_init_rgb(struct hidled_rgb *rgb, unsigned int minor)\r\n{\r\nint ret;\r\nret = hidled_init_led(&rgb->red, "red", rgb, minor);\r\nif (ret)\r\nreturn ret;\r\nret = hidled_init_led(&rgb->green, "green", rgb, minor);\r\nif (ret)\r\nreturn ret;\r\nreturn hidled_init_led(&rgb->blue, "blue", rgb, minor);\r\n}\r\nstatic int hidled_probe(struct hid_device *hdev, const struct hid_device_id *id)\r\n{\r\nstruct hidled_device *ldev;\r\nunsigned int minor;\r\nint ret, i;\r\nldev = devm_kzalloc(&hdev->dev, sizeof(*ldev), GFP_KERNEL);\r\nif (!ldev)\r\nreturn -ENOMEM;\r\nldev->buf = devm_kmalloc(&hdev->dev, MAX_REPORT_SIZE, GFP_KERNEL);\r\nif (!ldev->buf)\r\nreturn -ENOMEM;\r\nret = hid_parse(hdev);\r\nif (ret)\r\nreturn ret;\r\nldev->hdev = hdev;\r\nmutex_init(&ldev->lock);\r\nfor (i = 0; !ldev->config && i < ARRAY_SIZE(hidled_configs); i++)\r\nif (hidled_configs[i].type == id->driver_data)\r\nldev->config = &hidled_configs[i];\r\nif (!ldev->config)\r\nreturn -EINVAL;\r\nif (ldev->config->init) {\r\nret = ldev->config->init(ldev);\r\nif (ret)\r\nreturn ret;\r\n}\r\nldev->rgb = devm_kcalloc(&hdev->dev, ldev->config->num_leds,\r\nsizeof(struct hidled_rgb), GFP_KERNEL);\r\nif (!ldev->rgb)\r\nreturn -ENOMEM;\r\nret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\r\nif (ret)\r\nreturn ret;\r\nminor = ((struct hidraw *) hdev->hidraw)->minor;\r\nfor (i = 0; i < ldev->config->num_leds; i++) {\r\nldev->rgb[i].ldev = ldev;\r\nldev->rgb[i].num = i;\r\nret = hidled_init_rgb(&ldev->rgb[i], minor);\r\nif (ret) {\r\nhid_hw_stop(hdev);\r\nreturn ret;\r\n}\r\n}\r\nhid_info(hdev, "%s initialized\n", ldev->config->name);\r\nreturn 0;\r\n}
