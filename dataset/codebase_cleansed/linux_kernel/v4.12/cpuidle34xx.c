static int omap3_enter_idle(struct cpuidle_device *dev,\r\nstruct cpuidle_driver *drv,\r\nint index)\r\n{\r\nstruct omap3_idle_statedata *cx = &omap3_idle_data[index];\r\nif (omap_irq_pending() || need_resched())\r\ngoto return_sleep_time;\r\nif (cx->flags & OMAP_CPUIDLE_CX_NO_CLKDM_IDLE) {\r\nclkdm_deny_idle(mpu_pd->pwrdm_clkdms[0]);\r\n} else {\r\npwrdm_set_next_pwrst(mpu_pd, cx->mpu_state);\r\npwrdm_set_next_pwrst(core_pd, cx->core_state);\r\n}\r\nif (cx->mpu_state == PWRDM_POWER_OFF)\r\ncpu_pm_enter();\r\nomap_sram_idle();\r\nif (cx->mpu_state == PWRDM_POWER_OFF &&\r\npwrdm_read_prev_pwrst(mpu_pd) == PWRDM_POWER_OFF)\r\ncpu_pm_exit();\r\nif (cx->flags & OMAP_CPUIDLE_CX_NO_CLKDM_IDLE)\r\nclkdm_allow_idle(mpu_pd->pwrdm_clkdms[0]);\r\nreturn_sleep_time:\r\nreturn index;\r\n}\r\nstatic int next_valid_state(struct cpuidle_device *dev,\r\nstruct cpuidle_driver *drv, int index)\r\n{\r\nstruct omap3_idle_statedata *cx = &omap3_idle_data[index];\r\nu32 mpu_deepest_state = PWRDM_POWER_RET;\r\nu32 core_deepest_state = PWRDM_POWER_RET;\r\nint idx;\r\nint next_index = 0;\r\nif (enable_off_mode) {\r\nmpu_deepest_state = PWRDM_POWER_OFF;\r\nif (!IS_PM34XX_ERRATUM(PM_SDRC_WAKEUP_ERRATUM_i583))\r\ncore_deepest_state = PWRDM_POWER_OFF;\r\n}\r\nif ((cx->mpu_state >= mpu_deepest_state) &&\r\n(cx->core_state >= core_deepest_state))\r\nreturn index;\r\nfor (idx = index - 1; idx >= 0; idx--) {\r\ncx = &omap3_idle_data[idx];\r\nif ((cx->mpu_state >= mpu_deepest_state) &&\r\n(cx->core_state >= core_deepest_state)) {\r\nnext_index = idx;\r\nbreak;\r\n}\r\n}\r\nreturn next_index;\r\n}\r\nstatic int omap3_enter_idle_bm(struct cpuidle_device *dev,\r\nstruct cpuidle_driver *drv,\r\nint index)\r\n{\r\nint new_state_idx, ret;\r\nu8 per_next_state, per_saved_state;\r\nstruct omap3_idle_statedata *cx;\r\nif (pwrdm_read_pwrst(cam_pd) == PWRDM_POWER_ON)\r\nnew_state_idx = drv->safe_state_index;\r\nelse\r\nnew_state_idx = next_valid_state(dev, drv, index);\r\ncx = &omap3_idle_data[new_state_idx];\r\nper_next_state = pwrdm_read_next_pwrst(per_pd);\r\nper_saved_state = per_next_state;\r\nif (per_next_state < cx->per_min_state) {\r\nper_next_state = cx->per_min_state;\r\npwrdm_set_next_pwrst(per_pd, per_next_state);\r\n}\r\nret = omap3_enter_idle(dev, drv, new_state_idx);\r\nif (per_next_state != per_saved_state)\r\npwrdm_set_next_pwrst(per_pd, per_saved_state);\r\nreturn ret;\r\n}\r\nint __init omap3_idle_init(void)\r\n{\r\nmpu_pd = pwrdm_lookup("mpu_pwrdm");\r\ncore_pd = pwrdm_lookup("core_pwrdm");\r\nper_pd = pwrdm_lookup("per_pwrdm");\r\ncam_pd = pwrdm_lookup("cam_pwrdm");\r\nif (!mpu_pd || !core_pd || !per_pd || !cam_pd)\r\nreturn -ENODEV;\r\nif (cpu_is_omap3430())\r\nreturn cpuidle_register(&omap3430_idle_driver, NULL);\r\nelse\r\nreturn cpuidle_register(&omap3_idle_driver, NULL);\r\n}
