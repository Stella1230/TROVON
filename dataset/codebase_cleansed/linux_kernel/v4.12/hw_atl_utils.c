static int hw_atl_utils_fw_downld_dwords(struct aq_hw_s *self, u32 a,\r\nu32 *p, u32 cnt)\r\n{\r\nint err = 0;\r\nAQ_HW_WAIT_FOR(reg_glb_cpu_sem_get(self,\r\nHW_ATL_FW_SM_RAM) == 1U,\r\n1U, 10000U);\r\nif (err < 0) {\r\nbool is_locked;\r\nreg_glb_cpu_sem_set(self, 1U, HW_ATL_FW_SM_RAM);\r\nis_locked = reg_glb_cpu_sem_get(self, HW_ATL_FW_SM_RAM);\r\nif (!is_locked) {\r\nerr = -ETIME;\r\ngoto err_exit;\r\n}\r\n}\r\naq_hw_write_reg(self, 0x00000208U, a);\r\nfor (++cnt; --cnt;) {\r\nu32 i = 0U;\r\naq_hw_write_reg(self, 0x00000200U, 0x00008000U);\r\nfor (i = 1024U;\r\n(0x100U & aq_hw_read_reg(self, 0x00000200U)) && --i;) {\r\n}\r\n*(p++) = aq_hw_read_reg(self, 0x0000020CU);\r\n}\r\nreg_glb_cpu_sem_set(self, 1U, HW_ATL_FW_SM_RAM);\r\nerr_exit:\r\nreturn err;\r\n}\r\nstatic int hw_atl_utils_fw_upload_dwords(struct aq_hw_s *self, u32 a, u32 *p,\r\nu32 cnt)\r\n{\r\nint err = 0;\r\nbool is_locked;\r\nis_locked = reg_glb_cpu_sem_get(self, HW_ATL_FW_SM_RAM);\r\nif (!is_locked) {\r\nerr = -ETIME;\r\ngoto err_exit;\r\n}\r\naq_hw_write_reg(self, 0x00000208U, a);\r\nfor (++cnt; --cnt;) {\r\nu32 i = 0U;\r\naq_hw_write_reg(self, 0x0000020CU, *(p++));\r\naq_hw_write_reg(self, 0x00000200U, 0xC000U);\r\nfor (i = 1024U;\r\n(0x100U & aq_hw_read_reg(self, 0x00000200U)) && --i;) {\r\n}\r\n}\r\nreg_glb_cpu_sem_set(self, 1U, HW_ATL_FW_SM_RAM);\r\nerr_exit:\r\nreturn err;\r\n}\r\nstatic int hw_atl_utils_ver_match(u32 ver_expected, u32 ver_actual)\r\n{\r\nint err = 0;\r\nconst u32 dw_major_mask = 0xff000000U;\r\nconst u32 dw_minor_mask = 0x00ffffffU;\r\nerr = (dw_major_mask & (ver_expected ^ ver_actual)) ? -EOPNOTSUPP : 0;\r\nif (err < 0)\r\ngoto err_exit;\r\nerr = ((dw_minor_mask & ver_expected) > (dw_minor_mask & ver_actual)) ?\r\n-EOPNOTSUPP : 0;\r\nerr_exit:\r\nreturn err;\r\n}\r\nstatic int hw_atl_utils_init_ucp(struct aq_hw_s *self,\r\nstruct aq_hw_caps_s *aq_hw_caps)\r\n{\r\nint err = 0;\r\nif (!aq_hw_read_reg(self, 0x370U)) {\r\nunsigned int rnd = 0U;\r\nunsigned int ucp_0x370 = 0U;\r\nget_random_bytes(&rnd, sizeof(unsigned int));\r\nucp_0x370 = 0x02020202U | (0xFEFEFEFEU & rnd);\r\naq_hw_write_reg(self, HW_ATL_UCP_0X370_REG, ucp_0x370);\r\n}\r\nreg_glb_cpu_scratch_scp_set(self, 0x00000000U, 25U);\r\nAQ_HW_WAIT_FOR(0U != (PHAL_ATLANTIC_A0->mbox_addr =\r\naq_hw_read_reg(self, 0x360U)), 1000U, 10U);\r\nerr = hw_atl_utils_ver_match(aq_hw_caps->fw_ver_expected,\r\naq_hw_read_reg(self, 0x18U));\r\nreturn err;\r\n}\r\nstatic int hw_atl_utils_fw_rpc_call(struct aq_hw_s *self, unsigned int rpc_size)\r\n{\r\nint err = 0;\r\nstruct aq_hw_atl_utils_fw_rpc_tid_s sw;\r\nif (!IS_CHIP_FEATURE(MIPS)) {\r\nerr = -1;\r\ngoto err_exit;\r\n}\r\nerr = hw_atl_utils_fw_upload_dwords(self, PHAL_ATLANTIC->rpc_addr,\r\n(u32 *)(void *)&PHAL_ATLANTIC->rpc,\r\n(rpc_size + sizeof(u32) -\r\nsizeof(u8)) / sizeof(u32));\r\nif (err < 0)\r\ngoto err_exit;\r\nsw.tid = 0xFFFFU & (++PHAL_ATLANTIC->rpc_tid);\r\nsw.len = (u16)rpc_size;\r\naq_hw_write_reg(self, HW_ATL_RPC_CONTROL_ADR, sw.val);\r\nerr_exit:\r\nreturn err;\r\n}\r\nstatic int hw_atl_utils_fw_rpc_wait(struct aq_hw_s *self,\r\nstruct hw_aq_atl_utils_fw_rpc **rpc)\r\n{\r\nint err = 0;\r\nstruct aq_hw_atl_utils_fw_rpc_tid_s sw;\r\nstruct aq_hw_atl_utils_fw_rpc_tid_s fw;\r\ndo {\r\nsw.val = aq_hw_read_reg(self, HW_ATL_RPC_CONTROL_ADR);\r\nPHAL_ATLANTIC->rpc_tid = sw.tid;\r\nAQ_HW_WAIT_FOR(sw.tid ==\r\n(fw.val =\r\naq_hw_read_reg(self, HW_ATL_RPC_STATE_ADR),\r\nfw.tid), 1000U, 100U);\r\nif (err < 0)\r\ngoto err_exit;\r\nif (fw.len == 0xFFFFU) {\r\nerr = hw_atl_utils_fw_rpc_call(self, sw.len);\r\nif (err < 0)\r\ngoto err_exit;\r\n}\r\n} while (sw.tid != fw.tid || 0xFFFFU == fw.len);\r\nif (err < 0)\r\ngoto err_exit;\r\nif (rpc) {\r\nif (fw.len) {\r\nerr =\r\nhw_atl_utils_fw_downld_dwords(self,\r\nPHAL_ATLANTIC->rpc_addr,\r\n(u32 *)(void *)\r\n&PHAL_ATLANTIC->rpc,\r\n(fw.len + sizeof(u32) -\r\nsizeof(u8)) /\r\nsizeof(u32));\r\nif (err < 0)\r\ngoto err_exit;\r\n}\r\n*rpc = &PHAL_ATLANTIC->rpc;\r\n}\r\nerr_exit:\r\nreturn err;\r\n}\r\nstatic int hw_atl_utils_mpi_create(struct aq_hw_s *self,\r\nstruct aq_hw_caps_s *aq_hw_caps)\r\n{\r\nint err = 0;\r\nerr = hw_atl_utils_init_ucp(self, aq_hw_caps);\r\nif (err < 0)\r\ngoto err_exit;\r\nerr = hw_atl_utils_fw_rpc_init(self);\r\nif (err < 0)\r\ngoto err_exit;\r\nerr_exit:\r\nreturn err;\r\n}\r\nvoid hw_atl_utils_mpi_read_stats(struct aq_hw_s *self,\r\nstruct hw_aq_atl_utils_mbox *pmbox)\r\n{\r\nint err = 0;\r\nerr = hw_atl_utils_fw_downld_dwords(self,\r\nPHAL_ATLANTIC->mbox_addr,\r\n(u32 *)(void *)pmbox,\r\nsizeof(*pmbox) / sizeof(u32));\r\nif (err < 0)\r\ngoto err_exit;\r\nif (pmbox != &PHAL_ATLANTIC->mbox)\r\nmemcpy(pmbox, &PHAL_ATLANTIC->mbox, sizeof(*pmbox));\r\nif (IS_CHIP_FEATURE(REVISION_A0)) {\r\nunsigned int mtu = self->aq_nic_cfg ?\r\nself->aq_nic_cfg->mtu : 1514U;\r\npmbox->stats.ubrc = pmbox->stats.uprc * mtu;\r\npmbox->stats.ubtc = pmbox->stats.uptc * mtu;\r\npmbox->stats.dpc = atomic_read(&PHAL_ATLANTIC_A0->dpc);\r\n} else {\r\npmbox->stats.dpc = reg_rx_dma_stat_counter7get(self);\r\n}\r\nerr_exit:;\r\n}\r\nint hw_atl_utils_mpi_set_speed(struct aq_hw_s *self, u32 speed,\r\nenum hal_atl_utils_fw_state_e state)\r\n{\r\nu32 ucp_0x368 = 0;\r\nucp_0x368 = (speed << HW_ATL_MPI_SPEED_SHIFT) | state;\r\naq_hw_write_reg(self, HW_ATL_MPI_CONTROL_ADR, ucp_0x368);\r\nreturn 0;\r\n}\r\nvoid hw_atl_utils_mpi_set(struct aq_hw_s *self,\r\nenum hal_atl_utils_fw_state_e state, u32 speed)\r\n{\r\nint err = 0;\r\nu32 transaction_id = 0;\r\nif (state == MPI_RESET) {\r\nhw_atl_utils_mpi_read_stats(self, &PHAL_ATLANTIC->mbox);\r\ntransaction_id = PHAL_ATLANTIC->mbox.transaction_id;\r\nAQ_HW_WAIT_FOR(transaction_id !=\r\n(hw_atl_utils_mpi_read_stats\r\n(self, &PHAL_ATLANTIC->mbox),\r\nPHAL_ATLANTIC->mbox.transaction_id),\r\n1000U, 100U);\r\nif (err < 0)\r\ngoto err_exit;\r\n}\r\nerr = hw_atl_utils_mpi_set_speed(self, speed, state);\r\nerr_exit:;\r\n}\r\nint hw_atl_utils_mpi_get_link_status(struct aq_hw_s *self,\r\nstruct aq_hw_link_status_s *link_status)\r\n{\r\nu32 cp0x036C = aq_hw_read_reg(self, HW_ATL_MPI_STATE_ADR);\r\nu32 link_speed_mask = cp0x036C >> HW_ATL_MPI_SPEED_SHIFT;\r\nif (!link_speed_mask) {\r\nlink_status->mbps = 0U;\r\n} else {\r\nswitch (link_speed_mask) {\r\ncase HAL_ATLANTIC_RATE_10G:\r\nlink_status->mbps = 10000U;\r\nbreak;\r\ncase HAL_ATLANTIC_RATE_5G:\r\ncase HAL_ATLANTIC_RATE_5GSR:\r\nlink_status->mbps = 5000U;\r\nbreak;\r\ncase HAL_ATLANTIC_RATE_2GS:\r\nlink_status->mbps = 2500U;\r\nbreak;\r\ncase HAL_ATLANTIC_RATE_1G:\r\nlink_status->mbps = 1000U;\r\nbreak;\r\ncase HAL_ATLANTIC_RATE_100M:\r\nlink_status->mbps = 100U;\r\nbreak;\r\ndefault:\r\nlink_status->mbps = 0U;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint hw_atl_utils_get_mac_permanent(struct aq_hw_s *self,\r\nstruct aq_hw_caps_s *aq_hw_caps,\r\nu8 *mac)\r\n{\r\nint err = 0;\r\nu32 h = 0U;\r\nu32 l = 0U;\r\nu32 mac_addr[2];\r\nself->mmio = aq_pci_func_get_mmio(self->aq_pci_func);\r\nhw_atl_utils_hw_chip_features_init(self,\r\n&PHAL_ATLANTIC_A0->chip_features);\r\nerr = hw_atl_utils_mpi_create(self, aq_hw_caps);\r\nif (err < 0)\r\ngoto err_exit;\r\nif (!aq_hw_read_reg(self, HW_ATL_UCP_0X370_REG)) {\r\nunsigned int rnd = 0;\r\nunsigned int ucp_0x370 = 0;\r\nget_random_bytes(&rnd, sizeof(unsigned int));\r\nucp_0x370 = 0x02020202 | (0xFEFEFEFE & rnd);\r\naq_hw_write_reg(self, HW_ATL_UCP_0X370_REG, ucp_0x370);\r\n}\r\nerr = hw_atl_utils_fw_downld_dwords(self,\r\naq_hw_read_reg(self, 0x00000374U) +\r\n(40U * 4U),\r\nmac_addr,\r\nAQ_DIMOF(mac_addr));\r\nif (err < 0) {\r\nmac_addr[0] = 0U;\r\nmac_addr[1] = 0U;\r\nerr = 0;\r\n} else {\r\nmac_addr[0] = __swab32(mac_addr[0]);\r\nmac_addr[1] = __swab32(mac_addr[1]);\r\n}\r\nether_addr_copy(mac, (u8 *)mac_addr);\r\nif ((mac[0] & 0x01U) || ((mac[0] | mac[1] | mac[2]) == 0x00U)) {\r\nl = 0xE3000000U\r\n| (0xFFFFU & aq_hw_read_reg(self, HW_ATL_UCP_0X370_REG))\r\n| (0x00 << 16);\r\nh = 0x8001300EU;\r\nmac[5] = (u8)(0xFFU & l);\r\nl >>= 8;\r\nmac[4] = (u8)(0xFFU & l);\r\nl >>= 8;\r\nmac[3] = (u8)(0xFFU & l);\r\nl >>= 8;\r\nmac[2] = (u8)(0xFFU & l);\r\nmac[1] = (u8)(0xFFU & h);\r\nh >>= 8;\r\nmac[0] = (u8)(0xFFU & h);\r\n}\r\nerr_exit:\r\nreturn err;\r\n}\r\nunsigned int hw_atl_utils_mbps_2_speed_index(unsigned int mbps)\r\n{\r\nunsigned int ret = 0U;\r\nswitch (mbps) {\r\ncase 100U:\r\nret = 5U;\r\nbreak;\r\ncase 1000U:\r\nret = 4U;\r\nbreak;\r\ncase 2500U:\r\nret = 3U;\r\nbreak;\r\ncase 5000U:\r\nret = 1U;\r\nbreak;\r\ncase 10000U:\r\nret = 0U;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nvoid hw_atl_utils_hw_chip_features_init(struct aq_hw_s *self, u32 *p)\r\n{\r\nu32 chip_features = 0U;\r\nu32 val = reg_glb_mif_id_get(self);\r\nu32 mif_rev = val & 0xFFU;\r\nif ((3U & mif_rev) == 1U) {\r\nchip_features |=\r\nHAL_ATLANTIC_UTILS_CHIP_REVISION_A0 |\r\nHAL_ATLANTIC_UTILS_CHIP_MPI_AQ |\r\nHAL_ATLANTIC_UTILS_CHIP_MIPS;\r\n} else if ((3U & mif_rev) == 2U) {\r\nchip_features |=\r\nHAL_ATLANTIC_UTILS_CHIP_REVISION_B0 |\r\nHAL_ATLANTIC_UTILS_CHIP_MPI_AQ |\r\nHAL_ATLANTIC_UTILS_CHIP_MIPS |\r\nHAL_ATLANTIC_UTILS_CHIP_TPO2 |\r\nHAL_ATLANTIC_UTILS_CHIP_RPF2;\r\n}\r\n*p = chip_features;\r\n}\r\nint hw_atl_utils_hw_deinit(struct aq_hw_s *self)\r\n{\r\nhw_atl_utils_mpi_set(self, MPI_DEINIT, 0x0U);\r\nreturn 0;\r\n}\r\nint hw_atl_utils_hw_set_power(struct aq_hw_s *self,\r\nunsigned int power_state)\r\n{\r\nhw_atl_utils_mpi_set(self, MPI_POWER, 0x0U);\r\nreturn 0;\r\n}\r\nint hw_atl_utils_get_hw_stats(struct aq_hw_s *self,\r\nu64 *data, unsigned int *p_count)\r\n{\r\nstruct hw_atl_stats_s *stats = NULL;\r\nint i = 0;\r\nhw_atl_utils_mpi_read_stats(self, &PHAL_ATLANTIC->mbox);\r\nstats = &PHAL_ATLANTIC->mbox.stats;\r\ndata[i] = stats->uprc + stats->mprc + stats->bprc;\r\ndata[++i] = stats->uprc;\r\ndata[++i] = stats->mprc;\r\ndata[++i] = stats->bprc;\r\ndata[++i] = stats->erpt;\r\ndata[++i] = stats->uptc + stats->mptc + stats->bptc;\r\ndata[++i] = stats->uptc;\r\ndata[++i] = stats->mptc;\r\ndata[++i] = stats->bptc;\r\ndata[++i] = stats->ubrc;\r\ndata[++i] = stats->ubtc;\r\ndata[++i] = stats->mbrc;\r\ndata[++i] = stats->mbtc;\r\ndata[++i] = stats->bbrc;\r\ndata[++i] = stats->bbtc;\r\ndata[++i] = stats->ubrc + stats->mbrc + stats->bbrc;\r\ndata[++i] = stats->ubtc + stats->mbtc + stats->bbtc;\r\ndata[++i] = stats_rx_dma_good_pkt_counterlsw_get(self);\r\ndata[++i] = stats_tx_dma_good_pkt_counterlsw_get(self);\r\ndata[++i] = stats_rx_dma_good_octet_counterlsw_get(self);\r\ndata[++i] = stats_tx_dma_good_octet_counterlsw_get(self);\r\ndata[++i] = stats->dpc;\r\nif (p_count)\r\n*p_count = ++i;\r\nreturn 0;\r\n}\r\nint hw_atl_utils_hw_get_regs(struct aq_hw_s *self,\r\nstruct aq_hw_caps_s *aq_hw_caps,\r\nu32 *regs_buff)\r\n{\r\nunsigned int i = 0U;\r\nfor (i = 0; i < aq_hw_caps->mac_regs_count; i++)\r\nregs_buff[i] = aq_hw_read_reg(self,\r\nhw_atl_utils_hw_mac_regs[i]);\r\nreturn 0;\r\n}\r\nint hw_atl_utils_get_fw_version(struct aq_hw_s *self, u32 *fw_version)\r\n{\r\n*fw_version = aq_hw_read_reg(self, 0x18U);\r\nreturn 0;\r\n}
