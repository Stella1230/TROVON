static inline struct imx_timer *to_imx_timer(struct clock_event_device *ced)\r\n{\r\nreturn container_of(ced, struct imx_timer, ced);\r\n}\r\nstatic void imx1_gpt_irq_disable(struct imx_timer *imxtm)\r\n{\r\nunsigned int tmp;\r\ntmp = readl_relaxed(imxtm->base + MXC_TCTL);\r\nwritel_relaxed(tmp & ~MX1_2_TCTL_IRQEN, imxtm->base + MXC_TCTL);\r\n}\r\nstatic void imx31_gpt_irq_disable(struct imx_timer *imxtm)\r\n{\r\nwritel_relaxed(0, imxtm->base + V2_IR);\r\n}\r\nstatic void imx1_gpt_irq_enable(struct imx_timer *imxtm)\r\n{\r\nunsigned int tmp;\r\ntmp = readl_relaxed(imxtm->base + MXC_TCTL);\r\nwritel_relaxed(tmp | MX1_2_TCTL_IRQEN, imxtm->base + MXC_TCTL);\r\n}\r\nstatic void imx31_gpt_irq_enable(struct imx_timer *imxtm)\r\n{\r\nwritel_relaxed(1<<0, imxtm->base + V2_IR);\r\n}\r\nstatic void imx1_gpt_irq_acknowledge(struct imx_timer *imxtm)\r\n{\r\nwritel_relaxed(0, imxtm->base + MX1_2_TSTAT);\r\n}\r\nstatic void imx21_gpt_irq_acknowledge(struct imx_timer *imxtm)\r\n{\r\nwritel_relaxed(MX2_TSTAT_CAPT | MX2_TSTAT_COMP,\r\nimxtm->base + MX1_2_TSTAT);\r\n}\r\nstatic void imx31_gpt_irq_acknowledge(struct imx_timer *imxtm)\r\n{\r\nwritel_relaxed(V2_TSTAT_OF1, imxtm->base + V2_TSTAT);\r\n}\r\nstatic u64 notrace mxc_read_sched_clock(void)\r\n{\r\nreturn sched_clock_reg ? readl_relaxed(sched_clock_reg) : 0;\r\n}\r\nstatic unsigned long imx_read_current_timer(void)\r\n{\r\nreturn readl_relaxed(sched_clock_reg);\r\n}\r\nstatic int __init mxc_clocksource_init(struct imx_timer *imxtm)\r\n{\r\nunsigned int c = clk_get_rate(imxtm->clk_per);\r\nvoid __iomem *reg = imxtm->base + imxtm->gpt->reg_tcn;\r\nimx_delay_timer.read_current_timer = &imx_read_current_timer;\r\nimx_delay_timer.freq = c;\r\nregister_current_timer_delay(&imx_delay_timer);\r\nsched_clock_reg = reg;\r\nsched_clock_register(mxc_read_sched_clock, 32, c);\r\nreturn clocksource_mmio_init(reg, "mxc_timer1", c, 200, 32,\r\nclocksource_mmio_readl_up);\r\n}\r\nstatic int mx1_2_set_next_event(unsigned long evt,\r\nstruct clock_event_device *ced)\r\n{\r\nstruct imx_timer *imxtm = to_imx_timer(ced);\r\nunsigned long tcmp;\r\ntcmp = readl_relaxed(imxtm->base + MX1_2_TCN) + evt;\r\nwritel_relaxed(tcmp, imxtm->base + MX1_2_TCMP);\r\nreturn (int)(tcmp - readl_relaxed(imxtm->base + MX1_2_TCN)) < 0 ?\r\n-ETIME : 0;\r\n}\r\nstatic int v2_set_next_event(unsigned long evt,\r\nstruct clock_event_device *ced)\r\n{\r\nstruct imx_timer *imxtm = to_imx_timer(ced);\r\nunsigned long tcmp;\r\ntcmp = readl_relaxed(imxtm->base + V2_TCN) + evt;\r\nwritel_relaxed(tcmp, imxtm->base + V2_TCMP);\r\nreturn evt < 0x7fffffff &&\r\n(int)(tcmp - readl_relaxed(imxtm->base + V2_TCN)) < 0 ?\r\n-ETIME : 0;\r\n}\r\nstatic int mxc_shutdown(struct clock_event_device *ced)\r\n{\r\nstruct imx_timer *imxtm = to_imx_timer(ced);\r\nunsigned long flags;\r\nu32 tcn;\r\nlocal_irq_save(flags);\r\nimxtm->gpt->gpt_irq_disable(imxtm);\r\ntcn = readl_relaxed(imxtm->base + imxtm->gpt->reg_tcn);\r\nwritel_relaxed(tcn - 3, imxtm->base + imxtm->gpt->reg_tcmp);\r\nimxtm->gpt->gpt_irq_acknowledge(imxtm);\r\n#ifdef DEBUG\r\nprintk(KERN_INFO "%s: changing mode\n", __func__);\r\n#endif\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic int mxc_set_oneshot(struct clock_event_device *ced)\r\n{\r\nstruct imx_timer *imxtm = to_imx_timer(ced);\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nimxtm->gpt->gpt_irq_disable(imxtm);\r\nif (!clockevent_state_oneshot(ced)) {\r\nu32 tcn = readl_relaxed(imxtm->base + imxtm->gpt->reg_tcn);\r\nwritel_relaxed(tcn - 3, imxtm->base + imxtm->gpt->reg_tcmp);\r\nimxtm->gpt->gpt_irq_acknowledge(imxtm);\r\n}\r\n#ifdef DEBUG\r\nprintk(KERN_INFO "%s: changing mode\n", __func__);\r\n#endif\r\nimxtm->gpt->gpt_irq_enable(imxtm);\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t mxc_timer_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *ced = dev_id;\r\nstruct imx_timer *imxtm = to_imx_timer(ced);\r\nuint32_t tstat;\r\ntstat = readl_relaxed(imxtm->base + imxtm->gpt->reg_tstat);\r\nimxtm->gpt->gpt_irq_acknowledge(imxtm);\r\nced->event_handler(ced);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init mxc_clockevent_init(struct imx_timer *imxtm)\r\n{\r\nstruct clock_event_device *ced = &imxtm->ced;\r\nstruct irqaction *act = &imxtm->act;\r\nced->name = "mxc_timer1";\r\nced->features = CLOCK_EVT_FEAT_ONESHOT | CLOCK_EVT_FEAT_DYNIRQ;\r\nced->set_state_shutdown = mxc_shutdown;\r\nced->set_state_oneshot = mxc_set_oneshot;\r\nced->tick_resume = mxc_shutdown;\r\nced->set_next_event = imxtm->gpt->set_next_event;\r\nced->rating = 200;\r\nced->cpumask = cpumask_of(0);\r\nced->irq = imxtm->irq;\r\nclockevents_config_and_register(ced, clk_get_rate(imxtm->clk_per),\r\n0xff, 0xfffffffe);\r\nact->name = "i.MX Timer Tick";\r\nact->flags = IRQF_TIMER | IRQF_IRQPOLL;\r\nact->handler = mxc_timer_interrupt;\r\nact->dev_id = ced;\r\nreturn setup_irq(imxtm->irq, act);\r\n}\r\nstatic void imx1_gpt_setup_tctl(struct imx_timer *imxtm)\r\n{\r\nu32 tctl_val;\r\ntctl_val = MX1_2_TCTL_FRR | MX1_2_TCTL_CLK_PCLK1 | MXC_TCTL_TEN;\r\nwritel_relaxed(tctl_val, imxtm->base + MXC_TCTL);\r\n}\r\nstatic void imx31_gpt_setup_tctl(struct imx_timer *imxtm)\r\n{\r\nu32 tctl_val;\r\ntctl_val = V2_TCTL_FRR | V2_TCTL_WAITEN | MXC_TCTL_TEN;\r\nif (clk_get_rate(imxtm->clk_per) == V2_TIMER_RATE_OSC_DIV8)\r\ntctl_val |= V2_TCTL_CLK_OSC_DIV8;\r\nelse\r\ntctl_val |= V2_TCTL_CLK_PER;\r\nwritel_relaxed(tctl_val, imxtm->base + MXC_TCTL);\r\n}\r\nstatic void imx6dl_gpt_setup_tctl(struct imx_timer *imxtm)\r\n{\r\nu32 tctl_val;\r\ntctl_val = V2_TCTL_FRR | V2_TCTL_WAITEN | MXC_TCTL_TEN;\r\nif (clk_get_rate(imxtm->clk_per) == V2_TIMER_RATE_OSC_DIV8) {\r\ntctl_val |= V2_TCTL_CLK_OSC_DIV8;\r\nwritel_relaxed(7 << V2_TPRER_PRE24M, imxtm->base + MXC_TPRER);\r\ntctl_val |= V2_TCTL_24MEN;\r\n} else {\r\ntctl_val |= V2_TCTL_CLK_PER;\r\n}\r\nwritel_relaxed(tctl_val, imxtm->base + MXC_TCTL);\r\n}\r\nstatic int __init _mxc_timer_init(struct imx_timer *imxtm)\r\n{\r\nint ret;\r\nswitch (imxtm->type) {\r\ncase GPT_TYPE_IMX1:\r\nimxtm->gpt = &imx1_gpt_data;\r\nbreak;\r\ncase GPT_TYPE_IMX21:\r\nimxtm->gpt = &imx21_gpt_data;\r\nbreak;\r\ncase GPT_TYPE_IMX31:\r\nimxtm->gpt = &imx31_gpt_data;\r\nbreak;\r\ncase GPT_TYPE_IMX6DL:\r\nimxtm->gpt = &imx6dl_gpt_data;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (IS_ERR(imxtm->clk_per)) {\r\npr_err("i.MX timer: unable to get clk\n");\r\nreturn PTR_ERR(imxtm->clk_per);\r\n}\r\nif (!IS_ERR(imxtm->clk_ipg))\r\nclk_prepare_enable(imxtm->clk_ipg);\r\nclk_prepare_enable(imxtm->clk_per);\r\nwritel_relaxed(0, imxtm->base + MXC_TCTL);\r\nwritel_relaxed(0, imxtm->base + MXC_TPRER);\r\nimxtm->gpt->gpt_setup_tctl(imxtm);\r\nret = mxc_clocksource_init(imxtm);\r\nif (ret)\r\nreturn ret;\r\nreturn mxc_clockevent_init(imxtm);\r\n}\r\nvoid __init mxc_timer_init(unsigned long pbase, int irq, enum imx_gpt_type type)\r\n{\r\nstruct imx_timer *imxtm;\r\nimxtm = kzalloc(sizeof(*imxtm), GFP_KERNEL);\r\nBUG_ON(!imxtm);\r\nimxtm->clk_per = clk_get_sys("imx-gpt.0", "per");\r\nimxtm->clk_ipg = clk_get_sys("imx-gpt.0", "ipg");\r\nimxtm->base = ioremap(pbase, SZ_4K);\r\nBUG_ON(!imxtm->base);\r\nimxtm->type = type;\r\nimxtm->irq = irq;\r\n_mxc_timer_init(imxtm);\r\n}\r\nstatic int __init mxc_timer_init_dt(struct device_node *np, enum imx_gpt_type type)\r\n{\r\nstruct imx_timer *imxtm;\r\nstatic int initialized;\r\nint ret;\r\nif (initialized)\r\nreturn 0;\r\nimxtm = kzalloc(sizeof(*imxtm), GFP_KERNEL);\r\nif (!imxtm)\r\nreturn -ENOMEM;\r\nimxtm->base = of_iomap(np, 0);\r\nif (!imxtm->base)\r\nreturn -ENXIO;\r\nimxtm->irq = irq_of_parse_and_map(np, 0);\r\nif (imxtm->irq <= 0)\r\nreturn -EINVAL;\r\nimxtm->clk_ipg = of_clk_get_by_name(np, "ipg");\r\nimxtm->clk_per = of_clk_get_by_name(np, "osc_per");\r\nif (IS_ERR(imxtm->clk_per))\r\nimxtm->clk_per = of_clk_get_by_name(np, "per");\r\nimxtm->type = type;\r\nret = _mxc_timer_init(imxtm);\r\nif (ret)\r\nreturn ret;\r\ninitialized = 1;\r\nreturn 0;\r\n}\r\nstatic int __init imx1_timer_init_dt(struct device_node *np)\r\n{\r\nreturn mxc_timer_init_dt(np, GPT_TYPE_IMX1);\r\n}\r\nstatic int __init imx21_timer_init_dt(struct device_node *np)\r\n{\r\nreturn mxc_timer_init_dt(np, GPT_TYPE_IMX21);\r\n}\r\nstatic int __init imx31_timer_init_dt(struct device_node *np)\r\n{\r\nenum imx_gpt_type type = GPT_TYPE_IMX31;\r\nif (of_machine_is_compatible("fsl,imx6dl"))\r\ntype = GPT_TYPE_IMX6DL;\r\nreturn mxc_timer_init_dt(np, type);\r\n}\r\nstatic int __init imx6dl_timer_init_dt(struct device_node *np)\r\n{\r\nreturn mxc_timer_init_dt(np, GPT_TYPE_IMX6DL);\r\n}
