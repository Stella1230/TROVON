static bool cs4270_reg_is_readable(struct device *dev, unsigned int reg)\r\n{\r\nreturn (reg >= CS4270_FIRSTREG) && (reg <= CS4270_LASTREG);\r\n}\r\nstatic bool cs4270_reg_is_volatile(struct device *dev, unsigned int reg)\r\n{\r\nif ((reg < CS4270_FIRSTREG) || (reg > CS4270_LASTREG))\r\nreturn 1;\r\nreturn reg == CS4270_CHIPID;\r\n}\r\nstatic int cs4270_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct cs4270_private *cs4270 = snd_soc_codec_get_drvdata(codec);\r\ncs4270->mclk = freq;\r\nreturn 0;\r\n}\r\nstatic int cs4270_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int format)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct cs4270_private *cs4270 = snd_soc_codec_get_drvdata(codec);\r\nswitch (format & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\ncs4270->mode = format & SND_SOC_DAIFMT_FORMAT_MASK;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "invalid dai format\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (format & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\ncs4270->slave_mode = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\ncs4270->slave_mode = 0;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unknown master/slave configuration\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs4270_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct cs4270_private *cs4270 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nunsigned int i;\r\nunsigned int rate;\r\nunsigned int ratio;\r\nint reg;\r\nrate = params_rate(params);\r\nratio = cs4270->mclk / rate;\r\nfor (i = 0; i < NUM_MCLK_RATIOS; i++) {\r\nif (cs4270_mode_ratios[i].ratio == ratio)\r\nbreak;\r\n}\r\nif (i == NUM_MCLK_RATIOS) {\r\ndev_err(codec->dev, "could not find matching ratio\n");\r\nreturn -EINVAL;\r\n}\r\nreg = snd_soc_read(codec, CS4270_MODE);\r\nreg &= ~(CS4270_MODE_SPEED_MASK | CS4270_MODE_DIV_MASK);\r\nreg |= cs4270_mode_ratios[i].mclk;\r\nif (cs4270->slave_mode)\r\nreg |= CS4270_MODE_SLAVE;\r\nelse\r\nreg |= cs4270_mode_ratios[i].speed_mode;\r\nret = snd_soc_write(codec, CS4270_MODE, reg);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "i2c write failed\n");\r\nreturn ret;\r\n}\r\nreg = snd_soc_read(codec, CS4270_FORMAT);\r\nreg &= ~(CS4270_FORMAT_DAC_MASK | CS4270_FORMAT_ADC_MASK);\r\nswitch (cs4270->mode) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nreg |= CS4270_FORMAT_DAC_I2S | CS4270_FORMAT_ADC_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nreg |= CS4270_FORMAT_DAC_LJ | CS4270_FORMAT_ADC_LJ;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "unknown dai format\n");\r\nreturn -EINVAL;\r\n}\r\nret = snd_soc_write(codec, CS4270_FORMAT, reg);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "i2c write failed\n");\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cs4270_dai_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct cs4270_private *cs4270 = snd_soc_codec_get_drvdata(codec);\r\nint reg6;\r\nreg6 = snd_soc_read(codec, CS4270_MUTE);\r\nif (mute)\r\nreg6 |= CS4270_MUTE_DAC_A | CS4270_MUTE_DAC_B;\r\nelse {\r\nreg6 &= ~(CS4270_MUTE_DAC_A | CS4270_MUTE_DAC_B);\r\nreg6 |= cs4270->manual_mute;\r\n}\r\nreturn snd_soc_write(codec, CS4270_MUTE, reg6);\r\n}\r\nstatic int cs4270_soc_put_mute(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct cs4270_private *cs4270 = snd_soc_codec_get_drvdata(codec);\r\nint left = !ucontrol->value.integer.value[0];\r\nint right = !ucontrol->value.integer.value[1];\r\ncs4270->manual_mute = (left ? CS4270_MUTE_DAC_A : 0) |\r\n(right ? CS4270_MUTE_DAC_B : 0);\r\nreturn snd_soc_put_volsw(kcontrol, ucontrol);\r\n}\r\nstatic int cs4270_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct cs4270_private *cs4270 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nret = snd_soc_update_bits(codec, CS4270_MUTE, CS4270_MUTE_AUTO, 0);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "i2c write failed\n");\r\nreturn ret;\r\n}\r\nret = snd_soc_update_bits(codec, CS4270_TRANS,\r\nCS4270_TRANS_SOFT | CS4270_TRANS_ZERO, 0);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "i2c write failed\n");\r\nreturn ret;\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(cs4270->supplies),\r\ncs4270->supplies);\r\nreturn ret;\r\n}\r\nstatic int cs4270_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct cs4270_private *cs4270 = snd_soc_codec_get_drvdata(codec);\r\nregulator_bulk_disable(ARRAY_SIZE(cs4270->supplies), cs4270->supplies);\r\nreturn 0;\r\n}\r\nstatic int cs4270_soc_suspend(struct snd_soc_codec *codec)\r\n{\r\nstruct cs4270_private *cs4270 = snd_soc_codec_get_drvdata(codec);\r\nint reg, ret;\r\nreg = snd_soc_read(codec, CS4270_PWRCTL) | CS4270_PWRCTL_PDN_ALL;\r\nif (reg < 0)\r\nreturn reg;\r\nret = snd_soc_write(codec, CS4270_PWRCTL, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nregulator_bulk_disable(ARRAY_SIZE(cs4270->supplies),\r\ncs4270->supplies);\r\nreturn 0;\r\n}\r\nstatic int cs4270_soc_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct cs4270_private *cs4270 = snd_soc_codec_get_drvdata(codec);\r\nint reg, ret;\r\nret = regulator_bulk_enable(ARRAY_SIZE(cs4270->supplies),\r\ncs4270->supplies);\r\nif (ret != 0)\r\nreturn ret;\r\nndelay(500);\r\nregcache_sync(cs4270->regmap);\r\nreg = snd_soc_read(codec, CS4270_PWRCTL);\r\nreg &= ~CS4270_PWRCTL_PDN_ALL;\r\nreturn snd_soc_write(codec, CS4270_PWRCTL, reg);\r\n}\r\nstatic int cs4270_i2c_probe(struct i2c_client *i2c_client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device_node *np = i2c_client->dev.of_node;\r\nstruct cs4270_private *cs4270;\r\nunsigned int val;\r\nint ret, i;\r\ncs4270 = devm_kzalloc(&i2c_client->dev, sizeof(struct cs4270_private),\r\nGFP_KERNEL);\r\nif (!cs4270)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ARRAY_SIZE(supply_names); i++)\r\ncs4270->supplies[i].supply = supply_names[i];\r\nret = devm_regulator_bulk_get(&i2c_client->dev,\r\nARRAY_SIZE(cs4270->supplies),\r\ncs4270->supplies);\r\nif (ret < 0)\r\nreturn ret;\r\nif (np) {\r\nenum of_gpio_flags flags;\r\nint gpio = of_get_named_gpio_flags(np, "reset-gpio", 0, &flags);\r\nif (gpio_is_valid(gpio)) {\r\nret = devm_gpio_request_one(&i2c_client->dev, gpio,\r\nflags & OF_GPIO_ACTIVE_LOW ?\r\nGPIOF_OUT_INIT_LOW : GPIOF_OUT_INIT_HIGH,\r\n"cs4270 reset");\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n}\r\ncs4270->regmap = devm_regmap_init_i2c(i2c_client, &cs4270_regmap);\r\nif (IS_ERR(cs4270->regmap))\r\nreturn PTR_ERR(cs4270->regmap);\r\nret = regmap_read(cs4270->regmap, CS4270_CHIPID, &val);\r\nif (ret < 0) {\r\ndev_err(&i2c_client->dev, "failed to read i2c at addr %X\n",\r\ni2c_client->addr);\r\nreturn ret;\r\n}\r\nif ((val & 0xF0) != 0xC0) {\r\ndev_err(&i2c_client->dev, "device at addr %X is not a CS4270\n",\r\ni2c_client->addr);\r\nreturn -ENODEV;\r\n}\r\ndev_info(&i2c_client->dev, "found device at i2c address %X\n",\r\ni2c_client->addr);\r\ndev_info(&i2c_client->dev, "hardware revision %X\n", val & 0xF);\r\ni2c_set_clientdata(i2c_client, cs4270);\r\nret = snd_soc_register_codec(&i2c_client->dev,\r\n&soc_codec_device_cs4270, &cs4270_dai, 1);\r\nreturn ret;\r\n}\r\nstatic int cs4270_i2c_remove(struct i2c_client *i2c_client)\r\n{\r\nsnd_soc_unregister_codec(&i2c_client->dev);\r\nreturn 0;\r\n}
