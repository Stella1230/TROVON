void\r\ncfs_percpt_lock_free(struct cfs_percpt_lock *pcl)\r\n{\r\nLASSERT(pcl->pcl_locks);\r\nLASSERT(!pcl->pcl_locked);\r\ncfs_percpt_free(pcl->pcl_locks);\r\nLIBCFS_FREE(pcl, sizeof(*pcl));\r\n}\r\nstruct cfs_percpt_lock *\r\ncfs_percpt_lock_create(struct cfs_cpt_table *cptab,\r\nstruct lock_class_key *keys)\r\n{\r\nstruct cfs_percpt_lock *pcl;\r\nspinlock_t *lock;\r\nint i;\r\nLIBCFS_ALLOC(pcl, sizeof(*pcl));\r\nif (!pcl)\r\nreturn NULL;\r\npcl->pcl_cptab = cptab;\r\npcl->pcl_locks = cfs_percpt_alloc(cptab, sizeof(*lock));\r\nif (!pcl->pcl_locks) {\r\nLIBCFS_FREE(pcl, sizeof(*pcl));\r\nreturn NULL;\r\n}\r\nif (!keys)\r\nCWARN("Cannot setup class key for percpt lock, you may see recursive locking warnings which are actually fake.\n");\r\ncfs_percpt_for_each(lock, i, pcl->pcl_locks) {\r\nspin_lock_init(lock);\r\nif (keys)\r\nlockdep_set_class(lock, &keys[i]);\r\n}\r\nreturn pcl;\r\n}\r\nvoid\r\ncfs_percpt_lock(struct cfs_percpt_lock *pcl, int index)\r\n__acquires(pcl->pcl_locks)\r\n{\r\nint ncpt = cfs_cpt_number(pcl->pcl_cptab);\r\nint i;\r\nLASSERT(index >= CFS_PERCPT_LOCK_EX && index < ncpt);\r\nif (ncpt == 1) {\r\nindex = 0;\r\n} else {\r\nwhile (pcl->pcl_locked)\r\ncpu_relax();\r\n}\r\nif (likely(index != CFS_PERCPT_LOCK_EX)) {\r\nspin_lock(pcl->pcl_locks[index]);\r\nreturn;\r\n}\r\nfor (i = 0; i < ncpt; i++) {\r\nspin_lock(pcl->pcl_locks[i]);\r\nif (!i) {\r\nLASSERT(!pcl->pcl_locked);\r\npcl->pcl_locked = 1;\r\n}\r\n}\r\n}\r\nvoid\r\ncfs_percpt_unlock(struct cfs_percpt_lock *pcl, int index)\r\n__releases(pcl->pcl_locks)\r\n{\r\nint ncpt = cfs_cpt_number(pcl->pcl_cptab);\r\nint i;\r\nindex = ncpt == 1 ? 0 : index;\r\nif (likely(index != CFS_PERCPT_LOCK_EX)) {\r\nspin_unlock(pcl->pcl_locks[index]);\r\nreturn;\r\n}\r\nfor (i = ncpt - 1; i >= 0; i--) {\r\nif (!i) {\r\nLASSERT(pcl->pcl_locked);\r\npcl->pcl_locked = 0;\r\n}\r\nspin_unlock(pcl->pcl_locks[i]);\r\n}\r\n}
