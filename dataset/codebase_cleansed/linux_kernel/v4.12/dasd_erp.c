struct dasd_ccw_req *\r\ndasd_alloc_erp_request(char *magic, int cplength, int datasize,\r\nstruct dasd_device * device)\r\n{\r\nunsigned long flags;\r\nstruct dasd_ccw_req *cqr;\r\nchar *data;\r\nint size;\r\nBUG_ON( magic == NULL || datasize > PAGE_SIZE ||\r\n(cplength*sizeof(struct ccw1)) > PAGE_SIZE);\r\nsize = (sizeof(struct dasd_ccw_req) + 7L) & -8L;\r\nif (cplength > 0)\r\nsize += cplength * sizeof(struct ccw1);\r\nif (datasize > 0)\r\nsize += datasize;\r\nspin_lock_irqsave(&device->mem_lock, flags);\r\ncqr = (struct dasd_ccw_req *)\r\ndasd_alloc_chunk(&device->erp_chunks, size);\r\nspin_unlock_irqrestore(&device->mem_lock, flags);\r\nif (cqr == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nmemset(cqr, 0, sizeof(struct dasd_ccw_req));\r\nINIT_LIST_HEAD(&cqr->devlist);\r\nINIT_LIST_HEAD(&cqr->blocklist);\r\ndata = (char *) cqr + ((sizeof(struct dasd_ccw_req) + 7L) & -8L);\r\ncqr->cpaddr = NULL;\r\nif (cplength > 0) {\r\ncqr->cpaddr = (struct ccw1 *) data;\r\ndata += cplength*sizeof(struct ccw1);\r\nmemset(cqr->cpaddr, 0, cplength*sizeof(struct ccw1));\r\n}\r\ncqr->data = NULL;\r\nif (datasize > 0) {\r\ncqr->data = data;\r\nmemset(cqr->data, 0, datasize);\r\n}\r\nstrncpy((char *) &cqr->magic, magic, 4);\r\nASCEBC((char *) &cqr->magic, 4);\r\nset_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);\r\ndasd_get_device(device);\r\nreturn cqr;\r\n}\r\nvoid\r\ndasd_free_erp_request(struct dasd_ccw_req *cqr, struct dasd_device * device)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&device->mem_lock, flags);\r\ndasd_free_chunk(&device->erp_chunks, cqr);\r\nspin_unlock_irqrestore(&device->mem_lock, flags);\r\natomic_dec(&device->ref_count);\r\n}\r\nstruct dasd_ccw_req *\r\ndasd_default_erp_action(struct dasd_ccw_req *cqr)\r\n{\r\nstruct dasd_device *device;\r\ndevice = cqr->startdev;\r\nif (cqr->retries > 0) {\r\nDBF_DEV_EVENT(DBF_DEBUG, device,\r\n"default ERP called (%i retries left)",\r\ncqr->retries);\r\nif (!test_bit(DASD_CQR_VERIFY_PATH, &cqr->flags))\r\ncqr->lpm = dasd_path_get_opm(device);\r\ncqr->status = DASD_CQR_FILLED;\r\n} else {\r\npr_err("%s: default ERP has run out of retries and failed\n",\r\ndev_name(&device->cdev->dev));\r\ncqr->status = DASD_CQR_FAILED;\r\ncqr->stopclk = get_tod_clock();\r\n}\r\nreturn cqr;\r\n}\r\nstruct dasd_ccw_req *dasd_default_erp_postaction(struct dasd_ccw_req *cqr)\r\n{\r\nint success;\r\nunsigned long long startclk, stopclk;\r\nstruct dasd_device *startdev;\r\nBUG_ON(cqr->refers == NULL || cqr->function == NULL);\r\nsuccess = cqr->status == DASD_CQR_DONE;\r\nstartclk = cqr->startclk;\r\nstopclk = cqr->stopclk;\r\nstartdev = cqr->startdev;\r\nwhile (cqr->refers != NULL) {\r\nstruct dasd_ccw_req *refers;\r\nrefers = cqr->refers;\r\nlist_del(&cqr->blocklist);\r\ndasd_free_erp_request(cqr, cqr->memdev);\r\ncqr = refers;\r\n}\r\ncqr->startclk = startclk;\r\ncqr->stopclk = stopclk;\r\ncqr->startdev = startdev;\r\nif (success)\r\ncqr->status = DASD_CQR_DONE;\r\nelse {\r\ncqr->status = DASD_CQR_FAILED;\r\ncqr->stopclk = get_tod_clock();\r\n}\r\nreturn cqr;\r\n}\r\nvoid\r\ndasd_log_sense(struct dasd_ccw_req *cqr, struct irb *irb)\r\n{\r\nstruct dasd_device *device;\r\ndevice = cqr->startdev;\r\nif (cqr->intrc == -ETIMEDOUT) {\r\ndev_err(&device->cdev->dev,\r\n"A timeout error occurred for cqr %p\n", cqr);\r\nreturn;\r\n}\r\nif (cqr->intrc == -ENOLINK) {\r\ndev_err(&device->cdev->dev,\r\n"A transport error occurred for cqr %p\n", cqr);\r\nreturn;\r\n}\r\nif (device->discipline && device->discipline->dump_sense)\r\ndevice->discipline->dump_sense(device, cqr, irb);\r\n}\r\nvoid\r\ndasd_log_sense_dbf(struct dasd_ccw_req *cqr, struct irb *irb)\r\n{\r\nstruct dasd_device *device;\r\ndevice = cqr->startdev;\r\nif (device->discipline && device->discipline->dump_sense_dbf)\r\ndevice->discipline->dump_sense_dbf(device, irb, "log");\r\n}
