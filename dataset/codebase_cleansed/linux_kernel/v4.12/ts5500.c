static int __init ts5500_check_signature(void)\r\n{\r\nvoid __iomem *bios;\r\nint i, ret = -ENODEV;\r\nbios = ioremap(0xf0000, 0x10000);\r\nif (!bios)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ARRAY_SIZE(ts5500_signatures); i++) {\r\nif (check_signature(bios + ts5500_signatures[i].offset,\r\nts5500_signatures[i].string,\r\nstrlen(ts5500_signatures[i].string))) {\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\niounmap(bios);\r\nreturn ret;\r\n}\r\nstatic int __init ts5500_detect_config(struct ts5500_sbc *sbc)\r\n{\r\nu8 tmp;\r\nint ret = 0;\r\nif (!request_region(TS5500_PRODUCT_CODE_ADDR, 4, "ts5500"))\r\nreturn -EBUSY;\r\nsbc->id = inb(TS5500_PRODUCT_CODE_ADDR);\r\nif (sbc->id == TS5500_PRODUCT_CODE) {\r\nsbc->name = "TS-5500";\r\n} else if (sbc->id == TS5400_PRODUCT_CODE) {\r\nsbc->name = "TS-5400";\r\n} else {\r\npr_err("ts5500: unknown product code 0x%x\n", sbc->id);\r\nret = -ENODEV;\r\ngoto cleanup;\r\n}\r\ntmp = inb(TS5500_SRAM_RS485_ADC_ADDR);\r\nsbc->sram = tmp & TS5500_SRAM;\r\nsbc->rs485 = tmp & TS5500_RS485;\r\nsbc->adc = tmp & TS5500_ADC;\r\ntmp = inb(TS5500_ERESET_ITR_ADDR);\r\nsbc->ereset = tmp & TS5500_ERESET;\r\nsbc->itr = tmp & TS5500_ITR;\r\ntmp = inb(TS5500_LED_JP_ADDR);\r\nsbc->jumpers = tmp & ~TS5500_LED;\r\ncleanup:\r\nrelease_region(TS5500_PRODUCT_CODE_ADDR, 4);\r\nreturn ret;\r\n}\r\nstatic ssize_t name_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ts5500_sbc *sbc = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n", sbc->name);\r\n}\r\nstatic ssize_t id_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ts5500_sbc *sbc = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "0x%.2x\n", sbc->id);\r\n}\r\nstatic ssize_t jumpers_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ts5500_sbc *sbc = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "0x%.2x\n", sbc->jumpers >> 1);\r\n}\r\nstatic void ts5500_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness brightness)\r\n{\r\noutb(!!brightness, TS5500_LED_JP_ADDR);\r\n}\r\nstatic enum led_brightness ts5500_led_get(struct led_classdev *led_cdev)\r\n{\r\nreturn (inb(TS5500_LED_JP_ADDR) & TS5500_LED) ? LED_FULL : LED_OFF;\r\n}\r\nstatic int ts5500_adc_convert(u8 ctrl)\r\n{\r\nu8 lsb, msb;\r\noutb(ctrl & 0x1f, TS5500_ADC_CONV_INIT_LSB_ADDR);\r\nudelay(TS5500_ADC_CONV_DELAY);\r\nif (inb(TS5500_ADC_CONV_BUSY_ADDR) & TS5500_ADC_CONV_BUSY)\r\nreturn -EBUSY;\r\nlsb = inb(TS5500_ADC_CONV_INIT_LSB_ADDR);\r\nmsb = inb(TS5500_ADC_CONV_MSB_ADDR);\r\nreturn (msb << 8) | lsb;\r\n}\r\nstatic int __init ts5500_init(void)\r\n{\r\nstruct platform_device *pdev;\r\nstruct ts5500_sbc *sbc;\r\nint err;\r\nerr = ts5500_check_signature();\r\nif (err)\r\nreturn err;\r\npdev = platform_device_register_simple("ts5500", -1, NULL, 0);\r\nif (IS_ERR(pdev))\r\nreturn PTR_ERR(pdev);\r\nsbc = devm_kzalloc(&pdev->dev, sizeof(struct ts5500_sbc), GFP_KERNEL);\r\nif (!sbc) {\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\nerr = ts5500_detect_config(sbc);\r\nif (err)\r\ngoto error;\r\nplatform_set_drvdata(pdev, sbc);\r\nerr = sysfs_create_group(&pdev->dev.kobj, &ts5500_attr_group);\r\nif (err)\r\ngoto error;\r\nif (sbc->id == TS5500_PRODUCT_CODE) {\r\nts5500_dio1_pdev.dev.parent = &pdev->dev;\r\nif (platform_device_register(&ts5500_dio1_pdev))\r\ndev_warn(&pdev->dev, "DIO1 block registration failed\n");\r\nts5500_dio2_pdev.dev.parent = &pdev->dev;\r\nif (platform_device_register(&ts5500_dio2_pdev))\r\ndev_warn(&pdev->dev, "DIO2 block registration failed\n");\r\n}\r\nif (led_classdev_register(&pdev->dev, &ts5500_led_cdev))\r\ndev_warn(&pdev->dev, "LED registration failed\n");\r\nif (sbc->adc) {\r\nts5500_adc_pdev.dev.parent = &pdev->dev;\r\nif (platform_device_register(&ts5500_adc_pdev))\r\ndev_warn(&pdev->dev, "ADC registration failed\n");\r\n}\r\nreturn 0;\r\nerror:\r\nplatform_device_unregister(pdev);\r\nreturn err;\r\n}
