static int max98925_dac_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct max98925_priv *max98925 = snd_soc_codec_get_drvdata(codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nregmap_update_bits(max98925->regmap,\r\nMAX98925_BLOCK_ENABLE,\r\nM98925_BST_EN_MASK |\r\nM98925_ADC_IMON_EN_MASK | M98925_ADC_VMON_EN_MASK,\r\nM98925_BST_EN_MASK |\r\nM98925_ADC_IMON_EN_MASK | M98925_ADC_VMON_EN_MASK);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nregmap_update_bits(max98925->regmap,\r\nMAX98925_BLOCK_ENABLE, M98925_BST_EN_MASK |\r\nM98925_ADC_IMON_EN_MASK | M98925_ADC_VMON_EN_MASK, 0);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool max98925_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase MAX98925_VBAT_DATA:\r\ncase MAX98925_VBST_DATA:\r\ncase MAX98925_LIVE_STATUS0:\r\ncase MAX98925_LIVE_STATUS1:\r\ncase MAX98925_LIVE_STATUS2:\r\ncase MAX98925_STATE0:\r\ncase MAX98925_STATE1:\r\ncase MAX98925_STATE2:\r\ncase MAX98925_FLAG0:\r\ncase MAX98925_FLAG1:\r\ncase MAX98925_FLAG2:\r\ncase MAX98925_REV_VERSION:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool max98925_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase MAX98925_IRQ_CLEAR0:\r\ncase MAX98925_IRQ_CLEAR1:\r\ncase MAX98925_IRQ_CLEAR2:\r\ncase MAX98925_ALC_HOLD_RLS:\r\nreturn false;\r\ndefault:\r\nreturn true;\r\n}\r\n}\r\nstatic inline int max98925_rate_value(struct snd_soc_codec *codec,\r\nint rate, int clock, int *value, int *n, int *m)\r\n{\r\nint ret = -EINVAL;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(rate_table); i++) {\r\nif (rate_table[i].rate >= rate) {\r\n*value = rate_table[i].sr;\r\n*n = rate_table[i].divisors[clock][0];\r\n*m = rate_table[i].divisors[clock][1];\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void max98925_set_sense_data(struct max98925_priv *max98925)\r\n{\r\nregmap_update_bits(max98925->regmap,\r\nMAX98925_DOUT_CFG_VMON,\r\nM98925_DAI_VMON_EN_MASK, M98925_DAI_VMON_EN_MASK);\r\nregmap_update_bits(max98925->regmap,\r\nMAX98925_DOUT_CFG_VMON,\r\nM98925_DAI_VMON_SLOT_MASK,\r\nmax98925->v_slot << M98925_DAI_VMON_SLOT_SHIFT);\r\nregmap_update_bits(max98925->regmap,\r\nMAX98925_DOUT_CFG_IMON,\r\nM98925_DAI_IMON_EN_MASK, M98925_DAI_IMON_EN_MASK);\r\nregmap_update_bits(max98925->regmap,\r\nMAX98925_DOUT_CFG_IMON,\r\nM98925_DAI_IMON_SLOT_MASK,\r\nmax98925->i_slot << M98925_DAI_IMON_SLOT_SHIFT);\r\n}\r\nstatic int max98925_dai_set_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct max98925_priv *max98925 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int invert = 0;\r\ndev_dbg(codec->dev, "%s: fmt 0x%08X\n", __func__, fmt);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nregmap_update_bits(max98925->regmap,\r\nMAX98925_DAI_CLK_MODE2,\r\nM98925_DAI_MAS_MASK, 0);\r\nmax98925_set_sense_data(max98925);\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nregmap_update_bits(max98925->regmap,\r\nMAX98925_DAI_CLK_MODE2,\r\nM98925_DAI_MAS_MASK, M98925_DAI_MAS_MASK);\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\ndefault:\r\ndev_err(codec->dev, "DAI clock mode unsupported");\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\ninvert = M98925_DAI_WCI_MASK;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\ninvert = M98925_DAI_BCI_MASK;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\ninvert = M98925_DAI_BCI_MASK | M98925_DAI_WCI_MASK;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "DAI invert mode unsupported");\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(max98925->regmap, MAX98925_FORMAT,\r\nM98925_DAI_BCI_MASK | M98925_DAI_WCI_MASK, invert);\r\nreturn 0;\r\n}\r\nstatic int max98925_set_clock(struct max98925_priv *max98925,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nunsigned int dai_sr = 0, clock, mdll, n, m;\r\nstruct snd_soc_codec *codec = max98925->codec;\r\nint rate = params_rate(params);\r\nint blr_clk_ratio = params_channels(params) * max98925->ch_size;\r\nswitch (blr_clk_ratio) {\r\ncase 32:\r\nregmap_update_bits(max98925->regmap,\r\nMAX98925_DAI_CLK_MODE2,\r\nM98925_DAI_BSEL_MASK, M98925_DAI_BSEL_32);\r\nbreak;\r\ncase 48:\r\nregmap_update_bits(max98925->regmap,\r\nMAX98925_DAI_CLK_MODE2,\r\nM98925_DAI_BSEL_MASK, M98925_DAI_BSEL_48);\r\nbreak;\r\ncase 64:\r\nregmap_update_bits(max98925->regmap,\r\nMAX98925_DAI_CLK_MODE2,\r\nM98925_DAI_BSEL_MASK, M98925_DAI_BSEL_64);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (max98925->sysclk) {\r\ncase 6000000:\r\nclock = 0;\r\nmdll = M98925_MDLL_MULT_MCLKx16;\r\nbreak;\r\ncase 11289600:\r\nclock = 1;\r\nmdll = M98925_MDLL_MULT_MCLKx8;\r\nbreak;\r\ncase 12000000:\r\nclock = 0;\r\nmdll = M98925_MDLL_MULT_MCLKx8;\r\nbreak;\r\ncase 12288000:\r\nclock = 2;\r\nmdll = M98925_MDLL_MULT_MCLKx8;\r\nbreak;\r\ndefault:\r\ndev_info(max98925->codec->dev, "unsupported sysclk %d\n",\r\nmax98925->sysclk);\r\nreturn -EINVAL;\r\n}\r\nif (max98925_rate_value(codec, rate, clock, &dai_sr, &n, &m))\r\nreturn -EINVAL;\r\nregmap_update_bits(max98925->regmap,\r\nMAX98925_DAI_CLK_MODE2,\r\nM98925_DAI_SR_MASK, dai_sr << M98925_DAI_SR_SHIFT);\r\nregmap_write(max98925->regmap,\r\nMAX98925_DAI_CLK_DIV_M_MSBS, m >> 8);\r\nregmap_write(max98925->regmap,\r\nMAX98925_DAI_CLK_DIV_M_LSBS, m & 0xFF);\r\nregmap_write(max98925->regmap,\r\nMAX98925_DAI_CLK_DIV_N_MSBS, n >> 8);\r\nregmap_write(max98925->regmap,\r\nMAX98925_DAI_CLK_DIV_N_LSBS, n & 0xFF);\r\nregmap_update_bits(max98925->regmap, MAX98925_DAI_CLK_MODE1,\r\nM98925_MDLL_MULT_MASK, mdll << M98925_MDLL_MULT_SHIFT);\r\nreturn 0;\r\n}\r\nstatic int max98925_dai_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct max98925_priv *max98925 = snd_soc_codec_get_drvdata(codec);\r\nswitch (params_width(params)) {\r\ncase 16:\r\nregmap_update_bits(max98925->regmap,\r\nMAX98925_FORMAT,\r\nM98925_DAI_CHANSZ_MASK, M98925_DAI_CHANSZ_16);\r\nmax98925->ch_size = 16;\r\nbreak;\r\ncase 24:\r\nregmap_update_bits(max98925->regmap,\r\nMAX98925_FORMAT,\r\nM98925_DAI_CHANSZ_MASK, M98925_DAI_CHANSZ_24);\r\nmax98925->ch_size = 24;\r\nbreak;\r\ncase 32:\r\nregmap_update_bits(max98925->regmap,\r\nMAX98925_FORMAT,\r\nM98925_DAI_CHANSZ_MASK, M98925_DAI_CHANSZ_32);\r\nmax98925->ch_size = 32;\r\nbreak;\r\ndefault:\r\npr_err("%s: format unsupported %d",\r\n__func__, params_format(params));\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(codec->dev, "%s: format supported %d",\r\n__func__, params_format(params));\r\nreturn max98925_set_clock(max98925, params);\r\n}\r\nstatic int max98925_dai_set_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct max98925_priv *max98925 = snd_soc_codec_get_drvdata(codec);\r\nswitch (clk_id) {\r\ncase 0:\r\nregmap_update_bits(max98925->regmap,\r\nMAX98925_DAI_CLK_MODE1,\r\nM98925_DAI_CLK_SOURCE_MASK, 0);\r\nbreak;\r\ncase 1:\r\nregmap_update_bits(max98925->regmap,\r\nMAX98925_DAI_CLK_MODE1,\r\nM98925_DAI_CLK_SOURCE_MASK,\r\nM98925_DAI_CLK_SOURCE_MASK);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmax98925->sysclk = freq;\r\nreturn 0;\r\n}\r\nstatic int max98925_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct max98925_priv *max98925 = snd_soc_codec_get_drvdata(codec);\r\nmax98925->codec = codec;\r\nregmap_write(max98925->regmap, MAX98925_GLOBAL_ENABLE, 0x00);\r\nregmap_write(max98925->regmap,\r\nMAX98925_FORMAT, M98925_DAI_DLY_MASK);\r\nregmap_write(max98925->regmap, MAX98925_TDM_SLOT_SELECT, 0xC8);\r\nregmap_write(max98925->regmap, MAX98925_DOUT_HIZ_CFG1, 0xFF);\r\nregmap_write(max98925->regmap, MAX98925_DOUT_HIZ_CFG2, 0xFF);\r\nregmap_write(max98925->regmap, MAX98925_DOUT_HIZ_CFG3, 0xFF);\r\nregmap_write(max98925->regmap, MAX98925_DOUT_HIZ_CFG4, 0xF0);\r\nregmap_write(max98925->regmap, MAX98925_FILTERS, 0xD8);\r\nregmap_write(max98925->regmap, MAX98925_ALC_CONFIGURATION, 0xF8);\r\nregmap_write(max98925->regmap, MAX98925_CONFIGURATION, 0xF0);\r\nregmap_write(max98925->regmap, MAX98925_BOOST_LIMITER, 0xF8);\r\nreturn 0;\r\n}\r\nstatic int max98925_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret, reg;\r\nu32 value;\r\nstruct max98925_priv *max98925;\r\nmax98925 = devm_kzalloc(&i2c->dev,\r\nsizeof(*max98925), GFP_KERNEL);\r\nif (!max98925)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, max98925);\r\nmax98925->regmap = devm_regmap_init_i2c(i2c, &max98925_regmap);\r\nif (IS_ERR(max98925->regmap)) {\r\nret = PTR_ERR(max98925->regmap);\r\ndev_err(&i2c->dev,\r\n"Failed to allocate regmap: %d\n", ret);\r\ngoto err_out;\r\n}\r\nif (!of_property_read_u32(i2c->dev.of_node, "vmon-slot-no", &value)) {\r\nif (value > M98925_DAI_VMON_SLOT_1E_1F) {\r\ndev_err(&i2c->dev, "vmon slot number is wrong:\n");\r\nreturn -EINVAL;\r\n}\r\nmax98925->v_slot = value;\r\n}\r\nif (!of_property_read_u32(i2c->dev.of_node, "imon-slot-no", &value)) {\r\nif (value > M98925_DAI_IMON_SLOT_1E_1F) {\r\ndev_err(&i2c->dev, "imon slot number is wrong:\n");\r\nreturn -EINVAL;\r\n}\r\nmax98925->i_slot = value;\r\n}\r\nret = regmap_read(max98925->regmap,\r\nMAX98925_REV_VERSION, &reg);\r\nif ((ret < 0) ||\r\n((reg != MAX98925_VERSION) &&\r\n(reg != MAX98925_VERSION1))) {\r\ndev_err(&i2c->dev,\r\n"device initialization error (%d 0x%02X)\n",\r\nret, reg);\r\ngoto err_out;\r\n}\r\ndev_info(&i2c->dev, "device version 0x%02X\n", reg);\r\nret = snd_soc_register_codec(&i2c->dev, &soc_codec_dev_max98925,\r\nmax98925_dai, ARRAY_SIZE(max98925_dai));\r\nif (ret < 0)\r\ndev_err(&i2c->dev,\r\n"Failed to register codec: %d\n", ret);\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic int max98925_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
