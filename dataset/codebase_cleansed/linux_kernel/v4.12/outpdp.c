int\r\nnvkm_output_dp_train(struct nvkm_output *base, u32 datarate)\r\n{\r\nstruct nvkm_output_dp *outp = nvkm_output_dp(base);\r\nbool retrain = true;\r\nu8 link[2], stat[3];\r\nu32 linkrate;\r\nint ret, i;\r\nmutex_lock(&outp->mutex);\r\nret = nvkm_rdaux(outp->aux, DPCD_LC00_LINK_BW_SET, link, 2);\r\nif (ret) {\r\nOUTP_DBG(&outp->base,\r\n"failed to read link config, assuming no sink");\r\ngoto done;\r\n}\r\nlinkrate = link[0] * 27000 * (link[1] & DPCD_LC01_LANE_COUNT_SET);\r\nlinkrate = (linkrate * 8) / 10;\r\ndatarate = (datarate + 9) / 10;\r\nif (linkrate < datarate) {\r\nOUTP_DBG(&outp->base, "link not trained at sufficient rate");\r\ngoto done;\r\n}\r\nret = nvkm_rdaux(outp->aux, DPCD_LS02, stat, 3);\r\nif (ret) {\r\nOUTP_DBG(&outp->base,\r\n"failed to read link status, assuming no sink");\r\ngoto done;\r\n}\r\nif (stat[2] & DPCD_LS04_INTERLANE_ALIGN_DONE) {\r\nfor (i = 0; i < (link[1] & DPCD_LC01_LANE_COUNT_SET); i++) {\r\nu8 lane = (stat[i >> 1] >> ((i & 1) * 4)) & 0x0f;\r\nif (!(lane & DPCD_LS02_LANE0_CR_DONE) ||\r\n!(lane & DPCD_LS02_LANE0_CHANNEL_EQ_DONE) ||\r\n!(lane & DPCD_LS02_LANE0_SYMBOL_LOCKED)) {\r\nOUTP_DBG(&outp->base,\r\n"lane %d not equalised", lane);\r\ngoto done;\r\n}\r\n}\r\nretrain = false;\r\n} else {\r\nOUTP_DBG(&outp->base, "no inter-lane alignment");\r\n}\r\ndone:\r\nif (retrain || !atomic_read(&outp->lt.done)) {\r\nif (outp->dpcd[DPCD_RC00_DPCD_REV] == 0x00) {\r\noutp->dpcd[DPCD_RC01_MAX_LINK_RATE] =\r\noutp->base.info.dpconf.link_bw;\r\noutp->dpcd[DPCD_RC02] =\r\noutp->base.info.dpconf.link_nr;\r\n}\r\nnvkm_dp_train(outp);\r\n}\r\nmutex_unlock(&outp->mutex);\r\nreturn ret;\r\n}\r\nstatic void\r\nnvkm_output_dp_enable(struct nvkm_output_dp *outp, bool enable)\r\n{\r\nstruct nvkm_i2c_aux *aux = outp->aux;\r\nif (enable) {\r\nif (!outp->present) {\r\nOUTP_DBG(&outp->base, "aux power -> always");\r\nnvkm_i2c_aux_monitor(aux, true);\r\noutp->present = true;\r\n}\r\nif (!nvkm_rdaux(aux, DPCD_RC00_DPCD_REV, outp->dpcd,\r\nsizeof(outp->dpcd))) {\r\nnvkm_output_dp_train(&outp->base, 0);\r\nreturn;\r\n}\r\n}\r\nif (outp->present) {\r\nOUTP_DBG(&outp->base, "aux power -> demand");\r\nnvkm_i2c_aux_monitor(aux, false);\r\noutp->present = false;\r\n}\r\natomic_set(&outp->lt.done, 0);\r\n}\r\nstatic int\r\nnvkm_output_dp_hpd(struct nvkm_notify *notify)\r\n{\r\nconst struct nvkm_i2c_ntfy_rep *line = notify->data;\r\nstruct nvkm_output_dp *outp = container_of(notify, typeof(*outp), hpd);\r\nstruct nvkm_connector *conn = outp->base.conn;\r\nstruct nvkm_disp *disp = outp->base.disp;\r\nstruct nvif_notify_conn_rep_v0 rep = {};\r\nOUTP_DBG(&outp->base, "HPD: %d", line->mask);\r\nnvkm_output_dp_enable(outp, true);\r\nif (line->mask & NVKM_I2C_UNPLUG)\r\nrep.mask |= NVIF_NOTIFY_CONN_V0_UNPLUG;\r\nif (line->mask & NVKM_I2C_PLUG)\r\nrep.mask |= NVIF_NOTIFY_CONN_V0_PLUG;\r\nnvkm_event_send(&disp->hpd, rep.mask, conn->index, &rep, sizeof(rep));\r\nreturn NVKM_NOTIFY_KEEP;\r\n}\r\nstatic int\r\nnvkm_output_dp_irq(struct nvkm_notify *notify)\r\n{\r\nconst struct nvkm_i2c_ntfy_rep *line = notify->data;\r\nstruct nvkm_output_dp *outp = container_of(notify, typeof(*outp), irq);\r\nstruct nvkm_connector *conn = outp->base.conn;\r\nstruct nvkm_disp *disp = outp->base.disp;\r\nstruct nvif_notify_conn_rep_v0 rep = {\r\n.mask = NVIF_NOTIFY_CONN_V0_IRQ,\r\n};\r\nOUTP_DBG(&outp->base, "IRQ: %d", line->mask);\r\nnvkm_output_dp_train(&outp->base, 0);\r\nnvkm_event_send(&disp->hpd, rep.mask, conn->index, &rep, sizeof(rep));\r\nreturn NVKM_NOTIFY_KEEP;\r\n}\r\nstatic void\r\nnvkm_output_dp_fini(struct nvkm_output *base)\r\n{\r\nstruct nvkm_output_dp *outp = nvkm_output_dp(base);\r\nnvkm_notify_put(&outp->hpd);\r\nnvkm_notify_put(&outp->irq);\r\nnvkm_output_dp_enable(outp, false);\r\n}\r\nstatic void\r\nnvkm_output_dp_init(struct nvkm_output *base)\r\n{\r\nstruct nvkm_output_dp *outp = nvkm_output_dp(base);\r\nnvkm_notify_put(&outp->base.conn->hpd);\r\nnvkm_output_dp_enable(outp, true);\r\nnvkm_notify_get(&outp->irq);\r\nnvkm_notify_get(&outp->hpd);\r\n}\r\nstatic void *\r\nnvkm_output_dp_dtor(struct nvkm_output *base)\r\n{\r\nstruct nvkm_output_dp *outp = nvkm_output_dp(base);\r\nnvkm_notify_fini(&outp->hpd);\r\nnvkm_notify_fini(&outp->irq);\r\nreturn outp;\r\n}\r\nint\r\nnvkm_output_dp_ctor(const struct nvkm_output_dp_func *func,\r\nstruct nvkm_disp *disp, int index, struct dcb_output *dcbE,\r\nstruct nvkm_i2c_aux *aux, struct nvkm_output_dp *outp)\r\n{\r\nstruct nvkm_device *device = disp->engine.subdev.device;\r\nstruct nvkm_bios *bios = device->bios;\r\nstruct nvkm_i2c *i2c = device->i2c;\r\nu8 hdr, cnt, len;\r\nu32 data;\r\nint ret;\r\nnvkm_output_ctor(&nvkm_output_dp_func, disp, index, dcbE, &outp->base);\r\noutp->func = func;\r\noutp->aux = aux;\r\nif (!outp->aux) {\r\nOUTP_ERR(&outp->base, "no aux");\r\nreturn -ENODEV;\r\n}\r\ndata = nvbios_dpout_match(bios, outp->base.info.hasht,\r\noutp->base.info.hashm, &outp->version,\r\n&hdr, &cnt, &len, &outp->info);\r\nif (!data) {\r\nOUTP_ERR(&outp->base, "no bios dp data");\r\nreturn -ENODEV;\r\n}\r\nOUTP_DBG(&outp->base, "bios dp %02x %02x %02x %02x",\r\noutp->version, hdr, cnt, len);\r\nret = nvkm_notify_init(NULL, &i2c->event, nvkm_output_dp_irq, true,\r\n&(struct nvkm_i2c_ntfy_req) {\r\n.mask = NVKM_I2C_IRQ,\r\n.port = outp->aux->id,\r\n},\r\nsizeof(struct nvkm_i2c_ntfy_req),\r\nsizeof(struct nvkm_i2c_ntfy_rep),\r\n&outp->irq);\r\nif (ret) {\r\nOUTP_ERR(&outp->base, "error monitoring aux irq: %d", ret);\r\nreturn ret;\r\n}\r\nmutex_init(&outp->mutex);\r\natomic_set(&outp->lt.done, 0);\r\nret = nvkm_notify_init(NULL, &i2c->event, nvkm_output_dp_hpd, true,\r\n&(struct nvkm_i2c_ntfy_req) {\r\n.mask = NVKM_I2C_PLUG | NVKM_I2C_UNPLUG,\r\n.port = outp->aux->id,\r\n},\r\nsizeof(struct nvkm_i2c_ntfy_req),\r\nsizeof(struct nvkm_i2c_ntfy_rep),\r\n&outp->hpd);\r\nif (ret) {\r\nOUTP_ERR(&outp->base, "error monitoring aux hpd: %d", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nnvkm_output_dp_new_(const struct nvkm_output_dp_func *func,\r\nstruct nvkm_disp *disp, int index, struct dcb_output *dcbE,\r\nstruct nvkm_output **poutp)\r\n{\r\nstruct nvkm_i2c *i2c = disp->engine.subdev.device->i2c;\r\nstruct nvkm_i2c_aux *aux = nvkm_i2c_aux_find(i2c, dcbE->i2c_index);\r\nstruct nvkm_output_dp *outp;\r\nif (!(outp = kzalloc(sizeof(*outp), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\n*poutp = &outp->base;\r\nreturn nvkm_output_dp_ctor(func, disp, index, dcbE, aux, outp);\r\n}
