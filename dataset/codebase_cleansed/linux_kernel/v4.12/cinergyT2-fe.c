static uint16_t compute_tps(struct dtv_frontend_properties *op)\r\n{\r\nuint16_t tps = 0;\r\nswitch (op->code_rate_HP) {\r\ncase FEC_2_3:\r\ntps |= (1 << 7);\r\nbreak;\r\ncase FEC_3_4:\r\ntps |= (2 << 7);\r\nbreak;\r\ncase FEC_5_6:\r\ntps |= (3 << 7);\r\nbreak;\r\ncase FEC_7_8:\r\ntps |= (4 << 7);\r\nbreak;\r\ncase FEC_1_2:\r\ncase FEC_AUTO:\r\ndefault:\r\n;\r\n}\r\nswitch (op->code_rate_LP) {\r\ncase FEC_2_3:\r\ntps |= (1 << 4);\r\nbreak;\r\ncase FEC_3_4:\r\ntps |= (2 << 4);\r\nbreak;\r\ncase FEC_5_6:\r\ntps |= (3 << 4);\r\nbreak;\r\ncase FEC_7_8:\r\ntps |= (4 << 4);\r\nbreak;\r\ncase FEC_1_2:\r\ncase FEC_AUTO:\r\ndefault:\r\n;\r\n}\r\nswitch (op->modulation) {\r\ncase QAM_16:\r\ntps |= (1 << 13);\r\nbreak;\r\ncase QAM_64:\r\ntps |= (2 << 13);\r\nbreak;\r\ncase QPSK:\r\ndefault:\r\n;\r\n}\r\nswitch (op->transmission_mode) {\r\ncase TRANSMISSION_MODE_8K:\r\ntps |= (1 << 0);\r\nbreak;\r\ncase TRANSMISSION_MODE_2K:\r\ndefault:\r\n;\r\n}\r\nswitch (op->guard_interval) {\r\ncase GUARD_INTERVAL_1_16:\r\ntps |= (1 << 2);\r\nbreak;\r\ncase GUARD_INTERVAL_1_8:\r\ntps |= (2 << 2);\r\nbreak;\r\ncase GUARD_INTERVAL_1_4:\r\ntps |= (3 << 2);\r\nbreak;\r\ncase GUARD_INTERVAL_1_32:\r\ndefault:\r\n;\r\n}\r\nswitch (op->hierarchy) {\r\ncase HIERARCHY_1:\r\ntps |= (1 << 10);\r\nbreak;\r\ncase HIERARCHY_2:\r\ntps |= (2 << 10);\r\nbreak;\r\ncase HIERARCHY_4:\r\ntps |= (3 << 10);\r\nbreak;\r\ncase HIERARCHY_NONE:\r\ndefault:\r\n;\r\n}\r\nreturn tps;\r\n}\r\nstatic int cinergyt2_fe_read_status(struct dvb_frontend *fe,\r\nenum fe_status *status)\r\n{\r\nstruct cinergyt2_fe_state *state = fe->demodulator_priv;\r\nint ret;\r\nmutex_lock(&state->data_mutex);\r\nstate->data[0] = CINERGYT2_EP1_GET_TUNER_STATUS;\r\nret = dvb_usb_generic_rw(state->d, state->data, 1,\r\nstate->data, sizeof(state->status), 0);\r\nif (!ret)\r\nmemcpy(&state->status, state->data, sizeof(state->status));\r\nmutex_unlock(&state->data_mutex);\r\nif (ret < 0)\r\nreturn ret;\r\n*status = 0;\r\nif (0xffff - le16_to_cpu(state->status.gain) > 30)\r\n*status |= FE_HAS_SIGNAL;\r\nif (state->status.lock_bits & (1 << 6))\r\n*status |= FE_HAS_LOCK;\r\nif (state->status.lock_bits & (1 << 5))\r\n*status |= FE_HAS_SYNC;\r\nif (state->status.lock_bits & (1 << 4))\r\n*status |= FE_HAS_CARRIER;\r\nif (state->status.lock_bits & (1 << 1))\r\n*status |= FE_HAS_VITERBI;\r\nif ((*status & (FE_HAS_CARRIER | FE_HAS_VITERBI | FE_HAS_SYNC)) !=\r\n(FE_HAS_CARRIER | FE_HAS_VITERBI | FE_HAS_SYNC))\r\n*status &= ~FE_HAS_LOCK;\r\nreturn 0;\r\n}\r\nstatic int cinergyt2_fe_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct cinergyt2_fe_state *state = fe->demodulator_priv;\r\n*ber = le32_to_cpu(state->status.viterbi_error_rate);\r\nreturn 0;\r\n}\r\nstatic int cinergyt2_fe_read_unc_blocks(struct dvb_frontend *fe, u32 *unc)\r\n{\r\nstruct cinergyt2_fe_state *state = fe->demodulator_priv;\r\n*unc = le32_to_cpu(state->status.uncorrected_block_count);\r\nreturn 0;\r\n}\r\nstatic int cinergyt2_fe_read_signal_strength(struct dvb_frontend *fe,\r\nu16 *strength)\r\n{\r\nstruct cinergyt2_fe_state *state = fe->demodulator_priv;\r\n*strength = (0xffff - le16_to_cpu(state->status.gain));\r\nreturn 0;\r\n}\r\nstatic int cinergyt2_fe_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct cinergyt2_fe_state *state = fe->demodulator_priv;\r\n*snr = (state->status.snr << 8) | state->status.snr;\r\nreturn 0;\r\n}\r\nstatic int cinergyt2_fe_init(struct dvb_frontend *fe)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cinergyt2_fe_sleep(struct dvb_frontend *fe)\r\n{\r\ndeb_info("cinergyt2_fe_sleep() Called\n");\r\nreturn 0;\r\n}\r\nstatic int cinergyt2_fe_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *tune)\r\n{\r\ntune->min_delay_ms = 800;\r\nreturn 0;\r\n}\r\nstatic int cinergyt2_fe_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *fep = &fe->dtv_property_cache;\r\nstruct cinergyt2_fe_state *state = fe->demodulator_priv;\r\nstruct dvbt_set_parameters_msg *param;\r\nint err;\r\nmutex_lock(&state->data_mutex);\r\nparam = (void *)state->data;\r\nparam->cmd = CINERGYT2_EP1_SET_TUNER_PARAMETERS;\r\nparam->tps = cpu_to_le16(compute_tps(fep));\r\nparam->freq = cpu_to_le32(fep->frequency / 1000);\r\nparam->flags = 0;\r\nswitch (fep->bandwidth_hz) {\r\ndefault:\r\ncase 8000000:\r\nparam->bandwidth = 8;\r\nbreak;\r\ncase 7000000:\r\nparam->bandwidth = 7;\r\nbreak;\r\ncase 6000000:\r\nparam->bandwidth = 6;\r\nbreak;\r\n}\r\nerr = dvb_usb_generic_rw(state->d, state->data, sizeof(*param),\r\nstate->data, 2, 0);\r\nif (err < 0)\r\nerr("cinergyt2_fe_set_frontend() Failed! err=%d\n", err);\r\nmutex_unlock(&state->data_mutex);\r\nreturn (err < 0) ? err : 0;\r\n}\r\nstatic void cinergyt2_fe_release(struct dvb_frontend *fe)\r\n{\r\nstruct cinergyt2_fe_state *state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *cinergyt2_fe_attach(struct dvb_usb_device *d)\r\n{\r\nstruct cinergyt2_fe_state *s = kzalloc(sizeof(\r\nstruct cinergyt2_fe_state), GFP_KERNEL);\r\nif (s == NULL)\r\nreturn NULL;\r\ns->d = d;\r\nmemcpy(&s->fe.ops, &cinergyt2_fe_ops, sizeof(struct dvb_frontend_ops));\r\ns->fe.demodulator_priv = s;\r\nmutex_init(&s->data_mutex);\r\nreturn &s->fe;\r\n}
