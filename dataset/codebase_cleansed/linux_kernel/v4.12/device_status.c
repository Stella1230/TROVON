static void\r\nccw_device_msg_control_check(struct ccw_device *cdev, struct irb *irb)\r\n{\r\nstruct subchannel *sch = to_subchannel(cdev->dev.parent);\r\nchar dbf_text[15];\r\nif (!scsw_is_valid_cstat(&irb->scsw) ||\r\n!(scsw_cstat(&irb->scsw) & (SCHN_STAT_CHN_DATA_CHK |\r\nSCHN_STAT_CHN_CTRL_CHK | SCHN_STAT_INTF_CTRL_CHK)))\r\nreturn;\r\nCIO_MSG_EVENT(0, "Channel-Check or Interface-Control-Check "\r\n"received"\r\n" ... device %04x on subchannel 0.%x.%04x, dev_stat "\r\n": %02X sch_stat : %02X\n",\r\ncdev->private->dev_id.devno, sch->schid.ssid,\r\nsch->schid.sch_no,\r\nscsw_dstat(&irb->scsw), scsw_cstat(&irb->scsw));\r\nsprintf(dbf_text, "chk%x", sch->schid.sch_no);\r\nCIO_TRACE_EVENT(0, dbf_text);\r\nCIO_HEX_EVENT(0, irb, sizeof(struct irb));\r\n}\r\nstatic void\r\nccw_device_path_notoper(struct ccw_device *cdev)\r\n{\r\nstruct subchannel *sch;\r\nsch = to_subchannel(cdev->dev.parent);\r\nif (cio_update_schib(sch))\r\ngoto doverify;\r\nCIO_MSG_EVENT(0, "%s(0.%x.%04x) - path(s) %02x are "\r\n"not operational \n", __func__,\r\nsch->schid.ssid, sch->schid.sch_no,\r\nsch->schib.pmcw.pnom);\r\nsch->lpm &= ~sch->schib.pmcw.pnom;\r\ndoverify:\r\ncdev->private->flags.doverify = 1;\r\n}\r\nstatic void\r\nccw_device_accumulate_ecw(struct ccw_device *cdev, struct irb *irb)\r\n{\r\ncdev->private->irb.scsw.cmd.ectl = 0;\r\nif ((irb->scsw.cmd.stctl & SCSW_STCTL_ALERT_STATUS) &&\r\n!(irb->scsw.cmd.stctl & SCSW_STCTL_INTER_STATUS))\r\ncdev->private->irb.scsw.cmd.ectl = irb->scsw.cmd.ectl;\r\nif (!cdev->private->irb.scsw.cmd.ectl)\r\nreturn;\r\nmemcpy (&cdev->private->irb.ecw, irb->ecw, sizeof (irb->ecw));\r\n}\r\nstatic int\r\nccw_device_accumulate_esw_valid(struct irb *irb)\r\n{\r\nif (!irb->scsw.cmd.eswf &&\r\n(irb->scsw.cmd.stctl == SCSW_STCTL_STATUS_PEND))\r\nreturn 0;\r\nif (irb->scsw.cmd.stctl ==\r\n(SCSW_STCTL_INTER_STATUS|SCSW_STCTL_STATUS_PEND) &&\r\n!(irb->scsw.cmd.actl & SCSW_ACTL_SUSPENDED))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void\r\nccw_device_accumulate_esw(struct ccw_device *cdev, struct irb *irb)\r\n{\r\nstruct irb *cdev_irb;\r\nstruct sublog *cdev_sublog, *sublog;\r\nif (!ccw_device_accumulate_esw_valid(irb))\r\nreturn;\r\ncdev_irb = &cdev->private->irb;\r\ncdev_irb->esw.esw1.lpum = irb->esw.esw1.lpum;\r\nif (irb->scsw.cmd.eswf) {\r\ncdev_sublog = &cdev_irb->esw.esw0.sublog;\r\nsublog = &irb->esw.esw0.sublog;\r\ncdev_sublog->esf = sublog->esf;\r\nif (irb->scsw.cmd.cstat & (SCHN_STAT_CHN_DATA_CHK |\r\nSCHN_STAT_CHN_CTRL_CHK |\r\nSCHN_STAT_INTF_CTRL_CHK)) {\r\ncdev_sublog->arep = sublog->arep;\r\ncdev_sublog->fvf = sublog->fvf;\r\ncdev_sublog->sacc = sublog->sacc;\r\ncdev_sublog->termc = sublog->termc;\r\ncdev_sublog->seqc = sublog->seqc;\r\n}\r\ncdev_sublog->devsc = sublog->devsc;\r\ncdev_sublog->serr = sublog->serr;\r\ncdev_sublog->ioerr = sublog->ioerr;\r\nif (irb->scsw.cmd.cstat & SCHN_STAT_INTF_CTRL_CHK)\r\ncdev_irb->esw.esw0.erw.cpt = irb->esw.esw0.erw.cpt;\r\ncdev_irb->esw.esw0.erw.fsavf = irb->esw.esw0.erw.fsavf;\r\nif (cdev_irb->esw.esw0.erw.fsavf) {\r\nmemcpy(cdev_irb->esw.esw0.faddr, irb->esw.esw0.faddr,\r\nsizeof (irb->esw.esw0.faddr));\r\ncdev_irb->esw.esw0.erw.fsaf = irb->esw.esw0.erw.fsaf;\r\n}\r\ncdev_irb->esw.esw0.erw.scavf = irb->esw.esw0.erw.scavf;\r\nif (irb->esw.esw0.erw.scavf)\r\ncdev_irb->esw.esw0.saddr = irb->esw.esw0.saddr;\r\n}\r\ncdev_irb->esw.esw0.erw.auth = irb->esw.esw0.erw.auth;\r\ncdev_irb->esw.esw0.erw.pvrf = irb->esw.esw0.erw.pvrf;\r\nif (irb->esw.esw0.erw.pvrf)\r\ncdev->private->flags.doverify = 1;\r\ncdev_irb->esw.esw0.erw.cons = irb->esw.esw0.erw.cons;\r\nif (irb->esw.esw0.erw.cons)\r\ncdev_irb->esw.esw0.erw.scnt = irb->esw.esw0.erw.scnt;\r\n}\r\nvoid\r\nccw_device_accumulate_irb(struct ccw_device *cdev, struct irb *irb)\r\n{\r\nstruct irb *cdev_irb;\r\nif (!(scsw_stctl(&irb->scsw) & SCSW_STCTL_STATUS_PEND))\r\nreturn;\r\nccw_device_msg_control_check(cdev, irb);\r\nif (scsw_is_valid_pno(&irb->scsw) && scsw_pno(&irb->scsw))\r\nccw_device_path_notoper(cdev);\r\nif (scsw_is_tm(&irb->scsw)) {\r\nmemcpy(&cdev->private->irb, irb, sizeof(struct irb));\r\nreturn;\r\n}\r\nif (!scsw_is_solicited(&irb->scsw))\r\nreturn;\r\ncdev_irb = &cdev->private->irb;\r\nif (irb->scsw.cmd.fctl & SCSW_FCTL_CLEAR_FUNC)\r\nmemset(&cdev->private->irb, 0, sizeof(struct irb));\r\nif (irb->scsw.cmd.fctl & SCSW_FCTL_START_FUNC) {\r\ncdev_irb->scsw.cmd.key = irb->scsw.cmd.key;\r\ncdev_irb->scsw.cmd.sctl = irb->scsw.cmd.sctl;\r\ncdev_irb->scsw.cmd.cc |= irb->scsw.cmd.cc;\r\ncdev_irb->scsw.cmd.fmt = irb->scsw.cmd.fmt;\r\ncdev_irb->scsw.cmd.pfch = irb->scsw.cmd.pfch;\r\ncdev_irb->scsw.cmd.isic = irb->scsw.cmd.isic;\r\ncdev_irb->scsw.cmd.alcc = irb->scsw.cmd.alcc;\r\ncdev_irb->scsw.cmd.ssi = irb->scsw.cmd.ssi;\r\n}\r\nccw_device_accumulate_ecw(cdev, irb);\r\ncdev_irb->scsw.cmd.fctl |= irb->scsw.cmd.fctl;\r\ncdev_irb->scsw.cmd.actl = irb->scsw.cmd.actl;\r\ncdev_irb->scsw.cmd.stctl |= irb->scsw.cmd.stctl;\r\nif ((irb->scsw.cmd.stctl & SCSW_STCTL_PRIM_STATUS) ||\r\n((irb->scsw.cmd.stctl ==\r\n(SCSW_STCTL_INTER_STATUS|SCSW_STCTL_STATUS_PEND)) &&\r\n(irb->scsw.cmd.actl & SCSW_ACTL_DEVACT) &&\r\n(irb->scsw.cmd.actl & SCSW_ACTL_SCHACT)) ||\r\n(irb->scsw.cmd.actl & SCSW_ACTL_SUSPENDED))\r\ncdev_irb->scsw.cmd.cpa = irb->scsw.cmd.cpa;\r\ncdev_irb->scsw.cmd.dstat &= ~DEV_STAT_BUSY;\r\nif (irb->scsw.cmd.stctl &\r\n(SCSW_STCTL_PRIM_STATUS | SCSW_STCTL_SEC_STATUS\r\n| SCSW_STCTL_INTER_STATUS | SCSW_STCTL_ALERT_STATUS))\r\ncdev_irb->scsw.cmd.dstat |= irb->scsw.cmd.dstat;\r\ncdev_irb->scsw.cmd.cstat |= irb->scsw.cmd.cstat;\r\nif ((irb->scsw.cmd.stctl & SCSW_STCTL_PRIM_STATUS) &&\r\n(irb->scsw.cmd.cstat & ~(SCHN_STAT_PCI | SCHN_STAT_INCORR_LEN))\r\n== 0)\r\ncdev_irb->scsw.cmd.count = irb->scsw.cmd.count;\r\nccw_device_accumulate_esw(cdev, irb);\r\nif ((cdev_irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK) &&\r\n!(cdev_irb->esw.esw0.erw.cons))\r\ncdev->private->flags.dosense = 1;\r\n}\r\nint\r\nccw_device_do_sense(struct ccw_device *cdev, struct irb *irb)\r\n{\r\nstruct subchannel *sch;\r\nstruct ccw1 *sense_ccw;\r\nint rc;\r\nsch = to_subchannel(cdev->dev.parent);\r\nif (scsw_actl(&irb->scsw) & (SCSW_ACTL_DEVACT | SCSW_ACTL_SCHACT))\r\nreturn -EBUSY;\r\nsense_ccw = &to_io_private(sch)->sense_ccw;\r\nsense_ccw->cmd_code = CCW_CMD_BASIC_SENSE;\r\nsense_ccw->cda = (__u32) __pa(cdev->private->irb.ecw);\r\nsense_ccw->count = SENSE_MAX_COUNT;\r\nsense_ccw->flags = CCW_FLAG_SLI;\r\nrc = cio_start(sch, sense_ccw, 0xff);\r\nif (rc == -ENODEV || rc == -EACCES)\r\ndev_fsm_event(cdev, DEV_EVENT_VERIFY);\r\nreturn rc;\r\n}\r\nvoid\r\nccw_device_accumulate_basic_sense(struct ccw_device *cdev, struct irb *irb)\r\n{\r\nif (!(scsw_stctl(&irb->scsw) & SCSW_STCTL_STATUS_PEND))\r\nreturn;\r\nccw_device_msg_control_check(cdev, irb);\r\nif (scsw_is_valid_pno(&irb->scsw) && scsw_pno(&irb->scsw))\r\nccw_device_path_notoper(cdev);\r\nif (!(irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK) &&\r\n(irb->scsw.cmd.dstat & DEV_STAT_CHN_END)) {\r\ncdev->private->irb.esw.esw0.erw.cons = 1;\r\ncdev->private->flags.dosense = 0;\r\n}\r\nif (ccw_device_accumulate_esw_valid(irb) &&\r\nirb->esw.esw0.erw.pvrf)\r\ncdev->private->flags.doverify = 1;\r\n}\r\nint\r\nccw_device_accumulate_and_sense(struct ccw_device *cdev, struct irb *irb)\r\n{\r\nccw_device_accumulate_irb(cdev, irb);\r\nif ((irb->scsw.cmd.actl & (SCSW_ACTL_DEVACT | SCSW_ACTL_SCHACT)) != 0)\r\nreturn -EBUSY;\r\nif (cdev->private->flags.dosense &&\r\n!(irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK)) {\r\ncdev->private->irb.esw.esw0.erw.cons = 1;\r\ncdev->private->flags.dosense = 0;\r\nreturn 0;\r\n}\r\nif (cdev->private->flags.dosense) {\r\nccw_device_do_sense(cdev, irb);\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}
