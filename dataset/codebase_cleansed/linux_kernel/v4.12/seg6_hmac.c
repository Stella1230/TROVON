static int seg6_hmac_cmpfn(struct rhashtable_compare_arg *arg, const void *obj)\r\n{\r\nconst struct seg6_hmac_info *hinfo = obj;\r\nreturn (hinfo->hmackeyid != *(__u32 *)arg->key);\r\n}\r\nstatic inline void seg6_hinfo_release(struct seg6_hmac_info *hinfo)\r\n{\r\nkfree_rcu(hinfo, rcu);\r\n}\r\nstatic void seg6_free_hi(void *ptr, void *arg)\r\n{\r\nstruct seg6_hmac_info *hinfo = (struct seg6_hmac_info *)ptr;\r\nif (hinfo)\r\nseg6_hinfo_release(hinfo);\r\n}\r\nstatic struct sr6_tlv_hmac *seg6_get_tlv_hmac(struct ipv6_sr_hdr *srh)\r\n{\r\nstruct sr6_tlv_hmac *tlv;\r\nif (srh->hdrlen < (srh->first_segment + 1) * 2 + 5)\r\nreturn NULL;\r\nif (!sr_has_hmac(srh))\r\nreturn NULL;\r\ntlv = (struct sr6_tlv_hmac *)\r\n((char *)srh + ((srh->hdrlen + 1) << 3) - 40);\r\nif (tlv->tlvhdr.type != SR6_TLV_HMAC || tlv->tlvhdr.len != 38)\r\nreturn NULL;\r\nreturn tlv;\r\n}\r\nstatic struct seg6_hmac_algo *__hmac_get_algo(u8 alg_id)\r\n{\r\nstruct seg6_hmac_algo *algo;\r\nint i, alg_count;\r\nalg_count = sizeof(hmac_algos) / sizeof(struct seg6_hmac_algo);\r\nfor (i = 0; i < alg_count; i++) {\r\nalgo = &hmac_algos[i];\r\nif (algo->alg_id == alg_id)\r\nreturn algo;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int __do_hmac(struct seg6_hmac_info *hinfo, const char *text, u8 psize,\r\nu8 *output, int outlen)\r\n{\r\nstruct seg6_hmac_algo *algo;\r\nstruct crypto_shash *tfm;\r\nstruct shash_desc *shash;\r\nint ret, dgsize;\r\nalgo = __hmac_get_algo(hinfo->alg_id);\r\nif (!algo)\r\nreturn -ENOENT;\r\ntfm = *this_cpu_ptr(algo->tfms);\r\ndgsize = crypto_shash_digestsize(tfm);\r\nif (dgsize > outlen) {\r\npr_debug("sr-ipv6: __do_hmac: digest size too big (%d / %d)\n",\r\ndgsize, outlen);\r\nreturn -ENOMEM;\r\n}\r\nret = crypto_shash_setkey(tfm, hinfo->secret, hinfo->slen);\r\nif (ret < 0) {\r\npr_debug("sr-ipv6: crypto_shash_setkey failed: err %d\n", ret);\r\ngoto failed;\r\n}\r\nshash = *this_cpu_ptr(algo->shashs);\r\nshash->tfm = tfm;\r\nret = crypto_shash_digest(shash, text, psize, output);\r\nif (ret < 0) {\r\npr_debug("sr-ipv6: crypto_shash_digest failed: err %d\n", ret);\r\ngoto failed;\r\n}\r\nreturn dgsize;\r\nfailed:\r\nreturn ret;\r\n}\r\nint seg6_hmac_compute(struct seg6_hmac_info *hinfo, struct ipv6_sr_hdr *hdr,\r\nstruct in6_addr *saddr, u8 *output)\r\n{\r\n__be32 hmackeyid = cpu_to_be32(hinfo->hmackeyid);\r\nu8 tmp_out[SEG6_HMAC_MAX_DIGESTSIZE];\r\nint plen, i, dgsize, wrsize;\r\nchar *ring, *off;\r\nplen = 16 + 1 + 1 + 4 + (hdr->first_segment + 1) * 16;\r\nif (plen >= SEG6_HMAC_RING_SIZE)\r\nreturn -EMSGSIZE;\r\nlocal_bh_disable();\r\nring = this_cpu_ptr(hmac_ring);\r\noff = ring;\r\nmemcpy(off, saddr, 16);\r\noff += 16;\r\n*off++ = hdr->first_segment;\r\n*off++ = hdr->flags;\r\nmemcpy(off, &hmackeyid, 4);\r\noff += 4;\r\nfor (i = 0; i < hdr->first_segment + 1; i++) {\r\nmemcpy(off, hdr->segments + i, 16);\r\noff += 16;\r\n}\r\ndgsize = __do_hmac(hinfo, ring, plen, tmp_out,\r\nSEG6_HMAC_MAX_DIGESTSIZE);\r\nlocal_bh_enable();\r\nif (dgsize < 0)\r\nreturn dgsize;\r\nwrsize = SEG6_HMAC_FIELD_LEN;\r\nif (wrsize > dgsize)\r\nwrsize = dgsize;\r\nmemset(output, 0, SEG6_HMAC_FIELD_LEN);\r\nmemcpy(output, tmp_out, wrsize);\r\nreturn 0;\r\n}\r\nbool seg6_hmac_validate_skb(struct sk_buff *skb)\r\n{\r\nu8 hmac_output[SEG6_HMAC_FIELD_LEN];\r\nstruct net *net = dev_net(skb->dev);\r\nstruct seg6_hmac_info *hinfo;\r\nstruct sr6_tlv_hmac *tlv;\r\nstruct ipv6_sr_hdr *srh;\r\nstruct inet6_dev *idev;\r\nidev = __in6_dev_get(skb->dev);\r\nsrh = (struct ipv6_sr_hdr *)skb_transport_header(skb);\r\ntlv = seg6_get_tlv_hmac(srh);\r\nif (idev->cnf.seg6_require_hmac > 0 && !tlv)\r\nreturn false;\r\nif (idev->cnf.seg6_require_hmac < 0)\r\nreturn true;\r\nif (idev->cnf.seg6_require_hmac == 0 && !tlv)\r\nreturn true;\r\nhinfo = seg6_hmac_info_lookup(net, be32_to_cpu(tlv->hmackeyid));\r\nif (!hinfo)\r\nreturn false;\r\nif (seg6_hmac_compute(hinfo, srh, &ipv6_hdr(skb)->saddr, hmac_output))\r\nreturn false;\r\nif (memcmp(hmac_output, tlv->hmac, SEG6_HMAC_FIELD_LEN) != 0)\r\nreturn false;\r\nreturn true;\r\n}\r\nstruct seg6_hmac_info *seg6_hmac_info_lookup(struct net *net, u32 key)\r\n{\r\nstruct seg6_pernet_data *sdata = seg6_pernet(net);\r\nstruct seg6_hmac_info *hinfo;\r\nhinfo = rhashtable_lookup_fast(&sdata->hmac_infos, &key, rht_params);\r\nreturn hinfo;\r\n}\r\nint seg6_hmac_info_add(struct net *net, u32 key, struct seg6_hmac_info *hinfo)\r\n{\r\nstruct seg6_pernet_data *sdata = seg6_pernet(net);\r\nint err;\r\nerr = rhashtable_lookup_insert_fast(&sdata->hmac_infos, &hinfo->node,\r\nrht_params);\r\nreturn err;\r\n}\r\nint seg6_hmac_info_del(struct net *net, u32 key)\r\n{\r\nstruct seg6_pernet_data *sdata = seg6_pernet(net);\r\nstruct seg6_hmac_info *hinfo;\r\nint err = -ENOENT;\r\nhinfo = rhashtable_lookup_fast(&sdata->hmac_infos, &key, rht_params);\r\nif (!hinfo)\r\ngoto out;\r\nerr = rhashtable_remove_fast(&sdata->hmac_infos, &hinfo->node,\r\nrht_params);\r\nif (err)\r\ngoto out;\r\nseg6_hinfo_release(hinfo);\r\nout:\r\nreturn err;\r\n}\r\nint seg6_push_hmac(struct net *net, struct in6_addr *saddr,\r\nstruct ipv6_sr_hdr *srh)\r\n{\r\nstruct seg6_hmac_info *hinfo;\r\nstruct sr6_tlv_hmac *tlv;\r\nint err = -ENOENT;\r\ntlv = seg6_get_tlv_hmac(srh);\r\nif (!tlv)\r\nreturn -EINVAL;\r\nrcu_read_lock();\r\nhinfo = seg6_hmac_info_lookup(net, be32_to_cpu(tlv->hmackeyid));\r\nif (!hinfo)\r\ngoto out;\r\nmemset(tlv->hmac, 0, SEG6_HMAC_FIELD_LEN);\r\nerr = seg6_hmac_compute(hinfo, srh, saddr, tlv->hmac);\r\nout:\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nstatic int seg6_hmac_init_algo(void)\r\n{\r\nstruct seg6_hmac_algo *algo;\r\nstruct crypto_shash *tfm;\r\nstruct shash_desc *shash;\r\nint i, alg_count, cpu;\r\nalg_count = sizeof(hmac_algos) / sizeof(struct seg6_hmac_algo);\r\nfor (i = 0; i < alg_count; i++) {\r\nstruct crypto_shash **p_tfm;\r\nint shsize;\r\nalgo = &hmac_algos[i];\r\nalgo->tfms = alloc_percpu(struct crypto_shash *);\r\nif (!algo->tfms)\r\nreturn -ENOMEM;\r\nfor_each_possible_cpu(cpu) {\r\ntfm = crypto_alloc_shash(algo->name, 0, GFP_KERNEL);\r\nif (IS_ERR(tfm))\r\nreturn PTR_ERR(tfm);\r\np_tfm = per_cpu_ptr(algo->tfms, cpu);\r\n*p_tfm = tfm;\r\n}\r\np_tfm = raw_cpu_ptr(algo->tfms);\r\ntfm = *p_tfm;\r\nshsize = sizeof(*shash) + crypto_shash_descsize(tfm);\r\nalgo->shashs = alloc_percpu(struct shash_desc *);\r\nif (!algo->shashs)\r\nreturn -ENOMEM;\r\nfor_each_possible_cpu(cpu) {\r\nshash = kzalloc_node(shsize, GFP_KERNEL,\r\ncpu_to_node(cpu));\r\nif (!shash)\r\nreturn -ENOMEM;\r\n*per_cpu_ptr(algo->shashs, cpu) = shash;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint __init seg6_hmac_init(void)\r\n{\r\nreturn seg6_hmac_init_algo();\r\n}\r\nint __net_init seg6_hmac_net_init(struct net *net)\r\n{\r\nstruct seg6_pernet_data *sdata = seg6_pernet(net);\r\nrhashtable_init(&sdata->hmac_infos, &rht_params);\r\nreturn 0;\r\n}\r\nvoid seg6_hmac_exit(void)\r\n{\r\nstruct seg6_hmac_algo *algo = NULL;\r\nint i, alg_count, cpu;\r\nalg_count = sizeof(hmac_algos) / sizeof(struct seg6_hmac_algo);\r\nfor (i = 0; i < alg_count; i++) {\r\nalgo = &hmac_algos[i];\r\nfor_each_possible_cpu(cpu) {\r\nstruct crypto_shash *tfm;\r\nstruct shash_desc *shash;\r\nshash = *per_cpu_ptr(algo->shashs, cpu);\r\nkfree(shash);\r\ntfm = *per_cpu_ptr(algo->tfms, cpu);\r\ncrypto_free_shash(tfm);\r\n}\r\nfree_percpu(algo->tfms);\r\nfree_percpu(algo->shashs);\r\n}\r\n}\r\nvoid __net_exit seg6_hmac_net_exit(struct net *net)\r\n{\r\nstruct seg6_pernet_data *sdata = seg6_pernet(net);\r\nrhashtable_free_and_destroy(&sdata->hmac_infos, seg6_free_hi, NULL);\r\n}
