static inline u32 gpio_rcar_read(struct gpio_rcar_priv *p, int offs)\r\n{\r\nreturn ioread32(p->base + offs);\r\n}\r\nstatic inline void gpio_rcar_write(struct gpio_rcar_priv *p, int offs,\r\nu32 value)\r\n{\r\niowrite32(value, p->base + offs);\r\n}\r\nstatic void gpio_rcar_modify_bit(struct gpio_rcar_priv *p, int offs,\r\nint bit, bool value)\r\n{\r\nu32 tmp = gpio_rcar_read(p, offs);\r\nif (value)\r\ntmp |= BIT(bit);\r\nelse\r\ntmp &= ~BIT(bit);\r\ngpio_rcar_write(p, offs, tmp);\r\n}\r\nstatic void gpio_rcar_irq_disable(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct gpio_rcar_priv *p = gpiochip_get_data(gc);\r\ngpio_rcar_write(p, INTMSK, ~BIT(irqd_to_hwirq(d)));\r\n}\r\nstatic void gpio_rcar_irq_enable(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct gpio_rcar_priv *p = gpiochip_get_data(gc);\r\ngpio_rcar_write(p, MSKCLR, BIT(irqd_to_hwirq(d)));\r\n}\r\nstatic void gpio_rcar_config_interrupt_input_mode(struct gpio_rcar_priv *p,\r\nunsigned int hwirq,\r\nbool active_high_rising_edge,\r\nbool level_trigger,\r\nbool both)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&p->lock, flags);\r\ngpio_rcar_modify_bit(p, POSNEG, hwirq, !active_high_rising_edge);\r\ngpio_rcar_modify_bit(p, EDGLEVEL, hwirq, !level_trigger);\r\nif (p->has_both_edge_trigger)\r\ngpio_rcar_modify_bit(p, BOTHEDGE, hwirq, both);\r\ngpio_rcar_modify_bit(p, IOINTSEL, hwirq, true);\r\nif (!level_trigger)\r\ngpio_rcar_write(p, INTCLR, BIT(hwirq));\r\nspin_unlock_irqrestore(&p->lock, flags);\r\n}\r\nstatic int gpio_rcar_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct gpio_rcar_priv *p = gpiochip_get_data(gc);\r\nunsigned int hwirq = irqd_to_hwirq(d);\r\ndev_dbg(&p->pdev->dev, "sense irq = %d, type = %d\n", hwirq, type);\r\nswitch (type & IRQ_TYPE_SENSE_MASK) {\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\ngpio_rcar_config_interrupt_input_mode(p, hwirq, true, true,\r\nfalse);\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\ngpio_rcar_config_interrupt_input_mode(p, hwirq, false, true,\r\nfalse);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_RISING:\r\ngpio_rcar_config_interrupt_input_mode(p, hwirq, true, false,\r\nfalse);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\ngpio_rcar_config_interrupt_input_mode(p, hwirq, false, false,\r\nfalse);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nif (!p->has_both_edge_trigger)\r\nreturn -EINVAL;\r\ngpio_rcar_config_interrupt_input_mode(p, hwirq, true, false,\r\ntrue);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gpio_rcar_irq_set_wake(struct irq_data *d, unsigned int on)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct gpio_rcar_priv *p = gpiochip_get_data(gc);\r\nint error;\r\nif (p->irq_parent) {\r\nerror = irq_set_irq_wake(p->irq_parent, on);\r\nif (error) {\r\ndev_dbg(&p->pdev->dev,\r\n"irq %u doesn't support irq_set_wake\n",\r\np->irq_parent);\r\np->irq_parent = 0;\r\n}\r\n}\r\nif (!p->clk)\r\nreturn 0;\r\nif (on)\r\nclk_enable(p->clk);\r\nelse\r\nclk_disable(p->clk);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t gpio_rcar_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct gpio_rcar_priv *p = dev_id;\r\nu32 pending;\r\nunsigned int offset, irqs_handled = 0;\r\nwhile ((pending = gpio_rcar_read(p, INTDT) &\r\ngpio_rcar_read(p, INTMSK))) {\r\noffset = __ffs(pending);\r\ngpio_rcar_write(p, INTCLR, BIT(offset));\r\ngeneric_handle_irq(irq_find_mapping(p->gpio_chip.irqdomain,\r\noffset));\r\nirqs_handled++;\r\n}\r\nreturn irqs_handled ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic void gpio_rcar_config_general_input_output_mode(struct gpio_chip *chip,\r\nunsigned int gpio,\r\nbool output)\r\n{\r\nstruct gpio_rcar_priv *p = gpiochip_get_data(chip);\r\nunsigned long flags;\r\nspin_lock_irqsave(&p->lock, flags);\r\ngpio_rcar_modify_bit(p, POSNEG, gpio, false);\r\ngpio_rcar_modify_bit(p, IOINTSEL, gpio, false);\r\ngpio_rcar_modify_bit(p, INOUTSEL, gpio, output);\r\nspin_unlock_irqrestore(&p->lock, flags);\r\n}\r\nstatic int gpio_rcar_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct gpio_rcar_priv *p = gpiochip_get_data(chip);\r\nint error;\r\nerror = pm_runtime_get_sync(&p->pdev->dev);\r\nif (error < 0)\r\nreturn error;\r\nerror = pinctrl_request_gpio(chip->base + offset);\r\nif (error)\r\npm_runtime_put(&p->pdev->dev);\r\nreturn error;\r\n}\r\nstatic void gpio_rcar_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct gpio_rcar_priv *p = gpiochip_get_data(chip);\r\npinctrl_free_gpio(chip->base + offset);\r\ngpio_rcar_config_general_input_output_mode(chip, offset, false);\r\npm_runtime_put(&p->pdev->dev);\r\n}\r\nstatic int gpio_rcar_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\ngpio_rcar_config_general_input_output_mode(chip, offset, false);\r\nreturn 0;\r\n}\r\nstatic int gpio_rcar_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nu32 bit = BIT(offset);\r\nif (gpio_rcar_read(gpiochip_get_data(chip), INOUTSEL) & bit)\r\nreturn !!(gpio_rcar_read(gpiochip_get_data(chip), OUTDT) & bit);\r\nelse\r\nreturn !!(gpio_rcar_read(gpiochip_get_data(chip), INDT) & bit);\r\n}\r\nstatic void gpio_rcar_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct gpio_rcar_priv *p = gpiochip_get_data(chip);\r\nunsigned long flags;\r\nspin_lock_irqsave(&p->lock, flags);\r\ngpio_rcar_modify_bit(p, OUTDT, offset, value);\r\nspin_unlock_irqrestore(&p->lock, flags);\r\n}\r\nstatic void gpio_rcar_set_multiple(struct gpio_chip *chip, unsigned long *mask,\r\nunsigned long *bits)\r\n{\r\nstruct gpio_rcar_priv *p = gpiochip_get_data(chip);\r\nunsigned long flags;\r\nu32 val, bankmask;\r\nbankmask = mask[0] & GENMASK(chip->ngpio - 1, 0);\r\nif (!bankmask)\r\nreturn;\r\nspin_lock_irqsave(&p->lock, flags);\r\nval = gpio_rcar_read(p, OUTDT);\r\nval &= ~bankmask;\r\nval |= (bankmask & bits[0]);\r\ngpio_rcar_write(p, OUTDT, val);\r\nspin_unlock_irqrestore(&p->lock, flags);\r\n}\r\nstatic int gpio_rcar_direction_output(struct gpio_chip *chip, unsigned offset,\r\nint value)\r\n{\r\ngpio_rcar_set(chip, offset, value);\r\ngpio_rcar_config_general_input_output_mode(chip, offset, true);\r\nreturn 0;\r\n}\r\nstatic int gpio_rcar_parse_dt(struct gpio_rcar_priv *p, unsigned int *npins)\r\n{\r\nstruct device_node *np = p->pdev->dev.of_node;\r\nconst struct of_device_id *match;\r\nconst struct gpio_rcar_info *info;\r\nstruct of_phandle_args args;\r\nint ret;\r\nmatch = of_match_node(gpio_rcar_of_table, np);\r\nif (!match)\r\nreturn -EINVAL;\r\ninfo = match->data;\r\nret = of_parse_phandle_with_fixed_args(np, "gpio-ranges", 3, 0, &args);\r\n*npins = ret == 0 ? args.args[2] : RCAR_MAX_GPIO_PER_BANK;\r\np->has_both_edge_trigger = info->has_both_edge_trigger;\r\np->needs_clk = info->needs_clk;\r\nif (*npins == 0 || *npins > RCAR_MAX_GPIO_PER_BANK) {\r\ndev_warn(&p->pdev->dev,\r\n"Invalid number of gpio lines %u, using %u\n", *npins,\r\nRCAR_MAX_GPIO_PER_BANK);\r\n*npins = RCAR_MAX_GPIO_PER_BANK;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gpio_rcar_probe(struct platform_device *pdev)\r\n{\r\nstruct gpio_rcar_priv *p;\r\nstruct resource *io, *irq;\r\nstruct gpio_chip *gpio_chip;\r\nstruct irq_chip *irq_chip;\r\nstruct device *dev = &pdev->dev;\r\nconst char *name = dev_name(dev);\r\nunsigned int npins;\r\nint ret;\r\np = devm_kzalloc(dev, sizeof(*p), GFP_KERNEL);\r\nif (!p)\r\nreturn -ENOMEM;\r\np->pdev = pdev;\r\nspin_lock_init(&p->lock);\r\nret = gpio_rcar_parse_dt(p, &npins);\r\nif (ret < 0)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, p);\r\np->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(p->clk)) {\r\nif (p->needs_clk) {\r\ndev_err(dev, "unable to get clock\n");\r\nret = PTR_ERR(p->clk);\r\ngoto err0;\r\n}\r\np->clk = NULL;\r\n}\r\npm_runtime_enable(dev);\r\nio = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!io || !irq) {\r\ndev_err(dev, "missing IRQ or IOMEM\n");\r\nret = -EINVAL;\r\ngoto err0;\r\n}\r\np->base = devm_ioremap_nocache(dev, io->start, resource_size(io));\r\nif (!p->base) {\r\ndev_err(dev, "failed to remap I/O memory\n");\r\nret = -ENXIO;\r\ngoto err0;\r\n}\r\ngpio_chip = &p->gpio_chip;\r\ngpio_chip->request = gpio_rcar_request;\r\ngpio_chip->free = gpio_rcar_free;\r\ngpio_chip->direction_input = gpio_rcar_direction_input;\r\ngpio_chip->get = gpio_rcar_get;\r\ngpio_chip->direction_output = gpio_rcar_direction_output;\r\ngpio_chip->set = gpio_rcar_set;\r\ngpio_chip->set_multiple = gpio_rcar_set_multiple;\r\ngpio_chip->label = name;\r\ngpio_chip->parent = dev;\r\ngpio_chip->owner = THIS_MODULE;\r\ngpio_chip->base = -1;\r\ngpio_chip->ngpio = npins;\r\nirq_chip = &p->irq_chip;\r\nirq_chip->name = name;\r\nirq_chip->parent_device = dev;\r\nirq_chip->irq_mask = gpio_rcar_irq_disable;\r\nirq_chip->irq_unmask = gpio_rcar_irq_enable;\r\nirq_chip->irq_set_type = gpio_rcar_irq_set_type;\r\nirq_chip->irq_set_wake = gpio_rcar_irq_set_wake;\r\nirq_chip->flags = IRQCHIP_SET_TYPE_MASKED | IRQCHIP_MASK_ON_SUSPEND;\r\nret = gpiochip_add_data(gpio_chip, p);\r\nif (ret) {\r\ndev_err(dev, "failed to add GPIO controller\n");\r\ngoto err0;\r\n}\r\nret = gpiochip_irqchip_add(gpio_chip, irq_chip, 0, handle_level_irq,\r\nIRQ_TYPE_NONE);\r\nif (ret) {\r\ndev_err(dev, "cannot add irqchip\n");\r\ngoto err1;\r\n}\r\np->irq_parent = irq->start;\r\nif (devm_request_irq(dev, irq->start, gpio_rcar_irq_handler,\r\nIRQF_SHARED, name, p)) {\r\ndev_err(dev, "failed to request IRQ\n");\r\nret = -ENOENT;\r\ngoto err1;\r\n}\r\ndev_info(dev, "driving %d GPIOs\n", npins);\r\nreturn 0;\r\nerr1:\r\ngpiochip_remove(gpio_chip);\r\nerr0:\r\npm_runtime_disable(dev);\r\nreturn ret;\r\n}\r\nstatic int gpio_rcar_remove(struct platform_device *pdev)\r\n{\r\nstruct gpio_rcar_priv *p = platform_get_drvdata(pdev);\r\ngpiochip_remove(&p->gpio_chip);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}
