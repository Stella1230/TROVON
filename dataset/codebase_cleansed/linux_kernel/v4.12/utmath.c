acpi_status\r\nacpi_ut_short_divide(u64 dividend,\r\nu32 divisor, u64 *out_quotient, u32 *out_remainder)\r\n{\r\nunion uint64_overlay dividend_ovl;\r\nunion uint64_overlay quotient;\r\nu32 remainder32;\r\nACPI_FUNCTION_TRACE(ut_short_divide);\r\nif (divisor == 0) {\r\nACPI_ERROR((AE_INFO, "Divide by zero"));\r\nreturn_ACPI_STATUS(AE_AML_DIVIDE_BY_ZERO);\r\n}\r\ndividend_ovl.full = dividend;\r\nACPI_DIV_64_BY_32(0, dividend_ovl.part.hi, divisor,\r\nquotient.part.hi, remainder32);\r\nACPI_DIV_64_BY_32(remainder32, dividend_ovl.part.lo, divisor,\r\nquotient.part.lo, remainder32);\r\nif (out_quotient) {\r\n*out_quotient = quotient.full;\r\n}\r\nif (out_remainder) {\r\n*out_remainder = remainder32;\r\n}\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status\r\nacpi_ut_divide(u64 in_dividend,\r\nu64 in_divisor, u64 *out_quotient, u64 *out_remainder)\r\n{\r\nunion uint64_overlay dividend;\r\nunion uint64_overlay divisor;\r\nunion uint64_overlay quotient;\r\nunion uint64_overlay remainder;\r\nunion uint64_overlay normalized_dividend;\r\nunion uint64_overlay normalized_divisor;\r\nu32 partial1;\r\nunion uint64_overlay partial2;\r\nunion uint64_overlay partial3;\r\nACPI_FUNCTION_TRACE(ut_divide);\r\nif (in_divisor == 0) {\r\nACPI_ERROR((AE_INFO, "Divide by zero"));\r\nreturn_ACPI_STATUS(AE_AML_DIVIDE_BY_ZERO);\r\n}\r\ndivisor.full = in_divisor;\r\ndividend.full = in_dividend;\r\nif (divisor.part.hi == 0) {\r\nremainder.part.hi = 0;\r\nACPI_DIV_64_BY_32(0, dividend.part.hi, divisor.part.lo,\r\nquotient.part.hi, partial1);\r\nACPI_DIV_64_BY_32(partial1, dividend.part.lo, divisor.part.lo,\r\nquotient.part.lo, remainder.part.lo);\r\n}\r\nelse {\r\nquotient.part.hi = 0;\r\nnormalized_dividend = dividend;\r\nnormalized_divisor = divisor;\r\ndo {\r\nACPI_SHIFT_RIGHT_64(normalized_divisor.part.hi,\r\nnormalized_divisor.part.lo);\r\nACPI_SHIFT_RIGHT_64(normalized_dividend.part.hi,\r\nnormalized_dividend.part.lo);\r\n} while (normalized_divisor.part.hi != 0);\r\nACPI_DIV_64_BY_32(normalized_dividend.part.hi,\r\nnormalized_dividend.part.lo,\r\nnormalized_divisor.part.lo, quotient.part.lo,\r\npartial1);\r\npartial1 = quotient.part.lo * divisor.part.hi;\r\npartial2.full = (u64) quotient.part.lo * divisor.part.lo;\r\npartial3.full = (u64) partial2.part.hi + partial1;\r\nremainder.part.hi = partial3.part.lo;\r\nremainder.part.lo = partial2.part.lo;\r\nif (partial3.part.hi == 0) {\r\nif (partial3.part.lo >= dividend.part.hi) {\r\nif (partial3.part.lo == dividend.part.hi) {\r\nif (partial2.part.lo > dividend.part.lo) {\r\nquotient.part.lo--;\r\nremainder.full -= divisor.full;\r\n}\r\n} else {\r\nquotient.part.lo--;\r\nremainder.full -= divisor.full;\r\n}\r\n}\r\nremainder.full = remainder.full - dividend.full;\r\nremainder.part.hi = (u32)-((s32)remainder.part.hi);\r\nremainder.part.lo = (u32)-((s32)remainder.part.lo);\r\nif (remainder.part.lo) {\r\nremainder.part.hi--;\r\n}\r\n}\r\n}\r\nif (out_quotient) {\r\n*out_quotient = quotient.full;\r\n}\r\nif (out_remainder) {\r\n*out_remainder = remainder.full;\r\n}\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status\r\nacpi_ut_short_divide(u64 in_dividend,\r\nu32 divisor, u64 *out_quotient, u32 *out_remainder)\r\n{\r\nACPI_FUNCTION_TRACE(ut_short_divide);\r\nif (divisor == 0) {\r\nACPI_ERROR((AE_INFO, "Divide by zero"));\r\nreturn_ACPI_STATUS(AE_AML_DIVIDE_BY_ZERO);\r\n}\r\nif (out_quotient) {\r\n*out_quotient = in_dividend / divisor;\r\n}\r\nif (out_remainder) {\r\n*out_remainder = (u32) (in_dividend % divisor);\r\n}\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status\r\nacpi_ut_divide(u64 in_dividend,\r\nu64 in_divisor, u64 *out_quotient, u64 *out_remainder)\r\n{\r\nACPI_FUNCTION_TRACE(ut_divide);\r\nif (in_divisor == 0) {\r\nACPI_ERROR((AE_INFO, "Divide by zero"));\r\nreturn_ACPI_STATUS(AE_AML_DIVIDE_BY_ZERO);\r\n}\r\nif (out_quotient) {\r\n*out_quotient = in_dividend / in_divisor;\r\n}\r\nif (out_remainder) {\r\n*out_remainder = in_dividend % in_divisor;\r\n}\r\nreturn_ACPI_STATUS(AE_OK);\r\n}
