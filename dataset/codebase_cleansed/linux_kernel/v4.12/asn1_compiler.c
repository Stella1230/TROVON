static int directive_compare(const void *_key, const void *_pdir)\r\n{\r\nconst struct token *token = _key;\r\nconst char *const *pdir = _pdir, *dir = *pdir;\r\nsize_t dlen, clen;\r\nint val;\r\ndlen = strlen(dir);\r\nclen = (dlen < token->size) ? dlen : token->size;\r\nval = memcmp(token->content, dir, clen);\r\nif (val != 0) {\r\nreturn val;\r\n}\r\nif (dlen == token->size) {\r\nreturn 0;\r\n}\r\nreturn dlen - token->size;\r\n}\r\nstatic void tokenise(char *buffer, char *end)\r\n{\r\nstruct token *tokens;\r\nchar *line, *nl, *start, *p, *q;\r\nunsigned tix, lineno;\r\ntoken_list = tokens = calloc((end - buffer) / 2, sizeof(struct token));\r\nif (!tokens) {\r\nperror(NULL);\r\nexit(1);\r\n}\r\ntix = 0;\r\nlineno = 0;\r\nwhile (buffer < end) {\r\nlineno++;\r\nline = buffer;\r\nnl = memchr(line, '\n', end - buffer);\r\nif (!nl) {\r\nbuffer = nl = end;\r\n} else {\r\nbuffer = nl + 1;\r\n*nl = '\0';\r\n}\r\np = line;\r\nnext_comment:\r\nwhile ((p = memchr(p, '-', nl - p))) {\r\nif (p[1] == '-') {\r\nq = p + 2;\r\nwhile ((q = memchr(q, '-', nl - q))) {\r\nif (q[1] == '-') {\r\nq += 2;\r\nmemmove(p, q, nl - q);\r\ngoto next_comment;\r\n}\r\nq++;\r\n}\r\n*p = '\0';\r\nnl = p;\r\nbreak;\r\n} else {\r\np++;\r\n}\r\n}\r\np = line;\r\nwhile (p < nl) {\r\nwhile (p < nl && isspace(*p))\r\n*(p++) = 0;\r\nif (p >= nl)\r\nbreak;\r\ntokens[tix].line = lineno;\r\nstart = p;\r\nif (isalpha(*p)) {\r\nconst char **dir, *start = p;\r\nq = p + 1;\r\nwhile (q < nl && (isalnum(*q) || *q == '-' || *q == '_'))\r\nq++;\r\ntokens[tix].size = q - p;\r\np = q;\r\ntokens[tix].content = malloc(tokens[tix].size + 1);\r\nif (!tokens[tix].content) {\r\nperror(NULL);\r\nexit(1);\r\n}\r\nmemcpy(tokens[tix].content, start, tokens[tix].size);\r\ntokens[tix].content[tokens[tix].size] = 0;\r\nif (islower(tokens[tix].content[0])) {\r\ntokens[tix++].token_type = TOKEN_ELEMENT_NAME;\r\ncontinue;\r\n}\r\ndir = bsearch(&tokens[tix], directives,\r\nsizeof(directives) / sizeof(directives[1]),\r\nsizeof(directives[1]),\r\ndirective_compare);\r\nif (dir) {\r\ntokens[tix++].token_type = dir - directives;\r\ncontinue;\r\n}\r\ntokens[tix++].token_type = TOKEN_TYPE_NAME;\r\ncontinue;\r\n}\r\nif (isdigit(*p)) {\r\nq = p + 1;\r\nwhile (q < nl && (isdigit(*q)))\r\nq++;\r\ntokens[tix].size = q - p;\r\np = q;\r\ntokens[tix].content = malloc(tokens[tix].size + 1);\r\nif (!tokens[tix].content) {\r\nperror(NULL);\r\nexit(1);\r\n}\r\nmemcpy(tokens[tix].content, start, tokens[tix].size);\r\ntokens[tix].content[tokens[tix].size] = 0;\r\ntokens[tix++].token_type = TOKEN_NUMBER;\r\ncontinue;\r\n}\r\nif (nl - p >= 3) {\r\nif (memcmp(p, "::=", 3) == 0) {\r\np += 3;\r\ntokens[tix].size = 3;\r\ntokens[tix].content = "::=";\r\ntokens[tix++].token_type = TOKEN_ASSIGNMENT;\r\ncontinue;\r\n}\r\n}\r\nif (nl - p >= 2) {\r\nif (memcmp(p, "({", 2) == 0) {\r\np += 2;\r\ntokens[tix].size = 2;\r\ntokens[tix].content = "({";\r\ntokens[tix++].token_type = TOKEN_OPEN_ACTION;\r\ncontinue;\r\n}\r\nif (memcmp(p, "})", 2) == 0) {\r\np += 2;\r\ntokens[tix].size = 2;\r\ntokens[tix].content = "})";\r\ntokens[tix++].token_type = TOKEN_CLOSE_ACTION;\r\ncontinue;\r\n}\r\n}\r\nif (nl - p >= 1) {\r\ntokens[tix].size = 1;\r\nswitch (*p) {\r\ncase '{':\r\np += 1;\r\ntokens[tix].content = "{";\r\ntokens[tix++].token_type = TOKEN_OPEN_CURLY;\r\ncontinue;\r\ncase '}':\r\np += 1;\r\ntokens[tix].content = "}";\r\ntokens[tix++].token_type = TOKEN_CLOSE_CURLY;\r\ncontinue;\r\ncase '[':\r\np += 1;\r\ntokens[tix].content = "[";\r\ntokens[tix++].token_type = TOKEN_OPEN_SQUARE;\r\ncontinue;\r\ncase ']':\r\np += 1;\r\ntokens[tix].content = "]";\r\ntokens[tix++].token_type = TOKEN_CLOSE_SQUARE;\r\ncontinue;\r\ncase ',':\r\np += 1;\r\ntokens[tix].content = ",";\r\ntokens[tix++].token_type = TOKEN_COMMA;\r\ncontinue;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nfprintf(stderr, "%s:%u: Unknown character in grammar: '%c'\n",\r\nfilename, lineno, *p);\r\nexit(1);\r\n}\r\n}\r\nnr_tokens = tix;\r\nverbose("Extracted %u tokens\n", nr_tokens);\r\n#if 0\r\n{\r\nint n;\r\nfor (n = 0; n < nr_tokens; n++)\r\ndebug("Token %3u: '%s'\n", n, token_list[n].content);\r\n}\r\n#endif\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nstruct stat st;\r\nssize_t readlen;\r\nFILE *out, *hdr;\r\nchar *buffer, *p;\r\nchar *kbuild_verbose;\r\nint fd;\r\nkbuild_verbose = getenv("KBUILD_VERBOSE");\r\nif (kbuild_verbose)\r\nverbose_opt = atoi(kbuild_verbose);\r\nwhile (argc > 4) {\r\nif (strcmp(argv[1], "-v") == 0)\r\nverbose_opt = true;\r\nelse if (strcmp(argv[1], "-d") == 0)\r\ndebug_opt = true;\r\nelse\r\nbreak;\r\nmemmove(&argv[1], &argv[2], (argc - 2) * sizeof(char *));\r\nargc--;\r\n}\r\nif (argc != 4) {\r\nfprintf(stderr, "Format: %s [-v] [-d] <grammar-file> <c-file> <hdr-file>\n",\r\nargv[0]);\r\nexit(2);\r\n}\r\nfilename = argv[1];\r\noutputname = argv[2];\r\nheadername = argv[3];\r\nfd = open(filename, O_RDONLY);\r\nif (fd < 0) {\r\nperror(filename);\r\nexit(1);\r\n}\r\nif (fstat(fd, &st) < 0) {\r\nperror(filename);\r\nexit(1);\r\n}\r\nif (!(buffer = malloc(st.st_size + 1))) {\r\nperror(NULL);\r\nexit(1);\r\n}\r\nif ((readlen = read(fd, buffer, st.st_size)) < 0) {\r\nperror(filename);\r\nexit(1);\r\n}\r\nif (close(fd) < 0) {\r\nperror(filename);\r\nexit(1);\r\n}\r\nif (readlen != st.st_size) {\r\nfprintf(stderr, "%s: Short read\n", filename);\r\nexit(1);\r\n}\r\np = strrchr(argv[1], '/');\r\np = p ? p + 1 : argv[1];\r\ngrammar_name = strdup(p);\r\nif (!p) {\r\nperror(NULL);\r\nexit(1);\r\n}\r\np = strchr(grammar_name, '.');\r\nif (p)\r\n*p = '\0';\r\nbuffer[readlen] = 0;\r\ntokenise(buffer, buffer + readlen);\r\nbuild_type_list();\r\nparse();\r\ndump_elements();\r\nout = fopen(outputname, "w");\r\nif (!out) {\r\nperror(outputname);\r\nexit(1);\r\n}\r\nhdr = fopen(headername, "w");\r\nif (!hdr) {\r\nperror(headername);\r\nexit(1);\r\n}\r\nrender(out, hdr);\r\nif (fclose(out) < 0) {\r\nperror(outputname);\r\nexit(1);\r\n}\r\nif (fclose(hdr) < 0) {\r\nperror(headername);\r\nexit(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int type_index_compare(const void *_a, const void *_b)\r\n{\r\nconst struct type *const *a = _a, *const *b = _b;\r\nif ((*a)->name->size != (*b)->name->size)\r\nreturn (*a)->name->size - (*b)->name->size;\r\nelse\r\nreturn memcmp((*a)->name->content, (*b)->name->content,\r\n(*a)->name->size);\r\n}\r\nstatic int type_finder(const void *_key, const void *_ti)\r\n{\r\nconst struct token *token = _key;\r\nconst struct type *const *ti = _ti;\r\nconst struct type *type = *ti;\r\nif (token->size != type->name->size)\r\nreturn token->size - type->name->size;\r\nelse\r\nreturn memcmp(token->content, type->name->content,\r\ntoken->size);\r\n}\r\nstatic void build_type_list(void)\r\n{\r\nstruct type *types;\r\nunsigned nr, t, n;\r\nnr = 0;\r\nfor (n = 0; n < nr_tokens - 1; n++)\r\nif (token_list[n + 0].token_type == TOKEN_TYPE_NAME &&\r\ntoken_list[n + 1].token_type == TOKEN_ASSIGNMENT)\r\nnr++;\r\nif (nr == 0) {\r\nfprintf(stderr, "%s: No defined types\n", filename);\r\nexit(1);\r\n}\r\nnr_types = nr;\r\ntypes = type_list = calloc(nr + 1, sizeof(type_list[0]));\r\nif (!type_list) {\r\nperror(NULL);\r\nexit(1);\r\n}\r\ntype_index = calloc(nr, sizeof(type_index[0]));\r\nif (!type_index) {\r\nperror(NULL);\r\nexit(1);\r\n}\r\nt = 0;\r\ntypes[t].flags |= TYPE_BEGIN;\r\nfor (n = 0; n < nr_tokens - 1; n++) {\r\nif (token_list[n + 0].token_type == TOKEN_TYPE_NAME &&\r\ntoken_list[n + 1].token_type == TOKEN_ASSIGNMENT) {\r\ntypes[t].name = &token_list[n];\r\ntype_index[t] = &types[t];\r\nt++;\r\n}\r\n}\r\ntypes[t].name = &token_list[n + 1];\r\ntypes[t].flags |= TYPE_STOP_MARKER;\r\nqsort(type_index, nr, sizeof(type_index[0]), type_index_compare);\r\nverbose("Extracted %u types\n", nr_types);\r\n#if 0\r\nfor (n = 0; n < nr_types; n++) {\r\nstruct type *type = type_index[n];\r\ndebug("- %*.*s\n", type->name->content);\r\n}\r\n#endif\r\n}\r\nstatic void parse(void)\r\n{\r\nstruct token *cursor;\r\nstruct type *type;\r\ntype = type_list;\r\ndo {\r\ncursor = type->name;\r\nif (cursor[0].token_type != TOKEN_TYPE_NAME ||\r\ncursor[1].token_type != TOKEN_ASSIGNMENT)\r\nabort();\r\ncursor += 2;\r\ntype->element = parse_type(&cursor, type[1].name, NULL);\r\ntype->element->type_def = type;\r\nif (cursor != type[1].name) {\r\nfprintf(stderr, "%s:%d: Parse error at token '%s'\n",\r\nfilename, cursor->line, cursor->content);\r\nexit(1);\r\n}\r\n} while (type++, !(type->flags & TYPE_STOP_MARKER));\r\nverbose("Extracted %u actions\n", nr_actions);\r\n}\r\nstatic struct element *alloc_elem(struct token *type)\r\n{\r\nstruct element *e = calloc(1, sizeof(*e));\r\nif (!e) {\r\nperror(NULL);\r\nexit(1);\r\n}\r\ne->list_next = element_list;\r\nelement_list = e;\r\nreturn e;\r\n}\r\nstatic struct element *parse_type(struct token **_cursor, struct token *end,\r\nstruct token *name)\r\n{\r\nstruct element *top, *element;\r\nstruct action *action, **ppaction;\r\nstruct token *cursor = *_cursor;\r\nstruct type **ref;\r\nchar *p;\r\nint labelled = 0, implicit = 0;\r\ntop = element = alloc_elem(cursor);\r\nelement->class = ASN1_UNIV;\r\nelement->method = ASN1_PRIM;\r\nelement->tag = token_to_tag[cursor->token_type];\r\nelement->name = name;\r\nif (cursor->token_type == TOKEN_OPEN_SQUARE) {\r\ncursor++;\r\nif (cursor >= end)\r\ngoto overrun_error;\r\nswitch (cursor->token_type) {\r\ncase DIRECTIVE_UNIVERSAL:\r\nelement->class = ASN1_UNIV;\r\ncursor++;\r\nbreak;\r\ncase DIRECTIVE_APPLICATION:\r\nelement->class = ASN1_APPL;\r\ncursor++;\r\nbreak;\r\ncase TOKEN_NUMBER:\r\nelement->class = ASN1_CONT;\r\nbreak;\r\ncase DIRECTIVE_PRIVATE:\r\nelement->class = ASN1_PRIV;\r\ncursor++;\r\nbreak;\r\ndefault:\r\nfprintf(stderr, "%s:%d: Unrecognised tag class token '%s'\n",\r\nfilename, cursor->line, cursor->content);\r\nexit(1);\r\n}\r\nif (cursor >= end)\r\ngoto overrun_error;\r\nif (cursor->token_type != TOKEN_NUMBER) {\r\nfprintf(stderr, "%s:%d: Missing tag number '%s'\n",\r\nfilename, cursor->line, cursor->content);\r\nexit(1);\r\n}\r\nelement->tag &= ~0x1f;\r\nelement->tag |= strtoul(cursor->content, &p, 10);\r\nelement->flags |= ELEMENT_TAG_SPECIFIED;\r\nif (p - cursor->content != cursor->size)\r\nabort();\r\ncursor++;\r\nif (cursor >= end)\r\ngoto overrun_error;\r\nif (cursor->token_type != TOKEN_CLOSE_SQUARE) {\r\nfprintf(stderr, "%s:%d: Missing closing square bracket '%s'\n",\r\nfilename, cursor->line, cursor->content);\r\nexit(1);\r\n}\r\ncursor++;\r\nif (cursor >= end)\r\ngoto overrun_error;\r\nlabelled = 1;\r\n}\r\nif (cursor->token_type == DIRECTIVE_IMPLICIT) {\r\nelement->flags |= ELEMENT_IMPLICIT;\r\nimplicit = 1;\r\ncursor++;\r\nif (cursor >= end)\r\ngoto overrun_error;\r\n} else if (cursor->token_type == DIRECTIVE_EXPLICIT) {\r\nelement->flags |= ELEMENT_EXPLICIT;\r\ncursor++;\r\nif (cursor >= end)\r\ngoto overrun_error;\r\n}\r\nif (labelled) {\r\nif (!implicit)\r\nelement->method |= ASN1_CONS;\r\nelement->compound = implicit ? TAG_OVERRIDE : SEQUENCE;\r\nelement->children = alloc_elem(cursor);\r\nelement = element->children;\r\nelement->class = ASN1_UNIV;\r\nelement->method = ASN1_PRIM;\r\nelement->tag = token_to_tag[cursor->token_type];\r\nelement->name = name;\r\n}\r\nelement->type = cursor;\r\nswitch (cursor->token_type) {\r\ncase DIRECTIVE_ANY:\r\nelement->compound = ANY;\r\ncursor++;\r\nbreak;\r\ncase DIRECTIVE_NULL:\r\ncase DIRECTIVE_BOOLEAN:\r\ncase DIRECTIVE_ENUMERATED:\r\ncase DIRECTIVE_INTEGER:\r\nelement->compound = NOT_COMPOUND;\r\ncursor++;\r\nbreak;\r\ncase DIRECTIVE_EXTERNAL:\r\nelement->method = ASN1_CONS;\r\ncase DIRECTIVE_BMPString:\r\ncase DIRECTIVE_GeneralString:\r\ncase DIRECTIVE_GraphicString:\r\ncase DIRECTIVE_IA5String:\r\ncase DIRECTIVE_ISO646String:\r\ncase DIRECTIVE_NumericString:\r\ncase DIRECTIVE_PrintableString:\r\ncase DIRECTIVE_T61String:\r\ncase DIRECTIVE_TeletexString:\r\ncase DIRECTIVE_UniversalString:\r\ncase DIRECTIVE_UTF8String:\r\ncase DIRECTIVE_VideotexString:\r\ncase DIRECTIVE_VisibleString:\r\ncase DIRECTIVE_ObjectDescriptor:\r\ncase DIRECTIVE_GeneralizedTime:\r\ncase DIRECTIVE_UTCTime:\r\nelement->compound = NOT_COMPOUND;\r\ncursor++;\r\nbreak;\r\ncase DIRECTIVE_BIT:\r\ncase DIRECTIVE_OCTET:\r\nelement->compound = NOT_COMPOUND;\r\ncursor++;\r\nif (cursor >= end)\r\ngoto overrun_error;\r\nif (cursor->token_type != DIRECTIVE_STRING)\r\ngoto parse_error;\r\ncursor++;\r\nbreak;\r\ncase DIRECTIVE_OBJECT:\r\nelement->compound = NOT_COMPOUND;\r\ncursor++;\r\nif (cursor >= end)\r\ngoto overrun_error;\r\nif (cursor->token_type != DIRECTIVE_IDENTIFIER)\r\ngoto parse_error;\r\ncursor++;\r\nbreak;\r\ncase TOKEN_TYPE_NAME:\r\nelement->compound = TYPE_REF;\r\nref = bsearch(cursor, type_index, nr_types, sizeof(type_index[0]),\r\ntype_finder);\r\nif (!ref) {\r\nfprintf(stderr, "%s:%d: Type '%s' undefined\n",\r\nfilename, cursor->line, cursor->content);\r\nexit(1);\r\n}\r\ncursor->type = *ref;\r\n(*ref)->ref_count++;\r\ncursor++;\r\nbreak;\r\ncase DIRECTIVE_CHOICE:\r\nelement->compound = CHOICE;\r\ncursor++;\r\nelement->children = parse_compound(&cursor, end, 1);\r\nbreak;\r\ncase DIRECTIVE_SEQUENCE:\r\nelement->compound = SEQUENCE;\r\nelement->method = ASN1_CONS;\r\ncursor++;\r\nif (cursor >= end)\r\ngoto overrun_error;\r\nif (cursor->token_type == DIRECTIVE_OF) {\r\nelement->compound = SEQUENCE_OF;\r\ncursor++;\r\nif (cursor >= end)\r\ngoto overrun_error;\r\nelement->children = parse_type(&cursor, end, NULL);\r\n} else {\r\nelement->children = parse_compound(&cursor, end, 0);\r\n}\r\nbreak;\r\ncase DIRECTIVE_SET:\r\nelement->compound = SET;\r\nelement->method = ASN1_CONS;\r\ncursor++;\r\nif (cursor >= end)\r\ngoto overrun_error;\r\nif (cursor->token_type == DIRECTIVE_OF) {\r\nelement->compound = SET_OF;\r\ncursor++;\r\nif (cursor >= end)\r\ngoto parse_error;\r\nelement->children = parse_type(&cursor, end, NULL);\r\n} else {\r\nelement->children = parse_compound(&cursor, end, 1);\r\n}\r\nbreak;\r\ndefault:\r\nfprintf(stderr, "%s:%d: Token '%s' does not introduce a type\n",\r\nfilename, cursor->line, cursor->content);\r\nexit(1);\r\n}\r\nif (cursor < end && (cursor->token_type == DIRECTIVE_OPTIONAL ||\r\ncursor->token_type == DIRECTIVE_DEFAULT)\r\n) {\r\ncursor++;\r\ntop->flags |= ELEMENT_SKIPPABLE;\r\n}\r\nif (cursor < end && cursor->token_type == TOKEN_OPEN_ACTION) {\r\ncursor++;\r\nif (cursor >= end)\r\ngoto overrun_error;\r\nif (cursor->token_type != TOKEN_ELEMENT_NAME) {\r\nfprintf(stderr, "%s:%d: Token '%s' is not an action function name\n",\r\nfilename, cursor->line, cursor->content);\r\nexit(1);\r\n}\r\naction = malloc(sizeof(struct action));\r\nif (!action) {\r\nperror(NULL);\r\nexit(1);\r\n}\r\naction->index = 0;\r\naction->name = cursor->content;\r\nfor (ppaction = &action_list;\r\n*ppaction;\r\nppaction = &(*ppaction)->next\r\n) {\r\nint cmp = strcmp(action->name, (*ppaction)->name);\r\nif (cmp == 0) {\r\nfree(action);\r\naction = *ppaction;\r\ngoto found;\r\n}\r\nif (cmp < 0) {\r\naction->next = *ppaction;\r\n*ppaction = action;\r\nnr_actions++;\r\ngoto found;\r\n}\r\n}\r\naction->next = NULL;\r\n*ppaction = action;\r\nnr_actions++;\r\nfound:\r\nelement->action = action;\r\ncursor->action = action;\r\ncursor++;\r\nif (cursor >= end)\r\ngoto overrun_error;\r\nif (cursor->token_type != TOKEN_CLOSE_ACTION) {\r\nfprintf(stderr, "%s:%d: Missing close action, got '%s'\n",\r\nfilename, cursor->line, cursor->content);\r\nexit(1);\r\n}\r\ncursor++;\r\n}\r\n*_cursor = cursor;\r\nreturn top;\r\nparse_error:\r\nfprintf(stderr, "%s:%d: Unexpected token '%s'\n",\r\nfilename, cursor->line, cursor->content);\r\nexit(1);\r\noverrun_error:\r\nfprintf(stderr, "%s: Unexpectedly hit EOF\n", filename);\r\nexit(1);\r\n}\r\nstatic struct element *parse_compound(struct token **_cursor, struct token *end,\r\nint alternates)\r\n{\r\nstruct element *children, **child_p = &children, *element;\r\nstruct token *cursor = *_cursor, *name;\r\nif (cursor->token_type != TOKEN_OPEN_CURLY) {\r\nfprintf(stderr, "%s:%d: Expected compound to start with brace not '%s'\n",\r\nfilename, cursor->line, cursor->content);\r\nexit(1);\r\n}\r\ncursor++;\r\nif (cursor >= end)\r\ngoto overrun_error;\r\nif (cursor->token_type == TOKEN_OPEN_CURLY) {\r\nfprintf(stderr, "%s:%d: Empty compound\n",\r\nfilename, cursor->line);\r\nexit(1);\r\n}\r\nfor (;;) {\r\nname = NULL;\r\nif (cursor->token_type == TOKEN_ELEMENT_NAME) {\r\nname = cursor;\r\ncursor++;\r\nif (cursor >= end)\r\ngoto overrun_error;\r\n}\r\nelement = parse_type(&cursor, end, name);\r\nif (alternates)\r\nelement->flags |= ELEMENT_SKIPPABLE | ELEMENT_CONDITIONAL;\r\n*child_p = element;\r\nchild_p = &element->next;\r\nif (cursor >= end)\r\ngoto overrun_error;\r\nif (cursor->token_type != TOKEN_COMMA)\r\nbreak;\r\ncursor++;\r\nif (cursor >= end)\r\ngoto overrun_error;\r\n}\r\nchildren->flags &= ~ELEMENT_CONDITIONAL;\r\nif (cursor->token_type != TOKEN_CLOSE_CURLY) {\r\nfprintf(stderr, "%s:%d: Expected compound closure, got '%s'\n",\r\nfilename, cursor->line, cursor->content);\r\nexit(1);\r\n}\r\ncursor++;\r\n*_cursor = cursor;\r\nreturn children;\r\noverrun_error:\r\nfprintf(stderr, "%s: Unexpectedly hit EOF\n", filename);\r\nexit(1);\r\n}\r\nstatic void dump_element(const struct element *e, int level)\r\n{\r\nconst struct element *c;\r\nconst struct type *t = e->type_def;\r\nconst char *name = e->name ? e->name->content : ".";\r\nconst char *tname = t && t->name ? t->name->content : ".";\r\nchar tag[32];\r\nif (e->class == 0 && e->method == 0 && e->tag == 0)\r\nstrcpy(tag, "<...>");\r\nelse if (e->class == ASN1_UNIV)\r\nsprintf(tag, "%s %s %s",\r\nasn1_classes[e->class],\r\nasn1_methods[e->method],\r\nasn1_universal_tags[e->tag]);\r\nelse\r\nsprintf(tag, "%s %s %u",\r\nasn1_classes[e->class],\r\nasn1_methods[e->method],\r\ne->tag);\r\nprintf("%c%c%c%c%c %c %*s[*] \e[33m%s\e[m %s %s \e[35m%s\e[m\n",\r\ne->flags & ELEMENT_IMPLICIT ? 'I' : '-',\r\ne->flags & ELEMENT_EXPLICIT ? 'E' : '-',\r\ne->flags & ELEMENT_TAG_SPECIFIED ? 'T' : '-',\r\ne->flags & ELEMENT_SKIPPABLE ? 'S' : '-',\r\ne->flags & ELEMENT_CONDITIONAL ? 'C' : '-',\r\n"-tTqQcaro"[e->compound],\r\nlevel, "",\r\ntag,\r\ntname,\r\nname,\r\ne->action ? e->action->name : "");\r\nif (e->compound == TYPE_REF)\r\ndump_element(e->type->type->element, level + 3);\r\nelse\r\nfor (c = e->children; c; c = c->next)\r\ndump_element(c, level + 3);\r\n}\r\nstatic void dump_elements(void)\r\n{\r\nif (debug_opt)\r\ndump_element(type_list[0].element, 0);\r\n}\r\nstatic void render_opcode(FILE *out, const char *fmt, ...)\r\n{\r\nva_list va;\r\nif (out) {\r\nfprintf(out, "\t[%4d] =%*s", nr_entries, render_depth, "");\r\nva_start(va, fmt);\r\nvfprintf(out, fmt, va);\r\nva_end(va);\r\n}\r\nnr_entries++;\r\n}\r\nstatic void render_more(FILE *out, const char *fmt, ...)\r\n{\r\nva_list va;\r\nif (out) {\r\nva_start(va, fmt);\r\nvfprintf(out, fmt, va);\r\nva_end(va);\r\n}\r\n}\r\nstatic void render(FILE *out, FILE *hdr)\r\n{\r\nstruct element *e;\r\nstruct action *action;\r\nstruct type *root;\r\nint index;\r\nfprintf(hdr, "/*\n");\r\nfprintf(hdr, " * Automatically generated by asn1_compiler. Do not edit\n");\r\nfprintf(hdr, " *\n");\r\nfprintf(hdr, " * ASN.1 parser for %s\n", grammar_name);\r\nfprintf(hdr, " */\n");\r\nfprintf(hdr, "#include <linux/asn1_decoder.h>\n");\r\nfprintf(hdr, "\n");\r\nfprintf(hdr, "extern const struct asn1_decoder %s_decoder;\n", grammar_name);\r\nif (ferror(hdr)) {\r\nperror(headername);\r\nexit(1);\r\n}\r\nfprintf(out, "/*\n");\r\nfprintf(out, " * Automatically generated by asn1_compiler. Do not edit\n");\r\nfprintf(out, " *\n");\r\nfprintf(out, " * ASN.1 parser for %s\n", grammar_name);\r\nfprintf(out, " */\n");\r\nfprintf(out, "#include <linux/asn1_ber_bytecode.h>\n");\r\nfprintf(out, "#include \"%s-asn1.h\"\n", grammar_name);\r\nfprintf(out, "\n");\r\nif (ferror(out)) {\r\nperror(outputname);\r\nexit(1);\r\n}\r\nfprintf(hdr, "\n");\r\nindex = 0;\r\nfor (action = action_list; action; action = action->next) {\r\naction->index = index++;\r\nfprintf(hdr,\r\n"extern int %s(void *, size_t, unsigned char,"\r\n" const void *, size_t);\n",\r\naction->name);\r\n}\r\nfprintf(hdr, "\n");\r\nfprintf(out, "enum %s_actions {\n", grammar_name);\r\nfor (action = action_list; action; action = action->next)\r\nfprintf(out, "\tACT_%s = %u,\n",\r\naction->name, action->index);\r\nfprintf(out, "\tNR__%s_actions = %u\n", grammar_name, nr_actions);\r\nfprintf(out, "};\n");\r\nfprintf(out, "\n");\r\nfprintf(out, "static const asn1_action_t %s_action_table[NR__%s_actions] = {\n",\r\ngrammar_name, grammar_name);\r\nfor (action = action_list; action; action = action->next)\r\nfprintf(out, "\t[%4u] = %s,\n", action->index, action->name);\r\nfprintf(out, "};\n");\r\nif (ferror(out)) {\r\nperror(outputname);\r\nexit(1);\r\n}\r\nverbose("Pass 1\n");\r\nnr_entries = 0;\r\nroot = &type_list[0];\r\nrender_element(NULL, root->element, NULL);\r\nrender_opcode(NULL, "ASN1_OP_COMPLETE,\n");\r\nrender_out_of_line_list(NULL);\r\nfor (e = element_list; e; e = e->list_next)\r\ne->flags &= ~ELEMENT_RENDERED;\r\nverbose("Pass 2\n");\r\nfprintf(out, "\n");\r\nfprintf(out, "static const unsigned char %s_machine[] = {\n",\r\ngrammar_name);\r\nnr_entries = 0;\r\nroot = &type_list[0];\r\nrender_element(out, root->element, NULL);\r\nrender_opcode(out, "ASN1_OP_COMPLETE,\n");\r\nrender_out_of_line_list(out);\r\nfprintf(out, "};\n");\r\nfprintf(out, "\n");\r\nfprintf(out, "const struct asn1_decoder %s_decoder = {\n", grammar_name);\r\nfprintf(out, "\t.machine = %s_machine,\n", grammar_name);\r\nfprintf(out, "\t.machlen = sizeof(%s_machine),\n", grammar_name);\r\nfprintf(out, "\t.actions = %s_action_table,\n", grammar_name);\r\nfprintf(out, "};\n");\r\n}\r\nstatic void render_out_of_line_list(FILE *out)\r\n{\r\nstruct element *e, *ce;\r\nconst char *act;\r\nint entry;\r\nwhile ((e = render_list)) {\r\nrender_list = e->render_next;\r\nif (!render_list)\r\nrender_list_p = &render_list;\r\nrender_more(out, "\n");\r\ne->entry_index = entry = nr_entries;\r\nrender_depth++;\r\nfor (ce = e->children; ce; ce = ce->next)\r\nrender_element(out, ce, NULL);\r\nrender_depth--;\r\nact = e->action ? "_ACT" : "";\r\nswitch (e->compound) {\r\ncase SEQUENCE:\r\nrender_opcode(out, "ASN1_OP_END_SEQ%s,\n", act);\r\nbreak;\r\ncase SEQUENCE_OF:\r\nrender_opcode(out, "ASN1_OP_END_SEQ_OF%s,\n", act);\r\nrender_opcode(out, "_jump_target(%u),\n", entry);\r\nbreak;\r\ncase SET:\r\nrender_opcode(out, "ASN1_OP_END_SET%s,\n", act);\r\nbreak;\r\ncase SET_OF:\r\nrender_opcode(out, "ASN1_OP_END_SET_OF%s,\n", act);\r\nrender_opcode(out, "_jump_target(%u),\n", entry);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (e->action)\r\nrender_opcode(out, "_action(ACT_%s),\n",\r\ne->action->name);\r\nrender_opcode(out, "ASN1_OP_RETURN,\n");\r\n}\r\n}\r\nstatic void render_element(FILE *out, struct element *e, struct element *tag)\r\n{\r\nstruct element *ec, *x;\r\nconst char *cond, *act;\r\nint entry, skippable = 0, outofline = 0;\r\nif (e->flags & ELEMENT_SKIPPABLE ||\r\n(tag && tag->flags & ELEMENT_SKIPPABLE))\r\nskippable = 1;\r\nif ((e->type_def && e->type_def->ref_count > 1) ||\r\nskippable)\r\noutofline = 1;\r\nif (e->type_def && out) {\r\nrender_more(out, "\t// %s\n", e->type_def->name->content);\r\n}\r\ncond = (e->flags & ELEMENT_CONDITIONAL ||\r\n(tag && tag->flags & ELEMENT_CONDITIONAL)) ? "COND_" : "";\r\nact = e->action ? "_ACT" : "";\r\nswitch (e->compound) {\r\ncase ANY:\r\nrender_opcode(out, "ASN1_OP_%sMATCH_ANY%s%s,",\r\ncond, act, skippable ? "_OR_SKIP" : "");\r\nif (e->name)\r\nrender_more(out, "\t\t// %s", e->name->content);\r\nrender_more(out, "\n");\r\ngoto dont_render_tag;\r\ncase TAG_OVERRIDE:\r\nrender_element(out, e->children, e);\r\nreturn;\r\ncase SEQUENCE:\r\ncase SEQUENCE_OF:\r\ncase SET:\r\ncase SET_OF:\r\nrender_opcode(out, "ASN1_OP_%sMATCH%s%s,",\r\ncond,\r\noutofline ? "_JUMP" : "",\r\nskippable ? "_OR_SKIP" : "");\r\nbreak;\r\ncase CHOICE:\r\ngoto dont_render_tag;\r\ncase TYPE_REF:\r\nif (e->class == ASN1_UNIV && e->method == ASN1_PRIM && e->tag == 0)\r\ngoto dont_render_tag;\r\ndefault:\r\nrender_opcode(out, "ASN1_OP_%sMATCH%s%s,",\r\ncond, act,\r\nskippable ? "_OR_SKIP" : "");\r\nbreak;\r\n}\r\nx = tag ?: e;\r\nif (x->name)\r\nrender_more(out, "\t\t// %s", x->name->content);\r\nrender_more(out, "\n");\r\nif (!tag || !(tag->flags & ELEMENT_TAG_SPECIFIED))\r\ntag = e;\r\nif (tag->class == ASN1_UNIV &&\r\ntag->tag != 14 &&\r\ntag->tag != 15 &&\r\ntag->tag != 31)\r\nrender_opcode(out, "_tag(%s, %s, %s),\n",\r\nasn1_classes[tag->class],\r\nasn1_methods[tag->method | e->method],\r\nasn1_universal_tags[tag->tag]);\r\nelse\r\nrender_opcode(out, "_tagn(%s, %s, %2u),\n",\r\nasn1_classes[tag->class],\r\nasn1_methods[tag->method | e->method],\r\ntag->tag);\r\ntag = NULL;\r\ndont_render_tag:\r\nswitch (e->compound) {\r\ncase TYPE_REF:\r\nrender_element(out, e->type->type->element, tag);\r\nif (e->action)\r\nrender_opcode(out, "ASN1_OP_%sACT,\n",\r\nskippable ? "MAYBE_" : "");\r\nbreak;\r\ncase SEQUENCE:\r\nif (outofline) {\r\nrender_opcode(out, "_jump_target(%u),", e->entry_index);\r\nif (e->type_def && e->type_def->name)\r\nrender_more(out, "\t\t// --> %s",\r\ne->type_def->name->content);\r\nrender_more(out, "\n");\r\nif (!(e->flags & ELEMENT_RENDERED)) {\r\ne->flags |= ELEMENT_RENDERED;\r\n*render_list_p = e;\r\nrender_list_p = &e->render_next;\r\n}\r\nreturn;\r\n} else {\r\nrender_depth++;\r\nfor (ec = e->children; ec; ec = ec->next)\r\nrender_element(out, ec, NULL);\r\nrender_depth--;\r\nrender_opcode(out, "ASN1_OP_END_SEQ%s,\n", act);\r\n}\r\nbreak;\r\ncase SEQUENCE_OF:\r\ncase SET_OF:\r\nif (outofline) {\r\nrender_opcode(out, "_jump_target(%u),", e->entry_index);\r\nif (e->type_def && e->type_def->name)\r\nrender_more(out, "\t\t// --> %s",\r\ne->type_def->name->content);\r\nrender_more(out, "\n");\r\nif (!(e->flags & ELEMENT_RENDERED)) {\r\ne->flags |= ELEMENT_RENDERED;\r\n*render_list_p = e;\r\nrender_list_p = &e->render_next;\r\n}\r\nreturn;\r\n} else {\r\nentry = nr_entries;\r\nrender_depth++;\r\nrender_element(out, e->children, NULL);\r\nrender_depth--;\r\nif (e->compound == SEQUENCE_OF)\r\nrender_opcode(out, "ASN1_OP_END_SEQ_OF%s,\n", act);\r\nelse\r\nrender_opcode(out, "ASN1_OP_END_SET_OF%s,\n", act);\r\nrender_opcode(out, "_jump_target(%u),\n", entry);\r\n}\r\nbreak;\r\ncase SET:\r\nfprintf(stderr, "The ASN.1 SET type is not currently supported.\n");\r\nexit(1);\r\ncase CHOICE:\r\nfor (ec = e->children; ec; ec = ec->next)\r\nrender_element(out, ec, ec);\r\nif (!skippable)\r\nrender_opcode(out, "ASN1_OP_COND_FAIL,\n");\r\nif (e->action)\r\nrender_opcode(out, "ASN1_OP_ACT,\n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (e->action)\r\nrender_opcode(out, "_action(ACT_%s),\n", e->action->name);\r\n}
