static int __fsl_mc_device_remove_if_not_in_mc(struct device *dev, void *data)\r\n{\r\nint i;\r\nstruct dprc_child_objs *objs;\r\nstruct fsl_mc_device *mc_dev;\r\nWARN_ON(!dev);\r\nWARN_ON(!data);\r\nmc_dev = to_fsl_mc_device(dev);\r\nobjs = data;\r\nfor (i = 0; i < objs->child_count; i++) {\r\nstruct dprc_obj_desc *obj_desc = &objs->child_array[i];\r\nif (strlen(obj_desc->type) != 0 &&\r\nFSL_MC_DEVICE_MATCH(mc_dev, obj_desc))\r\nbreak;\r\n}\r\nif (i == objs->child_count)\r\nfsl_mc_device_remove(mc_dev);\r\nreturn 0;\r\n}\r\nstatic int __fsl_mc_device_remove(struct device *dev, void *data)\r\n{\r\nWARN_ON(!dev);\r\nWARN_ON(data);\r\nfsl_mc_device_remove(to_fsl_mc_device(dev));\r\nreturn 0;\r\n}\r\nstatic void dprc_remove_devices(struct fsl_mc_device *mc_bus_dev,\r\nstruct dprc_obj_desc *obj_desc_array,\r\nint num_child_objects_in_mc)\r\n{\r\nif (num_child_objects_in_mc != 0) {\r\nstruct dprc_child_objs objs;\r\nobjs.child_count = num_child_objects_in_mc;\r\nobjs.child_array = obj_desc_array;\r\ndevice_for_each_child(&mc_bus_dev->dev, &objs,\r\n__fsl_mc_device_remove_if_not_in_mc);\r\n} else {\r\ndevice_for_each_child(&mc_bus_dev->dev, NULL,\r\n__fsl_mc_device_remove);\r\n}\r\n}\r\nstatic int __fsl_mc_device_match(struct device *dev, void *data)\r\n{\r\nstruct dprc_obj_desc *obj_desc = data;\r\nstruct fsl_mc_device *mc_dev = to_fsl_mc_device(dev);\r\nreturn FSL_MC_DEVICE_MATCH(mc_dev, obj_desc);\r\n}\r\nstatic struct fsl_mc_device *fsl_mc_device_lookup(struct dprc_obj_desc\r\n*obj_desc,\r\nstruct fsl_mc_device\r\n*mc_bus_dev)\r\n{\r\nstruct device *dev;\r\ndev = device_find_child(&mc_bus_dev->dev, obj_desc,\r\n__fsl_mc_device_match);\r\nreturn dev ? to_fsl_mc_device(dev) : NULL;\r\n}\r\nstatic void check_plugged_state_change(struct fsl_mc_device *mc_dev,\r\nstruct dprc_obj_desc *obj_desc)\r\n{\r\nint error;\r\nu32 plugged_flag_at_mc =\r\nobj_desc->state & DPRC_OBJ_STATE_PLUGGED;\r\nif (plugged_flag_at_mc !=\r\n(mc_dev->obj_desc.state & DPRC_OBJ_STATE_PLUGGED)) {\r\nif (plugged_flag_at_mc) {\r\nmc_dev->obj_desc.state |= DPRC_OBJ_STATE_PLUGGED;\r\nerror = device_attach(&mc_dev->dev);\r\nif (error < 0) {\r\ndev_err(&mc_dev->dev,\r\n"device_attach() failed: %d\n",\r\nerror);\r\n}\r\n} else {\r\nmc_dev->obj_desc.state &= ~DPRC_OBJ_STATE_PLUGGED;\r\ndevice_release_driver(&mc_dev->dev);\r\n}\r\n}\r\n}\r\nstatic void dprc_add_new_devices(struct fsl_mc_device *mc_bus_dev,\r\nstruct dprc_obj_desc *obj_desc_array,\r\nint num_child_objects_in_mc)\r\n{\r\nint error;\r\nint i;\r\nfor (i = 0; i < num_child_objects_in_mc; i++) {\r\nstruct fsl_mc_device *child_dev;\r\nstruct dprc_obj_desc *obj_desc = &obj_desc_array[i];\r\nif (strlen(obj_desc->type) == 0)\r\ncontinue;\r\nchild_dev = fsl_mc_device_lookup(obj_desc, mc_bus_dev);\r\nif (child_dev) {\r\ncheck_plugged_state_change(child_dev, obj_desc);\r\nput_device(&child_dev->dev);\r\ncontinue;\r\n}\r\nerror = fsl_mc_device_add(obj_desc, NULL, &mc_bus_dev->dev,\r\n&child_dev);\r\nif (error < 0)\r\ncontinue;\r\n}\r\n}\r\nint dprc_scan_objects(struct fsl_mc_device *mc_bus_dev,\r\nunsigned int *total_irq_count)\r\n{\r\nint num_child_objects;\r\nint dprc_get_obj_failures;\r\nint error;\r\nunsigned int irq_count = mc_bus_dev->obj_desc.irq_count;\r\nstruct dprc_obj_desc *child_obj_desc_array = NULL;\r\nerror = dprc_get_obj_count(mc_bus_dev->mc_io,\r\n0,\r\nmc_bus_dev->mc_handle,\r\n&num_child_objects);\r\nif (error < 0) {\r\ndev_err(&mc_bus_dev->dev, "dprc_get_obj_count() failed: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nif (num_child_objects != 0) {\r\nint i;\r\nchild_obj_desc_array =\r\ndevm_kmalloc_array(&mc_bus_dev->dev, num_child_objects,\r\nsizeof(*child_obj_desc_array),\r\nGFP_KERNEL);\r\nif (!child_obj_desc_array)\r\nreturn -ENOMEM;\r\ndprc_get_obj_failures = 0;\r\nfor (i = 0; i < num_child_objects; i++) {\r\nstruct dprc_obj_desc *obj_desc =\r\n&child_obj_desc_array[i];\r\nerror = dprc_get_obj(mc_bus_dev->mc_io,\r\n0,\r\nmc_bus_dev->mc_handle,\r\ni, obj_desc);\r\nif (error < 0) {\r\ndev_err(&mc_bus_dev->dev,\r\n"dprc_get_obj(i=%d) failed: %d\n",\r\ni, error);\r\nobj_desc->type[0] = '\0';\r\nobj_desc->id = error;\r\ndprc_get_obj_failures++;\r\ncontinue;\r\n}\r\nif ((strcmp(obj_desc->type, "dpseci") == 0) &&\r\n(obj_desc->ver_major < 4))\r\nobj_desc->flags |=\r\nDPRC_OBJ_FLAG_NO_MEM_SHAREABILITY;\r\nirq_count += obj_desc->irq_count;\r\ndev_dbg(&mc_bus_dev->dev,\r\n"Discovered object: type %s, id %d\n",\r\nobj_desc->type, obj_desc->id);\r\n}\r\nif (dprc_get_obj_failures != 0) {\r\ndev_err(&mc_bus_dev->dev,\r\n"%d out of %d devices could not be retrieved\n",\r\ndprc_get_obj_failures, num_child_objects);\r\n}\r\n}\r\n*total_irq_count = irq_count;\r\ndprc_remove_devices(mc_bus_dev, child_obj_desc_array,\r\nnum_child_objects);\r\ndprc_add_new_devices(mc_bus_dev, child_obj_desc_array,\r\nnum_child_objects);\r\nif (child_obj_desc_array)\r\ndevm_kfree(&mc_bus_dev->dev, child_obj_desc_array);\r\nreturn 0;\r\n}\r\nint dprc_scan_container(struct fsl_mc_device *mc_bus_dev)\r\n{\r\nint error;\r\nunsigned int irq_count;\r\nstruct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_bus_dev);\r\nfsl_mc_init_all_resource_pools(mc_bus_dev);\r\nmutex_lock(&mc_bus->scan_mutex);\r\nerror = dprc_scan_objects(mc_bus_dev, &irq_count);\r\nmutex_unlock(&mc_bus->scan_mutex);\r\nif (error < 0)\r\ngoto error;\r\nif (dev_get_msi_domain(&mc_bus_dev->dev) && !mc_bus->irq_resources) {\r\nif (irq_count > FSL_MC_IRQ_POOL_MAX_TOTAL_IRQS) {\r\ndev_warn(&mc_bus_dev->dev,\r\n"IRQs needed (%u) exceed IRQs preallocated (%u)\n",\r\nirq_count, FSL_MC_IRQ_POOL_MAX_TOTAL_IRQS);\r\n}\r\nerror = fsl_mc_populate_irq_pool(\r\nmc_bus,\r\nFSL_MC_IRQ_POOL_MAX_TOTAL_IRQS);\r\nif (error < 0)\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nfsl_mc_cleanup_all_resource_pools(mc_bus_dev);\r\nreturn error;\r\n}\r\nstatic irqreturn_t dprc_irq0_handler(int irq_num, void *arg)\r\n{\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic irqreturn_t dprc_irq0_handler_thread(int irq_num, void *arg)\r\n{\r\nint error;\r\nu32 status;\r\nstruct device *dev = arg;\r\nstruct fsl_mc_device *mc_dev = to_fsl_mc_device(dev);\r\nstruct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_dev);\r\nstruct fsl_mc_io *mc_io = mc_dev->mc_io;\r\nstruct msi_desc *msi_desc = mc_dev->irqs[0]->msi_desc;\r\ndev_dbg(dev, "DPRC IRQ %d triggered on CPU %u\n",\r\nirq_num, smp_processor_id());\r\nif (WARN_ON(!(mc_dev->flags & FSL_MC_IS_DPRC)))\r\nreturn IRQ_HANDLED;\r\nmutex_lock(&mc_bus->scan_mutex);\r\nif (WARN_ON(!msi_desc || msi_desc->irq != (u32)irq_num))\r\ngoto out;\r\nstatus = 0;\r\nerror = dprc_get_irq_status(mc_io, 0, mc_dev->mc_handle, 0,\r\n&status);\r\nif (error < 0) {\r\ndev_err(dev,\r\n"dprc_get_irq_status() failed: %d\n", error);\r\ngoto out;\r\n}\r\nerror = dprc_clear_irq_status(mc_io, 0, mc_dev->mc_handle, 0,\r\nstatus);\r\nif (error < 0) {\r\ndev_err(dev,\r\n"dprc_clear_irq_status() failed: %d\n", error);\r\ngoto out;\r\n}\r\nif (status & (DPRC_IRQ_EVENT_OBJ_ADDED |\r\nDPRC_IRQ_EVENT_OBJ_REMOVED |\r\nDPRC_IRQ_EVENT_CONTAINER_DESTROYED |\r\nDPRC_IRQ_EVENT_OBJ_DESTROYED |\r\nDPRC_IRQ_EVENT_OBJ_CREATED)) {\r\nunsigned int irq_count;\r\nerror = dprc_scan_objects(mc_dev, &irq_count);\r\nif (error < 0) {\r\nif (error != -ENXIO) {\r\ndev_err(dev, "dprc_scan_objects() failed: %d\n",\r\nerror);\r\n}\r\ngoto out;\r\n}\r\nif (irq_count > FSL_MC_IRQ_POOL_MAX_TOTAL_IRQS) {\r\ndev_warn(dev,\r\n"IRQs needed (%u) exceed IRQs preallocated (%u)\n",\r\nirq_count, FSL_MC_IRQ_POOL_MAX_TOTAL_IRQS);\r\n}\r\n}\r\nout:\r\nmutex_unlock(&mc_bus->scan_mutex);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int disable_dprc_irq(struct fsl_mc_device *mc_dev)\r\n{\r\nint error;\r\nstruct fsl_mc_io *mc_io = mc_dev->mc_io;\r\nWARN_ON(mc_dev->obj_desc.irq_count != 1);\r\nerror = dprc_set_irq_enable(mc_io, 0, mc_dev->mc_handle, 0, 0);\r\nif (error < 0) {\r\ndev_err(&mc_dev->dev,\r\n"Disabling DPRC IRQ failed: dprc_set_irq_enable() failed: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = dprc_set_irq_mask(mc_io, 0, mc_dev->mc_handle, 0, 0x0);\r\nif (error < 0) {\r\ndev_err(&mc_dev->dev,\r\n"Disabling DPRC IRQ failed: dprc_set_irq_mask() failed: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = dprc_clear_irq_status(mc_io, 0, mc_dev->mc_handle, 0, ~0x0U);\r\nif (error < 0) {\r\ndev_err(&mc_dev->dev,\r\n"Disabling DPRC IRQ failed: dprc_clear_irq_status() failed: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int register_dprc_irq_handler(struct fsl_mc_device *mc_dev)\r\n{\r\nint error;\r\nstruct fsl_mc_device_irq *irq = mc_dev->irqs[0];\r\nWARN_ON(mc_dev->obj_desc.irq_count != 1);\r\nerror = devm_request_threaded_irq(&mc_dev->dev,\r\nirq->msi_desc->irq,\r\ndprc_irq0_handler,\r\ndprc_irq0_handler_thread,\r\nIRQF_NO_SUSPEND | IRQF_ONESHOT,\r\ndev_name(&mc_dev->dev),\r\n&mc_dev->dev);\r\nif (error < 0) {\r\ndev_err(&mc_dev->dev,\r\n"devm_request_threaded_irq() failed: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int enable_dprc_irq(struct fsl_mc_device *mc_dev)\r\n{\r\nint error;\r\nerror = dprc_set_irq_mask(mc_dev->mc_io, 0, mc_dev->mc_handle, 0,\r\n~0x0u);\r\nif (error < 0) {\r\ndev_err(&mc_dev->dev,\r\n"Enabling DPRC IRQ failed: dprc_set_irq_mask() failed: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = dprc_set_irq_enable(mc_dev->mc_io, 0, mc_dev->mc_handle, 0, 1);\r\nif (error < 0) {\r\ndev_err(&mc_dev->dev,\r\n"Enabling DPRC IRQ failed: dprc_set_irq_enable() failed: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dprc_setup_irq(struct fsl_mc_device *mc_dev)\r\n{\r\nint error;\r\nerror = fsl_mc_allocate_irqs(mc_dev);\r\nif (error < 0)\r\nreturn error;\r\nerror = disable_dprc_irq(mc_dev);\r\nif (error < 0)\r\ngoto error_free_irqs;\r\nerror = register_dprc_irq_handler(mc_dev);\r\nif (error < 0)\r\ngoto error_free_irqs;\r\nerror = enable_dprc_irq(mc_dev);\r\nif (error < 0)\r\ngoto error_free_irqs;\r\nreturn 0;\r\nerror_free_irqs:\r\nfsl_mc_free_irqs(mc_dev);\r\nreturn error;\r\n}\r\nstatic int dprc_probe(struct fsl_mc_device *mc_dev)\r\n{\r\nint error;\r\nsize_t region_size;\r\nstruct device *parent_dev = mc_dev->dev.parent;\r\nstruct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_dev);\r\nbool mc_io_created = false;\r\nbool msi_domain_set = false;\r\nu16 major_ver, minor_ver;\r\nif (WARN_ON(strcmp(mc_dev->obj_desc.type, "dprc") != 0))\r\nreturn -EINVAL;\r\nif (WARN_ON(dev_get_msi_domain(&mc_dev->dev)))\r\nreturn -EINVAL;\r\nif (!mc_dev->mc_io) {\r\nif (WARN_ON(!dev_is_fsl_mc(parent_dev)))\r\nreturn -EINVAL;\r\nif (WARN_ON(mc_dev->obj_desc.region_count == 0))\r\nreturn -EINVAL;\r\nregion_size = mc_dev->regions[0].end -\r\nmc_dev->regions[0].start + 1;\r\nerror = fsl_create_mc_io(&mc_dev->dev,\r\nmc_dev->regions[0].start,\r\nregion_size,\r\nNULL,\r\nFSL_MC_IO_ATOMIC_CONTEXT_PORTAL,\r\n&mc_dev->mc_io);\r\nif (error < 0)\r\nreturn error;\r\nmc_io_created = true;\r\ndev_set_msi_domain(&mc_dev->dev,\r\ndev_get_msi_domain(parent_dev));\r\nmsi_domain_set = true;\r\n} else {\r\nstruct irq_domain *mc_msi_domain;\r\nif (WARN_ON(dev_is_fsl_mc(parent_dev)))\r\nreturn -EINVAL;\r\nerror = fsl_mc_find_msi_domain(parent_dev,\r\n&mc_msi_domain);\r\nif (error < 0) {\r\ndev_warn(&mc_dev->dev,\r\n"WARNING: MC bus without interrupt support\n");\r\n} else {\r\ndev_set_msi_domain(&mc_dev->dev, mc_msi_domain);\r\nmsi_domain_set = true;\r\n}\r\n}\r\nerror = dprc_open(mc_dev->mc_io, 0, mc_dev->obj_desc.id,\r\n&mc_dev->mc_handle);\r\nif (error < 0) {\r\ndev_err(&mc_dev->dev, "dprc_open() failed: %d\n", error);\r\ngoto error_cleanup_msi_domain;\r\n}\r\nerror = dprc_get_attributes(mc_dev->mc_io, 0, mc_dev->mc_handle,\r\n&mc_bus->dprc_attr);\r\nif (error < 0) {\r\ndev_err(&mc_dev->dev, "dprc_get_attributes() failed: %d\n",\r\nerror);\r\ngoto error_cleanup_open;\r\n}\r\nerror = dprc_get_api_version(mc_dev->mc_io, 0,\r\n&major_ver,\r\n&minor_ver);\r\nif (error < 0) {\r\ndev_err(&mc_dev->dev, "dprc_get_api_version() failed: %d\n",\r\nerror);\r\ngoto error_cleanup_open;\r\n}\r\nif (major_ver < DPRC_MIN_VER_MAJOR ||\r\n(major_ver == DPRC_MIN_VER_MAJOR &&\r\nminor_ver < DPRC_MIN_VER_MINOR)) {\r\ndev_err(&mc_dev->dev,\r\n"ERROR: DPRC version %d.%d not supported\n",\r\nmajor_ver, minor_ver);\r\nerror = -ENOTSUPP;\r\ngoto error_cleanup_open;\r\n}\r\nmutex_init(&mc_bus->scan_mutex);\r\nerror = dprc_scan_container(mc_dev);\r\nif (error < 0)\r\ngoto error_cleanup_open;\r\nerror = dprc_setup_irq(mc_dev);\r\nif (error < 0)\r\ngoto error_cleanup_open;\r\ndev_info(&mc_dev->dev, "DPRC device bound to driver");\r\nreturn 0;\r\nerror_cleanup_open:\r\n(void)dprc_close(mc_dev->mc_io, 0, mc_dev->mc_handle);\r\nerror_cleanup_msi_domain:\r\nif (msi_domain_set)\r\ndev_set_msi_domain(&mc_dev->dev, NULL);\r\nif (mc_io_created) {\r\nfsl_destroy_mc_io(mc_dev->mc_io);\r\nmc_dev->mc_io = NULL;\r\n}\r\nreturn error;\r\n}\r\nstatic void dprc_teardown_irq(struct fsl_mc_device *mc_dev)\r\n{\r\nstruct fsl_mc_device_irq *irq = mc_dev->irqs[0];\r\n(void)disable_dprc_irq(mc_dev);\r\ndevm_free_irq(&mc_dev->dev, irq->msi_desc->irq, &mc_dev->dev);\r\nfsl_mc_free_irqs(mc_dev);\r\n}\r\nstatic int dprc_remove(struct fsl_mc_device *mc_dev)\r\n{\r\nint error;\r\nstruct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_dev);\r\nif (WARN_ON(strcmp(mc_dev->obj_desc.type, "dprc") != 0))\r\nreturn -EINVAL;\r\nif (WARN_ON(!mc_dev->mc_io))\r\nreturn -EINVAL;\r\nif (WARN_ON(!mc_bus->irq_resources))\r\nreturn -EINVAL;\r\nif (dev_get_msi_domain(&mc_dev->dev))\r\ndprc_teardown_irq(mc_dev);\r\ndevice_for_each_child(&mc_dev->dev, NULL, __fsl_mc_device_remove);\r\nif (dev_get_msi_domain(&mc_dev->dev)) {\r\nfsl_mc_cleanup_irq_pool(mc_bus);\r\ndev_set_msi_domain(&mc_dev->dev, NULL);\r\n}\r\nfsl_mc_cleanup_all_resource_pools(mc_dev);\r\nerror = dprc_close(mc_dev->mc_io, 0, mc_dev->mc_handle);\r\nif (error < 0)\r\ndev_err(&mc_dev->dev, "dprc_close() failed: %d\n", error);\r\nif (!fsl_mc_is_root_dprc(&mc_dev->dev)) {\r\nfsl_destroy_mc_io(mc_dev->mc_io);\r\nmc_dev->mc_io = NULL;\r\n}\r\ndev_info(&mc_dev->dev, "DPRC device unbound from driver");\r\nreturn 0;\r\n}\r\nint __init dprc_driver_init(void)\r\n{\r\nreturn fsl_mc_driver_register(&dprc_driver);\r\n}\r\nvoid dprc_driver_exit(void)\r\n{\r\nfsl_mc_driver_unregister(&dprc_driver);\r\n}
