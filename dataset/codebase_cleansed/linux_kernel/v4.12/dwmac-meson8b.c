static void meson8b_dwmac_mask_bits(struct meson8b_dwmac *dwmac, u32 reg,\r\nu32 mask, u32 value)\r\n{\r\nu32 data;\r\ndata = readl(dwmac->regs + reg);\r\ndata &= ~mask;\r\ndata |= (value & mask);\r\nwritel(data, dwmac->regs + reg);\r\n}\r\nstatic int meson8b_init_clk(struct meson8b_dwmac *dwmac)\r\n{\r\nstruct clk_init_data init;\r\nint i, ret;\r\nstruct device *dev = &dwmac->pdev->dev;\r\nchar clk_name[32];\r\nconst char *clk_div_parents[1];\r\nconst char *mux_parent_names[MUX_CLK_NUM_PARENTS];\r\nstatic struct clk_div_table clk_25m_div_table[] = {\r\n{ .val = 0, .div = 5 },\r\n{ .val = 1, .div = 10 },\r\n{ },\r\n};\r\nfor (i = 0; i < MUX_CLK_NUM_PARENTS; i++) {\r\nchar name[16];\r\nsnprintf(name, sizeof(name), "clkin%d", i);\r\ndwmac->m250_mux_parent[i] = devm_clk_get(dev, name);\r\nif (IS_ERR(dwmac->m250_mux_parent[i])) {\r\nret = PTR_ERR(dwmac->m250_mux_parent[i]);\r\nif (ret != -EPROBE_DEFER)\r\ndev_err(dev, "Missing clock %s\n", name);\r\nreturn ret;\r\n}\r\nmux_parent_names[i] =\r\n__clk_get_name(dwmac->m250_mux_parent[i]);\r\n}\r\nsnprintf(clk_name, sizeof(clk_name), "%s#m250_sel", dev_name(dev));\r\ninit.name = clk_name;\r\ninit.ops = &clk_mux_ops;\r\ninit.flags = 0;\r\ninit.parent_names = mux_parent_names;\r\ninit.num_parents = MUX_CLK_NUM_PARENTS;\r\ndwmac->m250_mux.reg = dwmac->regs + PRG_ETH0;\r\ndwmac->m250_mux.shift = PRG_ETH0_CLK_M250_SEL_SHIFT;\r\ndwmac->m250_mux.mask = PRG_ETH0_CLK_M250_SEL_MASK;\r\ndwmac->m250_mux.flags = 0;\r\ndwmac->m250_mux.table = NULL;\r\ndwmac->m250_mux.hw.init = &init;\r\ndwmac->m250_mux_clk = devm_clk_register(dev, &dwmac->m250_mux.hw);\r\nif (WARN_ON(IS_ERR(dwmac->m250_mux_clk)))\r\nreturn PTR_ERR(dwmac->m250_mux_clk);\r\nsnprintf(clk_name, sizeof(clk_name), "%s#m250_div", dev_name(dev));\r\ninit.name = devm_kstrdup(dev, clk_name, GFP_KERNEL);\r\ninit.ops = &clk_divider_ops;\r\ninit.flags = CLK_SET_RATE_PARENT;\r\nclk_div_parents[0] = __clk_get_name(dwmac->m250_mux_clk);\r\ninit.parent_names = clk_div_parents;\r\ninit.num_parents = ARRAY_SIZE(clk_div_parents);\r\ndwmac->m250_div.reg = dwmac->regs + PRG_ETH0;\r\ndwmac->m250_div.shift = PRG_ETH0_CLK_M250_DIV_SHIFT;\r\ndwmac->m250_div.width = PRG_ETH0_CLK_M250_DIV_WIDTH;\r\ndwmac->m250_div.hw.init = &init;\r\ndwmac->m250_div.flags = CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO;\r\ndwmac->m250_div_clk = devm_clk_register(dev, &dwmac->m250_div.hw);\r\nif (WARN_ON(IS_ERR(dwmac->m250_div_clk)))\r\nreturn PTR_ERR(dwmac->m250_div_clk);\r\nsnprintf(clk_name, sizeof(clk_name), "%s#m25_div", dev_name(dev));\r\ninit.name = devm_kstrdup(dev, clk_name, GFP_KERNEL);\r\ninit.ops = &clk_divider_ops;\r\ninit.flags = CLK_IS_BASIC | CLK_SET_RATE_PARENT;\r\nclk_div_parents[0] = __clk_get_name(dwmac->m250_div_clk);\r\ninit.parent_names = clk_div_parents;\r\ninit.num_parents = ARRAY_SIZE(clk_div_parents);\r\ndwmac->m25_div.reg = dwmac->regs + PRG_ETH0;\r\ndwmac->m25_div.shift = PRG_ETH0_CLK_M25_DIV_SHIFT;\r\ndwmac->m25_div.width = PRG_ETH0_CLK_M25_DIV_WIDTH;\r\ndwmac->m25_div.table = clk_25m_div_table;\r\ndwmac->m25_div.hw.init = &init;\r\ndwmac->m25_div.flags = CLK_DIVIDER_ALLOW_ZERO;\r\ndwmac->m25_div_clk = devm_clk_register(dev, &dwmac->m25_div.hw);\r\nif (WARN_ON(IS_ERR(dwmac->m25_div_clk)))\r\nreturn PTR_ERR(dwmac->m25_div_clk);\r\nreturn 0;\r\n}\r\nstatic int meson8b_init_prg_eth(struct meson8b_dwmac *dwmac)\r\n{\r\nint ret;\r\nunsigned long clk_rate;\r\nu8 tx_dly_val = 0;\r\nswitch (dwmac->phy_mode) {\r\ncase PHY_INTERFACE_MODE_RGMII:\r\ncase PHY_INTERFACE_MODE_RGMII_RXID:\r\ntx_dly_val = dwmac->tx_delay_ns >> 1;\r\ncase PHY_INTERFACE_MODE_RGMII_ID:\r\ncase PHY_INTERFACE_MODE_RGMII_TXID:\r\nclk_rate = 25 * 1000 * 1000;\r\nmeson8b_dwmac_mask_bits(dwmac, PRG_ETH0, PRG_ETH0_RGMII_MODE,\r\nPRG_ETH0_RGMII_MODE);\r\nmeson8b_dwmac_mask_bits(dwmac, PRG_ETH0,\r\nPRG_ETH0_INVERTED_RMII_CLK, 0);\r\nmeson8b_dwmac_mask_bits(dwmac, PRG_ETH0, PRG_ETH0_TXDLY_MASK,\r\ntx_dly_val << PRG_ETH0_TXDLY_SHIFT);\r\nbreak;\r\ncase PHY_INTERFACE_MODE_RMII:\r\nclk_rate = clk_get_rate(dwmac->m250_mux_clk);\r\nmeson8b_dwmac_mask_bits(dwmac, PRG_ETH0, PRG_ETH0_RGMII_MODE,\r\n0);\r\nmeson8b_dwmac_mask_bits(dwmac, PRG_ETH0,\r\nPRG_ETH0_INVERTED_RMII_CLK,\r\nPRG_ETH0_INVERTED_RMII_CLK);\r\nmeson8b_dwmac_mask_bits(dwmac, PRG_ETH0, PRG_ETH0_TXDLY_MASK,\r\n0);\r\nbreak;\r\ndefault:\r\ndev_err(&dwmac->pdev->dev, "unsupported phy-mode %s\n",\r\nphy_modes(dwmac->phy_mode));\r\nreturn -EINVAL;\r\n}\r\nret = clk_prepare_enable(dwmac->m25_div_clk);\r\nif (ret) {\r\ndev_err(&dwmac->pdev->dev, "failed to enable the PHY clock\n");\r\nreturn ret;\r\n}\r\nret = clk_set_rate(dwmac->m25_div_clk, clk_rate);\r\nif (ret) {\r\nclk_disable_unprepare(dwmac->m25_div_clk);\r\ndev_err(&dwmac->pdev->dev, "failed to set PHY clock\n");\r\nreturn ret;\r\n}\r\nmeson8b_dwmac_mask_bits(dwmac, PRG_ETH0, PRG_ETH0_TX_AND_PHY_REF_CLK,\r\nPRG_ETH0_TX_AND_PHY_REF_CLK);\r\nreturn 0;\r\n}\r\nstatic int meson8b_dwmac_probe(struct platform_device *pdev)\r\n{\r\nstruct plat_stmmacenet_data *plat_dat;\r\nstruct stmmac_resources stmmac_res;\r\nstruct resource *res;\r\nstruct meson8b_dwmac *dwmac;\r\nint ret;\r\nret = stmmac_get_platform_resources(pdev, &stmmac_res);\r\nif (ret)\r\nreturn ret;\r\nplat_dat = stmmac_probe_config_dt(pdev, &stmmac_res.mac);\r\nif (IS_ERR(plat_dat))\r\nreturn PTR_ERR(plat_dat);\r\ndwmac = devm_kzalloc(&pdev->dev, sizeof(*dwmac), GFP_KERNEL);\r\nif (!dwmac) {\r\nret = -ENOMEM;\r\ngoto err_remove_config_dt;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\ndwmac->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(dwmac->regs)) {\r\nret = PTR_ERR(dwmac->regs);\r\ngoto err_remove_config_dt;\r\n}\r\ndwmac->pdev = pdev;\r\ndwmac->phy_mode = of_get_phy_mode(pdev->dev.of_node);\r\nif (dwmac->phy_mode < 0) {\r\ndev_err(&pdev->dev, "missing phy-mode property\n");\r\nret = -EINVAL;\r\ngoto err_remove_config_dt;\r\n}\r\nif (of_property_read_u32(pdev->dev.of_node, "amlogic,tx-delay-ns",\r\n&dwmac->tx_delay_ns))\r\ndwmac->tx_delay_ns = 2;\r\nret = meson8b_init_clk(dwmac);\r\nif (ret)\r\ngoto err_remove_config_dt;\r\nret = meson8b_init_prg_eth(dwmac);\r\nif (ret)\r\ngoto err_remove_config_dt;\r\nplat_dat->bsp_priv = dwmac;\r\nret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);\r\nif (ret)\r\ngoto err_clk_disable;\r\nreturn 0;\r\nerr_clk_disable:\r\nclk_disable_unprepare(dwmac->m25_div_clk);\r\nerr_remove_config_dt:\r\nstmmac_remove_config_dt(pdev, plat_dat);\r\nreturn ret;\r\n}\r\nstatic int meson8b_dwmac_remove(struct platform_device *pdev)\r\n{\r\nstruct meson8b_dwmac *dwmac = get_stmmac_bsp_priv(&pdev->dev);\r\nclk_disable_unprepare(dwmac->m25_div_clk);\r\nreturn stmmac_pltfr_remove(pdev);\r\n}
