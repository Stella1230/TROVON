static inline int get_cvb_voltage(int speedo, int s_scale,\r\nconst struct cvb_coefficients *cvb)\r\n{\r\nint mv;\r\nmv = DIV_ROUND_CLOSEST(cvb->c2 * speedo, s_scale);\r\nmv = DIV_ROUND_CLOSEST((mv + cvb->c1) * speedo, s_scale) + cvb->c0;\r\nreturn mv;\r\n}\r\nstatic int round_cvb_voltage(int mv, int v_scale,\r\nconst struct rail_alignment *align)\r\n{\r\nint uv;\r\nint step = (align->step_uv ? : 1000) * v_scale;\r\nint offset = align->offset_uv * v_scale;\r\nuv = max(mv * 1000, offset) - offset;\r\nuv = DIV_ROUND_UP(uv, step) * align->step_uv + align->offset_uv;\r\nreturn uv / 1000;\r\n}\r\nstatic int round_voltage(int mv, const struct rail_alignment *align, int up)\r\n{\r\nif (align->step_uv) {\r\nint uv;\r\nuv = max(mv * 1000, align->offset_uv) - align->offset_uv;\r\nuv = (uv + (up ? align->step_uv - 1 : 0)) / align->step_uv;\r\nreturn (uv * align->step_uv + align->offset_uv) / 1000;\r\n}\r\nreturn mv;\r\n}\r\nstatic int build_opp_table(struct device *dev, const struct cvb_table *table,\r\nint speedo_value, unsigned long max_freq)\r\n{\r\nconst struct rail_alignment *align = &table->alignment;\r\nint i, ret, dfll_mv, min_mv, max_mv;\r\nmin_mv = round_voltage(table->min_millivolts, align, UP);\r\nmax_mv = round_voltage(table->max_millivolts, align, DOWN);\r\nfor (i = 0; i < MAX_DVFS_FREQS; i++) {\r\nconst struct cvb_table_freq_entry *entry = &table->entries[i];\r\nif (!entry->freq || (entry->freq > max_freq))\r\nbreak;\r\ndfll_mv = get_cvb_voltage(speedo_value, table->speedo_scale,\r\n&entry->coefficients);\r\ndfll_mv = round_cvb_voltage(dfll_mv, table->voltage_scale,\r\nalign);\r\ndfll_mv = clamp(dfll_mv, min_mv, max_mv);\r\nret = dev_pm_opp_add(dev, entry->freq, dfll_mv * 1000);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nconst struct cvb_table *\r\ntegra_cvb_add_opp_table(struct device *dev, const struct cvb_table *tables,\r\nsize_t count, int process_id, int speedo_id,\r\nint speedo_value, unsigned long max_freq)\r\n{\r\nsize_t i;\r\nint ret;\r\nfor (i = 0; i < count; i++) {\r\nconst struct cvb_table *table = &tables[i];\r\nif (table->speedo_id != -1 && table->speedo_id != speedo_id)\r\ncontinue;\r\nif (table->process_id != -1 && table->process_id != process_id)\r\ncontinue;\r\nret = build_opp_table(dev, table, speedo_value, max_freq);\r\nreturn ret ? ERR_PTR(ret) : table;\r\n}\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nvoid tegra_cvb_remove_opp_table(struct device *dev,\r\nconst struct cvb_table *table,\r\nunsigned long max_freq)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < MAX_DVFS_FREQS; i++) {\r\nconst struct cvb_table_freq_entry *entry = &table->entries[i];\r\nif (!entry->freq || (entry->freq > max_freq))\r\nbreak;\r\ndev_pm_opp_remove(dev, entry->freq);\r\n}\r\n}
