static int fdp1_fmt_is_rgb(const struct fdp1_fmt *fmt)\r\n{\r\nreturn fmt->fmt <= 0x1b;\r\n}\r\nstatic const struct fdp1_fmt *fdp1_find_format(u32 pixelformat)\r\n{\r\nconst struct fdp1_fmt *fmt;\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(fdp1_formats); i++) {\r\nfmt = &fdp1_formats[i];\r\nif (fmt->fourcc == pixelformat)\r\nreturn fmt;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline struct fdp1_buffer *to_fdp1_buffer(struct vb2_v4l2_buffer *vb)\r\n{\r\nreturn container_of(vb, struct fdp1_buffer, m2m_buf.vb);\r\n}\r\nstatic inline struct fdp1_ctx *fh_to_ctx(struct v4l2_fh *fh)\r\n{\r\nreturn container_of(fh, struct fdp1_ctx, fh);\r\n}\r\nstatic struct fdp1_q_data *get_q_data(struct fdp1_ctx *ctx,\r\nenum v4l2_buf_type type)\r\n{\r\nif (V4L2_TYPE_IS_OUTPUT(type))\r\nreturn &ctx->out_q;\r\nelse\r\nreturn &ctx->cap_q;\r\n}\r\nstatic struct fdp1_job *list_remove_job(struct fdp1_dev *fdp1,\r\nstruct list_head *list)\r\n{\r\nstruct fdp1_job *job;\r\nunsigned long flags;\r\nspin_lock_irqsave(&fdp1->irqlock, flags);\r\njob = list_first_entry_or_null(list, struct fdp1_job, list);\r\nif (job)\r\nlist_del(&job->list);\r\nspin_unlock_irqrestore(&fdp1->irqlock, flags);\r\nreturn job;\r\n}\r\nstatic void list_add_job(struct fdp1_dev *fdp1,\r\nstruct list_head *list,\r\nstruct fdp1_job *job)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&fdp1->irqlock, flags);\r\nlist_add_tail(&job->list, list);\r\nspin_unlock_irqrestore(&fdp1->irqlock, flags);\r\n}\r\nstatic struct fdp1_job *fdp1_job_alloc(struct fdp1_dev *fdp1)\r\n{\r\nreturn list_remove_job(fdp1, &fdp1->free_job_list);\r\n}\r\nstatic void fdp1_job_free(struct fdp1_dev *fdp1, struct fdp1_job *job)\r\n{\r\nmemset(job, 0, sizeof(struct fdp1_job));\r\nlist_add_job(fdp1, &fdp1->free_job_list, job);\r\n}\r\nstatic void queue_job(struct fdp1_dev *fdp1, struct fdp1_job *job)\r\n{\r\nlist_add_job(fdp1, &fdp1->queued_job_list, job);\r\n}\r\nstatic struct fdp1_job *get_queued_job(struct fdp1_dev *fdp1)\r\n{\r\nreturn list_remove_job(fdp1, &fdp1->queued_job_list);\r\n}\r\nstatic void queue_hw_job(struct fdp1_dev *fdp1, struct fdp1_job *job)\r\n{\r\nlist_add_job(fdp1, &fdp1->hw_job_list, job);\r\n}\r\nstatic struct fdp1_job *get_hw_queued_job(struct fdp1_dev *fdp1)\r\n{\r\nreturn list_remove_job(fdp1, &fdp1->hw_job_list);\r\n}\r\nstatic void fdp1_field_complete(struct fdp1_ctx *ctx,\r\nstruct fdp1_field_buffer *fbuf)\r\n{\r\nif (!fbuf)\r\nreturn;\r\nif (fbuf->last_field)\r\nv4l2_m2m_buf_done(fbuf->vb, VB2_BUF_STATE_DONE);\r\n}\r\nstatic void fdp1_queue_field(struct fdp1_ctx *ctx,\r\nstruct fdp1_field_buffer *fbuf)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ctx->fdp1->irqlock, flags);\r\nlist_add_tail(&fbuf->list, &ctx->fields_queue);\r\nspin_unlock_irqrestore(&ctx->fdp1->irqlock, flags);\r\nctx->buffers_queued++;\r\n}\r\nstatic struct fdp1_field_buffer *fdp1_dequeue_field(struct fdp1_ctx *ctx)\r\n{\r\nstruct fdp1_field_buffer *fbuf;\r\nunsigned long flags;\r\nctx->buffers_queued--;\r\nspin_lock_irqsave(&ctx->fdp1->irqlock, flags);\r\nfbuf = list_first_entry_or_null(&ctx->fields_queue,\r\nstruct fdp1_field_buffer, list);\r\nif (fbuf)\r\nlist_del(&fbuf->list);\r\nspin_unlock_irqrestore(&ctx->fdp1->irqlock, flags);\r\nreturn fbuf;\r\n}\r\nstatic struct fdp1_field_buffer *fdp1_peek_queued_field(struct fdp1_ctx *ctx)\r\n{\r\nstruct fdp1_field_buffer *fbuf;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ctx->fdp1->irqlock, flags);\r\nfbuf = list_first_entry_or_null(&ctx->fields_queue,\r\nstruct fdp1_field_buffer, list);\r\nspin_unlock_irqrestore(&ctx->fdp1->irqlock, flags);\r\nreturn fbuf;\r\n}\r\nstatic u32 fdp1_read(struct fdp1_dev *fdp1, unsigned int reg)\r\n{\r\nu32 value = ioread32(fdp1->regs + reg);\r\nif (debug >= 2)\r\ndprintk(fdp1, "Read 0x%08x from 0x%04x\n", value, reg);\r\nreturn value;\r\n}\r\nstatic void fdp1_write(struct fdp1_dev *fdp1, u32 val, unsigned int reg)\r\n{\r\nif (debug >= 2)\r\ndprintk(fdp1, "Write 0x%08x to 0x%04x\n", val, reg);\r\niowrite32(val, fdp1->regs + reg);\r\n}\r\nstatic void fdp1_set_ipc_dli(struct fdp1_ctx *ctx)\r\n{\r\nstruct fdp1_dev *fdp1 = ctx->fdp1;\r\nfdp1_write(fdp1, FD1_IPC_SMSK_THRESH_CONST, FD1_IPC_SMSK_THRESH);\r\nfdp1_write(fdp1, FD1_IPC_COMB_DET_CONST, FD1_IPC_COMB_DET);\r\nfdp1_write(fdp1, FD1_IPC_MOTDEC_CONST, FD1_IPC_MOTDEC);\r\nfdp1_write(fdp1, FD1_IPC_DLI_BLEND_CONST, FD1_IPC_DLI_BLEND);\r\nfdp1_write(fdp1, FD1_IPC_DLI_HGAIN_CONST, FD1_IPC_DLI_HGAIN);\r\nfdp1_write(fdp1, FD1_IPC_DLI_SPRS_CONST, FD1_IPC_DLI_SPRS);\r\nfdp1_write(fdp1, FD1_IPC_DLI_ANGLE_CONST, FD1_IPC_DLI_ANGLE);\r\nfdp1_write(fdp1, FD1_IPC_DLI_ISOPIX0_CONST, FD1_IPC_DLI_ISOPIX0);\r\nfdp1_write(fdp1, FD1_IPC_DLI_ISOPIX1_CONST, FD1_IPC_DLI_ISOPIX1);\r\n}\r\nstatic void fdp1_set_ipc_sensor(struct fdp1_ctx *ctx)\r\n{\r\nstruct fdp1_dev *fdp1 = ctx->fdp1;\r\nstruct fdp1_q_data *src_q_data = &ctx->out_q;\r\nunsigned int x0, x1;\r\nunsigned int hsize = src_q_data->format.width;\r\nunsigned int vsize = src_q_data->format.height;\r\nx0 = hsize / 3;\r\nx1 = 2 * hsize / 3;\r\nfdp1_write(fdp1, FD1_IPC_SENSOR_TH0_CONST, FD1_IPC_SENSOR_TH0);\r\nfdp1_write(fdp1, FD1_IPC_SENSOR_TH1_CONST, FD1_IPC_SENSOR_TH1);\r\nfdp1_write(fdp1, FD1_IPC_SENSOR_CTL0_CONST, FD1_IPC_SENSOR_CTL0);\r\nfdp1_write(fdp1, FD1_IPC_SENSOR_CTL1_CONST, FD1_IPC_SENSOR_CTL1);\r\nfdp1_write(fdp1, ((hsize - 1) << FD1_IPC_SENSOR_CTL2_X_SHIFT) |\r\n((vsize - 1) << FD1_IPC_SENSOR_CTL2_Y_SHIFT),\r\nFD1_IPC_SENSOR_CTL2);\r\nfdp1_write(fdp1, (x0 << FD1_IPC_SENSOR_CTL3_0_SHIFT) |\r\n(x1 << FD1_IPC_SENSOR_CTL3_1_SHIFT),\r\nFD1_IPC_SENSOR_CTL3);\r\n}\r\nstatic void fdp1_write_lut(struct fdp1_dev *fdp1, const u8 *lut,\r\nunsigned int len, unsigned int base)\r\n{\r\nunsigned int i;\r\nu8 pad;\r\nlen = min(len, 256u);\r\nfor (i = 0; i < len; i++)\r\nfdp1_write(fdp1, lut[i], base + (i*4));\r\npad = lut[i-1];\r\nfor (; i < 256; i++)\r\nfdp1_write(fdp1, pad, base + (i*4));\r\n}\r\nstatic void fdp1_set_lut(struct fdp1_dev *fdp1)\r\n{\r\nfdp1_write_lut(fdp1, fdp1_diff_adj, ARRAY_SIZE(fdp1_diff_adj),\r\nFD1_LUT_DIF_ADJ);\r\nfdp1_write_lut(fdp1, fdp1_sad_adj, ARRAY_SIZE(fdp1_sad_adj),\r\nFD1_LUT_SAD_ADJ);\r\nfdp1_write_lut(fdp1, fdp1_bld_gain, ARRAY_SIZE(fdp1_bld_gain),\r\nFD1_LUT_BLD_GAIN);\r\nfdp1_write_lut(fdp1, fdp1_dif_gain, ARRAY_SIZE(fdp1_dif_gain),\r\nFD1_LUT_DIF_GAIN);\r\nfdp1_write_lut(fdp1, fdp1_mdet, ARRAY_SIZE(fdp1_mdet),\r\nFD1_LUT_MDET);\r\n}\r\nstatic void fdp1_configure_rpf(struct fdp1_ctx *ctx,\r\nstruct fdp1_job *job)\r\n{\r\nstruct fdp1_dev *fdp1 = ctx->fdp1;\r\nu32 picture_size;\r\nu32 pstride;\r\nu32 format;\r\nu32 smsk_addr;\r\nstruct fdp1_q_data *q_data = &ctx->out_q;\r\npicture_size = (q_data->format.width << FD1_RPF_SIZE_H_SHIFT)\r\n| (q_data->vsize << FD1_RPF_SIZE_V_SHIFT);\r\npstride = q_data->stride_y << FD1_RPF_PSTRIDE_Y_SHIFT;\r\nif (q_data->format.num_planes > 1)\r\npstride |= q_data->stride_c << FD1_RPF_PSTRIDE_C_SHIFT;\r\nformat = q_data->fmt->fmt;\r\nif (q_data->fmt->swap_yc)\r\nformat |= FD1_RPF_FORMAT_RSPYCS;\r\nif (q_data->fmt->swap_uv)\r\nformat |= FD1_RPF_FORMAT_RSPUVS;\r\nif (job->active->field == V4L2_FIELD_BOTTOM) {\r\nformat |= FD1_RPF_FORMAT_CF;\r\nsmsk_addr = ctx->smsk_addr[0];\r\n} else {\r\nsmsk_addr = ctx->smsk_addr[1];\r\n}\r\nif (ctx->deint_mode)\r\nformat |= FD1_RPF_FORMAT_CIPM;\r\nfdp1_write(fdp1, format, FD1_RPF_FORMAT);\r\nfdp1_write(fdp1, q_data->fmt->swap, FD1_RPF_SWAP);\r\nfdp1_write(fdp1, picture_size, FD1_RPF_SIZE);\r\nfdp1_write(fdp1, pstride, FD1_RPF_PSTRIDE);\r\nfdp1_write(fdp1, smsk_addr, FD1_RPF_SMSK_ADDR);\r\nif (job->previous)\r\nfdp1_write(fdp1, job->previous->addrs[0], FD1_RPF0_ADDR_Y);\r\nfdp1_write(fdp1, job->active->addrs[0], FD1_RPF1_ADDR_Y);\r\nfdp1_write(fdp1, job->active->addrs[1], FD1_RPF1_ADDR_C0);\r\nfdp1_write(fdp1, job->active->addrs[2], FD1_RPF1_ADDR_C1);\r\nif (job->next)\r\nfdp1_write(fdp1, job->next->addrs[0], FD1_RPF2_ADDR_Y);\r\n}\r\nstatic void fdp1_configure_wpf(struct fdp1_ctx *ctx,\r\nstruct fdp1_job *job)\r\n{\r\nstruct fdp1_dev *fdp1 = ctx->fdp1;\r\nstruct fdp1_q_data *src_q_data = &ctx->out_q;\r\nstruct fdp1_q_data *q_data = &ctx->cap_q;\r\nu32 pstride;\r\nu32 format;\r\nu32 swap;\r\nu32 rndctl;\r\npstride = q_data->format.plane_fmt[0].bytesperline\r\n<< FD1_WPF_PSTRIDE_Y_SHIFT;\r\nif (q_data->format.num_planes > 1)\r\npstride |= q_data->format.plane_fmt[1].bytesperline\r\n<< FD1_WPF_PSTRIDE_C_SHIFT;\r\nformat = q_data->fmt->fmt;\r\nif (q_data->fmt->swap_yc)\r\nformat |= FD1_WPF_FORMAT_WSPYCS;\r\nif (q_data->fmt->swap_uv)\r\nformat |= FD1_WPF_FORMAT_WSPUVS;\r\nif (fdp1_fmt_is_rgb(q_data->fmt)) {\r\nformat |= FD1_WPF_FORMAT_CSC;\r\nif (src_q_data->format.ycbcr_enc == V4L2_YCBCR_ENC_709)\r\nformat |= FD1_WPF_FORMAT_WRTM_709_16;\r\nelse if (src_q_data->format.quantization ==\r\nV4L2_QUANTIZATION_FULL_RANGE)\r\nformat |= FD1_WPF_FORMAT_WRTM_601_0;\r\nelse\r\nformat |= FD1_WPF_FORMAT_WRTM_601_16;\r\n}\r\nformat |= ctx->alpha << FD1_WPF_FORMAT_PDV_SHIFT;\r\nrndctl = FD1_WPF_RNDCTL_CBRM;\r\nrndctl |= FD1_WPF_RNDCTL_CLMD_NOCLIP;\r\nswap = q_data->fmt->swap << FD1_WPF_SWAP_OSWAP_SHIFT;\r\nswap |= src_q_data->fmt->swap << FD1_WPF_SWAP_SSWAP_SHIFT;\r\nfdp1_write(fdp1, format, FD1_WPF_FORMAT);\r\nfdp1_write(fdp1, rndctl, FD1_WPF_RNDCTL);\r\nfdp1_write(fdp1, swap, FD1_WPF_SWAP);\r\nfdp1_write(fdp1, pstride, FD1_WPF_PSTRIDE);\r\nfdp1_write(fdp1, job->dst->addrs[0], FD1_WPF_ADDR_Y);\r\nfdp1_write(fdp1, job->dst->addrs[1], FD1_WPF_ADDR_C0);\r\nfdp1_write(fdp1, job->dst->addrs[2], FD1_WPF_ADDR_C1);\r\n}\r\nstatic void fdp1_configure_deint_mode(struct fdp1_ctx *ctx,\r\nstruct fdp1_job *job)\r\n{\r\nstruct fdp1_dev *fdp1 = ctx->fdp1;\r\nu32 opmode = FD1_CTL_OPMODE_VIMD_NOINTERRUPT;\r\nu32 ipcmode = FD1_IPC_MODE_DLI;\r\nu32 channels = FD1_CTL_CHACT_WR | FD1_CTL_CHACT_RD1;\r\nswitch (ctx->deint_mode) {\r\ndefault:\r\ncase FDP1_PROGRESSIVE:\r\ndprintk(fdp1, "Progressive Mode\n");\r\nopmode |= FD1_CTL_OPMODE_PRG;\r\nipcmode |= FD1_IPC_MODE_DIM_FIXED2D;\r\nbreak;\r\ncase FDP1_ADAPT2D3D:\r\ndprintk(fdp1, "Adapt2D3D Mode\n");\r\nif (ctx->sequence == 0 || ctx->aborting)\r\nipcmode |= FD1_IPC_MODE_DIM_FIXED2D;\r\nelse\r\nipcmode |= FD1_IPC_MODE_DIM_ADAPT2D3D;\r\nif (ctx->sequence > 1) {\r\nchannels |= FD1_CTL_CHACT_SMW;\r\nchannels |= FD1_CTL_CHACT_RD0 | FD1_CTL_CHACT_RD2;\r\n}\r\nif (ctx->sequence > 2)\r\nchannels |= FD1_CTL_CHACT_SMR;\r\nbreak;\r\ncase FDP1_FIXED3D:\r\ndprintk(fdp1, "Fixed 3D Mode\n");\r\nipcmode |= FD1_IPC_MODE_DIM_FIXED3D;\r\nif (!(ctx->sequence == 0 || ctx->aborting))\r\nchannels |= FD1_CTL_CHACT_RD0 | FD1_CTL_CHACT_RD2;\r\nbreak;\r\ncase FDP1_FIXED2D:\r\ndprintk(fdp1, "Fixed 2D Mode\n");\r\nipcmode |= FD1_IPC_MODE_DIM_FIXED2D;\r\nbreak;\r\ncase FDP1_PREVFIELD:\r\ndprintk(fdp1, "Previous Field Mode\n");\r\nipcmode |= FD1_IPC_MODE_DIM_PREVFIELD;\r\nchannels |= FD1_CTL_CHACT_RD0;\r\nbreak;\r\ncase FDP1_NEXTFIELD:\r\ndprintk(fdp1, "Next Field Mode\n");\r\nipcmode |= FD1_IPC_MODE_DIM_NEXTFIELD;\r\nchannels |= FD1_CTL_CHACT_RD2;\r\nbreak;\r\n}\r\nfdp1_write(fdp1, channels, FD1_CTL_CHACT);\r\nfdp1_write(fdp1, opmode, FD1_CTL_OPMODE);\r\nfdp1_write(fdp1, ipcmode, FD1_IPC_MODE);\r\n}\r\nstatic int fdp1_device_process(struct fdp1_ctx *ctx)\r\n{\r\nstruct fdp1_dev *fdp1 = ctx->fdp1;\r\nstruct fdp1_job *job;\r\nunsigned long flags;\r\nspin_lock_irqsave(&fdp1->device_process_lock, flags);\r\njob = get_queued_job(fdp1);\r\nif (!job) {\r\nspin_unlock_irqrestore(&fdp1->device_process_lock, flags);\r\nreturn 0;\r\n}\r\nfdp1_write(fdp1, FD1_CTL_CLKCTRL_CSTP_N, FD1_CTL_CLKCTRL);\r\nfdp1_configure_deint_mode(ctx, job);\r\nfdp1_set_ipc_dli(ctx);\r\nfdp1_set_ipc_sensor(ctx);\r\nfdp1_configure_rpf(ctx, job);\r\nfdp1_configure_wpf(ctx, job);\r\nfdp1_write(fdp1, FD1_IPC_LMEM_LINEAR, FD1_IPC_LMEM);\r\nfdp1_write(fdp1, FD1_CTL_IRQ_MASK, FD1_CTL_IRQENB);\r\nqueue_hw_job(fdp1, job);\r\nfdp1_write(fdp1, FD1_CTL_CMD_STRCMD, FD1_CTL_CMD);\r\nfdp1_write(fdp1, FD1_CTL_REGEND_REGEND, FD1_CTL_REGEND);\r\nfdp1_write(fdp1, FD1_CTL_SGCMD_SGEN, FD1_CTL_SGCMD);\r\nspin_unlock_irqrestore(&fdp1->device_process_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int fdp1_m2m_job_ready(void *priv)\r\n{\r\nstruct fdp1_ctx *ctx = priv;\r\nstruct fdp1_q_data *src_q_data = &ctx->out_q;\r\nint srcbufs = 1;\r\nint dstbufs = 1;\r\ndprintk(ctx->fdp1, "+ Src: %d : Dst: %d\n",\r\nv4l2_m2m_num_src_bufs_ready(ctx->fh.m2m_ctx),\r\nv4l2_m2m_num_dst_bufs_ready(ctx->fh.m2m_ctx));\r\nif (V4L2_FIELD_HAS_BOTH(src_q_data->format.field))\r\ndstbufs = 2;\r\nif (v4l2_m2m_num_src_bufs_ready(ctx->fh.m2m_ctx) < srcbufs\r\n|| v4l2_m2m_num_dst_bufs_ready(ctx->fh.m2m_ctx) < dstbufs) {\r\ndprintk(ctx->fdp1, "Not enough buffers available\n");\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void fdp1_m2m_job_abort(void *priv)\r\n{\r\nstruct fdp1_ctx *ctx = priv;\r\ndprintk(ctx->fdp1, "+\n");\r\nctx->aborting = 1;\r\nfdp1_write(ctx->fdp1, 0, FD1_CTL_SGCMD);\r\nfdp1_write(ctx->fdp1, FD1_CTL_SRESET_SRST, FD1_CTL_SRESET);\r\n}\r\nstatic struct fdp1_job *fdp1_prepare_job(struct fdp1_ctx *ctx)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf;\r\nstruct fdp1_buffer *fbuf;\r\nstruct fdp1_dev *fdp1 = ctx->fdp1;\r\nstruct fdp1_job *job;\r\nunsigned int buffers_required = 1;\r\ndprintk(fdp1, "+\n");\r\nif (FDP1_DEINT_MODE_USES_NEXT(ctx->deint_mode))\r\nbuffers_required = 2;\r\nif (ctx->buffers_queued < buffers_required)\r\nreturn NULL;\r\njob = fdp1_job_alloc(fdp1);\r\nif (!job) {\r\ndprintk(fdp1, "No free jobs currently available\n");\r\nreturn NULL;\r\n}\r\njob->active = fdp1_dequeue_field(ctx);\r\nif (!job->active) {\r\ndprintk(fdp1, "No input buffers currently available\n");\r\nfdp1_job_free(fdp1, job);\r\nreturn NULL;\r\n}\r\ndprintk(fdp1, "+ Buffer en-route...\n");\r\nvbuf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\r\nfbuf = to_fdp1_buffer(vbuf);\r\njob->dst = &fbuf->fields[0];\r\njob->active->vb->sequence = ctx->sequence;\r\njob->dst->vb->sequence = ctx->sequence;\r\nctx->sequence++;\r\nif (FDP1_DEINT_MODE_USES_PREV(ctx->deint_mode)) {\r\njob->previous = ctx->previous;\r\nctx->previous = job->active;\r\n}\r\nif (FDP1_DEINT_MODE_USES_NEXT(ctx->deint_mode)) {\r\njob->next = fdp1_peek_queued_field(ctx);\r\n}\r\njob->dst->vb->vb2_buf.timestamp = job->active->vb->vb2_buf.timestamp;\r\njob->dst->vb->flags = job->active->vb->flags &\r\nV4L2_BUF_FLAG_TSTAMP_SRC_MASK;\r\nctx->translen++;\r\nqueue_job(fdp1, job);\r\ndprintk(fdp1, "Job Queued translen = %d\n", ctx->translen);\r\nreturn job;\r\n}\r\nstatic void fdp1_m2m_device_run(void *priv)\r\n{\r\nstruct fdp1_ctx *ctx = priv;\r\nstruct fdp1_dev *fdp1 = ctx->fdp1;\r\nstruct vb2_v4l2_buffer *src_vb;\r\nstruct fdp1_buffer *buf;\r\nunsigned int i;\r\ndprintk(fdp1, "+\n");\r\nctx->translen = 0;\r\nsrc_vb = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\r\nbuf = to_fdp1_buffer(src_vb);\r\nfor (i = 0; i < buf->num_fields; i++) {\r\nstruct fdp1_field_buffer *fbuf = &buf->fields[i];\r\nfdp1_queue_field(ctx, fbuf);\r\ndprintk(fdp1, "Queued Buffer [%d] last_field:%d\n",\r\ni, fbuf->last_field);\r\n}\r\nwhile (fdp1_prepare_job(ctx))\r\n;\r\nif (ctx->translen == 0) {\r\ndprintk(fdp1, "No jobs were processed. M2M action complete\n");\r\nv4l2_m2m_job_finish(fdp1->m2m_dev, ctx->fh.m2m_ctx);\r\nreturn;\r\n}\r\nfdp1_device_process(ctx);\r\n}\r\nstatic void device_frame_end(struct fdp1_dev *fdp1,\r\nenum vb2_buffer_state state)\r\n{\r\nstruct fdp1_ctx *ctx;\r\nunsigned long flags;\r\nstruct fdp1_job *job = get_hw_queued_job(fdp1);\r\ndprintk(fdp1, "+\n");\r\nctx = v4l2_m2m_get_curr_priv(fdp1->m2m_dev);\r\nif (ctx == NULL) {\r\nv4l2_err(&fdp1->v4l2_dev,\r\n"Instance released before the end of transaction\n");\r\nreturn;\r\n}\r\nctx->num_processed++;\r\nif (FDP1_DEINT_MODE_USES_PREV(ctx->deint_mode))\r\nfdp1_field_complete(ctx, job->previous);\r\nelse\r\nfdp1_field_complete(ctx, job->active);\r\nspin_lock_irqsave(&fdp1->irqlock, flags);\r\nv4l2_m2m_buf_done(job->dst->vb, state);\r\njob->dst = NULL;\r\nspin_unlock_irqrestore(&fdp1->irqlock, flags);\r\nfdp1_job_free(fdp1, job);\r\ndprintk(fdp1, "curr_ctx->num_processed %d curr_ctx->translen %d\n",\r\nctx->num_processed, ctx->translen);\r\nif (ctx->num_processed == ctx->translen ||\r\nctx->aborting) {\r\ndprintk(ctx->fdp1, "Finishing transaction\n");\r\nctx->num_processed = 0;\r\nv4l2_m2m_job_finish(fdp1->m2m_dev, ctx->fh.m2m_ctx);\r\n} else {\r\nfdp1_device_process(ctx);\r\n}\r\n}\r\nstatic int fdp1_vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstrlcpy(cap->driver, DRIVER_NAME, sizeof(cap->driver));\r\nstrlcpy(cap->card, DRIVER_NAME, sizeof(cap->card));\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info),\r\n"platform:%s", DRIVER_NAME);\r\nreturn 0;\r\n}\r\nstatic int fdp1_enum_fmt(struct v4l2_fmtdesc *f, u32 type)\r\n{\r\nunsigned int i, num;\r\nnum = 0;\r\nfor (i = 0; i < ARRAY_SIZE(fdp1_formats); ++i) {\r\nif (fdp1_formats[i].types & type) {\r\nif (num == f->index)\r\nbreak;\r\n++num;\r\n}\r\n}\r\nif (i >= ARRAY_SIZE(fdp1_formats))\r\nreturn -EINVAL;\r\nf->pixelformat = fdp1_formats[i].fourcc;\r\nreturn 0;\r\n}\r\nstatic int fdp1_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nreturn fdp1_enum_fmt(f, FDP1_CAPTURE);\r\n}\r\nstatic int fdp1_enum_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nreturn fdp1_enum_fmt(f, FDP1_OUTPUT);\r\n}\r\nstatic int fdp1_g_fmt(struct file *file, void *priv, struct v4l2_format *f)\r\n{\r\nstruct fdp1_q_data *q_data;\r\nstruct fdp1_ctx *ctx = fh_to_ctx(priv);\r\nif (!v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type))\r\nreturn -EINVAL;\r\nq_data = get_q_data(ctx, f->type);\r\nf->fmt.pix_mp = q_data->format;\r\nreturn 0;\r\n}\r\nstatic void fdp1_compute_stride(struct v4l2_pix_format_mplane *pix,\r\nconst struct fdp1_fmt *fmt)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < min_t(unsigned int, fmt->num_planes, 2U); ++i) {\r\nunsigned int hsub = i > 0 ? fmt->hsub : 1;\r\nunsigned int vsub = i > 0 ? fmt->vsub : 1;\r\nunsigned int align = 128;\r\nunsigned int bpl;\r\nbpl = clamp_t(unsigned int, pix->plane_fmt[i].bytesperline,\r\npix->width / hsub * fmt->bpp[i] / 8,\r\nround_down(FDP1_MAX_STRIDE, align));\r\npix->plane_fmt[i].bytesperline = round_up(bpl, align);\r\npix->plane_fmt[i].sizeimage = pix->plane_fmt[i].bytesperline\r\n* pix->height / vsub;\r\nmemset(pix->plane_fmt[i].reserved, 0,\r\nsizeof(pix->plane_fmt[i].reserved));\r\n}\r\nif (fmt->num_planes == 3) {\r\npix->plane_fmt[2].bytesperline = pix->plane_fmt[1].bytesperline;\r\npix->plane_fmt[2].sizeimage = pix->plane_fmt[1].sizeimage;\r\nmemset(pix->plane_fmt[2].reserved, 0,\r\nsizeof(pix->plane_fmt[2].reserved));\r\n}\r\n}\r\nstatic void fdp1_try_fmt_output(struct fdp1_ctx *ctx,\r\nconst struct fdp1_fmt **fmtinfo,\r\nstruct v4l2_pix_format_mplane *pix)\r\n{\r\nconst struct fdp1_fmt *fmt;\r\nunsigned int width;\r\nunsigned int height;\r\nfmt = fdp1_find_format(pix->pixelformat);\r\nif (!fmt || !(fmt->types & FDP1_OUTPUT))\r\nfmt = fdp1_find_format(V4L2_PIX_FMT_YUYV);\r\nif (fmtinfo)\r\n*fmtinfo = fmt;\r\npix->pixelformat = fmt->fourcc;\r\npix->num_planes = fmt->num_planes;\r\nif (pix->field != V4L2_FIELD_NONE &&\r\npix->field != V4L2_FIELD_ALTERNATE &&\r\n!V4L2_FIELD_HAS_BOTH(pix->field))\r\npix->field = V4L2_FIELD_INTERLACED;\r\nif (pix->colorspace == V4L2_COLORSPACE_DEFAULT)\r\npix->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nwidth = round_down(pix->width, fmt->hsub);\r\npix->width = clamp(width, FDP1_MIN_W, FDP1_MAX_W);\r\nheight = round_down(pix->height, fmt->vsub);\r\nif (pix->field == V4L2_FIELD_ALTERNATE)\r\npix->height = clamp(height, FDP1_MIN_H / 2, FDP1_MAX_H / 2);\r\nelse\r\npix->height = clamp(height, FDP1_MIN_H, FDP1_MAX_H);\r\nfdp1_compute_stride(pix, fmt);\r\n}\r\nstatic void fdp1_try_fmt_capture(struct fdp1_ctx *ctx,\r\nconst struct fdp1_fmt **fmtinfo,\r\nstruct v4l2_pix_format_mplane *pix)\r\n{\r\nstruct fdp1_q_data *src_data = &ctx->out_q;\r\nenum v4l2_colorspace colorspace;\r\nenum v4l2_ycbcr_encoding ycbcr_enc;\r\nenum v4l2_quantization quantization;\r\nconst struct fdp1_fmt *fmt;\r\nbool allow_rgb;\r\ncolorspace = src_data->format.colorspace;\r\nycbcr_enc = src_data->format.ycbcr_enc;\r\nif (ycbcr_enc == V4L2_YCBCR_ENC_DEFAULT)\r\nycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(colorspace);\r\nquantization = src_data->format.quantization;\r\nif (quantization == V4L2_QUANTIZATION_DEFAULT)\r\nquantization = V4L2_MAP_QUANTIZATION_DEFAULT(false, colorspace,\r\nycbcr_enc);\r\nallow_rgb = ycbcr_enc == V4L2_YCBCR_ENC_601 ||\r\n(ycbcr_enc == V4L2_YCBCR_ENC_709 &&\r\nquantization == V4L2_QUANTIZATION_LIM_RANGE);\r\nfmt = fdp1_find_format(pix->pixelformat);\r\nif (!fmt || (!allow_rgb && fdp1_fmt_is_rgb(fmt)))\r\nfmt = fdp1_find_format(V4L2_PIX_FMT_YUYV);\r\nif (fmtinfo)\r\n*fmtinfo = fmt;\r\npix->pixelformat = fmt->fourcc;\r\npix->num_planes = fmt->num_planes;\r\npix->field = V4L2_FIELD_NONE;\r\npix->colorspace = src_data->format.colorspace;\r\npix->xfer_func = src_data->format.xfer_func;\r\nif (fdp1_fmt_is_rgb(fmt)) {\r\npix->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\r\npix->quantization = V4L2_QUANTIZATION_DEFAULT;\r\n} else {\r\npix->ycbcr_enc = src_data->format.ycbcr_enc;\r\npix->quantization = src_data->format.quantization;\r\n}\r\npix->width = src_data->format.width;\r\nif (src_data->format.field == V4L2_FIELD_ALTERNATE)\r\npix->height = 2 * src_data->format.height;\r\nelse\r\npix->height = src_data->format.height;\r\nfdp1_compute_stride(pix, fmt);\r\n}\r\nstatic int fdp1_try_fmt(struct file *file, void *priv, struct v4l2_format *f)\r\n{\r\nstruct fdp1_ctx *ctx = fh_to_ctx(priv);\r\nif (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\r\nfdp1_try_fmt_output(ctx, NULL, &f->fmt.pix_mp);\r\nelse\r\nfdp1_try_fmt_capture(ctx, NULL, &f->fmt.pix_mp);\r\ndprintk(ctx->fdp1, "Try %s format: %4.4s (0x%08x) %ux%u field %u\n",\r\nV4L2_TYPE_IS_OUTPUT(f->type) ? "output" : "capture",\r\n(char *)&f->fmt.pix_mp.pixelformat, f->fmt.pix_mp.pixelformat,\r\nf->fmt.pix_mp.width, f->fmt.pix_mp.height, f->fmt.pix_mp.field);\r\nreturn 0;\r\n}\r\nstatic void fdp1_set_format(struct fdp1_ctx *ctx,\r\nstruct v4l2_pix_format_mplane *pix,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct fdp1_q_data *q_data = get_q_data(ctx, type);\r\nconst struct fdp1_fmt *fmtinfo;\r\nif (type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\r\nfdp1_try_fmt_output(ctx, &fmtinfo, pix);\r\nelse\r\nfdp1_try_fmt_capture(ctx, &fmtinfo, pix);\r\nq_data->fmt = fmtinfo;\r\nq_data->format = *pix;\r\nq_data->vsize = pix->height;\r\nif (pix->field != V4L2_FIELD_NONE)\r\nq_data->vsize /= 2;\r\nq_data->stride_y = pix->plane_fmt[0].bytesperline;\r\nq_data->stride_c = pix->plane_fmt[1].bytesperline;\r\nif (pix->field == V4L2_FIELD_INTERLACED ||\r\npix->field == V4L2_FIELD_INTERLACED_TB ||\r\npix->field == V4L2_FIELD_INTERLACED_BT) {\r\nq_data->stride_y *= 2;\r\nq_data->stride_c *= 2;\r\n}\r\nif (type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nstruct fdp1_q_data *dst_data = &ctx->cap_q;\r\ndst_data->format = q_data->format;\r\nmemset(dst_data->format.plane_fmt, 0,\r\nsizeof(dst_data->format.plane_fmt));\r\ndst_data->format.field = V4L2_FIELD_NONE;\r\nif (pix->field == V4L2_FIELD_ALTERNATE)\r\ndst_data->format.height *= 2;\r\nfdp1_try_fmt_capture(ctx, &dst_data->fmt, &dst_data->format);\r\ndst_data->vsize = dst_data->format.height;\r\ndst_data->stride_y = dst_data->format.plane_fmt[0].bytesperline;\r\ndst_data->stride_c = dst_data->format.plane_fmt[1].bytesperline;\r\n}\r\n}\r\nstatic int fdp1_s_fmt(struct file *file, void *priv, struct v4l2_format *f)\r\n{\r\nstruct fdp1_ctx *ctx = fh_to_ctx(priv);\r\nstruct v4l2_m2m_ctx *m2m_ctx = ctx->fh.m2m_ctx;\r\nstruct vb2_queue *vq = v4l2_m2m_get_vq(m2m_ctx, f->type);\r\nif (vb2_is_busy(vq)) {\r\nv4l2_err(&ctx->fdp1->v4l2_dev, "%s queue busy\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nfdp1_set_format(ctx, &f->fmt.pix_mp, f->type);\r\ndprintk(ctx->fdp1, "Set %s format: %4.4s (0x%08x) %ux%u field %u\n",\r\nV4L2_TYPE_IS_OUTPUT(f->type) ? "output" : "capture",\r\n(char *)&f->fmt.pix_mp.pixelformat, f->fmt.pix_mp.pixelformat,\r\nf->fmt.pix_mp.width, f->fmt.pix_mp.height, f->fmt.pix_mp.field);\r\nreturn 0;\r\n}\r\nstatic int fdp1_g_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct fdp1_ctx *ctx =\r\ncontainer_of(ctrl->handler, struct fdp1_ctx, hdl);\r\nstruct fdp1_q_data *src_q_data = &ctx->out_q;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:\r\nif (V4L2_FIELD_HAS_BOTH(src_q_data->format.field))\r\nctrl->val = 2;\r\nelse\r\nctrl->val = 1;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int fdp1_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct fdp1_ctx *ctx =\r\ncontainer_of(ctrl->handler, struct fdp1_ctx, hdl);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_ALPHA_COMPONENT:\r\nctx->alpha = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_DEINTERLACING_MODE:\r\nctx->deint_mode = ctrl->val;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fdp1_queue_setup(struct vb2_queue *vq,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[],\r\nstruct device *alloc_ctxs[])\r\n{\r\nstruct fdp1_ctx *ctx = vb2_get_drv_priv(vq);\r\nstruct fdp1_q_data *q_data;\r\nunsigned int i;\r\nq_data = get_q_data(ctx, vq->type);\r\nif (*nplanes) {\r\nif (*nplanes > FDP1_MAX_PLANES)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\n*nplanes = q_data->format.num_planes;\r\nfor (i = 0; i < *nplanes; i++)\r\nsizes[i] = q_data->format.plane_fmt[i].sizeimage;\r\nreturn 0;\r\n}\r\nstatic void fdp1_buf_prepare_field(struct fdp1_q_data *q_data,\r\nstruct vb2_v4l2_buffer *vbuf,\r\nunsigned int field_num)\r\n{\r\nstruct fdp1_buffer *buf = to_fdp1_buffer(vbuf);\r\nstruct fdp1_field_buffer *fbuf = &buf->fields[field_num];\r\nunsigned int num_fields;\r\nunsigned int i;\r\nnum_fields = V4L2_FIELD_HAS_BOTH(vbuf->field) ? 2 : 1;\r\nfbuf->vb = vbuf;\r\nfbuf->last_field = (field_num + 1) == num_fields;\r\nfor (i = 0; i < vbuf->vb2_buf.num_planes; ++i)\r\nfbuf->addrs[i] = vb2_dma_contig_plane_dma_addr(&vbuf->vb2_buf, i);\r\nswitch (vbuf->field) {\r\ncase V4L2_FIELD_INTERLACED:\r\nfbuf->field = (q_data->format.height < 576) == field_num\r\n? V4L2_FIELD_TOP : V4L2_FIELD_BOTTOM;\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED_TB:\r\ncase V4L2_FIELD_SEQ_TB:\r\nfbuf->field = field_num ? V4L2_FIELD_BOTTOM : V4L2_FIELD_TOP;\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED_BT:\r\ncase V4L2_FIELD_SEQ_BT:\r\nfbuf->field = field_num ? V4L2_FIELD_TOP : V4L2_FIELD_BOTTOM;\r\nbreak;\r\ndefault:\r\nfbuf->field = vbuf->field;\r\nbreak;\r\n}\r\nif (!field_num)\r\nreturn;\r\nswitch (vbuf->field) {\r\ncase V4L2_FIELD_INTERLACED:\r\ncase V4L2_FIELD_INTERLACED_TB:\r\ncase V4L2_FIELD_INTERLACED_BT:\r\nfor (i = 0; i < vbuf->vb2_buf.num_planes; i++)\r\nfbuf->addrs[i] +=\r\n(i == 0 ? q_data->stride_y : q_data->stride_c);\r\nbreak;\r\ncase V4L2_FIELD_SEQ_TB:\r\ncase V4L2_FIELD_SEQ_BT:\r\nfor (i = 0; i < vbuf->vb2_buf.num_planes; i++)\r\nfbuf->addrs[i] += q_data->vsize *\r\n(i == 0 ? q_data->stride_y : q_data->stride_c);\r\nbreak;\r\n}\r\n}\r\nstatic int fdp1_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct fdp1_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct fdp1_q_data *q_data = get_q_data(ctx, vb->vb2_queue->type);\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct fdp1_buffer *buf = to_fdp1_buffer(vbuf);\r\nunsigned int i;\r\nif (V4L2_TYPE_IS_OUTPUT(vb->vb2_queue->type)) {\r\nbool field_valid = true;\r\nswitch (q_data->format.field) {\r\ncase V4L2_FIELD_NONE:\r\nif (vbuf->field != V4L2_FIELD_NONE)\r\nfield_valid = false;\r\nbreak;\r\ncase V4L2_FIELD_ALTERNATE:\r\nif (vbuf->field != V4L2_FIELD_TOP &&\r\nvbuf->field != V4L2_FIELD_BOTTOM)\r\nfield_valid = false;\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED:\r\ncase V4L2_FIELD_SEQ_TB:\r\ncase V4L2_FIELD_SEQ_BT:\r\ncase V4L2_FIELD_INTERLACED_TB:\r\ncase V4L2_FIELD_INTERLACED_BT:\r\nif (vbuf->field != q_data->format.field)\r\nfield_valid = false;\r\nbreak;\r\n}\r\nif (!field_valid) {\r\ndprintk(ctx->fdp1,\r\n"buffer field %u invalid for format field %u\n",\r\nvbuf->field, q_data->format.field);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nvbuf->field = V4L2_FIELD_NONE;\r\n}\r\nfor (i = 0; i < q_data->format.num_planes; i++) {\r\nunsigned long size = q_data->format.plane_fmt[i].sizeimage;\r\nif (vb2_plane_size(vb, i) < size) {\r\ndprintk(ctx->fdp1,\r\n"data will not fit into plane [%u/%u] (%lu < %lu)\n",\r\ni, q_data->format.num_planes,\r\nvb2_plane_size(vb, i), size);\r\nreturn -EINVAL;\r\n}\r\nvb2_set_plane_payload(vb, i, size);\r\n}\r\nbuf->num_fields = V4L2_FIELD_HAS_BOTH(vbuf->field) ? 2 : 1;\r\nfor (i = 0; i < buf->num_fields; ++i)\r\nfdp1_buf_prepare_field(q_data, vbuf, i);\r\nreturn 0;\r\n}\r\nstatic void fdp1_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct fdp1_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\r\n}\r\nstatic int fdp1_start_streaming(struct vb2_queue *q, unsigned int count)\r\n{\r\nstruct fdp1_ctx *ctx = vb2_get_drv_priv(q);\r\nstruct fdp1_q_data *q_data = get_q_data(ctx, q->type);\r\nif (V4L2_TYPE_IS_OUTPUT(q->type)) {\r\nif (q_data->format.field == V4L2_FIELD_NONE)\r\nctx->deint_mode = FDP1_PROGRESSIVE;\r\nif (ctx->deint_mode == FDP1_ADAPT2D3D) {\r\nu32 stride;\r\ndma_addr_t smsk_base;\r\nconst u32 bpp = 2;\r\nstride = round_up(q_data->format.width, 8);\r\nctx->smsk_size = bpp * stride * q_data->vsize;\r\nctx->smsk_cpu = dma_alloc_coherent(ctx->fdp1->dev,\r\nctx->smsk_size, &smsk_base, GFP_KERNEL);\r\nif (ctx->smsk_cpu == NULL) {\r\ndprintk(ctx->fdp1, "Failed to alloc smsk\n");\r\nreturn -ENOMEM;\r\n}\r\nctx->smsk_addr[0] = smsk_base;\r\nctx->smsk_addr[1] = smsk_base + (ctx->smsk_size/2);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void fdp1_stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct fdp1_ctx *ctx = vb2_get_drv_priv(q);\r\nstruct vb2_v4l2_buffer *vbuf;\r\nunsigned long flags;\r\nwhile (1) {\r\nif (V4L2_TYPE_IS_OUTPUT(q->type))\r\nvbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\r\nelse\r\nvbuf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\r\nif (vbuf == NULL)\r\nbreak;\r\nspin_lock_irqsave(&ctx->fdp1->irqlock, flags);\r\nv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\r\nspin_unlock_irqrestore(&ctx->fdp1->irqlock, flags);\r\n}\r\nif (V4L2_TYPE_IS_OUTPUT(q->type)) {\r\nstruct fdp1_field_buffer *fbuf;\r\nfbuf = fdp1_dequeue_field(ctx);\r\nwhile (fbuf != NULL) {\r\nfdp1_field_complete(ctx, fbuf);\r\nfbuf = fdp1_dequeue_field(ctx);\r\n}\r\nif (ctx->smsk_cpu) {\r\ndma_free_coherent(ctx->fdp1->dev, ctx->smsk_size,\r\nctx->smsk_cpu, ctx->smsk_addr[0]);\r\nctx->smsk_addr[0] = ctx->smsk_addr[1] = 0;\r\nctx->smsk_cpu = NULL;\r\n}\r\nWARN(!list_empty(&ctx->fields_queue),\r\n"Buffer queue not empty");\r\n} else {\r\nstruct fdp1_job *job;\r\njob = get_queued_job(ctx->fdp1);\r\nwhile (job) {\r\nif (FDP1_DEINT_MODE_USES_PREV(ctx->deint_mode))\r\nfdp1_field_complete(ctx, job->previous);\r\nelse\r\nfdp1_field_complete(ctx, job->active);\r\nv4l2_m2m_buf_done(job->dst->vb, VB2_BUF_STATE_ERROR);\r\njob->dst = NULL;\r\njob = get_queued_job(ctx->fdp1);\r\n}\r\nfdp1_field_complete(ctx, ctx->previous);\r\nWARN(!list_empty(&ctx->fdp1->queued_job_list),\r\n"Queued Job List not empty");\r\nWARN(!list_empty(&ctx->fdp1->hw_job_list),\r\n"HW Job list not empty");\r\n}\r\n}\r\nstatic int queue_init(void *priv, struct vb2_queue *src_vq,\r\nstruct vb2_queue *dst_vq)\r\n{\r\nstruct fdp1_ctx *ctx = priv;\r\nint ret;\r\nsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\r\nsrc_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\r\nsrc_vq->drv_priv = ctx;\r\nsrc_vq->buf_struct_size = sizeof(struct fdp1_buffer);\r\nsrc_vq->ops = &fdp1_qops;\r\nsrc_vq->mem_ops = &vb2_dma_contig_memops;\r\nsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\nsrc_vq->lock = &ctx->fdp1->dev_mutex;\r\nsrc_vq->dev = ctx->fdp1->dev;\r\nret = vb2_queue_init(src_vq);\r\nif (ret)\r\nreturn ret;\r\ndst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\r\ndst_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\r\ndst_vq->drv_priv = ctx;\r\ndst_vq->buf_struct_size = sizeof(struct fdp1_buffer);\r\ndst_vq->ops = &fdp1_qops;\r\ndst_vq->mem_ops = &vb2_dma_contig_memops;\r\ndst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\ndst_vq->lock = &ctx->fdp1->dev_mutex;\r\ndst_vq->dev = ctx->fdp1->dev;\r\nreturn vb2_queue_init(dst_vq);\r\n}\r\nstatic int fdp1_open(struct file *file)\r\n{\r\nstruct fdp1_dev *fdp1 = video_drvdata(file);\r\nstruct v4l2_pix_format_mplane format;\r\nstruct fdp1_ctx *ctx = NULL;\r\nstruct v4l2_ctrl *ctrl;\r\nint ret = 0;\r\nif (mutex_lock_interruptible(&fdp1->dev_mutex))\r\nreturn -ERESTARTSYS;\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx) {\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\nv4l2_fh_init(&ctx->fh, video_devdata(file));\r\nfile->private_data = &ctx->fh;\r\nctx->fdp1 = fdp1;\r\nINIT_LIST_HEAD(&ctx->fields_queue);\r\nctx->translen = 1;\r\nctx->sequence = 0;\r\nv4l2_ctrl_handler_init(&ctx->hdl, 3);\r\nv4l2_ctrl_new_std_menu_items(&ctx->hdl, &fdp1_ctrl_ops,\r\nV4L2_CID_DEINTERLACING_MODE,\r\nFDP1_NEXTFIELD, BIT(0), FDP1_FIXED3D,\r\nfdp1_ctrl_deint_menu);\r\nctrl = v4l2_ctrl_new_std(&ctx->hdl, &fdp1_ctrl_ops,\r\nV4L2_CID_MIN_BUFFERS_FOR_CAPTURE, 1, 2, 1, 1);\r\nif (ctrl)\r\nctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;\r\nv4l2_ctrl_new_std(&ctx->hdl, &fdp1_ctrl_ops,\r\nV4L2_CID_ALPHA_COMPONENT, 0, 255, 1, 255);\r\nif (ctx->hdl.error) {\r\nret = ctx->hdl.error;\r\nv4l2_ctrl_handler_free(&ctx->hdl);\r\ngoto done;\r\n}\r\nctx->fh.ctrl_handler = &ctx->hdl;\r\nv4l2_ctrl_handler_setup(&ctx->hdl);\r\nmemset(&format, 0, sizeof(format));\r\nfdp1_set_format(ctx, &format, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\r\nctx->fh.m2m_ctx = v4l2_m2m_ctx_init(fdp1->m2m_dev, ctx, &queue_init);\r\nif (IS_ERR(ctx->fh.m2m_ctx)) {\r\nret = PTR_ERR(ctx->fh.m2m_ctx);\r\nv4l2_ctrl_handler_free(&ctx->hdl);\r\nkfree(ctx);\r\ngoto done;\r\n}\r\npm_runtime_get_sync(fdp1->dev);\r\nv4l2_fh_add(&ctx->fh);\r\ndprintk(fdp1, "Created instance: %p, m2m_ctx: %p\n",\r\nctx, ctx->fh.m2m_ctx);\r\ndone:\r\nmutex_unlock(&fdp1->dev_mutex);\r\nreturn ret;\r\n}\r\nstatic int fdp1_release(struct file *file)\r\n{\r\nstruct fdp1_dev *fdp1 = video_drvdata(file);\r\nstruct fdp1_ctx *ctx = fh_to_ctx(file->private_data);\r\ndprintk(fdp1, "Releasing instance %p\n", ctx);\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nv4l2_ctrl_handler_free(&ctx->hdl);\r\nmutex_lock(&fdp1->dev_mutex);\r\nv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\r\nmutex_unlock(&fdp1->dev_mutex);\r\nkfree(ctx);\r\npm_runtime_put(fdp1->dev);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t fdp1_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct fdp1_dev *fdp1 = dev_id;\r\nu32 int_status;\r\nu32 ctl_status;\r\nu32 vint_cnt;\r\nu32 cycles;\r\nint_status = fdp1_read(fdp1, FD1_CTL_IRQSTA);\r\ncycles = fdp1_read(fdp1, FD1_CTL_VCYCLE_STAT);\r\nctl_status = fdp1_read(fdp1, FD1_CTL_STATUS);\r\nvint_cnt = (ctl_status & FD1_CTL_STATUS_VINT_CNT_MASK) >>\r\nFD1_CTL_STATUS_VINT_CNT_SHIFT;\r\nfdp1_write(fdp1, ~(int_status) & FD1_CTL_IRQ_MASK, FD1_CTL_IRQSTA);\r\nif (debug >= 2) {\r\ndprintk(fdp1, "IRQ: 0x%x %s%s%s\n", int_status,\r\nint_status & FD1_CTL_IRQ_VERE ? "[Error]" : "[!E]",\r\nint_status & FD1_CTL_IRQ_VINTE ? "[VSync]" : "[!V]",\r\nint_status & FD1_CTL_IRQ_FREE ? "[FrameEnd]" : "[!F]");\r\ndprintk(fdp1, "CycleStatus = %d (%dms)\n",\r\ncycles, cycles/(fdp1->clk_rate/1000));\r\ndprintk(fdp1,\r\n"Control Status = 0x%08x : VINT_CNT = %d %s:%s:%s:%s\n",\r\nctl_status, vint_cnt,\r\nctl_status & FD1_CTL_STATUS_SGREGSET ? "RegSet" : "",\r\nctl_status & FD1_CTL_STATUS_SGVERR ? "Vsync Error" : "",\r\nctl_status & FD1_CTL_STATUS_SGFREND ? "FrameEnd" : "",\r\nctl_status & FD1_CTL_STATUS_BSY ? "Busy" : "");\r\ndprintk(fdp1, "***********************************\n");\r\n}\r\nif (!(FD1_CTL_IRQ_MASK & int_status))\r\nreturn IRQ_NONE;\r\nif (FD1_CTL_IRQ_VERE & int_status)\r\ndevice_frame_end(fdp1, VB2_BUF_STATE_ERROR);\r\nelse if (FD1_CTL_IRQ_FREE & int_status)\r\ndevice_frame_end(fdp1, VB2_BUF_STATE_DONE);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int fdp1_probe(struct platform_device *pdev)\r\n{\r\nstruct fdp1_dev *fdp1;\r\nstruct video_device *vfd;\r\nstruct device_node *fcp_node;\r\nstruct resource *res;\r\nstruct clk *clk;\r\nunsigned int i;\r\nint ret;\r\nint hw_version;\r\nfdp1 = devm_kzalloc(&pdev->dev, sizeof(*fdp1), GFP_KERNEL);\r\nif (!fdp1)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&fdp1->free_job_list);\r\nINIT_LIST_HEAD(&fdp1->queued_job_list);\r\nINIT_LIST_HEAD(&fdp1->hw_job_list);\r\nfor (i = 0; i < ARRAY_SIZE(fdp1->jobs); i++)\r\nlist_add(&fdp1->jobs[i].list, &fdp1->free_job_list);\r\nmutex_init(&fdp1->dev_mutex);\r\nspin_lock_init(&fdp1->irqlock);\r\nspin_lock_init(&fdp1->device_process_lock);\r\nfdp1->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, fdp1);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nfdp1->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(fdp1->regs))\r\nreturn PTR_ERR(fdp1->regs);\r\nfdp1->irq = ret = platform_get_irq(pdev, 0);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "cannot find IRQ\n");\r\nreturn ret;\r\n}\r\nret = devm_request_irq(&pdev->dev, fdp1->irq, fdp1_irq_handler, 0,\r\ndev_name(&pdev->dev), fdp1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "cannot claim IRQ %d\n", fdp1->irq);\r\nreturn ret;\r\n}\r\nfcp_node = of_parse_phandle(pdev->dev.of_node, "renesas,fcp", 0);\r\nif (fcp_node) {\r\nfdp1->fcp = rcar_fcp_get(fcp_node);\r\nof_node_put(fcp_node);\r\nif (IS_ERR(fdp1->fcp)) {\r\ndev_err(&pdev->dev, "FCP not found (%ld)\n",\r\nPTR_ERR(fdp1->fcp));\r\nreturn PTR_ERR(fdp1->fcp);\r\n}\r\n}\r\nclk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nfdp1->clk_rate = clk_get_rate(clk);\r\nclk_put(clk);\r\nret = v4l2_device_register(&pdev->dev, &fdp1->v4l2_dev);\r\nif (ret) {\r\nv4l2_err(&fdp1->v4l2_dev, "Failed to register video device\n");\r\nreturn ret;\r\n}\r\nfdp1->m2m_dev = v4l2_m2m_init(&m2m_ops);\r\nif (IS_ERR(fdp1->m2m_dev)) {\r\nv4l2_err(&fdp1->v4l2_dev, "Failed to init mem2mem device\n");\r\nret = PTR_ERR(fdp1->m2m_dev);\r\ngoto unreg_dev;\r\n}\r\nfdp1->vfd = fdp1_videodev;\r\nvfd = &fdp1->vfd;\r\nvfd->lock = &fdp1->dev_mutex;\r\nvfd->v4l2_dev = &fdp1->v4l2_dev;\r\nvideo_set_drvdata(vfd, fdp1);\r\nstrlcpy(vfd->name, fdp1_videodev.name, sizeof(vfd->name));\r\nret = video_register_device(vfd, VFL_TYPE_GRABBER, 0);\r\nif (ret) {\r\nv4l2_err(&fdp1->v4l2_dev, "Failed to register video device\n");\r\ngoto release_m2m;\r\n}\r\nv4l2_info(&fdp1->v4l2_dev,\r\n"Device registered as /dev/video%d\n", vfd->num);\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_get_sync(fdp1->dev);\r\nhw_version = fdp1_read(fdp1, FD1_IP_INTDATA);\r\nswitch (hw_version) {\r\ncase FD1_IP_H3:\r\ndprintk(fdp1, "FDP1 Version R-Car H3\n");\r\nbreak;\r\ncase FD1_IP_M3W:\r\ndprintk(fdp1, "FDP1 Version R-Car M3-W\n");\r\nbreak;\r\ndefault:\r\ndev_err(fdp1->dev, "FDP1 Unidentifiable (0x%08x)\n",\r\nhw_version);\r\n}\r\npm_runtime_put(fdp1->dev);\r\nreturn 0;\r\nrelease_m2m:\r\nv4l2_m2m_release(fdp1->m2m_dev);\r\nunreg_dev:\r\nv4l2_device_unregister(&fdp1->v4l2_dev);\r\nreturn ret;\r\n}\r\nstatic int fdp1_remove(struct platform_device *pdev)\r\n{\r\nstruct fdp1_dev *fdp1 = platform_get_drvdata(pdev);\r\nv4l2_m2m_release(fdp1->m2m_dev);\r\nvideo_unregister_device(&fdp1->vfd);\r\nv4l2_device_unregister(&fdp1->v4l2_dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused fdp1_pm_runtime_suspend(struct device *dev)\r\n{\r\nstruct fdp1_dev *fdp1 = dev_get_drvdata(dev);\r\nrcar_fcp_disable(fdp1->fcp);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused fdp1_pm_runtime_resume(struct device *dev)\r\n{\r\nstruct fdp1_dev *fdp1 = dev_get_drvdata(dev);\r\nfdp1_set_lut(fdp1);\r\nreturn rcar_fcp_enable(fdp1->fcp);\r\n}
