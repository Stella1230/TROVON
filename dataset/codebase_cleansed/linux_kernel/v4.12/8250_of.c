static void tegra_serial_handle_break(struct uart_port *p)\r\n{\r\nunsigned int status, tmout = 10000;\r\ndo {\r\nstatus = p->serial_in(p, UART_LSR);\r\nif (status & (UART_LSR_FIFOE | UART_LSR_BRK_ERROR_BITS))\r\nstatus = p->serial_in(p, UART_RX);\r\nelse\r\nbreak;\r\nif (--tmout == 0)\r\nbreak;\r\nudelay(1);\r\n} while (1);\r\n}\r\nstatic inline void tegra_serial_handle_break(struct uart_port *port)\r\n{\r\n}\r\nstatic int of_platform_serial_setup(struct platform_device *ofdev,\r\nint type, struct uart_port *port,\r\nstruct of_serial_info *info)\r\n{\r\nstruct resource resource;\r\nstruct device_node *np = ofdev->dev.of_node;\r\nu32 clk, spd, prop;\r\nint ret;\r\nmemset(port, 0, sizeof *port);\r\nif (of_property_read_u32(np, "clock-frequency", &clk)) {\r\ninfo->clk = devm_clk_get(&ofdev->dev, NULL);\r\nif (IS_ERR(info->clk)) {\r\ndev_warn(&ofdev->dev,\r\n"clk or clock-frequency not defined\n");\r\nreturn PTR_ERR(info->clk);\r\n}\r\nret = clk_prepare_enable(info->clk);\r\nif (ret < 0)\r\nreturn ret;\r\nclk = clk_get_rate(info->clk);\r\n}\r\nif (of_property_read_u32(np, "current-speed", &spd) == 0)\r\nport->custom_divisor = clk / (16 * spd);\r\nret = of_address_to_resource(np, 0, &resource);\r\nif (ret) {\r\ndev_warn(&ofdev->dev, "invalid address\n");\r\ngoto out;\r\n}\r\nspin_lock_init(&port->lock);\r\nport->mapbase = resource.start;\r\nport->mapsize = resource_size(&resource);\r\nif (of_property_read_u32(np, "reg-offset", &prop) == 0)\r\nport->mapbase += prop;\r\nif (of_property_read_u32(np, "reg-shift", &prop) == 0)\r\nport->regshift = prop;\r\nif (of_property_read_u32(np, "fifo-size", &prop) == 0)\r\nport->fifosize = prop;\r\nret = of_alias_get_id(np, "serial");\r\nif (ret >= 0)\r\nport->line = ret;\r\nport->irq = irq_of_parse_and_map(np, 0);\r\nport->iotype = UPIO_MEM;\r\nif (of_property_read_u32(np, "reg-io-width", &prop) == 0) {\r\nswitch (prop) {\r\ncase 1:\r\nport->iotype = UPIO_MEM;\r\nbreak;\r\ncase 2:\r\nport->iotype = UPIO_MEM16;\r\nbreak;\r\ncase 4:\r\nport->iotype = of_device_is_big_endian(np) ?\r\nUPIO_MEM32BE : UPIO_MEM32;\r\nbreak;\r\ndefault:\r\ndev_warn(&ofdev->dev, "unsupported reg-io-width (%d)\n",\r\nprop);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nport->type = type;\r\nport->uartclk = clk;\r\nport->flags = UPF_SHARE_IRQ | UPF_BOOT_AUTOCONF | UPF_IOREMAP\r\n| UPF_FIXED_PORT | UPF_FIXED_TYPE;\r\nif (of_find_property(np, "no-loopback-test", NULL))\r\nport->flags |= UPF_SKIP_TEST;\r\nport->dev = &ofdev->dev;\r\nswitch (type) {\r\ncase PORT_TEGRA:\r\nport->handle_break = tegra_serial_handle_break;\r\nbreak;\r\ncase PORT_RT2880:\r\nport->iotype = UPIO_AU;\r\nbreak;\r\n}\r\nif (IS_ENABLED(CONFIG_SERIAL_8250_FSL) &&\r\n(of_device_is_compatible(np, "fsl,ns16550") ||\r\nof_device_is_compatible(np, "fsl,16550-FIFO64")))\r\nport->handle_irq = fsl8250_handle_irq;\r\nreturn 0;\r\nout:\r\nif (info->clk)\r\nclk_disable_unprepare(info->clk);\r\nreturn ret;\r\n}\r\nstatic int of_platform_serial_probe(struct platform_device *ofdev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct of_serial_info *info;\r\nstruct uart_8250_port port8250;\r\nu32 tx_threshold;\r\nint port_type;\r\nint ret;\r\nmatch = of_match_device(of_platform_serial_table, &ofdev->dev);\r\nif (!match)\r\nreturn -EINVAL;\r\nif (of_find_property(ofdev->dev.of_node, "used-by-rtas", NULL))\r\nreturn -EBUSY;\r\ninfo = kzalloc(sizeof(*info), GFP_KERNEL);\r\nif (info == NULL)\r\nreturn -ENOMEM;\r\nport_type = (unsigned long)match->data;\r\nmemset(&port8250, 0, sizeof(port8250));\r\nret = of_platform_serial_setup(ofdev, port_type, &port8250.port, info);\r\nif (ret)\r\ngoto out;\r\nif (port8250.port.fifosize)\r\nport8250.capabilities = UART_CAP_FIFO;\r\nif ((of_property_read_u32(ofdev->dev.of_node, "tx-threshold",\r\n&tx_threshold) == 0) &&\r\n(tx_threshold < port8250.port.fifosize))\r\nport8250.tx_loadsz = port8250.port.fifosize - tx_threshold;\r\nif (of_property_read_bool(ofdev->dev.of_node, "auto-flow-control"))\r\nport8250.capabilities |= UART_CAP_AFE;\r\nret = serial8250_register_8250_port(&port8250);\r\nif (ret < 0)\r\ngoto out;\r\ninfo->type = port_type;\r\ninfo->line = ret;\r\nplatform_set_drvdata(ofdev, info);\r\nreturn 0;\r\nout:\r\nkfree(info);\r\nirq_dispose_mapping(port8250.port.irq);\r\nreturn ret;\r\n}\r\nstatic int of_platform_serial_remove(struct platform_device *ofdev)\r\n{\r\nstruct of_serial_info *info = platform_get_drvdata(ofdev);\r\nserial8250_unregister_port(info->line);\r\nif (info->clk)\r\nclk_disable_unprepare(info->clk);\r\nkfree(info);\r\nreturn 0;\r\n}\r\nstatic int of_serial_suspend(struct device *dev)\r\n{\r\nstruct of_serial_info *info = dev_get_drvdata(dev);\r\nstruct uart_8250_port *port8250 = serial8250_get_port(info->line);\r\nstruct uart_port *port = &port8250->port;\r\nserial8250_suspend_port(info->line);\r\nif (info->clk && (!uart_console(port) || console_suspend_enabled))\r\nclk_disable_unprepare(info->clk);\r\nreturn 0;\r\n}\r\nstatic int of_serial_resume(struct device *dev)\r\n{\r\nstruct of_serial_info *info = dev_get_drvdata(dev);\r\nstruct uart_8250_port *port8250 = serial8250_get_port(info->line);\r\nstruct uart_port *port = &port8250->port;\r\nif (info->clk && (!uart_console(port) || console_suspend_enabled))\r\nclk_prepare_enable(info->clk);\r\nserial8250_resume_port(info->line);\r\nreturn 0;\r\n}
