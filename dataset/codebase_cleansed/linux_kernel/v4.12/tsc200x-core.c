static void tsc200x_update_pen_state(struct tsc200x *ts,\r\nint x, int y, int pressure)\r\n{\r\nif (pressure) {\r\ninput_report_abs(ts->idev, ABS_X, x);\r\ninput_report_abs(ts->idev, ABS_Y, y);\r\ninput_report_abs(ts->idev, ABS_PRESSURE, pressure);\r\nif (!ts->pen_down) {\r\ninput_report_key(ts->idev, BTN_TOUCH, !!pressure);\r\nts->pen_down = true;\r\n}\r\n} else {\r\ninput_report_abs(ts->idev, ABS_PRESSURE, 0);\r\nif (ts->pen_down) {\r\ninput_report_key(ts->idev, BTN_TOUCH, 0);\r\nts->pen_down = false;\r\n}\r\n}\r\ninput_sync(ts->idev);\r\ndev_dbg(ts->dev, "point(%4d,%4d), pressure (%4d)\n", x, y,\r\npressure);\r\n}\r\nstatic irqreturn_t tsc200x_irq_thread(int irq, void *_ts)\r\n{\r\nstruct tsc200x *ts = _ts;\r\nunsigned long flags;\r\nunsigned int pressure;\r\nstruct tsc200x_data tsdata;\r\nint error;\r\nerror = regmap_bulk_read(ts->regmap, TSC200X_REG_X, &tsdata,\r\nTSC200X_DATA_REGS);\r\nif (unlikely(error))\r\ngoto out;\r\nif (unlikely(tsdata.x > MAX_12BIT || tsdata.y > MAX_12BIT))\r\ngoto out;\r\nif (unlikely(tsdata.z1 == 0 || tsdata.z2 > MAX_12BIT))\r\ngoto out;\r\nif (unlikely(tsdata.z1 >= tsdata.z2))\r\ngoto out;\r\nif (!ts->pen_down &&\r\nts->in_x == tsdata.x && ts->in_y == tsdata.y &&\r\nts->in_z1 == tsdata.z1 && ts->in_z2 == tsdata.z2) {\r\ngoto out;\r\n}\r\nts->in_x = tsdata.x;\r\nts->in_y = tsdata.y;\r\nts->in_z1 = tsdata.z1;\r\nts->in_z2 = tsdata.z2;\r\npressure = tsdata.x * (tsdata.z2 - tsdata.z1) / tsdata.z1;\r\npressure = pressure * ts->x_plate_ohm / 4096;\r\nif (unlikely(pressure > MAX_12BIT))\r\ngoto out;\r\nspin_lock_irqsave(&ts->lock, flags);\r\ntsc200x_update_pen_state(ts, tsdata.x, tsdata.y, pressure);\r\nmod_timer(&ts->penup_timer,\r\njiffies + msecs_to_jiffies(TSC200X_PENUP_TIME_MS));\r\nspin_unlock_irqrestore(&ts->lock, flags);\r\nts->last_valid_interrupt = jiffies;\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void tsc200x_penup_timer(unsigned long data)\r\n{\r\nstruct tsc200x *ts = (struct tsc200x *)data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ts->lock, flags);\r\ntsc200x_update_pen_state(ts, 0, 0, 0);\r\nspin_unlock_irqrestore(&ts->lock, flags);\r\n}\r\nstatic void tsc200x_start_scan(struct tsc200x *ts)\r\n{\r\nregmap_write(ts->regmap, TSC200X_REG_CFR0, TSC200X_CFR0_INITVALUE);\r\nregmap_write(ts->regmap, TSC200X_REG_CFR1, TSC200X_CFR1_INITVALUE);\r\nregmap_write(ts->regmap, TSC200X_REG_CFR2, TSC200X_CFR2_INITVALUE);\r\nts->tsc200x_cmd(ts->dev, TSC200X_CMD_NORMAL);\r\n}\r\nstatic void tsc200x_stop_scan(struct tsc200x *ts)\r\n{\r\nts->tsc200x_cmd(ts->dev, TSC200X_CMD_STOP);\r\n}\r\nstatic void tsc200x_reset(struct tsc200x *ts)\r\n{\r\nif (ts->reset_gpio) {\r\ngpiod_set_value_cansleep(ts->reset_gpio, 1);\r\nusleep_range(100, 500);\r\ngpiod_set_value_cansleep(ts->reset_gpio, 0);\r\n}\r\n}\r\nstatic void __tsc200x_disable(struct tsc200x *ts)\r\n{\r\ntsc200x_stop_scan(ts);\r\ndisable_irq(ts->irq);\r\ndel_timer_sync(&ts->penup_timer);\r\ncancel_delayed_work_sync(&ts->esd_work);\r\nenable_irq(ts->irq);\r\n}\r\nstatic void __tsc200x_enable(struct tsc200x *ts)\r\n{\r\ntsc200x_start_scan(ts);\r\nif (ts->esd_timeout && ts->reset_gpio) {\r\nts->last_valid_interrupt = jiffies;\r\nschedule_delayed_work(&ts->esd_work,\r\nround_jiffies_relative(\r\nmsecs_to_jiffies(ts->esd_timeout)));\r\n}\r\n}\r\nstatic ssize_t tsc200x_selftest_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct tsc200x *ts = dev_get_drvdata(dev);\r\nunsigned int temp_high;\r\nunsigned int temp_high_orig;\r\nunsigned int temp_high_test;\r\nbool success = true;\r\nint error;\r\nmutex_lock(&ts->mutex);\r\n__tsc200x_disable(ts);\r\nerror = regmap_read(ts->regmap, TSC200X_REG_TEMP_HIGH, &temp_high_orig);\r\nif (error) {\r\ndev_warn(dev, "selftest failed: read error %d\n", error);\r\nsuccess = false;\r\ngoto out;\r\n}\r\ntemp_high_test = (temp_high_orig - 1) & MAX_12BIT;\r\nerror = regmap_write(ts->regmap, TSC200X_REG_TEMP_HIGH, temp_high_test);\r\nif (error) {\r\ndev_warn(dev, "selftest failed: write error %d\n", error);\r\nsuccess = false;\r\ngoto out;\r\n}\r\nerror = regmap_read(ts->regmap, TSC200X_REG_TEMP_HIGH, &temp_high);\r\nif (error) {\r\ndev_warn(dev, "selftest failed: read error %d after write\n",\r\nerror);\r\nsuccess = false;\r\ngoto out;\r\n}\r\nif (temp_high != temp_high_test) {\r\ndev_warn(dev, "selftest failed: %d != %d\n",\r\ntemp_high, temp_high_test);\r\nsuccess = false;\r\n}\r\ntsc200x_reset(ts);\r\nif (!success)\r\ngoto out;\r\nerror = regmap_read(ts->regmap, TSC200X_REG_TEMP_HIGH, &temp_high);\r\nif (error) {\r\ndev_warn(dev, "selftest failed: read error %d after reset\n",\r\nerror);\r\nsuccess = false;\r\ngoto out;\r\n}\r\nif (temp_high != temp_high_orig) {\r\ndev_warn(dev, "selftest failed after reset: %d != %d\n",\r\ntemp_high, temp_high_orig);\r\nsuccess = false;\r\n}\r\nout:\r\n__tsc200x_enable(ts);\r\nmutex_unlock(&ts->mutex);\r\nreturn sprintf(buf, "%d\n", success);\r\n}\r\nstatic umode_t tsc200x_attr_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int n)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct tsc200x *ts = dev_get_drvdata(dev);\r\numode_t mode = attr->mode;\r\nif (attr == &dev_attr_selftest.attr) {\r\nif (!ts->reset_gpio)\r\nmode = 0;\r\n}\r\nreturn mode;\r\n}\r\nstatic void tsc200x_esd_work(struct work_struct *work)\r\n{\r\nstruct tsc200x *ts = container_of(work, struct tsc200x, esd_work.work);\r\nint error;\r\nunsigned int r;\r\nif (!mutex_trylock(&ts->mutex)) {\r\ngoto reschedule;\r\n}\r\nif (time_is_after_jiffies(ts->last_valid_interrupt +\r\nmsecs_to_jiffies(ts->esd_timeout)))\r\ngoto out;\r\nerror = regmap_read(ts->regmap, TSC200X_REG_CFR0, &r);\r\nif (!error &&\r\n!((r ^ TSC200X_CFR0_INITVALUE) & TSC200X_CFR0_RW_MASK)) {\r\ngoto out;\r\n}\r\ndev_info(ts->dev, "TSC200X not responding - resetting\n");\r\ndisable_irq(ts->irq);\r\ndel_timer_sync(&ts->penup_timer);\r\ntsc200x_update_pen_state(ts, 0, 0, 0);\r\ntsc200x_reset(ts);\r\nenable_irq(ts->irq);\r\ntsc200x_start_scan(ts);\r\nout:\r\nmutex_unlock(&ts->mutex);\r\nreschedule:\r\nschedule_delayed_work(&ts->esd_work,\r\nround_jiffies_relative(\r\nmsecs_to_jiffies(ts->esd_timeout)));\r\n}\r\nstatic int tsc200x_open(struct input_dev *input)\r\n{\r\nstruct tsc200x *ts = input_get_drvdata(input);\r\nmutex_lock(&ts->mutex);\r\nif (!ts->suspended)\r\n__tsc200x_enable(ts);\r\nts->opened = true;\r\nmutex_unlock(&ts->mutex);\r\nreturn 0;\r\n}\r\nstatic void tsc200x_close(struct input_dev *input)\r\n{\r\nstruct tsc200x *ts = input_get_drvdata(input);\r\nmutex_lock(&ts->mutex);\r\nif (!ts->suspended)\r\n__tsc200x_disable(ts);\r\nts->opened = false;\r\nmutex_unlock(&ts->mutex);\r\n}\r\nint tsc200x_probe(struct device *dev, int irq, const struct input_id *tsc_id,\r\nstruct regmap *regmap,\r\nint (*tsc200x_cmd)(struct device *dev, u8 cmd))\r\n{\r\nstruct tsc200x *ts;\r\nstruct input_dev *input_dev;\r\nu32 x_plate_ohm;\r\nu32 esd_timeout;\r\nint error;\r\nif (irq <= 0) {\r\ndev_err(dev, "no irq\n");\r\nreturn -ENODEV;\r\n}\r\nif (IS_ERR(regmap))\r\nreturn PTR_ERR(regmap);\r\nif (!tsc200x_cmd) {\r\ndev_err(dev, "no cmd function\n");\r\nreturn -ENODEV;\r\n}\r\nts = devm_kzalloc(dev, sizeof(*ts), GFP_KERNEL);\r\nif (!ts)\r\nreturn -ENOMEM;\r\ninput_dev = devm_input_allocate_device(dev);\r\nif (!input_dev)\r\nreturn -ENOMEM;\r\nts->irq = irq;\r\nts->dev = dev;\r\nts->idev = input_dev;\r\nts->regmap = regmap;\r\nts->tsc200x_cmd = tsc200x_cmd;\r\nerror = device_property_read_u32(dev, "ti,x-plate-ohms", &x_plate_ohm);\r\nts->x_plate_ohm = error ? TSC200X_DEF_RESISTOR : x_plate_ohm;\r\nerror = device_property_read_u32(dev, "ti,esd-recovery-timeout-ms",\r\n&esd_timeout);\r\nts->esd_timeout = error ? 0 : esd_timeout;\r\nts->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);\r\nif (IS_ERR(ts->reset_gpio)) {\r\nerror = PTR_ERR(ts->reset_gpio);\r\ndev_err(dev, "error acquiring reset gpio: %d\n", error);\r\nreturn error;\r\n}\r\nts->vio = devm_regulator_get(dev, "vio");\r\nif (IS_ERR(ts->vio)) {\r\nerror = PTR_ERR(ts->vio);\r\ndev_err(dev, "error acquiring vio regulator: %d", error);\r\nreturn error;\r\n}\r\nmutex_init(&ts->mutex);\r\nspin_lock_init(&ts->lock);\r\nsetup_timer(&ts->penup_timer, tsc200x_penup_timer, (unsigned long)ts);\r\nINIT_DELAYED_WORK(&ts->esd_work, tsc200x_esd_work);\r\nsnprintf(ts->phys, sizeof(ts->phys),\r\n"%s/input-ts", dev_name(dev));\r\nif (tsc_id->product == 2004) {\r\ninput_dev->name = "TSC200X touchscreen";\r\n} else {\r\ninput_dev->name = devm_kasprintf(dev, GFP_KERNEL,\r\n"TSC%04d touchscreen",\r\ntsc_id->product);\r\nif (!input_dev->name)\r\nreturn -ENOMEM;\r\n}\r\ninput_dev->phys = ts->phys;\r\ninput_dev->id = *tsc_id;\r\ninput_dev->open = tsc200x_open;\r\ninput_dev->close = tsc200x_close;\r\ninput_set_drvdata(input_dev, ts);\r\ninput_set_capability(input_dev, EV_KEY, BTN_TOUCH);\r\ninput_set_abs_params(input_dev, ABS_X,\r\n0, MAX_12BIT, TSC200X_DEF_X_FUZZ, 0);\r\ninput_set_abs_params(input_dev, ABS_Y,\r\n0, MAX_12BIT, TSC200X_DEF_Y_FUZZ, 0);\r\ninput_set_abs_params(input_dev, ABS_PRESSURE,\r\n0, MAX_12BIT, TSC200X_DEF_P_FUZZ, 0);\r\ntouchscreen_parse_properties(input_dev, false, NULL);\r\ntsc200x_stop_scan(ts);\r\nerror = devm_request_threaded_irq(dev, irq, NULL,\r\ntsc200x_irq_thread,\r\nIRQF_TRIGGER_RISING | IRQF_ONESHOT,\r\n"tsc200x", ts);\r\nif (error) {\r\ndev_err(dev, "Failed to request irq, err: %d\n", error);\r\nreturn error;\r\n}\r\nerror = regulator_enable(ts->vio);\r\nif (error)\r\nreturn error;\r\ndev_set_drvdata(dev, ts);\r\nerror = sysfs_create_group(&dev->kobj, &tsc200x_attr_group);\r\nif (error) {\r\ndev_err(dev,\r\n"Failed to create sysfs attributes, err: %d\n", error);\r\ngoto disable_regulator;\r\n}\r\nerror = input_register_device(ts->idev);\r\nif (error) {\r\ndev_err(dev,\r\n"Failed to register input device, err: %d\n", error);\r\ngoto err_remove_sysfs;\r\n}\r\nirq_set_irq_wake(irq, 1);\r\nreturn 0;\r\nerr_remove_sysfs:\r\nsysfs_remove_group(&dev->kobj, &tsc200x_attr_group);\r\ndisable_regulator:\r\nregulator_disable(ts->vio);\r\nreturn error;\r\n}\r\nint tsc200x_remove(struct device *dev)\r\n{\r\nstruct tsc200x *ts = dev_get_drvdata(dev);\r\nsysfs_remove_group(&dev->kobj, &tsc200x_attr_group);\r\nregulator_disable(ts->vio);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused tsc200x_suspend(struct device *dev)\r\n{\r\nstruct tsc200x *ts = dev_get_drvdata(dev);\r\nmutex_lock(&ts->mutex);\r\nif (!ts->suspended && ts->opened)\r\n__tsc200x_disable(ts);\r\nts->suspended = true;\r\nmutex_unlock(&ts->mutex);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused tsc200x_resume(struct device *dev)\r\n{\r\nstruct tsc200x *ts = dev_get_drvdata(dev);\r\nmutex_lock(&ts->mutex);\r\nif (ts->suspended && ts->opened)\r\n__tsc200x_enable(ts);\r\nts->suspended = false;\r\nmutex_unlock(&ts->mutex);\r\nreturn 0;\r\n}
