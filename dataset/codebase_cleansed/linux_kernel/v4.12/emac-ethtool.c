static u32 emac_get_msglevel(struct net_device *netdev)\r\n{\r\nstruct emac_adapter *adpt = netdev_priv(netdev);\r\nreturn adpt->msg_enable;\r\n}\r\nstatic void emac_set_msglevel(struct net_device *netdev, u32 data)\r\n{\r\nstruct emac_adapter *adpt = netdev_priv(netdev);\r\nadpt->msg_enable = data;\r\n}\r\nstatic int emac_get_sset_count(struct net_device *netdev, int sset)\r\n{\r\nswitch (sset) {\r\ncase ETH_SS_STATS:\r\nreturn EMAC_STATS_LEN;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void emac_get_strings(struct net_device *netdev, u32 stringset, u8 *data)\r\n{\r\nunsigned int i;\r\nswitch (stringset) {\r\ncase ETH_SS_STATS:\r\nfor (i = 0; i < EMAC_STATS_LEN; i++) {\r\nstrlcpy(data, emac_ethtool_stat_strings[i],\r\nETH_GSTRING_LEN);\r\ndata += ETH_GSTRING_LEN;\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void emac_get_ethtool_stats(struct net_device *netdev,\r\nstruct ethtool_stats *stats,\r\nu64 *data)\r\n{\r\nstruct emac_adapter *adpt = netdev_priv(netdev);\r\nspin_lock(&adpt->stats.lock);\r\nemac_update_hw_stats(adpt);\r\nmemcpy(data, &adpt->stats, EMAC_STATS_LEN * sizeof(u64));\r\nspin_unlock(&adpt->stats.lock);\r\n}\r\nstatic int emac_nway_reset(struct net_device *netdev)\r\n{\r\nstruct phy_device *phydev = netdev->phydev;\r\nif (!phydev)\r\nreturn -ENODEV;\r\nreturn genphy_restart_aneg(phydev);\r\n}\r\nstatic void emac_get_ringparam(struct net_device *netdev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct emac_adapter *adpt = netdev_priv(netdev);\r\nring->rx_max_pending = EMAC_MAX_RX_DESCS;\r\nring->tx_max_pending = EMAC_MAX_TX_DESCS;\r\nring->rx_pending = adpt->rx_desc_cnt;\r\nring->tx_pending = adpt->tx_desc_cnt;\r\n}\r\nstatic int emac_set_ringparam(struct net_device *netdev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct emac_adapter *adpt = netdev_priv(netdev);\r\nif (ring->rx_mini_pending || ring->rx_jumbo_pending)\r\nreturn -EINVAL;\r\nadpt->tx_desc_cnt =\r\nclamp_val(ring->tx_pending, EMAC_MIN_TX_DESCS, EMAC_MAX_TX_DESCS);\r\nadpt->rx_desc_cnt =\r\nclamp_val(ring->rx_pending, EMAC_MIN_RX_DESCS, EMAC_MAX_RX_DESCS);\r\nif (netif_running(netdev))\r\nreturn emac_reinit_locked(adpt);\r\nreturn 0;\r\n}\r\nstatic void emac_get_pauseparam(struct net_device *netdev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct emac_adapter *adpt = netdev_priv(netdev);\r\npause->autoneg = adpt->automatic ? AUTONEG_ENABLE : AUTONEG_DISABLE;\r\npause->rx_pause = adpt->rx_flow_control ? 1 : 0;\r\npause->tx_pause = adpt->tx_flow_control ? 1 : 0;\r\n}\r\nstatic int emac_set_pauseparam(struct net_device *netdev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct emac_adapter *adpt = netdev_priv(netdev);\r\nadpt->automatic = pause->autoneg == AUTONEG_ENABLE;\r\nadpt->rx_flow_control = pause->rx_pause != 0;\r\nadpt->tx_flow_control = pause->tx_pause != 0;\r\nif (netif_running(netdev))\r\nreturn emac_reinit_locked(adpt);\r\nreturn 0;\r\n}\r\nstatic void emac_get_regs(struct net_device *netdev,\r\nstruct ethtool_regs *regs, void *buff)\r\n{\r\nstruct emac_adapter *adpt = netdev_priv(netdev);\r\nu32 *val = buff;\r\nunsigned int i;\r\nregs->version = EMAC_REGS_VERSION;\r\nregs->len = EMAC_MAX_REG_SIZE * sizeof(u32);\r\nfor (i = 0; i < EMAC_MAX_REG_SIZE; i++)\r\nval[i] = readl(adpt->base + emac_regs[i]);\r\n}\r\nstatic int emac_get_regs_len(struct net_device *netdev)\r\n{\r\nreturn EMAC_MAX_REG_SIZE * sizeof(u32);\r\n}\r\nvoid emac_set_ethtool_ops(struct net_device *netdev)\r\n{\r\nnetdev->ethtool_ops = &emac_ethtool_ops;\r\n}
