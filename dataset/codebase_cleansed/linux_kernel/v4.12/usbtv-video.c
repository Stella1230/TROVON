static int usbtv_configure_for_norm(struct usbtv *usbtv, v4l2_std_id norm)\r\n{\r\nint i, ret = 0;\r\nstruct usbtv_norm_params *params = NULL;\r\nfor (i = 0; i < ARRAY_SIZE(norm_params); i++) {\r\nif (norm_params[i].norm & norm) {\r\nparams = &norm_params[i];\r\nbreak;\r\n}\r\n}\r\nif (params) {\r\nusbtv->width = params->cap_width;\r\nusbtv->height = params->cap_height;\r\nusbtv->n_chunks = usbtv->width * usbtv->height\r\n/ 4 / USBTV_CHUNK;\r\nusbtv->norm = params->norm;\r\n} else\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int usbtv_select_input(struct usbtv *usbtv, int input)\r\n{\r\nint ret;\r\nstatic const u16 composite[][2] = {\r\n{ USBTV_BASE + 0x0105, 0x0060 },\r\n{ USBTV_BASE + 0x011f, 0x00f2 },\r\n{ USBTV_BASE + 0x0127, 0x0060 },\r\n{ USBTV_BASE + 0x00ae, 0x0010 },\r\n{ USBTV_BASE + 0x0239, 0x0060 },\r\n};\r\nstatic const u16 svideo[][2] = {\r\n{ USBTV_BASE + 0x0105, 0x0010 },\r\n{ USBTV_BASE + 0x011f, 0x00ff },\r\n{ USBTV_BASE + 0x0127, 0x0060 },\r\n{ USBTV_BASE + 0x00ae, 0x0030 },\r\n{ USBTV_BASE + 0x0239, 0x0060 },\r\n};\r\nswitch (input) {\r\ncase USBTV_COMPOSITE_INPUT:\r\nret = usbtv_set_regs(usbtv, composite, ARRAY_SIZE(composite));\r\nbreak;\r\ncase USBTV_SVIDEO_INPUT:\r\nret = usbtv_set_regs(usbtv, svideo, ARRAY_SIZE(svideo));\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nif (!ret)\r\nusbtv->input = input;\r\nreturn ret;\r\n}\r\nstatic int usbtv_select_norm(struct usbtv *usbtv, v4l2_std_id norm)\r\n{\r\nint ret;\r\nstatic const u16 pal[][2] = {\r\n{ USBTV_BASE + 0x001a, 0x0068 },\r\n{ USBTV_BASE + 0x010e, 0x0072 },\r\n{ USBTV_BASE + 0x010f, 0x00a2 },\r\n{ USBTV_BASE + 0x0112, 0x00b0 },\r\n{ USBTV_BASE + 0x0117, 0x0001 },\r\n{ USBTV_BASE + 0x0118, 0x002c },\r\n{ USBTV_BASE + 0x012d, 0x0010 },\r\n{ USBTV_BASE + 0x012f, 0x0020 },\r\n{ USBTV_BASE + 0x024f, 0x0002 },\r\n{ USBTV_BASE + 0x0254, 0x0059 },\r\n{ USBTV_BASE + 0x025a, 0x0016 },\r\n{ USBTV_BASE + 0x025b, 0x0035 },\r\n{ USBTV_BASE + 0x0263, 0x0017 },\r\n{ USBTV_BASE + 0x0266, 0x0016 },\r\n{ USBTV_BASE + 0x0267, 0x0036 }\r\n};\r\nstatic const u16 ntsc[][2] = {\r\n{ USBTV_BASE + 0x001a, 0x0079 },\r\n{ USBTV_BASE + 0x010e, 0x0068 },\r\n{ USBTV_BASE + 0x010f, 0x009c },\r\n{ USBTV_BASE + 0x0112, 0x00f0 },\r\n{ USBTV_BASE + 0x0117, 0x0000 },\r\n{ USBTV_BASE + 0x0118, 0x00fc },\r\n{ USBTV_BASE + 0x012d, 0x0004 },\r\n{ USBTV_BASE + 0x012f, 0x0008 },\r\n{ USBTV_BASE + 0x024f, 0x0001 },\r\n{ USBTV_BASE + 0x0254, 0x005f },\r\n{ USBTV_BASE + 0x025a, 0x0012 },\r\n{ USBTV_BASE + 0x025b, 0x0001 },\r\n{ USBTV_BASE + 0x0263, 0x001c },\r\n{ USBTV_BASE + 0x0266, 0x0011 },\r\n{ USBTV_BASE + 0x0267, 0x0005 }\r\n};\r\nret = usbtv_configure_for_norm(usbtv, norm);\r\nif (!ret) {\r\nif (norm & V4L2_STD_525_60)\r\nret = usbtv_set_regs(usbtv, ntsc, ARRAY_SIZE(ntsc));\r\nelse if (norm & V4L2_STD_PAL)\r\nret = usbtv_set_regs(usbtv, pal, ARRAY_SIZE(pal));\r\n}\r\nreturn ret;\r\n}\r\nstatic int usbtv_setup_capture(struct usbtv *usbtv)\r\n{\r\nint ret;\r\nstatic const u16 setup[][2] = {\r\n{ USBTV_BASE + 0x0008, 0x0001 },\r\n{ USBTV_BASE + 0x01d0, 0x00ff },\r\n{ USBTV_BASE + 0x01d9, 0x0002 },\r\n{ USBTV_BASE + 0x0239, 0x0040 },\r\n{ USBTV_BASE + 0x0240, 0x0000 },\r\n{ USBTV_BASE + 0x0241, 0x0000 },\r\n{ USBTV_BASE + 0x0242, 0x0002 },\r\n{ USBTV_BASE + 0x0243, 0x0080 },\r\n{ USBTV_BASE + 0x0244, 0x0012 },\r\n{ USBTV_BASE + 0x0245, 0x0090 },\r\n{ USBTV_BASE + 0x0246, 0x0000 },\r\n{ USBTV_BASE + 0x0278, 0x002d },\r\n{ USBTV_BASE + 0x0279, 0x000a },\r\n{ USBTV_BASE + 0x027a, 0x0032 },\r\n{ 0xf890, 0x000c },\r\n{ 0xf894, 0x0086 },\r\n{ USBTV_BASE + 0x00ac, 0x00c0 },\r\n{ USBTV_BASE + 0x00ad, 0x0000 },\r\n{ USBTV_BASE + 0x00a2, 0x0012 },\r\n{ USBTV_BASE + 0x00a3, 0x00e0 },\r\n{ USBTV_BASE + 0x00a4, 0x0028 },\r\n{ USBTV_BASE + 0x00a5, 0x0082 },\r\n{ USBTV_BASE + 0x00a7, 0x0080 },\r\n{ USBTV_BASE + 0x0000, 0x0014 },\r\n{ USBTV_BASE + 0x0006, 0x0003 },\r\n{ USBTV_BASE + 0x0090, 0x0099 },\r\n{ USBTV_BASE + 0x0091, 0x0090 },\r\n{ USBTV_BASE + 0x0094, 0x0068 },\r\n{ USBTV_BASE + 0x0095, 0x0070 },\r\n{ USBTV_BASE + 0x009c, 0x0030 },\r\n{ USBTV_BASE + 0x009d, 0x00c0 },\r\n{ USBTV_BASE + 0x009e, 0x00e0 },\r\n{ USBTV_BASE + 0x0019, 0x0006 },\r\n{ USBTV_BASE + 0x008c, 0x00ba },\r\n{ USBTV_BASE + 0x0101, 0x00ff },\r\n{ USBTV_BASE + 0x010c, 0x00b3 },\r\n{ USBTV_BASE + 0x01b2, 0x0080 },\r\n{ USBTV_BASE + 0x01b4, 0x00a0 },\r\n{ USBTV_BASE + 0x014c, 0x00ff },\r\n{ USBTV_BASE + 0x014d, 0x00ca },\r\n{ USBTV_BASE + 0x0113, 0x0053 },\r\n{ USBTV_BASE + 0x0119, 0x008a },\r\n{ USBTV_BASE + 0x013c, 0x0003 },\r\n{ USBTV_BASE + 0x0150, 0x009c },\r\n{ USBTV_BASE + 0x0151, 0x0071 },\r\n{ USBTV_BASE + 0x0152, 0x00c6 },\r\n{ USBTV_BASE + 0x0153, 0x0084 },\r\n{ USBTV_BASE + 0x0154, 0x00bc },\r\n{ USBTV_BASE + 0x0155, 0x00a0 },\r\n{ USBTV_BASE + 0x0156, 0x00a0 },\r\n{ USBTV_BASE + 0x0157, 0x009c },\r\n{ USBTV_BASE + 0x0158, 0x001f },\r\n{ USBTV_BASE + 0x0159, 0x0006 },\r\n{ USBTV_BASE + 0x015d, 0x0000 },\r\n{ USBTV_BASE + 0x0003, 0x0004 },\r\n{ USBTV_BASE + 0x0100, 0x00d3 },\r\n{ USBTV_BASE + 0x0115, 0x0015 },\r\n{ USBTV_BASE + 0x0220, 0x002e },\r\n{ USBTV_BASE + 0x0225, 0x0008 },\r\n{ USBTV_BASE + 0x024e, 0x0002 },\r\n{ USBTV_BASE + 0x024e, 0x0002 },\r\n{ USBTV_BASE + 0x024f, 0x0002 },\r\n};\r\nret = usbtv_set_regs(usbtv, setup, ARRAY_SIZE(setup));\r\nif (ret)\r\nreturn ret;\r\nret = usbtv_select_norm(usbtv, usbtv->norm);\r\nif (ret)\r\nreturn ret;\r\nret = usbtv_select_input(usbtv, usbtv->input);\r\nif (ret)\r\nreturn ret;\r\nret = v4l2_ctrl_handler_setup(&usbtv->ctrl);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void usbtv_chunk_to_vbuf(u32 *frame, __be32 *src, int chunk_no, int odd)\r\n{\r\nint half;\r\nfor (half = 0; half < 2; half++) {\r\nint part_no = chunk_no * 2 + half;\r\nint line = part_no / 3;\r\nint part_index = (line * 2 + !odd) * 3 + (part_no % 3);\r\nu32 *dst = &frame[part_index * USBTV_CHUNK/2];\r\nmemcpy(dst, src, USBTV_CHUNK/2 * sizeof(*src));\r\nsrc += USBTV_CHUNK/2;\r\n}\r\n}\r\nstatic void usbtv_image_chunk(struct usbtv *usbtv, __be32 *chunk)\r\n{\r\nint frame_id, odd, chunk_no;\r\nu32 *frame;\r\nstruct usbtv_buf *buf;\r\nunsigned long flags;\r\nif (!USBTV_MAGIC_OK(chunk))\r\nreturn;\r\nframe_id = USBTV_FRAME_ID(chunk);\r\nodd = USBTV_ODD(chunk);\r\nchunk_no = USBTV_CHUNK_NO(chunk);\r\nif (chunk_no >= usbtv->n_chunks)\r\nreturn;\r\nif (chunk_no == 0) {\r\nusbtv->frame_id = frame_id;\r\nusbtv->chunks_done = 0;\r\n}\r\nif (usbtv->frame_id != frame_id)\r\nreturn;\r\nspin_lock_irqsave(&usbtv->buflock, flags);\r\nif (list_empty(&usbtv->bufs)) {\r\nspin_unlock_irqrestore(&usbtv->buflock, flags);\r\nreturn;\r\n}\r\nbuf = list_first_entry(&usbtv->bufs, struct usbtv_buf, list);\r\nframe = vb2_plane_vaddr(&buf->vb.vb2_buf, 0);\r\nusbtv_chunk_to_vbuf(frame, &chunk[1], chunk_no, odd);\r\nusbtv->chunks_done++;\r\nif (chunk_no == usbtv->n_chunks-1) {\r\nif (odd && !usbtv->last_odd) {\r\nint size = vb2_plane_size(&buf->vb.vb2_buf, 0);\r\nenum vb2_buffer_state state = usbtv->chunks_done ==\r\nusbtv->n_chunks ?\r\nVB2_BUF_STATE_DONE :\r\nVB2_BUF_STATE_ERROR;\r\nbuf->vb.field = V4L2_FIELD_INTERLACED;\r\nbuf->vb.sequence = usbtv->sequence++;\r\nbuf->vb.vb2_buf.timestamp = ktime_get_ns();\r\nvb2_set_plane_payload(&buf->vb.vb2_buf, 0, size);\r\nvb2_buffer_done(&buf->vb.vb2_buf, state);\r\nlist_del(&buf->list);\r\n}\r\nusbtv->last_odd = odd;\r\n}\r\nspin_unlock_irqrestore(&usbtv->buflock, flags);\r\n}\r\nstatic void usbtv_iso_cb(struct urb *ip)\r\n{\r\nint ret;\r\nint i;\r\nstruct usbtv *usbtv = (struct usbtv *)ip->context;\r\nswitch (ip->status) {\r\ncase 0:\r\nbreak;\r\ncase -ENODEV:\r\ncase -ENOENT:\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\ndev_warn(usbtv->dev, "Bad response for ISO request.\n");\r\ngoto resubmit;\r\n}\r\nfor (i = 0; i < ip->number_of_packets; i++) {\r\nint size = ip->iso_frame_desc[i].actual_length;\r\nunsigned char *data = ip->transfer_buffer +\r\nip->iso_frame_desc[i].offset;\r\nint offset;\r\nfor (offset = 0; USBTV_CHUNK_SIZE * offset < size; offset++)\r\nusbtv_image_chunk(usbtv,\r\n(__be32 *)&data[USBTV_CHUNK_SIZE * offset]);\r\n}\r\nresubmit:\r\nret = usb_submit_urb(ip, GFP_ATOMIC);\r\nif (ret < 0)\r\ndev_warn(usbtv->dev, "Could not resubmit ISO URB\n");\r\n}\r\nstatic struct urb *usbtv_setup_iso_transfer(struct usbtv *usbtv)\r\n{\r\nstruct urb *ip;\r\nint size = usbtv->iso_size;\r\nint i;\r\nip = usb_alloc_urb(USBTV_ISOC_PACKETS, GFP_KERNEL);\r\nif (ip == NULL)\r\nreturn NULL;\r\nip->dev = usbtv->udev;\r\nip->context = usbtv;\r\nip->pipe = usb_rcvisocpipe(usbtv->udev, USBTV_VIDEO_ENDP);\r\nip->interval = 1;\r\nip->transfer_flags = URB_ISO_ASAP;\r\nip->transfer_buffer = kzalloc(size * USBTV_ISOC_PACKETS,\r\nGFP_KERNEL);\r\nif (!ip->transfer_buffer) {\r\nusb_free_urb(ip);\r\nreturn NULL;\r\n}\r\nip->complete = usbtv_iso_cb;\r\nip->number_of_packets = USBTV_ISOC_PACKETS;\r\nip->transfer_buffer_length = size * USBTV_ISOC_PACKETS;\r\nfor (i = 0; i < USBTV_ISOC_PACKETS; i++) {\r\nip->iso_frame_desc[i].offset = size * i;\r\nip->iso_frame_desc[i].length = size;\r\n}\r\nreturn ip;\r\n}\r\nstatic void usbtv_stop(struct usbtv *usbtv)\r\n{\r\nint i;\r\nunsigned long flags;\r\nfor (i = 0; i < USBTV_ISOC_TRANSFERS; i++) {\r\nstruct urb *ip = usbtv->isoc_urbs[i];\r\nif (ip == NULL)\r\ncontinue;\r\nusb_kill_urb(ip);\r\nkfree(ip->transfer_buffer);\r\nusb_free_urb(ip);\r\nusbtv->isoc_urbs[i] = NULL;\r\n}\r\nspin_lock_irqsave(&usbtv->buflock, flags);\r\nwhile (!list_empty(&usbtv->bufs)) {\r\nstruct usbtv_buf *buf = list_first_entry(&usbtv->bufs,\r\nstruct usbtv_buf, list);\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\r\nlist_del(&buf->list);\r\n}\r\nspin_unlock_irqrestore(&usbtv->buflock, flags);\r\n}\r\nstatic int usbtv_start(struct usbtv *usbtv)\r\n{\r\nint i;\r\nint ret;\r\nusbtv_audio_suspend(usbtv);\r\nret = usb_set_interface(usbtv->udev, 0, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = usbtv_setup_capture(usbtv);\r\nif (ret < 0)\r\nreturn ret;\r\nret = usb_set_interface(usbtv->udev, 0, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nusbtv_audio_resume(usbtv);\r\nfor (i = 0; i < USBTV_ISOC_TRANSFERS; i++) {\r\nstruct urb *ip;\r\nip = usbtv_setup_iso_transfer(usbtv);\r\nif (ip == NULL) {\r\nret = -ENOMEM;\r\ngoto start_fail;\r\n}\r\nusbtv->isoc_urbs[i] = ip;\r\nret = usb_submit_urb(ip, GFP_KERNEL);\r\nif (ret < 0)\r\ngoto start_fail;\r\n}\r\nreturn 0;\r\nstart_fail:\r\nusbtv_stop(usbtv);\r\nreturn ret;\r\n}\r\nstatic int usbtv_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct usbtv *dev = video_drvdata(file);\r\nstrlcpy(cap->driver, "usbtv", sizeof(cap->driver));\r\nstrlcpy(cap->card, "usbtv", sizeof(cap->card));\r\nusb_make_path(dev->udev, cap->bus_info, sizeof(cap->bus_info));\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE;\r\ncap->device_caps |= V4L2_CAP_READWRITE | V4L2_CAP_STREAMING;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int usbtv_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nstruct usbtv *dev = video_drvdata(file);\r\nswitch (i->index) {\r\ncase USBTV_COMPOSITE_INPUT:\r\nstrlcpy(i->name, "Composite", sizeof(i->name));\r\nbreak;\r\ncase USBTV_SVIDEO_INPUT:\r\nstrlcpy(i->name, "S-Video", sizeof(i->name));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\ni->std = dev->vdev.tvnorms;\r\nreturn 0;\r\n}\r\nstatic int usbtv_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (f->index > 0)\r\nreturn -EINVAL;\r\nstrlcpy(f->description, "16 bpp YUY2, 4:2:2, packed",\r\nsizeof(f->description));\r\nf->pixelformat = V4L2_PIX_FMT_YUYV;\r\nreturn 0;\r\n}\r\nstatic int usbtv_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct usbtv *usbtv = video_drvdata(file);\r\nf->fmt.pix.width = usbtv->width;\r\nf->fmt.pix.height = usbtv->height;\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_YUYV;\r\nf->fmt.pix.field = V4L2_FIELD_INTERLACED;\r\nf->fmt.pix.bytesperline = usbtv->width * 2;\r\nf->fmt.pix.sizeimage = (f->fmt.pix.bytesperline * f->fmt.pix.height);\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nreturn 0;\r\n}\r\nstatic int usbtv_g_std(struct file *file, void *priv, v4l2_std_id *norm)\r\n{\r\nstruct usbtv *usbtv = video_drvdata(file);\r\n*norm = usbtv->norm;\r\nreturn 0;\r\n}\r\nstatic int usbtv_s_std(struct file *file, void *priv, v4l2_std_id norm)\r\n{\r\nint ret = -EINVAL;\r\nstruct usbtv *usbtv = video_drvdata(file);\r\nif ((norm & V4L2_STD_525_60) || (norm & V4L2_STD_PAL))\r\nret = usbtv_select_norm(usbtv, norm);\r\nreturn ret;\r\n}\r\nstatic int usbtv_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct usbtv *usbtv = video_drvdata(file);\r\n*i = usbtv->input;\r\nreturn 0;\r\n}\r\nstatic int usbtv_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nstruct usbtv *usbtv = video_drvdata(file);\r\nreturn usbtv_select_input(usbtv, i);\r\n}\r\nstatic int usbtv_queue_setup(struct vb2_queue *vq,\r\nunsigned int *nbuffers,\r\nunsigned int *nplanes, unsigned int sizes[], struct device *alloc_devs[])\r\n{\r\nstruct usbtv *usbtv = vb2_get_drv_priv(vq);\r\nunsigned size = USBTV_CHUNK * usbtv->n_chunks * 2 * sizeof(u32);\r\nif (vq->num_buffers + *nbuffers < 2)\r\n*nbuffers = 2 - vq->num_buffers;\r\nif (*nplanes)\r\nreturn sizes[0] < size ? -EINVAL : 0;\r\n*nplanes = 1;\r\nsizes[0] = size;\r\nreturn 0;\r\n}\r\nstatic void usbtv_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct usbtv *usbtv = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct usbtv_buf *buf = container_of(vbuf, struct usbtv_buf, vb);\r\nunsigned long flags;\r\nif (usbtv->udev == NULL) {\r\nvb2_buffer_done(vb, VB2_BUF_STATE_ERROR);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&usbtv->buflock, flags);\r\nlist_add_tail(&buf->list, &usbtv->bufs);\r\nspin_unlock_irqrestore(&usbtv->buflock, flags);\r\n}\r\nstatic int usbtv_start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct usbtv *usbtv = vb2_get_drv_priv(vq);\r\nif (usbtv->udev == NULL)\r\nreturn -ENODEV;\r\nusbtv->last_odd = 1;\r\nusbtv->sequence = 0;\r\nreturn usbtv_start(usbtv);\r\n}\r\nstatic void usbtv_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct usbtv *usbtv = vb2_get_drv_priv(vq);\r\nif (usbtv->udev)\r\nusbtv_stop(usbtv);\r\n}\r\nstatic int usbtv_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct usbtv *usbtv = container_of(ctrl->handler, struct usbtv,\r\nctrl);\r\nu8 *data;\r\nu16 index, size;\r\nint ret;\r\ndata = kmalloc(3, GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nif (ctrl->id == V4L2_CID_BRIGHTNESS || ctrl->id == V4L2_CID_CONTRAST) {\r\nret = usb_control_msg(usbtv->udev,\r\nusb_sndctrlpipe(usbtv->udev, 0), USBTV_CONTROL_REG,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0, USBTV_BASE + 0x0244, (void *)data, 3, 0);\r\nif (ret < 0)\r\ngoto error;\r\n}\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nindex = USBTV_BASE + 0x0244;\r\nsize = 3;\r\ndata[0] &= 0xf0;\r\ndata[0] |= (ctrl->val >> 8) & 0xf;\r\ndata[2] = ctrl->val & 0xff;\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nindex = USBTV_BASE + 0x0244;\r\nsize = 3;\r\ndata[0] &= 0x0f;\r\ndata[0] |= (ctrl->val >> 4) & 0xf0;\r\ndata[1] = ctrl->val & 0xff;\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nindex = USBTV_BASE + 0x0242;\r\ndata[0] = ctrl->val >> 8;\r\ndata[1] = ctrl->val & 0xff;\r\nsize = 2;\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nindex = USBTV_BASE + 0x0240;\r\nsize = 2;\r\nif (ctrl->val > 0) {\r\ndata[0] = 0x92 + (ctrl->val >> 8);\r\ndata[1] = ctrl->val & 0xff;\r\n} else {\r\ndata[0] = 0x82 + (-ctrl->val >> 8);\r\ndata[1] = -ctrl->val & 0xff;\r\n}\r\nbreak;\r\ncase V4L2_CID_SHARPNESS:\r\nindex = USBTV_BASE + 0x0239;\r\ndata[0] = 0;\r\ndata[1] = ctrl->val;\r\nsize = 2;\r\nbreak;\r\ndefault:\r\nkfree(data);\r\nreturn -EINVAL;\r\n}\r\nret = usb_control_msg(usbtv->udev, usb_sndctrlpipe(usbtv->udev, 0),\r\nUSBTV_CONTROL_REG,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0, index, (void *)data, size, 0);\r\nerror:\r\nif (ret < 0)\r\ndev_warn(usbtv->dev, "Failed to submit a control request.\n");\r\nkfree(data);\r\nreturn ret;\r\n}\r\nstatic void usbtv_release(struct v4l2_device *v4l2_dev)\r\n{\r\nstruct usbtv *usbtv = container_of(v4l2_dev, struct usbtv, v4l2_dev);\r\nv4l2_device_unregister(&usbtv->v4l2_dev);\r\nv4l2_ctrl_handler_free(&usbtv->ctrl);\r\nvb2_queue_release(&usbtv->vb2q);\r\nkfree(usbtv);\r\n}\r\nint usbtv_video_init(struct usbtv *usbtv)\r\n{\r\nint ret;\r\n(void)usbtv_configure_for_norm(usbtv, V4L2_STD_525_60);\r\nspin_lock_init(&usbtv->buflock);\r\nmutex_init(&usbtv->v4l2_lock);\r\nmutex_init(&usbtv->vb2q_lock);\r\nINIT_LIST_HEAD(&usbtv->bufs);\r\nusbtv->vb2q.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nusbtv->vb2q.io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ;\r\nusbtv->vb2q.drv_priv = usbtv;\r\nusbtv->vb2q.buf_struct_size = sizeof(struct usbtv_buf);\r\nusbtv->vb2q.ops = &usbtv_vb2_ops;\r\nusbtv->vb2q.mem_ops = &vb2_vmalloc_memops;\r\nusbtv->vb2q.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nusbtv->vb2q.lock = &usbtv->vb2q_lock;\r\nret = vb2_queue_init(&usbtv->vb2q);\r\nif (ret < 0) {\r\ndev_warn(usbtv->dev, "Could not initialize videobuf2 queue\n");\r\nreturn ret;\r\n}\r\nv4l2_ctrl_handler_init(&usbtv->ctrl, 4);\r\nv4l2_ctrl_new_std(&usbtv->ctrl, &usbtv_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 0x3ff, 1, 0x1d0);\r\nv4l2_ctrl_new_std(&usbtv->ctrl, &usbtv_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 0x3ff, 1, 0x1c0);\r\nv4l2_ctrl_new_std(&usbtv->ctrl, &usbtv_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 0x3ff, 1, 0x200);\r\nv4l2_ctrl_new_std(&usbtv->ctrl, &usbtv_ctrl_ops,\r\nV4L2_CID_HUE, -0xdff, 0xdff, 1, 0x000);\r\nv4l2_ctrl_new_std(&usbtv->ctrl, &usbtv_ctrl_ops,\r\nV4L2_CID_SHARPNESS, 0x0, 0xff, 1, 0x60);\r\nret = usbtv->ctrl.error;\r\nif (ret < 0) {\r\ndev_warn(usbtv->dev, "Could not initialize controls\n");\r\ngoto ctrl_fail;\r\n}\r\nusbtv->v4l2_dev.ctrl_handler = &usbtv->ctrl;\r\nusbtv->v4l2_dev.release = usbtv_release;\r\nret = v4l2_device_register(usbtv->dev, &usbtv->v4l2_dev);\r\nif (ret < 0) {\r\ndev_warn(usbtv->dev, "Could not register v4l2 device\n");\r\ngoto v4l2_fail;\r\n}\r\nstrlcpy(usbtv->vdev.name, "usbtv", sizeof(usbtv->vdev.name));\r\nusbtv->vdev.v4l2_dev = &usbtv->v4l2_dev;\r\nusbtv->vdev.release = video_device_release_empty;\r\nusbtv->vdev.fops = &usbtv_fops;\r\nusbtv->vdev.ioctl_ops = &usbtv_ioctl_ops;\r\nusbtv->vdev.tvnorms = USBTV_TV_STD;\r\nusbtv->vdev.queue = &usbtv->vb2q;\r\nusbtv->vdev.lock = &usbtv->v4l2_lock;\r\nvideo_set_drvdata(&usbtv->vdev, usbtv);\r\nret = video_register_device(&usbtv->vdev, VFL_TYPE_GRABBER, -1);\r\nif (ret < 0) {\r\ndev_warn(usbtv->dev, "Could not register video device\n");\r\ngoto vdev_fail;\r\n}\r\nreturn 0;\r\nvdev_fail:\r\nv4l2_device_unregister(&usbtv->v4l2_dev);\r\nv4l2_fail:\r\nctrl_fail:\r\nv4l2_ctrl_handler_free(&usbtv->ctrl);\r\nvb2_queue_release(&usbtv->vb2q);\r\nreturn ret;\r\n}\r\nvoid usbtv_video_free(struct usbtv *usbtv)\r\n{\r\nmutex_lock(&usbtv->vb2q_lock);\r\nmutex_lock(&usbtv->v4l2_lock);\r\nusbtv_stop(usbtv);\r\nvideo_unregister_device(&usbtv->vdev);\r\nv4l2_device_disconnect(&usbtv->v4l2_dev);\r\nmutex_unlock(&usbtv->v4l2_lock);\r\nmutex_unlock(&usbtv->vb2q_lock);\r\nv4l2_device_put(&usbtv->v4l2_dev);\r\n}
