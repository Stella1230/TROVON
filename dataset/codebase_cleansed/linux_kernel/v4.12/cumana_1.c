static inline int cumanascsi_pwrite(struct NCR5380_hostdata *hostdata,\r\nunsigned char *addr, int len)\r\n{\r\nunsigned long *laddr;\r\nu8 __iomem *base = hostdata->io;\r\nu8 __iomem *dma = hostdata->pdma_io + 0x2000;\r\nif(!len) return 0;\r\nwriteb(0x02, base + CTRL);\r\nladdr = (unsigned long *)addr;\r\nwhile(len >= 32)\r\n{\r\nunsigned int status;\r\nunsigned long v;\r\nstatus = readb(base + STAT);\r\nif(status & 0x80)\r\ngoto end;\r\nif(!(status & 0x40))\r\ncontinue;\r\nv=*laddr++; writew(L(v), dma); writew(H(v), dma);\r\nv=*laddr++; writew(L(v), dma); writew(H(v), dma);\r\nv=*laddr++; writew(L(v), dma); writew(H(v), dma);\r\nv=*laddr++; writew(L(v), dma); writew(H(v), dma);\r\nv=*laddr++; writew(L(v), dma); writew(H(v), dma);\r\nv=*laddr++; writew(L(v), dma); writew(H(v), dma);\r\nv=*laddr++; writew(L(v), dma); writew(H(v), dma);\r\nv=*laddr++; writew(L(v), dma); writew(H(v), dma);\r\nlen -= 32;\r\nif(len == 0)\r\nbreak;\r\n}\r\naddr = (unsigned char *)laddr;\r\nwriteb(0x12, base + CTRL);\r\nwhile(len > 0)\r\n{\r\nunsigned int status;\r\nstatus = readb(base + STAT);\r\nif(status & 0x80)\r\ngoto end;\r\nif(status & 0x40)\r\n{\r\nwriteb(*addr++, dma);\r\nif(--len == 0)\r\nbreak;\r\n}\r\nstatus = readb(base + STAT);\r\nif(status & 0x80)\r\ngoto end;\r\nif(status & 0x40)\r\n{\r\nwriteb(*addr++, dma);\r\nif(--len == 0)\r\nbreak;\r\n}\r\n}\r\nend:\r\nwriteb(hostdata->ctrl | 0x40, base + CTRL);\r\nif (len)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic inline int cumanascsi_pread(struct NCR5380_hostdata *hostdata,\r\nunsigned char *addr, int len)\r\n{\r\nunsigned long *laddr;\r\nu8 __iomem *base = hostdata->io;\r\nu8 __iomem *dma = hostdata->pdma_io + 0x2000;\r\nif(!len) return 0;\r\nwriteb(0x00, base + CTRL);\r\nladdr = (unsigned long *)addr;\r\nwhile(len >= 32)\r\n{\r\nunsigned int status;\r\nstatus = readb(base + STAT);\r\nif(status & 0x80)\r\ngoto end;\r\nif(!(status & 0x40))\r\ncontinue;\r\n*laddr++ = readw(dma) | (readw(dma) << 16);\r\n*laddr++ = readw(dma) | (readw(dma) << 16);\r\n*laddr++ = readw(dma) | (readw(dma) << 16);\r\n*laddr++ = readw(dma) | (readw(dma) << 16);\r\n*laddr++ = readw(dma) | (readw(dma) << 16);\r\n*laddr++ = readw(dma) | (readw(dma) << 16);\r\n*laddr++ = readw(dma) | (readw(dma) << 16);\r\n*laddr++ = readw(dma) | (readw(dma) << 16);\r\nlen -= 32;\r\nif(len == 0)\r\nbreak;\r\n}\r\naddr = (unsigned char *)laddr;\r\nwriteb(0x10, base + CTRL);\r\nwhile(len > 0)\r\n{\r\nunsigned int status;\r\nstatus = readb(base + STAT);\r\nif(status & 0x80)\r\ngoto end;\r\nif(status & 0x40)\r\n{\r\n*addr++ = readb(dma);\r\nif(--len == 0)\r\nbreak;\r\n}\r\nstatus = readb(base + STAT);\r\nif(status & 0x80)\r\ngoto end;\r\nif(status & 0x40)\r\n{\r\n*addr++ = readb(dma);\r\nif(--len == 0)\r\nbreak;\r\n}\r\n}\r\nend:\r\nwriteb(hostdata->ctrl | 0x40, base + CTRL);\r\nif (len)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int cumanascsi_dma_xfer_len(struct NCR5380_hostdata *hostdata,\r\nstruct scsi_cmnd *cmd)\r\n{\r\nreturn cmd->transfersize;\r\n}\r\nstatic u8 cumanascsi_read(struct NCR5380_hostdata *hostdata,\r\nunsigned int reg)\r\n{\r\nu8 __iomem *base = hostdata->io;\r\nu8 val;\r\nwriteb(0, base + CTRL);\r\nval = readb(base + 0x2100 + (reg << 2));\r\nhostdata->ctrl = 0x40;\r\nwriteb(0x40, base + CTRL);\r\nreturn val;\r\n}\r\nstatic void cumanascsi_write(struct NCR5380_hostdata *hostdata,\r\nunsigned int reg, u8 value)\r\n{\r\nu8 __iomem *base = hostdata->io;\r\nwriteb(0, base + CTRL);\r\nwriteb(value, base + 0x2100 + (reg << 2));\r\nhostdata->ctrl = 0x40;\r\nwriteb(0x40, base + CTRL);\r\n}\r\nstatic int cumanascsi1_probe(struct expansion_card *ec,\r\nconst struct ecard_id *id)\r\n{\r\nstruct Scsi_Host *host;\r\nint ret;\r\nret = ecard_request_resources(ec);\r\nif (ret)\r\ngoto out;\r\nhost = scsi_host_alloc(&cumanascsi_template, sizeof(struct NCR5380_hostdata));\r\nif (!host) {\r\nret = -ENOMEM;\r\ngoto out_release;\r\n}\r\npriv(host)->io = ioremap(ecard_resource_start(ec, ECARD_RES_IOCSLOW),\r\necard_resource_len(ec, ECARD_RES_IOCSLOW));\r\npriv(host)->pdma_io = ioremap(ecard_resource_start(ec, ECARD_RES_MEMC),\r\necard_resource_len(ec, ECARD_RES_MEMC));\r\nif (!priv(host)->io || !priv(host)->pdma_io) {\r\nret = -ENOMEM;\r\ngoto out_unmap;\r\n}\r\nhost->irq = ec->irq;\r\nret = NCR5380_init(host, FLAG_DMA_FIXUP | FLAG_LATE_DMA_SETUP);\r\nif (ret)\r\ngoto out_unmap;\r\nNCR5380_maybe_reset_bus(host);\r\npriv(host)->ctrl = 0;\r\nwriteb(0, priv(host)->io + CTRL);\r\nret = request_irq(host->irq, cumanascsi_intr, 0,\r\n"CumanaSCSI-1", host);\r\nif (ret) {\r\nprintk("scsi%d: IRQ%d not free: %d\n",\r\nhost->host_no, host->irq, ret);\r\ngoto out_exit;\r\n}\r\nret = scsi_add_host(host, &ec->dev);\r\nif (ret)\r\ngoto out_free_irq;\r\nscsi_scan_host(host);\r\ngoto out;\r\nout_free_irq:\r\nfree_irq(host->irq, host);\r\nout_exit:\r\nNCR5380_exit(host);\r\nout_unmap:\r\niounmap(priv(host)->io);\r\niounmap(priv(host)->pdma_io);\r\nscsi_host_put(host);\r\nout_release:\r\necard_release_resources(ec);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void cumanascsi1_remove(struct expansion_card *ec)\r\n{\r\nstruct Scsi_Host *host = ecard_get_drvdata(ec);\r\nvoid __iomem *base = priv(host)->io;\r\nvoid __iomem *dma = priv(host)->pdma_io;\r\necard_set_drvdata(ec, NULL);\r\nscsi_remove_host(host);\r\nfree_irq(host->irq, host);\r\nNCR5380_exit(host);\r\nscsi_host_put(host);\r\niounmap(base);\r\niounmap(dma);\r\necard_release_resources(ec);\r\n}\r\nstatic int __init cumanascsi_init(void)\r\n{\r\nreturn ecard_register_driver(&cumanascsi1_driver);\r\n}\r\nstatic void __exit cumanascsi_exit(void)\r\n{\r\necard_remove_driver(&cumanascsi1_driver);\r\n}
