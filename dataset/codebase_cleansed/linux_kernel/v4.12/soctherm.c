static inline void clk_writel(struct tegra_soctherm *ts, u32 value, u32 reg)\r\n{\r\nwritel(value, (ts->clk_regs + reg));\r\n}\r\nstatic inline u32 clk_readl(struct tegra_soctherm *ts, u32 reg)\r\n{\r\nreturn readl(ts->clk_regs + reg);\r\n}\r\nstatic inline void ccroc_writel(struct tegra_soctherm *ts, u32 value, u32 reg)\r\n{\r\nwritel(value, (ts->ccroc_regs + reg));\r\n}\r\nstatic inline u32 ccroc_readl(struct tegra_soctherm *ts, u32 reg)\r\n{\r\nreturn readl(ts->ccroc_regs + reg);\r\n}\r\nstatic void enable_tsensor(struct tegra_soctherm *tegra, unsigned int i)\r\n{\r\nconst struct tegra_tsensor *sensor = &tegra->soc->tsensors[i];\r\nvoid __iomem *base = tegra->regs + sensor->base;\r\nunsigned int val;\r\nval = sensor->config->tall << SENSOR_CONFIG0_TALL_SHIFT;\r\nwritel(val, base + SENSOR_CONFIG0);\r\nval = (sensor->config->tsample - 1) << SENSOR_CONFIG1_TSAMPLE_SHIFT;\r\nval |= sensor->config->tiddq_en << SENSOR_CONFIG1_TIDDQ_EN_SHIFT;\r\nval |= sensor->config->ten_count << SENSOR_CONFIG1_TEN_COUNT_SHIFT;\r\nval |= SENSOR_CONFIG1_TEMP_ENABLE;\r\nwritel(val, base + SENSOR_CONFIG1);\r\nwritel(tegra->calib[i], base + SENSOR_CONFIG2);\r\n}\r\nstatic int translate_temp(u16 val)\r\n{\r\nint t;\r\nt = ((val & READBACK_VALUE_MASK) >> READBACK_VALUE_SHIFT) * 1000;\r\nif (val & READBACK_ADD_HALF)\r\nt += 500;\r\nif (val & READBACK_NEGATE)\r\nt *= -1;\r\nreturn t;\r\n}\r\nstatic int tegra_thermctl_get_temp(void *data, int *out_temp)\r\n{\r\nstruct tegra_thermctl_zone *zone = data;\r\nu32 val;\r\nval = readl(zone->reg);\r\nval = REG_GET_MASK(val, zone->sg->sensor_temp_mask);\r\n*out_temp = translate_temp(val);\r\nreturn 0;\r\n}\r\nstatic int tegra_thermctl_set_trip_temp(void *data, int trip, int temp)\r\n{\r\nstruct tegra_thermctl_zone *zone = data;\r\nstruct thermal_zone_device *tz = zone->tz;\r\nstruct tegra_soctherm *ts = zone->ts;\r\nconst struct tegra_tsensor_group *sg = zone->sg;\r\nstruct device *dev = zone->dev;\r\nenum thermal_trip_type type;\r\nint ret;\r\nif (!tz)\r\nreturn -EINVAL;\r\nret = tz->ops->get_trip_type(tz, trip, &type);\r\nif (ret)\r\nreturn ret;\r\nif (type == THERMAL_TRIP_CRITICAL) {\r\nreturn thermtrip_program(dev, sg, temp);\r\n} else if (type == THERMAL_TRIP_HOT) {\r\nint i;\r\nfor (i = 0; i < THROTTLE_SIZE; i++) {\r\nstruct thermal_cooling_device *cdev;\r\nstruct soctherm_throt_cfg *stc;\r\nif (!ts->throt_cfgs[i].init)\r\ncontinue;\r\ncdev = ts->throt_cfgs[i].cdev;\r\nif (get_thermal_instance(tz, cdev, trip))\r\nstc = find_throttle_cfg_by_name(ts, cdev->type);\r\nelse\r\ncontinue;\r\nreturn throttrip_program(dev, sg, stc, temp);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int enforce_temp_range(struct device *dev, int trip_temp)\r\n{\r\nint temp;\r\ntemp = clamp_val(trip_temp, min_low_temp, max_high_temp);\r\nif (temp != trip_temp)\r\ndev_info(dev, "soctherm: trip temperature %d forced to %d\n",\r\ntrip_temp, temp);\r\nreturn temp;\r\n}\r\nstatic int thermtrip_program(struct device *dev,\r\nconst struct tegra_tsensor_group *sg,\r\nint trip_temp)\r\n{\r\nstruct tegra_soctherm *ts = dev_get_drvdata(dev);\r\nint temp;\r\nu32 r;\r\nif (!sg || !sg->thermtrip_threshold_mask)\r\nreturn -EINVAL;\r\ntemp = enforce_temp_range(dev, trip_temp) / ts->soc->thresh_grain;\r\nr = readl(ts->regs + THERMCTL_THERMTRIP_CTL);\r\nr = REG_SET_MASK(r, sg->thermtrip_threshold_mask, temp);\r\nr = REG_SET_MASK(r, sg->thermtrip_enable_mask, 1);\r\nr = REG_SET_MASK(r, sg->thermtrip_any_en_mask, 0);\r\nwritel(r, ts->regs + THERMCTL_THERMTRIP_CTL);\r\nreturn 0;\r\n}\r\nstatic int throttrip_program(struct device *dev,\r\nconst struct tegra_tsensor_group *sg,\r\nstruct soctherm_throt_cfg *stc,\r\nint trip_temp)\r\n{\r\nstruct tegra_soctherm *ts = dev_get_drvdata(dev);\r\nint temp, cpu_throt, gpu_throt;\r\nunsigned int throt;\r\nu32 r, reg_off;\r\nif (!dev || !sg || !stc || !stc->init)\r\nreturn -EINVAL;\r\ntemp = enforce_temp_range(dev, trip_temp) / ts->soc->thresh_grain;\r\nthrot = stc->id;\r\nreg_off = THERMCTL_LVL_REG(sg->thermctl_lvl0_offset, throt + 1);\r\nif (throt == THROTTLE_LIGHT) {\r\ncpu_throt = THERMCTL_LVL0_CPU0_CPU_THROT_LIGHT;\r\ngpu_throt = THERMCTL_LVL0_CPU0_GPU_THROT_LIGHT;\r\n} else {\r\ncpu_throt = THERMCTL_LVL0_CPU0_CPU_THROT_HEAVY;\r\ngpu_throt = THERMCTL_LVL0_CPU0_GPU_THROT_HEAVY;\r\nif (throt != THROTTLE_HEAVY)\r\ndev_warn(dev,\r\n"invalid throt id %d - assuming HEAVY",\r\nthrot);\r\n}\r\nr = readl(ts->regs + reg_off);\r\nr = REG_SET_MASK(r, sg->thermctl_lvl0_up_thresh_mask, temp);\r\nr = REG_SET_MASK(r, sg->thermctl_lvl0_dn_thresh_mask, temp);\r\nr = REG_SET_MASK(r, THERMCTL_LVL0_CPU0_CPU_THROT_MASK, cpu_throt);\r\nr = REG_SET_MASK(r, THERMCTL_LVL0_CPU0_GPU_THROT_MASK, gpu_throt);\r\nr = REG_SET_MASK(r, THERMCTL_LVL0_CPU0_EN_MASK, 1);\r\nwritel(r, ts->regs + reg_off);\r\nreturn 0;\r\n}\r\nstatic struct soctherm_throt_cfg *\r\nfind_throttle_cfg_by_name(struct tegra_soctherm *ts, const char *name)\r\n{\r\nunsigned int i;\r\nfor (i = 0; ts->throt_cfgs[i].name; i++)\r\nif (!strcmp(ts->throt_cfgs[i].name, name))\r\nreturn &ts->throt_cfgs[i];\r\nreturn NULL;\r\n}\r\nstatic int get_hot_temp(struct thermal_zone_device *tz, int *trip, int *temp)\r\n{\r\nint ntrips, i, ret;\r\nenum thermal_trip_type type;\r\nntrips = of_thermal_get_ntrips(tz);\r\nif (ntrips <= 0)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ntrips; i++) {\r\nret = tz->ops->get_trip_type(tz, i, &type);\r\nif (ret)\r\nreturn -EINVAL;\r\nif (type == THERMAL_TRIP_HOT) {\r\nret = tz->ops->get_trip_temp(tz, i, temp);\r\nif (!ret)\r\n*trip = i;\r\nreturn ret;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int tegra_soctherm_set_hwtrips(struct device *dev,\r\nconst struct tegra_tsensor_group *sg,\r\nstruct thermal_zone_device *tz)\r\n{\r\nstruct tegra_soctherm *ts = dev_get_drvdata(dev);\r\nstruct soctherm_throt_cfg *stc;\r\nint i, trip, temperature;\r\nint ret;\r\nret = tz->ops->get_crit_temp(tz, &temperature);\r\nif (ret) {\r\ndev_warn(dev, "thermtrip: %s: missing critical temperature\n",\r\nsg->name);\r\ngoto set_throttle;\r\n}\r\nret = thermtrip_program(dev, sg, temperature);\r\nif (ret) {\r\ndev_err(dev, "thermtrip: %s: error during enable\n",\r\nsg->name);\r\nreturn ret;\r\n}\r\ndev_info(dev,\r\n"thermtrip: will shut down when %s reaches %d mC\n",\r\nsg->name, temperature);\r\nset_throttle:\r\nret = get_hot_temp(tz, &trip, &temperature);\r\nif (ret) {\r\ndev_warn(dev, "throttrip: %s: missing hot temperature\n",\r\nsg->name);\r\nreturn 0;\r\n}\r\nfor (i = 0; i < THROTTLE_SIZE; i++) {\r\nstruct thermal_cooling_device *cdev;\r\nif (!ts->throt_cfgs[i].init)\r\ncontinue;\r\ncdev = ts->throt_cfgs[i].cdev;\r\nif (get_thermal_instance(tz, cdev, trip))\r\nstc = find_throttle_cfg_by_name(ts, cdev->type);\r\nelse\r\ncontinue;\r\nret = throttrip_program(dev, sg, stc, temperature);\r\nif (ret) {\r\ndev_err(dev, "throttrip: %s: error during enable\n",\r\nsg->name);\r\nreturn ret;\r\n}\r\ndev_info(dev,\r\n"throttrip: will throttle when %s reaches %d mC\n",\r\nsg->name, temperature);\r\nbreak;\r\n}\r\nif (i == THROTTLE_SIZE)\r\ndev_warn(dev, "throttrip: %s: missing throttle cdev\n",\r\nsg->name);\r\nreturn 0;\r\n}\r\nstatic int regs_show(struct seq_file *s, void *data)\r\n{\r\nstruct platform_device *pdev = s->private;\r\nstruct tegra_soctherm *ts = platform_get_drvdata(pdev);\r\nconst struct tegra_tsensor *tsensors = ts->soc->tsensors;\r\nconst struct tegra_tsensor_group **ttgs = ts->soc->ttgs;\r\nu32 r, state;\r\nint i, level;\r\nseq_puts(s, "-----TSENSE (convert HW)-----\n");\r\nfor (i = 0; i < ts->soc->num_tsensors; i++) {\r\nr = readl(ts->regs + tsensors[i].base + SENSOR_CONFIG1);\r\nstate = REG_GET_MASK(r, SENSOR_CONFIG1_TEMP_ENABLE);\r\nseq_printf(s, "%s: ", tsensors[i].name);\r\nseq_printf(s, "En(%d) ", state);\r\nif (!state) {\r\nseq_puts(s, "\n");\r\ncontinue;\r\n}\r\nstate = REG_GET_MASK(r, SENSOR_CONFIG1_TIDDQ_EN_MASK);\r\nseq_printf(s, "tiddq(%d) ", state);\r\nstate = REG_GET_MASK(r, SENSOR_CONFIG1_TEN_COUNT_MASK);\r\nseq_printf(s, "ten_count(%d) ", state);\r\nstate = REG_GET_MASK(r, SENSOR_CONFIG1_TSAMPLE_MASK);\r\nseq_printf(s, "tsample(%d) ", state + 1);\r\nr = readl(ts->regs + tsensors[i].base + SENSOR_STATUS1);\r\nstate = REG_GET_MASK(r, SENSOR_STATUS1_TEMP_VALID_MASK);\r\nseq_printf(s, "Temp(%d/", state);\r\nstate = REG_GET_MASK(r, SENSOR_STATUS1_TEMP_MASK);\r\nseq_printf(s, "%d) ", translate_temp(state));\r\nr = readl(ts->regs + tsensors[i].base + SENSOR_STATUS0);\r\nstate = REG_GET_MASK(r, SENSOR_STATUS0_VALID_MASK);\r\nseq_printf(s, "Capture(%d/", state);\r\nstate = REG_GET_MASK(r, SENSOR_STATUS0_CAPTURE_MASK);\r\nseq_printf(s, "%d) ", state);\r\nr = readl(ts->regs + tsensors[i].base + SENSOR_CONFIG0);\r\nstate = REG_GET_MASK(r, SENSOR_CONFIG0_STOP);\r\nseq_printf(s, "Stop(%d) ", state);\r\nstate = REG_GET_MASK(r, SENSOR_CONFIG0_TALL_MASK);\r\nseq_printf(s, "Tall(%d) ", state);\r\nstate = REG_GET_MASK(r, SENSOR_CONFIG0_TCALC_OVER);\r\nseq_printf(s, "Over(%d/", state);\r\nstate = REG_GET_MASK(r, SENSOR_CONFIG0_OVER);\r\nseq_printf(s, "%d/", state);\r\nstate = REG_GET_MASK(r, SENSOR_CONFIG0_CPTR_OVER);\r\nseq_printf(s, "%d) ", state);\r\nr = readl(ts->regs + tsensors[i].base + SENSOR_CONFIG2);\r\nstate = REG_GET_MASK(r, SENSOR_CONFIG2_THERMA_MASK);\r\nseq_printf(s, "Therm_A/B(%d/", state);\r\nstate = REG_GET_MASK(r, SENSOR_CONFIG2_THERMB_MASK);\r\nseq_printf(s, "%d)\n", (s16)state);\r\n}\r\nr = readl(ts->regs + SENSOR_PDIV);\r\nseq_printf(s, "PDIV: 0x%x\n", r);\r\nr = readl(ts->regs + SENSOR_HOTSPOT_OFF);\r\nseq_printf(s, "HOTSPOT: 0x%x\n", r);\r\nseq_puts(s, "\n");\r\nseq_puts(s, "-----SOC_THERM-----\n");\r\nr = readl(ts->regs + SENSOR_TEMP1);\r\nstate = REG_GET_MASK(r, SENSOR_TEMP1_CPU_TEMP_MASK);\r\nseq_printf(s, "Temperatures: CPU(%d) ", translate_temp(state));\r\nstate = REG_GET_MASK(r, SENSOR_TEMP1_GPU_TEMP_MASK);\r\nseq_printf(s, " GPU(%d) ", translate_temp(state));\r\nr = readl(ts->regs + SENSOR_TEMP2);\r\nstate = REG_GET_MASK(r, SENSOR_TEMP2_PLLX_TEMP_MASK);\r\nseq_printf(s, " PLLX(%d) ", translate_temp(state));\r\nstate = REG_GET_MASK(r, SENSOR_TEMP2_MEM_TEMP_MASK);\r\nseq_printf(s, " MEM(%d)\n", translate_temp(state));\r\nfor (i = 0; i < ts->soc->num_ttgs; i++) {\r\nseq_printf(s, "%s:\n", ttgs[i]->name);\r\nfor (level = 0; level < 4; level++) {\r\ns32 v;\r\nu32 mask;\r\nu16 off = ttgs[i]->thermctl_lvl0_offset;\r\nr = readl(ts->regs + THERMCTL_LVL_REG(off, level));\r\nmask = ttgs[i]->thermctl_lvl0_up_thresh_mask;\r\nstate = REG_GET_MASK(r, mask);\r\nv = sign_extend32(state, ts->soc->bptt - 1);\r\nv *= ts->soc->thresh_grain;\r\nseq_printf(s, " %d: Up/Dn(%d /", level, v);\r\nmask = ttgs[i]->thermctl_lvl0_dn_thresh_mask;\r\nstate = REG_GET_MASK(r, mask);\r\nv = sign_extend32(state, ts->soc->bptt - 1);\r\nv *= ts->soc->thresh_grain;\r\nseq_printf(s, "%d ) ", v);\r\nmask = THERMCTL_LVL0_CPU0_EN_MASK;\r\nstate = REG_GET_MASK(r, mask);\r\nseq_printf(s, "En(%d) ", state);\r\nmask = THERMCTL_LVL0_CPU0_CPU_THROT_MASK;\r\nstate = REG_GET_MASK(r, mask);\r\nseq_puts(s, "CPU Throt");\r\nif (!state)\r\nseq_printf(s, "(%s) ", "none");\r\nelse if (state == THERMCTL_LVL0_CPU0_CPU_THROT_LIGHT)\r\nseq_printf(s, "(%s) ", "L");\r\nelse if (state == THERMCTL_LVL0_CPU0_CPU_THROT_HEAVY)\r\nseq_printf(s, "(%s) ", "H");\r\nelse\r\nseq_printf(s, "(%s) ", "H+L");\r\nmask = THERMCTL_LVL0_CPU0_GPU_THROT_MASK;\r\nstate = REG_GET_MASK(r, mask);\r\nseq_puts(s, "GPU Throt");\r\nif (!state)\r\nseq_printf(s, "(%s) ", "none");\r\nelse if (state == THERMCTL_LVL0_CPU0_GPU_THROT_LIGHT)\r\nseq_printf(s, "(%s) ", "L");\r\nelse if (state == THERMCTL_LVL0_CPU0_GPU_THROT_HEAVY)\r\nseq_printf(s, "(%s) ", "H");\r\nelse\r\nseq_printf(s, "(%s) ", "H+L");\r\nmask = THERMCTL_LVL0_CPU0_STATUS_MASK;\r\nstate = REG_GET_MASK(r, mask);\r\nseq_printf(s, "Status(%s)\n",\r\nstate == 0 ? "LO" :\r\nstate == 1 ? "In" :\r\nstate == 2 ? "Res" : "HI");\r\n}\r\n}\r\nr = readl(ts->regs + THERMCTL_STATS_CTL);\r\nseq_printf(s, "STATS: Up(%s) Dn(%s)\n",\r\nr & STATS_CTL_EN_UP ? "En" : "--",\r\nr & STATS_CTL_EN_DN ? "En" : "--");\r\nfor (level = 0; level < 4; level++) {\r\nu16 off;\r\noff = THERMCTL_LVL0_UP_STATS;\r\nr = readl(ts->regs + THERMCTL_LVL_REG(off, level));\r\nseq_printf(s, " Level_%d Up(%d) ", level, r);\r\noff = THERMCTL_LVL0_DN_STATS;\r\nr = readl(ts->regs + THERMCTL_LVL_REG(off, level));\r\nseq_printf(s, "Dn(%d)\n", r);\r\n}\r\nr = readl(ts->regs + THERMCTL_THERMTRIP_CTL);\r\nstate = REG_GET_MASK(r, ttgs[0]->thermtrip_any_en_mask);\r\nseq_printf(s, "Thermtrip Any En(%d)\n", state);\r\nfor (i = 0; i < ts->soc->num_ttgs; i++) {\r\nstate = REG_GET_MASK(r, ttgs[i]->thermtrip_enable_mask);\r\nseq_printf(s, " %s En(%d) ", ttgs[i]->name, state);\r\nstate = REG_GET_MASK(r, ttgs[i]->thermtrip_threshold_mask);\r\nstate *= ts->soc->thresh_grain;\r\nseq_printf(s, "Thresh(%d)\n", state);\r\n}\r\nr = readl(ts->regs + THROT_GLOBAL_CFG);\r\nseq_puts(s, "\n");\r\nseq_printf(s, "GLOBAL THROTTLE CONFIG: 0x%08x\n", r);\r\nseq_puts(s, "---------------------------------------------------\n");\r\nr = readl(ts->regs + THROT_STATUS);\r\nstate = REG_GET_MASK(r, THROT_STATUS_BREACH_MASK);\r\nseq_printf(s, "THROT STATUS: breach(%d) ", state);\r\nstate = REG_GET_MASK(r, THROT_STATUS_STATE_MASK);\r\nseq_printf(s, "state(%d) ", state);\r\nstate = REG_GET_MASK(r, THROT_STATUS_ENABLED_MASK);\r\nseq_printf(s, "enabled(%d)\n", state);\r\nr = readl(ts->regs + CPU_PSKIP_STATUS);\r\nif (ts->soc->use_ccroc) {\r\nstate = REG_GET_MASK(r, XPU_PSKIP_STATUS_ENABLED_MASK);\r\nseq_printf(s, "CPU PSKIP STATUS: enabled(%d)\n", state);\r\n} else {\r\nstate = REG_GET_MASK(r, XPU_PSKIP_STATUS_M_MASK);\r\nseq_printf(s, "CPU PSKIP STATUS: M(%d) ", state);\r\nstate = REG_GET_MASK(r, XPU_PSKIP_STATUS_N_MASK);\r\nseq_printf(s, "N(%d) ", state);\r\nstate = REG_GET_MASK(r, XPU_PSKIP_STATUS_ENABLED_MASK);\r\nseq_printf(s, "enabled(%d)\n", state);\r\n}\r\nreturn 0;\r\n}\r\nstatic int regs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, regs_show, inode->i_private);\r\n}\r\nstatic void soctherm_debug_init(struct platform_device *pdev)\r\n{\r\nstruct tegra_soctherm *tegra = platform_get_drvdata(pdev);\r\nstruct dentry *root, *file;\r\nroot = debugfs_create_dir("soctherm", NULL);\r\nif (!root) {\r\ndev_err(&pdev->dev, "failed to create debugfs directory\n");\r\nreturn;\r\n}\r\ntegra->debugfs_dir = root;\r\nfile = debugfs_create_file("reg_contents", 0644, root,\r\npdev, &regs_fops);\r\nif (!file) {\r\ndev_err(&pdev->dev, "failed to create debugfs file\n");\r\ndebugfs_remove_recursive(tegra->debugfs_dir);\r\ntegra->debugfs_dir = NULL;\r\n}\r\n}\r\nstatic inline void soctherm_debug_init(struct platform_device *pdev) {}\r\nstatic int soctherm_clk_enable(struct platform_device *pdev, bool enable)\r\n{\r\nstruct tegra_soctherm *tegra = platform_get_drvdata(pdev);\r\nint err;\r\nif (!tegra->clock_soctherm || !tegra->clock_tsensor)\r\nreturn -EINVAL;\r\nreset_control_assert(tegra->reset);\r\nif (enable) {\r\nerr = clk_prepare_enable(tegra->clock_soctherm);\r\nif (err) {\r\nreset_control_deassert(tegra->reset);\r\nreturn err;\r\n}\r\nerr = clk_prepare_enable(tegra->clock_tsensor);\r\nif (err) {\r\nclk_disable_unprepare(tegra->clock_soctherm);\r\nreset_control_deassert(tegra->reset);\r\nreturn err;\r\n}\r\n} else {\r\nclk_disable_unprepare(tegra->clock_tsensor);\r\nclk_disable_unprepare(tegra->clock_soctherm);\r\n}\r\nreset_control_deassert(tegra->reset);\r\nreturn 0;\r\n}\r\nstatic int throt_get_cdev_max_state(struct thermal_cooling_device *cdev,\r\nunsigned long *max_state)\r\n{\r\n*max_state = 1;\r\nreturn 0;\r\n}\r\nstatic int throt_get_cdev_cur_state(struct thermal_cooling_device *cdev,\r\nunsigned long *cur_state)\r\n{\r\nstruct tegra_soctherm *ts = cdev->devdata;\r\nu32 r;\r\nr = readl(ts->regs + THROT_STATUS);\r\nif (REG_GET_MASK(r, THROT_STATUS_STATE_MASK))\r\n*cur_state = 1;\r\nelse\r\n*cur_state = 0;\r\nreturn 0;\r\n}\r\nstatic int throt_set_cdev_state(struct thermal_cooling_device *cdev,\r\nunsigned long cur_state)\r\n{\r\nreturn 0;\r\n}\r\nstatic void soctherm_init_hw_throt_cdev(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct tegra_soctherm *ts = dev_get_drvdata(dev);\r\nstruct device_node *np_stc, *np_stcc;\r\nconst char *name;\r\nu32 val;\r\nint i, r;\r\nfor (i = 0; i < THROTTLE_SIZE; i++) {\r\nts->throt_cfgs[i].name = throt_names[i];\r\nts->throt_cfgs[i].id = i;\r\nts->throt_cfgs[i].init = false;\r\n}\r\nnp_stc = of_get_child_by_name(dev->of_node, "throttle-cfgs");\r\nif (!np_stc) {\r\ndev_info(dev,\r\n"throttle-cfg: no throttle-cfgs - not enabling\n");\r\nreturn;\r\n}\r\nfor_each_child_of_node(np_stc, np_stcc) {\r\nstruct soctherm_throt_cfg *stc;\r\nstruct thermal_cooling_device *tcd;\r\nname = np_stcc->name;\r\nstc = find_throttle_cfg_by_name(ts, name);\r\nif (!stc) {\r\ndev_err(dev,\r\n"throttle-cfg: could not find %s\n", name);\r\ncontinue;\r\n}\r\nr = of_property_read_u32(np_stcc, "nvidia,priority", &val);\r\nif (r) {\r\ndev_info(dev,\r\n"throttle-cfg: %s: missing priority\n", name);\r\ncontinue;\r\n}\r\nstc->priority = val;\r\nif (ts->soc->use_ccroc) {\r\nr = of_property_read_u32(np_stcc,\r\n"nvidia,cpu-throt-level",\r\n&val);\r\nif (r) {\r\ndev_info(dev,\r\n"throttle-cfg: %s: missing cpu-throt-level\n",\r\nname);\r\ncontinue;\r\n}\r\nstc->cpu_throt_level = val;\r\n} else {\r\nr = of_property_read_u32(np_stcc,\r\n"nvidia,cpu-throt-percent",\r\n&val);\r\nif (r) {\r\ndev_info(dev,\r\n"throttle-cfg: %s: missing cpu-throt-percent\n",\r\nname);\r\ncontinue;\r\n}\r\nstc->cpu_throt_depth = val;\r\n}\r\ntcd = thermal_of_cooling_device_register(np_stcc,\r\n(char *)name, ts,\r\n&throt_cooling_ops);\r\nof_node_put(np_stcc);\r\nif (IS_ERR_OR_NULL(tcd)) {\r\ndev_err(dev,\r\n"throttle-cfg: %s: failed to register cooling device\n",\r\nname);\r\ncontinue;\r\n}\r\nstc->cdev = tcd;\r\nstc->init = true;\r\n}\r\nof_node_put(np_stc);\r\n}\r\nstatic void throttlectl_cpu_level_cfg(struct tegra_soctherm *ts, int level)\r\n{\r\nu8 depth, dividend;\r\nu32 r;\r\nswitch (level) {\r\ncase TEGRA_SOCTHERM_THROT_LEVEL_LOW:\r\ndepth = 50;\r\nbreak;\r\ncase TEGRA_SOCTHERM_THROT_LEVEL_MED:\r\ndepth = 75;\r\nbreak;\r\ncase TEGRA_SOCTHERM_THROT_LEVEL_HIGH:\r\ndepth = 80;\r\nbreak;\r\ncase TEGRA_SOCTHERM_THROT_LEVEL_NONE:\r\nreturn;\r\ndefault:\r\nreturn;\r\n}\r\ndividend = THROT_DEPTH_DIVIDEND(depth);\r\nr = ccroc_readl(ts, CCROC_THROT_PSKIP_RAMP_CPU_REG(level));\r\nr = REG_SET_MASK(r, CCROC_THROT_PSKIP_RAMP_DURATION_MASK, 0xff);\r\nr = REG_SET_MASK(r, CCROC_THROT_PSKIP_RAMP_STEP_MASK, 0xf);\r\nccroc_writel(ts, r, CCROC_THROT_PSKIP_RAMP_CPU_REG(level));\r\nr = ccroc_readl(ts, CCROC_THROT_PSKIP_CTRL_CPU_REG(level));\r\nr = REG_SET_MASK(r, CCROC_THROT_PSKIP_CTRL_ENB_MASK, 1);\r\nr = REG_SET_MASK(r, CCROC_THROT_PSKIP_CTRL_DIVIDEND_MASK, dividend);\r\nr = REG_SET_MASK(r, CCROC_THROT_PSKIP_CTRL_DIVISOR_MASK, 0xff);\r\nccroc_writel(ts, r, CCROC_THROT_PSKIP_CTRL_CPU_REG(level));\r\n}\r\nstatic void throttlectl_cpu_level_select(struct tegra_soctherm *ts,\r\nenum soctherm_throttle_id throt)\r\n{\r\nu32 r, throt_vect;\r\nswitch (ts->throt_cfgs[throt].cpu_throt_level) {\r\ncase TEGRA_SOCTHERM_THROT_LEVEL_LOW:\r\nthrot_vect = THROT_VECT_LOW;\r\nbreak;\r\ncase TEGRA_SOCTHERM_THROT_LEVEL_MED:\r\nthrot_vect = THROT_VECT_MED;\r\nbreak;\r\ncase TEGRA_SOCTHERM_THROT_LEVEL_HIGH:\r\nthrot_vect = THROT_VECT_HIGH;\r\nbreak;\r\ndefault:\r\nthrot_vect = THROT_VECT_NONE;\r\nbreak;\r\n}\r\nr = readl(ts->regs + THROT_PSKIP_CTRL(throt, THROTTLE_DEV_CPU));\r\nr = REG_SET_MASK(r, THROT_PSKIP_CTRL_ENABLE_MASK, 1);\r\nr = REG_SET_MASK(r, THROT_PSKIP_CTRL_VECT_CPU_MASK, throt_vect);\r\nr = REG_SET_MASK(r, THROT_PSKIP_CTRL_VECT2_CPU_MASK, throt_vect);\r\nwritel(r, ts->regs + THROT_PSKIP_CTRL(throt, THROTTLE_DEV_CPU));\r\nr = REG_SET_MASK(0, THROT_PSKIP_RAMP_SEQ_BYPASS_MODE_MASK, 1);\r\nwritel(r, ts->regs + THROT_PSKIP_RAMP(throt, THROTTLE_DEV_CPU));\r\n}\r\nstatic void throttlectl_cpu_mn(struct tegra_soctherm *ts,\r\nenum soctherm_throttle_id throt)\r\n{\r\nu32 r;\r\nint depth;\r\nu8 dividend;\r\ndepth = ts->throt_cfgs[throt].cpu_throt_depth;\r\ndividend = THROT_DEPTH_DIVIDEND(depth);\r\nr = readl(ts->regs + THROT_PSKIP_CTRL(throt, THROTTLE_DEV_CPU));\r\nr = REG_SET_MASK(r, THROT_PSKIP_CTRL_ENABLE_MASK, 1);\r\nr = REG_SET_MASK(r, THROT_PSKIP_CTRL_DIVIDEND_MASK, dividend);\r\nr = REG_SET_MASK(r, THROT_PSKIP_CTRL_DIVISOR_MASK, 0xff);\r\nwritel(r, ts->regs + THROT_PSKIP_CTRL(throt, THROTTLE_DEV_CPU));\r\nr = readl(ts->regs + THROT_PSKIP_RAMP(throt, THROTTLE_DEV_CPU));\r\nr = REG_SET_MASK(r, THROT_PSKIP_RAMP_DURATION_MASK, 0xff);\r\nr = REG_SET_MASK(r, THROT_PSKIP_RAMP_STEP_MASK, 0xf);\r\nwritel(r, ts->regs + THROT_PSKIP_RAMP(throt, THROTTLE_DEV_CPU));\r\n}\r\nstatic void soctherm_throttle_program(struct tegra_soctherm *ts,\r\nenum soctherm_throttle_id throt)\r\n{\r\nu32 r;\r\nstruct soctherm_throt_cfg stc = ts->throt_cfgs[throt];\r\nif (!stc.init)\r\nreturn;\r\nif (ts->soc->use_ccroc)\r\nthrottlectl_cpu_level_select(ts, throt);\r\nelse\r\nthrottlectl_cpu_mn(ts, throt);\r\nr = REG_SET_MASK(0, THROT_PRIORITY_LITE_PRIO_MASK, stc.priority);\r\nwritel(r, ts->regs + THROT_PRIORITY_CTRL(throt));\r\nr = REG_SET_MASK(0, THROT_DELAY_LITE_DELAY_MASK, 0);\r\nwritel(r, ts->regs + THROT_DELAY_CTRL(throt));\r\nr = readl(ts->regs + THROT_PRIORITY_LOCK);\r\nr = REG_GET_MASK(r, THROT_PRIORITY_LOCK_PRIORITY_MASK);\r\nif (r >= stc.priority)\r\nreturn;\r\nr = REG_SET_MASK(0, THROT_PRIORITY_LOCK_PRIORITY_MASK,\r\nstc.priority);\r\nwritel(r, ts->regs + THROT_PRIORITY_LOCK);\r\n}\r\nstatic void tegra_soctherm_throttle(struct device *dev)\r\n{\r\nstruct tegra_soctherm *ts = dev_get_drvdata(dev);\r\nu32 v;\r\nint i;\r\nif (ts->soc->use_ccroc) {\r\nthrottlectl_cpu_level_cfg(ts, TEGRA_SOCTHERM_THROT_LEVEL_LOW);\r\nthrottlectl_cpu_level_cfg(ts, TEGRA_SOCTHERM_THROT_LEVEL_MED);\r\nthrottlectl_cpu_level_cfg(ts, TEGRA_SOCTHERM_THROT_LEVEL_HIGH);\r\n}\r\nfor (i = 0; i < THROTTLE_SIZE; i++)\r\nsoctherm_throttle_program(ts, i);\r\nv = REG_SET_MASK(0, THROT_GLOBAL_ENB_MASK, 1);\r\nif (ts->soc->use_ccroc) {\r\nccroc_writel(ts, v, CCROC_GLOBAL_CFG);\r\nv = ccroc_readl(ts, CCROC_SUPER_CCLKG_DIVIDER);\r\nv = REG_SET_MASK(v, CDIVG_USE_THERM_CONTROLS_MASK, 1);\r\nccroc_writel(ts, v, CCROC_SUPER_CCLKG_DIVIDER);\r\n} else {\r\nwritel(v, ts->regs + THROT_GLOBAL_CFG);\r\nv = clk_readl(ts, CAR_SUPER_CCLKG_DIVIDER);\r\nv = REG_SET_MASK(v, CDIVG_USE_THERM_CONTROLS_MASK, 1);\r\nclk_writel(ts, v, CAR_SUPER_CCLKG_DIVIDER);\r\n}\r\nv = STATS_CTL_CLR_DN | STATS_CTL_EN_DN |\r\nSTATS_CTL_CLR_UP | STATS_CTL_EN_UP;\r\nwritel(v, ts->regs + THERMCTL_STATS_CTL);\r\n}\r\nstatic void soctherm_init(struct platform_device *pdev)\r\n{\r\nstruct tegra_soctherm *tegra = platform_get_drvdata(pdev);\r\nconst struct tegra_tsensor_group **ttgs = tegra->soc->ttgs;\r\nint i;\r\nu32 pdiv, hotspot;\r\nfor (i = 0; i < tegra->soc->num_tsensors; ++i)\r\nenable_tsensor(tegra, i);\r\npdiv = readl(tegra->regs + SENSOR_PDIV);\r\nhotspot = readl(tegra->regs + SENSOR_HOTSPOT_OFF);\r\nfor (i = 0; i < tegra->soc->num_ttgs; ++i) {\r\npdiv = REG_SET_MASK(pdiv, ttgs[i]->pdiv_mask,\r\nttgs[i]->pdiv);\r\nif (ttgs[i]->id == TEGRA124_SOCTHERM_SENSOR_PLLX)\r\ncontinue;\r\nhotspot = REG_SET_MASK(hotspot,\r\nttgs[i]->pllx_hotspot_mask,\r\nttgs[i]->pllx_hotspot_diff);\r\n}\r\nwritel(pdiv, tegra->regs + SENSOR_PDIV);\r\nwritel(hotspot, tegra->regs + SENSOR_HOTSPOT_OFF);\r\ntegra_soctherm_throttle(&pdev->dev);\r\n}\r\nstatic int tegra_soctherm_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct tegra_soctherm *tegra;\r\nstruct thermal_zone_device *z;\r\nstruct tsensor_shared_calib shared_calib;\r\nstruct resource *res;\r\nstruct tegra_soctherm_soc *soc;\r\nunsigned int i;\r\nint err;\r\nmatch = of_match_node(tegra_soctherm_of_match, pdev->dev.of_node);\r\nif (!match)\r\nreturn -ENODEV;\r\nsoc = (struct tegra_soctherm_soc *)match->data;\r\nif (soc->num_ttgs > TEGRA124_SOCTHERM_SENSOR_NUM)\r\nreturn -EINVAL;\r\ntegra = devm_kzalloc(&pdev->dev, sizeof(*tegra), GFP_KERNEL);\r\nif (!tegra)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(&pdev->dev, tegra);\r\ntegra->soc = soc;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"soctherm-reg");\r\ntegra->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(tegra->regs)) {\r\ndev_err(&pdev->dev, "can't get soctherm registers");\r\nreturn PTR_ERR(tegra->regs);\r\n}\r\nif (!tegra->soc->use_ccroc) {\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"car-reg");\r\ntegra->clk_regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(tegra->clk_regs)) {\r\ndev_err(&pdev->dev, "can't get car clk registers");\r\nreturn PTR_ERR(tegra->clk_regs);\r\n}\r\n} else {\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"ccroc-reg");\r\ntegra->ccroc_regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(tegra->ccroc_regs)) {\r\ndev_err(&pdev->dev, "can't get ccroc registers");\r\nreturn PTR_ERR(tegra->ccroc_regs);\r\n}\r\n}\r\ntegra->reset = devm_reset_control_get(&pdev->dev, "soctherm");\r\nif (IS_ERR(tegra->reset)) {\r\ndev_err(&pdev->dev, "can't get soctherm reset\n");\r\nreturn PTR_ERR(tegra->reset);\r\n}\r\ntegra->clock_tsensor = devm_clk_get(&pdev->dev, "tsensor");\r\nif (IS_ERR(tegra->clock_tsensor)) {\r\ndev_err(&pdev->dev, "can't get tsensor clock\n");\r\nreturn PTR_ERR(tegra->clock_tsensor);\r\n}\r\ntegra->clock_soctherm = devm_clk_get(&pdev->dev, "soctherm");\r\nif (IS_ERR(tegra->clock_soctherm)) {\r\ndev_err(&pdev->dev, "can't get soctherm clock\n");\r\nreturn PTR_ERR(tegra->clock_soctherm);\r\n}\r\ntegra->calib = devm_kzalloc(&pdev->dev,\r\nsizeof(u32) * soc->num_tsensors,\r\nGFP_KERNEL);\r\nif (!tegra->calib)\r\nreturn -ENOMEM;\r\nerr = tegra_calc_shared_calib(soc->tfuse, &shared_calib);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < soc->num_tsensors; ++i) {\r\nerr = tegra_calc_tsensor_calib(&soc->tsensors[i],\r\n&shared_calib,\r\n&tegra->calib[i]);\r\nif (err)\r\nreturn err;\r\n}\r\ntegra->thermctl_tzs = devm_kzalloc(&pdev->dev,\r\nsizeof(*z) * soc->num_ttgs,\r\nGFP_KERNEL);\r\nif (!tegra->thermctl_tzs)\r\nreturn -ENOMEM;\r\nerr = soctherm_clk_enable(pdev, true);\r\nif (err)\r\nreturn err;\r\nsoctherm_init_hw_throt_cdev(pdev);\r\nsoctherm_init(pdev);\r\nfor (i = 0; i < soc->num_ttgs; ++i) {\r\nstruct tegra_thermctl_zone *zone =\r\ndevm_kzalloc(&pdev->dev, sizeof(*zone), GFP_KERNEL);\r\nif (!zone) {\r\nerr = -ENOMEM;\r\ngoto disable_clocks;\r\n}\r\nzone->reg = tegra->regs + soc->ttgs[i]->sensor_temp_offset;\r\nzone->dev = &pdev->dev;\r\nzone->sg = soc->ttgs[i];\r\nzone->ts = tegra;\r\nz = devm_thermal_zone_of_sensor_register(&pdev->dev,\r\nsoc->ttgs[i]->id, zone,\r\n&tegra_of_thermal_ops);\r\nif (IS_ERR(z)) {\r\nerr = PTR_ERR(z);\r\ndev_err(&pdev->dev, "failed to register sensor: %d\n",\r\nerr);\r\ngoto disable_clocks;\r\n}\r\nzone->tz = z;\r\ntegra->thermctl_tzs[soc->ttgs[i]->id] = z;\r\nerr = tegra_soctherm_set_hwtrips(&pdev->dev, soc->ttgs[i], z);\r\nif (err)\r\ngoto disable_clocks;\r\n}\r\nsoctherm_debug_init(pdev);\r\nreturn 0;\r\ndisable_clocks:\r\nsoctherm_clk_enable(pdev, false);\r\nreturn err;\r\n}\r\nstatic int tegra_soctherm_remove(struct platform_device *pdev)\r\n{\r\nstruct tegra_soctherm *tegra = platform_get_drvdata(pdev);\r\ndebugfs_remove_recursive(tegra->debugfs_dir);\r\nsoctherm_clk_enable(pdev, false);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused soctherm_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nsoctherm_clk_enable(pdev, false);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused soctherm_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct tegra_soctherm *tegra = platform_get_drvdata(pdev);\r\nstruct tegra_soctherm_soc *soc = tegra->soc;\r\nint err, i;\r\nerr = soctherm_clk_enable(pdev, true);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"Resume failed: enable clocks failed\n");\r\nreturn err;\r\n}\r\nsoctherm_init(pdev);\r\nfor (i = 0; i < soc->num_ttgs; ++i) {\r\nstruct thermal_zone_device *tz;\r\ntz = tegra->thermctl_tzs[soc->ttgs[i]->id];\r\nerr = tegra_soctherm_set_hwtrips(dev, soc->ttgs[i], tz);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"Resume failed: set hwtrips failed\n");\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}
