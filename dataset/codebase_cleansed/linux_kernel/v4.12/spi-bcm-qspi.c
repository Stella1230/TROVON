static inline bool has_bspi(struct bcm_qspi *qspi)\r\n{\r\nreturn qspi->bspi_mode;\r\n}\r\nstatic inline u32 bcm_qspi_read(struct bcm_qspi *qspi, enum base_type type,\r\nunsigned int offset)\r\n{\r\nreturn bcm_qspi_readl(qspi->big_endian, qspi->base[type] + offset);\r\n}\r\nstatic inline void bcm_qspi_write(struct bcm_qspi *qspi, enum base_type type,\r\nunsigned int offset, unsigned int data)\r\n{\r\nbcm_qspi_writel(qspi->big_endian, data, qspi->base[type] + offset);\r\n}\r\nstatic int bcm_qspi_bspi_busy_poll(struct bcm_qspi *qspi)\r\n{\r\nint i;\r\nfor (i = 0; i < 1000; i++) {\r\nif (!(bcm_qspi_read(qspi, BSPI, BSPI_BUSY_STATUS) & 1))\r\nreturn 0;\r\nudelay(1);\r\n}\r\ndev_warn(&qspi->pdev->dev, "timeout waiting for !busy_status\n");\r\nreturn -EIO;\r\n}\r\nstatic inline bool bcm_qspi_bspi_ver_three(struct bcm_qspi *qspi)\r\n{\r\nif (qspi->bspi_maj_rev < 4)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void bcm_qspi_bspi_flush_prefetch_buffers(struct bcm_qspi *qspi)\r\n{\r\nbcm_qspi_bspi_busy_poll(qspi);\r\nbcm_qspi_write(qspi, BSPI, BSPI_B0_CTRL, 1);\r\nbcm_qspi_write(qspi, BSPI, BSPI_B1_CTRL, 1);\r\nbcm_qspi_write(qspi, BSPI, BSPI_B0_CTRL, 0);\r\nbcm_qspi_write(qspi, BSPI, BSPI_B1_CTRL, 0);\r\n}\r\nstatic int bcm_qspi_bspi_lr_is_fifo_empty(struct bcm_qspi *qspi)\r\n{\r\nreturn (bcm_qspi_read(qspi, BSPI, BSPI_RAF_STATUS) &\r\nBSPI_RAF_STATUS_FIFO_EMPTY_MASK);\r\n}\r\nstatic inline u32 bcm_qspi_bspi_lr_read_fifo(struct bcm_qspi *qspi)\r\n{\r\nu32 data = bcm_qspi_read(qspi, BSPI, BSPI_RAF_READ_DATA);\r\nif (bcm_qspi_bspi_ver_three(qspi))\r\ndata = le32_to_cpu(data);\r\nreturn data;\r\n}\r\nstatic inline void bcm_qspi_bspi_lr_start(struct bcm_qspi *qspi)\r\n{\r\nbcm_qspi_bspi_busy_poll(qspi);\r\nbcm_qspi_write(qspi, BSPI, BSPI_RAF_CTRL,\r\nBSPI_RAF_CTRL_START_MASK);\r\n}\r\nstatic inline void bcm_qspi_bspi_lr_clear(struct bcm_qspi *qspi)\r\n{\r\nbcm_qspi_write(qspi, BSPI, BSPI_RAF_CTRL,\r\nBSPI_RAF_CTRL_CLEAR_MASK);\r\nbcm_qspi_bspi_flush_prefetch_buffers(qspi);\r\n}\r\nstatic void bcm_qspi_bspi_lr_data_read(struct bcm_qspi *qspi)\r\n{\r\nu32 *buf = (u32 *)qspi->bspi_rf_msg->buf;\r\nu32 data = 0;\r\ndev_dbg(&qspi->pdev->dev, "xfer %p rx %p rxlen %d\n", qspi->bspi_rf_msg,\r\nqspi->bspi_rf_msg->buf, qspi->bspi_rf_msg_len);\r\nwhile (!bcm_qspi_bspi_lr_is_fifo_empty(qspi)) {\r\ndata = bcm_qspi_bspi_lr_read_fifo(qspi);\r\nif (likely(qspi->bspi_rf_msg_len >= 4) &&\r\nIS_ALIGNED((uintptr_t)buf, 4)) {\r\nbuf[qspi->bspi_rf_msg_idx++] = data;\r\nqspi->bspi_rf_msg_len -= 4;\r\n} else {\r\nu8 *cbuf = (u8 *)&buf[qspi->bspi_rf_msg_idx];\r\ndata = cpu_to_le32(data);\r\nwhile (qspi->bspi_rf_msg_len) {\r\n*cbuf++ = (u8)data;\r\ndata >>= 8;\r\nqspi->bspi_rf_msg_len--;\r\n}\r\n}\r\n}\r\n}\r\nstatic void bcm_qspi_bspi_set_xfer_params(struct bcm_qspi *qspi, u8 cmd_byte,\r\nint bpp, int bpc, int flex_mode)\r\n{\r\nbcm_qspi_write(qspi, BSPI, BSPI_FLEX_MODE_ENABLE, 0);\r\nbcm_qspi_write(qspi, BSPI, BSPI_BITS_PER_CYCLE, bpc);\r\nbcm_qspi_write(qspi, BSPI, BSPI_BITS_PER_PHASE, bpp);\r\nbcm_qspi_write(qspi, BSPI, BSPI_CMD_AND_MODE_BYTE, cmd_byte);\r\nbcm_qspi_write(qspi, BSPI, BSPI_FLEX_MODE_ENABLE, flex_mode);\r\n}\r\nstatic int bcm_qspi_bspi_set_flex_mode(struct bcm_qspi *qspi, int width,\r\nint addrlen, int hp)\r\n{\r\nint bpc = 0, bpp = 0;\r\nu8 command = SPINOR_OP_READ_FAST;\r\nint flex_mode = 1, rv = 0;\r\nbool spans_4byte = false;\r\ndev_dbg(&qspi->pdev->dev, "set flex mode w %x addrlen %x hp %d\n",\r\nwidth, addrlen, hp);\r\nif (addrlen == BSPI_ADDRLEN_4BYTES) {\r\nbpp = BSPI_BPP_ADDR_SELECT_MASK;\r\nspans_4byte = true;\r\n}\r\nbpp |= 8;\r\nswitch (width) {\r\ncase SPI_NBITS_SINGLE:\r\nif (addrlen == BSPI_ADDRLEN_3BYTES)\r\nflex_mode = 0;\r\nelse\r\ncommand = SPINOR_OP_READ_FAST_4B;\r\nbreak;\r\ncase SPI_NBITS_DUAL:\r\nbpc = 0x00000001;\r\nif (hp) {\r\nbpc |= 0x00010100;\r\nbpp = BSPI_BPP_MODE_SELECT_MASK;\r\ncommand = OPCODE_DIOR;\r\nif (spans_4byte)\r\ncommand = OPCODE_DIOR_4B;\r\n} else {\r\ncommand = SPINOR_OP_READ_1_1_2;\r\nif (spans_4byte)\r\ncommand = SPINOR_OP_READ_1_1_2_4B;\r\n}\r\nbreak;\r\ncase SPI_NBITS_QUAD:\r\nbpc = 0x00000002;\r\nif (hp) {\r\nbpc |= 0x00020200;\r\nbpp = 4;\r\nbpp |= BSPI_BPP_ADDR_SELECT_MASK;\r\ncommand = OPCODE_QIOR;\r\nif (spans_4byte)\r\ncommand = OPCODE_QIOR_4B;\r\n} else {\r\ncommand = SPINOR_OP_READ_1_1_4;\r\nif (spans_4byte)\r\ncommand = SPINOR_OP_READ_1_1_4_4B;\r\n}\r\nbreak;\r\ndefault:\r\nrv = -EINVAL;\r\nbreak;\r\n}\r\nif (rv == 0)\r\nbcm_qspi_bspi_set_xfer_params(qspi, command, bpp, bpc,\r\nflex_mode);\r\nreturn rv;\r\n}\r\nstatic int bcm_qspi_bspi_set_override(struct bcm_qspi *qspi, int width,\r\nint addrlen, int hp)\r\n{\r\nu32 data = bcm_qspi_read(qspi, BSPI, BSPI_STRAP_OVERRIDE_CTRL);\r\ndev_dbg(&qspi->pdev->dev, "set override mode w %x addrlen %x hp %d\n",\r\nwidth, addrlen, hp);\r\nswitch (width) {\r\ncase SPI_NBITS_SINGLE:\r\ndata &= ~(BSPI_STRAP_OVERRIDE_CTRL_DATA_QUAD |\r\nBSPI_STRAP_OVERRIDE_CTRL_DATA_DUAL);\r\nbreak;\r\ncase SPI_NBITS_QUAD:\r\ndata &= ~BSPI_STRAP_OVERRIDE_CTRL_DATA_DUAL;\r\ndata |= BSPI_STRAP_OVERRIDE_CTRL_DATA_QUAD;\r\nbreak;\r\ncase SPI_NBITS_DUAL:\r\ndata &= ~BSPI_STRAP_OVERRIDE_CTRL_DATA_QUAD;\r\ndata |= BSPI_STRAP_OVERRIDE_CTRL_DATA_DUAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (addrlen == BSPI_ADDRLEN_4BYTES)\r\ndata |= BSPI_STRAP_OVERRIDE_CTRL_ADDR_4BYTE;\r\nelse\r\ndata &= ~BSPI_STRAP_OVERRIDE_CTRL_ADDR_4BYTE;\r\ndata |= BSPI_STRAP_OVERRIDE_CTRL_OVERRIDE;\r\nbcm_qspi_write(qspi, BSPI, BSPI_STRAP_OVERRIDE_CTRL, data);\r\nbcm_qspi_bspi_set_xfer_params(qspi, SPINOR_OP_READ_FAST, 0, 0, 0);\r\nreturn 0;\r\n}\r\nstatic int bcm_qspi_bspi_set_mode(struct bcm_qspi *qspi,\r\nint width, int addrlen, int hp)\r\n{\r\nint error = 0;\r\nqspi->xfer_mode.flex_mode = true;\r\nif (!bcm_qspi_bspi_ver_three(qspi)) {\r\nu32 val, mask;\r\nval = bcm_qspi_read(qspi, BSPI, BSPI_STRAP_OVERRIDE_CTRL);\r\nmask = BSPI_STRAP_OVERRIDE_CTRL_OVERRIDE;\r\nif (val & mask || qspi->s3_strap_override_ctrl & mask) {\r\nqspi->xfer_mode.flex_mode = false;\r\nbcm_qspi_write(qspi, BSPI, BSPI_FLEX_MODE_ENABLE,\r\n0);\r\nif ((val | qspi->s3_strap_override_ctrl) &\r\nBSPI_STRAP_OVERRIDE_CTRL_DATA_DUAL)\r\nwidth = SPI_NBITS_DUAL;\r\nelse if ((val | qspi->s3_strap_override_ctrl) &\r\nBSPI_STRAP_OVERRIDE_CTRL_DATA_QUAD)\r\nwidth = SPI_NBITS_QUAD;\r\nerror = bcm_qspi_bspi_set_override(qspi, width, addrlen,\r\nhp);\r\n}\r\n}\r\nif (qspi->xfer_mode.flex_mode)\r\nerror = bcm_qspi_bspi_set_flex_mode(qspi, width, addrlen, hp);\r\nif (error) {\r\ndev_warn(&qspi->pdev->dev,\r\n"INVALID COMBINATION: width=%d addrlen=%d hp=%d\n",\r\nwidth, addrlen, hp);\r\n} else if (qspi->xfer_mode.width != width ||\r\nqspi->xfer_mode.addrlen != addrlen ||\r\nqspi->xfer_mode.hp != hp) {\r\nqspi->xfer_mode.width = width;\r\nqspi->xfer_mode.addrlen = addrlen;\r\nqspi->xfer_mode.hp = hp;\r\ndev_dbg(&qspi->pdev->dev,\r\n"cs:%d %d-lane output, %d-byte address%s\n",\r\nqspi->curr_cs,\r\nqspi->xfer_mode.width,\r\nqspi->xfer_mode.addrlen,\r\nqspi->xfer_mode.hp != -1 ? ", hp mode" : "");\r\n}\r\nreturn error;\r\n}\r\nstatic void bcm_qspi_enable_bspi(struct bcm_qspi *qspi)\r\n{\r\nif (!has_bspi(qspi) || (qspi->bspi_enabled))\r\nreturn;\r\nqspi->bspi_enabled = 1;\r\nif ((bcm_qspi_read(qspi, BSPI, BSPI_MAST_N_BOOT_CTRL) & 1) == 0)\r\nreturn;\r\nbcm_qspi_bspi_flush_prefetch_buffers(qspi);\r\nudelay(1);\r\nbcm_qspi_write(qspi, BSPI, BSPI_MAST_N_BOOT_CTRL, 0);\r\nudelay(1);\r\n}\r\nstatic void bcm_qspi_disable_bspi(struct bcm_qspi *qspi)\r\n{\r\nif (!has_bspi(qspi) || (!qspi->bspi_enabled))\r\nreturn;\r\nqspi->bspi_enabled = 0;\r\nif ((bcm_qspi_read(qspi, BSPI, BSPI_MAST_N_BOOT_CTRL) & 1))\r\nreturn;\r\nbcm_qspi_bspi_busy_poll(qspi);\r\nbcm_qspi_write(qspi, BSPI, BSPI_MAST_N_BOOT_CTRL, 1);\r\nudelay(1);\r\n}\r\nstatic void bcm_qspi_chip_select(struct bcm_qspi *qspi, int cs)\r\n{\r\nu32 data = 0;\r\nif (qspi->curr_cs == cs)\r\nreturn;\r\nif (qspi->base[CHIP_SELECT]) {\r\ndata = bcm_qspi_read(qspi, CHIP_SELECT, 0);\r\ndata = (data & ~0xff) | (1 << cs);\r\nbcm_qspi_write(qspi, CHIP_SELECT, 0, data);\r\nusleep_range(10, 20);\r\n}\r\nqspi->curr_cs = cs;\r\n}\r\nstatic void bcm_qspi_hw_set_parms(struct bcm_qspi *qspi,\r\nconst struct bcm_qspi_parms *xp)\r\n{\r\nu32 spcr, spbr = 0;\r\nif (xp->speed_hz)\r\nspbr = qspi->base_clk / (2 * xp->speed_hz);\r\nspcr = clamp_val(spbr, QSPI_SPBR_MIN, QSPI_SPBR_MAX);\r\nbcm_qspi_write(qspi, MSPI, MSPI_SPCR0_LSB, spcr);\r\nspcr = MSPI_MASTER_BIT;\r\nif (xp->bits_per_word != 16)\r\nspcr |= xp->bits_per_word << 2;\r\nspcr |= xp->mode & 3;\r\nbcm_qspi_write(qspi, MSPI, MSPI_SPCR0_MSB, spcr);\r\nqspi->last_parms = *xp;\r\n}\r\nstatic void bcm_qspi_update_parms(struct bcm_qspi *qspi,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *trans)\r\n{\r\nstruct bcm_qspi_parms xp;\r\nxp.speed_hz = trans->speed_hz;\r\nxp.bits_per_word = trans->bits_per_word;\r\nxp.mode = spi->mode;\r\nbcm_qspi_hw_set_parms(qspi, &xp);\r\n}\r\nstatic int bcm_qspi_setup(struct spi_device *spi)\r\n{\r\nstruct bcm_qspi_parms *xp;\r\nif (spi->bits_per_word > 16)\r\nreturn -EINVAL;\r\nxp = spi_get_ctldata(spi);\r\nif (!xp) {\r\nxp = kzalloc(sizeof(*xp), GFP_KERNEL);\r\nif (!xp)\r\nreturn -ENOMEM;\r\nspi_set_ctldata(spi, xp);\r\n}\r\nxp->speed_hz = spi->max_speed_hz;\r\nxp->mode = spi->mode;\r\nif (spi->bits_per_word)\r\nxp->bits_per_word = spi->bits_per_word;\r\nelse\r\nxp->bits_per_word = 8;\r\nreturn 0;\r\n}\r\nstatic bool bcm_qspi_mspi_transfer_is_last(struct bcm_qspi *qspi,\r\nstruct qspi_trans *qt)\r\n{\r\nif (qt->mspi_last_trans &&\r\nspi_transfer_is_last(qspi->master, qt->trans))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic int update_qspi_trans_byte_count(struct bcm_qspi *qspi,\r\nstruct qspi_trans *qt, int flags)\r\n{\r\nint ret = TRANS_STATUS_BREAK_NONE;\r\nif (qt->trans->bits_per_word <= 8)\r\nqt->byte++;\r\nelse\r\nqt->byte += 2;\r\nif (qt->byte >= qt->trans->len) {\r\nif (qt->trans->delay_usecs &&\r\n(flags & TRANS_STATUS_BREAK_DELAY))\r\nret |= TRANS_STATUS_BREAK_DELAY;\r\nif (qt->trans->cs_change &&\r\n(flags & TRANS_STATUS_BREAK_CS_CHANGE))\r\nret |= TRANS_STATUS_BREAK_CS_CHANGE;\r\nif (ret)\r\ngoto done;\r\ndev_dbg(&qspi->pdev->dev, "advance msg exit\n");\r\nif (bcm_qspi_mspi_transfer_is_last(qspi, qt))\r\nret = TRANS_STATUS_BREAK_EOM;\r\nelse\r\nret = TRANS_STATUS_BREAK_NO_BYTES;\r\nqt->trans = NULL;\r\n}\r\ndone:\r\ndev_dbg(&qspi->pdev->dev, "trans %p len %d byte %d ret %x\n",\r\nqt->trans, qt->trans ? qt->trans->len : 0, qt->byte, ret);\r\nreturn ret;\r\n}\r\nstatic inline u8 read_rxram_slot_u8(struct bcm_qspi *qspi, int slot)\r\n{\r\nu32 slot_offset = MSPI_RXRAM + (slot << 3) + 0x4;\r\nreturn bcm_qspi_read(qspi, MSPI, slot_offset) & 0xff;\r\n}\r\nstatic inline u16 read_rxram_slot_u16(struct bcm_qspi *qspi, int slot)\r\n{\r\nu32 reg_offset = MSPI_RXRAM;\r\nu32 lsb_offset = reg_offset + (slot << 3) + 0x4;\r\nu32 msb_offset = reg_offset + (slot << 3);\r\nreturn (bcm_qspi_read(qspi, MSPI, lsb_offset) & 0xff) |\r\n((bcm_qspi_read(qspi, MSPI, msb_offset) & 0xff) << 8);\r\n}\r\nstatic void read_from_hw(struct bcm_qspi *qspi, int slots)\r\n{\r\nstruct qspi_trans tp;\r\nint slot;\r\nbcm_qspi_disable_bspi(qspi);\r\nif (slots > MSPI_NUM_CDRAM) {\r\ndev_err(&qspi->pdev->dev, "%s: too many slots!\n", __func__);\r\nreturn;\r\n}\r\ntp = qspi->trans_pos;\r\nfor (slot = 0; slot < slots; slot++) {\r\nif (tp.trans->bits_per_word <= 8) {\r\nu8 *buf = tp.trans->rx_buf;\r\nif (buf)\r\nbuf[tp.byte] = read_rxram_slot_u8(qspi, slot);\r\ndev_dbg(&qspi->pdev->dev, "RD %02x\n",\r\nbuf ? buf[tp.byte] : 0xff);\r\n} else {\r\nu16 *buf = tp.trans->rx_buf;\r\nif (buf)\r\nbuf[tp.byte / 2] = read_rxram_slot_u16(qspi,\r\nslot);\r\ndev_dbg(&qspi->pdev->dev, "RD %04x\n",\r\nbuf ? buf[tp.byte] : 0xffff);\r\n}\r\nupdate_qspi_trans_byte_count(qspi, &tp,\r\nTRANS_STATUS_BREAK_NONE);\r\n}\r\nqspi->trans_pos = tp;\r\n}\r\nstatic inline void write_txram_slot_u8(struct bcm_qspi *qspi, int slot,\r\nu8 val)\r\n{\r\nu32 reg_offset = MSPI_TXRAM + (slot << 3);\r\nbcm_qspi_write(qspi, MSPI, reg_offset, val);\r\n}\r\nstatic inline void write_txram_slot_u16(struct bcm_qspi *qspi, int slot,\r\nu16 val)\r\n{\r\nu32 reg_offset = MSPI_TXRAM;\r\nu32 msb_offset = reg_offset + (slot << 3);\r\nu32 lsb_offset = reg_offset + (slot << 3) + 0x4;\r\nbcm_qspi_write(qspi, MSPI, msb_offset, (val >> 8));\r\nbcm_qspi_write(qspi, MSPI, lsb_offset, (val & 0xff));\r\n}\r\nstatic inline u32 read_cdram_slot(struct bcm_qspi *qspi, int slot)\r\n{\r\nreturn bcm_qspi_read(qspi, MSPI, MSPI_CDRAM + (slot << 2));\r\n}\r\nstatic inline void write_cdram_slot(struct bcm_qspi *qspi, int slot, u32 val)\r\n{\r\nbcm_qspi_write(qspi, MSPI, (MSPI_CDRAM + (slot << 2)), val);\r\n}\r\nstatic int write_to_hw(struct bcm_qspi *qspi, struct spi_device *spi)\r\n{\r\nstruct qspi_trans tp;\r\nint slot = 0, tstatus = 0;\r\nu32 mspi_cdram = 0;\r\nbcm_qspi_disable_bspi(qspi);\r\ntp = qspi->trans_pos;\r\nbcm_qspi_update_parms(qspi, spi, tp.trans);\r\nwhile (!tstatus && slot < MSPI_NUM_CDRAM) {\r\nif (tp.trans->bits_per_word <= 8) {\r\nconst u8 *buf = tp.trans->tx_buf;\r\nu8 val = buf ? buf[tp.byte] : 0xff;\r\nwrite_txram_slot_u8(qspi, slot, val);\r\ndev_dbg(&qspi->pdev->dev, "WR %02x\n", val);\r\n} else {\r\nconst u16 *buf = tp.trans->tx_buf;\r\nu16 val = buf ? buf[tp.byte / 2] : 0xffff;\r\nwrite_txram_slot_u16(qspi, slot, val);\r\ndev_dbg(&qspi->pdev->dev, "WR %04x\n", val);\r\n}\r\nmspi_cdram = MSPI_CDRAM_CONT_BIT;\r\nmspi_cdram |= (~(1 << spi->chip_select) &\r\nMSPI_CDRAM_PCS);\r\nmspi_cdram |= ((tp.trans->bits_per_word <= 8) ? 0 :\r\nMSPI_CDRAM_BITSE_BIT);\r\nwrite_cdram_slot(qspi, slot, mspi_cdram);\r\ntstatus = update_qspi_trans_byte_count(qspi, &tp,\r\nTRANS_STATUS_BREAK_TX);\r\nslot++;\r\n}\r\nif (!slot) {\r\ndev_err(&qspi->pdev->dev, "%s: no data to send?", __func__);\r\ngoto done;\r\n}\r\ndev_dbg(&qspi->pdev->dev, "submitting %d slots\n", slot);\r\nbcm_qspi_write(qspi, MSPI, MSPI_NEWQP, 0);\r\nbcm_qspi_write(qspi, MSPI, MSPI_ENDQP, slot - 1);\r\nif (tstatus & TRANS_STATUS_BREAK_DESELECT) {\r\nmspi_cdram = read_cdram_slot(qspi, slot - 1) &\r\n~MSPI_CDRAM_CONT_BIT;\r\nwrite_cdram_slot(qspi, slot - 1, mspi_cdram);\r\n}\r\nif (has_bspi(qspi))\r\nbcm_qspi_write(qspi, MSPI, MSPI_WRITE_LOCK, 1);\r\nmb();\r\nbcm_qspi_write(qspi, MSPI, MSPI_SPCR2, 0xe0);\r\ndone:\r\nreturn slot;\r\n}\r\nstatic int bcm_qspi_bspi_flash_read(struct spi_device *spi,\r\nstruct spi_flash_read_message *msg)\r\n{\r\nstruct bcm_qspi *qspi = spi_master_get_devdata(spi->master);\r\nu32 addr = 0, len, rdlen, len_words;\r\nint ret = 0;\r\nunsigned long timeo = msecs_to_jiffies(100);\r\nstruct bcm_qspi_soc_intc *soc_intc = qspi->soc_intc;\r\nif (bcm_qspi_bspi_ver_three(qspi))\r\nif (msg->addr_width == BSPI_ADDRLEN_4BYTES)\r\nreturn -EIO;\r\nbcm_qspi_chip_select(qspi, spi->chip_select);\r\nbcm_qspi_write(qspi, MSPI, MSPI_WRITE_LOCK, 0);\r\nif (bcm_qspi_bspi_ver_three(qspi) == false) {\r\naddr = msg->from & 0xff000000;\r\nbcm_qspi_write(qspi, BSPI,\r\nBSPI_BSPI_FLASH_UPPER_ADDR_BYTE, addr);\r\n}\r\nif (!qspi->xfer_mode.flex_mode)\r\naddr = msg->from;\r\nelse\r\naddr = msg->from & 0x00ffffff;\r\nif (bcm_qspi_bspi_ver_three(qspi) == true)\r\naddr = (addr + 0xc00000) & 0xffffff;\r\nlen = msg->len;\r\nqspi->bspi_rf_msg_idx = 0;\r\ndo {\r\nif (len > BSPI_READ_LENGTH)\r\nrdlen = BSPI_READ_LENGTH;\r\nelse\r\nrdlen = len;\r\nreinit_completion(&qspi->bspi_done);\r\nbcm_qspi_enable_bspi(qspi);\r\nlen_words = (rdlen + 3) >> 2;\r\nqspi->bspi_rf_msg = msg;\r\nqspi->bspi_rf_msg_status = 0;\r\nqspi->bspi_rf_msg_len = rdlen;\r\ndev_dbg(&qspi->pdev->dev,\r\n"bspi xfr addr 0x%x len 0x%x", addr, rdlen);\r\nbcm_qspi_write(qspi, BSPI, BSPI_RAF_START_ADDR, addr);\r\nbcm_qspi_write(qspi, BSPI, BSPI_RAF_NUM_WORDS, len_words);\r\nbcm_qspi_write(qspi, BSPI, BSPI_RAF_WATERMARK, 0);\r\nif (qspi->soc_intc) {\r\nsoc_intc->bcm_qspi_int_ack(soc_intc, MSPI_BSPI_DONE);\r\nsoc_intc->bcm_qspi_int_set(soc_intc, BSPI_DONE, true);\r\n}\r\nmb();\r\nbcm_qspi_bspi_lr_start(qspi);\r\nif (!wait_for_completion_timeout(&qspi->bspi_done, timeo)) {\r\ndev_err(&qspi->pdev->dev, "timeout waiting for BSPI\n");\r\nret = -ETIMEDOUT;\r\nbreak;\r\n}\r\nmsg->retlen += rdlen;\r\naddr += rdlen;\r\nlen -= rdlen;\r\n} while (len);\r\nreturn ret;\r\n}\r\nstatic int bcm_qspi_transfer_one(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *trans)\r\n{\r\nstruct bcm_qspi *qspi = spi_master_get_devdata(master);\r\nint slots;\r\nunsigned long timeo = msecs_to_jiffies(100);\r\nbcm_qspi_chip_select(qspi, spi->chip_select);\r\nqspi->trans_pos.trans = trans;\r\nqspi->trans_pos.byte = 0;\r\nwhile (qspi->trans_pos.byte < trans->len) {\r\nreinit_completion(&qspi->mspi_done);\r\nslots = write_to_hw(qspi, spi);\r\nif (!wait_for_completion_timeout(&qspi->mspi_done, timeo)) {\r\ndev_err(&qspi->pdev->dev, "timeout waiting for MSPI\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nread_from_hw(qspi, slots);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm_qspi_mspi_flash_read(struct spi_device *spi,\r\nstruct spi_flash_read_message *msg)\r\n{\r\nstruct bcm_qspi *qspi = spi_master_get_devdata(spi->master);\r\nstruct spi_transfer t[2];\r\nu8 cmd[6];\r\nint ret;\r\nmemset(cmd, 0, sizeof(cmd));\r\nmemset(t, 0, sizeof(t));\r\ncmd[0] = msg->read_opcode;\r\ncmd[1] = msg->from >> (msg->addr_width * 8 - 8);\r\ncmd[2] = msg->from >> (msg->addr_width * 8 - 16);\r\ncmd[3] = msg->from >> (msg->addr_width * 8 - 24);\r\ncmd[4] = msg->from >> (msg->addr_width * 8 - 32);\r\nt[0].tx_buf = cmd;\r\nt[0].len = msg->addr_width + msg->dummy_bytes + 1;\r\nt[0].bits_per_word = spi->bits_per_word;\r\nt[0].tx_nbits = msg->opcode_nbits;\r\nqspi->trans_pos.mspi_last_trans = false;\r\nret = bcm_qspi_transfer_one(spi->master, spi, &t[0]);\r\nqspi->trans_pos.mspi_last_trans = true;\r\nif (!ret) {\r\nt[1].rx_buf = msg->buf;\r\nt[1].len = msg->len;\r\nt[1].rx_nbits = msg->data_nbits;\r\nt[1].bits_per_word = spi->bits_per_word;\r\nret = bcm_qspi_transfer_one(spi->master, spi, &t[1]);\r\n}\r\nif (!ret)\r\nmsg->retlen = msg->len;\r\nreturn ret;\r\n}\r\nstatic int bcm_qspi_flash_read(struct spi_device *spi,\r\nstruct spi_flash_read_message *msg)\r\n{\r\nstruct bcm_qspi *qspi = spi_master_get_devdata(spi->master);\r\nint ret = 0;\r\nbool mspi_read = false;\r\nu32 io_width, addrlen, addr, len;\r\nu_char *buf;\r\nbuf = msg->buf;\r\naddr = msg->from;\r\nlen = msg->len;\r\nif (bcm_qspi_bspi_ver_three(qspi) == true) {\r\naddr = (addr + 0xc00000) & 0xffffff;\r\nif ((~ADDR_4MB_MASK & addr) ^\r\n(~ADDR_4MB_MASK & (addr + len - 1)))\r\nmspi_read = true;\r\n}\r\nif (!IS_ALIGNED((uintptr_t)addr, 4) || !IS_ALIGNED((uintptr_t)buf, 4) ||\r\nlen < 4)\r\nmspi_read = true;\r\nif (mspi_read)\r\nreturn bcm_qspi_mspi_flash_read(spi, msg);\r\nio_width = msg->data_nbits ? msg->data_nbits : SPI_NBITS_SINGLE;\r\naddrlen = msg->addr_width;\r\nret = bcm_qspi_bspi_set_mode(qspi, io_width, addrlen, -1);\r\nif (!ret)\r\nret = bcm_qspi_bspi_flash_read(spi, msg);\r\nreturn ret;\r\n}\r\nstatic void bcm_qspi_cleanup(struct spi_device *spi)\r\n{\r\nstruct bcm_qspi_parms *xp = spi_get_ctldata(spi);\r\nkfree(xp);\r\n}\r\nstatic irqreturn_t bcm_qspi_mspi_l2_isr(int irq, void *dev_id)\r\n{\r\nstruct bcm_qspi_dev_id *qspi_dev_id = dev_id;\r\nstruct bcm_qspi *qspi = qspi_dev_id->dev;\r\nu32 status = bcm_qspi_read(qspi, MSPI, MSPI_MSPI_STATUS);\r\nif (status & MSPI_MSPI_STATUS_SPIF) {\r\nstruct bcm_qspi_soc_intc *soc_intc = qspi->soc_intc;\r\nstatus &= ~MSPI_MSPI_STATUS_SPIF;\r\nbcm_qspi_write(qspi, MSPI, MSPI_MSPI_STATUS, status);\r\nif (qspi->soc_intc)\r\nsoc_intc->bcm_qspi_int_ack(soc_intc, MSPI_DONE);\r\ncomplete(&qspi->mspi_done);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic irqreturn_t bcm_qspi_bspi_lr_l2_isr(int irq, void *dev_id)\r\n{\r\nstruct bcm_qspi_dev_id *qspi_dev_id = dev_id;\r\nstruct bcm_qspi *qspi = qspi_dev_id->dev;\r\nstruct bcm_qspi_soc_intc *soc_intc = qspi->soc_intc;\r\nu32 status = qspi_dev_id->irqp->mask;\r\nif (qspi->bspi_enabled && qspi->bspi_rf_msg) {\r\nbcm_qspi_bspi_lr_data_read(qspi);\r\nif (qspi->bspi_rf_msg_len == 0) {\r\nqspi->bspi_rf_msg = NULL;\r\nif (qspi->soc_intc) {\r\nsoc_intc->bcm_qspi_int_set(soc_intc, BSPI_DONE,\r\nfalse);\r\nstatus = INTR_BSPI_LR_SESSION_DONE_MASK;\r\n}\r\nif (qspi->bspi_rf_msg_status)\r\nbcm_qspi_bspi_lr_clear(qspi);\r\nelse\r\nbcm_qspi_bspi_flush_prefetch_buffers(qspi);\r\n}\r\nif (qspi->soc_intc)\r\nsoc_intc->bcm_qspi_int_ack(soc_intc, BSPI_DONE);\r\n}\r\nstatus &= INTR_BSPI_LR_SESSION_DONE_MASK;\r\nif (qspi->bspi_enabled && status && qspi->bspi_rf_msg_len == 0)\r\ncomplete(&qspi->bspi_done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t bcm_qspi_bspi_lr_err_l2_isr(int irq, void *dev_id)\r\n{\r\nstruct bcm_qspi_dev_id *qspi_dev_id = dev_id;\r\nstruct bcm_qspi *qspi = qspi_dev_id->dev;\r\nstruct bcm_qspi_soc_intc *soc_intc = qspi->soc_intc;\r\ndev_err(&qspi->pdev->dev, "BSPI INT error\n");\r\nqspi->bspi_rf_msg_status = -EIO;\r\nif (qspi->soc_intc)\r\nsoc_intc->bcm_qspi_int_ack(soc_intc, BSPI_ERR);\r\ncomplete(&qspi->bspi_done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t bcm_qspi_l1_isr(int irq, void *dev_id)\r\n{\r\nstruct bcm_qspi_dev_id *qspi_dev_id = dev_id;\r\nstruct bcm_qspi *qspi = qspi_dev_id->dev;\r\nstruct bcm_qspi_soc_intc *soc_intc = qspi->soc_intc;\r\nirqreturn_t ret = IRQ_NONE;\r\nif (soc_intc) {\r\nu32 status = soc_intc->bcm_qspi_get_int_status(soc_intc);\r\nif (status & MSPI_DONE)\r\nret = bcm_qspi_mspi_l2_isr(irq, dev_id);\r\nelse if (status & BSPI_DONE)\r\nret = bcm_qspi_bspi_lr_l2_isr(irq, dev_id);\r\nelse if (status & BSPI_ERR)\r\nret = bcm_qspi_bspi_lr_err_l2_isr(irq, dev_id);\r\n}\r\nreturn ret;\r\n}\r\nstatic void bcm_qspi_bspi_init(struct bcm_qspi *qspi)\r\n{\r\nu32 val = 0;\r\nval = bcm_qspi_read(qspi, BSPI, BSPI_REVISION_ID);\r\nqspi->bspi_maj_rev = (val >> 8) & 0xff;\r\nqspi->bspi_min_rev = val & 0xff;\r\nif (!(bcm_qspi_bspi_ver_three(qspi))) {\r\nbcm_qspi_write(qspi, BSPI, BSPI_BSPI_XOR_VALUE, 0);\r\nbcm_qspi_write(qspi, BSPI, BSPI_BSPI_XOR_ENABLE, 1);\r\n}\r\nqspi->bspi_enabled = 1;\r\nbcm_qspi_disable_bspi(qspi);\r\nbcm_qspi_write(qspi, BSPI, BSPI_B0_CTRL, 0);\r\nbcm_qspi_write(qspi, BSPI, BSPI_B1_CTRL, 0);\r\n}\r\nstatic void bcm_qspi_hw_init(struct bcm_qspi *qspi)\r\n{\r\nstruct bcm_qspi_parms parms;\r\nbcm_qspi_write(qspi, MSPI, MSPI_SPCR1_LSB, 0);\r\nbcm_qspi_write(qspi, MSPI, MSPI_SPCR1_MSB, 0);\r\nbcm_qspi_write(qspi, MSPI, MSPI_NEWQP, 0);\r\nbcm_qspi_write(qspi, MSPI, MSPI_ENDQP, 0);\r\nbcm_qspi_write(qspi, MSPI, MSPI_SPCR2, 0x20);\r\nparms.mode = SPI_MODE_3;\r\nparms.bits_per_word = 8;\r\nparms.speed_hz = qspi->max_speed_hz;\r\nbcm_qspi_hw_set_parms(qspi, &parms);\r\nif (has_bspi(qspi))\r\nbcm_qspi_bspi_init(qspi);\r\n}\r\nstatic void bcm_qspi_hw_uninit(struct bcm_qspi *qspi)\r\n{\r\nbcm_qspi_write(qspi, MSPI, MSPI_SPCR2, 0);\r\nif (has_bspi(qspi))\r\nbcm_qspi_write(qspi, MSPI, MSPI_WRITE_LOCK, 0);\r\n}\r\nint bcm_qspi_probe(struct platform_device *pdev,\r\nstruct bcm_qspi_soc_intc *soc_intc)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct bcm_qspi *qspi;\r\nstruct spi_master *master;\r\nstruct resource *res;\r\nint irq, ret = 0, num_ints = 0;\r\nu32 val;\r\nconst char *name = NULL;\r\nint num_irqs = ARRAY_SIZE(qspi_irq_tab);\r\nif (!dev->of_node)\r\nreturn -ENODEV;\r\nif (!of_match_node(bcm_qspi_of_match, dev->of_node))\r\nreturn -ENODEV;\r\nmaster = spi_alloc_master(dev, sizeof(struct bcm_qspi));\r\nif (!master) {\r\ndev_err(dev, "error allocating spi_master\n");\r\nreturn -ENOMEM;\r\n}\r\nqspi = spi_master_get_devdata(master);\r\nqspi->pdev = pdev;\r\nqspi->trans_pos.trans = NULL;\r\nqspi->trans_pos.byte = 0;\r\nqspi->trans_pos.mspi_last_trans = true;\r\nqspi->master = master;\r\nmaster->bus_num = -1;\r\nmaster->mode_bits = SPI_CPHA | SPI_CPOL | SPI_RX_DUAL | SPI_RX_QUAD;\r\nmaster->setup = bcm_qspi_setup;\r\nmaster->transfer_one = bcm_qspi_transfer_one;\r\nmaster->spi_flash_read = bcm_qspi_flash_read;\r\nmaster->cleanup = bcm_qspi_cleanup;\r\nmaster->dev.of_node = dev->of_node;\r\nmaster->num_chipselect = NUM_CHIPSELECT;\r\nqspi->big_endian = of_device_is_big_endian(dev->of_node);\r\nif (!of_property_read_u32(dev->of_node, "num-cs", &val))\r\nmaster->num_chipselect = val;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "hif_mspi");\r\nif (!res)\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"mspi");\r\nif (res) {\r\nqspi->base[MSPI] = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(qspi->base[MSPI])) {\r\nret = PTR_ERR(qspi->base[MSPI]);\r\ngoto qspi_probe_err;\r\n}\r\n} else {\r\ngoto qspi_probe_err;\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "bspi");\r\nif (res) {\r\nqspi->base[BSPI] = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(qspi->base[BSPI])) {\r\nret = PTR_ERR(qspi->base[BSPI]);\r\ngoto qspi_probe_err;\r\n}\r\nqspi->bspi_mode = true;\r\n} else {\r\nqspi->bspi_mode = false;\r\n}\r\ndev_info(dev, "using %smspi mode\n", qspi->bspi_mode ? "bspi-" : "");\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "cs_reg");\r\nif (res) {\r\nqspi->base[CHIP_SELECT] = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(qspi->base[CHIP_SELECT])) {\r\nret = PTR_ERR(qspi->base[CHIP_SELECT]);\r\ngoto qspi_probe_err;\r\n}\r\n}\r\nqspi->dev_ids = kcalloc(num_irqs, sizeof(struct bcm_qspi_dev_id),\r\nGFP_KERNEL);\r\nif (!qspi->dev_ids) {\r\nret = -ENOMEM;\r\ngoto qspi_probe_err;\r\n}\r\nfor (val = 0; val < num_irqs; val++) {\r\nirq = -1;\r\nname = qspi_irq_tab[val].irq_name;\r\nif (qspi_irq_tab[val].irq_source == SINGLE_L2) {\r\nirq = platform_get_irq_byname(pdev, name);\r\n} else if (!num_ints && soc_intc) {\r\nirq = platform_get_irq(pdev, 0);\r\n}\r\nif (irq >= 0) {\r\nret = devm_request_irq(&pdev->dev, irq,\r\nqspi_irq_tab[val].irq_handler, 0,\r\nname,\r\n&qspi->dev_ids[val]);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "IRQ %s not found\n", name);\r\ngoto qspi_probe_err;\r\n}\r\nqspi->dev_ids[val].dev = qspi;\r\nqspi->dev_ids[val].irqp = &qspi_irq_tab[val];\r\nnum_ints++;\r\ndev_dbg(&pdev->dev, "registered IRQ %s %d\n",\r\nqspi_irq_tab[val].irq_name,\r\nirq);\r\n}\r\n}\r\nif (!num_ints) {\r\ndev_err(&pdev->dev, "no IRQs registered, cannot init driver\n");\r\nret = -EINVAL;\r\ngoto qspi_probe_err;\r\n}\r\nif (soc_intc) {\r\nqspi->soc_intc = soc_intc;\r\nsoc_intc->bcm_qspi_int_set(soc_intc, MSPI_DONE, true);\r\n} else {\r\nqspi->soc_intc = NULL;\r\n}\r\nqspi->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(qspi->clk)) {\r\ndev_warn(dev, "unable to get clock\n");\r\nret = PTR_ERR(qspi->clk);\r\ngoto qspi_probe_err;\r\n}\r\nret = clk_prepare_enable(qspi->clk);\r\nif (ret) {\r\ndev_err(dev, "failed to prepare clock\n");\r\ngoto qspi_probe_err;\r\n}\r\nqspi->base_clk = clk_get_rate(qspi->clk);\r\nqspi->max_speed_hz = qspi->base_clk / (QSPI_SPBR_MIN * 2);\r\nbcm_qspi_hw_init(qspi);\r\ninit_completion(&qspi->mspi_done);\r\ninit_completion(&qspi->bspi_done);\r\nqspi->curr_cs = -1;\r\nplatform_set_drvdata(pdev, qspi);\r\nqspi->xfer_mode.width = -1;\r\nqspi->xfer_mode.addrlen = -1;\r\nqspi->xfer_mode.hp = -1;\r\nret = devm_spi_register_master(&pdev->dev, master);\r\nif (ret < 0) {\r\ndev_err(dev, "can't register master\n");\r\ngoto qspi_reg_err;\r\n}\r\nreturn 0;\r\nqspi_reg_err:\r\nbcm_qspi_hw_uninit(qspi);\r\nclk_disable_unprepare(qspi->clk);\r\nqspi_probe_err:\r\nspi_master_put(master);\r\nkfree(qspi->dev_ids);\r\nreturn ret;\r\n}\r\nint bcm_qspi_remove(struct platform_device *pdev)\r\n{\r\nstruct bcm_qspi *qspi = platform_get_drvdata(pdev);\r\nbcm_qspi_hw_uninit(qspi);\r\nclk_disable_unprepare(qspi->clk);\r\nkfree(qspi->dev_ids);\r\nspi_unregister_master(qspi->master);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused bcm_qspi_suspend(struct device *dev)\r\n{\r\nstruct bcm_qspi *qspi = dev_get_drvdata(dev);\r\nspi_master_suspend(qspi->master);\r\nclk_disable(qspi->clk);\r\nbcm_qspi_hw_uninit(qspi);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused bcm_qspi_resume(struct device *dev)\r\n{\r\nstruct bcm_qspi *qspi = dev_get_drvdata(dev);\r\nint ret = 0;\r\nbcm_qspi_hw_init(qspi);\r\nbcm_qspi_chip_select(qspi, qspi->curr_cs);\r\nif (qspi->soc_intc)\r\nqspi->soc_intc->bcm_qspi_int_set(qspi->soc_intc, MSPI_DONE,\r\ntrue);\r\nret = clk_enable(qspi->clk);\r\nif (!ret)\r\nspi_master_resume(qspi->master);\r\nreturn ret;\r\n}
