static int rtl8192cu_load_firmware(struct rtl8xxxu_priv *priv)\r\n{\r\nchar *fw_name;\r\nint ret;\r\nif (!priv->vendor_umc)\r\nfw_name = "rtlwifi/rtl8192cufw_TMSC.bin";\r\nelse if (priv->chip_cut || priv->rtl_chip == RTL8192C)\r\nfw_name = "rtlwifi/rtl8192cufw_B.bin";\r\nelse\r\nfw_name = "rtlwifi/rtl8192cufw_A.bin";\r\nret = rtl8xxxu_load_firmware(priv, fw_name);\r\nreturn ret;\r\n}\r\nstatic int rtl8192cu_parse_efuse(struct rtl8xxxu_priv *priv)\r\n{\r\nstruct rtl8192cu_efuse *efuse = &priv->efuse_wifi.efuse8192;\r\nint i;\r\nif (efuse->rtl_id != cpu_to_le16(0x8129))\r\nreturn -EINVAL;\r\nether_addr_copy(priv->mac_addr, efuse->mac_addr);\r\nmemcpy(priv->cck_tx_power_index_A,\r\nefuse->cck_tx_power_index_A,\r\nsizeof(efuse->cck_tx_power_index_A));\r\nmemcpy(priv->cck_tx_power_index_B,\r\nefuse->cck_tx_power_index_B,\r\nsizeof(efuse->cck_tx_power_index_B));\r\nmemcpy(priv->ht40_1s_tx_power_index_A,\r\nefuse->ht40_1s_tx_power_index_A,\r\nsizeof(efuse->ht40_1s_tx_power_index_A));\r\nmemcpy(priv->ht40_1s_tx_power_index_B,\r\nefuse->ht40_1s_tx_power_index_B,\r\nsizeof(efuse->ht40_1s_tx_power_index_B));\r\nmemcpy(priv->ht40_2s_tx_power_index_diff,\r\nefuse->ht40_2s_tx_power_index_diff,\r\nsizeof(efuse->ht40_2s_tx_power_index_diff));\r\nmemcpy(priv->ht20_tx_power_index_diff,\r\nefuse->ht20_tx_power_index_diff,\r\nsizeof(efuse->ht20_tx_power_index_diff));\r\nmemcpy(priv->ofdm_tx_power_index_diff,\r\nefuse->ofdm_tx_power_index_diff,\r\nsizeof(efuse->ofdm_tx_power_index_diff));\r\nmemcpy(priv->ht40_max_power_offset,\r\nefuse->ht40_max_power_offset,\r\nsizeof(efuse->ht40_max_power_offset));\r\nmemcpy(priv->ht20_max_power_offset,\r\nefuse->ht20_max_power_offset,\r\nsizeof(efuse->ht20_max_power_offset));\r\ndev_info(&priv->udev->dev, "Vendor: %.7s\n",\r\nefuse->vendor_name);\r\ndev_info(&priv->udev->dev, "Product: %.20s\n",\r\nefuse->device_name);\r\npriv->power_base = &rtl8192c_power_base;\r\nif (efuse->rf_regulatory & 0x20) {\r\nsprintf(priv->chip_name, "8188RU");\r\npriv->rtl_chip = RTL8188R;\r\npriv->hi_pa = 1;\r\npriv->no_pape = 1;\r\npriv->power_base = &rtl8188r_power_base;\r\n}\r\nif (rtl8xxxu_debug & RTL8XXXU_DEBUG_EFUSE) {\r\nunsigned char *raw = priv->efuse_wifi.raw;\r\ndev_info(&priv->udev->dev,\r\n"%s: dumping efuse (0x%02zx bytes):\n",\r\n__func__, sizeof(struct rtl8192cu_efuse));\r\nfor (i = 0; i < sizeof(struct rtl8192cu_efuse); i += 8)\r\ndev_info(&priv->udev->dev, "%02x: %8ph\n", i, &raw[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtl8192cu_init_phy_rf(struct rtl8xxxu_priv *priv)\r\n{\r\nstruct rtl8xxxu_rfregval *rftable;\r\nint ret;\r\nif (priv->rtl_chip == RTL8188R) {\r\nrftable = rtl8188ru_radioa_1t_highpa_table;\r\nret = rtl8xxxu_init_phy_rf(priv, rftable, RF_A);\r\n} else if (priv->rf_paths == 1) {\r\nrftable = rtl8192cu_radioa_1t_init_table;\r\nret = rtl8xxxu_init_phy_rf(priv, rftable, RF_A);\r\n} else {\r\nrftable = rtl8192cu_radioa_2t_init_table;\r\nret = rtl8xxxu_init_phy_rf(priv, rftable, RF_A);\r\nif (ret)\r\ngoto exit;\r\nrftable = rtl8192cu_radiob_2t_init_table;\r\nret = rtl8xxxu_init_phy_rf(priv, rftable, RF_B);\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int rtl8192cu_power_on(struct rtl8xxxu_priv *priv)\r\n{\r\nu8 val8;\r\nu16 val16;\r\nu32 val32;\r\nint i;\r\nfor (i = 100; i; i--) {\r\nval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO);\r\nif (val8 & APS_FSMCO_PFM_ALDN)\r\nbreak;\r\n}\r\nif (!i) {\r\npr_info("%s: Poll failed\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nrtl8xxxu_write8(priv, REG_RSV_CTRL, 0x0);\r\nrtl8xxxu_write8(priv, REG_SPS0_CTRL, 0x2b);\r\nudelay(100);\r\nval8 = rtl8xxxu_read8(priv, REG_LDOV12D_CTRL);\r\nif (!(val8 & LDOV12D_ENABLE)) {\r\npr_info("%s: Enabling LDOV12D (%02x)\n", __func__, val8);\r\nval8 |= LDOV12D_ENABLE;\r\nrtl8xxxu_write8(priv, REG_LDOV12D_CTRL, val8);\r\nudelay(100);\r\nval8 = rtl8xxxu_read8(priv, REG_SYS_ISO_CTRL);\r\nval8 &= ~SYS_ISO_MD2PP;\r\nrtl8xxxu_write8(priv, REG_SYS_ISO_CTRL, val8);\r\n}\r\nval16 = rtl8xxxu_read16(priv, REG_APS_FSMCO);\r\nval16 |= APS_FSMCO_MAC_ENABLE;\r\nrtl8xxxu_write16(priv, REG_APS_FSMCO, val16);\r\nfor (i = 1000; i; i--) {\r\nval16 = rtl8xxxu_read16(priv, REG_APS_FSMCO);\r\nif (!(val16 & APS_FSMCO_MAC_ENABLE))\r\nbreak;\r\n}\r\nif (!i) {\r\npr_info("%s: FSMCO_MAC_ENABLE poll failed\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nval16 = APS_FSMCO_HW_SUSPEND | APS_FSMCO_ENABLE_POWERDOWN |\r\nAPS_FSMCO_PFM_ALDN;\r\nrtl8xxxu_write16(priv, REG_APS_FSMCO, val16);\r\nval16 = rtl8xxxu_read16(priv, REG_SYS_ISO_CTRL);\r\nval16 &= ~SYS_ISO_DIOR;\r\nrtl8xxxu_write16(priv, REG_SYS_ISO_CTRL, val16);\r\nval8 = rtl8xxxu_read8(priv, REG_APSD_CTRL);\r\nval8 &= ~APSD_CTRL_OFF;\r\nrtl8xxxu_write8(priv, REG_APSD_CTRL, val8);\r\nfor (i = 200; i; i--) {\r\nval8 = rtl8xxxu_read8(priv, REG_APSD_CTRL);\r\nif (!(val8 & APSD_CTRL_OFF_STATUS))\r\nbreak;\r\n}\r\nif (!i) {\r\npr_info("%s: APSD_CTRL poll failed\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nval16 = rtl8xxxu_read16(priv, REG_CR);\r\nval16 |= CR_HCI_TXDMA_ENABLE | CR_HCI_RXDMA_ENABLE |\r\nCR_TXDMA_ENABLE | CR_RXDMA_ENABLE | CR_PROTOCOL_ENABLE |\r\nCR_SCHEDULE_ENABLE | CR_MAC_TX_ENABLE | CR_MAC_RX_ENABLE;\r\nrtl8xxxu_write16(priv, REG_CR, val16);\r\nrtl8xxxu_write8(priv, 0xfe10, 0x19);\r\nif (priv->rtl_chip == RTL8188R) {\r\nval32 = rtl8xxxu_read32(priv, REG_FPGA0_XCD_RF_PARM);\r\nval32 &= ~BIT(1);\r\nrtl8xxxu_write32(priv, REG_FPGA0_XCD_RF_PARM, val32);\r\n}\r\nreturn 0;\r\n}
