void arch_uprobe_copy_ixol(struct page *page, unsigned long vaddr,\r\nvoid *src, unsigned long len)\r\n{\r\nvoid *xol_page_kaddr = kmap_atomic(page);\r\nvoid *dst = xol_page_kaddr + (vaddr & ~PAGE_MASK);\r\nmemcpy(dst, src, len);\r\nsync_icache_aliases(dst, len);\r\nkunmap_atomic(xol_page_kaddr);\r\n}\r\nunsigned long uprobe_get_swbp_addr(struct pt_regs *regs)\r\n{\r\nreturn instruction_pointer(regs);\r\n}\r\nint arch_uprobe_analyze_insn(struct arch_uprobe *auprobe, struct mm_struct *mm,\r\nunsigned long addr)\r\n{\r\nprobe_opcode_t insn;\r\nif (test_bit(TIF_32BIT, &mm->context.flags))\r\nreturn -ENOTSUPP;\r\nelse if (!IS_ALIGNED(addr, AARCH64_INSN_SIZE))\r\nreturn -EINVAL;\r\ninsn = *(probe_opcode_t *)(&auprobe->insn[0]);\r\nswitch (arm_probe_decode_insn(insn, &auprobe->api)) {\r\ncase INSN_REJECTED:\r\nreturn -EINVAL;\r\ncase INSN_GOOD_NO_SLOT:\r\nauprobe->simulate = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint arch_uprobe_pre_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)\r\n{\r\nstruct uprobe_task *utask = current->utask;\r\ncurrent->thread.fault_code = UPROBE_INV_FAULT_CODE;\r\ninstruction_pointer_set(regs, utask->xol_vaddr);\r\nuser_enable_single_step(current);\r\nreturn 0;\r\n}\r\nint arch_uprobe_post_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)\r\n{\r\nstruct uprobe_task *utask = current->utask;\r\nWARN_ON_ONCE(current->thread.fault_code != UPROBE_INV_FAULT_CODE);\r\ninstruction_pointer_set(regs, utask->vaddr + 4);\r\nuser_disable_single_step(current);\r\nreturn 0;\r\n}\r\nbool arch_uprobe_xol_was_trapped(struct task_struct *t)\r\n{\r\nif (t->thread.fault_code != UPROBE_INV_FAULT_CODE)\r\nreturn true;\r\nreturn false;\r\n}\r\nbool arch_uprobe_skip_sstep(struct arch_uprobe *auprobe, struct pt_regs *regs)\r\n{\r\nprobe_opcode_t insn;\r\nunsigned long addr;\r\nif (!auprobe->simulate)\r\nreturn false;\r\ninsn = *(probe_opcode_t *)(&auprobe->insn[0]);\r\naddr = instruction_pointer(regs);\r\nif (auprobe->api.handler)\r\nauprobe->api.handler(insn, addr, regs);\r\nreturn true;\r\n}\r\nvoid arch_uprobe_abort_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)\r\n{\r\nstruct uprobe_task *utask = current->utask;\r\ninstruction_pointer_set(regs, utask->vaddr);\r\nuser_disable_single_step(current);\r\n}\r\nbool arch_uretprobe_is_alive(struct return_instance *ret, enum rp_check ctx,\r\nstruct pt_regs *regs)\r\n{\r\nif (ctx == RP_CHECK_CHAIN_CALL)\r\nreturn regs->sp <= ret->stack;\r\nelse\r\nreturn regs->sp < ret->stack;\r\n}\r\nunsigned long\r\narch_uretprobe_hijack_return_addr(unsigned long trampoline_vaddr,\r\nstruct pt_regs *regs)\r\n{\r\nunsigned long orig_ret_vaddr;\r\norig_ret_vaddr = procedure_link_pointer(regs);\r\nprocedure_link_pointer_set(regs, trampoline_vaddr);\r\nreturn orig_ret_vaddr;\r\n}\r\nint arch_uprobe_exception_notify(struct notifier_block *self,\r\nunsigned long val, void *data)\r\n{\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int uprobe_breakpoint_handler(struct pt_regs *regs,\r\nunsigned int esr)\r\n{\r\nif (user_mode(regs) && uprobe_pre_sstep_notifier(regs))\r\nreturn DBG_HOOK_HANDLED;\r\nreturn DBG_HOOK_ERROR;\r\n}\r\nstatic int uprobe_single_step_handler(struct pt_regs *regs,\r\nunsigned int esr)\r\n{\r\nstruct uprobe_task *utask = current->utask;\r\nif (user_mode(regs)) {\r\nWARN_ON(utask &&\r\n(instruction_pointer(regs) != utask->xol_vaddr + 4));\r\nif (uprobe_post_sstep_notifier(regs))\r\nreturn DBG_HOOK_HANDLED;\r\n}\r\nreturn DBG_HOOK_ERROR;\r\n}\r\nstatic int __init arch_init_uprobes(void)\r\n{\r\nregister_break_hook(&uprobes_break_hook);\r\nregister_step_hook(&uprobes_step_hook);\r\nreturn 0;\r\n}
