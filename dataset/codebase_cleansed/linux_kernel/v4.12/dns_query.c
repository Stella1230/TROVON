int dns_query(const char *type, const char *name, size_t namelen,\r\nconst char *options, char **_result, time64_t *_expiry)\r\n{\r\nstruct key *rkey;\r\nstruct user_key_payload *upayload;\r\nconst struct cred *saved_cred;\r\nsize_t typelen, desclen;\r\nchar *desc, *cp;\r\nint ret, len;\r\nkenter("%s,%*.*s,%zu,%s",\r\ntype, (int)namelen, (int)namelen, name, namelen, options);\r\nif (!name || namelen == 0 || !_result)\r\nreturn -EINVAL;\r\ntypelen = 0;\r\ndesclen = 0;\r\nif (type) {\r\ntypelen = strlen(type);\r\nif (typelen < 1)\r\nreturn -EINVAL;\r\ndesclen += typelen + 1;\r\n}\r\nif (!namelen)\r\nnamelen = strnlen(name, 256);\r\nif (namelen < 3 || namelen > 255)\r\nreturn -EINVAL;\r\ndesclen += namelen + 1;\r\ndesc = kmalloc(desclen, GFP_KERNEL);\r\nif (!desc)\r\nreturn -ENOMEM;\r\ncp = desc;\r\nif (type) {\r\nmemcpy(cp, type, typelen);\r\ncp += typelen;\r\n*cp++ = ':';\r\n}\r\nmemcpy(cp, name, namelen);\r\ncp += namelen;\r\n*cp = '\0';\r\nif (!options)\r\noptions = "";\r\nkdebug("call request_key(,%s,%s)", desc, options);\r\nsaved_cred = override_creds(dns_resolver_cache);\r\nrkey = request_key(&key_type_dns_resolver, desc, options);\r\nrevert_creds(saved_cred);\r\nkfree(desc);\r\nif (IS_ERR(rkey)) {\r\nret = PTR_ERR(rkey);\r\ngoto out;\r\n}\r\ndown_read(&rkey->sem);\r\nset_bit(KEY_FLAG_ROOT_CAN_INVAL, &rkey->flags);\r\nrkey->perm |= KEY_USR_VIEW;\r\nret = key_validate(rkey);\r\nif (ret < 0)\r\ngoto put;\r\nret = PTR_ERR(rkey->payload.data[dns_key_error]);\r\nif (ret)\r\ngoto put;\r\nupayload = user_key_payload_locked(rkey);\r\nlen = upayload->datalen;\r\nret = -ENOMEM;\r\n*_result = kmalloc(len + 1, GFP_KERNEL);\r\nif (!*_result)\r\ngoto put;\r\nmemcpy(*_result, upayload->data, len);\r\n(*_result)[len] = '\0';\r\nif (_expiry)\r\n*_expiry = rkey->expiry;\r\nret = len;\r\nput:\r\nup_read(&rkey->sem);\r\nkey_put(rkey);\r\nout:\r\nkleave(" = %d", ret);\r\nreturn ret;\r\n}
