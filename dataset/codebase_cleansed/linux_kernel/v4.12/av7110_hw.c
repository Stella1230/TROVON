int av7110_debiwrite(struct av7110 *av7110, u32 config,\r\nint addr, u32 val, unsigned int count)\r\n{\r\nstruct saa7146_dev *dev = av7110->dev;\r\nif (count > 32764) {\r\nprintk("%s: invalid count %d\n", __func__, count);\r\nreturn -1;\r\n}\r\nif (saa7146_wait_for_debi_done(av7110->dev, 0) < 0) {\r\nprintk("%s: wait_for_debi_done failed\n", __func__);\r\nreturn -1;\r\n}\r\nsaa7146_write(dev, DEBI_CONFIG, config);\r\nif (count <= 4)\r\nsaa7146_write(dev, DEBI_AD, val);\r\nelse\r\nsaa7146_write(dev, DEBI_AD, av7110->debi_bus);\r\nsaa7146_write(dev, DEBI_COMMAND, (count << 17) | (addr & 0xffff));\r\nsaa7146_write(dev, MC2, (2 << 16) | 2);\r\nreturn 0;\r\n}\r\nu32 av7110_debiread(struct av7110 *av7110, u32 config, int addr, unsigned int count)\r\n{\r\nstruct saa7146_dev *dev = av7110->dev;\r\nu32 result = 0;\r\nif (count > 32764) {\r\nprintk("%s: invalid count %d\n", __func__, count);\r\nreturn 0;\r\n}\r\nif (saa7146_wait_for_debi_done(av7110->dev, 0) < 0) {\r\nprintk("%s: wait_for_debi_done #1 failed\n", __func__);\r\nreturn 0;\r\n}\r\nsaa7146_write(dev, DEBI_AD, av7110->debi_bus);\r\nsaa7146_write(dev, DEBI_COMMAND, (count << 17) | 0x10000 | (addr & 0xffff));\r\nsaa7146_write(dev, DEBI_CONFIG, config);\r\nsaa7146_write(dev, MC2, (2 << 16) | 2);\r\nif (count > 4)\r\nreturn count;\r\nif (saa7146_wait_for_debi_done(av7110->dev, 0) < 0) {\r\nprintk("%s: wait_for_debi_done #2 failed\n", __func__);\r\nreturn 0;\r\n}\r\nresult = saa7146_read(dev, DEBI_AD);\r\nresult &= (0xffffffffUL >> ((4 - count) * 8));\r\nreturn result;\r\n}\r\nstatic int waitdebi(struct av7110 *av7110, int adr, int state)\r\n{\r\nint k;\r\ndprintk(4, "%p\n", av7110);\r\nfor (k = 0; k < 100; k++) {\r\nif (irdebi(av7110, DEBINOSWAP, adr, 0, 2) == state)\r\nreturn 0;\r\nudelay(5);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int load_dram(struct av7110 *av7110, u32 *data, int len)\r\n{\r\nint i;\r\nint blocks, rest;\r\nu32 base, bootblock = AV7110_BOOT_BLOCK;\r\ndprintk(4, "%p\n", av7110);\r\nblocks = len / AV7110_BOOT_MAX_SIZE;\r\nrest = len % AV7110_BOOT_MAX_SIZE;\r\nbase = DRAM_START_CODE;\r\nfor (i = 0; i < blocks; i++) {\r\nif (waitdebi(av7110, AV7110_BOOT_STATE, BOOTSTATE_BUFFER_EMPTY) < 0) {\r\nprintk(KERN_ERR "dvb-ttpci: load_dram(): timeout at block %d\n", i);\r\nreturn -ETIMEDOUT;\r\n}\r\ndprintk(4, "writing DRAM block %d\n", i);\r\nmwdebi(av7110, DEBISWAB, bootblock,\r\n((u8 *)data) + i * AV7110_BOOT_MAX_SIZE, AV7110_BOOT_MAX_SIZE);\r\nbootblock ^= 0x1400;\r\niwdebi(av7110, DEBISWAB, AV7110_BOOT_BASE, swab32(base), 4);\r\niwdebi(av7110, DEBINOSWAP, AV7110_BOOT_SIZE, AV7110_BOOT_MAX_SIZE, 2);\r\niwdebi(av7110, DEBINOSWAP, AV7110_BOOT_STATE, BOOTSTATE_BUFFER_FULL, 2);\r\nbase += AV7110_BOOT_MAX_SIZE;\r\n}\r\nif (rest > 0) {\r\nif (waitdebi(av7110, AV7110_BOOT_STATE, BOOTSTATE_BUFFER_EMPTY) < 0) {\r\nprintk(KERN_ERR "dvb-ttpci: load_dram(): timeout at last block\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nif (rest > 4)\r\nmwdebi(av7110, DEBISWAB, bootblock,\r\n((u8 *)data) + i * AV7110_BOOT_MAX_SIZE, rest);\r\nelse\r\nmwdebi(av7110, DEBISWAB, bootblock,\r\n((u8 *)data) + i * AV7110_BOOT_MAX_SIZE - 4, rest + 4);\r\niwdebi(av7110, DEBISWAB, AV7110_BOOT_BASE, swab32(base), 4);\r\niwdebi(av7110, DEBINOSWAP, AV7110_BOOT_SIZE, rest, 2);\r\niwdebi(av7110, DEBINOSWAP, AV7110_BOOT_STATE, BOOTSTATE_BUFFER_FULL, 2);\r\n}\r\nif (waitdebi(av7110, AV7110_BOOT_STATE, BOOTSTATE_BUFFER_EMPTY) < 0) {\r\nprintk(KERN_ERR "dvb-ttpci: load_dram(): timeout after last block\n");\r\nreturn -ETIMEDOUT;\r\n}\r\niwdebi(av7110, DEBINOSWAP, AV7110_BOOT_SIZE, 0, 2);\r\niwdebi(av7110, DEBINOSWAP, AV7110_BOOT_STATE, BOOTSTATE_BUFFER_FULL, 2);\r\nif (waitdebi(av7110, AV7110_BOOT_STATE, BOOTSTATE_AV7110_BOOT_COMPLETE) < 0) {\r\nprintk(KERN_ERR "dvb-ttpci: load_dram(): final handshake timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nint av7110_bootarm(struct av7110 *av7110)\r\n{\r\nconst struct firmware *fw;\r\nconst char *fw_name = "av7110/bootcode.bin";\r\nstruct saa7146_dev *dev = av7110->dev;\r\nu32 ret;\r\nint i;\r\ndprintk(4, "%p\n", av7110);\r\nav7110->arm_ready = 0;\r\nsaa7146_setgpio(dev, RESET_LINE, SAA7146_GPIO_OUTLO);\r\nSAA7146_IER_DISABLE(av7110->dev, MASK_03 | MASK_19);\r\nSAA7146_ISR_CLEAR(av7110->dev, MASK_19 | MASK_03);\r\nsaa7146_write(av7110->dev, MC1, 0x08800880);\r\nsaa7146_write(av7110->dev, DD1_STREAM_B, 0x00000000);\r\nsaa7146_write(av7110->dev, MC2, (MASK_09 | MASK_25 | MASK_10 | MASK_26));\r\niwdebi(av7110, DEBISWAP, DPRAM_BASE, 0x76543210, 4);\r\niwdebi(av7110, DEBISWAP, DPRAM_BASE, 0x76543210, 4);\r\nif ((ret=irdebi(av7110, DEBINOSWAP, DPRAM_BASE, 0, 4)) != 0x10325476) {\r\nprintk(KERN_ERR "dvb-ttpci: debi test in av7110_bootarm() failed: %08x != %08x (check your BIOS 'Plug&Play OS' settings)\n",\r\nret, 0x10325476);\r\nreturn -1;\r\n}\r\nfor (i = 0; i < 8192; i += 4)\r\niwdebi(av7110, DEBISWAP, DPRAM_BASE + i, 0x00, 4);\r\ndprintk(2, "debi test OK\n");\r\ndprintk(1, "load boot code\n");\r\nsaa7146_setgpio(dev, ARM_IRQ_LINE, SAA7146_GPIO_IRQLO);\r\nret = request_firmware(&fw, fw_name, &dev->pci->dev);\r\nif (ret) {\r\nprintk(KERN_ERR "dvb-ttpci: Failed to load firmware \"%s\"\n",\r\nfw_name);\r\nreturn ret;\r\n}\r\nmwdebi(av7110, DEBISWAB, DPRAM_BASE, fw->data, fw->size);\r\nrelease_firmware(fw);\r\niwdebi(av7110, DEBINOSWAP, AV7110_BOOT_STATE, BOOTSTATE_BUFFER_FULL, 2);\r\nif (saa7146_wait_for_debi_done(av7110->dev, 1)) {\r\nprintk(KERN_ERR "dvb-ttpci: av7110_bootarm(): saa7146_wait_for_debi_done() timed out\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nsaa7146_setgpio(dev, RESET_LINE, SAA7146_GPIO_OUTHI);\r\nmdelay(1);\r\ndprintk(1, "load dram code\n");\r\nif (load_dram(av7110, (u32 *)av7110->bin_root, av7110->size_root) < 0) {\r\nprintk(KERN_ERR "dvb-ttpci: av7110_bootarm(): load_dram() failed\n");\r\nreturn -1;\r\n}\r\nsaa7146_setgpio(dev, RESET_LINE, SAA7146_GPIO_OUTLO);\r\nmdelay(1);\r\ndprintk(1, "load dpram code\n");\r\nmwdebi(av7110, DEBISWAB, DPRAM_BASE, av7110->bin_dpram, av7110->size_dpram);\r\nif (saa7146_wait_for_debi_done(av7110->dev, 1)) {\r\nprintk(KERN_ERR "dvb-ttpci: av7110_bootarm(): saa7146_wait_for_debi_done() timed out after loading DRAM\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nsaa7146_setgpio(dev, RESET_LINE, SAA7146_GPIO_OUTHI);\r\nmsleep(30);\r\nARM_ResetMailBox(av7110);\r\nSAA7146_ISR_CLEAR(av7110->dev, MASK_19 | MASK_03);\r\nSAA7146_IER_ENABLE(av7110->dev, MASK_03);\r\nav7110->arm_errors = 0;\r\nav7110->arm_ready = 1;\r\nreturn 0;\r\n}\r\nint av7110_wait_msgstate(struct av7110 *av7110, u16 flags)\r\n{\r\nunsigned long start;\r\nu32 stat;\r\nint err;\r\nif (FW_VERSION(av7110->arm_app) <= 0x261c) {\r\nmsleep(50);\r\nreturn 0;\r\n}\r\nstart = jiffies;\r\nfor (;;) {\r\nerr = time_after(jiffies, start + ARM_WAIT_FREE);\r\nif (mutex_lock_interruptible(&av7110->dcomlock))\r\nreturn -ERESTARTSYS;\r\nstat = rdebi(av7110, DEBINOSWAP, MSGSTATE, 0, 2);\r\nmutex_unlock(&av7110->dcomlock);\r\nif ((stat & flags) == 0)\r\nbreak;\r\nif (err) {\r\nprintk(KERN_ERR "%s: timeout waiting for MSGSTATE %04x\n",\r\n__func__, stat & flags);\r\nreturn -ETIMEDOUT;\r\n}\r\nmsleep(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __av7110_send_fw_cmd(struct av7110 *av7110, u16* buf, int length)\r\n{\r\nint i;\r\nunsigned long start;\r\nchar *type = NULL;\r\nu16 flags[2] = {0, 0};\r\nu32 stat;\r\nint err;\r\nif (!av7110->arm_ready) {\r\ndprintk(1, "arm not ready.\n");\r\nreturn -ENXIO;\r\n}\r\nstart = jiffies;\r\nwhile (1) {\r\nerr = time_after(jiffies, start + ARM_WAIT_FREE);\r\nif (rdebi(av7110, DEBINOSWAP, COMMAND, 0, 2) == 0)\r\nbreak;\r\nif (err) {\r\nprintk(KERN_ERR "dvb-ttpci: %s(): timeout waiting for COMMAND idle\n", __func__);\r\nav7110->arm_errors++;\r\nreturn -ETIMEDOUT;\r\n}\r\nmsleep(1);\r\n}\r\nif (FW_VERSION(av7110->arm_app) <= 0x261f)\r\nwdebi(av7110, DEBINOSWAP, COM_IF_LOCK, 0xffff, 2);\r\n#ifndef _NOHANDSHAKE\r\nstart = jiffies;\r\nwhile (1) {\r\nerr = time_after(jiffies, start + ARM_WAIT_SHAKE);\r\nif (rdebi(av7110, DEBINOSWAP, HANDSHAKE_REG, 0, 2) == 0)\r\nbreak;\r\nif (err) {\r\nprintk(KERN_ERR "dvb-ttpci: %s(): timeout waiting for HANDSHAKE_REG\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nmsleep(1);\r\n}\r\n#endif\r\nswitch ((buf[0] >> 8) & 0xff) {\r\ncase COMTYPE_PIDFILTER:\r\ncase COMTYPE_ENCODER:\r\ncase COMTYPE_REC_PLAY:\r\ncase COMTYPE_MPEGDECODER:\r\ntype = "MSG";\r\nflags[0] = GPMQOver;\r\nflags[1] = GPMQFull;\r\nbreak;\r\ncase COMTYPE_OSD:\r\ntype = "OSD";\r\nflags[0] = OSDQOver;\r\nflags[1] = OSDQFull;\r\nbreak;\r\ncase COMTYPE_MISC:\r\nif (FW_VERSION(av7110->arm_app) >= 0x261d) {\r\ntype = "MSG";\r\nflags[0] = GPMQOver;\r\nflags[1] = GPMQBusy;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (type != NULL) {\r\nstart = jiffies;\r\nfor (;;) {\r\nerr = time_after(jiffies, start + ARM_WAIT_FREE);\r\nstat = rdebi(av7110, DEBINOSWAP, MSGSTATE, 0, 2);\r\nif (stat & flags[0]) {\r\nprintk(KERN_ERR "%s: %s QUEUE overflow\n",\r\n__func__, type);\r\nreturn -1;\r\n}\r\nif ((stat & flags[1]) == 0)\r\nbreak;\r\nif (err) {\r\nprintk(KERN_ERR "%s: timeout waiting on busy %s QUEUE\n",\r\n__func__, type);\r\nav7110->arm_errors++;\r\nreturn -ETIMEDOUT;\r\n}\r\nmsleep(1);\r\n}\r\n}\r\nfor (i = 2; i < length; i++)\r\nwdebi(av7110, DEBINOSWAP, COMMAND + 2 * i, (u32) buf[i], 2);\r\nif (length)\r\nwdebi(av7110, DEBINOSWAP, COMMAND + 2, (u32) buf[1], 2);\r\nelse\r\nwdebi(av7110, DEBINOSWAP, COMMAND + 2, 0, 2);\r\nwdebi(av7110, DEBINOSWAP, COMMAND, (u32) buf[0], 2);\r\nif (FW_VERSION(av7110->arm_app) <= 0x261f)\r\nwdebi(av7110, DEBINOSWAP, COM_IF_LOCK, 0x0000, 2);\r\n#ifdef COM_DEBUG\r\nstart = jiffies;\r\nwhile (1) {\r\nerr = time_after(jiffies, start + ARM_WAIT_FREE);\r\nif (rdebi(av7110, DEBINOSWAP, COMMAND, 0, 2) == 0)\r\nbreak;\r\nif (err) {\r\nprintk(KERN_ERR "dvb-ttpci: %s(): timeout waiting for COMMAND %d to complete\n",\r\n__func__, (buf[0] >> 8) & 0xff);\r\nreturn -ETIMEDOUT;\r\n}\r\nmsleep(1);\r\n}\r\nstat = rdebi(av7110, DEBINOSWAP, MSGSTATE, 0, 2);\r\nif (stat & GPMQOver) {\r\nprintk(KERN_ERR "dvb-ttpci: %s(): GPMQOver\n", __func__);\r\nreturn -ENOSPC;\r\n}\r\nelse if (stat & OSDQOver) {\r\nprintk(KERN_ERR "dvb-ttpci: %s(): OSDQOver\n", __func__);\r\nreturn -ENOSPC;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int av7110_send_fw_cmd(struct av7110 *av7110, u16* buf, int length)\r\n{\r\nint ret;\r\nif (!av7110->arm_ready) {\r\ndprintk(1, "arm not ready.\n");\r\nreturn -1;\r\n}\r\nif (mutex_lock_interruptible(&av7110->dcomlock))\r\nreturn -ERESTARTSYS;\r\nret = __av7110_send_fw_cmd(av7110, buf, length);\r\nmutex_unlock(&av7110->dcomlock);\r\nif (ret && ret!=-ERESTARTSYS)\r\nprintk(KERN_ERR "dvb-ttpci: %s(): av7110_send_fw_cmd error %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nint av7110_fw_cmd(struct av7110 *av7110, int type, int com, int num, ...)\r\n{\r\nva_list args;\r\nu16 buf[MAX_XFER_SIZE];\r\nint i, ret;\r\nif (2 + num > ARRAY_SIZE(buf)) {\r\nprintk(KERN_WARNING\r\n"%s: %s len=%d is too big!\n",\r\nKBUILD_MODNAME, __func__, num);\r\nreturn -EINVAL;\r\n}\r\nbuf[0] = ((type << 8) | com);\r\nbuf[1] = num;\r\nif (num) {\r\nva_start(args, num);\r\nfor (i = 0; i < num; i++)\r\nbuf[i + 2] = va_arg(args, u32);\r\nva_end(args);\r\n}\r\nret = av7110_send_fw_cmd(av7110, buf, num + 2);\r\nif (ret && ret != -ERESTARTSYS)\r\nprintk(KERN_ERR "dvb-ttpci: av7110_fw_cmd error %d\n", ret);\r\nreturn ret;\r\n}\r\nint av7110_fw_request(struct av7110 *av7110, u16 *request_buf,\r\nint request_buf_len, u16 *reply_buf, int reply_buf_len)\r\n{\r\nint err;\r\ns16 i;\r\nunsigned long start;\r\n#ifdef COM_DEBUG\r\nu32 stat;\r\n#endif\r\ndprintk(4, "%p\n", av7110);\r\nif (!av7110->arm_ready) {\r\ndprintk(1, "arm not ready.\n");\r\nreturn -1;\r\n}\r\nif (mutex_lock_interruptible(&av7110->dcomlock))\r\nreturn -ERESTARTSYS;\r\nif ((err = __av7110_send_fw_cmd(av7110, request_buf, request_buf_len)) < 0) {\r\nmutex_unlock(&av7110->dcomlock);\r\nprintk(KERN_ERR "dvb-ttpci: av7110_fw_request error %d\n", err);\r\nreturn err;\r\n}\r\nstart = jiffies;\r\nwhile (1) {\r\nerr = time_after(jiffies, start + ARM_WAIT_FREE);\r\nif (rdebi(av7110, DEBINOSWAP, COMMAND, 0, 2) == 0)\r\nbreak;\r\nif (err) {\r\nprintk(KERN_ERR "%s: timeout waiting for COMMAND to complete\n", __func__);\r\nmutex_unlock(&av7110->dcomlock);\r\nreturn -ETIMEDOUT;\r\n}\r\n#ifdef _NOHANDSHAKE\r\nmsleep(1);\r\n#endif\r\n}\r\n#ifndef _NOHANDSHAKE\r\nstart = jiffies;\r\nwhile (1) {\r\nerr = time_after(jiffies, start + ARM_WAIT_SHAKE);\r\nif (rdebi(av7110, DEBINOSWAP, HANDSHAKE_REG, 0, 2) == 0)\r\nbreak;\r\nif (err) {\r\nprintk(KERN_ERR "%s: timeout waiting for HANDSHAKE_REG\n", __func__);\r\nmutex_unlock(&av7110->dcomlock);\r\nreturn -ETIMEDOUT;\r\n}\r\nmsleep(1);\r\n}\r\n#endif\r\n#ifdef COM_DEBUG\r\nstat = rdebi(av7110, DEBINOSWAP, MSGSTATE, 0, 2);\r\nif (stat & GPMQOver) {\r\nprintk(KERN_ERR "%s: GPMQOver\n", __func__);\r\nmutex_unlock(&av7110->dcomlock);\r\nreturn -1;\r\n}\r\nelse if (stat & OSDQOver) {\r\nprintk(KERN_ERR "%s: OSDQOver\n", __func__);\r\nmutex_unlock(&av7110->dcomlock);\r\nreturn -1;\r\n}\r\n#endif\r\nfor (i = 0; i < reply_buf_len; i++)\r\nreply_buf[i] = rdebi(av7110, DEBINOSWAP, COM_BUFF + 2 * i, 0, 2);\r\nmutex_unlock(&av7110->dcomlock);\r\nreturn 0;\r\n}\r\nstatic int av7110_fw_query(struct av7110 *av7110, u16 tag, u16* buf, s16 length)\r\n{\r\nint ret;\r\nret = av7110_fw_request(av7110, &tag, 0, buf, length);\r\nif (ret)\r\nprintk(KERN_ERR "dvb-ttpci: av7110_fw_query error %d\n", ret);\r\nreturn ret;\r\n}\r\nint av7110_firmversion(struct av7110 *av7110)\r\n{\r\nu16 buf[20];\r\nu16 tag = ((COMTYPE_REQUEST << 8) + ReqVersion);\r\ndprintk(4, "%p\n", av7110);\r\nif (av7110_fw_query(av7110, tag, buf, 16)) {\r\nprintk("dvb-ttpci: failed to boot firmware @ card %d\n",\r\nav7110->dvb_adapter.num);\r\nreturn -EIO;\r\n}\r\nav7110->arm_fw = (buf[0] << 16) + buf[1];\r\nav7110->arm_rtsl = (buf[2] << 16) + buf[3];\r\nav7110->arm_vid = (buf[4] << 16) + buf[5];\r\nav7110->arm_app = (buf[6] << 16) + buf[7];\r\nav7110->avtype = (buf[8] << 16) + buf[9];\r\nprintk("dvb-ttpci: info @ card %d: firm %08x, rtsl %08x, vid %08x, app %08x\n",\r\nav7110->dvb_adapter.num, av7110->arm_fw,\r\nav7110->arm_rtsl, av7110->arm_vid, av7110->arm_app);\r\nif (FW_CI_LL_SUPPORT(av7110->arm_app))\r\nprintk("dvb-ttpci: firmware @ card %d supports CI link layer interface\n",\r\nav7110->dvb_adapter.num);\r\nelse\r\nprintk("dvb-ttpci: no firmware support for CI link layer interface @ card %d\n",\r\nav7110->dvb_adapter.num);\r\nreturn 0;\r\n}\r\nint av7110_diseqc_send(struct av7110 *av7110, int len, u8 *msg, unsigned long burst)\r\n{\r\nint i, ret;\r\nu16 buf[18] = { ((COMTYPE_AUDIODAC << 8) + SendDiSEqC),\r\n16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\r\ndprintk(4, "%p\n", av7110);\r\nif (len > 10)\r\nlen = 10;\r\nbuf[1] = len + 2;\r\nbuf[2] = len;\r\nif (burst != -1)\r\nbuf[3] = burst ? 0x01 : 0x00;\r\nelse\r\nbuf[3] = 0xffff;\r\nfor (i = 0; i < len; i++)\r\nbuf[i + 4] = msg[i];\r\nret = av7110_send_fw_cmd(av7110, buf, 18);\r\nif (ret && ret!=-ERESTARTSYS)\r\nprintk(KERN_ERR "dvb-ttpci: av7110_diseqc_send error %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic inline int SetColorBlend(struct av7110 *av7110, u8 windownr)\r\n{\r\nreturn av7110_fw_cmd(av7110, COMTYPE_OSD, SetCBlend, 1, windownr);\r\n}\r\nstatic inline int SetBlend_(struct av7110 *av7110, u8 windownr,\r\nenum av7110_osd_palette_type colordepth, u16 index, u8 blending)\r\n{\r\nreturn av7110_fw_cmd(av7110, COMTYPE_OSD, SetBlend, 4,\r\nwindownr, colordepth, index, blending);\r\n}\r\nstatic inline int SetColor_(struct av7110 *av7110, u8 windownr,\r\nenum av7110_osd_palette_type colordepth, u16 index, u16 colorhi, u16 colorlo)\r\n{\r\nreturn av7110_fw_cmd(av7110, COMTYPE_OSD, SetColor, 5,\r\nwindownr, colordepth, index, colorhi, colorlo);\r\n}\r\nstatic inline int SetFont(struct av7110 *av7110, u8 windownr, u8 fontsize,\r\nu16 colorfg, u16 colorbg)\r\n{\r\nreturn av7110_fw_cmd(av7110, COMTYPE_OSD, Set_Font, 4,\r\nwindownr, fontsize, colorfg, colorbg);\r\n}\r\nstatic int FlushText(struct av7110 *av7110)\r\n{\r\nunsigned long start;\r\nint err;\r\nif (mutex_lock_interruptible(&av7110->dcomlock))\r\nreturn -ERESTARTSYS;\r\nstart = jiffies;\r\nwhile (1) {\r\nerr = time_after(jiffies, start + ARM_WAIT_OSD);\r\nif (rdebi(av7110, DEBINOSWAP, BUFF1_BASE, 0, 2) == 0)\r\nbreak;\r\nif (err) {\r\nprintk(KERN_ERR "dvb-ttpci: %s(): timeout waiting for BUFF1_BASE == 0\n",\r\n__func__);\r\nmutex_unlock(&av7110->dcomlock);\r\nreturn -ETIMEDOUT;\r\n}\r\nmsleep(1);\r\n}\r\nmutex_unlock(&av7110->dcomlock);\r\nreturn 0;\r\n}\r\nstatic int WriteText(struct av7110 *av7110, u8 win, u16 x, u16 y, char *buf)\r\n{\r\nint i, ret;\r\nunsigned long start;\r\nint length = strlen(buf) + 1;\r\nu16 cbuf[5] = { (COMTYPE_OSD << 8) + DText, 3, win, x, y };\r\nif (mutex_lock_interruptible(&av7110->dcomlock))\r\nreturn -ERESTARTSYS;\r\nstart = jiffies;\r\nwhile (1) {\r\nret = time_after(jiffies, start + ARM_WAIT_OSD);\r\nif (rdebi(av7110, DEBINOSWAP, BUFF1_BASE, 0, 2) == 0)\r\nbreak;\r\nif (ret) {\r\nprintk(KERN_ERR "dvb-ttpci: %s: timeout waiting for BUFF1_BASE == 0\n",\r\n__func__);\r\nmutex_unlock(&av7110->dcomlock);\r\nreturn -ETIMEDOUT;\r\n}\r\nmsleep(1);\r\n}\r\n#ifndef _NOHANDSHAKE\r\nstart = jiffies;\r\nwhile (1) {\r\nret = time_after(jiffies, start + ARM_WAIT_SHAKE);\r\nif (rdebi(av7110, DEBINOSWAP, HANDSHAKE_REG, 0, 2) == 0)\r\nbreak;\r\nif (ret) {\r\nprintk(KERN_ERR "dvb-ttpci: %s: timeout waiting for HANDSHAKE_REG\n",\r\n__func__);\r\nmutex_unlock(&av7110->dcomlock);\r\nreturn -ETIMEDOUT;\r\n}\r\nmsleep(1);\r\n}\r\n#endif\r\nfor (i = 0; i < length / 2; i++)\r\nwdebi(av7110, DEBINOSWAP, BUFF1_BASE + i * 2,\r\nswab16(*(u16 *)(buf + 2 * i)), 2);\r\nif (length & 1)\r\nwdebi(av7110, DEBINOSWAP, BUFF1_BASE + i * 2, 0, 2);\r\nret = __av7110_send_fw_cmd(av7110, cbuf, 5);\r\nmutex_unlock(&av7110->dcomlock);\r\nif (ret && ret!=-ERESTARTSYS)\r\nprintk(KERN_ERR "dvb-ttpci: WriteText error %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic inline int DrawLine(struct av7110 *av7110, u8 windownr,\r\nu16 x, u16 y, u16 dx, u16 dy, u16 color)\r\n{\r\nreturn av7110_fw_cmd(av7110, COMTYPE_OSD, DLine, 6,\r\nwindownr, x, y, dx, dy, color);\r\n}\r\nstatic inline int DrawBlock(struct av7110 *av7110, u8 windownr,\r\nu16 x, u16 y, u16 dx, u16 dy, u16 color)\r\n{\r\nreturn av7110_fw_cmd(av7110, COMTYPE_OSD, DBox, 6,\r\nwindownr, x, y, dx, dy, color);\r\n}\r\nstatic inline int HideWindow(struct av7110 *av7110, u8 windownr)\r\n{\r\nreturn av7110_fw_cmd(av7110, COMTYPE_OSD, WHide, 1, windownr);\r\n}\r\nstatic inline int MoveWindowRel(struct av7110 *av7110, u8 windownr, u16 x, u16 y)\r\n{\r\nreturn av7110_fw_cmd(av7110, COMTYPE_OSD, WMoveD, 3, windownr, x, y);\r\n}\r\nstatic inline int MoveWindowAbs(struct av7110 *av7110, u8 windownr, u16 x, u16 y)\r\n{\r\nreturn av7110_fw_cmd(av7110, COMTYPE_OSD, WMoveA, 3, windownr, x, y);\r\n}\r\nstatic inline int DestroyOSDWindow(struct av7110 *av7110, u8 windownr)\r\n{\r\nreturn av7110_fw_cmd(av7110, COMTYPE_OSD, WDestroy, 1, windownr);\r\n}\r\nstatic inline int CreateOSDWindow(struct av7110 *av7110, u8 windownr,\r\nosd_raw_window_t disptype,\r\nu16 width, u16 height)\r\n{\r\nreturn av7110_fw_cmd(av7110, COMTYPE_OSD, WCreate, 4,\r\nwindownr, disptype, width, height);\r\n}\r\nstatic inline int WaitUntilBmpLoaded(struct av7110 *av7110)\r\n{\r\nint ret = wait_event_timeout(av7110->bmpq,\r\nav7110->bmp_state != BMP_LOADING, 10*HZ);\r\nif (ret == 0) {\r\nprintk("dvb-ttpci: warning: timeout waiting in LoadBitmap: %d, %d\n",\r\nret, av7110->bmp_state);\r\nav7110->bmp_state = BMP_NONE;\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int LoadBitmap(struct av7110 *av7110,\r\nu16 dx, u16 dy, int inc, u8 __user * data)\r\n{\r\nu16 format;\r\nint bpp;\r\nint i;\r\nint d, delta;\r\nu8 c;\r\nint ret;\r\ndprintk(4, "%p\n", av7110);\r\nformat = bpp2bit[av7110->osdbpp[av7110->osdwin]];\r\nav7110->bmp_state = BMP_LOADING;\r\nif (format == OSD_BITMAP8) {\r\nbpp=8; delta = 1;\r\n} else if (format == OSD_BITMAP4) {\r\nbpp=4; delta = 2;\r\n} else if (format == OSD_BITMAP2) {\r\nbpp=2; delta = 4;\r\n} else if (format == OSD_BITMAP1) {\r\nbpp=1; delta = 8;\r\n} else {\r\nav7110->bmp_state = BMP_NONE;\r\nreturn -EINVAL;\r\n}\r\nav7110->bmplen = ((dx * dy * bpp + 7) & ~7) / 8;\r\nav7110->bmpp = 0;\r\nif (av7110->bmplen > 32768) {\r\nav7110->bmp_state = BMP_NONE;\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < dy; i++) {\r\nif (copy_from_user(av7110->bmpbuf + 1024 + i * dx, data + i * inc, dx)) {\r\nav7110->bmp_state = BMP_NONE;\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (format != OSD_BITMAP8) {\r\nfor (i = 0; i < dx * dy / delta; i++) {\r\nc = ((u8 *)av7110->bmpbuf)[1024 + i * delta + delta - 1];\r\nfor (d = delta - 2; d >= 0; d--) {\r\nc |= (((u8 *)av7110->bmpbuf)[1024 + i * delta + d]\r\n<< ((delta - d - 1) * bpp));\r\n((u8 *)av7110->bmpbuf)[1024 + i] = c;\r\n}\r\n}\r\n}\r\nav7110->bmplen += 1024;\r\ndprintk(4, "av7110_fw_cmd: LoadBmp size %d\n", av7110->bmplen);\r\nret = av7110_fw_cmd(av7110, COMTYPE_OSD, LoadBmp, 3, format, dx, dy);\r\nif (!ret)\r\nret = WaitUntilBmpLoaded(av7110);\r\nreturn ret;\r\n}\r\nstatic int BlitBitmap(struct av7110 *av7110, u16 x, u16 y)\r\n{\r\ndprintk(4, "%p\n", av7110);\r\nreturn av7110_fw_cmd(av7110, COMTYPE_OSD, BlitBmp, 4, av7110->osdwin, x, y, 0);\r\n}\r\nstatic inline int ReleaseBitmap(struct av7110 *av7110)\r\n{\r\ndprintk(4, "%p\n", av7110);\r\nif (av7110->bmp_state != BMP_LOADED && FW_VERSION(av7110->arm_app) < 0x261e)\r\nreturn -1;\r\nif (av7110->bmp_state == BMP_LOADING)\r\ndprintk(1,"ReleaseBitmap called while BMP_LOADING\n");\r\nav7110->bmp_state = BMP_NONE;\r\nreturn av7110_fw_cmd(av7110, COMTYPE_OSD, ReleaseBmp, 0);\r\n}\r\nstatic u32 RGB2YUV(u16 R, u16 G, u16 B)\r\n{\r\nu16 y, u, v;\r\nu16 Y, Cr, Cb;\r\ny = R * 77 + G * 150 + B * 29;\r\nu = 2048 + B * 8 -(y >> 5);\r\nv = 2048 + R * 8 -(y >> 5);\r\nY = y / 256;\r\nCb = u / 16;\r\nCr = v / 16;\r\nreturn Cr | (Cb << 16) | (Y << 8);\r\n}\r\nstatic int OSDSetColor(struct av7110 *av7110, u8 color, u8 r, u8 g, u8 b, u8 blend)\r\n{\r\nint ret;\r\nu16 ch, cl;\r\nu32 yuv;\r\nyuv = blend ? RGB2YUV(r,g,b) : 0;\r\ncl = (yuv & 0xffff);\r\nch = ((yuv >> 16) & 0xffff);\r\nret = SetColor_(av7110, av7110->osdwin, bpp2pal[av7110->osdbpp[av7110->osdwin]],\r\ncolor, ch, cl);\r\nif (!ret)\r\nret = SetBlend_(av7110, av7110->osdwin, bpp2pal[av7110->osdbpp[av7110->osdwin]],\r\ncolor, ((blend >> 4) & 0x0f));\r\nreturn ret;\r\n}\r\nstatic int OSDSetPalette(struct av7110 *av7110, u32 __user * colors, u8 first, u8 last)\r\n{\r\nint i;\r\nint length = last - first + 1;\r\nif (length * 4 > DATA_BUFF3_SIZE)\r\nreturn -EINVAL;\r\nfor (i = 0; i < length; i++) {\r\nu32 color, blend, yuv;\r\nif (get_user(color, colors + i))\r\nreturn -EFAULT;\r\nblend = (color & 0xF0000000) >> 4;\r\nyuv = blend ? RGB2YUV(color & 0xFF, (color >> 8) & 0xFF,\r\n(color >> 16) & 0xFF) | blend : 0;\r\nyuv = ((yuv & 0xFFFF0000) >> 16) | ((yuv & 0x0000FFFF) << 16);\r\nwdebi(av7110, DEBINOSWAP, DATA_BUFF3_BASE + i * 4, yuv, 4);\r\n}\r\nreturn av7110_fw_cmd(av7110, COMTYPE_OSD, Set_Palette, 4,\r\nav7110->osdwin,\r\nbpp2pal[av7110->osdbpp[av7110->osdwin]],\r\nfirst, last);\r\n}\r\nstatic int OSDSetBlock(struct av7110 *av7110, int x0, int y0,\r\nint x1, int y1, int inc, u8 __user * data)\r\n{\r\nuint w, h, bpp, bpl, size, lpb, bnum, brest;\r\nint i;\r\nint rc,release_rc;\r\nw = x1 - x0 + 1;\r\nh = y1 - y0 + 1;\r\nif (inc <= 0)\r\ninc = w;\r\nif (w <= 0 || w > 720 || h <= 0 || h > 576)\r\nreturn -EINVAL;\r\nbpp = av7110->osdbpp[av7110->osdwin] + 1;\r\nbpl = ((w * bpp + 7) & ~7) / 8;\r\nsize = h * bpl;\r\nlpb = (32 * 1024) / bpl;\r\nbnum = size / (lpb * bpl);\r\nbrest = size - bnum * lpb * bpl;\r\nif (av7110->bmp_state == BMP_LOADING) {\r\nBUG_ON (FW_VERSION(av7110->arm_app) >= 0x261e);\r\nrc = WaitUntilBmpLoaded(av7110);\r\nif (rc)\r\nreturn rc;\r\n}\r\nrc = 0;\r\nfor (i = 0; i < bnum; i++) {\r\nrc = LoadBitmap(av7110, w, lpb, inc, data);\r\nif (rc)\r\nbreak;\r\nrc = BlitBitmap(av7110, x0, y0 + i * lpb);\r\nif (rc)\r\nbreak;\r\ndata += lpb * inc;\r\n}\r\nif (!rc && brest) {\r\nrc = LoadBitmap(av7110, w, brest / bpl, inc, data);\r\nif (!rc)\r\nrc = BlitBitmap(av7110, x0, y0 + bnum * lpb);\r\n}\r\nrelease_rc = ReleaseBitmap(av7110);\r\nif (!rc)\r\nrc = release_rc;\r\nif (rc)\r\ndprintk(1,"returns %d\n",rc);\r\nreturn rc;\r\n}\r\nint av7110_osd_cmd(struct av7110 *av7110, osd_cmd_t *dc)\r\n{\r\nint ret;\r\nif (mutex_lock_interruptible(&av7110->osd_mutex))\r\nreturn -ERESTARTSYS;\r\nswitch (dc->cmd) {\r\ncase OSD_Close:\r\nret = DestroyOSDWindow(av7110, av7110->osdwin);\r\nbreak;\r\ncase OSD_Open:\r\nav7110->osdbpp[av7110->osdwin] = (dc->color - 1) & 7;\r\nret = CreateOSDWindow(av7110, av7110->osdwin,\r\nbpp2bit[av7110->osdbpp[av7110->osdwin]],\r\ndc->x1 - dc->x0 + 1, dc->y1 - dc->y0 + 1);\r\nif (ret)\r\nbreak;\r\nif (!dc->data) {\r\nret = MoveWindowAbs(av7110, av7110->osdwin, dc->x0, dc->y0);\r\nif (ret)\r\nbreak;\r\nret = SetColorBlend(av7110, av7110->osdwin);\r\n}\r\nbreak;\r\ncase OSD_Show:\r\nret = MoveWindowRel(av7110, av7110->osdwin, 0, 0);\r\nbreak;\r\ncase OSD_Hide:\r\nret = HideWindow(av7110, av7110->osdwin);\r\nbreak;\r\ncase OSD_Clear:\r\nret = DrawBlock(av7110, av7110->osdwin, 0, 0, 720, 576, 0);\r\nbreak;\r\ncase OSD_Fill:\r\nret = DrawBlock(av7110, av7110->osdwin, 0, 0, 720, 576, dc->color);\r\nbreak;\r\ncase OSD_SetColor:\r\nret = OSDSetColor(av7110, dc->color, dc->x0, dc->y0, dc->x1, dc->y1);\r\nbreak;\r\ncase OSD_SetPalette:\r\nif (FW_VERSION(av7110->arm_app) >= 0x2618)\r\nret = OSDSetPalette(av7110, dc->data, dc->color, dc->x0);\r\nelse {\r\nint i, len = dc->x0-dc->color+1;\r\nu8 __user *colors = (u8 __user *)dc->data;\r\nu8 r, g = 0, b = 0, blend = 0;\r\nret = 0;\r\nfor (i = 0; i<len; i++) {\r\nif (get_user(r, colors + i * 4) ||\r\nget_user(g, colors + i * 4 + 1) ||\r\nget_user(b, colors + i * 4 + 2) ||\r\nget_user(blend, colors + i * 4 + 3)) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nret = OSDSetColor(av7110, dc->color + i, r, g, b, blend);\r\nif (ret)\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase OSD_SetPixel:\r\nret = DrawLine(av7110, av7110->osdwin,\r\ndc->x0, dc->y0, 0, 0, dc->color);\r\nbreak;\r\ncase OSD_SetRow:\r\ndc->y1 = dc->y0;\r\ncase OSD_SetBlock:\r\nret = OSDSetBlock(av7110, dc->x0, dc->y0, dc->x1, dc->y1, dc->color, dc->data);\r\nbreak;\r\ncase OSD_FillRow:\r\nret = DrawBlock(av7110, av7110->osdwin, dc->x0, dc->y0,\r\ndc->x1-dc->x0+1, dc->y1, dc->color);\r\nbreak;\r\ncase OSD_FillBlock:\r\nret = DrawBlock(av7110, av7110->osdwin, dc->x0, dc->y0,\r\ndc->x1 - dc->x0 + 1, dc->y1 - dc->y0 + 1, dc->color);\r\nbreak;\r\ncase OSD_Line:\r\nret = DrawLine(av7110, av7110->osdwin,\r\ndc->x0, dc->y0, dc->x1 - dc->x0, dc->y1 - dc->y0, dc->color);\r\nbreak;\r\ncase OSD_Text:\r\n{\r\nchar textbuf[240];\r\nif (strncpy_from_user(textbuf, dc->data, 240) < 0) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\ntextbuf[239] = 0;\r\nif (dc->x1 > 3)\r\ndc->x1 = 3;\r\nret = SetFont(av7110, av7110->osdwin, dc->x1,\r\n(u16) (dc->color & 0xffff), (u16) (dc->color >> 16));\r\nif (!ret)\r\nret = FlushText(av7110);\r\nif (!ret)\r\nret = WriteText(av7110, av7110->osdwin, dc->x0, dc->y0, textbuf);\r\nbreak;\r\n}\r\ncase OSD_SetWindow:\r\nif (dc->x0 < 1 || dc->x0 > 7)\r\nret = -EINVAL;\r\nelse {\r\nav7110->osdwin = dc->x0;\r\nret = 0;\r\n}\r\nbreak;\r\ncase OSD_MoveWindow:\r\nret = MoveWindowAbs(av7110, av7110->osdwin, dc->x0, dc->y0);\r\nif (!ret)\r\nret = SetColorBlend(av7110, av7110->osdwin);\r\nbreak;\r\ncase OSD_OpenRaw:\r\nif (dc->color < OSD_BITMAP1 || dc->color > OSD_CURSOR) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (dc->color >= OSD_BITMAP1 && dc->color <= OSD_BITMAP8HR)\r\nav7110->osdbpp[av7110->osdwin] = (1 << (dc->color & 3)) - 1;\r\nelse\r\nav7110->osdbpp[av7110->osdwin] = 0;\r\nret = CreateOSDWindow(av7110, av7110->osdwin, (osd_raw_window_t)dc->color,\r\ndc->x1 - dc->x0 + 1, dc->y1 - dc->y0 + 1);\r\nif (ret)\r\nbreak;\r\nif (!dc->data) {\r\nret = MoveWindowAbs(av7110, av7110->osdwin, dc->x0, dc->y0);\r\nif (!ret)\r\nret = SetColorBlend(av7110, av7110->osdwin);\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nmutex_unlock(&av7110->osd_mutex);\r\nif (ret==-ERESTARTSYS)\r\ndprintk(1, "av7110_osd_cmd(%d) returns with -ERESTARTSYS\n",dc->cmd);\r\nelse if (ret)\r\ndprintk(1, "av7110_osd_cmd(%d) returns with %d\n",dc->cmd,ret);\r\nreturn ret;\r\n}\r\nint av7110_osd_capability(struct av7110 *av7110, osd_cap_t *cap)\r\n{\r\nswitch (cap->cmd) {\r\ncase OSD_CAP_MEMSIZE:\r\nif (FW_4M_SDRAM(av7110->arm_app))\r\ncap->val = 1000000;\r\nelse\r\ncap->val = 92000;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}
