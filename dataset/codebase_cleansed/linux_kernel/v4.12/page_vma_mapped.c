static inline bool check_pmd(struct page_vma_mapped_walk *pvmw)\r\n{\r\npmd_t pmde;\r\npmde = READ_ONCE(*pvmw->pmd);\r\nreturn pmd_present(pmde) && !pmd_trans_huge(pmde);\r\n}\r\nstatic inline bool not_found(struct page_vma_mapped_walk *pvmw)\r\n{\r\npage_vma_mapped_walk_done(pvmw);\r\nreturn false;\r\n}\r\nstatic bool map_pte(struct page_vma_mapped_walk *pvmw)\r\n{\r\npvmw->pte = pte_offset_map(pvmw->pmd, pvmw->address);\r\nif (!(pvmw->flags & PVMW_SYNC)) {\r\nif (pvmw->flags & PVMW_MIGRATION) {\r\nif (!is_swap_pte(*pvmw->pte))\r\nreturn false;\r\n} else {\r\nif (!pte_present(*pvmw->pte))\r\nreturn false;\r\n}\r\n}\r\npvmw->ptl = pte_lockptr(pvmw->vma->vm_mm, pvmw->pmd);\r\nspin_lock(pvmw->ptl);\r\nreturn true;\r\n}\r\nstatic bool check_pte(struct page_vma_mapped_walk *pvmw)\r\n{\r\nif (pvmw->flags & PVMW_MIGRATION) {\r\n#ifdef CONFIG_MIGRATION\r\nswp_entry_t entry;\r\nif (!is_swap_pte(*pvmw->pte))\r\nreturn false;\r\nentry = pte_to_swp_entry(*pvmw->pte);\r\nif (!is_migration_entry(entry))\r\nreturn false;\r\nif (migration_entry_to_page(entry) - pvmw->page >=\r\nhpage_nr_pages(pvmw->page)) {\r\nreturn false;\r\n}\r\nif (migration_entry_to_page(entry) < pvmw->page)\r\nreturn false;\r\n#else\r\nWARN_ON_ONCE(1);\r\n#endif\r\n} else {\r\nif (!pte_present(*pvmw->pte))\r\nreturn false;\r\nif (pte_page(*pvmw->pte) - pvmw->page >=\r\nhpage_nr_pages(pvmw->page)) {\r\nreturn false;\r\n}\r\nif (pte_page(*pvmw->pte) < pvmw->page)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nbool page_vma_mapped_walk(struct page_vma_mapped_walk *pvmw)\r\n{\r\nstruct mm_struct *mm = pvmw->vma->vm_mm;\r\nstruct page *page = pvmw->page;\r\npgd_t *pgd;\r\np4d_t *p4d;\r\npud_t *pud;\r\nif (pvmw->pmd && !pvmw->pte)\r\nreturn not_found(pvmw);\r\nif (pvmw->pte)\r\ngoto next_pte;\r\nif (unlikely(PageHuge(pvmw->page))) {\r\npvmw->pte = huge_pte_offset(mm, pvmw->address);\r\nif (!pvmw->pte)\r\nreturn false;\r\npvmw->ptl = huge_pte_lockptr(page_hstate(page), mm, pvmw->pte);\r\nspin_lock(pvmw->ptl);\r\nif (!check_pte(pvmw))\r\nreturn not_found(pvmw);\r\nreturn true;\r\n}\r\nrestart:\r\npgd = pgd_offset(mm, pvmw->address);\r\nif (!pgd_present(*pgd))\r\nreturn false;\r\np4d = p4d_offset(pgd, pvmw->address);\r\nif (!p4d_present(*p4d))\r\nreturn false;\r\npud = pud_offset(p4d, pvmw->address);\r\nif (!pud_present(*pud))\r\nreturn false;\r\npvmw->pmd = pmd_offset(pud, pvmw->address);\r\nif (pmd_trans_huge(*pvmw->pmd)) {\r\npvmw->ptl = pmd_lock(mm, pvmw->pmd);\r\nif (!pmd_present(*pvmw->pmd))\r\nreturn not_found(pvmw);\r\nif (likely(pmd_trans_huge(*pvmw->pmd))) {\r\nif (pvmw->flags & PVMW_MIGRATION)\r\nreturn not_found(pvmw);\r\nif (pmd_page(*pvmw->pmd) != page)\r\nreturn not_found(pvmw);\r\nreturn true;\r\n} else {\r\nspin_unlock(pvmw->ptl);\r\npvmw->ptl = NULL;\r\n}\r\n} else {\r\nif (!check_pmd(pvmw))\r\nreturn false;\r\n}\r\nif (!map_pte(pvmw))\r\ngoto next_pte;\r\nwhile (1) {\r\nif (check_pte(pvmw))\r\nreturn true;\r\nnext_pte:\r\nif (!PageTransHuge(pvmw->page) || PageHuge(pvmw->page))\r\nreturn not_found(pvmw);\r\ndo {\r\npvmw->address += PAGE_SIZE;\r\nif (pvmw->address >= pvmw->vma->vm_end ||\r\npvmw->address >=\r\n__vma_address(pvmw->page, pvmw->vma) +\r\nhpage_nr_pages(pvmw->page) * PAGE_SIZE)\r\nreturn not_found(pvmw);\r\nif (pvmw->address % PMD_SIZE == 0) {\r\npte_unmap(pvmw->pte);\r\nif (pvmw->ptl) {\r\nspin_unlock(pvmw->ptl);\r\npvmw->ptl = NULL;\r\n}\r\ngoto restart;\r\n} else {\r\npvmw->pte++;\r\n}\r\n} while (pte_none(*pvmw->pte));\r\nif (!pvmw->ptl) {\r\npvmw->ptl = pte_lockptr(mm, pvmw->pmd);\r\nspin_lock(pvmw->ptl);\r\n}\r\n}\r\n}\r\nint page_mapped_in_vma(struct page *page, struct vm_area_struct *vma)\r\n{\r\nstruct page_vma_mapped_walk pvmw = {\r\n.page = page,\r\n.vma = vma,\r\n.flags = PVMW_SYNC,\r\n};\r\nunsigned long start, end;\r\nstart = __vma_address(page, vma);\r\nend = start + PAGE_SIZE * (hpage_nr_pages(page) - 1);\r\nif (unlikely(end < vma->vm_start || start >= vma->vm_end))\r\nreturn 0;\r\npvmw.address = max(start, vma->vm_start);\r\nif (!page_vma_mapped_walk(&pvmw))\r\nreturn 0;\r\npage_vma_mapped_walk_done(&pvmw);\r\nreturn 1;\r\n}
