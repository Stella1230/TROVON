static void st_rproc_mbox_callback(struct device *dev, u32 msg)\r\n{\r\nstruct rproc *rproc = dev_get_drvdata(dev);\r\nif (rproc_vq_interrupt(rproc, msg) == IRQ_NONE)\r\ndev_dbg(dev, "no message was found in vqid %d\n", msg);\r\n}\r\nstatic\r\nvoid st_rproc_mbox_callback_vq0(struct mbox_client *mbox_client, void *data)\r\n{\r\nst_rproc_mbox_callback(mbox_client->dev, 0);\r\n}\r\nstatic\r\nvoid st_rproc_mbox_callback_vq1(struct mbox_client *mbox_client, void *data)\r\n{\r\nst_rproc_mbox_callback(mbox_client->dev, 1);\r\n}\r\nstatic void st_rproc_kick(struct rproc *rproc, int vqid)\r\n{\r\nstruct st_rproc *ddata = rproc->priv;\r\nstruct device *dev = rproc->dev.parent;\r\nint ret;\r\nif (WARN_ON(vqid >= ST_RPROC_MAX_VRING))\r\nreturn;\r\nret = mbox_send_message(ddata->mbox_chan[vqid * MBOX_MAX + MBOX_TX],\r\n(void *)&vqid);\r\nif (ret < 0)\r\ndev_err(dev, "failed to send message via mbox: %d\n", ret);\r\n}\r\nstatic int st_rproc_start(struct rproc *rproc)\r\n{\r\nstruct st_rproc *ddata = rproc->priv;\r\nint err;\r\nregmap_update_bits(ddata->boot_base, ddata->boot_offset,\r\nddata->config->bootaddr_mask, rproc->bootaddr);\r\nerr = clk_enable(ddata->clk);\r\nif (err) {\r\ndev_err(&rproc->dev, "Failed to enable clock\n");\r\nreturn err;\r\n}\r\nif (ddata->config->sw_reset) {\r\nerr = reset_control_deassert(ddata->sw_reset);\r\nif (err) {\r\ndev_err(&rproc->dev, "Failed to deassert S/W Reset\n");\r\ngoto sw_reset_fail;\r\n}\r\n}\r\nif (ddata->config->pwr_reset) {\r\nerr = reset_control_deassert(ddata->pwr_reset);\r\nif (err) {\r\ndev_err(&rproc->dev, "Failed to deassert Power Reset\n");\r\ngoto pwr_reset_fail;\r\n}\r\n}\r\ndev_info(&rproc->dev, "Started from 0x%x\n", rproc->bootaddr);\r\nreturn 0;\r\npwr_reset_fail:\r\nif (ddata->config->pwr_reset)\r\nreset_control_assert(ddata->sw_reset);\r\nsw_reset_fail:\r\nclk_disable(ddata->clk);\r\nreturn err;\r\n}\r\nstatic int st_rproc_stop(struct rproc *rproc)\r\n{\r\nstruct st_rproc *ddata = rproc->priv;\r\nint sw_err = 0, pwr_err = 0;\r\nif (ddata->config->sw_reset) {\r\nsw_err = reset_control_assert(ddata->sw_reset);\r\nif (sw_err)\r\ndev_err(&rproc->dev, "Failed to assert S/W Reset\n");\r\n}\r\nif (ddata->config->pwr_reset) {\r\npwr_err = reset_control_assert(ddata->pwr_reset);\r\nif (pwr_err)\r\ndev_err(&rproc->dev, "Failed to assert Power Reset\n");\r\n}\r\nclk_disable(ddata->clk);\r\nreturn sw_err ?: pwr_err;\r\n}\r\nstatic int st_rproc_state(struct platform_device *pdev)\r\n{\r\nstruct rproc *rproc = platform_get_drvdata(pdev);\r\nstruct st_rproc *ddata = rproc->priv;\r\nint reset_sw = 0, reset_pwr = 0;\r\nif (ddata->config->sw_reset)\r\nreset_sw = reset_control_status(ddata->sw_reset);\r\nif (ddata->config->pwr_reset)\r\nreset_pwr = reset_control_status(ddata->pwr_reset);\r\nif (reset_sw < 0 || reset_pwr < 0)\r\nreturn -EINVAL;\r\nreturn !reset_sw && !reset_pwr;\r\n}\r\nstatic int st_rproc_parse_dt(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct rproc *rproc = platform_get_drvdata(pdev);\r\nstruct st_rproc *ddata = rproc->priv;\r\nstruct device_node *np = dev->of_node;\r\nint err;\r\nif (ddata->config->sw_reset) {\r\nddata->sw_reset = devm_reset_control_get(dev, "sw_reset");\r\nif (IS_ERR(ddata->sw_reset)) {\r\ndev_err(dev, "Failed to get S/W Reset\n");\r\nreturn PTR_ERR(ddata->sw_reset);\r\n}\r\n}\r\nif (ddata->config->pwr_reset) {\r\nddata->pwr_reset = devm_reset_control_get(dev, "pwr_reset");\r\nif (IS_ERR(ddata->pwr_reset)) {\r\ndev_err(dev, "Failed to get Power Reset\n");\r\nreturn PTR_ERR(ddata->pwr_reset);\r\n}\r\n}\r\nddata->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(ddata->clk)) {\r\ndev_err(dev, "Failed to get clock\n");\r\nreturn PTR_ERR(ddata->clk);\r\n}\r\nerr = of_property_read_u32(np, "clock-frequency", &ddata->clk_rate);\r\nif (err) {\r\ndev_err(dev, "failed to get clock frequency\n");\r\nreturn err;\r\n}\r\nddata->boot_base = syscon_regmap_lookup_by_phandle(np, "st,syscfg");\r\nif (IS_ERR(ddata->boot_base)) {\r\ndev_err(dev, "Boot base not found\n");\r\nreturn PTR_ERR(ddata->boot_base);\r\n}\r\nerr = of_property_read_u32_index(np, "st,syscfg", 1,\r\n&ddata->boot_offset);\r\nif (err) {\r\ndev_err(dev, "Boot offset not found\n");\r\nreturn -EINVAL;\r\n}\r\nerr = of_reserved_mem_device_init(dev);\r\nif (err) {\r\ndev_err(dev, "Failed to obtain shared memory\n");\r\nreturn err;\r\n}\r\nerr = clk_prepare(ddata->clk);\r\nif (err)\r\ndev_err(dev, "failed to get clock\n");\r\nreturn err;\r\n}\r\nstatic int st_rproc_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nconst struct of_device_id *match;\r\nstruct st_rproc *ddata;\r\nstruct device_node *np = dev->of_node;\r\nstruct rproc *rproc;\r\nstruct mbox_chan *chan;\r\nint enabled;\r\nint ret, i;\r\nmatch = of_match_device(st_rproc_match, dev);\r\nif (!match || !match->data) {\r\ndev_err(dev, "No device match found\n");\r\nreturn -ENODEV;\r\n}\r\nrproc = rproc_alloc(dev, np->name, &st_rproc_ops, NULL, sizeof(*ddata));\r\nif (!rproc)\r\nreturn -ENOMEM;\r\nrproc->has_iommu = false;\r\nddata = rproc->priv;\r\nddata->config = (struct st_rproc_config *)match->data;\r\nplatform_set_drvdata(pdev, rproc);\r\nret = st_rproc_parse_dt(pdev);\r\nif (ret)\r\ngoto free_rproc;\r\nenabled = st_rproc_state(pdev);\r\nif (enabled < 0) {\r\nret = enabled;\r\ngoto free_clk;\r\n}\r\nif (enabled) {\r\natomic_inc(&rproc->power);\r\nrproc->state = RPROC_RUNNING;\r\n} else {\r\nclk_set_rate(ddata->clk, ddata->clk_rate);\r\n}\r\nif (of_get_property(np, "mbox-names", NULL)) {\r\nddata->mbox_client_vq0.dev = dev;\r\nddata->mbox_client_vq0.tx_done = NULL;\r\nddata->mbox_client_vq0.tx_block = false;\r\nddata->mbox_client_vq0.knows_txdone = false;\r\nddata->mbox_client_vq0.rx_callback = st_rproc_mbox_callback_vq0;\r\nddata->mbox_client_vq1.dev = dev;\r\nddata->mbox_client_vq1.tx_done = NULL;\r\nddata->mbox_client_vq1.tx_block = false;\r\nddata->mbox_client_vq1.knows_txdone = false;\r\nddata->mbox_client_vq1.rx_callback = st_rproc_mbox_callback_vq1;\r\nchan = mbox_request_channel_byname(&ddata->mbox_client_vq0, "vq0_rx");\r\nif (IS_ERR(chan)) {\r\ndev_err(&rproc->dev, "failed to request mbox chan 0\n");\r\nret = PTR_ERR(chan);\r\ngoto free_clk;\r\n}\r\nddata->mbox_chan[ST_RPROC_VQ0 * MBOX_MAX + MBOX_RX] = chan;\r\nchan = mbox_request_channel_byname(&ddata->mbox_client_vq0, "vq0_tx");\r\nif (IS_ERR(chan)) {\r\ndev_err(&rproc->dev, "failed to request mbox chan 0\n");\r\nret = PTR_ERR(chan);\r\ngoto free_mbox;\r\n}\r\nddata->mbox_chan[ST_RPROC_VQ0 * MBOX_MAX + MBOX_TX] = chan;\r\nchan = mbox_request_channel_byname(&ddata->mbox_client_vq1, "vq1_rx");\r\nif (IS_ERR(chan)) {\r\ndev_err(&rproc->dev, "failed to request mbox chan 1\n");\r\nret = PTR_ERR(chan);\r\ngoto free_mbox;\r\n}\r\nddata->mbox_chan[ST_RPROC_VQ1 * MBOX_MAX + MBOX_RX] = chan;\r\nchan = mbox_request_channel_byname(&ddata->mbox_client_vq1, "vq1_tx");\r\nif (IS_ERR(chan)) {\r\ndev_err(&rproc->dev, "failed to request mbox chan 1\n");\r\nret = PTR_ERR(chan);\r\ngoto free_mbox;\r\n}\r\nddata->mbox_chan[ST_RPROC_VQ1 * MBOX_MAX + MBOX_TX] = chan;\r\n}\r\nret = rproc_add(rproc);\r\nif (ret)\r\ngoto free_mbox;\r\nreturn 0;\r\nfree_mbox:\r\nfor (i = 0; i < ST_RPROC_MAX_VRING * MBOX_MAX; i++)\r\nmbox_free_channel(ddata->mbox_chan[i]);\r\nfree_clk:\r\nclk_unprepare(ddata->clk);\r\nfree_rproc:\r\nrproc_free(rproc);\r\nreturn ret;\r\n}\r\nstatic int st_rproc_remove(struct platform_device *pdev)\r\n{\r\nstruct rproc *rproc = platform_get_drvdata(pdev);\r\nstruct st_rproc *ddata = rproc->priv;\r\nint i;\r\nrproc_del(rproc);\r\nclk_disable_unprepare(ddata->clk);\r\nof_reserved_mem_device_release(&pdev->dev);\r\nfor (i = 0; i < ST_RPROC_MAX_VRING * MBOX_MAX; i++)\r\nmbox_free_channel(ddata->mbox_chan[i]);\r\nrproc_free(rproc);\r\nreturn 0;\r\n}
