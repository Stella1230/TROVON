static inline void flush_tce(void* tceaddr)\r\n{\r\nif (boot_cpu_has(X86_FEATURE_CLFLUSH))\r\nclflush(tceaddr);\r\nelse\r\nwbinvd();\r\n}\r\nvoid tce_build(struct iommu_table *tbl, unsigned long index,\r\nunsigned int npages, unsigned long uaddr, int direction)\r\n{\r\nu64* tp;\r\nu64 t;\r\nu64 rpn;\r\nt = (1 << TCE_READ_SHIFT);\r\nif (direction != DMA_TO_DEVICE)\r\nt |= (1 << TCE_WRITE_SHIFT);\r\ntp = ((u64*)tbl->it_base) + index;\r\nwhile (npages--) {\r\nrpn = (virt_to_bus((void*)uaddr)) >> PAGE_SHIFT;\r\nt &= ~TCE_RPN_MASK;\r\nt |= (rpn << TCE_RPN_SHIFT);\r\n*tp = cpu_to_be64(t);\r\nflush_tce(tp);\r\nuaddr += PAGE_SIZE;\r\ntp++;\r\n}\r\n}\r\nvoid tce_free(struct iommu_table *tbl, long index, unsigned int npages)\r\n{\r\nu64* tp;\r\ntp = ((u64*)tbl->it_base) + index;\r\nwhile (npages--) {\r\n*tp = cpu_to_be64(0);\r\nflush_tce(tp);\r\ntp++;\r\n}\r\n}\r\nstatic inline unsigned int table_size_to_number_of_entries(unsigned char size)\r\n{\r\nreturn (1 << size) << 13;\r\n}\r\nstatic int tce_table_setparms(struct pci_dev *dev, struct iommu_table *tbl)\r\n{\r\nunsigned int bitmapsz;\r\nunsigned long bmppages;\r\nint ret;\r\ntbl->it_busno = dev->bus->number;\r\ntbl->it_size = table_size_to_number_of_entries(specified_table_size);\r\nbitmapsz = tbl->it_size / BITS_PER_BYTE;\r\nbmppages = __get_free_pages(GFP_KERNEL, get_order(bitmapsz));\r\nif (!bmppages) {\r\nprintk(KERN_ERR "Calgary: cannot allocate bitmap\n");\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\ntbl->it_map = (unsigned long*)bmppages;\r\nmemset(tbl->it_map, 0, bitmapsz);\r\ntbl->it_hint = 0;\r\nspin_lock_init(&tbl->it_lock);\r\nreturn 0;\r\ndone:\r\nreturn ret;\r\n}\r\nint __init build_tce_table(struct pci_dev *dev, void __iomem *bbar)\r\n{\r\nstruct iommu_table *tbl;\r\nint ret;\r\nif (pci_iommu(dev->bus)) {\r\nprintk(KERN_ERR "Calgary: dev %p has sysdata->iommu %p\n",\r\ndev, pci_iommu(dev->bus));\r\nBUG();\r\n}\r\ntbl = kzalloc(sizeof(struct iommu_table), GFP_KERNEL);\r\nif (!tbl) {\r\nprintk(KERN_ERR "Calgary: error allocating iommu_table\n");\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\nret = tce_table_setparms(dev, tbl);\r\nif (ret)\r\ngoto free_tbl;\r\ntbl->bbar = bbar;\r\nset_pci_iommu(dev->bus, tbl);\r\nreturn 0;\r\nfree_tbl:\r\nkfree(tbl);\r\ndone:\r\nreturn ret;\r\n}\r\nvoid * __init alloc_tce_table(void)\r\n{\r\nunsigned int size;\r\nsize = table_size_to_number_of_entries(specified_table_size);\r\nsize *= TCE_ENTRY_SIZE;\r\nreturn __alloc_bootmem_low(size, size, 0);\r\n}\r\nvoid __init free_tce_table(void *tbl)\r\n{\r\nunsigned int size;\r\nif (!tbl)\r\nreturn;\r\nsize = table_size_to_number_of_entries(specified_table_size);\r\nsize *= TCE_ENTRY_SIZE;\r\nfree_bootmem(__pa(tbl), size);\r\n}
