void rtl_cam_reset_sec_info(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nrtlpriv->sec.use_defaultkey = false;\r\nrtlpriv->sec.pairwise_enc_algorithm = NO_ENCRYPTION;\r\nrtlpriv->sec.group_enc_algorithm = NO_ENCRYPTION;\r\nmemset(rtlpriv->sec.key_buf, 0, KEY_BUF_SIZE * MAX_KEY_LEN);\r\nmemset(rtlpriv->sec.key_len, 0, KEY_BUF_SIZE);\r\nrtlpriv->sec.pairwise_key = NULL;\r\n}\r\nstatic void rtl_cam_program_entry(struct ieee80211_hw *hw, u32 entry_no,\r\nu8 *mac_addr, u8 *key_cont_128, u16 us_config)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu32 target_command;\r\nu32 target_content = 0;\r\nint entry_i;\r\nRT_PRINT_DATA(rtlpriv, COMP_SEC, DBG_DMESG, "Key content :",\r\nkey_cont_128, 16);\r\nfor (entry_i = CAM_CONTENT_COUNT - 1; entry_i >= 0; entry_i--) {\r\ntarget_command = entry_i + CAM_CONTENT_COUNT * entry_no;\r\ntarget_command = target_command | BIT(31) | BIT(16);\r\nif (entry_i == 0) {\r\ntarget_content = (u32) (*(mac_addr + 0)) << 16 |\r\n(u32) (*(mac_addr + 1)) << 24 | (u32) us_config;\r\nrtl_write_dword(rtlpriv, rtlpriv->cfg->maps[WCAMI],\r\ntarget_content);\r\nrtl_write_dword(rtlpriv, rtlpriv->cfg->maps[RWCAM],\r\ntarget_command);\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_LOUD,\r\n"WRITE %x: %x\n",\r\nrtlpriv->cfg->maps[WCAMI], target_content);\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_LOUD,\r\n"The Key ID is %d\n", entry_no);\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_LOUD,\r\n"WRITE %x: %x\n",\r\nrtlpriv->cfg->maps[RWCAM], target_command);\r\n} else if (entry_i == 1) {\r\ntarget_content = (u32) (*(mac_addr + 5)) << 24 |\r\n(u32) (*(mac_addr + 4)) << 16 |\r\n(u32) (*(mac_addr + 3)) << 8 |\r\n(u32) (*(mac_addr + 2));\r\nrtl_write_dword(rtlpriv, rtlpriv->cfg->maps[WCAMI],\r\ntarget_content);\r\nrtl_write_dword(rtlpriv, rtlpriv->cfg->maps[RWCAM],\r\ntarget_command);\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_LOUD,\r\n"WRITE A4: %x\n", target_content);\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_LOUD,\r\n"WRITE A0: %x\n", target_command);\r\n} else {\r\ntarget_content =\r\n(u32) (*(key_cont_128 + (entry_i * 4 - 8) + 3)) <<\r\n24 | (u32) (*(key_cont_128 + (entry_i * 4 - 8) + 2))\r\n<< 16 |\r\n(u32) (*(key_cont_128 + (entry_i * 4 - 8) + 1)) << 8\r\n| (u32) (*(key_cont_128 + (entry_i * 4 - 8) + 0));\r\nrtl_write_dword(rtlpriv, rtlpriv->cfg->maps[WCAMI],\r\ntarget_content);\r\nrtl_write_dword(rtlpriv, rtlpriv->cfg->maps[RWCAM],\r\ntarget_command);\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_LOUD,\r\n"WRITE A4: %x\n", target_content);\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_LOUD,\r\n"WRITE A0: %x\n", target_command);\r\n}\r\n}\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_LOUD,\r\n"after set key, usconfig:%x\n", us_config);\r\n}\r\nu8 rtl_cam_add_one_entry(struct ieee80211_hw *hw, u8 *mac_addr,\r\nu32 ul_key_id, u32 ul_entry_idx, u32 ul_enc_alg,\r\nu32 ul_default_key, u8 *key_content)\r\n{\r\nu32 us_config;\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG,\r\n"EntryNo:%x, ulKeyId=%x, ulEncAlg=%x, ulUseDK=%x MacAddr %pM\n",\r\nul_entry_idx, ul_key_id, ul_enc_alg,\r\nul_default_key, mac_addr);\r\nif (ul_key_id == TOTAL_CAM_ENTRY) {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,\r\n"ulKeyId exceed!\n");\r\nreturn 0;\r\n}\r\nif (ul_default_key == 1)\r\nus_config = CFG_VALID | ((u16) (ul_enc_alg) << 2);\r\nelse\r\nus_config = CFG_VALID | ((ul_enc_alg) << 2) | ul_key_id;\r\nrtl_cam_program_entry(hw, ul_entry_idx, mac_addr,\r\n(u8 *)key_content, us_config);\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG, "end\n");\r\nreturn 1;\r\n}\r\nint rtl_cam_delete_one_entry(struct ieee80211_hw *hw,\r\nu8 *mac_addr, u32 ul_key_id)\r\n{\r\nu32 ul_command;\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG, "key_idx:%d\n", ul_key_id);\r\nul_command = ul_key_id * CAM_CONTENT_COUNT;\r\nul_command = ul_command | BIT(31) | BIT(16);\r\nrtl_write_dword(rtlpriv, rtlpriv->cfg->maps[WCAMI], 0);\r\nrtl_write_dword(rtlpriv, rtlpriv->cfg->maps[RWCAM], ul_command);\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG,\r\n"rtl_cam_delete_one_entry(): WRITE A4: %x\n", 0);\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG,\r\n"rtl_cam_delete_one_entry(): WRITE A0: %x\n", ul_command);\r\nreturn 0;\r\n}\r\nvoid rtl_cam_reset_all_entry(struct ieee80211_hw *hw)\r\n{\r\nu32 ul_command;\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nul_command = BIT(31) | BIT(30);\r\nrtl_write_dword(rtlpriv, rtlpriv->cfg->maps[RWCAM], ul_command);\r\n}\r\nvoid rtl_cam_mark_invalid(struct ieee80211_hw *hw, u8 uc_index)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu32 ul_command;\r\nu32 ul_content;\r\nu32 ul_enc_algo = rtlpriv->cfg->maps[SEC_CAM_AES];\r\nswitch (rtlpriv->sec.pairwise_enc_algorithm) {\r\ncase WEP40_ENCRYPTION:\r\nul_enc_algo = rtlpriv->cfg->maps[SEC_CAM_WEP40];\r\nbreak;\r\ncase WEP104_ENCRYPTION:\r\nul_enc_algo = rtlpriv->cfg->maps[SEC_CAM_WEP104];\r\nbreak;\r\ncase TKIP_ENCRYPTION:\r\nul_enc_algo = rtlpriv->cfg->maps[SEC_CAM_TKIP];\r\nbreak;\r\ncase AESCCMP_ENCRYPTION:\r\nul_enc_algo = rtlpriv->cfg->maps[SEC_CAM_AES];\r\nbreak;\r\ndefault:\r\nul_enc_algo = rtlpriv->cfg->maps[SEC_CAM_AES];\r\n}\r\nul_content = (uc_index & 3) | ((u16) (ul_enc_algo) << 2);\r\nul_content |= BIT(15);\r\nul_command = CAM_CONTENT_COUNT * uc_index;\r\nul_command = ul_command | BIT(31) | BIT(16);\r\nrtl_write_dword(rtlpriv, rtlpriv->cfg->maps[WCAMI], ul_content);\r\nrtl_write_dword(rtlpriv, rtlpriv->cfg->maps[RWCAM], ul_command);\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG,\r\n"rtl_cam_mark_invalid(): WRITE A4: %x\n", ul_content);\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG,\r\n"rtl_cam_mark_invalid(): WRITE A0: %x\n", ul_command);\r\n}\r\nvoid rtl_cam_empty_entry(struct ieee80211_hw *hw, u8 uc_index)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu32 ul_command;\r\nu32 ul_content;\r\nu32 ul_encalgo = rtlpriv->cfg->maps[SEC_CAM_AES];\r\nu8 entry_i;\r\nswitch (rtlpriv->sec.pairwise_enc_algorithm) {\r\ncase WEP40_ENCRYPTION:\r\nul_encalgo = rtlpriv->cfg->maps[SEC_CAM_WEP40];\r\nbreak;\r\ncase WEP104_ENCRYPTION:\r\nul_encalgo = rtlpriv->cfg->maps[SEC_CAM_WEP104];\r\nbreak;\r\ncase TKIP_ENCRYPTION:\r\nul_encalgo = rtlpriv->cfg->maps[SEC_CAM_TKIP];\r\nbreak;\r\ncase AESCCMP_ENCRYPTION:\r\nul_encalgo = rtlpriv->cfg->maps[SEC_CAM_AES];\r\nbreak;\r\ndefault:\r\nul_encalgo = rtlpriv->cfg->maps[SEC_CAM_AES];\r\n}\r\nfor (entry_i = 0; entry_i < CAM_CONTENT_COUNT; entry_i++) {\r\nif (entry_i == 0) {\r\nul_content =\r\n(uc_index & 0x03) | ((u16) (ul_encalgo) << 2);\r\nul_content |= BIT(15);\r\n} else {\r\nul_content = 0;\r\n}\r\nul_command = CAM_CONTENT_COUNT * uc_index + entry_i;\r\nul_command = ul_command | BIT(31) | BIT(16);\r\nrtl_write_dword(rtlpriv, rtlpriv->cfg->maps[WCAMI], ul_content);\r\nrtl_write_dword(rtlpriv, rtlpriv->cfg->maps[RWCAM], ul_command);\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_LOUD,\r\n"rtl_cam_empty_entry(): WRITE A4: %x\n",\r\nul_content);\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_LOUD,\r\n"rtl_cam_empty_entry(): WRITE A0: %x\n",\r\nul_command);\r\n}\r\n}\r\nu8 rtl_cam_get_free_entry(struct ieee80211_hw *hw, u8 *sta_addr)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu32 bitmap = (rtlpriv->sec.hwsec_cam_bitmap) >> 4;\r\nu8 entry_idx = 0;\r\nu8 i, *addr;\r\nif (NULL == sta_addr) {\r\npr_err("sta_addr is NULL.\n");\r\nreturn TOTAL_CAM_ENTRY;\r\n}\r\nfor (i = 4; i < TOTAL_CAM_ENTRY; i++) {\r\naddr = rtlpriv->sec.hwsec_cam_sta_addr[i];\r\nif (ether_addr_equal_unaligned(addr, sta_addr))\r\nreturn i;\r\n}\r\nfor (entry_idx = 4; entry_idx < TOTAL_CAM_ENTRY; entry_idx++) {\r\nif ((bitmap & BIT(0)) == 0) {\r\npr_err("-----hwsec_cam_bitmap: 0x%x entry_idx=%d\n",\r\nrtlpriv->sec.hwsec_cam_bitmap, entry_idx);\r\nrtlpriv->sec.hwsec_cam_bitmap |= BIT(0) << entry_idx;\r\nmemcpy(rtlpriv->sec.hwsec_cam_sta_addr[entry_idx],\r\nsta_addr, ETH_ALEN);\r\nreturn entry_idx;\r\n}\r\nbitmap = bitmap >> 1;\r\n}\r\nreturn TOTAL_CAM_ENTRY;\r\n}\r\nvoid rtl_cam_del_entry(struct ieee80211_hw *hw, u8 *sta_addr)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu32 bitmap;\r\nu8 i, *addr;\r\nif (NULL == sta_addr) {\r\npr_err("sta_addr is NULL.\n");\r\nreturn;\r\n}\r\nif (is_zero_ether_addr(sta_addr)) {\r\npr_err("sta_addr is %pM\n", sta_addr);\r\nreturn;\r\n}\r\nfor (i = 4; i < TOTAL_CAM_ENTRY; i++) {\r\naddr = rtlpriv->sec.hwsec_cam_sta_addr[i];\r\nbitmap = (rtlpriv->sec.hwsec_cam_bitmap) >> i;\r\nif (((bitmap & BIT(0)) == BIT(0)) &&\r\n(ether_addr_equal_unaligned(addr, sta_addr))) {\r\neth_zero_addr(rtlpriv->sec.hwsec_cam_sta_addr[i]);\r\nrtlpriv->sec.hwsec_cam_bitmap &= ~(BIT(0) << i);\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG,\r\n"&&&&&&&&&del entry %d\n", i);\r\n}\r\n}\r\nreturn;\r\n}
