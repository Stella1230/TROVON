static const char *gr_ep0state_string(enum gr_ep0state state)\r\n{\r\nstatic const char *const names[] = {\r\n[GR_EP0_DISCONNECT] = "disconnect",\r\n[GR_EP0_SETUP] = "setup",\r\n[GR_EP0_IDATA] = "idata",\r\n[GR_EP0_ODATA] = "odata",\r\n[GR_EP0_ISTATUS] = "istatus",\r\n[GR_EP0_OSTATUS] = "ostatus",\r\n[GR_EP0_STALL] = "stall",\r\n[GR_EP0_SUSPEND] = "suspend",\r\n};\r\nif (state < 0 || state >= ARRAY_SIZE(names))\r\nreturn "UNKNOWN";\r\nreturn names[state];\r\n}\r\nstatic void gr_dbgprint_request(const char *str, struct gr_ep *ep,\r\nstruct gr_request *req)\r\n{\r\nint buflen = ep->is_in ? req->req.length : req->req.actual;\r\nint rowlen = 32;\r\nint plen = min(rowlen, buflen);\r\ndev_dbg(ep->dev->dev, "%s: 0x%p, %d bytes data%s:\n", str, req, buflen,\r\n(buflen > plen ? " (truncated)" : ""));\r\nprint_hex_dump_debug(" ", DUMP_PREFIX_NONE,\r\nrowlen, 4, req->req.buf, plen, false);\r\n}\r\nstatic void gr_dbgprint_devreq(struct gr_udc *dev, u8 type, u8 request,\r\nu16 value, u16 index, u16 length)\r\n{\r\ndev_vdbg(dev->dev, "REQ: %02x.%02x v%04x i%04x l%04x\n",\r\ntype, request, value, index, length);\r\n}\r\nstatic void gr_dbgprint_request(const char *str, struct gr_ep *ep,\r\nstruct gr_request *req) {}\r\nstatic void gr_dbgprint_devreq(struct gr_udc *dev, u8 type, u8 request,\r\nu16 value, u16 index, u16 length) {}\r\nstatic void gr_seq_ep_show(struct seq_file *seq, struct gr_ep *ep)\r\n{\r\nu32 epctrl = gr_read32(&ep->regs->epctrl);\r\nu32 epstat = gr_read32(&ep->regs->epstat);\r\nint mode = (epctrl & GR_EPCTRL_TT_MASK) >> GR_EPCTRL_TT_POS;\r\nstruct gr_request *req;\r\nseq_printf(seq, "%s:\n", ep->ep.name);\r\nseq_printf(seq, " mode = %s\n", gr_modestring[mode]);\r\nseq_printf(seq, " halted: %d\n", !!(epctrl & GR_EPCTRL_EH));\r\nseq_printf(seq, " disabled: %d\n", !!(epctrl & GR_EPCTRL_ED));\r\nseq_printf(seq, " valid: %d\n", !!(epctrl & GR_EPCTRL_EV));\r\nseq_printf(seq, " dma_start = %d\n", ep->dma_start);\r\nseq_printf(seq, " stopped = %d\n", ep->stopped);\r\nseq_printf(seq, " wedged = %d\n", ep->wedged);\r\nseq_printf(seq, " callback = %d\n", ep->callback);\r\nseq_printf(seq, " maxpacket = %d\n", ep->ep.maxpacket);\r\nseq_printf(seq, " maxpacket_limit = %d\n", ep->ep.maxpacket_limit);\r\nseq_printf(seq, " bytes_per_buffer = %d\n", ep->bytes_per_buffer);\r\nif (mode == 1 || mode == 3)\r\nseq_printf(seq, " nt = %d\n",\r\n(epctrl & GR_EPCTRL_NT_MASK) >> GR_EPCTRL_NT_POS);\r\nseq_printf(seq, " Buffer 0: %s %s%d\n",\r\nepstat & GR_EPSTAT_B0 ? "valid" : "invalid",\r\nepstat & GR_EPSTAT_BS ? " " : "selected ",\r\n(epstat & GR_EPSTAT_B0CNT_MASK) >> GR_EPSTAT_B0CNT_POS);\r\nseq_printf(seq, " Buffer 1: %s %s%d\n",\r\nepstat & GR_EPSTAT_B1 ? "valid" : "invalid",\r\nepstat & GR_EPSTAT_BS ? "selected " : " ",\r\n(epstat & GR_EPSTAT_B1CNT_MASK) >> GR_EPSTAT_B1CNT_POS);\r\nif (list_empty(&ep->queue)) {\r\nseq_puts(seq, " Queue: empty\n\n");\r\nreturn;\r\n}\r\nseq_puts(seq, " Queue:\n");\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\nstruct gr_dma_desc *desc;\r\nstruct gr_dma_desc *next;\r\nseq_printf(seq, " 0x%p: 0x%p %d %d\n", req,\r\n&req->req.buf, req->req.actual, req->req.length);\r\nnext = req->first_desc;\r\ndo {\r\ndesc = next;\r\nnext = desc->next_desc;\r\nseq_printf(seq, " %c 0x%p (0x%08x): 0x%05x 0x%08x\n",\r\ndesc == req->curr_desc ? 'c' : ' ',\r\ndesc, desc->paddr, desc->ctrl, desc->data);\r\n} while (desc != req->last_desc);\r\n}\r\nseq_puts(seq, "\n");\r\n}\r\nstatic int gr_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct gr_udc *dev = seq->private;\r\nu32 control = gr_read32(&dev->regs->control);\r\nu32 status = gr_read32(&dev->regs->status);\r\nstruct gr_ep *ep;\r\nseq_printf(seq, "usb state = %s\n",\r\nusb_state_string(dev->gadget.state));\r\nseq_printf(seq, "address = %d\n",\r\n(control & GR_CONTROL_UA_MASK) >> GR_CONTROL_UA_POS);\r\nseq_printf(seq, "speed = %s\n", GR_SPEED_STR(status));\r\nseq_printf(seq, "ep0state = %s\n", gr_ep0state_string(dev->ep0state));\r\nseq_printf(seq, "irq_enabled = %d\n", dev->irq_enabled);\r\nseq_printf(seq, "remote_wakeup = %d\n", dev->remote_wakeup);\r\nseq_printf(seq, "test_mode = %d\n", dev->test_mode);\r\nseq_puts(seq, "\n");\r\nlist_for_each_entry(ep, &dev->ep_list, ep_list)\r\ngr_seq_ep_show(seq, ep);\r\nreturn 0;\r\n}\r\nstatic int gr_dfs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, gr_seq_show, inode->i_private);\r\n}\r\nstatic void gr_dfs_create(struct gr_udc *dev)\r\n{\r\nconst char *name = "gr_udc_state";\r\ndev->dfs_root = debugfs_create_dir(dev_name(dev->dev), NULL);\r\ndev->dfs_state = debugfs_create_file(name, 0444, dev->dfs_root, dev,\r\n&gr_dfs_fops);\r\n}\r\nstatic void gr_dfs_delete(struct gr_udc *dev)\r\n{\r\ndebugfs_remove(dev->dfs_state);\r\ndebugfs_remove(dev->dfs_root);\r\n}\r\nstatic void gr_dfs_create(struct gr_udc *dev) {}\r\nstatic void gr_dfs_delete(struct gr_udc *dev) {}\r\nstatic struct gr_dma_desc *gr_alloc_dma_desc(struct gr_ep *ep, gfp_t gfp_flags)\r\n{\r\ndma_addr_t paddr;\r\nstruct gr_dma_desc *dma_desc;\r\ndma_desc = dma_pool_zalloc(ep->dev->desc_pool, gfp_flags, &paddr);\r\nif (!dma_desc) {\r\ndev_err(ep->dev->dev, "Could not allocate from DMA pool\n");\r\nreturn NULL;\r\n}\r\ndma_desc->paddr = paddr;\r\nreturn dma_desc;\r\n}\r\nstatic inline void gr_free_dma_desc(struct gr_udc *dev,\r\nstruct gr_dma_desc *desc)\r\n{\r\ndma_pool_free(dev->desc_pool, desc, (dma_addr_t)desc->paddr);\r\n}\r\nstatic void gr_free_dma_desc_chain(struct gr_udc *dev, struct gr_request *req)\r\n{\r\nstruct gr_dma_desc *desc;\r\nstruct gr_dma_desc *next;\r\nnext = req->first_desc;\r\nif (!next)\r\nreturn;\r\ndo {\r\ndesc = next;\r\nnext = desc->next_desc;\r\ngr_free_dma_desc(dev, desc);\r\n} while (desc != req->last_desc);\r\nreq->first_desc = NULL;\r\nreq->curr_desc = NULL;\r\nreq->last_desc = NULL;\r\n}\r\nstatic void gr_finish_request(struct gr_ep *ep, struct gr_request *req,\r\nint status)\r\n__releases(&dev->lock\r\nstatic struct usb_request *gr_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)\r\n{\r\nstruct gr_request *req;\r\nreq = kzalloc(sizeof(*req), gfp_flags);\r\nif (!req)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&req->queue);\r\nreturn &req->req;\r\n}\r\nstatic void gr_start_dma(struct gr_ep *ep)\r\n{\r\nstruct gr_request *req;\r\nu32 dmactrl;\r\nif (list_empty(&ep->queue)) {\r\nep->dma_start = 0;\r\nreturn;\r\n}\r\nreq = list_first_entry(&ep->queue, struct gr_request, queue);\r\nBUG_ON(!req->curr_desc);\r\nif (!ep->is_in && req->oddlen)\r\nreq->last_desc->data = ep->tailbuf_paddr;\r\nwmb();\r\ngr_write32(&ep->regs->dmaaddr, req->curr_desc->paddr);\r\ndmactrl = gr_read32(&ep->regs->dmactrl);\r\ngr_write32(&ep->regs->dmactrl, dmactrl | GR_DMACTRL_DA);\r\nep->dma_start = 1;\r\n}\r\nstatic void gr_dma_advance(struct gr_ep *ep, int status)\r\n{\r\nstruct gr_request *req;\r\nreq = list_first_entry(&ep->queue, struct gr_request, queue);\r\ngr_finish_request(ep, req, status);\r\ngr_start_dma(ep);\r\n}\r\nstatic void gr_abort_dma(struct gr_ep *ep)\r\n{\r\nu32 dmactrl;\r\ndmactrl = gr_read32(&ep->regs->dmactrl);\r\ngr_write32(&ep->regs->dmactrl, dmactrl | GR_DMACTRL_AD);\r\n}\r\nstatic int gr_add_dma_desc(struct gr_ep *ep, struct gr_request *req,\r\ndma_addr_t data, unsigned size, gfp_t gfp_flags)\r\n{\r\nstruct gr_dma_desc *desc;\r\ndesc = gr_alloc_dma_desc(ep, gfp_flags);\r\nif (!desc)\r\nreturn -ENOMEM;\r\ndesc->data = data;\r\nif (ep->is_in)\r\ndesc->ctrl =\r\n(GR_DESC_IN_CTRL_LEN_MASK & size) | GR_DESC_IN_CTRL_EN;\r\nelse\r\ndesc->ctrl = GR_DESC_OUT_CTRL_IE;\r\nif (!req->first_desc) {\r\nreq->first_desc = desc;\r\nreq->curr_desc = desc;\r\n} else {\r\nreq->last_desc->next_desc = desc;\r\nreq->last_desc->next = desc->paddr;\r\nreq->last_desc->ctrl |= GR_DESC_OUT_CTRL_NX;\r\n}\r\nreq->last_desc = desc;\r\nreturn 0;\r\n}\r\nstatic int gr_setup_out_desc_list(struct gr_ep *ep, struct gr_request *req,\r\ngfp_t gfp_flags)\r\n{\r\nu16 bytes_left;\r\nu16 bytes_used;\r\nint ret = 0;\r\nreq->first_desc = NULL;\r\nbytes_left = req->req.length;\r\nbytes_used = 0;\r\nwhile (bytes_left > 0) {\r\ndma_addr_t start = req->req.dma + bytes_used;\r\nu16 size = min(bytes_left, ep->bytes_per_buffer);\r\nif (size < ep->bytes_per_buffer) {\r\nreq->evenlen = req->req.length - bytes_left;\r\nreq->oddlen = size;\r\n}\r\nret = gr_add_dma_desc(ep, req, start, size, gfp_flags);\r\nif (ret)\r\ngoto alloc_err;\r\nbytes_left -= size;\r\nbytes_used += size;\r\n}\r\nreq->first_desc->ctrl |= GR_DESC_OUT_CTRL_EN;\r\nreturn 0;\r\nalloc_err:\r\ngr_free_dma_desc_chain(ep->dev, req);\r\nreturn ret;\r\n}\r\nstatic int gr_setup_in_desc_list(struct gr_ep *ep, struct gr_request *req,\r\ngfp_t gfp_flags)\r\n{\r\nu16 bytes_left;\r\nu16 bytes_used;\r\nint ret = 0;\r\nreq->first_desc = NULL;\r\nbytes_left = req->req.length;\r\nbytes_used = 0;\r\ndo {\r\ndma_addr_t start = req->req.dma + bytes_used;\r\nu16 size = min(bytes_left, ep->bytes_per_buffer);\r\nret = gr_add_dma_desc(ep, req, start, size, gfp_flags);\r\nif (ret)\r\ngoto alloc_err;\r\nbytes_left -= size;\r\nbytes_used += size;\r\n} while (bytes_left > 0);\r\nif (req->req.zero && (req->req.length % ep->ep.maxpacket == 0)) {\r\nret = gr_add_dma_desc(ep, req, 0, 0, gfp_flags);\r\nif (ret)\r\ngoto alloc_err;\r\n}\r\nreq->last_desc->ctrl |= GR_DESC_IN_CTRL_PI;\r\nreturn 0;\r\nalloc_err:\r\ngr_free_dma_desc_chain(ep->dev, req);\r\nreturn ret;\r\n}\r\nstatic int gr_queue(struct gr_ep *ep, struct gr_request *req, gfp_t gfp_flags)\r\n{\r\nstruct gr_udc *dev = ep->dev;\r\nint ret;\r\nif (unlikely(!ep->ep.desc && ep->num != 0)) {\r\ndev_err(dev->dev, "No ep descriptor for %s\n", ep->ep.name);\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(!req->req.buf || !list_empty(&req->queue))) {\r\ndev_err(dev->dev,\r\n"Invalid request for %s: buf=%p list_empty=%d\n",\r\nep->ep.name, req->req.buf, list_empty(&req->queue));\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)) {\r\ndev_err(dev->dev, "-ESHUTDOWN");\r\nreturn -ESHUTDOWN;\r\n}\r\nif (dev->ep0state == GR_EP0_SUSPEND) {\r\ndev_err(dev->dev, "-EBUSY");\r\nreturn -EBUSY;\r\n}\r\nret = usb_gadget_map_request(&dev->gadget, &req->req, ep->is_in);\r\nif (ret) {\r\ndev_err(dev->dev, "usb_gadget_map_request");\r\nreturn ret;\r\n}\r\nif (ep->is_in)\r\nret = gr_setup_in_desc_list(ep, req, gfp_flags);\r\nelse\r\nret = gr_setup_out_desc_list(ep, req, gfp_flags);\r\nif (ret)\r\nreturn ret;\r\nreq->req.status = -EINPROGRESS;\r\nreq->req.actual = 0;\r\nlist_add_tail(&req->queue, &ep->queue);\r\nif (!ep->dma_start && likely(!ep->stopped))\r\ngr_start_dma(ep);\r\nreturn 0;\r\n}\r\nstatic inline int gr_queue_int(struct gr_ep *ep, struct gr_request *req,\r\ngfp_t gfp_flags)\r\n{\r\nif (ep->is_in)\r\ngr_dbgprint_request("RESP", ep, req);\r\nreturn gr_queue(ep, req, gfp_flags);\r\n}\r\nstatic void gr_ep_nuke(struct gr_ep *ep)\r\n{\r\nstruct gr_request *req;\r\nep->stopped = 1;\r\nep->dma_start = 0;\r\ngr_abort_dma(ep);\r\nwhile (!list_empty(&ep->queue)) {\r\nreq = list_first_entry(&ep->queue, struct gr_request, queue);\r\ngr_finish_request(ep, req, -ESHUTDOWN);\r\n}\r\n}\r\nstatic void gr_ep_reset(struct gr_ep *ep)\r\n{\r\ngr_write32(&ep->regs->epctrl, 0);\r\ngr_write32(&ep->regs->dmactrl, 0);\r\nep->ep.maxpacket = MAX_CTRL_PL_SIZE;\r\nep->ep.desc = NULL;\r\nep->stopped = 1;\r\nep->dma_start = 0;\r\n}\r\nstatic void gr_control_stall(struct gr_udc *dev)\r\n{\r\nu32 epctrl;\r\nepctrl = gr_read32(&dev->epo[0].regs->epctrl);\r\ngr_write32(&dev->epo[0].regs->epctrl, epctrl | GR_EPCTRL_CS);\r\nepctrl = gr_read32(&dev->epi[0].regs->epctrl);\r\ngr_write32(&dev->epi[0].regs->epctrl, epctrl | GR_EPCTRL_CS);\r\ndev->ep0state = GR_EP0_STALL;\r\n}\r\nstatic int gr_ep_halt_wedge(struct gr_ep *ep, int halt, int wedge, int fromhost)\r\n{\r\nu32 epctrl;\r\nint retval = 0;\r\nif (ep->num && !ep->ep.desc)\r\nreturn -EINVAL;\r\nif (ep->num && ep->ep.desc->bmAttributes == USB_ENDPOINT_XFER_ISOC)\r\nreturn -EOPNOTSUPP;\r\nif (!ep->num) {\r\nif (halt && !fromhost) {\r\ngr_control_stall(ep->dev);\r\ndev_dbg(ep->dev->dev, "EP: stall ep0\n");\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(ep->dev->dev, "EP: %s halt %s\n",\r\n(halt ? (wedge ? "wedge" : "set") : "clear"), ep->ep.name);\r\nepctrl = gr_read32(&ep->regs->epctrl);\r\nif (halt) {\r\ngr_write32(&ep->regs->epctrl, epctrl | GR_EPCTRL_EH);\r\nep->stopped = 1;\r\nif (wedge)\r\nep->wedged = 1;\r\n} else {\r\ngr_write32(&ep->regs->epctrl, epctrl & ~GR_EPCTRL_EH);\r\nep->stopped = 0;\r\nep->wedged = 0;\r\nif (!ep->dma_start)\r\ngr_start_dma(ep);\r\n}\r\nreturn retval;\r\n}\r\nstatic inline void gr_set_ep0state(struct gr_udc *dev, enum gr_ep0state value)\r\n{\r\nif (dev->ep0state != value)\r\ndev_vdbg(dev->dev, "STATE: ep0state=%s\n",\r\ngr_ep0state_string(value));\r\ndev->ep0state = value;\r\n}\r\nstatic void gr_disable_interrupts_and_pullup(struct gr_udc *dev)\r\n{\r\ngr_write32(&dev->regs->control, 0);\r\nwmb();\r\ndev->irq_enabled = 0;\r\n}\r\nstatic void gr_stop_activity(struct gr_udc *dev)\r\n{\r\nstruct gr_ep *ep;\r\nlist_for_each_entry(ep, &dev->ep_list, ep_list)\r\ngr_ep_nuke(ep);\r\ngr_disable_interrupts_and_pullup(dev);\r\ngr_set_ep0state(dev, GR_EP0_DISCONNECT);\r\nusb_gadget_set_state(&dev->gadget, USB_STATE_NOTATTACHED);\r\n}\r\nstatic void gr_ep0_testmode_complete(struct usb_ep *_ep,\r\nstruct usb_request *_req)\r\n{\r\nstruct gr_ep *ep;\r\nstruct gr_udc *dev;\r\nu32 control;\r\nep = container_of(_ep, struct gr_ep, ep);\r\ndev = ep->dev;\r\nspin_lock(&dev->lock);\r\ncontrol = gr_read32(&dev->regs->control);\r\ncontrol |= GR_CONTROL_TM | (dev->test_mode << GR_CONTROL_TS_POS);\r\ngr_write32(&dev->regs->control, control);\r\nspin_unlock(&dev->lock);\r\n}\r\nstatic void gr_ep0_dummy_complete(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\n}\r\nstatic int gr_ep0_respond(struct gr_udc *dev, u8 *buf, int length,\r\nvoid (*complete)(struct usb_ep *ep,\r\nstruct usb_request *req))\r\n{\r\nu8 *reqbuf = dev->ep0reqi->req.buf;\r\nint status;\r\nint i;\r\nfor (i = 0; i < length; i++)\r\nreqbuf[i] = buf[i];\r\ndev->ep0reqi->req.length = length;\r\ndev->ep0reqi->req.complete = complete;\r\nstatus = gr_queue_int(&dev->epi[0], dev->ep0reqi, GFP_ATOMIC);\r\nif (status < 0)\r\ndev_err(dev->dev,\r\n"Could not queue ep0in setup response: %d\n", status);\r\nreturn status;\r\n}\r\nstatic inline int gr_ep0_respond_u16(struct gr_udc *dev, u16 response)\r\n{\r\n__le16 le_response = cpu_to_le16(response);\r\nreturn gr_ep0_respond(dev, (u8 *)&le_response, 2,\r\ngr_ep0_dummy_complete);\r\n}\r\nstatic inline int gr_ep0_respond_empty(struct gr_udc *dev)\r\n{\r\nreturn gr_ep0_respond(dev, NULL, 0, gr_ep0_dummy_complete);\r\n}\r\nstatic void gr_set_address(struct gr_udc *dev, u8 address)\r\n{\r\nu32 control;\r\ncontrol = gr_read32(&dev->regs->control) & ~GR_CONTROL_UA_MASK;\r\ncontrol |= (address << GR_CONTROL_UA_POS) & GR_CONTROL_UA_MASK;\r\ncontrol |= GR_CONTROL_SU;\r\ngr_write32(&dev->regs->control, control);\r\n}\r\nstatic int gr_device_request(struct gr_udc *dev, u8 type, u8 request,\r\nu16 value, u16 index)\r\n{\r\nu16 response;\r\nu8 test;\r\nswitch (request) {\r\ncase USB_REQ_SET_ADDRESS:\r\ndev_dbg(dev->dev, "STATUS: address %d\n", value & 0xff);\r\ngr_set_address(dev, value & 0xff);\r\nif (value)\r\nusb_gadget_set_state(&dev->gadget, USB_STATE_ADDRESS);\r\nelse\r\nusb_gadget_set_state(&dev->gadget, USB_STATE_DEFAULT);\r\nreturn gr_ep0_respond_empty(dev);\r\ncase USB_REQ_GET_STATUS:\r\nresponse = 0x0001 | (dev->remote_wakeup ? 0x0002 : 0);\r\nreturn gr_ep0_respond_u16(dev, response);\r\ncase USB_REQ_SET_FEATURE:\r\nswitch (value) {\r\ncase USB_DEVICE_REMOTE_WAKEUP:\r\ndev->remote_wakeup = 1;\r\nreturn gr_ep0_respond_empty(dev);\r\ncase USB_DEVICE_TEST_MODE:\r\ntest = index >> 8;\r\nif (test >= TEST_J && test <= TEST_PACKET) {\r\ndev->test_mode = test;\r\nreturn gr_ep0_respond(dev, NULL, 0,\r\ngr_ep0_testmode_complete);\r\n}\r\n}\r\nbreak;\r\ncase USB_REQ_CLEAR_FEATURE:\r\nswitch (value) {\r\ncase USB_DEVICE_REMOTE_WAKEUP:\r\ndev->remote_wakeup = 0;\r\nreturn gr_ep0_respond_empty(dev);\r\n}\r\nbreak;\r\n}\r\nreturn 1;\r\n}\r\nstatic int gr_interface_request(struct gr_udc *dev, u8 type, u8 request,\r\nu16 value, u16 index)\r\n{\r\nif (dev->gadget.state != USB_STATE_CONFIGURED)\r\nreturn -1;\r\nswitch (request) {\r\ncase USB_REQ_GET_STATUS:\r\nreturn gr_ep0_respond_u16(dev, 0x0000);\r\ncase USB_REQ_SET_FEATURE:\r\ncase USB_REQ_CLEAR_FEATURE:\r\nbreak;\r\n}\r\nreturn 1;\r\n}\r\nstatic int gr_endpoint_request(struct gr_udc *dev, u8 type, u8 request,\r\nu16 value, u16 index)\r\n{\r\nstruct gr_ep *ep;\r\nint status;\r\nint halted;\r\nu8 epnum = index & USB_ENDPOINT_NUMBER_MASK;\r\nu8 is_in = index & USB_ENDPOINT_DIR_MASK;\r\nif ((is_in && epnum >= dev->nepi) || (!is_in && epnum >= dev->nepo))\r\nreturn -1;\r\nif (dev->gadget.state != USB_STATE_CONFIGURED && epnum != 0)\r\nreturn -1;\r\nep = (is_in ? &dev->epi[epnum] : &dev->epo[epnum]);\r\nswitch (request) {\r\ncase USB_REQ_GET_STATUS:\r\nhalted = gr_read32(&ep->regs->epctrl) & GR_EPCTRL_EH;\r\nreturn gr_ep0_respond_u16(dev, halted ? 0x0001 : 0);\r\ncase USB_REQ_SET_FEATURE:\r\nswitch (value) {\r\ncase USB_ENDPOINT_HALT:\r\nstatus = gr_ep_halt_wedge(ep, 1, 0, 1);\r\nif (status >= 0)\r\nstatus = gr_ep0_respond_empty(dev);\r\nreturn status;\r\n}\r\nbreak;\r\ncase USB_REQ_CLEAR_FEATURE:\r\nswitch (value) {\r\ncase USB_ENDPOINT_HALT:\r\nif (ep->wedged)\r\nreturn -1;\r\nstatus = gr_ep_halt_wedge(ep, 0, 0, 1);\r\nif (status >= 0)\r\nstatus = gr_ep0_respond_empty(dev);\r\nreturn status;\r\n}\r\nbreak;\r\n}\r\nreturn 1;\r\n}\r\nstatic void gr_ep0out_requeue(struct gr_udc *dev)\r\n{\r\nint ret = gr_queue_int(&dev->epo[0], dev->ep0reqo, GFP_ATOMIC);\r\nif (ret)\r\ndev_err(dev->dev, "Could not queue ep0out setup request: %d\n",\r\nret);\r\n}\r\nstatic void gr_ep0_setup(struct gr_udc *dev, struct gr_request *req)\r\n__releases(&dev->lock\r\nstatic void gr_vbus_connected(struct gr_udc *dev, u32 status)\r\n{\r\nu32 control;\r\ndev->gadget.speed = GR_SPEED(status);\r\nusb_gadget_set_state(&dev->gadget, USB_STATE_POWERED);\r\ncontrol = (GR_CONTROL_SI | GR_CONTROL_UI | GR_CONTROL_VI |\r\nGR_CONTROL_SP | GR_CONTROL_EP);\r\ngr_write32(&dev->regs->control, control);\r\n}\r\nstatic void gr_enable_vbus_detect(struct gr_udc *dev)\r\n{\r\nu32 status;\r\ndev->irq_enabled = 1;\r\nwmb();\r\ngr_write32(&dev->regs->control, GR_CONTROL_VI);\r\nstatus = gr_read32(&dev->regs->status);\r\nif (status & GR_STATUS_VB)\r\ngr_vbus_connected(dev, status);\r\n}\r\nstatic void gr_vbus_disconnected(struct gr_udc *dev)\r\n{\r\ngr_stop_activity(dev);\r\nif (dev->driver && dev->driver->disconnect) {\r\nspin_unlock(&dev->lock);\r\ndev->driver->disconnect(&dev->gadget);\r\nspin_lock(&dev->lock);\r\n}\r\ngr_enable_vbus_detect(dev);\r\n}\r\nstatic void gr_udc_usbreset(struct gr_udc *dev, u32 status)\r\n{\r\ngr_set_address(dev, 0);\r\ngr_set_ep0state(dev, GR_EP0_SETUP);\r\nusb_gadget_set_state(&dev->gadget, USB_STATE_DEFAULT);\r\ndev->gadget.speed = GR_SPEED(status);\r\ngr_ep_nuke(&dev->epo[0]);\r\ngr_ep_nuke(&dev->epi[0]);\r\ndev->epo[0].stopped = 0;\r\ndev->epi[0].stopped = 0;\r\ngr_ep0out_requeue(dev);\r\n}\r\nstatic int gr_handle_in_ep(struct gr_ep *ep)\r\n{\r\nstruct gr_request *req;\r\nreq = list_first_entry(&ep->queue, struct gr_request, queue);\r\nif (!req->last_desc)\r\nreturn 0;\r\nif (ACCESS_ONCE(req->last_desc->ctrl) & GR_DESC_IN_CTRL_EN)\r\nreturn 0;\r\nif (gr_read32(&ep->regs->epstat) & (GR_EPSTAT_B1 | GR_EPSTAT_B0))\r\nreturn 0;\r\ngr_dma_advance(ep, 0);\r\nreturn 1;\r\n}\r\nstatic int gr_handle_out_ep(struct gr_ep *ep)\r\n{\r\nu32 ep_dmactrl;\r\nu32 ctrl;\r\nu16 len;\r\nstruct gr_request *req;\r\nstruct gr_udc *dev = ep->dev;\r\nreq = list_first_entry(&ep->queue, struct gr_request, queue);\r\nif (!req->curr_desc)\r\nreturn 0;\r\nctrl = ACCESS_ONCE(req->curr_desc->ctrl);\r\nif (ctrl & GR_DESC_OUT_CTRL_EN)\r\nreturn 0;\r\nlen = ctrl & GR_DESC_OUT_CTRL_LEN_MASK;\r\nreq->req.actual += len;\r\nif (ctrl & GR_DESC_OUT_CTRL_SE)\r\nreq->setup = 1;\r\nif (len < ep->ep.maxpacket || req->req.actual >= req->req.length) {\r\nif ((ep == &dev->epo[0]) && (dev->ep0state == GR_EP0_OSTATUS)) {\r\ngr_ep0_respond_empty(dev);\r\ngr_set_ep0state(dev, GR_EP0_SETUP);\r\n}\r\ngr_dma_advance(ep, 0);\r\n} else {\r\nreq->curr_desc = req->curr_desc->next_desc;\r\nreq->curr_desc->ctrl |= GR_DESC_OUT_CTRL_EN;\r\nep_dmactrl = gr_read32(&ep->regs->dmactrl);\r\ngr_write32(&ep->regs->dmactrl, ep_dmactrl | GR_DMACTRL_DA);\r\n}\r\nreturn 1;\r\n}\r\nstatic int gr_handle_state_changes(struct gr_udc *dev)\r\n{\r\nu32 status = gr_read32(&dev->regs->status);\r\nint handled = 0;\r\nint powstate = !(dev->gadget.state == USB_STATE_NOTATTACHED ||\r\ndev->gadget.state == USB_STATE_ATTACHED);\r\nif (!powstate && (status & GR_STATUS_VB)) {\r\ndev_dbg(dev->dev, "STATUS: vbus valid detected\n");\r\ngr_vbus_connected(dev, status);\r\nhandled = 1;\r\n}\r\nif (powstate && !(status & GR_STATUS_VB)) {\r\ndev_dbg(dev->dev, "STATUS: vbus invalid detected\n");\r\ngr_vbus_disconnected(dev);\r\nhandled = 1;\r\n}\r\nif (status & GR_STATUS_UR) {\r\ndev_dbg(dev->dev, "STATUS: USB reset - speed is %s\n",\r\nGR_SPEED_STR(status));\r\ngr_write32(&dev->regs->status, GR_STATUS_UR);\r\ngr_udc_usbreset(dev, status);\r\nhandled = 1;\r\n}\r\nif (dev->gadget.speed != GR_SPEED(status)) {\r\ndev_dbg(dev->dev, "STATUS: USB Speed change to %s\n",\r\nGR_SPEED_STR(status));\r\ndev->gadget.speed = GR_SPEED(status);\r\nhandled = 1;\r\n}\r\nif ((dev->ep0state != GR_EP0_SUSPEND) && !(status & GR_STATUS_SU)) {\r\ndev_dbg(dev->dev, "STATUS: USB suspend\n");\r\ngr_set_ep0state(dev, GR_EP0_SUSPEND);\r\ndev->suspended_from = dev->gadget.state;\r\nusb_gadget_set_state(&dev->gadget, USB_STATE_SUSPENDED);\r\nif ((dev->gadget.speed != USB_SPEED_UNKNOWN) &&\r\ndev->driver && dev->driver->suspend) {\r\nspin_unlock(&dev->lock);\r\ndev->driver->suspend(&dev->gadget);\r\nspin_lock(&dev->lock);\r\n}\r\nhandled = 1;\r\n}\r\nif ((dev->ep0state == GR_EP0_SUSPEND) && (status & GR_STATUS_SU)) {\r\ndev_dbg(dev->dev, "STATUS: USB resume\n");\r\nif (dev->suspended_from == USB_STATE_POWERED)\r\ngr_set_ep0state(dev, GR_EP0_DISCONNECT);\r\nelse\r\ngr_set_ep0state(dev, GR_EP0_SETUP);\r\nusb_gadget_set_state(&dev->gadget, dev->suspended_from);\r\nif ((dev->gadget.speed != USB_SPEED_UNKNOWN) &&\r\ndev->driver && dev->driver->resume) {\r\nspin_unlock(&dev->lock);\r\ndev->driver->resume(&dev->gadget);\r\nspin_lock(&dev->lock);\r\n}\r\nhandled = 1;\r\n}\r\nreturn handled;\r\n}\r\nstatic irqreturn_t gr_irq_handler(int irq, void *_dev)\r\n{\r\nstruct gr_udc *dev = _dev;\r\nstruct gr_ep *ep;\r\nint handled = 0;\r\nint i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->lock, flags);\r\nif (!dev->irq_enabled)\r\ngoto out;\r\nfor (i = 0; i < dev->nepi; i++) {\r\nep = &dev->epi[i];\r\nif (!ep->stopped && !ep->callback && !list_empty(&ep->queue))\r\nhandled = gr_handle_in_ep(ep) || handled;\r\n}\r\nfor (i = 0; i < dev->nepo; i++) {\r\nep = &dev->epo[i];\r\nif (!ep->stopped && !ep->callback && !list_empty(&ep->queue))\r\nhandled = gr_handle_out_ep(ep) || handled;\r\n}\r\nhandled = gr_handle_state_changes(dev) || handled;\r\nif (!handled) {\r\nlist_for_each_entry(ep, &dev->ep_list, ep_list) {\r\nif (gr_read32(&ep->regs->dmactrl) & GR_DMACTRL_AE) {\r\ndev_err(dev->dev,\r\n"AMBA Error occurred for %s\n",\r\nep->ep.name);\r\nhandled = 1;\r\n}\r\n}\r\n}\r\nout:\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn handled ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic irqreturn_t gr_irq(int irq, void *_dev)\r\n{\r\nstruct gr_udc *dev = _dev;\r\nif (!dev->irq_enabled)\r\nreturn IRQ_NONE;\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic int gr_ep_enable(struct usb_ep *_ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct gr_udc *dev;\r\nstruct gr_ep *ep;\r\nu8 mode;\r\nu8 nt;\r\nu16 max;\r\nu16 buffer_size = 0;\r\nu32 epctrl;\r\nep = container_of(_ep, struct gr_ep, ep);\r\nif (!_ep || !desc || desc->bDescriptorType != USB_DT_ENDPOINT)\r\nreturn -EINVAL;\r\ndev = ep->dev;\r\nif (ep == &dev->epo[0] || ep == &dev->epi[0])\r\nreturn -EINVAL;\r\nif (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn -ESHUTDOWN;\r\nepctrl = gr_read32(&ep->regs->epctrl);\r\nif (epctrl & GR_EPCTRL_EV)\r\nreturn -EBUSY;\r\nif (!ep->is_in != !usb_endpoint_dir_in(desc))\r\nreturn -EINVAL;\r\nif ((!ep->is_in && ep->num >= dev->nepo) ||\r\n(ep->is_in && ep->num >= dev->nepi))\r\nreturn -EINVAL;\r\nif (usb_endpoint_xfer_control(desc)) {\r\nmode = 0;\r\n} else if (usb_endpoint_xfer_isoc(desc)) {\r\nmode = 1;\r\n} else if (usb_endpoint_xfer_bulk(desc)) {\r\nmode = 2;\r\n} else if (usb_endpoint_xfer_int(desc)) {\r\nmode = 3;\r\n} else {\r\ndev_err(dev->dev, "Unknown transfer type for %s\n",\r\nep->ep.name);\r\nreturn -EINVAL;\r\n}\r\nmax = 0x7ff & usb_endpoint_maxp(desc);\r\nnt = usb_endpoint_maxp_mult(desc) - 1;\r\nbuffer_size = GR_BUFFER_SIZE(epctrl);\r\nif (nt && (mode == 0 || mode == 2)) {\r\ndev_err(dev->dev,\r\n"%s mode: multiple trans./microframe not valid\n",\r\n(mode == 2 ? "Bulk" : "Control"));\r\nreturn -EINVAL;\r\n} else if (nt == 0x3) {\r\ndev_err(dev->dev,\r\n"Invalid value 0x3 for additional trans./microframe\n");\r\nreturn -EINVAL;\r\n} else if ((nt + 1) * max > buffer_size) {\r\ndev_err(dev->dev, "Hw buffer size %d < max payload %d * %d\n",\r\nbuffer_size, (nt + 1), max);\r\nreturn -EINVAL;\r\n} else if (max == 0) {\r\ndev_err(dev->dev, "Max payload cannot be set to 0\n");\r\nreturn -EINVAL;\r\n} else if (max > ep->ep.maxpacket_limit) {\r\ndev_err(dev->dev, "Requested max payload %d > limit %d\n",\r\nmax, ep->ep.maxpacket_limit);\r\nreturn -EINVAL;\r\n}\r\nspin_lock(&ep->dev->lock);\r\nif (!ep->stopped) {\r\nspin_unlock(&ep->dev->lock);\r\nreturn -EBUSY;\r\n}\r\nep->stopped = 0;\r\nep->wedged = 0;\r\nep->ep.desc = desc;\r\nep->ep.maxpacket = max;\r\nep->dma_start = 0;\r\nif (nt) {\r\nep->bytes_per_buffer = (nt + 1) * max;\r\n} else if (ep->is_in) {\r\nep->bytes_per_buffer = (buffer_size / max) * max;\r\n} else {\r\nep->bytes_per_buffer = max;\r\n}\r\nepctrl = (max << GR_EPCTRL_MAXPL_POS)\r\n| (nt << GR_EPCTRL_NT_POS)\r\n| (mode << GR_EPCTRL_TT_POS)\r\n| GR_EPCTRL_EV;\r\nif (ep->is_in)\r\nepctrl |= GR_EPCTRL_PI;\r\ngr_write32(&ep->regs->epctrl, epctrl);\r\ngr_write32(&ep->regs->dmactrl, GR_DMACTRL_IE | GR_DMACTRL_AI);\r\nspin_unlock(&ep->dev->lock);\r\ndev_dbg(ep->dev->dev, "EP: %s enabled - %s with %d bytes/buffer\n",\r\nep->ep.name, gr_modestring[mode], ep->bytes_per_buffer);\r\nreturn 0;\r\n}\r\nstatic int gr_ep_disable(struct usb_ep *_ep)\r\n{\r\nstruct gr_ep *ep;\r\nstruct gr_udc *dev;\r\nunsigned long flags;\r\nep = container_of(_ep, struct gr_ep, ep);\r\nif (!_ep || !ep->ep.desc)\r\nreturn -ENODEV;\r\ndev = ep->dev;\r\nif (ep == &dev->epo[0] || ep == &dev->epi[0])\r\nreturn -EINVAL;\r\nif (dev->ep0state == GR_EP0_SUSPEND)\r\nreturn -EBUSY;\r\ndev_dbg(ep->dev->dev, "EP: disable %s\n", ep->ep.name);\r\nspin_lock_irqsave(&dev->lock, flags);\r\ngr_ep_nuke(ep);\r\ngr_ep_reset(ep);\r\nep->ep.desc = NULL;\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void gr_free_request(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct gr_request *req;\r\nif (!_ep || !_req)\r\nreturn;\r\nreq = container_of(_req, struct gr_request, req);\r\nWARN(!list_empty(&req->queue),\r\n"request not dequeued properly before freeing\n");\r\nkfree(req);\r\n}\r\nstatic int gr_queue_ext(struct usb_ep *_ep, struct usb_request *_req,\r\ngfp_t gfp_flags)\r\n{\r\nstruct gr_ep *ep;\r\nstruct gr_request *req;\r\nstruct gr_udc *dev;\r\nint ret;\r\nif (unlikely(!_ep || !_req))\r\nreturn -EINVAL;\r\nep = container_of(_ep, struct gr_ep, ep);\r\nreq = container_of(_req, struct gr_request, req);\r\ndev = ep->dev;\r\nspin_lock(&ep->dev->lock);\r\nif ((ep == &dev->epi[0]) && (dev->ep0state == GR_EP0_ODATA)) {\r\nep = &dev->epo[0];\r\nep->ep.driver_data = dev->epi[0].ep.driver_data;\r\n}\r\nif (ep->is_in)\r\ngr_dbgprint_request("EXTERN", ep, req);\r\nret = gr_queue(ep, req, GFP_ATOMIC);\r\nspin_unlock(&ep->dev->lock);\r\nreturn ret;\r\n}\r\nstatic int gr_dequeue(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct gr_request *req;\r\nstruct gr_ep *ep;\r\nstruct gr_udc *dev;\r\nint ret = 0;\r\nunsigned long flags;\r\nep = container_of(_ep, struct gr_ep, ep);\r\nif (!_ep || !_req || (!ep->ep.desc && ep->num != 0))\r\nreturn -EINVAL;\r\ndev = ep->dev;\r\nif (!dev->driver)\r\nreturn -ESHUTDOWN;\r\nif (dev->ep0state == GR_EP0_SUSPEND)\r\nreturn -EBUSY;\r\nspin_lock_irqsave(&dev->lock, flags);\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\nif (&req->req == _req)\r\nbreak;\r\n}\r\nif (&req->req != _req) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (list_first_entry(&ep->queue, struct gr_request, queue) == req) {\r\ngr_abort_dma(ep);\r\nif (ep->stopped)\r\ngr_finish_request(ep, req, -ECONNRESET);\r\nelse\r\ngr_dma_advance(ep, -ECONNRESET);\r\n} else if (!list_empty(&req->queue)) {\r\ngr_finish_request(ep, req, -ECONNRESET);\r\n} else {\r\nret = -EOPNOTSUPP;\r\n}\r\nout:\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int gr_set_halt_wedge(struct usb_ep *_ep, int halt, int wedge)\r\n{\r\nint ret;\r\nstruct gr_ep *ep;\r\nif (!_ep)\r\nreturn -ENODEV;\r\nep = container_of(_ep, struct gr_ep, ep);\r\nspin_lock(&ep->dev->lock);\r\nif (halt && ep->is_in && !list_empty(&ep->queue)) {\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\nret = gr_ep_halt_wedge(ep, halt, wedge, 0);\r\nout:\r\nspin_unlock(&ep->dev->lock);\r\nreturn ret;\r\n}\r\nstatic int gr_set_halt(struct usb_ep *_ep, int halt)\r\n{\r\nreturn gr_set_halt_wedge(_ep, halt, 0);\r\n}\r\nstatic int gr_set_wedge(struct usb_ep *_ep)\r\n{\r\nreturn gr_set_halt_wedge(_ep, 1, 1);\r\n}\r\nstatic int gr_fifo_status(struct usb_ep *_ep)\r\n{\r\nstruct gr_ep *ep;\r\nu32 epstat;\r\nu32 bytes = 0;\r\nif (!_ep)\r\nreturn -ENODEV;\r\nep = container_of(_ep, struct gr_ep, ep);\r\nepstat = gr_read32(&ep->regs->epstat);\r\nif (epstat & GR_EPSTAT_B0)\r\nbytes += (epstat & GR_EPSTAT_B0CNT_MASK) >> GR_EPSTAT_B0CNT_POS;\r\nif (epstat & GR_EPSTAT_B1)\r\nbytes += (epstat & GR_EPSTAT_B1CNT_MASK) >> GR_EPSTAT_B1CNT_POS;\r\nreturn bytes;\r\n}\r\nstatic void gr_fifo_flush(struct usb_ep *_ep)\r\n{\r\nstruct gr_ep *ep;\r\nu32 epctrl;\r\nif (!_ep)\r\nreturn;\r\nep = container_of(_ep, struct gr_ep, ep);\r\ndev_vdbg(ep->dev->dev, "EP: flush fifo %s\n", ep->ep.name);\r\nspin_lock(&ep->dev->lock);\r\nepctrl = gr_read32(&ep->regs->epctrl);\r\nepctrl |= GR_EPCTRL_CB;\r\ngr_write32(&ep->regs->epctrl, epctrl);\r\nspin_unlock(&ep->dev->lock);\r\n}\r\nstatic int gr_get_frame(struct usb_gadget *_gadget)\r\n{\r\nstruct gr_udc *dev;\r\nif (!_gadget)\r\nreturn -ENODEV;\r\ndev = container_of(_gadget, struct gr_udc, gadget);\r\nreturn gr_read32(&dev->regs->status) & GR_STATUS_FN_MASK;\r\n}\r\nstatic int gr_wakeup(struct usb_gadget *_gadget)\r\n{\r\nstruct gr_udc *dev;\r\nif (!_gadget)\r\nreturn -ENODEV;\r\ndev = container_of(_gadget, struct gr_udc, gadget);\r\nif (!dev->remote_wakeup)\r\nreturn -EINVAL;\r\nspin_lock(&dev->lock);\r\ngr_write32(&dev->regs->control,\r\ngr_read32(&dev->regs->control) | GR_CONTROL_RW);\r\nspin_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nstatic int gr_pullup(struct usb_gadget *_gadget, int is_on)\r\n{\r\nstruct gr_udc *dev;\r\nu32 control;\r\nif (!_gadget)\r\nreturn -ENODEV;\r\ndev = container_of(_gadget, struct gr_udc, gadget);\r\nspin_lock(&dev->lock);\r\ncontrol = gr_read32(&dev->regs->control);\r\nif (is_on)\r\ncontrol |= GR_CONTROL_EP;\r\nelse\r\ncontrol &= ~GR_CONTROL_EP;\r\ngr_write32(&dev->regs->control, control);\r\nspin_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nstatic int gr_udc_start(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct gr_udc *dev = to_gr_udc(gadget);\r\nspin_lock(&dev->lock);\r\ndriver->driver.bus = NULL;\r\ndev->driver = driver;\r\ngr_enable_vbus_detect(dev);\r\nspin_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nstatic int gr_udc_stop(struct usb_gadget *gadget)\r\n{\r\nstruct gr_udc *dev = to_gr_udc(gadget);\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->lock, flags);\r\ndev->driver = NULL;\r\ngr_stop_activity(dev);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int gr_ep_init(struct gr_udc *dev, int num, int is_in, u32 maxplimit)\r\n{\r\nstruct gr_ep *ep;\r\nstruct gr_request *req;\r\nstruct usb_request *_req;\r\nvoid *buf;\r\nif (is_in) {\r\nep = &dev->epi[num];\r\nep->ep.name = inames[num];\r\nep->regs = &dev->regs->epi[num];\r\n} else {\r\nep = &dev->epo[num];\r\nep->ep.name = onames[num];\r\nep->regs = &dev->regs->epo[num];\r\n}\r\ngr_ep_reset(ep);\r\nep->num = num;\r\nep->is_in = is_in;\r\nep->dev = dev;\r\nep->ep.ops = &gr_ep_ops;\r\nINIT_LIST_HEAD(&ep->queue);\r\nif (num == 0) {\r\n_req = gr_alloc_request(&ep->ep, GFP_ATOMIC);\r\nbuf = devm_kzalloc(dev->dev, PAGE_SIZE, GFP_DMA | GFP_ATOMIC);\r\nif (!_req || !buf) {\r\nreturn -ENOMEM;\r\n}\r\nreq = container_of(_req, struct gr_request, req);\r\nreq->req.buf = buf;\r\nreq->req.length = MAX_CTRL_PL_SIZE;\r\nif (is_in)\r\ndev->ep0reqi = req;\r\nelse\r\ndev->ep0reqo = req;\r\nusb_ep_set_maxpacket_limit(&ep->ep, MAX_CTRL_PL_SIZE);\r\nep->bytes_per_buffer = MAX_CTRL_PL_SIZE;\r\nep->ep.caps.type_control = true;\r\n} else {\r\nusb_ep_set_maxpacket_limit(&ep->ep, (u16)maxplimit);\r\nlist_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);\r\nep->ep.caps.type_iso = true;\r\nep->ep.caps.type_bulk = true;\r\nep->ep.caps.type_int = true;\r\n}\r\nlist_add_tail(&ep->ep_list, &dev->ep_list);\r\nif (is_in)\r\nep->ep.caps.dir_in = true;\r\nelse\r\nep->ep.caps.dir_out = true;\r\nep->tailbuf = dma_alloc_coherent(dev->dev, ep->ep.maxpacket_limit,\r\n&ep->tailbuf_paddr, GFP_ATOMIC);\r\nif (!ep->tailbuf)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int gr_udc_init(struct gr_udc *dev)\r\n{\r\nstruct device_node *np = dev->dev->of_node;\r\nu32 epctrl_val;\r\nu32 dmactrl_val;\r\nint i;\r\nint ret = 0;\r\nu32 bufsize;\r\ngr_set_address(dev, 0);\r\nINIT_LIST_HEAD(&dev->gadget.ep_list);\r\ndev->gadget.speed = USB_SPEED_UNKNOWN;\r\ndev->gadget.ep0 = &dev->epi[0].ep;\r\nINIT_LIST_HEAD(&dev->ep_list);\r\ngr_set_ep0state(dev, GR_EP0_DISCONNECT);\r\nfor (i = 0; i < dev->nepo; i++) {\r\nif (of_property_read_u32_index(np, "epobufsizes", i, &bufsize))\r\nbufsize = 1024;\r\nret = gr_ep_init(dev, i, 0, bufsize);\r\nif (ret)\r\nreturn ret;\r\n}\r\nfor (i = 0; i < dev->nepi; i++) {\r\nif (of_property_read_u32_index(np, "epibufsizes", i, &bufsize))\r\nbufsize = 1024;\r\nret = gr_ep_init(dev, i, 1, bufsize);\r\nif (ret)\r\nreturn ret;\r\n}\r\ndev->remote_wakeup = 0;\r\nepctrl_val = (MAX_CTRL_PL_SIZE << GR_EPCTRL_MAXPL_POS) | GR_EPCTRL_EV;\r\ndmactrl_val = GR_DMACTRL_IE | GR_DMACTRL_AI;\r\ngr_write32(&dev->epo[0].regs->epctrl, epctrl_val);\r\ngr_write32(&dev->epi[0].regs->epctrl, epctrl_val | GR_EPCTRL_PI);\r\ngr_write32(&dev->epo[0].regs->dmactrl, dmactrl_val);\r\ngr_write32(&dev->epi[0].regs->dmactrl, dmactrl_val);\r\nreturn 0;\r\n}\r\nstatic void gr_ep_remove(struct gr_udc *dev, int num, int is_in)\r\n{\r\nstruct gr_ep *ep;\r\nif (is_in)\r\nep = &dev->epi[num];\r\nelse\r\nep = &dev->epo[num];\r\nif (ep->tailbuf)\r\ndma_free_coherent(dev->dev, ep->ep.maxpacket_limit,\r\nep->tailbuf, ep->tailbuf_paddr);\r\n}\r\nstatic int gr_remove(struct platform_device *pdev)\r\n{\r\nstruct gr_udc *dev = platform_get_drvdata(pdev);\r\nint i;\r\nif (dev->added)\r\nusb_del_gadget_udc(&dev->gadget);\r\nif (dev->driver)\r\nreturn -EBUSY;\r\ngr_dfs_delete(dev);\r\ndma_pool_destroy(dev->desc_pool);\r\nplatform_set_drvdata(pdev, NULL);\r\ngr_free_request(&dev->epi[0].ep, &dev->ep0reqi->req);\r\ngr_free_request(&dev->epo[0].ep, &dev->ep0reqo->req);\r\nfor (i = 0; i < dev->nepo; i++)\r\ngr_ep_remove(dev, i, 0);\r\nfor (i = 0; i < dev->nepi; i++)\r\ngr_ep_remove(dev, i, 1);\r\nreturn 0;\r\n}\r\nstatic int gr_request_irq(struct gr_udc *dev, int irq)\r\n{\r\nreturn devm_request_threaded_irq(dev->dev, irq, gr_irq, gr_irq_handler,\r\nIRQF_SHARED, driver_name, dev);\r\n}\r\nstatic int gr_probe(struct platform_device *pdev)\r\n{\r\nstruct gr_udc *dev;\r\nstruct resource *res;\r\nstruct gr_regs __iomem *regs;\r\nint retval;\r\nu32 status;\r\ndev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->dev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nregs = devm_ioremap_resource(dev->dev, res);\r\nif (IS_ERR(regs))\r\nreturn PTR_ERR(regs);\r\ndev->irq = platform_get_irq(pdev, 0);\r\nif (dev->irq <= 0) {\r\ndev_err(dev->dev, "No irq found\n");\r\nreturn -ENODEV;\r\n}\r\ndev->irqi = platform_get_irq(pdev, 1);\r\nif (dev->irqi > 0) {\r\ndev->irqo = platform_get_irq(pdev, 2);\r\nif (dev->irqo <= 0) {\r\ndev_err(dev->dev, "Found irqi but not irqo\n");\r\nreturn -ENODEV;\r\n}\r\n} else {\r\ndev->irqi = 0;\r\n}\r\ndev->gadget.name = driver_name;\r\ndev->gadget.max_speed = USB_SPEED_HIGH;\r\ndev->gadget.ops = &gr_ops;\r\nspin_lock_init(&dev->lock);\r\ndev->regs = regs;\r\nplatform_set_drvdata(pdev, dev);\r\nstatus = gr_read32(&dev->regs->status);\r\ndev->nepi = ((status & GR_STATUS_NEPI_MASK) >> GR_STATUS_NEPI_POS) + 1;\r\ndev->nepo = ((status & GR_STATUS_NEPO_MASK) >> GR_STATUS_NEPO_POS) + 1;\r\nif (!(status & GR_STATUS_DM)) {\r\ndev_err(dev->dev, "Slave mode cores are not supported\n");\r\nreturn -ENODEV;\r\n}\r\ndev->desc_pool = dma_pool_create("desc_pool", dev->dev,\r\nsizeof(struct gr_dma_desc), 4, 0);\r\nif (!dev->desc_pool) {\r\ndev_err(dev->dev, "Could not allocate DMA pool");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock(&dev->lock);\r\nretval = usb_add_gadget_udc(dev->dev, &dev->gadget);\r\nif (retval) {\r\ndev_err(dev->dev, "Could not add gadget udc");\r\ngoto out;\r\n}\r\ndev->added = 1;\r\nretval = gr_udc_init(dev);\r\nif (retval)\r\ngoto out;\r\ngr_dfs_create(dev);\r\ngr_disable_interrupts_and_pullup(dev);\r\nretval = gr_request_irq(dev, dev->irq);\r\nif (retval) {\r\ndev_err(dev->dev, "Failed to request irq %d\n", dev->irq);\r\ngoto out;\r\n}\r\nif (dev->irqi) {\r\nretval = gr_request_irq(dev, dev->irqi);\r\nif (retval) {\r\ndev_err(dev->dev, "Failed to request irqi %d\n",\r\ndev->irqi);\r\ngoto out;\r\n}\r\nretval = gr_request_irq(dev, dev->irqo);\r\nif (retval) {\r\ndev_err(dev->dev, "Failed to request irqo %d\n",\r\ndev->irqo);\r\ngoto out;\r\n}\r\n}\r\nif (dev->irqi)\r\ndev_info(dev->dev, "regs: %p, irqs %d, %d, %d\n", dev->regs,\r\ndev->irq, dev->irqi, dev->irqo);\r\nelse\r\ndev_info(dev->dev, "regs: %p, irq %d\n", dev->regs, dev->irq);\r\nout:\r\nspin_unlock(&dev->lock);\r\nif (retval)\r\ngr_remove(pdev);\r\nreturn retval;\r\n}
