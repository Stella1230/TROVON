static void img_ir_timing_preprocess(struct img_ir_timing_range *range,\r\nunsigned int unit)\r\n{\r\nif (range->max < range->min)\r\nrange->max = range->min;\r\nif (unit) {\r\nrange->min = (range->min*unit)/1000;\r\nrange->max = (range->max*unit + 999)/1000;\r\n}\r\n}\r\nstatic void img_ir_symbol_timing_preprocess(struct img_ir_symbol_timing *timing,\r\nunsigned int unit)\r\n{\r\nimg_ir_timing_preprocess(&timing->pulse, unit);\r\nimg_ir_timing_preprocess(&timing->space, unit);\r\n}\r\nstatic void img_ir_timings_preprocess(struct img_ir_timings *timings,\r\nunsigned int unit)\r\n{\r\nimg_ir_symbol_timing_preprocess(&timings->ldr, unit);\r\nimg_ir_symbol_timing_preprocess(&timings->s00, unit);\r\nimg_ir_symbol_timing_preprocess(&timings->s01, unit);\r\nimg_ir_symbol_timing_preprocess(&timings->s10, unit);\r\nimg_ir_symbol_timing_preprocess(&timings->s11, unit);\r\nif (unit)\r\ntimings->ft.ft_min = (timings->ft.ft_min*unit + 999)/1000;\r\n}\r\nstatic void img_ir_timing_defaults(struct img_ir_timing_range *range,\r\nstruct img_ir_timing_range *defaults)\r\n{\r\nif (!range->min)\r\nrange->min = defaults->min;\r\nif (!range->max)\r\nrange->max = defaults->max;\r\n}\r\nstatic void img_ir_symbol_timing_defaults(struct img_ir_symbol_timing *timing,\r\nstruct img_ir_symbol_timing *defaults)\r\n{\r\nimg_ir_timing_defaults(&timing->pulse, &defaults->pulse);\r\nimg_ir_timing_defaults(&timing->space, &defaults->space);\r\n}\r\nstatic void img_ir_timings_defaults(struct img_ir_timings *timings,\r\nstruct img_ir_timings *defaults)\r\n{\r\nimg_ir_symbol_timing_defaults(&timings->ldr, &defaults->ldr);\r\nimg_ir_symbol_timing_defaults(&timings->s00, &defaults->s00);\r\nimg_ir_symbol_timing_defaults(&timings->s01, &defaults->s01);\r\nimg_ir_symbol_timing_defaults(&timings->s10, &defaults->s10);\r\nimg_ir_symbol_timing_defaults(&timings->s11, &defaults->s11);\r\nif (!timings->ft.ft_min)\r\ntimings->ft.ft_min = defaults->ft.ft_min;\r\n}\r\nstatic u32 img_ir_control(const struct img_ir_control *control)\r\n{\r\nu32 ctrl = control->code_type << IMG_IR_CODETYPE_SHIFT;\r\nif (control->decoden)\r\nctrl |= IMG_IR_DECODEN;\r\nif (control->hdrtog)\r\nctrl |= IMG_IR_HDRTOG;\r\nif (control->ldrdec)\r\nctrl |= IMG_IR_LDRDEC;\r\nif (control->decodinpol)\r\nctrl |= IMG_IR_DECODINPOL;\r\nif (control->bitorien)\r\nctrl |= IMG_IR_BITORIEN;\r\nif (control->d1validsel)\r\nctrl |= IMG_IR_D1VALIDSEL;\r\nif (control->bitinv)\r\nctrl |= IMG_IR_BITINV;\r\nif (control->decodend2)\r\nctrl |= IMG_IR_DECODEND2;\r\nif (control->bitoriend2)\r\nctrl |= IMG_IR_BITORIEND2;\r\nif (control->bitinvd2)\r\nctrl |= IMG_IR_BITINVD2;\r\nreturn ctrl;\r\n}\r\nstatic void img_ir_timing_range_convert(struct img_ir_timing_range *out,\r\nconst struct img_ir_timing_range *in,\r\nunsigned int tolerance,\r\nunsigned long clock_hz,\r\nunsigned int shift)\r\n{\r\nunsigned int min = in->min;\r\nunsigned int max = in->max;\r\nmin = min - (min*tolerance >> 7);\r\nmax = max + (max*tolerance >> 7);\r\nmin = min*clock_hz / 1000000;\r\nmax = (max*clock_hz + 999999) / 1000000;\r\nout->min = min >> shift;\r\nout->max = (max + ((1 << shift) - 1)) >> shift;\r\n}\r\nstatic u32 img_ir_symbol_timing(const struct img_ir_symbol_timing *timing,\r\nunsigned int tolerance,\r\nunsigned long clock_hz,\r\nunsigned int pd_shift,\r\nunsigned int w_shift)\r\n{\r\nstruct img_ir_timing_range hw_pulse, hw_period;\r\nhw_period.min = timing->pulse.min + timing->space.min;\r\nhw_period.max = timing->pulse.max + timing->space.max;\r\nimg_ir_timing_range_convert(&hw_period, &hw_period,\r\ntolerance, clock_hz, pd_shift);\r\nimg_ir_timing_range_convert(&hw_pulse, &timing->pulse,\r\ntolerance, clock_hz, w_shift);\r\nreturn (hw_period.max << IMG_IR_PD_MAX_SHIFT) |\r\n(hw_period.min << IMG_IR_PD_MIN_SHIFT) |\r\n(hw_pulse.max << IMG_IR_W_MAX_SHIFT) |\r\n(hw_pulse.min << IMG_IR_W_MIN_SHIFT);\r\n}\r\nstatic u32 img_ir_free_timing(const struct img_ir_free_timing *timing,\r\nunsigned long clock_hz)\r\n{\r\nunsigned int minlen, maxlen, ft_min;\r\nif (timing->minlen < 30)\r\nminlen = timing->minlen & -2;\r\nelse\r\nminlen = 30;\r\nif (timing->maxlen < 48)\r\nmaxlen = (timing->maxlen + 1) & -2;\r\nelse\r\nmaxlen = 48;\r\nft_min = (timing->ft_min*clock_hz + 999999) / 1000000;\r\nft_min = (ft_min + 7) >> 3;\r\nreturn (maxlen << IMG_IR_MAXLEN_SHIFT) |\r\n(minlen << IMG_IR_MINLEN_SHIFT) |\r\n(ft_min << IMG_IR_FT_MIN_SHIFT);\r\n}\r\nstatic u32 img_ir_free_timing_dynamic(u32 st_ft, struct img_ir_filter *filter)\r\n{\r\nunsigned int minlen, maxlen, newminlen, newmaxlen;\r\nnewminlen = filter->minlen & -2;\r\nnewmaxlen = (filter->maxlen + 1) & -2;\r\nminlen = (st_ft & IMG_IR_MINLEN) >> IMG_IR_MINLEN_SHIFT;\r\nmaxlen = (st_ft & IMG_IR_MAXLEN) >> IMG_IR_MAXLEN_SHIFT;\r\nif (newminlen > minlen) {\r\nst_ft &= ~IMG_IR_MINLEN;\r\nst_ft |= newminlen << IMG_IR_MINLEN_SHIFT;\r\n}\r\nif (newmaxlen < maxlen) {\r\nst_ft &= ~IMG_IR_MAXLEN;\r\nst_ft |= newmaxlen << IMG_IR_MAXLEN_SHIFT;\r\n}\r\nreturn st_ft;\r\n}\r\nstatic void img_ir_timings_convert(struct img_ir_timing_regvals *regs,\r\nconst struct img_ir_timings *timings,\r\nunsigned int tolerance,\r\nunsigned int clock_hz)\r\n{\r\nregs->ldr = img_ir_symbol_timing(&timings->ldr, tolerance, clock_hz,\r\n4, 4);\r\nregs->s00 = img_ir_symbol_timing(&timings->s00, tolerance, clock_hz,\r\n1, 0);\r\nregs->s01 = img_ir_symbol_timing(&timings->s01, tolerance, clock_hz,\r\n1, 0);\r\nregs->s10 = img_ir_symbol_timing(&timings->s10, tolerance, clock_hz,\r\n1, 0);\r\nregs->s11 = img_ir_symbol_timing(&timings->s11, tolerance, clock_hz,\r\n1, 0);\r\nregs->ft = img_ir_free_timing(&timings->ft, clock_hz);\r\n}\r\nstatic void img_ir_decoder_preprocess(struct img_ir_decoder *decoder)\r\n{\r\nif (!decoder->tolerance)\r\ndecoder->tolerance = 10;\r\ndecoder->tolerance = decoder->tolerance * 128 / 100;\r\nimg_ir_timings_preprocess(&decoder->timings, decoder->unit);\r\nif (decoder->repeat) {\r\nimg_ir_timings_preprocess(&decoder->rtimings, decoder->unit);\r\nimg_ir_timings_defaults(&decoder->rtimings, &decoder->timings);\r\n}\r\n}\r\nstatic void img_ir_decoder_convert(const struct img_ir_decoder *decoder,\r\nstruct img_ir_reg_timings *reg_timings,\r\nunsigned int clock_hz)\r\n{\r\nreg_timings->ctrl = img_ir_control(&decoder->control);\r\nimg_ir_timings_convert(&reg_timings->timings, &decoder->timings,\r\ndecoder->tolerance, clock_hz);\r\nif (decoder->repeat)\r\nimg_ir_timings_convert(&reg_timings->rtimings,\r\n&decoder->rtimings, decoder->tolerance,\r\nclock_hz);\r\n}\r\nstatic void img_ir_write_timings(struct img_ir_priv *priv,\r\nstruct img_ir_timing_regvals *regs,\r\nenum rc_filter_type type)\r\n{\r\nstruct img_ir_priv_hw *hw = &priv->hw;\r\nu32 ft = regs->ft;\r\nif (hw->flags & BIT(type))\r\nft = img_ir_free_timing_dynamic(regs->ft, &hw->filters[type]);\r\nimg_ir_write(priv, IMG_IR_LEAD_SYMB_TIMING, regs->ldr);\r\nimg_ir_write(priv, IMG_IR_S00_SYMB_TIMING, regs->s00);\r\nimg_ir_write(priv, IMG_IR_S01_SYMB_TIMING, regs->s01);\r\nimg_ir_write(priv, IMG_IR_S10_SYMB_TIMING, regs->s10);\r\nimg_ir_write(priv, IMG_IR_S11_SYMB_TIMING, regs->s11);\r\nimg_ir_write(priv, IMG_IR_FREE_SYMB_TIMING, ft);\r\ndev_dbg(priv->dev, "timings: ldr=%#x, s=[%#x, %#x, %#x, %#x], ft=%#x\n",\r\nregs->ldr, regs->s00, regs->s01, regs->s10, regs->s11, ft);\r\n}\r\nstatic void img_ir_write_filter(struct img_ir_priv *priv,\r\nstruct img_ir_filter *filter)\r\n{\r\nif (filter) {\r\ndev_dbg(priv->dev, "IR filter=%016llx & %016llx\n",\r\n(unsigned long long)filter->data,\r\n(unsigned long long)filter->mask);\r\nimg_ir_write(priv, IMG_IR_IRQ_MSG_DATA_LW, (u32)filter->data);\r\nimg_ir_write(priv, IMG_IR_IRQ_MSG_DATA_UP, (u32)(filter->data\r\n>> 32));\r\nimg_ir_write(priv, IMG_IR_IRQ_MSG_MASK_LW, (u32)filter->mask);\r\nimg_ir_write(priv, IMG_IR_IRQ_MSG_MASK_UP, (u32)(filter->mask\r\n>> 32));\r\n} else {\r\ndev_dbg(priv->dev, "IR clearing filter\n");\r\nimg_ir_write(priv, IMG_IR_IRQ_MSG_MASK_LW, 0);\r\nimg_ir_write(priv, IMG_IR_IRQ_MSG_MASK_UP, 0);\r\n}\r\n}\r\nstatic void _img_ir_set_filter(struct img_ir_priv *priv,\r\nstruct img_ir_filter *filter)\r\n{\r\nstruct img_ir_priv_hw *hw = &priv->hw;\r\nu32 irq_en, irq_on;\r\nirq_en = img_ir_read(priv, IMG_IR_IRQ_ENABLE);\r\nif (filter) {\r\nhw->filters[RC_FILTER_NORMAL] = *filter;\r\nhw->flags |= IMG_IR_F_FILTER;\r\nirq_on = IMG_IR_IRQ_DATA_MATCH;\r\nirq_en &= ~(IMG_IR_IRQ_DATA_VALID | IMG_IR_IRQ_DATA2_VALID);\r\n} else {\r\nhw->flags &= ~IMG_IR_F_FILTER;\r\nirq_en &= ~IMG_IR_IRQ_DATA_MATCH;\r\nirq_on = IMG_IR_IRQ_DATA_VALID | IMG_IR_IRQ_DATA2_VALID;\r\n}\r\nirq_en |= irq_on;\r\nimg_ir_write_filter(priv, filter);\r\nimg_ir_write(priv, IMG_IR_IRQ_CLEAR, irq_on);\r\nimg_ir_write(priv, IMG_IR_IRQ_ENABLE, irq_en);\r\n}\r\nstatic void _img_ir_set_wake_filter(struct img_ir_priv *priv,\r\nstruct img_ir_filter *filter)\r\n{\r\nstruct img_ir_priv_hw *hw = &priv->hw;\r\nif (filter) {\r\nhw->filters[RC_FILTER_WAKEUP] = *filter;\r\nhw->flags |= IMG_IR_F_WAKE;\r\n} else {\r\nhw->flags &= ~IMG_IR_F_WAKE;\r\n}\r\n}\r\nstatic int img_ir_set_filter(struct rc_dev *dev, enum rc_filter_type type,\r\nstruct rc_scancode_filter *sc_filter)\r\n{\r\nstruct img_ir_priv *priv = dev->priv;\r\nstruct img_ir_priv_hw *hw = &priv->hw;\r\nstruct img_ir_filter filter, *filter_ptr = &filter;\r\nint ret = 0;\r\ndev_dbg(priv->dev, "IR scancode %sfilter=%08x & %08x\n",\r\ntype == RC_FILTER_WAKEUP ? "wake " : "",\r\nsc_filter->data,\r\nsc_filter->mask);\r\nspin_lock_irq(&priv->lock);\r\nif (!sc_filter->mask) {\r\nfilter_ptr = NULL;\r\ngoto set_unlock;\r\n}\r\nif (!hw->decoder || !hw->decoder->filter) {\r\nret = -EINVAL;\r\ngoto unlock;\r\n}\r\nfilter.minlen = 0;\r\nfilter.maxlen = ~0;\r\nif (type == RC_FILTER_NORMAL) {\r\nret = hw->decoder->filter(sc_filter, &filter,\r\ndev->enabled_protocols);\r\n} else {\r\nret = hw->decoder->filter(sc_filter, &filter,\r\n1ULL << dev->wakeup_protocol);\r\n}\r\nif (ret)\r\ngoto unlock;\r\ndev_dbg(priv->dev, "IR raw %sfilter=%016llx & %016llx\n",\r\ntype == RC_FILTER_WAKEUP ? "wake " : "",\r\n(unsigned long long)filter.data,\r\n(unsigned long long)filter.mask);\r\nset_unlock:\r\nswitch (type) {\r\ncase RC_FILTER_NORMAL:\r\n_img_ir_set_filter(priv, filter_ptr);\r\nbreak;\r\ncase RC_FILTER_WAKEUP:\r\n_img_ir_set_wake_filter(priv, filter_ptr);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nunlock:\r\nspin_unlock_irq(&priv->lock);\r\nreturn ret;\r\n}\r\nstatic int img_ir_set_normal_filter(struct rc_dev *dev,\r\nstruct rc_scancode_filter *sc_filter)\r\n{\r\nreturn img_ir_set_filter(dev, RC_FILTER_NORMAL, sc_filter);\r\n}\r\nstatic int img_ir_set_wakeup_filter(struct rc_dev *dev,\r\nstruct rc_scancode_filter *sc_filter)\r\n{\r\nreturn img_ir_set_filter(dev, RC_FILTER_WAKEUP, sc_filter);\r\n}\r\nstatic void img_ir_set_decoder(struct img_ir_priv *priv,\r\nconst struct img_ir_decoder *decoder,\r\nu64 proto)\r\n{\r\nstruct img_ir_priv_hw *hw = &priv->hw;\r\nstruct rc_dev *rdev = hw->rdev;\r\nu32 ir_status, irq_en;\r\nspin_lock_irq(&priv->lock);\r\nhw->stopping = true;\r\nspin_unlock_irq(&priv->lock);\r\ndel_timer_sync(&hw->end_timer);\r\ndel_timer_sync(&hw->suspend_timer);\r\nspin_lock_irq(&priv->lock);\r\nhw->stopping = false;\r\nimg_ir_write(priv, IMG_IR_CONTROL, 0);\r\nirq_en = img_ir_read(priv, IMG_IR_IRQ_ENABLE);\r\nimg_ir_write(priv, IMG_IR_IRQ_ENABLE, irq_en & IMG_IR_IRQ_EDGE);\r\nimg_ir_write(priv, IMG_IR_IRQ_CLEAR, IMG_IR_IRQ_ALL & ~IMG_IR_IRQ_EDGE);\r\nir_status = img_ir_read(priv, IMG_IR_STATUS);\r\nif (ir_status & (IMG_IR_RXDVAL | IMG_IR_RXDVALD2)) {\r\nir_status &= ~(IMG_IR_RXDVAL | IMG_IR_RXDVALD2);\r\nimg_ir_write(priv, IMG_IR_STATUS, ir_status);\r\n}\r\nimg_ir_read(priv, IMG_IR_DATA_LW);\r\nimg_ir_read(priv, IMG_IR_DATA_UP);\r\nhw->mode = IMG_IR_M_NORMAL;\r\nrdev->scancode_wakeup_filter.data = 0;\r\nrdev->scancode_wakeup_filter.mask = 0;\r\nrdev->wakeup_protocol = RC_TYPE_UNKNOWN;\r\n_img_ir_set_filter(priv, NULL);\r\n_img_ir_set_wake_filter(priv, NULL);\r\nhw->enabled_protocols = 0;\r\nhw->decoder = decoder;\r\nif (!decoder)\r\ngoto unlock;\r\nif (!proto)\r\nproto = decoder->type;\r\nhw->enabled_protocols = proto;\r\nimg_ir_decoder_convert(decoder, &hw->reg_timings, hw->clk_hz);\r\nimg_ir_write_timings(priv, &hw->reg_timings.timings, RC_FILTER_NORMAL);\r\nimg_ir_write(priv, IMG_IR_CONTROL, hw->reg_timings.ctrl);\r\nunlock:\r\nspin_unlock_irq(&priv->lock);\r\n}\r\nstatic bool img_ir_decoder_compatible(struct img_ir_priv *priv,\r\nconst struct img_ir_decoder *dec)\r\n{\r\nunsigned int ct;\r\nct = dec->control.code_type;\r\nif (priv->hw.ct_quirks[ct] & IMG_IR_QUIRK_CODE_BROKEN)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic u64 img_ir_allowed_protos(struct img_ir_priv *priv)\r\n{\r\nu64 protos = 0;\r\nstruct img_ir_decoder **decp;\r\nfor (decp = img_ir_decoders; *decp; ++decp) {\r\nconst struct img_ir_decoder *dec = *decp;\r\nif (img_ir_decoder_compatible(priv, dec))\r\nprotos |= dec->type;\r\n}\r\nreturn protos;\r\n}\r\nstatic int img_ir_change_protocol(struct rc_dev *dev, u64 *ir_type)\r\n{\r\nstruct img_ir_priv *priv = dev->priv;\r\nstruct img_ir_priv_hw *hw = &priv->hw;\r\nstruct rc_dev *rdev = hw->rdev;\r\nstruct img_ir_decoder **decp;\r\nu64 wakeup_protocols;\r\nif (!*ir_type) {\r\nimg_ir_set_decoder(priv, NULL, 0);\r\ngoto success;\r\n}\r\nfor (decp = img_ir_decoders; *decp; ++decp) {\r\nconst struct img_ir_decoder *dec = *decp;\r\nif (!img_ir_decoder_compatible(priv, dec))\r\ncontinue;\r\nif (*ir_type & dec->type) {\r\n*ir_type &= dec->type;\r\nimg_ir_set_decoder(priv, dec, *ir_type);\r\ngoto success;\r\n}\r\n}\r\nreturn -EINVAL;\r\nsuccess:\r\nwakeup_protocols = *ir_type;\r\nif (!hw->decoder || !hw->decoder->filter)\r\nwakeup_protocols = 0;\r\nrdev->allowed_wakeup_protocols = wakeup_protocols;\r\nreturn 0;\r\n}\r\nstatic void img_ir_set_protocol(struct img_ir_priv *priv, u64 proto)\r\n{\r\nstruct rc_dev *rdev = priv->hw.rdev;\r\nspin_lock_irq(&rdev->rc_map.lock);\r\nrdev->rc_map.rc_type = __ffs64(proto);\r\nspin_unlock_irq(&rdev->rc_map.lock);\r\nmutex_lock(&rdev->lock);\r\nrdev->enabled_protocols = proto;\r\nrdev->allowed_wakeup_protocols = proto;\r\nmutex_unlock(&rdev->lock);\r\n}\r\nstatic void img_ir_init_decoders(void)\r\n{\r\nstruct img_ir_decoder **decp;\r\nspin_lock(&img_ir_decoders_lock);\r\nif (!img_ir_decoders_preprocessed) {\r\nfor (decp = img_ir_decoders; *decp; ++decp)\r\nimg_ir_decoder_preprocess(*decp);\r\nimg_ir_decoders_preprocessed = true;\r\n}\r\nspin_unlock(&img_ir_decoders_lock);\r\n}\r\nstatic int img_ir_enable_wake(struct img_ir_priv *priv)\r\n{\r\nstruct img_ir_priv_hw *hw = &priv->hw;\r\nint ret = 0;\r\nspin_lock_irq(&priv->lock);\r\nif (hw->flags & IMG_IR_F_WAKE) {\r\nhw->suspend_irqen = img_ir_read(priv, IMG_IR_IRQ_ENABLE);\r\nimg_ir_write(priv, IMG_IR_IRQ_ENABLE, IMG_IR_IRQ_DATA_MATCH);\r\nimg_ir_write_filter(priv, &hw->filters[RC_FILTER_WAKEUP]);\r\nimg_ir_write_timings(priv, &hw->reg_timings.timings,\r\nRC_FILTER_WAKEUP);\r\nhw->mode = IMG_IR_M_WAKE;\r\nret = 1;\r\n}\r\nspin_unlock_irq(&priv->lock);\r\nreturn ret;\r\n}\r\nstatic int img_ir_disable_wake(struct img_ir_priv *priv)\r\n{\r\nstruct img_ir_priv_hw *hw = &priv->hw;\r\nint ret = 0;\r\nspin_lock_irq(&priv->lock);\r\nif (hw->flags & IMG_IR_F_WAKE) {\r\nif (hw->flags & IMG_IR_F_FILTER) {\r\nimg_ir_write(priv, IMG_IR_IRQ_ENABLE,\r\n(hw->suspend_irqen & IMG_IR_IRQ_EDGE) |\r\nIMG_IR_IRQ_DATA_MATCH);\r\nimg_ir_write_filter(priv,\r\n&hw->filters[RC_FILTER_NORMAL]);\r\n} else {\r\nimg_ir_write(priv, IMG_IR_IRQ_ENABLE,\r\n(hw->suspend_irqen & IMG_IR_IRQ_EDGE) |\r\nIMG_IR_IRQ_DATA_VALID |\r\nIMG_IR_IRQ_DATA2_VALID);\r\nimg_ir_write_filter(priv, NULL);\r\n}\r\nimg_ir_write_timings(priv, &hw->reg_timings.timings,\r\nRC_FILTER_NORMAL);\r\nhw->mode = IMG_IR_M_NORMAL;\r\nret = 1;\r\n}\r\nspin_unlock_irq(&priv->lock);\r\nreturn ret;\r\n}\r\nstatic void img_ir_begin_repeat(struct img_ir_priv *priv)\r\n{\r\nstruct img_ir_priv_hw *hw = &priv->hw;\r\nif (hw->mode == IMG_IR_M_NORMAL) {\r\nimg_ir_write(priv, IMG_IR_CONTROL, 0);\r\nhw->mode = IMG_IR_M_REPEATING;\r\nimg_ir_write_timings(priv, &hw->reg_timings.rtimings,\r\nRC_FILTER_NORMAL);\r\nimg_ir_write(priv, IMG_IR_CONTROL, hw->reg_timings.ctrl);\r\n}\r\n}\r\nstatic void img_ir_end_repeat(struct img_ir_priv *priv)\r\n{\r\nstruct img_ir_priv_hw *hw = &priv->hw;\r\nif (hw->mode == IMG_IR_M_REPEATING) {\r\nimg_ir_write(priv, IMG_IR_CONTROL, 0);\r\nhw->mode = IMG_IR_M_NORMAL;\r\nimg_ir_write_timings(priv, &hw->reg_timings.timings,\r\nRC_FILTER_NORMAL);\r\nimg_ir_write(priv, IMG_IR_CONTROL, hw->reg_timings.ctrl);\r\n}\r\n}\r\nstatic void img_ir_handle_data(struct img_ir_priv *priv, u32 len, u64 raw)\r\n{\r\nstruct img_ir_priv_hw *hw = &priv->hw;\r\nconst struct img_ir_decoder *dec = hw->decoder;\r\nint ret = IMG_IR_SCANCODE;\r\nstruct img_ir_scancode_req request;\r\nrequest.protocol = RC_TYPE_UNKNOWN;\r\nrequest.toggle = 0;\r\nif (dec->scancode)\r\nret = dec->scancode(len, raw, hw->enabled_protocols, &request);\r\nelse if (len >= 32)\r\nrequest.scancode = (u32)raw;\r\nelse if (len < 32)\r\nrequest.scancode = (u32)raw & ((1 << len)-1);\r\ndev_dbg(priv->dev, "data (%u bits) = %#llx\n",\r\nlen, (unsigned long long)raw);\r\nif (ret == IMG_IR_SCANCODE) {\r\ndev_dbg(priv->dev, "decoded scan code %#x, toggle %u\n",\r\nrequest.scancode, request.toggle);\r\nrc_keydown(hw->rdev, request.protocol, request.scancode,\r\nrequest.toggle);\r\nimg_ir_end_repeat(priv);\r\n} else if (ret == IMG_IR_REPEATCODE) {\r\nif (hw->mode == IMG_IR_M_REPEATING) {\r\ndev_dbg(priv->dev, "decoded repeat code\n");\r\nrc_repeat(hw->rdev);\r\n} else {\r\ndev_dbg(priv->dev, "decoded unexpected repeat code, ignoring\n");\r\n}\r\n} else {\r\ndev_dbg(priv->dev, "decode failed (%d)\n", ret);\r\nreturn;\r\n}\r\nif (dec->repeat && !hw->stopping) {\r\nunsigned long interval;\r\nimg_ir_begin_repeat(priv);\r\ninterval = dec->repeat + (dec->repeat >> 3);\r\nmod_timer(&hw->end_timer,\r\njiffies + msecs_to_jiffies(interval));\r\n}\r\n}\r\nstatic void img_ir_end_timer(unsigned long arg)\r\n{\r\nstruct img_ir_priv *priv = (struct img_ir_priv *)arg;\r\nspin_lock_irq(&priv->lock);\r\nimg_ir_end_repeat(priv);\r\nspin_unlock_irq(&priv->lock);\r\n}\r\nstatic void img_ir_suspend_timer(unsigned long arg)\r\n{\r\nstruct img_ir_priv *priv = (struct img_ir_priv *)arg;\r\nspin_lock_irq(&priv->lock);\r\nif ((priv->hw.quirk_suspend_irq & IMG_IR_IRQ_EDGE) ==\r\nimg_ir_read(priv, IMG_IR_IRQ_ENABLE))\r\nimg_ir_write(priv, IMG_IR_IRQ_ENABLE,\r\npriv->hw.quirk_suspend_irq);\r\nimg_ir_write(priv, IMG_IR_CONTROL, priv->hw.reg_timings.ctrl);\r\nspin_unlock_irq(&priv->lock);\r\n}\r\nstatic void img_ir_change_frequency(struct img_ir_priv *priv,\r\nstruct clk_notifier_data *change)\r\n{\r\nstruct img_ir_priv_hw *hw = &priv->hw;\r\ndev_dbg(priv->dev, "clk changed %lu HZ -> %lu HZ\n",\r\nchange->old_rate, change->new_rate);\r\nspin_lock_irq(&priv->lock);\r\nif (hw->clk_hz == change->new_rate)\r\ngoto unlock;\r\nhw->clk_hz = change->new_rate;\r\nif (hw->decoder) {\r\nimg_ir_decoder_convert(hw->decoder, &hw->reg_timings,\r\nhw->clk_hz);\r\nswitch (hw->mode) {\r\ncase IMG_IR_M_NORMAL:\r\nimg_ir_write_timings(priv, &hw->reg_timings.timings,\r\nRC_FILTER_NORMAL);\r\nbreak;\r\ncase IMG_IR_M_REPEATING:\r\nimg_ir_write_timings(priv, &hw->reg_timings.rtimings,\r\nRC_FILTER_NORMAL);\r\nbreak;\r\n#ifdef CONFIG_PM_SLEEP\r\ncase IMG_IR_M_WAKE:\r\nimg_ir_write_timings(priv, &hw->reg_timings.timings,\r\nRC_FILTER_WAKEUP);\r\nbreak;\r\n#endif\r\n}\r\n}\r\nunlock:\r\nspin_unlock_irq(&priv->lock);\r\n}\r\nstatic int img_ir_clk_notify(struct notifier_block *self, unsigned long action,\r\nvoid *data)\r\n{\r\nstruct img_ir_priv *priv = container_of(self, struct img_ir_priv,\r\nhw.clk_nb);\r\nswitch (action) {\r\ncase POST_RATE_CHANGE:\r\nimg_ir_change_frequency(priv, data);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nvoid img_ir_isr_hw(struct img_ir_priv *priv, u32 irq_status)\r\n{\r\nstruct img_ir_priv_hw *hw = &priv->hw;\r\nu32 ir_status, len, lw, up;\r\nunsigned int ct;\r\nif (!hw->decoder)\r\nreturn;\r\nct = hw->decoder->control.code_type;\r\nir_status = img_ir_read(priv, IMG_IR_STATUS);\r\nif (!(ir_status & (IMG_IR_RXDVAL | IMG_IR_RXDVALD2))) {\r\nif (!(priv->hw.ct_quirks[ct] & IMG_IR_QUIRK_CODE_IRQ) ||\r\nhw->stopping)\r\nreturn;\r\nimg_ir_write(priv, IMG_IR_CONTROL, 0);\r\nhw->quirk_suspend_irq = img_ir_read(priv, IMG_IR_IRQ_ENABLE);\r\nimg_ir_write(priv, IMG_IR_IRQ_ENABLE,\r\nhw->quirk_suspend_irq & IMG_IR_IRQ_EDGE);\r\nmod_timer(&hw->suspend_timer,\r\njiffies + msecs_to_jiffies(5));\r\nreturn;\r\n}\r\nir_status &= ~(IMG_IR_RXDVAL | IMG_IR_RXDVALD2);\r\nimg_ir_write(priv, IMG_IR_STATUS, ir_status);\r\nlen = (ir_status & IMG_IR_RXDLEN) >> IMG_IR_RXDLEN_SHIFT;\r\nif (hw->ct_quirks[ct] & IMG_IR_QUIRK_CODE_LEN_INCR)\r\n++len;\r\nlw = img_ir_read(priv, IMG_IR_DATA_LW);\r\nup = img_ir_read(priv, IMG_IR_DATA_UP);\r\nimg_ir_handle_data(priv, len, (u64)up << 32 | lw);\r\n}\r\nvoid img_ir_setup_hw(struct img_ir_priv *priv)\r\n{\r\nstruct img_ir_decoder **decp;\r\nif (!priv->hw.rdev)\r\nreturn;\r\nfor (decp = img_ir_decoders; *decp; ++decp) {\r\nconst struct img_ir_decoder *dec = *decp;\r\nif (img_ir_decoder_compatible(priv, dec)) {\r\nimg_ir_set_protocol(priv, dec->type);\r\nimg_ir_set_decoder(priv, dec, 0);\r\nreturn;\r\n}\r\n}\r\nimg_ir_set_decoder(priv, NULL, 0);\r\n}\r\nstatic void img_ir_probe_hw_caps(struct img_ir_priv *priv)\r\n{\r\nstruct img_ir_priv_hw *hw = &priv->hw;\r\nhw->ct_quirks[IMG_IR_CODETYPE_PULSELEN]\r\n|= IMG_IR_QUIRK_CODE_LEN_INCR;\r\nhw->ct_quirks[IMG_IR_CODETYPE_BIPHASE]\r\n|= IMG_IR_QUIRK_CODE_IRQ;\r\nhw->ct_quirks[IMG_IR_CODETYPE_2BITPULSEPOS]\r\n|= IMG_IR_QUIRK_CODE_BROKEN;\r\n}\r\nint img_ir_probe_hw(struct img_ir_priv *priv)\r\n{\r\nstruct img_ir_priv_hw *hw = &priv->hw;\r\nstruct rc_dev *rdev;\r\nint error;\r\nimg_ir_init_decoders();\r\nimg_ir_probe_hw_caps(priv);\r\nsetup_timer(&hw->end_timer, img_ir_end_timer, (unsigned long)priv);\r\nsetup_timer(&hw->suspend_timer, img_ir_suspend_timer,\r\n(unsigned long)priv);\r\nif (!IS_ERR(priv->clk)) {\r\nhw->clk_hz = clk_get_rate(priv->clk);\r\n#ifdef CONFIG_COMMON_CLK\r\nhw->clk_nb.notifier_call = img_ir_clk_notify;\r\nerror = clk_notifier_register(priv->clk, &hw->clk_nb);\r\nif (error)\r\ndev_warn(priv->dev,\r\n"failed to register clock notifier\n");\r\n#endif\r\n} else {\r\nhw->clk_hz = 32768;\r\n}\r\nhw->rdev = rdev = rc_allocate_device(RC_DRIVER_SCANCODE);\r\nif (!rdev) {\r\ndev_err(priv->dev, "cannot allocate input device\n");\r\nerror = -ENOMEM;\r\ngoto err_alloc_rc;\r\n}\r\nrdev->priv = priv;\r\nrdev->map_name = RC_MAP_EMPTY;\r\nrdev->allowed_protocols = img_ir_allowed_protos(priv);\r\nrdev->input_name = "IMG Infrared Decoder";\r\nrdev->s_filter = img_ir_set_normal_filter;\r\nrdev->s_wakeup_filter = img_ir_set_wakeup_filter;\r\nerror = rc_register_device(rdev);\r\nif (error) {\r\ndev_err(priv->dev, "failed to register IR input device\n");\r\ngoto err_register_rc;\r\n}\r\nrdev->change_protocol = img_ir_change_protocol;\r\ndevice_init_wakeup(priv->dev, 1);\r\nreturn 0;\r\nerr_register_rc:\r\nimg_ir_set_decoder(priv, NULL, 0);\r\nhw->rdev = NULL;\r\nrc_free_device(rdev);\r\nerr_alloc_rc:\r\n#ifdef CONFIG_COMMON_CLK\r\nif (!IS_ERR(priv->clk))\r\nclk_notifier_unregister(priv->clk, &hw->clk_nb);\r\n#endif\r\nreturn error;\r\n}\r\nvoid img_ir_remove_hw(struct img_ir_priv *priv)\r\n{\r\nstruct img_ir_priv_hw *hw = &priv->hw;\r\nstruct rc_dev *rdev = hw->rdev;\r\nif (!rdev)\r\nreturn;\r\nimg_ir_set_decoder(priv, NULL, 0);\r\nhw->rdev = NULL;\r\nrc_unregister_device(rdev);\r\n#ifdef CONFIG_COMMON_CLK\r\nif (!IS_ERR(priv->clk))\r\nclk_notifier_unregister(priv->clk, &hw->clk_nb);\r\n#endif\r\n}\r\nint img_ir_suspend(struct device *dev)\r\n{\r\nstruct img_ir_priv *priv = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev) && img_ir_enable_wake(priv))\r\nenable_irq_wake(priv->irq);\r\nreturn 0;\r\n}\r\nint img_ir_resume(struct device *dev)\r\n{\r\nstruct img_ir_priv *priv = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev) && img_ir_disable_wake(priv))\r\ndisable_irq_wake(priv->irq);\r\nreturn 0;\r\n}
