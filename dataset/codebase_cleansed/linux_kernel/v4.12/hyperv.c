static inline u64 synic_read_sint(struct kvm_vcpu_hv_synic *synic, int sint)\r\n{\r\nreturn atomic64_read(&synic->sint[sint]);\r\n}\r\nstatic inline int synic_get_sint_vector(u64 sint_value)\r\n{\r\nif (sint_value & HV_SYNIC_SINT_MASKED)\r\nreturn -1;\r\nreturn sint_value & HV_SYNIC_SINT_VECTOR_MASK;\r\n}\r\nstatic bool synic_has_vector_connected(struct kvm_vcpu_hv_synic *synic,\r\nint vector)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(synic->sint); i++) {\r\nif (synic_get_sint_vector(synic_read_sint(synic, i)) == vector)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool synic_has_vector_auto_eoi(struct kvm_vcpu_hv_synic *synic,\r\nint vector)\r\n{\r\nint i;\r\nu64 sint_value;\r\nfor (i = 0; i < ARRAY_SIZE(synic->sint); i++) {\r\nsint_value = synic_read_sint(synic, i);\r\nif (synic_get_sint_vector(sint_value) == vector &&\r\nsint_value & HV_SYNIC_SINT_AUTO_EOI)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int synic_set_sint(struct kvm_vcpu_hv_synic *synic, int sint,\r\nu64 data, bool host)\r\n{\r\nint vector;\r\nvector = data & HV_SYNIC_SINT_VECTOR_MASK;\r\nif (vector < 16 && !host)\r\nreturn 1;\r\natomic64_set(&synic->sint[sint], data);\r\nif (synic_has_vector_connected(synic, vector))\r\n__set_bit(vector, synic->vec_bitmap);\r\nelse\r\n__clear_bit(vector, synic->vec_bitmap);\r\nif (synic_has_vector_auto_eoi(synic, vector))\r\n__set_bit(vector, synic->auto_eoi_bitmap);\r\nelse\r\n__clear_bit(vector, synic->auto_eoi_bitmap);\r\nkvm_make_request(KVM_REQ_SCAN_IOAPIC, synic_to_vcpu(synic));\r\nreturn 0;\r\n}\r\nstatic struct kvm_vcpu_hv_synic *synic_get(struct kvm *kvm, u32 vcpu_id)\r\n{\r\nstruct kvm_vcpu *vcpu;\r\nstruct kvm_vcpu_hv_synic *synic;\r\nif (vcpu_id >= atomic_read(&kvm->online_vcpus))\r\nreturn NULL;\r\nvcpu = kvm_get_vcpu(kvm, vcpu_id);\r\nif (!vcpu)\r\nreturn NULL;\r\nsynic = vcpu_to_synic(vcpu);\r\nreturn (synic->active) ? synic : NULL;\r\n}\r\nstatic void synic_clear_sint_msg_pending(struct kvm_vcpu_hv_synic *synic,\r\nu32 sint)\r\n{\r\nstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\r\nstruct page *page;\r\ngpa_t gpa;\r\nstruct hv_message *msg;\r\nstruct hv_message_page *msg_page;\r\ngpa = synic->msg_page & PAGE_MASK;\r\npage = kvm_vcpu_gfn_to_page(vcpu, gpa >> PAGE_SHIFT);\r\nif (is_error_page(page)) {\r\nvcpu_err(vcpu, "Hyper-V SynIC can't get msg page, gpa 0x%llx\n",\r\ngpa);\r\nreturn;\r\n}\r\nmsg_page = kmap_atomic(page);\r\nmsg = &msg_page->sint_message[sint];\r\nmsg->header.message_flags.msg_pending = 0;\r\nkunmap_atomic(msg_page);\r\nkvm_release_page_dirty(page);\r\nkvm_vcpu_mark_page_dirty(vcpu, gpa >> PAGE_SHIFT);\r\n}\r\nstatic void kvm_hv_notify_acked_sint(struct kvm_vcpu *vcpu, u32 sint)\r\n{\r\nstruct kvm *kvm = vcpu->kvm;\r\nstruct kvm_vcpu_hv_synic *synic = vcpu_to_synic(vcpu);\r\nstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\r\nstruct kvm_vcpu_hv_stimer *stimer;\r\nint gsi, idx, stimers_pending;\r\ntrace_kvm_hv_notify_acked_sint(vcpu->vcpu_id, sint);\r\nif (synic->msg_page & HV_SYNIC_SIMP_ENABLE)\r\nsynic_clear_sint_msg_pending(synic, sint);\r\nstimers_pending = 0;\r\nfor (idx = 0; idx < ARRAY_SIZE(hv_vcpu->stimer); idx++) {\r\nstimer = &hv_vcpu->stimer[idx];\r\nif (stimer->msg_pending &&\r\n(stimer->config & HV_STIMER_ENABLE) &&\r\nHV_STIMER_SINT(stimer->config) == sint) {\r\nset_bit(stimer->index,\r\nhv_vcpu->stimer_pending_bitmap);\r\nstimers_pending++;\r\n}\r\n}\r\nif (stimers_pending)\r\nkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\r\nidx = srcu_read_lock(&kvm->irq_srcu);\r\ngsi = atomic_read(&synic->sint_to_gsi[sint]);\r\nif (gsi != -1)\r\nkvm_notify_acked_gsi(kvm, gsi);\r\nsrcu_read_unlock(&kvm->irq_srcu, idx);\r\n}\r\nstatic void synic_exit(struct kvm_vcpu_hv_synic *synic, u32 msr)\r\n{\r\nstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\r\nstruct kvm_vcpu_hv *hv_vcpu = &vcpu->arch.hyperv;\r\nhv_vcpu->exit.type = KVM_EXIT_HYPERV_SYNIC;\r\nhv_vcpu->exit.u.synic.msr = msr;\r\nhv_vcpu->exit.u.synic.control = synic->control;\r\nhv_vcpu->exit.u.synic.evt_page = synic->evt_page;\r\nhv_vcpu->exit.u.synic.msg_page = synic->msg_page;\r\nkvm_make_request(KVM_REQ_HV_EXIT, vcpu);\r\n}\r\nstatic int synic_set_msr(struct kvm_vcpu_hv_synic *synic,\r\nu32 msr, u64 data, bool host)\r\n{\r\nstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\r\nint ret;\r\nif (!synic->active)\r\nreturn 1;\r\ntrace_kvm_hv_synic_set_msr(vcpu->vcpu_id, msr, data, host);\r\nret = 0;\r\nswitch (msr) {\r\ncase HV_X64_MSR_SCONTROL:\r\nsynic->control = data;\r\nif (!host)\r\nsynic_exit(synic, msr);\r\nbreak;\r\ncase HV_X64_MSR_SVERSION:\r\nif (!host) {\r\nret = 1;\r\nbreak;\r\n}\r\nsynic->version = data;\r\nbreak;\r\ncase HV_X64_MSR_SIEFP:\r\nif (data & HV_SYNIC_SIEFP_ENABLE)\r\nif (kvm_clear_guest(vcpu->kvm,\r\ndata & PAGE_MASK, PAGE_SIZE)) {\r\nret = 1;\r\nbreak;\r\n}\r\nsynic->evt_page = data;\r\nif (!host)\r\nsynic_exit(synic, msr);\r\nbreak;\r\ncase HV_X64_MSR_SIMP:\r\nif (data & HV_SYNIC_SIMP_ENABLE)\r\nif (kvm_clear_guest(vcpu->kvm,\r\ndata & PAGE_MASK, PAGE_SIZE)) {\r\nret = 1;\r\nbreak;\r\n}\r\nsynic->msg_page = data;\r\nif (!host)\r\nsynic_exit(synic, msr);\r\nbreak;\r\ncase HV_X64_MSR_EOM: {\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(synic->sint); i++)\r\nkvm_hv_notify_acked_sint(vcpu, i);\r\nbreak;\r\n}\r\ncase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\r\nret = synic_set_sint(synic, msr - HV_X64_MSR_SINT0, data, host);\r\nbreak;\r\ndefault:\r\nret = 1;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int synic_get_msr(struct kvm_vcpu_hv_synic *synic, u32 msr, u64 *pdata)\r\n{\r\nint ret;\r\nif (!synic->active)\r\nreturn 1;\r\nret = 0;\r\nswitch (msr) {\r\ncase HV_X64_MSR_SCONTROL:\r\n*pdata = synic->control;\r\nbreak;\r\ncase HV_X64_MSR_SVERSION:\r\n*pdata = synic->version;\r\nbreak;\r\ncase HV_X64_MSR_SIEFP:\r\n*pdata = synic->evt_page;\r\nbreak;\r\ncase HV_X64_MSR_SIMP:\r\n*pdata = synic->msg_page;\r\nbreak;\r\ncase HV_X64_MSR_EOM:\r\n*pdata = 0;\r\nbreak;\r\ncase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\r\n*pdata = atomic64_read(&synic->sint[msr - HV_X64_MSR_SINT0]);\r\nbreak;\r\ndefault:\r\nret = 1;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int synic_set_irq(struct kvm_vcpu_hv_synic *synic, u32 sint)\r\n{\r\nstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\r\nstruct kvm_lapic_irq irq;\r\nint ret, vector;\r\nif (sint >= ARRAY_SIZE(synic->sint))\r\nreturn -EINVAL;\r\nvector = synic_get_sint_vector(synic_read_sint(synic, sint));\r\nif (vector < 0)\r\nreturn -ENOENT;\r\nmemset(&irq, 0, sizeof(irq));\r\nirq.shorthand = APIC_DEST_SELF;\r\nirq.dest_mode = APIC_DEST_PHYSICAL;\r\nirq.delivery_mode = APIC_DM_FIXED;\r\nirq.vector = vector;\r\nirq.level = 1;\r\nret = kvm_irq_delivery_to_apic(vcpu->kvm, vcpu->arch.apic, &irq, NULL);\r\ntrace_kvm_hv_synic_set_irq(vcpu->vcpu_id, sint, irq.vector, ret);\r\nreturn ret;\r\n}\r\nint kvm_hv_synic_set_irq(struct kvm *kvm, u32 vcpu_id, u32 sint)\r\n{\r\nstruct kvm_vcpu_hv_synic *synic;\r\nsynic = synic_get(kvm, vcpu_id);\r\nif (!synic)\r\nreturn -EINVAL;\r\nreturn synic_set_irq(synic, sint);\r\n}\r\nvoid kvm_hv_synic_send_eoi(struct kvm_vcpu *vcpu, int vector)\r\n{\r\nstruct kvm_vcpu_hv_synic *synic = vcpu_to_synic(vcpu);\r\nint i;\r\ntrace_kvm_hv_synic_send_eoi(vcpu->vcpu_id, vector);\r\nfor (i = 0; i < ARRAY_SIZE(synic->sint); i++)\r\nif (synic_get_sint_vector(synic_read_sint(synic, i)) == vector)\r\nkvm_hv_notify_acked_sint(vcpu, i);\r\n}\r\nstatic int kvm_hv_set_sint_gsi(struct kvm *kvm, u32 vcpu_id, u32 sint, int gsi)\r\n{\r\nstruct kvm_vcpu_hv_synic *synic;\r\nsynic = synic_get(kvm, vcpu_id);\r\nif (!synic)\r\nreturn -EINVAL;\r\nif (sint >= ARRAY_SIZE(synic->sint_to_gsi))\r\nreturn -EINVAL;\r\natomic_set(&synic->sint_to_gsi[sint], gsi);\r\nreturn 0;\r\n}\r\nvoid kvm_hv_irq_routing_update(struct kvm *kvm)\r\n{\r\nstruct kvm_irq_routing_table *irq_rt;\r\nstruct kvm_kernel_irq_routing_entry *e;\r\nu32 gsi;\r\nirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\r\nlockdep_is_held(&kvm->irq_lock));\r\nfor (gsi = 0; gsi < irq_rt->nr_rt_entries; gsi++) {\r\nhlist_for_each_entry(e, &irq_rt->map[gsi], link) {\r\nif (e->type == KVM_IRQ_ROUTING_HV_SINT)\r\nkvm_hv_set_sint_gsi(kvm, e->hv_sint.vcpu,\r\ne->hv_sint.sint, gsi);\r\n}\r\n}\r\n}\r\nstatic void synic_init(struct kvm_vcpu_hv_synic *synic)\r\n{\r\nint i;\r\nmemset(synic, 0, sizeof(*synic));\r\nsynic->version = HV_SYNIC_VERSION_1;\r\nfor (i = 0; i < ARRAY_SIZE(synic->sint); i++) {\r\natomic64_set(&synic->sint[i], HV_SYNIC_SINT_MASKED);\r\natomic_set(&synic->sint_to_gsi[i], -1);\r\n}\r\n}\r\nstatic u64 get_time_ref_counter(struct kvm *kvm)\r\n{\r\nstruct kvm_hv *hv = &kvm->arch.hyperv;\r\nstruct kvm_vcpu *vcpu;\r\nu64 tsc;\r\nif (!hv->tsc_ref.tsc_sequence)\r\nreturn div_u64(get_kvmclock_ns(kvm), 100);\r\nvcpu = kvm_get_vcpu(kvm, 0);\r\ntsc = kvm_read_l1_tsc(vcpu, rdtsc());\r\nreturn mul_u64_u64_shr(tsc, hv->tsc_ref.tsc_scale, 64)\r\n+ hv->tsc_ref.tsc_offset;\r\n}\r\nstatic void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\r\nbool vcpu_kick)\r\n{\r\nstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\r\nset_bit(stimer->index,\r\nvcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\r\nkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\r\nif (vcpu_kick)\r\nkvm_vcpu_kick(vcpu);\r\n}\r\nstatic void stimer_cleanup(struct kvm_vcpu_hv_stimer *stimer)\r\n{\r\nstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\r\ntrace_kvm_hv_stimer_cleanup(stimer_to_vcpu(stimer)->vcpu_id,\r\nstimer->index);\r\nhrtimer_cancel(&stimer->timer);\r\nclear_bit(stimer->index,\r\nvcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\r\nstimer->msg_pending = false;\r\nstimer->exp_time = 0;\r\n}\r\nstatic enum hrtimer_restart stimer_timer_callback(struct hrtimer *timer)\r\n{\r\nstruct kvm_vcpu_hv_stimer *stimer;\r\nstimer = container_of(timer, struct kvm_vcpu_hv_stimer, timer);\r\ntrace_kvm_hv_stimer_callback(stimer_to_vcpu(stimer)->vcpu_id,\r\nstimer->index);\r\nstimer_mark_pending(stimer, true);\r\nreturn HRTIMER_NORESTART;\r\n}\r\nstatic int stimer_start(struct kvm_vcpu_hv_stimer *stimer)\r\n{\r\nu64 time_now;\r\nktime_t ktime_now;\r\ntime_now = get_time_ref_counter(stimer_to_vcpu(stimer)->kvm);\r\nktime_now = ktime_get();\r\nif (stimer->config & HV_STIMER_PERIODIC) {\r\nif (stimer->exp_time) {\r\nif (time_now >= stimer->exp_time) {\r\nu64 remainder;\r\ndiv64_u64_rem(time_now - stimer->exp_time,\r\nstimer->count, &remainder);\r\nstimer->exp_time =\r\ntime_now + (stimer->count - remainder);\r\n}\r\n} else\r\nstimer->exp_time = time_now + stimer->count;\r\ntrace_kvm_hv_stimer_start_periodic(\r\nstimer_to_vcpu(stimer)->vcpu_id,\r\nstimer->index,\r\ntime_now, stimer->exp_time);\r\nhrtimer_start(&stimer->timer,\r\nktime_add_ns(ktime_now,\r\n100 * (stimer->exp_time - time_now)),\r\nHRTIMER_MODE_ABS);\r\nreturn 0;\r\n}\r\nstimer->exp_time = stimer->count;\r\nif (time_now >= stimer->count) {\r\nstimer_mark_pending(stimer, false);\r\nreturn 0;\r\n}\r\ntrace_kvm_hv_stimer_start_one_shot(stimer_to_vcpu(stimer)->vcpu_id,\r\nstimer->index,\r\ntime_now, stimer->count);\r\nhrtimer_start(&stimer->timer,\r\nktime_add_ns(ktime_now, 100 * (stimer->count - time_now)),\r\nHRTIMER_MODE_ABS);\r\nreturn 0;\r\n}\r\nstatic int stimer_set_config(struct kvm_vcpu_hv_stimer *stimer, u64 config,\r\nbool host)\r\n{\r\ntrace_kvm_hv_stimer_set_config(stimer_to_vcpu(stimer)->vcpu_id,\r\nstimer->index, config, host);\r\nstimer_cleanup(stimer);\r\nif ((stimer->config & HV_STIMER_ENABLE) && HV_STIMER_SINT(config) == 0)\r\nconfig &= ~HV_STIMER_ENABLE;\r\nstimer->config = config;\r\nstimer_mark_pending(stimer, false);\r\nreturn 0;\r\n}\r\nstatic int stimer_set_count(struct kvm_vcpu_hv_stimer *stimer, u64 count,\r\nbool host)\r\n{\r\ntrace_kvm_hv_stimer_set_count(stimer_to_vcpu(stimer)->vcpu_id,\r\nstimer->index, count, host);\r\nstimer_cleanup(stimer);\r\nstimer->count = count;\r\nif (stimer->count == 0)\r\nstimer->config &= ~HV_STIMER_ENABLE;\r\nelse if (stimer->config & HV_STIMER_AUTOENABLE)\r\nstimer->config |= HV_STIMER_ENABLE;\r\nstimer_mark_pending(stimer, false);\r\nreturn 0;\r\n}\r\nstatic int stimer_get_config(struct kvm_vcpu_hv_stimer *stimer, u64 *pconfig)\r\n{\r\n*pconfig = stimer->config;\r\nreturn 0;\r\n}\r\nstatic int stimer_get_count(struct kvm_vcpu_hv_stimer *stimer, u64 *pcount)\r\n{\r\n*pcount = stimer->count;\r\nreturn 0;\r\n}\r\nstatic int synic_deliver_msg(struct kvm_vcpu_hv_synic *synic, u32 sint,\r\nstruct hv_message *src_msg)\r\n{\r\nstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\r\nstruct page *page;\r\ngpa_t gpa;\r\nstruct hv_message *dst_msg;\r\nint r;\r\nstruct hv_message_page *msg_page;\r\nif (!(synic->msg_page & HV_SYNIC_SIMP_ENABLE))\r\nreturn -ENOENT;\r\ngpa = synic->msg_page & PAGE_MASK;\r\npage = kvm_vcpu_gfn_to_page(vcpu, gpa >> PAGE_SHIFT);\r\nif (is_error_page(page))\r\nreturn -EFAULT;\r\nmsg_page = kmap_atomic(page);\r\ndst_msg = &msg_page->sint_message[sint];\r\nif (sync_cmpxchg(&dst_msg->header.message_type, HVMSG_NONE,\r\nsrc_msg->header.message_type) != HVMSG_NONE) {\r\ndst_msg->header.message_flags.msg_pending = 1;\r\nr = -EAGAIN;\r\n} else {\r\nmemcpy(&dst_msg->u.payload, &src_msg->u.payload,\r\nsrc_msg->header.payload_size);\r\ndst_msg->header.message_type = src_msg->header.message_type;\r\ndst_msg->header.payload_size = src_msg->header.payload_size;\r\nr = synic_set_irq(synic, sint);\r\nif (r >= 1)\r\nr = 0;\r\nelse if (r == 0)\r\nr = -EFAULT;\r\n}\r\nkunmap_atomic(msg_page);\r\nkvm_release_page_dirty(page);\r\nkvm_vcpu_mark_page_dirty(vcpu, gpa >> PAGE_SHIFT);\r\nreturn r;\r\n}\r\nstatic int stimer_send_msg(struct kvm_vcpu_hv_stimer *stimer)\r\n{\r\nstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\r\nstruct hv_message *msg = &stimer->msg;\r\nstruct hv_timer_message_payload *payload =\r\n(struct hv_timer_message_payload *)&msg->u.payload;\r\npayload->expiration_time = stimer->exp_time;\r\npayload->delivery_time = get_time_ref_counter(vcpu->kvm);\r\nreturn synic_deliver_msg(vcpu_to_synic(vcpu),\r\nHV_STIMER_SINT(stimer->config), msg);\r\n}\r\nstatic void stimer_expiration(struct kvm_vcpu_hv_stimer *stimer)\r\n{\r\nint r;\r\nstimer->msg_pending = true;\r\nr = stimer_send_msg(stimer);\r\ntrace_kvm_hv_stimer_expiration(stimer_to_vcpu(stimer)->vcpu_id,\r\nstimer->index, r);\r\nif (!r) {\r\nstimer->msg_pending = false;\r\nif (!(stimer->config & HV_STIMER_PERIODIC))\r\nstimer->config &= ~HV_STIMER_ENABLE;\r\n}\r\n}\r\nvoid kvm_hv_process_stimers(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\r\nstruct kvm_vcpu_hv_stimer *stimer;\r\nu64 time_now, exp_time;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(hv_vcpu->stimer); i++)\r\nif (test_and_clear_bit(i, hv_vcpu->stimer_pending_bitmap)) {\r\nstimer = &hv_vcpu->stimer[i];\r\nif (stimer->config & HV_STIMER_ENABLE) {\r\nexp_time = stimer->exp_time;\r\nif (exp_time) {\r\ntime_now =\r\nget_time_ref_counter(vcpu->kvm);\r\nif (time_now >= exp_time)\r\nstimer_expiration(stimer);\r\n}\r\nif ((stimer->config & HV_STIMER_ENABLE) &&\r\nstimer->count)\r\nstimer_start(stimer);\r\nelse\r\nstimer_cleanup(stimer);\r\n}\r\n}\r\n}\r\nvoid kvm_hv_vcpu_uninit(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(hv_vcpu->stimer); i++)\r\nstimer_cleanup(&hv_vcpu->stimer[i]);\r\n}\r\nstatic void stimer_prepare_msg(struct kvm_vcpu_hv_stimer *stimer)\r\n{\r\nstruct hv_message *msg = &stimer->msg;\r\nstruct hv_timer_message_payload *payload =\r\n(struct hv_timer_message_payload *)&msg->u.payload;\r\nmemset(&msg->header, 0, sizeof(msg->header));\r\nmsg->header.message_type = HVMSG_TIMER_EXPIRED;\r\nmsg->header.payload_size = sizeof(*payload);\r\npayload->timer_index = stimer->index;\r\npayload->expiration_time = 0;\r\npayload->delivery_time = 0;\r\n}\r\nstatic void stimer_init(struct kvm_vcpu_hv_stimer *stimer, int timer_index)\r\n{\r\nmemset(stimer, 0, sizeof(*stimer));\r\nstimer->index = timer_index;\r\nhrtimer_init(&stimer->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\r\nstimer->timer.function = stimer_timer_callback;\r\nstimer_prepare_msg(stimer);\r\n}\r\nvoid kvm_hv_vcpu_init(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\r\nint i;\r\nsynic_init(&hv_vcpu->synic);\r\nbitmap_zero(hv_vcpu->stimer_pending_bitmap, HV_SYNIC_STIMER_COUNT);\r\nfor (i = 0; i < ARRAY_SIZE(hv_vcpu->stimer); i++)\r\nstimer_init(&hv_vcpu->stimer[i], i);\r\n}\r\nint kvm_hv_activate_synic(struct kvm_vcpu *vcpu)\r\n{\r\nkvm_vcpu_deactivate_apicv(vcpu);\r\nvcpu_to_synic(vcpu)->active = true;\r\nreturn 0;\r\n}\r\nstatic bool kvm_hv_msr_partition_wide(u32 msr)\r\n{\r\nbool r = false;\r\nswitch (msr) {\r\ncase HV_X64_MSR_GUEST_OS_ID:\r\ncase HV_X64_MSR_HYPERCALL:\r\ncase HV_X64_MSR_REFERENCE_TSC:\r\ncase HV_X64_MSR_TIME_REF_COUNT:\r\ncase HV_X64_MSR_CRASH_CTL:\r\ncase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\r\ncase HV_X64_MSR_RESET:\r\nr = true;\r\nbreak;\r\n}\r\nreturn r;\r\n}\r\nstatic int kvm_hv_msr_get_crash_data(struct kvm_vcpu *vcpu,\r\nu32 index, u64 *pdata)\r\n{\r\nstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\r\nif (WARN_ON_ONCE(index >= ARRAY_SIZE(hv->hv_crash_param)))\r\nreturn -EINVAL;\r\n*pdata = hv->hv_crash_param[index];\r\nreturn 0;\r\n}\r\nstatic int kvm_hv_msr_get_crash_ctl(struct kvm_vcpu *vcpu, u64 *pdata)\r\n{\r\nstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\r\n*pdata = hv->hv_crash_ctl;\r\nreturn 0;\r\n}\r\nstatic int kvm_hv_msr_set_crash_ctl(struct kvm_vcpu *vcpu, u64 data, bool host)\r\n{\r\nstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\r\nif (host)\r\nhv->hv_crash_ctl = data & HV_X64_MSR_CRASH_CTL_NOTIFY;\r\nif (!host && (data & HV_X64_MSR_CRASH_CTL_NOTIFY)) {\r\nvcpu_debug(vcpu, "hv crash (0x%llx 0x%llx 0x%llx 0x%llx 0x%llx)\n",\r\nhv->hv_crash_param[0],\r\nhv->hv_crash_param[1],\r\nhv->hv_crash_param[2],\r\nhv->hv_crash_param[3],\r\nhv->hv_crash_param[4]);\r\nkvm_make_request(KVM_REQ_HV_CRASH, vcpu);\r\n}\r\nreturn 0;\r\n}\r\nstatic int kvm_hv_msr_set_crash_data(struct kvm_vcpu *vcpu,\r\nu32 index, u64 data)\r\n{\r\nstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\r\nif (WARN_ON_ONCE(index >= ARRAY_SIZE(hv->hv_crash_param)))\r\nreturn -EINVAL;\r\nhv->hv_crash_param[index] = data;\r\nreturn 0;\r\n}\r\nstatic bool compute_tsc_page_parameters(struct pvclock_vcpu_time_info *hv_clock,\r\nHV_REFERENCE_TSC_PAGE *tsc_ref)\r\n{\r\nu64 max_mul;\r\nif (!(hv_clock->flags & PVCLOCK_TSC_STABLE_BIT))\r\nreturn false;\r\nmax_mul = 100ull << (32 - hv_clock->tsc_shift);\r\nif (hv_clock->tsc_to_system_mul >= max_mul)\r\nreturn false;\r\ntsc_ref->tsc_scale =\r\nmul_u64_u32_div(1ULL << (32 + hv_clock->tsc_shift),\r\nhv_clock->tsc_to_system_mul,\r\n100);\r\ntsc_ref->tsc_offset = hv_clock->system_time;\r\ndo_div(tsc_ref->tsc_offset, 100);\r\ntsc_ref->tsc_offset -=\r\nmul_u64_u64_shr(hv_clock->tsc_timestamp, tsc_ref->tsc_scale, 64);\r\nreturn true;\r\n}\r\nvoid kvm_hv_setup_tsc_page(struct kvm *kvm,\r\nstruct pvclock_vcpu_time_info *hv_clock)\r\n{\r\nstruct kvm_hv *hv = &kvm->arch.hyperv;\r\nu32 tsc_seq;\r\nu64 gfn;\r\nBUILD_BUG_ON(sizeof(tsc_seq) != sizeof(hv->tsc_ref.tsc_sequence));\r\nBUILD_BUG_ON(offsetof(HV_REFERENCE_TSC_PAGE, tsc_sequence) != 0);\r\nif (!(hv->hv_tsc_page & HV_X64_MSR_TSC_REFERENCE_ENABLE))\r\nreturn;\r\nmutex_lock(&kvm->arch.hyperv.hv_lock);\r\nif (!(hv->hv_tsc_page & HV_X64_MSR_TSC_REFERENCE_ENABLE))\r\ngoto out_unlock;\r\ngfn = hv->hv_tsc_page >> HV_X64_MSR_TSC_REFERENCE_ADDRESS_SHIFT;\r\nif (unlikely(kvm_read_guest(kvm, gfn_to_gpa(gfn),\r\n&tsc_seq, sizeof(tsc_seq))))\r\ngoto out_unlock;\r\nhv->tsc_ref.tsc_sequence = 0;\r\nif (kvm_write_guest(kvm, gfn_to_gpa(gfn),\r\n&hv->tsc_ref, sizeof(hv->tsc_ref.tsc_sequence)))\r\ngoto out_unlock;\r\nif (!compute_tsc_page_parameters(hv_clock, &hv->tsc_ref))\r\ngoto out_unlock;\r\nsmp_wmb();\r\nif (kvm_write_guest(kvm, gfn_to_gpa(gfn), &hv->tsc_ref, sizeof(hv->tsc_ref)))\r\ngoto out_unlock;\r\ntsc_seq++;\r\nif (tsc_seq == 0xFFFFFFFF || tsc_seq == 0)\r\ntsc_seq = 1;\r\nsmp_wmb();\r\nhv->tsc_ref.tsc_sequence = tsc_seq;\r\nkvm_write_guest(kvm, gfn_to_gpa(gfn),\r\n&hv->tsc_ref, sizeof(hv->tsc_ref.tsc_sequence));\r\nout_unlock:\r\nmutex_unlock(&kvm->arch.hyperv.hv_lock);\r\n}\r\nstatic int kvm_hv_set_msr_pw(struct kvm_vcpu *vcpu, u32 msr, u64 data,\r\nbool host)\r\n{\r\nstruct kvm *kvm = vcpu->kvm;\r\nstruct kvm_hv *hv = &kvm->arch.hyperv;\r\nswitch (msr) {\r\ncase HV_X64_MSR_GUEST_OS_ID:\r\nhv->hv_guest_os_id = data;\r\nif (!hv->hv_guest_os_id)\r\nhv->hv_hypercall &= ~HV_X64_MSR_HYPERCALL_ENABLE;\r\nbreak;\r\ncase HV_X64_MSR_HYPERCALL: {\r\nu64 gfn;\r\nunsigned long addr;\r\nu8 instructions[4];\r\nif (!hv->hv_guest_os_id)\r\nbreak;\r\nif (!(data & HV_X64_MSR_HYPERCALL_ENABLE)) {\r\nhv->hv_hypercall = data;\r\nbreak;\r\n}\r\ngfn = data >> HV_X64_MSR_HYPERCALL_PAGE_ADDRESS_SHIFT;\r\naddr = gfn_to_hva(kvm, gfn);\r\nif (kvm_is_error_hva(addr))\r\nreturn 1;\r\nkvm_x86_ops->patch_hypercall(vcpu, instructions);\r\n((unsigned char *)instructions)[3] = 0xc3;\r\nif (__copy_to_user((void __user *)addr, instructions, 4))\r\nreturn 1;\r\nhv->hv_hypercall = data;\r\nmark_page_dirty(kvm, gfn);\r\nbreak;\r\n}\r\ncase HV_X64_MSR_REFERENCE_TSC:\r\nhv->hv_tsc_page = data;\r\nif (hv->hv_tsc_page & HV_X64_MSR_TSC_REFERENCE_ENABLE)\r\nkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\r\nbreak;\r\ncase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\r\nreturn kvm_hv_msr_set_crash_data(vcpu,\r\nmsr - HV_X64_MSR_CRASH_P0,\r\ndata);\r\ncase HV_X64_MSR_CRASH_CTL:\r\nreturn kvm_hv_msr_set_crash_ctl(vcpu, data, host);\r\ncase HV_X64_MSR_RESET:\r\nif (data == 1) {\r\nvcpu_debug(vcpu, "hyper-v reset requested\n");\r\nkvm_make_request(KVM_REQ_HV_RESET, vcpu);\r\n}\r\nbreak;\r\ndefault:\r\nvcpu_unimpl(vcpu, "Hyper-V uhandled wrmsr: 0x%x data 0x%llx\n",\r\nmsr, data);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic u64 current_task_runtime_100ns(void)\r\n{\r\nu64 utime, stime;\r\ntask_cputime_adjusted(current, &utime, &stime);\r\nreturn div_u64(utime + stime, 100);\r\n}\r\nstatic int kvm_hv_set_msr(struct kvm_vcpu *vcpu, u32 msr, u64 data, bool host)\r\n{\r\nstruct kvm_vcpu_hv *hv = &vcpu->arch.hyperv;\r\nswitch (msr) {\r\ncase HV_X64_MSR_APIC_ASSIST_PAGE: {\r\nu64 gfn;\r\nunsigned long addr;\r\nif (!(data & HV_X64_MSR_APIC_ASSIST_PAGE_ENABLE)) {\r\nhv->hv_vapic = data;\r\nif (kvm_lapic_enable_pv_eoi(vcpu, 0))\r\nreturn 1;\r\nbreak;\r\n}\r\ngfn = data >> HV_X64_MSR_APIC_ASSIST_PAGE_ADDRESS_SHIFT;\r\naddr = kvm_vcpu_gfn_to_hva(vcpu, gfn);\r\nif (kvm_is_error_hva(addr))\r\nreturn 1;\r\nif (__clear_user((void __user *)addr, PAGE_SIZE))\r\nreturn 1;\r\nhv->hv_vapic = data;\r\nkvm_vcpu_mark_page_dirty(vcpu, gfn);\r\nif (kvm_lapic_enable_pv_eoi(vcpu,\r\ngfn_to_gpa(gfn) | KVM_MSR_ENABLED))\r\nreturn 1;\r\nbreak;\r\n}\r\ncase HV_X64_MSR_EOI:\r\nreturn kvm_hv_vapic_msr_write(vcpu, APIC_EOI, data);\r\ncase HV_X64_MSR_ICR:\r\nreturn kvm_hv_vapic_msr_write(vcpu, APIC_ICR, data);\r\ncase HV_X64_MSR_TPR:\r\nreturn kvm_hv_vapic_msr_write(vcpu, APIC_TASKPRI, data);\r\ncase HV_X64_MSR_VP_RUNTIME:\r\nif (!host)\r\nreturn 1;\r\nhv->runtime_offset = data - current_task_runtime_100ns();\r\nbreak;\r\ncase HV_X64_MSR_SCONTROL:\r\ncase HV_X64_MSR_SVERSION:\r\ncase HV_X64_MSR_SIEFP:\r\ncase HV_X64_MSR_SIMP:\r\ncase HV_X64_MSR_EOM:\r\ncase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\r\nreturn synic_set_msr(vcpu_to_synic(vcpu), msr, data, host);\r\ncase HV_X64_MSR_STIMER0_CONFIG:\r\ncase HV_X64_MSR_STIMER1_CONFIG:\r\ncase HV_X64_MSR_STIMER2_CONFIG:\r\ncase HV_X64_MSR_STIMER3_CONFIG: {\r\nint timer_index = (msr - HV_X64_MSR_STIMER0_CONFIG)/2;\r\nreturn stimer_set_config(vcpu_to_stimer(vcpu, timer_index),\r\ndata, host);\r\n}\r\ncase HV_X64_MSR_STIMER0_COUNT:\r\ncase HV_X64_MSR_STIMER1_COUNT:\r\ncase HV_X64_MSR_STIMER2_COUNT:\r\ncase HV_X64_MSR_STIMER3_COUNT: {\r\nint timer_index = (msr - HV_X64_MSR_STIMER0_COUNT)/2;\r\nreturn stimer_set_count(vcpu_to_stimer(vcpu, timer_index),\r\ndata, host);\r\n}\r\ndefault:\r\nvcpu_unimpl(vcpu, "Hyper-V uhandled wrmsr: 0x%x data 0x%llx\n",\r\nmsr, data);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int kvm_hv_get_msr_pw(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\r\n{\r\nu64 data = 0;\r\nstruct kvm *kvm = vcpu->kvm;\r\nstruct kvm_hv *hv = &kvm->arch.hyperv;\r\nswitch (msr) {\r\ncase HV_X64_MSR_GUEST_OS_ID:\r\ndata = hv->hv_guest_os_id;\r\nbreak;\r\ncase HV_X64_MSR_HYPERCALL:\r\ndata = hv->hv_hypercall;\r\nbreak;\r\ncase HV_X64_MSR_TIME_REF_COUNT:\r\ndata = get_time_ref_counter(kvm);\r\nbreak;\r\ncase HV_X64_MSR_REFERENCE_TSC:\r\ndata = hv->hv_tsc_page;\r\nbreak;\r\ncase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\r\nreturn kvm_hv_msr_get_crash_data(vcpu,\r\nmsr - HV_X64_MSR_CRASH_P0,\r\npdata);\r\ncase HV_X64_MSR_CRASH_CTL:\r\nreturn kvm_hv_msr_get_crash_ctl(vcpu, pdata);\r\ncase HV_X64_MSR_RESET:\r\ndata = 0;\r\nbreak;\r\ndefault:\r\nvcpu_unimpl(vcpu, "Hyper-V unhandled rdmsr: 0x%x\n", msr);\r\nreturn 1;\r\n}\r\n*pdata = data;\r\nreturn 0;\r\n}\r\nstatic int kvm_hv_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\r\n{\r\nu64 data = 0;\r\nstruct kvm_vcpu_hv *hv = &vcpu->arch.hyperv;\r\nswitch (msr) {\r\ncase HV_X64_MSR_VP_INDEX: {\r\nint r;\r\nstruct kvm_vcpu *v;\r\nkvm_for_each_vcpu(r, v, vcpu->kvm) {\r\nif (v == vcpu) {\r\ndata = r;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\ncase HV_X64_MSR_EOI:\r\nreturn kvm_hv_vapic_msr_read(vcpu, APIC_EOI, pdata);\r\ncase HV_X64_MSR_ICR:\r\nreturn kvm_hv_vapic_msr_read(vcpu, APIC_ICR, pdata);\r\ncase HV_X64_MSR_TPR:\r\nreturn kvm_hv_vapic_msr_read(vcpu, APIC_TASKPRI, pdata);\r\ncase HV_X64_MSR_APIC_ASSIST_PAGE:\r\ndata = hv->hv_vapic;\r\nbreak;\r\ncase HV_X64_MSR_VP_RUNTIME:\r\ndata = current_task_runtime_100ns() + hv->runtime_offset;\r\nbreak;\r\ncase HV_X64_MSR_SCONTROL:\r\ncase HV_X64_MSR_SVERSION:\r\ncase HV_X64_MSR_SIEFP:\r\ncase HV_X64_MSR_SIMP:\r\ncase HV_X64_MSR_EOM:\r\ncase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\r\nreturn synic_get_msr(vcpu_to_synic(vcpu), msr, pdata);\r\ncase HV_X64_MSR_STIMER0_CONFIG:\r\ncase HV_X64_MSR_STIMER1_CONFIG:\r\ncase HV_X64_MSR_STIMER2_CONFIG:\r\ncase HV_X64_MSR_STIMER3_CONFIG: {\r\nint timer_index = (msr - HV_X64_MSR_STIMER0_CONFIG)/2;\r\nreturn stimer_get_config(vcpu_to_stimer(vcpu, timer_index),\r\npdata);\r\n}\r\ncase HV_X64_MSR_STIMER0_COUNT:\r\ncase HV_X64_MSR_STIMER1_COUNT:\r\ncase HV_X64_MSR_STIMER2_COUNT:\r\ncase HV_X64_MSR_STIMER3_COUNT: {\r\nint timer_index = (msr - HV_X64_MSR_STIMER0_COUNT)/2;\r\nreturn stimer_get_count(vcpu_to_stimer(vcpu, timer_index),\r\npdata);\r\n}\r\ndefault:\r\nvcpu_unimpl(vcpu, "Hyper-V unhandled rdmsr: 0x%x\n", msr);\r\nreturn 1;\r\n}\r\n*pdata = data;\r\nreturn 0;\r\n}\r\nint kvm_hv_set_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 data, bool host)\r\n{\r\nif (kvm_hv_msr_partition_wide(msr)) {\r\nint r;\r\nmutex_lock(&vcpu->kvm->arch.hyperv.hv_lock);\r\nr = kvm_hv_set_msr_pw(vcpu, msr, data, host);\r\nmutex_unlock(&vcpu->kvm->arch.hyperv.hv_lock);\r\nreturn r;\r\n} else\r\nreturn kvm_hv_set_msr(vcpu, msr, data, host);\r\n}\r\nint kvm_hv_get_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\r\n{\r\nif (kvm_hv_msr_partition_wide(msr)) {\r\nint r;\r\nmutex_lock(&vcpu->kvm->arch.hyperv.hv_lock);\r\nr = kvm_hv_get_msr_pw(vcpu, msr, pdata);\r\nmutex_unlock(&vcpu->kvm->arch.hyperv.hv_lock);\r\nreturn r;\r\n} else\r\nreturn kvm_hv_get_msr(vcpu, msr, pdata);\r\n}\r\nbool kvm_hv_hypercall_enabled(struct kvm *kvm)\r\n{\r\nreturn READ_ONCE(kvm->arch.hyperv.hv_hypercall) & HV_X64_MSR_HYPERCALL_ENABLE;\r\n}\r\nstatic void kvm_hv_hypercall_set_result(struct kvm_vcpu *vcpu, u64 result)\r\n{\r\nbool longmode;\r\nlongmode = is_64_bit_mode(vcpu);\r\nif (longmode)\r\nkvm_register_write(vcpu, VCPU_REGS_RAX, result);\r\nelse {\r\nkvm_register_write(vcpu, VCPU_REGS_RDX, result >> 32);\r\nkvm_register_write(vcpu, VCPU_REGS_RAX, result & 0xffffffff);\r\n}\r\n}\r\nstatic int kvm_hv_hypercall_complete_userspace(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_run *run = vcpu->run;\r\nkvm_hv_hypercall_set_result(vcpu, run->hyperv.u.hcall.result);\r\nreturn 1;\r\n}\r\nint kvm_hv_hypercall(struct kvm_vcpu *vcpu)\r\n{\r\nu64 param, ingpa, outgpa, ret;\r\nuint16_t code, rep_idx, rep_cnt, res = HV_STATUS_SUCCESS, rep_done = 0;\r\nbool fast, longmode;\r\nif (kvm_x86_ops->get_cpl(vcpu) != 0 || !is_protmode(vcpu)) {\r\nkvm_queue_exception(vcpu, UD_VECTOR);\r\nreturn 1;\r\n}\r\nlongmode = is_64_bit_mode(vcpu);\r\nif (!longmode) {\r\nparam = ((u64)kvm_register_read(vcpu, VCPU_REGS_RDX) << 32) |\r\n(kvm_register_read(vcpu, VCPU_REGS_RAX) & 0xffffffff);\r\ningpa = ((u64)kvm_register_read(vcpu, VCPU_REGS_RBX) << 32) |\r\n(kvm_register_read(vcpu, VCPU_REGS_RCX) & 0xffffffff);\r\noutgpa = ((u64)kvm_register_read(vcpu, VCPU_REGS_RDI) << 32) |\r\n(kvm_register_read(vcpu, VCPU_REGS_RSI) & 0xffffffff);\r\n}\r\n#ifdef CONFIG_X86_64\r\nelse {\r\nparam = kvm_register_read(vcpu, VCPU_REGS_RCX);\r\ningpa = kvm_register_read(vcpu, VCPU_REGS_RDX);\r\noutgpa = kvm_register_read(vcpu, VCPU_REGS_R8);\r\n}\r\n#endif\r\ncode = param & 0xffff;\r\nfast = (param >> 16) & 0x1;\r\nrep_cnt = (param >> 32) & 0xfff;\r\nrep_idx = (param >> 48) & 0xfff;\r\ntrace_kvm_hv_hypercall(code, fast, rep_cnt, rep_idx, ingpa, outgpa);\r\nif (rep_cnt || rep_idx) {\r\nres = HV_STATUS_INVALID_HYPERCALL_CODE;\r\ngoto set_result;\r\n}\r\nswitch (code) {\r\ncase HVCALL_NOTIFY_LONG_SPIN_WAIT:\r\nkvm_vcpu_on_spin(vcpu);\r\nbreak;\r\ncase HVCALL_POST_MESSAGE:\r\ncase HVCALL_SIGNAL_EVENT:\r\nif (!vcpu_to_synic(vcpu)->active) {\r\nres = HV_STATUS_INVALID_HYPERCALL_CODE;\r\nbreak;\r\n}\r\nvcpu->run->exit_reason = KVM_EXIT_HYPERV;\r\nvcpu->run->hyperv.type = KVM_EXIT_HYPERV_HCALL;\r\nvcpu->run->hyperv.u.hcall.input = param;\r\nvcpu->run->hyperv.u.hcall.params[0] = ingpa;\r\nvcpu->run->hyperv.u.hcall.params[1] = outgpa;\r\nvcpu->arch.complete_userspace_io =\r\nkvm_hv_hypercall_complete_userspace;\r\nreturn 0;\r\ndefault:\r\nres = HV_STATUS_INVALID_HYPERCALL_CODE;\r\nbreak;\r\n}\r\nset_result:\r\nret = res | (((u64)rep_done & 0xfff) << 32);\r\nkvm_hv_hypercall_set_result(vcpu, ret);\r\nreturn 1;\r\n}
