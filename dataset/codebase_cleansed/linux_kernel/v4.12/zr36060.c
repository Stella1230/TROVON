static u8\r\nzr36060_read (struct zr36060 *ptr,\r\nu16 reg)\r\n{\r\nu8 value = 0;\r\nif (ptr->codec->master_data->readreg)\r\nvalue = (ptr->codec->master_data->readreg(ptr->codec,\r\nreg)) & 0xff;\r\nelse\r\ndprintk(1,\r\nKERN_ERR "%s: invalid I/O setup, nothing read!\n",\r\nptr->name);\r\nreturn value;\r\n}\r\nstatic void\r\nzr36060_write(struct zr36060 *ptr,\r\nu16 reg,\r\nu8 value)\r\n{\r\ndprintk(4, "0x%02x @0x%04x\n", value, reg);\r\nif (ptr->codec->master_data->writereg)\r\nptr->codec->master_data->writereg(ptr->codec, reg, value);\r\nelse\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: invalid I/O setup, nothing written!\n",\r\nptr->name);\r\n}\r\nstatic u8\r\nzr36060_read_status (struct zr36060 *ptr)\r\n{\r\nptr->status = zr36060_read(ptr, ZR060_CFSR);\r\nzr36060_read(ptr, 0);\r\nreturn ptr->status;\r\n}\r\nstatic u16\r\nzr36060_read_scalefactor (struct zr36060 *ptr)\r\n{\r\nptr->scalefact = (zr36060_read(ptr, ZR060_SF_HI) << 8) |\r\n(zr36060_read(ptr, ZR060_SF_LO) & 0xFF);\r\nzr36060_read(ptr, 0);\r\nreturn ptr->scalefact;\r\n}\r\nstatic void\r\nzr36060_wait_end (struct zr36060 *ptr)\r\n{\r\nint i = 0;\r\nwhile (zr36060_read_status(ptr) & ZR060_CFSR_Busy) {\r\nudelay(1);\r\nif (i++ > 200000) {\r\ndprintk(1,\r\n"%s: timeout at wait_end (last status: 0x%02x)\n",\r\nptr->name, ptr->status);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int\r\nzr36060_basic_test (struct zr36060 *ptr)\r\n{\r\nif ((zr36060_read(ptr, ZR060_IDR_DEV) != 0x33) &&\r\n(zr36060_read(ptr, ZR060_IDR_REV) != 0x01)) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: attach failed, can't connect to jpeg processor!\n",\r\nptr->name);\r\nreturn -ENXIO;\r\n}\r\nzr36060_wait_end(ptr);\r\nif (ptr->status & ZR060_CFSR_Busy) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: attach failed, jpeg processor failed (end flag)!\n",\r\nptr->name);\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nzr36060_pushit (struct zr36060 *ptr,\r\nu16 startreg,\r\nu16 len,\r\nconst char *data)\r\n{\r\nint i = 0;\r\ndprintk(4, "%s: write data block to 0x%04x (len=%d)\n", ptr->name,\r\nstartreg, len);\r\nwhile (i < len) {\r\nzr36060_write(ptr, startreg++, data[i++]);\r\n}\r\nreturn i;\r\n}\r\nstatic int\r\nzr36060_set_sof (struct zr36060 *ptr)\r\n{\r\nchar sof_data[34];\r\nint i;\r\ndprintk(3, "%s: write SOF (%dx%d, %d components)\n", ptr->name,\r\nptr->width, ptr->height, NO_OF_COMPONENTS);\r\nsof_data[0] = 0xff;\r\nsof_data[1] = 0xc0;\r\nsof_data[2] = 0x00;\r\nsof_data[3] = (3 * NO_OF_COMPONENTS) + 8;\r\nsof_data[4] = BASELINE_PRECISION;\r\nsof_data[5] = (ptr->height) >> 8;\r\nsof_data[6] = (ptr->height) & 0xff;\r\nsof_data[7] = (ptr->width) >> 8;\r\nsof_data[8] = (ptr->width) & 0xff;\r\nsof_data[9] = NO_OF_COMPONENTS;\r\nfor (i = 0; i < NO_OF_COMPONENTS; i++) {\r\nsof_data[10 + (i * 3)] = i;\r\nsof_data[11 + (i * 3)] = (ptr->h_samp_ratio[i] << 4) |\r\n(ptr->v_samp_ratio[i]);\r\nsof_data[12 + (i * 3)] = zr36060_tq[i];\r\n}\r\nreturn zr36060_pushit(ptr, ZR060_SOF_IDX,\r\n(3 * NO_OF_COMPONENTS) + 10, sof_data);\r\n}\r\nstatic int\r\nzr36060_set_sos (struct zr36060 *ptr)\r\n{\r\nchar sos_data[16];\r\nint i;\r\ndprintk(3, "%s: write SOS\n", ptr->name);\r\nsos_data[0] = 0xff;\r\nsos_data[1] = 0xda;\r\nsos_data[2] = 0x00;\r\nsos_data[3] = 2 + 1 + (2 * NO_OF_COMPONENTS) + 3;\r\nsos_data[4] = NO_OF_COMPONENTS;\r\nfor (i = 0; i < NO_OF_COMPONENTS; i++) {\r\nsos_data[5 + (i * 2)] = i;\r\nsos_data[6 + (i * 2)] = (zr36060_td[i] << 4) |\r\nzr36060_ta[i];\r\n}\r\nsos_data[2 + 1 + (2 * NO_OF_COMPONENTS) + 2] = 00;\r\nsos_data[2 + 1 + (2 * NO_OF_COMPONENTS) + 3] = 0x3f;\r\nsos_data[2 + 1 + (2 * NO_OF_COMPONENTS) + 4] = 00;\r\nreturn zr36060_pushit(ptr, ZR060_SOS_IDX,\r\n4 + 1 + (2 * NO_OF_COMPONENTS) + 3,\r\nsos_data);\r\n}\r\nstatic int\r\nzr36060_set_dri (struct zr36060 *ptr)\r\n{\r\nchar dri_data[6];\r\ndprintk(3, "%s: write DRI\n", ptr->name);\r\ndri_data[0] = 0xff;\r\ndri_data[1] = 0xdd;\r\ndri_data[2] = 0x00;\r\ndri_data[3] = 0x04;\r\ndri_data[4] = (ptr->dri) >> 8;\r\ndri_data[5] = (ptr->dri) & 0xff;\r\nreturn zr36060_pushit(ptr, ZR060_DRI_IDX, 6, dri_data);\r\n}\r\nstatic void\r\nzr36060_init (struct zr36060 *ptr)\r\n{\r\nint sum = 0;\r\nlong bitcnt, tmp;\r\nif (ptr->mode == CODEC_DO_COMPRESSION) {\r\ndprintk(2, "%s: COMPRESSION SETUP\n", ptr->name);\r\nzr36060_write(ptr, ZR060_LOAD, ZR060_LOAD_SyncRst);\r\nzr36060_write(ptr, ZR060_CIR, ZR060_CIR_CodeMstr);\r\nzr36060_write(ptr, ZR060_CMR,\r\nZR060_CMR_Comp | ZR060_CMR_Pass2 |\r\nZR060_CMR_BRB);\r\nzr36060_write(ptr, ZR060_MBZ, 0x00);\r\nzr36060_write(ptr, ZR060_TCR_HI, 0x00);\r\nzr36060_write(ptr, ZR060_TCR_LO, 0x00);\r\nzr36060_write(ptr, ZR060_IMR, 0);\r\nzr36060_write(ptr, ZR060_SF_HI, ptr->scalefact >> 8);\r\nzr36060_write(ptr, ZR060_SF_LO, ptr->scalefact & 0xff);\r\nzr36060_write(ptr, ZR060_AF_HI, 0xff);\r\nzr36060_write(ptr, ZR060_AF_M, 0xff);\r\nzr36060_write(ptr, ZR060_AF_LO, 0xff);\r\nsum += zr36060_set_sof(ptr);\r\nsum += zr36060_set_sos(ptr);\r\nsum += zr36060_set_dri(ptr);\r\nsum +=\r\nzr36060_pushit(ptr, ZR060_DQT_IDX, sizeof(zr36060_dqt),\r\nzr36060_dqt);\r\nsum +=\r\nzr36060_pushit(ptr, ZR060_DHT_IDX, sizeof(zr36060_dht),\r\nzr36060_dht);\r\nzr36060_write(ptr, ZR060_APP_IDX, 0xff);\r\nzr36060_write(ptr, ZR060_APP_IDX + 1, 0xe0 + ptr->app.appn);\r\nzr36060_write(ptr, ZR060_APP_IDX + 2, 0x00);\r\nzr36060_write(ptr, ZR060_APP_IDX + 3, ptr->app.len + 2);\r\nsum += zr36060_pushit(ptr, ZR060_APP_IDX + 4, 60,\r\nptr->app.data) + 4;\r\nzr36060_write(ptr, ZR060_COM_IDX, 0xff);\r\nzr36060_write(ptr, ZR060_COM_IDX + 1, 0xfe);\r\nzr36060_write(ptr, ZR060_COM_IDX + 2, 0x00);\r\nzr36060_write(ptr, ZR060_COM_IDX + 3, ptr->com.len + 2);\r\nsum += zr36060_pushit(ptr, ZR060_COM_IDX + 4, 60,\r\nptr->com.data) + 4;\r\nsum = ptr->real_code_vol - sum;\r\nbitcnt = sum << 3;\r\ntmp = bitcnt >> 16;\r\ndprintk(3,\r\n"%s: code: csize=%d, tot=%d, bit=%ld, highbits=%ld\n",\r\nptr->name, sum, ptr->real_code_vol, bitcnt, tmp);\r\nzr36060_write(ptr, ZR060_TCV_NET_HI, tmp >> 8);\r\nzr36060_write(ptr, ZR060_TCV_NET_MH, tmp & 0xff);\r\ntmp = bitcnt & 0xffff;\r\nzr36060_write(ptr, ZR060_TCV_NET_ML, tmp >> 8);\r\nzr36060_write(ptr, ZR060_TCV_NET_LO, tmp & 0xff);\r\nbitcnt -= bitcnt >> 7;\r\nbitcnt -= ((bitcnt * 5) >> 6);\r\ntmp = bitcnt >> 16;\r\ndprintk(3, "%s: code: nettobit=%ld, highnettobits=%ld\n",\r\nptr->name, bitcnt, tmp);\r\nzr36060_write(ptr, ZR060_TCV_DATA_HI, tmp >> 8);\r\nzr36060_write(ptr, ZR060_TCV_DATA_MH, tmp & 0xff);\r\ntmp = bitcnt & 0xffff;\r\nzr36060_write(ptr, ZR060_TCV_DATA_ML, tmp >> 8);\r\nzr36060_write(ptr, ZR060_TCV_DATA_LO, tmp & 0xff);\r\nzr36060_write(ptr, ZR060_MER,\r\nZR060_MER_DQT | ZR060_MER_DHT |\r\n((ptr->com.len > 0) ? ZR060_MER_Com : 0) |\r\n((ptr->app.len > 0) ? ZR060_MER_App : 0));\r\nzr36060_write(ptr, ZR060_VCR, ZR060_VCR_Range);\r\n} else {\r\ndprintk(2, "%s: EXPANSION SETUP\n", ptr->name);\r\nzr36060_write(ptr, ZR060_LOAD, ZR060_LOAD_SyncRst);\r\nzr36060_write(ptr, ZR060_CIR, ZR060_CIR_CodeMstr);\r\nzr36060_write(ptr, ZR060_CMR, 0);\r\nzr36060_write(ptr, ZR060_MBZ, 0x00);\r\nzr36060_write(ptr, ZR060_TCR_HI, 0x00);\r\nzr36060_write(ptr, ZR060_TCR_LO, 0x00);\r\nzr36060_write(ptr, ZR060_IMR, 0);\r\nzr36060_write(ptr, ZR060_MER, 0);\r\nzr36060_pushit(ptr, ZR060_DHT_IDX, sizeof(zr36060_dht),\r\nzr36060_dht);\r\nzr36060_write(ptr, ZR060_VCR, ZR060_VCR_Range);\r\n}\r\nzr36060_write(ptr, ZR060_LOAD,\r\nZR060_LOAD_SyncRst | ZR060_LOAD_Load);\r\nzr36060_wait_end(ptr);\r\ndprintk(2, "%s: Status after table preload: 0x%02x\n", ptr->name,\r\nptr->status);\r\nif (ptr->status & ZR060_CFSR_Busy) {\r\ndprintk(1, KERN_ERR "%s: init aborted!\n", ptr->name);\r\nreturn;\r\n}\r\n}\r\nstatic int\r\nzr36060_set_mode (struct videocodec *codec,\r\nint mode)\r\n{\r\nstruct zr36060 *ptr = (struct zr36060 *) codec->data;\r\ndprintk(2, "%s: set_mode %d call\n", ptr->name, mode);\r\nif ((mode != CODEC_DO_EXPANSION) && (mode != CODEC_DO_COMPRESSION))\r\nreturn -EINVAL;\r\nptr->mode = mode;\r\nzr36060_init(ptr);\r\nreturn 0;\r\n}\r\nstatic int\r\nzr36060_set_video (struct videocodec *codec,\r\nstruct tvnorm *norm,\r\nstruct vfe_settings *cap,\r\nstruct vfe_polarity *pol)\r\n{\r\nstruct zr36060 *ptr = (struct zr36060 *) codec->data;\r\nu32 reg;\r\nint size;\r\ndprintk(2, "%s: set_video %d/%d-%dx%d (%%%d) call\n", ptr->name,\r\ncap->x, cap->y, cap->width, cap->height, cap->decimation);\r\nptr->width = cap->width / (cap->decimation & 0xff);\r\nptr->height = cap->height / (cap->decimation >> 8);\r\nzr36060_write(ptr, ZR060_LOAD, ZR060_LOAD_SyncRst);\r\nreg = (!pol->vsync_pol ? ZR060_VPR_VSPol : 0)\r\n| (!pol->hsync_pol ? ZR060_VPR_HSPol : 0)\r\n| (pol->field_pol ? ZR060_VPR_FIPol : 0)\r\n| (pol->blank_pol ? ZR060_VPR_BLPol : 0)\r\n| (pol->subimg_pol ? ZR060_VPR_SImgPol : 0)\r\n| (pol->poe_pol ? ZR060_VPR_PoePol : 0)\r\n| (pol->pvalid_pol ? ZR060_VPR_PValPol : 0)\r\n| (pol->vclk_pol ? ZR060_VPR_VCLKPol : 0);\r\nzr36060_write(ptr, ZR060_VPR, reg);\r\nreg = 0;\r\nswitch (cap->decimation & 0xff) {\r\ndefault:\r\ncase 1:\r\nbreak;\r\ncase 2:\r\nreg |= ZR060_SR_HScale2;\r\nbreak;\r\ncase 4:\r\nreg |= ZR060_SR_HScale4;\r\nbreak;\r\n}\r\nswitch (cap->decimation >> 8) {\r\ndefault:\r\ncase 1:\r\nbreak;\r\ncase 2:\r\nreg |= ZR060_SR_VScale;\r\nbreak;\r\n}\r\nzr36060_write(ptr, ZR060_SR, reg);\r\nzr36060_write(ptr, ZR060_BCR_Y, 0x00);\r\nzr36060_write(ptr, ZR060_BCR_U, 0x80);\r\nzr36060_write(ptr, ZR060_BCR_V, 0x80);\r\nreg = norm->Ht - 1;\r\nzr36060_write(ptr, ZR060_SGR_VTOTAL_HI, (reg >> 8) & 0xff);\r\nzr36060_write(ptr, ZR060_SGR_VTOTAL_LO, (reg >> 0) & 0xff);\r\nreg = norm->Wt - 1;\r\nzr36060_write(ptr, ZR060_SGR_HTOTAL_HI, (reg >> 8) & 0xff);\r\nzr36060_write(ptr, ZR060_SGR_HTOTAL_LO, (reg >> 0) & 0xff);\r\nreg = 6 - 1;\r\nzr36060_write(ptr, ZR060_SGR_VSYNC, reg);\r\nreg = 68;\r\nzr36060_write(ptr, ZR060_SGR_HSYNC, reg);\r\nreg = norm->VStart - 1;\r\nzr36060_write(ptr, ZR060_SGR_BVSTART, reg);\r\nreg += norm->Ha / 2;\r\nzr36060_write(ptr, ZR060_SGR_BVEND_HI, (reg >> 8) & 0xff);\r\nzr36060_write(ptr, ZR060_SGR_BVEND_LO, (reg >> 0) & 0xff);\r\nreg = norm->HStart - 1;\r\nzr36060_write(ptr, ZR060_SGR_BHSTART, reg);\r\nreg += norm->Wa;\r\nzr36060_write(ptr, ZR060_SGR_BHEND_HI, (reg >> 8) & 0xff);\r\nzr36060_write(ptr, ZR060_SGR_BHEND_LO, (reg >> 0) & 0xff);\r\nreg = cap->y + norm->VStart;\r\nzr36060_write(ptr, ZR060_AAR_VSTART_HI, (reg >> 8) & 0xff);\r\nzr36060_write(ptr, ZR060_AAR_VSTART_LO, (reg >> 0) & 0xff);\r\nreg += cap->height;\r\nzr36060_write(ptr, ZR060_AAR_VEND_HI, (reg >> 8) & 0xff);\r\nzr36060_write(ptr, ZR060_AAR_VEND_LO, (reg >> 0) & 0xff);\r\nreg = cap->x + norm->HStart;\r\nzr36060_write(ptr, ZR060_AAR_HSTART_HI, (reg >> 8) & 0xff);\r\nzr36060_write(ptr, ZR060_AAR_HSTART_LO, (reg >> 0) & 0xff);\r\nreg += cap->width;\r\nzr36060_write(ptr, ZR060_AAR_HEND_HI, (reg >> 8) & 0xff);\r\nzr36060_write(ptr, ZR060_AAR_HEND_LO, (reg >> 0) & 0xff);\r\nreg = norm->VStart - 4;\r\nzr36060_write(ptr, ZR060_SWR_VSTART_HI, (reg >> 8) & 0xff);\r\nzr36060_write(ptr, ZR060_SWR_VSTART_LO, (reg >> 0) & 0xff);\r\nreg += norm->Ha / 2 + 8;\r\nzr36060_write(ptr, ZR060_SWR_VEND_HI, (reg >> 8) & 0xff);\r\nzr36060_write(ptr, ZR060_SWR_VEND_LO, (reg >> 0) & 0xff);\r\nreg = norm->HStart - 4;\r\nzr36060_write(ptr, ZR060_SWR_HSTART_HI, (reg >> 8) & 0xff);\r\nzr36060_write(ptr, ZR060_SWR_HSTART_LO, (reg >> 0) & 0xff);\r\nreg += norm->Wa + 8;\r\nzr36060_write(ptr, ZR060_SWR_HEND_HI, (reg >> 8) & 0xff);\r\nzr36060_write(ptr, ZR060_SWR_HEND_LO, (reg >> 0) & 0xff);\r\nsize = ptr->width * ptr->height;\r\nsize = size * 16;\r\nsize = size * cap->quality / (low_bitrate ? 400 : 200);\r\nif (size < 8192)\r\nsize = 8192;\r\nif (size > ptr->total_code_vol * 7)\r\nsize = ptr->total_code_vol * 7;\r\nptr->real_code_vol = size >> 3;\r\nreg = ptr->max_block_vol;\r\nzr36060_write(ptr, ZR060_MBCVR, reg);\r\nreturn 0;\r\n}\r\nstatic int\r\nzr36060_control (struct videocodec *codec,\r\nint type,\r\nint size,\r\nvoid *data)\r\n{\r\nstruct zr36060 *ptr = (struct zr36060 *) codec->data;\r\nint *ival = (int *) data;\r\ndprintk(2, "%s: control %d call with %d byte\n", ptr->name, type,\r\nsize);\r\nswitch (type) {\r\ncase CODEC_G_STATUS:\r\nif (size != sizeof(int))\r\nreturn -EFAULT;\r\nzr36060_read_status(ptr);\r\n*ival = ptr->status;\r\nbreak;\r\ncase CODEC_G_CODEC_MODE:\r\nif (size != sizeof(int))\r\nreturn -EFAULT;\r\n*ival = CODEC_MODE_BJPG;\r\nbreak;\r\ncase CODEC_S_CODEC_MODE:\r\nif (size != sizeof(int))\r\nreturn -EFAULT;\r\nif (*ival != CODEC_MODE_BJPG)\r\nreturn -EINVAL;\r\nreturn 0;\r\ncase CODEC_G_VFE:\r\ncase CODEC_S_VFE:\r\nreturn 0;\r\ncase CODEC_S_MMAP:\r\nreturn -ENXIO;\r\ncase CODEC_G_JPEG_TDS_BYTE:\r\nif (size != sizeof(int))\r\nreturn -EFAULT;\r\n*ival = ptr->total_code_vol;\r\nbreak;\r\ncase CODEC_S_JPEG_TDS_BYTE:\r\nif (size != sizeof(int))\r\nreturn -EFAULT;\r\nptr->total_code_vol = *ival;\r\nptr->real_code_vol = (ptr->total_code_vol * 6) >> 3;\r\nbreak;\r\ncase CODEC_G_JPEG_SCALE:\r\nif (size != sizeof(int))\r\nreturn -EFAULT;\r\n*ival = zr36060_read_scalefactor(ptr);\r\nbreak;\r\ncase CODEC_S_JPEG_SCALE:\r\nif (size != sizeof(int))\r\nreturn -EFAULT;\r\nptr->scalefact = *ival;\r\nbreak;\r\ncase CODEC_G_JPEG_APP_DATA: {\r\nstruct jpeg_app_marker *app = data;\r\nif (size != sizeof(struct jpeg_app_marker))\r\nreturn -EFAULT;\r\n*app = ptr->app;\r\nbreak;\r\n}\r\ncase CODEC_S_JPEG_APP_DATA: {\r\nstruct jpeg_app_marker *app = data;\r\nif (size != sizeof(struct jpeg_app_marker))\r\nreturn -EFAULT;\r\nptr->app = *app;\r\nbreak;\r\n}\r\ncase CODEC_G_JPEG_COM_DATA: {\r\nstruct jpeg_com_marker *com = data;\r\nif (size != sizeof(struct jpeg_com_marker))\r\nreturn -EFAULT;\r\n*com = ptr->com;\r\nbreak;\r\n}\r\ncase CODEC_S_JPEG_COM_DATA: {\r\nstruct jpeg_com_marker *com = data;\r\nif (size != sizeof(struct jpeg_com_marker))\r\nreturn -EFAULT;\r\nptr->com = *com;\r\nbreak;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn size;\r\n}\r\nstatic int\r\nzr36060_unset (struct videocodec *codec)\r\n{\r\nstruct zr36060 *ptr = codec->data;\r\nif (ptr) {\r\ndprintk(1, "%s: finished codec #%d\n", ptr->name,\r\nptr->num);\r\nkfree(ptr);\r\ncodec->data = NULL;\r\nzr36060_codecs--;\r\nreturn 0;\r\n}\r\nreturn -EFAULT;\r\n}\r\nstatic int\r\nzr36060_setup (struct videocodec *codec)\r\n{\r\nstruct zr36060 *ptr;\r\nint res;\r\ndprintk(2, "zr36060: initializing MJPEG subsystem #%d.\n",\r\nzr36060_codecs);\r\nif (zr36060_codecs == MAX_CODECS) {\r\ndprintk(1,\r\nKERN_ERR "zr36060: Can't attach more codecs!\n");\r\nreturn -ENOSPC;\r\n}\r\ncodec->data = ptr = kzalloc(sizeof(struct zr36060), GFP_KERNEL);\r\nif (NULL == ptr) {\r\ndprintk(1, KERN_ERR "zr36060: Can't get enough memory!\n");\r\nreturn -ENOMEM;\r\n}\r\nsnprintf(ptr->name, sizeof(ptr->name), "zr36060[%d]",\r\nzr36060_codecs);\r\nptr->num = zr36060_codecs++;\r\nptr->codec = codec;\r\nres = zr36060_basic_test(ptr);\r\nif (res < 0) {\r\nzr36060_unset(codec);\r\nreturn res;\r\n}\r\nmemcpy(ptr->h_samp_ratio, zr36060_decimation_h, 8);\r\nmemcpy(ptr->v_samp_ratio, zr36060_decimation_v, 8);\r\nptr->bitrate_ctrl = 0;\r\nptr->mode = CODEC_DO_COMPRESSION;\r\nptr->width = 384;\r\nptr->height = 288;\r\nptr->total_code_vol = 16000;\r\nptr->real_code_vol = (ptr->total_code_vol * 6) >> 3;\r\nptr->max_block_vol = 240;\r\nptr->scalefact = 0x100;\r\nptr->dri = 1;\r\nptr->com.len = 0;\r\nptr->app.appn = 0;\r\nptr->app.len = 0;\r\nzr36060_init(ptr);\r\ndprintk(1, KERN_INFO "%s: codec attached and running\n",\r\nptr->name);\r\nreturn 0;\r\n}\r\nstatic int __init\r\nzr36060_init_module (void)\r\n{\r\nzr36060_codecs = 0;\r\nreturn videocodec_register(&zr36060_codec);\r\n}\r\nstatic void __exit\r\nzr36060_cleanup_module (void)\r\n{\r\nif (zr36060_codecs) {\r\ndprintk(1,\r\n"zr36060: something's wrong - %d codecs left somehow.\n",\r\nzr36060_codecs);\r\n}\r\nvideocodec_unregister(&zr36060_codec);\r\n}
