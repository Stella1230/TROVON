static void set_l2_indirect_reg(u64 reg, u64 val)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&l2_access_lock, flags);\r\nwrite_sysreg_s(reg, L2CPUSRSELR_EL1);\r\nisb();\r\nwrite_sysreg_s(val, L2CPUSRDR_EL1);\r\nisb();\r\nraw_spin_unlock_irqrestore(&l2_access_lock, flags);\r\n}\r\nstatic u64 get_l2_indirect_reg(u64 reg)\r\n{\r\nu64 val;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&l2_access_lock, flags);\r\nwrite_sysreg_s(reg, L2CPUSRSELR_EL1);\r\nisb();\r\nval = read_sysreg_s(L2CPUSRDR_EL1);\r\nraw_spin_unlock_irqrestore(&l2_access_lock, flags);\r\nreturn val;\r\n}\r\nstatic inline u32 idx_to_reg_bit(u32 idx)\r\n{\r\nif (idx == l2_cycle_ctr_idx)\r\nreturn BIT(L2CYCLE_CTR_BIT);\r\nreturn BIT(idx);\r\n}\r\nstatic inline struct cluster_pmu *get_cluster_pmu(\r\nstruct l2cache_pmu *l2cache_pmu, int cpu)\r\n{\r\nreturn *per_cpu_ptr(l2cache_pmu->pmu_cluster, cpu);\r\n}\r\nstatic void cluster_pmu_reset(void)\r\n{\r\nset_l2_indirect_reg(L2PMCR, L2PMCR_RESET_ALL);\r\nset_l2_indirect_reg(L2PMCNTENCLR, l2_counter_present_mask);\r\nset_l2_indirect_reg(L2PMINTENCLR, l2_counter_present_mask);\r\nset_l2_indirect_reg(L2PMOVSCLR, l2_counter_present_mask);\r\n}\r\nstatic inline void cluster_pmu_enable(void)\r\n{\r\nset_l2_indirect_reg(L2PMCR, L2PMCR_COUNTERS_ENABLE);\r\n}\r\nstatic inline void cluster_pmu_disable(void)\r\n{\r\nset_l2_indirect_reg(L2PMCR, L2PMCR_COUNTERS_DISABLE);\r\n}\r\nstatic inline void cluster_pmu_counter_set_value(u32 idx, u64 value)\r\n{\r\nif (idx == l2_cycle_ctr_idx)\r\nset_l2_indirect_reg(L2PMCCNTR, value);\r\nelse\r\nset_l2_indirect_reg(reg_idx(IA_L2PMXEVCNTR, idx), value);\r\n}\r\nstatic inline u64 cluster_pmu_counter_get_value(u32 idx)\r\n{\r\nu64 value;\r\nif (idx == l2_cycle_ctr_idx)\r\nvalue = get_l2_indirect_reg(L2PMCCNTR);\r\nelse\r\nvalue = get_l2_indirect_reg(reg_idx(IA_L2PMXEVCNTR, idx));\r\nreturn value;\r\n}\r\nstatic inline void cluster_pmu_counter_enable(u32 idx)\r\n{\r\nset_l2_indirect_reg(L2PMCNTENSET, idx_to_reg_bit(idx));\r\n}\r\nstatic inline void cluster_pmu_counter_disable(u32 idx)\r\n{\r\nset_l2_indirect_reg(L2PMCNTENCLR, idx_to_reg_bit(idx));\r\n}\r\nstatic inline void cluster_pmu_counter_enable_interrupt(u32 idx)\r\n{\r\nset_l2_indirect_reg(L2PMINTENSET, idx_to_reg_bit(idx));\r\n}\r\nstatic inline void cluster_pmu_counter_disable_interrupt(u32 idx)\r\n{\r\nset_l2_indirect_reg(L2PMINTENCLR, idx_to_reg_bit(idx));\r\n}\r\nstatic inline void cluster_pmu_set_evccntcr(u32 val)\r\n{\r\nset_l2_indirect_reg(L2PMCCNTCR, val);\r\n}\r\nstatic inline void cluster_pmu_set_evcntcr(u32 ctr, u32 val)\r\n{\r\nset_l2_indirect_reg(reg_idx(IA_L2PMXEVCNTCR, ctr), val);\r\n}\r\nstatic inline void cluster_pmu_set_evtyper(u32 ctr, u32 val)\r\n{\r\nset_l2_indirect_reg(reg_idx(IA_L2PMXEVTYPER, ctr), val);\r\n}\r\nstatic void cluster_pmu_set_resr(struct cluster_pmu *cluster,\r\nu32 event_group, u32 event_cc)\r\n{\r\nu64 field;\r\nu64 resr_val;\r\nu32 shift;\r\nunsigned long flags;\r\nshift = L2PMRESR_GROUP_BITS * event_group;\r\nfield = ((u64)(event_cc & L2PMRESR_GROUP_MASK) << shift);\r\nspin_lock_irqsave(&cluster->pmu_lock, flags);\r\nresr_val = get_l2_indirect_reg(L2PMRESR);\r\nresr_val &= ~(L2PMRESR_GROUP_MASK << shift);\r\nresr_val |= field;\r\nresr_val |= L2PMRESR_EN;\r\nset_l2_indirect_reg(L2PMRESR, resr_val);\r\nspin_unlock_irqrestore(&cluster->pmu_lock, flags);\r\n}\r\nstatic inline void cluster_pmu_set_evfilter_sys_mode(u32 ctr)\r\n{\r\nu32 val = L2PMXEVFILTER_SUFILTER_ALL |\r\nL2PMXEVFILTER_ORGFILTER_IDINDEP |\r\nL2PMXEVFILTER_ORGFILTER_ALL;\r\nset_l2_indirect_reg(reg_idx(IA_L2PMXEVFILTER, ctr), val);\r\n}\r\nstatic inline u32 cluster_pmu_getreset_ovsr(void)\r\n{\r\nu32 result = get_l2_indirect_reg(L2PMOVSSET);\r\nset_l2_indirect_reg(L2PMOVSCLR, result);\r\nreturn result;\r\n}\r\nstatic inline bool cluster_pmu_has_overflowed(u32 ovsr)\r\n{\r\nreturn !!(ovsr & l2_counter_present_mask);\r\n}\r\nstatic inline bool cluster_pmu_counter_has_overflowed(u32 ovsr, u32 idx)\r\n{\r\nreturn !!(ovsr & idx_to_reg_bit(idx));\r\n}\r\nstatic void l2_cache_event_update(struct perf_event *event)\r\n{\r\nstruct hw_perf_event *hwc = &event->hw;\r\nu64 delta, prev, now;\r\nu32 idx = hwc->idx;\r\ndo {\r\nprev = local64_read(&hwc->prev_count);\r\nnow = cluster_pmu_counter_get_value(idx);\r\n} while (local64_cmpxchg(&hwc->prev_count, prev, now) != prev);\r\ndelta = now - prev;\r\nif (idx != l2_cycle_ctr_idx)\r\ndelta &= 0xffffffff;\r\nlocal64_add(delta, &event->count);\r\n}\r\nstatic void l2_cache_cluster_set_period(struct cluster_pmu *cluster,\r\nstruct hw_perf_event *hwc)\r\n{\r\nu32 idx = hwc->idx;\r\nu64 new;\r\nif (idx == l2_cycle_ctr_idx)\r\nnew = L2_CYCLE_COUNTER_RELOAD;\r\nelse\r\nnew = L2_COUNTER_RELOAD;\r\nlocal64_set(&hwc->prev_count, new);\r\ncluster_pmu_counter_set_value(idx, new);\r\n}\r\nstatic int l2_cache_get_event_idx(struct cluster_pmu *cluster,\r\nstruct perf_event *event)\r\n{\r\nstruct hw_perf_event *hwc = &event->hw;\r\nint idx;\r\nint num_ctrs = cluster->l2cache_pmu->num_counters - 1;\r\nunsigned int group;\r\nif (hwc->config_base == L2CYCLE_CTR_RAW_CODE) {\r\nif (test_and_set_bit(l2_cycle_ctr_idx, cluster->used_counters))\r\nreturn -EAGAIN;\r\nreturn l2_cycle_ctr_idx;\r\n}\r\nidx = find_first_zero_bit(cluster->used_counters, num_ctrs);\r\nif (idx == num_ctrs)\r\nreturn -EAGAIN;\r\ngroup = L2_EVT_GROUP(hwc->config_base);\r\nif (test_bit(group, cluster->used_groups))\r\nreturn -EAGAIN;\r\nset_bit(idx, cluster->used_counters);\r\nset_bit(group, cluster->used_groups);\r\nreturn idx;\r\n}\r\nstatic void l2_cache_clear_event_idx(struct cluster_pmu *cluster,\r\nstruct perf_event *event)\r\n{\r\nstruct hw_perf_event *hwc = &event->hw;\r\nint idx = hwc->idx;\r\nclear_bit(idx, cluster->used_counters);\r\nif (hwc->config_base != L2CYCLE_CTR_RAW_CODE)\r\nclear_bit(L2_EVT_GROUP(hwc->config_base), cluster->used_groups);\r\n}\r\nstatic irqreturn_t l2_cache_handle_irq(int irq_num, void *data)\r\n{\r\nstruct cluster_pmu *cluster = data;\r\nint num_counters = cluster->l2cache_pmu->num_counters;\r\nu32 ovsr;\r\nint idx;\r\novsr = cluster_pmu_getreset_ovsr();\r\nif (!cluster_pmu_has_overflowed(ovsr))\r\nreturn IRQ_NONE;\r\nfor_each_set_bit(idx, cluster->used_counters, num_counters) {\r\nstruct perf_event *event = cluster->events[idx];\r\nstruct hw_perf_event *hwc;\r\nif (WARN_ON_ONCE(!event))\r\ncontinue;\r\nif (!cluster_pmu_counter_has_overflowed(ovsr, idx))\r\ncontinue;\r\nl2_cache_event_update(event);\r\nhwc = &event->hw;\r\nl2_cache_cluster_set_period(cluster, hwc);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void l2_cache_pmu_enable(struct pmu *pmu)\r\n{\r\ncluster_pmu_enable();\r\n}\r\nstatic void l2_cache_pmu_disable(struct pmu *pmu)\r\n{\r\ncluster_pmu_disable();\r\n}\r\nstatic int l2_cache_event_init(struct perf_event *event)\r\n{\r\nstruct hw_perf_event *hwc = &event->hw;\r\nstruct cluster_pmu *cluster;\r\nstruct perf_event *sibling;\r\nstruct l2cache_pmu *l2cache_pmu;\r\nif (event->attr.type != event->pmu->type)\r\nreturn -ENOENT;\r\nl2cache_pmu = to_l2cache_pmu(event->pmu);\r\nif (hwc->sample_period) {\r\ndev_dbg_ratelimited(&l2cache_pmu->pdev->dev,\r\n"Sampling not supported\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (event->cpu < 0) {\r\ndev_dbg_ratelimited(&l2cache_pmu->pdev->dev,\r\n"Per-task mode not supported\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (event->attr.exclude_user || event->attr.exclude_kernel ||\r\nevent->attr.exclude_hv || event->attr.exclude_idle) {\r\ndev_dbg_ratelimited(&l2cache_pmu->pdev->dev,\r\n"Can't exclude execution levels\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (((L2_EVT_GROUP(event->attr.config) > L2_EVT_GROUP_MAX) ||\r\n((event->attr.config & ~L2_EVT_MASK) != 0)) &&\r\n(event->attr.config != L2CYCLE_CTR_RAW_CODE)) {\r\ndev_dbg_ratelimited(&l2cache_pmu->pdev->dev,\r\n"Invalid config %llx\n",\r\nevent->attr.config);\r\nreturn -EINVAL;\r\n}\r\nif (event->group_leader->pmu != event->pmu &&\r\n!is_software_event(event->group_leader)) {\r\ndev_dbg_ratelimited(&l2cache_pmu->pdev->dev,\r\n"Can't create mixed PMU group\n");\r\nreturn -EINVAL;\r\n}\r\nlist_for_each_entry(sibling, &event->group_leader->sibling_list,\r\ngroup_entry)\r\nif (sibling->pmu != event->pmu &&\r\n!is_software_event(sibling)) {\r\ndev_dbg_ratelimited(&l2cache_pmu->pdev->dev,\r\n"Can't create mixed PMU group\n");\r\nreturn -EINVAL;\r\n}\r\ncluster = get_cluster_pmu(l2cache_pmu, event->cpu);\r\nif (!cluster) {\r\ndev_dbg_ratelimited(&l2cache_pmu->pdev->dev,\r\n"CPU%d not associated with L2 cluster\n", event->cpu);\r\nreturn -EINVAL;\r\n}\r\nif ((event->group_leader != event) &&\r\n(cluster->on_cpu != event->group_leader->cpu)) {\r\ndev_dbg_ratelimited(&l2cache_pmu->pdev->dev,\r\n"Can't create group on CPUs %d and %d",\r\nevent->cpu, event->group_leader->cpu);\r\nreturn -EINVAL;\r\n}\r\nif ((event != event->group_leader) &&\r\n(L2_EVT_GROUP(event->group_leader->attr.config) ==\r\nL2_EVT_GROUP(event->attr.config))) {\r\ndev_dbg_ratelimited(&l2cache_pmu->pdev->dev,\r\n"Column exclusion: conflicting events %llx %llx\n",\r\nevent->group_leader->attr.config,\r\nevent->attr.config);\r\nreturn -EINVAL;\r\n}\r\nlist_for_each_entry(sibling, &event->group_leader->sibling_list,\r\ngroup_entry) {\r\nif ((sibling != event) &&\r\n(L2_EVT_GROUP(sibling->attr.config) ==\r\nL2_EVT_GROUP(event->attr.config))) {\r\ndev_dbg_ratelimited(&l2cache_pmu->pdev->dev,\r\n"Column exclusion: conflicting events %llx %llx\n",\r\nsibling->attr.config,\r\nevent->attr.config);\r\nreturn -EINVAL;\r\n}\r\n}\r\nhwc->idx = -1;\r\nhwc->config_base = event->attr.config;\r\nevent->cpu = cluster->on_cpu;\r\nreturn 0;\r\n}\r\nstatic void l2_cache_event_start(struct perf_event *event, int flags)\r\n{\r\nstruct cluster_pmu *cluster;\r\nstruct hw_perf_event *hwc = &event->hw;\r\nint idx = hwc->idx;\r\nu32 config;\r\nu32 event_cc, event_group;\r\nhwc->state = 0;\r\ncluster = get_cluster_pmu(to_l2cache_pmu(event->pmu), event->cpu);\r\nl2_cache_cluster_set_period(cluster, hwc);\r\nif (hwc->config_base == L2CYCLE_CTR_RAW_CODE) {\r\ncluster_pmu_set_evccntcr(0);\r\n} else {\r\nconfig = hwc->config_base;\r\nevent_cc = L2_EVT_CODE(config);\r\nevent_group = L2_EVT_GROUP(config);\r\ncluster_pmu_set_evcntcr(idx, 0);\r\ncluster_pmu_set_evtyper(idx, event_group);\r\ncluster_pmu_set_resr(cluster, event_group, event_cc);\r\ncluster_pmu_set_evfilter_sys_mode(idx);\r\n}\r\ncluster_pmu_counter_enable_interrupt(idx);\r\ncluster_pmu_counter_enable(idx);\r\n}\r\nstatic void l2_cache_event_stop(struct perf_event *event, int flags)\r\n{\r\nstruct hw_perf_event *hwc = &event->hw;\r\nint idx = hwc->idx;\r\nif (hwc->state & PERF_HES_STOPPED)\r\nreturn;\r\ncluster_pmu_counter_disable_interrupt(idx);\r\ncluster_pmu_counter_disable(idx);\r\nif (flags & PERF_EF_UPDATE)\r\nl2_cache_event_update(event);\r\nhwc->state |= PERF_HES_STOPPED | PERF_HES_UPTODATE;\r\n}\r\nstatic int l2_cache_event_add(struct perf_event *event, int flags)\r\n{\r\nstruct hw_perf_event *hwc = &event->hw;\r\nint idx;\r\nint err = 0;\r\nstruct cluster_pmu *cluster;\r\ncluster = get_cluster_pmu(to_l2cache_pmu(event->pmu), event->cpu);\r\nidx = l2_cache_get_event_idx(cluster, event);\r\nif (idx < 0)\r\nreturn idx;\r\nhwc->idx = idx;\r\nhwc->state = PERF_HES_STOPPED | PERF_HES_UPTODATE;\r\ncluster->events[idx] = event;\r\nlocal64_set(&hwc->prev_count, 0);\r\nif (flags & PERF_EF_START)\r\nl2_cache_event_start(event, flags);\r\nperf_event_update_userpage(event);\r\nreturn err;\r\n}\r\nstatic void l2_cache_event_del(struct perf_event *event, int flags)\r\n{\r\nstruct hw_perf_event *hwc = &event->hw;\r\nstruct cluster_pmu *cluster;\r\nint idx = hwc->idx;\r\ncluster = get_cluster_pmu(to_l2cache_pmu(event->pmu), event->cpu);\r\nl2_cache_event_stop(event, flags | PERF_EF_UPDATE);\r\ncluster->events[idx] = NULL;\r\nl2_cache_clear_event_idx(cluster, event);\r\nperf_event_update_userpage(event);\r\n}\r\nstatic void l2_cache_event_read(struct perf_event *event)\r\n{\r\nl2_cache_event_update(event);\r\n}\r\nstatic ssize_t l2_cache_pmu_cpumask_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct l2cache_pmu *l2cache_pmu = to_l2cache_pmu(dev_get_drvdata(dev));\r\nreturn cpumap_print_to_pagebuf(true, buf, &l2cache_pmu->cpumask);\r\n}\r\nstatic int get_num_counters(void)\r\n{\r\nint val;\r\nval = get_l2_indirect_reg(L2PMCR);\r\nreturn ((val >> L2PMCR_NUM_EV_SHIFT) & L2PMCR_NUM_EV_MASK) + 1;\r\n}\r\nstatic struct cluster_pmu *l2_cache_associate_cpu_with_cluster(\r\nstruct l2cache_pmu *l2cache_pmu, int cpu)\r\n{\r\nu64 mpidr;\r\nint cpu_cluster_id;\r\nstruct cluster_pmu *cluster = NULL;\r\nmpidr = read_cpuid_mpidr();\r\nif (mpidr & MPIDR_MT_BITMASK)\r\ncpu_cluster_id = MPIDR_AFFINITY_LEVEL(mpidr, 2);\r\nelse\r\ncpu_cluster_id = MPIDR_AFFINITY_LEVEL(mpidr, 1);\r\nlist_for_each_entry(cluster, &l2cache_pmu->clusters, next) {\r\nif (cluster->cluster_id != cpu_cluster_id)\r\ncontinue;\r\ndev_info(&l2cache_pmu->pdev->dev,\r\n"CPU%d associated with cluster %d\n", cpu,\r\ncluster->cluster_id);\r\ncpumask_set_cpu(cpu, &cluster->cluster_cpus);\r\n*per_cpu_ptr(l2cache_pmu->pmu_cluster, cpu) = cluster;\r\nbreak;\r\n}\r\nreturn cluster;\r\n}\r\nstatic int l2cache_pmu_online_cpu(unsigned int cpu, struct hlist_node *node)\r\n{\r\nstruct cluster_pmu *cluster;\r\nstruct l2cache_pmu *l2cache_pmu;\r\nl2cache_pmu = hlist_entry_safe(node, struct l2cache_pmu, node);\r\ncluster = get_cluster_pmu(l2cache_pmu, cpu);\r\nif (!cluster) {\r\ncluster = l2_cache_associate_cpu_with_cluster(l2cache_pmu, cpu);\r\nif (!cluster) {\r\nWARN_ONCE(1, "No L2 cache cluster for CPU%d\n", cpu);\r\nreturn 0;\r\n}\r\n}\r\nif (cluster->on_cpu != -1)\r\nreturn 0;\r\ncluster->on_cpu = cpu;\r\ncpumask_set_cpu(cpu, &l2cache_pmu->cpumask);\r\ncluster_pmu_reset();\r\nWARN_ON(irq_set_affinity(cluster->irq, cpumask_of(cpu)));\r\nenable_irq(cluster->irq);\r\nreturn 0;\r\n}\r\nstatic int l2cache_pmu_offline_cpu(unsigned int cpu, struct hlist_node *node)\r\n{\r\nstruct cluster_pmu *cluster;\r\nstruct l2cache_pmu *l2cache_pmu;\r\ncpumask_t cluster_online_cpus;\r\nunsigned int target;\r\nl2cache_pmu = hlist_entry_safe(node, struct l2cache_pmu, node);\r\ncluster = get_cluster_pmu(l2cache_pmu, cpu);\r\nif (!cluster)\r\nreturn 0;\r\nif (cluster->on_cpu != cpu)\r\nreturn 0;\r\ncpumask_clear_cpu(cpu, &l2cache_pmu->cpumask);\r\ncluster->on_cpu = -1;\r\ncpumask_and(&cluster_online_cpus, &cluster->cluster_cpus,\r\ncpu_online_mask);\r\ntarget = cpumask_any_but(&cluster_online_cpus, cpu);\r\nif (target >= nr_cpu_ids) {\r\ndisable_irq(cluster->irq);\r\nreturn 0;\r\n}\r\nperf_pmu_migrate_context(&l2cache_pmu->pmu, cpu, target);\r\ncluster->on_cpu = target;\r\ncpumask_set_cpu(target, &l2cache_pmu->cpumask);\r\nWARN_ON(irq_set_affinity(cluster->irq, cpumask_of(target)));\r\nreturn 0;\r\n}\r\nstatic int l2_cache_pmu_probe_cluster(struct device *dev, void *data)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev->parent);\r\nstruct platform_device *sdev = to_platform_device(dev);\r\nstruct l2cache_pmu *l2cache_pmu = data;\r\nstruct cluster_pmu *cluster;\r\nstruct acpi_device *device;\r\nunsigned long fw_cluster_id;\r\nint err;\r\nint irq;\r\nif (acpi_bus_get_device(ACPI_HANDLE(dev), &device))\r\nreturn -ENODEV;\r\nif (kstrtoul(device->pnp.unique_id, 10, &fw_cluster_id) < 0) {\r\ndev_err(&pdev->dev, "unable to read ACPI uid\n");\r\nreturn -ENODEV;\r\n}\r\ncluster = devm_kzalloc(&pdev->dev, sizeof(*cluster), GFP_KERNEL);\r\nif (!cluster)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&cluster->next);\r\nlist_add(&cluster->next, &l2cache_pmu->clusters);\r\ncluster->cluster_id = fw_cluster_id;\r\nirq = platform_get_irq(sdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev,\r\n"Failed to get valid irq for cluster %ld\n",\r\nfw_cluster_id);\r\nreturn irq;\r\n}\r\nirq_set_status_flags(irq, IRQ_NOAUTOEN);\r\ncluster->irq = irq;\r\ncluster->l2cache_pmu = l2cache_pmu;\r\ncluster->on_cpu = -1;\r\nerr = devm_request_irq(&pdev->dev, irq, l2_cache_handle_irq,\r\nIRQF_NOBALANCING | IRQF_NO_THREAD,\r\n"l2-cache-pmu", cluster);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"Unable to request IRQ%d for L2 PMU counters\n", irq);\r\nreturn err;\r\n}\r\ndev_info(&pdev->dev,\r\n"Registered L2 cache PMU cluster %ld\n", fw_cluster_id);\r\nspin_lock_init(&cluster->pmu_lock);\r\nl2cache_pmu->num_pmus++;\r\nreturn 0;\r\n}\r\nstatic int l2_cache_pmu_probe(struct platform_device *pdev)\r\n{\r\nint err;\r\nstruct l2cache_pmu *l2cache_pmu;\r\nl2cache_pmu =\r\ndevm_kzalloc(&pdev->dev, sizeof(*l2cache_pmu), GFP_KERNEL);\r\nif (!l2cache_pmu)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&l2cache_pmu->clusters);\r\nplatform_set_drvdata(pdev, l2cache_pmu);\r\nl2cache_pmu->pmu = (struct pmu) {\r\n.name = "l2cache_0",\r\n.task_ctx_nr = perf_invalid_context,\r\n.pmu_enable = l2_cache_pmu_enable,\r\n.pmu_disable = l2_cache_pmu_disable,\r\n.event_init = l2_cache_event_init,\r\n.add = l2_cache_event_add,\r\n.del = l2_cache_event_del,\r\n.start = l2_cache_event_start,\r\n.stop = l2_cache_event_stop,\r\n.read = l2_cache_event_read,\r\n.attr_groups = l2_cache_pmu_attr_grps,\r\n};\r\nl2cache_pmu->num_counters = get_num_counters();\r\nl2cache_pmu->pdev = pdev;\r\nl2cache_pmu->pmu_cluster = devm_alloc_percpu(&pdev->dev,\r\nstruct cluster_pmu *);\r\nif (!l2cache_pmu->pmu_cluster)\r\nreturn -ENOMEM;\r\nl2_cycle_ctr_idx = l2cache_pmu->num_counters - 1;\r\nl2_counter_present_mask = GENMASK(l2cache_pmu->num_counters - 2, 0) |\r\nBIT(L2CYCLE_CTR_BIT);\r\ncpumask_clear(&l2cache_pmu->cpumask);\r\nerr = device_for_each_child(&pdev->dev, l2cache_pmu,\r\nl2_cache_pmu_probe_cluster);\r\nif (err)\r\nreturn err;\r\nif (l2cache_pmu->num_pmus == 0) {\r\ndev_err(&pdev->dev, "No hardware L2 cache PMUs found\n");\r\nreturn -ENODEV;\r\n}\r\nerr = cpuhp_state_add_instance(CPUHP_AP_PERF_ARM_QCOM_L2_ONLINE,\r\n&l2cache_pmu->node);\r\nif (err) {\r\ndev_err(&pdev->dev, "Error %d registering hotplug", err);\r\nreturn err;\r\n}\r\nerr = perf_pmu_register(&l2cache_pmu->pmu, l2cache_pmu->pmu.name, -1);\r\nif (err) {\r\ndev_err(&pdev->dev, "Error %d registering L2 cache PMU\n", err);\r\ngoto out_unregister;\r\n}\r\ndev_info(&pdev->dev, "Registered L2 cache PMU using %d HW PMUs\n",\r\nl2cache_pmu->num_pmus);\r\nreturn err;\r\nout_unregister:\r\ncpuhp_state_remove_instance(CPUHP_AP_PERF_ARM_QCOM_L2_ONLINE,\r\n&l2cache_pmu->node);\r\nreturn err;\r\n}\r\nstatic int l2_cache_pmu_remove(struct platform_device *pdev)\r\n{\r\nstruct l2cache_pmu *l2cache_pmu =\r\nto_l2cache_pmu(platform_get_drvdata(pdev));\r\nperf_pmu_unregister(&l2cache_pmu->pmu);\r\ncpuhp_state_remove_instance(CPUHP_AP_PERF_ARM_QCOM_L2_ONLINE,\r\n&l2cache_pmu->node);\r\nreturn 0;\r\n}\r\nstatic int __init register_l2_cache_pmu_driver(void)\r\n{\r\nint err;\r\nerr = cpuhp_setup_state_multi(CPUHP_AP_PERF_ARM_QCOM_L2_ONLINE,\r\n"AP_PERF_ARM_QCOM_L2_ONLINE",\r\nl2cache_pmu_online_cpu,\r\nl2cache_pmu_offline_cpu);\r\nif (err)\r\nreturn err;\r\nreturn platform_driver_register(&l2_cache_pmu_driver);\r\n}
