static int tps65218_pmic_set_voltage_sel(struct regulator_dev *dev,\r\nunsigned selector)\r\n{\r\nint ret;\r\nstruct tps65218 *tps = rdev_get_drvdata(dev);\r\nunsigned int rid = rdev_get_id(dev);\r\nret = tps65218_set_bits(tps, dev->desc->vsel_reg, dev->desc->vsel_mask,\r\nselector, TPS65218_PROTECT_L1);\r\nswitch (rid) {\r\ncase TPS65218_DCDC_1:\r\ncase TPS65218_DCDC_2:\r\nret = tps65218_set_bits(tps, TPS65218_REG_CONTRL_SLEW_RATE,\r\nTPS65218_SLEW_RATE_GO,\r\nTPS65218_SLEW_RATE_GO,\r\nTPS65218_PROTECT_L1);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int tps65218_pmic_enable(struct regulator_dev *dev)\r\n{\r\nstruct tps65218 *tps = rdev_get_drvdata(dev);\r\nint rid = rdev_get_id(dev);\r\nif (rid < TPS65218_DCDC_1 || rid > TPS65218_LDO_1)\r\nreturn -EINVAL;\r\nreturn tps65218_set_bits(tps, dev->desc->enable_reg,\r\ndev->desc->enable_mask, dev->desc->enable_mask,\r\nTPS65218_PROTECT_L1);\r\n}\r\nstatic int tps65218_pmic_disable(struct regulator_dev *dev)\r\n{\r\nstruct tps65218 *tps = rdev_get_drvdata(dev);\r\nint rid = rdev_get_id(dev);\r\nif (rid < TPS65218_DCDC_1 || rid > TPS65218_LDO_1)\r\nreturn -EINVAL;\r\nreturn tps65218_clear_bits(tps, dev->desc->enable_reg,\r\ndev->desc->enable_mask, TPS65218_PROTECT_L1);\r\n}\r\nstatic int tps65218_pmic_set_suspend_enable(struct regulator_dev *dev)\r\n{\r\nstruct tps65218 *tps = rdev_get_drvdata(dev);\r\nunsigned int rid = rdev_get_id(dev);\r\nif (rid < TPS65218_DCDC_1 || rid > TPS65218_LDO_1)\r\nreturn -EINVAL;\r\nreturn tps65218_clear_bits(tps, dev->desc->bypass_reg,\r\ndev->desc->bypass_mask,\r\nTPS65218_PROTECT_L1);\r\n}\r\nstatic int tps65218_pmic_set_suspend_disable(struct regulator_dev *dev)\r\n{\r\nstruct tps65218 *tps = rdev_get_drvdata(dev);\r\nunsigned int rid = rdev_get_id(dev);\r\nif (rid < TPS65218_DCDC_1 || rid > TPS65218_LDO_1)\r\nreturn -EINVAL;\r\nif (rid == TPS65218_DCDC_3 && tps->rev == TPS65218_REV_2_1)\r\nreturn 0;\r\nif (!tps->strobes[rid]) {\r\nif (rid == TPS65218_DCDC_3)\r\ntps->info[rid]->strobe = 3;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nreturn tps65218_set_bits(tps, dev->desc->bypass_reg,\r\ndev->desc->bypass_mask,\r\ntps->strobes[rid], TPS65218_PROTECT_L1);\r\n}\r\nstatic int tps65218_pmic_set_input_current_lim(struct regulator_dev *dev,\r\nint lim_uA)\r\n{\r\nunsigned int index = 0;\r\nunsigned int num_currents = ARRAY_SIZE(ls3_currents);\r\nstruct tps65218 *tps = rdev_get_drvdata(dev);\r\nwhile (index < num_currents && ls3_currents[index] != lim_uA)\r\nindex++;\r\nif (index == num_currents)\r\nreturn -EINVAL;\r\nreturn tps65218_set_bits(tps, dev->desc->csel_reg, dev->desc->csel_mask,\r\nindex << 2, TPS65218_PROTECT_L1);\r\n}\r\nstatic int tps65218_pmic_set_current_limit(struct regulator_dev *dev,\r\nint min_uA, int max_uA)\r\n{\r\nint index = 0;\r\nunsigned int num_currents = ARRAY_SIZE(ls3_currents);\r\nstruct tps65218 *tps = rdev_get_drvdata(dev);\r\nwhile (index < num_currents && ls3_currents[index] < max_uA)\r\nindex++;\r\nindex--;\r\nif (index < 0 || ls3_currents[index] < min_uA)\r\nreturn -EINVAL;\r\nreturn tps65218_set_bits(tps, dev->desc->csel_reg, dev->desc->csel_mask,\r\nindex << 2, TPS65218_PROTECT_L1);\r\n}\r\nstatic int tps65218_pmic_get_current_limit(struct regulator_dev *dev)\r\n{\r\nint retval;\r\nunsigned int index;\r\nstruct tps65218 *tps = rdev_get_drvdata(dev);\r\nretval = regmap_read(tps->regmap, dev->desc->csel_reg, &index);\r\nif (retval < 0)\r\nreturn retval;\r\nindex = (index & dev->desc->csel_mask) >> 2;\r\nreturn ls3_currents[index];\r\n}\r\nstatic int tps65218_regulator_probe(struct platform_device *pdev)\r\n{\r\nstruct tps65218 *tps = dev_get_drvdata(pdev->dev.parent);\r\nstruct regulator_dev *rdev;\r\nstruct regulator_config config = { };\r\nint i, ret;\r\nunsigned int val;\r\nconfig.dev = &pdev->dev;\r\nconfig.dev->of_node = tps->dev->of_node;\r\nconfig.driver_data = tps;\r\nconfig.regmap = tps->regmap;\r\ntps->strobes = devm_kzalloc(&pdev->dev, sizeof(u8) *\r\nTPS65218_NUM_REGULATOR, GFP_KERNEL);\r\nfor (i = 0; i < ARRAY_SIZE(regulators); i++) {\r\nrdev = devm_regulator_register(&pdev->dev, &regulators[i],\r\n&config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(tps->dev, "failed to register %s regulator\n",\r\npdev->name);\r\nreturn PTR_ERR(rdev);\r\n}\r\nret = regmap_read(tps->regmap, regulators[i].bypass_reg, &val);\r\nif (ret)\r\nreturn ret;\r\ntps->strobes[i] = val & regulators[i].bypass_mask;\r\n}\r\nreturn 0;\r\n}
