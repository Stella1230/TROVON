static void quirk_limit_mrrs(struct pci_dev *dev)\r\n{\r\nstruct pci_bus *bus = dev->bus;\r\nstruct pci_dev *bridge = bus->self;\r\nstatic const struct pci_device_id rc_pci_devids[] = {\r\n{ PCI_DEVICE(PCI_VENDOR_ID_TI, PCIE_RC_K2HK),\r\n.class = PCI_CLASS_BRIDGE_PCI << 8, .class_mask = ~0, },\r\n{ PCI_DEVICE(PCI_VENDOR_ID_TI, PCIE_RC_K2E),\r\n.class = PCI_CLASS_BRIDGE_PCI << 8, .class_mask = ~0, },\r\n{ PCI_DEVICE(PCI_VENDOR_ID_TI, PCIE_RC_K2L),\r\n.class = PCI_CLASS_BRIDGE_PCI << 8, .class_mask = ~0, },\r\n{ 0, },\r\n};\r\nif (pci_is_root_bus(bus))\r\nreturn;\r\nwhile (!pci_is_root_bus(bus)) {\r\nbridge = bus->self;\r\nbus = bus->parent;\r\n}\r\nif (bridge) {\r\nif (pci_match_id(rc_pci_devids, bridge)) {\r\nif (pcie_get_readrq(dev) > 256) {\r\ndev_info(&dev->dev, "limiting MRRS to 256\n");\r\npcie_set_readrq(dev, 256);\r\n}\r\n}\r\n}\r\n}\r\nstatic int ks_pcie_establish_link(struct keystone_pcie *ks_pcie)\r\n{\r\nstruct dw_pcie *pci = ks_pcie->pci;\r\nstruct pcie_port *pp = &pci->pp;\r\nstruct device *dev = pci->dev;\r\nunsigned int retries;\r\ndw_pcie_setup_rc(pp);\r\nif (dw_pcie_link_up(pci)) {\r\ndev_err(dev, "Link already up\n");\r\nreturn 0;\r\n}\r\nfor (retries = 0; retries < 5; retries++) {\r\nks_dw_pcie_initiate_link_train(ks_pcie);\r\nif (!dw_pcie_wait_for_link(pci))\r\nreturn 0;\r\n}\r\ndev_err(dev, "phy link never came up\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void ks_pcie_msi_irq_handler(struct irq_desc *desc)\r\n{\r\nunsigned int irq = irq_desc_get_irq(desc);\r\nstruct keystone_pcie *ks_pcie = irq_desc_get_handler_data(desc);\r\nu32 offset = irq - ks_pcie->msi_host_irqs[0];\r\nstruct dw_pcie *pci = ks_pcie->pci;\r\nstruct device *dev = pci->dev;\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\ndev_dbg(dev, "%s, irq %d\n", __func__, irq);\r\nchained_irq_enter(chip, desc);\r\nks_dw_pcie_handle_msi_irq(ks_pcie, offset);\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic void ks_pcie_legacy_irq_handler(struct irq_desc *desc)\r\n{\r\nunsigned int irq = irq_desc_get_irq(desc);\r\nstruct keystone_pcie *ks_pcie = irq_desc_get_handler_data(desc);\r\nstruct dw_pcie *pci = ks_pcie->pci;\r\nstruct device *dev = pci->dev;\r\nu32 irq_offset = irq - ks_pcie->legacy_host_irqs[0];\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\ndev_dbg(dev, ": Handling legacy irq %d\n", irq);\r\nchained_irq_enter(chip, desc);\r\nks_dw_pcie_handle_legacy_irq(ks_pcie, irq_offset);\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int ks_pcie_get_irq_controller_info(struct keystone_pcie *ks_pcie,\r\nchar *controller, int *num_irqs)\r\n{\r\nint temp, max_host_irqs, legacy = 1, *host_irqs;\r\nstruct device *dev = ks_pcie->pci->dev;\r\nstruct device_node *np_pcie = dev->of_node, **np_temp;\r\nif (!strcmp(controller, "msi-interrupt-controller"))\r\nlegacy = 0;\r\nif (legacy) {\r\nnp_temp = &ks_pcie->legacy_intc_np;\r\nmax_host_irqs = MAX_LEGACY_HOST_IRQS;\r\nhost_irqs = &ks_pcie->legacy_host_irqs[0];\r\n} else {\r\nnp_temp = &ks_pcie->msi_intc_np;\r\nmax_host_irqs = MAX_MSI_HOST_IRQS;\r\nhost_irqs = &ks_pcie->msi_host_irqs[0];\r\n}\r\n*np_temp = of_find_node_by_name(np_pcie, controller);\r\nif (!(*np_temp)) {\r\ndev_err(dev, "Node for %s is absent\n", controller);\r\nreturn -EINVAL;\r\n}\r\ntemp = of_irq_count(*np_temp);\r\nif (!temp) {\r\ndev_err(dev, "No IRQ entries in %s\n", controller);\r\nreturn -EINVAL;\r\n}\r\nif (temp > max_host_irqs)\r\ndev_warn(dev, "Too many %s interrupts defined %u\n",\r\n(legacy ? "legacy" : "MSI"), temp);\r\nfor (temp = 0; temp < max_host_irqs; temp++) {\r\nhost_irqs[temp] = irq_of_parse_and_map(*np_temp, temp);\r\nif (!host_irqs[temp])\r\nbreak;\r\n}\r\nif (temp) {\r\n*num_irqs = temp;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void ks_pcie_setup_interrupts(struct keystone_pcie *ks_pcie)\r\n{\r\nint i;\r\nfor (i = 0; i < ks_pcie->num_legacy_host_irqs; i++) {\r\nirq_set_chained_handler_and_data(ks_pcie->legacy_host_irqs[i],\r\nks_pcie_legacy_irq_handler,\r\nks_pcie);\r\n}\r\nks_dw_pcie_enable_legacy_irqs(ks_pcie);\r\nif (IS_ENABLED(CONFIG_PCI_MSI)) {\r\nfor (i = 0; i < ks_pcie->num_msi_host_irqs; i++) {\r\nirq_set_chained_handler_and_data(ks_pcie->msi_host_irqs[i],\r\nks_pcie_msi_irq_handler,\r\nks_pcie);\r\n}\r\n}\r\nif (ks_pcie->error_irq > 0)\r\nks_dw_pcie_enable_error_irq(ks_pcie);\r\n}\r\nstatic int keystone_pcie_fault(unsigned long addr, unsigned int fsr,\r\nstruct pt_regs *regs)\r\n{\r\nunsigned long instr = *(unsigned long *) instruction_pointer(regs);\r\nif ((instr & 0x0e100090) == 0x00100090) {\r\nint reg = (instr >> 12) & 15;\r\nregs->uregs[reg] = -1;\r\nregs->ARM_pc += 4;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __init ks_pcie_host_init(struct pcie_port *pp)\r\n{\r\nstruct dw_pcie *pci = to_dw_pcie_from_pp(pp);\r\nstruct keystone_pcie *ks_pcie = to_keystone_pcie(pci);\r\nu32 val;\r\nks_pcie_establish_link(ks_pcie);\r\nks_dw_pcie_setup_rc_app_regs(ks_pcie);\r\nks_pcie_setup_interrupts(ks_pcie);\r\nwritew(PCI_IO_RANGE_TYPE_32 | (PCI_IO_RANGE_TYPE_32 << 8),\r\npci->dbi_base + PCI_IO_BASE);\r\nwritew(ks_pcie->device_id, pci->dbi_base + PCI_DEVICE_ID);\r\nval = readl(pci->dbi_base + PCIE_CAP_BASE + PCI_EXP_DEVCTL);\r\nval &= ~PCI_EXP_DEVCTL_READRQ;\r\nval |= BIT(12);\r\nwritel(val, pci->dbi_base + PCIE_CAP_BASE + PCI_EXP_DEVCTL);\r\nhook_fault_code(17, keystone_pcie_fault, SIGBUS, 0,\r\n"Asynchronous external abort");\r\n}\r\nstatic irqreturn_t pcie_err_irq_handler(int irq, void *priv)\r\n{\r\nstruct keystone_pcie *ks_pcie = priv;\r\nreturn ks_dw_pcie_handle_error_irq(ks_pcie);\r\n}\r\nstatic int __init ks_add_pcie_port(struct keystone_pcie *ks_pcie,\r\nstruct platform_device *pdev)\r\n{\r\nstruct dw_pcie *pci = ks_pcie->pci;\r\nstruct pcie_port *pp = &pci->pp;\r\nstruct device *dev = &pdev->dev;\r\nint ret;\r\nret = ks_pcie_get_irq_controller_info(ks_pcie,\r\n"legacy-interrupt-controller",\r\n&ks_pcie->num_legacy_host_irqs);\r\nif (ret)\r\nreturn ret;\r\nif (IS_ENABLED(CONFIG_PCI_MSI)) {\r\nret = ks_pcie_get_irq_controller_info(ks_pcie,\r\n"msi-interrupt-controller",\r\n&ks_pcie->num_msi_host_irqs);\r\nif (ret)\r\nreturn ret;\r\n}\r\nks_pcie->error_irq = irq_of_parse_and_map(ks_pcie->np, 0);\r\nif (ks_pcie->error_irq <= 0)\r\ndev_info(dev, "no error IRQ defined\n");\r\nelse {\r\nret = request_irq(ks_pcie->error_irq, pcie_err_irq_handler,\r\nIRQF_SHARED, "pcie-error-irq", ks_pcie);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to request error IRQ %d\n",\r\nks_pcie->error_irq);\r\nreturn ret;\r\n}\r\n}\r\npp->root_bus_nr = -1;\r\npp->ops = &keystone_pcie_host_ops;\r\nret = ks_dw_pcie_host_init(ks_pcie, ks_pcie->msi_intc_np);\r\nif (ret) {\r\ndev_err(dev, "failed to initialize host\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __exit ks_pcie_remove(struct platform_device *pdev)\r\n{\r\nstruct keystone_pcie *ks_pcie = platform_get_drvdata(pdev);\r\nclk_disable_unprepare(ks_pcie->clk);\r\nreturn 0;\r\n}\r\nstatic int __init ks_pcie_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct dw_pcie *pci;\r\nstruct keystone_pcie *ks_pcie;\r\nstruct resource *res;\r\nvoid __iomem *reg_p;\r\nstruct phy *phy;\r\nint ret;\r\nks_pcie = devm_kzalloc(dev, sizeof(*ks_pcie), GFP_KERNEL);\r\nif (!ks_pcie)\r\nreturn -ENOMEM;\r\npci = devm_kzalloc(dev, sizeof(*pci), GFP_KERNEL);\r\nif (!pci)\r\nreturn -ENOMEM;\r\npci->dev = dev;\r\npci->ops = &dw_pcie_ops;\r\nks_pcie->pci = pci;\r\nphy = devm_phy_get(dev, "pcie-phy");\r\nif (PTR_ERR_OR_ZERO(phy) == -EPROBE_DEFER)\r\nreturn PTR_ERR(phy);\r\nif (!IS_ERR_OR_NULL(phy)) {\r\nret = phy_init(phy);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 2);\r\nreg_p = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(reg_p))\r\nreturn PTR_ERR(reg_p);\r\nks_pcie->device_id = readl(reg_p) >> 16;\r\ndevm_iounmap(dev, reg_p);\r\ndevm_release_mem_region(dev, res->start, resource_size(res));\r\nks_pcie->np = dev->of_node;\r\nplatform_set_drvdata(pdev, ks_pcie);\r\nks_pcie->clk = devm_clk_get(dev, "pcie");\r\nif (IS_ERR(ks_pcie->clk)) {\r\ndev_err(dev, "Failed to get pcie rc clock\n");\r\nreturn PTR_ERR(ks_pcie->clk);\r\n}\r\nret = clk_prepare_enable(ks_pcie->clk);\r\nif (ret)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, ks_pcie);\r\nret = ks_add_pcie_port(ks_pcie, pdev);\r\nif (ret < 0)\r\ngoto fail_clk;\r\nreturn 0;\r\nfail_clk:\r\nclk_disable_unprepare(ks_pcie->clk);\r\nreturn ret;\r\n}
