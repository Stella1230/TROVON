static void pcsp_call_pcm_elapsed(unsigned long priv)\r\n{\r\nif (atomic_read(&pcsp_chip.timer_active)) {\r\nstruct snd_pcm_substream *substream;\r\nsubstream = pcsp_chip.playback_substream;\r\nif (substream)\r\nsnd_pcm_period_elapsed(substream);\r\n}\r\n}\r\nstatic u64 pcsp_timer_update(struct snd_pcsp *chip)\r\n{\r\nunsigned char timer_cnt, val;\r\nu64 ns;\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_pcm_runtime *runtime;\r\nunsigned long flags;\r\nif (chip->thalf) {\r\noutb(chip->val61, 0x61);\r\nchip->thalf = 0;\r\nreturn chip->ns_rem;\r\n}\r\nsubstream = chip->playback_substream;\r\nif (!substream)\r\nreturn 0;\r\nruntime = substream->runtime;\r\nval = runtime->dma_area[chip->playback_ptr + chip->fmt_size - 1];\r\nif (chip->is_signed)\r\nval ^= 0x80;\r\ntimer_cnt = val * CUR_DIV() / 256;\r\nif (timer_cnt && chip->enable) {\r\nraw_spin_lock_irqsave(&i8253_lock, flags);\r\nif (!nforce_wa) {\r\noutb_p(chip->val61, 0x61);\r\noutb_p(timer_cnt, 0x42);\r\noutb(chip->val61 ^ 1, 0x61);\r\n} else {\r\noutb(chip->val61 ^ 2, 0x61);\r\nchip->thalf = 1;\r\n}\r\nraw_spin_unlock_irqrestore(&i8253_lock, flags);\r\n}\r\nchip->ns_rem = PCSP_PERIOD_NS();\r\nns = (chip->thalf ? PCSP_CALC_NS(timer_cnt) : chip->ns_rem);\r\nchip->ns_rem -= ns;\r\nreturn ns;\r\n}\r\nstatic void pcsp_pointer_update(struct snd_pcsp *chip)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nsize_t period_bytes, buffer_bytes;\r\nint periods_elapsed;\r\nunsigned long flags;\r\nsubstream = chip->playback_substream;\r\nif (!substream)\r\nreturn;\r\nperiod_bytes = snd_pcm_lib_period_bytes(substream);\r\nbuffer_bytes = snd_pcm_lib_buffer_bytes(substream);\r\nspin_lock_irqsave(&chip->substream_lock, flags);\r\nchip->playback_ptr += PCSP_INDEX_INC() * chip->fmt_size;\r\nperiods_elapsed = chip->playback_ptr - chip->period_ptr;\r\nif (periods_elapsed < 0) {\r\n#if PCSP_DEBUG\r\nprintk(KERN_INFO "PCSP: buffer_bytes mod period_bytes != 0 ? "\r\n"(%zi %zi %zi)\n",\r\nchip->playback_ptr, period_bytes, buffer_bytes);\r\n#endif\r\nperiods_elapsed += buffer_bytes;\r\n}\r\nperiods_elapsed /= period_bytes;\r\nchip->playback_ptr %= buffer_bytes;\r\nif (periods_elapsed) {\r\nchip->period_ptr += periods_elapsed * period_bytes;\r\nchip->period_ptr %= buffer_bytes;\r\n}\r\nspin_unlock_irqrestore(&chip->substream_lock, flags);\r\nif (periods_elapsed)\r\ntasklet_schedule(&pcsp_pcm_tasklet);\r\n}\r\nenum hrtimer_restart pcsp_do_timer(struct hrtimer *handle)\r\n{\r\nstruct snd_pcsp *chip = container_of(handle, struct snd_pcsp, timer);\r\nint pointer_update;\r\nu64 ns;\r\nif (!atomic_read(&chip->timer_active) || !chip->playback_substream)\r\nreturn HRTIMER_NORESTART;\r\npointer_update = !chip->thalf;\r\nns = pcsp_timer_update(chip);\r\nif (!ns) {\r\nprintk(KERN_WARNING "PCSP: unexpected stop\n");\r\nreturn HRTIMER_NORESTART;\r\n}\r\nif (pointer_update)\r\npcsp_pointer_update(chip);\r\nhrtimer_forward(handle, hrtimer_get_expires(handle), ns_to_ktime(ns));\r\nreturn HRTIMER_RESTART;\r\n}\r\nstatic int pcsp_start_playing(struct snd_pcsp *chip)\r\n{\r\n#if PCSP_DEBUG\r\nprintk(KERN_INFO "PCSP: start_playing called\n");\r\n#endif\r\nif (atomic_read(&chip->timer_active)) {\r\nprintk(KERN_ERR "PCSP: Timer already active\n");\r\nreturn -EIO;\r\n}\r\nraw_spin_lock(&i8253_lock);\r\nchip->val61 = inb(0x61) | 0x03;\r\noutb_p(0x92, 0x43);\r\nraw_spin_unlock(&i8253_lock);\r\natomic_set(&chip->timer_active, 1);\r\nchip->thalf = 0;\r\nhrtimer_start(&pcsp_chip.timer, 0, HRTIMER_MODE_REL);\r\nreturn 0;\r\n}\r\nstatic void pcsp_stop_playing(struct snd_pcsp *chip)\r\n{\r\n#if PCSP_DEBUG\r\nprintk(KERN_INFO "PCSP: stop_playing called\n");\r\n#endif\r\nif (!atomic_read(&chip->timer_active))\r\nreturn;\r\natomic_set(&chip->timer_active, 0);\r\nraw_spin_lock(&i8253_lock);\r\noutb_p(0xb6, 0x43);\r\noutb(chip->val61 & 0xFC, 0x61);\r\nraw_spin_unlock(&i8253_lock);\r\n}\r\nvoid pcsp_sync_stop(struct snd_pcsp *chip)\r\n{\r\nlocal_irq_disable();\r\npcsp_stop_playing(chip);\r\nlocal_irq_enable();\r\nhrtimer_cancel(&chip->timer);\r\ntasklet_kill(&pcsp_pcm_tasklet);\r\n}\r\nstatic int snd_pcsp_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcsp *chip = snd_pcm_substream_chip(substream);\r\n#if PCSP_DEBUG\r\nprintk(KERN_INFO "PCSP: close called\n");\r\n#endif\r\npcsp_sync_stop(chip);\r\nchip->playback_substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_pcsp_playback_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_pcsp *chip = snd_pcm_substream_chip(substream);\r\nint err;\r\npcsp_sync_stop(chip);\r\nerr = snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int snd_pcsp_playback_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcsp *chip = snd_pcm_substream_chip(substream);\r\n#if PCSP_DEBUG\r\nprintk(KERN_INFO "PCSP: hw_free called\n");\r\n#endif\r\npcsp_sync_stop(chip);\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int snd_pcsp_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcsp *chip = snd_pcm_substream_chip(substream);\r\npcsp_sync_stop(chip);\r\nchip->playback_ptr = 0;\r\nchip->period_ptr = 0;\r\nchip->fmt_size =\r\nsnd_pcm_format_physical_width(substream->runtime->format) >> 3;\r\nchip->is_signed = snd_pcm_format_signed(substream->runtime->format);\r\n#if PCSP_DEBUG\r\nprintk(KERN_INFO "PCSP: prepare called, "\r\n"size=%zi psize=%zi f=%zi f1=%i fsize=%i\n",\r\nsnd_pcm_lib_buffer_bytes(substream),\r\nsnd_pcm_lib_period_bytes(substream),\r\nsnd_pcm_lib_buffer_bytes(substream) /\r\nsnd_pcm_lib_period_bytes(substream),\r\nsubstream->runtime->periods,\r\nchip->fmt_size);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int snd_pcsp_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_pcsp *chip = snd_pcm_substream_chip(substream);\r\n#if PCSP_DEBUG\r\nprintk(KERN_INFO "PCSP: trigger called\n");\r\n#endif\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nreturn pcsp_start_playing(chip);\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\npcsp_stop_playing(chip);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t snd_pcsp_playback_pointer(struct snd_pcm_substream\r\n*substream)\r\n{\r\nstruct snd_pcsp *chip = snd_pcm_substream_chip(substream);\r\nunsigned int pos;\r\nspin_lock(&chip->substream_lock);\r\npos = chip->playback_ptr;\r\nspin_unlock(&chip->substream_lock);\r\nreturn bytes_to_frames(substream->runtime, pos);\r\n}\r\nstatic int snd_pcsp_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcsp *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\n#if PCSP_DEBUG\r\nprintk(KERN_INFO "PCSP: open called\n");\r\n#endif\r\nif (atomic_read(&chip->timer_active)) {\r\nprintk(KERN_ERR "PCSP: still active!!\n");\r\nreturn -EBUSY;\r\n}\r\nruntime->hw = snd_pcsp_playback;\r\nchip->playback_substream = substream;\r\nreturn 0;\r\n}\r\nint snd_pcsp_new_pcm(struct snd_pcsp *chip)\r\n{\r\nint err;\r\nerr = snd_pcm_new(chip->card, "pcspeaker", 0, 1, 0, &chip->pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(chip->pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&snd_pcsp_playback_ops);\r\nchip->pcm->private_data = chip;\r\nchip->pcm->info_flags = SNDRV_PCM_INFO_HALF_DUPLEX;\r\nstrcpy(chip->pcm->name, "pcsp");\r\nsnd_pcm_lib_preallocate_pages_for_all(chip->pcm,\r\nSNDRV_DMA_TYPE_CONTINUOUS,\r\nsnd_dma_continuous_data\r\n(GFP_KERNEL), PCSP_BUFFER_SIZE,\r\nPCSP_BUFFER_SIZE);\r\nreturn 0;\r\n}
