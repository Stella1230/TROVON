static int reg_write(struct gspca_dev *gspca_dev, u16 index, u16 value)\r\n{\r\nint ret;\r\nstruct usb_device *dev = gspca_dev->dev;\r\nret = usb_control_msg(dev,\r\nusb_sndctrlpipe(dev, 0),\r\n0,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, index, NULL, 0, 500);\r\nPDEBUG(D_USBO, "reg write i:0x%04x = 0x%02x",\r\nindex, value);\r\nif (ret < 0)\r\npr_err("reg write: error %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int reg_read(struct gspca_dev *gspca_dev,\r\nu16 index)\r\n{\r\nint ret;\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_rcvctrlpipe(gspca_dev->dev, 0),\r\n0,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0,\r\nindex,\r\ngspca_dev->usb_buf, 1,\r\n500);\r\nPDEBUG(D_USBI, "reg read i:%04x --> %02x",\r\nindex, gspca_dev->usb_buf[0]);\r\nif (ret < 0) {\r\npr_err("reg_read err %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn gspca_dev->usb_buf[0];\r\n}\r\nstatic int ssi_w(struct gspca_dev *gspca_dev,\r\nu16 reg, u16 val)\r\n{\r\nint ret, retry;\r\nret = reg_write(gspca_dev, 0x8802, reg >> 8);\r\nif (ret < 0)\r\ngoto out;\r\nret = reg_write(gspca_dev, 0x8801, reg & 0x00ff);\r\nif (ret < 0)\r\ngoto out;\r\nif ((reg & 0xff00) == 0x1000) {\r\nret = reg_write(gspca_dev, 0x8805, val & 0x00ff);\r\nif (ret < 0)\r\ngoto out;\r\nval >>= 8;\r\n}\r\nret = reg_write(gspca_dev, 0x8800, val);\r\nif (ret < 0)\r\ngoto out;\r\nretry = 10;\r\nfor (;;) {\r\nret = reg_read(gspca_dev, 0x8803);\r\nif (ret < 0)\r\nbreak;\r\nif (gspca_dev->usb_buf[0] == 0)\r\nbreak;\r\nif (--retry <= 0) {\r\nPERR("ssi_w busy %02x", gspca_dev->usb_buf[0]);\r\nret = -1;\r\nbreak;\r\n}\r\nmsleep(8);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct cam *cam;\r\nconst u16 (*init_data)[2];\r\nstatic const u16 (*(init_data_tb[]))[2] = {\r\nspca508_vista_init_data,\r\nspca508_sightcam_init_data,\r\nspca508_sightcam2_init_data,\r\nspca508cs110_init_data,\r\nspca508cs110_init_data,\r\nspca508_init_data,\r\n};\r\nint data1, data2;\r\ndata1 = reg_read(gspca_dev, 0x8104);\r\ndata2 = reg_read(gspca_dev, 0x8105);\r\nPDEBUG(D_PROBE, "Webcam Vendor ID: 0x%02x%02x", data2, data1);\r\ndata1 = reg_read(gspca_dev, 0x8106);\r\ndata2 = reg_read(gspca_dev, 0x8107);\r\nPDEBUG(D_PROBE, "Webcam Product ID: 0x%02x%02x", data2, data1);\r\ndata1 = reg_read(gspca_dev, 0x8621);\r\nPDEBUG(D_PROBE, "Window 1 average luminance: %d", data1);\r\ncam = &gspca_dev->cam;\r\ncam->cam_mode = sif_mode;\r\ncam->nmodes = ARRAY_SIZE(sif_mode);\r\nsd->subtype = id->driver_info;\r\ninit_data = init_data_tb[sd->subtype];\r\nreturn write_vector(gspca_dev, init_data);\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nint mode;\r\nmode = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv;\r\nreg_write(gspca_dev, 0x8500, mode);\r\nswitch (mode) {\r\ncase 0:\r\ncase 1:\r\nreg_write(gspca_dev, 0x8700, 0x28);\r\nbreak;\r\ndefault:\r\nreg_write(gspca_dev, 0x8700, 0x23);\r\nbreak;\r\n}\r\nreg_write(gspca_dev, 0x8112, 0x10 | 0x20);\r\nreturn 0;\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nreg_write(gspca_dev, 0x8112, 0x20);\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nswitch (data[0]) {\r\ncase 0:\r\ngspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\r\ndata += SPCA508_OFFSET_DATA;\r\nlen -= SPCA508_OFFSET_DATA;\r\ngspca_frame_add(gspca_dev, FIRST_PACKET, data, len);\r\nbreak;\r\ncase 0xff:\r\nbreak;\r\ndefault:\r\ndata += 1;\r\nlen -= 1;\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, len);\r\nbreak;\r\n}\r\n}\r\nstatic void setbrightness(struct gspca_dev *gspca_dev, s32 brightness)\r\n{\r\nreg_write(gspca_dev, 0x8651, brightness);\r\nreg_write(gspca_dev, 0x8652, brightness);\r\nreg_write(gspca_dev, 0x8653, brightness);\r\nreg_write(gspca_dev, 0x8654, brightness);\r\n}\r\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct gspca_dev *gspca_dev =\r\ncontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\r\ngspca_dev->usb_err = 0;\r\nif (!gspca_dev->streaming)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nsetbrightness(gspca_dev, ctrl->val);\r\nbreak;\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\r\n{\r\nstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\r\ngspca_dev->vdev.ctrl_handler = hdl;\r\nv4l2_ctrl_handler_init(hdl, 5);\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 255, 1, 128);\r\nif (hdl->error) {\r\npr_err("Could not initialize controls\n");\r\nreturn hdl->error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}
