static const struct fsl_soc_die_attr *fsl_soc_die_match(\r\nu32 svr, const struct fsl_soc_die_attr *matches)\r\n{\r\nwhile (matches->svr) {\r\nif (matches->svr == (svr & matches->mask))\r\nreturn matches;\r\nmatches++;\r\n};\r\nreturn NULL;\r\n}\r\nu32 fsl_guts_get_svr(void)\r\n{\r\nu32 svr = 0;\r\nif (!guts || !guts->regs)\r\nreturn svr;\r\nif (guts->little_endian)\r\nsvr = ioread32(&guts->regs->svr);\r\nelse\r\nsvr = ioread32be(&guts->regs->svr);\r\nreturn svr;\r\n}\r\nstatic int fsl_guts_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *root, *np = pdev->dev.of_node;\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nconst struct fsl_soc_die_attr *soc_die;\r\nconst char *machine;\r\nu32 svr;\r\nguts = devm_kzalloc(dev, sizeof(*guts), GFP_KERNEL);\r\nif (!guts)\r\nreturn -ENOMEM;\r\nguts->little_endian = of_property_read_bool(np, "little-endian");\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nguts->regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(guts->regs))\r\nreturn PTR_ERR(guts->regs);\r\nroot = of_find_node_by_path("/");\r\nif (of_property_read_string(root, "model", &machine))\r\nof_property_read_string_index(root, "compatible", 0, &machine);\r\nof_node_put(root);\r\nif (machine)\r\nsoc_dev_attr.machine = devm_kstrdup(dev, machine, GFP_KERNEL);\r\nsvr = fsl_guts_get_svr();\r\nsoc_die = fsl_soc_die_match(svr, fsl_soc_die);\r\nif (soc_die) {\r\nsoc_dev_attr.family = devm_kasprintf(dev, GFP_KERNEL,\r\n"QorIQ %s", soc_die->die);\r\n} else {\r\nsoc_dev_attr.family = devm_kasprintf(dev, GFP_KERNEL, "QorIQ");\r\n}\r\nsoc_dev_attr.soc_id = devm_kasprintf(dev, GFP_KERNEL,\r\n"svr:0x%08x", svr);\r\nsoc_dev_attr.revision = devm_kasprintf(dev, GFP_KERNEL, "%d.%d",\r\n(svr >> 4) & 0xf, svr & 0xf);\r\nsoc_dev = soc_device_register(&soc_dev_attr);\r\nif (IS_ERR(soc_dev))\r\nreturn PTR_ERR(soc_dev);\r\npr_info("Machine: %s\n", soc_dev_attr.machine);\r\npr_info("SoC family: %s\n", soc_dev_attr.family);\r\npr_info("SoC ID: %s, Revision: %s\n",\r\nsoc_dev_attr.soc_id, soc_dev_attr.revision);\r\nreturn 0;\r\n}\r\nstatic int fsl_guts_remove(struct platform_device *dev)\r\n{\r\nsoc_device_unregister(soc_dev);\r\nreturn 0;\r\n}\r\nstatic int __init fsl_guts_init(void)\r\n{\r\nreturn platform_driver_register(&fsl_guts_driver);\r\n}\r\nstatic void __exit fsl_guts_exit(void)\r\n{\r\nplatform_driver_unregister(&fsl_guts_driver);\r\n}
