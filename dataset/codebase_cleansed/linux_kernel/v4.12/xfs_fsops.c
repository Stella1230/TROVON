int\r\nxfs_fs_geometry(\r\nxfs_mount_t *mp,\r\nxfs_fsop_geom_t *geo,\r\nint new_version)\r\n{\r\nmemset(geo, 0, sizeof(*geo));\r\ngeo->blocksize = mp->m_sb.sb_blocksize;\r\ngeo->rtextsize = mp->m_sb.sb_rextsize;\r\ngeo->agblocks = mp->m_sb.sb_agblocks;\r\ngeo->agcount = mp->m_sb.sb_agcount;\r\ngeo->logblocks = mp->m_sb.sb_logblocks;\r\ngeo->sectsize = mp->m_sb.sb_sectsize;\r\ngeo->inodesize = mp->m_sb.sb_inodesize;\r\ngeo->imaxpct = mp->m_sb.sb_imax_pct;\r\ngeo->datablocks = mp->m_sb.sb_dblocks;\r\ngeo->rtblocks = mp->m_sb.sb_rblocks;\r\ngeo->rtextents = mp->m_sb.sb_rextents;\r\ngeo->logstart = mp->m_sb.sb_logstart;\r\nASSERT(sizeof(geo->uuid)==sizeof(mp->m_sb.sb_uuid));\r\nmemcpy(geo->uuid, &mp->m_sb.sb_uuid, sizeof(mp->m_sb.sb_uuid));\r\nif (new_version >= 2) {\r\ngeo->sunit = mp->m_sb.sb_unit;\r\ngeo->swidth = mp->m_sb.sb_width;\r\n}\r\nif (new_version >= 3) {\r\ngeo->version = XFS_FSOP_GEOM_VERSION;\r\ngeo->flags = XFS_FSOP_GEOM_FLAGS_NLINK |\r\nXFS_FSOP_GEOM_FLAGS_DIRV2 |\r\n(xfs_sb_version_hasattr(&mp->m_sb) ?\r\nXFS_FSOP_GEOM_FLAGS_ATTR : 0) |\r\n(xfs_sb_version_hasquota(&mp->m_sb) ?\r\nXFS_FSOP_GEOM_FLAGS_QUOTA : 0) |\r\n(xfs_sb_version_hasalign(&mp->m_sb) ?\r\nXFS_FSOP_GEOM_FLAGS_IALIGN : 0) |\r\n(xfs_sb_version_hasdalign(&mp->m_sb) ?\r\nXFS_FSOP_GEOM_FLAGS_DALIGN : 0) |\r\n(xfs_sb_version_hasextflgbit(&mp->m_sb) ?\r\nXFS_FSOP_GEOM_FLAGS_EXTFLG : 0) |\r\n(xfs_sb_version_hassector(&mp->m_sb) ?\r\nXFS_FSOP_GEOM_FLAGS_SECTOR : 0) |\r\n(xfs_sb_version_hasasciici(&mp->m_sb) ?\r\nXFS_FSOP_GEOM_FLAGS_DIRV2CI : 0) |\r\n(xfs_sb_version_haslazysbcount(&mp->m_sb) ?\r\nXFS_FSOP_GEOM_FLAGS_LAZYSB : 0) |\r\n(xfs_sb_version_hasattr2(&mp->m_sb) ?\r\nXFS_FSOP_GEOM_FLAGS_ATTR2 : 0) |\r\n(xfs_sb_version_hasprojid32bit(&mp->m_sb) ?\r\nXFS_FSOP_GEOM_FLAGS_PROJID32 : 0) |\r\n(xfs_sb_version_hascrc(&mp->m_sb) ?\r\nXFS_FSOP_GEOM_FLAGS_V5SB : 0) |\r\n(xfs_sb_version_hasftype(&mp->m_sb) ?\r\nXFS_FSOP_GEOM_FLAGS_FTYPE : 0) |\r\n(xfs_sb_version_hasfinobt(&mp->m_sb) ?\r\nXFS_FSOP_GEOM_FLAGS_FINOBT : 0) |\r\n(xfs_sb_version_hassparseinodes(&mp->m_sb) ?\r\nXFS_FSOP_GEOM_FLAGS_SPINODES : 0) |\r\n(xfs_sb_version_hasrmapbt(&mp->m_sb) ?\r\nXFS_FSOP_GEOM_FLAGS_RMAPBT : 0) |\r\n(xfs_sb_version_hasreflink(&mp->m_sb) ?\r\nXFS_FSOP_GEOM_FLAGS_REFLINK : 0);\r\ngeo->logsectsize = xfs_sb_version_hassector(&mp->m_sb) ?\r\nmp->m_sb.sb_logsectsize : BBSIZE;\r\ngeo->rtsectsize = mp->m_sb.sb_blocksize;\r\ngeo->dirblocksize = mp->m_dir_geo->blksize;\r\n}\r\nif (new_version >= 4) {\r\ngeo->flags |=\r\n(xfs_sb_version_haslogv2(&mp->m_sb) ?\r\nXFS_FSOP_GEOM_FLAGS_LOGV2 : 0);\r\ngeo->logsunit = mp->m_sb.sb_logsunit;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct xfs_buf *\r\nxfs_growfs_get_hdr_buf(\r\nstruct xfs_mount *mp,\r\nxfs_daddr_t blkno,\r\nsize_t numblks,\r\nint flags,\r\nconst struct xfs_buf_ops *ops)\r\n{\r\nstruct xfs_buf *bp;\r\nbp = xfs_buf_get_uncached(mp->m_ddev_targp, numblks, flags);\r\nif (!bp)\r\nreturn NULL;\r\nxfs_buf_zero(bp, 0, BBTOB(bp->b_length));\r\nbp->b_bn = blkno;\r\nbp->b_maps[0].bm_bn = blkno;\r\nbp->b_ops = ops;\r\nreturn bp;\r\n}\r\nstatic int\r\nxfs_growfs_data_private(\r\nxfs_mount_t *mp,\r\nxfs_growfs_data_t *in)\r\n{\r\nxfs_agf_t *agf;\r\nstruct xfs_agfl *agfl;\r\nxfs_agi_t *agi;\r\nxfs_agnumber_t agno;\r\nxfs_extlen_t agsize;\r\nxfs_extlen_t tmpsize;\r\nxfs_alloc_rec_t *arec;\r\nxfs_buf_t *bp;\r\nint bucket;\r\nint dpct;\r\nint error, saved_error = 0;\r\nxfs_agnumber_t nagcount;\r\nxfs_agnumber_t nagimax = 0;\r\nxfs_rfsblock_t nb, nb_mod;\r\nxfs_rfsblock_t new;\r\nxfs_rfsblock_t nfree;\r\nxfs_agnumber_t oagcount;\r\nint pct;\r\nxfs_trans_t *tp;\r\nnb = in->newblocks;\r\npct = in->imaxpct;\r\nif (nb < mp->m_sb.sb_dblocks || pct < 0 || pct > 100)\r\nreturn -EINVAL;\r\nif ((error = xfs_sb_validate_fsb_count(&mp->m_sb, nb)))\r\nreturn error;\r\ndpct = pct - mp->m_sb.sb_imax_pct;\r\nerror = xfs_buf_read_uncached(mp->m_ddev_targp,\r\nXFS_FSB_TO_BB(mp, nb) - XFS_FSS_TO_BB(mp, 1),\r\nXFS_FSS_TO_BB(mp, 1), 0, &bp, NULL);\r\nif (error)\r\nreturn error;\r\nxfs_buf_relse(bp);\r\nnew = nb;\r\nnb_mod = do_div(new, mp->m_sb.sb_agblocks);\r\nnagcount = new + (nb_mod != 0);\r\nif (nb_mod && nb_mod < XFS_MIN_AG_BLOCKS) {\r\nnagcount--;\r\nnb = (xfs_rfsblock_t)nagcount * mp->m_sb.sb_agblocks;\r\nif (nb < mp->m_sb.sb_dblocks)\r\nreturn -EINVAL;\r\n}\r\nnew = nb - mp->m_sb.sb_dblocks;\r\noagcount = mp->m_sb.sb_agcount;\r\nif (nagcount > oagcount) {\r\nerror = xfs_initialize_perag(mp, nagcount, &nagimax);\r\nif (error)\r\nreturn error;\r\n}\r\nerror = xfs_trans_alloc(mp, &M_RES(mp)->tr_growdata,\r\nXFS_GROWFS_SPACE_RES(mp), 0, XFS_TRANS_RESERVE, &tp);\r\nif (error)\r\nreturn error;\r\nnfree = 0;\r\nfor (agno = nagcount - 1; agno >= oagcount; agno--, new -= agsize) {\r\n__be32 *agfl_bno;\r\nbp = xfs_growfs_get_hdr_buf(mp,\r\nXFS_AG_DADDR(mp, agno, XFS_AGF_DADDR(mp)),\r\nXFS_FSS_TO_BB(mp, 1), 0,\r\n&xfs_agf_buf_ops);\r\nif (!bp) {\r\nerror = -ENOMEM;\r\ngoto error0;\r\n}\r\nagf = XFS_BUF_TO_AGF(bp);\r\nagf->agf_magicnum = cpu_to_be32(XFS_AGF_MAGIC);\r\nagf->agf_versionnum = cpu_to_be32(XFS_AGF_VERSION);\r\nagf->agf_seqno = cpu_to_be32(agno);\r\nif (agno == nagcount - 1)\r\nagsize =\r\nnb -\r\n(agno * (xfs_rfsblock_t)mp->m_sb.sb_agblocks);\r\nelse\r\nagsize = mp->m_sb.sb_agblocks;\r\nagf->agf_length = cpu_to_be32(agsize);\r\nagf->agf_roots[XFS_BTNUM_BNOi] = cpu_to_be32(XFS_BNO_BLOCK(mp));\r\nagf->agf_roots[XFS_BTNUM_CNTi] = cpu_to_be32(XFS_CNT_BLOCK(mp));\r\nagf->agf_levels[XFS_BTNUM_BNOi] = cpu_to_be32(1);\r\nagf->agf_levels[XFS_BTNUM_CNTi] = cpu_to_be32(1);\r\nif (xfs_sb_version_hasrmapbt(&mp->m_sb)) {\r\nagf->agf_roots[XFS_BTNUM_RMAPi] =\r\ncpu_to_be32(XFS_RMAP_BLOCK(mp));\r\nagf->agf_levels[XFS_BTNUM_RMAPi] = cpu_to_be32(1);\r\nagf->agf_rmap_blocks = cpu_to_be32(1);\r\n}\r\nagf->agf_flfirst = cpu_to_be32(1);\r\nagf->agf_fllast = 0;\r\nagf->agf_flcount = 0;\r\ntmpsize = agsize - mp->m_ag_prealloc_blocks;\r\nagf->agf_freeblks = cpu_to_be32(tmpsize);\r\nagf->agf_longest = cpu_to_be32(tmpsize);\r\nif (xfs_sb_version_hascrc(&mp->m_sb))\r\nuuid_copy(&agf->agf_uuid, &mp->m_sb.sb_meta_uuid);\r\nif (xfs_sb_version_hasreflink(&mp->m_sb)) {\r\nagf->agf_refcount_root = cpu_to_be32(\r\nxfs_refc_block(mp));\r\nagf->agf_refcount_level = cpu_to_be32(1);\r\nagf->agf_refcount_blocks = cpu_to_be32(1);\r\n}\r\nerror = xfs_bwrite(bp);\r\nxfs_buf_relse(bp);\r\nif (error)\r\ngoto error0;\r\nbp = xfs_growfs_get_hdr_buf(mp,\r\nXFS_AG_DADDR(mp, agno, XFS_AGFL_DADDR(mp)),\r\nXFS_FSS_TO_BB(mp, 1), 0,\r\n&xfs_agfl_buf_ops);\r\nif (!bp) {\r\nerror = -ENOMEM;\r\ngoto error0;\r\n}\r\nagfl = XFS_BUF_TO_AGFL(bp);\r\nif (xfs_sb_version_hascrc(&mp->m_sb)) {\r\nagfl->agfl_magicnum = cpu_to_be32(XFS_AGFL_MAGIC);\r\nagfl->agfl_seqno = cpu_to_be32(agno);\r\nuuid_copy(&agfl->agfl_uuid, &mp->m_sb.sb_meta_uuid);\r\n}\r\nagfl_bno = XFS_BUF_TO_AGFL_BNO(mp, bp);\r\nfor (bucket = 0; bucket < XFS_AGFL_SIZE(mp); bucket++)\r\nagfl_bno[bucket] = cpu_to_be32(NULLAGBLOCK);\r\nerror = xfs_bwrite(bp);\r\nxfs_buf_relse(bp);\r\nif (error)\r\ngoto error0;\r\nbp = xfs_growfs_get_hdr_buf(mp,\r\nXFS_AG_DADDR(mp, agno, XFS_AGI_DADDR(mp)),\r\nXFS_FSS_TO_BB(mp, 1), 0,\r\n&xfs_agi_buf_ops);\r\nif (!bp) {\r\nerror = -ENOMEM;\r\ngoto error0;\r\n}\r\nagi = XFS_BUF_TO_AGI(bp);\r\nagi->agi_magicnum = cpu_to_be32(XFS_AGI_MAGIC);\r\nagi->agi_versionnum = cpu_to_be32(XFS_AGI_VERSION);\r\nagi->agi_seqno = cpu_to_be32(agno);\r\nagi->agi_length = cpu_to_be32(agsize);\r\nagi->agi_count = 0;\r\nagi->agi_root = cpu_to_be32(XFS_IBT_BLOCK(mp));\r\nagi->agi_level = cpu_to_be32(1);\r\nagi->agi_freecount = 0;\r\nagi->agi_newino = cpu_to_be32(NULLAGINO);\r\nagi->agi_dirino = cpu_to_be32(NULLAGINO);\r\nif (xfs_sb_version_hascrc(&mp->m_sb))\r\nuuid_copy(&agi->agi_uuid, &mp->m_sb.sb_meta_uuid);\r\nif (xfs_sb_version_hasfinobt(&mp->m_sb)) {\r\nagi->agi_free_root = cpu_to_be32(XFS_FIBT_BLOCK(mp));\r\nagi->agi_free_level = cpu_to_be32(1);\r\n}\r\nfor (bucket = 0; bucket < XFS_AGI_UNLINKED_BUCKETS; bucket++)\r\nagi->agi_unlinked[bucket] = cpu_to_be32(NULLAGINO);\r\nerror = xfs_bwrite(bp);\r\nxfs_buf_relse(bp);\r\nif (error)\r\ngoto error0;\r\nbp = xfs_growfs_get_hdr_buf(mp,\r\nXFS_AGB_TO_DADDR(mp, agno, XFS_BNO_BLOCK(mp)),\r\nBTOBB(mp->m_sb.sb_blocksize), 0,\r\n&xfs_allocbt_buf_ops);\r\nif (!bp) {\r\nerror = -ENOMEM;\r\ngoto error0;\r\n}\r\nxfs_btree_init_block(mp, bp, XFS_BTNUM_BNO, 0, 1, agno, 0);\r\narec = XFS_ALLOC_REC_ADDR(mp, XFS_BUF_TO_BLOCK(bp), 1);\r\narec->ar_startblock = cpu_to_be32(mp->m_ag_prealloc_blocks);\r\narec->ar_blockcount = cpu_to_be32(\r\nagsize - be32_to_cpu(arec->ar_startblock));\r\nerror = xfs_bwrite(bp);\r\nxfs_buf_relse(bp);\r\nif (error)\r\ngoto error0;\r\nbp = xfs_growfs_get_hdr_buf(mp,\r\nXFS_AGB_TO_DADDR(mp, agno, XFS_CNT_BLOCK(mp)),\r\nBTOBB(mp->m_sb.sb_blocksize), 0,\r\n&xfs_allocbt_buf_ops);\r\nif (!bp) {\r\nerror = -ENOMEM;\r\ngoto error0;\r\n}\r\nxfs_btree_init_block(mp, bp, XFS_BTNUM_CNT, 0, 1, agno, 0);\r\narec = XFS_ALLOC_REC_ADDR(mp, XFS_BUF_TO_BLOCK(bp), 1);\r\narec->ar_startblock = cpu_to_be32(mp->m_ag_prealloc_blocks);\r\narec->ar_blockcount = cpu_to_be32(\r\nagsize - be32_to_cpu(arec->ar_startblock));\r\nnfree += be32_to_cpu(arec->ar_blockcount);\r\nerror = xfs_bwrite(bp);\r\nxfs_buf_relse(bp);\r\nif (error)\r\ngoto error0;\r\nif (xfs_sb_version_hasrmapbt(&mp->m_sb)) {\r\nstruct xfs_rmap_rec *rrec;\r\nstruct xfs_btree_block *block;\r\nbp = xfs_growfs_get_hdr_buf(mp,\r\nXFS_AGB_TO_DADDR(mp, agno, XFS_RMAP_BLOCK(mp)),\r\nBTOBB(mp->m_sb.sb_blocksize), 0,\r\n&xfs_rmapbt_buf_ops);\r\nif (!bp) {\r\nerror = -ENOMEM;\r\ngoto error0;\r\n}\r\nxfs_btree_init_block(mp, bp, XFS_BTNUM_RMAP, 0, 0,\r\nagno, 0);\r\nblock = XFS_BUF_TO_BLOCK(bp);\r\nrrec = XFS_RMAP_REC_ADDR(block, 1);\r\nrrec->rm_startblock = 0;\r\nrrec->rm_blockcount = cpu_to_be32(XFS_BNO_BLOCK(mp));\r\nrrec->rm_owner = cpu_to_be64(XFS_RMAP_OWN_FS);\r\nrrec->rm_offset = 0;\r\nbe16_add_cpu(&block->bb_numrecs, 1);\r\nrrec = XFS_RMAP_REC_ADDR(block, 2);\r\nrrec->rm_startblock = cpu_to_be32(XFS_BNO_BLOCK(mp));\r\nrrec->rm_blockcount = cpu_to_be32(2);\r\nrrec->rm_owner = cpu_to_be64(XFS_RMAP_OWN_AG);\r\nrrec->rm_offset = 0;\r\nbe16_add_cpu(&block->bb_numrecs, 1);\r\nrrec = XFS_RMAP_REC_ADDR(block, 3);\r\nrrec->rm_startblock = cpu_to_be32(XFS_IBT_BLOCK(mp));\r\nrrec->rm_blockcount = cpu_to_be32(XFS_RMAP_BLOCK(mp) -\r\nXFS_IBT_BLOCK(mp));\r\nrrec->rm_owner = cpu_to_be64(XFS_RMAP_OWN_INOBT);\r\nrrec->rm_offset = 0;\r\nbe16_add_cpu(&block->bb_numrecs, 1);\r\nrrec = XFS_RMAP_REC_ADDR(block, 4);\r\nrrec->rm_startblock = cpu_to_be32(XFS_RMAP_BLOCK(mp));\r\nrrec->rm_blockcount = cpu_to_be32(1);\r\nrrec->rm_owner = cpu_to_be64(XFS_RMAP_OWN_AG);\r\nrrec->rm_offset = 0;\r\nbe16_add_cpu(&block->bb_numrecs, 1);\r\nif (xfs_sb_version_hasreflink(&mp->m_sb)) {\r\nrrec = XFS_RMAP_REC_ADDR(block, 5);\r\nrrec->rm_startblock = cpu_to_be32(\r\nxfs_refc_block(mp));\r\nrrec->rm_blockcount = cpu_to_be32(1);\r\nrrec->rm_owner = cpu_to_be64(XFS_RMAP_OWN_REFC);\r\nrrec->rm_offset = 0;\r\nbe16_add_cpu(&block->bb_numrecs, 1);\r\n}\r\nerror = xfs_bwrite(bp);\r\nxfs_buf_relse(bp);\r\nif (error)\r\ngoto error0;\r\n}\r\nbp = xfs_growfs_get_hdr_buf(mp,\r\nXFS_AGB_TO_DADDR(mp, agno, XFS_IBT_BLOCK(mp)),\r\nBTOBB(mp->m_sb.sb_blocksize), 0,\r\n&xfs_inobt_buf_ops);\r\nif (!bp) {\r\nerror = -ENOMEM;\r\ngoto error0;\r\n}\r\nxfs_btree_init_block(mp, bp, XFS_BTNUM_INO , 0, 0, agno, 0);\r\nerror = xfs_bwrite(bp);\r\nxfs_buf_relse(bp);\r\nif (error)\r\ngoto error0;\r\nif (xfs_sb_version_hasfinobt(&mp->m_sb)) {\r\nbp = xfs_growfs_get_hdr_buf(mp,\r\nXFS_AGB_TO_DADDR(mp, agno, XFS_FIBT_BLOCK(mp)),\r\nBTOBB(mp->m_sb.sb_blocksize), 0,\r\n&xfs_inobt_buf_ops);\r\nif (!bp) {\r\nerror = -ENOMEM;\r\ngoto error0;\r\n}\r\nxfs_btree_init_block(mp, bp, XFS_BTNUM_FINO,\r\n0, 0, agno, 0);\r\nerror = xfs_bwrite(bp);\r\nxfs_buf_relse(bp);\r\nif (error)\r\ngoto error0;\r\n}\r\nif (xfs_sb_version_hasreflink(&mp->m_sb)) {\r\nbp = xfs_growfs_get_hdr_buf(mp,\r\nXFS_AGB_TO_DADDR(mp, agno, xfs_refc_block(mp)),\r\nBTOBB(mp->m_sb.sb_blocksize), 0,\r\n&xfs_refcountbt_buf_ops);\r\nif (!bp) {\r\nerror = -ENOMEM;\r\ngoto error0;\r\n}\r\nxfs_btree_init_block(mp, bp, XFS_BTNUM_REFC,\r\n0, 0, agno, 0);\r\nerror = xfs_bwrite(bp);\r\nxfs_buf_relse(bp);\r\nif (error)\r\ngoto error0;\r\n}\r\n}\r\nxfs_trans_agblocks_delta(tp, nfree);\r\nif (new) {\r\nstruct xfs_owner_info oinfo;\r\nerror = xfs_ialloc_read_agi(mp, tp, agno, &bp);\r\nif (error) {\r\ngoto error0;\r\n}\r\nASSERT(bp);\r\nagi = XFS_BUF_TO_AGI(bp);\r\nbe32_add_cpu(&agi->agi_length, new);\r\nASSERT(nagcount == oagcount ||\r\nbe32_to_cpu(agi->agi_length) == mp->m_sb.sb_agblocks);\r\nxfs_ialloc_log_agi(tp, bp, XFS_AGI_LENGTH);\r\nerror = xfs_alloc_read_agf(mp, tp, agno, 0, &bp);\r\nif (error) {\r\ngoto error0;\r\n}\r\nASSERT(bp);\r\nagf = XFS_BUF_TO_AGF(bp);\r\nbe32_add_cpu(&agf->agf_length, new);\r\nASSERT(be32_to_cpu(agf->agf_length) ==\r\nbe32_to_cpu(agi->agi_length));\r\nxfs_alloc_log_agf(tp, bp, XFS_AGF_LENGTH);\r\nxfs_rmap_ag_owner(&oinfo, XFS_RMAP_OWN_NULL);\r\nerror = xfs_free_extent(tp,\r\nXFS_AGB_TO_FSB(mp, agno,\r\nbe32_to_cpu(agf->agf_length) - new),\r\nnew, &oinfo, XFS_AG_RESV_NONE);\r\nif (error)\r\ngoto error0;\r\n}\r\nif (nagcount > oagcount)\r\nxfs_trans_mod_sb(tp, XFS_TRANS_SB_AGCOUNT, nagcount - oagcount);\r\nif (nb > mp->m_sb.sb_dblocks)\r\nxfs_trans_mod_sb(tp, XFS_TRANS_SB_DBLOCKS,\r\nnb - mp->m_sb.sb_dblocks);\r\nif (nfree)\r\nxfs_trans_mod_sb(tp, XFS_TRANS_SB_FDBLOCKS, nfree);\r\nif (dpct)\r\nxfs_trans_mod_sb(tp, XFS_TRANS_SB_IMAXPCT, dpct);\r\nxfs_trans_set_sync(tp);\r\nerror = xfs_trans_commit(tp);\r\nif (error)\r\nreturn error;\r\nif (nagimax)\r\nmp->m_maxagi = nagimax;\r\nif (mp->m_sb.sb_imax_pct) {\r\n__uint64_t icount = mp->m_sb.sb_dblocks * mp->m_sb.sb_imax_pct;\r\ndo_div(icount, 100);\r\nmp->m_maxicount = icount << mp->m_sb.sb_inopblog;\r\n} else\r\nmp->m_maxicount = 0;\r\nxfs_set_low_space_thresholds(mp);\r\nmp->m_alloc_set_aside = xfs_alloc_set_aside(mp);\r\nif (new) {\r\nstruct xfs_perag *pag;\r\npag = xfs_perag_get(mp, agno);\r\nerror = xfs_ag_resv_free(pag);\r\nxfs_perag_put(pag);\r\nif (error)\r\ngoto out;\r\n}\r\nerror = xfs_fs_reserve_ag_blocks(mp);\r\nif (error && error != -ENOSPC)\r\ngoto out;\r\nfor (agno = 1; agno < nagcount; agno++) {\r\nerror = 0;\r\nif (agno < oagcount) {\r\nerror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\r\nXFS_AGB_TO_DADDR(mp, agno, XFS_SB_BLOCK(mp)),\r\nXFS_FSS_TO_BB(mp, 1), 0, &bp,\r\n&xfs_sb_buf_ops);\r\n} else {\r\nbp = xfs_trans_get_buf(NULL, mp->m_ddev_targp,\r\nXFS_AGB_TO_DADDR(mp, agno, XFS_SB_BLOCK(mp)),\r\nXFS_FSS_TO_BB(mp, 1), 0);\r\nif (bp) {\r\nbp->b_ops = &xfs_sb_buf_ops;\r\nxfs_buf_zero(bp, 0, BBTOB(bp->b_length));\r\n} else\r\nerror = -ENOMEM;\r\n}\r\nif (error) {\r\nxfs_warn(mp,\r\n"error %d reading secondary superblock for ag %d",\r\nerror, agno);\r\nsaved_error = error;\r\ncontinue;\r\n}\r\nxfs_sb_to_disk(XFS_BUF_TO_SBP(bp), &mp->m_sb);\r\nerror = xfs_bwrite(bp);\r\nxfs_buf_relse(bp);\r\nif (error) {\r\nxfs_warn(mp,\r\n"write error %d updating secondary superblock for ag %d",\r\nerror, agno);\r\nsaved_error = error;\r\ncontinue;\r\n}\r\n}\r\nout:\r\nreturn saved_error ? saved_error : error;\r\nerror0:\r\nxfs_trans_cancel(tp);\r\nreturn error;\r\n}\r\nstatic int\r\nxfs_growfs_log_private(\r\nxfs_mount_t *mp,\r\nxfs_growfs_log_t *in)\r\n{\r\nxfs_extlen_t nb;\r\nnb = in->newblocks;\r\nif (nb < XFS_MIN_LOG_BLOCKS || nb < XFS_B_TO_FSB(mp, XFS_MIN_LOG_BYTES))\r\nreturn -EINVAL;\r\nif (nb == mp->m_sb.sb_logblocks &&\r\nin->isint == (mp->m_sb.sb_logstart != 0))\r\nreturn -EINVAL;\r\nreturn -ENOSYS;\r\n}\r\nint\r\nxfs_growfs_data(\r\nxfs_mount_t *mp,\r\nxfs_growfs_data_t *in)\r\n{\r\nint error;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (!mutex_trylock(&mp->m_growlock))\r\nreturn -EWOULDBLOCK;\r\nerror = xfs_growfs_data_private(mp, in);\r\nmp->m_generation++;\r\nmutex_unlock(&mp->m_growlock);\r\nreturn error;\r\n}\r\nint\r\nxfs_growfs_log(\r\nxfs_mount_t *mp,\r\nxfs_growfs_log_t *in)\r\n{\r\nint error;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (!mutex_trylock(&mp->m_growlock))\r\nreturn -EWOULDBLOCK;\r\nerror = xfs_growfs_log_private(mp, in);\r\nmutex_unlock(&mp->m_growlock);\r\nreturn error;\r\n}\r\nint\r\nxfs_fs_counts(\r\nxfs_mount_t *mp,\r\nxfs_fsop_counts_t *cnt)\r\n{\r\ncnt->allocino = percpu_counter_read_positive(&mp->m_icount);\r\ncnt->freeino = percpu_counter_read_positive(&mp->m_ifree);\r\ncnt->freedata = percpu_counter_read_positive(&mp->m_fdblocks) -\r\nmp->m_alloc_set_aside;\r\nspin_lock(&mp->m_sb_lock);\r\ncnt->freertx = mp->m_sb.sb_frextents;\r\nspin_unlock(&mp->m_sb_lock);\r\nreturn 0;\r\n}\r\nint\r\nxfs_reserve_blocks(\r\nxfs_mount_t *mp,\r\n__uint64_t *inval,\r\nxfs_fsop_resblks_t *outval)\r\n{\r\n__int64_t lcounter, delta;\r\n__int64_t fdblks_delta = 0;\r\n__uint64_t request;\r\n__int64_t free;\r\nint error = 0;\r\nif (inval == (__uint64_t *)NULL) {\r\nif (!outval)\r\nreturn -EINVAL;\r\noutval->resblks = mp->m_resblks;\r\noutval->resblks_avail = mp->m_resblks_avail;\r\nreturn 0;\r\n}\r\nrequest = *inval;\r\nspin_lock(&mp->m_sb_lock);\r\nif (mp->m_resblks > request) {\r\nlcounter = mp->m_resblks_avail - request;\r\nif (lcounter > 0) {\r\nfdblks_delta = lcounter;\r\nmp->m_resblks_avail -= lcounter;\r\n}\r\nmp->m_resblks = request;\r\nif (fdblks_delta) {\r\nspin_unlock(&mp->m_sb_lock);\r\nerror = xfs_mod_fdblocks(mp, fdblks_delta, 0);\r\nspin_lock(&mp->m_sb_lock);\r\n}\r\ngoto out;\r\n}\r\nerror = -ENOSPC;\r\ndo {\r\nfree = percpu_counter_sum(&mp->m_fdblocks) -\r\nmp->m_alloc_set_aside;\r\nif (!free)\r\nbreak;\r\ndelta = request - mp->m_resblks;\r\nlcounter = free - delta;\r\nif (lcounter < 0)\r\nfdblks_delta = free;\r\nelse\r\nfdblks_delta = delta;\r\nspin_unlock(&mp->m_sb_lock);\r\nerror = xfs_mod_fdblocks(mp, -fdblks_delta, 0);\r\nspin_lock(&mp->m_sb_lock);\r\n} while (error == -ENOSPC);\r\nif (!error && fdblks_delta) {\r\nmp->m_resblks += fdblks_delta;\r\nmp->m_resblks_avail += fdblks_delta;\r\n}\r\nout:\r\nif (outval) {\r\noutval->resblks = mp->m_resblks;\r\noutval->resblks_avail = mp->m_resblks_avail;\r\n}\r\nspin_unlock(&mp->m_sb_lock);\r\nreturn error;\r\n}\r\nint\r\nxfs_fs_goingdown(\r\nxfs_mount_t *mp,\r\n__uint32_t inflags)\r\n{\r\nswitch (inflags) {\r\ncase XFS_FSOP_GOING_FLAGS_DEFAULT: {\r\nstruct super_block *sb = freeze_bdev(mp->m_super->s_bdev);\r\nif (sb && !IS_ERR(sb)) {\r\nxfs_force_shutdown(mp, SHUTDOWN_FORCE_UMOUNT);\r\nthaw_bdev(sb->s_bdev, sb);\r\n}\r\nbreak;\r\n}\r\ncase XFS_FSOP_GOING_FLAGS_LOGFLUSH:\r\nxfs_force_shutdown(mp, SHUTDOWN_FORCE_UMOUNT);\r\nbreak;\r\ncase XFS_FSOP_GOING_FLAGS_NOLOGFLUSH:\r\nxfs_force_shutdown(mp,\r\nSHUTDOWN_FORCE_UMOUNT | SHUTDOWN_LOG_IO_ERROR);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nxfs_do_force_shutdown(\r\nxfs_mount_t *mp,\r\nint flags,\r\nchar *fname,\r\nint lnnum)\r\n{\r\nint logerror;\r\nlogerror = flags & SHUTDOWN_LOG_IO_ERROR;\r\nif (!(flags & SHUTDOWN_FORCE_UMOUNT)) {\r\nxfs_notice(mp,\r\n"%s(0x%x) called from line %d of file %s. Return address = 0x%p",\r\n__func__, flags, lnnum, fname, __return_address);\r\n}\r\nif (XFS_FORCED_SHUTDOWN(mp) && !logerror)\r\nreturn;\r\nif (xfs_log_force_umount(mp, logerror))\r\nreturn;\r\nif (flags & SHUTDOWN_CORRUPT_INCORE) {\r\nxfs_alert_tag(mp, XFS_PTAG_SHUTDOWN_CORRUPT,\r\n"Corruption of in-memory data detected. Shutting down filesystem");\r\nif (XFS_ERRLEVEL_HIGH <= xfs_error_level)\r\nxfs_stack_trace();\r\n} else if (!(flags & SHUTDOWN_FORCE_UMOUNT)) {\r\nif (logerror) {\r\nxfs_alert_tag(mp, XFS_PTAG_SHUTDOWN_LOGERROR,\r\n"Log I/O Error Detected. Shutting down filesystem");\r\n} else if (flags & SHUTDOWN_DEVICE_REQ) {\r\nxfs_alert_tag(mp, XFS_PTAG_SHUTDOWN_IOERROR,\r\n"All device paths lost. Shutting down filesystem");\r\n} else if (!(flags & SHUTDOWN_REMOTE_REQ)) {\r\nxfs_alert_tag(mp, XFS_PTAG_SHUTDOWN_IOERROR,\r\n"I/O Error Detected. Shutting down filesystem");\r\n}\r\n}\r\nif (!(flags & SHUTDOWN_FORCE_UMOUNT)) {\r\nxfs_alert(mp,\r\n"Please umount the filesystem and rectify the problem(s)");\r\n}\r\n}\r\nint\r\nxfs_fs_reserve_ag_blocks(\r\nstruct xfs_mount *mp)\r\n{\r\nxfs_agnumber_t agno;\r\nstruct xfs_perag *pag;\r\nint error = 0;\r\nint err2;\r\nfor (agno = 0; agno < mp->m_sb.sb_agcount; agno++) {\r\npag = xfs_perag_get(mp, agno);\r\nerr2 = xfs_ag_resv_init(pag);\r\nxfs_perag_put(pag);\r\nif (err2 && !error)\r\nerror = err2;\r\n}\r\nif (error && error != -ENOSPC) {\r\nxfs_warn(mp,\r\n"Error %d reserving per-AG metadata reserve pool.", error);\r\nxfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\r\n}\r\nreturn error;\r\n}\r\nint\r\nxfs_fs_unreserve_ag_blocks(\r\nstruct xfs_mount *mp)\r\n{\r\nxfs_agnumber_t agno;\r\nstruct xfs_perag *pag;\r\nint error = 0;\r\nint err2;\r\nfor (agno = 0; agno < mp->m_sb.sb_agcount; agno++) {\r\npag = xfs_perag_get(mp, agno);\r\nerr2 = xfs_ag_resv_free(pag);\r\nxfs_perag_put(pag);\r\nif (err2 && !error)\r\nerror = err2;\r\n}\r\nif (error)\r\nxfs_warn(mp,\r\n"Error %d freeing per-AG metadata reserve pool.", error);\r\nreturn error;\r\n}
