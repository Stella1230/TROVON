static int pnx4008_wdt_start(struct watchdog_device *wdd)\r\n{\r\nspin_lock(&io_lock);\r\nwritel(RESET_COUNT, WDTIM_CTRL(wdt_base));\r\nwhile (readl(WDTIM_COUNTER(wdt_base)))\r\ncpu_relax();\r\nwritel(M_RES2 | STOP_COUNT0 | RESET_COUNT0, WDTIM_MCTRL(wdt_base));\r\nwritel(MATCH_OUTPUT_HIGH, WDTIM_EMR(wdt_base));\r\nwritel(MATCH_INT, WDTIM_INT(wdt_base));\r\nwritel(0xFFFF, WDTIM_PULSE(wdt_base));\r\nwritel(wdd->timeout * WDOG_COUNTER_RATE, WDTIM_MATCH0(wdt_base));\r\nwritel(COUNT_ENAB | DEBUG_EN, WDTIM_CTRL(wdt_base));\r\nspin_unlock(&io_lock);\r\nreturn 0;\r\n}\r\nstatic int pnx4008_wdt_stop(struct watchdog_device *wdd)\r\n{\r\nspin_lock(&io_lock);\r\nwritel(0, WDTIM_CTRL(wdt_base));\r\nspin_unlock(&io_lock);\r\nreturn 0;\r\n}\r\nstatic int pnx4008_wdt_set_timeout(struct watchdog_device *wdd,\r\nunsigned int new_timeout)\r\n{\r\nwdd->timeout = new_timeout;\r\nreturn 0;\r\n}\r\nstatic int pnx4008_restart_handler(struct watchdog_device *wdd,\r\nunsigned long mode, void *cmd)\r\n{\r\nconst char *boot_cmd = cmd;\r\nif (boot_cmd) {\r\nif (boot_cmd[0] == 'h')\r\nmode = REBOOT_HARD;\r\nelse if (boot_cmd[0] == 's')\r\nmode = REBOOT_SOFT;\r\n}\r\nif (mode == REBOOT_SOFT) {\r\nwritel(EXT_MATCH0, WDTIM_EMR(wdt_base));\r\nwritel(M_RES1, WDTIM_MCTRL(wdt_base));\r\n} else {\r\nwritel(13000, WDTIM_PULSE(wdt_base));\r\nwritel(M_RES2 | RESFRC1 | RESFRC2, WDTIM_MCTRL(wdt_base));\r\n}\r\nmdelay(1000);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int pnx4008_wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *r;\r\nint ret = 0;\r\nwatchdog_init_timeout(&pnx4008_wdd, heartbeat, &pdev->dev);\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nwdt_base = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(wdt_base))\r\nreturn PTR_ERR(wdt_base);\r\nwdt_clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(wdt_clk))\r\nreturn PTR_ERR(wdt_clk);\r\nret = clk_prepare_enable(wdt_clk);\r\nif (ret)\r\nreturn ret;\r\npnx4008_wdd.bootstatus = (readl(WDTIM_RES(wdt_base)) & WDOG_RESET) ?\r\nWDIOF_CARDRESET : 0;\r\npnx4008_wdd.parent = &pdev->dev;\r\nwatchdog_set_nowayout(&pnx4008_wdd, nowayout);\r\nwatchdog_set_restart_priority(&pnx4008_wdd, 128);\r\npnx4008_wdt_stop(&pnx4008_wdd);\r\nret = watchdog_register_device(&pnx4008_wdd);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "cannot register watchdog device\n");\r\ngoto disable_clk;\r\n}\r\ndev_info(&pdev->dev, "heartbeat %d sec\n", pnx4008_wdd.timeout);\r\nreturn 0;\r\ndisable_clk:\r\nclk_disable_unprepare(wdt_clk);\r\nreturn ret;\r\n}\r\nstatic int pnx4008_wdt_remove(struct platform_device *pdev)\r\n{\r\nwatchdog_unregister_device(&pnx4008_wdd);\r\nclk_disable_unprepare(wdt_clk);\r\nreturn 0;\r\n}
