static void mpc85xx_pci_check(struct edac_pci_ctl_info *pci)\r\n{\r\nstruct mpc85xx_pci_pdata *pdata = pci->pvt_info;\r\nu32 err_detect;\r\nerr_detect = in_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_DR);\r\nif (!(err_detect & ~(PCI_EDE_MULTI_ERR | PCI_EDE_MST_ABRT))) {\r\nout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_DR, err_detect);\r\nreturn;\r\n}\r\npr_err("PCI error(s) detected\n");\r\npr_err("PCI/X ERR_DR register: %#08x\n", err_detect);\r\npr_err("PCI/X ERR_ATTRIB register: %#08x\n",\r\nin_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_ATTRIB));\r\npr_err("PCI/X ERR_ADDR register: %#08x\n",\r\nin_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_ADDR));\r\npr_err("PCI/X ERR_EXT_ADDR register: %#08x\n",\r\nin_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_EXT_ADDR));\r\npr_err("PCI/X ERR_DL register: %#08x\n",\r\nin_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_DL));\r\npr_err("PCI/X ERR_DH register: %#08x\n",\r\nin_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_DH));\r\nout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_DR, err_detect);\r\nif (err_detect & PCI_EDE_PERR_MASK)\r\nedac_pci_handle_pe(pci, pci->ctl_name);\r\nif ((err_detect & ~PCI_EDE_MULTI_ERR) & ~PCI_EDE_PERR_MASK)\r\nedac_pci_handle_npe(pci, pci->ctl_name);\r\n}\r\nstatic void mpc85xx_pcie_check(struct edac_pci_ctl_info *pci)\r\n{\r\nstruct mpc85xx_pci_pdata *pdata = pci->pvt_info;\r\nu32 err_detect, err_cap_stat;\r\nerr_detect = in_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_DR);\r\nerr_cap_stat = in_be32(pdata->pci_vbase + MPC85XX_PCI_GAS_TIMR);\r\npr_err("PCIe error(s) detected\n");\r\npr_err("PCIe ERR_DR register: 0x%08x\n", err_detect);\r\npr_err("PCIe ERR_CAP_STAT register: 0x%08x\n", err_cap_stat);\r\npr_err("PCIe ERR_CAP_R0 register: 0x%08x\n",\r\nin_be32(pdata->pci_vbase + MPC85XX_PCIE_ERR_CAP_R0));\r\npr_err("PCIe ERR_CAP_R1 register: 0x%08x\n",\r\nin_be32(pdata->pci_vbase + MPC85XX_PCIE_ERR_CAP_R1));\r\npr_err("PCIe ERR_CAP_R2 register: 0x%08x\n",\r\nin_be32(pdata->pci_vbase + MPC85XX_PCIE_ERR_CAP_R2));\r\npr_err("PCIe ERR_CAP_R3 register: 0x%08x\n",\r\nin_be32(pdata->pci_vbase + MPC85XX_PCIE_ERR_CAP_R3));\r\nout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_DR, err_detect);\r\nout_be32(pdata->pci_vbase + MPC85XX_PCI_GAS_TIMR, err_cap_stat | 0x1);\r\n}\r\nstatic int mpc85xx_pcie_find_capability(struct device_node *np)\r\n{\r\nstruct pci_controller *hose;\r\nif (!np)\r\nreturn -EINVAL;\r\nhose = pci_find_hose_for_OF_device(np);\r\nreturn early_find_capability(hose, 0, 0, PCI_CAP_ID_EXP);\r\n}\r\nstatic irqreturn_t mpc85xx_pci_isr(int irq, void *dev_id)\r\n{\r\nstruct edac_pci_ctl_info *pci = dev_id;\r\nstruct mpc85xx_pci_pdata *pdata = pci->pvt_info;\r\nu32 err_detect;\r\nerr_detect = in_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_DR);\r\nif (!err_detect)\r\nreturn IRQ_NONE;\r\nif (pdata->is_pcie)\r\nmpc85xx_pcie_check(pci);\r\nelse\r\nmpc85xx_pci_check(pci);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mpc85xx_pci_err_probe(struct platform_device *op)\r\n{\r\nstruct edac_pci_ctl_info *pci;\r\nstruct mpc85xx_pci_pdata *pdata;\r\nstruct mpc85xx_edac_pci_plat_data *plat_data;\r\nstruct device_node *of_node;\r\nstruct resource r;\r\nint res = 0;\r\nif (!devres_open_group(&op->dev, mpc85xx_pci_err_probe, GFP_KERNEL))\r\nreturn -ENOMEM;\r\npci = edac_pci_alloc_ctl_info(sizeof(*pdata), "mpc85xx_pci_err");\r\nif (!pci)\r\nreturn -ENOMEM;\r\nswitch (edac_op_state) {\r\ncase EDAC_OPSTATE_POLL:\r\ncase EDAC_OPSTATE_INT:\r\nbreak;\r\ndefault:\r\nedac_op_state = EDAC_OPSTATE_INT;\r\nbreak;\r\n}\r\npdata = pci->pvt_info;\r\npdata->name = "mpc85xx_pci_err";\r\nplat_data = op->dev.platform_data;\r\nif (!plat_data) {\r\ndev_err(&op->dev, "no platform data");\r\nres = -ENXIO;\r\ngoto err;\r\n}\r\nof_node = plat_data->of_node;\r\nif (mpc85xx_pcie_find_capability(of_node) > 0)\r\npdata->is_pcie = true;\r\ndev_set_drvdata(&op->dev, pci);\r\npci->dev = &op->dev;\r\npci->mod_name = EDAC_MOD_STR;\r\npci->ctl_name = pdata->name;\r\npci->dev_name = dev_name(&op->dev);\r\nif (edac_op_state == EDAC_OPSTATE_POLL) {\r\nif (pdata->is_pcie)\r\npci->edac_check = mpc85xx_pcie_check;\r\nelse\r\npci->edac_check = mpc85xx_pci_check;\r\n}\r\npdata->edac_idx = edac_pci_idx++;\r\nres = of_address_to_resource(of_node, 0, &r);\r\nif (res) {\r\npr_err("%s: Unable to get resource for PCI err regs\n", __func__);\r\ngoto err;\r\n}\r\nr.start += 0xe00;\r\nif (!devm_request_mem_region(&op->dev, r.start, resource_size(&r),\r\npdata->name)) {\r\npr_err("%s: Error while requesting mem region\n", __func__);\r\nres = -EBUSY;\r\ngoto err;\r\n}\r\npdata->pci_vbase = devm_ioremap(&op->dev, r.start, resource_size(&r));\r\nif (!pdata->pci_vbase) {\r\npr_err("%s: Unable to setup PCI err regs\n", __func__);\r\nres = -ENOMEM;\r\ngoto err;\r\n}\r\nif (pdata->is_pcie) {\r\norig_pci_err_cap_dr =\r\nin_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_ADDR);\r\nout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_ADDR, ~0);\r\norig_pci_err_en =\r\nin_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_EN);\r\nout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_EN, 0);\r\n} else {\r\norig_pci_err_cap_dr =\r\nin_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_CAP_DR);\r\nout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_CAP_DR, 0x40);\r\norig_pci_err_en =\r\nin_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_EN);\r\nout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_EN, ~0x40);\r\n}\r\nout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_DR, ~0);\r\nout_be32(pdata->pci_vbase + MPC85XX_PCI_GAS_TIMR, 0x1);\r\nif (edac_pci_add_device(pci, pdata->edac_idx) > 0) {\r\nedac_dbg(3, "failed edac_pci_add_device()\n");\r\ngoto err;\r\n}\r\nif (edac_op_state == EDAC_OPSTATE_INT) {\r\npdata->irq = irq_of_parse_and_map(of_node, 0);\r\nres = devm_request_irq(&op->dev, pdata->irq,\r\nmpc85xx_pci_isr,\r\nIRQF_SHARED,\r\n"[EDAC] PCI err", pci);\r\nif (res < 0) {\r\npr_err("%s: Unable to request irq %d for MPC85xx PCI err\n",\r\n__func__, pdata->irq);\r\nirq_dispose_mapping(pdata->irq);\r\nres = -ENODEV;\r\ngoto err2;\r\n}\r\npr_info(EDAC_MOD_STR " acquired irq %d for PCI Err\n",\r\npdata->irq);\r\n}\r\nif (pdata->is_pcie) {\r\nout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_EN, ~0\r\n& ~PEX_ERR_ICCAIE_EN_BIT);\r\nout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_ADDR, 0\r\n| PEX_ERR_ICCAD_DISR_BIT);\r\n}\r\ndevres_remove_group(&op->dev, mpc85xx_pci_err_probe);\r\nedac_dbg(3, "success\n");\r\npr_info(EDAC_MOD_STR " PCI err registered\n");\r\nreturn 0;\r\nerr2:\r\nedac_pci_del_device(&op->dev);\r\nerr:\r\nedac_pci_free_ctl_info(pci);\r\ndevres_release_group(&op->dev, mpc85xx_pci_err_probe);\r\nreturn res;\r\n}\r\nstatic int mpc85xx_pci_err_remove(struct platform_device *op)\r\n{\r\nstruct edac_pci_ctl_info *pci = dev_get_drvdata(&op->dev);\r\nstruct mpc85xx_pci_pdata *pdata = pci->pvt_info;\r\nedac_dbg(0, "\n");\r\nout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_ADDR, orig_pci_err_cap_dr);\r\nout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_EN, orig_pci_err_en);\r\nedac_pci_del_device(&op->dev);\r\nedac_pci_free_ctl_info(pci);\r\nreturn 0;\r\n}\r\nstatic ssize_t mpc85xx_l2_inject_data_hi_show(struct edac_device_ctl_info\r\n*edac_dev, char *data)\r\n{\r\nstruct mpc85xx_l2_pdata *pdata = edac_dev->pvt_info;\r\nreturn sprintf(data, "0x%08x",\r\nin_be32(pdata->l2_vbase + MPC85XX_L2_ERRINJHI));\r\n}\r\nstatic ssize_t mpc85xx_l2_inject_data_lo_show(struct edac_device_ctl_info\r\n*edac_dev, char *data)\r\n{\r\nstruct mpc85xx_l2_pdata *pdata = edac_dev->pvt_info;\r\nreturn sprintf(data, "0x%08x",\r\nin_be32(pdata->l2_vbase + MPC85XX_L2_ERRINJLO));\r\n}\r\nstatic ssize_t mpc85xx_l2_inject_ctrl_show(struct edac_device_ctl_info\r\n*edac_dev, char *data)\r\n{\r\nstruct mpc85xx_l2_pdata *pdata = edac_dev->pvt_info;\r\nreturn sprintf(data, "0x%08x",\r\nin_be32(pdata->l2_vbase + MPC85XX_L2_ERRINJCTL));\r\n}\r\nstatic ssize_t mpc85xx_l2_inject_data_hi_store(struct edac_device_ctl_info\r\n*edac_dev, const char *data,\r\nsize_t count)\r\n{\r\nstruct mpc85xx_l2_pdata *pdata = edac_dev->pvt_info;\r\nif (isdigit(*data)) {\r\nout_be32(pdata->l2_vbase + MPC85XX_L2_ERRINJHI,\r\nsimple_strtoul(data, NULL, 0));\r\nreturn count;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t mpc85xx_l2_inject_data_lo_store(struct edac_device_ctl_info\r\n*edac_dev, const char *data,\r\nsize_t count)\r\n{\r\nstruct mpc85xx_l2_pdata *pdata = edac_dev->pvt_info;\r\nif (isdigit(*data)) {\r\nout_be32(pdata->l2_vbase + MPC85XX_L2_ERRINJLO,\r\nsimple_strtoul(data, NULL, 0));\r\nreturn count;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t mpc85xx_l2_inject_ctrl_store(struct edac_device_ctl_info\r\n*edac_dev, const char *data,\r\nsize_t count)\r\n{\r\nstruct mpc85xx_l2_pdata *pdata = edac_dev->pvt_info;\r\nif (isdigit(*data)) {\r\nout_be32(pdata->l2_vbase + MPC85XX_L2_ERRINJCTL,\r\nsimple_strtoul(data, NULL, 0));\r\nreturn count;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mpc85xx_set_l2_sysfs_attributes(struct edac_device_ctl_info\r\n*edac_dev)\r\n{\r\nedac_dev->sysfs_attributes = mpc85xx_l2_sysfs_attributes;\r\n}\r\nstatic void mpc85xx_l2_check(struct edac_device_ctl_info *edac_dev)\r\n{\r\nstruct mpc85xx_l2_pdata *pdata = edac_dev->pvt_info;\r\nu32 err_detect;\r\nerr_detect = in_be32(pdata->l2_vbase + MPC85XX_L2_ERRDET);\r\nif (!(err_detect & L2_EDE_MASK))\r\nreturn;\r\npr_err("ECC Error in CPU L2 cache\n");\r\npr_err("L2 Error Detect Register: 0x%08x\n", err_detect);\r\npr_err("L2 Error Capture Data High Register: 0x%08x\n",\r\nin_be32(pdata->l2_vbase + MPC85XX_L2_CAPTDATAHI));\r\npr_err("L2 Error Capture Data Lo Register: 0x%08x\n",\r\nin_be32(pdata->l2_vbase + MPC85XX_L2_CAPTDATALO));\r\npr_err("L2 Error Syndrome Register: 0x%08x\n",\r\nin_be32(pdata->l2_vbase + MPC85XX_L2_CAPTECC));\r\npr_err("L2 Error Attributes Capture Register: 0x%08x\n",\r\nin_be32(pdata->l2_vbase + MPC85XX_L2_ERRATTR));\r\npr_err("L2 Error Address Capture Register: 0x%08x\n",\r\nin_be32(pdata->l2_vbase + MPC85XX_L2_ERRADDR));\r\nout_be32(pdata->l2_vbase + MPC85XX_L2_ERRDET, err_detect);\r\nif (err_detect & L2_EDE_CE_MASK)\r\nedac_device_handle_ce(edac_dev, 0, 0, edac_dev->ctl_name);\r\nif (err_detect & L2_EDE_UE_MASK)\r\nedac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);\r\n}\r\nstatic irqreturn_t mpc85xx_l2_isr(int irq, void *dev_id)\r\n{\r\nstruct edac_device_ctl_info *edac_dev = dev_id;\r\nstruct mpc85xx_l2_pdata *pdata = edac_dev->pvt_info;\r\nu32 err_detect;\r\nerr_detect = in_be32(pdata->l2_vbase + MPC85XX_L2_ERRDET);\r\nif (!(err_detect & L2_EDE_MASK))\r\nreturn IRQ_NONE;\r\nmpc85xx_l2_check(edac_dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mpc85xx_l2_err_probe(struct platform_device *op)\r\n{\r\nstruct edac_device_ctl_info *edac_dev;\r\nstruct mpc85xx_l2_pdata *pdata;\r\nstruct resource r;\r\nint res;\r\nif (!devres_open_group(&op->dev, mpc85xx_l2_err_probe, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nedac_dev = edac_device_alloc_ctl_info(sizeof(*pdata),\r\n"cpu", 1, "L", 1, 2, NULL, 0,\r\nedac_dev_idx);\r\nif (!edac_dev) {\r\ndevres_release_group(&op->dev, mpc85xx_l2_err_probe);\r\nreturn -ENOMEM;\r\n}\r\npdata = edac_dev->pvt_info;\r\npdata->name = "mpc85xx_l2_err";\r\nedac_dev->dev = &op->dev;\r\ndev_set_drvdata(edac_dev->dev, edac_dev);\r\nedac_dev->ctl_name = pdata->name;\r\nedac_dev->dev_name = pdata->name;\r\nres = of_address_to_resource(op->dev.of_node, 0, &r);\r\nif (res) {\r\npr_err("%s: Unable to get resource for L2 err regs\n", __func__);\r\ngoto err;\r\n}\r\nr.start += 0xe00;\r\nif (!devm_request_mem_region(&op->dev, r.start, resource_size(&r),\r\npdata->name)) {\r\npr_err("%s: Error while requesting mem region\n", __func__);\r\nres = -EBUSY;\r\ngoto err;\r\n}\r\npdata->l2_vbase = devm_ioremap(&op->dev, r.start, resource_size(&r));\r\nif (!pdata->l2_vbase) {\r\npr_err("%s: Unable to setup L2 err regs\n", __func__);\r\nres = -ENOMEM;\r\ngoto err;\r\n}\r\nout_be32(pdata->l2_vbase + MPC85XX_L2_ERRDET, ~0);\r\norig_l2_err_disable = in_be32(pdata->l2_vbase + MPC85XX_L2_ERRDIS);\r\nout_be32(pdata->l2_vbase + MPC85XX_L2_ERRDIS, 0);\r\nedac_dev->mod_name = EDAC_MOD_STR;\r\nif (edac_op_state == EDAC_OPSTATE_POLL)\r\nedac_dev->edac_check = mpc85xx_l2_check;\r\nmpc85xx_set_l2_sysfs_attributes(edac_dev);\r\npdata->edac_idx = edac_dev_idx++;\r\nif (edac_device_add_device(edac_dev) > 0) {\r\nedac_dbg(3, "failed edac_device_add_device()\n");\r\ngoto err;\r\n}\r\nif (edac_op_state == EDAC_OPSTATE_INT) {\r\npdata->irq = irq_of_parse_and_map(op->dev.of_node, 0);\r\nres = devm_request_irq(&op->dev, pdata->irq,\r\nmpc85xx_l2_isr, IRQF_SHARED,\r\n"[EDAC] L2 err", edac_dev);\r\nif (res < 0) {\r\npr_err("%s: Unable to request irq %d for MPC85xx L2 err\n",\r\n__func__, pdata->irq);\r\nirq_dispose_mapping(pdata->irq);\r\nres = -ENODEV;\r\ngoto err2;\r\n}\r\npr_info(EDAC_MOD_STR " acquired irq %d for L2 Err\n", pdata->irq);\r\nedac_dev->op_state = OP_RUNNING_INTERRUPT;\r\nout_be32(pdata->l2_vbase + MPC85XX_L2_ERRINTEN, L2_EIE_MASK);\r\n}\r\ndevres_remove_group(&op->dev, mpc85xx_l2_err_probe);\r\nedac_dbg(3, "success\n");\r\npr_info(EDAC_MOD_STR " L2 err registered\n");\r\nreturn 0;\r\nerr2:\r\nedac_device_del_device(&op->dev);\r\nerr:\r\ndevres_release_group(&op->dev, mpc85xx_l2_err_probe);\r\nedac_device_free_ctl_info(edac_dev);\r\nreturn res;\r\n}\r\nstatic int mpc85xx_l2_err_remove(struct platform_device *op)\r\n{\r\nstruct edac_device_ctl_info *edac_dev = dev_get_drvdata(&op->dev);\r\nstruct mpc85xx_l2_pdata *pdata = edac_dev->pvt_info;\r\nedac_dbg(0, "\n");\r\nif (edac_op_state == EDAC_OPSTATE_INT) {\r\nout_be32(pdata->l2_vbase + MPC85XX_L2_ERRINTEN, 0);\r\nirq_dispose_mapping(pdata->irq);\r\n}\r\nout_be32(pdata->l2_vbase + MPC85XX_L2_ERRDIS, orig_l2_err_disable);\r\nedac_device_del_device(&op->dev);\r\nedac_device_free_ctl_info(edac_dev);\r\nreturn 0;\r\n}\r\nstatic int __init mpc85xx_mc_init(void)\r\n{\r\nint res = 0;\r\nu32 __maybe_unused pvr = 0;\r\npr_info("Freescale(R) MPC85xx EDAC driver, (C) 2006 Montavista Software\n");\r\nswitch (edac_op_state) {\r\ncase EDAC_OPSTATE_POLL:\r\ncase EDAC_OPSTATE_INT:\r\nbreak;\r\ndefault:\r\nedac_op_state = EDAC_OPSTATE_INT;\r\nbreak;\r\n}\r\nres = platform_register_drivers(drivers, ARRAY_SIZE(drivers));\r\nif (res)\r\npr_warn(EDAC_MOD_STR "drivers fail to register\n");\r\nreturn 0;\r\n}\r\nstatic void __exit mpc85xx_mc_exit(void)\r\n{\r\nplatform_unregister_drivers(drivers, ARRAY_SIZE(drivers));\r\n}
