int idr_alloc(struct idr *idr, void *ptr, int start, int end, gfp_t gfp)\r\n{\r\nvoid __rcu **slot;\r\nstruct radix_tree_iter iter;\r\nif (WARN_ON_ONCE(start < 0))\r\nreturn -EINVAL;\r\nif (WARN_ON_ONCE(radix_tree_is_internal_node(ptr)))\r\nreturn -EINVAL;\r\nradix_tree_iter_init(&iter, start);\r\nslot = idr_get_free(&idr->idr_rt, &iter, gfp, end);\r\nif (IS_ERR(slot))\r\nreturn PTR_ERR(slot);\r\nradix_tree_iter_replace(&idr->idr_rt, &iter, slot, ptr);\r\nradix_tree_iter_tag_clear(&idr->idr_rt, &iter, IDR_FREE);\r\nreturn iter.index;\r\n}\r\nint idr_alloc_cyclic(struct idr *idr, void *ptr, int start, int end, gfp_t gfp)\r\n{\r\nint id, curr = idr->idr_next;\r\nif (curr < start)\r\ncurr = start;\r\nid = idr_alloc(idr, ptr, curr, end, gfp);\r\nif ((id == -ENOSPC) && (curr > start))\r\nid = idr_alloc(idr, ptr, start, curr, gfp);\r\nif (id >= 0)\r\nidr->idr_next = id + 1U;\r\nreturn id;\r\n}\r\nint idr_for_each(const struct idr *idr,\r\nint (*fn)(int id, void *p, void *data), void *data)\r\n{\r\nstruct radix_tree_iter iter;\r\nvoid __rcu **slot;\r\nradix_tree_for_each_slot(slot, &idr->idr_rt, &iter, 0) {\r\nint ret = fn(iter.index, rcu_dereference_raw(*slot), data);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid *idr_get_next(struct idr *idr, int *nextid)\r\n{\r\nstruct radix_tree_iter iter;\r\nvoid __rcu **slot;\r\nslot = radix_tree_iter_find(&idr->idr_rt, &iter, *nextid);\r\nif (!slot)\r\nreturn NULL;\r\n*nextid = iter.index;\r\nreturn rcu_dereference_raw(*slot);\r\n}\r\nvoid *idr_replace(struct idr *idr, void *ptr, int id)\r\n{\r\nstruct radix_tree_node *node;\r\nvoid __rcu **slot = NULL;\r\nvoid *entry;\r\nif (WARN_ON_ONCE(id < 0))\r\nreturn ERR_PTR(-EINVAL);\r\nif (WARN_ON_ONCE(radix_tree_is_internal_node(ptr)))\r\nreturn ERR_PTR(-EINVAL);\r\nentry = __radix_tree_lookup(&idr->idr_rt, id, &node, &slot);\r\nif (!slot || radix_tree_tag_get(&idr->idr_rt, id, IDR_FREE))\r\nreturn ERR_PTR(-ENOENT);\r\n__radix_tree_replace(&idr->idr_rt, node, slot, ptr, NULL, NULL);\r\nreturn entry;\r\n}\r\nint ida_get_new_above(struct ida *ida, int start, int *id)\r\n{\r\nstruct radix_tree_root *root = &ida->ida_rt;\r\nvoid __rcu **slot;\r\nstruct radix_tree_iter iter;\r\nstruct ida_bitmap *bitmap;\r\nunsigned long index;\r\nunsigned bit, ebit;\r\nint new;\r\nindex = start / IDA_BITMAP_BITS;\r\nbit = start % IDA_BITMAP_BITS;\r\nebit = bit + RADIX_TREE_EXCEPTIONAL_SHIFT;\r\nslot = radix_tree_iter_init(&iter, index);\r\nfor (;;) {\r\nif (slot)\r\nslot = radix_tree_next_slot(slot, &iter,\r\nRADIX_TREE_ITER_TAGGED);\r\nif (!slot) {\r\nslot = idr_get_free(root, &iter, GFP_NOWAIT, IDA_MAX);\r\nif (IS_ERR(slot)) {\r\nif (slot == ERR_PTR(-ENOMEM))\r\nreturn -EAGAIN;\r\nreturn PTR_ERR(slot);\r\n}\r\n}\r\nif (iter.index > index) {\r\nbit = 0;\r\nebit = RADIX_TREE_EXCEPTIONAL_SHIFT;\r\n}\r\nnew = iter.index * IDA_BITMAP_BITS;\r\nbitmap = rcu_dereference_raw(*slot);\r\nif (radix_tree_exception(bitmap)) {\r\nunsigned long tmp = (unsigned long)bitmap;\r\nebit = find_next_zero_bit(&tmp, BITS_PER_LONG, ebit);\r\nif (ebit < BITS_PER_LONG) {\r\ntmp |= 1UL << ebit;\r\nrcu_assign_pointer(*slot, (void *)tmp);\r\n*id = new + ebit - RADIX_TREE_EXCEPTIONAL_SHIFT;\r\nreturn 0;\r\n}\r\nbitmap = this_cpu_xchg(ida_bitmap, NULL);\r\nif (!bitmap)\r\nreturn -EAGAIN;\r\nmemset(bitmap, 0, sizeof(*bitmap));\r\nbitmap->bitmap[0] = tmp >> RADIX_TREE_EXCEPTIONAL_SHIFT;\r\nrcu_assign_pointer(*slot, bitmap);\r\n}\r\nif (bitmap) {\r\nbit = find_next_zero_bit(bitmap->bitmap,\r\nIDA_BITMAP_BITS, bit);\r\nnew += bit;\r\nif (new < 0)\r\nreturn -ENOSPC;\r\nif (bit == IDA_BITMAP_BITS)\r\ncontinue;\r\n__set_bit(bit, bitmap->bitmap);\r\nif (bitmap_full(bitmap->bitmap, IDA_BITMAP_BITS))\r\nradix_tree_iter_tag_clear(root, &iter,\r\nIDR_FREE);\r\n} else {\r\nnew += bit;\r\nif (new < 0)\r\nreturn -ENOSPC;\r\nif (ebit < BITS_PER_LONG) {\r\nbitmap = (void *)((1UL << ebit) |\r\nRADIX_TREE_EXCEPTIONAL_ENTRY);\r\nradix_tree_iter_replace(root, &iter, slot,\r\nbitmap);\r\n*id = new;\r\nreturn 0;\r\n}\r\nbitmap = this_cpu_xchg(ida_bitmap, NULL);\r\nif (!bitmap)\r\nreturn -EAGAIN;\r\nmemset(bitmap, 0, sizeof(*bitmap));\r\n__set_bit(bit, bitmap->bitmap);\r\nradix_tree_iter_replace(root, &iter, slot, bitmap);\r\n}\r\n*id = new;\r\nreturn 0;\r\n}\r\n}\r\nvoid ida_remove(struct ida *ida, int id)\r\n{\r\nunsigned long index = id / IDA_BITMAP_BITS;\r\nunsigned offset = id % IDA_BITMAP_BITS;\r\nstruct ida_bitmap *bitmap;\r\nunsigned long *btmp;\r\nstruct radix_tree_iter iter;\r\nvoid __rcu **slot;\r\nslot = radix_tree_iter_lookup(&ida->ida_rt, &iter, index);\r\nif (!slot)\r\ngoto err;\r\nbitmap = rcu_dereference_raw(*slot);\r\nif (radix_tree_exception(bitmap)) {\r\nbtmp = (unsigned long *)slot;\r\noffset += RADIX_TREE_EXCEPTIONAL_SHIFT;\r\nif (offset >= BITS_PER_LONG)\r\ngoto err;\r\n} else {\r\nbtmp = bitmap->bitmap;\r\n}\r\nif (!test_bit(offset, btmp))\r\ngoto err;\r\n__clear_bit(offset, btmp);\r\nradix_tree_iter_tag_set(&ida->ida_rt, &iter, IDR_FREE);\r\nif (radix_tree_exception(bitmap)) {\r\nif (rcu_dereference_raw(*slot) ==\r\n(void *)RADIX_TREE_EXCEPTIONAL_ENTRY)\r\nradix_tree_iter_delete(&ida->ida_rt, &iter, slot);\r\n} else if (bitmap_empty(btmp, IDA_BITMAP_BITS)) {\r\nkfree(bitmap);\r\nradix_tree_iter_delete(&ida->ida_rt, &iter, slot);\r\n}\r\nreturn;\r\nerr:\r\nWARN(1, "ida_remove called for id=%d which is not allocated.\n", id);\r\n}\r\nvoid ida_destroy(struct ida *ida)\r\n{\r\nstruct radix_tree_iter iter;\r\nvoid __rcu **slot;\r\nradix_tree_for_each_slot(slot, &ida->ida_rt, &iter, 0) {\r\nstruct ida_bitmap *bitmap = rcu_dereference_raw(*slot);\r\nif (!radix_tree_exception(bitmap))\r\nkfree(bitmap);\r\nradix_tree_iter_delete(&ida->ida_rt, &iter, slot);\r\n}\r\n}\r\nint ida_simple_get(struct ida *ida, unsigned int start, unsigned int end,\r\ngfp_t gfp_mask)\r\n{\r\nint ret, id;\r\nunsigned int max;\r\nunsigned long flags;\r\nBUG_ON((int)start < 0);\r\nBUG_ON((int)end < 0);\r\nif (end == 0)\r\nmax = 0x80000000;\r\nelse {\r\nBUG_ON(end < start);\r\nmax = end - 1;\r\n}\r\nagain:\r\nif (!ida_pre_get(ida, gfp_mask))\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&simple_ida_lock, flags);\r\nret = ida_get_new_above(ida, start, &id);\r\nif (!ret) {\r\nif (id > max) {\r\nida_remove(ida, id);\r\nret = -ENOSPC;\r\n} else {\r\nret = id;\r\n}\r\n}\r\nspin_unlock_irqrestore(&simple_ida_lock, flags);\r\nif (unlikely(ret == -EAGAIN))\r\ngoto again;\r\nreturn ret;\r\n}\r\nvoid ida_simple_remove(struct ida *ida, unsigned int id)\r\n{\r\nunsigned long flags;\r\nBUG_ON((int)id < 0);\r\nspin_lock_irqsave(&simple_ida_lock, flags);\r\nida_remove(ida, id);\r\nspin_unlock_irqrestore(&simple_ida_lock, flags);\r\n}
