static int ide_imodel_proc_show(struct seq_file *m, void *v)\r\n{\r\nide_hwif_t *hwif = (ide_hwif_t *) m->private;\r\nconst char *name;\r\nswitch (hwif->chipset) {\r\ncase ide_generic: name = "generic"; break;\r\ncase ide_pci: name = "pci"; break;\r\ncase ide_cmd640: name = "cmd640"; break;\r\ncase ide_dtc2278: name = "dtc2278"; break;\r\ncase ide_ali14xx: name = "ali14xx"; break;\r\ncase ide_qd65xx: name = "qd65xx"; break;\r\ncase ide_umc8672: name = "umc8672"; break;\r\ncase ide_ht6560b: name = "ht6560b"; break;\r\ncase ide_4drives: name = "4drives"; break;\r\ncase ide_pmac: name = "mac-io"; break;\r\ncase ide_au1xxx: name = "au1xxx"; break;\r\ncase ide_palm3710: name = "palm3710"; break;\r\ncase ide_acorn: name = "acorn"; break;\r\ndefault: name = "(unknown)"; break;\r\n}\r\nseq_printf(m, "%s\n", name);\r\nreturn 0;\r\n}\r\nstatic int ide_imodel_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ide_imodel_proc_show, PDE_DATA(inode));\r\n}\r\nstatic int ide_mate_proc_show(struct seq_file *m, void *v)\r\n{\r\nide_hwif_t *hwif = (ide_hwif_t *) m->private;\r\nif (hwif && hwif->mate)\r\nseq_printf(m, "%s\n", hwif->mate->name);\r\nelse\r\nseq_printf(m, "(none)\n");\r\nreturn 0;\r\n}\r\nstatic int ide_mate_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ide_mate_proc_show, PDE_DATA(inode));\r\n}\r\nstatic int ide_channel_proc_show(struct seq_file *m, void *v)\r\n{\r\nide_hwif_t *hwif = (ide_hwif_t *) m->private;\r\nseq_printf(m, "%c\n", hwif->channel ? '1' : '0');\r\nreturn 0;\r\n}\r\nstatic int ide_channel_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ide_channel_proc_show, PDE_DATA(inode));\r\n}\r\nstatic int ide_identify_proc_show(struct seq_file *m, void *v)\r\n{\r\nide_drive_t *drive = (ide_drive_t *)m->private;\r\nu8 *buf;\r\nif (!drive) {\r\nseq_putc(m, '\n');\r\nreturn 0;\r\n}\r\nbuf = kmalloc(SECTOR_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (taskfile_lib_get_identify(drive, buf) == 0) {\r\n__le16 *val = (__le16 *)buf;\r\nint i;\r\nfor (i = 0; i < SECTOR_SIZE / 2; i++) {\r\nseq_printf(m, "%04x%c", le16_to_cpu(val[i]),\r\n(i % 8) == 7 ? '\n' : ' ');\r\n}\r\n} else\r\nseq_putc(m, buf[0]);\r\nkfree(buf);\r\nreturn 0;\r\n}\r\nstatic int ide_identify_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ide_identify_proc_show, PDE_DATA(inode));\r\n}\r\nstatic\r\nconst struct ide_proc_devset *ide_find_setting(const struct ide_proc_devset *st,\r\nchar *name)\r\n{\r\nwhile (st->name) {\r\nif (strcmp(st->name, name) == 0)\r\nbreak;\r\nst++;\r\n}\r\nreturn st->name ? st : NULL;\r\n}\r\nstatic int ide_read_setting(ide_drive_t *drive,\r\nconst struct ide_proc_devset *setting)\r\n{\r\nconst struct ide_devset *ds = setting->setting;\r\nint val = -EINVAL;\r\nif (ds->get)\r\nval = ds->get(drive);\r\nreturn val;\r\n}\r\nstatic int ide_write_setting(ide_drive_t *drive,\r\nconst struct ide_proc_devset *setting, int val)\r\n{\r\nconst struct ide_devset *ds = setting->setting;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nif (!ds->set)\r\nreturn -EPERM;\r\nif ((ds->flags & DS_SYNC)\r\n&& (val < setting->min || val > setting->max))\r\nreturn -EINVAL;\r\nreturn ide_devset_execute(drive, ds, val);\r\n}\r\nstatic int set_xfer_rate (ide_drive_t *drive, int arg)\r\n{\r\nstruct ide_cmd cmd;\r\nif (arg < XFER_PIO_0 || arg > XFER_UDMA_6)\r\nreturn -EINVAL;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.tf.command = ATA_CMD_SET_FEATURES;\r\ncmd.tf.feature = SETFEATURES_XFER;\r\ncmd.tf.nsect = (u8)arg;\r\ncmd.valid.out.tf = IDE_VALID_FEATURE | IDE_VALID_NSECT;\r\ncmd.valid.in.tf = IDE_VALID_NSECT;\r\ncmd.tf_flags = IDE_TFLAG_SET_XFER;\r\nreturn ide_no_data_taskfile(drive, &cmd);\r\n}\r\nstatic void proc_ide_settings_warn(void)\r\n{\r\nprintk_once(KERN_WARNING "Warning: /proc/ide/hd?/settings interface is "\r\n"obsolete, and will be removed soon!\n");\r\n}\r\nstatic int ide_settings_proc_show(struct seq_file *m, void *v)\r\n{\r\nconst struct ide_proc_devset *setting, *g, *d;\r\nconst struct ide_devset *ds;\r\nide_drive_t *drive = (ide_drive_t *) m->private;\r\nint rc, mul_factor, div_factor;\r\nproc_ide_settings_warn();\r\nmutex_lock(&ide_setting_mtx);\r\ng = ide_generic_settings;\r\nd = drive->settings;\r\nseq_printf(m, "name\t\t\tvalue\t\tmin\t\tmax\t\tmode\n");\r\nseq_printf(m, "----\t\t\t-----\t\t---\t\t---\t\t----\n");\r\nwhile (g->name || (d && d->name)) {\r\nif (g->name && d && d->name) {\r\nif (strcmp(d->name, g->name) < 0)\r\nsetting = d++;\r\nelse\r\nsetting = g++;\r\n} else if (d && d->name) {\r\nsetting = d++;\r\n} else\r\nsetting = g++;\r\nmul_factor = setting->mulf ? setting->mulf(drive) : 1;\r\ndiv_factor = setting->divf ? setting->divf(drive) : 1;\r\nseq_printf(m, "%-24s", setting->name);\r\nrc = ide_read_setting(drive, setting);\r\nif (rc >= 0)\r\nseq_printf(m, "%-16d", rc * mul_factor / div_factor);\r\nelse\r\nseq_printf(m, "%-16s", "write-only");\r\nseq_printf(m, "%-16d%-16d", (setting->min * mul_factor + div_factor - 1) / div_factor, setting->max * mul_factor / div_factor);\r\nds = setting->setting;\r\nif (ds->get)\r\nseq_printf(m, "r");\r\nif (ds->set)\r\nseq_printf(m, "w");\r\nseq_printf(m, "\n");\r\n}\r\nmutex_unlock(&ide_setting_mtx);\r\nreturn 0;\r\n}\r\nstatic int ide_settings_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ide_settings_proc_show, PDE_DATA(inode));\r\n}\r\nstatic ssize_t ide_settings_proc_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *pos)\r\n{\r\nide_drive_t *drive = PDE_DATA(file_inode(file));\r\nchar name[MAX_LEN + 1];\r\nint for_real = 0, mul_factor, div_factor;\r\nunsigned long n;\r\nconst struct ide_proc_devset *setting;\r\nchar *buf, *s;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nproc_ide_settings_warn();\r\nif (count >= PAGE_SIZE)\r\nreturn -EINVAL;\r\ns = buf = (char *)__get_free_page(GFP_USER);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (copy_from_user(buf, buffer, count)) {\r\nfree_page((unsigned long)buf);\r\nreturn -EFAULT;\r\n}\r\nbuf[count] = '\0';\r\nwhile (count && isspace(*s)) {\r\n--count;\r\n++s;\r\n}\r\ndo {\r\nchar *p = s;\r\nn = count;\r\nwhile (n > 0) {\r\nunsigned val;\r\nchar *q = p;\r\nwhile (n > 0 && *p != ':') {\r\n--n;\r\np++;\r\n}\r\nif (*p != ':')\r\ngoto parse_error;\r\nif (p - q > MAX_LEN)\r\ngoto parse_error;\r\nmemcpy(name, q, p - q);\r\nname[p - q] = 0;\r\nif (n > 0) {\r\n--n;\r\np++;\r\n} else\r\ngoto parse_error;\r\nval = simple_strtoul(p, &q, 10);\r\nn -= q - p;\r\np = q;\r\nif (n > 0 && !isspace(*p))\r\ngoto parse_error;\r\nwhile (n > 0 && isspace(*p)) {\r\n--n;\r\n++p;\r\n}\r\nmutex_lock(&ide_setting_mtx);\r\nsetting = ide_find_setting(ide_generic_settings, name);\r\nif (!setting) {\r\nif (drive->settings)\r\nsetting = ide_find_setting(drive->settings, name);\r\nif (!setting) {\r\nmutex_unlock(&ide_setting_mtx);\r\ngoto parse_error;\r\n}\r\n}\r\nif (for_real) {\r\nmul_factor = setting->mulf ? setting->mulf(drive) : 1;\r\ndiv_factor = setting->divf ? setting->divf(drive) : 1;\r\nide_write_setting(drive, setting, val * div_factor / mul_factor);\r\n}\r\nmutex_unlock(&ide_setting_mtx);\r\n}\r\n} while (!for_real++);\r\nfree_page((unsigned long)buf);\r\nreturn count;\r\nparse_error:\r\nfree_page((unsigned long)buf);\r\nprintk("%s(): parse error\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nstatic int ide_capacity_proc_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "%llu\n", (long long)0x7fffffff);\r\nreturn 0;\r\n}\r\nstatic int ide_capacity_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ide_capacity_proc_show, NULL);\r\n}\r\nstatic int ide_geometry_proc_show(struct seq_file *m, void *v)\r\n{\r\nide_drive_t *drive = (ide_drive_t *) m->private;\r\nseq_printf(m, "physical %d/%d/%d\n",\r\ndrive->cyl, drive->head, drive->sect);\r\nseq_printf(m, "logical %d/%d/%d\n",\r\ndrive->bios_cyl, drive->bios_head, drive->bios_sect);\r\nreturn 0;\r\n}\r\nstatic int ide_geometry_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ide_geometry_proc_show, PDE_DATA(inode));\r\n}\r\nstatic int ide_dmodel_proc_show(struct seq_file *seq, void *v)\r\n{\r\nide_drive_t *drive = (ide_drive_t *) seq->private;\r\nchar *m = (char *)&drive->id[ATA_ID_PROD];\r\nseq_printf(seq, "%.40s\n", m[0] ? m : "(none)");\r\nreturn 0;\r\n}\r\nstatic int ide_dmodel_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ide_dmodel_proc_show, PDE_DATA(inode));\r\n}\r\nstatic int ide_driver_proc_show(struct seq_file *m, void *v)\r\n{\r\nide_drive_t *drive = (ide_drive_t *)m->private;\r\nstruct device *dev = &drive->gendev;\r\nstruct ide_driver *ide_drv;\r\nif (dev->driver) {\r\nide_drv = to_ide_driver(dev->driver);\r\nseq_printf(m, "%s version %s\n",\r\ndev->driver->name, ide_drv->version);\r\n} else\r\nseq_printf(m, "ide-default version 0.9.newide\n");\r\nreturn 0;\r\n}\r\nstatic int ide_driver_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ide_driver_proc_show, PDE_DATA(inode));\r\n}\r\nstatic int ide_replace_subdriver(ide_drive_t *drive, const char *driver)\r\n{\r\nstruct device *dev = &drive->gendev;\r\nint ret = 1;\r\nint err;\r\ndevice_release_driver(dev);\r\nstrlcpy(drive->driver_req, driver, sizeof(drive->driver_req));\r\nerr = device_attach(dev);\r\nif (err < 0)\r\nprintk(KERN_WARNING "IDE: %s: device_attach error: %d\n",\r\n__func__, err);\r\ndrive->driver_req[0] = 0;\r\nif (dev->driver == NULL) {\r\nerr = device_attach(dev);\r\nif (err < 0)\r\nprintk(KERN_WARNING\r\n"IDE: %s: device_attach(2) error: %d\n",\r\n__func__, err);\r\n}\r\nif (dev->driver && !strcmp(dev->driver->name, driver))\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic ssize_t ide_driver_proc_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *pos)\r\n{\r\nide_drive_t *drive = PDE_DATA(file_inode(file));\r\nchar name[32];\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nif (count > 31)\r\ncount = 31;\r\nif (copy_from_user(name, buffer, count))\r\nreturn -EFAULT;\r\nname[count] = '\0';\r\nif (ide_replace_subdriver(drive, name))\r\nreturn -EINVAL;\r\nreturn count;\r\n}\r\nstatic int ide_media_proc_show(struct seq_file *m, void *v)\r\n{\r\nide_drive_t *drive = (ide_drive_t *) m->private;\r\nconst char *media;\r\nswitch (drive->media) {\r\ncase ide_disk: media = "disk\n"; break;\r\ncase ide_cdrom: media = "cdrom\n"; break;\r\ncase ide_tape: media = "tape\n"; break;\r\ncase ide_floppy: media = "floppy\n"; break;\r\ncase ide_optical: media = "optical\n"; break;\r\ndefault: media = "UNKNOWN\n"; break;\r\n}\r\nseq_puts(m, media);\r\nreturn 0;\r\n}\r\nstatic int ide_media_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ide_media_proc_show, PDE_DATA(inode));\r\n}\r\nstatic void ide_add_proc_entries(struct proc_dir_entry *dir, ide_proc_entry_t *p, void *data)\r\n{\r\nstruct proc_dir_entry *ent;\r\nif (!dir || !p)\r\nreturn;\r\nwhile (p->name != NULL) {\r\nent = proc_create_data(p->name, p->mode, dir, p->proc_fops, data);\r\nif (!ent) return;\r\np++;\r\n}\r\n}\r\nstatic void ide_remove_proc_entries(struct proc_dir_entry *dir, ide_proc_entry_t *p)\r\n{\r\nif (!dir || !p)\r\nreturn;\r\nwhile (p->name != NULL) {\r\nremove_proc_entry(p->name, dir);\r\np++;\r\n}\r\n}\r\nvoid ide_proc_register_driver(ide_drive_t *drive, struct ide_driver *driver)\r\n{\r\nmutex_lock(&ide_setting_mtx);\r\ndrive->settings = driver->proc_devsets(drive);\r\nmutex_unlock(&ide_setting_mtx);\r\nide_add_proc_entries(drive->proc, driver->proc_entries(drive), drive);\r\n}\r\nvoid ide_proc_unregister_driver(ide_drive_t *drive, struct ide_driver *driver)\r\n{\r\nide_remove_proc_entries(drive->proc, driver->proc_entries(drive));\r\nmutex_lock(&ide_setting_mtx);\r\ndrive->settings = NULL;\r\nmutex_unlock(&ide_setting_mtx);\r\n}\r\nvoid ide_proc_port_register_devices(ide_hwif_t *hwif)\r\n{\r\nstruct proc_dir_entry *ent;\r\nstruct proc_dir_entry *parent = hwif->proc;\r\nide_drive_t *drive;\r\nchar name[64];\r\nint i;\r\nide_port_for_each_dev(i, drive, hwif) {\r\nif ((drive->dev_flags & IDE_DFLAG_PRESENT) == 0)\r\ncontinue;\r\ndrive->proc = proc_mkdir(drive->name, parent);\r\nif (drive->proc)\r\nide_add_proc_entries(drive->proc, generic_drive_entries, drive);\r\nsprintf(name, "ide%d/%s", (drive->name[2]-'a')/2, drive->name);\r\nent = proc_symlink(drive->name, proc_ide_root, name);\r\nif (!ent) return;\r\n}\r\n}\r\nvoid ide_proc_unregister_device(ide_drive_t *drive)\r\n{\r\nif (drive->proc) {\r\nide_remove_proc_entries(drive->proc, generic_drive_entries);\r\nremove_proc_entry(drive->name, proc_ide_root);\r\nremove_proc_entry(drive->name, drive->hwif->proc);\r\ndrive->proc = NULL;\r\n}\r\n}\r\nvoid ide_proc_register_port(ide_hwif_t *hwif)\r\n{\r\nif (!hwif->proc) {\r\nhwif->proc = proc_mkdir(hwif->name, proc_ide_root);\r\nif (!hwif->proc)\r\nreturn;\r\nide_add_proc_entries(hwif->proc, hwif_entries, hwif);\r\n}\r\n}\r\nvoid ide_proc_unregister_port(ide_hwif_t *hwif)\r\n{\r\nif (hwif->proc) {\r\nide_remove_proc_entries(hwif->proc, hwif_entries);\r\nremove_proc_entry(hwif->name, proc_ide_root);\r\nhwif->proc = NULL;\r\n}\r\n}\r\nstatic int proc_print_driver(struct device_driver *drv, void *data)\r\n{\r\nstruct ide_driver *ide_drv = to_ide_driver(drv);\r\nstruct seq_file *s = data;\r\nseq_printf(s, "%s version %s\n", drv->name, ide_drv->version);\r\nreturn 0;\r\n}\r\nstatic int ide_drivers_show(struct seq_file *s, void *p)\r\n{\r\nint err;\r\nerr = bus_for_each_drv(&ide_bus_type, NULL, s, proc_print_driver);\r\nif (err < 0)\r\nprintk(KERN_WARNING "IDE: %s: bus_for_each_drv error: %d\n",\r\n__func__, err);\r\nreturn 0;\r\n}\r\nstatic int ide_drivers_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, &ide_drivers_show, NULL);\r\n}\r\nvoid proc_ide_create(void)\r\n{\r\nproc_ide_root = proc_mkdir("ide", NULL);\r\nif (!proc_ide_root)\r\nreturn;\r\nproc_create("drivers", 0, proc_ide_root, &ide_drivers_operations);\r\n}\r\nvoid proc_ide_destroy(void)\r\n{\r\nremove_proc_entry("drivers", proc_ide_root);\r\nremove_proc_entry("ide", NULL);\r\n}
