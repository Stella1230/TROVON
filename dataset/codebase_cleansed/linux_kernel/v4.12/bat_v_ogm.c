struct batadv_orig_node *batadv_v_ogm_orig_get(struct batadv_priv *bat_priv,\r\nconst u8 *addr)\r\n{\r\nstruct batadv_orig_node *orig_node;\r\nint hash_added;\r\norig_node = batadv_orig_hash_find(bat_priv, addr);\r\nif (orig_node)\r\nreturn orig_node;\r\norig_node = batadv_orig_node_new(bat_priv, addr);\r\nif (!orig_node)\r\nreturn NULL;\r\nkref_get(&orig_node->refcount);\r\nhash_added = batadv_hash_add(bat_priv->orig_hash, batadv_compare_orig,\r\nbatadv_choose_orig, orig_node,\r\n&orig_node->hash_entry);\r\nif (hash_added != 0) {\r\nbatadv_orig_node_put(orig_node);\r\nbatadv_orig_node_put(orig_node);\r\norig_node = NULL;\r\n}\r\nreturn orig_node;\r\n}\r\nstatic void batadv_v_ogm_start_timer(struct batadv_priv *bat_priv)\r\n{\r\nunsigned long msecs;\r\nif (delayed_work_pending(&bat_priv->bat_v.ogm_wq))\r\nreturn;\r\nmsecs = atomic_read(&bat_priv->orig_interval) - BATADV_JITTER;\r\nmsecs += prandom_u32() % (2 * BATADV_JITTER);\r\nqueue_delayed_work(batadv_event_workqueue, &bat_priv->bat_v.ogm_wq,\r\nmsecs_to_jiffies(msecs));\r\n}\r\nstatic void batadv_v_ogm_send_to_if(struct sk_buff *skb,\r\nstruct batadv_hard_iface *hard_iface)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\r\nif (hard_iface->if_status != BATADV_IF_ACTIVE)\r\nreturn;\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_MGMT_TX);\r\nbatadv_add_counter(bat_priv, BATADV_CNT_MGMT_TX_BYTES,\r\nskb->len + ETH_HLEN);\r\nbatadv_send_broadcast_skb(skb, hard_iface);\r\n}\r\nstatic void batadv_v_ogm_send(struct work_struct *work)\r\n{\r\nstruct batadv_hard_iface *hard_iface;\r\nstruct batadv_priv_bat_v *bat_v;\r\nstruct batadv_priv *bat_priv;\r\nstruct batadv_ogm2_packet *ogm_packet;\r\nstruct sk_buff *skb, *skb_tmp;\r\nunsigned char *ogm_buff, *pkt_buff;\r\nint ogm_buff_len;\r\nu16 tvlv_len = 0;\r\nint ret;\r\nbat_v = container_of(work, struct batadv_priv_bat_v, ogm_wq.work);\r\nbat_priv = container_of(bat_v, struct batadv_priv, bat_v);\r\nif (atomic_read(&bat_priv->mesh_state) == BATADV_MESH_DEACTIVATING)\r\ngoto out;\r\nogm_buff = bat_priv->bat_v.ogm_buff;\r\nogm_buff_len = bat_priv->bat_v.ogm_buff_len;\r\nbatadv_tt_local_commit_changes(bat_priv);\r\ntvlv_len = batadv_tvlv_container_ogm_append(bat_priv, &ogm_buff,\r\n&ogm_buff_len,\r\nBATADV_OGM2_HLEN);\r\nbat_priv->bat_v.ogm_buff = ogm_buff;\r\nbat_priv->bat_v.ogm_buff_len = ogm_buff_len;\r\nskb = netdev_alloc_skb_ip_align(NULL, ETH_HLEN + ogm_buff_len);\r\nif (!skb)\r\ngoto reschedule;\r\nskb_reserve(skb, ETH_HLEN);\r\npkt_buff = skb_put(skb, ogm_buff_len);\r\nmemcpy(pkt_buff, ogm_buff, ogm_buff_len);\r\nogm_packet = (struct batadv_ogm2_packet *)skb->data;\r\nogm_packet->seqno = htonl(atomic_read(&bat_priv->bat_v.ogm_seqno));\r\natomic_inc(&bat_priv->bat_v.ogm_seqno);\r\nogm_packet->tvlv_len = htons(tvlv_len);\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\r\nif (hard_iface->soft_iface != bat_priv->soft_iface)\r\ncontinue;\r\nif (!kref_get_unless_zero(&hard_iface->refcount))\r\ncontinue;\r\nret = batadv_hardif_no_broadcast(hard_iface, NULL, NULL);\r\nif (ret) {\r\nchar *type;\r\nswitch (ret) {\r\ncase BATADV_HARDIF_BCAST_NORECIPIENT:\r\ntype = "no neighbor";\r\nbreak;\r\ncase BATADV_HARDIF_BCAST_DUPFWD:\r\ntype = "single neighbor is source";\r\nbreak;\r\ncase BATADV_HARDIF_BCAST_DUPORIG:\r\ntype = "single neighbor is originator";\r\nbreak;\r\ndefault:\r\ntype = "unknown";\r\n}\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv, "OGM2 from ourselve on %s surpressed: %s\n",\r\nhard_iface->net_dev->name, type);\r\nbatadv_hardif_put(hard_iface);\r\ncontinue;\r\n}\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Sending own OGM2 packet (originator %pM, seqno %u, throughput %u, TTL %d) on interface %s [%pM]\n",\r\nogm_packet->orig, ntohl(ogm_packet->seqno),\r\nntohl(ogm_packet->throughput), ogm_packet->ttl,\r\nhard_iface->net_dev->name,\r\nhard_iface->net_dev->dev_addr);\r\nskb_tmp = skb_clone(skb, GFP_ATOMIC);\r\nif (!skb_tmp) {\r\nbatadv_hardif_put(hard_iface);\r\nbreak;\r\n}\r\nbatadv_v_ogm_send_to_if(skb_tmp, hard_iface);\r\nbatadv_hardif_put(hard_iface);\r\n}\r\nrcu_read_unlock();\r\nconsume_skb(skb);\r\nreschedule:\r\nbatadv_v_ogm_start_timer(bat_priv);\r\nout:\r\nreturn;\r\n}\r\nint batadv_v_ogm_iface_enable(struct batadv_hard_iface *hard_iface)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\r\nbatadv_v_ogm_start_timer(bat_priv);\r\nreturn 0;\r\n}\r\nvoid batadv_v_ogm_primary_iface_set(struct batadv_hard_iface *primary_iface)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(primary_iface->soft_iface);\r\nstruct batadv_ogm2_packet *ogm_packet;\r\nif (!bat_priv->bat_v.ogm_buff)\r\nreturn;\r\nogm_packet = (struct batadv_ogm2_packet *)bat_priv->bat_v.ogm_buff;\r\nether_addr_copy(ogm_packet->orig, primary_iface->net_dev->dev_addr);\r\n}\r\nstatic u32 batadv_v_forward_penalty(struct batadv_priv *bat_priv,\r\nstruct batadv_hard_iface *if_incoming,\r\nstruct batadv_hard_iface *if_outgoing,\r\nu32 throughput)\r\n{\r\nint hop_penalty = atomic_read(&bat_priv->hop_penalty);\r\nint hop_penalty_max = BATADV_TQ_MAX_VALUE;\r\nif (if_outgoing == BATADV_IF_DEFAULT)\r\nreturn throughput;\r\nif ((throughput > 10) &&\r\n(if_incoming == if_outgoing) &&\r\n!(if_incoming->bat_v.flags & BATADV_FULL_DUPLEX))\r\nreturn throughput / 2;\r\nreturn throughput * (hop_penalty_max - hop_penalty) / hop_penalty_max;\r\n}\r\nstatic void batadv_v_ogm_forward(struct batadv_priv *bat_priv,\r\nconst struct batadv_ogm2_packet *ogm_received,\r\nstruct batadv_orig_node *orig_node,\r\nstruct batadv_neigh_node *neigh_node,\r\nstruct batadv_hard_iface *if_incoming,\r\nstruct batadv_hard_iface *if_outgoing)\r\n{\r\nstruct batadv_neigh_ifinfo *neigh_ifinfo = NULL;\r\nstruct batadv_orig_ifinfo *orig_ifinfo = NULL;\r\nstruct batadv_neigh_node *router = NULL;\r\nstruct batadv_ogm2_packet *ogm_forward;\r\nunsigned char *skb_buff;\r\nstruct sk_buff *skb;\r\nsize_t packet_len;\r\nu16 tvlv_len;\r\nif (if_outgoing == BATADV_IF_DEFAULT)\r\ngoto out;\r\norig_ifinfo = batadv_orig_ifinfo_new(orig_node, if_outgoing);\r\nif (!orig_ifinfo)\r\ngoto out;\r\nrouter = batadv_orig_router_get(orig_node, if_outgoing);\r\nif (neigh_node != router)\r\ngoto out;\r\nif (orig_ifinfo->last_seqno_forwarded == ntohl(ogm_received->seqno))\r\ngoto out;\r\norig_ifinfo->last_seqno_forwarded = ntohl(ogm_received->seqno);\r\nif (ogm_received->ttl <= 1) {\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv, "ttl exceeded\n");\r\ngoto out;\r\n}\r\nneigh_ifinfo = batadv_neigh_ifinfo_get(neigh_node, if_outgoing);\r\nif (!neigh_ifinfo)\r\ngoto out;\r\ntvlv_len = ntohs(ogm_received->tvlv_len);\r\npacket_len = BATADV_OGM2_HLEN + tvlv_len;\r\nskb = netdev_alloc_skb_ip_align(if_outgoing->net_dev,\r\nETH_HLEN + packet_len);\r\nif (!skb)\r\ngoto out;\r\nskb_reserve(skb, ETH_HLEN);\r\nskb_buff = skb_put(skb, packet_len);\r\nmemcpy(skb_buff, ogm_received, packet_len);\r\nogm_forward = (struct batadv_ogm2_packet *)skb_buff;\r\nogm_forward->throughput = htonl(neigh_ifinfo->bat_v.throughput);\r\nogm_forward->ttl--;\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Forwarding OGM2 packet on %s: throughput %u, ttl %u, received via %s\n",\r\nif_outgoing->net_dev->name, ntohl(ogm_forward->throughput),\r\nogm_forward->ttl, if_incoming->net_dev->name);\r\nbatadv_v_ogm_send_to_if(skb, if_outgoing);\r\nout:\r\nif (orig_ifinfo)\r\nbatadv_orig_ifinfo_put(orig_ifinfo);\r\nif (router)\r\nbatadv_neigh_node_put(router);\r\nif (neigh_ifinfo)\r\nbatadv_neigh_ifinfo_put(neigh_ifinfo);\r\n}\r\nstatic int batadv_v_ogm_metric_update(struct batadv_priv *bat_priv,\r\nconst struct batadv_ogm2_packet *ogm2,\r\nstruct batadv_orig_node *orig_node,\r\nstruct batadv_neigh_node *neigh_node,\r\nstruct batadv_hard_iface *if_incoming,\r\nstruct batadv_hard_iface *if_outgoing)\r\n{\r\nstruct batadv_orig_ifinfo *orig_ifinfo;\r\nstruct batadv_neigh_ifinfo *neigh_ifinfo = NULL;\r\nbool protection_started = false;\r\nint ret = -EINVAL;\r\nu32 path_throughput;\r\ns32 seq_diff;\r\norig_ifinfo = batadv_orig_ifinfo_new(orig_node, if_outgoing);\r\nif (!orig_ifinfo)\r\ngoto out;\r\nseq_diff = ntohl(ogm2->seqno) - orig_ifinfo->last_real_seqno;\r\nif (!hlist_empty(&orig_node->neigh_list) &&\r\nbatadv_window_protected(bat_priv, seq_diff,\r\nBATADV_OGM_MAX_AGE,\r\n&orig_ifinfo->batman_seqno_reset,\r\n&protection_started)) {\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Drop packet: packet within window protection time from %pM\n",\r\nogm2->orig);\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Last reset: %ld, %ld\n",\r\norig_ifinfo->batman_seqno_reset, jiffies);\r\ngoto out;\r\n}\r\nif ((seq_diff < 0) && !protection_started)\r\ngoto out;\r\nneigh_node->last_seen = jiffies;\r\norig_node->last_seen = jiffies;\r\norig_ifinfo->last_real_seqno = ntohl(ogm2->seqno);\r\norig_ifinfo->last_ttl = ogm2->ttl;\r\nneigh_ifinfo = batadv_neigh_ifinfo_new(neigh_node, if_outgoing);\r\nif (!neigh_ifinfo)\r\ngoto out;\r\npath_throughput = batadv_v_forward_penalty(bat_priv, if_incoming,\r\nif_outgoing,\r\nntohl(ogm2->throughput));\r\nneigh_ifinfo->bat_v.throughput = path_throughput;\r\nneigh_ifinfo->bat_v.last_seqno = ntohl(ogm2->seqno);\r\nneigh_ifinfo->last_ttl = ogm2->ttl;\r\nif (seq_diff > 0 || protection_started)\r\nret = 1;\r\nelse\r\nret = 0;\r\nout:\r\nif (orig_ifinfo)\r\nbatadv_orig_ifinfo_put(orig_ifinfo);\r\nif (neigh_ifinfo)\r\nbatadv_neigh_ifinfo_put(neigh_ifinfo);\r\nreturn ret;\r\n}\r\nstatic bool batadv_v_ogm_route_update(struct batadv_priv *bat_priv,\r\nconst struct ethhdr *ethhdr,\r\nconst struct batadv_ogm2_packet *ogm2,\r\nstruct batadv_orig_node *orig_node,\r\nstruct batadv_neigh_node *neigh_node,\r\nstruct batadv_hard_iface *if_incoming,\r\nstruct batadv_hard_iface *if_outgoing)\r\n{\r\nstruct batadv_neigh_node *router = NULL;\r\nstruct batadv_orig_node *orig_neigh_node;\r\nstruct batadv_neigh_node *orig_neigh_router = NULL;\r\nstruct batadv_neigh_ifinfo *router_ifinfo = NULL, *neigh_ifinfo = NULL;\r\nu32 router_throughput, neigh_throughput;\r\nu32 router_last_seqno;\r\nu32 neigh_last_seqno;\r\ns32 neigh_seq_diff;\r\nbool forward = false;\r\norig_neigh_node = batadv_v_ogm_orig_get(bat_priv, ethhdr->h_source);\r\nif (!orig_neigh_node)\r\ngoto out;\r\norig_neigh_router = batadv_orig_router_get(orig_neigh_node,\r\nif_outgoing);\r\nrouter = batadv_orig_router_get(orig_node, if_outgoing);\r\nif (router && router->orig_node != orig_node && !orig_neigh_router) {\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Drop packet: OGM via unknown neighbor!\n");\r\ngoto out;\r\n}\r\nforward = true;\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Searching and updating originator entry of received packet\n");\r\nif (router == neigh_node)\r\ngoto out;\r\nif (router) {\r\nrouter_ifinfo = batadv_neigh_ifinfo_get(router, if_outgoing);\r\nneigh_ifinfo = batadv_neigh_ifinfo_get(neigh_node, if_outgoing);\r\nif (!router_ifinfo || !neigh_ifinfo)\r\ngoto out;\r\nneigh_last_seqno = neigh_ifinfo->bat_v.last_seqno;\r\nrouter_last_seqno = router_ifinfo->bat_v.last_seqno;\r\nneigh_seq_diff = neigh_last_seqno - router_last_seqno;\r\nrouter_throughput = router_ifinfo->bat_v.throughput;\r\nneigh_throughput = neigh_ifinfo->bat_v.throughput;\r\nif ((neigh_seq_diff < BATADV_OGM_MAX_ORIGDIFF) &&\r\n(router_throughput >= neigh_throughput))\r\ngoto out;\r\n}\r\nbatadv_update_route(bat_priv, orig_node, if_outgoing, neigh_node);\r\nout:\r\nif (router)\r\nbatadv_neigh_node_put(router);\r\nif (orig_neigh_router)\r\nbatadv_neigh_node_put(orig_neigh_router);\r\nif (orig_neigh_node)\r\nbatadv_orig_node_put(orig_neigh_node);\r\nif (router_ifinfo)\r\nbatadv_neigh_ifinfo_put(router_ifinfo);\r\nif (neigh_ifinfo)\r\nbatadv_neigh_ifinfo_put(neigh_ifinfo);\r\nreturn forward;\r\n}\r\nstatic void\r\nbatadv_v_ogm_process_per_outif(struct batadv_priv *bat_priv,\r\nconst struct ethhdr *ethhdr,\r\nconst struct batadv_ogm2_packet *ogm2,\r\nstruct batadv_orig_node *orig_node,\r\nstruct batadv_neigh_node *neigh_node,\r\nstruct batadv_hard_iface *if_incoming,\r\nstruct batadv_hard_iface *if_outgoing)\r\n{\r\nint seqno_age;\r\nbool forward;\r\nseqno_age = batadv_v_ogm_metric_update(bat_priv, ogm2, orig_node,\r\nneigh_node, if_incoming,\r\nif_outgoing);\r\nif (seqno_age < 0)\r\nreturn;\r\nif ((seqno_age > 0) && (if_outgoing == BATADV_IF_DEFAULT))\r\nbatadv_tvlv_containers_process(bat_priv, true, orig_node,\r\nNULL, NULL,\r\n(unsigned char *)(ogm2 + 1),\r\nntohs(ogm2->tvlv_len));\r\nforward = batadv_v_ogm_route_update(bat_priv, ethhdr, ogm2, orig_node,\r\nneigh_node, if_incoming,\r\nif_outgoing);\r\nif (forward)\r\nbatadv_v_ogm_forward(bat_priv, ogm2, orig_node, neigh_node,\r\nif_incoming, if_outgoing);\r\n}\r\nstatic bool batadv_v_ogm_aggr_packet(int buff_pos, int packet_len,\r\n__be16 tvlv_len)\r\n{\r\nint next_buff_pos = 0;\r\nnext_buff_pos += buff_pos + BATADV_OGM2_HLEN;\r\nnext_buff_pos += ntohs(tvlv_len);\r\nreturn (next_buff_pos <= packet_len) &&\r\n(next_buff_pos <= BATADV_MAX_AGGREGATION_BYTES);\r\n}\r\nstatic void batadv_v_ogm_process(const struct sk_buff *skb, int ogm_offset,\r\nstruct batadv_hard_iface *if_incoming)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(if_incoming->soft_iface);\r\nstruct ethhdr *ethhdr;\r\nstruct batadv_orig_node *orig_node = NULL;\r\nstruct batadv_hardif_neigh_node *hardif_neigh = NULL;\r\nstruct batadv_neigh_node *neigh_node = NULL;\r\nstruct batadv_hard_iface *hard_iface;\r\nstruct batadv_ogm2_packet *ogm_packet;\r\nu32 ogm_throughput, link_throughput, path_throughput;\r\nint ret;\r\nethhdr = eth_hdr(skb);\r\nogm_packet = (struct batadv_ogm2_packet *)(skb->data + ogm_offset);\r\nogm_throughput = ntohl(ogm_packet->throughput);\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Received OGM2 packet via NB: %pM, IF: %s [%pM] (from OG: %pM, seqno %u, troughput %u, TTL %u, V %u, tvlv_len %u)\n",\r\nethhdr->h_source, if_incoming->net_dev->name,\r\nif_incoming->net_dev->dev_addr, ogm_packet->orig,\r\nntohl(ogm_packet->seqno), ogm_throughput, ogm_packet->ttl,\r\nogm_packet->version, ntohs(ogm_packet->tvlv_len));\r\nif (ogm_throughput == 0) {\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Drop packet: originator packet with troughput metric of 0\n");\r\nreturn;\r\n}\r\nhardif_neigh = batadv_hardif_neigh_get(if_incoming, ethhdr->h_source);\r\nif (!hardif_neigh) {\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Drop packet: OGM via unknown neighbor!\n");\r\ngoto out;\r\n}\r\norig_node = batadv_v_ogm_orig_get(bat_priv, ogm_packet->orig);\r\nif (!orig_node)\r\nreturn;\r\nneigh_node = batadv_neigh_node_get_or_create(orig_node, if_incoming,\r\nethhdr->h_source);\r\nif (!neigh_node)\r\ngoto out;\r\nlink_throughput = ewma_throughput_read(&hardif_neigh->bat_v.throughput);\r\npath_throughput = min_t(u32, link_throughput, ogm_throughput);\r\nogm_packet->throughput = htonl(path_throughput);\r\nbatadv_v_ogm_process_per_outif(bat_priv, ethhdr, ogm_packet, orig_node,\r\nneigh_node, if_incoming,\r\nBATADV_IF_DEFAULT);\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\r\nif (hard_iface->if_status != BATADV_IF_ACTIVE)\r\ncontinue;\r\nif (hard_iface->soft_iface != bat_priv->soft_iface)\r\ncontinue;\r\nif (!kref_get_unless_zero(&hard_iface->refcount))\r\ncontinue;\r\nret = batadv_hardif_no_broadcast(hard_iface,\r\nogm_packet->orig,\r\nhardif_neigh->orig);\r\nif (ret) {\r\nchar *type;\r\nswitch (ret) {\r\ncase BATADV_HARDIF_BCAST_NORECIPIENT:\r\ntype = "no neighbor";\r\nbreak;\r\ncase BATADV_HARDIF_BCAST_DUPFWD:\r\ntype = "single neighbor is source";\r\nbreak;\r\ncase BATADV_HARDIF_BCAST_DUPORIG:\r\ntype = "single neighbor is originator";\r\nbreak;\r\ndefault:\r\ntype = "unknown";\r\n}\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv, "OGM2 packet from %pM on %s surpressed: %s\n",\r\nogm_packet->orig, hard_iface->net_dev->name,\r\ntype);\r\nbatadv_hardif_put(hard_iface);\r\ncontinue;\r\n}\r\nbatadv_v_ogm_process_per_outif(bat_priv, ethhdr, ogm_packet,\r\norig_node, neigh_node,\r\nif_incoming, hard_iface);\r\nbatadv_hardif_put(hard_iface);\r\n}\r\nrcu_read_unlock();\r\nout:\r\nif (orig_node)\r\nbatadv_orig_node_put(orig_node);\r\nif (neigh_node)\r\nbatadv_neigh_node_put(neigh_node);\r\nif (hardif_neigh)\r\nbatadv_hardif_neigh_put(hardif_neigh);\r\n}\r\nint batadv_v_ogm_packet_recv(struct sk_buff *skb,\r\nstruct batadv_hard_iface *if_incoming)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(if_incoming->soft_iface);\r\nstruct batadv_ogm2_packet *ogm_packet;\r\nstruct ethhdr *ethhdr = eth_hdr(skb);\r\nint ogm_offset;\r\nu8 *packet_pos;\r\nint ret = NET_RX_DROP;\r\nif (strcmp(bat_priv->algo_ops->name, "BATMAN_V") != 0)\r\ngoto free_skb;\r\nif (!batadv_check_management_packet(skb, if_incoming, BATADV_OGM2_HLEN))\r\ngoto free_skb;\r\nif (batadv_is_my_mac(bat_priv, ethhdr->h_source))\r\ngoto free_skb;\r\nogm_packet = (struct batadv_ogm2_packet *)skb->data;\r\nif (batadv_is_my_mac(bat_priv, ogm_packet->orig))\r\ngoto free_skb;\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_MGMT_RX);\r\nbatadv_add_counter(bat_priv, BATADV_CNT_MGMT_RX_BYTES,\r\nskb->len + ETH_HLEN);\r\nogm_offset = 0;\r\nogm_packet = (struct batadv_ogm2_packet *)skb->data;\r\nwhile (batadv_v_ogm_aggr_packet(ogm_offset, skb_headlen(skb),\r\nogm_packet->tvlv_len)) {\r\nbatadv_v_ogm_process(skb, ogm_offset, if_incoming);\r\nogm_offset += BATADV_OGM2_HLEN;\r\nogm_offset += ntohs(ogm_packet->tvlv_len);\r\npacket_pos = skb->data + ogm_offset;\r\nogm_packet = (struct batadv_ogm2_packet *)packet_pos;\r\n}\r\nret = NET_RX_SUCCESS;\r\nfree_skb:\r\nif (ret == NET_RX_SUCCESS)\r\nconsume_skb(skb);\r\nelse\r\nkfree_skb(skb);\r\nreturn ret;\r\n}\r\nint batadv_v_ogm_init(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_ogm2_packet *ogm_packet;\r\nunsigned char *ogm_buff;\r\nu32 random_seqno;\r\nbat_priv->bat_v.ogm_buff_len = BATADV_OGM2_HLEN;\r\nogm_buff = kzalloc(bat_priv->bat_v.ogm_buff_len, GFP_ATOMIC);\r\nif (!ogm_buff)\r\nreturn -ENOMEM;\r\nbat_priv->bat_v.ogm_buff = ogm_buff;\r\nogm_packet = (struct batadv_ogm2_packet *)ogm_buff;\r\nogm_packet->packet_type = BATADV_OGM2;\r\nogm_packet->version = BATADV_COMPAT_VERSION;\r\nogm_packet->ttl = BATADV_TTL;\r\nogm_packet->flags = BATADV_NO_FLAGS;\r\nogm_packet->throughput = htonl(BATADV_THROUGHPUT_MAX_VALUE);\r\nget_random_bytes(&random_seqno, sizeof(random_seqno));\r\natomic_set(&bat_priv->bat_v.ogm_seqno, random_seqno);\r\nINIT_DELAYED_WORK(&bat_priv->bat_v.ogm_wq, batadv_v_ogm_send);\r\nreturn 0;\r\n}\r\nvoid batadv_v_ogm_free(struct batadv_priv *bat_priv)\r\n{\r\ncancel_delayed_work_sync(&bat_priv->bat_v.ogm_wq);\r\nkfree(bat_priv->bat_v.ogm_buff);\r\nbat_priv->bat_v.ogm_buff = NULL;\r\nbat_priv->bat_v.ogm_buff_len = 0;\r\n}
