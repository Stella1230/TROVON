int acpi_numa_get_nid(unsigned int cpu, u64 hwid)\r\n{\r\nint i;\r\nfor (i = 0; i < cpus_in_srat; i++) {\r\nif (hwid == early_node_cpu_hwid[i].cpu_hwid)\r\nreturn early_node_cpu_hwid[i].node_id;\r\n}\r\nreturn NUMA_NO_NODE;\r\n}\r\nvoid __init acpi_numa_gicc_affinity_init(struct acpi_srat_gicc_affinity *pa)\r\n{\r\nint pxm, node;\r\nphys_cpuid_t mpidr;\r\nif (srat_disabled())\r\nreturn;\r\nif (pa->header.length < sizeof(struct acpi_srat_gicc_affinity)) {\r\npr_err("SRAT: Invalid SRAT header length: %d\n",\r\npa->header.length);\r\nbad_srat();\r\nreturn;\r\n}\r\nif (!(pa->flags & ACPI_SRAT_GICC_ENABLED))\r\nreturn;\r\nif (cpus_in_srat >= NR_CPUS) {\r\npr_warn_once("SRAT: cpu_to_node_map[%d] is too small, may not be able to use all cpus\n",\r\nNR_CPUS);\r\nreturn;\r\n}\r\npxm = pa->proximity_domain;\r\nnode = acpi_map_pxm_to_node(pxm);\r\nif (node == NUMA_NO_NODE || node >= MAX_NUMNODES) {\r\npr_err("SRAT: Too many proximity domains %d\n", pxm);\r\nbad_srat();\r\nreturn;\r\n}\r\nmpidr = acpi_map_madt_entry(pa->acpi_processor_uid);\r\nif (mpidr == PHYS_CPUID_INVALID) {\r\npr_err("SRAT: PXM %d with ACPI ID %d has no valid MPIDR in MADT\n",\r\npxm, pa->acpi_processor_uid);\r\nbad_srat();\r\nreturn;\r\n}\r\nearly_node_cpu_hwid[cpus_in_srat].node_id = node;\r\nearly_node_cpu_hwid[cpus_in_srat].cpu_hwid = mpidr;\r\nnode_set(node, numa_nodes_parsed);\r\ncpus_in_srat++;\r\npr_info("SRAT: PXM %d -> MPIDR 0x%Lx -> Node %d\n",\r\npxm, mpidr, node);\r\n}\r\nint __init arm64_acpi_numa_init(void)\r\n{\r\nint ret;\r\nret = acpi_numa_init();\r\nif (ret) {\r\npr_info("Failed to initialise from firmware\n");\r\nreturn ret;\r\n}\r\nreturn srat_disabled() ? -EINVAL : 0;\r\n}
