static ssize_t notrace\r\ndummy_stm_packet(struct stm_data *stm_data, unsigned int master,\r\nunsigned int channel, unsigned int packet, unsigned int flags,\r\nunsigned int size, const unsigned char *payload)\r\n{\r\n#ifdef DEBUG\r\nu64 pl = 0;\r\nif (payload)\r\npl = *(u64 *)payload;\r\nif (size < 8)\r\npl &= (1ull << (size * 8)) - 1;\r\ntrace_printk("[%u:%u] [pkt: %x/%x] (%llx)\n", master, channel,\r\npacket, size, pl);\r\n#endif\r\nreturn size;\r\n}\r\nstatic int dummy_stm_link(struct stm_data *data, unsigned int master,\r\nunsigned int channel)\r\n{\r\nif (fail_mode && (channel & fail_mode))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int dummy_stm_init(void)\r\n{\r\nint i, ret = -ENOMEM;\r\nif (nr_dummies < 0 || nr_dummies > DUMMY_STM_MAX)\r\nreturn -EINVAL;\r\nfor (i = 0; i < nr_dummies; i++) {\r\ndummy_stm[i].name = kasprintf(GFP_KERNEL, "dummy_stm.%d", i);\r\nif (!dummy_stm[i].name)\r\ngoto fail_unregister;\r\ndummy_stm[i].sw_start = 0x0000;\r\ndummy_stm[i].sw_end = 0xffff;\r\ndummy_stm[i].sw_nchannels = 0xffff;\r\ndummy_stm[i].packet = dummy_stm_packet;\r\ndummy_stm[i].link = dummy_stm_link;\r\nret = stm_register_device(NULL, &dummy_stm[i], THIS_MODULE);\r\nif (ret)\r\ngoto fail_free;\r\n}\r\nreturn 0;\r\nfail_unregister:\r\nfor (i--; i >= 0; i--) {\r\nstm_unregister_device(&dummy_stm[i]);\r\nfail_free:\r\nkfree(dummy_stm[i].name);\r\n}\r\nreturn ret;\r\n}\r\nstatic void dummy_stm_exit(void)\r\n{\r\nint i;\r\nfor (i = 0; i < nr_dummies; i++) {\r\nstm_unregister_device(&dummy_stm[i]);\r\nkfree(dummy_stm[i].name);\r\n}\r\n}
