static int stmmac_mdio_read(struct mii_bus *bus, int phyaddr, int phyreg)\r\n{\r\nstruct net_device *ndev = bus->priv;\r\nstruct stmmac_priv *priv = netdev_priv(ndev);\r\nunsigned int mii_address = priv->hw->mii.addr;\r\nunsigned int mii_data = priv->hw->mii.data;\r\nu32 v;\r\nint data;\r\nu32 value = MII_BUSY;\r\nvalue |= (phyaddr << priv->hw->mii.addr_shift)\r\n& priv->hw->mii.addr_mask;\r\nvalue |= (phyreg << priv->hw->mii.reg_shift) & priv->hw->mii.reg_mask;\r\nvalue |= (priv->clk_csr << priv->hw->mii.clk_csr_shift)\r\n& priv->hw->mii.clk_csr_mask;\r\nif (priv->plat->has_gmac4)\r\nvalue |= MII_GMAC4_READ;\r\nif (readl_poll_timeout(priv->ioaddr + mii_address, v, !(v & MII_BUSY),\r\n100, 10000))\r\nreturn -EBUSY;\r\nwritel(value, priv->ioaddr + mii_address);\r\nif (readl_poll_timeout(priv->ioaddr + mii_address, v, !(v & MII_BUSY),\r\n100, 10000))\r\nreturn -EBUSY;\r\ndata = (int)readl(priv->ioaddr + mii_data);\r\nreturn data;\r\n}\r\nstatic int stmmac_mdio_write(struct mii_bus *bus, int phyaddr, int phyreg,\r\nu16 phydata)\r\n{\r\nstruct net_device *ndev = bus->priv;\r\nstruct stmmac_priv *priv = netdev_priv(ndev);\r\nunsigned int mii_address = priv->hw->mii.addr;\r\nunsigned int mii_data = priv->hw->mii.data;\r\nu32 v;\r\nu32 value = MII_BUSY;\r\nvalue |= (phyaddr << priv->hw->mii.addr_shift)\r\n& priv->hw->mii.addr_mask;\r\nvalue |= (phyreg << priv->hw->mii.reg_shift) & priv->hw->mii.reg_mask;\r\nvalue |= (priv->clk_csr << priv->hw->mii.clk_csr_shift)\r\n& priv->hw->mii.clk_csr_mask;\r\nif (priv->plat->has_gmac4)\r\nvalue |= MII_GMAC4_WRITE;\r\nelse\r\nvalue |= MII_WRITE;\r\nif (readl_poll_timeout(priv->ioaddr + mii_address, v, !(v & MII_BUSY),\r\n100, 10000))\r\nreturn -EBUSY;\r\nwritel(phydata, priv->ioaddr + mii_data);\r\nwritel(value, priv->ioaddr + mii_address);\r\nreturn readl_poll_timeout(priv->ioaddr + mii_address, v, !(v & MII_BUSY),\r\n100, 10000);\r\n}\r\nint stmmac_mdio_reset(struct mii_bus *bus)\r\n{\r\n#if defined(CONFIG_STMMAC_PLATFORM)\r\nstruct net_device *ndev = bus->priv;\r\nstruct stmmac_priv *priv = netdev_priv(ndev);\r\nunsigned int mii_address = priv->hw->mii.addr;\r\nstruct stmmac_mdio_bus_data *data = priv->plat->mdio_bus_data;\r\n#ifdef CONFIG_OF\r\nif (priv->device->of_node) {\r\nif (data->reset_gpio < 0) {\r\nstruct device_node *np = priv->device->of_node;\r\nif (!np)\r\nreturn 0;\r\ndata->reset_gpio = of_get_named_gpio(np,\r\n"snps,reset-gpio", 0);\r\nif (data->reset_gpio < 0)\r\nreturn 0;\r\ndata->active_low = of_property_read_bool(np,\r\n"snps,reset-active-low");\r\nof_property_read_u32_array(np,\r\n"snps,reset-delays-us", data->delays, 3);\r\nif (gpio_request(data->reset_gpio, "mdio-reset"))\r\nreturn 0;\r\n}\r\ngpio_direction_output(data->reset_gpio,\r\ndata->active_low ? 1 : 0);\r\nif (data->delays[0])\r\nmsleep(DIV_ROUND_UP(data->delays[0], 1000));\r\ngpio_set_value(data->reset_gpio, data->active_low ? 0 : 1);\r\nif (data->delays[1])\r\nmsleep(DIV_ROUND_UP(data->delays[1], 1000));\r\ngpio_set_value(data->reset_gpio, data->active_low ? 1 : 0);\r\nif (data->delays[2])\r\nmsleep(DIV_ROUND_UP(data->delays[2], 1000));\r\n}\r\n#endif\r\nif (data->phy_reset) {\r\nnetdev_dbg(ndev, "stmmac_mdio_reset: calling phy_reset\n");\r\ndata->phy_reset(priv->plat->bsp_priv);\r\n}\r\nif (!priv->plat->has_gmac4)\r\nwritel(0, priv->ioaddr + mii_address);\r\n#endif\r\nreturn 0;\r\n}\r\nint stmmac_mdio_register(struct net_device *ndev)\r\n{\r\nint err = 0;\r\nstruct mii_bus *new_bus;\r\nstruct stmmac_priv *priv = netdev_priv(ndev);\r\nstruct stmmac_mdio_bus_data *mdio_bus_data = priv->plat->mdio_bus_data;\r\nstruct device_node *mdio_node = priv->plat->mdio_node;\r\nint addr, found;\r\nif (!mdio_bus_data)\r\nreturn 0;\r\nnew_bus = mdiobus_alloc();\r\nif (!new_bus)\r\nreturn -ENOMEM;\r\nif (mdio_bus_data->irqs)\r\nmemcpy(new_bus->irq, mdio_bus_data->irqs, sizeof(new_bus->irq));\r\n#ifdef CONFIG_OF\r\nif (priv->device->of_node)\r\nmdio_bus_data->reset_gpio = -1;\r\n#endif\r\nnew_bus->name = "stmmac";\r\nnew_bus->read = &stmmac_mdio_read;\r\nnew_bus->write = &stmmac_mdio_write;\r\nnew_bus->reset = &stmmac_mdio_reset;\r\nsnprintf(new_bus->id, MII_BUS_ID_SIZE, "%s-%x",\r\nnew_bus->name, priv->plat->bus_id);\r\nnew_bus->priv = ndev;\r\nnew_bus->phy_mask = mdio_bus_data->phy_mask;\r\nnew_bus->parent = priv->device;\r\nif (mdio_node)\r\nerr = of_mdiobus_register(new_bus, mdio_node);\r\nelse\r\nerr = mdiobus_register(new_bus);\r\nif (err != 0) {\r\nnetdev_err(ndev, "Cannot register the MDIO bus\n");\r\ngoto bus_register_fail;\r\n}\r\nif (priv->plat->phy_node || mdio_node)\r\ngoto bus_register_done;\r\nfound = 0;\r\nfor (addr = 0; addr < PHY_MAX_ADDR; addr++) {\r\nstruct phy_device *phydev = mdiobus_get_phy(new_bus, addr);\r\nint act = 0;\r\nchar irq_num[4];\r\nchar *irq_str;\r\nif (!phydev)\r\ncontinue;\r\nif (!mdio_bus_data->irqs &&\r\n(mdio_bus_data->probed_phy_irq > 0)) {\r\nnew_bus->irq[addr] = mdio_bus_data->probed_phy_irq;\r\nphydev->irq = mdio_bus_data->probed_phy_irq;\r\n}\r\nif (priv->plat->phy_addr == -1)\r\npriv->plat->phy_addr = addr;\r\nact = (priv->plat->phy_addr == addr);\r\nswitch (phydev->irq) {\r\ncase PHY_POLL:\r\nirq_str = "POLL";\r\nbreak;\r\ncase PHY_IGNORE_INTERRUPT:\r\nirq_str = "IGNORE";\r\nbreak;\r\ndefault:\r\nsprintf(irq_num, "%d", phydev->irq);\r\nirq_str = irq_num;\r\nbreak;\r\n}\r\nnetdev_info(ndev, "PHY ID %08x at %d IRQ %s (%s)%s\n",\r\nphydev->phy_id, addr, irq_str, phydev_name(phydev),\r\nact ? " active" : "");\r\nfound = 1;\r\n}\r\nif (!found && !mdio_node) {\r\nnetdev_warn(ndev, "No PHY found\n");\r\nmdiobus_unregister(new_bus);\r\nmdiobus_free(new_bus);\r\nreturn -ENODEV;\r\n}\r\nbus_register_done:\r\npriv->mii = new_bus;\r\nreturn 0;\r\nbus_register_fail:\r\nmdiobus_free(new_bus);\r\nreturn err;\r\n}\r\nint stmmac_mdio_unregister(struct net_device *ndev)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(ndev);\r\nif (!priv->mii)\r\nreturn 0;\r\nmdiobus_unregister(priv->mii);\r\npriv->mii->priv = NULL;\r\nmdiobus_free(priv->mii);\r\npriv->mii = NULL;\r\nreturn 0;\r\n}
