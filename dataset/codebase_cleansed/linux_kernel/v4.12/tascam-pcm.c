static void set_buffer_params(struct snd_pcm_hardware *hw)\r\n{\r\nhw->period_bytes_min = 4 * hw->channels_min;\r\nhw->period_bytes_max = hw->period_bytes_min * 2048;\r\nhw->buffer_bytes_max = hw->period_bytes_max * 2;\r\nhw->periods_min = 2;\r\nhw->periods_max = UINT_MAX;\r\n}\r\nstatic int pcm_init_hw_params(struct snd_tscm *tscm,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstatic const struct snd_pcm_hardware hardware = {\r\n.info = SNDRV_PCM_INFO_BATCH |\r\nSNDRV_PCM_INFO_BLOCK_TRANSFER |\r\nSNDRV_PCM_INFO_INTERLEAVED |\r\nSNDRV_PCM_INFO_JOINT_DUPLEX |\r\nSNDRV_PCM_INFO_MMAP |\r\nSNDRV_PCM_INFO_MMAP_VALID,\r\n.rates = SNDRV_PCM_RATE_44100 |\r\nSNDRV_PCM_RATE_48000 |\r\nSNDRV_PCM_RATE_88200 |\r\nSNDRV_PCM_RATE_96000,\r\n.rate_min = 44100,\r\n.rate_max = 96000,\r\n.channels_min = 10,\r\n.channels_max = 18,\r\n};\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct amdtp_stream *stream;\r\nunsigned int pcm_channels;\r\nruntime->hw = hardware;\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\r\nruntime->hw.formats = SNDRV_PCM_FMTBIT_S32;\r\nstream = &tscm->tx_stream;\r\npcm_channels = tscm->spec->pcm_capture_analog_channels;\r\n} else {\r\nruntime->hw.formats =\r\nSNDRV_PCM_FMTBIT_S16 | SNDRV_PCM_FMTBIT_S32;\r\nstream = &tscm->rx_stream;\r\npcm_channels = tscm->spec->pcm_playback_analog_channels;\r\n}\r\nif (tscm->spec->has_adat)\r\npcm_channels += 8;\r\nif (tscm->spec->has_spdif)\r\npcm_channels += 2;\r\nruntime->hw.channels_min = runtime->hw.channels_max = pcm_channels;\r\nset_buffer_params(&runtime->hw);\r\nreturn amdtp_tscm_add_pcm_hw_constraints(stream, runtime);\r\n}\r\nstatic int pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_tscm *tscm = substream->private_data;\r\nenum snd_tscm_clock clock;\r\nunsigned int rate;\r\nint err;\r\nerr = snd_tscm_stream_lock_try(tscm);\r\nif (err < 0)\r\ngoto end;\r\nerr = pcm_init_hw_params(tscm, substream);\r\nif (err < 0)\r\ngoto err_locked;\r\nerr = snd_tscm_stream_get_clock(tscm, &clock);\r\nif (clock != SND_TSCM_CLOCK_INTERNAL ||\r\namdtp_stream_pcm_running(&tscm->rx_stream) ||\r\namdtp_stream_pcm_running(&tscm->tx_stream)) {\r\nerr = snd_tscm_stream_get_rate(tscm, &rate);\r\nif (err < 0)\r\ngoto err_locked;\r\nsubstream->runtime->hw.rate_min = rate;\r\nsubstream->runtime->hw.rate_max = rate;\r\n}\r\nsnd_pcm_set_sync(substream);\r\nend:\r\nreturn err;\r\nerr_locked:\r\nsnd_tscm_stream_lock_release(tscm);\r\nreturn err;\r\n}\r\nstatic int pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_tscm *tscm = substream->private_data;\r\nsnd_tscm_stream_lock_release(tscm);\r\nreturn 0;\r\n}\r\nstatic int pcm_capture_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_tscm *tscm = substream->private_data;\r\nint err;\r\nerr = snd_pcm_lib_alloc_vmalloc_buffer(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (err < 0)\r\nreturn err;\r\nif (substream->runtime->status->state == SNDRV_PCM_STATE_OPEN) {\r\nmutex_lock(&tscm->mutex);\r\ntscm->substreams_counter++;\r\nmutex_unlock(&tscm->mutex);\r\n}\r\namdtp_tscm_set_pcm_format(&tscm->tx_stream, params_format(hw_params));\r\nreturn 0;\r\n}\r\nstatic int pcm_playback_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_tscm *tscm = substream->private_data;\r\nint err;\r\nerr = snd_pcm_lib_alloc_vmalloc_buffer(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (err < 0)\r\nreturn err;\r\nif (substream->runtime->status->state == SNDRV_PCM_STATE_OPEN) {\r\nmutex_lock(&tscm->mutex);\r\ntscm->substreams_counter++;\r\nmutex_unlock(&tscm->mutex);\r\n}\r\namdtp_tscm_set_pcm_format(&tscm->rx_stream, params_format(hw_params));\r\nreturn 0;\r\n}\r\nstatic int pcm_capture_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_tscm *tscm = substream->private_data;\r\nmutex_lock(&tscm->mutex);\r\nif (substream->runtime->status->state != SNDRV_PCM_STATE_OPEN)\r\ntscm->substreams_counter--;\r\nsnd_tscm_stream_stop_duplex(tscm);\r\nmutex_unlock(&tscm->mutex);\r\nreturn snd_pcm_lib_free_vmalloc_buffer(substream);\r\n}\r\nstatic int pcm_playback_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_tscm *tscm = substream->private_data;\r\nmutex_lock(&tscm->mutex);\r\nif (substream->runtime->status->state != SNDRV_PCM_STATE_OPEN)\r\ntscm->substreams_counter--;\r\nsnd_tscm_stream_stop_duplex(tscm);\r\nmutex_unlock(&tscm->mutex);\r\nreturn snd_pcm_lib_free_vmalloc_buffer(substream);\r\n}\r\nstatic int pcm_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_tscm *tscm = substream->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nmutex_lock(&tscm->mutex);\r\nerr = snd_tscm_stream_start_duplex(tscm, runtime->rate);\r\nif (err >= 0)\r\namdtp_stream_pcm_prepare(&tscm->tx_stream);\r\nmutex_unlock(&tscm->mutex);\r\nreturn err;\r\n}\r\nstatic int pcm_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_tscm *tscm = substream->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nmutex_lock(&tscm->mutex);\r\nerr = snd_tscm_stream_start_duplex(tscm, runtime->rate);\r\nif (err >= 0)\r\namdtp_stream_pcm_prepare(&tscm->rx_stream);\r\nmutex_unlock(&tscm->mutex);\r\nreturn err;\r\n}\r\nstatic int pcm_capture_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_tscm *tscm = substream->private_data;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\namdtp_stream_pcm_trigger(&tscm->tx_stream, substream);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\namdtp_stream_pcm_trigger(&tscm->tx_stream, NULL);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcm_playback_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_tscm *tscm = substream->private_data;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\namdtp_stream_pcm_trigger(&tscm->rx_stream, substream);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\namdtp_stream_pcm_trigger(&tscm->rx_stream, NULL);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t pcm_capture_pointer(struct snd_pcm_substream *sbstrm)\r\n{\r\nstruct snd_tscm *tscm = sbstrm->private_data;\r\nreturn amdtp_stream_pcm_pointer(&tscm->tx_stream);\r\n}\r\nstatic snd_pcm_uframes_t pcm_playback_pointer(struct snd_pcm_substream *sbstrm)\r\n{\r\nstruct snd_tscm *tscm = sbstrm->private_data;\r\nreturn amdtp_stream_pcm_pointer(&tscm->rx_stream);\r\n}\r\nint snd_tscm_create_pcm_devices(struct snd_tscm *tscm)\r\n{\r\nstatic const struct snd_pcm_ops capture_ops = {\r\n.open = pcm_open,\r\n.close = pcm_close,\r\n.ioctl = snd_pcm_lib_ioctl,\r\n.hw_params = pcm_capture_hw_params,\r\n.hw_free = pcm_capture_hw_free,\r\n.prepare = pcm_capture_prepare,\r\n.trigger = pcm_capture_trigger,\r\n.pointer = pcm_capture_pointer,\r\n.page = snd_pcm_lib_get_vmalloc_page,\r\n};\r\nstatic const struct snd_pcm_ops playback_ops = {\r\n.open = pcm_open,\r\n.close = pcm_close,\r\n.ioctl = snd_pcm_lib_ioctl,\r\n.hw_params = pcm_playback_hw_params,\r\n.hw_free = pcm_playback_hw_free,\r\n.prepare = pcm_playback_prepare,\r\n.trigger = pcm_playback_trigger,\r\n.pointer = pcm_playback_pointer,\r\n.page = snd_pcm_lib_get_vmalloc_page,\r\n.mmap = snd_pcm_lib_mmap_vmalloc,\r\n};\r\nstruct snd_pcm *pcm;\r\nint err;\r\nerr = snd_pcm_new(tscm->card, tscm->card->driver, 0, 1, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\npcm->private_data = tscm;\r\nsnprintf(pcm->name, sizeof(pcm->name),\r\n"%s PCM", tscm->card->shortname);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &capture_ops);\r\nreturn 0;\r\n}
