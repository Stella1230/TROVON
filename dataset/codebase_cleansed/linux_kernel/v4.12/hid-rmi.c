static int rmi_set_page(struct hid_device *hdev, u8 page)\r\n{\r\nstruct rmi_data *data = hid_get_drvdata(hdev);\r\nint retval;\r\ndata->writeReport[0] = RMI_WRITE_REPORT_ID;\r\ndata->writeReport[1] = 1;\r\ndata->writeReport[2] = 0xFF;\r\ndata->writeReport[4] = page;\r\nretval = rmi_write_report(hdev, data->writeReport,\r\ndata->output_report_size);\r\nif (retval != data->output_report_size) {\r\ndev_err(&hdev->dev,\r\n"%s: set page failed: %d.", __func__, retval);\r\nreturn retval;\r\n}\r\ndata->page = page;\r\nreturn 0;\r\n}\r\nstatic int rmi_set_mode(struct hid_device *hdev, u8 mode)\r\n{\r\nint ret;\r\nconst u8 txbuf[2] = {RMI_SET_RMI_MODE_REPORT_ID, mode};\r\nu8 *buf;\r\nbuf = kmemdup(txbuf, sizeof(txbuf), GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = hid_hw_raw_request(hdev, RMI_SET_RMI_MODE_REPORT_ID, buf,\r\nsizeof(txbuf), HID_FEATURE_REPORT, HID_REQ_SET_REPORT);\r\nkfree(buf);\r\nif (ret < 0) {\r\ndev_err(&hdev->dev, "unable to set rmi mode to %d (%d)\n", mode,\r\nret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_write_report(struct hid_device *hdev, u8 *report, int len)\r\n{\r\nint ret;\r\nret = hid_hw_output_report(hdev, (void *)report, len);\r\nif (ret < 0) {\r\ndev_err(&hdev->dev, "failed to write hid report (%d)\n", ret);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rmi_hid_read_block(struct rmi_transport_dev *xport, u16 addr,\r\nvoid *buf, size_t len)\r\n{\r\nstruct rmi_data *data = container_of(xport, struct rmi_data, xport);\r\nstruct hid_device *hdev = data->hdev;\r\nint ret;\r\nint bytes_read;\r\nint bytes_needed;\r\nint retries;\r\nint read_input_count;\r\nmutex_lock(&data->page_mutex);\r\nif (RMI_PAGE(addr) != data->page) {\r\nret = rmi_set_page(hdev, RMI_PAGE(addr));\r\nif (ret < 0)\r\ngoto exit;\r\n}\r\nfor (retries = 5; retries > 0; retries--) {\r\ndata->writeReport[0] = RMI_READ_ADDR_REPORT_ID;\r\ndata->writeReport[1] = 0;\r\ndata->writeReport[2] = addr & 0xFF;\r\ndata->writeReport[3] = (addr >> 8) & 0xFF;\r\ndata->writeReport[4] = len & 0xFF;\r\ndata->writeReport[5] = (len >> 8) & 0xFF;\r\nset_bit(RMI_READ_REQUEST_PENDING, &data->flags);\r\nret = rmi_write_report(hdev, data->writeReport,\r\ndata->output_report_size);\r\nif (ret != data->output_report_size) {\r\nclear_bit(RMI_READ_REQUEST_PENDING, &data->flags);\r\ndev_err(&hdev->dev,\r\n"failed to write request output report (%d)\n",\r\nret);\r\ngoto exit;\r\n}\r\nbytes_read = 0;\r\nbytes_needed = len;\r\nwhile (bytes_read < len) {\r\nif (!wait_event_timeout(data->wait,\r\ntest_bit(RMI_READ_DATA_PENDING, &data->flags),\r\nmsecs_to_jiffies(1000))) {\r\nhid_warn(hdev, "%s: timeout elapsed\n",\r\n__func__);\r\nret = -EAGAIN;\r\nbreak;\r\n}\r\nread_input_count = data->readReport[1];\r\nmemcpy(buf + bytes_read, &data->readReport[2],\r\nread_input_count < bytes_needed ?\r\nread_input_count : bytes_needed);\r\nbytes_read += read_input_count;\r\nbytes_needed -= read_input_count;\r\nclear_bit(RMI_READ_DATA_PENDING, &data->flags);\r\n}\r\nif (ret >= 0) {\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nexit:\r\nclear_bit(RMI_READ_REQUEST_PENDING, &data->flags);\r\nmutex_unlock(&data->page_mutex);\r\nreturn ret;\r\n}\r\nstatic int rmi_hid_write_block(struct rmi_transport_dev *xport, u16 addr,\r\nconst void *buf, size_t len)\r\n{\r\nstruct rmi_data *data = container_of(xport, struct rmi_data, xport);\r\nstruct hid_device *hdev = data->hdev;\r\nint ret;\r\nmutex_lock(&data->page_mutex);\r\nif (RMI_PAGE(addr) != data->page) {\r\nret = rmi_set_page(hdev, RMI_PAGE(addr));\r\nif (ret < 0)\r\ngoto exit;\r\n}\r\ndata->writeReport[0] = RMI_WRITE_REPORT_ID;\r\ndata->writeReport[1] = len;\r\ndata->writeReport[2] = addr & 0xFF;\r\ndata->writeReport[3] = (addr >> 8) & 0xFF;\r\nmemcpy(&data->writeReport[4], buf, len);\r\nret = rmi_write_report(hdev, data->writeReport,\r\ndata->output_report_size);\r\nif (ret < 0) {\r\ndev_err(&hdev->dev,\r\n"failed to write request output report (%d)\n",\r\nret);\r\ngoto exit;\r\n}\r\nret = 0;\r\nexit:\r\nmutex_unlock(&data->page_mutex);\r\nreturn ret;\r\n}\r\nstatic int rmi_reset_attn_mode(struct hid_device *hdev)\r\n{\r\nstruct rmi_data *data = hid_get_drvdata(hdev);\r\nstruct rmi_device *rmi_dev = data->xport.rmi_dev;\r\nint ret;\r\nret = rmi_set_mode(hdev, RMI_MODE_ATTN_REPORTS);\r\nif (ret)\r\nreturn ret;\r\nif (test_bit(RMI_STARTED, &data->flags))\r\nret = rmi_dev->driver->reset_handler(rmi_dev);\r\nreturn ret;\r\n}\r\nstatic void rmi_reset_work(struct work_struct *work)\r\n{\r\nstruct rmi_data *hdata = container_of(work, struct rmi_data,\r\nreset_work);\r\nrmi_reset_attn_mode(hdata->hdev);\r\n}\r\nstatic int rmi_input_event(struct hid_device *hdev, u8 *data, int size)\r\n{\r\nstruct rmi_data *hdata = hid_get_drvdata(hdev);\r\nstruct rmi_device *rmi_dev = hdata->xport.rmi_dev;\r\nunsigned long flags;\r\nif (!(test_bit(RMI_STARTED, &hdata->flags)))\r\nreturn 0;\r\nlocal_irq_save(flags);\r\nrmi_set_attn_data(rmi_dev, data[1], &data[2], size - 2);\r\ngeneric_handle_irq(hdata->rmi_irq);\r\nlocal_irq_restore(flags);\r\nreturn 1;\r\n}\r\nstatic int rmi_read_data_event(struct hid_device *hdev, u8 *data, int size)\r\n{\r\nstruct rmi_data *hdata = hid_get_drvdata(hdev);\r\nif (!test_bit(RMI_READ_REQUEST_PENDING, &hdata->flags)) {\r\nhid_dbg(hdev, "no read request pending\n");\r\nreturn 0;\r\n}\r\nmemcpy(hdata->readReport, data, size < hdata->input_report_size ?\r\nsize : hdata->input_report_size);\r\nset_bit(RMI_READ_DATA_PENDING, &hdata->flags);\r\nwake_up(&hdata->wait);\r\nreturn 1;\r\n}\r\nstatic int rmi_check_sanity(struct hid_device *hdev, u8 *data, int size)\r\n{\r\nint valid_size = size;\r\nwhile ((data[valid_size - 1] == 0xff) && valid_size > 0)\r\nvalid_size--;\r\nreturn valid_size;\r\n}\r\nstatic int rmi_raw_event(struct hid_device *hdev,\r\nstruct hid_report *report, u8 *data, int size)\r\n{\r\nsize = rmi_check_sanity(hdev, data, size);\r\nif (size < 2)\r\nreturn 0;\r\nswitch (data[0]) {\r\ncase RMI_READ_DATA_REPORT_ID:\r\nreturn rmi_read_data_event(hdev, data, size);\r\ncase RMI_ATTN_REPORT_ID:\r\nreturn rmi_input_event(hdev, data, size);\r\ndefault:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_event(struct hid_device *hdev, struct hid_field *field,\r\nstruct hid_usage *usage, __s32 value)\r\n{\r\nstruct rmi_data *data = hid_get_drvdata(hdev);\r\nif ((data->device_flags & RMI_DEVICE) &&\r\n(field->application == HID_GD_POINTER ||\r\nfield->application == HID_GD_MOUSE)) {\r\nif (data->device_flags & RMI_DEVICE_HAS_PHYS_BUTTONS) {\r\nif ((usage->hid & HID_USAGE_PAGE) == HID_UP_BUTTON)\r\nreturn 0;\r\nif ((usage->hid == HID_GD_X || usage->hid == HID_GD_Y)\r\n&& !value)\r\nreturn 1;\r\n}\r\nschedule_work(&data->reset_work);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_suspend(struct hid_device *hdev, pm_message_t message)\r\n{\r\nstruct rmi_data *data = hid_get_drvdata(hdev);\r\nstruct rmi_device *rmi_dev = data->xport.rmi_dev;\r\nint ret;\r\nif (!(data->device_flags & RMI_DEVICE))\r\nreturn 0;\r\nret = rmi_driver_suspend(rmi_dev, false);\r\nif (ret) {\r\nhid_warn(hdev, "Failed to suspend device: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_post_resume(struct hid_device *hdev)\r\n{\r\nstruct rmi_data *data = hid_get_drvdata(hdev);\r\nstruct rmi_device *rmi_dev = data->xport.rmi_dev;\r\nint ret;\r\nif (!(data->device_flags & RMI_DEVICE))\r\nreturn 0;\r\nret = rmi_reset_attn_mode(hdev);\r\nif (ret)\r\nreturn ret;\r\nret = rmi_driver_resume(rmi_dev, false);\r\nif (ret) {\r\nhid_warn(hdev, "Failed to resume device: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_hid_reset(struct rmi_transport_dev *xport, u16 reset_addr)\r\n{\r\nstruct rmi_data *data = container_of(xport, struct rmi_data, xport);\r\nstruct hid_device *hdev = data->hdev;\r\nreturn rmi_reset_attn_mode(hdev);\r\n}\r\nstatic int rmi_input_configured(struct hid_device *hdev, struct hid_input *hi)\r\n{\r\nstruct rmi_data *data = hid_get_drvdata(hdev);\r\nstruct input_dev *input = hi->input;\r\nint ret = 0;\r\nif (!(data->device_flags & RMI_DEVICE))\r\nreturn 0;\r\ndata->xport.input = input;\r\nhid_dbg(hdev, "Opening low level driver\n");\r\nret = hid_hw_open(hdev);\r\nif (ret)\r\nreturn ret;\r\nhid_device_io_start(hdev);\r\nret = rmi_set_mode(hdev, RMI_MODE_ATTN_REPORTS);\r\nif (ret < 0) {\r\ndev_err(&hdev->dev, "failed to set rmi mode\n");\r\ngoto exit;\r\n}\r\nret = rmi_set_page(hdev, 0);\r\nif (ret < 0) {\r\ndev_err(&hdev->dev, "failed to set page select to 0.\n");\r\ngoto exit;\r\n}\r\nret = rmi_register_transport_device(&data->xport);\r\nif (ret < 0) {\r\ndev_err(&hdev->dev, "failed to register transport driver\n");\r\ngoto exit;\r\n}\r\nset_bit(RMI_STARTED, &data->flags);\r\nexit:\r\nhid_device_io_stop(hdev);\r\nhid_hw_close(hdev);\r\nreturn ret;\r\n}\r\nstatic int rmi_input_mapping(struct hid_device *hdev,\r\nstruct hid_input *hi, struct hid_field *field,\r\nstruct hid_usage *usage, unsigned long **bit, int *max)\r\n{\r\nstruct rmi_data *data = hid_get_drvdata(hdev);\r\nif (data->device_flags & RMI_DEVICE) {\r\nif ((data->device_flags & RMI_DEVICE_HAS_PHYS_BUTTONS) &&\r\n((usage->hid & HID_USAGE_PAGE) == HID_UP_BUTTON))\r\nreturn 0;\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_check_valid_report_id(struct hid_device *hdev, unsigned type,\r\nunsigned id, struct hid_report **report)\r\n{\r\nint i;\r\n*report = hdev->report_enum[type].report_id_hash[id];\r\nif (*report) {\r\nfor (i = 0; i < (*report)->maxfield; i++) {\r\nunsigned app = (*report)->field[i]->application;\r\nif ((app & HID_USAGE_PAGE) >= HID_UP_MSVENDOR)\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void rmi_irq_teardown(void *data)\r\n{\r\nstruct rmi_data *hdata = data;\r\nstruct irq_domain *domain = hdata->domain;\r\nif (!domain)\r\nreturn;\r\nirq_dispose_mapping(irq_find_mapping(domain, 0));\r\nirq_domain_remove(domain);\r\nhdata->domain = NULL;\r\nhdata->rmi_irq = 0;\r\n}\r\nstatic int rmi_irq_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hw_irq_num)\r\n{\r\nirq_set_chip_and_handler(virq, &dummy_irq_chip, handle_simple_irq);\r\nreturn 0;\r\n}\r\nstatic int rmi_setup_irq_domain(struct hid_device *hdev)\r\n{\r\nstruct rmi_data *hdata = hid_get_drvdata(hdev);\r\nint ret;\r\nhdata->domain = irq_domain_create_linear(hdev->dev.fwnode, 1,\r\n&rmi_irq_ops, hdata);\r\nif (!hdata->domain)\r\nreturn -ENOMEM;\r\nret = devm_add_action_or_reset(&hdev->dev, &rmi_irq_teardown, hdata);\r\nif (ret)\r\nreturn ret;\r\nhdata->rmi_irq = irq_create_mapping(hdata->domain, 0);\r\nif (hdata->rmi_irq <= 0) {\r\nhid_err(hdev, "Can't allocate an IRQ\n");\r\nreturn hdata->rmi_irq < 0 ? hdata->rmi_irq : -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_probe(struct hid_device *hdev, const struct hid_device_id *id)\r\n{\r\nstruct rmi_data *data = NULL;\r\nint ret;\r\nsize_t alloc_size;\r\nstruct hid_report *input_report;\r\nstruct hid_report *output_report;\r\nstruct hid_report *feature_report;\r\ndata = devm_kzalloc(&hdev->dev, sizeof(struct rmi_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nINIT_WORK(&data->reset_work, rmi_reset_work);\r\ndata->hdev = hdev;\r\nhid_set_drvdata(hdev, data);\r\nhdev->quirks |= HID_QUIRK_NO_INIT_REPORTS;\r\nret = hid_parse(hdev);\r\nif (ret) {\r\nhid_err(hdev, "parse failed\n");\r\nreturn ret;\r\n}\r\nif (id->driver_data)\r\ndata->device_flags = id->driver_data;\r\nif (!rmi_check_valid_report_id(hdev, HID_FEATURE_REPORT,\r\nRMI_SET_RMI_MODE_REPORT_ID, &feature_report)) {\r\nhid_dbg(hdev, "device does not have set mode feature report\n");\r\ngoto start;\r\n}\r\nif (!rmi_check_valid_report_id(hdev, HID_INPUT_REPORT,\r\nRMI_ATTN_REPORT_ID, &input_report)) {\r\nhid_dbg(hdev, "device does not have attention input report\n");\r\ngoto start;\r\n}\r\ndata->input_report_size = hid_report_len(input_report);\r\nif (!rmi_check_valid_report_id(hdev, HID_OUTPUT_REPORT,\r\nRMI_WRITE_REPORT_ID, &output_report)) {\r\nhid_dbg(hdev,\r\n"device does not have rmi write output report\n");\r\ngoto start;\r\n}\r\ndata->output_report_size = hid_report_len(output_report);\r\ndata->device_flags |= RMI_DEVICE;\r\nalloc_size = data->output_report_size + data->input_report_size;\r\ndata->writeReport = devm_kzalloc(&hdev->dev, alloc_size, GFP_KERNEL);\r\nif (!data->writeReport) {\r\nhid_err(hdev, "failed to allocate buffer for HID reports\n");\r\nreturn -ENOMEM;\r\n}\r\ndata->readReport = data->writeReport + data->output_report_size;\r\ninit_waitqueue_head(&data->wait);\r\nmutex_init(&data->page_mutex);\r\nret = rmi_setup_irq_domain(hdev);\r\nif (ret) {\r\nhid_err(hdev, "failed to allocate IRQ domain\n");\r\nreturn ret;\r\n}\r\nif (data->device_flags & RMI_DEVICE_HAS_PHYS_BUTTONS)\r\nrmi_hid_pdata.f30_data.disable = true;\r\ndata->xport.dev = hdev->dev.parent;\r\ndata->xport.pdata = rmi_hid_pdata;\r\ndata->xport.pdata.irq = data->rmi_irq;\r\ndata->xport.proto_name = "hid";\r\ndata->xport.ops = &hid_rmi_ops;\r\nstart:\r\nret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\r\nif (ret) {\r\nhid_err(hdev, "hw start failed\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rmi_remove(struct hid_device *hdev)\r\n{\r\nstruct rmi_data *hdata = hid_get_drvdata(hdev);\r\nclear_bit(RMI_STARTED, &hdata->flags);\r\ncancel_work_sync(&hdata->reset_work);\r\nrmi_unregister_transport_device(&hdata->xport);\r\nhid_hw_stop(hdev);\r\n}
