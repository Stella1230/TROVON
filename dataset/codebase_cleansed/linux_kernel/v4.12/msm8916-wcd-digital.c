static int msm8916_wcd_digital_enable_interpolator(\r\nstruct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol,\r\nint event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nusleep_range(10000, 10100);\r\nsnd_soc_write(codec, rx_gain_reg[w->shift],\r\nsnd_soc_read(codec, rx_gain_reg[w->shift]));\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int msm8916_wcd_digital_enable_dec(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol,\r\nint event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nunsigned int decimator = w->shift + 1;\r\nu16 dec_reset_reg, tx_vol_ctl_reg, tx_mux_ctl_reg;\r\nu8 dec_hpf_cut_of_freq;\r\ndec_reset_reg = LPASS_CDC_CLK_TX_RESET_B1_CTL;\r\ntx_vol_ctl_reg = LPASS_CDC_TX1_VOL_CTL_CFG + 32 * (decimator - 1);\r\ntx_mux_ctl_reg = LPASS_CDC_TX1_MUX_CTL + 32 * (decimator - 1);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nsnd_soc_update_bits(codec, tx_vol_ctl_reg,\r\nTX_VOL_CTL_CFG_MUTE_EN_MASK,\r\nTX_VOL_CTL_CFG_MUTE_EN_ENABLE);\r\ndec_hpf_cut_of_freq = snd_soc_read(codec, tx_mux_ctl_reg) &\r\nTX_MUX_CTL_CUT_OFF_FREQ_MASK;\r\ndec_hpf_cut_of_freq >>= TX_MUX_CTL_CUT_OFF_FREQ_SHIFT;\r\nif (dec_hpf_cut_of_freq != TX_MUX_CTL_CF_NEG_3DB_150HZ) {\r\nsnd_soc_update_bits(codec, tx_mux_ctl_reg,\r\nTX_MUX_CTL_CUT_OFF_FREQ_MASK,\r\nTX_MUX_CTL_CF_NEG_3DB_150HZ);\r\n}\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMU:\r\nsnd_soc_update_bits(codec, tx_mux_ctl_reg,\r\nTX_MUX_CTL_HPF_BP_SEL_MASK,\r\nTX_MUX_CTL_HPF_BP_SEL_NO_BYPASS);\r\nsnd_soc_write(codec, tx_gain_reg[w->shift],\r\nsnd_soc_read(codec, tx_gain_reg[w->shift]));\r\nsnd_soc_update_bits(codec, tx_vol_ctl_reg,\r\nTX_VOL_CTL_CFG_MUTE_EN_MASK, 0);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nsnd_soc_update_bits(codec, tx_vol_ctl_reg,\r\nTX_VOL_CTL_CFG_MUTE_EN_MASK,\r\nTX_VOL_CTL_CFG_MUTE_EN_ENABLE);\r\nsnd_soc_update_bits(codec, tx_mux_ctl_reg,\r\nTX_MUX_CTL_HPF_BP_SEL_MASK,\r\nTX_MUX_CTL_HPF_BP_SEL_BYPASS);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nsnd_soc_update_bits(codec, dec_reset_reg, 1 << w->shift,\r\n1 << w->shift);\r\nsnd_soc_update_bits(codec, dec_reset_reg, 1 << w->shift, 0x0);\r\nsnd_soc_update_bits(codec, tx_mux_ctl_reg,\r\nTX_MUX_CTL_HPF_BP_SEL_MASK,\r\nTX_MUX_CTL_HPF_BP_SEL_BYPASS);\r\nsnd_soc_update_bits(codec, tx_vol_ctl_reg,\r\nTX_VOL_CTL_CFG_MUTE_EN_MASK, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int msm8916_wcd_digital_enable_dmic(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol,\r\nint event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nunsigned int dmic;\r\nint ret;\r\nchar *dmic_num = strpbrk(w->name, "12");\r\nif (dmic_num == NULL) {\r\ndev_err(codec->dev, "Invalid DMIC\n");\r\nreturn -EINVAL;\r\n}\r\nret = kstrtouint(dmic_num, 10, &dmic);\r\nif (ret < 0 || dmic > 2) {\r\ndev_err(codec->dev, "Invalid DMIC line on the codec\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nsnd_soc_update_bits(codec, LPASS_CDC_CLK_DMIC_B1_CTL,\r\nDMIC_B1_CTL_DMIC0_CLK_SEL_MASK,\r\nDMIC_B1_CTL_DMIC0_CLK_SEL_DIV3);\r\nswitch (dmic) {\r\ncase 1:\r\nsnd_soc_update_bits(codec, LPASS_CDC_TX1_DMIC_CTL,\r\nTXN_DMIC_CTL_CLK_SEL_MASK,\r\nTXN_DMIC_CTL_CLK_SEL_DIV3);\r\nbreak;\r\ncase 2:\r\nsnd_soc_update_bits(codec, LPASS_CDC_TX2_DMIC_CTL,\r\nTXN_DMIC_CTL_CLK_SEL_MASK,\r\nTXN_DMIC_CTL_CLK_SEL_DIV3);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int msm8916_wcd_digital_get_clks(struct platform_device *pdev,\r\nstruct msm8916_wcd_digital_priv *priv)\r\n{\r\nstruct device *dev = &pdev->dev;\r\npriv->ahbclk = devm_clk_get(dev, "ahbix-clk");\r\nif (IS_ERR(priv->ahbclk)) {\r\ndev_err(dev, "failed to get ahbix clk\n");\r\nreturn PTR_ERR(priv->ahbclk);\r\n}\r\npriv->mclk = devm_clk_get(dev, "mclk");\r\nif (IS_ERR(priv->mclk)) {\r\ndev_err(dev, "failed to get mclk\n");\r\nreturn PTR_ERR(priv->mclk);\r\n}\r\nreturn 0;\r\n}\r\nstatic int msm8916_wcd_digital_codec_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct msm8916_wcd_digital_priv *priv = dev_get_drvdata(codec->dev);\r\nsnd_soc_codec_set_drvdata(codec, priv);\r\nreturn 0;\r\n}\r\nstatic int msm8916_wcd_digital_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nu8 tx_fs_rate;\r\nu8 rx_fs_rate;\r\nswitch (params_rate(params)) {\r\ncase 8000:\r\ntx_fs_rate = TX_I2S_CTL_TX_I2S_FS_RATE_F_8_KHZ;\r\nrx_fs_rate = RX_I2S_CTL_RX_I2S_FS_RATE_F_8_KHZ;\r\nbreak;\r\ncase 16000:\r\ntx_fs_rate = TX_I2S_CTL_TX_I2S_FS_RATE_F_16_KHZ;\r\nrx_fs_rate = RX_I2S_CTL_RX_I2S_FS_RATE_F_16_KHZ;\r\nbreak;\r\ncase 32000:\r\ntx_fs_rate = TX_I2S_CTL_TX_I2S_FS_RATE_F_32_KHZ;\r\nrx_fs_rate = RX_I2S_CTL_RX_I2S_FS_RATE_F_32_KHZ;\r\nbreak;\r\ncase 48000:\r\ntx_fs_rate = TX_I2S_CTL_TX_I2S_FS_RATE_F_48_KHZ;\r\nrx_fs_rate = RX_I2S_CTL_RX_I2S_FS_RATE_F_48_KHZ;\r\nbreak;\r\ndefault:\r\ndev_err(dai->codec->dev, "Invalid sampling rate %d\n",\r\nparams_rate(params));\r\nreturn -EINVAL;\r\n}\r\nswitch (substream->stream) {\r\ncase SNDRV_PCM_STREAM_CAPTURE:\r\nsnd_soc_update_bits(dai->codec, LPASS_CDC_CLK_TX_I2S_CTL,\r\nTX_I2S_CTL_TX_I2S_FS_RATE_MASK, tx_fs_rate);\r\nbreak;\r\ncase SNDRV_PCM_STREAM_PLAYBACK:\r\nsnd_soc_update_bits(dai->codec, LPASS_CDC_CLK_RX_I2S_CTL,\r\nRX_I2S_CTL_RX_I2S_FS_RATE_MASK, rx_fs_rate);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nsnd_soc_update_bits(dai->codec, LPASS_CDC_CLK_TX_I2S_CTL,\r\nTX_I2S_CTL_TX_I2S_MODE_MASK,\r\nTX_I2S_CTL_TX_I2S_MODE_16);\r\nsnd_soc_update_bits(dai->codec, LPASS_CDC_CLK_RX_I2S_CTL,\r\nRX_I2S_CTL_RX_I2S_MODE_MASK,\r\nRX_I2S_CTL_RX_I2S_MODE_16);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nsnd_soc_update_bits(dai->codec, LPASS_CDC_CLK_TX_I2S_CTL,\r\nTX_I2S_CTL_TX_I2S_MODE_MASK,\r\nTX_I2S_CTL_TX_I2S_MODE_32);\r\nsnd_soc_update_bits(dai->codec, LPASS_CDC_CLK_RX_I2S_CTL,\r\nRX_I2S_CTL_RX_I2S_MODE_MASK,\r\nRX_I2S_CTL_RX_I2S_MODE_32);\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "%s: wrong format selected\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int msm8916_wcd_digital_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct msm8916_wcd_digital_priv *msm8916_wcd;\r\nunsigned long mclk_rate;\r\nmsm8916_wcd = snd_soc_codec_get_drvdata(codec);\r\nsnd_soc_update_bits(codec, LPASS_CDC_CLK_MCLK_CTL,\r\nMCLK_CTL_MCLK_EN_MASK,\r\nMCLK_CTL_MCLK_EN_ENABLE);\r\nsnd_soc_update_bits(codec, LPASS_CDC_CLK_PDM_CTL,\r\nLPASS_CDC_CLK_PDM_CTL_PDM_CLK_SEL_MASK,\r\nLPASS_CDC_CLK_PDM_CTL_PDM_CLK_SEL_FB);\r\nmclk_rate = clk_get_rate(msm8916_wcd->mclk);\r\nswitch (mclk_rate) {\r\ncase 12288000:\r\nsnd_soc_update_bits(codec, LPASS_CDC_TOP_CTL,\r\nTOP_CTL_DIG_MCLK_FREQ_MASK,\r\nTOP_CTL_DIG_MCLK_FREQ_F_12_288MHZ);\r\nbreak;\r\ncase 9600000:\r\nsnd_soc_update_bits(codec, LPASS_CDC_TOP_CTL,\r\nTOP_CTL_DIG_MCLK_FREQ_MASK,\r\nTOP_CTL_DIG_MCLK_FREQ_F_9_6MHZ);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid mclk rate %ld\n", mclk_rate);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void msm8916_wcd_digital_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nsnd_soc_update_bits(dai->codec, LPASS_CDC_CLK_PDM_CTL,\r\nLPASS_CDC_CLK_PDM_CTL_PDM_CLK_SEL_MASK, 0);\r\n}\r\nstatic int msm8916_wcd_digital_probe(struct platform_device *pdev)\r\n{\r\nstruct msm8916_wcd_digital_priv *priv;\r\nstruct device *dev = &pdev->dev;\r\nvoid __iomem *base;\r\nstruct resource *mem_res;\r\nstruct regmap *digital_map;\r\nint ret;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nmem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, mem_res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\ndigital_map =\r\ndevm_regmap_init_mmio(&pdev->dev, base,\r\n&msm8916_codec_regmap_config);\r\nif (IS_ERR(digital_map))\r\nreturn PTR_ERR(digital_map);\r\nret = msm8916_wcd_digital_get_clks(pdev, priv);\r\nif (ret < 0)\r\nreturn ret;\r\nret = clk_prepare_enable(priv->ahbclk);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to enable ahbclk %d\n", ret);\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(priv->mclk);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to enable mclk %d\n", ret);\r\nreturn ret;\r\n}\r\ndev_set_drvdata(dev, priv);\r\nreturn snd_soc_register_codec(dev, &msm8916_wcd_digital,\r\nmsm8916_wcd_digital_dai,\r\nARRAY_SIZE(msm8916_wcd_digital_dai));\r\n}\r\nstatic int msm8916_wcd_digital_remove(struct platform_device *pdev)\r\n{\r\nstruct msm8916_wcd_digital_priv *priv = dev_get_drvdata(&pdev->dev);\r\nsnd_soc_unregister_codec(&pdev->dev);\r\nclk_disable_unprepare(priv->mclk);\r\nclk_disable_unprepare(priv->ahbclk);\r\nreturn 0;\r\n}
