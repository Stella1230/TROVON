static int mtk_regmap_update_bits(struct regmap *map, int reg,\r\nunsigned int mask,\r\nunsigned int val)\r\n{\r\nif (reg < 0)\r\nreturn 0;\r\nreturn regmap_update_bits(map, reg, mask, val);\r\n}\r\nstatic int mtk_regmap_write(struct regmap *map, int reg, unsigned int val)\r\n{\r\nif (reg < 0)\r\nreturn 0;\r\nreturn regmap_write(map, reg, val);\r\n}\r\nint mtk_afe_fe_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_base_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint memif_num = rtd->cpu_dai->id;\r\nstruct mtk_base_afe_memif *memif = &afe->memif[memif_num];\r\nconst struct snd_pcm_hardware *mtk_afe_hardware = afe->mtk_afe_hardware;\r\nint ret;\r\nmemif->substream = substream;\r\nsnd_pcm_hw_constraint_step(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_BUFFER_BYTES, 16);\r\nmtk_regmap_update_bits(afe->regmap, memif->data->agent_disable_reg,\r\n1 << memif->data->agent_disable_shift,\r\n0 << memif->data->agent_disable_shift);\r\nsnd_soc_set_runtime_hwparams(substream, mtk_afe_hardware);\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\r\nint periods_max = mtk_afe_hardware->periods_max;\r\nret = snd_pcm_hw_constraint_minmax(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS,\r\n3, periods_max);\r\nif (ret < 0) {\r\ndev_err(afe->dev, "hw_constraint_minmax failed\n");\r\nreturn ret;\r\n}\r\n}\r\nret = snd_pcm_hw_constraint_integer(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\nif (ret < 0)\r\ndev_err(afe->dev, "snd_pcm_hw_constraint_integer failed\n");\r\nif (memif->irq_usage < 0) {\r\nint irq_id = mtk_dynamic_irq_acquire(afe);\r\nif (irq_id != afe->irqs_size) {\r\nmemif->irq_usage = irq_id;\r\n} else {\r\ndev_err(afe->dev, "%s() error: no more asys irq\n",\r\n__func__);\r\nret = -EBUSY;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nvoid mtk_afe_fe_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_base_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nstruct mtk_base_afe_memif *memif = &afe->memif[rtd->cpu_dai->id];\r\nint irq_id;\r\nirq_id = memif->irq_usage;\r\nmtk_regmap_update_bits(afe->regmap, memif->data->agent_disable_reg,\r\n1 << memif->data->agent_disable_shift,\r\n1 << memif->data->agent_disable_shift);\r\nif (!memif->const_irq) {\r\nmtk_dynamic_irq_release(afe, irq_id);\r\nmemif->irq_usage = -1;\r\nmemif->substream = NULL;\r\n}\r\n}\r\nint mtk_afe_fe_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_base_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nstruct mtk_base_afe_memif *memif = &afe->memif[rtd->cpu_dai->id];\r\nint msb_at_bit33 = 0;\r\nint ret, fs = 0;\r\nret = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));\r\nif (ret < 0)\r\nreturn ret;\r\nmsb_at_bit33 = upper_32_bits(substream->runtime->dma_addr) ? 1 : 0;\r\nmemif->phys_buf_addr = lower_32_bits(substream->runtime->dma_addr);\r\nmemif->buffer_size = substream->runtime->dma_bytes;\r\nmtk_regmap_write(afe->regmap, memif->data->reg_ofs_base,\r\nmemif->phys_buf_addr);\r\nmtk_regmap_write(afe->regmap,\r\nmemif->data->reg_ofs_base + AFE_BASE_END_OFFSET,\r\nmemif->phys_buf_addr + memif->buffer_size - 1);\r\nmtk_regmap_update_bits(afe->regmap, memif->data->msb_reg,\r\n1 << memif->data->msb_shift,\r\nmsb_at_bit33 << memif->data->msb_shift);\r\nif (memif->data->mono_shift >= 0) {\r\nunsigned int mono = (params_channels(params) == 1) ? 1 : 0;\r\nmtk_regmap_update_bits(afe->regmap, memif->data->mono_reg,\r\n1 << memif->data->mono_shift,\r\nmono << memif->data->mono_shift);\r\n}\r\nif (memif->data->fs_shift < 0)\r\nreturn 0;\r\nfs = afe->memif_fs(substream, params_rate(params));\r\nif (fs < 0)\r\nreturn -EINVAL;\r\nmtk_regmap_update_bits(afe->regmap, memif->data->fs_reg,\r\nmemif->data->fs_maskbit << memif->data->fs_shift,\r\nfs << memif->data->fs_shift);\r\nreturn 0;\r\n}\r\nint mtk_afe_fe_hw_free(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nint mtk_afe_fe_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_pcm_runtime * const runtime = substream->runtime;\r\nstruct mtk_base_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nstruct mtk_base_afe_memif *memif = &afe->memif[rtd->cpu_dai->id];\r\nstruct mtk_base_afe_irq *irqs = &afe->irqs[memif->irq_usage];\r\nconst struct mtk_base_irq_data *irq_data = irqs->irq_data;\r\nunsigned int counter = runtime->period_size;\r\nint fs;\r\ndev_dbg(afe->dev, "%s %s cmd=%d\n", __func__, memif->data->name, cmd);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nif (memif->data->enable_shift >= 0)\r\nmtk_regmap_update_bits(afe->regmap,\r\nmemif->data->enable_reg,\r\n1 << memif->data->enable_shift,\r\n1 << memif->data->enable_shift);\r\nmtk_regmap_update_bits(afe->regmap, irq_data->irq_cnt_reg,\r\nirq_data->irq_cnt_maskbit\r\n<< irq_data->irq_cnt_shift,\r\ncounter << irq_data->irq_cnt_shift);\r\nfs = afe->irq_fs(substream, runtime->rate);\r\nif (fs < 0)\r\nreturn -EINVAL;\r\nmtk_regmap_update_bits(afe->regmap, irq_data->irq_fs_reg,\r\nirq_data->irq_fs_maskbit\r\n<< irq_data->irq_fs_shift,\r\nfs << irq_data->irq_fs_shift);\r\nmtk_regmap_update_bits(afe->regmap, irq_data->irq_en_reg,\r\n1 << irq_data->irq_en_shift,\r\n1 << irq_data->irq_en_shift);\r\nreturn 0;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nmtk_regmap_update_bits(afe->regmap, memif->data->enable_reg,\r\n1 << memif->data->enable_shift, 0);\r\nmtk_regmap_update_bits(afe->regmap, irq_data->irq_en_reg,\r\n1 << irq_data->irq_en_shift,\r\n0 << irq_data->irq_en_shift);\r\nmtk_regmap_write(afe->regmap, irq_data->irq_clr_reg,\r\n1 << irq_data->irq_clr_shift);\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nint mtk_afe_fe_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct mtk_base_afe *afe = snd_soc_platform_get_drvdata(rtd->platform);\r\nstruct mtk_base_afe_memif *memif = &afe->memif[rtd->cpu_dai->id];\r\nint hd_audio = 0;\r\nswitch (substream->runtime->format) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nhd_audio = 0;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nhd_audio = 1;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nhd_audio = 1;\r\nbreak;\r\ndefault:\r\ndev_err(afe->dev, "%s() error: unsupported format %d\n",\r\n__func__, substream->runtime->format);\r\nbreak;\r\n}\r\nmtk_regmap_update_bits(afe->regmap, memif->data->hd_reg,\r\n1 << memif->data->hd_shift,\r\nhd_audio << memif->data->hd_shift);\r\nreturn 0;\r\n}\r\nint mtk_dynamic_irq_acquire(struct mtk_base_afe *afe)\r\n{\r\nint i;\r\nmutex_lock(&afe->irq_alloc_lock);\r\nfor (i = 0; i < afe->irqs_size; ++i) {\r\nif (afe->irqs[i].irq_occupyed == 0) {\r\nafe->irqs[i].irq_occupyed = 1;\r\nmutex_unlock(&afe->irq_alloc_lock);\r\nreturn i;\r\n}\r\n}\r\nmutex_unlock(&afe->irq_alloc_lock);\r\nreturn afe->irqs_size;\r\n}\r\nint mtk_dynamic_irq_release(struct mtk_base_afe *afe, int irq_id)\r\n{\r\nmutex_lock(&afe->irq_alloc_lock);\r\nif (irq_id >= 0 && irq_id < afe->irqs_size) {\r\nafe->irqs[irq_id].irq_occupyed = 0;\r\nmutex_unlock(&afe->irq_alloc_lock);\r\nreturn 0;\r\n}\r\nmutex_unlock(&afe->irq_alloc_lock);\r\nreturn -EINVAL;\r\n}\r\nint mtk_afe_dai_suspend(struct snd_soc_dai *dai)\r\n{\r\nstruct mtk_base_afe *afe = dev_get_drvdata(dai->dev);\r\nstruct device *dev = afe->dev;\r\nstruct regmap *regmap = afe->regmap;\r\nint i;\r\nif (pm_runtime_status_suspended(dev) || afe->suspended)\r\nreturn 0;\r\nif (!afe->reg_back_up)\r\nafe->reg_back_up =\r\ndevm_kcalloc(dev, afe->reg_back_up_list_num,\r\nsizeof(unsigned int), GFP_KERNEL);\r\nfor (i = 0; i < afe->reg_back_up_list_num; i++)\r\nregmap_read(regmap, afe->reg_back_up_list[i],\r\n&afe->reg_back_up[i]);\r\nafe->suspended = true;\r\nafe->runtime_suspend(dev);\r\nreturn 0;\r\n}\r\nint mtk_afe_dai_resume(struct snd_soc_dai *dai)\r\n{\r\nstruct mtk_base_afe *afe = dev_get_drvdata(dai->dev);\r\nstruct device *dev = afe->dev;\r\nstruct regmap *regmap = afe->regmap;\r\nint i = 0;\r\nif (pm_runtime_status_suspended(dev) || !afe->suspended)\r\nreturn 0;\r\nafe->runtime_resume(dev);\r\nif (!afe->reg_back_up)\r\ndev_dbg(dev, "%s no reg_backup\n", __func__);\r\nfor (i = 0; i < afe->reg_back_up_list_num; i++)\r\nmtk_regmap_write(regmap, afe->reg_back_up_list[i],\r\nafe->reg_back_up[i]);\r\nafe->suspended = false;\r\nreturn 0;\r\n}
