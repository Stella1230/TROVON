static unsigned long clk_sama5d4_h32mx_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_sama5d4_h32mx *h32mxclk = to_clk_sama5d4_h32mx(hw);\r\nunsigned int mckr;\r\nregmap_read(h32mxclk->regmap, AT91_PMC_MCKR, &mckr);\r\nif (mckr & AT91_PMC_H32MXDIV)\r\nreturn parent_rate / 2;\r\nif (parent_rate > H32MX_MAX_FREQ)\r\npr_warn("H32MX clock is too fast\n");\r\nreturn parent_rate;\r\n}\r\nstatic long clk_sama5d4_h32mx_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nunsigned long div;\r\nif (rate > *parent_rate)\r\nreturn *parent_rate;\r\ndiv = *parent_rate / 2;\r\nif (rate < div)\r\nreturn div;\r\nif (rate - div < *parent_rate - rate)\r\nreturn div;\r\nreturn *parent_rate;\r\n}\r\nstatic int clk_sama5d4_h32mx_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_sama5d4_h32mx *h32mxclk = to_clk_sama5d4_h32mx(hw);\r\nu32 mckr = 0;\r\nif (parent_rate != rate && (parent_rate / 2) != rate)\r\nreturn -EINVAL;\r\nif ((parent_rate / 2) == rate)\r\nmckr = AT91_PMC_H32MXDIV;\r\nregmap_update_bits(h32mxclk->regmap, AT91_PMC_MCKR,\r\nAT91_PMC_H32MXDIV, mckr);\r\nreturn 0;\r\n}\r\nstatic void __init of_sama5d4_clk_h32mx_setup(struct device_node *np)\r\n{\r\nstruct clk_sama5d4_h32mx *h32mxclk;\r\nstruct clk_init_data init;\r\nconst char *parent_name;\r\nstruct regmap *regmap;\r\nint ret;\r\nregmap = syscon_node_to_regmap(of_get_parent(np));\r\nif (IS_ERR(regmap))\r\nreturn;\r\nh32mxclk = kzalloc(sizeof(*h32mxclk), GFP_KERNEL);\r\nif (!h32mxclk)\r\nreturn;\r\nparent_name = of_clk_get_parent_name(np, 0);\r\ninit.name = np->name;\r\ninit.ops = &h32mx_ops;\r\ninit.parent_names = parent_name ? &parent_name : NULL;\r\ninit.num_parents = parent_name ? 1 : 0;\r\ninit.flags = CLK_SET_RATE_GATE;\r\nh32mxclk->hw.init = &init;\r\nh32mxclk->regmap = regmap;\r\nret = clk_hw_register(NULL, &h32mxclk->hw);\r\nif (ret) {\r\nkfree(h32mxclk);\r\nreturn;\r\n}\r\nof_clk_add_hw_provider(np, of_clk_hw_simple_get, &h32mxclk->hw);\r\n}
