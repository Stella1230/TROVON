static bool percpu_counter_fixup_free(void *addr, enum debug_obj_state state)\r\n{\r\nstruct percpu_counter *fbc = addr;\r\nswitch (state) {\r\ncase ODEBUG_STATE_ACTIVE:\r\npercpu_counter_destroy(fbc);\r\ndebug_object_free(fbc, &percpu_counter_debug_descr);\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic inline void debug_percpu_counter_activate(struct percpu_counter *fbc)\r\n{\r\ndebug_object_init(fbc, &percpu_counter_debug_descr);\r\ndebug_object_activate(fbc, &percpu_counter_debug_descr);\r\n}\r\nstatic inline void debug_percpu_counter_deactivate(struct percpu_counter *fbc)\r\n{\r\ndebug_object_deactivate(fbc, &percpu_counter_debug_descr);\r\ndebug_object_free(fbc, &percpu_counter_debug_descr);\r\n}\r\nstatic inline void debug_percpu_counter_activate(struct percpu_counter *fbc)\r\n{ }\r\nstatic inline void debug_percpu_counter_deactivate(struct percpu_counter *fbc)\r\n{ }\r\nvoid percpu_counter_set(struct percpu_counter *fbc, s64 amount)\r\n{\r\nint cpu;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&fbc->lock, flags);\r\nfor_each_possible_cpu(cpu) {\r\ns32 *pcount = per_cpu_ptr(fbc->counters, cpu);\r\n*pcount = 0;\r\n}\r\nfbc->count = amount;\r\nraw_spin_unlock_irqrestore(&fbc->lock, flags);\r\n}\r\nvoid __percpu_counter_add(struct percpu_counter *fbc, s64 amount, s32 batch)\r\n{\r\ns64 count;\r\npreempt_disable();\r\ncount = __this_cpu_read(*fbc->counters) + amount;\r\nif (count >= batch || count <= -batch) {\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&fbc->lock, flags);\r\nfbc->count += count;\r\n__this_cpu_sub(*fbc->counters, count - amount);\r\nraw_spin_unlock_irqrestore(&fbc->lock, flags);\r\n} else {\r\nthis_cpu_add(*fbc->counters, amount);\r\n}\r\npreempt_enable();\r\n}\r\ns64 __percpu_counter_sum(struct percpu_counter *fbc)\r\n{\r\ns64 ret;\r\nint cpu;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&fbc->lock, flags);\r\nret = fbc->count;\r\nfor_each_online_cpu(cpu) {\r\ns32 *pcount = per_cpu_ptr(fbc->counters, cpu);\r\nret += *pcount;\r\n}\r\nraw_spin_unlock_irqrestore(&fbc->lock, flags);\r\nreturn ret;\r\n}\r\nint __percpu_counter_init(struct percpu_counter *fbc, s64 amount, gfp_t gfp,\r\nstruct lock_class_key *key)\r\n{\r\nunsigned long flags __maybe_unused;\r\nraw_spin_lock_init(&fbc->lock);\r\nlockdep_set_class(&fbc->lock, key);\r\nfbc->count = amount;\r\nfbc->counters = alloc_percpu_gfp(s32, gfp);\r\nif (!fbc->counters)\r\nreturn -ENOMEM;\r\ndebug_percpu_counter_activate(fbc);\r\n#ifdef CONFIG_HOTPLUG_CPU\r\nINIT_LIST_HEAD(&fbc->list);\r\nspin_lock_irqsave(&percpu_counters_lock, flags);\r\nlist_add(&fbc->list, &percpu_counters);\r\nspin_unlock_irqrestore(&percpu_counters_lock, flags);\r\n#endif\r\nreturn 0;\r\n}\r\nvoid percpu_counter_destroy(struct percpu_counter *fbc)\r\n{\r\nunsigned long flags __maybe_unused;\r\nif (!fbc->counters)\r\nreturn;\r\ndebug_percpu_counter_deactivate(fbc);\r\n#ifdef CONFIG_HOTPLUG_CPU\r\nspin_lock_irqsave(&percpu_counters_lock, flags);\r\nlist_del(&fbc->list);\r\nspin_unlock_irqrestore(&percpu_counters_lock, flags);\r\n#endif\r\nfree_percpu(fbc->counters);\r\nfbc->counters = NULL;\r\n}\r\nstatic int compute_batch_value(unsigned int cpu)\r\n{\r\nint nr = num_online_cpus();\r\npercpu_counter_batch = max(32, nr*2);\r\nreturn 0;\r\n}\r\nstatic int percpu_counter_cpu_dead(unsigned int cpu)\r\n{\r\n#ifdef CONFIG_HOTPLUG_CPU\r\nstruct percpu_counter *fbc;\r\ncompute_batch_value(cpu);\r\nspin_lock_irq(&percpu_counters_lock);\r\nlist_for_each_entry(fbc, &percpu_counters, list) {\r\ns32 *pcount;\r\nraw_spin_lock(&fbc->lock);\r\npcount = per_cpu_ptr(fbc->counters, cpu);\r\nfbc->count += *pcount;\r\n*pcount = 0;\r\nraw_spin_unlock(&fbc->lock);\r\n}\r\nspin_unlock_irq(&percpu_counters_lock);\r\n#endif\r\nreturn 0;\r\n}\r\nint __percpu_counter_compare(struct percpu_counter *fbc, s64 rhs, s32 batch)\r\n{\r\ns64 count;\r\ncount = percpu_counter_read(fbc);\r\nif (abs(count - rhs) > (batch * num_online_cpus())) {\r\nif (count > rhs)\r\nreturn 1;\r\nelse\r\nreturn -1;\r\n}\r\ncount = percpu_counter_sum(fbc);\r\nif (count > rhs)\r\nreturn 1;\r\nelse if (count < rhs)\r\nreturn -1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int __init percpu_counter_startup(void)\r\n{\r\nint ret;\r\nret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, "lib/percpu_cnt:online",\r\ncompute_batch_value, NULL);\r\nWARN_ON(ret < 0);\r\nret = cpuhp_setup_state_nocalls(CPUHP_PERCPU_CNT_DEAD,\r\n"lib/percpu_cnt:dead", NULL,\r\npercpu_counter_cpu_dead);\r\nWARN_ON(ret < 0);\r\nreturn 0;\r\n}
