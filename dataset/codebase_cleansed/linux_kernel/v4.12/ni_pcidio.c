static inline unsigned int primary_DMAChannel_bits(unsigned int channel)\r\n{\r\nreturn channel & 0x3;\r\n}\r\nstatic inline unsigned int secondary_DMAChannel_bits(unsigned int channel)\r\n{\r\nreturn (channel << 2) & 0xc;\r\n}\r\nstatic int ni_pcidio_request_di_mite_channel(struct comedi_device *dev)\r\n{\r\nstruct nidio96_private *devpriv = dev->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nBUG_ON(devpriv->di_mite_chan);\r\ndevpriv->di_mite_chan =\r\nmite_request_channel_in_range(devpriv->mite,\r\ndevpriv->di_mite_ring, 1, 2);\r\nif (!devpriv->di_mite_chan) {\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\ndev_err(dev->class_dev, "failed to reserve mite dma channel\n");\r\nreturn -EBUSY;\r\n}\r\ndevpriv->di_mite_chan->dir = COMEDI_INPUT;\r\nwriteb(primary_DMAChannel_bits(devpriv->di_mite_chan->channel) |\r\nsecondary_DMAChannel_bits(devpriv->di_mite_chan->channel),\r\ndev->mmio + DMA_Line_Control_Group1);\r\nmmiowb();\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void ni_pcidio_release_di_mite_channel(struct comedi_device *dev)\r\n{\r\nstruct nidio96_private *devpriv = dev->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nif (devpriv->di_mite_chan) {\r\nmite_release_channel(devpriv->di_mite_chan);\r\ndevpriv->di_mite_chan = NULL;\r\nwriteb(primary_DMAChannel_bits(0) |\r\nsecondary_DMAChannel_bits(0),\r\ndev->mmio + DMA_Line_Control_Group1);\r\nmmiowb();\r\n}\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\n}\r\nstatic int setup_mite_dma(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct nidio96_private *devpriv = dev->private;\r\nint retval;\r\nunsigned long flags;\r\nretval = ni_pcidio_request_di_mite_channel(dev);\r\nif (retval)\r\nreturn retval;\r\ncomedi_buf_write_alloc(s, s->async->prealloc_bufsz);\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nif (devpriv->di_mite_chan) {\r\nmite_prep_dma(devpriv->di_mite_chan, 32, 32);\r\nmite_dma_arm(devpriv->di_mite_chan);\r\n} else {\r\nretval = -EIO;\r\n}\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\nreturn retval;\r\n}\r\nstatic int ni_pcidio_poll(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct nidio96_private *devpriv = dev->private;\r\nunsigned long irq_flags;\r\nint count;\r\nspin_lock_irqsave(&dev->spinlock, irq_flags);\r\nspin_lock(&devpriv->mite_channel_lock);\r\nif (devpriv->di_mite_chan)\r\nmite_sync_dma(devpriv->di_mite_chan, s);\r\nspin_unlock(&devpriv->mite_channel_lock);\r\ncount = comedi_buf_n_bytes_ready(s);\r\nspin_unlock_irqrestore(&dev->spinlock, irq_flags);\r\nreturn count;\r\n}\r\nstatic irqreturn_t nidio_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct nidio96_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_async *async = s->async;\r\nunsigned int auxdata;\r\nint flags;\r\nint status;\r\nint work = 0;\r\nif (!dev->attached) {\r\nreturn IRQ_NONE;\r\n}\r\nspin_lock(&dev->spinlock);\r\nstatus = readb(dev->mmio + Interrupt_And_Window_Status);\r\nflags = readb(dev->mmio + Group_1_Flags);\r\nspin_lock(&devpriv->mite_channel_lock);\r\nif (devpriv->di_mite_chan) {\r\nmite_ack_linkc(devpriv->di_mite_chan, s, false);\r\n}\r\nspin_unlock(&devpriv->mite_channel_lock);\r\nwhile (status & DataLeft) {\r\nwork++;\r\nif (work > 20) {\r\ndev_dbg(dev->class_dev, "too much work in interrupt\n");\r\nwriteb(0x00,\r\ndev->mmio + Master_DMA_And_Interrupt_Control);\r\nbreak;\r\n}\r\nflags &= IntEn;\r\nif (flags & TransferReady) {\r\nwhile (flags & TransferReady) {\r\nwork++;\r\nif (work > 100) {\r\ndev_dbg(dev->class_dev,\r\n"too much work in interrupt\n");\r\nwriteb(0x00, dev->mmio +\r\nMaster_DMA_And_Interrupt_Control\r\n);\r\ngoto out;\r\n}\r\nauxdata = readl(dev->mmio + Group_1_FIFO);\r\ncomedi_buf_write_samples(s, &auxdata, 1);\r\nflags = readb(dev->mmio + Group_1_Flags);\r\n}\r\n}\r\nif (flags & CountExpired) {\r\nwriteb(ClearExpired, dev->mmio + Group_1_Second_Clear);\r\nasync->events |= COMEDI_CB_EOA;\r\nwriteb(0x00, dev->mmio + OpMode);\r\nbreak;\r\n} else if (flags & Waited) {\r\nwriteb(ClearWaited, dev->mmio + Group_1_First_Clear);\r\nasync->events |= COMEDI_CB_ERROR;\r\nbreak;\r\n} else if (flags & PrimaryTC) {\r\nwriteb(ClearPrimaryTC,\r\ndev->mmio + Group_1_First_Clear);\r\nasync->events |= COMEDI_CB_EOA;\r\n} else if (flags & SecondaryTC) {\r\nwriteb(ClearSecondaryTC,\r\ndev->mmio + Group_1_First_Clear);\r\nasync->events |= COMEDI_CB_EOA;\r\n}\r\nflags = readb(dev->mmio + Group_1_Flags);\r\nstatus = readb(dev->mmio + Interrupt_And_Window_Status);\r\n}\r\nout:\r\ncomedi_handle_events(dev, s);\r\n#if 0\r\nif (!tag)\r\nwriteb(0x03, dev->mmio + Master_DMA_And_Interrupt_Control);\r\n#endif\r\nspin_unlock(&dev->spinlock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ni_pcidio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint ret;\r\nret = comedi_dio_insn_config(dev, s, insn, data, 0);\r\nif (ret)\r\nreturn ret;\r\nwritel(s->io_bits, dev->mmio + Port_Pin_Directions(0));\r\nreturn insn->n;\r\n}\r\nstatic int ni_pcidio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nif (comedi_dio_update_state(s, data))\r\nwritel(s->state, dev->mmio + Port_IO(0));\r\ndata[1] = readl(dev->mmio + Port_IO(0));\r\nreturn insn->n;\r\n}\r\nstatic int ni_pcidio_ns_to_timer(int *nanosec, unsigned int flags)\r\n{\r\nint divider, base;\r\nbase = TIMER_BASE;\r\nswitch (flags & CMDF_ROUND_MASK) {\r\ncase CMDF_ROUND_NEAREST:\r\ndefault:\r\ndivider = DIV_ROUND_CLOSEST(*nanosec, base);\r\nbreak;\r\ncase CMDF_ROUND_DOWN:\r\ndivider = (*nanosec) / base;\r\nbreak;\r\ncase CMDF_ROUND_UP:\r\ndivider = DIV_ROUND_UP(*nanosec, base);\r\nbreak;\r\n}\r\n*nanosec = base * divider;\r\nreturn divider;\r\n}\r\nstatic int ni_pcidio_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nunsigned int arg;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src,\r\nTRIG_TIMER | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->start_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\n#define MAX_SPEED (TIMER_BASE)\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nerr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\r\nMAX_SPEED);\r\n} else {\r\nif ((cmd->scan_begin_arg & ~(CR_EDGE | CR_INVERT)) != 0) {\r\ncmd->scan_begin_arg &= (CR_EDGE | CR_INVERT);\r\nerr |= -EINVAL;\r\n}\r\n}\r\nerr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\narg = cmd->scan_begin_arg;\r\nni_pcidio_ns_to_timer(&arg, cmd->flags);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\r\n}\r\nif (err)\r\nreturn 4;\r\nreturn 0;\r\n}\r\nstatic int ni_pcidio_inttrig(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nstruct nidio96_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nif (trig_num != cmd->start_arg)\r\nreturn -EINVAL;\r\nwriteb(devpriv->OpModeBits, dev->mmio + OpMode);\r\ns->async->inttrig = NULL;\r\nreturn 1;\r\n}\r\nstatic int ni_pcidio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct nidio96_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nwritel(0x0000, dev->mmio + Port_Pin_Directions(0));\r\nif (1) {\r\nwriteb(0x0f, dev->mmio + Data_Path);\r\nwriteb(TransferWidth(0) | TransferLength(0),\r\ndev->mmio + Transfer_Size_Control);\r\n} else {\r\nwriteb(0x03, dev->mmio + Data_Path);\r\nwriteb(TransferWidth(3) | TransferLength(0),\r\ndev->mmio + Transfer_Size_Control);\r\n}\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nwriteb(0, dev->mmio + OpMode);\r\nwriteb(0x00, dev->mmio + ClockReg);\r\nwriteb(1, dev->mmio + Sequence);\r\nwriteb(0x04, dev->mmio + ReqReg);\r\nwriteb(4, dev->mmio + BlockMode);\r\nwriteb(3, dev->mmio + LinePolarities);\r\nwriteb(0xc0, dev->mmio + AckSer);\r\nwritel(ni_pcidio_ns_to_timer(&cmd->scan_begin_arg,\r\nCMDF_ROUND_NEAREST),\r\ndev->mmio + StartDelay);\r\nwriteb(1, dev->mmio + ReqDelay);\r\nwriteb(1, dev->mmio + ReqNotDelay);\r\nwriteb(1, dev->mmio + AckDelay);\r\nwriteb(0x0b, dev->mmio + AckNotDelay);\r\nwriteb(0x01, dev->mmio + Data1Delay);\r\nwritew(0, dev->mmio + ClockSpeed);\r\nwriteb(0, dev->mmio + DAQOptions);\r\n} else {\r\nwriteb(0, dev->mmio + OpMode);\r\nwriteb(0x00, dev->mmio + ClockReg);\r\nwriteb(0, dev->mmio + Sequence);\r\nwriteb(0x00, dev->mmio + ReqReg);\r\nwriteb(4, dev->mmio + BlockMode);\r\nif (!(cmd->scan_begin_arg & CR_INVERT))\r\nwriteb(0, dev->mmio + LinePolarities);\r\nelse\r\nwriteb(2, dev->mmio + LinePolarities);\r\nwriteb(0x00, dev->mmio + AckSer);\r\nwritel(1, dev->mmio + StartDelay);\r\nwriteb(1, dev->mmio + ReqDelay);\r\nwriteb(1, dev->mmio + ReqNotDelay);\r\nwriteb(1, dev->mmio + AckDelay);\r\nwriteb(0x0C, dev->mmio + AckNotDelay);\r\nwriteb(0x10, dev->mmio + Data1Delay);\r\nwritew(0, dev->mmio + ClockSpeed);\r\nwriteb(0x60, dev->mmio + DAQOptions);\r\n}\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nwritel(cmd->stop_arg,\r\ndev->mmio + Transfer_Count);\r\n} else {\r\n}\r\n#ifdef USE_DMA\r\nwriteb(ClearPrimaryTC | ClearSecondaryTC,\r\ndev->mmio + Group_1_First_Clear);\r\n{\r\nint retval = setup_mite_dma(dev, s);\r\nif (retval)\r\nreturn retval;\r\n}\r\n#else\r\nwriteb(0x00, dev->mmio + DMA_Line_Control_Group1);\r\n#endif\r\nwriteb(0x00, dev->mmio + DMA_Line_Control_Group2);\r\nwriteb(0xff, dev->mmio + Group_1_First_Clear);\r\nwriteb(IntEn, dev->mmio + Interrupt_Control);\r\nwriteb(0x03, dev->mmio + Master_DMA_And_Interrupt_Control);\r\nif (cmd->stop_src == TRIG_NONE) {\r\ndevpriv->OpModeBits = DataLatching(0) | RunMode(7);\r\n} else {\r\ndevpriv->OpModeBits = Numbered | RunMode(7);\r\n}\r\nif (cmd->start_src == TRIG_NOW) {\r\nwriteb(devpriv->OpModeBits, dev->mmio + OpMode);\r\ns->async->inttrig = NULL;\r\n} else {\r\ns->async->inttrig = ni_pcidio_inttrig;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ni_pcidio_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nwriteb(0x00, dev->mmio + Master_DMA_And_Interrupt_Control);\r\nni_pcidio_release_di_mite_channel(dev);\r\nreturn 0;\r\n}\r\nstatic int ni_pcidio_change(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct nidio96_private *devpriv = dev->private;\r\nint ret;\r\nret = mite_buf_change(devpriv->di_mite_ring, s);\r\nif (ret < 0)\r\nreturn ret;\r\nmemset(s->async->prealloc_buf, 0xaa, s->async->prealloc_bufsz);\r\nreturn 0;\r\n}\r\nstatic int pci_6534_load_fpga(struct comedi_device *dev,\r\nconst u8 *data, size_t data_len,\r\nunsigned long context)\r\n{\r\nstatic const int timeout = 1000;\r\nint fpga_index = context;\r\nint i;\r\nsize_t j;\r\nwritew(0x80 | fpga_index, dev->mmio + Firmware_Control_Register);\r\nwritew(0xc0 | fpga_index, dev->mmio + Firmware_Control_Register);\r\nfor (i = 0;\r\n(readw(dev->mmio + Firmware_Status_Register) & 0x2) == 0 &&\r\ni < timeout; ++i) {\r\nudelay(1);\r\n}\r\nif (i == timeout) {\r\ndev_warn(dev->class_dev,\r\n"ni_pcidio: failed to load fpga %i, waiting for status 0x2\n",\r\nfpga_index);\r\nreturn -EIO;\r\n}\r\nwritew(0x80 | fpga_index, dev->mmio + Firmware_Control_Register);\r\nfor (i = 0;\r\nreadw(dev->mmio + Firmware_Status_Register) != 0x3 &&\r\ni < timeout; ++i) {\r\nudelay(1);\r\n}\r\nif (i == timeout) {\r\ndev_warn(dev->class_dev,\r\n"ni_pcidio: failed to load fpga %i, waiting for status 0x3\n",\r\nfpga_index);\r\nreturn -EIO;\r\n}\r\nfor (j = 0; j + 1 < data_len;) {\r\nunsigned int value = data[j++];\r\nvalue |= data[j++] << 8;\r\nwritew(value, dev->mmio + Firmware_Data_Register);\r\nfor (i = 0;\r\n(readw(dev->mmio + Firmware_Status_Register) & 0x2) == 0\r\n&& i < timeout; ++i) {\r\nudelay(1);\r\n}\r\nif (i == timeout) {\r\ndev_warn(dev->class_dev,\r\n"ni_pcidio: failed to load word into fpga %i\n",\r\nfpga_index);\r\nreturn -EIO;\r\n}\r\nif (need_resched())\r\nschedule();\r\n}\r\nwritew(0x0, dev->mmio + Firmware_Control_Register);\r\nreturn 0;\r\n}\r\nstatic int pci_6534_reset_fpga(struct comedi_device *dev, int fpga_index)\r\n{\r\nreturn pci_6534_load_fpga(dev, NULL, 0, fpga_index);\r\n}\r\nstatic int pci_6534_reset_fpgas(struct comedi_device *dev)\r\n{\r\nint ret;\r\nint i;\r\nwritew(0x0, dev->mmio + Firmware_Control_Register);\r\nfor (i = 0; i < 3; ++i) {\r\nret = pci_6534_reset_fpga(dev, i);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nwritew(0x0, dev->mmio + Firmware_Mask_Register);\r\nreturn ret;\r\n}\r\nstatic void pci_6534_init_main_fpga(struct comedi_device *dev)\r\n{\r\nwritel(0, dev->mmio + FPGA_Control1_Register);\r\nwritel(0, dev->mmio + FPGA_Control2_Register);\r\nwritel(0, dev->mmio + FPGA_SCALS_Counter_Register);\r\nwritel(0, dev->mmio + FPGA_SCAMS_Counter_Register);\r\nwritel(0, dev->mmio + FPGA_SCBLS_Counter_Register);\r\nwritel(0, dev->mmio + FPGA_SCBMS_Counter_Register);\r\n}\r\nstatic int pci_6534_upload_firmware(struct comedi_device *dev)\r\n{\r\nstruct nidio96_private *devpriv = dev->private;\r\nstatic const char *const fw_file[3] = {\r\nFW_PCI_6534_SCARAB_DI,\r\nFW_PCI_6534_SCARAB_DO,\r\nFW_PCI_6534_MAIN,\r\n};\r\nint ret;\r\nint n;\r\nret = pci_6534_reset_fpgas(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (n = 2; n >= 0; n--) {\r\nret = comedi_load_firmware(dev, &devpriv->mite->pcidev->dev,\r\nfw_file[n],\r\npci_6534_load_fpga, n);\r\nif (ret == 0 && n == 2)\r\npci_6534_init_main_fpga(dev);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void nidio_reset_board(struct comedi_device *dev)\r\n{\r\nwritel(0, dev->mmio + Port_IO(0));\r\nwritel(0, dev->mmio + Port_Pin_Directions(0));\r\nwritel(0, dev->mmio + Port_Pin_Mask(0));\r\nwriteb(0, dev->mmio + Master_DMA_And_Interrupt_Control);\r\n}\r\nstatic int nidio_auto_attach(struct comedi_device *dev,\r\nunsigned long context)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nconst struct nidio_board *board = NULL;\r\nstruct nidio96_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint ret;\r\nunsigned int irq;\r\nif (context < ARRAY_SIZE(nidio_boards))\r\nboard = &nidio_boards[context];\r\nif (!board)\r\nreturn -ENODEV;\r\ndev->board_ptr = board;\r\ndev->board_name = board->name;\r\nret = comedi_pci_enable(dev);\r\nif (ret)\r\nreturn ret;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nspin_lock_init(&devpriv->mite_channel_lock);\r\ndevpriv->mite = mite_attach(dev, false);\r\nif (!devpriv->mite)\r\nreturn -ENOMEM;\r\ndevpriv->di_mite_ring = mite_alloc_ring(devpriv->mite);\r\nif (!devpriv->di_mite_ring)\r\nreturn -ENOMEM;\r\nif (board->uses_firmware) {\r\nret = pci_6534_upload_firmware(dev);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nnidio_reset_board(dev);\r\nret = comedi_alloc_subdevices(dev, 1);\r\nif (ret)\r\nreturn ret;\r\ndev_info(dev->class_dev, "%s rev=%d\n", dev->board_name,\r\nreadb(dev->mmio + Chip_Version));\r\ns = &dev->subdevices[0];\r\ndev->read_subdev = s;\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags =\r\nSDF_READABLE | SDF_WRITABLE | SDF_LSAMPL | SDF_PACKED |\r\nSDF_CMD_READ;\r\ns->n_chan = 32;\r\ns->range_table = &range_digital;\r\ns->maxdata = 1;\r\ns->insn_config = &ni_pcidio_insn_config;\r\ns->insn_bits = &ni_pcidio_insn_bits;\r\ns->do_cmd = &ni_pcidio_cmd;\r\ns->do_cmdtest = &ni_pcidio_cmdtest;\r\ns->cancel = &ni_pcidio_cancel;\r\ns->len_chanlist = 32;\r\ns->buf_change = &ni_pcidio_change;\r\ns->async_dma_dir = DMA_BIDIRECTIONAL;\r\ns->poll = &ni_pcidio_poll;\r\nirq = pcidev->irq;\r\nif (irq) {\r\nret = request_irq(irq, nidio_interrupt, IRQF_SHARED,\r\ndev->board_name, dev);\r\nif (ret == 0)\r\ndev->irq = irq;\r\n}\r\nreturn 0;\r\n}\r\nstatic void nidio_detach(struct comedi_device *dev)\r\n{\r\nstruct nidio96_private *devpriv = dev->private;\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nif (devpriv) {\r\nif (devpriv->di_mite_ring) {\r\nmite_free_ring(devpriv->di_mite_ring);\r\ndevpriv->di_mite_ring = NULL;\r\n}\r\nmite_detach(devpriv->mite);\r\n}\r\nif (dev->mmio)\r\niounmap(dev->mmio);\r\ncomedi_pci_disable(dev);\r\n}\r\nstatic int ni_pcidio_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nreturn comedi_pci_auto_config(dev, &ni_pcidio_driver, id->driver_data);\r\n}
