static int gsbi_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct device_node *tcsr_node;\r\nconst struct of_device_id *match;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nstruct gsbi_info *gsbi;\r\nint i;\r\nu32 mask, gsbi_num;\r\nconst struct crci_config *config = NULL;\r\ngsbi = devm_kzalloc(&pdev->dev, sizeof(*gsbi), GFP_KERNEL);\r\nif (!gsbi)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\ngsbi->tcsr = syscon_regmap_lookup_by_phandle(node, "syscon-tcsr");\r\nif (!IS_ERR(gsbi->tcsr)) {\r\ntcsr_node = of_parse_phandle(node, "syscon-tcsr", 0);\r\nif (tcsr_node) {\r\nmatch = of_match_node(tcsr_dt_match, tcsr_node);\r\nif (match)\r\nconfig = match->data;\r\nelse\r\ndev_warn(&pdev->dev, "no matching TCSR\n");\r\nof_node_put(tcsr_node);\r\n}\r\n}\r\nif (of_property_read_u32(node, "cell-index", &gsbi_num)) {\r\ndev_err(&pdev->dev, "missing cell-index\n");\r\nreturn -EINVAL;\r\n}\r\nif (gsbi_num < 1 || gsbi_num > MAX_GSBI) {\r\ndev_err(&pdev->dev, "invalid cell-index\n");\r\nreturn -EINVAL;\r\n}\r\nif (of_property_read_u32(node, "qcom,mode", &gsbi->mode)) {\r\ndev_err(&pdev->dev, "missing mode configuration\n");\r\nreturn -EINVAL;\r\n}\r\nof_property_read_u32(node, "qcom,crci", &gsbi->crci);\r\ndev_info(&pdev->dev, "GSBI port protocol: %d crci: %d\n",\r\ngsbi->mode, gsbi->crci);\r\ngsbi->hclk = devm_clk_get(&pdev->dev, "iface");\r\nif (IS_ERR(gsbi->hclk))\r\nreturn PTR_ERR(gsbi->hclk);\r\nclk_prepare_enable(gsbi->hclk);\r\nwritel_relaxed((gsbi->mode << GSBI_PROTOCOL_SHIFT) | gsbi->crci,\r\nbase + GSBI_CTRL_REG);\r\nif (config) {\r\nfor (i = 0; i < config->num_rows; i++) {\r\nmask = config->array[i][gsbi_num - 1];\r\nif (gsbi->mode == GSBI_PROT_SPI)\r\nregmap_update_bits(gsbi->tcsr,\r\nTCSR_ADM_CRCI_BASE + 4 * i, mask, 0);\r\nelse\r\nregmap_update_bits(gsbi->tcsr,\r\nTCSR_ADM_CRCI_BASE + 4 * i, mask, mask);\r\n}\r\n}\r\nwmb();\r\nplatform_set_drvdata(pdev, gsbi);\r\nreturn of_platform_populate(node, NULL, NULL, &pdev->dev);\r\n}\r\nstatic int gsbi_remove(struct platform_device *pdev)\r\n{\r\nstruct gsbi_info *gsbi = platform_get_drvdata(pdev);\r\nclk_disable_unprepare(gsbi->hclk);\r\nreturn 0;\r\n}
