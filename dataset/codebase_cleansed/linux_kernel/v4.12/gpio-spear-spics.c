static int spics_get_value(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn -ENXIO;\r\n}\r\nstatic void spics_set_value(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct spear_spics *spics = gpiochip_get_data(chip);\r\nu32 tmp;\r\ntmp = readl_relaxed(spics->base + spics->perip_cfg);\r\nif (spics->last_off != offset) {\r\nspics->last_off = offset;\r\ntmp &= ~(spics->cs_enable_mask << spics->cs_enable_shift);\r\ntmp |= offset << spics->cs_enable_shift;\r\n}\r\ntmp &= ~(0x1 << spics->cs_value_bit);\r\ntmp |= value << spics->cs_value_bit;\r\nwritel_relaxed(tmp, spics->base + spics->perip_cfg);\r\n}\r\nstatic int spics_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn -ENXIO;\r\n}\r\nstatic int spics_direction_output(struct gpio_chip *chip, unsigned offset,\r\nint value)\r\n{\r\nspics_set_value(chip, offset, value);\r\nreturn 0;\r\n}\r\nstatic int spics_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct spear_spics *spics = gpiochip_get_data(chip);\r\nu32 tmp;\r\nif (!spics->use_count++) {\r\ntmp = readl_relaxed(spics->base + spics->perip_cfg);\r\ntmp |= 0x1 << spics->sw_enable_bit;\r\ntmp |= 0x1 << spics->cs_value_bit;\r\nwritel_relaxed(tmp, spics->base + spics->perip_cfg);\r\n}\r\nreturn 0;\r\n}\r\nstatic void spics_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct spear_spics *spics = gpiochip_get_data(chip);\r\nu32 tmp;\r\nif (!--spics->use_count) {\r\ntmp = readl_relaxed(spics->base + spics->perip_cfg);\r\ntmp &= ~(0x1 << spics->sw_enable_bit);\r\nwritel_relaxed(tmp, spics->base + spics->perip_cfg);\r\n}\r\n}\r\nstatic int spics_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct spear_spics *spics;\r\nstruct resource *res;\r\nint ret;\r\nspics = devm_kzalloc(&pdev->dev, sizeof(*spics), GFP_KERNEL);\r\nif (!spics)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nspics->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(spics->base))\r\nreturn PTR_ERR(spics->base);\r\nif (of_property_read_u32(np, "st-spics,peripcfg-reg",\r\n&spics->perip_cfg))\r\ngoto err_dt_data;\r\nif (of_property_read_u32(np, "st-spics,sw-enable-bit",\r\n&spics->sw_enable_bit))\r\ngoto err_dt_data;\r\nif (of_property_read_u32(np, "st-spics,cs-value-bit",\r\n&spics->cs_value_bit))\r\ngoto err_dt_data;\r\nif (of_property_read_u32(np, "st-spics,cs-enable-mask",\r\n&spics->cs_enable_mask))\r\ngoto err_dt_data;\r\nif (of_property_read_u32(np, "st-spics,cs-enable-shift",\r\n&spics->cs_enable_shift))\r\ngoto err_dt_data;\r\nplatform_set_drvdata(pdev, spics);\r\nspics->chip.ngpio = NUM_OF_GPIO;\r\nspics->chip.base = -1;\r\nspics->chip.request = spics_request;\r\nspics->chip.free = spics_free;\r\nspics->chip.direction_input = spics_direction_input;\r\nspics->chip.direction_output = spics_direction_output;\r\nspics->chip.get = spics_get_value;\r\nspics->chip.set = spics_set_value;\r\nspics->chip.label = dev_name(&pdev->dev);\r\nspics->chip.parent = &pdev->dev;\r\nspics->chip.owner = THIS_MODULE;\r\nspics->last_off = -1;\r\nret = devm_gpiochip_add_data(&pdev->dev, &spics->chip, spics);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to add gpio chip\n");\r\nreturn ret;\r\n}\r\ndev_info(&pdev->dev, "spear spics registered\n");\r\nreturn 0;\r\nerr_dt_data:\r\ndev_err(&pdev->dev, "DT probe failed\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int __init spics_gpio_init(void)\r\n{\r\nreturn platform_driver_register(&spics_gpio_driver);\r\n}
