static void i82975x_get_error_info(struct mem_ctl_info *mci,\r\nstruct i82975x_error_info *info)\r\n{\r\nstruct pci_dev *pdev;\r\npdev = to_pci_dev(mci->pdev);\r\npci_read_config_word(pdev, I82975X_ERRSTS, &info->errsts);\r\npci_read_config_dword(pdev, I82975X_EAP, &info->eap);\r\npci_read_config_byte(pdev, I82975X_XEAP, &info->xeap);\r\npci_read_config_byte(pdev, I82975X_DES, &info->des);\r\npci_read_config_byte(pdev, I82975X_DERRSYN, &info->derrsyn);\r\npci_read_config_word(pdev, I82975X_ERRSTS, &info->errsts2);\r\npci_write_bits16(pdev, I82975X_ERRSTS, 0x0003, 0x0003);\r\nif (!(info->errsts2 & 0x0003))\r\nreturn;\r\nif ((info->errsts ^ info->errsts2) & 0x0003) {\r\npci_read_config_dword(pdev, I82975X_EAP, &info->eap);\r\npci_read_config_byte(pdev, I82975X_XEAP, &info->xeap);\r\npci_read_config_byte(pdev, I82975X_DES, &info->des);\r\npci_read_config_byte(pdev, I82975X_DERRSYN,\r\n&info->derrsyn);\r\n}\r\n}\r\nstatic int i82975x_process_error_info(struct mem_ctl_info *mci,\r\nstruct i82975x_error_info *info, int handle_errors)\r\n{\r\nint row, chan;\r\nunsigned long offst, page;\r\nif (!(info->errsts2 & 0x0003))\r\nreturn 0;\r\nif (!handle_errors)\r\nreturn 1;\r\nif ((info->errsts ^ info->errsts2) & 0x0003) {\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1, 0, 0, 0,\r\n-1, -1, -1, "UE overwrote CE", "");\r\ninfo->errsts = info->errsts2;\r\n}\r\npage = (unsigned long) info->eap;\r\npage >>= 1;\r\nif (info->xeap & 1)\r\npage |= 0x80000000;\r\npage >>= (PAGE_SHIFT - 1);\r\nrow = edac_mc_find_csrow_by_page(mci, page);\r\nif (row == -1) {\r\ni82975x_mc_printk(mci, KERN_ERR, "error processing EAP:\n"\r\n"\tXEAP=%u\n"\r\n"\t EAP=0x%08x\n"\r\n"\tPAGE=0x%08x\n",\r\n(info->xeap & 1) ? 1 : 0, info->eap, (unsigned int) page);\r\nreturn 0;\r\n}\r\nchan = (mci->csrows[row]->nr_channels == 1) ? 0 : info->eap & 1;\r\noffst = info->eap\r\n& ((1 << PAGE_SHIFT) -\r\n(1 << mci->csrows[row]->channels[chan]->dimm->grain));\r\nif (info->errsts & 0x0002)\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\r\npage, offst, 0,\r\nrow, -1, -1,\r\n"i82975x UE", "");\r\nelse\r\nedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\r\npage, offst, info->derrsyn,\r\nrow, chan ? chan : 0, -1,\r\n"i82975x CE", "");\r\nreturn 1;\r\n}\r\nstatic void i82975x_check(struct mem_ctl_info *mci)\r\n{\r\nstruct i82975x_error_info info;\r\nedac_dbg(1, "MC%d\n", mci->mc_idx);\r\ni82975x_get_error_info(mci, &info);\r\ni82975x_process_error_info(mci, &info, 1);\r\n}\r\nstatic int dual_channel_active(void __iomem *mch_window)\r\n{\r\nu8 drb[4][2];\r\nint row;\r\nint dualch;\r\nfor (dualch = 1, row = 0; dualch && (row < 4); row++) {\r\ndrb[row][0] = readb(mch_window + I82975X_DRB + row);\r\ndrb[row][1] = readb(mch_window + I82975X_DRB + row + 0x80);\r\ndualch = dualch && (drb[row][0] == drb[row][1]);\r\n}\r\nreturn dualch;\r\n}\r\nstatic enum dev_type i82975x_dram_type(void __iomem *mch_window, int rank)\r\n{\r\nreturn DEV_X8;\r\n}\r\nstatic void i82975x_init_csrows(struct mem_ctl_info *mci,\r\nstruct pci_dev *pdev, void __iomem *mch_window)\r\n{\r\nstruct csrow_info *csrow;\r\nunsigned long last_cumul_size;\r\nu8 value;\r\nu32 cumul_size, nr_pages;\r\nint index, chan;\r\nstruct dimm_info *dimm;\r\nenum dev_type dtype;\r\nlast_cumul_size = 0;\r\nfor (index = 0; index < mci->nr_csrows; index++) {\r\ncsrow = mci->csrows[index];\r\nvalue = readb(mch_window + I82975X_DRB + index +\r\n((index >= 4) ? 0x80 : 0));\r\ncumul_size = value;\r\ncumul_size <<= (I82975X_DRB_SHIFT - PAGE_SHIFT);\r\nif (csrow->nr_channels > 1)\r\ncumul_size <<= 1;\r\nedac_dbg(3, "(%d) cumul_size 0x%x\n", index, cumul_size);\r\nnr_pages = cumul_size - last_cumul_size;\r\nif (!nr_pages)\r\ncontinue;\r\ndtype = i82975x_dram_type(mch_window, index);\r\nfor (chan = 0; chan < csrow->nr_channels; chan++) {\r\ndimm = mci->csrows[index]->channels[chan]->dimm;\r\ndimm->nr_pages = nr_pages / csrow->nr_channels;\r\nsnprintf(csrow->channels[chan]->dimm->label, EDAC_MC_LABEL_LEN, "DIMM %c%d",\r\n(chan == 0) ? 'A' : 'B',\r\nindex);\r\ndimm->grain = 1 << 7;\r\ndimm->dtype = i82975x_dram_type(mch_window, index);\r\ndimm->mtype = MEM_DDR2;\r\ndimm->edac_mode = EDAC_SECDED;\r\n}\r\ncsrow->first_page = last_cumul_size;\r\ncsrow->last_page = cumul_size - 1;\r\nlast_cumul_size = cumul_size;\r\n}\r\n}\r\nstatic void i82975x_print_dram_timings(void __iomem *mch_window)\r\n{\r\nstatic const int caslats[4] = { 5, 4, 3, 6 };\r\nu32 dtreg[2];\r\ndtreg[0] = readl(mch_window + 0x114);\r\ndtreg[1] = readl(mch_window + 0x194);\r\ni82975x_printk(KERN_INFO, "DRAM Timings : Ch0 Ch1\n"\r\n" RAS Active Min = %d %d\n"\r\n" CAS latency = %d %d\n"\r\n" RAS to CAS = %d %d\n"\r\n" RAS precharge = %d %d\n",\r\n(dtreg[0] >> 19 ) & 0x0f,\r\n(dtreg[1] >> 19) & 0x0f,\r\ncaslats[(dtreg[0] >> 8) & 0x03],\r\ncaslats[(dtreg[1] >> 8) & 0x03],\r\n((dtreg[0] >> 4) & 0x07) + 2,\r\n((dtreg[1] >> 4) & 0x07) + 2,\r\n(dtreg[0] & 0x07) + 2,\r\n(dtreg[1] & 0x07) + 2\r\n);\r\n}\r\nstatic int i82975x_probe1(struct pci_dev *pdev, int dev_idx)\r\n{\r\nint rc = -ENODEV;\r\nstruct mem_ctl_info *mci;\r\nstruct edac_mc_layer layers[2];\r\nstruct i82975x_pvt *pvt;\r\nvoid __iomem *mch_window;\r\nu32 mchbar;\r\nu32 drc[2];\r\nstruct i82975x_error_info discard;\r\nint chans;\r\n#ifdef i82975x_DEBUG_IOMEM\r\nu8 c0drb[4];\r\nu8 c1drb[4];\r\n#endif\r\nedac_dbg(0, "\n");\r\npci_read_config_dword(pdev, I82975X_MCHBAR, &mchbar);\r\nif (!(mchbar & 1)) {\r\nedac_dbg(3, "failed, MCHBAR disabled!\n");\r\ngoto fail0;\r\n}\r\nmchbar &= 0xffffc000;\r\nmch_window = ioremap_nocache(mchbar, 0x1000);\r\nif (!mch_window) {\r\nedac_dbg(3, "error ioremapping MCHBAR!\n");\r\ngoto fail0;\r\n}\r\n#ifdef i82975x_DEBUG_IOMEM\r\ni82975x_printk(KERN_INFO, "MCHBAR real = %0x, remapped = %p\n",\r\nmchbar, mch_window);\r\nc0drb[0] = readb(mch_window + I82975X_DRB_CH0R0);\r\nc0drb[1] = readb(mch_window + I82975X_DRB_CH0R1);\r\nc0drb[2] = readb(mch_window + I82975X_DRB_CH0R2);\r\nc0drb[3] = readb(mch_window + I82975X_DRB_CH0R3);\r\nc1drb[0] = readb(mch_window + I82975X_DRB_CH1R0);\r\nc1drb[1] = readb(mch_window + I82975X_DRB_CH1R1);\r\nc1drb[2] = readb(mch_window + I82975X_DRB_CH1R2);\r\nc1drb[3] = readb(mch_window + I82975X_DRB_CH1R3);\r\ni82975x_printk(KERN_INFO, "DRBCH0R0 = 0x%02x\n", c0drb[0]);\r\ni82975x_printk(KERN_INFO, "DRBCH0R1 = 0x%02x\n", c0drb[1]);\r\ni82975x_printk(KERN_INFO, "DRBCH0R2 = 0x%02x\n", c0drb[2]);\r\ni82975x_printk(KERN_INFO, "DRBCH0R3 = 0x%02x\n", c0drb[3]);\r\ni82975x_printk(KERN_INFO, "DRBCH1R0 = 0x%02x\n", c1drb[0]);\r\ni82975x_printk(KERN_INFO, "DRBCH1R1 = 0x%02x\n", c1drb[1]);\r\ni82975x_printk(KERN_INFO, "DRBCH1R2 = 0x%02x\n", c1drb[2]);\r\ni82975x_printk(KERN_INFO, "DRBCH1R3 = 0x%02x\n", c1drb[3]);\r\n#endif\r\ndrc[0] = readl(mch_window + I82975X_DRC_CH0M0);\r\ndrc[1] = readl(mch_window + I82975X_DRC_CH1M0);\r\n#ifdef i82975x_DEBUG_IOMEM\r\ni82975x_printk(KERN_INFO, "DRC_CH0 = %0x, %s\n", drc[0],\r\n((drc[0] >> 21) & 3) == 1 ?\r\n"ECC enabled" : "ECC disabled");\r\ni82975x_printk(KERN_INFO, "DRC_CH1 = %0x, %s\n", drc[1],\r\n((drc[1] >> 21) & 3) == 1 ?\r\n"ECC enabled" : "ECC disabled");\r\ni82975x_printk(KERN_INFO, "C0 BNKARC = %0x\n",\r\nreadw(mch_window + I82975X_C0BNKARC));\r\ni82975x_printk(KERN_INFO, "C1 BNKARC = %0x\n",\r\nreadw(mch_window + I82975X_C1BNKARC));\r\ni82975x_print_dram_timings(mch_window);\r\ngoto fail1;\r\n#endif\r\nif (!(((drc[0] >> 21) & 3) == 1 || ((drc[1] >> 21) & 3) == 1)) {\r\ni82975x_printk(KERN_INFO, "ECC disabled on both channels.\n");\r\ngoto fail1;\r\n}\r\nchans = dual_channel_active(mch_window) + 1;\r\nlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\r\nlayers[0].size = I82975X_NR_DIMMS;\r\nlayers[0].is_virt_csrow = true;\r\nlayers[1].type = EDAC_MC_LAYER_CHANNEL;\r\nlayers[1].size = I82975X_NR_CSROWS(chans);\r\nlayers[1].is_virt_csrow = false;\r\nmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers, sizeof(*pvt));\r\nif (!mci) {\r\nrc = -ENOMEM;\r\ngoto fail1;\r\n}\r\nedac_dbg(3, "init mci\n");\r\nmci->pdev = &pdev->dev;\r\nmci->mtype_cap = MEM_FLAG_DDR2;\r\nmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_SECDED;\r\nmci->edac_cap = EDAC_FLAG_NONE | EDAC_FLAG_SECDED;\r\nmci->mod_name = EDAC_MOD_STR;\r\nmci->mod_ver = I82975X_REVISION;\r\nmci->ctl_name = i82975x_devs[dev_idx].ctl_name;\r\nmci->dev_name = pci_name(pdev);\r\nmci->edac_check = i82975x_check;\r\nmci->ctl_page_to_phys = NULL;\r\nedac_dbg(3, "init pvt\n");\r\npvt = (struct i82975x_pvt *) mci->pvt_info;\r\npvt->mch_window = mch_window;\r\ni82975x_init_csrows(mci, pdev, mch_window);\r\nmci->scrub_mode = SCRUB_HW_SRC;\r\ni82975x_get_error_info(mci, &discard);\r\nif (edac_mc_add_mc(mci)) {\r\nedac_dbg(3, "failed edac_mc_add_mc()\n");\r\ngoto fail2;\r\n}\r\nedac_dbg(3, "success\n");\r\nreturn 0;\r\nfail2:\r\nedac_mc_free(mci);\r\nfail1:\r\niounmap(mch_window);\r\nfail0:\r\nreturn rc;\r\n}\r\nstatic int i82975x_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nint rc;\r\nedac_dbg(0, "\n");\r\nif (pci_enable_device(pdev) < 0)\r\nreturn -EIO;\r\nrc = i82975x_probe1(pdev, ent->driver_data);\r\nif (mci_pdev == NULL)\r\nmci_pdev = pci_dev_get(pdev);\r\nreturn rc;\r\n}\r\nstatic void i82975x_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct i82975x_pvt *pvt;\r\nedac_dbg(0, "\n");\r\nmci = edac_mc_del_mc(&pdev->dev);\r\nif (mci == NULL)\r\nreturn;\r\npvt = mci->pvt_info;\r\nif (pvt->mch_window)\r\niounmap( pvt->mch_window );\r\nedac_mc_free(mci);\r\n}\r\nstatic int __init i82975x_init(void)\r\n{\r\nint pci_rc;\r\nedac_dbg(3, "\n");\r\nopstate_init();\r\npci_rc = pci_register_driver(&i82975x_driver);\r\nif (pci_rc < 0)\r\ngoto fail0;\r\nif (mci_pdev == NULL) {\r\nmci_pdev = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_82975_0, NULL);\r\nif (!mci_pdev) {\r\nedac_dbg(0, "i82975x pci_get_device fail\n");\r\npci_rc = -ENODEV;\r\ngoto fail1;\r\n}\r\npci_rc = i82975x_init_one(mci_pdev, i82975x_pci_tbl);\r\nif (pci_rc < 0) {\r\nedac_dbg(0, "i82975x init fail\n");\r\npci_rc = -ENODEV;\r\ngoto fail1;\r\n}\r\n}\r\nreturn 0;\r\nfail1:\r\npci_unregister_driver(&i82975x_driver);\r\nfail0:\r\npci_dev_put(mci_pdev);\r\nreturn pci_rc;\r\n}\r\nstatic void __exit i82975x_exit(void)\r\n{\r\nedac_dbg(3, "\n");\r\npci_unregister_driver(&i82975x_driver);\r\nif (!i82975x_registered) {\r\ni82975x_remove_one(mci_pdev);\r\npci_dev_put(mci_pdev);\r\n}\r\n}
