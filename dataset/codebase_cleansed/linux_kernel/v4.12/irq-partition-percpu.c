static bool partition_check_cpu(struct partition_desc *part,\r\nunsigned int cpu, unsigned int hwirq)\r\n{\r\nreturn cpumask_test_cpu(cpu, &part->parts[hwirq].mask);\r\n}\r\nstatic void partition_irq_mask(struct irq_data *d)\r\n{\r\nstruct partition_desc *part = irq_data_get_irq_chip_data(d);\r\nstruct irq_chip *chip = irq_desc_get_chip(part->chained_desc);\r\nstruct irq_data *data = irq_desc_get_irq_data(part->chained_desc);\r\nif (partition_check_cpu(part, smp_processor_id(), d->hwirq) &&\r\nchip->irq_mask)\r\nchip->irq_mask(data);\r\n}\r\nstatic void partition_irq_unmask(struct irq_data *d)\r\n{\r\nstruct partition_desc *part = irq_data_get_irq_chip_data(d);\r\nstruct irq_chip *chip = irq_desc_get_chip(part->chained_desc);\r\nstruct irq_data *data = irq_desc_get_irq_data(part->chained_desc);\r\nif (partition_check_cpu(part, smp_processor_id(), d->hwirq) &&\r\nchip->irq_unmask)\r\nchip->irq_unmask(data);\r\n}\r\nstatic int partition_irq_set_irqchip_state(struct irq_data *d,\r\nenum irqchip_irq_state which,\r\nbool val)\r\n{\r\nstruct partition_desc *part = irq_data_get_irq_chip_data(d);\r\nstruct irq_chip *chip = irq_desc_get_chip(part->chained_desc);\r\nstruct irq_data *data = irq_desc_get_irq_data(part->chained_desc);\r\nif (partition_check_cpu(part, smp_processor_id(), d->hwirq) &&\r\nchip->irq_set_irqchip_state)\r\nreturn chip->irq_set_irqchip_state(data, which, val);\r\nreturn -EINVAL;\r\n}\r\nstatic int partition_irq_get_irqchip_state(struct irq_data *d,\r\nenum irqchip_irq_state which,\r\nbool *val)\r\n{\r\nstruct partition_desc *part = irq_data_get_irq_chip_data(d);\r\nstruct irq_chip *chip = irq_desc_get_chip(part->chained_desc);\r\nstruct irq_data *data = irq_desc_get_irq_data(part->chained_desc);\r\nif (partition_check_cpu(part, smp_processor_id(), d->hwirq) &&\r\nchip->irq_get_irqchip_state)\r\nreturn chip->irq_get_irqchip_state(data, which, val);\r\nreturn -EINVAL;\r\n}\r\nstatic int partition_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct partition_desc *part = irq_data_get_irq_chip_data(d);\r\nstruct irq_chip *chip = irq_desc_get_chip(part->chained_desc);\r\nstruct irq_data *data = irq_desc_get_irq_data(part->chained_desc);\r\nif (chip->irq_set_type)\r\nreturn chip->irq_set_type(data, type);\r\nreturn -EINVAL;\r\n}\r\nstatic void partition_irq_print_chip(struct irq_data *d, struct seq_file *p)\r\n{\r\nstruct partition_desc *part = irq_data_get_irq_chip_data(d);\r\nstruct irq_chip *chip = irq_desc_get_chip(part->chained_desc);\r\nstruct irq_data *data = irq_desc_get_irq_data(part->chained_desc);\r\nseq_printf(p, " %5s-%lu", chip->name, data->hwirq);\r\n}\r\nstatic void partition_handle_irq(struct irq_desc *desc)\r\n{\r\nstruct partition_desc *part = irq_desc_get_handler_data(desc);\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nint cpu = smp_processor_id();\r\nint hwirq;\r\nchained_irq_enter(chip, desc);\r\nfor_each_set_bit(hwirq, part->bitmap, part->nr_parts) {\r\nif (partition_check_cpu(part, cpu, hwirq))\r\nbreak;\r\n}\r\nif (unlikely(hwirq == part->nr_parts)) {\r\nhandle_bad_irq(desc);\r\n} else {\r\nunsigned int irq;\r\nirq = irq_find_mapping(part->domain, hwirq);\r\ngeneric_handle_irq(irq);\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int partition_domain_alloc(struct irq_domain *domain, unsigned int virq,\r\nunsigned int nr_irqs, void *arg)\r\n{\r\nint ret;\r\nirq_hw_number_t hwirq;\r\nunsigned int type;\r\nstruct irq_fwspec *fwspec = arg;\r\nstruct partition_desc *part;\r\nBUG_ON(nr_irqs != 1);\r\nret = domain->ops->translate(domain, fwspec, &hwirq, &type);\r\nif (ret)\r\nreturn ret;\r\npart = domain->host_data;\r\nset_bit(hwirq, part->bitmap);\r\nirq_set_chained_handler_and_data(irq_desc_get_irq(part->chained_desc),\r\npartition_handle_irq, part);\r\nirq_set_percpu_devid_partition(virq, &part->parts[hwirq].mask);\r\nirq_domain_set_info(domain, virq, hwirq, &partition_irq_chip, part,\r\nhandle_percpu_devid_irq, NULL, NULL);\r\nirq_set_status_flags(virq, IRQ_NOAUTOEN);\r\nreturn 0;\r\n}\r\nstatic void partition_domain_free(struct irq_domain *domain, unsigned int virq,\r\nunsigned int nr_irqs)\r\n{\r\nstruct irq_data *d;\r\nBUG_ON(nr_irqs != 1);\r\nd = irq_domain_get_irq_data(domain, virq);\r\nirq_set_handler(virq, NULL);\r\nirq_domain_reset_irq_data(d);\r\n}\r\nint partition_translate_id(struct partition_desc *desc, void *partition_id)\r\n{\r\nstruct partition_affinity *part = NULL;\r\nint i;\r\nfor (i = 0; i < desc->nr_parts; i++) {\r\nif (desc->parts[i].partition_id == partition_id) {\r\npart = &desc->parts[i];\r\nbreak;\r\n}\r\n}\r\nif (WARN_ON(!part)) {\r\npr_err("Failed to find partition\n");\r\nreturn -EINVAL;\r\n}\r\nreturn i;\r\n}\r\nstruct partition_desc *partition_create_desc(struct fwnode_handle *fwnode,\r\nstruct partition_affinity *parts,\r\nint nr_parts,\r\nint chained_irq,\r\nconst struct irq_domain_ops *ops)\r\n{\r\nstruct partition_desc *desc;\r\nstruct irq_domain *d;\r\nBUG_ON(!ops->select || !ops->translate);\r\ndesc = kzalloc(sizeof(*desc), GFP_KERNEL);\r\nif (!desc)\r\nreturn NULL;\r\ndesc->ops = *ops;\r\ndesc->ops.free = partition_domain_free;\r\ndesc->ops.alloc = partition_domain_alloc;\r\nd = irq_domain_create_linear(fwnode, nr_parts, &desc->ops, desc);\r\nif (!d)\r\ngoto out;\r\ndesc->domain = d;\r\ndesc->bitmap = kzalloc(sizeof(long) * BITS_TO_LONGS(nr_parts),\r\nGFP_KERNEL);\r\nif (WARN_ON(!desc->bitmap))\r\ngoto out;\r\ndesc->chained_desc = irq_to_desc(chained_irq);\r\ndesc->nr_parts = nr_parts;\r\ndesc->parts = parts;\r\nreturn desc;\r\nout:\r\nif (d)\r\nirq_domain_remove(d);\r\nkfree(desc);\r\nreturn NULL;\r\n}\r\nstruct irq_domain *partition_get_domain(struct partition_desc *dsc)\r\n{\r\nif (dsc)\r\nreturn dsc->domain;\r\nreturn NULL;\r\n}
