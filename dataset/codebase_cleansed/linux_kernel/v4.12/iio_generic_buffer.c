int size_from_channelarray(struct iio_channel_info *channels, int num_channels)\r\n{\r\nint bytes = 0;\r\nint i = 0;\r\nwhile (i < num_channels) {\r\nif (bytes % channels[i].bytes == 0)\r\nchannels[i].location = bytes;\r\nelse\r\nchannels[i].location = bytes - bytes % channels[i].bytes\r\n+ channels[i].bytes;\r\nbytes = channels[i].location + channels[i].bytes;\r\ni++;\r\n}\r\nreturn bytes;\r\n}\r\nvoid print1byte(uint8_t input, struct iio_channel_info *info)\r\n{\r\ninput >>= info->shift;\r\ninput &= info->mask;\r\nif (info->is_signed) {\r\nint8_t val = (int8_t)(input << (8 - info->bits_used)) >>\r\n(8 - info->bits_used);\r\nprintf("%05f ", ((float)val + info->offset) * info->scale);\r\n} else {\r\nprintf("%05f ", ((float)input + info->offset) * info->scale);\r\n}\r\n}\r\nvoid print2byte(uint16_t input, struct iio_channel_info *info)\r\n{\r\nif (info->be)\r\ninput = be16toh(input);\r\nelse\r\ninput = le16toh(input);\r\ninput >>= info->shift;\r\ninput &= info->mask;\r\nif (info->is_signed) {\r\nint16_t val = (int16_t)(input << (16 - info->bits_used)) >>\r\n(16 - info->bits_used);\r\nprintf("%05f ", ((float)val + info->offset) * info->scale);\r\n} else {\r\nprintf("%05f ", ((float)input + info->offset) * info->scale);\r\n}\r\n}\r\nvoid print4byte(uint32_t input, struct iio_channel_info *info)\r\n{\r\nif (info->be)\r\ninput = be32toh(input);\r\nelse\r\ninput = le32toh(input);\r\ninput >>= info->shift;\r\ninput &= info->mask;\r\nif (info->is_signed) {\r\nint32_t val = (int32_t)(input << (32 - info->bits_used)) >>\r\n(32 - info->bits_used);\r\nprintf("%05f ", ((float)val + info->offset) * info->scale);\r\n} else {\r\nprintf("%05f ", ((float)input + info->offset) * info->scale);\r\n}\r\n}\r\nvoid print8byte(uint64_t input, struct iio_channel_info *info)\r\n{\r\nif (info->be)\r\ninput = be64toh(input);\r\nelse\r\ninput = le64toh(input);\r\ninput >>= info->shift;\r\ninput &= info->mask;\r\nif (info->is_signed) {\r\nint64_t val = (int64_t)(input << (64 - info->bits_used)) >>\r\n(64 - info->bits_used);\r\nif (info->scale == 1.0f && info->offset == 0.0f)\r\nprintf("%" PRId64 " ", val);\r\nelse\r\nprintf("%05f ",\r\n((float)val + info->offset) * info->scale);\r\n} else {\r\nprintf("%05f ", ((float)input + info->offset) * info->scale);\r\n}\r\n}\r\nvoid process_scan(char *data,\r\nstruct iio_channel_info *channels,\r\nint num_channels)\r\n{\r\nint k;\r\nfor (k = 0; k < num_channels; k++)\r\nswitch (channels[k].bytes) {\r\ncase 1:\r\nprint1byte(*(uint8_t *)(data + channels[k].location),\r\n&channels[k]);\r\nbreak;\r\ncase 2:\r\nprint2byte(*(uint16_t *)(data + channels[k].location),\r\n&channels[k]);\r\nbreak;\r\ncase 4:\r\nprint4byte(*(uint32_t *)(data + channels[k].location),\r\n&channels[k]);\r\nbreak;\r\ncase 8:\r\nprint8byte(*(uint64_t *)(data + channels[k].location),\r\n&channels[k]);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nprintf("\n");\r\n}\r\nstatic int enable_disable_all_channels(char *dev_dir_name, int enable)\r\n{\r\nconst struct dirent *ent;\r\nchar scanelemdir[256];\r\nDIR *dp;\r\nint ret;\r\nsnprintf(scanelemdir, sizeof(scanelemdir),\r\nFORMAT_SCAN_ELEMENTS_DIR, dev_dir_name);\r\nscanelemdir[sizeof(scanelemdir)-1] = '\0';\r\ndp = opendir(scanelemdir);\r\nif (!dp) {\r\nfprintf(stderr, "Enabling/disabling channels: can't open %s\n",\r\nscanelemdir);\r\nreturn -EIO;\r\n}\r\nret = -ENOENT;\r\nwhile (ent = readdir(dp), ent) {\r\nif (iioutils_check_suffix(ent->d_name, "_en")) {\r\nprintf("%sabling: %s\n",\r\nenable ? "En" : "Dis",\r\nent->d_name);\r\nret = write_sysfs_int(ent->d_name, scanelemdir,\r\nenable);\r\nif (ret < 0)\r\nfprintf(stderr, "Failed to enable/disable %s\n",\r\nent->d_name);\r\n}\r\n}\r\nif (closedir(dp) == -1) {\r\nperror("Enabling/disabling channels: "\r\n"Failed to close directory");\r\nreturn -errno;\r\n}\r\nreturn 0;\r\n}\r\nvoid print_usage(void)\r\n{\r\nfprintf(stderr, "Usage: generic_buffer [options]...\n"\r\n"Capture, convert and output data from IIO device buffer\n"\r\n" -a Auto-activate all available channels\n"\r\n" -A Force-activate ALL channels\n"\r\n" -c <n> Do n conversions\n"\r\n" -e Disable wait for event (new data)\n"\r\n" -g Use trigger-less mode\n"\r\n" -l <n> Set buffer length to n samples\n"\r\n" --device-name -n <name>\n"\r\n" --device-num -N <num>\n"\r\n" Set device by name or number (mandatory)\n"\r\n" --trigger-name -t <name>\n"\r\n" --trigger-num -T <num>\n"\r\n" Set trigger by name or number\n"\r\n" -w <n> Set delay between reads in us (event-less mode)\n");\r\n}\r\nvoid cleanup(void)\r\n{\r\nint ret;\r\nif (dev_dir_name && current_trigger_set) {\r\nret = write_sysfs_string("trigger/current_trigger",\r\ndev_dir_name, "NULL");\r\nif (ret < 0)\r\nfprintf(stderr, "Failed to disable trigger: %s\n",\r\nstrerror(-ret));\r\ncurrent_trigger_set = false;\r\n}\r\nif (buf_dir_name) {\r\nret = write_sysfs_int("enable", buf_dir_name, 0);\r\nif (ret < 0)\r\nfprintf(stderr, "Failed to disable buffer: %s\n",\r\nstrerror(-ret));\r\n}\r\nif (dev_dir_name && autochannels == AUTOCHANNELS_ACTIVE) {\r\nret = enable_disable_all_channels(dev_dir_name, 0);\r\nif (ret)\r\nfprintf(stderr, "Failed to disable all channels\n");\r\nautochannels = AUTOCHANNELS_DISABLED;\r\n}\r\n}\r\nvoid sig_handler(int signum)\r\n{\r\nfprintf(stderr, "Caught signal %d\n", signum);\r\ncleanup();\r\nexit(-signum);\r\n}\r\nvoid register_cleanup(void)\r\n{\r\nstruct sigaction sa = { .sa_handler = sig_handler };\r\nconst int signums[] = { SIGINT, SIGTERM, SIGABRT };\r\nint ret, i;\r\nfor (i = 0; i < ARRAY_SIZE(signums); ++i) {\r\nret = sigaction(signums[i], &sa, NULL);\r\nif (ret) {\r\nperror("Failed to register signal handler");\r\nexit(-1);\r\n}\r\n}\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nunsigned long num_loops = 2;\r\nunsigned long timedelay = 1000000;\r\nunsigned long buf_len = 128;\r\nint ret, c, i, j, toread;\r\nint fp = -1;\r\nint num_channels = 0;\r\nchar *trigger_name = NULL, *device_name = NULL;\r\nchar *data = NULL;\r\nssize_t read_size;\r\nint dev_num = -1, trig_num = -1;\r\nchar *buffer_access = NULL;\r\nint scan_size;\r\nint noevents = 0;\r\nint notrigger = 0;\r\nchar *dummy;\r\nbool force_autochannels = false;\r\nstruct iio_channel_info *channels = NULL;\r\nregister_cleanup();\r\nwhile ((c = getopt_long(argc, argv, "aAc:egl:n:N:t:T:w:?", longopts,\r\nNULL)) != -1) {\r\nswitch (c) {\r\ncase 'a':\r\nautochannels = AUTOCHANNELS_ENABLED;\r\nbreak;\r\ncase 'A':\r\nautochannels = AUTOCHANNELS_ENABLED;\r\nforce_autochannels = true;\r\nbreak;\r\ncase 'c':\r\nerrno = 0;\r\nnum_loops = strtoul(optarg, &dummy, 10);\r\nif (errno) {\r\nret = -errno;\r\ngoto error;\r\n}\r\nbreak;\r\ncase 'e':\r\nnoevents = 1;\r\nbreak;\r\ncase 'g':\r\nnotrigger = 1;\r\nbreak;\r\ncase 'l':\r\nerrno = 0;\r\nbuf_len = strtoul(optarg, &dummy, 10);\r\nif (errno) {\r\nret = -errno;\r\ngoto error;\r\n}\r\nbreak;\r\ncase 'n':\r\ndevice_name = strdup(optarg);\r\nbreak;\r\ncase 'N':\r\nerrno = 0;\r\ndev_num = strtoul(optarg, &dummy, 10);\r\nif (errno) {\r\nret = -errno;\r\ngoto error;\r\n}\r\nbreak;\r\ncase 't':\r\ntrigger_name = strdup(optarg);\r\nbreak;\r\ncase 'T':\r\nerrno = 0;\r\ntrig_num = strtoul(optarg, &dummy, 10);\r\nif (errno)\r\nreturn -errno;\r\nbreak;\r\ncase 'w':\r\nerrno = 0;\r\ntimedelay = strtoul(optarg, &dummy, 10);\r\nif (errno) {\r\nret = -errno;\r\ngoto error;\r\n}\r\nbreak;\r\ncase '?':\r\nprint_usage();\r\nret = -1;\r\ngoto error;\r\n}\r\n}\r\nif (dev_num < 0 && !device_name) {\r\nfprintf(stderr, "Device not set\n");\r\nprint_usage();\r\nret = -1;\r\ngoto error;\r\n} else if (dev_num >= 0 && device_name) {\r\nfprintf(stderr, "Only one of --device-num or --device-name needs to be set\n");\r\nprint_usage();\r\nret = -1;\r\ngoto error;\r\n} else if (dev_num < 0) {\r\ndev_num = find_type_by_name(device_name, "iio:device");\r\nif (dev_num < 0) {\r\nfprintf(stderr, "Failed to find the %s\n", device_name);\r\nret = dev_num;\r\ngoto error;\r\n}\r\n}\r\nprintf("iio device number being used is %d\n", dev_num);\r\nret = asprintf(&dev_dir_name, "%siio:device%d", iio_dir, dev_num);\r\nif (ret < 0)\r\nreturn -ENOMEM;\r\nif (!device_name) {\r\ndevice_name = malloc(IIO_MAX_NAME_LENGTH);\r\nif (!device_name) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nret = read_sysfs_string("name", dev_dir_name, device_name);\r\nif (ret < 0) {\r\nfprintf(stderr, "Failed to read name of device %d\n", dev_num);\r\ngoto error;\r\n}\r\n}\r\nif (notrigger) {\r\nprintf("trigger-less mode selected\n");\r\n} else if (trig_num >= 0) {\r\nchar *trig_dev_name;\r\nret = asprintf(&trig_dev_name, "%strigger%d", iio_dir, trig_num);\r\nif (ret < 0) {\r\nreturn -ENOMEM;\r\n}\r\ntrigger_name = malloc(IIO_MAX_NAME_LENGTH);\r\nret = read_sysfs_string("name", trig_dev_name, trigger_name);\r\nfree(trig_dev_name);\r\nif (ret < 0) {\r\nfprintf(stderr, "Failed to read trigger%d name from\n", trig_num);\r\nreturn ret;\r\n}\r\nprintf("iio trigger number being used is %d\n", trig_num);\r\n} else {\r\nif (!trigger_name) {\r\nret = asprintf(&trigger_name,\r\n"%s-dev%d", device_name, dev_num);\r\nif (ret < 0) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\n}\r\ntrig_num = find_type_by_name(trigger_name, "trigger");\r\nif (trig_num < 0) {\r\nfree(trigger_name);\r\nret = asprintf(&trigger_name,\r\n"%s-trigger", device_name);\r\nif (ret < 0) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\n}\r\ntrig_num = find_type_by_name(trigger_name, "trigger");\r\nif (trig_num < 0) {\r\nfprintf(stderr, "Failed to find the trigger %s\n",\r\ntrigger_name);\r\nret = trig_num;\r\ngoto error;\r\n}\r\nprintf("iio trigger number being used is %d\n", trig_num);\r\n}\r\nret = build_channel_array(dev_dir_name, &channels, &num_channels);\r\nif (ret) {\r\nfprintf(stderr, "Problem reading scan element information\n"\r\n"diag %s\n", dev_dir_name);\r\ngoto error;\r\n}\r\nif (num_channels && autochannels == AUTOCHANNELS_ENABLED &&\r\n!force_autochannels) {\r\nfprintf(stderr, "Auto-channels selected but some channels "\r\n"are already activated in sysfs\n");\r\nfprintf(stderr, "Proceeding without activating any channels\n");\r\n}\r\nif ((!num_channels && autochannels == AUTOCHANNELS_ENABLED) ||\r\n(autochannels == AUTOCHANNELS_ENABLED && force_autochannels)) {\r\nfprintf(stderr, "Enabling all channels\n");\r\nret = enable_disable_all_channels(dev_dir_name, 1);\r\nif (ret) {\r\nfprintf(stderr, "Failed to enable all channels\n");\r\ngoto error;\r\n}\r\nautochannels = AUTOCHANNELS_ACTIVE;\r\nret = build_channel_array(dev_dir_name, &channels,\r\n&num_channels);\r\nif (ret) {\r\nfprintf(stderr, "Problem reading scan element "\r\n"information\n"\r\n"diag %s\n", dev_dir_name);\r\ngoto error;\r\n}\r\nif (!num_channels) {\r\nfprintf(stderr, "Still no channels after "\r\n"auto-enabling, giving up\n");\r\ngoto error;\r\n}\r\n}\r\nif (!num_channels && autochannels == AUTOCHANNELS_DISABLED) {\r\nfprintf(stderr,\r\n"No channels are enabled, we have nothing to scan.\n");\r\nfprintf(stderr, "Enable channels manually in "\r\nFORMAT_SCAN_ELEMENTS_DIR\r\n"/*_en or pass -a to autoenable channels and "\r\n"try again.\n", dev_dir_name);\r\nret = -ENOENT;\r\ngoto error;\r\n}\r\nret = asprintf(&buf_dir_name,\r\n"%siio:device%d/buffer", iio_dir, dev_num);\r\nif (ret < 0) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nif (!notrigger) {\r\nprintf("%s %s\n", dev_dir_name, trigger_name);\r\nret = write_sysfs_string_and_verify("trigger/current_trigger",\r\ndev_dir_name,\r\ntrigger_name);\r\nif (ret < 0) {\r\nfprintf(stderr,\r\n"Failed to write current_trigger file\n");\r\ngoto error;\r\n}\r\n}\r\nret = write_sysfs_int("length", buf_dir_name, buf_len);\r\nif (ret < 0)\r\ngoto error;\r\nret = write_sysfs_int("enable", buf_dir_name, 1);\r\nif (ret < 0) {\r\nfprintf(stderr,\r\n"Failed to enable buffer: %s\n", strerror(-ret));\r\ngoto error;\r\n}\r\nscan_size = size_from_channelarray(channels, num_channels);\r\ndata = malloc(scan_size * buf_len);\r\nif (!data) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nret = asprintf(&buffer_access, "/dev/iio:device%d", dev_num);\r\nif (ret < 0) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nfp = open(buffer_access, O_RDONLY | O_NONBLOCK);\r\nif (fp == -1) {\r\nret = -errno;\r\nfprintf(stderr, "Failed to open %s\n", buffer_access);\r\ngoto error;\r\n}\r\nfor (j = 0; j < num_loops; j++) {\r\nif (!noevents) {\r\nstruct pollfd pfd = {\r\n.fd = fp,\r\n.events = POLLIN,\r\n};\r\nret = poll(&pfd, 1, -1);\r\nif (ret < 0) {\r\nret = -errno;\r\ngoto error;\r\n} else if (ret == 0) {\r\ncontinue;\r\n}\r\ntoread = buf_len;\r\n} else {\r\nusleep(timedelay);\r\ntoread = 64;\r\n}\r\nread_size = read(fp, data, toread * scan_size);\r\nif (read_size < 0) {\r\nif (errno == EAGAIN) {\r\nfprintf(stderr, "nothing available\n");\r\ncontinue;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nfor (i = 0; i < read_size / scan_size; i++)\r\nprocess_scan(data + scan_size * i, channels,\r\nnum_channels);\r\n}\r\nerror:\r\ncleanup();\r\nif (fp >= 0 && close(fp) == -1)\r\nperror("Failed to close buffer");\r\nfree(buffer_access);\r\nfree(data);\r\nfree(buf_dir_name);\r\nfor (i = num_channels - 1; i >= 0; i--) {\r\nfree(channels[i].name);\r\nfree(channels[i].generic_name);\r\n}\r\nfree(channels);\r\nfree(trigger_name);\r\nfree(device_name);\r\nfree(dev_dir_name);\r\nreturn ret;\r\n}
