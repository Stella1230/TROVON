int snd_pcm_format_signed(snd_pcm_format_t format)\r\n{\r\nint val;\r\nif ((INT)format < 0 || (INT)format > (INT)SNDRV_PCM_FORMAT_LAST)\r\nreturn -EINVAL;\r\nif ((val = pcm_formats[(INT)format].signd) < 0)\r\nreturn -EINVAL;\r\nreturn val;\r\n}\r\nint snd_pcm_format_unsigned(snd_pcm_format_t format)\r\n{\r\nint val;\r\nval = snd_pcm_format_signed(format);\r\nif (val < 0)\r\nreturn val;\r\nreturn !val;\r\n}\r\nint snd_pcm_format_linear(snd_pcm_format_t format)\r\n{\r\nreturn snd_pcm_format_signed(format) >= 0;\r\n}\r\nint snd_pcm_format_little_endian(snd_pcm_format_t format)\r\n{\r\nint val;\r\nif ((INT)format < 0 || (INT)format > (INT)SNDRV_PCM_FORMAT_LAST)\r\nreturn -EINVAL;\r\nif ((val = pcm_formats[(INT)format].le) < 0)\r\nreturn -EINVAL;\r\nreturn val;\r\n}\r\nint snd_pcm_format_big_endian(snd_pcm_format_t format)\r\n{\r\nint val;\r\nval = snd_pcm_format_little_endian(format);\r\nif (val < 0)\r\nreturn val;\r\nreturn !val;\r\n}\r\nint snd_pcm_format_width(snd_pcm_format_t format)\r\n{\r\nint val;\r\nif ((INT)format < 0 || (INT)format > (INT)SNDRV_PCM_FORMAT_LAST)\r\nreturn -EINVAL;\r\nif ((val = pcm_formats[(INT)format].width) == 0)\r\nreturn -EINVAL;\r\nreturn val;\r\n}\r\nint snd_pcm_format_physical_width(snd_pcm_format_t format)\r\n{\r\nint val;\r\nif ((INT)format < 0 || (INT)format > (INT)SNDRV_PCM_FORMAT_LAST)\r\nreturn -EINVAL;\r\nif ((val = pcm_formats[(INT)format].phys) == 0)\r\nreturn -EINVAL;\r\nreturn val;\r\n}\r\nssize_t snd_pcm_format_size(snd_pcm_format_t format, size_t samples)\r\n{\r\nint phys_width = snd_pcm_format_physical_width(format);\r\nif (phys_width < 0)\r\nreturn -EINVAL;\r\nreturn samples * phys_width / 8;\r\n}\r\nconst unsigned char *snd_pcm_format_silence_64(snd_pcm_format_t format)\r\n{\r\nif ((INT)format < 0 || (INT)format > (INT)SNDRV_PCM_FORMAT_LAST)\r\nreturn NULL;\r\nif (! pcm_formats[(INT)format].phys)\r\nreturn NULL;\r\nreturn pcm_formats[(INT)format].silence;\r\n}\r\nint snd_pcm_format_set_silence(snd_pcm_format_t format, void *data, unsigned int samples)\r\n{\r\nint width;\r\nunsigned char *dst, *pat;\r\nif ((INT)format < 0 || (INT)format > (INT)SNDRV_PCM_FORMAT_LAST)\r\nreturn -EINVAL;\r\nif (samples == 0)\r\nreturn 0;\r\nwidth = pcm_formats[(INT)format].phys;\r\npat = pcm_formats[(INT)format].silence;\r\nif (! width)\r\nreturn -EINVAL;\r\nif (pcm_formats[(INT)format].signd == 1 || width <= 8) {\r\nunsigned int bytes = samples * width / 8;\r\nmemset(data, *pat, bytes);\r\nreturn 0;\r\n}\r\nwidth /= 8;\r\ndst = data;\r\n#if 0\r\nwhile (samples--) {\r\nmemcpy(dst, pat, width);\r\ndst += width;\r\n}\r\n#else\r\nswitch (width) {\r\ncase 2:\r\nwhile (samples--) {\r\nmemcpy(dst, pat, 2);\r\ndst += 2;\r\n}\r\nbreak;\r\ncase 3:\r\nwhile (samples--) {\r\nmemcpy(dst, pat, 3);\r\ndst += 3;\r\n}\r\nbreak;\r\ncase 4:\r\nwhile (samples--) {\r\nmemcpy(dst, pat, 4);\r\ndst += 4;\r\n}\r\nbreak;\r\ncase 8:\r\nwhile (samples--) {\r\nmemcpy(dst, pat, 8);\r\ndst += 8;\r\n}\r\nbreak;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nint snd_pcm_limit_hw_rates(struct snd_pcm_runtime *runtime)\r\n{\r\nint i;\r\nfor (i = 0; i < (int)snd_pcm_known_rates.count; i++) {\r\nif (runtime->hw.rates & (1 << i)) {\r\nruntime->hw.rate_min = snd_pcm_known_rates.list[i];\r\nbreak;\r\n}\r\n}\r\nfor (i = (int)snd_pcm_known_rates.count - 1; i >= 0; i--) {\r\nif (runtime->hw.rates & (1 << i)) {\r\nruntime->hw.rate_max = snd_pcm_known_rates.list[i];\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nunsigned int snd_pcm_rate_to_rate_bit(unsigned int rate)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < snd_pcm_known_rates.count; i++)\r\nif (snd_pcm_known_rates.list[i] == rate)\r\nreturn 1u << i;\r\nreturn SNDRV_PCM_RATE_KNOT;\r\n}\r\nunsigned int snd_pcm_rate_bit_to_rate(unsigned int rate_bit)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < snd_pcm_known_rates.count; i++)\r\nif ((1u << i) == rate_bit)\r\nreturn snd_pcm_known_rates.list[i];\r\nreturn 0;\r\n}\r\nstatic unsigned int snd_pcm_rate_mask_sanitize(unsigned int rates)\r\n{\r\nif (rates & SNDRV_PCM_RATE_CONTINUOUS)\r\nreturn SNDRV_PCM_RATE_CONTINUOUS;\r\nelse if (rates & SNDRV_PCM_RATE_KNOT)\r\nreturn SNDRV_PCM_RATE_KNOT;\r\nreturn rates;\r\n}\r\nunsigned int snd_pcm_rate_mask_intersect(unsigned int rates_a,\r\nunsigned int rates_b)\r\n{\r\nrates_a = snd_pcm_rate_mask_sanitize(rates_a);\r\nrates_b = snd_pcm_rate_mask_sanitize(rates_b);\r\nif (rates_a & SNDRV_PCM_RATE_CONTINUOUS)\r\nreturn rates_b;\r\nelse if (rates_b & SNDRV_PCM_RATE_CONTINUOUS)\r\nreturn rates_a;\r\nelse if (rates_a & SNDRV_PCM_RATE_KNOT)\r\nreturn rates_b;\r\nelse if (rates_b & SNDRV_PCM_RATE_KNOT)\r\nreturn rates_a;\r\nreturn rates_a & rates_b;\r\n}\r\nunsigned int snd_pcm_rate_range_to_bits(unsigned int rate_min,\r\nunsigned int rate_max)\r\n{\r\nunsigned int rates = 0;\r\nint i;\r\nfor (i = 0; i < snd_pcm_known_rates.count; i++) {\r\nif (snd_pcm_known_rates.list[i] >= rate_min\r\n&& snd_pcm_known_rates.list[i] <= rate_max)\r\nrates |= 1 << i;\r\n}\r\nif (!rates)\r\nrates = SNDRV_PCM_RATE_KNOT;\r\nreturn rates;\r\n}
