static inline u32 pmc_reg_read(struct pmc_dev *pmc, int reg_offset)\r\n{\r\nreturn readl(pmc->regmap + reg_offset);\r\n}\r\nstatic inline void pmc_reg_write(struct pmc_dev *pmc, int reg_offset, u32 val)\r\n{\r\nwritel(val, pmc->regmap + reg_offset);\r\n}\r\nint pmc_atom_read(int offset, u32 *value)\r\n{\r\nstruct pmc_dev *pmc = &pmc_device;\r\nif (!pmc->init)\r\nreturn -ENODEV;\r\n*value = pmc_reg_read(pmc, offset);\r\nreturn 0;\r\n}\r\nint pmc_atom_write(int offset, u32 value)\r\n{\r\nstruct pmc_dev *pmc = &pmc_device;\r\nif (!pmc->init)\r\nreturn -ENODEV;\r\npmc_reg_write(pmc, offset, value);\r\nreturn 0;\r\n}\r\nstatic void pmc_power_off(void)\r\n{\r\nu16 pm1_cnt_port;\r\nu32 pm1_cnt_value;\r\npr_info("Preparing to enter system sleep state S5\n");\r\npm1_cnt_port = acpi_base_addr + PM1_CNT;\r\npm1_cnt_value = inl(pm1_cnt_port);\r\npm1_cnt_value &= SLEEP_TYPE_MASK;\r\npm1_cnt_value |= SLEEP_TYPE_S5;\r\npm1_cnt_value |= SLEEP_ENABLE;\r\noutl(pm1_cnt_value, pm1_cnt_port);\r\n}\r\nstatic void pmc_hw_reg_setup(struct pmc_dev *pmc)\r\n{\r\npmc_reg_write(pmc, PMC_S0IX_WAKE_EN, (u32)PMC_WAKE_EN_SETTING);\r\n}\r\nstatic void pmc_dev_state_print(struct seq_file *s, int reg_index,\r\nu32 sts, const struct pmc_bit_map *sts_map,\r\nu32 fd, const struct pmc_bit_map *fd_map)\r\n{\r\nint offset = PMC_REG_BIT_WIDTH * reg_index;\r\nint index;\r\nfor (index = 0; sts_map[index].name; index++) {\r\nseq_printf(s, "Dev: %-2d - %-32s\tState: %s [%s]\n",\r\noffset + index, sts_map[index].name,\r\nfd_map[index].bit_mask & fd ? "Disabled" : "Enabled ",\r\nsts_map[index].bit_mask & sts ? "D3" : "D0");\r\n}\r\n}\r\nstatic int pmc_dev_state_show(struct seq_file *s, void *unused)\r\n{\r\nstruct pmc_dev *pmc = s->private;\r\nconst struct pmc_reg_map *m = pmc->map;\r\nu32 func_dis, func_dis_2;\r\nu32 d3_sts_0, d3_sts_1;\r\nfunc_dis = pmc_reg_read(pmc, PMC_FUNC_DIS);\r\nfunc_dis_2 = pmc_reg_read(pmc, PMC_FUNC_DIS_2);\r\nd3_sts_0 = pmc_reg_read(pmc, PMC_D3_STS_0);\r\nd3_sts_1 = pmc_reg_read(pmc, PMC_D3_STS_1);\r\npmc_dev_state_print(s, 0, d3_sts_0, m->d3_sts_0, func_dis, m->func_dis);\r\npmc_dev_state_print(s, 1, d3_sts_1, m->d3_sts_1, func_dis_2, m->func_dis_2);\r\nreturn 0;\r\n}\r\nstatic int pmc_dev_state_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, pmc_dev_state_show, inode->i_private);\r\n}\r\nstatic int pmc_pss_state_show(struct seq_file *s, void *unused)\r\n{\r\nstruct pmc_dev *pmc = s->private;\r\nconst struct pmc_bit_map *map = pmc->map->pss;\r\nu32 pss = pmc_reg_read(pmc, PMC_PSS);\r\nint index;\r\nfor (index = 0; map[index].name; index++) {\r\nseq_printf(s, "Island: %-2d - %-32s\tState: %s\n",\r\nindex, map[index].name,\r\nmap[index].bit_mask & pss ? "Off" : "On");\r\n}\r\nreturn 0;\r\n}\r\nstatic int pmc_pss_state_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, pmc_pss_state_show, inode->i_private);\r\n}\r\nstatic int pmc_sleep_tmr_show(struct seq_file *s, void *unused)\r\n{\r\nstruct pmc_dev *pmc = s->private;\r\nu64 s0ir_tmr, s0i1_tmr, s0i2_tmr, s0i3_tmr, s0_tmr;\r\ns0ir_tmr = (u64)pmc_reg_read(pmc, PMC_S0IR_TMR) << PMC_TMR_SHIFT;\r\ns0i1_tmr = (u64)pmc_reg_read(pmc, PMC_S0I1_TMR) << PMC_TMR_SHIFT;\r\ns0i2_tmr = (u64)pmc_reg_read(pmc, PMC_S0I2_TMR) << PMC_TMR_SHIFT;\r\ns0i3_tmr = (u64)pmc_reg_read(pmc, PMC_S0I3_TMR) << PMC_TMR_SHIFT;\r\ns0_tmr = (u64)pmc_reg_read(pmc, PMC_S0_TMR) << PMC_TMR_SHIFT;\r\nseq_printf(s, "S0IR Residency:\t%lldus\n", s0ir_tmr);\r\nseq_printf(s, "S0I1 Residency:\t%lldus\n", s0i1_tmr);\r\nseq_printf(s, "S0I2 Residency:\t%lldus\n", s0i2_tmr);\r\nseq_printf(s, "S0I3 Residency:\t%lldus\n", s0i3_tmr);\r\nseq_printf(s, "S0 Residency:\t%lldus\n", s0_tmr);\r\nreturn 0;\r\n}\r\nstatic int pmc_sleep_tmr_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, pmc_sleep_tmr_show, inode->i_private);\r\n}\r\nstatic void pmc_dbgfs_unregister(struct pmc_dev *pmc)\r\n{\r\ndebugfs_remove_recursive(pmc->dbgfs_dir);\r\n}\r\nstatic int pmc_dbgfs_register(struct pmc_dev *pmc)\r\n{\r\nstruct dentry *dir, *f;\r\ndir = debugfs_create_dir("pmc_atom", NULL);\r\nif (!dir)\r\nreturn -ENOMEM;\r\npmc->dbgfs_dir = dir;\r\nf = debugfs_create_file("dev_state", S_IFREG | S_IRUGO,\r\ndir, pmc, &pmc_dev_state_ops);\r\nif (!f)\r\ngoto err;\r\nf = debugfs_create_file("pss_state", S_IFREG | S_IRUGO,\r\ndir, pmc, &pmc_pss_state_ops);\r\nif (!f)\r\ngoto err;\r\nf = debugfs_create_file("sleep_state", S_IFREG | S_IRUGO,\r\ndir, pmc, &pmc_sleep_tmr_ops);\r\nif (!f)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\npmc_dbgfs_unregister(pmc);\r\nreturn -ENODEV;\r\n}\r\nstatic int pmc_dbgfs_register(struct pmc_dev *pmc)\r\n{\r\nreturn 0;\r\n}\r\nstatic int pmc_setup_clks(struct pci_dev *pdev, void __iomem *pmc_regmap,\r\nconst struct pmc_data *pmc_data)\r\n{\r\nstruct platform_device *clkdev;\r\nstruct pmc_clk_data *clk_data;\r\nclk_data = kzalloc(sizeof(*clk_data), GFP_KERNEL);\r\nif (!clk_data)\r\nreturn -ENOMEM;\r\nclk_data->base = pmc_regmap;\r\nclk_data->clks = pmc_data->clks;\r\nclkdev = platform_device_register_data(&pdev->dev, "clk-pmc-atom",\r\nPLATFORM_DEVID_NONE,\r\nclk_data, sizeof(*clk_data));\r\nif (IS_ERR(clkdev)) {\r\nkfree(clk_data);\r\nreturn PTR_ERR(clkdev);\r\n}\r\nkfree(clk_data);\r\nreturn 0;\r\n}\r\nstatic int pmc_setup_dev(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct pmc_dev *pmc = &pmc_device;\r\nconst struct pmc_data *data = (struct pmc_data *)ent->driver_data;\r\nconst struct pmc_reg_map *map = data->map;\r\nint ret;\r\npci_read_config_dword(pdev, ACPI_BASE_ADDR_OFFSET, &acpi_base_addr);\r\nacpi_base_addr &= ACPI_BASE_ADDR_MASK;\r\nif (acpi_base_addr != 0 && pm_power_off == NULL)\r\npm_power_off = pmc_power_off;\r\npci_read_config_dword(pdev, PMC_BASE_ADDR_OFFSET, &pmc->base_addr);\r\npmc->base_addr &= PMC_BASE_ADDR_MASK;\r\npmc->regmap = ioremap_nocache(pmc->base_addr, PMC_MMIO_REG_LEN);\r\nif (!pmc->regmap) {\r\ndev_err(&pdev->dev, "error: ioremap failed\n");\r\nreturn -ENOMEM;\r\n}\r\npmc->map = map;\r\npmc_hw_reg_setup(pmc);\r\nret = pmc_dbgfs_register(pmc);\r\nif (ret)\r\ndev_warn(&pdev->dev, "debugfs register failed\n");\r\nret = pmc_setup_clks(pdev, pmc->regmap, data);\r\nif (ret)\r\ndev_warn(&pdev->dev, "platform clocks register failed: %d\n",\r\nret);\r\npmc->init = true;\r\nreturn ret;\r\n}\r\nstatic int __init pmc_atom_init(void)\r\n{\r\nstruct pci_dev *pdev = NULL;\r\nconst struct pci_device_id *ent;\r\nfor_each_pci_dev(pdev) {\r\nent = pci_match_id(pmc_pci_ids, pdev);\r\nif (ent)\r\nreturn pmc_setup_dev(pdev, ent);\r\n}\r\nreturn -ENODEV;\r\n}
