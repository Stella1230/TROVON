int drm_getmagic(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\nstruct drm_auth *auth = data;\r\nint ret = 0;\r\nmutex_lock(&dev->master_mutex);\r\nif (!file_priv->magic) {\r\nret = idr_alloc(&file_priv->master->magic_map, file_priv,\r\n1, 0, GFP_KERNEL);\r\nif (ret >= 0)\r\nfile_priv->magic = ret;\r\n}\r\nauth->magic = file_priv->magic;\r\nmutex_unlock(&dev->master_mutex);\r\nDRM_DEBUG("%u\n", auth->magic);\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nint drm_authmagic(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_auth *auth = data;\r\nstruct drm_file *file;\r\nDRM_DEBUG("%u\n", auth->magic);\r\nmutex_lock(&dev->master_mutex);\r\nfile = idr_find(&file_priv->master->magic_map, auth->magic);\r\nif (file) {\r\nfile->authenticated = 1;\r\nidr_replace(&file_priv->master->magic_map, NULL, auth->magic);\r\n}\r\nmutex_unlock(&dev->master_mutex);\r\nreturn file ? 0 : -EINVAL;\r\n}\r\nstatic struct drm_master *drm_master_create(struct drm_device *dev)\r\n{\r\nstruct drm_master *master;\r\nmaster = kzalloc(sizeof(*master), GFP_KERNEL);\r\nif (!master)\r\nreturn NULL;\r\nkref_init(&master->refcount);\r\nspin_lock_init(&master->lock.spinlock);\r\ninit_waitqueue_head(&master->lock.lock_queue);\r\nidr_init(&master->magic_map);\r\nmaster->dev = dev;\r\nreturn master;\r\n}\r\nstatic int drm_set_master(struct drm_device *dev, struct drm_file *fpriv,\r\nbool new_master)\r\n{\r\nint ret = 0;\r\ndev->master = drm_master_get(fpriv->master);\r\nif (dev->driver->master_set) {\r\nret = dev->driver->master_set(dev, fpriv, new_master);\r\nif (unlikely(ret != 0)) {\r\ndrm_master_put(&dev->master);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int drm_new_set_master(struct drm_device *dev, struct drm_file *fpriv)\r\n{\r\nstruct drm_master *old_master;\r\nint ret;\r\nlockdep_assert_held_once(&dev->master_mutex);\r\nold_master = fpriv->master;\r\nfpriv->master = drm_master_create(dev);\r\nif (!fpriv->master) {\r\nfpriv->master = old_master;\r\nreturn -ENOMEM;\r\n}\r\nif (dev->driver->master_create) {\r\nret = dev->driver->master_create(dev, fpriv->master);\r\nif (ret)\r\ngoto out_err;\r\n}\r\nfpriv->is_master = 1;\r\nfpriv->authenticated = 1;\r\nret = drm_set_master(dev, fpriv, true);\r\nif (ret)\r\ngoto out_err;\r\nif (old_master)\r\ndrm_master_put(&old_master);\r\nreturn 0;\r\nout_err:\r\ndrm_master_put(&fpriv->master);\r\nfpriv->master = old_master;\r\nreturn ret;\r\n}\r\nint drm_setmaster_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nint ret = 0;\r\nmutex_lock(&dev->master_mutex);\r\nif (drm_is_current_master(file_priv))\r\ngoto out_unlock;\r\nif (dev->master) {\r\nret = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nif (!file_priv->master) {\r\nret = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nif (!file_priv->is_master) {\r\nret = drm_new_set_master(dev, file_priv);\r\ngoto out_unlock;\r\n}\r\nret = drm_set_master(dev, file_priv, false);\r\nout_unlock:\r\nmutex_unlock(&dev->master_mutex);\r\nreturn ret;\r\n}\r\nstatic void drm_drop_master(struct drm_device *dev,\r\nstruct drm_file *fpriv)\r\n{\r\nif (dev->driver->master_drop)\r\ndev->driver->master_drop(dev, fpriv);\r\ndrm_master_put(&dev->master);\r\n}\r\nint drm_dropmaster_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nint ret = -EINVAL;\r\nmutex_lock(&dev->master_mutex);\r\nif (!drm_is_current_master(file_priv))\r\ngoto out_unlock;\r\nif (!dev->master)\r\ngoto out_unlock;\r\nret = 0;\r\ndrm_drop_master(dev, file_priv);\r\nout_unlock:\r\nmutex_unlock(&dev->master_mutex);\r\nreturn ret;\r\n}\r\nint drm_master_open(struct drm_file *file_priv)\r\n{\r\nstruct drm_device *dev = file_priv->minor->dev;\r\nint ret = 0;\r\nmutex_lock(&dev->master_mutex);\r\nif (!dev->master)\r\nret = drm_new_set_master(dev, file_priv);\r\nelse\r\nfile_priv->master = drm_master_get(dev->master);\r\nmutex_unlock(&dev->master_mutex);\r\nreturn ret;\r\n}\r\nvoid drm_master_release(struct drm_file *file_priv)\r\n{\r\nstruct drm_device *dev = file_priv->minor->dev;\r\nstruct drm_master *master = file_priv->master;\r\nmutex_lock(&dev->master_mutex);\r\nif (file_priv->magic)\r\nidr_remove(&file_priv->master->magic_map, file_priv->magic);\r\nif (!drm_is_current_master(file_priv))\r\ngoto out;\r\nif (drm_core_check_feature(dev, DRIVER_LEGACY)) {\r\nmutex_lock(&dev->struct_mutex);\r\nif (master->lock.hw_lock) {\r\nif (dev->sigdata.lock == master->lock.hw_lock)\r\ndev->sigdata.lock = NULL;\r\nmaster->lock.hw_lock = NULL;\r\nmaster->lock.file_priv = NULL;\r\nwake_up_interruptible_all(&master->lock.lock_queue);\r\n}\r\nmutex_unlock(&dev->struct_mutex);\r\n}\r\nif (dev->master == file_priv->master)\r\ndrm_drop_master(dev, file_priv);\r\nout:\r\nif (file_priv->master)\r\ndrm_master_put(&file_priv->master);\r\nmutex_unlock(&dev->master_mutex);\r\n}\r\nbool drm_is_current_master(struct drm_file *fpriv)\r\n{\r\nreturn fpriv->is_master && fpriv->master == fpriv->minor->dev->master;\r\n}\r\nstruct drm_master *drm_master_get(struct drm_master *master)\r\n{\r\nkref_get(&master->refcount);\r\nreturn master;\r\n}\r\nstatic void drm_master_destroy(struct kref *kref)\r\n{\r\nstruct drm_master *master = container_of(kref, struct drm_master, refcount);\r\nstruct drm_device *dev = master->dev;\r\nif (dev->driver->master_destroy)\r\ndev->driver->master_destroy(dev, master);\r\ndrm_legacy_master_rmmaps(dev, master);\r\nidr_destroy(&master->magic_map);\r\nkfree(master->unique);\r\nkfree(master);\r\n}\r\nvoid drm_master_put(struct drm_master **master)\r\n{\r\nkref_put(&(*master)->refcount, drm_master_destroy);\r\n*master = NULL;\r\n}
