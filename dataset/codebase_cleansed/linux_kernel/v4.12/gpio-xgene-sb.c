static void xgene_gpio_set_bit(struct gpio_chip *gc,\r\nvoid __iomem *reg, u32 gpio, int val)\r\n{\r\nu32 data;\r\ndata = gc->read_reg(reg);\r\nif (val)\r\ndata |= GPIO_MASK(gpio);\r\nelse\r\ndata &= ~GPIO_MASK(gpio);\r\ngc->write_reg(reg, data);\r\n}\r\nstatic int xgene_gpio_sb_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct xgene_gpio_sb *priv = irq_data_get_irq_chip_data(d);\r\nint gpio = HWIRQ_TO_GPIO(priv, d->hwirq);\r\nint lvl_type = GPIO_INT_LEVEL_H;\r\nswitch (type & IRQ_TYPE_SENSE_MASK) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nlvl_type = GPIO_INT_LEVEL_H;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nlvl_type = GPIO_INT_LEVEL_L;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nxgene_gpio_set_bit(&priv->gc, priv->regs + MPA_GPIO_SEL_LO,\r\ngpio * 2, 1);\r\nxgene_gpio_set_bit(&priv->gc, priv->regs + MPA_GPIO_INT_LVL,\r\nd->hwirq, lvl_type);\r\nif (type & IRQ_TYPE_EDGE_BOTH)\r\nreturn irq_chip_set_type_parent(d, IRQ_TYPE_EDGE_RISING);\r\nelse\r\nreturn irq_chip_set_type_parent(d, IRQ_TYPE_LEVEL_HIGH);\r\n}\r\nstatic int xgene_gpio_sb_to_irq(struct gpio_chip *gc, u32 gpio)\r\n{\r\nstruct xgene_gpio_sb *priv = gpiochip_get_data(gc);\r\nstruct irq_fwspec fwspec;\r\nif ((gpio < priv->irq_start) ||\r\n(gpio > HWIRQ_TO_GPIO(priv, priv->nirq)))\r\nreturn -ENXIO;\r\nif (gc->parent->of_node)\r\nfwspec.fwnode = of_node_to_fwnode(gc->parent->of_node);\r\nelse\r\nfwspec.fwnode = gc->parent->fwnode;\r\nfwspec.param_count = 2;\r\nfwspec.param[0] = GPIO_TO_HWIRQ(priv, gpio);\r\nfwspec.param[1] = IRQ_TYPE_NONE;\r\nreturn irq_create_fwspec_mapping(&fwspec);\r\n}\r\nstatic void xgene_gpio_sb_domain_activate(struct irq_domain *d,\r\nstruct irq_data *irq_data)\r\n{\r\nstruct xgene_gpio_sb *priv = d->host_data;\r\nu32 gpio = HWIRQ_TO_GPIO(priv, irq_data->hwirq);\r\nif (gpiochip_lock_as_irq(&priv->gc, gpio)) {\r\ndev_err(priv->gc.parent,\r\n"Unable to configure XGene GPIO standby pin %d as IRQ\n",\r\ngpio);\r\nreturn;\r\n}\r\nxgene_gpio_set_bit(&priv->gc, priv->regs + MPA_GPIO_SEL_LO,\r\ngpio * 2, 1);\r\n}\r\nstatic void xgene_gpio_sb_domain_deactivate(struct irq_domain *d,\r\nstruct irq_data *irq_data)\r\n{\r\nstruct xgene_gpio_sb *priv = d->host_data;\r\nu32 gpio = HWIRQ_TO_GPIO(priv, irq_data->hwirq);\r\ngpiochip_unlock_as_irq(&priv->gc, gpio);\r\nxgene_gpio_set_bit(&priv->gc, priv->regs + MPA_GPIO_SEL_LO,\r\ngpio * 2, 0);\r\n}\r\nstatic int xgene_gpio_sb_domain_translate(struct irq_domain *d,\r\nstruct irq_fwspec *fwspec,\r\nunsigned long *hwirq,\r\nunsigned int *type)\r\n{\r\nstruct xgene_gpio_sb *priv = d->host_data;\r\nif ((fwspec->param_count != 2) ||\r\n(fwspec->param[0] >= priv->nirq))\r\nreturn -EINVAL;\r\n*hwirq = fwspec->param[0];\r\n*type = fwspec->param[1];\r\nreturn 0;\r\n}\r\nstatic int xgene_gpio_sb_domain_alloc(struct irq_domain *domain,\r\nunsigned int virq,\r\nunsigned int nr_irqs, void *data)\r\n{\r\nstruct irq_fwspec *fwspec = data;\r\nstruct irq_fwspec parent_fwspec;\r\nstruct xgene_gpio_sb *priv = domain->host_data;\r\nirq_hw_number_t hwirq;\r\nunsigned int i;\r\nhwirq = fwspec->param[0];\r\nfor (i = 0; i < nr_irqs; i++)\r\nirq_domain_set_hwirq_and_chip(domain, virq + i, hwirq + i,\r\n&xgene_gpio_sb_irq_chip, priv);\r\nparent_fwspec.fwnode = domain->parent->fwnode;\r\nif (is_of_node(parent_fwspec.fwnode)) {\r\nparent_fwspec.param_count = 3;\r\nparent_fwspec.param[0] = 0;\r\nparent_fwspec.param[1] = hwirq + priv->parent_irq_base - 32;\r\nparent_fwspec.param[2] = fwspec->param[1];\r\n} else if (is_fwnode_irqchip(parent_fwspec.fwnode)) {\r\nparent_fwspec.param_count = 2;\r\nparent_fwspec.param[0] = hwirq + priv->parent_irq_base;\r\nparent_fwspec.param[1] = fwspec->param[1];\r\n} else\r\nreturn -EINVAL;\r\nreturn irq_domain_alloc_irqs_parent(domain, virq, nr_irqs,\r\n&parent_fwspec);\r\n}\r\nstatic int xgene_gpio_sb_probe(struct platform_device *pdev)\r\n{\r\nstruct xgene_gpio_sb *priv;\r\nint ret;\r\nstruct resource *res;\r\nvoid __iomem *regs;\r\nstruct irq_domain *parent_domain = NULL;\r\nstruct fwnode_handle *fwnode;\r\nu32 val32;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nregs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(regs))\r\nreturn PTR_ERR(regs);\r\npriv->regs = regs;\r\nret = platform_get_irq(pdev, 0);\r\nif (ret > 0) {\r\npriv->parent_irq_base = irq_get_irq_data(ret)->hwirq;\r\nparent_domain = irq_get_irq_data(ret)->domain;\r\n}\r\nif (!parent_domain) {\r\ndev_err(&pdev->dev, "unable to obtain parent domain\n");\r\nreturn -ENODEV;\r\n}\r\nret = bgpio_init(&priv->gc, &pdev->dev, 4,\r\nregs + MPA_GPIO_IN_ADDR,\r\nregs + MPA_GPIO_OUT_ADDR, NULL,\r\nregs + MPA_GPIO_OE_ADDR, NULL, 0);\r\nif (ret)\r\nreturn ret;\r\npriv->gc.to_irq = xgene_gpio_sb_to_irq;\r\npriv->irq_start = XGENE_DFLT_IRQ_START_PIN;\r\nif (!device_property_read_u32(&pdev->dev,\r\nXGENE_IRQ_START_PROPERTY, &val32))\r\npriv->irq_start = val32;\r\npriv->nirq = XGENE_DFLT_MAX_NIRQ;\r\nif (!device_property_read_u32(&pdev->dev, XGENE_NIRQ_PROPERTY, &val32))\r\npriv->nirq = val32;\r\npriv->gc.ngpio = XGENE_DFLT_MAX_NGPIO;\r\nif (!device_property_read_u32(&pdev->dev, XGENE_NGPIO_PROPERTY, &val32))\r\npriv->gc.ngpio = val32;\r\ndev_info(&pdev->dev, "Support %d gpios, %d irqs start from pin %d\n",\r\npriv->gc.ngpio, priv->nirq, priv->irq_start);\r\nplatform_set_drvdata(pdev, priv);\r\nif (pdev->dev.of_node)\r\nfwnode = of_node_to_fwnode(pdev->dev.of_node);\r\nelse\r\nfwnode = pdev->dev.fwnode;\r\npriv->irq_domain = irq_domain_create_hierarchy(parent_domain,\r\n0, priv->nirq, fwnode,\r\n&xgene_gpio_sb_domain_ops, priv);\r\nif (!priv->irq_domain)\r\nreturn -ENODEV;\r\npriv->gc.irqdomain = priv->irq_domain;\r\nret = devm_gpiochip_add_data(&pdev->dev, &priv->gc, priv);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"failed to register X-Gene GPIO Standby driver\n");\r\nirq_domain_remove(priv->irq_domain);\r\nreturn ret;\r\n}\r\ndev_info(&pdev->dev, "X-Gene GPIO Standby driver registered\n");\r\nif (priv->nirq > 0) {\r\nacpi_gpiochip_request_interrupts(&priv->gc);\r\n}\r\nreturn ret;\r\n}\r\nstatic int xgene_gpio_sb_remove(struct platform_device *pdev)\r\n{\r\nstruct xgene_gpio_sb *priv = platform_get_drvdata(pdev);\r\nif (priv->nirq > 0) {\r\nacpi_gpiochip_free_interrupts(&priv->gc);\r\n}\r\nirq_domain_remove(priv->irq_domain);\r\nreturn 0;\r\n}
