static inline int mdc_queue_wait(struct ptlrpc_request *req)\r\n{\r\nstruct client_obd *cli = &req->rq_import->imp_obd->u.cli;\r\nint rc;\r\nrc = obd_get_request_slot(cli);\r\nif (rc != 0)\r\nreturn rc;\r\nrc = ptlrpc_queue_wait(req);\r\nobd_put_request_slot(cli);\r\nreturn rc;\r\n}\r\nstatic int mdc_getstatus(struct obd_export *exp, struct lu_fid *rootfid)\r\n{\r\nstruct ptlrpc_request *req;\r\nstruct mdt_body *body;\r\nint rc;\r\nreq = ptlrpc_request_alloc_pack(class_exp2cliimp(exp),\r\n&RQF_MDS_GETSTATUS,\r\nLUSTRE_MDS_VERSION, MDS_GETSTATUS);\r\nif (!req)\r\nreturn -ENOMEM;\r\nmdc_pack_body(req, NULL, 0, 0, -1, 0);\r\nreq->rq_send_state = LUSTRE_IMP_FULL;\r\nptlrpc_request_set_replen(req);\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc)\r\ngoto out;\r\nbody = req_capsule_server_get(&req->rq_pill, &RMF_MDT_BODY);\r\nif (!body) {\r\nrc = -EPROTO;\r\ngoto out;\r\n}\r\n*rootfid = body->mbo_fid1;\r\nCDEBUG(D_NET,\r\n"root fid="DFID", last_committed=%llu\n",\r\nPFID(rootfid),\r\nlustre_msg_get_last_committed(req->rq_repmsg));\r\nout:\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic int mdc_getattr_common(struct obd_export *exp,\r\nstruct ptlrpc_request *req)\r\n{\r\nstruct req_capsule *pill = &req->rq_pill;\r\nstruct mdt_body *body;\r\nvoid *eadata;\r\nint rc;\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc != 0)\r\nreturn rc;\r\nbody = req_capsule_server_get(pill, &RMF_MDT_BODY);\r\nif (!body)\r\nreturn -EPROTO;\r\nCDEBUG(D_NET, "mode: %o\n", body->mbo_mode);\r\nmdc_update_max_ea_from_body(exp, body);\r\nif (body->mbo_eadatasize != 0) {\r\neadata = req_capsule_server_sized_get(pill, &RMF_MDT_MD,\r\nbody->mbo_eadatasize);\r\nif (!eadata)\r\nreturn -EPROTO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mdc_getattr(struct obd_export *exp, struct md_op_data *op_data,\r\nstruct ptlrpc_request **request)\r\n{\r\nstruct ptlrpc_request *req;\r\nint rc;\r\nif (op_data->op_flags & MF_GET_MDT_IDX) {\r\nop_data->op_mds = 0;\r\nreturn 0;\r\n}\r\n*request = NULL;\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp), &RQF_MDS_GETATTR);\r\nif (!req)\r\nreturn -ENOMEM;\r\nrc = ptlrpc_request_pack(req, LUSTRE_MDS_VERSION, MDS_GETATTR);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nmdc_pack_body(req, &op_data->op_fid1, op_data->op_valid,\r\nop_data->op_mode, -1, 0);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_MDT_MD, RCL_SERVER,\r\nop_data->op_mode);\r\nptlrpc_request_set_replen(req);\r\nrc = mdc_getattr_common(exp, req);\r\nif (rc)\r\nptlrpc_req_finished(req);\r\nelse\r\n*request = req;\r\nreturn rc;\r\n}\r\nstatic int mdc_getattr_name(struct obd_export *exp, struct md_op_data *op_data,\r\nstruct ptlrpc_request **request)\r\n{\r\nstruct ptlrpc_request *req;\r\nint rc;\r\n*request = NULL;\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp),\r\n&RQF_MDS_GETATTR_NAME);\r\nif (!req)\r\nreturn -ENOMEM;\r\nreq_capsule_set_size(&req->rq_pill, &RMF_NAME, RCL_CLIENT,\r\nop_data->op_namelen + 1);\r\nrc = ptlrpc_request_pack(req, LUSTRE_MDS_VERSION, MDS_GETATTR_NAME);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nmdc_pack_body(req, &op_data->op_fid1, op_data->op_valid,\r\nop_data->op_mode, op_data->op_suppgids[0], 0);\r\nif (op_data->op_name) {\r\nchar *name = req_capsule_client_get(&req->rq_pill, &RMF_NAME);\r\nLASSERT(strnlen(op_data->op_name, op_data->op_namelen) ==\r\nop_data->op_namelen);\r\nmemcpy(name, op_data->op_name, op_data->op_namelen);\r\n}\r\nreq_capsule_set_size(&req->rq_pill, &RMF_MDT_MD, RCL_SERVER,\r\nop_data->op_mode);\r\nptlrpc_request_set_replen(req);\r\nrc = mdc_getattr_common(exp, req);\r\nif (rc)\r\nptlrpc_req_finished(req);\r\nelse\r\n*request = req;\r\nreturn rc;\r\n}\r\nstatic int mdc_xattr_common(struct obd_export *exp,\r\nconst struct req_format *fmt,\r\nconst struct lu_fid *fid,\r\nint opcode, u64 valid,\r\nconst char *xattr_name, const char *input,\r\nint input_size, int output_size, int flags,\r\n__u32 suppgid, struct ptlrpc_request **request)\r\n{\r\nstruct ptlrpc_request *req;\r\nint xattr_namelen = 0;\r\nchar *tmp;\r\nint rc;\r\n*request = NULL;\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp), fmt);\r\nif (!req)\r\nreturn -ENOMEM;\r\nif (xattr_name) {\r\nxattr_namelen = strlen(xattr_name) + 1;\r\nreq_capsule_set_size(&req->rq_pill, &RMF_NAME, RCL_CLIENT,\r\nxattr_namelen);\r\n}\r\nif (input_size) {\r\nLASSERT(input);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_EADATA, RCL_CLIENT,\r\ninput_size);\r\n}\r\nif (opcode == MDS_REINT && fid_is_sane(fid) &&\r\nexp->exp_connect_data.ocd_ibits_known & MDS_INODELOCK_XATTR) {\r\nLIST_HEAD(cancels);\r\nint count;\r\nif (input_size == 0)\r\nreq_capsule_set_size(&req->rq_pill, &RMF_EADATA,\r\nRCL_CLIENT, 0);\r\ncount = mdc_resource_get_unused(exp, fid,\r\n&cancels, LCK_EX,\r\nMDS_INODELOCK_XATTR);\r\nrc = mdc_prep_elc_req(exp, req, MDS_REINT, &cancels, count);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\n} else {\r\nrc = ptlrpc_request_pack(req, LUSTRE_MDS_VERSION, opcode);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\n}\r\nif (opcode == MDS_REINT) {\r\nstruct mdt_rec_setxattr *rec;\r\nBUILD_BUG_ON(sizeof(struct mdt_rec_setxattr) !=\r\nsizeof(struct mdt_rec_reint));\r\nrec = req_capsule_client_get(&req->rq_pill, &RMF_REC_REINT);\r\nrec->sx_opcode = REINT_SETXATTR;\r\nrec->sx_fsuid = from_kuid(&init_user_ns, current_fsuid());\r\nrec->sx_fsgid = from_kgid(&init_user_ns, current_fsgid());\r\nrec->sx_cap = cfs_curproc_cap_pack();\r\nrec->sx_suppgid1 = suppgid;\r\nrec->sx_suppgid2 = -1;\r\nrec->sx_fid = *fid;\r\nrec->sx_valid = valid | OBD_MD_FLCTIME;\r\nrec->sx_time = ktime_get_real_seconds();\r\nrec->sx_size = output_size;\r\nrec->sx_flags = flags;\r\n} else {\r\nmdc_pack_body(req, fid, valid, output_size, suppgid, flags);\r\n}\r\nif (xattr_name) {\r\ntmp = req_capsule_client_get(&req->rq_pill, &RMF_NAME);\r\nmemcpy(tmp, xattr_name, xattr_namelen);\r\n}\r\nif (input_size) {\r\ntmp = req_capsule_client_get(&req->rq_pill, &RMF_EADATA);\r\nmemcpy(tmp, input, input_size);\r\n}\r\nif (req_capsule_has_field(&req->rq_pill, &RMF_EADATA, RCL_SERVER))\r\nreq_capsule_set_size(&req->rq_pill, &RMF_EADATA,\r\nRCL_SERVER, output_size);\r\nptlrpc_request_set_replen(req);\r\nif (opcode == MDS_REINT)\r\nmdc_get_mod_rpc_slot(req, NULL);\r\nrc = ptlrpc_queue_wait(req);\r\nif (opcode == MDS_REINT)\r\nmdc_put_mod_rpc_slot(req, NULL);\r\nif (rc)\r\nptlrpc_req_finished(req);\r\nelse\r\n*request = req;\r\nreturn rc;\r\n}\r\nstatic int mdc_setxattr(struct obd_export *exp, const struct lu_fid *fid,\r\nu64 valid, const char *xattr_name,\r\nconst char *input, int input_size, int output_size,\r\nint flags, __u32 suppgid,\r\nstruct ptlrpc_request **request)\r\n{\r\nreturn mdc_xattr_common(exp, &RQF_MDS_REINT_SETXATTR,\r\nfid, MDS_REINT, valid, xattr_name,\r\ninput, input_size, output_size, flags,\r\nsuppgid, request);\r\n}\r\nstatic int mdc_getxattr(struct obd_export *exp, const struct lu_fid *fid,\r\nu64 valid, const char *xattr_name,\r\nconst char *input, int input_size, int output_size,\r\nint flags, struct ptlrpc_request **request)\r\n{\r\nreturn mdc_xattr_common(exp, &RQF_MDS_GETXATTR,\r\nfid, MDS_GETXATTR, valid, xattr_name,\r\ninput, input_size, output_size, flags,\r\n-1, request);\r\n}\r\nstatic int mdc_unpack_acl(struct ptlrpc_request *req, struct lustre_md *md)\r\n{\r\nstruct req_capsule *pill = &req->rq_pill;\r\nstruct mdt_body *body = md->body;\r\nstruct posix_acl *acl;\r\nvoid *buf;\r\nint rc;\r\nif (!body->mbo_aclsize)\r\nreturn 0;\r\nbuf = req_capsule_server_sized_get(pill, &RMF_ACL, body->mbo_aclsize);\r\nif (!buf)\r\nreturn -EPROTO;\r\nacl = posix_acl_from_xattr(&init_user_ns, buf, body->mbo_aclsize);\r\nif (!acl)\r\nreturn 0;\r\nif (IS_ERR(acl)) {\r\nrc = PTR_ERR(acl);\r\nCERROR("convert xattr to acl: %d\n", rc);\r\nreturn rc;\r\n}\r\nrc = posix_acl_valid(&init_user_ns, acl);\r\nif (rc) {\r\nCERROR("validate acl: %d\n", rc);\r\nposix_acl_release(acl);\r\nreturn rc;\r\n}\r\nmd->posix_acl = acl;\r\nreturn 0;\r\n}\r\nstatic int mdc_get_lustre_md(struct obd_export *exp,\r\nstruct ptlrpc_request *req,\r\nstruct obd_export *dt_exp,\r\nstruct obd_export *md_exp,\r\nstruct lustre_md *md)\r\n{\r\nstruct req_capsule *pill = &req->rq_pill;\r\nint rc;\r\nLASSERT(md);\r\nmemset(md, 0, sizeof(*md));\r\nmd->body = req_capsule_server_get(pill, &RMF_MDT_BODY);\r\nif (md->body->mbo_valid & OBD_MD_FLEASIZE) {\r\nif (!S_ISREG(md->body->mbo_mode)) {\r\nCDEBUG(D_INFO,\r\n"OBD_MD_FLEASIZE set, should be a regular file, but is not\n");\r\nrc = -EPROTO;\r\ngoto out;\r\n}\r\nif (md->body->mbo_eadatasize == 0) {\r\nCDEBUG(D_INFO,\r\n"OBD_MD_FLEASIZE set, but eadatasize 0\n");\r\nrc = -EPROTO;\r\ngoto out;\r\n}\r\nmd->layout.lb_len = md->body->mbo_eadatasize;\r\nmd->layout.lb_buf = req_capsule_server_sized_get(pill,\r\n&RMF_MDT_MD,\r\nmd->layout.lb_len);\r\nif (!md->layout.lb_buf) {\r\nrc = -EPROTO;\r\ngoto out;\r\n}\r\n} else if (md->body->mbo_valid & OBD_MD_FLDIREA) {\r\nconst union lmv_mds_md *lmv;\r\nsize_t lmv_size;\r\nif (!S_ISDIR(md->body->mbo_mode)) {\r\nCDEBUG(D_INFO,\r\n"OBD_MD_FLDIREA set, should be a directory, but is not\n");\r\nrc = -EPROTO;\r\ngoto out;\r\n}\r\nlmv_size = md->body->mbo_eadatasize;\r\nif (!lmv_size) {\r\nCDEBUG(D_INFO,\r\n"OBD_MD_FLDIREA is set, but eadatasize 0\n");\r\nreturn -EPROTO;\r\n}\r\nif (md->body->mbo_valid & OBD_MD_MEA) {\r\nlmv = req_capsule_server_sized_get(pill, &RMF_MDT_MD,\r\nlmv_size);\r\nif (!lmv) {\r\nrc = -EPROTO;\r\ngoto out;\r\n}\r\nrc = md_unpackmd(md_exp, &md->lmv, lmv, lmv_size);\r\nif (rc < 0)\r\ngoto out;\r\nif (rc < (typeof(rc))sizeof(*md->lmv)) {\r\nCDEBUG(D_INFO,\r\n"size too small: rc < sizeof(*md->lmv) (%d < %d)\n",\r\nrc, (int)sizeof(*md->lmv));\r\nrc = -EPROTO;\r\ngoto out;\r\n}\r\n}\r\n}\r\nrc = 0;\r\nif (md->body->mbo_valid & OBD_MD_FLACL) {\r\nif (md->body->mbo_aclsize) {\r\nrc = mdc_unpack_acl(req, md);\r\nif (rc)\r\ngoto out;\r\n#ifdef CONFIG_FS_POSIX_ACL\r\n} else {\r\nmd->posix_acl = NULL;\r\n#endif\r\n}\r\n}\r\nout:\r\nif (rc) {\r\n#ifdef CONFIG_FS_POSIX_ACL\r\nposix_acl_release(md->posix_acl);\r\n#endif\r\n}\r\nreturn rc;\r\n}\r\nstatic int mdc_free_lustre_md(struct obd_export *exp, struct lustre_md *md)\r\n{\r\nreturn 0;\r\n}\r\nvoid mdc_replay_open(struct ptlrpc_request *req)\r\n{\r\nstruct md_open_data *mod = req->rq_cb_data;\r\nstruct ptlrpc_request *close_req;\r\nstruct obd_client_handle *och;\r\nstruct lustre_handle old;\r\nstruct mdt_body *body;\r\nif (!mod) {\r\nDEBUG_REQ(D_ERROR, req,\r\n"Can't properly replay without open data.");\r\nreturn;\r\n}\r\nbody = req_capsule_server_get(&req->rq_pill, &RMF_MDT_BODY);\r\noch = mod->mod_och;\r\nif (och) {\r\nstruct lustre_handle *file_fh;\r\nLASSERT(och->och_magic == OBD_CLIENT_HANDLE_MAGIC);\r\nfile_fh = &och->och_fh;\r\nCDEBUG(D_HA, "updating handle from %#llx to %#llx\n",\r\nfile_fh->cookie, body->mbo_handle.cookie);\r\nold = *file_fh;\r\n*file_fh = body->mbo_handle;\r\n}\r\nclose_req = mod->mod_close_req;\r\nif (close_req) {\r\n__u32 opc = lustre_msg_get_opc(close_req->rq_reqmsg);\r\nstruct mdt_ioepoch *epoch;\r\nLASSERT(opc == MDS_CLOSE);\r\nepoch = req_capsule_client_get(&close_req->rq_pill,\r\n&RMF_MDT_EPOCH);\r\nLASSERT(epoch);\r\nif (och)\r\nLASSERT(!memcmp(&old, &epoch->mio_handle, sizeof(old)));\r\nDEBUG_REQ(D_HA, close_req, "updating close body with new fh");\r\nepoch->mio_handle = body->mbo_handle;\r\n}\r\n}\r\nvoid mdc_commit_open(struct ptlrpc_request *req)\r\n{\r\nstruct md_open_data *mod = req->rq_cb_data;\r\nif (!mod)\r\nreturn;\r\nptlrpc_request_addref(req);\r\nspin_lock(&req->rq_lock);\r\nreq->rq_committed = 1;\r\nspin_unlock(&req->rq_lock);\r\nreq->rq_cb_data = NULL;\r\nobd_mod_put(mod);\r\n}\r\nint mdc_set_open_replay_data(struct obd_export *exp,\r\nstruct obd_client_handle *och,\r\nstruct lookup_intent *it)\r\n{\r\nstruct md_open_data *mod;\r\nstruct mdt_rec_create *rec;\r\nstruct mdt_body *body;\r\nstruct ptlrpc_request *open_req = it->it_request;\r\nstruct obd_import *imp = open_req->rq_import;\r\nif (!open_req->rq_replay)\r\nreturn 0;\r\nrec = req_capsule_client_get(&open_req->rq_pill, &RMF_REC_REINT);\r\nbody = req_capsule_server_get(&open_req->rq_pill, &RMF_MDT_BODY);\r\nLASSERT(rec);\r\nLASSERT(body);\r\nif (och && imp->imp_replayable) {\r\nmod = obd_mod_alloc();\r\nif (!mod) {\r\nDEBUG_REQ(D_ERROR, open_req,\r\n"Can't allocate md_open_data");\r\nreturn 0;\r\n}\r\nobd_mod_get(mod);\r\nobd_mod_get(mod);\r\nspin_lock(&open_req->rq_lock);\r\noch->och_mod = mod;\r\nmod->mod_och = och;\r\nmod->mod_is_create = it_disposition(it, DISP_OPEN_CREATE) ||\r\nit_disposition(it, DISP_OPEN_STRIPE);\r\nmod->mod_open_req = open_req;\r\nopen_req->rq_cb_data = mod;\r\nopen_req->rq_commit_cb = mdc_commit_open;\r\nspin_unlock(&open_req->rq_lock);\r\n}\r\nrec->cr_fid2 = body->mbo_fid1;\r\nrec->cr_ioepoch = body->mbo_ioepoch;\r\nrec->cr_old_handle.cookie = body->mbo_handle.cookie;\r\nopen_req->rq_replay_cb = mdc_replay_open;\r\nif (!fid_is_sane(&body->mbo_fid1)) {\r\nDEBUG_REQ(D_ERROR, open_req,\r\n"Saving replay request with insane fid");\r\nLBUG();\r\n}\r\nDEBUG_REQ(D_RPCTRACE, open_req, "Set up open replay data");\r\nreturn 0;\r\n}\r\nstatic void mdc_free_open(struct md_open_data *mod)\r\n{\r\nint committed = 0;\r\nif (mod->mod_is_create == 0 &&\r\nimp_connect_disp_stripe(mod->mod_open_req->rq_import))\r\ncommitted = 1;\r\nDEBUG_REQ(D_RPCTRACE, mod->mod_open_req,\r\n"free open request rq_replay = %d\n",\r\nmod->mod_open_req->rq_replay);\r\nptlrpc_request_committed(mod->mod_open_req, committed);\r\nif (mod->mod_close_req)\r\nptlrpc_request_committed(mod->mod_close_req, committed);\r\n}\r\nstatic int mdc_clear_open_replay_data(struct obd_export *exp,\r\nstruct obd_client_handle *och)\r\n{\r\nstruct md_open_data *mod = och->och_mod;\r\nif (!mod)\r\nreturn 0;\r\nLASSERT(mod != LP_POISON);\r\nLASSERT(mod->mod_open_req);\r\nmdc_free_open(mod);\r\nmod->mod_och = NULL;\r\noch->och_mod = NULL;\r\nobd_mod_put(mod);\r\nreturn 0;\r\n}\r\nstatic int mdc_close(struct obd_export *exp, struct md_op_data *op_data,\r\nstruct md_open_data *mod, struct ptlrpc_request **request)\r\n{\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nstruct ptlrpc_request *req;\r\nstruct req_format *req_fmt;\r\nint rc;\r\nint saved_rc = 0;\r\nif (op_data->op_bias & MDS_HSM_RELEASE) {\r\nreq_fmt = &RQF_MDS_INTENT_CLOSE;\r\nrc = mdc_fid_alloc(NULL, exp, &op_data->op_fid2, op_data);\r\nif (rc < 0) {\r\nCERROR("%s: "DFID" failed to allocate FID: %d\n",\r\nobd->obd_name, PFID(&op_data->op_fid1), rc);\r\nsaved_rc = rc;\r\n}\r\n} else if (op_data->op_bias & MDS_CLOSE_LAYOUT_SWAP) {\r\nreq_fmt = &RQF_MDS_INTENT_CLOSE;\r\n} else {\r\nreq_fmt = &RQF_MDS_CLOSE;\r\n}\r\n*request = NULL;\r\nif (OBD_FAIL_CHECK(OBD_FAIL_MDC_CLOSE))\r\nreq = NULL;\r\nelse\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp), req_fmt);\r\nif (likely(mod)) {\r\nLASSERTF(mod->mod_open_req &&\r\nmod->mod_open_req->rq_type != LI_POISON,\r\n"POISONED open %p!\n", mod->mod_open_req);\r\nmod->mod_close_req = req;\r\nDEBUG_REQ(D_HA, mod->mod_open_req, "matched open");\r\nspin_lock(&mod->mod_open_req->rq_lock);\r\nmod->mod_open_req->rq_replay = 0;\r\nspin_unlock(&mod->mod_open_req->rq_lock);\r\n} else {\r\nCDEBUG(D_HA,\r\n"couldn't find open req; expecting close error\n");\r\n}\r\nif (!req) {\r\nCWARN("%s: close of FID "DFID" failed, file reference will be dropped when this client unmounts or is evicted\n",\r\nobd->obd_name, PFID(&op_data->op_fid1));\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nrc = ptlrpc_request_pack(req, LUSTRE_MDS_VERSION, MDS_CLOSE);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreq = NULL;\r\ngoto out;\r\n}\r\nreq->rq_request_portal = MDS_READPAGE_PORTAL;\r\nptlrpc_at_set_req_timeout(req);\r\nmdc_close_pack(req, op_data);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_MDT_MD, RCL_SERVER,\r\nobd->u.cli.cl_default_mds_easize);\r\nptlrpc_request_set_replen(req);\r\nmdc_get_mod_rpc_slot(req, NULL);\r\nrc = ptlrpc_queue_wait(req);\r\nmdc_put_mod_rpc_slot(req, NULL);\r\nif (!req->rq_repmsg) {\r\nCDEBUG(D_RPCTRACE, "request failed to send: %p, %d\n", req,\r\nreq->rq_status);\r\nif (rc == 0)\r\nrc = req->rq_status ?: -EIO;\r\n} else if (rc == 0 || rc == -EAGAIN) {\r\nstruct mdt_body *body;\r\nrc = lustre_msg_get_status(req->rq_repmsg);\r\nif (lustre_msg_get_type(req->rq_repmsg) == PTL_RPC_MSG_ERR) {\r\nDEBUG_REQ(D_ERROR, req,\r\n"type == PTL_RPC_MSG_ERR, err = %d", rc);\r\nif (rc > 0)\r\nrc = -rc;\r\n}\r\nbody = req_capsule_server_get(&req->rq_pill, &RMF_MDT_BODY);\r\nif (!body)\r\nrc = -EPROTO;\r\n} else if (rc == -ESTALE) {\r\nif (mod) {\r\nDEBUG_REQ(D_HA, req, "Reset ESTALE = %d", rc);\r\nif (mod->mod_open_req->rq_committed)\r\nrc = 0;\r\n}\r\n}\r\nout:\r\nif (mod) {\r\nif (rc != 0)\r\nmod->mod_close_req = NULL;\r\nobd_mod_put(mod);\r\n}\r\n*request = req;\r\nreturn rc < 0 ? rc : saved_rc;\r\n}\r\nstatic int mdc_getpage(struct obd_export *exp, const struct lu_fid *fid,\r\nu64 offset, struct page **pages, int npages,\r\nstruct ptlrpc_request **request)\r\n{\r\nstruct ptlrpc_bulk_desc *desc;\r\nstruct ptlrpc_request *req;\r\nwait_queue_head_t waitq;\r\nstruct l_wait_info lwi;\r\nint resends = 0;\r\nint rc;\r\nint i;\r\n*request = NULL;\r\ninit_waitqueue_head(&waitq);\r\nrestart_bulk:\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp), &RQF_MDS_READPAGE);\r\nif (!req)\r\nreturn -ENOMEM;\r\nrc = ptlrpc_request_pack(req, LUSTRE_MDS_VERSION, MDS_READPAGE);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nreq->rq_request_portal = MDS_READPAGE_PORTAL;\r\nptlrpc_at_set_req_timeout(req);\r\ndesc = ptlrpc_prep_bulk_imp(req, npages, 1,\r\nPTLRPC_BULK_PUT_SINK | PTLRPC_BULK_BUF_KIOV,\r\nMDS_BULK_PORTAL,\r\n&ptlrpc_bulk_kiov_pin_ops);\r\nif (!desc) {\r\nptlrpc_request_free(req);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < npages; i++)\r\ndesc->bd_frag_ops->add_kiov_frag(desc, pages[i], 0, PAGE_SIZE);\r\nmdc_readdir_pack(req, offset, PAGE_SIZE * npages, fid);\r\nptlrpc_request_set_replen(req);\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc) {\r\nptlrpc_req_finished(req);\r\nif (rc != -ETIMEDOUT)\r\nreturn rc;\r\nresends++;\r\nif (!client_should_resend(resends, &exp->exp_obd->u.cli)) {\r\nCERROR("%s: too many resend retries: rc = %d\n",\r\nexp->exp_obd->obd_name, -EIO);\r\nreturn -EIO;\r\n}\r\nlwi = LWI_TIMEOUT_INTR(cfs_time_seconds(resends), NULL, NULL,\r\nNULL);\r\nl_wait_event(waitq, 0, &lwi);\r\ngoto restart_bulk;\r\n}\r\nrc = sptlrpc_cli_unwrap_bulk_read(req, req->rq_bulk,\r\nreq->rq_bulk->bd_nob_transferred);\r\nif (rc < 0) {\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nif (req->rq_bulk->bd_nob_transferred & ~LU_PAGE_MASK) {\r\nCERROR("%s: unexpected bytes transferred: %d (%ld expected)\n",\r\nexp->exp_obd->obd_name, req->rq_bulk->bd_nob_transferred,\r\nPAGE_SIZE * npages);\r\nptlrpc_req_finished(req);\r\nreturn -EPROTO;\r\n}\r\n*request = req;\r\nreturn 0;\r\n}\r\nstatic void mdc_release_page(struct page *page, int remove)\r\n{\r\nif (remove) {\r\nlock_page(page);\r\nif (likely(page->mapping))\r\ntruncate_complete_page(page->mapping, page);\r\nunlock_page(page);\r\n}\r\nput_page(page);\r\n}\r\nstatic struct page *mdc_page_locate(struct address_space *mapping, __u64 *hash,\r\n__u64 *start, __u64 *end, int hash64)\r\n{\r\nunsigned long offset = hash_x_index(*hash, hash64);\r\nstruct page *page;\r\nint found;\r\nspin_lock_irq(&mapping->tree_lock);\r\nfound = radix_tree_gang_lookup(&mapping->page_tree,\r\n(void **)&page, offset, 1);\r\nif (found > 0 && !radix_tree_exceptional_entry(page)) {\r\nstruct lu_dirpage *dp;\r\nget_page(page);\r\nspin_unlock_irq(&mapping->tree_lock);\r\nwait_on_page_locked(page);\r\nif (PageUptodate(page)) {\r\ndp = kmap(page);\r\nif (BITS_PER_LONG == 32 && hash64) {\r\n*start = le64_to_cpu(dp->ldp_hash_start) >> 32;\r\n*end = le64_to_cpu(dp->ldp_hash_end) >> 32;\r\n*hash = *hash >> 32;\r\n} else {\r\n*start = le64_to_cpu(dp->ldp_hash_start);\r\n*end = le64_to_cpu(dp->ldp_hash_end);\r\n}\r\nif (unlikely(*start == 1 && *hash == 0))\r\n*hash = *start;\r\nelse\r\nLASSERTF(*start <= *hash, "start = %#llx,end = %#llx,hash = %#llx\n",\r\n*start, *end, *hash);\r\nCDEBUG(D_VFSTRACE, "offset %lx [%#llx %#llx], hash %#llx\n",\r\noffset, *start, *end, *hash);\r\nif (*hash > *end) {\r\nkunmap(page);\r\nmdc_release_page(page, 0);\r\npage = NULL;\r\n} else if (*end != *start && *hash == *end) {\r\nkunmap(page);\r\nmdc_release_page(page,\r\nle32_to_cpu(dp->ldp_flags) & LDF_COLLIDE);\r\npage = NULL;\r\n}\r\n} else {\r\nput_page(page);\r\npage = ERR_PTR(-EIO);\r\n}\r\n} else {\r\nspin_unlock_irq(&mapping->tree_lock);\r\npage = NULL;\r\n}\r\nreturn page;\r\n}\r\nstatic void mdc_adjust_dirpages(struct page **pages, int cfs_pgs, int lu_pgs)\r\n{\r\nint i;\r\nfor (i = 0; i < cfs_pgs; i++) {\r\nstruct lu_dirpage *dp = kmap(pages[i]);\r\n__u64 hash_end = le64_to_cpu(dp->ldp_hash_end);\r\n__u32 flags = le32_to_cpu(dp->ldp_flags);\r\nstruct lu_dirpage *first = dp;\r\nstruct lu_dirent *end_dirent = NULL;\r\nstruct lu_dirent *ent;\r\nwhile (--lu_pgs > 0) {\r\nent = lu_dirent_start(dp);\r\nfor (end_dirent = ent; ent;\r\nend_dirent = ent, ent = lu_dirent_next(ent));\r\ndp = (struct lu_dirpage *)((char *)dp + LU_PAGE_SIZE);\r\nif (!((unsigned long)dp & ~PAGE_MASK))\r\nbreak;\r\nhash_end = le64_to_cpu(dp->ldp_hash_end);\r\nflags = le32_to_cpu(dp->ldp_flags);\r\nif (!end_dirent)\r\nbreak;\r\nLASSERT(!le16_to_cpu(end_dirent->lde_reclen));\r\nend_dirent->lde_reclen =\r\ncpu_to_le16((char *)(dp->ldp_entries) -\r\n(char *)end_dirent);\r\n}\r\nfirst->ldp_hash_end = hash_end;\r\nfirst->ldp_flags &= ~cpu_to_le32(LDF_COLLIDE);\r\nfirst->ldp_flags |= flags & cpu_to_le32(LDF_COLLIDE);\r\nkunmap(pages[i]);\r\n}\r\nLASSERTF(lu_pgs == 0, "left = %d", lu_pgs);\r\n}\r\nstatic int mdc_read_page_remote(void *data, struct page *page0)\r\n{\r\nstruct readpage_param *rp = data;\r\nstruct page **page_pool;\r\nstruct page *page;\r\nstruct lu_dirpage *dp;\r\nint rd_pgs = 0;\r\nint npages;\r\nstruct md_op_data *op_data = rp->rp_mod;\r\nstruct ptlrpc_request *req;\r\nint max_pages = op_data->op_max_pages;\r\nstruct inode *inode;\r\nstruct lu_fid *fid;\r\nint i;\r\nint rc;\r\nLASSERT(max_pages > 0 && max_pages <= PTLRPC_MAX_BRW_PAGES);\r\ninode = op_data->op_data;\r\nfid = &op_data->op_fid1;\r\nLASSERT(inode);\r\npage_pool = kcalloc(max_pages, sizeof(page), GFP_NOFS);\r\nif (page_pool) {\r\npage_pool[0] = page0;\r\n} else {\r\npage_pool = &page0;\r\nmax_pages = 1;\r\n}\r\nfor (npages = 1; npages < max_pages; npages++) {\r\npage = page_cache_alloc_cold(inode->i_mapping);\r\nif (!page)\r\nbreak;\r\npage_pool[npages] = page;\r\n}\r\nrc = mdc_getpage(rp->rp_exp, fid, rp->rp_off, page_pool, npages, &req);\r\nif (!rc) {\r\nint lu_pgs = req->rq_bulk->bd_nob_transferred;\r\nrd_pgs = (req->rq_bulk->bd_nob_transferred +\r\nPAGE_SIZE - 1) >> PAGE_SHIFT;\r\nlu_pgs >>= LU_PAGE_SHIFT;\r\nLASSERT(!(req->rq_bulk->bd_nob_transferred & ~LU_PAGE_MASK));\r\nCDEBUG(D_INODE, "read %d(%d) pages\n", rd_pgs, lu_pgs);\r\nmdc_adjust_dirpages(page_pool, rd_pgs, lu_pgs);\r\nSetPageUptodate(page0);\r\n}\r\nunlock_page(page0);\r\nptlrpc_req_finished(req);\r\nCDEBUG(D_CACHE, "read %d/%d pages\n", rd_pgs, npages);\r\nfor (i = 1; i < npages; i++) {\r\nunsigned long offset;\r\n__u64 hash;\r\nint ret;\r\npage = page_pool[i];\r\nif (rc < 0 || i >= rd_pgs) {\r\nput_page(page);\r\ncontinue;\r\n}\r\nSetPageUptodate(page);\r\ndp = kmap(page);\r\nhash = le64_to_cpu(dp->ldp_hash_start);\r\nkunmap(page);\r\noffset = hash_x_index(hash, rp->rp_hash64);\r\nprefetchw(&page->flags);\r\nret = add_to_page_cache_lru(page, inode->i_mapping, offset,\r\nGFP_KERNEL);\r\nif (!ret)\r\nunlock_page(page);\r\nelse\r\nCDEBUG(D_VFSTRACE, "page %lu add to page cache failed: rc = %d\n",\r\noffset, ret);\r\nput_page(page);\r\n}\r\nif (page_pool != &page0)\r\nkfree(page_pool);\r\nreturn rc;\r\n}\r\nstatic int mdc_read_page(struct obd_export *exp, struct md_op_data *op_data,\r\nstruct md_callback *cb_op, __u64 hash_offset,\r\nstruct page **ppage)\r\n{\r\nstruct lookup_intent it = { .it_op = IT_READDIR };\r\nstruct page *page;\r\nstruct inode *dir = op_data->op_data;\r\nstruct address_space *mapping;\r\nstruct lu_dirpage *dp;\r\n__u64 start = 0;\r\n__u64 end = 0;\r\nstruct lustre_handle lockh;\r\nstruct ptlrpc_request *enq_req = NULL;\r\nstruct readpage_param rp_param;\r\nint rc;\r\n*ppage = NULL;\r\nLASSERT(dir);\r\nmapping = dir->i_mapping;\r\nrc = mdc_intent_lock(exp, op_data, &it, &enq_req,\r\ncb_op->md_blocking_ast, 0);\r\nif (enq_req)\r\nptlrpc_req_finished(enq_req);\r\nif (rc < 0) {\r\nCERROR("%s: "DFID" lock enqueue fails: rc = %d\n",\r\nexp->exp_obd->obd_name, PFID(&op_data->op_fid1), rc);\r\nreturn rc;\r\n}\r\nrc = 0;\r\nlockh.cookie = it.it_lock_handle;\r\nmdc_set_lock_data(exp, &lockh, dir, NULL);\r\nrp_param.rp_off = hash_offset;\r\nrp_param.rp_hash64 = op_data->op_cli_flags & CLI_HASH64;\r\npage = mdc_page_locate(mapping, &rp_param.rp_off, &start, &end,\r\nrp_param.rp_hash64);\r\nif (IS_ERR(page)) {\r\nCDEBUG(D_INFO, "%s: dir page locate: " DFID " at %llu: rc %ld\n",\r\nexp->exp_obd->obd_name, PFID(&op_data->op_fid1),\r\nrp_param.rp_off, PTR_ERR(page));\r\nrc = PTR_ERR(page);\r\ngoto out_unlock;\r\n} else if (page) {\r\ngoto hash_collision;\r\n}\r\nrp_param.rp_exp = exp;\r\nrp_param.rp_mod = op_data;\r\npage = read_cache_page(mapping,\r\nhash_x_index(rp_param.rp_off,\r\nrp_param.rp_hash64),\r\nmdc_read_page_remote, &rp_param);\r\nif (IS_ERR(page)) {\r\nCERROR("%s: read cache page: "DFID" at %llu: rc %ld\n",\r\nexp->exp_obd->obd_name, PFID(&op_data->op_fid1),\r\nrp_param.rp_off, PTR_ERR(page));\r\nrc = PTR_ERR(page);\r\ngoto out_unlock;\r\n}\r\nwait_on_page_locked(page);\r\n(void)kmap(page);\r\nif (!PageUptodate(page)) {\r\nCERROR("%s: page not updated: "DFID" at %llu: rc %d\n",\r\nexp->exp_obd->obd_name, PFID(&op_data->op_fid1),\r\nrp_param.rp_off, -5);\r\ngoto fail;\r\n}\r\nif (!PageChecked(page))\r\nSetPageChecked(page);\r\nif (PageError(page)) {\r\nCERROR("%s: page error: "DFID" at %llu: rc %d\n",\r\nexp->exp_obd->obd_name, PFID(&op_data->op_fid1),\r\nrp_param.rp_off, -5);\r\ngoto fail;\r\n}\r\nhash_collision:\r\ndp = page_address(page);\r\nif (BITS_PER_LONG == 32 && rp_param.rp_hash64) {\r\nstart = le64_to_cpu(dp->ldp_hash_start) >> 32;\r\nend = le64_to_cpu(dp->ldp_hash_end) >> 32;\r\nrp_param.rp_off = hash_offset >> 32;\r\n} else {\r\nstart = le64_to_cpu(dp->ldp_hash_start);\r\nend = le64_to_cpu(dp->ldp_hash_end);\r\nrp_param.rp_off = hash_offset;\r\n}\r\nif (end == start) {\r\nLASSERT(start == rp_param.rp_off);\r\nCWARN("Page-wide hash collision: %#lx\n", (unsigned long)end);\r\n#if BITS_PER_LONG == 32\r\nCWARN("Real page-wide hash collision at [%llu %llu] with hash %llu\n",\r\nle64_to_cpu(dp->ldp_hash_start),\r\nle64_to_cpu(dp->ldp_hash_end), hash_offset);\r\n#endif\r\ngoto fail;\r\n}\r\n*ppage = page;\r\nout_unlock:\r\nldlm_lock_decref(&lockh, it.it_lock_mode);\r\nreturn rc;\r\nfail:\r\nkunmap(page);\r\nmdc_release_page(page, 1);\r\nrc = -EIO;\r\ngoto out_unlock;\r\n}\r\nstatic int mdc_statfs(const struct lu_env *env,\r\nstruct obd_export *exp, struct obd_statfs *osfs,\r\n__u64 max_age, __u32 flags)\r\n{\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nstruct ptlrpc_request *req;\r\nstruct obd_statfs *msfs;\r\nstruct obd_import *imp = NULL;\r\nint rc;\r\ndown_read(&obd->u.cli.cl_sem);\r\nif (obd->u.cli.cl_import)\r\nimp = class_import_get(obd->u.cli.cl_import);\r\nup_read(&obd->u.cli.cl_sem);\r\nif (!imp)\r\nreturn -ENODEV;\r\nreq = ptlrpc_request_alloc_pack(imp, &RQF_MDS_STATFS,\r\nLUSTRE_MDS_VERSION, MDS_STATFS);\r\nif (!req) {\r\nrc = -ENOMEM;\r\ngoto output;\r\n}\r\nptlrpc_request_set_replen(req);\r\nif (flags & OBD_STATFS_NODELAY) {\r\nreq->rq_no_resend = 1;\r\nreq->rq_no_delay = 1;\r\n}\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc) {\r\nif (imp->imp_connect_error)\r\nrc = imp->imp_connect_error;\r\ngoto out;\r\n}\r\nmsfs = req_capsule_server_get(&req->rq_pill, &RMF_OBD_STATFS);\r\nif (!msfs) {\r\nrc = -EPROTO;\r\ngoto out;\r\n}\r\n*osfs = *msfs;\r\nout:\r\nptlrpc_req_finished(req);\r\noutput:\r\nclass_import_put(imp);\r\nreturn rc;\r\n}\r\nstatic int mdc_ioc_fid2path(struct obd_export *exp, struct getinfo_fid2path *gf)\r\n{\r\n__u32 keylen, vallen;\r\nvoid *key;\r\nint rc;\r\nif (gf->gf_pathlen > PATH_MAX)\r\nreturn -ENAMETOOLONG;\r\nif (gf->gf_pathlen < 2)\r\nreturn -EOVERFLOW;\r\nkeylen = cfs_size_round(sizeof(KEY_FID2PATH)) + sizeof(*gf);\r\nkey = kzalloc(keylen, GFP_NOFS);\r\nif (!key)\r\nreturn -ENOMEM;\r\nmemcpy(key, KEY_FID2PATH, sizeof(KEY_FID2PATH));\r\nmemcpy(key + cfs_size_round(sizeof(KEY_FID2PATH)), gf, sizeof(*gf));\r\nCDEBUG(D_IOCTL, "path get "DFID" from %llu #%d\n",\r\nPFID(&gf->gf_fid), gf->gf_recno, gf->gf_linkno);\r\nif (!fid_is_sane(&gf->gf_fid)) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nvallen = sizeof(*gf) + gf->gf_pathlen;\r\nrc = obd_get_info(NULL, exp, keylen, key, &vallen, gf);\r\nif (rc != 0 && rc != -EREMOTE)\r\ngoto out;\r\nif (vallen <= sizeof(*gf)) {\r\nrc = -EPROTO;\r\ngoto out;\r\n} else if (vallen > sizeof(*gf) + gf->gf_pathlen) {\r\nrc = -EOVERFLOW;\r\ngoto out;\r\n}\r\nCDEBUG(D_IOCTL, "path got " DFID " from %llu #%d: %s\n",\r\nPFID(&gf->gf_fid), gf->gf_recno, gf->gf_linkno,\r\ngf->gf_pathlen < 512 ? gf->gf_path :\r\ngf->gf_path + gf->gf_pathlen - 512);\r\nout:\r\nkfree(key);\r\nreturn rc;\r\n}\r\nstatic int mdc_ioc_hsm_progress(struct obd_export *exp,\r\nstruct hsm_progress_kernel *hpk)\r\n{\r\nstruct obd_import *imp = class_exp2cliimp(exp);\r\nstruct hsm_progress_kernel *req_hpk;\r\nstruct ptlrpc_request *req;\r\nint rc;\r\nreq = ptlrpc_request_alloc_pack(imp, &RQF_MDS_HSM_PROGRESS,\r\nLUSTRE_MDS_VERSION, MDS_HSM_PROGRESS);\r\nif (!req) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nmdc_pack_body(req, NULL, 0, 0, -1, 0);\r\nreq_hpk = req_capsule_client_get(&req->rq_pill, &RMF_MDS_HSM_PROGRESS);\r\nif (!req_hpk) {\r\nrc = -EPROTO;\r\ngoto out;\r\n}\r\n*req_hpk = *hpk;\r\nreq_hpk->hpk_errval = lustre_errno_hton(hpk->hpk_errval);\r\nptlrpc_request_set_replen(req);\r\nmdc_get_mod_rpc_slot(req, NULL);\r\nrc = ptlrpc_queue_wait(req);\r\nmdc_put_mod_rpc_slot(req, NULL);\r\nout:\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic int mdc_ioc_hsm_ct_register(struct obd_import *imp, __u32 archives)\r\n{\r\n__u32 *archive_mask;\r\nstruct ptlrpc_request *req;\r\nint rc;\r\nreq = ptlrpc_request_alloc_pack(imp, &RQF_MDS_HSM_CT_REGISTER,\r\nLUSTRE_MDS_VERSION,\r\nMDS_HSM_CT_REGISTER);\r\nif (!req) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nmdc_pack_body(req, NULL, 0, 0, -1, 0);\r\narchive_mask = req_capsule_client_get(&req->rq_pill,\r\n&RMF_MDS_HSM_ARCHIVE);\r\nif (!archive_mask) {\r\nrc = -EPROTO;\r\ngoto out;\r\n}\r\n*archive_mask = archives;\r\nptlrpc_request_set_replen(req);\r\nrc = mdc_queue_wait(req);\r\nout:\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic int mdc_ioc_hsm_current_action(struct obd_export *exp,\r\nstruct md_op_data *op_data)\r\n{\r\nstruct hsm_current_action *hca = op_data->op_data;\r\nstruct hsm_current_action *req_hca;\r\nstruct ptlrpc_request *req;\r\nint rc;\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp),\r\n&RQF_MDS_HSM_ACTION);\r\nif (!req)\r\nreturn -ENOMEM;\r\nrc = ptlrpc_request_pack(req, LUSTRE_MDS_VERSION, MDS_HSM_ACTION);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nmdc_pack_body(req, &op_data->op_fid1, 0, 0,\r\nop_data->op_suppgids[0], 0);\r\nptlrpc_request_set_replen(req);\r\nrc = mdc_queue_wait(req);\r\nif (rc)\r\ngoto out;\r\nreq_hca = req_capsule_server_get(&req->rq_pill,\r\n&RMF_MDS_HSM_CURRENT_ACTION);\r\nif (!req_hca) {\r\nrc = -EPROTO;\r\ngoto out;\r\n}\r\n*hca = *req_hca;\r\nout:\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic int mdc_ioc_hsm_ct_unregister(struct obd_import *imp)\r\n{\r\nstruct ptlrpc_request *req;\r\nint rc;\r\nreq = ptlrpc_request_alloc_pack(imp, &RQF_MDS_HSM_CT_UNREGISTER,\r\nLUSTRE_MDS_VERSION,\r\nMDS_HSM_CT_UNREGISTER);\r\nif (!req) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nmdc_pack_body(req, NULL, 0, 0, -1, 0);\r\nptlrpc_request_set_replen(req);\r\nrc = mdc_queue_wait(req);\r\nout:\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic int mdc_ioc_hsm_state_get(struct obd_export *exp,\r\nstruct md_op_data *op_data)\r\n{\r\nstruct hsm_user_state *hus = op_data->op_data;\r\nstruct hsm_user_state *req_hus;\r\nstruct ptlrpc_request *req;\r\nint rc;\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp),\r\n&RQF_MDS_HSM_STATE_GET);\r\nif (!req)\r\nreturn -ENOMEM;\r\nrc = ptlrpc_request_pack(req, LUSTRE_MDS_VERSION, MDS_HSM_STATE_GET);\r\nif (rc != 0) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nmdc_pack_body(req, &op_data->op_fid1, 0, 0,\r\nop_data->op_suppgids[0], 0);\r\nptlrpc_request_set_replen(req);\r\nrc = mdc_queue_wait(req);\r\nif (rc)\r\ngoto out;\r\nreq_hus = req_capsule_server_get(&req->rq_pill, &RMF_HSM_USER_STATE);\r\nif (!req_hus) {\r\nrc = -EPROTO;\r\ngoto out;\r\n}\r\n*hus = *req_hus;\r\nout:\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic int mdc_ioc_hsm_state_set(struct obd_export *exp,\r\nstruct md_op_data *op_data)\r\n{\r\nstruct hsm_state_set *hss = op_data->op_data;\r\nstruct hsm_state_set *req_hss;\r\nstruct ptlrpc_request *req;\r\nint rc;\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp),\r\n&RQF_MDS_HSM_STATE_SET);\r\nif (!req)\r\nreturn -ENOMEM;\r\nrc = ptlrpc_request_pack(req, LUSTRE_MDS_VERSION, MDS_HSM_STATE_SET);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nmdc_pack_body(req, &op_data->op_fid1, 0, 0,\r\nop_data->op_suppgids[0], 0);\r\nreq_hss = req_capsule_client_get(&req->rq_pill, &RMF_HSM_STATE_SET);\r\nif (!req_hss) {\r\nrc = -EPROTO;\r\ngoto out;\r\n}\r\n*req_hss = *hss;\r\nptlrpc_request_set_replen(req);\r\nmdc_get_mod_rpc_slot(req, NULL);\r\nrc = ptlrpc_queue_wait(req);\r\nmdc_put_mod_rpc_slot(req, NULL);\r\nout:\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic int mdc_ioc_hsm_request(struct obd_export *exp,\r\nstruct hsm_user_request *hur)\r\n{\r\nstruct obd_import *imp = class_exp2cliimp(exp);\r\nstruct ptlrpc_request *req;\r\nstruct hsm_request *req_hr;\r\nstruct hsm_user_item *req_hui;\r\nchar *req_opaque;\r\nint rc;\r\nreq = ptlrpc_request_alloc(imp, &RQF_MDS_HSM_REQUEST);\r\nif (!req) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nreq_capsule_set_size(&req->rq_pill, &RMF_MDS_HSM_USER_ITEM, RCL_CLIENT,\r\nhur->hur_request.hr_itemcount\r\n* sizeof(struct hsm_user_item));\r\nreq_capsule_set_size(&req->rq_pill, &RMF_GENERIC_DATA, RCL_CLIENT,\r\nhur->hur_request.hr_data_len);\r\nrc = ptlrpc_request_pack(req, LUSTRE_MDS_VERSION, MDS_HSM_REQUEST);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nmdc_pack_body(req, NULL, 0, 0, -1, 0);\r\nreq_hr = req_capsule_client_get(&req->rq_pill, &RMF_MDS_HSM_REQUEST);\r\nif (!req_hr) {\r\nrc = -EPROTO;\r\ngoto out;\r\n}\r\n*req_hr = hur->hur_request;\r\nreq_hui = req_capsule_client_get(&req->rq_pill, &RMF_MDS_HSM_USER_ITEM);\r\nif (!req_hui) {\r\nrc = -EPROTO;\r\ngoto out;\r\n}\r\nmemcpy(req_hui, hur->hur_user_item,\r\nhur->hur_request.hr_itemcount * sizeof(struct hsm_user_item));\r\nreq_opaque = req_capsule_client_get(&req->rq_pill, &RMF_GENERIC_DATA);\r\nif (!req_opaque) {\r\nrc = -EPROTO;\r\ngoto out;\r\n}\r\nmemcpy(req_opaque, hur_data(hur), hur->hur_request.hr_data_len);\r\nptlrpc_request_set_replen(req);\r\nmdc_get_mod_rpc_slot(req, NULL);\r\nrc = ptlrpc_queue_wait(req);\r\nmdc_put_mod_rpc_slot(req, NULL);\r\nout:\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic struct kuc_hdr *changelog_kuc_hdr(char *buf, size_t len, u32 flags)\r\n{\r\nstruct kuc_hdr *lh = (struct kuc_hdr *)buf;\r\nLASSERT(len <= KUC_CHANGELOG_MSG_MAXSIZE);\r\nlh->kuc_magic = KUC_MAGIC;\r\nlh->kuc_transport = KUC_TRANSPORT_CHANGELOG;\r\nlh->kuc_flags = flags;\r\nlh->kuc_msgtype = CL_RECORD;\r\nlh->kuc_msglen = len;\r\nreturn lh;\r\n}\r\nstatic inline char *cs_obd_name(struct changelog_show *cs)\r\n{\r\nreturn cs->cs_obd->obd_name;\r\n}\r\nstatic int changelog_kkuc_cb(const struct lu_env *env, struct llog_handle *llh,\r\nstruct llog_rec_hdr *hdr, void *data)\r\n{\r\nstruct changelog_show *cs = data;\r\nstruct llog_changelog_rec *rec = (struct llog_changelog_rec *)hdr;\r\nstruct kuc_hdr *lh;\r\nsize_t len;\r\nint rc;\r\nif (rec->cr_hdr.lrh_type != CHANGELOG_REC) {\r\nrc = -EINVAL;\r\nCERROR("%s: not a changelog rec %x/%d: rc = %d\n",\r\ncs_obd_name(cs), rec->cr_hdr.lrh_type,\r\nrec->cr.cr_type, rc);\r\nreturn rc;\r\n}\r\nif (rec->cr.cr_index < cs->cs_startrec) {\r\nCDEBUG(D_HSM, "rec=%llu start=%llu\n",\r\nrec->cr.cr_index, cs->cs_startrec);\r\nreturn 0;\r\n}\r\nCDEBUG(D_HSM, "%llu %02d%-5s %llu 0x%x t=" DFID " p=" DFID\r\n" %.*s\n", rec->cr.cr_index, rec->cr.cr_type,\r\nchangelog_type2str(rec->cr.cr_type), rec->cr.cr_time,\r\nrec->cr.cr_flags & CLF_FLAGMASK,\r\nPFID(&rec->cr.cr_tfid), PFID(&rec->cr.cr_pfid),\r\nrec->cr.cr_namelen, changelog_rec_name(&rec->cr));\r\nlen = sizeof(*lh) + changelog_rec_size(&rec->cr) + rec->cr.cr_namelen;\r\nlh = changelog_kuc_hdr(cs->cs_buf, len, cs->cs_flags);\r\nmemcpy(lh + 1, &rec->cr, len - sizeof(*lh));\r\nrc = libcfs_kkuc_msg_put(cs->cs_fp, lh);\r\nCDEBUG(D_HSM, "kucmsg fp %p len %zu rc %d\n", cs->cs_fp, len, rc);\r\nreturn rc;\r\n}\r\nstatic int mdc_changelog_send_thread(void *csdata)\r\n{\r\nenum llog_flag flags = LLOG_F_IS_CAT;\r\nstruct changelog_show *cs = csdata;\r\nstruct llog_ctxt *ctxt = NULL;\r\nstruct llog_handle *llh = NULL;\r\nstruct kuc_hdr *kuch;\r\nint rc;\r\nCDEBUG(D_HSM, "changelog to fp=%p start %llu\n",\r\ncs->cs_fp, cs->cs_startrec);\r\ncs->cs_buf = kzalloc(KUC_CHANGELOG_MSG_MAXSIZE, GFP_NOFS);\r\nif (!cs->cs_buf) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nctxt = llog_get_context(cs->cs_obd, LLOG_CHANGELOG_REPL_CTXT);\r\nif (!ctxt) {\r\nrc = -ENOENT;\r\ngoto out;\r\n}\r\nrc = llog_open(NULL, ctxt, &llh, NULL, CHANGELOG_CATALOG,\r\nLLOG_OPEN_EXISTS);\r\nif (rc) {\r\nCERROR("%s: fail to open changelog catalog: rc = %d\n",\r\ncs_obd_name(cs), rc);\r\ngoto out;\r\n}\r\nif (cs->cs_flags & CHANGELOG_FLAG_JOBID)\r\nflags |= LLOG_F_EXT_JOBID;\r\nrc = llog_init_handle(NULL, llh, flags, NULL);\r\nif (rc) {\r\nCERROR("llog_init_handle failed %d\n", rc);\r\ngoto out;\r\n}\r\nrc = llog_cat_process(NULL, llh, changelog_kkuc_cb, cs, 0, 0);\r\nkuch = changelog_kuc_hdr(cs->cs_buf, sizeof(*kuch), cs->cs_flags);\r\nkuch->kuc_msgtype = CL_EOF;\r\nlibcfs_kkuc_msg_put(cs->cs_fp, kuch);\r\nout:\r\nfput(cs->cs_fp);\r\nif (llh)\r\nllog_cat_close(NULL, llh);\r\nif (ctxt)\r\nllog_ctxt_put(ctxt);\r\nkfree(cs->cs_buf);\r\nkfree(cs);\r\nreturn rc;\r\n}\r\nstatic int mdc_ioc_changelog_send(struct obd_device *obd,\r\nstruct ioc_changelog *icc)\r\n{\r\nstruct changelog_show *cs;\r\nstruct task_struct *task;\r\nint rc;\r\ncs = kzalloc(sizeof(*cs), GFP_NOFS);\r\nif (!cs)\r\nreturn -ENOMEM;\r\ncs->cs_obd = obd;\r\ncs->cs_startrec = icc->icc_recno;\r\ncs->cs_fp = fget(icc->icc_id);\r\ncs->cs_flags = icc->icc_flags;\r\ntask = kthread_run(mdc_changelog_send_thread, cs,\r\n"mdc_clg_send_thread");\r\nif (IS_ERR(task)) {\r\nrc = PTR_ERR(task);\r\nCERROR("%s: can't start changelog thread: rc = %d\n",\r\ncs_obd_name(cs), rc);\r\nkfree(cs);\r\n} else {\r\nrc = 0;\r\nCDEBUG(D_HSM, "%s: started changelog thread\n",\r\ncs_obd_name(cs));\r\n}\r\nCERROR("Failed to start changelog thread: %d\n", rc);\r\nreturn rc;\r\n}\r\nstatic int mdc_quotactl(struct obd_device *unused, struct obd_export *exp,\r\nstruct obd_quotactl *oqctl)\r\n{\r\nstruct ptlrpc_request *req;\r\nstruct obd_quotactl *oqc;\r\nint rc;\r\nreq = ptlrpc_request_alloc_pack(class_exp2cliimp(exp),\r\n&RQF_MDS_QUOTACTL, LUSTRE_MDS_VERSION,\r\nMDS_QUOTACTL);\r\nif (!req)\r\nreturn -ENOMEM;\r\noqc = req_capsule_client_get(&req->rq_pill, &RMF_OBD_QUOTACTL);\r\n*oqc = *oqctl;\r\nptlrpc_request_set_replen(req);\r\nptlrpc_at_set_req_timeout(req);\r\nreq->rq_no_resend = 1;\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc)\r\nCERROR("ptlrpc_queue_wait failed, rc: %d\n", rc);\r\nif (req->rq_repmsg) {\r\noqc = req_capsule_server_get(&req->rq_pill, &RMF_OBD_QUOTACTL);\r\nif (oqc) {\r\n*oqctl = *oqc;\r\n} else if (!rc) {\r\nCERROR("Can't unpack obd_quotactl\n");\r\nrc = -EPROTO;\r\n}\r\n} else if (!rc) {\r\nCERROR("Can't unpack obd_quotactl\n");\r\nrc = -EPROTO;\r\n}\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic int mdc_ioc_swap_layouts(struct obd_export *exp,\r\nstruct md_op_data *op_data)\r\n{\r\nLIST_HEAD(cancels);\r\nstruct ptlrpc_request *req;\r\nint rc, count;\r\nstruct mdc_swap_layouts *msl, *payload;\r\nmsl = op_data->op_data;\r\ncount = mdc_resource_get_unused(exp, &op_data->op_fid1, &cancels,\r\nLCK_CR, MDS_INODELOCK_LAYOUT |\r\nMDS_INODELOCK_XATTR);\r\ncount += mdc_resource_get_unused(exp, &op_data->op_fid2, &cancels,\r\nLCK_CR, MDS_INODELOCK_LAYOUT |\r\nMDS_INODELOCK_XATTR);\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp),\r\n&RQF_MDS_SWAP_LAYOUTS);\r\nif (!req) {\r\nldlm_lock_list_put(&cancels, l_bl_ast, count);\r\nreturn -ENOMEM;\r\n}\r\nrc = mdc_prep_elc_req(exp, req, MDS_SWAP_LAYOUTS, &cancels, count);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nmdc_swap_layouts_pack(req, op_data);\r\npayload = req_capsule_client_get(&req->rq_pill, &RMF_SWAP_LAYOUTS);\r\nLASSERT(payload);\r\n*payload = *msl;\r\nptlrpc_request_set_replen(req);\r\nrc = ptlrpc_queue_wait(req);\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic int mdc_iocontrol(unsigned int cmd, struct obd_export *exp, int len,\r\nvoid *karg, void __user *uarg)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct obd_ioctl_data *data = karg;\r\nstruct obd_import *imp = obd->u.cli.cl_import;\r\nint rc;\r\nif (!try_module_get(THIS_MODULE)) {\r\nCERROR("%s: cannot get module '%s'\n", obd->obd_name,\r\nmodule_name(THIS_MODULE));\r\nreturn -EINVAL;\r\n}\r\nswitch (cmd) {\r\ncase OBD_IOC_CHANGELOG_SEND:\r\nrc = mdc_ioc_changelog_send(obd, karg);\r\ngoto out;\r\ncase OBD_IOC_CHANGELOG_CLEAR: {\r\nstruct ioc_changelog *icc = karg;\r\nstruct changelog_setinfo cs = {\r\n.cs_recno = icc->icc_recno,\r\n.cs_id = icc->icc_id\r\n};\r\nrc = obd_set_info_async(NULL, exp, strlen(KEY_CHANGELOG_CLEAR),\r\nKEY_CHANGELOG_CLEAR, sizeof(cs), &cs,\r\nNULL);\r\ngoto out;\r\n}\r\ncase OBD_IOC_FID2PATH:\r\nrc = mdc_ioc_fid2path(exp, karg);\r\ngoto out;\r\ncase LL_IOC_HSM_CT_START:\r\nrc = mdc_ioc_hsm_ct_start(exp, karg);\r\nif (rc == -EEXIST)\r\nrc = 0;\r\ngoto out;\r\ncase LL_IOC_HSM_PROGRESS:\r\nrc = mdc_ioc_hsm_progress(exp, karg);\r\ngoto out;\r\ncase LL_IOC_HSM_STATE_GET:\r\nrc = mdc_ioc_hsm_state_get(exp, karg);\r\ngoto out;\r\ncase LL_IOC_HSM_STATE_SET:\r\nrc = mdc_ioc_hsm_state_set(exp, karg);\r\ngoto out;\r\ncase LL_IOC_HSM_ACTION:\r\nrc = mdc_ioc_hsm_current_action(exp, karg);\r\ngoto out;\r\ncase LL_IOC_HSM_REQUEST:\r\nrc = mdc_ioc_hsm_request(exp, karg);\r\ngoto out;\r\ncase OBD_IOC_CLIENT_RECOVER:\r\nrc = ptlrpc_recover_import(imp, data->ioc_inlbuf1, 0);\r\nif (rc < 0)\r\ngoto out;\r\nrc = 0;\r\ngoto out;\r\ncase IOC_OSC_SET_ACTIVE:\r\nrc = ptlrpc_set_import_active(imp, data->ioc_offset);\r\ngoto out;\r\ncase OBD_IOC_PING_TARGET:\r\nrc = ptlrpc_obd_ping(obd);\r\ngoto out;\r\ncase IOC_OBD_STATFS: {\r\nstruct obd_statfs stat_buf = {0};\r\nif (*((__u32 *)data->ioc_inlbuf2) != 0) {\r\nrc = -ENODEV;\r\ngoto out;\r\n}\r\nif (copy_to_user(data->ioc_pbuf2, obd2cli_tgt(obd),\r\nmin_t(size_t, data->ioc_plen2,\r\nsizeof(struct obd_uuid)))) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nrc = mdc_statfs(NULL, obd->obd_self_export, &stat_buf,\r\ncfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),\r\n0);\r\nif (rc != 0)\r\ngoto out;\r\nif (copy_to_user(data->ioc_pbuf1, &stat_buf,\r\nmin_t(size_t, data->ioc_plen1,\r\nsizeof(stat_buf)))) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nrc = 0;\r\ngoto out;\r\n}\r\ncase OBD_IOC_QUOTACTL: {\r\nstruct if_quotactl *qctl = karg;\r\nstruct obd_quotactl *oqctl;\r\noqctl = kzalloc(sizeof(*oqctl), GFP_NOFS);\r\nif (!oqctl) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nQCTL_COPY(oqctl, qctl);\r\nrc = obd_quotactl(exp, oqctl);\r\nif (rc == 0) {\r\nQCTL_COPY(qctl, oqctl);\r\nqctl->qc_valid = QC_MDTIDX;\r\nqctl->obd_uuid = obd->u.cli.cl_target_uuid;\r\n}\r\nkfree(oqctl);\r\ngoto out;\r\n}\r\ncase LL_IOC_GET_CONNECT_FLAGS:\r\nif (copy_to_user(uarg, exp_connect_flags_ptr(exp),\r\nsizeof(*exp_connect_flags_ptr(exp)))) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nrc = 0;\r\ngoto out;\r\ncase LL_IOC_LOV_SWAP_LAYOUTS:\r\nrc = mdc_ioc_swap_layouts(exp, karg);\r\ngoto out;\r\ndefault:\r\nCERROR("unrecognised ioctl: cmd = %#x\n", cmd);\r\nrc = -ENOTTY;\r\ngoto out;\r\n}\r\nout:\r\nmodule_put(THIS_MODULE);\r\nreturn rc;\r\n}\r\nstatic int mdc_get_info_rpc(struct obd_export *exp,\r\nu32 keylen, void *key,\r\nint vallen, void *val)\r\n{\r\nstruct obd_import *imp = class_exp2cliimp(exp);\r\nstruct ptlrpc_request *req;\r\nchar *tmp;\r\nint rc = -EINVAL;\r\nreq = ptlrpc_request_alloc(imp, &RQF_MDS_GET_INFO);\r\nif (!req)\r\nreturn -ENOMEM;\r\nreq_capsule_set_size(&req->rq_pill, &RMF_GETINFO_KEY,\r\nRCL_CLIENT, keylen);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_GETINFO_VALLEN,\r\nRCL_CLIENT, sizeof(__u32));\r\nrc = ptlrpc_request_pack(req, LUSTRE_MDS_VERSION, MDS_GET_INFO);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\ntmp = req_capsule_client_get(&req->rq_pill, &RMF_GETINFO_KEY);\r\nmemcpy(tmp, key, keylen);\r\ntmp = req_capsule_client_get(&req->rq_pill, &RMF_GETINFO_VALLEN);\r\nmemcpy(tmp, &vallen, sizeof(__u32));\r\nreq_capsule_set_size(&req->rq_pill, &RMF_GETINFO_VAL,\r\nRCL_SERVER, vallen);\r\nptlrpc_request_set_replen(req);\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc == 0 || rc == -EREMOTE) {\r\ntmp = req_capsule_server_get(&req->rq_pill, &RMF_GETINFO_VAL);\r\nmemcpy(val, tmp, vallen);\r\nif (ptlrpc_rep_need_swab(req)) {\r\nif (KEY_IS(KEY_FID2PATH))\r\nlustre_swab_fid2path(val);\r\n}\r\n}\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic void lustre_swab_hai(struct hsm_action_item *h)\r\n{\r\n__swab32s(&h->hai_len);\r\n__swab32s(&h->hai_action);\r\nlustre_swab_lu_fid(&h->hai_fid);\r\nlustre_swab_lu_fid(&h->hai_dfid);\r\n__swab64s(&h->hai_cookie);\r\n__swab64s(&h->hai_extent.offset);\r\n__swab64s(&h->hai_extent.length);\r\n__swab64s(&h->hai_gid);\r\n}\r\nstatic void lustre_swab_hal(struct hsm_action_list *h)\r\n{\r\nstruct hsm_action_item *hai;\r\nu32 i;\r\n__swab32s(&h->hal_version);\r\n__swab32s(&h->hal_count);\r\n__swab32s(&h->hal_archive_id);\r\n__swab64s(&h->hal_flags);\r\nhai = hai_first(h);\r\nfor (i = 0; i < h->hal_count; i++, hai = hai_next(hai))\r\nlustre_swab_hai(hai);\r\n}\r\nstatic void lustre_swab_kuch(struct kuc_hdr *l)\r\n{\r\n__swab16s(&l->kuc_magic);\r\n__swab16s(&l->kuc_msgtype);\r\n__swab16s(&l->kuc_msglen);\r\n}\r\nstatic int mdc_ioc_hsm_ct_start(struct obd_export *exp,\r\nstruct lustre_kernelcomm *lk)\r\n{\r\nstruct obd_import *imp = class_exp2cliimp(exp);\r\n__u32 archive = lk->lk_data;\r\nint rc = 0;\r\nif (lk->lk_group != KUC_GRP_HSM) {\r\nCERROR("Bad copytool group %d\n", lk->lk_group);\r\nreturn -EINVAL;\r\n}\r\nCDEBUG(D_HSM, "CT start r%d w%d u%d g%d f%#x\n", lk->lk_rfd, lk->lk_wfd,\r\nlk->lk_uid, lk->lk_group, lk->lk_flags);\r\nif (lk->lk_flags & LK_FLG_STOP) {\r\nrc = mdc_ioc_hsm_ct_unregister(imp);\r\n} else {\r\nrc = mdc_ioc_hsm_ct_register(imp, archive);\r\n}\r\nreturn rc;\r\n}\r\nstatic int mdc_hsm_copytool_send(size_t len, void *val)\r\n{\r\nstruct kuc_hdr *lh = (struct kuc_hdr *)val;\r\nstruct hsm_action_list *hal = (struct hsm_action_list *)(lh + 1);\r\nif (len < sizeof(*lh) + sizeof(*hal)) {\r\nCERROR("Short HSM message %zu < %zu\n", len,\r\nsizeof(*lh) + sizeof(*hal));\r\nreturn -EPROTO;\r\n}\r\nif (lh->kuc_magic == __swab16(KUC_MAGIC)) {\r\nlustre_swab_kuch(lh);\r\nlustre_swab_hal(hal);\r\n} else if (lh->kuc_magic != KUC_MAGIC) {\r\nCERROR("Bad magic %x!=%x\n", lh->kuc_magic, KUC_MAGIC);\r\nreturn -EPROTO;\r\n}\r\nCDEBUG(D_HSM,\r\n"Received message mg=%x t=%d m=%d l=%d actions=%d on %s\n",\r\nlh->kuc_magic, lh->kuc_transport, lh->kuc_msgtype,\r\nlh->kuc_msglen, hal->hal_count, hal->hal_fsname);\r\nreturn libcfs_kkuc_group_put(KUC_GRP_HSM, lh);\r\n}\r\nstatic int mdc_hsm_ct_reregister(void *data, void *cb_arg)\r\n{\r\nstruct kkuc_ct_data *kcd = data;\r\nstruct obd_import *imp = (struct obd_import *)cb_arg;\r\nint rc;\r\nif (!kcd || kcd->kcd_magic != KKUC_CT_DATA_MAGIC)\r\nreturn -EPROTO;\r\nif (!obd_uuid_equals(&kcd->kcd_uuid, &imp->imp_obd->obd_uuid))\r\nreturn 0;\r\nCDEBUG(D_HA, "%s: recover copytool registration to MDT (archive=%#x)\n",\r\nimp->imp_obd->obd_name, kcd->kcd_archive);\r\nrc = mdc_ioc_hsm_ct_register(imp, kcd->kcd_archive);\r\nreturn (rc == -EEXIST) ? 0 : rc;\r\n}\r\nstatic int mdc_set_info_async(const struct lu_env *env,\r\nstruct obd_export *exp,\r\nu32 keylen, void *key,\r\nu32 vallen, void *val,\r\nstruct ptlrpc_request_set *set)\r\n{\r\nstruct obd_import *imp = class_exp2cliimp(exp);\r\nint rc;\r\nif (KEY_IS(KEY_READ_ONLY)) {\r\nif (vallen != sizeof(int))\r\nreturn -EINVAL;\r\nspin_lock(&imp->imp_lock);\r\nif (*((int *)val)) {\r\nimp->imp_connect_flags_orig |= OBD_CONNECT_RDONLY;\r\nimp->imp_connect_data.ocd_connect_flags |=\r\nOBD_CONNECT_RDONLY;\r\n} else {\r\nimp->imp_connect_flags_orig &= ~OBD_CONNECT_RDONLY;\r\nimp->imp_connect_data.ocd_connect_flags &=\r\n~OBD_CONNECT_RDONLY;\r\n}\r\nspin_unlock(&imp->imp_lock);\r\nreturn do_set_info_async(imp, MDS_SET_INFO, LUSTRE_MDS_VERSION,\r\nkeylen, key, vallen, val, set);\r\n}\r\nif (KEY_IS(KEY_SPTLRPC_CONF)) {\r\nsptlrpc_conf_client_adapt(exp->exp_obd);\r\nreturn 0;\r\n}\r\nif (KEY_IS(KEY_FLUSH_CTX)) {\r\nsptlrpc_import_flush_my_ctx(imp);\r\nreturn 0;\r\n}\r\nif (KEY_IS(KEY_CHANGELOG_CLEAR)) {\r\nrc = do_set_info_async(imp, MDS_SET_INFO, LUSTRE_MDS_VERSION,\r\nkeylen, key, vallen, val, set);\r\nreturn rc;\r\n}\r\nif (KEY_IS(KEY_HSM_COPYTOOL_SEND)) {\r\nrc = mdc_hsm_copytool_send(vallen, val);\r\nreturn rc;\r\n}\r\nif (KEY_IS(KEY_DEFAULT_EASIZE)) {\r\nu32 *default_easize = val;\r\nexp->exp_obd->u.cli.cl_default_mds_easize = *default_easize;\r\nreturn 0;\r\n}\r\nCERROR("Unknown key %s\n", (char *)key);\r\nreturn -EINVAL;\r\n}\r\nstatic int mdc_get_info(const struct lu_env *env, struct obd_export *exp,\r\n__u32 keylen, void *key, __u32 *vallen, void *val)\r\n{\r\nint rc = -EINVAL;\r\nif (KEY_IS(KEY_MAX_EASIZE)) {\r\nu32 mdsize, *max_easize;\r\nif (*vallen != sizeof(int))\r\nreturn -EINVAL;\r\nmdsize = *(u32 *)val;\r\nif (mdsize > exp->exp_obd->u.cli.cl_max_mds_easize)\r\nexp->exp_obd->u.cli.cl_max_mds_easize = mdsize;\r\nmax_easize = val;\r\n*max_easize = exp->exp_obd->u.cli.cl_max_mds_easize;\r\nreturn 0;\r\n} else if (KEY_IS(KEY_DEFAULT_EASIZE)) {\r\nu32 *default_easize;\r\nif (*vallen != sizeof(int))\r\nreturn -EINVAL;\r\ndefault_easize = val;\r\n*default_easize = exp->exp_obd->u.cli.cl_default_mds_easize;\r\nreturn 0;\r\n} else if (KEY_IS(KEY_CONN_DATA)) {\r\nstruct obd_import *imp = class_exp2cliimp(exp);\r\nstruct obd_connect_data *data = val;\r\nif (*vallen != sizeof(*data))\r\nreturn -EINVAL;\r\n*data = imp->imp_connect_data;\r\nreturn 0;\r\n} else if (KEY_IS(KEY_TGT_COUNT)) {\r\n*((u32 *)val) = 1;\r\nreturn 0;\r\n}\r\nrc = mdc_get_info_rpc(exp, keylen, key, *vallen, val);\r\nreturn rc;\r\n}\r\nstatic int mdc_sync(struct obd_export *exp, const struct lu_fid *fid,\r\nstruct ptlrpc_request **request)\r\n{\r\nstruct ptlrpc_request *req;\r\nint rc;\r\n*request = NULL;\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp), &RQF_MDS_SYNC);\r\nif (!req)\r\nreturn -ENOMEM;\r\nrc = ptlrpc_request_pack(req, LUSTRE_MDS_VERSION, MDS_SYNC);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nmdc_pack_body(req, fid, 0, 0, -1, 0);\r\nptlrpc_request_set_replen(req);\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc)\r\nptlrpc_req_finished(req);\r\nelse\r\n*request = req;\r\nreturn rc;\r\n}\r\nstatic int mdc_import_event(struct obd_device *obd, struct obd_import *imp,\r\nenum obd_import_event event)\r\n{\r\nint rc = 0;\r\nLASSERT(imp->imp_obd == obd);\r\nswitch (event) {\r\ncase IMP_EVENT_INACTIVE: {\r\nstruct client_obd *cli = &obd->u.cli;\r\nif (cli->cl_seq)\r\nseq_client_flush(cli->cl_seq);\r\nrc = obd_notify_observer(obd, obd, OBD_NOTIFY_INACTIVE, NULL);\r\nbreak;\r\n}\r\ncase IMP_EVENT_INVALIDATE: {\r\nstruct ldlm_namespace *ns = obd->obd_namespace;\r\nldlm_namespace_cleanup(ns, LDLM_FL_LOCAL_ONLY);\r\nbreak;\r\n}\r\ncase IMP_EVENT_ACTIVE:\r\nrc = obd_notify_observer(obd, obd, OBD_NOTIFY_ACTIVE, NULL);\r\nif (rc == 0)\r\nrc = libcfs_kkuc_group_foreach(KUC_GRP_HSM,\r\nmdc_hsm_ct_reregister,\r\n(void *)imp);\r\nbreak;\r\ncase IMP_EVENT_OCD:\r\nrc = obd_notify_observer(obd, obd, OBD_NOTIFY_OCD, NULL);\r\nbreak;\r\ncase IMP_EVENT_DISCON:\r\ncase IMP_EVENT_DEACTIVATE:\r\ncase IMP_EVENT_ACTIVATE:\r\nbreak;\r\ndefault:\r\nCERROR("Unknown import event %x\n", event);\r\nLBUG();\r\n}\r\nreturn rc;\r\n}\r\nint mdc_fid_alloc(const struct lu_env *env, struct obd_export *exp,\r\nstruct lu_fid *fid, struct md_op_data *op_data)\r\n{\r\nstruct client_obd *cli = &exp->exp_obd->u.cli;\r\nstruct lu_client_seq *seq = cli->cl_seq;\r\nreturn seq_client_alloc_fid(env, seq, fid);\r\n}\r\nstatic struct obd_uuid *mdc_get_uuid(struct obd_export *exp)\r\n{\r\nstruct client_obd *cli = &exp->exp_obd->u.cli;\r\nreturn &cli->cl_target_uuid;\r\n}\r\nstatic int mdc_cancel_weight(struct ldlm_lock *lock)\r\n{\r\nif (lock->l_resource->lr_type != LDLM_IBITS)\r\nreturn 0;\r\nif (lock->l_policy_data.l_inodebits.bits & MDS_INODELOCK_OPEN)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int mdc_resource_inode_free(struct ldlm_resource *res)\r\n{\r\nif (res->lr_lvb_inode)\r\nres->lr_lvb_inode = NULL;\r\nreturn 0;\r\n}\r\nstatic int mdc_llog_init(struct obd_device *obd)\r\n{\r\nstruct obd_llog_group *olg = &obd->obd_olg;\r\nstruct llog_ctxt *ctxt;\r\nint rc;\r\nrc = llog_setup(NULL, obd, olg, LLOG_CHANGELOG_REPL_CTXT, obd,\r\n&llog_client_ops);\r\nif (rc)\r\nreturn rc;\r\nctxt = llog_group_get_ctxt(olg, LLOG_CHANGELOG_REPL_CTXT);\r\nllog_initiator_connect(ctxt);\r\nllog_ctxt_put(ctxt);\r\nreturn 0;\r\n}\r\nstatic void mdc_llog_finish(struct obd_device *obd)\r\n{\r\nstruct llog_ctxt *ctxt;\r\nctxt = llog_get_context(obd, LLOG_CHANGELOG_REPL_CTXT);\r\nif (ctxt)\r\nllog_cleanup(NULL, ctxt);\r\n}\r\nstatic int mdc_setup(struct obd_device *obd, struct lustre_cfg *cfg)\r\n{\r\nstruct lprocfs_static_vars lvars = { NULL };\r\nint rc;\r\nrc = ptlrpcd_addref();\r\nif (rc < 0)\r\nreturn rc;\r\nrc = client_obd_setup(obd, cfg);\r\nif (rc)\r\ngoto err_ptlrpcd_decref;\r\nlprocfs_mdc_init_vars(&lvars);\r\nlprocfs_obd_setup(obd, lvars.obd_vars, lvars.sysfs_vars);\r\nsptlrpc_lprocfs_cliobd_attach(obd);\r\nptlrpc_lprocfs_register_obd(obd);\r\nns_register_cancel(obd->obd_namespace, mdc_cancel_weight);\r\nobd->obd_namespace->ns_lvbo = &inode_lvbo;\r\nrc = mdc_llog_init(obd);\r\nif (rc) {\r\nmdc_cleanup(obd);\r\nCERROR("failed to setup llogging subsystems\n");\r\nreturn rc;\r\n}\r\nreturn rc;\r\nerr_ptlrpcd_decref:\r\nptlrpcd_decref();\r\nreturn rc;\r\n}\r\nstatic int mdc_init_ea_size(struct obd_export *exp, u32 easize, u32 def_easize)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct client_obd *cli = &obd->u.cli;\r\nif (cli->cl_max_mds_easize < easize)\r\ncli->cl_max_mds_easize = easize;\r\nif (cli->cl_default_mds_easize < def_easize)\r\ncli->cl_default_mds_easize = def_easize;\r\nreturn 0;\r\n}\r\nstatic int mdc_precleanup(struct obd_device *obd)\r\n{\r\nif (obd->obd_type->typ_refcnt <= 1)\r\nlibcfs_kkuc_group_rem(0, KUC_GRP_HSM);\r\nobd_cleanup_client_import(obd);\r\nptlrpc_lprocfs_unregister_obd(obd);\r\nlprocfs_obd_cleanup(obd);\r\nmdc_llog_finish(obd);\r\nreturn 0;\r\n}\r\nstatic int mdc_cleanup(struct obd_device *obd)\r\n{\r\nptlrpcd_decref();\r\nreturn client_obd_cleanup(obd);\r\n}\r\nstatic int mdc_process_config(struct obd_device *obd, u32 len, void *buf)\r\n{\r\nstruct lustre_cfg *lcfg = buf;\r\nstruct lprocfs_static_vars lvars = { NULL };\r\nint rc = 0;\r\nlprocfs_mdc_init_vars(&lvars);\r\nswitch (lcfg->lcfg_command) {\r\ndefault:\r\nrc = class_process_proc_param(PARAM_MDC, lvars.obd_vars,\r\nlcfg, obd);\r\nif (rc > 0)\r\nrc = 0;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int __init mdc_init(void)\r\n{\r\nstruct lprocfs_static_vars lvars = { NULL };\r\nlprocfs_mdc_init_vars(&lvars);\r\nreturn class_register_type(&mdc_obd_ops, &mdc_md_ops,\r\nLUSTRE_MDC_NAME, NULL);\r\n}\r\nstatic void mdc_exit(void)\r\n{\r\nclass_unregister_type(LUSTRE_MDC_NAME);\r\n}
