static int\r\nnfnl_acct_new(struct sock *nfnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh, const struct nlattr * const tb[])\r\n{\r\nstruct nf_acct *nfacct, *matching = NULL;\r\nchar *acct_name;\r\nunsigned int size = 0;\r\nu32 flags = 0;\r\nif (!tb[NFACCT_NAME])\r\nreturn -EINVAL;\r\nacct_name = nla_data(tb[NFACCT_NAME]);\r\nif (strlen(acct_name) == 0)\r\nreturn -EINVAL;\r\nlist_for_each_entry(nfacct, &nfnl_acct_list, head) {\r\nif (strncmp(nfacct->name, acct_name, NFACCT_NAME_MAX) != 0)\r\ncontinue;\r\nif (nlh->nlmsg_flags & NLM_F_EXCL)\r\nreturn -EEXIST;\r\nmatching = nfacct;\r\nbreak;\r\n}\r\nif (matching) {\r\nif (nlh->nlmsg_flags & NLM_F_REPLACE) {\r\natomic64_set(&matching->pkts, 0);\r\natomic64_set(&matching->bytes, 0);\r\nsmp_mb__before_atomic();\r\nif ((matching->flags & NFACCT_F_QUOTA))\r\nclear_bit(NFACCT_OVERQUOTA_BIT,\r\n&matching->flags);\r\nreturn 0;\r\n}\r\nreturn -EBUSY;\r\n}\r\nif (tb[NFACCT_FLAGS]) {\r\nflags = ntohl(nla_get_be32(tb[NFACCT_FLAGS]));\r\nif (flags & ~NFACCT_F_QUOTA)\r\nreturn -EOPNOTSUPP;\r\nif ((flags & NFACCT_F_QUOTA) == NFACCT_F_QUOTA)\r\nreturn -EINVAL;\r\nif (flags & NFACCT_F_OVERQUOTA)\r\nreturn -EINVAL;\r\nsize += sizeof(u64);\r\n}\r\nnfacct = kzalloc(sizeof(struct nf_acct) + size, GFP_KERNEL);\r\nif (nfacct == NULL)\r\nreturn -ENOMEM;\r\nif (flags & NFACCT_F_QUOTA) {\r\nu64 *quota = (u64 *)nfacct->data;\r\n*quota = be64_to_cpu(nla_get_be64(tb[NFACCT_QUOTA]));\r\nnfacct->flags = flags;\r\n}\r\nstrncpy(nfacct->name, nla_data(tb[NFACCT_NAME]), NFACCT_NAME_MAX);\r\nif (tb[NFACCT_BYTES]) {\r\natomic64_set(&nfacct->bytes,\r\nbe64_to_cpu(nla_get_be64(tb[NFACCT_BYTES])));\r\n}\r\nif (tb[NFACCT_PKTS]) {\r\natomic64_set(&nfacct->pkts,\r\nbe64_to_cpu(nla_get_be64(tb[NFACCT_PKTS])));\r\n}\r\natomic_set(&nfacct->refcnt, 1);\r\nlist_add_tail_rcu(&nfacct->head, &nfnl_acct_list);\r\nreturn 0;\r\n}\r\nstatic int\r\nnfnl_acct_fill_info(struct sk_buff *skb, u32 portid, u32 seq, u32 type,\r\nint event, struct nf_acct *acct)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct nfgenmsg *nfmsg;\r\nunsigned int flags = portid ? NLM_F_MULTI : 0;\r\nu64 pkts, bytes;\r\nu32 old_flags;\r\nevent |= NFNL_SUBSYS_ACCT << 8;\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(*nfmsg), flags);\r\nif (nlh == NULL)\r\ngoto nlmsg_failure;\r\nnfmsg = nlmsg_data(nlh);\r\nnfmsg->nfgen_family = AF_UNSPEC;\r\nnfmsg->version = NFNETLINK_V0;\r\nnfmsg->res_id = 0;\r\nif (nla_put_string(skb, NFACCT_NAME, acct->name))\r\ngoto nla_put_failure;\r\nold_flags = acct->flags;\r\nif (type == NFNL_MSG_ACCT_GET_CTRZERO) {\r\npkts = atomic64_xchg(&acct->pkts, 0);\r\nbytes = atomic64_xchg(&acct->bytes, 0);\r\nsmp_mb__before_atomic();\r\nif (acct->flags & NFACCT_F_QUOTA)\r\nclear_bit(NFACCT_OVERQUOTA_BIT, &acct->flags);\r\n} else {\r\npkts = atomic64_read(&acct->pkts);\r\nbytes = atomic64_read(&acct->bytes);\r\n}\r\nif (nla_put_be64(skb, NFACCT_PKTS, cpu_to_be64(pkts)) ||\r\nnla_put_be64(skb, NFACCT_BYTES, cpu_to_be64(bytes)) ||\r\nnla_put_be32(skb, NFACCT_USE, htonl(atomic_read(&acct->refcnt))))\r\ngoto nla_put_failure;\r\nif (acct->flags & NFACCT_F_QUOTA) {\r\nu64 *quota = (u64 *)acct->data;\r\nif (nla_put_be32(skb, NFACCT_FLAGS, htonl(old_flags)) ||\r\nnla_put_be64(skb, NFACCT_QUOTA, cpu_to_be64(*quota)))\r\ngoto nla_put_failure;\r\n}\r\nnlmsg_end(skb, nlh);\r\nreturn skb->len;\r\nnlmsg_failure:\r\nnla_put_failure:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -1;\r\n}\r\nstatic int\r\nnfnl_acct_dump(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct nf_acct *cur, *last;\r\nconst struct nfacct_filter *filter = cb->data;\r\nif (cb->args[2])\r\nreturn 0;\r\nlast = (struct nf_acct *)cb->args[1];\r\nif (cb->args[1])\r\ncb->args[1] = 0;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(cur, &nfnl_acct_list, head) {\r\nif (last) {\r\nif (cur != last)\r\ncontinue;\r\nlast = NULL;\r\n}\r\nif (filter && (cur->flags & filter->mask) != filter->value)\r\ncontinue;\r\nif (nfnl_acct_fill_info(skb, NETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nNFNL_MSG_TYPE(cb->nlh->nlmsg_type),\r\nNFNL_MSG_ACCT_NEW, cur) < 0) {\r\ncb->args[1] = (unsigned long)cur;\r\nbreak;\r\n}\r\n}\r\nif (!cb->args[1])\r\ncb->args[2] = 1;\r\nrcu_read_unlock();\r\nreturn skb->len;\r\n}\r\nstatic int nfnl_acct_done(struct netlink_callback *cb)\r\n{\r\nkfree(cb->data);\r\nreturn 0;\r\n}\r\nstatic struct nfacct_filter *\r\nnfacct_filter_alloc(const struct nlattr * const attr)\r\n{\r\nstruct nfacct_filter *filter;\r\nstruct nlattr *tb[NFACCT_FILTER_MAX + 1];\r\nint err;\r\nerr = nla_parse_nested(tb, NFACCT_FILTER_MAX, attr, filter_policy);\r\nif (err < 0)\r\nreturn ERR_PTR(err);\r\nfilter = kzalloc(sizeof(struct nfacct_filter), GFP_KERNEL);\r\nif (!filter)\r\nreturn ERR_PTR(-ENOMEM);\r\nfilter->mask = ntohl(nla_get_be32(tb[NFACCT_FILTER_MASK]));\r\nfilter->value = ntohl(nla_get_be32(tb[NFACCT_FILTER_VALUE]));\r\nreturn filter;\r\n}\r\nstatic int\r\nnfnl_acct_get(struct sock *nfnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh, const struct nlattr * const tb[])\r\n{\r\nint ret = -ENOENT;\r\nstruct nf_acct *cur;\r\nchar *acct_name;\r\nif (nlh->nlmsg_flags & NLM_F_DUMP) {\r\nstruct netlink_dump_control c = {\r\n.dump = nfnl_acct_dump,\r\n.done = nfnl_acct_done,\r\n};\r\nif (tb[NFACCT_FILTER]) {\r\nstruct nfacct_filter *filter;\r\nfilter = nfacct_filter_alloc(tb[NFACCT_FILTER]);\r\nif (IS_ERR(filter))\r\nreturn PTR_ERR(filter);\r\nc.data = filter;\r\n}\r\nreturn netlink_dump_start(nfnl, skb, nlh, &c);\r\n}\r\nif (!tb[NFACCT_NAME])\r\nreturn -EINVAL;\r\nacct_name = nla_data(tb[NFACCT_NAME]);\r\nlist_for_each_entry(cur, &nfnl_acct_list, head) {\r\nstruct sk_buff *skb2;\r\nif (strncmp(cur->name, acct_name, NFACCT_NAME_MAX)!= 0)\r\ncontinue;\r\nskb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (skb2 == NULL) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nret = nfnl_acct_fill_info(skb2, NETLINK_CB(skb).portid,\r\nnlh->nlmsg_seq,\r\nNFNL_MSG_TYPE(nlh->nlmsg_type),\r\nNFNL_MSG_ACCT_NEW, cur);\r\nif (ret <= 0) {\r\nkfree_skb(skb2);\r\nbreak;\r\n}\r\nret = netlink_unicast(nfnl, skb2, NETLINK_CB(skb).portid,\r\nMSG_DONTWAIT);\r\nif (ret > 0)\r\nret = 0;\r\nreturn ret == -EAGAIN ? -ENOBUFS : ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int nfnl_acct_try_del(struct nf_acct *cur)\r\n{\r\nint ret = 0;\r\nif (atomic_dec_and_test(&cur->refcnt)) {\r\nlist_del_rcu(&cur->head);\r\nkfree_rcu(cur, rcu_head);\r\n} else {\r\natomic_inc(&cur->refcnt);\r\nret = -EBUSY;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nnfnl_acct_del(struct sock *nfnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh, const struct nlattr * const tb[])\r\n{\r\nchar *acct_name;\r\nstruct nf_acct *cur;\r\nint ret = -ENOENT;\r\nif (!tb[NFACCT_NAME]) {\r\nlist_for_each_entry(cur, &nfnl_acct_list, head)\r\nnfnl_acct_try_del(cur);\r\nreturn 0;\r\n}\r\nacct_name = nla_data(tb[NFACCT_NAME]);\r\nlist_for_each_entry(cur, &nfnl_acct_list, head) {\r\nif (strncmp(cur->name, acct_name, NFACCT_NAME_MAX) != 0)\r\ncontinue;\r\nret = nfnl_acct_try_del(cur);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstruct nf_acct *nfnl_acct_find_get(const char *acct_name)\r\n{\r\nstruct nf_acct *cur, *acct = NULL;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(cur, &nfnl_acct_list, head) {\r\nif (strncmp(cur->name, acct_name, NFACCT_NAME_MAX)!= 0)\r\ncontinue;\r\nif (!try_module_get(THIS_MODULE))\r\ngoto err;\r\nif (!atomic_inc_not_zero(&cur->refcnt)) {\r\nmodule_put(THIS_MODULE);\r\ngoto err;\r\n}\r\nacct = cur;\r\nbreak;\r\n}\r\nerr:\r\nrcu_read_unlock();\r\nreturn acct;\r\n}\r\nvoid nfnl_acct_put(struct nf_acct *acct)\r\n{\r\natomic_dec(&acct->refcnt);\r\nmodule_put(THIS_MODULE);\r\n}\r\nvoid nfnl_acct_update(const struct sk_buff *skb, struct nf_acct *nfacct)\r\n{\r\natomic64_inc(&nfacct->pkts);\r\natomic64_add(skb->len, &nfacct->bytes);\r\n}\r\nstatic void nfnl_overquota_report(struct nf_acct *nfacct)\r\n{\r\nint ret;\r\nstruct sk_buff *skb;\r\nskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn;\r\nret = nfnl_acct_fill_info(skb, 0, 0, NFNL_MSG_ACCT_OVERQUOTA, 0,\r\nnfacct);\r\nif (ret <= 0) {\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nnetlink_broadcast(init_net.nfnl, skb, 0, NFNLGRP_ACCT_QUOTA,\r\nGFP_ATOMIC);\r\n}\r\nint nfnl_acct_overquota(const struct sk_buff *skb, struct nf_acct *nfacct)\r\n{\r\nu64 now;\r\nu64 *quota;\r\nint ret = NFACCT_UNDERQUOTA;\r\nif (!(nfacct->flags & NFACCT_F_QUOTA))\r\nreturn NFACCT_NO_QUOTA;\r\nquota = (u64 *)nfacct->data;\r\nnow = (nfacct->flags & NFACCT_F_QUOTA_PKTS) ?\r\natomic64_read(&nfacct->pkts) : atomic64_read(&nfacct->bytes);\r\nret = now > *quota;\r\nif (now >= *quota &&\r\n!test_and_set_bit(NFACCT_OVERQUOTA_BIT, &nfacct->flags)) {\r\nnfnl_overquota_report(nfacct);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init nfnl_acct_init(void)\r\n{\r\nint ret;\r\npr_info("nfnl_acct: registering with nfnetlink.\n");\r\nret = nfnetlink_subsys_register(&nfnl_acct_subsys);\r\nif (ret < 0) {\r\npr_err("nfnl_acct_init: cannot register with nfnetlink.\n");\r\ngoto err_out;\r\n}\r\nreturn 0;\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic void __exit nfnl_acct_exit(void)\r\n{\r\nstruct nf_acct *cur, *tmp;\r\npr_info("nfnl_acct: unregistering from nfnetlink.\n");\r\nnfnetlink_subsys_unregister(&nfnl_acct_subsys);\r\nlist_for_each_entry_safe(cur, tmp, &nfnl_acct_list, head) {\r\nlist_del_rcu(&cur->head);\r\nkfree_rcu(cur, rcu_head);\r\n}\r\n}
