i40e_status i40e_set_mac_type(struct i40e_hw *hw)\r\n{\r\ni40e_status status = 0;\r\nif (hw->vendor_id == PCI_VENDOR_ID_INTEL) {\r\nswitch (hw->device_id) {\r\ncase I40E_DEV_ID_SFP_XL710:\r\ncase I40E_DEV_ID_QEMU:\r\ncase I40E_DEV_ID_KX_A:\r\ncase I40E_DEV_ID_KX_B:\r\ncase I40E_DEV_ID_KX_C:\r\ncase I40E_DEV_ID_QSFP_A:\r\ncase I40E_DEV_ID_QSFP_B:\r\ncase I40E_DEV_ID_QSFP_C:\r\ncase I40E_DEV_ID_10G_BASE_T:\r\ncase I40E_DEV_ID_20G_KR2:\r\nhw->mac.type = I40E_MAC_XL710;\r\nbreak;\r\ncase I40E_DEV_ID_VF:\r\ncase I40E_DEV_ID_VF_HV:\r\nhw->mac.type = I40E_MAC_VF;\r\nbreak;\r\ndefault:\r\nhw->mac.type = I40E_MAC_GENERIC;\r\nbreak;\r\n}\r\n} else {\r\nstatus = I40E_ERR_DEVICE_NOT_SUPPORTED;\r\n}\r\nhw_dbg(hw, "i40e_set_mac_type found mac: %d, returns: %d\n",\r\nhw->mac.type, status);\r\nreturn status;\r\n}\r\nvoid i40evf_debug_aq(struct i40e_hw *hw, enum i40e_debug_mask mask, void *desc,\r\nvoid *buffer, u16 buf_len)\r\n{\r\nstruct i40e_aq_desc *aq_desc = (struct i40e_aq_desc *)desc;\r\nu16 len = le16_to_cpu(aq_desc->datalen);\r\nu8 *buf = (u8 *)buffer;\r\nu16 i = 0;\r\nif ((!(mask & hw->debug_mask)) || (desc == NULL))\r\nreturn;\r\ni40e_debug(hw, mask,\r\n"AQ CMD: opcode 0x%04X, flags 0x%04X, datalen 0x%04X, retval 0x%04X\n",\r\nle16_to_cpu(aq_desc->opcode),\r\nle16_to_cpu(aq_desc->flags),\r\nle16_to_cpu(aq_desc->datalen),\r\nle16_to_cpu(aq_desc->retval));\r\ni40e_debug(hw, mask, "\tcookie (h,l) 0x%08X 0x%08X\n",\r\nle32_to_cpu(aq_desc->cookie_high),\r\nle32_to_cpu(aq_desc->cookie_low));\r\ni40e_debug(hw, mask, "\tparam (0,1) 0x%08X 0x%08X\n",\r\nle32_to_cpu(aq_desc->params.internal.param0),\r\nle32_to_cpu(aq_desc->params.internal.param1));\r\ni40e_debug(hw, mask, "\taddr (h,l) 0x%08X 0x%08X\n",\r\nle32_to_cpu(aq_desc->params.external.addr_high),\r\nle32_to_cpu(aq_desc->params.external.addr_low));\r\nif ((buffer != NULL) && (aq_desc->datalen != 0)) {\r\ni40e_debug(hw, mask, "AQ CMD Buffer:\n");\r\nif (buf_len < len)\r\nlen = buf_len;\r\nfor (i = 0; i < (len - 16); i += 16)\r\ni40e_debug(hw, mask,\r\n"\t0x%04X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X\n",\r\ni, buf[i], buf[i + 1], buf[i + 2],\r\nbuf[i + 3], buf[i + 4], buf[i + 5],\r\nbuf[i + 6], buf[i + 7], buf[i + 8],\r\nbuf[i + 9], buf[i + 10], buf[i + 11],\r\nbuf[i + 12], buf[i + 13], buf[i + 14],\r\nbuf[i + 15]);\r\nif (i < len) {\r\nchar d_buf[80];\r\nint j = 0;\r\nmemset(d_buf, 0, sizeof(d_buf));\r\nj += sprintf(d_buf, "\t0x%04X ", i);\r\nwhile (i < len)\r\nj += sprintf(&d_buf[j], " %02X", buf[i++]);\r\ni40e_debug(hw, mask, "%s\n", d_buf);\r\n}\r\n}\r\n}\r\nbool i40evf_check_asq_alive(struct i40e_hw *hw)\r\n{\r\nif (hw->aq.asq.len)\r\nreturn !!(rd32(hw, hw->aq.asq.len) &\r\nI40E_PF_ATQLEN_ATQENABLE_MASK);\r\nelse\r\nreturn false;\r\n}\r\ni40e_status i40evf_aq_queue_shutdown(struct i40e_hw *hw,\r\nbool unloading)\r\n{\r\nstruct i40e_aq_desc desc;\r\nstruct i40e_aqc_queue_shutdown *cmd =\r\n(struct i40e_aqc_queue_shutdown *)&desc.params.raw;\r\ni40e_status status;\r\ni40evf_fill_default_direct_cmd_desc(&desc,\r\ni40e_aqc_opc_queue_shutdown);\r\nif (unloading)\r\ncmd->driver_unloading = cpu_to_le32(I40E_AQ_DRIVER_UNLOADING);\r\nstatus = i40evf_asq_send_command(hw, &desc, NULL, 0, NULL);\r\nreturn status;\r\n}\r\ni40e_status i40e_aq_send_msg_to_pf(struct i40e_hw *hw,\r\nenum i40e_virtchnl_ops v_opcode,\r\ni40e_status v_retval,\r\nu8 *msg, u16 msglen,\r\nstruct i40e_asq_cmd_details *cmd_details)\r\n{\r\nstruct i40e_aq_desc desc;\r\nstruct i40e_asq_cmd_details details;\r\ni40e_status status;\r\ni40evf_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_send_msg_to_pf);\r\ndesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_SI);\r\ndesc.cookie_high = cpu_to_le32(v_opcode);\r\ndesc.cookie_low = cpu_to_le32(v_retval);\r\nif (msglen) {\r\ndesc.flags |= cpu_to_le16((u16)(I40E_AQ_FLAG_BUF\r\n| I40E_AQ_FLAG_RD));\r\nif (msglen > I40E_AQ_LARGE_BUF)\r\ndesc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_LB);\r\ndesc.datalen = cpu_to_le16(msglen);\r\n}\r\nif (!cmd_details) {\r\nmemset(&details, 0, sizeof(details));\r\ndetails.async = true;\r\ncmd_details = &details;\r\n}\r\nstatus = i40evf_asq_send_command(hw, &desc, msg, msglen, cmd_details);\r\nreturn status;\r\n}\r\nvoid i40e_vf_parse_hw_config(struct i40e_hw *hw,\r\nstruct i40e_virtchnl_vf_resource *msg)\r\n{\r\nstruct i40e_virtchnl_vsi_resource *vsi_res;\r\nint i;\r\nvsi_res = &msg->vsi_res[0];\r\nhw->dev_caps.num_vsis = msg->num_vsis;\r\nhw->dev_caps.num_rx_qp = msg->num_queue_pairs;\r\nhw->dev_caps.num_tx_qp = msg->num_queue_pairs;\r\nhw->dev_caps.num_msix_vectors_vf = msg->max_vectors;\r\nhw->dev_caps.dcb = msg->vf_offload_flags &\r\nI40E_VIRTCHNL_VF_OFFLOAD_L2;\r\nhw->dev_caps.fcoe = (msg->vf_offload_flags &\r\nI40E_VIRTCHNL_VF_OFFLOAD_FCOE) ? 1 : 0;\r\nfor (i = 0; i < msg->num_vsis; i++) {\r\nif (vsi_res->vsi_type == I40E_VSI_SRIOV) {\r\nmemcpy(hw->mac.perm_addr, vsi_res->default_mac_addr,\r\nETH_ALEN);\r\nmemcpy(hw->mac.addr, vsi_res->default_mac_addr,\r\nETH_ALEN);\r\n}\r\nvsi_res++;\r\n}\r\n}\r\ni40e_status i40e_vf_reset(struct i40e_hw *hw)\r\n{\r\nreturn i40e_aq_send_msg_to_pf(hw, I40E_VIRTCHNL_OP_RESET_VF,\r\n0, NULL, 0, NULL);\r\n}
