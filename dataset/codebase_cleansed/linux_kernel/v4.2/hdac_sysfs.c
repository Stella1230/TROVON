static int get_codec_nid(struct kobject *kobj, struct hdac_device **codecp)\r\n{\r\nstruct device *dev = kobj_to_dev(kobj->parent->parent);\r\nint nid;\r\nssize_t ret;\r\nret = kstrtoint(kobj->name, 16, &nid);\r\nif (ret < 0)\r\nreturn ret;\r\n*codecp = dev_to_hdac_dev(dev);\r\nreturn nid;\r\n}\r\nstatic ssize_t widget_attr_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct widget_attribute *wid_attr =\r\ncontainer_of(attr, struct widget_attribute, attr);\r\nstruct hdac_device *codec;\r\nint nid;\r\nif (!wid_attr->show)\r\nreturn -EIO;\r\nnid = get_codec_nid(kobj, &codec);\r\nif (nid < 0)\r\nreturn nid;\r\nreturn wid_attr->show(codec, nid, wid_attr, buf);\r\n}\r\nstatic ssize_t widget_attr_store(struct kobject *kobj, struct attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct widget_attribute *wid_attr =\r\ncontainer_of(attr, struct widget_attribute, attr);\r\nstruct hdac_device *codec;\r\nint nid;\r\nif (!wid_attr->store)\r\nreturn -EIO;\r\nnid = get_codec_nid(kobj, &codec);\r\nif (nid < 0)\r\nreturn nid;\r\nreturn wid_attr->store(codec, nid, wid_attr, buf, count);\r\n}\r\nstatic void widget_release(struct kobject *kobj)\r\n{\r\nkfree(kobj);\r\n}\r\nstatic ssize_t caps_show(struct hdac_device *codec, hda_nid_t nid,\r\nstruct widget_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "0x%08x\n", get_wcaps(codec, nid));\r\n}\r\nstatic ssize_t pin_caps_show(struct hdac_device *codec, hda_nid_t nid,\r\nstruct widget_attribute *attr, char *buf)\r\n{\r\nif (get_wcaps_type(get_wcaps(codec, nid)) != AC_WID_PIN)\r\nreturn 0;\r\nreturn sprintf(buf, "0x%08x\n",\r\nsnd_hdac_read_parm(codec, nid, AC_PAR_PIN_CAP));\r\n}\r\nstatic ssize_t pin_cfg_show(struct hdac_device *codec, hda_nid_t nid,\r\nstruct widget_attribute *attr, char *buf)\r\n{\r\nunsigned int val;\r\nif (get_wcaps_type(get_wcaps(codec, nid)) != AC_WID_PIN)\r\nreturn 0;\r\nif (snd_hdac_read(codec, nid, AC_VERB_GET_CONFIG_DEFAULT, 0, &val))\r\nreturn 0;\r\nreturn sprintf(buf, "0x%08x\n", val);\r\n}\r\nstatic bool has_pcm_cap(struct hdac_device *codec, hda_nid_t nid)\r\n{\r\nif (nid == codec->afg || nid == codec->mfg)\r\nreturn true;\r\nswitch (get_wcaps_type(get_wcaps(codec, nid))) {\r\ncase AC_WID_AUD_OUT:\r\ncase AC_WID_AUD_IN:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic ssize_t pcm_caps_show(struct hdac_device *codec, hda_nid_t nid,\r\nstruct widget_attribute *attr, char *buf)\r\n{\r\nif (!has_pcm_cap(codec, nid))\r\nreturn 0;\r\nreturn sprintf(buf, "0x%08x\n",\r\nsnd_hdac_read_parm(codec, nid, AC_PAR_PCM));\r\n}\r\nstatic ssize_t pcm_formats_show(struct hdac_device *codec, hda_nid_t nid,\r\nstruct widget_attribute *attr, char *buf)\r\n{\r\nif (!has_pcm_cap(codec, nid))\r\nreturn 0;\r\nreturn sprintf(buf, "0x%08x\n",\r\nsnd_hdac_read_parm(codec, nid, AC_PAR_STREAM));\r\n}\r\nstatic ssize_t amp_in_caps_show(struct hdac_device *codec, hda_nid_t nid,\r\nstruct widget_attribute *attr, char *buf)\r\n{\r\nif (nid != codec->afg && !(get_wcaps(codec, nid) & AC_WCAP_IN_AMP))\r\nreturn 0;\r\nreturn sprintf(buf, "0x%08x\n",\r\nsnd_hdac_read_parm(codec, nid, AC_PAR_AMP_IN_CAP));\r\n}\r\nstatic ssize_t amp_out_caps_show(struct hdac_device *codec, hda_nid_t nid,\r\nstruct widget_attribute *attr, char *buf)\r\n{\r\nif (nid != codec->afg && !(get_wcaps(codec, nid) & AC_WCAP_OUT_AMP))\r\nreturn 0;\r\nreturn sprintf(buf, "0x%08x\n",\r\nsnd_hdac_read_parm(codec, nid, AC_PAR_AMP_OUT_CAP));\r\n}\r\nstatic ssize_t power_caps_show(struct hdac_device *codec, hda_nid_t nid,\r\nstruct widget_attribute *attr, char *buf)\r\n{\r\nif (nid != codec->afg && !(get_wcaps(codec, nid) & AC_WCAP_POWER))\r\nreturn 0;\r\nreturn sprintf(buf, "0x%08x\n",\r\nsnd_hdac_read_parm(codec, nid, AC_PAR_POWER_STATE));\r\n}\r\nstatic ssize_t gpio_caps_show(struct hdac_device *codec, hda_nid_t nid,\r\nstruct widget_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "0x%08x\n",\r\nsnd_hdac_read_parm(codec, nid, AC_PAR_GPIO_CAP));\r\n}\r\nstatic ssize_t connections_show(struct hdac_device *codec, hda_nid_t nid,\r\nstruct widget_attribute *attr, char *buf)\r\n{\r\nhda_nid_t list[32];\r\nint i, nconns;\r\nssize_t ret = 0;\r\nnconns = snd_hdac_get_connections(codec, nid, list, ARRAY_SIZE(list));\r\nif (nconns <= 0)\r\nreturn nconns;\r\nfor (i = 0; i < nconns; i++)\r\nret += sprintf(buf + ret, "%s0x%02x", i ? " " : "", list[i]);\r\nret += sprintf(buf + ret, "\n");\r\nreturn ret;\r\n}\r\nstatic void free_widget_node(struct kobject *kobj,\r\nconst struct attribute_group *group)\r\n{\r\nif (kobj) {\r\nsysfs_remove_group(kobj, group);\r\nkobject_put(kobj);\r\n}\r\n}\r\nstatic void widget_tree_free(struct hdac_device *codec)\r\n{\r\nstruct hdac_widget_tree *tree = codec->widgets;\r\nstruct kobject **p;\r\nif (!tree)\r\nreturn;\r\nfree_widget_node(tree->afg, &widget_afg_group);\r\nif (tree->nodes) {\r\nfor (p = tree->nodes; *p; p++)\r\nfree_widget_node(*p, &widget_node_group);\r\nkfree(tree->nodes);\r\n}\r\nif (tree->root)\r\nkobject_put(tree->root);\r\nkfree(tree);\r\ncodec->widgets = NULL;\r\n}\r\nstatic int add_widget_node(struct kobject *parent, hda_nid_t nid,\r\nconst struct attribute_group *group,\r\nstruct kobject **res)\r\n{\r\nstruct kobject *kobj = kzalloc(sizeof(*kobj), GFP_KERNEL);\r\nint err;\r\nif (!kobj)\r\nreturn -ENOMEM;\r\nkobject_init(kobj, &widget_ktype);\r\nerr = kobject_add(kobj, parent, "%02x", nid);\r\nif (err < 0)\r\nreturn err;\r\nerr = sysfs_create_group(kobj, group);\r\nif (err < 0) {\r\nkobject_put(kobj);\r\nreturn err;\r\n}\r\n*res = kobj;\r\nreturn 0;\r\n}\r\nstatic int widget_tree_create(struct hdac_device *codec)\r\n{\r\nstruct hdac_widget_tree *tree;\r\nint i, err;\r\nhda_nid_t nid;\r\ntree = codec->widgets = kzalloc(sizeof(*tree), GFP_KERNEL);\r\nif (!tree)\r\nreturn -ENOMEM;\r\ntree->root = kobject_create_and_add("widgets", &codec->dev.kobj);\r\nif (!tree->root)\r\nreturn -ENOMEM;\r\ntree->nodes = kcalloc(codec->num_nodes + 1, sizeof(*tree->nodes),\r\nGFP_KERNEL);\r\nif (!tree->nodes)\r\nreturn -ENOMEM;\r\nfor (i = 0, nid = codec->start_nid; i < codec->num_nodes; i++, nid++) {\r\nerr = add_widget_node(tree->root, nid, &widget_node_group,\r\n&tree->nodes[i]);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (codec->afg) {\r\nerr = add_widget_node(tree->root, codec->afg,\r\n&widget_afg_group, &tree->afg);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nkobject_uevent(tree->root, KOBJ_CHANGE);\r\nreturn 0;\r\n}\r\nint hda_widget_sysfs_init(struct hdac_device *codec)\r\n{\r\nint err;\r\nerr = widget_tree_create(codec);\r\nif (err < 0) {\r\nwidget_tree_free(codec);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nvoid hda_widget_sysfs_exit(struct hdac_device *codec)\r\n{\r\nwidget_tree_free(codec);\r\n}
