static void init_busid_table(void)\r\n{\r\nmemset(busid_table, 0, sizeof(busid_table));\r\nspin_lock_init(&busid_table_lock);\r\n}\r\nstatic int get_busid_idx(const char *busid)\r\n{\r\nint i;\r\nint idx = -1;\r\nfor (i = 0; i < MAX_BUSID; i++)\r\nif (busid_table[i].name[0])\r\nif (!strncmp(busid_table[i].name, busid, BUSID_SIZE)) {\r\nidx = i;\r\nbreak;\r\n}\r\nreturn idx;\r\n}\r\nstruct bus_id_priv *get_busid_priv(const char *busid)\r\n{\r\nint idx;\r\nstruct bus_id_priv *bid = NULL;\r\nspin_lock(&busid_table_lock);\r\nidx = get_busid_idx(busid);\r\nif (idx >= 0)\r\nbid = &(busid_table[idx]);\r\nspin_unlock(&busid_table_lock);\r\nreturn bid;\r\n}\r\nstatic int add_match_busid(char *busid)\r\n{\r\nint i;\r\nint ret = -1;\r\nspin_lock(&busid_table_lock);\r\nif (get_busid_idx(busid) >= 0) {\r\nret = 0;\r\ngoto out;\r\n}\r\nfor (i = 0; i < MAX_BUSID; i++)\r\nif (!busid_table[i].name[0]) {\r\nstrlcpy(busid_table[i].name, busid, BUSID_SIZE);\r\nif ((busid_table[i].status != STUB_BUSID_ALLOC) &&\r\n(busid_table[i].status != STUB_BUSID_REMOV))\r\nbusid_table[i].status = STUB_BUSID_ADDED;\r\nret = 0;\r\nbreak;\r\n}\r\nout:\r\nspin_unlock(&busid_table_lock);\r\nreturn ret;\r\n}\r\nint del_match_busid(char *busid)\r\n{\r\nint idx;\r\nint ret = -1;\r\nspin_lock(&busid_table_lock);\r\nidx = get_busid_idx(busid);\r\nif (idx < 0)\r\ngoto out;\r\nret = 0;\r\nif (busid_table[idx].status == STUB_BUSID_OTHER)\r\nmemset(busid_table[idx].name, 0, BUSID_SIZE);\r\nif ((busid_table[idx].status != STUB_BUSID_OTHER) &&\r\n(busid_table[idx].status != STUB_BUSID_ADDED))\r\nbusid_table[idx].status = STUB_BUSID_REMOV;\r\nout:\r\nspin_unlock(&busid_table_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t show_match_busid(struct device_driver *drv, char *buf)\r\n{\r\nint i;\r\nchar *out = buf;\r\nspin_lock(&busid_table_lock);\r\nfor (i = 0; i < MAX_BUSID; i++)\r\nif (busid_table[i].name[0])\r\nout += sprintf(out, "%s ", busid_table[i].name);\r\nspin_unlock(&busid_table_lock);\r\nout += sprintf(out, "\n");\r\nreturn out - buf;\r\n}\r\nstatic ssize_t store_match_busid(struct device_driver *dev, const char *buf,\r\nsize_t count)\r\n{\r\nint len;\r\nchar busid[BUSID_SIZE];\r\nif (count < 5)\r\nreturn -EINVAL;\r\nlen = strlcpy(busid, buf + 4, BUSID_SIZE);\r\nif (sizeof(busid) <= len)\r\nreturn -EINVAL;\r\nif (!strncmp(buf, "add ", 4)) {\r\nif (add_match_busid(busid) < 0)\r\nreturn -ENOMEM;\r\npr_debug("add busid %s\n", busid);\r\nreturn count;\r\n}\r\nif (!strncmp(buf, "del ", 4)) {\r\nif (del_match_busid(busid) < 0)\r\nreturn -ENODEV;\r\npr_debug("del busid %s\n", busid);\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t rebind_store(struct device_driver *dev, const char *buf,\r\nsize_t count)\r\n{\r\nint ret;\r\nint len;\r\nstruct bus_id_priv *bid;\r\nlen = strnlen(buf, BUSID_SIZE);\r\nif (!(len < BUSID_SIZE))\r\nreturn -EINVAL;\r\nbid = get_busid_priv(buf);\r\nif (!bid)\r\nreturn -ENODEV;\r\nret = device_attach(&bid->udev->dev);\r\nif (ret < 0) {\r\ndev_err(&bid->udev->dev, "rebind failed\n");\r\nreturn ret;\r\n}\r\nreturn count;\r\n}\r\nstatic struct stub_priv *stub_priv_pop_from_listhead(struct list_head *listhead)\r\n{\r\nstruct stub_priv *priv, *tmp;\r\nlist_for_each_entry_safe(priv, tmp, listhead, list) {\r\nlist_del(&priv->list);\r\nreturn priv;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct stub_priv *stub_priv_pop(struct stub_device *sdev)\r\n{\r\nunsigned long flags;\r\nstruct stub_priv *priv;\r\nspin_lock_irqsave(&sdev->priv_lock, flags);\r\npriv = stub_priv_pop_from_listhead(&sdev->priv_init);\r\nif (priv)\r\ngoto done;\r\npriv = stub_priv_pop_from_listhead(&sdev->priv_tx);\r\nif (priv)\r\ngoto done;\r\npriv = stub_priv_pop_from_listhead(&sdev->priv_free);\r\ndone:\r\nspin_unlock_irqrestore(&sdev->priv_lock, flags);\r\nreturn priv;\r\n}\r\nvoid stub_device_cleanup_urbs(struct stub_device *sdev)\r\n{\r\nstruct stub_priv *priv;\r\nstruct urb *urb;\r\ndev_dbg(&sdev->udev->dev, "free sdev %p\n", sdev);\r\nwhile ((priv = stub_priv_pop(sdev))) {\r\nurb = priv->urb;\r\ndev_dbg(&sdev->udev->dev, "free urb %p\n", urb);\r\nusb_kill_urb(urb);\r\nkmem_cache_free(stub_priv_cache, priv);\r\nkfree(urb->transfer_buffer);\r\nkfree(urb->setup_packet);\r\nusb_free_urb(urb);\r\n}\r\n}\r\nstatic int __init usbip_host_init(void)\r\n{\r\nint ret;\r\ninit_busid_table();\r\nstub_priv_cache = KMEM_CACHE(stub_priv, SLAB_HWCACHE_ALIGN);\r\nif (!stub_priv_cache) {\r\npr_err("kmem_cache_create failed\n");\r\nreturn -ENOMEM;\r\n}\r\nret = usb_register_device_driver(&stub_driver, THIS_MODULE);\r\nif (ret) {\r\npr_err("usb_register failed %d\n", ret);\r\ngoto err_usb_register;\r\n}\r\nret = driver_create_file(&stub_driver.drvwrap.driver,\r\n&driver_attr_match_busid);\r\nif (ret) {\r\npr_err("driver_create_file failed\n");\r\ngoto err_create_file;\r\n}\r\nret = driver_create_file(&stub_driver.drvwrap.driver,\r\n&driver_attr_rebind);\r\nif (ret) {\r\npr_err("driver_create_file failed\n");\r\ngoto err_create_file;\r\n}\r\npr_info(DRIVER_DESC " v" USBIP_VERSION "\n");\r\nreturn ret;\r\nerr_create_file:\r\nusb_deregister_device_driver(&stub_driver);\r\nerr_usb_register:\r\nkmem_cache_destroy(stub_priv_cache);\r\nreturn ret;\r\n}\r\nstatic void __exit usbip_host_exit(void)\r\n{\r\ndriver_remove_file(&stub_driver.drvwrap.driver,\r\n&driver_attr_match_busid);\r\ndriver_remove_file(&stub_driver.drvwrap.driver,\r\n&driver_attr_rebind);\r\nusb_deregister_device_driver(&stub_driver);\r\nkmem_cache_destroy(stub_priv_cache);\r\n}
