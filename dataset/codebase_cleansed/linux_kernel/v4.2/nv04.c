int\r\nnv04_fifo_object_attach(struct nvkm_object *parent,\r\nstruct nvkm_object *object, u32 handle)\r\n{\r\nstruct nv04_fifo_priv *priv = (void *)parent->engine;\r\nstruct nv04_fifo_chan *chan = (void *)parent;\r\nu32 context, chid = chan->base.chid;\r\nint ret;\r\nif (nv_iclass(object, NV_GPUOBJ_CLASS))\r\ncontext = nv_gpuobj(object)->addr >> 4;\r\nelse\r\ncontext = 0x00000004;\r\nswitch (nv_engidx(object->engine)) {\r\ncase NVDEV_ENGINE_DMAOBJ:\r\ncase NVDEV_ENGINE_SW:\r\ncontext |= 0x00000000;\r\nbreak;\r\ncase NVDEV_ENGINE_GR:\r\ncontext |= 0x00010000;\r\nbreak;\r\ncase NVDEV_ENGINE_MPEG:\r\ncontext |= 0x00020000;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncontext |= 0x80000000;\r\ncontext |= chid << 24;\r\nmutex_lock(&nv_subdev(priv)->mutex);\r\nret = nvkm_ramht_insert(priv->ramht, chid, handle, context);\r\nmutex_unlock(&nv_subdev(priv)->mutex);\r\nreturn ret;\r\n}\r\nvoid\r\nnv04_fifo_object_detach(struct nvkm_object *parent, int cookie)\r\n{\r\nstruct nv04_fifo_priv *priv = (void *)parent->engine;\r\nmutex_lock(&nv_subdev(priv)->mutex);\r\nnvkm_ramht_remove(priv->ramht, cookie);\r\nmutex_unlock(&nv_subdev(priv)->mutex);\r\n}\r\nint\r\nnv04_fifo_context_attach(struct nvkm_object *parent,\r\nstruct nvkm_object *object)\r\n{\r\nnv_engctx(object)->addr = nvkm_fifo_chan(parent)->chid;\r\nreturn 0;\r\n}\r\nstatic int\r\nnv04_fifo_chan_ctor(struct nvkm_object *parent,\r\nstruct nvkm_object *engine,\r\nstruct nvkm_oclass *oclass, void *data, u32 size,\r\nstruct nvkm_object **pobject)\r\n{\r\nunion {\r\nstruct nv03_channel_dma_v0 v0;\r\n} *args = data;\r\nstruct nv04_fifo_priv *priv = (void *)engine;\r\nstruct nv04_fifo_chan *chan;\r\nint ret;\r\nnv_ioctl(parent, "create channel dma size %d\n", size);\r\nif (nvif_unpack(args->v0, 0, 0, false)) {\r\nnv_ioctl(parent, "create channel dma vers %d pushbuf %08x "\r\n"offset %016llx\n", args->v0.version,\r\nargs->v0.pushbuf, args->v0.offset);\r\n} else\r\nreturn ret;\r\nret = nvkm_fifo_channel_create(parent, engine, oclass, 0, 0x800000,\r\n0x10000, args->v0.pushbuf,\r\n(1ULL << NVDEV_ENGINE_DMAOBJ) |\r\n(1ULL << NVDEV_ENGINE_SW) |\r\n(1ULL << NVDEV_ENGINE_GR), &chan);\r\n*pobject = nv_object(chan);\r\nif (ret)\r\nreturn ret;\r\nargs->v0.chid = chan->base.chid;\r\nnv_parent(chan)->object_attach = nv04_fifo_object_attach;\r\nnv_parent(chan)->object_detach = nv04_fifo_object_detach;\r\nnv_parent(chan)->context_attach = nv04_fifo_context_attach;\r\nchan->ramfc = chan->base.chid * 32;\r\nnv_wo32(priv->ramfc, chan->ramfc + 0x00, args->v0.offset);\r\nnv_wo32(priv->ramfc, chan->ramfc + 0x04, args->v0.offset);\r\nnv_wo32(priv->ramfc, chan->ramfc + 0x08, chan->base.pushgpu->addr >> 4);\r\nnv_wo32(priv->ramfc, chan->ramfc + 0x10,\r\nNV_PFIFO_CACHE1_DMA_FETCH_TRIG_128_BYTES |\r\nNV_PFIFO_CACHE1_DMA_FETCH_SIZE_128_BYTES |\r\n#ifdef __BIG_ENDIAN\r\nNV_PFIFO_CACHE1_BIG_ENDIAN |\r\n#endif\r\nNV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_8);\r\nreturn 0;\r\n}\r\nvoid\r\nnv04_fifo_chan_dtor(struct nvkm_object *object)\r\n{\r\nstruct nv04_fifo_priv *priv = (void *)object->engine;\r\nstruct nv04_fifo_chan *chan = (void *)object;\r\nstruct ramfc_desc *c = priv->ramfc_desc;\r\ndo {\r\nnv_wo32(priv->ramfc, chan->ramfc + c->ctxp, 0x00000000);\r\n} while ((++c)->bits);\r\nnvkm_fifo_channel_destroy(&chan->base);\r\n}\r\nint\r\nnv04_fifo_chan_init(struct nvkm_object *object)\r\n{\r\nstruct nv04_fifo_priv *priv = (void *)object->engine;\r\nstruct nv04_fifo_chan *chan = (void *)object;\r\nu32 mask = 1 << chan->base.chid;\r\nunsigned long flags;\r\nint ret;\r\nret = nvkm_fifo_channel_init(&chan->base);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_irqsave(&priv->base.lock, flags);\r\nnv_mask(priv, NV04_PFIFO_MODE, mask, mask);\r\nspin_unlock_irqrestore(&priv->base.lock, flags);\r\nreturn 0;\r\n}\r\nint\r\nnv04_fifo_chan_fini(struct nvkm_object *object, bool suspend)\r\n{\r\nstruct nv04_fifo_priv *priv = (void *)object->engine;\r\nstruct nv04_fifo_chan *chan = (void *)object;\r\nstruct nvkm_gpuobj *fctx = priv->ramfc;\r\nstruct ramfc_desc *c;\r\nunsigned long flags;\r\nu32 data = chan->ramfc;\r\nu32 chid;\r\nspin_lock_irqsave(&priv->base.lock, flags);\r\nnv_wr32(priv, NV03_PFIFO_CACHES, 0);\r\nchid = nv_rd32(priv, NV03_PFIFO_CACHE1_PUSH1) & priv->base.max;\r\nif (chid == chan->base.chid) {\r\nnv_mask(priv, NV04_PFIFO_CACHE1_DMA_PUSH, 0x00000001, 0);\r\nnv_wr32(priv, NV03_PFIFO_CACHE1_PUSH0, 0);\r\nnv_mask(priv, NV04_PFIFO_CACHE1_PULL0, 0x00000001, 0);\r\nc = priv->ramfc_desc;\r\ndo {\r\nu32 rm = ((1ULL << c->bits) - 1) << c->regs;\r\nu32 cm = ((1ULL << c->bits) - 1) << c->ctxs;\r\nu32 rv = (nv_rd32(priv, c->regp) & rm) >> c->regs;\r\nu32 cv = (nv_ro32(fctx, c->ctxp + data) & ~cm);\r\nnv_wo32(fctx, c->ctxp + data, cv | (rv << c->ctxs));\r\n} while ((++c)->bits);\r\nc = priv->ramfc_desc;\r\ndo {\r\nnv_wr32(priv, c->regp, 0x00000000);\r\n} while ((++c)->bits);\r\nnv_wr32(priv, NV03_PFIFO_CACHE1_GET, 0);\r\nnv_wr32(priv, NV03_PFIFO_CACHE1_PUT, 0);\r\nnv_wr32(priv, NV03_PFIFO_CACHE1_PUSH1, priv->base.max);\r\nnv_wr32(priv, NV03_PFIFO_CACHE1_PUSH0, 1);\r\nnv_wr32(priv, NV04_PFIFO_CACHE1_PULL0, 1);\r\n}\r\nnv_mask(priv, NV04_PFIFO_MODE, 1 << chan->base.chid, 0);\r\nnv_wr32(priv, NV03_PFIFO_CACHES, 1);\r\nspin_unlock_irqrestore(&priv->base.lock, flags);\r\nreturn nvkm_fifo_channel_fini(&chan->base, suspend);\r\n}\r\nint\r\nnv04_fifo_context_ctor(struct nvkm_object *parent,\r\nstruct nvkm_object *engine,\r\nstruct nvkm_oclass *oclass, void *data, u32 size,\r\nstruct nvkm_object **pobject)\r\n{\r\nstruct nv04_fifo_base *base;\r\nint ret;\r\nret = nvkm_fifo_context_create(parent, engine, oclass, NULL, 0x1000,\r\n0x1000, NVOBJ_FLAG_HEAP, &base);\r\n*pobject = nv_object(base);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nvoid\r\nnv04_fifo_pause(struct nvkm_fifo *pfifo, unsigned long *pflags)\r\n__acquires(priv->base.lock)\r\n{\r\nstruct nv04_fifo_priv *priv = (void *)pfifo;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->base.lock, flags);\r\n*pflags = flags;\r\nnv_wr32(priv, NV03_PFIFO_CACHES, 0x00000000);\r\nnv_mask(priv, NV04_PFIFO_CACHE1_PULL0, 0x00000001, 0x00000000);\r\nif (!nv_wait(priv, NV04_PFIFO_CACHE1_PULL0,\r\nNV04_PFIFO_CACHE1_PULL0_HASH_BUSY, 0x00000000))\r\nnv_warn(priv, "timeout idling puller\n");\r\nif (nv_rd32(priv, NV04_PFIFO_CACHE1_PULL0) &\r\nNV04_PFIFO_CACHE1_PULL0_HASH_FAILED)\r\nnv_wr32(priv, NV03_PFIFO_INTR_0, NV_PFIFO_INTR_CACHE_ERROR);\r\nnv_wr32(priv, NV04_PFIFO_CACHE1_HASH, 0x00000000);\r\n}\r\nvoid\r\nnv04_fifo_start(struct nvkm_fifo *pfifo, unsigned long *pflags)\r\n__releases(priv->base.lock)\r\n{\r\nstruct nv04_fifo_priv *priv = (void *)pfifo;\r\nunsigned long flags = *pflags;\r\nnv_mask(priv, NV04_PFIFO_CACHE1_PULL0, 0x00000001, 0x00000001);\r\nnv_wr32(priv, NV03_PFIFO_CACHES, 0x00000001);\r\nspin_unlock_irqrestore(&priv->base.lock, flags);\r\n}\r\nstatic const char *\r\nnv_dma_state_err(u32 state)\r\n{\r\nstatic const char * const desc[] = {\r\n"NONE", "CALL_SUBR_ACTIVE", "INVALID_MTHD", "RET_SUBR_INACTIVE",\r\n"INVALID_CMD", "IB_EMPTY", "MEM_FAULT", "UNK"\r\n};\r\nreturn desc[(state >> 29) & 0x7];\r\n}\r\nstatic bool\r\nnv04_fifo_swmthd(struct nv04_fifo_priv *priv, u32 chid, u32 addr, u32 data)\r\n{\r\nstruct nv04_fifo_chan *chan = NULL;\r\nstruct nvkm_handle *bind;\r\nconst int subc = (addr >> 13) & 0x7;\r\nconst int mthd = addr & 0x1ffc;\r\nbool handled = false;\r\nunsigned long flags;\r\nu32 engine;\r\nspin_lock_irqsave(&priv->base.lock, flags);\r\nif (likely(chid >= priv->base.min && chid <= priv->base.max))\r\nchan = (void *)priv->base.channel[chid];\r\nif (unlikely(!chan))\r\ngoto out;\r\nswitch (mthd) {\r\ncase 0x0000:\r\nbind = nvkm_namedb_get(nv_namedb(chan), data);\r\nif (unlikely(!bind))\r\nbreak;\r\nif (nv_engidx(bind->object->engine) == NVDEV_ENGINE_SW) {\r\nengine = 0x0000000f << (subc * 4);\r\nchan->subc[subc] = data;\r\nhandled = true;\r\nnv_mask(priv, NV04_PFIFO_CACHE1_ENGINE, engine, 0);\r\n}\r\nnvkm_namedb_put(bind);\r\nbreak;\r\ndefault:\r\nengine = nv_rd32(priv, NV04_PFIFO_CACHE1_ENGINE);\r\nif (unlikely(((engine >> (subc * 4)) & 0xf) != 0))\r\nbreak;\r\nbind = nvkm_namedb_get(nv_namedb(chan), chan->subc[subc]);\r\nif (likely(bind)) {\r\nif (!nv_call(bind->object, mthd, data))\r\nhandled = true;\r\nnvkm_namedb_put(bind);\r\n}\r\nbreak;\r\n}\r\nout:\r\nspin_unlock_irqrestore(&priv->base.lock, flags);\r\nreturn handled;\r\n}\r\nstatic void\r\nnv04_fifo_cache_error(struct nvkm_device *device,\r\nstruct nv04_fifo_priv *priv, u32 chid, u32 get)\r\n{\r\nu32 mthd, data;\r\nint ptr;\r\nptr = (get & 0x7ff) >> 2;\r\nif (device->card_type < NV_40) {\r\nmthd = nv_rd32(priv, NV04_PFIFO_CACHE1_METHOD(ptr));\r\ndata = nv_rd32(priv, NV04_PFIFO_CACHE1_DATA(ptr));\r\n} else {\r\nmthd = nv_rd32(priv, NV40_PFIFO_CACHE1_METHOD(ptr));\r\ndata = nv_rd32(priv, NV40_PFIFO_CACHE1_DATA(ptr));\r\n}\r\nif (!nv04_fifo_swmthd(priv, chid, mthd, data)) {\r\nconst char *client_name =\r\nnvkm_client_name_for_fifo_chid(&priv->base, chid);\r\nnv_error(priv,\r\n"CACHE_ERROR - ch %d [%s] subc %d mthd 0x%04x data 0x%08x\n",\r\nchid, client_name, (mthd >> 13) & 7, mthd & 0x1ffc,\r\ndata);\r\n}\r\nnv_wr32(priv, NV04_PFIFO_CACHE1_DMA_PUSH, 0);\r\nnv_wr32(priv, NV03_PFIFO_INTR_0, NV_PFIFO_INTR_CACHE_ERROR);\r\nnv_wr32(priv, NV03_PFIFO_CACHE1_PUSH0,\r\nnv_rd32(priv, NV03_PFIFO_CACHE1_PUSH0) & ~1);\r\nnv_wr32(priv, NV03_PFIFO_CACHE1_GET, get + 4);\r\nnv_wr32(priv, NV03_PFIFO_CACHE1_PUSH0,\r\nnv_rd32(priv, NV03_PFIFO_CACHE1_PUSH0) | 1);\r\nnv_wr32(priv, NV04_PFIFO_CACHE1_HASH, 0);\r\nnv_wr32(priv, NV04_PFIFO_CACHE1_DMA_PUSH,\r\nnv_rd32(priv, NV04_PFIFO_CACHE1_DMA_PUSH) | 1);\r\nnv_wr32(priv, NV04_PFIFO_CACHE1_PULL0, 1);\r\n}\r\nstatic void\r\nnv04_fifo_dma_pusher(struct nvkm_device *device,\r\nstruct nv04_fifo_priv *priv, u32 chid)\r\n{\r\nconst char *client_name;\r\nu32 dma_get = nv_rd32(priv, 0x003244);\r\nu32 dma_put = nv_rd32(priv, 0x003240);\r\nu32 push = nv_rd32(priv, 0x003220);\r\nu32 state = nv_rd32(priv, 0x003228);\r\nclient_name = nvkm_client_name_for_fifo_chid(&priv->base, chid);\r\nif (device->card_type == NV_50) {\r\nu32 ho_get = nv_rd32(priv, 0x003328);\r\nu32 ho_put = nv_rd32(priv, 0x003320);\r\nu32 ib_get = nv_rd32(priv, 0x003334);\r\nu32 ib_put = nv_rd32(priv, 0x003330);\r\nnv_error(priv,\r\n"DMA_PUSHER - ch %d [%s] get 0x%02x%08x put 0x%02x%08x ib_get 0x%08x ib_put 0x%08x state 0x%08x (err: %s) push 0x%08x\n",\r\nchid, client_name, ho_get, dma_get, ho_put, dma_put,\r\nib_get, ib_put, state, nv_dma_state_err(state), push);\r\nnv_wr32(priv, 0x003364, 0x00000000);\r\nif (dma_get != dma_put || ho_get != ho_put) {\r\nnv_wr32(priv, 0x003244, dma_put);\r\nnv_wr32(priv, 0x003328, ho_put);\r\n} else\r\nif (ib_get != ib_put)\r\nnv_wr32(priv, 0x003334, ib_put);\r\n} else {\r\nnv_error(priv,\r\n"DMA_PUSHER - ch %d [%s] get 0x%08x put 0x%08x state 0x%08x (err: %s) push 0x%08x\n",\r\nchid, client_name, dma_get, dma_put, state,\r\nnv_dma_state_err(state), push);\r\nif (dma_get != dma_put)\r\nnv_wr32(priv, 0x003244, dma_put);\r\n}\r\nnv_wr32(priv, 0x003228, 0x00000000);\r\nnv_wr32(priv, 0x003220, 0x00000001);\r\nnv_wr32(priv, 0x002100, NV_PFIFO_INTR_DMA_PUSHER);\r\n}\r\nvoid\r\nnv04_fifo_intr(struct nvkm_subdev *subdev)\r\n{\r\nstruct nvkm_device *device = nv_device(subdev);\r\nstruct nv04_fifo_priv *priv = (void *)subdev;\r\nu32 mask = nv_rd32(priv, NV03_PFIFO_INTR_EN_0);\r\nu32 stat = nv_rd32(priv, NV03_PFIFO_INTR_0) & mask;\r\nu32 reassign, chid, get, sem;\r\nreassign = nv_rd32(priv, NV03_PFIFO_CACHES) & 1;\r\nnv_wr32(priv, NV03_PFIFO_CACHES, 0);\r\nchid = nv_rd32(priv, NV03_PFIFO_CACHE1_PUSH1) & priv->base.max;\r\nget = nv_rd32(priv, NV03_PFIFO_CACHE1_GET);\r\nif (stat & NV_PFIFO_INTR_CACHE_ERROR) {\r\nnv04_fifo_cache_error(device, priv, chid, get);\r\nstat &= ~NV_PFIFO_INTR_CACHE_ERROR;\r\n}\r\nif (stat & NV_PFIFO_INTR_DMA_PUSHER) {\r\nnv04_fifo_dma_pusher(device, priv, chid);\r\nstat &= ~NV_PFIFO_INTR_DMA_PUSHER;\r\n}\r\nif (stat & NV_PFIFO_INTR_SEMAPHORE) {\r\nstat &= ~NV_PFIFO_INTR_SEMAPHORE;\r\nnv_wr32(priv, NV03_PFIFO_INTR_0, NV_PFIFO_INTR_SEMAPHORE);\r\nsem = nv_rd32(priv, NV10_PFIFO_CACHE1_SEMAPHORE);\r\nnv_wr32(priv, NV10_PFIFO_CACHE1_SEMAPHORE, sem | 0x1);\r\nnv_wr32(priv, NV03_PFIFO_CACHE1_GET, get + 4);\r\nnv_wr32(priv, NV04_PFIFO_CACHE1_PULL0, 1);\r\n}\r\nif (device->card_type == NV_50) {\r\nif (stat & 0x00000010) {\r\nstat &= ~0x00000010;\r\nnv_wr32(priv, 0x002100, 0x00000010);\r\n}\r\nif (stat & 0x40000000) {\r\nnv_wr32(priv, 0x002100, 0x40000000);\r\nnvkm_fifo_uevent(&priv->base);\r\nstat &= ~0x40000000;\r\n}\r\n}\r\nif (stat) {\r\nnv_warn(priv, "unknown intr 0x%08x\n", stat);\r\nnv_mask(priv, NV03_PFIFO_INTR_EN_0, stat, 0x00000000);\r\nnv_wr32(priv, NV03_PFIFO_INTR_0, stat);\r\n}\r\nnv_wr32(priv, NV03_PFIFO_CACHES, reassign);\r\n}\r\nstatic int\r\nnv04_fifo_ctor(struct nvkm_object *parent, struct nvkm_object *engine,\r\nstruct nvkm_oclass *oclass, void *data, u32 size,\r\nstruct nvkm_object **pobject)\r\n{\r\nstruct nv04_instmem_priv *imem = nv04_instmem(parent);\r\nstruct nv04_fifo_priv *priv;\r\nint ret;\r\nret = nvkm_fifo_create(parent, engine, oclass, 0, 15, &priv);\r\n*pobject = nv_object(priv);\r\nif (ret)\r\nreturn ret;\r\nnvkm_ramht_ref(imem->ramht, &priv->ramht);\r\nnvkm_gpuobj_ref(imem->ramro, &priv->ramro);\r\nnvkm_gpuobj_ref(imem->ramfc, &priv->ramfc);\r\nnv_subdev(priv)->unit = 0x00000100;\r\nnv_subdev(priv)->intr = nv04_fifo_intr;\r\nnv_engine(priv)->cclass = &nv04_fifo_cclass;\r\nnv_engine(priv)->sclass = nv04_fifo_sclass;\r\npriv->base.pause = nv04_fifo_pause;\r\npriv->base.start = nv04_fifo_start;\r\npriv->ramfc_desc = nv04_ramfc;\r\nreturn 0;\r\n}\r\nvoid\r\nnv04_fifo_dtor(struct nvkm_object *object)\r\n{\r\nstruct nv04_fifo_priv *priv = (void *)object;\r\nnvkm_gpuobj_ref(NULL, &priv->ramfc);\r\nnvkm_gpuobj_ref(NULL, &priv->ramro);\r\nnvkm_ramht_ref(NULL, &priv->ramht);\r\nnvkm_fifo_destroy(&priv->base);\r\n}\r\nint\r\nnv04_fifo_init(struct nvkm_object *object)\r\n{\r\nstruct nv04_fifo_priv *priv = (void *)object;\r\nint ret;\r\nret = nvkm_fifo_init(&priv->base);\r\nif (ret)\r\nreturn ret;\r\nnv_wr32(priv, NV04_PFIFO_DELAY_0, 0x000000ff);\r\nnv_wr32(priv, NV04_PFIFO_DMA_TIMESLICE, 0x0101ffff);\r\nnv_wr32(priv, NV03_PFIFO_RAMHT, (0x03 << 24) |\r\n((priv->ramht->bits - 9) << 16) |\r\n(priv->ramht->gpuobj.addr >> 8));\r\nnv_wr32(priv, NV03_PFIFO_RAMRO, priv->ramro->addr >> 8);\r\nnv_wr32(priv, NV03_PFIFO_RAMFC, priv->ramfc->addr >> 8);\r\nnv_wr32(priv, NV03_PFIFO_CACHE1_PUSH1, priv->base.max);\r\nnv_wr32(priv, NV03_PFIFO_INTR_0, 0xffffffff);\r\nnv_wr32(priv, NV03_PFIFO_INTR_EN_0, 0xffffffff);\r\nnv_wr32(priv, NV03_PFIFO_CACHE1_PUSH0, 1);\r\nnv_wr32(priv, NV04_PFIFO_CACHE1_PULL0, 1);\r\nnv_wr32(priv, NV03_PFIFO_CACHES, 1);\r\nreturn 0;\r\n}
