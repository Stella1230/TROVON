static void approximate(int base, int target, int *prediv,\r\nint *postdiv, int *mul)\r\n{\r\nint i, j, k, freq, res = target;\r\nfor (i = 1; i <= 16; i++)\r\nfor (j = 1; j <= 32; j++)\r\nfor (k = 1; k <= 32; k++) {\r\nfreq = abs(base / j * i / k - target);\r\nif (freq < res) {\r\nres = freq;\r\n*mul = i;\r\n*prediv = j;\r\n*postdiv = k;\r\n}\r\n}\r\n}\r\nstatic void calculate(int base, int target, int *prediv, int *postdiv,\r\nint *mul)\r\n{\r\nint tmp_gcd, tmp_base, tmp_freq;\r\nfor (*prediv = 1; *prediv <= 32; (*prediv)++) {\r\ntmp_base = base / *prediv;\r\ntmp_gcd = gcd(target, tmp_base);\r\n*mul = target / tmp_gcd;\r\n*postdiv = tmp_base / tmp_gcd;\r\nif ((*mul < 1) || (*mul >= 16))\r\ncontinue;\r\nif ((*postdiv > 0) & (*postdiv <= 32))\r\nbreak;\r\n}\r\nif (base / *prediv * *mul / *postdiv != target) {\r\napproximate(base, target, prediv, postdiv, mul);\r\ntmp_freq = base / *prediv * *mul / *postdiv;\r\nprintk(KERN_WARNING\r\n"Adjusted requested frequency %d to %d\n",\r\ntarget, tmp_freq);\r\n}\r\nprintk(KERN_DEBUG "Clocks: prediv: %d, postdiv: %d, mul: %d\n",\r\n*prediv, *postdiv, *mul);\r\n}\r\nstatic int tnetd7300_dsp_clock(void)\r\n{\r\nu32 didr1, didr2;\r\nu8 rev = ar7_chip_rev();\r\ndidr1 = readl((void *)KSEG1ADDR(AR7_REGS_GPIO + 0x18));\r\ndidr2 = readl((void *)KSEG1ADDR(AR7_REGS_GPIO + 0x1c));\r\nif (didr2 & (1 << 23))\r\nreturn 0;\r\nif ((rev >= 0x23) && (rev != 0x57))\r\nreturn 250000000;\r\nif ((((didr2 & 0x1fff) << 10) | ((didr1 & 0xffc00000) >> 22))\r\n> 4208000)\r\nreturn 250000000;\r\nreturn 0;\r\n}\r\nstatic int tnetd7300_get_clock(u32 shift, struct tnetd7300_clock *clock,\r\nu32 *bootcr, u32 bus_clock)\r\n{\r\nint product;\r\nint base_clock = AR7_REF_CLOCK;\r\nu32 ctrl = readl(&clock->ctrl);\r\nu32 pll = readl(&clock->pll);\r\nint prediv = ((ctrl & PREDIV_MASK) >> PREDIV_SHIFT) + 1;\r\nint postdiv = (ctrl & POSTDIV_MASK) + 1;\r\nint divisor = prediv * postdiv;\r\nint mul = ((pll & MUL_MASK) >> MUL_SHIFT) + 1;\r\nswitch ((*bootcr & (BOOT_PLL_SOURCE_MASK << shift)) >> shift) {\r\ncase BOOT_PLL_SOURCE_BUS:\r\nbase_clock = bus_clock;\r\nbreak;\r\ncase BOOT_PLL_SOURCE_REF:\r\nbase_clock = AR7_REF_CLOCK;\r\nbreak;\r\ncase BOOT_PLL_SOURCE_XTAL:\r\nbase_clock = AR7_XTAL_CLOCK;\r\nbreak;\r\ncase BOOT_PLL_SOURCE_CPU:\r\nbase_clock = cpu_clk.rate;\r\nbreak;\r\n}\r\nif (*bootcr & BOOT_PLL_BYPASS)\r\nreturn base_clock / divisor;\r\nif ((pll & PLL_MODE_MASK) == 0)\r\nreturn (base_clock >> (mul / 16 + 1)) / divisor;\r\nif ((pll & (PLL_NDIV | PLL_DIV)) == (PLL_NDIV | PLL_DIV)) {\r\nproduct = (mul & 1) ?\r\n(base_clock * mul) >> 1 :\r\n(base_clock * (mul - 1)) >> 2;\r\nreturn product / divisor;\r\n}\r\nif (mul == 16)\r\nreturn base_clock / divisor;\r\nreturn base_clock * mul / divisor;\r\n}\r\nstatic void tnetd7300_set_clock(u32 shift, struct tnetd7300_clock *clock,\r\nu32 *bootcr, u32 frequency)\r\n{\r\nint prediv, postdiv, mul;\r\nint base_clock = bus_clk.rate;\r\nswitch ((*bootcr & (BOOT_PLL_SOURCE_MASK << shift)) >> shift) {\r\ncase BOOT_PLL_SOURCE_BUS:\r\nbase_clock = bus_clk.rate;\r\nbreak;\r\ncase BOOT_PLL_SOURCE_REF:\r\nbase_clock = AR7_REF_CLOCK;\r\nbreak;\r\ncase BOOT_PLL_SOURCE_XTAL:\r\nbase_clock = AR7_XTAL_CLOCK;\r\nbreak;\r\ncase BOOT_PLL_SOURCE_CPU:\r\nbase_clock = cpu_clk.rate;\r\nbreak;\r\n}\r\ncalculate(base_clock, frequency, &prediv, &postdiv, &mul);\r\nwritel(((prediv - 1) << PREDIV_SHIFT) | (postdiv - 1), &clock->ctrl);\r\nmdelay(1);\r\nwritel(4, &clock->pll);\r\nwhile (readl(&clock->pll) & PLL_STATUS)\r\n;\r\nwritel(((mul - 1) << MUL_SHIFT) | (0xff << 3) | 0x0e, &clock->pll);\r\nmdelay(75);\r\n}\r\nstatic void __init tnetd7300_init_clocks(void)\r\n{\r\nu32 *bootcr = (u32 *)ioremap_nocache(AR7_REGS_DCL, 4);\r\nstruct tnetd7300_clocks *clocks =\r\nioremap_nocache(UR8_REGS_CLOCKS,\r\nsizeof(struct tnetd7300_clocks));\r\nbus_clk.rate = tnetd7300_get_clock(BUS_PLL_SOURCE_SHIFT,\r\n&clocks->bus, bootcr, AR7_AFE_CLOCK);\r\nif (*bootcr & BOOT_PLL_ASYNC_MODE)\r\ncpu_clk.rate = tnetd7300_get_clock(CPU_PLL_SOURCE_SHIFT,\r\n&clocks->cpu, bootcr, AR7_AFE_CLOCK);\r\nelse\r\ncpu_clk.rate = bus_clk.rate;\r\nif (dsp_clk.rate == 250000000)\r\ntnetd7300_set_clock(DSP_PLL_SOURCE_SHIFT, &clocks->dsp,\r\nbootcr, dsp_clk.rate);\r\niounmap(clocks);\r\niounmap(bootcr);\r\n}\r\nstatic void tnetd7200_set_clock(int base, struct tnetd7200_clock *clock,\r\nint prediv, int postdiv, int postdiv2, int mul, u32 frequency)\r\n{\r\nprintk(KERN_INFO\r\n"Clocks: base = %d, frequency = %u, prediv = %d, "\r\n"postdiv = %d, postdiv2 = %d, mul = %d\n",\r\nbase, frequency, prediv, postdiv, postdiv2, mul);\r\nwritel(0, &clock->ctrl);\r\nwritel(DIVISOR_ENABLE_MASK | ((prediv - 1) & 0x1F), &clock->prediv);\r\nwritel((mul - 1) & 0xF, &clock->mul);\r\nwhile (readl(&clock->status) & 0x1)\r\n;\r\nwritel(DIVISOR_ENABLE_MASK | ((postdiv - 1) & 0x1F), &clock->postdiv);\r\nwritel(readl(&clock->cmden) | 1, &clock->cmden);\r\nwritel(readl(&clock->cmd) | 1, &clock->cmd);\r\nwhile (readl(&clock->status) & 0x1)\r\n;\r\nwritel(DIVISOR_ENABLE_MASK | ((postdiv2 - 1) & 0x1F), &clock->postdiv2);\r\nwritel(readl(&clock->cmden) | 1, &clock->cmden);\r\nwritel(readl(&clock->cmd) | 1, &clock->cmd);\r\nwhile (readl(&clock->status) & 0x1)\r\n;\r\nwritel(readl(&clock->ctrl) | 1, &clock->ctrl);\r\n}\r\nstatic int tnetd7200_get_clock_base(int clock_id, u32 *bootcr)\r\n{\r\nif (*bootcr & BOOT_PLL_ASYNC_MODE)\r\nswitch (clock_id) {\r\ncase TNETD7200_CLOCK_ID_DSP:\r\nreturn AR7_REF_CLOCK;\r\ndefault:\r\nreturn AR7_AFE_CLOCK;\r\n}\r\nelse\r\nif (*bootcr & BOOT_PLL_2TO1_MODE)\r\nswitch (clock_id) {\r\ncase TNETD7200_CLOCK_ID_DSP:\r\nreturn AR7_REF_CLOCK;\r\ndefault:\r\nreturn AR7_AFE_CLOCK;\r\n}\r\nelse\r\nreturn AR7_REF_CLOCK;\r\n}\r\nstatic void __init tnetd7200_init_clocks(void)\r\n{\r\nu32 *bootcr = (u32 *)ioremap_nocache(AR7_REGS_DCL, 4);\r\nstruct tnetd7200_clocks *clocks =\r\nioremap_nocache(AR7_REGS_CLOCKS,\r\nsizeof(struct tnetd7200_clocks));\r\nint cpu_base, cpu_mul, cpu_prediv, cpu_postdiv;\r\nint dsp_base, dsp_mul, dsp_prediv, dsp_postdiv;\r\nint usb_base, usb_mul, usb_prediv, usb_postdiv;\r\ncpu_base = tnetd7200_get_clock_base(TNETD7200_CLOCK_ID_CPU, bootcr);\r\ndsp_base = tnetd7200_get_clock_base(TNETD7200_CLOCK_ID_DSP, bootcr);\r\nif (*bootcr & BOOT_PLL_ASYNC_MODE) {\r\nprintk(KERN_INFO "Clocks: Async mode\n");\r\nprintk(KERN_INFO "Clocks: Setting DSP clock\n");\r\ncalculate(dsp_base, TNETD7200_DEF_DSP_CLK,\r\n&dsp_prediv, &dsp_postdiv, &dsp_mul);\r\nbus_clk.rate =\r\n((dsp_base / dsp_prediv) * dsp_mul) / dsp_postdiv;\r\ntnetd7200_set_clock(dsp_base, &clocks->dsp,\r\ndsp_prediv, dsp_postdiv * 2, dsp_postdiv, dsp_mul * 2,\r\nbus_clk.rate);\r\nprintk(KERN_INFO "Clocks: Setting CPU clock\n");\r\ncalculate(cpu_base, TNETD7200_DEF_CPU_CLK, &cpu_prediv,\r\n&cpu_postdiv, &cpu_mul);\r\ncpu_clk.rate =\r\n((cpu_base / cpu_prediv) * cpu_mul) / cpu_postdiv;\r\ntnetd7200_set_clock(cpu_base, &clocks->cpu,\r\ncpu_prediv, cpu_postdiv, -1, cpu_mul,\r\ncpu_clk.rate);\r\n} else\r\nif (*bootcr & BOOT_PLL_2TO1_MODE) {\r\nprintk(KERN_INFO "Clocks: Sync 2:1 mode\n");\r\nprintk(KERN_INFO "Clocks: Setting CPU clock\n");\r\ncalculate(cpu_base, TNETD7200_DEF_CPU_CLK, &cpu_prediv,\r\n&cpu_postdiv, &cpu_mul);\r\ncpu_clk.rate = ((cpu_base / cpu_prediv) * cpu_mul)\r\n/ cpu_postdiv;\r\ntnetd7200_set_clock(cpu_base, &clocks->cpu,\r\ncpu_prediv, cpu_postdiv, -1, cpu_mul,\r\ncpu_clk.rate);\r\nprintk(KERN_INFO "Clocks: Setting DSP clock\n");\r\ncalculate(dsp_base, TNETD7200_DEF_DSP_CLK, &dsp_prediv,\r\n&dsp_postdiv, &dsp_mul);\r\nbus_clk.rate = cpu_clk.rate / 2;\r\ntnetd7200_set_clock(dsp_base, &clocks->dsp,\r\ndsp_prediv, dsp_postdiv * 2, dsp_postdiv,\r\ndsp_mul * 2, bus_clk.rate);\r\n} else {\r\nprintk(KERN_INFO "Clocks: Sync 1:1 mode\n");\r\nprintk(KERN_INFO "Clocks: Setting DSP clock\n");\r\ncalculate(dsp_base, TNETD7200_DEF_DSP_CLK, &dsp_prediv,\r\n&dsp_postdiv, &dsp_mul);\r\nbus_clk.rate = ((dsp_base / dsp_prediv) * dsp_mul)\r\n/ dsp_postdiv;\r\ntnetd7200_set_clock(dsp_base, &clocks->dsp,\r\ndsp_prediv, dsp_postdiv * 2, dsp_postdiv,\r\ndsp_mul * 2, bus_clk.rate);\r\ncpu_clk.rate = bus_clk.rate;\r\n}\r\nprintk(KERN_INFO "Clocks: Setting USB clock\n");\r\nusb_base = bus_clk.rate;\r\ncalculate(usb_base, TNETD7200_DEF_USB_CLK, &usb_prediv,\r\n&usb_postdiv, &usb_mul);\r\ntnetd7200_set_clock(usb_base, &clocks->usb,\r\nusb_prediv, usb_postdiv, -1, usb_mul,\r\nTNETD7200_DEF_USB_CLK);\r\ndsp_clk.rate = cpu_clk.rate;\r\niounmap(clocks);\r\niounmap(bootcr);\r\n}\r\nint clk_enable(struct clk *clk)\r\n{\r\nreturn 0;\r\n}\r\nvoid clk_disable(struct clk *clk)\r\n{\r\n}\r\nunsigned long clk_get_rate(struct clk *clk)\r\n{\r\nreturn clk->rate;\r\n}\r\nstruct clk *clk_get(struct device *dev, const char *id)\r\n{\r\nif (!strcmp(id, "bus"))\r\nreturn &bus_clk;\r\nif (!strcmp(id, "cpmac"))\r\nreturn &vbus_clk;\r\nif (!strcmp(id, "cpu"))\r\nreturn &cpu_clk;\r\nif (!strcmp(id, "dsp"))\r\nreturn &dsp_clk;\r\nif (!strcmp(id, "vbus"))\r\nreturn &vbus_clk;\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nvoid clk_put(struct clk *clk)\r\n{\r\n}\r\nvoid __init ar7_init_clocks(void)\r\n{\r\nswitch (ar7_chip_id()) {\r\ncase AR7_CHIP_7100:\r\ncase AR7_CHIP_7200:\r\ntnetd7200_init_clocks();\r\nbreak;\r\ncase AR7_CHIP_7300:\r\ndsp_clk.rate = tnetd7300_dsp_clock();\r\ntnetd7300_init_clocks();\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nvbus_clk.rate = bus_clk.rate / 2;\r\n}
