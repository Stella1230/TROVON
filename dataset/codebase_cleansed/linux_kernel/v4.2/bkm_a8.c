static inline u_char\r\nreadreg(unsigned int ale, unsigned int adr, u_char off)\r\n{\r\nregister u_char ret;\r\nwordout(ale, off);\r\nret = wordin(adr) & 0xFF;\r\nreturn (ret);\r\n}\r\nstatic inline void\r\nreadfifo(unsigned int ale, unsigned int adr, u_char off, u_char *data, int size)\r\n{\r\nint i;\r\nwordout(ale, off);\r\nfor (i = 0; i < size; i++)\r\ndata[i] = wordin(adr) & 0xFF;\r\n}\r\nstatic inline void\r\nwritereg(unsigned int ale, unsigned int adr, u_char off, u_char data)\r\n{\r\nwordout(ale, off);\r\nwordout(adr, data);\r\n}\r\nstatic inline void\r\nwritefifo(unsigned int ale, unsigned int adr, u_char off, u_char *data, int size)\r\n{\r\nint i;\r\nwordout(ale, off);\r\nfor (i = 0; i < size; i++)\r\nwordout(adr, data[i]);\r\n}\r\nstatic u_char\r\nReadISAC(struct IsdnCardState *cs, u_char offset)\r\n{\r\nreturn (readreg(cs->hw.ax.base, cs->hw.ax.data_adr, offset | 0x80));\r\n}\r\nstatic void\r\nWriteISAC(struct IsdnCardState *cs, u_char offset, u_char value)\r\n{\r\nwritereg(cs->hw.ax.base, cs->hw.ax.data_adr, offset | 0x80, value);\r\n}\r\nstatic void\r\nReadISACfifo(struct IsdnCardState *cs, u_char *data, int size)\r\n{\r\nreadfifo(cs->hw.ax.base, cs->hw.ax.data_adr, 0x80, data, size);\r\n}\r\nstatic void\r\nWriteISACfifo(struct IsdnCardState *cs, u_char *data, int size)\r\n{\r\nwritefifo(cs->hw.ax.base, cs->hw.ax.data_adr, 0x80, data, size);\r\n}\r\nstatic u_char\r\nReadHSCX(struct IsdnCardState *cs, int hscx, u_char offset)\r\n{\r\nreturn (readreg(cs->hw.ax.base, cs->hw.ax.data_adr, offset + (hscx ? 0x40 : 0)));\r\n}\r\nstatic void\r\nWriteHSCX(struct IsdnCardState *cs, int hscx, u_char offset, u_char value)\r\n{\r\nwritereg(cs->hw.ax.base, cs->hw.ax.data_adr, offset + (hscx ? 0x40 : 0), value);\r\n}\r\nstatic void\r\nset_ipac_active(struct IsdnCardState *cs, u_int active)\r\n{\r\nwritereg(cs->hw.ax.base, cs->hw.ax.data_adr, IPAC_MASK,\r\nactive ? 0xc0 : 0xff);\r\n}\r\nstatic irqreturn_t\r\nbkm_interrupt_ipac(int intno, void *dev_id)\r\n{\r\nstruct IsdnCardState *cs = dev_id;\r\nu_char ista, val, icnt = 5;\r\nu_long flags;\r\nspin_lock_irqsave(&cs->lock, flags);\r\nista = readreg(cs->hw.ax.base, cs->hw.ax.data_adr, IPAC_ISTA);\r\nif (!(ista & 0x3f)) {\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn IRQ_NONE;\r\n}\r\nStart_IPAC:\r\nif (cs->debug & L1_DEB_IPAC)\r\ndebugl1(cs, "IPAC ISTA %02X", ista);\r\nif (ista & 0x0f) {\r\nval = readreg(cs->hw.ax.base, cs->hw.ax.data_adr, HSCX_ISTA + 0x40);\r\nif (ista & 0x01)\r\nval |= 0x01;\r\nif (ista & 0x04)\r\nval |= 0x02;\r\nif (ista & 0x08)\r\nval |= 0x04;\r\nif (val) {\r\nhscx_int_main(cs, val);\r\n}\r\n}\r\nif (ista & 0x20) {\r\nval = 0xfe & readreg(cs->hw.ax.base, cs->hw.ax.data_adr, ISAC_ISTA | 0x80);\r\nif (val) {\r\nisac_interrupt(cs, val);\r\n}\r\n}\r\nif (ista & 0x10) {\r\nval = 0x01;\r\nisac_interrupt(cs, val);\r\n}\r\nista = readreg(cs->hw.ax.base, cs->hw.ax.data_adr, IPAC_ISTA);\r\nif ((ista & 0x3f) && icnt) {\r\nicnt--;\r\ngoto Start_IPAC;\r\n}\r\nif (!icnt)\r\nprintk(KERN_WARNING "HiSax: Scitel Quadro (%s) IRQ LOOP\n",\r\nsct_quadro_subtypes[cs->subtyp]);\r\nwritereg(cs->hw.ax.base, cs->hw.ax.data_adr, IPAC_MASK, 0xFF);\r\nwritereg(cs->hw.ax.base, cs->hw.ax.data_adr, IPAC_MASK, 0xC0);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nrelease_io_sct_quadro(struct IsdnCardState *cs)\r\n{\r\nrelease_region(cs->hw.ax.base & 0xffffffc0, 128);\r\nif (cs->subtyp == SCT_1)\r\nrelease_region(cs->hw.ax.plx_adr, 64);\r\n}\r\nstatic void\r\nenable_bkm_int(struct IsdnCardState *cs, unsigned bEnable)\r\n{\r\nif (cs->typ == ISDN_CTYPE_SCT_QUADRO) {\r\nif (bEnable)\r\nwordout(cs->hw.ax.plx_adr + 0x4C, (wordin(cs->hw.ax.plx_adr + 0x4C) | 0x41));\r\nelse\r\nwordout(cs->hw.ax.plx_adr + 0x4C, (wordin(cs->hw.ax.plx_adr + 0x4C) & ~0x41));\r\n}\r\n}\r\nstatic void\r\nreset_bkm(struct IsdnCardState *cs)\r\n{\r\nif (cs->subtyp == SCT_1) {\r\nwordout(cs->hw.ax.plx_adr + 0x50, (wordin(cs->hw.ax.plx_adr + 0x50) & ~4));\r\nmdelay(10);\r\nwordout(cs->hw.ax.plx_adr + 0x50, (wordin(cs->hw.ax.plx_adr + 0x50) | 4));\r\nmdelay(10);\r\n}\r\n}\r\nstatic int\r\nBKM_card_msg(struct IsdnCardState *cs, int mt, void *arg)\r\n{\r\nu_long flags;\r\nswitch (mt) {\r\ncase CARD_RESET:\r\nspin_lock_irqsave(&cs->lock, flags);\r\nset_ipac_active(cs, 0);\r\nenable_bkm_int(cs, 0);\r\nreset_bkm(cs);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn (0);\r\ncase CARD_RELEASE:\r\nspin_lock_irqsave(&cs->lock, flags);\r\nset_ipac_active(cs, 0);\r\nenable_bkm_int(cs, 0);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nrelease_io_sct_quadro(cs);\r\nreturn (0);\r\ncase CARD_INIT:\r\nspin_lock_irqsave(&cs->lock, flags);\r\ncs->debug |= L1_DEB_IPAC;\r\nset_ipac_active(cs, 1);\r\ninithscxisac(cs, 3);\r\nenable_bkm_int(cs, 1);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn (0);\r\ncase CARD_TEST:\r\nreturn (0);\r\n}\r\nreturn (0);\r\n}\r\nstatic int sct_alloc_io(u_int adr, u_int len)\r\n{\r\nif (!request_region(adr, len, "scitel")) {\r\nprintk(KERN_WARNING\r\n"HiSax: Scitel port %#x-%#x already in use\n",\r\nadr, adr + len);\r\nreturn (1);\r\n}\r\nreturn (0);\r\n}\r\nint setup_sct_quadro(struct IsdnCard *card)\r\n{\r\nstruct IsdnCardState *cs = card->cs;\r\nchar tmp[64];\r\nu_int found = 0;\r\nu_int pci_ioaddr1, pci_ioaddr2, pci_ioaddr3, pci_ioaddr4, pci_ioaddr5;\r\nstrcpy(tmp, sct_quadro_revision);\r\nprintk(KERN_INFO "HiSax: T-Berkom driver Rev. %s\n", HiSax_getrev(tmp));\r\nif (cs->typ == ISDN_CTYPE_SCT_QUADRO) {\r\ncs->subtyp = SCT_1;\r\n} else\r\nreturn (0);\r\nif (card->para[0] >= SCT_1 && card->para[0] <= SCT_4)\r\ncs->subtyp = card->para[0];\r\nelse {\r\nprintk(KERN_WARNING "HiSax: Scitel Quadro: Invalid "\r\n"subcontroller in configuration, default to 1\n");\r\nreturn (0);\r\n}\r\nif ((cs->subtyp != SCT_1) && ((sub_sys_id != PCI_DEVICE_ID_BERKOM_SCITEL_QUADRO) ||\r\n(sub_vendor_id != PCI_VENDOR_ID_BERKOM)))\r\nreturn (0);\r\nif (cs->subtyp == SCT_1) {\r\nwhile ((dev_a8 = hisax_find_pci_device(PCI_VENDOR_ID_PLX,\r\nPCI_DEVICE_ID_PLX_9050, dev_a8))) {\r\nsub_vendor_id = dev_a8->subsystem_vendor;\r\nsub_sys_id = dev_a8->subsystem_device;\r\nif ((sub_sys_id == PCI_DEVICE_ID_BERKOM_SCITEL_QUADRO) &&\r\n(sub_vendor_id == PCI_VENDOR_ID_BERKOM)) {\r\nif (pci_enable_device(dev_a8))\r\nreturn (0);\r\npci_ioaddr1 = pci_resource_start(dev_a8, 1);\r\npci_irq = dev_a8->irq;\r\npci_bus = dev_a8->bus->number;\r\npci_device_fn = dev_a8->devfn;\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nprintk(KERN_WARNING "HiSax: Scitel Quadro (%s): "\r\n"Card not found\n",\r\nsct_quadro_subtypes[cs->subtyp]);\r\nreturn (0);\r\n}\r\n#ifdef ATTEMPT_PCI_REMAPPING\r\nif ((pci_ioaddr1 & 0x80) && (dev_a8->revision == 1)) {\r\nprintk(KERN_WARNING "HiSax: Scitel Quadro (%s): "\r\n"PLX rev 1, remapping required!\n",\r\nsct_quadro_subtypes[cs->subtyp]);\r\npci_write_config_dword(dev_a8, PCI_BASE_ADDRESS_1, (u_int)-1);\r\npci_ioaddr1 += 0x80;\r\npci_ioaddr1 &= PCI_BASE_ADDRESS_IO_MASK;\r\npci_write_config_dword(dev_a8, PCI_BASE_ADDRESS_1, pci_ioaddr1);\r\ndev_a8->resource[1].start = pci_ioaddr1;\r\n}\r\n#endif\r\n}\r\nif (!pci_irq) {\r\nprintk(KERN_WARNING "HiSax: Scitel Quadro (%s): No IRQ\n",\r\nsct_quadro_subtypes[cs->subtyp]);\r\nreturn (0);\r\n}\r\npci_read_config_dword(dev_a8, PCI_BASE_ADDRESS_1, &pci_ioaddr1);\r\npci_read_config_dword(dev_a8, PCI_BASE_ADDRESS_2, &pci_ioaddr2);\r\npci_read_config_dword(dev_a8, PCI_BASE_ADDRESS_3, &pci_ioaddr3);\r\npci_read_config_dword(dev_a8, PCI_BASE_ADDRESS_4, &pci_ioaddr4);\r\npci_read_config_dword(dev_a8, PCI_BASE_ADDRESS_5, &pci_ioaddr5);\r\nif (!pci_ioaddr1 || !pci_ioaddr2 || !pci_ioaddr3 || !pci_ioaddr4 || !pci_ioaddr5) {\r\nprintk(KERN_WARNING "HiSax: Scitel Quadro (%s): "\r\n"No IO base address(es)\n",\r\nsct_quadro_subtypes[cs->subtyp]);\r\nreturn (0);\r\n}\r\npci_ioaddr1 &= PCI_BASE_ADDRESS_IO_MASK;\r\npci_ioaddr2 &= PCI_BASE_ADDRESS_IO_MASK;\r\npci_ioaddr3 &= PCI_BASE_ADDRESS_IO_MASK;\r\npci_ioaddr4 &= PCI_BASE_ADDRESS_IO_MASK;\r\npci_ioaddr5 &= PCI_BASE_ADDRESS_IO_MASK;\r\ncs->irq = pci_irq;\r\ncs->irq_flags |= IRQF_SHARED;\r\ncs->hw.ax.plx_adr = pci_ioaddr1;\r\nswitch (cs->subtyp) {\r\ncase 1:\r\ncs->hw.ax.base = pci_ioaddr5 + 0x00;\r\nif (sct_alloc_io(pci_ioaddr1, 128))\r\nreturn (0);\r\nif (sct_alloc_io(pci_ioaddr5, 64))\r\nreturn (0);\r\nwritereg(pci_ioaddr5, pci_ioaddr5 + 4,\r\nIPAC_MASK, 0xFF);\r\nwritereg(pci_ioaddr4 + 0x08, pci_ioaddr4 + 0x0c,\r\nIPAC_MASK, 0xFF);\r\nwritereg(pci_ioaddr3 + 0x10, pci_ioaddr3 + 0x14,\r\nIPAC_MASK, 0xFF);\r\nwritereg(pci_ioaddr2 + 0x20, pci_ioaddr2 + 0x24,\r\nIPAC_MASK, 0xFF);\r\nbreak;\r\ncase 2:\r\ncs->hw.ax.base = pci_ioaddr4 + 0x08;\r\nif (sct_alloc_io(pci_ioaddr4, 64))\r\nreturn (0);\r\nbreak;\r\ncase 3:\r\ncs->hw.ax.base = pci_ioaddr3 + 0x10;\r\nif (sct_alloc_io(pci_ioaddr3, 64))\r\nreturn (0);\r\nbreak;\r\ncase 4:\r\ncs->hw.ax.base = pci_ioaddr2 + 0x20;\r\nif (sct_alloc_io(pci_ioaddr2, 64))\r\nreturn (0);\r\nbreak;\r\n}\r\ncs->hw.ax.data_adr = cs->hw.ax.base + 4;\r\nprintk(KERN_INFO "HiSax: Scitel Quadro (%s) configured at "\r\n"0x%.4lX, 0x%.4lX, 0x%.4lX and IRQ %d\n",\r\nsct_quadro_subtypes[cs->subtyp],\r\ncs->hw.ax.plx_adr,\r\ncs->hw.ax.base,\r\ncs->hw.ax.data_adr,\r\ncs->irq);\r\ntest_and_set_bit(HW_IPAC, &cs->HW_Flags);\r\ncs->readisac = &ReadISAC;\r\ncs->writeisac = &WriteISAC;\r\ncs->readisacfifo = &ReadISACfifo;\r\ncs->writeisacfifo = &WriteISACfifo;\r\ncs->BC_Read_Reg = &ReadHSCX;\r\ncs->BC_Write_Reg = &WriteHSCX;\r\ncs->BC_Send_Data = &hscx_fill_fifo;\r\ncs->cardmsg = &BKM_card_msg;\r\ncs->irq_func = &bkm_interrupt_ipac;\r\nprintk(KERN_INFO "HiSax: Scitel Quadro (%s): IPAC Version %d\n",\r\nsct_quadro_subtypes[cs->subtyp],\r\nreadreg(cs->hw.ax.base, cs->hw.ax.data_adr, IPAC_ID));\r\nreturn (1);\r\n}
