inline void do_gettimeofday_fast(struct fasttime_t *tv)\r\n{\r\ntv->tv_jiff = jiffies;\r\ntv->tv_usec = GET_JIFFIES_USEC();\r\n}\r\ninline int fasttime_cmp(struct fasttime_t *t0, struct fasttime_t *t1)\r\n{\r\nif (time_before(t0->tv_jiff, t1->tv_jiff))\r\nreturn -1;\r\nelse if (time_after(t0->tv_jiff, t1->tv_jiff))\r\nreturn 1;\r\nif (t0->tv_usec < t1->tv_usec)\r\nreturn -1;\r\nelse if (t0->tv_usec > t1->tv_usec)\r\nreturn 1;\r\nreturn 0;\r\n}\r\ninline void start_timer_trig(unsigned long delay_us)\r\n{\r\nreg_timer_rw_ack_intr ack_intr = { 0 };\r\nreg_timer_rw_intr_mask intr_mask;\r\nreg_timer_rw_trig trig;\r\nreg_timer_rw_trig_cfg trig_cfg = { 0 };\r\nreg_timer_r_time r_time0;\r\nreg_timer_r_time r_time1;\r\nunsigned char trig_wrap;\r\nunsigned char time_wrap;\r\nr_time0 = REG_RD(timer, regi_timer0, r_time);\r\nD1(printk("start_timer_trig : %d us freq: %i div: %i\n",\r\ndelay_us, freq_index, div));\r\nintr_mask = REG_RD(timer, regi_timer0, rw_intr_mask);\r\nintr_mask.trig = 0;\r\nREG_WR(timer, regi_timer0, rw_intr_mask, intr_mask);\r\ntrig_wrap = (trig = r_time0 + delay_us*(1000/10)) < r_time0;\r\ntimer_div_settings[fast_timers_started % NUM_TIMER_STATS] = trig;\r\ntimer_delay_settings[fast_timers_started % NUM_TIMER_STATS] = delay_us;\r\nack_intr.trig = 1;\r\nREG_WR(timer, regi_timer0, rw_ack_intr, ack_intr);\r\nREG_WR(timer, regi_timer0, rw_trig, trig);\r\ntrig_cfg.tmr = regk_timer_time;\r\nREG_WR(timer, regi_timer0, rw_trig_cfg, trig_cfg);\r\nr_time1 = REG_RD(timer, regi_timer0, r_time);\r\ntime_wrap = r_time1 < r_time0;\r\nif ((trig_wrap && !time_wrap) || (r_time1 < trig)) {\r\nintr_mask = REG_RD(timer, regi_timer0, rw_intr_mask);\r\nintr_mask.trig = 1;\r\nREG_WR(timer, regi_timer0, rw_intr_mask, intr_mask);\r\nfast_timers_started++;\r\nfast_timer_running = 1;\r\n} else {\r\ntrig_cfg.tmr = regk_timer_off;\r\nREG_WR(timer, regi_timer0, rw_trig_cfg, trig_cfg);\r\nREG_WR(timer, regi_timer0, rw_ack_intr, ack_intr);\r\nINIT_WORK(&fast_work, timer_trig_handler);\r\nschedule_work(&fast_work);\r\n}\r\n}\r\nvoid start_one_shot_timer(struct fast_timer *t,\r\nfast_timer_function_type *function,\r\nunsigned long data,\r\nunsigned long delay_us,\r\nconst char *name)\r\n{\r\nunsigned long flags;\r\nstruct fast_timer *tmp;\r\nD1(printk("sft %s %d us\n", name, delay_us));\r\nlocal_irq_save(flags);\r\ndo_gettimeofday_fast(&t->tv_set);\r\ntmp = fast_timer_list;\r\n#ifdef FAST_TIMER_SANITY_CHECKS\r\nwhile (tmp != NULL) {\r\nif (tmp == t) {\r\nprintk(KERN_DEBUG\r\n"timer name: %s data: 0x%08lX already "\r\n"in list!\n", name, data);\r\nsanity_failed++;\r\ngoto done;\r\n} else\r\ntmp = tmp->next;\r\n}\r\ntmp = fast_timer_list;\r\n#endif\r\nt->delay_us = delay_us;\r\nt->function = function;\r\nt->data = data;\r\nt->name = name;\r\nt->tv_expires.tv_usec = t->tv_set.tv_usec + delay_us % 1000000;\r\nt->tv_expires.tv_jiff = t->tv_set.tv_jiff + delay_us / 1000000 / HZ;\r\nif (t->tv_expires.tv_usec > 1000000) {\r\nt->tv_expires.tv_usec -= 1000000;\r\nt->tv_expires.tv_jiff += HZ;\r\n}\r\n#ifdef FAST_TIMER_LOG\r\ntimer_added_log[fast_timers_added % NUM_TIMER_STATS] = *t;\r\n#endif\r\nfast_timers_added++;\r\nif (tmp == NULL || fasttime_cmp(&t->tv_expires, &tmp->tv_expires) < 0) {\r\nt->prev = NULL;\r\nt->next = fast_timer_list;\r\nif (fast_timer_list)\r\nfast_timer_list->prev = t;\r\nfast_timer_list = t;\r\n#ifdef FAST_TIMER_LOG\r\ntimer_started_log[fast_timers_started % NUM_TIMER_STATS] = *t;\r\n#endif\r\nstart_timer_trig(delay_us);\r\n} else {\r\nwhile (tmp->next &&\r\nfasttime_cmp(&t->tv_expires, &tmp->next->tv_expires) > 0)\r\ntmp = tmp->next;\r\nt->prev = tmp;\r\nt->next = tmp->next;\r\nif (tmp->next)\r\n{\r\ntmp->next->prev = t;\r\n}\r\ntmp->next = t;\r\n}\r\nD2(printk("start_one_shot_timer: %d us done\n", delay_us));\r\ndone:\r\nlocal_irq_restore(flags);\r\n}\r\nstatic inline int fast_timer_pending (const struct fast_timer * t)\r\n{\r\nreturn (t->next != NULL) || (t->prev != NULL) || (t == fast_timer_list);\r\n}\r\nstatic inline int detach_fast_timer (struct fast_timer *t)\r\n{\r\nstruct fast_timer *next, *prev;\r\nif (!fast_timer_pending(t))\r\nreturn 0;\r\nnext = t->next;\r\nprev = t->prev;\r\nif (next)\r\nnext->prev = prev;\r\nif (prev)\r\nprev->next = next;\r\nelse\r\nfast_timer_list = next;\r\nfast_timers_deleted++;\r\nreturn 1;\r\n}\r\nint del_fast_timer(struct fast_timer * t)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nlocal_irq_save(flags);\r\nret = detach_fast_timer(t);\r\nt->next = t->prev = NULL;\r\nlocal_irq_restore(flags);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t\r\ntimer_trig_interrupt(int irq, void *dev_id)\r\n{\r\nreg_timer_r_masked_intr masked_intr;\r\nmasked_intr = REG_RD(timer, regi_timer0, r_masked_intr);\r\nif (!masked_intr.trig)\r\nreturn IRQ_NONE;\r\ntimer_trig_handler(NULL);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void timer_trig_handler(struct work_struct *work)\r\n{\r\nreg_timer_rw_ack_intr ack_intr = { 0 };\r\nreg_timer_rw_intr_mask intr_mask;\r\nreg_timer_rw_trig_cfg trig_cfg = { 0 };\r\nstruct fast_timer *t;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nintr_mask = REG_RD(timer, regi_timer0, rw_intr_mask);\r\nintr_mask.trig = 0;\r\nREG_WR(timer, regi_timer0, rw_intr_mask, intr_mask);\r\ntrig_cfg.tmr = regk_timer_off;\r\nREG_WR(timer, regi_timer0, rw_trig_cfg, trig_cfg);\r\nack_intr.trig = 1;\r\nREG_WR(timer, regi_timer0, rw_ack_intr, ack_intr);\r\nfast_timer_running = 0;\r\nfast_timer_ints++;\r\nfast_timer_function_type *f;\r\nunsigned long d;\r\nt = fast_timer_list;\r\nwhile (t) {\r\nstruct fasttime_t tv;\r\ndo_gettimeofday_fast(&tv);\r\nD1(printk(KERN_DEBUG\r\n"t: %is %06ius\n", tv.tv_jiff, tv.tv_usec));\r\nif (fasttime_cmp(&t->tv_expires, &tv) <= 0) {\r\n#ifdef FAST_TIMER_LOG\r\ntimer_expired_log[fast_timers_expired % NUM_TIMER_STATS] = *t;\r\n#endif\r\nfast_timers_expired++;\r\nif (t->prev)\r\nt->prev->next = t->next;\r\nelse\r\nfast_timer_list = t->next;\r\nif (t->next)\r\nt->next->prev = t->prev;\r\nt->prev = NULL;\r\nt->next = NULL;\r\nf = t->function;\r\nd = t->data;\r\nif (f != NULL) {\r\nlocal_irq_restore(flags);\r\nf(d);\r\nlocal_irq_save(flags);\r\n} else\r\nDEBUG_LOG("!trimertrig %i function==NULL!\n", fast_timer_ints);\r\n} else {\r\nD1(printk(".\n"));\r\n}\r\nt = fast_timer_list;\r\nif (t != NULL) {\r\nlong us = 0;\r\nstruct fasttime_t tv;\r\ndo_gettimeofday_fast(&tv);\r\nif (time_after_eq(t->tv_expires.tv_jiff, tv.tv_jiff))\r\nus = ((t->tv_expires.tv_jiff - tv.tv_jiff) *\r\n1000000 / HZ + t->tv_expires.tv_usec -\r\ntv.tv_usec);\r\nif (us > 0) {\r\nif (!fast_timer_running) {\r\n#ifdef FAST_TIMER_LOG\r\ntimer_started_log[fast_timers_started % NUM_TIMER_STATS] = *t;\r\n#endif\r\nstart_timer_trig(us);\r\n}\r\nbreak;\r\n} else {\r\nD1(printk("e! %d\n", us));\r\n}\r\n}\r\n}\r\nlocal_irq_restore(flags);\r\nif (!t)\r\nD1(printk("ttrig stop!\n"));\r\n}\r\nstatic void wake_up_func(unsigned long data)\r\n{\r\nwait_queue_head_t *sleep_wait_p = (wait_queue_head_t*)data;\r\nwake_up(sleep_wait_p);\r\n}\r\nvoid schedule_usleep(unsigned long us)\r\n{\r\nstruct fast_timer t;\r\nwait_queue_head_t sleep_wait;\r\ninit_waitqueue_head(&sleep_wait);\r\nD1(printk("schedule_usleep(%d)\n", us));\r\nstart_one_shot_timer(&t, wake_up_func, (unsigned long)&sleep_wait, us,\r\n"usleep");\r\nwait_event(sleep_wait, !fast_timer_pending(&t));\r\nD1(printk("done schedule_usleep(%d)\n", us));\r\n}\r\nstatic int proc_fasttimer_show(struct seq_file *m, void *v)\r\n{\r\nunsigned long flags;\r\nint i = 0;\r\nint num_to_show;\r\nstruct fasttime_t tv;\r\nstruct fast_timer *t, *nextt;\r\ndo_gettimeofday_fast(&tv);\r\nseq_printf(m, "Fast timers added: %i\n", fast_timers_added);\r\nseq_printf(m, "Fast timers started: %i\n", fast_timers_started);\r\nseq_printf(m, "Fast timer interrupts: %i\n", fast_timer_ints);\r\nseq_printf(m, "Fast timers expired: %i\n", fast_timers_expired);\r\nseq_printf(m, "Fast timers deleted: %i\n", fast_timers_deleted);\r\nseq_printf(m, "Fast timer running: %s\n",\r\nfast_timer_running ? "yes" : "no");\r\nseq_printf(m, "Current time: %lu.%06lu\n",\r\n(unsigned long)tv.tv_jiff,\r\n(unsigned long)tv.tv_usec);\r\n#ifdef FAST_TIMER_SANITY_CHECKS\r\nseq_printf(m, "Sanity failed: %i\n", sanity_failed);\r\n#endif\r\nseq_putc(m, '\n');\r\n#ifdef DEBUG_LOG_INCLUDED\r\n{\r\nint end_i = debug_log_cnt;\r\ni = 0;\r\nif (debug_log_cnt_wrapped)\r\ni = debug_log_cnt;\r\nwhile ((i != end_i || debug_log_cnt_wrapped)) {\r\nseq_printf(m, debug_log_string[i], debug_log_value[i]);\r\nif (seq_has_overflowed(m))\r\nreturn 0;\r\ni = (i+1) % DEBUG_LOG_MAX;\r\n}\r\n}\r\nseq_putc(m, '\n');\r\n#endif\r\nnum_to_show = (fast_timers_started < NUM_TIMER_STATS ? fast_timers_started:\r\nNUM_TIMER_STATS);\r\nseq_printf(m, "Timers started: %i\n", fast_timers_started);\r\nfor (i = 0; i < num_to_show; i++) {\r\nint cur = (fast_timers_started - i - 1) % NUM_TIMER_STATS;\r\n#if 1\r\nseq_printf(m, "div: %i delay: %i\n",\r\ntimer_div_settings[cur],\r\ntimer_delay_settings[cur]);\r\n#endif\r\n#ifdef FAST_TIMER_LOG\r\nt = &timer_started_log[cur];\r\nseq_printf(m, "%-14s s: %6lu.%06lu e: %6lu.%06lu d: %6li us data: 0x%08lX\n",\r\nt->name,\r\n(unsigned long)t->tv_set.tv_jiff,\r\n(unsigned long)t->tv_set.tv_usec,\r\n(unsigned long)t->tv_expires.tv_jiff,\r\n(unsigned long)t->tv_expires.tv_usec,\r\nt->delay_us,\r\nt->data);\r\nif (seq_has_overflowed(m))\r\nreturn 0;\r\n#endif\r\n}\r\nseq_putc(m, '\n');\r\n#ifdef FAST_TIMER_LOG\r\nnum_to_show = (fast_timers_added < NUM_TIMER_STATS ? fast_timers_added:\r\nNUM_TIMER_STATS);\r\nseq_printf(m, "Timers added: %i\n", fast_timers_added);\r\nfor (i = 0; i < num_to_show; i++) {\r\nt = &timer_added_log[(fast_timers_added - i - 1) % NUM_TIMER_STATS];\r\nseq_printf(m, "%-14s s: %6lu.%06lu e: %6lu.%06lu d: %6li us data: 0x%08lX\n",\r\nt->name,\r\n(unsigned long)t->tv_set.tv_jiff,\r\n(unsigned long)t->tv_set.tv_usec,\r\n(unsigned long)t->tv_expires.tv_jiff,\r\n(unsigned long)t->tv_expires.tv_usec,\r\nt->delay_us,\r\nt->data);\r\nif (seq_has_overflowed(m))\r\nreturn 0;\r\n}\r\nseq_putc(m, '\n');\r\nnum_to_show = (fast_timers_expired < NUM_TIMER_STATS ? fast_timers_expired:\r\nNUM_TIMER_STATS);\r\nseq_printf(m, "Timers expired: %i\n", fast_timers_expired);\r\nfor (i = 0; i < num_to_show; i++){\r\nt = &timer_expired_log[(fast_timers_expired - i - 1) % NUM_TIMER_STATS];\r\nseq_printf(m, "%-14s s: %6lu.%06lu e: %6lu.%06lu d: %6li us data: 0x%08lX\n",\r\nt->name,\r\n(unsigned long)t->tv_set.tv_jiff,\r\n(unsigned long)t->tv_set.tv_usec,\r\n(unsigned long)t->tv_expires.tv_jiff,\r\n(unsigned long)t->tv_expires.tv_usec,\r\nt->delay_us,\r\nt->data);\r\nif (seq_has_overflowed(m))\r\nreturn 0;\r\n}\r\nseq_putc(m, '\n');\r\n#endif\r\nseq_puts(m, "Active timers:\n");\r\nlocal_irq_save(flags);\r\nt = fast_timer_list;\r\nwhile (t != NULL){\r\nnextt = t->next;\r\nlocal_irq_restore(flags);\r\nseq_printf(m, "%-14s s: %6lu.%06lu e: %6lu.%06lu d: %6li us data: 0x%08lX\n",\r\nt->name,\r\n(unsigned long)t->tv_set.tv_jiff,\r\n(unsigned long)t->tv_set.tv_usec,\r\n(unsigned long)t->tv_expires.tv_jiff,\r\n(unsigned long)t->tv_expires.tv_usec,\r\nt->delay_us,\r\nt->data);\r\nif (seq_has_overflowed(m))\r\nreturn 0;\r\nlocal_irq_save(flags);\r\nif (t->next != nextt)\r\nprintk("timer removed!\n");\r\nt = nextt;\r\n}\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic int proc_fasttimer_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open_size(file, proc_fasttimer_show, PDE_DATA(inode), BIG_BUF_SIZE);\r\n}\r\nstatic void test_timeout(unsigned long data)\r\n{\r\ndo_gettimeofday_fast(&tv_exp[data]);\r\nexp_num[data] = num_test_timeout;\r\nnum_test_timeout++;\r\n}\r\nstatic void test_timeout1(unsigned long data)\r\n{\r\ndo_gettimeofday_fast(&tv_exp[data]);\r\nexp_num[data] = num_test_timeout;\r\nif (data < 7)\r\n{\r\nstart_one_shot_timer(&tr[i], test_timeout1, i, 1000, "timeout1");\r\ni++;\r\n}\r\nnum_test_timeout++;\r\n}\r\nstatic void fast_timer_test(void)\r\n{\r\nint prev_num;\r\nint j;\r\nstruct fasttime_t tv, tv0, tv1, tv2;\r\nprintk("fast_timer_test() start\n");\r\ndo_gettimeofday_fast(&tv);\r\nfor (j = 0; j < 1000; j++)\r\n{\r\nj_u[j] = GET_JIFFIES_USEC();\r\n}\r\nfor (j = 0; j < 100; j++)\r\n{\r\ndo_gettimeofday_fast(&tv_exp[j]);\r\n}\r\nprintk(KERN_DEBUG "fast_timer_test() %is %06i\n", tv.tv_jiff, tv.tv_usec);\r\nfor (j = 0; j < 1000; j++)\r\n{\r\nprintk(KERN_DEBUG "%i %i %i %i %i\n",\r\nj_u[j], j_u[j+1], j_u[j+2], j_u[j+3], j_u[j+4]);\r\nj += 4;\r\n}\r\nfor (j = 0; j < 100; j++)\r\n{\r\nprintk(KERN_DEBUG "%i.%i %i.%i %i.%i %i.%i %i.%i\n",\r\ntv_exp[j].tv_jiff, tv_exp[j].tv_usec,\r\ntv_exp[j+1].tv_jiff, tv_exp[j+1].tv_usec,\r\ntv_exp[j+2].tv_jiff, tv_exp[j+2].tv_usec,\r\ntv_exp[j+3].tv_jiff, tv_exp[j+3].tv_usec,\r\ntv_exp[j+4].tv_jiff, tv_exp[j+4].tv_usec);\r\nj += 4;\r\n}\r\ndo_gettimeofday_fast(&tv0);\r\nstart_one_shot_timer(&tr[i], test_timeout, i, 50000, "test0");\r\nDP(proc_fasttimer_read(buf0, NULL, 0, 0, 0));\r\ni++;\r\nstart_one_shot_timer(&tr[i], test_timeout, i, 70000, "test1");\r\nDP(proc_fasttimer_read(buf1, NULL, 0, 0, 0));\r\ni++;\r\nstart_one_shot_timer(&tr[i], test_timeout, i, 40000, "test2");\r\nDP(proc_fasttimer_read(buf2, NULL, 0, 0, 0));\r\ni++;\r\nstart_one_shot_timer(&tr[i], test_timeout, i, 60000, "test3");\r\nDP(proc_fasttimer_read(buf3, NULL, 0, 0, 0));\r\ni++;\r\nstart_one_shot_timer(&tr[i], test_timeout1, i, 55000, "test4xx");\r\nDP(proc_fasttimer_read(buf4, NULL, 0, 0, 0));\r\ni++;\r\ndo_gettimeofday_fast(&tv1);\r\nproc_fasttimer_read(buf5, NULL, 0, 0, 0);\r\nprev_num = num_test_timeout;\r\nwhile (num_test_timeout < i)\r\n{\r\nif (num_test_timeout != prev_num)\r\nprev_num = num_test_timeout;\r\n}\r\ndo_gettimeofday_fast(&tv2);\r\nprintk(KERN_INFO "Timers started %is %06i\n",\r\ntv0.tv_jiff, tv0.tv_usec);\r\nprintk(KERN_INFO "Timers started at %is %06i\n",\r\ntv1.tv_jiff, tv1.tv_usec);\r\nprintk(KERN_INFO "Timers done %is %06i\n",\r\ntv2.tv_jiff, tv2.tv_usec);\r\nDP(printk("buf0:\n");\r\nprintk(buf0);\r\nprintk("buf1:\n");\r\nprintk(buf1);\r\nprintk("buf2:\n");\r\nprintk(buf2);\r\nprintk("buf3:\n");\r\nprintk(buf3);\r\nprintk("buf4:\n");\r\nprintk(buf4);\r\n);\r\nprintk("buf5:\n");\r\nprintk(buf5);\r\nprintk("timers set:\n");\r\nfor(j = 0; j<i; j++)\r\n{\r\nstruct fast_timer *t = &tr[j];\r\nprintk("%-10s set: %6is %06ius exp: %6is %06ius "\r\n"data: 0x%08X func: 0x%08X\n",\r\nt->name,\r\nt->tv_set.tv_jiff,\r\nt->tv_set.tv_usec,\r\nt->tv_expires.tv_jiff,\r\nt->tv_expires.tv_usec,\r\nt->data,\r\nt->function\r\n);\r\nprintk(" del: %6ius did exp: %6is %06ius as #%i error: %6li\n",\r\nt->delay_us,\r\ntv_exp[j].tv_jiff,\r\ntv_exp[j].tv_usec,\r\nexp_num[j],\r\n(tv_exp[j].tv_jiff - t->tv_expires.tv_jiff) *\r\n1000000 + tv_exp[j].tv_usec -\r\nt->tv_expires.tv_usec);\r\n}\r\nproc_fasttimer_read(buf5, NULL, 0, 0, 0);\r\nprintk("buf5 after all done:\n");\r\nprintk(buf5);\r\nprintk("fast_timer_test() done\n");\r\n}\r\nint fast_timer_init(void)\r\n{\r\nif (!fast_timer_is_init)\r\n{\r\nprintk("fast_timer_init()\n");\r\n#ifdef CONFIG_PROC_FS\r\nproc_create("fasttimer", 0, NULL, &proc_fasttimer_fops);\r\n#endif\r\nif (request_irq(TIMER0_INTR_VECT, timer_trig_interrupt,\r\nIRQF_SHARED,\r\n"fast timer int", &fast_timer_list))\r\nprintk(KERN_ERR "err: fasttimer irq\n");\r\nfast_timer_is_init = 1;\r\n#ifdef FAST_TIMER_TEST\r\nprintk("do test\n");\r\nfast_timer_test();\r\n#endif\r\n}\r\nreturn 0;\r\n}
