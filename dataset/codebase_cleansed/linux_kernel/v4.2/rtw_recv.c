void _rtw_init_sta_recv_priv23a(struct sta_recv_priv *psta_recvpriv)\r\n{\r\nspin_lock_init(&psta_recvpriv->lock);\r\n_rtw_init_queue23a(&psta_recvpriv->defrag_q);\r\n}\r\nint _rtw_init_recv_priv23a(struct recv_priv *precvpriv,\r\nstruct rtw_adapter *padapter)\r\n{\r\nstruct recv_frame *precvframe;\r\nint i;\r\nint res = _SUCCESS;\r\nspin_lock_init(&precvpriv->lock);\r\n_rtw_init_queue23a(&precvpriv->free_recv_queue);\r\n_rtw_init_queue23a(&precvpriv->recv_pending_queue);\r\n_rtw_init_queue23a(&precvpriv->uc_swdec_pending_queue);\r\nprecvpriv->adapter = padapter;\r\nfor (i = 0; i < NR_RECVFRAME ; i++) {\r\nprecvframe = kzalloc(sizeof(struct recv_frame), GFP_KERNEL);\r\nif (!precvframe)\r\nbreak;\r\nINIT_LIST_HEAD(&precvframe->list);\r\nlist_add_tail(&precvframe->list,\r\n&precvpriv->free_recv_queue.queue);\r\nprecvframe->adapter = padapter;\r\nprecvframe++;\r\n}\r\nprecvpriv->free_recvframe_cnt = i;\r\nprecvpriv->rx_pending_cnt = 1;\r\nres = rtl8723au_init_recv_priv(padapter);\r\nsetup_timer(&precvpriv->signal_stat_timer, rtw_signal_stat_timer_hdl23a,\r\n(unsigned long)padapter);\r\nprecvpriv->signal_stat_sampling_interval = 1000;\r\nrtw_set_signal_stat_timer(precvpriv);\r\nreturn res;\r\n}\r\nvoid _rtw_free_recv_priv23a (struct recv_priv *precvpriv)\r\n{\r\nstruct rtw_adapter *padapter = precvpriv->adapter;\r\nstruct recv_frame *precvframe;\r\nstruct list_head *plist, *ptmp;\r\nrtw_free_uc_swdec_pending_queue23a(padapter);\r\nlist_for_each_safe(plist, ptmp, &precvpriv->free_recv_queue.queue) {\r\nprecvframe = container_of(plist, struct recv_frame, list);\r\nlist_del_init(&precvframe->list);\r\nkfree(precvframe);\r\n}\r\nrtl8723au_free_recv_priv(padapter);\r\n}\r\nstruct recv_frame *rtw_alloc_recvframe23a(struct rtw_queue *pfree_recv_queue)\r\n{\r\nstruct recv_frame *pframe;\r\nstruct list_head *plist, *phead;\r\nstruct rtw_adapter *padapter;\r\nstruct recv_priv *precvpriv;\r\nspin_lock_bh(&pfree_recv_queue->lock);\r\nif (list_empty(&pfree_recv_queue->queue))\r\npframe = NULL;\r\nelse {\r\nphead = get_list_head(pfree_recv_queue);\r\nplist = phead->next;\r\npframe = container_of(plist, struct recv_frame, list);\r\nlist_del_init(&pframe->list);\r\npadapter = pframe->adapter;\r\nif (padapter) {\r\nprecvpriv = &padapter->recvpriv;\r\nif (pfree_recv_queue == &precvpriv->free_recv_queue)\r\nprecvpriv->free_recvframe_cnt--;\r\n}\r\n}\r\nspin_unlock_bh(&pfree_recv_queue->lock);\r\nreturn pframe;\r\n}\r\nint rtw_free_recvframe23a(struct recv_frame *precvframe)\r\n{\r\nstruct rtw_adapter *padapter = precvframe->adapter;\r\nstruct recv_priv *precvpriv = &padapter->recvpriv;\r\nstruct rtw_queue *pfree_recv_queue;\r\nif (precvframe->pkt) {\r\ndev_kfree_skb_any(precvframe->pkt);\r\nprecvframe->pkt = NULL;\r\n}\r\npfree_recv_queue = &precvpriv->free_recv_queue;\r\nspin_lock_bh(&pfree_recv_queue->lock);\r\nlist_del_init(&precvframe->list);\r\nlist_add_tail(&precvframe->list, get_list_head(pfree_recv_queue));\r\nif (padapter) {\r\nif (pfree_recv_queue == &precvpriv->free_recv_queue)\r\nprecvpriv->free_recvframe_cnt++;\r\n}\r\nspin_unlock_bh(&pfree_recv_queue->lock);\r\nreturn _SUCCESS;\r\n}\r\nint rtw_enqueue_recvframe23a(struct recv_frame *precvframe, struct rtw_queue *queue)\r\n{\r\nstruct rtw_adapter *padapter = precvframe->adapter;\r\nstruct recv_priv *precvpriv = &padapter->recvpriv;\r\nspin_lock_bh(&queue->lock);\r\nlist_del_init(&precvframe->list);\r\nlist_add_tail(&precvframe->list, get_list_head(queue));\r\nif (padapter) {\r\nif (queue == &precvpriv->free_recv_queue)\r\nprecvpriv->free_recvframe_cnt++;\r\n}\r\nspin_unlock_bh(&queue->lock);\r\nreturn _SUCCESS;\r\n}\r\nstatic void rtw_free_recvframe23a_queue(struct rtw_queue *pframequeue)\r\n{\r\nstruct recv_frame *hdr;\r\nstruct list_head *plist, *phead, *ptmp;\r\nspin_lock(&pframequeue->lock);\r\nphead = get_list_head(pframequeue);\r\nplist = phead->next;\r\nlist_for_each_safe(plist, ptmp, phead) {\r\nhdr = container_of(plist, struct recv_frame, list);\r\nrtw_free_recvframe23a(hdr);\r\n}\r\nspin_unlock(&pframequeue->lock);\r\n}\r\nu32 rtw_free_uc_swdec_pending_queue23a(struct rtw_adapter *adapter)\r\n{\r\nu32 cnt = 0;\r\nstruct recv_frame *pending_frame;\r\nwhile ((pending_frame = rtw_alloc_recvframe23a(&adapter->recvpriv.uc_swdec_pending_queue))) {\r\nrtw_free_recvframe23a(pending_frame);\r\nDBG_8723A("%s: dequeue uc_swdec_pending_queue\n", __func__);\r\ncnt++;\r\n}\r\nreturn cnt;\r\n}\r\nint rtw_enqueue_recvbuf23a_to_head(struct recv_buf *precvbuf, struct rtw_queue *queue)\r\n{\r\nspin_lock_bh(&queue->lock);\r\nlist_del_init(&precvbuf->list);\r\nlist_add(&precvbuf->list, get_list_head(queue));\r\nspin_unlock_bh(&queue->lock);\r\nreturn _SUCCESS;\r\n}\r\nint rtw_enqueue_recvbuf23a(struct recv_buf *precvbuf, struct rtw_queue *queue)\r\n{\r\nunsigned long irqL;\r\nspin_lock_irqsave(&queue->lock, irqL);\r\nlist_del_init(&precvbuf->list);\r\nlist_add_tail(&precvbuf->list, get_list_head(queue));\r\nspin_unlock_irqrestore(&queue->lock, irqL);\r\nreturn _SUCCESS;\r\n}\r\nstruct recv_buf *rtw_dequeue_recvbuf23a (struct rtw_queue *queue)\r\n{\r\nunsigned long irqL;\r\nstruct recv_buf *precvbuf;\r\nstruct list_head *plist, *phead;\r\nspin_lock_irqsave(&queue->lock, irqL);\r\nif (list_empty(&queue->queue)) {\r\nprecvbuf = NULL;\r\n} else {\r\nphead = get_list_head(queue);\r\nplist = phead->next;\r\nprecvbuf = container_of(plist, struct recv_buf, list);\r\nlist_del_init(&precvbuf->list);\r\n}\r\nspin_unlock_irqrestore(&queue->lock, irqL);\r\nreturn precvbuf;\r\n}\r\nint recvframe_chkmic(struct rtw_adapter *adapter,\r\nstruct recv_frame *precvframe) {\r\nint i, res = _SUCCESS;\r\nu32 datalen;\r\nu8 miccode[8];\r\nu8 bmic_err = false, brpt_micerror = true;\r\nu8 *pframe, *payload, *pframemic;\r\nu8 *mickey;\r\nstruct sta_info *stainfo;\r\nstruct rx_pkt_attrib *prxattrib = &precvframe->attrib;\r\nstruct security_priv *psecuritypriv = &adapter->securitypriv;\r\nstruct mlme_ext_priv *pmlmeext = &adapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nstainfo = rtw_get_stainfo23a(&adapter->stapriv, &prxattrib->ta[0]);\r\nif (prxattrib->encrypt == WLAN_CIPHER_SUITE_TKIP) {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_info_,\r\n"recvframe_chkmic:prxattrib->encrypt == WLAN_CIPHER_SUITE_TKIP\n");\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_info_,\r\n"recvframe_chkmic:da = %pM\n", prxattrib->ra);\r\nif (stainfo != NULL) {\r\nif (is_multicast_ether_addr(prxattrib->ra)) {\r\nmickey = &psecuritypriv->dot118021XGrprxmickey[prxattrib->key_index].skey[0];\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_info_,\r\n"recvframe_chkmic: bcmc key\n");\r\nif (!psecuritypriv->binstallGrpkey) {\r\nres = _FAIL;\r\nRT_TRACE(_module_rtl871x_recv_c_,\r\n_drv_err_,\r\n"recvframe_chkmic:didn't install group key!\n");\r\nDBG_8723A("\n recvframe_chkmic:didn't "\r\n"install group key!!!!!!\n");\r\ngoto exit;\r\n}\r\n} else {\r\nmickey = &stainfo->dot11tkiprxmickey.skey[0];\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n"recvframe_chkmic: unicast key\n");\r\n}\r\ndatalen = precvframe->pkt->len-prxattrib->\r\nhdrlen-prxattrib->iv_len-prxattrib->icv_len - 8;\r\npframe = precvframe->pkt->data;\r\npayload = pframe + prxattrib->hdrlen +\r\nprxattrib->iv_len;\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_info_,\r\n"prxattrib->iv_len =%d prxattrib->icv_len =%d\n",\r\nprxattrib->iv_len, prxattrib->icv_len);\r\nrtw_seccalctkipmic23a(mickey, pframe, payload,\r\ndatalen, &miccode[0],\r\n(unsigned char)prxattrib->priority);\r\npframemic = payload + datalen;\r\nbmic_err = false;\r\nfor (i = 0; i < 8; i++) {\r\nif (miccode[i] != *(pframemic + i)) {\r\nRT_TRACE(_module_rtl871x_recv_c_,\r\n_drv_err_,\r\n"recvframe_chkmic:miccode[%d](%02x) != *(pframemic+%d)(%02x)\n",\r\ni, miccode[i],\r\ni, *(pframemic + i));\r\nbmic_err = true;\r\n}\r\n}\r\nif (bmic_err == true) {\r\nint i;\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n"*(pframemic-8)-*(pframemic-1) =0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",\r\n*(pframemic - 8), *(pframemic - 7),\r\n*(pframemic - 6), *(pframemic - 5),\r\n*(pframemic - 4), *(pframemic - 3),\r\n*(pframemic - 2), *(pframemic - 1));\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n"*(pframemic-16)-*(pframemic-9) =0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",\r\n*(pframemic - 16), *(pframemic - 15),\r\n*(pframemic - 14), *(pframemic - 13),\r\n*(pframemic - 12), *(pframemic - 11),\r\n*(pframemic - 10), *(pframemic - 9));\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n"====== demp packet (len =%d) ======\n",\r\nprecvframe->pkt->len);\r\nfor (i = 0; i < precvframe->pkt->len; i = i + 8) {\r\nRT_TRACE(_module_rtl871x_recv_c_,\r\n_drv_err_,\r\n"0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",\r\n*(precvframe->pkt->data+i),\r\n*(precvframe->pkt->data+i+1),\r\n*(precvframe->pkt->data+i+2),\r\n*(precvframe->pkt->data+i+3),\r\n*(precvframe->pkt->data+i+4),\r\n*(precvframe->pkt->data+i+5),\r\n*(precvframe->pkt->data+i+6),\r\n*(precvframe->pkt->data+i+7));\r\n}\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n"====== demp packet end [len =%d]======\n",\r\nprecvframe->pkt->len);\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n"hrdlen =%d\n", prxattrib->hdrlen);\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n"ra = %pM psecuritypriv->binstallGrpkey =%d\n",\r\nprxattrib->ra,\r\npsecuritypriv->binstallGrpkey);\r\nif ((is_multicast_ether_addr(prxattrib->ra)) &&\r\n(prxattrib->key_index !=\r\npmlmeinfo->key_index))\r\nbrpt_micerror = false;\r\nif ((prxattrib->bdecrypted == true) &&\r\n(brpt_micerror == true)) {\r\nrtw_handle_tkip_mic_err23a(adapter, (u8)is_multicast_ether_addr(prxattrib->ra));\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n"mic error :prxattrib->bdecrypted =%d\n",\r\nprxattrib->bdecrypted);\r\nDBG_8723A(" mic error :prxattrib->"\r\n"bdecrypted =%d\n",\r\nprxattrib->bdecrypted);\r\n} else {\r\nRT_TRACE(_module_rtl871x_recv_c_,\r\n_drv_err_,\r\n"mic error :prxattrib->bdecrypted =%d\n",\r\nprxattrib->bdecrypted);\r\nDBG_8723A(" mic error :prxattrib->"\r\n"bdecrypted =%d\n",\r\nprxattrib->bdecrypted);\r\n}\r\nres = _FAIL;\r\n} else {\r\nif (!psecuritypriv->bcheck_grpkey &&\r\nis_multicast_ether_addr(prxattrib->ra)) {\r\npsecuritypriv->bcheck_grpkey = 1;\r\nRT_TRACE(_module_rtl871x_recv_c_,\r\n_drv_err_,\r\n"psecuritypriv->bcheck_grpkey = true\n");\r\n}\r\n}\r\n} else {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n"recvframe_chkmic: rtw_get_stainfo23a ==NULL!!!\n");\r\n}\r\nskb_trim(precvframe->pkt, precvframe->pkt->len - 8);\r\n}\r\nexit:\r\nreturn res;\r\n}\r\nstruct recv_frame *decryptor(struct rtw_adapter *padapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\nstruct rx_pkt_attrib *prxattrib = &precv_frame->attrib;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct recv_frame *return_packet = precv_frame;\r\nint res = _SUCCESS;\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_info_,\r\n"prxstat->decrypted =%x prxattrib->encrypt = 0x%03x\n",\r\nprxattrib->bdecrypted, prxattrib->encrypt);\r\nif (prxattrib->encrypt > 0) {\r\nu8 *iv = precv_frame->pkt->data + prxattrib->hdrlen;\r\nprxattrib->key_index = (((iv[3]) >> 6) & 0x3);\r\nif (prxattrib->key_index > WEP_KEYS) {\r\nDBG_8723A("prxattrib->key_index(%d) > WEP_KEYS\n",\r\nprxattrib->key_index);\r\nswitch (prxattrib->encrypt) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\nprxattrib->key_index =\r\npsecuritypriv->dot11PrivacyKeyIndex;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\ndefault:\r\nprxattrib->key_index =\r\npsecuritypriv->dot118021XGrpKeyid;\r\nbreak;\r\n}\r\n}\r\n}\r\nif ((prxattrib->encrypt > 0) && ((prxattrib->bdecrypted == 0))) {\r\npsecuritypriv->hw_decrypted = 0;\r\nswitch (prxattrib->encrypt) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\nrtw_wep_decrypt23a(padapter, precv_frame);\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nres = rtw_tkip_decrypt23a(padapter, precv_frame);\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nres = rtw_aes_decrypt23a(padapter, precv_frame);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else if (prxattrib->bdecrypted == 1 && prxattrib->encrypt > 0 &&\r\n(psecuritypriv->busetkipkey == 1 ||\r\nprxattrib->encrypt != WLAN_CIPHER_SUITE_TKIP)) {\r\npsecuritypriv->hw_decrypted = 1;\r\n}\r\nif (res == _FAIL) {\r\nrtw_free_recvframe23a(return_packet);\r\nreturn_packet = NULL;\r\n}\r\nreturn return_packet;\r\n}\r\nstatic struct recv_frame *portctrl(struct rtw_adapter *adapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\nu8 *psta_addr, *ptr;\r\nuint auth_alg;\r\nstruct recv_frame *pfhdr;\r\nstruct sta_info *psta;\r\nstruct sta_priv *pstapriv ;\r\nstruct recv_frame *prtnframe;\r\nu16 ether_type;\r\nu16 eapol_type = ETH_P_PAE;\r\nstruct rx_pkt_attrib *pattrib;\r\npstapriv = &adapter->stapriv;\r\nauth_alg = adapter->securitypriv.dot11AuthAlgrthm;\r\npfhdr = precv_frame;\r\npattrib = &pfhdr->attrib;\r\npsta_addr = pattrib->ta;\r\npsta = rtw_get_stainfo23a(pstapriv, psta_addr);\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_info_,\r\n"########portctrl:adapter->securitypriv.dot11AuthAlgrthm =%d\n",\r\nadapter->securitypriv.dot11AuthAlgrthm);\r\nprtnframe = precv_frame;\r\nif (auth_alg == dot11AuthAlgrthm_8021X) {\r\nptr = pfhdr->pkt->data + pfhdr->attrib.hdrlen;\r\nether_type = (ptr[6] << 8) | ptr[7];\r\nif (psta && psta->ieee8021x_blocked) {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_info_,\r\n"########portctrl:psta->ieee8021x_blocked ==1\n");\r\nif (ether_type != eapol_type) {\r\nrtw_free_recvframe23a(precv_frame);\r\nprtnframe = NULL;\r\n}\r\n}\r\n}\r\nreturn prtnframe;\r\n}\r\nint recv_decache(struct recv_frame *precv_frame, u8 bretry,\r\nstruct stainfo_rxcache *prxcache)\r\n{\r\nint tid = precv_frame->attrib.priority;\r\nu16 seq_ctrl = ((precv_frame->attrib.seq_num & 0xffff) << 4) |\r\n(precv_frame->attrib.frag_num & 0xf);\r\nif (tid > 15) {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_notice_,\r\n"recv_decache, (tid>15)! seq_ctrl = 0x%x, tid = 0x%x\n",\r\nseq_ctrl, tid);\r\nreturn _FAIL;\r\n}\r\nif (1) {\r\nif (seq_ctrl == prxcache->tid_rxseq[tid]) {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_notice_,\r\n"recv_decache, seq_ctrl = 0x%x, tid = 0x%x, tid_rxseq = 0x%x\n",\r\nseq_ctrl, tid, prxcache->tid_rxseq[tid]);\r\nreturn _FAIL;\r\n}\r\n}\r\nprxcache->tid_rxseq[tid] = seq_ctrl;\r\nreturn _SUCCESS;\r\n}\r\nvoid process23a_pwrbit_data(struct rtw_adapter *padapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\n#ifdef CONFIG_8723AU_AP_MODE\r\nunsigned char pwrbit;\r\nstruct sk_buff *skb = precv_frame->pkt;\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nstruct rx_pkt_attrib *pattrib = &precv_frame->attrib;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct sta_info *psta = NULL;\r\npsta = rtw_get_stainfo23a(pstapriv, pattrib->src);\r\nif (psta) {\r\npwrbit = ieee80211_has_pm(hdr->frame_control);\r\nif (pwrbit) {\r\nif (!(psta->state & WIFI_SLEEP_STATE))\r\nstop_sta_xmit23a(padapter, psta);\r\n} else {\r\nif (psta->state & WIFI_SLEEP_STATE)\r\nwakeup_sta_to_xmit23a(padapter, psta);\r\n}\r\n}\r\n#endif\r\n}\r\nvoid process_wmmps_data(struct rtw_adapter *padapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\n#ifdef CONFIG_8723AU_AP_MODE\r\nstruct rx_pkt_attrib *pattrib = &precv_frame->attrib;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct sta_info *psta = NULL;\r\npsta = rtw_get_stainfo23a(pstapriv, pattrib->src);\r\nif (!psta)\r\nreturn;\r\nif (!psta->qos_option)\r\nreturn;\r\nif (!(psta->qos_info & 0xf))\r\nreturn;\r\nif (psta->state & WIFI_SLEEP_STATE) {\r\nu8 wmmps_ac = 0;\r\nswitch (pattrib->priority) {\r\ncase 1:\r\ncase 2:\r\nwmmps_ac = psta->uapsd_bk & BIT(1);\r\nbreak;\r\ncase 4:\r\ncase 5:\r\nwmmps_ac = psta->uapsd_vi & BIT(1);\r\nbreak;\r\ncase 6:\r\ncase 7:\r\nwmmps_ac = psta->uapsd_vo & BIT(1);\r\nbreak;\r\ncase 0:\r\ncase 3:\r\ndefault:\r\nwmmps_ac = psta->uapsd_be & BIT(1);\r\nbreak;\r\n}\r\nif (wmmps_ac) {\r\nif (psta->sleepq_ac_len > 0) {\r\nxmit_delivery_enabled_frames23a(padapter, psta);\r\n} else {\r\nissue_qos_nulldata23a(padapter, psta->hwaddr,\r\n(u16)pattrib->priority,\r\n0, 0);\r\n}\r\n}\r\n}\r\n#endif\r\n}\r\nstatic void count_rx_stats(struct rtw_adapter *padapter,\r\nstruct recv_frame *prframe, struct sta_info *sta)\r\n{\r\nint sz;\r\nstruct sta_info *psta = NULL;\r\nstruct stainfo_stats *pstats = NULL;\r\nstruct rx_pkt_attrib *pattrib = & prframe->attrib;\r\nstruct recv_priv *precvpriv = &padapter->recvpriv;\r\nsz = prframe->pkt->len;\r\nprecvpriv->rx_bytes += sz;\r\npadapter->mlmepriv.LinkDetectInfo.NumRxOkInPeriod++;\r\nif ((!is_broadcast_ether_addr(pattrib->dst)) &&\r\n(!is_multicast_ether_addr(pattrib->dst)))\r\npadapter->mlmepriv.LinkDetectInfo.NumRxUnicastOkInPeriod++;\r\nif (sta)\r\npsta = sta;\r\nelse\r\npsta = prframe->psta;\r\nif (psta) {\r\npstats = &psta->sta_stats;\r\npstats->rx_data_pkts++;\r\npstats->rx_bytes += sz;\r\n}\r\n}\r\nstatic int sta2sta_data_frame(struct rtw_adapter *adapter,\r\nstruct recv_frame *precv_frame,\r\nstruct sta_info**psta)\r\n{\r\nstruct sk_buff *skb = precv_frame->pkt;\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nint ret = _SUCCESS;\r\nstruct rx_pkt_attrib *pattrib = & precv_frame->attrib;\r\nstruct sta_priv *pstapriv = &adapter->stapriv;\r\nstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\r\nu8 *mybssid = get_bssid(pmlmepriv);\r\nu8 *myhwaddr = myid(&adapter->eeprompriv);\r\nu8 *sta_addr = NULL;\r\nint bmcast = is_multicast_ether_addr(pattrib->dst);\r\nif (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) ||\r\ncheck_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) {\r\nif (ether_addr_equal(myhwaddr, pattrib->src)) {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n"SA == myself\n");\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\nif (!ether_addr_equal(myhwaddr, pattrib->dst) && !bmcast) {\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\nif (ether_addr_equal(pattrib->bssid, "\x0\x0\x0\x0\x0\x0") ||\r\nether_addr_equal(mybssid, "\x0\x0\x0\x0\x0\x0") ||\r\n!ether_addr_equal(pattrib->bssid, mybssid)) {\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\nsta_addr = pattrib->src;\r\n} else if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {\r\nif (!ether_addr_equal(pattrib->bssid, pattrib->src)) {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n"bssid != TA under STATION_MODE; drop pkt\n");\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\nsta_addr = pattrib->bssid;\r\n} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\r\nif (bmcast) {\r\nif (!is_multicast_ether_addr(pattrib->bssid)) {\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\n} else {\r\nif (!ether_addr_equal(pattrib->bssid, pattrib->dst)) {\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\nsta_addr = pattrib->src;\r\n}\r\n} else if (check_fwstate(pmlmepriv, WIFI_MP_STATE)) {\r\nether_addr_copy(pattrib->dst, hdr->addr1);\r\nether_addr_copy(pattrib->src, hdr->addr2);\r\nether_addr_copy(pattrib->bssid, hdr->addr3);\r\nether_addr_copy(pattrib->ra, pattrib->dst);\r\nether_addr_copy(pattrib->ta, pattrib->src);\r\nsta_addr = mybssid;\r\n} else {\r\nret = _FAIL;\r\n}\r\nif (bmcast)\r\n*psta = rtw_get_bcmc_stainfo23a(adapter);\r\nelse\r\n*psta = rtw_get_stainfo23a(pstapriv, sta_addr);\r\nif (*psta == NULL) {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n"can't get psta under sta2sta_data_frame ; drop pkt\n");\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nint ap2sta_data_frame(struct rtw_adapter *adapter,\r\nstruct recv_frame *precv_frame,\r\nstruct sta_info **psta)\r\n{\r\nstruct sk_buff *skb = precv_frame->pkt;\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nstruct rx_pkt_attrib *pattrib = & precv_frame->attrib;\r\nint ret = _SUCCESS;\r\nstruct sta_priv *pstapriv = &adapter->stapriv;\r\nstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\r\nu8 *mybssid = get_bssid(pmlmepriv);\r\nu8 *myhwaddr = myid(&adapter->eeprompriv);\r\nint bmcast = is_multicast_ether_addr(pattrib->dst);\r\nif (check_fwstate(pmlmepriv, WIFI_STATION_STATE) &&\r\n(check_fwstate(pmlmepriv, _FW_LINKED) ||\r\ncheck_fwstate(pmlmepriv, _FW_UNDER_LINKING))) {\r\nif (ether_addr_equal(myhwaddr, pattrib->src)) {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n"SA == myself\n");\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\nif (!ether_addr_equal(myhwaddr, pattrib->dst) && !bmcast) {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_info_,\r\n"ap2sta_data_frame: compare DA failed; DA=%pM\n",\r\npattrib->dst);\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\nif (ether_addr_equal(pattrib->bssid, "\x0\x0\x0\x0\x0\x0") ||\r\nether_addr_equal(mybssid, "\x0\x0\x0\x0\x0\x0") ||\r\n!ether_addr_equal(pattrib->bssid, mybssid)) {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_info_,\r\n"ap2sta_data_frame: compare BSSID failed; BSSID=%pM\n",\r\npattrib->bssid);\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_info_,\r\n"mybssid=%pM\n", mybssid);\r\nif (!bmcast) {\r\nDBG_8723A("issue_deauth23a to the nonassociated ap=%pM for the reason(7)\n",\r\npattrib->bssid);\r\nissue_deauth23a(adapter, pattrib->bssid,\r\nWLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA);\r\n}\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\nif (bmcast)\r\n*psta = rtw_get_bcmc_stainfo23a(adapter);\r\nelse\r\n*psta = rtw_get_stainfo23a(pstapriv, pattrib->bssid);\r\nif (*psta == NULL) {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n"ap2sta: can't get psta under STATION_MODE; drop pkt\n");\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\nif (ieee80211_is_nullfunc(hdr->frame_control)) {\r\ncount_rx_stats(adapter, precv_frame, *psta);\r\nret = RTW_RX_HANDLED;\r\ngoto exit;\r\n}\r\n} else if (check_fwstate(pmlmepriv, WIFI_MP_STATE) &&\r\ncheck_fwstate(pmlmepriv, _FW_LINKED)) {\r\nether_addr_copy(pattrib->dst, hdr->addr1);\r\nether_addr_copy(pattrib->src, hdr->addr2);\r\nether_addr_copy(pattrib->bssid, hdr->addr3);\r\nether_addr_copy(pattrib->ra, pattrib->dst);\r\nether_addr_copy(pattrib->ta, pattrib->src);\r\nether_addr_copy(pattrib->bssid, mybssid);\r\n*psta = rtw_get_stainfo23a(pstapriv, pattrib->bssid);\r\nif (*psta == NULL) {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n"can't get psta under MP_MODE ; drop pkt\n");\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\n} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\r\nret = RTW_RX_HANDLED;\r\ngoto exit;\r\n} else {\r\nif (ether_addr_equal(myhwaddr, pattrib->dst) && !bmcast) {\r\n*psta = rtw_get_stainfo23a(pstapriv, pattrib->bssid);\r\nif (*psta == NULL) {\r\nDBG_8723A("issue_deauth23a to the ap=%pM for the reason(7)\n",\r\npattrib->bssid);\r\nissue_deauth23a(adapter, pattrib->bssid,\r\nWLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA);\r\n}\r\n}\r\nret = _FAIL;\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nint sta2ap_data_frame(struct rtw_adapter *adapter,\r\nstruct recv_frame *precv_frame,\r\nstruct sta_info **psta)\r\n{\r\nstruct sk_buff *skb = precv_frame->pkt;\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nstruct rx_pkt_attrib *pattrib = & precv_frame->attrib;\r\nstruct sta_priv *pstapriv = &adapter->stapriv;\r\nstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\r\nunsigned char *mybssid = get_bssid(pmlmepriv);\r\nint ret = _SUCCESS;\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\r\nif (!ether_addr_equal(pattrib->bssid, mybssid)) {\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\n*psta = rtw_get_stainfo23a(pstapriv, pattrib->src);\r\nif (*psta == NULL) {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n"can't get psta under AP_MODE; drop pkt\n");\r\nDBG_8723A("issue_deauth23a to sta=%pM for the reason(7)\n",\r\npattrib->src);\r\nissue_deauth23a(adapter, pattrib->src,\r\nWLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA);\r\nret = RTW_RX_HANDLED;\r\ngoto exit;\r\n}\r\nprocess23a_pwrbit_data(adapter, precv_frame);\r\nif (ieee80211_is_data_qos(hdr->frame_control))\r\nprocess_wmmps_data(adapter, precv_frame);\r\nif (ieee80211_is_nullfunc(hdr->frame_control)) {\r\ncount_rx_stats(adapter, precv_frame, *psta);\r\nret = RTW_RX_HANDLED;\r\ngoto exit;\r\n}\r\n} else {\r\nu8 *myhwaddr = myid(&adapter->eeprompriv);\r\nif (!ether_addr_equal(pattrib->ra, myhwaddr)) {\r\nret = RTW_RX_HANDLED;\r\ngoto exit;\r\n}\r\nDBG_8723A("issue_deauth23a to sta=%pM for the reason(7)\n",\r\npattrib->src);\r\nissue_deauth23a(adapter, pattrib->src,\r\nWLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA);\r\nret = RTW_RX_HANDLED;\r\ngoto exit;\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int validate_recv_ctrl_frame(struct rtw_adapter *padapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\n#ifdef CONFIG_8723AU_AP_MODE\r\nstruct rx_pkt_attrib *pattrib = &precv_frame->attrib;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct sk_buff *skb = precv_frame->pkt;\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nif (!ieee80211_is_ctl(hdr->frame_control))\r\nreturn _FAIL;\r\nif (!ether_addr_equal(hdr->addr1, myid(&padapter->eeprompriv)))\r\nreturn _FAIL;\r\nif (ieee80211_is_pspoll(hdr->frame_control)) {\r\nstruct ieee80211_pspoll *psp = (struct ieee80211_pspoll *)hdr;\r\nu16 aid;\r\nu8 wmmps_ac = 0;\r\nstruct sta_info *psta = NULL;\r\naid = le16_to_cpu(psp->aid) & 0x3fff;\r\npsta = rtw_get_stainfo23a(pstapriv, hdr->addr2);\r\nif (!psta || psta->aid != aid)\r\nreturn _FAIL;\r\npsta->sta_stats.rx_ctrl_pkts++;\r\nswitch (pattrib->priority) {\r\ncase 1:\r\ncase 2:\r\nwmmps_ac = psta->uapsd_bk & BIT(0);\r\nbreak;\r\ncase 4:\r\ncase 5:\r\nwmmps_ac = psta->uapsd_vi & BIT(0);\r\nbreak;\r\ncase 6:\r\ncase 7:\r\nwmmps_ac = psta->uapsd_vo & BIT(0);\r\nbreak;\r\ncase 0:\r\ncase 3:\r\ndefault:\r\nwmmps_ac = psta->uapsd_be & BIT(0);\r\nbreak;\r\n}\r\nif (wmmps_ac)\r\nreturn _FAIL;\r\nif (psta->state & WIFI_STA_ALIVE_CHK_STATE) {\r\nDBG_8723A("%s alive check-rx ps-poll\n", __func__);\r\npsta->expire_to = pstapriv->expire_to;\r\npsta->state ^= WIFI_STA_ALIVE_CHK_STATE;\r\n}\r\nif ((psta->state & WIFI_SLEEP_STATE) &&\r\n(pstapriv->sta_dz_bitmap & CHKBIT(psta->aid))) {\r\nstruct list_head *xmitframe_plist, *xmitframe_phead;\r\nstruct xmit_frame *pxmitframe;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nspin_lock_bh(&pxmitpriv->lock);\r\nxmitframe_phead = get_list_head(&psta->sleep_q);\r\nxmitframe_plist = xmitframe_phead->next;\r\nif (!list_empty(xmitframe_phead)) {\r\npxmitframe = container_of(xmitframe_plist,\r\nstruct xmit_frame,\r\nlist);\r\nxmitframe_plist = xmitframe_plist->next;\r\nlist_del_init(&pxmitframe->list);\r\npsta->sleepq_len--;\r\nif (psta->sleepq_len>0)\r\npxmitframe->attrib.mdata = 1;\r\nelse\r\npxmitframe->attrib.mdata = 0;\r\npxmitframe->attrib.triggered = 1;\r\nrtl8723au_hal_xmitframe_enqueue(padapter,\r\npxmitframe);\r\nif (psta->sleepq_len == 0) {\r\npstapriv->tim_bitmap &= ~CHKBIT(psta->aid);\r\nupdate_beacon23a(padapter, WLAN_EID_TIM,\r\nNULL, false);\r\n}\r\nspin_unlock_bh(&pxmitpriv->lock);\r\n} else {\r\nspin_unlock_bh(&pxmitpriv->lock);\r\nif (pstapriv->tim_bitmap & CHKBIT(psta->aid)) {\r\nif (psta->sleepq_len == 0) {\r\nDBG_8723A("no buffered packets "\r\n"to xmit\n");\r\nissue_nulldata23a(padapter,\r\npsta->hwaddr,\r\n0, 0, 0);\r\n} else {\r\nDBG_8723A("error!psta->sleepq"\r\n"_len =%d\n",\r\npsta->sleepq_len);\r\npsta->sleepq_len = 0;\r\n}\r\npstapriv->tim_bitmap &= ~CHKBIT(psta->aid);\r\nupdate_beacon23a(padapter, WLAN_EID_TIM,\r\nNULL, false);\r\n}\r\n}\r\n}\r\n}\r\n#endif\r\nreturn _FAIL;\r\n}\r\nstatic int validate_recv_mgnt_frame(struct rtw_adapter *padapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\nstruct sta_info *psta;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_hdr *hdr;\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_info_,\r\n"+validate_recv_mgnt_frame\n");\r\nprecv_frame = recvframe_chk_defrag23a(padapter, precv_frame);\r\nif (precv_frame == NULL) {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_notice_,\r\n"%s: fragment packet\n", __func__);\r\nreturn _SUCCESS;\r\n}\r\nskb = precv_frame->pkt;\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\npsta = rtw_get_stainfo23a(&padapter->stapriv, hdr->addr2);\r\nif (psta) {\r\npsta->sta_stats.rx_mgnt_pkts++;\r\nif (ieee80211_is_beacon(hdr->frame_control))\r\npsta->sta_stats.rx_beacon_pkts++;\r\nelse if (ieee80211_is_probe_req(hdr->frame_control))\r\npsta->sta_stats.rx_probereq_pkts++;\r\nelse if (ieee80211_is_probe_resp(hdr->frame_control)) {\r\nif (ether_addr_equal(padapter->eeprompriv.mac_addr,\r\nhdr->addr1))\r\npsta->sta_stats.rx_probersp_pkts++;\r\nelse if (is_broadcast_ether_addr(hdr->addr1) ||\r\nis_multicast_ether_addr(hdr->addr1))\r\npsta->sta_stats.rx_probersp_bm_pkts++;\r\nelse\r\npsta->sta_stats.rx_probersp_uo_pkts++;\r\n}\r\n}\r\nmgt_dispatcher23a(padapter, precv_frame);\r\nreturn _SUCCESS;\r\n}\r\nstatic int validate_recv_data_frame(struct rtw_adapter *adapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\nu8 bretry;\r\nu8 *psa, *pda;\r\nstruct sta_info *psta = NULL;\r\nstruct rx_pkt_attrib *pattrib = & precv_frame->attrib;\r\nstruct security_priv *psecuritypriv = &adapter->securitypriv;\r\nint ret = _SUCCESS;\r\nstruct sk_buff *skb = precv_frame->pkt;\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nbretry = ieee80211_has_retry(hdr->frame_control);\r\npda = ieee80211_get_DA(hdr);\r\npsa = ieee80211_get_SA(hdr);\r\nether_addr_copy(pattrib->dst, pda);\r\nether_addr_copy(pattrib->src, psa);\r\nswitch (hdr->frame_control &\r\ncpu_to_le16(IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) {\r\ncase cpu_to_le16(0):\r\nether_addr_copy(pattrib->bssid, hdr->addr3);\r\nether_addr_copy(pattrib->ra, pda);\r\nether_addr_copy(pattrib->ta, psa);\r\nret = sta2sta_data_frame(adapter, precv_frame, &psta);\r\nbreak;\r\ncase cpu_to_le16(IEEE80211_FCTL_FROMDS):\r\nether_addr_copy(pattrib->bssid, hdr->addr2);\r\nether_addr_copy(pattrib->ra, pda);\r\nether_addr_copy(pattrib->ta, hdr->addr2);\r\nret = ap2sta_data_frame(adapter, precv_frame, &psta);\r\nbreak;\r\ncase cpu_to_le16(IEEE80211_FCTL_TODS):\r\nether_addr_copy(pattrib->bssid, hdr->addr1);\r\nether_addr_copy(pattrib->ra, hdr->addr1);\r\nether_addr_copy(pattrib->ta, psa);\r\nret = sta2ap_data_frame(adapter, precv_frame, &psta);\r\nbreak;\r\ncase cpu_to_le16(IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS):\r\nether_addr_copy(pattrib->bssid, hdr->addr1);\r\nether_addr_copy(pattrib->ra, hdr->addr1);\r\nether_addr_copy(pattrib->ta, hdr->addr2);\r\nret = _FAIL;\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_, "case 3\n");\r\nbreak;\r\n}\r\nif ((ret == _FAIL) || (ret == RTW_RX_HANDLED))\r\ngoto exit;\r\nif (!psta) {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n"after to_fr_ds_chk; psta == NULL\n");\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\nprecv_frame->psta = psta;\r\npattrib->hdrlen = sizeof(struct ieee80211_hdr_3addr);\r\nif (ieee80211_has_a4(hdr->frame_control))\r\npattrib->hdrlen += ETH_ALEN;\r\nif (pattrib->qos == 1) {\r\n__le16 *qptr = (__le16 *)ieee80211_get_qos_ctl(hdr);\r\nu16 qos_ctrl = le16_to_cpu(*qptr);\r\npattrib->priority = qos_ctrl & IEEE80211_QOS_CTL_TID_MASK;\r\npattrib->ack_policy = (qos_ctrl >> 5) & 3;\r\npattrib->amsdu =\r\n(qos_ctrl & IEEE80211_QOS_CTL_A_MSDU_PRESENT) >> 7;\r\npattrib->hdrlen += IEEE80211_QOS_CTL_LEN;\r\nif (pattrib->priority != 0 && pattrib->priority != 3) {\r\nadapter->recvpriv.bIsAnyNonBEPkts = true;\r\n}\r\n} else {\r\npattrib->priority = 0;\r\npattrib->ack_policy = 0;\r\npattrib->amsdu = 0;\r\n}\r\nif (pattrib->order) {\r\npattrib->hdrlen += 4;\r\n}\r\nprecv_frame->preorder_ctrl = &psta->recvreorder_ctrl[pattrib->priority];\r\nif (recv_decache(precv_frame, bretry, &psta->sta_recvpriv.rxcache) ==\r\n_FAIL) {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n"decache : drop pkt\n");\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\nif (pattrib->privacy) {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_info_,\r\n"validate_recv_data_frame:pattrib->privacy =%x\n",\r\npattrib->privacy);\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_info_,\r\n"^^^^^^^^^^^is_multicast_ether_addr(pattrib->ra(0x%02x)) =%d^^^^^^^^^^^^^^^6\n",\r\npattrib->ra[0],\r\nis_multicast_ether_addr(pattrib->ra));\r\nGET_ENCRY_ALGO(psecuritypriv, psta, pattrib->encrypt,\r\nis_multicast_ether_addr(pattrib->ra));\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_info_,\r\n"pattrib->encrypt =%d\n", pattrib->encrypt);\r\nswitch (pattrib->encrypt) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\npattrib->iv_len = IEEE80211_WEP_IV_LEN;\r\npattrib->icv_len = IEEE80211_WEP_ICV_LEN;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\npattrib->iv_len = IEEE80211_TKIP_IV_LEN;\r\npattrib->icv_len = IEEE80211_TKIP_ICV_LEN;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\npattrib->iv_len = IEEE80211_CCMP_HDR_LEN;\r\npattrib->icv_len = IEEE80211_CCMP_MIC_LEN;\r\nbreak;\r\ndefault:\r\npattrib->iv_len = 0;\r\npattrib->icv_len = 0;\r\nbreak;\r\n}\r\n} else {\r\npattrib->encrypt = 0;\r\npattrib->iv_len = 0;\r\npattrib->icv_len = 0;\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nstatic void dump_rx_pkt(struct sk_buff *skb, u16 type, int level)\r\n{\r\nint i;\r\nu8 *ptr;\r\nif ((level == 1) ||\r\n((level == 2) && (type == IEEE80211_FTYPE_MGMT)) ||\r\n((level == 3) && (type == IEEE80211_FTYPE_DATA))) {\r\nptr = skb->data;\r\nDBG_8723A("#############################\n");\r\nfor (i = 0; i < 64; i = i + 8)\r\nDBG_8723A("%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:\n",\r\n*(ptr + i), *(ptr + i + 1), *(ptr + i + 2),\r\n*(ptr + i + 3), *(ptr + i + 4),\r\n*(ptr + i + 5), *(ptr + i + 6),\r\n*(ptr + i + 7));\r\nDBG_8723A("#############################\n");\r\n}\r\n}\r\nstatic int validate_recv_frame(struct rtw_adapter *adapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\nu8 type;\r\nu8 subtype;\r\nint retval = _SUCCESS;\r\nstruct rx_pkt_attrib *pattrib = & precv_frame->attrib;\r\nstruct sk_buff *skb = precv_frame->pkt;\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nu8 ver;\r\nu8 bDumpRxPkt;\r\nu16 seq_ctrl, fctl;\r\nfctl = le16_to_cpu(hdr->frame_control);\r\nver = fctl & IEEE80211_FCTL_VERS;\r\ntype = fctl & IEEE80211_FCTL_FTYPE;\r\nsubtype = fctl & IEEE80211_FCTL_STYPE;\r\nif (ver != 0) {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n"validate_recv_data_frame fail! (ver!= 0)\n");\r\nretval = _FAIL;\r\ngoto exit;\r\n}\r\nseq_ctrl = le16_to_cpu(hdr->seq_ctrl);\r\npattrib->frag_num = seq_ctrl & IEEE80211_SCTL_FRAG;\r\npattrib->seq_num = seq_ctrl >> 4;\r\npattrib->pw_save = ieee80211_has_pm(hdr->frame_control);\r\npattrib->mfrag = ieee80211_has_morefrags(hdr->frame_control);\r\npattrib->mdata = ieee80211_has_moredata(hdr->frame_control);\r\npattrib->privacy = ieee80211_has_protected(hdr->frame_control);\r\npattrib->order = ieee80211_has_order(hdr->frame_control);\r\nGetHalDefVar8192CUsb(adapter, HAL_DEF_DBG_DUMP_RXPKT, &bDumpRxPkt);\r\nif (unlikely(bDumpRxPkt == 1))\r\ndump_rx_pkt(skb, type, bDumpRxPkt);\r\nswitch (type) {\r\ncase IEEE80211_FTYPE_MGMT:\r\nretval = validate_recv_mgnt_frame(adapter, precv_frame);\r\nif (retval == _FAIL) {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n"validate_recv_mgnt_frame fail\n");\r\n}\r\nretval = _FAIL;\r\nbreak;\r\ncase IEEE80211_FTYPE_CTL:\r\nretval = validate_recv_ctrl_frame(adapter, precv_frame);\r\nif (retval == _FAIL) {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n"validate_recv_ctrl_frame fail\n");\r\n}\r\nretval = _FAIL;\r\nbreak;\r\ncase IEEE80211_FTYPE_DATA:\r\npattrib->qos = (subtype & IEEE80211_STYPE_QOS_DATA) ? 1 : 0;\r\nretval = validate_recv_data_frame(adapter, precv_frame);\r\nif (retval == _FAIL) {\r\nstruct recv_priv *precvpriv = &adapter->recvpriv;\r\nprecvpriv->rx_drop++;\r\n}\r\nbreak;\r\ndefault:\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n"validate_recv_data_frame fail! type = 0x%x\n", type);\r\nretval = _FAIL;\r\nbreak;\r\n}\r\nexit:\r\nreturn retval;\r\n}\r\nstatic int wlanhdr_to_ethhdr (struct recv_frame *precvframe)\r\n{\r\nu16 eth_type, len, hdrlen;\r\nu8 bsnaphdr;\r\nu8 *psnap;\r\nstruct rtw_adapter *adapter = precvframe->adapter;\r\nstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\r\nstruct sk_buff *skb = precvframe->pkt;\r\nu8 *ptr;\r\nstruct rx_pkt_attrib *pattrib = &precvframe->attrib;\r\nptr = skb->data;\r\nhdrlen = pattrib->hdrlen;\r\npsnap = ptr + hdrlen;\r\neth_type = (psnap[6] << 8) | psnap[7];\r\nif ((ether_addr_equal(psnap, rfc1042_header) &&\r\neth_type != ETH_P_AARP && eth_type != ETH_P_IPX) ||\r\nether_addr_equal(psnap, bridge_tunnel_header)) {\r\nbsnaphdr = true;\r\nhdrlen += SNAP_SIZE;\r\n} else {\r\nbsnaphdr = false;\r\neth_type = (psnap[0] << 8) | psnap[1];\r\n}\r\nlen = skb->len - hdrlen;\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_info_,\r\n"=== pattrib->hdrlen: %x, pattrib->iv_len:%x ===\n",\r\npattrib->hdrlen, pattrib->iv_len);\r\npattrib->eth_type = eth_type;\r\nif (check_fwstate(pmlmepriv, WIFI_MP_STATE)) {\r\nptr += hdrlen;\r\n*ptr = 0x87;\r\n*(ptr + 1) = 0x12;\r\neth_type = 0x8712;\r\nptr = skb_pull(skb, (hdrlen - sizeof(struct ethhdr) + 2) - 24);\r\nmemcpy(ptr, skb->head, 24);\r\nptr += 24;\r\n} else {\r\nptr = skb_pull(skb, (hdrlen - sizeof(struct ethhdr) +\r\n(bsnaphdr ? 2:0)));\r\n}\r\nether_addr_copy(ptr, pattrib->dst);\r\nether_addr_copy(ptr + ETH_ALEN, pattrib->src);\r\nif (!bsnaphdr) {\r\nlen = htons(len);\r\nmemcpy(ptr + 12, &len, 2);\r\n}\r\nreturn _SUCCESS;\r\n}\r\nstruct recv_frame *recvframe_defrag(struct rtw_adapter *adapter,\r\nstruct rtw_queue *defrag_q)\r\n{\r\nstruct list_head *plist, *phead, *ptmp;\r\nu8 *data, wlanhdr_offset;\r\nu8 curfragnum;\r\nstruct recv_frame *pnfhdr;\r\nstruct recv_frame *prframe, *pnextrframe;\r\nstruct rtw_queue *pfree_recv_queue;\r\nstruct sk_buff *skb;\r\ncurfragnum = 0;\r\npfree_recv_queue = &adapter->recvpriv.free_recv_queue;\r\nphead = get_list_head(defrag_q);\r\nplist = phead->next;\r\nprframe = container_of(plist, struct recv_frame, list);\r\nlist_del_init(&prframe->list);\r\nskb = prframe->pkt;\r\nif (curfragnum != prframe->attrib.frag_num) {\r\nrtw_free_recvframe23a(prframe);\r\nrtw_free_recvframe23a_queue(defrag_q);\r\nreturn NULL;\r\n}\r\ncurfragnum++;\r\nphead = get_list_head(defrag_q);\r\ndata = prframe->pkt->data;\r\nlist_for_each_safe(plist, ptmp, phead) {\r\npnfhdr = container_of(plist, struct recv_frame, list);\r\npnextrframe = (struct recv_frame *)pnfhdr;\r\nif (curfragnum != pnfhdr->attrib.frag_num) {\r\nrtw_free_recvframe23a(prframe);\r\nrtw_free_recvframe23a_queue(defrag_q);\r\nreturn NULL;\r\n}\r\ncurfragnum++;\r\nwlanhdr_offset = pnfhdr->attrib.hdrlen + pnfhdr->attrib.iv_len;\r\nskb_pull(pnfhdr->pkt, wlanhdr_offset);\r\nskb_trim(skb, skb->len - prframe->attrib.icv_len);\r\nmemcpy(skb_tail_pointer(skb), pnfhdr->pkt->data,\r\npnfhdr->pkt->len);\r\nskb_put(skb, pnfhdr->pkt->len);\r\nprframe->attrib.icv_len = pnfhdr->attrib.icv_len;\r\n}\r\nrtw_free_recvframe23a_queue(defrag_q);\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_info_,\r\n"Performance defrag!!!!!\n");\r\nreturn prframe;\r\n}\r\nstruct recv_frame *recvframe_chk_defrag23a(struct rtw_adapter *padapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\nu8 ismfrag;\r\nu8 fragnum;\r\nu8 *psta_addr;\r\nstruct recv_frame *pfhdr;\r\nstruct sta_info *psta;\r\nstruct sta_priv *pstapriv;\r\nstruct list_head *phead;\r\nstruct recv_frame *prtnframe = NULL;\r\nstruct rtw_queue *pfree_recv_queue, *pdefrag_q;\r\npstapriv = &padapter->stapriv;\r\npfhdr = precv_frame;\r\npfree_recv_queue = &padapter->recvpriv.free_recv_queue;\r\nismfrag = pfhdr->attrib.mfrag;\r\nfragnum = pfhdr->attrib.frag_num;\r\npsta_addr = pfhdr->attrib.ta;\r\npsta = rtw_get_stainfo23a(pstapriv, psta_addr);\r\nif (!psta) {\r\nstruct ieee80211_hdr *hdr =\r\n(struct ieee80211_hdr *) pfhdr->pkt->data;\r\nif (!ieee80211_is_data(hdr->frame_control)) {\r\npsta = rtw_get_bcmc_stainfo23a(padapter);\r\npdefrag_q = &psta->sta_recvpriv.defrag_q;\r\n} else\r\npdefrag_q = NULL;\r\n} else\r\npdefrag_q = &psta->sta_recvpriv.defrag_q;\r\nif ((ismfrag == 0) && (fragnum == 0)) {\r\nprtnframe = precv_frame;\r\n}\r\nif (ismfrag == 1) {\r\nif (pdefrag_q != NULL) {\r\nif (fragnum == 0) {\r\nif (!list_empty(&pdefrag_q->queue)) {\r\nrtw_free_recvframe23a_queue(pdefrag_q);\r\n}\r\n}\r\nphead = get_list_head(pdefrag_q);\r\nlist_add_tail(&pfhdr->list, phead);\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_info_,\r\n"Enqueuq: ismfrag = %d, fragnum = %d\n",\r\nismfrag, fragnum);\r\nprtnframe = NULL;\r\n} else {\r\nrtw_free_recvframe23a(precv_frame);\r\nprtnframe = NULL;\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n"Free because pdefrag_q == NULL: ismfrag = %d, fragnum = %d\n",\r\nismfrag, fragnum);\r\n}\r\n}\r\nif ((ismfrag == 0) && (fragnum != 0)) {\r\nif (pdefrag_q != NULL) {\r\nphead = get_list_head(pdefrag_q);\r\nlist_add_tail(&pfhdr->list, phead);\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_info_,\r\n"defrag: ismfrag = %d, fragnum = %d\n",\r\nismfrag, fragnum);\r\nprecv_frame = recvframe_defrag(padapter, pdefrag_q);\r\nprtnframe = precv_frame;\r\n} else {\r\nrtw_free_recvframe23a(precv_frame);\r\nprtnframe = NULL;\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n"Free because pdefrag_q == NULL: ismfrag = %d, fragnum = %d\n",\r\nismfrag, fragnum);\r\n}\r\n}\r\nif ((prtnframe != NULL) && (prtnframe->attrib.privacy)) {\r\nif (recvframe_chkmic(padapter, prtnframe) == _FAIL) {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n"recvframe_chkmic(padapter, prtnframe) ==_FAIL\n");\r\nrtw_free_recvframe23a(prtnframe);\r\nprtnframe = NULL;\r\n}\r\n}\r\nreturn prtnframe;\r\n}\r\nint amsdu_to_msdu(struct rtw_adapter *padapter, struct recv_frame *prframe)\r\n{\r\nstruct rx_pkt_attrib *pattrib;\r\nstruct sk_buff *skb, *sub_skb;\r\nstruct sk_buff_head skb_list;\r\npattrib = &prframe->attrib;\r\nskb = prframe->pkt;\r\nskb_pull(skb, prframe->attrib.hdrlen);\r\n__skb_queue_head_init(&skb_list);\r\nieee80211_amsdu_to_8023s(skb, &skb_list, NULL, 0, 0, false);\r\nwhile (!skb_queue_empty(&skb_list)) {\r\nsub_skb = __skb_dequeue(&skb_list);\r\nsub_skb->protocol = eth_type_trans(sub_skb, padapter->pnetdev);\r\nsub_skb->dev = padapter->pnetdev;\r\nsub_skb->ip_summed = CHECKSUM_NONE;\r\nnetif_rx(sub_skb);\r\n}\r\nprframe->pkt = NULL;\r\nrtw_free_recvframe23a(prframe);\r\nreturn _SUCCESS;\r\n}\r\nint check_indicate_seq(struct recv_reorder_ctrl *preorder_ctrl, u16 seq_num)\r\n{\r\nu8 wsize = preorder_ctrl->wsize_b;\r\nu16 wend = (preorder_ctrl->indicate_seq + wsize -1) & 0xFFF;\r\nif (preorder_ctrl->indicate_seq == 0xFFFF)\r\npreorder_ctrl->indicate_seq = seq_num;\r\nif (SN_LESS(seq_num, preorder_ctrl->indicate_seq))\r\nreturn false;\r\nif (SN_EQUAL(seq_num, preorder_ctrl->indicate_seq)) {\r\npreorder_ctrl->indicate_seq =\r\n(preorder_ctrl->indicate_seq + 1) & 0xFFF;\r\n} else if (SN_LESS(wend, seq_num)) {\r\nif (seq_num >= (wsize - 1))\r\npreorder_ctrl->indicate_seq = seq_num + 1 -wsize;\r\nelse\r\npreorder_ctrl->indicate_seq = 0xFFF - (wsize - (seq_num + 1)) + 1;\r\n}\r\nreturn true;\r\n}\r\nstatic int enqueue_reorder_recvframe23a(struct recv_reorder_ctrl *preorder_ctrl,\r\nstruct recv_frame *prframe)\r\n{\r\nstruct rx_pkt_attrib *pattrib = &prframe->attrib;\r\nstruct rtw_queue *ppending_recvframe_queue;\r\nstruct list_head *phead, *plist, *ptmp;\r\nstruct recv_frame *hdr;\r\nstruct rx_pkt_attrib *pnextattrib;\r\nppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;\r\nphead = get_list_head(ppending_recvframe_queue);\r\nlist_for_each_safe(plist, ptmp, phead) {\r\nhdr = container_of(plist, struct recv_frame, list);\r\npnextattrib = &hdr->attrib;\r\nif (SN_LESS(pnextattrib->seq_num, pattrib->seq_num)) {\r\ncontinue;\r\n} else if (SN_EQUAL(pnextattrib->seq_num, pattrib->seq_num)) {\r\nreturn false;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nlist_del_init(&prframe->list);\r\nlist_add_tail(&prframe->list, plist);\r\nreturn true;\r\n}\r\nint recv_indicatepkts_in_order(struct rtw_adapter *padapter,\r\nstruct recv_reorder_ctrl *preorder_ctrl,\r\nint bforced)\r\n{\r\nstruct list_head *phead, *plist;\r\nstruct recv_frame *prframe;\r\nstruct rx_pkt_attrib *pattrib;\r\nint bPktInBuf = false;\r\nstruct recv_priv *precvpriv;\r\nstruct rtw_queue *ppending_recvframe_queue;\r\nprecvpriv = &padapter->recvpriv;\r\nppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;\r\nphead = get_list_head(ppending_recvframe_queue);\r\nplist = phead->next;\r\nif (bforced) {\r\nif (list_empty(phead)) {\r\nreturn true;\r\n}\r\nprframe = container_of(plist, struct recv_frame, list);\r\npattrib = &prframe->attrib;\r\npreorder_ctrl->indicate_seq = pattrib->seq_num;\r\n}\r\nwhile (!list_empty(phead)) {\r\nprframe = container_of(plist, struct recv_frame, list);\r\npattrib = &prframe->attrib;\r\nif (!SN_LESS(preorder_ctrl->indicate_seq, pattrib->seq_num)) {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_notice_,\r\n"recv_indicatepkts_in_order: indicate =%d seq =%d amsdu =%d\n",\r\npreorder_ctrl->indicate_seq,\r\npattrib->seq_num, pattrib->amsdu);\r\nplist = plist->next;\r\nlist_del_init(&prframe->list);\r\nif (SN_EQUAL(preorder_ctrl->indicate_seq,\r\npattrib->seq_num)) {\r\npreorder_ctrl->indicate_seq =\r\n(preorder_ctrl->indicate_seq + 1)&0xFFF;\r\n}\r\nif (!pattrib->amsdu) {\r\nif ((padapter->bDriverStopped == false) &&\r\n(padapter->bSurpriseRemoved == false)) {\r\nrtw_recv_indicatepkt23a(padapter, prframe);\r\n}\r\n} else {\r\nif (amsdu_to_msdu(padapter, prframe) !=\r\n_SUCCESS)\r\nrtw_free_recvframe23a(prframe);\r\n}\r\nbPktInBuf = false;\r\n} else {\r\nbPktInBuf = true;\r\nbreak;\r\n}\r\n}\r\nreturn bPktInBuf;\r\n}\r\nint recv_indicatepkt_reorder(struct rtw_adapter *padapter,\r\nstruct recv_frame *prframe)\r\n{\r\nint retval = _SUCCESS;\r\nstruct rx_pkt_attrib *pattrib;\r\nstruct recv_reorder_ctrl *preorder_ctrl;\r\nstruct rtw_queue *ppending_recvframe_queue;\r\npattrib = &prframe->attrib;\r\npreorder_ctrl = prframe->preorder_ctrl;\r\nppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;\r\nif (!pattrib->amsdu) {\r\nwlanhdr_to_ethhdr(prframe);\r\nif ((pattrib->qos!= 1) || (pattrib->eth_type == ETH_P_ARP) ||\r\n(pattrib->ack_policy != 0)) {\r\nif ((padapter->bDriverStopped == false) &&\r\n(padapter->bSurpriseRemoved == false)) {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_notice_,\r\n"@@@@ recv_indicatepkt_reorder -recv_func recv_indicatepkt\n");\r\nrtw_recv_indicatepkt23a(padapter, prframe);\r\nreturn _SUCCESS;\r\n}\r\nreturn _FAIL;\r\n}\r\nif (preorder_ctrl->enable == false) {\r\npreorder_ctrl->indicate_seq = pattrib->seq_num;\r\nrtw_recv_indicatepkt23a(padapter, prframe);\r\npreorder_ctrl->indicate_seq =\r\n(preorder_ctrl->indicate_seq + 1) % 4096;\r\nreturn _SUCCESS;\r\n}\r\n} else {\r\nif (preorder_ctrl->enable == false) {\r\npreorder_ctrl->indicate_seq = pattrib->seq_num;\r\nretval = amsdu_to_msdu(padapter, prframe);\r\npreorder_ctrl->indicate_seq =\r\n(preorder_ctrl->indicate_seq + 1) % 4096;\r\nreturn retval;\r\n}\r\n}\r\nspin_lock_bh(&ppending_recvframe_queue->lock);\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_notice_,\r\n"recv_indicatepkt_reorder: indicate =%d seq =%d\n",\r\npreorder_ctrl->indicate_seq, pattrib->seq_num);\r\nif (!check_indicate_seq(preorder_ctrl, pattrib->seq_num)) {\r\ngoto _err_exit;\r\n}\r\nif (!enqueue_reorder_recvframe23a(preorder_ctrl, prframe)) {\r\ngoto _err_exit;\r\n}\r\nif (recv_indicatepkts_in_order(padapter, preorder_ctrl, false) == true) {\r\nmod_timer(&preorder_ctrl->reordering_ctrl_timer,\r\njiffies + msecs_to_jiffies(REORDER_WAIT_TIME));\r\nspin_unlock_bh(&ppending_recvframe_queue->lock);\r\n} else {\r\nspin_unlock_bh(&ppending_recvframe_queue->lock);\r\ndel_timer_sync(&preorder_ctrl->reordering_ctrl_timer);\r\n}\r\nreturn _SUCCESS;\r\n_err_exit:\r\nspin_unlock_bh(&ppending_recvframe_queue->lock);\r\nreturn _FAIL;\r\n}\r\nvoid rtw_reordering_ctrl_timeout_handler23a(unsigned long pcontext)\r\n{\r\nstruct recv_reorder_ctrl *preorder_ctrl;\r\nstruct rtw_adapter *padapter;\r\nstruct rtw_queue *ppending_recvframe_queue;\r\npreorder_ctrl = (struct recv_reorder_ctrl *)pcontext;\r\npadapter = preorder_ctrl->padapter;\r\nppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;\r\nif (padapter->bDriverStopped || padapter->bSurpriseRemoved) {\r\nreturn;\r\n}\r\nspin_lock_bh(&ppending_recvframe_queue->lock);\r\nif (recv_indicatepkts_in_order(padapter, preorder_ctrl, true) == true) {\r\nmod_timer(&preorder_ctrl->reordering_ctrl_timer,\r\njiffies + msecs_to_jiffies(REORDER_WAIT_TIME));\r\n}\r\nspin_unlock_bh(&ppending_recvframe_queue->lock);\r\n}\r\nint process_recv_indicatepkts(struct rtw_adapter *padapter,\r\nstruct recv_frame *prframe)\r\n{\r\nint retval = _SUCCESS;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct ht_priv *phtpriv = &pmlmepriv->htpriv;\r\nif (phtpriv->ht_option == true) {\r\nif (recv_indicatepkt_reorder(padapter, prframe) != _SUCCESS) {\r\nif ((padapter->bDriverStopped == false) &&\r\n(padapter->bSurpriseRemoved == false)) {\r\nretval = _FAIL;\r\nreturn retval;\r\n}\r\n}\r\n} else {\r\nretval = wlanhdr_to_ethhdr(prframe);\r\nif (retval != _SUCCESS) {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n"wlanhdr_to_ethhdr: drop pkt\n");\r\nreturn retval;\r\n}\r\nif ((padapter->bDriverStopped == false) &&\r\n(padapter->bSurpriseRemoved == false)) {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_notice_,\r\n"@@@@ process_recv_indicatepkts- recv_func recv_indicatepkt\n");\r\nrtw_recv_indicatepkt23a(padapter, prframe);\r\n} else {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_notice_,\r\n"@@@@ process_recv_indicatepkts- recv_func free_indicatepkt\n");\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_notice_,\r\n"recv_func:bDriverStopped(%d) OR bSurpriseRemoved(%d)\n",\r\npadapter->bDriverStopped,\r\npadapter->bSurpriseRemoved);\r\nretval = _FAIL;\r\nreturn retval;\r\n}\r\n}\r\nreturn retval;\r\n}\r\nstatic int recv_func_prehandle(struct rtw_adapter *padapter,\r\nstruct recv_frame *rframe)\r\n{\r\nint ret = _SUCCESS;\r\nret = validate_recv_frame(padapter, rframe);\r\nif (ret != _SUCCESS) {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_info_,\r\n"recv_func: validate_recv_frame fail! drop pkt\n");\r\nrtw_free_recvframe23a(rframe);\r\ngoto exit;\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int recv_func_posthandle(struct rtw_adapter *padapter,\r\nstruct recv_frame *prframe)\r\n{\r\nint ret = _SUCCESS;\r\nstruct recv_frame *orig_prframe = prframe;\r\nstruct recv_priv *precvpriv = &padapter->recvpriv;\r\nprframe = decryptor(padapter, prframe);\r\nif (prframe == NULL) {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n"decryptor: drop pkt\n");\r\nret = _FAIL;\r\ngoto _recv_data_drop;\r\n}\r\nprframe = recvframe_chk_defrag23a(padapter, prframe);\r\nif (!prframe) {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n"recvframe_chk_defrag23a: drop pkt\n");\r\ngoto _recv_data_drop;\r\n}\r\nif (prframe->attrib.iv_len > 0) {\r\nskb_pull(prframe->pkt, prframe->attrib.iv_len);\r\n}\r\nif (prframe->attrib.icv_len > 0) {\r\nskb_trim(prframe->pkt,\r\nprframe->pkt->len - prframe->attrib.icv_len);\r\n}\r\nprframe = portctrl(padapter, prframe);\r\nif (!prframe) {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n"portctrl: drop pkt\n");\r\nret = _FAIL;\r\ngoto _recv_data_drop;\r\n}\r\ncount_rx_stats(padapter, prframe, NULL);\r\nret = process_recv_indicatepkts(padapter, prframe);\r\nif (ret != _SUCCESS) {\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n"recv_func: process_recv_indicatepkts fail!\n");\r\nrtw_free_recvframe23a(orig_prframe);\r\ngoto _recv_data_drop;\r\n}\r\nreturn ret;\r\n_recv_data_drop:\r\nprecvpriv->rx_drop++;\r\nreturn ret;\r\n}\r\nint rtw_recv_entry23a(struct recv_frame *rframe)\r\n{\r\nint ret, r;\r\nstruct rtw_adapter *padapter = rframe->adapter;\r\nstruct rx_pkt_attrib *prxattrib = &rframe->attrib;\r\nstruct recv_priv *recvpriv = &padapter->recvpriv;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct mlme_priv *mlmepriv = &padapter->mlmepriv;\r\nif (check_fwstate(mlmepriv, WIFI_STATION_STATE) &&\r\npsecuritypriv->busetkipkey) {\r\nstruct recv_frame *pending_frame;\r\nwhile ((pending_frame = rtw_alloc_recvframe23a(&padapter->recvpriv.uc_swdec_pending_queue))) {\r\nr = recv_func_posthandle(padapter, pending_frame);\r\nif (r == _SUCCESS)\r\nDBG_8723A("%s: dequeue uc_swdec_pending_queue\n", __func__);\r\n}\r\n}\r\nret = recv_func_prehandle(padapter, rframe);\r\nif (ret == _SUCCESS) {\r\nif (check_fwstate(mlmepriv, WIFI_STATION_STATE) &&\r\n!is_multicast_ether_addr(prxattrib->ra) &&\r\nprxattrib->encrypt > 0 &&\r\n(prxattrib->bdecrypted == 0) &&\r\n!is_wep_enc(psecuritypriv->dot11PrivacyAlgrthm) &&\r\n!psecuritypriv->busetkipkey) {\r\nrtw_enqueue_recvframe23a(rframe, &padapter->recvpriv.uc_swdec_pending_queue);\r\nDBG_8723A("%s: no key, enqueue uc_swdec_pending_queue\n", __func__);\r\ngoto exit;\r\n}\r\nret = recv_func_posthandle(padapter, rframe);\r\nrecvpriv->rx_pkts++;\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nvoid rtw_signal_stat_timer_hdl23a(unsigned long data)\r\n{\r\nstruct rtw_adapter *adapter = (struct rtw_adapter *)data;\r\nstruct recv_priv *recvpriv = &adapter->recvpriv;\r\nu32 tmp_s, tmp_q;\r\nu8 avg_signal_strength = 0;\r\nu8 avg_signal_qual = 0;\r\nu32 num_signal_strength = 0;\r\nu32 num_signal_qual = 0;\r\nu8 _alpha = 3;\r\nif (recvpriv->signal_strength_data.update_req == 0) {\r\navg_signal_strength = recvpriv->signal_strength_data.avg_val;\r\nnum_signal_strength = recvpriv->signal_strength_data.total_num;\r\nrecvpriv->signal_strength_data.update_req = 1;\r\n}\r\nif (recvpriv->signal_qual_data.update_req == 0) {\r\navg_signal_qual = recvpriv->signal_qual_data.avg_val;\r\nnum_signal_qual = recvpriv->signal_qual_data.total_num;\r\nrecvpriv->signal_qual_data.update_req = 1;\r\n}\r\nif (!check_fwstate(&adapter->mlmepriv, _FW_UNDER_SURVEY)) {\r\ntmp_s = avg_signal_strength + (_alpha - 1) *\r\nrecvpriv->signal_strength;\r\nif (tmp_s %_alpha)\r\ntmp_s = tmp_s / _alpha + 1;\r\nelse\r\ntmp_s = tmp_s / _alpha;\r\nif (tmp_s > 100)\r\ntmp_s = 100;\r\ntmp_q = avg_signal_qual + (_alpha - 1) * recvpriv->signal_qual;\r\nif (tmp_q %_alpha)\r\ntmp_q = tmp_q / _alpha + 1;\r\nelse\r\ntmp_q = tmp_q / _alpha;\r\nif (tmp_q > 100)\r\ntmp_q = 100;\r\nrecvpriv->signal_strength = tmp_s;\r\nrecvpriv->signal_qual = tmp_q;\r\nDBG_8723A("%s signal_strength:%3u, signal_qual:%3u, "\r\n"num_signal_strength:%u, num_signal_qual:%u\n",\r\n__func__, recvpriv->signal_strength,\r\nrecvpriv->signal_qual, num_signal_strength,\r\nnum_signal_qual);\r\n}\r\nrtw_set_signal_stat_timer(recvpriv);\r\n}
