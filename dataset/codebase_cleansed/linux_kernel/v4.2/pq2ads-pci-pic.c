static void pq2ads_pci_mask_irq(struct irq_data *d)\r\n{\r\nstruct pq2ads_pci_pic *priv = irq_data_get_irq_chip_data(d);\r\nint irq = NUM_IRQS - irqd_to_hwirq(d) - 1;\r\nif (irq != -1) {\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&pci_pic_lock, flags);\r\nsetbits32(&priv->regs->mask, 1 << irq);\r\nmb();\r\nraw_spin_unlock_irqrestore(&pci_pic_lock, flags);\r\n}\r\n}\r\nstatic void pq2ads_pci_unmask_irq(struct irq_data *d)\r\n{\r\nstruct pq2ads_pci_pic *priv = irq_data_get_irq_chip_data(d);\r\nint irq = NUM_IRQS - irqd_to_hwirq(d) - 1;\r\nif (irq != -1) {\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&pci_pic_lock, flags);\r\nclrbits32(&priv->regs->mask, 1 << irq);\r\nraw_spin_unlock_irqrestore(&pci_pic_lock, flags);\r\n}\r\n}\r\nstatic void pq2ads_pci_irq_demux(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct pq2ads_pci_pic *priv = irq_desc_get_handler_data(desc);\r\nu32 stat, mask, pend;\r\nint bit;\r\nfor (;;) {\r\nstat = in_be32(&priv->regs->stat);\r\nmask = in_be32(&priv->regs->mask);\r\npend = stat & ~mask;\r\nif (!pend)\r\nbreak;\r\nfor (bit = 0; pend != 0; ++bit, pend <<= 1) {\r\nif (pend & 0x80000000) {\r\nint virq = irq_linear_revmap(priv->host, bit);\r\ngeneric_handle_irq(virq);\r\n}\r\n}\r\n}\r\n}\r\nstatic int pci_pic_host_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nirq_set_status_flags(virq, IRQ_LEVEL);\r\nirq_set_chip_data(virq, h->host_data);\r\nirq_set_chip_and_handler(virq, &pq2ads_pci_ic, handle_level_irq);\r\nreturn 0;\r\n}\r\nint __init pq2ads_pci_init_irq(void)\r\n{\r\nstruct pq2ads_pci_pic *priv;\r\nstruct irq_domain *host;\r\nstruct device_node *np;\r\nint ret = -ENODEV;\r\nint irq;\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,pq2ads-pci-pic");\r\nif (!np) {\r\nprintk(KERN_ERR "No pci pic node in device tree.\n");\r\nof_node_put(np);\r\ngoto out;\r\n}\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (irq == NO_IRQ) {\r\nprintk(KERN_ERR "No interrupt in pci pic node.\n");\r\nof_node_put(np);\r\ngoto out;\r\n}\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\nof_node_put(np);\r\nret = -ENOMEM;\r\ngoto out_unmap_irq;\r\n}\r\npriv->regs = of_iomap(np, 0);\r\nif (!priv->regs) {\r\nprintk(KERN_ERR "Cannot map PCI PIC registers.\n");\r\ngoto out_free_kmalloc;\r\n}\r\nout_be32(&priv->regs->mask, ~0);\r\nmb();\r\nhost = irq_domain_add_linear(np, NUM_IRQS, &pci_pic_host_ops, priv);\r\nif (!host) {\r\nret = -ENOMEM;\r\ngoto out_unmap_regs;\r\n}\r\npriv->host = host;\r\nirq_set_handler_data(irq, priv);\r\nirq_set_chained_handler(irq, pq2ads_pci_irq_demux);\r\nof_node_put(np);\r\nreturn 0;\r\nout_unmap_regs:\r\niounmap(priv->regs);\r\nout_free_kmalloc:\r\nkfree(priv);\r\nof_node_put(np);\r\nout_unmap_irq:\r\nirq_dispose_mapping(irq);\r\nout:\r\nreturn ret;\r\n}
