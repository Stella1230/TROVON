int tso_count_descs(struct sk_buff *skb)\r\n{\r\nreturn skb_shinfo(skb)->gso_segs * 2 + skb_shinfo(skb)->nr_frags;\r\n}\r\nvoid tso_build_hdr(struct sk_buff *skb, char *hdr, struct tso_t *tso,\r\nint size, bool is_last)\r\n{\r\nstruct iphdr *iph;\r\nstruct tcphdr *tcph;\r\nint hdr_len = skb_transport_offset(skb) + tcp_hdrlen(skb);\r\nint mac_hdr_len = skb_network_offset(skb);\r\nmemcpy(hdr, skb->data, hdr_len);\r\niph = (struct iphdr *)(hdr + mac_hdr_len);\r\niph->id = htons(tso->ip_id);\r\niph->tot_len = htons(size + hdr_len - mac_hdr_len);\r\ntcph = (struct tcphdr *)(hdr + skb_transport_offset(skb));\r\nput_unaligned_be32(tso->tcp_seq, &tcph->seq);\r\ntso->ip_id++;\r\nif (!is_last) {\r\ntcph->psh = 0;\r\ntcph->fin = 0;\r\ntcph->rst = 0;\r\n}\r\n}\r\nvoid tso_build_data(struct sk_buff *skb, struct tso_t *tso, int size)\r\n{\r\ntso->tcp_seq += size;\r\ntso->size -= size;\r\ntso->data += size;\r\nif ((tso->size == 0) &&\r\n(tso->next_frag_idx < skb_shinfo(skb)->nr_frags)) {\r\nskb_frag_t *frag = &skb_shinfo(skb)->frags[tso->next_frag_idx];\r\ntso->size = frag->size;\r\ntso->data = page_address(frag->page.p) + frag->page_offset;\r\ntso->next_frag_idx++;\r\n}\r\n}\r\nvoid tso_start(struct sk_buff *skb, struct tso_t *tso)\r\n{\r\nint hdr_len = skb_transport_offset(skb) + tcp_hdrlen(skb);\r\ntso->ip_id = ntohs(ip_hdr(skb)->id);\r\ntso->tcp_seq = ntohl(tcp_hdr(skb)->seq);\r\ntso->next_frag_idx = 0;\r\ntso->size = skb_headlen(skb) - hdr_len;\r\ntso->data = skb->data + hdr_len;\r\nif ((tso->size == 0) &&\r\n(tso->next_frag_idx < skb_shinfo(skb)->nr_frags)) {\r\nskb_frag_t *frag = &skb_shinfo(skb)->frags[tso->next_frag_idx];\r\ntso->size = frag->size;\r\ntso->data = page_address(frag->page.p) + frag->page_offset;\r\ntso->next_frag_idx++;\r\n}\r\n}
