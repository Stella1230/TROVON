static int snd_us428ctls_vm_fault(struct vm_area_struct *area,\r\nstruct vm_fault *vmf)\r\n{\r\nunsigned long offset;\r\nstruct page * page;\r\nvoid *vaddr;\r\nsnd_printdd("ENTER, start %lXh, pgoff %ld\n",\r\narea->vm_start,\r\nvmf->pgoff);\r\noffset = vmf->pgoff << PAGE_SHIFT;\r\nvaddr = (char*)((struct usX2Ydev *)area->vm_private_data)->us428ctls_sharedmem + offset;\r\npage = virt_to_page(vaddr);\r\nget_page(page);\r\nvmf->page = page;\r\nsnd_printdd("vaddr=%p made us428ctls_vm_fault() page %p\n",\r\nvaddr, page);\r\nreturn 0;\r\n}\r\nstatic int snd_us428ctls_mmap(struct snd_hwdep * hw, struct file *filp, struct vm_area_struct *area)\r\n{\r\nunsigned long size = (unsigned long)(area->vm_end - area->vm_start);\r\nstruct usX2Ydev *us428 = hw->private_data;\r\nif (!(us428->chip_status & USX2Y_STAT_CHIP_INIT))\r\nreturn -EBUSY;\r\nif (size > PAGE_ALIGN(sizeof(struct us428ctls_sharedmem))) {\r\nsnd_printd( "%lu > %lu\n", size, (unsigned long)sizeof(struct us428ctls_sharedmem));\r\nreturn -EINVAL;\r\n}\r\nif (!us428->us428ctls_sharedmem) {\r\ninit_waitqueue_head(&us428->us428ctls_wait_queue_head);\r\nif(!(us428->us428ctls_sharedmem = snd_malloc_pages(sizeof(struct us428ctls_sharedmem), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\nmemset(us428->us428ctls_sharedmem, -1, sizeof(struct us428ctls_sharedmem));\r\nus428->us428ctls_sharedmem->CtlSnapShotLast = -2;\r\n}\r\narea->vm_ops = &us428ctls_vm_ops;\r\narea->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;\r\narea->vm_private_data = hw->private_data;\r\nreturn 0;\r\n}\r\nstatic unsigned int snd_us428ctls_poll(struct snd_hwdep *hw, struct file *file, poll_table *wait)\r\n{\r\nunsigned int mask = 0;\r\nstruct usX2Ydev *us428 = hw->private_data;\r\nstruct us428ctls_sharedmem *shm = us428->us428ctls_sharedmem;\r\nif (us428->chip_status & USX2Y_STAT_CHIP_HUP)\r\nreturn POLLHUP;\r\npoll_wait(file, &us428->us428ctls_wait_queue_head, wait);\r\nif (shm != NULL && shm->CtlSnapShotLast != shm->CtlSnapShotRed)\r\nmask |= POLLIN;\r\nreturn mask;\r\n}\r\nstatic int snd_usX2Y_hwdep_dsp_status(struct snd_hwdep *hw,\r\nstruct snd_hwdep_dsp_status *info)\r\n{\r\nstatic char *type_ids[USX2Y_TYPE_NUMS] = {\r\n[USX2Y_TYPE_122] = "us122",\r\n[USX2Y_TYPE_224] = "us224",\r\n[USX2Y_TYPE_428] = "us428",\r\n};\r\nstruct usX2Ydev *us428 = hw->private_data;\r\nint id = -1;\r\nswitch (le16_to_cpu(us428->dev->descriptor.idProduct)) {\r\ncase USB_ID_US122:\r\nid = USX2Y_TYPE_122;\r\nbreak;\r\ncase USB_ID_US224:\r\nid = USX2Y_TYPE_224;\r\nbreak;\r\ncase USB_ID_US428:\r\nid = USX2Y_TYPE_428;\r\nbreak;\r\n}\r\nif (0 > id)\r\nreturn -ENODEV;\r\nstrcpy(info->id, type_ids[id]);\r\ninfo->num_dsps = 2;\r\nif (us428->chip_status & USX2Y_STAT_CHIP_INIT)\r\ninfo->chip_ready = 1;\r\ninfo->version = USX2Y_DRIVER_VERSION;\r\nreturn 0;\r\n}\r\nstatic int usX2Y_create_usbmidi(struct snd_card *card)\r\n{\r\nstatic struct snd_usb_midi_endpoint_info quirk_data_1 = {\r\n.out_ep = 0x06,\r\n.in_ep = 0x06,\r\n.out_cables = 0x001,\r\n.in_cables = 0x001\r\n};\r\nstatic struct snd_usb_audio_quirk quirk_1 = {\r\n.vendor_name = "TASCAM",\r\n.product_name = NAME_ALLCAPS,\r\n.ifnum = 0,\r\n.type = QUIRK_MIDI_FIXED_ENDPOINT,\r\n.data = &quirk_data_1\r\n};\r\nstatic struct snd_usb_midi_endpoint_info quirk_data_2 = {\r\n.out_ep = 0x06,\r\n.in_ep = 0x06,\r\n.out_cables = 0x003,\r\n.in_cables = 0x003\r\n};\r\nstatic struct snd_usb_audio_quirk quirk_2 = {\r\n.vendor_name = "TASCAM",\r\n.product_name = "US428",\r\n.ifnum = 0,\r\n.type = QUIRK_MIDI_FIXED_ENDPOINT,\r\n.data = &quirk_data_2\r\n};\r\nstruct usb_device *dev = usX2Y(card)->dev;\r\nstruct usb_interface *iface = usb_ifnum_to_if(dev, 0);\r\nstruct snd_usb_audio_quirk *quirk =\r\nle16_to_cpu(dev->descriptor.idProduct) == USB_ID_US428 ?\r\n&quirk_2 : &quirk_1;\r\nsnd_printdd("usX2Y_create_usbmidi \n");\r\nreturn snd_usbmidi_create(card, iface, &usX2Y(card)->midi_list, quirk);\r\n}\r\nstatic int usX2Y_create_alsa_devices(struct snd_card *card)\r\n{\r\nint err;\r\ndo {\r\nif ((err = usX2Y_create_usbmidi(card)) < 0) {\r\nsnd_printk(KERN_ERR "usX2Y_create_alsa_devices: usX2Y_create_usbmidi error %i \n", err);\r\nbreak;\r\n}\r\nif ((err = usX2Y_audio_create(card)) < 0)\r\nbreak;\r\nif ((err = usX2Y_hwdep_pcm_new(card)) < 0)\r\nbreak;\r\nif ((err = snd_card_register(card)) < 0)\r\nbreak;\r\n} while (0);\r\nreturn err;\r\n}\r\nstatic int snd_usX2Y_hwdep_dsp_load(struct snd_hwdep *hw,\r\nstruct snd_hwdep_dsp_image *dsp)\r\n{\r\nstruct usX2Ydev *priv = hw->private_data;\r\nint lret, err = -EINVAL;\r\nsnd_printdd( "dsp_load %s\n", dsp->name);\r\nif (access_ok(VERIFY_READ, dsp->image, dsp->length)) {\r\nstruct usb_device* dev = priv->dev;\r\nchar *buf;\r\nbuf = memdup_user(dsp->image, dsp->length);\r\nif (IS_ERR(buf))\r\nreturn PTR_ERR(buf);\r\nerr = usb_set_interface(dev, 0, 1);\r\nif (err)\r\nsnd_printk(KERN_ERR "usb_set_interface error \n");\r\nelse\r\nerr = usb_bulk_msg(dev, usb_sndbulkpipe(dev, 2), buf, dsp->length, &lret, 6000);\r\nkfree(buf);\r\n}\r\nif (err)\r\nreturn err;\r\nif (dsp->index == 1) {\r\nmsleep(250);\r\nerr = usX2Y_AsyncSeq04_init(priv);\r\nif (err) {\r\nsnd_printk(KERN_ERR "usX2Y_AsyncSeq04_init error \n");\r\nreturn err;\r\n}\r\nerr = usX2Y_In04_init(priv);\r\nif (err) {\r\nsnd_printk(KERN_ERR "usX2Y_In04_init error \n");\r\nreturn err;\r\n}\r\nerr = usX2Y_create_alsa_devices(hw->card);\r\nif (err) {\r\nsnd_printk(KERN_ERR "usX2Y_create_alsa_devices error %i \n", err);\r\nsnd_card_free(hw->card);\r\nreturn err;\r\n}\r\npriv->chip_status |= USX2Y_STAT_CHIP_INIT;\r\nsnd_printdd("%s: alsa all started\n", hw->name);\r\n}\r\nreturn err;\r\n}\r\nint usX2Y_hwdep_new(struct snd_card *card, struct usb_device* device)\r\n{\r\nint err;\r\nstruct snd_hwdep *hw;\r\nif ((err = snd_hwdep_new(card, SND_USX2Y_LOADER_ID, 0, &hw)) < 0)\r\nreturn err;\r\nhw->iface = SNDRV_HWDEP_IFACE_USX2Y;\r\nhw->private_data = usX2Y(card);\r\nhw->ops.dsp_status = snd_usX2Y_hwdep_dsp_status;\r\nhw->ops.dsp_load = snd_usX2Y_hwdep_dsp_load;\r\nhw->ops.mmap = snd_us428ctls_mmap;\r\nhw->ops.poll = snd_us428ctls_poll;\r\nhw->exclusive = 1;\r\nsprintf(hw->name, "/proc/bus/usb/%03d/%03d", device->bus->busnum, device->devnum);\r\nreturn 0;\r\n}
