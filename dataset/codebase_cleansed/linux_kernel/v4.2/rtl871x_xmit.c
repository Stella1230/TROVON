static void _init_txservq(struct tx_servq *ptxservq)\r\n{\r\nINIT_LIST_HEAD(&ptxservq->tx_pending);\r\n_init_queue(&ptxservq->sta_pending);\r\nptxservq->qcnt = 0;\r\n}\r\nvoid _r8712_init_sta_xmit_priv(struct sta_xmit_priv *psta_xmitpriv)\r\n{\r\nmemset((unsigned char *)psta_xmitpriv, 0,\r\nsizeof(struct sta_xmit_priv));\r\nspin_lock_init(&psta_xmitpriv->lock);\r\n_init_txservq(&psta_xmitpriv->be_q);\r\n_init_txservq(&psta_xmitpriv->bk_q);\r\n_init_txservq(&psta_xmitpriv->vi_q);\r\n_init_txservq(&psta_xmitpriv->vo_q);\r\nINIT_LIST_HEAD(&psta_xmitpriv->legacy_dz);\r\nINIT_LIST_HEAD(&psta_xmitpriv->apsd);\r\n}\r\nsint _r8712_init_xmit_priv(struct xmit_priv *pxmitpriv,\r\nstruct _adapter *padapter)\r\n{\r\nsint i;\r\nstruct xmit_buf *pxmitbuf;\r\nstruct xmit_frame *pxframe;\r\nmemset((unsigned char *)pxmitpriv, 0, sizeof(struct xmit_priv));\r\nspin_lock_init(&pxmitpriv->lock);\r\npxmitpriv->adapter = padapter;\r\n_init_queue(&pxmitpriv->be_pending);\r\n_init_queue(&pxmitpriv->bk_pending);\r\n_init_queue(&pxmitpriv->vi_pending);\r\n_init_queue(&pxmitpriv->vo_pending);\r\n_init_queue(&pxmitpriv->bm_pending);\r\n_init_queue(&pxmitpriv->legacy_dz_queue);\r\n_init_queue(&pxmitpriv->apsd_queue);\r\n_init_queue(&pxmitpriv->free_xmit_queue);\r\npxmitpriv->pallocated_frame_buf = kmalloc(NR_XMITFRAME * sizeof(struct xmit_frame) + 4,\r\nGFP_ATOMIC);\r\nif (pxmitpriv->pallocated_frame_buf == NULL) {\r\npxmitpriv->pxmit_frame_buf = NULL;\r\nreturn _FAIL;\r\n}\r\npxmitpriv->pxmit_frame_buf = pxmitpriv->pallocated_frame_buf + 4 -\r\n((addr_t) (pxmitpriv->pallocated_frame_buf) & 3);\r\npxframe = (struct xmit_frame *) pxmitpriv->pxmit_frame_buf;\r\nfor (i = 0; i < NR_XMITFRAME; i++) {\r\nINIT_LIST_HEAD(&(pxframe->list));\r\npxframe->padapter = padapter;\r\npxframe->frame_tag = DATA_FRAMETAG;\r\npxframe->pkt = NULL;\r\npxframe->buf_addr = NULL;\r\npxframe->pxmitbuf = NULL;\r\nlist_add_tail(&(pxframe->list),\r\n&(pxmitpriv->free_xmit_queue.queue));\r\npxframe++;\r\n}\r\npxmitpriv->free_xmitframe_cnt = NR_XMITFRAME;\r\n_r8712_init_hw_txqueue(&pxmitpriv->be_txqueue, BE_QUEUE_INX);\r\n_r8712_init_hw_txqueue(&pxmitpriv->bk_txqueue, BK_QUEUE_INX);\r\n_r8712_init_hw_txqueue(&pxmitpriv->vi_txqueue, VI_QUEUE_INX);\r\n_r8712_init_hw_txqueue(&pxmitpriv->vo_txqueue, VO_QUEUE_INX);\r\n_r8712_init_hw_txqueue(&pxmitpriv->bmc_txqueue, BMC_QUEUE_INX);\r\npxmitpriv->frag_len = MAX_FRAG_THRESHOLD;\r\npxmitpriv->txirp_cnt = 1;\r\npxmitpriv->beq_cnt = 0;\r\npxmitpriv->bkq_cnt = 0;\r\npxmitpriv->viq_cnt = 0;\r\npxmitpriv->voq_cnt = 0;\r\n_init_queue(&pxmitpriv->free_xmitbuf_queue);\r\n_init_queue(&pxmitpriv->pending_xmitbuf_queue);\r\npxmitpriv->pallocated_xmitbuf = kmalloc(NR_XMITBUFF * sizeof(struct xmit_buf) + 4,\r\nGFP_ATOMIC);\r\nif (pxmitpriv->pallocated_xmitbuf == NULL)\r\nreturn _FAIL;\r\npxmitpriv->pxmitbuf = pxmitpriv->pallocated_xmitbuf + 4 -\r\n((addr_t)(pxmitpriv->pallocated_xmitbuf) & 3);\r\npxmitbuf = (struct xmit_buf *)pxmitpriv->pxmitbuf;\r\nfor (i = 0; i < NR_XMITBUFF; i++) {\r\nINIT_LIST_HEAD(&pxmitbuf->list);\r\npxmitbuf->pallocated_buf = kmalloc(MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ,\r\nGFP_ATOMIC);\r\nif (pxmitbuf->pallocated_buf == NULL)\r\nreturn _FAIL;\r\npxmitbuf->pbuf = pxmitbuf->pallocated_buf + XMITBUF_ALIGN_SZ -\r\n((addr_t) (pxmitbuf->pallocated_buf) &\r\n(XMITBUF_ALIGN_SZ - 1));\r\nr8712_xmit_resource_alloc(padapter, pxmitbuf);\r\nlist_add_tail(&pxmitbuf->list,\r\n&(pxmitpriv->free_xmitbuf_queue.queue));\r\npxmitbuf++;\r\n}\r\npxmitpriv->free_xmitbuf_cnt = NR_XMITBUFF;\r\nINIT_WORK(&padapter->wkFilterRxFF0, r8712_SetFilter);\r\nalloc_hwxmits(padapter);\r\ninit_hwxmits(pxmitpriv->hwxmits, pxmitpriv->hwxmit_entry);\r\ntasklet_init(&pxmitpriv->xmit_tasklet,\r\n(void(*)(unsigned long))r8712_xmit_bh,\r\n(unsigned long)padapter);\r\nreturn _SUCCESS;\r\n}\r\nvoid _free_xmit_priv(struct xmit_priv *pxmitpriv)\r\n{\r\nint i;\r\nstruct _adapter *padapter = pxmitpriv->adapter;\r\nstruct xmit_frame *pxmitframe = (struct xmit_frame *)\r\npxmitpriv->pxmit_frame_buf;\r\nstruct xmit_buf *pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmitbuf;\r\nif (pxmitpriv->pxmit_frame_buf == NULL)\r\nreturn;\r\nfor (i = 0; i < NR_XMITFRAME; i++) {\r\nr8712_xmit_complete(padapter, pxmitframe);\r\npxmitframe++;\r\n}\r\nfor (i = 0; i < NR_XMITBUFF; i++) {\r\nr8712_xmit_resource_free(padapter, pxmitbuf);\r\nkfree(pxmitbuf->pallocated_buf);\r\npxmitbuf++;\r\n}\r\nkfree(pxmitpriv->pallocated_frame_buf);\r\nkfree(pxmitpriv->pallocated_xmitbuf);\r\nfree_hwxmits(padapter);\r\n}\r\nsint r8712_update_attrib(struct _adapter *padapter, _pkt *pkt,\r\nstruct pkt_attrib *pattrib)\r\n{\r\nstruct pkt_file pktfile;\r\nstruct sta_info *psta = NULL;\r\nstruct ethhdr etherhdr;\r\nstruct tx_cmd txdesc;\r\nsint bmcast;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct qos_priv *pqospriv = &pmlmepriv->qospriv;\r\n_r8712_open_pktfile(pkt, &pktfile);\r\n_r8712_pktfile_read(&pktfile, (unsigned char *)&etherhdr, ETH_HLEN);\r\npattrib->ether_type = ntohs(etherhdr.h_proto);\r\n{\r\nif (pattrib->ether_type == 0x0806) {\r\nif (padapter->pwrctrlpriv.pwr_mode !=\r\npadapter->registrypriv.power_mgnt) {\r\ndel_timer_sync(&pmlmepriv->dhcp_timer);\r\nr8712_set_ps_mode(padapter, padapter->registrypriv.\r\npower_mgnt, padapter->registrypriv.smart_ps);\r\n}\r\n}\r\n}\r\nmemcpy(pattrib->dst, &etherhdr.h_dest, ETH_ALEN);\r\nmemcpy(pattrib->src, &etherhdr.h_source, ETH_ALEN);\r\npattrib->pctrl = 0;\r\nif ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) ||\r\n(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)) {\r\nmemcpy(pattrib->ra, pattrib->dst, ETH_ALEN);\r\nmemcpy(pattrib->ta, pattrib->src, ETH_ALEN);\r\n} else if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {\r\nmemcpy(pattrib->ra, get_bssid(pmlmepriv), ETH_ALEN);\r\nmemcpy(pattrib->ta, pattrib->src, ETH_ALEN);\r\n} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\r\nmemcpy(pattrib->ra, pattrib->dst, ETH_ALEN);\r\nmemcpy(pattrib->ta, get_bssid(pmlmepriv), ETH_ALEN);\r\n} else if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) {\r\nif (pattrib->ether_type != 0x8712)\r\nreturn _FAIL;\r\n_r8712_pktfile_read(&pktfile, (u8 *)&txdesc, TXDESC_SIZE);\r\nmemcpy(pattrib->ra, pattrib->dst, ETH_ALEN);\r\nmemcpy(pattrib->ta, pattrib->src, ETH_ALEN);\r\npattrib->pctrl = 1;\r\n}\r\npattrib->pktlen = pktfile.pkt_len;\r\nif (ETH_P_IP == pattrib->ether_type) {\r\nu8 tmp[24];\r\n_r8712_pktfile_read(&pktfile, &tmp[0], 24);\r\npattrib->dhcp_pkt = 0;\r\nif (pktfile.pkt_len > 282) {\r\nif (ETH_P_IP == pattrib->ether_type) {\r\nif (((tmp[21] == 68) && (tmp[23] == 67)) ||\r\n((tmp[21] == 67) && (tmp[23] == 68))) {\r\npattrib->dhcp_pkt = 1;\r\n}\r\n}\r\n}\r\n}\r\nbmcast = IS_MCAST(pattrib->ra);\r\nif (bmcast) {\r\npsta = r8712_get_bcmc_stainfo(padapter);\r\npattrib->mac_id = 4;\r\n} else {\r\nif (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) {\r\npsta = r8712_get_stainfo(pstapriv,\r\nget_bssid(pmlmepriv));\r\npattrib->mac_id = 5;\r\n} else {\r\npsta = r8712_get_stainfo(pstapriv, pattrib->ra);\r\nif (psta == NULL)\r\nreturn _FAIL;\r\nif (check_fwstate(pmlmepriv, WIFI_STATION_STATE))\r\npattrib->mac_id = 5;\r\nelse\r\npattrib->mac_id = psta->mac_id;\r\n}\r\n}\r\nif (psta) {\r\npattrib->psta = psta;\r\n} else {\r\nreturn _FAIL;\r\n}\r\npattrib->ack_policy = 0;\r\npattrib->pkt_hdrlen = ETH_HLEN;\r\nif (pqospriv->qos_option)\r\nr8712_set_qos(&pktfile, pattrib);\r\nelse {\r\npattrib->hdrlen = WLAN_HDR_A3_LEN;\r\npattrib->subtype = WIFI_DATA_TYPE;\r\npattrib->priority = 0;\r\n}\r\nif (psta->ieee8021x_blocked == true) {\r\npattrib->encrypt = 0;\r\nif ((pattrib->ether_type != 0x888e) &&\r\n(check_fwstate(pmlmepriv, WIFI_MP_STATE) == false))\r\nreturn _FAIL;\r\n} else\r\nGET_ENCRY_ALGO(psecuritypriv, psta, pattrib->encrypt, bmcast);\r\nswitch (pattrib->encrypt) {\r\ncase _WEP40_:\r\ncase _WEP104_:\r\npattrib->iv_len = 4;\r\npattrib->icv_len = 4;\r\nbreak;\r\ncase _TKIP_:\r\npattrib->iv_len = 8;\r\npattrib->icv_len = 4;\r\nif (padapter->securitypriv.busetkipkey == _FAIL)\r\nreturn _FAIL;\r\nbreak;\r\ncase _AES_:\r\npattrib->iv_len = 8;\r\npattrib->icv_len = 8;\r\nbreak;\r\ndefault:\r\npattrib->iv_len = 0;\r\npattrib->icv_len = 0;\r\nbreak;\r\n}\r\nif (pattrib->encrypt &&\r\n((padapter->securitypriv.sw_encrypt == true) ||\r\n(psecuritypriv->hw_decrypted == false)))\r\npattrib->bswenc = true;\r\nelse\r\npattrib->bswenc = false;\r\nif (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true)\r\npattrib->priority = (txdesc.txdw1 >> QSEL_SHT) & 0x1f;\r\nreturn _SUCCESS;\r\n}\r\nstatic sint xmitframe_addmic(struct _adapter *padapter,\r\nstruct xmit_frame *pxmitframe)\r\n{\r\nu32 curfragnum, length;\r\nu8 *pframe, *payload, mic[8];\r\nstruct mic_data micdata;\r\nstruct sta_info *stainfo;\r\nstruct qos_priv *pqospriv = &(padapter->mlmepriv.qospriv);\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nu8 priority[4] = {0x0, 0x0, 0x0, 0x0};\r\nsint bmcst = IS_MCAST(pattrib->ra);\r\nif (pattrib->psta)\r\nstainfo = pattrib->psta;\r\nelse\r\nstainfo = r8712_get_stainfo(&padapter->stapriv,\r\n&pattrib->ra[0]);\r\nif (pattrib->encrypt == _TKIP_) {\r\nif (stainfo != NULL) {\r\nu8 null_key[16] = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\r\n0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\r\n0x0, 0x0};\r\npframe = pxmitframe->buf_addr + TXDESC_OFFSET;\r\nif (bmcst) {\r\nif (!memcmp(psecuritypriv->XGrptxmickey\r\n[psecuritypriv->XGrpKeyid].skey,\r\nnull_key, 16))\r\nreturn _FAIL;\r\nr8712_secmicsetkey(&micdata,\r\npsecuritypriv->\r\nXGrptxmickey[psecuritypriv->\r\nXGrpKeyid].skey);\r\n} else {\r\nif (!memcmp(&stainfo->tkiptxmickey.skey[0],\r\nnull_key, 16))\r\nreturn _FAIL;\r\nr8712_secmicsetkey(&micdata,\r\n&stainfo->tkiptxmickey.skey[0]);\r\n}\r\nif (pframe[1] & 1) {\r\nr8712_secmicappend(&micdata,\r\n&pframe[16], 6);\r\nif (pframe[1]&2)\r\nr8712_secmicappend(&micdata,\r\n&pframe[24], 6);\r\nelse\r\nr8712_secmicappend(&micdata,\r\n&pframe[10], 6);\r\n} else {\r\nr8712_secmicappend(&micdata,\r\n&pframe[4], 6);\r\nif (pframe[1]&2)\r\nr8712_secmicappend(&micdata,\r\n&pframe[16], 6);\r\nelse\r\nr8712_secmicappend(&micdata,\r\n&pframe[10], 6);\r\n}\r\nif (pqospriv->qos_option == 1)\r\npriority[0] = (u8)pxmitframe->\r\nattrib.priority;\r\nr8712_secmicappend(&micdata, &priority[0], 4);\r\npayload = pframe;\r\nfor (curfragnum = 0; curfragnum < pattrib->nr_frags;\r\ncurfragnum++) {\r\npayload = (u8 *)RND4((addr_t)(payload));\r\npayload = payload+pattrib->\r\nhdrlen+pattrib->iv_len;\r\nif ((curfragnum + 1) == pattrib->nr_frags) {\r\nlength = pattrib->last_txcmdsz -\r\npattrib->hdrlen -\r\npattrib->iv_len -\r\n((psecuritypriv->sw_encrypt)\r\n? pattrib->icv_len : 0);\r\nr8712_secmicappend(&micdata, payload,\r\nlength);\r\npayload = payload+length;\r\n} else{\r\nlength = pxmitpriv->frag_len -\r\npattrib->hdrlen-pattrib->iv_len -\r\n((psecuritypriv->sw_encrypt) ?\r\npattrib->icv_len : 0);\r\nr8712_secmicappend(&micdata, payload,\r\nlength);\r\npayload = payload + length +\r\npattrib->icv_len;\r\n}\r\n}\r\nr8712_secgetmic(&micdata, &(mic[0]));\r\nmemcpy(payload, &(mic[0]), 8);\r\npattrib->last_txcmdsz += 8;\r\npayload = payload-pattrib->last_txcmdsz + 8;\r\n}\r\n}\r\nreturn _SUCCESS;\r\n}\r\nstatic sint xmitframe_swencrypt(struct _adapter *padapter,\r\nstruct xmit_frame *pxmitframe)\r\n{\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nif (pattrib->bswenc) {\r\nswitch (pattrib->encrypt) {\r\ncase _WEP40_:\r\ncase _WEP104_:\r\nr8712_wep_encrypt(padapter, (u8 *)pxmitframe);\r\nbreak;\r\ncase _TKIP_:\r\nr8712_tkip_encrypt(padapter, (u8 *)pxmitframe);\r\nbreak;\r\ncase _AES_:\r\nr8712_aes_encrypt(padapter, (u8 *)pxmitframe);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn _SUCCESS;\r\n}\r\nstatic sint make_wlanhdr(struct _adapter *padapter, u8 *hdr,\r\nstruct pkt_attrib *pattrib)\r\n{\r\nu16 *qc;\r\nstruct ieee80211_hdr *pwlanhdr = (struct ieee80211_hdr *)hdr;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct qos_priv *pqospriv = &pmlmepriv->qospriv;\r\nu16 *fctrl = &pwlanhdr->frame_ctl;\r\nmemset(hdr, 0, WLANHDR_OFFSET);\r\nSetFrameSubType(fctrl, pattrib->subtype);\r\nif (pattrib->subtype & WIFI_DATA_TYPE) {\r\nif (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true) {\r\nSetToDs(fctrl);\r\nmemcpy(pwlanhdr->addr1, get_bssid(pmlmepriv),\r\nETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, pattrib->dst, ETH_ALEN);\r\n} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {\r\nSetFrDs(fctrl);\r\nmemcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, get_bssid(pmlmepriv),\r\nETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, pattrib->src, ETH_ALEN);\r\n} else if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true)\r\n|| (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)\r\n== true)) {\r\nmemcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, get_bssid(pmlmepriv),\r\nETH_ALEN);\r\n} else if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) {\r\nmemcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, get_bssid(pmlmepriv),\r\nETH_ALEN);\r\n} else\r\nreturn _FAIL;\r\nif (pattrib->encrypt)\r\nSetPrivacy(fctrl);\r\nif (pqospriv->qos_option) {\r\nqc = (unsigned short *)(hdr + pattrib->hdrlen - 2);\r\nif (pattrib->priority)\r\nSetPriority(qc, pattrib->priority);\r\nSetAckpolicy(qc, pattrib->ack_policy);\r\n}\r\n{\r\nstruct sta_info *psta;\r\nsint bmcst = IS_MCAST(pattrib->ra);\r\nif (pattrib->psta)\r\npsta = pattrib->psta;\r\nelse {\r\nif (bmcst)\r\npsta = r8712_get_bcmc_stainfo(padapter);\r\nelse\r\npsta =\r\nr8712_get_stainfo(&padapter->stapriv,\r\npattrib->ra);\r\n}\r\nif (psta) {\r\npsta->sta_xmitpriv.txseq_tid\r\n[pattrib->priority]++;\r\npsta->sta_xmitpriv.txseq_tid[pattrib->priority]\r\n&= 0xFFF;\r\npattrib->seqnum = psta->sta_xmitpriv.\r\ntxseq_tid[pattrib->priority];\r\nSetSeqNum(hdr, pattrib->seqnum);\r\n}\r\n}\r\n}\r\nreturn _SUCCESS;\r\n}\r\nstatic sint r8712_put_snap(u8 *data, u16 h_proto)\r\n{\r\nstruct ieee80211_snap_hdr *snap;\r\nconst u8 *oui;\r\nsnap = (struct ieee80211_snap_hdr *)data;\r\nsnap->dsap = 0xaa;\r\nsnap->ssap = 0xaa;\r\nsnap->ctrl = 0x03;\r\nif (h_proto == 0x8137 || h_proto == 0x80f3)\r\noui = P802_1H_OUI;\r\nelse\r\noui = RFC1042_OUI;\r\nsnap->oui[0] = oui[0];\r\nsnap->oui[1] = oui[1];\r\nsnap->oui[2] = oui[2];\r\n*(u16 *)(data + SNAP_SIZE) = htons(h_proto);\r\nreturn SNAP_SIZE + sizeof(u16);\r\n}\r\nsint r8712_xmitframe_coalesce(struct _adapter *padapter, _pkt *pkt,\r\nstruct xmit_frame *pxmitframe)\r\n{\r\nstruct pkt_file pktfile;\r\nsint frg_len, mpdu_len, llc_sz;\r\nu32 mem_sz;\r\nu8 frg_inx;\r\naddr_t addr;\r\nu8 *pframe, *mem_start, *ptxdesc;\r\nstruct sta_info *psta;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nu8 *pbuf_start;\r\nsint bmcst = IS_MCAST(pattrib->ra);\r\nif (pattrib->psta == NULL)\r\nreturn _FAIL;\r\npsta = pattrib->psta;\r\nif (pxmitframe->buf_addr == NULL)\r\nreturn _FAIL;\r\npbuf_start = pxmitframe->buf_addr;\r\nptxdesc = pbuf_start;\r\nmem_start = pbuf_start + TXDESC_OFFSET;\r\nif (make_wlanhdr(padapter, mem_start, pattrib) == _FAIL)\r\nreturn _FAIL;\r\n_r8712_open_pktfile(pkt, &pktfile);\r\n_r8712_pktfile_read(&pktfile, NULL, (uint) pattrib->pkt_hdrlen);\r\nif (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) {\r\nif (pattrib->ether_type == 0x8712) {\r\n_r8712_pktfile_read(&pktfile, ptxdesc, TXDESC_SIZE);\r\n}\r\n}\r\npattrib->pktlen = pktfile.pkt_len;\r\nfrg_inx = 0;\r\nfrg_len = pxmitpriv->frag_len - 4;\r\nwhile (1) {\r\nllc_sz = 0;\r\nmpdu_len = frg_len;\r\npframe = mem_start;\r\nSetMFrag(mem_start);\r\npframe += pattrib->hdrlen;\r\nmpdu_len -= pattrib->hdrlen;\r\nif (pattrib->iv_len) {\r\nif (psta != NULL) {\r\nswitch (pattrib->encrypt) {\r\ncase _WEP40_:\r\ncase _WEP104_:\r\nWEP_IV(pattrib->iv, psta->txpn,\r\n(u8)psecuritypriv->\r\nPrivacyKeyIndex);\r\nbreak;\r\ncase _TKIP_:\r\nif (bmcst)\r\nTKIP_IV(pattrib->iv,\r\npsta->txpn,\r\n(u8)psecuritypriv->\r\nXGrpKeyid);\r\nelse\r\nTKIP_IV(pattrib->iv, psta->txpn,\r\n0);\r\nbreak;\r\ncase _AES_:\r\nif (bmcst)\r\nAES_IV(pattrib->iv, psta->txpn,\r\n(u8)psecuritypriv->\r\nXGrpKeyid);\r\nelse\r\nAES_IV(pattrib->iv, psta->txpn,\r\n0);\r\nbreak;\r\n}\r\n}\r\nmemcpy(pframe, pattrib->iv, pattrib->iv_len);\r\npframe += pattrib->iv_len;\r\nmpdu_len -= pattrib->iv_len;\r\n}\r\nif (frg_inx == 0) {\r\nllc_sz = r8712_put_snap(pframe, pattrib->ether_type);\r\npframe += llc_sz;\r\nmpdu_len -= llc_sz;\r\n}\r\nif ((pattrib->icv_len > 0) && (pattrib->bswenc))\r\nmpdu_len -= pattrib->icv_len;\r\nif (bmcst)\r\nmem_sz = _r8712_pktfile_read(&pktfile, pframe,\r\npattrib->pktlen);\r\nelse\r\nmem_sz = _r8712_pktfile_read(&pktfile, pframe,\r\nmpdu_len);\r\npframe += mem_sz;\r\nif ((pattrib->icv_len > 0) && (pattrib->bswenc)) {\r\nmemcpy(pframe, pattrib->icv, pattrib->icv_len);\r\npframe += pattrib->icv_len;\r\n}\r\nfrg_inx++;\r\nif (bmcst || (r8712_endofpktfile(&pktfile) == true)) {\r\npattrib->nr_frags = frg_inx;\r\npattrib->last_txcmdsz = pattrib->hdrlen +\r\npattrib->iv_len +\r\n((pattrib->nr_frags == 1) ?\r\nllc_sz : 0) +\r\n((pattrib->bswenc) ?\r\npattrib->icv_len : 0) + mem_sz;\r\nClearMFrag(mem_start);\r\nbreak;\r\n}\r\naddr = (addr_t)(pframe);\r\nmem_start = (unsigned char *)RND4(addr) + TXDESC_OFFSET;\r\nmemcpy(mem_start, pbuf_start + TXDESC_OFFSET, pattrib->hdrlen);\r\n}\r\nif (xmitframe_addmic(padapter, pxmitframe) == _FAIL)\r\nreturn _FAIL;\r\nxmitframe_swencrypt(padapter, pxmitframe);\r\nreturn _SUCCESS;\r\n}\r\nvoid r8712_update_protection(struct _adapter *padapter, u8 *ie, uint ie_len)\r\n{\r\nuint protection;\r\nu8 *perp;\r\nsint erp_len;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nstruct registry_priv *pregistrypriv = &padapter->registrypriv;\r\nswitch (pxmitpriv->vcs_setting) {\r\ncase DISABLE_VCS:\r\npxmitpriv->vcs = NONE_VCS;\r\nbreak;\r\ncase ENABLE_VCS:\r\nbreak;\r\ncase AUTO_VCS:\r\ndefault:\r\nperp = r8712_get_ie(ie, _ERPINFO_IE_, &erp_len, ie_len);\r\nif (perp == NULL)\r\npxmitpriv->vcs = NONE_VCS;\r\nelse {\r\nprotection = (*(perp + 2)) & BIT(1);\r\nif (protection) {\r\nif (pregistrypriv->vcs_type == RTS_CTS)\r\npxmitpriv->vcs = RTS_CTS;\r\nelse\r\npxmitpriv->vcs = CTS_TO_SELF;\r\n} else\r\npxmitpriv->vcs = NONE_VCS;\r\n}\r\nbreak;\r\n}\r\n}\r\nstruct xmit_buf *r8712_alloc_xmitbuf(struct xmit_priv *pxmitpriv)\r\n{\r\nunsigned long irqL;\r\nstruct xmit_buf *pxmitbuf = NULL;\r\nstruct list_head *plist, *phead;\r\nstruct __queue *pfree_xmitbuf_queue = &pxmitpriv->free_xmitbuf_queue;\r\nspin_lock_irqsave(&pfree_xmitbuf_queue->lock, irqL);\r\nif (list_empty(&pfree_xmitbuf_queue->queue))\r\npxmitbuf = NULL;\r\nelse {\r\nphead = &pfree_xmitbuf_queue->queue;\r\nplist = phead->next;\r\npxmitbuf = LIST_CONTAINOR(plist, struct xmit_buf, list);\r\nlist_del_init(&(pxmitbuf->list));\r\n}\r\nif (pxmitbuf != NULL)\r\npxmitpriv->free_xmitbuf_cnt--;\r\nspin_unlock_irqrestore(&pfree_xmitbuf_queue->lock, irqL);\r\nreturn pxmitbuf;\r\n}\r\nint r8712_free_xmitbuf(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)\r\n{\r\nunsigned long irqL;\r\nstruct __queue *pfree_xmitbuf_queue = &pxmitpriv->free_xmitbuf_queue;\r\nif (pxmitbuf == NULL)\r\nreturn _FAIL;\r\nspin_lock_irqsave(&pfree_xmitbuf_queue->lock, irqL);\r\nlist_del_init(&pxmitbuf->list);\r\nlist_add_tail(&(pxmitbuf->list), &pfree_xmitbuf_queue->queue);\r\npxmitpriv->free_xmitbuf_cnt++;\r\nspin_unlock_irqrestore(&pfree_xmitbuf_queue->lock, irqL);\r\nreturn _SUCCESS;\r\n}\r\nstruct xmit_frame *r8712_alloc_xmitframe(struct xmit_priv *pxmitpriv)\r\n{\r\nunsigned long irqL;\r\nstruct xmit_frame *pxframe = NULL;\r\nstruct list_head *plist, *phead;\r\nstruct __queue *pfree_xmit_queue = &pxmitpriv->free_xmit_queue;\r\nspin_lock_irqsave(&pfree_xmit_queue->lock, irqL);\r\nif (list_empty(&pfree_xmit_queue->queue))\r\npxframe = NULL;\r\nelse {\r\nphead = &pfree_xmit_queue->queue;\r\nplist = phead->next;\r\npxframe = LIST_CONTAINOR(plist, struct xmit_frame, list);\r\nlist_del_init(&(pxframe->list));\r\n}\r\nif (pxframe != NULL) {\r\npxmitpriv->free_xmitframe_cnt--;\r\npxframe->buf_addr = NULL;\r\npxframe->pxmitbuf = NULL;\r\npxframe->attrib.psta = NULL;\r\npxframe->pkt = NULL;\r\n}\r\nspin_unlock_irqrestore(&pfree_xmit_queue->lock, irqL);\r\nreturn pxframe;\r\n}\r\nvoid r8712_free_xmitframe(struct xmit_priv *pxmitpriv,\r\nstruct xmit_frame *pxmitframe)\r\n{\r\nunsigned long irqL;\r\nstruct __queue *pfree_xmit_queue = &pxmitpriv->free_xmit_queue;\r\nstruct _adapter *padapter = pxmitpriv->adapter;\r\nif (pxmitframe == NULL)\r\nreturn;\r\nspin_lock_irqsave(&pfree_xmit_queue->lock, irqL);\r\nlist_del_init(&pxmitframe->list);\r\nif (pxmitframe->pkt)\r\npxmitframe->pkt = NULL;\r\nlist_add_tail(&pxmitframe->list, &pfree_xmit_queue->queue);\r\npxmitpriv->free_xmitframe_cnt++;\r\nspin_unlock_irqrestore(&pfree_xmit_queue->lock, irqL);\r\nif (netif_queue_stopped(padapter->pnetdev))\r\nnetif_wake_queue(padapter->pnetdev);\r\n}\r\nvoid r8712_free_xmitframe_ex(struct xmit_priv *pxmitpriv,\r\nstruct xmit_frame *pxmitframe)\r\n{\r\nif (pxmitframe == NULL)\r\nreturn;\r\nif (pxmitframe->frame_tag == DATA_FRAMETAG)\r\nr8712_free_xmitframe(pxmitpriv, pxmitframe);\r\n}\r\nvoid r8712_free_xmitframe_queue(struct xmit_priv *pxmitpriv,\r\nstruct __queue *pframequeue)\r\n{\r\nunsigned long irqL;\r\nstruct list_head *plist, *phead;\r\nstruct xmit_frame *pxmitframe;\r\nspin_lock_irqsave(&(pframequeue->lock), irqL);\r\nphead = &pframequeue->queue;\r\nplist = phead->next;\r\nwhile (end_of_queue_search(phead, plist) == false) {\r\npxmitframe = LIST_CONTAINOR(plist, struct xmit_frame, list);\r\nplist = plist->next;\r\nr8712_free_xmitframe(pxmitpriv, pxmitframe);\r\n}\r\nspin_unlock_irqrestore(&(pframequeue->lock), irqL);\r\n}\r\nstatic inline struct tx_servq *get_sta_pending(struct _adapter *padapter,\r\nstruct __queue **ppstapending,\r\nstruct sta_info *psta, sint up)\r\n{\r\nstruct tx_servq *ptxservq;\r\nstruct hw_xmit *phwxmits = padapter->xmitpriv.hwxmits;\r\nswitch (up) {\r\ncase 1:\r\ncase 2:\r\nptxservq = &(psta->sta_xmitpriv.bk_q);\r\n*ppstapending = &padapter->xmitpriv.bk_pending;\r\n(phwxmits+3)->accnt++;\r\nbreak;\r\ncase 4:\r\ncase 5:\r\nptxservq = &(psta->sta_xmitpriv.vi_q);\r\n*ppstapending = &padapter->xmitpriv.vi_pending;\r\n(phwxmits+1)->accnt++;\r\nbreak;\r\ncase 6:\r\ncase 7:\r\nptxservq = &(psta->sta_xmitpriv.vo_q);\r\n*ppstapending = &padapter->xmitpriv.vo_pending;\r\n(phwxmits+0)->accnt++;\r\nbreak;\r\ncase 0:\r\ncase 3:\r\ndefault:\r\nptxservq = &(psta->sta_xmitpriv.be_q);\r\n*ppstapending = &padapter->xmitpriv.be_pending;\r\n(phwxmits + 2)->accnt++;\r\nbreak;\r\n}\r\nreturn ptxservq;\r\n}\r\nsint r8712_xmit_classifier(struct _adapter *padapter,\r\nstruct xmit_frame *pxmitframe)\r\n{\r\nunsigned long irqL0;\r\nstruct __queue *pstapending;\r\nstruct sta_info *psta;\r\nstruct tx_servq *ptxservq;\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nsint bmcst = IS_MCAST(pattrib->ra);\r\nif (pattrib->psta)\r\npsta = pattrib->psta;\r\nelse {\r\nif (bmcst)\r\npsta = r8712_get_bcmc_stainfo(padapter);\r\nelse {\r\nif (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true)\r\npsta = r8712_get_stainfo(pstapriv,\r\nget_bssid(pmlmepriv));\r\nelse\r\npsta = r8712_get_stainfo(pstapriv, pattrib->ra);\r\n}\r\n}\r\nif (psta == NULL)\r\nreturn _FAIL;\r\nptxservq = get_sta_pending(padapter, &pstapending,\r\npsta, pattrib->priority);\r\nspin_lock_irqsave(&pstapending->lock, irqL0);\r\nif (list_empty(&ptxservq->tx_pending))\r\nlist_add_tail(&ptxservq->tx_pending, &pstapending->queue);\r\nlist_add_tail(&pxmitframe->list, &ptxservq->sta_pending.queue);\r\nptxservq->qcnt++;\r\nspin_unlock_irqrestore(&pstapending->lock, irqL0);\r\nreturn _SUCCESS;\r\n}\r\nstatic void alloc_hwxmits(struct _adapter *padapter)\r\n{\r\nstruct hw_xmit *hwxmits;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\npxmitpriv->hwxmit_entry = HWXMIT_ENTRY;\r\npxmitpriv->hwxmits = kmalloc_array(pxmitpriv->hwxmit_entry,\r\nsizeof(struct hw_xmit), GFP_ATOMIC);\r\nif (pxmitpriv->hwxmits == NULL)\r\nreturn;\r\nhwxmits = pxmitpriv->hwxmits;\r\nif (pxmitpriv->hwxmit_entry == 5) {\r\npxmitpriv->bmc_txqueue.head = 0;\r\nhwxmits[0] .phwtxqueue = &pxmitpriv->bmc_txqueue;\r\nhwxmits[0] .sta_queue = &pxmitpriv->bm_pending;\r\npxmitpriv->vo_txqueue.head = 0;\r\nhwxmits[1] .phwtxqueue = &pxmitpriv->vo_txqueue;\r\nhwxmits[1] .sta_queue = &pxmitpriv->vo_pending;\r\npxmitpriv->vi_txqueue.head = 0;\r\nhwxmits[2] .phwtxqueue = &pxmitpriv->vi_txqueue;\r\nhwxmits[2] .sta_queue = &pxmitpriv->vi_pending;\r\npxmitpriv->bk_txqueue.head = 0;\r\nhwxmits[3] .phwtxqueue = &pxmitpriv->bk_txqueue;\r\nhwxmits[3] .sta_queue = &pxmitpriv->bk_pending;\r\npxmitpriv->be_txqueue.head = 0;\r\nhwxmits[4] .phwtxqueue = &pxmitpriv->be_txqueue;\r\nhwxmits[4] .sta_queue = &pxmitpriv->be_pending;\r\n} else if (pxmitpriv->hwxmit_entry == 4) {\r\npxmitpriv->vo_txqueue.head = 0;\r\nhwxmits[0] .phwtxqueue = &pxmitpriv->vo_txqueue;\r\nhwxmits[0] .sta_queue = &pxmitpriv->vo_pending;\r\npxmitpriv->vi_txqueue.head = 0;\r\nhwxmits[1] .phwtxqueue = &pxmitpriv->vi_txqueue;\r\nhwxmits[1] .sta_queue = &pxmitpriv->vi_pending;\r\npxmitpriv->be_txqueue.head = 0;\r\nhwxmits[2] .phwtxqueue = &pxmitpriv->be_txqueue;\r\nhwxmits[2] .sta_queue = &pxmitpriv->be_pending;\r\npxmitpriv->bk_txqueue.head = 0;\r\nhwxmits[3] .phwtxqueue = &pxmitpriv->bk_txqueue;\r\nhwxmits[3] .sta_queue = &pxmitpriv->bk_pending;\r\n}\r\n}\r\nstatic void free_hwxmits(struct _adapter *padapter)\r\n{\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nkfree(pxmitpriv->hwxmits);\r\n}\r\nstatic void init_hwxmits(struct hw_xmit *phwxmit, sint entry)\r\n{\r\nsint i;\r\nfor (i = 0; i < entry; i++, phwxmit++) {\r\nspin_lock_init(&phwxmit->xmit_lock);\r\nINIT_LIST_HEAD(&phwxmit->pending);\r\nphwxmit->txcmdcnt = 0;\r\nphwxmit->accnt = 0;\r\n}\r\n}\r\nvoid xmitframe_xmitbuf_attach(struct xmit_frame *pxmitframe,\r\nstruct xmit_buf *pxmitbuf)\r\n{\r\npxmitframe->pxmitbuf = pxmitbuf;\r\npxmitframe->pxmit_urb[0] = pxmitbuf->pxmit_urb[0];\r\npxmitframe->buf_addr = pxmitbuf->pbuf;\r\npxmitbuf->priv_data = pxmitframe;\r\n}\r\nint r8712_pre_xmit(struct _adapter *padapter, struct xmit_frame *pxmitframe)\r\n{\r\nunsigned long irqL;\r\nint ret;\r\nstruct xmit_buf *pxmitbuf = NULL;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nr8712_do_queue_select(padapter, pattrib);\r\nspin_lock_irqsave(&pxmitpriv->lock, irqL);\r\nif (r8712_txframes_sta_ac_pending(padapter, pattrib) > 0) {\r\nret = false;\r\nr8712_xmit_enqueue(padapter, pxmitframe);\r\nspin_unlock_irqrestore(&pxmitpriv->lock, irqL);\r\nreturn ret;\r\n}\r\npxmitbuf = r8712_alloc_xmitbuf(pxmitpriv);\r\nif (pxmitbuf == NULL) {\r\nret = false;\r\nr8712_xmit_enqueue(padapter, pxmitframe);\r\nspin_unlock_irqrestore(&pxmitpriv->lock, irqL);\r\n} else {\r\nspin_unlock_irqrestore(&pxmitpriv->lock, irqL);\r\nret = true;\r\nxmitframe_xmitbuf_attach(pxmitframe, pxmitbuf);\r\nr8712_xmit_direct(padapter, pxmitframe);\r\n}\r\nreturn ret;\r\n}
