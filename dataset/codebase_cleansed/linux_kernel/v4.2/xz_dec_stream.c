static bool fill_temp(struct xz_dec *s, struct xz_buf *b)\r\n{\r\nsize_t copy_size = min_t(size_t,\r\nb->in_size - b->in_pos, s->temp.size - s->temp.pos);\r\nmemcpy(s->temp.buf + s->temp.pos, b->in + b->in_pos, copy_size);\r\nb->in_pos += copy_size;\r\ns->temp.pos += copy_size;\r\nif (s->temp.pos == s->temp.size) {\r\ns->temp.pos = 0;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic enum xz_ret dec_vli(struct xz_dec *s, const uint8_t *in,\r\nsize_t *in_pos, size_t in_size)\r\n{\r\nuint8_t byte;\r\nif (s->pos == 0)\r\ns->vli = 0;\r\nwhile (*in_pos < in_size) {\r\nbyte = in[*in_pos];\r\n++*in_pos;\r\ns->vli |= (vli_type)(byte & 0x7F) << s->pos;\r\nif ((byte & 0x80) == 0) {\r\nif (byte == 0 && s->pos != 0)\r\nreturn XZ_DATA_ERROR;\r\ns->pos = 0;\r\nreturn XZ_STREAM_END;\r\n}\r\ns->pos += 7;\r\nif (s->pos == 7 * VLI_BYTES_MAX)\r\nreturn XZ_DATA_ERROR;\r\n}\r\nreturn XZ_OK;\r\n}\r\nstatic enum xz_ret dec_block(struct xz_dec *s, struct xz_buf *b)\r\n{\r\nenum xz_ret ret;\r\ns->in_start = b->in_pos;\r\ns->out_start = b->out_pos;\r\n#ifdef XZ_DEC_BCJ\r\nif (s->bcj_active)\r\nret = xz_dec_bcj_run(s->bcj, s->lzma2, b);\r\nelse\r\n#endif\r\nret = xz_dec_lzma2_run(s->lzma2, b);\r\ns->block.compressed += b->in_pos - s->in_start;\r\ns->block.uncompressed += b->out_pos - s->out_start;\r\nif (s->block.compressed > s->block_header.compressed\r\n|| s->block.uncompressed\r\n> s->block_header.uncompressed)\r\nreturn XZ_DATA_ERROR;\r\nif (s->check_type == XZ_CHECK_CRC32)\r\ns->crc32 = xz_crc32(b->out + s->out_start,\r\nb->out_pos - s->out_start, s->crc32);\r\nif (ret == XZ_STREAM_END) {\r\nif (s->block_header.compressed != VLI_UNKNOWN\r\n&& s->block_header.compressed\r\n!= s->block.compressed)\r\nreturn XZ_DATA_ERROR;\r\nif (s->block_header.uncompressed != VLI_UNKNOWN\r\n&& s->block_header.uncompressed\r\n!= s->block.uncompressed)\r\nreturn XZ_DATA_ERROR;\r\ns->block.hash.unpadded += s->block_header.size\r\n+ s->block.compressed;\r\n#ifdef XZ_DEC_ANY_CHECK\r\ns->block.hash.unpadded += check_sizes[s->check_type];\r\n#else\r\nif (s->check_type == XZ_CHECK_CRC32)\r\ns->block.hash.unpadded += 4;\r\n#endif\r\ns->block.hash.uncompressed += s->block.uncompressed;\r\ns->block.hash.crc32 = xz_crc32(\r\n(const uint8_t *)&s->block.hash,\r\nsizeof(s->block.hash), s->block.hash.crc32);\r\n++s->block.count;\r\n}\r\nreturn ret;\r\n}\r\nstatic void index_update(struct xz_dec *s, const struct xz_buf *b)\r\n{\r\nsize_t in_used = b->in_pos - s->in_start;\r\ns->index.size += in_used;\r\ns->crc32 = xz_crc32(b->in + s->in_start, in_used, s->crc32);\r\n}\r\nstatic enum xz_ret dec_index(struct xz_dec *s, struct xz_buf *b)\r\n{\r\nenum xz_ret ret;\r\ndo {\r\nret = dec_vli(s, b->in, &b->in_pos, b->in_size);\r\nif (ret != XZ_STREAM_END) {\r\nindex_update(s, b);\r\nreturn ret;\r\n}\r\nswitch (s->index.sequence) {\r\ncase SEQ_INDEX_COUNT:\r\ns->index.count = s->vli;\r\nif (s->index.count != s->block.count)\r\nreturn XZ_DATA_ERROR;\r\ns->index.sequence = SEQ_INDEX_UNPADDED;\r\nbreak;\r\ncase SEQ_INDEX_UNPADDED:\r\ns->index.hash.unpadded += s->vli;\r\ns->index.sequence = SEQ_INDEX_UNCOMPRESSED;\r\nbreak;\r\ncase SEQ_INDEX_UNCOMPRESSED:\r\ns->index.hash.uncompressed += s->vli;\r\ns->index.hash.crc32 = xz_crc32(\r\n(const uint8_t *)&s->index.hash,\r\nsizeof(s->index.hash),\r\ns->index.hash.crc32);\r\n--s->index.count;\r\ns->index.sequence = SEQ_INDEX_UNPADDED;\r\nbreak;\r\n}\r\n} while (s->index.count > 0);\r\nreturn XZ_STREAM_END;\r\n}\r\nstatic enum xz_ret crc32_validate(struct xz_dec *s, struct xz_buf *b)\r\n{\r\ndo {\r\nif (b->in_pos == b->in_size)\r\nreturn XZ_OK;\r\nif (((s->crc32 >> s->pos) & 0xFF) != b->in[b->in_pos++])\r\nreturn XZ_DATA_ERROR;\r\ns->pos += 8;\r\n} while (s->pos < 32);\r\ns->crc32 = 0;\r\ns->pos = 0;\r\nreturn XZ_STREAM_END;\r\n}\r\nstatic bool check_skip(struct xz_dec *s, struct xz_buf *b)\r\n{\r\nwhile (s->pos < check_sizes[s->check_type]) {\r\nif (b->in_pos == b->in_size)\r\nreturn false;\r\n++b->in_pos;\r\n++s->pos;\r\n}\r\ns->pos = 0;\r\nreturn true;\r\n}\r\nstatic enum xz_ret dec_stream_header(struct xz_dec *s)\r\n{\r\nif (!memeq(s->temp.buf, HEADER_MAGIC, HEADER_MAGIC_SIZE))\r\nreturn XZ_FORMAT_ERROR;\r\nif (xz_crc32(s->temp.buf + HEADER_MAGIC_SIZE, 2, 0)\r\n!= get_le32(s->temp.buf + HEADER_MAGIC_SIZE + 2))\r\nreturn XZ_DATA_ERROR;\r\nif (s->temp.buf[HEADER_MAGIC_SIZE] != 0)\r\nreturn XZ_OPTIONS_ERROR;\r\ns->check_type = s->temp.buf[HEADER_MAGIC_SIZE + 1];\r\n#ifdef XZ_DEC_ANY_CHECK\r\nif (s->check_type > XZ_CHECK_MAX)\r\nreturn XZ_OPTIONS_ERROR;\r\nif (s->check_type > XZ_CHECK_CRC32)\r\nreturn XZ_UNSUPPORTED_CHECK;\r\n#else\r\nif (s->check_type > XZ_CHECK_CRC32)\r\nreturn XZ_OPTIONS_ERROR;\r\n#endif\r\nreturn XZ_OK;\r\n}\r\nstatic enum xz_ret dec_stream_footer(struct xz_dec *s)\r\n{\r\nif (!memeq(s->temp.buf + 10, FOOTER_MAGIC, FOOTER_MAGIC_SIZE))\r\nreturn XZ_DATA_ERROR;\r\nif (xz_crc32(s->temp.buf + 4, 6, 0) != get_le32(s->temp.buf))\r\nreturn XZ_DATA_ERROR;\r\nif ((s->index.size >> 2) != get_le32(s->temp.buf + 4))\r\nreturn XZ_DATA_ERROR;\r\nif (s->temp.buf[8] != 0 || s->temp.buf[9] != s->check_type)\r\nreturn XZ_DATA_ERROR;\r\nreturn XZ_STREAM_END;\r\n}\r\nstatic enum xz_ret dec_block_header(struct xz_dec *s)\r\n{\r\nenum xz_ret ret;\r\ns->temp.size -= 4;\r\nif (xz_crc32(s->temp.buf, s->temp.size, 0)\r\n!= get_le32(s->temp.buf + s->temp.size))\r\nreturn XZ_DATA_ERROR;\r\ns->temp.pos = 2;\r\n#ifdef XZ_DEC_BCJ\r\nif (s->temp.buf[1] & 0x3E)\r\n#else\r\nif (s->temp.buf[1] & 0x3F)\r\n#endif\r\nreturn XZ_OPTIONS_ERROR;\r\nif (s->temp.buf[1] & 0x40) {\r\nif (dec_vli(s, s->temp.buf, &s->temp.pos, s->temp.size)\r\n!= XZ_STREAM_END)\r\nreturn XZ_DATA_ERROR;\r\ns->block_header.compressed = s->vli;\r\n} else {\r\ns->block_header.compressed = VLI_UNKNOWN;\r\n}\r\nif (s->temp.buf[1] & 0x80) {\r\nif (dec_vli(s, s->temp.buf, &s->temp.pos, s->temp.size)\r\n!= XZ_STREAM_END)\r\nreturn XZ_DATA_ERROR;\r\ns->block_header.uncompressed = s->vli;\r\n} else {\r\ns->block_header.uncompressed = VLI_UNKNOWN;\r\n}\r\n#ifdef XZ_DEC_BCJ\r\ns->bcj_active = s->temp.buf[1] & 0x01;\r\nif (s->bcj_active) {\r\nif (s->temp.size - s->temp.pos < 2)\r\nreturn XZ_OPTIONS_ERROR;\r\nret = xz_dec_bcj_reset(s->bcj, s->temp.buf[s->temp.pos++]);\r\nif (ret != XZ_OK)\r\nreturn ret;\r\nif (s->temp.buf[s->temp.pos++] != 0x00)\r\nreturn XZ_OPTIONS_ERROR;\r\n}\r\n#endif\r\nif (s->temp.size - s->temp.pos < 2)\r\nreturn XZ_DATA_ERROR;\r\nif (s->temp.buf[s->temp.pos++] != 0x21)\r\nreturn XZ_OPTIONS_ERROR;\r\nif (s->temp.buf[s->temp.pos++] != 0x01)\r\nreturn XZ_OPTIONS_ERROR;\r\nif (s->temp.size - s->temp.pos < 1)\r\nreturn XZ_DATA_ERROR;\r\nret = xz_dec_lzma2_reset(s->lzma2, s->temp.buf[s->temp.pos++]);\r\nif (ret != XZ_OK)\r\nreturn ret;\r\nwhile (s->temp.pos < s->temp.size)\r\nif (s->temp.buf[s->temp.pos++] != 0x00)\r\nreturn XZ_OPTIONS_ERROR;\r\ns->temp.pos = 0;\r\ns->block.compressed = 0;\r\ns->block.uncompressed = 0;\r\nreturn XZ_OK;\r\n}\r\nstatic enum xz_ret dec_main(struct xz_dec *s, struct xz_buf *b)\r\n{\r\nenum xz_ret ret;\r\ns->in_start = b->in_pos;\r\nwhile (true) {\r\nswitch (s->sequence) {\r\ncase SEQ_STREAM_HEADER:\r\nif (!fill_temp(s, b))\r\nreturn XZ_OK;\r\ns->sequence = SEQ_BLOCK_START;\r\nret = dec_stream_header(s);\r\nif (ret != XZ_OK)\r\nreturn ret;\r\ncase SEQ_BLOCK_START:\r\nif (b->in_pos == b->in_size)\r\nreturn XZ_OK;\r\nif (b->in[b->in_pos] == 0) {\r\ns->in_start = b->in_pos++;\r\ns->sequence = SEQ_INDEX;\r\nbreak;\r\n}\r\ns->block_header.size\r\n= ((uint32_t)b->in[b->in_pos] + 1) * 4;\r\ns->temp.size = s->block_header.size;\r\ns->temp.pos = 0;\r\ns->sequence = SEQ_BLOCK_HEADER;\r\ncase SEQ_BLOCK_HEADER:\r\nif (!fill_temp(s, b))\r\nreturn XZ_OK;\r\nret = dec_block_header(s);\r\nif (ret != XZ_OK)\r\nreturn ret;\r\ns->sequence = SEQ_BLOCK_UNCOMPRESS;\r\ncase SEQ_BLOCK_UNCOMPRESS:\r\nret = dec_block(s, b);\r\nif (ret != XZ_STREAM_END)\r\nreturn ret;\r\ns->sequence = SEQ_BLOCK_PADDING;\r\ncase SEQ_BLOCK_PADDING:\r\nwhile (s->block.compressed & 3) {\r\nif (b->in_pos == b->in_size)\r\nreturn XZ_OK;\r\nif (b->in[b->in_pos++] != 0)\r\nreturn XZ_DATA_ERROR;\r\n++s->block.compressed;\r\n}\r\ns->sequence = SEQ_BLOCK_CHECK;\r\ncase SEQ_BLOCK_CHECK:\r\nif (s->check_type == XZ_CHECK_CRC32) {\r\nret = crc32_validate(s, b);\r\nif (ret != XZ_STREAM_END)\r\nreturn ret;\r\n}\r\n#ifdef XZ_DEC_ANY_CHECK\r\nelse if (!check_skip(s, b)) {\r\nreturn XZ_OK;\r\n}\r\n#endif\r\ns->sequence = SEQ_BLOCK_START;\r\nbreak;\r\ncase SEQ_INDEX:\r\nret = dec_index(s, b);\r\nif (ret != XZ_STREAM_END)\r\nreturn ret;\r\ns->sequence = SEQ_INDEX_PADDING;\r\ncase SEQ_INDEX_PADDING:\r\nwhile ((s->index.size + (b->in_pos - s->in_start))\r\n& 3) {\r\nif (b->in_pos == b->in_size) {\r\nindex_update(s, b);\r\nreturn XZ_OK;\r\n}\r\nif (b->in[b->in_pos++] != 0)\r\nreturn XZ_DATA_ERROR;\r\n}\r\nindex_update(s, b);\r\nif (!memeq(&s->block.hash, &s->index.hash,\r\nsizeof(s->block.hash)))\r\nreturn XZ_DATA_ERROR;\r\ns->sequence = SEQ_INDEX_CRC32;\r\ncase SEQ_INDEX_CRC32:\r\nret = crc32_validate(s, b);\r\nif (ret != XZ_STREAM_END)\r\nreturn ret;\r\ns->temp.size = STREAM_HEADER_SIZE;\r\ns->sequence = SEQ_STREAM_FOOTER;\r\ncase SEQ_STREAM_FOOTER:\r\nif (!fill_temp(s, b))\r\nreturn XZ_OK;\r\nreturn dec_stream_footer(s);\r\n}\r\n}\r\n}\r\nXZ_EXTERN enum xz_ret xz_dec_run(struct xz_dec *s, struct xz_buf *b)\r\n{\r\nsize_t in_start;\r\nsize_t out_start;\r\nenum xz_ret ret;\r\nif (DEC_IS_SINGLE(s->mode))\r\nxz_dec_reset(s);\r\nin_start = b->in_pos;\r\nout_start = b->out_pos;\r\nret = dec_main(s, b);\r\nif (DEC_IS_SINGLE(s->mode)) {\r\nif (ret == XZ_OK)\r\nret = b->in_pos == b->in_size\r\n? XZ_DATA_ERROR : XZ_BUF_ERROR;\r\nif (ret != XZ_STREAM_END) {\r\nb->in_pos = in_start;\r\nb->out_pos = out_start;\r\n}\r\n} else if (ret == XZ_OK && in_start == b->in_pos\r\n&& out_start == b->out_pos) {\r\nif (s->allow_buf_error)\r\nret = XZ_BUF_ERROR;\r\ns->allow_buf_error = true;\r\n} else {\r\ns->allow_buf_error = false;\r\n}\r\nreturn ret;\r\n}\r\nXZ_EXTERN struct xz_dec *xz_dec_init(enum xz_mode mode, uint32_t dict_max)\r\n{\r\nstruct xz_dec *s = kmalloc(sizeof(*s), GFP_KERNEL);\r\nif (s == NULL)\r\nreturn NULL;\r\ns->mode = mode;\r\n#ifdef XZ_DEC_BCJ\r\ns->bcj = xz_dec_bcj_create(DEC_IS_SINGLE(mode));\r\nif (s->bcj == NULL)\r\ngoto error_bcj;\r\n#endif\r\ns->lzma2 = xz_dec_lzma2_create(mode, dict_max);\r\nif (s->lzma2 == NULL)\r\ngoto error_lzma2;\r\nxz_dec_reset(s);\r\nreturn s;\r\nerror_lzma2:\r\n#ifdef XZ_DEC_BCJ\r\nxz_dec_bcj_end(s->bcj);\r\nerror_bcj:\r\n#endif\r\nkfree(s);\r\nreturn NULL;\r\n}\r\nXZ_EXTERN void xz_dec_reset(struct xz_dec *s)\r\n{\r\ns->sequence = SEQ_STREAM_HEADER;\r\ns->allow_buf_error = false;\r\ns->pos = 0;\r\ns->crc32 = 0;\r\nmemzero(&s->block, sizeof(s->block));\r\nmemzero(&s->index, sizeof(s->index));\r\ns->temp.pos = 0;\r\ns->temp.size = STREAM_HEADER_SIZE;\r\n}\r\nXZ_EXTERN void xz_dec_end(struct xz_dec *s)\r\n{\r\nif (s != NULL) {\r\nxz_dec_lzma2_end(s->lzma2);\r\n#ifdef XZ_DEC_BCJ\r\nxz_dec_bcj_end(s->bcj);\r\n#endif\r\nkfree(s);\r\n}\r\n}
