static void ipu_fb_enable(struct ipu_crtc *ipu_crtc)\r\n{\r\nstruct ipu_soc *ipu = dev_get_drvdata(ipu_crtc->dev->parent);\r\nif (ipu_crtc->enabled)\r\nreturn;\r\nipu_dc_enable(ipu);\r\nipu_plane_enable(ipu_crtc->plane[0]);\r\nipu_dc_enable_channel(ipu_crtc->dc);\r\nipu_di_enable(ipu_crtc->di);\r\nipu_crtc->enabled = 1;\r\n}\r\nstatic void ipu_fb_disable(struct ipu_crtc *ipu_crtc)\r\n{\r\nstruct ipu_soc *ipu = dev_get_drvdata(ipu_crtc->dev->parent);\r\nif (!ipu_crtc->enabled)\r\nreturn;\r\nipu_dc_disable_channel(ipu_crtc->dc);\r\nipu_di_disable(ipu_crtc->di);\r\nipu_plane_disable(ipu_crtc->plane[0]);\r\nipu_dc_disable(ipu);\r\nipu_crtc->enabled = 0;\r\n}\r\nstatic void ipu_crtc_dpms(struct drm_crtc *crtc, int mode)\r\n{\r\nstruct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);\r\ndev_dbg(ipu_crtc->dev, "%s mode: %d\n", __func__, mode);\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\nipu_fb_enable(ipu_crtc);\r\nbreak;\r\ncase DRM_MODE_DPMS_STANDBY:\r\ncase DRM_MODE_DPMS_SUSPEND:\r\ncase DRM_MODE_DPMS_OFF:\r\nipu_fb_disable(ipu_crtc);\r\nbreak;\r\n}\r\n}\r\nstatic int ipu_page_flip(struct drm_crtc *crtc,\r\nstruct drm_framebuffer *fb,\r\nstruct drm_pending_vblank_event *event,\r\nuint32_t page_flip_flags)\r\n{\r\nstruct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);\r\nint ret;\r\nif (ipu_crtc->newfb)\r\nreturn -EBUSY;\r\nret = imx_drm_crtc_vblank_get(ipu_crtc->imx_crtc);\r\nif (ret) {\r\ndev_dbg(ipu_crtc->dev, "failed to acquire vblank counter\n");\r\nlist_del(&event->base.link);\r\nreturn ret;\r\n}\r\nipu_crtc->newfb = fb;\r\nipu_crtc->page_flip_event = event;\r\ncrtc->primary->fb = fb;\r\nreturn 0;\r\n}\r\nstatic int ipu_crtc_mode_set(struct drm_crtc *crtc,\r\nstruct drm_display_mode *orig_mode,\r\nstruct drm_display_mode *mode,\r\nint x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_encoder *encoder;\r\nstruct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);\r\nstruct ipu_di_signal_cfg sig_cfg = {};\r\nunsigned long encoder_types = 0;\r\nint ret;\r\ndev_dbg(ipu_crtc->dev, "%s: mode->hdisplay: %d\n", __func__,\r\nmode->hdisplay);\r\ndev_dbg(ipu_crtc->dev, "%s: mode->vdisplay: %d\n", __func__,\r\nmode->vdisplay);\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head)\r\nif (encoder->crtc == crtc)\r\nencoder_types |= BIT(encoder->encoder_type);\r\ndev_dbg(ipu_crtc->dev, "%s: attached to encoder types 0x%lx\n",\r\n__func__, encoder_types);\r\nif (encoder_types & (BIT(DRM_MODE_ENCODER_DAC) |\r\nBIT(DRM_MODE_ENCODER_LVDS)))\r\nsig_cfg.clkflags = IPU_DI_CLKMODE_SYNC | IPU_DI_CLKMODE_EXT;\r\nelse if (encoder_types & BIT(DRM_MODE_ENCODER_TVDAC))\r\nsig_cfg.clkflags = IPU_DI_CLKMODE_EXT;\r\nelse\r\nsig_cfg.clkflags = 0;\r\nsig_cfg.enable_pol = 1;\r\nsig_cfg.clk_pol = 0;\r\nsig_cfg.bus_format = ipu_crtc->bus_format;\r\nsig_cfg.v_to_h_sync = 0;\r\nsig_cfg.hsync_pin = ipu_crtc->di_hsync_pin;\r\nsig_cfg.vsync_pin = ipu_crtc->di_vsync_pin;\r\ndrm_display_mode_to_videomode(mode, &sig_cfg.mode);\r\nret = ipu_dc_init_sync(ipu_crtc->dc, ipu_crtc->di,\r\nmode->flags & DRM_MODE_FLAG_INTERLACE,\r\nipu_crtc->bus_format, mode->hdisplay);\r\nif (ret) {\r\ndev_err(ipu_crtc->dev,\r\n"initializing display controller failed with %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = ipu_di_init_sync_panel(ipu_crtc->di, &sig_cfg);\r\nif (ret) {\r\ndev_err(ipu_crtc->dev,\r\n"initializing panel failed with %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn ipu_plane_mode_set(ipu_crtc->plane[0], crtc, mode,\r\ncrtc->primary->fb,\r\n0, 0, mode->hdisplay, mode->vdisplay,\r\nx, y, mode->hdisplay, mode->vdisplay,\r\nmode->flags & DRM_MODE_FLAG_INTERLACE);\r\n}\r\nstatic void ipu_crtc_handle_pageflip(struct ipu_crtc *ipu_crtc)\r\n{\r\nunsigned long flags;\r\nstruct drm_device *drm = ipu_crtc->base.dev;\r\nspin_lock_irqsave(&drm->event_lock, flags);\r\nif (ipu_crtc->page_flip_event)\r\ndrm_send_vblank_event(drm, -1, ipu_crtc->page_flip_event);\r\nipu_crtc->page_flip_event = NULL;\r\nimx_drm_crtc_vblank_put(ipu_crtc->imx_crtc);\r\nspin_unlock_irqrestore(&drm->event_lock, flags);\r\n}\r\nstatic irqreturn_t ipu_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct ipu_crtc *ipu_crtc = dev_id;\r\nimx_drm_handle_vblank(ipu_crtc->imx_crtc);\r\nif (ipu_crtc->newfb) {\r\nstruct ipu_plane *plane = ipu_crtc->plane[0];\r\nipu_crtc->newfb = NULL;\r\nipu_plane_set_base(plane, ipu_crtc->base.primary->fb,\r\nplane->x, plane->y);\r\nipu_crtc_handle_pageflip(ipu_crtc);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic bool ipu_crtc_mode_fixup(struct drm_crtc *crtc,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);\r\nstruct videomode vm;\r\nint ret;\r\ndrm_display_mode_to_videomode(adjusted_mode, &vm);\r\nret = ipu_di_adjust_videomode(ipu_crtc->di, &vm);\r\nif (ret)\r\nreturn false;\r\ndrm_display_mode_from_videomode(&vm, adjusted_mode);\r\nreturn true;\r\n}\r\nstatic void ipu_crtc_prepare(struct drm_crtc *crtc)\r\n{\r\nstruct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);\r\nipu_fb_disable(ipu_crtc);\r\n}\r\nstatic void ipu_crtc_commit(struct drm_crtc *crtc)\r\n{\r\nstruct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);\r\nipu_fb_enable(ipu_crtc);\r\n}\r\nstatic int ipu_enable_vblank(struct drm_crtc *crtc)\r\n{\r\nreturn 0;\r\n}\r\nstatic void ipu_disable_vblank(struct drm_crtc *crtc)\r\n{\r\nstruct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);\r\nipu_crtc->page_flip_event = NULL;\r\nipu_crtc->newfb = NULL;\r\n}\r\nstatic int ipu_set_interface_pix_fmt(struct drm_crtc *crtc,\r\nu32 bus_format, int hsync_pin, int vsync_pin)\r\n{\r\nstruct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);\r\nipu_crtc->bus_format = bus_format;\r\nipu_crtc->di_hsync_pin = hsync_pin;\r\nipu_crtc->di_vsync_pin = vsync_pin;\r\nreturn 0;\r\n}\r\nstatic void ipu_put_resources(struct ipu_crtc *ipu_crtc)\r\n{\r\nif (!IS_ERR_OR_NULL(ipu_crtc->dc))\r\nipu_dc_put(ipu_crtc->dc);\r\nif (!IS_ERR_OR_NULL(ipu_crtc->di))\r\nipu_di_put(ipu_crtc->di);\r\n}\r\nstatic int ipu_get_resources(struct ipu_crtc *ipu_crtc,\r\nstruct ipu_client_platformdata *pdata)\r\n{\r\nstruct ipu_soc *ipu = dev_get_drvdata(ipu_crtc->dev->parent);\r\nint ret;\r\nipu_crtc->dc = ipu_dc_get(ipu, pdata->dc);\r\nif (IS_ERR(ipu_crtc->dc)) {\r\nret = PTR_ERR(ipu_crtc->dc);\r\ngoto err_out;\r\n}\r\nipu_crtc->di = ipu_di_get(ipu, pdata->di);\r\nif (IS_ERR(ipu_crtc->di)) {\r\nret = PTR_ERR(ipu_crtc->di);\r\ngoto err_out;\r\n}\r\nreturn 0;\r\nerr_out:\r\nipu_put_resources(ipu_crtc);\r\nreturn ret;\r\n}\r\nstatic int ipu_crtc_init(struct ipu_crtc *ipu_crtc,\r\nstruct ipu_client_platformdata *pdata, struct drm_device *drm)\r\n{\r\nstruct ipu_soc *ipu = dev_get_drvdata(ipu_crtc->dev->parent);\r\nint dp = -EINVAL;\r\nint ret;\r\nint id;\r\nret = ipu_get_resources(ipu_crtc, pdata);\r\nif (ret) {\r\ndev_err(ipu_crtc->dev, "getting resources failed with %d.\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = imx_drm_add_crtc(drm, &ipu_crtc->base, &ipu_crtc->imx_crtc,\r\n&ipu_crtc_helper_funcs, ipu_crtc->dev->of_node);\r\nif (ret) {\r\ndev_err(ipu_crtc->dev, "adding crtc failed with %d.\n", ret);\r\ngoto err_put_resources;\r\n}\r\nif (pdata->dp >= 0)\r\ndp = IPU_DP_FLOW_SYNC_BG;\r\nid = imx_drm_crtc_id(ipu_crtc->imx_crtc);\r\nipu_crtc->plane[0] = ipu_plane_init(ipu_crtc->base.dev, ipu,\r\npdata->dma[0], dp, BIT(id), true);\r\nret = ipu_plane_get_resources(ipu_crtc->plane[0]);\r\nif (ret) {\r\ndev_err(ipu_crtc->dev, "getting plane 0 resources failed with %d.\n",\r\nret);\r\ngoto err_remove_crtc;\r\n}\r\nif (pdata->dp >= 0 && pdata->dma[1] > 0) {\r\nipu_crtc->plane[1] = ipu_plane_init(ipu_crtc->base.dev, ipu,\r\npdata->dma[1],\r\nIPU_DP_FLOW_SYNC_FG,\r\nBIT(id), false);\r\nif (IS_ERR(ipu_crtc->plane[1]))\r\nipu_crtc->plane[1] = NULL;\r\n}\r\nipu_crtc->irq = ipu_plane_irq(ipu_crtc->plane[0]);\r\nret = devm_request_irq(ipu_crtc->dev, ipu_crtc->irq, ipu_irq_handler, 0,\r\n"imx_drm", ipu_crtc);\r\nif (ret < 0) {\r\ndev_err(ipu_crtc->dev, "irq request failed with %d.\n", ret);\r\ngoto err_put_plane_res;\r\n}\r\nreturn 0;\r\nerr_put_plane_res:\r\nipu_plane_put_resources(ipu_crtc->plane[0]);\r\nerr_remove_crtc:\r\nimx_drm_remove_crtc(ipu_crtc->imx_crtc);\r\nerr_put_resources:\r\nipu_put_resources(ipu_crtc);\r\nreturn ret;\r\n}\r\nstatic struct device_node *ipu_drm_get_port_by_id(struct device_node *parent,\r\nint port_id)\r\n{\r\nstruct device_node *port;\r\nint id, ret;\r\nport = of_get_child_by_name(parent, "port");\r\nwhile (port) {\r\nret = of_property_read_u32(port, "reg", &id);\r\nif (!ret && id == port_id)\r\nreturn port;\r\ndo {\r\nport = of_get_next_child(parent, port);\r\nif (!port)\r\nreturn NULL;\r\n} while (of_node_cmp(port->name, "port"));\r\n}\r\nreturn NULL;\r\n}\r\nstatic int ipu_drm_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct ipu_client_platformdata *pdata = dev->platform_data;\r\nstruct drm_device *drm = data;\r\nstruct ipu_crtc *ipu_crtc;\r\nint ret;\r\nipu_crtc = devm_kzalloc(dev, sizeof(*ipu_crtc), GFP_KERNEL);\r\nif (!ipu_crtc)\r\nreturn -ENOMEM;\r\nipu_crtc->dev = dev;\r\nret = ipu_crtc_init(ipu_crtc, pdata, drm);\r\nif (ret)\r\nreturn ret;\r\ndev_set_drvdata(dev, ipu_crtc);\r\nreturn 0;\r\n}\r\nstatic void ipu_drm_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct ipu_crtc *ipu_crtc = dev_get_drvdata(dev);\r\nimx_drm_remove_crtc(ipu_crtc->imx_crtc);\r\nipu_plane_put_resources(ipu_crtc->plane[0]);\r\nipu_put_resources(ipu_crtc);\r\n}\r\nstatic int ipu_drm_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct ipu_client_platformdata *pdata = dev->platform_data;\r\nint ret;\r\nif (!dev->platform_data)\r\nreturn -EINVAL;\r\nif (!dev->of_node) {\r\ndev->of_node = ipu_drm_get_port_by_id(dev->parent->of_node,\r\npdata->di + 2);\r\nif (!dev->of_node) {\r\ndev_err(dev, "missing port@%d node in %s\n",\r\npdata->di + 2, dev->parent->of_node->full_name);\r\nreturn -ENODEV;\r\n}\r\n}\r\nret = dma_set_coherent_mask(dev, DMA_BIT_MASK(32));\r\nif (ret)\r\nreturn ret;\r\nreturn component_add(dev, &ipu_crtc_ops);\r\n}\r\nstatic int ipu_drm_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &ipu_crtc_ops);\r\nreturn 0;\r\n}
