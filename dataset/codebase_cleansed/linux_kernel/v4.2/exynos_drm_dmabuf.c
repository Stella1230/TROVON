static struct exynos_drm_gem_obj *dma_buf_to_obj(struct dma_buf *buf)\r\n{\r\nreturn to_exynos_gem_obj(buf->priv);\r\n}\r\nstatic int exynos_gem_attach_dma_buf(struct dma_buf *dmabuf,\r\nstruct device *dev,\r\nstruct dma_buf_attachment *attach)\r\n{\r\nstruct exynos_drm_dmabuf_attachment *exynos_attach;\r\nexynos_attach = kzalloc(sizeof(*exynos_attach), GFP_KERNEL);\r\nif (!exynos_attach)\r\nreturn -ENOMEM;\r\nexynos_attach->dir = DMA_NONE;\r\nattach->priv = exynos_attach;\r\nreturn 0;\r\n}\r\nstatic void exynos_gem_detach_dma_buf(struct dma_buf *dmabuf,\r\nstruct dma_buf_attachment *attach)\r\n{\r\nstruct exynos_drm_dmabuf_attachment *exynos_attach = attach->priv;\r\nstruct sg_table *sgt;\r\nif (!exynos_attach)\r\nreturn;\r\nsgt = &exynos_attach->sgt;\r\nif (exynos_attach->dir != DMA_NONE)\r\ndma_unmap_sg(attach->dev, sgt->sgl, sgt->nents,\r\nexynos_attach->dir);\r\nsg_free_table(sgt);\r\nkfree(exynos_attach);\r\nattach->priv = NULL;\r\n}\r\nstatic struct sg_table *\r\nexynos_gem_map_dma_buf(struct dma_buf_attachment *attach,\r\nenum dma_data_direction dir)\r\n{\r\nstruct exynos_drm_dmabuf_attachment *exynos_attach = attach->priv;\r\nstruct exynos_drm_gem_obj *gem_obj = dma_buf_to_obj(attach->dmabuf);\r\nstruct drm_device *dev = gem_obj->base.dev;\r\nstruct exynos_drm_gem_buf *buf;\r\nstruct scatterlist *rd, *wr;\r\nstruct sg_table *sgt = NULL;\r\nunsigned int i;\r\nint nents, ret;\r\nif (exynos_attach->dir == dir && exynos_attach->is_mapped)\r\nreturn &exynos_attach->sgt;\r\nbuf = gem_obj->buffer;\r\nif (!buf) {\r\nDRM_ERROR("buffer is null.\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nsgt = &exynos_attach->sgt;\r\nret = sg_alloc_table(sgt, buf->sgt->orig_nents, GFP_KERNEL);\r\nif (ret) {\r\nDRM_ERROR("failed to alloc sgt.\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nmutex_lock(&dev->struct_mutex);\r\nrd = buf->sgt->sgl;\r\nwr = sgt->sgl;\r\nfor (i = 0; i < sgt->orig_nents; ++i) {\r\nsg_set_page(wr, sg_page(rd), rd->length, rd->offset);\r\nrd = sg_next(rd);\r\nwr = sg_next(wr);\r\n}\r\nif (dir != DMA_NONE) {\r\nnents = dma_map_sg(attach->dev, sgt->sgl, sgt->orig_nents, dir);\r\nif (!nents) {\r\nDRM_ERROR("failed to map sgl with iommu.\n");\r\nsg_free_table(sgt);\r\nsgt = ERR_PTR(-EIO);\r\ngoto err_unlock;\r\n}\r\n}\r\nexynos_attach->is_mapped = true;\r\nexynos_attach->dir = dir;\r\nattach->priv = exynos_attach;\r\nDRM_DEBUG_PRIME("buffer size = 0x%lx\n", buf->size);\r\nerr_unlock:\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn sgt;\r\n}\r\nstatic void exynos_gem_unmap_dma_buf(struct dma_buf_attachment *attach,\r\nstruct sg_table *sgt,\r\nenum dma_data_direction dir)\r\n{\r\n}\r\nstatic void *exynos_gem_dmabuf_kmap_atomic(struct dma_buf *dma_buf,\r\nunsigned long page_num)\r\n{\r\nreturn NULL;\r\n}\r\nstatic void exynos_gem_dmabuf_kunmap_atomic(struct dma_buf *dma_buf,\r\nunsigned long page_num,\r\nvoid *addr)\r\n{\r\n}\r\nstatic void *exynos_gem_dmabuf_kmap(struct dma_buf *dma_buf,\r\nunsigned long page_num)\r\n{\r\nreturn NULL;\r\n}\r\nstatic void exynos_gem_dmabuf_kunmap(struct dma_buf *dma_buf,\r\nunsigned long page_num, void *addr)\r\n{\r\n}\r\nstatic int exynos_gem_dmabuf_mmap(struct dma_buf *dma_buf,\r\nstruct vm_area_struct *vma)\r\n{\r\nreturn -ENOTTY;\r\n}\r\nstruct dma_buf *exynos_dmabuf_prime_export(struct drm_device *drm_dev,\r\nstruct drm_gem_object *obj, int flags)\r\n{\r\nstruct exynos_drm_gem_obj *exynos_gem_obj = to_exynos_gem_obj(obj);\r\nDEFINE_DMA_BUF_EXPORT_INFO(exp_info);\r\nexp_info.ops = &exynos_dmabuf_ops;\r\nexp_info.size = exynos_gem_obj->base.size;\r\nexp_info.flags = flags;\r\nexp_info.priv = obj;\r\nreturn dma_buf_export(&exp_info);\r\n}\r\nstruct drm_gem_object *exynos_dmabuf_prime_import(struct drm_device *drm_dev,\r\nstruct dma_buf *dma_buf)\r\n{\r\nstruct dma_buf_attachment *attach;\r\nstruct sg_table *sgt;\r\nstruct scatterlist *sgl;\r\nstruct exynos_drm_gem_obj *exynos_gem_obj;\r\nstruct exynos_drm_gem_buf *buffer;\r\nint ret;\r\nif (dma_buf->ops == &exynos_dmabuf_ops) {\r\nstruct drm_gem_object *obj;\r\nobj = dma_buf->priv;\r\nif (obj->dev == drm_dev) {\r\ndrm_gem_object_reference(obj);\r\nreturn obj;\r\n}\r\n}\r\nattach = dma_buf_attach(dma_buf, drm_dev->dev);\r\nif (IS_ERR(attach))\r\nreturn ERR_PTR(-EINVAL);\r\nget_dma_buf(dma_buf);\r\nsgt = dma_buf_map_attachment(attach, DMA_BIDIRECTIONAL);\r\nif (IS_ERR(sgt)) {\r\nret = PTR_ERR(sgt);\r\ngoto err_buf_detach;\r\n}\r\nbuffer = kzalloc(sizeof(*buffer), GFP_KERNEL);\r\nif (!buffer) {\r\nret = -ENOMEM;\r\ngoto err_unmap_attach;\r\n}\r\nexynos_gem_obj = exynos_drm_gem_init(drm_dev, dma_buf->size);\r\nif (!exynos_gem_obj) {\r\nret = -ENOMEM;\r\ngoto err_free_buffer;\r\n}\r\nsgl = sgt->sgl;\r\nbuffer->size = dma_buf->size;\r\nbuffer->dma_addr = sg_dma_address(sgl);\r\nif (sgt->nents == 1) {\r\nexynos_gem_obj->flags |= EXYNOS_BO_CONTIG;\r\n} else {\r\nexynos_gem_obj->flags |= EXYNOS_BO_NONCONTIG;\r\n}\r\nexynos_gem_obj->buffer = buffer;\r\nbuffer->sgt = sgt;\r\nexynos_gem_obj->base.import_attach = attach;\r\nDRM_DEBUG_PRIME("dma_addr = %pad, size = 0x%lx\n", &buffer->dma_addr,\r\nbuffer->size);\r\nreturn &exynos_gem_obj->base;\r\nerr_free_buffer:\r\nkfree(buffer);\r\nbuffer = NULL;\r\nerr_unmap_attach:\r\ndma_buf_unmap_attachment(attach, sgt, DMA_BIDIRECTIONAL);\r\nerr_buf_detach:\r\ndma_buf_detach(dma_buf, attach);\r\ndma_buf_put(dma_buf);\r\nreturn ERR_PTR(ret);\r\n}
