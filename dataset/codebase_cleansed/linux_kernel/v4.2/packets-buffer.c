int iso_packets_buffer_init(struct iso_packets_buffer *b, struct fw_unit *unit,\r\nunsigned int count, unsigned int packet_size,\r\nenum dma_data_direction direction)\r\n{\r\nunsigned int packets_per_page, pages;\r\nunsigned int i, page_index, offset_in_page;\r\nvoid *p;\r\nint err;\r\nb->packets = kmalloc(count * sizeof(*b->packets), GFP_KERNEL);\r\nif (!b->packets) {\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\npacket_size = L1_CACHE_ALIGN(packet_size);\r\npackets_per_page = PAGE_SIZE / packet_size;\r\nif (WARN_ON(!packets_per_page)) {\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\npages = DIV_ROUND_UP(count, packets_per_page);\r\nerr = fw_iso_buffer_init(&b->iso_buffer, fw_parent_device(unit)->card,\r\npages, direction);\r\nif (err < 0)\r\ngoto err_packets;\r\nfor (i = 0; i < count; ++i) {\r\npage_index = i / packets_per_page;\r\np = page_address(b->iso_buffer.pages[page_index]);\r\noffset_in_page = (i % packets_per_page) * packet_size;\r\nb->packets[i].buffer = p + offset_in_page;\r\nb->packets[i].offset = page_index * PAGE_SIZE + offset_in_page;\r\n}\r\nreturn 0;\r\nerr_packets:\r\nkfree(b->packets);\r\nerror:\r\nreturn err;\r\n}\r\nvoid iso_packets_buffer_destroy(struct iso_packets_buffer *b,\r\nstruct fw_unit *unit)\r\n{\r\nfw_iso_buffer_destroy(&b->iso_buffer, fw_parent_device(unit)->card);\r\nkfree(b->packets);\r\n}
