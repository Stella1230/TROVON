static void change_color(struct usb_led *led)\r\n{\r\nint retval = 0;\r\nunsigned char *buffer;\r\nint actlength;\r\nbuffer = kmalloc(8, GFP_KERNEL);\r\nif (!buffer) {\r\ndev_err(&led->udev->dev, "out of memory\n");\r\nreturn;\r\n}\r\nswitch (led->type) {\r\ncase DELCOM_VISUAL_SIGNAL_INDICATOR: {\r\nunsigned char color = 0x07;\r\nif (led->blue)\r\ncolor &= ~0x04;\r\nif (led->red)\r\ncolor &= ~0x02;\r\nif (led->green)\r\ncolor &= ~0x01;\r\ndev_dbg(&led->udev->dev,\r\n"blue = %d, red = %d, green = %d, color = %.2x\n",\r\nled->blue, led->red, led->green, color);\r\nretval = usb_control_msg(led->udev,\r\nusb_sndctrlpipe(led->udev, 0),\r\n0x12,\r\n0xc8,\r\n(0x02 * 0x100) + 0x0a,\r\n(0x00 * 0x100) + color,\r\nbuffer,\r\n8,\r\n2000);\r\nbreak;\r\n}\r\ncase DREAM_CHEEKY_WEBMAIL_NOTIFIER:\r\ndev_dbg(&led->udev->dev,\r\n"red = %d, green = %d, blue = %d\n",\r\nled->red, led->green, led->blue);\r\nbuffer[0] = led->red;\r\nbuffer[1] = led->green;\r\nbuffer[2] = led->blue;\r\nbuffer[3] = buffer[4] = buffer[5] = 0;\r\nbuffer[6] = 0x1a;\r\nbuffer[7] = 0x05;\r\nretval = usb_control_msg(led->udev,\r\nusb_sndctrlpipe(led->udev, 0),\r\n0x09,\r\n0x21,\r\n0x200,\r\n0,\r\nbuffer,\r\n8,\r\n2000);\r\nbreak;\r\ncase RISO_KAGAKU_LED:\r\nbuffer[0] = RISO_KAGAKU_IX(led->red, led->green, led->blue);\r\nbuffer[1] = 0;\r\nbuffer[2] = 0;\r\nbuffer[3] = 0;\r\nbuffer[4] = 0;\r\nretval = usb_interrupt_msg(led->udev,\r\nusb_sndctrlpipe(led->udev, 2),\r\nbuffer, 5, &actlength, 1000 );\r\nbreak;\r\ndefault:\r\ndev_err(&led->udev->dev, "unknown device type %d\n", led->type);\r\n}\r\nif (retval)\r\ndev_dbg(&led->udev->dev, "retval = %d\n", retval);\r\nkfree(buffer);\r\n}\r\nstatic int led_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(interface);\r\nstruct usb_led *dev = NULL;\r\nint retval = -ENOMEM;\r\ndev = kzalloc(sizeof(struct usb_led), GFP_KERNEL);\r\nif (dev == NULL) {\r\ndev_err(&interface->dev, "out of memory\n");\r\ngoto error_mem;\r\n}\r\ndev->udev = usb_get_dev(udev);\r\ndev->type = id->driver_info;\r\nusb_set_intfdata(interface, dev);\r\nretval = device_create_file(&interface->dev, &dev_attr_blue);\r\nif (retval)\r\ngoto error;\r\nretval = device_create_file(&interface->dev, &dev_attr_red);\r\nif (retval)\r\ngoto error;\r\nretval = device_create_file(&interface->dev, &dev_attr_green);\r\nif (retval)\r\ngoto error;\r\nif (dev->type == DREAM_CHEEKY_WEBMAIL_NOTIFIER) {\r\nunsigned char *enable;\r\nenable = kmemdup("\x1f\x02\0\x5f\0\0\x1a\x03", 8, GFP_KERNEL);\r\nif (!enable) {\r\ndev_err(&interface->dev, "out of memory\n");\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\nretval = usb_control_msg(udev,\r\nusb_sndctrlpipe(udev, 0),\r\n0x09,\r\n0x21,\r\n0x200,\r\n0,\r\nenable,\r\n8,\r\n2000);\r\nkfree(enable);\r\nif (retval != 8)\r\ngoto error;\r\n}\r\ndev_info(&interface->dev, "USB LED device now attached\n");\r\nreturn 0;\r\nerror:\r\ndevice_remove_file(&interface->dev, &dev_attr_blue);\r\ndevice_remove_file(&interface->dev, &dev_attr_red);\r\ndevice_remove_file(&interface->dev, &dev_attr_green);\r\nusb_set_intfdata(interface, NULL);\r\nusb_put_dev(dev->udev);\r\nkfree(dev);\r\nerror_mem:\r\nreturn retval;\r\n}\r\nstatic void led_disconnect(struct usb_interface *interface)\r\n{\r\nstruct usb_led *dev;\r\ndev = usb_get_intfdata(interface);\r\ndevice_remove_file(&interface->dev, &dev_attr_blue);\r\ndevice_remove_file(&interface->dev, &dev_attr_red);\r\ndevice_remove_file(&interface->dev, &dev_attr_green);\r\nusb_set_intfdata(interface, NULL);\r\nusb_put_dev(dev->udev);\r\nkfree(dev);\r\ndev_info(&interface->dev, "USB LED now disconnected\n");\r\n}
