int btrfs_alloc_stripe_hash_table(struct btrfs_fs_info *info)\r\n{\r\nstruct btrfs_stripe_hash_table *table;\r\nstruct btrfs_stripe_hash_table *x;\r\nstruct btrfs_stripe_hash *cur;\r\nstruct btrfs_stripe_hash *h;\r\nint num_entries = 1 << BTRFS_STRIPE_HASH_TABLE_BITS;\r\nint i;\r\nint table_size;\r\nif (info->stripe_hash_table)\r\nreturn 0;\r\ntable_size = sizeof(*table) + sizeof(*h) * num_entries;\r\ntable = kzalloc(table_size, GFP_KERNEL | __GFP_NOWARN | __GFP_REPEAT);\r\nif (!table) {\r\ntable = vzalloc(table_size);\r\nif (!table)\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&table->cache_lock);\r\nINIT_LIST_HEAD(&table->stripe_cache);\r\nh = table->table;\r\nfor (i = 0; i < num_entries; i++) {\r\ncur = h + i;\r\nINIT_LIST_HEAD(&cur->hash_list);\r\nspin_lock_init(&cur->lock);\r\ninit_waitqueue_head(&cur->wait);\r\n}\r\nx = cmpxchg(&info->stripe_hash_table, NULL, table);\r\nif (x)\r\nkvfree(x);\r\nreturn 0;\r\n}\r\nstatic void cache_rbio_pages(struct btrfs_raid_bio *rbio)\r\n{\r\nint i;\r\nchar *s;\r\nchar *d;\r\nint ret;\r\nret = alloc_rbio_pages(rbio);\r\nif (ret)\r\nreturn;\r\nfor (i = 0; i < rbio->nr_pages; i++) {\r\nif (!rbio->bio_pages[i])\r\ncontinue;\r\ns = kmap(rbio->bio_pages[i]);\r\nd = kmap(rbio->stripe_pages[i]);\r\nmemcpy(d, s, PAGE_CACHE_SIZE);\r\nkunmap(rbio->bio_pages[i]);\r\nkunmap(rbio->stripe_pages[i]);\r\nSetPageUptodate(rbio->stripe_pages[i]);\r\n}\r\nset_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\r\n}\r\nstatic int rbio_bucket(struct btrfs_raid_bio *rbio)\r\n{\r\nu64 num = rbio->bbio->raid_map[0];\r\nreturn hash_64(num >> 16, BTRFS_STRIPE_HASH_TABLE_BITS);\r\n}\r\nstatic void steal_rbio(struct btrfs_raid_bio *src, struct btrfs_raid_bio *dest)\r\n{\r\nint i;\r\nstruct page *s;\r\nstruct page *d;\r\nif (!test_bit(RBIO_CACHE_READY_BIT, &src->flags))\r\nreturn;\r\nfor (i = 0; i < dest->nr_pages; i++) {\r\ns = src->stripe_pages[i];\r\nif (!s || !PageUptodate(s)) {\r\ncontinue;\r\n}\r\nd = dest->stripe_pages[i];\r\nif (d)\r\n__free_page(d);\r\ndest->stripe_pages[i] = s;\r\nsrc->stripe_pages[i] = NULL;\r\n}\r\n}\r\nstatic void merge_rbio(struct btrfs_raid_bio *dest,\r\nstruct btrfs_raid_bio *victim)\r\n{\r\nbio_list_merge(&dest->bio_list, &victim->bio_list);\r\ndest->bio_list_bytes += victim->bio_list_bytes;\r\ndest->generic_bio_cnt += victim->generic_bio_cnt;\r\nbio_list_init(&victim->bio_list);\r\n}\r\nstatic void __remove_rbio_from_cache(struct btrfs_raid_bio *rbio)\r\n{\r\nint bucket = rbio_bucket(rbio);\r\nstruct btrfs_stripe_hash_table *table;\r\nstruct btrfs_stripe_hash *h;\r\nint freeit = 0;\r\nif (!test_bit(RBIO_CACHE_BIT, &rbio->flags))\r\nreturn;\r\ntable = rbio->fs_info->stripe_hash_table;\r\nh = table->table + bucket;\r\nspin_lock(&h->lock);\r\nspin_lock(&rbio->bio_list_lock);\r\nif (test_and_clear_bit(RBIO_CACHE_BIT, &rbio->flags)) {\r\nlist_del_init(&rbio->stripe_cache);\r\ntable->cache_size -= 1;\r\nfreeit = 1;\r\nif (bio_list_empty(&rbio->bio_list)) {\r\nif (!list_empty(&rbio->hash_list)) {\r\nlist_del_init(&rbio->hash_list);\r\natomic_dec(&rbio->refs);\r\nBUG_ON(!list_empty(&rbio->plug_list));\r\n}\r\n}\r\n}\r\nspin_unlock(&rbio->bio_list_lock);\r\nspin_unlock(&h->lock);\r\nif (freeit)\r\n__free_raid_bio(rbio);\r\n}\r\nstatic void remove_rbio_from_cache(struct btrfs_raid_bio *rbio)\r\n{\r\nstruct btrfs_stripe_hash_table *table;\r\nunsigned long flags;\r\nif (!test_bit(RBIO_CACHE_BIT, &rbio->flags))\r\nreturn;\r\ntable = rbio->fs_info->stripe_hash_table;\r\nspin_lock_irqsave(&table->cache_lock, flags);\r\n__remove_rbio_from_cache(rbio);\r\nspin_unlock_irqrestore(&table->cache_lock, flags);\r\n}\r\nstatic void btrfs_clear_rbio_cache(struct btrfs_fs_info *info)\r\n{\r\nstruct btrfs_stripe_hash_table *table;\r\nunsigned long flags;\r\nstruct btrfs_raid_bio *rbio;\r\ntable = info->stripe_hash_table;\r\nspin_lock_irqsave(&table->cache_lock, flags);\r\nwhile (!list_empty(&table->stripe_cache)) {\r\nrbio = list_entry(table->stripe_cache.next,\r\nstruct btrfs_raid_bio,\r\nstripe_cache);\r\n__remove_rbio_from_cache(rbio);\r\n}\r\nspin_unlock_irqrestore(&table->cache_lock, flags);\r\n}\r\nvoid btrfs_free_stripe_hash_table(struct btrfs_fs_info *info)\r\n{\r\nif (!info->stripe_hash_table)\r\nreturn;\r\nbtrfs_clear_rbio_cache(info);\r\nkvfree(info->stripe_hash_table);\r\ninfo->stripe_hash_table = NULL;\r\n}\r\nstatic void cache_rbio(struct btrfs_raid_bio *rbio)\r\n{\r\nstruct btrfs_stripe_hash_table *table;\r\nunsigned long flags;\r\nif (!test_bit(RBIO_CACHE_READY_BIT, &rbio->flags))\r\nreturn;\r\ntable = rbio->fs_info->stripe_hash_table;\r\nspin_lock_irqsave(&table->cache_lock, flags);\r\nspin_lock(&rbio->bio_list_lock);\r\nif (!test_and_set_bit(RBIO_CACHE_BIT, &rbio->flags))\r\natomic_inc(&rbio->refs);\r\nif (!list_empty(&rbio->stripe_cache)){\r\nlist_move(&rbio->stripe_cache, &table->stripe_cache);\r\n} else {\r\nlist_add(&rbio->stripe_cache, &table->stripe_cache);\r\ntable->cache_size += 1;\r\n}\r\nspin_unlock(&rbio->bio_list_lock);\r\nif (table->cache_size > RBIO_CACHE_SIZE) {\r\nstruct btrfs_raid_bio *found;\r\nfound = list_entry(table->stripe_cache.prev,\r\nstruct btrfs_raid_bio,\r\nstripe_cache);\r\nif (found != rbio)\r\n__remove_rbio_from_cache(found);\r\n}\r\nspin_unlock_irqrestore(&table->cache_lock, flags);\r\nreturn;\r\n}\r\nstatic void run_xor(void **pages, int src_cnt, ssize_t len)\r\n{\r\nint src_off = 0;\r\nint xor_src_cnt = 0;\r\nvoid *dest = pages[src_cnt];\r\nwhile(src_cnt > 0) {\r\nxor_src_cnt = min(src_cnt, MAX_XOR_BLOCKS);\r\nxor_blocks(xor_src_cnt, len, dest, pages + src_off);\r\nsrc_cnt -= xor_src_cnt;\r\nsrc_off += xor_src_cnt;\r\n}\r\n}\r\nstatic int __rbio_is_full(struct btrfs_raid_bio *rbio)\r\n{\r\nunsigned long size = rbio->bio_list_bytes;\r\nint ret = 1;\r\nif (size != rbio->nr_data * rbio->stripe_len)\r\nret = 0;\r\nBUG_ON(size > rbio->nr_data * rbio->stripe_len);\r\nreturn ret;\r\n}\r\nstatic int rbio_is_full(struct btrfs_raid_bio *rbio)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&rbio->bio_list_lock, flags);\r\nret = __rbio_is_full(rbio);\r\nspin_unlock_irqrestore(&rbio->bio_list_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int rbio_can_merge(struct btrfs_raid_bio *last,\r\nstruct btrfs_raid_bio *cur)\r\n{\r\nif (test_bit(RBIO_RMW_LOCKED_BIT, &last->flags) ||\r\ntest_bit(RBIO_RMW_LOCKED_BIT, &cur->flags))\r\nreturn 0;\r\nif (test_bit(RBIO_CACHE_BIT, &last->flags) ||\r\ntest_bit(RBIO_CACHE_BIT, &cur->flags))\r\nreturn 0;\r\nif (last->bbio->raid_map[0] !=\r\ncur->bbio->raid_map[0])\r\nreturn 0;\r\nif (last->operation != cur->operation)\r\nreturn 0;\r\nif (last->operation == BTRFS_RBIO_PARITY_SCRUB ||\r\ncur->operation == BTRFS_RBIO_PARITY_SCRUB)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic struct page *rbio_pstripe_page(struct btrfs_raid_bio *rbio, int index)\r\n{\r\nindex += (rbio->nr_data * rbio->stripe_len) >> PAGE_CACHE_SHIFT;\r\nreturn rbio->stripe_pages[index];\r\n}\r\nstatic struct page *rbio_qstripe_page(struct btrfs_raid_bio *rbio, int index)\r\n{\r\nif (rbio->nr_data + 1 == rbio->real_stripes)\r\nreturn NULL;\r\nindex += ((rbio->nr_data + 1) * rbio->stripe_len) >>\r\nPAGE_CACHE_SHIFT;\r\nreturn rbio->stripe_pages[index];\r\n}\r\nstatic noinline int lock_stripe_add(struct btrfs_raid_bio *rbio)\r\n{\r\nint bucket = rbio_bucket(rbio);\r\nstruct btrfs_stripe_hash *h = rbio->fs_info->stripe_hash_table->table + bucket;\r\nstruct btrfs_raid_bio *cur;\r\nstruct btrfs_raid_bio *pending;\r\nunsigned long flags;\r\nDEFINE_WAIT(wait);\r\nstruct btrfs_raid_bio *freeit = NULL;\r\nstruct btrfs_raid_bio *cache_drop = NULL;\r\nint ret = 0;\r\nint walk = 0;\r\nspin_lock_irqsave(&h->lock, flags);\r\nlist_for_each_entry(cur, &h->hash_list, hash_list) {\r\nwalk++;\r\nif (cur->bbio->raid_map[0] == rbio->bbio->raid_map[0]) {\r\nspin_lock(&cur->bio_list_lock);\r\nif (bio_list_empty(&cur->bio_list) &&\r\nlist_empty(&cur->plug_list) &&\r\ntest_bit(RBIO_CACHE_BIT, &cur->flags) &&\r\n!test_bit(RBIO_RMW_LOCKED_BIT, &cur->flags)) {\r\nlist_del_init(&cur->hash_list);\r\natomic_dec(&cur->refs);\r\nsteal_rbio(cur, rbio);\r\ncache_drop = cur;\r\nspin_unlock(&cur->bio_list_lock);\r\ngoto lockit;\r\n}\r\nif (rbio_can_merge(cur, rbio)) {\r\nmerge_rbio(cur, rbio);\r\nspin_unlock(&cur->bio_list_lock);\r\nfreeit = rbio;\r\nret = 1;\r\ngoto out;\r\n}\r\nlist_for_each_entry(pending, &cur->plug_list,\r\nplug_list) {\r\nif (rbio_can_merge(pending, rbio)) {\r\nmerge_rbio(pending, rbio);\r\nspin_unlock(&cur->bio_list_lock);\r\nfreeit = rbio;\r\nret = 1;\r\ngoto out;\r\n}\r\n}\r\nlist_add_tail(&rbio->plug_list, &cur->plug_list);\r\nspin_unlock(&cur->bio_list_lock);\r\nret = 1;\r\ngoto out;\r\n}\r\n}\r\nlockit:\r\natomic_inc(&rbio->refs);\r\nlist_add(&rbio->hash_list, &h->hash_list);\r\nout:\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nif (cache_drop)\r\nremove_rbio_from_cache(cache_drop);\r\nif (freeit)\r\n__free_raid_bio(freeit);\r\nreturn ret;\r\n}\r\nstatic noinline void unlock_stripe(struct btrfs_raid_bio *rbio)\r\n{\r\nint bucket;\r\nstruct btrfs_stripe_hash *h;\r\nunsigned long flags;\r\nint keep_cache = 0;\r\nbucket = rbio_bucket(rbio);\r\nh = rbio->fs_info->stripe_hash_table->table + bucket;\r\nif (list_empty(&rbio->plug_list))\r\ncache_rbio(rbio);\r\nspin_lock_irqsave(&h->lock, flags);\r\nspin_lock(&rbio->bio_list_lock);\r\nif (!list_empty(&rbio->hash_list)) {\r\nif (list_empty(&rbio->plug_list) &&\r\ntest_bit(RBIO_CACHE_BIT, &rbio->flags)) {\r\nkeep_cache = 1;\r\nclear_bit(RBIO_RMW_LOCKED_BIT, &rbio->flags);\r\nBUG_ON(!bio_list_empty(&rbio->bio_list));\r\ngoto done;\r\n}\r\nlist_del_init(&rbio->hash_list);\r\natomic_dec(&rbio->refs);\r\nif (!list_empty(&rbio->plug_list)) {\r\nstruct btrfs_raid_bio *next;\r\nstruct list_head *head = rbio->plug_list.next;\r\nnext = list_entry(head, struct btrfs_raid_bio,\r\nplug_list);\r\nlist_del_init(&rbio->plug_list);\r\nlist_add(&next->hash_list, &h->hash_list);\r\natomic_inc(&next->refs);\r\nspin_unlock(&rbio->bio_list_lock);\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nif (next->operation == BTRFS_RBIO_READ_REBUILD)\r\nasync_read_rebuild(next);\r\nelse if (next->operation == BTRFS_RBIO_WRITE) {\r\nsteal_rbio(rbio, next);\r\nasync_rmw_stripe(next);\r\n} else if (next->operation == BTRFS_RBIO_PARITY_SCRUB) {\r\nsteal_rbio(rbio, next);\r\nasync_scrub_parity(next);\r\n}\r\ngoto done_nolock;\r\n} else if (waitqueue_active(&h->wait)) {\r\nspin_unlock(&rbio->bio_list_lock);\r\nspin_unlock_irqrestore(&h->lock, flags);\r\nwake_up(&h->wait);\r\ngoto done_nolock;\r\n}\r\n}\r\ndone:\r\nspin_unlock(&rbio->bio_list_lock);\r\nspin_unlock_irqrestore(&h->lock, flags);\r\ndone_nolock:\r\nif (!keep_cache)\r\nremove_rbio_from_cache(rbio);\r\n}\r\nstatic void __free_raid_bio(struct btrfs_raid_bio *rbio)\r\n{\r\nint i;\r\nWARN_ON(atomic_read(&rbio->refs) < 0);\r\nif (!atomic_dec_and_test(&rbio->refs))\r\nreturn;\r\nWARN_ON(!list_empty(&rbio->stripe_cache));\r\nWARN_ON(!list_empty(&rbio->hash_list));\r\nWARN_ON(!bio_list_empty(&rbio->bio_list));\r\nfor (i = 0; i < rbio->nr_pages; i++) {\r\nif (rbio->stripe_pages[i]) {\r\n__free_page(rbio->stripe_pages[i]);\r\nrbio->stripe_pages[i] = NULL;\r\n}\r\n}\r\nbtrfs_put_bbio(rbio->bbio);\r\nkfree(rbio);\r\n}\r\nstatic void free_raid_bio(struct btrfs_raid_bio *rbio)\r\n{\r\nunlock_stripe(rbio);\r\n__free_raid_bio(rbio);\r\n}\r\nstatic void rbio_orig_end_io(struct btrfs_raid_bio *rbio, int err, int uptodate)\r\n{\r\nstruct bio *cur = bio_list_get(&rbio->bio_list);\r\nstruct bio *next;\r\nif (rbio->generic_bio_cnt)\r\nbtrfs_bio_counter_sub(rbio->fs_info, rbio->generic_bio_cnt);\r\nfree_raid_bio(rbio);\r\nwhile (cur) {\r\nnext = cur->bi_next;\r\ncur->bi_next = NULL;\r\nif (uptodate)\r\nset_bit(BIO_UPTODATE, &cur->bi_flags);\r\nbio_endio(cur, err);\r\ncur = next;\r\n}\r\n}\r\nstatic void raid_write_end_io(struct bio *bio, int err)\r\n{\r\nstruct btrfs_raid_bio *rbio = bio->bi_private;\r\nif (err)\r\nfail_bio_stripe(rbio, bio);\r\nbio_put(bio);\r\nif (!atomic_dec_and_test(&rbio->stripes_pending))\r\nreturn;\r\nerr = 0;\r\nif (atomic_read(&rbio->error) > rbio->bbio->max_errors)\r\nerr = -EIO;\r\nrbio_orig_end_io(rbio, err, 0);\r\nreturn;\r\n}\r\nstatic struct page *page_in_rbio(struct btrfs_raid_bio *rbio,\r\nint index, int pagenr, int bio_list_only)\r\n{\r\nint chunk_page;\r\nstruct page *p = NULL;\r\nchunk_page = index * (rbio->stripe_len >> PAGE_SHIFT) + pagenr;\r\nspin_lock_irq(&rbio->bio_list_lock);\r\np = rbio->bio_pages[chunk_page];\r\nspin_unlock_irq(&rbio->bio_list_lock);\r\nif (p || bio_list_only)\r\nreturn p;\r\nreturn rbio->stripe_pages[chunk_page];\r\n}\r\nstatic unsigned long rbio_nr_pages(unsigned long stripe_len, int nr_stripes)\r\n{\r\nunsigned long nr = stripe_len * nr_stripes;\r\nreturn DIV_ROUND_UP(nr, PAGE_CACHE_SIZE);\r\n}\r\nstatic struct btrfs_raid_bio *alloc_rbio(struct btrfs_root *root,\r\nstruct btrfs_bio *bbio, u64 stripe_len)\r\n{\r\nstruct btrfs_raid_bio *rbio;\r\nint nr_data = 0;\r\nint real_stripes = bbio->num_stripes - bbio->num_tgtdevs;\r\nint num_pages = rbio_nr_pages(stripe_len, real_stripes);\r\nint stripe_npages = DIV_ROUND_UP(stripe_len, PAGE_SIZE);\r\nvoid *p;\r\nrbio = kzalloc(sizeof(*rbio) + num_pages * sizeof(struct page *) * 2 +\r\nDIV_ROUND_UP(stripe_npages, BITS_PER_LONG / 8),\r\nGFP_NOFS);\r\nif (!rbio)\r\nreturn ERR_PTR(-ENOMEM);\r\nbio_list_init(&rbio->bio_list);\r\nINIT_LIST_HEAD(&rbio->plug_list);\r\nspin_lock_init(&rbio->bio_list_lock);\r\nINIT_LIST_HEAD(&rbio->stripe_cache);\r\nINIT_LIST_HEAD(&rbio->hash_list);\r\nrbio->bbio = bbio;\r\nrbio->fs_info = root->fs_info;\r\nrbio->stripe_len = stripe_len;\r\nrbio->nr_pages = num_pages;\r\nrbio->real_stripes = real_stripes;\r\nrbio->stripe_npages = stripe_npages;\r\nrbio->faila = -1;\r\nrbio->failb = -1;\r\natomic_set(&rbio->refs, 1);\r\natomic_set(&rbio->error, 0);\r\natomic_set(&rbio->stripes_pending, 0);\r\np = rbio + 1;\r\nrbio->stripe_pages = p;\r\nrbio->bio_pages = p + sizeof(struct page *) * num_pages;\r\nrbio->dbitmap = p + sizeof(struct page *) * num_pages * 2;\r\nif (bbio->map_type & BTRFS_BLOCK_GROUP_RAID5)\r\nnr_data = real_stripes - 1;\r\nelse if (bbio->map_type & BTRFS_BLOCK_GROUP_RAID6)\r\nnr_data = real_stripes - 2;\r\nelse\r\nBUG();\r\nrbio->nr_data = nr_data;\r\nreturn rbio;\r\n}\r\nstatic int alloc_rbio_pages(struct btrfs_raid_bio *rbio)\r\n{\r\nint i;\r\nstruct page *page;\r\nfor (i = 0; i < rbio->nr_pages; i++) {\r\nif (rbio->stripe_pages[i])\r\ncontinue;\r\npage = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\r\nif (!page)\r\nreturn -ENOMEM;\r\nrbio->stripe_pages[i] = page;\r\nClearPageUptodate(page);\r\n}\r\nreturn 0;\r\n}\r\nstatic int alloc_rbio_parity_pages(struct btrfs_raid_bio *rbio)\r\n{\r\nint i;\r\nstruct page *page;\r\ni = (rbio->nr_data * rbio->stripe_len) >> PAGE_CACHE_SHIFT;\r\nfor (; i < rbio->nr_pages; i++) {\r\nif (rbio->stripe_pages[i])\r\ncontinue;\r\npage = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\r\nif (!page)\r\nreturn -ENOMEM;\r\nrbio->stripe_pages[i] = page;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rbio_add_io_page(struct btrfs_raid_bio *rbio,\r\nstruct bio_list *bio_list,\r\nstruct page *page,\r\nint stripe_nr,\r\nunsigned long page_index,\r\nunsigned long bio_max_len)\r\n{\r\nstruct bio *last = bio_list->tail;\r\nu64 last_end = 0;\r\nint ret;\r\nstruct bio *bio;\r\nstruct btrfs_bio_stripe *stripe;\r\nu64 disk_start;\r\nstripe = &rbio->bbio->stripes[stripe_nr];\r\ndisk_start = stripe->physical + (page_index << PAGE_CACHE_SHIFT);\r\nif (!stripe->dev->bdev)\r\nreturn fail_rbio_index(rbio, stripe_nr);\r\nif (last) {\r\nlast_end = (u64)last->bi_iter.bi_sector << 9;\r\nlast_end += last->bi_iter.bi_size;\r\nif (last_end == disk_start && stripe->dev->bdev &&\r\ntest_bit(BIO_UPTODATE, &last->bi_flags) &&\r\nlast->bi_bdev == stripe->dev->bdev) {\r\nret = bio_add_page(last, page, PAGE_CACHE_SIZE, 0);\r\nif (ret == PAGE_CACHE_SIZE)\r\nreturn 0;\r\n}\r\n}\r\nbio = btrfs_io_bio_alloc(GFP_NOFS, bio_max_len >> PAGE_SHIFT?:1);\r\nif (!bio)\r\nreturn -ENOMEM;\r\nbio->bi_iter.bi_size = 0;\r\nbio->bi_bdev = stripe->dev->bdev;\r\nbio->bi_iter.bi_sector = disk_start >> 9;\r\nset_bit(BIO_UPTODATE, &bio->bi_flags);\r\nbio_add_page(bio, page, PAGE_CACHE_SIZE, 0);\r\nbio_list_add(bio_list, bio);\r\nreturn 0;\r\n}\r\nstatic void validate_rbio_for_rmw(struct btrfs_raid_bio *rbio)\r\n{\r\nif (rbio->faila >= 0 || rbio->failb >= 0) {\r\nBUG_ON(rbio->faila == rbio->real_stripes - 1);\r\n__raid56_parity_recover(rbio);\r\n} else {\r\nfinish_rmw(rbio);\r\n}\r\n}\r\nstatic struct page *rbio_stripe_page(struct btrfs_raid_bio *rbio, int stripe, int page)\r\n{\r\nint index;\r\nindex = stripe * (rbio->stripe_len >> PAGE_CACHE_SHIFT);\r\nindex += page;\r\nreturn rbio->stripe_pages[index];\r\n}\r\nstatic void index_rbio_pages(struct btrfs_raid_bio *rbio)\r\n{\r\nstruct bio *bio;\r\nu64 start;\r\nunsigned long stripe_offset;\r\nunsigned long page_index;\r\nstruct page *p;\r\nint i;\r\nspin_lock_irq(&rbio->bio_list_lock);\r\nbio_list_for_each(bio, &rbio->bio_list) {\r\nstart = (u64)bio->bi_iter.bi_sector << 9;\r\nstripe_offset = start - rbio->bbio->raid_map[0];\r\npage_index = stripe_offset >> PAGE_CACHE_SHIFT;\r\nfor (i = 0; i < bio->bi_vcnt; i++) {\r\np = bio->bi_io_vec[i].bv_page;\r\nrbio->bio_pages[page_index + i] = p;\r\n}\r\n}\r\nspin_unlock_irq(&rbio->bio_list_lock);\r\n}\r\nstatic noinline void finish_rmw(struct btrfs_raid_bio *rbio)\r\n{\r\nstruct btrfs_bio *bbio = rbio->bbio;\r\nvoid *pointers[rbio->real_stripes];\r\nint stripe_len = rbio->stripe_len;\r\nint nr_data = rbio->nr_data;\r\nint stripe;\r\nint pagenr;\r\nint p_stripe = -1;\r\nint q_stripe = -1;\r\nstruct bio_list bio_list;\r\nstruct bio *bio;\r\nint pages_per_stripe = stripe_len >> PAGE_CACHE_SHIFT;\r\nint ret;\r\nbio_list_init(&bio_list);\r\nif (rbio->real_stripes - rbio->nr_data == 1) {\r\np_stripe = rbio->real_stripes - 1;\r\n} else if (rbio->real_stripes - rbio->nr_data == 2) {\r\np_stripe = rbio->real_stripes - 2;\r\nq_stripe = rbio->real_stripes - 1;\r\n} else {\r\nBUG();\r\n}\r\nspin_lock_irq(&rbio->bio_list_lock);\r\nset_bit(RBIO_RMW_LOCKED_BIT, &rbio->flags);\r\nspin_unlock_irq(&rbio->bio_list_lock);\r\natomic_set(&rbio->error, 0);\r\nindex_rbio_pages(rbio);\r\nif (!rbio_is_full(rbio))\r\ncache_rbio_pages(rbio);\r\nelse\r\nclear_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\r\nfor (pagenr = 0; pagenr < pages_per_stripe; pagenr++) {\r\nstruct page *p;\r\nfor (stripe = 0; stripe < nr_data; stripe++) {\r\np = page_in_rbio(rbio, stripe, pagenr, 0);\r\npointers[stripe] = kmap(p);\r\n}\r\np = rbio_pstripe_page(rbio, pagenr);\r\nSetPageUptodate(p);\r\npointers[stripe++] = kmap(p);\r\nif (q_stripe != -1) {\r\np = rbio_qstripe_page(rbio, pagenr);\r\nSetPageUptodate(p);\r\npointers[stripe++] = kmap(p);\r\nraid6_call.gen_syndrome(rbio->real_stripes, PAGE_SIZE,\r\npointers);\r\n} else {\r\nmemcpy(pointers[nr_data], pointers[0], PAGE_SIZE);\r\nrun_xor(pointers + 1, nr_data - 1, PAGE_CACHE_SIZE);\r\n}\r\nfor (stripe = 0; stripe < rbio->real_stripes; stripe++)\r\nkunmap(page_in_rbio(rbio, stripe, pagenr, 0));\r\n}\r\nfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\r\nfor (pagenr = 0; pagenr < pages_per_stripe; pagenr++) {\r\nstruct page *page;\r\nif (stripe < rbio->nr_data) {\r\npage = page_in_rbio(rbio, stripe, pagenr, 1);\r\nif (!page)\r\ncontinue;\r\n} else {\r\npage = rbio_stripe_page(rbio, stripe, pagenr);\r\n}\r\nret = rbio_add_io_page(rbio, &bio_list,\r\npage, stripe, pagenr, rbio->stripe_len);\r\nif (ret)\r\ngoto cleanup;\r\n}\r\n}\r\nif (likely(!bbio->num_tgtdevs))\r\ngoto write_data;\r\nfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\r\nif (!bbio->tgtdev_map[stripe])\r\ncontinue;\r\nfor (pagenr = 0; pagenr < pages_per_stripe; pagenr++) {\r\nstruct page *page;\r\nif (stripe < rbio->nr_data) {\r\npage = page_in_rbio(rbio, stripe, pagenr, 1);\r\nif (!page)\r\ncontinue;\r\n} else {\r\npage = rbio_stripe_page(rbio, stripe, pagenr);\r\n}\r\nret = rbio_add_io_page(rbio, &bio_list, page,\r\nrbio->bbio->tgtdev_map[stripe],\r\npagenr, rbio->stripe_len);\r\nif (ret)\r\ngoto cleanup;\r\n}\r\n}\r\nwrite_data:\r\natomic_set(&rbio->stripes_pending, bio_list_size(&bio_list));\r\nBUG_ON(atomic_read(&rbio->stripes_pending) == 0);\r\nwhile (1) {\r\nbio = bio_list_pop(&bio_list);\r\nif (!bio)\r\nbreak;\r\nbio->bi_private = rbio;\r\nbio->bi_end_io = raid_write_end_io;\r\nBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\r\nsubmit_bio(WRITE, bio);\r\n}\r\nreturn;\r\ncleanup:\r\nrbio_orig_end_io(rbio, -EIO, 0);\r\n}\r\nstatic int find_bio_stripe(struct btrfs_raid_bio *rbio,\r\nstruct bio *bio)\r\n{\r\nu64 physical = bio->bi_iter.bi_sector;\r\nu64 stripe_start;\r\nint i;\r\nstruct btrfs_bio_stripe *stripe;\r\nphysical <<= 9;\r\nfor (i = 0; i < rbio->bbio->num_stripes; i++) {\r\nstripe = &rbio->bbio->stripes[i];\r\nstripe_start = stripe->physical;\r\nif (physical >= stripe_start &&\r\nphysical < stripe_start + rbio->stripe_len &&\r\nbio->bi_bdev == stripe->dev->bdev) {\r\nreturn i;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic int find_logical_bio_stripe(struct btrfs_raid_bio *rbio,\r\nstruct bio *bio)\r\n{\r\nu64 logical = bio->bi_iter.bi_sector;\r\nu64 stripe_start;\r\nint i;\r\nlogical <<= 9;\r\nfor (i = 0; i < rbio->nr_data; i++) {\r\nstripe_start = rbio->bbio->raid_map[i];\r\nif (logical >= stripe_start &&\r\nlogical < stripe_start + rbio->stripe_len) {\r\nreturn i;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic int fail_rbio_index(struct btrfs_raid_bio *rbio, int failed)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&rbio->bio_list_lock, flags);\r\nif (rbio->faila == failed || rbio->failb == failed)\r\ngoto out;\r\nif (rbio->faila == -1) {\r\nrbio->faila = failed;\r\natomic_inc(&rbio->error);\r\n} else if (rbio->failb == -1) {\r\nrbio->failb = failed;\r\natomic_inc(&rbio->error);\r\n} else {\r\nret = -EIO;\r\n}\r\nout:\r\nspin_unlock_irqrestore(&rbio->bio_list_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int fail_bio_stripe(struct btrfs_raid_bio *rbio,\r\nstruct bio *bio)\r\n{\r\nint failed = find_bio_stripe(rbio, bio);\r\nif (failed < 0)\r\nreturn -EIO;\r\nreturn fail_rbio_index(rbio, failed);\r\n}\r\nstatic void set_bio_pages_uptodate(struct bio *bio)\r\n{\r\nint i;\r\nstruct page *p;\r\nfor (i = 0; i < bio->bi_vcnt; i++) {\r\np = bio->bi_io_vec[i].bv_page;\r\nSetPageUptodate(p);\r\n}\r\n}\r\nstatic void raid_rmw_end_io(struct bio *bio, int err)\r\n{\r\nstruct btrfs_raid_bio *rbio = bio->bi_private;\r\nif (err)\r\nfail_bio_stripe(rbio, bio);\r\nelse\r\nset_bio_pages_uptodate(bio);\r\nbio_put(bio);\r\nif (!atomic_dec_and_test(&rbio->stripes_pending))\r\nreturn;\r\nerr = 0;\r\nif (atomic_read(&rbio->error) > rbio->bbio->max_errors)\r\ngoto cleanup;\r\nvalidate_rbio_for_rmw(rbio);\r\nreturn;\r\ncleanup:\r\nrbio_orig_end_io(rbio, -EIO, 0);\r\n}\r\nstatic void async_rmw_stripe(struct btrfs_raid_bio *rbio)\r\n{\r\nbtrfs_init_work(&rbio->work, btrfs_rmw_helper,\r\nrmw_work, NULL, NULL);\r\nbtrfs_queue_work(rbio->fs_info->rmw_workers,\r\n&rbio->work);\r\n}\r\nstatic void async_read_rebuild(struct btrfs_raid_bio *rbio)\r\n{\r\nbtrfs_init_work(&rbio->work, btrfs_rmw_helper,\r\nread_rebuild_work, NULL, NULL);\r\nbtrfs_queue_work(rbio->fs_info->rmw_workers,\r\n&rbio->work);\r\n}\r\nstatic int raid56_rmw_stripe(struct btrfs_raid_bio *rbio)\r\n{\r\nint bios_to_read = 0;\r\nstruct bio_list bio_list;\r\nint ret;\r\nint nr_pages = DIV_ROUND_UP(rbio->stripe_len, PAGE_CACHE_SIZE);\r\nint pagenr;\r\nint stripe;\r\nstruct bio *bio;\r\nbio_list_init(&bio_list);\r\nret = alloc_rbio_pages(rbio);\r\nif (ret)\r\ngoto cleanup;\r\nindex_rbio_pages(rbio);\r\natomic_set(&rbio->error, 0);\r\nfor (stripe = 0; stripe < rbio->nr_data; stripe++) {\r\nfor (pagenr = 0; pagenr < nr_pages; pagenr++) {\r\nstruct page *page;\r\npage = page_in_rbio(rbio, stripe, pagenr, 1);\r\nif (page)\r\ncontinue;\r\npage = rbio_stripe_page(rbio, stripe, pagenr);\r\nif (PageUptodate(page))\r\ncontinue;\r\nret = rbio_add_io_page(rbio, &bio_list, page,\r\nstripe, pagenr, rbio->stripe_len);\r\nif (ret)\r\ngoto cleanup;\r\n}\r\n}\r\nbios_to_read = bio_list_size(&bio_list);\r\nif (!bios_to_read) {\r\ngoto finish;\r\n}\r\natomic_set(&rbio->stripes_pending, bios_to_read);\r\nwhile (1) {\r\nbio = bio_list_pop(&bio_list);\r\nif (!bio)\r\nbreak;\r\nbio->bi_private = rbio;\r\nbio->bi_end_io = raid_rmw_end_io;\r\nbtrfs_bio_wq_end_io(rbio->fs_info, bio,\r\nBTRFS_WQ_ENDIO_RAID56);\r\nBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\r\nsubmit_bio(READ, bio);\r\n}\r\nreturn 0;\r\ncleanup:\r\nrbio_orig_end_io(rbio, -EIO, 0);\r\nreturn -EIO;\r\nfinish:\r\nvalidate_rbio_for_rmw(rbio);\r\nreturn 0;\r\n}\r\nstatic int full_stripe_write(struct btrfs_raid_bio *rbio)\r\n{\r\nint ret;\r\nret = alloc_rbio_parity_pages(rbio);\r\nif (ret) {\r\n__free_raid_bio(rbio);\r\nreturn ret;\r\n}\r\nret = lock_stripe_add(rbio);\r\nif (ret == 0)\r\nfinish_rmw(rbio);\r\nreturn 0;\r\n}\r\nstatic int partial_stripe_write(struct btrfs_raid_bio *rbio)\r\n{\r\nint ret;\r\nret = lock_stripe_add(rbio);\r\nif (ret == 0)\r\nasync_rmw_stripe(rbio);\r\nreturn 0;\r\n}\r\nstatic int __raid56_parity_write(struct btrfs_raid_bio *rbio)\r\n{\r\nif (!rbio_is_full(rbio))\r\nreturn partial_stripe_write(rbio);\r\nreturn full_stripe_write(rbio);\r\n}\r\nstatic int plug_cmp(void *priv, struct list_head *a, struct list_head *b)\r\n{\r\nstruct btrfs_raid_bio *ra = container_of(a, struct btrfs_raid_bio,\r\nplug_list);\r\nstruct btrfs_raid_bio *rb = container_of(b, struct btrfs_raid_bio,\r\nplug_list);\r\nu64 a_sector = ra->bio_list.head->bi_iter.bi_sector;\r\nu64 b_sector = rb->bio_list.head->bi_iter.bi_sector;\r\nif (a_sector < b_sector)\r\nreturn -1;\r\nif (a_sector > b_sector)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void run_plug(struct btrfs_plug_cb *plug)\r\n{\r\nstruct btrfs_raid_bio *cur;\r\nstruct btrfs_raid_bio *last = NULL;\r\nlist_sort(NULL, &plug->rbio_list, plug_cmp);\r\nwhile (!list_empty(&plug->rbio_list)) {\r\ncur = list_entry(plug->rbio_list.next,\r\nstruct btrfs_raid_bio, plug_list);\r\nlist_del_init(&cur->plug_list);\r\nif (rbio_is_full(cur)) {\r\nfull_stripe_write(cur);\r\ncontinue;\r\n}\r\nif (last) {\r\nif (rbio_can_merge(last, cur)) {\r\nmerge_rbio(last, cur);\r\n__free_raid_bio(cur);\r\ncontinue;\r\n}\r\n__raid56_parity_write(last);\r\n}\r\nlast = cur;\r\n}\r\nif (last) {\r\n__raid56_parity_write(last);\r\n}\r\nkfree(plug);\r\n}\r\nstatic void unplug_work(struct btrfs_work *work)\r\n{\r\nstruct btrfs_plug_cb *plug;\r\nplug = container_of(work, struct btrfs_plug_cb, work);\r\nrun_plug(plug);\r\n}\r\nstatic void btrfs_raid_unplug(struct blk_plug_cb *cb, bool from_schedule)\r\n{\r\nstruct btrfs_plug_cb *plug;\r\nplug = container_of(cb, struct btrfs_plug_cb, cb);\r\nif (from_schedule) {\r\nbtrfs_init_work(&plug->work, btrfs_rmw_helper,\r\nunplug_work, NULL, NULL);\r\nbtrfs_queue_work(plug->info->rmw_workers,\r\n&plug->work);\r\nreturn;\r\n}\r\nrun_plug(plug);\r\n}\r\nint raid56_parity_write(struct btrfs_root *root, struct bio *bio,\r\nstruct btrfs_bio *bbio, u64 stripe_len)\r\n{\r\nstruct btrfs_raid_bio *rbio;\r\nstruct btrfs_plug_cb *plug = NULL;\r\nstruct blk_plug_cb *cb;\r\nint ret;\r\nrbio = alloc_rbio(root, bbio, stripe_len);\r\nif (IS_ERR(rbio)) {\r\nbtrfs_put_bbio(bbio);\r\nreturn PTR_ERR(rbio);\r\n}\r\nbio_list_add(&rbio->bio_list, bio);\r\nrbio->bio_list_bytes = bio->bi_iter.bi_size;\r\nrbio->operation = BTRFS_RBIO_WRITE;\r\nbtrfs_bio_counter_inc_noblocked(root->fs_info);\r\nrbio->generic_bio_cnt = 1;\r\nif (rbio_is_full(rbio)) {\r\nret = full_stripe_write(rbio);\r\nif (ret)\r\nbtrfs_bio_counter_dec(root->fs_info);\r\nreturn ret;\r\n}\r\ncb = blk_check_plugged(btrfs_raid_unplug, root->fs_info,\r\nsizeof(*plug));\r\nif (cb) {\r\nplug = container_of(cb, struct btrfs_plug_cb, cb);\r\nif (!plug->info) {\r\nplug->info = root->fs_info;\r\nINIT_LIST_HEAD(&plug->rbio_list);\r\n}\r\nlist_add_tail(&rbio->plug_list, &plug->rbio_list);\r\nret = 0;\r\n} else {\r\nret = __raid56_parity_write(rbio);\r\nif (ret)\r\nbtrfs_bio_counter_dec(root->fs_info);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __raid_recover_end_io(struct btrfs_raid_bio *rbio)\r\n{\r\nint pagenr, stripe;\r\nvoid **pointers;\r\nint faila = -1, failb = -1;\r\nint nr_pages = DIV_ROUND_UP(rbio->stripe_len, PAGE_CACHE_SIZE);\r\nstruct page *page;\r\nint err;\r\nint i;\r\npointers = kcalloc(rbio->real_stripes, sizeof(void *), GFP_NOFS);\r\nif (!pointers) {\r\nerr = -ENOMEM;\r\ngoto cleanup_io;\r\n}\r\nfaila = rbio->faila;\r\nfailb = rbio->failb;\r\nif (rbio->operation == BTRFS_RBIO_READ_REBUILD) {\r\nspin_lock_irq(&rbio->bio_list_lock);\r\nset_bit(RBIO_RMW_LOCKED_BIT, &rbio->flags);\r\nspin_unlock_irq(&rbio->bio_list_lock);\r\n}\r\nindex_rbio_pages(rbio);\r\nfor (pagenr = 0; pagenr < nr_pages; pagenr++) {\r\nif (rbio->operation == BTRFS_RBIO_PARITY_SCRUB &&\r\n!test_bit(pagenr, rbio->dbitmap))\r\ncontinue;\r\nfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\r\nif (rbio->operation == BTRFS_RBIO_READ_REBUILD &&\r\n(stripe == faila || stripe == failb)) {\r\npage = page_in_rbio(rbio, stripe, pagenr, 0);\r\n} else {\r\npage = rbio_stripe_page(rbio, stripe, pagenr);\r\n}\r\npointers[stripe] = kmap(page);\r\n}\r\nif (rbio->bbio->map_type & BTRFS_BLOCK_GROUP_RAID6) {\r\nif (failb < 0) {\r\nif (faila == rbio->nr_data) {\r\nerr = -EIO;\r\ngoto cleanup;\r\n}\r\ngoto pstripe;\r\n}\r\nif (faila > failb) {\r\nint tmp = failb;\r\nfailb = faila;\r\nfaila = tmp;\r\n}\r\nif (rbio->bbio->raid_map[failb] == RAID6_Q_STRIPE) {\r\nif (rbio->bbio->raid_map[faila] ==\r\nRAID5_P_STRIPE) {\r\nerr = -EIO;\r\ngoto cleanup;\r\n}\r\ngoto pstripe;\r\n}\r\nif (rbio->bbio->raid_map[failb] == RAID5_P_STRIPE) {\r\nraid6_datap_recov(rbio->real_stripes,\r\nPAGE_SIZE, faila, pointers);\r\n} else {\r\nraid6_2data_recov(rbio->real_stripes,\r\nPAGE_SIZE, faila, failb,\r\npointers);\r\n}\r\n} else {\r\nvoid *p;\r\nBUG_ON(failb != -1);\r\npstripe:\r\nmemcpy(pointers[faila],\r\npointers[rbio->nr_data],\r\nPAGE_CACHE_SIZE);\r\np = pointers[faila];\r\nfor (stripe = faila; stripe < rbio->nr_data - 1; stripe++)\r\npointers[stripe] = pointers[stripe + 1];\r\npointers[rbio->nr_data - 1] = p;\r\nrun_xor(pointers, rbio->nr_data - 1, PAGE_CACHE_SIZE);\r\n}\r\nif (rbio->operation == BTRFS_RBIO_WRITE) {\r\nfor (i = 0; i < nr_pages; i++) {\r\nif (faila != -1) {\r\npage = rbio_stripe_page(rbio, faila, i);\r\nSetPageUptodate(page);\r\n}\r\nif (failb != -1) {\r\npage = rbio_stripe_page(rbio, failb, i);\r\nSetPageUptodate(page);\r\n}\r\n}\r\n}\r\nfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\r\nif (rbio->operation == BTRFS_RBIO_READ_REBUILD &&\r\n(stripe == faila || stripe == failb)) {\r\npage = page_in_rbio(rbio, stripe, pagenr, 0);\r\n} else {\r\npage = rbio_stripe_page(rbio, stripe, pagenr);\r\n}\r\nkunmap(page);\r\n}\r\n}\r\nerr = 0;\r\ncleanup:\r\nkfree(pointers);\r\ncleanup_io:\r\nif (rbio->operation == BTRFS_RBIO_READ_REBUILD) {\r\nif (err == 0)\r\ncache_rbio_pages(rbio);\r\nelse\r\nclear_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\r\nrbio_orig_end_io(rbio, err, err == 0);\r\n} else if (err == 0) {\r\nrbio->faila = -1;\r\nrbio->failb = -1;\r\nif (rbio->operation == BTRFS_RBIO_WRITE)\r\nfinish_rmw(rbio);\r\nelse if (rbio->operation == BTRFS_RBIO_PARITY_SCRUB)\r\nfinish_parity_scrub(rbio, 0);\r\nelse\r\nBUG();\r\n} else {\r\nrbio_orig_end_io(rbio, err, 0);\r\n}\r\n}\r\nstatic void raid_recover_end_io(struct bio *bio, int err)\r\n{\r\nstruct btrfs_raid_bio *rbio = bio->bi_private;\r\nif (err)\r\nfail_bio_stripe(rbio, bio);\r\nelse\r\nset_bio_pages_uptodate(bio);\r\nbio_put(bio);\r\nif (!atomic_dec_and_test(&rbio->stripes_pending))\r\nreturn;\r\nif (atomic_read(&rbio->error) > rbio->bbio->max_errors)\r\nrbio_orig_end_io(rbio, -EIO, 0);\r\nelse\r\n__raid_recover_end_io(rbio);\r\n}\r\nstatic int __raid56_parity_recover(struct btrfs_raid_bio *rbio)\r\n{\r\nint bios_to_read = 0;\r\nstruct bio_list bio_list;\r\nint ret;\r\nint nr_pages = DIV_ROUND_UP(rbio->stripe_len, PAGE_CACHE_SIZE);\r\nint pagenr;\r\nint stripe;\r\nstruct bio *bio;\r\nbio_list_init(&bio_list);\r\nret = alloc_rbio_pages(rbio);\r\nif (ret)\r\ngoto cleanup;\r\natomic_set(&rbio->error, 0);\r\nfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\r\nif (rbio->faila == stripe || rbio->failb == stripe) {\r\natomic_inc(&rbio->error);\r\ncontinue;\r\n}\r\nfor (pagenr = 0; pagenr < nr_pages; pagenr++) {\r\nstruct page *p;\r\np = rbio_stripe_page(rbio, stripe, pagenr);\r\nif (PageUptodate(p))\r\ncontinue;\r\nret = rbio_add_io_page(rbio, &bio_list,\r\nrbio_stripe_page(rbio, stripe, pagenr),\r\nstripe, pagenr, rbio->stripe_len);\r\nif (ret < 0)\r\ngoto cleanup;\r\n}\r\n}\r\nbios_to_read = bio_list_size(&bio_list);\r\nif (!bios_to_read) {\r\nif (atomic_read(&rbio->error) <= rbio->bbio->max_errors) {\r\n__raid_recover_end_io(rbio);\r\ngoto out;\r\n} else {\r\ngoto cleanup;\r\n}\r\n}\r\natomic_set(&rbio->stripes_pending, bios_to_read);\r\nwhile (1) {\r\nbio = bio_list_pop(&bio_list);\r\nif (!bio)\r\nbreak;\r\nbio->bi_private = rbio;\r\nbio->bi_end_io = raid_recover_end_io;\r\nbtrfs_bio_wq_end_io(rbio->fs_info, bio,\r\nBTRFS_WQ_ENDIO_RAID56);\r\nBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\r\nsubmit_bio(READ, bio);\r\n}\r\nout:\r\nreturn 0;\r\ncleanup:\r\nif (rbio->operation == BTRFS_RBIO_READ_REBUILD)\r\nrbio_orig_end_io(rbio, -EIO, 0);\r\nreturn -EIO;\r\n}\r\nint raid56_parity_recover(struct btrfs_root *root, struct bio *bio,\r\nstruct btrfs_bio *bbio, u64 stripe_len,\r\nint mirror_num, int generic_io)\r\n{\r\nstruct btrfs_raid_bio *rbio;\r\nint ret;\r\nrbio = alloc_rbio(root, bbio, stripe_len);\r\nif (IS_ERR(rbio)) {\r\nif (generic_io)\r\nbtrfs_put_bbio(bbio);\r\nreturn PTR_ERR(rbio);\r\n}\r\nrbio->operation = BTRFS_RBIO_READ_REBUILD;\r\nbio_list_add(&rbio->bio_list, bio);\r\nrbio->bio_list_bytes = bio->bi_iter.bi_size;\r\nrbio->faila = find_logical_bio_stripe(rbio, bio);\r\nif (rbio->faila == -1) {\r\nBUG();\r\nif (generic_io)\r\nbtrfs_put_bbio(bbio);\r\nkfree(rbio);\r\nreturn -EIO;\r\n}\r\nif (generic_io) {\r\nbtrfs_bio_counter_inc_noblocked(root->fs_info);\r\nrbio->generic_bio_cnt = 1;\r\n} else {\r\nbtrfs_get_bbio(bbio);\r\n}\r\nif (mirror_num == 3)\r\nrbio->failb = rbio->real_stripes - 2;\r\nret = lock_stripe_add(rbio);\r\nif (ret == 0)\r\n__raid56_parity_recover(rbio);\r\nreturn 0;\r\n}\r\nstatic void rmw_work(struct btrfs_work *work)\r\n{\r\nstruct btrfs_raid_bio *rbio;\r\nrbio = container_of(work, struct btrfs_raid_bio, work);\r\nraid56_rmw_stripe(rbio);\r\n}\r\nstatic void read_rebuild_work(struct btrfs_work *work)\r\n{\r\nstruct btrfs_raid_bio *rbio;\r\nrbio = container_of(work, struct btrfs_raid_bio, work);\r\n__raid56_parity_recover(rbio);\r\n}\r\nstruct btrfs_raid_bio *\r\nraid56_parity_alloc_scrub_rbio(struct btrfs_root *root, struct bio *bio,\r\nstruct btrfs_bio *bbio, u64 stripe_len,\r\nstruct btrfs_device *scrub_dev,\r\nunsigned long *dbitmap, int stripe_nsectors)\r\n{\r\nstruct btrfs_raid_bio *rbio;\r\nint i;\r\nrbio = alloc_rbio(root, bbio, stripe_len);\r\nif (IS_ERR(rbio))\r\nreturn NULL;\r\nbio_list_add(&rbio->bio_list, bio);\r\nASSERT(!bio->bi_iter.bi_size);\r\nrbio->operation = BTRFS_RBIO_PARITY_SCRUB;\r\nfor (i = 0; i < rbio->real_stripes; i++) {\r\nif (bbio->stripes[i].dev == scrub_dev) {\r\nrbio->scrubp = i;\r\nbreak;\r\n}\r\n}\r\nASSERT(root->sectorsize == PAGE_SIZE);\r\nASSERT(rbio->stripe_npages == stripe_nsectors);\r\nbitmap_copy(rbio->dbitmap, dbitmap, stripe_nsectors);\r\nreturn rbio;\r\n}\r\nvoid raid56_parity_add_scrub_pages(struct btrfs_raid_bio *rbio,\r\nstruct page *page, u64 logical)\r\n{\r\nint stripe_offset;\r\nint index;\r\nASSERT(logical >= rbio->bbio->raid_map[0]);\r\nASSERT(logical + PAGE_SIZE <= rbio->bbio->raid_map[0] +\r\nrbio->stripe_len * rbio->nr_data);\r\nstripe_offset = (int)(logical - rbio->bbio->raid_map[0]);\r\nindex = stripe_offset >> PAGE_CACHE_SHIFT;\r\nrbio->bio_pages[index] = page;\r\n}\r\nstatic int alloc_rbio_essential_pages(struct btrfs_raid_bio *rbio)\r\n{\r\nint i;\r\nint bit;\r\nint index;\r\nstruct page *page;\r\nfor_each_set_bit(bit, rbio->dbitmap, rbio->stripe_npages) {\r\nfor (i = 0; i < rbio->real_stripes; i++) {\r\nindex = i * rbio->stripe_npages + bit;\r\nif (rbio->stripe_pages[index])\r\ncontinue;\r\npage = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\r\nif (!page)\r\nreturn -ENOMEM;\r\nrbio->stripe_pages[index] = page;\r\nClearPageUptodate(page);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void raid_write_parity_end_io(struct bio *bio, int err)\r\n{\r\nstruct btrfs_raid_bio *rbio = bio->bi_private;\r\nif (err)\r\nfail_bio_stripe(rbio, bio);\r\nbio_put(bio);\r\nif (!atomic_dec_and_test(&rbio->stripes_pending))\r\nreturn;\r\nerr = 0;\r\nif (atomic_read(&rbio->error))\r\nerr = -EIO;\r\nrbio_orig_end_io(rbio, err, 0);\r\n}\r\nstatic noinline void finish_parity_scrub(struct btrfs_raid_bio *rbio,\r\nint need_check)\r\n{\r\nstruct btrfs_bio *bbio = rbio->bbio;\r\nvoid *pointers[rbio->real_stripes];\r\nDECLARE_BITMAP(pbitmap, rbio->stripe_npages);\r\nint nr_data = rbio->nr_data;\r\nint stripe;\r\nint pagenr;\r\nint p_stripe = -1;\r\nint q_stripe = -1;\r\nstruct page *p_page = NULL;\r\nstruct page *q_page = NULL;\r\nstruct bio_list bio_list;\r\nstruct bio *bio;\r\nint is_replace = 0;\r\nint ret;\r\nbio_list_init(&bio_list);\r\nif (rbio->real_stripes - rbio->nr_data == 1) {\r\np_stripe = rbio->real_stripes - 1;\r\n} else if (rbio->real_stripes - rbio->nr_data == 2) {\r\np_stripe = rbio->real_stripes - 2;\r\nq_stripe = rbio->real_stripes - 1;\r\n} else {\r\nBUG();\r\n}\r\nif (bbio->num_tgtdevs && bbio->tgtdev_map[rbio->scrubp]) {\r\nis_replace = 1;\r\nbitmap_copy(pbitmap, rbio->dbitmap, rbio->stripe_npages);\r\n}\r\nclear_bit(RBIO_CACHE_READY_BIT, &rbio->flags);\r\nif (!need_check)\r\ngoto writeback;\r\np_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\r\nif (!p_page)\r\ngoto cleanup;\r\nSetPageUptodate(p_page);\r\nif (q_stripe != -1) {\r\nq_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\r\nif (!q_page) {\r\n__free_page(p_page);\r\ngoto cleanup;\r\n}\r\nSetPageUptodate(q_page);\r\n}\r\natomic_set(&rbio->error, 0);\r\nfor_each_set_bit(pagenr, rbio->dbitmap, rbio->stripe_npages) {\r\nstruct page *p;\r\nvoid *parity;\r\nfor (stripe = 0; stripe < nr_data; stripe++) {\r\np = page_in_rbio(rbio, stripe, pagenr, 0);\r\npointers[stripe] = kmap(p);\r\n}\r\npointers[stripe++] = kmap(p_page);\r\nif (q_stripe != -1) {\r\npointers[stripe++] = kmap(q_page);\r\nraid6_call.gen_syndrome(rbio->real_stripes, PAGE_SIZE,\r\npointers);\r\n} else {\r\nmemcpy(pointers[nr_data], pointers[0], PAGE_SIZE);\r\nrun_xor(pointers + 1, nr_data - 1, PAGE_CACHE_SIZE);\r\n}\r\np = rbio_stripe_page(rbio, rbio->scrubp, pagenr);\r\nparity = kmap(p);\r\nif (memcmp(parity, pointers[rbio->scrubp], PAGE_CACHE_SIZE))\r\nmemcpy(parity, pointers[rbio->scrubp], PAGE_CACHE_SIZE);\r\nelse\r\nbitmap_clear(rbio->dbitmap, pagenr, 1);\r\nkunmap(p);\r\nfor (stripe = 0; stripe < rbio->real_stripes; stripe++)\r\nkunmap(page_in_rbio(rbio, stripe, pagenr, 0));\r\n}\r\n__free_page(p_page);\r\nif (q_page)\r\n__free_page(q_page);\r\nwriteback:\r\nfor_each_set_bit(pagenr, rbio->dbitmap, rbio->stripe_npages) {\r\nstruct page *page;\r\npage = rbio_stripe_page(rbio, rbio->scrubp, pagenr);\r\nret = rbio_add_io_page(rbio, &bio_list,\r\npage, rbio->scrubp, pagenr, rbio->stripe_len);\r\nif (ret)\r\ngoto cleanup;\r\n}\r\nif (!is_replace)\r\ngoto submit_write;\r\nfor_each_set_bit(pagenr, pbitmap, rbio->stripe_npages) {\r\nstruct page *page;\r\npage = rbio_stripe_page(rbio, rbio->scrubp, pagenr);\r\nret = rbio_add_io_page(rbio, &bio_list, page,\r\nbbio->tgtdev_map[rbio->scrubp],\r\npagenr, rbio->stripe_len);\r\nif (ret)\r\ngoto cleanup;\r\n}\r\nsubmit_write:\r\nnr_data = bio_list_size(&bio_list);\r\nif (!nr_data) {\r\nrbio_orig_end_io(rbio, 0, 0);\r\nreturn;\r\n}\r\natomic_set(&rbio->stripes_pending, nr_data);\r\nwhile (1) {\r\nbio = bio_list_pop(&bio_list);\r\nif (!bio)\r\nbreak;\r\nbio->bi_private = rbio;\r\nbio->bi_end_io = raid_write_parity_end_io;\r\nBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\r\nsubmit_bio(WRITE, bio);\r\n}\r\nreturn;\r\ncleanup:\r\nrbio_orig_end_io(rbio, -EIO, 0);\r\n}\r\nstatic inline int is_data_stripe(struct btrfs_raid_bio *rbio, int stripe)\r\n{\r\nif (stripe >= 0 && stripe < rbio->nr_data)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void validate_rbio_for_parity_scrub(struct btrfs_raid_bio *rbio)\r\n{\r\nif (atomic_read(&rbio->error) > rbio->bbio->max_errors)\r\ngoto cleanup;\r\nif (rbio->faila >= 0 || rbio->failb >= 0) {\r\nint dfail = 0, failp = -1;\r\nif (is_data_stripe(rbio, rbio->faila))\r\ndfail++;\r\nelse if (is_parity_stripe(rbio->faila))\r\nfailp = rbio->faila;\r\nif (is_data_stripe(rbio, rbio->failb))\r\ndfail++;\r\nelse if (is_parity_stripe(rbio->failb))\r\nfailp = rbio->failb;\r\nif (dfail > rbio->bbio->max_errors - 1)\r\ngoto cleanup;\r\nif (dfail == 0) {\r\nfinish_parity_scrub(rbio, 0);\r\nreturn;\r\n}\r\nif (failp != rbio->scrubp)\r\ngoto cleanup;\r\n__raid_recover_end_io(rbio);\r\n} else {\r\nfinish_parity_scrub(rbio, 1);\r\n}\r\nreturn;\r\ncleanup:\r\nrbio_orig_end_io(rbio, -EIO, 0);\r\n}\r\nstatic void raid56_parity_scrub_end_io(struct bio *bio, int err)\r\n{\r\nstruct btrfs_raid_bio *rbio = bio->bi_private;\r\nif (err)\r\nfail_bio_stripe(rbio, bio);\r\nelse\r\nset_bio_pages_uptodate(bio);\r\nbio_put(bio);\r\nif (!atomic_dec_and_test(&rbio->stripes_pending))\r\nreturn;\r\nvalidate_rbio_for_parity_scrub(rbio);\r\n}\r\nstatic void raid56_parity_scrub_stripe(struct btrfs_raid_bio *rbio)\r\n{\r\nint bios_to_read = 0;\r\nstruct bio_list bio_list;\r\nint ret;\r\nint pagenr;\r\nint stripe;\r\nstruct bio *bio;\r\nret = alloc_rbio_essential_pages(rbio);\r\nif (ret)\r\ngoto cleanup;\r\nbio_list_init(&bio_list);\r\natomic_set(&rbio->error, 0);\r\nfor (stripe = 0; stripe < rbio->real_stripes; stripe++) {\r\nfor_each_set_bit(pagenr, rbio->dbitmap, rbio->stripe_npages) {\r\nstruct page *page;\r\npage = page_in_rbio(rbio, stripe, pagenr, 1);\r\nif (page)\r\ncontinue;\r\npage = rbio_stripe_page(rbio, stripe, pagenr);\r\nif (PageUptodate(page))\r\ncontinue;\r\nret = rbio_add_io_page(rbio, &bio_list, page,\r\nstripe, pagenr, rbio->stripe_len);\r\nif (ret)\r\ngoto cleanup;\r\n}\r\n}\r\nbios_to_read = bio_list_size(&bio_list);\r\nif (!bios_to_read) {\r\ngoto finish;\r\n}\r\natomic_set(&rbio->stripes_pending, bios_to_read);\r\nwhile (1) {\r\nbio = bio_list_pop(&bio_list);\r\nif (!bio)\r\nbreak;\r\nbio->bi_private = rbio;\r\nbio->bi_end_io = raid56_parity_scrub_end_io;\r\nbtrfs_bio_wq_end_io(rbio->fs_info, bio,\r\nBTRFS_WQ_ENDIO_RAID56);\r\nBUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));\r\nsubmit_bio(READ, bio);\r\n}\r\nreturn;\r\ncleanup:\r\nrbio_orig_end_io(rbio, -EIO, 0);\r\nreturn;\r\nfinish:\r\nvalidate_rbio_for_parity_scrub(rbio);\r\n}\r\nstatic void scrub_parity_work(struct btrfs_work *work)\r\n{\r\nstruct btrfs_raid_bio *rbio;\r\nrbio = container_of(work, struct btrfs_raid_bio, work);\r\nraid56_parity_scrub_stripe(rbio);\r\n}\r\nstatic void async_scrub_parity(struct btrfs_raid_bio *rbio)\r\n{\r\nbtrfs_init_work(&rbio->work, btrfs_rmw_helper,\r\nscrub_parity_work, NULL, NULL);\r\nbtrfs_queue_work(rbio->fs_info->rmw_workers,\r\n&rbio->work);\r\n}\r\nvoid raid56_parity_submit_scrub_rbio(struct btrfs_raid_bio *rbio)\r\n{\r\nif (!lock_stripe_add(rbio))\r\nasync_scrub_parity(rbio);\r\n}
