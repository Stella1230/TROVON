unsigned char cia_set_irq(struct ciabase *base, unsigned char mask)\r\n{\r\nunsigned char old;\r\nold = (base->icr_data |= base->cia->icr);\r\nif (mask & CIA_ICR_SETCLR)\r\nbase->icr_data |= mask;\r\nelse\r\nbase->icr_data &= ~mask;\r\nif (base->icr_data & base->icr_mask)\r\namiga_custom.intreq = IF_SETCLR | base->int_mask;\r\nreturn old & base->icr_mask;\r\n}\r\nunsigned char cia_able_irq(struct ciabase *base, unsigned char mask)\r\n{\r\nunsigned char old;\r\nold = base->icr_mask;\r\nbase->icr_data |= base->cia->icr;\r\nbase->cia->icr = mask;\r\nif (mask & CIA_ICR_SETCLR)\r\nbase->icr_mask |= mask;\r\nelse\r\nbase->icr_mask &= ~mask;\r\nbase->icr_mask &= CIA_ICR_ALL;\r\nif (base->icr_data & base->icr_mask)\r\namiga_custom.intreq = IF_SETCLR | base->int_mask;\r\nreturn old;\r\n}\r\nstatic irqreturn_t cia_handler(int irq, void *dev_id)\r\n{\r\nstruct ciabase *base = dev_id;\r\nint mach_irq;\r\nunsigned char ints;\r\nmach_irq = base->cia_irq;\r\nints = cia_set_irq(base, CIA_ICR_ALL);\r\namiga_custom.intreq = base->int_mask;\r\nfor (; ints; mach_irq++, ints >>= 1) {\r\nif (ints & 1)\r\ngeneric_handle_irq(mach_irq);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void cia_irq_enable(struct irq_data *data)\r\n{\r\nunsigned int irq = data->irq;\r\nunsigned char mask;\r\nif (irq >= IRQ_AMIGA_CIAB) {\r\nmask = 1 << (irq - IRQ_AMIGA_CIAB);\r\ncia_set_irq(&ciab_base, mask);\r\ncia_able_irq(&ciab_base, CIA_ICR_SETCLR | mask);\r\n} else {\r\nmask = 1 << (irq - IRQ_AMIGA_CIAA);\r\ncia_set_irq(&ciaa_base, mask);\r\ncia_able_irq(&ciaa_base, CIA_ICR_SETCLR | mask);\r\n}\r\n}\r\nstatic void cia_irq_disable(struct irq_data *data)\r\n{\r\nunsigned int irq = data->irq;\r\nif (irq >= IRQ_AMIGA_CIAB)\r\ncia_able_irq(&ciab_base, 1 << (irq - IRQ_AMIGA_CIAB));\r\nelse\r\ncia_able_irq(&ciaa_base, 1 << (irq - IRQ_AMIGA_CIAA));\r\n}\r\nstatic void auto_irq_enable(struct irq_data *data)\r\n{\r\nswitch (data->irq) {\r\ncase IRQ_AUTO_2:\r\namiga_custom.intena = IF_SETCLR | IF_PORTS;\r\nbreak;\r\ncase IRQ_AUTO_6:\r\namiga_custom.intena = IF_SETCLR | IF_EXTER;\r\nbreak;\r\n}\r\n}\r\nstatic void auto_irq_disable(struct irq_data *data)\r\n{\r\nswitch (data->irq) {\r\ncase IRQ_AUTO_2:\r\namiga_custom.intena = IF_PORTS;\r\nbreak;\r\ncase IRQ_AUTO_6:\r\namiga_custom.intena = IF_EXTER;\r\nbreak;\r\n}\r\n}\r\nvoid __init cia_init_IRQ(struct ciabase *base)\r\n{\r\nm68k_setup_irq_controller(&cia_irq_chip, handle_simple_irq,\r\nbase->cia_irq, CIA_IRQS);\r\ncia_set_irq(base, CIA_ICR_ALL);\r\ncia_able_irq(base, CIA_ICR_ALL);\r\nm68k_setup_irq_controller(&auto_irq_chip, handle_simple_irq,\r\nbase->handler_irq, 1);\r\nm68k_irq_startup_irq(base->handler_irq);\r\nif (request_irq(base->handler_irq, cia_handler, IRQF_SHARED,\r\nbase->name, base))\r\npr_err("Couldn't register %s interrupt\n", base->name);\r\n}
