static int solo_is_motion_on(struct solo_enc_dev *solo_enc)\r\n{\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nreturn (solo_dev->motion_mask >> solo_enc->ch) & 1;\r\n}\r\nstatic int solo_motion_detected(struct solo_enc_dev *solo_enc)\r\n{\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nunsigned long flags;\r\nu32 ch_mask = 1 << solo_enc->ch;\r\nint ret = 0;\r\nspin_lock_irqsave(&solo_enc->motion_lock, flags);\r\nif (solo_reg_read(solo_dev, SOLO_VI_MOT_STATUS) & ch_mask) {\r\nsolo_reg_write(solo_dev, SOLO_VI_MOT_CLEAR, ch_mask);\r\nret = 1;\r\n}\r\nspin_unlock_irqrestore(&solo_enc->motion_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void solo_motion_toggle(struct solo_enc_dev *solo_enc, int on)\r\n{\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nu32 mask = 1 << solo_enc->ch;\r\nunsigned long flags;\r\nspin_lock_irqsave(&solo_enc->motion_lock, flags);\r\nif (on)\r\nsolo_dev->motion_mask |= mask;\r\nelse\r\nsolo_dev->motion_mask &= ~mask;\r\nsolo_reg_write(solo_dev, SOLO_VI_MOT_CLEAR, mask);\r\nsolo_reg_write(solo_dev, SOLO_VI_MOT_ADR,\r\nSOLO_VI_MOTION_EN(solo_dev->motion_mask) |\r\n(SOLO_MOTION_EXT_ADDR(solo_dev) >> 16));\r\nspin_unlock_irqrestore(&solo_enc->motion_lock, flags);\r\n}\r\nvoid solo_update_mode(struct solo_enc_dev *solo_enc)\r\n{\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nint vop_len;\r\nu8 *vop;\r\nsolo_enc->interlaced = (solo_enc->mode & 0x08) ? 1 : 0;\r\nsolo_enc->bw_weight = max(solo_dev->fps / solo_enc->interval, 1);\r\nif (solo_enc->mode == SOLO_ENC_MODE_CIF) {\r\nsolo_enc->width = solo_dev->video_hsize >> 1;\r\nsolo_enc->height = solo_dev->video_vsize;\r\nif (solo_dev->type == SOLO_DEV_6110) {\r\nif (solo_dev->video_type == SOLO_VO_FMT_TYPE_NTSC) {\r\nvop = vop_6110_ntsc_cif;\r\nvop_len = sizeof(vop_6110_ntsc_cif);\r\n} else {\r\nvop = vop_6110_pal_cif;\r\nvop_len = sizeof(vop_6110_pal_cif);\r\n}\r\n} else {\r\nif (solo_dev->video_type == SOLO_VO_FMT_TYPE_NTSC) {\r\nvop = vop_6010_ntsc_cif;\r\nvop_len = sizeof(vop_6010_ntsc_cif);\r\n} else {\r\nvop = vop_6010_pal_cif;\r\nvop_len = sizeof(vop_6010_pal_cif);\r\n}\r\n}\r\n} else {\r\nsolo_enc->width = solo_dev->video_hsize;\r\nsolo_enc->height = solo_dev->video_vsize << 1;\r\nsolo_enc->bw_weight <<= 2;\r\nif (solo_dev->type == SOLO_DEV_6110) {\r\nif (solo_dev->video_type == SOLO_VO_FMT_TYPE_NTSC) {\r\nvop = vop_6110_ntsc_d1;\r\nvop_len = sizeof(vop_6110_ntsc_d1);\r\n} else {\r\nvop = vop_6110_pal_d1;\r\nvop_len = sizeof(vop_6110_pal_d1);\r\n}\r\n} else {\r\nif (solo_dev->video_type == SOLO_VO_FMT_TYPE_NTSC) {\r\nvop = vop_6010_ntsc_d1;\r\nvop_len = sizeof(vop_6010_ntsc_d1);\r\n} else {\r\nvop = vop_6010_pal_d1;\r\nvop_len = sizeof(vop_6010_pal_d1);\r\n}\r\n}\r\n}\r\nmemcpy(solo_enc->vop, vop, vop_len);\r\nif (solo_dev->type == SOLO_DEV_6010) {\r\nu16 fps = solo_dev->fps * 1000;\r\nu16 interval = solo_enc->interval * 1000;\r\nvop = solo_enc->vop;\r\nvop[22] = fps >> 4;\r\nvop[23] = ((fps << 4) & 0xf0) | 0x0c\r\n| ((interval >> 13) & 0x3);\r\nvop[24] = (interval >> 5) & 0xff;\r\nvop[25] = ((interval << 3) & 0xf8) | 0x04;\r\n}\r\nsolo_enc->vop_len = vop_len;\r\nvop = solo_enc->jpeg_header;\r\nvop[SOF0_START + 5] = 0xff & (solo_enc->height >> 8);\r\nvop[SOF0_START + 6] = 0xff & solo_enc->height;\r\nvop[SOF0_START + 7] = 0xff & (solo_enc->width >> 8);\r\nvop[SOF0_START + 8] = 0xff & solo_enc->width;\r\nmemcpy(vop + DQT_START,\r\njpeg_dqt[solo_g_jpeg_qp(solo_dev, solo_enc->ch)], DQT_LEN);\r\n}\r\nstatic int solo_enc_on(struct solo_enc_dev *solo_enc)\r\n{\r\nu8 ch = solo_enc->ch;\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nu8 interval;\r\nsolo_update_mode(solo_enc);\r\nif (solo_enc->bw_weight > solo_dev->enc_bw_remain)\r\nreturn -EBUSY;\r\nsolo_enc->sequence = 0;\r\nsolo_dev->enc_bw_remain -= solo_enc->bw_weight;\r\nif (solo_enc->type == SOLO_ENC_TYPE_EXT)\r\nsolo_reg_write(solo_dev, SOLO_CAP_CH_COMP_ENA_E(ch), 1);\r\nsolo_reg_write(solo_dev, SOLO_CAP_CH_SCALE(ch), 0);\r\nsolo_reg_write(solo_dev, SOLO_VE_CH_INTL(ch),\r\nsolo_enc->interlaced ? 1 : 0);\r\nif (solo_enc->interlaced)\r\ninterval = solo_enc->interval - 1;\r\nelse\r\ninterval = solo_enc->interval;\r\nsolo_reg_write(solo_dev, SOLO_VE_CH_GOP(ch), solo_enc->gop);\r\nsolo_reg_write(solo_dev, SOLO_VE_CH_QP(ch), solo_enc->qp);\r\nsolo_reg_write(solo_dev, SOLO_CAP_CH_INTV(ch), interval);\r\nsolo_reg_write(solo_dev, SOLO_VE_CH_GOP_E(ch), solo_enc->gop);\r\nsolo_reg_write(solo_dev, SOLO_VE_CH_QP_E(ch), solo_enc->qp);\r\nsolo_reg_write(solo_dev, SOLO_CAP_CH_INTV_E(ch), interval);\r\nsolo_reg_write(solo_dev, SOLO_CAP_CH_SCALE(ch), solo_enc->mode);\r\nreturn 0;\r\n}\r\nstatic void solo_enc_off(struct solo_enc_dev *solo_enc)\r\n{\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nsolo_dev->enc_bw_remain += solo_enc->bw_weight;\r\nsolo_reg_write(solo_dev, SOLO_CAP_CH_SCALE(solo_enc->ch), 0);\r\nsolo_reg_write(solo_dev, SOLO_CAP_CH_COMP_ENA_E(solo_enc->ch), 0);\r\n}\r\nstatic int enc_get_mpeg_dma(struct solo_dev *solo_dev, dma_addr_t dma,\r\nunsigned int off, unsigned int size)\r\n{\r\nint ret;\r\nif (off > SOLO_MP4E_EXT_SIZE(solo_dev))\r\nreturn -EINVAL;\r\nif (off + size <= SOLO_MP4E_EXT_SIZE(solo_dev)) {\r\nreturn solo_p2m_dma_t(solo_dev, 0, dma,\r\nSOLO_MP4E_EXT_ADDR(solo_dev) + off, size,\r\n0, 0);\r\n}\r\nret = solo_p2m_dma_t(solo_dev, 0, dma,\r\nSOLO_MP4E_EXT_ADDR(solo_dev) + off,\r\nSOLO_MP4E_EXT_SIZE(solo_dev) - off, 0, 0);\r\nif (!ret) {\r\nret = solo_p2m_dma_t(solo_dev, 0,\r\ndma + SOLO_MP4E_EXT_SIZE(solo_dev) - off,\r\nSOLO_MP4E_EXT_ADDR(solo_dev),\r\nsize + off - SOLO_MP4E_EXT_SIZE(solo_dev), 0, 0);\r\n}\r\nreturn ret;\r\n}\r\nstatic int solo_send_desc(struct solo_enc_dev *solo_enc, int skip,\r\nstruct sg_table *vbuf, int off, int size,\r\nunsigned int base, unsigned int base_size)\r\n{\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nstruct scatterlist *sg;\r\nint i;\r\nint ret;\r\nif (WARN_ON_ONCE(size > FRAME_BUF_SIZE))\r\nreturn -EINVAL;\r\nsolo_enc->desc_count = 1;\r\nfor_each_sg(vbuf->sgl, sg, vbuf->nents, i) {\r\nstruct solo_p2m_desc *desc;\r\ndma_addr_t dma;\r\nint len;\r\nint left = base_size - off;\r\ndesc = &solo_enc->desc_items[solo_enc->desc_count++];\r\ndma = sg_dma_address(sg);\r\nlen = sg_dma_len(sg);\r\nBUG_ON(skip >= len);\r\nif (skip) {\r\nlen -= skip;\r\ndma += skip;\r\nsize -= skip;\r\nskip = 0;\r\n}\r\nlen = min(len, size);\r\nif (len <= left) {\r\nsolo_p2m_fill_desc(desc, 0, dma, base + off,\r\nlen, 0, 0);\r\n} else {\r\nret = solo_p2m_dma_t(solo_dev, 0, dma, base + off,\r\nleft, 0, 0);\r\nif (ret)\r\nreturn ret;\r\nret = solo_p2m_dma_t(solo_dev, 0, dma + left, base,\r\nlen - left, 0, 0);\r\nif (ret)\r\nreturn ret;\r\nsolo_enc->desc_count--;\r\n}\r\nsize -= len;\r\nif (size <= 0)\r\nbreak;\r\noff += len;\r\nif (off >= base_size)\r\noff -= base_size;\r\nif (solo_enc->desc_count >= (solo_enc->desc_nelts - 1)) {\r\nret = solo_p2m_dma_desc(solo_dev, solo_enc->desc_items,\r\nsolo_enc->desc_dma,\r\nsolo_enc->desc_count - 1);\r\nif (ret)\r\nreturn ret;\r\nsolo_enc->desc_count = 1;\r\n}\r\n}\r\nif (solo_enc->desc_count <= 1)\r\nreturn 0;\r\nreturn solo_p2m_dma_desc(solo_dev, solo_enc->desc_items,\r\nsolo_enc->desc_dma, solo_enc->desc_count - 1);\r\n}\r\nstatic inline int vop_interlaced(const vop_header *vh)\r\n{\r\nreturn (__le32_to_cpu((*vh)[0]) >> 30) & 1;\r\n}\r\nstatic inline u8 vop_channel(const vop_header *vh)\r\n{\r\nreturn (__le32_to_cpu((*vh)[0]) >> 24) & 0x1F;\r\n}\r\nstatic inline u8 vop_type(const vop_header *vh)\r\n{\r\nreturn (__le32_to_cpu((*vh)[0]) >> 22) & 3;\r\n}\r\nstatic inline u32 vop_mpeg_size(const vop_header *vh)\r\n{\r\nreturn __le32_to_cpu((*vh)[0]) & 0xFFFFF;\r\n}\r\nstatic inline u8 vop_hsize(const vop_header *vh)\r\n{\r\nreturn (__le32_to_cpu((*vh)[1]) >> 8) & 0xFF;\r\n}\r\nstatic inline u8 vop_vsize(const vop_header *vh)\r\n{\r\nreturn __le32_to_cpu((*vh)[1]) & 0xFF;\r\n}\r\nstatic inline u32 vop_mpeg_offset(const vop_header *vh)\r\n{\r\nreturn __le32_to_cpu((*vh)[2]);\r\n}\r\nstatic inline u32 vop_jpeg_offset(const vop_header *vh)\r\n{\r\nreturn __le32_to_cpu((*vh)[3]);\r\n}\r\nstatic inline u32 vop_jpeg_size(const vop_header *vh)\r\n{\r\nreturn __le32_to_cpu((*vh)[4]) & 0xFFFFF;\r\n}\r\nstatic inline u32 vop_sec(const vop_header *vh)\r\n{\r\nreturn __le32_to_cpu((*vh)[5]);\r\n}\r\nstatic inline u32 vop_usec(const vop_header *vh)\r\n{\r\nreturn __le32_to_cpu((*vh)[6]);\r\n}\r\nstatic int solo_fill_jpeg(struct solo_enc_dev *solo_enc,\r\nstruct vb2_buffer *vb, const vop_header *vh)\r\n{\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nstruct sg_table *vbuf = vb2_dma_sg_plane_desc(vb, 0);\r\nint frame_size;\r\nvb->v4l2_buf.flags |= V4L2_BUF_FLAG_KEYFRAME;\r\nif (vb2_plane_size(vb, 0) < vop_jpeg_size(vh) + solo_enc->jpeg_len)\r\nreturn -EIO;\r\nframe_size = ALIGN(vop_jpeg_size(vh) + solo_enc->jpeg_len, DMA_ALIGN);\r\nvb2_set_plane_payload(vb, 0, vop_jpeg_size(vh) + solo_enc->jpeg_len);\r\nreturn solo_send_desc(solo_enc, solo_enc->jpeg_len, vbuf,\r\nvop_jpeg_offset(vh) - SOLO_JPEG_EXT_ADDR(solo_dev),\r\nframe_size, SOLO_JPEG_EXT_ADDR(solo_dev),\r\nSOLO_JPEG_EXT_SIZE(solo_dev));\r\n}\r\nstatic int solo_fill_mpeg(struct solo_enc_dev *solo_enc,\r\nstruct vb2_buffer *vb, const vop_header *vh)\r\n{\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nstruct sg_table *vbuf = vb2_dma_sg_plane_desc(vb, 0);\r\nint frame_off, frame_size;\r\nint skip = 0;\r\nif (vb2_plane_size(vb, 0) < vop_mpeg_size(vh))\r\nreturn -EIO;\r\nvb->v4l2_buf.flags &= ~(V4L2_BUF_FLAG_KEYFRAME | V4L2_BUF_FLAG_PFRAME |\r\nV4L2_BUF_FLAG_BFRAME);\r\nif (!vop_type(vh)) {\r\nskip = solo_enc->vop_len;\r\nvb->v4l2_buf.flags |= V4L2_BUF_FLAG_KEYFRAME;\r\nvb2_set_plane_payload(vb, 0, vop_mpeg_size(vh) +\r\nsolo_enc->vop_len);\r\n} else {\r\nvb->v4l2_buf.flags |= V4L2_BUF_FLAG_PFRAME;\r\nvb2_set_plane_payload(vb, 0, vop_mpeg_size(vh));\r\n}\r\nframe_off = (vop_mpeg_offset(vh) - SOLO_MP4E_EXT_ADDR(solo_dev) +\r\nsizeof(*vh)) % SOLO_MP4E_EXT_SIZE(solo_dev);\r\nframe_size = ALIGN(vop_mpeg_size(vh) + skip, DMA_ALIGN);\r\nreturn solo_send_desc(solo_enc, skip, vbuf, frame_off, frame_size,\r\nSOLO_MP4E_EXT_ADDR(solo_dev),\r\nSOLO_MP4E_EXT_SIZE(solo_dev));\r\n}\r\nstatic int solo_enc_fillbuf(struct solo_enc_dev *solo_enc,\r\nstruct vb2_buffer *vb, struct solo_enc_buf *enc_buf)\r\n{\r\nconst vop_header *vh = enc_buf->vh;\r\nint ret;\r\nswitch (solo_enc->fmt) {\r\ncase V4L2_PIX_FMT_MPEG4:\r\ncase V4L2_PIX_FMT_H264:\r\nret = solo_fill_mpeg(solo_enc, vb, vh);\r\nbreak;\r\ndefault:\r\nret = solo_fill_jpeg(solo_enc, vb, vh);\r\nbreak;\r\n}\r\nif (!ret) {\r\nvb->v4l2_buf.sequence = solo_enc->sequence++;\r\nvb->v4l2_buf.timestamp.tv_sec = vop_sec(vh);\r\nvb->v4l2_buf.timestamp.tv_usec = vop_usec(vh);\r\nif (solo_is_motion_on(solo_enc) && enc_buf->motion) {\r\nstruct v4l2_event ev = {\r\n.type = V4L2_EVENT_MOTION_DET,\r\n.u.motion_det = {\r\n.flags = V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ,\r\n.frame_sequence = vb->v4l2_buf.sequence,\r\n.region_mask = enc_buf->motion ? 1 : 0,\r\n},\r\n};\r\nv4l2_event_queue(solo_enc->vfd, &ev);\r\n}\r\n}\r\nvb2_buffer_done(vb, ret ? VB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);\r\nreturn ret;\r\n}\r\nstatic void solo_enc_handle_one(struct solo_enc_dev *solo_enc,\r\nstruct solo_enc_buf *enc_buf)\r\n{\r\nstruct solo_vb2_buf *vb;\r\nunsigned long flags;\r\nmutex_lock(&solo_enc->lock);\r\nif (solo_enc->type != enc_buf->type)\r\ngoto unlock;\r\nspin_lock_irqsave(&solo_enc->av_lock, flags);\r\nif (list_empty(&solo_enc->vidq_active)) {\r\nspin_unlock_irqrestore(&solo_enc->av_lock, flags);\r\ngoto unlock;\r\n}\r\nvb = list_first_entry(&solo_enc->vidq_active, struct solo_vb2_buf,\r\nlist);\r\nlist_del(&vb->list);\r\nspin_unlock_irqrestore(&solo_enc->av_lock, flags);\r\nsolo_enc_fillbuf(solo_enc, &vb->vb, enc_buf);\r\nunlock:\r\nmutex_unlock(&solo_enc->lock);\r\n}\r\nvoid solo_enc_v4l2_isr(struct solo_dev *solo_dev)\r\n{\r\nwake_up_interruptible_all(&solo_dev->ring_thread_wait);\r\n}\r\nstatic void solo_handle_ring(struct solo_dev *solo_dev)\r\n{\r\nfor (;;) {\r\nstruct solo_enc_dev *solo_enc;\r\nstruct solo_enc_buf enc_buf;\r\nu32 mpeg_current, off;\r\nu8 ch;\r\nu8 cur_q;\r\ncur_q = solo_reg_read(solo_dev, SOLO_VE_STATE(11)) & 0xff;\r\nif (cur_q == solo_dev->enc_idx)\r\nbreak;\r\nmpeg_current = solo_reg_read(solo_dev,\r\nSOLO_VE_MPEG4_QUE(solo_dev->enc_idx));\r\nsolo_dev->enc_idx = (solo_dev->enc_idx + 1) % MP4_QS;\r\nch = (mpeg_current >> 24) & 0x1f;\r\noff = mpeg_current & 0x00ffffff;\r\nif (ch >= SOLO_MAX_CHANNELS) {\r\nch -= SOLO_MAX_CHANNELS;\r\nenc_buf.type = SOLO_ENC_TYPE_EXT;\r\n} else\r\nenc_buf.type = SOLO_ENC_TYPE_STD;\r\nsolo_enc = solo_dev->v4l2_enc[ch];\r\nif (solo_enc == NULL) {\r\ndev_err(&solo_dev->pdev->dev,\r\n"Got spurious packet for channel %d\n", ch);\r\ncontinue;\r\n}\r\nif (enc_get_mpeg_dma(solo_dev, solo_dev->vh_dma, off,\r\nsizeof(vop_header)))\r\ncontinue;\r\nenc_buf.vh = solo_dev->vh_buf;\r\nif (vop_mpeg_offset(enc_buf.vh) !=\r\nSOLO_MP4E_EXT_ADDR(solo_dev) + off)\r\ncontinue;\r\nif (solo_motion_detected(solo_enc))\r\nenc_buf.motion = 1;\r\nelse\r\nenc_buf.motion = 0;\r\nsolo_enc_handle_one(solo_enc, &enc_buf);\r\n}\r\n}\r\nstatic int solo_ring_thread(void *data)\r\n{\r\nstruct solo_dev *solo_dev = data;\r\nDECLARE_WAITQUEUE(wait, current);\r\nset_freezable();\r\nadd_wait_queue(&solo_dev->ring_thread_wait, &wait);\r\nfor (;;) {\r\nlong timeout = schedule_timeout_interruptible(HZ);\r\nif (timeout == -ERESTARTSYS || kthread_should_stop())\r\nbreak;\r\nsolo_handle_ring(solo_dev);\r\ntry_to_freeze();\r\n}\r\nremove_wait_queue(&solo_dev->ring_thread_wait, &wait);\r\nreturn 0;\r\n}\r\nstatic int solo_enc_queue_setup(struct vb2_queue *q,\r\nconst struct v4l2_format *fmt,\r\nunsigned int *num_buffers,\r\nunsigned int *num_planes, unsigned int sizes[],\r\nvoid *alloc_ctxs[])\r\n{\r\nstruct solo_enc_dev *solo_enc = vb2_get_drv_priv(q);\r\nsizes[0] = FRAME_BUF_SIZE;\r\nalloc_ctxs[0] = solo_enc->alloc_ctx;\r\n*num_planes = 1;\r\nif (*num_buffers < MIN_VID_BUFFERS)\r\n*num_buffers = MIN_VID_BUFFERS;\r\nreturn 0;\r\n}\r\nstatic void solo_enc_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_queue *vq = vb->vb2_queue;\r\nstruct solo_enc_dev *solo_enc = vb2_get_drv_priv(vq);\r\nstruct solo_vb2_buf *solo_vb =\r\ncontainer_of(vb, struct solo_vb2_buf, vb);\r\nspin_lock(&solo_enc->av_lock);\r\nlist_add_tail(&solo_vb->list, &solo_enc->vidq_active);\r\nspin_unlock(&solo_enc->av_lock);\r\n}\r\nstatic int solo_ring_start(struct solo_dev *solo_dev)\r\n{\r\nsolo_dev->ring_thread = kthread_run(solo_ring_thread, solo_dev,\r\nSOLO6X10_NAME "_ring");\r\nif (IS_ERR(solo_dev->ring_thread)) {\r\nint err = PTR_ERR(solo_dev->ring_thread);\r\nsolo_dev->ring_thread = NULL;\r\nreturn err;\r\n}\r\nsolo_irq_on(solo_dev, SOLO_IRQ_ENCODER);\r\nreturn 0;\r\n}\r\nstatic void solo_ring_stop(struct solo_dev *solo_dev)\r\n{\r\nif (solo_dev->ring_thread) {\r\nkthread_stop(solo_dev->ring_thread);\r\nsolo_dev->ring_thread = NULL;\r\n}\r\nsolo_irq_off(solo_dev, SOLO_IRQ_ENCODER);\r\n}\r\nstatic int solo_enc_start_streaming(struct vb2_queue *q, unsigned int count)\r\n{\r\nstruct solo_enc_dev *solo_enc = vb2_get_drv_priv(q);\r\nreturn solo_enc_on(solo_enc);\r\n}\r\nstatic void solo_enc_stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct solo_enc_dev *solo_enc = vb2_get_drv_priv(q);\r\nunsigned long flags;\r\nspin_lock_irqsave(&solo_enc->av_lock, flags);\r\nsolo_enc_off(solo_enc);\r\nwhile (!list_empty(&solo_enc->vidq_active)) {\r\nstruct solo_vb2_buf *buf = list_entry(\r\nsolo_enc->vidq_active.next,\r\nstruct solo_vb2_buf, list);\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irqrestore(&solo_enc->av_lock, flags);\r\n}\r\nstatic void solo_enc_buf_finish(struct vb2_buffer *vb)\r\n{\r\nstruct solo_enc_dev *solo_enc = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct sg_table *vbuf = vb2_dma_sg_plane_desc(vb, 0);\r\nswitch (solo_enc->fmt) {\r\ncase V4L2_PIX_FMT_MPEG4:\r\ncase V4L2_PIX_FMT_H264:\r\nif (vb->v4l2_buf.flags & V4L2_BUF_FLAG_KEYFRAME)\r\nsg_copy_from_buffer(vbuf->sgl, vbuf->nents,\r\nsolo_enc->vop, solo_enc->vop_len);\r\nbreak;\r\ndefault:\r\nsg_copy_from_buffer(vbuf->sgl, vbuf->nents,\r\nsolo_enc->jpeg_header, solo_enc->jpeg_len);\r\nbreak;\r\n}\r\n}\r\nstatic int solo_enc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct solo_enc_dev *solo_enc = video_drvdata(file);\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nstrcpy(cap->driver, SOLO6X10_NAME);\r\nsnprintf(cap->card, sizeof(cap->card), "Softlogic 6x10 Enc %d",\r\nsolo_enc->ch);\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info), "PCI:%s",\r\npci_name(solo_dev->pdev));\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_READWRITE | V4L2_CAP_STREAMING;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int solo_enc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *input)\r\n{\r\nstruct solo_enc_dev *solo_enc = video_drvdata(file);\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nif (input->index)\r\nreturn -EINVAL;\r\nsnprintf(input->name, sizeof(input->name), "Encoder %d",\r\nsolo_enc->ch + 1);\r\ninput->type = V4L2_INPUT_TYPE_CAMERA;\r\ninput->std = solo_enc->vfd->tvnorms;\r\nif (!tw28_get_video_status(solo_dev, solo_enc->ch))\r\ninput->status = V4L2_IN_ST_NO_SIGNAL;\r\nreturn 0;\r\n}\r\nstatic int solo_enc_set_input(struct file *file, void *priv,\r\nunsigned int index)\r\n{\r\nif (index)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int solo_enc_get_input(struct file *file, void *priv,\r\nunsigned int *index)\r\n{\r\n*index = 0;\r\nreturn 0;\r\n}\r\nstatic int solo_enc_enum_fmt_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct solo_enc_dev *solo_enc = video_drvdata(file);\r\nint dev_type = solo_enc->solo_dev->type;\r\nswitch (f->index) {\r\ncase 0:\r\nswitch (dev_type) {\r\ncase SOLO_DEV_6010:\r\nf->pixelformat = V4L2_PIX_FMT_MPEG4;\r\nstrcpy(f->description, "MPEG-4 part 2");\r\nbreak;\r\ncase SOLO_DEV_6110:\r\nf->pixelformat = V4L2_PIX_FMT_H264;\r\nstrcpy(f->description, "H.264");\r\nbreak;\r\n}\r\nbreak;\r\ncase 1:\r\nf->pixelformat = V4L2_PIX_FMT_MJPEG;\r\nstrcpy(f->description, "MJPEG");\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nf->flags = V4L2_FMT_FLAG_COMPRESSED;\r\nreturn 0;\r\n}\r\nstatic inline int solo_valid_pixfmt(u32 pixfmt, int dev_type)\r\n{\r\nreturn (pixfmt == V4L2_PIX_FMT_H264 && dev_type == SOLO_DEV_6110)\r\n|| (pixfmt == V4L2_PIX_FMT_MPEG4 && dev_type == SOLO_DEV_6010)\r\n|| pixfmt == V4L2_PIX_FMT_MJPEG ? 0 : -EINVAL;\r\n}\r\nstatic int solo_enc_try_fmt_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct solo_enc_dev *solo_enc = video_drvdata(file);\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nif (solo_valid_pixfmt(pix->pixelformat, solo_dev->type))\r\nreturn -EINVAL;\r\nif (pix->width < solo_dev->video_hsize ||\r\npix->height < solo_dev->video_vsize << 1) {\r\npix->width = solo_dev->video_hsize >> 1;\r\npix->height = solo_dev->video_vsize;\r\n} else {\r\npix->width = solo_dev->video_hsize;\r\npix->height = solo_dev->video_vsize << 1;\r\n}\r\nswitch (pix->field) {\r\ncase V4L2_FIELD_NONE:\r\ncase V4L2_FIELD_INTERLACED:\r\nbreak;\r\ncase V4L2_FIELD_ANY:\r\ndefault:\r\npix->field = V4L2_FIELD_INTERLACED;\r\nbreak;\r\n}\r\npix->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\npix->sizeimage = FRAME_BUF_SIZE;\r\npix->bytesperline = 0;\r\npix->priv = 0;\r\nreturn 0;\r\n}\r\nstatic int solo_enc_set_fmt_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct solo_enc_dev *solo_enc = video_drvdata(file);\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nint ret;\r\nif (vb2_is_busy(&solo_enc->vidq))\r\nreturn -EBUSY;\r\nret = solo_enc_try_fmt_cap(file, priv, f);\r\nif (ret)\r\nreturn ret;\r\nif (pix->width == solo_dev->video_hsize)\r\nsolo_enc->mode = SOLO_ENC_MODE_D1;\r\nelse\r\nsolo_enc->mode = SOLO_ENC_MODE_CIF;\r\nsolo_enc->fmt = pix->pixelformat;\r\nsolo_update_mode(solo_enc);\r\nreturn 0;\r\n}\r\nstatic int solo_enc_get_fmt_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct solo_enc_dev *solo_enc = video_drvdata(file);\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\npix->width = solo_enc->width;\r\npix->height = solo_enc->height;\r\npix->pixelformat = solo_enc->fmt;\r\npix->field = solo_enc->interlaced ? V4L2_FIELD_INTERLACED :\r\nV4L2_FIELD_NONE;\r\npix->sizeimage = FRAME_BUF_SIZE;\r\npix->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\npix->priv = 0;\r\nreturn 0;\r\n}\r\nstatic int solo_enc_g_std(struct file *file, void *priv, v4l2_std_id *i)\r\n{\r\nstruct solo_enc_dev *solo_enc = video_drvdata(file);\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nif (solo_dev->video_type == SOLO_VO_FMT_TYPE_NTSC)\r\n*i = V4L2_STD_NTSC_M;\r\nelse\r\n*i = V4L2_STD_PAL;\r\nreturn 0;\r\n}\r\nstatic int solo_enc_s_std(struct file *file, void *priv, v4l2_std_id std)\r\n{\r\nstruct solo_enc_dev *solo_enc = video_drvdata(file);\r\nreturn solo_set_video_type(solo_enc->solo_dev, std & V4L2_STD_625_50);\r\n}\r\nstatic int solo_enum_framesizes(struct file *file, void *priv,\r\nstruct v4l2_frmsizeenum *fsize)\r\n{\r\nstruct solo_enc_dev *solo_enc = video_drvdata(file);\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nif (solo_valid_pixfmt(fsize->pixel_format, solo_dev->type))\r\nreturn -EINVAL;\r\nswitch (fsize->index) {\r\ncase 0:\r\nfsize->discrete.width = solo_dev->video_hsize >> 1;\r\nfsize->discrete.height = solo_dev->video_vsize;\r\nbreak;\r\ncase 1:\r\nfsize->discrete.width = solo_dev->video_hsize;\r\nfsize->discrete.height = solo_dev->video_vsize << 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\r\nreturn 0;\r\n}\r\nstatic int solo_enum_frameintervals(struct file *file, void *priv,\r\nstruct v4l2_frmivalenum *fintv)\r\n{\r\nstruct solo_enc_dev *solo_enc = video_drvdata(file);\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nif (solo_valid_pixfmt(fintv->pixel_format, solo_dev->type))\r\nreturn -EINVAL;\r\nif (fintv->index)\r\nreturn -EINVAL;\r\nif ((fintv->width != solo_dev->video_hsize >> 1 ||\r\nfintv->height != solo_dev->video_vsize) &&\r\n(fintv->width != solo_dev->video_hsize ||\r\nfintv->height != solo_dev->video_vsize << 1))\r\nreturn -EINVAL;\r\nfintv->type = V4L2_FRMIVAL_TYPE_STEPWISE;\r\nfintv->stepwise.min.numerator = 1;\r\nfintv->stepwise.min.denominator = solo_dev->fps;\r\nfintv->stepwise.max.numerator = 15;\r\nfintv->stepwise.max.denominator = solo_dev->fps;\r\nfintv->stepwise.step.numerator = 1;\r\nfintv->stepwise.step.denominator = solo_dev->fps;\r\nreturn 0;\r\n}\r\nstatic int solo_g_parm(struct file *file, void *priv,\r\nstruct v4l2_streamparm *sp)\r\n{\r\nstruct solo_enc_dev *solo_enc = video_drvdata(file);\r\nstruct v4l2_captureparm *cp = &sp->parm.capture;\r\ncp->capability = V4L2_CAP_TIMEPERFRAME;\r\ncp->timeperframe.numerator = solo_enc->interval;\r\ncp->timeperframe.denominator = solo_enc->solo_dev->fps;\r\ncp->capturemode = 0;\r\ncp->readbuffers = 2;\r\nreturn 0;\r\n}\r\nstatic inline int calc_interval(u8 fps, u32 n, u32 d)\r\n{\r\nif (!n || !d)\r\nreturn 1;\r\nif (d == fps)\r\nreturn n;\r\nn *= fps;\r\nreturn min(15U, n / d + (n % d >= (fps >> 1)));\r\n}\r\nstatic int solo_s_parm(struct file *file, void *priv,\r\nstruct v4l2_streamparm *sp)\r\n{\r\nstruct solo_enc_dev *solo_enc = video_drvdata(file);\r\nstruct v4l2_fract *t = &sp->parm.capture.timeperframe;\r\nu8 fps = solo_enc->solo_dev->fps;\r\nif (vb2_is_streaming(&solo_enc->vidq))\r\nreturn -EBUSY;\r\nsolo_enc->interval = calc_interval(fps, t->numerator, t->denominator);\r\nsolo_update_mode(solo_enc);\r\nreturn solo_g_parm(file, priv, sp);\r\n}\r\nstatic int solo_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct solo_enc_dev *solo_enc =\r\ncontainer_of(ctrl->handler, struct solo_enc_dev, hdl);\r\nstruct solo_dev *solo_dev = solo_enc->solo_dev;\r\nint err;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\ncase V4L2_CID_CONTRAST:\r\ncase V4L2_CID_SATURATION:\r\ncase V4L2_CID_HUE:\r\ncase V4L2_CID_SHARPNESS:\r\nreturn tw28_set_ctrl_val(solo_dev, ctrl->id, solo_enc->ch,\r\nctrl->val);\r\ncase V4L2_CID_MPEG_VIDEO_GOP_SIZE:\r\nsolo_enc->gop = ctrl->val;\r\nsolo_reg_write(solo_dev, SOLO_VE_CH_GOP(solo_enc->ch), solo_enc->gop);\r\nsolo_reg_write(solo_dev, SOLO_VE_CH_GOP_E(solo_enc->ch), solo_enc->gop);\r\nreturn 0;\r\ncase V4L2_CID_MPEG_VIDEO_H264_MIN_QP:\r\nsolo_enc->qp = ctrl->val;\r\nsolo_reg_write(solo_dev, SOLO_VE_CH_QP(solo_enc->ch), solo_enc->qp);\r\nsolo_reg_write(solo_dev, SOLO_VE_CH_QP_E(solo_enc->ch), solo_enc->qp);\r\nreturn 0;\r\ncase V4L2_CID_DETECT_MD_GLOBAL_THRESHOLD:\r\nsolo_enc->motion_thresh = ctrl->val << 8;\r\nif (!solo_enc->motion_global || !solo_enc->motion_enabled)\r\nreturn 0;\r\nreturn solo_set_motion_threshold(solo_dev, solo_enc->ch,\r\nsolo_enc->motion_thresh);\r\ncase V4L2_CID_DETECT_MD_MODE:\r\nsolo_enc->motion_global = ctrl->val == V4L2_DETECT_MD_MODE_GLOBAL;\r\nsolo_enc->motion_enabled = ctrl->val > V4L2_DETECT_MD_MODE_DISABLED;\r\nif (ctrl->val) {\r\nif (solo_enc->motion_global)\r\nerr = solo_set_motion_threshold(solo_dev, solo_enc->ch,\r\nsolo_enc->motion_thresh);\r\nelse\r\nerr = solo_set_motion_block(solo_dev, solo_enc->ch,\r\nsolo_enc->md_thresholds->p_cur.p_u16);\r\nif (err)\r\nreturn err;\r\n}\r\nsolo_motion_toggle(solo_enc, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_DETECT_MD_THRESHOLD_GRID:\r\nif (solo_enc->motion_enabled && !solo_enc->motion_global)\r\nreturn solo_set_motion_block(solo_dev, solo_enc->ch,\r\nsolo_enc->md_thresholds->p_new.p_u16);\r\nbreak;\r\ncase V4L2_CID_OSD_TEXT:\r\nstrcpy(solo_enc->osd_text, ctrl->p_new.p_char);\r\nreturn solo_osd_print(solo_enc);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int solo_subscribe_event(struct v4l2_fh *fh,\r\nconst struct v4l2_event_subscription *sub)\r\n{\r\nswitch (sub->type) {\r\ncase V4L2_EVENT_CTRL:\r\nreturn v4l2_ctrl_subscribe_event(fh, sub);\r\ncase V4L2_EVENT_MOTION_DET:\r\nreturn v4l2_event_subscribe(fh, sub, 30, NULL);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic struct solo_enc_dev *solo_enc_alloc(struct solo_dev *solo_dev,\r\nu8 ch, unsigned nr)\r\n{\r\nstruct solo_enc_dev *solo_enc;\r\nstruct v4l2_ctrl_handler *hdl;\r\nint ret;\r\nsolo_enc = kzalloc(sizeof(*solo_enc), GFP_KERNEL);\r\nif (!solo_enc)\r\nreturn ERR_PTR(-ENOMEM);\r\nhdl = &solo_enc->hdl;\r\nsolo_enc->alloc_ctx = vb2_dma_sg_init_ctx(&solo_dev->pdev->dev);\r\nif (IS_ERR(solo_enc->alloc_ctx)) {\r\nret = PTR_ERR(solo_enc->alloc_ctx);\r\ngoto hdl_free;\r\n}\r\nv4l2_ctrl_handler_init(hdl, 10);\r\nv4l2_ctrl_new_std(hdl, &solo_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(hdl, &solo_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(hdl, &solo_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(hdl, &solo_ctrl_ops,\r\nV4L2_CID_HUE, 0, 255, 1, 128);\r\nif (tw28_has_sharpness(solo_dev, ch))\r\nv4l2_ctrl_new_std(hdl, &solo_ctrl_ops,\r\nV4L2_CID_SHARPNESS, 0, 15, 1, 0);\r\nv4l2_ctrl_new_std(hdl, &solo_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_GOP_SIZE, 1, 255, 1, solo_dev->fps);\r\nv4l2_ctrl_new_std(hdl, &solo_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_H264_MIN_QP, 0, 31, 1, SOLO_DEFAULT_QP);\r\nv4l2_ctrl_new_std_menu(hdl, &solo_ctrl_ops,\r\nV4L2_CID_DETECT_MD_MODE,\r\nV4L2_DETECT_MD_MODE_THRESHOLD_GRID, 0,\r\nV4L2_DETECT_MD_MODE_DISABLED);\r\nv4l2_ctrl_new_std(hdl, &solo_ctrl_ops,\r\nV4L2_CID_DETECT_MD_GLOBAL_THRESHOLD, 0, 0xff, 1,\r\nSOLO_DEF_MOT_THRESH >> 8);\r\nv4l2_ctrl_new_custom(hdl, &solo_osd_text_ctrl, NULL);\r\nsolo_enc->md_thresholds =\r\nv4l2_ctrl_new_custom(hdl, &solo_md_thresholds, NULL);\r\nif (hdl->error) {\r\nret = hdl->error;\r\ngoto hdl_free;\r\n}\r\nsolo_enc->solo_dev = solo_dev;\r\nsolo_enc->ch = ch;\r\nmutex_init(&solo_enc->lock);\r\nspin_lock_init(&solo_enc->av_lock);\r\nINIT_LIST_HEAD(&solo_enc->vidq_active);\r\nsolo_enc->fmt = (solo_dev->type == SOLO_DEV_6010) ?\r\nV4L2_PIX_FMT_MPEG4 : V4L2_PIX_FMT_H264;\r\nsolo_enc->type = SOLO_ENC_TYPE_STD;\r\nsolo_enc->qp = SOLO_DEFAULT_QP;\r\nsolo_enc->gop = solo_dev->fps;\r\nsolo_enc->interval = 1;\r\nsolo_enc->mode = SOLO_ENC_MODE_CIF;\r\nsolo_enc->motion_global = true;\r\nsolo_enc->motion_thresh = SOLO_DEF_MOT_THRESH;\r\nsolo_enc->vidq.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nsolo_enc->vidq.io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ;\r\nsolo_enc->vidq.ops = &solo_enc_video_qops;\r\nsolo_enc->vidq.mem_ops = &vb2_dma_sg_memops;\r\nsolo_enc->vidq.drv_priv = solo_enc;\r\nsolo_enc->vidq.gfp_flags = __GFP_DMA32;\r\nsolo_enc->vidq.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nsolo_enc->vidq.buf_struct_size = sizeof(struct solo_vb2_buf);\r\nsolo_enc->vidq.lock = &solo_enc->lock;\r\nret = vb2_queue_init(&solo_enc->vidq);\r\nif (ret)\r\ngoto hdl_free;\r\nsolo_update_mode(solo_enc);\r\nspin_lock_init(&solo_enc->motion_lock);\r\nsolo_enc->jpeg_len = sizeof(jpeg_header);\r\nmemcpy(solo_enc->jpeg_header, jpeg_header, solo_enc->jpeg_len);\r\nsolo_enc->desc_nelts = 32;\r\nsolo_enc->desc_items = pci_alloc_consistent(solo_dev->pdev,\r\nsizeof(struct solo_p2m_desc) *\r\nsolo_enc->desc_nelts,\r\n&solo_enc->desc_dma);\r\nret = -ENOMEM;\r\nif (solo_enc->desc_items == NULL)\r\ngoto hdl_free;\r\nsolo_enc->vfd = video_device_alloc();\r\nif (!solo_enc->vfd)\r\ngoto pci_free;\r\n*solo_enc->vfd = solo_enc_template;\r\nsolo_enc->vfd->v4l2_dev = &solo_dev->v4l2_dev;\r\nsolo_enc->vfd->ctrl_handler = hdl;\r\nsolo_enc->vfd->queue = &solo_enc->vidq;\r\nsolo_enc->vfd->lock = &solo_enc->lock;\r\nvideo_set_drvdata(solo_enc->vfd, solo_enc);\r\nret = video_register_device(solo_enc->vfd, VFL_TYPE_GRABBER, nr);\r\nif (ret < 0)\r\ngoto vdev_release;\r\nsnprintf(solo_enc->vfd->name, sizeof(solo_enc->vfd->name),\r\n"%s-enc (%i/%i)", SOLO6X10_NAME, solo_dev->vfd->num,\r\nsolo_enc->vfd->num);\r\nreturn solo_enc;\r\nvdev_release:\r\nvideo_device_release(solo_enc->vfd);\r\npci_free:\r\npci_free_consistent(solo_enc->solo_dev->pdev,\r\nsizeof(struct solo_p2m_desc) * solo_enc->desc_nelts,\r\nsolo_enc->desc_items, solo_enc->desc_dma);\r\nhdl_free:\r\nv4l2_ctrl_handler_free(hdl);\r\nvb2_dma_sg_cleanup_ctx(solo_enc->alloc_ctx);\r\nkfree(solo_enc);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic void solo_enc_free(struct solo_enc_dev *solo_enc)\r\n{\r\nif (solo_enc == NULL)\r\nreturn;\r\npci_free_consistent(solo_enc->solo_dev->pdev,\r\nsizeof(struct solo_p2m_desc) * solo_enc->desc_nelts,\r\nsolo_enc->desc_items, solo_enc->desc_dma);\r\nvideo_unregister_device(solo_enc->vfd);\r\nv4l2_ctrl_handler_free(&solo_enc->hdl);\r\nvb2_dma_sg_cleanup_ctx(solo_enc->alloc_ctx);\r\nkfree(solo_enc);\r\n}\r\nint solo_enc_v4l2_init(struct solo_dev *solo_dev, unsigned nr)\r\n{\r\nint i;\r\ninit_waitqueue_head(&solo_dev->ring_thread_wait);\r\nsolo_dev->vh_size = sizeof(vop_header);\r\nsolo_dev->vh_buf = pci_alloc_consistent(solo_dev->pdev,\r\nsolo_dev->vh_size,\r\n&solo_dev->vh_dma);\r\nif (solo_dev->vh_buf == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < solo_dev->nr_chans; i++) {\r\nsolo_dev->v4l2_enc[i] = solo_enc_alloc(solo_dev, i, nr);\r\nif (IS_ERR(solo_dev->v4l2_enc[i]))\r\nbreak;\r\n}\r\nif (i != solo_dev->nr_chans) {\r\nint ret = PTR_ERR(solo_dev->v4l2_enc[i]);\r\nwhile (i--)\r\nsolo_enc_free(solo_dev->v4l2_enc[i]);\r\npci_free_consistent(solo_dev->pdev, solo_dev->vh_size,\r\nsolo_dev->vh_buf, solo_dev->vh_dma);\r\nsolo_dev->vh_buf = NULL;\r\nreturn ret;\r\n}\r\nif (solo_dev->type == SOLO_DEV_6010)\r\nsolo_dev->enc_bw_remain = solo_dev->fps * 4 * 4;\r\nelse\r\nsolo_dev->enc_bw_remain = solo_dev->fps * 4 * 5;\r\ndev_info(&solo_dev->pdev->dev, "Encoders as /dev/video%d-%d\n",\r\nsolo_dev->v4l2_enc[0]->vfd->num,\r\nsolo_dev->v4l2_enc[solo_dev->nr_chans - 1]->vfd->num);\r\nreturn solo_ring_start(solo_dev);\r\n}\r\nvoid solo_enc_v4l2_exit(struct solo_dev *solo_dev)\r\n{\r\nint i;\r\nsolo_ring_stop(solo_dev);\r\nfor (i = 0; i < solo_dev->nr_chans; i++)\r\nsolo_enc_free(solo_dev->v4l2_enc[i]);\r\nif (solo_dev->vh_buf)\r\npci_free_consistent(solo_dev->pdev, solo_dev->vh_size,\r\nsolo_dev->vh_buf, solo_dev->vh_dma);\r\n}
