static void set_audio_registers(struct cx88_core *core, const struct rlist *l)\r\n{\r\nint i;\r\nfor (i = 0; l[i].reg; i++) {\r\nswitch (l[i].reg) {\r\ncase AUD_PDF_DDS_CNST_BYTE2:\r\ncase AUD_PDF_DDS_CNST_BYTE1:\r\ncase AUD_PDF_DDS_CNST_BYTE0:\r\ncase AUD_QAM_MODE:\r\ncase AUD_PHACC_FREQ_8MSB:\r\ncase AUD_PHACC_FREQ_8LSB:\r\ncx_writeb(l[i].reg, l[i].val);\r\nbreak;\r\ndefault:\r\ncx_write(l[i].reg, l[i].val);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void set_audio_start(struct cx88_core *core, u32 mode)\r\n{\r\ncx_write(AUD_VOL_CTL, (1 << 6));\r\ncx_write(AUD_INIT, mode);\r\ncx_write(AUD_INIT_LD, 0x0001);\r\ncx_write(AUD_SOFT_RESET, 0x0001);\r\n}\r\nstatic void set_audio_finish(struct cx88_core *core, u32 ctl)\r\n{\r\nu32 volume;\r\ncx88_stop_audio_dma(core);\r\ncx_write(AUD_RATE_THRES_DMD, 0x000000C0);\r\ncx88_start_audio_dma(core);\r\nif (core->board.mpeg & CX88_MPEG_BLACKBIRD) {\r\ncx_write(AUD_I2SINPUTCNTL, 4);\r\ncx_write(AUD_BAUDRATE, 1);\r\ncx_set(AUD_CTL, EN_I2SOUT_ENABLE);\r\ncx_write(AUD_I2SOUTPUTCNTL, 1);\r\ncx_write(AUD_I2SCNTL, 0);\r\n}\r\nif ((always_analog) || (!(core->board.mpeg & CX88_MPEG_BLACKBIRD))) {\r\nctl |= EN_DAC_ENABLE;\r\ncx_write(AUD_CTL, ctl);\r\n}\r\ncx_write(AUD_SOFT_RESET, 0x0000);\r\nvolume = cx_sread(SHADOW_AUD_VOL_CTL);\r\ncx_swrite(SHADOW_AUD_VOL_CTL, AUD_VOL_CTL, volume);\r\ncore->last_change = jiffies;\r\n}\r\nstatic void set_audio_standard_BTSC(struct cx88_core *core, unsigned int sap,\r\nu32 mode)\r\n{\r\nstatic const struct rlist btsc[] = {\r\n{AUD_AFE_12DB_EN, 0x00000001},\r\n{AUD_OUT1_SEL, 0x00000013},\r\n{AUD_OUT1_SHIFT, 0x00000000},\r\n{AUD_POLY0_DDS_CONSTANT, 0x0012010c},\r\n{AUD_DMD_RA_DDS, 0x00c3e7aa},\r\n{AUD_DBX_IN_GAIN, 0x00004734},\r\n{AUD_DBX_WBE_GAIN, 0x00004640},\r\n{AUD_DBX_SE_GAIN, 0x00008d31},\r\n{AUD_DCOC_0_SRC, 0x0000001a},\r\n{AUD_IIR1_4_SEL, 0x00000021},\r\n{AUD_DCOC_PASS_IN, 0x00000003},\r\n{AUD_DCOC_0_SHIFT_IN0, 0x0000000a},\r\n{AUD_DCOC_0_SHIFT_IN1, 0x00000008},\r\n{AUD_DCOC_1_SHIFT_IN0, 0x0000000a},\r\n{AUD_DCOC_1_SHIFT_IN1, 0x00000008},\r\n{AUD_DN0_FREQ, 0x0000283b},\r\n{AUD_DN2_SRC_SEL, 0x00000008},\r\n{AUD_DN2_FREQ, 0x00003000},\r\n{AUD_DN2_AFC, 0x00000002},\r\n{AUD_DN2_SHFT, 0x00000000},\r\n{AUD_IIR2_2_SEL, 0x00000020},\r\n{AUD_IIR2_2_SHIFT, 0x00000000},\r\n{AUD_IIR2_3_SEL, 0x0000001f},\r\n{AUD_IIR2_3_SHIFT, 0x00000000},\r\n{AUD_CRDC1_SRC_SEL, 0x000003ce},\r\n{AUD_CRDC1_SHIFT, 0x00000000},\r\n{AUD_CORDIC_SHIFT_1, 0x00000007},\r\n{AUD_DCOC_1_SRC, 0x0000001b},\r\n{AUD_DCOC1_SHIFT, 0x00000000},\r\n{AUD_RDSI_SEL, 0x00000008},\r\n{AUD_RDSQ_SEL, 0x00000008},\r\n{AUD_RDSI_SHIFT, 0x00000000},\r\n{AUD_RDSQ_SHIFT, 0x00000000},\r\n{AUD_POLYPH80SCALEFAC, 0x00000003},\r\n{ },\r\n};\r\nstatic const struct rlist btsc_sap[] = {\r\n{AUD_AFE_12DB_EN, 0x00000001},\r\n{AUD_DBX_IN_GAIN, 0x00007200},\r\n{AUD_DBX_WBE_GAIN, 0x00006200},\r\n{AUD_DBX_SE_GAIN, 0x00006200},\r\n{AUD_IIR1_1_SEL, 0x00000000},\r\n{AUD_IIR1_3_SEL, 0x00000001},\r\n{AUD_DN1_SRC_SEL, 0x00000007},\r\n{AUD_IIR1_4_SHIFT, 0x00000006},\r\n{AUD_IIR2_1_SHIFT, 0x00000000},\r\n{AUD_IIR2_2_SHIFT, 0x00000000},\r\n{AUD_IIR3_0_SHIFT, 0x00000000},\r\n{AUD_IIR3_1_SHIFT, 0x00000000},\r\n{AUD_IIR3_0_SEL, 0x0000000d},\r\n{AUD_IIR3_1_SEL, 0x0000000e},\r\n{AUD_DEEMPH1_SRC_SEL, 0x00000014},\r\n{AUD_DEEMPH1_SHIFT, 0x00000000},\r\n{AUD_DEEMPH1_G0, 0x00004000},\r\n{AUD_DEEMPH1_A0, 0x00000000},\r\n{AUD_DEEMPH1_B0, 0x00000000},\r\n{AUD_DEEMPH1_A1, 0x00000000},\r\n{AUD_DEEMPH1_B1, 0x00000000},\r\n{AUD_OUT0_SEL, 0x0000003f},\r\n{AUD_OUT1_SEL, 0x0000003f},\r\n{AUD_DN1_AFC, 0x00000002},\r\n{AUD_DCOC_0_SHIFT_IN0, 0x0000000a},\r\n{AUD_DCOC_0_SHIFT_IN1, 0x00000008},\r\n{AUD_DCOC_1_SHIFT_IN0, 0x0000000a},\r\n{AUD_DCOC_1_SHIFT_IN1, 0x00000008},\r\n{AUD_IIR1_0_SEL, 0x0000001d},\r\n{AUD_IIR1_2_SEL, 0x0000001e},\r\n{AUD_IIR2_1_SEL, 0x00000002},\r\n{AUD_IIR2_2_SEL, 0x00000004},\r\n{AUD_IIR3_2_SEL, 0x0000000f},\r\n{AUD_DCOC2_SHIFT, 0x00000001},\r\n{AUD_IIR3_2_SHIFT, 0x00000001},\r\n{AUD_DEEMPH0_SRC_SEL, 0x00000014},\r\n{AUD_CORDIC_SHIFT_1, 0x00000006},\r\n{AUD_POLY0_DDS_CONSTANT, 0x000e4db2},\r\n{AUD_DMD_RA_DDS, 0x00f696e6},\r\n{AUD_IIR2_3_SEL, 0x00000025},\r\n{AUD_IIR1_4_SEL, 0x00000021},\r\n{AUD_DN1_FREQ, 0x0000c965},\r\n{AUD_DCOC_PASS_IN, 0x00000003},\r\n{AUD_DCOC_0_SRC, 0x0000001a},\r\n{AUD_DCOC_1_SRC, 0x0000001b},\r\n{AUD_DCOC1_SHIFT, 0x00000000},\r\n{AUD_RDSI_SEL, 0x00000009},\r\n{AUD_RDSQ_SEL, 0x00000009},\r\n{AUD_RDSI_SHIFT, 0x00000000},\r\n{AUD_RDSQ_SHIFT, 0x00000000},\r\n{AUD_POLYPH80SCALEFAC, 0x00000003},\r\n{ },\r\n};\r\nmode |= EN_FMRADIO_EN_RDS;\r\nif (sap) {\r\ndprintk("%s SAP (status: unknown)\n", __func__);\r\nset_audio_start(core, SEL_SAP);\r\nset_audio_registers(core, btsc_sap);\r\nset_audio_finish(core, mode);\r\n} else {\r\ndprintk("%s (status: known-good)\n", __func__);\r\nset_audio_start(core, SEL_BTSC);\r\nset_audio_registers(core, btsc);\r\nset_audio_finish(core, mode);\r\n}\r\n}\r\nstatic void set_audio_standard_NICAM(struct cx88_core *core, u32 mode)\r\n{\r\nstatic const struct rlist nicam_l[] = {\r\n{AUD_AFE_12DB_EN, 0x00000001},\r\n{AUD_RATE_ADJ1, 0x00000060},\r\n{AUD_RATE_ADJ2, 0x000000F9},\r\n{AUD_RATE_ADJ3, 0x000001CC},\r\n{AUD_RATE_ADJ4, 0x000002B3},\r\n{AUD_RATE_ADJ5, 0x00000726},\r\n{AUD_DEEMPHDENOM1_R, 0x0000F3D0},\r\n{AUD_DEEMPHDENOM2_R, 0x00000000},\r\n{AUD_ERRLOGPERIOD_R, 0x00000064},\r\n{AUD_ERRINTRPTTHSHLD1_R, 0x00000FFF},\r\n{AUD_ERRINTRPTTHSHLD2_R, 0x0000001F},\r\n{AUD_ERRINTRPTTHSHLD3_R, 0x0000000F},\r\n{AUD_POLYPH80SCALEFAC, 0x00000003},\r\n{AUD_DMD_RA_DDS, 0x00C00000},\r\n{AUD_PLL_INT, 0x0000001E},\r\n{AUD_PLL_DDS, 0x00000000},\r\n{AUD_PLL_FRAC, 0x0000E542},\r\n{AUD_START_TIMER, 0x00000000},\r\n{AUD_DEEMPHNUMER1_R, 0x000353DE},\r\n{AUD_DEEMPHNUMER2_R, 0x000001B1},\r\n{AUD_PDF_DDS_CNST_BYTE2, 0x06},\r\n{AUD_PDF_DDS_CNST_BYTE1, 0x82},\r\n{AUD_PDF_DDS_CNST_BYTE0, 0x12},\r\n{AUD_QAM_MODE, 0x05},\r\n{AUD_PHACC_FREQ_8MSB, 0x34},\r\n{AUD_PHACC_FREQ_8LSB, 0x4C},\r\n{AUD_DEEMPHGAIN_R, 0x00006680},\r\n{AUD_RATE_THRES_DMD, 0x000000C0},\r\n{ },\r\n};\r\nstatic const struct rlist nicam_bgdki_common[] = {\r\n{AUD_AFE_12DB_EN, 0x00000001},\r\n{AUD_RATE_ADJ1, 0x00000010},\r\n{AUD_RATE_ADJ2, 0x00000040},\r\n{AUD_RATE_ADJ3, 0x00000100},\r\n{AUD_RATE_ADJ4, 0x00000400},\r\n{AUD_RATE_ADJ5, 0x00001000},\r\n{AUD_ERRLOGPERIOD_R, 0x00000fff},\r\n{AUD_ERRINTRPTTHSHLD1_R, 0x000003ff},\r\n{AUD_ERRINTRPTTHSHLD2_R, 0x000000ff},\r\n{AUD_ERRINTRPTTHSHLD3_R, 0x0000003f},\r\n{AUD_POLYPH80SCALEFAC, 0x00000003},\r\n{AUD_DEEMPHGAIN_R, 0x000023c2},\r\n{AUD_DEEMPHNUMER1_R, 0x0002a7bc},\r\n{AUD_DEEMPHNUMER2_R, 0x0003023e},\r\n{AUD_DEEMPHDENOM1_R, 0x0000f3d0},\r\n{AUD_DEEMPHDENOM2_R, 0x00000000},\r\n{AUD_PDF_DDS_CNST_BYTE2, 0x06},\r\n{AUD_PDF_DDS_CNST_BYTE1, 0x82},\r\n{AUD_QAM_MODE, 0x05},\r\n{ },\r\n};\r\nstatic const struct rlist nicam_i[] = {\r\n{AUD_PDF_DDS_CNST_BYTE0, 0x12},\r\n{AUD_PHACC_FREQ_8MSB, 0x3a},\r\n{AUD_PHACC_FREQ_8LSB, 0x93},\r\n{ },\r\n};\r\nstatic const struct rlist nicam_default[] = {\r\n{AUD_PDF_DDS_CNST_BYTE0, 0x16},\r\n{AUD_PHACC_FREQ_8MSB, 0x34},\r\n{AUD_PHACC_FREQ_8LSB, 0x4c},\r\n{ },\r\n};\r\nset_audio_start(core,SEL_NICAM);\r\nswitch (core->tvaudio) {\r\ncase WW_L:\r\ndprintk("%s SECAM-L NICAM (status: devel)\n", __func__);\r\nset_audio_registers(core, nicam_l);\r\nbreak;\r\ncase WW_I:\r\ndprintk("%s PAL-I NICAM (status: known-good)\n", __func__);\r\nset_audio_registers(core, nicam_bgdki_common);\r\nset_audio_registers(core, nicam_i);\r\nbreak;\r\ncase WW_NONE:\r\ncase WW_BTSC:\r\ncase WW_BG:\r\ncase WW_DK:\r\ncase WW_EIAJ:\r\ncase WW_I2SPT:\r\ncase WW_FM:\r\ncase WW_I2SADC:\r\ncase WW_M:\r\ndprintk("%s PAL-BGDK NICAM (status: known-good)\n", __func__);\r\nset_audio_registers(core, nicam_bgdki_common);\r\nset_audio_registers(core, nicam_default);\r\nbreak;\r\n}\r\nmode |= EN_DMTRX_LR | EN_DMTRX_BYPASS;\r\nset_audio_finish(core, mode);\r\n}\r\nstatic void set_audio_standard_A2(struct cx88_core *core, u32 mode)\r\n{\r\nstatic const struct rlist a2_bgdk_common[] = {\r\n{AUD_ERRLOGPERIOD_R, 0x00000064},\r\n{AUD_ERRINTRPTTHSHLD1_R, 0x00000fff},\r\n{AUD_ERRINTRPTTHSHLD2_R, 0x0000001f},\r\n{AUD_ERRINTRPTTHSHLD3_R, 0x0000000f},\r\n{AUD_PDF_DDS_CNST_BYTE2, 0x06},\r\n{AUD_PDF_DDS_CNST_BYTE1, 0x82},\r\n{AUD_PDF_DDS_CNST_BYTE0, 0x12},\r\n{AUD_QAM_MODE, 0x05},\r\n{AUD_PHACC_FREQ_8MSB, 0x34},\r\n{AUD_PHACC_FREQ_8LSB, 0x4c},\r\n{AUD_RATE_ADJ1, 0x00000100},\r\n{AUD_RATE_ADJ2, 0x00000200},\r\n{AUD_RATE_ADJ3, 0x00000300},\r\n{AUD_RATE_ADJ4, 0x00000400},\r\n{AUD_RATE_ADJ5, 0x00000500},\r\n{AUD_THR_FR, 0x00000000},\r\n{AAGC_HYST, 0x0000001a},\r\n{AUD_PILOT_BQD_1_K0, 0x0000755b},\r\n{AUD_PILOT_BQD_1_K1, 0x00551340},\r\n{AUD_PILOT_BQD_1_K2, 0x006d30be},\r\n{AUD_PILOT_BQD_1_K3, 0xffd394af},\r\n{AUD_PILOT_BQD_1_K4, 0x00400000},\r\n{AUD_PILOT_BQD_2_K0, 0x00040000},\r\n{AUD_PILOT_BQD_2_K1, 0x002a4841},\r\n{AUD_PILOT_BQD_2_K2, 0x00400000},\r\n{AUD_PILOT_BQD_2_K3, 0x00000000},\r\n{AUD_PILOT_BQD_2_K4, 0x00000000},\r\n{AUD_MODE_CHG_TIMER, 0x00000040},\r\n{AUD_AFE_12DB_EN, 0x00000001},\r\n{AUD_CORDIC_SHIFT_0, 0x00000007},\r\n{AUD_CORDIC_SHIFT_1, 0x00000007},\r\n{AUD_DEEMPH0_G0, 0x00000380},\r\n{AUD_DEEMPH1_G0, 0x00000380},\r\n{AUD_DCOC_0_SRC, 0x0000001a},\r\n{AUD_DCOC0_SHIFT, 0x00000000},\r\n{AUD_DCOC_0_SHIFT_IN0, 0x0000000a},\r\n{AUD_DCOC_0_SHIFT_IN1, 0x00000008},\r\n{AUD_DCOC_PASS_IN, 0x00000003},\r\n{AUD_IIR3_0_SEL, 0x00000021},\r\n{AUD_DN2_AFC, 0x00000002},\r\n{AUD_DCOC_1_SRC, 0x0000001b},\r\n{AUD_DCOC1_SHIFT, 0x00000000},\r\n{AUD_DCOC_1_SHIFT_IN0, 0x0000000a},\r\n{AUD_DCOC_1_SHIFT_IN1, 0x00000008},\r\n{AUD_IIR3_1_SEL, 0x00000023},\r\n{AUD_RDSI_SEL, 0x00000017},\r\n{AUD_RDSI_SHIFT, 0x00000000},\r\n{AUD_RDSQ_SEL, 0x00000017},\r\n{AUD_RDSQ_SHIFT, 0x00000000},\r\n{AUD_PLL_INT, 0x0000001e},\r\n{AUD_PLL_DDS, 0x00000000},\r\n{AUD_PLL_FRAC, 0x0000e542},\r\n{AUD_POLYPH80SCALEFAC, 0x00000001},\r\n{AUD_START_TIMER, 0x00000000},\r\n{ },\r\n};\r\nstatic const struct rlist a2_bg[] = {\r\n{AUD_DMD_RA_DDS, 0x002a4f2f},\r\n{AUD_C1_UP_THR, 0x00007000},\r\n{AUD_C1_LO_THR, 0x00005400},\r\n{AUD_C2_UP_THR, 0x00005400},\r\n{AUD_C2_LO_THR, 0x00003000},\r\n{ },\r\n};\r\nstatic const struct rlist a2_dk[] = {\r\n{AUD_DMD_RA_DDS, 0x002a4f2f},\r\n{AUD_C1_UP_THR, 0x00007000},\r\n{AUD_C1_LO_THR, 0x00005400},\r\n{AUD_C2_UP_THR, 0x00005400},\r\n{AUD_C2_LO_THR, 0x00003000},\r\n{AUD_DN0_FREQ, 0x00003a1c},\r\n{AUD_DN2_FREQ, 0x0000d2e0},\r\n{ },\r\n};\r\nstatic const struct rlist a1_i[] = {\r\n{AUD_ERRLOGPERIOD_R, 0x00000064},\r\n{AUD_ERRINTRPTTHSHLD1_R, 0x00000fff},\r\n{AUD_ERRINTRPTTHSHLD2_R, 0x0000001f},\r\n{AUD_ERRINTRPTTHSHLD3_R, 0x0000000f},\r\n{AUD_PDF_DDS_CNST_BYTE2, 0x06},\r\n{AUD_PDF_DDS_CNST_BYTE1, 0x82},\r\n{AUD_PDF_DDS_CNST_BYTE0, 0x12},\r\n{AUD_QAM_MODE, 0x05},\r\n{AUD_PHACC_FREQ_8MSB, 0x3a},\r\n{AUD_PHACC_FREQ_8LSB, 0x93},\r\n{AUD_DMD_RA_DDS, 0x002a4f2f},\r\n{AUD_PLL_INT, 0x0000001e},\r\n{AUD_PLL_DDS, 0x00000004},\r\n{AUD_PLL_FRAC, 0x0000e542},\r\n{AUD_RATE_ADJ1, 0x00000100},\r\n{AUD_RATE_ADJ2, 0x00000200},\r\n{AUD_RATE_ADJ3, 0x00000300},\r\n{AUD_RATE_ADJ4, 0x00000400},\r\n{AUD_RATE_ADJ5, 0x00000500},\r\n{AUD_THR_FR, 0x00000000},\r\n{AUD_PILOT_BQD_1_K0, 0x0000755b},\r\n{AUD_PILOT_BQD_1_K1, 0x00551340},\r\n{AUD_PILOT_BQD_1_K2, 0x006d30be},\r\n{AUD_PILOT_BQD_1_K3, 0xffd394af},\r\n{AUD_PILOT_BQD_1_K4, 0x00400000},\r\n{AUD_PILOT_BQD_2_K0, 0x00040000},\r\n{AUD_PILOT_BQD_2_K1, 0x002a4841},\r\n{AUD_PILOT_BQD_2_K2, 0x00400000},\r\n{AUD_PILOT_BQD_2_K3, 0x00000000},\r\n{AUD_PILOT_BQD_2_K4, 0x00000000},\r\n{AUD_MODE_CHG_TIMER, 0x00000060},\r\n{AUD_AFE_12DB_EN, 0x00000001},\r\n{AAGC_HYST, 0x0000000a},\r\n{AUD_CORDIC_SHIFT_0, 0x00000007},\r\n{AUD_CORDIC_SHIFT_1, 0x00000007},\r\n{AUD_C1_UP_THR, 0x00007000},\r\n{AUD_C1_LO_THR, 0x00005400},\r\n{AUD_C2_UP_THR, 0x00005400},\r\n{AUD_C2_LO_THR, 0x00003000},\r\n{AUD_DCOC_0_SRC, 0x0000001a},\r\n{AUD_DCOC0_SHIFT, 0x00000000},\r\n{AUD_DCOC_0_SHIFT_IN0, 0x0000000a},\r\n{AUD_DCOC_0_SHIFT_IN1, 0x00000008},\r\n{AUD_DCOC_PASS_IN, 0x00000003},\r\n{AUD_IIR3_0_SEL, 0x00000021},\r\n{AUD_DN2_AFC, 0x00000002},\r\n{AUD_DCOC_1_SRC, 0x0000001b},\r\n{AUD_DCOC1_SHIFT, 0x00000000},\r\n{AUD_DCOC_1_SHIFT_IN0, 0x0000000a},\r\n{AUD_DCOC_1_SHIFT_IN1, 0x00000008},\r\n{AUD_IIR3_1_SEL, 0x00000023},\r\n{AUD_DN0_FREQ, 0x000035a3},\r\n{AUD_DN2_FREQ, 0x000029c7},\r\n{AUD_CRDC0_SRC_SEL, 0x00000511},\r\n{AUD_IIR1_0_SEL, 0x00000001},\r\n{AUD_IIR1_1_SEL, 0x00000000},\r\n{AUD_IIR3_2_SEL, 0x00000003},\r\n{AUD_IIR3_2_SHIFT, 0x00000000},\r\n{AUD_IIR3_0_SEL, 0x00000002},\r\n{AUD_IIR2_0_SEL, 0x00000021},\r\n{AUD_IIR2_0_SHIFT, 0x00000002},\r\n{AUD_DEEMPH0_SRC_SEL, 0x0000000b},\r\n{AUD_DEEMPH1_SRC_SEL, 0x0000000b},\r\n{AUD_POLYPH80SCALEFAC, 0x00000001},\r\n{AUD_START_TIMER, 0x00000000},\r\n{ },\r\n};\r\nstatic const struct rlist am_l[] = {\r\n{AUD_ERRLOGPERIOD_R, 0x00000064},\r\n{AUD_ERRINTRPTTHSHLD1_R, 0x00000FFF},\r\n{AUD_ERRINTRPTTHSHLD2_R, 0x0000001F},\r\n{AUD_ERRINTRPTTHSHLD3_R, 0x0000000F},\r\n{AUD_PDF_DDS_CNST_BYTE2, 0x48},\r\n{AUD_PDF_DDS_CNST_BYTE1, 0x3D},\r\n{AUD_QAM_MODE, 0x00},\r\n{AUD_PDF_DDS_CNST_BYTE0, 0xf5},\r\n{AUD_PHACC_FREQ_8MSB, 0x3a},\r\n{AUD_PHACC_FREQ_8LSB, 0x4a},\r\n{AUD_DEEMPHGAIN_R, 0x00006680},\r\n{AUD_DEEMPHNUMER1_R, 0x000353DE},\r\n{AUD_DEEMPHNUMER2_R, 0x000001B1},\r\n{AUD_DEEMPHDENOM1_R, 0x0000F3D0},\r\n{AUD_DEEMPHDENOM2_R, 0x00000000},\r\n{AUD_FM_MODE_ENABLE, 0x00000007},\r\n{AUD_POLYPH80SCALEFAC, 0x00000003},\r\n{AUD_AFE_12DB_EN, 0x00000001},\r\n{AAGC_GAIN, 0x00000000},\r\n{AAGC_HYST, 0x00000018},\r\n{AAGC_DEF, 0x00000020},\r\n{AUD_DN0_FREQ, 0x00000000},\r\n{AUD_POLY0_DDS_CONSTANT, 0x000E4DB2},\r\n{AUD_DCOC_0_SRC, 0x00000021},\r\n{AUD_IIR1_0_SEL, 0x00000000},\r\n{AUD_IIR1_0_SHIFT, 0x00000007},\r\n{AUD_IIR1_1_SEL, 0x00000002},\r\n{AUD_IIR1_1_SHIFT, 0x00000000},\r\n{AUD_DCOC_1_SRC, 0x00000003},\r\n{AUD_DCOC1_SHIFT, 0x00000000},\r\n{AUD_DCOC_PASS_IN, 0x00000000},\r\n{AUD_IIR1_2_SEL, 0x00000023},\r\n{AUD_IIR1_2_SHIFT, 0x00000000},\r\n{AUD_IIR1_3_SEL, 0x00000004},\r\n{AUD_IIR1_3_SHIFT, 0x00000007},\r\n{AUD_IIR1_4_SEL, 0x00000005},\r\n{AUD_IIR1_4_SHIFT, 0x00000007},\r\n{AUD_IIR3_0_SEL, 0x00000007},\r\n{AUD_IIR3_0_SHIFT, 0x00000000},\r\n{AUD_DEEMPH0_SRC_SEL, 0x00000011},\r\n{AUD_DEEMPH0_SHIFT, 0x00000000},\r\n{AUD_DEEMPH0_G0, 0x00007000},\r\n{AUD_DEEMPH0_A0, 0x00000000},\r\n{AUD_DEEMPH0_B0, 0x00000000},\r\n{AUD_DEEMPH0_A1, 0x00000000},\r\n{AUD_DEEMPH0_B1, 0x00000000},\r\n{AUD_DEEMPH1_SRC_SEL, 0x00000011},\r\n{AUD_DEEMPH1_SHIFT, 0x00000000},\r\n{AUD_DEEMPH1_G0, 0x00007000},\r\n{AUD_DEEMPH1_A0, 0x00000000},\r\n{AUD_DEEMPH1_B0, 0x00000000},\r\n{AUD_DEEMPH1_A1, 0x00000000},\r\n{AUD_DEEMPH1_B1, 0x00000000},\r\n{AUD_OUT0_SEL, 0x0000003F},\r\n{AUD_OUT1_SEL, 0x0000003F},\r\n{AUD_DMD_RA_DDS, 0x00F5C285},\r\n{AUD_PLL_INT, 0x0000001E},\r\n{AUD_PLL_DDS, 0x00000000},\r\n{AUD_PLL_FRAC, 0x0000E542},\r\n{AUD_RATE_ADJ1, 0x00000100},\r\n{AUD_RATE_ADJ2, 0x00000200},\r\n{AUD_RATE_ADJ3, 0x00000300},\r\n{AUD_RATE_ADJ4, 0x00000400},\r\n{AUD_RATE_ADJ5, 0x00000500},\r\n{AUD_RATE_THRES_DMD, 0x000000C0},\r\n{ },\r\n};\r\nstatic const struct rlist a2_deemph50[] = {\r\n{AUD_DEEMPH0_G0, 0x00000380},\r\n{AUD_DEEMPH1_G0, 0x00000380},\r\n{AUD_DEEMPHGAIN_R, 0x000011e1},\r\n{AUD_DEEMPHNUMER1_R, 0x0002a7bc},\r\n{AUD_DEEMPHNUMER2_R, 0x0003023c},\r\n{ },\r\n};\r\nset_audio_start(core, SEL_A2);\r\nswitch (core->tvaudio) {\r\ncase WW_BG:\r\ndprintk("%s PAL-BG A1/2 (status: known-good)\n", __func__);\r\nset_audio_registers(core, a2_bgdk_common);\r\nset_audio_registers(core, a2_bg);\r\nset_audio_registers(core, a2_deemph50);\r\nbreak;\r\ncase WW_DK:\r\ndprintk("%s PAL-DK A1/2 (status: known-good)\n", __func__);\r\nset_audio_registers(core, a2_bgdk_common);\r\nset_audio_registers(core, a2_dk);\r\nset_audio_registers(core, a2_deemph50);\r\nbreak;\r\ncase WW_I:\r\ndprintk("%s PAL-I A1 (status: known-good)\n", __func__);\r\nset_audio_registers(core, a1_i);\r\nset_audio_registers(core, a2_deemph50);\r\nbreak;\r\ncase WW_L:\r\ndprintk("%s AM-L (status: devel)\n", __func__);\r\nset_audio_registers(core, am_l);\r\nbreak;\r\ncase WW_NONE:\r\ncase WW_BTSC:\r\ncase WW_EIAJ:\r\ncase WW_I2SPT:\r\ncase WW_FM:\r\ncase WW_I2SADC:\r\ncase WW_M:\r\ndprintk("%s Warning: wrong value\n", __func__);\r\nreturn;\r\nbreak;\r\n}\r\nmode |= EN_FMRADIO_EN_RDS | EN_DMTRX_SUMDIFF;\r\nset_audio_finish(core, mode);\r\n}\r\nstatic void set_audio_standard_EIAJ(struct cx88_core *core)\r\n{\r\nstatic const struct rlist eiaj[] = {\r\n{ },\r\n};\r\ndprintk("%s (status: unknown)\n", __func__);\r\nset_audio_start(core, SEL_EIAJ);\r\nset_audio_registers(core, eiaj);\r\nset_audio_finish(core, EN_EIAJ_AUTO_STEREO);\r\n}\r\nstatic void set_audio_standard_FM(struct cx88_core *core,\r\nenum cx88_deemph_type deemph)\r\n{\r\nstatic const struct rlist fm_deemph_50[] = {\r\n{AUD_DEEMPH0_G0, 0x0C45},\r\n{AUD_DEEMPH0_A0, 0x6262},\r\n{AUD_DEEMPH0_B0, 0x1C29},\r\n{AUD_DEEMPH0_A1, 0x3FC66},\r\n{AUD_DEEMPH0_B1, 0x399A},\r\n{AUD_DEEMPH1_G0, 0x0D80},\r\n{AUD_DEEMPH1_A0, 0x6262},\r\n{AUD_DEEMPH1_B0, 0x1C29},\r\n{AUD_DEEMPH1_A1, 0x3FC66},\r\n{AUD_DEEMPH1_B1, 0x399A},\r\n{AUD_POLYPH80SCALEFAC, 0x0003},\r\n{ },\r\n};\r\nstatic const struct rlist fm_deemph_75[] = {\r\n{AUD_DEEMPH0_G0, 0x091B},\r\n{AUD_DEEMPH0_A0, 0x6B68},\r\n{AUD_DEEMPH0_B0, 0x11EC},\r\n{AUD_DEEMPH0_A1, 0x3FC66},\r\n{AUD_DEEMPH0_B1, 0x399A},\r\n{AUD_DEEMPH1_G0, 0x0AA0},\r\n{AUD_DEEMPH1_A0, 0x6B68},\r\n{AUD_DEEMPH1_B0, 0x11EC},\r\n{AUD_DEEMPH1_A1, 0x3FC66},\r\n{AUD_DEEMPH1_B1, 0x399A},\r\n{AUD_POLYPH80SCALEFAC, 0x0003},\r\n{ },\r\n};\r\nstatic const struct rlist fm_no_deemph[] = {\r\n{AUD_POLYPH80SCALEFAC, 0x0003},\r\n{ },\r\n};\r\ndprintk("%s (status: unknown)\n", __func__);\r\nset_audio_start(core, SEL_FMRADIO);\r\nswitch (deemph) {\r\ndefault:\r\ncase FM_NO_DEEMPH:\r\nset_audio_registers(core, fm_no_deemph);\r\nbreak;\r\ncase FM_DEEMPH_50:\r\nset_audio_registers(core, fm_deemph_50);\r\nbreak;\r\ncase FM_DEEMPH_75:\r\nset_audio_registers(core, fm_deemph_75);\r\nbreak;\r\n}\r\nset_audio_finish(core, EN_FMRADIO_AUTO_STEREO);\r\n}\r\nstatic int cx88_detect_nicam(struct cx88_core *core)\r\n{\r\nint i, j = 0;\r\ndprintk("start nicam autodetect.\n");\r\nfor (i = 0; i < 6; i++) {\r\nj += ((cx_read(AUD_NICAM_STATUS2) & 0x02) >> 1);\r\nif (j == 1) {\r\ndprintk("nicam is detected.\n");\r\nreturn 1;\r\n}\r\nmsleep(10);\r\n}\r\ndprintk("nicam is not detected.\n");\r\nreturn 0;\r\n}\r\nvoid cx88_set_tvaudio(struct cx88_core *core)\r\n{\r\nswitch (core->tvaudio) {\r\ncase WW_BTSC:\r\nset_audio_standard_BTSC(core, 0, EN_BTSC_AUTO_STEREO);\r\nbreak;\r\ncase WW_BG:\r\ncase WW_DK:\r\ncase WW_M:\r\ncase WW_I:\r\ncase WW_L:\r\nset_audio_standard_A2(core, EN_A2_FORCE_MONO1);\r\nset_audio_standard_NICAM(core, EN_NICAM_AUTO_STEREO);\r\nif (0 == cx88_detect_nicam(core)) {\r\nset_audio_standard_A2(core, EN_A2_FORCE_MONO1);\r\ncore->audiomode_current = V4L2_TUNER_MODE_MONO;\r\ncore->use_nicam = 0;\r\n} else {\r\ncore->use_nicam = 1;\r\n}\r\nbreak;\r\ncase WW_EIAJ:\r\nset_audio_standard_EIAJ(core);\r\nbreak;\r\ncase WW_FM:\r\nset_audio_standard_FM(core, radio_deemphasis);\r\nbreak;\r\ncase WW_I2SADC:\r\nset_audio_start(core, 0x01);\r\ncx_write(AUD_I2SINPUTCNTL, core->board.i2sinputcntl);\r\ncx_write(AUD_I2SCNTL, 0x1);\r\nset_audio_finish(core, EN_I2SIN_ENABLE);\r\nbreak;\r\ncase WW_NONE:\r\ncase WW_I2SPT:\r\nprintk("%s/0: unknown tv audio mode [%d]\n",\r\ncore->name, core->tvaudio);\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nvoid cx88_newstation(struct cx88_core *core)\r\n{\r\ncore->audiomode_manual = UNSET;\r\ncore->last_change = jiffies;\r\n}\r\nvoid cx88_get_stereo(struct cx88_core *core, struct v4l2_tuner *t)\r\n{\r\nstatic const char * const m[] = { "stereo", "dual mono", "mono", "sap" };\r\nstatic const char * const p[] = { "no pilot", "pilot c1", "pilot c2", "?" };\r\nu32 reg, mode, pilot;\r\nreg = cx_read(AUD_STATUS);\r\nmode = reg & 0x03;\r\npilot = (reg >> 2) & 0x03;\r\nif (core->astat != reg)\r\ndprintk("AUD_STATUS: 0x%x [%s/%s] ctl=%s\n",\r\nreg, m[mode], p[pilot],\r\naud_ctl_names[cx_read(AUD_CTL) & 63]);\r\ncore->astat = reg;\r\nt->capability = V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_SAP |\r\nV4L2_TUNER_CAP_LANG1 | V4L2_TUNER_CAP_LANG2;\r\nt->rxsubchans = UNSET;\r\nt->audmode = V4L2_TUNER_MODE_MONO;\r\nswitch (mode) {\r\ncase 0:\r\nt->audmode = V4L2_TUNER_MODE_STEREO;\r\nbreak;\r\ncase 1:\r\nt->audmode = V4L2_TUNER_MODE_LANG2;\r\nbreak;\r\ncase 2:\r\nt->audmode = V4L2_TUNER_MODE_MONO;\r\nbreak;\r\ncase 3:\r\nt->audmode = V4L2_TUNER_MODE_SAP;\r\nbreak;\r\n}\r\nswitch (core->tvaudio) {\r\ncase WW_BTSC:\r\ncase WW_BG:\r\ncase WW_DK:\r\ncase WW_M:\r\ncase WW_EIAJ:\r\nif (!core->use_nicam) {\r\nt->rxsubchans = cx88_dsp_detect_stereo_sap(core);\r\nbreak;\r\n}\r\nbreak;\r\ncase WW_NONE:\r\ncase WW_I:\r\ncase WW_L:\r\ncase WW_I2SPT:\r\ncase WW_FM:\r\ncase WW_I2SADC:\r\nbreak;\r\n}\r\nif (UNSET == t->rxsubchans) {\r\nt->rxsubchans = V4L2_TUNER_SUB_MONO;\r\nif (V4L2_TUNER_MODE_STEREO == t->audmode)\r\nt->rxsubchans |= V4L2_TUNER_SUB_STEREO;\r\n}\r\nreturn;\r\n}\r\nvoid cx88_set_stereo(struct cx88_core *core, u32 mode, int manual)\r\n{\r\nu32 ctl = UNSET;\r\nu32 mask = UNSET;\r\nif (manual) {\r\ncore->audiomode_manual = mode;\r\n} else {\r\nif (UNSET != core->audiomode_manual)\r\nreturn;\r\n}\r\ncore->audiomode_current = mode;\r\nswitch (core->tvaudio) {\r\ncase WW_BTSC:\r\nswitch (mode) {\r\ncase V4L2_TUNER_MODE_MONO:\r\nset_audio_standard_BTSC(core, 0, EN_BTSC_FORCE_MONO);\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG1:\r\nset_audio_standard_BTSC(core, 0, EN_BTSC_AUTO_STEREO);\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG2:\r\nset_audio_standard_BTSC(core, 1, EN_BTSC_FORCE_SAP);\r\nbreak;\r\ncase V4L2_TUNER_MODE_STEREO:\r\ncase V4L2_TUNER_MODE_LANG1_LANG2:\r\nset_audio_standard_BTSC(core, 0, EN_BTSC_FORCE_STEREO);\r\nbreak;\r\n}\r\nbreak;\r\ncase WW_BG:\r\ncase WW_DK:\r\ncase WW_M:\r\ncase WW_I:\r\ncase WW_L:\r\nif (1 == core->use_nicam) {\r\nswitch (mode) {\r\ncase V4L2_TUNER_MODE_MONO:\r\ncase V4L2_TUNER_MODE_LANG1:\r\nset_audio_standard_NICAM(core,\r\nEN_NICAM_FORCE_MONO1);\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG2:\r\nset_audio_standard_NICAM(core,\r\nEN_NICAM_FORCE_MONO2);\r\nbreak;\r\ncase V4L2_TUNER_MODE_STEREO:\r\ncase V4L2_TUNER_MODE_LANG1_LANG2:\r\nset_audio_standard_NICAM(core,\r\nEN_NICAM_FORCE_STEREO);\r\nbreak;\r\n}\r\n} else {\r\nif ((core->tvaudio == WW_I) || (core->tvaudio == WW_L)) {\r\nset_audio_standard_A2(core, EN_A2_FORCE_MONO1);\r\n} else {\r\nmask = 0x3f;\r\nswitch (mode) {\r\ncase V4L2_TUNER_MODE_MONO:\r\ncase V4L2_TUNER_MODE_LANG1:\r\nctl = EN_A2_FORCE_MONO1;\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG2:\r\nctl = EN_A2_FORCE_MONO2;\r\nbreak;\r\ncase V4L2_TUNER_MODE_STEREO:\r\ncase V4L2_TUNER_MODE_LANG1_LANG2:\r\nctl = EN_A2_FORCE_STEREO;\r\nbreak;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase WW_FM:\r\nswitch (mode) {\r\ncase V4L2_TUNER_MODE_MONO:\r\nctl = EN_FMRADIO_FORCE_MONO;\r\nmask = 0x3f;\r\nbreak;\r\ncase V4L2_TUNER_MODE_STEREO:\r\nctl = EN_FMRADIO_AUTO_STEREO;\r\nmask = 0x3f;\r\nbreak;\r\n}\r\nbreak;\r\ncase WW_I2SADC:\r\ncase WW_NONE:\r\ncase WW_EIAJ:\r\ncase WW_I2SPT:\r\nbreak;\r\n}\r\nif (UNSET != ctl) {\r\ndprintk("cx88_set_stereo: mask 0x%x, ctl 0x%x "\r\n"[status=0x%x,ctl=0x%x,vol=0x%x]\n",\r\nmask, ctl, cx_read(AUD_STATUS),\r\ncx_read(AUD_CTL), cx_sread(SHADOW_AUD_VOL_CTL));\r\ncx_andor(AUD_CTL, mask, ctl);\r\n}\r\nreturn;\r\n}\r\nint cx88_audio_thread(void *data)\r\n{\r\nstruct cx88_core *core = data;\r\nstruct v4l2_tuner t;\r\nu32 mode = 0;\r\ndprintk("cx88: tvaudio thread started\n");\r\nset_freezable();\r\nfor (;;) {\r\nmsleep_interruptible(1000);\r\nif (kthread_should_stop())\r\nbreak;\r\ntry_to_freeze();\r\nswitch (core->tvaudio) {\r\ncase WW_BG:\r\ncase WW_DK:\r\ncase WW_M:\r\ncase WW_I:\r\ncase WW_L:\r\nif (core->use_nicam)\r\ngoto hw_autodetect;\r\nmemset(&t, 0, sizeof(t));\r\ncx88_get_stereo(core, &t);\r\nif (UNSET != core->audiomode_manual)\r\ncontinue;\r\nif (t.rxsubchans & V4L2_TUNER_SUB_STEREO)\r\nmode = V4L2_TUNER_MODE_STEREO;\r\nelse\r\nmode = V4L2_TUNER_MODE_MONO;\r\nif (mode == core->audiomode_current)\r\ncontinue;\r\ncx88_set_stereo(core, mode, 0);\r\nbreak;\r\ncase WW_NONE:\r\ncase WW_BTSC:\r\ncase WW_EIAJ:\r\ncase WW_I2SPT:\r\ncase WW_FM:\r\ncase WW_I2SADC:\r\nhw_autodetect:\r\nbreak;\r\n}\r\n}\r\ndprintk("cx88: tvaudio thread exiting\n");\r\nreturn 0;\r\n}
