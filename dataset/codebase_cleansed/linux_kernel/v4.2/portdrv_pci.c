static int __init pcie_port_setup(char *str)\r\n{\r\nif (!strncmp(str, "compat", 6)) {\r\npcie_ports_disabled = true;\r\n} else if (!strncmp(str, "native", 6)) {\r\npcie_ports_disabled = false;\r\npcie_ports_auto = false;\r\n} else if (!strncmp(str, "auto", 4)) {\r\npcie_ports_disabled = false;\r\npcie_ports_auto = true;\r\n}\r\nreturn 1;\r\n}\r\nvoid pcie_clear_root_pme_status(struct pci_dev *dev)\r\n{\r\npcie_capability_set_dword(dev, PCI_EXP_RTSTA, PCI_EXP_RTSTA_PME);\r\n}\r\nstatic int pcie_portdrv_restore_config(struct pci_dev *dev)\r\n{\r\nint retval;\r\nretval = pci_enable_device(dev);\r\nif (retval)\r\nreturn retval;\r\npci_set_master(dev);\r\nreturn 0;\r\n}\r\nstatic int pcie_port_resume_noirq(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nif (pci_pcie_type(pdev) == PCI_EXP_TYPE_ROOT_PORT)\r\npcie_clear_root_pme_status(pdev);\r\nreturn 0;\r\n}\r\nstatic int pcie_portdrv_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nint status;\r\nif (!pci_is_pcie(dev) ||\r\n((pci_pcie_type(dev) != PCI_EXP_TYPE_ROOT_PORT) &&\r\n(pci_pcie_type(dev) != PCI_EXP_TYPE_UPSTREAM) &&\r\n(pci_pcie_type(dev) != PCI_EXP_TYPE_DOWNSTREAM)))\r\nreturn -ENODEV;\r\nstatus = pcie_port_device_register(dev);\r\nif (status)\r\nreturn status;\r\npci_save_state(dev);\r\ndev->d3cold_allowed = false;\r\nreturn 0;\r\n}\r\nstatic void pcie_portdrv_remove(struct pci_dev *dev)\r\n{\r\npcie_port_device_remove(dev);\r\n}\r\nstatic int error_detected_iter(struct device *device, void *data)\r\n{\r\nstruct pcie_device *pcie_device;\r\nstruct pcie_port_service_driver *driver;\r\nstruct aer_broadcast_data *result_data;\r\npci_ers_result_t status;\r\nresult_data = (struct aer_broadcast_data *) data;\r\nif (device->bus == &pcie_port_bus_type && device->driver) {\r\ndriver = to_service_driver(device->driver);\r\nif (!driver ||\r\n!driver->err_handler ||\r\n!driver->err_handler->error_detected)\r\nreturn 0;\r\npcie_device = to_pcie_device(device);\r\nstatus = driver->err_handler->error_detected(\r\npcie_device->port,\r\nresult_data->state);\r\nresult_data->result =\r\nmerge_result(result_data->result, status);\r\n}\r\nreturn 0;\r\n}\r\nstatic pci_ers_result_t pcie_portdrv_error_detected(struct pci_dev *dev,\r\nenum pci_channel_state error)\r\n{\r\nstruct aer_broadcast_data data = {error, PCI_ERS_RESULT_CAN_RECOVER};\r\ndevice_for_each_child(&dev->dev, &data, error_detected_iter);\r\nreturn data.result;\r\n}\r\nstatic int mmio_enabled_iter(struct device *device, void *data)\r\n{\r\nstruct pcie_device *pcie_device;\r\nstruct pcie_port_service_driver *driver;\r\npci_ers_result_t status, *result;\r\nresult = (pci_ers_result_t *) data;\r\nif (device->bus == &pcie_port_bus_type && device->driver) {\r\ndriver = to_service_driver(device->driver);\r\nif (driver &&\r\ndriver->err_handler &&\r\ndriver->err_handler->mmio_enabled) {\r\npcie_device = to_pcie_device(device);\r\nstatus = driver->err_handler->mmio_enabled(\r\npcie_device->port);\r\n*result = merge_result(*result, status);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic pci_ers_result_t pcie_portdrv_mmio_enabled(struct pci_dev *dev)\r\n{\r\npci_ers_result_t status = PCI_ERS_RESULT_RECOVERED;\r\ndevice_for_each_child(&dev->dev, &status, mmio_enabled_iter);\r\nreturn status;\r\n}\r\nstatic int slot_reset_iter(struct device *device, void *data)\r\n{\r\nstruct pcie_device *pcie_device;\r\nstruct pcie_port_service_driver *driver;\r\npci_ers_result_t status, *result;\r\nresult = (pci_ers_result_t *) data;\r\nif (device->bus == &pcie_port_bus_type && device->driver) {\r\ndriver = to_service_driver(device->driver);\r\nif (driver &&\r\ndriver->err_handler &&\r\ndriver->err_handler->slot_reset) {\r\npcie_device = to_pcie_device(device);\r\nstatus = driver->err_handler->slot_reset(\r\npcie_device->port);\r\n*result = merge_result(*result, status);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic pci_ers_result_t pcie_portdrv_slot_reset(struct pci_dev *dev)\r\n{\r\npci_ers_result_t status = PCI_ERS_RESULT_RECOVERED;\r\nif (dev->error_state == pci_channel_io_frozen) {\r\ndev->state_saved = true;\r\npci_restore_state(dev);\r\npcie_portdrv_restore_config(dev);\r\npci_enable_pcie_error_reporting(dev);\r\n}\r\ndevice_for_each_child(&dev->dev, &status, slot_reset_iter);\r\nreturn status;\r\n}\r\nstatic int resume_iter(struct device *device, void *data)\r\n{\r\nstruct pcie_device *pcie_device;\r\nstruct pcie_port_service_driver *driver;\r\nif (device->bus == &pcie_port_bus_type && device->driver) {\r\ndriver = to_service_driver(device->driver);\r\nif (driver &&\r\ndriver->err_handler &&\r\ndriver->err_handler->resume) {\r\npcie_device = to_pcie_device(device);\r\ndriver->err_handler->resume(pcie_device->port);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void pcie_portdrv_err_resume(struct pci_dev *dev)\r\n{\r\ndevice_for_each_child(&dev->dev, NULL, resume_iter);\r\n}\r\nstatic int __init dmi_pcie_pme_disable_msi(const struct dmi_system_id *d)\r\n{\r\npr_notice("%s detected: will not use MSI for PCIe PME signaling\n",\r\nd->ident);\r\npcie_pme_disable_msi();\r\nreturn 0;\r\n}\r\nstatic int __init pcie_portdrv_init(void)\r\n{\r\nint retval;\r\nif (pcie_ports_disabled)\r\nreturn pci_register_driver(&pcie_portdriver);\r\ndmi_check_system(pcie_portdrv_dmi_table);\r\nretval = pcie_port_bus_register();\r\nif (retval) {\r\nprintk(KERN_WARNING "PCIE: bus_register error: %d\n", retval);\r\ngoto out;\r\n}\r\nretval = pci_register_driver(&pcie_portdriver);\r\nif (retval)\r\npcie_port_bus_unregister();\r\nout:\r\nreturn retval;\r\n}
