static inline int imr_is_enabled(struct imr_regs *imr)\r\n{\r\nreturn !(imr->rmask == IMR_READ_ACCESS_ALL &&\r\nimr->wmask == IMR_WRITE_ACCESS_ALL &&\r\nimr_to_phys(imr->addr_lo) == 0 &&\r\nimr_to_phys(imr->addr_hi) == 0);\r\n}\r\nstatic int imr_read(struct imr_device *idev, u32 imr_id, struct imr_regs *imr)\r\n{\r\nu32 reg = imr_id * IMR_NUM_REGS + idev->reg_base;\r\nint ret;\r\nret = iosf_mbi_read(QRK_MBI_UNIT_MM, QRK_MBI_MM_READ,\r\nreg++, &imr->addr_lo);\r\nif (ret)\r\nreturn ret;\r\nret = iosf_mbi_read(QRK_MBI_UNIT_MM, QRK_MBI_MM_READ,\r\nreg++, &imr->addr_hi);\r\nif (ret)\r\nreturn ret;\r\nret = iosf_mbi_read(QRK_MBI_UNIT_MM, QRK_MBI_MM_READ,\r\nreg++, &imr->rmask);\r\nif (ret)\r\nreturn ret;\r\nreturn iosf_mbi_read(QRK_MBI_UNIT_MM, QRK_MBI_MM_READ,\r\nreg++, &imr->wmask);\r\n}\r\nstatic int imr_write(struct imr_device *idev, u32 imr_id,\r\nstruct imr_regs *imr, bool lock)\r\n{\r\nunsigned long flags;\r\nu32 reg = imr_id * IMR_NUM_REGS + idev->reg_base;\r\nint ret;\r\nlocal_irq_save(flags);\r\nret = iosf_mbi_write(QRK_MBI_UNIT_MM, QRK_MBI_MM_WRITE, reg++,\r\nimr->addr_lo);\r\nif (ret)\r\ngoto failed;\r\nret = iosf_mbi_write(QRK_MBI_UNIT_MM, QRK_MBI_MM_WRITE,\r\nreg++, imr->addr_hi);\r\nif (ret)\r\ngoto failed;\r\nret = iosf_mbi_write(QRK_MBI_UNIT_MM, QRK_MBI_MM_WRITE,\r\nreg++, imr->rmask);\r\nif (ret)\r\ngoto failed;\r\nret = iosf_mbi_write(QRK_MBI_UNIT_MM, QRK_MBI_MM_WRITE,\r\nreg++, imr->wmask);\r\nif (ret)\r\ngoto failed;\r\nif (lock) {\r\nimr->addr_lo |= IMR_LOCK;\r\nret = iosf_mbi_write(QRK_MBI_UNIT_MM, QRK_MBI_MM_WRITE,\r\nreg - IMR_NUM_REGS, imr->addr_lo);\r\nif (ret)\r\ngoto failed;\r\n}\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\nfailed:\r\nlocal_irq_restore(flags);\r\nWARN(ret, "IOSF-MBI write fail range 0x%08x-0x%08x unreliable\n",\r\nimr_to_phys(imr->addr_lo), imr_to_phys(imr->addr_hi) + IMR_MASK);\r\nreturn ret;\r\n}\r\nstatic int imr_dbgfs_state_show(struct seq_file *s, void *unused)\r\n{\r\nphys_addr_t base;\r\nphys_addr_t end;\r\nint i;\r\nstruct imr_device *idev = s->private;\r\nstruct imr_regs imr;\r\nsize_t size;\r\nint ret = -ENODEV;\r\nmutex_lock(&idev->lock);\r\nfor (i = 0; i < idev->max_imr; i++) {\r\nret = imr_read(idev, i, &imr);\r\nif (ret)\r\nbreak;\r\nif (imr_is_enabled(&imr)) {\r\nbase = imr_to_phys(imr.addr_lo);\r\nend = imr_to_phys(imr.addr_hi) + IMR_MASK;\r\n} else {\r\nbase = 0;\r\nend = 0;\r\n}\r\nsize = end - base;\r\nseq_printf(s, "imr%02i: base=%pa, end=%pa, size=0x%08zx "\r\n"rmask=0x%08x, wmask=0x%08x, %s, %s\n", i,\r\n&base, &end, size, imr.rmask, imr.wmask,\r\nimr_is_enabled(&imr) ? "enabled " : "disabled",\r\nimr.addr_lo & IMR_LOCK ? "locked" : "unlocked");\r\n}\r\nmutex_unlock(&idev->lock);\r\nreturn ret;\r\n}\r\nstatic int imr_state_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, imr_dbgfs_state_show, inode->i_private);\r\n}\r\nstatic int imr_debugfs_register(struct imr_device *idev)\r\n{\r\nidev->file = debugfs_create_file("imr_state", S_IFREG | S_IRUGO, NULL,\r\nidev, &imr_state_ops);\r\nreturn PTR_ERR_OR_ZERO(idev->file);\r\n}\r\nstatic void imr_debugfs_unregister(struct imr_device *idev)\r\n{\r\ndebugfs_remove(idev->file);\r\n}\r\nstatic int imr_check_params(phys_addr_t base, size_t size)\r\n{\r\nif ((base & IMR_MASK) || (size & IMR_MASK)) {\r\npr_err("base %pa size 0x%08zx must align to 1KiB\n",\r\n&base, size);\r\nreturn -EINVAL;\r\n}\r\nif (size == 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic inline size_t imr_raw_size(size_t size)\r\n{\r\nreturn size - IMR_ALIGN;\r\n}\r\nstatic inline int imr_address_overlap(phys_addr_t addr, struct imr_regs *imr)\r\n{\r\nreturn addr >= imr_to_phys(imr->addr_lo) && addr <= imr_to_phys(imr->addr_hi);\r\n}\r\nint imr_add_range(phys_addr_t base, size_t size,\r\nunsigned int rmask, unsigned int wmask, bool lock)\r\n{\r\nphys_addr_t end;\r\nunsigned int i;\r\nstruct imr_device *idev = &imr_dev;\r\nstruct imr_regs imr;\r\nsize_t raw_size;\r\nint reg;\r\nint ret;\r\nif (WARN_ONCE(idev->init == false, "driver not initialized"))\r\nreturn -ENODEV;\r\nret = imr_check_params(base, size);\r\nif (ret)\r\nreturn ret;\r\nraw_size = imr_raw_size(size);\r\nend = base + raw_size;\r\nimr.addr_lo = phys_to_imr(base);\r\nimr.addr_hi = phys_to_imr(end);\r\nimr.rmask = rmask;\r\nimr.wmask = wmask;\r\nif (!imr_is_enabled(&imr))\r\nreturn -ENOTSUPP;\r\nmutex_lock(&idev->lock);\r\nreg = -1;\r\nfor (i = 0; i < idev->max_imr; i++) {\r\nret = imr_read(idev, i, &imr);\r\nif (ret)\r\ngoto failed;\r\nret = -EINVAL;\r\nif (imr_is_enabled(&imr)) {\r\nif (imr_address_overlap(base, &imr))\r\ngoto failed;\r\nif (imr_address_overlap(end, &imr))\r\ngoto failed;\r\n} else {\r\nreg = i;\r\n}\r\n}\r\nif (reg == -1) {\r\nret = -ENOMEM;\r\ngoto failed;\r\n}\r\npr_debug("add %d phys %pa-%pa size %zx mask 0x%08x wmask 0x%08x\n",\r\nreg, &base, &end, raw_size, rmask, wmask);\r\nimr.addr_lo = phys_to_imr(base);\r\nimr.addr_hi = phys_to_imr(end);\r\nimr.rmask = rmask;\r\nimr.wmask = wmask;\r\nret = imr_write(idev, reg, &imr, lock);\r\nif (ret < 0) {\r\nimr.addr_lo = 0;\r\nimr.addr_hi = 0;\r\nimr.rmask = IMR_READ_ACCESS_ALL;\r\nimr.wmask = IMR_WRITE_ACCESS_ALL;\r\nimr_write(idev, reg, &imr, false);\r\n}\r\nfailed:\r\nmutex_unlock(&idev->lock);\r\nreturn ret;\r\n}\r\nstatic int __imr_remove_range(int reg, phys_addr_t base, size_t size)\r\n{\r\nphys_addr_t end;\r\nbool found = false;\r\nunsigned int i;\r\nstruct imr_device *idev = &imr_dev;\r\nstruct imr_regs imr;\r\nsize_t raw_size;\r\nint ret = 0;\r\nif (WARN_ONCE(idev->init == false, "driver not initialized"))\r\nreturn -ENODEV;\r\nif (reg == -1) {\r\nret = imr_check_params(base, size);\r\nif (ret)\r\nreturn ret;\r\n}\r\nraw_size = imr_raw_size(size);\r\nend = base + raw_size;\r\nmutex_lock(&idev->lock);\r\nif (reg >= 0) {\r\nret = imr_read(idev, reg, &imr);\r\nif (ret)\r\ngoto failed;\r\nif (!imr_is_enabled(&imr) || imr.addr_lo & IMR_LOCK) {\r\nret = -ENODEV;\r\ngoto failed;\r\n}\r\nfound = true;\r\n} else {\r\nfor (i = 0; i < idev->max_imr; i++) {\r\nret = imr_read(idev, i, &imr);\r\nif (ret)\r\ngoto failed;\r\nif (!imr_is_enabled(&imr) || imr.addr_lo & IMR_LOCK)\r\ncontinue;\r\nif ((imr_to_phys(imr.addr_lo) == base) &&\r\n(imr_to_phys(imr.addr_hi) == end)) {\r\nfound = true;\r\nreg = i;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!found) {\r\nret = -ENODEV;\r\ngoto failed;\r\n}\r\npr_debug("remove %d phys %pa-%pa size %zx\n", reg, &base, &end, raw_size);\r\nimr.addr_lo = 0;\r\nimr.addr_hi = 0;\r\nimr.rmask = IMR_READ_ACCESS_ALL;\r\nimr.wmask = IMR_WRITE_ACCESS_ALL;\r\nret = imr_write(idev, reg, &imr, false);\r\nfailed:\r\nmutex_unlock(&idev->lock);\r\nreturn ret;\r\n}\r\nint imr_remove_range(phys_addr_t base, size_t size)\r\n{\r\nreturn __imr_remove_range(-1, base, size);\r\n}\r\nstatic inline int imr_clear(int reg)\r\n{\r\nreturn __imr_remove_range(reg, 0, 0);\r\n}\r\nstatic void __init imr_fixup_memmap(struct imr_device *idev)\r\n{\r\nphys_addr_t base = virt_to_phys(&_text);\r\nsize_t size = virt_to_phys(&__end_rodata) - base;\r\nint i;\r\nint ret;\r\nfor (i = 0; i < idev->max_imr; i++)\r\nimr_clear(i);\r\nret = imr_add_range(base, size, IMR_CPU, IMR_CPU, true);\r\nif (ret < 0) {\r\npr_err("unable to setup IMR for kernel: (%p - %p)\n",\r\n&_text, &__end_rodata);\r\n} else {\r\npr_info("protecting kernel .text - .rodata: %zu KiB (%p - %p)\n",\r\nsize / 1024, &_text, &__end_rodata);\r\n}\r\n}\r\nstatic int __init imr_init(void)\r\n{\r\nstruct imr_device *idev = &imr_dev;\r\nint ret;\r\nif (!x86_match_cpu(imr_ids) || !iosf_mbi_available())\r\nreturn -ENODEV;\r\nidev->max_imr = QUARK_X1000_IMR_MAX;\r\nidev->reg_base = QUARK_X1000_IMR_REGBASE;\r\nidev->init = true;\r\nmutex_init(&idev->lock);\r\nret = imr_debugfs_register(idev);\r\nif (ret != 0)\r\npr_warn("debugfs register failed!\n");\r\nimr_fixup_memmap(idev);\r\nreturn 0;\r\n}\r\nstatic void __exit imr_exit(void)\r\n{\r\nimr_debugfs_unregister(&imr_dev);\r\n}
