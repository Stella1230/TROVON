static unsigned long *ipmi_ssif_lock_cond(struct ssif_info *ssif_info,\r\nunsigned long *flags)\r\n{\r\nspin_lock_irqsave(&ssif_info->lock, *flags);\r\nreturn flags;\r\n}\r\nstatic void ipmi_ssif_unlock_cond(struct ssif_info *ssif_info,\r\nunsigned long *flags)\r\n{\r\nspin_unlock_irqrestore(&ssif_info->lock, *flags);\r\n}\r\nstatic void deliver_recv_msg(struct ssif_info *ssif_info,\r\nstruct ipmi_smi_msg *msg)\r\n{\r\nipmi_smi_t intf = ssif_info->intf;\r\nif (!intf) {\r\nipmi_free_smi_msg(msg);\r\n} else if (msg->rsp_size < 0) {\r\nreturn_hosed_msg(ssif_info, msg);\r\npr_err(PFX\r\n"Malformed message in deliver_recv_msg: rsp_size = %d\n",\r\nmsg->rsp_size);\r\n} else {\r\nipmi_smi_msg_received(intf, msg);\r\n}\r\n}\r\nstatic void return_hosed_msg(struct ssif_info *ssif_info,\r\nstruct ipmi_smi_msg *msg)\r\n{\r\nssif_inc_stat(ssif_info, hosed);\r\nmsg->rsp[0] = msg->data[0] | 4;\r\nmsg->rsp[1] = msg->data[1];\r\nmsg->rsp[2] = 0xFF;\r\nmsg->rsp_size = 3;\r\ndeliver_recv_msg(ssif_info, msg);\r\n}\r\nstatic void start_clear_flags(struct ssif_info *ssif_info, unsigned long *flags)\r\n{\r\nunsigned char msg[3];\r\nssif_info->msg_flags &= ~WDT_PRE_TIMEOUT_INT;\r\nssif_info->ssif_state = SSIF_CLEARING_FLAGS;\r\nipmi_ssif_unlock_cond(ssif_info, flags);\r\nmsg[0] = (IPMI_NETFN_APP_REQUEST << 2);\r\nmsg[1] = IPMI_CLEAR_MSG_FLAGS_CMD;\r\nmsg[2] = WDT_PRE_TIMEOUT_INT;\r\nif (start_send(ssif_info, msg, 3) != 0) {\r\nssif_info->ssif_state = SSIF_NORMAL;\r\n}\r\n}\r\nstatic void start_flag_fetch(struct ssif_info *ssif_info, unsigned long *flags)\r\n{\r\nunsigned char mb[2];\r\nssif_info->req_flags = false;\r\nssif_info->ssif_state = SSIF_GETTING_FLAGS;\r\nipmi_ssif_unlock_cond(ssif_info, flags);\r\nmb[0] = (IPMI_NETFN_APP_REQUEST << 2);\r\nmb[1] = IPMI_GET_MSG_FLAGS_CMD;\r\nif (start_send(ssif_info, mb, 2) != 0)\r\nssif_info->ssif_state = SSIF_NORMAL;\r\n}\r\nstatic void check_start_send(struct ssif_info *ssif_info, unsigned long *flags,\r\nstruct ipmi_smi_msg *msg)\r\n{\r\nif (start_send(ssif_info, msg->data, msg->data_size) != 0) {\r\nunsigned long oflags;\r\nflags = ipmi_ssif_lock_cond(ssif_info, &oflags);\r\nssif_info->curr_msg = NULL;\r\nssif_info->ssif_state = SSIF_NORMAL;\r\nipmi_ssif_unlock_cond(ssif_info, flags);\r\nipmi_free_smi_msg(msg);\r\n}\r\n}\r\nstatic void start_event_fetch(struct ssif_info *ssif_info, unsigned long *flags)\r\n{\r\nstruct ipmi_smi_msg *msg;\r\nssif_info->req_events = false;\r\nmsg = ipmi_alloc_smi_msg();\r\nif (!msg) {\r\nssif_info->ssif_state = SSIF_NORMAL;\r\nreturn;\r\n}\r\nssif_info->curr_msg = msg;\r\nssif_info->ssif_state = SSIF_GETTING_EVENTS;\r\nipmi_ssif_unlock_cond(ssif_info, flags);\r\nmsg->data[0] = (IPMI_NETFN_APP_REQUEST << 2);\r\nmsg->data[1] = IPMI_READ_EVENT_MSG_BUFFER_CMD;\r\nmsg->data_size = 2;\r\ncheck_start_send(ssif_info, flags, msg);\r\n}\r\nstatic void start_recv_msg_fetch(struct ssif_info *ssif_info,\r\nunsigned long *flags)\r\n{\r\nstruct ipmi_smi_msg *msg;\r\nmsg = ipmi_alloc_smi_msg();\r\nif (!msg) {\r\nssif_info->ssif_state = SSIF_NORMAL;\r\nreturn;\r\n}\r\nssif_info->curr_msg = msg;\r\nssif_info->ssif_state = SSIF_GETTING_MESSAGES;\r\nipmi_ssif_unlock_cond(ssif_info, flags);\r\nmsg->data[0] = (IPMI_NETFN_APP_REQUEST << 2);\r\nmsg->data[1] = IPMI_GET_MSG_CMD;\r\nmsg->data_size = 2;\r\ncheck_start_send(ssif_info, flags, msg);\r\n}\r\nstatic void handle_flags(struct ssif_info *ssif_info, unsigned long *flags)\r\n{\r\nif (ssif_info->msg_flags & WDT_PRE_TIMEOUT_INT) {\r\nipmi_smi_t intf = ssif_info->intf;\r\nssif_inc_stat(ssif_info, watchdog_pretimeouts);\r\nstart_clear_flags(ssif_info, flags);\r\nif (intf)\r\nipmi_smi_watchdog_pretimeout(intf);\r\n} else if (ssif_info->msg_flags & RECEIVE_MSG_AVAIL)\r\nstart_recv_msg_fetch(ssif_info, flags);\r\nelse if (ssif_info->msg_flags & EVENT_MSG_BUFFER_FULL)\r\nstart_event_fetch(ssif_info, flags);\r\nelse {\r\nssif_info->ssif_state = SSIF_NORMAL;\r\nipmi_ssif_unlock_cond(ssif_info, flags);\r\n}\r\n}\r\nstatic int ipmi_ssif_thread(void *data)\r\n{\r\nstruct ssif_info *ssif_info = data;\r\nwhile (!kthread_should_stop()) {\r\nint result;\r\nresult = wait_for_completion_interruptible(\r\n&ssif_info->wake_thread);\r\nif (ssif_info->stopping)\r\nbreak;\r\nif (result == -ERESTARTSYS)\r\ncontinue;\r\ninit_completion(&ssif_info->wake_thread);\r\nif (ssif_info->i2c_read_write == I2C_SMBUS_WRITE) {\r\nresult = i2c_smbus_write_block_data(\r\nssif_info->client, ssif_info->i2c_command,\r\nssif_info->i2c_data[0],\r\nssif_info->i2c_data + 1);\r\nssif_info->done_handler(ssif_info, result, NULL, 0);\r\n} else {\r\nresult = i2c_smbus_read_block_data(\r\nssif_info->client, ssif_info->i2c_command,\r\nssif_info->i2c_data);\r\nif (result < 0)\r\nssif_info->done_handler(ssif_info, result,\r\nNULL, 0);\r\nelse\r\nssif_info->done_handler(ssif_info, 0,\r\nssif_info->i2c_data,\r\nresult);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ssif_i2c_send(struct ssif_info *ssif_info,\r\nssif_i2c_done handler,\r\nint read_write, int command,\r\nunsigned char *data, unsigned int size)\r\n{\r\nssif_info->done_handler = handler;\r\nssif_info->i2c_read_write = read_write;\r\nssif_info->i2c_command = command;\r\nssif_info->i2c_data = data;\r\nssif_info->i2c_size = size;\r\ncomplete(&ssif_info->wake_thread);\r\nreturn 0;\r\n}\r\nstatic void start_get(struct ssif_info *ssif_info)\r\n{\r\nint rv;\r\nssif_info->rtc_us_timer = 0;\r\nssif_info->multi_pos = 0;\r\nrv = ssif_i2c_send(ssif_info, msg_done_handler, I2C_SMBUS_READ,\r\nSSIF_IPMI_RESPONSE,\r\nssif_info->recv, I2C_SMBUS_BLOCK_DATA);\r\nif (rv < 0) {\r\nif (ssif_info->ssif_debug & SSIF_DEBUG_MSG)\r\npr_info("Error from i2c_non_blocking_op(5)\n");\r\nmsg_done_handler(ssif_info, -EIO, NULL, 0);\r\n}\r\n}\r\nstatic void retry_timeout(unsigned long data)\r\n{\r\nstruct ssif_info *ssif_info = (void *) data;\r\nunsigned long oflags, *flags;\r\nbool waiting;\r\nif (ssif_info->stopping)\r\nreturn;\r\nflags = ipmi_ssif_lock_cond(ssif_info, &oflags);\r\nwaiting = ssif_info->waiting_alert;\r\nssif_info->waiting_alert = false;\r\nipmi_ssif_unlock_cond(ssif_info, flags);\r\nif (waiting)\r\nstart_get(ssif_info);\r\n}\r\nstatic void ssif_alert(struct i2c_client *client, unsigned int data)\r\n{\r\nstruct ssif_info *ssif_info = i2c_get_clientdata(client);\r\nunsigned long oflags, *flags;\r\nbool do_get = false;\r\nssif_inc_stat(ssif_info, alerts);\r\nflags = ipmi_ssif_lock_cond(ssif_info, &oflags);\r\nif (ssif_info->waiting_alert) {\r\nssif_info->waiting_alert = false;\r\ndel_timer(&ssif_info->retry_timer);\r\ndo_get = true;\r\n} else if (ssif_info->curr_msg) {\r\nssif_info->got_alert = true;\r\n}\r\nipmi_ssif_unlock_cond(ssif_info, flags);\r\nif (do_get)\r\nstart_get(ssif_info);\r\n}\r\nstatic void msg_done_handler(struct ssif_info *ssif_info, int result,\r\nunsigned char *data, unsigned int len)\r\n{\r\nstruct ipmi_smi_msg *msg;\r\nunsigned long oflags, *flags;\r\nint rv;\r\nif (result < 0) {\r\nssif_info->retries_left--;\r\nif (ssif_info->retries_left > 0) {\r\nssif_inc_stat(ssif_info, receive_retries);\r\nflags = ipmi_ssif_lock_cond(ssif_info, &oflags);\r\nssif_info->waiting_alert = true;\r\nssif_info->rtc_us_timer = SSIF_MSG_USEC;\r\nmod_timer(&ssif_info->retry_timer,\r\njiffies + SSIF_MSG_JIFFIES);\r\nipmi_ssif_unlock_cond(ssif_info, flags);\r\nreturn;\r\n}\r\nssif_inc_stat(ssif_info, receive_errors);\r\nif (ssif_info->ssif_debug & SSIF_DEBUG_MSG)\r\npr_info("Error in msg_done_handler: %d\n", result);\r\nlen = 0;\r\ngoto continue_op;\r\n}\r\nif ((len > 1) && (ssif_info->multi_pos == 0)\r\n&& (data[0] == 0x00) && (data[1] == 0x01)) {\r\nint i;\r\nssif_inc_stat(ssif_info, received_message_parts);\r\nlen -= 2;\r\nfor (i = 0; i < len; i++)\r\nssif_info->data[i] = data[i+2];\r\nssif_info->multi_len = len;\r\nssif_info->multi_pos = 1;\r\nrv = ssif_i2c_send(ssif_info, msg_done_handler, I2C_SMBUS_READ,\r\nSSIF_IPMI_MULTI_PART_RESPONSE_MIDDLE,\r\nssif_info->recv, I2C_SMBUS_BLOCK_DATA);\r\nif (rv < 0) {\r\nif (ssif_info->ssif_debug & SSIF_DEBUG_MSG)\r\npr_info("Error from i2c_non_blocking_op(1)\n");\r\nresult = -EIO;\r\n} else\r\nreturn;\r\n} else if (ssif_info->multi_pos) {\r\nint i;\r\nunsigned char blocknum;\r\nif (len == 0) {\r\nresult = -EIO;\r\nif (ssif_info->ssif_debug & SSIF_DEBUG_MSG)\r\npr_info(PFX "Middle message with no data\n");\r\ngoto continue_op;\r\n}\r\nblocknum = data[0];\r\nif (ssif_info->multi_len + len - 1 > IPMI_MAX_MSG_LENGTH) {\r\nresult = -E2BIG;\r\nif (ssif_info->ssif_debug & SSIF_DEBUG_MSG)\r\npr_info("Received message too big\n");\r\ngoto continue_op;\r\n}\r\nlen--;\r\nfor (i = 0; i < len; i++)\r\nssif_info->data[i + ssif_info->multi_len] = data[i + 1];\r\nssif_info->multi_len += len;\r\nif (blocknum == 0xff) {\r\nlen = ssif_info->multi_len;\r\ndata = ssif_info->data;\r\n} else if (blocknum + 1 != ssif_info->multi_pos) {\r\nresult = -EIO;\r\n} else {\r\nssif_inc_stat(ssif_info, received_message_parts);\r\nssif_info->multi_pos++;\r\nrv = ssif_i2c_send(ssif_info, msg_done_handler,\r\nI2C_SMBUS_READ,\r\nSSIF_IPMI_MULTI_PART_RESPONSE_MIDDLE,\r\nssif_info->recv,\r\nI2C_SMBUS_BLOCK_DATA);\r\nif (rv < 0) {\r\nif (ssif_info->ssif_debug & SSIF_DEBUG_MSG)\r\npr_info(PFX\r\n"Error from ssif_i2c_send\n");\r\nresult = -EIO;\r\n} else\r\nreturn;\r\n}\r\n}\r\nif (result < 0) {\r\nssif_inc_stat(ssif_info, receive_errors);\r\n} else {\r\nssif_inc_stat(ssif_info, received_messages);\r\nssif_inc_stat(ssif_info, received_message_parts);\r\n}\r\ncontinue_op:\r\nif (ssif_info->ssif_debug & SSIF_DEBUG_STATE)\r\npr_info(PFX "DONE 1: state = %d, result=%d.\n",\r\nssif_info->ssif_state, result);\r\nflags = ipmi_ssif_lock_cond(ssif_info, &oflags);\r\nmsg = ssif_info->curr_msg;\r\nif (msg) {\r\nmsg->rsp_size = len;\r\nif (msg->rsp_size > IPMI_MAX_MSG_LENGTH)\r\nmsg->rsp_size = IPMI_MAX_MSG_LENGTH;\r\nmemcpy(msg->rsp, data, msg->rsp_size);\r\nssif_info->curr_msg = NULL;\r\n}\r\nswitch (ssif_info->ssif_state) {\r\ncase SSIF_NORMAL:\r\nipmi_ssif_unlock_cond(ssif_info, flags);\r\nif (!msg)\r\nbreak;\r\nif (result < 0)\r\nreturn_hosed_msg(ssif_info, msg);\r\nelse\r\ndeliver_recv_msg(ssif_info, msg);\r\nbreak;\r\ncase SSIF_GETTING_FLAGS:\r\nif ((result < 0) || (len < 4) || (data[2] != 0)) {\r\nssif_info->ssif_state = SSIF_NORMAL;\r\nipmi_ssif_unlock_cond(ssif_info, flags);\r\npr_warn(PFX "Error getting flags: %d %d, %x\n",\r\nresult, len, data[2]);\r\n} else if (data[0] != (IPMI_NETFN_APP_REQUEST | 1) << 2\r\n|| data[1] != IPMI_GET_MSG_FLAGS_CMD) {\r\npr_warn(PFX "Invalid response getting flags: %x %x\n",\r\ndata[0], data[1]);\r\n} else {\r\nssif_inc_stat(ssif_info, flag_fetches);\r\nssif_info->msg_flags = data[3];\r\nhandle_flags(ssif_info, flags);\r\n}\r\nbreak;\r\ncase SSIF_CLEARING_FLAGS:\r\nif ((result < 0) || (len < 3) || (data[2] != 0)) {\r\npr_warn(PFX "Error clearing flags: %d %d, %x\n",\r\nresult, len, data[2]);\r\n} else if (data[0] != (IPMI_NETFN_APP_REQUEST | 1) << 2\r\n|| data[1] != IPMI_CLEAR_MSG_FLAGS_CMD) {\r\npr_warn(PFX "Invalid response clearing flags: %x %x\n",\r\ndata[0], data[1]);\r\n}\r\nssif_info->ssif_state = SSIF_NORMAL;\r\nipmi_ssif_unlock_cond(ssif_info, flags);\r\nbreak;\r\ncase SSIF_GETTING_EVENTS:\r\nif ((result < 0) || (len < 3) || (msg->rsp[2] != 0)) {\r\nmsg->done(msg);\r\nssif_info->msg_flags &= ~EVENT_MSG_BUFFER_FULL;\r\nhandle_flags(ssif_info, flags);\r\n} else if (msg->rsp[0] != (IPMI_NETFN_APP_REQUEST | 1) << 2\r\n|| msg->rsp[1] != IPMI_READ_EVENT_MSG_BUFFER_CMD) {\r\npr_warn(PFX "Invalid response getting events: %x %x\n",\r\nmsg->rsp[0], msg->rsp[1]);\r\nmsg->done(msg);\r\nssif_info->msg_flags &= ~EVENT_MSG_BUFFER_FULL;\r\nhandle_flags(ssif_info, flags);\r\n} else {\r\nhandle_flags(ssif_info, flags);\r\nssif_inc_stat(ssif_info, events);\r\ndeliver_recv_msg(ssif_info, msg);\r\n}\r\nbreak;\r\ncase SSIF_GETTING_MESSAGES:\r\nif ((result < 0) || (len < 3) || (msg->rsp[2] != 0)) {\r\nmsg->done(msg);\r\nssif_info->msg_flags &= ~RECEIVE_MSG_AVAIL;\r\nhandle_flags(ssif_info, flags);\r\n} else if (msg->rsp[0] != (IPMI_NETFN_APP_REQUEST | 1) << 2\r\n|| msg->rsp[1] != IPMI_GET_MSG_CMD) {\r\npr_warn(PFX "Invalid response clearing flags: %x %x\n",\r\nmsg->rsp[0], msg->rsp[1]);\r\nmsg->done(msg);\r\nssif_info->msg_flags &= ~RECEIVE_MSG_AVAIL;\r\nhandle_flags(ssif_info, flags);\r\n} else {\r\nssif_inc_stat(ssif_info, incoming_messages);\r\nhandle_flags(ssif_info, flags);\r\ndeliver_recv_msg(ssif_info, msg);\r\n}\r\nbreak;\r\n}\r\nflags = ipmi_ssif_lock_cond(ssif_info, &oflags);\r\nif (SSIF_IDLE(ssif_info) && !ssif_info->stopping) {\r\nif (ssif_info->req_events)\r\nstart_event_fetch(ssif_info, flags);\r\nelse if (ssif_info->req_flags)\r\nstart_flag_fetch(ssif_info, flags);\r\nelse\r\nstart_next_msg(ssif_info, flags);\r\n} else\r\nipmi_ssif_unlock_cond(ssif_info, flags);\r\nif (ssif_info->ssif_debug & SSIF_DEBUG_STATE)\r\npr_info(PFX "DONE 2: state = %d.\n", ssif_info->ssif_state);\r\n}\r\nstatic void msg_written_handler(struct ssif_info *ssif_info, int result,\r\nunsigned char *data, unsigned int len)\r\n{\r\nint rv;\r\nif (result < 0) {\r\nssif_info->retries_left--;\r\nif (ssif_info->retries_left > 0) {\r\nif (!start_resend(ssif_info)) {\r\nssif_inc_stat(ssif_info, send_retries);\r\nreturn;\r\n}\r\nssif_inc_stat(ssif_info, send_errors);\r\nif (ssif_info->ssif_debug & SSIF_DEBUG_MSG)\r\npr_info(PFX\r\n"Out of retries in msg_written_handler\n");\r\nmsg_done_handler(ssif_info, -EIO, NULL, 0);\r\nreturn;\r\n}\r\nssif_inc_stat(ssif_info, send_errors);\r\nif (ssif_info->ssif_debug & SSIF_DEBUG_MSG)\r\npr_info("Error in msg_written_handler: %d\n", result);\r\nmsg_done_handler(ssif_info, result, NULL, 0);\r\nreturn;\r\n}\r\nif (ssif_info->multi_data) {\r\nint left;\r\nssif_inc_stat(ssif_info, sent_messages_parts);\r\nleft = ssif_info->multi_len - ssif_info->multi_pos;\r\nif (left > 32)\r\nleft = 32;\r\nssif_info->multi_data[ssif_info->multi_pos] = left;\r\nssif_info->multi_pos += left;\r\nif (left < 32)\r\nssif_info->multi_data = NULL;\r\nrv = ssif_i2c_send(ssif_info, msg_written_handler,\r\nI2C_SMBUS_WRITE,\r\nSSIF_IPMI_MULTI_PART_REQUEST_MIDDLE,\r\nssif_info->multi_data + ssif_info->multi_pos,\r\nI2C_SMBUS_BLOCK_DATA);\r\nif (rv < 0) {\r\nssif_inc_stat(ssif_info, send_errors);\r\nif (ssif_info->ssif_debug & SSIF_DEBUG_MSG)\r\npr_info("Error from i2c_non_blocking_op(3)\n");\r\nmsg_done_handler(ssif_info, -EIO, NULL, 0);\r\n}\r\n} else {\r\nunsigned long oflags, *flags;\r\nbool got_alert;\r\nssif_inc_stat(ssif_info, sent_messages);\r\nssif_inc_stat(ssif_info, sent_messages_parts);\r\nflags = ipmi_ssif_lock_cond(ssif_info, &oflags);\r\ngot_alert = ssif_info->got_alert;\r\nif (got_alert) {\r\nssif_info->got_alert = false;\r\nssif_info->waiting_alert = false;\r\n}\r\nif (got_alert) {\r\nipmi_ssif_unlock_cond(ssif_info, flags);\r\nretry_timeout((unsigned long) ssif_info);\r\n} else {\r\nssif_info->waiting_alert = true;\r\nssif_info->retries_left = SSIF_RECV_RETRIES;\r\nssif_info->rtc_us_timer = SSIF_MSG_PART_USEC;\r\nmod_timer(&ssif_info->retry_timer,\r\njiffies + SSIF_MSG_PART_JIFFIES);\r\nipmi_ssif_unlock_cond(ssif_info, flags);\r\n}\r\n}\r\n}\r\nstatic int start_resend(struct ssif_info *ssif_info)\r\n{\r\nint rv;\r\nint command;\r\nssif_info->got_alert = false;\r\nif (ssif_info->data_len > 32) {\r\ncommand = SSIF_IPMI_MULTI_PART_REQUEST_START;\r\nssif_info->multi_data = ssif_info->data;\r\nssif_info->multi_len = ssif_info->data_len;\r\nssif_info->multi_pos = 32;\r\nssif_info->data[0] = 32;\r\n} else {\r\nssif_info->multi_data = NULL;\r\ncommand = SSIF_IPMI_REQUEST;\r\nssif_info->data[0] = ssif_info->data_len;\r\n}\r\nrv = ssif_i2c_send(ssif_info, msg_written_handler, I2C_SMBUS_WRITE,\r\ncommand, ssif_info->data, I2C_SMBUS_BLOCK_DATA);\r\nif (rv && (ssif_info->ssif_debug & SSIF_DEBUG_MSG))\r\npr_info("Error from i2c_non_blocking_op(4)\n");\r\nreturn rv;\r\n}\r\nstatic int start_send(struct ssif_info *ssif_info,\r\nunsigned char *data,\r\nunsigned int len)\r\n{\r\nif (len > IPMI_MAX_MSG_LENGTH)\r\nreturn -E2BIG;\r\nif (len > ssif_info->max_xmit_msg_size)\r\nreturn -E2BIG;\r\nssif_info->retries_left = SSIF_SEND_RETRIES;\r\nmemcpy(ssif_info->data + 1, data, len);\r\nssif_info->data_len = len;\r\nreturn start_resend(ssif_info);\r\n}\r\nstatic void start_next_msg(struct ssif_info *ssif_info, unsigned long *flags)\r\n{\r\nstruct ipmi_smi_msg *msg;\r\nunsigned long oflags;\r\nrestart:\r\nif (!SSIF_IDLE(ssif_info)) {\r\nipmi_ssif_unlock_cond(ssif_info, flags);\r\nreturn;\r\n}\r\nif (!ssif_info->waiting_msg) {\r\nssif_info->curr_msg = NULL;\r\nipmi_ssif_unlock_cond(ssif_info, flags);\r\n} else {\r\nint rv;\r\nssif_info->curr_msg = ssif_info->waiting_msg;\r\nssif_info->waiting_msg = NULL;\r\nipmi_ssif_unlock_cond(ssif_info, flags);\r\nrv = start_send(ssif_info,\r\nssif_info->curr_msg->data,\r\nssif_info->curr_msg->data_size);\r\nif (rv) {\r\nmsg = ssif_info->curr_msg;\r\nssif_info->curr_msg = NULL;\r\nreturn_hosed_msg(ssif_info, msg);\r\nflags = ipmi_ssif_lock_cond(ssif_info, &oflags);\r\ngoto restart;\r\n}\r\n}\r\n}\r\nstatic void sender(void *send_info,\r\nstruct ipmi_smi_msg *msg)\r\n{\r\nstruct ssif_info *ssif_info = (struct ssif_info *) send_info;\r\nunsigned long oflags, *flags;\r\nBUG_ON(ssif_info->waiting_msg);\r\nssif_info->waiting_msg = msg;\r\nflags = ipmi_ssif_lock_cond(ssif_info, &oflags);\r\nstart_next_msg(ssif_info, flags);\r\nif (ssif_info->ssif_debug & SSIF_DEBUG_TIMING) {\r\nstruct timeval t;\r\ndo_gettimeofday(&t);\r\npr_info("**Enqueue %02x %02x: %ld.%6.6ld\n",\r\nmsg->data[0], msg->data[1],\r\n(long) t.tv_sec, (long) t.tv_usec);\r\n}\r\n}\r\nstatic int get_smi_info(void *send_info, struct ipmi_smi_info *data)\r\n{\r\nstruct ssif_info *ssif_info = send_info;\r\ndata->addr_src = ssif_info->addr_source;\r\ndata->dev = &ssif_info->client->dev;\r\ndata->addr_info = ssif_info->addr_info;\r\nget_device(data->dev);\r\nreturn 0;\r\n}\r\nstatic void request_events(void *send_info)\r\n{\r\nstruct ssif_info *ssif_info = (struct ssif_info *) send_info;\r\nunsigned long oflags, *flags;\r\nif (!ssif_info->has_event_buffer)\r\nreturn;\r\nflags = ipmi_ssif_lock_cond(ssif_info, &oflags);\r\nssif_info->req_events = true;\r\nif (SSIF_IDLE(ssif_info))\r\nstart_flag_fetch(ssif_info, flags);\r\nelse {\r\nssif_info->req_flags = true;\r\nipmi_ssif_unlock_cond(ssif_info, flags);\r\n}\r\n}\r\nstatic int inc_usecount(void *send_info)\r\n{\r\nstruct ssif_info *ssif_info = send_info;\r\nif (!i2c_get_adapter(ssif_info->client->adapter->nr))\r\nreturn -ENODEV;\r\ni2c_use_client(ssif_info->client);\r\nreturn 0;\r\n}\r\nstatic void dec_usecount(void *send_info)\r\n{\r\nstruct ssif_info *ssif_info = send_info;\r\ni2c_release_client(ssif_info->client);\r\ni2c_put_adapter(ssif_info->client->adapter);\r\n}\r\nstatic int ssif_start_processing(void *send_info,\r\nipmi_smi_t intf)\r\n{\r\nstruct ssif_info *ssif_info = send_info;\r\nssif_info->intf = intf;\r\nreturn 0;\r\n}\r\nstatic int ssif_remove(struct i2c_client *client)\r\n{\r\nstruct ssif_info *ssif_info = i2c_get_clientdata(client);\r\nint rv;\r\nif (!ssif_info)\r\nreturn 0;\r\nrv = ipmi_unregister_smi(ssif_info->intf);\r\nif (rv) {\r\npr_err(PFX "Unable to unregister device: errno=%d\n", rv);\r\nreturn rv;\r\n}\r\nssif_info->intf = NULL;\r\nwhile (ssif_info->ssif_state != SSIF_NORMAL)\r\nschedule_timeout(1);\r\nssif_info->stopping = true;\r\ndel_timer_sync(&ssif_info->retry_timer);\r\nif (ssif_info->thread) {\r\ncomplete(&ssif_info->wake_thread);\r\nkthread_stop(ssif_info->thread);\r\n}\r\nkfree(ssif_info);\r\nreturn 0;\r\n}\r\nstatic int do_cmd(struct i2c_client *client, int len, unsigned char *msg,\r\nint *resp_len, unsigned char *resp)\r\n{\r\nint retry_cnt;\r\nint ret;\r\nretry_cnt = SSIF_SEND_RETRIES;\r\nretry1:\r\nret = i2c_smbus_write_block_data(client, SSIF_IPMI_REQUEST, len, msg);\r\nif (ret) {\r\nretry_cnt--;\r\nif (retry_cnt > 0)\r\ngoto retry1;\r\nreturn -ENODEV;\r\n}\r\nret = -ENODEV;\r\nretry_cnt = SSIF_RECV_RETRIES;\r\nwhile (retry_cnt > 0) {\r\nret = i2c_smbus_read_block_data(client, SSIF_IPMI_RESPONSE,\r\nresp);\r\nif (ret > 0)\r\nbreak;\r\nmsleep(SSIF_MSG_MSEC);\r\nretry_cnt--;\r\nif (retry_cnt <= 0)\r\nbreak;\r\n}\r\nif (ret > 0) {\r\nif (ret < 3 ||\r\n(resp[0] != (msg[0] | (1 << 2))) ||\r\n(resp[1] != msg[1]))\r\nret = -EINVAL;\r\nelse {\r\n*resp_len = ret;\r\nret = 0;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int ssif_detect(struct i2c_client *client, struct i2c_board_info *info)\r\n{\r\nunsigned char *resp;\r\nunsigned char msg[3];\r\nint rv;\r\nint len;\r\nresp = kmalloc(IPMI_MAX_MSG_LENGTH, GFP_KERNEL);\r\nif (!resp)\r\nreturn -ENOMEM;\r\nmsg[0] = IPMI_NETFN_APP_REQUEST << 2;\r\nmsg[1] = IPMI_GET_DEVICE_ID_CMD;\r\nrv = do_cmd(client, 2, msg, &len, resp);\r\nif (rv)\r\nrv = -ENODEV;\r\nelse\r\nstrlcpy(info->type, DEVICE_NAME, I2C_NAME_SIZE);\r\nkfree(resp);\r\nreturn rv;\r\n}\r\nstatic int smi_type_proc_show(struct seq_file *m, void *v)\r\n{\r\nseq_puts(m, "ssif\n");\r\nreturn 0;\r\n}\r\nstatic int smi_type_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, smi_type_proc_show, inode->i_private);\r\n}\r\nstatic int smi_stats_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct ssif_info *ssif_info = m->private;\r\nseq_printf(m, "sent_messages: %u\n",\r\nssif_get_stat(ssif_info, sent_messages));\r\nseq_printf(m, "sent_messages_parts: %u\n",\r\nssif_get_stat(ssif_info, sent_messages_parts));\r\nseq_printf(m, "send_retries: %u\n",\r\nssif_get_stat(ssif_info, send_retries));\r\nseq_printf(m, "send_errors: %u\n",\r\nssif_get_stat(ssif_info, send_errors));\r\nseq_printf(m, "received_messages: %u\n",\r\nssif_get_stat(ssif_info, received_messages));\r\nseq_printf(m, "received_message_parts: %u\n",\r\nssif_get_stat(ssif_info, received_message_parts));\r\nseq_printf(m, "receive_retries: %u\n",\r\nssif_get_stat(ssif_info, receive_retries));\r\nseq_printf(m, "receive_errors: %u\n",\r\nssif_get_stat(ssif_info, receive_errors));\r\nseq_printf(m, "flag_fetches: %u\n",\r\nssif_get_stat(ssif_info, flag_fetches));\r\nseq_printf(m, "hosed: %u\n",\r\nssif_get_stat(ssif_info, hosed));\r\nseq_printf(m, "events: %u\n",\r\nssif_get_stat(ssif_info, events));\r\nseq_printf(m, "watchdog_pretimeouts: %u\n",\r\nssif_get_stat(ssif_info, watchdog_pretimeouts));\r\nseq_printf(m, "alerts: %u\n",\r\nssif_get_stat(ssif_info, alerts));\r\nreturn 0;\r\n}\r\nstatic int smi_stats_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, smi_stats_proc_show, PDE_DATA(inode));\r\n}\r\nstatic int strcmp_nospace(char *s1, char *s2)\r\n{\r\nwhile (*s1 && *s2) {\r\nwhile (isspace(*s1))\r\ns1++;\r\nwhile (isspace(*s2))\r\ns2++;\r\nif (*s1 > *s2)\r\nreturn 1;\r\nif (*s1 < *s2)\r\nreturn -1;\r\ns1++;\r\ns2++;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct ssif_addr_info *ssif_info_find(unsigned short addr,\r\nchar *adapter_name,\r\nbool match_null_name)\r\n{\r\nstruct ssif_addr_info *info, *found = NULL;\r\nrestart:\r\nlist_for_each_entry(info, &ssif_infos, link) {\r\nif (info->binfo.addr == addr) {\r\nif (info->adapter_name || adapter_name) {\r\nif (!info->adapter_name != !adapter_name) {\r\ncontinue;\r\n}\r\nif (adapter_name &&\r\nstrcmp_nospace(info->adapter_name,\r\nadapter_name))\r\ncontinue;\r\n}\r\nfound = info;\r\nbreak;\r\n}\r\n}\r\nif (!found && match_null_name) {\r\nadapter_name = NULL;\r\nmatch_null_name = false;\r\ngoto restart;\r\n}\r\nreturn found;\r\n}\r\nstatic bool check_acpi(struct ssif_info *ssif_info, struct device *dev)\r\n{\r\n#ifdef CONFIG_ACPI\r\nacpi_handle acpi_handle;\r\nacpi_handle = ACPI_HANDLE(dev);\r\nif (acpi_handle) {\r\nssif_info->addr_source = SI_ACPI;\r\nssif_info->addr_info.acpi_info.acpi_handle = acpi_handle;\r\nreturn true;\r\n}\r\n#endif\r\nreturn false;\r\n}\r\nstatic int ssif_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nunsigned char msg[3];\r\nunsigned char *resp;\r\nstruct ssif_info *ssif_info;\r\nint rv = 0;\r\nint len;\r\nint i;\r\nu8 slave_addr = 0;\r\nstruct ssif_addr_info *addr_info = NULL;\r\nresp = kmalloc(IPMI_MAX_MSG_LENGTH, GFP_KERNEL);\r\nif (!resp)\r\nreturn -ENOMEM;\r\nssif_info = kzalloc(sizeof(*ssif_info), GFP_KERNEL);\r\nif (!ssif_info) {\r\nkfree(resp);\r\nreturn -ENOMEM;\r\n}\r\nif (!check_acpi(ssif_info, &client->dev)) {\r\naddr_info = ssif_info_find(client->addr, client->adapter->name,\r\ntrue);\r\nif (!addr_info) {\r\nssif_info->addr_source = SI_HOTMOD;\r\n} else {\r\nssif_info->addr_source = addr_info->addr_src;\r\nssif_info->ssif_debug = addr_info->debug;\r\nssif_info->addr_info = addr_info->addr_info;\r\nslave_addr = addr_info->slave_addr;\r\n}\r\n}\r\npr_info(PFX "Trying %s-specified SSIF interface at i2c address 0x%x, adapter %s, slave address 0x%x\n",\r\nipmi_addr_src_to_str(ssif_info->addr_source),\r\nclient->addr, client->adapter->name, slave_addr);\r\nmsg[0] = IPMI_NETFN_APP_REQUEST << 2;\r\nmsg[1] = IPMI_GET_DEVICE_ID_CMD;\r\nrv = do_cmd(client, 2, msg, &len, resp);\r\nif (rv)\r\ngoto out;\r\nrv = ipmi_demangle_device_id(resp, len, &ssif_info->device_id);\r\nif (rv)\r\ngoto out;\r\nssif_info->client = client;\r\ni2c_set_clientdata(client, ssif_info);\r\nmsg[0] = IPMI_NETFN_APP_REQUEST << 2;\r\nmsg[1] = IPMI_GET_SYSTEM_INTERFACE_CAPABILITIES_CMD;\r\nmsg[2] = 0;\r\nrv = do_cmd(client, 3, msg, &len, resp);\r\nif (!rv && (len >= 3) && (resp[2] == 0)) {\r\nif (len < 7) {\r\nif (ssif_dbg_probe)\r\npr_info(PFX "SSIF info too short: %d\n", len);\r\ngoto no_support;\r\n}\r\nssif_info->max_xmit_msg_size = resp[5];\r\nssif_info->max_recv_msg_size = resp[6];\r\nssif_info->multi_support = (resp[4] >> 6) & 0x3;\r\nssif_info->supports_pec = (resp[4] >> 3) & 0x1;\r\nswitch (ssif_info->multi_support) {\r\ncase SSIF_NO_MULTI:\r\nif (ssif_info->max_xmit_msg_size > 32)\r\nssif_info->max_xmit_msg_size = 32;\r\nif (ssif_info->max_recv_msg_size > 32)\r\nssif_info->max_recv_msg_size = 32;\r\nbreak;\r\ncase SSIF_MULTI_2_PART:\r\nif (ssif_info->max_xmit_msg_size > 63)\r\nssif_info->max_xmit_msg_size = 63;\r\nif (ssif_info->max_recv_msg_size > 62)\r\nssif_info->max_recv_msg_size = 62;\r\nbreak;\r\ncase SSIF_MULTI_n_PART:\r\nif (ssif_info->max_xmit_msg_size > 63)\r\nssif_info->max_xmit_msg_size = 63;\r\nbreak;\r\ndefault:\r\ngoto no_support;\r\n}\r\n} else {\r\nno_support:\r\npr_info(PFX "Error fetching SSIF: %d %d %2.2x, your system probably doesn't support this command so using defaults\n",\r\nrv, len, resp[2]);\r\nssif_info->max_xmit_msg_size = 32;\r\nssif_info->max_recv_msg_size = 32;\r\nssif_info->multi_support = SSIF_NO_MULTI;\r\nssif_info->supports_pec = 0;\r\n}\r\nmsg[0] = IPMI_NETFN_APP_REQUEST << 2;\r\nmsg[1] = IPMI_CLEAR_MSG_FLAGS_CMD;\r\nmsg[2] = WDT_PRE_TIMEOUT_INT;\r\nrv = do_cmd(client, 3, msg, &len, resp);\r\nif (rv || (len < 3) || (resp[2] != 0))\r\npr_warn(PFX "Unable to clear message flags: %d %d %2.2x\n",\r\nrv, len, resp[2]);\r\nmsg[0] = IPMI_NETFN_APP_REQUEST << 2;\r\nmsg[1] = IPMI_GET_BMC_GLOBAL_ENABLES_CMD;\r\nrv = do_cmd(client, 2, msg, &len, resp);\r\nif (rv || (len < 4) || (resp[2] != 0)) {\r\npr_warn(PFX "Error getting global enables: %d %d %2.2x\n",\r\nrv, len, resp[2]);\r\nrv = 0;\r\ngoto found;\r\n}\r\nssif_info->global_enables = resp[3];\r\nif (resp[3] & IPMI_BMC_EVT_MSG_BUFF) {\r\nssif_info->has_event_buffer = true;\r\ngoto found;\r\n}\r\nmsg[0] = IPMI_NETFN_APP_REQUEST << 2;\r\nmsg[1] = IPMI_SET_BMC_GLOBAL_ENABLES_CMD;\r\nmsg[2] = ssif_info->global_enables | IPMI_BMC_EVT_MSG_BUFF;\r\nrv = do_cmd(client, 3, msg, &len, resp);\r\nif (rv || (len < 2)) {\r\npr_warn(PFX "Error setting global enables: %d %d %2.2x\n",\r\nrv, len, resp[2]);\r\nrv = 0;\r\ngoto found;\r\n}\r\nif (resp[2] == 0) {\r\nssif_info->has_event_buffer = true;\r\nssif_info->global_enables |= IPMI_BMC_EVT_MSG_BUFF;\r\n}\r\nmsg[0] = IPMI_NETFN_APP_REQUEST << 2;\r\nmsg[1] = IPMI_SET_BMC_GLOBAL_ENABLES_CMD;\r\nmsg[2] = ssif_info->global_enables | IPMI_BMC_RCV_MSG_INTR;\r\nrv = do_cmd(client, 3, msg, &len, resp);\r\nif (rv || (len < 2)) {\r\npr_warn(PFX "Error setting global enables: %d %d %2.2x\n",\r\nrv, len, resp[2]);\r\nrv = 0;\r\ngoto found;\r\n}\r\nif (resp[2] == 0) {\r\nssif_info->supports_alert = true;\r\nssif_info->global_enables |= IPMI_BMC_RCV_MSG_INTR;\r\n}\r\nfound:\r\nssif_info->intf_num = atomic_inc_return(&next_intf);\r\nif (ssif_dbg_probe) {\r\npr_info("ssif_probe: i2c_probe found device at i2c address %x\n",\r\nclient->addr);\r\n}\r\nspin_lock_init(&ssif_info->lock);\r\nssif_info->ssif_state = SSIF_NORMAL;\r\ninit_timer(&ssif_info->retry_timer);\r\nssif_info->retry_timer.data = (unsigned long) ssif_info;\r\nssif_info->retry_timer.function = retry_timeout;\r\nfor (i = 0; i < SSIF_NUM_STATS; i++)\r\natomic_set(&ssif_info->stats[i], 0);\r\nif (ssif_info->supports_pec)\r\nssif_info->client->flags |= I2C_CLIENT_PEC;\r\nssif_info->handlers.owner = THIS_MODULE;\r\nssif_info->handlers.start_processing = ssif_start_processing;\r\nssif_info->handlers.get_smi_info = get_smi_info;\r\nssif_info->handlers.sender = sender;\r\nssif_info->handlers.request_events = request_events;\r\nssif_info->handlers.inc_usecount = inc_usecount;\r\nssif_info->handlers.dec_usecount = dec_usecount;\r\n{\r\nunsigned int thread_num;\r\nthread_num = ((ssif_info->client->adapter->nr << 8) |\r\nssif_info->client->addr);\r\ninit_completion(&ssif_info->wake_thread);\r\nssif_info->thread = kthread_run(ipmi_ssif_thread, ssif_info,\r\n"kssif%4.4x", thread_num);\r\nif (IS_ERR(ssif_info->thread)) {\r\nrv = PTR_ERR(ssif_info->thread);\r\ndev_notice(&ssif_info->client->dev,\r\n"Could not start kernel thread: error %d\n",\r\nrv);\r\ngoto out;\r\n}\r\n}\r\nrv = ipmi_register_smi(&ssif_info->handlers,\r\nssif_info,\r\n&ssif_info->device_id,\r\n&ssif_info->client->dev,\r\nslave_addr);\r\nif (rv) {\r\npr_err(PFX "Unable to register device: error %d\n", rv);\r\ngoto out;\r\n}\r\nrv = ipmi_smi_add_proc_entry(ssif_info->intf, "type",\r\n&smi_type_proc_ops,\r\nssif_info);\r\nif (rv) {\r\npr_err(PFX "Unable to create proc entry: %d\n", rv);\r\ngoto out_err_unreg;\r\n}\r\nrv = ipmi_smi_add_proc_entry(ssif_info->intf, "ssif_stats",\r\n&smi_stats_proc_ops,\r\nssif_info);\r\nif (rv) {\r\npr_err(PFX "Unable to create proc entry: %d\n", rv);\r\ngoto out_err_unreg;\r\n}\r\nout:\r\nif (rv)\r\nkfree(ssif_info);\r\nkfree(resp);\r\nreturn rv;\r\nout_err_unreg:\r\nipmi_unregister_smi(ssif_info->intf);\r\ngoto out;\r\n}\r\nstatic int ssif_adapter_handler(struct device *adev, void *opaque)\r\n{\r\nstruct ssif_addr_info *addr_info = opaque;\r\nif (adev->type != &i2c_adapter_type)\r\nreturn 0;\r\ni2c_new_device(to_i2c_adapter(adev), &addr_info->binfo);\r\nif (!addr_info->adapter_name)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int new_ssif_client(int addr, char *adapter_name,\r\nint debug, int slave_addr,\r\nenum ipmi_addr_src addr_src)\r\n{\r\nstruct ssif_addr_info *addr_info;\r\nint rv = 0;\r\nmutex_lock(&ssif_infos_mutex);\r\nif (ssif_info_find(addr, adapter_name, false)) {\r\nrv = -EEXIST;\r\ngoto out_unlock;\r\n}\r\naddr_info = kzalloc(sizeof(*addr_info), GFP_KERNEL);\r\nif (!addr_info) {\r\nrv = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\nif (adapter_name) {\r\naddr_info->adapter_name = kstrdup(adapter_name, GFP_KERNEL);\r\nif (!addr_info->adapter_name) {\r\nkfree(addr_info);\r\nrv = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\n}\r\nstrncpy(addr_info->binfo.type, DEVICE_NAME,\r\nsizeof(addr_info->binfo.type));\r\naddr_info->binfo.addr = addr;\r\naddr_info->binfo.platform_data = addr_info;\r\naddr_info->debug = debug;\r\naddr_info->slave_addr = slave_addr;\r\naddr_info->addr_src = addr_src;\r\nlist_add_tail(&addr_info->link, &ssif_infos);\r\nif (initialized)\r\ni2c_for_each_dev(addr_info, ssif_adapter_handler);\r\nout_unlock:\r\nmutex_unlock(&ssif_infos_mutex);\r\nreturn rv;\r\n}\r\nstatic void free_ssif_clients(void)\r\n{\r\nstruct ssif_addr_info *info, *tmp;\r\nmutex_lock(&ssif_infos_mutex);\r\nlist_for_each_entry_safe(info, tmp, &ssif_infos, link) {\r\nlist_del(&info->link);\r\nkfree(info->adapter_name);\r\nkfree(info);\r\n}\r\nmutex_unlock(&ssif_infos_mutex);\r\n}\r\nstatic unsigned short *ssif_address_list(void)\r\n{\r\nstruct ssif_addr_info *info;\r\nunsigned int count = 0, i;\r\nunsigned short *address_list;\r\nlist_for_each_entry(info, &ssif_infos, link)\r\ncount++;\r\naddress_list = kzalloc(sizeof(*address_list) * (count + 1), GFP_KERNEL);\r\nif (!address_list)\r\nreturn NULL;\r\ni = 0;\r\nlist_for_each_entry(info, &ssif_infos, link) {\r\nunsigned short addr = info->binfo.addr;\r\nint j;\r\nfor (j = 0; j < i; j++) {\r\nif (address_list[j] == addr)\r\ngoto skip_addr;\r\n}\r\naddress_list[i] = addr;\r\nskip_addr:\r\ni++;\r\n}\r\naddress_list[i] = I2C_CLIENT_END;\r\nreturn address_list;\r\n}\r\nstatic int try_init_spmi(struct SPMITable *spmi)\r\n{\r\nunsigned short myaddr;\r\nif (num_addrs >= MAX_SSIF_BMCS)\r\nreturn -1;\r\nif (spmi->IPMIlegacy != 1) {\r\npr_warn("IPMI: Bad SPMI legacy: %d\n", spmi->IPMIlegacy);\r\nreturn -ENODEV;\r\n}\r\nif (spmi->InterfaceType != 4)\r\nreturn -ENODEV;\r\nif (spmi->addr.space_id != ACPI_ADR_SPACE_SMBUS) {\r\npr_warn(PFX "Invalid ACPI SSIF I/O Address type: %d\n",\r\nspmi->addr.space_id);\r\nreturn -EIO;\r\n}\r\nmyaddr = spmi->addr.address >> 1;\r\nreturn new_ssif_client(myaddr, NULL, 0, 0, SI_SPMI);\r\n}\r\nstatic void spmi_find_bmc(void)\r\n{\r\nacpi_status status;\r\nstruct SPMITable *spmi;\r\nint i;\r\nif (acpi_disabled)\r\nreturn;\r\nif (acpi_failure)\r\nreturn;\r\nfor (i = 0; ; i++) {\r\nstatus = acpi_get_table(ACPI_SIG_SPMI, i+1,\r\n(struct acpi_table_header **)&spmi);\r\nif (status != AE_OK)\r\nreturn;\r\ntry_init_spmi(spmi);\r\n}\r\n}\r\nstatic void spmi_find_bmc(void) { }\r\nstatic int decode_dmi(const struct dmi_device *dmi_dev)\r\n{\r\nstruct dmi_header *dm = dmi_dev->device_data;\r\nu8 *data = (u8 *) dm;\r\nu8 len = dm->length;\r\nunsigned short myaddr;\r\nint slave_addr;\r\nif (num_addrs >= MAX_SSIF_BMCS)\r\nreturn -1;\r\nif (len < 9)\r\nreturn -1;\r\nif (data[0x04] != 4)\r\nreturn -1;\r\nif ((data[8] >> 1) == 0) {\r\nmyaddr = data[6] >> 1;\r\nslave_addr = 0;\r\n} else {\r\nmyaddr = data[8] >> 1;\r\nslave_addr = data[6];\r\n}\r\nreturn new_ssif_client(myaddr, NULL, 0, 0, SI_SMBIOS);\r\n}\r\nstatic void dmi_iterator(void)\r\n{\r\nconst struct dmi_device *dev = NULL;\r\nwhile ((dev = dmi_find_device(DMI_DEV_TYPE_IPMI, NULL, dev)))\r\ndecode_dmi(dev);\r\n}\r\nstatic void dmi_iterator(void) { }\r\nstatic int init_ipmi_ssif(void)\r\n{\r\nint i;\r\nint rv;\r\nif (initialized)\r\nreturn 0;\r\npr_info("IPMI SSIF Interface driver\n");\r\nfor (i = 0; i < num_addrs; i++) {\r\nrv = new_ssif_client(addr[i], adapter_name[i],\r\ndbg[i], slave_addrs[i],\r\nSI_HARDCODED);\r\nif (rv)\r\npr_err(PFX\r\n"Couldn't add hardcoded device at addr 0x%x\n",\r\naddr[i]);\r\n}\r\nif (ssif_tryacpi)\r\nssif_i2c_driver.driver.acpi_match_table =\r\nACPI_PTR(ssif_acpi_match);\r\nif (ssif_trydmi)\r\ndmi_iterator();\r\nif (ssif_tryacpi)\r\nspmi_find_bmc();\r\nssif_i2c_driver.address_list = ssif_address_list();\r\nrv = i2c_add_driver(&ssif_i2c_driver);\r\nif (!rv)\r\ninitialized = true;\r\nreturn rv;\r\n}\r\nstatic void cleanup_ipmi_ssif(void)\r\n{\r\nif (!initialized)\r\nreturn;\r\ninitialized = false;\r\ni2c_del_driver(&ssif_i2c_driver);\r\nfree_ssif_clients();\r\n}
