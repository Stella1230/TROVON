static struct bpf_map *htab_map_alloc(union bpf_attr *attr)\r\n{\r\nstruct bpf_htab *htab;\r\nint err, i;\r\nhtab = kzalloc(sizeof(*htab), GFP_USER);\r\nif (!htab)\r\nreturn ERR_PTR(-ENOMEM);\r\nhtab->map.key_size = attr->key_size;\r\nhtab->map.value_size = attr->value_size;\r\nhtab->map.max_entries = attr->max_entries;\r\nerr = -EINVAL;\r\nif (htab->map.max_entries == 0 || htab->map.key_size == 0 ||\r\nhtab->map.value_size == 0)\r\ngoto free_htab;\r\nhtab->n_buckets = roundup_pow_of_two(htab->map.max_entries);\r\nerr = -E2BIG;\r\nif (htab->map.key_size > MAX_BPF_STACK)\r\ngoto free_htab;\r\nerr = -ENOMEM;\r\nif (htab->n_buckets == 0 ||\r\nhtab->n_buckets > U32_MAX / sizeof(struct hlist_head))\r\ngoto free_htab;\r\nhtab->buckets = kmalloc_array(htab->n_buckets, sizeof(struct hlist_head),\r\nGFP_USER | __GFP_NOWARN);\r\nif (!htab->buckets) {\r\nhtab->buckets = vmalloc(htab->n_buckets * sizeof(struct hlist_head));\r\nif (!htab->buckets)\r\ngoto free_htab;\r\n}\r\nfor (i = 0; i < htab->n_buckets; i++)\r\nINIT_HLIST_HEAD(&htab->buckets[i]);\r\nspin_lock_init(&htab->lock);\r\nhtab->count = 0;\r\nhtab->elem_size = sizeof(struct htab_elem) +\r\nround_up(htab->map.key_size, 8) +\r\nhtab->map.value_size;\r\nreturn &htab->map;\r\nfree_htab:\r\nkfree(htab);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic inline u32 htab_map_hash(const void *key, u32 key_len)\r\n{\r\nreturn jhash(key, key_len, 0);\r\n}\r\nstatic inline struct hlist_head *select_bucket(struct bpf_htab *htab, u32 hash)\r\n{\r\nreturn &htab->buckets[hash & (htab->n_buckets - 1)];\r\n}\r\nstatic struct htab_elem *lookup_elem_raw(struct hlist_head *head, u32 hash,\r\nvoid *key, u32 key_size)\r\n{\r\nstruct htab_elem *l;\r\nhlist_for_each_entry_rcu(l, head, hash_node)\r\nif (l->hash == hash && !memcmp(&l->key, key, key_size))\r\nreturn l;\r\nreturn NULL;\r\n}\r\nstatic void *htab_map_lookup_elem(struct bpf_map *map, void *key)\r\n{\r\nstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\r\nstruct hlist_head *head;\r\nstruct htab_elem *l;\r\nu32 hash, key_size;\r\nWARN_ON_ONCE(!rcu_read_lock_held());\r\nkey_size = map->key_size;\r\nhash = htab_map_hash(key, key_size);\r\nhead = select_bucket(htab, hash);\r\nl = lookup_elem_raw(head, hash, key, key_size);\r\nif (l)\r\nreturn l->key + round_up(map->key_size, 8);\r\nreturn NULL;\r\n}\r\nstatic int htab_map_get_next_key(struct bpf_map *map, void *key, void *next_key)\r\n{\r\nstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\r\nstruct hlist_head *head;\r\nstruct htab_elem *l, *next_l;\r\nu32 hash, key_size;\r\nint i;\r\nWARN_ON_ONCE(!rcu_read_lock_held());\r\nkey_size = map->key_size;\r\nhash = htab_map_hash(key, key_size);\r\nhead = select_bucket(htab, hash);\r\nl = lookup_elem_raw(head, hash, key, key_size);\r\nif (!l) {\r\ni = 0;\r\ngoto find_first_elem;\r\n}\r\nnext_l = hlist_entry_safe(rcu_dereference_raw(hlist_next_rcu(&l->hash_node)),\r\nstruct htab_elem, hash_node);\r\nif (next_l) {\r\nmemcpy(next_key, next_l->key, key_size);\r\nreturn 0;\r\n}\r\ni = hash & (htab->n_buckets - 1);\r\ni++;\r\nfind_first_elem:\r\nfor (; i < htab->n_buckets; i++) {\r\nhead = select_bucket(htab, i);\r\nnext_l = hlist_entry_safe(rcu_dereference_raw(hlist_first_rcu(head)),\r\nstruct htab_elem, hash_node);\r\nif (next_l) {\r\nmemcpy(next_key, next_l->key, key_size);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic int htab_map_update_elem(struct bpf_map *map, void *key, void *value,\r\nu64 map_flags)\r\n{\r\nstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\r\nstruct htab_elem *l_new, *l_old;\r\nstruct hlist_head *head;\r\nunsigned long flags;\r\nu32 key_size;\r\nint ret;\r\nif (map_flags > BPF_EXIST)\r\nreturn -EINVAL;\r\nWARN_ON_ONCE(!rcu_read_lock_held());\r\nl_new = kmalloc(htab->elem_size, GFP_ATOMIC);\r\nif (!l_new)\r\nreturn -ENOMEM;\r\nkey_size = map->key_size;\r\nmemcpy(l_new->key, key, key_size);\r\nmemcpy(l_new->key + round_up(key_size, 8), value, map->value_size);\r\nl_new->hash = htab_map_hash(l_new->key, key_size);\r\nspin_lock_irqsave(&htab->lock, flags);\r\nhead = select_bucket(htab, l_new->hash);\r\nl_old = lookup_elem_raw(head, l_new->hash, key, key_size);\r\nif (!l_old && unlikely(htab->count >= map->max_entries)) {\r\nret = -E2BIG;\r\ngoto err;\r\n}\r\nif (l_old && map_flags == BPF_NOEXIST) {\r\nret = -EEXIST;\r\ngoto err;\r\n}\r\nif (!l_old && map_flags == BPF_EXIST) {\r\nret = -ENOENT;\r\ngoto err;\r\n}\r\nhlist_add_head_rcu(&l_new->hash_node, head);\r\nif (l_old) {\r\nhlist_del_rcu(&l_old->hash_node);\r\nkfree_rcu(l_old, rcu);\r\n} else {\r\nhtab->count++;\r\n}\r\nspin_unlock_irqrestore(&htab->lock, flags);\r\nreturn 0;\r\nerr:\r\nspin_unlock_irqrestore(&htab->lock, flags);\r\nkfree(l_new);\r\nreturn ret;\r\n}\r\nstatic int htab_map_delete_elem(struct bpf_map *map, void *key)\r\n{\r\nstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\r\nstruct hlist_head *head;\r\nstruct htab_elem *l;\r\nunsigned long flags;\r\nu32 hash, key_size;\r\nint ret = -ENOENT;\r\nWARN_ON_ONCE(!rcu_read_lock_held());\r\nkey_size = map->key_size;\r\nhash = htab_map_hash(key, key_size);\r\nspin_lock_irqsave(&htab->lock, flags);\r\nhead = select_bucket(htab, hash);\r\nl = lookup_elem_raw(head, hash, key, key_size);\r\nif (l) {\r\nhlist_del_rcu(&l->hash_node);\r\nhtab->count--;\r\nkfree_rcu(l, rcu);\r\nret = 0;\r\n}\r\nspin_unlock_irqrestore(&htab->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void delete_all_elements(struct bpf_htab *htab)\r\n{\r\nint i;\r\nfor (i = 0; i < htab->n_buckets; i++) {\r\nstruct hlist_head *head = select_bucket(htab, i);\r\nstruct hlist_node *n;\r\nstruct htab_elem *l;\r\nhlist_for_each_entry_safe(l, n, head, hash_node) {\r\nhlist_del_rcu(&l->hash_node);\r\nhtab->count--;\r\nkfree(l);\r\n}\r\n}\r\n}\r\nstatic void htab_map_free(struct bpf_map *map)\r\n{\r\nstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\r\nsynchronize_rcu();\r\ndelete_all_elements(htab);\r\nkvfree(htab->buckets);\r\nkfree(htab);\r\n}\r\nstatic int __init register_htab_map(void)\r\n{\r\nbpf_register_map_type(&htab_type);\r\nreturn 0;\r\n}
