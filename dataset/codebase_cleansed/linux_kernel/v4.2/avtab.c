static inline int avtab_hash(struct avtab_key *keyp, u32 mask)\r\n{\r\nstatic const u32 c1 = 0xcc9e2d51;\r\nstatic const u32 c2 = 0x1b873593;\r\nstatic const u32 r1 = 15;\r\nstatic const u32 r2 = 13;\r\nstatic const u32 m = 5;\r\nstatic const u32 n = 0xe6546b64;\r\nu32 hash = 0;\r\n#define mix(input) { \\r\nu32 v = input; \\r\nv *= c1; \\r\nv = (v << r1) | (v >> (32 - r1)); \\r\nv *= c2; \\r\nhash ^= v; \\r\nhash = (hash << r2) | (hash >> (32 - r2)); \\r\nhash = hash * m + n; \\r\n}\r\nmix(keyp->target_class);\r\nmix(keyp->target_type);\r\nmix(keyp->source_type);\r\n#undef mix\r\nhash ^= hash >> 16;\r\nhash *= 0x85ebca6b;\r\nhash ^= hash >> 13;\r\nhash *= 0xc2b2ae35;\r\nhash ^= hash >> 16;\r\nreturn hash & mask;\r\n}\r\nstatic struct avtab_node*\r\navtab_insert_node(struct avtab *h, int hvalue,\r\nstruct avtab_node *prev, struct avtab_node *cur,\r\nstruct avtab_key *key, struct avtab_datum *datum)\r\n{\r\nstruct avtab_node *newnode;\r\nnewnode = kmem_cache_zalloc(avtab_node_cachep, GFP_KERNEL);\r\nif (newnode == NULL)\r\nreturn NULL;\r\nnewnode->key = *key;\r\nnewnode->datum = *datum;\r\nif (prev) {\r\nnewnode->next = prev->next;\r\nprev->next = newnode;\r\n} else {\r\nnewnode->next = flex_array_get_ptr(h->htable, hvalue);\r\nif (flex_array_put_ptr(h->htable, hvalue, newnode,\r\nGFP_KERNEL|__GFP_ZERO)) {\r\nkmem_cache_free(avtab_node_cachep, newnode);\r\nreturn NULL;\r\n}\r\n}\r\nh->nel++;\r\nreturn newnode;\r\n}\r\nstatic int avtab_insert(struct avtab *h, struct avtab_key *key, struct avtab_datum *datum)\r\n{\r\nint hvalue;\r\nstruct avtab_node *prev, *cur, *newnode;\r\nu16 specified = key->specified & ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\r\nif (!h || !h->htable)\r\nreturn -EINVAL;\r\nhvalue = avtab_hash(key, h->mask);\r\nfor (prev = NULL, cur = flex_array_get_ptr(h->htable, hvalue);\r\ncur;\r\nprev = cur, cur = cur->next) {\r\nif (key->source_type == cur->key.source_type &&\r\nkey->target_type == cur->key.target_type &&\r\nkey->target_class == cur->key.target_class &&\r\n(specified & cur->key.specified))\r\nreturn -EEXIST;\r\nif (key->source_type < cur->key.source_type)\r\nbreak;\r\nif (key->source_type == cur->key.source_type &&\r\nkey->target_type < cur->key.target_type)\r\nbreak;\r\nif (key->source_type == cur->key.source_type &&\r\nkey->target_type == cur->key.target_type &&\r\nkey->target_class < cur->key.target_class)\r\nbreak;\r\n}\r\nnewnode = avtab_insert_node(h, hvalue, prev, cur, key, datum);\r\nif (!newnode)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstruct avtab_node *\r\navtab_insert_nonunique(struct avtab *h, struct avtab_key *key, struct avtab_datum *datum)\r\n{\r\nint hvalue;\r\nstruct avtab_node *prev, *cur;\r\nu16 specified = key->specified & ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\r\nif (!h || !h->htable)\r\nreturn NULL;\r\nhvalue = avtab_hash(key, h->mask);\r\nfor (prev = NULL, cur = flex_array_get_ptr(h->htable, hvalue);\r\ncur;\r\nprev = cur, cur = cur->next) {\r\nif (key->source_type == cur->key.source_type &&\r\nkey->target_type == cur->key.target_type &&\r\nkey->target_class == cur->key.target_class &&\r\n(specified & cur->key.specified))\r\nbreak;\r\nif (key->source_type < cur->key.source_type)\r\nbreak;\r\nif (key->source_type == cur->key.source_type &&\r\nkey->target_type < cur->key.target_type)\r\nbreak;\r\nif (key->source_type == cur->key.source_type &&\r\nkey->target_type == cur->key.target_type &&\r\nkey->target_class < cur->key.target_class)\r\nbreak;\r\n}\r\nreturn avtab_insert_node(h, hvalue, prev, cur, key, datum);\r\n}\r\nstruct avtab_datum *avtab_search(struct avtab *h, struct avtab_key *key)\r\n{\r\nint hvalue;\r\nstruct avtab_node *cur;\r\nu16 specified = key->specified & ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\r\nif (!h || !h->htable)\r\nreturn NULL;\r\nhvalue = avtab_hash(key, h->mask);\r\nfor (cur = flex_array_get_ptr(h->htable, hvalue); cur;\r\ncur = cur->next) {\r\nif (key->source_type == cur->key.source_type &&\r\nkey->target_type == cur->key.target_type &&\r\nkey->target_class == cur->key.target_class &&\r\n(specified & cur->key.specified))\r\nreturn &cur->datum;\r\nif (key->source_type < cur->key.source_type)\r\nbreak;\r\nif (key->source_type == cur->key.source_type &&\r\nkey->target_type < cur->key.target_type)\r\nbreak;\r\nif (key->source_type == cur->key.source_type &&\r\nkey->target_type == cur->key.target_type &&\r\nkey->target_class < cur->key.target_class)\r\nbreak;\r\n}\r\nreturn NULL;\r\n}\r\nstruct avtab_node*\r\navtab_search_node(struct avtab *h, struct avtab_key *key)\r\n{\r\nint hvalue;\r\nstruct avtab_node *cur;\r\nu16 specified = key->specified & ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\r\nif (!h || !h->htable)\r\nreturn NULL;\r\nhvalue = avtab_hash(key, h->mask);\r\nfor (cur = flex_array_get_ptr(h->htable, hvalue); cur;\r\ncur = cur->next) {\r\nif (key->source_type == cur->key.source_type &&\r\nkey->target_type == cur->key.target_type &&\r\nkey->target_class == cur->key.target_class &&\r\n(specified & cur->key.specified))\r\nreturn cur;\r\nif (key->source_type < cur->key.source_type)\r\nbreak;\r\nif (key->source_type == cur->key.source_type &&\r\nkey->target_type < cur->key.target_type)\r\nbreak;\r\nif (key->source_type == cur->key.source_type &&\r\nkey->target_type == cur->key.target_type &&\r\nkey->target_class < cur->key.target_class)\r\nbreak;\r\n}\r\nreturn NULL;\r\n}\r\nstruct avtab_node*\r\navtab_search_node_next(struct avtab_node *node, int specified)\r\n{\r\nstruct avtab_node *cur;\r\nif (!node)\r\nreturn NULL;\r\nspecified &= ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\r\nfor (cur = node->next; cur; cur = cur->next) {\r\nif (node->key.source_type == cur->key.source_type &&\r\nnode->key.target_type == cur->key.target_type &&\r\nnode->key.target_class == cur->key.target_class &&\r\n(specified & cur->key.specified))\r\nreturn cur;\r\nif (node->key.source_type < cur->key.source_type)\r\nbreak;\r\nif (node->key.source_type == cur->key.source_type &&\r\nnode->key.target_type < cur->key.target_type)\r\nbreak;\r\nif (node->key.source_type == cur->key.source_type &&\r\nnode->key.target_type == cur->key.target_type &&\r\nnode->key.target_class < cur->key.target_class)\r\nbreak;\r\n}\r\nreturn NULL;\r\n}\r\nvoid avtab_destroy(struct avtab *h)\r\n{\r\nint i;\r\nstruct avtab_node *cur, *temp;\r\nif (!h || !h->htable)\r\nreturn;\r\nfor (i = 0; i < h->nslot; i++) {\r\ncur = flex_array_get_ptr(h->htable, i);\r\nwhile (cur) {\r\ntemp = cur;\r\ncur = cur->next;\r\nkmem_cache_free(avtab_node_cachep, temp);\r\n}\r\n}\r\nflex_array_free(h->htable);\r\nh->htable = NULL;\r\nh->nslot = 0;\r\nh->mask = 0;\r\n}\r\nint avtab_init(struct avtab *h)\r\n{\r\nh->htable = NULL;\r\nh->nel = 0;\r\nreturn 0;\r\n}\r\nint avtab_alloc(struct avtab *h, u32 nrules)\r\n{\r\nu32 mask = 0;\r\nu32 shift = 0;\r\nu32 work = nrules;\r\nu32 nslot = 0;\r\nif (nrules == 0)\r\ngoto avtab_alloc_out;\r\nwhile (work) {\r\nwork = work >> 1;\r\nshift++;\r\n}\r\nif (shift > 2)\r\nshift = shift - 2;\r\nnslot = 1 << shift;\r\nif (nslot > MAX_AVTAB_HASH_BUCKETS)\r\nnslot = MAX_AVTAB_HASH_BUCKETS;\r\nmask = nslot - 1;\r\nh->htable = flex_array_alloc(sizeof(struct avtab_node *), nslot,\r\nGFP_KERNEL | __GFP_ZERO);\r\nif (!h->htable)\r\nreturn -ENOMEM;\r\navtab_alloc_out:\r\nh->nel = 0;\r\nh->nslot = nslot;\r\nh->mask = mask;\r\nprintk(KERN_DEBUG "SELinux: %d avtab hash slots, %d rules.\n",\r\nh->nslot, nrules);\r\nreturn 0;\r\n}\r\nvoid avtab_hash_eval(struct avtab *h, char *tag)\r\n{\r\nint i, chain_len, slots_used, max_chain_len;\r\nunsigned long long chain2_len_sum;\r\nstruct avtab_node *cur;\r\nslots_used = 0;\r\nmax_chain_len = 0;\r\nchain2_len_sum = 0;\r\nfor (i = 0; i < h->nslot; i++) {\r\ncur = flex_array_get_ptr(h->htable, i);\r\nif (cur) {\r\nslots_used++;\r\nchain_len = 0;\r\nwhile (cur) {\r\nchain_len++;\r\ncur = cur->next;\r\n}\r\nif (chain_len > max_chain_len)\r\nmax_chain_len = chain_len;\r\nchain2_len_sum += chain_len * chain_len;\r\n}\r\n}\r\nprintk(KERN_DEBUG "SELinux: %s: %d entries and %d/%d buckets used, "\r\n"longest chain length %d sum of chain length^2 %llu\n",\r\ntag, h->nel, slots_used, h->nslot, max_chain_len,\r\nchain2_len_sum);\r\n}\r\nint avtab_read_item(struct avtab *a, void *fp, struct policydb *pol,\r\nint (*insertf)(struct avtab *a, struct avtab_key *k,\r\nstruct avtab_datum *d, void *p),\r\nvoid *p)\r\n{\r\n__le16 buf16[4];\r\nu16 enabled;\r\n__le32 buf32[7];\r\nu32 items, items2, val, vers = pol->policyvers;\r\nstruct avtab_key key;\r\nstruct avtab_datum datum;\r\nint i, rc;\r\nunsigned set;\r\nmemset(&key, 0, sizeof(struct avtab_key));\r\nmemset(&datum, 0, sizeof(struct avtab_datum));\r\nif (vers < POLICYDB_VERSION_AVTAB) {\r\nrc = next_entry(buf32, fp, sizeof(u32));\r\nif (rc) {\r\nprintk(KERN_ERR "SELinux: avtab: truncated entry\n");\r\nreturn rc;\r\n}\r\nitems2 = le32_to_cpu(buf32[0]);\r\nif (items2 > ARRAY_SIZE(buf32)) {\r\nprintk(KERN_ERR "SELinux: avtab: entry overflow\n");\r\nreturn -EINVAL;\r\n}\r\nrc = next_entry(buf32, fp, sizeof(u32)*items2);\r\nif (rc) {\r\nprintk(KERN_ERR "SELinux: avtab: truncated entry\n");\r\nreturn rc;\r\n}\r\nitems = 0;\r\nval = le32_to_cpu(buf32[items++]);\r\nkey.source_type = (u16)val;\r\nif (key.source_type != val) {\r\nprintk(KERN_ERR "SELinux: avtab: truncated source type\n");\r\nreturn -EINVAL;\r\n}\r\nval = le32_to_cpu(buf32[items++]);\r\nkey.target_type = (u16)val;\r\nif (key.target_type != val) {\r\nprintk(KERN_ERR "SELinux: avtab: truncated target type\n");\r\nreturn -EINVAL;\r\n}\r\nval = le32_to_cpu(buf32[items++]);\r\nkey.target_class = (u16)val;\r\nif (key.target_class != val) {\r\nprintk(KERN_ERR "SELinux: avtab: truncated target class\n");\r\nreturn -EINVAL;\r\n}\r\nval = le32_to_cpu(buf32[items++]);\r\nenabled = (val & AVTAB_ENABLED_OLD) ? AVTAB_ENABLED : 0;\r\nif (!(val & (AVTAB_AV | AVTAB_TYPE))) {\r\nprintk(KERN_ERR "SELinux: avtab: null entry\n");\r\nreturn -EINVAL;\r\n}\r\nif ((val & AVTAB_AV) &&\r\n(val & AVTAB_TYPE)) {\r\nprintk(KERN_ERR "SELinux: avtab: entry has both access vectors and types\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(spec_order); i++) {\r\nif (val & spec_order[i]) {\r\nkey.specified = spec_order[i] | enabled;\r\ndatum.data = le32_to_cpu(buf32[items++]);\r\nrc = insertf(a, &key, &datum, p);\r\nif (rc)\r\nreturn rc;\r\n}\r\n}\r\nif (items != items2) {\r\nprintk(KERN_ERR "SELinux: avtab: entry only had %d items, expected %d\n", items2, items);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nrc = next_entry(buf16, fp, sizeof(u16)*4);\r\nif (rc) {\r\nprintk(KERN_ERR "SELinux: avtab: truncated entry\n");\r\nreturn rc;\r\n}\r\nitems = 0;\r\nkey.source_type = le16_to_cpu(buf16[items++]);\r\nkey.target_type = le16_to_cpu(buf16[items++]);\r\nkey.target_class = le16_to_cpu(buf16[items++]);\r\nkey.specified = le16_to_cpu(buf16[items++]);\r\nif (!policydb_type_isvalid(pol, key.source_type) ||\r\n!policydb_type_isvalid(pol, key.target_type) ||\r\n!policydb_class_isvalid(pol, key.target_class)) {\r\nprintk(KERN_ERR "SELinux: avtab: invalid type or class\n");\r\nreturn -EINVAL;\r\n}\r\nset = 0;\r\nfor (i = 0; i < ARRAY_SIZE(spec_order); i++) {\r\nif (key.specified & spec_order[i])\r\nset++;\r\n}\r\nif (!set || set > 1) {\r\nprintk(KERN_ERR "SELinux: avtab: more than one specifier\n");\r\nreturn -EINVAL;\r\n}\r\nrc = next_entry(buf32, fp, sizeof(u32));\r\nif (rc) {\r\nprintk(KERN_ERR "SELinux: avtab: truncated entry\n");\r\nreturn rc;\r\n}\r\ndatum.data = le32_to_cpu(*buf32);\r\nif ((key.specified & AVTAB_TYPE) &&\r\n!policydb_type_isvalid(pol, datum.data)) {\r\nprintk(KERN_ERR "SELinux: avtab: invalid type\n");\r\nreturn -EINVAL;\r\n}\r\nreturn insertf(a, &key, &datum, p);\r\n}\r\nstatic int avtab_insertf(struct avtab *a, struct avtab_key *k,\r\nstruct avtab_datum *d, void *p)\r\n{\r\nreturn avtab_insert(a, k, d);\r\n}\r\nint avtab_read(struct avtab *a, void *fp, struct policydb *pol)\r\n{\r\nint rc;\r\n__le32 buf[1];\r\nu32 nel, i;\r\nrc = next_entry(buf, fp, sizeof(u32));\r\nif (rc < 0) {\r\nprintk(KERN_ERR "SELinux: avtab: truncated table\n");\r\ngoto bad;\r\n}\r\nnel = le32_to_cpu(buf[0]);\r\nif (!nel) {\r\nprintk(KERN_ERR "SELinux: avtab: table is empty\n");\r\nrc = -EINVAL;\r\ngoto bad;\r\n}\r\nrc = avtab_alloc(a, nel);\r\nif (rc)\r\ngoto bad;\r\nfor (i = 0; i < nel; i++) {\r\nrc = avtab_read_item(a, fp, pol, avtab_insertf, NULL);\r\nif (rc) {\r\nif (rc == -ENOMEM)\r\nprintk(KERN_ERR "SELinux: avtab: out of memory\n");\r\nelse if (rc == -EEXIST)\r\nprintk(KERN_ERR "SELinux: avtab: duplicate entry\n");\r\ngoto bad;\r\n}\r\n}\r\nrc = 0;\r\nout:\r\nreturn rc;\r\nbad:\r\navtab_destroy(a);\r\ngoto out;\r\n}\r\nint avtab_write_item(struct policydb *p, struct avtab_node *cur, void *fp)\r\n{\r\n__le16 buf16[4];\r\n__le32 buf32[1];\r\nint rc;\r\nbuf16[0] = cpu_to_le16(cur->key.source_type);\r\nbuf16[1] = cpu_to_le16(cur->key.target_type);\r\nbuf16[2] = cpu_to_le16(cur->key.target_class);\r\nbuf16[3] = cpu_to_le16(cur->key.specified);\r\nrc = put_entry(buf16, sizeof(u16), 4, fp);\r\nif (rc)\r\nreturn rc;\r\nbuf32[0] = cpu_to_le32(cur->datum.data);\r\nrc = put_entry(buf32, sizeof(u32), 1, fp);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nint avtab_write(struct policydb *p, struct avtab *a, void *fp)\r\n{\r\nunsigned int i;\r\nint rc = 0;\r\nstruct avtab_node *cur;\r\n__le32 buf[1];\r\nbuf[0] = cpu_to_le32(a->nel);\r\nrc = put_entry(buf, sizeof(u32), 1, fp);\r\nif (rc)\r\nreturn rc;\r\nfor (i = 0; i < a->nslot; i++) {\r\nfor (cur = flex_array_get_ptr(a->htable, i); cur;\r\ncur = cur->next) {\r\nrc = avtab_write_item(p, cur, fp);\r\nif (rc)\r\nreturn rc;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nvoid avtab_cache_init(void)\r\n{\r\navtab_node_cachep = kmem_cache_create("avtab_node",\r\nsizeof(struct avtab_node),\r\n0, SLAB_PANIC, NULL);\r\n}\r\nvoid avtab_cache_destroy(void)\r\n{\r\nkmem_cache_destroy(avtab_node_cachep);\r\n}
