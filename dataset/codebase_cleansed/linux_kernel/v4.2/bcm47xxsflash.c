static void bcm47xxsflash_cmd(struct bcm47xxsflash *b47s, u32 opcode)\r\n{\r\nint i;\r\nb47s->cc_write(b47s, BCMA_CC_FLASHCTL, BCMA_CC_FLASHCTL_START | opcode);\r\nfor (i = 0; i < 1000; i++) {\r\nif (!(b47s->cc_read(b47s, BCMA_CC_FLASHCTL) &\r\nBCMA_CC_FLASHCTL_BUSY))\r\nreturn;\r\ncpu_relax();\r\n}\r\npr_err("Control command failed (timeout)!\n");\r\n}\r\nstatic int bcm47xxsflash_poll(struct bcm47xxsflash *b47s, int timeout)\r\n{\r\nunsigned long deadline = jiffies + timeout;\r\ndo {\r\nswitch (b47s->type) {\r\ncase BCM47XXSFLASH_TYPE_ST:\r\nbcm47xxsflash_cmd(b47s, OPCODE_ST_RDSR);\r\nif (!(b47s->cc_read(b47s, BCMA_CC_FLASHDATA) &\r\nSR_ST_WIP))\r\nreturn 0;\r\nbreak;\r\ncase BCM47XXSFLASH_TYPE_ATMEL:\r\nbcm47xxsflash_cmd(b47s, OPCODE_AT_STATUS);\r\nif (b47s->cc_read(b47s, BCMA_CC_FLASHDATA) &\r\nSR_AT_READY)\r\nreturn 0;\r\nbreak;\r\n}\r\ncpu_relax();\r\nudelay(1);\r\n} while (!time_after_eq(jiffies, deadline));\r\npr_err("Timeout waiting for flash to be ready!\n");\r\nreturn -EBUSY;\r\n}\r\nstatic int bcm47xxsflash_erase(struct mtd_info *mtd, struct erase_info *erase)\r\n{\r\nstruct bcm47xxsflash *b47s = mtd->priv;\r\nint err;\r\nswitch (b47s->type) {\r\ncase BCM47XXSFLASH_TYPE_ST:\r\nbcm47xxsflash_cmd(b47s, OPCODE_ST_WREN);\r\nb47s->cc_write(b47s, BCMA_CC_FLASHADDR, erase->addr);\r\nif (b47s->blocksize < (64 * 1024))\r\nbcm47xxsflash_cmd(b47s, OPCODE_ST_SSE);\r\nelse\r\nbcm47xxsflash_cmd(b47s, OPCODE_ST_SE);\r\nbreak;\r\ncase BCM47XXSFLASH_TYPE_ATMEL:\r\nb47s->cc_write(b47s, BCMA_CC_FLASHADDR, erase->addr << 1);\r\nbcm47xxsflash_cmd(b47s, OPCODE_AT_PAGE_ERASE);\r\nbreak;\r\n}\r\nerr = bcm47xxsflash_poll(b47s, HZ);\r\nif (err)\r\nerase->state = MTD_ERASE_FAILED;\r\nelse\r\nerase->state = MTD_ERASE_DONE;\r\nif (erase->callback)\r\nerase->callback(erase);\r\nreturn err;\r\n}\r\nstatic int bcm47xxsflash_read(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, u_char *buf)\r\n{\r\nstruct bcm47xxsflash *b47s = mtd->priv;\r\nif ((from + len) > mtd->size)\r\nreturn -EINVAL;\r\nmemcpy_fromio(buf, (void __iomem *)KSEG0ADDR(b47s->window + from),\r\nlen);\r\n*retlen = len;\r\nreturn len;\r\n}\r\nstatic int bcm47xxsflash_write_st(struct mtd_info *mtd, u32 offset, size_t len,\r\nconst u_char *buf)\r\n{\r\nstruct bcm47xxsflash *b47s = mtd->priv;\r\nint written = 0;\r\nbcm47xxsflash_cmd(b47s, OPCODE_ST_WREN);\r\nb47s->cc_write(b47s, BCMA_CC_FLASHADDR, offset);\r\nb47s->cc_write(b47s, BCMA_CC_FLASHDATA, *buf++);\r\nif (b47s->bcma_cc->core->id.rev < 20) {\r\nbcm47xxsflash_cmd(b47s, OPCODE_ST_PP);\r\nreturn 1;\r\n}\r\nbcm47xxsflash_cmd(b47s, OPCODE_ST_CSA | OPCODE_ST_PP);\r\noffset++;\r\nlen--;\r\nwritten++;\r\nwhile (len > 0) {\r\nif ((offset & 0xFF) == 0)\r\nbreak;\r\nbcm47xxsflash_cmd(b47s, OPCODE_ST_CSA | *buf++);\r\noffset++;\r\nlen--;\r\nwritten++;\r\n}\r\nb47s->cc_write(b47s, BCMA_CC_FLASHCTL, 0);\r\nudelay(1);\r\nif (bcm47xxsflash_poll(b47s, HZ / 10))\r\npr_err("Flash rejected dropping CSA\n");\r\nreturn written;\r\n}\r\nstatic int bcm47xxsflash_write_at(struct mtd_info *mtd, u32 offset, size_t len,\r\nconst u_char *buf)\r\n{\r\nstruct bcm47xxsflash *b47s = mtd->priv;\r\nu32 mask = b47s->blocksize - 1;\r\nu32 page = (offset & ~mask) << 1;\r\nu32 byte = offset & mask;\r\nint written = 0;\r\nif (byte || (len < b47s->blocksize)) {\r\nint err;\r\nb47s->cc_write(b47s, BCMA_CC_FLASHADDR, page);\r\nbcm47xxsflash_cmd(b47s, OPCODE_AT_BUF1_LOAD);\r\nerr = bcm47xxsflash_poll(b47s, HZ / 1000);\r\nif (err) {\r\npr_err("Timeout reading page 0x%X info buffer\n", page);\r\nreturn err;\r\n}\r\n}\r\nwhile (len > 0) {\r\nif (byte == b47s->blocksize)\r\nbreak;\r\nb47s->cc_write(b47s, BCMA_CC_FLASHADDR, byte++);\r\nb47s->cc_write(b47s, BCMA_CC_FLASHDATA, *buf++);\r\nbcm47xxsflash_cmd(b47s, OPCODE_AT_BUF1_WRITE);\r\nlen--;\r\nwritten++;\r\n}\r\nb47s->cc_write(b47s, BCMA_CC_FLASHADDR, page);\r\nbcm47xxsflash_cmd(b47s, OPCODE_AT_BUF1_PROGRAM);\r\nreturn written;\r\n}\r\nstatic int bcm47xxsflash_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, const u_char *buf)\r\n{\r\nstruct bcm47xxsflash *b47s = mtd->priv;\r\nint written;\r\nwhile (len > 0) {\r\nswitch (b47s->type) {\r\ncase BCM47XXSFLASH_TYPE_ST:\r\nwritten = bcm47xxsflash_write_st(mtd, to, len, buf);\r\nbreak;\r\ncase BCM47XXSFLASH_TYPE_ATMEL:\r\nwritten = bcm47xxsflash_write_at(mtd, to, len, buf);\r\nbreak;\r\ndefault:\r\nBUG_ON(1);\r\n}\r\nif (written < 0) {\r\npr_err("Error writing at offset 0x%llX\n", to);\r\nreturn written;\r\n}\r\nto += (loff_t)written;\r\nlen -= written;\r\n*retlen += written;\r\nbuf += written;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bcm47xxsflash_fill_mtd(struct bcm47xxsflash *b47s)\r\n{\r\nstruct mtd_info *mtd = &b47s->mtd;\r\nmtd->priv = b47s;\r\nmtd->name = "bcm47xxsflash";\r\nmtd->owner = THIS_MODULE;\r\nmtd->type = MTD_NORFLASH;\r\nmtd->flags = MTD_CAP_NORFLASH;\r\nmtd->size = b47s->size;\r\nmtd->erasesize = b47s->blocksize;\r\nmtd->writesize = 1;\r\nmtd->writebufsize = 1;\r\nmtd->_erase = bcm47xxsflash_erase;\r\nmtd->_read = bcm47xxsflash_read;\r\nmtd->_write = bcm47xxsflash_write;\r\n}\r\nstatic int bcm47xxsflash_bcma_cc_read(struct bcm47xxsflash *b47s, u16 offset)\r\n{\r\nreturn bcma_cc_read32(b47s->bcma_cc, offset);\r\n}\r\nstatic void bcm47xxsflash_bcma_cc_write(struct bcm47xxsflash *b47s, u16 offset,\r\nu32 value)\r\n{\r\nbcma_cc_write32(b47s->bcma_cc, offset, value);\r\n}\r\nstatic int bcm47xxsflash_bcma_probe(struct platform_device *pdev)\r\n{\r\nstruct bcma_sflash *sflash = dev_get_platdata(&pdev->dev);\r\nstruct bcm47xxsflash *b47s;\r\nint err;\r\nb47s = devm_kzalloc(&pdev->dev, sizeof(*b47s), GFP_KERNEL);\r\nif (!b47s)\r\nreturn -ENOMEM;\r\nsflash->priv = b47s;\r\nb47s->bcma_cc = container_of(sflash, struct bcma_drv_cc, sflash);\r\nb47s->cc_read = bcm47xxsflash_bcma_cc_read;\r\nb47s->cc_write = bcm47xxsflash_bcma_cc_write;\r\nswitch (b47s->bcma_cc->capabilities & BCMA_CC_CAP_FLASHT) {\r\ncase BCMA_CC_FLASHT_STSER:\r\nb47s->type = BCM47XXSFLASH_TYPE_ST;\r\nbreak;\r\ncase BCMA_CC_FLASHT_ATSER:\r\nb47s->type = BCM47XXSFLASH_TYPE_ATMEL;\r\nbreak;\r\n}\r\nb47s->window = sflash->window;\r\nb47s->blocksize = sflash->blocksize;\r\nb47s->numblocks = sflash->numblocks;\r\nb47s->size = sflash->size;\r\nbcm47xxsflash_fill_mtd(b47s);\r\nerr = mtd_device_parse_register(&b47s->mtd, probes, NULL, NULL, 0);\r\nif (err) {\r\npr_err("Failed to register MTD device: %d\n", err);\r\nreturn err;\r\n}\r\nif (bcm47xxsflash_poll(b47s, HZ / 10))\r\npr_warn("Serial flash busy\n");\r\nreturn 0;\r\n}\r\nstatic int bcm47xxsflash_bcma_remove(struct platform_device *pdev)\r\n{\r\nstruct bcma_sflash *sflash = dev_get_platdata(&pdev->dev);\r\nstruct bcm47xxsflash *b47s = sflash->priv;\r\nmtd_device_unregister(&b47s->mtd);\r\nreturn 0;\r\n}
