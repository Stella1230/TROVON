static int __init scu_a9_enable(void)\r\n{\r\nunsigned long config_base;\r\nvoid __iomem *scu_base;\r\nif (!scu_a9_has_base()) {\r\npr_err("no configuration base address register!\n");\r\nreturn -ENXIO;\r\n}\r\nconfig_base = scu_a9_get_base();\r\nif (!config_base) {\r\npr_err("hardware reports only one core\n");\r\nreturn -ENOENT;\r\n}\r\nscu_base = ioremap((phys_addr_t)config_base, CORTEX_A9_SCU_SIZE);\r\nif (!scu_base) {\r\npr_err("failed to remap config base (%lu/%u) for SCU\n",\r\nconfig_base, CORTEX_A9_SCU_SIZE);\r\nreturn -ENOMEM;\r\n}\r\nscu_enable(scu_base);\r\niounmap(scu_base);\r\nreturn 0;\r\n}\r\nstatic void __init bcm_smp_prepare_cpus(unsigned int max_cpus)\r\n{\r\nstatic cpumask_t only_cpu_0 = { CPU_BITS_CPU0 };\r\nstruct device_node *node;\r\nint ret;\r\nBUG_ON(secondary_boot);\r\nnode = of_find_node_by_path("/cpus");\r\nBUG_ON(!node);\r\nif (of_property_read_u32(node, OF_SECONDARY_BOOT, &secondary_boot)) {\r\npr_err("%s: missing/invalid " OF_SECONDARY_BOOT " property\n",\r\nnode->name);\r\nret = -ENOENT;\r\ngoto out;\r\n}\r\nret = scu_a9_enable();\r\nout:\r\nof_node_put(node);\r\nif (ret) {\r\nBUG_ON(ret != -ENOENT);\r\npr_warn("disabling SMP\n");\r\ninit_cpu_present(&only_cpu_0);\r\n}\r\n}\r\nstatic int bcm_boot_secondary(unsigned int cpu, struct task_struct *idle)\r\n{\r\nvoid __iomem *boot_reg;\r\nphys_addr_t boot_func;\r\nu64 start_clock;\r\nu32 cpu_id;\r\nu32 boot_val;\r\nbool timeout = false;\r\ncpu_id = cpu_logical_map(cpu);\r\nif (cpu_id & ~BOOT_ADDR_CPUID_MASK) {\r\npr_err("bad cpu id (%u > %u)\n", cpu_id, BOOT_ADDR_CPUID_MASK);\r\nreturn -EINVAL;\r\n}\r\nif (!secondary_boot) {\r\npr_err("required secondary boot register not specified\n");\r\nreturn -EINVAL;\r\n}\r\nboot_reg = ioremap_nocache((phys_addr_t)secondary_boot, sizeof(u32));\r\nif (!boot_reg) {\r\npr_err("unable to map boot register for cpu %u\n", cpu_id);\r\nreturn -ENOSYS;\r\n}\r\nboot_func = virt_to_phys(secondary_startup);\r\nBUG_ON(boot_func & BOOT_ADDR_CPUID_MASK);\r\nBUG_ON(boot_func > (phys_addr_t)U32_MAX);\r\nboot_val = (u32)boot_func | cpu_id;\r\nwritel_relaxed(boot_val, boot_reg);\r\nsev();\r\nstart_clock = local_clock();\r\nwhile (!timeout && readl_relaxed(boot_reg) == boot_val)\r\ntimeout = local_clock() - start_clock > SECONDARY_TIMEOUT_NS;\r\niounmap(boot_reg);\r\nif (!timeout)\r\nreturn 0;\r\npr_err("timeout waiting for cpu %u to start\n", cpu_id);\r\nreturn -ENOSYS;\r\n}
