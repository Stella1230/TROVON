void ieee80211_ocb_rx_no_sta(struct ieee80211_sub_if_data *sdata,\r\nconst u8 *bssid, const u8 *addr,\r\nu32 supp_rates)\r\n{\r\nstruct ieee80211_if_ocb *ifocb = &sdata->u.ocb;\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct ieee80211_chanctx_conf *chanctx_conf;\r\nstruct ieee80211_supported_band *sband;\r\nenum nl80211_bss_scan_width scan_width;\r\nstruct sta_info *sta;\r\nint band;\r\nif (local->num_sta >= IEEE80211_OCB_MAX_STA_ENTRIES) {\r\nnet_info_ratelimited("%s: No room for a new OCB STA entry %pM\n",\r\nsdata->name, addr);\r\nreturn;\r\n}\r\nocb_dbg(sdata, "Adding new OCB station %pM\n", addr);\r\nrcu_read_lock();\r\nchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\r\nif (WARN_ON_ONCE(!chanctx_conf)) {\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\nband = chanctx_conf->def.chan->band;\r\nscan_width = cfg80211_chandef_to_scan_width(&chanctx_conf->def);\r\nrcu_read_unlock();\r\nsta = sta_info_alloc(sdata, addr, GFP_ATOMIC);\r\nif (!sta)\r\nreturn;\r\nsta->last_rx = jiffies;\r\nsband = local->hw.wiphy->bands[band];\r\nsta->sta.supp_rates[band] =\r\nieee80211_mandatory_rates(sband, scan_width);\r\nspin_lock(&ifocb->incomplete_lock);\r\nlist_add(&sta->list, &ifocb->incomplete_stations);\r\nspin_unlock(&ifocb->incomplete_lock);\r\nieee80211_queue_work(&local->hw, &sdata->work);\r\n}\r\nstatic struct sta_info *ieee80211_ocb_finish_sta(struct sta_info *sta)\r\n__acquires(RCU)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nu8 addr[ETH_ALEN];\r\nmemcpy(addr, sta->sta.addr, ETH_ALEN);\r\nocb_dbg(sdata, "Adding new IBSS station %pM (dev=%s)\n",\r\naddr, sdata->name);\r\nsta_info_move_state(sta, IEEE80211_STA_AUTH);\r\nsta_info_move_state(sta, IEEE80211_STA_ASSOC);\r\nsta_info_move_state(sta, IEEE80211_STA_AUTHORIZED);\r\nrate_control_rate_init(sta);\r\nif (sta_info_insert_rcu(sta))\r\nreturn sta_info_get(sdata, addr);\r\nreturn sta;\r\n}\r\nstatic void ieee80211_ocb_housekeeping(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_if_ocb *ifocb = &sdata->u.ocb;\r\nocb_dbg(sdata, "Running ocb housekeeping\n");\r\nieee80211_sta_expire(sdata, IEEE80211_OCB_PEER_INACTIVITY_LIMIT);\r\nmod_timer(&ifocb->housekeeping_timer,\r\nround_jiffies(jiffies + IEEE80211_OCB_HOUSEKEEPING_INTERVAL));\r\n}\r\nvoid ieee80211_ocb_work(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_if_ocb *ifocb = &sdata->u.ocb;\r\nstruct sta_info *sta;\r\nif (ifocb->joined != true)\r\nreturn;\r\nsdata_lock(sdata);\r\nspin_lock_bh(&ifocb->incomplete_lock);\r\nwhile (!list_empty(&ifocb->incomplete_stations)) {\r\nsta = list_first_entry(&ifocb->incomplete_stations,\r\nstruct sta_info, list);\r\nlist_del(&sta->list);\r\nspin_unlock_bh(&ifocb->incomplete_lock);\r\nieee80211_ocb_finish_sta(sta);\r\nrcu_read_unlock();\r\nspin_lock_bh(&ifocb->incomplete_lock);\r\n}\r\nspin_unlock_bh(&ifocb->incomplete_lock);\r\nif (test_and_clear_bit(OCB_WORK_HOUSEKEEPING, &ifocb->wrkq_flags))\r\nieee80211_ocb_housekeeping(sdata);\r\nsdata_unlock(sdata);\r\n}\r\nstatic void ieee80211_ocb_housekeeping_timer(unsigned long data)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = (void *)data;\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct ieee80211_if_ocb *ifocb = &sdata->u.ocb;\r\nset_bit(OCB_WORK_HOUSEKEEPING, &ifocb->wrkq_flags);\r\nieee80211_queue_work(&local->hw, &sdata->work);\r\n}\r\nvoid ieee80211_ocb_setup_sdata(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_if_ocb *ifocb = &sdata->u.ocb;\r\nsetup_timer(&ifocb->housekeeping_timer,\r\nieee80211_ocb_housekeeping_timer,\r\n(unsigned long)sdata);\r\nINIT_LIST_HEAD(&ifocb->incomplete_stations);\r\nspin_lock_init(&ifocb->incomplete_lock);\r\n}\r\nint ieee80211_ocb_join(struct ieee80211_sub_if_data *sdata,\r\nstruct ocb_setup *setup)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct ieee80211_if_ocb *ifocb = &sdata->u.ocb;\r\nu32 changed = BSS_CHANGED_OCB;\r\nint err;\r\nif (ifocb->joined == true)\r\nreturn -EINVAL;\r\nsdata->flags |= IEEE80211_SDATA_OPERATING_GMODE;\r\nsdata->smps_mode = IEEE80211_SMPS_OFF;\r\nsdata->needed_rx_chains = sdata->local->rx_chains;\r\nmutex_lock(&sdata->local->mtx);\r\nerr = ieee80211_vif_use_channel(sdata, &setup->chandef,\r\nIEEE80211_CHANCTX_SHARED);\r\nmutex_unlock(&sdata->local->mtx);\r\nif (err)\r\nreturn err;\r\nieee80211_bss_info_change_notify(sdata, changed);\r\nifocb->joined = true;\r\nset_bit(OCB_WORK_HOUSEKEEPING, &ifocb->wrkq_flags);\r\nieee80211_queue_work(&local->hw, &sdata->work);\r\nnetif_carrier_on(sdata->dev);\r\nreturn 0;\r\n}\r\nint ieee80211_ocb_leave(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_if_ocb *ifocb = &sdata->u.ocb;\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct sta_info *sta;\r\nifocb->joined = false;\r\nsta_info_flush(sdata);\r\nspin_lock_bh(&ifocb->incomplete_lock);\r\nwhile (!list_empty(&ifocb->incomplete_stations)) {\r\nsta = list_first_entry(&ifocb->incomplete_stations,\r\nstruct sta_info, list);\r\nlist_del(&sta->list);\r\nspin_unlock_bh(&ifocb->incomplete_lock);\r\nsta_info_free(local, sta);\r\nspin_lock_bh(&ifocb->incomplete_lock);\r\n}\r\nspin_unlock_bh(&ifocb->incomplete_lock);\r\nnetif_carrier_off(sdata->dev);\r\nclear_bit(SDATA_STATE_OFFCHANNEL, &sdata->state);\r\nieee80211_bss_info_change_notify(sdata, BSS_CHANGED_OCB);\r\nmutex_lock(&sdata->local->mtx);\r\nieee80211_vif_release_channel(sdata);\r\nmutex_unlock(&sdata->local->mtx);\r\nskb_queue_purge(&sdata->skb_queue);\r\ndel_timer_sync(&sdata->u.ocb.housekeeping_timer);\r\nreturn 0;\r\n}
