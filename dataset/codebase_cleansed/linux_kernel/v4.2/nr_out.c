void nr_output(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct sk_buff *skbn;\r\nunsigned char transport[NR_TRANSPORT_LEN];\r\nint err, frontlen, len;\r\nif (skb->len - NR_TRANSPORT_LEN > NR_MAX_PACKET_SIZE) {\r\nskb_copy_from_linear_data(skb, transport, NR_TRANSPORT_LEN);\r\nskb_pull(skb, NR_TRANSPORT_LEN);\r\nfrontlen = skb_headroom(skb);\r\nwhile (skb->len > 0) {\r\nif ((skbn = sock_alloc_send_skb(sk, frontlen + NR_MAX_PACKET_SIZE, 0, &err)) == NULL)\r\nreturn;\r\nskb_reserve(skbn, frontlen);\r\nlen = (NR_MAX_PACKET_SIZE > skb->len) ? skb->len : NR_MAX_PACKET_SIZE;\r\nskb_copy_from_linear_data(skb, skb_put(skbn, len), len);\r\nskb_pull(skb, len);\r\nskb_push(skbn, NR_TRANSPORT_LEN);\r\nskb_copy_to_linear_data(skbn, transport,\r\nNR_TRANSPORT_LEN);\r\nif (skb->len > 0)\r\nskbn->data[4] |= NR_MORE_FLAG;\r\nskb_queue_tail(&sk->sk_write_queue, skbn);\r\n}\r\nkfree_skb(skb);\r\n} else {\r\nskb_queue_tail(&sk->sk_write_queue, skb);\r\n}\r\nnr_kick(sk);\r\n}\r\nstatic void nr_send_iframe(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct nr_sock *nr = nr_sk(sk);\r\nif (skb == NULL)\r\nreturn;\r\nskb->data[2] = nr->vs;\r\nskb->data[3] = nr->vr;\r\nif (nr->condition & NR_COND_OWN_RX_BUSY)\r\nskb->data[4] |= NR_CHOKE_FLAG;\r\nnr_start_idletimer(sk);\r\nnr_transmit_buffer(sk, skb);\r\n}\r\nvoid nr_send_nak_frame(struct sock *sk)\r\n{\r\nstruct sk_buff *skb, *skbn;\r\nstruct nr_sock *nr = nr_sk(sk);\r\nif ((skb = skb_peek(&nr->ack_queue)) == NULL)\r\nreturn;\r\nif ((skbn = skb_clone(skb, GFP_ATOMIC)) == NULL)\r\nreturn;\r\nskbn->data[2] = nr->va;\r\nskbn->data[3] = nr->vr;\r\nif (nr->condition & NR_COND_OWN_RX_BUSY)\r\nskbn->data[4] |= NR_CHOKE_FLAG;\r\nnr_transmit_buffer(sk, skbn);\r\nnr->condition &= ~NR_COND_ACK_PENDING;\r\nnr->vl = nr->vr;\r\nnr_stop_t1timer(sk);\r\n}\r\nvoid nr_kick(struct sock *sk)\r\n{\r\nstruct nr_sock *nr = nr_sk(sk);\r\nstruct sk_buff *skb, *skbn;\r\nunsigned short start, end;\r\nif (nr->state != NR_STATE_3)\r\nreturn;\r\nif (nr->condition & NR_COND_PEER_RX_BUSY)\r\nreturn;\r\nif (!skb_peek(&sk->sk_write_queue))\r\nreturn;\r\nstart = (skb_peek(&nr->ack_queue) == NULL) ? nr->va : nr->vs;\r\nend = (nr->va + nr->window) % NR_MODULUS;\r\nif (start == end)\r\nreturn;\r\nnr->vs = start;\r\nskb = skb_dequeue(&sk->sk_write_queue);\r\ndo {\r\nif ((skbn = skb_clone(skb, GFP_ATOMIC)) == NULL) {\r\nskb_queue_head(&sk->sk_write_queue, skb);\r\nbreak;\r\n}\r\nskb_set_owner_w(skbn, sk);\r\nnr_send_iframe(sk, skbn);\r\nnr->vs = (nr->vs + 1) % NR_MODULUS;\r\nskb_queue_tail(&nr->ack_queue, skb);\r\n} while (nr->vs != end &&\r\n(skb = skb_dequeue(&sk->sk_write_queue)) != NULL);\r\nnr->vl = nr->vr;\r\nnr->condition &= ~NR_COND_ACK_PENDING;\r\nif (!nr_t1timer_running(sk))\r\nnr_start_t1timer(sk);\r\n}\r\nvoid nr_transmit_buffer(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct nr_sock *nr = nr_sk(sk);\r\nunsigned char *dptr;\r\ndptr = skb_push(skb, NR_NETWORK_LEN);\r\nmemcpy(dptr, &nr->source_addr, AX25_ADDR_LEN);\r\ndptr[6] &= ~AX25_CBIT;\r\ndptr[6] &= ~AX25_EBIT;\r\ndptr[6] |= AX25_SSSID_SPARE;\r\ndptr += AX25_ADDR_LEN;\r\nmemcpy(dptr, &nr->dest_addr, AX25_ADDR_LEN);\r\ndptr[6] &= ~AX25_CBIT;\r\ndptr[6] |= AX25_EBIT;\r\ndptr[6] |= AX25_SSSID_SPARE;\r\ndptr += AX25_ADDR_LEN;\r\n*dptr++ = sysctl_netrom_network_ttl_initialiser;\r\nif (!nr_route_frame(skb, NULL)) {\r\nkfree_skb(skb);\r\nnr_disconnect(sk, ENETUNREACH);\r\n}\r\n}\r\nvoid nr_establish_data_link(struct sock *sk)\r\n{\r\nstruct nr_sock *nr = nr_sk(sk);\r\nnr->condition = 0x00;\r\nnr->n2count = 0;\r\nnr_write_internal(sk, NR_CONNREQ);\r\nnr_stop_t2timer(sk);\r\nnr_stop_t4timer(sk);\r\nnr_stop_idletimer(sk);\r\nnr_start_t1timer(sk);\r\n}\r\nvoid nr_enquiry_response(struct sock *sk)\r\n{\r\nstruct nr_sock *nr = nr_sk(sk);\r\nint frametype = NR_INFOACK;\r\nif (nr->condition & NR_COND_OWN_RX_BUSY) {\r\nframetype |= NR_CHOKE_FLAG;\r\n} else {\r\nif (skb_peek(&nr->reseq_queue) != NULL)\r\nframetype |= NR_NAK_FLAG;\r\n}\r\nnr_write_internal(sk, frametype);\r\nnr->vl = nr->vr;\r\nnr->condition &= ~NR_COND_ACK_PENDING;\r\n}\r\nvoid nr_check_iframes_acked(struct sock *sk, unsigned short nr)\r\n{\r\nstruct nr_sock *nrom = nr_sk(sk);\r\nif (nrom->vs == nr) {\r\nnr_frames_acked(sk, nr);\r\nnr_stop_t1timer(sk);\r\nnrom->n2count = 0;\r\n} else {\r\nif (nrom->va != nr) {\r\nnr_frames_acked(sk, nr);\r\nnr_start_t1timer(sk);\r\n}\r\n}\r\n}
