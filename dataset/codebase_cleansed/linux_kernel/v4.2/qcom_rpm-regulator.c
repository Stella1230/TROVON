static int rpm_reg_write(struct qcom_rpm_reg *vreg,\r\nconst struct request_member *req,\r\nconst int value)\r\n{\r\nif (WARN_ON((value << req->shift) & ~req->mask))\r\nreturn -EINVAL;\r\nvreg->val[req->word] &= ~req->mask;\r\nvreg->val[req->word] |= value << req->shift;\r\nreturn qcom_rpm_write(vreg->rpm,\r\nQCOM_RPM_ACTIVE_STATE,\r\nvreg->resource,\r\nvreg->val,\r\nvreg->parts->request_len);\r\n}\r\nstatic int rpm_reg_set_mV_sel(struct regulator_dev *rdev,\r\nunsigned selector)\r\n{\r\nstruct qcom_rpm_reg *vreg = rdev_get_drvdata(rdev);\r\nconst struct rpm_reg_parts *parts = vreg->parts;\r\nconst struct request_member *req = &parts->mV;\r\nint ret = 0;\r\nint uV;\r\nif (req->mask == 0)\r\nreturn -EINVAL;\r\nuV = regulator_list_voltage_linear_range(rdev, selector);\r\nif (uV < 0)\r\nreturn uV;\r\nmutex_lock(&vreg->lock);\r\nif (vreg->is_enabled)\r\nret = rpm_reg_write(vreg, req, uV / 1000);\r\nif (!ret)\r\nvreg->uV = uV;\r\nmutex_unlock(&vreg->lock);\r\nreturn ret;\r\n}\r\nstatic int rpm_reg_set_uV_sel(struct regulator_dev *rdev,\r\nunsigned selector)\r\n{\r\nstruct qcom_rpm_reg *vreg = rdev_get_drvdata(rdev);\r\nconst struct rpm_reg_parts *parts = vreg->parts;\r\nconst struct request_member *req = &parts->uV;\r\nint ret = 0;\r\nint uV;\r\nif (req->mask == 0)\r\nreturn -EINVAL;\r\nuV = regulator_list_voltage_linear_range(rdev, selector);\r\nif (uV < 0)\r\nreturn uV;\r\nmutex_lock(&vreg->lock);\r\nif (vreg->is_enabled)\r\nret = rpm_reg_write(vreg, req, uV);\r\nif (!ret)\r\nvreg->uV = uV;\r\nmutex_unlock(&vreg->lock);\r\nreturn ret;\r\n}\r\nstatic int rpm_reg_get_voltage(struct regulator_dev *rdev)\r\n{\r\nstruct qcom_rpm_reg *vreg = rdev_get_drvdata(rdev);\r\nreturn vreg->uV;\r\n}\r\nstatic int rpm_reg_mV_enable(struct regulator_dev *rdev)\r\n{\r\nstruct qcom_rpm_reg *vreg = rdev_get_drvdata(rdev);\r\nconst struct rpm_reg_parts *parts = vreg->parts;\r\nconst struct request_member *req = &parts->mV;\r\nint ret;\r\nif (req->mask == 0)\r\nreturn -EINVAL;\r\nmutex_lock(&vreg->lock);\r\nret = rpm_reg_write(vreg, req, vreg->uV / 1000);\r\nif (!ret)\r\nvreg->is_enabled = 1;\r\nmutex_unlock(&vreg->lock);\r\nreturn ret;\r\n}\r\nstatic int rpm_reg_uV_enable(struct regulator_dev *rdev)\r\n{\r\nstruct qcom_rpm_reg *vreg = rdev_get_drvdata(rdev);\r\nconst struct rpm_reg_parts *parts = vreg->parts;\r\nconst struct request_member *req = &parts->uV;\r\nint ret;\r\nif (req->mask == 0)\r\nreturn -EINVAL;\r\nmutex_lock(&vreg->lock);\r\nret = rpm_reg_write(vreg, req, vreg->uV);\r\nif (!ret)\r\nvreg->is_enabled = 1;\r\nmutex_unlock(&vreg->lock);\r\nreturn ret;\r\n}\r\nstatic int rpm_reg_switch_enable(struct regulator_dev *rdev)\r\n{\r\nstruct qcom_rpm_reg *vreg = rdev_get_drvdata(rdev);\r\nconst struct rpm_reg_parts *parts = vreg->parts;\r\nconst struct request_member *req = &parts->enable_state;\r\nint ret;\r\nif (req->mask == 0)\r\nreturn -EINVAL;\r\nmutex_lock(&vreg->lock);\r\nret = rpm_reg_write(vreg, req, 1);\r\nif (!ret)\r\nvreg->is_enabled = 1;\r\nmutex_unlock(&vreg->lock);\r\nreturn ret;\r\n}\r\nstatic int rpm_reg_mV_disable(struct regulator_dev *rdev)\r\n{\r\nstruct qcom_rpm_reg *vreg = rdev_get_drvdata(rdev);\r\nconst struct rpm_reg_parts *parts = vreg->parts;\r\nconst struct request_member *req = &parts->mV;\r\nint ret;\r\nif (req->mask == 0)\r\nreturn -EINVAL;\r\nmutex_lock(&vreg->lock);\r\nret = rpm_reg_write(vreg, req, 0);\r\nif (!ret)\r\nvreg->is_enabled = 0;\r\nmutex_unlock(&vreg->lock);\r\nreturn ret;\r\n}\r\nstatic int rpm_reg_uV_disable(struct regulator_dev *rdev)\r\n{\r\nstruct qcom_rpm_reg *vreg = rdev_get_drvdata(rdev);\r\nconst struct rpm_reg_parts *parts = vreg->parts;\r\nconst struct request_member *req = &parts->uV;\r\nint ret;\r\nif (req->mask == 0)\r\nreturn -EINVAL;\r\nmutex_lock(&vreg->lock);\r\nret = rpm_reg_write(vreg, req, 0);\r\nif (!ret)\r\nvreg->is_enabled = 0;\r\nmutex_unlock(&vreg->lock);\r\nreturn ret;\r\n}\r\nstatic int rpm_reg_switch_disable(struct regulator_dev *rdev)\r\n{\r\nstruct qcom_rpm_reg *vreg = rdev_get_drvdata(rdev);\r\nconst struct rpm_reg_parts *parts = vreg->parts;\r\nconst struct request_member *req = &parts->enable_state;\r\nint ret;\r\nif (req->mask == 0)\r\nreturn -EINVAL;\r\nmutex_lock(&vreg->lock);\r\nret = rpm_reg_write(vreg, req, 0);\r\nif (!ret)\r\nvreg->is_enabled = 0;\r\nmutex_unlock(&vreg->lock);\r\nreturn ret;\r\n}\r\nstatic int rpm_reg_is_enabled(struct regulator_dev *rdev)\r\n{\r\nstruct qcom_rpm_reg *vreg = rdev_get_drvdata(rdev);\r\nreturn vreg->is_enabled;\r\n}\r\nstatic int rpm_reg_set_load(struct regulator_dev *rdev, int load_uA)\r\n{\r\nstruct qcom_rpm_reg *vreg = rdev_get_drvdata(rdev);\r\nconst struct rpm_reg_parts *parts = vreg->parts;\r\nconst struct request_member *req = &parts->ia;\r\nint load_mA = load_uA / 1000;\r\nint max_mA = req->mask >> req->shift;\r\nint ret;\r\nif (req->mask == 0)\r\nreturn -EINVAL;\r\nif (load_mA > max_mA)\r\nload_mA = max_mA;\r\nmutex_lock(&vreg->lock);\r\nret = rpm_reg_write(vreg, req, load_mA);\r\nmutex_unlock(&vreg->lock);\r\nreturn ret;\r\n}\r\nstatic int rpm_reg_set(struct qcom_rpm_reg *vreg,\r\nconst struct request_member *req,\r\nconst int value)\r\n{\r\nif (req->mask == 0 || (value << req->shift) & ~req->mask)\r\nreturn -EINVAL;\r\nvreg->val[req->word] &= ~req->mask;\r\nvreg->val[req->word] |= value << req->shift;\r\nreturn 0;\r\n}\r\nstatic int rpm_reg_of_parse_freq(struct device *dev,\r\nstruct device_node *node,\r\nstruct qcom_rpm_reg *vreg)\r\n{\r\nstatic const int freq_table[] = {\r\n19200000, 9600000, 6400000, 4800000, 3840000, 3200000, 2740000,\r\n2400000, 2130000, 1920000, 1750000, 1600000, 1480000, 1370000,\r\n1280000, 1200000,\r\n};\r\nconst char *key;\r\nu32 freq;\r\nint ret;\r\nint i;\r\nkey = "qcom,switch-mode-frequency";\r\nret = of_property_read_u32(node, key, &freq);\r\nif (ret) {\r\ndev_err(dev, "regulator requires %s property\n", key);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(freq_table); i++) {\r\nif (freq == freq_table[i]) {\r\nrpm_reg_set(vreg, &vreg->parts->freq, i + 1);\r\nreturn 0;\r\n}\r\n}\r\ndev_err(dev, "invalid frequency %d\n", freq);\r\nreturn -EINVAL;\r\n}\r\nstatic int rpm_reg_of_parse(struct device_node *node,\r\nconst struct regulator_desc *desc,\r\nstruct regulator_config *config)\r\n{\r\nstruct qcom_rpm_reg *vreg = config->driver_data;\r\nstruct device *dev = config->dev;\r\nconst char *key;\r\nu32 force_mode;\r\nbool pwm;\r\nu32 val;\r\nint ret;\r\nkey = "bias-pull-down";\r\nif (of_property_read_bool(node, key)) {\r\nret = rpm_reg_set(vreg, &vreg->parts->pd, 1);\r\nif (ret) {\r\ndev_err(dev, "%s is invalid", key);\r\nreturn ret;\r\n}\r\n}\r\nif (vreg->parts->freq.mask) {\r\nret = rpm_reg_of_parse_freq(dev, node, vreg);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (vreg->parts->pm.mask) {\r\nkey = "qcom,power-mode-hysteretic";\r\npwm = !of_property_read_bool(node, key);\r\nret = rpm_reg_set(vreg, &vreg->parts->pm, pwm);\r\nif (ret) {\r\ndev_err(dev, "failed to set power mode\n");\r\nreturn ret;\r\n}\r\n}\r\nif (vreg->parts->fm.mask) {\r\nforce_mode = -1;\r\nkey = "qcom,force-mode";\r\nret = of_property_read_u32(node, key, &val);\r\nif (ret == -EINVAL) {\r\nval = QCOM_RPM_FORCE_MODE_NONE;\r\n} else if (ret < 0) {\r\ndev_err(dev, "failed to read %s\n", key);\r\nreturn ret;\r\n}\r\nswitch (val) {\r\ncase QCOM_RPM_FORCE_MODE_NONE:\r\nforce_mode = 0;\r\nbreak;\r\ncase QCOM_RPM_FORCE_MODE_LPM:\r\nforce_mode = 1;\r\nbreak;\r\ncase QCOM_RPM_FORCE_MODE_HPM:\r\nif (FORCE_MODE_IS_2_BITS(vreg))\r\nforce_mode = 2;\r\nelse\r\nforce_mode = 3;\r\nbreak;\r\ncase QCOM_RPM_FORCE_MODE_AUTO:\r\nif (vreg->supports_force_mode_auto)\r\nforce_mode = 2;\r\nbreak;\r\ncase QCOM_RPM_FORCE_MODE_BYPASS:\r\nif (vreg->supports_force_mode_bypass)\r\nforce_mode = 4;\r\nbreak;\r\n}\r\nif (force_mode == -1) {\r\ndev_err(dev, "invalid force mode\n");\r\nreturn -EINVAL;\r\n}\r\nret = rpm_reg_set(vreg, &vreg->parts->fm, force_mode);\r\nif (ret) {\r\ndev_err(dev, "failed to set force mode\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int rpm_reg_probe(struct platform_device *pdev)\r\n{\r\nconst struct rpm_regulator_data *reg;\r\nconst struct of_device_id *match;\r\nstruct regulator_config config = { };\r\nstruct regulator_dev *rdev;\r\nstruct qcom_rpm_reg *vreg;\r\nstruct qcom_rpm *rpm;\r\nrpm = dev_get_drvdata(pdev->dev.parent);\r\nif (!rpm) {\r\ndev_err(&pdev->dev, "unable to retrieve handle to rpm\n");\r\nreturn -ENODEV;\r\n}\r\nmatch = of_match_device(rpm_of_match, &pdev->dev);\r\nfor (reg = match->data; reg->name; reg++) {\r\nvreg = devm_kmalloc(&pdev->dev, sizeof(*vreg), GFP_KERNEL);\r\nif (!vreg)\r\nreturn -ENOMEM;\r\nmemcpy(vreg, reg->template, sizeof(*vreg));\r\nmutex_init(&vreg->lock);\r\nvreg->dev = &pdev->dev;\r\nvreg->resource = reg->resource;\r\nvreg->rpm = rpm;\r\nvreg->desc.id = -1;\r\nvreg->desc.owner = THIS_MODULE;\r\nvreg->desc.type = REGULATOR_VOLTAGE;\r\nvreg->desc.name = reg->name;\r\nvreg->desc.supply_name = reg->supply;\r\nvreg->desc.of_match = reg->name;\r\nvreg->desc.of_parse_cb = rpm_reg_of_parse;\r\nconfig.dev = &pdev->dev;\r\nconfig.driver_data = vreg;\r\nrdev = devm_regulator_register(&pdev->dev, &vreg->desc, &config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(&pdev->dev, "failed to register %s\n", reg->name);\r\nreturn PTR_ERR(rdev);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init rpm_reg_init(void)\r\n{\r\nreturn platform_driver_register(&rpm_reg_driver);\r\n}\r\nstatic void __exit rpm_reg_exit(void)\r\n{\r\nplatform_driver_unregister(&rpm_reg_driver);\r\n}
