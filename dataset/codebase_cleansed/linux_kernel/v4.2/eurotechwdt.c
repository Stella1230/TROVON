static inline void eurwdt_write_reg(u8 index, u8 data)\r\n{\r\noutb(index, io);\r\noutb(data, io+1);\r\n}\r\nstatic inline void eurwdt_lock_chip(void)\r\n{\r\noutb(0xaa, io);\r\n}\r\nstatic inline void eurwdt_unlock_chip(void)\r\n{\r\noutb(0x55, io);\r\neurwdt_write_reg(0x07, 0x08);\r\n}\r\nstatic inline void eurwdt_set_timeout(int timeout)\r\n{\r\neurwdt_write_reg(WDT_TIMEOUT_VAL, (u8) timeout);\r\n}\r\nstatic inline void eurwdt_disable_timer(void)\r\n{\r\neurwdt_set_timeout(0);\r\n}\r\nstatic void eurwdt_activate_timer(void)\r\n{\r\neurwdt_disable_timer();\r\neurwdt_write_reg(WDT_CTRL_REG, 0x01);\r\neurwdt_write_reg(WDT_OUTPIN_CFG,\r\n!strcmp("int", ev) ? WDT_EVENT_INT : WDT_EVENT_REBOOT);\r\nif (irq == 2 || irq > 15 || irq < 0) {\r\npr_err("invalid irq number\n");\r\nirq = 0;\r\n}\r\nif (irq == 0)\r\npr_info("interrupt disabled\n");\r\neurwdt_write_reg(WDT_TIMER_CFG, irq << 4);\r\neurwdt_write_reg(WDT_UNIT_SEL, WDT_UNIT_SECS);\r\neurwdt_set_timeout(0);\r\n}\r\nstatic irqreturn_t eurwdt_interrupt(int irq, void *dev_id)\r\n{\r\npr_crit("timeout WDT timeout\n");\r\n#ifdef ONLY_TESTING\r\npr_crit("Would Reboot\n");\r\n#else\r\npr_crit("Initiating system reboot\n");\r\nemergency_restart();\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void eurwdt_ping(void)\r\n{\r\neurwdt_set_timeout(eurwdt_timeout);\r\n}\r\nstatic ssize_t eurwdt_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nif (count) {\r\nif (!nowayout) {\r\nsize_t i;\r\neur_expect_close = 0;\r\nfor (i = 0; i != count; i++) {\r\nchar c;\r\nif (get_user(c, buf + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\neur_expect_close = 42;\r\n}\r\n}\r\nspin_lock(&eurwdt_lock);\r\neurwdt_ping();\r\nspin_unlock(&eurwdt_lock);\r\n}\r\nreturn count;\r\n}\r\nstatic long eurwdt_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nstatic const struct watchdog_info ident = {\r\n.options = WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT\r\n| WDIOF_MAGICCLOSE,\r\n.firmware_version = 1,\r\n.identity = "WDT Eurotech CPU-1220/1410",\r\n};\r\nint time;\r\nint options, retval = -EINVAL;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nreturn copy_to_user(argp, &ident, sizeof(ident)) ? -EFAULT : 0;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(0, p);\r\ncase WDIOC_SETOPTIONS:\r\nif (get_user(options, p))\r\nreturn -EFAULT;\r\nspin_lock(&eurwdt_lock);\r\nif (options & WDIOS_DISABLECARD) {\r\neurwdt_disable_timer();\r\nretval = 0;\r\n}\r\nif (options & WDIOS_ENABLECARD) {\r\neurwdt_activate_timer();\r\neurwdt_ping();\r\nretval = 0;\r\n}\r\nspin_unlock(&eurwdt_lock);\r\nreturn retval;\r\ncase WDIOC_KEEPALIVE:\r\nspin_lock(&eurwdt_lock);\r\neurwdt_ping();\r\nspin_unlock(&eurwdt_lock);\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\nif (copy_from_user(&time, p, sizeof(int)))\r\nreturn -EFAULT;\r\nif (time < 0 || time > 255)\r\nreturn -EINVAL;\r\nspin_lock(&eurwdt_lock);\r\neurwdt_timeout = time;\r\neurwdt_set_timeout(time);\r\nspin_unlock(&eurwdt_lock);\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(eurwdt_timeout, p);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int eurwdt_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(0, &eurwdt_is_open))\r\nreturn -EBUSY;\r\neurwdt_timeout = WDT_TIMEOUT;\r\neurwdt_activate_timer();\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int eurwdt_release(struct inode *inode, struct file *file)\r\n{\r\nif (eur_expect_close == 42)\r\neurwdt_disable_timer();\r\nelse {\r\npr_crit("Unexpected close, not stopping watchdog!\n");\r\neurwdt_ping();\r\n}\r\nclear_bit(0, &eurwdt_is_open);\r\neur_expect_close = 0;\r\nreturn 0;\r\n}\r\nstatic int eurwdt_notify_sys(struct notifier_block *this, unsigned long code,\r\nvoid *unused)\r\n{\r\nif (code == SYS_DOWN || code == SYS_HALT)\r\neurwdt_disable_timer();\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void __exit eurwdt_exit(void)\r\n{\r\neurwdt_lock_chip();\r\nmisc_deregister(&eurwdt_miscdev);\r\nunregister_reboot_notifier(&eurwdt_notifier);\r\nrelease_region(io, 2);\r\nfree_irq(irq, NULL);\r\n}\r\nstatic int __init eurwdt_init(void)\r\n{\r\nint ret;\r\nret = request_irq(irq, eurwdt_interrupt, 0, "eurwdt", NULL);\r\nif (ret) {\r\npr_err("IRQ %d is not free\n", irq);\r\ngoto out;\r\n}\r\nif (!request_region(io, 2, "eurwdt")) {\r\npr_err("IO %X is not free\n", io);\r\nret = -EBUSY;\r\ngoto outirq;\r\n}\r\nret = register_reboot_notifier(&eurwdt_notifier);\r\nif (ret) {\r\npr_err("can't register reboot notifier (err=%d)\n", ret);\r\ngoto outreg;\r\n}\r\nret = misc_register(&eurwdt_miscdev);\r\nif (ret) {\r\npr_err("can't misc_register on minor=%d\n", WATCHDOG_MINOR);\r\ngoto outreboot;\r\n}\r\neurwdt_unlock_chip();\r\nret = 0;\r\npr_info("Eurotech WDT driver 0.01 at %X (Interrupt %d) - timeout event: %s\n",\r\nio, irq, (!strcmp("int", ev) ? "int" : "reboot"));\r\nout:\r\nreturn ret;\r\noutreboot:\r\nunregister_reboot_notifier(&eurwdt_notifier);\r\noutreg:\r\nrelease_region(io, 2);\r\noutirq:\r\nfree_irq(irq, NULL);\r\ngoto out;\r\n}
