static inline int is_intr(u8 rtc_intr)\r\n{\r\nif (!(rtc_intr & RTC_IRQF))\r\nreturn 0;\r\nreturn rtc_intr & RTC_IRQMASK;\r\n}\r\nstatic inline int is_hpet_enabled(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline int hpet_mask_rtc_irq_bit(unsigned long mask)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline int hpet_set_rtc_irq_bit(unsigned long mask)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline int\r\nhpet_set_alarm_time(unsigned char hrs, unsigned char min, unsigned char sec)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline int hpet_set_periodic_freq(unsigned long freq)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline int hpet_rtc_dropped_irq(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline int hpet_rtc_timer_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline int hpet_register_irq_handler(irq_handler_t handler)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline int hpet_unregister_irq_handler(irq_handler_t handler)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline unsigned char cmos_read_bank2(unsigned char addr)\r\n{\r\noutb(addr, RTC_PORT(2));\r\nreturn inb(RTC_PORT(3));\r\n}\r\nstatic inline void cmos_write_bank2(unsigned char val, unsigned char addr)\r\n{\r\noutb(addr, RTC_PORT(2));\r\noutb(val, RTC_PORT(3));\r\n}\r\nstatic inline unsigned char cmos_read_bank2(unsigned char addr)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void cmos_write_bank2(unsigned char val, unsigned char addr)\r\n{\r\n}\r\nstatic int cmos_read_time(struct device *dev, struct rtc_time *t)\r\n{\r\nget_rtc_time(t);\r\nreturn 0;\r\n}\r\nstatic int cmos_set_time(struct device *dev, struct rtc_time *t)\r\n{\r\nreturn set_rtc_time(t);\r\n}\r\nstatic int cmos_read_alarm(struct device *dev, struct rtc_wkalrm *t)\r\n{\r\nstruct cmos_rtc *cmos = dev_get_drvdata(dev);\r\nunsigned char rtc_control;\r\nif (!is_valid_irq(cmos->irq))\r\nreturn -EIO;\r\nt->time.tm_mday = -1;\r\nt->time.tm_mon = -1;\r\nspin_lock_irq(&rtc_lock);\r\nt->time.tm_sec = CMOS_READ(RTC_SECONDS_ALARM);\r\nt->time.tm_min = CMOS_READ(RTC_MINUTES_ALARM);\r\nt->time.tm_hour = CMOS_READ(RTC_HOURS_ALARM);\r\nif (cmos->day_alrm) {\r\nt->time.tm_mday = CMOS_READ(cmos->day_alrm) & 0x3f;\r\nif (!t->time.tm_mday)\r\nt->time.tm_mday = -1;\r\nif (cmos->mon_alrm) {\r\nt->time.tm_mon = CMOS_READ(cmos->mon_alrm);\r\nif (!t->time.tm_mon)\r\nt->time.tm_mon = -1;\r\n}\r\n}\r\nrtc_control = CMOS_READ(RTC_CONTROL);\r\nspin_unlock_irq(&rtc_lock);\r\nif (!(rtc_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {\r\nif (((unsigned)t->time.tm_sec) < 0x60)\r\nt->time.tm_sec = bcd2bin(t->time.tm_sec);\r\nelse\r\nt->time.tm_sec = -1;\r\nif (((unsigned)t->time.tm_min) < 0x60)\r\nt->time.tm_min = bcd2bin(t->time.tm_min);\r\nelse\r\nt->time.tm_min = -1;\r\nif (((unsigned)t->time.tm_hour) < 0x24)\r\nt->time.tm_hour = bcd2bin(t->time.tm_hour);\r\nelse\r\nt->time.tm_hour = -1;\r\nif (cmos->day_alrm) {\r\nif (((unsigned)t->time.tm_mday) <= 0x31)\r\nt->time.tm_mday = bcd2bin(t->time.tm_mday);\r\nelse\r\nt->time.tm_mday = -1;\r\nif (cmos->mon_alrm) {\r\nif (((unsigned)t->time.tm_mon) <= 0x12)\r\nt->time.tm_mon = bcd2bin(t->time.tm_mon)-1;\r\nelse\r\nt->time.tm_mon = -1;\r\n}\r\n}\r\n}\r\nt->time.tm_year = -1;\r\nt->enabled = !!(rtc_control & RTC_AIE);\r\nt->pending = 0;\r\nreturn 0;\r\n}\r\nstatic void cmos_checkintr(struct cmos_rtc *cmos, unsigned char rtc_control)\r\n{\r\nunsigned char rtc_intr;\r\nrtc_intr = CMOS_READ(RTC_INTR_FLAGS);\r\nif (is_hpet_enabled())\r\nreturn;\r\nrtc_intr &= (rtc_control & RTC_IRQMASK) | RTC_IRQF;\r\nif (is_intr(rtc_intr))\r\nrtc_update_irq(cmos->rtc, 1, rtc_intr);\r\n}\r\nstatic void cmos_irq_enable(struct cmos_rtc *cmos, unsigned char mask)\r\n{\r\nunsigned char rtc_control;\r\nrtc_control = CMOS_READ(RTC_CONTROL);\r\ncmos_checkintr(cmos, rtc_control);\r\nrtc_control |= mask;\r\nCMOS_WRITE(rtc_control, RTC_CONTROL);\r\nhpet_set_rtc_irq_bit(mask);\r\ncmos_checkintr(cmos, rtc_control);\r\n}\r\nstatic void cmos_irq_disable(struct cmos_rtc *cmos, unsigned char mask)\r\n{\r\nunsigned char rtc_control;\r\nrtc_control = CMOS_READ(RTC_CONTROL);\r\nrtc_control &= ~mask;\r\nCMOS_WRITE(rtc_control, RTC_CONTROL);\r\nhpet_mask_rtc_irq_bit(mask);\r\ncmos_checkintr(cmos, rtc_control);\r\n}\r\nstatic int cmos_set_alarm(struct device *dev, struct rtc_wkalrm *t)\r\n{\r\nstruct cmos_rtc *cmos = dev_get_drvdata(dev);\r\nunsigned char mon, mday, hrs, min, sec, rtc_control;\r\nif (!is_valid_irq(cmos->irq))\r\nreturn -EIO;\r\nmon = t->time.tm_mon + 1;\r\nmday = t->time.tm_mday;\r\nhrs = t->time.tm_hour;\r\nmin = t->time.tm_min;\r\nsec = t->time.tm_sec;\r\nrtc_control = CMOS_READ(RTC_CONTROL);\r\nif (!(rtc_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {\r\nmon = (mon <= 12) ? bin2bcd(mon) : 0xff;\r\nmday = (mday >= 1 && mday <= 31) ? bin2bcd(mday) : 0xff;\r\nhrs = (hrs < 24) ? bin2bcd(hrs) : 0xff;\r\nmin = (min < 60) ? bin2bcd(min) : 0xff;\r\nsec = (sec < 60) ? bin2bcd(sec) : 0xff;\r\n}\r\nspin_lock_irq(&rtc_lock);\r\ncmos_irq_disable(cmos, RTC_AIE);\r\nCMOS_WRITE(hrs, RTC_HOURS_ALARM);\r\nCMOS_WRITE(min, RTC_MINUTES_ALARM);\r\nCMOS_WRITE(sec, RTC_SECONDS_ALARM);\r\nif (cmos->day_alrm) {\r\nCMOS_WRITE(mday, cmos->day_alrm);\r\nif (cmos->mon_alrm)\r\nCMOS_WRITE(mon, cmos->mon_alrm);\r\n}\r\nhpet_set_alarm_time(t->time.tm_hour, t->time.tm_min, t->time.tm_sec);\r\nif (t->enabled)\r\ncmos_irq_enable(cmos, RTC_AIE);\r\nspin_unlock_irq(&rtc_lock);\r\nreturn 0;\r\n}\r\nstatic int __init set_alarm_disable_quirk(const struct dmi_system_id *id)\r\n{\r\nalarm_disable_quirk = true;\r\npr_info("BIOS has alarm-disable quirk - RTC alarms disabled\n");\r\nreturn 0;\r\n}\r\nstatic int cmos_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct cmos_rtc *cmos = dev_get_drvdata(dev);\r\nunsigned long flags;\r\nif (!is_valid_irq(cmos->irq))\r\nreturn -EINVAL;\r\nif (alarm_disable_quirk)\r\nreturn 0;\r\nspin_lock_irqsave(&rtc_lock, flags);\r\nif (enabled)\r\ncmos_irq_enable(cmos, RTC_AIE);\r\nelse\r\ncmos_irq_disable(cmos, RTC_AIE);\r\nspin_unlock_irqrestore(&rtc_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int cmos_procfs(struct device *dev, struct seq_file *seq)\r\n{\r\nstruct cmos_rtc *cmos = dev_get_drvdata(dev);\r\nunsigned char rtc_control, valid;\r\nspin_lock_irq(&rtc_lock);\r\nrtc_control = CMOS_READ(RTC_CONTROL);\r\nvalid = CMOS_READ(RTC_VALID);\r\nspin_unlock_irq(&rtc_lock);\r\nseq_printf(seq,\r\n"periodic_IRQ\t: %s\n"\r\n"update_IRQ\t: %s\n"\r\n"HPET_emulated\t: %s\n"\r\n"BCD\t\t: %s\n"\r\n"DST_enable\t: %s\n"\r\n"periodic_freq\t: %d\n"\r\n"batt_status\t: %s\n",\r\n(rtc_control & RTC_PIE) ? "yes" : "no",\r\n(rtc_control & RTC_UIE) ? "yes" : "no",\r\nis_hpet_enabled() ? "yes" : "no",\r\n(rtc_control & RTC_DM_BINARY) ? "no" : "yes",\r\n(rtc_control & RTC_DST_EN) ? "yes" : "no",\r\ncmos->rtc->irq_freq,\r\n(valid & RTC_VRT) ? "okay" : "dead");\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\ncmos_nvram_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nint retval;\r\nif (unlikely(off >= attr->size))\r\nreturn 0;\r\nif (unlikely(off < 0))\r\nreturn -EINVAL;\r\nif ((off + count) > attr->size)\r\ncount = attr->size - off;\r\noff += NVRAM_OFFSET;\r\nspin_lock_irq(&rtc_lock);\r\nfor (retval = 0; count; count--, off++, retval++) {\r\nif (off < 128)\r\n*buf++ = CMOS_READ(off);\r\nelse if (can_bank2)\r\n*buf++ = cmos_read_bank2(off);\r\nelse\r\nbreak;\r\n}\r\nspin_unlock_irq(&rtc_lock);\r\nreturn retval;\r\n}\r\nstatic ssize_t\r\ncmos_nvram_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct cmos_rtc *cmos;\r\nint retval;\r\ncmos = dev_get_drvdata(container_of(kobj, struct device, kobj));\r\nif (unlikely(off >= attr->size))\r\nreturn -EFBIG;\r\nif (unlikely(off < 0))\r\nreturn -EINVAL;\r\nif ((off + count) > attr->size)\r\ncount = attr->size - off;\r\noff += NVRAM_OFFSET;\r\nspin_lock_irq(&rtc_lock);\r\nfor (retval = 0; count; count--, off++, retval++) {\r\nif (off == cmos->day_alrm\r\n|| off == cmos->mon_alrm\r\n|| off == cmos->century)\r\nbuf++;\r\nelse if (off < 128)\r\nCMOS_WRITE(*buf++, off);\r\nelse if (can_bank2)\r\ncmos_write_bank2(*buf++, off);\r\nelse\r\nbreak;\r\n}\r\nspin_unlock_irq(&rtc_lock);\r\nreturn retval;\r\n}\r\nstatic irqreturn_t cmos_interrupt(int irq, void *p)\r\n{\r\nu8 irqstat;\r\nu8 rtc_control;\r\nspin_lock(&rtc_lock);\r\nirqstat = CMOS_READ(RTC_INTR_FLAGS);\r\nrtc_control = CMOS_READ(RTC_CONTROL);\r\nif (is_hpet_enabled())\r\nirqstat = (unsigned long)irq & 0xF0;\r\nif (!cmos_rtc.suspend_ctrl)\r\nirqstat &= (rtc_control & RTC_IRQMASK) | RTC_IRQF;\r\nelse\r\nirqstat &= (cmos_rtc.suspend_ctrl & RTC_IRQMASK) | RTC_IRQF;\r\nif (irqstat & RTC_AIE) {\r\ncmos_rtc.suspend_ctrl &= ~RTC_AIE;\r\nrtc_control &= ~RTC_AIE;\r\nCMOS_WRITE(rtc_control, RTC_CONTROL);\r\nhpet_mask_rtc_irq_bit(RTC_AIE);\r\nCMOS_READ(RTC_INTR_FLAGS);\r\n}\r\nspin_unlock(&rtc_lock);\r\nif (is_intr(irqstat)) {\r\nrtc_update_irq(p, 1, irqstat);\r\nreturn IRQ_HANDLED;\r\n} else\r\nreturn IRQ_NONE;\r\n}\r\nstatic int INITSECTION\r\ncmos_do_probe(struct device *dev, struct resource *ports, int rtc_irq)\r\n{\r\nstruct cmos_rtc_board_info *info = dev_get_platdata(dev);\r\nint retval = 0;\r\nunsigned char rtc_control;\r\nunsigned address_space;\r\nu32 flags = 0;\r\nif (cmos_rtc.dev)\r\nreturn -EBUSY;\r\nif (!ports)\r\nreturn -ENODEV;\r\nif (RTC_IOMAPPED)\r\nports = request_region(ports->start, resource_size(ports),\r\ndriver_name);\r\nelse\r\nports = request_mem_region(ports->start, resource_size(ports),\r\ndriver_name);\r\nif (!ports) {\r\ndev_dbg(dev, "i/o registers already in use\n");\r\nreturn -EBUSY;\r\n}\r\ncmos_rtc.irq = rtc_irq;\r\ncmos_rtc.iomem = ports;\r\n#if defined(CONFIG_ATARI)\r\naddress_space = 64;\r\n#elif defined(__i386__) || defined(__x86_64__) || defined(__arm__) \\r\n|| defined(__sparc__) || defined(__mips__) \\r\n|| defined(__powerpc__)\r\naddress_space = 128;\r\n#else\r\n#warning Assuming 128 bytes of RTC+NVRAM address space, not 64 bytes.\r\naddress_space = 128;\r\n#endif\r\nif (can_bank2 && ports->end > (ports->start + 1))\r\naddress_space = 256;\r\nif (info) {\r\nif (info->flags)\r\nflags = info->flags;\r\nif (info->address_space)\r\naddress_space = info->address_space;\r\nif (info->rtc_day_alarm && info->rtc_day_alarm < 128)\r\ncmos_rtc.day_alrm = info->rtc_day_alarm;\r\nif (info->rtc_mon_alarm && info->rtc_mon_alarm < 128)\r\ncmos_rtc.mon_alrm = info->rtc_mon_alarm;\r\nif (info->rtc_century && info->rtc_century < 128)\r\ncmos_rtc.century = info->rtc_century;\r\nif (info->wake_on && info->wake_off) {\r\ncmos_rtc.wake_on = info->wake_on;\r\ncmos_rtc.wake_off = info->wake_off;\r\n}\r\n}\r\ncmos_rtc.dev = dev;\r\ndev_set_drvdata(dev, &cmos_rtc);\r\ncmos_rtc.rtc = rtc_device_register(driver_name, dev,\r\n&cmos_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(cmos_rtc.rtc)) {\r\nretval = PTR_ERR(cmos_rtc.rtc);\r\ngoto cleanup0;\r\n}\r\nrename_region(ports, dev_name(&cmos_rtc.rtc->dev));\r\nspin_lock_irq(&rtc_lock);\r\nif (!(flags & CMOS_RTC_FLAGS_NOFREQ)) {\r\ncmos_rtc.rtc->irq_freq = 1024;\r\nhpet_set_periodic_freq(cmos_rtc.rtc->irq_freq);\r\nCMOS_WRITE(RTC_REF_CLCK_32KHZ | 0x06, RTC_FREQ_SELECT);\r\n}\r\nif (is_valid_irq(rtc_irq))\r\ncmos_irq_disable(&cmos_rtc, RTC_PIE | RTC_AIE | RTC_UIE);\r\nrtc_control = CMOS_READ(RTC_CONTROL);\r\nspin_unlock_irq(&rtc_lock);\r\nif (is_valid_irq(rtc_irq) && !(rtc_control & RTC_24H)) {\r\ndev_warn(dev, "only 24-hr supported\n");\r\nretval = -ENXIO;\r\ngoto cleanup1;\r\n}\r\nif (is_valid_irq(rtc_irq)) {\r\nirq_handler_t rtc_cmos_int_handler;\r\nif (is_hpet_enabled()) {\r\nrtc_cmos_int_handler = hpet_rtc_interrupt;\r\nretval = hpet_register_irq_handler(cmos_interrupt);\r\nif (retval) {\r\ndev_warn(dev, "hpet_register_irq_handler "\r\n" failed in rtc_init().");\r\ngoto cleanup1;\r\n}\r\n} else\r\nrtc_cmos_int_handler = cmos_interrupt;\r\nretval = request_irq(rtc_irq, rtc_cmos_int_handler,\r\n0, dev_name(&cmos_rtc.rtc->dev),\r\ncmos_rtc.rtc);\r\nif (retval < 0) {\r\ndev_dbg(dev, "IRQ %d is already in use\n", rtc_irq);\r\ngoto cleanup1;\r\n}\r\n}\r\nhpet_rtc_timer_init();\r\nnvram.size = address_space - NVRAM_OFFSET;\r\nretval = sysfs_create_bin_file(&dev->kobj, &nvram);\r\nif (retval < 0) {\r\ndev_dbg(dev, "can't create nvram file? %d\n", retval);\r\ngoto cleanup2;\r\n}\r\ndev_info(dev, "%s%s, %zd bytes nvram%s\n",\r\n!is_valid_irq(rtc_irq) ? "no alarms" :\r\ncmos_rtc.mon_alrm ? "alarms up to one year" :\r\ncmos_rtc.day_alrm ? "alarms up to one month" :\r\n"alarms up to one day",\r\ncmos_rtc.century ? ", y3k" : "",\r\nnvram.size,\r\nis_hpet_enabled() ? ", hpet irqs" : "");\r\nreturn 0;\r\ncleanup2:\r\nif (is_valid_irq(rtc_irq))\r\nfree_irq(rtc_irq, cmos_rtc.rtc);\r\ncleanup1:\r\ncmos_rtc.dev = NULL;\r\nrtc_device_unregister(cmos_rtc.rtc);\r\ncleanup0:\r\nif (RTC_IOMAPPED)\r\nrelease_region(ports->start, resource_size(ports));\r\nelse\r\nrelease_mem_region(ports->start, resource_size(ports));\r\nreturn retval;\r\n}\r\nstatic void cmos_do_shutdown(int rtc_irq)\r\n{\r\nspin_lock_irq(&rtc_lock);\r\nif (is_valid_irq(rtc_irq))\r\ncmos_irq_disable(&cmos_rtc, RTC_IRQMASK);\r\nspin_unlock_irq(&rtc_lock);\r\n}\r\nstatic void __exit cmos_do_remove(struct device *dev)\r\n{\r\nstruct cmos_rtc *cmos = dev_get_drvdata(dev);\r\nstruct resource *ports;\r\ncmos_do_shutdown(cmos->irq);\r\nsysfs_remove_bin_file(&dev->kobj, &nvram);\r\nif (is_valid_irq(cmos->irq)) {\r\nfree_irq(cmos->irq, cmos->rtc);\r\nhpet_unregister_irq_handler(cmos_interrupt);\r\n}\r\nrtc_device_unregister(cmos->rtc);\r\ncmos->rtc = NULL;\r\nports = cmos->iomem;\r\nif (RTC_IOMAPPED)\r\nrelease_region(ports->start, resource_size(ports));\r\nelse\r\nrelease_mem_region(ports->start, resource_size(ports));\r\ncmos->iomem = NULL;\r\ncmos->dev = NULL;\r\n}\r\nstatic int cmos_suspend(struct device *dev)\r\n{\r\nstruct cmos_rtc *cmos = dev_get_drvdata(dev);\r\nunsigned char tmp;\r\nspin_lock_irq(&rtc_lock);\r\ncmos->suspend_ctrl = tmp = CMOS_READ(RTC_CONTROL);\r\nif (tmp & (RTC_PIE|RTC_AIE|RTC_UIE)) {\r\nunsigned char mask;\r\nif (device_may_wakeup(dev))\r\nmask = RTC_IRQMASK & ~RTC_AIE;\r\nelse\r\nmask = RTC_IRQMASK;\r\ntmp &= ~mask;\r\nCMOS_WRITE(tmp, RTC_CONTROL);\r\nhpet_mask_rtc_irq_bit(mask);\r\ncmos_checkintr(cmos, tmp);\r\n}\r\nspin_unlock_irq(&rtc_lock);\r\nif (tmp & RTC_AIE) {\r\ncmos->enabled_wake = 1;\r\nif (cmos->wake_on)\r\ncmos->wake_on(dev);\r\nelse\r\nenable_irq_wake(cmos->irq);\r\n}\r\ndev_dbg(dev, "suspend%s, ctrl %02x\n",\r\n(tmp & RTC_AIE) ? ", alarm may wake" : "",\r\ntmp);\r\nreturn 0;\r\n}\r\nstatic inline int cmos_poweroff(struct device *dev)\r\n{\r\nreturn cmos_suspend(dev);\r\n}\r\nstatic int cmos_resume(struct device *dev)\r\n{\r\nstruct cmos_rtc *cmos = dev_get_drvdata(dev);\r\nunsigned char tmp;\r\nif (cmos->enabled_wake) {\r\nif (cmos->wake_off)\r\ncmos->wake_off(dev);\r\nelse\r\ndisable_irq_wake(cmos->irq);\r\ncmos->enabled_wake = 0;\r\n}\r\nspin_lock_irq(&rtc_lock);\r\ntmp = cmos->suspend_ctrl;\r\ncmos->suspend_ctrl = 0;\r\nif (tmp & RTC_IRQMASK) {\r\nunsigned char mask;\r\nif (device_may_wakeup(dev))\r\nhpet_rtc_timer_init();\r\ndo {\r\nCMOS_WRITE(tmp, RTC_CONTROL);\r\nhpet_set_rtc_irq_bit(tmp & RTC_IRQMASK);\r\nmask = CMOS_READ(RTC_INTR_FLAGS);\r\nmask &= (tmp & RTC_IRQMASK) | RTC_IRQF;\r\nif (!is_hpet_enabled() || !is_intr(mask))\r\nbreak;\r\nrtc_update_irq(cmos->rtc, 1, mask);\r\ntmp &= ~RTC_AIE;\r\nhpet_mask_rtc_irq_bit(RTC_AIE);\r\n} while (mask & RTC_AIE);\r\n}\r\nspin_unlock_irq(&rtc_lock);\r\ndev_dbg(dev, "resume, ctrl %02x\n", tmp);\r\nreturn 0;\r\n}\r\nstatic inline int cmos_poweroff(struct device *dev)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic u32 rtc_handler(void *context)\r\n{\r\nstruct device *dev = context;\r\npm_wakeup_event(dev, 0);\r\nacpi_clear_event(ACPI_EVENT_RTC);\r\nacpi_disable_event(ACPI_EVENT_RTC, 0);\r\nreturn ACPI_INTERRUPT_HANDLED;\r\n}\r\nstatic inline void rtc_wake_setup(struct device *dev)\r\n{\r\nacpi_install_fixed_event_handler(ACPI_EVENT_RTC, rtc_handler, dev);\r\nacpi_clear_event(ACPI_EVENT_RTC);\r\nacpi_disable_event(ACPI_EVENT_RTC, 0);\r\n}\r\nstatic void rtc_wake_on(struct device *dev)\r\n{\r\nacpi_clear_event(ACPI_EVENT_RTC);\r\nacpi_enable_event(ACPI_EVENT_RTC, 0);\r\n}\r\nstatic void rtc_wake_off(struct device *dev)\r\n{\r\nacpi_disable_event(ACPI_EVENT_RTC, 0);\r\n}\r\nstatic void cmos_wake_setup(struct device *dev)\r\n{\r\nif (acpi_disabled)\r\nreturn;\r\nrtc_wake_setup(dev);\r\nacpi_rtc_info.wake_on = rtc_wake_on;\r\nacpi_rtc_info.wake_off = rtc_wake_off;\r\nif (acpi_gbl_FADT.month_alarm && !acpi_gbl_FADT.day_alarm) {\r\ndev_dbg(dev, "bogus FADT month_alarm (%d)\n",\r\nacpi_gbl_FADT.month_alarm);\r\nacpi_gbl_FADT.month_alarm = 0;\r\n}\r\nacpi_rtc_info.rtc_day_alarm = acpi_gbl_FADT.day_alarm;\r\nacpi_rtc_info.rtc_mon_alarm = acpi_gbl_FADT.month_alarm;\r\nacpi_rtc_info.rtc_century = acpi_gbl_FADT.century;\r\nif (acpi_gbl_FADT.flags & ACPI_FADT_S4_RTC_WAKE)\r\ndev_info(dev, "RTC can wake from S4\n");\r\ndev->platform_data = &acpi_rtc_info;\r\ndevice_init_wakeup(dev, 1);\r\n}\r\nstatic void cmos_wake_setup(struct device *dev)\r\n{\r\n}\r\nstatic int cmos_pnp_probe(struct pnp_dev *pnp, const struct pnp_device_id *id)\r\n{\r\ncmos_wake_setup(&pnp->dev);\r\nif (pnp_port_start(pnp, 0) == 0x70 && !pnp_irq_valid(pnp, 0))\r\nreturn cmos_do_probe(&pnp->dev,\r\npnp_get_resource(pnp, IORESOURCE_IO, 0), 8);\r\nelse\r\nreturn cmos_do_probe(&pnp->dev,\r\npnp_get_resource(pnp, IORESOURCE_IO, 0),\r\npnp_irq(pnp, 0));\r\n}\r\nstatic void __exit cmos_pnp_remove(struct pnp_dev *pnp)\r\n{\r\ncmos_do_remove(&pnp->dev);\r\n}\r\nstatic void cmos_pnp_shutdown(struct pnp_dev *pnp)\r\n{\r\nstruct device *dev = &pnp->dev;\r\nstruct cmos_rtc *cmos = dev_get_drvdata(dev);\r\nif (system_state == SYSTEM_POWER_OFF && !cmos_poweroff(dev))\r\nreturn;\r\ncmos_do_shutdown(cmos->irq);\r\n}\r\nstatic __init void cmos_of_init(struct platform_device *pdev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct rtc_time time;\r\nint ret;\r\nconst __be32 *val;\r\nif (!node)\r\nreturn;\r\nval = of_get_property(node, "ctrl-reg", NULL);\r\nif (val)\r\nCMOS_WRITE(be32_to_cpup(val), RTC_CONTROL);\r\nval = of_get_property(node, "freq-reg", NULL);\r\nif (val)\r\nCMOS_WRITE(be32_to_cpup(val), RTC_FREQ_SELECT);\r\nget_rtc_time(&time);\r\nret = rtc_valid_tm(&time);\r\nif (ret) {\r\nstruct rtc_time def_time = {\r\n.tm_year = 1,\r\n.tm_mday = 1,\r\n};\r\nset_rtc_time(&def_time);\r\n}\r\n}\r\nstatic inline void cmos_of_init(struct platform_device *pdev) {}\r\nstatic int __init cmos_platform_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *resource;\r\nint irq;\r\ncmos_of_init(pdev);\r\ncmos_wake_setup(&pdev->dev);\r\nif (RTC_IOMAPPED)\r\nresource = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nelse\r\nresource = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nirq = -1;\r\nreturn cmos_do_probe(&pdev->dev, resource, irq);\r\n}\r\nstatic int __exit cmos_platform_remove(struct platform_device *pdev)\r\n{\r\ncmos_do_remove(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic void cmos_platform_shutdown(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct cmos_rtc *cmos = dev_get_drvdata(dev);\r\nif (system_state == SYSTEM_POWER_OFF && !cmos_poweroff(dev))\r\nreturn;\r\ncmos_do_shutdown(cmos->irq);\r\n}\r\nstatic int __init cmos_init(void)\r\n{\r\nint retval = 0;\r\n#ifdef CONFIG_PNP\r\nretval = pnp_register_driver(&cmos_pnp_driver);\r\nif (retval == 0)\r\npnp_driver_registered = true;\r\n#endif\r\nif (!cmos_rtc.dev) {\r\nretval = platform_driver_probe(&cmos_platform_driver,\r\ncmos_platform_probe);\r\nif (retval == 0)\r\nplatform_driver_registered = true;\r\n}\r\ndmi_check_system(rtc_quirks);\r\nif (retval == 0)\r\nreturn 0;\r\n#ifdef CONFIG_PNP\r\nif (pnp_driver_registered)\r\npnp_unregister_driver(&cmos_pnp_driver);\r\n#endif\r\nreturn retval;\r\n}\r\nstatic void __exit cmos_exit(void)\r\n{\r\n#ifdef CONFIG_PNP\r\nif (pnp_driver_registered)\r\npnp_unregister_driver(&cmos_pnp_driver);\r\n#endif\r\nif (platform_driver_registered)\r\nplatform_driver_unregister(&cmos_platform_driver);\r\n}
