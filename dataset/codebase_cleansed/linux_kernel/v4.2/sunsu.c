static unsigned int serial_in(struct uart_sunsu_port *up, int offset)\r\n{\r\noffset <<= up->port.regshift;\r\nswitch (up->port.iotype) {\r\ncase UPIO_HUB6:\r\noutb(up->port.hub6 - 1 + offset, up->port.iobase);\r\nreturn inb(up->port.iobase + 1);\r\ncase UPIO_MEM:\r\nreturn readb(up->port.membase + offset);\r\ndefault:\r\nreturn inb(up->port.iobase + offset);\r\n}\r\n}\r\nstatic void serial_out(struct uart_sunsu_port *up, int offset, int value)\r\n{\r\n#ifndef CONFIG_SPARC64\r\nif (offset == UART_MCR)\r\nvalue |= UART_MCR_OUT2;\r\n#endif\r\noffset <<= up->port.regshift;\r\nswitch (up->port.iotype) {\r\ncase UPIO_HUB6:\r\noutb(up->port.hub6 - 1 + offset, up->port.iobase);\r\noutb(value, up->port.iobase + 1);\r\nbreak;\r\ncase UPIO_MEM:\r\nwriteb(value, up->port.membase + offset);\r\nbreak;\r\ndefault:\r\noutb(value, up->port.iobase + offset);\r\n}\r\n}\r\nstatic void serial_icr_write(struct uart_sunsu_port *up, int offset, int value)\r\n{\r\nserial_out(up, UART_SCR, offset);\r\nserial_out(up, UART_ICR, value);\r\n}\r\nstatic int __enable_rsa(struct uart_sunsu_port *up)\r\n{\r\nunsigned char mode;\r\nint result;\r\nmode = serial_inp(up, UART_RSA_MSR);\r\nresult = mode & UART_RSA_MSR_FIFO;\r\nif (!result) {\r\nserial_outp(up, UART_RSA_MSR, mode | UART_RSA_MSR_FIFO);\r\nmode = serial_inp(up, UART_RSA_MSR);\r\nresult = mode & UART_RSA_MSR_FIFO;\r\n}\r\nif (result)\r\nup->port.uartclk = SERIAL_RSA_BAUD_BASE * 16;\r\nreturn result;\r\n}\r\nstatic void enable_rsa(struct uart_sunsu_port *up)\r\n{\r\nif (up->port.type == PORT_RSA) {\r\nif (up->port.uartclk != SERIAL_RSA_BAUD_BASE * 16) {\r\nspin_lock_irq(&up->port.lock);\r\n__enable_rsa(up);\r\nspin_unlock_irq(&up->port.lock);\r\n}\r\nif (up->port.uartclk == SERIAL_RSA_BAUD_BASE * 16)\r\nserial_outp(up, UART_RSA_FRR, 0);\r\n}\r\n}\r\nstatic void disable_rsa(struct uart_sunsu_port *up)\r\n{\r\nunsigned char mode;\r\nint result;\r\nif (up->port.type == PORT_RSA &&\r\nup->port.uartclk == SERIAL_RSA_BAUD_BASE * 16) {\r\nspin_lock_irq(&up->port.lock);\r\nmode = serial_inp(up, UART_RSA_MSR);\r\nresult = !(mode & UART_RSA_MSR_FIFO);\r\nif (!result) {\r\nserial_outp(up, UART_RSA_MSR, mode & ~UART_RSA_MSR_FIFO);\r\nmode = serial_inp(up, UART_RSA_MSR);\r\nresult = !(mode & UART_RSA_MSR_FIFO);\r\n}\r\nif (result)\r\nup->port.uartclk = SERIAL_RSA_BAUD_BASE_LO * 16;\r\nspin_unlock_irq(&up->port.lock);\r\n}\r\n}\r\nstatic inline void __stop_tx(struct uart_sunsu_port *p)\r\n{\r\nif (p->ier & UART_IER_THRI) {\r\np->ier &= ~UART_IER_THRI;\r\nserial_out(p, UART_IER, p->ier);\r\n}\r\n}\r\nstatic void sunsu_stop_tx(struct uart_port *port)\r\n{\r\nstruct uart_sunsu_port *up =\r\ncontainer_of(port, struct uart_sunsu_port, port);\r\n__stop_tx(up);\r\nif (up->port.type == PORT_16C950) {\r\nup->acr |= UART_ACR_TXDIS;\r\nserial_icr_write(up, UART_ACR, up->acr);\r\n}\r\n}\r\nstatic void sunsu_start_tx(struct uart_port *port)\r\n{\r\nstruct uart_sunsu_port *up =\r\ncontainer_of(port, struct uart_sunsu_port, port);\r\nif (!(up->ier & UART_IER_THRI)) {\r\nup->ier |= UART_IER_THRI;\r\nserial_out(up, UART_IER, up->ier);\r\n}\r\nif (up->port.type == PORT_16C950 && up->acr & UART_ACR_TXDIS) {\r\nup->acr &= ~UART_ACR_TXDIS;\r\nserial_icr_write(up, UART_ACR, up->acr);\r\n}\r\n}\r\nstatic void sunsu_stop_rx(struct uart_port *port)\r\n{\r\nstruct uart_sunsu_port *up =\r\ncontainer_of(port, struct uart_sunsu_port, port);\r\nup->ier &= ~UART_IER_RLSI;\r\nup->port.read_status_mask &= ~UART_LSR_DR;\r\nserial_out(up, UART_IER, up->ier);\r\n}\r\nstatic void sunsu_enable_ms(struct uart_port *port)\r\n{\r\nstruct uart_sunsu_port *up =\r\ncontainer_of(port, struct uart_sunsu_port, port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nup->ier |= UART_IER_MSI;\r\nserial_out(up, UART_IER, up->ier);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\n}\r\nstatic void\r\nreceive_chars(struct uart_sunsu_port *up, unsigned char *status)\r\n{\r\nstruct tty_port *port = &up->port.state->port;\r\nunsigned char ch, flag;\r\nint max_count = 256;\r\nint saw_console_brk = 0;\r\ndo {\r\nch = serial_inp(up, UART_RX);\r\nflag = TTY_NORMAL;\r\nup->port.icount.rx++;\r\nif (unlikely(*status & (UART_LSR_BI | UART_LSR_PE |\r\nUART_LSR_FE | UART_LSR_OE))) {\r\nif (*status & UART_LSR_BI) {\r\n*status &= ~(UART_LSR_FE | UART_LSR_PE);\r\nup->port.icount.brk++;\r\nif (up->port.cons != NULL &&\r\nup->port.line == up->port.cons->index)\r\nsaw_console_brk = 1;\r\nif (uart_handle_break(&up->port))\r\ngoto ignore_char;\r\n} else if (*status & UART_LSR_PE)\r\nup->port.icount.parity++;\r\nelse if (*status & UART_LSR_FE)\r\nup->port.icount.frame++;\r\nif (*status & UART_LSR_OE)\r\nup->port.icount.overrun++;\r\n*status &= up->port.read_status_mask;\r\nif (up->port.cons != NULL &&\r\nup->port.line == up->port.cons->index) {\r\n*status |= up->lsr_break_flag;\r\nup->lsr_break_flag = 0;\r\n}\r\nif (*status & UART_LSR_BI) {\r\nflag = TTY_BREAK;\r\n} else if (*status & UART_LSR_PE)\r\nflag = TTY_PARITY;\r\nelse if (*status & UART_LSR_FE)\r\nflag = TTY_FRAME;\r\n}\r\nif (uart_handle_sysrq_char(&up->port, ch))\r\ngoto ignore_char;\r\nif ((*status & up->port.ignore_status_mask) == 0)\r\ntty_insert_flip_char(port, ch, flag);\r\nif (*status & UART_LSR_OE)\r\ntty_insert_flip_char(port, 0, TTY_OVERRUN);\r\nignore_char:\r\n*status = serial_inp(up, UART_LSR);\r\n} while ((*status & UART_LSR_DR) && (max_count-- > 0));\r\nif (saw_console_brk)\r\nsun_do_break();\r\n}\r\nstatic void transmit_chars(struct uart_sunsu_port *up)\r\n{\r\nstruct circ_buf *xmit = &up->port.state->xmit;\r\nint count;\r\nif (up->port.x_char) {\r\nserial_outp(up, UART_TX, up->port.x_char);\r\nup->port.icount.tx++;\r\nup->port.x_char = 0;\r\nreturn;\r\n}\r\nif (uart_tx_stopped(&up->port)) {\r\nsunsu_stop_tx(&up->port);\r\nreturn;\r\n}\r\nif (uart_circ_empty(xmit)) {\r\n__stop_tx(up);\r\nreturn;\r\n}\r\ncount = up->port.fifosize;\r\ndo {\r\nserial_out(up, UART_TX, xmit->buf[xmit->tail]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nup->port.icount.tx++;\r\nif (uart_circ_empty(xmit))\r\nbreak;\r\n} while (--count > 0);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&up->port);\r\nif (uart_circ_empty(xmit))\r\n__stop_tx(up);\r\n}\r\nstatic void check_modem_status(struct uart_sunsu_port *up)\r\n{\r\nint status;\r\nstatus = serial_in(up, UART_MSR);\r\nif ((status & UART_MSR_ANY_DELTA) == 0)\r\nreturn;\r\nif (status & UART_MSR_TERI)\r\nup->port.icount.rng++;\r\nif (status & UART_MSR_DDSR)\r\nup->port.icount.dsr++;\r\nif (status & UART_MSR_DDCD)\r\nuart_handle_dcd_change(&up->port, status & UART_MSR_DCD);\r\nif (status & UART_MSR_DCTS)\r\nuart_handle_cts_change(&up->port, status & UART_MSR_CTS);\r\nwake_up_interruptible(&up->port.state->port.delta_msr_wait);\r\n}\r\nstatic irqreturn_t sunsu_serial_interrupt(int irq, void *dev_id)\r\n{\r\nstruct uart_sunsu_port *up = dev_id;\r\nunsigned long flags;\r\nunsigned char status;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\ndo {\r\nstatus = serial_inp(up, UART_LSR);\r\nif (status & UART_LSR_DR)\r\nreceive_chars(up, &status);\r\ncheck_modem_status(up);\r\nif (status & UART_LSR_THRE)\r\ntransmit_chars(up);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\ntty_flip_buffer_push(&up->port.state->port);\r\nspin_lock_irqsave(&up->port.lock, flags);\r\n} while (!(serial_in(up, UART_IIR) & UART_IIR_NO_INT));\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sunsu_change_mouse_baud(struct uart_sunsu_port *up)\r\n{\r\nunsigned int cur_cflag = up->cflag;\r\nint quot, new_baud;\r\nup->cflag &= ~CBAUD;\r\nup->cflag |= suncore_mouse_baud_cflag_next(cur_cflag, &new_baud);\r\nquot = up->port.uartclk / (16 * new_baud);\r\nsunsu_change_speed(&up->port, up->cflag, 0, quot);\r\n}\r\nstatic void receive_kbd_ms_chars(struct uart_sunsu_port *up, int is_break)\r\n{\r\ndo {\r\nunsigned char ch = serial_inp(up, UART_RX);\r\nif (up->su_type == SU_PORT_KBD) {\r\n#ifdef CONFIG_SERIO\r\nserio_interrupt(&up->serio, ch, 0);\r\n#endif\r\n} else if (up->su_type == SU_PORT_MS) {\r\nint ret = suncore_mouse_baud_detection(ch, is_break);\r\nswitch (ret) {\r\ncase 2:\r\nsunsu_change_mouse_baud(up);\r\ncase 1:\r\nbreak;\r\ncase 0:\r\n#ifdef CONFIG_SERIO\r\nserio_interrupt(&up->serio, ch, 0);\r\n#endif\r\nbreak;\r\n}\r\n}\r\n} while (serial_in(up, UART_LSR) & UART_LSR_DR);\r\n}\r\nstatic irqreturn_t sunsu_kbd_ms_interrupt(int irq, void *dev_id)\r\n{\r\nstruct uart_sunsu_port *up = dev_id;\r\nif (!(serial_in(up, UART_IIR) & UART_IIR_NO_INT)) {\r\nunsigned char status = serial_inp(up, UART_LSR);\r\nif ((status & UART_LSR_DR) || (status & UART_LSR_BI))\r\nreceive_kbd_ms_chars(up, (status & UART_LSR_BI) != 0);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int sunsu_tx_empty(struct uart_port *port)\r\n{\r\nstruct uart_sunsu_port *up =\r\ncontainer_of(port, struct uart_sunsu_port, port);\r\nunsigned long flags;\r\nunsigned int ret;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nret = serial_in(up, UART_LSR) & UART_LSR_TEMT ? TIOCSER_TEMT : 0;\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nreturn ret;\r\n}\r\nstatic unsigned int sunsu_get_mctrl(struct uart_port *port)\r\n{\r\nstruct uart_sunsu_port *up =\r\ncontainer_of(port, struct uart_sunsu_port, port);\r\nunsigned char status;\r\nunsigned int ret;\r\nstatus = serial_in(up, UART_MSR);\r\nret = 0;\r\nif (status & UART_MSR_DCD)\r\nret |= TIOCM_CAR;\r\nif (status & UART_MSR_RI)\r\nret |= TIOCM_RNG;\r\nif (status & UART_MSR_DSR)\r\nret |= TIOCM_DSR;\r\nif (status & UART_MSR_CTS)\r\nret |= TIOCM_CTS;\r\nreturn ret;\r\n}\r\nstatic void sunsu_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct uart_sunsu_port *up =\r\ncontainer_of(port, struct uart_sunsu_port, port);\r\nunsigned char mcr = 0;\r\nif (mctrl & TIOCM_RTS)\r\nmcr |= UART_MCR_RTS;\r\nif (mctrl & TIOCM_DTR)\r\nmcr |= UART_MCR_DTR;\r\nif (mctrl & TIOCM_OUT1)\r\nmcr |= UART_MCR_OUT1;\r\nif (mctrl & TIOCM_OUT2)\r\nmcr |= UART_MCR_OUT2;\r\nif (mctrl & TIOCM_LOOP)\r\nmcr |= UART_MCR_LOOP;\r\nserial_out(up, UART_MCR, mcr);\r\n}\r\nstatic void sunsu_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nstruct uart_sunsu_port *up =\r\ncontainer_of(port, struct uart_sunsu_port, port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nif (break_state == -1)\r\nup->lcr |= UART_LCR_SBC;\r\nelse\r\nup->lcr &= ~UART_LCR_SBC;\r\nserial_out(up, UART_LCR, up->lcr);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\n}\r\nstatic int sunsu_startup(struct uart_port *port)\r\n{\r\nstruct uart_sunsu_port *up =\r\ncontainer_of(port, struct uart_sunsu_port, port);\r\nunsigned long flags;\r\nint retval;\r\nif (up->port.type == PORT_16C950) {\r\nup->acr = 0;\r\nserial_outp(up, UART_LCR, 0xBF);\r\nserial_outp(up, UART_EFR, UART_EFR_ECB);\r\nserial_outp(up, UART_IER, 0);\r\nserial_outp(up, UART_LCR, 0);\r\nserial_icr_write(up, UART_CSR, 0);\r\nserial_outp(up, UART_LCR, 0xBF);\r\nserial_outp(up, UART_EFR, UART_EFR_ECB);\r\nserial_outp(up, UART_LCR, 0);\r\n}\r\n#ifdef CONFIG_SERIAL_8250_RSA\r\nenable_rsa(up);\r\n#endif\r\nif (uart_config[up->port.type].flags & UART_CLEAR_FIFO) {\r\nserial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO);\r\nserial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO |\r\nUART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);\r\nserial_outp(up, UART_FCR, 0);\r\n}\r\n(void) serial_inp(up, UART_LSR);\r\n(void) serial_inp(up, UART_RX);\r\n(void) serial_inp(up, UART_IIR);\r\n(void) serial_inp(up, UART_MSR);\r\nif (!(up->port.flags & UPF_BUGGY_UART) &&\r\n(serial_inp(up, UART_LSR) == 0xff)) {\r\nprintk("ttyS%d: LSR safety check engaged!\n", up->port.line);\r\nreturn -ENODEV;\r\n}\r\nif (up->su_type != SU_PORT_PORT) {\r\nretval = request_irq(up->port.irq, sunsu_kbd_ms_interrupt,\r\nIRQF_SHARED, su_typev[up->su_type], up);\r\n} else {\r\nretval = request_irq(up->port.irq, sunsu_serial_interrupt,\r\nIRQF_SHARED, su_typev[up->su_type], up);\r\n}\r\nif (retval) {\r\nprintk("su: Cannot register IRQ %d\n", up->port.irq);\r\nreturn retval;\r\n}\r\nserial_outp(up, UART_LCR, UART_LCR_WLEN8);\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nup->port.mctrl |= TIOCM_OUT2;\r\nsunsu_set_mctrl(&up->port, up->port.mctrl);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nup->ier = UART_IER_RLSI | UART_IER_RDI;\r\nserial_outp(up, UART_IER, up->ier);\r\nif (up->port.flags & UPF_FOURPORT) {\r\nunsigned int icp;\r\nicp = (up->port.iobase & 0xfe0) | 0x01f;\r\noutb_p(0x80, icp);\r\n(void) inb_p(icp);\r\n}\r\n(void) serial_inp(up, UART_LSR);\r\n(void) serial_inp(up, UART_RX);\r\n(void) serial_inp(up, UART_IIR);\r\n(void) serial_inp(up, UART_MSR);\r\nreturn 0;\r\n}\r\nstatic void sunsu_shutdown(struct uart_port *port)\r\n{\r\nstruct uart_sunsu_port *up =\r\ncontainer_of(port, struct uart_sunsu_port, port);\r\nunsigned long flags;\r\nup->ier = 0;\r\nserial_outp(up, UART_IER, 0);\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nif (up->port.flags & UPF_FOURPORT) {\r\ninb((up->port.iobase & 0xfe0) | 0x1f);\r\nup->port.mctrl |= TIOCM_OUT1;\r\n} else\r\nup->port.mctrl &= ~TIOCM_OUT2;\r\nsunsu_set_mctrl(&up->port, up->port.mctrl);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nserial_out(up, UART_LCR, serial_inp(up, UART_LCR) & ~UART_LCR_SBC);\r\nserial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO |\r\nUART_FCR_CLEAR_RCVR |\r\nUART_FCR_CLEAR_XMIT);\r\nserial_outp(up, UART_FCR, 0);\r\n#ifdef CONFIG_SERIAL_8250_RSA\r\ndisable_rsa(up);\r\n#endif\r\n(void) serial_in(up, UART_RX);\r\nfree_irq(up->port.irq, up);\r\n}\r\nstatic void\r\nsunsu_change_speed(struct uart_port *port, unsigned int cflag,\r\nunsigned int iflag, unsigned int quot)\r\n{\r\nstruct uart_sunsu_port *up =\r\ncontainer_of(port, struct uart_sunsu_port, port);\r\nunsigned char cval, fcr = 0;\r\nunsigned long flags;\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\ncval = 0x00;\r\nbreak;\r\ncase CS6:\r\ncval = 0x01;\r\nbreak;\r\ncase CS7:\r\ncval = 0x02;\r\nbreak;\r\ndefault:\r\ncase CS8:\r\ncval = 0x03;\r\nbreak;\r\n}\r\nif (cflag & CSTOPB)\r\ncval |= 0x04;\r\nif (cflag & PARENB)\r\ncval |= UART_LCR_PARITY;\r\nif (!(cflag & PARODD))\r\ncval |= UART_LCR_EPAR;\r\n#ifdef CMSPAR\r\nif (cflag & CMSPAR)\r\ncval |= UART_LCR_SPAR;\r\n#endif\r\nif ((quot & 0xff) == 0 && up->port.type == PORT_16C950 &&\r\nup->rev == 0x5201)\r\nquot ++;\r\nif (uart_config[up->port.type].flags & UART_USE_FIFO) {\r\nif ((up->port.uartclk / quot) < (2400 * 16))\r\nfcr = UART_FCR_ENABLE_FIFO | UART_FCR_TRIGGER_1;\r\n#ifdef CONFIG_SERIAL_8250_RSA\r\nelse if (up->port.type == PORT_RSA)\r\nfcr = UART_FCR_ENABLE_FIFO | UART_FCR_TRIGGER_14;\r\n#endif\r\nelse\r\nfcr = UART_FCR_ENABLE_FIFO | UART_FCR_TRIGGER_8;\r\n}\r\nif (up->port.type == PORT_16750)\r\nfcr |= UART_FCR7_64BYTE;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nuart_update_timeout(port, cflag, (port->uartclk / (16 * quot)));\r\nup->port.read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;\r\nif (iflag & INPCK)\r\nup->port.read_status_mask |= UART_LSR_FE | UART_LSR_PE;\r\nif (iflag & (IGNBRK | BRKINT | PARMRK))\r\nup->port.read_status_mask |= UART_LSR_BI;\r\nup->port.ignore_status_mask = 0;\r\nif (iflag & IGNPAR)\r\nup->port.ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;\r\nif (iflag & IGNBRK) {\r\nup->port.ignore_status_mask |= UART_LSR_BI;\r\nif (iflag & IGNPAR)\r\nup->port.ignore_status_mask |= UART_LSR_OE;\r\n}\r\nif ((cflag & CREAD) == 0)\r\nup->port.ignore_status_mask |= UART_LSR_DR;\r\nup->ier &= ~UART_IER_MSI;\r\nif (UART_ENABLE_MS(&up->port, cflag))\r\nup->ier |= UART_IER_MSI;\r\nserial_out(up, UART_IER, up->ier);\r\nif (uart_config[up->port.type].flags & UART_STARTECH) {\r\nserial_outp(up, UART_LCR, 0xBF);\r\nserial_outp(up, UART_EFR, cflag & CRTSCTS ? UART_EFR_CTS :0);\r\n}\r\nserial_outp(up, UART_LCR, cval | UART_LCR_DLAB);\r\nserial_outp(up, UART_DLL, quot & 0xff);\r\nserial_outp(up, UART_DLM, quot >> 8);\r\nif (up->port.type == PORT_16750)\r\nserial_outp(up, UART_FCR, fcr);\r\nserial_outp(up, UART_LCR, cval);\r\nup->lcr = cval;\r\nif (up->port.type != PORT_16750) {\r\nif (fcr & UART_FCR_ENABLE_FIFO) {\r\nserial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO);\r\n}\r\nserial_outp(up, UART_FCR, fcr);\r\n}\r\nup->cflag = cflag;\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\n}\r\nstatic void\r\nsunsu_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nunsigned int baud, quot;\r\nbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);\r\nquot = uart_get_divisor(port, baud);\r\nsunsu_change_speed(port, termios->c_cflag, termios->c_iflag, quot);\r\n}\r\nstatic void sunsu_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int sunsu_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void sunsu_config_port(struct uart_port *port, int flags)\r\n{\r\nstruct uart_sunsu_port *up =\r\ncontainer_of(port, struct uart_sunsu_port, port);\r\nif (flags & UART_CONFIG_TYPE) {\r\nport->type = up->type_probed;\r\n}\r\n}\r\nstatic int\r\nsunsu_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic const char *\r\nsunsu_type(struct uart_port *port)\r\n{\r\nint type = port->type;\r\nif (type >= ARRAY_SIZE(uart_config))\r\ntype = 0;\r\nreturn uart_config[type].name;\r\n}\r\nstatic int sunsu_serio_write(struct serio *serio, unsigned char ch)\r\n{\r\nstruct uart_sunsu_port *up = serio->port_data;\r\nunsigned long flags;\r\nint lsr;\r\nspin_lock_irqsave(&sunsu_serio_lock, flags);\r\ndo {\r\nlsr = serial_in(up, UART_LSR);\r\n} while (!(lsr & UART_LSR_THRE));\r\nserial_out(up, UART_TX, ch);\r\nspin_unlock_irqrestore(&sunsu_serio_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int sunsu_serio_open(struct serio *serio)\r\n{\r\nstruct uart_sunsu_port *up = serio->port_data;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&sunsu_serio_lock, flags);\r\nif (!up->serio_open) {\r\nup->serio_open = 1;\r\nret = 0;\r\n} else\r\nret = -EBUSY;\r\nspin_unlock_irqrestore(&sunsu_serio_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void sunsu_serio_close(struct serio *serio)\r\n{\r\nstruct uart_sunsu_port *up = serio->port_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sunsu_serio_lock, flags);\r\nup->serio_open = 0;\r\nspin_unlock_irqrestore(&sunsu_serio_lock, flags);\r\n}\r\nstatic void sunsu_autoconfig(struct uart_sunsu_port *up)\r\n{\r\nunsigned char status1, status2, scratch, scratch2, scratch3;\r\nunsigned char save_lcr, save_mcr;\r\nunsigned long flags;\r\nif (up->su_type == SU_PORT_NONE)\r\nreturn;\r\nup->type_probed = PORT_UNKNOWN;\r\nup->port.iotype = UPIO_MEM;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nif (!(up->port.flags & UPF_BUGGY_UART)) {\r\nscratch = serial_inp(up, UART_IER);\r\nserial_outp(up, UART_IER, 0);\r\n#ifdef __i386__\r\noutb(0xff, 0x080);\r\n#endif\r\nscratch2 = serial_inp(up, UART_IER);\r\nserial_outp(up, UART_IER, 0x0f);\r\n#ifdef __i386__\r\noutb(0, 0x080);\r\n#endif\r\nscratch3 = serial_inp(up, UART_IER);\r\nserial_outp(up, UART_IER, scratch);\r\nif (scratch2 != 0 || scratch3 != 0x0F)\r\ngoto out;\r\n}\r\nsave_mcr = serial_in(up, UART_MCR);\r\nsave_lcr = serial_in(up, UART_LCR);\r\nif (!(up->port.flags & UPF_SKIP_TEST)) {\r\nserial_outp(up, UART_MCR, UART_MCR_LOOP | 0x0A);\r\nstatus1 = serial_inp(up, UART_MSR) & 0xF0;\r\nserial_outp(up, UART_MCR, save_mcr);\r\nif (status1 != 0x90)\r\ngoto out;\r\n}\r\nserial_outp(up, UART_LCR, 0xBF);\r\nserial_outp(up, UART_EFR, 0);\r\nserial_outp(up, UART_LCR, 0);\r\nserial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO);\r\nscratch = serial_in(up, UART_IIR) >> 6;\r\nswitch (scratch) {\r\ncase 0:\r\nup->port.type = PORT_16450;\r\nbreak;\r\ncase 1:\r\nup->port.type = PORT_UNKNOWN;\r\nbreak;\r\ncase 2:\r\nup->port.type = PORT_16550;\r\nbreak;\r\ncase 3:\r\nup->port.type = PORT_16550A;\r\nbreak;\r\n}\r\nif (up->port.type == PORT_16550A) {\r\nserial_outp(up, UART_LCR, UART_LCR_DLAB);\r\nif (serial_in(up, UART_EFR) == 0) {\r\nup->port.type = PORT_16650;\r\n} else {\r\nserial_outp(up, UART_LCR, 0xBF);\r\nif (serial_in(up, UART_EFR) == 0)\r\nup->port.type = PORT_16650V2;\r\n}\r\n}\r\nif (up->port.type == PORT_16550A) {\r\nserial_outp(up, UART_LCR, save_lcr | UART_LCR_DLAB);\r\nserial_outp(up, UART_FCR,\r\nUART_FCR_ENABLE_FIFO | UART_FCR7_64BYTE);\r\nscratch = serial_in(up, UART_IIR) >> 5;\r\nif (scratch == 7) {\r\nserial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO);\r\nserial_outp(up, UART_LCR, 0);\r\nserial_outp(up, UART_FCR,\r\nUART_FCR_ENABLE_FIFO | UART_FCR7_64BYTE);\r\nscratch = serial_in(up, UART_IIR) >> 5;\r\nif (scratch == 6)\r\nup->port.type = PORT_16750;\r\n}\r\nserial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO);\r\n}\r\nserial_outp(up, UART_LCR, save_lcr);\r\nif (up->port.type == PORT_16450) {\r\nscratch = serial_in(up, UART_SCR);\r\nserial_outp(up, UART_SCR, 0xa5);\r\nstatus1 = serial_in(up, UART_SCR);\r\nserial_outp(up, UART_SCR, 0x5a);\r\nstatus2 = serial_in(up, UART_SCR);\r\nserial_outp(up, UART_SCR, scratch);\r\nif ((status1 != 0xa5) || (status2 != 0x5a))\r\nup->port.type = PORT_8250;\r\n}\r\nup->port.fifosize = uart_config[up->port.type].dfl_xmit_fifo_size;\r\nif (up->port.type == PORT_UNKNOWN)\r\ngoto out;\r\nup->type_probed = up->port.type;\r\n#ifdef CONFIG_SERIAL_8250_RSA\r\nif (up->port.type == PORT_RSA)\r\nserial_outp(up, UART_RSA_FRR, 0);\r\n#endif\r\nserial_outp(up, UART_MCR, save_mcr);\r\nserial_outp(up, UART_FCR, (UART_FCR_ENABLE_FIFO |\r\nUART_FCR_CLEAR_RCVR |\r\nUART_FCR_CLEAR_XMIT));\r\nserial_outp(up, UART_FCR, 0);\r\n(void)serial_in(up, UART_RX);\r\nserial_outp(up, UART_IER, 0);\r\nout:\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\n}\r\nstatic int sunsu_kbd_ms_init(struct uart_sunsu_port *up)\r\n{\r\nint quot, baud;\r\n#ifdef CONFIG_SERIO\r\nstruct serio *serio;\r\n#endif\r\nif (up->su_type == SU_PORT_KBD) {\r\nup->cflag = B1200 | CS8 | CLOCAL | CREAD;\r\nbaud = 1200;\r\n} else {\r\nup->cflag = B4800 | CS8 | CLOCAL | CREAD;\r\nbaud = 4800;\r\n}\r\nquot = up->port.uartclk / (16 * baud);\r\nsunsu_autoconfig(up);\r\nif (up->port.type == PORT_UNKNOWN)\r\nreturn -ENODEV;\r\nprintk("%s: %s port at %llx, irq %u\n",\r\nup->port.dev->of_node->full_name,\r\n(up->su_type == SU_PORT_KBD) ? "Keyboard" : "Mouse",\r\n(unsigned long long) up->port.mapbase,\r\nup->port.irq);\r\n#ifdef CONFIG_SERIO\r\nserio = &up->serio;\r\nserio->port_data = up;\r\nserio->id.type = SERIO_RS232;\r\nif (up->su_type == SU_PORT_KBD) {\r\nserio->id.proto = SERIO_SUNKBD;\r\nstrlcpy(serio->name, "sukbd", sizeof(serio->name));\r\n} else {\r\nserio->id.proto = SERIO_SUN;\r\nserio->id.extra = 1;\r\nstrlcpy(serio->name, "sums", sizeof(serio->name));\r\n}\r\nstrlcpy(serio->phys,\r\n(!(up->port.line & 1) ? "su/serio0" : "su/serio1"),\r\nsizeof(serio->phys));\r\nserio->write = sunsu_serio_write;\r\nserio->open = sunsu_serio_open;\r\nserio->close = sunsu_serio_close;\r\nserio->dev.parent = up->port.dev;\r\nserio_register_port(serio);\r\n#endif\r\nsunsu_change_speed(&up->port, up->cflag, 0, quot);\r\nsunsu_startup(&up->port);\r\nreturn 0;\r\n}\r\nstatic __inline__ void wait_for_xmitr(struct uart_sunsu_port *up)\r\n{\r\nunsigned int status, tmout = 10000;\r\ndo {\r\nstatus = serial_in(up, UART_LSR);\r\nif (status & UART_LSR_BI)\r\nup->lsr_break_flag = UART_LSR_BI;\r\nif (--tmout == 0)\r\nbreak;\r\nudelay(1);\r\n} while ((status & BOTH_EMPTY) != BOTH_EMPTY);\r\nif (up->port.flags & UPF_CONS_FLOW) {\r\ntmout = 1000000;\r\nwhile (--tmout &&\r\n((serial_in(up, UART_MSR) & UART_MSR_CTS) == 0))\r\nudelay(1);\r\n}\r\n}\r\nstatic void sunsu_console_putchar(struct uart_port *port, int ch)\r\n{\r\nstruct uart_sunsu_port *up =\r\ncontainer_of(port, struct uart_sunsu_port, port);\r\nwait_for_xmitr(up);\r\nserial_out(up, UART_TX, ch);\r\n}\r\nstatic void sunsu_console_write(struct console *co, const char *s,\r\nunsigned int count)\r\n{\r\nstruct uart_sunsu_port *up = &sunsu_ports[co->index];\r\nunsigned long flags;\r\nunsigned int ier;\r\nint locked = 1;\r\nif (up->port.sysrq || oops_in_progress)\r\nlocked = spin_trylock_irqsave(&up->port.lock, flags);\r\nelse\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nier = serial_in(up, UART_IER);\r\nserial_out(up, UART_IER, 0);\r\nuart_console_write(&up->port, s, count, sunsu_console_putchar);\r\nwait_for_xmitr(up);\r\nserial_out(up, UART_IER, ier);\r\nif (locked)\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\n}\r\nstatic int __init sunsu_console_setup(struct console *co, char *options)\r\n{\r\nstatic struct ktermios dummy;\r\nstruct ktermios termios;\r\nstruct uart_port *port;\r\nprintk("Console: ttyS%d (SU)\n",\r\n(sunsu_reg.minor - 64) + co->index);\r\nif (co->index > nr_inst)\r\nreturn -ENODEV;\r\nport = &sunsu_ports[co->index].port;\r\nspin_lock_init(&port->lock);\r\nsunserial_console_termios(co, port->dev->of_node);\r\nmemset(&termios, 0, sizeof(struct ktermios));\r\ntermios.c_cflag = co->cflag;\r\nport->mctrl |= TIOCM_DTR;\r\nport->ops->set_termios(port, &termios, &dummy);\r\nreturn 0;\r\n}\r\nstatic inline struct console *SUNSU_CONSOLE(void)\r\n{\r\nreturn &sunsu_console;\r\n}\r\nstatic enum su_type su_get_type(struct device_node *dp)\r\n{\r\nstruct device_node *ap = of_find_node_by_path("/aliases");\r\nif (ap) {\r\nconst char *keyb = of_get_property(ap, "keyboard", NULL);\r\nconst char *ms = of_get_property(ap, "mouse", NULL);\r\nif (keyb) {\r\nif (dp == of_find_node_by_path(keyb))\r\nreturn SU_PORT_KBD;\r\n}\r\nif (ms) {\r\nif (dp == of_find_node_by_path(ms))\r\nreturn SU_PORT_MS;\r\n}\r\n}\r\nreturn SU_PORT_PORT;\r\n}\r\nstatic int su_probe(struct platform_device *op)\r\n{\r\nstruct device_node *dp = op->dev.of_node;\r\nstruct uart_sunsu_port *up;\r\nstruct resource *rp;\r\nenum su_type type;\r\nbool ignore_line;\r\nint err;\r\ntype = su_get_type(dp);\r\nif (type == SU_PORT_PORT) {\r\nif (nr_inst >= UART_NR)\r\nreturn -EINVAL;\r\nup = &sunsu_ports[nr_inst];\r\n} else {\r\nup = kzalloc(sizeof(*up), GFP_KERNEL);\r\nif (!up)\r\nreturn -ENOMEM;\r\n}\r\nup->port.line = nr_inst;\r\nspin_lock_init(&up->port.lock);\r\nup->su_type = type;\r\nrp = &op->resource[0];\r\nup->port.mapbase = rp->start;\r\nup->reg_size = resource_size(rp);\r\nup->port.membase = of_ioremap(rp, 0, up->reg_size, "su");\r\nif (!up->port.membase) {\r\nif (type != SU_PORT_PORT)\r\nkfree(up);\r\nreturn -ENOMEM;\r\n}\r\nup->port.irq = op->archdata.irqs[0];\r\nup->port.dev = &op->dev;\r\nup->port.type = PORT_UNKNOWN;\r\nup->port.uartclk = (SU_BASE_BAUD * 16);\r\nerr = 0;\r\nif (up->su_type == SU_PORT_KBD || up->su_type == SU_PORT_MS) {\r\nerr = sunsu_kbd_ms_init(up);\r\nif (err) {\r\nof_iounmap(&op->resource[0],\r\nup->port.membase, up->reg_size);\r\nkfree(up);\r\nreturn err;\r\n}\r\nplatform_set_drvdata(op, up);\r\nnr_inst++;\r\nreturn 0;\r\n}\r\nup->port.flags |= UPF_BOOT_AUTOCONF;\r\nsunsu_autoconfig(up);\r\nerr = -ENODEV;\r\nif (up->port.type == PORT_UNKNOWN)\r\ngoto out_unmap;\r\nup->port.ops = &sunsu_pops;\r\nignore_line = false;\r\nif (!strcmp(dp->name, "rsc-console") ||\r\n!strcmp(dp->name, "lom-console"))\r\nignore_line = true;\r\nsunserial_console_match(SUNSU_CONSOLE(), dp,\r\n&sunsu_reg, up->port.line,\r\nignore_line);\r\nerr = uart_add_one_port(&sunsu_reg, &up->port);\r\nif (err)\r\ngoto out_unmap;\r\nplatform_set_drvdata(op, up);\r\nnr_inst++;\r\nreturn 0;\r\nout_unmap:\r\nof_iounmap(&op->resource[0], up->port.membase, up->reg_size);\r\nreturn err;\r\n}\r\nstatic int su_remove(struct platform_device *op)\r\n{\r\nstruct uart_sunsu_port *up = platform_get_drvdata(op);\r\nbool kbdms = false;\r\nif (up->su_type == SU_PORT_MS ||\r\nup->su_type == SU_PORT_KBD)\r\nkbdms = true;\r\nif (kbdms) {\r\n#ifdef CONFIG_SERIO\r\nserio_unregister_port(&up->serio);\r\n#endif\r\n} else if (up->port.type != PORT_UNKNOWN)\r\nuart_remove_one_port(&sunsu_reg, &up->port);\r\nif (up->port.membase)\r\nof_iounmap(&op->resource[0], up->port.membase, up->reg_size);\r\nif (kbdms)\r\nkfree(up);\r\nreturn 0;\r\n}\r\nstatic int __init sunsu_init(void)\r\n{\r\nstruct device_node *dp;\r\nint err;\r\nint num_uart = 0;\r\nfor_each_node_by_name(dp, "su") {\r\nif (su_get_type(dp) == SU_PORT_PORT)\r\nnum_uart++;\r\n}\r\nfor_each_node_by_name(dp, "su_pnp") {\r\nif (su_get_type(dp) == SU_PORT_PORT)\r\nnum_uart++;\r\n}\r\nfor_each_node_by_name(dp, "serial") {\r\nif (of_device_is_compatible(dp, "su")) {\r\nif (su_get_type(dp) == SU_PORT_PORT)\r\nnum_uart++;\r\n}\r\n}\r\nfor_each_node_by_type(dp, "serial") {\r\nif (of_device_is_compatible(dp, "su")) {\r\nif (su_get_type(dp) == SU_PORT_PORT)\r\nnum_uart++;\r\n}\r\n}\r\nif (num_uart) {\r\nerr = sunserial_register_minors(&sunsu_reg, num_uart);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = platform_driver_register(&su_driver);\r\nif (err && num_uart)\r\nsunserial_unregister_minors(&sunsu_reg, num_uart);\r\nreturn err;\r\n}\r\nstatic void __exit sunsu_exit(void)\r\n{\r\nplatform_driver_unregister(&su_driver);\r\nif (sunsu_reg.nr)\r\nsunserial_unregister_minors(&sunsu_reg, sunsu_reg.nr);\r\n}
