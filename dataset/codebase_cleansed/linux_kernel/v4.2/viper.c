static void viper_icr_set_bit(unsigned int bit)\r\n{\r\nicr |= bit;\r\nVIPER_ICR = icr;\r\n}\r\nstatic void viper_icr_clear_bit(unsigned int bit)\r\n{\r\nicr &= ~bit;\r\nVIPER_ICR = icr;\r\n}\r\nstatic void viper_cf_reset(int state)\r\n{\r\nif (state)\r\nviper_icr_set_bit(VIPER_ICR_CF_RST);\r\nelse\r\nviper_icr_clear_bit(VIPER_ICR_CF_RST);\r\n}\r\nstatic u8 viper_hw_version(void)\r\n{\r\nu8 v1, v2;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nVIPER_VERSION = 0;\r\nv1 = VIPER_VERSION;\r\nVIPER_VERSION = 0xff;\r\nv2 = VIPER_VERSION;\r\nv1 = (v1 != v2 || v1 == 0xff) ? 0 : v1;\r\nlocal_irq_restore(flags);\r\nreturn v1;\r\n}\r\nstatic int viper_cpu_suspend(void)\r\n{\r\nviper_icr_set_bit(VIPER_ICR_R_DIS);\r\nreturn 0;\r\n}\r\nstatic void viper_cpu_resume(void)\r\n{\r\nviper_icr_clear_bit(VIPER_ICR_R_DIS);\r\n}\r\nstatic void viper_set_core_cpu_voltage(unsigned long khz, int force)\r\n{\r\nint i = 0;\r\nunsigned int divisor = 0;\r\nconst char *v;\r\nif (khz < 200000) {\r\nv = "1.0"; divisor = 0xfff;\r\n} else if (khz < 300000) {\r\nv = "1.1"; divisor = 0xde5;\r\n} else {\r\nv = "1.3"; divisor = 0x325;\r\n}\r\npr_debug("viper: setting CPU core voltage to %sV at %d.%03dMHz\n",\r\nv, (int)khz / 1000, (int)khz % 1000);\r\n#define STEP 0x100\r\ndo {\r\nint step;\r\nif (force)\r\nstep = divisor;\r\nelse if (current_voltage_divisor < divisor - STEP)\r\nstep = current_voltage_divisor + STEP;\r\nelse if (current_voltage_divisor > divisor + STEP)\r\nstep = current_voltage_divisor - STEP;\r\nelse\r\nstep = divisor;\r\nforce = 0;\r\ngpio_set_value(VIPER_PSU_CLK_GPIO, 0);\r\ngpio_set_value(VIPER_PSU_nCS_LD_GPIO, 0);\r\nfor (i = 1 << 11 ; i > 0 ; i >>= 1) {\r\nudelay(1);\r\ngpio_set_value(VIPER_PSU_DATA_GPIO, step & i);\r\nudelay(1);\r\ngpio_set_value(VIPER_PSU_CLK_GPIO, 1);\r\nudelay(1);\r\ngpio_set_value(VIPER_PSU_CLK_GPIO, 0);\r\n}\r\nudelay(1);\r\ngpio_set_value(VIPER_PSU_nCS_LD_GPIO, 1);\r\nudelay(1);\r\ngpio_set_value(VIPER_PSU_nCS_LD_GPIO, 0);\r\ncurrent_voltage_divisor = step;\r\n} while (current_voltage_divisor != divisor);\r\n}\r\nstatic inline int viper_irq_to_bitmask(unsigned int irq)\r\n{\r\nreturn viper_isa_irq_map[irq - PXA_ISA_IRQ(0)];\r\n}\r\nstatic inline int viper_bit_to_irq(int bit)\r\n{\r\nreturn viper_isa_irqs[bit] + PXA_ISA_IRQ(0);\r\n}\r\nstatic void viper_ack_irq(struct irq_data *d)\r\n{\r\nint viper_irq = viper_irq_to_bitmask(d->irq);\r\nif (viper_irq & 0xff)\r\nVIPER_LO_IRQ_STATUS = viper_irq;\r\nelse\r\nVIPER_HI_IRQ_STATUS = (viper_irq >> 8);\r\n}\r\nstatic void viper_mask_irq(struct irq_data *d)\r\n{\r\nviper_irq_enabled_mask &= ~(viper_irq_to_bitmask(d->irq));\r\n}\r\nstatic void viper_unmask_irq(struct irq_data *d)\r\n{\r\nviper_irq_enabled_mask |= viper_irq_to_bitmask(d->irq);\r\n}\r\nstatic inline unsigned long viper_irq_pending(void)\r\n{\r\nreturn (VIPER_HI_IRQ_STATUS << 8 | VIPER_LO_IRQ_STATUS) &\r\nviper_irq_enabled_mask;\r\n}\r\nstatic void viper_irq_handler(unsigned int irq, struct irq_desc *desc)\r\n{\r\nunsigned long pending;\r\npending = viper_irq_pending();\r\ndo {\r\ndesc->irq_data.chip->irq_ack(&desc->irq_data);\r\nif (likely(pending)) {\r\nirq = viper_bit_to_irq(__ffs(pending));\r\ngeneric_handle_irq(irq);\r\n}\r\npending = viper_irq_pending();\r\n} while (pending);\r\n}\r\nstatic void __init viper_init_irq(void)\r\n{\r\nint level;\r\nint isa_irq;\r\npxa25x_init_irq();\r\nfor (level = 0; level < ARRAY_SIZE(viper_isa_irqs); level++) {\r\nisa_irq = viper_bit_to_irq(level);\r\nirq_set_chip_and_handler(isa_irq, &viper_irq_chip,\r\nhandle_edge_irq);\r\nset_irq_flags(isa_irq, IRQF_VALID | IRQF_PROBE);\r\n}\r\nirq_set_chained_handler(gpio_to_irq(VIPER_CPLD_GPIO),\r\nviper_irq_handler);\r\nirq_set_irq_type(gpio_to_irq(VIPER_CPLD_GPIO), IRQ_TYPE_EDGE_BOTH);\r\n}\r\nstatic int viper_backlight_init(struct device *dev)\r\n{\r\nint ret;\r\nret = gpio_request(VIPER_BCKLIGHT_EN_GPIO, "Backlight");\r\nif (ret)\r\ngoto err_request_bckl;\r\nret = gpio_request(VIPER_LCD_EN_GPIO, "LCD");\r\nif (ret)\r\ngoto err_request_lcd;\r\nret = gpio_direction_output(VIPER_BCKLIGHT_EN_GPIO, 0);\r\nif (ret)\r\ngoto err_dir;\r\nret = gpio_direction_output(VIPER_LCD_EN_GPIO, 0);\r\nif (ret)\r\ngoto err_dir;\r\nreturn 0;\r\nerr_dir:\r\ngpio_free(VIPER_LCD_EN_GPIO);\r\nerr_request_lcd:\r\ngpio_free(VIPER_BCKLIGHT_EN_GPIO);\r\nerr_request_bckl:\r\ndev_err(dev, "Failed to setup LCD GPIOs\n");\r\nreturn ret;\r\n}\r\nstatic int viper_backlight_notify(struct device *dev, int brightness)\r\n{\r\ngpio_set_value(VIPER_LCD_EN_GPIO, !!brightness);\r\ngpio_set_value(VIPER_BCKLIGHT_EN_GPIO, !!brightness);\r\nreturn brightness;\r\n}\r\nstatic void viper_backlight_exit(struct device *dev)\r\n{\r\ngpio_free(VIPER_LCD_EN_GPIO);\r\ngpio_free(VIPER_BCKLIGHT_EN_GPIO);\r\n}\r\nstatic void isp116x_delay(struct device *dev, int delay)\r\n{\r\nndelay(delay);\r\n}\r\nstatic int __init viper_tpm_setup(char *str)\r\n{\r\nreturn kstrtoul(str, 10, &viper_tpm) >= 0;\r\n}\r\nstatic void __init viper_tpm_init(void)\r\n{\r\nstruct platform_device *tpm_device;\r\nstruct i2c_gpio_platform_data i2c_tpm_data = {\r\n.sda_pin = VIPER_TPM_I2C_SDA_GPIO,\r\n.scl_pin = VIPER_TPM_I2C_SCL_GPIO,\r\n.udelay = 10,\r\n.timeout = HZ,\r\n};\r\nchar *errstr;\r\nif (!viper_tpm)\r\nreturn;\r\ntpm_device = platform_device_alloc("i2c-gpio", 2);\r\nif (tpm_device) {\r\nif (!platform_device_add_data(tpm_device,\r\n&i2c_tpm_data,\r\nsizeof(i2c_tpm_data))) {\r\nif (platform_device_add(tpm_device)) {\r\nerrstr = "register TPM i2c bus";\r\ngoto error_free_tpm;\r\n}\r\n} else {\r\nerrstr = "allocate TPM i2c bus data";\r\ngoto error_free_tpm;\r\n}\r\n} else {\r\nerrstr = "allocate TPM i2c device";\r\ngoto error_tpm;\r\n}\r\nreturn;\r\nerror_free_tpm:\r\nkfree(tpm_device);\r\nerror_tpm:\r\npr_err("viper: Couldn't %s, giving up\n", errstr);\r\n}\r\nstatic void __init viper_init_vcore_gpios(void)\r\n{\r\nif (gpio_request(VIPER_PSU_DATA_GPIO, "PSU data"))\r\ngoto err_request_data;\r\nif (gpio_request(VIPER_PSU_CLK_GPIO, "PSU clock"))\r\ngoto err_request_clk;\r\nif (gpio_request(VIPER_PSU_nCS_LD_GPIO, "PSU cs"))\r\ngoto err_request_cs;\r\nif (gpio_direction_output(VIPER_PSU_DATA_GPIO, 0) ||\r\ngpio_direction_output(VIPER_PSU_CLK_GPIO, 0) ||\r\ngpio_direction_output(VIPER_PSU_nCS_LD_GPIO, 0))\r\ngoto err_dir;\r\nviper_set_core_cpu_voltage(get_clk_frequency_khz(0), 1);\r\nreturn;\r\nerr_dir:\r\ngpio_free(VIPER_PSU_nCS_LD_GPIO);\r\nerr_request_cs:\r\ngpio_free(VIPER_PSU_CLK_GPIO);\r\nerr_request_clk:\r\ngpio_free(VIPER_PSU_DATA_GPIO);\r\nerr_request_data:\r\npr_err("viper: Failed to setup vcore control GPIOs\n");\r\n}\r\nstatic void __init viper_init_serial_gpio(void)\r\n{\r\nif (gpio_request(VIPER_UART_SHDN_GPIO, "UARTs shutdown"))\r\ngoto err_request;\r\nif (gpio_direction_output(VIPER_UART_SHDN_GPIO, 0))\r\ngoto err_dir;\r\nreturn;\r\nerr_dir:\r\ngpio_free(VIPER_UART_SHDN_GPIO);\r\nerr_request:\r\npr_err("viper: Failed to setup UART shutdown GPIO\n");\r\n}\r\nstatic int viper_cpufreq_notifier(struct notifier_block *nb,\r\nunsigned long val, void *data)\r\n{\r\nstruct cpufreq_freqs *freq = data;\r\nswitch (val) {\r\ncase CPUFREQ_PRECHANGE:\r\nif (freq->old < freq->new) {\r\nviper_set_core_cpu_voltage(freq->new, 0);\r\n}\r\nbreak;\r\ncase CPUFREQ_POSTCHANGE:\r\nif (freq->old > freq->new) {\r\nviper_set_core_cpu_voltage(freq->new, 0);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __init viper_init_cpufreq(void)\r\n{\r\nif (cpufreq_register_notifier(&viper_cpufreq_notifier_block,\r\nCPUFREQ_TRANSITION_NOTIFIER))\r\npr_err("viper: Failed to setup cpufreq notifier\n");\r\n}\r\nstatic inline void viper_init_cpufreq(void) {}\r\nstatic void viper_power_off(void)\r\n{\r\npr_notice("Shutting off UPS\n");\r\ngpio_set_value(VIPER_UPS_GPIO, 1);\r\nwhile (1);\r\n}\r\nstatic void __init viper_init(void)\r\n{\r\nu8 version;\r\npm_power_off = viper_power_off;\r\npxa2xx_mfp_config(ARRAY_AND_SIZE(viper_pin_config));\r\npxa_set_ffuart_info(NULL);\r\npxa_set_btuart_info(NULL);\r\npxa_set_stuart_info(NULL);\r\nviper_init_serial_gpio();\r\npxa_set_fb_info(NULL, &fb_info);\r\nversion = viper_hw_version();\r\nif (version == 0)\r\nsmc91x_device.num_resources--;\r\npxa_set_i2c_info(NULL);\r\nplatform_add_devices(viper_devs, ARRAY_SIZE(viper_devs));\r\nviper_init_vcore_gpios();\r\nviper_init_cpufreq();\r\nregister_syscore_ops(&viper_cpu_syscore_ops);\r\nif (version) {\r\npr_info("viper: hardware v%di%d detected. "\r\n"CPLD revision %d.\n",\r\nVIPER_BOARD_VERSION(version),\r\nVIPER_BOARD_ISSUE(version),\r\nVIPER_CPLD_REVISION(version));\r\nsystem_rev = (VIPER_BOARD_VERSION(version) << 8) |\r\n(VIPER_BOARD_ISSUE(version) << 4) |\r\nVIPER_CPLD_REVISION(version);\r\n} else {\r\npr_info("viper: No version register.\n");\r\n}\r\ni2c_register_board_info(1, ARRAY_AND_SIZE(viper_i2c_devices));\r\nviper_tpm_init();\r\npxa_set_ac97_info(NULL);\r\n}\r\nstatic void __init viper_map_io(void)\r\n{\r\npxa25x_map_io();\r\niotable_init(viper_io_desc, ARRAY_SIZE(viper_io_desc));\r\nPCFR |= PCFR_OPDE;\r\n}
