static void cpsw_gmii_sel_am3352(struct cpsw_phy_sel_priv *priv,\r\nphy_interface_t phy_mode, int slave)\r\n{\r\nu32 reg;\r\nu32 mask;\r\nu32 mode = 0;\r\nreg = readl(priv->gmii_sel);\r\nswitch (phy_mode) {\r\ncase PHY_INTERFACE_MODE_RMII:\r\nmode = AM33XX_GMII_SEL_MODE_RMII;\r\nbreak;\r\ncase PHY_INTERFACE_MODE_RGMII:\r\ncase PHY_INTERFACE_MODE_RGMII_ID:\r\ncase PHY_INTERFACE_MODE_RGMII_RXID:\r\ncase PHY_INTERFACE_MODE_RGMII_TXID:\r\nmode = AM33XX_GMII_SEL_MODE_RGMII;\r\nbreak;\r\ncase PHY_INTERFACE_MODE_MII:\r\ndefault:\r\nmode = AM33XX_GMII_SEL_MODE_MII;\r\nbreak;\r\n};\r\nmask = GMII_SEL_MODE_MASK << (slave * 2) | BIT(slave + 6);\r\nmode <<= slave * 2;\r\nif (priv->rmii_clock_external) {\r\nif (slave == 0)\r\nmode |= AM33XX_GMII_SEL_RMII1_IO_CLK_EN;\r\nelse\r\nmode |= AM33XX_GMII_SEL_RMII2_IO_CLK_EN;\r\n}\r\nreg &= ~mask;\r\nreg |= mode;\r\nwritel(reg, priv->gmii_sel);\r\n}\r\nstatic void cpsw_gmii_sel_dra7xx(struct cpsw_phy_sel_priv *priv,\r\nphy_interface_t phy_mode, int slave)\r\n{\r\nu32 reg;\r\nu32 mask;\r\nu32 mode = 0;\r\nreg = readl(priv->gmii_sel);\r\nswitch (phy_mode) {\r\ncase PHY_INTERFACE_MODE_RMII:\r\nmode = AM33XX_GMII_SEL_MODE_RMII;\r\nbreak;\r\ncase PHY_INTERFACE_MODE_RGMII:\r\ncase PHY_INTERFACE_MODE_RGMII_ID:\r\ncase PHY_INTERFACE_MODE_RGMII_RXID:\r\ncase PHY_INTERFACE_MODE_RGMII_TXID:\r\nmode = AM33XX_GMII_SEL_MODE_RGMII;\r\nbreak;\r\ncase PHY_INTERFACE_MODE_MII:\r\ndefault:\r\nmode = AM33XX_GMII_SEL_MODE_MII;\r\nbreak;\r\n};\r\nswitch (slave) {\r\ncase 0:\r\nmask = GMII_SEL_MODE_MASK;\r\nbreak;\r\ncase 1:\r\nmask = GMII_SEL_MODE_MASK << 4;\r\nmode <<= 4;\r\nbreak;\r\ndefault:\r\ndev_err(priv->dev, "invalid slave number...\n");\r\nreturn;\r\n}\r\nif (priv->rmii_clock_external)\r\ndev_err(priv->dev, "RMII External clock is not supported\n");\r\nreg &= ~mask;\r\nreg |= mode;\r\nwritel(reg, priv->gmii_sel);\r\n}\r\nstatic int match(struct device *dev, void *data)\r\n{\r\nstruct device_node *node = (struct device_node *)data;\r\nreturn dev->of_node == node &&\r\ndev->driver == &cpsw_phy_sel_driver.driver;\r\n}\r\nvoid cpsw_phy_sel(struct device *dev, phy_interface_t phy_mode, int slave)\r\n{\r\nstruct device_node *node;\r\nstruct cpsw_phy_sel_priv *priv;\r\nnode = of_get_child_by_name(dev->of_node, "cpsw-phy-sel");\r\nif (!node) {\r\ndev_err(dev, "Phy mode driver DT not found\n");\r\nreturn;\r\n}\r\ndev = bus_find_device(&platform_bus_type, NULL, node, match);\r\npriv = dev_get_drvdata(dev);\r\npriv->cpsw_phy_sel(priv, phy_mode, slave);\r\n}\r\nstatic int cpsw_phy_sel_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nconst struct of_device_id *of_id;\r\nstruct cpsw_phy_sel_priv *priv;\r\nof_id = of_match_node(cpsw_phy_sel_id_table, pdev->dev.of_node);\r\nif (!of_id)\r\nreturn -EINVAL;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(&pdev->dev, "unable to alloc memory for cpsw phy sel\n");\r\nreturn -ENOMEM;\r\n}\r\npriv->dev = &pdev->dev;\r\npriv->cpsw_phy_sel = of_id->data;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "gmii-sel");\r\npriv->gmii_sel = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(priv->gmii_sel))\r\nreturn PTR_ERR(priv->gmii_sel);\r\nif (of_find_property(pdev->dev.of_node, "rmii-clock-ext", NULL))\r\npriv->rmii_clock_external = true;\r\ndev_set_drvdata(&pdev->dev, priv);\r\nreturn 0;\r\n}
