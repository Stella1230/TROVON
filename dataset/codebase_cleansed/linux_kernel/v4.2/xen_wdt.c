static inline __kernel_time_t set_timeout(void)\r\n{\r\nwdt.timeout = timeout;\r\nreturn ktime_to_timespec(ktime_get()).tv_sec + timeout;\r\n}\r\nstatic int xen_wdt_start(void)\r\n{\r\n__kernel_time_t expires;\r\nint err;\r\nspin_lock(&wdt_lock);\r\nexpires = set_timeout();\r\nif (!wdt.id)\r\nerr = HYPERVISOR_sched_op(SCHEDOP_watchdog, &wdt);\r\nelse\r\nerr = -EBUSY;\r\nif (err > 0) {\r\nwdt.id = err;\r\nwdt_expires = expires;\r\nerr = 0;\r\n} else\r\nBUG_ON(!err);\r\nspin_unlock(&wdt_lock);\r\nreturn err;\r\n}\r\nstatic int xen_wdt_stop(void)\r\n{\r\nint err = 0;\r\nspin_lock(&wdt_lock);\r\nwdt.timeout = 0;\r\nif (wdt.id)\r\nerr = HYPERVISOR_sched_op(SCHEDOP_watchdog, &wdt);\r\nif (!err)\r\nwdt.id = 0;\r\nspin_unlock(&wdt_lock);\r\nreturn err;\r\n}\r\nstatic int xen_wdt_kick(void)\r\n{\r\n__kernel_time_t expires;\r\nint err;\r\nspin_lock(&wdt_lock);\r\nexpires = set_timeout();\r\nif (wdt.id)\r\nerr = HYPERVISOR_sched_op(SCHEDOP_watchdog, &wdt);\r\nelse\r\nerr = -ENXIO;\r\nif (!err)\r\nwdt_expires = expires;\r\nspin_unlock(&wdt_lock);\r\nreturn err;\r\n}\r\nstatic int xen_wdt_open(struct inode *inode, struct file *file)\r\n{\r\nint err;\r\nif (xchg(&is_active, true))\r\nreturn -EBUSY;\r\nerr = xen_wdt_start();\r\nif (err == -EBUSY)\r\nerr = xen_wdt_kick();\r\nreturn err ?: nonseekable_open(inode, file);\r\n}\r\nstatic int xen_wdt_release(struct inode *inode, struct file *file)\r\n{\r\nint err = 0;\r\nif (expect_release)\r\nerr = xen_wdt_stop();\r\nelse {\r\npr_crit("unexpected close, not stopping watchdog!\n");\r\nxen_wdt_kick();\r\n}\r\nis_active = err;\r\nexpect_release = false;\r\nreturn err;\r\n}\r\nstatic ssize_t xen_wdt_write(struct file *file, const char __user *data,\r\nsize_t len, loff_t *ppos)\r\n{\r\nif (len) {\r\nif (!nowayout) {\r\nsize_t i;\r\nexpect_release = false;\r\nfor (i = 0; i != len; i++) {\r\nchar c;\r\nif (get_user(c, data + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nexpect_release = true;\r\n}\r\n}\r\nxen_wdt_kick();\r\n}\r\nreturn len;\r\n}\r\nstatic long xen_wdt_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint new_options, retval = -EINVAL;\r\nint new_timeout;\r\nint __user *argp = (void __user *)arg;\r\nstatic const struct watchdog_info ident = {\r\n.options = WDIOF_SETTIMEOUT | WDIOF_MAGICCLOSE,\r\n.firmware_version = 0,\r\n.identity = DRV_NAME,\r\n};\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nreturn copy_to_user(argp, &ident, sizeof(ident)) ? -EFAULT : 0;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(0, argp);\r\ncase WDIOC_SETOPTIONS:\r\nif (get_user(new_options, argp))\r\nreturn -EFAULT;\r\nif (new_options & WDIOS_DISABLECARD)\r\nretval = xen_wdt_stop();\r\nif (new_options & WDIOS_ENABLECARD) {\r\nretval = xen_wdt_start();\r\nif (retval == -EBUSY)\r\nretval = xen_wdt_kick();\r\n}\r\nreturn retval;\r\ncase WDIOC_KEEPALIVE:\r\nxen_wdt_kick();\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(new_timeout, argp))\r\nreturn -EFAULT;\r\nif (!new_timeout)\r\nreturn -EINVAL;\r\ntimeout = new_timeout;\r\nxen_wdt_kick();\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(timeout, argp);\r\ncase WDIOC_GETTIMELEFT:\r\nretval = wdt_expires - ktime_to_timespec(ktime_get()).tv_sec;\r\nreturn put_user(retval, argp);\r\n}\r\nreturn -ENOTTY;\r\n}\r\nstatic int xen_wdt_probe(struct platform_device *dev)\r\n{\r\nstruct sched_watchdog wd = { .id = ~0 };\r\nint ret = HYPERVISOR_sched_op(SCHEDOP_watchdog, &wd);\r\nswitch (ret) {\r\ncase -EINVAL:\r\nif (!timeout) {\r\ntimeout = WATCHDOG_TIMEOUT;\r\npr_info("timeout value invalid, using %d\n", timeout);\r\n}\r\nret = misc_register(&xen_wdt_miscdev);\r\nif (ret) {\r\npr_err("cannot register miscdev on minor=%d (%d)\n",\r\nWATCHDOG_MINOR, ret);\r\nbreak;\r\n}\r\npr_info("initialized (timeout=%ds, nowayout=%d)\n",\r\ntimeout, nowayout);\r\nbreak;\r\ncase -ENOSYS:\r\npr_info("not supported\n");\r\nret = -ENODEV;\r\nbreak;\r\ndefault:\r\npr_info("bogus return value %d\n", ret);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int xen_wdt_remove(struct platform_device *dev)\r\n{\r\nif (!nowayout)\r\nxen_wdt_stop();\r\nmisc_deregister(&xen_wdt_miscdev);\r\nreturn 0;\r\n}\r\nstatic void xen_wdt_shutdown(struct platform_device *dev)\r\n{\r\nxen_wdt_stop();\r\n}\r\nstatic int xen_wdt_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\ntypeof(wdt.id) id = wdt.id;\r\nint rc = xen_wdt_stop();\r\nwdt.id = id;\r\nreturn rc;\r\n}\r\nstatic int xen_wdt_resume(struct platform_device *dev)\r\n{\r\nif (!wdt.id)\r\nreturn 0;\r\nwdt.id = 0;\r\nreturn xen_wdt_start();\r\n}\r\nstatic int __init xen_wdt_init_module(void)\r\n{\r\nint err;\r\nif (!xen_domain())\r\nreturn -ENODEV;\r\npr_info("Xen WatchDog Timer Driver v%s\n", DRV_VERSION);\r\nerr = platform_driver_register(&xen_wdt_driver);\r\nif (err)\r\nreturn err;\r\nplatform_device = platform_device_register_simple(DRV_NAME,\r\n-1, NULL, 0);\r\nif (IS_ERR(platform_device)) {\r\nerr = PTR_ERR(platform_device);\r\nplatform_driver_unregister(&xen_wdt_driver);\r\n}\r\nreturn err;\r\n}\r\nstatic void __exit xen_wdt_cleanup_module(void)\r\n{\r\nplatform_device_unregister(platform_device);\r\nplatform_driver_unregister(&xen_wdt_driver);\r\npr_info("module unloaded\n");\r\n}
