struct iscsi_cls_session *beiscsi_session_create(struct iscsi_endpoint *ep,\r\nu16 cmds_max,\r\nu16 qdepth,\r\nu32 initial_cmdsn)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct beiscsi_endpoint *beiscsi_ep;\r\nstruct iscsi_cls_session *cls_session;\r\nstruct beiscsi_hba *phba;\r\nstruct iscsi_session *sess;\r\nstruct beiscsi_session *beiscsi_sess;\r\nstruct beiscsi_io_task *io_task;\r\nif (!ep) {\r\nprintk(KERN_ERR\r\n"beiscsi_session_create: invalid ep\n");\r\nreturn NULL;\r\n}\r\nbeiscsi_ep = ep->dd_data;\r\nphba = beiscsi_ep->phba;\r\nif (phba->state & BE_ADAPTER_PCI_ERR) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BS_%d : PCI_ERROR Recovery\n");\r\nreturn NULL;\r\n} else {\r\nbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\r\n"BS_%d : In beiscsi_session_create\n");\r\n}\r\nif (cmds_max > beiscsi_ep->phba->params.wrbs_per_cxn) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BS_%d : Cannot handle %d cmds."\r\n"Max cmds per session supported is %d. Using %d."\r\n"\n", cmds_max,\r\nbeiscsi_ep->phba->params.wrbs_per_cxn,\r\nbeiscsi_ep->phba->params.wrbs_per_cxn);\r\ncmds_max = beiscsi_ep->phba->params.wrbs_per_cxn;\r\n}\r\nshost = phba->shost;\r\ncls_session = iscsi_session_setup(&beiscsi_iscsi_transport,\r\nshost, cmds_max,\r\nsizeof(*beiscsi_sess),\r\nsizeof(*io_task),\r\ninitial_cmdsn, ISCSI_MAX_TARGET);\r\nif (!cls_session)\r\nreturn NULL;\r\nsess = cls_session->dd_data;\r\nbeiscsi_sess = sess->dd_data;\r\nbeiscsi_sess->bhs_pool = pci_pool_create("beiscsi_bhs_pool",\r\nphba->pcidev,\r\nsizeof(struct be_cmd_bhs),\r\n64, 0);\r\nif (!beiscsi_sess->bhs_pool)\r\ngoto destroy_sess;\r\nreturn cls_session;\r\ndestroy_sess:\r\niscsi_session_teardown(cls_session);\r\nreturn NULL;\r\n}\r\nvoid beiscsi_session_destroy(struct iscsi_cls_session *cls_session)\r\n{\r\nstruct iscsi_session *sess = cls_session->dd_data;\r\nstruct beiscsi_session *beiscsi_sess = sess->dd_data;\r\nprintk(KERN_INFO "In beiscsi_session_destroy\n");\r\npci_pool_destroy(beiscsi_sess->bhs_pool);\r\niscsi_session_teardown(cls_session);\r\n}\r\nstruct iscsi_cls_conn *\r\nbeiscsi_conn_create(struct iscsi_cls_session *cls_session, u32 cid)\r\n{\r\nstruct beiscsi_hba *phba;\r\nstruct Scsi_Host *shost;\r\nstruct iscsi_cls_conn *cls_conn;\r\nstruct beiscsi_conn *beiscsi_conn;\r\nstruct iscsi_conn *conn;\r\nstruct iscsi_session *sess;\r\nstruct beiscsi_session *beiscsi_sess;\r\nshost = iscsi_session_to_shost(cls_session);\r\nphba = iscsi_host_priv(shost);\r\nbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\r\n"BS_%d : In beiscsi_conn_create ,cid"\r\n"from iscsi layer=%d\n", cid);\r\ncls_conn = iscsi_conn_setup(cls_session, sizeof(*beiscsi_conn), cid);\r\nif (!cls_conn)\r\nreturn NULL;\r\nconn = cls_conn->dd_data;\r\nbeiscsi_conn = conn->dd_data;\r\nbeiscsi_conn->ep = NULL;\r\nbeiscsi_conn->phba = phba;\r\nbeiscsi_conn->conn = conn;\r\nsess = cls_session->dd_data;\r\nbeiscsi_sess = sess->dd_data;\r\nbeiscsi_conn->beiscsi_sess = beiscsi_sess;\r\nreturn cls_conn;\r\n}\r\nstatic int beiscsi_bindconn_cid(struct beiscsi_hba *phba,\r\nstruct beiscsi_conn *beiscsi_conn,\r\nunsigned int cid)\r\n{\r\nuint16_t cri_index = BE_GET_CRI_FROM_CID(cid);\r\nif (phba->conn_table[cri_index]) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BS_%d : Connection table already occupied. Detected clash\n");\r\nreturn -EINVAL;\r\n} else {\r\nbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\r\n"BS_%d : phba->conn_table[%d]=%p(beiscsi_conn)\n",\r\ncri_index, beiscsi_conn);\r\nphba->conn_table[cri_index] = beiscsi_conn;\r\n}\r\nreturn 0;\r\n}\r\nint beiscsi_conn_bind(struct iscsi_cls_session *cls_session,\r\nstruct iscsi_cls_conn *cls_conn,\r\nu64 transport_fd, int is_leading)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nstruct beiscsi_conn *beiscsi_conn = conn->dd_data;\r\nstruct Scsi_Host *shost = iscsi_session_to_shost(cls_session);\r\nstruct beiscsi_hba *phba = iscsi_host_priv(shost);\r\nstruct hwi_controller *phwi_ctrlr = phba->phwi_ctrlr;\r\nstruct hwi_wrb_context *pwrb_context;\r\nstruct beiscsi_endpoint *beiscsi_ep;\r\nstruct iscsi_endpoint *ep;\r\nep = iscsi_lookup_endpoint(transport_fd);\r\nif (!ep)\r\nreturn -EINVAL;\r\nbeiscsi_ep = ep->dd_data;\r\nif (iscsi_conn_bind(cls_session, cls_conn, is_leading))\r\nreturn -EINVAL;\r\nif (beiscsi_ep->phba != phba) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BS_%d : beiscsi_ep->hba=%p not equal to phba=%p\n",\r\nbeiscsi_ep->phba, phba);\r\nreturn -EEXIST;\r\n}\r\npwrb_context = &phwi_ctrlr->wrb_context[BE_GET_CRI_FROM_CID(\r\nbeiscsi_ep->ep_cid)];\r\nbeiscsi_conn->beiscsi_conn_cid = beiscsi_ep->ep_cid;\r\nbeiscsi_conn->ep = beiscsi_ep;\r\nbeiscsi_ep->conn = beiscsi_conn;\r\nbeiscsi_conn->doorbell_offset = pwrb_context->doorbell_offset;\r\nbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\r\n"BS_%d : beiscsi_conn=%p conn=%p ep_cid=%d\n",\r\nbeiscsi_conn, conn, beiscsi_ep->ep_cid);\r\nreturn beiscsi_bindconn_cid(phba, beiscsi_conn, beiscsi_ep->ep_cid);\r\n}\r\nstatic int beiscsi_create_ipv4_iface(struct beiscsi_hba *phba)\r\n{\r\nif (phba->ipv4_iface)\r\nreturn 0;\r\nphba->ipv4_iface = iscsi_create_iface(phba->shost,\r\n&beiscsi_iscsi_transport,\r\nISCSI_IFACE_TYPE_IPV4,\r\n0, 0);\r\nif (!phba->ipv4_iface) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BS_%d : Could not "\r\n"create default IPv4 address.\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int beiscsi_create_ipv6_iface(struct beiscsi_hba *phba)\r\n{\r\nif (phba->ipv6_iface)\r\nreturn 0;\r\nphba->ipv6_iface = iscsi_create_iface(phba->shost,\r\n&beiscsi_iscsi_transport,\r\nISCSI_IFACE_TYPE_IPV6,\r\n0, 0);\r\nif (!phba->ipv6_iface) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BS_%d : Could not "\r\n"create default IPv6 address.\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nvoid beiscsi_create_def_ifaces(struct beiscsi_hba *phba)\r\n{\r\nstruct be_cmd_get_if_info_resp *if_info;\r\nif (!mgmt_get_if_info(phba, BE2_IPV4, &if_info)) {\r\nbeiscsi_create_ipv4_iface(phba);\r\nkfree(if_info);\r\n}\r\nif (!mgmt_get_if_info(phba, BE2_IPV6, &if_info)) {\r\nbeiscsi_create_ipv6_iface(phba);\r\nkfree(if_info);\r\n}\r\n}\r\nvoid beiscsi_destroy_def_ifaces(struct beiscsi_hba *phba)\r\n{\r\nif (phba->ipv6_iface)\r\niscsi_destroy_iface(phba->ipv6_iface);\r\nif (phba->ipv4_iface)\r\niscsi_destroy_iface(phba->ipv4_iface);\r\n}\r\nstatic int\r\nbeiscsi_set_static_ip(struct Scsi_Host *shost,\r\nstruct iscsi_iface_param_info *iface_param,\r\nvoid *data, uint32_t dt_len)\r\n{\r\nstruct beiscsi_hba *phba = iscsi_host_priv(shost);\r\nstruct iscsi_iface_param_info *iface_ip = NULL;\r\nstruct iscsi_iface_param_info *iface_subnet = NULL;\r\nstruct nlattr *nla;\r\nint ret;\r\nswitch (iface_param->param) {\r\ncase ISCSI_NET_PARAM_IPV4_BOOTPROTO:\r\nnla = nla_find(data, dt_len, ISCSI_NET_PARAM_IPV4_ADDR);\r\nif (nla)\r\niface_ip = nla_data(nla);\r\nnla = nla_find(data, dt_len, ISCSI_NET_PARAM_IPV4_SUBNET);\r\nif (nla)\r\niface_subnet = nla_data(nla);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_ADDR:\r\niface_ip = iface_param;\r\nnla = nla_find(data, dt_len, ISCSI_NET_PARAM_IPV4_SUBNET);\r\nif (nla)\r\niface_subnet = nla_data(nla);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_SUBNET:\r\niface_subnet = iface_param;\r\nnla = nla_find(data, dt_len, ISCSI_NET_PARAM_IPV4_ADDR);\r\nif (nla)\r\niface_ip = nla_data(nla);\r\nbreak;\r\ndefault:\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BS_%d : Unsupported param %d\n",\r\niface_param->param);\r\n}\r\nif (!iface_ip || !iface_subnet) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BS_%d : IP and Subnet Mask required\n");\r\nreturn -EINVAL;\r\n}\r\nret = mgmt_set_ip(phba, iface_ip, iface_subnet,\r\nISCSI_BOOTPROTO_STATIC);\r\nreturn ret;\r\n}\r\nstatic int\r\nbeiscsi_set_vlan_tag(struct Scsi_Host *shost,\r\nstruct iscsi_iface_param_info *iface_param)\r\n{\r\nstruct beiscsi_hba *phba = iscsi_host_priv(shost);\r\nint ret = 0;\r\nif (mgmt_get_all_if_id(phba)) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BS_%d : Getting Interface Handle Failed\n");\r\nreturn -EIO;\r\n}\r\nswitch (iface_param->param) {\r\ncase ISCSI_NET_PARAM_VLAN_ENABLED:\r\nif (iface_param->value[0] != ISCSI_VLAN_ENABLE)\r\nret = mgmt_set_vlan(phba, BEISCSI_VLAN_DISABLE);\r\nbreak;\r\ncase ISCSI_NET_PARAM_VLAN_TAG:\r\nret = mgmt_set_vlan(phba,\r\n*((uint16_t *)iface_param->value));\r\nbreak;\r\ndefault:\r\nbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\r\n"BS_%d : Unknown Param Type : %d\n",\r\niface_param->param);\r\nreturn -ENOSYS;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nbeiscsi_set_ipv4(struct Scsi_Host *shost,\r\nstruct iscsi_iface_param_info *iface_param,\r\nvoid *data, uint32_t dt_len)\r\n{\r\nstruct beiscsi_hba *phba = iscsi_host_priv(shost);\r\nint ret = 0;\r\nswitch (iface_param->param) {\r\ncase ISCSI_NET_PARAM_IPV4_GW:\r\nret = mgmt_set_gateway(phba, iface_param);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_BOOTPROTO:\r\nif (iface_param->value[0] == ISCSI_BOOTPROTO_DHCP)\r\nret = mgmt_set_ip(phba, iface_param,\r\nNULL, ISCSI_BOOTPROTO_DHCP);\r\nelse if (iface_param->value[0] == ISCSI_BOOTPROTO_STATIC)\r\nret = beiscsi_set_static_ip(shost, iface_param,\r\ndata, dt_len);\r\nelse\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BS_%d : Invalid BOOTPROTO: %d\n",\r\niface_param->value[0]);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IFACE_ENABLE:\r\nif (iface_param->value[0] == ISCSI_IFACE_ENABLE)\r\nret = beiscsi_create_ipv4_iface(phba);\r\nelse\r\niscsi_destroy_iface(phba->ipv4_iface);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_SUBNET:\r\ncase ISCSI_NET_PARAM_IPV4_ADDR:\r\nret = beiscsi_set_static_ip(shost, iface_param,\r\ndata, dt_len);\r\nbreak;\r\ncase ISCSI_NET_PARAM_VLAN_ENABLED:\r\ncase ISCSI_NET_PARAM_VLAN_TAG:\r\nret = beiscsi_set_vlan_tag(shost, iface_param);\r\nbreak;\r\ndefault:\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BS_%d : Param %d not supported\n",\r\niface_param->param);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nbeiscsi_set_ipv6(struct Scsi_Host *shost,\r\nstruct iscsi_iface_param_info *iface_param,\r\nvoid *data, uint32_t dt_len)\r\n{\r\nstruct beiscsi_hba *phba = iscsi_host_priv(shost);\r\nint ret = 0;\r\nswitch (iface_param->param) {\r\ncase ISCSI_NET_PARAM_IFACE_ENABLE:\r\nif (iface_param->value[0] == ISCSI_IFACE_ENABLE)\r\nret = beiscsi_create_ipv6_iface(phba);\r\nelse {\r\niscsi_destroy_iface(phba->ipv6_iface);\r\nret = 0;\r\n}\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_ADDR:\r\nret = mgmt_set_ip(phba, iface_param, NULL,\r\nISCSI_BOOTPROTO_STATIC);\r\nbreak;\r\ndefault:\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BS_%d : Param %d not supported\n",\r\niface_param->param);\r\n}\r\nreturn ret;\r\n}\r\nint be2iscsi_iface_set_param(struct Scsi_Host *shost,\r\nvoid *data, uint32_t dt_len)\r\n{\r\nstruct iscsi_iface_param_info *iface_param = NULL;\r\nstruct beiscsi_hba *phba = iscsi_host_priv(shost);\r\nstruct nlattr *attrib;\r\nuint32_t rm_len = dt_len;\r\nint ret = 0 ;\r\nif (phba->state & BE_ADAPTER_PCI_ERR) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BS_%d : In PCI_ERROR Recovery\n");\r\nreturn -EBUSY;\r\n}\r\nnla_for_each_attr(attrib, data, dt_len, rm_len) {\r\niface_param = nla_data(attrib);\r\nif (iface_param->param_type != ISCSI_NET_PARAM)\r\ncontinue;\r\nif (iface_param->iface_num) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BS_%d : Invalid iface_num %d."\r\n"Only iface_num 0 is supported.\n",\r\niface_param->iface_num);\r\nreturn -EINVAL;\r\n}\r\nswitch (iface_param->iface_type) {\r\ncase ISCSI_IFACE_TYPE_IPV4:\r\nret = beiscsi_set_ipv4(shost, iface_param,\r\ndata, dt_len);\r\nbreak;\r\ncase ISCSI_IFACE_TYPE_IPV6:\r\nret = beiscsi_set_ipv6(shost, iface_param,\r\ndata, dt_len);\r\nbreak;\r\ndefault:\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BS_%d : Invalid iface type :%d passed\n",\r\niface_param->iface_type);\r\nbreak;\r\n}\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int be2iscsi_get_if_param(struct beiscsi_hba *phba,\r\nstruct iscsi_iface *iface, int param,\r\nchar *buf)\r\n{\r\nstruct be_cmd_get_if_info_resp *if_info;\r\nint len, ip_type = BE2_IPV4;\r\nif (iface->iface_type == ISCSI_IFACE_TYPE_IPV6)\r\nip_type = BE2_IPV6;\r\nlen = mgmt_get_if_info(phba, ip_type, &if_info);\r\nif (len)\r\nreturn len;\r\nswitch (param) {\r\ncase ISCSI_NET_PARAM_IPV4_ADDR:\r\nlen = sprintf(buf, "%pI4\n", if_info->ip_addr.addr);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV6_ADDR:\r\nlen = sprintf(buf, "%pI6\n", if_info->ip_addr.addr);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_BOOTPROTO:\r\nif (!if_info->dhcp_state)\r\nlen = sprintf(buf, "static\n");\r\nelse\r\nlen = sprintf(buf, "dhcp\n");\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_SUBNET:\r\nlen = sprintf(buf, "%pI4\n", if_info->ip_addr.subnet_mask);\r\nbreak;\r\ncase ISCSI_NET_PARAM_VLAN_ENABLED:\r\nlen = sprintf(buf, "%s\n",\r\n(if_info->vlan_priority == BEISCSI_VLAN_DISABLE)\r\n? "Disabled\n" : "Enabled\n");\r\nbreak;\r\ncase ISCSI_NET_PARAM_VLAN_ID:\r\nif (if_info->vlan_priority == BEISCSI_VLAN_DISABLE)\r\nlen = -EINVAL;\r\nelse\r\nlen = sprintf(buf, "%d\n",\r\n(if_info->vlan_priority &\r\nISCSI_MAX_VLAN_ID));\r\nbreak;\r\ncase ISCSI_NET_PARAM_VLAN_PRIORITY:\r\nif (if_info->vlan_priority == BEISCSI_VLAN_DISABLE)\r\nlen = -EINVAL;\r\nelse\r\nlen = sprintf(buf, "%d\n",\r\n((if_info->vlan_priority >> 13) &\r\nISCSI_MAX_VLAN_PRIORITY));\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\n}\r\nkfree(if_info);\r\nreturn len;\r\n}\r\nint be2iscsi_iface_get_param(struct iscsi_iface *iface,\r\nenum iscsi_param_type param_type,\r\nint param, char *buf)\r\n{\r\nstruct Scsi_Host *shost = iscsi_iface_to_shost(iface);\r\nstruct beiscsi_hba *phba = iscsi_host_priv(shost);\r\nstruct be_cmd_get_def_gateway_resp gateway;\r\nint len = -ENOSYS;\r\nif (phba->state & BE_ADAPTER_PCI_ERR) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BS_%d : In PCI_ERROR Recovery\n");\r\nreturn -EBUSY;\r\n}\r\nswitch (param) {\r\ncase ISCSI_NET_PARAM_IPV4_ADDR:\r\ncase ISCSI_NET_PARAM_IPV4_SUBNET:\r\ncase ISCSI_NET_PARAM_IPV4_BOOTPROTO:\r\ncase ISCSI_NET_PARAM_IPV6_ADDR:\r\ncase ISCSI_NET_PARAM_VLAN_ENABLED:\r\ncase ISCSI_NET_PARAM_VLAN_ID:\r\ncase ISCSI_NET_PARAM_VLAN_PRIORITY:\r\nlen = be2iscsi_get_if_param(phba, iface, param, buf);\r\nbreak;\r\ncase ISCSI_NET_PARAM_IFACE_ENABLE:\r\nlen = sprintf(buf, "enabled\n");\r\nbreak;\r\ncase ISCSI_NET_PARAM_IPV4_GW:\r\nmemset(&gateway, 0, sizeof(gateway));\r\nlen = mgmt_get_gateway(phba, BE2_IPV4, &gateway);\r\nif (!len)\r\nlen = sprintf(buf, "%pI4\n", &gateway.ip_addr.addr);\r\nbreak;\r\ndefault:\r\nlen = -ENOSYS;\r\n}\r\nreturn len;\r\n}\r\nint beiscsi_ep_get_param(struct iscsi_endpoint *ep,\r\nenum iscsi_param param, char *buf)\r\n{\r\nstruct beiscsi_endpoint *beiscsi_ep = ep->dd_data;\r\nint len = 0;\r\nbeiscsi_log(beiscsi_ep->phba, KERN_INFO,\r\nBEISCSI_LOG_CONFIG,\r\n"BS_%d : In beiscsi_ep_get_param,"\r\n" param= %d\n", param);\r\nswitch (param) {\r\ncase ISCSI_PARAM_CONN_PORT:\r\nlen = sprintf(buf, "%hu\n", beiscsi_ep->dst_tcpport);\r\nbreak;\r\ncase ISCSI_PARAM_CONN_ADDRESS:\r\nif (beiscsi_ep->ip_type == BE2_IPV4)\r\nlen = sprintf(buf, "%pI4\n", &beiscsi_ep->dst_addr);\r\nelse\r\nlen = sprintf(buf, "%pI6\n", &beiscsi_ep->dst6_addr);\r\nbreak;\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\nreturn len;\r\n}\r\nint beiscsi_set_param(struct iscsi_cls_conn *cls_conn,\r\nenum iscsi_param param, char *buf, int buflen)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nstruct iscsi_session *session = conn->session;\r\nstruct beiscsi_hba *phba = NULL;\r\nint ret;\r\nphba = ((struct beiscsi_conn *)conn->dd_data)->phba;\r\nbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\r\n"BS_%d : In beiscsi_conn_set_param,"\r\n" param= %d\n", param);\r\nret = iscsi_set_param(cls_conn, param, buf, buflen);\r\nif (ret)\r\nreturn ret;\r\nswitch (param) {\r\ncase ISCSI_PARAM_FIRST_BURST:\r\nif (session->first_burst > 8192)\r\nsession->first_burst = 8192;\r\nbreak;\r\ncase ISCSI_PARAM_MAX_RECV_DLENGTH:\r\nif (conn->max_recv_dlength > 65536)\r\nconn->max_recv_dlength = 65536;\r\nbreak;\r\ncase ISCSI_PARAM_MAX_BURST:\r\nif (session->max_burst > 262144)\r\nsession->max_burst = 262144;\r\nbreak;\r\ncase ISCSI_PARAM_MAX_XMIT_DLENGTH:\r\nif (conn->max_xmit_dlength > 65536)\r\nconn->max_xmit_dlength = 65536;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int beiscsi_get_initname(char *buf, struct beiscsi_hba *phba)\r\n{\r\nint rc;\r\nunsigned int tag;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_hba_name *resp;\r\ntag = be_cmd_get_initname(phba);\r\nif (!tag) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BS_%d : Getting Initiator Name Failed\n");\r\nreturn -EBUSY;\r\n}\r\nrc = beiscsi_mccq_compl(phba, tag, &wrb, NULL);\r\nif (rc) {\r\nbeiscsi_log(phba, KERN_ERR,\r\nBEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,\r\n"BS_%d : Initiator Name MBX Failed\n");\r\nreturn rc;\r\n}\r\nresp = embedded_payload(wrb);\r\nrc = sprintf(buf, "%s\n", resp->initiator_name);\r\nreturn rc;\r\n}\r\nstatic void beiscsi_get_port_state(struct Scsi_Host *shost)\r\n{\r\nstruct beiscsi_hba *phba = iscsi_host_priv(shost);\r\nstruct iscsi_cls_host *ihost = shost->shost_data;\r\nihost->port_state = (phba->state == BE_ADAPTER_LINK_UP) ?\r\nISCSI_PORT_STATE_UP : ISCSI_PORT_STATE_DOWN;\r\n}\r\nstatic int beiscsi_get_port_speed(struct Scsi_Host *shost)\r\n{\r\nint rc;\r\nunsigned int tag;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_ntwk_link_status_resp *resp;\r\nstruct beiscsi_hba *phba = iscsi_host_priv(shost);\r\nstruct iscsi_cls_host *ihost = shost->shost_data;\r\ntag = be_cmd_get_port_speed(phba);\r\nif (!tag) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BS_%d : Getting Port Speed Failed\n");\r\nreturn -EBUSY;\r\n}\r\nrc = beiscsi_mccq_compl(phba, tag, &wrb, NULL);\r\nif (rc) {\r\nbeiscsi_log(phba, KERN_ERR,\r\nBEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,\r\n"BS_%d : Port Speed MBX Failed\n");\r\nreturn rc;\r\n}\r\nresp = embedded_payload(wrb);\r\nswitch (resp->mac_speed) {\r\ncase BE2ISCSI_LINK_SPEED_10MBPS:\r\nihost->port_speed = ISCSI_PORT_SPEED_10MBPS;\r\nbreak;\r\ncase BE2ISCSI_LINK_SPEED_100MBPS:\r\nihost->port_speed = ISCSI_PORT_SPEED_100MBPS;\r\nbreak;\r\ncase BE2ISCSI_LINK_SPEED_1GBPS:\r\nihost->port_speed = ISCSI_PORT_SPEED_1GBPS;\r\nbreak;\r\ncase BE2ISCSI_LINK_SPEED_10GBPS:\r\nihost->port_speed = ISCSI_PORT_SPEED_10GBPS;\r\nbreak;\r\ndefault:\r\nihost->port_speed = ISCSI_PORT_SPEED_UNKNOWN;\r\n}\r\nreturn 0;\r\n}\r\nint beiscsi_get_host_param(struct Scsi_Host *shost,\r\nenum iscsi_host_param param, char *buf)\r\n{\r\nstruct beiscsi_hba *phba = iscsi_host_priv(shost);\r\nint status = 0;\r\nif (phba->state & BE_ADAPTER_PCI_ERR) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BS_%d : In PCI_ERROR Recovery\n");\r\nreturn -EBUSY;\r\n} else {\r\nbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\r\n"BS_%d : In beiscsi_get_host_param,"\r\n" param = %d\n", param);\r\n}\r\nswitch (param) {\r\ncase ISCSI_HOST_PARAM_HWADDRESS:\r\nstatus = beiscsi_get_macaddr(buf, phba);\r\nif (status < 0) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BS_%d : beiscsi_get_macaddr Failed\n");\r\nreturn status;\r\n}\r\nbreak;\r\ncase ISCSI_HOST_PARAM_INITIATOR_NAME:\r\nstatus = beiscsi_get_initname(buf, phba);\r\nif (status < 0) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BS_%d : Retreiving Initiator Name Failed\n");\r\nreturn status;\r\n}\r\nbreak;\r\ncase ISCSI_HOST_PARAM_PORT_STATE:\r\nbeiscsi_get_port_state(shost);\r\nstatus = sprintf(buf, "%s\n", iscsi_get_port_state_name(shost));\r\nbreak;\r\ncase ISCSI_HOST_PARAM_PORT_SPEED:\r\nstatus = beiscsi_get_port_speed(shost);\r\nif (status) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BS_%d : Retreiving Port Speed Failed\n");\r\nreturn status;\r\n}\r\nstatus = sprintf(buf, "%s\n", iscsi_get_port_speed_name(shost));\r\nbreak;\r\ndefault:\r\nreturn iscsi_host_get_param(shost, param, buf);\r\n}\r\nreturn status;\r\n}\r\nint beiscsi_get_macaddr(char *buf, struct beiscsi_hba *phba)\r\n{\r\nstruct be_cmd_get_nic_conf_resp resp;\r\nint rc;\r\nif (phba->mac_addr_set)\r\nreturn sysfs_format_mac(buf, phba->mac_address, ETH_ALEN);\r\nmemset(&resp, 0, sizeof(resp));\r\nrc = mgmt_get_nic_conf(phba, &resp);\r\nif (rc)\r\nreturn rc;\r\nphba->mac_addr_set = true;\r\nmemcpy(phba->mac_address, resp.mac_address, ETH_ALEN);\r\nreturn sysfs_format_mac(buf, phba->mac_address, ETH_ALEN);\r\n}\r\nvoid beiscsi_conn_get_stats(struct iscsi_cls_conn *cls_conn,\r\nstruct iscsi_stats *stats)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nstruct beiscsi_hba *phba = NULL;\r\nphba = ((struct beiscsi_conn *)conn->dd_data)->phba;\r\nbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\r\n"BS_%d : In beiscsi_conn_get_stats\n");\r\nstats->txdata_octets = conn->txdata_octets;\r\nstats->rxdata_octets = conn->rxdata_octets;\r\nstats->dataout_pdus = conn->dataout_pdus_cnt;\r\nstats->scsirsp_pdus = conn->scsirsp_pdus_cnt;\r\nstats->scsicmd_pdus = conn->scsicmd_pdus_cnt;\r\nstats->datain_pdus = conn->datain_pdus_cnt;\r\nstats->tmfrsp_pdus = conn->tmfrsp_pdus_cnt;\r\nstats->tmfcmd_pdus = conn->tmfcmd_pdus_cnt;\r\nstats->r2t_pdus = conn->r2t_pdus_cnt;\r\nstats->digest_err = 0;\r\nstats->timeout_err = 0;\r\nstats->custom_length = 1;\r\nstrcpy(stats->custom[0].desc, "eh_abort_cnt");\r\nstats->custom[0].value = conn->eh_abort_cnt;\r\n}\r\nstatic void beiscsi_set_params_for_offld(struct beiscsi_conn *beiscsi_conn,\r\nstruct beiscsi_offload_params *params)\r\n{\r\nstruct iscsi_conn *conn = beiscsi_conn->conn;\r\nstruct iscsi_session *session = conn->session;\r\nAMAP_SET_BITS(struct amap_beiscsi_offload_params, max_burst_length,\r\nparams, session->max_burst);\r\nAMAP_SET_BITS(struct amap_beiscsi_offload_params,\r\nmax_send_data_segment_length, params,\r\nconn->max_xmit_dlength);\r\nAMAP_SET_BITS(struct amap_beiscsi_offload_params, first_burst_length,\r\nparams, session->first_burst);\r\nAMAP_SET_BITS(struct amap_beiscsi_offload_params, erl, params,\r\nsession->erl);\r\nAMAP_SET_BITS(struct amap_beiscsi_offload_params, dde, params,\r\nconn->datadgst_en);\r\nAMAP_SET_BITS(struct amap_beiscsi_offload_params, hde, params,\r\nconn->hdrdgst_en);\r\nAMAP_SET_BITS(struct amap_beiscsi_offload_params, ir2t, params,\r\nsession->initial_r2t_en);\r\nAMAP_SET_BITS(struct amap_beiscsi_offload_params, imd, params,\r\nsession->imm_data_en);\r\nAMAP_SET_BITS(struct amap_beiscsi_offload_params,\r\ndata_seq_inorder, params,\r\nsession->dataseq_inorder_en);\r\nAMAP_SET_BITS(struct amap_beiscsi_offload_params,\r\npdu_seq_inorder, params,\r\nsession->pdu_inorder_en);\r\nAMAP_SET_BITS(struct amap_beiscsi_offload_params, max_r2t, params,\r\nsession->max_r2t);\r\nAMAP_SET_BITS(struct amap_beiscsi_offload_params, exp_statsn, params,\r\n(conn->exp_statsn - 1));\r\nAMAP_SET_BITS(struct amap_beiscsi_offload_params,\r\nmax_recv_data_segment_length, params,\r\nconn->max_recv_dlength);\r\n}\r\nint beiscsi_conn_start(struct iscsi_cls_conn *cls_conn)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nstruct beiscsi_conn *beiscsi_conn = conn->dd_data;\r\nstruct beiscsi_endpoint *beiscsi_ep;\r\nstruct beiscsi_offload_params params;\r\nstruct beiscsi_hba *phba;\r\nphba = ((struct beiscsi_conn *)conn->dd_data)->phba;\r\nif (phba->state & BE_ADAPTER_PCI_ERR) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BS_%d : In PCI_ERROR Recovery\n");\r\nreturn -EBUSY;\r\n} else {\r\nbeiscsi_log(beiscsi_conn->phba, KERN_INFO,\r\nBEISCSI_LOG_CONFIG,\r\n"BS_%d : In beiscsi_conn_start\n");\r\n}\r\nmemset(&params, 0, sizeof(struct beiscsi_offload_params));\r\nbeiscsi_ep = beiscsi_conn->ep;\r\nif (!beiscsi_ep)\r\nbeiscsi_log(beiscsi_conn->phba, KERN_ERR,\r\nBEISCSI_LOG_CONFIG,\r\n"BS_%d : In beiscsi_conn_start , no beiscsi_ep\n");\r\nbeiscsi_conn->login_in_progress = 0;\r\nbeiscsi_set_params_for_offld(beiscsi_conn, &params);\r\nbeiscsi_offload_connection(beiscsi_conn, &params);\r\niscsi_conn_start(cls_conn);\r\nreturn 0;\r\n}\r\nstatic int beiscsi_get_cid(struct beiscsi_hba *phba)\r\n{\r\nunsigned short cid = 0xFFFF, cid_from_ulp;\r\nstruct ulp_cid_info *cid_info = NULL;\r\nuint16_t cid_avlbl_ulp0, cid_avlbl_ulp1;\r\ncid_avlbl_ulp0 = (phba->cid_array_info[BEISCSI_ULP0]) ?\r\nBEISCSI_ULP0_AVLBL_CID(phba) : 0;\r\ncid_avlbl_ulp1 = (phba->cid_array_info[BEISCSI_ULP1]) ?\r\nBEISCSI_ULP1_AVLBL_CID(phba) : 0;\r\ncid_from_ulp = (cid_avlbl_ulp0 > cid_avlbl_ulp1) ?\r\nBEISCSI_ULP0 : BEISCSI_ULP1;\r\nif (test_bit(cid_from_ulp, (void *)&phba->fw_config.ulp_supported)) {\r\ncid_info = phba->cid_array_info[cid_from_ulp];\r\nif (!cid_info->avlbl_cids)\r\nreturn cid;\r\ncid = cid_info->cid_array[cid_info->cid_alloc++];\r\nif (cid_info->cid_alloc == BEISCSI_GET_CID_COUNT(\r\nphba, cid_from_ulp))\r\ncid_info->cid_alloc = 0;\r\ncid_info->avlbl_cids--;\r\n}\r\nreturn cid;\r\n}\r\nstatic void beiscsi_put_cid(struct beiscsi_hba *phba, unsigned short cid)\r\n{\r\nuint16_t cid_post_ulp;\r\nstruct hwi_controller *phwi_ctrlr;\r\nstruct hwi_wrb_context *pwrb_context;\r\nstruct ulp_cid_info *cid_info = NULL;\r\nuint16_t cri_index = BE_GET_CRI_FROM_CID(cid);\r\nphwi_ctrlr = phba->phwi_ctrlr;\r\npwrb_context = &phwi_ctrlr->wrb_context[cri_index];\r\ncid_post_ulp = pwrb_context->ulp_num;\r\ncid_info = phba->cid_array_info[cid_post_ulp];\r\ncid_info->avlbl_cids++;\r\ncid_info->cid_array[cid_info->cid_free++] = cid;\r\nif (cid_info->cid_free == BEISCSI_GET_CID_COUNT(phba, cid_post_ulp))\r\ncid_info->cid_free = 0;\r\n}\r\nstatic void beiscsi_free_ep(struct beiscsi_endpoint *beiscsi_ep)\r\n{\r\nstruct beiscsi_hba *phba = beiscsi_ep->phba;\r\nstruct beiscsi_conn *beiscsi_conn;\r\nbeiscsi_put_cid(phba, beiscsi_ep->ep_cid);\r\nbeiscsi_ep->phba = NULL;\r\nphba->ep_array[BE_GET_CRI_FROM_CID\r\n(beiscsi_ep->ep_cid)] = NULL;\r\nif (!beiscsi_ep->conn)\r\nreturn;\r\nbeiscsi_conn = beiscsi_ep->conn;\r\nif (beiscsi_conn->login_in_progress) {\r\nbeiscsi_free_mgmt_task_handles(beiscsi_conn,\r\nbeiscsi_conn->task);\r\nbeiscsi_conn->login_in_progress = 0;\r\n}\r\n}\r\nstatic int beiscsi_open_conn(struct iscsi_endpoint *ep,\r\nstruct sockaddr *src_addr,\r\nstruct sockaddr *dst_addr, int non_blocking)\r\n{\r\nstruct beiscsi_endpoint *beiscsi_ep = ep->dd_data;\r\nstruct beiscsi_hba *phba = beiscsi_ep->phba;\r\nstruct tcp_connect_and_offload_out *ptcpcnct_out;\r\nstruct be_dma_mem nonemb_cmd;\r\nunsigned int tag, req_memsize;\r\nint ret = -ENOMEM;\r\nbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\r\n"BS_%d : In beiscsi_open_conn\n");\r\nbeiscsi_ep->ep_cid = beiscsi_get_cid(phba);\r\nif (beiscsi_ep->ep_cid == 0xFFFF) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BS_%d : No free cid available\n");\r\nreturn ret;\r\n}\r\nbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\r\n"BS_%d : In beiscsi_open_conn, ep_cid=%d\n",\r\nbeiscsi_ep->ep_cid);\r\nphba->ep_array[BE_GET_CRI_FROM_CID\r\n(beiscsi_ep->ep_cid)] = ep;\r\nbeiscsi_ep->cid_vld = 0;\r\nif (is_chip_be2_be3r(phba))\r\nreq_memsize = sizeof(struct tcp_connect_and_offload_in);\r\nelse\r\nreq_memsize = sizeof(struct tcp_connect_and_offload_in_v1);\r\nnonemb_cmd.va = pci_alloc_consistent(phba->ctrl.pdev,\r\nreq_memsize,\r\n&nonemb_cmd.dma);\r\nif (nonemb_cmd.va == NULL) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BS_%d : Failed to allocate memory for"\r\n" mgmt_open_connection\n");\r\nbeiscsi_free_ep(beiscsi_ep);\r\nreturn -ENOMEM;\r\n}\r\nnonemb_cmd.size = req_memsize;\r\nmemset(nonemb_cmd.va, 0, nonemb_cmd.size);\r\ntag = mgmt_open_connection(phba, dst_addr, beiscsi_ep, &nonemb_cmd);\r\nif (tag <= 0) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BS_%d : mgmt_open_connection Failed for cid=%d\n",\r\nbeiscsi_ep->ep_cid);\r\npci_free_consistent(phba->ctrl.pdev, nonemb_cmd.size,\r\nnonemb_cmd.va, nonemb_cmd.dma);\r\nbeiscsi_free_ep(beiscsi_ep);\r\nreturn -EAGAIN;\r\n}\r\nret = beiscsi_mccq_compl(phba, tag, NULL, &nonemb_cmd);\r\nif (ret) {\r\nbeiscsi_log(phba, KERN_ERR,\r\nBEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,\r\n"BS_%d : mgmt_open_connection Failed");\r\nif (ret != -EBUSY)\r\npci_free_consistent(phba->ctrl.pdev, nonemb_cmd.size,\r\nnonemb_cmd.va, nonemb_cmd.dma);\r\nbeiscsi_free_ep(beiscsi_ep);\r\nreturn ret;\r\n}\r\nptcpcnct_out = (struct tcp_connect_and_offload_out *)nonemb_cmd.va;\r\nbeiscsi_ep = ep->dd_data;\r\nbeiscsi_ep->fw_handle = ptcpcnct_out->connection_handle;\r\nbeiscsi_ep->cid_vld = 1;\r\nbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\r\n"BS_%d : mgmt_open_connection Success\n");\r\npci_free_consistent(phba->ctrl.pdev, nonemb_cmd.size,\r\nnonemb_cmd.va, nonemb_cmd.dma);\r\nreturn 0;\r\n}\r\nstruct iscsi_endpoint *\r\nbeiscsi_ep_connect(struct Scsi_Host *shost, struct sockaddr *dst_addr,\r\nint non_blocking)\r\n{\r\nstruct beiscsi_hba *phba;\r\nstruct beiscsi_endpoint *beiscsi_ep;\r\nstruct iscsi_endpoint *ep;\r\nint ret;\r\nif (shost)\r\nphba = iscsi_host_priv(shost);\r\nelse {\r\nret = -ENXIO;\r\nprintk(KERN_ERR\r\n"beiscsi_ep_connect shost is NULL\n");\r\nreturn ERR_PTR(ret);\r\n}\r\nif (beiscsi_error(phba)) {\r\nret = -EIO;\r\nbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\r\n"BS_%d : The FW state Not Stable!!!\n");\r\nreturn ERR_PTR(ret);\r\n}\r\nif (phba->state & BE_ADAPTER_PCI_ERR) {\r\nret = -EBUSY;\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BS_%d : In PCI_ERROR Recovery\n");\r\nreturn ERR_PTR(ret);\r\n} else if (phba->state & BE_ADAPTER_LINK_DOWN) {\r\nret = -EBUSY;\r\nbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\r\n"BS_%d : The Adapter Port state is Down!!!\n");\r\nreturn ERR_PTR(ret);\r\n}\r\nep = iscsi_create_endpoint(sizeof(struct beiscsi_endpoint));\r\nif (!ep) {\r\nret = -ENOMEM;\r\nreturn ERR_PTR(ret);\r\n}\r\nbeiscsi_ep = ep->dd_data;\r\nbeiscsi_ep->phba = phba;\r\nbeiscsi_ep->openiscsi_ep = ep;\r\nret = beiscsi_open_conn(ep, NULL, dst_addr, non_blocking);\r\nif (ret) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BS_%d : Failed in beiscsi_open_conn\n");\r\ngoto free_ep;\r\n}\r\nreturn ep;\r\nfree_ep:\r\niscsi_destroy_endpoint(ep);\r\nreturn ERR_PTR(ret);\r\n}\r\nint beiscsi_ep_poll(struct iscsi_endpoint *ep, int timeout_ms)\r\n{\r\nstruct beiscsi_endpoint *beiscsi_ep = ep->dd_data;\r\nbeiscsi_log(beiscsi_ep->phba, KERN_INFO, BEISCSI_LOG_CONFIG,\r\n"BS_%d : In beiscsi_ep_poll\n");\r\nif (beiscsi_ep->cid_vld == 1)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic void beiscsi_flush_cq(struct beiscsi_hba *phba)\r\n{\r\nuint16_t i;\r\nstruct be_eq_obj *pbe_eq;\r\nstruct hwi_controller *phwi_ctrlr;\r\nstruct hwi_context_memory *phwi_context;\r\nphwi_ctrlr = phba->phwi_ctrlr;\r\nphwi_context = phwi_ctrlr->phwi_ctxt;\r\nfor (i = 0; i < phba->num_cpus; i++) {\r\npbe_eq = &phwi_context->be_eq[i];\r\nblk_iopoll_disable(&pbe_eq->iopoll);\r\nbeiscsi_process_cq(pbe_eq);\r\nblk_iopoll_enable(&pbe_eq->iopoll);\r\n}\r\n}\r\nstatic int beiscsi_close_conn(struct beiscsi_endpoint *beiscsi_ep, int flag)\r\n{\r\nint ret = 0;\r\nunsigned int tag;\r\nstruct beiscsi_hba *phba = beiscsi_ep->phba;\r\ntag = mgmt_upload_connection(phba, beiscsi_ep->ep_cid, flag);\r\nif (!tag) {\r\nbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\r\n"BS_%d : upload failed for cid 0x%x\n",\r\nbeiscsi_ep->ep_cid);\r\nret = -EAGAIN;\r\n}\r\nret = beiscsi_mccq_compl(phba, tag, NULL, NULL);\r\nbeiscsi_flush_cq(phba);\r\nreturn ret;\r\n}\r\nstatic int beiscsi_unbind_conn_to_cid(struct beiscsi_hba *phba,\r\nunsigned int cid)\r\n{\r\nuint16_t cri_index = BE_GET_CRI_FROM_CID(cid);\r\nif (phba->conn_table[cri_index])\r\nphba->conn_table[cri_index] = NULL;\r\nelse {\r\nbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\r\n"BS_%d : Connection table Not occupied.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid beiscsi_ep_disconnect(struct iscsi_endpoint *ep)\r\n{\r\nstruct beiscsi_conn *beiscsi_conn;\r\nstruct beiscsi_endpoint *beiscsi_ep;\r\nstruct beiscsi_hba *phba;\r\nunsigned int tag;\r\nuint8_t mgmt_invalidate_flag, tcp_upload_flag;\r\nunsigned short savecfg_flag = CMD_ISCSI_SESSION_SAVE_CFG_ON_FLASH;\r\nbeiscsi_ep = ep->dd_data;\r\nphba = beiscsi_ep->phba;\r\nbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\r\n"BS_%d : In beiscsi_ep_disconnect for ep_cid = %d\n",\r\nbeiscsi_ep->ep_cid);\r\nif (beiscsi_ep->conn) {\r\nbeiscsi_conn = beiscsi_ep->conn;\r\niscsi_suspend_queue(beiscsi_conn->conn);\r\nmgmt_invalidate_flag = ~BEISCSI_NO_RST_ISSUE;\r\ntcp_upload_flag = CONNECTION_UPLOAD_GRACEFUL;\r\n} else {\r\nmgmt_invalidate_flag = BEISCSI_NO_RST_ISSUE;\r\ntcp_upload_flag = CONNECTION_UPLOAD_ABORT;\r\n}\r\nif (phba->state & BE_ADAPTER_PCI_ERR) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BS_%d : PCI_ERROR Recovery\n");\r\ngoto free_ep;\r\n}\r\ntag = mgmt_invalidate_connection(phba, beiscsi_ep,\r\nbeiscsi_ep->ep_cid,\r\nmgmt_invalidate_flag,\r\nsavecfg_flag);\r\nif (!tag) {\r\nbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\r\n"BS_%d : mgmt_invalidate_connection Failed for cid=%d\n",\r\nbeiscsi_ep->ep_cid);\r\n}\r\nbeiscsi_mccq_compl(phba, tag, NULL, NULL);\r\nbeiscsi_close_conn(beiscsi_ep, tcp_upload_flag);\r\nfree_ep:\r\nmsleep(BEISCSI_LOGOUT_SYNC_DELAY);\r\nbeiscsi_free_ep(beiscsi_ep);\r\nbeiscsi_unbind_conn_to_cid(phba, beiscsi_ep->ep_cid);\r\niscsi_destroy_endpoint(beiscsi_ep->openiscsi_ep);\r\n}\r\numode_t be2iscsi_attr_is_visible(int param_type, int param)\r\n{\r\nswitch (param_type) {\r\ncase ISCSI_NET_PARAM:\r\nswitch (param) {\r\ncase ISCSI_NET_PARAM_IFACE_ENABLE:\r\ncase ISCSI_NET_PARAM_IPV4_ADDR:\r\ncase ISCSI_NET_PARAM_IPV4_SUBNET:\r\ncase ISCSI_NET_PARAM_IPV4_BOOTPROTO:\r\ncase ISCSI_NET_PARAM_IPV4_GW:\r\ncase ISCSI_NET_PARAM_IPV6_ADDR:\r\ncase ISCSI_NET_PARAM_VLAN_ID:\r\ncase ISCSI_NET_PARAM_VLAN_PRIORITY:\r\ncase ISCSI_NET_PARAM_VLAN_ENABLED:\r\nreturn S_IRUGO;\r\ndefault:\r\nreturn 0;\r\n}\r\ncase ISCSI_HOST_PARAM:\r\nswitch (param) {\r\ncase ISCSI_HOST_PARAM_HWADDRESS:\r\ncase ISCSI_HOST_PARAM_INITIATOR_NAME:\r\ncase ISCSI_HOST_PARAM_PORT_STATE:\r\ncase ISCSI_HOST_PARAM_PORT_SPEED:\r\nreturn S_IRUGO;\r\ndefault:\r\nreturn 0;\r\n}\r\ncase ISCSI_PARAM:\r\nswitch (param) {\r\ncase ISCSI_PARAM_MAX_RECV_DLENGTH:\r\ncase ISCSI_PARAM_MAX_XMIT_DLENGTH:\r\ncase ISCSI_PARAM_HDRDGST_EN:\r\ncase ISCSI_PARAM_DATADGST_EN:\r\ncase ISCSI_PARAM_CONN_ADDRESS:\r\ncase ISCSI_PARAM_CONN_PORT:\r\ncase ISCSI_PARAM_EXP_STATSN:\r\ncase ISCSI_PARAM_PERSISTENT_ADDRESS:\r\ncase ISCSI_PARAM_PERSISTENT_PORT:\r\ncase ISCSI_PARAM_PING_TMO:\r\ncase ISCSI_PARAM_RECV_TMO:\r\ncase ISCSI_PARAM_INITIAL_R2T_EN:\r\ncase ISCSI_PARAM_MAX_R2T:\r\ncase ISCSI_PARAM_IMM_DATA_EN:\r\ncase ISCSI_PARAM_FIRST_BURST:\r\ncase ISCSI_PARAM_MAX_BURST:\r\ncase ISCSI_PARAM_PDU_INORDER_EN:\r\ncase ISCSI_PARAM_DATASEQ_INORDER_EN:\r\ncase ISCSI_PARAM_ERL:\r\ncase ISCSI_PARAM_TARGET_NAME:\r\ncase ISCSI_PARAM_TPGT:\r\ncase ISCSI_PARAM_USERNAME:\r\ncase ISCSI_PARAM_PASSWORD:\r\ncase ISCSI_PARAM_USERNAME_IN:\r\ncase ISCSI_PARAM_PASSWORD_IN:\r\ncase ISCSI_PARAM_FAST_ABORT:\r\ncase ISCSI_PARAM_ABORT_TMO:\r\ncase ISCSI_PARAM_LU_RESET_TMO:\r\ncase ISCSI_PARAM_IFACE_NAME:\r\ncase ISCSI_PARAM_INITIATOR_NAME:\r\nreturn S_IRUGO;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nreturn 0;\r\n}
