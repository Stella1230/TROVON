int tcp_init_cgroup(struct mem_cgroup *memcg, struct cgroup_subsys *ss)\r\n{\r\nstruct mem_cgroup *parent = parent_mem_cgroup(memcg);\r\nstruct page_counter *counter_parent = NULL;\r\nstruct cg_proto *cg_proto, *parent_cg;\r\ncg_proto = tcp_prot.proto_cgroup(memcg);\r\nif (!cg_proto)\r\nreturn 0;\r\ncg_proto->sysctl_mem[0] = sysctl_tcp_mem[0];\r\ncg_proto->sysctl_mem[1] = sysctl_tcp_mem[1];\r\ncg_proto->sysctl_mem[2] = sysctl_tcp_mem[2];\r\ncg_proto->memory_pressure = 0;\r\ncg_proto->memcg = memcg;\r\nparent_cg = tcp_prot.proto_cgroup(parent);\r\nif (parent_cg)\r\ncounter_parent = &parent_cg->memory_allocated;\r\npage_counter_init(&cg_proto->memory_allocated, counter_parent);\r\npercpu_counter_init(&cg_proto->sockets_allocated, 0, GFP_KERNEL);\r\nreturn 0;\r\n}\r\nvoid tcp_destroy_cgroup(struct mem_cgroup *memcg)\r\n{\r\nstruct cg_proto *cg_proto;\r\ncg_proto = tcp_prot.proto_cgroup(memcg);\r\nif (!cg_proto)\r\nreturn;\r\npercpu_counter_destroy(&cg_proto->sockets_allocated);\r\nif (test_bit(MEMCG_SOCK_ACTIVATED, &cg_proto->flags))\r\nstatic_key_slow_dec(&memcg_socket_limit_enabled);\r\n}\r\nstatic int tcp_update_limit(struct mem_cgroup *memcg, unsigned long nr_pages)\r\n{\r\nstruct cg_proto *cg_proto;\r\nint i;\r\nint ret;\r\ncg_proto = tcp_prot.proto_cgroup(memcg);\r\nif (!cg_proto)\r\nreturn -EINVAL;\r\nret = page_counter_limit(&cg_proto->memory_allocated, nr_pages);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < 3; i++)\r\ncg_proto->sysctl_mem[i] = min_t(long, nr_pages,\r\nsysctl_tcp_mem[i]);\r\nif (nr_pages == PAGE_COUNTER_MAX)\r\nclear_bit(MEMCG_SOCK_ACTIVE, &cg_proto->flags);\r\nelse {\r\nif (!test_and_set_bit(MEMCG_SOCK_ACTIVATED, &cg_proto->flags))\r\nstatic_key_slow_inc(&memcg_socket_limit_enabled);\r\nset_bit(MEMCG_SOCK_ACTIVE, &cg_proto->flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t tcp_cgroup_write(struct kernfs_open_file *of,\r\nchar *buf, size_t nbytes, loff_t off)\r\n{\r\nstruct mem_cgroup *memcg = mem_cgroup_from_css(of_css(of));\r\nunsigned long nr_pages;\r\nint ret = 0;\r\nbuf = strstrip(buf);\r\nswitch (of_cft(of)->private) {\r\ncase RES_LIMIT:\r\nret = page_counter_memparse(buf, "-1", &nr_pages);\r\nif (ret)\r\nbreak;\r\nmutex_lock(&tcp_limit_mutex);\r\nret = tcp_update_limit(memcg, nr_pages);\r\nmutex_unlock(&tcp_limit_mutex);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret ?: nbytes;\r\n}\r\nstatic u64 tcp_cgroup_read(struct cgroup_subsys_state *css, struct cftype *cft)\r\n{\r\nstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\r\nstruct cg_proto *cg_proto = tcp_prot.proto_cgroup(memcg);\r\nu64 val;\r\nswitch (cft->private) {\r\ncase RES_LIMIT:\r\nif (!cg_proto)\r\nreturn PAGE_COUNTER_MAX;\r\nval = cg_proto->memory_allocated.limit;\r\nval *= PAGE_SIZE;\r\nbreak;\r\ncase RES_USAGE:\r\nif (!cg_proto)\r\nval = atomic_long_read(&tcp_memory_allocated);\r\nelse\r\nval = page_counter_read(&cg_proto->memory_allocated);\r\nval *= PAGE_SIZE;\r\nbreak;\r\ncase RES_FAILCNT:\r\nif (!cg_proto)\r\nreturn 0;\r\nval = cg_proto->memory_allocated.failcnt;\r\nbreak;\r\ncase RES_MAX_USAGE:\r\nif (!cg_proto)\r\nreturn 0;\r\nval = cg_proto->memory_allocated.watermark;\r\nval *= PAGE_SIZE;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn val;\r\n}\r\nstatic ssize_t tcp_cgroup_reset(struct kernfs_open_file *of,\r\nchar *buf, size_t nbytes, loff_t off)\r\n{\r\nstruct mem_cgroup *memcg;\r\nstruct cg_proto *cg_proto;\r\nmemcg = mem_cgroup_from_css(of_css(of));\r\ncg_proto = tcp_prot.proto_cgroup(memcg);\r\nif (!cg_proto)\r\nreturn nbytes;\r\nswitch (of_cft(of)->private) {\r\ncase RES_MAX_USAGE:\r\npage_counter_reset_watermark(&cg_proto->memory_allocated);\r\nbreak;\r\ncase RES_FAILCNT:\r\ncg_proto->memory_allocated.failcnt = 0;\r\nbreak;\r\n}\r\nreturn nbytes;\r\n}\r\nstatic int __init tcp_memcontrol_init(void)\r\n{\r\nWARN_ON(cgroup_add_legacy_cftypes(&memory_cgrp_subsys, tcp_files));\r\nreturn 0;\r\n}
