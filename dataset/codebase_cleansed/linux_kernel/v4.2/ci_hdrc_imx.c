static struct imx_usbmisc_data *usbmisc_get_init_data(struct device *dev)\r\n{\r\nstruct platform_device *misc_pdev;\r\nstruct device_node *np = dev->of_node;\r\nstruct of_phandle_args args;\r\nstruct imx_usbmisc_data *data;\r\nint ret;\r\nif (!of_get_property(np, "fsl,usbmisc", NULL))\r\nreturn NULL;\r\ndata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = of_parse_phandle_with_args(np, "fsl,usbmisc", "#index-cells",\r\n0, &args);\r\nif (ret) {\r\ndev_err(dev, "Failed to parse property fsl,usbmisc, errno %d\n",\r\nret);\r\nreturn ERR_PTR(ret);\r\n}\r\ndata->index = args.args[0];\r\nmisc_pdev = of_find_device_by_node(args.np);\r\nof_node_put(args.np);\r\nif (!misc_pdev)\r\nreturn ERR_PTR(-EPROBE_DEFER);\r\ndata->dev = &misc_pdev->dev;\r\nif (of_find_property(np, "disable-over-current", NULL))\r\ndata->disable_oc = 1;\r\nif (of_find_property(np, "external-vbus-divider", NULL))\r\ndata->evdo = 1;\r\nreturn data;\r\n}\r\nstatic int ci_hdrc_imx_probe(struct platform_device *pdev)\r\n{\r\nstruct ci_hdrc_imx_data *data;\r\nstruct ci_hdrc_platform_data pdata = {\r\n.name = dev_name(&pdev->dev),\r\n.capoffset = DEF_CAPOFFSET,\r\n.flags = CI_HDRC_DISABLE_STREAMING,\r\n};\r\nint ret;\r\nconst struct of_device_id *of_id =\r\nof_match_device(ci_hdrc_imx_dt_ids, &pdev->dev);\r\nconst struct ci_hdrc_imx_platform_flag *imx_platform_flag = of_id->data;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->usbmisc_data = usbmisc_get_init_data(&pdev->dev);\r\nif (IS_ERR(data->usbmisc_data))\r\nreturn PTR_ERR(data->usbmisc_data);\r\ndata->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(data->clk)) {\r\ndev_err(&pdev->dev,\r\n"Failed to get clock, err=%ld\n", PTR_ERR(data->clk));\r\nreturn PTR_ERR(data->clk);\r\n}\r\nret = clk_prepare_enable(data->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Failed to prepare or enable clock, err=%d\n", ret);\r\nreturn ret;\r\n}\r\ndata->phy = devm_usb_get_phy_by_phandle(&pdev->dev, "fsl,usbphy", 0);\r\nif (IS_ERR(data->phy)) {\r\nret = PTR_ERR(data->phy);\r\nif (ret == -ENODEV)\r\nret = -EINVAL;\r\ngoto err_clk;\r\n}\r\npdata.usb_phy = data->phy;\r\npdata.flags |= imx_platform_flag->flags;\r\nif (pdata.flags & CI_HDRC_SUPPORTS_RUNTIME_PM)\r\ndata->supports_runtime_pm = true;\r\nret = dma_coerce_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\r\nif (ret)\r\ngoto err_clk;\r\nret = imx_usbmisc_init(data->usbmisc_data);\r\nif (ret) {\r\ndev_err(&pdev->dev, "usbmisc init failed, ret=%d\n", ret);\r\ngoto err_clk;\r\n}\r\ndata->ci_pdev = ci_hdrc_add_device(&pdev->dev,\r\npdev->resource, pdev->num_resources,\r\n&pdata);\r\nif (IS_ERR(data->ci_pdev)) {\r\nret = PTR_ERR(data->ci_pdev);\r\ndev_err(&pdev->dev,\r\n"Can't register ci_hdrc platform device, err=%d\n",\r\nret);\r\ngoto err_clk;\r\n}\r\nret = imx_usbmisc_init_post(data->usbmisc_data);\r\nif (ret) {\r\ndev_err(&pdev->dev, "usbmisc post failed, ret=%d\n", ret);\r\ngoto disable_device;\r\n}\r\nplatform_set_drvdata(pdev, data);\r\nif (data->supports_runtime_pm) {\r\npm_runtime_set_active(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\n}\r\ndevice_set_wakeup_capable(&pdev->dev, true);\r\nreturn 0;\r\ndisable_device:\r\nci_hdrc_remove_device(data->ci_pdev);\r\nerr_clk:\r\nclk_disable_unprepare(data->clk);\r\nreturn ret;\r\n}\r\nstatic int ci_hdrc_imx_remove(struct platform_device *pdev)\r\n{\r\nstruct ci_hdrc_imx_data *data = platform_get_drvdata(pdev);\r\nif (data->supports_runtime_pm) {\r\npm_runtime_get_sync(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\npm_runtime_put_noidle(&pdev->dev);\r\n}\r\nci_hdrc_remove_device(data->ci_pdev);\r\nclk_disable_unprepare(data->clk);\r\nreturn 0;\r\n}\r\nstatic int imx_controller_suspend(struct device *dev)\r\n{\r\nstruct ci_hdrc_imx_data *data = dev_get_drvdata(dev);\r\ndev_dbg(dev, "at %s\n", __func__);\r\nclk_disable_unprepare(data->clk);\r\ndata->in_lpm = true;\r\nreturn 0;\r\n}\r\nstatic int imx_controller_resume(struct device *dev)\r\n{\r\nstruct ci_hdrc_imx_data *data = dev_get_drvdata(dev);\r\nint ret = 0;\r\ndev_dbg(dev, "at %s\n", __func__);\r\nif (!data->in_lpm) {\r\nWARN_ON(1);\r\nreturn 0;\r\n}\r\nret = clk_prepare_enable(data->clk);\r\nif (ret)\r\nreturn ret;\r\ndata->in_lpm = false;\r\nret = imx_usbmisc_set_wakeup(data->usbmisc_data, false);\r\nif (ret) {\r\ndev_err(dev, "usbmisc set_wakeup failed, ret=%d\n", ret);\r\ngoto clk_disable;\r\n}\r\nreturn 0;\r\nclk_disable:\r\nclk_disable_unprepare(data->clk);\r\nreturn ret;\r\n}\r\nstatic int ci_hdrc_imx_suspend(struct device *dev)\r\n{\r\nint ret;\r\nstruct ci_hdrc_imx_data *data = dev_get_drvdata(dev);\r\nif (data->in_lpm)\r\nreturn 0;\r\nif (device_may_wakeup(dev)) {\r\nret = imx_usbmisc_set_wakeup(data->usbmisc_data, true);\r\nif (ret) {\r\ndev_err(dev, "usbmisc set_wakeup failed, ret=%d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nreturn imx_controller_suspend(dev);\r\n}\r\nstatic int ci_hdrc_imx_resume(struct device *dev)\r\n{\r\nstruct ci_hdrc_imx_data *data = dev_get_drvdata(dev);\r\nint ret;\r\nret = imx_controller_resume(dev);\r\nif (!ret && data->supports_runtime_pm) {\r\npm_runtime_disable(dev);\r\npm_runtime_set_active(dev);\r\npm_runtime_enable(dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ci_hdrc_imx_runtime_suspend(struct device *dev)\r\n{\r\nstruct ci_hdrc_imx_data *data = dev_get_drvdata(dev);\r\nint ret;\r\nif (data->in_lpm) {\r\nWARN_ON(1);\r\nreturn 0;\r\n}\r\nret = imx_usbmisc_set_wakeup(data->usbmisc_data, true);\r\nif (ret) {\r\ndev_err(dev, "usbmisc set_wakeup failed, ret=%d\n", ret);\r\nreturn ret;\r\n}\r\nreturn imx_controller_suspend(dev);\r\n}\r\nstatic int ci_hdrc_imx_runtime_resume(struct device *dev)\r\n{\r\nreturn imx_controller_resume(dev);\r\n}
