static unsigned int\r\nreject_tg6(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct ip6t_reject_info *reject = par->targinfo;\r\nstruct net *net = dev_net((par->in != NULL) ? par->in : par->out);\r\npr_debug("%s: medium point\n", __func__);\r\nswitch (reject->with) {\r\ncase IP6T_ICMP6_NO_ROUTE:\r\nnf_send_unreach6(net, skb, ICMPV6_NOROUTE, par->hooknum);\r\nbreak;\r\ncase IP6T_ICMP6_ADM_PROHIBITED:\r\nnf_send_unreach6(net, skb, ICMPV6_ADM_PROHIBITED, par->hooknum);\r\nbreak;\r\ncase IP6T_ICMP6_NOT_NEIGHBOUR:\r\nnf_send_unreach6(net, skb, ICMPV6_NOT_NEIGHBOUR, par->hooknum);\r\nbreak;\r\ncase IP6T_ICMP6_ADDR_UNREACH:\r\nnf_send_unreach6(net, skb, ICMPV6_ADDR_UNREACH, par->hooknum);\r\nbreak;\r\ncase IP6T_ICMP6_PORT_UNREACH:\r\nnf_send_unreach6(net, skb, ICMPV6_PORT_UNREACH, par->hooknum);\r\nbreak;\r\ncase IP6T_ICMP6_ECHOREPLY:\r\nbreak;\r\ncase IP6T_TCP_RESET:\r\nnf_send_reset6(net, skb, par->hooknum);\r\nbreak;\r\ndefault:\r\nnet_info_ratelimited("case %u not handled yet\n", reject->with);\r\nbreak;\r\n}\r\nreturn NF_DROP;\r\n}\r\nstatic int reject_tg6_check(const struct xt_tgchk_param *par)\r\n{\r\nconst struct ip6t_reject_info *rejinfo = par->targinfo;\r\nconst struct ip6t_entry *e = par->entryinfo;\r\nif (rejinfo->with == IP6T_ICMP6_ECHOREPLY) {\r\npr_info("ECHOREPLY is not supported.\n");\r\nreturn -EINVAL;\r\n} else if (rejinfo->with == IP6T_TCP_RESET) {\r\nif (!(e->ipv6.flags & IP6T_F_PROTO) ||\r\ne->ipv6.proto != IPPROTO_TCP ||\r\n(e->ipv6.invflags & XT_INV_PROTO)) {\r\npr_info("TCP_RESET illegal for non-tcp\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init reject_tg6_init(void)\r\n{\r\nreturn xt_register_target(&reject_tg6_reg);\r\n}\r\nstatic void __exit reject_tg6_exit(void)\r\n{\r\nxt_unregister_target(&reject_tg6_reg);\r\n}
