static int dw_hdmi_imx_parse_dt(struct imx_hdmi *hdmi)\r\n{\r\nstruct device_node *np = hdmi->dev->of_node;\r\nhdmi->regmap = syscon_regmap_lookup_by_phandle(np, "gpr");\r\nif (IS_ERR(hdmi->regmap)) {\r\ndev_err(hdmi->dev, "Unable to get gpr\n");\r\nreturn PTR_ERR(hdmi->regmap);\r\n}\r\nreturn 0;\r\n}\r\nstatic void dw_hdmi_imx_encoder_disable(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic bool dw_hdmi_imx_encoder_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adj_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic void dw_hdmi_imx_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adj_mode)\r\n{\r\n}\r\nstatic void dw_hdmi_imx_encoder_commit(struct drm_encoder *encoder)\r\n{\r\nstruct imx_hdmi *hdmi = container_of(encoder, struct imx_hdmi, encoder);\r\nint mux = imx_drm_encoder_get_mux_id(hdmi->dev->of_node, encoder);\r\nregmap_update_bits(hdmi->regmap, IOMUXC_GPR3,\r\nIMX6Q_GPR3_HDMI_MUX_CTL_MASK,\r\nmux << IMX6Q_GPR3_HDMI_MUX_CTL_SHIFT);\r\n}\r\nstatic void dw_hdmi_imx_encoder_prepare(struct drm_encoder *encoder)\r\n{\r\nimx_drm_set_bus_format(encoder, MEDIA_BUS_FMT_RGB888_1X24);\r\n}\r\nstatic enum drm_mode_status imx6q_hdmi_mode_valid(struct drm_connector *con,\r\nstruct drm_display_mode *mode)\r\n{\r\nif (mode->clock < 13500)\r\nreturn MODE_CLOCK_LOW;\r\nif (mode->clock > 266000)\r\nreturn MODE_CLOCK_HIGH;\r\nreturn MODE_OK;\r\n}\r\nstatic enum drm_mode_status imx6dl_hdmi_mode_valid(struct drm_connector *con,\r\nstruct drm_display_mode *mode)\r\n{\r\nif (mode->clock < 13500)\r\nreturn MODE_CLOCK_LOW;\r\nif (mode->clock > 270000)\r\nreturn MODE_CLOCK_HIGH;\r\nreturn MODE_OK;\r\n}\r\nstatic int dw_hdmi_imx_bind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nconst struct dw_hdmi_plat_data *plat_data;\r\nconst struct of_device_id *match;\r\nstruct drm_device *drm = data;\r\nstruct drm_encoder *encoder;\r\nstruct imx_hdmi *hdmi;\r\nstruct resource *iores;\r\nint irq;\r\nint ret;\r\nif (!pdev->dev.of_node)\r\nreturn -ENODEV;\r\nhdmi = devm_kzalloc(&pdev->dev, sizeof(*hdmi), GFP_KERNEL);\r\nif (!hdmi)\r\nreturn -ENOMEM;\r\nmatch = of_match_node(dw_hdmi_imx_dt_ids, pdev->dev.of_node);\r\nplat_data = match->data;\r\nhdmi->dev = &pdev->dev;\r\nencoder = &hdmi->encoder;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\niores = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!iores)\r\nreturn -ENXIO;\r\nplatform_set_drvdata(pdev, hdmi);\r\nencoder->possible_crtcs = drm_of_find_possible_crtcs(drm, dev->of_node);\r\nif (encoder->possible_crtcs == 0)\r\nreturn -EPROBE_DEFER;\r\nret = dw_hdmi_imx_parse_dt(hdmi);\r\nif (ret < 0)\r\nreturn ret;\r\ndrm_encoder_helper_add(encoder, &dw_hdmi_imx_encoder_helper_funcs);\r\ndrm_encoder_init(drm, encoder, &dw_hdmi_imx_encoder_funcs,\r\nDRM_MODE_ENCODER_TMDS);\r\nreturn dw_hdmi_bind(dev, master, data, encoder, iores, irq, plat_data);\r\n}\r\nstatic void dw_hdmi_imx_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nreturn dw_hdmi_unbind(dev, master, data);\r\n}\r\nstatic int dw_hdmi_imx_probe(struct platform_device *pdev)\r\n{\r\nreturn component_add(&pdev->dev, &dw_hdmi_imx_ops);\r\n}\r\nstatic int dw_hdmi_imx_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &dw_hdmi_imx_ops);\r\nreturn 0;\r\n}
