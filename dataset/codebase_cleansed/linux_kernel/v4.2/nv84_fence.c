u64\r\nnv84_fence_crtc(struct nouveau_channel *chan, int crtc)\r\n{\r\nstruct nv84_fence_chan *fctx = chan->fence;\r\nreturn fctx->dispc_vma[crtc].offset;\r\n}\r\nstatic int\r\nnv84_fence_emit32(struct nouveau_channel *chan, u64 virtual, u32 sequence)\r\n{\r\nint ret = RING_SPACE(chan, 8);\r\nif (ret == 0) {\r\nBEGIN_NV04(chan, 0, NV11_SUBCHAN_DMA_SEMAPHORE, 1);\r\nOUT_RING (chan, chan->vram.handle);\r\nBEGIN_NV04(chan, 0, NV84_SUBCHAN_SEMAPHORE_ADDRESS_HIGH, 5);\r\nOUT_RING (chan, upper_32_bits(virtual));\r\nOUT_RING (chan, lower_32_bits(virtual));\r\nOUT_RING (chan, sequence);\r\nOUT_RING (chan, NV84_SUBCHAN_SEMAPHORE_TRIGGER_WRITE_LONG);\r\nOUT_RING (chan, 0x00000000);\r\nFIRE_RING (chan);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nnv84_fence_sync32(struct nouveau_channel *chan, u64 virtual, u32 sequence)\r\n{\r\nint ret = RING_SPACE(chan, 7);\r\nif (ret == 0) {\r\nBEGIN_NV04(chan, 0, NV11_SUBCHAN_DMA_SEMAPHORE, 1);\r\nOUT_RING (chan, chan->vram.handle);\r\nBEGIN_NV04(chan, 0, NV84_SUBCHAN_SEMAPHORE_ADDRESS_HIGH, 4);\r\nOUT_RING (chan, upper_32_bits(virtual));\r\nOUT_RING (chan, lower_32_bits(virtual));\r\nOUT_RING (chan, sequence);\r\nOUT_RING (chan, NV84_SUBCHAN_SEMAPHORE_TRIGGER_ACQUIRE_GEQUAL);\r\nFIRE_RING (chan);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nnv84_fence_emit(struct nouveau_fence *fence)\r\n{\r\nstruct nouveau_channel *chan = fence->channel;\r\nstruct nv84_fence_chan *fctx = chan->fence;\r\nu64 addr = chan->chid * 16;\r\nif (fence->sysmem)\r\naddr += fctx->vma_gart.offset;\r\nelse\r\naddr += fctx->vma.offset;\r\nreturn fctx->base.emit32(chan, addr, fence->base.seqno);\r\n}\r\nstatic int\r\nnv84_fence_sync(struct nouveau_fence *fence,\r\nstruct nouveau_channel *prev, struct nouveau_channel *chan)\r\n{\r\nstruct nv84_fence_chan *fctx = chan->fence;\r\nu64 addr = prev->chid * 16;\r\nif (fence->sysmem)\r\naddr += fctx->vma_gart.offset;\r\nelse\r\naddr += fctx->vma.offset;\r\nreturn fctx->base.sync32(chan, addr, fence->base.seqno);\r\n}\r\nstatic u32\r\nnv84_fence_read(struct nouveau_channel *chan)\r\n{\r\nstruct nv84_fence_priv *priv = chan->drm->fence;\r\nreturn nouveau_bo_rd32(priv->bo, chan->chid * 16/4);\r\n}\r\nstatic void\r\nnv84_fence_context_del(struct nouveau_channel *chan)\r\n{\r\nstruct drm_device *dev = chan->drm->dev;\r\nstruct nv84_fence_priv *priv = chan->drm->fence;\r\nstruct nv84_fence_chan *fctx = chan->fence;\r\nint i;\r\nfor (i = 0; i < dev->mode_config.num_crtc; i++) {\r\nstruct nouveau_bo *bo = nv50_display_crtc_sema(dev, i);\r\nnouveau_bo_vma_del(bo, &fctx->dispc_vma[i]);\r\n}\r\nnouveau_bo_wr32(priv->bo, chan->chid * 16 / 4, fctx->base.sequence);\r\nnouveau_bo_vma_del(priv->bo, &fctx->vma_gart);\r\nnouveau_bo_vma_del(priv->bo, &fctx->vma);\r\nnouveau_fence_context_del(&fctx->base);\r\nchan->fence = NULL;\r\nnouveau_fence_context_free(&fctx->base);\r\n}\r\nint\r\nnv84_fence_context_new(struct nouveau_channel *chan)\r\n{\r\nstruct nouveau_cli *cli = (void *)nvif_client(&chan->device->base);\r\nstruct nv84_fence_priv *priv = chan->drm->fence;\r\nstruct nv84_fence_chan *fctx;\r\nint ret, i;\r\nfctx = chan->fence = kzalloc(sizeof(*fctx), GFP_KERNEL);\r\nif (!fctx)\r\nreturn -ENOMEM;\r\nnouveau_fence_context_new(chan, &fctx->base);\r\nfctx->base.emit = nv84_fence_emit;\r\nfctx->base.sync = nv84_fence_sync;\r\nfctx->base.read = nv84_fence_read;\r\nfctx->base.emit32 = nv84_fence_emit32;\r\nfctx->base.sync32 = nv84_fence_sync32;\r\nfctx->base.sequence = nv84_fence_read(chan);\r\nret = nouveau_bo_vma_add(priv->bo, cli->vm, &fctx->vma);\r\nif (ret == 0) {\r\nret = nouveau_bo_vma_add(priv->bo_gart, cli->vm,\r\n&fctx->vma_gart);\r\n}\r\nfor (i = 0; !ret && i < chan->drm->dev->mode_config.num_crtc; i++) {\r\nstruct nouveau_bo *bo = nv50_display_crtc_sema(chan->drm->dev, i);\r\nret = nouveau_bo_vma_add(bo, cli->vm, &fctx->dispc_vma[i]);\r\n}\r\nif (ret)\r\nnv84_fence_context_del(chan);\r\nreturn ret;\r\n}\r\nstatic bool\r\nnv84_fence_suspend(struct nouveau_drm *drm)\r\n{\r\nstruct nv84_fence_priv *priv = drm->fence;\r\nint i;\r\npriv->suspend = vmalloc(priv->base.contexts * sizeof(u32));\r\nif (priv->suspend) {\r\nfor (i = 0; i < priv->base.contexts; i++)\r\npriv->suspend[i] = nouveau_bo_rd32(priv->bo, i*4);\r\n}\r\nreturn priv->suspend != NULL;\r\n}\r\nstatic void\r\nnv84_fence_resume(struct nouveau_drm *drm)\r\n{\r\nstruct nv84_fence_priv *priv = drm->fence;\r\nint i;\r\nif (priv->suspend) {\r\nfor (i = 0; i < priv->base.contexts; i++)\r\nnouveau_bo_wr32(priv->bo, i*4, priv->suspend[i]);\r\nvfree(priv->suspend);\r\npriv->suspend = NULL;\r\n}\r\n}\r\nstatic void\r\nnv84_fence_destroy(struct nouveau_drm *drm)\r\n{\r\nstruct nv84_fence_priv *priv = drm->fence;\r\nnouveau_bo_unmap(priv->bo_gart);\r\nif (priv->bo_gart)\r\nnouveau_bo_unpin(priv->bo_gart);\r\nnouveau_bo_ref(NULL, &priv->bo_gart);\r\nnouveau_bo_unmap(priv->bo);\r\nif (priv->bo)\r\nnouveau_bo_unpin(priv->bo);\r\nnouveau_bo_ref(NULL, &priv->bo);\r\ndrm->fence = NULL;\r\nkfree(priv);\r\n}\r\nint\r\nnv84_fence_create(struct nouveau_drm *drm)\r\n{\r\nstruct nvkm_fifo *pfifo = nvxx_fifo(&drm->device);\r\nstruct nv84_fence_priv *priv;\r\nu32 domain;\r\nint ret;\r\npriv = drm->fence = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->base.dtor = nv84_fence_destroy;\r\npriv->base.suspend = nv84_fence_suspend;\r\npriv->base.resume = nv84_fence_resume;\r\npriv->base.context_new = nv84_fence_context_new;\r\npriv->base.context_del = nv84_fence_context_del;\r\npriv->base.contexts = pfifo->max + 1;\r\npriv->base.context_base = fence_context_alloc(priv->base.contexts);\r\npriv->base.uevent = true;\r\ndomain = drm->device.info.ram_size != 0 ? TTM_PL_FLAG_VRAM :\r\nTTM_PL_FLAG_TT | TTM_PL_FLAG_UNCACHED;\r\nret = nouveau_bo_new(drm->dev, 16 * priv->base.contexts, 0, domain, 0,\r\n0, NULL, NULL, &priv->bo);\r\nif (ret == 0) {\r\nret = nouveau_bo_pin(priv->bo, domain, false);\r\nif (ret == 0) {\r\nret = nouveau_bo_map(priv->bo);\r\nif (ret)\r\nnouveau_bo_unpin(priv->bo);\r\n}\r\nif (ret)\r\nnouveau_bo_ref(NULL, &priv->bo);\r\n}\r\nif (ret == 0)\r\nret = nouveau_bo_new(drm->dev, 16 * priv->base.contexts, 0,\r\nTTM_PL_FLAG_TT | TTM_PL_FLAG_UNCACHED, 0,\r\n0, NULL, NULL, &priv->bo_gart);\r\nif (ret == 0) {\r\nret = nouveau_bo_pin(priv->bo_gart, TTM_PL_FLAG_TT, false);\r\nif (ret == 0) {\r\nret = nouveau_bo_map(priv->bo_gart);\r\nif (ret)\r\nnouveau_bo_unpin(priv->bo_gart);\r\n}\r\nif (ret)\r\nnouveau_bo_ref(NULL, &priv->bo_gart);\r\n}\r\nif (ret)\r\nnv84_fence_destroy(drm);\r\nreturn ret;\r\n}
