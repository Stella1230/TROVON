static void show_fdinfo(struct seq_file *m, struct file *f,\r\nvoid (*show)(struct seq_file *m,\r\nstruct fsnotify_mark *mark))\r\n{\r\nstruct fsnotify_group *group = f->private_data;\r\nstruct fsnotify_mark *mark;\r\nmutex_lock(&group->mark_mutex);\r\nlist_for_each_entry(mark, &group->marks_list, g_list) {\r\nshow(m, mark);\r\nif (seq_has_overflowed(m))\r\nbreak;\r\n}\r\nmutex_unlock(&group->mark_mutex);\r\n}\r\nstatic void show_mark_fhandle(struct seq_file *m, struct inode *inode)\r\n{\r\nstruct {\r\nstruct file_handle handle;\r\nu8 pad[MAX_HANDLE_SZ];\r\n} f;\r\nint size, ret, i;\r\nf.handle.handle_bytes = sizeof(f.pad);\r\nsize = f.handle.handle_bytes >> 2;\r\nret = exportfs_encode_inode_fh(inode, (struct fid *)f.handle.f_handle, &size, 0);\r\nif ((ret == FILEID_INVALID) || (ret < 0)) {\r\nWARN_ONCE(1, "Can't encode file handler for inotify: %d\n", ret);\r\nreturn;\r\n}\r\nf.handle.handle_type = ret;\r\nf.handle.handle_bytes = size * sizeof(u32);\r\nseq_printf(m, "fhandle-bytes:%x fhandle-type:%x f_handle:",\r\nf.handle.handle_bytes, f.handle.handle_type);\r\nfor (i = 0; i < f.handle.handle_bytes; i++)\r\nseq_printf(m, "%02x", (int)f.handle.f_handle[i]);\r\n}\r\nstatic void show_mark_fhandle(struct seq_file *m, struct inode *inode)\r\n{\r\n}\r\nstatic void inotify_fdinfo(struct seq_file *m, struct fsnotify_mark *mark)\r\n{\r\nstruct inotify_inode_mark *inode_mark;\r\nstruct inode *inode;\r\nif (!(mark->flags & (FSNOTIFY_MARK_FLAG_ALIVE | FSNOTIFY_MARK_FLAG_INODE)))\r\nreturn;\r\ninode_mark = container_of(mark, struct inotify_inode_mark, fsn_mark);\r\ninode = igrab(mark->inode);\r\nif (inode) {\r\nseq_printf(m, "inotify wd:%x ino:%lx sdev:%x mask:%x ignored_mask:%x ",\r\ninode_mark->wd, inode->i_ino, inode->i_sb->s_dev,\r\nmark->mask, mark->ignored_mask);\r\nshow_mark_fhandle(m, inode);\r\nseq_putc(m, '\n');\r\niput(inode);\r\n}\r\n}\r\nvoid inotify_show_fdinfo(struct seq_file *m, struct file *f)\r\n{\r\nshow_fdinfo(m, f, inotify_fdinfo);\r\n}\r\nstatic void fanotify_fdinfo(struct seq_file *m, struct fsnotify_mark *mark)\r\n{\r\nunsigned int mflags = 0;\r\nstruct inode *inode;\r\nif (!(mark->flags & FSNOTIFY_MARK_FLAG_ALIVE))\r\nreturn;\r\nif (mark->flags & FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY)\r\nmflags |= FAN_MARK_IGNORED_SURV_MODIFY;\r\nif (mark->flags & FSNOTIFY_MARK_FLAG_INODE) {\r\ninode = igrab(mark->inode);\r\nif (!inode)\r\nreturn;\r\nseq_printf(m, "fanotify ino:%lx sdev:%x mflags:%x mask:%x ignored_mask:%x ",\r\ninode->i_ino, inode->i_sb->s_dev,\r\nmflags, mark->mask, mark->ignored_mask);\r\nshow_mark_fhandle(m, inode);\r\nseq_putc(m, '\n');\r\niput(inode);\r\n} else if (mark->flags & FSNOTIFY_MARK_FLAG_VFSMOUNT) {\r\nstruct mount *mnt = real_mount(mark->mnt);\r\nseq_printf(m, "fanotify mnt_id:%x mflags:%x mask:%x ignored_mask:%x\n",\r\nmnt->mnt_id, mflags, mark->mask, mark->ignored_mask);\r\n}\r\n}\r\nvoid fanotify_show_fdinfo(struct seq_file *m, struct file *f)\r\n{\r\nstruct fsnotify_group *group = f->private_data;\r\nunsigned int flags = 0;\r\nswitch (group->priority) {\r\ncase FS_PRIO_0:\r\nflags |= FAN_CLASS_NOTIF;\r\nbreak;\r\ncase FS_PRIO_1:\r\nflags |= FAN_CLASS_CONTENT;\r\nbreak;\r\ncase FS_PRIO_2:\r\nflags |= FAN_CLASS_PRE_CONTENT;\r\nbreak;\r\n}\r\nif (group->max_events == UINT_MAX)\r\nflags |= FAN_UNLIMITED_QUEUE;\r\nif (group->fanotify_data.max_marks == UINT_MAX)\r\nflags |= FAN_UNLIMITED_MARKS;\r\nseq_printf(m, "fanotify flags:%x event-flags:%x\n",\r\nflags, group->fanotify_data.f_flags);\r\nshow_fdinfo(m, f, fanotify_fdinfo);\r\n}
