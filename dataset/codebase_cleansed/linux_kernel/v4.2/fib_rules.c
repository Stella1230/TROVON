int fib_default_rule_add(struct fib_rules_ops *ops,\r\nu32 pref, u32 table, u32 flags)\r\n{\r\nstruct fib_rule *r;\r\nr = kzalloc(ops->rule_size, GFP_KERNEL);\r\nif (r == NULL)\r\nreturn -ENOMEM;\r\natomic_set(&r->refcnt, 1);\r\nr->action = FR_ACT_TO_TBL;\r\nr->pref = pref;\r\nr->table = table;\r\nr->flags = flags;\r\nr->fr_net = ops->fro_net;\r\nr->suppress_prefixlen = -1;\r\nr->suppress_ifgroup = -1;\r\nlist_add_tail(&r->list, &ops->rules_list);\r\nreturn 0;\r\n}\r\nu32 fib_default_rule_pref(struct fib_rules_ops *ops)\r\n{\r\nstruct list_head *pos;\r\nstruct fib_rule *rule;\r\nif (!list_empty(&ops->rules_list)) {\r\npos = ops->rules_list.next;\r\nif (pos->next != &ops->rules_list) {\r\nrule = list_entry(pos->next, struct fib_rule, list);\r\nif (rule->pref)\r\nreturn rule->pref - 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct fib_rules_ops *lookup_rules_ops(struct net *net, int family)\r\n{\r\nstruct fib_rules_ops *ops;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(ops, &net->rules_ops, list) {\r\nif (ops->family == family) {\r\nif (!try_module_get(ops->owner))\r\nops = NULL;\r\nrcu_read_unlock();\r\nreturn ops;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn NULL;\r\n}\r\nstatic void rules_ops_put(struct fib_rules_ops *ops)\r\n{\r\nif (ops)\r\nmodule_put(ops->owner);\r\n}\r\nstatic void flush_route_cache(struct fib_rules_ops *ops)\r\n{\r\nif (ops->flush_cache)\r\nops->flush_cache(ops);\r\n}\r\nstatic int __fib_rules_register(struct fib_rules_ops *ops)\r\n{\r\nint err = -EEXIST;\r\nstruct fib_rules_ops *o;\r\nstruct net *net;\r\nnet = ops->fro_net;\r\nif (ops->rule_size < sizeof(struct fib_rule))\r\nreturn -EINVAL;\r\nif (ops->match == NULL || ops->configure == NULL ||\r\nops->compare == NULL || ops->fill == NULL ||\r\nops->action == NULL)\r\nreturn -EINVAL;\r\nspin_lock(&net->rules_mod_lock);\r\nlist_for_each_entry(o, &net->rules_ops, list)\r\nif (ops->family == o->family)\r\ngoto errout;\r\nlist_add_tail_rcu(&ops->list, &net->rules_ops);\r\nerr = 0;\r\nerrout:\r\nspin_unlock(&net->rules_mod_lock);\r\nreturn err;\r\n}\r\nstruct fib_rules_ops *\r\nfib_rules_register(const struct fib_rules_ops *tmpl, struct net *net)\r\n{\r\nstruct fib_rules_ops *ops;\r\nint err;\r\nops = kmemdup(tmpl, sizeof(*ops), GFP_KERNEL);\r\nif (ops == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nINIT_LIST_HEAD(&ops->rules_list);\r\nops->fro_net = net;\r\nerr = __fib_rules_register(ops);\r\nif (err) {\r\nkfree(ops);\r\nops = ERR_PTR(err);\r\n}\r\nreturn ops;\r\n}\r\nstatic void fib_rules_cleanup_ops(struct fib_rules_ops *ops)\r\n{\r\nstruct fib_rule *rule, *tmp;\r\nlist_for_each_entry_safe(rule, tmp, &ops->rules_list, list) {\r\nlist_del_rcu(&rule->list);\r\nif (ops->delete)\r\nops->delete(rule);\r\nfib_rule_put(rule);\r\n}\r\n}\r\nvoid fib_rules_unregister(struct fib_rules_ops *ops)\r\n{\r\nstruct net *net = ops->fro_net;\r\nspin_lock(&net->rules_mod_lock);\r\nlist_del_rcu(&ops->list);\r\nspin_unlock(&net->rules_mod_lock);\r\nfib_rules_cleanup_ops(ops);\r\nkfree_rcu(ops, rcu);\r\n}\r\nstatic int fib_rule_match(struct fib_rule *rule, struct fib_rules_ops *ops,\r\nstruct flowi *fl, int flags)\r\n{\r\nint ret = 0;\r\nif (rule->iifindex && (rule->iifindex != fl->flowi_iif))\r\ngoto out;\r\nif (rule->oifindex && (rule->oifindex != fl->flowi_oif))\r\ngoto out;\r\nif ((rule->mark ^ fl->flowi_mark) & rule->mark_mask)\r\ngoto out;\r\nret = ops->match(rule, fl, flags);\r\nout:\r\nreturn (rule->flags & FIB_RULE_INVERT) ? !ret : ret;\r\n}\r\nint fib_rules_lookup(struct fib_rules_ops *ops, struct flowi *fl,\r\nint flags, struct fib_lookup_arg *arg)\r\n{\r\nstruct fib_rule *rule;\r\nint err;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(rule, &ops->rules_list, list) {\r\njumped:\r\nif (!fib_rule_match(rule, ops, fl, flags))\r\ncontinue;\r\nif (rule->action == FR_ACT_GOTO) {\r\nstruct fib_rule *target;\r\ntarget = rcu_dereference(rule->ctarget);\r\nif (target == NULL) {\r\ncontinue;\r\n} else {\r\nrule = target;\r\ngoto jumped;\r\n}\r\n} else if (rule->action == FR_ACT_NOP)\r\ncontinue;\r\nelse\r\nerr = ops->action(rule, fl, flags, arg);\r\nif (!err && ops->suppress && ops->suppress(rule, arg))\r\ncontinue;\r\nif (err != -EAGAIN) {\r\nif ((arg->flags & FIB_LOOKUP_NOREF) ||\r\nlikely(atomic_inc_not_zero(&rule->refcnt))) {\r\narg->rule = rule;\r\ngoto out;\r\n}\r\nbreak;\r\n}\r\n}\r\nerr = -ESRCH;\r\nout:\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nstatic int validate_rulemsg(struct fib_rule_hdr *frh, struct nlattr **tb,\r\nstruct fib_rules_ops *ops)\r\n{\r\nint err = -EINVAL;\r\nif (frh->src_len)\r\nif (tb[FRA_SRC] == NULL ||\r\nfrh->src_len > (ops->addr_size * 8) ||\r\nnla_len(tb[FRA_SRC]) != ops->addr_size)\r\ngoto errout;\r\nif (frh->dst_len)\r\nif (tb[FRA_DST] == NULL ||\r\nfrh->dst_len > (ops->addr_size * 8) ||\r\nnla_len(tb[FRA_DST]) != ops->addr_size)\r\ngoto errout;\r\nerr = 0;\r\nerrout:\r\nreturn err;\r\n}\r\nstatic int fib_nl_newrule(struct sk_buff *skb, struct nlmsghdr* nlh)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct fib_rule_hdr *frh = nlmsg_data(nlh);\r\nstruct fib_rules_ops *ops = NULL;\r\nstruct fib_rule *rule, *r, *last = NULL;\r\nstruct nlattr *tb[FRA_MAX+1];\r\nint err = -EINVAL, unresolved = 0;\r\nif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*frh)))\r\ngoto errout;\r\nops = lookup_rules_ops(net, frh->family);\r\nif (ops == NULL) {\r\nerr = -EAFNOSUPPORT;\r\ngoto errout;\r\n}\r\nerr = nlmsg_parse(nlh, sizeof(*frh), tb, FRA_MAX, ops->policy);\r\nif (err < 0)\r\ngoto errout;\r\nerr = validate_rulemsg(frh, tb, ops);\r\nif (err < 0)\r\ngoto errout;\r\nrule = kzalloc(ops->rule_size, GFP_KERNEL);\r\nif (rule == NULL) {\r\nerr = -ENOMEM;\r\ngoto errout;\r\n}\r\nrule->fr_net = net;\r\nif (tb[FRA_PRIORITY])\r\nrule->pref = nla_get_u32(tb[FRA_PRIORITY]);\r\nif (tb[FRA_IIFNAME]) {\r\nstruct net_device *dev;\r\nrule->iifindex = -1;\r\nnla_strlcpy(rule->iifname, tb[FRA_IIFNAME], IFNAMSIZ);\r\ndev = __dev_get_by_name(net, rule->iifname);\r\nif (dev)\r\nrule->iifindex = dev->ifindex;\r\n}\r\nif (tb[FRA_OIFNAME]) {\r\nstruct net_device *dev;\r\nrule->oifindex = -1;\r\nnla_strlcpy(rule->oifname, tb[FRA_OIFNAME], IFNAMSIZ);\r\ndev = __dev_get_by_name(net, rule->oifname);\r\nif (dev)\r\nrule->oifindex = dev->ifindex;\r\n}\r\nif (tb[FRA_FWMARK]) {\r\nrule->mark = nla_get_u32(tb[FRA_FWMARK]);\r\nif (rule->mark)\r\nrule->mark_mask = 0xFFFFFFFF;\r\n}\r\nif (tb[FRA_FWMASK])\r\nrule->mark_mask = nla_get_u32(tb[FRA_FWMASK]);\r\nrule->action = frh->action;\r\nrule->flags = frh->flags;\r\nrule->table = frh_get_table(frh, tb);\r\nif (tb[FRA_SUPPRESS_PREFIXLEN])\r\nrule->suppress_prefixlen = nla_get_u32(tb[FRA_SUPPRESS_PREFIXLEN]);\r\nelse\r\nrule->suppress_prefixlen = -1;\r\nif (tb[FRA_SUPPRESS_IFGROUP])\r\nrule->suppress_ifgroup = nla_get_u32(tb[FRA_SUPPRESS_IFGROUP]);\r\nelse\r\nrule->suppress_ifgroup = -1;\r\nif (!tb[FRA_PRIORITY] && ops->default_pref)\r\nrule->pref = ops->default_pref(ops);\r\nerr = -EINVAL;\r\nif (tb[FRA_GOTO]) {\r\nif (rule->action != FR_ACT_GOTO)\r\ngoto errout_free;\r\nrule->target = nla_get_u32(tb[FRA_GOTO]);\r\nif (rule->target <= rule->pref)\r\ngoto errout_free;\r\nlist_for_each_entry(r, &ops->rules_list, list) {\r\nif (r->pref == rule->target) {\r\nRCU_INIT_POINTER(rule->ctarget, r);\r\nbreak;\r\n}\r\n}\r\nif (rcu_dereference_protected(rule->ctarget, 1) == NULL)\r\nunresolved = 1;\r\n} else if (rule->action == FR_ACT_GOTO)\r\ngoto errout_free;\r\nerr = ops->configure(rule, skb, frh, tb);\r\nif (err < 0)\r\ngoto errout_free;\r\nlist_for_each_entry(r, &ops->rules_list, list) {\r\nif (r->pref > rule->pref)\r\nbreak;\r\nlast = r;\r\n}\r\nfib_rule_get(rule);\r\nif (last)\r\nlist_add_rcu(&rule->list, &last->list);\r\nelse\r\nlist_add_rcu(&rule->list, &ops->rules_list);\r\nif (ops->unresolved_rules) {\r\nlist_for_each_entry(r, &ops->rules_list, list) {\r\nif (r->action == FR_ACT_GOTO &&\r\nr->target == rule->pref &&\r\nrtnl_dereference(r->ctarget) == NULL) {\r\nrcu_assign_pointer(r->ctarget, rule);\r\nif (--ops->unresolved_rules == 0)\r\nbreak;\r\n}\r\n}\r\n}\r\nif (rule->action == FR_ACT_GOTO)\r\nops->nr_goto_rules++;\r\nif (unresolved)\r\nops->unresolved_rules++;\r\nnotify_rule_change(RTM_NEWRULE, rule, ops, nlh, NETLINK_CB(skb).portid);\r\nflush_route_cache(ops);\r\nrules_ops_put(ops);\r\nreturn 0;\r\nerrout_free:\r\nkfree(rule);\r\nerrout:\r\nrules_ops_put(ops);\r\nreturn err;\r\n}\r\nstatic int fib_nl_delrule(struct sk_buff *skb, struct nlmsghdr* nlh)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct fib_rule_hdr *frh = nlmsg_data(nlh);\r\nstruct fib_rules_ops *ops = NULL;\r\nstruct fib_rule *rule, *tmp;\r\nstruct nlattr *tb[FRA_MAX+1];\r\nint err = -EINVAL;\r\nif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*frh)))\r\ngoto errout;\r\nops = lookup_rules_ops(net, frh->family);\r\nif (ops == NULL) {\r\nerr = -EAFNOSUPPORT;\r\ngoto errout;\r\n}\r\nerr = nlmsg_parse(nlh, sizeof(*frh), tb, FRA_MAX, ops->policy);\r\nif (err < 0)\r\ngoto errout;\r\nerr = validate_rulemsg(frh, tb, ops);\r\nif (err < 0)\r\ngoto errout;\r\nlist_for_each_entry(rule, &ops->rules_list, list) {\r\nif (frh->action && (frh->action != rule->action))\r\ncontinue;\r\nif (frh_get_table(frh, tb) &&\r\n(frh_get_table(frh, tb) != rule->table))\r\ncontinue;\r\nif (tb[FRA_PRIORITY] &&\r\n(rule->pref != nla_get_u32(tb[FRA_PRIORITY])))\r\ncontinue;\r\nif (tb[FRA_IIFNAME] &&\r\nnla_strcmp(tb[FRA_IIFNAME], rule->iifname))\r\ncontinue;\r\nif (tb[FRA_OIFNAME] &&\r\nnla_strcmp(tb[FRA_OIFNAME], rule->oifname))\r\ncontinue;\r\nif (tb[FRA_FWMARK] &&\r\n(rule->mark != nla_get_u32(tb[FRA_FWMARK])))\r\ncontinue;\r\nif (tb[FRA_FWMASK] &&\r\n(rule->mark_mask != nla_get_u32(tb[FRA_FWMASK])))\r\ncontinue;\r\nif (!ops->compare(rule, frh, tb))\r\ncontinue;\r\nif (rule->flags & FIB_RULE_PERMANENT) {\r\nerr = -EPERM;\r\ngoto errout;\r\n}\r\nif (ops->delete) {\r\nerr = ops->delete(rule);\r\nif (err)\r\ngoto errout;\r\n}\r\nlist_del_rcu(&rule->list);\r\nif (rule->action == FR_ACT_GOTO) {\r\nops->nr_goto_rules--;\r\nif (rtnl_dereference(rule->ctarget) == NULL)\r\nops->unresolved_rules--;\r\n}\r\nif (ops->nr_goto_rules > 0) {\r\nlist_for_each_entry(tmp, &ops->rules_list, list) {\r\nif (rtnl_dereference(tmp->ctarget) == rule) {\r\nRCU_INIT_POINTER(tmp->ctarget, NULL);\r\nops->unresolved_rules++;\r\n}\r\n}\r\n}\r\nnotify_rule_change(RTM_DELRULE, rule, ops, nlh,\r\nNETLINK_CB(skb).portid);\r\nfib_rule_put(rule);\r\nflush_route_cache(ops);\r\nrules_ops_put(ops);\r\nreturn 0;\r\n}\r\nerr = -ENOENT;\r\nerrout:\r\nrules_ops_put(ops);\r\nreturn err;\r\n}\r\nstatic inline size_t fib_rule_nlmsg_size(struct fib_rules_ops *ops,\r\nstruct fib_rule *rule)\r\n{\r\nsize_t payload = NLMSG_ALIGN(sizeof(struct fib_rule_hdr))\r\n+ nla_total_size(IFNAMSIZ)\r\n+ nla_total_size(IFNAMSIZ)\r\n+ nla_total_size(4)\r\n+ nla_total_size(4)\r\n+ nla_total_size(4)\r\n+ nla_total_size(4)\r\n+ nla_total_size(4)\r\n+ nla_total_size(4);\r\nif (ops->nlmsg_payload)\r\npayload += ops->nlmsg_payload(rule);\r\nreturn payload;\r\n}\r\nstatic int fib_nl_fill_rule(struct sk_buff *skb, struct fib_rule *rule,\r\nu32 pid, u32 seq, int type, int flags,\r\nstruct fib_rules_ops *ops)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct fib_rule_hdr *frh;\r\nnlh = nlmsg_put(skb, pid, seq, type, sizeof(*frh), flags);\r\nif (nlh == NULL)\r\nreturn -EMSGSIZE;\r\nfrh = nlmsg_data(nlh);\r\nfrh->family = ops->family;\r\nfrh->table = rule->table;\r\nif (nla_put_u32(skb, FRA_TABLE, rule->table))\r\ngoto nla_put_failure;\r\nif (nla_put_u32(skb, FRA_SUPPRESS_PREFIXLEN, rule->suppress_prefixlen))\r\ngoto nla_put_failure;\r\nfrh->res1 = 0;\r\nfrh->res2 = 0;\r\nfrh->action = rule->action;\r\nfrh->flags = rule->flags;\r\nif (rule->action == FR_ACT_GOTO &&\r\nrcu_access_pointer(rule->ctarget) == NULL)\r\nfrh->flags |= FIB_RULE_UNRESOLVED;\r\nif (rule->iifname[0]) {\r\nif (nla_put_string(skb, FRA_IIFNAME, rule->iifname))\r\ngoto nla_put_failure;\r\nif (rule->iifindex == -1)\r\nfrh->flags |= FIB_RULE_IIF_DETACHED;\r\n}\r\nif (rule->oifname[0]) {\r\nif (nla_put_string(skb, FRA_OIFNAME, rule->oifname))\r\ngoto nla_put_failure;\r\nif (rule->oifindex == -1)\r\nfrh->flags |= FIB_RULE_OIF_DETACHED;\r\n}\r\nif ((rule->pref &&\r\nnla_put_u32(skb, FRA_PRIORITY, rule->pref)) ||\r\n(rule->mark &&\r\nnla_put_u32(skb, FRA_FWMARK, rule->mark)) ||\r\n((rule->mark_mask || rule->mark) &&\r\nnla_put_u32(skb, FRA_FWMASK, rule->mark_mask)) ||\r\n(rule->target &&\r\nnla_put_u32(skb, FRA_GOTO, rule->target)))\r\ngoto nla_put_failure;\r\nif (rule->suppress_ifgroup != -1) {\r\nif (nla_put_u32(skb, FRA_SUPPRESS_IFGROUP, rule->suppress_ifgroup))\r\ngoto nla_put_failure;\r\n}\r\nif (ops->fill(rule, skb, frh) < 0)\r\ngoto nla_put_failure;\r\nnlmsg_end(skb, nlh);\r\nreturn 0;\r\nnla_put_failure:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int dump_rules(struct sk_buff *skb, struct netlink_callback *cb,\r\nstruct fib_rules_ops *ops)\r\n{\r\nint idx = 0;\r\nstruct fib_rule *rule;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(rule, &ops->rules_list, list) {\r\nif (idx < cb->args[1])\r\ngoto skip;\r\nif (fib_nl_fill_rule(skb, rule, NETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, RTM_NEWRULE,\r\nNLM_F_MULTI, ops) < 0)\r\nbreak;\r\nskip:\r\nidx++;\r\n}\r\nrcu_read_unlock();\r\ncb->args[1] = idx;\r\nrules_ops_put(ops);\r\nreturn skb->len;\r\n}\r\nstatic int fib_nl_dumprule(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct fib_rules_ops *ops;\r\nint idx = 0, family;\r\nfamily = rtnl_msg_family(cb->nlh);\r\nif (family != AF_UNSPEC) {\r\nops = lookup_rules_ops(net, family);\r\nif (ops == NULL)\r\nreturn -EAFNOSUPPORT;\r\nreturn dump_rules(skb, cb, ops);\r\n}\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(ops, &net->rules_ops, list) {\r\nif (idx < cb->args[0] || !try_module_get(ops->owner))\r\ngoto skip;\r\nif (dump_rules(skb, cb, ops) < 0)\r\nbreak;\r\ncb->args[1] = 0;\r\nskip:\r\nidx++;\r\n}\r\nrcu_read_unlock();\r\ncb->args[0] = idx;\r\nreturn skb->len;\r\n}\r\nstatic void notify_rule_change(int event, struct fib_rule *rule,\r\nstruct fib_rules_ops *ops, struct nlmsghdr *nlh,\r\nu32 pid)\r\n{\r\nstruct net *net;\r\nstruct sk_buff *skb;\r\nint err = -ENOBUFS;\r\nnet = ops->fro_net;\r\nskb = nlmsg_new(fib_rule_nlmsg_size(ops, rule), GFP_KERNEL);\r\nif (skb == NULL)\r\ngoto errout;\r\nerr = fib_nl_fill_rule(skb, rule, pid, nlh->nlmsg_seq, event, 0, ops);\r\nif (err < 0) {\r\nWARN_ON(err == -EMSGSIZE);\r\nkfree_skb(skb);\r\ngoto errout;\r\n}\r\nrtnl_notify(skb, net, pid, ops->nlgroup, nlh, GFP_KERNEL);\r\nreturn;\r\nerrout:\r\nif (err < 0)\r\nrtnl_set_sk_err(net, ops->nlgroup, err);\r\n}\r\nstatic void attach_rules(struct list_head *rules, struct net_device *dev)\r\n{\r\nstruct fib_rule *rule;\r\nlist_for_each_entry(rule, rules, list) {\r\nif (rule->iifindex == -1 &&\r\nstrcmp(dev->name, rule->iifname) == 0)\r\nrule->iifindex = dev->ifindex;\r\nif (rule->oifindex == -1 &&\r\nstrcmp(dev->name, rule->oifname) == 0)\r\nrule->oifindex = dev->ifindex;\r\n}\r\n}\r\nstatic void detach_rules(struct list_head *rules, struct net_device *dev)\r\n{\r\nstruct fib_rule *rule;\r\nlist_for_each_entry(rule, rules, list) {\r\nif (rule->iifindex == dev->ifindex)\r\nrule->iifindex = -1;\r\nif (rule->oifindex == dev->ifindex)\r\nrule->oifindex = -1;\r\n}\r\n}\r\nstatic int fib_rules_event(struct notifier_block *this, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct net *net = dev_net(dev);\r\nstruct fib_rules_ops *ops;\r\nASSERT_RTNL();\r\nswitch (event) {\r\ncase NETDEV_REGISTER:\r\nlist_for_each_entry(ops, &net->rules_ops, list)\r\nattach_rules(&ops->rules_list, dev);\r\nbreak;\r\ncase NETDEV_CHANGENAME:\r\nlist_for_each_entry(ops, &net->rules_ops, list) {\r\ndetach_rules(&ops->rules_list, dev);\r\nattach_rules(&ops->rules_list, dev);\r\n}\r\nbreak;\r\ncase NETDEV_UNREGISTER:\r\nlist_for_each_entry(ops, &net->rules_ops, list)\r\ndetach_rules(&ops->rules_list, dev);\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __net_init fib_rules_net_init(struct net *net)\r\n{\r\nINIT_LIST_HEAD(&net->rules_ops);\r\nspin_lock_init(&net->rules_mod_lock);\r\nreturn 0;\r\n}\r\nstatic int __init fib_rules_init(void)\r\n{\r\nint err;\r\nrtnl_register(PF_UNSPEC, RTM_NEWRULE, fib_nl_newrule, NULL, NULL);\r\nrtnl_register(PF_UNSPEC, RTM_DELRULE, fib_nl_delrule, NULL, NULL);\r\nrtnl_register(PF_UNSPEC, RTM_GETRULE, NULL, fib_nl_dumprule, NULL);\r\nerr = register_pernet_subsys(&fib_rules_net_ops);\r\nif (err < 0)\r\ngoto fail;\r\nerr = register_netdevice_notifier(&fib_rules_notifier);\r\nif (err < 0)\r\ngoto fail_unregister;\r\nreturn 0;\r\nfail_unregister:\r\nunregister_pernet_subsys(&fib_rules_net_ops);\r\nfail:\r\nrtnl_unregister(PF_UNSPEC, RTM_NEWRULE);\r\nrtnl_unregister(PF_UNSPEC, RTM_DELRULE);\r\nrtnl_unregister(PF_UNSPEC, RTM_GETRULE);\r\nreturn err;\r\n}
