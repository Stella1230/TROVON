static unsigned long elf_hash(const unsigned char *name)\r\n{\r\nunsigned long h = 0, g;\r\nwhile (*name)\r\n{\r\nh = (h << 4) + *name++;\r\nif (g = h & 0xf0000000)\r\nh ^= g >> 24;\r\nh &= ~g;\r\n}\r\nreturn h;\r\n}\r\nvoid vdso_init_from_sysinfo_ehdr(uintptr_t base)\r\n{\r\nsize_t i;\r\nbool found_vaddr = false;\r\nvdso_info.valid = false;\r\nvdso_info.load_addr = base;\r\nELF(Ehdr) *hdr = (ELF(Ehdr)*)base;\r\nif (hdr->e_ident[EI_CLASS] !=\r\n(ELF_BITS == 32 ? ELFCLASS32 : ELFCLASS64)) {\r\nreturn;\r\n}\r\nELF(Phdr) *pt = (ELF(Phdr)*)(vdso_info.load_addr + hdr->e_phoff);\r\nELF(Dyn) *dyn = 0;\r\nfor (i = 0; i < hdr->e_phnum; i++)\r\n{\r\nif (pt[i].p_type == PT_LOAD && !found_vaddr) {\r\nfound_vaddr = true;\r\nvdso_info.load_offset = base\r\n+ (uintptr_t)pt[i].p_offset\r\n- (uintptr_t)pt[i].p_vaddr;\r\n} else if (pt[i].p_type == PT_DYNAMIC) {\r\ndyn = (ELF(Dyn)*)(base + pt[i].p_offset);\r\n}\r\n}\r\nif (!found_vaddr || !dyn)\r\nreturn;\r\nELF(Word) *hash = 0;\r\nvdso_info.symstrings = 0;\r\nvdso_info.symtab = 0;\r\nvdso_info.versym = 0;\r\nvdso_info.verdef = 0;\r\nfor (i = 0; dyn[i].d_tag != DT_NULL; i++) {\r\nswitch (dyn[i].d_tag) {\r\ncase DT_STRTAB:\r\nvdso_info.symstrings = (const char *)\r\n((uintptr_t)dyn[i].d_un.d_ptr\r\n+ vdso_info.load_offset);\r\nbreak;\r\ncase DT_SYMTAB:\r\nvdso_info.symtab = (ELF(Sym) *)\r\n((uintptr_t)dyn[i].d_un.d_ptr\r\n+ vdso_info.load_offset);\r\nbreak;\r\ncase DT_HASH:\r\nhash = (ELF(Word) *)\r\n((uintptr_t)dyn[i].d_un.d_ptr\r\n+ vdso_info.load_offset);\r\nbreak;\r\ncase DT_VERSYM:\r\nvdso_info.versym = (ELF(Versym) *)\r\n((uintptr_t)dyn[i].d_un.d_ptr\r\n+ vdso_info.load_offset);\r\nbreak;\r\ncase DT_VERDEF:\r\nvdso_info.verdef = (ELF(Verdef) *)\r\n((uintptr_t)dyn[i].d_un.d_ptr\r\n+ vdso_info.load_offset);\r\nbreak;\r\n}\r\n}\r\nif (!vdso_info.symstrings || !vdso_info.symtab || !hash)\r\nreturn;\r\nif (!vdso_info.verdef)\r\nvdso_info.versym = 0;\r\nvdso_info.nbucket = hash[0];\r\nvdso_info.nchain = hash[1];\r\nvdso_info.bucket = &hash[2];\r\nvdso_info.chain = &hash[vdso_info.nbucket + 2];\r\nvdso_info.valid = true;\r\n}\r\nvoid *vdso_sym(const char *version, const char *name)\r\n{\r\nunsigned long ver_hash;\r\nif (!vdso_info.valid)\r\nreturn 0;\r\nver_hash = elf_hash(version);\r\nELF(Word) chain = vdso_info.bucket[elf_hash(name) % vdso_info.nbucket];\r\nfor (; chain != STN_UNDEF; chain = vdso_info.chain[chain]) {\r\nELF(Sym) *sym = &vdso_info.symtab[chain];\r\nif (ELF64_ST_TYPE(sym->st_info) != STT_FUNC)\r\ncontinue;\r\nif (ELF64_ST_BIND(sym->st_info) != STB_GLOBAL &&\r\nELF64_ST_BIND(sym->st_info) != STB_WEAK)\r\ncontinue;\r\nif (sym->st_shndx == SHN_UNDEF)\r\ncontinue;\r\nif (strcmp(name, vdso_info.symstrings + sym->st_name))\r\ncontinue;\r\nif (vdso_info.versym\r\n&& !vdso_match_version(vdso_info.versym[chain],\r\nversion, ver_hash))\r\ncontinue;\r\nreturn (void *)(vdso_info.load_offset + sym->st_value);\r\n}\r\nreturn 0;\r\n}\r\nvoid vdso_init_from_auxv(void *auxv)\r\n{\r\nELF(auxv_t) *elf_auxv = auxv;\r\nfor (int i = 0; elf_auxv[i].a_type != AT_NULL; i++)\r\n{\r\nif (elf_auxv[i].a_type == AT_SYSINFO_EHDR) {\r\nvdso_init_from_sysinfo_ehdr(elf_auxv[i].a_un.a_val);\r\nreturn;\r\n}\r\n}\r\nvdso_info.valid = false;\r\n}
