int imx_drm_crtc_id(struct imx_drm_crtc *crtc)\r\n{\r\nreturn crtc->pipe;\r\n}\r\nstatic void imx_drm_driver_lastclose(struct drm_device *drm)\r\n{\r\n#if IS_ENABLED(CONFIG_DRM_IMX_FB_HELPER)\r\nstruct imx_drm_device *imxdrm = drm->dev_private;\r\nif (imxdrm->fbhelper)\r\ndrm_fbdev_cma_restore_mode(imxdrm->fbhelper);\r\n#endif\r\n}\r\nstatic int imx_drm_driver_unload(struct drm_device *drm)\r\n{\r\n#if IS_ENABLED(CONFIG_DRM_IMX_FB_HELPER)\r\nstruct imx_drm_device *imxdrm = drm->dev_private;\r\n#endif\r\ndrm_kms_helper_poll_fini(drm);\r\n#if IS_ENABLED(CONFIG_DRM_IMX_FB_HELPER)\r\nif (imxdrm->fbhelper)\r\ndrm_fbdev_cma_fini(imxdrm->fbhelper);\r\n#endif\r\ncomponent_unbind_all(drm->dev, drm);\r\ndrm_vblank_cleanup(drm);\r\ndrm_mode_config_cleanup(drm);\r\nplatform_set_drvdata(drm->platformdev, NULL);\r\nreturn 0;\r\n}\r\nstatic struct imx_drm_crtc *imx_drm_find_crtc(struct drm_crtc *crtc)\r\n{\r\nstruct imx_drm_device *imxdrm = crtc->dev->dev_private;\r\nunsigned i;\r\nfor (i = 0; i < MAX_CRTC; i++)\r\nif (imxdrm->crtc[i] && imxdrm->crtc[i]->crtc == crtc)\r\nreturn imxdrm->crtc[i];\r\nreturn NULL;\r\n}\r\nint imx_drm_set_bus_format_pins(struct drm_encoder *encoder, u32 bus_format,\r\nint hsync_pin, int vsync_pin)\r\n{\r\nstruct imx_drm_crtc_helper_funcs *helper;\r\nstruct imx_drm_crtc *imx_crtc;\r\nimx_crtc = imx_drm_find_crtc(encoder->crtc);\r\nif (!imx_crtc)\r\nreturn -EINVAL;\r\nhelper = &imx_crtc->imx_drm_helper_funcs;\r\nif (helper->set_interface_pix_fmt)\r\nreturn helper->set_interface_pix_fmt(encoder->crtc,\r\nbus_format, hsync_pin, vsync_pin);\r\nreturn 0;\r\n}\r\nint imx_drm_set_bus_format(struct drm_encoder *encoder, u32 bus_format)\r\n{\r\nreturn imx_drm_set_bus_format_pins(encoder, bus_format, 2, 3);\r\n}\r\nint imx_drm_crtc_vblank_get(struct imx_drm_crtc *imx_drm_crtc)\r\n{\r\nreturn drm_vblank_get(imx_drm_crtc->crtc->dev, imx_drm_crtc->pipe);\r\n}\r\nvoid imx_drm_crtc_vblank_put(struct imx_drm_crtc *imx_drm_crtc)\r\n{\r\ndrm_vblank_put(imx_drm_crtc->crtc->dev, imx_drm_crtc->pipe);\r\n}\r\nvoid imx_drm_handle_vblank(struct imx_drm_crtc *imx_drm_crtc)\r\n{\r\ndrm_handle_vblank(imx_drm_crtc->crtc->dev, imx_drm_crtc->pipe);\r\n}\r\nstatic int imx_drm_enable_vblank(struct drm_device *drm, int crtc)\r\n{\r\nstruct imx_drm_device *imxdrm = drm->dev_private;\r\nstruct imx_drm_crtc *imx_drm_crtc = imxdrm->crtc[crtc];\r\nint ret;\r\nif (!imx_drm_crtc)\r\nreturn -EINVAL;\r\nif (!imx_drm_crtc->imx_drm_helper_funcs.enable_vblank)\r\nreturn -ENOSYS;\r\nret = imx_drm_crtc->imx_drm_helper_funcs.enable_vblank(\r\nimx_drm_crtc->crtc);\r\nreturn ret;\r\n}\r\nstatic void imx_drm_disable_vblank(struct drm_device *drm, int crtc)\r\n{\r\nstruct imx_drm_device *imxdrm = drm->dev_private;\r\nstruct imx_drm_crtc *imx_drm_crtc = imxdrm->crtc[crtc];\r\nif (!imx_drm_crtc)\r\nreturn;\r\nif (!imx_drm_crtc->imx_drm_helper_funcs.disable_vblank)\r\nreturn;\r\nimx_drm_crtc->imx_drm_helper_funcs.disable_vblank(imx_drm_crtc->crtc);\r\n}\r\nstatic void imx_drm_driver_preclose(struct drm_device *drm,\r\nstruct drm_file *file)\r\n{\r\nint i;\r\nif (!file->is_master)\r\nreturn;\r\nfor (i = 0; i < MAX_CRTC; i++)\r\nimx_drm_disable_vblank(drm, i);\r\n}\r\nvoid imx_drm_connector_destroy(struct drm_connector *connector)\r\n{\r\ndrm_connector_unregister(connector);\r\ndrm_connector_cleanup(connector);\r\n}\r\nvoid imx_drm_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\ndrm_encoder_cleanup(encoder);\r\n}\r\nstatic void imx_drm_output_poll_changed(struct drm_device *drm)\r\n{\r\n#if IS_ENABLED(CONFIG_DRM_IMX_FB_HELPER)\r\nstruct imx_drm_device *imxdrm = drm->dev_private;\r\ndrm_fbdev_cma_hotplug_event(imxdrm->fbhelper);\r\n#endif\r\n}\r\nstatic int imx_drm_driver_load(struct drm_device *drm, unsigned long flags)\r\n{\r\nstruct imx_drm_device *imxdrm;\r\nstruct drm_connector *connector;\r\nint ret;\r\nimxdrm = devm_kzalloc(drm->dev, sizeof(*imxdrm), GFP_KERNEL);\r\nif (!imxdrm)\r\nreturn -ENOMEM;\r\nimxdrm->drm = drm;\r\ndrm->dev_private = imxdrm;\r\ndrm->irq_enabled = true;\r\ndrm->mode_config.min_width = 64;\r\ndrm->mode_config.min_height = 64;\r\ndrm->mode_config.max_width = 4096;\r\ndrm->mode_config.max_height = 4096;\r\ndrm->mode_config.funcs = &imx_drm_mode_config_funcs;\r\ndrm_mode_config_init(drm);\r\nret = drm_vblank_init(drm, MAX_CRTC);\r\nif (ret)\r\ngoto err_kms;\r\ndrm->vblank_disable_allowed = true;\r\nplatform_set_drvdata(drm->platformdev, drm);\r\nret = component_bind_all(drm->dev, drm);\r\nif (ret)\r\ngoto err_vblank;\r\nlist_for_each_entry(connector, &drm->mode_config.connector_list, head) {\r\nret = drm_connector_register(connector);\r\nif (ret) {\r\ndev_err(drm->dev,\r\n"[CONNECTOR:%d:%s] drm_connector_register failed: %d\n",\r\nconnector->base.id,\r\nconnector->name, ret);\r\ngoto err_unbind;\r\n}\r\n}\r\n#if IS_ENABLED(CONFIG_DRM_IMX_FB_HELPER)\r\nif (legacyfb_depth != 16 && legacyfb_depth != 32) {\r\ndev_warn(drm->dev, "Invalid legacyfb_depth. Defaulting to 16bpp\n");\r\nlegacyfb_depth = 16;\r\n}\r\nimxdrm->fbhelper = drm_fbdev_cma_init(drm, legacyfb_depth,\r\ndrm->mode_config.num_crtc, MAX_CRTC);\r\nif (IS_ERR(imxdrm->fbhelper)) {\r\nret = PTR_ERR(imxdrm->fbhelper);\r\nimxdrm->fbhelper = NULL;\r\ngoto err_unbind;\r\n}\r\n#endif\r\ndrm_kms_helper_poll_init(drm);\r\nreturn 0;\r\nerr_unbind:\r\ncomponent_unbind_all(drm->dev, drm);\r\nerr_vblank:\r\ndrm_vblank_cleanup(drm);\r\nerr_kms:\r\ndrm_mode_config_cleanup(drm);\r\nreturn ret;\r\n}\r\nint imx_drm_add_crtc(struct drm_device *drm, struct drm_crtc *crtc,\r\nstruct imx_drm_crtc **new_crtc,\r\nconst struct imx_drm_crtc_helper_funcs *imx_drm_helper_funcs,\r\nstruct device_node *port)\r\n{\r\nstruct imx_drm_device *imxdrm = drm->dev_private;\r\nstruct imx_drm_crtc *imx_drm_crtc;\r\nint ret;\r\nif (imxdrm->pipes >= MAX_CRTC)\r\nreturn -EINVAL;\r\nif (imxdrm->drm->open_count)\r\nreturn -EBUSY;\r\nimx_drm_crtc = kzalloc(sizeof(*imx_drm_crtc), GFP_KERNEL);\r\nif (!imx_drm_crtc)\r\nreturn -ENOMEM;\r\nimx_drm_crtc->imx_drm_helper_funcs = *imx_drm_helper_funcs;\r\nimx_drm_crtc->pipe = imxdrm->pipes++;\r\nimx_drm_crtc->crtc = crtc;\r\ncrtc->port = port;\r\nimxdrm->crtc[imx_drm_crtc->pipe] = imx_drm_crtc;\r\n*new_crtc = imx_drm_crtc;\r\nret = drm_mode_crtc_set_gamma_size(imx_drm_crtc->crtc, 256);\r\nif (ret)\r\ngoto err_register;\r\ndrm_crtc_helper_add(crtc,\r\nimx_drm_crtc->imx_drm_helper_funcs.crtc_helper_funcs);\r\ndrm_crtc_init(drm, crtc,\r\nimx_drm_crtc->imx_drm_helper_funcs.crtc_funcs);\r\nreturn 0;\r\nerr_register:\r\nimxdrm->crtc[imx_drm_crtc->pipe] = NULL;\r\nkfree(imx_drm_crtc);\r\nreturn ret;\r\n}\r\nint imx_drm_remove_crtc(struct imx_drm_crtc *imx_drm_crtc)\r\n{\r\nstruct imx_drm_device *imxdrm = imx_drm_crtc->crtc->dev->dev_private;\r\ndrm_crtc_cleanup(imx_drm_crtc->crtc);\r\nimxdrm->crtc[imx_drm_crtc->pipe] = NULL;\r\nkfree(imx_drm_crtc);\r\nreturn 0;\r\n}\r\nint imx_drm_encoder_parse_of(struct drm_device *drm,\r\nstruct drm_encoder *encoder, struct device_node *np)\r\n{\r\nuint32_t crtc_mask = drm_of_find_possible_crtcs(drm, np);\r\nif (crtc_mask == 0)\r\nreturn -EPROBE_DEFER;\r\nencoder->possible_crtcs = crtc_mask;\r\nencoder->possible_clones = ~0;\r\nreturn 0;\r\n}\r\nint imx_drm_encoder_get_mux_id(struct device_node *node,\r\nstruct drm_encoder *encoder)\r\n{\r\nstruct imx_drm_crtc *imx_crtc = imx_drm_find_crtc(encoder->crtc);\r\nstruct device_node *ep;\r\nstruct of_endpoint endpoint;\r\nstruct device_node *port;\r\nint ret;\r\nif (!node || !imx_crtc)\r\nreturn -EINVAL;\r\nfor_each_endpoint_of_node(node, ep) {\r\nport = of_graph_get_remote_port(ep);\r\nof_node_put(port);\r\nif (port == imx_crtc->crtc->port) {\r\nret = of_graph_parse_endpoint(ep, &endpoint);\r\nof_node_put(ep);\r\nreturn ret ? ret : endpoint.port;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int compare_of(struct device *dev, void *data)\r\n{\r\nstruct device_node *np = data;\r\nif (of_node_cmp(np->name, "lvds-channel") == 0) {\r\nnp = of_get_parent(np);\r\nof_node_put(np);\r\n}\r\nreturn dev->of_node == np;\r\n}\r\nstatic int imx_drm_bind(struct device *dev)\r\n{\r\nreturn drm_platform_init(&imx_drm_driver, to_platform_device(dev));\r\n}\r\nstatic void imx_drm_unbind(struct device *dev)\r\n{\r\ndrm_put_dev(dev_get_drvdata(dev));\r\n}\r\nstatic int imx_drm_platform_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *ep, *port, *remote;\r\nstruct component_match *match = NULL;\r\nint ret;\r\nint i;\r\nfor (i = 0; ; i++) {\r\nport = of_parse_phandle(pdev->dev.of_node, "ports", i);\r\nif (!port)\r\nbreak;\r\ncomponent_match_add(&pdev->dev, &match, compare_of, port);\r\n}\r\nif (i == 0) {\r\ndev_err(&pdev->dev, "missing 'ports' property\n");\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; ; i++) {\r\nport = of_parse_phandle(pdev->dev.of_node, "ports", i);\r\nif (!port)\r\nbreak;\r\nfor_each_child_of_node(port, ep) {\r\nremote = of_graph_get_remote_port_parent(ep);\r\nif (!remote || !of_device_is_available(remote)) {\r\nof_node_put(remote);\r\ncontinue;\r\n} else if (!of_device_is_available(remote->parent)) {\r\ndev_warn(&pdev->dev, "parent device of %s is not available\n",\r\nremote->full_name);\r\nof_node_put(remote);\r\ncontinue;\r\n}\r\ncomponent_match_add(&pdev->dev, &match, compare_of,\r\nremote);\r\nof_node_put(remote);\r\n}\r\nof_node_put(port);\r\n}\r\nret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));\r\nif (ret)\r\nreturn ret;\r\nreturn component_master_add_with_match(&pdev->dev, &imx_drm_ops, match);\r\n}\r\nstatic int imx_drm_platform_remove(struct platform_device *pdev)\r\n{\r\ncomponent_master_del(&pdev->dev, &imx_drm_ops);\r\nreturn 0;\r\n}\r\nstatic int imx_drm_suspend(struct device *dev)\r\n{\r\nstruct drm_device *drm_dev = dev_get_drvdata(dev);\r\nif (drm_dev == NULL)\r\nreturn 0;\r\ndrm_kms_helper_poll_disable(drm_dev);\r\nreturn 0;\r\n}\r\nstatic int imx_drm_resume(struct device *dev)\r\n{\r\nstruct drm_device *drm_dev = dev_get_drvdata(dev);\r\nif (drm_dev == NULL)\r\nreturn 0;\r\ndrm_helper_resume_force_mode(drm_dev);\r\ndrm_kms_helper_poll_enable(drm_dev);\r\nreturn 0;\r\n}
