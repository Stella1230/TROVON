static inline int msm_dll_poll_ck_out_en(struct sdhci_host *host, u8 poll)\r\n{\r\nu32 wait_cnt = 50;\r\nu8 ck_out_en;\r\nstruct mmc_host *mmc = host->mmc;\r\nck_out_en = !!(readl_relaxed(host->ioaddr + CORE_DLL_CONFIG) &\r\nCORE_CK_OUT_EN);\r\nwhile (ck_out_en != poll) {\r\nif (--wait_cnt == 0) {\r\ndev_err(mmc_dev(mmc), "%s: CK_OUT_EN bit is not %d\n",\r\nmmc_hostname(mmc), poll);\r\nreturn -ETIMEDOUT;\r\n}\r\nudelay(1);\r\nck_out_en = !!(readl_relaxed(host->ioaddr + CORE_DLL_CONFIG) &\r\nCORE_CK_OUT_EN);\r\n}\r\nreturn 0;\r\n}\r\nstatic int msm_config_cm_dll_phase(struct sdhci_host *host, u8 phase)\r\n{\r\nint rc;\r\nstatic const u8 grey_coded_phase_table[] = {\r\n0x0, 0x1, 0x3, 0x2, 0x6, 0x7, 0x5, 0x4,\r\n0xc, 0xd, 0xf, 0xe, 0xa, 0xb, 0x9, 0x8\r\n};\r\nunsigned long flags;\r\nu32 config;\r\nstruct mmc_host *mmc = host->mmc;\r\nspin_lock_irqsave(&host->lock, flags);\r\nconfig = readl_relaxed(host->ioaddr + CORE_DLL_CONFIG);\r\nconfig &= ~(CORE_CDR_EN | CORE_CK_OUT_EN);\r\nconfig |= (CORE_CDR_EXT_EN | CORE_DLL_EN);\r\nwritel_relaxed(config, host->ioaddr + CORE_DLL_CONFIG);\r\nrc = msm_dll_poll_ck_out_en(host, 0);\r\nif (rc)\r\ngoto err_out;\r\nconfig = readl_relaxed(host->ioaddr + CORE_DLL_CONFIG);\r\nconfig &= ~CDR_SELEXT_MASK;\r\nconfig |= grey_coded_phase_table[phase] << CDR_SELEXT_SHIFT;\r\nwritel_relaxed(config, host->ioaddr + CORE_DLL_CONFIG);\r\nwritel_relaxed((readl_relaxed(host->ioaddr + CORE_DLL_CONFIG)\r\n| CORE_CK_OUT_EN), host->ioaddr + CORE_DLL_CONFIG);\r\nrc = msm_dll_poll_ck_out_en(host, 1);\r\nif (rc)\r\ngoto err_out;\r\nconfig = readl_relaxed(host->ioaddr + CORE_DLL_CONFIG);\r\nconfig |= CORE_CDR_EN;\r\nconfig &= ~CORE_CDR_EXT_EN;\r\nwritel_relaxed(config, host->ioaddr + CORE_DLL_CONFIG);\r\ngoto out;\r\nerr_out:\r\ndev_err(mmc_dev(mmc), "%s: Failed to set DLL phase: %d\n",\r\nmmc_hostname(mmc), phase);\r\nout:\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nreturn rc;\r\n}\r\nstatic int msm_find_most_appropriate_phase(struct sdhci_host *host,\r\nu8 *phase_table, u8 total_phases)\r\n{\r\nint ret;\r\nu8 ranges[MAX_PHASES][MAX_PHASES] = { {0}, {0} };\r\nu8 phases_per_row[MAX_PHASES] = { 0 };\r\nint row_index = 0, col_index = 0, selected_row_index = 0, curr_max = 0;\r\nint i, cnt, phase_0_raw_index = 0, phase_15_raw_index = 0;\r\nbool phase_0_found = false, phase_15_found = false;\r\nstruct mmc_host *mmc = host->mmc;\r\nif (!total_phases || (total_phases > MAX_PHASES)) {\r\ndev_err(mmc_dev(mmc), "%s: Invalid argument: total_phases=%d\n",\r\nmmc_hostname(mmc), total_phases);\r\nreturn -EINVAL;\r\n}\r\nfor (cnt = 0; cnt < total_phases; cnt++) {\r\nranges[row_index][col_index] = phase_table[cnt];\r\nphases_per_row[row_index] += 1;\r\ncol_index++;\r\nif ((cnt + 1) == total_phases) {\r\ncontinue;\r\n} else if ((phase_table[cnt] + 1) != phase_table[cnt + 1]) {\r\nrow_index++;\r\ncol_index = 0;\r\n}\r\n}\r\nif (row_index >= MAX_PHASES)\r\nreturn -EINVAL;\r\nif (!ranges[0][0]) {\r\nphase_0_found = true;\r\nphase_0_raw_index = 0;\r\nfor (cnt = 1; cnt <= row_index; cnt++) {\r\nif (phases_per_row[cnt]) {\r\nfor (i = 0; i < phases_per_row[cnt]; i++) {\r\nif (ranges[cnt][i] == 15) {\r\nphase_15_found = true;\r\nphase_15_raw_index = cnt;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nif (phase_0_found && phase_15_found) {\r\nu8 phases_0 = phases_per_row[phase_0_raw_index];\r\nu8 phases_15 = phases_per_row[phase_15_raw_index];\r\nif (phases_0 + phases_15 >= MAX_PHASES)\r\nreturn -EINVAL;\r\ni = phases_15;\r\nfor (cnt = 0; cnt < phases_0; cnt++) {\r\nranges[phase_15_raw_index][i] =\r\nranges[phase_0_raw_index][cnt];\r\nif (++i >= MAX_PHASES)\r\nbreak;\r\n}\r\nphases_per_row[phase_0_raw_index] = 0;\r\nphases_per_row[phase_15_raw_index] = phases_15 + phases_0;\r\n}\r\nfor (cnt = 0; cnt <= row_index; cnt++) {\r\nif (phases_per_row[cnt] > curr_max) {\r\ncurr_max = phases_per_row[cnt];\r\nselected_row_index = cnt;\r\n}\r\n}\r\ni = (curr_max * 3) / 4;\r\nif (i)\r\ni--;\r\nret = ranges[selected_row_index][i];\r\nif (ret >= MAX_PHASES) {\r\nret = -EINVAL;\r\ndev_err(mmc_dev(mmc), "%s: Invalid phase selected=%d\n",\r\nmmc_hostname(mmc), ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic inline void msm_cm_dll_set_freq(struct sdhci_host *host)\r\n{\r\nu32 mclk_freq = 0, config;\r\nif (host->clock <= 112000000)\r\nmclk_freq = 0;\r\nelse if (host->clock <= 125000000)\r\nmclk_freq = 1;\r\nelse if (host->clock <= 137000000)\r\nmclk_freq = 2;\r\nelse if (host->clock <= 150000000)\r\nmclk_freq = 3;\r\nelse if (host->clock <= 162000000)\r\nmclk_freq = 4;\r\nelse if (host->clock <= 175000000)\r\nmclk_freq = 5;\r\nelse if (host->clock <= 187000000)\r\nmclk_freq = 6;\r\nelse if (host->clock <= 200000000)\r\nmclk_freq = 7;\r\nconfig = readl_relaxed(host->ioaddr + CORE_DLL_CONFIG);\r\nconfig &= ~CMUX_SHIFT_PHASE_MASK;\r\nconfig |= mclk_freq << CMUX_SHIFT_PHASE_SHIFT;\r\nwritel_relaxed(config, host->ioaddr + CORE_DLL_CONFIG);\r\n}\r\nstatic int msm_init_cm_dll(struct sdhci_host *host)\r\n{\r\nstruct mmc_host *mmc = host->mmc;\r\nint wait_cnt = 50;\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->lock, flags);\r\nwritel_relaxed((readl_relaxed(host->ioaddr + CORE_VENDOR_SPEC)\r\n& ~CORE_CLK_PWRSAVE), host->ioaddr + CORE_VENDOR_SPEC);\r\nwritel_relaxed((readl_relaxed(host->ioaddr + CORE_DLL_CONFIG)\r\n| CORE_DLL_RST), host->ioaddr + CORE_DLL_CONFIG);\r\nwritel_relaxed((readl_relaxed(host->ioaddr + CORE_DLL_CONFIG)\r\n| CORE_DLL_PDN), host->ioaddr + CORE_DLL_CONFIG);\r\nmsm_cm_dll_set_freq(host);\r\nwritel_relaxed((readl_relaxed(host->ioaddr + CORE_DLL_CONFIG)\r\n& ~CORE_DLL_RST), host->ioaddr + CORE_DLL_CONFIG);\r\nwritel_relaxed((readl_relaxed(host->ioaddr + CORE_DLL_CONFIG)\r\n& ~CORE_DLL_PDN), host->ioaddr + CORE_DLL_CONFIG);\r\nwritel_relaxed((readl_relaxed(host->ioaddr + CORE_DLL_CONFIG)\r\n| CORE_DLL_EN), host->ioaddr + CORE_DLL_CONFIG);\r\nwritel_relaxed((readl_relaxed(host->ioaddr + CORE_DLL_CONFIG)\r\n| CORE_CK_OUT_EN), host->ioaddr + CORE_DLL_CONFIG);\r\nwhile (!(readl_relaxed(host->ioaddr + CORE_DLL_STATUS) &\r\nCORE_DLL_LOCK)) {\r\nif (--wait_cnt == 0) {\r\ndev_err(mmc_dev(mmc), "%s: DLL failed to LOCK\n",\r\nmmc_hostname(mmc));\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nreturn -ETIMEDOUT;\r\n}\r\nudelay(1);\r\n}\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int sdhci_msm_execute_tuning(struct sdhci_host *host, u32 opcode)\r\n{\r\nint tuning_seq_cnt = 3;\r\nu8 phase, tuned_phases[16], tuned_phase_cnt = 0;\r\nint rc;\r\nstruct mmc_host *mmc = host->mmc;\r\nstruct mmc_ios ios = host->mmc->ios;\r\nif (host->clock <= 100 * 1000 * 1000 ||\r\n!((ios.timing == MMC_TIMING_MMC_HS200) ||\r\n(ios.timing == MMC_TIMING_UHS_SDR104)))\r\nreturn 0;\r\nretry:\r\nrc = msm_init_cm_dll(host);\r\nif (rc)\r\nreturn rc;\r\nphase = 0;\r\ndo {\r\nrc = msm_config_cm_dll_phase(host, phase);\r\nif (rc)\r\nreturn rc;\r\nrc = mmc_send_tuning(mmc);\r\nif (!rc) {\r\ntuned_phases[tuned_phase_cnt++] = phase;\r\ndev_dbg(mmc_dev(mmc), "%s: Found good phase = %d\n",\r\nmmc_hostname(mmc), phase);\r\n}\r\n} while (++phase < ARRAY_SIZE(tuned_phases));\r\nif (tuned_phase_cnt) {\r\nrc = msm_find_most_appropriate_phase(host, tuned_phases,\r\ntuned_phase_cnt);\r\nif (rc < 0)\r\nreturn rc;\r\nelse\r\nphase = rc;\r\nrc = msm_config_cm_dll_phase(host, phase);\r\nif (rc)\r\nreturn rc;\r\ndev_dbg(mmc_dev(mmc), "%s: Setting the tuning phase to %d\n",\r\nmmc_hostname(mmc), phase);\r\n} else {\r\nif (--tuning_seq_cnt)\r\ngoto retry;\r\ndev_dbg(mmc_dev(mmc), "%s: No tuning point found\n",\r\nmmc_hostname(mmc));\r\nrc = -EIO;\r\n}\r\nreturn rc;\r\n}\r\nstatic int sdhci_msm_probe(struct platform_device *pdev)\r\n{\r\nstruct sdhci_host *host;\r\nstruct sdhci_pltfm_host *pltfm_host;\r\nstruct sdhci_msm_host *msm_host;\r\nstruct resource *core_memres;\r\nint ret;\r\nu16 host_version, core_minor;\r\nu32 core_version, caps;\r\nu8 core_major;\r\nmsm_host = devm_kzalloc(&pdev->dev, sizeof(*msm_host), GFP_KERNEL);\r\nif (!msm_host)\r\nreturn -ENOMEM;\r\nmsm_host->sdhci_msm_pdata.ops = &sdhci_msm_ops;\r\nhost = sdhci_pltfm_init(pdev, &msm_host->sdhci_msm_pdata, 0);\r\nif (IS_ERR(host))\r\nreturn PTR_ERR(host);\r\npltfm_host = sdhci_priv(host);\r\npltfm_host->priv = msm_host;\r\nmsm_host->mmc = host->mmc;\r\nmsm_host->pdev = pdev;\r\nret = mmc_of_parse(host->mmc);\r\nif (ret)\r\ngoto pltfm_free;\r\nsdhci_get_of_property(pdev);\r\nmsm_host->bus_clk = devm_clk_get(&pdev->dev, "bus");\r\nif (!IS_ERR(msm_host->bus_clk)) {\r\nret = clk_set_rate(msm_host->bus_clk, INT_MAX);\r\nif (ret)\r\ngoto pltfm_free;\r\nret = clk_prepare_enable(msm_host->bus_clk);\r\nif (ret)\r\ngoto pltfm_free;\r\n}\r\nmsm_host->pclk = devm_clk_get(&pdev->dev, "iface");\r\nif (IS_ERR(msm_host->pclk)) {\r\nret = PTR_ERR(msm_host->pclk);\r\ndev_err(&pdev->dev, "Perpheral clk setup failed (%d)\n", ret);\r\ngoto bus_clk_disable;\r\n}\r\nret = clk_prepare_enable(msm_host->pclk);\r\nif (ret)\r\ngoto bus_clk_disable;\r\nmsm_host->clk = devm_clk_get(&pdev->dev, "core");\r\nif (IS_ERR(msm_host->clk)) {\r\nret = PTR_ERR(msm_host->clk);\r\ndev_err(&pdev->dev, "SDC MMC clk setup failed (%d)\n", ret);\r\ngoto pclk_disable;\r\n}\r\nret = clk_prepare_enable(msm_host->clk);\r\nif (ret)\r\ngoto pclk_disable;\r\ncore_memres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nmsm_host->core_mem = devm_ioremap_resource(&pdev->dev, core_memres);\r\nif (IS_ERR(msm_host->core_mem)) {\r\ndev_err(&pdev->dev, "Failed to remap registers\n");\r\nret = PTR_ERR(msm_host->core_mem);\r\ngoto clk_disable;\r\n}\r\nwritel_relaxed(readl_relaxed(msm_host->core_mem + CORE_POWER) |\r\nCORE_SW_RST, msm_host->core_mem + CORE_POWER);\r\nusleep_range(1000, 5000);\r\nif (readl(msm_host->core_mem + CORE_POWER) & CORE_SW_RST) {\r\ndev_err(&pdev->dev, "Stuck in reset\n");\r\nret = -ETIMEDOUT;\r\ngoto clk_disable;\r\n}\r\nwritel_relaxed(HC_MODE_EN, (msm_host->core_mem + CORE_HC_MODE));\r\nhost->quirks |= SDHCI_QUIRK_BROKEN_CARD_DETECTION;\r\nhost->quirks |= SDHCI_QUIRK_SINGLE_POWER_WRITE;\r\nhost_version = readw_relaxed((host->ioaddr + SDHCI_HOST_VERSION));\r\ndev_dbg(&pdev->dev, "Host Version: 0x%x Vendor Version 0x%x\n",\r\nhost_version, ((host_version & SDHCI_VENDOR_VER_MASK) >>\r\nSDHCI_VENDOR_VER_SHIFT));\r\ncore_version = readl_relaxed(msm_host->core_mem + CORE_MCI_VERSION);\r\ncore_major = (core_version & CORE_VERSION_MAJOR_MASK) >>\r\nCORE_VERSION_MAJOR_SHIFT;\r\ncore_minor = core_version & CORE_VERSION_MINOR_MASK;\r\ndev_dbg(&pdev->dev, "MCI Version: 0x%08x, major: 0x%04x, minor: 0x%02x\n",\r\ncore_version, core_major, core_minor);\r\nif (core_major >= 1 && core_minor != 0x11 && core_minor != 0x12) {\r\ncaps = readl_relaxed(host->ioaddr + SDHCI_CAPABILITIES);\r\ncaps |= SDHCI_CAN_VDD_300 | SDHCI_CAN_DO_8BIT;\r\nwritel_relaxed(caps, host->ioaddr +\r\nCORE_VENDOR_SPEC_CAPABILITIES0);\r\n}\r\nret = sdhci_add_host(host);\r\nif (ret)\r\ngoto clk_disable;\r\nreturn 0;\r\nclk_disable:\r\nclk_disable_unprepare(msm_host->clk);\r\npclk_disable:\r\nclk_disable_unprepare(msm_host->pclk);\r\nbus_clk_disable:\r\nif (!IS_ERR(msm_host->bus_clk))\r\nclk_disable_unprepare(msm_host->bus_clk);\r\npltfm_free:\r\nsdhci_pltfm_free(pdev);\r\nreturn ret;\r\n}\r\nstatic int sdhci_msm_remove(struct platform_device *pdev)\r\n{\r\nstruct sdhci_host *host = platform_get_drvdata(pdev);\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct sdhci_msm_host *msm_host = pltfm_host->priv;\r\nint dead = (readl_relaxed(host->ioaddr + SDHCI_INT_STATUS) ==\r\n0xffffffff);\r\nsdhci_remove_host(host, dead);\r\nsdhci_pltfm_free(pdev);\r\nclk_disable_unprepare(msm_host->clk);\r\nclk_disable_unprepare(msm_host->pclk);\r\nif (!IS_ERR(msm_host->bus_clk))\r\nclk_disable_unprepare(msm_host->bus_clk);\r\nreturn 0;\r\n}
