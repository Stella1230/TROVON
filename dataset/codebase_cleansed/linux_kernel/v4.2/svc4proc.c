static __be32\r\nnlm4svc_retrieve_args(struct svc_rqst *rqstp, struct nlm_args *argp,\r\nstruct nlm_host **hostp, struct nlm_file **filp)\r\n{\r\nstruct nlm_host *host = NULL;\r\nstruct nlm_file *file = NULL;\r\nstruct nlm_lock *lock = &argp->lock;\r\n__be32 error = 0;\r\nif (!nlmsvc_ops)\r\nreturn nlm_lck_denied_nolocks;\r\nif (!(host = nlmsvc_lookup_host(rqstp, lock->caller, lock->len))\r\n|| (argp->monitor && nsm_monitor(host) < 0))\r\ngoto no_locks;\r\n*hostp = host;\r\nif (filp != NULL) {\r\nif ((error = nlm_lookup_file(rqstp, &file, &lock->fh)) != 0)\r\ngoto no_locks;\r\n*filp = file;\r\nlock->fl.fl_file = file->f_file;\r\nlock->fl.fl_owner = (fl_owner_t) host;\r\nlock->fl.fl_lmops = &nlmsvc_lock_operations;\r\n}\r\nreturn 0;\r\nno_locks:\r\nnlmsvc_release_host(host);\r\nif (error)\r\nreturn error;\r\nreturn nlm_lck_denied_nolocks;\r\n}\r\nstatic __be32\r\nnlm4svc_proc_null(struct svc_rqst *rqstp, void *argp, void *resp)\r\n{\r\ndprintk("lockd: NULL called\n");\r\nreturn rpc_success;\r\n}\r\nstatic __be32\r\nnlm4svc_proc_test(struct svc_rqst *rqstp, struct nlm_args *argp,\r\nstruct nlm_res *resp)\r\n{\r\nstruct nlm_host *host;\r\nstruct nlm_file *file;\r\n__be32 rc = rpc_success;\r\ndprintk("lockd: TEST4 called\n");\r\nresp->cookie = argp->cookie;\r\nif ((resp->status = nlm4svc_retrieve_args(rqstp, argp, &host, &file)))\r\nreturn resp->status == nlm_drop_reply ? rpc_drop_reply :rpc_success;\r\nresp->status = nlmsvc_testlock(rqstp, file, host, &argp->lock, &resp->lock, &resp->cookie);\r\nif (resp->status == nlm_drop_reply)\r\nrc = rpc_drop_reply;\r\nelse\r\ndprintk("lockd: TEST4 status %d\n", ntohl(resp->status));\r\nnlmsvc_release_host(host);\r\nnlm_release_file(file);\r\nreturn rc;\r\n}\r\nstatic __be32\r\nnlm4svc_proc_lock(struct svc_rqst *rqstp, struct nlm_args *argp,\r\nstruct nlm_res *resp)\r\n{\r\nstruct nlm_host *host;\r\nstruct nlm_file *file;\r\n__be32 rc = rpc_success;\r\ndprintk("lockd: LOCK called\n");\r\nresp->cookie = argp->cookie;\r\nif ((resp->status = nlm4svc_retrieve_args(rqstp, argp, &host, &file)))\r\nreturn resp->status == nlm_drop_reply ? rpc_drop_reply :rpc_success;\r\n#if 0\r\nif (host->h_nsmstate && host->h_nsmstate != argp->state) {\r\nresp->status = nlm_lck_denied_nolocks;\r\n} else\r\n#endif\r\nresp->status = nlmsvc_lock(rqstp, file, host, &argp->lock,\r\nargp->block, &argp->cookie,\r\nargp->reclaim);\r\nif (resp->status == nlm_drop_reply)\r\nrc = rpc_drop_reply;\r\nelse\r\ndprintk("lockd: LOCK status %d\n", ntohl(resp->status));\r\nnlmsvc_release_host(host);\r\nnlm_release_file(file);\r\nreturn rc;\r\n}\r\nstatic __be32\r\nnlm4svc_proc_cancel(struct svc_rqst *rqstp, struct nlm_args *argp,\r\nstruct nlm_res *resp)\r\n{\r\nstruct nlm_host *host;\r\nstruct nlm_file *file;\r\ndprintk("lockd: CANCEL called\n");\r\nresp->cookie = argp->cookie;\r\nif (locks_in_grace(SVC_NET(rqstp))) {\r\nresp->status = nlm_lck_denied_grace_period;\r\nreturn rpc_success;\r\n}\r\nif ((resp->status = nlm4svc_retrieve_args(rqstp, argp, &host, &file)))\r\nreturn resp->status == nlm_drop_reply ? rpc_drop_reply :rpc_success;\r\nresp->status = nlmsvc_cancel_blocked(SVC_NET(rqstp), file, &argp->lock);\r\ndprintk("lockd: CANCEL status %d\n", ntohl(resp->status));\r\nnlmsvc_release_host(host);\r\nnlm_release_file(file);\r\nreturn rpc_success;\r\n}\r\nstatic __be32\r\nnlm4svc_proc_unlock(struct svc_rqst *rqstp, struct nlm_args *argp,\r\nstruct nlm_res *resp)\r\n{\r\nstruct nlm_host *host;\r\nstruct nlm_file *file;\r\ndprintk("lockd: UNLOCK called\n");\r\nresp->cookie = argp->cookie;\r\nif (locks_in_grace(SVC_NET(rqstp))) {\r\nresp->status = nlm_lck_denied_grace_period;\r\nreturn rpc_success;\r\n}\r\nif ((resp->status = nlm4svc_retrieve_args(rqstp, argp, &host, &file)))\r\nreturn resp->status == nlm_drop_reply ? rpc_drop_reply :rpc_success;\r\nresp->status = nlmsvc_unlock(SVC_NET(rqstp), file, &argp->lock);\r\ndprintk("lockd: UNLOCK status %d\n", ntohl(resp->status));\r\nnlmsvc_release_host(host);\r\nnlm_release_file(file);\r\nreturn rpc_success;\r\n}\r\nstatic __be32\r\nnlm4svc_proc_granted(struct svc_rqst *rqstp, struct nlm_args *argp,\r\nstruct nlm_res *resp)\r\n{\r\nresp->cookie = argp->cookie;\r\ndprintk("lockd: GRANTED called\n");\r\nresp->status = nlmclnt_grant(svc_addr(rqstp), &argp->lock);\r\ndprintk("lockd: GRANTED status %d\n", ntohl(resp->status));\r\nreturn rpc_success;\r\n}\r\nstatic void nlm4svc_callback_exit(struct rpc_task *task, void *data)\r\n{\r\ndprintk("lockd: %5u callback returned %d\n", task->tk_pid,\r\n-task->tk_status);\r\n}\r\nstatic void nlm4svc_callback_release(void *data)\r\n{\r\nnlmsvc_release_call(data);\r\n}\r\nstatic __be32 nlm4svc_callback(struct svc_rqst *rqstp, u32 proc, struct nlm_args *argp,\r\n__be32 (*func)(struct svc_rqst *, struct nlm_args *, struct nlm_res *))\r\n{\r\nstruct nlm_host *host;\r\nstruct nlm_rqst *call;\r\n__be32 stat;\r\nhost = nlmsvc_lookup_host(rqstp,\r\nargp->lock.caller,\r\nargp->lock.len);\r\nif (host == NULL)\r\nreturn rpc_system_err;\r\ncall = nlm_alloc_call(host);\r\nnlmsvc_release_host(host);\r\nif (call == NULL)\r\nreturn rpc_system_err;\r\nstat = func(rqstp, argp, &call->a_res);\r\nif (stat != 0) {\r\nnlmsvc_release_call(call);\r\nreturn stat;\r\n}\r\ncall->a_flags = RPC_TASK_ASYNC;\r\nif (nlm_async_reply(call, proc, &nlm4svc_callback_ops) < 0)\r\nreturn rpc_system_err;\r\nreturn rpc_success;\r\n}\r\nstatic __be32 nlm4svc_proc_test_msg(struct svc_rqst *rqstp, struct nlm_args *argp,\r\nvoid *resp)\r\n{\r\ndprintk("lockd: TEST_MSG called\n");\r\nreturn nlm4svc_callback(rqstp, NLMPROC_TEST_RES, argp, nlm4svc_proc_test);\r\n}\r\nstatic __be32 nlm4svc_proc_lock_msg(struct svc_rqst *rqstp, struct nlm_args *argp,\r\nvoid *resp)\r\n{\r\ndprintk("lockd: LOCK_MSG called\n");\r\nreturn nlm4svc_callback(rqstp, NLMPROC_LOCK_RES, argp, nlm4svc_proc_lock);\r\n}\r\nstatic __be32 nlm4svc_proc_cancel_msg(struct svc_rqst *rqstp, struct nlm_args *argp,\r\nvoid *resp)\r\n{\r\ndprintk("lockd: CANCEL_MSG called\n");\r\nreturn nlm4svc_callback(rqstp, NLMPROC_CANCEL_RES, argp, nlm4svc_proc_cancel);\r\n}\r\nstatic __be32 nlm4svc_proc_unlock_msg(struct svc_rqst *rqstp, struct nlm_args *argp,\r\nvoid *resp)\r\n{\r\ndprintk("lockd: UNLOCK_MSG called\n");\r\nreturn nlm4svc_callback(rqstp, NLMPROC_UNLOCK_RES, argp, nlm4svc_proc_unlock);\r\n}\r\nstatic __be32 nlm4svc_proc_granted_msg(struct svc_rqst *rqstp, struct nlm_args *argp,\r\nvoid *resp)\r\n{\r\ndprintk("lockd: GRANTED_MSG called\n");\r\nreturn nlm4svc_callback(rqstp, NLMPROC_GRANTED_RES, argp, nlm4svc_proc_granted);\r\n}\r\nstatic __be32\r\nnlm4svc_proc_share(struct svc_rqst *rqstp, struct nlm_args *argp,\r\nstruct nlm_res *resp)\r\n{\r\nstruct nlm_host *host;\r\nstruct nlm_file *file;\r\ndprintk("lockd: SHARE called\n");\r\nresp->cookie = argp->cookie;\r\nif (locks_in_grace(SVC_NET(rqstp)) && !argp->reclaim) {\r\nresp->status = nlm_lck_denied_grace_period;\r\nreturn rpc_success;\r\n}\r\nif ((resp->status = nlm4svc_retrieve_args(rqstp, argp, &host, &file)))\r\nreturn resp->status == nlm_drop_reply ? rpc_drop_reply :rpc_success;\r\nresp->status = nlmsvc_share_file(host, file, argp);\r\ndprintk("lockd: SHARE status %d\n", ntohl(resp->status));\r\nnlmsvc_release_host(host);\r\nnlm_release_file(file);\r\nreturn rpc_success;\r\n}\r\nstatic __be32\r\nnlm4svc_proc_unshare(struct svc_rqst *rqstp, struct nlm_args *argp,\r\nstruct nlm_res *resp)\r\n{\r\nstruct nlm_host *host;\r\nstruct nlm_file *file;\r\ndprintk("lockd: UNSHARE called\n");\r\nresp->cookie = argp->cookie;\r\nif (locks_in_grace(SVC_NET(rqstp))) {\r\nresp->status = nlm_lck_denied_grace_period;\r\nreturn rpc_success;\r\n}\r\nif ((resp->status = nlm4svc_retrieve_args(rqstp, argp, &host, &file)))\r\nreturn resp->status == nlm_drop_reply ? rpc_drop_reply :rpc_success;\r\nresp->status = nlmsvc_unshare_file(host, file, argp);\r\ndprintk("lockd: UNSHARE status %d\n", ntohl(resp->status));\r\nnlmsvc_release_host(host);\r\nnlm_release_file(file);\r\nreturn rpc_success;\r\n}\r\nstatic __be32\r\nnlm4svc_proc_nm_lock(struct svc_rqst *rqstp, struct nlm_args *argp,\r\nstruct nlm_res *resp)\r\n{\r\ndprintk("lockd: NM_LOCK called\n");\r\nargp->monitor = 0;\r\nreturn nlm4svc_proc_lock(rqstp, argp, resp);\r\n}\r\nstatic __be32\r\nnlm4svc_proc_free_all(struct svc_rqst *rqstp, struct nlm_args *argp,\r\nvoid *resp)\r\n{\r\nstruct nlm_host *host;\r\nif (nlm4svc_retrieve_args(rqstp, argp, &host, NULL))\r\nreturn rpc_success;\r\nnlmsvc_free_host_resources(host);\r\nnlmsvc_release_host(host);\r\nreturn rpc_success;\r\n}\r\nstatic __be32\r\nnlm4svc_proc_sm_notify(struct svc_rqst *rqstp, struct nlm_reboot *argp,\r\nvoid *resp)\r\n{\r\ndprintk("lockd: SM_NOTIFY called\n");\r\nif (!nlm_privileged_requester(rqstp)) {\r\nchar buf[RPC_MAX_ADDRBUFLEN];\r\nprintk(KERN_WARNING "lockd: rejected NSM callback from %s\n",\r\nsvc_print_addr(rqstp, buf, sizeof(buf)));\r\nreturn rpc_system_err;\r\n}\r\nnlm_host_rebooted(argp);\r\nreturn rpc_success;\r\n}\r\nstatic __be32\r\nnlm4svc_proc_granted_res(struct svc_rqst *rqstp, struct nlm_res *argp,\r\nvoid *resp)\r\n{\r\nif (!nlmsvc_ops)\r\nreturn rpc_success;\r\ndprintk("lockd: GRANTED_RES called\n");\r\nnlmsvc_grant_reply(&argp->cookie, argp->status);\r\nreturn rpc_success;\r\n}
