static void sctp_ulpevent_init(struct sctp_ulpevent *event,\r\nint msg_flags,\r\nunsigned int len)\r\n{\r\nmemset(event, 0, sizeof(struct sctp_ulpevent));\r\nevent->msg_flags = msg_flags;\r\nevent->rmem_len = len;\r\n}\r\nstatic struct sctp_ulpevent *sctp_ulpevent_new(int size, int msg_flags,\r\ngfp_t gfp)\r\n{\r\nstruct sctp_ulpevent *event;\r\nstruct sk_buff *skb;\r\nskb = alloc_skb(size, gfp);\r\nif (!skb)\r\ngoto fail;\r\nevent = sctp_skb2event(skb);\r\nsctp_ulpevent_init(event, msg_flags, skb->truesize);\r\nreturn event;\r\nfail:\r\nreturn NULL;\r\n}\r\nint sctp_ulpevent_is_notification(const struct sctp_ulpevent *event)\r\n{\r\nreturn MSG_NOTIFICATION == (event->msg_flags & MSG_NOTIFICATION);\r\n}\r\nstatic inline void sctp_ulpevent_set_owner(struct sctp_ulpevent *event,\r\nconst struct sctp_association *asoc)\r\n{\r\nstruct sk_buff *skb;\r\nsctp_association_hold((struct sctp_association *)asoc);\r\nskb = sctp_event2skb(event);\r\nevent->asoc = (struct sctp_association *)asoc;\r\natomic_add(event->rmem_len, &event->asoc->rmem_alloc);\r\nsctp_skb_set_owner_r(skb, asoc->base.sk);\r\n}\r\nstatic inline void sctp_ulpevent_release_owner(struct sctp_ulpevent *event)\r\n{\r\nstruct sctp_association *asoc = event->asoc;\r\natomic_sub(event->rmem_len, &asoc->rmem_alloc);\r\nsctp_association_put(asoc);\r\n}\r\nstruct sctp_ulpevent *sctp_ulpevent_make_assoc_change(\r\nconst struct sctp_association *asoc,\r\n__u16 flags, __u16 state, __u16 error, __u16 outbound,\r\n__u16 inbound, struct sctp_chunk *chunk, gfp_t gfp)\r\n{\r\nstruct sctp_ulpevent *event;\r\nstruct sctp_assoc_change *sac;\r\nstruct sk_buff *skb;\r\nif (chunk) {\r\nskb = skb_copy_expand(chunk->skb,\r\nsizeof(struct sctp_assoc_change), 0, gfp);\r\nif (!skb)\r\ngoto fail;\r\nevent = sctp_skb2event(skb);\r\nsctp_ulpevent_init(event, MSG_NOTIFICATION, skb->truesize);\r\nsac = (struct sctp_assoc_change *)\r\nskb_push(skb, sizeof(struct sctp_assoc_change));\r\nskb_trim(skb, sizeof(struct sctp_assoc_change) +\r\nntohs(chunk->chunk_hdr->length) -\r\nsizeof(sctp_chunkhdr_t));\r\n} else {\r\nevent = sctp_ulpevent_new(sizeof(struct sctp_assoc_change),\r\nMSG_NOTIFICATION, gfp);\r\nif (!event)\r\ngoto fail;\r\nskb = sctp_event2skb(event);\r\nsac = (struct sctp_assoc_change *) skb_put(skb,\r\nsizeof(struct sctp_assoc_change));\r\n}\r\nsac->sac_type = SCTP_ASSOC_CHANGE;\r\nsac->sac_state = state;\r\nsac->sac_flags = 0;\r\nsac->sac_length = skb->len;\r\nsac->sac_error = error;\r\nsac->sac_outbound_streams = outbound;\r\nsac->sac_inbound_streams = inbound;\r\nsctp_ulpevent_set_owner(event, asoc);\r\nsac->sac_assoc_id = sctp_assoc2id(asoc);\r\nreturn event;\r\nfail:\r\nreturn NULL;\r\n}\r\nstruct sctp_ulpevent *sctp_ulpevent_make_peer_addr_change(\r\nconst struct sctp_association *asoc,\r\nconst struct sockaddr_storage *aaddr,\r\nint flags, int state, int error, gfp_t gfp)\r\n{\r\nstruct sctp_ulpevent *event;\r\nstruct sctp_paddr_change *spc;\r\nstruct sk_buff *skb;\r\nevent = sctp_ulpevent_new(sizeof(struct sctp_paddr_change),\r\nMSG_NOTIFICATION, gfp);\r\nif (!event)\r\ngoto fail;\r\nskb = sctp_event2skb(event);\r\nspc = (struct sctp_paddr_change *)\r\nskb_put(skb, sizeof(struct sctp_paddr_change));\r\nspc->spc_type = SCTP_PEER_ADDR_CHANGE;\r\nspc->spc_length = sizeof(struct sctp_paddr_change);\r\nspc->spc_flags = 0;\r\nspc->spc_state = state;\r\nspc->spc_error = error;\r\nsctp_ulpevent_set_owner(event, asoc);\r\nspc->spc_assoc_id = sctp_assoc2id(asoc);\r\nmemcpy(&spc->spc_aaddr, aaddr, sizeof(struct sockaddr_storage));\r\nsctp_get_pf_specific(asoc->base.sk->sk_family)->addr_to_user(\r\nsctp_sk(asoc->base.sk),\r\n(union sctp_addr *)&spc->spc_aaddr);\r\nreturn event;\r\nfail:\r\nreturn NULL;\r\n}\r\nstruct sctp_ulpevent *\r\nsctp_ulpevent_make_remote_error(const struct sctp_association *asoc,\r\nstruct sctp_chunk *chunk, __u16 flags,\r\ngfp_t gfp)\r\n{\r\nstruct sctp_ulpevent *event;\r\nstruct sctp_remote_error *sre;\r\nstruct sk_buff *skb;\r\nsctp_errhdr_t *ch;\r\n__be16 cause;\r\nint elen;\r\nch = (sctp_errhdr_t *)(chunk->skb->data);\r\ncause = ch->cause;\r\nelen = WORD_ROUND(ntohs(ch->length)) - sizeof(sctp_errhdr_t);\r\nskb_pull(chunk->skb, sizeof(sctp_errhdr_t));\r\nskb = skb_copy_expand(chunk->skb, sizeof(*sre), 0, gfp);\r\nskb_pull(chunk->skb, elen);\r\nif (!skb)\r\ngoto fail;\r\nevent = sctp_skb2event(skb);\r\nsctp_ulpevent_init(event, MSG_NOTIFICATION, skb->truesize);\r\nsre = (struct sctp_remote_error *) skb_push(skb, sizeof(*sre));\r\nskb_trim(skb, sizeof(*sre) + elen);\r\nmemset(sre, 0, sizeof(*sre));\r\nsre->sre_type = SCTP_REMOTE_ERROR;\r\nsre->sre_flags = 0;\r\nsre->sre_length = skb->len;\r\nsre->sre_error = cause;\r\nsctp_ulpevent_set_owner(event, asoc);\r\nsre->sre_assoc_id = sctp_assoc2id(asoc);\r\nreturn event;\r\nfail:\r\nreturn NULL;\r\n}\r\nstruct sctp_ulpevent *sctp_ulpevent_make_send_failed(\r\nconst struct sctp_association *asoc, struct sctp_chunk *chunk,\r\n__u16 flags, __u32 error, gfp_t gfp)\r\n{\r\nstruct sctp_ulpevent *event;\r\nstruct sctp_send_failed *ssf;\r\nstruct sk_buff *skb;\r\nint len = ntohs(chunk->chunk_hdr->length);\r\nskb = skb_copy_expand(chunk->skb,\r\nsizeof(struct sctp_send_failed),\r\n0,\r\ngfp);\r\nif (!skb)\r\ngoto fail;\r\nskb_pull(skb, sizeof(struct sctp_data_chunk));\r\nlen -= sizeof(struct sctp_data_chunk);\r\nevent = sctp_skb2event(skb);\r\nsctp_ulpevent_init(event, MSG_NOTIFICATION, skb->truesize);\r\nssf = (struct sctp_send_failed *)\r\nskb_push(skb, sizeof(struct sctp_send_failed));\r\nssf->ssf_type = SCTP_SEND_FAILED;\r\nssf->ssf_flags = flags;\r\nssf->ssf_length = sizeof(struct sctp_send_failed) + len;\r\nskb_trim(skb, ssf->ssf_length);\r\nssf->ssf_error = error;\r\nmemcpy(&ssf->ssf_info, &chunk->sinfo, sizeof(struct sctp_sndrcvinfo));\r\nssf->ssf_info.sinfo_flags = chunk->chunk_hdr->flags;\r\nsctp_ulpevent_set_owner(event, asoc);\r\nssf->ssf_assoc_id = sctp_assoc2id(asoc);\r\nreturn event;\r\nfail:\r\nreturn NULL;\r\n}\r\nstruct sctp_ulpevent *sctp_ulpevent_make_shutdown_event(\r\nconst struct sctp_association *asoc,\r\n__u16 flags, gfp_t gfp)\r\n{\r\nstruct sctp_ulpevent *event;\r\nstruct sctp_shutdown_event *sse;\r\nstruct sk_buff *skb;\r\nevent = sctp_ulpevent_new(sizeof(struct sctp_shutdown_event),\r\nMSG_NOTIFICATION, gfp);\r\nif (!event)\r\ngoto fail;\r\nskb = sctp_event2skb(event);\r\nsse = (struct sctp_shutdown_event *)\r\nskb_put(skb, sizeof(struct sctp_shutdown_event));\r\nsse->sse_type = SCTP_SHUTDOWN_EVENT;\r\nsse->sse_flags = 0;\r\nsse->sse_length = sizeof(struct sctp_shutdown_event);\r\nsctp_ulpevent_set_owner(event, asoc);\r\nsse->sse_assoc_id = sctp_assoc2id(asoc);\r\nreturn event;\r\nfail:\r\nreturn NULL;\r\n}\r\nstruct sctp_ulpevent *sctp_ulpevent_make_adaptation_indication(\r\nconst struct sctp_association *asoc, gfp_t gfp)\r\n{\r\nstruct sctp_ulpevent *event;\r\nstruct sctp_adaptation_event *sai;\r\nstruct sk_buff *skb;\r\nevent = sctp_ulpevent_new(sizeof(struct sctp_adaptation_event),\r\nMSG_NOTIFICATION, gfp);\r\nif (!event)\r\ngoto fail;\r\nskb = sctp_event2skb(event);\r\nsai = (struct sctp_adaptation_event *)\r\nskb_put(skb, sizeof(struct sctp_adaptation_event));\r\nsai->sai_type = SCTP_ADAPTATION_INDICATION;\r\nsai->sai_flags = 0;\r\nsai->sai_length = sizeof(struct sctp_adaptation_event);\r\nsai->sai_adaptation_ind = asoc->peer.adaptation_ind;\r\nsctp_ulpevent_set_owner(event, asoc);\r\nsai->sai_assoc_id = sctp_assoc2id(asoc);\r\nreturn event;\r\nfail:\r\nreturn NULL;\r\n}\r\nstruct sctp_ulpevent *sctp_ulpevent_make_rcvmsg(struct sctp_association *asoc,\r\nstruct sctp_chunk *chunk,\r\ngfp_t gfp)\r\n{\r\nstruct sctp_ulpevent *event = NULL;\r\nstruct sk_buff *skb;\r\nsize_t padding, len;\r\nint rx_count;\r\nif (asoc->ep->rcvbuf_policy)\r\nrx_count = atomic_read(&asoc->rmem_alloc);\r\nelse\r\nrx_count = atomic_read(&asoc->base.sk->sk_rmem_alloc);\r\nif (rx_count >= asoc->base.sk->sk_rcvbuf) {\r\nif ((asoc->base.sk->sk_userlocks & SOCK_RCVBUF_LOCK) ||\r\n(!sk_rmem_schedule(asoc->base.sk, chunk->skb,\r\nchunk->skb->truesize)))\r\ngoto fail;\r\n}\r\nskb = skb_clone(chunk->skb, gfp);\r\nif (!skb)\r\ngoto fail;\r\nif (sctp_tsnmap_mark(&asoc->peer.tsn_map,\r\nntohl(chunk->subh.data_hdr->tsn),\r\nchunk->transport))\r\ngoto fail_mark;\r\nlen = ntohs(chunk->chunk_hdr->length);\r\npadding = WORD_ROUND(len) - len;\r\nskb_trim(skb, chunk->chunk_end - padding - skb->data);\r\nevent = sctp_skb2event(skb);\r\nsctp_ulpevent_init(event, 0, skb->len + sizeof(struct sk_buff));\r\nsctp_ulpevent_receive_data(event, asoc);\r\nevent->stream = ntohs(chunk->subh.data_hdr->stream);\r\nevent->ssn = ntohs(chunk->subh.data_hdr->ssn);\r\nevent->ppid = chunk->subh.data_hdr->ppid;\r\nif (chunk->chunk_hdr->flags & SCTP_DATA_UNORDERED) {\r\nevent->flags |= SCTP_UNORDERED;\r\nevent->cumtsn = sctp_tsnmap_get_ctsn(&asoc->peer.tsn_map);\r\n}\r\nevent->tsn = ntohl(chunk->subh.data_hdr->tsn);\r\nevent->msg_flags |= chunk->chunk_hdr->flags;\r\nevent->iif = sctp_chunk_iif(chunk);\r\nreturn event;\r\nfail_mark:\r\nkfree_skb(skb);\r\nfail:\r\nreturn NULL;\r\n}\r\nstruct sctp_ulpevent *sctp_ulpevent_make_pdapi(\r\nconst struct sctp_association *asoc, __u32 indication,\r\ngfp_t gfp)\r\n{\r\nstruct sctp_ulpevent *event;\r\nstruct sctp_pdapi_event *pd;\r\nstruct sk_buff *skb;\r\nevent = sctp_ulpevent_new(sizeof(struct sctp_pdapi_event),\r\nMSG_NOTIFICATION, gfp);\r\nif (!event)\r\ngoto fail;\r\nskb = sctp_event2skb(event);\r\npd = (struct sctp_pdapi_event *)\r\nskb_put(skb, sizeof(struct sctp_pdapi_event));\r\npd->pdapi_type = SCTP_PARTIAL_DELIVERY_EVENT;\r\npd->pdapi_flags = 0;\r\npd->pdapi_length = sizeof(struct sctp_pdapi_event);\r\npd->pdapi_indication = indication;\r\nsctp_ulpevent_set_owner(event, asoc);\r\npd->pdapi_assoc_id = sctp_assoc2id(asoc);\r\nreturn event;\r\nfail:\r\nreturn NULL;\r\n}\r\nstruct sctp_ulpevent *sctp_ulpevent_make_authkey(\r\nconst struct sctp_association *asoc, __u16 key_id,\r\n__u32 indication, gfp_t gfp)\r\n{\r\nstruct sctp_ulpevent *event;\r\nstruct sctp_authkey_event *ak;\r\nstruct sk_buff *skb;\r\nevent = sctp_ulpevent_new(sizeof(struct sctp_authkey_event),\r\nMSG_NOTIFICATION, gfp);\r\nif (!event)\r\ngoto fail;\r\nskb = sctp_event2skb(event);\r\nak = (struct sctp_authkey_event *)\r\nskb_put(skb, sizeof(struct sctp_authkey_event));\r\nak->auth_type = SCTP_AUTHENTICATION_EVENT;\r\nak->auth_flags = 0;\r\nak->auth_length = sizeof(struct sctp_authkey_event);\r\nak->auth_keynumber = key_id;\r\nak->auth_altkeynumber = 0;\r\nak->auth_indication = indication;\r\nsctp_ulpevent_set_owner(event, asoc);\r\nak->auth_assoc_id = sctp_assoc2id(asoc);\r\nreturn event;\r\nfail:\r\nreturn NULL;\r\n}\r\nstruct sctp_ulpevent *sctp_ulpevent_make_sender_dry_event(\r\nconst struct sctp_association *asoc, gfp_t gfp)\r\n{\r\nstruct sctp_ulpevent *event;\r\nstruct sctp_sender_dry_event *sdry;\r\nstruct sk_buff *skb;\r\nevent = sctp_ulpevent_new(sizeof(struct sctp_sender_dry_event),\r\nMSG_NOTIFICATION, gfp);\r\nif (!event)\r\nreturn NULL;\r\nskb = sctp_event2skb(event);\r\nsdry = (struct sctp_sender_dry_event *)\r\nskb_put(skb, sizeof(struct sctp_sender_dry_event));\r\nsdry->sender_dry_type = SCTP_SENDER_DRY_EVENT;\r\nsdry->sender_dry_flags = 0;\r\nsdry->sender_dry_length = sizeof(struct sctp_sender_dry_event);\r\nsctp_ulpevent_set_owner(event, asoc);\r\nsdry->sender_dry_assoc_id = sctp_assoc2id(asoc);\r\nreturn event;\r\n}\r\n__u16 sctp_ulpevent_get_notification_type(const struct sctp_ulpevent *event)\r\n{\r\nunion sctp_notification *notification;\r\nstruct sk_buff *skb;\r\nskb = sctp_event2skb(event);\r\nnotification = (union sctp_notification *) skb->data;\r\nreturn notification->sn_header.sn_type;\r\n}\r\nvoid sctp_ulpevent_read_sndrcvinfo(const struct sctp_ulpevent *event,\r\nstruct msghdr *msghdr)\r\n{\r\nstruct sctp_sndrcvinfo sinfo;\r\nif (sctp_ulpevent_is_notification(event))\r\nreturn;\r\nmemset(&sinfo, 0, sizeof(sinfo));\r\nsinfo.sinfo_stream = event->stream;\r\nsinfo.sinfo_ssn = event->ssn;\r\nsinfo.sinfo_ppid = event->ppid;\r\nsinfo.sinfo_flags = event->flags;\r\nsinfo.sinfo_tsn = event->tsn;\r\nsinfo.sinfo_cumtsn = event->cumtsn;\r\nsinfo.sinfo_assoc_id = sctp_assoc2id(event->asoc);\r\nsinfo.sinfo_context = event->asoc->default_rcv_context;\r\nsinfo.sinfo_timetolive = 0;\r\nput_cmsg(msghdr, IPPROTO_SCTP, SCTP_SNDRCV,\r\nsizeof(sinfo), &sinfo);\r\n}\r\nvoid sctp_ulpevent_read_rcvinfo(const struct sctp_ulpevent *event,\r\nstruct msghdr *msghdr)\r\n{\r\nstruct sctp_rcvinfo rinfo;\r\nif (sctp_ulpevent_is_notification(event))\r\nreturn;\r\nmemset(&rinfo, 0, sizeof(struct sctp_rcvinfo));\r\nrinfo.rcv_sid = event->stream;\r\nrinfo.rcv_ssn = event->ssn;\r\nrinfo.rcv_ppid = event->ppid;\r\nrinfo.rcv_flags = event->flags;\r\nrinfo.rcv_tsn = event->tsn;\r\nrinfo.rcv_cumtsn = event->cumtsn;\r\nrinfo.rcv_assoc_id = sctp_assoc2id(event->asoc);\r\nrinfo.rcv_context = event->asoc->default_rcv_context;\r\nput_cmsg(msghdr, IPPROTO_SCTP, SCTP_RCVINFO,\r\nsizeof(rinfo), &rinfo);\r\n}\r\nstatic void __sctp_ulpevent_read_nxtinfo(const struct sctp_ulpevent *event,\r\nstruct msghdr *msghdr,\r\nconst struct sk_buff *skb)\r\n{\r\nstruct sctp_nxtinfo nxtinfo;\r\nmemset(&nxtinfo, 0, sizeof(nxtinfo));\r\nnxtinfo.nxt_sid = event->stream;\r\nnxtinfo.nxt_ppid = event->ppid;\r\nnxtinfo.nxt_flags = event->flags;\r\nif (sctp_ulpevent_is_notification(event))\r\nnxtinfo.nxt_flags |= SCTP_NOTIFICATION;\r\nnxtinfo.nxt_length = skb->len;\r\nnxtinfo.nxt_assoc_id = sctp_assoc2id(event->asoc);\r\nput_cmsg(msghdr, IPPROTO_SCTP, SCTP_NXTINFO,\r\nsizeof(nxtinfo), &nxtinfo);\r\n}\r\nvoid sctp_ulpevent_read_nxtinfo(const struct sctp_ulpevent *event,\r\nstruct msghdr *msghdr,\r\nstruct sock *sk)\r\n{\r\nstruct sk_buff *skb;\r\nint err;\r\nskb = sctp_skb_recv_datagram(sk, MSG_PEEK, 1, &err);\r\nif (skb != NULL) {\r\n__sctp_ulpevent_read_nxtinfo(sctp_skb2event(skb),\r\nmsghdr, skb);\r\nkfree_skb(skb);\r\n}\r\n}\r\nstatic void sctp_ulpevent_receive_data(struct sctp_ulpevent *event,\r\nstruct sctp_association *asoc)\r\n{\r\nstruct sk_buff *skb, *frag;\r\nskb = sctp_event2skb(event);\r\nsctp_ulpevent_set_owner(event, asoc);\r\nsctp_assoc_rwnd_decrease(asoc, skb_headlen(skb));\r\nif (!skb->data_len)\r\nreturn;\r\nskb_walk_frags(skb, frag)\r\nsctp_ulpevent_receive_data(sctp_skb2event(frag), asoc);\r\n}\r\nstatic void sctp_ulpevent_release_data(struct sctp_ulpevent *event)\r\n{\r\nstruct sk_buff *skb, *frag;\r\nunsigned int len;\r\nskb = sctp_event2skb(event);\r\nlen = skb->len;\r\nif (!skb->data_len)\r\ngoto done;\r\nskb_walk_frags(skb, frag) {\r\nsctp_ulpevent_release_frag_data(sctp_skb2event(frag));\r\n}\r\ndone:\r\nsctp_assoc_rwnd_increase(event->asoc, len);\r\nsctp_ulpevent_release_owner(event);\r\n}\r\nstatic void sctp_ulpevent_release_frag_data(struct sctp_ulpevent *event)\r\n{\r\nstruct sk_buff *skb, *frag;\r\nskb = sctp_event2skb(event);\r\nif (!skb->data_len)\r\ngoto done;\r\nskb_walk_frags(skb, frag) {\r\nsctp_ulpevent_release_frag_data(sctp_skb2event(frag));\r\n}\r\ndone:\r\nsctp_ulpevent_release_owner(event);\r\n}\r\nvoid sctp_ulpevent_free(struct sctp_ulpevent *event)\r\n{\r\nif (sctp_ulpevent_is_notification(event))\r\nsctp_ulpevent_release_owner(event);\r\nelse\r\nsctp_ulpevent_release_data(event);\r\nkfree_skb(sctp_event2skb(event));\r\n}\r\nunsigned int sctp_queue_purge_ulpevents(struct sk_buff_head *list)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned int data_unread = 0;\r\nwhile ((skb = skb_dequeue(list)) != NULL) {\r\nstruct sctp_ulpevent *event = sctp_skb2event(skb);\r\nif (!sctp_ulpevent_is_notification(event))\r\ndata_unread += skb->len;\r\nsctp_ulpevent_free(event);\r\n}\r\nreturn data_unread;\r\n}
