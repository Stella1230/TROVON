static int ssi_debug_show(struct seq_file *m, void *p __maybe_unused)\r\n{\r\nstruct hsi_controller *ssi = m->private;\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\nvoid __iomem *sys = omap_ssi->sys;\r\npm_runtime_get_sync(ssi->device.parent);\r\nseq_printf(m, "REVISION\t: 0x%08x\n", readl(sys + SSI_REVISION_REG));\r\nseq_printf(m, "SYSCONFIG\t: 0x%08x\n", readl(sys + SSI_SYSCONFIG_REG));\r\nseq_printf(m, "SYSSTATUS\t: 0x%08x\n", readl(sys + SSI_SYSSTATUS_REG));\r\npm_runtime_put_sync(ssi->device.parent);\r\nreturn 0;\r\n}\r\nstatic int ssi_debug_gdd_show(struct seq_file *m, void *p __maybe_unused)\r\n{\r\nstruct hsi_controller *ssi = m->private;\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\nvoid __iomem *gdd = omap_ssi->gdd;\r\nvoid __iomem *sys = omap_ssi->sys;\r\nint lch;\r\npm_runtime_get_sync(ssi->device.parent);\r\nseq_printf(m, "GDD_MPU_STATUS\t: 0x%08x\n",\r\nreadl(sys + SSI_GDD_MPU_IRQ_STATUS_REG));\r\nseq_printf(m, "GDD_MPU_ENABLE\t: 0x%08x\n\n",\r\nreadl(sys + SSI_GDD_MPU_IRQ_ENABLE_REG));\r\nseq_printf(m, "HW_ID\t\t: 0x%08x\n",\r\nreadl(gdd + SSI_GDD_HW_ID_REG));\r\nseq_printf(m, "PPORT_ID\t: 0x%08x\n",\r\nreadl(gdd + SSI_GDD_PPORT_ID_REG));\r\nseq_printf(m, "MPORT_ID\t: 0x%08x\n",\r\nreadl(gdd + SSI_GDD_MPORT_ID_REG));\r\nseq_printf(m, "TEST\t\t: 0x%08x\n",\r\nreadl(gdd + SSI_GDD_TEST_REG));\r\nseq_printf(m, "GCR\t\t: 0x%08x\n",\r\nreadl(gdd + SSI_GDD_GCR_REG));\r\nfor (lch = 0; lch < SSI_MAX_GDD_LCH; lch++) {\r\nseq_printf(m, "\nGDD LCH %d\n=========\n", lch);\r\nseq_printf(m, "CSDP\t\t: 0x%04x\n",\r\nreadw(gdd + SSI_GDD_CSDP_REG(lch)));\r\nseq_printf(m, "CCR\t\t: 0x%04x\n",\r\nreadw(gdd + SSI_GDD_CCR_REG(lch)));\r\nseq_printf(m, "CICR\t\t: 0x%04x\n",\r\nreadw(gdd + SSI_GDD_CICR_REG(lch)));\r\nseq_printf(m, "CSR\t\t: 0x%04x\n",\r\nreadw(gdd + SSI_GDD_CSR_REG(lch)));\r\nseq_printf(m, "CSSA\t\t: 0x%08x\n",\r\nreadl(gdd + SSI_GDD_CSSA_REG(lch)));\r\nseq_printf(m, "CDSA\t\t: 0x%08x\n",\r\nreadl(gdd + SSI_GDD_CDSA_REG(lch)));\r\nseq_printf(m, "CEN\t\t: 0x%04x\n",\r\nreadw(gdd + SSI_GDD_CEN_REG(lch)));\r\nseq_printf(m, "CSAC\t\t: 0x%04x\n",\r\nreadw(gdd + SSI_GDD_CSAC_REG(lch)));\r\nseq_printf(m, "CDAC\t\t: 0x%04x\n",\r\nreadw(gdd + SSI_GDD_CDAC_REG(lch)));\r\nseq_printf(m, "CLNK_CTRL\t: 0x%04x\n",\r\nreadw(gdd + SSI_GDD_CLNK_CTRL_REG(lch)));\r\n}\r\npm_runtime_put_sync(ssi->device.parent);\r\nreturn 0;\r\n}\r\nstatic int ssi_regs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ssi_debug_show, inode->i_private);\r\n}\r\nstatic int ssi_gdd_regs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ssi_debug_gdd_show, inode->i_private);\r\n}\r\nstatic int __init ssi_debug_add_ctrl(struct hsi_controller *ssi)\r\n{\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\nstruct dentry *dir;\r\nomap_ssi->dir = debugfs_create_dir(dev_name(&ssi->device), NULL);\r\nif (!omap_ssi->dir)\r\nreturn -ENOMEM;\r\ndebugfs_create_file("regs", S_IRUGO, omap_ssi->dir, ssi,\r\n&ssi_regs_fops);\r\ndir = debugfs_create_dir("gdd", omap_ssi->dir);\r\nif (!dir)\r\ngoto rback;\r\ndebugfs_create_file("regs", S_IRUGO, dir, ssi, &ssi_gdd_regs_fops);\r\nreturn 0;\r\nrback:\r\ndebugfs_remove_recursive(omap_ssi->dir);\r\nreturn -ENOMEM;\r\n}\r\nstatic void ssi_debug_remove_ctrl(struct hsi_controller *ssi)\r\n{\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\ndebugfs_remove_recursive(omap_ssi->dir);\r\n}\r\nvoid ssi_waketest(struct hsi_client *cl, unsigned int enable)\r\n{\r\nstruct hsi_port *port = hsi_get_port(cl);\r\nstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\r\nstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\nomap_port->wktest = !!enable;\r\nif (omap_port->wktest) {\r\npm_runtime_get_sync(ssi->device.parent);\r\nwritel_relaxed(SSI_WAKE(0),\r\nomap_ssi->sys + SSI_SET_WAKE_REG(port->num));\r\n} else {\r\nwritel_relaxed(SSI_WAKE(0),\r\nomap_ssi->sys + SSI_CLEAR_WAKE_REG(port->num));\r\npm_runtime_put_sync(ssi->device.parent);\r\n}\r\n}\r\nstatic void ssi_gdd_complete(struct hsi_controller *ssi, unsigned int lch)\r\n{\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\nstruct hsi_msg *msg = omap_ssi->gdd_trn[lch].msg;\r\nstruct hsi_port *port = to_hsi_port(msg->cl->device.parent);\r\nstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\r\nunsigned int dir;\r\nu32 csr;\r\nu32 val;\r\nspin_lock(&omap_ssi->lock);\r\nval = readl(omap_ssi->sys + SSI_GDD_MPU_IRQ_ENABLE_REG);\r\nval &= ~SSI_GDD_LCH(lch);\r\nwritel_relaxed(val, omap_ssi->sys + SSI_GDD_MPU_IRQ_ENABLE_REG);\r\nif (msg->ttype == HSI_MSG_READ) {\r\ndir = DMA_FROM_DEVICE;\r\nval = SSI_DATAAVAILABLE(msg->channel);\r\npm_runtime_put_sync(ssi->device.parent);\r\n} else {\r\ndir = DMA_TO_DEVICE;\r\nval = SSI_DATAACCEPT(msg->channel);\r\n}\r\ndma_unmap_sg(&ssi->device, msg->sgt.sgl, msg->sgt.nents, dir);\r\ncsr = readw(omap_ssi->gdd + SSI_GDD_CSR_REG(lch));\r\nomap_ssi->gdd_trn[lch].msg = NULL;\r\ndev_dbg(&port->device, "DMA completed ch %d ttype %d\n",\r\nmsg->channel, msg->ttype);\r\nspin_unlock(&omap_ssi->lock);\r\nif (csr & SSI_CSR_TOUR) {\r\nmsg->status = HSI_STATUS_ERROR;\r\nmsg->actual_len = 0;\r\nspin_lock(&omap_port->lock);\r\nlist_del(&msg->link);\r\nspin_unlock(&omap_port->lock);\r\nmsg->complete(msg);\r\nreturn;\r\n}\r\nspin_lock(&omap_port->lock);\r\nval |= readl(omap_ssi->sys + SSI_MPU_ENABLE_REG(port->num, 0));\r\nwritel_relaxed(val, omap_ssi->sys + SSI_MPU_ENABLE_REG(port->num, 0));\r\nspin_unlock(&omap_port->lock);\r\nmsg->status = HSI_STATUS_COMPLETED;\r\nmsg->actual_len = sg_dma_len(msg->sgt.sgl);\r\n}\r\nstatic void ssi_gdd_tasklet(unsigned long dev)\r\n{\r\nstruct hsi_controller *ssi = (struct hsi_controller *)dev;\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\nvoid __iomem *sys = omap_ssi->sys;\r\nunsigned int lch;\r\nu32 status_reg;\r\npm_runtime_get_sync(ssi->device.parent);\r\nstatus_reg = readl(sys + SSI_GDD_MPU_IRQ_STATUS_REG);\r\nfor (lch = 0; lch < SSI_MAX_GDD_LCH; lch++) {\r\nif (status_reg & SSI_GDD_LCH(lch))\r\nssi_gdd_complete(ssi, lch);\r\n}\r\nwritel_relaxed(status_reg, sys + SSI_GDD_MPU_IRQ_STATUS_REG);\r\nstatus_reg = readl(sys + SSI_GDD_MPU_IRQ_STATUS_REG);\r\npm_runtime_put_sync(ssi->device.parent);\r\nif (status_reg)\r\ntasklet_hi_schedule(&omap_ssi->gdd_tasklet);\r\nelse\r\nenable_irq(omap_ssi->gdd_irq);\r\n}\r\nstatic irqreturn_t ssi_gdd_isr(int irq, void *ssi)\r\n{\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\ntasklet_hi_schedule(&omap_ssi->gdd_tasklet);\r\ndisable_irq_nosync(irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned long ssi_get_clk_rate(struct hsi_controller *ssi)\r\n{\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\nunsigned long rate = clk_get_rate(omap_ssi->fck);\r\nreturn rate;\r\n}\r\nstatic int __init ssi_get_iomem(struct platform_device *pd,\r\nconst char *name, void __iomem **pbase, dma_addr_t *phy)\r\n{\r\nstruct resource *mem;\r\nstruct resource *ioarea;\r\nvoid __iomem *base;\r\nstruct hsi_controller *ssi = platform_get_drvdata(pd);\r\nmem = platform_get_resource_byname(pd, IORESOURCE_MEM, name);\r\nif (!mem) {\r\ndev_err(&pd->dev, "IO memory region missing (%s)\n", name);\r\nreturn -ENXIO;\r\n}\r\nioarea = devm_request_mem_region(&ssi->device, mem->start,\r\nresource_size(mem), dev_name(&pd->dev));\r\nif (!ioarea) {\r\ndev_err(&pd->dev, "%s IO memory region request failed\n",\r\nmem->name);\r\nreturn -ENXIO;\r\n}\r\nbase = devm_ioremap(&ssi->device, mem->start, resource_size(mem));\r\nif (!base) {\r\ndev_err(&pd->dev, "%s IO remap failed\n", mem->name);\r\nreturn -ENXIO;\r\n}\r\n*pbase = base;\r\nif (phy)\r\n*phy = mem->start;\r\nreturn 0;\r\n}\r\nstatic int __init ssi_add_controller(struct hsi_controller *ssi,\r\nstruct platform_device *pd)\r\n{\r\nstruct omap_ssi_controller *omap_ssi;\r\nint err;\r\nomap_ssi = devm_kzalloc(&ssi->device, sizeof(*omap_ssi), GFP_KERNEL);\r\nif (!omap_ssi) {\r\ndev_err(&pd->dev, "not enough memory for omap ssi\n");\r\nreturn -ENOMEM;\r\n}\r\nssi->id = ida_simple_get(&platform_omap_ssi_ida, 0, 0, GFP_KERNEL);\r\nif (ssi->id < 0) {\r\nerr = ssi->id;\r\ngoto out_err;\r\n}\r\nssi->owner = THIS_MODULE;\r\nssi->device.parent = &pd->dev;\r\ndev_set_name(&ssi->device, "ssi%d", ssi->id);\r\nhsi_controller_set_drvdata(ssi, omap_ssi);\r\nomap_ssi->dev = &ssi->device;\r\nerr = ssi_get_iomem(pd, "sys", &omap_ssi->sys, NULL);\r\nif (err < 0)\r\ngoto out_err;\r\nerr = ssi_get_iomem(pd, "gdd", &omap_ssi->gdd, NULL);\r\nif (err < 0)\r\ngoto out_err;\r\nerr = platform_get_irq_byname(pd, "gdd_mpu");\r\nif (err < 0) {\r\ndev_err(&pd->dev, "GDD IRQ resource missing\n");\r\ngoto out_err;\r\n}\r\nomap_ssi->gdd_irq = err;\r\ntasklet_init(&omap_ssi->gdd_tasklet, ssi_gdd_tasklet,\r\n(unsigned long)ssi);\r\nerr = devm_request_irq(&ssi->device, omap_ssi->gdd_irq, ssi_gdd_isr,\r\n0, "gdd_mpu", ssi);\r\nif (err < 0) {\r\ndev_err(&ssi->device, "Request GDD IRQ %d failed (%d)",\r\nomap_ssi->gdd_irq, err);\r\ngoto out_err;\r\n}\r\nomap_ssi->port = devm_kzalloc(&ssi->device,\r\nsizeof(struct omap_ssi_port *) * ssi->num_ports, GFP_KERNEL);\r\nif (!omap_ssi->port) {\r\nerr = -ENOMEM;\r\ngoto out_err;\r\n}\r\nomap_ssi->fck = devm_clk_get(&ssi->device, "ssi_ssr_fck");\r\nif (IS_ERR(omap_ssi->fck)) {\r\ndev_err(&pd->dev, "Could not acquire clock \"ssi_ssr_fck\": %li\n",\r\nPTR_ERR(omap_ssi->fck));\r\nerr = -ENODEV;\r\ngoto out_err;\r\n}\r\nomap_ssi->get_loss = NULL;\r\nomap_ssi->max_speed = UINT_MAX;\r\nspin_lock_init(&omap_ssi->lock);\r\nerr = hsi_register_controller(ssi);\r\nif (err < 0)\r\ngoto out_err;\r\nreturn 0;\r\nout_err:\r\nida_simple_remove(&platform_omap_ssi_ida, ssi->id);\r\nreturn err;\r\n}\r\nstatic int __init ssi_hw_init(struct hsi_controller *ssi)\r\n{\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\nunsigned int i;\r\nu32 val;\r\nint err;\r\nerr = pm_runtime_get_sync(ssi->device.parent);\r\nif (err < 0) {\r\ndev_err(&ssi->device, "runtime PM failed %d\n", err);\r\nreturn err;\r\n}\r\nwritel_relaxed(SSI_SOFTRESET, omap_ssi->sys + SSI_SYSCONFIG_REG);\r\nval = readl(omap_ssi->sys + SSI_SYSSTATUS_REG);\r\nfor (i = 0; ((i < 20) && !(val & SSI_RESETDONE)); i++) {\r\nmsleep(20);\r\nval = readl(omap_ssi->sys + SSI_SYSSTATUS_REG);\r\n}\r\nif (!(val & SSI_RESETDONE)) {\r\ndev_err(&ssi->device, "SSI HW reset failed\n");\r\npm_runtime_put_sync(ssi->device.parent);\r\nreturn -EIO;\r\n}\r\nwritel_relaxed(SSI_SWRESET, omap_ssi->gdd + SSI_GDD_GRST_REG);\r\nomap_ssi->fck_rate = DIV_ROUND_CLOSEST(ssi_get_clk_rate(ssi), 1000);\r\ndev_dbg(&ssi->device, "SSI fck rate %lu KHz\n", omap_ssi->fck_rate);\r\nval = SSI_AUTOIDLE | SSI_SIDLEMODE_SMART | SSI_MIDLEMODE_SMART;\r\nwritel_relaxed(val, omap_ssi->sys + SSI_SYSCONFIG_REG);\r\nomap_ssi->sysconfig = val;\r\nwritel_relaxed(SSI_CLK_AUTOGATING_ON, omap_ssi->sys + SSI_GDD_GCR_REG);\r\nomap_ssi->gdd_gcr = SSI_CLK_AUTOGATING_ON;\r\npm_runtime_put_sync(ssi->device.parent);\r\nreturn 0;\r\n}\r\nstatic void ssi_remove_controller(struct hsi_controller *ssi)\r\n{\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\nint id = ssi->id;\r\ntasklet_kill(&omap_ssi->gdd_tasklet);\r\nhsi_unregister_controller(ssi);\r\nida_simple_remove(&platform_omap_ssi_ida, id);\r\n}\r\nstatic inline int ssi_of_get_available_ports_count(const struct device_node *np)\r\n{\r\nstruct device_node *child;\r\nint num = 0;\r\nfor_each_available_child_of_node(np, child)\r\nif (of_device_is_compatible(child, "ti,omap3-ssi-port"))\r\nnum++;\r\nreturn num;\r\n}\r\nstatic int ssi_remove_ports(struct device *dev, void *c)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nof_device_unregister(pdev);\r\nreturn 0;\r\n}\r\nstatic int __init ssi_probe(struct platform_device *pd)\r\n{\r\nstruct platform_device *childpdev;\r\nstruct device_node *np = pd->dev.of_node;\r\nstruct device_node *child;\r\nstruct hsi_controller *ssi;\r\nint err;\r\nint num_ports;\r\nif (!np) {\r\ndev_err(&pd->dev, "missing device tree data\n");\r\nreturn -EINVAL;\r\n}\r\nnum_ports = ssi_of_get_available_ports_count(np);\r\nssi = hsi_alloc_controller(num_ports, GFP_KERNEL);\r\nif (!ssi) {\r\ndev_err(&pd->dev, "No memory for controller\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pd, ssi);\r\nerr = ssi_add_controller(ssi, pd);\r\nif (err < 0)\r\ngoto out1;\r\npm_runtime_irq_safe(&pd->dev);\r\npm_runtime_enable(&pd->dev);\r\nerr = ssi_hw_init(ssi);\r\nif (err < 0)\r\ngoto out2;\r\n#ifdef CONFIG_DEBUG_FS\r\nerr = ssi_debug_add_ctrl(ssi);\r\nif (err < 0)\r\ngoto out2;\r\n#endif\r\nfor_each_available_child_of_node(np, child) {\r\nif (!of_device_is_compatible(child, "ti,omap3-ssi-port"))\r\ncontinue;\r\nchildpdev = of_platform_device_create(child, NULL, &pd->dev);\r\nif (!childpdev) {\r\nerr = -ENODEV;\r\ndev_err(&pd->dev, "failed to create ssi controller port\n");\r\ngoto out3;\r\n}\r\n}\r\ndev_info(&pd->dev, "ssi controller %d initialized (%d ports)!\n",\r\nssi->id, num_ports);\r\nreturn err;\r\nout3:\r\ndevice_for_each_child(&pd->dev, NULL, ssi_remove_ports);\r\nout2:\r\nssi_remove_controller(ssi);\r\nout1:\r\nplatform_set_drvdata(pd, NULL);\r\npm_runtime_disable(&pd->dev);\r\nreturn err;\r\n}\r\nstatic int __exit ssi_remove(struct platform_device *pd)\r\n{\r\nstruct hsi_controller *ssi = platform_get_drvdata(pd);\r\n#ifdef CONFIG_DEBUG_FS\r\nssi_debug_remove_ctrl(ssi);\r\n#endif\r\nssi_remove_controller(ssi);\r\nplatform_set_drvdata(pd, NULL);\r\npm_runtime_disable(&pd->dev);\r\ndevice_for_each_child(&pd->dev, NULL, ssi_remove_ports);\r\nreturn 0;\r\n}\r\nstatic int omap_ssi_runtime_suspend(struct device *dev)\r\n{\r\nstruct hsi_controller *ssi = dev_get_drvdata(dev);\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\ndev_dbg(dev, "runtime suspend!\n");\r\nif (omap_ssi->get_loss)\r\nomap_ssi->loss_count =\r\nomap_ssi->get_loss(ssi->device.parent);\r\nreturn 0;\r\n}\r\nstatic int omap_ssi_runtime_resume(struct device *dev)\r\n{\r\nstruct hsi_controller *ssi = dev_get_drvdata(dev);\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\ndev_dbg(dev, "runtime resume!\n");\r\nif ((omap_ssi->get_loss) && (omap_ssi->loss_count ==\r\nomap_ssi->get_loss(ssi->device.parent)))\r\nreturn 0;\r\nwritel_relaxed(omap_ssi->gdd_gcr, omap_ssi->gdd + SSI_GDD_GCR_REG);\r\nreturn 0;\r\n}
