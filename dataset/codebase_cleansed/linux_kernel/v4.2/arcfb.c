static void ks108_writeb_ctl(struct arcfb_par *par,\r\nunsigned int chipindex, unsigned char value)\r\n{\r\nunsigned char chipselval = par->cslut[chipindex];\r\noutb(chipselval|KS_CEHI|KS_SEL_CMD, par->cio_addr);\r\noutb(value, par->dio_addr);\r\nudelay(tuhold);\r\noutb(chipselval|KS_CELO|KS_SEL_CMD, par->cio_addr);\r\n}\r\nstatic void ks108_writeb_mainctl(struct arcfb_par *par, unsigned char value)\r\n{\r\noutb(value, par->cio_addr);\r\nudelay(tuhold);\r\n}\r\nstatic unsigned char ks108_readb_ctl2(struct arcfb_par *par)\r\n{\r\nreturn inb(par->c2io_addr);\r\n}\r\nstatic void ks108_writeb_data(struct arcfb_par *par,\r\nunsigned int chipindex, unsigned char value)\r\n{\r\nunsigned char chipselval = par->cslut[chipindex];\r\noutb(chipselval|KS_CEHI|KS_SEL_DATA, par->cio_addr);\r\noutb(value, par->dio_addr);\r\nudelay(tuhold);\r\noutb(chipselval|KS_CELO|KS_SEL_DATA, par->cio_addr);\r\n}\r\nstatic void ks108_set_start_line(struct arcfb_par *par,\r\nunsigned int chipindex, unsigned char y)\r\n{\r\nks108_writeb_ctl(par, chipindex, KS_SET_DPY_START_LINE|y);\r\n}\r\nstatic void ks108_set_yaddr(struct arcfb_par *par,\r\nunsigned int chipindex, unsigned char y)\r\n{\r\nks108_writeb_ctl(par, chipindex, KS_SET_PAGE_NUM|y);\r\n}\r\nstatic void ks108_set_xaddr(struct arcfb_par *par,\r\nunsigned int chipindex, unsigned char x)\r\n{\r\nks108_writeb_ctl(par, chipindex, KS_SET_X|x);\r\n}\r\nstatic void ks108_clear_lcd(struct arcfb_par *par, unsigned int chipindex)\r\n{\r\nint i,j;\r\nfor (i = 0; i <= 8; i++) {\r\nks108_set_yaddr(par, chipindex, i);\r\nks108_set_xaddr(par, chipindex, 0);\r\nfor (j = 0; j < 64; j++) {\r\nks108_writeb_data(par, chipindex,\r\n(unsigned char) splashval);\r\n}\r\n}\r\n}\r\nstatic int arcfb_open(struct fb_info *info, int user)\r\n{\r\nstruct arcfb_par *par = info->par;\r\natomic_inc(&par->ref_count);\r\nreturn 0;\r\n}\r\nstatic int arcfb_release(struct fb_info *info, int user)\r\n{\r\nstruct arcfb_par *par = info->par;\r\nint count = atomic_read(&par->ref_count);\r\nif (!count)\r\nreturn -EINVAL;\r\natomic_dec(&par->ref_count);\r\nreturn 0;\r\n}\r\nstatic int arcfb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nint i;\r\nstruct arcfb_par *par = info->par;\r\nif ((var->vmode & FB_VMODE_YWRAP) && (var->yoffset < 64)\r\n&& (info->var.yres <= 64)) {\r\nfor (i = 0; i < num_cols; i++) {\r\nks108_set_start_line(par, i, var->yoffset);\r\n}\r\ninfo->var.yoffset = var->yoffset;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic irqreturn_t arcfb_interrupt(int vec, void *dev_instance)\r\n{\r\nstruct fb_info *info = dev_instance;\r\nunsigned char ctl2status;\r\nstruct arcfb_par *par = info->par;\r\nctl2status = ks108_readb_ctl2(par);\r\nif (!(ctl2status & KS_INTACK))\r\nreturn IRQ_NONE;\r\nks108_writeb_mainctl(par, KS_CLRINT);\r\nspin_lock(&par->lock);\r\nif (waitqueue_active(&arcfb_waitq)) {\r\nwake_up(&arcfb_waitq);\r\n}\r\nspin_unlock(&par->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void arcfb_lcd_update_page(struct arcfb_par *par, unsigned int upper,\r\nunsigned int left, unsigned int right, unsigned int distance)\r\n{\r\nunsigned char *src;\r\nunsigned int xindex, yindex, chipindex, linesize;\r\nint i;\r\nunsigned char val;\r\nunsigned char bitmask, rightshift;\r\nxindex = left >> 6;\r\nyindex = upper >> 6;\r\nchipindex = (xindex + (yindex*num_cols));\r\nks108_set_yaddr(par, chipindex, upper/8);\r\nlinesize = par->info->var.xres/8;\r\nsrc = (unsigned char __force *) par->info->screen_base + (left/8) +\r\n(upper * linesize);\r\nks108_set_xaddr(par, chipindex, left);\r\nbitmask=1;\r\nrightshift=0;\r\nwhile (left <= right) {\r\nval = 0;\r\nfor (i = 0; i < 8; i++) {\r\nif ( i > rightshift) {\r\nval |= (*(src + (i*linesize)) & bitmask)\r\n<< (i - rightshift);\r\n} else {\r\nval |= (*(src + (i*linesize)) & bitmask)\r\n>> (rightshift - i);\r\n}\r\n}\r\nks108_writeb_data(par, chipindex, val);\r\nleft++;\r\nif (bitmask == 0x80) {\r\nbitmask = 1;\r\nsrc++;\r\nrightshift=0;\r\n} else {\r\nbitmask <<= 1;\r\nrightshift++;\r\n}\r\n}\r\n}\r\nstatic void arcfb_lcd_update_vert(struct arcfb_par *par, unsigned int top,\r\nunsigned int bottom, unsigned int left, unsigned int right)\r\n{\r\nunsigned int distance, upper, lower;\r\ndistance = (bottom - top) + 1;\r\nupper = top;\r\nlower = top + 7;\r\nwhile (distance > 0) {\r\ndistance -= 8;\r\narcfb_lcd_update_page(par, upper, left, right, 8);\r\nupper = lower + 1;\r\nlower = upper + 7;\r\n}\r\n}\r\nstatic void arcfb_lcd_update_horiz(struct arcfb_par *par, unsigned int left,\r\nunsigned int right, unsigned int top, unsigned int h)\r\n{\r\nunsigned int distance, upper, lower;\r\ndistance = h;\r\nupper = floor8(top);\r\nlower = min(upper + distance - 1, ceil64(upper));\r\nwhile (distance > 0) {\r\ndistance -= ((lower - upper) + 1 );\r\narcfb_lcd_update_vert(par, upper, lower, left, right);\r\nupper = lower + 1;\r\nlower = min(upper + distance - 1, ceil64(upper));\r\n}\r\n}\r\nstatic void arcfb_lcd_update(struct arcfb_par *par, unsigned int dx,\r\nunsigned int dy, unsigned int w, unsigned int h)\r\n{\r\nunsigned int left, right, distance, y;\r\ny = floor8(dy);\r\nh += dy - y;\r\nh = iceil8(h);\r\ndistance = w;\r\nleft = dx;\r\nright = min(left + w - 1, ceil64(left));\r\nwhile (distance > 0) {\r\narcfb_lcd_update_horiz(par, left, right, y, h);\r\ndistance -= ((right - left) + 1);\r\nleft = right + 1;\r\nright = min(left + distance - 1, ceil64(left));\r\n}\r\n}\r\nstatic void arcfb_fillrect(struct fb_info *info,\r\nconst struct fb_fillrect *rect)\r\n{\r\nstruct arcfb_par *par = info->par;\r\nsys_fillrect(info, rect);\r\narcfb_lcd_update(par, rect->dx, rect->dy, rect->width, rect->height);\r\n}\r\nstatic void arcfb_copyarea(struct fb_info *info,\r\nconst struct fb_copyarea *area)\r\n{\r\nstruct arcfb_par *par = info->par;\r\nsys_copyarea(info, area);\r\narcfb_lcd_update(par, area->dx, area->dy, area->width, area->height);\r\n}\r\nstatic void arcfb_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\nstruct arcfb_par *par = info->par;\r\nsys_imageblit(info, image);\r\narcfb_lcd_update(par, image->dx, image->dy, image->width,\r\nimage->height);\r\n}\r\nstatic int arcfb_ioctl(struct fb_info *info,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nstruct arcfb_par *par = info->par;\r\nunsigned long flags;\r\nswitch (cmd) {\r\ncase FBIO_WAITEVENT:\r\n{\r\nDEFINE_WAIT(wait);\r\nif (!par->irq)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&par->lock, flags);\r\nprepare_to_wait(&arcfb_waitq, &wait,\r\nTASK_INTERRUPTIBLE);\r\nspin_unlock_irqrestore(&par->lock, flags);\r\nschedule();\r\nfinish_wait(&arcfb_waitq, &wait);\r\n}\r\ncase FBIO_GETCONTROL2:\r\n{\r\nunsigned char ctl2;\r\nctl2 = ks108_readb_ctl2(info->par);\r\nif (copy_to_user(argp, &ctl2, sizeof(ctl2)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic ssize_t arcfb_write(struct fb_info *info, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nunsigned long p;\r\nint err=-EINVAL;\r\nunsigned int fbmemlength,x,y,w,h, bitppos, startpos, endpos, bitcount;\r\nstruct arcfb_par *par;\r\nunsigned int xres;\r\np = *ppos;\r\npar = info->par;\r\nxres = info->var.xres;\r\nfbmemlength = (xres * info->var.yres)/8;\r\nif (p > fbmemlength)\r\nreturn -ENOSPC;\r\nerr = 0;\r\nif ((count + p) > fbmemlength) {\r\ncount = fbmemlength - p;\r\nerr = -ENOSPC;\r\n}\r\nif (count) {\r\nchar *base_addr;\r\nbase_addr = (char __force *)info->screen_base;\r\ncount -= copy_from_user(base_addr + p, buf, count);\r\n*ppos += count;\r\nerr = -EFAULT;\r\n}\r\nbitppos = p*8;\r\nstartpos = floorXres(bitppos, xres);\r\nendpos = ceilXres((bitppos + (count*8)), xres);\r\nbitcount = endpos - startpos;\r\nx = startpos % xres;\r\ny = startpos / xres;\r\nw = xres;\r\nh = bitcount / xres;\r\narcfb_lcd_update(par, x, y, w, h);\r\nif (count)\r\nreturn count;\r\nreturn err;\r\n}\r\nstatic int arcfb_probe(struct platform_device *dev)\r\n{\r\nstruct fb_info *info;\r\nint retval = -ENOMEM;\r\nint videomemorysize;\r\nunsigned char *videomemory;\r\nstruct arcfb_par *par;\r\nint i;\r\nvideomemorysize = (((64*64)*num_cols)*num_rows)/8;\r\nvideomemory = vzalloc(videomemorysize);\r\nif (!videomemory)\r\nreturn retval;\r\ninfo = framebuffer_alloc(sizeof(struct arcfb_par), &dev->dev);\r\nif (!info)\r\ngoto err;\r\ninfo->screen_base = (char __iomem *)videomemory;\r\ninfo->fbops = &arcfb_ops;\r\ninfo->var = arcfb_var;\r\ninfo->fix = arcfb_fix;\r\npar = info->par;\r\npar->info = info;\r\nif (!dio_addr || !cio_addr || !c2io_addr) {\r\nprintk(KERN_WARNING "no IO addresses supplied\n");\r\ngoto err1;\r\n}\r\npar->dio_addr = dio_addr;\r\npar->cio_addr = cio_addr;\r\npar->c2io_addr = c2io_addr;\r\npar->cslut[0] = 0x00;\r\npar->cslut[1] = 0x06;\r\ninfo->flags = FBINFO_FLAG_DEFAULT;\r\nspin_lock_init(&par->lock);\r\nretval = register_framebuffer(info);\r\nif (retval < 0)\r\ngoto err1;\r\nplatform_set_drvdata(dev, info);\r\nif (irq) {\r\npar->irq = irq;\r\nif (request_irq(par->irq, &arcfb_interrupt, IRQF_SHARED,\r\n"arcfb", info)) {\r\nprintk(KERN_INFO\r\n"arcfb: Failed req IRQ %d\n", par->irq);\r\nretval = -EBUSY;\r\ngoto err1;\r\n}\r\n}\r\nfb_info(info, "Arc frame buffer device, using %dK of video memory\n",\r\nvideomemorysize >> 10);\r\nfor (i = 0; i < num_cols * num_rows; i++) {\r\nks108_writeb_ctl(par, i, KS_DPY_OFF);\r\nks108_set_start_line(par, i, 0);\r\nks108_set_yaddr(par, i, 0);\r\nks108_set_xaddr(par, i, 0);\r\nks108_writeb_ctl(par, i, KS_DPY_ON);\r\n}\r\nif (!nosplash) {\r\nfor (i = 0; i < num_cols * num_rows; i++) {\r\nfb_info(info, "splashing lcd %d\n", i);\r\nks108_set_start_line(par, i, 0);\r\nks108_clear_lcd(par, i);\r\n}\r\n}\r\nreturn 0;\r\nerr1:\r\nframebuffer_release(info);\r\nerr:\r\nvfree(videomemory);\r\nreturn retval;\r\n}\r\nstatic int arcfb_remove(struct platform_device *dev)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(dev);\r\nif (info) {\r\nunregister_framebuffer(info);\r\nvfree((void __force *)info->screen_base);\r\nframebuffer_release(info);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init arcfb_init(void)\r\n{\r\nint ret;\r\nif (!arcfb_enable)\r\nreturn -ENXIO;\r\nret = platform_driver_register(&arcfb_driver);\r\nif (!ret) {\r\narcfb_device = platform_device_alloc("arcfb", 0);\r\nif (arcfb_device) {\r\nret = platform_device_add(arcfb_device);\r\n} else {\r\nret = -ENOMEM;\r\n}\r\nif (ret) {\r\nplatform_device_put(arcfb_device);\r\nplatform_driver_unregister(&arcfb_driver);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit arcfb_exit(void)\r\n{\r\nplatform_device_unregister(arcfb_device);\r\nplatform_driver_unregister(&arcfb_driver);\r\n}
