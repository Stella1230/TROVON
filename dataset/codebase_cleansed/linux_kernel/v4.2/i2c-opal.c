static int i2c_opal_translate_error(int rc)\r\n{\r\nswitch (rc) {\r\ncase OPAL_NO_MEM:\r\nreturn -ENOMEM;\r\ncase OPAL_PARAMETER:\r\nreturn -EINVAL;\r\ncase OPAL_I2C_ARBT_LOST:\r\nreturn -EAGAIN;\r\ncase OPAL_I2C_TIMEOUT:\r\nreturn -ETIMEDOUT;\r\ncase OPAL_I2C_NACK_RCVD:\r\nreturn -ENXIO;\r\ncase OPAL_I2C_STOP_ERR:\r\nreturn -EBUSY;\r\ndefault:\r\nreturn -EIO;\r\n}\r\n}\r\nstatic int i2c_opal_send_request(u32 bus_id, struct opal_i2c_request *req)\r\n{\r\nstruct opal_msg msg;\r\nint token, rc;\r\ntoken = opal_async_get_token_interruptible();\r\nif (token < 0) {\r\nif (token != -ERESTARTSYS)\r\npr_err("Failed to get the async token\n");\r\nreturn token;\r\n}\r\nrc = opal_i2c_request(token, bus_id, req);\r\nif (rc != OPAL_ASYNC_COMPLETION) {\r\nrc = i2c_opal_translate_error(rc);\r\ngoto exit;\r\n}\r\nrc = opal_async_wait_response(token, &msg);\r\nif (rc)\r\ngoto exit;\r\nrc = be64_to_cpu(msg.params[1]);\r\nif (rc != OPAL_SUCCESS) {\r\nrc = i2c_opal_translate_error(rc);\r\ngoto exit;\r\n}\r\nexit:\r\nopal_async_release_token(token);\r\nreturn rc;\r\n}\r\nstatic int i2c_opal_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\r\nint num)\r\n{\r\nunsigned long opal_id = (unsigned long)adap->algo_data;\r\nstruct opal_i2c_request req;\r\nint rc, i;\r\nmemset(&req, 0, sizeof(req));\r\nswitch(num) {\r\ncase 0:\r\nreturn 0;\r\ncase 1:\r\nreq.type = (msgs[0].flags & I2C_M_RD) ?\r\nOPAL_I2C_RAW_READ : OPAL_I2C_RAW_WRITE;\r\nreq.addr = cpu_to_be16(msgs[0].addr);\r\nreq.size = cpu_to_be32(msgs[0].len);\r\nreq.buffer_ra = cpu_to_be64(__pa(msgs[0].buf));\r\nbreak;\r\ncase 2:\r\nreq.type = (msgs[1].flags & I2C_M_RD) ?\r\nOPAL_I2C_SM_READ : OPAL_I2C_SM_WRITE;\r\nreq.addr = cpu_to_be16(msgs[0].addr);\r\nreq.subaddr_sz = msgs[0].len;\r\nfor (i = 0; i < msgs[0].len; i++)\r\nreq.subaddr = (req.subaddr << 8) | msgs[0].buf[i];\r\nreq.subaddr = cpu_to_be32(req.subaddr);\r\nreq.size = cpu_to_be32(msgs[1].len);\r\nreq.buffer_ra = cpu_to_be64(__pa(msgs[1].buf));\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nrc = i2c_opal_send_request(opal_id, &req);\r\nif (rc)\r\nreturn rc;\r\nreturn num;\r\n}\r\nstatic int i2c_opal_smbus_xfer(struct i2c_adapter *adap, u16 addr,\r\nunsigned short flags, char read_write,\r\nu8 command, int size, union i2c_smbus_data *data)\r\n{\r\nunsigned long opal_id = (unsigned long)adap->algo_data;\r\nstruct opal_i2c_request req;\r\nu8 local[2];\r\nint rc;\r\nmemset(&req, 0, sizeof(req));\r\nreq.addr = cpu_to_be16(addr);\r\nswitch (size) {\r\ncase I2C_SMBUS_BYTE:\r\nreq.buffer_ra = cpu_to_be64(__pa(&data->byte));\r\nreq.size = cpu_to_be32(1);\r\ncase I2C_SMBUS_QUICK:\r\nreq.type = (read_write == I2C_SMBUS_READ) ?\r\nOPAL_I2C_RAW_READ : OPAL_I2C_RAW_WRITE;\r\nbreak;\r\ncase I2C_SMBUS_BYTE_DATA:\r\nreq.buffer_ra = cpu_to_be64(__pa(&data->byte));\r\nreq.size = cpu_to_be32(1);\r\nreq.subaddr = cpu_to_be32(command);\r\nreq.subaddr_sz = 1;\r\nreq.type = (read_write == I2C_SMBUS_READ) ?\r\nOPAL_I2C_SM_READ : OPAL_I2C_SM_WRITE;\r\nbreak;\r\ncase I2C_SMBUS_WORD_DATA:\r\nif (!read_write) {\r\nlocal[0] = data->word & 0xff;\r\nlocal[1] = (data->word >> 8) & 0xff;\r\n}\r\nreq.buffer_ra = cpu_to_be64(__pa(local));\r\nreq.size = cpu_to_be32(2);\r\nreq.subaddr = cpu_to_be32(command);\r\nreq.subaddr_sz = 1;\r\nreq.type = (read_write == I2C_SMBUS_READ) ?\r\nOPAL_I2C_SM_READ : OPAL_I2C_SM_WRITE;\r\nbreak;\r\ncase I2C_SMBUS_I2C_BLOCK_DATA:\r\nreq.buffer_ra = cpu_to_be64(__pa(&data->block[1]));\r\nreq.size = cpu_to_be32(data->block[0]);\r\nreq.subaddr = cpu_to_be32(command);\r\nreq.subaddr_sz = 1;\r\nreq.type = (read_write == I2C_SMBUS_READ) ?\r\nOPAL_I2C_SM_READ : OPAL_I2C_SM_WRITE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nrc = i2c_opal_send_request(opal_id, &req);\r\nif (!rc && read_write && size == I2C_SMBUS_WORD_DATA) {\r\ndata->word = ((u16)local[1]) << 8;\r\ndata->word |= local[0];\r\n}\r\nreturn rc;\r\n}\r\nstatic u32 i2c_opal_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |\r\nI2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |\r\nI2C_FUNC_SMBUS_I2C_BLOCK;\r\n}\r\nstatic int i2c_opal_probe(struct platform_device *pdev)\r\n{\r\nstruct i2c_adapter *adapter;\r\nconst char *pname;\r\nu32 opal_id;\r\nint rc;\r\nif (!pdev->dev.of_node)\r\nreturn -ENODEV;\r\nrc = of_property_read_u32(pdev->dev.of_node, "ibm,opal-id", &opal_id);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Missing ibm,opal-id property !\n");\r\nreturn -EIO;\r\n}\r\nadapter = devm_kzalloc(&pdev->dev, sizeof(*adapter), GFP_KERNEL);\r\nif (!adapter)\r\nreturn -ENOMEM;\r\nadapter->algo = &i2c_opal_algo;\r\nadapter->algo_data = (void *)(unsigned long)opal_id;\r\nadapter->quirks = &i2c_opal_quirks;\r\nadapter->dev.parent = &pdev->dev;\r\nadapter->dev.of_node = of_node_get(pdev->dev.of_node);\r\npname = of_get_property(pdev->dev.of_node, "ibm,port-name", NULL);\r\nif (pname)\r\nstrlcpy(adapter->name, pname, sizeof(adapter->name));\r\nelse\r\nstrlcpy(adapter->name, "opal", sizeof(adapter->name));\r\nplatform_set_drvdata(pdev, adapter);\r\nrc = i2c_add_adapter(adapter);\r\nif (rc)\r\ndev_err(&pdev->dev, "Failed to register the i2c adapter\n");\r\nreturn rc;\r\n}\r\nstatic int i2c_opal_remove(struct platform_device *pdev)\r\n{\r\nstruct i2c_adapter *adapter = platform_get_drvdata(pdev);\r\ni2c_del_adapter(adapter);\r\nreturn 0;\r\n}\r\nstatic int __init i2c_opal_init(void)\r\n{\r\nif (!firmware_has_feature(FW_FEATURE_OPAL))\r\nreturn -ENODEV;\r\nreturn platform_driver_register(&i2c_opal_driver);\r\n}\r\nstatic void __exit i2c_opal_exit(void)\r\n{\r\nreturn platform_driver_unregister(&i2c_opal_driver);\r\n}
