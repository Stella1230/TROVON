void page_counter_cancel(struct page_counter *counter, unsigned long nr_pages)\r\n{\r\nlong new;\r\nnew = atomic_long_sub_return(nr_pages, &counter->count);\r\nWARN_ON_ONCE(new < 0);\r\n}\r\nvoid page_counter_charge(struct page_counter *counter, unsigned long nr_pages)\r\n{\r\nstruct page_counter *c;\r\nfor (c = counter; c; c = c->parent) {\r\nlong new;\r\nnew = atomic_long_add_return(nr_pages, &c->count);\r\nif (new > c->watermark)\r\nc->watermark = new;\r\n}\r\n}\r\nint page_counter_try_charge(struct page_counter *counter,\r\nunsigned long nr_pages,\r\nstruct page_counter **fail)\r\n{\r\nstruct page_counter *c;\r\nfor (c = counter; c; c = c->parent) {\r\nlong new;\r\nnew = atomic_long_add_return(nr_pages, &c->count);\r\nif (new > c->limit) {\r\natomic_long_sub(nr_pages, &c->count);\r\nc->failcnt++;\r\n*fail = c;\r\ngoto failed;\r\n}\r\nif (new > c->watermark)\r\nc->watermark = new;\r\n}\r\nreturn 0;\r\nfailed:\r\nfor (c = counter; c != *fail; c = c->parent)\r\npage_counter_cancel(c, nr_pages);\r\nreturn -ENOMEM;\r\n}\r\nvoid page_counter_uncharge(struct page_counter *counter, unsigned long nr_pages)\r\n{\r\nstruct page_counter *c;\r\nfor (c = counter; c; c = c->parent)\r\npage_counter_cancel(c, nr_pages);\r\n}\r\nint page_counter_limit(struct page_counter *counter, unsigned long limit)\r\n{\r\nfor (;;) {\r\nunsigned long old;\r\nlong count;\r\ncount = atomic_long_read(&counter->count);\r\nif (count > limit)\r\nreturn -EBUSY;\r\nold = xchg(&counter->limit, limit);\r\nif (atomic_long_read(&counter->count) <= count)\r\nreturn 0;\r\ncounter->limit = old;\r\ncond_resched();\r\n}\r\n}\r\nint page_counter_memparse(const char *buf, const char *max,\r\nunsigned long *nr_pages)\r\n{\r\nchar *end;\r\nu64 bytes;\r\nif (!strcmp(buf, max)) {\r\n*nr_pages = PAGE_COUNTER_MAX;\r\nreturn 0;\r\n}\r\nbytes = memparse(buf, &end);\r\nif (*end != '\0')\r\nreturn -EINVAL;\r\n*nr_pages = min(bytes / PAGE_SIZE, (u64)PAGE_COUNTER_MAX);\r\nreturn 0;\r\n}
