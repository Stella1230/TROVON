static int rcar_sysc_pwr_on_off(struct rcar_sysc_ch *sysc_ch,\r\nint sr_bit, int reg_offs)\r\n{\r\nint k;\r\nfor (k = 0; k < SYSCSR_RETRIES; k++) {\r\nif (ioread32(rcar_sysc_base + SYSCSR) & (1 << sr_bit))\r\nbreak;\r\nudelay(SYSCSR_DELAY_US);\r\n}\r\nif (k == SYSCSR_RETRIES)\r\nreturn -EAGAIN;\r\niowrite32(1 << sysc_ch->chan_bit,\r\nrcar_sysc_base + sysc_ch->chan_offs + reg_offs);\r\nreturn 0;\r\n}\r\nstatic int rcar_sysc_pwr_off(struct rcar_sysc_ch *sysc_ch)\r\n{\r\nreturn rcar_sysc_pwr_on_off(sysc_ch, 0, PWROFFCR_OFFS);\r\n}\r\nstatic int rcar_sysc_pwr_on(struct rcar_sysc_ch *sysc_ch)\r\n{\r\nreturn rcar_sysc_pwr_on_off(sysc_ch, 1, PWRONCR_OFFS);\r\n}\r\nstatic int rcar_sysc_update(struct rcar_sysc_ch *sysc_ch,\r\nint (*on_off_fn)(struct rcar_sysc_ch *))\r\n{\r\nunsigned int isr_mask = 1 << sysc_ch->isr_bit;\r\nunsigned int chan_mask = 1 << sysc_ch->chan_bit;\r\nunsigned int status;\r\nunsigned long flags;\r\nint ret = 0;\r\nint k;\r\nspin_lock_irqsave(&rcar_sysc_lock, flags);\r\niowrite32(isr_mask, rcar_sysc_base + SYSCISCR);\r\ndo {\r\nret = on_off_fn(sysc_ch);\r\nif (ret)\r\ngoto out;\r\nstatus = ioread32(rcar_sysc_base +\r\nsysc_ch->chan_offs + PWRER_OFFS);\r\n} while (status & chan_mask);\r\nfor (k = 0; k < SYSCISR_RETRIES; k++) {\r\nif (ioread32(rcar_sysc_base + SYSCISR) & isr_mask)\r\nbreak;\r\nudelay(SYSCISR_DELAY_US);\r\n}\r\nif (k == SYSCISR_RETRIES)\r\nret = -EIO;\r\niowrite32(isr_mask, rcar_sysc_base + SYSCISCR);\r\nout:\r\nspin_unlock_irqrestore(&rcar_sysc_lock, flags);\r\npr_debug("sysc power domain %d: %08x -> %d\n",\r\nsysc_ch->isr_bit, ioread32(rcar_sysc_base + SYSCISR), ret);\r\nreturn ret;\r\n}\r\nint rcar_sysc_power_down(struct rcar_sysc_ch *sysc_ch)\r\n{\r\nreturn rcar_sysc_update(sysc_ch, rcar_sysc_pwr_off);\r\n}\r\nint rcar_sysc_power_up(struct rcar_sysc_ch *sysc_ch)\r\n{\r\nreturn rcar_sysc_update(sysc_ch, rcar_sysc_pwr_on);\r\n}\r\nbool rcar_sysc_power_is_off(struct rcar_sysc_ch *sysc_ch)\r\n{\r\nunsigned int st;\r\nst = ioread32(rcar_sysc_base + sysc_ch->chan_offs + PWRSR_OFFS);\r\nif (st & (1 << sysc_ch->chan_bit))\r\nreturn true;\r\nreturn false;\r\n}\r\nvoid __iomem *rcar_sysc_init(phys_addr_t base)\r\n{\r\nrcar_sysc_base = ioremap_nocache(base, PAGE_SIZE);\r\nif (!rcar_sysc_base)\r\npanic("unable to ioremap R-Car SYSC hardware block\n");\r\nreturn rcar_sysc_base;\r\n}
