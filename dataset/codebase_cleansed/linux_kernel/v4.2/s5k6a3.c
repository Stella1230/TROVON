static inline struct s5k6a3 *sd_to_s5k6a3(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct s5k6a3, subdev);\r\n}\r\nstatic const struct v4l2_mbus_framefmt *find_sensor_format(\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(s5k6a3_formats); i++)\r\nif (mf->code == s5k6a3_formats[i].code)\r\nreturn &s5k6a3_formats[i];\r\nreturn &s5k6a3_formats[0];\r\n}\r\nstatic int s5k6a3_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nif (code->index >= ARRAY_SIZE(s5k6a3_formats))\r\nreturn -EINVAL;\r\ncode->code = s5k6a3_formats[code->index].code;\r\nreturn 0;\r\n}\r\nstatic void s5k6a3_try_format(struct v4l2_mbus_framefmt *mf)\r\n{\r\nconst struct v4l2_mbus_framefmt *fmt;\r\nfmt = find_sensor_format(mf);\r\nmf->code = fmt->code;\r\nmf->field = V4L2_FIELD_NONE;\r\nv4l_bound_align_image(&mf->width, S5K6A3_SENSOR_MIN_WIDTH,\r\nS5K6A3_SENSOR_MAX_WIDTH, 0,\r\n&mf->height, S5K6A3_SENSOR_MIN_HEIGHT,\r\nS5K6A3_SENSOR_MAX_HEIGHT, 0, 0);\r\n}\r\nstatic struct v4l2_mbus_framefmt *__s5k6a3_get_format(\r\nstruct s5k6a3 *sensor, struct v4l2_subdev_pad_config *cfg,\r\nu32 pad, enum v4l2_subdev_format_whence which)\r\n{\r\nif (which == V4L2_SUBDEV_FORMAT_TRY)\r\nreturn cfg ? v4l2_subdev_get_try_format(&sensor->subdev, cfg, pad) : NULL;\r\nreturn &sensor->format;\r\n}\r\nstatic int s5k6a3_set_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct s5k6a3 *sensor = sd_to_s5k6a3(sd);\r\nstruct v4l2_mbus_framefmt *mf;\r\ns5k6a3_try_format(&fmt->format);\r\nmf = __s5k6a3_get_format(sensor, cfg, fmt->pad, fmt->which);\r\nif (mf) {\r\nmutex_lock(&sensor->lock);\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)\r\n*mf = fmt->format;\r\nmutex_unlock(&sensor->lock);\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5k6a3_get_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct s5k6a3 *sensor = sd_to_s5k6a3(sd);\r\nstruct v4l2_mbus_framefmt *mf;\r\nmf = __s5k6a3_get_format(sensor, cfg, fmt->pad, fmt->which);\r\nmutex_lock(&sensor->lock);\r\nfmt->format = *mf;\r\nmutex_unlock(&sensor->lock);\r\nreturn 0;\r\n}\r\nstatic int s5k6a3_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\r\n{\r\nstruct v4l2_mbus_framefmt *format = v4l2_subdev_get_try_format(sd, fh->pad, 0);\r\n*format = s5k6a3_formats[0];\r\nformat->width = S5K6A3_DEFAULT_WIDTH;\r\nformat->height = S5K6A3_DEFAULT_HEIGHT;\r\nreturn 0;\r\n}\r\nstatic int __s5k6a3_power_on(struct s5k6a3 *sensor)\r\n{\r\nint i = S5K6A3_SUPP_VDDA;\r\nint ret;\r\nret = clk_set_rate(sensor->clock, sensor->clock_frequency);\r\nif (ret < 0)\r\nreturn ret;\r\nret = pm_runtime_get(sensor->dev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regulator_enable(sensor->supplies[i].consumer);\r\nif (ret < 0)\r\ngoto error_rpm_put;\r\nret = clk_prepare_enable(sensor->clock);\r\nif (ret < 0)\r\ngoto error_reg_dis;\r\nfor (i++; i < S5K6A3_NUM_SUPPLIES; i++) {\r\nret = regulator_enable(sensor->supplies[i].consumer);\r\nif (ret < 0)\r\ngoto error_reg_dis;\r\n}\r\ngpio_set_value(sensor->gpio_reset, 1);\r\nusleep_range(600, 800);\r\ngpio_set_value(sensor->gpio_reset, 0);\r\nusleep_range(600, 800);\r\ngpio_set_value(sensor->gpio_reset, 1);\r\nmsleep(20);\r\nreturn 0;\r\nerror_reg_dis:\r\nfor (--i; i >= 0; --i)\r\nregulator_disable(sensor->supplies[i].consumer);\r\nerror_rpm_put:\r\npm_runtime_put(sensor->dev);\r\nreturn ret;\r\n}\r\nstatic int __s5k6a3_power_off(struct s5k6a3 *sensor)\r\n{\r\nint i;\r\ngpio_set_value(sensor->gpio_reset, 0);\r\nfor (i = S5K6A3_NUM_SUPPLIES - 1; i >= 0; i--)\r\nregulator_disable(sensor->supplies[i].consumer);\r\nclk_disable_unprepare(sensor->clock);\r\npm_runtime_put(sensor->dev);\r\nreturn 0;\r\n}\r\nstatic int s5k6a3_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct s5k6a3 *sensor = sd_to_s5k6a3(sd);\r\nint ret = 0;\r\nmutex_lock(&sensor->lock);\r\nif (sensor->power_count == !on) {\r\nif (on)\r\nret = __s5k6a3_power_on(sensor);\r\nelse\r\nret = __s5k6a3_power_off(sensor);\r\nif (ret == 0)\r\nsensor->power_count += on ? 1 : -1;\r\n}\r\nmutex_unlock(&sensor->lock);\r\nreturn ret;\r\n}\r\nstatic int s5k6a3_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct s5k6a3 *sensor;\r\nstruct v4l2_subdev *sd;\r\nint gpio, i, ret;\r\nsensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);\r\nif (!sensor)\r\nreturn -ENOMEM;\r\nmutex_init(&sensor->lock);\r\nsensor->gpio_reset = -EINVAL;\r\nsensor->clock = ERR_PTR(-EINVAL);\r\nsensor->dev = dev;\r\nsensor->clock = devm_clk_get(sensor->dev, S5K6A3_CLK_NAME);\r\nif (IS_ERR(sensor->clock))\r\nreturn PTR_ERR(sensor->clock);\r\ngpio = of_get_gpio_flags(dev->of_node, 0, NULL);\r\nif (!gpio_is_valid(gpio))\r\nreturn gpio;\r\nret = devm_gpio_request_one(dev, gpio, GPIOF_OUT_INIT_LOW,\r\nS5K6A3_DRV_NAME);\r\nif (ret < 0)\r\nreturn ret;\r\nsensor->gpio_reset = gpio;\r\nif (of_property_read_u32(dev->of_node, "clock-frequency",\r\n&sensor->clock_frequency)) {\r\nsensor->clock_frequency = S5K6A3_DEFAULT_CLK_FREQ;\r\ndev_info(dev, "using default %u Hz clock frequency\n",\r\nsensor->clock_frequency);\r\n}\r\nfor (i = 0; i < S5K6A3_NUM_SUPPLIES; i++)\r\nsensor->supplies[i].supply = s5k6a3_supply_names[i];\r\nret = devm_regulator_bulk_get(&client->dev, S5K6A3_NUM_SUPPLIES,\r\nsensor->supplies);\r\nif (ret < 0)\r\nreturn ret;\r\nsd = &sensor->subdev;\r\nv4l2_i2c_subdev_init(sd, client, &s5k6a3_subdev_ops);\r\nsensor->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nsd->internal_ops = &s5k6a3_sd_internal_ops;\r\nsensor->format.code = s5k6a3_formats[0].code;\r\nsensor->format.width = S5K6A3_DEFAULT_WIDTH;\r\nsensor->format.height = S5K6A3_DEFAULT_HEIGHT;\r\nsensor->pad.flags = MEDIA_PAD_FL_SOURCE;\r\nret = media_entity_init(&sd->entity, 1, &sensor->pad, 0);\r\nif (ret < 0)\r\nreturn ret;\r\npm_runtime_no_callbacks(dev);\r\npm_runtime_enable(dev);\r\nret = v4l2_async_register_subdev(sd);\r\nif (ret < 0) {\r\npm_runtime_disable(&client->dev);\r\nmedia_entity_cleanup(&sd->entity);\r\n}\r\nreturn ret;\r\n}\r\nstatic int s5k6a3_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\npm_runtime_disable(&client->dev);\r\nv4l2_async_unregister_subdev(sd);\r\nmedia_entity_cleanup(&sd->entity);\r\nreturn 0;\r\n}
