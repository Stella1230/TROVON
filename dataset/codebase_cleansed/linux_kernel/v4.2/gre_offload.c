static struct sk_buff *gre_gso_segment(struct sk_buff *skb,\r\nnetdev_features_t features)\r\n{\r\nstruct sk_buff *segs = ERR_PTR(-EINVAL);\r\nnetdev_features_t enc_features;\r\nint ghl;\r\nstruct gre_base_hdr *greh;\r\nu16 mac_offset = skb->mac_header;\r\nint mac_len = skb->mac_len;\r\n__be16 protocol = skb->protocol;\r\nint tnl_hlen;\r\nbool csum;\r\nif (unlikely(skb_shinfo(skb)->gso_type &\r\n~(SKB_GSO_TCPV4 |\r\nSKB_GSO_TCPV6 |\r\nSKB_GSO_UDP |\r\nSKB_GSO_DODGY |\r\nSKB_GSO_TCP_ECN |\r\nSKB_GSO_GRE |\r\nSKB_GSO_GRE_CSUM |\r\nSKB_GSO_IPIP)))\r\ngoto out;\r\nif (!skb->encapsulation)\r\ngoto out;\r\nif (unlikely(!pskb_may_pull(skb, sizeof(*greh))))\r\ngoto out;\r\ngreh = (struct gre_base_hdr *)skb_transport_header(skb);\r\nghl = skb_inner_mac_header(skb) - skb_transport_header(skb);\r\nif (unlikely(ghl < sizeof(*greh)))\r\ngoto out;\r\ncsum = !!(greh->flags & GRE_CSUM);\r\nif (csum)\r\nskb->encap_hdr_csum = 1;\r\nskb->protocol = greh->protocol;\r\nskb->encapsulation = 0;\r\nif (unlikely(!pskb_may_pull(skb, ghl)))\r\ngoto out;\r\n__skb_pull(skb, ghl);\r\nskb_reset_mac_header(skb);\r\nskb_set_network_header(skb, skb_inner_network_offset(skb));\r\nskb->mac_len = skb_inner_network_offset(skb);\r\nenc_features = skb->dev->hw_enc_features & features;\r\nsegs = skb_mac_gso_segment(skb, enc_features);\r\nif (IS_ERR_OR_NULL(segs)) {\r\nskb_gso_error_unwind(skb, protocol, ghl, mac_offset, mac_len);\r\ngoto out;\r\n}\r\nskb = segs;\r\ntnl_hlen = skb_tnl_header_len(skb);\r\ndo {\r\n__skb_push(skb, ghl);\r\nif (csum) {\r\n__be32 *pcsum;\r\nif (skb_has_shared_frag(skb)) {\r\nint err;\r\nerr = __skb_linearize(skb);\r\nif (err) {\r\nkfree_skb_list(segs);\r\nsegs = ERR_PTR(err);\r\ngoto out;\r\n}\r\n}\r\nskb_reset_transport_header(skb);\r\ngreh = (struct gre_base_hdr *)\r\nskb_transport_header(skb);\r\npcsum = (__be32 *)(greh + 1);\r\n*pcsum = 0;\r\n*(__sum16 *)pcsum = gso_make_checksum(skb, 0);\r\n}\r\n__skb_push(skb, tnl_hlen - ghl);\r\nskb_reset_inner_headers(skb);\r\nskb->encapsulation = 1;\r\nskb_reset_mac_header(skb);\r\nskb_set_network_header(skb, mac_len);\r\nskb->mac_len = mac_len;\r\nskb->protocol = protocol;\r\n} while ((skb = skb->next));\r\nout:\r\nreturn segs;\r\n}\r\nstatic struct sk_buff **gre_gro_receive(struct sk_buff **head,\r\nstruct sk_buff *skb)\r\n{\r\nstruct sk_buff **pp = NULL;\r\nstruct sk_buff *p;\r\nconst struct gre_base_hdr *greh;\r\nunsigned int hlen, grehlen;\r\nunsigned int off;\r\nint flush = 1;\r\nstruct packet_offload *ptype;\r\n__be16 type;\r\noff = skb_gro_offset(skb);\r\nhlen = off + sizeof(*greh);\r\ngreh = skb_gro_header_fast(skb, off);\r\nif (skb_gro_header_hard(skb, hlen)) {\r\ngreh = skb_gro_header_slow(skb, hlen, off);\r\nif (unlikely(!greh))\r\ngoto out;\r\n}\r\nif ((greh->flags & ~(GRE_KEY|GRE_CSUM)) != 0)\r\ngoto out;\r\ntype = greh->protocol;\r\nrcu_read_lock();\r\nptype = gro_find_receive_by_type(type);\r\nif (!ptype)\r\ngoto out_unlock;\r\ngrehlen = GRE_HEADER_SECTION;\r\nif (greh->flags & GRE_KEY)\r\ngrehlen += GRE_HEADER_SECTION;\r\nif (greh->flags & GRE_CSUM)\r\ngrehlen += GRE_HEADER_SECTION;\r\nhlen = off + grehlen;\r\nif (skb_gro_header_hard(skb, hlen)) {\r\ngreh = skb_gro_header_slow(skb, hlen, off);\r\nif (unlikely(!greh))\r\ngoto out_unlock;\r\n}\r\nif ((greh->flags & GRE_CSUM) && !NAPI_GRO_CB(skb)->flush) {\r\nif (skb_gro_checksum_simple_validate(skb))\r\ngoto out_unlock;\r\nskb_gro_checksum_try_convert(skb, IPPROTO_GRE, 0,\r\nnull_compute_pseudo);\r\n}\r\nflush = 0;\r\nfor (p = *head; p; p = p->next) {\r\nconst struct gre_base_hdr *greh2;\r\nif (!NAPI_GRO_CB(p)->same_flow)\r\ncontinue;\r\ngreh2 = (struct gre_base_hdr *)(p->data + off);\r\nif (greh2->flags != greh->flags ||\r\ngreh2->protocol != greh->protocol) {\r\nNAPI_GRO_CB(p)->same_flow = 0;\r\ncontinue;\r\n}\r\nif (greh->flags & GRE_KEY) {\r\nif (*(__be32 *)(greh2+1) != *(__be32 *)(greh+1)) {\r\nNAPI_GRO_CB(p)->same_flow = 0;\r\ncontinue;\r\n}\r\n}\r\n}\r\nskb_gro_pull(skb, grehlen);\r\nskb_gro_postpull_rcsum(skb, greh, grehlen);\r\npp = ptype->callbacks.gro_receive(head, skb);\r\nout_unlock:\r\nrcu_read_unlock();\r\nout:\r\nNAPI_GRO_CB(skb)->flush |= flush;\r\nreturn pp;\r\n}\r\nstatic int gre_gro_complete(struct sk_buff *skb, int nhoff)\r\n{\r\nstruct gre_base_hdr *greh = (struct gre_base_hdr *)(skb->data + nhoff);\r\nstruct packet_offload *ptype;\r\nunsigned int grehlen = sizeof(*greh);\r\nint err = -ENOENT;\r\n__be16 type;\r\nskb->encapsulation = 1;\r\nskb_shinfo(skb)->gso_type = SKB_GSO_GRE;\r\ntype = greh->protocol;\r\nif (greh->flags & GRE_KEY)\r\ngrehlen += GRE_HEADER_SECTION;\r\nif (greh->flags & GRE_CSUM)\r\ngrehlen += GRE_HEADER_SECTION;\r\nrcu_read_lock();\r\nptype = gro_find_complete_by_type(type);\r\nif (ptype)\r\nerr = ptype->callbacks.gro_complete(skb, nhoff + grehlen);\r\nrcu_read_unlock();\r\nskb_set_inner_mac_header(skb, nhoff + grehlen);\r\nreturn err;\r\n}\r\nstatic int __init gre_offload_init(void)\r\n{\r\nreturn inet_add_offload(&gre_offload, IPPROTO_GRE);\r\n}
