static inline struct usb_hcd *oxu_to_hcd(struct oxu_hcd *oxu)\r\n{\r\nreturn container_of((void *) oxu, struct usb_hcd, hcd_priv);\r\n}\r\nstatic inline struct oxu_hcd *hcd_to_oxu(struct usb_hcd *hcd)\r\n{\r\nreturn (struct oxu_hcd *) (hcd->hcd_priv);\r\n}\r\nstatic int dbg_command_buf(char *buf, unsigned len,\r\nconst char *label, u32 command)\r\n{\r\nreturn scnprintf(buf, len,\r\n"%s%scommand %06x %s=%d ithresh=%d%s%s%s%s period=%s%s %s",\r\nlabel, label[0] ? " " : "", command,\r\n(command & CMD_PARK) ? "park" : "(park)",\r\nCMD_PARK_CNT(command),\r\n(command >> 16) & 0x3f,\r\n(command & CMD_LRESET) ? " LReset" : "",\r\n(command & CMD_IAAD) ? " IAAD" : "",\r\n(command & CMD_ASE) ? " Async" : "",\r\n(command & CMD_PSE) ? " Periodic" : "",\r\nfls_strings[(command >> 2) & 0x3],\r\n(command & CMD_RESET) ? " Reset" : "",\r\n(command & CMD_RUN) ? "RUN" : "HALT"\r\n);\r\n}\r\nstatic int dbg_port_buf(char *buf, unsigned len, const char *label,\r\nint port, u32 status)\r\n{\r\nchar *sig;\r\nswitch (status & (3 << 10)) {\r\ncase 0 << 10:\r\nsig = "se0";\r\nbreak;\r\ncase 1 << 10:\r\nsig = "k";\r\nbreak;\r\ncase 2 << 10:\r\nsig = "j";\r\nbreak;\r\ndefault:\r\nsig = "?";\r\nbreak;\r\n}\r\nreturn scnprintf(buf, len,\r\n"%s%sport %d status %06x%s%s sig=%s%s%s%s%s%s%s%s%s%s",\r\nlabel, label[0] ? " " : "", port, status,\r\n(status & PORT_POWER) ? " POWER" : "",\r\n(status & PORT_OWNER) ? " OWNER" : "",\r\nsig,\r\n(status & PORT_RESET) ? " RESET" : "",\r\n(status & PORT_SUSPEND) ? " SUSPEND" : "",\r\n(status & PORT_RESUME) ? " RESUME" : "",\r\n(status & PORT_OCC) ? " OCC" : "",\r\n(status & PORT_OC) ? " OC" : "",\r\n(status & PORT_PEC) ? " PEC" : "",\r\n(status & PORT_PE) ? " PE" : "",\r\n(status & PORT_CSC) ? " CSC" : "",\r\n(status & PORT_CONNECT) ? " CONNECT" : ""\r\n);\r\n}\r\nstatic inline u32 oxu_readl(void *base, u32 reg)\r\n{\r\nreturn readl(base + reg);\r\n}\r\nstatic inline void oxu_writel(void *base, u32 reg, u32 val)\r\n{\r\nwritel(val, base + reg);\r\n}\r\nstatic inline void timer_action_done(struct oxu_hcd *oxu,\r\nenum ehci_timer_action action)\r\n{\r\nclear_bit(action, &oxu->actions);\r\n}\r\nstatic inline void timer_action(struct oxu_hcd *oxu,\r\nenum ehci_timer_action action)\r\n{\r\nif (!test_and_set_bit(action, &oxu->actions)) {\r\nunsigned long t;\r\nswitch (action) {\r\ncase TIMER_IAA_WATCHDOG:\r\nt = EHCI_IAA_JIFFIES;\r\nbreak;\r\ncase TIMER_IO_WATCHDOG:\r\nt = EHCI_IO_JIFFIES;\r\nbreak;\r\ncase TIMER_ASYNC_OFF:\r\nt = EHCI_ASYNC_JIFFIES;\r\nbreak;\r\ncase TIMER_ASYNC_SHRINK:\r\ndefault:\r\nt = EHCI_SHRINK_JIFFIES;\r\nbreak;\r\n}\r\nt += jiffies;\r\nif (action != TIMER_IAA_WATCHDOG\r\n&& t > oxu->watchdog.expires\r\n&& timer_pending(&oxu->watchdog))\r\nreturn;\r\nmod_timer(&oxu->watchdog, t);\r\n}\r\n}\r\nstatic int handshake(struct oxu_hcd *oxu, void __iomem *ptr,\r\nu32 mask, u32 done, int usec)\r\n{\r\nu32 result;\r\ndo {\r\nresult = readl(ptr);\r\nif (result == ~(u32)0)\r\nreturn -ENODEV;\r\nresult &= mask;\r\nif (result == done)\r\nreturn 0;\r\nudelay(1);\r\nusec--;\r\n} while (usec > 0);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int ehci_halt(struct oxu_hcd *oxu)\r\n{\r\nu32 temp = readl(&oxu->regs->status);\r\nwritel(0, &oxu->regs->intr_enable);\r\nif ((temp & STS_HALT) != 0)\r\nreturn 0;\r\ntemp = readl(&oxu->regs->command);\r\ntemp &= ~CMD_RUN;\r\nwritel(temp, &oxu->regs->command);\r\nreturn handshake(oxu, &oxu->regs->status,\r\nSTS_HALT, STS_HALT, 16 * 125);\r\n}\r\nstatic void tdi_reset(struct oxu_hcd *oxu)\r\n{\r\nu32 __iomem *reg_ptr;\r\nu32 tmp;\r\nreg_ptr = (u32 __iomem *)(((u8 __iomem *)oxu->regs) + 0x68);\r\ntmp = readl(reg_ptr);\r\ntmp |= 0x3;\r\nwritel(tmp, reg_ptr);\r\n}\r\nstatic int ehci_reset(struct oxu_hcd *oxu)\r\n{\r\nint retval;\r\nu32 command = readl(&oxu->regs->command);\r\ncommand |= CMD_RESET;\r\ndbg_cmd(oxu, "reset", command);\r\nwritel(command, &oxu->regs->command);\r\noxu_to_hcd(oxu)->state = HC_STATE_HALT;\r\noxu->next_statechange = jiffies;\r\nretval = handshake(oxu, &oxu->regs->command,\r\nCMD_RESET, 0, 250 * 1000);\r\nif (retval)\r\nreturn retval;\r\ntdi_reset(oxu);\r\nreturn retval;\r\n}\r\nstatic void ehci_quiesce(struct oxu_hcd *oxu)\r\n{\r\nu32 temp;\r\n#ifdef DEBUG\r\nif (!HC_IS_RUNNING(oxu_to_hcd(oxu)->state))\r\nBUG();\r\n#endif\r\ntemp = readl(&oxu->regs->command) << 10;\r\ntemp &= STS_ASS | STS_PSS;\r\nif (handshake(oxu, &oxu->regs->status, STS_ASS | STS_PSS,\r\ntemp, 16 * 125) != 0) {\r\noxu_to_hcd(oxu)->state = HC_STATE_HALT;\r\nreturn;\r\n}\r\ntemp = readl(&oxu->regs->command);\r\ntemp &= ~(CMD_ASE | CMD_IAAD | CMD_PSE);\r\nwritel(temp, &oxu->regs->command);\r\nif (handshake(oxu, &oxu->regs->status, STS_ASS | STS_PSS,\r\n0, 16 * 125) != 0) {\r\noxu_to_hcd(oxu)->state = HC_STATE_HALT;\r\nreturn;\r\n}\r\n}\r\nstatic int check_reset_complete(struct oxu_hcd *oxu, int index,\r\nu32 __iomem *status_reg, int port_status)\r\n{\r\nif (!(port_status & PORT_CONNECT)) {\r\noxu->reset_done[index] = 0;\r\nreturn port_status;\r\n}\r\nif (!(port_status & PORT_PE)) {\r\noxu_dbg(oxu, "Failed to enable port %d on root hub TT\n",\r\nindex+1);\r\nreturn port_status;\r\n} else\r\noxu_dbg(oxu, "port %d high speed\n", index + 1);\r\nreturn port_status;\r\n}\r\nstatic void ehci_hub_descriptor(struct oxu_hcd *oxu,\r\nstruct usb_hub_descriptor *desc)\r\n{\r\nint ports = HCS_N_PORTS(oxu->hcs_params);\r\nu16 temp;\r\ndesc->bDescriptorType = USB_DT_HUB;\r\ndesc->bPwrOn2PwrGood = 10;\r\ndesc->bHubContrCurrent = 0;\r\ndesc->bNbrPorts = ports;\r\ntemp = 1 + (ports / 8);\r\ndesc->bDescLength = 7 + 2 * temp;\r\nmemset(&desc->u.hs.DeviceRemovable[0], 0, temp);\r\nmemset(&desc->u.hs.DeviceRemovable[temp], 0xff, temp);\r\ntemp = HUB_CHAR_INDV_PORT_OCPM;\r\nif (HCS_PPC(oxu->hcs_params))\r\ntemp |= HUB_CHAR_INDV_PORT_LPSM;\r\nelse\r\ntemp |= HUB_CHAR_NO_LPSM;\r\ndesc->wHubCharacteristics = (__force __u16)cpu_to_le16(temp);\r\n}\r\nstatic int oxu_buf_alloc(struct oxu_hcd *oxu, struct ehci_qtd *qtd, int len)\r\n{\r\nint n_blocks;\r\nint a_blocks;\r\nint i, j;\r\nif (len > BUFFER_SIZE * BUFFER_NUM) {\r\noxu_err(oxu, "buffer too big (%d)\n", len);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock(&oxu->mem_lock);\r\nn_blocks = (len + BUFFER_SIZE - 1) / BUFFER_SIZE;\r\nfor (a_blocks = 1; a_blocks < n_blocks; a_blocks <<= 1)\r\n;\r\nfor (i = 0; i < BUFFER_NUM;\r\ni += max(a_blocks, (int)oxu->db_used[i])) {\r\nfor (j = 0; j < a_blocks; j++)\r\nif (oxu->db_used[i + j])\r\nbreak;\r\nif (j != a_blocks)\r\ncontinue;\r\nqtd->buffer = (void *) &oxu->mem->db_pool[i];\r\nqtd->buffer_dma = virt_to_phys(qtd->buffer);\r\nqtd->qtd_buffer_len = BUFFER_SIZE * a_blocks;\r\noxu->db_used[i] = a_blocks;\r\nspin_unlock(&oxu->mem_lock);\r\nreturn 0;\r\n}\r\nspin_unlock(&oxu->mem_lock);\r\nreturn -ENOMEM;\r\n}\r\nstatic void oxu_buf_free(struct oxu_hcd *oxu, struct ehci_qtd *qtd)\r\n{\r\nint index;\r\nspin_lock(&oxu->mem_lock);\r\nindex = (qtd->buffer - (void *) &oxu->mem->db_pool[0])\r\n/ BUFFER_SIZE;\r\noxu->db_used[index] = 0;\r\nqtd->qtd_buffer_len = 0;\r\nqtd->buffer_dma = 0;\r\nqtd->buffer = NULL;\r\nspin_unlock(&oxu->mem_lock);\r\n}\r\nstatic inline void ehci_qtd_init(struct ehci_qtd *qtd, dma_addr_t dma)\r\n{\r\nmemset(qtd, 0, sizeof *qtd);\r\nqtd->qtd_dma = dma;\r\nqtd->hw_token = cpu_to_le32(QTD_STS_HALT);\r\nqtd->hw_next = EHCI_LIST_END;\r\nqtd->hw_alt_next = EHCI_LIST_END;\r\nINIT_LIST_HEAD(&qtd->qtd_list);\r\n}\r\nstatic inline void oxu_qtd_free(struct oxu_hcd *oxu, struct ehci_qtd *qtd)\r\n{\r\nint index;\r\nif (qtd->buffer)\r\noxu_buf_free(oxu, qtd);\r\nspin_lock(&oxu->mem_lock);\r\nindex = qtd - &oxu->mem->qtd_pool[0];\r\noxu->qtd_used[index] = 0;\r\nspin_unlock(&oxu->mem_lock);\r\n}\r\nstatic struct ehci_qtd *ehci_qtd_alloc(struct oxu_hcd *oxu)\r\n{\r\nint i;\r\nstruct ehci_qtd *qtd = NULL;\r\nspin_lock(&oxu->mem_lock);\r\nfor (i = 0; i < QTD_NUM; i++)\r\nif (!oxu->qtd_used[i])\r\nbreak;\r\nif (i < QTD_NUM) {\r\nqtd = (struct ehci_qtd *) &oxu->mem->qtd_pool[i];\r\nmemset(qtd, 0, sizeof *qtd);\r\nqtd->hw_token = cpu_to_le32(QTD_STS_HALT);\r\nqtd->hw_next = EHCI_LIST_END;\r\nqtd->hw_alt_next = EHCI_LIST_END;\r\nINIT_LIST_HEAD(&qtd->qtd_list);\r\nqtd->qtd_dma = virt_to_phys(qtd);\r\noxu->qtd_used[i] = 1;\r\n}\r\nspin_unlock(&oxu->mem_lock);\r\nreturn qtd;\r\n}\r\nstatic void oxu_qh_free(struct oxu_hcd *oxu, struct ehci_qh *qh)\r\n{\r\nint index;\r\nspin_lock(&oxu->mem_lock);\r\nindex = qh - &oxu->mem->qh_pool[0];\r\noxu->qh_used[index] = 0;\r\nspin_unlock(&oxu->mem_lock);\r\n}\r\nstatic void qh_destroy(struct kref *kref)\r\n{\r\nstruct ehci_qh *qh = container_of(kref, struct ehci_qh, kref);\r\nstruct oxu_hcd *oxu = qh->oxu;\r\nif (!list_empty(&qh->qtd_list) || qh->qh_next.ptr) {\r\noxu_dbg(oxu, "unused qh not empty!\n");\r\nBUG();\r\n}\r\nif (qh->dummy)\r\noxu_qtd_free(oxu, qh->dummy);\r\noxu_qh_free(oxu, qh);\r\n}\r\nstatic struct ehci_qh *oxu_qh_alloc(struct oxu_hcd *oxu)\r\n{\r\nint i;\r\nstruct ehci_qh *qh = NULL;\r\nspin_lock(&oxu->mem_lock);\r\nfor (i = 0; i < QHEAD_NUM; i++)\r\nif (!oxu->qh_used[i])\r\nbreak;\r\nif (i < QHEAD_NUM) {\r\nqh = (struct ehci_qh *) &oxu->mem->qh_pool[i];\r\nmemset(qh, 0, sizeof *qh);\r\nkref_init(&qh->kref);\r\nqh->oxu = oxu;\r\nqh->qh_dma = virt_to_phys(qh);\r\nINIT_LIST_HEAD(&qh->qtd_list);\r\nqh->dummy = ehci_qtd_alloc(oxu);\r\nif (qh->dummy == NULL) {\r\noxu_dbg(oxu, "no dummy td\n");\r\noxu->qh_used[i] = 0;\r\nqh = NULL;\r\ngoto unlock;\r\n}\r\noxu->qh_used[i] = 1;\r\n}\r\nunlock:\r\nspin_unlock(&oxu->mem_lock);\r\nreturn qh;\r\n}\r\nstatic inline struct ehci_qh *qh_get(struct ehci_qh *qh)\r\n{\r\nkref_get(&qh->kref);\r\nreturn qh;\r\n}\r\nstatic inline void qh_put(struct ehci_qh *qh)\r\n{\r\nkref_put(&qh->kref, qh_destroy);\r\n}\r\nstatic void oxu_murb_free(struct oxu_hcd *oxu, struct oxu_murb *murb)\r\n{\r\nint index;\r\nspin_lock(&oxu->mem_lock);\r\nindex = murb - &oxu->murb_pool[0];\r\noxu->murb_used[index] = 0;\r\nspin_unlock(&oxu->mem_lock);\r\n}\r\nstatic struct oxu_murb *oxu_murb_alloc(struct oxu_hcd *oxu)\r\n{\r\nint i;\r\nstruct oxu_murb *murb = NULL;\r\nspin_lock(&oxu->mem_lock);\r\nfor (i = 0; i < MURB_NUM; i++)\r\nif (!oxu->murb_used[i])\r\nbreak;\r\nif (i < MURB_NUM) {\r\nmurb = &(oxu->murb_pool)[i];\r\noxu->murb_used[i] = 1;\r\n}\r\nspin_unlock(&oxu->mem_lock);\r\nreturn murb;\r\n}\r\nstatic void ehci_mem_cleanup(struct oxu_hcd *oxu)\r\n{\r\nkfree(oxu->murb_pool);\r\noxu->murb_pool = NULL;\r\nif (oxu->async)\r\nqh_put(oxu->async);\r\noxu->async = NULL;\r\ndel_timer(&oxu->urb_timer);\r\noxu->periodic = NULL;\r\nkfree(oxu->pshadow);\r\noxu->pshadow = NULL;\r\n}\r\nstatic int ehci_mem_init(struct oxu_hcd *oxu, gfp_t flags)\r\n{\r\nint i;\r\nfor (i = 0; i < oxu->periodic_size; i++)\r\noxu->mem->frame_list[i] = EHCI_LIST_END;\r\nfor (i = 0; i < QHEAD_NUM; i++)\r\noxu->qh_used[i] = 0;\r\nfor (i = 0; i < QTD_NUM; i++)\r\noxu->qtd_used[i] = 0;\r\noxu->murb_pool = kcalloc(MURB_NUM, sizeof(struct oxu_murb), flags);\r\nif (!oxu->murb_pool)\r\ngoto fail;\r\nfor (i = 0; i < MURB_NUM; i++)\r\noxu->murb_used[i] = 0;\r\noxu->async = oxu_qh_alloc(oxu);\r\nif (!oxu->async)\r\ngoto fail;\r\noxu->periodic = (__le32 *) &oxu->mem->frame_list;\r\noxu->periodic_dma = virt_to_phys(oxu->periodic);\r\nfor (i = 0; i < oxu->periodic_size; i++)\r\noxu->periodic[i] = EHCI_LIST_END;\r\noxu->pshadow = kcalloc(oxu->periodic_size, sizeof(void *), flags);\r\nif (oxu->pshadow != NULL)\r\nreturn 0;\r\nfail:\r\noxu_dbg(oxu, "couldn't init memory\n");\r\nehci_mem_cleanup(oxu);\r\nreturn -ENOMEM;\r\n}\r\nstatic int qtd_fill(struct ehci_qtd *qtd, dma_addr_t buf, size_t len,\r\nint token, int maxpacket)\r\n{\r\nint i, count;\r\nu64 addr = buf;\r\nqtd->hw_buf[0] = cpu_to_le32((u32)addr);\r\nqtd->hw_buf_hi[0] = cpu_to_le32((u32)(addr >> 32));\r\ncount = 0x1000 - (buf & 0x0fff);\r\nif (likely(len < count))\r\ncount = len;\r\nelse {\r\nbuf += 0x1000;\r\nbuf &= ~0x0fff;\r\nfor (i = 1; count < len && i < 5; i++) {\r\naddr = buf;\r\nqtd->hw_buf[i] = cpu_to_le32((u32)addr);\r\nqtd->hw_buf_hi[i] = cpu_to_le32((u32)(addr >> 32));\r\nbuf += 0x1000;\r\nif ((count + 0x1000) < len)\r\ncount += 0x1000;\r\nelse\r\ncount = len;\r\n}\r\nif (count != len)\r\ncount -= (count % maxpacket);\r\n}\r\nqtd->hw_token = cpu_to_le32((count << 16) | token);\r\nqtd->length = count;\r\nreturn count;\r\n}\r\nstatic inline void qh_update(struct oxu_hcd *oxu,\r\nstruct ehci_qh *qh, struct ehci_qtd *qtd)\r\n{\r\nBUG_ON(qh->qh_state != QH_STATE_IDLE);\r\nqh->hw_qtd_next = QTD_NEXT(qtd->qtd_dma);\r\nqh->hw_alt_next = EHCI_LIST_END;\r\nif (!(qh->hw_info1 & cpu_to_le32(1 << 14))) {\r\nunsigned is_out, epnum;\r\nis_out = !(qtd->hw_token & cpu_to_le32(1 << 8));\r\nepnum = (le32_to_cpup(&qh->hw_info1) >> 8) & 0x0f;\r\nif (unlikely(!usb_gettoggle(qh->dev, epnum, is_out))) {\r\nqh->hw_token &= ~cpu_to_le32(QTD_TOGGLE);\r\nusb_settoggle(qh->dev, epnum, is_out, 1);\r\n}\r\n}\r\nwmb();\r\nqh->hw_token &= cpu_to_le32(QTD_TOGGLE | QTD_STS_PING);\r\n}\r\nstatic void qh_refresh(struct oxu_hcd *oxu, struct ehci_qh *qh)\r\n{\r\nstruct ehci_qtd *qtd;\r\nif (list_empty(&qh->qtd_list))\r\nqtd = qh->dummy;\r\nelse {\r\nqtd = list_entry(qh->qtd_list.next,\r\nstruct ehci_qtd, qtd_list);\r\nif (cpu_to_le32(qtd->qtd_dma) == qh->hw_current)\r\nqtd = NULL;\r\n}\r\nif (qtd)\r\nqh_update(oxu, qh, qtd);\r\n}\r\nstatic void qtd_copy_status(struct oxu_hcd *oxu, struct urb *urb,\r\nsize_t length, u32 token)\r\n{\r\nif (likely(QTD_PID(token) != 2))\r\nurb->actual_length += length - QTD_LENGTH(token);\r\nif (unlikely(urb->status != -EINPROGRESS))\r\nreturn;\r\nif (unlikely(IS_SHORT_READ(token)))\r\nurb->status = -EREMOTEIO;\r\nif (token & QTD_STS_HALT) {\r\nif (token & QTD_STS_BABBLE) {\r\nurb->status = -EOVERFLOW;\r\n} else if (token & QTD_STS_MMF) {\r\nurb->status = -EPROTO;\r\n} else if (token & QTD_STS_DBE) {\r\nurb->status = (QTD_PID(token) == 1)\r\n? -ENOSR\r\n: -ECOMM;\r\n} else if (token & QTD_STS_XACT) {\r\nif (QTD_CERR(token))\r\nurb->status = -EPIPE;\r\nelse {\r\noxu_dbg(oxu, "devpath %s ep%d%s 3strikes\n",\r\nurb->dev->devpath,\r\nusb_pipeendpoint(urb->pipe),\r\nusb_pipein(urb->pipe) ? "in" : "out");\r\nurb->status = -EPROTO;\r\n}\r\n} else if (QTD_CERR(token))\r\nurb->status = -EPIPE;\r\nelse\r\nurb->status = -EPROTO;\r\noxu_vdbg(oxu, "dev%d ep%d%s qtd token %08x --> status %d\n",\r\nusb_pipedevice(urb->pipe),\r\nusb_pipeendpoint(urb->pipe),\r\nusb_pipein(urb->pipe) ? "in" : "out",\r\ntoken, urb->status);\r\n}\r\n}\r\nstatic void ehci_urb_done(struct oxu_hcd *oxu, struct urb *urb)\r\n__releases(oxu->lock)\r\n__acquires(oxu->lock)\r\n{\r\nif (likely(urb->hcpriv != NULL)) {\r\nstruct ehci_qh *qh = (struct ehci_qh *) urb->hcpriv;\r\nif ((qh->hw_info2 & cpu_to_le32(QH_SMASK)) != 0) {\r\noxu_to_hcd(oxu)->self.bandwidth_int_reqs--;\r\n}\r\nqh_put(qh);\r\n}\r\nurb->hcpriv = NULL;\r\nswitch (urb->status) {\r\ncase -EINPROGRESS:\r\nurb->status = 0;\r\ndefault:\r\nbreak;\r\ncase -EREMOTEIO:\r\nif (!(urb->transfer_flags & URB_SHORT_NOT_OK))\r\nurb->status = 0;\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\nbreak;\r\n}\r\n#ifdef OXU_URB_TRACE\r\noxu_dbg(oxu, "%s %s urb %p ep%d%s status %d len %d/%d\n",\r\n__func__, urb->dev->devpath, urb,\r\nusb_pipeendpoint(urb->pipe),\r\nusb_pipein(urb->pipe) ? "in" : "out",\r\nurb->status,\r\nurb->actual_length, urb->transfer_buffer_length);\r\n#endif\r\nspin_unlock(&oxu->lock);\r\nusb_hcd_giveback_urb(oxu_to_hcd(oxu), urb, urb->status);\r\nspin_lock(&oxu->lock);\r\n}\r\nstatic unsigned qh_completions(struct oxu_hcd *oxu, struct ehci_qh *qh)\r\n{\r\nstruct ehci_qtd *last = NULL, *end = qh->dummy;\r\nstruct list_head *entry, *tmp;\r\nint stopped;\r\nunsigned count = 0;\r\nint do_status = 0;\r\nu8 state;\r\nstruct oxu_murb *murb = NULL;\r\nif (unlikely(list_empty(&qh->qtd_list)))\r\nreturn count;\r\nstate = qh->qh_state;\r\nqh->qh_state = QH_STATE_COMPLETING;\r\nstopped = (state == QH_STATE_IDLE);\r\nlist_for_each_safe(entry, tmp, &qh->qtd_list) {\r\nstruct ehci_qtd *qtd;\r\nstruct urb *urb;\r\nu32 token = 0;\r\nqtd = list_entry(entry, struct ehci_qtd, qtd_list);\r\nurb = qtd->urb;\r\nif (last) {\r\nif (likely(last->urb != urb)) {\r\nif (last->urb->complete == NULL) {\r\nmurb = (struct oxu_murb *) last->urb;\r\nlast->urb = murb->main;\r\nif (murb->last) {\r\nehci_urb_done(oxu, last->urb);\r\ncount++;\r\n}\r\noxu_murb_free(oxu, murb);\r\n} else {\r\nehci_urb_done(oxu, last->urb);\r\ncount++;\r\n}\r\n}\r\noxu_qtd_free(oxu, last);\r\nlast = NULL;\r\n}\r\nif (qtd == end)\r\nbreak;\r\nrmb();\r\ntoken = le32_to_cpu(qtd->hw_token);\r\nif ((token & QTD_STS_ACTIVE) == 0) {\r\nif ((token & QTD_STS_HALT) != 0) {\r\nstopped = 1;\r\n} else if (IS_SHORT_READ(token) &&\r\n!(qtd->hw_alt_next & EHCI_LIST_END)) {\r\nstopped = 1;\r\ngoto halt;\r\n}\r\n} else if (likely(!stopped &&\r\nHC_IS_RUNNING(oxu_to_hcd(oxu)->state))) {\r\nbreak;\r\n} else {\r\nstopped = 1;\r\nif (unlikely(!HC_IS_RUNNING(oxu_to_hcd(oxu)->state)))\r\nurb->status = -ESHUTDOWN;\r\nif (likely(urb->status == -EINPROGRESS))\r\ncontinue;\r\nif (unlikely(do_status != 0)\r\n&& QTD_PID(token) == 0 ) {\r\ndo_status = 0;\r\ncontinue;\r\n}\r\nif (state == QH_STATE_IDLE\r\n&& cpu_to_le32(qtd->qtd_dma)\r\n== qh->hw_current)\r\ntoken = le32_to_cpu(qh->hw_token);\r\nif ((HALT_BIT & qh->hw_token) == 0) {\r\nhalt:\r\nqh->hw_token |= HALT_BIT;\r\nwmb();\r\n}\r\n}\r\nqtd_copy_status(oxu, urb->complete ?\r\nurb : ((struct oxu_murb *) urb)->main,\r\nqtd->length, token);\r\nif ((usb_pipein(qtd->urb->pipe)) &&\r\n(NULL != qtd->transfer_buffer))\r\nmemcpy(qtd->transfer_buffer, qtd->buffer, qtd->length);\r\ndo_status = (urb->status == -EREMOTEIO)\r\n&& usb_pipecontrol(urb->pipe);\r\nif (stopped && qtd->qtd_list.prev != &qh->qtd_list) {\r\nlast = list_entry(qtd->qtd_list.prev,\r\nstruct ehci_qtd, qtd_list);\r\nlast->hw_next = qtd->hw_next;\r\n}\r\nlist_del(&qtd->qtd_list);\r\nlast = qtd;\r\n}\r\nif (likely(last != NULL)) {\r\nif (last->urb->complete == NULL) {\r\nmurb = (struct oxu_murb *) last->urb;\r\nlast->urb = murb->main;\r\nif (murb->last) {\r\nehci_urb_done(oxu, last->urb);\r\ncount++;\r\n}\r\noxu_murb_free(oxu, murb);\r\n} else {\r\nehci_urb_done(oxu, last->urb);\r\ncount++;\r\n}\r\noxu_qtd_free(oxu, last);\r\n}\r\nqh->qh_state = state;\r\nif (stopped != 0 || qh->hw_qtd_next == EHCI_LIST_END) {\r\nswitch (state) {\r\ncase QH_STATE_IDLE:\r\nqh_refresh(oxu, qh);\r\nbreak;\r\ncase QH_STATE_LINKED:\r\nif ((cpu_to_le32(QH_SMASK)\r\n& qh->hw_info2) != 0) {\r\nintr_deschedule(oxu, qh);\r\n(void) qh_schedule(oxu, qh);\r\n} else\r\nunlink_async(oxu, qh);\r\nbreak;\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic void qtd_list_free(struct oxu_hcd *oxu,\r\nstruct urb *urb, struct list_head *qtd_list)\r\n{\r\nstruct list_head *entry, *temp;\r\nlist_for_each_safe(entry, temp, qtd_list) {\r\nstruct ehci_qtd *qtd;\r\nqtd = list_entry(entry, struct ehci_qtd, qtd_list);\r\nlist_del(&qtd->qtd_list);\r\noxu_qtd_free(oxu, qtd);\r\n}\r\n}\r\nstatic struct list_head *qh_urb_transaction(struct oxu_hcd *oxu,\r\nstruct urb *urb,\r\nstruct list_head *head,\r\ngfp_t flags)\r\n{\r\nstruct ehci_qtd *qtd, *qtd_prev;\r\ndma_addr_t buf;\r\nint len, maxpacket;\r\nint is_input;\r\nu32 token;\r\nvoid *transfer_buf = NULL;\r\nint ret;\r\nqtd = ehci_qtd_alloc(oxu);\r\nif (unlikely(!qtd))\r\nreturn NULL;\r\nlist_add_tail(&qtd->qtd_list, head);\r\nqtd->urb = urb;\r\ntoken = QTD_STS_ACTIVE;\r\ntoken |= (EHCI_TUNE_CERR << 10);\r\nlen = urb->transfer_buffer_length;\r\nis_input = usb_pipein(urb->pipe);\r\nif (!urb->transfer_buffer && urb->transfer_buffer_length && is_input)\r\nurb->transfer_buffer = phys_to_virt(urb->transfer_dma);\r\nif (usb_pipecontrol(urb->pipe)) {\r\nret = oxu_buf_alloc(oxu, qtd, sizeof(struct usb_ctrlrequest));\r\nif (ret)\r\ngoto cleanup;\r\nqtd_fill(qtd, qtd->buffer_dma, sizeof(struct usb_ctrlrequest),\r\ntoken | (2 << 8), 8);\r\nmemcpy(qtd->buffer, qtd->urb->setup_packet,\r\nsizeof(struct usb_ctrlrequest));\r\ntoken ^= QTD_TOGGLE;\r\nqtd_prev = qtd;\r\nqtd = ehci_qtd_alloc(oxu);\r\nif (unlikely(!qtd))\r\ngoto cleanup;\r\nqtd->urb = urb;\r\nqtd_prev->hw_next = QTD_NEXT(qtd->qtd_dma);\r\nlist_add_tail(&qtd->qtd_list, head);\r\nif (len == 0)\r\ntoken |= (1 << 8);\r\n}\r\nret = oxu_buf_alloc(oxu, qtd, len);\r\nif (ret)\r\ngoto cleanup;\r\nbuf = qtd->buffer_dma;\r\ntransfer_buf = urb->transfer_buffer;\r\nif (!is_input)\r\nmemcpy(qtd->buffer, qtd->urb->transfer_buffer, len);\r\nif (is_input)\r\ntoken |= (1 << 8);\r\nmaxpacket = max_packet(usb_maxpacket(urb->dev, urb->pipe, !is_input));\r\nfor (;;) {\r\nint this_qtd_len;\r\nthis_qtd_len = qtd_fill(qtd, buf, len, token, maxpacket);\r\nqtd->transfer_buffer = transfer_buf;\r\nlen -= this_qtd_len;\r\nbuf += this_qtd_len;\r\ntransfer_buf += this_qtd_len;\r\nif (is_input)\r\nqtd->hw_alt_next = oxu->async->hw_alt_next;\r\nif ((maxpacket & (this_qtd_len + (maxpacket - 1))) == 0)\r\ntoken ^= QTD_TOGGLE;\r\nif (likely(len <= 0))\r\nbreak;\r\nqtd_prev = qtd;\r\nqtd = ehci_qtd_alloc(oxu);\r\nif (unlikely(!qtd))\r\ngoto cleanup;\r\nif (likely(len > 0)) {\r\nret = oxu_buf_alloc(oxu, qtd, len);\r\nif (ret)\r\ngoto cleanup;\r\n}\r\nqtd->urb = urb;\r\nqtd_prev->hw_next = QTD_NEXT(qtd->qtd_dma);\r\nlist_add_tail(&qtd->qtd_list, head);\r\n}\r\nif (likely((urb->transfer_flags & URB_SHORT_NOT_OK) == 0\r\n|| usb_pipecontrol(urb->pipe)))\r\nqtd->hw_alt_next = EHCI_LIST_END;\r\nif (likely(urb->transfer_buffer_length != 0)) {\r\nint one_more = 0;\r\nif (usb_pipecontrol(urb->pipe)) {\r\none_more = 1;\r\ntoken ^= 0x0100;\r\ntoken |= QTD_TOGGLE;\r\n} else if (usb_pipebulk(urb->pipe)\r\n&& (urb->transfer_flags & URB_ZERO_PACKET)\r\n&& !(urb->transfer_buffer_length % maxpacket)) {\r\none_more = 1;\r\n}\r\nif (one_more) {\r\nqtd_prev = qtd;\r\nqtd = ehci_qtd_alloc(oxu);\r\nif (unlikely(!qtd))\r\ngoto cleanup;\r\nqtd->urb = urb;\r\nqtd_prev->hw_next = QTD_NEXT(qtd->qtd_dma);\r\nlist_add_tail(&qtd->qtd_list, head);\r\nqtd_fill(qtd, 0, 0, token, 0);\r\n}\r\n}\r\nqtd->hw_token |= cpu_to_le32(QTD_IOC);\r\nreturn head;\r\ncleanup:\r\nqtd_list_free(oxu, urb, head);\r\nreturn NULL;\r\n}\r\nstatic struct ehci_qh *qh_make(struct oxu_hcd *oxu,\r\nstruct urb *urb, gfp_t flags)\r\n{\r\nstruct ehci_qh *qh = oxu_qh_alloc(oxu);\r\nu32 info1 = 0, info2 = 0;\r\nint is_input, type;\r\nint maxp = 0;\r\nif (!qh)\r\nreturn qh;\r\ninfo1 |= usb_pipeendpoint(urb->pipe) << 8;\r\ninfo1 |= usb_pipedevice(urb->pipe) << 0;\r\nis_input = usb_pipein(urb->pipe);\r\ntype = usb_pipetype(urb->pipe);\r\nmaxp = usb_maxpacket(urb->dev, urb->pipe, !is_input);\r\nif (type == PIPE_INTERRUPT) {\r\nqh->usecs = NS_TO_US(usb_calc_bus_time(USB_SPEED_HIGH,\r\nis_input, 0,\r\nhb_mult(maxp) * max_packet(maxp)));\r\nqh->start = NO_FRAME;\r\nif (urb->dev->speed == USB_SPEED_HIGH) {\r\nqh->c_usecs = 0;\r\nqh->gap_uf = 0;\r\nqh->period = urb->interval >> 3;\r\nif (qh->period == 0 && urb->interval != 1) {\r\noxu_dbg(oxu, "intr period %d uframes, NYET!\n",\r\nurb->interval);\r\ngoto done;\r\n}\r\n} else {\r\nstruct usb_tt *tt = urb->dev->tt;\r\nint think_time;\r\nqh->gap_uf = 1 + usb_calc_bus_time(urb->dev->speed,\r\nis_input, 0, maxp) / (125 * 1000);\r\nif (is_input) {\r\nqh->c_usecs = qh->usecs + HS_USECS(0);\r\nqh->usecs = HS_USECS(1);\r\n} else {\r\nqh->usecs += HS_USECS(1);\r\nqh->c_usecs = HS_USECS(0);\r\n}\r\nthink_time = tt ? tt->think_time : 0;\r\nqh->tt_usecs = NS_TO_US(think_time +\r\nusb_calc_bus_time(urb->dev->speed,\r\nis_input, 0, max_packet(maxp)));\r\nqh->period = urb->interval;\r\n}\r\n}\r\nqh->dev = urb->dev;\r\nswitch (urb->dev->speed) {\r\ncase USB_SPEED_LOW:\r\ninfo1 |= (1 << 12);\r\ncase USB_SPEED_FULL:\r\nif (type != PIPE_INTERRUPT)\r\ninfo1 |= (EHCI_TUNE_RL_TT << 28);\r\nif (type == PIPE_CONTROL) {\r\ninfo1 |= (1 << 27);\r\ninfo1 |= 1 << 14;\r\n}\r\ninfo1 |= maxp << 16;\r\ninfo2 |= (EHCI_TUNE_MULT_TT << 30);\r\ninfo2 |= urb->dev->ttport << 23;\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\ninfo1 |= (2 << 12);\r\nif (type == PIPE_CONTROL) {\r\ninfo1 |= (EHCI_TUNE_RL_HS << 28);\r\ninfo1 |= 64 << 16;\r\ninfo1 |= 1 << 14;\r\ninfo2 |= (EHCI_TUNE_MULT_HS << 30);\r\n} else if (type == PIPE_BULK) {\r\ninfo1 |= (EHCI_TUNE_RL_HS << 28);\r\ninfo1 |= 512 << 16;\r\ninfo2 |= (EHCI_TUNE_MULT_HS << 30);\r\n} else {\r\ninfo1 |= max_packet(maxp) << 16;\r\ninfo2 |= hb_mult(maxp) << 30;\r\n}\r\nbreak;\r\ndefault:\r\noxu_dbg(oxu, "bogus dev %p speed %d\n", urb->dev, urb->dev->speed);\r\ndone:\r\nqh_put(qh);\r\nreturn NULL;\r\n}\r\nqh->qh_state = QH_STATE_IDLE;\r\nqh->hw_info1 = cpu_to_le32(info1);\r\nqh->hw_info2 = cpu_to_le32(info2);\r\nusb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe), !is_input, 1);\r\nqh_refresh(oxu, qh);\r\nreturn qh;\r\n}\r\nstatic void qh_link_async(struct oxu_hcd *oxu, struct ehci_qh *qh)\r\n{\r\n__le32 dma = QH_NEXT(qh->qh_dma);\r\nstruct ehci_qh *head;\r\nhead = oxu->async;\r\ntimer_action_done(oxu, TIMER_ASYNC_OFF);\r\nif (!head->qh_next.qh) {\r\nu32 cmd = readl(&oxu->regs->command);\r\nif (!(cmd & CMD_ASE)) {\r\n(void)handshake(oxu, &oxu->regs->status,\r\nSTS_ASS, 0, 150);\r\ncmd |= CMD_ASE | CMD_RUN;\r\nwritel(cmd, &oxu->regs->command);\r\noxu_to_hcd(oxu)->state = HC_STATE_RUNNING;\r\n}\r\n}\r\nif (qh->qh_state == QH_STATE_IDLE)\r\nqh_refresh(oxu, qh);\r\nqh->qh_next = head->qh_next;\r\nqh->hw_next = head->hw_next;\r\nwmb();\r\nhead->qh_next.qh = qh;\r\nhead->hw_next = dma;\r\nqh->qh_state = QH_STATE_LINKED;\r\n}\r\nstatic struct ehci_qh *qh_append_tds(struct oxu_hcd *oxu,\r\nstruct urb *urb, struct list_head *qtd_list,\r\nint epnum, void **ptr)\r\n{\r\nstruct ehci_qh *qh = NULL;\r\nqh = (struct ehci_qh *) *ptr;\r\nif (unlikely(qh == NULL)) {\r\nqh = qh_make(oxu, urb, GFP_ATOMIC);\r\n*ptr = qh;\r\n}\r\nif (likely(qh != NULL)) {\r\nstruct ehci_qtd *qtd;\r\nif (unlikely(list_empty(qtd_list)))\r\nqtd = NULL;\r\nelse\r\nqtd = list_entry(qtd_list->next, struct ehci_qtd,\r\nqtd_list);\r\nif (unlikely(epnum == 0)) {\r\nif (usb_pipedevice(urb->pipe) == 0)\r\nqh->hw_info1 &= ~QH_ADDR_MASK;\r\n}\r\nif (likely(qtd != NULL)) {\r\nstruct ehci_qtd *dummy;\r\ndma_addr_t dma;\r\n__le32 token;\r\ntoken = qtd->hw_token;\r\nqtd->hw_token = HALT_BIT;\r\nwmb();\r\ndummy = qh->dummy;\r\ndma = dummy->qtd_dma;\r\n*dummy = *qtd;\r\ndummy->qtd_dma = dma;\r\nlist_del(&qtd->qtd_list);\r\nlist_add(&dummy->qtd_list, qtd_list);\r\nlist_splice(qtd_list, qh->qtd_list.prev);\r\nehci_qtd_init(qtd, qtd->qtd_dma);\r\nqh->dummy = qtd;\r\ndma = qtd->qtd_dma;\r\nqtd = list_entry(qh->qtd_list.prev,\r\nstruct ehci_qtd, qtd_list);\r\nqtd->hw_next = QTD_NEXT(dma);\r\ndummy->hw_token = (token & ~(0x80));\r\nwmb();\r\ndummy->hw_token = token;\r\nurb->hcpriv = qh_get(qh);\r\n}\r\n}\r\nreturn qh;\r\n}\r\nstatic int submit_async(struct oxu_hcd *oxu, struct urb *urb,\r\nstruct list_head *qtd_list, gfp_t mem_flags)\r\n{\r\nstruct ehci_qtd *qtd;\r\nint epnum;\r\nunsigned long flags;\r\nstruct ehci_qh *qh = NULL;\r\nint rc = 0;\r\nqtd = list_entry(qtd_list->next, struct ehci_qtd, qtd_list);\r\nepnum = urb->ep->desc.bEndpointAddress;\r\n#ifdef OXU_URB_TRACE\r\noxu_dbg(oxu, "%s %s urb %p ep%d%s len %d, qtd %p [qh %p]\n",\r\n__func__, urb->dev->devpath, urb,\r\nepnum & 0x0f, (epnum & USB_DIR_IN) ? "in" : "out",\r\nurb->transfer_buffer_length,\r\nqtd, urb->ep->hcpriv);\r\n#endif\r\nspin_lock_irqsave(&oxu->lock, flags);\r\nif (unlikely(!HCD_HW_ACCESSIBLE(oxu_to_hcd(oxu)))) {\r\nrc = -ESHUTDOWN;\r\ngoto done;\r\n}\r\nqh = qh_append_tds(oxu, urb, qtd_list, epnum, &urb->ep->hcpriv);\r\nif (unlikely(qh == NULL)) {\r\nrc = -ENOMEM;\r\ngoto done;\r\n}\r\nif (likely(qh->qh_state == QH_STATE_IDLE))\r\nqh_link_async(oxu, qh_get(qh));\r\ndone:\r\nspin_unlock_irqrestore(&oxu->lock, flags);\r\nif (unlikely(qh == NULL))\r\nqtd_list_free(oxu, urb, qtd_list);\r\nreturn rc;\r\n}\r\nstatic void end_unlink_async(struct oxu_hcd *oxu)\r\n{\r\nstruct ehci_qh *qh = oxu->reclaim;\r\nstruct ehci_qh *next;\r\ntimer_action_done(oxu, TIMER_IAA_WATCHDOG);\r\nqh->qh_state = QH_STATE_IDLE;\r\nqh->qh_next.qh = NULL;\r\nqh_put(qh);\r\nnext = qh->reclaim;\r\noxu->reclaim = next;\r\noxu->reclaim_ready = 0;\r\nqh->reclaim = NULL;\r\nqh_completions(oxu, qh);\r\nif (!list_empty(&qh->qtd_list)\r\n&& HC_IS_RUNNING(oxu_to_hcd(oxu)->state))\r\nqh_link_async(oxu, qh);\r\nelse {\r\nqh_put(qh);\r\nif (HC_IS_RUNNING(oxu_to_hcd(oxu)->state)\r\n&& oxu->async->qh_next.qh == NULL)\r\ntimer_action(oxu, TIMER_ASYNC_OFF);\r\n}\r\nif (next) {\r\noxu->reclaim = NULL;\r\nstart_unlink_async(oxu, next);\r\n}\r\n}\r\nstatic void start_unlink_async(struct oxu_hcd *oxu, struct ehci_qh *qh)\r\n{\r\nint cmd = readl(&oxu->regs->command);\r\nstruct ehci_qh *prev;\r\n#ifdef DEBUG\r\nassert_spin_locked(&oxu->lock);\r\nif (oxu->reclaim || (qh->qh_state != QH_STATE_LINKED\r\n&& qh->qh_state != QH_STATE_UNLINK_WAIT))\r\nBUG();\r\n#endif\r\nif (unlikely(qh == oxu->async)) {\r\nif (oxu_to_hcd(oxu)->state != HC_STATE_HALT\r\n&& !oxu->reclaim) {\r\nwritel(cmd & ~CMD_ASE, &oxu->regs->command);\r\nwmb();\r\ntimer_action_done(oxu, TIMER_ASYNC_OFF);\r\n}\r\nreturn;\r\n}\r\nqh->qh_state = QH_STATE_UNLINK;\r\noxu->reclaim = qh = qh_get(qh);\r\nprev = oxu->async;\r\nwhile (prev->qh_next.qh != qh)\r\nprev = prev->qh_next.qh;\r\nprev->hw_next = qh->hw_next;\r\nprev->qh_next = qh->qh_next;\r\nwmb();\r\nif (unlikely(oxu_to_hcd(oxu)->state == HC_STATE_HALT)) {\r\nend_unlink_async(oxu);\r\nreturn;\r\n}\r\noxu->reclaim_ready = 0;\r\ncmd |= CMD_IAAD;\r\nwritel(cmd, &oxu->regs->command);\r\n(void) readl(&oxu->regs->command);\r\ntimer_action(oxu, TIMER_IAA_WATCHDOG);\r\n}\r\nstatic void scan_async(struct oxu_hcd *oxu)\r\n{\r\nstruct ehci_qh *qh;\r\nenum ehci_timer_action action = TIMER_IO_WATCHDOG;\r\nif (!++(oxu->stamp))\r\noxu->stamp++;\r\ntimer_action_done(oxu, TIMER_ASYNC_SHRINK);\r\nrescan:\r\nqh = oxu->async->qh_next.qh;\r\nif (likely(qh != NULL)) {\r\ndo {\r\nif (!list_empty(&qh->qtd_list)\r\n&& qh->stamp != oxu->stamp) {\r\nint temp;\r\nqh = qh_get(qh);\r\nqh->stamp = oxu->stamp;\r\ntemp = qh_completions(oxu, qh);\r\nqh_put(qh);\r\nif (temp != 0)\r\ngoto rescan;\r\n}\r\nif (list_empty(&qh->qtd_list)) {\r\nif (qh->stamp == oxu->stamp)\r\naction = TIMER_ASYNC_SHRINK;\r\nelse if (!oxu->reclaim\r\n&& qh->qh_state == QH_STATE_LINKED)\r\nstart_unlink_async(oxu, qh);\r\n}\r\nqh = qh->qh_next.qh;\r\n} while (qh);\r\n}\r\nif (action == TIMER_ASYNC_SHRINK)\r\ntimer_action(oxu, TIMER_ASYNC_SHRINK);\r\n}\r\nstatic union ehci_shadow *periodic_next_shadow(union ehci_shadow *periodic,\r\n__le32 tag)\r\n{\r\nswitch (tag) {\r\ndefault:\r\ncase Q_TYPE_QH:\r\nreturn &periodic->qh->qh_next;\r\n}\r\n}\r\nstatic void periodic_unlink(struct oxu_hcd *oxu, unsigned frame, void *ptr)\r\n{\r\nunion ehci_shadow *prev_p = &oxu->pshadow[frame];\r\n__le32 *hw_p = &oxu->periodic[frame];\r\nunion ehci_shadow here = *prev_p;\r\nwhile (here.ptr && here.ptr != ptr) {\r\nprev_p = periodic_next_shadow(prev_p, Q_NEXT_TYPE(*hw_p));\r\nhw_p = here.hw_next;\r\nhere = *prev_p;\r\n}\r\nif (!here.ptr)\r\nreturn;\r\n*prev_p = *periodic_next_shadow(&here, Q_NEXT_TYPE(*hw_p));\r\n*hw_p = *here.hw_next;\r\n}\r\nstatic unsigned short periodic_usecs(struct oxu_hcd *oxu,\r\nunsigned frame, unsigned uframe)\r\n{\r\n__le32 *hw_p = &oxu->periodic[frame];\r\nunion ehci_shadow *q = &oxu->pshadow[frame];\r\nunsigned usecs = 0;\r\nwhile (q->ptr) {\r\nswitch (Q_NEXT_TYPE(*hw_p)) {\r\ncase Q_TYPE_QH:\r\ndefault:\r\nif (q->qh->hw_info2 & cpu_to_le32(1 << uframe))\r\nusecs += q->qh->usecs;\r\nif (q->qh->hw_info2 & cpu_to_le32(1 << (8 + uframe)))\r\nusecs += q->qh->c_usecs;\r\nhw_p = &q->qh->hw_next;\r\nq = &q->qh->qh_next;\r\nbreak;\r\n}\r\n}\r\n#ifdef DEBUG\r\nif (usecs > 100)\r\noxu_err(oxu, "uframe %d sched overrun: %d usecs\n",\r\nframe * 8 + uframe, usecs);\r\n#endif\r\nreturn usecs;\r\n}\r\nstatic int enable_periodic(struct oxu_hcd *oxu)\r\n{\r\nu32 cmd;\r\nint status;\r\nstatus = handshake(oxu, &oxu->regs->status, STS_PSS, 0, 9 * 125);\r\nif (status != 0) {\r\noxu_to_hcd(oxu)->state = HC_STATE_HALT;\r\nusb_hc_died(oxu_to_hcd(oxu));\r\nreturn status;\r\n}\r\ncmd = readl(&oxu->regs->command) | CMD_PSE;\r\nwritel(cmd, &oxu->regs->command);\r\noxu_to_hcd(oxu)->state = HC_STATE_RUNNING;\r\noxu->next_uframe = readl(&oxu->regs->frame_index)\r\n% (oxu->periodic_size << 3);\r\nreturn 0;\r\n}\r\nstatic int disable_periodic(struct oxu_hcd *oxu)\r\n{\r\nu32 cmd;\r\nint status;\r\nstatus = handshake(oxu, &oxu->regs->status, STS_PSS, STS_PSS, 9 * 125);\r\nif (status != 0) {\r\noxu_to_hcd(oxu)->state = HC_STATE_HALT;\r\nusb_hc_died(oxu_to_hcd(oxu));\r\nreturn status;\r\n}\r\ncmd = readl(&oxu->regs->command) & ~CMD_PSE;\r\nwritel(cmd, &oxu->regs->command);\r\noxu->next_uframe = -1;\r\nreturn 0;\r\n}\r\nstatic int qh_link_periodic(struct oxu_hcd *oxu, struct ehci_qh *qh)\r\n{\r\nunsigned i;\r\nunsigned period = qh->period;\r\ndev_dbg(&qh->dev->dev,\r\n"link qh%d-%04x/%p start %d [%d/%d us]\n",\r\nperiod, le32_to_cpup(&qh->hw_info2) & (QH_CMASK | QH_SMASK),\r\nqh, qh->start, qh->usecs, qh->c_usecs);\r\nif (period == 0)\r\nperiod = 1;\r\nfor (i = qh->start; i < oxu->periodic_size; i += period) {\r\nunion ehci_shadow *prev = &oxu->pshadow[i];\r\n__le32 *hw_p = &oxu->periodic[i];\r\nunion ehci_shadow here = *prev;\r\n__le32 type = 0;\r\nwhile (here.ptr) {\r\ntype = Q_NEXT_TYPE(*hw_p);\r\nif (type == Q_TYPE_QH)\r\nbreak;\r\nprev = periodic_next_shadow(prev, type);\r\nhw_p = &here.qh->hw_next;\r\nhere = *prev;\r\n}\r\nwhile (here.ptr && qh != here.qh) {\r\nif (qh->period > here.qh->period)\r\nbreak;\r\nprev = &here.qh->qh_next;\r\nhw_p = &here.qh->hw_next;\r\nhere = *prev;\r\n}\r\nif (qh != here.qh) {\r\nqh->qh_next = here;\r\nif (here.qh)\r\nqh->hw_next = *hw_p;\r\nwmb();\r\nprev->qh = qh;\r\n*hw_p = QH_NEXT(qh->qh_dma);\r\n}\r\n}\r\nqh->qh_state = QH_STATE_LINKED;\r\nqh_get(qh);\r\noxu_to_hcd(oxu)->self.bandwidth_allocated += qh->period\r\n? ((qh->usecs + qh->c_usecs) / qh->period)\r\n: (qh->usecs * 8);\r\nif (!oxu->periodic_sched++)\r\nreturn enable_periodic(oxu);\r\nreturn 0;\r\n}\r\nstatic void qh_unlink_periodic(struct oxu_hcd *oxu, struct ehci_qh *qh)\r\n{\r\nunsigned i;\r\nunsigned period;\r\nperiod = qh->period;\r\nif (period == 0)\r\nperiod = 1;\r\nfor (i = qh->start; i < oxu->periodic_size; i += period)\r\nperiodic_unlink(oxu, i, qh);\r\noxu_to_hcd(oxu)->self.bandwidth_allocated -= qh->period\r\n? ((qh->usecs + qh->c_usecs) / qh->period)\r\n: (qh->usecs * 8);\r\ndev_dbg(&qh->dev->dev,\r\n"unlink qh%d-%04x/%p start %d [%d/%d us]\n",\r\nqh->period,\r\nle32_to_cpup(&qh->hw_info2) & (QH_CMASK | QH_SMASK),\r\nqh, qh->start, qh->usecs, qh->c_usecs);\r\nqh->qh_state = QH_STATE_UNLINK;\r\nqh->qh_next.ptr = NULL;\r\nqh_put(qh);\r\noxu->periodic_sched--;\r\nif (!oxu->periodic_sched)\r\n(void) disable_periodic(oxu);\r\n}\r\nstatic void intr_deschedule(struct oxu_hcd *oxu, struct ehci_qh *qh)\r\n{\r\nunsigned wait;\r\nqh_unlink_periodic(oxu, qh);\r\nif (list_empty(&qh->qtd_list)\r\n|| (cpu_to_le32(QH_CMASK) & qh->hw_info2) != 0)\r\nwait = 2;\r\nelse\r\nwait = 55;\r\nudelay(wait);\r\nqh->qh_state = QH_STATE_IDLE;\r\nqh->hw_next = EHCI_LIST_END;\r\nwmb();\r\n}\r\nstatic int check_period(struct oxu_hcd *oxu,\r\nunsigned frame, unsigned uframe,\r\nunsigned period, unsigned usecs)\r\n{\r\nint claimed;\r\nif (uframe >= 8)\r\nreturn 0;\r\nusecs = 100 - usecs;\r\nif (unlikely(period == 0)) {\r\ndo {\r\nfor (uframe = 0; uframe < 7; uframe++) {\r\nclaimed = periodic_usecs(oxu, frame, uframe);\r\nif (claimed > usecs)\r\nreturn 0;\r\n}\r\n} while ((frame += 1) < oxu->periodic_size);\r\n} else {\r\ndo {\r\nclaimed = periodic_usecs(oxu, frame, uframe);\r\nif (claimed > usecs)\r\nreturn 0;\r\n} while ((frame += period) < oxu->periodic_size);\r\n}\r\nreturn 1;\r\n}\r\nstatic int check_intr_schedule(struct oxu_hcd *oxu,\r\nunsigned frame, unsigned uframe,\r\nconst struct ehci_qh *qh, __le32 *c_maskp)\r\n{\r\nint retval = -ENOSPC;\r\nif (qh->c_usecs && uframe >= 6)\r\ngoto done;\r\nif (!check_period(oxu, frame, uframe, qh->period, qh->usecs))\r\ngoto done;\r\nif (!qh->c_usecs) {\r\nretval = 0;\r\n*c_maskp = 0;\r\ngoto done;\r\n}\r\ndone:\r\nreturn retval;\r\n}\r\nstatic int qh_schedule(struct oxu_hcd *oxu, struct ehci_qh *qh)\r\n{\r\nint status;\r\nunsigned uframe;\r\n__le32 c_mask;\r\nunsigned frame;\r\nqh_refresh(oxu, qh);\r\nqh->hw_next = EHCI_LIST_END;\r\nframe = qh->start;\r\nif (frame < qh->period) {\r\nuframe = ffs(le32_to_cpup(&qh->hw_info2) & QH_SMASK);\r\nstatus = check_intr_schedule(oxu, frame, --uframe,\r\nqh, &c_mask);\r\n} else {\r\nuframe = 0;\r\nc_mask = 0;\r\nstatus = -ENOSPC;\r\n}\r\nif (status) {\r\nif (qh->period) {\r\nframe = qh->period - 1;\r\ndo {\r\nfor (uframe = 0; uframe < 8; uframe++) {\r\nstatus = check_intr_schedule(oxu,\r\nframe, uframe, qh,\r\n&c_mask);\r\nif (status == 0)\r\nbreak;\r\n}\r\n} while (status && frame--);\r\n} else {\r\nframe = 0;\r\nstatus = check_intr_schedule(oxu, 0, 0, qh, &c_mask);\r\n}\r\nif (status)\r\ngoto done;\r\nqh->start = frame;\r\nqh->hw_info2 &= cpu_to_le32(~(QH_CMASK | QH_SMASK));\r\nqh->hw_info2 |= qh->period\r\n? cpu_to_le32(1 << uframe)\r\n: cpu_to_le32(QH_SMASK);\r\nqh->hw_info2 |= c_mask;\r\n} else\r\noxu_dbg(oxu, "reused qh %p schedule\n", qh);\r\nstatus = qh_link_periodic(oxu, qh);\r\ndone:\r\nreturn status;\r\n}\r\nstatic int intr_submit(struct oxu_hcd *oxu, struct urb *urb,\r\nstruct list_head *qtd_list, gfp_t mem_flags)\r\n{\r\nunsigned epnum;\r\nunsigned long flags;\r\nstruct ehci_qh *qh;\r\nint status = 0;\r\nstruct list_head empty;\r\nepnum = urb->ep->desc.bEndpointAddress;\r\nspin_lock_irqsave(&oxu->lock, flags);\r\nif (unlikely(!HCD_HW_ACCESSIBLE(oxu_to_hcd(oxu)))) {\r\nstatus = -ESHUTDOWN;\r\ngoto done;\r\n}\r\nINIT_LIST_HEAD(&empty);\r\nqh = qh_append_tds(oxu, urb, &empty, epnum, &urb->ep->hcpriv);\r\nif (qh == NULL) {\r\nstatus = -ENOMEM;\r\ngoto done;\r\n}\r\nif (qh->qh_state == QH_STATE_IDLE) {\r\nstatus = qh_schedule(oxu, qh);\r\nif (status != 0)\r\ngoto done;\r\n}\r\nqh = qh_append_tds(oxu, urb, qtd_list, epnum, &urb->ep->hcpriv);\r\nBUG_ON(qh == NULL);\r\noxu_to_hcd(oxu)->self.bandwidth_int_reqs++;\r\ndone:\r\nspin_unlock_irqrestore(&oxu->lock, flags);\r\nif (status)\r\nqtd_list_free(oxu, urb, qtd_list);\r\nreturn status;\r\n}\r\nstatic inline int itd_submit(struct oxu_hcd *oxu, struct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\noxu_dbg(oxu, "iso support is missing!\n");\r\nreturn -ENOSYS;\r\n}\r\nstatic inline int sitd_submit(struct oxu_hcd *oxu, struct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\noxu_dbg(oxu, "split iso support is missing!\n");\r\nreturn -ENOSYS;\r\n}\r\nstatic void scan_periodic(struct oxu_hcd *oxu)\r\n{\r\nunsigned frame, clock, now_uframe, mod;\r\nunsigned modified;\r\nmod = oxu->periodic_size << 3;\r\nnow_uframe = oxu->next_uframe;\r\nif (HC_IS_RUNNING(oxu_to_hcd(oxu)->state))\r\nclock = readl(&oxu->regs->frame_index);\r\nelse\r\nclock = now_uframe + mod - 1;\r\nclock %= mod;\r\nfor (;;) {\r\nunion ehci_shadow q, *q_p;\r\n__le32 type, *hw_p;\r\nunsigned uframes;\r\nframe = now_uframe >> 3;\r\nif (frame == (clock >> 3))\r\nuframes = now_uframe & 0x07;\r\nelse {\r\nnow_uframe |= 0x07;\r\nuframes = 8;\r\n}\r\nrestart:\r\nq_p = &oxu->pshadow[frame];\r\nhw_p = &oxu->periodic[frame];\r\nq.ptr = q_p->ptr;\r\ntype = Q_NEXT_TYPE(*hw_p);\r\nmodified = 0;\r\nwhile (q.ptr != NULL) {\r\nunion ehci_shadow temp;\r\nint live;\r\nlive = HC_IS_RUNNING(oxu_to_hcd(oxu)->state);\r\nswitch (type) {\r\ncase Q_TYPE_QH:\r\ntemp.qh = qh_get(q.qh);\r\ntype = Q_NEXT_TYPE(q.qh->hw_next);\r\nq = q.qh->qh_next;\r\nmodified = qh_completions(oxu, temp.qh);\r\nif (unlikely(list_empty(&temp.qh->qtd_list)))\r\nintr_deschedule(oxu, temp.qh);\r\nqh_put(temp.qh);\r\nbreak;\r\ndefault:\r\noxu_dbg(oxu, "corrupt type %d frame %d shadow %p\n",\r\ntype, frame, q.ptr);\r\nq.ptr = NULL;\r\n}\r\nif (unlikely(modified))\r\ngoto restart;\r\n}\r\nif (now_uframe == clock) {\r\nunsigned now;\r\nif (!HC_IS_RUNNING(oxu_to_hcd(oxu)->state))\r\nbreak;\r\noxu->next_uframe = now_uframe;\r\nnow = readl(&oxu->regs->frame_index) % mod;\r\nif (now_uframe == now)\r\nbreak;\r\nclock = now;\r\n} else {\r\nnow_uframe++;\r\nnow_uframe %= mod;\r\n}\r\n}\r\n}\r\nstatic void ehci_turn_off_all_ports(struct oxu_hcd *oxu)\r\n{\r\nint port = HCS_N_PORTS(oxu->hcs_params);\r\nwhile (port--)\r\nwritel(PORT_RWC_BITS, &oxu->regs->port_status[port]);\r\n}\r\nstatic void ehci_port_power(struct oxu_hcd *oxu, int is_on)\r\n{\r\nunsigned port;\r\nif (!HCS_PPC(oxu->hcs_params))\r\nreturn;\r\noxu_dbg(oxu, "...power%s ports...\n", is_on ? "up" : "down");\r\nfor (port = HCS_N_PORTS(oxu->hcs_params); port > 0; )\r\n(void) oxu_hub_control(oxu_to_hcd(oxu),\r\nis_on ? SetPortFeature : ClearPortFeature,\r\nUSB_PORT_FEAT_POWER,\r\nport--, NULL, 0);\r\nmsleep(20);\r\n}\r\nstatic void ehci_work(struct oxu_hcd *oxu)\r\n{\r\ntimer_action_done(oxu, TIMER_IO_WATCHDOG);\r\nif (oxu->reclaim_ready)\r\nend_unlink_async(oxu);\r\nif (oxu->scanning)\r\nreturn;\r\noxu->scanning = 1;\r\nscan_async(oxu);\r\nif (oxu->next_uframe != -1)\r\nscan_periodic(oxu);\r\noxu->scanning = 0;\r\nif (HC_IS_RUNNING(oxu_to_hcd(oxu)->state) &&\r\n(oxu->async->qh_next.ptr != NULL ||\r\noxu->periodic_sched != 0))\r\ntimer_action(oxu, TIMER_IO_WATCHDOG);\r\n}\r\nstatic void unlink_async(struct oxu_hcd *oxu, struct ehci_qh *qh)\r\n{\r\nif (qh->qh_state == QH_STATE_LINKED\r\n&& oxu->reclaim\r\n&& HC_IS_RUNNING(oxu_to_hcd(oxu)->state)) {\r\nstruct ehci_qh *last;\r\nfor (last = oxu->reclaim;\r\nlast->reclaim;\r\nlast = last->reclaim)\r\ncontinue;\r\nqh->qh_state = QH_STATE_UNLINK_WAIT;\r\nlast->reclaim = qh;\r\n} else if (!HC_IS_RUNNING(oxu_to_hcd(oxu)->state) && oxu->reclaim)\r\nend_unlink_async(oxu);\r\nif (qh->qh_state == QH_STATE_LINKED)\r\nstart_unlink_async(oxu, qh);\r\n}\r\nstatic irqreturn_t oxu210_hcd_irq(struct usb_hcd *hcd)\r\n{\r\nstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\r\nu32 status, pcd_status = 0;\r\nint bh;\r\nspin_lock(&oxu->lock);\r\nstatus = readl(&oxu->regs->status);\r\nif (status == ~(u32) 0) {\r\noxu_dbg(oxu, "device removed\n");\r\ngoto dead;\r\n}\r\nstatus &= INTR_MASK;\r\nif (!status || unlikely(hcd->state == HC_STATE_HALT)) {\r\nspin_unlock(&oxu->lock);\r\nreturn IRQ_NONE;\r\n}\r\nwritel(status, &oxu->regs->status);\r\nreadl(&oxu->regs->command);\r\nbh = 0;\r\n#ifdef OXU_VERBOSE_DEBUG\r\ndbg_status(oxu, "irq", status);\r\n#endif\r\nif (likely((status & (STS_INT|STS_ERR)) != 0))\r\nbh = 1;\r\nif (status & STS_IAA) {\r\noxu->reclaim_ready = 1;\r\nbh = 1;\r\n}\r\nif (status & STS_PCD) {\r\nunsigned i = HCS_N_PORTS(oxu->hcs_params);\r\npcd_status = status;\r\nif (!(readl(&oxu->regs->command) & CMD_RUN))\r\nusb_hcd_resume_root_hub(hcd);\r\nwhile (i--) {\r\nint pstatus = readl(&oxu->regs->port_status[i]);\r\nif (pstatus & PORT_OWNER)\r\ncontinue;\r\nif (!(pstatus & PORT_RESUME)\r\n|| oxu->reset_done[i] != 0)\r\ncontinue;\r\noxu->reset_done[i] = jiffies +\r\nmsecs_to_jiffies(USB_RESUME_TIMEOUT);\r\noxu_dbg(oxu, "port %d remote wakeup\n", i + 1);\r\nmod_timer(&hcd->rh_timer, oxu->reset_done[i]);\r\n}\r\n}\r\nif (unlikely((status & STS_FATAL) != 0)) {\r\nstatus = readl(&oxu->regs->status);\r\ndbg_cmd(oxu, "fatal", readl(&oxu->regs->command));\r\ndbg_status(oxu, "fatal", status);\r\nif (status & STS_HALT) {\r\noxu_err(oxu, "fatal error\n");\r\ndead:\r\nehci_reset(oxu);\r\nwritel(0, &oxu->regs->configured_flag);\r\nusb_hc_died(hcd);\r\nbh = 1;\r\n}\r\n}\r\nif (bh)\r\nehci_work(oxu);\r\nspin_unlock(&oxu->lock);\r\nif (pcd_status & STS_PCD)\r\nusb_hcd_poll_rh_status(hcd);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t oxu_irq(struct usb_hcd *hcd)\r\n{\r\nstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\r\nint ret = IRQ_HANDLED;\r\nu32 status = oxu_readl(hcd->regs, OXU_CHIPIRQSTATUS);\r\nu32 enable = oxu_readl(hcd->regs, OXU_CHIPIRQEN_SET);\r\noxu_writel(hcd->regs, OXU_CHIPIRQEN_CLR, enable);\r\nif ((oxu->is_otg && (status & OXU_USBOTGI)) ||\r\n(!oxu->is_otg && (status & OXU_USBSPHI)))\r\noxu210_hcd_irq(hcd);\r\nelse\r\nret = IRQ_NONE;\r\noxu_writel(hcd->regs, OXU_CHIPIRQEN_SET, enable);\r\nreturn ret;\r\n}\r\nstatic void oxu_watchdog(unsigned long param)\r\n{\r\nstruct oxu_hcd *oxu = (struct oxu_hcd *) param;\r\nunsigned long flags;\r\nspin_lock_irqsave(&oxu->lock, flags);\r\nif (oxu->reclaim) {\r\nu32 status = readl(&oxu->regs->status);\r\nif (status & STS_IAA) {\r\noxu_vdbg(oxu, "lost IAA\n");\r\nwritel(STS_IAA, &oxu->regs->status);\r\noxu->reclaim_ready = 1;\r\n}\r\n}\r\nif (test_bit(TIMER_ASYNC_OFF, &oxu->actions))\r\nstart_unlink_async(oxu, oxu->async);\r\nehci_work(oxu);\r\nspin_unlock_irqrestore(&oxu->lock, flags);\r\n}\r\nstatic int oxu_hcd_init(struct usb_hcd *hcd)\r\n{\r\nstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\r\nu32 temp;\r\nint retval;\r\nu32 hcc_params;\r\nspin_lock_init(&oxu->lock);\r\nsetup_timer(&oxu->watchdog, oxu_watchdog, (unsigned long)oxu);\r\noxu->periodic_size = DEFAULT_I_TDPS;\r\nretval = ehci_mem_init(oxu, GFP_KERNEL);\r\nif (retval < 0)\r\nreturn retval;\r\nhcc_params = readl(&oxu->caps->hcc_params);\r\nif (HCC_ISOC_CACHE(hcc_params))\r\noxu->i_thresh = 8;\r\nelse\r\noxu->i_thresh = 2 + HCC_ISOC_THRES(hcc_params);\r\noxu->reclaim = NULL;\r\noxu->reclaim_ready = 0;\r\noxu->next_uframe = -1;\r\noxu->async->qh_next.qh = NULL;\r\noxu->async->hw_next = QH_NEXT(oxu->async->qh_dma);\r\noxu->async->hw_info1 = cpu_to_le32(QH_HEAD);\r\noxu->async->hw_token = cpu_to_le32(QTD_STS_HALT);\r\noxu->async->hw_qtd_next = EHCI_LIST_END;\r\noxu->async->qh_state = QH_STATE_LINKED;\r\noxu->async->hw_alt_next = QTD_NEXT(oxu->async->dummy->qtd_dma);\r\nif (log2_irq_thresh < 0 || log2_irq_thresh > 6)\r\nlog2_irq_thresh = 0;\r\ntemp = 1 << (16 + log2_irq_thresh);\r\nif (HCC_CANPARK(hcc_params)) {\r\nif (park) {\r\npark = min(park, (unsigned) 3);\r\ntemp |= CMD_PARK;\r\ntemp |= park << 8;\r\n}\r\noxu_dbg(oxu, "park %d\n", park);\r\n}\r\nif (HCC_PGM_FRAMELISTLEN(hcc_params)) {\r\ntemp &= ~(3 << 2);\r\ntemp |= (EHCI_TUNE_FLS << 2);\r\n}\r\noxu->command = temp;\r\nreturn 0;\r\n}\r\nstatic int oxu_reset(struct usb_hcd *hcd)\r\n{\r\nstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\r\nint ret;\r\nspin_lock_init(&oxu->mem_lock);\r\nINIT_LIST_HEAD(&oxu->urb_list);\r\noxu->urb_len = 0;\r\nhcd->self.controller->dma_mask = NULL;\r\nif (oxu->is_otg) {\r\noxu->caps = hcd->regs + OXU_OTG_CAP_OFFSET;\r\noxu->regs = hcd->regs + OXU_OTG_CAP_OFFSET + \\r\nHC_LENGTH(readl(&oxu->caps->hc_capbase));\r\noxu->mem = hcd->regs + OXU_SPH_MEM;\r\n} else {\r\noxu->caps = hcd->regs + OXU_SPH_CAP_OFFSET;\r\noxu->regs = hcd->regs + OXU_SPH_CAP_OFFSET + \\r\nHC_LENGTH(readl(&oxu->caps->hc_capbase));\r\noxu->mem = hcd->regs + OXU_OTG_MEM;\r\n}\r\noxu->hcs_params = readl(&oxu->caps->hcs_params);\r\noxu->sbrn = 0x20;\r\nret = oxu_hcd_init(hcd);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int oxu_run(struct usb_hcd *hcd)\r\n{\r\nstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\r\nint retval;\r\nu32 temp, hcc_params;\r\nhcd->uses_new_polling = 1;\r\nretval = ehci_reset(oxu);\r\nif (retval != 0) {\r\nehci_mem_cleanup(oxu);\r\nreturn retval;\r\n}\r\nwritel(oxu->periodic_dma, &oxu->regs->frame_list);\r\nwritel((u32) oxu->async->qh_dma, &oxu->regs->async_next);\r\nhcc_params = readl(&oxu->caps->hcc_params);\r\nif (HCC_64BIT_ADDR(hcc_params))\r\nwritel(0, &oxu->regs->segment);\r\noxu->command &= ~(CMD_LRESET | CMD_IAAD | CMD_PSE |\r\nCMD_ASE | CMD_RESET);\r\noxu->command |= CMD_RUN;\r\nwritel(oxu->command, &oxu->regs->command);\r\ndbg_cmd(oxu, "init", oxu->command);\r\nhcd->state = HC_STATE_RUNNING;\r\nwritel(FLAG_CF, &oxu->regs->configured_flag);\r\nreadl(&oxu->regs->command);\r\ntemp = HC_VERSION(readl(&oxu->caps->hc_capbase));\r\noxu_info(oxu, "USB %x.%x started, quasi-EHCI %x.%02x, driver %s%s\n",\r\n((oxu->sbrn & 0xf0)>>4), (oxu->sbrn & 0x0f),\r\ntemp >> 8, temp & 0xff, DRIVER_VERSION,\r\nignore_oc ? ", overcurrent ignored" : "");\r\nwritel(INTR_MASK, &oxu->regs->intr_enable);\r\nreturn 0;\r\n}\r\nstatic void oxu_stop(struct usb_hcd *hcd)\r\n{\r\nstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\r\nehci_port_power(oxu, 0);\r\ndel_timer_sync(&oxu->watchdog);\r\nspin_lock_irq(&oxu->lock);\r\nif (HC_IS_RUNNING(hcd->state))\r\nehci_quiesce(oxu);\r\nehci_reset(oxu);\r\nwritel(0, &oxu->regs->intr_enable);\r\nspin_unlock_irq(&oxu->lock);\r\nwritel(0, &oxu->regs->configured_flag);\r\nspin_lock_irq(&oxu->lock);\r\nif (oxu->async)\r\nehci_work(oxu);\r\nspin_unlock_irq(&oxu->lock);\r\nehci_mem_cleanup(oxu);\r\ndbg_status(oxu, "oxu_stop completed", readl(&oxu->regs->status));\r\n}\r\nstatic void oxu_shutdown(struct usb_hcd *hcd)\r\n{\r\nstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\r\n(void) ehci_halt(oxu);\r\nehci_turn_off_all_ports(oxu);\r\nwritel(0, &oxu->regs->configured_flag);\r\nreadl(&oxu->regs->configured_flag);\r\n}\r\nstatic int __oxu_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\r\nstruct list_head qtd_list;\r\nINIT_LIST_HEAD(&qtd_list);\r\nswitch (usb_pipetype(urb->pipe)) {\r\ncase PIPE_CONTROL:\r\ncase PIPE_BULK:\r\ndefault:\r\nif (!qh_urb_transaction(oxu, urb, &qtd_list, mem_flags))\r\nreturn -ENOMEM;\r\nreturn submit_async(oxu, urb, &qtd_list, mem_flags);\r\ncase PIPE_INTERRUPT:\r\nif (!qh_urb_transaction(oxu, urb, &qtd_list, mem_flags))\r\nreturn -ENOMEM;\r\nreturn intr_submit(oxu, urb, &qtd_list, mem_flags);\r\ncase PIPE_ISOCHRONOUS:\r\nif (urb->dev->speed == USB_SPEED_HIGH)\r\nreturn itd_submit(oxu, urb, mem_flags);\r\nelse\r\nreturn sitd_submit(oxu, urb, mem_flags);\r\n}\r\n}\r\nstatic int oxu_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\r\nint num, rem;\r\nint transfer_buffer_length;\r\nvoid *transfer_buffer;\r\nstruct urb *murb;\r\nint i, ret;\r\nif (!usb_pipebulk(urb->pipe))\r\nreturn __oxu_urb_enqueue(hcd, urb, mem_flags);\r\ntransfer_buffer = urb->transfer_buffer;\r\ntransfer_buffer_length = urb->transfer_buffer_length;\r\nnum = urb->transfer_buffer_length / 4096;\r\nrem = urb->transfer_buffer_length % 4096;\r\nif (rem != 0)\r\nnum++;\r\nif (num == 1)\r\nreturn __oxu_urb_enqueue(hcd, urb, mem_flags);\r\nfor (i = 0; i < num - 1; i++) {\r\ndo {\r\nmurb = (struct urb *) oxu_murb_alloc(oxu);\r\nif (!murb)\r\nschedule();\r\n} while (!murb);\r\nmemcpy(murb, urb, sizeof(struct urb));\r\nmurb->transfer_buffer_length = 4096;\r\nmurb->transfer_buffer = transfer_buffer + i * 4096;\r\nmurb->complete = NULL;\r\n((struct oxu_murb *) murb)->main = urb;\r\n((struct oxu_murb *) murb)->last = 0;\r\ndo {\r\nret = __oxu_urb_enqueue(hcd, murb, mem_flags);\r\nif (ret)\r\nschedule();\r\n} while (ret);\r\n}\r\ndo {\r\nmurb = (struct urb *) oxu_murb_alloc(oxu);\r\nif (!murb)\r\nschedule();\r\n} while (!murb);\r\nmemcpy(murb, urb, sizeof(struct urb));\r\nmurb->transfer_buffer_length = rem > 0 ? rem : 4096;\r\nmurb->transfer_buffer = transfer_buffer + (num - 1) * 4096;\r\nmurb->complete = NULL;\r\n((struct oxu_murb *) murb)->main = urb;\r\n((struct oxu_murb *) murb)->last = 1;\r\ndo {\r\nret = __oxu_urb_enqueue(hcd, murb, mem_flags);\r\nif (ret)\r\nschedule();\r\n} while (ret);\r\nreturn ret;\r\n}\r\nstatic int oxu_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\r\n{\r\nstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\r\nstruct ehci_qh *qh;\r\nunsigned long flags;\r\nspin_lock_irqsave(&oxu->lock, flags);\r\nswitch (usb_pipetype(urb->pipe)) {\r\ncase PIPE_CONTROL:\r\ncase PIPE_BULK:\r\ndefault:\r\nqh = (struct ehci_qh *) urb->hcpriv;\r\nif (!qh)\r\nbreak;\r\nunlink_async(oxu, qh);\r\nbreak;\r\ncase PIPE_INTERRUPT:\r\nqh = (struct ehci_qh *) urb->hcpriv;\r\nif (!qh)\r\nbreak;\r\nswitch (qh->qh_state) {\r\ncase QH_STATE_LINKED:\r\nintr_deschedule(oxu, qh);\r\ncase QH_STATE_IDLE:\r\nqh_completions(oxu, qh);\r\nbreak;\r\ndefault:\r\noxu_dbg(oxu, "bogus qh %p state %d\n",\r\nqh, qh->qh_state);\r\ngoto done;\r\n}\r\nif (!list_empty(&qh->qtd_list)\r\n&& HC_IS_RUNNING(hcd->state)) {\r\nint status;\r\nstatus = qh_schedule(oxu, qh);\r\nspin_unlock_irqrestore(&oxu->lock, flags);\r\nif (status != 0) {\r\ndev_err(hcd->self.controller,\r\n"can't reschedule qh %p, err %d\n", qh,\r\nstatus);\r\n}\r\nreturn status;\r\n}\r\nbreak;\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&oxu->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void oxu_endpoint_disable(struct usb_hcd *hcd,\r\nstruct usb_host_endpoint *ep)\r\n{\r\nstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\r\nunsigned long flags;\r\nstruct ehci_qh *qh, *tmp;\r\nrescan:\r\nspin_lock_irqsave(&oxu->lock, flags);\r\nqh = ep->hcpriv;\r\nif (!qh)\r\ngoto done;\r\nif (qh->hw_info1 == 0) {\r\noxu_vdbg(oxu, "iso delay\n");\r\ngoto idle_timeout;\r\n}\r\nif (!HC_IS_RUNNING(hcd->state))\r\nqh->qh_state = QH_STATE_IDLE;\r\nswitch (qh->qh_state) {\r\ncase QH_STATE_LINKED:\r\nfor (tmp = oxu->async->qh_next.qh;\r\ntmp && tmp != qh;\r\ntmp = tmp->qh_next.qh)\r\ncontinue;\r\nif (!tmp)\r\ngoto nogood;\r\nunlink_async(oxu, qh);\r\ncase QH_STATE_UNLINK:\r\nidle_timeout:\r\nspin_unlock_irqrestore(&oxu->lock, flags);\r\nschedule_timeout_uninterruptible(1);\r\ngoto rescan;\r\ncase QH_STATE_IDLE:\r\nif (list_empty(&qh->qtd_list)) {\r\nqh_put(qh);\r\nbreak;\r\n}\r\ndefault:\r\nnogood:\r\noxu_err(oxu, "qh %p (#%02x) state %d%s\n",\r\nqh, ep->desc.bEndpointAddress, qh->qh_state,\r\nlist_empty(&qh->qtd_list) ? "" : "(has tds)");\r\nbreak;\r\n}\r\nep->hcpriv = NULL;\r\ndone:\r\nspin_unlock_irqrestore(&oxu->lock, flags);\r\n}\r\nstatic int oxu_get_frame(struct usb_hcd *hcd)\r\n{\r\nstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\r\nreturn (readl(&oxu->regs->frame_index) >> 3) %\r\noxu->periodic_size;\r\n}\r\nstatic int oxu_hub_status_data(struct usb_hcd *hcd, char *buf)\r\n{\r\nstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\r\nu32 temp, mask, status = 0;\r\nint ports, i, retval = 1;\r\nunsigned long flags;\r\nif (!HC_IS_RUNNING(hcd->state))\r\nreturn 0;\r\nbuf[0] = 0;\r\nports = HCS_N_PORTS(oxu->hcs_params);\r\nif (ports > 7) {\r\nbuf[1] = 0;\r\nretval++;\r\n}\r\nif (!ignore_oc)\r\nmask = PORT_CSC | PORT_PEC | PORT_OCC;\r\nelse\r\nmask = PORT_CSC | PORT_PEC;\r\nspin_lock_irqsave(&oxu->lock, flags);\r\nfor (i = 0; i < ports; i++) {\r\ntemp = readl(&oxu->regs->port_status[i]);\r\nif (!(temp & PORT_CONNECT))\r\noxu->reset_done[i] = 0;\r\nif ((temp & mask) != 0 || ((temp & PORT_RESUME) != 0 &&\r\ntime_after_eq(jiffies, oxu->reset_done[i]))) {\r\nif (i < 7)\r\nbuf[0] |= 1 << (i + 1);\r\nelse\r\nbuf[1] |= 1 << (i - 7);\r\nstatus = STS_PCD;\r\n}\r\n}\r\nspin_unlock_irqrestore(&oxu->lock, flags);\r\nreturn status ? retval : 0;\r\n}\r\nstatic inline unsigned int oxu_port_speed(struct oxu_hcd *oxu,\r\nunsigned int portsc)\r\n{\r\nswitch ((portsc >> 26) & 3) {\r\ncase 0:\r\nreturn 0;\r\ncase 1:\r\nreturn USB_PORT_STAT_LOW_SPEED;\r\ncase 2:\r\ndefault:\r\nreturn USB_PORT_STAT_HIGH_SPEED;\r\n}\r\n}\r\nstatic int oxu_hub_control(struct usb_hcd *hcd, u16 typeReq,\r\nu16 wValue, u16 wIndex, char *buf, u16 wLength)\r\n{\r\nstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\r\nint ports = HCS_N_PORTS(oxu->hcs_params);\r\nu32 __iomem *status_reg = &oxu->regs->port_status[wIndex - 1];\r\nu32 temp, status;\r\nunsigned long flags;\r\nint retval = 0;\r\nunsigned selector;\r\nspin_lock_irqsave(&oxu->lock, flags);\r\nswitch (typeReq) {\r\ncase ClearHubFeature:\r\nswitch (wValue) {\r\ncase C_HUB_LOCAL_POWER:\r\ncase C_HUB_OVER_CURRENT:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ncase ClearPortFeature:\r\nif (!wIndex || wIndex > ports)\r\ngoto error;\r\nwIndex--;\r\ntemp = readl(status_reg);\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_ENABLE:\r\nwritel(temp & ~PORT_PE, status_reg);\r\nbreak;\r\ncase USB_PORT_FEAT_C_ENABLE:\r\nwritel((temp & ~PORT_RWC_BITS) | PORT_PEC, status_reg);\r\nbreak;\r\ncase USB_PORT_FEAT_SUSPEND:\r\nif (temp & PORT_RESET)\r\ngoto error;\r\nif (temp & PORT_SUSPEND) {\r\nif ((temp & PORT_PE) == 0)\r\ngoto error;\r\ntemp &= ~(PORT_RWC_BITS | PORT_WAKE_BITS);\r\nwritel(temp | PORT_RESUME, status_reg);\r\noxu->reset_done[wIndex] = jiffies\r\n+ msecs_to_jiffies(20);\r\n}\r\nbreak;\r\ncase USB_PORT_FEAT_C_SUSPEND:\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\nif (HCS_PPC(oxu->hcs_params))\r\nwritel(temp & ~(PORT_RWC_BITS | PORT_POWER),\r\nstatus_reg);\r\nbreak;\r\ncase USB_PORT_FEAT_C_CONNECTION:\r\nwritel((temp & ~PORT_RWC_BITS) | PORT_CSC, status_reg);\r\nbreak;\r\ncase USB_PORT_FEAT_C_OVER_CURRENT:\r\nwritel((temp & ~PORT_RWC_BITS) | PORT_OCC, status_reg);\r\nbreak;\r\ncase USB_PORT_FEAT_C_RESET:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nreadl(&oxu->regs->command);\r\nbreak;\r\ncase GetHubDescriptor:\r\nehci_hub_descriptor(oxu, (struct usb_hub_descriptor *)\r\nbuf);\r\nbreak;\r\ncase GetHubStatus:\r\nmemset(buf, 0, 4);\r\nbreak;\r\ncase GetPortStatus:\r\nif (!wIndex || wIndex > ports)\r\ngoto error;\r\nwIndex--;\r\nstatus = 0;\r\ntemp = readl(status_reg);\r\nif (temp & PORT_CSC)\r\nstatus |= USB_PORT_STAT_C_CONNECTION << 16;\r\nif (temp & PORT_PEC)\r\nstatus |= USB_PORT_STAT_C_ENABLE << 16;\r\nif ((temp & PORT_OCC) && !ignore_oc)\r\nstatus |= USB_PORT_STAT_C_OVERCURRENT << 16;\r\nif (temp & PORT_RESUME) {\r\nif (!oxu->reset_done[wIndex]) {\r\noxu->reset_done[wIndex] = jiffies\r\n+ msecs_to_jiffies(20);\r\nmod_timer(&oxu_to_hcd(oxu)->rh_timer,\r\noxu->reset_done[wIndex]);\r\n}\r\nelse if (time_after_eq(jiffies,\r\noxu->reset_done[wIndex])) {\r\nstatus |= USB_PORT_STAT_C_SUSPEND << 16;\r\noxu->reset_done[wIndex] = 0;\r\ntemp = readl(status_reg);\r\nwritel(temp & ~(PORT_RWC_BITS | PORT_RESUME),\r\nstatus_reg);\r\nretval = handshake(oxu, status_reg,\r\nPORT_RESUME, 0, 2000 );\r\nif (retval != 0) {\r\noxu_err(oxu,\r\n"port %d resume error %d\n",\r\nwIndex + 1, retval);\r\ngoto error;\r\n}\r\ntemp &= ~(PORT_SUSPEND|PORT_RESUME|(3<<10));\r\n}\r\n}\r\nif ((temp & PORT_RESET)\r\n&& time_after_eq(jiffies,\r\noxu->reset_done[wIndex])) {\r\nstatus |= USB_PORT_STAT_C_RESET << 16;\r\noxu->reset_done[wIndex] = 0;\r\nwritel(temp & ~(PORT_RWC_BITS | PORT_RESET),\r\nstatus_reg);\r\nretval = handshake(oxu, status_reg,\r\nPORT_RESET, 0, 750);\r\nif (retval != 0) {\r\noxu_err(oxu, "port %d reset error %d\n",\r\nwIndex + 1, retval);\r\ngoto error;\r\n}\r\ntemp = check_reset_complete(oxu, wIndex, status_reg,\r\nreadl(status_reg));\r\n}\r\nif ((temp & PORT_CONNECT) &&\r\ntest_bit(wIndex, &oxu->companion_ports)) {\r\ntemp &= ~PORT_RWC_BITS;\r\ntemp |= PORT_OWNER;\r\nwritel(temp, status_reg);\r\noxu_dbg(oxu, "port %d --> companion\n", wIndex + 1);\r\ntemp = readl(status_reg);\r\n}\r\nif (temp & PORT_CONNECT) {\r\nstatus |= USB_PORT_STAT_CONNECTION;\r\nstatus |= oxu_port_speed(oxu, temp);\r\n}\r\nif (temp & PORT_PE)\r\nstatus |= USB_PORT_STAT_ENABLE;\r\nif (temp & (PORT_SUSPEND|PORT_RESUME))\r\nstatus |= USB_PORT_STAT_SUSPEND;\r\nif (temp & PORT_OC)\r\nstatus |= USB_PORT_STAT_OVERCURRENT;\r\nif (temp & PORT_RESET)\r\nstatus |= USB_PORT_STAT_RESET;\r\nif (temp & PORT_POWER)\r\nstatus |= USB_PORT_STAT_POWER;\r\n#ifndef OXU_VERBOSE_DEBUG\r\nif (status & ~0xffff)\r\n#endif\r\ndbg_port(oxu, "GetStatus", wIndex + 1, temp);\r\nput_unaligned(cpu_to_le32(status), (__le32 *) buf);\r\nbreak;\r\ncase SetHubFeature:\r\nswitch (wValue) {\r\ncase C_HUB_LOCAL_POWER:\r\ncase C_HUB_OVER_CURRENT:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ncase SetPortFeature:\r\nselector = wIndex >> 8;\r\nwIndex &= 0xff;\r\nif (!wIndex || wIndex > ports)\r\ngoto error;\r\nwIndex--;\r\ntemp = readl(status_reg);\r\nif (temp & PORT_OWNER)\r\nbreak;\r\ntemp &= ~PORT_RWC_BITS;\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_SUSPEND:\r\nif ((temp & PORT_PE) == 0\r\n|| (temp & PORT_RESET) != 0)\r\ngoto error;\r\nif (device_may_wakeup(&hcd->self.root_hub->dev))\r\ntemp |= PORT_WAKE_BITS;\r\nwritel(temp | PORT_SUSPEND, status_reg);\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\nif (HCS_PPC(oxu->hcs_params))\r\nwritel(temp | PORT_POWER, status_reg);\r\nbreak;\r\ncase USB_PORT_FEAT_RESET:\r\nif (temp & PORT_RESUME)\r\ngoto error;\r\noxu_vdbg(oxu, "port %d reset\n", wIndex + 1);\r\ntemp |= PORT_RESET;\r\ntemp &= ~PORT_PE;\r\noxu->reset_done[wIndex] = jiffies\r\n+ msecs_to_jiffies(50);\r\nwritel(temp, status_reg);\r\nbreak;\r\ncase USB_PORT_FEAT_TEST:\r\nif (!selector || selector > 5)\r\ngoto error;\r\nehci_quiesce(oxu);\r\nehci_halt(oxu);\r\ntemp |= selector << 16;\r\nwritel(temp, status_reg);\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nreadl(&oxu->regs->command);\r\nbreak;\r\ndefault:\r\nerror:\r\nretval = -EPIPE;\r\n}\r\nspin_unlock_irqrestore(&oxu->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int oxu_bus_suspend(struct usb_hcd *hcd)\r\n{\r\nstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\r\nint port;\r\nint mask;\r\noxu_dbg(oxu, "suspend root hub\n");\r\nif (time_before(jiffies, oxu->next_statechange))\r\nmsleep(5);\r\nport = HCS_N_PORTS(oxu->hcs_params);\r\nspin_lock_irq(&oxu->lock);\r\nif (HC_IS_RUNNING(hcd->state)) {\r\nehci_quiesce(oxu);\r\nhcd->state = HC_STATE_QUIESCING;\r\n}\r\noxu->command = readl(&oxu->regs->command);\r\nif (oxu->reclaim)\r\noxu->reclaim_ready = 1;\r\nehci_work(oxu);\r\noxu->bus_suspended = 0;\r\nwhile (port--) {\r\nu32 __iomem *reg = &oxu->regs->port_status[port];\r\nu32 t1 = readl(reg) & ~PORT_RWC_BITS;\r\nu32 t2 = t1;\r\nif ((t1 & PORT_PE) && !(t1 & PORT_OWNER) &&\r\n!(t1 & PORT_SUSPEND)) {\r\nt2 |= PORT_SUSPEND;\r\nset_bit(port, &oxu->bus_suspended);\r\n}\r\nif (device_may_wakeup(&hcd->self.root_hub->dev))\r\nt2 |= PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E;\r\nelse\r\nt2 &= ~(PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E);\r\nif (t1 != t2) {\r\noxu_vdbg(oxu, "port %d, %08x -> %08x\n",\r\nport + 1, t1, t2);\r\nwritel(t2, reg);\r\n}\r\n}\r\ndel_timer_sync(&oxu->watchdog);\r\nehci_halt(oxu);\r\nhcd->state = HC_STATE_SUSPENDED;\r\nmask = INTR_MASK;\r\nif (!device_may_wakeup(&hcd->self.root_hub->dev))\r\nmask &= ~STS_PCD;\r\nwritel(mask, &oxu->regs->intr_enable);\r\nreadl(&oxu->regs->intr_enable);\r\noxu->next_statechange = jiffies + msecs_to_jiffies(10);\r\nspin_unlock_irq(&oxu->lock);\r\nreturn 0;\r\n}\r\nstatic int oxu_bus_resume(struct usb_hcd *hcd)\r\n{\r\nstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\r\nu32 temp;\r\nint i;\r\nif (time_before(jiffies, oxu->next_statechange))\r\nmsleep(5);\r\nspin_lock_irq(&oxu->lock);\r\ntemp = readl(&oxu->regs->intr_enable);\r\noxu_dbg(oxu, "resume root hub%s\n", temp ? "" : " after power loss");\r\nwritel(0, &oxu->regs->intr_enable);\r\nwritel(0, &oxu->regs->segment);\r\nwritel(oxu->periodic_dma, &oxu->regs->frame_list);\r\nwritel((u32) oxu->async->qh_dma, &oxu->regs->async_next);\r\nwritel(oxu->command, &oxu->regs->command);\r\nmdelay(8);\r\ni = HCS_N_PORTS(oxu->hcs_params);\r\nwhile (i--) {\r\ntemp = readl(&oxu->regs->port_status[i]);\r\ntemp &= ~(PORT_RWC_BITS\r\n| PORT_WKOC_E | PORT_WKDISC_E | PORT_WKCONN_E);\r\nif (test_bit(i, &oxu->bus_suspended) && (temp & PORT_SUSPEND)) {\r\noxu->reset_done[i] = jiffies + msecs_to_jiffies(20);\r\ntemp |= PORT_RESUME;\r\n}\r\nwritel(temp, &oxu->regs->port_status[i]);\r\n}\r\ni = HCS_N_PORTS(oxu->hcs_params);\r\nmdelay(20);\r\nwhile (i--) {\r\ntemp = readl(&oxu->regs->port_status[i]);\r\nif (test_bit(i, &oxu->bus_suspended) && (temp & PORT_SUSPEND)) {\r\ntemp &= ~(PORT_RWC_BITS | PORT_RESUME);\r\nwritel(temp, &oxu->regs->port_status[i]);\r\noxu_vdbg(oxu, "resumed port %d\n", i + 1);\r\n}\r\n}\r\n(void) readl(&oxu->regs->command);\r\ntemp = 0;\r\nif (oxu->async->qh_next.qh)\r\ntemp |= CMD_ASE;\r\nif (oxu->periodic_sched)\r\ntemp |= CMD_PSE;\r\nif (temp) {\r\noxu->command |= temp;\r\nwritel(oxu->command, &oxu->regs->command);\r\n}\r\noxu->next_statechange = jiffies + msecs_to_jiffies(5);\r\nhcd->state = HC_STATE_RUNNING;\r\nwritel(INTR_MASK, &oxu->regs->intr_enable);\r\nspin_unlock_irq(&oxu->lock);\r\nreturn 0;\r\n}\r\nstatic int oxu_bus_suspend(struct usb_hcd *hcd)\r\n{\r\nreturn 0;\r\n}\r\nstatic int oxu_bus_resume(struct usb_hcd *hcd)\r\n{\r\nreturn 0;\r\n}\r\nstatic void oxu_configuration(struct platform_device *pdev, void *base)\r\n{\r\nu32 tmp;\r\noxu_writel(base, OXU_HOSTIFCONFIG, 0x0000037D);\r\noxu_writel(base, OXU_SOFTRESET, OXU_SRESET);\r\noxu_writel(base, OXU_HOSTIFCONFIG, 0x0000037D);\r\ntmp = oxu_readl(base, OXU_PIOBURSTREADCTRL);\r\noxu_writel(base, OXU_PIOBURSTREADCTRL, tmp | 0x0040);\r\noxu_writel(base, OXU_ASO, OXU_SPHPOEN | OXU_OVRCCURPUPDEN |\r\nOXU_COMPARATOR | OXU_ASO_OP);\r\ntmp = oxu_readl(base, OXU_CLKCTRL_SET);\r\noxu_writel(base, OXU_CLKCTRL_SET, tmp | OXU_SYSCLKEN | OXU_USBOTGCLKEN);\r\noxu_writel(base, OXU_CHIPIRQEN_CLR, 0xff);\r\noxu_writel(base, OXU_CHIPIRQSTATUS, 0xff);\r\noxu_writel(base, OXU_CHIPIRQEN_SET, OXU_USBSPHLPWUI | OXU_USBOTGLPWUI);\r\n}\r\nstatic int oxu_verify_id(struct platform_device *pdev, void *base)\r\n{\r\nu32 id;\r\nstatic const char * const bo[] = {\r\n"reserved",\r\n"128-pin LQFP",\r\n"84-pin TFBGA",\r\n"reserved",\r\n};\r\nid = oxu_readl(base, OXU_DEVICEID);\r\ndev_info(&pdev->dev, "device ID %x\n", id);\r\nif ((id & OXU_REV_MASK) != (OXU_REV_2100 << OXU_REV_SHIFT))\r\nreturn -1;\r\ndev_info(&pdev->dev, "found device %x %s (%04x:%04x)\n",\r\nid >> OXU_REV_SHIFT,\r\nbo[(id & OXU_BO_MASK) >> OXU_BO_SHIFT],\r\n(id & OXU_MAJ_REV_MASK) >> OXU_MAJ_REV_SHIFT,\r\n(id & OXU_MIN_REV_MASK) >> OXU_MIN_REV_SHIFT);\r\nreturn 0;\r\n}\r\nstatic struct usb_hcd *oxu_create(struct platform_device *pdev,\r\nunsigned long memstart, unsigned long memlen,\r\nvoid *base, int irq, int otg)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct usb_hcd *hcd;\r\nstruct oxu_hcd *oxu;\r\nint ret;\r\noxu_writel(base + (otg ? OXU_OTG_CORE_OFFSET : OXU_SPH_CORE_OFFSET),\r\nOXU_USBMODE,\r\nOXU_CM_HOST_ONLY | OXU_ES_LITTLE | OXU_VBPS);\r\nhcd = usb_create_hcd(&oxu_hc_driver, dev,\r\notg ? "oxu210hp_otg" : "oxu210hp_sph");\r\nif (!hcd)\r\nreturn ERR_PTR(-ENOMEM);\r\nhcd->rsrc_start = memstart;\r\nhcd->rsrc_len = memlen;\r\nhcd->regs = base;\r\nhcd->irq = irq;\r\nhcd->state = HC_STATE_HALT;\r\noxu = hcd_to_oxu(hcd);\r\noxu->is_otg = otg;\r\nret = usb_add_hcd(hcd, irq, IRQF_SHARED);\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\ndevice_wakeup_enable(hcd->self.controller);\r\nreturn hcd;\r\n}\r\nstatic int oxu_init(struct platform_device *pdev,\r\nunsigned long memstart, unsigned long memlen,\r\nvoid *base, int irq)\r\n{\r\nstruct oxu_info *info = platform_get_drvdata(pdev);\r\nstruct usb_hcd *hcd;\r\nint ret;\r\noxu_configuration(pdev, base);\r\nret = oxu_verify_id(pdev, base);\r\nif (ret) {\r\ndev_err(&pdev->dev, "no devices found!\n");\r\nreturn -ENODEV;\r\n}\r\nhcd = oxu_create(pdev, memstart, memlen, base, irq, 1);\r\nif (IS_ERR(hcd)) {\r\ndev_err(&pdev->dev, "cannot create OTG controller!\n");\r\nret = PTR_ERR(hcd);\r\ngoto error_create_otg;\r\n}\r\ninfo->hcd[0] = hcd;\r\nhcd = oxu_create(pdev, memstart, memlen, base, irq, 0);\r\nif (IS_ERR(hcd)) {\r\ndev_err(&pdev->dev, "cannot create SPH controller!\n");\r\nret = PTR_ERR(hcd);\r\ngoto error_create_sph;\r\n}\r\ninfo->hcd[1] = hcd;\r\noxu_writel(base, OXU_CHIPIRQEN_SET,\r\noxu_readl(base, OXU_CHIPIRQEN_SET) | 3);\r\nreturn 0;\r\nerror_create_sph:\r\nusb_remove_hcd(info->hcd[0]);\r\nusb_put_hcd(info->hcd[0]);\r\nerror_create_otg:\r\nreturn ret;\r\n}\r\nstatic int oxu_drv_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nvoid *base;\r\nunsigned long memstart, memlen;\r\nint irq, ret;\r\nstruct oxu_info *info;\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev,\r\n"no IRQ! Check %s setup!\n", dev_name(&pdev->dev));\r\nreturn -ENODEV;\r\n}\r\nirq = res->start;\r\ndev_dbg(&pdev->dev, "IRQ resource %d\n", irq);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base)) {\r\nret = PTR_ERR(base);\r\ngoto error;\r\n}\r\nmemstart = res->start;\r\nmemlen = resource_size(res);\r\nret = irq_set_irq_type(irq, IRQF_TRIGGER_FALLING);\r\nif (ret) {\r\ndev_err(&pdev->dev, "error setting irq type\n");\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\ninfo = devm_kzalloc(&pdev->dev, sizeof(struct oxu_info), GFP_KERNEL);\r\nif (!info) {\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\nplatform_set_drvdata(pdev, info);\r\nret = oxu_init(pdev, memstart, memlen, base, irq);\r\nif (ret < 0) {\r\ndev_dbg(&pdev->dev, "cannot init USB devices\n");\r\ngoto error;\r\n}\r\ndev_info(&pdev->dev, "devices enabled and running\n");\r\nplatform_set_drvdata(pdev, info);\r\nreturn 0;\r\nerror:\r\ndev_err(&pdev->dev, "init %s fail, %d\n", dev_name(&pdev->dev), ret);\r\nreturn ret;\r\n}\r\nstatic void oxu_remove(struct platform_device *pdev, struct usb_hcd *hcd)\r\n{\r\nusb_remove_hcd(hcd);\r\nusb_put_hcd(hcd);\r\n}\r\nstatic int oxu_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct oxu_info *info = platform_get_drvdata(pdev);\r\noxu_remove(pdev, info->hcd[0]);\r\noxu_remove(pdev, info->hcd[1]);\r\nreturn 0;\r\n}\r\nstatic void oxu_drv_shutdown(struct platform_device *pdev)\r\n{\r\noxu_drv_remove(pdev);\r\n}
