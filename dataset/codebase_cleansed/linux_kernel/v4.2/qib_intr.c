static void qib_format_hwmsg(char *msg, size_t msgl, const char *hwmsg)\r\n{\r\nstrlcat(msg, "[", msgl);\r\nstrlcat(msg, hwmsg, msgl);\r\nstrlcat(msg, "]", msgl);\r\n}\r\nvoid qib_format_hwerrors(u64 hwerrs, const struct qib_hwerror_msgs *hwerrmsgs,\r\nsize_t nhwerrmsgs, char *msg, size_t msgl)\r\n{\r\nint i;\r\nfor (i = 0; i < nhwerrmsgs; i++)\r\nif (hwerrs & hwerrmsgs[i].mask)\r\nqib_format_hwmsg(msg, msgl, hwerrmsgs[i].msg);\r\n}\r\nstatic void signal_ib_event(struct qib_pportdata *ppd, enum ib_event_type ev)\r\n{\r\nstruct ib_event event;\r\nstruct qib_devdata *dd = ppd->dd;\r\nevent.device = &dd->verbs_dev.ibdev;\r\nevent.element.port_num = ppd->port;\r\nevent.event = ev;\r\nib_dispatch_event(&event);\r\n}\r\nvoid qib_handle_e_ibstatuschanged(struct qib_pportdata *ppd, u64 ibcs)\r\n{\r\nstruct qib_devdata *dd = ppd->dd;\r\nunsigned long flags;\r\nu32 lstate;\r\nu8 ltstate;\r\nenum ib_event_type ev = 0;\r\nlstate = dd->f_iblink_state(ibcs);\r\nltstate = dd->f_ibphys_portstate(ibcs);\r\nif (lstate >= IB_PORT_INIT &&\r\n(!ppd->lflags || (ppd->lflags & QIBL_LINKDOWN)) &&\r\nltstate == IB_PHYSPORTSTATE_LINKUP) {\r\nif (dd->f_ib_updown(ppd, 1, ibcs))\r\ngoto skip_ibchange;\r\n} else if (ppd->lflags & (QIBL_LINKINIT | QIBL_LINKARMED |\r\nQIBL_LINKACTIVE | QIBL_IB_FORCE_NOTIFY)) {\r\nif (ltstate != IB_PHYSPORTSTATE_LINKUP &&\r\nltstate <= IB_PHYSPORTSTATE_CFG_TRAIN &&\r\ndd->f_ib_updown(ppd, 0, ibcs))\r\ngoto skip_ibchange;\r\nqib_set_uevent_bits(ppd, _QIB_EVENT_LINKDOWN_BIT);\r\n}\r\nif (lstate != IB_PORT_DOWN) {\r\nif (lstate != IB_PORT_ACTIVE) {\r\n*ppd->statusp &= ~QIB_STATUS_IB_READY;\r\nif (ppd->lflags & QIBL_LINKACTIVE)\r\nev = IB_EVENT_PORT_ERR;\r\nspin_lock_irqsave(&ppd->lflags_lock, flags);\r\nif (lstate == IB_PORT_ARMED) {\r\nppd->lflags |= QIBL_LINKARMED | QIBL_LINKV;\r\nppd->lflags &= ~(QIBL_LINKINIT |\r\nQIBL_LINKDOWN | QIBL_LINKACTIVE);\r\n} else {\r\nppd->lflags |= QIBL_LINKINIT | QIBL_LINKV;\r\nppd->lflags &= ~(QIBL_LINKARMED |\r\nQIBL_LINKDOWN | QIBL_LINKACTIVE);\r\n}\r\nspin_unlock_irqrestore(&ppd->lflags_lock, flags);\r\nmod_timer(&ppd->symerr_clear_timer,\r\nmsecs_to_jiffies(75));\r\n} else if (ltstate == IB_PHYSPORTSTATE_LINKUP &&\r\n!(ppd->lflags & QIBL_LINKACTIVE)) {\r\nqib_hol_up(ppd);\r\n*ppd->statusp |=\r\nQIB_STATUS_IB_READY | QIB_STATUS_IB_CONF;\r\nqib_clear_symerror_on_linkup((unsigned long)ppd);\r\nspin_lock_irqsave(&ppd->lflags_lock, flags);\r\nppd->lflags |= QIBL_LINKACTIVE | QIBL_LINKV;\r\nppd->lflags &= ~(QIBL_LINKINIT |\r\nQIBL_LINKDOWN | QIBL_LINKARMED);\r\nspin_unlock_irqrestore(&ppd->lflags_lock, flags);\r\nif (dd->flags & QIB_HAS_SEND_DMA)\r\nqib_sdma_process_event(ppd,\r\nqib_sdma_event_e30_go_running);\r\nev = IB_EVENT_PORT_ACTIVE;\r\ndd->f_setextled(ppd, 1);\r\n}\r\n} else {\r\nif (ppd->lflags & QIBL_LINKACTIVE)\r\nev = IB_EVENT_PORT_ERR;\r\nspin_lock_irqsave(&ppd->lflags_lock, flags);\r\nppd->lflags |= QIBL_LINKDOWN | QIBL_LINKV;\r\nppd->lflags &= ~(QIBL_LINKINIT |\r\nQIBL_LINKACTIVE | QIBL_LINKARMED);\r\nspin_unlock_irqrestore(&ppd->lflags_lock, flags);\r\n*ppd->statusp &= ~QIB_STATUS_IB_READY;\r\n}\r\nskip_ibchange:\r\nppd->lastibcstat = ibcs;\r\nif (ev)\r\nsignal_ib_event(ppd, ev);\r\n}\r\nvoid qib_clear_symerror_on_linkup(unsigned long opaque)\r\n{\r\nstruct qib_pportdata *ppd = (struct qib_pportdata *)opaque;\r\nif (ppd->lflags & QIBL_LINKACTIVE)\r\nreturn;\r\nppd->ibport_data.z_symbol_error_counter =\r\nppd->dd->f_portcntr(ppd, QIBPORTCNTR_IBSYMBOLERR);\r\n}\r\nvoid qib_handle_urcv(struct qib_devdata *dd, u64 ctxtr)\r\n{\r\nstruct qib_ctxtdata *rcd;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&dd->uctxt_lock, flags);\r\nfor (i = dd->first_user_ctxt; dd->rcd && i < dd->cfgctxts; i++) {\r\nif (!(ctxtr & (1ULL << i)))\r\ncontinue;\r\nrcd = dd->rcd[i];\r\nif (!rcd || !rcd->cnt)\r\ncontinue;\r\nif (test_and_clear_bit(QIB_CTXT_WAITING_RCV, &rcd->flag)) {\r\nwake_up_interruptible(&rcd->wait);\r\ndd->f_rcvctrl(rcd->ppd, QIB_RCVCTRL_INTRAVAIL_DIS,\r\nrcd->ctxt);\r\n} else if (test_and_clear_bit(QIB_CTXT_WAITING_URG,\r\n&rcd->flag)) {\r\nrcd->urgent++;\r\nwake_up_interruptible(&rcd->wait);\r\n}\r\n}\r\nspin_unlock_irqrestore(&dd->uctxt_lock, flags);\r\n}\r\nvoid qib_bad_intrstatus(struct qib_devdata *dd)\r\n{\r\nstatic int allbits;\r\nqib_dev_err(dd,\r\n"Read of chip interrupt status failed disabling interrupts\n");\r\nif (allbits++) {\r\nif (allbits == 2)\r\ndd->f_set_intr_state(dd, 0);\r\nif (allbits == 3) {\r\nqib_dev_err(dd,\r\n"2nd bad interrupt status, unregistering interrupts\n");\r\ndd->flags |= QIB_BADINTR;\r\ndd->flags &= ~QIB_INITTED;\r\ndd->f_free_irq(dd);\r\n}\r\n}\r\n}
