fw_memblock_t * __init fw_getmdesc(int eva)\r\n{\r\nchar *memsize_str, *ememsize_str = NULL, *ptr;\r\nunsigned long memsize = 0, ememsize = 0;\r\nstatic char cmdline[COMMAND_LINE_SIZE] __initdata;\r\nint tmp;\r\nmemsize_str = fw_getenv("memsize");\r\nif (memsize_str) {\r\ntmp = kstrtoul(memsize_str, 0, &memsize);\r\nif (tmp)\r\npr_warn("Failed to read the 'memsize' env variable.\n");\r\n}\r\nif (eva) {\r\nememsize_str = fw_getenv("ememsize");\r\nif (ememsize_str) {\r\ntmp = kstrtoul(ememsize_str, 0, &ememsize);\r\nif (tmp)\r\npr_warn("Failed to read the 'ememsize' env variable.\n");\r\n}\r\n}\r\nif (!memsize && !ememsize) {\r\npr_warn("memsize not set in YAMON, set to default (32Mb)\n");\r\nphysical_memsize = 0x02000000;\r\n} else {\r\nif (memsize > (256 << 20)) {\r\npr_warn("Unsupported memsize value (0x%lx) detected! "\r\n"Using 0x10000000 (256M) instead\n",\r\nmemsize);\r\nmemsize = 256 << 20;\r\n}\r\nphysical_memsize = ememsize ? : memsize;\r\n}\r\n#ifdef CONFIG_CPU_BIG_ENDIAN\r\nphysical_memsize -= PAGE_SIZE;\r\n#endif\r\nstrcpy(cmdline, arcs_cmdline);\r\nptr = strstr(cmdline, "memsize=");\r\nif (ptr && (ptr != cmdline) && (*(ptr - 1) != ' '))\r\nptr = strstr(ptr, " memsize=");\r\nif (eva) {\r\nptr = strstr(cmdline, "ememsize=");\r\nif (ptr && (ptr != cmdline) && (*(ptr - 1) != ' '))\r\nptr = strstr(ptr, " ememsize=");\r\n}\r\nif (ptr)\r\nmemsize = memparse(ptr + 8 + (eva ? 1 : 0), &ptr);\r\nelse\r\nmemsize = physical_memsize;\r\nif (memsize > 0x7fff0000)\r\nmemsize = 0x7fff0000;\r\nmemset(mdesc, 0, sizeof(mdesc));\r\nmdesc[0].type = fw_dontuse;\r\nmdesc[0].base = PHYS_OFFSET;\r\nmdesc[0].size = 0x00001000;\r\nmdesc[1].type = fw_code;\r\nmdesc[1].base = mdesc[0].base + 0x00001000UL;\r\nmdesc[1].size = 0x000ef000;\r\nmdesc[2].type = fw_dontuse;\r\nmdesc[2].base = mdesc[0].base + 0x000f0000UL;\r\nmdesc[2].size = 0x00010000;\r\nmdesc[3].type = fw_dontuse;\r\nmdesc[3].base = mdesc[0].base + 0x00100000UL;\r\nmdesc[3].size = CPHYSADDR(PFN_ALIGN((unsigned long)&_end)) -\r\n0x00100000UL;\r\nmdesc[4].type = fw_free;\r\nmdesc[4].base = mdesc[0].base + CPHYSADDR(PFN_ALIGN(&_end));\r\nmdesc[4].size = memsize - CPHYSADDR(mdesc[4].base);\r\nreturn &mdesc[0];\r\n}\r\nstatic void free_init_pages_eva_malta(void *begin, void *end)\r\n{\r\nfree_init_pages("unused kernel", __pa_symbol((unsigned long *)begin),\r\n__pa_symbol((unsigned long *)end));\r\n}\r\nstatic int __init fw_memtype_classify(unsigned int type)\r\n{\r\nswitch (type) {\r\ncase fw_free:\r\nreturn BOOT_MEM_RAM;\r\ncase fw_code:\r\nreturn BOOT_MEM_ROM_DATA;\r\ndefault:\r\nreturn BOOT_MEM_RESERVED;\r\n}\r\n}\r\nvoid __init fw_meminit(void)\r\n{\r\nfw_memblock_t *p;\r\np = fw_getmdesc(config_enabled(CONFIG_EVA));\r\nfree_init_pages_eva = (config_enabled(CONFIG_EVA) ?\r\nfree_init_pages_eva_malta : NULL);\r\nwhile (p->size) {\r\nlong type;\r\nunsigned long base, size;\r\ntype = fw_memtype_classify(p->type);\r\nbase = p->base;\r\nsize = p->size;\r\nadd_memory_region(base, size, type);\r\np++;\r\n}\r\n}\r\nvoid __init prom_free_prom_memory(void)\r\n{\r\nunsigned long addr;\r\nint i;\r\nfor (i = 0; i < boot_mem_map.nr_map; i++) {\r\nif (boot_mem_map.map[i].type != BOOT_MEM_ROM_DATA)\r\ncontinue;\r\naddr = boot_mem_map.map[i].addr;\r\nfree_init_pages("YAMON memory",\r\naddr, addr + boot_mem_map.map[i].size);\r\n}\r\n}\r\nunsigned platform_maar_init(unsigned num_pairs)\r\n{\r\nphys_addr_t mem_end = (physical_memsize & ~0xffffull) - 1;\r\nstruct maar_config cfg[] = {\r\n{ 0x00000000, 0x0fffffff, MIPS_MAAR_S },\r\n{ 0x20000000, mem_end, MIPS_MAAR_S },\r\n{ 0x80000000, 0x80000000 + mem_end, MIPS_MAAR_S },\r\n};\r\nunsigned i, num_cfg = ARRAY_SIZE(cfg);\r\nif (physical_memsize <= 0x10000000) {\r\nnum_cfg--;\r\nfor (i = 1; i < num_cfg; i++)\r\ncfg[i] = cfg[i + 1];\r\n}\r\nreturn maar_config(cfg, num_cfg, num_pairs);\r\n}\r\nphys_addr_t mips_cdmm_phys_base(void)\r\n{\r\nreturn 0x1fc10000;\r\n}
