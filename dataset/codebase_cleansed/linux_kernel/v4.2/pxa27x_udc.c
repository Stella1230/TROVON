static int state_dbg_show(struct seq_file *s, void *p)\r\n{\r\nstruct pxa_udc *udc = s->private;\r\nu32 tmp;\r\nif (!udc->driver)\r\nreturn -ENODEV;\r\nseq_printf(s, DRIVER_DESC "\n"\r\n"%s version: %s\n"\r\n"Gadget driver: %s\n",\r\ndriver_name, DRIVER_VERSION,\r\nudc->driver ? udc->driver->driver.name : "(none)");\r\ntmp = udc_readl(udc, UDCCR);\r\nseq_printf(s,\r\n"udccr=0x%0x(%s%s%s%s%s%s%s%s%s%s), con=%d,inter=%d,altinter=%d\n",\r\ntmp,\r\n(tmp & UDCCR_OEN) ? " oen":"",\r\n(tmp & UDCCR_AALTHNP) ? " aalthnp":"",\r\n(tmp & UDCCR_AHNP) ? " rem" : "",\r\n(tmp & UDCCR_BHNP) ? " rstir" : "",\r\n(tmp & UDCCR_DWRE) ? " dwre" : "",\r\n(tmp & UDCCR_SMAC) ? " smac" : "",\r\n(tmp & UDCCR_EMCE) ? " emce" : "",\r\n(tmp & UDCCR_UDR) ? " udr" : "",\r\n(tmp & UDCCR_UDA) ? " uda" : "",\r\n(tmp & UDCCR_UDE) ? " ude" : "",\r\n(tmp & UDCCR_ACN) >> UDCCR_ACN_S,\r\n(tmp & UDCCR_AIN) >> UDCCR_AIN_S,\r\n(tmp & UDCCR_AAISN) >> UDCCR_AAISN_S);\r\nseq_printf(s, "udcicr0=0x%08x udcicr1=0x%08x\n",\r\nudc_readl(udc, UDCICR0), udc_readl(udc, UDCICR1));\r\nseq_printf(s, "udcisr0=0x%08x udcisr1=0x%08x\n",\r\nudc_readl(udc, UDCISR0), udc_readl(udc, UDCISR1));\r\nseq_printf(s, "udcfnr=%d\n", udc_readl(udc, UDCFNR));\r\nseq_printf(s, "irqs: reset=%lu, suspend=%lu, resume=%lu, reconfig=%lu\n",\r\nudc->stats.irqs_reset, udc->stats.irqs_suspend,\r\nudc->stats.irqs_resume, udc->stats.irqs_reconfig);\r\nreturn 0;\r\n}\r\nstatic int queues_dbg_show(struct seq_file *s, void *p)\r\n{\r\nstruct pxa_udc *udc = s->private;\r\nstruct pxa_ep *ep;\r\nstruct pxa27x_request *req;\r\nint i, maxpkt;\r\nif (!udc->driver)\r\nreturn -ENODEV;\r\nfor (i = 0; i < NR_PXA_ENDPOINTS; i++) {\r\nep = &udc->pxa_ep[i];\r\nmaxpkt = ep->fifo_size;\r\nseq_printf(s, "%-12s max_pkt=%d %s\n",\r\nEPNAME(ep), maxpkt, "pio");\r\nif (list_empty(&ep->queue)) {\r\nseq_puts(s, "\t(nothing queued)\n");\r\ncontinue;\r\n}\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\nseq_printf(s, "\treq %p len %d/%d buf %p\n",\r\n&req->req, req->req.actual,\r\nreq->req.length, req->req.buf);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int eps_dbg_show(struct seq_file *s, void *p)\r\n{\r\nstruct pxa_udc *udc = s->private;\r\nstruct pxa_ep *ep;\r\nint i;\r\nu32 tmp;\r\nif (!udc->driver)\r\nreturn -ENODEV;\r\nep = &udc->pxa_ep[0];\r\ntmp = udc_ep_readl(ep, UDCCSR);\r\nseq_printf(s, "udccsr0=0x%03x(%s%s%s%s%s%s%s)\n",\r\ntmp,\r\n(tmp & UDCCSR0_SA) ? " sa" : "",\r\n(tmp & UDCCSR0_RNE) ? " rne" : "",\r\n(tmp & UDCCSR0_FST) ? " fst" : "",\r\n(tmp & UDCCSR0_SST) ? " sst" : "",\r\n(tmp & UDCCSR0_DME) ? " dme" : "",\r\n(tmp & UDCCSR0_IPR) ? " ipr" : "",\r\n(tmp & UDCCSR0_OPC) ? " opc" : "");\r\nfor (i = 0; i < NR_PXA_ENDPOINTS; i++) {\r\nep = &udc->pxa_ep[i];\r\ntmp = i? udc_ep_readl(ep, UDCCR) : udc_readl(udc, UDCCR);\r\nseq_printf(s, "%-12s: IN %lu(%lu reqs), OUT %lu(%lu reqs), irqs=%lu, udccr=0x%08x, udccsr=0x%03x, udcbcr=%d\n",\r\nEPNAME(ep),\r\nep->stats.in_bytes, ep->stats.in_ops,\r\nep->stats.out_bytes, ep->stats.out_ops,\r\nep->stats.irqs,\r\ntmp, udc_ep_readl(ep, UDCCSR),\r\nudc_ep_readl(ep, UDCBCR));\r\n}\r\nreturn 0;\r\n}\r\nstatic int eps_dbg_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, eps_dbg_show, inode->i_private);\r\n}\r\nstatic int queues_dbg_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, queues_dbg_show, inode->i_private);\r\n}\r\nstatic int state_dbg_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, state_dbg_show, inode->i_private);\r\n}\r\nstatic void pxa_init_debugfs(struct pxa_udc *udc)\r\n{\r\nstruct dentry *root, *state, *queues, *eps;\r\nroot = debugfs_create_dir(udc->gadget.name, NULL);\r\nif (IS_ERR(root) || !root)\r\ngoto err_root;\r\nstate = debugfs_create_file("udcstate", 0400, root, udc,\r\n&state_dbg_fops);\r\nif (!state)\r\ngoto err_state;\r\nqueues = debugfs_create_file("queues", 0400, root, udc,\r\n&queues_dbg_fops);\r\nif (!queues)\r\ngoto err_queues;\r\neps = debugfs_create_file("epstate", 0400, root, udc,\r\n&eps_dbg_fops);\r\nif (!eps)\r\ngoto err_eps;\r\nudc->debugfs_root = root;\r\nudc->debugfs_state = state;\r\nudc->debugfs_queues = queues;\r\nudc->debugfs_eps = eps;\r\nreturn;\r\nerr_eps:\r\ndebugfs_remove(eps);\r\nerr_queues:\r\ndebugfs_remove(queues);\r\nerr_state:\r\ndebugfs_remove(root);\r\nerr_root:\r\ndev_err(udc->dev, "debugfs is not available\n");\r\n}\r\nstatic void pxa_cleanup_debugfs(struct pxa_udc *udc)\r\n{\r\ndebugfs_remove(udc->debugfs_eps);\r\ndebugfs_remove(udc->debugfs_queues);\r\ndebugfs_remove(udc->debugfs_state);\r\ndebugfs_remove(udc->debugfs_root);\r\nudc->debugfs_eps = NULL;\r\nudc->debugfs_queues = NULL;\r\nudc->debugfs_state = NULL;\r\nudc->debugfs_root = NULL;\r\n}\r\nstatic inline void pxa_init_debugfs(struct pxa_udc *udc)\r\n{\r\n}\r\nstatic inline void pxa_cleanup_debugfs(struct pxa_udc *udc)\r\n{\r\n}\r\nstatic int is_match_usb_pxa(struct udc_usb_ep *udc_usb_ep, struct pxa_ep *ep,\r\nint config, int interface, int altsetting)\r\n{\r\nif (usb_endpoint_num(&udc_usb_ep->desc) != ep->addr)\r\nreturn 0;\r\nif (usb_endpoint_dir_in(&udc_usb_ep->desc) != ep->dir_in)\r\nreturn 0;\r\nif (usb_endpoint_type(&udc_usb_ep->desc) != ep->type)\r\nreturn 0;\r\nif ((ep->config != config) || (ep->interface != interface)\r\n|| (ep->alternate != altsetting))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic struct pxa_ep *find_pxa_ep(struct pxa_udc *udc,\r\nstruct udc_usb_ep *udc_usb_ep)\r\n{\r\nint i;\r\nstruct pxa_ep *ep;\r\nint cfg = udc->config;\r\nint iface = udc->last_interface;\r\nint alt = udc->last_alternate;\r\nif (udc_usb_ep == &udc->udc_usb_ep[0])\r\nreturn &udc->pxa_ep[0];\r\nfor (i = 1; i < NR_PXA_ENDPOINTS; i++) {\r\nep = &udc->pxa_ep[i];\r\nif (is_match_usb_pxa(udc_usb_ep, ep, cfg, iface, alt))\r\nreturn ep;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void update_pxa_ep_matches(struct pxa_udc *udc)\r\n{\r\nint i;\r\nstruct udc_usb_ep *udc_usb_ep;\r\nfor (i = 1; i < NR_USB_ENDPOINTS; i++) {\r\nudc_usb_ep = &udc->udc_usb_ep[i];\r\nif (udc_usb_ep->pxa_ep)\r\nudc_usb_ep->pxa_ep = find_pxa_ep(udc, udc_usb_ep);\r\n}\r\n}\r\nstatic void pio_irq_enable(struct pxa_ep *ep)\r\n{\r\nstruct pxa_udc *udc = ep->dev;\r\nint index = EPIDX(ep);\r\nu32 udcicr0 = udc_readl(udc, UDCICR0);\r\nu32 udcicr1 = udc_readl(udc, UDCICR1);\r\nif (index < 16)\r\nudc_writel(udc, UDCICR0, udcicr0 | (3 << (index * 2)));\r\nelse\r\nudc_writel(udc, UDCICR1, udcicr1 | (3 << ((index - 16) * 2)));\r\n}\r\nstatic void pio_irq_disable(struct pxa_ep *ep)\r\n{\r\nstruct pxa_udc *udc = ep->dev;\r\nint index = EPIDX(ep);\r\nu32 udcicr0 = udc_readl(udc, UDCICR0);\r\nu32 udcicr1 = udc_readl(udc, UDCICR1);\r\nif (index < 16)\r\nudc_writel(udc, UDCICR0, udcicr0 & ~(3 << (index * 2)));\r\nelse\r\nudc_writel(udc, UDCICR1, udcicr1 & ~(3 << ((index - 16) * 2)));\r\n}\r\nstatic inline void udc_set_mask_UDCCR(struct pxa_udc *udc, int mask)\r\n{\r\nu32 udccr = udc_readl(udc, UDCCR);\r\nudc_writel(udc, UDCCR,\r\n(udccr & UDCCR_MASK_BITS) | (mask & UDCCR_MASK_BITS));\r\n}\r\nstatic inline void udc_clear_mask_UDCCR(struct pxa_udc *udc, int mask)\r\n{\r\nu32 udccr = udc_readl(udc, UDCCR);\r\nudc_writel(udc, UDCCR,\r\n(udccr & UDCCR_MASK_BITS) & ~(mask & UDCCR_MASK_BITS));\r\n}\r\nstatic inline void ep_write_UDCCSR(struct pxa_ep *ep, int mask)\r\n{\r\nif (is_ep0(ep))\r\nmask |= UDCCSR0_ACM;\r\nudc_ep_writel(ep, UDCCSR, mask);\r\n}\r\nstatic int ep_count_bytes_remain(struct pxa_ep *ep)\r\n{\r\nif (ep->dir_in)\r\nreturn -EOPNOTSUPP;\r\nreturn udc_ep_readl(ep, UDCBCR) & 0x3ff;\r\n}\r\nstatic int ep_is_empty(struct pxa_ep *ep)\r\n{\r\nint ret;\r\nif (!is_ep0(ep) && ep->dir_in)\r\nreturn -EOPNOTSUPP;\r\nif (is_ep0(ep))\r\nret = !(udc_ep_readl(ep, UDCCSR) & UDCCSR0_RNE);\r\nelse\r\nret = !(udc_ep_readl(ep, UDCCSR) & UDCCSR_BNE);\r\nreturn ret;\r\n}\r\nstatic int ep_is_full(struct pxa_ep *ep)\r\n{\r\nif (is_ep0(ep))\r\nreturn (udc_ep_readl(ep, UDCCSR) & UDCCSR0_IPR);\r\nif (!ep->dir_in)\r\nreturn -EOPNOTSUPP;\r\nreturn (!(udc_ep_readl(ep, UDCCSR) & UDCCSR_BNF));\r\n}\r\nstatic int epout_has_pkt(struct pxa_ep *ep)\r\n{\r\nif (!is_ep0(ep) && ep->dir_in)\r\nreturn -EOPNOTSUPP;\r\nif (is_ep0(ep))\r\nreturn (udc_ep_readl(ep, UDCCSR) & UDCCSR0_OPC);\r\nreturn (udc_ep_readl(ep, UDCCSR) & UDCCSR_PC);\r\n}\r\nstatic void set_ep0state(struct pxa_udc *udc, int state)\r\n{\r\nstruct pxa_ep *ep = &udc->pxa_ep[0];\r\nchar *old_stname = EP0_STNAME(udc);\r\nudc->ep0state = state;\r\nep_dbg(ep, "state=%s->%s, udccsr0=0x%03x, udcbcr=%d\n", old_stname,\r\nEP0_STNAME(udc), udc_ep_readl(ep, UDCCSR),\r\nudc_ep_readl(ep, UDCBCR));\r\n}\r\nstatic void ep0_idle(struct pxa_udc *dev)\r\n{\r\nset_ep0state(dev, WAIT_FOR_SETUP);\r\n}\r\nstatic void inc_ep_stats_reqs(struct pxa_ep *ep, int is_in)\r\n{\r\nif (is_in)\r\nep->stats.in_ops++;\r\nelse\r\nep->stats.out_ops++;\r\n}\r\nstatic void inc_ep_stats_bytes(struct pxa_ep *ep, int count, int is_in)\r\n{\r\nif (is_in)\r\nep->stats.in_bytes += count;\r\nelse\r\nep->stats.out_bytes += count;\r\n}\r\nstatic void pxa_ep_setup(struct pxa_ep *ep)\r\n{\r\nu32 new_udccr;\r\nnew_udccr = ((ep->config << UDCCONR_CN_S) & UDCCONR_CN)\r\n| ((ep->interface << UDCCONR_IN_S) & UDCCONR_IN)\r\n| ((ep->alternate << UDCCONR_AISN_S) & UDCCONR_AISN)\r\n| ((EPADDR(ep) << UDCCONR_EN_S) & UDCCONR_EN)\r\n| ((EPXFERTYPE(ep) << UDCCONR_ET_S) & UDCCONR_ET)\r\n| ((ep->dir_in) ? UDCCONR_ED : 0)\r\n| ((ep->fifo_size << UDCCONR_MPS_S) & UDCCONR_MPS)\r\n| UDCCONR_EE;\r\nudc_ep_writel(ep, UDCCR, new_udccr);\r\n}\r\nstatic void pxa_eps_setup(struct pxa_udc *dev)\r\n{\r\nunsigned int i;\r\ndev_dbg(dev->dev, "%s: dev=%p\n", __func__, dev);\r\nfor (i = 1; i < NR_PXA_ENDPOINTS; i++)\r\npxa_ep_setup(&dev->pxa_ep[i]);\r\n}\r\nstatic struct usb_request *\r\npxa_ep_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)\r\n{\r\nstruct pxa27x_request *req;\r\nreq = kzalloc(sizeof *req, gfp_flags);\r\nif (!req)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&req->queue);\r\nreq->in_use = 0;\r\nreq->udc_usb_ep = container_of(_ep, struct udc_usb_ep, usb_ep);\r\nreturn &req->req;\r\n}\r\nstatic void pxa_ep_free_request(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct pxa27x_request *req;\r\nreq = container_of(_req, struct pxa27x_request, req);\r\nWARN_ON(!list_empty(&req->queue));\r\nkfree(req);\r\n}\r\nstatic void ep_add_request(struct pxa_ep *ep, struct pxa27x_request *req)\r\n{\r\nif (unlikely(!req))\r\nreturn;\r\nep_vdbg(ep, "req:%p, lg=%d, udccsr=0x%03x\n", req,\r\nreq->req.length, udc_ep_readl(ep, UDCCSR));\r\nreq->in_use = 1;\r\nlist_add_tail(&req->queue, &ep->queue);\r\npio_irq_enable(ep);\r\n}\r\nstatic void ep_del_request(struct pxa_ep *ep, struct pxa27x_request *req)\r\n{\r\nif (unlikely(!req))\r\nreturn;\r\nep_vdbg(ep, "req:%p, lg=%d, udccsr=0x%03x\n", req,\r\nreq->req.length, udc_ep_readl(ep, UDCCSR));\r\nlist_del_init(&req->queue);\r\nreq->in_use = 0;\r\nif (!is_ep0(ep) && list_empty(&ep->queue))\r\npio_irq_disable(ep);\r\n}\r\nstatic void req_done(struct pxa_ep *ep, struct pxa27x_request *req, int status,\r\nunsigned long *pflags)\r\n{\r\nunsigned long flags;\r\nep_del_request(ep, req);\r\nif (likely(req->req.status == -EINPROGRESS))\r\nreq->req.status = status;\r\nelse\r\nstatus = req->req.status;\r\nif (status && status != -ESHUTDOWN)\r\nep_dbg(ep, "complete req %p stat %d len %u/%u\n",\r\n&req->req, status,\r\nreq->req.actual, req->req.length);\r\nif (pflags)\r\nspin_unlock_irqrestore(&ep->lock, *pflags);\r\nlocal_irq_save(flags);\r\nusb_gadget_giveback_request(&req->udc_usb_ep->usb_ep, &req->req);\r\nlocal_irq_restore(flags);\r\nif (pflags)\r\nspin_lock_irqsave(&ep->lock, *pflags);\r\n}\r\nstatic void ep_end_out_req(struct pxa_ep *ep, struct pxa27x_request *req,\r\nunsigned long *pflags)\r\n{\r\ninc_ep_stats_reqs(ep, !USB_DIR_IN);\r\nreq_done(ep, req, 0, pflags);\r\n}\r\nstatic void ep0_end_out_req(struct pxa_ep *ep, struct pxa27x_request *req,\r\nunsigned long *pflags)\r\n{\r\nset_ep0state(ep->dev, OUT_STATUS_STAGE);\r\nep_end_out_req(ep, req, pflags);\r\nep0_idle(ep->dev);\r\n}\r\nstatic void ep_end_in_req(struct pxa_ep *ep, struct pxa27x_request *req,\r\nunsigned long *pflags)\r\n{\r\ninc_ep_stats_reqs(ep, USB_DIR_IN);\r\nreq_done(ep, req, 0, pflags);\r\n}\r\nstatic void ep0_end_in_req(struct pxa_ep *ep, struct pxa27x_request *req,\r\nunsigned long *pflags)\r\n{\r\nset_ep0state(ep->dev, IN_STATUS_STAGE);\r\nep_end_in_req(ep, req, pflags);\r\n}\r\nstatic void nuke(struct pxa_ep *ep, int status)\r\n{\r\nstruct pxa27x_request *req;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ep->lock, flags);\r\nwhile (!list_empty(&ep->queue)) {\r\nreq = list_entry(ep->queue.next, struct pxa27x_request, queue);\r\nreq_done(ep, req, status, &flags);\r\n}\r\nspin_unlock_irqrestore(&ep->lock, flags);\r\n}\r\nstatic int read_packet(struct pxa_ep *ep, struct pxa27x_request *req)\r\n{\r\nu32 *buf;\r\nint bytes_ep, bufferspace, count, i;\r\nbytes_ep = ep_count_bytes_remain(ep);\r\nbufferspace = req->req.length - req->req.actual;\r\nbuf = (u32 *)(req->req.buf + req->req.actual);\r\nprefetchw(buf);\r\nif (likely(!ep_is_empty(ep)))\r\ncount = min(bytes_ep, bufferspace);\r\nelse\r\ncount = 0;\r\nfor (i = count; i > 0; i -= 4)\r\n*buf++ = udc_ep_readl(ep, UDCDR);\r\nreq->req.actual += count;\r\nep_write_UDCCSR(ep, UDCCSR_PC);\r\nreturn count;\r\n}\r\nstatic int write_packet(struct pxa_ep *ep, struct pxa27x_request *req,\r\nunsigned int max)\r\n{\r\nint length, count, remain, i;\r\nu32 *buf;\r\nu8 *buf_8;\r\nbuf = (u32 *)(req->req.buf + req->req.actual);\r\nprefetch(buf);\r\nlength = min(req->req.length - req->req.actual, max);\r\nreq->req.actual += length;\r\nremain = length & 0x3;\r\ncount = length & ~(0x3);\r\nfor (i = count; i > 0 ; i -= 4)\r\nudc_ep_writel(ep, UDCDR, *buf++);\r\nbuf_8 = (u8 *)buf;\r\nfor (i = remain; i > 0; i--)\r\nudc_ep_writeb(ep, UDCDR, *buf_8++);\r\nep_vdbg(ep, "length=%d+%d, udccsr=0x%03x\n", count, remain,\r\nudc_ep_readl(ep, UDCCSR));\r\nreturn length;\r\n}\r\nstatic int read_fifo(struct pxa_ep *ep, struct pxa27x_request *req)\r\n{\r\nint count, is_short, completed = 0;\r\nwhile (epout_has_pkt(ep)) {\r\ncount = read_packet(ep, req);\r\ninc_ep_stats_bytes(ep, count, !USB_DIR_IN);\r\nis_short = (count < ep->fifo_size);\r\nep_dbg(ep, "read udccsr:%03x, count:%d bytes%s req %p %d/%d\n",\r\nudc_ep_readl(ep, UDCCSR), count, is_short ? "/S" : "",\r\n&req->req, req->req.actual, req->req.length);\r\nif (is_short || req->req.actual == req->req.length) {\r\ncompleted = 1;\r\nbreak;\r\n}\r\n}\r\nreturn completed;\r\n}\r\nstatic int write_fifo(struct pxa_ep *ep, struct pxa27x_request *req)\r\n{\r\nunsigned max;\r\nint count, is_short, is_last = 0, completed = 0, totcount = 0;\r\nu32 udccsr;\r\nmax = ep->fifo_size;\r\ndo {\r\nis_short = 0;\r\nudccsr = udc_ep_readl(ep, UDCCSR);\r\nif (udccsr & UDCCSR_PC) {\r\nep_vdbg(ep, "Clearing Transmit Complete, udccsr=%x\n",\r\nudccsr);\r\nep_write_UDCCSR(ep, UDCCSR_PC);\r\n}\r\nif (udccsr & UDCCSR_TRN) {\r\nep_vdbg(ep, "Clearing Underrun on, udccsr=%x\n",\r\nudccsr);\r\nep_write_UDCCSR(ep, UDCCSR_TRN);\r\n}\r\ncount = write_packet(ep, req, max);\r\ninc_ep_stats_bytes(ep, count, USB_DIR_IN);\r\ntotcount += count;\r\nif (unlikely(count < max)) {\r\nis_last = 1;\r\nis_short = 1;\r\n} else {\r\nif (likely(req->req.length > req->req.actual)\r\n|| req->req.zero)\r\nis_last = 0;\r\nelse\r\nis_last = 1;\r\nis_short = unlikely(max < ep->fifo_size);\r\n}\r\nif (is_short)\r\nep_write_UDCCSR(ep, UDCCSR_SP);\r\nif (is_last) {\r\ncompleted = 1;\r\nbreak;\r\n}\r\n} while (!ep_is_full(ep));\r\nep_dbg(ep, "wrote count:%d bytes%s%s, left:%d req=%p\n",\r\ntotcount, is_last ? "/L" : "", is_short ? "/S" : "",\r\nreq->req.length - req->req.actual, &req->req);\r\nreturn completed;\r\n}\r\nstatic int read_ep0_fifo(struct pxa_ep *ep, struct pxa27x_request *req)\r\n{\r\nint count, is_short, completed = 0;\r\nwhile (epout_has_pkt(ep)) {\r\ncount = read_packet(ep, req);\r\nep_write_UDCCSR(ep, UDCCSR0_OPC);\r\ninc_ep_stats_bytes(ep, count, !USB_DIR_IN);\r\nis_short = (count < ep->fifo_size);\r\nep_dbg(ep, "read udccsr:%03x, count:%d bytes%s req %p %d/%d\n",\r\nudc_ep_readl(ep, UDCCSR), count, is_short ? "/S" : "",\r\n&req->req, req->req.actual, req->req.length);\r\nif (is_short || req->req.actual >= req->req.length) {\r\ncompleted = 1;\r\nbreak;\r\n}\r\n}\r\nreturn completed;\r\n}\r\nstatic int write_ep0_fifo(struct pxa_ep *ep, struct pxa27x_request *req)\r\n{\r\nunsigned count;\r\nint is_last, is_short;\r\ncount = write_packet(ep, req, EP0_FIFO_SIZE);\r\ninc_ep_stats_bytes(ep, count, USB_DIR_IN);\r\nis_short = (count < EP0_FIFO_SIZE);\r\nis_last = ((count == 0) || (count < EP0_FIFO_SIZE));\r\nif (unlikely(is_short))\r\nep_write_UDCCSR(ep, UDCCSR0_IPR);\r\nep_dbg(ep, "in %d bytes%s%s, %d left, req=%p, udccsr0=0x%03x\n",\r\ncount, is_short ? "/S" : "", is_last ? "/L" : "",\r\nreq->req.length - req->req.actual,\r\n&req->req, udc_ep_readl(ep, UDCCSR));\r\nreturn is_last;\r\n}\r\nstatic int pxa_ep_queue(struct usb_ep *_ep, struct usb_request *_req,\r\ngfp_t gfp_flags)\r\n{\r\nstruct udc_usb_ep *udc_usb_ep;\r\nstruct pxa_ep *ep;\r\nstruct pxa27x_request *req;\r\nstruct pxa_udc *dev;\r\nunsigned long flags;\r\nint rc = 0;\r\nint is_first_req;\r\nunsigned length;\r\nint recursion_detected;\r\nreq = container_of(_req, struct pxa27x_request, req);\r\nudc_usb_ep = container_of(_ep, struct udc_usb_ep, usb_ep);\r\nif (unlikely(!_req || !_req->complete || !_req->buf))\r\nreturn -EINVAL;\r\nif (unlikely(!_ep))\r\nreturn -EINVAL;\r\ndev = udc_usb_ep->dev;\r\nep = udc_usb_ep->pxa_ep;\r\nif (unlikely(!ep))\r\nreturn -EINVAL;\r\ndev = ep->dev;\r\nif (unlikely(!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)) {\r\nep_dbg(ep, "bogus device state\n");\r\nreturn -ESHUTDOWN;\r\n}\r\nif (unlikely(EPXFERTYPE_is_ISO(ep)\r\n&& req->req.length > ep->fifo_size))\r\nreturn -EMSGSIZE;\r\nspin_lock_irqsave(&ep->lock, flags);\r\nrecursion_detected = ep->in_handle_ep;\r\nis_first_req = list_empty(&ep->queue);\r\nep_dbg(ep, "queue req %p(first=%s), len %d buf %p\n",\r\n_req, is_first_req ? "yes" : "no",\r\n_req->length, _req->buf);\r\nif (!ep->enabled) {\r\n_req->status = -ESHUTDOWN;\r\nrc = -ESHUTDOWN;\r\ngoto out_locked;\r\n}\r\nif (req->in_use) {\r\nep_err(ep, "refusing to queue req %p (already queued)\n", req);\r\ngoto out_locked;\r\n}\r\nlength = _req->length;\r\n_req->status = -EINPROGRESS;\r\n_req->actual = 0;\r\nep_add_request(ep, req);\r\nspin_unlock_irqrestore(&ep->lock, flags);\r\nif (is_ep0(ep)) {\r\nswitch (dev->ep0state) {\r\ncase WAIT_ACK_SET_CONF_INTERF:\r\nif (length == 0) {\r\nep_end_in_req(ep, req, NULL);\r\n} else {\r\nep_err(ep, "got a request of %d bytes while"\r\n"in state WAIT_ACK_SET_CONF_INTERF\n",\r\nlength);\r\nep_del_request(ep, req);\r\nrc = -EL2HLT;\r\n}\r\nep0_idle(ep->dev);\r\nbreak;\r\ncase IN_DATA_STAGE:\r\nif (!ep_is_full(ep))\r\nif (write_ep0_fifo(ep, req))\r\nep0_end_in_req(ep, req, NULL);\r\nbreak;\r\ncase OUT_DATA_STAGE:\r\nif ((length == 0) || !epout_has_pkt(ep))\r\nif (read_ep0_fifo(ep, req))\r\nep0_end_out_req(ep, req, NULL);\r\nbreak;\r\ndefault:\r\nep_err(ep, "odd state %s to send me a request\n",\r\nEP0_STNAME(ep->dev));\r\nep_del_request(ep, req);\r\nrc = -EL2HLT;\r\nbreak;\r\n}\r\n} else {\r\nif (!recursion_detected)\r\nhandle_ep(ep);\r\n}\r\nout:\r\nreturn rc;\r\nout_locked:\r\nspin_unlock_irqrestore(&ep->lock, flags);\r\ngoto out;\r\n}\r\nstatic int pxa_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct pxa_ep *ep;\r\nstruct udc_usb_ep *udc_usb_ep;\r\nstruct pxa27x_request *req;\r\nunsigned long flags;\r\nint rc = -EINVAL;\r\nif (!_ep)\r\nreturn rc;\r\nudc_usb_ep = container_of(_ep, struct udc_usb_ep, usb_ep);\r\nep = udc_usb_ep->pxa_ep;\r\nif (!ep || is_ep0(ep))\r\nreturn rc;\r\nspin_lock_irqsave(&ep->lock, flags);\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\nif (&req->req == _req) {\r\nrc = 0;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&ep->lock, flags);\r\nif (!rc)\r\nreq_done(ep, req, -ECONNRESET, NULL);\r\nreturn rc;\r\n}\r\nstatic int pxa_ep_set_halt(struct usb_ep *_ep, int value)\r\n{\r\nstruct pxa_ep *ep;\r\nstruct udc_usb_ep *udc_usb_ep;\r\nunsigned long flags;\r\nint rc;\r\nif (!_ep)\r\nreturn -EINVAL;\r\nudc_usb_ep = container_of(_ep, struct udc_usb_ep, usb_ep);\r\nep = udc_usb_ep->pxa_ep;\r\nif (!ep || is_ep0(ep))\r\nreturn -EINVAL;\r\nif (value == 0) {\r\nep_dbg(ep, "only host can clear halt\n");\r\nreturn -EROFS;\r\n}\r\nspin_lock_irqsave(&ep->lock, flags);\r\nrc = -EAGAIN;\r\nif (ep->dir_in && (ep_is_full(ep) || !list_empty(&ep->queue)))\r\ngoto out;\r\nrc = 0;\r\nep_write_UDCCSR(ep, UDCCSR_FST | UDCCSR_FEF);\r\nif (is_ep0(ep))\r\nset_ep0state(ep->dev, STALL);\r\nout:\r\nspin_unlock_irqrestore(&ep->lock, flags);\r\nreturn rc;\r\n}\r\nstatic int pxa_ep_fifo_status(struct usb_ep *_ep)\r\n{\r\nstruct pxa_ep *ep;\r\nstruct udc_usb_ep *udc_usb_ep;\r\nif (!_ep)\r\nreturn -ENODEV;\r\nudc_usb_ep = container_of(_ep, struct udc_usb_ep, usb_ep);\r\nep = udc_usb_ep->pxa_ep;\r\nif (!ep || is_ep0(ep))\r\nreturn -ENODEV;\r\nif (ep->dir_in)\r\nreturn -EOPNOTSUPP;\r\nif (ep->dev->gadget.speed == USB_SPEED_UNKNOWN || ep_is_empty(ep))\r\nreturn 0;\r\nelse\r\nreturn ep_count_bytes_remain(ep) + 1;\r\n}\r\nstatic void pxa_ep_fifo_flush(struct usb_ep *_ep)\r\n{\r\nstruct pxa_ep *ep;\r\nstruct udc_usb_ep *udc_usb_ep;\r\nunsigned long flags;\r\nif (!_ep)\r\nreturn;\r\nudc_usb_ep = container_of(_ep, struct udc_usb_ep, usb_ep);\r\nep = udc_usb_ep->pxa_ep;\r\nif (!ep || is_ep0(ep))\r\nreturn;\r\nspin_lock_irqsave(&ep->lock, flags);\r\nif (unlikely(!list_empty(&ep->queue)))\r\nep_dbg(ep, "called while queue list not empty\n");\r\nep_dbg(ep, "called\n");\r\nif (!ep->dir_in) {\r\nwhile (!ep_is_empty(ep))\r\nudc_ep_readl(ep, UDCDR);\r\n} else {\r\nep_write_UDCCSR(ep,\r\nUDCCSR_PC | UDCCSR_FEF | UDCCSR_TRN\r\n| (EPXFERTYPE_is_ISO(ep) ? 0 : UDCCSR_SST));\r\n}\r\nspin_unlock_irqrestore(&ep->lock, flags);\r\n}\r\nstatic int pxa_ep_enable(struct usb_ep *_ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct pxa_ep *ep;\r\nstruct udc_usb_ep *udc_usb_ep;\r\nstruct pxa_udc *udc;\r\nif (!_ep || !desc)\r\nreturn -EINVAL;\r\nudc_usb_ep = container_of(_ep, struct udc_usb_ep, usb_ep);\r\nif (udc_usb_ep->pxa_ep) {\r\nep = udc_usb_ep->pxa_ep;\r\nep_warn(ep, "usb_ep %s already enabled, doing nothing\n",\r\n_ep->name);\r\n} else {\r\nep = find_pxa_ep(udc_usb_ep->dev, udc_usb_ep);\r\n}\r\nif (!ep || is_ep0(ep)) {\r\ndev_err(udc_usb_ep->dev->dev,\r\n"unable to match pxa_ep for ep %s\n",\r\n_ep->name);\r\nreturn -EINVAL;\r\n}\r\nif ((desc->bDescriptorType != USB_DT_ENDPOINT)\r\n|| (ep->type != usb_endpoint_type(desc))) {\r\nep_err(ep, "type mismatch\n");\r\nreturn -EINVAL;\r\n}\r\nif (ep->fifo_size < usb_endpoint_maxp(desc)) {\r\nep_err(ep, "bad maxpacket\n");\r\nreturn -ERANGE;\r\n}\r\nudc_usb_ep->pxa_ep = ep;\r\nudc = ep->dev;\r\nif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN) {\r\nep_err(ep, "bogus device state\n");\r\nreturn -ESHUTDOWN;\r\n}\r\nep->enabled = 1;\r\npxa_ep_fifo_flush(_ep);\r\nep_dbg(ep, "enabled\n");\r\nreturn 0;\r\n}\r\nstatic int pxa_ep_disable(struct usb_ep *_ep)\r\n{\r\nstruct pxa_ep *ep;\r\nstruct udc_usb_ep *udc_usb_ep;\r\nif (!_ep)\r\nreturn -EINVAL;\r\nudc_usb_ep = container_of(_ep, struct udc_usb_ep, usb_ep);\r\nep = udc_usb_ep->pxa_ep;\r\nif (!ep || is_ep0(ep) || !list_empty(&ep->queue))\r\nreturn -EINVAL;\r\nep->enabled = 0;\r\nnuke(ep, -ESHUTDOWN);\r\npxa_ep_fifo_flush(_ep);\r\nudc_usb_ep->pxa_ep = NULL;\r\nep_dbg(ep, "disabled\n");\r\nreturn 0;\r\n}\r\nstatic void dplus_pullup(struct pxa_udc *udc, int on)\r\n{\r\nif (udc->gpiod) {\r\ngpiod_set_value(udc->gpiod, on);\r\n} else if (udc->udc_command) {\r\nif (on)\r\nudc->udc_command(PXA2XX_UDC_CMD_CONNECT);\r\nelse\r\nudc->udc_command(PXA2XX_UDC_CMD_DISCONNECT);\r\n}\r\nudc->pullup_on = on;\r\n}\r\nstatic int pxa_udc_get_frame(struct usb_gadget *_gadget)\r\n{\r\nstruct pxa_udc *udc = to_gadget_udc(_gadget);\r\nreturn (udc_readl(udc, UDCFNR) & 0x7ff);\r\n}\r\nstatic int pxa_udc_wakeup(struct usb_gadget *_gadget)\r\n{\r\nstruct pxa_udc *udc = to_gadget_udc(_gadget);\r\nif ((udc_readl(udc, UDCCR) & UDCCR_DWRE) == 0)\r\nreturn -EHOSTUNREACH;\r\nudc_set_mask_UDCCR(udc, UDCCR_UDR);\r\nreturn 0;\r\n}\r\nstatic int should_enable_udc(struct pxa_udc *udc)\r\n{\r\nint put_on;\r\nput_on = ((udc->pullup_on) && (udc->driver));\r\nput_on &= ((udc->vbus_sensed) || (IS_ERR_OR_NULL(udc->transceiver)));\r\nreturn put_on;\r\n}\r\nstatic int should_disable_udc(struct pxa_udc *udc)\r\n{\r\nint put_off;\r\nput_off = ((!udc->pullup_on) || (!udc->driver));\r\nput_off |= ((!udc->vbus_sensed) && (!IS_ERR_OR_NULL(udc->transceiver)));\r\nreturn put_off;\r\n}\r\nstatic int pxa_udc_pullup(struct usb_gadget *_gadget, int is_active)\r\n{\r\nstruct pxa_udc *udc = to_gadget_udc(_gadget);\r\nif (!udc->gpiod && !udc->udc_command)\r\nreturn -EOPNOTSUPP;\r\ndplus_pullup(udc, is_active);\r\nif (should_enable_udc(udc))\r\nudc_enable(udc);\r\nif (should_disable_udc(udc))\r\nudc_disable(udc);\r\nreturn 0;\r\n}\r\nstatic int pxa_udc_vbus_session(struct usb_gadget *_gadget, int is_active)\r\n{\r\nstruct pxa_udc *udc = to_gadget_udc(_gadget);\r\nudc->vbus_sensed = is_active;\r\nif (should_enable_udc(udc))\r\nudc_enable(udc);\r\nif (should_disable_udc(udc))\r\nudc_disable(udc);\r\nreturn 0;\r\n}\r\nstatic int pxa_udc_vbus_draw(struct usb_gadget *_gadget, unsigned mA)\r\n{\r\nstruct pxa_udc *udc;\r\nudc = to_gadget_udc(_gadget);\r\nif (!IS_ERR_OR_NULL(udc->transceiver))\r\nreturn usb_phy_set_power(udc->transceiver, mA);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic void udc_disable(struct pxa_udc *udc)\r\n{\r\nif (!udc->enabled)\r\nreturn;\r\nudc_writel(udc, UDCICR0, 0);\r\nudc_writel(udc, UDCICR1, 0);\r\nudc_clear_mask_UDCCR(udc, UDCCR_UDE);\r\nep0_idle(udc);\r\nudc->gadget.speed = USB_SPEED_UNKNOWN;\r\nclk_disable(udc->clk);\r\nudc->enabled = 0;\r\n}\r\nstatic void udc_init_data(struct pxa_udc *dev)\r\n{\r\nint i;\r\nstruct pxa_ep *ep;\r\nINIT_LIST_HEAD(&dev->gadget.ep_list);\r\nINIT_LIST_HEAD(&dev->gadget.ep0->ep_list);\r\ndev->udc_usb_ep[0].pxa_ep = &dev->pxa_ep[0];\r\nep0_idle(dev);\r\nfor (i = 0; i < NR_PXA_ENDPOINTS; i++) {\r\nep = &dev->pxa_ep[i];\r\nep->enabled = is_ep0(ep);\r\nINIT_LIST_HEAD(&ep->queue);\r\nspin_lock_init(&ep->lock);\r\n}\r\nfor (i = 1; i < NR_USB_ENDPOINTS; i++) {\r\nlist_add_tail(&dev->udc_usb_ep[i].usb_ep.ep_list,\r\n&dev->gadget.ep_list);\r\nusb_ep_set_maxpacket_limit(&dev->udc_usb_ep[i].usb_ep,\r\ndev->udc_usb_ep[i].usb_ep.maxpacket);\r\n}\r\n}\r\nstatic void udc_enable(struct pxa_udc *udc)\r\n{\r\nif (udc->enabled)\r\nreturn;\r\nclk_enable(udc->clk);\r\nudc_writel(udc, UDCICR0, 0);\r\nudc_writel(udc, UDCICR1, 0);\r\nudc_clear_mask_UDCCR(udc, UDCCR_UDE);\r\nep0_idle(udc);\r\nudc->gadget.speed = USB_SPEED_FULL;\r\nmemset(&udc->stats, 0, sizeof(udc->stats));\r\npxa_eps_setup(udc);\r\nudc_set_mask_UDCCR(udc, UDCCR_UDE);\r\nep_write_UDCCSR(&udc->pxa_ep[0], UDCCSR0_ACM);\r\nudelay(2);\r\nif (udc_readl(udc, UDCCR) & UDCCR_EMCE)\r\ndev_err(udc->dev, "Configuration errors, udc disabled\n");\r\nmsleep(100);\r\nudc_writel(udc, UDCICR1,\r\nUDCICR1_IECC | UDCICR1_IERU\r\n| UDCICR1_IESU | UDCICR1_IERS);\r\npio_irq_enable(&udc->pxa_ep[0]);\r\nudc->enabled = 1;\r\n}\r\nstatic int pxa27x_udc_start(struct usb_gadget *g,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct pxa_udc *udc = to_pxa(g);\r\nint retval;\r\nudc->driver = driver;\r\nif (!IS_ERR_OR_NULL(udc->transceiver)) {\r\nretval = otg_set_peripheral(udc->transceiver->otg,\r\n&udc->gadget);\r\nif (retval) {\r\ndev_err(udc->dev, "can't bind to transceiver\n");\r\ngoto fail;\r\n}\r\n}\r\nif (should_enable_udc(udc))\r\nudc_enable(udc);\r\nreturn 0;\r\nfail:\r\nudc->driver = NULL;\r\nreturn retval;\r\n}\r\nstatic void stop_activity(struct pxa_udc *udc, struct usb_gadget_driver *driver)\r\n{\r\nint i;\r\nif (udc->gadget.speed == USB_SPEED_UNKNOWN)\r\ndriver = NULL;\r\nudc->gadget.speed = USB_SPEED_UNKNOWN;\r\nfor (i = 0; i < NR_USB_ENDPOINTS; i++)\r\npxa_ep_disable(&udc->udc_usb_ep[i].usb_ep);\r\n}\r\nstatic int pxa27x_udc_stop(struct usb_gadget *g)\r\n{\r\nstruct pxa_udc *udc = to_pxa(g);\r\nstop_activity(udc, NULL);\r\nudc_disable(udc);\r\nudc->driver = NULL;\r\nif (!IS_ERR_OR_NULL(udc->transceiver))\r\nreturn otg_set_peripheral(udc->transceiver->otg, NULL);\r\nreturn 0;\r\n}\r\nstatic void handle_ep0_ctrl_req(struct pxa_udc *udc,\r\nstruct pxa27x_request *req)\r\n{\r\nstruct pxa_ep *ep = &udc->pxa_ep[0];\r\nunion {\r\nstruct usb_ctrlrequest r;\r\nu32 word[2];\r\n} u;\r\nint i;\r\nint have_extrabytes = 0;\r\nunsigned long flags;\r\nnuke(ep, -EPROTO);\r\nspin_lock_irqsave(&ep->lock, flags);\r\nif (epout_has_pkt(ep) && (ep_count_bytes_remain(ep) == 0))\r\nep_write_UDCCSR(ep, UDCCSR0_OPC);\r\nfor (i = 0; i < 2; i++) {\r\nif (unlikely(ep_is_empty(ep)))\r\ngoto stall;\r\nu.word[i] = udc_ep_readl(ep, UDCDR);\r\n}\r\nhave_extrabytes = !ep_is_empty(ep);\r\nwhile (!ep_is_empty(ep)) {\r\ni = udc_ep_readl(ep, UDCDR);\r\nep_err(ep, "wrong to have extra bytes for setup : 0x%08x\n", i);\r\n}\r\nep_dbg(ep, "SETUP %02x.%02x v%04x i%04x l%04x\n",\r\nu.r.bRequestType, u.r.bRequest,\r\nle16_to_cpu(u.r.wValue), le16_to_cpu(u.r.wIndex),\r\nle16_to_cpu(u.r.wLength));\r\nif (unlikely(have_extrabytes))\r\ngoto stall;\r\nif (u.r.bRequestType & USB_DIR_IN)\r\nset_ep0state(udc, IN_DATA_STAGE);\r\nelse\r\nset_ep0state(udc, OUT_DATA_STAGE);\r\nep_write_UDCCSR(ep, UDCCSR0_SA | UDCCSR0_OPC);\r\nspin_unlock_irqrestore(&ep->lock, flags);\r\ni = udc->driver->setup(&udc->gadget, &u.r);\r\nspin_lock_irqsave(&ep->lock, flags);\r\nif (i < 0)\r\ngoto stall;\r\nout:\r\nspin_unlock_irqrestore(&ep->lock, flags);\r\nreturn;\r\nstall:\r\nep_dbg(ep, "protocol STALL, udccsr0=%03x err %d\n",\r\nudc_ep_readl(ep, UDCCSR), i);\r\nep_write_UDCCSR(ep, UDCCSR0_FST | UDCCSR0_FTF);\r\nset_ep0state(udc, STALL);\r\ngoto out;\r\n}\r\nstatic void handle_ep0(struct pxa_udc *udc, int fifo_irq, int opc_irq)\r\n{\r\nu32 udccsr0;\r\nstruct pxa_ep *ep = &udc->pxa_ep[0];\r\nstruct pxa27x_request *req = NULL;\r\nint completed = 0;\r\nif (!list_empty(&ep->queue))\r\nreq = list_entry(ep->queue.next, struct pxa27x_request, queue);\r\nudccsr0 = udc_ep_readl(ep, UDCCSR);\r\nep_dbg(ep, "state=%s, req=%p, udccsr0=0x%03x, udcbcr=%d, irq_msk=%x\n",\r\nEP0_STNAME(udc), req, udccsr0, udc_ep_readl(ep, UDCBCR),\r\n(fifo_irq << 1 | opc_irq));\r\nif (udccsr0 & UDCCSR0_SST) {\r\nep_dbg(ep, "clearing stall status\n");\r\nnuke(ep, -EPIPE);\r\nep_write_UDCCSR(ep, UDCCSR0_SST);\r\nep0_idle(udc);\r\n}\r\nif (udccsr0 & UDCCSR0_SA) {\r\nnuke(ep, 0);\r\nset_ep0state(udc, SETUP_STAGE);\r\n}\r\nswitch (udc->ep0state) {\r\ncase WAIT_FOR_SETUP:\r\nbreak;\r\ncase SETUP_STAGE:\r\nudccsr0 &= UDCCSR0_CTRL_REQ_MASK;\r\nif (likely(udccsr0 == UDCCSR0_CTRL_REQ_MASK))\r\nhandle_ep0_ctrl_req(udc, req);\r\nbreak;\r\ncase IN_DATA_STAGE:\r\nif (epout_has_pkt(ep))\r\nep_write_UDCCSR(ep, UDCCSR0_OPC);\r\nif (req && !ep_is_full(ep))\r\ncompleted = write_ep0_fifo(ep, req);\r\nif (completed)\r\nep0_end_in_req(ep, req, NULL);\r\nbreak;\r\ncase OUT_DATA_STAGE:\r\nif (epout_has_pkt(ep) && req)\r\ncompleted = read_ep0_fifo(ep, req);\r\nif (completed)\r\nep0_end_out_req(ep, req, NULL);\r\nbreak;\r\ncase STALL:\r\nep_write_UDCCSR(ep, UDCCSR0_FST);\r\nbreak;\r\ncase IN_STATUS_STAGE:\r\nif (opc_irq)\r\nep0_idle(udc);\r\nbreak;\r\ncase OUT_STATUS_STAGE:\r\ncase WAIT_ACK_SET_CONF_INTERF:\r\nep_warn(ep, "should never get in %s state here!!!\n",\r\nEP0_STNAME(ep->dev));\r\nep0_idle(udc);\r\nbreak;\r\n}\r\n}\r\nstatic void handle_ep(struct pxa_ep *ep)\r\n{\r\nstruct pxa27x_request *req;\r\nint completed;\r\nu32 udccsr;\r\nint is_in = ep->dir_in;\r\nint loop = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ep->lock, flags);\r\nif (ep->in_handle_ep)\r\ngoto recursion_detected;\r\nep->in_handle_ep = 1;\r\ndo {\r\ncompleted = 0;\r\nudccsr = udc_ep_readl(ep, UDCCSR);\r\nif (likely(!list_empty(&ep->queue)))\r\nreq = list_entry(ep->queue.next,\r\nstruct pxa27x_request, queue);\r\nelse\r\nreq = NULL;\r\nep_dbg(ep, "req:%p, udccsr 0x%03x loop=%d\n",\r\nreq, udccsr, loop++);\r\nif (unlikely(udccsr & (UDCCSR_SST | UDCCSR_TRN)))\r\nudc_ep_writel(ep, UDCCSR,\r\nudccsr & (UDCCSR_SST | UDCCSR_TRN));\r\nif (!req)\r\nbreak;\r\nif (unlikely(is_in)) {\r\nif (likely(!ep_is_full(ep)))\r\ncompleted = write_fifo(ep, req);\r\n} else {\r\nif (likely(epout_has_pkt(ep)))\r\ncompleted = read_fifo(ep, req);\r\n}\r\nif (completed) {\r\nif (is_in)\r\nep_end_in_req(ep, req, &flags);\r\nelse\r\nep_end_out_req(ep, req, &flags);\r\n}\r\n} while (completed);\r\nep->in_handle_ep = 0;\r\nrecursion_detected:\r\nspin_unlock_irqrestore(&ep->lock, flags);\r\n}\r\nstatic void pxa27x_change_configuration(struct pxa_udc *udc, int config)\r\n{\r\nstruct usb_ctrlrequest req ;\r\ndev_dbg(udc->dev, "config=%d\n", config);\r\nudc->config = config;\r\nudc->last_interface = 0;\r\nudc->last_alternate = 0;\r\nreq.bRequestType = 0;\r\nreq.bRequest = USB_REQ_SET_CONFIGURATION;\r\nreq.wValue = config;\r\nreq.wIndex = 0;\r\nreq.wLength = 0;\r\nset_ep0state(udc, WAIT_ACK_SET_CONF_INTERF);\r\nudc->driver->setup(&udc->gadget, &req);\r\nep_write_UDCCSR(&udc->pxa_ep[0], UDCCSR0_AREN);\r\n}\r\nstatic void pxa27x_change_interface(struct pxa_udc *udc, int iface, int alt)\r\n{\r\nstruct usb_ctrlrequest req;\r\ndev_dbg(udc->dev, "interface=%d, alternate setting=%d\n", iface, alt);\r\nudc->last_interface = iface;\r\nudc->last_alternate = alt;\r\nreq.bRequestType = USB_RECIP_INTERFACE;\r\nreq.bRequest = USB_REQ_SET_INTERFACE;\r\nreq.wValue = alt;\r\nreq.wIndex = iface;\r\nreq.wLength = 0;\r\nset_ep0state(udc, WAIT_ACK_SET_CONF_INTERF);\r\nudc->driver->setup(&udc->gadget, &req);\r\nep_write_UDCCSR(&udc->pxa_ep[0], UDCCSR0_AREN);\r\n}\r\nstatic void irq_handle_data(int irq, struct pxa_udc *udc)\r\n{\r\nint i;\r\nstruct pxa_ep *ep;\r\nu32 udcisr0 = udc_readl(udc, UDCISR0) & UDCCISR0_EP_MASK;\r\nu32 udcisr1 = udc_readl(udc, UDCISR1) & UDCCISR1_EP_MASK;\r\nif (udcisr0 & UDCISR_INT_MASK) {\r\nudc->pxa_ep[0].stats.irqs++;\r\nudc_writel(udc, UDCISR0, UDCISR_INT(0, UDCISR_INT_MASK));\r\nhandle_ep0(udc, !!(udcisr0 & UDCICR_FIFOERR),\r\n!!(udcisr0 & UDCICR_PKTCOMPL));\r\n}\r\nudcisr0 >>= 2;\r\nfor (i = 1; udcisr0 != 0 && i < 16; udcisr0 >>= 2, i++) {\r\nif (!(udcisr0 & UDCISR_INT_MASK))\r\ncontinue;\r\nudc_writel(udc, UDCISR0, UDCISR_INT(i, UDCISR_INT_MASK));\r\nWARN_ON(i >= ARRAY_SIZE(udc->pxa_ep));\r\nif (i < ARRAY_SIZE(udc->pxa_ep)) {\r\nep = &udc->pxa_ep[i];\r\nep->stats.irqs++;\r\nhandle_ep(ep);\r\n}\r\n}\r\nfor (i = 16; udcisr1 != 0 && i < 24; udcisr1 >>= 2, i++) {\r\nudc_writel(udc, UDCISR1, UDCISR_INT(i - 16, UDCISR_INT_MASK));\r\nif (!(udcisr1 & UDCISR_INT_MASK))\r\ncontinue;\r\nWARN_ON(i >= ARRAY_SIZE(udc->pxa_ep));\r\nif (i < ARRAY_SIZE(udc->pxa_ep)) {\r\nep = &udc->pxa_ep[i];\r\nep->stats.irqs++;\r\nhandle_ep(ep);\r\n}\r\n}\r\n}\r\nstatic void irq_udc_suspend(struct pxa_udc *udc)\r\n{\r\nudc_writel(udc, UDCISR1, UDCISR1_IRSU);\r\nudc->stats.irqs_suspend++;\r\nif (udc->gadget.speed != USB_SPEED_UNKNOWN\r\n&& udc->driver && udc->driver->suspend)\r\nudc->driver->suspend(&udc->gadget);\r\nep0_idle(udc);\r\n}\r\nstatic void irq_udc_resume(struct pxa_udc *udc)\r\n{\r\nudc_writel(udc, UDCISR1, UDCISR1_IRRU);\r\nudc->stats.irqs_resume++;\r\nif (udc->gadget.speed != USB_SPEED_UNKNOWN\r\n&& udc->driver && udc->driver->resume)\r\nudc->driver->resume(&udc->gadget);\r\n}\r\nstatic void irq_udc_reconfig(struct pxa_udc *udc)\r\n{\r\nunsigned config, interface, alternate, config_change;\r\nu32 udccr = udc_readl(udc, UDCCR);\r\nudc_writel(udc, UDCISR1, UDCISR1_IRCC);\r\nudc->stats.irqs_reconfig++;\r\nconfig = (udccr & UDCCR_ACN) >> UDCCR_ACN_S;\r\nconfig_change = (config != udc->config);\r\npxa27x_change_configuration(udc, config);\r\ninterface = (udccr & UDCCR_AIN) >> UDCCR_AIN_S;\r\nalternate = (udccr & UDCCR_AAISN) >> UDCCR_AAISN_S;\r\npxa27x_change_interface(udc, interface, alternate);\r\nif (config_change)\r\nupdate_pxa_ep_matches(udc);\r\nudc_set_mask_UDCCR(udc, UDCCR_SMAC);\r\n}\r\nstatic void irq_udc_reset(struct pxa_udc *udc)\r\n{\r\nu32 udccr = udc_readl(udc, UDCCR);\r\nstruct pxa_ep *ep = &udc->pxa_ep[0];\r\ndev_info(udc->dev, "USB reset\n");\r\nudc_writel(udc, UDCISR1, UDCISR1_IRRS);\r\nudc->stats.irqs_reset++;\r\nif ((udccr & UDCCR_UDA) == 0) {\r\ndev_dbg(udc->dev, "USB reset start\n");\r\nstop_activity(udc, udc->driver);\r\n}\r\nudc->gadget.speed = USB_SPEED_FULL;\r\nmemset(&udc->stats, 0, sizeof udc->stats);\r\nnuke(ep, -EPROTO);\r\nep_write_UDCCSR(ep, UDCCSR0_FTF | UDCCSR0_OPC);\r\nep0_idle(udc);\r\n}\r\nstatic irqreturn_t pxa_udc_irq(int irq, void *_dev)\r\n{\r\nstruct pxa_udc *udc = _dev;\r\nu32 udcisr0 = udc_readl(udc, UDCISR0);\r\nu32 udcisr1 = udc_readl(udc, UDCISR1);\r\nu32 udccr = udc_readl(udc, UDCCR);\r\nu32 udcisr1_spec;\r\ndev_vdbg(udc->dev, "Interrupt, UDCISR0:0x%08x, UDCISR1:0x%08x, "\r\n"UDCCR:0x%08x\n", udcisr0, udcisr1, udccr);\r\nudcisr1_spec = udcisr1 & 0xf8000000;\r\nif (unlikely(udcisr1_spec & UDCISR1_IRSU))\r\nirq_udc_suspend(udc);\r\nif (unlikely(udcisr1_spec & UDCISR1_IRRU))\r\nirq_udc_resume(udc);\r\nif (unlikely(udcisr1_spec & UDCISR1_IRCC))\r\nirq_udc_reconfig(udc);\r\nif (unlikely(udcisr1_spec & UDCISR1_IRRS))\r\nirq_udc_reset(udc);\r\nif ((udcisr0 & UDCCISR0_EP_MASK) | (udcisr1 & UDCCISR1_EP_MASK))\r\nirq_handle_data(irq, udc);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pxa_udc_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *regs;\r\nstruct pxa_udc *udc = &memory;\r\nint retval = 0, gpio;\r\nstruct pxa2xx_udc_mach_info *mach = dev_get_platdata(&pdev->dev);\r\nunsigned long gpio_flags;\r\nif (mach) {\r\ngpio_flags = mach->gpio_pullup_inverted ? GPIOF_ACTIVE_LOW : 0;\r\ngpio = mach->gpio_pullup;\r\nif (gpio_is_valid(gpio)) {\r\nretval = devm_gpio_request_one(&pdev->dev, gpio,\r\ngpio_flags,\r\n"USB D+ pullup");\r\nif (retval)\r\nreturn retval;\r\nudc->gpiod = gpio_to_desc(mach->gpio_pullup);\r\n}\r\nudc->udc_command = mach->udc_command;\r\n} else {\r\nudc->gpiod = devm_gpiod_get(&pdev->dev, NULL);\r\n}\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nudc->regs = devm_ioremap_resource(&pdev->dev, regs);\r\nif (IS_ERR(udc->regs))\r\nreturn PTR_ERR(udc->regs);\r\nudc->irq = platform_get_irq(pdev, 0);\r\nif (udc->irq < 0)\r\nreturn udc->irq;\r\nudc->dev = &pdev->dev;\r\nudc->transceiver = usb_get_phy(USB_PHY_TYPE_USB2);\r\nif (IS_ERR(udc->gpiod)) {\r\ndev_err(&pdev->dev, "Couldn't find or request D+ gpio : %ld\n",\r\nPTR_ERR(udc->gpiod));\r\nreturn PTR_ERR(udc->gpiod);\r\n}\r\nif (udc->gpiod)\r\ngpiod_direction_output(udc->gpiod, 0);\r\nudc->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(udc->clk))\r\nreturn PTR_ERR(udc->clk);\r\nretval = clk_prepare(udc->clk);\r\nif (retval)\r\nreturn retval;\r\nudc->vbus_sensed = 0;\r\nthe_controller = udc;\r\nplatform_set_drvdata(pdev, udc);\r\nudc_init_data(udc);\r\nretval = devm_request_irq(&pdev->dev, udc->irq, pxa_udc_irq,\r\nIRQF_SHARED, driver_name, udc);\r\nif (retval != 0) {\r\ndev_err(udc->dev, "%s: can't get irq %i, err %d\n",\r\ndriver_name, udc->irq, retval);\r\ngoto err;\r\n}\r\nretval = usb_add_gadget_udc(&pdev->dev, &udc->gadget);\r\nif (retval)\r\ngoto err;\r\npxa_init_debugfs(udc);\r\nif (should_enable_udc(udc))\r\nudc_enable(udc);\r\nreturn 0;\r\nerr:\r\nclk_unprepare(udc->clk);\r\nreturn retval;\r\n}\r\nstatic int pxa_udc_remove(struct platform_device *_dev)\r\n{\r\nstruct pxa_udc *udc = platform_get_drvdata(_dev);\r\nusb_del_gadget_udc(&udc->gadget);\r\npxa_cleanup_debugfs(udc);\r\nusb_put_phy(udc->transceiver);\r\nudc->transceiver = NULL;\r\nthe_controller = NULL;\r\nclk_unprepare(udc->clk);\r\nreturn 0;\r\n}\r\nstatic void pxa_udc_shutdown(struct platform_device *_dev)\r\n{\r\nstruct pxa_udc *udc = platform_get_drvdata(_dev);\r\nif (udc_readl(udc, UDCCR) & UDCCR_UDE)\r\nudc_disable(udc);\r\n}\r\nstatic int pxa_udc_suspend(struct platform_device *_dev, pm_message_t state)\r\n{\r\nstruct pxa_udc *udc = platform_get_drvdata(_dev);\r\nstruct pxa_ep *ep;\r\nep = &udc->pxa_ep[0];\r\nudc->udccsr0 = udc_ep_readl(ep, UDCCSR);\r\nudc_disable(udc);\r\nudc->pullup_resume = udc->pullup_on;\r\ndplus_pullup(udc, 0);\r\nreturn 0;\r\n}\r\nstatic int pxa_udc_resume(struct platform_device *_dev)\r\n{\r\nstruct pxa_udc *udc = platform_get_drvdata(_dev);\r\nstruct pxa_ep *ep;\r\nep = &udc->pxa_ep[0];\r\nudc_ep_writel(ep, UDCCSR, udc->udccsr0 & (UDCCSR0_FST | UDCCSR0_DME));\r\ndplus_pullup(udc, udc->pullup_resume);\r\nif (should_enable_udc(udc))\r\nudc_enable(udc);\r\npxa27x_clear_otgph();\r\nreturn 0;\r\n}
