static u32 page_to_balloon_pfn(struct page *page)\r\n{\r\nunsigned long pfn = page_to_pfn(page);\r\nBUILD_BUG_ON(PAGE_SHIFT < VIRTIO_BALLOON_PFN_SHIFT);\r\nreturn pfn * VIRTIO_BALLOON_PAGES_PER_PAGE;\r\n}\r\nstatic struct page *balloon_pfn_to_page(u32 pfn)\r\n{\r\nBUG_ON(pfn % VIRTIO_BALLOON_PAGES_PER_PAGE);\r\nreturn pfn_to_page(pfn / VIRTIO_BALLOON_PAGES_PER_PAGE);\r\n}\r\nstatic void balloon_ack(struct virtqueue *vq)\r\n{\r\nstruct virtio_balloon *vb = vq->vdev->priv;\r\nwake_up(&vb->acked);\r\n}\r\nstatic void tell_host(struct virtio_balloon *vb, struct virtqueue *vq)\r\n{\r\nstruct scatterlist sg;\r\nunsigned int len;\r\nsg_init_one(&sg, vb->pfns, sizeof(vb->pfns[0]) * vb->num_pfns);\r\nvirtqueue_add_outbuf(vq, &sg, 1, vb, GFP_KERNEL);\r\nvirtqueue_kick(vq);\r\nwait_event(vb->acked, virtqueue_get_buf(vq, &len));\r\n}\r\nstatic void set_page_pfns(u32 pfns[], struct page *page)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < VIRTIO_BALLOON_PAGES_PER_PAGE; i++)\r\npfns[i] = page_to_balloon_pfn(page) + i;\r\n}\r\nstatic void fill_balloon(struct virtio_balloon *vb, size_t num)\r\n{\r\nstruct balloon_dev_info *vb_dev_info = &vb->vb_dev_info;\r\nnum = min(num, ARRAY_SIZE(vb->pfns));\r\nmutex_lock(&vb->balloon_lock);\r\nfor (vb->num_pfns = 0; vb->num_pfns < num;\r\nvb->num_pfns += VIRTIO_BALLOON_PAGES_PER_PAGE) {\r\nstruct page *page = balloon_page_enqueue(vb_dev_info);\r\nif (!page) {\r\ndev_info_ratelimited(&vb->vdev->dev,\r\n"Out of puff! Can't get %u pages\n",\r\nVIRTIO_BALLOON_PAGES_PER_PAGE);\r\nmsleep(200);\r\nbreak;\r\n}\r\nset_page_pfns(vb->pfns + vb->num_pfns, page);\r\nvb->num_pages += VIRTIO_BALLOON_PAGES_PER_PAGE;\r\nadjust_managed_page_count(page, -1);\r\n}\r\nif (vb->num_pfns != 0)\r\ntell_host(vb, vb->inflate_vq);\r\nmutex_unlock(&vb->balloon_lock);\r\n}\r\nstatic void release_pages_by_pfn(const u32 pfns[], unsigned int num)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < num; i += VIRTIO_BALLOON_PAGES_PER_PAGE) {\r\nstruct page *page = balloon_pfn_to_page(pfns[i]);\r\nadjust_managed_page_count(page, 1);\r\nput_page(page);\r\n}\r\n}\r\nstatic unsigned leak_balloon(struct virtio_balloon *vb, size_t num)\r\n{\r\nunsigned num_freed_pages;\r\nstruct page *page;\r\nstruct balloon_dev_info *vb_dev_info = &vb->vb_dev_info;\r\nnum = min(num, ARRAY_SIZE(vb->pfns));\r\nmutex_lock(&vb->balloon_lock);\r\nfor (vb->num_pfns = 0; vb->num_pfns < num;\r\nvb->num_pfns += VIRTIO_BALLOON_PAGES_PER_PAGE) {\r\npage = balloon_page_dequeue(vb_dev_info);\r\nif (!page)\r\nbreak;\r\nset_page_pfns(vb->pfns + vb->num_pfns, page);\r\nvb->num_pages -= VIRTIO_BALLOON_PAGES_PER_PAGE;\r\n}\r\nnum_freed_pages = vb->num_pfns;\r\nif (vb->num_pfns != 0)\r\ntell_host(vb, vb->deflate_vq);\r\nmutex_unlock(&vb->balloon_lock);\r\nrelease_pages_by_pfn(vb->pfns, vb->num_pfns);\r\nreturn num_freed_pages;\r\n}\r\nstatic inline void update_stat(struct virtio_balloon *vb, int idx,\r\nu16 tag, u64 val)\r\n{\r\nBUG_ON(idx >= VIRTIO_BALLOON_S_NR);\r\nvb->stats[idx].tag = cpu_to_virtio16(vb->vdev, tag);\r\nvb->stats[idx].val = cpu_to_virtio64(vb->vdev, val);\r\n}\r\nstatic void update_balloon_stats(struct virtio_balloon *vb)\r\n{\r\nunsigned long events[NR_VM_EVENT_ITEMS];\r\nstruct sysinfo i;\r\nint idx = 0;\r\nall_vm_events(events);\r\nsi_meminfo(&i);\r\nupdate_stat(vb, idx++, VIRTIO_BALLOON_S_SWAP_IN,\r\npages_to_bytes(events[PSWPIN]));\r\nupdate_stat(vb, idx++, VIRTIO_BALLOON_S_SWAP_OUT,\r\npages_to_bytes(events[PSWPOUT]));\r\nupdate_stat(vb, idx++, VIRTIO_BALLOON_S_MAJFLT, events[PGMAJFAULT]);\r\nupdate_stat(vb, idx++, VIRTIO_BALLOON_S_MINFLT, events[PGFAULT]);\r\nupdate_stat(vb, idx++, VIRTIO_BALLOON_S_MEMFREE,\r\npages_to_bytes(i.freeram));\r\nupdate_stat(vb, idx++, VIRTIO_BALLOON_S_MEMTOT,\r\npages_to_bytes(i.totalram));\r\n}\r\nstatic void stats_request(struct virtqueue *vq)\r\n{\r\nstruct virtio_balloon *vb = vq->vdev->priv;\r\nvb->need_stats_update = 1;\r\nwake_up(&vb->config_change);\r\n}\r\nstatic void stats_handle_request(struct virtio_balloon *vb)\r\n{\r\nstruct virtqueue *vq;\r\nstruct scatterlist sg;\r\nunsigned int len;\r\nvb->need_stats_update = 0;\r\nupdate_balloon_stats(vb);\r\nvq = vb->stats_vq;\r\nif (!virtqueue_get_buf(vq, &len))\r\nreturn;\r\nsg_init_one(&sg, vb->stats, sizeof(vb->stats));\r\nvirtqueue_add_outbuf(vq, &sg, 1, vb, GFP_KERNEL);\r\nvirtqueue_kick(vq);\r\n}\r\nstatic void virtballoon_changed(struct virtio_device *vdev)\r\n{\r\nstruct virtio_balloon *vb = vdev->priv;\r\nwake_up(&vb->config_change);\r\n}\r\nstatic inline s64 towards_target(struct virtio_balloon *vb)\r\n{\r\ns64 target;\r\nu32 num_pages;\r\nvirtio_cread(vb->vdev, struct virtio_balloon_config, num_pages,\r\n&num_pages);\r\nif (!virtio_has_feature(vb->vdev, VIRTIO_F_VERSION_1))\r\nnum_pages = le32_to_cpu((__force __le32)num_pages);\r\ntarget = num_pages;\r\nreturn target - vb->num_pages;\r\n}\r\nstatic void update_balloon_size(struct virtio_balloon *vb)\r\n{\r\nu32 actual = vb->num_pages;\r\nif (!virtio_has_feature(vb->vdev, VIRTIO_F_VERSION_1))\r\nactual = (__force u32)cpu_to_le32(actual);\r\nvirtio_cwrite(vb->vdev, struct virtio_balloon_config, actual,\r\n&actual);\r\n}\r\nstatic int virtballoon_oom_notify(struct notifier_block *self,\r\nunsigned long dummy, void *parm)\r\n{\r\nstruct virtio_balloon *vb;\r\nunsigned long *freed;\r\nunsigned num_freed_pages;\r\nvb = container_of(self, struct virtio_balloon, nb);\r\nif (!virtio_has_feature(vb->vdev, VIRTIO_BALLOON_F_DEFLATE_ON_OOM))\r\nreturn NOTIFY_OK;\r\nfreed = parm;\r\nnum_freed_pages = leak_balloon(vb, oom_pages);\r\nupdate_balloon_size(vb);\r\n*freed += num_freed_pages;\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int balloon(void *_vballoon)\r\n{\r\nstruct virtio_balloon *vb = _vballoon;\r\nDEFINE_WAIT_FUNC(wait, woken_wake_function);\r\nset_freezable();\r\nwhile (!kthread_should_stop()) {\r\ns64 diff;\r\ntry_to_freeze();\r\nadd_wait_queue(&vb->config_change, &wait);\r\nfor (;;) {\r\nif ((diff = towards_target(vb)) != 0 ||\r\nvb->need_stats_update ||\r\nkthread_should_stop() ||\r\nfreezing(current))\r\nbreak;\r\nwait_woken(&wait, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\r\n}\r\nremove_wait_queue(&vb->config_change, &wait);\r\nif (vb->need_stats_update)\r\nstats_handle_request(vb);\r\nif (diff > 0)\r\nfill_balloon(vb, diff);\r\nelse if (diff < 0)\r\nleak_balloon(vb, -diff);\r\nupdate_balloon_size(vb);\r\ncond_resched();\r\n}\r\nreturn 0;\r\n}\r\nstatic int init_vqs(struct virtio_balloon *vb)\r\n{\r\nstruct virtqueue *vqs[3];\r\nvq_callback_t *callbacks[] = { balloon_ack, balloon_ack, stats_request };\r\nconst char *names[] = { "inflate", "deflate", "stats" };\r\nint err, nvqs;\r\nnvqs = virtio_has_feature(vb->vdev, VIRTIO_BALLOON_F_STATS_VQ) ? 3 : 2;\r\nerr = vb->vdev->config->find_vqs(vb->vdev, nvqs, vqs, callbacks, names);\r\nif (err)\r\nreturn err;\r\nvb->inflate_vq = vqs[0];\r\nvb->deflate_vq = vqs[1];\r\nif (virtio_has_feature(vb->vdev, VIRTIO_BALLOON_F_STATS_VQ)) {\r\nstruct scatterlist sg;\r\nvb->stats_vq = vqs[2];\r\nsg_init_one(&sg, vb->stats, sizeof vb->stats);\r\nif (virtqueue_add_outbuf(vb->stats_vq, &sg, 1, vb, GFP_KERNEL)\r\n< 0)\r\nBUG();\r\nvirtqueue_kick(vb->stats_vq);\r\n}\r\nreturn 0;\r\n}\r\nstatic int virtballoon_migratepage(struct balloon_dev_info *vb_dev_info,\r\nstruct page *newpage, struct page *page, enum migrate_mode mode)\r\n{\r\nstruct virtio_balloon *vb = container_of(vb_dev_info,\r\nstruct virtio_balloon, vb_dev_info);\r\nunsigned long flags;\r\nif (!mutex_trylock(&vb->balloon_lock))\r\nreturn -EAGAIN;\r\nget_page(newpage);\r\nspin_lock_irqsave(&vb_dev_info->pages_lock, flags);\r\nballoon_page_insert(vb_dev_info, newpage);\r\nvb_dev_info->isolated_pages--;\r\n__count_vm_event(BALLOON_MIGRATE);\r\nspin_unlock_irqrestore(&vb_dev_info->pages_lock, flags);\r\nvb->num_pfns = VIRTIO_BALLOON_PAGES_PER_PAGE;\r\nset_page_pfns(vb->pfns, newpage);\r\ntell_host(vb, vb->inflate_vq);\r\nballoon_page_delete(page);\r\nvb->num_pfns = VIRTIO_BALLOON_PAGES_PER_PAGE;\r\nset_page_pfns(vb->pfns, page);\r\ntell_host(vb, vb->deflate_vq);\r\nmutex_unlock(&vb->balloon_lock);\r\nput_page(page);\r\nreturn MIGRATEPAGE_SUCCESS;\r\n}\r\nstatic int virtballoon_probe(struct virtio_device *vdev)\r\n{\r\nstruct virtio_balloon *vb;\r\nint err;\r\nif (!vdev->config->get) {\r\ndev_err(&vdev->dev, "%s failure: config access disabled\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nvdev->priv = vb = kmalloc(sizeof(*vb), GFP_KERNEL);\r\nif (!vb) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nvb->num_pages = 0;\r\nmutex_init(&vb->balloon_lock);\r\ninit_waitqueue_head(&vb->config_change);\r\ninit_waitqueue_head(&vb->acked);\r\nvb->vdev = vdev;\r\nvb->need_stats_update = 0;\r\nballoon_devinfo_init(&vb->vb_dev_info);\r\n#ifdef CONFIG_BALLOON_COMPACTION\r\nvb->vb_dev_info.migratepage = virtballoon_migratepage;\r\n#endif\r\nerr = init_vqs(vb);\r\nif (err)\r\ngoto out_free_vb;\r\nvb->nb.notifier_call = virtballoon_oom_notify;\r\nvb->nb.priority = VIRTBALLOON_OOM_NOTIFY_PRIORITY;\r\nerr = register_oom_notifier(&vb->nb);\r\nif (err < 0)\r\ngoto out_oom_notify;\r\nvirtio_device_ready(vdev);\r\nvb->thread = kthread_run(balloon, vb, "vballoon");\r\nif (IS_ERR(vb->thread)) {\r\nerr = PTR_ERR(vb->thread);\r\ngoto out_del_vqs;\r\n}\r\nreturn 0;\r\nout_del_vqs:\r\nunregister_oom_notifier(&vb->nb);\r\nout_oom_notify:\r\nvdev->config->del_vqs(vdev);\r\nout_free_vb:\r\nkfree(vb);\r\nout:\r\nreturn err;\r\n}\r\nstatic void remove_common(struct virtio_balloon *vb)\r\n{\r\nwhile (vb->num_pages)\r\nleak_balloon(vb, vb->num_pages);\r\nupdate_balloon_size(vb);\r\nvb->vdev->config->reset(vb->vdev);\r\nvb->vdev->config->del_vqs(vb->vdev);\r\n}\r\nstatic void virtballoon_remove(struct virtio_device *vdev)\r\n{\r\nstruct virtio_balloon *vb = vdev->priv;\r\nunregister_oom_notifier(&vb->nb);\r\nkthread_stop(vb->thread);\r\nremove_common(vb);\r\nkfree(vb);\r\n}\r\nstatic int virtballoon_freeze(struct virtio_device *vdev)\r\n{\r\nstruct virtio_balloon *vb = vdev->priv;\r\nremove_common(vb);\r\nreturn 0;\r\n}\r\nstatic int virtballoon_restore(struct virtio_device *vdev)\r\n{\r\nstruct virtio_balloon *vb = vdev->priv;\r\nint ret;\r\nret = init_vqs(vdev->priv);\r\nif (ret)\r\nreturn ret;\r\nvirtio_device_ready(vdev);\r\nfill_balloon(vb, towards_target(vb));\r\nupdate_balloon_size(vb);\r\nreturn 0;\r\n}
