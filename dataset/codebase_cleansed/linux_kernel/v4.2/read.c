static struct nfs_pgio_header *nfs_readhdr_alloc(void)\r\n{\r\nreturn kmem_cache_zalloc(nfs_rdata_cachep, GFP_KERNEL);\r\n}\r\nstatic void nfs_readhdr_free(struct nfs_pgio_header *rhdr)\r\n{\r\nkmem_cache_free(nfs_rdata_cachep, rhdr);\r\n}\r\nstatic\r\nint nfs_return_empty_page(struct page *page)\r\n{\r\nzero_user(page, 0, PAGE_CACHE_SIZE);\r\nSetPageUptodate(page);\r\nunlock_page(page);\r\nreturn 0;\r\n}\r\nvoid nfs_pageio_init_read(struct nfs_pageio_descriptor *pgio,\r\nstruct inode *inode, bool force_mds,\r\nconst struct nfs_pgio_completion_ops *compl_ops)\r\n{\r\nstruct nfs_server *server = NFS_SERVER(inode);\r\nconst struct nfs_pageio_ops *pg_ops = &nfs_pgio_rw_ops;\r\n#ifdef CONFIG_NFS_V4_1\r\nif (server->pnfs_curr_ld && !force_mds)\r\npg_ops = server->pnfs_curr_ld->pg_read_ops;\r\n#endif\r\nnfs_pageio_init(pgio, inode, pg_ops, compl_ops, &nfs_rw_read_ops,\r\nserver->rsize, 0);\r\n}\r\nvoid nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio)\r\n{\r\nstruct nfs_pgio_mirror *mirror;\r\npgio->pg_ops = &nfs_pgio_rw_ops;\r\nWARN_ON_ONCE(pgio->pg_mirror_count != 1);\r\nmirror = &pgio->pg_mirrors[0];\r\nmirror->pg_bsize = NFS_SERVER(pgio->pg_inode)->rsize;\r\n}\r\nint nfs_readpage_async(struct nfs_open_context *ctx, struct inode *inode,\r\nstruct page *page)\r\n{\r\nstruct nfs_page *new;\r\nunsigned int len;\r\nstruct nfs_pageio_descriptor pgio;\r\nstruct nfs_pgio_mirror *pgm;\r\nlen = nfs_page_length(page);\r\nif (len == 0)\r\nreturn nfs_return_empty_page(page);\r\nnew = nfs_create_request(ctx, page, NULL, 0, len);\r\nif (IS_ERR(new)) {\r\nunlock_page(page);\r\nreturn PTR_ERR(new);\r\n}\r\nif (len < PAGE_CACHE_SIZE)\r\nzero_user_segment(page, len, PAGE_CACHE_SIZE);\r\nnfs_pageio_init_read(&pgio, inode, false,\r\n&nfs_async_read_completion_ops);\r\nnfs_pageio_add_request(&pgio, new);\r\nnfs_pageio_complete(&pgio);\r\nWARN_ON_ONCE(pgio.pg_mirror_count != 1);\r\npgm = &pgio.pg_mirrors[0];\r\nNFS_I(inode)->read_io += pgm->pg_bytes_written;\r\nreturn 0;\r\n}\r\nstatic void nfs_readpage_release(struct nfs_page *req)\r\n{\r\nstruct inode *inode = d_inode(req->wb_context->dentry);\r\ndprintk("NFS: read done (%s/%llu %d@%lld)\n", inode->i_sb->s_id,\r\n(unsigned long long)NFS_FILEID(inode), req->wb_bytes,\r\n(long long)req_offset(req));\r\nif (nfs_page_group_sync_on_bit(req, PG_UNLOCKPAGE)) {\r\nif (PageUptodate(req->wb_page))\r\nnfs_readpage_to_fscache(inode, req->wb_page, 0);\r\nunlock_page(req->wb_page);\r\n}\r\nnfs_release_request(req);\r\n}\r\nstatic void nfs_page_group_set_uptodate(struct nfs_page *req)\r\n{\r\nif (nfs_page_group_sync_on_bit(req, PG_UPTODATE))\r\nSetPageUptodate(req->wb_page);\r\n}\r\nstatic void nfs_read_completion(struct nfs_pgio_header *hdr)\r\n{\r\nunsigned long bytes = 0;\r\nif (test_bit(NFS_IOHDR_REDO, &hdr->flags))\r\ngoto out;\r\nwhile (!list_empty(&hdr->pages)) {\r\nstruct nfs_page *req = nfs_list_entry(hdr->pages.next);\r\nstruct page *page = req->wb_page;\r\nunsigned long start = req->wb_pgbase;\r\nunsigned long end = req->wb_pgbase + req->wb_bytes;\r\nif (test_bit(NFS_IOHDR_EOF, &hdr->flags)) {\r\nif (bytes > hdr->good_bytes) {\r\nzero_user_segment(page, start, end);\r\n} else if (hdr->good_bytes - bytes < req->wb_bytes) {\r\nstart += hdr->good_bytes - bytes;\r\nWARN_ON(start < req->wb_pgbase);\r\nzero_user_segment(page, start, end);\r\n}\r\n}\r\nbytes += req->wb_bytes;\r\nif (test_bit(NFS_IOHDR_ERROR, &hdr->flags)) {\r\nif (bytes <= hdr->good_bytes)\r\nnfs_page_group_set_uptodate(req);\r\n} else\r\nnfs_page_group_set_uptodate(req);\r\nnfs_list_remove_request(req);\r\nnfs_readpage_release(req);\r\n}\r\nout:\r\nhdr->release(hdr);\r\n}\r\nstatic void nfs_initiate_read(struct nfs_pgio_header *hdr,\r\nstruct rpc_message *msg,\r\nconst struct nfs_rpc_ops *rpc_ops,\r\nstruct rpc_task_setup *task_setup_data, int how)\r\n{\r\nstruct inode *inode = hdr->inode;\r\nint swap_flags = IS_SWAPFILE(inode) ? NFS_RPC_SWAPFLAGS : 0;\r\ntask_setup_data->flags |= swap_flags;\r\nrpc_ops->read_setup(hdr, msg);\r\n}\r\nstatic void\r\nnfs_async_read_error(struct list_head *head)\r\n{\r\nstruct nfs_page *req;\r\nwhile (!list_empty(head)) {\r\nreq = nfs_list_entry(head->next);\r\nnfs_list_remove_request(req);\r\nnfs_readpage_release(req);\r\n}\r\n}\r\nstatic int nfs_readpage_done(struct rpc_task *task,\r\nstruct nfs_pgio_header *hdr,\r\nstruct inode *inode)\r\n{\r\nint status = NFS_PROTO(inode)->read_done(task, hdr);\r\nif (status != 0)\r\nreturn status;\r\nnfs_add_stats(inode, NFSIOS_SERVERREADBYTES, hdr->res.count);\r\nif (task->tk_status == -ESTALE) {\r\nset_bit(NFS_INO_STALE, &NFS_I(inode)->flags);\r\nnfs_mark_for_revalidate(inode);\r\n}\r\nreturn 0;\r\n}\r\nstatic void nfs_readpage_retry(struct rpc_task *task,\r\nstruct nfs_pgio_header *hdr)\r\n{\r\nstruct nfs_pgio_args *argp = &hdr->args;\r\nstruct nfs_pgio_res *resp = &hdr->res;\r\nnfs_inc_stats(hdr->inode, NFSIOS_SHORTREAD);\r\nif (resp->count == 0) {\r\nnfs_set_pgio_error(hdr, -EIO, argp->offset);\r\nreturn;\r\n}\r\nhdr->mds_offset += resp->count;\r\nargp->offset += resp->count;\r\nargp->pgbase += resp->count;\r\nargp->count -= resp->count;\r\nrpc_restart_call_prepare(task);\r\n}\r\nstatic void nfs_readpage_result(struct rpc_task *task,\r\nstruct nfs_pgio_header *hdr)\r\n{\r\nif (hdr->res.eof) {\r\nloff_t bound;\r\nbound = hdr->args.offset + hdr->res.count;\r\nspin_lock(&hdr->lock);\r\nif (bound < hdr->io_start + hdr->good_bytes) {\r\nset_bit(NFS_IOHDR_EOF, &hdr->flags);\r\nclear_bit(NFS_IOHDR_ERROR, &hdr->flags);\r\nhdr->good_bytes = bound - hdr->io_start;\r\n}\r\nspin_unlock(&hdr->lock);\r\n} else if (hdr->res.count != hdr->args.count)\r\nnfs_readpage_retry(task, hdr);\r\n}\r\nint nfs_readpage(struct file *file, struct page *page)\r\n{\r\nstruct nfs_open_context *ctx;\r\nstruct inode *inode = page_file_mapping(page)->host;\r\nint error;\r\ndprintk("NFS: nfs_readpage (%p %ld@%lu)\n",\r\npage, PAGE_CACHE_SIZE, page_file_index(page));\r\nnfs_inc_stats(inode, NFSIOS_VFSREADPAGE);\r\nnfs_add_stats(inode, NFSIOS_READPAGES, 1);\r\nerror = nfs_wb_page(inode, page);\r\nif (error)\r\ngoto out_unlock;\r\nif (PageUptodate(page))\r\ngoto out_unlock;\r\nerror = -ESTALE;\r\nif (NFS_STALE(inode))\r\ngoto out_unlock;\r\nif (file == NULL) {\r\nerror = -EBADF;\r\nctx = nfs_find_open_context(inode, NULL, FMODE_READ);\r\nif (ctx == NULL)\r\ngoto out_unlock;\r\n} else\r\nctx = get_nfs_open_context(nfs_file_open_context(file));\r\nif (!IS_SYNC(inode)) {\r\nerror = nfs_readpage_from_fscache(ctx, inode, page);\r\nif (error == 0)\r\ngoto out;\r\n}\r\nerror = nfs_readpage_async(ctx, inode, page);\r\nout:\r\nput_nfs_open_context(ctx);\r\nreturn error;\r\nout_unlock:\r\nunlock_page(page);\r\nreturn error;\r\n}\r\nstatic int\r\nreadpage_async_filler(void *data, struct page *page)\r\n{\r\nstruct nfs_readdesc *desc = (struct nfs_readdesc *)data;\r\nstruct nfs_page *new;\r\nunsigned int len;\r\nint error;\r\nlen = nfs_page_length(page);\r\nif (len == 0)\r\nreturn nfs_return_empty_page(page);\r\nnew = nfs_create_request(desc->ctx, page, NULL, 0, len);\r\nif (IS_ERR(new))\r\ngoto out_error;\r\nif (len < PAGE_CACHE_SIZE)\r\nzero_user_segment(page, len, PAGE_CACHE_SIZE);\r\nif (!nfs_pageio_add_request(desc->pgio, new)) {\r\nerror = desc->pgio->pg_error;\r\ngoto out_unlock;\r\n}\r\nreturn 0;\r\nout_error:\r\nerror = PTR_ERR(new);\r\nout_unlock:\r\nunlock_page(page);\r\nreturn error;\r\n}\r\nint nfs_readpages(struct file *filp, struct address_space *mapping,\r\nstruct list_head *pages, unsigned nr_pages)\r\n{\r\nstruct nfs_pageio_descriptor pgio;\r\nstruct nfs_pgio_mirror *pgm;\r\nstruct nfs_readdesc desc = {\r\n.pgio = &pgio,\r\n};\r\nstruct inode *inode = mapping->host;\r\nunsigned long npages;\r\nint ret = -ESTALE;\r\ndprintk("NFS: nfs_readpages (%s/%Lu %d)\n",\r\ninode->i_sb->s_id,\r\n(unsigned long long)NFS_FILEID(inode),\r\nnr_pages);\r\nnfs_inc_stats(inode, NFSIOS_VFSREADPAGES);\r\nif (NFS_STALE(inode))\r\ngoto out;\r\nif (filp == NULL) {\r\ndesc.ctx = nfs_find_open_context(inode, NULL, FMODE_READ);\r\nif (desc.ctx == NULL)\r\nreturn -EBADF;\r\n} else\r\ndesc.ctx = get_nfs_open_context(nfs_file_open_context(filp));\r\nret = nfs_readpages_from_fscache(desc.ctx, inode, mapping,\r\npages, &nr_pages);\r\nif (ret == 0)\r\ngoto read_complete;\r\nnfs_pageio_init_read(&pgio, inode, false,\r\n&nfs_async_read_completion_ops);\r\nret = read_cache_pages(mapping, pages, readpage_async_filler, &desc);\r\nnfs_pageio_complete(&pgio);\r\nWARN_ON_ONCE(pgio.pg_mirror_count != 1);\r\npgm = &pgio.pg_mirrors[0];\r\nNFS_I(inode)->read_io += pgm->pg_bytes_written;\r\nnpages = (pgm->pg_bytes_written + PAGE_CACHE_SIZE - 1) >>\r\nPAGE_CACHE_SHIFT;\r\nnfs_add_stats(inode, NFSIOS_READPAGES, npages);\r\nread_complete:\r\nput_nfs_open_context(desc.ctx);\r\nout:\r\nreturn ret;\r\n}\r\nint __init nfs_init_readpagecache(void)\r\n{\r\nnfs_rdata_cachep = kmem_cache_create("nfs_read_data",\r\nsizeof(struct nfs_pgio_header),\r\n0, SLAB_HWCACHE_ALIGN,\r\nNULL);\r\nif (nfs_rdata_cachep == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid nfs_destroy_readpagecache(void)\r\n{\r\nkmem_cache_destroy(nfs_rdata_cachep);\r\n}
