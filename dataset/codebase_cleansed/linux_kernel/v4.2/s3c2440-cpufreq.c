static inline int within_khz(unsigned long a, unsigned long b)\r\n{\r\nlong diff = a - b;\r\nreturn (diff >= -1000 && diff <= 1000);\r\n}\r\nstatic int s3c2440_cpufreq_calcdivs(struct s3c_cpufreq_config *cfg)\r\n{\r\nunsigned int hdiv, pdiv;\r\nunsigned long hclk, fclk, armclk;\r\nunsigned long hclk_max;\r\nfclk = cfg->freq.fclk;\r\narmclk = cfg->freq.armclk;\r\nhclk_max = cfg->max.hclk;\r\ns3c_freq_dbg("%s: fclk is %lu, armclk %lu, max hclk %lu\n",\r\n__func__, fclk, armclk, hclk_max);\r\nif (armclk > fclk) {\r\nprintk(KERN_WARNING "%s: armclk > fclk\n", __func__);\r\narmclk = fclk;\r\n}\r\nif (armclk < fclk && armclk < hclk_max)\r\nhclk_max = armclk;\r\nfor (hdiv = 1; hdiv < 9; hdiv++) {\r\nif (hdiv == 5 || hdiv == 7)\r\nhdiv++;\r\nhclk = (fclk / hdiv);\r\nif (hclk <= hclk_max || within_khz(hclk, hclk_max))\r\nbreak;\r\n}\r\ns3c_freq_dbg("%s: hclk %lu, div %d\n", __func__, hclk, hdiv);\r\nif (hdiv > 8)\r\ngoto invalid;\r\npdiv = (hclk > cfg->max.pclk) ? 2 : 1;\r\nif ((hclk / pdiv) > cfg->max.pclk)\r\npdiv++;\r\ns3c_freq_dbg("%s: pdiv %d\n", __func__, pdiv);\r\nif (pdiv > 2)\r\ngoto invalid;\r\npdiv *= hdiv;\r\nif (armclk < hclk)\r\narmclk = hclk;\r\nif (armclk < fclk) {\r\ncfg->divs.dvs = 1;\r\narmclk = hclk;\r\n} else\r\ncfg->divs.dvs = 0;\r\ncfg->freq.armclk = armclk;\r\ncfg->divs.h_divisor = hdiv;\r\ncfg->divs.p_divisor = pdiv;\r\nreturn 0;\r\ninvalid:\r\nreturn -EINVAL;\r\n}\r\nstatic void s3c2440_cpufreq_setdivs(struct s3c_cpufreq_config *cfg)\r\n{\r\nunsigned long clkdiv, camdiv;\r\ns3c_freq_dbg("%s: divsiors: h=%d, p=%d\n", __func__,\r\ncfg->divs.h_divisor, cfg->divs.p_divisor);\r\nclkdiv = __raw_readl(S3C2410_CLKDIVN);\r\ncamdiv = __raw_readl(S3C2440_CAMDIVN);\r\nclkdiv &= ~(S3C2440_CLKDIVN_HDIVN_MASK | S3C2440_CLKDIVN_PDIVN);\r\ncamdiv &= ~CAMDIVN_HCLK_HALF;\r\nswitch (cfg->divs.h_divisor) {\r\ncase 1:\r\nclkdiv |= S3C2440_CLKDIVN_HDIVN_1;\r\nbreak;\r\ncase 2:\r\nclkdiv |= S3C2440_CLKDIVN_HDIVN_2;\r\nbreak;\r\ncase 6:\r\ncamdiv |= S3C2440_CAMDIVN_HCLK3_HALF;\r\ncase 3:\r\nclkdiv |= S3C2440_CLKDIVN_HDIVN_3_6;\r\nbreak;\r\ncase 8:\r\ncamdiv |= S3C2440_CAMDIVN_HCLK4_HALF;\r\ncase 4:\r\nclkdiv |= S3C2440_CLKDIVN_HDIVN_4_8;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nif (cfg->divs.p_divisor != cfg->divs.h_divisor)\r\nclkdiv |= S3C2440_CLKDIVN_PDIVN;\r\n__raw_writel(camdiv | CAMDIVN_HCLK_HALF, S3C2440_CAMDIVN);\r\n__raw_writel(clkdiv, S3C2410_CLKDIVN);\r\nndelay(20);\r\n__raw_writel(camdiv, S3C2440_CAMDIVN);\r\nclk_set_parent(armclk, cfg->divs.dvs ? hclk : fclk);\r\n}\r\nstatic int run_freq_for(unsigned long max_hclk, unsigned long fclk,\r\nint *divs,\r\nstruct cpufreq_frequency_table *table,\r\nsize_t table_size)\r\n{\r\nunsigned long freq;\r\nint index = 0;\r\nint div;\r\nfor (div = *divs; div > 0; div = *divs++) {\r\nfreq = fclk / div;\r\nif (freq > max_hclk && div != 1)\r\ncontinue;\r\nfreq /= 1000;\r\nindex = s3c_cpufreq_addfreq(table, index, table_size, freq);\r\nif (index < 0)\r\nbreak;\r\n}\r\nreturn index;\r\n}\r\nstatic int s3c2440_cpufreq_calctable(struct s3c_cpufreq_config *cfg,\r\nstruct cpufreq_frequency_table *table,\r\nsize_t table_size)\r\n{\r\nint ret;\r\nWARN_ON(cfg->info == NULL);\r\nWARN_ON(cfg->board == NULL);\r\nret = run_freq_for(cfg->info->max.hclk,\r\ncfg->info->max.fclk,\r\nhclk_divs,\r\ntable, table_size);\r\ns3c_freq_dbg("%s: returning %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int s3c2440_cpufreq_add(struct device *dev,\r\nstruct subsys_interface *sif)\r\n{\r\nxtal = s3c_cpufreq_clk_get(NULL, "xtal");\r\nhclk = s3c_cpufreq_clk_get(NULL, "hclk");\r\nfclk = s3c_cpufreq_clk_get(NULL, "fclk");\r\narmclk = s3c_cpufreq_clk_get(NULL, "armclk");\r\nif (IS_ERR(xtal) || IS_ERR(hclk) || IS_ERR(fclk) || IS_ERR(armclk)) {\r\nprintk(KERN_ERR "%s: failed to get clocks\n", __func__);\r\nreturn -ENOENT;\r\n}\r\nreturn s3c_cpufreq_register(&s3c2440_cpufreq_info);\r\n}\r\nstatic int s3c2440_cpufreq_init(void)\r\n{\r\nreturn subsys_interface_register(&s3c2440_cpufreq_interface);\r\n}\r\nstatic int s3c2442_cpufreq_init(void)\r\n{\r\nreturn subsys_interface_register(&s3c2442_cpufreq_interface);\r\n}
