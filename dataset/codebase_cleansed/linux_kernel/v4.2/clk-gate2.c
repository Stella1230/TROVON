static int clk_gate2_enable(struct clk_hw *hw)\r\n{\r\nstruct clk_gate2 *gate = to_clk_gate2(hw);\r\nu32 reg;\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(gate->lock, flags);\r\nif (gate->share_count && (*gate->share_count)++ > 0)\r\ngoto out;\r\nreg = readl(gate->reg);\r\nreg |= 3 << gate->bit_idx;\r\nwritel(reg, gate->reg);\r\nout:\r\nspin_unlock_irqrestore(gate->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void clk_gate2_disable(struct clk_hw *hw)\r\n{\r\nstruct clk_gate2 *gate = to_clk_gate2(hw);\r\nu32 reg;\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(gate->lock, flags);\r\nif (gate->share_count) {\r\nif (WARN_ON(*gate->share_count == 0))\r\ngoto out;\r\nelse if (--(*gate->share_count) > 0)\r\ngoto out;\r\n}\r\nreg = readl(gate->reg);\r\nreg &= ~(3 << gate->bit_idx);\r\nwritel(reg, gate->reg);\r\nout:\r\nspin_unlock_irqrestore(gate->lock, flags);\r\n}\r\nstatic int clk_gate2_reg_is_enabled(void __iomem *reg, u8 bit_idx)\r\n{\r\nu32 val = readl(reg);\r\nif (((val >> bit_idx) & 1) == 1)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int clk_gate2_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct clk_gate2 *gate = to_clk_gate2(hw);\r\nreturn clk_gate2_reg_is_enabled(gate->reg, gate->bit_idx);\r\n}\r\nstatic void clk_gate2_disable_unused(struct clk_hw *hw)\r\n{\r\nstruct clk_gate2 *gate = to_clk_gate2(hw);\r\nunsigned long flags = 0;\r\nu32 reg;\r\nspin_lock_irqsave(gate->lock, flags);\r\nif (!gate->share_count || *gate->share_count == 0) {\r\nreg = readl(gate->reg);\r\nreg &= ~(3 << gate->bit_idx);\r\nwritel(reg, gate->reg);\r\n}\r\nspin_unlock_irqrestore(gate->lock, flags);\r\n}\r\nstruct clk *clk_register_gate2(struct device *dev, const char *name,\r\nconst char *parent_name, unsigned long flags,\r\nvoid __iomem *reg, u8 bit_idx,\r\nu8 clk_gate2_flags, spinlock_t *lock,\r\nunsigned int *share_count)\r\n{\r\nstruct clk_gate2 *gate;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\ngate = kzalloc(sizeof(struct clk_gate2), GFP_KERNEL);\r\nif (!gate)\r\nreturn ERR_PTR(-ENOMEM);\r\ngate->reg = reg;\r\ngate->bit_idx = bit_idx;\r\ngate->flags = clk_gate2_flags;\r\ngate->lock = lock;\r\ngate->share_count = share_count;\r\ninit.name = name;\r\ninit.ops = &clk_gate2_ops;\r\ninit.flags = flags;\r\ninit.parent_names = parent_name ? &parent_name : NULL;\r\ninit.num_parents = parent_name ? 1 : 0;\r\ngate->hw.init = &init;\r\nclk = clk_register(dev, &gate->hw);\r\nif (IS_ERR(clk))\r\nkfree(gate);\r\nreturn clk;\r\n}
