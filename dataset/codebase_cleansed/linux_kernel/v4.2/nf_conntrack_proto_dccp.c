static inline struct dccp_net *dccp_pernet(struct net *net)\r\n{\r\nreturn net_generic(net, dccp_net_id);\r\n}\r\nstatic bool dccp_pkt_to_tuple(const struct sk_buff *skb, unsigned int dataoff,\r\nstruct nf_conntrack_tuple *tuple)\r\n{\r\nstruct dccp_hdr _hdr, *dh;\r\ndh = skb_header_pointer(skb, dataoff, sizeof(_hdr), &_hdr);\r\nif (dh == NULL)\r\nreturn false;\r\ntuple->src.u.dccp.port = dh->dccph_sport;\r\ntuple->dst.u.dccp.port = dh->dccph_dport;\r\nreturn true;\r\n}\r\nstatic bool dccp_invert_tuple(struct nf_conntrack_tuple *inv,\r\nconst struct nf_conntrack_tuple *tuple)\r\n{\r\ninv->src.u.dccp.port = tuple->dst.u.dccp.port;\r\ninv->dst.u.dccp.port = tuple->src.u.dccp.port;\r\nreturn true;\r\n}\r\nstatic bool dccp_new(struct nf_conn *ct, const struct sk_buff *skb,\r\nunsigned int dataoff, unsigned int *timeouts)\r\n{\r\nstruct net *net = nf_ct_net(ct);\r\nstruct dccp_net *dn;\r\nstruct dccp_hdr _dh, *dh;\r\nconst char *msg;\r\nu_int8_t state;\r\ndh = skb_header_pointer(skb, dataoff, sizeof(_dh), &_dh);\r\nBUG_ON(dh == NULL);\r\nstate = dccp_state_table[CT_DCCP_ROLE_CLIENT][dh->dccph_type][CT_DCCP_NONE];\r\nswitch (state) {\r\ndefault:\r\ndn = dccp_pernet(net);\r\nif (dn->dccp_loose == 0) {\r\nmsg = "nf_ct_dccp: not picking up existing connection ";\r\ngoto out_invalid;\r\n}\r\ncase CT_DCCP_REQUEST:\r\nbreak;\r\ncase CT_DCCP_INVALID:\r\nmsg = "nf_ct_dccp: invalid state transition ";\r\ngoto out_invalid;\r\n}\r\nct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_CLIENT;\r\nct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_SERVER;\r\nct->proto.dccp.state = CT_DCCP_NONE;\r\nct->proto.dccp.last_pkt = DCCP_PKT_REQUEST;\r\nct->proto.dccp.last_dir = IP_CT_DIR_ORIGINAL;\r\nct->proto.dccp.handshake_seq = 0;\r\nreturn true;\r\nout_invalid:\r\nif (LOG_INVALID(net, IPPROTO_DCCP))\r\nnf_log_packet(net, nf_ct_l3num(ct), 0, skb, NULL, NULL,\r\nNULL, "%s", msg);\r\nreturn false;\r\n}\r\nstatic u64 dccp_ack_seq(const struct dccp_hdr *dh)\r\n{\r\nconst struct dccp_hdr_ack_bits *dhack;\r\ndhack = (void *)dh + __dccp_basic_hdr_len(dh);\r\nreturn ((u64)ntohs(dhack->dccph_ack_nr_high) << 32) +\r\nntohl(dhack->dccph_ack_nr_low);\r\n}\r\nstatic unsigned int *dccp_get_timeouts(struct net *net)\r\n{\r\nreturn dccp_pernet(net)->dccp_timeout;\r\n}\r\nstatic int dccp_packet(struct nf_conn *ct, const struct sk_buff *skb,\r\nunsigned int dataoff, enum ip_conntrack_info ctinfo,\r\nu_int8_t pf, unsigned int hooknum,\r\nunsigned int *timeouts)\r\n{\r\nstruct net *net = nf_ct_net(ct);\r\nenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\r\nstruct dccp_hdr _dh, *dh;\r\nu_int8_t type, old_state, new_state;\r\nenum ct_dccp_roles role;\r\ndh = skb_header_pointer(skb, dataoff, sizeof(_dh), &_dh);\r\nBUG_ON(dh == NULL);\r\ntype = dh->dccph_type;\r\nif (type == DCCP_PKT_RESET &&\r\n!test_bit(IPS_SEEN_REPLY_BIT, &ct->status)) {\r\nnf_ct_kill_acct(ct, ctinfo, skb);\r\nreturn NF_ACCEPT;\r\n}\r\nspin_lock_bh(&ct->lock);\r\nrole = ct->proto.dccp.role[dir];\r\nold_state = ct->proto.dccp.state;\r\nnew_state = dccp_state_table[role][type][old_state];\r\nswitch (new_state) {\r\ncase CT_DCCP_REQUEST:\r\nif (old_state == CT_DCCP_TIMEWAIT &&\r\nrole == CT_DCCP_ROLE_SERVER) {\r\nct->proto.dccp.role[dir] = CT_DCCP_ROLE_CLIENT;\r\nct->proto.dccp.role[!dir] = CT_DCCP_ROLE_SERVER;\r\n}\r\nbreak;\r\ncase CT_DCCP_RESPOND:\r\nif (old_state == CT_DCCP_REQUEST)\r\nct->proto.dccp.handshake_seq = dccp_hdr_seq(dh);\r\nbreak;\r\ncase CT_DCCP_PARTOPEN:\r\nif (old_state == CT_DCCP_RESPOND &&\r\ntype == DCCP_PKT_ACK &&\r\ndccp_ack_seq(dh) == ct->proto.dccp.handshake_seq)\r\nset_bit(IPS_ASSURED_BIT, &ct->status);\r\nbreak;\r\ncase CT_DCCP_IGNORE:\r\nif (ct->proto.dccp.last_dir == !dir &&\r\nct->proto.dccp.last_pkt == DCCP_PKT_REQUEST &&\r\ntype == DCCP_PKT_RESPONSE) {\r\nct->proto.dccp.role[!dir] = CT_DCCP_ROLE_CLIENT;\r\nct->proto.dccp.role[dir] = CT_DCCP_ROLE_SERVER;\r\nct->proto.dccp.handshake_seq = dccp_hdr_seq(dh);\r\nnew_state = CT_DCCP_RESPOND;\r\nbreak;\r\n}\r\nct->proto.dccp.last_dir = dir;\r\nct->proto.dccp.last_pkt = type;\r\nspin_unlock_bh(&ct->lock);\r\nif (LOG_INVALID(net, IPPROTO_DCCP))\r\nnf_log_packet(net, pf, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_dccp: invalid packet ignored ");\r\nreturn NF_ACCEPT;\r\ncase CT_DCCP_INVALID:\r\nspin_unlock_bh(&ct->lock);\r\nif (LOG_INVALID(net, IPPROTO_DCCP))\r\nnf_log_packet(net, pf, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_dccp: invalid state transition ");\r\nreturn -NF_ACCEPT;\r\n}\r\nct->proto.dccp.last_dir = dir;\r\nct->proto.dccp.last_pkt = type;\r\nct->proto.dccp.state = new_state;\r\nspin_unlock_bh(&ct->lock);\r\nif (new_state != old_state)\r\nnf_conntrack_event_cache(IPCT_PROTOINFO, ct);\r\nnf_ct_refresh_acct(ct, ctinfo, skb, timeouts[new_state]);\r\nreturn NF_ACCEPT;\r\n}\r\nstatic int dccp_error(struct net *net, struct nf_conn *tmpl,\r\nstruct sk_buff *skb, unsigned int dataoff,\r\nenum ip_conntrack_info *ctinfo,\r\nu_int8_t pf, unsigned int hooknum)\r\n{\r\nstruct dccp_hdr _dh, *dh;\r\nunsigned int dccp_len = skb->len - dataoff;\r\nunsigned int cscov;\r\nconst char *msg;\r\ndh = skb_header_pointer(skb, dataoff, sizeof(_dh), &_dh);\r\nif (dh == NULL) {\r\nmsg = "nf_ct_dccp: short packet ";\r\ngoto out_invalid;\r\n}\r\nif (dh->dccph_doff * 4 < sizeof(struct dccp_hdr) ||\r\ndh->dccph_doff * 4 > dccp_len) {\r\nmsg = "nf_ct_dccp: truncated/malformed packet ";\r\ngoto out_invalid;\r\n}\r\ncscov = dccp_len;\r\nif (dh->dccph_cscov) {\r\ncscov = (dh->dccph_cscov - 1) * 4;\r\nif (cscov > dccp_len) {\r\nmsg = "nf_ct_dccp: bad checksum coverage ";\r\ngoto out_invalid;\r\n}\r\n}\r\nif (net->ct.sysctl_checksum && hooknum == NF_INET_PRE_ROUTING &&\r\nnf_checksum_partial(skb, hooknum, dataoff, cscov, IPPROTO_DCCP,\r\npf)) {\r\nmsg = "nf_ct_dccp: bad checksum ";\r\ngoto out_invalid;\r\n}\r\nif (dh->dccph_type >= DCCP_PKT_INVALID) {\r\nmsg = "nf_ct_dccp: reserved packet type ";\r\ngoto out_invalid;\r\n}\r\nreturn NF_ACCEPT;\r\nout_invalid:\r\nif (LOG_INVALID(net, IPPROTO_DCCP))\r\nnf_log_packet(net, pf, 0, skb, NULL, NULL, NULL, "%s", msg);\r\nreturn -NF_ACCEPT;\r\n}\r\nstatic void dccp_print_tuple(struct seq_file *s,\r\nconst struct nf_conntrack_tuple *tuple)\r\n{\r\nseq_printf(s, "sport=%hu dport=%hu ",\r\nntohs(tuple->src.u.dccp.port),\r\nntohs(tuple->dst.u.dccp.port));\r\n}\r\nstatic void dccp_print_conntrack(struct seq_file *s, struct nf_conn *ct)\r\n{\r\nseq_printf(s, "%s ", dccp_state_names[ct->proto.dccp.state]);\r\n}\r\nstatic int dccp_to_nlattr(struct sk_buff *skb, struct nlattr *nla,\r\nstruct nf_conn *ct)\r\n{\r\nstruct nlattr *nest_parms;\r\nspin_lock_bh(&ct->lock);\r\nnest_parms = nla_nest_start(skb, CTA_PROTOINFO_DCCP | NLA_F_NESTED);\r\nif (!nest_parms)\r\ngoto nla_put_failure;\r\nif (nla_put_u8(skb, CTA_PROTOINFO_DCCP_STATE, ct->proto.dccp.state) ||\r\nnla_put_u8(skb, CTA_PROTOINFO_DCCP_ROLE,\r\nct->proto.dccp.role[IP_CT_DIR_ORIGINAL]) ||\r\nnla_put_be64(skb, CTA_PROTOINFO_DCCP_HANDSHAKE_SEQ,\r\ncpu_to_be64(ct->proto.dccp.handshake_seq)))\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest_parms);\r\nspin_unlock_bh(&ct->lock);\r\nreturn 0;\r\nnla_put_failure:\r\nspin_unlock_bh(&ct->lock);\r\nreturn -1;\r\n}\r\nstatic int nlattr_to_dccp(struct nlattr *cda[], struct nf_conn *ct)\r\n{\r\nstruct nlattr *attr = cda[CTA_PROTOINFO_DCCP];\r\nstruct nlattr *tb[CTA_PROTOINFO_DCCP_MAX + 1];\r\nint err;\r\nif (!attr)\r\nreturn 0;\r\nerr = nla_parse_nested(tb, CTA_PROTOINFO_DCCP_MAX, attr,\r\ndccp_nla_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (!tb[CTA_PROTOINFO_DCCP_STATE] ||\r\n!tb[CTA_PROTOINFO_DCCP_ROLE] ||\r\nnla_get_u8(tb[CTA_PROTOINFO_DCCP_ROLE]) > CT_DCCP_ROLE_MAX ||\r\nnla_get_u8(tb[CTA_PROTOINFO_DCCP_STATE]) >= CT_DCCP_IGNORE) {\r\nreturn -EINVAL;\r\n}\r\nspin_lock_bh(&ct->lock);\r\nct->proto.dccp.state = nla_get_u8(tb[CTA_PROTOINFO_DCCP_STATE]);\r\nif (nla_get_u8(tb[CTA_PROTOINFO_DCCP_ROLE]) == CT_DCCP_ROLE_CLIENT) {\r\nct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_CLIENT;\r\nct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_SERVER;\r\n} else {\r\nct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_SERVER;\r\nct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_CLIENT;\r\n}\r\nif (tb[CTA_PROTOINFO_DCCP_HANDSHAKE_SEQ]) {\r\nct->proto.dccp.handshake_seq =\r\nbe64_to_cpu(nla_get_be64(tb[CTA_PROTOINFO_DCCP_HANDSHAKE_SEQ]));\r\n}\r\nspin_unlock_bh(&ct->lock);\r\nreturn 0;\r\n}\r\nstatic int dccp_nlattr_size(void)\r\n{\r\nreturn nla_total_size(0)\r\n+ nla_policy_len(dccp_nla_policy, CTA_PROTOINFO_DCCP_MAX + 1);\r\n}\r\nstatic int dccp_timeout_nlattr_to_obj(struct nlattr *tb[],\r\nstruct net *net, void *data)\r\n{\r\nstruct dccp_net *dn = dccp_pernet(net);\r\nunsigned int *timeouts = data;\r\nint i;\r\nfor (i=0; i<CT_DCCP_MAX; i++)\r\ntimeouts[i] = dn->dccp_timeout[i];\r\nfor (i=CTA_TIMEOUT_DCCP_UNSPEC+1; i<CTA_TIMEOUT_DCCP_MAX+1; i++) {\r\nif (tb[i]) {\r\ntimeouts[i] = ntohl(nla_get_be32(tb[i])) * HZ;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ndccp_timeout_obj_to_nlattr(struct sk_buff *skb, const void *data)\r\n{\r\nconst unsigned int *timeouts = data;\r\nint i;\r\nfor (i=CTA_TIMEOUT_DCCP_UNSPEC+1; i<CTA_TIMEOUT_DCCP_MAX+1; i++) {\r\nif (nla_put_be32(skb, i, htonl(timeouts[i] / HZ)))\r\ngoto nla_put_failure;\r\n}\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -ENOSPC;\r\n}\r\nstatic int dccp_kmemdup_sysctl_table(struct net *net, struct nf_proto_net *pn,\r\nstruct dccp_net *dn)\r\n{\r\n#ifdef CONFIG_SYSCTL\r\nif (pn->ctl_table)\r\nreturn 0;\r\npn->ctl_table = kmemdup(dccp_sysctl_table,\r\nsizeof(dccp_sysctl_table),\r\nGFP_KERNEL);\r\nif (!pn->ctl_table)\r\nreturn -ENOMEM;\r\npn->ctl_table[0].data = &dn->dccp_timeout[CT_DCCP_REQUEST];\r\npn->ctl_table[1].data = &dn->dccp_timeout[CT_DCCP_RESPOND];\r\npn->ctl_table[2].data = &dn->dccp_timeout[CT_DCCP_PARTOPEN];\r\npn->ctl_table[3].data = &dn->dccp_timeout[CT_DCCP_OPEN];\r\npn->ctl_table[4].data = &dn->dccp_timeout[CT_DCCP_CLOSEREQ];\r\npn->ctl_table[5].data = &dn->dccp_timeout[CT_DCCP_CLOSING];\r\npn->ctl_table[6].data = &dn->dccp_timeout[CT_DCCP_TIMEWAIT];\r\npn->ctl_table[7].data = &dn->dccp_loose;\r\nif (net->user_ns != &init_user_ns)\r\npn->ctl_table[0].procname = NULL;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int dccp_init_net(struct net *net, u_int16_t proto)\r\n{\r\nstruct dccp_net *dn = dccp_pernet(net);\r\nstruct nf_proto_net *pn = &dn->pn;\r\nif (!pn->users) {\r\ndn->dccp_loose = 1;\r\ndn->dccp_timeout[CT_DCCP_REQUEST] = 2 * DCCP_MSL;\r\ndn->dccp_timeout[CT_DCCP_RESPOND] = 4 * DCCP_MSL;\r\ndn->dccp_timeout[CT_DCCP_PARTOPEN] = 4 * DCCP_MSL;\r\ndn->dccp_timeout[CT_DCCP_OPEN] = 12 * 3600 * HZ;\r\ndn->dccp_timeout[CT_DCCP_CLOSEREQ] = 64 * HZ;\r\ndn->dccp_timeout[CT_DCCP_CLOSING] = 64 * HZ;\r\ndn->dccp_timeout[CT_DCCP_TIMEWAIT] = 2 * DCCP_MSL;\r\n}\r\nreturn dccp_kmemdup_sysctl_table(net, pn, dn);\r\n}\r\nstatic __net_init int dccp_net_init(struct net *net)\r\n{\r\nint ret = 0;\r\nret = nf_ct_l4proto_pernet_register(net, &dccp_proto4);\r\nif (ret < 0) {\r\npr_err("nf_conntrack_dccp4: pernet registration failed.\n");\r\ngoto out;\r\n}\r\nret = nf_ct_l4proto_pernet_register(net, &dccp_proto6);\r\nif (ret < 0) {\r\npr_err("nf_conntrack_dccp6: pernet registration failed.\n");\r\ngoto cleanup_dccp4;\r\n}\r\nreturn 0;\r\ncleanup_dccp4:\r\nnf_ct_l4proto_pernet_unregister(net, &dccp_proto4);\r\nout:\r\nreturn ret;\r\n}\r\nstatic __net_exit void dccp_net_exit(struct net *net)\r\n{\r\nnf_ct_l4proto_pernet_unregister(net, &dccp_proto6);\r\nnf_ct_l4proto_pernet_unregister(net, &dccp_proto4);\r\n}\r\nstatic int __init nf_conntrack_proto_dccp_init(void)\r\n{\r\nint ret;\r\nret = register_pernet_subsys(&dccp_net_ops);\r\nif (ret < 0)\r\ngoto out_pernet;\r\nret = nf_ct_l4proto_register(&dccp_proto4);\r\nif (ret < 0)\r\ngoto out_dccp4;\r\nret = nf_ct_l4proto_register(&dccp_proto6);\r\nif (ret < 0)\r\ngoto out_dccp6;\r\nreturn 0;\r\nout_dccp6:\r\nnf_ct_l4proto_unregister(&dccp_proto4);\r\nout_dccp4:\r\nunregister_pernet_subsys(&dccp_net_ops);\r\nout_pernet:\r\nreturn ret;\r\n}\r\nstatic void __exit nf_conntrack_proto_dccp_fini(void)\r\n{\r\nnf_ct_l4proto_unregister(&dccp_proto6);\r\nnf_ct_l4proto_unregister(&dccp_proto4);\r\nunregister_pernet_subsys(&dccp_net_ops);\r\n}
