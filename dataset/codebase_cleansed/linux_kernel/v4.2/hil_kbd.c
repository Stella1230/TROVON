static bool hil_dev_is_command_response(hil_packet p)\r\n{\r\nif ((p & ~HIL_CMDCT_POL) == (HIL_ERR_INT | HIL_PKT_CMD | HIL_CMD_POL))\r\nreturn false;\r\nif ((p & ~HIL_CMDCT_RPL) == (HIL_ERR_INT | HIL_PKT_CMD | HIL_CMD_RPL))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void hil_dev_handle_command_response(struct hil_dev *dev)\r\n{\r\nhil_packet p;\r\nchar *buf;\r\nint i, idx;\r\nidx = dev->idx4 / 4;\r\np = dev->data[idx - 1];\r\nswitch (p & HIL_PKT_DATA_MASK) {\r\ncase HIL_CMD_IDD:\r\nbuf = dev->idd;\r\nbreak;\r\ncase HIL_CMD_RSC:\r\nbuf = dev->rsc;\r\nbreak;\r\ncase HIL_CMD_EXD:\r\nbuf = dev->exd;\r\nbreak;\r\ncase HIL_CMD_RNM:\r\ndev->rnm[HIL_PACKET_MAX_LENGTH] = 0;\r\nbuf = dev->rnm;\r\nbreak;\r\ndefault:\r\nif (p != (HIL_ERR_INT | HIL_PKT_CMD)) {\r\nprintk(KERN_WARNING PREFIX "Device sent unknown record %x\n", p);\r\n}\r\ngoto out;\r\n}\r\nfor (i = 0; i < idx; i++)\r\nbuf[i] = dev->data[i] & HIL_PKT_DATA_MASK;\r\nfor (; i < HIL_PACKET_MAX_LENGTH; i++)\r\nbuf[i] = 0;\r\nout:\r\ncomplete(&dev->cmd_done);\r\n}\r\nstatic void hil_dev_handle_kbd_events(struct hil_dev *kbd)\r\n{\r\nstruct input_dev *dev = kbd->dev;\r\nint idx = kbd->idx4 / 4;\r\nint i;\r\nswitch (kbd->data[0] & HIL_POL_CHARTYPE_MASK) {\r\ncase HIL_POL_CHARTYPE_NONE:\r\nreturn;\r\ncase HIL_POL_CHARTYPE_ASCII:\r\nfor (i = 1; i < idx - 1; i++)\r\ninput_report_key(dev, kbd->data[i] & 0x7f, 1);\r\nbreak;\r\ncase HIL_POL_CHARTYPE_RSVD1:\r\ncase HIL_POL_CHARTYPE_RSVD2:\r\ncase HIL_POL_CHARTYPE_BINARY:\r\nfor (i = 1; i < idx - 1; i++)\r\ninput_report_key(dev, kbd->data[i], 1);\r\nbreak;\r\ncase HIL_POL_CHARTYPE_SET1:\r\nfor (i = 1; i < idx - 1; i++) {\r\nunsigned int key = kbd->data[i];\r\nint up = key & HIL_KBD_SET1_UPBIT;\r\nkey &= (~HIL_KBD_SET1_UPBIT & 0xff);\r\nkey = hil_kbd_set1[key >> HIL_KBD_SET1_SHIFT];\r\ninput_report_key(dev, key, !up);\r\n}\r\nbreak;\r\ncase HIL_POL_CHARTYPE_SET2:\r\nfor (i = 1; i < idx - 1; i++) {\r\nunsigned int key = kbd->data[i];\r\nint up = key & HIL_KBD_SET2_UPBIT;\r\nkey &= (~HIL_KBD_SET1_UPBIT & 0xff);\r\nkey = key >> HIL_KBD_SET2_SHIFT;\r\ninput_report_key(dev, key, !up);\r\n}\r\nbreak;\r\ncase HIL_POL_CHARTYPE_SET3:\r\nfor (i = 1; i < idx - 1; i++) {\r\nunsigned int key = kbd->data[i];\r\nint up = key & HIL_KBD_SET3_UPBIT;\r\nkey &= (~HIL_KBD_SET1_UPBIT & 0xff);\r\nkey = hil_kbd_set3[key >> HIL_KBD_SET3_SHIFT];\r\ninput_report_key(dev, key, !up);\r\n}\r\nbreak;\r\n}\r\ninput_sync(dev);\r\n}\r\nstatic void hil_dev_handle_ptr_events(struct hil_dev *ptr)\r\n{\r\nstruct input_dev *dev = ptr->dev;\r\nint idx = ptr->idx4 / 4;\r\nhil_packet p = ptr->data[idx - 1];\r\nint i, cnt, laxis;\r\nbool absdev, ax16;\r\nif ((p & HIL_CMDCT_POL) != idx - 1) {\r\nprintk(KERN_WARNING PREFIX\r\n"Malformed poll packet %x (idx = %i)\n", p, idx);\r\nreturn;\r\n}\r\ni = (p & HIL_POL_AXIS_ALT) ? 3 : 0;\r\nlaxis = (p & HIL_POL_NUM_AXES_MASK) + i;\r\nax16 = ptr->idd[1] & HIL_IDD_HEADER_16BIT;\r\nabsdev = ptr->idd[1] & HIL_IDD_HEADER_ABS;\r\nfor (cnt = 1; i < laxis; i++) {\r\nunsigned int lo, hi, val;\r\nlo = ptr->data[cnt++] & HIL_PKT_DATA_MASK;\r\nhi = ax16 ? (ptr->data[cnt++] & HIL_PKT_DATA_MASK) : 0;\r\nif (absdev) {\r\nval = lo + (hi << 8);\r\n#ifdef TABLET_AUTOADJUST\r\nif (val < input_abs_get_min(dev, ABS_X + i))\r\ninput_abs_set_min(dev, ABS_X + i, val);\r\nif (val > input_abs_get_max(dev, ABS_X + i))\r\ninput_abs_set_max(dev, ABS_X + i, val);\r\n#endif\r\nif (i % 3)\r\nval = input_abs_get_max(dev, ABS_X + i) - val;\r\ninput_report_abs(dev, ABS_X + i, val);\r\n} else {\r\nval = (int) (((int8_t) lo) | ((int8_t) hi << 8));\r\nif (i % 3)\r\nval *= -1;\r\ninput_report_rel(dev, REL_X + i, val);\r\n}\r\n}\r\nwhile (cnt < idx - 1) {\r\nunsigned int btn = ptr->data[cnt++];\r\nint up = btn & 1;\r\nbtn &= 0xfe;\r\nif (btn == 0x8e)\r\ncontinue;\r\nif (btn > 0x8c || btn < 0x80)\r\ncontinue;\r\nbtn = (btn - 0x80) >> 1;\r\nbtn = ptr->btnmap[btn];\r\ninput_report_key(dev, btn, !up);\r\n}\r\ninput_sync(dev);\r\n}\r\nstatic void hil_dev_process_err(struct hil_dev *dev)\r\n{\r\nprintk(KERN_WARNING PREFIX "errored HIL packet\n");\r\ndev->idx4 = 0;\r\ncomplete(&dev->cmd_done);\r\n}\r\nstatic irqreturn_t hil_dev_interrupt(struct serio *serio,\r\nunsigned char data, unsigned int flags)\r\n{\r\nstruct hil_dev *dev;\r\nhil_packet packet;\r\nint idx;\r\ndev = serio_get_drvdata(serio);\r\nBUG_ON(dev == NULL);\r\nif (dev->idx4 >= HIL_PACKET_MAX_LENGTH * sizeof(hil_packet)) {\r\nhil_dev_process_err(dev);\r\ngoto out;\r\n}\r\nidx = dev->idx4 / 4;\r\nif (!(dev->idx4 % 4))\r\ndev->data[idx] = 0;\r\npacket = dev->data[idx];\r\npacket |= ((hil_packet)data) << ((3 - (dev->idx4 % 4)) * 8);\r\ndev->data[idx] = packet;\r\nif ((++dev->idx4 % 4) == 0) {\r\nif ((packet & 0xffff0000) != HIL_ERR_INT) {\r\nhil_dev_process_err(dev);\r\n} else if (packet & HIL_PKT_CMD) {\r\nif (hil_dev_is_command_response(packet))\r\nhil_dev_handle_command_response(dev);\r\nelse if (dev->is_pointer)\r\nhil_dev_handle_ptr_events(dev);\r\nelse\r\nhil_dev_handle_kbd_events(dev);\r\ndev->idx4 = 0;\r\n}\r\n}\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void hil_dev_disconnect(struct serio *serio)\r\n{\r\nstruct hil_dev *dev = serio_get_drvdata(serio);\r\nBUG_ON(dev == NULL);\r\nserio_close(serio);\r\ninput_unregister_device(dev->dev);\r\nserio_set_drvdata(serio, NULL);\r\nkfree(dev);\r\n}\r\nstatic void hil_dev_keyboard_setup(struct hil_dev *kbd)\r\n{\r\nstruct input_dev *input_dev = kbd->dev;\r\nuint8_t did = kbd->idd[0];\r\nint i;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);\r\ninput_dev->ledbit[0] = BIT_MASK(LED_NUML) | BIT_MASK(LED_CAPSL) |\r\nBIT_MASK(LED_SCROLLL);\r\nfor (i = 0; i < 128; i++) {\r\n__set_bit(hil_kbd_set1[i], input_dev->keybit);\r\n__set_bit(hil_kbd_set3[i], input_dev->keybit);\r\n}\r\n__clear_bit(KEY_RESERVED, input_dev->keybit);\r\ninput_dev->keycodemax = HIL_KEYCODES_SET1_TBLSIZE;\r\ninput_dev->keycodesize = sizeof(hil_kbd_set1[0]);\r\ninput_dev->keycode = hil_kbd_set1;\r\ninput_dev->name = strlen(kbd->rnm) ? kbd->rnm : "HIL keyboard";\r\ninput_dev->phys = "hpkbd/input0";\r\nprintk(KERN_INFO PREFIX "HIL keyboard found (did = 0x%02x, lang = %s)\n",\r\ndid, hil_language[did & HIL_IDD_DID_TYPE_KB_LANG_MASK]);\r\n}\r\nstatic void hil_dev_pointer_setup(struct hil_dev *ptr)\r\n{\r\nstruct input_dev *input_dev = ptr->dev;\r\nuint8_t did = ptr->idd[0];\r\nuint8_t *idd = ptr->idd + 1;\r\nunsigned int naxsets = HIL_IDD_NUM_AXSETS(*idd);\r\nunsigned int i, btntype;\r\nconst char *txt;\r\nptr->naxes = HIL_IDD_NUM_AXES_PER_SET(*idd);\r\nswitch (did & HIL_IDD_DID_TYPE_MASK) {\r\ncase HIL_IDD_DID_TYPE_REL:\r\ninput_dev->evbit[0] = BIT_MASK(EV_REL);\r\nfor (i = 0; i < ptr->naxes; i++)\r\n__set_bit(REL_X + i, input_dev->relbit);\r\nfor (i = 3; naxsets > 1 && i < ptr->naxes + 3; i++)\r\n__set_bit(REL_X + i, input_dev->relbit);\r\ntxt = "relative";\r\nbreak;\r\ncase HIL_IDD_DID_TYPE_ABS:\r\ninput_dev->evbit[0] = BIT_MASK(EV_ABS);\r\nfor (i = 0; i < ptr->naxes; i++)\r\ninput_set_abs_params(input_dev, ABS_X + i,\r\n0, HIL_IDD_AXIS_MAX(idd, i), 0, 0);\r\nfor (i = 3; naxsets > 1 && i < ptr->naxes + 3; i++)\r\ninput_set_abs_params(input_dev, ABS_X + i,\r\n0, HIL_IDD_AXIS_MAX(idd, i - 3), 0, 0);\r\n#ifdef TABLET_AUTOADJUST\r\nfor (i = 0; i < ABS_MAX; i++) {\r\nint diff = input_abs_get_max(input_dev, ABS_X + i) / 10;\r\ninput_abs_set_min(input_dev, ABS_X + i,\r\ninput_abs_get_min(input_dev, ABS_X + i) + diff);\r\ninput_abs_set_max(input_dev, ABS_X + i,\r\ninput_abs_get_max(input_dev, ABS_X + i) - diff);\r\n}\r\n#endif\r\ntxt = "absolute";\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nptr->nbtn = HIL_IDD_NUM_BUTTONS(idd);\r\nif (ptr->nbtn)\r\ninput_dev->evbit[0] |= BIT_MASK(EV_KEY);\r\nbtntype = BTN_MISC;\r\nif ((did & HIL_IDD_DID_ABS_TABLET_MASK) == HIL_IDD_DID_ABS_TABLET)\r\n#ifdef TABLET_SIMULATES_MOUSE\r\nbtntype = BTN_TOUCH;\r\n#else\r\nbtntype = BTN_DIGI;\r\n#endif\r\nif ((did & HIL_IDD_DID_ABS_TSCREEN_MASK) == HIL_IDD_DID_ABS_TSCREEN)\r\nbtntype = BTN_TOUCH;\r\nif ((did & HIL_IDD_DID_REL_MOUSE_MASK) == HIL_IDD_DID_REL_MOUSE)\r\nbtntype = BTN_MOUSE;\r\nfor (i = 0; i < ptr->nbtn; i++) {\r\n__set_bit(btntype | i, input_dev->keybit);\r\nptr->btnmap[i] = btntype | i;\r\n}\r\nif (btntype == BTN_MOUSE) {\r\nptr->btnmap[1] = BTN_MIDDLE;\r\nptr->btnmap[2] = BTN_RIGHT;\r\n}\r\ninput_dev->name = strlen(ptr->rnm) ? ptr->rnm : "HIL pointer device";\r\nprintk(KERN_INFO PREFIX\r\n"HIL pointer device found (did: 0x%02x, axis: %s)\n",\r\ndid, txt);\r\nprintk(KERN_INFO PREFIX\r\n"HIL pointer has %i buttons and %i sets of %i axes\n",\r\nptr->nbtn, naxsets, ptr->naxes);\r\n}\r\nstatic int hil_dev_connect(struct serio *serio, struct serio_driver *drv)\r\n{\r\nstruct hil_dev *dev;\r\nstruct input_dev *input_dev;\r\nuint8_t did, *idd;\r\nint error;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!dev || !input_dev) {\r\nerror = -ENOMEM;\r\ngoto bail0;\r\n}\r\ndev->serio = serio;\r\ndev->dev = input_dev;\r\nerror = serio_open(serio, drv);\r\nif (error)\r\ngoto bail0;\r\nserio_set_drvdata(serio, dev);\r\ninit_completion(&dev->cmd_done);\r\nserio_write(serio, 0);\r\nserio_write(serio, 0);\r\nserio_write(serio, HIL_PKT_CMD >> 8);\r\nserio_write(serio, HIL_CMD_IDD);\r\nerror = wait_for_completion_killable(&dev->cmd_done);\r\nif (error)\r\ngoto bail1;\r\nreinit_completion(&dev->cmd_done);\r\nserio_write(serio, 0);\r\nserio_write(serio, 0);\r\nserio_write(serio, HIL_PKT_CMD >> 8);\r\nserio_write(serio, HIL_CMD_RSC);\r\nerror = wait_for_completion_killable(&dev->cmd_done);\r\nif (error)\r\ngoto bail1;\r\nreinit_completion(&dev->cmd_done);\r\nserio_write(serio, 0);\r\nserio_write(serio, 0);\r\nserio_write(serio, HIL_PKT_CMD >> 8);\r\nserio_write(serio, HIL_CMD_RNM);\r\nerror = wait_for_completion_killable(&dev->cmd_done);\r\nif (error)\r\ngoto bail1;\r\nreinit_completion(&dev->cmd_done);\r\nserio_write(serio, 0);\r\nserio_write(serio, 0);\r\nserio_write(serio, HIL_PKT_CMD >> 8);\r\nserio_write(serio, HIL_CMD_EXD);\r\nerror = wait_for_completion_killable(&dev->cmd_done);\r\nif (error)\r\ngoto bail1;\r\ndid = dev->idd[0];\r\nidd = dev->idd + 1;\r\nswitch (did & HIL_IDD_DID_TYPE_MASK) {\r\ncase HIL_IDD_DID_TYPE_KB_INTEGRAL:\r\ncase HIL_IDD_DID_TYPE_KB_ITF:\r\ncase HIL_IDD_DID_TYPE_KB_RSVD:\r\ncase HIL_IDD_DID_TYPE_CHAR:\r\nif (HIL_IDD_NUM_BUTTONS(idd) ||\r\nHIL_IDD_NUM_AXES_PER_SET(*idd)) {\r\nprintk(KERN_INFO PREFIX\r\n"combo devices are not supported.\n");\r\ngoto bail1;\r\n}\r\ndev->is_pointer = false;\r\nhil_dev_keyboard_setup(dev);\r\nbreak;\r\ncase HIL_IDD_DID_TYPE_REL:\r\ncase HIL_IDD_DID_TYPE_ABS:\r\ndev->is_pointer = true;\r\nhil_dev_pointer_setup(dev);\r\nbreak;\r\ndefault:\r\ngoto bail1;\r\n}\r\ninput_dev->id.bustype = BUS_HIL;\r\ninput_dev->id.vendor = PCI_VENDOR_ID_HP;\r\ninput_dev->id.product = 0x0001;\r\ninput_dev->id.version = 0x0100;\r\ninput_dev->dev.parent = &serio->dev;\r\nif (!dev->is_pointer) {\r\nserio_write(serio, 0);\r\nserio_write(serio, 0);\r\nserio_write(serio, HIL_PKT_CMD >> 8);\r\nserio_write(serio, HIL_CMD_EK1);\r\n}\r\nerror = input_register_device(input_dev);\r\nif (error)\r\ngoto bail1;\r\nreturn 0;\r\nbail1:\r\nserio_close(serio);\r\nserio_set_drvdata(serio, NULL);\r\nbail0:\r\ninput_free_device(input_dev);\r\nkfree(dev);\r\nreturn error;\r\n}
