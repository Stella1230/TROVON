static int get_exclusive(struct ubi_volume_desc *desc)\r\n{\r\nint users, err;\r\nstruct ubi_volume *vol = desc->vol;\r\nspin_lock(&vol->ubi->volumes_lock);\r\nusers = vol->readers + vol->writers + vol->exclusive + vol->metaonly;\r\nubi_assert(users > 0);\r\nif (users > 1) {\r\nubi_err(vol->ubi, "%d users for volume %d", users, vol->vol_id);\r\nerr = -EBUSY;\r\n} else {\r\nvol->readers = vol->writers = vol->metaonly = 0;\r\nvol->exclusive = 1;\r\nerr = desc->mode;\r\ndesc->mode = UBI_EXCLUSIVE;\r\n}\r\nspin_unlock(&vol->ubi->volumes_lock);\r\nreturn err;\r\n}\r\nstatic void revoke_exclusive(struct ubi_volume_desc *desc, int mode)\r\n{\r\nstruct ubi_volume *vol = desc->vol;\r\nspin_lock(&vol->ubi->volumes_lock);\r\nubi_assert(vol->readers == 0 && vol->writers == 0 && vol->metaonly == 0);\r\nubi_assert(vol->exclusive == 1 && desc->mode == UBI_EXCLUSIVE);\r\nvol->exclusive = 0;\r\nif (mode == UBI_READONLY)\r\nvol->readers = 1;\r\nelse if (mode == UBI_READWRITE)\r\nvol->writers = 1;\r\nelse if (mode == UBI_METAONLY)\r\nvol->metaonly = 1;\r\nelse\r\nvol->exclusive = 1;\r\nspin_unlock(&vol->ubi->volumes_lock);\r\ndesc->mode = mode;\r\n}\r\nstatic int vol_cdev_open(struct inode *inode, struct file *file)\r\n{\r\nstruct ubi_volume_desc *desc;\r\nint vol_id = iminor(inode) - 1, mode, ubi_num;\r\nubi_num = ubi_major2num(imajor(inode));\r\nif (ubi_num < 0)\r\nreturn ubi_num;\r\nif (file->f_mode & FMODE_WRITE)\r\nmode = UBI_READWRITE;\r\nelse\r\nmode = UBI_READONLY;\r\ndbg_gen("open device %d, volume %d, mode %d",\r\nubi_num, vol_id, mode);\r\ndesc = ubi_open_volume(ubi_num, vol_id, mode);\r\nif (IS_ERR(desc))\r\nreturn PTR_ERR(desc);\r\nfile->private_data = desc;\r\nreturn 0;\r\n}\r\nstatic int vol_cdev_release(struct inode *inode, struct file *file)\r\n{\r\nstruct ubi_volume_desc *desc = file->private_data;\r\nstruct ubi_volume *vol = desc->vol;\r\ndbg_gen("release device %d, volume %d, mode %d",\r\nvol->ubi->ubi_num, vol->vol_id, desc->mode);\r\nif (vol->updating) {\r\nubi_warn(vol->ubi, "update of volume %d not finished, volume is damaged",\r\nvol->vol_id);\r\nubi_assert(!vol->changing_leb);\r\nvol->updating = 0;\r\nvfree(vol->upd_buf);\r\n} else if (vol->changing_leb) {\r\ndbg_gen("only %lld of %lld bytes received for atomic LEB change for volume %d:%d, cancel",\r\nvol->upd_received, vol->upd_bytes, vol->ubi->ubi_num,\r\nvol->vol_id);\r\nvol->changing_leb = 0;\r\nvfree(vol->upd_buf);\r\n}\r\nubi_close_volume(desc);\r\nreturn 0;\r\n}\r\nstatic loff_t vol_cdev_llseek(struct file *file, loff_t offset, int origin)\r\n{\r\nstruct ubi_volume_desc *desc = file->private_data;\r\nstruct ubi_volume *vol = desc->vol;\r\nif (vol->updating) {\r\nubi_err(vol->ubi, "updating");\r\nreturn -EBUSY;\r\n}\r\nreturn fixed_size_llseek(file, offset, origin, vol->used_bytes);\r\n}\r\nstatic int vol_cdev_fsync(struct file *file, loff_t start, loff_t end,\r\nint datasync)\r\n{\r\nstruct ubi_volume_desc *desc = file->private_data;\r\nstruct ubi_device *ubi = desc->vol->ubi;\r\nstruct inode *inode = file_inode(file);\r\nint err;\r\nmutex_lock(&inode->i_mutex);\r\nerr = ubi_sync(ubi->ubi_num);\r\nmutex_unlock(&inode->i_mutex);\r\nreturn err;\r\n}\r\nstatic ssize_t vol_cdev_read(struct file *file, __user char *buf, size_t count,\r\nloff_t *offp)\r\n{\r\nstruct ubi_volume_desc *desc = file->private_data;\r\nstruct ubi_volume *vol = desc->vol;\r\nstruct ubi_device *ubi = vol->ubi;\r\nint err, lnum, off, len, tbuf_size;\r\nsize_t count_save = count;\r\nvoid *tbuf;\r\ndbg_gen("read %zd bytes from offset %lld of volume %d",\r\ncount, *offp, vol->vol_id);\r\nif (vol->updating) {\r\nubi_err(vol->ubi, "updating");\r\nreturn -EBUSY;\r\n}\r\nif (vol->upd_marker) {\r\nubi_err(vol->ubi, "damaged volume, update marker is set");\r\nreturn -EBADF;\r\n}\r\nif (*offp == vol->used_bytes || count == 0)\r\nreturn 0;\r\nif (vol->corrupted)\r\ndbg_gen("read from corrupted volume %d", vol->vol_id);\r\nif (*offp + count > vol->used_bytes)\r\ncount_save = count = vol->used_bytes - *offp;\r\ntbuf_size = vol->usable_leb_size;\r\nif (count < tbuf_size)\r\ntbuf_size = ALIGN(count, ubi->min_io_size);\r\ntbuf = vmalloc(tbuf_size);\r\nif (!tbuf)\r\nreturn -ENOMEM;\r\nlen = count > tbuf_size ? tbuf_size : count;\r\nlnum = div_u64_rem(*offp, vol->usable_leb_size, &off);\r\ndo {\r\ncond_resched();\r\nif (off + len >= vol->usable_leb_size)\r\nlen = vol->usable_leb_size - off;\r\nerr = ubi_eba_read_leb(ubi, vol, lnum, tbuf, off, len, 0);\r\nif (err)\r\nbreak;\r\noff += len;\r\nif (off == vol->usable_leb_size) {\r\nlnum += 1;\r\noff -= vol->usable_leb_size;\r\n}\r\ncount -= len;\r\n*offp += len;\r\nerr = copy_to_user(buf, tbuf, len);\r\nif (err) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nbuf += len;\r\nlen = count > tbuf_size ? tbuf_size : count;\r\n} while (count);\r\nvfree(tbuf);\r\nreturn err ? err : count_save - count;\r\n}\r\nstatic ssize_t vol_cdev_direct_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *offp)\r\n{\r\nstruct ubi_volume_desc *desc = file->private_data;\r\nstruct ubi_volume *vol = desc->vol;\r\nstruct ubi_device *ubi = vol->ubi;\r\nint lnum, off, len, tbuf_size, err = 0;\r\nsize_t count_save = count;\r\nchar *tbuf;\r\nif (!vol->direct_writes)\r\nreturn -EPERM;\r\ndbg_gen("requested: write %zd bytes to offset %lld of volume %u",\r\ncount, *offp, vol->vol_id);\r\nif (vol->vol_type == UBI_STATIC_VOLUME)\r\nreturn -EROFS;\r\nlnum = div_u64_rem(*offp, vol->usable_leb_size, &off);\r\nif (off & (ubi->min_io_size - 1)) {\r\nubi_err(ubi, "unaligned position");\r\nreturn -EINVAL;\r\n}\r\nif (*offp + count > vol->used_bytes)\r\ncount_save = count = vol->used_bytes - *offp;\r\nif (count & (ubi->min_io_size - 1)) {\r\nubi_err(ubi, "unaligned write length");\r\nreturn -EINVAL;\r\n}\r\ntbuf_size = vol->usable_leb_size;\r\nif (count < tbuf_size)\r\ntbuf_size = ALIGN(count, ubi->min_io_size);\r\ntbuf = vmalloc(tbuf_size);\r\nif (!tbuf)\r\nreturn -ENOMEM;\r\nlen = count > tbuf_size ? tbuf_size : count;\r\nwhile (count) {\r\ncond_resched();\r\nif (off + len >= vol->usable_leb_size)\r\nlen = vol->usable_leb_size - off;\r\nerr = copy_from_user(tbuf, buf, len);\r\nif (err) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nerr = ubi_eba_write_leb(ubi, vol, lnum, tbuf, off, len);\r\nif (err)\r\nbreak;\r\noff += len;\r\nif (off == vol->usable_leb_size) {\r\nlnum += 1;\r\noff -= vol->usable_leb_size;\r\n}\r\ncount -= len;\r\n*offp += len;\r\nbuf += len;\r\nlen = count > tbuf_size ? tbuf_size : count;\r\n}\r\nvfree(tbuf);\r\nreturn err ? err : count_save - count;\r\n}\r\nstatic ssize_t vol_cdev_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *offp)\r\n{\r\nint err = 0;\r\nstruct ubi_volume_desc *desc = file->private_data;\r\nstruct ubi_volume *vol = desc->vol;\r\nstruct ubi_device *ubi = vol->ubi;\r\nif (!vol->updating && !vol->changing_leb)\r\nreturn vol_cdev_direct_write(file, buf, count, offp);\r\nif (vol->updating)\r\nerr = ubi_more_update_data(ubi, vol, buf, count);\r\nelse\r\nerr = ubi_more_leb_change_data(ubi, vol, buf, count);\r\nif (err < 0) {\r\nubi_err(ubi, "cannot accept more %zd bytes of data, error %d",\r\ncount, err);\r\nreturn err;\r\n}\r\nif (err) {\r\ncount = err;\r\nif (vol->changing_leb) {\r\nrevoke_exclusive(desc, UBI_READWRITE);\r\nreturn count;\r\n}\r\nerr = ubi_check_volume(ubi, vol->vol_id);\r\nif (err < 0)\r\nreturn err;\r\nif (err) {\r\nubi_warn(ubi, "volume %d on UBI device %d is corrupted",\r\nvol->vol_id, ubi->ubi_num);\r\nvol->corrupted = 1;\r\n}\r\nvol->checked = 1;\r\nubi_volume_notify(ubi, vol, UBI_VOLUME_UPDATED);\r\nrevoke_exclusive(desc, UBI_READWRITE);\r\n}\r\nreturn count;\r\n}\r\nstatic long vol_cdev_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint err = 0;\r\nstruct ubi_volume_desc *desc = file->private_data;\r\nstruct ubi_volume *vol = desc->vol;\r\nstruct ubi_device *ubi = vol->ubi;\r\nvoid __user *argp = (void __user *)arg;\r\nswitch (cmd) {\r\ncase UBI_IOCVOLUP:\r\n{\r\nint64_t bytes, rsvd_bytes;\r\nif (!capable(CAP_SYS_RESOURCE)) {\r\nerr = -EPERM;\r\nbreak;\r\n}\r\nerr = copy_from_user(&bytes, argp, sizeof(int64_t));\r\nif (err) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nif (desc->mode == UBI_READONLY) {\r\nerr = -EROFS;\r\nbreak;\r\n}\r\nrsvd_bytes = (long long)vol->reserved_pebs *\r\nubi->leb_size-vol->data_pad;\r\nif (bytes < 0 || bytes > rsvd_bytes) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nerr = get_exclusive(desc);\r\nif (err < 0)\r\nbreak;\r\nerr = ubi_start_update(ubi, vol, bytes);\r\nif (bytes == 0) {\r\nubi_volume_notify(ubi, vol, UBI_VOLUME_UPDATED);\r\nrevoke_exclusive(desc, UBI_READWRITE);\r\n}\r\nbreak;\r\n}\r\ncase UBI_IOCEBCH:\r\n{\r\nstruct ubi_leb_change_req req;\r\nerr = copy_from_user(&req, argp,\r\nsizeof(struct ubi_leb_change_req));\r\nif (err) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nif (desc->mode == UBI_READONLY ||\r\nvol->vol_type == UBI_STATIC_VOLUME) {\r\nerr = -EROFS;\r\nbreak;\r\n}\r\nerr = -EINVAL;\r\nif (req.lnum < 0 || req.lnum >= vol->reserved_pebs ||\r\nreq.bytes < 0 || req.bytes > vol->usable_leb_size)\r\nbreak;\r\nerr = get_exclusive(desc);\r\nif (err < 0)\r\nbreak;\r\nerr = ubi_start_leb_change(ubi, vol, &req);\r\nif (req.bytes == 0)\r\nrevoke_exclusive(desc, UBI_READWRITE);\r\nbreak;\r\n}\r\ncase UBI_IOCEBER:\r\n{\r\nint32_t lnum;\r\nerr = get_user(lnum, (__user int32_t *)argp);\r\nif (err) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nif (desc->mode == UBI_READONLY ||\r\nvol->vol_type == UBI_STATIC_VOLUME) {\r\nerr = -EROFS;\r\nbreak;\r\n}\r\nif (lnum < 0 || lnum >= vol->reserved_pebs) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\ndbg_gen("erase LEB %d:%d", vol->vol_id, lnum);\r\nerr = ubi_eba_unmap_leb(ubi, vol, lnum);\r\nif (err)\r\nbreak;\r\nerr = ubi_wl_flush(ubi, UBI_ALL, UBI_ALL);\r\nbreak;\r\n}\r\ncase UBI_IOCEBMAP:\r\n{\r\nstruct ubi_map_req req;\r\nerr = copy_from_user(&req, argp, sizeof(struct ubi_map_req));\r\nif (err) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nerr = ubi_leb_map(desc, req.lnum);\r\nbreak;\r\n}\r\ncase UBI_IOCEBUNMAP:\r\n{\r\nint32_t lnum;\r\nerr = get_user(lnum, (__user int32_t *)argp);\r\nif (err) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nerr = ubi_leb_unmap(desc, lnum);\r\nbreak;\r\n}\r\ncase UBI_IOCEBISMAP:\r\n{\r\nint32_t lnum;\r\nerr = get_user(lnum, (__user int32_t *)argp);\r\nif (err) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nerr = ubi_is_mapped(desc, lnum);\r\nbreak;\r\n}\r\ncase UBI_IOCSETVOLPROP:\r\n{\r\nstruct ubi_set_vol_prop_req req;\r\nerr = copy_from_user(&req, argp,\r\nsizeof(struct ubi_set_vol_prop_req));\r\nif (err) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nswitch (req.property) {\r\ncase UBI_VOL_PROP_DIRECT_WRITE:\r\nmutex_lock(&ubi->device_mutex);\r\ndesc->vol->direct_writes = !!req.value;\r\nmutex_unlock(&ubi->device_mutex);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase UBI_IOCVOLCRBLK:\r\n{\r\nstruct ubi_volume_info vi;\r\nubi_get_volume_info(desc, &vi);\r\nerr = ubiblock_create(&vi);\r\nbreak;\r\n}\r\ncase UBI_IOCVOLRMBLK:\r\n{\r\nstruct ubi_volume_info vi;\r\nubi_get_volume_info(desc, &vi);\r\nerr = ubiblock_remove(&vi);\r\nbreak;\r\n}\r\ndefault:\r\nerr = -ENOTTY;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int verify_mkvol_req(const struct ubi_device *ubi,\r\nconst struct ubi_mkvol_req *req)\r\n{\r\nint n, err = -EINVAL;\r\nif (req->bytes < 0 || req->alignment < 0 || req->vol_type < 0 ||\r\nreq->name_len < 0)\r\ngoto bad;\r\nif ((req->vol_id < 0 || req->vol_id >= ubi->vtbl_slots) &&\r\nreq->vol_id != UBI_VOL_NUM_AUTO)\r\ngoto bad;\r\nif (req->alignment == 0)\r\ngoto bad;\r\nif (req->bytes == 0)\r\ngoto bad;\r\nif (req->vol_type != UBI_DYNAMIC_VOLUME &&\r\nreq->vol_type != UBI_STATIC_VOLUME)\r\ngoto bad;\r\nif (req->alignment > ubi->leb_size)\r\ngoto bad;\r\nn = req->alignment & (ubi->min_io_size - 1);\r\nif (req->alignment != 1 && n)\r\ngoto bad;\r\nif (!req->name[0] || !req->name_len)\r\ngoto bad;\r\nif (req->name_len > UBI_VOL_NAME_MAX) {\r\nerr = -ENAMETOOLONG;\r\ngoto bad;\r\n}\r\nn = strnlen(req->name, req->name_len + 1);\r\nif (n != req->name_len)\r\ngoto bad;\r\nreturn 0;\r\nbad:\r\nubi_err(ubi, "bad volume creation request");\r\nubi_dump_mkvol_req(req);\r\nreturn err;\r\n}\r\nstatic int verify_rsvol_req(const struct ubi_device *ubi,\r\nconst struct ubi_rsvol_req *req)\r\n{\r\nif (req->bytes <= 0)\r\nreturn -EINVAL;\r\nif (req->vol_id < 0 || req->vol_id >= ubi->vtbl_slots)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int rename_volumes(struct ubi_device *ubi,\r\nstruct ubi_rnvol_req *req)\r\n{\r\nint i, n, err;\r\nstruct list_head rename_list;\r\nstruct ubi_rename_entry *re, *re1;\r\nif (req->count < 0 || req->count > UBI_MAX_RNVOL)\r\nreturn -EINVAL;\r\nif (req->count == 0)\r\nreturn 0;\r\nfor (i = 0; i < req->count; i++) {\r\nif (req->ents[i].vol_id < 0 ||\r\nreq->ents[i].vol_id >= ubi->vtbl_slots)\r\nreturn -EINVAL;\r\nif (req->ents[i].name_len < 0)\r\nreturn -EINVAL;\r\nif (req->ents[i].name_len > UBI_VOL_NAME_MAX)\r\nreturn -ENAMETOOLONG;\r\nreq->ents[i].name[req->ents[i].name_len] = '\0';\r\nn = strlen(req->ents[i].name);\r\nif (n != req->ents[i].name_len)\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < req->count - 1; i++) {\r\nfor (n = i + 1; n < req->count; n++) {\r\nif (req->ents[i].vol_id == req->ents[n].vol_id) {\r\nubi_err(ubi, "duplicated volume id %d",\r\nreq->ents[i].vol_id);\r\nreturn -EINVAL;\r\n}\r\nif (!strcmp(req->ents[i].name, req->ents[n].name)) {\r\nubi_err(ubi, "duplicated volume name \"%s\"",\r\nreq->ents[i].name);\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nINIT_LIST_HEAD(&rename_list);\r\nfor (i = 0; i < req->count; i++) {\r\nint vol_id = req->ents[i].vol_id;\r\nint name_len = req->ents[i].name_len;\r\nconst char *name = req->ents[i].name;\r\nre = kzalloc(sizeof(struct ubi_rename_entry), GFP_KERNEL);\r\nif (!re) {\r\nerr = -ENOMEM;\r\ngoto out_free;\r\n}\r\nre->desc = ubi_open_volume(ubi->ubi_num, vol_id, UBI_METAONLY);\r\nif (IS_ERR(re->desc)) {\r\nerr = PTR_ERR(re->desc);\r\nubi_err(ubi, "cannot open volume %d, error %d",\r\nvol_id, err);\r\nkfree(re);\r\ngoto out_free;\r\n}\r\nif (re->desc->vol->name_len == name_len &&\r\n!memcmp(re->desc->vol->name, name, name_len)) {\r\nubi_close_volume(re->desc);\r\nkfree(re);\r\ncontinue;\r\n}\r\nre->new_name_len = name_len;\r\nmemcpy(re->new_name, name, name_len);\r\nlist_add_tail(&re->list, &rename_list);\r\ndbg_gen("will rename volume %d from \"%s\" to \"%s\"",\r\nvol_id, re->desc->vol->name, name);\r\n}\r\nif (list_empty(&rename_list))\r\nreturn 0;\r\nlist_for_each_entry(re, &rename_list, list) {\r\nstruct ubi_volume_desc *desc;\r\nint no_remove_needed = 0;\r\nlist_for_each_entry(re1, &rename_list, list) {\r\nif (re->new_name_len == re1->desc->vol->name_len &&\r\n!memcmp(re->new_name, re1->desc->vol->name,\r\nre1->desc->vol->name_len)) {\r\nno_remove_needed = 1;\r\nbreak;\r\n}\r\n}\r\nif (no_remove_needed)\r\ncontinue;\r\ndesc = ubi_open_volume_nm(ubi->ubi_num, re->new_name,\r\nUBI_EXCLUSIVE);\r\nif (IS_ERR(desc)) {\r\nerr = PTR_ERR(desc);\r\nif (err == -ENODEV)\r\ncontinue;\r\nubi_err(ubi, "cannot open volume \"%s\", error %d",\r\nre->new_name, err);\r\ngoto out_free;\r\n}\r\nre1 = kzalloc(sizeof(struct ubi_rename_entry), GFP_KERNEL);\r\nif (!re1) {\r\nerr = -ENOMEM;\r\nubi_close_volume(desc);\r\ngoto out_free;\r\n}\r\nre1->remove = 1;\r\nre1->desc = desc;\r\nlist_add(&re1->list, &rename_list);\r\ndbg_gen("will remove volume %d, name \"%s\"",\r\nre1->desc->vol->vol_id, re1->desc->vol->name);\r\n}\r\nmutex_lock(&ubi->device_mutex);\r\nerr = ubi_rename_volumes(ubi, &rename_list);\r\nmutex_unlock(&ubi->device_mutex);\r\nout_free:\r\nlist_for_each_entry_safe(re, re1, &rename_list, list) {\r\nubi_close_volume(re->desc);\r\nlist_del(&re->list);\r\nkfree(re);\r\n}\r\nreturn err;\r\n}\r\nstatic long ubi_cdev_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint err = 0;\r\nstruct ubi_device *ubi;\r\nstruct ubi_volume_desc *desc;\r\nvoid __user *argp = (void __user *)arg;\r\nif (!capable(CAP_SYS_RESOURCE))\r\nreturn -EPERM;\r\nubi = ubi_get_by_major(imajor(file->f_mapping->host));\r\nif (!ubi)\r\nreturn -ENODEV;\r\nswitch (cmd) {\r\ncase UBI_IOCMKVOL:\r\n{\r\nstruct ubi_mkvol_req req;\r\ndbg_gen("create volume");\r\nerr = copy_from_user(&req, argp, sizeof(struct ubi_mkvol_req));\r\nif (err) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nerr = verify_mkvol_req(ubi, &req);\r\nif (err)\r\nbreak;\r\nmutex_lock(&ubi->device_mutex);\r\nerr = ubi_create_volume(ubi, &req);\r\nmutex_unlock(&ubi->device_mutex);\r\nif (err)\r\nbreak;\r\nerr = put_user(req.vol_id, (__user int32_t *)argp);\r\nif (err)\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\ncase UBI_IOCRMVOL:\r\n{\r\nint vol_id;\r\ndbg_gen("remove volume");\r\nerr = get_user(vol_id, (__user int32_t *)argp);\r\nif (err) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\ndesc = ubi_open_volume(ubi->ubi_num, vol_id, UBI_EXCLUSIVE);\r\nif (IS_ERR(desc)) {\r\nerr = PTR_ERR(desc);\r\nbreak;\r\n}\r\nmutex_lock(&ubi->device_mutex);\r\nerr = ubi_remove_volume(desc, 0);\r\nmutex_unlock(&ubi->device_mutex);\r\nubi_close_volume(desc);\r\nbreak;\r\n}\r\ncase UBI_IOCRSVOL:\r\n{\r\nint pebs;\r\nstruct ubi_rsvol_req req;\r\ndbg_gen("re-size volume");\r\nerr = copy_from_user(&req, argp, sizeof(struct ubi_rsvol_req));\r\nif (err) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nerr = verify_rsvol_req(ubi, &req);\r\nif (err)\r\nbreak;\r\ndesc = ubi_open_volume(ubi->ubi_num, req.vol_id, UBI_EXCLUSIVE);\r\nif (IS_ERR(desc)) {\r\nerr = PTR_ERR(desc);\r\nbreak;\r\n}\r\npebs = div_u64(req.bytes + desc->vol->usable_leb_size - 1,\r\ndesc->vol->usable_leb_size);\r\nmutex_lock(&ubi->device_mutex);\r\nerr = ubi_resize_volume(desc, pebs);\r\nmutex_unlock(&ubi->device_mutex);\r\nubi_close_volume(desc);\r\nbreak;\r\n}\r\ncase UBI_IOCRNVOL:\r\n{\r\nstruct ubi_rnvol_req *req;\r\ndbg_gen("re-name volumes");\r\nreq = kmalloc(sizeof(struct ubi_rnvol_req), GFP_KERNEL);\r\nif (!req) {\r\nerr = -ENOMEM;\r\nbreak;\r\n};\r\nerr = copy_from_user(req, argp, sizeof(struct ubi_rnvol_req));\r\nif (err) {\r\nerr = -EFAULT;\r\nkfree(req);\r\nbreak;\r\n}\r\nerr = rename_volumes(ubi, req);\r\nkfree(req);\r\nbreak;\r\n}\r\ndefault:\r\nerr = -ENOTTY;\r\nbreak;\r\n}\r\nubi_put_device(ubi);\r\nreturn err;\r\n}\r\nstatic long ctrl_cdev_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint err = 0;\r\nvoid __user *argp = (void __user *)arg;\r\nif (!capable(CAP_SYS_RESOURCE))\r\nreturn -EPERM;\r\nswitch (cmd) {\r\ncase UBI_IOCATT:\r\n{\r\nstruct ubi_attach_req req;\r\nstruct mtd_info *mtd;\r\ndbg_gen("attach MTD device");\r\nerr = copy_from_user(&req, argp, sizeof(struct ubi_attach_req));\r\nif (err) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nif (req.mtd_num < 0 ||\r\n(req.ubi_num < 0 && req.ubi_num != UBI_DEV_NUM_AUTO)) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nmtd = get_mtd_device(NULL, req.mtd_num);\r\nif (IS_ERR(mtd)) {\r\nerr = PTR_ERR(mtd);\r\nbreak;\r\n}\r\nmutex_lock(&ubi_devices_mutex);\r\nerr = ubi_attach_mtd_dev(mtd, req.ubi_num, req.vid_hdr_offset,\r\nreq.max_beb_per1024);\r\nmutex_unlock(&ubi_devices_mutex);\r\nif (err < 0)\r\nput_mtd_device(mtd);\r\nelse\r\nerr = put_user(err, (__user int32_t *)argp);\r\nbreak;\r\n}\r\ncase UBI_IOCDET:\r\n{\r\nint ubi_num;\r\ndbg_gen("detach MTD device");\r\nerr = get_user(ubi_num, (__user int32_t *)argp);\r\nif (err) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nmutex_lock(&ubi_devices_mutex);\r\nerr = ubi_detach_mtd_dev(ubi_num, 0);\r\nmutex_unlock(&ubi_devices_mutex);\r\nbreak;\r\n}\r\ndefault:\r\nerr = -ENOTTY;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic long vol_cdev_compat_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nunsigned long translated_arg = (unsigned long)compat_ptr(arg);\r\nreturn vol_cdev_ioctl(file, cmd, translated_arg);\r\n}\r\nstatic long ubi_cdev_compat_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nunsigned long translated_arg = (unsigned long)compat_ptr(arg);\r\nreturn ubi_cdev_ioctl(file, cmd, translated_arg);\r\n}\r\nstatic long ctrl_cdev_compat_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nunsigned long translated_arg = (unsigned long)compat_ptr(arg);\r\nreturn ctrl_cdev_ioctl(file, cmd, translated_arg);\r\n}
