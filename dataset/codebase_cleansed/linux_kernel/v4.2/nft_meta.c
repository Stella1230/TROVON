void nft_meta_get_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_meta *priv = nft_expr_priv(expr);\r\nconst struct sk_buff *skb = pkt->skb;\r\nconst struct net_device *in = pkt->in, *out = pkt->out;\r\nu32 *dest = &regs->data[priv->dreg];\r\nswitch (priv->key) {\r\ncase NFT_META_LEN:\r\n*dest = skb->len;\r\nbreak;\r\ncase NFT_META_PROTOCOL:\r\n*dest = 0;\r\n*(__be16 *)dest = skb->protocol;\r\nbreak;\r\ncase NFT_META_NFPROTO:\r\n*dest = pkt->ops->pf;\r\nbreak;\r\ncase NFT_META_L4PROTO:\r\n*dest = pkt->tprot;\r\nbreak;\r\ncase NFT_META_PRIORITY:\r\n*dest = skb->priority;\r\nbreak;\r\ncase NFT_META_MARK:\r\n*dest = skb->mark;\r\nbreak;\r\ncase NFT_META_IIF:\r\nif (in == NULL)\r\ngoto err;\r\n*dest = in->ifindex;\r\nbreak;\r\ncase NFT_META_OIF:\r\nif (out == NULL)\r\ngoto err;\r\n*dest = out->ifindex;\r\nbreak;\r\ncase NFT_META_IIFNAME:\r\nif (in == NULL)\r\ngoto err;\r\nstrncpy((char *)dest, in->name, IFNAMSIZ);\r\nbreak;\r\ncase NFT_META_OIFNAME:\r\nif (out == NULL)\r\ngoto err;\r\nstrncpy((char *)dest, out->name, IFNAMSIZ);\r\nbreak;\r\ncase NFT_META_IIFTYPE:\r\nif (in == NULL)\r\ngoto err;\r\n*dest = 0;\r\n*(u16 *)dest = in->type;\r\nbreak;\r\ncase NFT_META_OIFTYPE:\r\nif (out == NULL)\r\ngoto err;\r\n*dest = 0;\r\n*(u16 *)dest = out->type;\r\nbreak;\r\ncase NFT_META_SKUID:\r\nif (skb->sk == NULL || !sk_fullsock(skb->sk))\r\ngoto err;\r\nread_lock_bh(&skb->sk->sk_callback_lock);\r\nif (skb->sk->sk_socket == NULL ||\r\nskb->sk->sk_socket->file == NULL) {\r\nread_unlock_bh(&skb->sk->sk_callback_lock);\r\ngoto err;\r\n}\r\n*dest = from_kuid_munged(&init_user_ns,\r\nskb->sk->sk_socket->file->f_cred->fsuid);\r\nread_unlock_bh(&skb->sk->sk_callback_lock);\r\nbreak;\r\ncase NFT_META_SKGID:\r\nif (skb->sk == NULL || !sk_fullsock(skb->sk))\r\ngoto err;\r\nread_lock_bh(&skb->sk->sk_callback_lock);\r\nif (skb->sk->sk_socket == NULL ||\r\nskb->sk->sk_socket->file == NULL) {\r\nread_unlock_bh(&skb->sk->sk_callback_lock);\r\ngoto err;\r\n}\r\n*dest = from_kgid_munged(&init_user_ns,\r\nskb->sk->sk_socket->file->f_cred->fsgid);\r\nread_unlock_bh(&skb->sk->sk_callback_lock);\r\nbreak;\r\n#ifdef CONFIG_IP_ROUTE_CLASSID\r\ncase NFT_META_RTCLASSID: {\r\nconst struct dst_entry *dst = skb_dst(skb);\r\nif (dst == NULL)\r\ngoto err;\r\n*dest = dst->tclassid;\r\nbreak;\r\n}\r\n#endif\r\n#ifdef CONFIG_NETWORK_SECMARK\r\ncase NFT_META_SECMARK:\r\n*dest = skb->secmark;\r\nbreak;\r\n#endif\r\ncase NFT_META_PKTTYPE:\r\nif (skb->pkt_type != PACKET_LOOPBACK) {\r\n*dest = skb->pkt_type;\r\nbreak;\r\n}\r\nswitch (pkt->ops->pf) {\r\ncase NFPROTO_IPV4:\r\nif (ipv4_is_multicast(ip_hdr(skb)->daddr))\r\n*dest = PACKET_MULTICAST;\r\nelse\r\n*dest = PACKET_BROADCAST;\r\nbreak;\r\ncase NFPROTO_IPV6:\r\nif (ipv6_hdr(skb)->daddr.s6_addr[0] == 0xFF)\r\n*dest = PACKET_MULTICAST;\r\nelse\r\n*dest = PACKET_BROADCAST;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\ngoto err;\r\n}\r\nbreak;\r\ncase NFT_META_CPU:\r\n*dest = raw_smp_processor_id();\r\nbreak;\r\ncase NFT_META_IIFGROUP:\r\nif (in == NULL)\r\ngoto err;\r\n*dest = in->group;\r\nbreak;\r\ncase NFT_META_OIFGROUP:\r\nif (out == NULL)\r\ngoto err;\r\n*dest = out->group;\r\nbreak;\r\ncase NFT_META_CGROUP:\r\nif (skb->sk == NULL || !sk_fullsock(skb->sk))\r\ngoto err;\r\n*dest = skb->sk->sk_classid;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\ngoto err;\r\n}\r\nreturn;\r\nerr:\r\nregs->verdict.code = NFT_BREAK;\r\n}\r\nvoid nft_meta_set_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_meta *meta = nft_expr_priv(expr);\r\nstruct sk_buff *skb = pkt->skb;\r\nu32 value = regs->data[meta->sreg];\r\nswitch (meta->key) {\r\ncase NFT_META_MARK:\r\nskb->mark = value;\r\nbreak;\r\ncase NFT_META_PRIORITY:\r\nskb->priority = value;\r\nbreak;\r\ncase NFT_META_NFTRACE:\r\nskb->nf_trace = 1;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\n}\r\n}\r\nint nft_meta_get_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_meta *priv = nft_expr_priv(expr);\r\nunsigned int len;\r\npriv->key = ntohl(nla_get_be32(tb[NFTA_META_KEY]));\r\nswitch (priv->key) {\r\ncase NFT_META_PROTOCOL:\r\ncase NFT_META_IIFTYPE:\r\ncase NFT_META_OIFTYPE:\r\nlen = sizeof(u16);\r\nbreak;\r\ncase NFT_META_NFPROTO:\r\ncase NFT_META_L4PROTO:\r\ncase NFT_META_LEN:\r\ncase NFT_META_PRIORITY:\r\ncase NFT_META_MARK:\r\ncase NFT_META_IIF:\r\ncase NFT_META_OIF:\r\ncase NFT_META_SKUID:\r\ncase NFT_META_SKGID:\r\n#ifdef CONFIG_IP_ROUTE_CLASSID\r\ncase NFT_META_RTCLASSID:\r\n#endif\r\n#ifdef CONFIG_NETWORK_SECMARK\r\ncase NFT_META_SECMARK:\r\n#endif\r\ncase NFT_META_PKTTYPE:\r\ncase NFT_META_CPU:\r\ncase NFT_META_IIFGROUP:\r\ncase NFT_META_OIFGROUP:\r\ncase NFT_META_CGROUP:\r\nlen = sizeof(u32);\r\nbreak;\r\ncase NFT_META_IIFNAME:\r\ncase NFT_META_OIFNAME:\r\nlen = IFNAMSIZ;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\npriv->dreg = nft_parse_register(tb[NFTA_META_DREG]);\r\nreturn nft_validate_register_store(ctx, priv->dreg, NULL,\r\nNFT_DATA_VALUE, len);\r\n}\r\nint nft_meta_set_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_meta *priv = nft_expr_priv(expr);\r\nunsigned int len;\r\nint err;\r\npriv->key = ntohl(nla_get_be32(tb[NFTA_META_KEY]));\r\nswitch (priv->key) {\r\ncase NFT_META_MARK:\r\ncase NFT_META_PRIORITY:\r\nlen = sizeof(u32);\r\nbreak;\r\ncase NFT_META_NFTRACE:\r\nlen = sizeof(u8);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\npriv->sreg = nft_parse_register(tb[NFTA_META_SREG]);\r\nerr = nft_validate_register_load(priv->sreg, len);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint nft_meta_get_dump(struct sk_buff *skb,\r\nconst struct nft_expr *expr)\r\n{\r\nconst struct nft_meta *priv = nft_expr_priv(expr);\r\nif (nla_put_be32(skb, NFTA_META_KEY, htonl(priv->key)))\r\ngoto nla_put_failure;\r\nif (nft_dump_register(skb, NFTA_META_DREG, priv->dreg))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nint nft_meta_set_dump(struct sk_buff *skb,\r\nconst struct nft_expr *expr)\r\n{\r\nconst struct nft_meta *priv = nft_expr_priv(expr);\r\nif (nla_put_be32(skb, NFTA_META_KEY, htonl(priv->key)))\r\ngoto nla_put_failure;\r\nif (nft_dump_register(skb, NFTA_META_SREG, priv->sreg))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic const struct nft_expr_ops *\r\nnft_meta_select_ops(const struct nft_ctx *ctx,\r\nconst struct nlattr * const tb[])\r\n{\r\nif (tb[NFTA_META_KEY] == NULL)\r\nreturn ERR_PTR(-EINVAL);\r\nif (tb[NFTA_META_DREG] && tb[NFTA_META_SREG])\r\nreturn ERR_PTR(-EINVAL);\r\nif (tb[NFTA_META_DREG])\r\nreturn &nft_meta_get_ops;\r\nif (tb[NFTA_META_SREG])\r\nreturn &nft_meta_set_ops;\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic int __init nft_meta_module_init(void)\r\n{\r\nreturn nft_register_expr(&nft_meta_type);\r\n}\r\nstatic void __exit nft_meta_module_exit(void)\r\n{\r\nnft_unregister_expr(&nft_meta_type);\r\n}
