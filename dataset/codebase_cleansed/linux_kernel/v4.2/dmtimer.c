static inline u32 omap_dm_timer_read_reg(struct omap_dm_timer *timer, u32 reg)\r\n{\r\nWARN_ON((reg & 0xff) < _OMAP_TIMER_WAKEUP_EN_OFFSET);\r\nreturn __omap_dm_timer_read(timer, reg, timer->posted);\r\n}\r\nstatic void omap_dm_timer_write_reg(struct omap_dm_timer *timer, u32 reg,\r\nu32 value)\r\n{\r\nWARN_ON((reg & 0xff) < _OMAP_TIMER_WAKEUP_EN_OFFSET);\r\n__omap_dm_timer_write(timer, reg, value, timer->posted);\r\n}\r\nstatic void omap_timer_restore_context(struct omap_dm_timer *timer)\r\n{\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_WAKEUP_EN_REG,\r\ntimer->context.twer);\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_COUNTER_REG,\r\ntimer->context.tcrr);\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_LOAD_REG,\r\ntimer->context.tldr);\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_MATCH_REG,\r\ntimer->context.tmar);\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_IF_CTRL_REG,\r\ntimer->context.tsicr);\r\nwritel_relaxed(timer->context.tier, timer->irq_ena);\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_CTRL_REG,\r\ntimer->context.tclr);\r\n}\r\nstatic int omap_dm_timer_reset(struct omap_dm_timer *timer)\r\n{\r\nu32 l, timeout = 100000;\r\nif (timer->revision != 1)\r\nreturn -EINVAL;\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_IF_CTRL_REG, 0x06);\r\ndo {\r\nl = __omap_dm_timer_read(timer,\r\nOMAP_TIMER_V1_SYS_STAT_OFFSET, 0);\r\n} while (!l && timeout--);\r\nif (!timeout) {\r\ndev_err(&timer->pdev->dev, "Timer failed to reset\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nl = __omap_dm_timer_read(timer, OMAP_TIMER_OCP_CFG_OFFSET, 0);\r\nl |= 0x2 << 0x3;\r\n__omap_dm_timer_write(timer, OMAP_TIMER_OCP_CFG_OFFSET, l, 0);\r\ntimer->posted = 0;\r\nreturn 0;\r\n}\r\nstatic int omap_dm_timer_prepare(struct omap_dm_timer *timer)\r\n{\r\nint rc;\r\nif (!(timer->capability & OMAP_TIMER_NEEDS_RESET)) {\r\ntimer->fclk = clk_get(&timer->pdev->dev, "fck");\r\nif (WARN_ON_ONCE(IS_ERR(timer->fclk))) {\r\ndev_err(&timer->pdev->dev, ": No fclk handle.\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nomap_dm_timer_enable(timer);\r\nif (timer->capability & OMAP_TIMER_NEEDS_RESET) {\r\nrc = omap_dm_timer_reset(timer);\r\nif (rc) {\r\nomap_dm_timer_disable(timer);\r\nreturn rc;\r\n}\r\n}\r\n__omap_dm_timer_enable_posted(timer);\r\nomap_dm_timer_disable(timer);\r\nreturn omap_dm_timer_set_source(timer, OMAP_TIMER_SRC_32_KHZ);\r\n}\r\nstatic inline u32 omap_dm_timer_reserved_systimer(int id)\r\n{\r\nreturn (omap_reserved_systimers & (1 << (id - 1))) ? 1 : 0;\r\n}\r\nint omap_dm_timer_reserve_systimer(int id)\r\n{\r\nif (omap_dm_timer_reserved_systimer(id))\r\nreturn -ENODEV;\r\nomap_reserved_systimers |= (1 << (id - 1));\r\nreturn 0;\r\n}\r\nstatic struct omap_dm_timer *_omap_dm_timer_request(int req_type, void *data)\r\n{\r\nstruct omap_dm_timer *timer = NULL, *t;\r\nstruct device_node *np = NULL;\r\nunsigned long flags;\r\nu32 cap = 0;\r\nint id = 0;\r\nswitch (req_type) {\r\ncase REQUEST_BY_ID:\r\nid = *(int *)data;\r\nbreak;\r\ncase REQUEST_BY_CAP:\r\ncap = *(u32 *)data;\r\nbreak;\r\ncase REQUEST_BY_NODE:\r\nnp = (struct device_node *)data;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nspin_lock_irqsave(&dm_timer_lock, flags);\r\nlist_for_each_entry(t, &omap_timer_list, node) {\r\nif (t->reserved)\r\ncontinue;\r\nswitch (req_type) {\r\ncase REQUEST_BY_ID:\r\nif (id == t->pdev->id) {\r\ntimer = t;\r\ntimer->reserved = 1;\r\ngoto found;\r\n}\r\nbreak;\r\ncase REQUEST_BY_CAP:\r\nif (cap == (t->capability & cap)) {\r\nif (timer)\r\ntimer->reserved = 0;\r\ntimer = t;\r\ntimer->reserved = 1;\r\nif (t->capability == cap)\r\ngoto found;\r\n}\r\nbreak;\r\ncase REQUEST_BY_NODE:\r\nif (np == t->pdev->dev.of_node) {\r\ntimer = t;\r\ntimer->reserved = 1;\r\ngoto found;\r\n}\r\nbreak;\r\ndefault:\r\ntimer = t;\r\ntimer->reserved = 1;\r\ngoto found;\r\n}\r\n}\r\nfound:\r\nspin_unlock_irqrestore(&dm_timer_lock, flags);\r\nif (timer && omap_dm_timer_prepare(timer)) {\r\ntimer->reserved = 0;\r\ntimer = NULL;\r\n}\r\nif (!timer)\r\npr_debug("%s: timer request failed!\n", __func__);\r\nreturn timer;\r\n}\r\nstruct omap_dm_timer *omap_dm_timer_request(void)\r\n{\r\nreturn _omap_dm_timer_request(REQUEST_ANY, NULL);\r\n}\r\nstruct omap_dm_timer *omap_dm_timer_request_specific(int id)\r\n{\r\nif (of_have_populated_dt()) {\r\npr_warn("%s: Please use omap_dm_timer_request_by_cap/node()\n",\r\n__func__);\r\nreturn NULL;\r\n}\r\nreturn _omap_dm_timer_request(REQUEST_BY_ID, &id);\r\n}\r\nstruct omap_dm_timer *omap_dm_timer_request_by_cap(u32 cap)\r\n{\r\nreturn _omap_dm_timer_request(REQUEST_BY_CAP, &cap);\r\n}\r\nstruct omap_dm_timer *omap_dm_timer_request_by_node(struct device_node *np)\r\n{\r\nif (!np)\r\nreturn NULL;\r\nreturn _omap_dm_timer_request(REQUEST_BY_NODE, np);\r\n}\r\nint omap_dm_timer_free(struct omap_dm_timer *timer)\r\n{\r\nif (unlikely(!timer))\r\nreturn -EINVAL;\r\nclk_put(timer->fclk);\r\nWARN_ON(!timer->reserved);\r\ntimer->reserved = 0;\r\nreturn 0;\r\n}\r\nvoid omap_dm_timer_enable(struct omap_dm_timer *timer)\r\n{\r\nint c;\r\npm_runtime_get_sync(&timer->pdev->dev);\r\nif (!(timer->capability & OMAP_TIMER_ALWON)) {\r\nif (timer->get_context_loss_count) {\r\nc = timer->get_context_loss_count(&timer->pdev->dev);\r\nif (c != timer->ctx_loss_count) {\r\nomap_timer_restore_context(timer);\r\ntimer->ctx_loss_count = c;\r\n}\r\n} else {\r\nomap_timer_restore_context(timer);\r\n}\r\n}\r\n}\r\nvoid omap_dm_timer_disable(struct omap_dm_timer *timer)\r\n{\r\npm_runtime_put_sync(&timer->pdev->dev);\r\n}\r\nint omap_dm_timer_get_irq(struct omap_dm_timer *timer)\r\n{\r\nif (timer)\r\nreturn timer->irq;\r\nreturn -EINVAL;\r\n}\r\n__u32 omap_dm_timer_modify_idlect_mask(__u32 inputmask)\r\n{\r\nint i = 0;\r\nstruct omap_dm_timer *timer = NULL;\r\nunsigned long flags;\r\nif (!(inputmask & (1 << 1)))\r\nreturn inputmask;\r\nspin_lock_irqsave(&dm_timer_lock, flags);\r\nlist_for_each_entry(timer, &omap_timer_list, node) {\r\nu32 l;\r\nl = omap_dm_timer_read_reg(timer, OMAP_TIMER_CTRL_REG);\r\nif (l & OMAP_TIMER_CTRL_ST) {\r\nif (((omap_readl(MOD_CONF_CTRL_1) >> (i * 2)) & 0x03) == 0)\r\ninputmask &= ~(1 << 1);\r\nelse\r\ninputmask &= ~(1 << 2);\r\n}\r\ni++;\r\n}\r\nspin_unlock_irqrestore(&dm_timer_lock, flags);\r\nreturn inputmask;\r\n}\r\nstruct clk *omap_dm_timer_get_fclk(struct omap_dm_timer *timer)\r\n{\r\nif (timer && !IS_ERR(timer->fclk))\r\nreturn timer->fclk;\r\nreturn NULL;\r\n}\r\n__u32 omap_dm_timer_modify_idlect_mask(__u32 inputmask)\r\n{\r\nBUG();\r\nreturn 0;\r\n}\r\nint omap_dm_timer_trigger(struct omap_dm_timer *timer)\r\n{\r\nif (unlikely(!timer || pm_runtime_suspended(&timer->pdev->dev))) {\r\npr_err("%s: timer not available or enabled.\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_TRIGGER_REG, 0);\r\nreturn 0;\r\n}\r\nint omap_dm_timer_start(struct omap_dm_timer *timer)\r\n{\r\nu32 l;\r\nif (unlikely(!timer))\r\nreturn -EINVAL;\r\nomap_dm_timer_enable(timer);\r\nl = omap_dm_timer_read_reg(timer, OMAP_TIMER_CTRL_REG);\r\nif (!(l & OMAP_TIMER_CTRL_ST)) {\r\nl |= OMAP_TIMER_CTRL_ST;\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_CTRL_REG, l);\r\n}\r\ntimer->context.tclr = l;\r\nreturn 0;\r\n}\r\nint omap_dm_timer_stop(struct omap_dm_timer *timer)\r\n{\r\nunsigned long rate = 0;\r\nif (unlikely(!timer))\r\nreturn -EINVAL;\r\nif (!(timer->capability & OMAP_TIMER_NEEDS_RESET))\r\nrate = clk_get_rate(timer->fclk);\r\n__omap_dm_timer_stop(timer, timer->posted, rate);\r\ntimer->context.tclr =\r\nomap_dm_timer_read_reg(timer, OMAP_TIMER_CTRL_REG);\r\nomap_dm_timer_disable(timer);\r\nreturn 0;\r\n}\r\nint omap_dm_timer_set_source(struct omap_dm_timer *timer, int source)\r\n{\r\nint ret;\r\nchar *parent_name = NULL;\r\nstruct clk *parent;\r\nstruct dmtimer_platform_data *pdata;\r\nif (unlikely(!timer))\r\nreturn -EINVAL;\r\npdata = timer->pdev->dev.platform_data;\r\nif (source < 0 || source >= 3)\r\nreturn -EINVAL;\r\nif (pdata && pdata->set_timer_src)\r\nreturn pdata->set_timer_src(timer->pdev, source);\r\nif (IS_ERR(timer->fclk))\r\nreturn -EINVAL;\r\nswitch (source) {\r\ncase OMAP_TIMER_SRC_SYS_CLK:\r\nparent_name = "timer_sys_ck";\r\nbreak;\r\ncase OMAP_TIMER_SRC_32_KHZ:\r\nparent_name = "timer_32k_ck";\r\nbreak;\r\ncase OMAP_TIMER_SRC_EXT_CLK:\r\nparent_name = "timer_ext_ck";\r\nbreak;\r\n}\r\nparent = clk_get(&timer->pdev->dev, parent_name);\r\nif (IS_ERR(parent)) {\r\npr_err("%s: %s not found\n", __func__, parent_name);\r\nreturn -EINVAL;\r\n}\r\nret = clk_set_parent(timer->fclk, parent);\r\nif (ret < 0)\r\npr_err("%s: failed to set %s as parent\n", __func__,\r\nparent_name);\r\nclk_put(parent);\r\nreturn ret;\r\n}\r\nint omap_dm_timer_set_load(struct omap_dm_timer *timer, int autoreload,\r\nunsigned int load)\r\n{\r\nu32 l;\r\nif (unlikely(!timer))\r\nreturn -EINVAL;\r\nomap_dm_timer_enable(timer);\r\nl = omap_dm_timer_read_reg(timer, OMAP_TIMER_CTRL_REG);\r\nif (autoreload)\r\nl |= OMAP_TIMER_CTRL_AR;\r\nelse\r\nl &= ~OMAP_TIMER_CTRL_AR;\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_CTRL_REG, l);\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_LOAD_REG, load);\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_TRIGGER_REG, 0);\r\ntimer->context.tclr = l;\r\ntimer->context.tldr = load;\r\nomap_dm_timer_disable(timer);\r\nreturn 0;\r\n}\r\nint omap_dm_timer_set_load_start(struct omap_dm_timer *timer, int autoreload,\r\nunsigned int load)\r\n{\r\nu32 l;\r\nif (unlikely(!timer))\r\nreturn -EINVAL;\r\nomap_dm_timer_enable(timer);\r\nl = omap_dm_timer_read_reg(timer, OMAP_TIMER_CTRL_REG);\r\nif (autoreload) {\r\nl |= OMAP_TIMER_CTRL_AR;\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_LOAD_REG, load);\r\n} else {\r\nl &= ~OMAP_TIMER_CTRL_AR;\r\n}\r\nl |= OMAP_TIMER_CTRL_ST;\r\n__omap_dm_timer_load_start(timer, l, load, timer->posted);\r\ntimer->context.tclr = l;\r\ntimer->context.tldr = load;\r\ntimer->context.tcrr = load;\r\nreturn 0;\r\n}\r\nint omap_dm_timer_set_match(struct omap_dm_timer *timer, int enable,\r\nunsigned int match)\r\n{\r\nu32 l;\r\nif (unlikely(!timer))\r\nreturn -EINVAL;\r\nomap_dm_timer_enable(timer);\r\nl = omap_dm_timer_read_reg(timer, OMAP_TIMER_CTRL_REG);\r\nif (enable)\r\nl |= OMAP_TIMER_CTRL_CE;\r\nelse\r\nl &= ~OMAP_TIMER_CTRL_CE;\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_MATCH_REG, match);\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_CTRL_REG, l);\r\ntimer->context.tclr = l;\r\ntimer->context.tmar = match;\r\nomap_dm_timer_disable(timer);\r\nreturn 0;\r\n}\r\nint omap_dm_timer_set_pwm(struct omap_dm_timer *timer, int def_on,\r\nint toggle, int trigger)\r\n{\r\nu32 l;\r\nif (unlikely(!timer))\r\nreturn -EINVAL;\r\nomap_dm_timer_enable(timer);\r\nl = omap_dm_timer_read_reg(timer, OMAP_TIMER_CTRL_REG);\r\nl &= ~(OMAP_TIMER_CTRL_GPOCFG | OMAP_TIMER_CTRL_SCPWM |\r\nOMAP_TIMER_CTRL_PT | (0x03 << 10));\r\nif (def_on)\r\nl |= OMAP_TIMER_CTRL_SCPWM;\r\nif (toggle)\r\nl |= OMAP_TIMER_CTRL_PT;\r\nl |= trigger << 10;\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_CTRL_REG, l);\r\ntimer->context.tclr = l;\r\nomap_dm_timer_disable(timer);\r\nreturn 0;\r\n}\r\nint omap_dm_timer_set_prescaler(struct omap_dm_timer *timer, int prescaler)\r\n{\r\nu32 l;\r\nif (unlikely(!timer))\r\nreturn -EINVAL;\r\nomap_dm_timer_enable(timer);\r\nl = omap_dm_timer_read_reg(timer, OMAP_TIMER_CTRL_REG);\r\nl &= ~(OMAP_TIMER_CTRL_PRE | (0x07 << 2));\r\nif (prescaler >= 0x00 && prescaler <= 0x07) {\r\nl |= OMAP_TIMER_CTRL_PRE;\r\nl |= prescaler << 2;\r\n}\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_CTRL_REG, l);\r\ntimer->context.tclr = l;\r\nomap_dm_timer_disable(timer);\r\nreturn 0;\r\n}\r\nint omap_dm_timer_set_int_enable(struct omap_dm_timer *timer,\r\nunsigned int value)\r\n{\r\nif (unlikely(!timer))\r\nreturn -EINVAL;\r\nomap_dm_timer_enable(timer);\r\n__omap_dm_timer_int_enable(timer, value);\r\ntimer->context.tier = value;\r\ntimer->context.twer = value;\r\nomap_dm_timer_disable(timer);\r\nreturn 0;\r\n}\r\nint omap_dm_timer_set_int_disable(struct omap_dm_timer *timer, u32 mask)\r\n{\r\nu32 l = mask;\r\nif (unlikely(!timer))\r\nreturn -EINVAL;\r\nomap_dm_timer_enable(timer);\r\nif (timer->revision == 1)\r\nl = readl_relaxed(timer->irq_ena) & ~mask;\r\nwritel_relaxed(l, timer->irq_dis);\r\nl = omap_dm_timer_read_reg(timer, OMAP_TIMER_WAKEUP_EN_REG) & ~mask;\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_WAKEUP_EN_REG, l);\r\ntimer->context.tier &= ~mask;\r\ntimer->context.twer &= ~mask;\r\nomap_dm_timer_disable(timer);\r\nreturn 0;\r\n}\r\nunsigned int omap_dm_timer_read_status(struct omap_dm_timer *timer)\r\n{\r\nunsigned int l;\r\nif (unlikely(!timer || pm_runtime_suspended(&timer->pdev->dev))) {\r\npr_err("%s: timer not available or enabled.\n", __func__);\r\nreturn 0;\r\n}\r\nl = readl_relaxed(timer->irq_stat);\r\nreturn l;\r\n}\r\nint omap_dm_timer_write_status(struct omap_dm_timer *timer, unsigned int value)\r\n{\r\nif (unlikely(!timer || pm_runtime_suspended(&timer->pdev->dev)))\r\nreturn -EINVAL;\r\n__omap_dm_timer_write_status(timer, value);\r\nreturn 0;\r\n}\r\nunsigned int omap_dm_timer_read_counter(struct omap_dm_timer *timer)\r\n{\r\nif (unlikely(!timer || pm_runtime_suspended(&timer->pdev->dev))) {\r\npr_err("%s: timer not iavailable or enabled.\n", __func__);\r\nreturn 0;\r\n}\r\nreturn __omap_dm_timer_read_counter(timer, timer->posted);\r\n}\r\nint omap_dm_timer_write_counter(struct omap_dm_timer *timer, unsigned int value)\r\n{\r\nif (unlikely(!timer || pm_runtime_suspended(&timer->pdev->dev))) {\r\npr_err("%s: timer not available or enabled.\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nomap_dm_timer_write_reg(timer, OMAP_TIMER_COUNTER_REG, value);\r\ntimer->context.tcrr = value;\r\nreturn 0;\r\n}\r\nint omap_dm_timers_active(void)\r\n{\r\nstruct omap_dm_timer *timer;\r\nlist_for_each_entry(timer, &omap_timer_list, node) {\r\nif (!timer->reserved)\r\ncontinue;\r\nif (omap_dm_timer_read_reg(timer, OMAP_TIMER_CTRL_REG) &\r\nOMAP_TIMER_CTRL_ST) {\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_dm_timer_probe(struct platform_device *pdev)\r\n{\r\nunsigned long flags;\r\nstruct omap_dm_timer *timer;\r\nstruct resource *mem, *irq;\r\nstruct device *dev = &pdev->dev;\r\nconst struct of_device_id *match;\r\nconst struct dmtimer_platform_data *pdata;\r\nint ret;\r\nmatch = of_match_device(of_match_ptr(omap_timer_match), dev);\r\npdata = match ? match->data : dev->platform_data;\r\nif (!pdata && !dev->of_node) {\r\ndev_err(dev, "%s: no platform data.\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (unlikely(!irq)) {\r\ndev_err(dev, "%s: no IRQ resource.\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (unlikely(!mem)) {\r\ndev_err(dev, "%s: no memory resource.\n", __func__);\r\nreturn -ENODEV;\r\n}\r\ntimer = devm_kzalloc(dev, sizeof(struct omap_dm_timer), GFP_KERNEL);\r\nif (!timer) {\r\ndev_err(dev, "%s: memory alloc failed!\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\ntimer->fclk = ERR_PTR(-ENODEV);\r\ntimer->io_base = devm_ioremap_resource(dev, mem);\r\nif (IS_ERR(timer->io_base))\r\nreturn PTR_ERR(timer->io_base);\r\nif (dev->of_node) {\r\nif (of_find_property(dev->of_node, "ti,timer-alwon", NULL))\r\ntimer->capability |= OMAP_TIMER_ALWON;\r\nif (of_find_property(dev->of_node, "ti,timer-dsp", NULL))\r\ntimer->capability |= OMAP_TIMER_HAS_DSP_IRQ;\r\nif (of_find_property(dev->of_node, "ti,timer-pwm", NULL))\r\ntimer->capability |= OMAP_TIMER_HAS_PWM;\r\nif (of_find_property(dev->of_node, "ti,timer-secure", NULL))\r\ntimer->capability |= OMAP_TIMER_SECURE;\r\n} else {\r\ntimer->id = pdev->id;\r\ntimer->capability = pdata->timer_capability;\r\ntimer->reserved = omap_dm_timer_reserved_systimer(timer->id);\r\ntimer->get_context_loss_count = pdata->get_context_loss_count;\r\n}\r\nif (pdata)\r\ntimer->errata = pdata->timer_errata;\r\ntimer->irq = irq->start;\r\ntimer->pdev = pdev;\r\nif (!(timer->capability & OMAP_TIMER_NEEDS_RESET)) {\r\npm_runtime_enable(dev);\r\npm_runtime_irq_safe(dev);\r\n}\r\nif (!timer->reserved) {\r\nret = pm_runtime_get_sync(dev);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: pm_runtime_get_sync failed!\n",\r\n__func__);\r\ngoto err_get_sync;\r\n}\r\n__omap_dm_timer_init_regs(timer);\r\npm_runtime_put(dev);\r\n}\r\nspin_lock_irqsave(&dm_timer_lock, flags);\r\nlist_add_tail(&timer->node, &omap_timer_list);\r\nspin_unlock_irqrestore(&dm_timer_lock, flags);\r\ndev_dbg(dev, "Device Probed.\n");\r\nreturn 0;\r\nerr_get_sync:\r\npm_runtime_put_noidle(dev);\r\npm_runtime_disable(dev);\r\nreturn ret;\r\n}\r\nstatic int omap_dm_timer_remove(struct platform_device *pdev)\r\n{\r\nstruct omap_dm_timer *timer;\r\nunsigned long flags;\r\nint ret = -EINVAL;\r\nspin_lock_irqsave(&dm_timer_lock, flags);\r\nlist_for_each_entry(timer, &omap_timer_list, node)\r\nif (!strcmp(dev_name(&timer->pdev->dev),\r\ndev_name(&pdev->dev))) {\r\nlist_del(&timer->node);\r\nret = 0;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&dm_timer_lock, flags);\r\npm_runtime_disable(&pdev->dev);\r\nreturn ret;\r\n}
