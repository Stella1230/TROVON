void pci_update_resource(struct pci_dev *dev, int resno)\r\n{\r\nstruct pci_bus_region region;\r\nbool disable;\r\nu16 cmd;\r\nu32 new, check, mask;\r\nint reg;\r\nenum pci_bar_type type;\r\nstruct resource *res = dev->resource + resno;\r\nif (!res->flags)\r\nreturn;\r\nif (res->flags & IORESOURCE_UNSET)\r\nreturn;\r\nif (res->flags & IORESOURCE_PCI_FIXED)\r\nreturn;\r\npcibios_resource_to_bus(dev->bus, &region, res);\r\nnew = region.start | (res->flags & PCI_REGION_FLAG_MASK);\r\nif (res->flags & IORESOURCE_IO)\r\nmask = (u32)PCI_BASE_ADDRESS_IO_MASK;\r\nelse\r\nmask = (u32)PCI_BASE_ADDRESS_MEM_MASK;\r\nreg = pci_resource_bar(dev, resno, &type);\r\nif (!reg)\r\nreturn;\r\nif (type != pci_bar_unknown) {\r\nif (!(res->flags & IORESOURCE_ROM_ENABLE))\r\nreturn;\r\nnew |= PCI_ROM_ADDRESS_ENABLE;\r\n}\r\ndisable = (res->flags & IORESOURCE_MEM_64) && !dev->mmio_always_on;\r\nif (disable) {\r\npci_read_config_word(dev, PCI_COMMAND, &cmd);\r\npci_write_config_word(dev, PCI_COMMAND,\r\ncmd & ~PCI_COMMAND_MEMORY);\r\n}\r\npci_write_config_dword(dev, reg, new);\r\npci_read_config_dword(dev, reg, &check);\r\nif ((new ^ check) & mask) {\r\ndev_err(&dev->dev, "BAR %d: error updating (%#08x != %#08x)\n",\r\nresno, new, check);\r\n}\r\nif (res->flags & IORESOURCE_MEM_64) {\r\nnew = region.start >> 16 >> 16;\r\npci_write_config_dword(dev, reg + 4, new);\r\npci_read_config_dword(dev, reg + 4, &check);\r\nif (check != new) {\r\ndev_err(&dev->dev, "BAR %d: error updating (high %#08x != %#08x)\n",\r\nresno, new, check);\r\n}\r\n}\r\nif (disable)\r\npci_write_config_word(dev, PCI_COMMAND, cmd);\r\n}\r\nint pci_claim_resource(struct pci_dev *dev, int resource)\r\n{\r\nstruct resource *res = &dev->resource[resource];\r\nstruct resource *root, *conflict;\r\nif (res->flags & IORESOURCE_UNSET) {\r\ndev_info(&dev->dev, "can't claim BAR %d %pR: no address assigned\n",\r\nresource, res);\r\nreturn -EINVAL;\r\n}\r\nroot = pci_find_parent_resource(dev, res);\r\nif (!root) {\r\ndev_info(&dev->dev, "can't claim BAR %d %pR: no compatible bridge window\n",\r\nresource, res);\r\nres->flags |= IORESOURCE_UNSET;\r\nreturn -EINVAL;\r\n}\r\nconflict = request_resource_conflict(root, res);\r\nif (conflict) {\r\ndev_info(&dev->dev, "can't claim BAR %d %pR: address conflict with %s %pR\n",\r\nresource, res, conflict->name, conflict);\r\nres->flags |= IORESOURCE_UNSET;\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nvoid pci_disable_bridge_window(struct pci_dev *dev)\r\n{\r\ndev_info(&dev->dev, "disabling bridge mem windows\n");\r\npci_write_config_dword(dev, PCI_MEMORY_BASE, 0x0000fff0);\r\npci_write_config_dword(dev, PCI_PREF_LIMIT_UPPER32, 0);\r\npci_write_config_dword(dev, PCI_PREF_MEMORY_BASE, 0x0000fff0);\r\npci_write_config_dword(dev, PCI_PREF_BASE_UPPER32, 0xffffffff);\r\n}\r\nresource_size_t __weak pcibios_retrieve_fw_addr(struct pci_dev *dev, int idx)\r\n{\r\nreturn 0;\r\n}\r\nstatic int pci_revert_fw_address(struct resource *res, struct pci_dev *dev,\r\nint resno, resource_size_t size)\r\n{\r\nstruct resource *root, *conflict;\r\nresource_size_t fw_addr, start, end;\r\nfw_addr = pcibios_retrieve_fw_addr(dev, resno);\r\nif (!fw_addr)\r\nreturn -ENOMEM;\r\nstart = res->start;\r\nend = res->end;\r\nres->start = fw_addr;\r\nres->end = res->start + size - 1;\r\nroot = pci_find_parent_resource(dev, res);\r\nif (!root) {\r\nif (res->flags & IORESOURCE_IO)\r\nroot = &ioport_resource;\r\nelse\r\nroot = &iomem_resource;\r\n}\r\ndev_info(&dev->dev, "BAR %d: trying firmware assignment %pR\n",\r\nresno, res);\r\nconflict = request_resource_conflict(root, res);\r\nif (conflict) {\r\ndev_info(&dev->dev, "BAR %d: %pR conflicts with %s %pR\n",\r\nresno, res, conflict->name, conflict);\r\nres->start = start;\r\nres->end = end;\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __pci_assign_resource(struct pci_bus *bus, struct pci_dev *dev,\r\nint resno, resource_size_t size, resource_size_t align)\r\n{\r\nstruct resource *res = dev->resource + resno;\r\nresource_size_t min;\r\nint ret;\r\nmin = (res->flags & IORESOURCE_IO) ? PCIBIOS_MIN_IO : PCIBIOS_MIN_MEM;\r\nret = pci_bus_alloc_resource(bus, res, size, align, min,\r\nIORESOURCE_PREFETCH | IORESOURCE_MEM_64,\r\npcibios_align_resource, dev);\r\nif (ret == 0)\r\nreturn 0;\r\nif ((res->flags & (IORESOURCE_PREFETCH | IORESOURCE_MEM_64)) ==\r\n(IORESOURCE_PREFETCH | IORESOURCE_MEM_64)) {\r\nret = pci_bus_alloc_resource(bus, res, size, align, min,\r\nIORESOURCE_PREFETCH,\r\npcibios_align_resource, dev);\r\nif (ret == 0)\r\nreturn 0;\r\n}\r\nif (res->flags & (IORESOURCE_PREFETCH | IORESOURCE_MEM_64))\r\nret = pci_bus_alloc_resource(bus, res, size, align, min, 0,\r\npcibios_align_resource, dev);\r\nreturn ret;\r\n}\r\nstatic int _pci_assign_resource(struct pci_dev *dev, int resno,\r\nresource_size_t size, resource_size_t min_align)\r\n{\r\nstruct pci_bus *bus;\r\nint ret;\r\nbus = dev->bus;\r\nwhile ((ret = __pci_assign_resource(bus, dev, resno, size, min_align))) {\r\nif (!bus->parent || !bus->self->transparent)\r\nbreak;\r\nbus = bus->parent;\r\n}\r\nreturn ret;\r\n}\r\nint pci_assign_resource(struct pci_dev *dev, int resno)\r\n{\r\nstruct resource *res = dev->resource + resno;\r\nresource_size_t align, size;\r\nint ret;\r\nres->flags |= IORESOURCE_UNSET;\r\nalign = pci_resource_alignment(dev, res);\r\nif (!align) {\r\ndev_info(&dev->dev, "BAR %d: can't assign %pR (bogus alignment)\n",\r\nresno, res);\r\nreturn -EINVAL;\r\n}\r\nsize = resource_size(res);\r\nret = _pci_assign_resource(dev, resno, size, align);\r\nif (ret < 0) {\r\ndev_info(&dev->dev, "BAR %d: no space for %pR\n", resno, res);\r\nret = pci_revert_fw_address(res, dev, resno, size);\r\n}\r\nif (ret < 0) {\r\ndev_info(&dev->dev, "BAR %d: failed to assign %pR\n", resno,\r\nres);\r\nreturn ret;\r\n}\r\nres->flags &= ~IORESOURCE_UNSET;\r\nres->flags &= ~IORESOURCE_STARTALIGN;\r\ndev_info(&dev->dev, "BAR %d: assigned %pR\n", resno, res);\r\nif (resno < PCI_BRIDGE_RESOURCES)\r\npci_update_resource(dev, resno);\r\nreturn 0;\r\n}\r\nint pci_reassign_resource(struct pci_dev *dev, int resno, resource_size_t addsize,\r\nresource_size_t min_align)\r\n{\r\nstruct resource *res = dev->resource + resno;\r\nunsigned long flags;\r\nresource_size_t new_size;\r\nint ret;\r\nflags = res->flags;\r\nres->flags |= IORESOURCE_UNSET;\r\nif (!res->parent) {\r\ndev_info(&dev->dev, "BAR %d: can't reassign an unassigned resource %pR\n",\r\nresno, res);\r\nreturn -EINVAL;\r\n}\r\nnew_size = resource_size(res) + addsize;\r\nret = _pci_assign_resource(dev, resno, new_size, min_align);\r\nif (ret) {\r\nres->flags = flags;\r\ndev_info(&dev->dev, "BAR %d: %pR (failed to expand by %#llx)\n",\r\nresno, res, (unsigned long long) addsize);\r\nreturn ret;\r\n}\r\nres->flags &= ~IORESOURCE_UNSET;\r\nres->flags &= ~IORESOURCE_STARTALIGN;\r\ndev_info(&dev->dev, "BAR %d: reassigned %pR (expanded by %#llx)\n",\r\nresno, res, (unsigned long long) addsize);\r\nif (resno < PCI_BRIDGE_RESOURCES)\r\npci_update_resource(dev, resno);\r\nreturn 0;\r\n}\r\nint pci_enable_resources(struct pci_dev *dev, int mask)\r\n{\r\nu16 cmd, old_cmd;\r\nint i;\r\nstruct resource *r;\r\npci_read_config_word(dev, PCI_COMMAND, &cmd);\r\nold_cmd = cmd;\r\nfor (i = 0; i < PCI_NUM_RESOURCES; i++) {\r\nif (!(mask & (1 << i)))\r\ncontinue;\r\nr = &dev->resource[i];\r\nif (!(r->flags & (IORESOURCE_IO | IORESOURCE_MEM)))\r\ncontinue;\r\nif ((i == PCI_ROM_RESOURCE) &&\r\n(!(r->flags & IORESOURCE_ROM_ENABLE)))\r\ncontinue;\r\nif (r->flags & IORESOURCE_UNSET) {\r\ndev_err(&dev->dev, "can't enable device: BAR %d %pR not assigned\n",\r\ni, r);\r\nreturn -EINVAL;\r\n}\r\nif (!r->parent) {\r\ndev_err(&dev->dev, "can't enable device: BAR %d %pR not claimed\n",\r\ni, r);\r\nreturn -EINVAL;\r\n}\r\nif (r->flags & IORESOURCE_IO)\r\ncmd |= PCI_COMMAND_IO;\r\nif (r->flags & IORESOURCE_MEM)\r\ncmd |= PCI_COMMAND_MEMORY;\r\n}\r\nif (cmd != old_cmd) {\r\ndev_info(&dev->dev, "enabling device (%04x -> %04x)\n",\r\nold_cmd, cmd);\r\npci_write_config_word(dev, PCI_COMMAND, cmd);\r\n}\r\nreturn 0;\r\n}
