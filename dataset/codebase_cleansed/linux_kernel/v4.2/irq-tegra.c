static inline void tegra_ictlr_write_mask(struct irq_data *d, unsigned long reg)\r\n{\r\nvoid __iomem *base = d->chip_data;\r\nu32 mask;\r\nmask = BIT(d->hwirq % 32);\r\nwritel_relaxed(mask, base + reg);\r\n}\r\nstatic void tegra_mask(struct irq_data *d)\r\n{\r\ntegra_ictlr_write_mask(d, ICTLR_CPU_IER_CLR);\r\nirq_chip_mask_parent(d);\r\n}\r\nstatic void tegra_unmask(struct irq_data *d)\r\n{\r\ntegra_ictlr_write_mask(d, ICTLR_CPU_IER_SET);\r\nirq_chip_unmask_parent(d);\r\n}\r\nstatic void tegra_eoi(struct irq_data *d)\r\n{\r\ntegra_ictlr_write_mask(d, ICTLR_CPU_IEP_FIR_CLR);\r\nirq_chip_eoi_parent(d);\r\n}\r\nstatic int tegra_retrigger(struct irq_data *d)\r\n{\r\ntegra_ictlr_write_mask(d, ICTLR_CPU_IEP_FIR_SET);\r\nreturn irq_chip_retrigger_hierarchy(d);\r\n}\r\nstatic int tegra_set_wake(struct irq_data *d, unsigned int enable)\r\n{\r\nu32 irq = d->hwirq;\r\nu32 index, mask;\r\nindex = (irq / 32);\r\nmask = BIT(irq % 32);\r\nif (enable)\r\nlic->ictlr_wake_mask[index] |= mask;\r\nelse\r\nlic->ictlr_wake_mask[index] &= ~mask;\r\nreturn 0;\r\n}\r\nstatic int tegra_ictlr_suspend(void)\r\n{\r\nunsigned long flags;\r\nunsigned int i;\r\nlocal_irq_save(flags);\r\nfor (i = 0; i < num_ictlrs; i++) {\r\nvoid __iomem *ictlr = lic->base[i];\r\nlic->cpu_ier[i] = readl_relaxed(ictlr + ICTLR_CPU_IER);\r\nlic->cpu_iep[i] = readl_relaxed(ictlr + ICTLR_CPU_IEP_CLASS);\r\nlic->cop_ier[i] = readl_relaxed(ictlr + ICTLR_COP_IER);\r\nlic->cop_iep[i] = readl_relaxed(ictlr + ICTLR_COP_IEP_CLASS);\r\nwritel_relaxed(~0ul, ictlr + ICTLR_COP_IER_CLR);\r\nwritel_relaxed(~0ul, ictlr + ICTLR_CPU_IER_CLR);\r\nwritel_relaxed(lic->ictlr_wake_mask[i], ictlr + ICTLR_CPU_IER_SET);\r\n}\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic void tegra_ictlr_resume(void)\r\n{\r\nunsigned long flags;\r\nunsigned int i;\r\nlocal_irq_save(flags);\r\nfor (i = 0; i < num_ictlrs; i++) {\r\nvoid __iomem *ictlr = lic->base[i];\r\nwritel_relaxed(lic->cpu_iep[i],\r\nictlr + ICTLR_CPU_IEP_CLASS);\r\nwritel_relaxed(~0ul, ictlr + ICTLR_CPU_IER_CLR);\r\nwritel_relaxed(lic->cpu_ier[i],\r\nictlr + ICTLR_CPU_IER_SET);\r\nwritel_relaxed(lic->cop_iep[i],\r\nictlr + ICTLR_COP_IEP_CLASS);\r\nwritel_relaxed(~0ul, ictlr + ICTLR_COP_IER_CLR);\r\nwritel_relaxed(lic->cop_ier[i],\r\nictlr + ICTLR_COP_IER_SET);\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void tegra_ictlr_syscore_init(void)\r\n{\r\nregister_syscore_ops(&tegra_ictlr_syscore_ops);\r\n}\r\nstatic inline void tegra_ictlr_syscore_init(void) {}\r\nstatic int tegra_ictlr_domain_xlate(struct irq_domain *domain,\r\nstruct device_node *controller,\r\nconst u32 *intspec,\r\nunsigned int intsize,\r\nunsigned long *out_hwirq,\r\nunsigned int *out_type)\r\n{\r\nif (domain->of_node != controller)\r\nreturn -EINVAL;\r\nif (intsize != 3)\r\nreturn -EINVAL;\r\nif (intspec[0] != GIC_SPI)\r\nreturn -EINVAL;\r\n*out_hwirq = intspec[1];\r\n*out_type = intspec[2];\r\nreturn 0;\r\n}\r\nstatic int tegra_ictlr_domain_alloc(struct irq_domain *domain,\r\nunsigned int virq,\r\nunsigned int nr_irqs, void *data)\r\n{\r\nstruct of_phandle_args *args = data;\r\nstruct of_phandle_args parent_args;\r\nstruct tegra_ictlr_info *info = domain->host_data;\r\nirq_hw_number_t hwirq;\r\nunsigned int i;\r\nif (args->args_count != 3)\r\nreturn -EINVAL;\r\nif (args->args[0] != GIC_SPI)\r\nreturn -EINVAL;\r\nhwirq = args->args[1];\r\nif (hwirq >= (num_ictlrs * 32))\r\nreturn -EINVAL;\r\nfor (i = 0; i < nr_irqs; i++) {\r\nint ictlr = (hwirq + i) / 32;\r\nirq_domain_set_hwirq_and_chip(domain, virq + i, hwirq + i,\r\n&tegra_ictlr_chip,\r\ninfo->base[ictlr]);\r\n}\r\nparent_args = *args;\r\nparent_args.np = domain->parent->of_node;\r\nreturn irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, &parent_args);\r\n}\r\nstatic void tegra_ictlr_domain_free(struct irq_domain *domain,\r\nunsigned int virq,\r\nunsigned int nr_irqs)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < nr_irqs; i++) {\r\nstruct irq_data *d = irq_domain_get_irq_data(domain, virq + i);\r\nirq_domain_reset_irq_data(d);\r\n}\r\n}\r\nstatic int __init tegra_ictlr_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nstruct irq_domain *parent_domain, *domain;\r\nconst struct of_device_id *match;\r\nconst struct tegra_ictlr_soc *soc;\r\nunsigned int i;\r\nint err;\r\nif (!parent) {\r\npr_err("%s: no parent, giving up\n", node->full_name);\r\nreturn -ENODEV;\r\n}\r\nparent_domain = irq_find_host(parent);\r\nif (!parent_domain) {\r\npr_err("%s: unable to obtain parent domain\n", node->full_name);\r\nreturn -ENXIO;\r\n}\r\nmatch = of_match_node(ictlr_matches, node);\r\nif (!match)\r\nreturn -ENODEV;\r\nsoc = match->data;\r\nlic = kzalloc(sizeof(*lic), GFP_KERNEL);\r\nif (!lic)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < TEGRA_MAX_NUM_ICTLRS; i++) {\r\nvoid __iomem *base;\r\nbase = of_iomap(node, i);\r\nif (!base)\r\nbreak;\r\nlic->base[i] = base;\r\nwritel_relaxed(~0UL, base + ICTLR_CPU_IER_CLR);\r\nwritel_relaxed(0, base + ICTLR_CPU_IEP_CLASS);\r\nnum_ictlrs++;\r\n}\r\nif (!num_ictlrs) {\r\npr_err("%s: no valid regions, giving up\n", node->full_name);\r\nerr = -ENOMEM;\r\ngoto out_free;\r\n}\r\nWARN(num_ictlrs != soc->num_ictlrs,\r\n"%s: Found %u interrupt controllers in DT; expected %u.\n",\r\nnode->full_name, num_ictlrs, soc->num_ictlrs);\r\ndomain = irq_domain_add_hierarchy(parent_domain, 0, num_ictlrs * 32,\r\nnode, &tegra_ictlr_domain_ops,\r\nlic);\r\nif (!domain) {\r\npr_err("%s: failed to allocated domain\n", node->full_name);\r\nerr = -ENOMEM;\r\ngoto out_unmap;\r\n}\r\ntegra_ictlr_syscore_init();\r\npr_info("%s: %d interrupts forwarded to %s\n",\r\nnode->full_name, num_ictlrs * 32, parent->full_name);\r\nreturn 0;\r\nout_unmap:\r\nfor (i = 0; i < num_ictlrs; i++)\r\niounmap(lic->base[i]);\r\nout_free:\r\nkfree(lic);\r\nreturn err;\r\n}
