void hci_req_init(struct hci_request *req, struct hci_dev *hdev)\r\n{\r\nskb_queue_head_init(&req->cmd_q);\r\nreq->hdev = hdev;\r\nreq->err = 0;\r\n}\r\nstatic int req_run(struct hci_request *req, hci_req_complete_t complete,\r\nhci_req_complete_skb_t complete_skb)\r\n{\r\nstruct hci_dev *hdev = req->hdev;\r\nstruct sk_buff *skb;\r\nunsigned long flags;\r\nBT_DBG("length %u", skb_queue_len(&req->cmd_q));\r\nif (req->err) {\r\nskb_queue_purge(&req->cmd_q);\r\nreturn req->err;\r\n}\r\nif (skb_queue_empty(&req->cmd_q))\r\nreturn -ENODATA;\r\nskb = skb_peek_tail(&req->cmd_q);\r\nbt_cb(skb)->req.complete = complete;\r\nbt_cb(skb)->req.complete_skb = complete_skb;\r\nspin_lock_irqsave(&hdev->cmd_q.lock, flags);\r\nskb_queue_splice_tail(&req->cmd_q, &hdev->cmd_q);\r\nspin_unlock_irqrestore(&hdev->cmd_q.lock, flags);\r\nqueue_work(hdev->workqueue, &hdev->cmd_work);\r\nreturn 0;\r\n}\r\nint hci_req_run(struct hci_request *req, hci_req_complete_t complete)\r\n{\r\nreturn req_run(req, complete, NULL);\r\n}\r\nint hci_req_run_skb(struct hci_request *req, hci_req_complete_skb_t complete)\r\n{\r\nreturn req_run(req, NULL, complete);\r\n}\r\nstruct sk_buff *hci_prepare_cmd(struct hci_dev *hdev, u16 opcode, u32 plen,\r\nconst void *param)\r\n{\r\nint len = HCI_COMMAND_HDR_SIZE + plen;\r\nstruct hci_command_hdr *hdr;\r\nstruct sk_buff *skb;\r\nskb = bt_skb_alloc(len, GFP_ATOMIC);\r\nif (!skb)\r\nreturn NULL;\r\nhdr = (struct hci_command_hdr *) skb_put(skb, HCI_COMMAND_HDR_SIZE);\r\nhdr->opcode = cpu_to_le16(opcode);\r\nhdr->plen = plen;\r\nif (plen)\r\nmemcpy(skb_put(skb, plen), param, plen);\r\nBT_DBG("skb len %d", skb->len);\r\nbt_cb(skb)->pkt_type = HCI_COMMAND_PKT;\r\nbt_cb(skb)->opcode = opcode;\r\nreturn skb;\r\n}\r\nvoid hci_req_add_ev(struct hci_request *req, u16 opcode, u32 plen,\r\nconst void *param, u8 event)\r\n{\r\nstruct hci_dev *hdev = req->hdev;\r\nstruct sk_buff *skb;\r\nBT_DBG("%s opcode 0x%4.4x plen %d", hdev->name, opcode, plen);\r\nif (req->err)\r\nreturn;\r\nskb = hci_prepare_cmd(hdev, opcode, plen, param);\r\nif (!skb) {\r\nBT_ERR("%s no memory for command (opcode 0x%4.4x)",\r\nhdev->name, opcode);\r\nreq->err = -ENOMEM;\r\nreturn;\r\n}\r\nif (skb_queue_empty(&req->cmd_q))\r\nbt_cb(skb)->req.start = true;\r\nbt_cb(skb)->req.event = event;\r\nskb_queue_tail(&req->cmd_q, skb);\r\n}\r\nvoid hci_req_add(struct hci_request *req, u16 opcode, u32 plen,\r\nconst void *param)\r\n{\r\nhci_req_add_ev(req, opcode, plen, param, 0);\r\n}\r\nvoid hci_req_add_le_scan_disable(struct hci_request *req)\r\n{\r\nstruct hci_cp_le_set_scan_enable cp;\r\nmemset(&cp, 0, sizeof(cp));\r\ncp.enable = LE_SCAN_DISABLE;\r\nhci_req_add(req, HCI_OP_LE_SET_SCAN_ENABLE, sizeof(cp), &cp);\r\n}\r\nstatic void add_to_white_list(struct hci_request *req,\r\nstruct hci_conn_params *params)\r\n{\r\nstruct hci_cp_le_add_to_white_list cp;\r\ncp.bdaddr_type = params->addr_type;\r\nbacpy(&cp.bdaddr, &params->addr);\r\nhci_req_add(req, HCI_OP_LE_ADD_TO_WHITE_LIST, sizeof(cp), &cp);\r\n}\r\nstatic u8 update_white_list(struct hci_request *req)\r\n{\r\nstruct hci_dev *hdev = req->hdev;\r\nstruct hci_conn_params *params;\r\nstruct bdaddr_list *b;\r\nuint8_t white_list_entries = 0;\r\nlist_for_each_entry(b, &hdev->le_white_list, list) {\r\nstruct hci_cp_le_del_from_white_list cp;\r\nif (hci_pend_le_action_lookup(&hdev->pend_le_conns,\r\n&b->bdaddr, b->bdaddr_type) ||\r\nhci_pend_le_action_lookup(&hdev->pend_le_reports,\r\n&b->bdaddr, b->bdaddr_type)) {\r\nwhite_list_entries++;\r\ncontinue;\r\n}\r\ncp.bdaddr_type = b->bdaddr_type;\r\nbacpy(&cp.bdaddr, &b->bdaddr);\r\nhci_req_add(req, HCI_OP_LE_DEL_FROM_WHITE_LIST,\r\nsizeof(cp), &cp);\r\n}\r\nlist_for_each_entry(params, &hdev->pend_le_conns, action) {\r\nif (hci_bdaddr_list_lookup(&hdev->le_white_list,\r\n&params->addr, params->addr_type))\r\ncontinue;\r\nif (white_list_entries >= hdev->le_white_list_size) {\r\nreturn 0x00;\r\n}\r\nif (hci_find_irk_by_addr(hdev, &params->addr,\r\nparams->addr_type)) {\r\nreturn 0x00;\r\n}\r\nwhite_list_entries++;\r\nadd_to_white_list(req, params);\r\n}\r\nlist_for_each_entry(params, &hdev->pend_le_reports, action) {\r\nif (hci_bdaddr_list_lookup(&hdev->le_white_list,\r\n&params->addr, params->addr_type))\r\ncontinue;\r\nif (white_list_entries >= hdev->le_white_list_size) {\r\nreturn 0x00;\r\n}\r\nif (hci_find_irk_by_addr(hdev, &params->addr,\r\nparams->addr_type)) {\r\nreturn 0x00;\r\n}\r\nwhite_list_entries++;\r\nadd_to_white_list(req, params);\r\n}\r\nreturn 0x01;\r\n}\r\nvoid hci_req_add_le_passive_scan(struct hci_request *req)\r\n{\r\nstruct hci_cp_le_set_scan_param param_cp;\r\nstruct hci_cp_le_set_scan_enable enable_cp;\r\nstruct hci_dev *hdev = req->hdev;\r\nu8 own_addr_type;\r\nu8 filter_policy;\r\nif (hci_update_random_address(req, false, &own_addr_type))\r\nreturn;\r\nfilter_policy = update_white_list(req);\r\nif (hci_dev_test_flag(hdev, HCI_PRIVACY) &&\r\n(hdev->le_features[0] & HCI_LE_EXT_SCAN_POLICY))\r\nfilter_policy |= 0x02;\r\nmemset(&param_cp, 0, sizeof(param_cp));\r\nparam_cp.type = LE_SCAN_PASSIVE;\r\nparam_cp.interval = cpu_to_le16(hdev->le_scan_interval);\r\nparam_cp.window = cpu_to_le16(hdev->le_scan_window);\r\nparam_cp.own_address_type = own_addr_type;\r\nparam_cp.filter_policy = filter_policy;\r\nhci_req_add(req, HCI_OP_LE_SET_SCAN_PARAM, sizeof(param_cp),\r\n&param_cp);\r\nmemset(&enable_cp, 0, sizeof(enable_cp));\r\nenable_cp.enable = LE_SCAN_ENABLE;\r\nenable_cp.filter_dup = LE_SCAN_FILTER_DUP_ENABLE;\r\nhci_req_add(req, HCI_OP_LE_SET_SCAN_ENABLE, sizeof(enable_cp),\r\n&enable_cp);\r\n}\r\nstatic void set_random_addr(struct hci_request *req, bdaddr_t *rpa)\r\n{\r\nstruct hci_dev *hdev = req->hdev;\r\nif (hci_dev_test_flag(hdev, HCI_LE_ADV) ||\r\nhci_conn_hash_lookup_state(hdev, LE_LINK, BT_CONNECT)) {\r\nBT_DBG("Deferring random address update");\r\nhci_dev_set_flag(hdev, HCI_RPA_EXPIRED);\r\nreturn;\r\n}\r\nhci_req_add(req, HCI_OP_LE_SET_RANDOM_ADDR, 6, rpa);\r\n}\r\nint hci_update_random_address(struct hci_request *req, bool require_privacy,\r\nu8 *own_addr_type)\r\n{\r\nstruct hci_dev *hdev = req->hdev;\r\nint err;\r\nif (hci_dev_test_flag(hdev, HCI_PRIVACY)) {\r\nint to;\r\n*own_addr_type = ADDR_LE_DEV_RANDOM;\r\nif (!hci_dev_test_and_clear_flag(hdev, HCI_RPA_EXPIRED) &&\r\n!bacmp(&hdev->random_addr, &hdev->rpa))\r\nreturn 0;\r\nerr = smp_generate_rpa(hdev, hdev->irk, &hdev->rpa);\r\nif (err < 0) {\r\nBT_ERR("%s failed to generate new RPA", hdev->name);\r\nreturn err;\r\n}\r\nset_random_addr(req, &hdev->rpa);\r\nto = msecs_to_jiffies(hdev->rpa_timeout * 1000);\r\nqueue_delayed_work(hdev->workqueue, &hdev->rpa_expired, to);\r\nreturn 0;\r\n}\r\nif (require_privacy) {\r\nbdaddr_t nrpa;\r\nwhile (true) {\r\nget_random_bytes(&nrpa, 6);\r\nnrpa.b[5] &= 0x3f;\r\nif (bacmp(&hdev->bdaddr, &nrpa))\r\nbreak;\r\n}\r\n*own_addr_type = ADDR_LE_DEV_RANDOM;\r\nset_random_addr(req, &nrpa);\r\nreturn 0;\r\n}\r\nif (hci_dev_test_flag(hdev, HCI_FORCE_STATIC_ADDR) ||\r\n!bacmp(&hdev->bdaddr, BDADDR_ANY) ||\r\n(!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED) &&\r\nbacmp(&hdev->static_addr, BDADDR_ANY))) {\r\n*own_addr_type = ADDR_LE_DEV_RANDOM;\r\nif (bacmp(&hdev->static_addr, &hdev->random_addr))\r\nhci_req_add(req, HCI_OP_LE_SET_RANDOM_ADDR, 6,\r\n&hdev->static_addr);\r\nreturn 0;\r\n}\r\n*own_addr_type = ADDR_LE_DEV_PUBLIC;\r\nreturn 0;\r\n}\r\nstatic bool disconnected_whitelist_entries(struct hci_dev *hdev)\r\n{\r\nstruct bdaddr_list *b;\r\nlist_for_each_entry(b, &hdev->whitelist, list) {\r\nstruct hci_conn *conn;\r\nconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &b->bdaddr);\r\nif (!conn)\r\nreturn true;\r\nif (conn->state != BT_CONNECTED && conn->state != BT_CONFIG)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nvoid __hci_update_page_scan(struct hci_request *req)\r\n{\r\nstruct hci_dev *hdev = req->hdev;\r\nu8 scan;\r\nif (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED))\r\nreturn;\r\nif (!hdev_is_powered(hdev))\r\nreturn;\r\nif (mgmt_powering_down(hdev))\r\nreturn;\r\nif (hci_dev_test_flag(hdev, HCI_CONNECTABLE) ||\r\ndisconnected_whitelist_entries(hdev))\r\nscan = SCAN_PAGE;\r\nelse\r\nscan = SCAN_DISABLED;\r\nif (test_bit(HCI_PSCAN, &hdev->flags) == !!(scan & SCAN_PAGE))\r\nreturn;\r\nif (hci_dev_test_flag(hdev, HCI_DISCOVERABLE))\r\nscan |= SCAN_INQUIRY;\r\nhci_req_add(req, HCI_OP_WRITE_SCAN_ENABLE, 1, &scan);\r\n}\r\nvoid hci_update_page_scan(struct hci_dev *hdev)\r\n{\r\nstruct hci_request req;\r\nhci_req_init(&req, hdev);\r\n__hci_update_page_scan(&req);\r\nhci_req_run(&req, NULL);\r\n}\r\nvoid __hci_update_background_scan(struct hci_request *req)\r\n{\r\nstruct hci_dev *hdev = req->hdev;\r\nstruct hci_conn *conn;\r\nif (!test_bit(HCI_UP, &hdev->flags) ||\r\ntest_bit(HCI_INIT, &hdev->flags) ||\r\nhci_dev_test_flag(hdev, HCI_SETUP) ||\r\nhci_dev_test_flag(hdev, HCI_CONFIG) ||\r\nhci_dev_test_flag(hdev, HCI_AUTO_OFF) ||\r\nhci_dev_test_flag(hdev, HCI_UNREGISTER))\r\nreturn;\r\nif (!hci_dev_test_flag(hdev, HCI_LE_ENABLED))\r\nreturn;\r\nif (hdev->discovery.state != DISCOVERY_STOPPED)\r\nreturn;\r\nhci_discovery_filter_clear(hdev);\r\nif (list_empty(&hdev->pend_le_conns) &&\r\nlist_empty(&hdev->pend_le_reports)) {\r\nif (!hci_dev_test_flag(hdev, HCI_LE_SCAN))\r\nreturn;\r\nhci_req_add_le_scan_disable(req);\r\nBT_DBG("%s stopping background scanning", hdev->name);\r\n} else {\r\nconn = hci_conn_hash_lookup_state(hdev, LE_LINK, BT_CONNECT);\r\nif (conn)\r\nreturn;\r\nif (hci_dev_test_flag(hdev, HCI_LE_SCAN))\r\nhci_req_add_le_scan_disable(req);\r\nhci_req_add_le_passive_scan(req);\r\nBT_DBG("%s starting background scanning", hdev->name);\r\n}\r\n}\r\nstatic void update_background_scan_complete(struct hci_dev *hdev, u8 status,\r\nu16 opcode)\r\n{\r\nif (status)\r\nBT_DBG("HCI request failed to update background scanning: "\r\n"status 0x%2.2x", status);\r\n}\r\nvoid hci_update_background_scan(struct hci_dev *hdev)\r\n{\r\nint err;\r\nstruct hci_request req;\r\nhci_req_init(&req, hdev);\r\n__hci_update_background_scan(&req);\r\nerr = hci_req_run(&req, update_background_scan_complete);\r\nif (err && err != -ENODATA)\r\nBT_ERR("Failed to run HCI request: err %d", err);\r\n}
