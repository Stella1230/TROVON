static ssize_t device_show(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mbus_device *dev = dev_to_mbus(d);\r\nreturn sprintf(buf, "0x%04x\n", dev->id.device);\r\n}\r\nstatic ssize_t vendor_show(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mbus_device *dev = dev_to_mbus(d);\r\nreturn sprintf(buf, "0x%04x\n", dev->id.vendor);\r\n}\r\nstatic ssize_t modalias_show(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mbus_device *dev = dev_to_mbus(d);\r\nreturn sprintf(buf, "mbus:d%08Xv%08X\n",\r\ndev->id.device, dev->id.vendor);\r\n}\r\nstatic inline int mbus_id_match(const struct mbus_device *dev,\r\nconst struct mbus_device_id *id)\r\n{\r\nif (id->device != dev->id.device && id->device != MBUS_DEV_ANY_ID)\r\nreturn 0;\r\nreturn id->vendor == MBUS_DEV_ANY_ID || id->vendor == dev->id.vendor;\r\n}\r\nstatic int mbus_dev_match(struct device *dv, struct device_driver *dr)\r\n{\r\nunsigned int i;\r\nstruct mbus_device *dev = dev_to_mbus(dv);\r\nconst struct mbus_device_id *ids;\r\nids = drv_to_mbus(dr)->id_table;\r\nfor (i = 0; ids[i].device; i++)\r\nif (mbus_id_match(dev, &ids[i]))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int mbus_uevent(struct device *dv, struct kobj_uevent_env *env)\r\n{\r\nstruct mbus_device *dev = dev_to_mbus(dv);\r\nreturn add_uevent_var(env, "MODALIAS=mbus:d%08Xv%08X",\r\ndev->id.device, dev->id.vendor);\r\n}\r\nstatic int mbus_dev_probe(struct device *d)\r\n{\r\nint err;\r\nstruct mbus_device *dev = dev_to_mbus(d);\r\nstruct mbus_driver *drv = drv_to_mbus(dev->dev.driver);\r\nerr = drv->probe(dev);\r\nif (!err)\r\nif (drv->scan)\r\ndrv->scan(dev);\r\nreturn err;\r\n}\r\nstatic int mbus_dev_remove(struct device *d)\r\n{\r\nstruct mbus_device *dev = dev_to_mbus(d);\r\nstruct mbus_driver *drv = drv_to_mbus(dev->dev.driver);\r\ndrv->remove(dev);\r\nreturn 0;\r\n}\r\nint mbus_register_driver(struct mbus_driver *driver)\r\n{\r\ndriver->driver.bus = &mic_bus;\r\nreturn driver_register(&driver->driver);\r\n}\r\nvoid mbus_unregister_driver(struct mbus_driver *driver)\r\n{\r\ndriver_unregister(&driver->driver);\r\n}\r\nstatic void mbus_release_dev(struct device *d)\r\n{\r\nstruct mbus_device *mbdev = dev_to_mbus(d);\r\nkfree(mbdev);\r\n}\r\nstruct mbus_device *\r\nmbus_register_device(struct device *pdev, int id, struct dma_map_ops *dma_ops,\r\nstruct mbus_hw_ops *hw_ops, void __iomem *mmio_va)\r\n{\r\nint ret;\r\nstruct mbus_device *mbdev;\r\nmbdev = kzalloc(sizeof(*mbdev), GFP_KERNEL);\r\nif (!mbdev)\r\nreturn ERR_PTR(-ENOMEM);\r\nmbdev->mmio_va = mmio_va;\r\nmbdev->dev.parent = pdev;\r\nmbdev->id.device = id;\r\nmbdev->id.vendor = MBUS_DEV_ANY_ID;\r\nmbdev->dev.archdata.dma_ops = dma_ops;\r\nmbdev->dev.dma_mask = &mbdev->dev.coherent_dma_mask;\r\ndma_set_mask(&mbdev->dev, DMA_BIT_MASK(64));\r\nmbdev->dev.release = mbus_release_dev;\r\nmbdev->hw_ops = hw_ops;\r\nmbdev->dev.bus = &mic_bus;\r\nret = ida_simple_get(&mbus_index_ida, 0, 0, GFP_KERNEL);\r\nif (ret < 0)\r\ngoto free_mbdev;\r\nmbdev->index = ret;\r\ndev_set_name(&mbdev->dev, "mbus-dev%u", mbdev->index);\r\nret = device_register(&mbdev->dev);\r\nif (ret)\r\ngoto ida_remove;\r\nreturn mbdev;\r\nida_remove:\r\nida_simple_remove(&mbus_index_ida, mbdev->index);\r\nfree_mbdev:\r\nkfree(mbdev);\r\nreturn ERR_PTR(ret);\r\n}\r\nvoid mbus_unregister_device(struct mbus_device *mbdev)\r\n{\r\nint index = mbdev->index;\r\ndevice_unregister(&mbdev->dev);\r\nida_simple_remove(&mbus_index_ida, index);\r\n}\r\nstatic int __init mbus_init(void)\r\n{\r\nreturn bus_register(&mic_bus);\r\n}\r\nstatic void __exit mbus_exit(void)\r\n{\r\nbus_unregister(&mic_bus);\r\nida_destroy(&mbus_index_ida);\r\n}
