static struct kirkwood_dma_data *kirkwood_priv(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_soc_pcm_runtime *soc_runtime = subs->private_data;\r\nreturn snd_soc_dai_get_drvdata(soc_runtime->cpu_dai);\r\n}\r\nstatic irqreturn_t kirkwood_dma_irq(int irq, void *dev_id)\r\n{\r\nstruct kirkwood_dma_data *priv = dev_id;\r\nunsigned long mask, status, cause;\r\nmask = readl(priv->io + KIRKWOOD_INT_MASK);\r\nstatus = readl(priv->io + KIRKWOOD_INT_CAUSE) & mask;\r\ncause = readl(priv->io + KIRKWOOD_ERR_CAUSE);\r\nif (unlikely(cause)) {\r\nprintk(KERN_WARNING "%s: got err interrupt 0x%lx\n",\r\n__func__, cause);\r\nwritel(cause, priv->io + KIRKWOOD_ERR_CAUSE);\r\n}\r\nif (status & ~(KIRKWOOD_INT_CAUSE_PLAY_BYTES | \\r\nKIRKWOOD_INT_CAUSE_REC_BYTES)) {\r\nprintk(KERN_WARNING "%s: unexpected interrupt %lx\n",\r\n__func__, status);\r\nreturn IRQ_NONE;\r\n}\r\nwritel(status, priv->io + KIRKWOOD_INT_CAUSE);\r\nif (status & KIRKWOOD_INT_CAUSE_PLAY_BYTES)\r\nsnd_pcm_period_elapsed(priv->substream_play);\r\nif (status & KIRKWOOD_INT_CAUSE_REC_BYTES)\r\nsnd_pcm_period_elapsed(priv->substream_rec);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nkirkwood_dma_conf_mbus_windows(void __iomem *base, int win,\r\nunsigned long dma,\r\nconst struct mbus_dram_target_info *dram)\r\n{\r\nint i;\r\nwritel(0, base + KIRKWOOD_AUDIO_WIN_CTRL_REG(win));\r\nwritel(0, base + KIRKWOOD_AUDIO_WIN_BASE_REG(win));\r\nfor (i = 0; i < dram->num_cs; i++) {\r\nconst struct mbus_dram_window *cs = dram->cs + i;\r\nif ((cs->base & 0xffff0000) < (dma & 0xffff0000)) {\r\nwritel(cs->base & 0xffff0000,\r\nbase + KIRKWOOD_AUDIO_WIN_BASE_REG(win));\r\nwritel(((cs->size - 1) & 0xffff0000) |\r\n(cs->mbus_attr << 8) |\r\n(dram->mbus_dram_target_id << 4) | 1,\r\nbase + KIRKWOOD_AUDIO_WIN_CTRL_REG(win));\r\n}\r\n}\r\n}\r\nstatic int kirkwood_dma_open(struct snd_pcm_substream *substream)\r\n{\r\nint err;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct kirkwood_dma_data *priv = kirkwood_priv(substream);\r\nconst struct mbus_dram_target_info *dram;\r\nunsigned long addr;\r\nsnd_soc_set_runtime_hwparams(substream, &kirkwood_dma_snd_hw);\r\nerr = snd_pcm_hw_constraint_minmax(runtime,\r\nSNDRV_PCM_HW_PARAM_BUFFER_BYTES,\r\npriv->burst * 2,\r\nKIRKWOOD_AUDIO_BUF_MAX-1);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_constraint_step(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_BUFFER_BYTES,\r\npriv->burst);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_constraint_step(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_PERIOD_BYTES,\r\npriv->burst);\r\nif (err < 0)\r\nreturn err;\r\nif (!priv->substream_play && !priv->substream_rec) {\r\nerr = request_irq(priv->irq, kirkwood_dma_irq, IRQF_SHARED,\r\n"kirkwood-i2s", priv);\r\nif (err)\r\nreturn -EBUSY;\r\nwritel((unsigned int)-1, priv->io + KIRKWOOD_ERR_MASK);\r\n}\r\ndram = mv_mbus_dram_info();\r\naddr = substream->dma_buffer.addr;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\npriv->substream_play = substream;\r\nkirkwood_dma_conf_mbus_windows(priv->io,\r\nKIRKWOOD_PLAYBACK_WIN, addr, dram);\r\n} else {\r\npriv->substream_rec = substream;\r\nkirkwood_dma_conf_mbus_windows(priv->io,\r\nKIRKWOOD_RECORD_WIN, addr, dram);\r\n}\r\nreturn 0;\r\n}\r\nstatic int kirkwood_dma_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct kirkwood_dma_data *priv = kirkwood_priv(substream);\r\nif (!priv)\r\nreturn 0;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\npriv->substream_play = NULL;\r\nelse\r\npriv->substream_rec = NULL;\r\nif (!priv->substream_play && !priv->substream_rec) {\r\nwritel(0, priv->io + KIRKWOOD_ERR_MASK);\r\nfree_irq(priv->irq, priv);\r\n}\r\nreturn 0;\r\n}\r\nstatic int kirkwood_dma_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);\r\nruntime->dma_bytes = params_buffer_bytes(params);\r\nreturn 0;\r\n}\r\nstatic int kirkwood_dma_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nsnd_pcm_set_runtime_buffer(substream, NULL);\r\nreturn 0;\r\n}\r\nstatic int kirkwood_dma_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct kirkwood_dma_data *priv = kirkwood_priv(substream);\r\nunsigned long size, count;\r\nsize = frames_to_bytes(runtime, runtime->buffer_size);\r\nsize = (size>>2)-1;\r\ncount = snd_pcm_lib_period_bytes(substream);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nwritel(count, priv->io + KIRKWOOD_PLAY_BYTE_INT_COUNT);\r\nwritel(runtime->dma_addr, priv->io + KIRKWOOD_PLAY_BUF_ADDR);\r\nwritel(size, priv->io + KIRKWOOD_PLAY_BUF_SIZE);\r\n} else {\r\nwritel(count, priv->io + KIRKWOOD_REC_BYTE_INT_COUNT);\r\nwritel(runtime->dma_addr, priv->io + KIRKWOOD_REC_BUF_ADDR);\r\nwritel(size, priv->io + KIRKWOOD_REC_BUF_SIZE);\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t kirkwood_dma_pointer(struct snd_pcm_substream\r\n*substream)\r\n{\r\nstruct kirkwood_dma_data *priv = kirkwood_priv(substream);\r\nsnd_pcm_uframes_t count;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ncount = bytes_to_frames(substream->runtime,\r\nreadl(priv->io + KIRKWOOD_PLAY_BYTE_COUNT));\r\nelse\r\ncount = bytes_to_frames(substream->runtime,\r\nreadl(priv->io + KIRKWOOD_REC_BYTE_COUNT));\r\nreturn count;\r\n}\r\nstatic int kirkwood_dma_preallocate_dma_buffer(struct snd_pcm *pcm,\r\nint stream)\r\n{\r\nstruct snd_pcm_substream *substream = pcm->streams[stream].substream;\r\nstruct snd_dma_buffer *buf = &substream->dma_buffer;\r\nsize_t size = kirkwood_dma_snd_hw.buffer_bytes_max;\r\nbuf->dev.type = SNDRV_DMA_TYPE_DEV;\r\nbuf->dev.dev = pcm->card->dev;\r\nbuf->area = dma_alloc_coherent(pcm->card->dev, size,\r\n&buf->addr, GFP_KERNEL);\r\nif (!buf->area)\r\nreturn -ENOMEM;\r\nbuf->bytes = size;\r\nbuf->private_data = NULL;\r\nreturn 0;\r\n}\r\nstatic int kirkwood_dma_new(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct snd_card *card = rtd->card->snd_card;\r\nstruct snd_pcm *pcm = rtd->pcm;\r\nint ret;\r\nret = dma_coerce_mask_and_coherent(card->dev, DMA_BIT_MASK(32));\r\nif (ret)\r\nreturn ret;\r\nif (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {\r\nret = kirkwood_dma_preallocate_dma_buffer(pcm,\r\nSNDRV_PCM_STREAM_PLAYBACK);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {\r\nret = kirkwood_dma_preallocate_dma_buffer(pcm,\r\nSNDRV_PCM_STREAM_CAPTURE);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void kirkwood_dma_free_dma_buffers(struct snd_pcm *pcm)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_dma_buffer *buf;\r\nint stream;\r\nfor (stream = 0; stream < 2; stream++) {\r\nsubstream = pcm->streams[stream].substream;\r\nif (!substream)\r\ncontinue;\r\nbuf = &substream->dma_buffer;\r\nif (!buf->area)\r\ncontinue;\r\ndma_free_coherent(pcm->card->dev, buf->bytes,\r\nbuf->area, buf->addr);\r\nbuf->area = NULL;\r\n}\r\n}
