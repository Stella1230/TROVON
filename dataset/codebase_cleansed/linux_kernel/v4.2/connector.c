int cn_netlink_send_mult(struct cn_msg *msg, u16 len, u32 portid, u32 __group,\r\ngfp_t gfp_mask)\r\n{\r\nstruct cn_callback_entry *__cbq;\r\nunsigned int size;\r\nstruct sk_buff *skb;\r\nstruct nlmsghdr *nlh;\r\nstruct cn_msg *data;\r\nstruct cn_dev *dev = &cdev;\r\nu32 group = 0;\r\nint found = 0;\r\nif (portid || __group) {\r\ngroup = __group;\r\n} else {\r\nspin_lock_bh(&dev->cbdev->queue_lock);\r\nlist_for_each_entry(__cbq, &dev->cbdev->queue_list,\r\ncallback_entry) {\r\nif (cn_cb_equal(&__cbq->id.id, &msg->id)) {\r\nfound = 1;\r\ngroup = __cbq->group;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&dev->cbdev->queue_lock);\r\nif (!found)\r\nreturn -ENODEV;\r\n}\r\nif (!portid && !netlink_has_listeners(dev->nls, group))\r\nreturn -ESRCH;\r\nsize = sizeof(*msg) + len;\r\nskb = nlmsg_new(size, gfp_mask);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nnlh = nlmsg_put(skb, 0, msg->seq, NLMSG_DONE, size, 0);\r\nif (!nlh) {\r\nkfree_skb(skb);\r\nreturn -EMSGSIZE;\r\n}\r\ndata = nlmsg_data(nlh);\r\nmemcpy(data, msg, size);\r\nNETLINK_CB(skb).dst_group = group;\r\nif (group)\r\nreturn netlink_broadcast(dev->nls, skb, portid, group,\r\ngfp_mask);\r\nreturn netlink_unicast(dev->nls, skb, portid, !(gfp_mask&__GFP_WAIT));\r\n}\r\nint cn_netlink_send(struct cn_msg *msg, u32 portid, u32 __group,\r\ngfp_t gfp_mask)\r\n{\r\nreturn cn_netlink_send_mult(msg, msg->len, portid, __group, gfp_mask);\r\n}\r\nstatic int cn_call_callback(struct sk_buff *skb)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct cn_callback_entry *i, *cbq = NULL;\r\nstruct cn_dev *dev = &cdev;\r\nstruct cn_msg *msg = nlmsg_data(nlmsg_hdr(skb));\r\nstruct netlink_skb_parms *nsp = &NETLINK_CB(skb);\r\nint err = -ENODEV;\r\nnlh = nlmsg_hdr(skb);\r\nif (nlh->nlmsg_len < NLMSG_HDRLEN + sizeof(struct cn_msg) + msg->len)\r\nreturn -EINVAL;\r\nspin_lock_bh(&dev->cbdev->queue_lock);\r\nlist_for_each_entry(i, &dev->cbdev->queue_list, callback_entry) {\r\nif (cn_cb_equal(&i->id.id, &msg->id)) {\r\natomic_inc(&i->refcnt);\r\ncbq = i;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&dev->cbdev->queue_lock);\r\nif (cbq != NULL) {\r\ncbq->callback(msg, nsp);\r\nkfree_skb(skb);\r\ncn_queue_release_callback(cbq);\r\nerr = 0;\r\n}\r\nreturn err;\r\n}\r\nstatic void cn_rx_skb(struct sk_buff *__skb)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct sk_buff *skb;\r\nint len, err;\r\nskb = skb_get(__skb);\r\nif (skb->len >= NLMSG_HDRLEN) {\r\nnlh = nlmsg_hdr(skb);\r\nlen = nlmsg_len(nlh);\r\nif (len < (int)sizeof(struct cn_msg) ||\r\nskb->len < nlh->nlmsg_len ||\r\nlen > CONNECTOR_MAX_MSG_SIZE) {\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nerr = cn_call_callback(skb);\r\nif (err < 0)\r\nkfree_skb(skb);\r\n}\r\n}\r\nint cn_add_callback(struct cb_id *id, const char *name,\r\nvoid (*callback)(struct cn_msg *,\r\nstruct netlink_skb_parms *))\r\n{\r\nint err;\r\nstruct cn_dev *dev = &cdev;\r\nif (!cn_already_initialized)\r\nreturn -EAGAIN;\r\nerr = cn_queue_add_callback(dev->cbdev, name, id, callback);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nvoid cn_del_callback(struct cb_id *id)\r\n{\r\nstruct cn_dev *dev = &cdev;\r\ncn_queue_del_callback(dev->cbdev, id);\r\n}\r\nstatic int cn_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct cn_queue_dev *dev = cdev.cbdev;\r\nstruct cn_callback_entry *cbq;\r\nseq_printf(m, "Name ID\n");\r\nspin_lock_bh(&dev->queue_lock);\r\nlist_for_each_entry(cbq, &dev->queue_list, callback_entry) {\r\nseq_printf(m, "%-15s %u:%u\n",\r\ncbq->id.name,\r\ncbq->id.id.idx,\r\ncbq->id.id.val);\r\n}\r\nspin_unlock_bh(&dev->queue_lock);\r\nreturn 0;\r\n}\r\nstatic int cn_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, cn_proc_show, NULL);\r\n}\r\nstatic int cn_init(void)\r\n{\r\nstruct cn_dev *dev = &cdev;\r\nstruct netlink_kernel_cfg cfg = {\r\n.groups = CN_NETLINK_USERS + 0xf,\r\n.input = dev->input,\r\n};\r\ndev->nls = netlink_kernel_create(&init_net, NETLINK_CONNECTOR, &cfg);\r\nif (!dev->nls)\r\nreturn -EIO;\r\ndev->cbdev = cn_queue_alloc_dev("cqueue", dev->nls);\r\nif (!dev->cbdev) {\r\nnetlink_kernel_release(dev->nls);\r\nreturn -EINVAL;\r\n}\r\ncn_already_initialized = 1;\r\nproc_create("connector", S_IRUGO, init_net.proc_net, &cn_file_ops);\r\nreturn 0;\r\n}\r\nstatic void cn_fini(void)\r\n{\r\nstruct cn_dev *dev = &cdev;\r\ncn_already_initialized = 0;\r\nremove_proc_entry("connector", init_net.proc_net);\r\ncn_queue_free_dev(dev->cbdev);\r\nnetlink_kernel_release(dev->nls);\r\n}
