static void irlan_eth_setup(struct net_device *dev)\r\n{\r\nether_setup(dev);\r\ndev->netdev_ops = &irlan_eth_netdev_ops;\r\ndev->destructor = free_netdev;\r\ndev->tx_queue_len = 4;\r\n}\r\nstruct net_device *alloc_irlandev(const char *name)\r\n{\r\nreturn alloc_netdev(sizeof(struct irlan_cb), name, NET_NAME_UNKNOWN,\r\nirlan_eth_setup);\r\n}\r\nstatic int irlan_eth_open(struct net_device *dev)\r\n{\r\nstruct irlan_cb *self = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nself->disconnect_reason = 0;\r\nirlan_client_wakeup(self, self->saddr, self->daddr);\r\nreturn wait_event_interruptible(self->open_wait,\r\n!self->tsap_data->connected);\r\n}\r\nstatic int irlan_eth_close(struct net_device *dev)\r\n{\r\nstruct irlan_cb *self = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nirlan_close_data_channel(self);\r\nirlan_close_tsaps(self);\r\nirlan_do_client_event(self, IRLAN_LMP_DISCONNECT, NULL);\r\nirlan_do_provider_event(self, IRLAN_LMP_DISCONNECT, NULL);\r\nskb_queue_purge(&self->client.txq);\r\nself->client.tx_busy = 0;\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t irlan_eth_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct irlan_cb *self = netdev_priv(dev);\r\nint ret;\r\nunsigned int len;\r\nif ((skb_headroom(skb) < self->max_header_size) || (skb_shared(skb))) {\r\nstruct sk_buff *new_skb =\r\nskb_realloc_headroom(skb, self->max_header_size);\r\ndev_kfree_skb(skb);\r\nif (new_skb == NULL)\r\nreturn NETDEV_TX_OK;\r\nskb = new_skb;\r\n}\r\ndev->trans_start = jiffies;\r\nlen = skb->len;\r\nif (self->use_udata)\r\nret = irttp_udata_request(self->tsap_data, skb);\r\nelse\r\nret = irttp_data_request(self->tsap_data, skb);\r\nif (ret < 0) {\r\ndev->stats.tx_dropped++;\r\n} else {\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += len;\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nint irlan_eth_receive(void *instance, void *sap, struct sk_buff *skb)\r\n{\r\nstruct irlan_cb *self = instance;\r\nstruct net_device *dev = self->dev;\r\nif (skb == NULL) {\r\ndev->stats.rx_dropped++;\r\nreturn 0;\r\n}\r\nif (skb->len < ETH_HLEN) {\r\npr_debug("%s() : IrLAN frame too short (%d)\n",\r\n__func__, skb->len);\r\ndev->stats.rx_dropped++;\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\nskb->protocol = eth_type_trans(skb, dev);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += skb->len;\r\nnetif_rx(skb);\r\nreturn 0;\r\n}\r\nvoid irlan_eth_flow_indication(void *instance, void *sap, LOCAL_FLOW flow)\r\n{\r\nstruct irlan_cb *self;\r\nstruct net_device *dev;\r\nself = instance;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\r\ndev = self->dev;\r\nIRDA_ASSERT(dev != NULL, return;);\r\npr_debug("%s() : flow %s ; running %d\n", __func__,\r\nflow == FLOW_STOP ? "FLOW_STOP" : "FLOW_START",\r\nnetif_running(dev));\r\nswitch (flow) {\r\ncase FLOW_STOP:\r\nnetif_stop_queue(dev);\r\nbreak;\r\ncase FLOW_START:\r\ndefault:\r\nnetif_wake_queue(dev);\r\nbreak;\r\n}\r\n}\r\nstatic void irlan_eth_set_multicast_list(struct net_device *dev)\r\n{\r\nstruct irlan_cb *self = netdev_priv(dev);\r\nif (self->client.state != IRLAN_DATA) {\r\npr_debug("%s(), delaying!\n", __func__);\r\nreturn;\r\n}\r\nif (dev->flags & IFF_PROMISC) {\r\nnet_warn_ratelimited("Promiscuous mode not implemented by IrLAN!\n");\r\n} else if ((dev->flags & IFF_ALLMULTI) ||\r\nnetdev_mc_count(dev) > HW_MAX_ADDRS) {\r\npr_debug("%s(), Setting multicast filter\n", __func__);\r\nirlan_set_multicast_filter(self, TRUE);\r\n} else if (!netdev_mc_empty(dev)) {\r\npr_debug("%s(), Setting multicast filter\n", __func__);\r\nirlan_set_multicast_filter(self, TRUE);\r\n} else {\r\npr_debug("%s(), Clearing multicast filter\n", __func__);\r\nirlan_set_multicast_filter(self, FALSE);\r\n}\r\nif (dev->flags & IFF_BROADCAST)\r\nirlan_set_broadcast_filter(self, TRUE);\r\nelse\r\nirlan_set_broadcast_filter(self, FALSE);\r\n}
