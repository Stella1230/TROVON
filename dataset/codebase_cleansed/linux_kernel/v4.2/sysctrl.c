void ltq_pmu_enable(unsigned int module)\r\n{\r\nint err = 1000000;\r\npmu_w32(pmu_r32(PMU_PWDCR) & ~module, PMU_PWDCR);\r\ndo {} while (--err && (pmu_r32(PMU_PWDSR) & module));\r\nif (!err)\r\npanic("activating PMU module failed!");\r\n}\r\nvoid ltq_pmu_disable(unsigned int module)\r\n{\r\npmu_w32(pmu_r32(PMU_PWDCR) | module, PMU_PWDCR);\r\n}\r\nstatic int cgu_enable(struct clk *clk)\r\n{\r\nltq_cgu_w32(ltq_cgu_r32(ifccr) | clk->bits, ifccr);\r\nreturn 0;\r\n}\r\nstatic void cgu_disable(struct clk *clk)\r\n{\r\nltq_cgu_w32(ltq_cgu_r32(ifccr) & ~clk->bits, ifccr);\r\n}\r\nstatic int pmu_enable(struct clk *clk)\r\n{\r\nint retry = 1000000;\r\npmu_w32(pmu_r32(PWDCR(clk->module)) & ~clk->bits,\r\nPWDCR(clk->module));\r\ndo {} while (--retry && (pmu_r32(PWDSR(clk->module)) & clk->bits));\r\nif (!retry)\r\npanic("activating PMU module failed!");\r\nreturn 0;\r\n}\r\nstatic void pmu_disable(struct clk *clk)\r\n{\r\npmu_w32(pmu_r32(PWDCR(clk->module)) | clk->bits,\r\nPWDCR(clk->module));\r\n}\r\nstatic int pci_enable(struct clk *clk)\r\n{\r\nunsigned int val = ltq_cgu_r32(ifccr);\r\nif (of_machine_is_compatible("lantiq,ar9") ||\r\nof_machine_is_compatible("lantiq,vr9")) {\r\nval &= ~0x1f00000;\r\nif (clk->rate == CLOCK_33M)\r\nval |= 0xe00000;\r\nelse\r\nval |= 0x700000;\r\n} else {\r\nval &= ~0xf00000;\r\nif (clk->rate == CLOCK_33M)\r\nval |= 0x800000;\r\nelse\r\nval |= 0x400000;\r\n}\r\nltq_cgu_w32(val, ifccr);\r\npmu_enable(clk);\r\nreturn 0;\r\n}\r\nstatic int pci_ext_enable(struct clk *clk)\r\n{\r\nltq_cgu_w32(ltq_cgu_r32(ifccr) & ~(1 << 16), ifccr);\r\nltq_cgu_w32((1 << 30), pcicr);\r\nreturn 0;\r\n}\r\nstatic void pci_ext_disable(struct clk *clk)\r\n{\r\nltq_cgu_w32(ltq_cgu_r32(ifccr) | (1 << 16), ifccr);\r\nltq_cgu_w32((1 << 31) | (1 << 30), pcicr);\r\n}\r\nstatic int clkout_enable(struct clk *clk)\r\n{\r\nint i;\r\nfor (i = 0; i < 4; i++) {\r\nif (clk->rates[i] == clk->rate) {\r\nint shift = 14 - (2 * clk->module);\r\nint enable = 7 - clk->module;\r\nunsigned int val = ltq_cgu_r32(ifccr);\r\nval &= ~(3 << shift);\r\nval |= i << shift;\r\nval |= enable;\r\nltq_cgu_w32(val, ifccr);\r\nreturn 0;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic void clkdev_add_pmu(const char *dev, const char *con,\r\nunsigned int module, unsigned int bits)\r\n{\r\nstruct clk *clk = kzalloc(sizeof(struct clk), GFP_KERNEL);\r\nclk->cl.dev_id = dev;\r\nclk->cl.con_id = con;\r\nclk->cl.clk = clk;\r\nclk->enable = pmu_enable;\r\nclk->disable = pmu_disable;\r\nclk->module = module;\r\nclk->bits = bits;\r\nclkdev_add(&clk->cl);\r\n}\r\nstatic void clkdev_add_cgu(const char *dev, const char *con,\r\nunsigned int bits)\r\n{\r\nstruct clk *clk = kzalloc(sizeof(struct clk), GFP_KERNEL);\r\nclk->cl.dev_id = dev;\r\nclk->cl.con_id = con;\r\nclk->cl.clk = clk;\r\nclk->enable = cgu_enable;\r\nclk->disable = cgu_disable;\r\nclk->bits = bits;\r\nclkdev_add(&clk->cl);\r\n}\r\nstatic void clkdev_add_pci(void)\r\n{\r\nstruct clk *clk = kzalloc(sizeof(struct clk), GFP_KERNEL);\r\nstruct clk *clk_ext = kzalloc(sizeof(struct clk), GFP_KERNEL);\r\nclk->cl.dev_id = "17000000.pci";\r\nclk->cl.con_id = NULL;\r\nclk->cl.clk = clk;\r\nclk->rate = CLOCK_33M;\r\nclk->rates = valid_pci_rates;\r\nclk->enable = pci_enable;\r\nclk->disable = pmu_disable;\r\nclk->module = 0;\r\nclk->bits = PMU_PCI;\r\nclkdev_add(&clk->cl);\r\nclk_ext->cl.dev_id = "17000000.pci";\r\nclk_ext->cl.con_id = "external";\r\nclk_ext->cl.clk = clk_ext;\r\nclk_ext->enable = pci_ext_enable;\r\nclk_ext->disable = pci_ext_disable;\r\nclkdev_add(&clk_ext->cl);\r\n}\r\nstatic void clkdev_add_clkout(void)\r\n{\r\nint i;\r\nfor (i = 0; i < 4; i++) {\r\nstruct clk *clk;\r\nchar *name;\r\nname = kzalloc(sizeof("clkout0"), GFP_KERNEL);\r\nsprintf(name, "clkout%d", i);\r\nclk = kzalloc(sizeof(struct clk), GFP_KERNEL);\r\nclk->cl.dev_id = "1f103000.cgu";\r\nclk->cl.con_id = name;\r\nclk->cl.clk = clk;\r\nclk->rate = 0;\r\nclk->rates = valid_clkout_rates[i];\r\nclk->enable = clkout_enable;\r\nclk->module = i;\r\nclkdev_add(&clk->cl);\r\n}\r\n}\r\nvoid __init ltq_soc_init(void)\r\n{\r\nstruct resource res_pmu, res_cgu, res_ebu;\r\nstruct device_node *np_pmu =\r\nof_find_compatible_node(NULL, NULL, "lantiq,pmu-xway");\r\nstruct device_node *np_cgu =\r\nof_find_compatible_node(NULL, NULL, "lantiq,cgu-xway");\r\nstruct device_node *np_ebu =\r\nof_find_compatible_node(NULL, NULL, "lantiq,ebu-xway");\r\nif (!np_pmu || !np_cgu || !np_ebu)\r\npanic("Failed to load core nodes from devicetree");\r\nif (of_address_to_resource(np_pmu, 0, &res_pmu) ||\r\nof_address_to_resource(np_cgu, 0, &res_cgu) ||\r\nof_address_to_resource(np_ebu, 0, &res_ebu))\r\npanic("Failed to get core resources");\r\nif ((request_mem_region(res_pmu.start, resource_size(&res_pmu),\r\nres_pmu.name) < 0) ||\r\n(request_mem_region(res_cgu.start, resource_size(&res_cgu),\r\nres_cgu.name) < 0) ||\r\n(request_mem_region(res_ebu.start, resource_size(&res_ebu),\r\nres_ebu.name) < 0))\r\npr_err("Failed to request core resources");\r\npmu_membase = ioremap_nocache(res_pmu.start, resource_size(&res_pmu));\r\nltq_cgu_membase = ioremap_nocache(res_cgu.start,\r\nresource_size(&res_cgu));\r\nltq_ebu_membase = ioremap_nocache(res_ebu.start,\r\nresource_size(&res_ebu));\r\nif (!pmu_membase || !ltq_cgu_membase || !ltq_ebu_membase)\r\npanic("Failed to remap core resources");\r\nltq_ebu_w32(ltq_ebu_r32(LTQ_EBU_BUSCON0) & ~EBU_WRDIS, LTQ_EBU_BUSCON0);\r\nclkdev_add_pmu("10000000.fpi", NULL, 0, PMU_FPI);\r\nclkdev_add_pmu("1e100400.serial", NULL, 0, PMU_ASC0);\r\nclkdev_add_pmu("1e100a00.gptu", NULL, 0, PMU_GPT);\r\nclkdev_add_pmu("1e100bb0.stp", NULL, 0, PMU_STP);\r\nclkdev_add_pmu("1e104100.dma", NULL, 0, PMU_DMA);\r\nclkdev_add_pmu("1e100800.spi", NULL, 0, PMU_SPI);\r\nclkdev_add_pmu("1e105300.ebu", NULL, 0, PMU_EBU);\r\nclkdev_add_clkout();\r\nif (of_machine_is_compatible("lantiq,vr9")) {\r\nifccr = CGU_IFCCR_VR9;\r\npcicr = CGU_PCICR_VR9;\r\n} else {\r\nclkdev_add_pmu("1e180000.etop", NULL, 0, PMU_PPE);\r\n}\r\nif (!of_machine_is_compatible("lantiq,ase")) {\r\nclkdev_add_pmu("1e100c00.serial", NULL, 0, PMU_ASC1);\r\nclkdev_add_pci();\r\n}\r\nif (of_machine_is_compatible("lantiq,ase")) {\r\nif (ltq_cgu_r32(CGU_SYS) & (1 << 5))\r\nclkdev_add_static(CLOCK_266M, CLOCK_133M,\r\nCLOCK_133M, CLOCK_266M);\r\nelse\r\nclkdev_add_static(CLOCK_133M, CLOCK_133M,\r\nCLOCK_133M, CLOCK_133M);\r\nclkdev_add_cgu("1e180000.etop", "ephycgu", CGU_EPHY),\r\nclkdev_add_pmu("1e180000.etop", "ephy", 0, PMU_EPHY);\r\n} else if (of_machine_is_compatible("lantiq,vr9")) {\r\nclkdev_add_static(ltq_vr9_cpu_hz(), ltq_vr9_fpi_hz(),\r\nltq_vr9_fpi_hz(), ltq_vr9_pp32_hz());\r\nclkdev_add_pmu("1d900000.pcie", "phy", 1, PMU1_PCIE_PHY);\r\nclkdev_add_pmu("1d900000.pcie", "bus", 0, PMU_PCIE_CLK);\r\nclkdev_add_pmu("1d900000.pcie", "msi", 1, PMU1_PCIE_MSI);\r\nclkdev_add_pmu("1d900000.pcie", "pdi", 1, PMU1_PCIE_PDI);\r\nclkdev_add_pmu("1d900000.pcie", "ctl", 1, PMU1_PCIE_CTL);\r\nclkdev_add_pmu("1d900000.pcie", "ahb", 0, PMU_AHBM | PMU_AHBS);\r\nclkdev_add_pmu("1e108000.eth", NULL, 0,\r\nPMU_SWITCH | PMU_PPE_DPLUS | PMU_PPE_DPLUM |\r\nPMU_PPE_EMA | PMU_PPE_TC | PMU_PPE_SLL01 |\r\nPMU_PPE_QSB | PMU_PPE_TOP);\r\nclkdev_add_pmu("1f203000.rcu", "gphy", 0, PMU_GPHY);\r\n} else if (of_machine_is_compatible("lantiq,ar9")) {\r\nclkdev_add_static(ltq_ar9_cpu_hz(), ltq_ar9_fpi_hz(),\r\nltq_ar9_fpi_hz(), CLOCK_250M);\r\nclkdev_add_pmu("1e180000.etop", "switch", 0, PMU_SWITCH);\r\n} else {\r\nclkdev_add_static(ltq_danube_cpu_hz(), ltq_danube_fpi_hz(),\r\nltq_danube_fpi_hz(), ltq_danube_pp32_hz());\r\n}\r\n}
