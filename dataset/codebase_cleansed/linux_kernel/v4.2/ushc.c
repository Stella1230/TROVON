static int ushc_hw_reset(struct ushc_data *ushc)\r\n{\r\nreturn usb_control_msg(ushc->usb_dev, usb_sndctrlpipe(ushc->usb_dev, 0),\r\nUSHC_RESET, USHC_RESET_TYPE,\r\n0, 0, NULL, 0, 100);\r\n}\r\nstatic int ushc_hw_get_caps(struct ushc_data *ushc)\r\n{\r\nint ret;\r\nint version;\r\nret = usb_control_msg(ushc->usb_dev, usb_rcvctrlpipe(ushc->usb_dev, 0),\r\nUSHC_GET_CAPS, USHC_GET_CAPS_TYPE,\r\n0, 0, &ushc->caps, sizeof(ushc->caps), 100);\r\nif (ret < 0)\r\nreturn ret;\r\nushc->caps = le32_to_cpu(ushc->caps);\r\nversion = ushc->caps & USHC_GET_CAPS_VERSION_MASK;\r\nif (version != 0x02) {\r\ndev_err(&ushc->usb_dev->dev, "controller version %d is not supported\n", version);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ushc_hw_set_host_ctrl(struct ushc_data *ushc, u16 mask, u16 val)\r\n{\r\nu16 host_ctrl;\r\nint ret;\r\nhost_ctrl = (ushc->host_ctrl & ~mask) | val;\r\nret = usb_control_msg(ushc->usb_dev, usb_sndctrlpipe(ushc->usb_dev, 0),\r\nUSHC_HOST_CTRL, USHC_HOST_CTRL_TYPE,\r\nhost_ctrl, 0, NULL, 0, 100);\r\nif (ret < 0)\r\nreturn ret;\r\nushc->host_ctrl = host_ctrl;\r\nreturn 0;\r\n}\r\nstatic void int_callback(struct urb *urb)\r\n{\r\nstruct ushc_data *ushc = urb->context;\r\nu8 status, last_status;\r\nif (urb->status < 0)\r\nreturn;\r\nstatus = ushc->int_data->status;\r\nlast_status = ushc->last_status;\r\nushc->last_status = status;\r\nif (!test_and_clear_bit(IGNORE_NEXT_INT, &ushc->flags)\r\n&& test_bit(INT_EN, &ushc->flags)\r\n&& status & USHC_INT_STATUS_SDIO_INT) {\r\nmmc_signal_sdio_irq(ushc->mmc);\r\n}\r\nif ((status ^ last_status) & USHC_INT_STATUS_CARD_PRESENT)\r\nmmc_detect_change(ushc->mmc, msecs_to_jiffies(100));\r\nif (!test_bit(INT_EN, &ushc->flags))\r\nset_bit(IGNORE_NEXT_INT, &ushc->flags);\r\nusb_submit_urb(ushc->int_urb, GFP_ATOMIC);\r\n}\r\nstatic void cbw_callback(struct urb *urb)\r\n{\r\nstruct ushc_data *ushc = urb->context;\r\nif (urb->status != 0) {\r\nusb_unlink_urb(ushc->data_urb);\r\nusb_unlink_urb(ushc->csw_urb);\r\n}\r\n}\r\nstatic void data_callback(struct urb *urb)\r\n{\r\nstruct ushc_data *ushc = urb->context;\r\nif (urb->status != 0)\r\nusb_unlink_urb(ushc->csw_urb);\r\n}\r\nstatic void csw_callback(struct urb *urb)\r\n{\r\nstruct ushc_data *ushc = urb->context;\r\nstruct mmc_request *req = ushc->current_req;\r\nint status;\r\nstatus = ushc->csw->status;\r\nif (urb->status != 0) {\r\nreq->cmd->error = urb->status;\r\n} else if (status & USHC_READ_RESP_ERR_CMD) {\r\nif (status & USHC_READ_RESP_ERR_CRC)\r\nreq->cmd->error = -EIO;\r\nelse\r\nreq->cmd->error = -ETIMEDOUT;\r\n}\r\nif (req->data) {\r\nif (status & USHC_READ_RESP_ERR_DAT) {\r\nif (status & USHC_READ_RESP_ERR_CRC)\r\nreq->data->error = -EIO;\r\nelse\r\nreq->data->error = -ETIMEDOUT;\r\nreq->data->bytes_xfered = 0;\r\n} else {\r\nreq->data->bytes_xfered = req->data->blksz * req->data->blocks;\r\n}\r\n}\r\nreq->cmd->resp[0] = le32_to_cpu(ushc->csw->response);\r\nmmc_request_done(ushc->mmc, req);\r\n}\r\nstatic void ushc_request(struct mmc_host *mmc, struct mmc_request *req)\r\n{\r\nstruct ushc_data *ushc = mmc_priv(mmc);\r\nint ret;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ushc->lock, flags);\r\nif (test_bit(DISCONNECTED, &ushc->flags)) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (req->cmd->flags & MMC_RSP_136) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (req->data && ushc->clock_freq < 6000000) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nushc->current_req = req;\r\nushc->cbw->cmd_idx = cpu_to_le16(req->cmd->opcode);\r\nif (req->data)\r\nushc->cbw->block_size = cpu_to_le16(req->data->blksz);\r\nelse\r\nushc->cbw->block_size = 0;\r\nushc->cbw->arg = cpu_to_le32(req->cmd->arg);\r\nret = usb_submit_urb(ushc->cbw_urb, GFP_ATOMIC);\r\nif (ret < 0)\r\ngoto out;\r\nif (req->data) {\r\nstruct mmc_data *data = req->data;\r\nint pipe;\r\nif (data->flags & MMC_DATA_READ)\r\npipe = usb_rcvbulkpipe(ushc->usb_dev, 6);\r\nelse\r\npipe = usb_sndbulkpipe(ushc->usb_dev, 2);\r\nusb_fill_bulk_urb(ushc->data_urb, ushc->usb_dev, pipe,\r\nsg_virt(data->sg), data->sg->length,\r\ndata_callback, ushc);\r\nret = usb_submit_urb(ushc->data_urb, GFP_ATOMIC);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nret = usb_submit_urb(ushc->csw_urb, GFP_ATOMIC);\r\nif (ret < 0)\r\ngoto out;\r\nout:\r\nspin_unlock_irqrestore(&ushc->lock, flags);\r\nif (ret < 0) {\r\nusb_unlink_urb(ushc->cbw_urb);\r\nusb_unlink_urb(ushc->data_urb);\r\nreq->cmd->error = ret;\r\nmmc_request_done(mmc, req);\r\n}\r\n}\r\nstatic int ushc_set_power(struct ushc_data *ushc, unsigned char power_mode)\r\n{\r\nu16 voltage;\r\nswitch (power_mode) {\r\ncase MMC_POWER_OFF:\r\nvoltage = USHC_PWR_CTRL_OFF;\r\nbreak;\r\ncase MMC_POWER_UP:\r\ncase MMC_POWER_ON:\r\nvoltage = USHC_PWR_CTRL_3V3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn usb_control_msg(ushc->usb_dev, usb_sndctrlpipe(ushc->usb_dev, 0),\r\nUSHC_PWR_CTRL, USHC_PWR_CTRL_TYPE,\r\nvoltage, 0, NULL, 0, 100);\r\n}\r\nstatic int ushc_set_bus_width(struct ushc_data *ushc, int bus_width)\r\n{\r\nreturn ushc_hw_set_host_ctrl(ushc, USHC_HOST_CTRL_4BIT,\r\nbus_width == 4 ? USHC_HOST_CTRL_4BIT : 0);\r\n}\r\nstatic int ushc_set_bus_freq(struct ushc_data *ushc, int clk, bool enable_hs)\r\n{\r\nint ret;\r\nif (clk == 0)\r\nclk = 400000;\r\nret = ushc_hw_set_host_ctrl(ushc, USHC_HOST_CTRL_HIGH_SPD,\r\nenable_hs ? USHC_HOST_CTRL_HIGH_SPD : 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = usb_control_msg(ushc->usb_dev, usb_sndctrlpipe(ushc->usb_dev, 0),\r\nUSHC_CLK_FREQ, USHC_CLK_FREQ_TYPE,\r\nclk & 0xffff, (clk >> 16) & 0xffff, NULL, 0, 100);\r\nif (ret < 0)\r\nreturn ret;\r\nushc->clock_freq = clk;\r\nreturn 0;\r\n}\r\nstatic void ushc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct ushc_data *ushc = mmc_priv(mmc);\r\nushc_set_power(ushc, ios->power_mode);\r\nushc_set_bus_width(ushc, 1 << ios->bus_width);\r\nushc_set_bus_freq(ushc, ios->clock, ios->timing == MMC_TIMING_SD_HS);\r\n}\r\nstatic int ushc_get_cd(struct mmc_host *mmc)\r\n{\r\nstruct ushc_data *ushc = mmc_priv(mmc);\r\nreturn !!(ushc->last_status & USHC_INT_STATUS_CARD_PRESENT);\r\n}\r\nstatic void ushc_enable_sdio_irq(struct mmc_host *mmc, int enable)\r\n{\r\nstruct ushc_data *ushc = mmc_priv(mmc);\r\nif (enable)\r\nset_bit(INT_EN, &ushc->flags);\r\nelse\r\nclear_bit(INT_EN, &ushc->flags);\r\n}\r\nstatic void ushc_clean_up(struct ushc_data *ushc)\r\n{\r\nusb_free_urb(ushc->int_urb);\r\nusb_free_urb(ushc->csw_urb);\r\nusb_free_urb(ushc->data_urb);\r\nusb_free_urb(ushc->cbw_urb);\r\nkfree(ushc->int_data);\r\nkfree(ushc->cbw);\r\nkfree(ushc->csw);\r\nmmc_free_host(ushc->mmc);\r\n}\r\nstatic int ushc_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nstruct usb_device *usb_dev = interface_to_usbdev(intf);\r\nstruct mmc_host *mmc;\r\nstruct ushc_data *ushc;\r\nint ret;\r\nmmc = mmc_alloc_host(sizeof(struct ushc_data), &intf->dev);\r\nif (mmc == NULL)\r\nreturn -ENOMEM;\r\nushc = mmc_priv(mmc);\r\nusb_set_intfdata(intf, ushc);\r\nushc->usb_dev = usb_dev;\r\nushc->mmc = mmc;\r\nspin_lock_init(&ushc->lock);\r\nret = ushc_hw_reset(ushc);\r\nif (ret < 0)\r\ngoto err;\r\nret = ushc_hw_get_caps(ushc);\r\nif (ret < 0)\r\ngoto err;\r\nmmc->ops = &ushc_ops;\r\nmmc->f_min = 400000;\r\nmmc->f_max = 50000000;\r\nmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;\r\nmmc->caps = MMC_CAP_4_BIT_DATA | MMC_CAP_SDIO_IRQ;\r\nmmc->caps |= (ushc->caps & USHC_GET_CAPS_HIGH_SPD) ? MMC_CAP_SD_HIGHSPEED : 0;\r\nmmc->max_seg_size = 512*511;\r\nmmc->max_segs = 1;\r\nmmc->max_req_size = 512*511;\r\nmmc->max_blk_size = 512;\r\nmmc->max_blk_count = 511;\r\nushc->int_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (ushc->int_urb == NULL) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nushc->int_data = kzalloc(sizeof(struct ushc_int_data), GFP_KERNEL);\r\nif (ushc->int_data == NULL) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nusb_fill_int_urb(ushc->int_urb, ushc->usb_dev,\r\nusb_rcvintpipe(usb_dev,\r\nintf->cur_altsetting->endpoint[0].desc.bEndpointAddress),\r\nushc->int_data, sizeof(struct ushc_int_data),\r\nint_callback, ushc,\r\nintf->cur_altsetting->endpoint[0].desc.bInterval);\r\nushc->cbw_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (ushc->cbw_urb == NULL) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nushc->cbw = kzalloc(sizeof(struct ushc_cbw), GFP_KERNEL);\r\nif (ushc->cbw == NULL) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nushc->cbw->signature = USHC_CBW_SIGNATURE;\r\nusb_fill_bulk_urb(ushc->cbw_urb, ushc->usb_dev, usb_sndbulkpipe(usb_dev, 2),\r\nushc->cbw, sizeof(struct ushc_cbw),\r\ncbw_callback, ushc);\r\nushc->data_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (ushc->data_urb == NULL) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nushc->csw_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (ushc->csw_urb == NULL) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nushc->csw = kzalloc(sizeof(struct ushc_csw), GFP_KERNEL);\r\nif (ushc->csw == NULL) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nusb_fill_bulk_urb(ushc->csw_urb, ushc->usb_dev, usb_rcvbulkpipe(usb_dev, 6),\r\nushc->csw, sizeof(struct ushc_csw),\r\ncsw_callback, ushc);\r\nret = mmc_add_host(ushc->mmc);\r\nif (ret)\r\ngoto err;\r\nret = usb_submit_urb(ushc->int_urb, GFP_KERNEL);\r\nif (ret < 0) {\r\nmmc_remove_host(ushc->mmc);\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nushc_clean_up(ushc);\r\nreturn ret;\r\n}\r\nstatic void ushc_disconnect(struct usb_interface *intf)\r\n{\r\nstruct ushc_data *ushc = usb_get_intfdata(intf);\r\nspin_lock_irq(&ushc->lock);\r\nset_bit(DISCONNECTED, &ushc->flags);\r\nspin_unlock_irq(&ushc->lock);\r\nusb_kill_urb(ushc->int_urb);\r\nusb_kill_urb(ushc->cbw_urb);\r\nusb_kill_urb(ushc->data_urb);\r\nusb_kill_urb(ushc->csw_urb);\r\nmmc_remove_host(ushc->mmc);\r\nushc_clean_up(ushc);\r\n}
