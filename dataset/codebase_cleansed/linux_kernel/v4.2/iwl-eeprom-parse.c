static u16 iwl_eeprom_query16(const u8 *eeprom, size_t eeprom_size, int offset)\r\n{\r\nif (WARN_ON(offset + sizeof(u16) > eeprom_size))\r\nreturn 0;\r\nreturn le16_to_cpup((__le16 *)(eeprom + offset));\r\n}\r\nstatic u32 eeprom_indirect_address(const u8 *eeprom, size_t eeprom_size,\r\nu32 address)\r\n{\r\nu16 offset = 0;\r\nif ((address & INDIRECT_ADDRESS) == 0)\r\nreturn address;\r\nswitch (address & INDIRECT_TYPE_MSK) {\r\ncase INDIRECT_HOST:\r\noffset = iwl_eeprom_query16(eeprom, eeprom_size,\r\nEEPROM_LINK_HOST);\r\nbreak;\r\ncase INDIRECT_GENERAL:\r\noffset = iwl_eeprom_query16(eeprom, eeprom_size,\r\nEEPROM_LINK_GENERAL);\r\nbreak;\r\ncase INDIRECT_REGULATORY:\r\noffset = iwl_eeprom_query16(eeprom, eeprom_size,\r\nEEPROM_LINK_REGULATORY);\r\nbreak;\r\ncase INDIRECT_TXP_LIMIT:\r\noffset = iwl_eeprom_query16(eeprom, eeprom_size,\r\nEEPROM_LINK_TXP_LIMIT);\r\nbreak;\r\ncase INDIRECT_TXP_LIMIT_SIZE:\r\noffset = iwl_eeprom_query16(eeprom, eeprom_size,\r\nEEPROM_LINK_TXP_LIMIT_SIZE);\r\nbreak;\r\ncase INDIRECT_CALIBRATION:\r\noffset = iwl_eeprom_query16(eeprom, eeprom_size,\r\nEEPROM_LINK_CALIBRATION);\r\nbreak;\r\ncase INDIRECT_PROCESS_ADJST:\r\noffset = iwl_eeprom_query16(eeprom, eeprom_size,\r\nEEPROM_LINK_PROCESS_ADJST);\r\nbreak;\r\ncase INDIRECT_OTHERS:\r\noffset = iwl_eeprom_query16(eeprom, eeprom_size,\r\nEEPROM_LINK_OTHERS);\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nbreak;\r\n}\r\nreturn (address & ADDRESS_MSK) + (offset << 1);\r\n}\r\nstatic const u8 *iwl_eeprom_query_addr(const u8 *eeprom, size_t eeprom_size,\r\nu32 offset)\r\n{\r\nu32 address = eeprom_indirect_address(eeprom, eeprom_size, offset);\r\nif (WARN_ON(address >= eeprom_size))\r\nreturn NULL;\r\nreturn &eeprom[address];\r\n}\r\nstatic int iwl_eeprom_read_calib(const u8 *eeprom, size_t eeprom_size,\r\nstruct iwl_nvm_data *data)\r\n{\r\nstruct iwl_eeprom_calib_hdr *hdr;\r\nhdr = (void *)iwl_eeprom_query_addr(eeprom, eeprom_size,\r\nEEPROM_CALIB_ALL);\r\nif (!hdr)\r\nreturn -ENODATA;\r\ndata->calib_version = hdr->version;\r\ndata->calib_voltage = hdr->voltage;\r\nreturn 0;\r\n}\r\nstatic s8 iwl_get_max_txpwr_half_dbm(const struct iwl_nvm_data *data,\r\nstruct iwl_eeprom_enhanced_txpwr *txp)\r\n{\r\ns8 result = 0;\r\nif (data->valid_tx_ant & ANT_A && txp->chain_a_max > result)\r\nresult = txp->chain_a_max;\r\nif (data->valid_tx_ant & ANT_B && txp->chain_b_max > result)\r\nresult = txp->chain_b_max;\r\nif (data->valid_tx_ant & ANT_C && txp->chain_c_max > result)\r\nresult = txp->chain_c_max;\r\nif ((data->valid_tx_ant == ANT_AB ||\r\ndata->valid_tx_ant == ANT_BC ||\r\ndata->valid_tx_ant == ANT_AC) && txp->mimo2_max > result)\r\nresult = txp->mimo2_max;\r\nif (data->valid_tx_ant == ANT_ABC && txp->mimo3_max > result)\r\nresult = txp->mimo3_max;\r\nreturn result;\r\n}\r\nstatic void\r\niwl_eeprom_enh_txp_read_element(struct iwl_nvm_data *data,\r\nstruct iwl_eeprom_enhanced_txpwr *txp,\r\nint n_channels, s8 max_txpower_avg)\r\n{\r\nint ch_idx;\r\nenum ieee80211_band band;\r\nband = txp->flags & IWL_EEPROM_ENH_TXP_FL_BAND_52G ?\r\nIEEE80211_BAND_5GHZ : IEEE80211_BAND_2GHZ;\r\nfor (ch_idx = 0; ch_idx < n_channels; ch_idx++) {\r\nstruct ieee80211_channel *chan = &data->channels[ch_idx];\r\nif (txp->channel != 0 && chan->hw_value != txp->channel)\r\ncontinue;\r\nif (band != chan->band)\r\ncontinue;\r\nif (chan->max_power < max_txpower_avg &&\r\n!(txp->flags & IWL_EEPROM_ENH_TXP_FL_40MHZ))\r\nchan->max_power = max_txpower_avg;\r\n}\r\n}\r\nstatic void iwl_eeprom_enhanced_txpower(struct device *dev,\r\nstruct iwl_nvm_data *data,\r\nconst u8 *eeprom, size_t eeprom_size,\r\nint n_channels)\r\n{\r\nstruct iwl_eeprom_enhanced_txpwr *txp_array, *txp;\r\nint idx, entries;\r\n__le16 *txp_len;\r\ns8 max_txp_avg_halfdbm;\r\nBUILD_BUG_ON(sizeof(struct iwl_eeprom_enhanced_txpwr) != 8);\r\ntxp_len = (__le16 *)iwl_eeprom_query_addr(eeprom, eeprom_size,\r\nEEPROM_TXP_SZ_OFFS);\r\nentries = le16_to_cpup(txp_len) * 2 / EEPROM_TXP_ENTRY_LEN;\r\ntxp_array = (void *)iwl_eeprom_query_addr(eeprom, eeprom_size,\r\nEEPROM_TXP_OFFS);\r\nfor (idx = 0; idx < entries; idx++) {\r\ntxp = &txp_array[idx];\r\nif (!(txp->flags & IWL_EEPROM_ENH_TXP_FL_VALID))\r\ncontinue;\r\nIWL_DEBUG_EEPROM(dev, "%s %d:\t %s%s%s%s%s%s%s%s (0x%02x)\n",\r\n(txp->channel && (txp->flags &\r\nIWL_EEPROM_ENH_TXP_FL_COMMON_TYPE)) ?\r\n"Common " : (txp->channel) ?\r\n"Channel" : "Common",\r\n(txp->channel),\r\nTXP_CHECK_AND_PRINT(VALID),\r\nTXP_CHECK_AND_PRINT(BAND_52G),\r\nTXP_CHECK_AND_PRINT(OFDM),\r\nTXP_CHECK_AND_PRINT(40MHZ),\r\nTXP_CHECK_AND_PRINT(HT_AP),\r\nTXP_CHECK_AND_PRINT(RES1),\r\nTXP_CHECK_AND_PRINT(RES2),\r\nTXP_CHECK_AND_PRINT(COMMON_TYPE),\r\ntxp->flags);\r\nIWL_DEBUG_EEPROM(dev,\r\n"\t\t chain_A: 0x%02x chain_B: 0X%02x chain_C: 0X%02x\n",\r\ntxp->chain_a_max, txp->chain_b_max,\r\ntxp->chain_c_max);\r\nIWL_DEBUG_EEPROM(dev,\r\n"\t\t MIMO2: 0x%02x MIMO3: 0x%02x High 20_on_40: 0x%02x Low 20_on_40: 0x%02x\n",\r\ntxp->mimo2_max, txp->mimo3_max,\r\n((txp->delta_20_in_40 & 0xf0) >> 4),\r\n(txp->delta_20_in_40 & 0x0f));\r\nmax_txp_avg_halfdbm = iwl_get_max_txpwr_half_dbm(data, txp);\r\niwl_eeprom_enh_txp_read_element(data, txp, n_channels,\r\nDIV_ROUND_UP(max_txp_avg_halfdbm, 2));\r\nif (max_txp_avg_halfdbm > data->max_tx_pwr_half_dbm)\r\ndata->max_tx_pwr_half_dbm = max_txp_avg_halfdbm;\r\n}\r\n}\r\nstatic void iwl_init_band_reference(const struct iwl_cfg *cfg,\r\nconst u8 *eeprom, size_t eeprom_size,\r\nint eeprom_band, int *eeprom_ch_count,\r\nconst struct iwl_eeprom_channel **ch_info,\r\nconst u8 **eeprom_ch_array)\r\n{\r\nu32 offset = cfg->eeprom_params->regulatory_bands[eeprom_band - 1];\r\noffset |= INDIRECT_ADDRESS | INDIRECT_REGULATORY;\r\n*ch_info = (void *)iwl_eeprom_query_addr(eeprom, eeprom_size, offset);\r\nswitch (eeprom_band) {\r\ncase 1:\r\n*eeprom_ch_count = ARRAY_SIZE(iwl_eeprom_band_1);\r\n*eeprom_ch_array = iwl_eeprom_band_1;\r\nbreak;\r\ncase 2:\r\n*eeprom_ch_count = ARRAY_SIZE(iwl_eeprom_band_2);\r\n*eeprom_ch_array = iwl_eeprom_band_2;\r\nbreak;\r\ncase 3:\r\n*eeprom_ch_count = ARRAY_SIZE(iwl_eeprom_band_3);\r\n*eeprom_ch_array = iwl_eeprom_band_3;\r\nbreak;\r\ncase 4:\r\n*eeprom_ch_count = ARRAY_SIZE(iwl_eeprom_band_4);\r\n*eeprom_ch_array = iwl_eeprom_band_4;\r\nbreak;\r\ncase 5:\r\n*eeprom_ch_count = ARRAY_SIZE(iwl_eeprom_band_5);\r\n*eeprom_ch_array = iwl_eeprom_band_5;\r\nbreak;\r\ncase 6:\r\n*eeprom_ch_count = ARRAY_SIZE(iwl_eeprom_band_6);\r\n*eeprom_ch_array = iwl_eeprom_band_6;\r\nbreak;\r\ncase 7:\r\n*eeprom_ch_count = ARRAY_SIZE(iwl_eeprom_band_7);\r\n*eeprom_ch_array = iwl_eeprom_band_7;\r\nbreak;\r\ndefault:\r\n*eeprom_ch_count = 0;\r\n*eeprom_ch_array = NULL;\r\nWARN_ON(1);\r\n}\r\n}\r\nstatic void iwl_mod_ht40_chan_info(struct device *dev,\r\nstruct iwl_nvm_data *data, int n_channels,\r\nenum ieee80211_band band, u16 channel,\r\nconst struct iwl_eeprom_channel *eeprom_ch,\r\nu8 clear_ht40_extension_channel)\r\n{\r\nstruct ieee80211_channel *chan = NULL;\r\nint i;\r\nfor (i = 0; i < n_channels; i++) {\r\nif (data->channels[i].band != band)\r\ncontinue;\r\nif (data->channels[i].hw_value != channel)\r\ncontinue;\r\nchan = &data->channels[i];\r\nbreak;\r\n}\r\nif (!chan)\r\nreturn;\r\nIWL_DEBUG_EEPROM(dev,\r\n"HT40 Ch. %d [%sGHz] %s%s%s%s%s(0x%02x %ddBm): Ad-Hoc %ssupported\n",\r\nchannel,\r\nband == IEEE80211_BAND_5GHZ ? "5.2" : "2.4",\r\nCHECK_AND_PRINT(IBSS),\r\nCHECK_AND_PRINT(ACTIVE),\r\nCHECK_AND_PRINT(RADAR),\r\nCHECK_AND_PRINT(WIDE),\r\nCHECK_AND_PRINT(DFS),\r\neeprom_ch->flags,\r\neeprom_ch->max_power_avg,\r\n((eeprom_ch->flags & EEPROM_CHANNEL_IBSS) &&\r\n!(eeprom_ch->flags & EEPROM_CHANNEL_RADAR)) ? ""\r\n: "not ");\r\nif (eeprom_ch->flags & EEPROM_CHANNEL_VALID)\r\nchan->flags &= ~clear_ht40_extension_channel;\r\n}\r\nstatic int iwl_init_channel_map(struct device *dev, const struct iwl_cfg *cfg,\r\nstruct iwl_nvm_data *data,\r\nconst u8 *eeprom, size_t eeprom_size)\r\n{\r\nint band, ch_idx;\r\nconst struct iwl_eeprom_channel *eeprom_ch_info;\r\nconst u8 *eeprom_ch_array;\r\nint eeprom_ch_count;\r\nint n_channels = 0;\r\nfor (band = 1; band <= 5; band++) {\r\nstruct ieee80211_channel *channel;\r\niwl_init_band_reference(cfg, eeprom, eeprom_size, band,\r\n&eeprom_ch_count, &eeprom_ch_info,\r\n&eeprom_ch_array);\r\nfor (ch_idx = 0; ch_idx < eeprom_ch_count; ch_idx++) {\r\nconst struct iwl_eeprom_channel *eeprom_ch;\r\neeprom_ch = &eeprom_ch_info[ch_idx];\r\nif (!(eeprom_ch->flags & EEPROM_CHANNEL_VALID)) {\r\nIWL_DEBUG_EEPROM(dev,\r\n"Ch. %d Flags %x [%sGHz] - No traffic\n",\r\neeprom_ch_array[ch_idx],\r\neeprom_ch_info[ch_idx].flags,\r\n(band != 1) ? "5.2" : "2.4");\r\ncontinue;\r\n}\r\nchannel = &data->channels[n_channels];\r\nn_channels++;\r\nchannel->hw_value = eeprom_ch_array[ch_idx];\r\nchannel->band = (band == 1) ? IEEE80211_BAND_2GHZ\r\n: IEEE80211_BAND_5GHZ;\r\nchannel->center_freq =\r\nieee80211_channel_to_frequency(\r\nchannel->hw_value, channel->band);\r\nchannel->flags = IEEE80211_CHAN_NO_HT40;\r\nif (!(eeprom_ch->flags & EEPROM_CHANNEL_IBSS))\r\nchannel->flags |= IEEE80211_CHAN_NO_IR;\r\nif (!(eeprom_ch->flags & EEPROM_CHANNEL_ACTIVE))\r\nchannel->flags |= IEEE80211_CHAN_NO_IR;\r\nif (eeprom_ch->flags & EEPROM_CHANNEL_RADAR)\r\nchannel->flags |= IEEE80211_CHAN_RADAR;\r\nchannel->max_power =\r\neeprom_ch_info[ch_idx].max_power_avg;\r\nIWL_DEBUG_EEPROM(dev,\r\n"Ch. %d [%sGHz] %s%s%s%s%s%s(0x%02x %ddBm): Ad-Hoc %ssupported\n",\r\nchannel->hw_value,\r\n(band != 1) ? "5.2" : "2.4",\r\nCHECK_AND_PRINT_I(VALID),\r\nCHECK_AND_PRINT_I(IBSS),\r\nCHECK_AND_PRINT_I(ACTIVE),\r\nCHECK_AND_PRINT_I(RADAR),\r\nCHECK_AND_PRINT_I(WIDE),\r\nCHECK_AND_PRINT_I(DFS),\r\neeprom_ch_info[ch_idx].flags,\r\neeprom_ch_info[ch_idx].max_power_avg,\r\n((eeprom_ch_info[ch_idx].flags &\r\nEEPROM_CHANNEL_IBSS) &&\r\n!(eeprom_ch_info[ch_idx].flags &\r\nEEPROM_CHANNEL_RADAR))\r\n? "" : "not ");\r\n}\r\n}\r\nif (cfg->eeprom_params->enhanced_txpower) {\r\niwl_eeprom_enhanced_txpower(dev, data, eeprom, eeprom_size,\r\nn_channels);\r\n} else {\r\nint i;\r\ndata->max_tx_pwr_half_dbm = -128;\r\nfor (i = 0; i < n_channels; i++)\r\ndata->max_tx_pwr_half_dbm =\r\nmax_t(s8, data->max_tx_pwr_half_dbm,\r\ndata->channels[i].max_power * 2);\r\n}\r\nif (cfg->eeprom_params->regulatory_bands[5] ==\r\nEEPROM_REGULATORY_BAND_NO_HT40 &&\r\ncfg->eeprom_params->regulatory_bands[6] ==\r\nEEPROM_REGULATORY_BAND_NO_HT40)\r\nreturn n_channels;\r\nfor (band = 6; band <= 7; band++) {\r\nenum ieee80211_band ieeeband;\r\niwl_init_band_reference(cfg, eeprom, eeprom_size, band,\r\n&eeprom_ch_count, &eeprom_ch_info,\r\n&eeprom_ch_array);\r\nieeeband = (band == 6) ? IEEE80211_BAND_2GHZ\r\n: IEEE80211_BAND_5GHZ;\r\nfor (ch_idx = 0; ch_idx < eeprom_ch_count; ch_idx++) {\r\niwl_mod_ht40_chan_info(dev, data, n_channels, ieeeband,\r\neeprom_ch_array[ch_idx],\r\n&eeprom_ch_info[ch_idx],\r\nIEEE80211_CHAN_NO_HT40PLUS);\r\niwl_mod_ht40_chan_info(dev, data, n_channels, ieeeband,\r\neeprom_ch_array[ch_idx] + 4,\r\n&eeprom_ch_info[ch_idx],\r\nIEEE80211_CHAN_NO_HT40MINUS);\r\n}\r\n}\r\nreturn n_channels;\r\n}\r\nint iwl_init_sband_channels(struct iwl_nvm_data *data,\r\nstruct ieee80211_supported_band *sband,\r\nint n_channels, enum ieee80211_band band)\r\n{\r\nstruct ieee80211_channel *chan = &data->channels[0];\r\nint n = 0, idx = 0;\r\nwhile (chan->band != band && idx < n_channels)\r\nchan = &data->channels[++idx];\r\nsband->channels = &data->channels[idx];\r\nwhile (chan->band == band && idx < n_channels) {\r\nchan = &data->channels[++idx];\r\nn++;\r\n}\r\nsband->n_channels = n;\r\nreturn n;\r\n}\r\nvoid iwl_init_ht_hw_capab(const struct iwl_cfg *cfg,\r\nstruct iwl_nvm_data *data,\r\nstruct ieee80211_sta_ht_cap *ht_info,\r\nenum ieee80211_band band,\r\nu8 tx_chains, u8 rx_chains)\r\n{\r\nint max_bit_rate = 0;\r\ntx_chains = hweight8(tx_chains);\r\nif (cfg->rx_with_siso_diversity)\r\nrx_chains = 1;\r\nelse\r\nrx_chains = hweight8(rx_chains);\r\nif (!(data->sku_cap_11n_enable) || !cfg->ht_params) {\r\nht_info->ht_supported = false;\r\nreturn;\r\n}\r\nif (data->sku_cap_mimo_disabled)\r\nrx_chains = 1;\r\nht_info->ht_supported = true;\r\nht_info->cap = IEEE80211_HT_CAP_DSSSCCK40;\r\nif (cfg->ht_params->stbc) {\r\nht_info->cap |= (1 << IEEE80211_HT_CAP_RX_STBC_SHIFT);\r\nif (tx_chains > 1)\r\nht_info->cap |= IEEE80211_HT_CAP_TX_STBC;\r\n}\r\nif (cfg->ht_params->ldpc)\r\nht_info->cap |= IEEE80211_HT_CAP_LDPC_CODING;\r\nif (iwlwifi_mod_params.amsdu_size_8K)\r\nht_info->cap |= IEEE80211_HT_CAP_MAX_AMSDU;\r\nht_info->ampdu_factor = cfg->max_ht_ampdu_exponent;\r\nht_info->ampdu_density = IEEE80211_HT_MPDU_DENSITY_4;\r\nht_info->mcs.rx_mask[0] = 0xFF;\r\nif (rx_chains >= 2)\r\nht_info->mcs.rx_mask[1] = 0xFF;\r\nif (rx_chains >= 3)\r\nht_info->mcs.rx_mask[2] = 0xFF;\r\nif (cfg->ht_params->ht_greenfield_support)\r\nht_info->cap |= IEEE80211_HT_CAP_GRN_FLD;\r\nht_info->cap |= IEEE80211_HT_CAP_SGI_20;\r\nmax_bit_rate = MAX_BIT_RATE_20_MHZ;\r\nif (cfg->ht_params->ht40_bands & BIT(band)) {\r\nht_info->cap |= IEEE80211_HT_CAP_SUP_WIDTH_20_40;\r\nht_info->cap |= IEEE80211_HT_CAP_SGI_40;\r\nmax_bit_rate = MAX_BIT_RATE_40_MHZ;\r\n}\r\nmax_bit_rate *= rx_chains;\r\nWARN_ON(max_bit_rate & ~IEEE80211_HT_MCS_RX_HIGHEST_MASK);\r\nht_info->mcs.rx_highest = cpu_to_le16(max_bit_rate);\r\nht_info->mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;\r\nif (tx_chains != rx_chains) {\r\nht_info->mcs.tx_params |= IEEE80211_HT_MCS_TX_RX_DIFF;\r\nht_info->mcs.tx_params |= ((tx_chains - 1) <<\r\nIEEE80211_HT_MCS_TX_MAX_STREAMS_SHIFT);\r\n}\r\n}\r\nstatic void iwl_init_sbands(struct device *dev, const struct iwl_cfg *cfg,\r\nstruct iwl_nvm_data *data,\r\nconst u8 *eeprom, size_t eeprom_size)\r\n{\r\nint n_channels = iwl_init_channel_map(dev, cfg, data,\r\neeprom, eeprom_size);\r\nint n_used = 0;\r\nstruct ieee80211_supported_band *sband;\r\nsband = &data->bands[IEEE80211_BAND_2GHZ];\r\nsband->band = IEEE80211_BAND_2GHZ;\r\nsband->bitrates = &iwl_cfg80211_rates[RATES_24_OFFS];\r\nsband->n_bitrates = N_RATES_24;\r\nn_used += iwl_init_sband_channels(data, sband, n_channels,\r\nIEEE80211_BAND_2GHZ);\r\niwl_init_ht_hw_capab(cfg, data, &sband->ht_cap, IEEE80211_BAND_2GHZ,\r\ndata->valid_tx_ant, data->valid_rx_ant);\r\nsband = &data->bands[IEEE80211_BAND_5GHZ];\r\nsband->band = IEEE80211_BAND_5GHZ;\r\nsband->bitrates = &iwl_cfg80211_rates[RATES_52_OFFS];\r\nsband->n_bitrates = N_RATES_52;\r\nn_used += iwl_init_sband_channels(data, sband, n_channels,\r\nIEEE80211_BAND_5GHZ);\r\niwl_init_ht_hw_capab(cfg, data, &sband->ht_cap, IEEE80211_BAND_5GHZ,\r\ndata->valid_tx_ant, data->valid_rx_ant);\r\nif (n_channels != n_used)\r\nIWL_ERR_DEV(dev, "EEPROM: used only %d of %d channels\n",\r\nn_used, n_channels);\r\n}\r\nstruct iwl_nvm_data *\r\niwl_parse_eeprom_data(struct device *dev, const struct iwl_cfg *cfg,\r\nconst u8 *eeprom, size_t eeprom_size)\r\n{\r\nstruct iwl_nvm_data *data;\r\nconst void *tmp;\r\nu16 radio_cfg, sku;\r\nif (WARN_ON(!cfg || !cfg->eeprom_params))\r\nreturn NULL;\r\ndata = kzalloc(sizeof(*data) +\r\nsizeof(struct ieee80211_channel) * IWL_NUM_CHANNELS,\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn NULL;\r\ntmp = iwl_eeprom_query_addr(eeprom, eeprom_size, EEPROM_MAC_ADDRESS);\r\nif (!tmp)\r\ngoto err_free;\r\nmemcpy(data->hw_addr, tmp, ETH_ALEN);\r\ndata->n_hw_addrs = iwl_eeprom_query16(eeprom, eeprom_size,\r\nEEPROM_NUM_MAC_ADDRESS);\r\nif (iwl_eeprom_read_calib(eeprom, eeprom_size, data))\r\ngoto err_free;\r\ntmp = iwl_eeprom_query_addr(eeprom, eeprom_size, EEPROM_XTAL);\r\nif (!tmp)\r\ngoto err_free;\r\nmemcpy(data->xtal_calib, tmp, sizeof(data->xtal_calib));\r\ntmp = iwl_eeprom_query_addr(eeprom, eeprom_size,\r\nEEPROM_RAW_TEMPERATURE);\r\nif (!tmp)\r\ngoto err_free;\r\ndata->raw_temperature = *(__le16 *)tmp;\r\ntmp = iwl_eeprom_query_addr(eeprom, eeprom_size,\r\nEEPROM_KELVIN_TEMPERATURE);\r\nif (!tmp)\r\ngoto err_free;\r\ndata->kelvin_temperature = *(__le16 *)tmp;\r\ndata->kelvin_voltage = *((__le16 *)tmp + 1);\r\nradio_cfg = iwl_eeprom_query16(eeprom, eeprom_size,\r\nEEPROM_RADIO_CONFIG);\r\ndata->radio_cfg_dash = EEPROM_RF_CFG_DASH_MSK(radio_cfg);\r\ndata->radio_cfg_pnum = EEPROM_RF_CFG_PNUM_MSK(radio_cfg);\r\ndata->radio_cfg_step = EEPROM_RF_CFG_STEP_MSK(radio_cfg);\r\ndata->radio_cfg_type = EEPROM_RF_CFG_TYPE_MSK(radio_cfg);\r\ndata->valid_rx_ant = EEPROM_RF_CFG_RX_ANT_MSK(radio_cfg);\r\ndata->valid_tx_ant = EEPROM_RF_CFG_TX_ANT_MSK(radio_cfg);\r\nsku = iwl_eeprom_query16(eeprom, eeprom_size,\r\nEEPROM_SKU_CAP);\r\ndata->sku_cap_11n_enable = sku & EEPROM_SKU_CAP_11N_ENABLE;\r\ndata->sku_cap_amt_enable = sku & EEPROM_SKU_CAP_AMT_ENABLE;\r\ndata->sku_cap_band_24GHz_enable = sku & EEPROM_SKU_CAP_BAND_24GHZ;\r\ndata->sku_cap_band_52GHz_enable = sku & EEPROM_SKU_CAP_BAND_52GHZ;\r\ndata->sku_cap_ipan_enable = sku & EEPROM_SKU_CAP_IPAN_ENABLE;\r\nif (iwlwifi_mod_params.disable_11n & IWL_DISABLE_HT_ALL)\r\ndata->sku_cap_11n_enable = false;\r\ndata->nvm_version = iwl_eeprom_query16(eeprom, eeprom_size,\r\nEEPROM_VERSION);\r\nif (cfg->valid_tx_ant)\r\ndata->valid_tx_ant = cfg->valid_tx_ant;\r\nif (cfg->valid_rx_ant)\r\ndata->valid_rx_ant = cfg->valid_rx_ant;\r\nif (!data->valid_tx_ant || !data->valid_rx_ant) {\r\nIWL_ERR_DEV(dev, "invalid antennas (0x%x, 0x%x)\n",\r\ndata->valid_tx_ant, data->valid_rx_ant);\r\ngoto err_free;\r\n}\r\niwl_init_sbands(dev, cfg, data, eeprom, eeprom_size);\r\nreturn data;\r\nerr_free:\r\nkfree(data);\r\nreturn NULL;\r\n}\r\nint iwl_nvm_check_version(struct iwl_nvm_data *data,\r\nstruct iwl_trans *trans)\r\n{\r\nif (data->nvm_version >= trans->cfg->nvm_ver ||\r\ndata->calib_version >= trans->cfg->nvm_calib_ver) {\r\nIWL_DEBUG_INFO(trans, "device EEPROM VER=0x%x, CALIB=0x%x\n",\r\ndata->nvm_version, data->calib_version);\r\nreturn 0;\r\n}\r\nIWL_ERR(trans,\r\n"Unsupported (too old) EEPROM VER=0x%x < 0x%x CALIB=0x%x < 0x%x\n",\r\ndata->nvm_version, trans->cfg->nvm_ver,\r\ndata->calib_version, trans->cfg->nvm_calib_ver);\r\nreturn -EINVAL;\r\n}
