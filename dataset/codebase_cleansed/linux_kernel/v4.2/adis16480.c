static ssize_t adis16480_show_firmware_revision(struct file *file,\r\nchar __user *userbuf, size_t count, loff_t *ppos)\r\n{\r\nstruct adis16480 *adis16480 = file->private_data;\r\nchar buf[7];\r\nsize_t len;\r\nu16 rev;\r\nint ret;\r\nret = adis_read_reg_16(&adis16480->adis, ADIS16480_REG_FIRM_REV, &rev);\r\nif (ret < 0)\r\nreturn ret;\r\nlen = scnprintf(buf, sizeof(buf), "%x.%x\n", rev >> 8, rev & 0xff);\r\nreturn simple_read_from_buffer(userbuf, count, ppos, buf, len);\r\n}\r\nstatic ssize_t adis16480_show_firmware_date(struct file *file,\r\nchar __user *userbuf, size_t count, loff_t *ppos)\r\n{\r\nstruct adis16480 *adis16480 = file->private_data;\r\nu16 md, year;\r\nchar buf[12];\r\nsize_t len;\r\nint ret;\r\nret = adis_read_reg_16(&adis16480->adis, ADIS16480_REG_FIRM_Y, &year);\r\nif (ret < 0)\r\nreturn ret;\r\nret = adis_read_reg_16(&adis16480->adis, ADIS16480_REG_FIRM_DM, &md);\r\nif (ret < 0)\r\nreturn ret;\r\nlen = snprintf(buf, sizeof(buf), "%.2x-%.2x-%.4x\n",\r\nmd >> 8, md & 0xff, year);\r\nreturn simple_read_from_buffer(userbuf, count, ppos, buf, len);\r\n}\r\nstatic int adis16480_show_serial_number(void *arg, u64 *val)\r\n{\r\nstruct adis16480 *adis16480 = arg;\r\nu16 serial;\r\nint ret;\r\nret = adis_read_reg_16(&adis16480->adis, ADIS16480_REG_SERIAL_NUM,\r\n&serial);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = serial;\r\nreturn 0;\r\n}\r\nstatic int adis16480_show_product_id(void *arg, u64 *val)\r\n{\r\nstruct adis16480 *adis16480 = arg;\r\nu16 prod_id;\r\nint ret;\r\nret = adis_read_reg_16(&adis16480->adis, ADIS16480_REG_PROD_ID,\r\n&prod_id);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = prod_id;\r\nreturn 0;\r\n}\r\nstatic int adis16480_show_flash_count(void *arg, u64 *val)\r\n{\r\nstruct adis16480 *adis16480 = arg;\r\nu32 flash_count;\r\nint ret;\r\nret = adis_read_reg_32(&adis16480->adis, ADIS16480_REG_FLASH_CNT,\r\n&flash_count);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = flash_count;\r\nreturn 0;\r\n}\r\nstatic int adis16480_debugfs_init(struct iio_dev *indio_dev)\r\n{\r\nstruct adis16480 *adis16480 = iio_priv(indio_dev);\r\ndebugfs_create_file("firmware_revision", 0400,\r\nindio_dev->debugfs_dentry, adis16480,\r\n&adis16480_firmware_revision_fops);\r\ndebugfs_create_file("firmware_date", 0400, indio_dev->debugfs_dentry,\r\nadis16480, &adis16480_firmware_date_fops);\r\ndebugfs_create_file("serial_number", 0400, indio_dev->debugfs_dentry,\r\nadis16480, &adis16480_serial_number_fops);\r\ndebugfs_create_file("product_id", 0400, indio_dev->debugfs_dentry,\r\nadis16480, &adis16480_product_id_fops);\r\ndebugfs_create_file("flash_count", 0400, indio_dev->debugfs_dentry,\r\nadis16480, &adis16480_flash_count_fops);\r\nreturn 0;\r\n}\r\nstatic int adis16480_debugfs_init(struct iio_dev *indio_dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int adis16480_set_freq(struct iio_dev *indio_dev, int val, int val2)\r\n{\r\nstruct adis16480 *st = iio_priv(indio_dev);\r\nunsigned int t;\r\nt = val * 1000 + val2 / 1000;\r\nif (t <= 0)\r\nreturn -EINVAL;\r\nt = 2460000 / t;\r\nif (t > 2048)\r\nt = 2048;\r\nif (t != 0)\r\nt--;\r\nreturn adis_write_reg_16(&st->adis, ADIS16480_REG_DEC_RATE, t);\r\n}\r\nstatic int adis16480_get_freq(struct iio_dev *indio_dev, int *val, int *val2)\r\n{\r\nstruct adis16480 *st = iio_priv(indio_dev);\r\nuint16_t t;\r\nint ret;\r\nunsigned freq;\r\nret = adis_read_reg_16(&st->adis, ADIS16480_REG_DEC_RATE, &t);\r\nif (ret < 0)\r\nreturn ret;\r\nfreq = 2460000 / (t + 1);\r\n*val = freq / 1000;\r\n*val2 = (freq % 1000) * 1000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n}\r\nstatic int adis16480_set_calibbias(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, int bias)\r\n{\r\nunsigned int reg = adis16480_calibbias_regs[chan->scan_index];\r\nstruct adis16480 *st = iio_priv(indio_dev);\r\nswitch (chan->type) {\r\ncase IIO_MAGN:\r\ncase IIO_PRESSURE:\r\nif (bias < -0x8000 || bias >= 0x8000)\r\nreturn -EINVAL;\r\nreturn adis_write_reg_16(&st->adis, reg, bias);\r\ncase IIO_ANGL_VEL:\r\ncase IIO_ACCEL:\r\nreturn adis_write_reg_32(&st->adis, reg, bias);\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int adis16480_get_calibbias(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, int *bias)\r\n{\r\nunsigned int reg = adis16480_calibbias_regs[chan->scan_index];\r\nstruct adis16480 *st = iio_priv(indio_dev);\r\nuint16_t val16;\r\nuint32_t val32;\r\nint ret;\r\nswitch (chan->type) {\r\ncase IIO_MAGN:\r\ncase IIO_PRESSURE:\r\nret = adis_read_reg_16(&st->adis, reg, &val16);\r\n*bias = sign_extend32(val16, 15);\r\nbreak;\r\ncase IIO_ANGL_VEL:\r\ncase IIO_ACCEL:\r\nret = adis_read_reg_32(&st->adis, reg, &val32);\r\n*bias = sign_extend32(val32, 31);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nif (ret < 0)\r\nreturn ret;\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic int adis16480_set_calibscale(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, int scale)\r\n{\r\nunsigned int reg = adis16480_calibscale_regs[chan->scan_index];\r\nstruct adis16480 *st = iio_priv(indio_dev);\r\nif (scale < -0x8000 || scale >= 0x8000)\r\nreturn -EINVAL;\r\nreturn adis_write_reg_16(&st->adis, reg, scale);\r\n}\r\nstatic int adis16480_get_calibscale(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, int *scale)\r\n{\r\nunsigned int reg = adis16480_calibscale_regs[chan->scan_index];\r\nstruct adis16480 *st = iio_priv(indio_dev);\r\nuint16_t val16;\r\nint ret;\r\nret = adis_read_reg_16(&st->adis, reg, &val16);\r\nif (ret < 0)\r\nreturn ret;\r\n*scale = sign_extend32(val16, 15);\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic int adis16480_get_filter_freq(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, int *freq)\r\n{\r\nstruct adis16480 *st = iio_priv(indio_dev);\r\nunsigned int enable_mask, offset, reg;\r\nuint16_t val;\r\nint ret;\r\nreg = ad16480_filter_data[chan->scan_index][0];\r\noffset = ad16480_filter_data[chan->scan_index][1];\r\nenable_mask = BIT(offset + 2);\r\nret = adis_read_reg_16(&st->adis, reg, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!(val & enable_mask))\r\n*freq = 0;\r\nelse\r\n*freq = adis16480_def_filter_freqs[(val >> offset) & 0x3];\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic int adis16480_set_filter_freq(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, unsigned int freq)\r\n{\r\nstruct adis16480 *st = iio_priv(indio_dev);\r\nunsigned int enable_mask, offset, reg;\r\nunsigned int diff, best_diff;\r\nunsigned int i, best_freq;\r\nuint16_t val;\r\nint ret;\r\nreg = ad16480_filter_data[chan->scan_index][0];\r\noffset = ad16480_filter_data[chan->scan_index][1];\r\nenable_mask = BIT(offset + 2);\r\nret = adis_read_reg_16(&st->adis, reg, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nif (freq == 0) {\r\nval &= ~enable_mask;\r\n} else {\r\nbest_freq = 0;\r\nbest_diff = 310;\r\nfor (i = 0; i < ARRAY_SIZE(adis16480_def_filter_freqs); i++) {\r\nif (adis16480_def_filter_freqs[i] >= freq) {\r\ndiff = adis16480_def_filter_freqs[i] - freq;\r\nif (diff < best_diff) {\r\nbest_diff = diff;\r\nbest_freq = i;\r\n}\r\n}\r\n}\r\nval &= ~(0x3 << offset);\r\nval |= best_freq << offset;\r\nval |= enable_mask;\r\n}\r\nreturn adis_write_reg_16(&st->adis, reg, val);\r\n}\r\nstatic int adis16480_read_raw(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, int *val, int *val2, long info)\r\n{\r\nswitch (info) {\r\ncase IIO_CHAN_INFO_RAW:\r\nreturn adis_single_conversion(indio_dev, chan, 0, val);\r\ncase IIO_CHAN_INFO_SCALE:\r\nswitch (chan->type) {\r\ncase IIO_ANGL_VEL:\r\n*val = 0;\r\n*val2 = IIO_DEGREE_TO_RAD(20000);\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_ACCEL:\r\n*val = 0;\r\n*val2 = IIO_G_TO_M_S_2(800);\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_MAGN:\r\n*val = 0;\r\n*val2 = 100;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_TEMP:\r\n*val = 5;\r\n*val2 = 650000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_PRESSURE:\r\n*val = 0;\r\n*val2 = 4000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncase IIO_CHAN_INFO_OFFSET:\r\n*val = 4425;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nreturn adis16480_get_calibbias(indio_dev, chan, val);\r\ncase IIO_CHAN_INFO_CALIBSCALE:\r\nreturn adis16480_get_calibscale(indio_dev, chan, val);\r\ncase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\r\nreturn adis16480_get_filter_freq(indio_dev, chan, val);\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nreturn adis16480_get_freq(indio_dev, val, val2);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int adis16480_write_raw(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, int val, int val2, long info)\r\n{\r\nswitch (info) {\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nreturn adis16480_set_calibbias(indio_dev, chan, val);\r\ncase IIO_CHAN_INFO_CALIBSCALE:\r\nreturn adis16480_set_calibscale(indio_dev, chan, val);\r\ncase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\r\nreturn adis16480_set_filter_freq(indio_dev, chan, val);\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nreturn adis16480_set_freq(indio_dev, val, val2);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int adis16480_stop_device(struct iio_dev *indio_dev)\r\n{\r\nstruct adis16480 *st = iio_priv(indio_dev);\r\nint ret;\r\nret = adis_write_reg_16(&st->adis, ADIS16480_REG_SLP_CNT, BIT(9));\r\nif (ret)\r\ndev_err(&indio_dev->dev,\r\n"Could not power down device: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int adis16480_enable_irq(struct adis *adis, bool enable)\r\n{\r\nreturn adis_write_reg_16(adis, ADIS16480_REG_FNCTIO_CTRL,\r\nenable ? BIT(3) : 0);\r\n}\r\nstatic int adis16480_initial_setup(struct iio_dev *indio_dev)\r\n{\r\nstruct adis16480 *st = iio_priv(indio_dev);\r\nuint16_t prod_id;\r\nunsigned int device_id;\r\nint ret;\r\nadis_reset(&st->adis);\r\nmsleep(70);\r\nret = adis_write_reg_16(&st->adis, ADIS16480_REG_GLOB_CMD, BIT(1));\r\nif (ret)\r\nreturn ret;\r\nmsleep(30);\r\nret = adis_check_status(&st->adis);\r\nif (ret)\r\nreturn ret;\r\nret = adis_read_reg_16(&st->adis, ADIS16480_REG_PROD_ID, &prod_id);\r\nif (ret)\r\nreturn ret;\r\nsscanf(indio_dev->name, "adis%u\n", &device_id);\r\nif (prod_id != device_id)\r\ndev_warn(&indio_dev->dev, "Device ID(%u) and product ID(%u) do not match.",\r\ndevice_id, prod_id);\r\nreturn 0;\r\n}\r\nstatic int adis16480_probe(struct spi_device *spi)\r\n{\r\nconst struct spi_device_id *id = spi_get_device_id(spi);\r\nstruct iio_dev *indio_dev;\r\nstruct adis16480 *st;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\r\nif (indio_dev == NULL)\r\nreturn -ENOMEM;\r\nspi_set_drvdata(spi, indio_dev);\r\nst = iio_priv(indio_dev);\r\nst->chip_info = &adis16480_chip_info[id->driver_data];\r\nindio_dev->dev.parent = &spi->dev;\r\nindio_dev->name = spi_get_device_id(spi)->name;\r\nindio_dev->channels = st->chip_info->channels;\r\nindio_dev->num_channels = st->chip_info->num_channels;\r\nindio_dev->info = &adis16480_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nret = adis_init(&st->adis, indio_dev, spi, &adis16480_data);\r\nif (ret)\r\nreturn ret;\r\nret = adis_setup_buffer_and_trigger(&st->adis, indio_dev, NULL);\r\nif (ret)\r\nreturn ret;\r\nret = adis16480_initial_setup(indio_dev);\r\nif (ret)\r\ngoto error_cleanup_buffer;\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto error_stop_device;\r\nadis16480_debugfs_init(indio_dev);\r\nreturn 0;\r\nerror_stop_device:\r\nadis16480_stop_device(indio_dev);\r\nerror_cleanup_buffer:\r\nadis_cleanup_buffer_and_trigger(&st->adis, indio_dev);\r\nreturn ret;\r\n}\r\nstatic int adis16480_remove(struct spi_device *spi)\r\n{\r\nstruct iio_dev *indio_dev = spi_get_drvdata(spi);\r\nstruct adis16480 *st = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\nadis16480_stop_device(indio_dev);\r\nadis_cleanup_buffer_and_trigger(&st->adis, indio_dev);\r\nreturn 0;\r\n}
