static inline unsigned int ipv4_clip_hash(struct clip_tbl *c, const u32 *key)\r\n{\r\nunsigned int clipt_size_half = c->clipt_size / 2;\r\nreturn jhash_1word(*key, 0) % clipt_size_half;\r\n}\r\nstatic inline unsigned int ipv6_clip_hash(struct clip_tbl *d, const u32 *key)\r\n{\r\nunsigned int clipt_size_half = d->clipt_size / 2;\r\nu32 xor = key[0] ^ key[1] ^ key[2] ^ key[3];\r\nreturn clipt_size_half +\r\n(jhash_1word(xor, 0) % clipt_size_half);\r\n}\r\nstatic unsigned int clip_addr_hash(struct clip_tbl *ctbl, const u32 *addr,\r\nu8 v6)\r\n{\r\nreturn v6 ? ipv6_clip_hash(ctbl, addr) :\r\nipv4_clip_hash(ctbl, addr);\r\n}\r\nstatic int clip6_get_mbox(const struct net_device *dev,\r\nconst struct in6_addr *lip)\r\n{\r\nstruct adapter *adap = netdev2adap(dev);\r\nstruct fw_clip_cmd c;\r\nmemset(&c, 0, sizeof(c));\r\nc.op_to_write = htonl(FW_CMD_OP_V(FW_CLIP_CMD) |\r\nFW_CMD_REQUEST_F | FW_CMD_WRITE_F);\r\nc.alloc_to_len16 = htonl(FW_CLIP_CMD_ALLOC_F | FW_LEN16(c));\r\n*(__be64 *)&c.ip_hi = *(__be64 *)(lip->s6_addr);\r\n*(__be64 *)&c.ip_lo = *(__be64 *)(lip->s6_addr + 8);\r\nreturn t4_wr_mbox_meat(adap, adap->mbox, &c, sizeof(c), &c, false);\r\n}\r\nstatic int clip6_release_mbox(const struct net_device *dev,\r\nconst struct in6_addr *lip)\r\n{\r\nstruct adapter *adap = netdev2adap(dev);\r\nstruct fw_clip_cmd c;\r\nmemset(&c, 0, sizeof(c));\r\nc.op_to_write = htonl(FW_CMD_OP_V(FW_CLIP_CMD) |\r\nFW_CMD_REQUEST_F | FW_CMD_READ_F);\r\nc.alloc_to_len16 = htonl(FW_CLIP_CMD_FREE_F | FW_LEN16(c));\r\n*(__be64 *)&c.ip_hi = *(__be64 *)(lip->s6_addr);\r\n*(__be64 *)&c.ip_lo = *(__be64 *)(lip->s6_addr + 8);\r\nreturn t4_wr_mbox_meat(adap, adap->mbox, &c, sizeof(c), &c, false);\r\n}\r\nint cxgb4_clip_get(const struct net_device *dev, const u32 *lip, u8 v6)\r\n{\r\nstruct adapter *adap = netdev2adap(dev);\r\nstruct clip_tbl *ctbl = adap->clipt;\r\nstruct clip_entry *ce, *cte;\r\nu32 *addr = (u32 *)lip;\r\nint hash;\r\nint ret = -1;\r\nif (!ctbl)\r\nreturn 0;\r\nhash = clip_addr_hash(ctbl, addr, v6);\r\nread_lock_bh(&ctbl->lock);\r\nlist_for_each_entry(cte, &ctbl->hash_list[hash], list) {\r\nif (cte->addr6.sin6_family == AF_INET6 && v6)\r\nret = memcmp(lip, cte->addr6.sin6_addr.s6_addr,\r\nsizeof(struct in6_addr));\r\nelse if (cte->addr.sin_family == AF_INET && !v6)\r\nret = memcmp(lip, (char *)(&cte->addr.sin_addr),\r\nsizeof(struct in_addr));\r\nif (!ret) {\r\nce = cte;\r\nread_unlock_bh(&ctbl->lock);\r\ngoto found;\r\n}\r\n}\r\nread_unlock_bh(&ctbl->lock);\r\nwrite_lock_bh(&ctbl->lock);\r\nif (!list_empty(&ctbl->ce_free_head)) {\r\nce = list_first_entry(&ctbl->ce_free_head,\r\nstruct clip_entry, list);\r\nlist_del(&ce->list);\r\nINIT_LIST_HEAD(&ce->list);\r\nspin_lock_init(&ce->lock);\r\natomic_set(&ce->refcnt, 0);\r\natomic_dec(&ctbl->nfree);\r\nlist_add_tail(&ce->list, &ctbl->hash_list[hash]);\r\nif (v6) {\r\nce->addr6.sin6_family = AF_INET6;\r\nmemcpy(ce->addr6.sin6_addr.s6_addr,\r\nlip, sizeof(struct in6_addr));\r\nret = clip6_get_mbox(dev, (const struct in6_addr *)lip);\r\nif (ret) {\r\nwrite_unlock_bh(&ctbl->lock);\r\nreturn ret;\r\n}\r\n} else {\r\nce->addr.sin_family = AF_INET;\r\nmemcpy((char *)(&ce->addr.sin_addr), lip,\r\nsizeof(struct in_addr));\r\n}\r\n} else {\r\nwrite_unlock_bh(&ctbl->lock);\r\nreturn -ENOMEM;\r\n}\r\nwrite_unlock_bh(&ctbl->lock);\r\nfound:\r\natomic_inc(&ce->refcnt);\r\nreturn 0;\r\n}\r\nvoid cxgb4_clip_release(const struct net_device *dev, const u32 *lip, u8 v6)\r\n{\r\nstruct adapter *adap = netdev2adap(dev);\r\nstruct clip_tbl *ctbl = adap->clipt;\r\nstruct clip_entry *ce, *cte;\r\nu32 *addr = (u32 *)lip;\r\nint hash;\r\nint ret = -1;\r\nhash = clip_addr_hash(ctbl, addr, v6);\r\nread_lock_bh(&ctbl->lock);\r\nlist_for_each_entry(cte, &ctbl->hash_list[hash], list) {\r\nif (cte->addr6.sin6_family == AF_INET6 && v6)\r\nret = memcmp(lip, cte->addr6.sin6_addr.s6_addr,\r\nsizeof(struct in6_addr));\r\nelse if (cte->addr.sin_family == AF_INET && !v6)\r\nret = memcmp(lip, (char *)(&cte->addr.sin_addr),\r\nsizeof(struct in_addr));\r\nif (!ret) {\r\nce = cte;\r\nread_unlock_bh(&ctbl->lock);\r\ngoto found;\r\n}\r\n}\r\nread_unlock_bh(&ctbl->lock);\r\nreturn;\r\nfound:\r\nwrite_lock_bh(&ctbl->lock);\r\nspin_lock_bh(&ce->lock);\r\nif (atomic_dec_and_test(&ce->refcnt)) {\r\nlist_del(&ce->list);\r\nINIT_LIST_HEAD(&ce->list);\r\nlist_add_tail(&ce->list, &ctbl->ce_free_head);\r\natomic_inc(&ctbl->nfree);\r\nif (v6)\r\nclip6_release_mbox(dev, (const struct in6_addr *)lip);\r\n}\r\nspin_unlock_bh(&ce->lock);\r\nwrite_unlock_bh(&ctbl->lock);\r\n}\r\nstatic int cxgb4_update_dev_clip(struct net_device *root_dev,\r\nstruct net_device *dev)\r\n{\r\nstruct inet6_dev *idev = NULL;\r\nstruct inet6_ifaddr *ifa;\r\nint ret = 0;\r\nidev = __in6_dev_get(root_dev);\r\nif (!idev)\r\nreturn ret;\r\nread_lock_bh(&idev->lock);\r\nlist_for_each_entry(ifa, &idev->addr_list, if_list) {\r\nret = cxgb4_clip_get(dev, (const u32 *)ifa->addr.s6_addr, 1);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nread_unlock_bh(&idev->lock);\r\nreturn ret;\r\n}\r\nint cxgb4_update_root_dev_clip(struct net_device *dev)\r\n{\r\nstruct net_device *root_dev = NULL;\r\nint i, ret = 0;\r\nret = cxgb4_update_dev_clip(dev, dev);\r\nif (ret)\r\nreturn ret;\r\nroot_dev = netdev_master_upper_dev_get_rcu(dev);\r\nif (root_dev) {\r\nret = cxgb4_update_dev_clip(root_dev, dev);\r\nif (ret)\r\nreturn ret;\r\n}\r\nfor (i = 0; i < VLAN_N_VID; i++) {\r\nroot_dev = __vlan_find_dev_deep_rcu(dev, htons(ETH_P_8021Q), i);\r\nif (!root_dev)\r\ncontinue;\r\nret = cxgb4_update_dev_clip(root_dev, dev);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint clip_tbl_show(struct seq_file *seq, void *v)\r\n{\r\nstruct adapter *adapter = seq->private;\r\nstruct clip_tbl *ctbl = adapter->clipt;\r\nstruct clip_entry *ce;\r\nchar ip[60];\r\nint i;\r\nread_lock_bh(&ctbl->lock);\r\nseq_puts(seq, "IP Address Users\n");\r\nfor (i = 0 ; i < ctbl->clipt_size; ++i) {\r\nlist_for_each_entry(ce, &ctbl->hash_list[i], list) {\r\nip[0] = '\0';\r\nsprintf(ip, "%pISc", &ce->addr);\r\nseq_printf(seq, "%-25s %u\n", ip,\r\natomic_read(&ce->refcnt));\r\n}\r\n}\r\nseq_printf(seq, "Free clip entries : %d\n", atomic_read(&ctbl->nfree));\r\nread_unlock_bh(&ctbl->lock);\r\nreturn 0;\r\n}\r\nstruct clip_tbl *t4_init_clip_tbl(unsigned int clipt_start,\r\nunsigned int clipt_end)\r\n{\r\nstruct clip_entry *cl_list;\r\nstruct clip_tbl *ctbl;\r\nunsigned int clipt_size;\r\nint i;\r\nif (clipt_start >= clipt_end)\r\nreturn NULL;\r\nclipt_size = clipt_end - clipt_start + 1;\r\nif (clipt_size < CLIPT_MIN_HASH_BUCKETS)\r\nreturn NULL;\r\nctbl = t4_alloc_mem(sizeof(*ctbl) +\r\nclipt_size*sizeof(struct list_head));\r\nif (!ctbl)\r\nreturn NULL;\r\nctbl->clipt_start = clipt_start;\r\nctbl->clipt_size = clipt_size;\r\nINIT_LIST_HEAD(&ctbl->ce_free_head);\r\natomic_set(&ctbl->nfree, clipt_size);\r\nrwlock_init(&ctbl->lock);\r\nfor (i = 0; i < ctbl->clipt_size; ++i)\r\nINIT_LIST_HEAD(&ctbl->hash_list[i]);\r\ncl_list = t4_alloc_mem(clipt_size*sizeof(struct clip_entry));\r\nctbl->cl_list = (void *)cl_list;\r\nfor (i = 0; i < clipt_size; i++) {\r\nINIT_LIST_HEAD(&cl_list[i].list);\r\nlist_add_tail(&cl_list[i].list, &ctbl->ce_free_head);\r\n}\r\nreturn ctbl;\r\n}\r\nvoid t4_cleanup_clip_tbl(struct adapter *adap)\r\n{\r\nstruct clip_tbl *ctbl = adap->clipt;\r\nif (ctbl) {\r\nif (ctbl->cl_list)\r\nt4_free_mem(ctbl->cl_list);\r\nt4_free_mem(ctbl);\r\n}\r\n}
