static inline struct tegra_plane *to_tegra_plane(struct drm_plane *plane)\r\n{\r\nreturn container_of(plane, struct tegra_plane, base);\r\n}\r\nstatic inline struct tegra_dc_state *to_dc_state(struct drm_crtc_state *state)\r\n{\r\nif (state)\r\nreturn container_of(state, struct tegra_dc_state, base);\r\nreturn NULL;\r\n}\r\nstatic inline struct tegra_plane_state *\r\nto_tegra_plane_state(struct drm_plane_state *state)\r\n{\r\nif (state)\r\nreturn container_of(state, struct tegra_plane_state, base);\r\nreturn NULL;\r\n}\r\nstatic u32 tegra_dc_readl_active(struct tegra_dc *dc, unsigned long offset)\r\n{\r\nunsigned long flags;\r\nu32 value;\r\nspin_lock_irqsave(&dc->lock, flags);\r\ntegra_dc_writel(dc, READ_MUX, DC_CMD_STATE_ACCESS);\r\nvalue = tegra_dc_readl(dc, offset);\r\ntegra_dc_writel(dc, 0, DC_CMD_STATE_ACCESS);\r\nspin_unlock_irqrestore(&dc->lock, flags);\r\nreturn value;\r\n}\r\nvoid tegra_dc_commit(struct tegra_dc *dc)\r\n{\r\ntegra_dc_writel(dc, GENERAL_ACT_REQ << 8, DC_CMD_STATE_CONTROL);\r\ntegra_dc_writel(dc, GENERAL_ACT_REQ, DC_CMD_STATE_CONTROL);\r\n}\r\nstatic int tegra_dc_format(u32 fourcc, u32 *format, u32 *swap)\r\n{\r\nif (swap)\r\n*swap = BYTE_SWAP_NOSWAP;\r\nswitch (fourcc) {\r\ncase DRM_FORMAT_XBGR8888:\r\n*format = WIN_COLOR_DEPTH_R8G8B8A8;\r\nbreak;\r\ncase DRM_FORMAT_XRGB8888:\r\n*format = WIN_COLOR_DEPTH_B8G8R8A8;\r\nbreak;\r\ncase DRM_FORMAT_RGB565:\r\n*format = WIN_COLOR_DEPTH_B5G6R5;\r\nbreak;\r\ncase DRM_FORMAT_UYVY:\r\n*format = WIN_COLOR_DEPTH_YCbCr422;\r\nbreak;\r\ncase DRM_FORMAT_YUYV:\r\nif (swap)\r\n*swap = BYTE_SWAP_SWAP2;\r\n*format = WIN_COLOR_DEPTH_YCbCr422;\r\nbreak;\r\ncase DRM_FORMAT_YUV420:\r\n*format = WIN_COLOR_DEPTH_YCbCr420P;\r\nbreak;\r\ncase DRM_FORMAT_YUV422:\r\n*format = WIN_COLOR_DEPTH_YCbCr422P;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool tegra_dc_format_is_yuv(unsigned int format, bool *planar)\r\n{\r\nswitch (format) {\r\ncase WIN_COLOR_DEPTH_YCbCr422:\r\ncase WIN_COLOR_DEPTH_YUV422:\r\nif (planar)\r\n*planar = false;\r\nreturn true;\r\ncase WIN_COLOR_DEPTH_YCbCr420P:\r\ncase WIN_COLOR_DEPTH_YUV420P:\r\ncase WIN_COLOR_DEPTH_YCbCr422P:\r\ncase WIN_COLOR_DEPTH_YUV422P:\r\ncase WIN_COLOR_DEPTH_YCbCr422R:\r\ncase WIN_COLOR_DEPTH_YUV422R:\r\ncase WIN_COLOR_DEPTH_YCbCr422RA:\r\ncase WIN_COLOR_DEPTH_YUV422RA:\r\nif (planar)\r\n*planar = true;\r\nreturn true;\r\n}\r\nif (planar)\r\n*planar = false;\r\nreturn false;\r\n}\r\nstatic inline u32 compute_dda_inc(unsigned int in, unsigned int out, bool v,\r\nunsigned int bpp)\r\n{\r\nfixed20_12 outf = dfixed_init(out);\r\nfixed20_12 inf = dfixed_init(in);\r\nu32 dda_inc;\r\nint max;\r\nif (v)\r\nmax = 15;\r\nelse {\r\nswitch (bpp) {\r\ncase 2:\r\nmax = 8;\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\ncase 4:\r\nmax = 4;\r\nbreak;\r\n}\r\n}\r\noutf.full = max_t(u32, outf.full - dfixed_const(1), dfixed_const(1));\r\ninf.full -= dfixed_const(1);\r\ndda_inc = dfixed_div(inf, outf);\r\ndda_inc = min_t(u32, dda_inc, dfixed_const(max));\r\nreturn dda_inc;\r\n}\r\nstatic inline u32 compute_initial_dda(unsigned int in)\r\n{\r\nfixed20_12 inf = dfixed_init(in);\r\nreturn dfixed_frac(inf);\r\n}\r\nstatic void tegra_dc_setup_window(struct tegra_dc *dc, unsigned int index,\r\nconst struct tegra_dc_window *window)\r\n{\r\nunsigned h_offset, v_offset, h_size, v_size, h_dda, v_dda, bpp;\r\nunsigned long value, flags;\r\nbool yuv, planar;\r\nyuv = tegra_dc_format_is_yuv(window->format, &planar);\r\nif (!yuv)\r\nbpp = window->bits_per_pixel / 8;\r\nelse\r\nbpp = planar ? 1 : 2;\r\nspin_lock_irqsave(&dc->lock, flags);\r\nvalue = WINDOW_A_SELECT << index;\r\ntegra_dc_writel(dc, value, DC_CMD_DISPLAY_WINDOW_HEADER);\r\ntegra_dc_writel(dc, window->format, DC_WIN_COLOR_DEPTH);\r\ntegra_dc_writel(dc, window->swap, DC_WIN_BYTE_SWAP);\r\nvalue = V_POSITION(window->dst.y) | H_POSITION(window->dst.x);\r\ntegra_dc_writel(dc, value, DC_WIN_POSITION);\r\nvalue = V_SIZE(window->dst.h) | H_SIZE(window->dst.w);\r\ntegra_dc_writel(dc, value, DC_WIN_SIZE);\r\nh_offset = window->src.x * bpp;\r\nv_offset = window->src.y;\r\nh_size = window->src.w * bpp;\r\nv_size = window->src.h;\r\nvalue = V_PRESCALED_SIZE(v_size) | H_PRESCALED_SIZE(h_size);\r\ntegra_dc_writel(dc, value, DC_WIN_PRESCALED_SIZE);\r\nif (yuv && planar)\r\nbpp = 2;\r\nh_dda = compute_dda_inc(window->src.w, window->dst.w, false, bpp);\r\nv_dda = compute_dda_inc(window->src.h, window->dst.h, true, bpp);\r\nvalue = V_DDA_INC(v_dda) | H_DDA_INC(h_dda);\r\ntegra_dc_writel(dc, value, DC_WIN_DDA_INC);\r\nh_dda = compute_initial_dda(window->src.x);\r\nv_dda = compute_initial_dda(window->src.y);\r\ntegra_dc_writel(dc, h_dda, DC_WIN_H_INITIAL_DDA);\r\ntegra_dc_writel(dc, v_dda, DC_WIN_V_INITIAL_DDA);\r\ntegra_dc_writel(dc, 0, DC_WIN_UV_BUF_STRIDE);\r\ntegra_dc_writel(dc, 0, DC_WIN_BUF_STRIDE);\r\ntegra_dc_writel(dc, window->base[0], DC_WINBUF_START_ADDR);\r\nif (yuv && planar) {\r\ntegra_dc_writel(dc, window->base[1], DC_WINBUF_START_ADDR_U);\r\ntegra_dc_writel(dc, window->base[2], DC_WINBUF_START_ADDR_V);\r\nvalue = window->stride[1] << 16 | window->stride[0];\r\ntegra_dc_writel(dc, value, DC_WIN_LINE_STRIDE);\r\n} else {\r\ntegra_dc_writel(dc, window->stride[0], DC_WIN_LINE_STRIDE);\r\n}\r\nif (window->bottom_up)\r\nv_offset += window->src.h - 1;\r\ntegra_dc_writel(dc, h_offset, DC_WINBUF_ADDR_H_OFFSET);\r\ntegra_dc_writel(dc, v_offset, DC_WINBUF_ADDR_V_OFFSET);\r\nif (dc->soc->supports_block_linear) {\r\nunsigned long height = window->tiling.value;\r\nswitch (window->tiling.mode) {\r\ncase TEGRA_BO_TILING_MODE_PITCH:\r\nvalue = DC_WINBUF_SURFACE_KIND_PITCH;\r\nbreak;\r\ncase TEGRA_BO_TILING_MODE_TILED:\r\nvalue = DC_WINBUF_SURFACE_KIND_TILED;\r\nbreak;\r\ncase TEGRA_BO_TILING_MODE_BLOCK:\r\nvalue = DC_WINBUF_SURFACE_KIND_BLOCK_HEIGHT(height) |\r\nDC_WINBUF_SURFACE_KIND_BLOCK;\r\nbreak;\r\n}\r\ntegra_dc_writel(dc, value, DC_WINBUF_SURFACE_KIND);\r\n} else {\r\nswitch (window->tiling.mode) {\r\ncase TEGRA_BO_TILING_MODE_PITCH:\r\nvalue = DC_WIN_BUFFER_ADDR_MODE_LINEAR_UV |\r\nDC_WIN_BUFFER_ADDR_MODE_LINEAR;\r\nbreak;\r\ncase TEGRA_BO_TILING_MODE_TILED:\r\nvalue = DC_WIN_BUFFER_ADDR_MODE_TILE_UV |\r\nDC_WIN_BUFFER_ADDR_MODE_TILE;\r\nbreak;\r\ncase TEGRA_BO_TILING_MODE_BLOCK:\r\nbreak;\r\n}\r\ntegra_dc_writel(dc, value, DC_WIN_BUFFER_ADDR_MODE);\r\n}\r\nvalue = WIN_ENABLE;\r\nif (yuv) {\r\ntegra_dc_writel(dc, 0x00f0, DC_WIN_CSC_YOF);\r\ntegra_dc_writel(dc, 0x012a, DC_WIN_CSC_KYRGB);\r\ntegra_dc_writel(dc, 0x0000, DC_WIN_CSC_KUR);\r\ntegra_dc_writel(dc, 0x0198, DC_WIN_CSC_KVR);\r\ntegra_dc_writel(dc, 0x039b, DC_WIN_CSC_KUG);\r\ntegra_dc_writel(dc, 0x032f, DC_WIN_CSC_KVG);\r\ntegra_dc_writel(dc, 0x0204, DC_WIN_CSC_KUB);\r\ntegra_dc_writel(dc, 0x0000, DC_WIN_CSC_KVB);\r\nvalue |= CSC_ENABLE;\r\n} else if (window->bits_per_pixel < 24) {\r\nvalue |= COLOR_EXPAND;\r\n}\r\nif (window->bottom_up)\r\nvalue |= V_DIRECTION;\r\ntegra_dc_writel(dc, value, DC_WIN_WIN_OPTIONS);\r\ntegra_dc_writel(dc, 0xffff00, DC_WIN_BLEND_NOKEY);\r\ntegra_dc_writel(dc, 0xffff00, DC_WIN_BLEND_1WIN);\r\nswitch (index) {\r\ncase 0:\r\ntegra_dc_writel(dc, 0x000000, DC_WIN_BLEND_2WIN_X);\r\ntegra_dc_writel(dc, 0x000000, DC_WIN_BLEND_2WIN_Y);\r\ntegra_dc_writel(dc, 0x000000, DC_WIN_BLEND_3WIN_XY);\r\nbreak;\r\ncase 1:\r\ntegra_dc_writel(dc, 0xffff00, DC_WIN_BLEND_2WIN_X);\r\ntegra_dc_writel(dc, 0x000000, DC_WIN_BLEND_2WIN_Y);\r\ntegra_dc_writel(dc, 0x000000, DC_WIN_BLEND_3WIN_XY);\r\nbreak;\r\ncase 2:\r\ntegra_dc_writel(dc, 0xffff00, DC_WIN_BLEND_2WIN_X);\r\ntegra_dc_writel(dc, 0xffff00, DC_WIN_BLEND_2WIN_Y);\r\ntegra_dc_writel(dc, 0xffff00, DC_WIN_BLEND_3WIN_XY);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&dc->lock, flags);\r\n}\r\nstatic void tegra_plane_destroy(struct drm_plane *plane)\r\n{\r\nstruct tegra_plane *p = to_tegra_plane(plane);\r\ndrm_plane_cleanup(plane);\r\nkfree(p);\r\n}\r\nstatic void tegra_primary_plane_destroy(struct drm_plane *plane)\r\n{\r\ntegra_plane_destroy(plane);\r\n}\r\nstatic void tegra_plane_reset(struct drm_plane *plane)\r\n{\r\nstruct tegra_plane_state *state;\r\nif (plane->state)\r\n__drm_atomic_helper_plane_destroy_state(plane, plane->state);\r\nkfree(plane->state);\r\nplane->state = NULL;\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (state) {\r\nplane->state = &state->base;\r\nplane->state->plane = plane;\r\n}\r\n}\r\nstatic struct drm_plane_state *tegra_plane_atomic_duplicate_state(struct drm_plane *plane)\r\n{\r\nstruct tegra_plane_state *state = to_tegra_plane_state(plane->state);\r\nstruct tegra_plane_state *copy;\r\ncopy = kmalloc(sizeof(*copy), GFP_KERNEL);\r\nif (!copy)\r\nreturn NULL;\r\n__drm_atomic_helper_plane_duplicate_state(plane, &copy->base);\r\ncopy->tiling = state->tiling;\r\ncopy->format = state->format;\r\ncopy->swap = state->swap;\r\nreturn &copy->base;\r\n}\r\nstatic void tegra_plane_atomic_destroy_state(struct drm_plane *plane,\r\nstruct drm_plane_state *state)\r\n{\r\n__drm_atomic_helper_plane_destroy_state(plane, state);\r\nkfree(state);\r\n}\r\nstatic int tegra_plane_prepare_fb(struct drm_plane *plane,\r\nstruct drm_framebuffer *fb,\r\nconst struct drm_plane_state *new_state)\r\n{\r\nreturn 0;\r\n}\r\nstatic void tegra_plane_cleanup_fb(struct drm_plane *plane,\r\nstruct drm_framebuffer *fb,\r\nconst struct drm_plane_state *old_fb)\r\n{\r\n}\r\nstatic int tegra_plane_state_add(struct tegra_plane *plane,\r\nstruct drm_plane_state *state)\r\n{\r\nstruct drm_crtc_state *crtc_state;\r\nstruct tegra_dc_state *tegra;\r\ncrtc_state = drm_atomic_get_crtc_state(state->state, state->crtc);\r\nif (IS_ERR(crtc_state))\r\nreturn PTR_ERR(crtc_state);\r\ntegra = to_dc_state(crtc_state);\r\ntegra->planes |= WIN_A_ACT_REQ << plane->index;\r\nreturn 0;\r\n}\r\nstatic int tegra_plane_atomic_check(struct drm_plane *plane,\r\nstruct drm_plane_state *state)\r\n{\r\nstruct tegra_plane_state *plane_state = to_tegra_plane_state(state);\r\nstruct tegra_bo_tiling *tiling = &plane_state->tiling;\r\nstruct tegra_plane *tegra = to_tegra_plane(plane);\r\nstruct tegra_dc *dc = to_tegra_dc(state->crtc);\r\nint err;\r\nif (!state->crtc)\r\nreturn 0;\r\nerr = tegra_dc_format(state->fb->pixel_format, &plane_state->format,\r\n&plane_state->swap);\r\nif (err < 0)\r\nreturn err;\r\nerr = tegra_fb_get_tiling(state->fb, tiling);\r\nif (err < 0)\r\nreturn err;\r\nif (tiling->mode == TEGRA_BO_TILING_MODE_BLOCK &&\r\n!dc->soc->supports_block_linear) {\r\nDRM_ERROR("hardware doesn't support block linear mode\n");\r\nreturn -EINVAL;\r\n}\r\nif (drm_format_num_planes(state->fb->pixel_format) > 2) {\r\nif (state->fb->pitches[2] != state->fb->pitches[1]) {\r\nDRM_ERROR("unsupported UV-plane configuration\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nerr = tegra_plane_state_add(tegra, state);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void tegra_plane_atomic_update(struct drm_plane *plane,\r\nstruct drm_plane_state *old_state)\r\n{\r\nstruct tegra_plane_state *state = to_tegra_plane_state(plane->state);\r\nstruct tegra_dc *dc = to_tegra_dc(plane->state->crtc);\r\nstruct drm_framebuffer *fb = plane->state->fb;\r\nstruct tegra_plane *p = to_tegra_plane(plane);\r\nstruct tegra_dc_window window;\r\nunsigned int i;\r\nif (!plane->state->crtc || !plane->state->fb)\r\nreturn;\r\nmemset(&window, 0, sizeof(window));\r\nwindow.src.x = plane->state->src_x >> 16;\r\nwindow.src.y = plane->state->src_y >> 16;\r\nwindow.src.w = plane->state->src_w >> 16;\r\nwindow.src.h = plane->state->src_h >> 16;\r\nwindow.dst.x = plane->state->crtc_x;\r\nwindow.dst.y = plane->state->crtc_y;\r\nwindow.dst.w = plane->state->crtc_w;\r\nwindow.dst.h = plane->state->crtc_h;\r\nwindow.bits_per_pixel = fb->bits_per_pixel;\r\nwindow.bottom_up = tegra_fb_is_bottom_up(fb);\r\nwindow.tiling = state->tiling;\r\nwindow.format = state->format;\r\nwindow.swap = state->swap;\r\nfor (i = 0; i < drm_format_num_planes(fb->pixel_format); i++) {\r\nstruct tegra_bo *bo = tegra_fb_get_plane(fb, i);\r\nwindow.base[i] = bo->paddr + fb->offsets[i];\r\nwindow.stride[i] = fb->pitches[i];\r\n}\r\ntegra_dc_setup_window(dc, p->index, &window);\r\n}\r\nstatic void tegra_plane_atomic_disable(struct drm_plane *plane,\r\nstruct drm_plane_state *old_state)\r\n{\r\nstruct tegra_plane *p = to_tegra_plane(plane);\r\nstruct tegra_dc *dc;\r\nunsigned long flags;\r\nu32 value;\r\nif (!old_state || !old_state->crtc)\r\nreturn;\r\ndc = to_tegra_dc(old_state->crtc);\r\nspin_lock_irqsave(&dc->lock, flags);\r\nvalue = WINDOW_A_SELECT << p->index;\r\ntegra_dc_writel(dc, value, DC_CMD_DISPLAY_WINDOW_HEADER);\r\nvalue = tegra_dc_readl(dc, DC_WIN_WIN_OPTIONS);\r\nvalue &= ~WIN_ENABLE;\r\ntegra_dc_writel(dc, value, DC_WIN_WIN_OPTIONS);\r\nspin_unlock_irqrestore(&dc->lock, flags);\r\n}\r\nstatic struct drm_plane *tegra_dc_primary_plane_create(struct drm_device *drm,\r\nstruct tegra_dc *dc)\r\n{\r\nunsigned long possible_crtcs = 1 << drm->mode_config.num_crtc;\r\nstruct tegra_plane *plane;\r\nunsigned int num_formats;\r\nconst u32 *formats;\r\nint err;\r\nplane = kzalloc(sizeof(*plane), GFP_KERNEL);\r\nif (!plane)\r\nreturn ERR_PTR(-ENOMEM);\r\nnum_formats = ARRAY_SIZE(tegra_primary_plane_formats);\r\nformats = tegra_primary_plane_formats;\r\nerr = drm_universal_plane_init(drm, &plane->base, possible_crtcs,\r\n&tegra_primary_plane_funcs, formats,\r\nnum_formats, DRM_PLANE_TYPE_PRIMARY);\r\nif (err < 0) {\r\nkfree(plane);\r\nreturn ERR_PTR(err);\r\n}\r\ndrm_plane_helper_add(&plane->base, &tegra_primary_plane_helper_funcs);\r\nreturn &plane->base;\r\n}\r\nstatic int tegra_cursor_atomic_check(struct drm_plane *plane,\r\nstruct drm_plane_state *state)\r\n{\r\nstruct tegra_plane *tegra = to_tegra_plane(plane);\r\nint err;\r\nif (!state->crtc)\r\nreturn 0;\r\nif ((state->src_w >> 16 != state->crtc_w) ||\r\n(state->src_h >> 16 != state->crtc_h))\r\nreturn -EINVAL;\r\nif (state->src_w != state->src_h)\r\nreturn -EINVAL;\r\nif (state->crtc_w != 32 && state->crtc_w != 64 &&\r\nstate->crtc_w != 128 && state->crtc_w != 256)\r\nreturn -EINVAL;\r\nerr = tegra_plane_state_add(tegra, state);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void tegra_cursor_atomic_update(struct drm_plane *plane,\r\nstruct drm_plane_state *old_state)\r\n{\r\nstruct tegra_bo *bo = tegra_fb_get_plane(plane->state->fb, 0);\r\nstruct tegra_dc *dc = to_tegra_dc(plane->state->crtc);\r\nstruct drm_plane_state *state = plane->state;\r\nu32 value = CURSOR_CLIP_DISPLAY;\r\nif (!plane->state->crtc || !plane->state->fb)\r\nreturn;\r\nswitch (state->crtc_w) {\r\ncase 32:\r\nvalue |= CURSOR_SIZE_32x32;\r\nbreak;\r\ncase 64:\r\nvalue |= CURSOR_SIZE_64x64;\r\nbreak;\r\ncase 128:\r\nvalue |= CURSOR_SIZE_128x128;\r\nbreak;\r\ncase 256:\r\nvalue |= CURSOR_SIZE_256x256;\r\nbreak;\r\ndefault:\r\nWARN(1, "cursor size %ux%u not supported\n", state->crtc_w,\r\nstate->crtc_h);\r\nreturn;\r\n}\r\nvalue |= (bo->paddr >> 10) & 0x3fffff;\r\ntegra_dc_writel(dc, value, DC_DISP_CURSOR_START_ADDR);\r\n#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT\r\nvalue = (bo->paddr >> 32) & 0x3;\r\ntegra_dc_writel(dc, value, DC_DISP_CURSOR_START_ADDR_HI);\r\n#endif\r\nvalue = tegra_dc_readl(dc, DC_DISP_DISP_WIN_OPTIONS);\r\nvalue |= CURSOR_ENABLE;\r\ntegra_dc_writel(dc, value, DC_DISP_DISP_WIN_OPTIONS);\r\nvalue = tegra_dc_readl(dc, DC_DISP_BLEND_CURSOR_CONTROL);\r\nvalue &= ~CURSOR_DST_BLEND_MASK;\r\nvalue &= ~CURSOR_SRC_BLEND_MASK;\r\nvalue |= CURSOR_MODE_NORMAL;\r\nvalue |= CURSOR_DST_BLEND_NEG_K1_TIMES_SRC;\r\nvalue |= CURSOR_SRC_BLEND_K1_TIMES_SRC;\r\nvalue |= CURSOR_ALPHA;\r\ntegra_dc_writel(dc, value, DC_DISP_BLEND_CURSOR_CONTROL);\r\nvalue = (state->crtc_y & 0x3fff) << 16 | (state->crtc_x & 0x3fff);\r\ntegra_dc_writel(dc, value, DC_DISP_CURSOR_POSITION);\r\n}\r\nstatic void tegra_cursor_atomic_disable(struct drm_plane *plane,\r\nstruct drm_plane_state *old_state)\r\n{\r\nstruct tegra_dc *dc;\r\nu32 value;\r\nif (!old_state || !old_state->crtc)\r\nreturn;\r\ndc = to_tegra_dc(old_state->crtc);\r\nvalue = tegra_dc_readl(dc, DC_DISP_DISP_WIN_OPTIONS);\r\nvalue &= ~CURSOR_ENABLE;\r\ntegra_dc_writel(dc, value, DC_DISP_DISP_WIN_OPTIONS);\r\n}\r\nstatic struct drm_plane *tegra_dc_cursor_plane_create(struct drm_device *drm,\r\nstruct tegra_dc *dc)\r\n{\r\nstruct tegra_plane *plane;\r\nunsigned int num_formats;\r\nconst u32 *formats;\r\nint err;\r\nplane = kzalloc(sizeof(*plane), GFP_KERNEL);\r\nif (!plane)\r\nreturn ERR_PTR(-ENOMEM);\r\nplane->index = 6;\r\nnum_formats = ARRAY_SIZE(tegra_cursor_plane_formats);\r\nformats = tegra_cursor_plane_formats;\r\nerr = drm_universal_plane_init(drm, &plane->base, 1 << dc->pipe,\r\n&tegra_cursor_plane_funcs, formats,\r\nnum_formats, DRM_PLANE_TYPE_CURSOR);\r\nif (err < 0) {\r\nkfree(plane);\r\nreturn ERR_PTR(err);\r\n}\r\ndrm_plane_helper_add(&plane->base, &tegra_cursor_plane_helper_funcs);\r\nreturn &plane->base;\r\n}\r\nstatic void tegra_overlay_plane_destroy(struct drm_plane *plane)\r\n{\r\ntegra_plane_destroy(plane);\r\n}\r\nstatic struct drm_plane *tegra_dc_overlay_plane_create(struct drm_device *drm,\r\nstruct tegra_dc *dc,\r\nunsigned int index)\r\n{\r\nstruct tegra_plane *plane;\r\nunsigned int num_formats;\r\nconst u32 *formats;\r\nint err;\r\nplane = kzalloc(sizeof(*plane), GFP_KERNEL);\r\nif (!plane)\r\nreturn ERR_PTR(-ENOMEM);\r\nplane->index = index;\r\nnum_formats = ARRAY_SIZE(tegra_overlay_plane_formats);\r\nformats = tegra_overlay_plane_formats;\r\nerr = drm_universal_plane_init(drm, &plane->base, 1 << dc->pipe,\r\n&tegra_overlay_plane_funcs, formats,\r\nnum_formats, DRM_PLANE_TYPE_OVERLAY);\r\nif (err < 0) {\r\nkfree(plane);\r\nreturn ERR_PTR(err);\r\n}\r\ndrm_plane_helper_add(&plane->base, &tegra_overlay_plane_helper_funcs);\r\nreturn &plane->base;\r\n}\r\nstatic int tegra_dc_add_planes(struct drm_device *drm, struct tegra_dc *dc)\r\n{\r\nstruct drm_plane *plane;\r\nunsigned int i;\r\nfor (i = 0; i < 2; i++) {\r\nplane = tegra_dc_overlay_plane_create(drm, dc, 1 + i);\r\nif (IS_ERR(plane))\r\nreturn PTR_ERR(plane);\r\n}\r\nreturn 0;\r\n}\r\nu32 tegra_dc_get_vblank_counter(struct tegra_dc *dc)\r\n{\r\nif (dc->syncpt)\r\nreturn host1x_syncpt_read(dc->syncpt);\r\nreturn drm_crtc_vblank_count(&dc->base);\r\n}\r\nvoid tegra_dc_enable_vblank(struct tegra_dc *dc)\r\n{\r\nunsigned long value, flags;\r\nspin_lock_irqsave(&dc->lock, flags);\r\nvalue = tegra_dc_readl(dc, DC_CMD_INT_MASK);\r\nvalue |= VBLANK_INT;\r\ntegra_dc_writel(dc, value, DC_CMD_INT_MASK);\r\nspin_unlock_irqrestore(&dc->lock, flags);\r\n}\r\nvoid tegra_dc_disable_vblank(struct tegra_dc *dc)\r\n{\r\nunsigned long value, flags;\r\nspin_lock_irqsave(&dc->lock, flags);\r\nvalue = tegra_dc_readl(dc, DC_CMD_INT_MASK);\r\nvalue &= ~VBLANK_INT;\r\ntegra_dc_writel(dc, value, DC_CMD_INT_MASK);\r\nspin_unlock_irqrestore(&dc->lock, flags);\r\n}\r\nstatic void tegra_dc_finish_page_flip(struct tegra_dc *dc)\r\n{\r\nstruct drm_device *drm = dc->base.dev;\r\nstruct drm_crtc *crtc = &dc->base;\r\nunsigned long flags, base;\r\nstruct tegra_bo *bo;\r\nspin_lock_irqsave(&drm->event_lock, flags);\r\nif (!dc->event) {\r\nspin_unlock_irqrestore(&drm->event_lock, flags);\r\nreturn;\r\n}\r\nbo = tegra_fb_get_plane(crtc->primary->fb, 0);\r\nspin_lock(&dc->lock);\r\ntegra_dc_writel(dc, WINDOW_A_SELECT, DC_CMD_DISPLAY_WINDOW_HEADER);\r\ntegra_dc_writel(dc, READ_MUX, DC_CMD_STATE_ACCESS);\r\nbase = tegra_dc_readl(dc, DC_WINBUF_START_ADDR);\r\ntegra_dc_writel(dc, 0, DC_CMD_STATE_ACCESS);\r\nspin_unlock(&dc->lock);\r\nif (base == bo->paddr + crtc->primary->fb->offsets[0]) {\r\ndrm_crtc_send_vblank_event(crtc, dc->event);\r\ndrm_crtc_vblank_put(crtc);\r\ndc->event = NULL;\r\n}\r\nspin_unlock_irqrestore(&drm->event_lock, flags);\r\n}\r\nvoid tegra_dc_cancel_page_flip(struct drm_crtc *crtc, struct drm_file *file)\r\n{\r\nstruct tegra_dc *dc = to_tegra_dc(crtc);\r\nstruct drm_device *drm = crtc->dev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&drm->event_lock, flags);\r\nif (dc->event && dc->event->base.file_priv == file) {\r\ndc->event->base.destroy(&dc->event->base);\r\ndrm_crtc_vblank_put(crtc);\r\ndc->event = NULL;\r\n}\r\nspin_unlock_irqrestore(&drm->event_lock, flags);\r\n}\r\nstatic void tegra_dc_destroy(struct drm_crtc *crtc)\r\n{\r\ndrm_crtc_cleanup(crtc);\r\n}\r\nstatic void tegra_crtc_reset(struct drm_crtc *crtc)\r\n{\r\nstruct tegra_dc_state *state;\r\nif (crtc->state)\r\n__drm_atomic_helper_crtc_destroy_state(crtc, crtc->state);\r\nkfree(crtc->state);\r\ncrtc->state = NULL;\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (state) {\r\ncrtc->state = &state->base;\r\ncrtc->state->crtc = crtc;\r\n}\r\n}\r\nstatic struct drm_crtc_state *\r\ntegra_crtc_atomic_duplicate_state(struct drm_crtc *crtc)\r\n{\r\nstruct tegra_dc_state *state = to_dc_state(crtc->state);\r\nstruct tegra_dc_state *copy;\r\ncopy = kmalloc(sizeof(*copy), GFP_KERNEL);\r\nif (!copy)\r\nreturn NULL;\r\n__drm_atomic_helper_crtc_duplicate_state(crtc, &copy->base);\r\ncopy->clk = state->clk;\r\ncopy->pclk = state->pclk;\r\ncopy->div = state->div;\r\ncopy->planes = state->planes;\r\nreturn &copy->base;\r\n}\r\nstatic void tegra_crtc_atomic_destroy_state(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *state)\r\n{\r\n__drm_atomic_helper_crtc_destroy_state(crtc, state);\r\nkfree(state);\r\n}\r\nstatic void tegra_dc_stop(struct tegra_dc *dc)\r\n{\r\nu32 value;\r\nvalue = tegra_dc_readl(dc, DC_CMD_DISPLAY_COMMAND);\r\nvalue &= ~DISP_CTRL_MODE_MASK;\r\ntegra_dc_writel(dc, value, DC_CMD_DISPLAY_COMMAND);\r\ntegra_dc_commit(dc);\r\n}\r\nstatic bool tegra_dc_idle(struct tegra_dc *dc)\r\n{\r\nu32 value;\r\nvalue = tegra_dc_readl_active(dc, DC_CMD_DISPLAY_COMMAND);\r\nreturn (value & DISP_CTRL_MODE_MASK) == 0;\r\n}\r\nstatic int tegra_dc_wait_idle(struct tegra_dc *dc, unsigned long timeout)\r\n{\r\ntimeout = jiffies + msecs_to_jiffies(timeout);\r\nwhile (time_before(jiffies, timeout)) {\r\nif (tegra_dc_idle(dc))\r\nreturn 0;\r\nusleep_range(1000, 2000);\r\n}\r\ndev_dbg(dc->dev, "timeout waiting for DC to become idle\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void tegra_crtc_disable(struct drm_crtc *crtc)\r\n{\r\nstruct tegra_dc *dc = to_tegra_dc(crtc);\r\nu32 value;\r\nif (!tegra_dc_idle(dc)) {\r\ntegra_dc_stop(dc);\r\ntegra_dc_wait_idle(dc, 100);\r\n}\r\nif (dc->rgb) {\r\nvalue = tegra_dc_readl(dc, DC_CMD_DISPLAY_POWER_CONTROL);\r\nvalue &= ~(PW0_ENABLE | PW1_ENABLE | PW2_ENABLE | PW3_ENABLE |\r\nPW4_ENABLE | PM0_ENABLE | PM1_ENABLE);\r\ntegra_dc_writel(dc, value, DC_CMD_DISPLAY_POWER_CONTROL);\r\n}\r\ndrm_crtc_vblank_off(crtc);\r\n}\r\nstatic bool tegra_crtc_mode_fixup(struct drm_crtc *crtc,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted)\r\n{\r\nreturn true;\r\n}\r\nstatic int tegra_dc_set_timings(struct tegra_dc *dc,\r\nstruct drm_display_mode *mode)\r\n{\r\nunsigned int h_ref_to_sync = 1;\r\nunsigned int v_ref_to_sync = 1;\r\nunsigned long value;\r\ntegra_dc_writel(dc, 0x0, DC_DISP_DISP_TIMING_OPTIONS);\r\nvalue = (v_ref_to_sync << 16) | h_ref_to_sync;\r\ntegra_dc_writel(dc, value, DC_DISP_REF_TO_SYNC);\r\nvalue = ((mode->vsync_end - mode->vsync_start) << 16) |\r\n((mode->hsync_end - mode->hsync_start) << 0);\r\ntegra_dc_writel(dc, value, DC_DISP_SYNC_WIDTH);\r\nvalue = ((mode->vtotal - mode->vsync_end) << 16) |\r\n((mode->htotal - mode->hsync_end) << 0);\r\ntegra_dc_writel(dc, value, DC_DISP_BACK_PORCH);\r\nvalue = ((mode->vsync_start - mode->vdisplay) << 16) |\r\n((mode->hsync_start - mode->hdisplay) << 0);\r\ntegra_dc_writel(dc, value, DC_DISP_FRONT_PORCH);\r\nvalue = (mode->vdisplay << 16) | mode->hdisplay;\r\ntegra_dc_writel(dc, value, DC_DISP_ACTIVE);\r\nreturn 0;\r\n}\r\nint tegra_dc_state_setup_clock(struct tegra_dc *dc,\r\nstruct drm_crtc_state *crtc_state,\r\nstruct clk *clk, unsigned long pclk,\r\nunsigned int div)\r\n{\r\nstruct tegra_dc_state *state = to_dc_state(crtc_state);\r\nif (!clk_has_parent(dc->clk, clk))\r\nreturn -EINVAL;\r\nstate->clk = clk;\r\nstate->pclk = pclk;\r\nstate->div = div;\r\nreturn 0;\r\n}\r\nstatic void tegra_dc_commit_state(struct tegra_dc *dc,\r\nstruct tegra_dc_state *state)\r\n{\r\nu32 value;\r\nint err;\r\nerr = clk_set_parent(dc->clk, state->clk);\r\nif (err < 0)\r\ndev_err(dc->dev, "failed to set parent clock: %d\n", err);\r\nif (state->pclk > 0) {\r\nerr = clk_set_rate(state->clk, state->pclk);\r\nif (err < 0)\r\ndev_err(dc->dev,\r\n"failed to set clock rate to %lu Hz\n",\r\nstate->pclk);\r\n}\r\nDRM_DEBUG_KMS("rate: %lu, div: %u\n", clk_get_rate(dc->clk),\r\nstate->div);\r\nDRM_DEBUG_KMS("pclk: %lu\n", state->pclk);\r\nvalue = SHIFT_CLK_DIVIDER(state->div) | PIXEL_CLK_DIVIDER_PCD1;\r\ntegra_dc_writel(dc, value, DC_DISP_DISP_CLOCK_CONTROL);\r\n}\r\nstatic void tegra_crtc_mode_set_nofb(struct drm_crtc *crtc)\r\n{\r\nstruct drm_display_mode *mode = &crtc->state->adjusted_mode;\r\nstruct tegra_dc_state *state = to_dc_state(crtc->state);\r\nstruct tegra_dc *dc = to_tegra_dc(crtc);\r\nu32 value;\r\ntegra_dc_commit_state(dc, state);\r\ntegra_dc_set_timings(dc, mode);\r\nif (dc->soc->supports_interlacing) {\r\nvalue = tegra_dc_readl(dc, DC_DISP_INTERLACE_CONTROL);\r\nvalue &= ~INTERLACE_ENABLE;\r\ntegra_dc_writel(dc, value, DC_DISP_INTERLACE_CONTROL);\r\n}\r\nvalue = tegra_dc_readl(dc, DC_CMD_DISPLAY_COMMAND);\r\nvalue &= ~DISP_CTRL_MODE_MASK;\r\nvalue |= DISP_CTRL_MODE_C_DISPLAY;\r\ntegra_dc_writel(dc, value, DC_CMD_DISPLAY_COMMAND);\r\nvalue = tegra_dc_readl(dc, DC_CMD_DISPLAY_POWER_CONTROL);\r\nvalue |= PW0_ENABLE | PW1_ENABLE | PW2_ENABLE | PW3_ENABLE |\r\nPW4_ENABLE | PM0_ENABLE | PM1_ENABLE;\r\ntegra_dc_writel(dc, value, DC_CMD_DISPLAY_POWER_CONTROL);\r\ntegra_dc_commit(dc);\r\n}\r\nstatic void tegra_crtc_prepare(struct drm_crtc *crtc)\r\n{\r\ndrm_crtc_vblank_off(crtc);\r\n}\r\nstatic void tegra_crtc_commit(struct drm_crtc *crtc)\r\n{\r\ndrm_crtc_vblank_on(crtc);\r\n}\r\nstatic int tegra_crtc_atomic_check(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *state)\r\n{\r\nreturn 0;\r\n}\r\nstatic void tegra_crtc_atomic_begin(struct drm_crtc *crtc)\r\n{\r\nstruct tegra_dc *dc = to_tegra_dc(crtc);\r\nif (crtc->state->event) {\r\ncrtc->state->event->pipe = drm_crtc_index(crtc);\r\nWARN_ON(drm_crtc_vblank_get(crtc) != 0);\r\ndc->event = crtc->state->event;\r\ncrtc->state->event = NULL;\r\n}\r\n}\r\nstatic void tegra_crtc_atomic_flush(struct drm_crtc *crtc)\r\n{\r\nstruct tegra_dc_state *state = to_dc_state(crtc->state);\r\nstruct tegra_dc *dc = to_tegra_dc(crtc);\r\ntegra_dc_writel(dc, state->planes << 8, DC_CMD_STATE_CONTROL);\r\ntegra_dc_writel(dc, state->planes, DC_CMD_STATE_CONTROL);\r\n}\r\nstatic irqreturn_t tegra_dc_irq(int irq, void *data)\r\n{\r\nstruct tegra_dc *dc = data;\r\nunsigned long status;\r\nstatus = tegra_dc_readl(dc, DC_CMD_INT_STATUS);\r\ntegra_dc_writel(dc, status, DC_CMD_INT_STATUS);\r\nif (status & FRAME_END_INT) {\r\n}\r\nif (status & VBLANK_INT) {\r\ndrm_crtc_handle_vblank(&dc->base);\r\ntegra_dc_finish_page_flip(dc);\r\n}\r\nif (status & (WIN_A_UF_INT | WIN_B_UF_INT | WIN_C_UF_INT)) {\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int tegra_dc_show_regs(struct seq_file *s, void *data)\r\n{\r\nstruct drm_info_node *node = s->private;\r\nstruct tegra_dc *dc = node->info_ent->data;\r\n#define DUMP_REG(name) \\r\nseq_printf(s, "%-40s %#05x %08x\n", #name, name, \\r\ntegra_dc_readl(dc, name))\r\nDUMP_REG(DC_CMD_GENERAL_INCR_SYNCPT);\r\nDUMP_REG(DC_CMD_GENERAL_INCR_SYNCPT_CNTRL);\r\nDUMP_REG(DC_CMD_GENERAL_INCR_SYNCPT_ERROR);\r\nDUMP_REG(DC_CMD_WIN_A_INCR_SYNCPT);\r\nDUMP_REG(DC_CMD_WIN_A_INCR_SYNCPT_CNTRL);\r\nDUMP_REG(DC_CMD_WIN_A_INCR_SYNCPT_ERROR);\r\nDUMP_REG(DC_CMD_WIN_B_INCR_SYNCPT);\r\nDUMP_REG(DC_CMD_WIN_B_INCR_SYNCPT_CNTRL);\r\nDUMP_REG(DC_CMD_WIN_B_INCR_SYNCPT_ERROR);\r\nDUMP_REG(DC_CMD_WIN_C_INCR_SYNCPT);\r\nDUMP_REG(DC_CMD_WIN_C_INCR_SYNCPT_CNTRL);\r\nDUMP_REG(DC_CMD_WIN_C_INCR_SYNCPT_ERROR);\r\nDUMP_REG(DC_CMD_CONT_SYNCPT_VSYNC);\r\nDUMP_REG(DC_CMD_DISPLAY_COMMAND_OPTION0);\r\nDUMP_REG(DC_CMD_DISPLAY_COMMAND);\r\nDUMP_REG(DC_CMD_SIGNAL_RAISE);\r\nDUMP_REG(DC_CMD_DISPLAY_POWER_CONTROL);\r\nDUMP_REG(DC_CMD_INT_STATUS);\r\nDUMP_REG(DC_CMD_INT_MASK);\r\nDUMP_REG(DC_CMD_INT_ENABLE);\r\nDUMP_REG(DC_CMD_INT_TYPE);\r\nDUMP_REG(DC_CMD_INT_POLARITY);\r\nDUMP_REG(DC_CMD_SIGNAL_RAISE1);\r\nDUMP_REG(DC_CMD_SIGNAL_RAISE2);\r\nDUMP_REG(DC_CMD_SIGNAL_RAISE3);\r\nDUMP_REG(DC_CMD_STATE_ACCESS);\r\nDUMP_REG(DC_CMD_STATE_CONTROL);\r\nDUMP_REG(DC_CMD_DISPLAY_WINDOW_HEADER);\r\nDUMP_REG(DC_CMD_REG_ACT_CONTROL);\r\nDUMP_REG(DC_COM_CRC_CONTROL);\r\nDUMP_REG(DC_COM_CRC_CHECKSUM);\r\nDUMP_REG(DC_COM_PIN_OUTPUT_ENABLE(0));\r\nDUMP_REG(DC_COM_PIN_OUTPUT_ENABLE(1));\r\nDUMP_REG(DC_COM_PIN_OUTPUT_ENABLE(2));\r\nDUMP_REG(DC_COM_PIN_OUTPUT_ENABLE(3));\r\nDUMP_REG(DC_COM_PIN_OUTPUT_POLARITY(0));\r\nDUMP_REG(DC_COM_PIN_OUTPUT_POLARITY(1));\r\nDUMP_REG(DC_COM_PIN_OUTPUT_POLARITY(2));\r\nDUMP_REG(DC_COM_PIN_OUTPUT_POLARITY(3));\r\nDUMP_REG(DC_COM_PIN_OUTPUT_DATA(0));\r\nDUMP_REG(DC_COM_PIN_OUTPUT_DATA(1));\r\nDUMP_REG(DC_COM_PIN_OUTPUT_DATA(2));\r\nDUMP_REG(DC_COM_PIN_OUTPUT_DATA(3));\r\nDUMP_REG(DC_COM_PIN_INPUT_ENABLE(0));\r\nDUMP_REG(DC_COM_PIN_INPUT_ENABLE(1));\r\nDUMP_REG(DC_COM_PIN_INPUT_ENABLE(2));\r\nDUMP_REG(DC_COM_PIN_INPUT_ENABLE(3));\r\nDUMP_REG(DC_COM_PIN_INPUT_DATA(0));\r\nDUMP_REG(DC_COM_PIN_INPUT_DATA(1));\r\nDUMP_REG(DC_COM_PIN_OUTPUT_SELECT(0));\r\nDUMP_REG(DC_COM_PIN_OUTPUT_SELECT(1));\r\nDUMP_REG(DC_COM_PIN_OUTPUT_SELECT(2));\r\nDUMP_REG(DC_COM_PIN_OUTPUT_SELECT(3));\r\nDUMP_REG(DC_COM_PIN_OUTPUT_SELECT(4));\r\nDUMP_REG(DC_COM_PIN_OUTPUT_SELECT(5));\r\nDUMP_REG(DC_COM_PIN_OUTPUT_SELECT(6));\r\nDUMP_REG(DC_COM_PIN_MISC_CONTROL);\r\nDUMP_REG(DC_COM_PIN_PM0_CONTROL);\r\nDUMP_REG(DC_COM_PIN_PM0_DUTY_CYCLE);\r\nDUMP_REG(DC_COM_PIN_PM1_CONTROL);\r\nDUMP_REG(DC_COM_PIN_PM1_DUTY_CYCLE);\r\nDUMP_REG(DC_COM_SPI_CONTROL);\r\nDUMP_REG(DC_COM_SPI_START_BYTE);\r\nDUMP_REG(DC_COM_HSPI_WRITE_DATA_AB);\r\nDUMP_REG(DC_COM_HSPI_WRITE_DATA_CD);\r\nDUMP_REG(DC_COM_HSPI_CS_DC);\r\nDUMP_REG(DC_COM_SCRATCH_REGISTER_A);\r\nDUMP_REG(DC_COM_SCRATCH_REGISTER_B);\r\nDUMP_REG(DC_COM_GPIO_CTRL);\r\nDUMP_REG(DC_COM_GPIO_DEBOUNCE_COUNTER);\r\nDUMP_REG(DC_COM_CRC_CHECKSUM_LATCHED);\r\nDUMP_REG(DC_DISP_DISP_SIGNAL_OPTIONS0);\r\nDUMP_REG(DC_DISP_DISP_SIGNAL_OPTIONS1);\r\nDUMP_REG(DC_DISP_DISP_WIN_OPTIONS);\r\nDUMP_REG(DC_DISP_DISP_MEM_HIGH_PRIORITY);\r\nDUMP_REG(DC_DISP_DISP_MEM_HIGH_PRIORITY_TIMER);\r\nDUMP_REG(DC_DISP_DISP_TIMING_OPTIONS);\r\nDUMP_REG(DC_DISP_REF_TO_SYNC);\r\nDUMP_REG(DC_DISP_SYNC_WIDTH);\r\nDUMP_REG(DC_DISP_BACK_PORCH);\r\nDUMP_REG(DC_DISP_ACTIVE);\r\nDUMP_REG(DC_DISP_FRONT_PORCH);\r\nDUMP_REG(DC_DISP_H_PULSE0_CONTROL);\r\nDUMP_REG(DC_DISP_H_PULSE0_POSITION_A);\r\nDUMP_REG(DC_DISP_H_PULSE0_POSITION_B);\r\nDUMP_REG(DC_DISP_H_PULSE0_POSITION_C);\r\nDUMP_REG(DC_DISP_H_PULSE0_POSITION_D);\r\nDUMP_REG(DC_DISP_H_PULSE1_CONTROL);\r\nDUMP_REG(DC_DISP_H_PULSE1_POSITION_A);\r\nDUMP_REG(DC_DISP_H_PULSE1_POSITION_B);\r\nDUMP_REG(DC_DISP_H_PULSE1_POSITION_C);\r\nDUMP_REG(DC_DISP_H_PULSE1_POSITION_D);\r\nDUMP_REG(DC_DISP_H_PULSE2_CONTROL);\r\nDUMP_REG(DC_DISP_H_PULSE2_POSITION_A);\r\nDUMP_REG(DC_DISP_H_PULSE2_POSITION_B);\r\nDUMP_REG(DC_DISP_H_PULSE2_POSITION_C);\r\nDUMP_REG(DC_DISP_H_PULSE2_POSITION_D);\r\nDUMP_REG(DC_DISP_V_PULSE0_CONTROL);\r\nDUMP_REG(DC_DISP_V_PULSE0_POSITION_A);\r\nDUMP_REG(DC_DISP_V_PULSE0_POSITION_B);\r\nDUMP_REG(DC_DISP_V_PULSE0_POSITION_C);\r\nDUMP_REG(DC_DISP_V_PULSE1_CONTROL);\r\nDUMP_REG(DC_DISP_V_PULSE1_POSITION_A);\r\nDUMP_REG(DC_DISP_V_PULSE1_POSITION_B);\r\nDUMP_REG(DC_DISP_V_PULSE1_POSITION_C);\r\nDUMP_REG(DC_DISP_V_PULSE2_CONTROL);\r\nDUMP_REG(DC_DISP_V_PULSE2_POSITION_A);\r\nDUMP_REG(DC_DISP_V_PULSE3_CONTROL);\r\nDUMP_REG(DC_DISP_V_PULSE3_POSITION_A);\r\nDUMP_REG(DC_DISP_M0_CONTROL);\r\nDUMP_REG(DC_DISP_M1_CONTROL);\r\nDUMP_REG(DC_DISP_DI_CONTROL);\r\nDUMP_REG(DC_DISP_PP_CONTROL);\r\nDUMP_REG(DC_DISP_PP_SELECT_A);\r\nDUMP_REG(DC_DISP_PP_SELECT_B);\r\nDUMP_REG(DC_DISP_PP_SELECT_C);\r\nDUMP_REG(DC_DISP_PP_SELECT_D);\r\nDUMP_REG(DC_DISP_DISP_CLOCK_CONTROL);\r\nDUMP_REG(DC_DISP_DISP_INTERFACE_CONTROL);\r\nDUMP_REG(DC_DISP_DISP_COLOR_CONTROL);\r\nDUMP_REG(DC_DISP_SHIFT_CLOCK_OPTIONS);\r\nDUMP_REG(DC_DISP_DATA_ENABLE_OPTIONS);\r\nDUMP_REG(DC_DISP_SERIAL_INTERFACE_OPTIONS);\r\nDUMP_REG(DC_DISP_LCD_SPI_OPTIONS);\r\nDUMP_REG(DC_DISP_BORDER_COLOR);\r\nDUMP_REG(DC_DISP_COLOR_KEY0_LOWER);\r\nDUMP_REG(DC_DISP_COLOR_KEY0_UPPER);\r\nDUMP_REG(DC_DISP_COLOR_KEY1_LOWER);\r\nDUMP_REG(DC_DISP_COLOR_KEY1_UPPER);\r\nDUMP_REG(DC_DISP_CURSOR_FOREGROUND);\r\nDUMP_REG(DC_DISP_CURSOR_BACKGROUND);\r\nDUMP_REG(DC_DISP_CURSOR_START_ADDR);\r\nDUMP_REG(DC_DISP_CURSOR_START_ADDR_NS);\r\nDUMP_REG(DC_DISP_CURSOR_POSITION);\r\nDUMP_REG(DC_DISP_CURSOR_POSITION_NS);\r\nDUMP_REG(DC_DISP_INIT_SEQ_CONTROL);\r\nDUMP_REG(DC_DISP_SPI_INIT_SEQ_DATA_A);\r\nDUMP_REG(DC_DISP_SPI_INIT_SEQ_DATA_B);\r\nDUMP_REG(DC_DISP_SPI_INIT_SEQ_DATA_C);\r\nDUMP_REG(DC_DISP_SPI_INIT_SEQ_DATA_D);\r\nDUMP_REG(DC_DISP_DC_MCCIF_FIFOCTRL);\r\nDUMP_REG(DC_DISP_MCCIF_DISPLAY0A_HYST);\r\nDUMP_REG(DC_DISP_MCCIF_DISPLAY0B_HYST);\r\nDUMP_REG(DC_DISP_MCCIF_DISPLAY1A_HYST);\r\nDUMP_REG(DC_DISP_MCCIF_DISPLAY1B_HYST);\r\nDUMP_REG(DC_DISP_DAC_CRT_CTRL);\r\nDUMP_REG(DC_DISP_DISP_MISC_CONTROL);\r\nDUMP_REG(DC_DISP_SD_CONTROL);\r\nDUMP_REG(DC_DISP_SD_CSC_COEFF);\r\nDUMP_REG(DC_DISP_SD_LUT(0));\r\nDUMP_REG(DC_DISP_SD_LUT(1));\r\nDUMP_REG(DC_DISP_SD_LUT(2));\r\nDUMP_REG(DC_DISP_SD_LUT(3));\r\nDUMP_REG(DC_DISP_SD_LUT(4));\r\nDUMP_REG(DC_DISP_SD_LUT(5));\r\nDUMP_REG(DC_DISP_SD_LUT(6));\r\nDUMP_REG(DC_DISP_SD_LUT(7));\r\nDUMP_REG(DC_DISP_SD_LUT(8));\r\nDUMP_REG(DC_DISP_SD_FLICKER_CONTROL);\r\nDUMP_REG(DC_DISP_DC_PIXEL_COUNT);\r\nDUMP_REG(DC_DISP_SD_HISTOGRAM(0));\r\nDUMP_REG(DC_DISP_SD_HISTOGRAM(1));\r\nDUMP_REG(DC_DISP_SD_HISTOGRAM(2));\r\nDUMP_REG(DC_DISP_SD_HISTOGRAM(3));\r\nDUMP_REG(DC_DISP_SD_HISTOGRAM(4));\r\nDUMP_REG(DC_DISP_SD_HISTOGRAM(5));\r\nDUMP_REG(DC_DISP_SD_HISTOGRAM(6));\r\nDUMP_REG(DC_DISP_SD_HISTOGRAM(7));\r\nDUMP_REG(DC_DISP_SD_BL_TF(0));\r\nDUMP_REG(DC_DISP_SD_BL_TF(1));\r\nDUMP_REG(DC_DISP_SD_BL_TF(2));\r\nDUMP_REG(DC_DISP_SD_BL_TF(3));\r\nDUMP_REG(DC_DISP_SD_BL_CONTROL);\r\nDUMP_REG(DC_DISP_SD_HW_K_VALUES);\r\nDUMP_REG(DC_DISP_SD_MAN_K_VALUES);\r\nDUMP_REG(DC_DISP_CURSOR_START_ADDR_HI);\r\nDUMP_REG(DC_DISP_BLEND_CURSOR_CONTROL);\r\nDUMP_REG(DC_WIN_WIN_OPTIONS);\r\nDUMP_REG(DC_WIN_BYTE_SWAP);\r\nDUMP_REG(DC_WIN_BUFFER_CONTROL);\r\nDUMP_REG(DC_WIN_COLOR_DEPTH);\r\nDUMP_REG(DC_WIN_POSITION);\r\nDUMP_REG(DC_WIN_SIZE);\r\nDUMP_REG(DC_WIN_PRESCALED_SIZE);\r\nDUMP_REG(DC_WIN_H_INITIAL_DDA);\r\nDUMP_REG(DC_WIN_V_INITIAL_DDA);\r\nDUMP_REG(DC_WIN_DDA_INC);\r\nDUMP_REG(DC_WIN_LINE_STRIDE);\r\nDUMP_REG(DC_WIN_BUF_STRIDE);\r\nDUMP_REG(DC_WIN_UV_BUF_STRIDE);\r\nDUMP_REG(DC_WIN_BUFFER_ADDR_MODE);\r\nDUMP_REG(DC_WIN_DV_CONTROL);\r\nDUMP_REG(DC_WIN_BLEND_NOKEY);\r\nDUMP_REG(DC_WIN_BLEND_1WIN);\r\nDUMP_REG(DC_WIN_BLEND_2WIN_X);\r\nDUMP_REG(DC_WIN_BLEND_2WIN_Y);\r\nDUMP_REG(DC_WIN_BLEND_3WIN_XY);\r\nDUMP_REG(DC_WIN_HP_FETCH_CONTROL);\r\nDUMP_REG(DC_WINBUF_START_ADDR);\r\nDUMP_REG(DC_WINBUF_START_ADDR_NS);\r\nDUMP_REG(DC_WINBUF_START_ADDR_U);\r\nDUMP_REG(DC_WINBUF_START_ADDR_U_NS);\r\nDUMP_REG(DC_WINBUF_START_ADDR_V);\r\nDUMP_REG(DC_WINBUF_START_ADDR_V_NS);\r\nDUMP_REG(DC_WINBUF_ADDR_H_OFFSET);\r\nDUMP_REG(DC_WINBUF_ADDR_H_OFFSET_NS);\r\nDUMP_REG(DC_WINBUF_ADDR_V_OFFSET);\r\nDUMP_REG(DC_WINBUF_ADDR_V_OFFSET_NS);\r\nDUMP_REG(DC_WINBUF_UFLOW_STATUS);\r\nDUMP_REG(DC_WINBUF_AD_UFLOW_STATUS);\r\nDUMP_REG(DC_WINBUF_BD_UFLOW_STATUS);\r\nDUMP_REG(DC_WINBUF_CD_UFLOW_STATUS);\r\n#undef DUMP_REG\r\nreturn 0;\r\n}\r\nstatic int tegra_dc_debugfs_init(struct tegra_dc *dc, struct drm_minor *minor)\r\n{\r\nunsigned int i;\r\nchar *name;\r\nint err;\r\nname = kasprintf(GFP_KERNEL, "dc.%d", dc->pipe);\r\ndc->debugfs = debugfs_create_dir(name, minor->debugfs_root);\r\nkfree(name);\r\nif (!dc->debugfs)\r\nreturn -ENOMEM;\r\ndc->debugfs_files = kmemdup(debugfs_files, sizeof(debugfs_files),\r\nGFP_KERNEL);\r\nif (!dc->debugfs_files) {\r\nerr = -ENOMEM;\r\ngoto remove;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(debugfs_files); i++)\r\ndc->debugfs_files[i].data = dc;\r\nerr = drm_debugfs_create_files(dc->debugfs_files,\r\nARRAY_SIZE(debugfs_files),\r\ndc->debugfs, minor);\r\nif (err < 0)\r\ngoto free;\r\ndc->minor = minor;\r\nreturn 0;\r\nfree:\r\nkfree(dc->debugfs_files);\r\ndc->debugfs_files = NULL;\r\nremove:\r\ndebugfs_remove(dc->debugfs);\r\ndc->debugfs = NULL;\r\nreturn err;\r\n}\r\nstatic int tegra_dc_debugfs_exit(struct tegra_dc *dc)\r\n{\r\ndrm_debugfs_remove_files(dc->debugfs_files, ARRAY_SIZE(debugfs_files),\r\ndc->minor);\r\ndc->minor = NULL;\r\nkfree(dc->debugfs_files);\r\ndc->debugfs_files = NULL;\r\ndebugfs_remove(dc->debugfs);\r\ndc->debugfs = NULL;\r\nreturn 0;\r\n}\r\nstatic int tegra_dc_init(struct host1x_client *client)\r\n{\r\nstruct drm_device *drm = dev_get_drvdata(client->parent);\r\nstruct tegra_dc *dc = host1x_client_to_dc(client);\r\nstruct tegra_drm *tegra = drm->dev_private;\r\nstruct drm_plane *primary = NULL;\r\nstruct drm_plane *cursor = NULL;\r\nu32 value;\r\nint err;\r\nif (tegra->domain) {\r\nerr = iommu_attach_device(tegra->domain, dc->dev);\r\nif (err < 0) {\r\ndev_err(dc->dev, "failed to attach to domain: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\ndc->domain = tegra->domain;\r\n}\r\nprimary = tegra_dc_primary_plane_create(drm, dc);\r\nif (IS_ERR(primary)) {\r\nerr = PTR_ERR(primary);\r\ngoto cleanup;\r\n}\r\nif (dc->soc->supports_cursor) {\r\ncursor = tegra_dc_cursor_plane_create(drm, dc);\r\nif (IS_ERR(cursor)) {\r\nerr = PTR_ERR(cursor);\r\ngoto cleanup;\r\n}\r\n}\r\nerr = drm_crtc_init_with_planes(drm, &dc->base, primary, cursor,\r\n&tegra_crtc_funcs);\r\nif (err < 0)\r\ngoto cleanup;\r\ndrm_mode_crtc_set_gamma_size(&dc->base, 256);\r\ndrm_crtc_helper_add(&dc->base, &tegra_crtc_helper_funcs);\r\nif (dc->soc->pitch_align > tegra->pitch_align)\r\ntegra->pitch_align = dc->soc->pitch_align;\r\nerr = tegra_dc_rgb_init(drm, dc);\r\nif (err < 0 && err != -ENODEV) {\r\ndev_err(dc->dev, "failed to initialize RGB output: %d\n", err);\r\ngoto cleanup;\r\n}\r\nerr = tegra_dc_add_planes(drm, dc);\r\nif (err < 0)\r\ngoto cleanup;\r\nif (IS_ENABLED(CONFIG_DEBUG_FS)) {\r\nerr = tegra_dc_debugfs_init(dc, drm->primary);\r\nif (err < 0)\r\ndev_err(dc->dev, "debugfs setup failed: %d\n", err);\r\n}\r\nerr = devm_request_irq(dc->dev, dc->irq, tegra_dc_irq, 0,\r\ndev_name(dc->dev), dc);\r\nif (err < 0) {\r\ndev_err(dc->dev, "failed to request IRQ#%u: %d\n", dc->irq,\r\nerr);\r\ngoto cleanup;\r\n}\r\nif (dc->syncpt) {\r\nu32 syncpt = host1x_syncpt_id(dc->syncpt);\r\nvalue = SYNCPT_CNTRL_NO_STALL;\r\ntegra_dc_writel(dc, value, DC_CMD_GENERAL_INCR_SYNCPT_CNTRL);\r\nvalue = SYNCPT_VSYNC_ENABLE | syncpt;\r\ntegra_dc_writel(dc, value, DC_CMD_CONT_SYNCPT_VSYNC);\r\n}\r\nvalue = WIN_A_UF_INT | WIN_B_UF_INT | WIN_C_UF_INT | WIN_A_OF_INT;\r\ntegra_dc_writel(dc, value, DC_CMD_INT_TYPE);\r\nvalue = WIN_A_UF_INT | WIN_B_UF_INT | WIN_C_UF_INT |\r\nWIN_A_OF_INT | WIN_B_OF_INT | WIN_C_OF_INT;\r\ntegra_dc_writel(dc, value, DC_CMD_INT_POLARITY);\r\nvalue = CURSOR_THRESHOLD(0) | WINDOW_A_THRESHOLD(0x20) |\r\nWINDOW_B_THRESHOLD(0x20) | WINDOW_C_THRESHOLD(0x20);\r\ntegra_dc_writel(dc, value, DC_DISP_DISP_MEM_HIGH_PRIORITY);\r\nvalue = CURSOR_THRESHOLD(0) | WINDOW_A_THRESHOLD(1) |\r\nWINDOW_B_THRESHOLD(1) | WINDOW_C_THRESHOLD(1);\r\ntegra_dc_writel(dc, value, DC_DISP_DISP_MEM_HIGH_PRIORITY_TIMER);\r\nvalue = VBLANK_INT | WIN_A_UF_INT | WIN_B_UF_INT | WIN_C_UF_INT;\r\ntegra_dc_writel(dc, value, DC_CMD_INT_ENABLE);\r\nvalue = WIN_A_UF_INT | WIN_B_UF_INT | WIN_C_UF_INT;\r\ntegra_dc_writel(dc, value, DC_CMD_INT_MASK);\r\nif (dc->soc->supports_border_color)\r\ntegra_dc_writel(dc, 0, DC_DISP_BORDER_COLOR);\r\nreturn 0;\r\ncleanup:\r\nif (cursor)\r\ndrm_plane_cleanup(cursor);\r\nif (primary)\r\ndrm_plane_cleanup(primary);\r\nif (tegra->domain) {\r\niommu_detach_device(tegra->domain, dc->dev);\r\ndc->domain = NULL;\r\n}\r\nreturn err;\r\n}\r\nstatic int tegra_dc_exit(struct host1x_client *client)\r\n{\r\nstruct tegra_dc *dc = host1x_client_to_dc(client);\r\nint err;\r\ndevm_free_irq(dc->dev, dc->irq, dc);\r\nif (IS_ENABLED(CONFIG_DEBUG_FS)) {\r\nerr = tegra_dc_debugfs_exit(dc);\r\nif (err < 0)\r\ndev_err(dc->dev, "debugfs cleanup failed: %d\n", err);\r\n}\r\nerr = tegra_dc_rgb_exit(dc);\r\nif (err) {\r\ndev_err(dc->dev, "failed to shutdown RGB output: %d\n", err);\r\nreturn err;\r\n}\r\nif (dc->domain) {\r\niommu_detach_device(dc->domain, dc->dev);\r\ndc->domain = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tegra_dc_parse_dt(struct tegra_dc *dc)\r\n{\r\nstruct device_node *np;\r\nu32 value = 0;\r\nint err;\r\nerr = of_property_read_u32(dc->dev->of_node, "nvidia,head", &value);\r\nif (err < 0) {\r\ndev_err(dc->dev, "missing \"nvidia,head\" property\n");\r\nfor_each_matching_node(np, tegra_dc_of_match) {\r\nif (np == dc->dev->of_node)\r\nbreak;\r\nvalue++;\r\n}\r\n}\r\ndc->pipe = value;\r\nreturn 0;\r\n}\r\nstatic int tegra_dc_probe(struct platform_device *pdev)\r\n{\r\nunsigned long flags = HOST1X_SYNCPT_CLIENT_MANAGED;\r\nconst struct of_device_id *id;\r\nstruct resource *regs;\r\nstruct tegra_dc *dc;\r\nint err;\r\ndc = devm_kzalloc(&pdev->dev, sizeof(*dc), GFP_KERNEL);\r\nif (!dc)\r\nreturn -ENOMEM;\r\nid = of_match_node(tegra_dc_of_match, pdev->dev.of_node);\r\nif (!id)\r\nreturn -ENODEV;\r\nspin_lock_init(&dc->lock);\r\nINIT_LIST_HEAD(&dc->list);\r\ndc->dev = &pdev->dev;\r\ndc->soc = id->data;\r\nerr = tegra_dc_parse_dt(dc);\r\nif (err < 0)\r\nreturn err;\r\ndc->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(dc->clk)) {\r\ndev_err(&pdev->dev, "failed to get clock\n");\r\nreturn PTR_ERR(dc->clk);\r\n}\r\ndc->rst = devm_reset_control_get(&pdev->dev, "dc");\r\nif (IS_ERR(dc->rst)) {\r\ndev_err(&pdev->dev, "failed to get reset\n");\r\nreturn PTR_ERR(dc->rst);\r\n}\r\nif (dc->soc->has_powergate) {\r\nif (dc->pipe == 0)\r\ndc->powergate = TEGRA_POWERGATE_DIS;\r\nelse\r\ndc->powergate = TEGRA_POWERGATE_DISB;\r\nerr = tegra_powergate_sequence_power_up(dc->powergate, dc->clk,\r\ndc->rst);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to power partition: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\n} else {\r\nerr = clk_prepare_enable(dc->clk);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to enable clock: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nerr = reset_control_deassert(dc->rst);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to deassert reset: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\n}\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndc->regs = devm_ioremap_resource(&pdev->dev, regs);\r\nif (IS_ERR(dc->regs))\r\nreturn PTR_ERR(dc->regs);\r\ndc->irq = platform_get_irq(pdev, 0);\r\nif (dc->irq < 0) {\r\ndev_err(&pdev->dev, "failed to get IRQ\n");\r\nreturn -ENXIO;\r\n}\r\nINIT_LIST_HEAD(&dc->client.list);\r\ndc->client.ops = &dc_client_ops;\r\ndc->client.dev = &pdev->dev;\r\nerr = tegra_dc_rgb_probe(dc);\r\nif (err < 0 && err != -ENODEV) {\r\ndev_err(&pdev->dev, "failed to probe RGB output: %d\n", err);\r\nreturn err;\r\n}\r\nerr = host1x_client_register(&dc->client);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to register host1x client: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\ndc->syncpt = host1x_syncpt_request(&pdev->dev, flags);\r\nif (!dc->syncpt)\r\ndev_warn(&pdev->dev, "failed to allocate syncpoint\n");\r\nplatform_set_drvdata(pdev, dc);\r\nreturn 0;\r\n}\r\nstatic int tegra_dc_remove(struct platform_device *pdev)\r\n{\r\nstruct tegra_dc *dc = platform_get_drvdata(pdev);\r\nint err;\r\nhost1x_syncpt_free(dc->syncpt);\r\nerr = host1x_client_unregister(&dc->client);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to unregister host1x client: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nerr = tegra_dc_rgb_remove(dc);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to remove RGB output: %d\n", err);\r\nreturn err;\r\n}\r\nreset_control_assert(dc->rst);\r\nif (dc->soc->has_powergate)\r\ntegra_powergate_power_off(dc->powergate);\r\nclk_disable_unprepare(dc->clk);\r\nreturn 0;\r\n}
