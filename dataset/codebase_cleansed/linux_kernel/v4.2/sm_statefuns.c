static inline int\r\nsctp_chunk_length_valid(struct sctp_chunk *chunk,\r\n__u16 required_length)\r\n{\r\n__u16 chunk_length = ntohs(chunk->chunk_hdr->length);\r\nif (unlikely(chunk->pdiscard))\r\nreturn 0;\r\nif (unlikely(chunk_length < required_length))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nsctp_disposition_t sctp_sf_do_4_C(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = arg;\r\nstruct sctp_ulpevent *ev;\r\nif (!sctp_vtag_verify_either(chunk, asoc))\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nif (!chunk->singleton)\r\nreturn sctp_sf_violation_chunk(net, ep, asoc, type, arg, commands);\r\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\nev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_SHUTDOWN_COMP,\r\n0, 0, 0, NULL, GFP_ATOMIC);\r\nif (ev)\r\nsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\r\nSCTP_ULPEVENT(ev));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\r\nSCTP_STATE(SCTP_STATE_CLOSED));\r\nSCTP_INC_STATS(net, SCTP_MIB_SHUTDOWNS);\r\nSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\r\nsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\r\nreturn SCTP_DISPOSITION_DELETE_TCB;\r\n}\r\nsctp_disposition_t sctp_sf_do_5_1B_init(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = arg;\r\nstruct sctp_chunk *repl;\r\nstruct sctp_association *new_asoc;\r\nstruct sctp_chunk *err_chunk;\r\nstruct sctp_packet *packet;\r\nsctp_unrecognized_param_t *unk_param;\r\nint len;\r\nif (!chunk->singleton)\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nif (ep == sctp_sk(net->sctp.ctl_sock)->ep) {\r\nSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\r\nreturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\r\n}\r\nif (chunk->sctp_hdr->vtag != 0)\r\nreturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\r\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_init_chunk_t)))\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nif (sctp_sstate(ep->base.sk, CLOSING))\r\nreturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\r\nerr_chunk = NULL;\r\nif (!sctp_verify_init(net, ep, asoc, chunk->chunk_hdr->type,\r\n(sctp_init_chunk_t *)chunk->chunk_hdr, chunk,\r\n&err_chunk)) {\r\nif (err_chunk) {\r\npacket = sctp_abort_pkt_new(net, ep, asoc, arg,\r\n(__u8 *)(err_chunk->chunk_hdr) +\r\nsizeof(sctp_chunkhdr_t),\r\nntohs(err_chunk->chunk_hdr->length) -\r\nsizeof(sctp_chunkhdr_t));\r\nsctp_chunk_free(err_chunk);\r\nif (packet) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\r\nSCTP_PACKET(packet));\r\nSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n} else {\r\nreturn SCTP_DISPOSITION_NOMEM;\r\n}\r\n} else {\r\nreturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg,\r\ncommands);\r\n}\r\n}\r\nchunk->subh.init_hdr = (sctp_inithdr_t *)chunk->skb->data;\r\nchunk->param_hdr.v = skb_pull(chunk->skb, sizeof(sctp_inithdr_t));\r\nnew_asoc = sctp_make_temp_asoc(ep, chunk, GFP_ATOMIC);\r\nif (!new_asoc)\r\ngoto nomem;\r\nif (sctp_assoc_set_bind_addr_from_ep(new_asoc,\r\nsctp_scope(sctp_source(chunk)),\r\nGFP_ATOMIC) < 0)\r\ngoto nomem_init;\r\nif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk),\r\n(sctp_init_chunk_t *)chunk->chunk_hdr,\r\nGFP_ATOMIC))\r\ngoto nomem_init;\r\nlen = 0;\r\nif (err_chunk)\r\nlen = ntohs(err_chunk->chunk_hdr->length) -\r\nsizeof(sctp_chunkhdr_t);\r\nrepl = sctp_make_init_ack(new_asoc, chunk, GFP_ATOMIC, len);\r\nif (!repl)\r\ngoto nomem_init;\r\nif (err_chunk) {\r\nunk_param = (sctp_unrecognized_param_t *)\r\n((__u8 *)(err_chunk->chunk_hdr) +\r\nsizeof(sctp_chunkhdr_t));\r\nsctp_addto_chunk(repl, len, unk_param);\r\nsctp_chunk_free(err_chunk);\r\n}\r\nsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\r\nreturn SCTP_DISPOSITION_DELETE_TCB;\r\nnomem_init:\r\nsctp_association_free(new_asoc);\r\nnomem:\r\nif (err_chunk)\r\nsctp_chunk_free(err_chunk);\r\nreturn SCTP_DISPOSITION_NOMEM;\r\n}\r\nsctp_disposition_t sctp_sf_do_5_1C_ack(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = arg;\r\nsctp_init_chunk_t *initchunk;\r\nstruct sctp_chunk *err_chunk;\r\nstruct sctp_packet *packet;\r\nif (!sctp_vtag_verify(chunk, asoc))\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nif (!chunk->singleton)\r\nreturn sctp_sf_violation_chunk(net, ep, asoc, type, arg, commands);\r\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_initack_chunk_t)))\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\nchunk->subh.init_hdr = (sctp_inithdr_t *) chunk->skb->data;\r\nerr_chunk = NULL;\r\nif (!sctp_verify_init(net, ep, asoc, chunk->chunk_hdr->type,\r\n(sctp_init_chunk_t *)chunk->chunk_hdr, chunk,\r\n&err_chunk)) {\r\nsctp_error_t error = SCTP_ERROR_NO_RESOURCE;\r\nif (err_chunk) {\r\npacket = sctp_abort_pkt_new(net, ep, asoc, arg,\r\n(__u8 *)(err_chunk->chunk_hdr) +\r\nsizeof(sctp_chunkhdr_t),\r\nntohs(err_chunk->chunk_hdr->length) -\r\nsizeof(sctp_chunkhdr_t));\r\nsctp_chunk_free(err_chunk);\r\nif (packet) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\r\nSCTP_PACKET(packet));\r\nSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\r\nerror = SCTP_ERROR_INV_PARAM;\r\n}\r\n}\r\nif (sctp_auth_recv_cid(SCTP_CID_ABORT, asoc))\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\r\nreturn sctp_stop_t1_and_abort(net, commands, error, ECONNREFUSED,\r\nasoc, chunk->transport);\r\n}\r\nchunk->param_hdr.v = skb_pull(chunk->skb, sizeof(sctp_inithdr_t));\r\ninitchunk = (sctp_init_chunk_t *) chunk->chunk_hdr;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_PEER_INIT,\r\nSCTP_PEER_INIT(initchunk));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_INIT_COUNTER_RESET, SCTP_NULL());\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\r\nSCTP_STATE(SCTP_STATE_COOKIE_ECHOED));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_SHKEY, SCTP_NULL());\r\nsctp_add_cmd_sf(commands, SCTP_CMD_GEN_COOKIE_ECHO,\r\nSCTP_CHUNK(err_chunk));\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nsctp_disposition_t sctp_sf_do_5_1D_ce(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type, void *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = arg;\r\nstruct sctp_association *new_asoc;\r\nsctp_init_chunk_t *peer_init;\r\nstruct sctp_chunk *repl;\r\nstruct sctp_ulpevent *ev, *ai_ev = NULL;\r\nint error = 0;\r\nstruct sctp_chunk *err_chk_p;\r\nstruct sock *sk;\r\nif (ep == sctp_sk(net->sctp.ctl_sock)->ep) {\r\nSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\r\nreturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\r\n}\r\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nsk = ep->base.sk;\r\nif (!sctp_sstate(sk, LISTENING) ||\r\n(sctp_style(sk, TCP) && sk_acceptq_is_full(sk)))\r\nreturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\r\nchunk->subh.cookie_hdr =\r\n(struct sctp_signed_cookie *)chunk->skb->data;\r\nif (!pskb_pull(chunk->skb, ntohs(chunk->chunk_hdr->length) -\r\nsizeof(sctp_chunkhdr_t)))\r\ngoto nomem;\r\nnew_asoc = sctp_unpack_cookie(ep, asoc, chunk, GFP_ATOMIC, &error,\r\n&err_chk_p);\r\nif (!new_asoc) {\r\nswitch (error) {\r\ncase -SCTP_IERROR_NOMEM:\r\ngoto nomem;\r\ncase -SCTP_IERROR_STALE_COOKIE:\r\nsctp_send_stale_cookie_err(net, ep, asoc, chunk, commands,\r\nerr_chk_p);\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\ncase -SCTP_IERROR_BAD_SIG:\r\ndefault:\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\n}\r\n}\r\npeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\r\nif (!sctp_process_init(new_asoc, chunk,\r\n&chunk->subh.cookie_hdr->c.peer_addr,\r\npeer_init, GFP_ATOMIC))\r\ngoto nomem_init;\r\nerror = sctp_auth_asoc_init_active_key(new_asoc, GFP_ATOMIC);\r\nif (error)\r\ngoto nomem_init;\r\nif (chunk->auth_chunk) {\r\nstruct sctp_chunk auth;\r\nsctp_ierror_t ret;\r\nif (!net->sctp.auth_enable || !new_asoc->peer.auth_capable) {\r\nsctp_association_free(new_asoc);\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\n}\r\nauth.skb = chunk->auth_chunk;\r\nauth.asoc = chunk->asoc;\r\nauth.sctp_hdr = chunk->sctp_hdr;\r\nauth.chunk_hdr = (sctp_chunkhdr_t *)skb_push(chunk->auth_chunk,\r\nsizeof(sctp_chunkhdr_t));\r\nskb_pull(chunk->auth_chunk, sizeof(sctp_chunkhdr_t));\r\nauth.transport = chunk->transport;\r\nret = sctp_sf_authenticate(net, ep, new_asoc, type, &auth);\r\nif (ret != SCTP_IERROR_NO_ERROR) {\r\nsctp_association_free(new_asoc);\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\n}\r\n}\r\nrepl = sctp_make_cookie_ack(new_asoc, chunk);\r\nif (!repl)\r\ngoto nomem_init;\r\nev = sctp_ulpevent_make_assoc_change(new_asoc, 0, SCTP_COMM_UP, 0,\r\nnew_asoc->c.sinit_num_ostreams,\r\nnew_asoc->c.sinit_max_instreams,\r\nNULL, GFP_ATOMIC);\r\nif (!ev)\r\ngoto nomem_ev;\r\nif (new_asoc->peer.adaptation_ind) {\r\nai_ev = sctp_ulpevent_make_adaptation_indication(new_asoc,\r\nGFP_ATOMIC);\r\nif (!ai_ev)\r\ngoto nomem_aiev;\r\n}\r\nsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\r\nSCTP_STATE(SCTP_STATE_ESTABLISHED));\r\nSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\r\nSCTP_INC_STATS(net, SCTP_MIB_PASSIVEESTABS);\r\nsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\r\nif (new_asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\r\nif (ai_ev)\r\nsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\r\nSCTP_ULPEVENT(ai_ev));\r\nreturn SCTP_DISPOSITION_CONSUME;\r\nnomem_aiev:\r\nsctp_ulpevent_free(ev);\r\nnomem_ev:\r\nsctp_chunk_free(repl);\r\nnomem_init:\r\nsctp_association_free(new_asoc);\r\nnomem:\r\nreturn SCTP_DISPOSITION_NOMEM;\r\n}\r\nsctp_disposition_t sctp_sf_do_5_1E_ca(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type, void *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = arg;\r\nstruct sctp_ulpevent *ev;\r\nif (!sctp_vtag_verify(chunk, asoc))\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\nsctp_add_cmd_sf(commands, SCTP_CMD_INIT_COUNTER_RESET, SCTP_NULL());\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\r\nSCTP_STATE(SCTP_STATE_ESTABLISHED));\r\nSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\r\nSCTP_INC_STATS(net, SCTP_MIB_ACTIVEESTABS);\r\nsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\r\nif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\r\nev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_COMM_UP,\r\n0, asoc->c.sinit_num_ostreams,\r\nasoc->c.sinit_max_instreams,\r\nNULL, GFP_ATOMIC);\r\nif (!ev)\r\ngoto nomem;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\r\nif (asoc->peer.adaptation_ind) {\r\nev = sctp_ulpevent_make_adaptation_indication(asoc, GFP_ATOMIC);\r\nif (!ev)\r\ngoto nomem;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\r\nSCTP_ULPEVENT(ev));\r\n}\r\nreturn SCTP_DISPOSITION_CONSUME;\r\nnomem:\r\nreturn SCTP_DISPOSITION_NOMEM;\r\n}\r\nstatic sctp_disposition_t sctp_sf_heartbeat(const struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_transport *transport = (struct sctp_transport *) arg;\r\nstruct sctp_chunk *reply;\r\nreply = sctp_make_heartbeat(asoc, transport);\r\nif (!reply)\r\nreturn SCTP_DISPOSITION_NOMEM;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_RTO_PENDING,\r\nSCTP_TRANSPORT(transport));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nsctp_disposition_t sctp_sf_sendbeat_8_3(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_transport *transport = (struct sctp_transport *) arg;\r\nif (asoc->overall_error_count >= asoc->max_retrans) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\r\nSCTP_ERROR(ETIMEDOUT));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\r\nSCTP_PERR(SCTP_ERROR_NO_ERROR));\r\nSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\r\nSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\r\nreturn SCTP_DISPOSITION_DELETE_TCB;\r\n}\r\nif (transport->param_flags & SPP_HB_ENABLE) {\r\nif (SCTP_DISPOSITION_NOMEM ==\r\nsctp_sf_heartbeat(ep, asoc, type, arg,\r\ncommands))\r\nreturn SCTP_DISPOSITION_NOMEM;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_HB_SENT,\r\nSCTP_TRANSPORT(transport));\r\n}\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_IDLE,\r\nSCTP_TRANSPORT(transport));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMER_UPDATE,\r\nSCTP_TRANSPORT(transport));\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nsctp_disposition_t sctp_sf_beat_8_3(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nsctp_paramhdr_t *param_hdr;\r\nstruct sctp_chunk *chunk = arg;\r\nstruct sctp_chunk *reply;\r\nsize_t paylen = 0;\r\nif (!sctp_vtag_verify(chunk, asoc))\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_heartbeat_chunk_t)))\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\nchunk->subh.hb_hdr = (sctp_heartbeathdr_t *) chunk->skb->data;\r\nparam_hdr = (sctp_paramhdr_t *) chunk->subh.hb_hdr;\r\npaylen = ntohs(chunk->chunk_hdr->length) - sizeof(sctp_chunkhdr_t);\r\nif (ntohs(param_hdr->length) > paylen)\r\nreturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\r\nparam_hdr, commands);\r\nif (!pskb_pull(chunk->skb, paylen))\r\ngoto nomem;\r\nreply = sctp_make_heartbeat_ack(asoc, chunk, param_hdr, paylen);\r\nif (!reply)\r\ngoto nomem;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\r\nreturn SCTP_DISPOSITION_CONSUME;\r\nnomem:\r\nreturn SCTP_DISPOSITION_NOMEM;\r\n}\r\nsctp_disposition_t sctp_sf_backbeat_8_3(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = arg;\r\nunion sctp_addr from_addr;\r\nstruct sctp_transport *link;\r\nsctp_sender_hb_info_t *hbinfo;\r\nunsigned long max_interval;\r\nif (!sctp_vtag_verify(chunk, asoc))\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t) +\r\nsizeof(sctp_sender_hb_info_t)))\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\nhbinfo = (sctp_sender_hb_info_t *) chunk->skb->data;\r\nif (ntohs(hbinfo->param_hdr.length) !=\r\nsizeof(sctp_sender_hb_info_t)) {\r\nreturn SCTP_DISPOSITION_DISCARD;\r\n}\r\nfrom_addr = hbinfo->daddr;\r\nlink = sctp_assoc_lookup_paddr(asoc, &from_addr);\r\nif (unlikely(!link)) {\r\nif (from_addr.sa.sa_family == AF_INET6) {\r\nnet_warn_ratelimited("%s association %p could not find address %pI6\n",\r\n__func__,\r\nasoc,\r\n&from_addr.v6.sin6_addr);\r\n} else {\r\nnet_warn_ratelimited("%s association %p could not find address %pI4\n",\r\n__func__,\r\nasoc,\r\n&from_addr.v4.sin_addr.s_addr);\r\n}\r\nreturn SCTP_DISPOSITION_DISCARD;\r\n}\r\nif (hbinfo->hb_nonce != link->hb_nonce)\r\nreturn SCTP_DISPOSITION_DISCARD;\r\nmax_interval = link->hbinterval + link->rto;\r\nif (time_after(hbinfo->sent_at, jiffies) ||\r\ntime_after(jiffies, hbinfo->sent_at + max_interval)) {\r\npr_debug("%s: HEARTBEAT ACK with invalid timestamp received "\r\n"for transport:%p\n", __func__, link);\r\nreturn SCTP_DISPOSITION_DISCARD;\r\n}\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_ON, SCTP_TRANSPORT(link));\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nstatic int sctp_sf_send_restart_abort(struct net *net, union sctp_addr *ssa,\r\nstruct sctp_chunk *init,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nint len;\r\nstruct sctp_packet *pkt;\r\nunion sctp_addr_param *addrparm;\r\nstruct sctp_errhdr *errhdr;\r\nstruct sctp_endpoint *ep;\r\nchar buffer[sizeof(struct sctp_errhdr)+sizeof(union sctp_addr_param)];\r\nstruct sctp_af *af = sctp_get_af_specific(ssa->v4.sin_family);\r\nerrhdr = (struct sctp_errhdr *)buffer;\r\naddrparm = (union sctp_addr_param *)errhdr->variable;\r\nlen = af->to_addr_param(ssa, addrparm);\r\nlen += sizeof(sctp_errhdr_t);\r\nerrhdr->cause = SCTP_ERROR_RESTART;\r\nerrhdr->length = htons(len);\r\nep = sctp_sk(net->sctp.ctl_sock)->ep;\r\npkt = sctp_abort_pkt_new(net, ep, NULL, init, errhdr, len);\r\nif (!pkt)\r\ngoto out;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT, SCTP_PACKET(pkt));\r\nSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\r\nsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\r\nout:\r\nreturn 0;\r\n}\r\nstatic bool list_has_sctp_addr(const struct list_head *list,\r\nunion sctp_addr *ipaddr)\r\n{\r\nstruct sctp_transport *addr;\r\nlist_for_each_entry(addr, list, transports) {\r\nif (sctp_cmp_addr_exact(ipaddr, &addr->ipaddr))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int sctp_sf_check_restart_addrs(const struct sctp_association *new_asoc,\r\nconst struct sctp_association *asoc,\r\nstruct sctp_chunk *init,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct net *net = sock_net(new_asoc->base.sk);\r\nstruct sctp_transport *new_addr;\r\nint ret = 1;\r\nlist_for_each_entry(new_addr, &new_asoc->peer.transport_addr_list,\r\ntransports) {\r\nif (!list_has_sctp_addr(&asoc->peer.transport_addr_list,\r\n&new_addr->ipaddr)) {\r\nsctp_sf_send_restart_abort(net, &new_addr->ipaddr, init,\r\ncommands);\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void sctp_tietags_populate(struct sctp_association *new_asoc,\r\nconst struct sctp_association *asoc)\r\n{\r\nswitch (asoc->state) {\r\ncase SCTP_STATE_COOKIE_WAIT:\r\nnew_asoc->c.my_vtag = asoc->c.my_vtag;\r\nnew_asoc->c.my_ttag = asoc->c.my_vtag;\r\nnew_asoc->c.peer_ttag = 0;\r\nbreak;\r\ncase SCTP_STATE_COOKIE_ECHOED:\r\nnew_asoc->c.my_vtag = asoc->c.my_vtag;\r\nnew_asoc->c.my_ttag = asoc->c.my_vtag;\r\nnew_asoc->c.peer_ttag = asoc->c.peer_vtag;\r\nbreak;\r\ndefault:\r\nnew_asoc->c.my_ttag = asoc->c.my_vtag;\r\nnew_asoc->c.peer_ttag = asoc->c.peer_vtag;\r\nbreak;\r\n}\r\nnew_asoc->rwnd = asoc->rwnd;\r\nnew_asoc->c.sinit_num_ostreams = asoc->c.sinit_num_ostreams;\r\nnew_asoc->c.sinit_max_instreams = asoc->c.sinit_max_instreams;\r\nnew_asoc->c.initial_tsn = asoc->c.initial_tsn;\r\n}\r\nstatic char sctp_tietags_compare(struct sctp_association *new_asoc,\r\nconst struct sctp_association *asoc)\r\n{\r\nif ((asoc->c.my_vtag != new_asoc->c.my_vtag) &&\r\n(asoc->c.peer_vtag != new_asoc->c.peer_vtag) &&\r\n(asoc->c.my_vtag == new_asoc->c.my_ttag) &&\r\n(asoc->c.peer_vtag == new_asoc->c.peer_ttag))\r\nreturn 'A';\r\nif ((asoc->c.my_vtag == new_asoc->c.my_vtag) &&\r\n((asoc->c.peer_vtag != new_asoc->c.peer_vtag) ||\r\n(0 == asoc->c.peer_vtag))) {\r\nreturn 'B';\r\n}\r\nif ((asoc->c.my_vtag == new_asoc->c.my_vtag) &&\r\n(asoc->c.peer_vtag == new_asoc->c.peer_vtag))\r\nreturn 'D';\r\nif ((asoc->c.my_vtag != new_asoc->c.my_vtag) &&\r\n(asoc->c.peer_vtag == new_asoc->c.peer_vtag) &&\r\n(0 == new_asoc->c.my_ttag) &&\r\n(0 == new_asoc->c.peer_ttag))\r\nreturn 'C';\r\nreturn 'E';\r\n}\r\nstatic sctp_disposition_t sctp_sf_do_unexpected_init(\r\nstruct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg, sctp_cmd_seq_t *commands)\r\n{\r\nsctp_disposition_t retval;\r\nstruct sctp_chunk *chunk = arg;\r\nstruct sctp_chunk *repl;\r\nstruct sctp_association *new_asoc;\r\nstruct sctp_chunk *err_chunk;\r\nstruct sctp_packet *packet;\r\nsctp_unrecognized_param_t *unk_param;\r\nint len;\r\nif (!chunk->singleton)\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nif (chunk->sctp_hdr->vtag != 0)\r\nreturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\r\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_init_chunk_t)))\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\nchunk->subh.init_hdr = (sctp_inithdr_t *) chunk->skb->data;\r\nchunk->param_hdr.v = skb_pull(chunk->skb, sizeof(sctp_inithdr_t));\r\nerr_chunk = NULL;\r\nif (!sctp_verify_init(net, ep, asoc, chunk->chunk_hdr->type,\r\n(sctp_init_chunk_t *)chunk->chunk_hdr, chunk,\r\n&err_chunk)) {\r\nif (err_chunk) {\r\npacket = sctp_abort_pkt_new(net, ep, asoc, arg,\r\n(__u8 *)(err_chunk->chunk_hdr) +\r\nsizeof(sctp_chunkhdr_t),\r\nntohs(err_chunk->chunk_hdr->length) -\r\nsizeof(sctp_chunkhdr_t));\r\nif (packet) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\r\nSCTP_PACKET(packet));\r\nSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\r\nretval = SCTP_DISPOSITION_CONSUME;\r\n} else {\r\nretval = SCTP_DISPOSITION_NOMEM;\r\n}\r\ngoto cleanup;\r\n} else {\r\nreturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg,\r\ncommands);\r\n}\r\n}\r\nnew_asoc = sctp_make_temp_asoc(ep, chunk, GFP_ATOMIC);\r\nif (!new_asoc)\r\ngoto nomem;\r\nif (sctp_assoc_set_bind_addr_from_ep(new_asoc,\r\nsctp_scope(sctp_source(chunk)), GFP_ATOMIC) < 0)\r\ngoto nomem;\r\nif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk),\r\n(sctp_init_chunk_t *)chunk->chunk_hdr,\r\nGFP_ATOMIC))\r\ngoto nomem;\r\nif (!sctp_state(asoc, COOKIE_WAIT)) {\r\nif (!sctp_sf_check_restart_addrs(new_asoc, asoc, chunk,\r\ncommands)) {\r\nretval = SCTP_DISPOSITION_CONSUME;\r\ngoto nomem_retval;\r\n}\r\n}\r\nsctp_tietags_populate(new_asoc, asoc);\r\nlen = 0;\r\nif (err_chunk) {\r\nlen = ntohs(err_chunk->chunk_hdr->length) -\r\nsizeof(sctp_chunkhdr_t);\r\n}\r\nrepl = sctp_make_init_ack(new_asoc, chunk, GFP_ATOMIC, len);\r\nif (!repl)\r\ngoto nomem;\r\nif (err_chunk) {\r\nunk_param = (sctp_unrecognized_param_t *)\r\n((__u8 *)(err_chunk->chunk_hdr) +\r\nsizeof(sctp_chunkhdr_t));\r\nsctp_addto_chunk(repl, len, unk_param);\r\n}\r\nsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\r\nretval = SCTP_DISPOSITION_CONSUME;\r\nreturn retval;\r\nnomem:\r\nretval = SCTP_DISPOSITION_NOMEM;\r\nnomem_retval:\r\nif (new_asoc)\r\nsctp_association_free(new_asoc);\r\ncleanup:\r\nif (err_chunk)\r\nsctp_chunk_free(err_chunk);\r\nreturn retval;\r\n}\r\nsctp_disposition_t sctp_sf_do_5_2_1_siminit(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nreturn sctp_sf_do_unexpected_init(net, ep, asoc, type, arg, commands);\r\n}\r\nsctp_disposition_t sctp_sf_do_5_2_2_dupinit(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nreturn sctp_sf_do_unexpected_init(net, ep, asoc, type, arg, commands);\r\n}\r\nsctp_disposition_t sctp_sf_do_5_2_3_initack(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg, sctp_cmd_seq_t *commands)\r\n{\r\nif (ep == sctp_sk(net->sctp.ctl_sock)->ep)\r\nreturn sctp_sf_ootb(net, ep, asoc, type, arg, commands);\r\nelse\r\nreturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\r\n}\r\nstatic sctp_disposition_t sctp_sf_do_dupcook_a(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nstruct sctp_chunk *chunk,\r\nsctp_cmd_seq_t *commands,\r\nstruct sctp_association *new_asoc)\r\n{\r\nsctp_init_chunk_t *peer_init;\r\nstruct sctp_ulpevent *ev;\r\nstruct sctp_chunk *repl;\r\nstruct sctp_chunk *err;\r\nsctp_disposition_t disposition;\r\npeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\r\nif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk), peer_init,\r\nGFP_ATOMIC))\r\ngoto nomem;\r\nif (!sctp_sf_check_restart_addrs(new_asoc, asoc, chunk, commands)) {\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nif (sctp_state(asoc, SHUTDOWN_ACK_SENT)) {\r\ndisposition = sctp_sf_do_9_2_reshutack(net, ep, asoc,\r\nSCTP_ST_CHUNK(chunk->chunk_hdr->type),\r\nchunk, commands);\r\nif (SCTP_DISPOSITION_NOMEM == disposition)\r\ngoto nomem;\r\nerr = sctp_make_op_error(asoc, chunk,\r\nSCTP_ERROR_COOKIE_IN_SHUTDOWN,\r\nNULL, 0, 0);\r\nif (err)\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\r\nSCTP_CHUNK(err));\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nsctp_add_cmd_sf(commands, SCTP_CMD_T3_RTX_TIMERS_STOP, SCTP_NULL());\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_SACK));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_PURGE_OUTQUEUE, SCTP_NULL());\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_PURGE_ASCONF_QUEUE, SCTP_NULL());\r\nrepl = sctp_make_cookie_ack(new_asoc, chunk);\r\nif (!repl)\r\ngoto nomem;\r\nev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_RESTART, 0,\r\nnew_asoc->c.sinit_num_ostreams,\r\nnew_asoc->c.sinit_max_instreams,\r\nNULL, GFP_ATOMIC);\r\nif (!ev)\r\ngoto nomem_ev;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_UPDATE_ASSOC, SCTP_ASOC(new_asoc));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\r\nif (sctp_state(asoc, SHUTDOWN_PENDING) &&\r\n(sctp_sstate(asoc->base.sk, CLOSING) ||\r\nsock_flag(asoc->base.sk, SOCK_DEAD))) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\r\nreturn sctp_sf_do_9_2_start_shutdown(net, ep, asoc,\r\nSCTP_ST_CHUNK(0), NULL,\r\ncommands);\r\n} else {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\r\nSCTP_STATE(SCTP_STATE_ESTABLISHED));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\r\n}\r\nreturn SCTP_DISPOSITION_CONSUME;\r\nnomem_ev:\r\nsctp_chunk_free(repl);\r\nnomem:\r\nreturn SCTP_DISPOSITION_NOMEM;\r\n}\r\nstatic sctp_disposition_t sctp_sf_do_dupcook_b(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nstruct sctp_chunk *chunk,\r\nsctp_cmd_seq_t *commands,\r\nstruct sctp_association *new_asoc)\r\n{\r\nsctp_init_chunk_t *peer_init;\r\nstruct sctp_chunk *repl;\r\npeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\r\nif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk), peer_init,\r\nGFP_ATOMIC))\r\ngoto nomem;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_UPDATE_ASSOC, SCTP_ASOC(new_asoc));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\r\nSCTP_STATE(SCTP_STATE_ESTABLISHED));\r\nSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\r\nsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\r\nrepl = sctp_make_cookie_ack(new_asoc, chunk);\r\nif (!repl)\r\ngoto nomem;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_CHANGE, SCTP_U8(SCTP_COMM_UP));\r\nif (asoc->peer.adaptation_ind)\r\nsctp_add_cmd_sf(commands, SCTP_CMD_ADAPTATION_IND, SCTP_NULL());\r\nreturn SCTP_DISPOSITION_CONSUME;\r\nnomem:\r\nreturn SCTP_DISPOSITION_NOMEM;\r\n}\r\nstatic sctp_disposition_t sctp_sf_do_dupcook_c(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nstruct sctp_chunk *chunk,\r\nsctp_cmd_seq_t *commands,\r\nstruct sctp_association *new_asoc)\r\n{\r\nreturn SCTP_DISPOSITION_DISCARD;\r\n}\r\nstatic sctp_disposition_t sctp_sf_do_dupcook_d(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nstruct sctp_chunk *chunk,\r\nsctp_cmd_seq_t *commands,\r\nstruct sctp_association *new_asoc)\r\n{\r\nstruct sctp_ulpevent *ev = NULL, *ai_ev = NULL;\r\nstruct sctp_chunk *repl;\r\nif (asoc->state < SCTP_STATE_ESTABLISHED) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\r\nSCTP_STATE(SCTP_STATE_ESTABLISHED));\r\nSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\r\nsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START,\r\nSCTP_NULL());\r\nev = sctp_ulpevent_make_assoc_change(asoc, 0,\r\nSCTP_COMM_UP, 0,\r\nasoc->c.sinit_num_ostreams,\r\nasoc->c.sinit_max_instreams,\r\nNULL, GFP_ATOMIC);\r\nif (!ev)\r\ngoto nomem;\r\nif (asoc->peer.adaptation_ind) {\r\nai_ev = sctp_ulpevent_make_adaptation_indication(asoc,\r\nGFP_ATOMIC);\r\nif (!ai_ev)\r\ngoto nomem;\r\n}\r\n}\r\nrepl = sctp_make_cookie_ack(new_asoc, chunk);\r\nif (!repl)\r\ngoto nomem;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\r\nif (ev)\r\nsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\r\nSCTP_ULPEVENT(ev));\r\nif (ai_ev)\r\nsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\r\nSCTP_ULPEVENT(ai_ev));\r\nreturn SCTP_DISPOSITION_CONSUME;\r\nnomem:\r\nif (ai_ev)\r\nsctp_ulpevent_free(ai_ev);\r\nif (ev)\r\nsctp_ulpevent_free(ev);\r\nreturn SCTP_DISPOSITION_NOMEM;\r\n}\r\nsctp_disposition_t sctp_sf_do_5_2_4_dupcook(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nsctp_disposition_t retval;\r\nstruct sctp_chunk *chunk = arg;\r\nstruct sctp_association *new_asoc;\r\nint error = 0;\r\nchar action;\r\nstruct sctp_chunk *err_chk_p;\r\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\nchunk->subh.cookie_hdr = (struct sctp_signed_cookie *)chunk->skb->data;\r\nif (!pskb_pull(chunk->skb, ntohs(chunk->chunk_hdr->length) -\r\nsizeof(sctp_chunkhdr_t)))\r\ngoto nomem;\r\nnew_asoc = sctp_unpack_cookie(ep, asoc, chunk, GFP_ATOMIC, &error,\r\n&err_chk_p);\r\nif (!new_asoc) {\r\nswitch (error) {\r\ncase -SCTP_IERROR_NOMEM:\r\ngoto nomem;\r\ncase -SCTP_IERROR_STALE_COOKIE:\r\nsctp_send_stale_cookie_err(net, ep, asoc, chunk, commands,\r\nerr_chk_p);\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\ncase -SCTP_IERROR_BAD_SIG:\r\ndefault:\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\n}\r\n}\r\naction = sctp_tietags_compare(new_asoc, asoc);\r\nswitch (action) {\r\ncase 'A':\r\nretval = sctp_sf_do_dupcook_a(net, ep, asoc, chunk, commands,\r\nnew_asoc);\r\nbreak;\r\ncase 'B':\r\nretval = sctp_sf_do_dupcook_b(net, ep, asoc, chunk, commands,\r\nnew_asoc);\r\nbreak;\r\ncase 'C':\r\nretval = sctp_sf_do_dupcook_c(net, ep, asoc, chunk, commands,\r\nnew_asoc);\r\nbreak;\r\ncase 'D':\r\nretval = sctp_sf_do_dupcook_d(net, ep, asoc, chunk, commands,\r\nnew_asoc);\r\nbreak;\r\ndefault:\r\nretval = sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nbreak;\r\n}\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SET_ASOC, SCTP_ASOC(new_asoc));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SET_ASOC,\r\nSCTP_ASOC((struct sctp_association *)asoc));\r\nreturn retval;\r\nnomem:\r\nreturn SCTP_DISPOSITION_NOMEM;\r\n}\r\nsctp_disposition_t sctp_sf_shutdown_pending_abort(\r\nstruct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = arg;\r\nif (!sctp_vtag_verify_either(chunk, asoc))\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_abort_chunk_t)))\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nif (SCTP_ADDR_DEL ==\r\nsctp_bind_addr_state(&asoc->base.bind_addr, &chunk->dest))\r\nreturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\r\nreturn __sctp_sf_do_9_1_abort(net, ep, asoc, type, arg, commands);\r\n}\r\nsctp_disposition_t sctp_sf_shutdown_sent_abort(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = arg;\r\nif (!sctp_vtag_verify_either(chunk, asoc))\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_abort_chunk_t)))\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nif (SCTP_ADDR_DEL ==\r\nsctp_bind_addr_state(&asoc->base.bind_addr, &chunk->dest))\r\nreturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\r\nreturn __sctp_sf_do_9_1_abort(net, ep, asoc, type, arg, commands);\r\n}\r\nsctp_disposition_t sctp_sf_shutdown_ack_sent_abort(\r\nstruct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nreturn sctp_sf_shutdown_sent_abort(net, ep, asoc, type, arg, commands);\r\n}\r\nsctp_disposition_t sctp_sf_cookie_echoed_err(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = arg;\r\nsctp_errhdr_t *err;\r\nif (!sctp_vtag_verify(chunk, asoc))\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_operr_chunk_t)))\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\nsctp_walk_errors(err, chunk->chunk_hdr) {\r\nif (SCTP_ERROR_STALE_COOKIE == err->cause)\r\nreturn sctp_sf_do_5_2_6_stale(net, ep, asoc, type,\r\narg, commands);\r\n}\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\n}\r\nstatic sctp_disposition_t sctp_sf_do_5_2_6_stale(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = arg;\r\ntime_t stale;\r\nsctp_cookie_preserve_param_t bht;\r\nsctp_errhdr_t *err;\r\nstruct sctp_chunk *reply;\r\nstruct sctp_bind_addr *bp;\r\nint attempts = asoc->init_err_counter + 1;\r\nif (attempts > asoc->max_init_attempts) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\r\nSCTP_ERROR(ETIMEDOUT));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\r\nSCTP_PERR(SCTP_ERROR_STALE_COOKIE));\r\nreturn SCTP_DISPOSITION_DELETE_TCB;\r\n}\r\nerr = (sctp_errhdr_t *)(chunk->skb->data);\r\nstale = ntohl(*(__be32 *)((u8 *)err + sizeof(sctp_errhdr_t)));\r\nstale = (stale * 2) / 1000;\r\nbht.param_hdr.type = SCTP_PARAM_COOKIE_PRESERVATIVE;\r\nbht.param_hdr.length = htons(sizeof(bht));\r\nbht.lifespan_increment = htonl(stale);\r\nbp = (struct sctp_bind_addr *) &asoc->base.bind_addr;\r\nreply = sctp_make_init(asoc, bp, GFP_ATOMIC, sizeof(bht));\r\nif (!reply)\r\ngoto nomem;\r\nsctp_addto_chunk(reply, sizeof(bht), &bht);\r\nsctp_add_cmd_sf(commands, SCTP_CMD_CLEAR_INIT_TAG, SCTP_NULL());\r\nsctp_add_cmd_sf(commands, SCTP_CMD_T3_RTX_TIMERS_STOP, SCTP_NULL());\r\nsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_STOP, SCTP_NULL());\r\nsctp_add_cmd_sf(commands, SCTP_CMD_DEL_NON_PRIMARY, SCTP_NULL());\r\nsctp_add_cmd_sf(commands, SCTP_CMD_T1_RETRAN,\r\nSCTP_TRANSPORT(asoc->peer.primary_path));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_INIT_COUNTER_INC, SCTP_NULL());\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\r\nSCTP_STATE(SCTP_STATE_COOKIE_WAIT));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\r\nreturn SCTP_DISPOSITION_CONSUME;\r\nnomem:\r\nreturn SCTP_DISPOSITION_NOMEM;\r\n}\r\nsctp_disposition_t sctp_sf_do_9_1_abort(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = arg;\r\nif (!sctp_vtag_verify_either(chunk, asoc))\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_abort_chunk_t)))\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nif (SCTP_ADDR_DEL ==\r\nsctp_bind_addr_state(&asoc->base.bind_addr, &chunk->dest))\r\nreturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\r\nreturn __sctp_sf_do_9_1_abort(net, ep, asoc, type, arg, commands);\r\n}\r\nstatic sctp_disposition_t __sctp_sf_do_9_1_abort(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = arg;\r\nunsigned int len;\r\n__be16 error = SCTP_ERROR_NO_ERROR;\r\nlen = ntohs(chunk->chunk_hdr->length);\r\nif (len >= sizeof(struct sctp_chunkhdr) + sizeof(struct sctp_errhdr)) {\r\nsctp_errhdr_t *err;\r\nsctp_walk_errors(err, chunk->chunk_hdr);\r\nif ((void *)err != (void *)chunk->chunk_end)\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nerror = ((sctp_errhdr_t *)chunk->skb->data)->cause;\r\n}\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR, SCTP_ERROR(ECONNRESET));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED, SCTP_PERR(error));\r\nSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\r\nSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\r\nreturn SCTP_DISPOSITION_ABORT;\r\n}\r\nsctp_disposition_t sctp_sf_cookie_wait_abort(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = arg;\r\nunsigned int len;\r\n__be16 error = SCTP_ERROR_NO_ERROR;\r\nif (!sctp_vtag_verify_either(chunk, asoc))\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_abort_chunk_t)))\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nlen = ntohs(chunk->chunk_hdr->length);\r\nif (len >= sizeof(struct sctp_chunkhdr) + sizeof(struct sctp_errhdr))\r\nerror = ((sctp_errhdr_t *)chunk->skb->data)->cause;\r\nreturn sctp_stop_t1_and_abort(net, commands, error, ECONNREFUSED, asoc,\r\nchunk->transport);\r\n}\r\nsctp_disposition_t sctp_sf_cookie_wait_icmp_abort(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nreturn sctp_stop_t1_and_abort(net, commands, SCTP_ERROR_NO_ERROR,\r\nENOPROTOOPT, asoc,\r\n(struct sctp_transport *)arg);\r\n}\r\nsctp_disposition_t sctp_sf_cookie_echoed_abort(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nreturn sctp_sf_cookie_wait_abort(net, ep, asoc, type, arg, commands);\r\n}\r\nstatic sctp_disposition_t sctp_stop_t1_and_abort(struct net *net,\r\nsctp_cmd_seq_t *commands,\r\n__be16 error, int sk_err,\r\nconst struct sctp_association *asoc,\r\nstruct sctp_transport *transport)\r\n{\r\npr_debug("%s: ABORT received (INIT)\n", __func__);\r\nsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\r\nSCTP_STATE(SCTP_STATE_CLOSED));\r\nSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR, SCTP_ERROR(sk_err));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\r\nSCTP_PERR(error));\r\nreturn SCTP_DISPOSITION_ABORT;\r\n}\r\nsctp_disposition_t sctp_sf_do_9_2_shutdown(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = arg;\r\nsctp_shutdownhdr_t *sdh;\r\nsctp_disposition_t disposition;\r\nstruct sctp_ulpevent *ev;\r\n__u32 ctsn;\r\nif (!sctp_vtag_verify(chunk, asoc))\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nif (!sctp_chunk_length_valid(chunk,\r\nsizeof(struct sctp_shutdown_chunk_t)))\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\nsdh = (sctp_shutdownhdr_t *)chunk->skb->data;\r\nskb_pull(chunk->skb, sizeof(sctp_shutdownhdr_t));\r\nchunk->subh.shutdown_hdr = sdh;\r\nctsn = ntohl(sdh->cum_tsn_ack);\r\nif (TSN_lt(ctsn, asoc->ctsn_ack_point)) {\r\npr_debug("%s: ctsn:%x, ctsn_ack_point:%x\n", __func__, ctsn,\r\nasoc->ctsn_ack_point);\r\nreturn SCTP_DISPOSITION_DISCARD;\r\n}\r\nif (!TSN_lt(ctsn, asoc->next_tsn))\r\nreturn sctp_sf_violation_ctsn(net, ep, asoc, type, arg, commands);\r\nev = sctp_ulpevent_make_shutdown_event(asoc, 0, GFP_ATOMIC);\r\nif (!ev) {\r\ndisposition = SCTP_DISPOSITION_NOMEM;\r\ngoto out;\r\n}\r\nsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\r\nSCTP_STATE(SCTP_STATE_SHUTDOWN_RECEIVED));\r\ndisposition = SCTP_DISPOSITION_CONSUME;\r\nif (sctp_outq_is_empty(&asoc->outqueue)) {\r\ndisposition = sctp_sf_do_9_2_shutdown_ack(net, ep, asoc, type,\r\narg, commands);\r\n}\r\nif (SCTP_DISPOSITION_NOMEM == disposition)\r\ngoto out;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_CTSN,\r\nSCTP_BE32(chunk->subh.shutdown_hdr->cum_tsn_ack));\r\nout:\r\nreturn disposition;\r\n}\r\nsctp_disposition_t sctp_sf_do_9_2_shut_ctsn(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = arg;\r\nsctp_shutdownhdr_t *sdh;\r\n__u32 ctsn;\r\nif (!sctp_vtag_verify(chunk, asoc))\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nif (!sctp_chunk_length_valid(chunk,\r\nsizeof(struct sctp_shutdown_chunk_t)))\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\nsdh = (sctp_shutdownhdr_t *)chunk->skb->data;\r\nctsn = ntohl(sdh->cum_tsn_ack);\r\nif (TSN_lt(ctsn, asoc->ctsn_ack_point)) {\r\npr_debug("%s: ctsn:%x, ctsn_ack_point:%x\n", __func__, ctsn,\r\nasoc->ctsn_ack_point);\r\nreturn SCTP_DISPOSITION_DISCARD;\r\n}\r\nif (!TSN_lt(ctsn, asoc->next_tsn))\r\nreturn sctp_sf_violation_ctsn(net, ep, asoc, type, arg, commands);\r\nsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_CTSN,\r\nSCTP_BE32(sdh->cum_tsn_ack));\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nsctp_disposition_t sctp_sf_do_9_2_reshutack(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = (struct sctp_chunk *) arg;\r\nstruct sctp_chunk *reply;\r\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\nreply = sctp_make_shutdown_ack(asoc, chunk);\r\nif (NULL == reply)\r\ngoto nomem;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\r\nreturn SCTP_DISPOSITION_CONSUME;\r\nnomem:\r\nreturn SCTP_DISPOSITION_NOMEM;\r\n}\r\nsctp_disposition_t sctp_sf_do_ecn_cwr(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nsctp_cwrhdr_t *cwr;\r\nstruct sctp_chunk *chunk = arg;\r\nu32 lowest_tsn;\r\nif (!sctp_vtag_verify(chunk, asoc))\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_ecne_chunk_t)))\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\ncwr = (sctp_cwrhdr_t *) chunk->skb->data;\r\nskb_pull(chunk->skb, sizeof(sctp_cwrhdr_t));\r\nlowest_tsn = ntohl(cwr->lowest_tsn);\r\nif (TSN_lte(asoc->last_ecne_tsn, lowest_tsn)) {\r\nsctp_add_cmd_sf(commands,\r\nSCTP_CMD_ECN_CWR,\r\nSCTP_U32(lowest_tsn));\r\n}\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nsctp_disposition_t sctp_sf_do_ecne(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nsctp_ecnehdr_t *ecne;\r\nstruct sctp_chunk *chunk = arg;\r\nif (!sctp_vtag_verify(chunk, asoc))\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_ecne_chunk_t)))\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\necne = (sctp_ecnehdr_t *) chunk->skb->data;\r\nskb_pull(chunk->skb, sizeof(sctp_ecnehdr_t));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_ECN_ECNE,\r\nSCTP_U32(ntohl(ecne->lowest_tsn)));\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nsctp_disposition_t sctp_sf_eat_data_6_2(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = arg;\r\nsctp_arg_t force = SCTP_NOFORCE();\r\nint error;\r\nif (!sctp_vtag_verify(chunk, asoc)) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\r\nSCTP_NULL());\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\n}\r\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_data_chunk_t)))\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\nerror = sctp_eat_data(asoc, chunk, commands);\r\nswitch (error) {\r\ncase SCTP_IERROR_NO_ERROR:\r\nbreak;\r\ncase SCTP_IERROR_HIGH_TSN:\r\ncase SCTP_IERROR_BAD_STREAM:\r\nSCTP_INC_STATS(net, SCTP_MIB_IN_DATA_CHUNK_DISCARDS);\r\ngoto discard_noforce;\r\ncase SCTP_IERROR_DUP_TSN:\r\ncase SCTP_IERROR_IGNORE_TSN:\r\nSCTP_INC_STATS(net, SCTP_MIB_IN_DATA_CHUNK_DISCARDS);\r\ngoto discard_force;\r\ncase SCTP_IERROR_NO_DATA:\r\ngoto consume;\r\ncase SCTP_IERROR_PROTO_VIOLATION:\r\nreturn sctp_sf_abort_violation(net, ep, asoc, chunk, commands,\r\n(u8 *)chunk->subh.data_hdr, sizeof(sctp_datahdr_t));\r\ndefault:\r\nBUG();\r\n}\r\nif (chunk->chunk_hdr->flags & SCTP_DATA_SACK_IMM)\r\nforce = SCTP_FORCE();\r\nif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE]) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\r\n}\r\nif (chunk->end_of_packet)\r\nsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, force);\r\nreturn SCTP_DISPOSITION_CONSUME;\r\ndiscard_force:\r\nif (chunk->end_of_packet)\r\nsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\r\nreturn SCTP_DISPOSITION_DISCARD;\r\ndiscard_noforce:\r\nif (chunk->end_of_packet)\r\nsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, force);\r\nreturn SCTP_DISPOSITION_DISCARD;\r\nconsume:\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nsctp_disposition_t sctp_sf_eat_data_fast_4_4(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = arg;\r\nint error;\r\nif (!sctp_vtag_verify(chunk, asoc)) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\r\nSCTP_NULL());\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\n}\r\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_data_chunk_t)))\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\nerror = sctp_eat_data(asoc, chunk, commands);\r\nswitch (error) {\r\ncase SCTP_IERROR_NO_ERROR:\r\ncase SCTP_IERROR_HIGH_TSN:\r\ncase SCTP_IERROR_DUP_TSN:\r\ncase SCTP_IERROR_IGNORE_TSN:\r\ncase SCTP_IERROR_BAD_STREAM:\r\nbreak;\r\ncase SCTP_IERROR_NO_DATA:\r\ngoto consume;\r\ncase SCTP_IERROR_PROTO_VIOLATION:\r\nreturn sctp_sf_abort_violation(net, ep, asoc, chunk, commands,\r\n(u8 *)chunk->subh.data_hdr, sizeof(sctp_datahdr_t));\r\ndefault:\r\nBUG();\r\n}\r\nif (chunk->end_of_packet) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SHUTDOWN, SCTP_NULL());\r\nsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\r\n}\r\nconsume:\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nsctp_disposition_t sctp_sf_eat_sack_6_2(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = arg;\r\nsctp_sackhdr_t *sackh;\r\n__u32 ctsn;\r\nif (!sctp_vtag_verify(chunk, asoc))\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_sack_chunk_t)))\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\nsackh = sctp_sm_pull_sack(chunk);\r\nif (!sackh)\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nchunk->subh.sack_hdr = sackh;\r\nctsn = ntohl(sackh->cum_tsn_ack);\r\nif (TSN_lt(ctsn, asoc->ctsn_ack_point)) {\r\npr_debug("%s: ctsn:%x, ctsn_ack_point:%x\n", __func__, ctsn,\r\nasoc->ctsn_ack_point);\r\nreturn SCTP_DISPOSITION_DISCARD;\r\n}\r\nif (!TSN_lt(ctsn, asoc->next_tsn))\r\nreturn sctp_sf_violation_ctsn(net, ep, asoc, type, arg, commands);\r\nsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_SACK, SCTP_CHUNK(chunk));\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nstatic sctp_disposition_t sctp_sf_tabort_8_4_8(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_packet *packet = NULL;\r\nstruct sctp_chunk *chunk = arg;\r\nstruct sctp_chunk *abort;\r\npacket = sctp_ootb_pkt_new(net, asoc, chunk);\r\nif (packet) {\r\nabort = sctp_make_abort(asoc, chunk, 0);\r\nif (!abort) {\r\nsctp_ootb_pkt_free(packet);\r\nreturn SCTP_DISPOSITION_NOMEM;\r\n}\r\nif (sctp_test_T_bit(abort))\r\npacket->vtag = ntohl(chunk->sctp_hdr->vtag);\r\nabort->skb->sk = ep->base.sk;\r\nsctp_packet_append_chunk(packet, abort);\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\r\nSCTP_PACKET(packet));\r\nSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\r\nsctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nreturn SCTP_DISPOSITION_NOMEM;\r\n}\r\nsctp_disposition_t sctp_sf_operr_notify(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = arg;\r\nsctp_errhdr_t *err;\r\nif (!sctp_vtag_verify(chunk, asoc))\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_operr_chunk_t)))\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\nsctp_walk_errors(err, chunk->chunk_hdr);\r\nif ((void *)err != (void *)chunk->chunk_end)\r\nreturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\r\n(void *)err, commands);\r\nsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_OPERR,\r\nSCTP_CHUNK(chunk));\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nsctp_disposition_t sctp_sf_do_9_2_final(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = arg;\r\nstruct sctp_chunk *reply;\r\nstruct sctp_ulpevent *ev;\r\nif (!sctp_vtag_verify(chunk, asoc))\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\nev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_SHUTDOWN_COMP,\r\n0, 0, 0, NULL, GFP_ATOMIC);\r\nif (!ev)\r\ngoto nomem;\r\nreply = sctp_make_shutdown_complete(asoc, chunk);\r\nif (!reply)\r\ngoto nomem_chunk;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\r\nSCTP_STATE(SCTP_STATE_CLOSED));\r\nSCTP_INC_STATS(net, SCTP_MIB_SHUTDOWNS);\r\nSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\r\nreturn SCTP_DISPOSITION_DELETE_TCB;\r\nnomem_chunk:\r\nsctp_ulpevent_free(ev);\r\nnomem:\r\nreturn SCTP_DISPOSITION_NOMEM;\r\n}\r\nsctp_disposition_t sctp_sf_ootb(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = arg;\r\nstruct sk_buff *skb = chunk->skb;\r\nsctp_chunkhdr_t *ch;\r\nsctp_errhdr_t *err;\r\n__u8 *ch_end;\r\nint ootb_shut_ack = 0;\r\nint ootb_cookie_ack = 0;\r\nSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\r\nch = (sctp_chunkhdr_t *) chunk->chunk_hdr;\r\ndo {\r\nif (ntohs(ch->length) < sizeof(sctp_chunkhdr_t))\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\nif (SCTP_CID_SHUTDOWN_ACK == ch->type)\r\nootb_shut_ack = 1;\r\nif (SCTP_CID_ABORT == ch->type)\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nif (SCTP_CID_COOKIE_ACK == ch->type)\r\nootb_cookie_ack = 1;\r\nif (SCTP_CID_ERROR == ch->type) {\r\nsctp_walk_errors(err, ch) {\r\nif (SCTP_ERROR_STALE_COOKIE == err->cause) {\r\nootb_cookie_ack = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\nch_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch->length));\r\nif (ch_end > skb_tail_pointer(skb))\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\nch = (sctp_chunkhdr_t *) ch_end;\r\n} while (ch_end < skb_tail_pointer(skb));\r\nif (ootb_shut_ack)\r\nreturn sctp_sf_shut_8_4_5(net, ep, asoc, type, arg, commands);\r\nelse if (ootb_cookie_ack)\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nelse\r\nreturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\r\n}\r\nstatic sctp_disposition_t sctp_sf_shut_8_4_5(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_packet *packet = NULL;\r\nstruct sctp_chunk *chunk = arg;\r\nstruct sctp_chunk *shut;\r\npacket = sctp_ootb_pkt_new(net, asoc, chunk);\r\nif (packet) {\r\nshut = sctp_make_shutdown_complete(asoc, chunk);\r\nif (!shut) {\r\nsctp_ootb_pkt_free(packet);\r\nreturn SCTP_DISPOSITION_NOMEM;\r\n}\r\nif (sctp_test_T_bit(shut))\r\npacket->vtag = ntohl(chunk->sctp_hdr->vtag);\r\nshut->skb->sk = ep->base.sk;\r\nsctp_packet_append_chunk(packet, shut);\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\r\nSCTP_PACKET(packet));\r\nSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\r\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\n}\r\nreturn SCTP_DISPOSITION_NOMEM;\r\n}\r\nsctp_disposition_t sctp_sf_do_8_5_1_E_sa(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = arg;\r\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\nSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\r\nreturn sctp_sf_shut_8_4_5(net, ep, NULL, type, arg, commands);\r\n}\r\nsctp_disposition_t sctp_sf_do_asconf(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type, void *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = arg;\r\nstruct sctp_chunk *asconf_ack = NULL;\r\nstruct sctp_paramhdr *err_param = NULL;\r\nsctp_addiphdr_t *hdr;\r\n__u32 serial;\r\nif (!sctp_vtag_verify(chunk, asoc)) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\r\nSCTP_NULL());\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\n}\r\nif (!net->sctp.addip_noauth && !chunk->auth)\r\nreturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\r\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_addip_chunk_t)))\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\nhdr = (sctp_addiphdr_t *)chunk->skb->data;\r\nserial = ntohl(hdr->serial);\r\nif (!sctp_verify_asconf(asoc, chunk, true, &err_param))\r\nreturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\r\n(void *)err_param, commands);\r\nif (serial == asoc->peer.addip_serial + 1) {\r\nif (!chunk->has_asconf)\r\nsctp_assoc_clean_asconf_ack_cache(asoc);\r\nasconf_ack = sctp_process_asconf((struct sctp_association *)\r\nasoc, chunk);\r\nif (!asconf_ack)\r\nreturn SCTP_DISPOSITION_NOMEM;\r\n} else if (serial < asoc->peer.addip_serial + 1) {\r\nasconf_ack = sctp_assoc_lookup_asconf_ack(asoc, hdr->serial);\r\nif (!asconf_ack)\r\nreturn SCTP_DISPOSITION_DISCARD;\r\nasconf_ack->transport = NULL;\r\n} else {\r\nreturn SCTP_DISPOSITION_DISCARD;\r\n}\r\nasconf_ack->dest = chunk->source;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(asconf_ack));\r\nif (asoc->new_transport) {\r\nsctp_sf_heartbeat(ep, asoc, type, asoc->new_transport, commands);\r\n((struct sctp_association *)asoc)->new_transport = NULL;\r\n}\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nsctp_disposition_t sctp_sf_do_asconf_ack(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type, void *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *asconf_ack = arg;\r\nstruct sctp_chunk *last_asconf = asoc->addip_last_asconf;\r\nstruct sctp_chunk *abort;\r\nstruct sctp_paramhdr *err_param = NULL;\r\nsctp_addiphdr_t *addip_hdr;\r\n__u32 sent_serial, rcvd_serial;\r\nif (!sctp_vtag_verify(asconf_ack, asoc)) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\r\nSCTP_NULL());\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\n}\r\nif (!net->sctp.addip_noauth && !asconf_ack->auth)\r\nreturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\r\nif (!sctp_chunk_length_valid(asconf_ack, sizeof(sctp_addip_chunk_t)))\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\naddip_hdr = (sctp_addiphdr_t *)asconf_ack->skb->data;\r\nrcvd_serial = ntohl(addip_hdr->serial);\r\nif (!sctp_verify_asconf(asoc, asconf_ack, false, &err_param))\r\nreturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\r\n(void *)err_param, commands);\r\nif (last_asconf) {\r\naddip_hdr = (sctp_addiphdr_t *)last_asconf->subh.addip_hdr;\r\nsent_serial = ntohl(addip_hdr->serial);\r\n} else {\r\nsent_serial = asoc->addip_serial - 1;\r\n}\r\nif (ADDIP_SERIAL_gte(rcvd_serial, sent_serial + 1) &&\r\n!(asoc->addip_last_asconf)) {\r\nabort = sctp_make_abort(asoc, asconf_ack,\r\nsizeof(sctp_errhdr_t));\r\nif (abort) {\r\nsctp_init_cause(abort, SCTP_ERROR_ASCONF_ACK, 0);\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\r\nSCTP_CHUNK(abort));\r\n}\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\r\nSCTP_ERROR(ECONNABORTED));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\r\nSCTP_PERR(SCTP_ERROR_ASCONF_ACK));\r\nSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\r\nSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\r\nreturn SCTP_DISPOSITION_ABORT;\r\n}\r\nif ((rcvd_serial == sent_serial) && asoc->addip_last_asconf) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\r\nif (!sctp_process_asconf_ack((struct sctp_association *)asoc,\r\nasconf_ack)) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SEND_NEXT_ASCONF,\r\nSCTP_NULL());\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nabort = sctp_make_abort(asoc, asconf_ack,\r\nsizeof(sctp_errhdr_t));\r\nif (abort) {\r\nsctp_init_cause(abort, SCTP_ERROR_RSRC_LOW, 0);\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\r\nSCTP_CHUNK(abort));\r\n}\r\nsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\r\nSCTP_ERROR(ECONNABORTED));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\r\nSCTP_PERR(SCTP_ERROR_ASCONF_ACK));\r\nSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\r\nSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\r\nreturn SCTP_DISPOSITION_ABORT;\r\n}\r\nreturn SCTP_DISPOSITION_DISCARD;\r\n}\r\nsctp_disposition_t sctp_sf_eat_fwd_tsn(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = arg;\r\nstruct sctp_fwdtsn_hdr *fwdtsn_hdr;\r\nstruct sctp_fwdtsn_skip *skip;\r\n__u16 len;\r\n__u32 tsn;\r\nif (!sctp_vtag_verify(chunk, asoc)) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\r\nSCTP_NULL());\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\n}\r\nif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_fwdtsn_chunk)))\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\nfwdtsn_hdr = (struct sctp_fwdtsn_hdr *)chunk->skb->data;\r\nchunk->subh.fwdtsn_hdr = fwdtsn_hdr;\r\nlen = ntohs(chunk->chunk_hdr->length);\r\nlen -= sizeof(struct sctp_chunkhdr);\r\nskb_pull(chunk->skb, len);\r\ntsn = ntohl(fwdtsn_hdr->new_cum_tsn);\r\npr_debug("%s: TSN 0x%x\n", __func__, tsn);\r\nif (sctp_tsnmap_check(&asoc->peer.tsn_map, tsn) < 0)\r\ngoto discard_noforce;\r\nsctp_walk_fwdtsn(skip, chunk) {\r\nif (ntohs(skip->stream) >= asoc->c.sinit_max_instreams)\r\ngoto discard_noforce;\r\n}\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_FWDTSN, SCTP_U32(tsn));\r\nif (len > sizeof(struct sctp_fwdtsn_hdr))\r\nsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_FWDTSN,\r\nSCTP_CHUNK(chunk));\r\nif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE]) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\r\n}\r\nsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_NOFORCE());\r\nreturn SCTP_DISPOSITION_CONSUME;\r\ndiscard_noforce:\r\nreturn SCTP_DISPOSITION_DISCARD;\r\n}\r\nsctp_disposition_t sctp_sf_eat_fwd_tsn_fast(\r\nstruct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = arg;\r\nstruct sctp_fwdtsn_hdr *fwdtsn_hdr;\r\nstruct sctp_fwdtsn_skip *skip;\r\n__u16 len;\r\n__u32 tsn;\r\nif (!sctp_vtag_verify(chunk, asoc)) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\r\nSCTP_NULL());\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\n}\r\nif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_fwdtsn_chunk)))\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\nfwdtsn_hdr = (struct sctp_fwdtsn_hdr *)chunk->skb->data;\r\nchunk->subh.fwdtsn_hdr = fwdtsn_hdr;\r\nlen = ntohs(chunk->chunk_hdr->length);\r\nlen -= sizeof(struct sctp_chunkhdr);\r\nskb_pull(chunk->skb, len);\r\ntsn = ntohl(fwdtsn_hdr->new_cum_tsn);\r\npr_debug("%s: TSN 0x%x\n", __func__, tsn);\r\nif (sctp_tsnmap_check(&asoc->peer.tsn_map, tsn) < 0)\r\ngoto gen_shutdown;\r\nsctp_walk_fwdtsn(skip, chunk) {\r\nif (ntohs(skip->stream) >= asoc->c.sinit_max_instreams)\r\ngoto gen_shutdown;\r\n}\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_FWDTSN, SCTP_U32(tsn));\r\nif (len > sizeof(struct sctp_fwdtsn_hdr))\r\nsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_FWDTSN,\r\nSCTP_CHUNK(chunk));\r\ngen_shutdown:\r\nsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SHUTDOWN, SCTP_NULL());\r\nsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nstatic sctp_ierror_t sctp_sf_authenticate(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nstruct sctp_chunk *chunk)\r\n{\r\nstruct sctp_authhdr *auth_hdr;\r\nstruct sctp_hmac *hmac;\r\nunsigned int sig_len;\r\n__u16 key_id;\r\n__u8 *save_digest;\r\n__u8 *digest;\r\nauth_hdr = (struct sctp_authhdr *)chunk->skb->data;\r\nchunk->subh.auth_hdr = auth_hdr;\r\nskb_pull(chunk->skb, sizeof(struct sctp_authhdr));\r\nif (!sctp_auth_asoc_verify_hmac_id(asoc, auth_hdr->hmac_id))\r\nreturn SCTP_IERROR_AUTH_BAD_HMAC;\r\nkey_id = ntohs(auth_hdr->shkey_id);\r\nif (key_id != asoc->active_key_id && !sctp_auth_get_shkey(asoc, key_id))\r\nreturn SCTP_IERROR_AUTH_BAD_KEYID;\r\nsig_len = ntohs(chunk->chunk_hdr->length) - sizeof(sctp_auth_chunk_t);\r\nhmac = sctp_auth_get_hmac(ntohs(auth_hdr->hmac_id));\r\nif (sig_len != hmac->hmac_len)\r\nreturn SCTP_IERROR_PROTO_VIOLATION;\r\ndigest = auth_hdr->hmac;\r\nskb_pull(chunk->skb, sig_len);\r\nsave_digest = kmemdup(digest, sig_len, GFP_ATOMIC);\r\nif (!save_digest)\r\ngoto nomem;\r\nmemset(digest, 0, sig_len);\r\nsctp_auth_calculate_hmac(asoc, chunk->skb,\r\n(struct sctp_auth_chunk *)chunk->chunk_hdr,\r\nGFP_ATOMIC);\r\nif (memcmp(save_digest, digest, sig_len)) {\r\nkfree(save_digest);\r\nreturn SCTP_IERROR_BAD_SIG;\r\n}\r\nkfree(save_digest);\r\nchunk->auth = 1;\r\nreturn SCTP_IERROR_NO_ERROR;\r\nnomem:\r\nreturn SCTP_IERROR_NOMEM;\r\n}\r\nsctp_disposition_t sctp_sf_eat_auth(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_authhdr *auth_hdr;\r\nstruct sctp_chunk *chunk = arg;\r\nstruct sctp_chunk *err_chunk;\r\nsctp_ierror_t error;\r\nif (!asoc->peer.auth_capable)\r\nreturn sctp_sf_unk_chunk(net, ep, asoc, type, arg, commands);\r\nif (!sctp_vtag_verify(chunk, asoc)) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\r\nSCTP_NULL());\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\n}\r\nif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_auth_chunk)))\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\nauth_hdr = (struct sctp_authhdr *)chunk->skb->data;\r\nerror = sctp_sf_authenticate(net, ep, asoc, type, chunk);\r\nswitch (error) {\r\ncase SCTP_IERROR_AUTH_BAD_HMAC:\r\nerr_chunk = sctp_make_op_error(asoc, chunk,\r\nSCTP_ERROR_UNSUP_HMAC,\r\n&auth_hdr->hmac_id,\r\nsizeof(__u16), 0);\r\nif (err_chunk) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\r\nSCTP_CHUNK(err_chunk));\r\n}\r\ncase SCTP_IERROR_AUTH_BAD_KEYID:\r\ncase SCTP_IERROR_BAD_SIG:\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\ncase SCTP_IERROR_PROTO_VIOLATION:\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\ncase SCTP_IERROR_NOMEM:\r\nreturn SCTP_DISPOSITION_NOMEM;\r\ndefault:\r\nbreak;\r\n}\r\nif (asoc->active_key_id != ntohs(auth_hdr->shkey_id)) {\r\nstruct sctp_ulpevent *ev;\r\nev = sctp_ulpevent_make_authkey(asoc, ntohs(auth_hdr->shkey_id),\r\nSCTP_AUTH_NEWKEY, GFP_ATOMIC);\r\nif (!ev)\r\nreturn -ENOMEM;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\r\nSCTP_ULPEVENT(ev));\r\n}\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nsctp_disposition_t sctp_sf_unk_chunk(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *unk_chunk = arg;\r\nstruct sctp_chunk *err_chunk;\r\nsctp_chunkhdr_t *hdr;\r\npr_debug("%s: processing unknown chunk id:%d\n", __func__, type.chunk);\r\nif (!sctp_vtag_verify(unk_chunk, asoc))\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nif (!sctp_chunk_length_valid(unk_chunk, sizeof(sctp_chunkhdr_t)))\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\nswitch (type.chunk & SCTP_CID_ACTION_MASK) {\r\ncase SCTP_CID_ACTION_DISCARD:\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\ncase SCTP_CID_ACTION_DISCARD_ERR:\r\nhdr = unk_chunk->chunk_hdr;\r\nerr_chunk = sctp_make_op_error(asoc, unk_chunk,\r\nSCTP_ERROR_UNKNOWN_CHUNK, hdr,\r\nWORD_ROUND(ntohs(hdr->length)),\r\n0);\r\nif (err_chunk) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\r\nSCTP_CHUNK(err_chunk));\r\n}\r\nsctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nreturn SCTP_DISPOSITION_CONSUME;\r\ncase SCTP_CID_ACTION_SKIP:\r\nreturn SCTP_DISPOSITION_DISCARD;\r\ncase SCTP_CID_ACTION_SKIP_ERR:\r\nhdr = unk_chunk->chunk_hdr;\r\nerr_chunk = sctp_make_op_error(asoc, unk_chunk,\r\nSCTP_ERROR_UNKNOWN_CHUNK, hdr,\r\nWORD_ROUND(ntohs(hdr->length)),\r\n0);\r\nif (err_chunk) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\r\nSCTP_CHUNK(err_chunk));\r\n}\r\nreturn SCTP_DISPOSITION_CONSUME;\r\ndefault:\r\nbreak;\r\n}\r\nreturn SCTP_DISPOSITION_DISCARD;\r\n}\r\nsctp_disposition_t sctp_sf_discard_chunk(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = arg;\r\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\npr_debug("%s: chunk:%d is discarded\n", __func__, type.chunk);\r\nreturn SCTP_DISPOSITION_DISCARD;\r\n}\r\nsctp_disposition_t sctp_sf_pdiscard(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nSCTP_INC_STATS(net, SCTP_MIB_IN_PKT_DISCARDS);\r\nsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nsctp_disposition_t sctp_sf_violation(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = arg;\r\nif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\nreturn SCTP_DISPOSITION_VIOLATION;\r\n}\r\nstatic sctp_disposition_t sctp_sf_abort_violation(\r\nstruct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands,\r\nconst __u8 *payload,\r\nconst size_t paylen)\r\n{\r\nstruct sctp_packet *packet = NULL;\r\nstruct sctp_chunk *chunk = arg;\r\nstruct sctp_chunk *abort = NULL;\r\nif (sctp_auth_recv_cid(SCTP_CID_ABORT, asoc))\r\ngoto discard;\r\nabort = sctp_make_abort_violation(asoc, chunk, payload, paylen);\r\nif (!abort)\r\ngoto nomem;\r\nif (asoc) {\r\nif (chunk->chunk_hdr->type == SCTP_CID_INIT_ACK &&\r\n!asoc->peer.i.init_tag) {\r\nsctp_initack_chunk_t *initack;\r\ninitack = (sctp_initack_chunk_t *)chunk->chunk_hdr;\r\nif (!sctp_chunk_length_valid(chunk,\r\nsizeof(sctp_initack_chunk_t)))\r\nabort->chunk_hdr->flags |= SCTP_CHUNK_FLAG_T;\r\nelse {\r\nunsigned int inittag;\r\ninittag = ntohl(initack->init_hdr.init_tag);\r\nsctp_add_cmd_sf(commands, SCTP_CMD_UPDATE_INITTAG,\r\nSCTP_U32(inittag));\r\n}\r\n}\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\r\nSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\r\nif (asoc->state <= SCTP_STATE_COOKIE_ECHOED) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\r\nSCTP_ERROR(ECONNREFUSED));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\r\nSCTP_PERR(SCTP_ERROR_PROTO_VIOLATION));\r\n} else {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\r\nSCTP_ERROR(ECONNABORTED));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\r\nSCTP_PERR(SCTP_ERROR_PROTO_VIOLATION));\r\nSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\r\n}\r\n} else {\r\npacket = sctp_ootb_pkt_new(net, asoc, chunk);\r\nif (!packet)\r\ngoto nomem_pkt;\r\nif (sctp_test_T_bit(abort))\r\npacket->vtag = ntohl(chunk->sctp_hdr->vtag);\r\nabort->skb->sk = ep->base.sk;\r\nsctp_packet_append_chunk(packet, abort);\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\r\nSCTP_PACKET(packet));\r\nSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\r\n}\r\nSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\r\ndiscard:\r\nsctp_sf_pdiscard(net, ep, asoc, SCTP_ST_CHUNK(0), arg, commands);\r\nreturn SCTP_DISPOSITION_ABORT;\r\nnomem_pkt:\r\nsctp_chunk_free(abort);\r\nnomem:\r\nreturn SCTP_DISPOSITION_NOMEM;\r\n}\r\nstatic sctp_disposition_t sctp_sf_violation_chunklen(\r\nstruct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstatic const char err_str[] = "The following chunk had invalid length:";\r\nreturn sctp_sf_abort_violation(net, ep, asoc, arg, commands, err_str,\r\nsizeof(err_str));\r\n}\r\nstatic sctp_disposition_t sctp_sf_violation_paramlen(\r\nstruct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg, void *ext,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = arg;\r\nstruct sctp_paramhdr *param = ext;\r\nstruct sctp_chunk *abort = NULL;\r\nif (sctp_auth_recv_cid(SCTP_CID_ABORT, asoc))\r\ngoto discard;\r\nabort = sctp_make_violation_paramlen(asoc, chunk, param);\r\nif (!abort)\r\ngoto nomem;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\r\nSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\r\nSCTP_ERROR(ECONNABORTED));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\r\nSCTP_PERR(SCTP_ERROR_PROTO_VIOLATION));\r\nSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\r\nSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\r\ndiscard:\r\nsctp_sf_pdiscard(net, ep, asoc, SCTP_ST_CHUNK(0), arg, commands);\r\nreturn SCTP_DISPOSITION_ABORT;\r\nnomem:\r\nreturn SCTP_DISPOSITION_NOMEM;\r\n}\r\nstatic sctp_disposition_t sctp_sf_violation_ctsn(\r\nstruct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstatic const char err_str[] = "The cumulative tsn ack beyond the max tsn currently sent:";\r\nreturn sctp_sf_abort_violation(net, ep, asoc, arg, commands, err_str,\r\nsizeof(err_str));\r\n}\r\nstatic sctp_disposition_t sctp_sf_violation_chunk(\r\nstruct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstatic const char err_str[] = "The following chunk violates protocol:";\r\nif (!asoc)\r\nreturn sctp_sf_violation(net, ep, asoc, type, arg, commands);\r\nreturn sctp_sf_abort_violation(net, ep, asoc, arg, commands, err_str,\r\nsizeof(err_str));\r\n}\r\nsctp_disposition_t sctp_sf_do_prm_asoc(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *repl;\r\nstruct sctp_association *my_asoc;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\r\nSCTP_STATE(SCTP_STATE_COOKIE_WAIT));\r\nrepl = sctp_make_init(asoc, &asoc->base.bind_addr, GFP_ATOMIC, 0);\r\nif (!repl)\r\ngoto nomem;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_INIT_CHOOSE_TRANSPORT,\r\nSCTP_CHUNK(repl));\r\nmy_asoc = (struct sctp_association *)asoc;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(my_asoc));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\r\nreturn SCTP_DISPOSITION_CONSUME;\r\nnomem:\r\nreturn SCTP_DISPOSITION_NOMEM;\r\n}\r\nsctp_disposition_t sctp_sf_do_prm_send(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_datamsg *msg = arg;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SEND_MSG, SCTP_DATAMSG(msg));\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nsctp_disposition_t sctp_sf_do_9_2_prm_shutdown(\r\nstruct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nint disposition;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\r\nSCTP_STATE(SCTP_STATE_SHUTDOWN_PENDING));\r\ndisposition = SCTP_DISPOSITION_CONSUME;\r\nif (sctp_outq_is_empty(&asoc->outqueue)) {\r\ndisposition = sctp_sf_do_9_2_start_shutdown(net, ep, asoc, type,\r\narg, commands);\r\n}\r\nreturn disposition;\r\n}\r\nsctp_disposition_t sctp_sf_do_9_1_prm_abort(\r\nstruct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *abort = arg;\r\nsctp_disposition_t retval;\r\nretval = SCTP_DISPOSITION_CONSUME;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\r\nSCTP_ERROR(ECONNABORTED));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\r\nSCTP_PERR(SCTP_ERROR_USER_ABORT));\r\nSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\r\nSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\r\nreturn retval;\r\n}\r\nsctp_disposition_t sctp_sf_error_closed(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_ERROR, SCTP_ERROR(-EINVAL));\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nsctp_disposition_t sctp_sf_error_shutdown(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_ERROR,\r\nSCTP_ERROR(-ESHUTDOWN));\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nsctp_disposition_t sctp_sf_cookie_wait_prm_shutdown(\r\nstruct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\r\nSCTP_STATE(SCTP_STATE_CLOSED));\r\nSCTP_INC_STATS(net, SCTP_MIB_SHUTDOWNS);\r\nsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\r\nreturn SCTP_DISPOSITION_DELETE_TCB;\r\n}\r\nsctp_disposition_t sctp_sf_cookie_echoed_prm_shutdown(\r\nstruct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg, sctp_cmd_seq_t *commands)\r\n{\r\nreturn sctp_sf_cookie_wait_prm_shutdown(net, ep, asoc, type, arg, commands);\r\n}\r\nsctp_disposition_t sctp_sf_cookie_wait_prm_abort(\r\nstruct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *abort = arg;\r\nsctp_disposition_t retval;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\r\nretval = SCTP_DISPOSITION_CONSUME;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\r\nSCTP_STATE(SCTP_STATE_CLOSED));\r\nSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\r\nSCTP_ERROR(ECONNREFUSED));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\r\nSCTP_PERR(SCTP_ERROR_USER_ABORT));\r\nreturn retval;\r\n}\r\nsctp_disposition_t sctp_sf_cookie_echoed_prm_abort(\r\nstruct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nreturn sctp_sf_cookie_wait_prm_abort(net, ep, asoc, type, arg, commands);\r\n}\r\nsctp_disposition_t sctp_sf_shutdown_pending_prm_abort(\r\nstruct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\r\nreturn sctp_sf_do_9_1_prm_abort(net, ep, asoc, type, arg, commands);\r\n}\r\nsctp_disposition_t sctp_sf_shutdown_sent_prm_abort(\r\nstruct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\r\nreturn sctp_sf_do_9_1_prm_abort(net, ep, asoc, type, arg, commands);\r\n}\r\nsctp_disposition_t sctp_sf_shutdown_ack_sent_prm_abort(\r\nstruct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nreturn sctp_sf_shutdown_sent_prm_abort(net, ep, asoc, type, arg, commands);\r\n}\r\nsctp_disposition_t sctp_sf_do_prm_requestheartbeat(\r\nstruct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nif (SCTP_DISPOSITION_NOMEM == sctp_sf_heartbeat(ep, asoc, type,\r\n(struct sctp_transport *)arg, commands))\r\nreturn SCTP_DISPOSITION_NOMEM;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_HB_SENT,\r\nSCTP_TRANSPORT(arg));\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nsctp_disposition_t sctp_sf_do_prm_asconf(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = arg;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T4, SCTP_CHUNK(chunk));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(chunk));\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nsctp_disposition_t sctp_sf_ignore_primitive(\r\nstruct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\npr_debug("%s: primitive type:%d is ignored\n", __func__,\r\ntype.primitive);\r\nreturn SCTP_DISPOSITION_DISCARD;\r\n}\r\nsctp_disposition_t sctp_sf_do_no_pending_tsn(\r\nstruct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_ulpevent *event;\r\nevent = sctp_ulpevent_make_sender_dry_event(asoc, GFP_ATOMIC);\r\nif (!event)\r\nreturn SCTP_DISPOSITION_NOMEM;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(event));\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nsctp_disposition_t sctp_sf_do_9_2_start_shutdown(\r\nstruct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *reply;\r\nreply = sctp_make_shutdown(asoc, NULL);\r\nif (!reply)\r\ngoto nomem;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\r\nif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\r\nSCTP_STATE(SCTP_STATE_SHUTDOWN_SENT));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_STOP, SCTP_NULL());\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\r\nreturn SCTP_DISPOSITION_CONSUME;\r\nnomem:\r\nreturn SCTP_DISPOSITION_NOMEM;\r\n}\r\nsctp_disposition_t sctp_sf_do_9_2_shutdown_ack(\r\nstruct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = (struct sctp_chunk *) arg;\r\nstruct sctp_chunk *reply;\r\nif (chunk) {\r\nif (!sctp_vtag_verify(chunk, asoc))\r\nreturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\r\nif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_shutdown_chunk_t)))\r\nreturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\r\ncommands);\r\n}\r\nreply = sctp_make_shutdown_ack(asoc, chunk);\r\nif (!reply)\r\ngoto nomem;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\r\nif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\r\nSCTP_STATE(SCTP_STATE_SHUTDOWN_ACK_SENT));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_STOP, SCTP_NULL());\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\r\nreturn SCTP_DISPOSITION_CONSUME;\r\nnomem:\r\nreturn SCTP_DISPOSITION_NOMEM;\r\n}\r\nsctp_disposition_t sctp_sf_ignore_other(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\npr_debug("%s: the event other type:%d is ignored\n",\r\n__func__, type.other);\r\nreturn SCTP_DISPOSITION_DISCARD;\r\n}\r\nsctp_disposition_t sctp_sf_do_6_3_3_rtx(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_transport *transport = arg;\r\nSCTP_INC_STATS(net, SCTP_MIB_T3_RTX_EXPIREDS);\r\nif (asoc->overall_error_count >= asoc->max_retrans) {\r\nif (asoc->state == SCTP_STATE_SHUTDOWN_PENDING) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START_ONCE,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\r\n} else {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\r\nSCTP_ERROR(ETIMEDOUT));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\r\nSCTP_PERR(SCTP_ERROR_NO_ERROR));\r\nSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\r\nSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\r\nreturn SCTP_DISPOSITION_DELETE_TCB;\r\n}\r\n}\r\nsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE, SCTP_TRANSPORT(transport));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_RETRAN, SCTP_TRANSPORT(transport));\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nsctp_disposition_t sctp_sf_do_6_2_sack(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nSCTP_INC_STATS(net, SCTP_MIB_DELAY_SACK_EXPIREDS);\r\nsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nsctp_disposition_t sctp_sf_t1_init_timer_expire(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *repl = NULL;\r\nstruct sctp_bind_addr *bp;\r\nint attempts = asoc->init_err_counter + 1;\r\npr_debug("%s: timer T1 expired (INIT)\n", __func__);\r\nSCTP_INC_STATS(net, SCTP_MIB_T1_INIT_EXPIREDS);\r\nif (attempts <= asoc->max_init_attempts) {\r\nbp = (struct sctp_bind_addr *) &asoc->base.bind_addr;\r\nrepl = sctp_make_init(asoc, bp, GFP_ATOMIC, 0);\r\nif (!repl)\r\nreturn SCTP_DISPOSITION_NOMEM;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_INIT_CHOOSE_TRANSPORT,\r\nSCTP_CHUNK(repl));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_INIT_RESTART,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\r\n} else {\r\npr_debug("%s: giving up on INIT, attempts:%d "\r\n"max_init_attempts:%d\n", __func__, attempts,\r\nasoc->max_init_attempts);\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\r\nSCTP_ERROR(ETIMEDOUT));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\r\nSCTP_PERR(SCTP_ERROR_NO_ERROR));\r\nreturn SCTP_DISPOSITION_DELETE_TCB;\r\n}\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nsctp_disposition_t sctp_sf_t1_cookie_timer_expire(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *repl = NULL;\r\nint attempts = asoc->init_err_counter + 1;\r\npr_debug("%s: timer T1 expired (COOKIE-ECHO)\n", __func__);\r\nSCTP_INC_STATS(net, SCTP_MIB_T1_COOKIE_EXPIREDS);\r\nif (attempts <= asoc->max_init_attempts) {\r\nrepl = sctp_make_cookie_echo(asoc, NULL);\r\nif (!repl)\r\nreturn SCTP_DISPOSITION_NOMEM;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_INIT_CHOOSE_TRANSPORT,\r\nSCTP_CHUNK(repl));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_COOKIEECHO_RESTART,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\r\n} else {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\r\nSCTP_ERROR(ETIMEDOUT));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\r\nSCTP_PERR(SCTP_ERROR_NO_ERROR));\r\nreturn SCTP_DISPOSITION_DELETE_TCB;\r\n}\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nsctp_disposition_t sctp_sf_t2_timer_expire(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *reply = NULL;\r\npr_debug("%s: timer T2 expired\n", __func__);\r\nSCTP_INC_STATS(net, SCTP_MIB_T2_SHUTDOWN_EXPIREDS);\r\n((struct sctp_association *)asoc)->shutdown_retries++;\r\nif (asoc->overall_error_count >= asoc->max_retrans) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\r\nSCTP_ERROR(ETIMEDOUT));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\r\nSCTP_PERR(SCTP_ERROR_NO_ERROR));\r\nSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\r\nSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\r\nreturn SCTP_DISPOSITION_DELETE_TCB;\r\n}\r\nswitch (asoc->state) {\r\ncase SCTP_STATE_SHUTDOWN_SENT:\r\nreply = sctp_make_shutdown(asoc, NULL);\r\nbreak;\r\ncase SCTP_STATE_SHUTDOWN_ACK_SENT:\r\nreply = sctp_make_shutdown_ack(asoc, NULL);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nif (!reply)\r\ngoto nomem;\r\nif (asoc->shutdown_last_sent_to)\r\nsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE,\r\nSCTP_TRANSPORT(asoc->shutdown_last_sent_to));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\r\nreturn SCTP_DISPOSITION_CONSUME;\r\nnomem:\r\nreturn SCTP_DISPOSITION_NOMEM;\r\n}\r\nsctp_disposition_t sctp_sf_t4_timer_expire(\r\nstruct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *chunk = asoc->addip_last_asconf;\r\nstruct sctp_transport *transport = chunk->transport;\r\nSCTP_INC_STATS(net, SCTP_MIB_T4_RTO_EXPIREDS);\r\nif (transport)\r\nsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE,\r\nSCTP_TRANSPORT(transport));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T4, SCTP_CHUNK(chunk));\r\nif (asoc->overall_error_count >= asoc->max_retrans) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\r\nSCTP_ERROR(ETIMEDOUT));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\r\nSCTP_PERR(SCTP_ERROR_NO_ERROR));\r\nSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\r\nSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\r\nreturn SCTP_DISPOSITION_ABORT;\r\n}\r\nsctp_chunk_hold(asoc->addip_last_asconf);\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\r\nSCTP_CHUNK(asoc->addip_last_asconf));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nsctp_disposition_t sctp_sf_t5_timer_expire(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nstruct sctp_chunk *reply = NULL;\r\npr_debug("%s: timer T5 expired\n", __func__);\r\nSCTP_INC_STATS(net, SCTP_MIB_T5_SHUTDOWN_GUARD_EXPIREDS);\r\nreply = sctp_make_abort(asoc, NULL, 0);\r\nif (!reply)\r\ngoto nomem;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\r\nSCTP_ERROR(ETIMEDOUT));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\r\nSCTP_PERR(SCTP_ERROR_NO_ERROR));\r\nSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\r\nSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\r\nreturn SCTP_DISPOSITION_DELETE_TCB;\r\nnomem:\r\nreturn SCTP_DISPOSITION_NOMEM;\r\n}\r\nsctp_disposition_t sctp_sf_autoclose_timer_expire(\r\nstruct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nint disposition;\r\nSCTP_INC_STATS(net, SCTP_MIB_AUTOCLOSE_EXPIREDS);\r\nsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\r\nSCTP_STATE(SCTP_STATE_SHUTDOWN_PENDING));\r\ndisposition = SCTP_DISPOSITION_CONSUME;\r\nif (sctp_outq_is_empty(&asoc->outqueue)) {\r\ndisposition = sctp_sf_do_9_2_start_shutdown(net, ep, asoc, type,\r\narg, commands);\r\n}\r\nreturn disposition;\r\n}\r\nsctp_disposition_t sctp_sf_not_impl(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nreturn SCTP_DISPOSITION_NOT_IMPL;\r\n}\r\nsctp_disposition_t sctp_sf_bug(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nreturn SCTP_DISPOSITION_BUG;\r\n}\r\nsctp_disposition_t sctp_sf_timer_ignore(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst sctp_subtype_t type,\r\nvoid *arg,\r\nsctp_cmd_seq_t *commands)\r\n{\r\npr_debug("%s: timer %d ignored\n", __func__, type.chunk);\r\nreturn SCTP_DISPOSITION_CONSUME;\r\n}\r\nstatic struct sctp_sackhdr *sctp_sm_pull_sack(struct sctp_chunk *chunk)\r\n{\r\nstruct sctp_sackhdr *sack;\r\nunsigned int len;\r\n__u16 num_blocks;\r\n__u16 num_dup_tsns;\r\nsack = (struct sctp_sackhdr *) chunk->skb->data;\r\nnum_blocks = ntohs(sack->num_gap_ack_blocks);\r\nnum_dup_tsns = ntohs(sack->num_dup_tsns);\r\nlen = sizeof(struct sctp_sackhdr);\r\nlen += (num_blocks + num_dup_tsns) * sizeof(__u32);\r\nif (len > chunk->skb->len)\r\nreturn NULL;\r\nskb_pull(chunk->skb, len);\r\nreturn sack;\r\n}\r\nstatic struct sctp_packet *sctp_abort_pkt_new(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nstruct sctp_chunk *chunk,\r\nconst void *payload,\r\nsize_t paylen)\r\n{\r\nstruct sctp_packet *packet;\r\nstruct sctp_chunk *abort;\r\npacket = sctp_ootb_pkt_new(net, asoc, chunk);\r\nif (packet) {\r\nabort = sctp_make_abort(asoc, chunk, paylen);\r\nif (!abort) {\r\nsctp_ootb_pkt_free(packet);\r\nreturn NULL;\r\n}\r\nif (sctp_test_T_bit(abort))\r\npacket->vtag = ntohl(chunk->sctp_hdr->vtag);\r\nsctp_addto_chunk(abort, paylen, payload);\r\nabort->skb->sk = ep->base.sk;\r\nsctp_packet_append_chunk(packet, abort);\r\n}\r\nreturn packet;\r\n}\r\nstatic struct sctp_packet *sctp_ootb_pkt_new(struct net *net,\r\nconst struct sctp_association *asoc,\r\nconst struct sctp_chunk *chunk)\r\n{\r\nstruct sctp_packet *packet;\r\nstruct sctp_transport *transport;\r\n__u16 sport;\r\n__u16 dport;\r\n__u32 vtag;\r\nsport = ntohs(chunk->sctp_hdr->dest);\r\ndport = ntohs(chunk->sctp_hdr->source);\r\nif (asoc) {\r\nswitch (chunk->chunk_hdr->type) {\r\ncase SCTP_CID_INIT_ACK:\r\n{\r\nsctp_initack_chunk_t *initack;\r\ninitack = (sctp_initack_chunk_t *)chunk->chunk_hdr;\r\nvtag = ntohl(initack->init_hdr.init_tag);\r\nbreak;\r\n}\r\ndefault:\r\nvtag = asoc->peer.i.init_tag;\r\nbreak;\r\n}\r\n} else {\r\nswitch (chunk->chunk_hdr->type) {\r\ncase SCTP_CID_INIT:\r\n{\r\nsctp_init_chunk_t *init;\r\ninit = (sctp_init_chunk_t *)chunk->chunk_hdr;\r\nvtag = ntohl(init->init_hdr.init_tag);\r\nbreak;\r\n}\r\ndefault:\r\nvtag = ntohl(chunk->sctp_hdr->vtag);\r\nbreak;\r\n}\r\n}\r\ntransport = sctp_transport_new(net, sctp_source(chunk), GFP_ATOMIC);\r\nif (!transport)\r\ngoto nomem;\r\nsctp_transport_route(transport, (union sctp_addr *)&chunk->dest,\r\nsctp_sk(net->sctp.ctl_sock));\r\npacket = sctp_packet_init(&transport->packet, transport, sport, dport);\r\npacket = sctp_packet_config(packet, vtag, 0);\r\nreturn packet;\r\nnomem:\r\nreturn NULL;\r\n}\r\nvoid sctp_ootb_pkt_free(struct sctp_packet *packet)\r\n{\r\nsctp_transport_free(packet->transport);\r\n}\r\nstatic void sctp_send_stale_cookie_err(struct net *net,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst struct sctp_chunk *chunk,\r\nsctp_cmd_seq_t *commands,\r\nstruct sctp_chunk *err_chunk)\r\n{\r\nstruct sctp_packet *packet;\r\nif (err_chunk) {\r\npacket = sctp_ootb_pkt_new(net, asoc, chunk);\r\nif (packet) {\r\nstruct sctp_signed_cookie *cookie;\r\ncookie = chunk->subh.cookie_hdr;\r\npacket->vtag = cookie->c.peer_vtag;\r\nerr_chunk->skb->sk = ep->base.sk;\r\nsctp_packet_append_chunk(packet, err_chunk);\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\r\nSCTP_PACKET(packet));\r\nSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\r\n} else\r\nsctp_chunk_free (err_chunk);\r\n}\r\n}\r\nstatic int sctp_eat_data(const struct sctp_association *asoc,\r\nstruct sctp_chunk *chunk,\r\nsctp_cmd_seq_t *commands)\r\n{\r\nsctp_datahdr_t *data_hdr;\r\nstruct sctp_chunk *err;\r\nsize_t datalen;\r\nsctp_verb_t deliver;\r\nint tmp;\r\n__u32 tsn;\r\nstruct sctp_tsnmap *map = (struct sctp_tsnmap *)&asoc->peer.tsn_map;\r\nstruct sock *sk = asoc->base.sk;\r\nstruct net *net = sock_net(sk);\r\nu16 ssn;\r\nu16 sid;\r\nu8 ordered = 0;\r\ndata_hdr = chunk->subh.data_hdr = (sctp_datahdr_t *)chunk->skb->data;\r\nskb_pull(chunk->skb, sizeof(sctp_datahdr_t));\r\ntsn = ntohl(data_hdr->tsn);\r\npr_debug("%s: TSN 0x%x\n", __func__, tsn);\r\nif (!chunk->ecn_ce_done) {\r\nstruct sctp_af *af;\r\nchunk->ecn_ce_done = 1;\r\naf = sctp_get_af_specific(\r\nipver2af(ip_hdr(chunk->skb)->version));\r\nif (af && af->is_ce(chunk->skb) && asoc->peer.ecn_capable) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_ECN_CE,\r\nSCTP_U32(tsn));\r\n}\r\n}\r\ntmp = sctp_tsnmap_check(&asoc->peer.tsn_map, tsn);\r\nif (tmp < 0) {\r\nif (chunk->asoc)\r\nchunk->asoc->stats.outofseqtsns++;\r\nreturn SCTP_IERROR_HIGH_TSN;\r\n} else if (tmp > 0) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_DUP, SCTP_U32(tsn));\r\nreturn SCTP_IERROR_DUP_TSN;\r\n}\r\ndatalen = ntohs(chunk->chunk_hdr->length);\r\ndatalen -= sizeof(sctp_data_chunk_t);\r\ndeliver = SCTP_CMD_CHUNK_ULP;\r\nif ((datalen >= asoc->rwnd) && (!asoc->ulpq.pd_mode)) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_PART_DELIVER, SCTP_NULL());\r\n}\r\nif ((!chunk->data_accepted) && (!asoc->rwnd || asoc->rwnd_over ||\r\n(datalen > asoc->rwnd + asoc->frag_point))) {\r\nif (sctp_tsnmap_has_gap(map) &&\r\n(sctp_tsnmap_get_ctsn(map) + 1) == tsn) {\r\npr_debug("%s: reneging for tsn:%u\n", __func__, tsn);\r\ndeliver = SCTP_CMD_RENEGE;\r\n} else {\r\npr_debug("%s: discard tsn:%u len:%zu, rwnd:%d\n",\r\n__func__, tsn, datalen, asoc->rwnd);\r\nreturn SCTP_IERROR_IGNORE_TSN;\r\n}\r\n}\r\nif (*sk->sk_prot_creator->memory_pressure) {\r\nif (sctp_tsnmap_has_gap(map) &&\r\n(sctp_tsnmap_get_ctsn(map) + 1) == tsn) {\r\npr_debug("%s: under pressure, reneging for tsn:%u\n",\r\n__func__, tsn);\r\ndeliver = SCTP_CMD_RENEGE;\r\n}\r\n}\r\nif (unlikely(0 == datalen)) {\r\nerr = sctp_make_abort_no_data(asoc, chunk, tsn);\r\nif (err) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\r\nSCTP_CHUNK(err));\r\n}\r\nsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\r\nsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\r\nSCTP_ERROR(ECONNABORTED));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\r\nSCTP_PERR(SCTP_ERROR_NO_DATA));\r\nSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\r\nSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\r\nreturn SCTP_IERROR_NO_DATA;\r\n}\r\nchunk->data_accepted = 1;\r\nif (chunk->chunk_hdr->flags & SCTP_DATA_UNORDERED) {\r\nSCTP_INC_STATS(net, SCTP_MIB_INUNORDERCHUNKS);\r\nif (chunk->asoc)\r\nchunk->asoc->stats.iuodchunks++;\r\n} else {\r\nSCTP_INC_STATS(net, SCTP_MIB_INORDERCHUNKS);\r\nif (chunk->asoc)\r\nchunk->asoc->stats.iodchunks++;\r\nordered = 1;\r\n}\r\nsid = ntohs(data_hdr->stream);\r\nif (sid >= asoc->c.sinit_max_instreams) {\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_TSN, SCTP_U32(tsn));\r\nerr = sctp_make_op_error(asoc, chunk, SCTP_ERROR_INV_STRM,\r\n&data_hdr->stream,\r\nsizeof(data_hdr->stream),\r\nsizeof(u16));\r\nif (err)\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\r\nSCTP_CHUNK(err));\r\nreturn SCTP_IERROR_BAD_STREAM;\r\n}\r\nssn = ntohs(data_hdr->ssn);\r\nif (ordered && SSN_lt(ssn, sctp_ssn_peek(&asoc->ssnmap->in, sid))) {\r\nreturn SCTP_IERROR_PROTO_VIOLATION;\r\n}\r\nsctp_add_cmd_sf(commands, deliver, SCTP_CHUNK(chunk));\r\nreturn SCTP_IERROR_NO_ERROR;\r\n}
