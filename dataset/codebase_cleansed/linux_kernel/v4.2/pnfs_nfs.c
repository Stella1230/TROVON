void pnfs_generic_rw_release(void *data)\r\n{\r\nstruct nfs_pgio_header *hdr = data;\r\nnfs_put_client(hdr->ds_clp);\r\nhdr->mds_ops->rpc_release(data);\r\n}\r\nvoid pnfs_generic_prepare_to_resend_writes(struct nfs_commit_data *data)\r\n{\r\nstruct nfs_page *first = nfs_list_entry(data->pages.next);\r\ndata->task.tk_status = 0;\r\nmemcpy(&data->verf.verifier, &first->wb_verf,\r\nsizeof(data->verf.verifier));\r\ndata->verf.verifier.data[0]++;\r\n}\r\nvoid pnfs_generic_write_commit_done(struct rpc_task *task, void *data)\r\n{\r\nstruct nfs_commit_data *wdata = data;\r\nwdata->mds_ops->rpc_call_done(task, data);\r\n}\r\nvoid pnfs_generic_commit_release(void *calldata)\r\n{\r\nstruct nfs_commit_data *data = calldata;\r\ndata->completion_ops->completion(data);\r\npnfs_put_lseg(data->lseg);\r\nnfs_put_client(data->ds_clp);\r\nnfs_commitdata_release(data);\r\n}\r\nvoid\r\npnfs_generic_clear_request_commit(struct nfs_page *req,\r\nstruct nfs_commit_info *cinfo)\r\n{\r\nstruct pnfs_layout_segment *freeme = NULL;\r\nif (!test_and_clear_bit(PG_COMMIT_TO_DS, &req->wb_flags))\r\ngoto out;\r\ncinfo->ds->nwritten--;\r\nif (list_is_singular(&req->wb_list)) {\r\nstruct pnfs_commit_bucket *bucket;\r\nbucket = list_first_entry(&req->wb_list,\r\nstruct pnfs_commit_bucket,\r\nwritten);\r\nfreeme = bucket->wlseg;\r\nbucket->wlseg = NULL;\r\n}\r\nout:\r\nnfs_request_remove_commit_list(req, cinfo);\r\npnfs_put_lseg_locked(freeme);\r\n}\r\nstatic int\r\npnfs_generic_transfer_commit_list(struct list_head *src, struct list_head *dst,\r\nstruct nfs_commit_info *cinfo, int max)\r\n{\r\nstruct nfs_page *req, *tmp;\r\nint ret = 0;\r\nlist_for_each_entry_safe(req, tmp, src, wb_list) {\r\nif (!nfs_lock_request(req))\r\ncontinue;\r\nkref_get(&req->wb_kref);\r\nif (cond_resched_lock(cinfo->lock))\r\nlist_safe_reset_next(req, tmp, wb_list);\r\nnfs_request_remove_commit_list(req, cinfo);\r\nclear_bit(PG_COMMIT_TO_DS, &req->wb_flags);\r\nnfs_list_add_request(req, dst);\r\nret++;\r\nif ((ret == max) && !cinfo->dreq)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\npnfs_generic_scan_ds_commit_list(struct pnfs_commit_bucket *bucket,\r\nstruct nfs_commit_info *cinfo,\r\nint max)\r\n{\r\nstruct list_head *src = &bucket->written;\r\nstruct list_head *dst = &bucket->committing;\r\nint ret;\r\nlockdep_assert_held(cinfo->lock);\r\nret = pnfs_generic_transfer_commit_list(src, dst, cinfo, max);\r\nif (ret) {\r\ncinfo->ds->nwritten -= ret;\r\ncinfo->ds->ncommitting += ret;\r\nbucket->clseg = bucket->wlseg;\r\nif (list_empty(src))\r\nbucket->wlseg = NULL;\r\nelse\r\npnfs_get_lseg(bucket->clseg);\r\n}\r\nreturn ret;\r\n}\r\nint pnfs_generic_scan_commit_lists(struct nfs_commit_info *cinfo,\r\nint max)\r\n{\r\nint i, rv = 0, cnt;\r\nlockdep_assert_held(cinfo->lock);\r\nfor (i = 0; i < cinfo->ds->nbuckets && max != 0; i++) {\r\ncnt = pnfs_generic_scan_ds_commit_list(&cinfo->ds->buckets[i],\r\ncinfo, max);\r\nmax -= cnt;\r\nrv += cnt;\r\n}\r\nreturn rv;\r\n}\r\nvoid pnfs_generic_recover_commit_reqs(struct list_head *dst,\r\nstruct nfs_commit_info *cinfo)\r\n{\r\nstruct pnfs_commit_bucket *b;\r\nstruct pnfs_layout_segment *freeme;\r\nint i;\r\nlockdep_assert_held(cinfo->lock);\r\nrestart:\r\nfor (i = 0, b = cinfo->ds->buckets; i < cinfo->ds->nbuckets; i++, b++) {\r\nif (pnfs_generic_transfer_commit_list(&b->written, dst,\r\ncinfo, 0)) {\r\nfreeme = b->wlseg;\r\nb->wlseg = NULL;\r\nspin_unlock(cinfo->lock);\r\npnfs_put_lseg(freeme);\r\nspin_lock(cinfo->lock);\r\ngoto restart;\r\n}\r\n}\r\ncinfo->ds->nwritten = 0;\r\n}\r\nstatic void pnfs_generic_retry_commit(struct nfs_commit_info *cinfo, int idx)\r\n{\r\nstruct pnfs_ds_commit_info *fl_cinfo = cinfo->ds;\r\nstruct pnfs_commit_bucket *bucket;\r\nstruct pnfs_layout_segment *freeme;\r\nint i;\r\nfor (i = idx; i < fl_cinfo->nbuckets; i++) {\r\nbucket = &fl_cinfo->buckets[i];\r\nif (list_empty(&bucket->committing))\r\ncontinue;\r\nnfs_retry_commit(&bucket->committing, bucket->clseg, cinfo, i);\r\nspin_lock(cinfo->lock);\r\nfreeme = bucket->clseg;\r\nbucket->clseg = NULL;\r\nspin_unlock(cinfo->lock);\r\npnfs_put_lseg(freeme);\r\n}\r\n}\r\nstatic unsigned int\r\npnfs_generic_alloc_ds_commits(struct nfs_commit_info *cinfo,\r\nstruct list_head *list)\r\n{\r\nstruct pnfs_ds_commit_info *fl_cinfo;\r\nstruct pnfs_commit_bucket *bucket;\r\nstruct nfs_commit_data *data;\r\nint i;\r\nunsigned int nreq = 0;\r\nfl_cinfo = cinfo->ds;\r\nbucket = fl_cinfo->buckets;\r\nfor (i = 0; i < fl_cinfo->nbuckets; i++, bucket++) {\r\nif (list_empty(&bucket->committing))\r\ncontinue;\r\ndata = nfs_commitdata_alloc();\r\nif (!data)\r\nbreak;\r\ndata->ds_commit_index = i;\r\nspin_lock(cinfo->lock);\r\ndata->lseg = bucket->clseg;\r\nbucket->clseg = NULL;\r\nspin_unlock(cinfo->lock);\r\nlist_add(&data->pages, list);\r\nnreq++;\r\n}\r\npnfs_generic_retry_commit(cinfo, i);\r\nreturn nreq;\r\n}\r\nint\r\npnfs_generic_commit_pagelist(struct inode *inode, struct list_head *mds_pages,\r\nint how, struct nfs_commit_info *cinfo,\r\nint (*initiate_commit)(struct nfs_commit_data *data,\r\nint how))\r\n{\r\nstruct nfs_commit_data *data, *tmp;\r\nLIST_HEAD(list);\r\nunsigned int nreq = 0;\r\nif (!list_empty(mds_pages)) {\r\ndata = nfs_commitdata_alloc();\r\nif (data != NULL) {\r\ndata->lseg = NULL;\r\nlist_add(&data->pages, &list);\r\nnreq++;\r\n} else {\r\nnfs_retry_commit(mds_pages, NULL, cinfo, 0);\r\npnfs_generic_retry_commit(cinfo, 0);\r\ncinfo->completion_ops->error_cleanup(NFS_I(inode));\r\nreturn -ENOMEM;\r\n}\r\n}\r\nnreq += pnfs_generic_alloc_ds_commits(cinfo, &list);\r\nif (nreq == 0) {\r\ncinfo->completion_ops->error_cleanup(NFS_I(inode));\r\ngoto out;\r\n}\r\natomic_add(nreq, &cinfo->mds->rpcs_out);\r\nlist_for_each_entry_safe(data, tmp, &list, pages) {\r\nlist_del_init(&data->pages);\r\nif (!data->lseg) {\r\nnfs_init_commit(data, mds_pages, NULL, cinfo);\r\nnfs_initiate_commit(NFS_CLIENT(inode), data,\r\nNFS_PROTO(data->inode),\r\ndata->mds_ops, how, 0);\r\n} else {\r\nstruct pnfs_commit_bucket *buckets;\r\nbuckets = cinfo->ds->buckets;\r\nnfs_init_commit(data,\r\n&buckets[data->ds_commit_index].committing,\r\ndata->lseg,\r\ncinfo);\r\ninitiate_commit(data, how);\r\n}\r\n}\r\nout:\r\ncinfo->ds->ncommitting = 0;\r\nreturn PNFS_ATTEMPTED;\r\n}\r\nstatic void\r\nprint_ds(struct nfs4_pnfs_ds *ds)\r\n{\r\nif (ds == NULL) {\r\nprintk(KERN_WARNING "%s NULL device\n", __func__);\r\nreturn;\r\n}\r\nprintk(KERN_WARNING " ds %s\n"\r\n" ref count %d\n"\r\n" client %p\n"\r\n" cl_exchange_flags %x\n",\r\nds->ds_remotestr,\r\natomic_read(&ds->ds_count), ds->ds_clp,\r\nds->ds_clp ? ds->ds_clp->cl_exchange_flags : 0);\r\n}\r\nstatic bool\r\nsame_sockaddr(struct sockaddr *addr1, struct sockaddr *addr2)\r\n{\r\nstruct sockaddr_in *a, *b;\r\nstruct sockaddr_in6 *a6, *b6;\r\nif (addr1->sa_family != addr2->sa_family)\r\nreturn false;\r\nswitch (addr1->sa_family) {\r\ncase AF_INET:\r\na = (struct sockaddr_in *)addr1;\r\nb = (struct sockaddr_in *)addr2;\r\nif (a->sin_addr.s_addr == b->sin_addr.s_addr &&\r\na->sin_port == b->sin_port)\r\nreturn true;\r\nbreak;\r\ncase AF_INET6:\r\na6 = (struct sockaddr_in6 *)addr1;\r\nb6 = (struct sockaddr_in6 *)addr2;\r\nif (ipv6_addr_src_scope(&a6->sin6_addr) ==\r\nIPV6_ADDR_SCOPE_LINKLOCAL &&\r\na6->sin6_scope_id != b6->sin6_scope_id)\r\nreturn false;\r\nif (ipv6_addr_equal(&a6->sin6_addr, &b6->sin6_addr) &&\r\na6->sin6_port == b6->sin6_port)\r\nreturn true;\r\nbreak;\r\ndefault:\r\ndprintk("%s: unhandled address family: %u\n",\r\n__func__, addr1->sa_family);\r\nreturn false;\r\n}\r\nreturn false;\r\n}\r\nstatic bool\r\n_same_data_server_addrs_locked(const struct list_head *dsaddrs1,\r\nconst struct list_head *dsaddrs2)\r\n{\r\nstruct nfs4_pnfs_ds_addr *da1, *da2;\r\nfor (da1 = list_first_entry(dsaddrs1, typeof(*da1), da_node),\r\nda2 = list_first_entry(dsaddrs2, typeof(*da2), da_node);\r\nda1 != NULL && da2 != NULL;\r\nda1 = list_entry(da1->da_node.next, typeof(*da1), da_node),\r\nda2 = list_entry(da2->da_node.next, typeof(*da2), da_node)) {\r\nif (!same_sockaddr((struct sockaddr *)&da1->da_addr,\r\n(struct sockaddr *)&da2->da_addr))\r\nreturn false;\r\n}\r\nif (da1 == NULL && da2 == NULL)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic struct nfs4_pnfs_ds *\r\n_data_server_lookup_locked(const struct list_head *dsaddrs)\r\n{\r\nstruct nfs4_pnfs_ds *ds;\r\nlist_for_each_entry(ds, &nfs4_data_server_cache, ds_node)\r\nif (_same_data_server_addrs_locked(&ds->ds_addrs, dsaddrs))\r\nreturn ds;\r\nreturn NULL;\r\n}\r\nstatic void destroy_ds(struct nfs4_pnfs_ds *ds)\r\n{\r\nstruct nfs4_pnfs_ds_addr *da;\r\ndprintk("--> %s\n", __func__);\r\nifdebug(FACILITY)\r\nprint_ds(ds);\r\nnfs_put_client(ds->ds_clp);\r\nwhile (!list_empty(&ds->ds_addrs)) {\r\nda = list_first_entry(&ds->ds_addrs,\r\nstruct nfs4_pnfs_ds_addr,\r\nda_node);\r\nlist_del_init(&da->da_node);\r\nkfree(da->da_remotestr);\r\nkfree(da);\r\n}\r\nkfree(ds->ds_remotestr);\r\nkfree(ds);\r\n}\r\nvoid nfs4_pnfs_ds_put(struct nfs4_pnfs_ds *ds)\r\n{\r\nif (atomic_dec_and_lock(&ds->ds_count,\r\n&nfs4_ds_cache_lock)) {\r\nlist_del_init(&ds->ds_node);\r\nspin_unlock(&nfs4_ds_cache_lock);\r\ndestroy_ds(ds);\r\n}\r\n}\r\nstatic char *\r\nnfs4_pnfs_remotestr(struct list_head *dsaddrs, gfp_t gfp_flags)\r\n{\r\nstruct nfs4_pnfs_ds_addr *da;\r\nchar *remotestr;\r\nsize_t len;\r\nchar *p;\r\nlen = 3;\r\nlist_for_each_entry(da, dsaddrs, da_node) {\r\nlen += strlen(da->da_remotestr) + 1;\r\n}\r\nremotestr = kzalloc(len, gfp_flags);\r\nif (!remotestr)\r\nreturn NULL;\r\np = remotestr;\r\n*(p++) = '{';\r\nlen--;\r\nlist_for_each_entry(da, dsaddrs, da_node) {\r\nsize_t ll = strlen(da->da_remotestr);\r\nif (ll > len)\r\ngoto out_err;\r\nmemcpy(p, da->da_remotestr, ll);\r\np += ll;\r\nlen -= ll;\r\nif (len < 1)\r\ngoto out_err;\r\n(*p++) = ',';\r\nlen--;\r\n}\r\nif (len < 2)\r\ngoto out_err;\r\n*(p++) = '}';\r\n*p = '\0';\r\nreturn remotestr;\r\nout_err:\r\nkfree(remotestr);\r\nreturn NULL;\r\n}\r\nstruct nfs4_pnfs_ds *\r\nnfs4_pnfs_ds_add(struct list_head *dsaddrs, gfp_t gfp_flags)\r\n{\r\nstruct nfs4_pnfs_ds *tmp_ds, *ds = NULL;\r\nchar *remotestr;\r\nif (list_empty(dsaddrs)) {\r\ndprintk("%s: no addresses defined\n", __func__);\r\ngoto out;\r\n}\r\nds = kzalloc(sizeof(*ds), gfp_flags);\r\nif (!ds)\r\ngoto out;\r\nremotestr = nfs4_pnfs_remotestr(dsaddrs, gfp_flags);\r\nspin_lock(&nfs4_ds_cache_lock);\r\ntmp_ds = _data_server_lookup_locked(dsaddrs);\r\nif (tmp_ds == NULL) {\r\nINIT_LIST_HEAD(&ds->ds_addrs);\r\nlist_splice_init(dsaddrs, &ds->ds_addrs);\r\nds->ds_remotestr = remotestr;\r\natomic_set(&ds->ds_count, 1);\r\nINIT_LIST_HEAD(&ds->ds_node);\r\nds->ds_clp = NULL;\r\nlist_add(&ds->ds_node, &nfs4_data_server_cache);\r\ndprintk("%s add new data server %s\n", __func__,\r\nds->ds_remotestr);\r\n} else {\r\nkfree(remotestr);\r\nkfree(ds);\r\natomic_inc(&tmp_ds->ds_count);\r\ndprintk("%s data server %s found, inc'ed ds_count to %d\n",\r\n__func__, tmp_ds->ds_remotestr,\r\natomic_read(&tmp_ds->ds_count));\r\nds = tmp_ds;\r\n}\r\nspin_unlock(&nfs4_ds_cache_lock);\r\nout:\r\nreturn ds;\r\n}\r\nstatic void nfs4_wait_ds_connect(struct nfs4_pnfs_ds *ds)\r\n{\r\nmight_sleep();\r\nwait_on_bit(&ds->ds_state, NFS4DS_CONNECTING,\r\nTASK_KILLABLE);\r\n}\r\nstatic void nfs4_clear_ds_conn_bit(struct nfs4_pnfs_ds *ds)\r\n{\r\nsmp_mb__before_atomic();\r\nclear_bit(NFS4DS_CONNECTING, &ds->ds_state);\r\nsmp_mb__after_atomic();\r\nwake_up_bit(&ds->ds_state, NFS4DS_CONNECTING);\r\n}\r\nstatic bool load_v3_ds_connect(void)\r\n{\r\nif (!get_v3_ds_connect) {\r\nget_v3_ds_connect = symbol_request(nfs3_set_ds_client);\r\nWARN_ON_ONCE(!get_v3_ds_connect);\r\n}\r\nreturn(get_v3_ds_connect != NULL);\r\n}\r\nvoid nfs4_pnfs_v3_ds_connect_unload(void)\r\n{\r\nif (get_v3_ds_connect) {\r\nsymbol_put(nfs3_set_ds_client);\r\nget_v3_ds_connect = NULL;\r\n}\r\n}\r\nstatic int _nfs4_pnfs_v3_ds_connect(struct nfs_server *mds_srv,\r\nstruct nfs4_pnfs_ds *ds,\r\nunsigned int timeo,\r\nunsigned int retrans,\r\nrpc_authflavor_t au_flavor)\r\n{\r\nstruct nfs_client *clp = ERR_PTR(-EIO);\r\nstruct nfs4_pnfs_ds_addr *da;\r\nint status = 0;\r\ndprintk("--> %s DS %s au_flavor %d\n", __func__,\r\nds->ds_remotestr, au_flavor);\r\nif (!load_v3_ds_connect())\r\ngoto out;\r\nlist_for_each_entry(da, &ds->ds_addrs, da_node) {\r\ndprintk("%s: DS %s: trying address %s\n",\r\n__func__, ds->ds_remotestr, da->da_remotestr);\r\nclp = get_v3_ds_connect(mds_srv->nfs_client,\r\n(struct sockaddr *)&da->da_addr,\r\nda->da_addrlen, IPPROTO_TCP,\r\ntimeo, retrans, au_flavor);\r\nif (!IS_ERR(clp))\r\nbreak;\r\n}\r\nif (IS_ERR(clp)) {\r\nstatus = PTR_ERR(clp);\r\ngoto out;\r\n}\r\nsmp_wmb();\r\nds->ds_clp = clp;\r\ndprintk("%s [new] addr: %s\n", __func__, ds->ds_remotestr);\r\nout:\r\nreturn status;\r\n}\r\nstatic int _nfs4_pnfs_v4_ds_connect(struct nfs_server *mds_srv,\r\nstruct nfs4_pnfs_ds *ds,\r\nunsigned int timeo,\r\nunsigned int retrans,\r\nu32 minor_version,\r\nrpc_authflavor_t au_flavor)\r\n{\r\nstruct nfs_client *clp = ERR_PTR(-EIO);\r\nstruct nfs4_pnfs_ds_addr *da;\r\nint status = 0;\r\ndprintk("--> %s DS %s au_flavor %d\n", __func__, ds->ds_remotestr,\r\nau_flavor);\r\nlist_for_each_entry(da, &ds->ds_addrs, da_node) {\r\ndprintk("%s: DS %s: trying address %s\n",\r\n__func__, ds->ds_remotestr, da->da_remotestr);\r\nclp = nfs4_set_ds_client(mds_srv->nfs_client,\r\n(struct sockaddr *)&da->da_addr,\r\nda->da_addrlen, IPPROTO_TCP,\r\ntimeo, retrans, minor_version,\r\nau_flavor);\r\nif (!IS_ERR(clp))\r\nbreak;\r\n}\r\nif (IS_ERR(clp)) {\r\nstatus = PTR_ERR(clp);\r\ngoto out;\r\n}\r\nstatus = nfs4_init_ds_session(clp, mds_srv->nfs_client->cl_lease_time);\r\nif (status)\r\ngoto out_put;\r\nsmp_wmb();\r\nds->ds_clp = clp;\r\ndprintk("%s [new] addr: %s\n", __func__, ds->ds_remotestr);\r\nout:\r\nreturn status;\r\nout_put:\r\nnfs_put_client(clp);\r\ngoto out;\r\n}\r\nvoid nfs4_pnfs_ds_connect(struct nfs_server *mds_srv, struct nfs4_pnfs_ds *ds,\r\nstruct nfs4_deviceid_node *devid, unsigned int timeo,\r\nunsigned int retrans, u32 version,\r\nu32 minor_version, rpc_authflavor_t au_flavor)\r\n{\r\nif (test_and_set_bit(NFS4DS_CONNECTING, &ds->ds_state) == 0) {\r\nint err = 0;\r\nif (version == 3) {\r\nerr = _nfs4_pnfs_v3_ds_connect(mds_srv, ds, timeo,\r\nretrans, au_flavor);\r\n} else if (version == 4) {\r\nerr = _nfs4_pnfs_v4_ds_connect(mds_srv, ds, timeo,\r\nretrans, minor_version,\r\nau_flavor);\r\n} else {\r\ndprintk("%s: unsupported DS version %d\n", __func__,\r\nversion);\r\nerr = -EPROTONOSUPPORT;\r\n}\r\nif (err)\r\nnfs4_mark_deviceid_unavailable(devid);\r\nnfs4_clear_ds_conn_bit(ds);\r\n} else {\r\nnfs4_wait_ds_connect(ds);\r\n}\r\n}\r\nstruct nfs4_pnfs_ds_addr *\r\nnfs4_decode_mp_ds_addr(struct net *net, struct xdr_stream *xdr, gfp_t gfp_flags)\r\n{\r\nstruct nfs4_pnfs_ds_addr *da = NULL;\r\nchar *buf, *portstr;\r\n__be16 port;\r\nint nlen, rlen;\r\nint tmp[2];\r\n__be32 *p;\r\nchar *netid, *match_netid;\r\nsize_t len, match_netid_len;\r\nchar *startsep = "";\r\nchar *endsep = "";\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(!p))\r\ngoto out_err;\r\nnlen = be32_to_cpup(p++);\r\np = xdr_inline_decode(xdr, nlen);\r\nif (unlikely(!p))\r\ngoto out_err;\r\nnetid = kmalloc(nlen+1, gfp_flags);\r\nif (unlikely(!netid))\r\ngoto out_err;\r\nnetid[nlen] = '\0';\r\nmemcpy(netid, p, nlen);\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(!p))\r\ngoto out_free_netid;\r\nrlen = be32_to_cpup(p);\r\np = xdr_inline_decode(xdr, rlen);\r\nif (unlikely(!p))\r\ngoto out_free_netid;\r\nif (rlen > INET6_ADDRSTRLEN + IPV6_SCOPE_ID_LEN + 8) {\r\ndprintk("%s: Invalid address, length %d\n", __func__,\r\nrlen);\r\ngoto out_free_netid;\r\n}\r\nbuf = kmalloc(rlen + 1, gfp_flags);\r\nif (!buf) {\r\ndprintk("%s: Not enough memory\n", __func__);\r\ngoto out_free_netid;\r\n}\r\nbuf[rlen] = '\0';\r\nmemcpy(buf, p, rlen);\r\nportstr = strrchr(buf, '.');\r\nif (!portstr) {\r\ndprintk("%s: Failed finding expected dot in port\n",\r\n__func__);\r\ngoto out_free_buf;\r\n}\r\n*portstr = '-';\r\nportstr = strrchr(buf, '.');\r\nif (!portstr) {\r\ndprintk("%s: Failed finding expected dot between address and "\r\n"port\n", __func__);\r\ngoto out_free_buf;\r\n}\r\n*portstr = '\0';\r\nda = kzalloc(sizeof(*da), gfp_flags);\r\nif (unlikely(!da))\r\ngoto out_free_buf;\r\nINIT_LIST_HEAD(&da->da_node);\r\nif (!rpc_pton(net, buf, portstr-buf, (struct sockaddr *)&da->da_addr,\r\nsizeof(da->da_addr))) {\r\ndprintk("%s: error parsing address %s\n", __func__, buf);\r\ngoto out_free_da;\r\n}\r\nportstr++;\r\nsscanf(portstr, "%d-%d", &tmp[0], &tmp[1]);\r\nport = htons((tmp[0] << 8) | (tmp[1]));\r\nswitch (da->da_addr.ss_family) {\r\ncase AF_INET:\r\n((struct sockaddr_in *)&da->da_addr)->sin_port = port;\r\nda->da_addrlen = sizeof(struct sockaddr_in);\r\nmatch_netid = "tcp";\r\nmatch_netid_len = 3;\r\nbreak;\r\ncase AF_INET6:\r\n((struct sockaddr_in6 *)&da->da_addr)->sin6_port = port;\r\nda->da_addrlen = sizeof(struct sockaddr_in6);\r\nmatch_netid = "tcp6";\r\nmatch_netid_len = 4;\r\nstartsep = "[";\r\nendsep = "]";\r\nbreak;\r\ndefault:\r\ndprintk("%s: unsupported address family: %u\n",\r\n__func__, da->da_addr.ss_family);\r\ngoto out_free_da;\r\n}\r\nif (nlen != match_netid_len || strncmp(netid, match_netid, nlen)) {\r\ndprintk("%s: ERROR: r_netid \"%s\" != \"%s\"\n",\r\n__func__, netid, match_netid);\r\ngoto out_free_da;\r\n}\r\nlen = strlen(startsep) + strlen(buf) + strlen(endsep) + 7;\r\nda->da_remotestr = kzalloc(len, gfp_flags);\r\nif (da->da_remotestr)\r\nsnprintf(da->da_remotestr, len, "%s%s%s:%u", startsep,\r\nbuf, endsep, ntohs(port));\r\ndprintk("%s: Parsed DS addr %s\n", __func__, da->da_remotestr);\r\nkfree(buf);\r\nkfree(netid);\r\nreturn da;\r\nout_free_da:\r\nkfree(da);\r\nout_free_buf:\r\ndprintk("%s: Error parsing DS addr: %s\n", __func__, buf);\r\nkfree(buf);\r\nout_free_netid:\r\nkfree(netid);\r\nout_err:\r\nreturn NULL;\r\n}\r\nvoid\r\npnfs_layout_mark_request_commit(struct nfs_page *req,\r\nstruct pnfs_layout_segment *lseg,\r\nstruct nfs_commit_info *cinfo,\r\nu32 ds_commit_idx)\r\n{\r\nstruct list_head *list;\r\nstruct pnfs_commit_bucket *buckets;\r\nspin_lock(cinfo->lock);\r\nbuckets = cinfo->ds->buckets;\r\nlist = &buckets[ds_commit_idx].written;\r\nif (list_empty(list)) {\r\nWARN_ON_ONCE(buckets[ds_commit_idx].wlseg != NULL);\r\nbuckets[ds_commit_idx].wlseg = pnfs_get_lseg(lseg);\r\n}\r\nset_bit(PG_COMMIT_TO_DS, &req->wb_flags);\r\ncinfo->ds->nwritten++;\r\nspin_unlock(cinfo->lock);\r\nnfs_request_add_commit_list(req, list, cinfo);\r\n}\r\nint\r\npnfs_nfs_generic_sync(struct inode *inode, bool datasync)\r\n{\r\nif (datasync)\r\nreturn 0;\r\nreturn pnfs_layoutcommit_inode(inode, true);\r\n}
