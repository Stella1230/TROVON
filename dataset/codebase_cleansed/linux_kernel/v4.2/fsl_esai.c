static irqreturn_t esai_isr(int irq, void *devid)\r\n{\r\nstruct fsl_esai *esai_priv = (struct fsl_esai *)devid;\r\nstruct platform_device *pdev = esai_priv->pdev;\r\nu32 esr;\r\nregmap_read(esai_priv->regmap, REG_ESAI_ESR, &esr);\r\nif (esr & ESAI_ESR_TINIT_MASK)\r\ndev_dbg(&pdev->dev, "isr: Transmition Initialized\n");\r\nif (esr & ESAI_ESR_RFF_MASK)\r\ndev_warn(&pdev->dev, "isr: Receiving overrun\n");\r\nif (esr & ESAI_ESR_TFE_MASK)\r\ndev_warn(&pdev->dev, "isr: Transmition underrun\n");\r\nif (esr & ESAI_ESR_TLS_MASK)\r\ndev_dbg(&pdev->dev, "isr: Just transmitted the last slot\n");\r\nif (esr & ESAI_ESR_TDE_MASK)\r\ndev_dbg(&pdev->dev, "isr: Transmition data exception\n");\r\nif (esr & ESAI_ESR_TED_MASK)\r\ndev_dbg(&pdev->dev, "isr: Transmitting even slots\n");\r\nif (esr & ESAI_ESR_TD_MASK)\r\ndev_dbg(&pdev->dev, "isr: Transmitting data\n");\r\nif (esr & ESAI_ESR_RLS_MASK)\r\ndev_dbg(&pdev->dev, "isr: Just received the last slot\n");\r\nif (esr & ESAI_ESR_RDE_MASK)\r\ndev_dbg(&pdev->dev, "isr: Receiving data exception\n");\r\nif (esr & ESAI_ESR_RED_MASK)\r\ndev_dbg(&pdev->dev, "isr: Receiving even slots\n");\r\nif (esr & ESAI_ESR_RD_MASK)\r\ndev_dbg(&pdev->dev, "isr: Receiving data\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int fsl_esai_divisor_cal(struct snd_soc_dai *dai, bool tx, u32 ratio,\r\nbool usefp, u32 fp)\r\n{\r\nstruct fsl_esai *esai_priv = snd_soc_dai_get_drvdata(dai);\r\nu32 psr, pm = 999, maxfp, prod, sub, savesub, i, j;\r\nmaxfp = usefp ? 16 : 1;\r\nif (usefp && fp)\r\ngoto out_fp;\r\nif (ratio > 2 * 8 * 256 * maxfp || ratio < 2) {\r\ndev_err(dai->dev, "the ratio is out of range (2 ~ %d)\n",\r\n2 * 8 * 256 * maxfp);\r\nreturn -EINVAL;\r\n} else if (ratio % 2) {\r\ndev_err(dai->dev, "the raio must be even if using upper divider\n");\r\nreturn -EINVAL;\r\n}\r\nratio /= 2;\r\npsr = ratio <= 256 * maxfp ? ESAI_xCCR_xPSR_BYPASS : ESAI_xCCR_xPSR_DIV8;\r\nsavesub = (psr ? 1 : 8) * 256 * maxfp / 1000;\r\nfor (i = 1; i <= 256; i++) {\r\nfor (j = 1; j <= maxfp; j++) {\r\nprod = (psr ? 1 : 8) * i * j;\r\nif (prod == ratio)\r\nsub = 0;\r\nelse if (prod / ratio == 1)\r\nsub = prod - ratio;\r\nelse if (ratio / prod == 1)\r\nsub = ratio - prod;\r\nelse\r\ncontinue;\r\nsub = sub * 1000 / ratio;\r\nif (sub < savesub) {\r\nsavesub = sub;\r\npm = i;\r\nfp = j;\r\n}\r\nif (savesub == 0)\r\ngoto out;\r\n}\r\n}\r\nif (pm == 999) {\r\ndev_err(dai->dev, "failed to calculate proper divisors\n");\r\nreturn -EINVAL;\r\n}\r\nout:\r\nregmap_update_bits(esai_priv->regmap, REG_ESAI_xCCR(tx),\r\nESAI_xCCR_xPSR_MASK | ESAI_xCCR_xPM_MASK,\r\npsr | ESAI_xCCR_xPM(pm));\r\nout_fp:\r\nif (maxfp <= 1)\r\nreturn 0;\r\nregmap_update_bits(esai_priv->regmap, REG_ESAI_xCCR(tx),\r\nESAI_xCCR_xFP_MASK, ESAI_xCCR_xFP(fp));\r\nreturn 0;\r\n}\r\nstatic int fsl_esai_set_dai_sysclk(struct snd_soc_dai *dai, int clk_id,\r\nunsigned int freq, int dir)\r\n{\r\nstruct fsl_esai *esai_priv = snd_soc_dai_get_drvdata(dai);\r\nstruct clk *clksrc = esai_priv->extalclk;\r\nbool tx = clk_id <= ESAI_HCKT_EXTAL;\r\nbool in = dir == SND_SOC_CLOCK_IN;\r\nu32 ratio, ecr = 0;\r\nunsigned long clk_rate;\r\nint ret;\r\nif (freq == esai_priv->hck_rate[tx] && dir == esai_priv->hck_dir[tx])\r\nreturn 0;\r\nesai_priv->sck_div[tx] = true;\r\nregmap_update_bits(esai_priv->regmap, REG_ESAI_xCCR(tx),\r\nESAI_xCCR_xHCKD, in ? 0 : ESAI_xCCR_xHCKD);\r\nif (in)\r\ngoto out;\r\nswitch (clk_id) {\r\ncase ESAI_HCKT_FSYS:\r\ncase ESAI_HCKR_FSYS:\r\nclksrc = esai_priv->fsysclk;\r\nbreak;\r\ncase ESAI_HCKT_EXTAL:\r\necr |= ESAI_ECR_ETI;\r\ncase ESAI_HCKR_EXTAL:\r\necr |= ESAI_ECR_ERI;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (IS_ERR(clksrc)) {\r\ndev_err(dai->dev, "no assigned %s clock\n",\r\nclk_id % 2 ? "extal" : "fsys");\r\nreturn PTR_ERR(clksrc);\r\n}\r\nclk_rate = clk_get_rate(clksrc);\r\nratio = clk_rate / freq;\r\nif (ratio * freq > clk_rate)\r\nret = ratio * freq - clk_rate;\r\nelse if (ratio * freq < clk_rate)\r\nret = clk_rate - ratio * freq;\r\nelse\r\nret = 0;\r\nif (ret != 0 && clk_rate / ret < 1000) {\r\ndev_err(dai->dev, "failed to derive required HCK%c rate\n",\r\ntx ? 'T' : 'R');\r\nreturn -EINVAL;\r\n}\r\nif (ratio == 1 && clksrc == esai_priv->extalclk) {\r\necr |= tx ? ESAI_ECR_ETO : ESAI_ECR_ERO;\r\ngoto out;\r\n} else if (ratio < 2) {\r\ndev_err(dai->dev, "failed to derive required HCK%c rate\n",\r\ntx ? 'T' : 'R');\r\nreturn -EINVAL;\r\n}\r\nret = fsl_esai_divisor_cal(dai, tx, ratio, false, 0);\r\nif (ret)\r\nreturn ret;\r\nesai_priv->sck_div[tx] = false;\r\nout:\r\nesai_priv->hck_dir[tx] = dir;\r\nesai_priv->hck_rate[tx] = freq;\r\nregmap_update_bits(esai_priv->regmap, REG_ESAI_ECR,\r\ntx ? ESAI_ECR_ETI | ESAI_ECR_ETO :\r\nESAI_ECR_ERI | ESAI_ECR_ERO, ecr);\r\nreturn 0;\r\n}\r\nstatic int fsl_esai_set_bclk(struct snd_soc_dai *dai, bool tx, u32 freq)\r\n{\r\nstruct fsl_esai *esai_priv = snd_soc_dai_get_drvdata(dai);\r\nu32 hck_rate = esai_priv->hck_rate[tx];\r\nu32 sub, ratio = hck_rate / freq;\r\nint ret;\r\nif (esai_priv->slave_mode || esai_priv->sck_rate[tx] == freq)\r\nreturn 0;\r\nif (ratio * freq > hck_rate)\r\nsub = ratio * freq - hck_rate;\r\nelse if (ratio * freq < hck_rate)\r\nsub = hck_rate - ratio * freq;\r\nelse\r\nsub = 0;\r\nif (sub != 0 && hck_rate / sub < 1000) {\r\ndev_err(dai->dev, "failed to derive required SCK%c rate\n",\r\ntx ? 'T' : 'R');\r\nreturn -EINVAL;\r\n}\r\nif (!esai_priv->sck_div[tx] && (ratio > 16 || ratio == 0)) {\r\ndev_err(dai->dev, "the ratio is out of range (1 ~ 16)\n");\r\nreturn -EINVAL;\r\n}\r\nret = fsl_esai_divisor_cal(dai, tx, ratio, true,\r\nesai_priv->sck_div[tx] ? 0 : ratio);\r\nif (ret)\r\nreturn ret;\r\nesai_priv->sck_rate[tx] = freq;\r\nreturn 0;\r\n}\r\nstatic int fsl_esai_set_dai_tdm_slot(struct snd_soc_dai *dai, u32 tx_mask,\r\nu32 rx_mask, int slots, int slot_width)\r\n{\r\nstruct fsl_esai *esai_priv = snd_soc_dai_get_drvdata(dai);\r\nregmap_update_bits(esai_priv->regmap, REG_ESAI_TCCR,\r\nESAI_xCCR_xDC_MASK, ESAI_xCCR_xDC(slots));\r\nregmap_update_bits(esai_priv->regmap, REG_ESAI_TSMA,\r\nESAI_xSMA_xS_MASK, ESAI_xSMA_xS(tx_mask));\r\nregmap_update_bits(esai_priv->regmap, REG_ESAI_TSMB,\r\nESAI_xSMB_xS_MASK, ESAI_xSMB_xS(tx_mask));\r\nregmap_update_bits(esai_priv->regmap, REG_ESAI_RCCR,\r\nESAI_xCCR_xDC_MASK, ESAI_xCCR_xDC(slots));\r\nregmap_update_bits(esai_priv->regmap, REG_ESAI_RSMA,\r\nESAI_xSMA_xS_MASK, ESAI_xSMA_xS(rx_mask));\r\nregmap_update_bits(esai_priv->regmap, REG_ESAI_RSMB,\r\nESAI_xSMB_xS_MASK, ESAI_xSMB_xS(rx_mask));\r\nesai_priv->slot_width = slot_width;\r\nesai_priv->slots = slots;\r\nreturn 0;\r\n}\r\nstatic int fsl_esai_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct fsl_esai *esai_priv = snd_soc_dai_get_drvdata(dai);\r\nu32 xcr = 0, xccr = 0, mask;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nxcr |= ESAI_xCR_xFSR;\r\nxccr |= ESAI_xCCR_xFSP | ESAI_xCCR_xCKP | ESAI_xCCR_xHCKP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nxccr |= ESAI_xCCR_xCKP | ESAI_xCCR_xHCKP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nxccr |= ESAI_xCCR_xCKP | ESAI_xCCR_xHCKP | ESAI_xCR_xWA;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nxcr |= ESAI_xCR_xFSL | ESAI_xCR_xFSR;\r\nxccr |= ESAI_xCCR_xCKP | ESAI_xCCR_xHCKP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nxcr |= ESAI_xCR_xFSL;\r\nxccr |= ESAI_xCCR_xCKP | ESAI_xCCR_xHCKP;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nxccr ^= ESAI_xCCR_xCKP | ESAI_xCCR_xHCKP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nxccr ^= ESAI_xCCR_xFSP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nxccr ^= ESAI_xCCR_xCKP | ESAI_xCCR_xHCKP | ESAI_xCCR_xFSP;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nesai_priv->slave_mode = false;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nesai_priv->slave_mode = true;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\nxccr |= ESAI_xCCR_xCKD;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\nxccr |= ESAI_xCCR_xFSD;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nxccr |= ESAI_xCCR_xFSD | ESAI_xCCR_xCKD;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmask = ESAI_xCR_xFSL | ESAI_xCR_xFSR;\r\nregmap_update_bits(esai_priv->regmap, REG_ESAI_TCR, mask, xcr);\r\nregmap_update_bits(esai_priv->regmap, REG_ESAI_RCR, mask, xcr);\r\nmask = ESAI_xCCR_xCKP | ESAI_xCCR_xHCKP | ESAI_xCCR_xFSP |\r\nESAI_xCCR_xFSD | ESAI_xCCR_xCKD | ESAI_xCR_xWA;\r\nregmap_update_bits(esai_priv->regmap, REG_ESAI_TCCR, mask, xccr);\r\nregmap_update_bits(esai_priv->regmap, REG_ESAI_RCCR, mask, xccr);\r\nreturn 0;\r\n}\r\nstatic int fsl_esai_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct fsl_esai *esai_priv = snd_soc_dai_get_drvdata(dai);\r\nint ret;\r\nret = clk_prepare_enable(esai_priv->coreclk);\r\nif (ret)\r\nreturn ret;\r\nif (!IS_ERR(esai_priv->extalclk)) {\r\nret = clk_prepare_enable(esai_priv->extalclk);\r\nif (ret)\r\ngoto err_extalck;\r\n}\r\nif (!IS_ERR(esai_priv->fsysclk)) {\r\nret = clk_prepare_enable(esai_priv->fsysclk);\r\nif (ret)\r\ngoto err_fsysclk;\r\n}\r\nif (!dai->active) {\r\nregmap_update_bits(esai_priv->regmap, REG_ESAI_SAICR,\r\nESAI_SAICR_SYNC, esai_priv->synchronous ?\r\nESAI_SAICR_SYNC : 0);\r\nregmap_update_bits(esai_priv->regmap, REG_ESAI_TCCR,\r\nESAI_xCCR_xDC_MASK, ESAI_xCCR_xDC(2));\r\nregmap_update_bits(esai_priv->regmap, REG_ESAI_RCCR,\r\nESAI_xCCR_xDC_MASK, ESAI_xCCR_xDC(2));\r\n}\r\nreturn 0;\r\nerr_fsysclk:\r\nif (!IS_ERR(esai_priv->extalclk))\r\nclk_disable_unprepare(esai_priv->extalclk);\r\nerr_extalck:\r\nclk_disable_unprepare(esai_priv->coreclk);\r\nreturn ret;\r\n}\r\nstatic int fsl_esai_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct fsl_esai *esai_priv = snd_soc_dai_get_drvdata(dai);\r\nbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\r\nu32 width = snd_pcm_format_width(params_format(params));\r\nu32 channels = params_channels(params);\r\nu32 pins = DIV_ROUND_UP(channels, esai_priv->slots);\r\nu32 slot_width = width;\r\nu32 bclk, mask, val;\r\nint ret;\r\nif (esai_priv->slot_width)\r\nslot_width = esai_priv->slot_width;\r\nbclk = params_rate(params) * slot_width * esai_priv->slots;\r\nret = fsl_esai_set_bclk(dai, tx, bclk);\r\nif (ret)\r\nreturn ret;\r\nregmap_update_bits(esai_priv->regmap, REG_ESAI_xCR(tx),\r\nESAI_xCR_xMOD_MASK, params_channels(params) > 1 ?\r\nESAI_xCR_xMOD_NETWORK : 0);\r\nregmap_update_bits(esai_priv->regmap, REG_ESAI_xFCR(tx),\r\nESAI_xFCR_xFR_MASK, ESAI_xFCR_xFR);\r\nmask = ESAI_xFCR_xFR_MASK | ESAI_xFCR_xWA_MASK | ESAI_xFCR_xFWM_MASK |\r\n(tx ? ESAI_xFCR_TE_MASK | ESAI_xFCR_TIEN : ESAI_xFCR_RE_MASK);\r\nval = ESAI_xFCR_xWA(width) | ESAI_xFCR_xFWM(esai_priv->fifo_depth) |\r\n(tx ? ESAI_xFCR_TE(pins) | ESAI_xFCR_TIEN : ESAI_xFCR_RE(pins));\r\nregmap_update_bits(esai_priv->regmap, REG_ESAI_xFCR(tx), mask, val);\r\nmask = ESAI_xCR_xSWS_MASK | (tx ? ESAI_xCR_PADC : 0);\r\nval = ESAI_xCR_xSWS(slot_width, width) | (tx ? ESAI_xCR_PADC : 0);\r\nregmap_update_bits(esai_priv->regmap, REG_ESAI_xCR(tx), mask, val);\r\nregmap_update_bits(esai_priv->regmap, REG_ESAI_PRRC,\r\nESAI_PRRC_PDC_MASK, ESAI_PRRC_PDC(ESAI_GPIO));\r\nregmap_update_bits(esai_priv->regmap, REG_ESAI_PCRC,\r\nESAI_PCRC_PC_MASK, ESAI_PCRC_PC(ESAI_GPIO));\r\nreturn 0;\r\n}\r\nstatic void fsl_esai_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct fsl_esai *esai_priv = snd_soc_dai_get_drvdata(dai);\r\nif (!IS_ERR(esai_priv->fsysclk))\r\nclk_disable_unprepare(esai_priv->fsysclk);\r\nif (!IS_ERR(esai_priv->extalclk))\r\nclk_disable_unprepare(esai_priv->extalclk);\r\nclk_disable_unprepare(esai_priv->coreclk);\r\n}\r\nstatic int fsl_esai_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct fsl_esai *esai_priv = snd_soc_dai_get_drvdata(dai);\r\nbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\r\nu8 i, channels = substream->runtime->channels;\r\nu32 pins = DIV_ROUND_UP(channels, esai_priv->slots);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nregmap_update_bits(esai_priv->regmap, REG_ESAI_xFCR(tx),\r\nESAI_xFCR_xFEN_MASK, ESAI_xFCR_xFEN);\r\nfor (i = 0; tx && i < channels; i++)\r\nregmap_write(esai_priv->regmap, REG_ESAI_ETDR, 0x0);\r\nregmap_update_bits(esai_priv->regmap, REG_ESAI_xCR(tx),\r\ntx ? ESAI_xCR_TE_MASK : ESAI_xCR_RE_MASK,\r\ntx ? ESAI_xCR_TE(pins) : ESAI_xCR_RE(pins));\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nregmap_update_bits(esai_priv->regmap, REG_ESAI_xCR(tx),\r\ntx ? ESAI_xCR_TE_MASK : ESAI_xCR_RE_MASK, 0);\r\nregmap_update_bits(esai_priv->regmap, REG_ESAI_xFCR(tx),\r\nESAI_xFCR_xFR | ESAI_xFCR_xFEN, ESAI_xFCR_xFR);\r\nregmap_update_bits(esai_priv->regmap, REG_ESAI_xFCR(tx),\r\nESAI_xFCR_xFR, 0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_esai_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct fsl_esai *esai_priv = snd_soc_dai_get_drvdata(dai);\r\nsnd_soc_dai_init_dma_data(dai, &esai_priv->dma_params_tx,\r\n&esai_priv->dma_params_rx);\r\nreturn 0;\r\n}\r\nstatic bool fsl_esai_readable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase REG_ESAI_ERDR:\r\ncase REG_ESAI_ECR:\r\ncase REG_ESAI_ESR:\r\ncase REG_ESAI_TFCR:\r\ncase REG_ESAI_TFSR:\r\ncase REG_ESAI_RFCR:\r\ncase REG_ESAI_RFSR:\r\ncase REG_ESAI_RX0:\r\ncase REG_ESAI_RX1:\r\ncase REG_ESAI_RX2:\r\ncase REG_ESAI_RX3:\r\ncase REG_ESAI_SAISR:\r\ncase REG_ESAI_SAICR:\r\ncase REG_ESAI_TCR:\r\ncase REG_ESAI_TCCR:\r\ncase REG_ESAI_RCR:\r\ncase REG_ESAI_RCCR:\r\ncase REG_ESAI_TSMA:\r\ncase REG_ESAI_TSMB:\r\ncase REG_ESAI_RSMA:\r\ncase REG_ESAI_RSMB:\r\ncase REG_ESAI_PRRC:\r\ncase REG_ESAI_PCRC:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool fsl_esai_writeable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase REG_ESAI_ETDR:\r\ncase REG_ESAI_ECR:\r\ncase REG_ESAI_TFCR:\r\ncase REG_ESAI_RFCR:\r\ncase REG_ESAI_TX0:\r\ncase REG_ESAI_TX1:\r\ncase REG_ESAI_TX2:\r\ncase REG_ESAI_TX3:\r\ncase REG_ESAI_TX4:\r\ncase REG_ESAI_TX5:\r\ncase REG_ESAI_TSR:\r\ncase REG_ESAI_SAICR:\r\ncase REG_ESAI_TCR:\r\ncase REG_ESAI_TCCR:\r\ncase REG_ESAI_RCR:\r\ncase REG_ESAI_RCCR:\r\ncase REG_ESAI_TSMA:\r\ncase REG_ESAI_TSMB:\r\ncase REG_ESAI_RSMA:\r\ncase REG_ESAI_RSMB:\r\ncase REG_ESAI_PRRC:\r\ncase REG_ESAI_PCRC:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int fsl_esai_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct fsl_esai *esai_priv;\r\nstruct resource *res;\r\nconst uint32_t *iprop;\r\nvoid __iomem *regs;\r\nint irq, ret;\r\nesai_priv = devm_kzalloc(&pdev->dev, sizeof(*esai_priv), GFP_KERNEL);\r\nif (!esai_priv)\r\nreturn -ENOMEM;\r\nesai_priv->pdev = pdev;\r\nstrncpy(esai_priv->name, np->name, sizeof(esai_priv->name) - 1);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nregs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(regs))\r\nreturn PTR_ERR(regs);\r\nesai_priv->regmap = devm_regmap_init_mmio_clk(&pdev->dev,\r\n"core", regs, &fsl_esai_regmap_config);\r\nif (IS_ERR(esai_priv->regmap)) {\r\ndev_err(&pdev->dev, "failed to init regmap: %ld\n",\r\nPTR_ERR(esai_priv->regmap));\r\nreturn PTR_ERR(esai_priv->regmap);\r\n}\r\nesai_priv->coreclk = devm_clk_get(&pdev->dev, "core");\r\nif (IS_ERR(esai_priv->coreclk)) {\r\ndev_err(&pdev->dev, "failed to get core clock: %ld\n",\r\nPTR_ERR(esai_priv->coreclk));\r\nreturn PTR_ERR(esai_priv->coreclk);\r\n}\r\nesai_priv->extalclk = devm_clk_get(&pdev->dev, "extal");\r\nif (IS_ERR(esai_priv->extalclk))\r\ndev_warn(&pdev->dev, "failed to get extal clock: %ld\n",\r\nPTR_ERR(esai_priv->extalclk));\r\nesai_priv->fsysclk = devm_clk_get(&pdev->dev, "fsys");\r\nif (IS_ERR(esai_priv->fsysclk))\r\ndev_warn(&pdev->dev, "failed to get fsys clock: %ld\n",\r\nPTR_ERR(esai_priv->fsysclk));\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no irq for node %s\n", pdev->name);\r\nreturn irq;\r\n}\r\nret = devm_request_irq(&pdev->dev, irq, esai_isr, 0,\r\nesai_priv->name, esai_priv);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to claim irq %u\n", irq);\r\nreturn ret;\r\n}\r\nesai_priv->slots = 2;\r\nesai_priv->slave_mode = true;\r\niprop = of_get_property(np, "fsl,fifo-depth", NULL);\r\nif (iprop)\r\nesai_priv->fifo_depth = be32_to_cpup(iprop);\r\nelse\r\nesai_priv->fifo_depth = 64;\r\nesai_priv->dma_params_tx.maxburst = 16;\r\nesai_priv->dma_params_rx.maxburst = 16;\r\nesai_priv->dma_params_tx.addr = res->start + REG_ESAI_ETDR;\r\nesai_priv->dma_params_rx.addr = res->start + REG_ESAI_ERDR;\r\nesai_priv->synchronous =\r\nof_property_read_bool(np, "fsl,esai-synchronous");\r\nif (esai_priv->synchronous) {\r\nfsl_esai_dai.symmetric_rates = 1;\r\nfsl_esai_dai.symmetric_channels = 1;\r\nfsl_esai_dai.symmetric_samplebits = 1;\r\n}\r\ndev_set_drvdata(&pdev->dev, esai_priv);\r\nret = regmap_write(esai_priv->regmap, REG_ESAI_ECR, ESAI_ECR_ERST);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to reset ESAI: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_write(esai_priv->regmap, REG_ESAI_ECR, ESAI_ECR_ESAIEN);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to enable ESAI: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = devm_snd_soc_register_component(&pdev->dev, &fsl_esai_component,\r\n&fsl_esai_dai, 1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register DAI: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = imx_pcm_dma_init(pdev);\r\nif (ret)\r\ndev_err(&pdev->dev, "failed to init imx pcm dma: %d\n", ret);\r\nreturn ret;\r\n}
