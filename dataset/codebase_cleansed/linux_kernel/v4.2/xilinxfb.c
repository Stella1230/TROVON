static void xilinx_fb_out32(struct xilinxfb_drvdata *drvdata, u32 offset,\r\nu32 val)\r\n{\r\nif (drvdata->flags & BUS_ACCESS_FLAG) {\r\nif (drvdata->flags & LITTLE_ENDIAN_ACCESS)\r\niowrite32(val, drvdata->regs + (offset << 2));\r\nelse\r\niowrite32be(val, drvdata->regs + (offset << 2));\r\n}\r\n#ifdef CONFIG_PPC_DCR\r\nelse\r\ndcr_write(drvdata->dcr_host, offset, val);\r\n#endif\r\n}\r\nstatic u32 xilinx_fb_in32(struct xilinxfb_drvdata *drvdata, u32 offset)\r\n{\r\nif (drvdata->flags & BUS_ACCESS_FLAG) {\r\nif (drvdata->flags & LITTLE_ENDIAN_ACCESS)\r\nreturn ioread32(drvdata->regs + (offset << 2));\r\nelse\r\nreturn ioread32be(drvdata->regs + (offset << 2));\r\n}\r\n#ifdef CONFIG_PPC_DCR\r\nelse\r\nreturn dcr_read(drvdata->dcr_host, offset);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int\r\nxilinx_fb_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue,\r\nunsigned transp, struct fb_info *fbi)\r\n{\r\nu32 *palette = fbi->pseudo_palette;\r\nif (regno >= PALETTE_ENTRIES_NO)\r\nreturn -EINVAL;\r\nif (fbi->var.grayscale) {\r\nred = green = blue =\r\n(red * 77 + green * 151 + blue * 28 + 127) >> 8;\r\n}\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\npalette[regno] = (red << RED_SHIFT) | (green << GREEN_SHIFT) |\r\n(blue << BLUE_SHIFT);\r\nreturn 0;\r\n}\r\nstatic int\r\nxilinx_fb_blank(int blank_mode, struct fb_info *fbi)\r\n{\r\nstruct xilinxfb_drvdata *drvdata = to_xilinxfb_drvdata(fbi);\r\nswitch (blank_mode) {\r\ncase FB_BLANK_UNBLANK:\r\nxilinx_fb_out32(drvdata, REG_CTRL, drvdata->reg_ctrl_default);\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ncase FB_BLANK_POWERDOWN:\r\nxilinx_fb_out32(drvdata, REG_CTRL, 0);\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xilinxfb_assign(struct platform_device *pdev,\r\nstruct xilinxfb_drvdata *drvdata,\r\nstruct xilinxfb_platform_data *pdata)\r\n{\r\nint rc;\r\nstruct device *dev = &pdev->dev;\r\nint fbsize = pdata->xvirt * pdata->yvirt * BYTES_PER_PIXEL;\r\nif (drvdata->flags & BUS_ACCESS_FLAG) {\r\nstruct resource *res;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndrvdata->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(drvdata->regs))\r\nreturn PTR_ERR(drvdata->regs);\r\ndrvdata->regs_phys = res->start;\r\n}\r\nif (pdata->fb_phys) {\r\ndrvdata->fb_phys = pdata->fb_phys;\r\ndrvdata->fb_virt = ioremap(pdata->fb_phys, fbsize);\r\n} else {\r\ndrvdata->fb_alloced = 1;\r\ndrvdata->fb_virt = dma_alloc_coherent(dev, PAGE_ALIGN(fbsize),\r\n&drvdata->fb_phys, GFP_KERNEL);\r\n}\r\nif (!drvdata->fb_virt) {\r\ndev_err(dev, "Could not allocate frame buffer memory\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset_io((void __iomem *)drvdata->fb_virt, 0, fbsize);\r\nxilinx_fb_out32(drvdata, REG_FB_ADDR, drvdata->fb_phys);\r\nrc = xilinx_fb_in32(drvdata, REG_FB_ADDR);\r\nif (rc != drvdata->fb_phys) {\r\ndrvdata->flags |= LITTLE_ENDIAN_ACCESS;\r\nxilinx_fb_out32(drvdata, REG_FB_ADDR, drvdata->fb_phys);\r\n}\r\ndrvdata->reg_ctrl_default = REG_CTRL_ENABLE;\r\nif (pdata->rotate_screen)\r\ndrvdata->reg_ctrl_default |= REG_CTRL_ROTATE;\r\nxilinx_fb_out32(drvdata, REG_CTRL,\r\ndrvdata->reg_ctrl_default);\r\ndrvdata->info.device = dev;\r\ndrvdata->info.screen_base = (void __iomem *)drvdata->fb_virt;\r\ndrvdata->info.fbops = &xilinxfb_ops;\r\ndrvdata->info.fix = xilinx_fb_fix;\r\ndrvdata->info.fix.smem_start = drvdata->fb_phys;\r\ndrvdata->info.fix.smem_len = fbsize;\r\ndrvdata->info.fix.line_length = pdata->xvirt * BYTES_PER_PIXEL;\r\ndrvdata->info.pseudo_palette = drvdata->pseudo_palette;\r\ndrvdata->info.flags = FBINFO_DEFAULT;\r\ndrvdata->info.var = xilinx_fb_var;\r\ndrvdata->info.var.height = pdata->screen_height_mm;\r\ndrvdata->info.var.width = pdata->screen_width_mm;\r\ndrvdata->info.var.xres = pdata->xres;\r\ndrvdata->info.var.yres = pdata->yres;\r\ndrvdata->info.var.xres_virtual = pdata->xvirt;\r\ndrvdata->info.var.yres_virtual = pdata->yvirt;\r\nrc = fb_alloc_cmap(&drvdata->info.cmap, PALETTE_ENTRIES_NO, 0);\r\nif (rc) {\r\ndev_err(dev, "Fail to allocate colormap (%d entries)\n",\r\nPALETTE_ENTRIES_NO);\r\ngoto err_cmap;\r\n}\r\nrc = register_framebuffer(&drvdata->info);\r\nif (rc) {\r\ndev_err(dev, "Could not register frame buffer\n");\r\ngoto err_regfb;\r\n}\r\nif (drvdata->flags & BUS_ACCESS_FLAG) {\r\ndev_dbg(dev, "regs: phys=%pa, virt=%p\n",\r\n&drvdata->regs_phys, drvdata->regs);\r\n}\r\ndev_dbg(dev, "fb: phys=%llx, virt=%p, size=%x\n",\r\n(unsigned long long)drvdata->fb_phys, drvdata->fb_virt, fbsize);\r\nreturn 0;\r\nerr_regfb:\r\nfb_dealloc_cmap(&drvdata->info.cmap);\r\nerr_cmap:\r\nif (drvdata->fb_alloced)\r\ndma_free_coherent(dev, PAGE_ALIGN(fbsize), drvdata->fb_virt,\r\ndrvdata->fb_phys);\r\nelse\r\niounmap(drvdata->fb_virt);\r\nxilinx_fb_out32(drvdata, REG_CTRL, 0);\r\nreturn rc;\r\n}\r\nstatic int xilinxfb_release(struct device *dev)\r\n{\r\nstruct xilinxfb_drvdata *drvdata = dev_get_drvdata(dev);\r\n#if !defined(CONFIG_FRAMEBUFFER_CONSOLE) && defined(CONFIG_LOGO)\r\nxilinx_fb_blank(VESA_POWERDOWN, &drvdata->info);\r\n#endif\r\nunregister_framebuffer(&drvdata->info);\r\nfb_dealloc_cmap(&drvdata->info.cmap);\r\nif (drvdata->fb_alloced)\r\ndma_free_coherent(dev, PAGE_ALIGN(drvdata->info.fix.smem_len),\r\ndrvdata->fb_virt, drvdata->fb_phys);\r\nelse\r\niounmap(drvdata->fb_virt);\r\nxilinx_fb_out32(drvdata, REG_CTRL, 0);\r\n#ifdef CONFIG_PPC_DCR\r\nif (!(drvdata->flags & BUS_ACCESS_FLAG))\r\ndcr_unmap(drvdata->dcr_host, drvdata->dcr_len);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int xilinxfb_of_probe(struct platform_device *pdev)\r\n{\r\nconst u32 *prop;\r\nu32 tft_access = 0;\r\nstruct xilinxfb_platform_data pdata;\r\nint size;\r\nstruct xilinxfb_drvdata *drvdata;\r\npdata = xilinx_fb_default_pdata;\r\ndrvdata = devm_kzalloc(&pdev->dev, sizeof(*drvdata), GFP_KERNEL);\r\nif (!drvdata)\r\nreturn -ENOMEM;\r\nof_property_read_u32(pdev->dev.of_node, "xlnx,dcr-splb-slave-if",\r\n&tft_access);\r\nif (tft_access) {\r\ndrvdata->flags |= BUS_ACCESS_FLAG;\r\n}\r\n#ifdef CONFIG_PPC_DCR\r\nelse {\r\nint start;\r\nstart = dcr_resource_start(pdev->dev.of_node, 0);\r\ndrvdata->dcr_len = dcr_resource_len(pdev->dev.of_node, 0);\r\ndrvdata->dcr_host = dcr_map(pdev->dev.of_node, start, drvdata->dcr_len);\r\nif (!DCR_MAP_OK(drvdata->dcr_host)) {\r\ndev_err(&pdev->dev, "invalid DCR address\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\n#endif\r\nprop = of_get_property(pdev->dev.of_node, "phys-size", &size);\r\nif ((prop) && (size >= sizeof(u32)*2)) {\r\npdata.screen_width_mm = prop[0];\r\npdata.screen_height_mm = prop[1];\r\n}\r\nprop = of_get_property(pdev->dev.of_node, "resolution", &size);\r\nif ((prop) && (size >= sizeof(u32)*2)) {\r\npdata.xres = prop[0];\r\npdata.yres = prop[1];\r\n}\r\nprop = of_get_property(pdev->dev.of_node, "virtual-resolution", &size);\r\nif ((prop) && (size >= sizeof(u32)*2)) {\r\npdata.xvirt = prop[0];\r\npdata.yvirt = prop[1];\r\n}\r\nif (of_find_property(pdev->dev.of_node, "rotate-display", NULL))\r\npdata.rotate_screen = 1;\r\ndev_set_drvdata(&pdev->dev, drvdata);\r\nreturn xilinxfb_assign(pdev, drvdata, &pdata);\r\n}\r\nstatic int xilinxfb_of_remove(struct platform_device *op)\r\n{\r\nreturn xilinxfb_release(&op->dev);\r\n}
