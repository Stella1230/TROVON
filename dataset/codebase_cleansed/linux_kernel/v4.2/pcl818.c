static void pcl818_ai_setup_dma(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int unread_samples)\r\n{\r\nstruct pcl818_private *devpriv = dev->private;\r\nstruct comedi_isadma *dma = devpriv->dma;\r\nstruct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];\r\nunsigned int max_samples = comedi_bytes_to_samples(s, desc->maxsize);\r\nunsigned int nsamples;\r\ncomedi_isadma_disable(dma->chan);\r\nnsamples = comedi_nsamples_left(s, max_samples + unread_samples);\r\nif (nsamples > unread_samples) {\r\nnsamples -= unread_samples;\r\ndesc->size = comedi_samples_to_bytes(s, nsamples);\r\ncomedi_isadma_program(desc);\r\n}\r\n}\r\nstatic void pcl818_ai_set_chan_range(struct comedi_device *dev,\r\nunsigned int chan,\r\nunsigned int range)\r\n{\r\noutb(chan, dev->iobase + PCL818_MUX_REG);\r\noutb(range, dev->iobase + PCL818_RANGE_REG);\r\n}\r\nstatic void pcl818_ai_set_chan_scan(struct comedi_device *dev,\r\nunsigned int first_chan,\r\nunsigned int last_chan)\r\n{\r\noutb(PCL818_MUX_SCAN(first_chan, last_chan),\r\ndev->iobase + PCL818_MUX_REG);\r\n}\r\nstatic void pcl818_ai_setup_chanlist(struct comedi_device *dev,\r\nunsigned int *chanlist,\r\nunsigned int seglen)\r\n{\r\nstruct pcl818_private *devpriv = dev->private;\r\nunsigned int first_chan = CR_CHAN(chanlist[0]);\r\nunsigned int last_chan;\r\nunsigned int range;\r\nint i;\r\ndevpriv->act_chanlist_len = seglen;\r\ndevpriv->act_chanlist_pos = 0;\r\nfor (i = 0; i < seglen; i++) {\r\nlast_chan = CR_CHAN(chanlist[i]);\r\nrange = CR_RANGE(chanlist[i]);\r\ndevpriv->act_chanlist[i] = last_chan;\r\npcl818_ai_set_chan_range(dev, last_chan, range);\r\n}\r\nudelay(1);\r\npcl818_ai_set_chan_scan(dev, first_chan, last_chan);\r\n}\r\nstatic void pcl818_ai_clear_eoc(struct comedi_device *dev)\r\n{\r\noutb(0, dev->iobase + PCL818_STATUS_REG);\r\n}\r\nstatic void pcl818_ai_soft_trig(struct comedi_device *dev)\r\n{\r\noutb(0, dev->iobase + PCL818_AI_LSB_REG);\r\n}\r\nstatic unsigned int pcl818_ai_get_fifo_sample(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int *chan)\r\n{\r\nunsigned int val;\r\nval = inb(dev->iobase + PCL818_FI_DATALO);\r\nval |= (inb(dev->iobase + PCL818_FI_DATAHI) << 8);\r\nif (chan)\r\n*chan = val & 0xf;\r\nreturn (val >> 4) & s->maxdata;\r\n}\r\nstatic unsigned int pcl818_ai_get_sample(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int *chan)\r\n{\r\nunsigned int val;\r\nval = inb(dev->iobase + PCL818_AI_MSB_REG) << 8;\r\nval |= inb(dev->iobase + PCL818_AI_LSB_REG);\r\nif (chan)\r\n*chan = val & 0xf;\r\nreturn (val >> 4) & s->maxdata;\r\n}\r\nstatic int pcl818_ai_eoc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nunsigned int status;\r\nstatus = inb(dev->iobase + PCL818_STATUS_REG);\r\nif (status & PCL818_STATUS_INT)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic bool pcl818_ai_write_sample(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int chan, unsigned int val)\r\n{\r\nstruct pcl818_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int expected_chan;\r\nexpected_chan = devpriv->act_chanlist[devpriv->act_chanlist_pos];\r\nif (chan != expected_chan) {\r\ndev_dbg(dev->class_dev,\r\n"A/D mode1/3 %s - channel dropout %d!=%d !\n",\r\n(devpriv->dma) ? "DMA" :\r\n(devpriv->usefifo) ? "FIFO" : "IRQ",\r\nchan, expected_chan);\r\ns->async->events |= COMEDI_CB_ERROR;\r\nreturn false;\r\n}\r\ncomedi_buf_write_samples(s, &val, 1);\r\ndevpriv->act_chanlist_pos++;\r\nif (devpriv->act_chanlist_pos >= devpriv->act_chanlist_len)\r\ndevpriv->act_chanlist_pos = 0;\r\nif (cmd->stop_src == TRIG_COUNT &&\r\ns->async->scans_done >= cmd->stop_arg) {\r\ns->async->events |= COMEDI_CB_EOA;\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void pcl818_handle_eoc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nunsigned int chan;\r\nunsigned int val;\r\nif (pcl818_ai_eoc(dev, s, NULL, 0)) {\r\ndev_err(dev->class_dev, "A/D mode1/3 IRQ without DRDY!\n");\r\ns->async->events |= COMEDI_CB_ERROR;\r\nreturn;\r\n}\r\nval = pcl818_ai_get_sample(dev, s, &chan);\r\npcl818_ai_write_sample(dev, s, chan, val);\r\n}\r\nstatic void pcl818_handle_dma(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct pcl818_private *devpriv = dev->private;\r\nstruct comedi_isadma *dma = devpriv->dma;\r\nstruct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];\r\nunsigned short *ptr = desc->virt_addr;\r\nunsigned int nsamples = comedi_bytes_to_samples(s, desc->size);\r\nunsigned int chan;\r\nunsigned int val;\r\nint i;\r\ndma->cur_dma = 1 - dma->cur_dma;\r\npcl818_ai_setup_dma(dev, s, nsamples);\r\nfor (i = 0; i < nsamples; i++) {\r\nval = ptr[i];\r\nchan = val & 0xf;\r\nval = (val >> 4) & s->maxdata;\r\nif (!pcl818_ai_write_sample(dev, s, chan, val))\r\nbreak;\r\n}\r\n}\r\nstatic void pcl818_handle_fifo(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nunsigned int status;\r\nunsigned int chan;\r\nunsigned int val;\r\nint i, len;\r\nstatus = inb(dev->iobase + PCL818_FI_STATUS);\r\nif (status & 4) {\r\ndev_err(dev->class_dev, "A/D mode1/3 FIFO overflow!\n");\r\ns->async->events |= COMEDI_CB_ERROR;\r\nreturn;\r\n}\r\nif (status & 1) {\r\ndev_err(dev->class_dev,\r\n"A/D mode1/3 FIFO interrupt without data!\n");\r\ns->async->events |= COMEDI_CB_ERROR;\r\nreturn;\r\n}\r\nif (status & 2)\r\nlen = 512;\r\nelse\r\nlen = 0;\r\nfor (i = 0; i < len; i++) {\r\nval = pcl818_ai_get_fifo_sample(dev, s, &chan);\r\nif (!pcl818_ai_write_sample(dev, s, chan, val))\r\nbreak;\r\n}\r\n}\r\nstatic irqreturn_t pcl818_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct pcl818_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nif (!dev->attached || !devpriv->ai_cmd_running) {\r\npcl818_ai_clear_eoc(dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (devpriv->ai_cmd_canceled) {\r\ns->async->scans_done = cmd->stop_arg;\r\ns->cancel(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (devpriv->dma)\r\npcl818_handle_dma(dev, s);\r\nelse if (devpriv->usefifo)\r\npcl818_handle_fifo(dev, s);\r\nelse\r\npcl818_handle_eoc(dev, s);\r\npcl818_ai_clear_eoc(dev);\r\ncomedi_handle_events(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int check_channel_list(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int *chanlist, unsigned int n_chan)\r\n{\r\nunsigned int chansegment[16];\r\nunsigned int i, nowmustbechan, seglen, segpos;\r\nif (n_chan < 1) {\r\ndev_err(dev->class_dev, "range/channel list is empty!\n");\r\nreturn 0;\r\n}\r\nif (n_chan > 1) {\r\nchansegment[0] = chanlist[0];\r\nfor (i = 1, seglen = 1; i < n_chan; i++, seglen++) {\r\nif (chanlist[0] == chanlist[i])\r\nbreak;\r\nnowmustbechan =\r\n(CR_CHAN(chansegment[i - 1]) + 1) % s->n_chan;\r\nif (nowmustbechan != CR_CHAN(chanlist[i])) {\r\ndev_dbg(dev->class_dev,\r\n"channel list must be continuous! chanlist[%i]=%d but must be %d or %d!\n",\r\ni, CR_CHAN(chanlist[i]), nowmustbechan,\r\nCR_CHAN(chanlist[0]));\r\nreturn 0;\r\n}\r\nchansegment[i] = chanlist[i];\r\n}\r\nfor (i = 0, segpos = 0; i < n_chan; i++) {\r\nif (chanlist[i] != chansegment[i % seglen]) {\r\ndev_dbg(dev->class_dev,\r\n"bad channel or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",\r\ni, CR_CHAN(chansegment[i]),\r\nCR_RANGE(chansegment[i]),\r\nCR_AREF(chansegment[i]),\r\nCR_CHAN(chanlist[i % seglen]),\r\nCR_RANGE(chanlist[i % seglen]),\r\nCR_AREF(chansegment[i % seglen]));\r\nreturn 0;\r\n}\r\n}\r\n} else {\r\nseglen = 1;\r\n}\r\nreturn seglen;\r\n}\r\nstatic int check_single_ended(unsigned int port)\r\n{\r\nif (inb(port + PCL818_STATUS_REG) & PCL818_STATUS_MUX)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nconst struct pcl818_board *board = dev->board_ptr;\r\nint err = 0;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_FOLLOW);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src,\r\nTRIG_TIMER | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->convert_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nerr |= comedi_check_trigger_arg_min(&cmd->convert_arg,\r\nboard->ns_min);\r\n} else {\r\nerr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\r\n}\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nunsigned int arg = cmd->convert_arg;\r\ncomedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);\r\nerr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\r\n}\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist) {\r\nif (!check_channel_list(dev, s, cmd->chanlist,\r\ncmd->chanlist_len))\r\nreturn 5;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcl818_ai_cmd(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct pcl818_private *devpriv = dev->private;\r\nstruct comedi_isadma *dma = devpriv->dma;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int ctrl = 0;\r\nunsigned int seglen;\r\nif (devpriv->ai_cmd_running)\r\nreturn -EBUSY;\r\nseglen = check_channel_list(dev, s, cmd->chanlist, cmd->chanlist_len);\r\nif (seglen < 1)\r\nreturn -EINVAL;\r\npcl818_ai_setup_chanlist(dev, cmd->chanlist, seglen);\r\ndevpriv->ai_cmd_running = 1;\r\ndevpriv->ai_cmd_canceled = 0;\r\ndevpriv->act_chanlist_pos = 0;\r\nif (cmd->convert_src == TRIG_TIMER)\r\nctrl |= PCL818_CTRL_PACER_TRIG;\r\nelse\r\nctrl |= PCL818_CTRL_EXT_TRIG;\r\noutb(PCL818_CNTENABLE_PACER_ENA, dev->iobase + PCL818_CNTENABLE_REG);\r\nif (dma) {\r\ndma->cur_dma = 0;\r\npcl818_ai_setup_dma(dev, s, 0);\r\nctrl |= PCL818_CTRL_INTE | PCL818_CTRL_IRQ(dev->irq) |\r\nPCL818_CTRL_DMAE;\r\n} else if (devpriv->usefifo) {\r\noutb(1, dev->iobase + PCL818_FI_ENABLE);\r\n} else {\r\nctrl |= PCL818_CTRL_INTE | PCL818_CTRL_IRQ(dev->irq);\r\n}\r\noutb(ctrl, dev->iobase + PCL818_CTRL_REG);\r\nif (cmd->convert_src == TRIG_TIMER) {\r\ncomedi_8254_update_divisors(dev->pacer);\r\ncomedi_8254_pacer_enable(dev->pacer, 1, 2, true);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcl818_ai_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct pcl818_private *devpriv = dev->private;\r\nstruct comedi_isadma *dma = devpriv->dma;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nif (!devpriv->ai_cmd_running)\r\nreturn 0;\r\nif (dma) {\r\nif (cmd->stop_src == TRIG_NONE ||\r\n(cmd->stop_src == TRIG_COUNT &&\r\ns->async->scans_done < cmd->stop_arg)) {\r\nif (!devpriv->ai_cmd_canceled) {\r\ndevpriv->ai_cmd_canceled = 1;\r\nreturn 0;\r\n}\r\n}\r\ncomedi_isadma_disable(dma->chan);\r\n}\r\noutb(PCL818_CTRL_DISABLE_TRIG, dev->iobase + PCL818_CTRL_REG);\r\ncomedi_8254_pacer_enable(dev->pacer, 1, 2, false);\r\npcl818_ai_clear_eoc(dev);\r\nif (devpriv->usefifo) {\r\noutb(0, dev->iobase + PCL818_FI_INTCLR);\r\noutb(0, dev->iobase + PCL818_FI_FLUSH);\r\noutb(0, dev->iobase + PCL818_FI_ENABLE);\r\n}\r\ndevpriv->ai_cmd_running = 0;\r\ndevpriv->ai_cmd_canceled = 0;\r\nreturn 0;\r\n}\r\nstatic int pcl818_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int range = CR_RANGE(insn->chanspec);\r\nint ret = 0;\r\nint i;\r\noutb(PCL818_CTRL_SOFT_TRIG, dev->iobase + PCL818_CTRL_REG);\r\npcl818_ai_set_chan_range(dev, chan, range);\r\npcl818_ai_set_chan_scan(dev, chan, chan);\r\nfor (i = 0; i < insn->n; i++) {\r\npcl818_ai_clear_eoc(dev);\r\npcl818_ai_soft_trig(dev);\r\nret = comedi_timeout(dev, s, insn, pcl818_ai_eoc, 0);\r\nif (ret)\r\nbreak;\r\ndata[i] = pcl818_ai_get_sample(dev, s, NULL);\r\n}\r\npcl818_ai_clear_eoc(dev);\r\nreturn ret ? ret : insn->n;\r\n}\r\nstatic int pcl818_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int val = s->readback[chan];\r\nint i;\r\nfor (i = 0; i < insn->n; i++) {\r\nval = data[i];\r\noutb((val & 0x000f) << 4,\r\ndev->iobase + PCL818_AO_LSB_REG(chan));\r\noutb((val & 0x0ff0) >> 4,\r\ndev->iobase + PCL818_AO_MSB_REG(chan));\r\n}\r\ns->readback[chan] = val;\r\nreturn insn->n;\r\n}\r\nstatic int pcl818_di_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\ndata[1] = inb(dev->iobase + PCL818_DO_DI_LSB_REG) |\r\n(inb(dev->iobase + PCL818_DO_DI_MSB_REG) << 8);\r\nreturn insn->n;\r\n}\r\nstatic int pcl818_do_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nif (comedi_dio_update_state(s, data)) {\r\noutb(s->state & 0xff, dev->iobase + PCL818_DO_DI_LSB_REG);\r\noutb((s->state >> 8), dev->iobase + PCL818_DO_DI_MSB_REG);\r\n}\r\ndata[1] = s->state;\r\nreturn insn->n;\r\n}\r\nstatic void pcl818_reset(struct comedi_device *dev)\r\n{\r\nconst struct pcl818_board *board = dev->board_ptr;\r\nunsigned int chan;\r\nif (board->has_fifo) {\r\noutb(0, dev->iobase + PCL818_FI_INTCLR);\r\noutb(0, dev->iobase + PCL818_FI_FLUSH);\r\noutb(0, dev->iobase + PCL818_FI_ENABLE);\r\n}\r\noutb(PCL818_CTRL_DISABLE_TRIG, dev->iobase + PCL818_CTRL_REG);\r\npcl818_ai_clear_eoc(dev);\r\npcl818_ai_set_chan_range(dev, 0, 0);\r\noutb(PCL818_CNTENABLE_PACER_ENA, dev->iobase + PCL818_CNTENABLE_REG);\r\nfor (chan = 0; chan < board->n_aochan; chan++) {\r\noutb(0, dev->iobase + PCL818_AO_LSB_REG(chan));\r\noutb(0, dev->iobase + PCL818_AO_MSB_REG(chan));\r\n}\r\noutb(0, dev->iobase + PCL818_DO_DI_MSB_REG);\r\noutb(0, dev->iobase + PCL818_DO_DI_LSB_REG);\r\n}\r\nstatic void pcl818_set_ai_range_table(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_devconfig *it)\r\n{\r\nconst struct pcl818_board *board = dev->board_ptr;\r\ns->range_table = board->ai_range_type;\r\nif (board->is_818) {\r\nif (it->options[4] == 1 || it->options[4] == 10) {\r\ns->range_table = &range_pcl818l_h_ai;\r\n}\r\n} else {\r\nswitch (it->options[4]) {\r\ncase 0:\r\ns->range_table = &range_bipolar10;\r\nbreak;\r\ncase 1:\r\ns->range_table = &range_bipolar5;\r\nbreak;\r\ncase 2:\r\ns->range_table = &range_bipolar2_5;\r\nbreak;\r\ncase 3:\r\ns->range_table = &range718_bipolar1;\r\nbreak;\r\ncase 4:\r\ns->range_table = &range718_bipolar0_5;\r\nbreak;\r\ncase 6:\r\ns->range_table = &range_unipolar10;\r\nbreak;\r\ncase 7:\r\ns->range_table = &range_unipolar5;\r\nbreak;\r\ncase 8:\r\ns->range_table = &range718_unipolar2;\r\nbreak;\r\ncase 9:\r\ns->range_table = &range718_unipolar1;\r\nbreak;\r\ndefault:\r\ns->range_table = &range_unknown;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void pcl818_alloc_dma(struct comedi_device *dev, unsigned int dma_chan)\r\n{\r\nstruct pcl818_private *devpriv = dev->private;\r\nif (!(dma_chan == 3 || dma_chan == 1))\r\nreturn;\r\ndevpriv->dma = comedi_isadma_alloc(dev, 2, dma_chan, dma_chan,\r\nPAGE_SIZE * 4, COMEDI_ISADMA_READ);\r\n}\r\nstatic void pcl818_free_dma(struct comedi_device *dev)\r\n{\r\nstruct pcl818_private *devpriv = dev->private;\r\nif (devpriv)\r\ncomedi_isadma_free(devpriv->dma);\r\n}\r\nstatic int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nconst struct pcl818_board *board = dev->board_ptr;\r\nstruct pcl818_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nunsigned int osc_base;\r\nint ret;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nret = comedi_request_region(dev, it->options[0],\r\nboard->has_fifo ? 0x20 : 0x10);\r\nif (ret)\r\nreturn ret;\r\nif (it->options[1] >= 2 && it->options[1] <= 7) {\r\nret = request_irq(it->options[1], pcl818_interrupt, 0,\r\ndev->board_name, dev);\r\nif (ret == 0)\r\ndev->irq = it->options[1];\r\n}\r\nif (dev->irq && board->has_fifo && it->options[2] == -1)\r\ndevpriv->usefifo = 1;\r\nif (dev->irq && board->has_dma)\r\npcl818_alloc_dma(dev, it->options[2]);\r\nif ((it->options[3] == 0) || (it->options[3] == 10))\r\nosc_base = I8254_OSC_BASE_10MHZ;\r\nelse\r\nosc_base = I8254_OSC_BASE_1MHZ;\r\ndev->pacer = comedi_8254_init(dev->iobase + PCL818_TIMER_BASE,\r\nosc_base, I8254_IO8, 0);\r\nif (!dev->pacer)\r\nreturn -ENOMEM;\r\ndevpriv->ns_min = board->ns_min;\r\nif (!board->is_818) {\r\nif ((it->options[6] == 1) || (it->options[6] == 100))\r\ndevpriv->ns_min = 10000;\r\n}\r\nret = comedi_alloc_subdevices(dev, 4);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE;\r\nif (check_single_ended(dev->iobase)) {\r\ns->n_chan = 16;\r\ns->subdev_flags |= SDF_COMMON | SDF_GROUND;\r\n} else {\r\ns->n_chan = 8;\r\ns->subdev_flags |= SDF_DIFF;\r\n}\r\ns->maxdata = 0x0fff;\r\npcl818_set_ai_range_table(dev, s, it);\r\ns->insn_read = pcl818_ai_insn_read;\r\nif (dev->irq) {\r\ndev->read_subdev = s;\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->len_chanlist = s->n_chan;\r\ns->do_cmdtest = ai_cmdtest;\r\ns->do_cmd = pcl818_ai_cmd;\r\ns->cancel = pcl818_ai_cancel;\r\n}\r\ns = &dev->subdevices[1];\r\nif (board->n_aochan) {\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_GROUND;\r\ns->n_chan = board->n_aochan;\r\ns->maxdata = 0x0fff;\r\ns->range_table = &range_unipolar5;\r\nif (board->is_818) {\r\nif ((it->options[4] == 1) || (it->options[4] == 10))\r\ns->range_table = &range_unipolar10;\r\nif (it->options[4] == 2)\r\ns->range_table = &range_unknown;\r\n} else {\r\nif ((it->options[5] == 1) || (it->options[5] == 10))\r\ns->range_table = &range_unipolar10;\r\nif (it->options[5] == 2)\r\ns->range_table = &range_unknown;\r\n}\r\ns->insn_write = pcl818_ao_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 16;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = pcl818_di_insn_bits;\r\ns = &dev->subdevices[3];\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 16;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = pcl818_do_insn_bits;\r\npcl818_reset(dev);\r\nreturn 0;\r\n}\r\nstatic void pcl818_detach(struct comedi_device *dev)\r\n{\r\nstruct pcl818_private *devpriv = dev->private;\r\nif (devpriv) {\r\npcl818_ai_cancel(dev, dev->read_subdev);\r\npcl818_reset(dev);\r\n}\r\npcl818_free_dma(dev);\r\ncomedi_legacy_detach(dev);\r\n}
