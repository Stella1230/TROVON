static u32 ns_to_src(struct src_sel *s, u32 ns)\r\n{\r\nns >>= s->src_sel_shift;\r\nns &= SRC_SEL_MASK;\r\nreturn ns;\r\n}\r\nstatic u32 src_to_ns(struct src_sel *s, u8 src, u32 ns)\r\n{\r\nu32 mask;\r\nmask = SRC_SEL_MASK;\r\nmask <<= s->src_sel_shift;\r\nns &= ~mask;\r\nns |= src << s->src_sel_shift;\r\nreturn ns;\r\n}\r\nstatic u8 clk_rcg_get_parent(struct clk_hw *hw)\r\n{\r\nstruct clk_rcg *rcg = to_clk_rcg(hw);\r\nint num_parents = __clk_get_num_parents(hw->clk);\r\nu32 ns;\r\nint i, ret;\r\nret = regmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\r\nif (ret)\r\ngoto err;\r\nns = ns_to_src(&rcg->s, ns);\r\nfor (i = 0; i < num_parents; i++)\r\nif (ns == rcg->s.parent_map[i].cfg)\r\nreturn i;\r\nerr:\r\npr_debug("%s: Clock %s has invalid parent, using default.\n",\r\n__func__, __clk_get_name(hw->clk));\r\nreturn 0;\r\n}\r\nstatic int reg_to_bank(struct clk_dyn_rcg *rcg, u32 bank)\r\n{\r\nbank &= BIT(rcg->mux_sel_bit);\r\nreturn !!bank;\r\n}\r\nstatic u8 clk_dyn_rcg_get_parent(struct clk_hw *hw)\r\n{\r\nstruct clk_dyn_rcg *rcg = to_clk_dyn_rcg(hw);\r\nint num_parents = __clk_get_num_parents(hw->clk);\r\nu32 ns, reg;\r\nint bank;\r\nint i, ret;\r\nstruct src_sel *s;\r\nret = regmap_read(rcg->clkr.regmap, rcg->bank_reg, &reg);\r\nif (ret)\r\ngoto err;\r\nbank = reg_to_bank(rcg, reg);\r\ns = &rcg->s[bank];\r\nret = regmap_read(rcg->clkr.regmap, rcg->ns_reg[bank], &ns);\r\nif (ret)\r\ngoto err;\r\nns = ns_to_src(s, ns);\r\nfor (i = 0; i < num_parents; i++)\r\nif (ns == s->parent_map[i].cfg)\r\nreturn i;\r\nerr:\r\npr_debug("%s: Clock %s has invalid parent, using default.\n",\r\n__func__, __clk_get_name(hw->clk));\r\nreturn 0;\r\n}\r\nstatic int clk_rcg_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct clk_rcg *rcg = to_clk_rcg(hw);\r\nu32 ns;\r\nregmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\r\nns = src_to_ns(&rcg->s, rcg->s.parent_map[index].cfg, ns);\r\nregmap_write(rcg->clkr.regmap, rcg->ns_reg, ns);\r\nreturn 0;\r\n}\r\nstatic u32 md_to_m(struct mn *mn, u32 md)\r\n{\r\nmd >>= mn->m_val_shift;\r\nmd &= BIT(mn->width) - 1;\r\nreturn md;\r\n}\r\nstatic u32 ns_to_pre_div(struct pre_div *p, u32 ns)\r\n{\r\nns >>= p->pre_div_shift;\r\nns &= BIT(p->pre_div_width) - 1;\r\nreturn ns;\r\n}\r\nstatic u32 pre_div_to_ns(struct pre_div *p, u8 pre_div, u32 ns)\r\n{\r\nu32 mask;\r\nmask = BIT(p->pre_div_width) - 1;\r\nmask <<= p->pre_div_shift;\r\nns &= ~mask;\r\nns |= pre_div << p->pre_div_shift;\r\nreturn ns;\r\n}\r\nstatic u32 mn_to_md(struct mn *mn, u32 m, u32 n, u32 md)\r\n{\r\nu32 mask, mask_w;\r\nmask_w = BIT(mn->width) - 1;\r\nmask = (mask_w << mn->m_val_shift) | mask_w;\r\nmd &= ~mask;\r\nif (n) {\r\nm <<= mn->m_val_shift;\r\nmd |= m;\r\nmd |= ~n & mask_w;\r\n}\r\nreturn md;\r\n}\r\nstatic u32 ns_m_to_n(struct mn *mn, u32 ns, u32 m)\r\n{\r\nns = ~ns >> mn->n_val_shift;\r\nns &= BIT(mn->width) - 1;\r\nreturn ns + m;\r\n}\r\nstatic u32 reg_to_mnctr_mode(struct mn *mn, u32 val)\r\n{\r\nval >>= mn->mnctr_mode_shift;\r\nval &= MNCTR_MODE_MASK;\r\nreturn val;\r\n}\r\nstatic u32 mn_to_ns(struct mn *mn, u32 m, u32 n, u32 ns)\r\n{\r\nu32 mask;\r\nmask = BIT(mn->width) - 1;\r\nmask <<= mn->n_val_shift;\r\nns &= ~mask;\r\nif (n) {\r\nn = n - m;\r\nn = ~n;\r\nn &= BIT(mn->width) - 1;\r\nn <<= mn->n_val_shift;\r\nns |= n;\r\n}\r\nreturn ns;\r\n}\r\nstatic u32 mn_to_reg(struct mn *mn, u32 m, u32 n, u32 val)\r\n{\r\nu32 mask;\r\nmask = MNCTR_MODE_MASK << mn->mnctr_mode_shift;\r\nmask |= BIT(mn->mnctr_en_bit);\r\nval &= ~mask;\r\nif (n) {\r\nval |= BIT(mn->mnctr_en_bit);\r\nval |= MNCTR_MODE_DUAL << mn->mnctr_mode_shift;\r\n}\r\nreturn val;\r\n}\r\nstatic int configure_bank(struct clk_dyn_rcg *rcg, const struct freq_tbl *f)\r\n{\r\nu32 ns, md, reg;\r\nint bank, new_bank, ret, index;\r\nstruct mn *mn;\r\nstruct pre_div *p;\r\nstruct src_sel *s;\r\nbool enabled;\r\nu32 md_reg, ns_reg;\r\nbool banked_mn = !!rcg->mn[1].width;\r\nbool banked_p = !!rcg->p[1].pre_div_width;\r\nstruct clk_hw *hw = &rcg->clkr.hw;\r\nenabled = __clk_is_enabled(hw->clk);\r\nret = regmap_read(rcg->clkr.regmap, rcg->bank_reg, &reg);\r\nif (ret)\r\nreturn ret;\r\nbank = reg_to_bank(rcg, reg);\r\nnew_bank = enabled ? !bank : bank;\r\nns_reg = rcg->ns_reg[new_bank];\r\nret = regmap_read(rcg->clkr.regmap, ns_reg, &ns);\r\nif (ret)\r\nreturn ret;\r\nif (banked_mn) {\r\nmn = &rcg->mn[new_bank];\r\nmd_reg = rcg->md_reg[new_bank];\r\nns |= BIT(mn->mnctr_reset_bit);\r\nret = regmap_write(rcg->clkr.regmap, ns_reg, ns);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_read(rcg->clkr.regmap, md_reg, &md);\r\nif (ret)\r\nreturn ret;\r\nmd = mn_to_md(mn, f->m, f->n, md);\r\nret = regmap_write(rcg->clkr.regmap, md_reg, md);\r\nif (ret)\r\nreturn ret;\r\nns = mn_to_ns(mn, f->m, f->n, ns);\r\nret = regmap_write(rcg->clkr.regmap, ns_reg, ns);\r\nif (ret)\r\nreturn ret;\r\nif (rcg->ns_reg[0] != rcg->ns_reg[1]) {\r\nns = mn_to_reg(mn, f->m, f->n, ns);\r\nret = regmap_write(rcg->clkr.regmap, ns_reg, ns);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nreg = mn_to_reg(mn, f->m, f->n, reg);\r\nret = regmap_write(rcg->clkr.regmap, rcg->bank_reg,\r\nreg);\r\nif (ret)\r\nreturn ret;\r\n}\r\nns &= ~BIT(mn->mnctr_reset_bit);\r\nret = regmap_write(rcg->clkr.regmap, ns_reg, ns);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (banked_p) {\r\np = &rcg->p[new_bank];\r\nns = pre_div_to_ns(p, f->pre_div - 1, ns);\r\n}\r\ns = &rcg->s[new_bank];\r\nindex = qcom_find_src_index(hw, s->parent_map, f->src);\r\nif (index < 0)\r\nreturn index;\r\nns = src_to_ns(s, s->parent_map[index].cfg, ns);\r\nret = regmap_write(rcg->clkr.regmap, ns_reg, ns);\r\nif (ret)\r\nreturn ret;\r\nif (enabled) {\r\nret = regmap_read(rcg->clkr.regmap, rcg->bank_reg, &reg);\r\nif (ret)\r\nreturn ret;\r\nreg ^= BIT(rcg->mux_sel_bit);\r\nret = regmap_write(rcg->clkr.regmap, rcg->bank_reg, reg);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int clk_dyn_rcg_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct clk_dyn_rcg *rcg = to_clk_dyn_rcg(hw);\r\nu32 ns, md, reg;\r\nint bank;\r\nstruct freq_tbl f = { 0 };\r\nbool banked_mn = !!rcg->mn[1].width;\r\nbool banked_p = !!rcg->p[1].pre_div_width;\r\nregmap_read(rcg->clkr.regmap, rcg->bank_reg, &reg);\r\nbank = reg_to_bank(rcg, reg);\r\nregmap_read(rcg->clkr.regmap, rcg->ns_reg[bank], &ns);\r\nif (banked_mn) {\r\nregmap_read(rcg->clkr.regmap, rcg->md_reg[bank], &md);\r\nf.m = md_to_m(&rcg->mn[bank], md);\r\nf.n = ns_m_to_n(&rcg->mn[bank], ns, f.m);\r\n}\r\nif (banked_p)\r\nf.pre_div = ns_to_pre_div(&rcg->p[bank], ns) + 1;\r\nf.src = qcom_find_src_index(hw, rcg->s[bank].parent_map, index);\r\nreturn configure_bank(rcg, &f);\r\n}\r\nstatic unsigned long\r\ncalc_rate(unsigned long rate, u32 m, u32 n, u32 mode, u32 pre_div)\r\n{\r\nif (pre_div)\r\nrate /= pre_div + 1;\r\nif (mode) {\r\nu64 tmp = rate;\r\ntmp *= m;\r\ndo_div(tmp, n);\r\nrate = tmp;\r\n}\r\nreturn rate;\r\n}\r\nstatic unsigned long\r\nclk_rcg_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\r\n{\r\nstruct clk_rcg *rcg = to_clk_rcg(hw);\r\nu32 pre_div, m = 0, n = 0, ns, md, mode = 0;\r\nstruct mn *mn = &rcg->mn;\r\nregmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\r\npre_div = ns_to_pre_div(&rcg->p, ns);\r\nif (rcg->mn.width) {\r\nregmap_read(rcg->clkr.regmap, rcg->md_reg, &md);\r\nm = md_to_m(mn, md);\r\nn = ns_m_to_n(mn, ns, m);\r\nif (rcg->clkr.enable_reg != rcg->ns_reg)\r\nregmap_read(rcg->clkr.regmap, rcg->clkr.enable_reg, &mode);\r\nelse\r\nmode = ns;\r\nmode = reg_to_mnctr_mode(mn, mode);\r\n}\r\nreturn calc_rate(parent_rate, m, n, mode, pre_div);\r\n}\r\nstatic unsigned long\r\nclk_dyn_rcg_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\r\n{\r\nstruct clk_dyn_rcg *rcg = to_clk_dyn_rcg(hw);\r\nu32 m, n, pre_div, ns, md, mode, reg;\r\nint bank;\r\nstruct mn *mn;\r\nbool banked_p = !!rcg->p[1].pre_div_width;\r\nbool banked_mn = !!rcg->mn[1].width;\r\nregmap_read(rcg->clkr.regmap, rcg->bank_reg, &reg);\r\nbank = reg_to_bank(rcg, reg);\r\nregmap_read(rcg->clkr.regmap, rcg->ns_reg[bank], &ns);\r\nm = n = pre_div = mode = 0;\r\nif (banked_mn) {\r\nmn = &rcg->mn[bank];\r\nregmap_read(rcg->clkr.regmap, rcg->md_reg[bank], &md);\r\nm = md_to_m(mn, md);\r\nn = ns_m_to_n(mn, ns, m);\r\nif (rcg->ns_reg[0] != rcg->ns_reg[1])\r\nreg = ns;\r\nmode = reg_to_mnctr_mode(mn, reg);\r\n}\r\nif (banked_p)\r\npre_div = ns_to_pre_div(&rcg->p[bank], ns);\r\nreturn calc_rate(parent_rate, m, n, mode, pre_div);\r\n}\r\nstatic long _freq_tbl_determine_rate(struct clk_hw *hw,\r\nconst struct freq_tbl *f, unsigned long rate,\r\nunsigned long min_rate, unsigned long max_rate,\r\nunsigned long *p_rate, struct clk_hw **p_hw,\r\nconst struct parent_map *parent_map)\r\n{\r\nunsigned long clk_flags;\r\nstruct clk *p;\r\nint index;\r\nf = qcom_find_freq(f, rate);\r\nif (!f)\r\nreturn -EINVAL;\r\nindex = qcom_find_src_index(hw, parent_map, f->src);\r\nif (index < 0)\r\nreturn index;\r\nclk_flags = __clk_get_flags(hw->clk);\r\np = clk_get_parent_by_index(hw->clk, index);\r\nif (clk_flags & CLK_SET_RATE_PARENT) {\r\nrate = rate * f->pre_div;\r\nif (f->n) {\r\nu64 tmp = rate;\r\ntmp = tmp * f->n;\r\ndo_div(tmp, f->m);\r\nrate = tmp;\r\n}\r\n} else {\r\nrate = __clk_get_rate(p);\r\n}\r\n*p_hw = __clk_get_hw(p);\r\n*p_rate = rate;\r\nreturn f->freq;\r\n}\r\nstatic long clk_rcg_determine_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long min_rate, unsigned long max_rate,\r\nunsigned long *p_rate, struct clk_hw **p)\r\n{\r\nstruct clk_rcg *rcg = to_clk_rcg(hw);\r\nreturn _freq_tbl_determine_rate(hw, rcg->freq_tbl, rate, min_rate,\r\nmax_rate, p_rate, p, rcg->s.parent_map);\r\n}\r\nstatic long clk_dyn_rcg_determine_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long min_rate, unsigned long max_rate,\r\nunsigned long *p_rate, struct clk_hw **p)\r\n{\r\nstruct clk_dyn_rcg *rcg = to_clk_dyn_rcg(hw);\r\nu32 reg;\r\nint bank;\r\nstruct src_sel *s;\r\nregmap_read(rcg->clkr.regmap, rcg->bank_reg, &reg);\r\nbank = reg_to_bank(rcg, reg);\r\ns = &rcg->s[bank];\r\nreturn _freq_tbl_determine_rate(hw, rcg->freq_tbl, rate, min_rate,\r\nmax_rate, p_rate, p, s->parent_map);\r\n}\r\nstatic long clk_rcg_bypass_determine_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long min_rate, unsigned long max_rate,\r\nunsigned long *p_rate, struct clk_hw **p_hw)\r\n{\r\nstruct clk_rcg *rcg = to_clk_rcg(hw);\r\nconst struct freq_tbl *f = rcg->freq_tbl;\r\nstruct clk *p;\r\nint index = qcom_find_src_index(hw, rcg->s.parent_map, f->src);\r\np = clk_get_parent_by_index(hw->clk, index);\r\n*p_hw = __clk_get_hw(p);\r\n*p_rate = __clk_round_rate(p, rate);\r\nreturn *p_rate;\r\n}\r\nstatic int __clk_rcg_set_rate(struct clk_rcg *rcg, const struct freq_tbl *f)\r\n{\r\nu32 ns, md, ctl;\r\nstruct mn *mn = &rcg->mn;\r\nu32 mask = 0;\r\nunsigned int reset_reg;\r\nif (rcg->mn.reset_in_cc)\r\nreset_reg = rcg->clkr.enable_reg;\r\nelse\r\nreset_reg = rcg->ns_reg;\r\nif (rcg->mn.width) {\r\nmask = BIT(mn->mnctr_reset_bit);\r\nregmap_update_bits(rcg->clkr.regmap, reset_reg, mask, mask);\r\nregmap_read(rcg->clkr.regmap, rcg->md_reg, &md);\r\nmd = mn_to_md(mn, f->m, f->n, md);\r\nregmap_write(rcg->clkr.regmap, rcg->md_reg, md);\r\nregmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\r\nif (rcg->clkr.enable_reg != rcg->ns_reg) {\r\nregmap_read(rcg->clkr.regmap, rcg->clkr.enable_reg, &ctl);\r\nctl = mn_to_reg(mn, f->m, f->n, ctl);\r\nregmap_write(rcg->clkr.regmap, rcg->clkr.enable_reg, ctl);\r\n} else {\r\nns = mn_to_reg(mn, f->m, f->n, ns);\r\n}\r\nns = mn_to_ns(mn, f->m, f->n, ns);\r\n} else {\r\nregmap_read(rcg->clkr.regmap, rcg->ns_reg, &ns);\r\n}\r\nns = pre_div_to_ns(&rcg->p, f->pre_div - 1, ns);\r\nregmap_write(rcg->clkr.regmap, rcg->ns_reg, ns);\r\nregmap_update_bits(rcg->clkr.regmap, reset_reg, mask, 0);\r\nreturn 0;\r\n}\r\nstatic int clk_rcg_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_rcg *rcg = to_clk_rcg(hw);\r\nconst struct freq_tbl *f;\r\nf = qcom_find_freq(rcg->freq_tbl, rate);\r\nif (!f)\r\nreturn -EINVAL;\r\nreturn __clk_rcg_set_rate(rcg, f);\r\n}\r\nstatic int clk_rcg_bypass_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_rcg *rcg = to_clk_rcg(hw);\r\nreturn __clk_rcg_set_rate(rcg, rcg->freq_tbl);\r\n}\r\nstatic int clk_rcg_lcc_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_rcg *rcg = to_clk_rcg(hw);\r\nconst struct freq_tbl *f;\r\nint ret;\r\nu32 gfm = BIT(10);\r\nf = qcom_find_freq(rcg->freq_tbl, rate);\r\nif (!f)\r\nreturn -EINVAL;\r\nregmap_update_bits(rcg->clkr.regmap, rcg->ns_reg, gfm, 0);\r\nret = __clk_rcg_set_rate(rcg, f);\r\nif (__clk_is_enabled(hw->clk))\r\nregmap_update_bits(rcg->clkr.regmap, rcg->ns_reg, gfm, gfm);\r\nreturn ret;\r\n}\r\nstatic int clk_rcg_lcc_enable(struct clk_hw *hw)\r\n{\r\nstruct clk_rcg *rcg = to_clk_rcg(hw);\r\nu32 gfm = BIT(10);\r\nreturn regmap_update_bits(rcg->clkr.regmap, rcg->ns_reg, gfm, gfm);\r\n}\r\nstatic void clk_rcg_lcc_disable(struct clk_hw *hw)\r\n{\r\nstruct clk_rcg *rcg = to_clk_rcg(hw);\r\nu32 gfm = BIT(10);\r\nregmap_update_bits(rcg->clkr.regmap, rcg->ns_reg, gfm, 0);\r\n}\r\nstatic int __clk_dyn_rcg_set_rate(struct clk_hw *hw, unsigned long rate)\r\n{\r\nstruct clk_dyn_rcg *rcg = to_clk_dyn_rcg(hw);\r\nconst struct freq_tbl *f;\r\nf = qcom_find_freq(rcg->freq_tbl, rate);\r\nif (!f)\r\nreturn -EINVAL;\r\nreturn configure_bank(rcg, f);\r\n}\r\nstatic int clk_dyn_rcg_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nreturn __clk_dyn_rcg_set_rate(hw, rate);\r\n}\r\nstatic int clk_dyn_rcg_set_rate_and_parent(struct clk_hw *hw,\r\nunsigned long rate, unsigned long parent_rate, u8 index)\r\n{\r\nreturn __clk_dyn_rcg_set_rate(hw, rate);\r\n}
