int\r\nnvkm_object_create_(struct nvkm_object *parent, struct nvkm_object *engine,\r\nstruct nvkm_oclass *oclass, u32 pclass,\r\nint size, void **pobject)\r\n{\r\nstruct nvkm_object *object;\r\nobject = *pobject = kzalloc(size, GFP_KERNEL);\r\nif (!object)\r\nreturn -ENOMEM;\r\nnvkm_object_ref(parent, &object->parent);\r\nnvkm_object_ref(engine, (struct nvkm_object **)&object->engine);\r\nobject->oclass = oclass;\r\nobject->oclass->handle |= pclass;\r\natomic_set(&object->refcount, 1);\r\natomic_set(&object->usecount, 0);\r\n#ifdef NVKM_OBJECT_MAGIC\r\nobject->_magic = NVKM_OBJECT_MAGIC;\r\nspin_lock(&_objlist_lock);\r\nlist_add(&object->list, &_objlist);\r\nspin_unlock(&_objlist_lock);\r\n#endif\r\nreturn 0;\r\n}\r\nint\r\n_nvkm_object_ctor(struct nvkm_object *parent, struct nvkm_object *engine,\r\nstruct nvkm_oclass *oclass, void *data, u32 size,\r\nstruct nvkm_object **pobject)\r\n{\r\nif (size != 0)\r\nreturn -ENOSYS;\r\nreturn nvkm_object_create(parent, engine, oclass, 0, pobject);\r\n}\r\nvoid\r\nnvkm_object_destroy(struct nvkm_object *object)\r\n{\r\n#ifdef NVKM_OBJECT_MAGIC\r\nspin_lock(&_objlist_lock);\r\nlist_del(&object->list);\r\nspin_unlock(&_objlist_lock);\r\n#endif\r\nnvkm_object_ref(NULL, (struct nvkm_object **)&object->engine);\r\nnvkm_object_ref(NULL, &object->parent);\r\nkfree(object);\r\n}\r\nint\r\nnvkm_object_init(struct nvkm_object *object)\r\n{\r\nreturn 0;\r\n}\r\nint\r\nnvkm_object_fini(struct nvkm_object *object, bool suspend)\r\n{\r\nreturn 0;\r\n}\r\nint\r\nnvkm_object_ctor(struct nvkm_object *parent, struct nvkm_object *engine,\r\nstruct nvkm_oclass *oclass, void *data, u32 size,\r\nstruct nvkm_object **pobject)\r\n{\r\nstruct nvkm_ofuncs *ofuncs = oclass->ofuncs;\r\nstruct nvkm_object *object = NULL;\r\nint ret;\r\nret = ofuncs->ctor(parent, engine, oclass, data, size, &object);\r\n*pobject = object;\r\nif (ret < 0) {\r\nif (ret != -ENODEV) {\r\nnv_error(parent, "failed to create 0x%08x, %d\n",\r\noclass->handle, ret);\r\n}\r\nif (object) {\r\nofuncs->dtor(object);\r\n*pobject = NULL;\r\n}\r\nreturn ret;\r\n}\r\nif (ret == 0) {\r\nnv_trace(object, "created\n");\r\natomic_set(&object->refcount, 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nnvkm_object_dtor(struct nvkm_object *object)\r\n{\r\nnv_trace(object, "destroying\n");\r\nnv_ofuncs(object)->dtor(object);\r\n}\r\nvoid\r\nnvkm_object_ref(struct nvkm_object *obj, struct nvkm_object **ref)\r\n{\r\nif (obj) {\r\natomic_inc(&obj->refcount);\r\nnv_trace(obj, "inc() == %d\n", atomic_read(&obj->refcount));\r\n}\r\nif (*ref) {\r\nint dead = atomic_dec_and_test(&(*ref)->refcount);\r\nnv_trace(*ref, "dec() == %d\n", atomic_read(&(*ref)->refcount));\r\nif (dead)\r\nnvkm_object_dtor(*ref);\r\n}\r\n*ref = obj;\r\n}\r\nint\r\nnvkm_object_inc(struct nvkm_object *object)\r\n{\r\nint ref = atomic_add_return(1, &object->usecount);\r\nint ret;\r\nnv_trace(object, "use(+1) == %d\n", atomic_read(&object->usecount));\r\nif (ref != 1)\r\nreturn 0;\r\nnv_trace(object, "initialising...\n");\r\nif (object->parent) {\r\nret = nvkm_object_inc(object->parent);\r\nif (ret) {\r\nnv_error(object, "parent failed, %d\n", ret);\r\ngoto fail_parent;\r\n}\r\n}\r\nif (object->engine) {\r\nmutex_lock(&nv_subdev(object->engine)->mutex);\r\nret = nvkm_object_inc(&object->engine->subdev.object);\r\nmutex_unlock(&nv_subdev(object->engine)->mutex);\r\nif (ret) {\r\nnv_error(object, "engine failed, %d\n", ret);\r\ngoto fail_engine;\r\n}\r\n}\r\nret = nv_ofuncs(object)->init(object);\r\natomic_set(&object->usecount, 1);\r\nif (ret) {\r\nnv_error(object, "init failed, %d\n", ret);\r\ngoto fail_self;\r\n}\r\nnv_trace(object, "initialised\n");\r\nreturn 0;\r\nfail_self:\r\nif (object->engine) {\r\nmutex_lock(&nv_subdev(object->engine)->mutex);\r\nnvkm_object_dec(&object->engine->subdev.object, false);\r\nmutex_unlock(&nv_subdev(object->engine)->mutex);\r\n}\r\nfail_engine:\r\nif (object->parent)\r\nnvkm_object_dec(object->parent, false);\r\nfail_parent:\r\natomic_dec(&object->usecount);\r\nreturn ret;\r\n}\r\nstatic int\r\nnvkm_object_decf(struct nvkm_object *object)\r\n{\r\nint ret;\r\nnv_trace(object, "stopping...\n");\r\nret = nv_ofuncs(object)->fini(object, false);\r\natomic_set(&object->usecount, 0);\r\nif (ret)\r\nnv_warn(object, "failed fini, %d\n", ret);\r\nif (object->engine) {\r\nmutex_lock(&nv_subdev(object->engine)->mutex);\r\nnvkm_object_dec(&object->engine->subdev.object, false);\r\nmutex_unlock(&nv_subdev(object->engine)->mutex);\r\n}\r\nif (object->parent)\r\nnvkm_object_dec(object->parent, false);\r\nnv_trace(object, "stopped\n");\r\nreturn 0;\r\n}\r\nstatic int\r\nnvkm_object_decs(struct nvkm_object *object)\r\n{\r\nint ret, rret;\r\nnv_trace(object, "suspending...\n");\r\nret = nv_ofuncs(object)->fini(object, true);\r\natomic_set(&object->usecount, 0);\r\nif (ret) {\r\nnv_error(object, "failed suspend, %d\n", ret);\r\nreturn ret;\r\n}\r\nif (object->engine) {\r\nmutex_lock(&nv_subdev(object->engine)->mutex);\r\nret = nvkm_object_dec(&object->engine->subdev.object, true);\r\nmutex_unlock(&nv_subdev(object->engine)->mutex);\r\nif (ret) {\r\nnv_warn(object, "engine failed suspend, %d\n", ret);\r\ngoto fail_engine;\r\n}\r\n}\r\nif (object->parent) {\r\nret = nvkm_object_dec(object->parent, true);\r\nif (ret) {\r\nnv_warn(object, "parent failed suspend, %d\n", ret);\r\ngoto fail_parent;\r\n}\r\n}\r\nnv_trace(object, "suspended\n");\r\nreturn 0;\r\nfail_parent:\r\nif (object->engine) {\r\nmutex_lock(&nv_subdev(object->engine)->mutex);\r\nrret = nvkm_object_inc(&object->engine->subdev.object);\r\nmutex_unlock(&nv_subdev(object->engine)->mutex);\r\nif (rret)\r\nnv_fatal(object, "engine failed to reinit, %d\n", rret);\r\n}\r\nfail_engine:\r\nrret = nv_ofuncs(object)->init(object);\r\nif (rret)\r\nnv_fatal(object, "failed to reinit, %d\n", rret);\r\nreturn ret;\r\n}\r\nint\r\nnvkm_object_dec(struct nvkm_object *object, bool suspend)\r\n{\r\nint ref = atomic_add_return(-1, &object->usecount);\r\nint ret;\r\nnv_trace(object, "use(-1) == %d\n", atomic_read(&object->usecount));\r\nif (ref == 0) {\r\nif (suspend)\r\nret = nvkm_object_decs(object);\r\nelse\r\nret = nvkm_object_decf(object);\r\nif (ret) {\r\natomic_inc(&object->usecount);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nnvkm_object_debug(void)\r\n{\r\n#ifdef NVKM_OBJECT_MAGIC\r\nstruct nvkm_object *object;\r\nif (!list_empty(&_objlist)) {\r\nnv_fatal(NULL, "*******************************************\n");\r\nnv_fatal(NULL, "* AIIIII! object(s) still exist!!!\n");\r\nnv_fatal(NULL, "*******************************************\n");\r\nlist_for_each_entry(object, &_objlist, list) {\r\nnv_fatal(object, "%p/%p/%d/%d\n",\r\nobject->parent, object->engine,\r\natomic_read(&object->refcount),\r\natomic_read(&object->usecount));\r\n}\r\n}\r\n#endif\r\n}
