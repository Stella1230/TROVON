static inline u8 rtc_read(struct omap_rtc *rtc, unsigned int reg)\r\n{\r\nreturn readb(rtc->base + reg);\r\n}\r\nstatic inline u32 rtc_readl(struct omap_rtc *rtc, unsigned int reg)\r\n{\r\nreturn readl(rtc->base + reg);\r\n}\r\nstatic inline void rtc_write(struct omap_rtc *rtc, unsigned int reg, u8 val)\r\n{\r\nwriteb(val, rtc->base + reg);\r\n}\r\nstatic inline void rtc_writel(struct omap_rtc *rtc, unsigned int reg, u32 val)\r\n{\r\nwritel(val, rtc->base + reg);\r\n}\r\nstatic void am3352_rtc_unlock(struct omap_rtc *rtc)\r\n{\r\nrtc_writel(rtc, OMAP_RTC_KICK0_REG, KICK0_VALUE);\r\nrtc_writel(rtc, OMAP_RTC_KICK1_REG, KICK1_VALUE);\r\n}\r\nstatic void am3352_rtc_lock(struct omap_rtc *rtc)\r\n{\r\nrtc_writel(rtc, OMAP_RTC_KICK0_REG, 0);\r\nrtc_writel(rtc, OMAP_RTC_KICK1_REG, 0);\r\n}\r\nstatic void default_rtc_unlock(struct omap_rtc *rtc)\r\n{\r\n}\r\nstatic void default_rtc_lock(struct omap_rtc *rtc)\r\n{\r\n}\r\nstatic void rtc_wait_not_busy(struct omap_rtc *rtc)\r\n{\r\nint count;\r\nu8 status;\r\nfor (count = 0; count < 50; count++) {\r\nstatus = rtc_read(rtc, OMAP_RTC_STATUS_REG);\r\nif (!(status & OMAP_RTC_STATUS_BUSY))\r\nbreak;\r\nudelay(1);\r\n}\r\n}\r\nstatic irqreturn_t rtc_irq(int irq, void *dev_id)\r\n{\r\nstruct omap_rtc *rtc = dev_id;\r\nunsigned long events = 0;\r\nu8 irq_data;\r\nirq_data = rtc_read(rtc, OMAP_RTC_STATUS_REG);\r\nif (irq_data & OMAP_RTC_STATUS_ALARM) {\r\nrtc->type->unlock(rtc);\r\nrtc_write(rtc, OMAP_RTC_STATUS_REG, OMAP_RTC_STATUS_ALARM);\r\nrtc->type->lock(rtc);\r\nevents |= RTC_IRQF | RTC_AF;\r\n}\r\nif (irq_data & OMAP_RTC_STATUS_1S_EVENT)\r\nevents |= RTC_IRQF | RTC_UF;\r\nrtc_update_irq(rtc->rtc, 1, events);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int omap_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct omap_rtc *rtc = dev_get_drvdata(dev);\r\nu8 reg, irqwake_reg = 0;\r\nlocal_irq_disable();\r\nrtc_wait_not_busy(rtc);\r\nreg = rtc_read(rtc, OMAP_RTC_INTERRUPTS_REG);\r\nif (rtc->type->has_irqwakeen)\r\nirqwake_reg = rtc_read(rtc, OMAP_RTC_IRQWAKEEN);\r\nif (enabled) {\r\nreg |= OMAP_RTC_INTERRUPTS_IT_ALARM;\r\nirqwake_reg |= OMAP_RTC_IRQWAKEEN_ALARM_WAKEEN;\r\n} else {\r\nreg &= ~OMAP_RTC_INTERRUPTS_IT_ALARM;\r\nirqwake_reg &= ~OMAP_RTC_IRQWAKEEN_ALARM_WAKEEN;\r\n}\r\nrtc_wait_not_busy(rtc);\r\nrtc->type->unlock(rtc);\r\nrtc_write(rtc, OMAP_RTC_INTERRUPTS_REG, reg);\r\nif (rtc->type->has_irqwakeen)\r\nrtc_write(rtc, OMAP_RTC_IRQWAKEEN, irqwake_reg);\r\nrtc->type->lock(rtc);\r\nlocal_irq_enable();\r\nreturn 0;\r\n}\r\nstatic int tm2bcd(struct rtc_time *tm)\r\n{\r\nif (rtc_valid_tm(tm) != 0)\r\nreturn -EINVAL;\r\ntm->tm_sec = bin2bcd(tm->tm_sec);\r\ntm->tm_min = bin2bcd(tm->tm_min);\r\ntm->tm_hour = bin2bcd(tm->tm_hour);\r\ntm->tm_mday = bin2bcd(tm->tm_mday);\r\ntm->tm_mon = bin2bcd(tm->tm_mon + 1);\r\nif (tm->tm_year < 100 || tm->tm_year > 199)\r\nreturn -EINVAL;\r\ntm->tm_year = bin2bcd(tm->tm_year - 100);\r\nreturn 0;\r\n}\r\nstatic void bcd2tm(struct rtc_time *tm)\r\n{\r\ntm->tm_sec = bcd2bin(tm->tm_sec);\r\ntm->tm_min = bcd2bin(tm->tm_min);\r\ntm->tm_hour = bcd2bin(tm->tm_hour);\r\ntm->tm_mday = bcd2bin(tm->tm_mday);\r\ntm->tm_mon = bcd2bin(tm->tm_mon) - 1;\r\ntm->tm_year = bcd2bin(tm->tm_year) + 100;\r\n}\r\nstatic void omap_rtc_read_time_raw(struct omap_rtc *rtc, struct rtc_time *tm)\r\n{\r\ntm->tm_sec = rtc_read(rtc, OMAP_RTC_SECONDS_REG);\r\ntm->tm_min = rtc_read(rtc, OMAP_RTC_MINUTES_REG);\r\ntm->tm_hour = rtc_read(rtc, OMAP_RTC_HOURS_REG);\r\ntm->tm_mday = rtc_read(rtc, OMAP_RTC_DAYS_REG);\r\ntm->tm_mon = rtc_read(rtc, OMAP_RTC_MONTHS_REG);\r\ntm->tm_year = rtc_read(rtc, OMAP_RTC_YEARS_REG);\r\n}\r\nstatic int omap_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct omap_rtc *rtc = dev_get_drvdata(dev);\r\nlocal_irq_disable();\r\nrtc_wait_not_busy(rtc);\r\nomap_rtc_read_time_raw(rtc, tm);\r\nlocal_irq_enable();\r\nbcd2tm(tm);\r\nreturn 0;\r\n}\r\nstatic int omap_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct omap_rtc *rtc = dev_get_drvdata(dev);\r\nif (tm2bcd(tm) < 0)\r\nreturn -EINVAL;\r\nlocal_irq_disable();\r\nrtc_wait_not_busy(rtc);\r\nrtc->type->unlock(rtc);\r\nrtc_write(rtc, OMAP_RTC_YEARS_REG, tm->tm_year);\r\nrtc_write(rtc, OMAP_RTC_MONTHS_REG, tm->tm_mon);\r\nrtc_write(rtc, OMAP_RTC_DAYS_REG, tm->tm_mday);\r\nrtc_write(rtc, OMAP_RTC_HOURS_REG, tm->tm_hour);\r\nrtc_write(rtc, OMAP_RTC_MINUTES_REG, tm->tm_min);\r\nrtc_write(rtc, OMAP_RTC_SECONDS_REG, tm->tm_sec);\r\nrtc->type->lock(rtc);\r\nlocal_irq_enable();\r\nreturn 0;\r\n}\r\nstatic int omap_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alm)\r\n{\r\nstruct omap_rtc *rtc = dev_get_drvdata(dev);\r\nu8 interrupts;\r\nlocal_irq_disable();\r\nrtc_wait_not_busy(rtc);\r\nalm->time.tm_sec = rtc_read(rtc, OMAP_RTC_ALARM_SECONDS_REG);\r\nalm->time.tm_min = rtc_read(rtc, OMAP_RTC_ALARM_MINUTES_REG);\r\nalm->time.tm_hour = rtc_read(rtc, OMAP_RTC_ALARM_HOURS_REG);\r\nalm->time.tm_mday = rtc_read(rtc, OMAP_RTC_ALARM_DAYS_REG);\r\nalm->time.tm_mon = rtc_read(rtc, OMAP_RTC_ALARM_MONTHS_REG);\r\nalm->time.tm_year = rtc_read(rtc, OMAP_RTC_ALARM_YEARS_REG);\r\nlocal_irq_enable();\r\nbcd2tm(&alm->time);\r\ninterrupts = rtc_read(rtc, OMAP_RTC_INTERRUPTS_REG);\r\nalm->enabled = !!(interrupts & OMAP_RTC_INTERRUPTS_IT_ALARM);\r\nreturn 0;\r\n}\r\nstatic int omap_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)\r\n{\r\nstruct omap_rtc *rtc = dev_get_drvdata(dev);\r\nu8 reg, irqwake_reg = 0;\r\nif (tm2bcd(&alm->time) < 0)\r\nreturn -EINVAL;\r\nlocal_irq_disable();\r\nrtc_wait_not_busy(rtc);\r\nrtc->type->unlock(rtc);\r\nrtc_write(rtc, OMAP_RTC_ALARM_YEARS_REG, alm->time.tm_year);\r\nrtc_write(rtc, OMAP_RTC_ALARM_MONTHS_REG, alm->time.tm_mon);\r\nrtc_write(rtc, OMAP_RTC_ALARM_DAYS_REG, alm->time.tm_mday);\r\nrtc_write(rtc, OMAP_RTC_ALARM_HOURS_REG, alm->time.tm_hour);\r\nrtc_write(rtc, OMAP_RTC_ALARM_MINUTES_REG, alm->time.tm_min);\r\nrtc_write(rtc, OMAP_RTC_ALARM_SECONDS_REG, alm->time.tm_sec);\r\nreg = rtc_read(rtc, OMAP_RTC_INTERRUPTS_REG);\r\nif (rtc->type->has_irqwakeen)\r\nirqwake_reg = rtc_read(rtc, OMAP_RTC_IRQWAKEEN);\r\nif (alm->enabled) {\r\nreg |= OMAP_RTC_INTERRUPTS_IT_ALARM;\r\nirqwake_reg |= OMAP_RTC_IRQWAKEEN_ALARM_WAKEEN;\r\n} else {\r\nreg &= ~OMAP_RTC_INTERRUPTS_IT_ALARM;\r\nirqwake_reg &= ~OMAP_RTC_IRQWAKEEN_ALARM_WAKEEN;\r\n}\r\nrtc_write(rtc, OMAP_RTC_INTERRUPTS_REG, reg);\r\nif (rtc->type->has_irqwakeen)\r\nrtc_write(rtc, OMAP_RTC_IRQWAKEEN, irqwake_reg);\r\nrtc->type->lock(rtc);\r\nlocal_irq_enable();\r\nreturn 0;\r\n}\r\nstatic void omap_rtc_power_off(void)\r\n{\r\nstruct omap_rtc *rtc = omap_rtc_power_off_rtc;\r\nstruct rtc_time tm;\r\nunsigned long now;\r\nu32 val;\r\nrtc->type->unlock(rtc);\r\nval = rtc_readl(rtc, OMAP_RTC_PMIC_REG);\r\nrtc_writel(rtc, OMAP_RTC_PMIC_REG, val | OMAP_RTC_PMIC_POWER_EN_EN);\r\nomap_rtc_read_time_raw(rtc, &tm);\r\nbcd2tm(&tm);\r\nrtc_tm_to_time(&tm, &now);\r\nrtc_time_to_tm(now + 2, &tm);\r\nif (tm2bcd(&tm) < 0) {\r\ndev_err(&rtc->rtc->dev, "power off failed\n");\r\nreturn;\r\n}\r\nrtc_wait_not_busy(rtc);\r\nrtc_write(rtc, OMAP_RTC_ALARM2_SECONDS_REG, tm.tm_sec);\r\nrtc_write(rtc, OMAP_RTC_ALARM2_MINUTES_REG, tm.tm_min);\r\nrtc_write(rtc, OMAP_RTC_ALARM2_HOURS_REG, tm.tm_hour);\r\nrtc_write(rtc, OMAP_RTC_ALARM2_DAYS_REG, tm.tm_mday);\r\nrtc_write(rtc, OMAP_RTC_ALARM2_MONTHS_REG, tm.tm_mon);\r\nrtc_write(rtc, OMAP_RTC_ALARM2_YEARS_REG, tm.tm_year);\r\nval = rtc_read(rtc, OMAP_RTC_INTERRUPTS_REG);\r\nrtc_writel(rtc, OMAP_RTC_INTERRUPTS_REG,\r\nval | OMAP_RTC_INTERRUPTS_IT_ALARM2);\r\nrtc->type->lock(rtc);\r\nmdelay(2500);\r\n}\r\nstatic int omap_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct omap_rtc *rtc;\r\nstruct resource *res;\r\nu8 reg, mask, new_ctrl;\r\nconst struct platform_device_id *id_entry;\r\nconst struct of_device_id *of_id;\r\nint ret;\r\nrtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);\r\nif (!rtc)\r\nreturn -ENOMEM;\r\nof_id = of_match_device(omap_rtc_of_match, &pdev->dev);\r\nif (of_id) {\r\nrtc->type = of_id->data;\r\nrtc->is_pmic_controller = rtc->type->has_pmic_mode &&\r\nof_property_read_bool(pdev->dev.of_node,\r\n"system-power-controller");\r\n} else {\r\nid_entry = platform_get_device_id(pdev);\r\nrtc->type = (void *)id_entry->driver_data;\r\n}\r\nrtc->irq_timer = platform_get_irq(pdev, 0);\r\nif (rtc->irq_timer <= 0)\r\nreturn -ENOENT;\r\nrtc->irq_alarm = platform_get_irq(pdev, 1);\r\nif (rtc->irq_alarm <= 0)\r\nreturn -ENOENT;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrtc->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(rtc->base))\r\nreturn PTR_ERR(rtc->base);\r\nplatform_set_drvdata(pdev, rtc);\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_get_sync(&pdev->dev);\r\nrtc->type->unlock(rtc);\r\nrtc_writel(rtc, OMAP_RTC_INTERRUPTS_REG, 0);\r\nif (rtc->type->has_32kclk_en) {\r\nreg = rtc_read(rtc, OMAP_RTC_OSC_REG);\r\nrtc_writel(rtc, OMAP_RTC_OSC_REG,\r\nreg | OMAP_RTC_OSC_32KCLK_EN);\r\n}\r\nreg = rtc_read(rtc, OMAP_RTC_STATUS_REG);\r\nmask = OMAP_RTC_STATUS_ALARM;\r\nif (rtc->type->has_pmic_mode)\r\nmask |= OMAP_RTC_STATUS_ALARM2;\r\nif (rtc->type->has_power_up_reset) {\r\nmask |= OMAP_RTC_STATUS_POWER_UP;\r\nif (reg & OMAP_RTC_STATUS_POWER_UP)\r\ndev_info(&pdev->dev, "RTC power up reset detected\n");\r\n}\r\nif (reg & mask)\r\nrtc_write(rtc, OMAP_RTC_STATUS_REG, reg & mask);\r\nreg = rtc_read(rtc, OMAP_RTC_CTRL_REG);\r\nif (reg & OMAP_RTC_CTRL_STOP)\r\ndev_info(&pdev->dev, "already running\n");\r\nnew_ctrl = reg & (OMAP_RTC_CTRL_SPLIT | OMAP_RTC_CTRL_AUTO_COMP);\r\nnew_ctrl |= OMAP_RTC_CTRL_STOP;\r\nif (new_ctrl & OMAP_RTC_CTRL_SPLIT)\r\ndev_info(&pdev->dev, "split power mode\n");\r\nif (reg != new_ctrl)\r\nrtc_write(rtc, OMAP_RTC_CTRL_REG, new_ctrl);\r\nrtc->type->lock(rtc);\r\ndevice_init_wakeup(&pdev->dev, true);\r\nrtc->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,\r\n&omap_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rtc->rtc)) {\r\nret = PTR_ERR(rtc->rtc);\r\ngoto err;\r\n}\r\nret = devm_request_irq(&pdev->dev, rtc->irq_timer, rtc_irq, 0,\r\ndev_name(&rtc->rtc->dev), rtc);\r\nif (ret)\r\ngoto err;\r\nif (rtc->irq_timer != rtc->irq_alarm) {\r\nret = devm_request_irq(&pdev->dev, rtc->irq_alarm, rtc_irq, 0,\r\ndev_name(&rtc->rtc->dev), rtc);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (rtc->is_pmic_controller) {\r\nif (!pm_power_off) {\r\nomap_rtc_power_off_rtc = rtc;\r\npm_power_off = omap_rtc_power_off;\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\ndevice_init_wakeup(&pdev->dev, false);\r\nrtc->type->lock(rtc);\r\npm_runtime_put_sync(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn ret;\r\n}\r\nstatic int __exit omap_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct omap_rtc *rtc = platform_get_drvdata(pdev);\r\nif (pm_power_off == omap_rtc_power_off &&\r\nomap_rtc_power_off_rtc == rtc) {\r\npm_power_off = NULL;\r\nomap_rtc_power_off_rtc = NULL;\r\n}\r\ndevice_init_wakeup(&pdev->dev, 0);\r\nrtc->type->unlock(rtc);\r\nrtc_write(rtc, OMAP_RTC_INTERRUPTS_REG, 0);\r\nrtc->type->lock(rtc);\r\npm_runtime_put_sync(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int omap_rtc_suspend(struct device *dev)\r\n{\r\nstruct omap_rtc *rtc = dev_get_drvdata(dev);\r\nrtc->interrupts_reg = rtc_read(rtc, OMAP_RTC_INTERRUPTS_REG);\r\nrtc->type->unlock(rtc);\r\nif (device_may_wakeup(dev))\r\nenable_irq_wake(rtc->irq_alarm);\r\nelse\r\nrtc_write(rtc, OMAP_RTC_INTERRUPTS_REG, 0);\r\nrtc->type->lock(rtc);\r\npm_runtime_put_sync(dev);\r\nreturn 0;\r\n}\r\nstatic int omap_rtc_resume(struct device *dev)\r\n{\r\nstruct omap_rtc *rtc = dev_get_drvdata(dev);\r\npm_runtime_get_sync(dev);\r\nrtc->type->unlock(rtc);\r\nif (device_may_wakeup(dev))\r\ndisable_irq_wake(rtc->irq_alarm);\r\nelse\r\nrtc_write(rtc, OMAP_RTC_INTERRUPTS_REG, rtc->interrupts_reg);\r\nrtc->type->lock(rtc);\r\nreturn 0;\r\n}\r\nstatic void omap_rtc_shutdown(struct platform_device *pdev)\r\n{\r\nstruct omap_rtc *rtc = platform_get_drvdata(pdev);\r\nu8 mask;\r\nrtc->type->unlock(rtc);\r\nmask = rtc_read(rtc, OMAP_RTC_INTERRUPTS_REG);\r\nmask &= OMAP_RTC_INTERRUPTS_IT_ALARM;\r\nrtc_write(rtc, OMAP_RTC_INTERRUPTS_REG, mask);\r\nrtc->type->lock(rtc);\r\n}
