static void isp1301_configure_lpc32xx(void)\r\n{\r\ni2c_smbus_write_byte_data(isp1301_i2c_client,\r\n(ISP1301_I2C_MODE_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR),\r\nMC1_UART_EN);\r\ni2c_smbus_write_byte_data(isp1301_i2c_client,\r\n(ISP1301_I2C_MODE_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR),\r\n~MC1_SPEED_REG);\r\ni2c_smbus_write_byte_data(isp1301_i2c_client,\r\nISP1301_I2C_MODE_CONTROL_1, MC1_SPEED_REG);\r\ni2c_smbus_write_byte_data(isp1301_i2c_client,\r\n(ISP1301_I2C_MODE_CONTROL_2 | ISP1301_I2C_REG_CLEAR_ADDR),\r\n~0);\r\ni2c_smbus_write_byte_data(isp1301_i2c_client,\r\nISP1301_I2C_MODE_CONTROL_2,\r\n(MC2_BI_DI | MC2_PSW_EN | MC2_SPD_SUSP_CTRL));\r\ni2c_smbus_write_byte_data(isp1301_i2c_client,\r\n(ISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR), ~0);\r\ni2c_smbus_write_byte_data(isp1301_i2c_client,\r\nISP1301_I2C_MODE_CONTROL_1, MC1_DAT_SE0);\r\ni2c_smbus_write_byte_data(isp1301_i2c_client,\r\nISP1301_I2C_OTG_CONTROL_1,\r\n(OTG1_DM_PULLDOWN | OTG1_DP_PULLDOWN));\r\ni2c_smbus_write_byte_data(isp1301_i2c_client,\r\n(ISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR),\r\n(OTG1_DM_PULLUP | OTG1_DP_PULLUP));\r\ni2c_smbus_write_byte_data(isp1301_i2c_client,\r\nISP1301_I2C_INTERRUPT_LATCH | ISP1301_I2C_REG_CLEAR_ADDR, ~0);\r\ni2c_smbus_write_byte_data(isp1301_i2c_client,\r\nISP1301_I2C_INTERRUPT_FALLING | ISP1301_I2C_REG_CLEAR_ADDR,\r\n~0);\r\ni2c_smbus_write_byte_data(isp1301_i2c_client,\r\nISP1301_I2C_INTERRUPT_RISING | ISP1301_I2C_REG_CLEAR_ADDR, ~0);\r\n__raw_writel(__raw_readl(USB_CTRL) | USB_HOST_NEED_CLK_EN, USB_CTRL);\r\nprintk(KERN_INFO "ISP1301 Vendor ID : 0x%04x\n",\r\ni2c_smbus_read_word_data(isp1301_i2c_client, 0x00));\r\nprintk(KERN_INFO "ISP1301 Product ID : 0x%04x\n",\r\ni2c_smbus_read_word_data(isp1301_i2c_client, 0x02));\r\nprintk(KERN_INFO "ISP1301 Version ID : 0x%04x\n",\r\ni2c_smbus_read_word_data(isp1301_i2c_client, 0x14));\r\n}\r\nstatic void isp1301_configure(void)\r\n{\r\nisp1301_configure_lpc32xx();\r\n}\r\nstatic inline void isp1301_vbus_on(void)\r\n{\r\ni2c_smbus_write_byte_data(isp1301_i2c_client, ISP1301_I2C_OTG_CONTROL_1,\r\nOTG1_VBUS_DRV);\r\n}\r\nstatic inline void isp1301_vbus_off(void)\r\n{\r\ni2c_smbus_write_byte_data(isp1301_i2c_client,\r\nISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR,\r\nOTG1_VBUS_DRV);\r\n}\r\nstatic void ohci_nxp_start_hc(void)\r\n{\r\nunsigned long tmp = __raw_readl(USB_OTG_STAT_CONTROL) | HOST_EN;\r\n__raw_writel(tmp, USB_OTG_STAT_CONTROL);\r\nisp1301_vbus_on();\r\n}\r\nstatic void ohci_nxp_stop_hc(void)\r\n{\r\nunsigned long tmp;\r\nisp1301_vbus_off();\r\ntmp = __raw_readl(USB_OTG_STAT_CONTROL) & ~HOST_EN;\r\n__raw_writel(tmp, USB_OTG_STAT_CONTROL);\r\n}\r\nstatic int ohci_hcd_nxp_probe(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd = 0;\r\nconst struct hc_driver *driver = &ohci_nxp_hc_driver;\r\nstruct resource *res;\r\nint ret = 0, irq;\r\nstruct device_node *isp1301_node;\r\nif (pdev->dev.of_node) {\r\nisp1301_node = of_parse_phandle(pdev->dev.of_node,\r\n"transceiver", 0);\r\n} else {\r\nisp1301_node = NULL;\r\n}\r\nisp1301_i2c_client = isp1301_get_client(isp1301_node);\r\nif (!isp1301_i2c_client) {\r\nreturn -EPROBE_DEFER;\r\n}\r\nret = dma_coerce_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\r\nif (ret)\r\ngoto fail_disable;\r\ndev_dbg(&pdev->dev, "%s: " DRIVER_DESC " (nxp)\n", hcd_name);\r\nif (usb_disabled()) {\r\ndev_err(&pdev->dev, "USB is disabled\n");\r\nret = -ENODEV;\r\ngoto fail_disable;\r\n}\r\n__raw_writel(USB_SLAVE_HCLK_EN | PAD_CONTROL_LAST_DRIVEN, USB_CTRL);\r\nusb_pll_clk = devm_clk_get(&pdev->dev, "ck_pll5");\r\nif (IS_ERR(usb_pll_clk)) {\r\ndev_err(&pdev->dev, "failed to acquire USB PLL\n");\r\nret = PTR_ERR(usb_pll_clk);\r\ngoto fail_disable;\r\n}\r\nret = clk_enable(usb_pll_clk);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to start USB PLL\n");\r\ngoto fail_disable;\r\n}\r\nret = clk_set_rate(usb_pll_clk, 48000);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to set USB clock rate\n");\r\ngoto fail_rate;\r\n}\r\nusb_dev_clk = devm_clk_get(&pdev->dev, "ck_usbd");\r\nif (IS_ERR(usb_dev_clk)) {\r\ndev_err(&pdev->dev, "failed to acquire USB DEV Clock\n");\r\nret = PTR_ERR(usb_dev_clk);\r\ngoto fail_rate;\r\n}\r\nret = clk_enable(usb_dev_clk);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to start USB DEV Clock\n");\r\ngoto fail_rate;\r\n}\r\nusb_otg_clk = devm_clk_get(&pdev->dev, "ck_usb_otg");\r\nif (IS_ERR(usb_otg_clk)) {\r\ndev_err(&pdev->dev, "failed to acquire USB DEV Clock\n");\r\nret = PTR_ERR(usb_otg_clk);\r\ngoto fail_otg;\r\n}\r\n__raw_writel(__raw_readl(USB_CTRL) | USB_HOST_NEED_CLK_EN, USB_CTRL);\r\nret = clk_enable(usb_otg_clk);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to start USB DEV Clock\n");\r\ngoto fail_otg;\r\n}\r\nisp1301_configure();\r\nhcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));\r\nif (!hcd) {\r\ndev_err(&pdev->dev, "Failed to allocate HC buffer\n");\r\nret = -ENOMEM;\r\ngoto fail_hcd;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nhcd->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(hcd->regs)) {\r\nret = PTR_ERR(hcd->regs);\r\ngoto fail_resource;\r\n}\r\nhcd->rsrc_start = res->start;\r\nhcd->rsrc_len = resource_size(res);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\nret = -ENXIO;\r\ngoto fail_resource;\r\n}\r\nohci_nxp_start_hc();\r\nplatform_set_drvdata(pdev, hcd);\r\ndev_info(&pdev->dev, "at 0x%p, irq %d\n", hcd->regs, hcd->irq);\r\nret = usb_add_hcd(hcd, irq, 0);\r\nif (ret == 0) {\r\ndevice_wakeup_enable(hcd->self.controller);\r\nreturn ret;\r\n}\r\nohci_nxp_stop_hc();\r\nfail_resource:\r\nusb_put_hcd(hcd);\r\nfail_hcd:\r\nclk_disable(usb_otg_clk);\r\nfail_otg:\r\nclk_disable(usb_dev_clk);\r\nfail_rate:\r\nclk_disable(usb_pll_clk);\r\nfail_disable:\r\nisp1301_i2c_client = NULL;\r\nreturn ret;\r\n}\r\nstatic int ohci_hcd_nxp_remove(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nusb_remove_hcd(hcd);\r\nohci_nxp_stop_hc();\r\nusb_put_hcd(hcd);\r\nclk_disable(usb_pll_clk);\r\nclk_disable(usb_dev_clk);\r\ni2c_unregister_device(isp1301_i2c_client);\r\nisp1301_i2c_client = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init ohci_nxp_init(void)\r\n{\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\npr_info("%s: " DRIVER_DESC "\n", hcd_name);\r\nohci_init_driver(&ohci_nxp_hc_driver, NULL);\r\nreturn platform_driver_register(&ohci_hcd_nxp_driver);\r\n}\r\nstatic void __exit ohci_nxp_cleanup(void)\r\n{\r\nplatform_driver_unregister(&ohci_hcd_nxp_driver);\r\n}
