static __u64 ptr_to_u64(void *ptr)\r\n{\r\nreturn (__u64) (unsigned long) ptr;\r\n}\r\nint bpf_create_map(enum bpf_map_type map_type, int key_size, int value_size,\r\nint max_entries)\r\n{\r\nunion bpf_attr attr = {\r\n.map_type = map_type,\r\n.key_size = key_size,\r\n.value_size = value_size,\r\n.max_entries = max_entries\r\n};\r\nreturn syscall(__NR_bpf, BPF_MAP_CREATE, &attr, sizeof(attr));\r\n}\r\nint bpf_update_elem(int fd, void *key, void *value, unsigned long long flags)\r\n{\r\nunion bpf_attr attr = {\r\n.map_fd = fd,\r\n.key = ptr_to_u64(key),\r\n.value = ptr_to_u64(value),\r\n.flags = flags,\r\n};\r\nreturn syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, &attr, sizeof(attr));\r\n}\r\nint bpf_lookup_elem(int fd, void *key, void *value)\r\n{\r\nunion bpf_attr attr = {\r\n.map_fd = fd,\r\n.key = ptr_to_u64(key),\r\n.value = ptr_to_u64(value),\r\n};\r\nreturn syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, &attr, sizeof(attr));\r\n}\r\nint bpf_delete_elem(int fd, void *key)\r\n{\r\nunion bpf_attr attr = {\r\n.map_fd = fd,\r\n.key = ptr_to_u64(key),\r\n};\r\nreturn syscall(__NR_bpf, BPF_MAP_DELETE_ELEM, &attr, sizeof(attr));\r\n}\r\nint bpf_get_next_key(int fd, void *key, void *next_key)\r\n{\r\nunion bpf_attr attr = {\r\n.map_fd = fd,\r\n.key = ptr_to_u64(key),\r\n.next_key = ptr_to_u64(next_key),\r\n};\r\nreturn syscall(__NR_bpf, BPF_MAP_GET_NEXT_KEY, &attr, sizeof(attr));\r\n}\r\nint bpf_prog_load(enum bpf_prog_type prog_type,\r\nconst struct bpf_insn *insns, int prog_len,\r\nconst char *license, int kern_version)\r\n{\r\nunion bpf_attr attr = {\r\n.prog_type = prog_type,\r\n.insns = ptr_to_u64((void *) insns),\r\n.insn_cnt = prog_len / sizeof(struct bpf_insn),\r\n.license = ptr_to_u64((void *) license),\r\n.log_buf = ptr_to_u64(bpf_log_buf),\r\n.log_size = LOG_BUF_SIZE,\r\n.log_level = 1,\r\n};\r\nattr.kern_version = kern_version;\r\nbpf_log_buf[0] = 0;\r\nreturn syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr));\r\n}\r\nint open_raw_sock(const char *name)\r\n{\r\nstruct sockaddr_ll sll;\r\nint sock;\r\nsock = socket(PF_PACKET, SOCK_RAW | SOCK_NONBLOCK | SOCK_CLOEXEC, htons(ETH_P_ALL));\r\nif (sock < 0) {\r\nprintf("cannot create raw socket\n");\r\nreturn -1;\r\n}\r\nmemset(&sll, 0, sizeof(sll));\r\nsll.sll_family = AF_PACKET;\r\nsll.sll_ifindex = if_nametoindex(name);\r\nsll.sll_protocol = htons(ETH_P_ALL);\r\nif (bind(sock, (struct sockaddr *)&sll, sizeof(sll)) < 0) {\r\nprintf("bind to %s: %s\n", name, strerror(errno));\r\nclose(sock);\r\nreturn -1;\r\n}\r\nreturn sock;\r\n}\r\nint perf_event_open(struct perf_event_attr *attr, int pid, int cpu,\r\nint group_fd, unsigned long flags)\r\n{\r\nreturn syscall(__NR_perf_event_open, attr, pid, cpu,\r\ngroup_fd, flags);\r\n}
