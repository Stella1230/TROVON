static struct ovl_priv_data *get_ovl_priv(struct omap_overlay *ovl)\r\n{\r\nreturn &dss_data.ovl_priv_data_array[ovl->id];\r\n}\r\nstatic struct mgr_priv_data *get_mgr_priv(struct omap_overlay_manager *mgr)\r\n{\r\nreturn &dss_data.mgr_priv_data_array[mgr->id];\r\n}\r\nstatic void apply_init_priv(void)\r\n{\r\nconst int num_ovls = dss_feat_get_num_ovls();\r\nstruct mgr_priv_data *mp;\r\nint i;\r\nspin_lock_init(&data_lock);\r\nfor (i = 0; i < num_ovls; ++i) {\r\nstruct ovl_priv_data *op;\r\nop = &dss_data.ovl_priv_data_array[i];\r\nop->info.color_mode = OMAP_DSS_COLOR_RGB16;\r\nop->info.rotation_type = OMAP_DSS_ROT_DMA;\r\nop->info.global_alpha = 255;\r\nswitch (i) {\r\ncase 0:\r\nop->info.zorder = 0;\r\nbreak;\r\ncase 1:\r\nop->info.zorder =\r\ndss_has_feature(FEAT_ALPHA_FREE_ZORDER) ? 3 : 0;\r\nbreak;\r\ncase 2:\r\nop->info.zorder =\r\ndss_has_feature(FEAT_ALPHA_FREE_ZORDER) ? 2 : 0;\r\nbreak;\r\ncase 3:\r\nop->info.zorder =\r\ndss_has_feature(FEAT_ALPHA_FREE_ZORDER) ? 1 : 0;\r\nbreak;\r\n}\r\nop->user_info = op->info;\r\n}\r\nmp = &dss_data.mgr_priv_data_array[OMAP_DSS_CHANNEL_DIGIT];\r\nmp->lcd_config.video_port_width = 24;\r\nmp->lcd_config.clock_info.lck_div = 1;\r\nmp->lcd_config.clock_info.pck_div = 1;\r\n}\r\nstatic bool ovl_manual_update(struct omap_overlay *ovl)\r\n{\r\nstruct mgr_priv_data *mp = get_mgr_priv(ovl->manager);\r\nreturn mp->lcd_config.stallmode;\r\n}\r\nstatic bool mgr_manual_update(struct omap_overlay_manager *mgr)\r\n{\r\nstruct mgr_priv_data *mp = get_mgr_priv(mgr);\r\nreturn mp->lcd_config.stallmode;\r\n}\r\nstatic int dss_check_settings_low(struct omap_overlay_manager *mgr,\r\nbool applying)\r\n{\r\nstruct omap_overlay_info *oi;\r\nstruct omap_overlay_manager_info *mi;\r\nstruct omap_overlay *ovl;\r\nstruct omap_overlay_info *ois[MAX_DSS_OVERLAYS];\r\nstruct ovl_priv_data *op;\r\nstruct mgr_priv_data *mp;\r\nmp = get_mgr_priv(mgr);\r\nif (!mp->enabled)\r\nreturn 0;\r\nif (applying && mp->user_info_dirty)\r\nmi = &mp->user_info;\r\nelse\r\nmi = &mp->info;\r\nlist_for_each_entry(ovl, &mgr->overlays, list) {\r\nop = get_ovl_priv(ovl);\r\nif (!op->enabled && !op->enabling)\r\noi = NULL;\r\nelse if (applying && op->user_info_dirty)\r\noi = &op->user_info;\r\nelse\r\noi = &op->info;\r\nois[ovl->id] = oi;\r\n}\r\nreturn dss_mgr_check(mgr, mi, &mp->timings, &mp->lcd_config, ois);\r\n}\r\nstatic int dss_check_settings(struct omap_overlay_manager *mgr)\r\n{\r\nreturn dss_check_settings_low(mgr, false);\r\n}\r\nstatic int dss_check_settings_apply(struct omap_overlay_manager *mgr)\r\n{\r\nreturn dss_check_settings_low(mgr, true);\r\n}\r\nstatic bool need_isr(void)\r\n{\r\nconst int num_mgrs = dss_feat_get_num_mgrs();\r\nint i;\r\nfor (i = 0; i < num_mgrs; ++i) {\r\nstruct omap_overlay_manager *mgr;\r\nstruct mgr_priv_data *mp;\r\nstruct omap_overlay *ovl;\r\nmgr = omap_dss_get_overlay_manager(i);\r\nmp = get_mgr_priv(mgr);\r\nif (!mp->enabled)\r\ncontinue;\r\nif (mgr_manual_update(mgr)) {\r\nif (mp->updating)\r\nreturn true;\r\n} else {\r\nif (mp->busy)\r\nreturn true;\r\nif (mp->info_dirty)\r\nreturn true;\r\nif (mp->shadow_info_dirty)\r\nreturn true;\r\nif (mp->extra_info_dirty)\r\nreturn true;\r\nif (mp->shadow_extra_info_dirty)\r\nreturn true;\r\nlist_for_each_entry(ovl, &mgr->overlays, list) {\r\nstruct ovl_priv_data *op;\r\nop = get_ovl_priv(ovl);\r\nif (op->extra_info_dirty)\r\nreturn true;\r\nif (op->shadow_extra_info_dirty)\r\nreturn true;\r\nif (!op->enabled)\r\ncontinue;\r\nif (op->info_dirty)\r\nreturn true;\r\nif (op->shadow_info_dirty)\r\nreturn true;\r\n}\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic bool need_go(struct omap_overlay_manager *mgr)\r\n{\r\nstruct omap_overlay *ovl;\r\nstruct mgr_priv_data *mp;\r\nstruct ovl_priv_data *op;\r\nmp = get_mgr_priv(mgr);\r\nif (mp->shadow_info_dirty || mp->shadow_extra_info_dirty)\r\nreturn true;\r\nlist_for_each_entry(ovl, &mgr->overlays, list) {\r\nop = get_ovl_priv(ovl);\r\nif (op->shadow_info_dirty || op->shadow_extra_info_dirty)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool extra_info_update_ongoing(void)\r\n{\r\nconst int num_mgrs = dss_feat_get_num_mgrs();\r\nint i;\r\nfor (i = 0; i < num_mgrs; ++i) {\r\nstruct omap_overlay_manager *mgr;\r\nstruct omap_overlay *ovl;\r\nstruct mgr_priv_data *mp;\r\nmgr = omap_dss_get_overlay_manager(i);\r\nmp = get_mgr_priv(mgr);\r\nif (!mp->enabled)\r\ncontinue;\r\nif (!mp->updating)\r\ncontinue;\r\nif (mp->extra_info_dirty || mp->shadow_extra_info_dirty)\r\nreturn true;\r\nlist_for_each_entry(ovl, &mgr->overlays, list) {\r\nstruct ovl_priv_data *op = get_ovl_priv(ovl);\r\nif (op->extra_info_dirty || op->shadow_extra_info_dirty)\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic void wait_pending_extra_info_updates(void)\r\n{\r\nbool updating;\r\nunsigned long flags;\r\nunsigned long t;\r\nint r;\r\nspin_lock_irqsave(&data_lock, flags);\r\nupdating = extra_info_update_ongoing();\r\nif (!updating) {\r\nspin_unlock_irqrestore(&data_lock, flags);\r\nreturn;\r\n}\r\ninit_completion(&extra_updated_completion);\r\nspin_unlock_irqrestore(&data_lock, flags);\r\nt = msecs_to_jiffies(500);\r\nr = wait_for_completion_timeout(&extra_updated_completion, t);\r\nif (r == 0)\r\nDSSWARN("timeout in wait_pending_extra_info_updates\n");\r\n}\r\nstatic struct omap_dss_device *dss_mgr_get_device(struct omap_overlay_manager *mgr)\r\n{\r\nstruct omap_dss_device *dssdev;\r\ndssdev = mgr->output;\r\nif (dssdev == NULL)\r\nreturn NULL;\r\nwhile (dssdev->dst)\r\ndssdev = dssdev->dst;\r\nif (dssdev->driver)\r\nreturn dssdev;\r\nelse\r\nreturn NULL;\r\n}\r\nstatic struct omap_dss_device *dss_ovl_get_device(struct omap_overlay *ovl)\r\n{\r\nreturn ovl->manager ? dss_mgr_get_device(ovl->manager) : NULL;\r\n}\r\nstatic int dss_mgr_wait_for_vsync(struct omap_overlay_manager *mgr)\r\n{\r\nunsigned long timeout = msecs_to_jiffies(500);\r\nu32 irq;\r\nint r;\r\nif (mgr->output == NULL)\r\nreturn -ENODEV;\r\nr = dispc_runtime_get();\r\nif (r)\r\nreturn r;\r\nswitch (mgr->output->id) {\r\ncase OMAP_DSS_OUTPUT_VENC:\r\nirq = DISPC_IRQ_EVSYNC_ODD;\r\nbreak;\r\ncase OMAP_DSS_OUTPUT_HDMI:\r\nirq = DISPC_IRQ_EVSYNC_EVEN;\r\nbreak;\r\ndefault:\r\nirq = dispc_mgr_get_vsync_irq(mgr->id);\r\nbreak;\r\n}\r\nr = omap_dispc_wait_for_irq_interruptible_timeout(irq, timeout);\r\ndispc_runtime_put();\r\nreturn r;\r\n}\r\nstatic int dss_mgr_wait_for_go(struct omap_overlay_manager *mgr)\r\n{\r\nunsigned long timeout = msecs_to_jiffies(500);\r\nstruct mgr_priv_data *mp = get_mgr_priv(mgr);\r\nu32 irq;\r\nunsigned long flags;\r\nint r;\r\nint i;\r\nspin_lock_irqsave(&data_lock, flags);\r\nif (mgr_manual_update(mgr)) {\r\nspin_unlock_irqrestore(&data_lock, flags);\r\nreturn 0;\r\n}\r\nif (!mp->enabled) {\r\nspin_unlock_irqrestore(&data_lock, flags);\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&data_lock, flags);\r\nr = dispc_runtime_get();\r\nif (r)\r\nreturn r;\r\nirq = dispc_mgr_get_vsync_irq(mgr->id);\r\ni = 0;\r\nwhile (1) {\r\nbool shadow_dirty, dirty;\r\nspin_lock_irqsave(&data_lock, flags);\r\ndirty = mp->info_dirty;\r\nshadow_dirty = mp->shadow_info_dirty;\r\nspin_unlock_irqrestore(&data_lock, flags);\r\nif (!dirty && !shadow_dirty) {\r\nr = 0;\r\nbreak;\r\n}\r\nif (i++ == 3) {\r\nDSSERR("mgr(%d)->wait_for_go() not finishing\n",\r\nmgr->id);\r\nr = 0;\r\nbreak;\r\n}\r\nr = omap_dispc_wait_for_irq_interruptible_timeout(irq, timeout);\r\nif (r == -ERESTARTSYS)\r\nbreak;\r\nif (r) {\r\nDSSERR("mgr(%d)->wait_for_go() timeout\n", mgr->id);\r\nbreak;\r\n}\r\n}\r\ndispc_runtime_put();\r\nreturn r;\r\n}\r\nstatic int dss_mgr_wait_for_go_ovl(struct omap_overlay *ovl)\r\n{\r\nunsigned long timeout = msecs_to_jiffies(500);\r\nstruct ovl_priv_data *op;\r\nstruct mgr_priv_data *mp;\r\nu32 irq;\r\nunsigned long flags;\r\nint r;\r\nint i;\r\nif (!ovl->manager)\r\nreturn 0;\r\nmp = get_mgr_priv(ovl->manager);\r\nspin_lock_irqsave(&data_lock, flags);\r\nif (ovl_manual_update(ovl)) {\r\nspin_unlock_irqrestore(&data_lock, flags);\r\nreturn 0;\r\n}\r\nif (!mp->enabled) {\r\nspin_unlock_irqrestore(&data_lock, flags);\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&data_lock, flags);\r\nr = dispc_runtime_get();\r\nif (r)\r\nreturn r;\r\nirq = dispc_mgr_get_vsync_irq(ovl->manager->id);\r\nop = get_ovl_priv(ovl);\r\ni = 0;\r\nwhile (1) {\r\nbool shadow_dirty, dirty;\r\nspin_lock_irqsave(&data_lock, flags);\r\ndirty = op->info_dirty;\r\nshadow_dirty = op->shadow_info_dirty;\r\nspin_unlock_irqrestore(&data_lock, flags);\r\nif (!dirty && !shadow_dirty) {\r\nr = 0;\r\nbreak;\r\n}\r\nif (i++ == 3) {\r\nDSSERR("ovl(%d)->wait_for_go() not finishing\n",\r\novl->id);\r\nr = 0;\r\nbreak;\r\n}\r\nr = omap_dispc_wait_for_irq_interruptible_timeout(irq, timeout);\r\nif (r == -ERESTARTSYS)\r\nbreak;\r\nif (r) {\r\nDSSERR("ovl(%d)->wait_for_go() timeout\n", ovl->id);\r\nbreak;\r\n}\r\n}\r\ndispc_runtime_put();\r\nreturn r;\r\n}\r\nstatic void dss_ovl_write_regs(struct omap_overlay *ovl)\r\n{\r\nstruct ovl_priv_data *op = get_ovl_priv(ovl);\r\nstruct omap_overlay_info *oi;\r\nbool replication;\r\nstruct mgr_priv_data *mp;\r\nint r;\r\nDSSDBG("writing ovl %d regs\n", ovl->id);\r\nif (!op->enabled || !op->info_dirty)\r\nreturn;\r\noi = &op->info;\r\nmp = get_mgr_priv(ovl->manager);\r\nreplication = dss_ovl_use_replication(mp->lcd_config, oi->color_mode);\r\nr = dispc_ovl_setup(ovl->id, oi, replication, &mp->timings, false);\r\nif (r) {\r\nDSSERR("dispc_ovl_setup failed for ovl %d\n", ovl->id);\r\nop->enabled = false;\r\ndispc_ovl_enable(ovl->id, false);\r\nreturn;\r\n}\r\nop->info_dirty = false;\r\nif (mp->updating)\r\nop->shadow_info_dirty = true;\r\n}\r\nstatic void dss_ovl_write_regs_extra(struct omap_overlay *ovl)\r\n{\r\nstruct ovl_priv_data *op = get_ovl_priv(ovl);\r\nstruct mgr_priv_data *mp;\r\nDSSDBG("writing ovl %d regs extra\n", ovl->id);\r\nif (!op->extra_info_dirty)\r\nreturn;\r\ndispc_ovl_enable(ovl->id, op->enabled);\r\ndispc_ovl_set_fifo_threshold(ovl->id, op->fifo_low, op->fifo_high);\r\nmp = get_mgr_priv(ovl->manager);\r\nop->extra_info_dirty = false;\r\nif (mp->updating)\r\nop->shadow_extra_info_dirty = true;\r\n}\r\nstatic void dss_mgr_write_regs(struct omap_overlay_manager *mgr)\r\n{\r\nstruct mgr_priv_data *mp = get_mgr_priv(mgr);\r\nstruct omap_overlay *ovl;\r\nDSSDBG("writing mgr %d regs\n", mgr->id);\r\nif (!mp->enabled)\r\nreturn;\r\nWARN_ON(mp->busy);\r\nlist_for_each_entry(ovl, &mgr->overlays, list) {\r\ndss_ovl_write_regs(ovl);\r\ndss_ovl_write_regs_extra(ovl);\r\n}\r\nif (mp->info_dirty) {\r\ndispc_mgr_setup(mgr->id, &mp->info);\r\nmp->info_dirty = false;\r\nif (mp->updating)\r\nmp->shadow_info_dirty = true;\r\n}\r\n}\r\nstatic void dss_mgr_write_regs_extra(struct omap_overlay_manager *mgr)\r\n{\r\nstruct mgr_priv_data *mp = get_mgr_priv(mgr);\r\nDSSDBG("writing mgr %d regs extra\n", mgr->id);\r\nif (!mp->extra_info_dirty)\r\nreturn;\r\ndispc_mgr_set_timings(mgr->id, &mp->timings);\r\nif (dss_mgr_is_lcd(mgr->id))\r\ndispc_mgr_set_lcd_config(mgr->id, &mp->lcd_config);\r\nmp->extra_info_dirty = false;\r\nif (mp->updating)\r\nmp->shadow_extra_info_dirty = true;\r\n}\r\nstatic void dss_write_regs(void)\r\n{\r\nconst int num_mgrs = omap_dss_get_num_overlay_managers();\r\nint i;\r\nfor (i = 0; i < num_mgrs; ++i) {\r\nstruct omap_overlay_manager *mgr;\r\nstruct mgr_priv_data *mp;\r\nint r;\r\nmgr = omap_dss_get_overlay_manager(i);\r\nmp = get_mgr_priv(mgr);\r\nif (!mp->enabled || mgr_manual_update(mgr) || mp->busy)\r\ncontinue;\r\nr = dss_check_settings(mgr);\r\nif (r) {\r\nDSSERR("cannot write registers for manager %s: "\r\n"illegal configuration\n", mgr->name);\r\ncontinue;\r\n}\r\ndss_mgr_write_regs(mgr);\r\ndss_mgr_write_regs_extra(mgr);\r\n}\r\n}\r\nstatic void dss_set_go_bits(void)\r\n{\r\nconst int num_mgrs = omap_dss_get_num_overlay_managers();\r\nint i;\r\nfor (i = 0; i < num_mgrs; ++i) {\r\nstruct omap_overlay_manager *mgr;\r\nstruct mgr_priv_data *mp;\r\nmgr = omap_dss_get_overlay_manager(i);\r\nmp = get_mgr_priv(mgr);\r\nif (!mp->enabled || mgr_manual_update(mgr) || mp->busy)\r\ncontinue;\r\nif (!need_go(mgr))\r\ncontinue;\r\nmp->busy = true;\r\nif (!dss_data.irq_enabled && need_isr())\r\ndss_register_vsync_isr();\r\ndispc_mgr_go(mgr->id);\r\n}\r\n}\r\nstatic void mgr_clear_shadow_dirty(struct omap_overlay_manager *mgr)\r\n{\r\nstruct omap_overlay *ovl;\r\nstruct mgr_priv_data *mp;\r\nstruct ovl_priv_data *op;\r\nmp = get_mgr_priv(mgr);\r\nmp->shadow_info_dirty = false;\r\nmp->shadow_extra_info_dirty = false;\r\nlist_for_each_entry(ovl, &mgr->overlays, list) {\r\nop = get_ovl_priv(ovl);\r\nop->shadow_info_dirty = false;\r\nop->shadow_extra_info_dirty = false;\r\n}\r\n}\r\nstatic int dss_mgr_connect_compat(struct omap_overlay_manager *mgr,\r\nstruct omap_dss_device *dst)\r\n{\r\nreturn mgr->set_output(mgr, dst);\r\n}\r\nstatic void dss_mgr_disconnect_compat(struct omap_overlay_manager *mgr,\r\nstruct omap_dss_device *dst)\r\n{\r\nmgr->unset_output(mgr);\r\n}\r\nstatic void dss_mgr_start_update_compat(struct omap_overlay_manager *mgr)\r\n{\r\nstruct mgr_priv_data *mp = get_mgr_priv(mgr);\r\nunsigned long flags;\r\nint r;\r\nspin_lock_irqsave(&data_lock, flags);\r\nWARN_ON(mp->updating);\r\nr = dss_check_settings(mgr);\r\nif (r) {\r\nDSSERR("cannot start manual update: illegal configuration\n");\r\nspin_unlock_irqrestore(&data_lock, flags);\r\nreturn;\r\n}\r\ndss_mgr_write_regs(mgr);\r\ndss_mgr_write_regs_extra(mgr);\r\nmp->updating = true;\r\nif (!dss_data.irq_enabled && need_isr())\r\ndss_register_vsync_isr();\r\ndispc_mgr_enable_sync(mgr->id);\r\nspin_unlock_irqrestore(&data_lock, flags);\r\n}\r\nstatic void dss_register_vsync_isr(void)\r\n{\r\nconst int num_mgrs = dss_feat_get_num_mgrs();\r\nu32 mask;\r\nint r, i;\r\nmask = 0;\r\nfor (i = 0; i < num_mgrs; ++i)\r\nmask |= dispc_mgr_get_vsync_irq(i);\r\nfor (i = 0; i < num_mgrs; ++i)\r\nmask |= dispc_mgr_get_framedone_irq(i);\r\nr = omap_dispc_register_isr(dss_apply_irq_handler, NULL, mask);\r\nWARN_ON(r);\r\ndss_data.irq_enabled = true;\r\n}\r\nstatic void dss_unregister_vsync_isr(void)\r\n{\r\nconst int num_mgrs = dss_feat_get_num_mgrs();\r\nu32 mask;\r\nint r, i;\r\nmask = 0;\r\nfor (i = 0; i < num_mgrs; ++i)\r\nmask |= dispc_mgr_get_vsync_irq(i);\r\nfor (i = 0; i < num_mgrs; ++i)\r\nmask |= dispc_mgr_get_framedone_irq(i);\r\nr = omap_dispc_unregister_isr(dss_apply_irq_handler, NULL, mask);\r\nWARN_ON(r);\r\ndss_data.irq_enabled = false;\r\n}\r\nstatic void dss_apply_irq_handler(void *data, u32 mask)\r\n{\r\nconst int num_mgrs = dss_feat_get_num_mgrs();\r\nint i;\r\nbool extra_updating;\r\nspin_lock(&data_lock);\r\nfor (i = 0; i < num_mgrs; i++) {\r\nstruct omap_overlay_manager *mgr;\r\nstruct mgr_priv_data *mp;\r\nmgr = omap_dss_get_overlay_manager(i);\r\nmp = get_mgr_priv(mgr);\r\nif (!mp->enabled)\r\ncontinue;\r\nmp->updating = dispc_mgr_is_enabled(i);\r\nif (!mgr_manual_update(mgr)) {\r\nbool was_busy = mp->busy;\r\nmp->busy = dispc_mgr_go_busy(i);\r\nif (was_busy && !mp->busy)\r\nmgr_clear_shadow_dirty(mgr);\r\n}\r\n}\r\ndss_write_regs();\r\ndss_set_go_bits();\r\nextra_updating = extra_info_update_ongoing();\r\nif (!extra_updating)\r\ncomplete_all(&extra_updated_completion);\r\nfor (i = 0; i < num_mgrs; i++) {\r\nstruct omap_overlay_manager *mgr;\r\nstruct mgr_priv_data *mp;\r\nmgr = omap_dss_get_overlay_manager(i);\r\nmp = get_mgr_priv(mgr);\r\nif (!mgr_manual_update(mgr) || !mp->framedone_handler)\r\ncontinue;\r\nif (mask & dispc_mgr_get_framedone_irq(i))\r\nmp->framedone_handler(mp->framedone_handler_data);\r\n}\r\nif (!need_isr())\r\ndss_unregister_vsync_isr();\r\nspin_unlock(&data_lock);\r\n}\r\nstatic void omap_dss_mgr_apply_ovl(struct omap_overlay *ovl)\r\n{\r\nstruct ovl_priv_data *op;\r\nop = get_ovl_priv(ovl);\r\nif (!op->user_info_dirty)\r\nreturn;\r\nop->user_info_dirty = false;\r\nop->info_dirty = true;\r\nop->info = op->user_info;\r\n}\r\nstatic void omap_dss_mgr_apply_mgr(struct omap_overlay_manager *mgr)\r\n{\r\nstruct mgr_priv_data *mp;\r\nmp = get_mgr_priv(mgr);\r\nif (!mp->user_info_dirty)\r\nreturn;\r\nmp->user_info_dirty = false;\r\nmp->info_dirty = true;\r\nmp->info = mp->user_info;\r\n}\r\nstatic int omap_dss_mgr_apply(struct omap_overlay_manager *mgr)\r\n{\r\nunsigned long flags;\r\nstruct omap_overlay *ovl;\r\nint r;\r\nDSSDBG("omap_dss_mgr_apply(%s)\n", mgr->name);\r\nspin_lock_irqsave(&data_lock, flags);\r\nr = dss_check_settings_apply(mgr);\r\nif (r) {\r\nspin_unlock_irqrestore(&data_lock, flags);\r\nDSSERR("failed to apply settings: illegal configuration.\n");\r\nreturn r;\r\n}\r\nlist_for_each_entry(ovl, &mgr->overlays, list)\r\nomap_dss_mgr_apply_ovl(ovl);\r\nomap_dss_mgr_apply_mgr(mgr);\r\ndss_write_regs();\r\ndss_set_go_bits();\r\nspin_unlock_irqrestore(&data_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void dss_apply_ovl_enable(struct omap_overlay *ovl, bool enable)\r\n{\r\nstruct ovl_priv_data *op;\r\nop = get_ovl_priv(ovl);\r\nif (op->enabled == enable)\r\nreturn;\r\nop->enabled = enable;\r\nop->extra_info_dirty = true;\r\n}\r\nstatic void dss_apply_ovl_fifo_thresholds(struct omap_overlay *ovl,\r\nu32 fifo_low, u32 fifo_high)\r\n{\r\nstruct ovl_priv_data *op = get_ovl_priv(ovl);\r\nif (op->fifo_low == fifo_low && op->fifo_high == fifo_high)\r\nreturn;\r\nop->fifo_low = fifo_low;\r\nop->fifo_high = fifo_high;\r\nop->extra_info_dirty = true;\r\n}\r\nstatic void dss_ovl_setup_fifo(struct omap_overlay *ovl)\r\n{\r\nstruct ovl_priv_data *op = get_ovl_priv(ovl);\r\nu32 fifo_low, fifo_high;\r\nbool use_fifo_merge = false;\r\nif (!op->enabled && !op->enabling)\r\nreturn;\r\ndispc_ovl_compute_fifo_thresholds(ovl->id, &fifo_low, &fifo_high,\r\nuse_fifo_merge, ovl_manual_update(ovl));\r\ndss_apply_ovl_fifo_thresholds(ovl, fifo_low, fifo_high);\r\n}\r\nstatic void dss_mgr_setup_fifos(struct omap_overlay_manager *mgr)\r\n{\r\nstruct omap_overlay *ovl;\r\nstruct mgr_priv_data *mp;\r\nmp = get_mgr_priv(mgr);\r\nif (!mp->enabled)\r\nreturn;\r\nlist_for_each_entry(ovl, &mgr->overlays, list)\r\ndss_ovl_setup_fifo(ovl);\r\n}\r\nstatic void dss_setup_fifos(void)\r\n{\r\nconst int num_mgrs = omap_dss_get_num_overlay_managers();\r\nstruct omap_overlay_manager *mgr;\r\nint i;\r\nfor (i = 0; i < num_mgrs; ++i) {\r\nmgr = omap_dss_get_overlay_manager(i);\r\ndss_mgr_setup_fifos(mgr);\r\n}\r\n}\r\nstatic int dss_mgr_enable_compat(struct omap_overlay_manager *mgr)\r\n{\r\nstruct mgr_priv_data *mp = get_mgr_priv(mgr);\r\nunsigned long flags;\r\nint r;\r\nmutex_lock(&apply_lock);\r\nif (mp->enabled)\r\ngoto out;\r\nspin_lock_irqsave(&data_lock, flags);\r\nmp->enabled = true;\r\nr = dss_check_settings(mgr);\r\nif (r) {\r\nDSSERR("failed to enable manager %d: check_settings failed\n",\r\nmgr->id);\r\ngoto err;\r\n}\r\ndss_setup_fifos();\r\ndss_write_regs();\r\ndss_set_go_bits();\r\nif (!mgr_manual_update(mgr))\r\nmp->updating = true;\r\nif (!dss_data.irq_enabled && need_isr())\r\ndss_register_vsync_isr();\r\nspin_unlock_irqrestore(&data_lock, flags);\r\nif (!mgr_manual_update(mgr))\r\ndispc_mgr_enable_sync(mgr->id);\r\nout:\r\nmutex_unlock(&apply_lock);\r\nreturn 0;\r\nerr:\r\nmp->enabled = false;\r\nspin_unlock_irqrestore(&data_lock, flags);\r\nmutex_unlock(&apply_lock);\r\nreturn r;\r\n}\r\nstatic void dss_mgr_disable_compat(struct omap_overlay_manager *mgr)\r\n{\r\nstruct mgr_priv_data *mp = get_mgr_priv(mgr);\r\nunsigned long flags;\r\nmutex_lock(&apply_lock);\r\nif (!mp->enabled)\r\ngoto out;\r\nwait_pending_extra_info_updates();\r\nif (!mgr_manual_update(mgr))\r\ndispc_mgr_disable_sync(mgr->id);\r\nspin_lock_irqsave(&data_lock, flags);\r\nmp->updating = false;\r\nmp->enabled = false;\r\nspin_unlock_irqrestore(&data_lock, flags);\r\nout:\r\nmutex_unlock(&apply_lock);\r\n}\r\nstatic int dss_mgr_set_info(struct omap_overlay_manager *mgr,\r\nstruct omap_overlay_manager_info *info)\r\n{\r\nstruct mgr_priv_data *mp = get_mgr_priv(mgr);\r\nunsigned long flags;\r\nint r;\r\nr = dss_mgr_simple_check(mgr, info);\r\nif (r)\r\nreturn r;\r\nspin_lock_irqsave(&data_lock, flags);\r\nmp->user_info = *info;\r\nmp->user_info_dirty = true;\r\nspin_unlock_irqrestore(&data_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void dss_mgr_get_info(struct omap_overlay_manager *mgr,\r\nstruct omap_overlay_manager_info *info)\r\n{\r\nstruct mgr_priv_data *mp = get_mgr_priv(mgr);\r\nunsigned long flags;\r\nspin_lock_irqsave(&data_lock, flags);\r\n*info = mp->user_info;\r\nspin_unlock_irqrestore(&data_lock, flags);\r\n}\r\nstatic int dss_mgr_set_output(struct omap_overlay_manager *mgr,\r\nstruct omap_dss_device *output)\r\n{\r\nint r;\r\nmutex_lock(&apply_lock);\r\nif (mgr->output) {\r\nDSSERR("manager %s is already connected to an output\n",\r\nmgr->name);\r\nr = -EINVAL;\r\ngoto err;\r\n}\r\nif ((mgr->supported_outputs & output->id) == 0) {\r\nDSSERR("output does not support manager %s\n",\r\nmgr->name);\r\nr = -EINVAL;\r\ngoto err;\r\n}\r\noutput->manager = mgr;\r\nmgr->output = output;\r\nmutex_unlock(&apply_lock);\r\nreturn 0;\r\nerr:\r\nmutex_unlock(&apply_lock);\r\nreturn r;\r\n}\r\nstatic int dss_mgr_unset_output(struct omap_overlay_manager *mgr)\r\n{\r\nint r;\r\nstruct mgr_priv_data *mp = get_mgr_priv(mgr);\r\nunsigned long flags;\r\nmutex_lock(&apply_lock);\r\nif (!mgr->output) {\r\nDSSERR("failed to unset output, output not set\n");\r\nr = -EINVAL;\r\ngoto err;\r\n}\r\nspin_lock_irqsave(&data_lock, flags);\r\nif (mp->enabled) {\r\nDSSERR("output can't be unset when manager is enabled\n");\r\nr = -EINVAL;\r\ngoto err1;\r\n}\r\nspin_unlock_irqrestore(&data_lock, flags);\r\nmgr->output->manager = NULL;\r\nmgr->output = NULL;\r\nmutex_unlock(&apply_lock);\r\nreturn 0;\r\nerr1:\r\nspin_unlock_irqrestore(&data_lock, flags);\r\nerr:\r\nmutex_unlock(&apply_lock);\r\nreturn r;\r\n}\r\nstatic void dss_apply_mgr_timings(struct omap_overlay_manager *mgr,\r\nconst struct omap_video_timings *timings)\r\n{\r\nstruct mgr_priv_data *mp = get_mgr_priv(mgr);\r\nmp->timings = *timings;\r\nmp->extra_info_dirty = true;\r\n}\r\nstatic void dss_mgr_set_timings_compat(struct omap_overlay_manager *mgr,\r\nconst struct omap_video_timings *timings)\r\n{\r\nunsigned long flags;\r\nstruct mgr_priv_data *mp = get_mgr_priv(mgr);\r\nspin_lock_irqsave(&data_lock, flags);\r\nif (mp->updating) {\r\nDSSERR("cannot set timings for %s: manager needs to be disabled\n",\r\nmgr->name);\r\ngoto out;\r\n}\r\ndss_apply_mgr_timings(mgr, timings);\r\nout:\r\nspin_unlock_irqrestore(&data_lock, flags);\r\n}\r\nstatic void dss_apply_mgr_lcd_config(struct omap_overlay_manager *mgr,\r\nconst struct dss_lcd_mgr_config *config)\r\n{\r\nstruct mgr_priv_data *mp = get_mgr_priv(mgr);\r\nmp->lcd_config = *config;\r\nmp->extra_info_dirty = true;\r\n}\r\nstatic void dss_mgr_set_lcd_config_compat(struct omap_overlay_manager *mgr,\r\nconst struct dss_lcd_mgr_config *config)\r\n{\r\nunsigned long flags;\r\nstruct mgr_priv_data *mp = get_mgr_priv(mgr);\r\nspin_lock_irqsave(&data_lock, flags);\r\nif (mp->enabled) {\r\nDSSERR("cannot apply lcd config for %s: manager needs to be disabled\n",\r\nmgr->name);\r\ngoto out;\r\n}\r\ndss_apply_mgr_lcd_config(mgr, config);\r\nout:\r\nspin_unlock_irqrestore(&data_lock, flags);\r\n}\r\nstatic int dss_ovl_set_info(struct omap_overlay *ovl,\r\nstruct omap_overlay_info *info)\r\n{\r\nstruct ovl_priv_data *op = get_ovl_priv(ovl);\r\nunsigned long flags;\r\nint r;\r\nr = dss_ovl_simple_check(ovl, info);\r\nif (r)\r\nreturn r;\r\nspin_lock_irqsave(&data_lock, flags);\r\nop->user_info = *info;\r\nop->user_info_dirty = true;\r\nspin_unlock_irqrestore(&data_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void dss_ovl_get_info(struct omap_overlay *ovl,\r\nstruct omap_overlay_info *info)\r\n{\r\nstruct ovl_priv_data *op = get_ovl_priv(ovl);\r\nunsigned long flags;\r\nspin_lock_irqsave(&data_lock, flags);\r\n*info = op->user_info;\r\nspin_unlock_irqrestore(&data_lock, flags);\r\n}\r\nstatic int dss_ovl_set_manager(struct omap_overlay *ovl,\r\nstruct omap_overlay_manager *mgr)\r\n{\r\nstruct ovl_priv_data *op = get_ovl_priv(ovl);\r\nunsigned long flags;\r\nint r;\r\nif (!mgr)\r\nreturn -EINVAL;\r\nmutex_lock(&apply_lock);\r\nif (ovl->manager) {\r\nDSSERR("overlay '%s' already has a manager '%s'\n",\r\novl->name, ovl->manager->name);\r\nr = -EINVAL;\r\ngoto err;\r\n}\r\nr = dispc_runtime_get();\r\nif (r)\r\ngoto err;\r\nspin_lock_irqsave(&data_lock, flags);\r\nif (op->enabled) {\r\nspin_unlock_irqrestore(&data_lock, flags);\r\nDSSERR("overlay has to be disabled to change the manager\n");\r\nr = -EINVAL;\r\ngoto err1;\r\n}\r\ndispc_ovl_set_channel_out(ovl->id, mgr->id);\r\novl->manager = mgr;\r\nlist_add_tail(&ovl->list, &mgr->overlays);\r\nspin_unlock_irqrestore(&data_lock, flags);\r\ndispc_runtime_put();\r\nmutex_unlock(&apply_lock);\r\nreturn 0;\r\nerr1:\r\ndispc_runtime_put();\r\nerr:\r\nmutex_unlock(&apply_lock);\r\nreturn r;\r\n}\r\nstatic int dss_ovl_unset_manager(struct omap_overlay *ovl)\r\n{\r\nstruct ovl_priv_data *op = get_ovl_priv(ovl);\r\nunsigned long flags;\r\nint r;\r\nmutex_lock(&apply_lock);\r\nif (!ovl->manager) {\r\nDSSERR("failed to detach overlay: manager not set\n");\r\nr = -EINVAL;\r\ngoto err;\r\n}\r\nspin_lock_irqsave(&data_lock, flags);\r\nif (op->enabled) {\r\nspin_unlock_irqrestore(&data_lock, flags);\r\nDSSERR("overlay has to be disabled to unset the manager\n");\r\nr = -EINVAL;\r\ngoto err;\r\n}\r\nspin_unlock_irqrestore(&data_lock, flags);\r\nwait_pending_extra_info_updates();\r\nspin_lock_irqsave(&data_lock, flags);\r\nif (ovl_manual_update(ovl) && op->extra_info_dirty) {\r\nspin_unlock_irqrestore(&data_lock, flags);\r\nDSSERR("need an update to change the manager\n");\r\nr = -EINVAL;\r\ngoto err;\r\n}\r\novl->manager = NULL;\r\nlist_del(&ovl->list);\r\nspin_unlock_irqrestore(&data_lock, flags);\r\nmutex_unlock(&apply_lock);\r\nreturn 0;\r\nerr:\r\nmutex_unlock(&apply_lock);\r\nreturn r;\r\n}\r\nstatic bool dss_ovl_is_enabled(struct omap_overlay *ovl)\r\n{\r\nstruct ovl_priv_data *op = get_ovl_priv(ovl);\r\nunsigned long flags;\r\nbool e;\r\nspin_lock_irqsave(&data_lock, flags);\r\ne = op->enabled;\r\nspin_unlock_irqrestore(&data_lock, flags);\r\nreturn e;\r\n}\r\nstatic int dss_ovl_enable(struct omap_overlay *ovl)\r\n{\r\nstruct ovl_priv_data *op = get_ovl_priv(ovl);\r\nunsigned long flags;\r\nint r;\r\nmutex_lock(&apply_lock);\r\nif (op->enabled) {\r\nr = 0;\r\ngoto err1;\r\n}\r\nif (ovl->manager == NULL || ovl->manager->output == NULL) {\r\nr = -EINVAL;\r\ngoto err1;\r\n}\r\nspin_lock_irqsave(&data_lock, flags);\r\nop->enabling = true;\r\nr = dss_check_settings(ovl->manager);\r\nif (r) {\r\nDSSERR("failed to enable overlay %d: check_settings failed\n",\r\novl->id);\r\ngoto err2;\r\n}\r\ndss_setup_fifos();\r\nop->enabling = false;\r\ndss_apply_ovl_enable(ovl, true);\r\ndss_write_regs();\r\ndss_set_go_bits();\r\nspin_unlock_irqrestore(&data_lock, flags);\r\nmutex_unlock(&apply_lock);\r\nreturn 0;\r\nerr2:\r\nop->enabling = false;\r\nspin_unlock_irqrestore(&data_lock, flags);\r\nerr1:\r\nmutex_unlock(&apply_lock);\r\nreturn r;\r\n}\r\nstatic int dss_ovl_disable(struct omap_overlay *ovl)\r\n{\r\nstruct ovl_priv_data *op = get_ovl_priv(ovl);\r\nunsigned long flags;\r\nint r;\r\nmutex_lock(&apply_lock);\r\nif (!op->enabled) {\r\nr = 0;\r\ngoto err;\r\n}\r\nif (ovl->manager == NULL || ovl->manager->output == NULL) {\r\nr = -EINVAL;\r\ngoto err;\r\n}\r\nspin_lock_irqsave(&data_lock, flags);\r\ndss_apply_ovl_enable(ovl, false);\r\ndss_write_regs();\r\ndss_set_go_bits();\r\nspin_unlock_irqrestore(&data_lock, flags);\r\nmutex_unlock(&apply_lock);\r\nreturn 0;\r\nerr:\r\nmutex_unlock(&apply_lock);\r\nreturn r;\r\n}\r\nstatic int dss_mgr_register_framedone_handler_compat(struct omap_overlay_manager *mgr,\r\nvoid (*handler)(void *), void *data)\r\n{\r\nstruct mgr_priv_data *mp = get_mgr_priv(mgr);\r\nif (mp->framedone_handler)\r\nreturn -EBUSY;\r\nmp->framedone_handler = handler;\r\nmp->framedone_handler_data = data;\r\nreturn 0;\r\n}\r\nstatic void dss_mgr_unregister_framedone_handler_compat(struct omap_overlay_manager *mgr,\r\nvoid (*handler)(void *), void *data)\r\n{\r\nstruct mgr_priv_data *mp = get_mgr_priv(mgr);\r\nWARN_ON(mp->framedone_handler != handler ||\r\nmp->framedone_handler_data != data);\r\nmp->framedone_handler = NULL;\r\nmp->framedone_handler_data = NULL;\r\n}\r\nint omapdss_compat_init(void)\r\n{\r\nstruct platform_device *pdev = dss_get_core_pdev();\r\nint i, r;\r\nmutex_lock(&compat_init_lock);\r\nif (compat_refcnt++ > 0)\r\ngoto out;\r\napply_init_priv();\r\ndss_init_overlay_managers_sysfs(pdev);\r\ndss_init_overlays(pdev);\r\nfor (i = 0; i < omap_dss_get_num_overlay_managers(); i++) {\r\nstruct omap_overlay_manager *mgr;\r\nmgr = omap_dss_get_overlay_manager(i);\r\nmgr->set_output = &dss_mgr_set_output;\r\nmgr->unset_output = &dss_mgr_unset_output;\r\nmgr->apply = &omap_dss_mgr_apply;\r\nmgr->set_manager_info = &dss_mgr_set_info;\r\nmgr->get_manager_info = &dss_mgr_get_info;\r\nmgr->wait_for_go = &dss_mgr_wait_for_go;\r\nmgr->wait_for_vsync = &dss_mgr_wait_for_vsync;\r\nmgr->get_device = &dss_mgr_get_device;\r\n}\r\nfor (i = 0; i < omap_dss_get_num_overlays(); i++) {\r\nstruct omap_overlay *ovl = omap_dss_get_overlay(i);\r\novl->is_enabled = &dss_ovl_is_enabled;\r\novl->enable = &dss_ovl_enable;\r\novl->disable = &dss_ovl_disable;\r\novl->set_manager = &dss_ovl_set_manager;\r\novl->unset_manager = &dss_ovl_unset_manager;\r\novl->set_overlay_info = &dss_ovl_set_info;\r\novl->get_overlay_info = &dss_ovl_get_info;\r\novl->wait_for_go = &dss_mgr_wait_for_go_ovl;\r\novl->get_device = &dss_ovl_get_device;\r\n}\r\nr = dss_install_mgr_ops(&apply_mgr_ops);\r\nif (r)\r\ngoto err_mgr_ops;\r\nr = display_init_sysfs(pdev);\r\nif (r)\r\ngoto err_disp_sysfs;\r\ndispc_runtime_get();\r\nr = dss_dispc_initialize_irq();\r\nif (r)\r\ngoto err_init_irq;\r\ndispc_runtime_put();\r\nout:\r\nmutex_unlock(&compat_init_lock);\r\nreturn 0;\r\nerr_init_irq:\r\ndispc_runtime_put();\r\ndisplay_uninit_sysfs(pdev);\r\nerr_disp_sysfs:\r\ndss_uninstall_mgr_ops();\r\nerr_mgr_ops:\r\ndss_uninit_overlay_managers_sysfs(pdev);\r\ndss_uninit_overlays(pdev);\r\ncompat_refcnt--;\r\nmutex_unlock(&compat_init_lock);\r\nreturn r;\r\n}\r\nvoid omapdss_compat_uninit(void)\r\n{\r\nstruct platform_device *pdev = dss_get_core_pdev();\r\nmutex_lock(&compat_init_lock);\r\nif (--compat_refcnt > 0)\r\ngoto out;\r\ndss_dispc_uninitialize_irq();\r\ndisplay_uninit_sysfs(pdev);\r\ndss_uninstall_mgr_ops();\r\ndss_uninit_overlay_managers_sysfs(pdev);\r\ndss_uninit_overlays(pdev);\r\nout:\r\nmutex_unlock(&compat_init_lock);\r\n}
