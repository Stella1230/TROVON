static int\r\n_scsih_set_debug_level(const char *val, struct kernel_param *kp)\r\n{\r\nint ret = param_set_int(val, kp);\r\nstruct MPT2SAS_ADAPTER *ioc;\r\nif (ret)\r\nreturn ret;\r\nprintk(KERN_INFO "setting logging_level(0x%08x)\n", logging_level);\r\nlist_for_each_entry(ioc, &mpt2sas_ioc_list, list)\r\nioc->logging_level = logging_level;\r\nreturn 0;\r\n}\r\nstatic inline int\r\n_scsih_srch_boot_sas_address(u64 sas_address,\r\nMpi2BootDeviceSasWwid_t *boot_device)\r\n{\r\nreturn (sas_address == le64_to_cpu(boot_device->SASAddress)) ? 1 : 0;\r\n}\r\nstatic inline int\r\n_scsih_srch_boot_device_name(u64 device_name,\r\nMpi2BootDeviceDeviceName_t *boot_device)\r\n{\r\nreturn (device_name == le64_to_cpu(boot_device->DeviceName)) ? 1 : 0;\r\n}\r\nstatic inline int\r\n_scsih_srch_boot_encl_slot(u64 enclosure_logical_id, u16 slot_number,\r\nMpi2BootDeviceEnclosureSlot_t *boot_device)\r\n{\r\nreturn (enclosure_logical_id == le64_to_cpu(boot_device->\r\nEnclosureLogicalID) && slot_number == le16_to_cpu(boot_device->\r\nSlotNumber)) ? 1 : 0;\r\n}\r\nstatic int\r\n_scsih_is_boot_device(u64 sas_address, u64 device_name,\r\nu64 enclosure_logical_id, u16 slot, u8 form,\r\nMpi2BiosPage2BootDevice_t *boot_device)\r\n{\r\nint rc = 0;\r\nswitch (form) {\r\ncase MPI2_BIOSPAGE2_FORM_SAS_WWID:\r\nif (!sas_address)\r\nbreak;\r\nrc = _scsih_srch_boot_sas_address(\r\nsas_address, &boot_device->SasWwid);\r\nbreak;\r\ncase MPI2_BIOSPAGE2_FORM_ENCLOSURE_SLOT:\r\nif (!enclosure_logical_id)\r\nbreak;\r\nrc = _scsih_srch_boot_encl_slot(\r\nenclosure_logical_id,\r\nslot, &boot_device->EnclosureSlot);\r\nbreak;\r\ncase MPI2_BIOSPAGE2_FORM_DEVICE_NAME:\r\nif (!device_name)\r\nbreak;\r\nrc = _scsih_srch_boot_device_name(\r\ndevice_name, &boot_device->DeviceName);\r\nbreak;\r\ncase MPI2_BIOSPAGE2_FORM_NO_DEVICE_SPECIFIED:\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\n_scsih_get_sas_address(struct MPT2SAS_ADAPTER *ioc, u16 handle,\r\nu64 *sas_address)\r\n{\r\nMpi2SasDevicePage0_t sas_device_pg0;\r\nMpi2ConfigReply_t mpi_reply;\r\nu32 ioc_status;\r\n*sas_address = 0;\r\nif (handle <= ioc->sas_hba.num_phys) {\r\n*sas_address = ioc->sas_hba.sas_address;\r\nreturn 0;\r\n}\r\nif ((mpt2sas_config_get_sas_device_pg0(ioc, &mpi_reply, &sas_device_pg0,\r\nMPI2_SAS_DEVICE_PGAD_FORM_HANDLE, handle))) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n", ioc->name,\r\n__FILE__, __LINE__, __func__);\r\nreturn -ENXIO;\r\n}\r\nioc_status = le16_to_cpu(mpi_reply.IOCStatus) & MPI2_IOCSTATUS_MASK;\r\nif (ioc_status == MPI2_IOCSTATUS_SUCCESS) {\r\n*sas_address = le64_to_cpu(sas_device_pg0.SASAddress);\r\nreturn 0;\r\n}\r\nif (ioc_status == MPI2_IOCSTATUS_CONFIG_INVALID_PAGE)\r\nreturn -ENXIO;\r\nprintk(MPT2SAS_ERR_FMT "handle(0x%04x), ioc_status(0x%04x), "\r\n"failure at %s:%d/%s()!\n", ioc->name, handle, ioc_status,\r\n__FILE__, __LINE__, __func__);\r\nreturn -EIO;\r\n}\r\nstatic void\r\n_scsih_determine_boot_device(struct MPT2SAS_ADAPTER *ioc,\r\nvoid *device, u8 is_raid)\r\n{\r\nstruct _sas_device *sas_device;\r\nstruct _raid_device *raid_device;\r\nu64 sas_address;\r\nu64 device_name;\r\nu64 enclosure_logical_id;\r\nu16 slot;\r\nif (!ioc->is_driver_loading)\r\nreturn;\r\nif (!ioc->bios_pg3.BiosVersion)\r\nreturn;\r\nif (!is_raid) {\r\nsas_device = device;\r\nsas_address = sas_device->sas_address;\r\ndevice_name = sas_device->device_name;\r\nenclosure_logical_id = sas_device->enclosure_logical_id;\r\nslot = sas_device->slot;\r\n} else {\r\nraid_device = device;\r\nsas_address = raid_device->wwid;\r\ndevice_name = 0;\r\nenclosure_logical_id = 0;\r\nslot = 0;\r\n}\r\nif (!ioc->req_boot_device.device) {\r\nif (_scsih_is_boot_device(sas_address, device_name,\r\nenclosure_logical_id, slot,\r\n(ioc->bios_pg2.ReqBootDeviceForm &\r\nMPI2_BIOSPAGE2_FORM_MASK),\r\n&ioc->bios_pg2.RequestedBootDevice)) {\r\ndinitprintk(ioc, printk(MPT2SAS_INFO_FMT\r\n"%s: req_boot_device(0x%016llx)\n",\r\nioc->name, __func__,\r\n(unsigned long long)sas_address));\r\nioc->req_boot_device.device = device;\r\nioc->req_boot_device.is_raid = is_raid;\r\n}\r\n}\r\nif (!ioc->req_alt_boot_device.device) {\r\nif (_scsih_is_boot_device(sas_address, device_name,\r\nenclosure_logical_id, slot,\r\n(ioc->bios_pg2.ReqAltBootDeviceForm &\r\nMPI2_BIOSPAGE2_FORM_MASK),\r\n&ioc->bios_pg2.RequestedAltBootDevice)) {\r\ndinitprintk(ioc, printk(MPT2SAS_INFO_FMT\r\n"%s: req_alt_boot_device(0x%016llx)\n",\r\nioc->name, __func__,\r\n(unsigned long long)sas_address));\r\nioc->req_alt_boot_device.device = device;\r\nioc->req_alt_boot_device.is_raid = is_raid;\r\n}\r\n}\r\nif (!ioc->current_boot_device.device) {\r\nif (_scsih_is_boot_device(sas_address, device_name,\r\nenclosure_logical_id, slot,\r\n(ioc->bios_pg2.CurrentBootDeviceForm &\r\nMPI2_BIOSPAGE2_FORM_MASK),\r\n&ioc->bios_pg2.CurrentBootDevice)) {\r\ndinitprintk(ioc, printk(MPT2SAS_INFO_FMT\r\n"%s: current_boot_device(0x%016llx)\n",\r\nioc->name, __func__,\r\n(unsigned long long)sas_address));\r\nioc->current_boot_device.device = device;\r\nioc->current_boot_device.is_raid = is_raid;\r\n}\r\n}\r\n}\r\nstruct _sas_device *\r\nmpt2sas_scsih_sas_device_find_by_sas_address(struct MPT2SAS_ADAPTER *ioc,\r\nu64 sas_address)\r\n{\r\nstruct _sas_device *sas_device;\r\nlist_for_each_entry(sas_device, &ioc->sas_device_list, list)\r\nif (sas_device->sas_address == sas_address)\r\nreturn sas_device;\r\nlist_for_each_entry(sas_device, &ioc->sas_device_init_list, list)\r\nif (sas_device->sas_address == sas_address)\r\nreturn sas_device;\r\nreturn NULL;\r\n}\r\nstatic struct _sas_device *\r\n_scsih_sas_device_find_by_handle(struct MPT2SAS_ADAPTER *ioc, u16 handle)\r\n{\r\nstruct _sas_device *sas_device;\r\nlist_for_each_entry(sas_device, &ioc->sas_device_list, list)\r\nif (sas_device->handle == handle)\r\nreturn sas_device;\r\nlist_for_each_entry(sas_device, &ioc->sas_device_init_list, list)\r\nif (sas_device->handle == handle)\r\nreturn sas_device;\r\nreturn NULL;\r\n}\r\nstatic void\r\n_scsih_sas_device_remove(struct MPT2SAS_ADAPTER *ioc,\r\nstruct _sas_device *sas_device)\r\n{\r\nunsigned long flags;\r\nif (!sas_device)\r\nreturn;\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nlist_del(&sas_device->list);\r\nkfree(sas_device);\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\n}\r\nstatic void\r\n_scsih_sas_device_add(struct MPT2SAS_ADAPTER *ioc,\r\nstruct _sas_device *sas_device)\r\n{\r\nunsigned long flags;\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: handle"\r\n"(0x%04x), sas_addr(0x%016llx)\n", ioc->name, __func__,\r\nsas_device->handle, (unsigned long long)sas_device->sas_address));\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nlist_add_tail(&sas_device->list, &ioc->sas_device_list);\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\nif (!mpt2sas_transport_port_add(ioc, sas_device->handle,\r\nsas_device->sas_address_parent)) {\r\n_scsih_sas_device_remove(ioc, sas_device);\r\n} else if (!sas_device->starget) {\r\nif (!ioc->is_driver_loading) {\r\nmpt2sas_transport_port_remove(ioc,\r\nsas_device->sas_address,\r\nsas_device->sas_address_parent);\r\n_scsih_sas_device_remove(ioc, sas_device);\r\n}\r\n}\r\n}\r\nstatic void\r\n_scsih_sas_device_init_add(struct MPT2SAS_ADAPTER *ioc,\r\nstruct _sas_device *sas_device)\r\n{\r\nunsigned long flags;\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: handle"\r\n"(0x%04x), sas_addr(0x%016llx)\n", ioc->name, __func__,\r\nsas_device->handle, (unsigned long long)sas_device->sas_address));\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nlist_add_tail(&sas_device->list, &ioc->sas_device_init_list);\r\n_scsih_determine_boot_device(ioc, sas_device, 0);\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\n}\r\nstatic struct _raid_device *\r\n_scsih_raid_device_find_by_id(struct MPT2SAS_ADAPTER *ioc, int id, int channel)\r\n{\r\nstruct _raid_device *raid_device, *r;\r\nr = NULL;\r\nlist_for_each_entry(raid_device, &ioc->raid_device_list, list) {\r\nif (raid_device->id == id && raid_device->channel == channel) {\r\nr = raid_device;\r\ngoto out;\r\n}\r\n}\r\nout:\r\nreturn r;\r\n}\r\nstatic struct _raid_device *\r\n_scsih_raid_device_find_by_handle(struct MPT2SAS_ADAPTER *ioc, u16 handle)\r\n{\r\nstruct _raid_device *raid_device, *r;\r\nr = NULL;\r\nlist_for_each_entry(raid_device, &ioc->raid_device_list, list) {\r\nif (raid_device->handle != handle)\r\ncontinue;\r\nr = raid_device;\r\ngoto out;\r\n}\r\nout:\r\nreturn r;\r\n}\r\nstatic struct _raid_device *\r\n_scsih_raid_device_find_by_wwid(struct MPT2SAS_ADAPTER *ioc, u64 wwid)\r\n{\r\nstruct _raid_device *raid_device, *r;\r\nr = NULL;\r\nlist_for_each_entry(raid_device, &ioc->raid_device_list, list) {\r\nif (raid_device->wwid != wwid)\r\ncontinue;\r\nr = raid_device;\r\ngoto out;\r\n}\r\nout:\r\nreturn r;\r\n}\r\nstatic void\r\n_scsih_raid_device_add(struct MPT2SAS_ADAPTER *ioc,\r\nstruct _raid_device *raid_device)\r\n{\r\nunsigned long flags;\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: handle"\r\n"(0x%04x), wwid(0x%016llx)\n", ioc->name, __func__,\r\nraid_device->handle, (unsigned long long)raid_device->wwid));\r\nspin_lock_irqsave(&ioc->raid_device_lock, flags);\r\nlist_add_tail(&raid_device->list, &ioc->raid_device_list);\r\nspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\r\n}\r\nstatic void\r\n_scsih_raid_device_remove(struct MPT2SAS_ADAPTER *ioc,\r\nstruct _raid_device *raid_device)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ioc->raid_device_lock, flags);\r\nlist_del(&raid_device->list);\r\nkfree(raid_device);\r\nspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\r\n}\r\nstruct _sas_node *\r\nmpt2sas_scsih_expander_find_by_handle(struct MPT2SAS_ADAPTER *ioc, u16 handle)\r\n{\r\nstruct _sas_node *sas_expander, *r;\r\nr = NULL;\r\nlist_for_each_entry(sas_expander, &ioc->sas_expander_list, list) {\r\nif (sas_expander->handle != handle)\r\ncontinue;\r\nr = sas_expander;\r\ngoto out;\r\n}\r\nout:\r\nreturn r;\r\n}\r\nstruct _sas_node *\r\nmpt2sas_scsih_expander_find_by_sas_address(struct MPT2SAS_ADAPTER *ioc,\r\nu64 sas_address)\r\n{\r\nstruct _sas_node *sas_expander, *r;\r\nr = NULL;\r\nlist_for_each_entry(sas_expander, &ioc->sas_expander_list, list) {\r\nif (sas_expander->sas_address != sas_address)\r\ncontinue;\r\nr = sas_expander;\r\ngoto out;\r\n}\r\nout:\r\nreturn r;\r\n}\r\nstatic void\r\n_scsih_expander_node_add(struct MPT2SAS_ADAPTER *ioc,\r\nstruct _sas_node *sas_expander)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ioc->sas_node_lock, flags);\r\nlist_add_tail(&sas_expander->list, &ioc->sas_expander_list);\r\nspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\r\n}\r\nstatic int\r\n_scsih_is_end_device(u32 device_info)\r\n{\r\nif (device_info & MPI2_SAS_DEVICE_INFO_END_DEVICE &&\r\n((device_info & MPI2_SAS_DEVICE_INFO_SSP_TARGET) |\r\n(device_info & MPI2_SAS_DEVICE_INFO_STP_TARGET) |\r\n(device_info & MPI2_SAS_DEVICE_INFO_SATA_DEVICE)))\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic struct scsi_cmnd *\r\n_scsih_scsi_lookup_get(struct MPT2SAS_ADAPTER *ioc, u16 smid)\r\n{\r\nreturn ioc->scsi_lookup[smid - 1].scmd;\r\n}\r\nstatic inline struct scsi_cmnd *\r\n_scsih_scsi_lookup_get_clear(struct MPT2SAS_ADAPTER *ioc, u16 smid)\r\n{\r\nunsigned long flags;\r\nstruct scsi_cmnd *scmd;\r\nspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\r\nscmd = ioc->scsi_lookup[smid - 1].scmd;\r\nioc->scsi_lookup[smid - 1].scmd = NULL;\r\nspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\r\nreturn scmd;\r\n}\r\nstatic u16\r\n_scsih_scsi_lookup_find_by_scmd(struct MPT2SAS_ADAPTER *ioc, struct scsi_cmnd\r\n*scmd)\r\n{\r\nu16 smid;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\r\nsmid = 0;\r\nfor (i = 0; i < ioc->scsiio_depth; i++) {\r\nif (ioc->scsi_lookup[i].scmd == scmd) {\r\nsmid = ioc->scsi_lookup[i].smid;\r\ngoto out;\r\n}\r\n}\r\nout:\r\nspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\r\nreturn smid;\r\n}\r\nstatic u8\r\n_scsih_scsi_lookup_find_by_target(struct MPT2SAS_ADAPTER *ioc, int id,\r\nint channel)\r\n{\r\nu8 found;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\r\nfound = 0;\r\nfor (i = 0 ; i < ioc->scsiio_depth; i++) {\r\nif (ioc->scsi_lookup[i].scmd &&\r\n(ioc->scsi_lookup[i].scmd->device->id == id &&\r\nioc->scsi_lookup[i].scmd->device->channel == channel)) {\r\nfound = 1;\r\ngoto out;\r\n}\r\n}\r\nout:\r\nspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\r\nreturn found;\r\n}\r\nstatic u8\r\n_scsih_scsi_lookup_find_by_lun(struct MPT2SAS_ADAPTER *ioc, int id,\r\nunsigned int lun, int channel)\r\n{\r\nu8 found;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\r\nfound = 0;\r\nfor (i = 0 ; i < ioc->scsiio_depth; i++) {\r\nif (ioc->scsi_lookup[i].scmd &&\r\n(ioc->scsi_lookup[i].scmd->device->id == id &&\r\nioc->scsi_lookup[i].scmd->device->channel == channel &&\r\nioc->scsi_lookup[i].scmd->device->lun == lun)) {\r\nfound = 1;\r\ngoto out;\r\n}\r\n}\r\nout:\r\nspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\r\nreturn found;\r\n}\r\nstatic struct chain_tracker *\r\n_scsih_get_chain_buffer_tracker(struct MPT2SAS_ADAPTER *ioc, u16 smid)\r\n{\r\nstruct chain_tracker *chain_req;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\r\nif (list_empty(&ioc->free_chain_list)) {\r\nspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\r\ndfailprintk(ioc, printk(MPT2SAS_WARN_FMT "chain buffers not "\r\n"available\n", ioc->name));\r\nreturn NULL;\r\n}\r\nchain_req = list_entry(ioc->free_chain_list.next,\r\nstruct chain_tracker, tracker_list);\r\nlist_del_init(&chain_req->tracker_list);\r\nlist_add_tail(&chain_req->tracker_list,\r\n&ioc->scsi_lookup[smid - 1].chain_list);\r\nspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\r\nreturn chain_req;\r\n}\r\nstatic int\r\n_scsih_build_scatter_gather(struct MPT2SAS_ADAPTER *ioc,\r\nstruct scsi_cmnd *scmd, u16 smid)\r\n{\r\nMpi2SCSIIORequest_t *mpi_request;\r\ndma_addr_t chain_dma;\r\nstruct scatterlist *sg_scmd;\r\nvoid *sg_local, *chain;\r\nu32 chain_offset;\r\nu32 chain_length;\r\nu32 chain_flags;\r\nint sges_left;\r\nu32 sges_in_segment;\r\nu32 sgl_flags;\r\nu32 sgl_flags_last_element;\r\nu32 sgl_flags_end_buffer;\r\nstruct chain_tracker *chain_req;\r\nmpi_request = mpt2sas_base_get_msg_frame(ioc, smid);\r\nsgl_flags = MPI2_SGE_FLAGS_SIMPLE_ELEMENT;\r\nif (scmd->sc_data_direction == DMA_TO_DEVICE)\r\nsgl_flags |= MPI2_SGE_FLAGS_HOST_TO_IOC;\r\nsgl_flags_last_element = (sgl_flags | MPI2_SGE_FLAGS_LAST_ELEMENT)\r\n<< MPI2_SGE_FLAGS_SHIFT;\r\nsgl_flags_end_buffer = (sgl_flags | MPI2_SGE_FLAGS_LAST_ELEMENT |\r\nMPI2_SGE_FLAGS_END_OF_BUFFER | MPI2_SGE_FLAGS_END_OF_LIST)\r\n<< MPI2_SGE_FLAGS_SHIFT;\r\nsgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;\r\nsg_scmd = scsi_sglist(scmd);\r\nsges_left = scsi_dma_map(scmd);\r\nif (sges_left < 0) {\r\nsdev_printk(KERN_ERR, scmd->device, "pci_map_sg"\r\n" failed: request for %d bytes!\n", scsi_bufflen(scmd));\r\nreturn -ENOMEM;\r\n}\r\nsg_local = &mpi_request->SGL;\r\nsges_in_segment = ioc->max_sges_in_main_message;\r\nif (sges_left <= sges_in_segment)\r\ngoto fill_in_last_segment;\r\nmpi_request->ChainOffset = (offsetof(Mpi2SCSIIORequest_t, SGL) +\r\n(sges_in_segment * ioc->sge_size))/4;\r\nwhile (sges_in_segment) {\r\nif (sges_in_segment == 1)\r\nioc->base_add_sg_single(sg_local,\r\nsgl_flags_last_element | sg_dma_len(sg_scmd),\r\nsg_dma_address(sg_scmd));\r\nelse\r\nioc->base_add_sg_single(sg_local, sgl_flags |\r\nsg_dma_len(sg_scmd), sg_dma_address(sg_scmd));\r\nsg_scmd = sg_next(sg_scmd);\r\nsg_local += ioc->sge_size;\r\nsges_left--;\r\nsges_in_segment--;\r\n}\r\nchain_flags = MPI2_SGE_FLAGS_CHAIN_ELEMENT << MPI2_SGE_FLAGS_SHIFT;\r\nchain_req = _scsih_get_chain_buffer_tracker(ioc, smid);\r\nif (!chain_req)\r\nreturn -1;\r\nchain = chain_req->chain_buffer;\r\nchain_dma = chain_req->chain_buffer_dma;\r\ndo {\r\nsges_in_segment = (sges_left <=\r\nioc->max_sges_in_chain_message) ? sges_left :\r\nioc->max_sges_in_chain_message;\r\nchain_offset = (sges_left == sges_in_segment) ?\r\n0 : (sges_in_segment * ioc->sge_size)/4;\r\nchain_length = sges_in_segment * ioc->sge_size;\r\nif (chain_offset) {\r\nchain_offset = chain_offset <<\r\nMPI2_SGE_CHAIN_OFFSET_SHIFT;\r\nchain_length += ioc->sge_size;\r\n}\r\nioc->base_add_sg_single(sg_local, chain_flags | chain_offset |\r\nchain_length, chain_dma);\r\nsg_local = chain;\r\nif (!chain_offset)\r\ngoto fill_in_last_segment;\r\nwhile (sges_in_segment) {\r\nif (sges_in_segment == 1)\r\nioc->base_add_sg_single(sg_local,\r\nsgl_flags_last_element |\r\nsg_dma_len(sg_scmd),\r\nsg_dma_address(sg_scmd));\r\nelse\r\nioc->base_add_sg_single(sg_local, sgl_flags |\r\nsg_dma_len(sg_scmd),\r\nsg_dma_address(sg_scmd));\r\nsg_scmd = sg_next(sg_scmd);\r\nsg_local += ioc->sge_size;\r\nsges_left--;\r\nsges_in_segment--;\r\n}\r\nchain_req = _scsih_get_chain_buffer_tracker(ioc, smid);\r\nif (!chain_req)\r\nreturn -1;\r\nchain = chain_req->chain_buffer;\r\nchain_dma = chain_req->chain_buffer_dma;\r\n} while (1);\r\nfill_in_last_segment:\r\nwhile (sges_left) {\r\nif (sges_left == 1)\r\nioc->base_add_sg_single(sg_local, sgl_flags_end_buffer |\r\nsg_dma_len(sg_scmd), sg_dma_address(sg_scmd));\r\nelse\r\nioc->base_add_sg_single(sg_local, sgl_flags |\r\nsg_dma_len(sg_scmd), sg_dma_address(sg_scmd));\r\nsg_scmd = sg_next(sg_scmd);\r\nsg_local += ioc->sge_size;\r\nsges_left--;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\n_scsih_change_queue_depth(struct scsi_device *sdev, int qdepth)\r\n{\r\nstruct Scsi_Host *shost = sdev->host;\r\nint max_depth;\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nstruct MPT2SAS_DEVICE *sas_device_priv_data;\r\nstruct MPT2SAS_TARGET *sas_target_priv_data;\r\nstruct _sas_device *sas_device;\r\nunsigned long flags;\r\nmax_depth = shost->can_queue;\r\nsas_device_priv_data = sdev->hostdata;\r\nif (!sas_device_priv_data)\r\ngoto not_sata;\r\nsas_target_priv_data = sas_device_priv_data->sas_target;\r\nif (!sas_target_priv_data)\r\ngoto not_sata;\r\nif ((sas_target_priv_data->flags & MPT_TARGET_FLAGS_VOLUME))\r\ngoto not_sata;\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nsas_device = mpt2sas_scsih_sas_device_find_by_sas_address(ioc,\r\nsas_device_priv_data->sas_target->sas_address);\r\nif (sas_device && sas_device->device_info &\r\nMPI2_SAS_DEVICE_INFO_SATA_DEVICE)\r\nmax_depth = MPT2SAS_SATA_QUEUE_DEPTH;\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\nnot_sata:\r\nif (!sdev->tagged_supported)\r\nmax_depth = 1;\r\nif (qdepth > max_depth)\r\nqdepth = max_depth;\r\nreturn scsi_change_queue_depth(sdev, qdepth);\r\n}\r\nstatic int\r\n_scsih_target_alloc(struct scsi_target *starget)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(&starget->dev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nstruct MPT2SAS_TARGET *sas_target_priv_data;\r\nstruct _sas_device *sas_device;\r\nstruct _raid_device *raid_device;\r\nunsigned long flags;\r\nstruct sas_rphy *rphy;\r\nsas_target_priv_data = kzalloc(sizeof(*sas_target_priv_data),\r\nGFP_KERNEL);\r\nif (!sas_target_priv_data)\r\nreturn -ENOMEM;\r\nstarget->hostdata = sas_target_priv_data;\r\nsas_target_priv_data->starget = starget;\r\nsas_target_priv_data->handle = MPT2SAS_INVALID_DEVICE_HANDLE;\r\nif (starget->channel == RAID_CHANNEL) {\r\nspin_lock_irqsave(&ioc->raid_device_lock, flags);\r\nraid_device = _scsih_raid_device_find_by_id(ioc, starget->id,\r\nstarget->channel);\r\nif (raid_device) {\r\nsas_target_priv_data->handle = raid_device->handle;\r\nsas_target_priv_data->sas_address = raid_device->wwid;\r\nsas_target_priv_data->flags |= MPT_TARGET_FLAGS_VOLUME;\r\nif (ioc->is_warpdrive)\r\nsas_target_priv_data->raid_device = raid_device;\r\nraid_device->starget = starget;\r\n}\r\nspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\r\nreturn 0;\r\n}\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nrphy = dev_to_rphy(starget->dev.parent);\r\nsas_device = mpt2sas_scsih_sas_device_find_by_sas_address(ioc,\r\nrphy->identify.sas_address);\r\nif (sas_device) {\r\nsas_target_priv_data->handle = sas_device->handle;\r\nsas_target_priv_data->sas_address = sas_device->sas_address;\r\nsas_device->starget = starget;\r\nsas_device->id = starget->id;\r\nsas_device->channel = starget->channel;\r\nif (test_bit(sas_device->handle, ioc->pd_handles))\r\nsas_target_priv_data->flags |=\r\nMPT_TARGET_FLAGS_RAID_COMPONENT;\r\n}\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void\r\n_scsih_target_destroy(struct scsi_target *starget)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(&starget->dev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nstruct MPT2SAS_TARGET *sas_target_priv_data;\r\nstruct _sas_device *sas_device;\r\nstruct _raid_device *raid_device;\r\nunsigned long flags;\r\nstruct sas_rphy *rphy;\r\nsas_target_priv_data = starget->hostdata;\r\nif (!sas_target_priv_data)\r\nreturn;\r\nif (starget->channel == RAID_CHANNEL) {\r\nspin_lock_irqsave(&ioc->raid_device_lock, flags);\r\nraid_device = _scsih_raid_device_find_by_id(ioc, starget->id,\r\nstarget->channel);\r\nif (raid_device) {\r\nraid_device->starget = NULL;\r\nraid_device->sdev = NULL;\r\n}\r\nspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\r\ngoto out;\r\n}\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nrphy = dev_to_rphy(starget->dev.parent);\r\nsas_device = mpt2sas_scsih_sas_device_find_by_sas_address(ioc,\r\nrphy->identify.sas_address);\r\nif (sas_device && (sas_device->starget == starget) &&\r\n(sas_device->id == starget->id) &&\r\n(sas_device->channel == starget->channel))\r\nsas_device->starget = NULL;\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\nout:\r\nkfree(sas_target_priv_data);\r\nstarget->hostdata = NULL;\r\n}\r\nstatic int\r\n_scsih_slave_alloc(struct scsi_device *sdev)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct MPT2SAS_ADAPTER *ioc;\r\nstruct MPT2SAS_TARGET *sas_target_priv_data;\r\nstruct MPT2SAS_DEVICE *sas_device_priv_data;\r\nstruct scsi_target *starget;\r\nstruct _raid_device *raid_device;\r\nstruct _sas_device *sas_device;\r\nunsigned long flags;\r\nsas_device_priv_data = kzalloc(sizeof(*sas_device_priv_data),\r\nGFP_KERNEL);\r\nif (!sas_device_priv_data)\r\nreturn -ENOMEM;\r\nsas_device_priv_data->lun = sdev->lun;\r\nsas_device_priv_data->flags = MPT_DEVICE_FLAGS_INIT;\r\nstarget = scsi_target(sdev);\r\nsas_target_priv_data = starget->hostdata;\r\nsas_target_priv_data->num_luns++;\r\nsas_device_priv_data->sas_target = sas_target_priv_data;\r\nsdev->hostdata = sas_device_priv_data;\r\nif ((sas_target_priv_data->flags & MPT_TARGET_FLAGS_RAID_COMPONENT))\r\nsdev->no_uld_attach = 1;\r\nshost = dev_to_shost(&starget->dev);\r\nioc = shost_priv(shost);\r\nif (starget->channel == RAID_CHANNEL) {\r\nspin_lock_irqsave(&ioc->raid_device_lock, flags);\r\nraid_device = _scsih_raid_device_find_by_id(ioc,\r\nstarget->id, starget->channel);\r\nif (raid_device)\r\nraid_device->sdev = sdev;\r\nspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\r\n}\r\nif (!(sas_target_priv_data->flags & MPT_TARGET_FLAGS_VOLUME)) {\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nsas_device = mpt2sas_scsih_sas_device_find_by_sas_address(ioc,\r\nsas_target_priv_data->sas_address);\r\nif (sas_device && (sas_device->starget == NULL)) {\r\nsdev_printk(KERN_INFO, sdev,\r\n"%s : sas_device->starget set to starget @ %d\n",\r\n__func__, __LINE__);\r\nsas_device->starget = starget;\r\n}\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\n_scsih_slave_destroy(struct scsi_device *sdev)\r\n{\r\nstruct MPT2SAS_TARGET *sas_target_priv_data;\r\nstruct scsi_target *starget;\r\nstruct Scsi_Host *shost;\r\nstruct MPT2SAS_ADAPTER *ioc;\r\nstruct _sas_device *sas_device;\r\nunsigned long flags;\r\nif (!sdev->hostdata)\r\nreturn;\r\nstarget = scsi_target(sdev);\r\nsas_target_priv_data = starget->hostdata;\r\nsas_target_priv_data->num_luns--;\r\nshost = dev_to_shost(&starget->dev);\r\nioc = shost_priv(shost);\r\nif (!(sas_target_priv_data->flags & MPT_TARGET_FLAGS_VOLUME)) {\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nsas_device = mpt2sas_scsih_sas_device_find_by_sas_address(ioc,\r\nsas_target_priv_data->sas_address);\r\nif (sas_device && !sas_target_priv_data->num_luns)\r\nsas_device->starget = NULL;\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\n}\r\nkfree(sdev->hostdata);\r\nsdev->hostdata = NULL;\r\n}\r\nstatic void\r\n_scsih_display_sata_capabilities(struct MPT2SAS_ADAPTER *ioc,\r\nu16 handle, struct scsi_device *sdev)\r\n{\r\nMpi2ConfigReply_t mpi_reply;\r\nMpi2SasDevicePage0_t sas_device_pg0;\r\nu32 ioc_status;\r\nu16 flags;\r\nu32 device_info;\r\nif ((mpt2sas_config_get_sas_device_pg0(ioc, &mpi_reply, &sas_device_pg0,\r\nMPI2_SAS_DEVICE_PGAD_FORM_HANDLE, handle))) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn;\r\n}\r\nioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\r\nMPI2_IOCSTATUS_MASK;\r\nif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn;\r\n}\r\nflags = le16_to_cpu(sas_device_pg0.Flags);\r\ndevice_info = le32_to_cpu(sas_device_pg0.DeviceInfo);\r\nsdev_printk(KERN_INFO, sdev,\r\n"atapi(%s), ncq(%s), asyn_notify(%s), smart(%s), fua(%s), "\r\n"sw_preserve(%s)\n",\r\n(device_info & MPI2_SAS_DEVICE_INFO_ATAPI_DEVICE) ? "y" : "n",\r\n(flags & MPI2_SAS_DEVICE0_FLAGS_SATA_NCQ_SUPPORTED) ? "y" : "n",\r\n(flags & MPI2_SAS_DEVICE0_FLAGS_SATA_ASYNCHRONOUS_NOTIFY) ? "y" :\r\n"n",\r\n(flags & MPI2_SAS_DEVICE0_FLAGS_SATA_SMART_SUPPORTED) ? "y" : "n",\r\n(flags & MPI2_SAS_DEVICE0_FLAGS_SATA_FUA_SUPPORTED) ? "y" : "n",\r\n(flags & MPI2_SAS_DEVICE0_FLAGS_SATA_SW_PRESERVE) ? "y" : "n");\r\n}\r\nstatic int\r\n_scsih_is_raid(struct device *dev)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(sdev->host);\r\nif (ioc->is_warpdrive)\r\nreturn 0;\r\nreturn (sdev->channel == RAID_CHANNEL) ? 1 : 0;\r\n}\r\nstatic void\r\n_scsih_get_resync(struct device *dev)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(sdev->host);\r\nstatic struct _raid_device *raid_device;\r\nunsigned long flags;\r\nMpi2RaidVolPage0_t vol_pg0;\r\nMpi2ConfigReply_t mpi_reply;\r\nu32 volume_status_flags;\r\nu8 percent_complete;\r\nu16 handle;\r\npercent_complete = 0;\r\nhandle = 0;\r\nif (ioc->is_warpdrive)\r\ngoto out;\r\nspin_lock_irqsave(&ioc->raid_device_lock, flags);\r\nraid_device = _scsih_raid_device_find_by_id(ioc, sdev->id,\r\nsdev->channel);\r\nif (raid_device) {\r\nhandle = raid_device->handle;\r\npercent_complete = raid_device->percent_complete;\r\n}\r\nspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\r\nif (!handle)\r\ngoto out;\r\nif (mpt2sas_config_get_raid_volume_pg0(ioc, &mpi_reply, &vol_pg0,\r\nMPI2_RAID_VOLUME_PGAD_FORM_HANDLE, handle,\r\nsizeof(Mpi2RaidVolPage0_t))) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\npercent_complete = 0;\r\ngoto out;\r\n}\r\nvolume_status_flags = le32_to_cpu(vol_pg0.VolumeStatusFlags);\r\nif (!(volume_status_flags &\r\nMPI2_RAIDVOL0_STATUS_FLAG_RESYNC_IN_PROGRESS))\r\npercent_complete = 0;\r\nout:\r\nraid_set_resync(mpt2sas_raid_template, dev, percent_complete);\r\n}\r\nstatic void\r\n_scsih_get_state(struct device *dev)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(sdev->host);\r\nstatic struct _raid_device *raid_device;\r\nunsigned long flags;\r\nMpi2RaidVolPage0_t vol_pg0;\r\nMpi2ConfigReply_t mpi_reply;\r\nu32 volstate;\r\nenum raid_state state = RAID_STATE_UNKNOWN;\r\nu16 handle = 0;\r\nspin_lock_irqsave(&ioc->raid_device_lock, flags);\r\nraid_device = _scsih_raid_device_find_by_id(ioc, sdev->id,\r\nsdev->channel);\r\nif (raid_device)\r\nhandle = raid_device->handle;\r\nspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\r\nif (!raid_device)\r\ngoto out;\r\nif (mpt2sas_config_get_raid_volume_pg0(ioc, &mpi_reply, &vol_pg0,\r\nMPI2_RAID_VOLUME_PGAD_FORM_HANDLE, handle,\r\nsizeof(Mpi2RaidVolPage0_t))) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\ngoto out;\r\n}\r\nvolstate = le32_to_cpu(vol_pg0.VolumeStatusFlags);\r\nif (volstate & MPI2_RAIDVOL0_STATUS_FLAG_RESYNC_IN_PROGRESS) {\r\nstate = RAID_STATE_RESYNCING;\r\ngoto out;\r\n}\r\nswitch (vol_pg0.VolumeState) {\r\ncase MPI2_RAID_VOL_STATE_OPTIMAL:\r\ncase MPI2_RAID_VOL_STATE_ONLINE:\r\nstate = RAID_STATE_ACTIVE;\r\nbreak;\r\ncase MPI2_RAID_VOL_STATE_DEGRADED:\r\nstate = RAID_STATE_DEGRADED;\r\nbreak;\r\ncase MPI2_RAID_VOL_STATE_FAILED:\r\ncase MPI2_RAID_VOL_STATE_MISSING:\r\nstate = RAID_STATE_OFFLINE;\r\nbreak;\r\n}\r\nout:\r\nraid_set_state(mpt2sas_raid_template, dev, state);\r\n}\r\nstatic void\r\n_scsih_set_level(struct scsi_device *sdev, u8 volume_type)\r\n{\r\nenum raid_level level = RAID_LEVEL_UNKNOWN;\r\nswitch (volume_type) {\r\ncase MPI2_RAID_VOL_TYPE_RAID0:\r\nlevel = RAID_LEVEL_0;\r\nbreak;\r\ncase MPI2_RAID_VOL_TYPE_RAID10:\r\nlevel = RAID_LEVEL_10;\r\nbreak;\r\ncase MPI2_RAID_VOL_TYPE_RAID1E:\r\nlevel = RAID_LEVEL_1E;\r\nbreak;\r\ncase MPI2_RAID_VOL_TYPE_RAID1:\r\nlevel = RAID_LEVEL_1;\r\nbreak;\r\n}\r\nraid_set_level(mpt2sas_raid_template, &sdev->sdev_gendev, level);\r\n}\r\nstatic int\r\n_scsih_get_volume_capabilities(struct MPT2SAS_ADAPTER *ioc,\r\nstruct _raid_device *raid_device)\r\n{\r\nMpi2RaidVolPage0_t *vol_pg0;\r\nMpi2RaidPhysDiskPage0_t pd_pg0;\r\nMpi2SasDevicePage0_t sas_device_pg0;\r\nMpi2ConfigReply_t mpi_reply;\r\nu16 sz;\r\nu8 num_pds;\r\nif ((mpt2sas_config_get_number_pds(ioc, raid_device->handle,\r\n&num_pds)) || !num_pds) {\r\ndfailprintk(ioc, printk(MPT2SAS_WARN_FMT\r\n"failure at %s:%d/%s()!\n", ioc->name, __FILE__, __LINE__,\r\n__func__));\r\nreturn 1;\r\n}\r\nraid_device->num_pds = num_pds;\r\nsz = offsetof(Mpi2RaidVolPage0_t, PhysDisk) + (num_pds *\r\nsizeof(Mpi2RaidVol0PhysDisk_t));\r\nvol_pg0 = kzalloc(sz, GFP_KERNEL);\r\nif (!vol_pg0) {\r\ndfailprintk(ioc, printk(MPT2SAS_WARN_FMT\r\n"failure at %s:%d/%s()!\n", ioc->name, __FILE__, __LINE__,\r\n__func__));\r\nreturn 1;\r\n}\r\nif ((mpt2sas_config_get_raid_volume_pg0(ioc, &mpi_reply, vol_pg0,\r\nMPI2_RAID_VOLUME_PGAD_FORM_HANDLE, raid_device->handle, sz))) {\r\ndfailprintk(ioc, printk(MPT2SAS_WARN_FMT\r\n"failure at %s:%d/%s()!\n", ioc->name, __FILE__, __LINE__,\r\n__func__));\r\nkfree(vol_pg0);\r\nreturn 1;\r\n}\r\nraid_device->volume_type = vol_pg0->VolumeType;\r\nif (!(mpt2sas_config_get_phys_disk_pg0(ioc, &mpi_reply,\r\n&pd_pg0, MPI2_PHYSDISK_PGAD_FORM_PHYSDISKNUM,\r\nvol_pg0->PhysDisk[0].PhysDiskNum))) {\r\nif (!(mpt2sas_config_get_sas_device_pg0(ioc, &mpi_reply,\r\n&sas_device_pg0, MPI2_SAS_DEVICE_PGAD_FORM_HANDLE,\r\nle16_to_cpu(pd_pg0.DevHandle)))) {\r\nraid_device->device_info =\r\nle32_to_cpu(sas_device_pg0.DeviceInfo);\r\n}\r\n}\r\nkfree(vol_pg0);\r\nreturn 0;\r\n}\r\nstatic void\r\n_scsih_disable_ddio(struct MPT2SAS_ADAPTER *ioc)\r\n{\r\nMpi2RaidVolPage1_t vol_pg1;\r\nMpi2ConfigReply_t mpi_reply;\r\nstruct _raid_device *raid_device;\r\nu16 handle;\r\nu16 ioc_status;\r\nunsigned long flags;\r\nhandle = 0xFFFF;\r\nwhile (!(mpt2sas_config_get_raid_volume_pg1(ioc, &mpi_reply,\r\n&vol_pg1, MPI2_RAID_VOLUME_PGAD_FORM_GET_NEXT_HANDLE, handle))) {\r\nioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\r\nMPI2_IOCSTATUS_MASK;\r\nif (ioc_status == MPI2_IOCSTATUS_CONFIG_INVALID_PAGE)\r\nbreak;\r\nhandle = le16_to_cpu(vol_pg1.DevHandle);\r\nspin_lock_irqsave(&ioc->raid_device_lock, flags);\r\nraid_device = _scsih_raid_device_find_by_handle(ioc, handle);\r\nif (raid_device)\r\nraid_device->direct_io_enabled = 0;\r\nspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\r\n}\r\nreturn;\r\n}\r\nstatic u8\r\n_scsih_get_num_volumes(struct MPT2SAS_ADAPTER *ioc)\r\n{\r\nMpi2RaidVolPage1_t vol_pg1;\r\nMpi2ConfigReply_t mpi_reply;\r\nu16 handle;\r\nu8 vol_cnt = 0;\r\nu16 ioc_status;\r\nhandle = 0xFFFF;\r\nwhile (!(mpt2sas_config_get_raid_volume_pg1(ioc, &mpi_reply,\r\n&vol_pg1, MPI2_RAID_VOLUME_PGAD_FORM_GET_NEXT_HANDLE, handle))) {\r\nioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\r\nMPI2_IOCSTATUS_MASK;\r\nif (ioc_status == MPI2_IOCSTATUS_CONFIG_INVALID_PAGE)\r\nbreak;\r\nvol_cnt++;\r\nhandle = le16_to_cpu(vol_pg1.DevHandle);\r\n}\r\nreturn vol_cnt;\r\n}\r\nstatic void\r\n_scsih_init_warpdrive_properties(struct MPT2SAS_ADAPTER *ioc,\r\nstruct _raid_device *raid_device)\r\n{\r\nMpi2RaidVolPage0_t *vol_pg0;\r\nMpi2RaidPhysDiskPage0_t pd_pg0;\r\nMpi2ConfigReply_t mpi_reply;\r\nu16 sz;\r\nu8 num_pds, count;\r\nunsigned long stripe_sz, block_sz;\r\nu8 stripe_exp, block_exp;\r\nu64 dev_max_lba;\r\nif (!ioc->is_warpdrive)\r\nreturn;\r\nif (ioc->mfg_pg10_hide_flag == MFG_PAGE10_EXPOSE_ALL_DISKS) {\r\nprintk(MPT2SAS_INFO_FMT "WarpDrive : Direct IO is disabled "\r\n"globally as drives are exposed\n", ioc->name);\r\nreturn;\r\n}\r\nif (_scsih_get_num_volumes(ioc) > 1) {\r\n_scsih_disable_ddio(ioc);\r\nprintk(MPT2SAS_INFO_FMT "WarpDrive : Direct IO is disabled "\r\n"globally as number of drives > 1\n", ioc->name);\r\nreturn;\r\n}\r\nif ((mpt2sas_config_get_number_pds(ioc, raid_device->handle,\r\n&num_pds)) || !num_pds) {\r\nprintk(MPT2SAS_INFO_FMT "WarpDrive : Direct IO is disabled "\r\n"Failure in computing number of drives\n", ioc->name);\r\nreturn;\r\n}\r\nsz = offsetof(Mpi2RaidVolPage0_t, PhysDisk) + (num_pds *\r\nsizeof(Mpi2RaidVol0PhysDisk_t));\r\nvol_pg0 = kzalloc(sz, GFP_KERNEL);\r\nif (!vol_pg0) {\r\nprintk(MPT2SAS_INFO_FMT "WarpDrive : Direct IO is disabled "\r\n"Memory allocation failure for RVPG0\n", ioc->name);\r\nreturn;\r\n}\r\nif ((mpt2sas_config_get_raid_volume_pg0(ioc, &mpi_reply, vol_pg0,\r\nMPI2_RAID_VOLUME_PGAD_FORM_HANDLE, raid_device->handle, sz))) {\r\nprintk(MPT2SAS_INFO_FMT "WarpDrive : Direct IO is disabled "\r\n"Failure in retrieving RVPG0\n", ioc->name);\r\nkfree(vol_pg0);\r\nreturn;\r\n}\r\nif (num_pds > MPT_MAX_WARPDRIVE_PDS) {\r\nprintk(MPT2SAS_WARN_FMT "WarpDrive : Direct IO is disabled "\r\n"for the drive with handle(0x%04x): num_mem=%d, "\r\n"max_mem_allowed=%d\n", ioc->name, raid_device->handle,\r\nnum_pds, MPT_MAX_WARPDRIVE_PDS);\r\nkfree(vol_pg0);\r\nreturn;\r\n}\r\nfor (count = 0; count < num_pds; count++) {\r\nif (mpt2sas_config_get_phys_disk_pg0(ioc, &mpi_reply,\r\n&pd_pg0, MPI2_PHYSDISK_PGAD_FORM_PHYSDISKNUM,\r\nvol_pg0->PhysDisk[count].PhysDiskNum) ||\r\nle16_to_cpu(pd_pg0.DevHandle) ==\r\nMPT2SAS_INVALID_DEVICE_HANDLE) {\r\nprintk(MPT2SAS_INFO_FMT "WarpDrive : Direct IO is "\r\n"disabled for the drive with handle(0x%04x) member"\r\n"handle retrieval failed for member number=%d\n",\r\nioc->name, raid_device->handle,\r\nvol_pg0->PhysDisk[count].PhysDiskNum);\r\ngoto out_error;\r\n}\r\ndev_max_lba = le64_to_cpu(pd_pg0.DeviceMaxLBA);\r\nif (dev_max_lba >> 32) {\r\nprintk(MPT2SAS_INFO_FMT "WarpDrive : Direct IO is "\r\n"disabled for the drive with handle(0x%04x) member"\r\n"handle (0x%04x) unsupported max lba 0x%016llx\n",\r\nioc->name, raid_device->handle,\r\nle16_to_cpu(pd_pg0.DevHandle),\r\n(unsigned long long)dev_max_lba);\r\ngoto out_error;\r\n}\r\nraid_device->pd_handle[count] = le16_to_cpu(pd_pg0.DevHandle);\r\n}\r\nif (raid_device->volume_type != MPI2_RAID_VOL_TYPE_RAID0) {\r\nprintk(MPT2SAS_INFO_FMT "WarpDrive : Direct IO is disabled "\r\n"for the drive with handle(0x%04x): type=%d, "\r\n"s_sz=%uK, blk_size=%u\n", ioc->name,\r\nraid_device->handle, raid_device->volume_type,\r\n(le32_to_cpu(vol_pg0->StripeSize) *\r\nle16_to_cpu(vol_pg0->BlockSize)) / 1024,\r\nle16_to_cpu(vol_pg0->BlockSize));\r\ngoto out_error;\r\n}\r\nstripe_sz = le32_to_cpu(vol_pg0->StripeSize);\r\nstripe_exp = find_first_bit(&stripe_sz, 32);\r\nif (stripe_exp == 32) {\r\nprintk(MPT2SAS_INFO_FMT "WarpDrive : Direct IO is disabled "\r\n"for the drive with handle(0x%04x) invalid stripe sz %uK\n",\r\nioc->name, raid_device->handle,\r\n(le32_to_cpu(vol_pg0->StripeSize) *\r\nle16_to_cpu(vol_pg0->BlockSize)) / 1024);\r\ngoto out_error;\r\n}\r\nraid_device->stripe_exponent = stripe_exp;\r\nblock_sz = le16_to_cpu(vol_pg0->BlockSize);\r\nblock_exp = find_first_bit(&block_sz, 16);\r\nif (block_exp == 16) {\r\nprintk(MPT2SAS_INFO_FMT "WarpDrive : Direct IO is disabled "\r\n"for the drive with handle(0x%04x) invalid block sz %u\n",\r\nioc->name, raid_device->handle,\r\nle16_to_cpu(vol_pg0->BlockSize));\r\ngoto out_error;\r\n}\r\nraid_device->block_exponent = block_exp;\r\nraid_device->direct_io_enabled = 1;\r\nprintk(MPT2SAS_INFO_FMT "WarpDrive : Direct IO is Enabled for the drive"\r\n" with handle(0x%04x)\n", ioc->name, raid_device->handle);\r\nraid_device->max_lba = le64_to_cpu(vol_pg0->MaxLBA);\r\nraid_device->stripe_sz = le32_to_cpu(vol_pg0->StripeSize);\r\nraid_device->block_sz = le16_to_cpu(vol_pg0->BlockSize);\r\nkfree(vol_pg0);\r\nreturn;\r\nout_error:\r\nraid_device->direct_io_enabled = 0;\r\nfor (count = 0; count < num_pds; count++)\r\nraid_device->pd_handle[count] = 0;\r\nkfree(vol_pg0);\r\nreturn;\r\n}\r\nstatic void\r\n_scsih_enable_tlr(struct MPT2SAS_ADAPTER *ioc, struct scsi_device *sdev)\r\n{\r\nif (sdev->type != TYPE_TAPE)\r\nreturn;\r\nif (!(ioc->facts.IOCCapabilities & MPI2_IOCFACTS_CAPABILITY_TLR))\r\nreturn;\r\nsas_enable_tlr(sdev);\r\nsdev_printk(KERN_INFO, sdev, "TLR %s\n",\r\nsas_is_tlr_enabled(sdev) ? "Enabled" : "Disabled");\r\nreturn;\r\n}\r\nstatic int\r\n_scsih_slave_configure(struct scsi_device *sdev)\r\n{\r\nstruct Scsi_Host *shost = sdev->host;\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nstruct MPT2SAS_DEVICE *sas_device_priv_data;\r\nstruct MPT2SAS_TARGET *sas_target_priv_data;\r\nstruct _sas_device *sas_device;\r\nstruct _raid_device *raid_device;\r\nunsigned long flags;\r\nint qdepth;\r\nu8 ssp_target = 0;\r\nchar *ds = "";\r\nchar *r_level = "";\r\nu16 handle, volume_handle = 0;\r\nu64 volume_wwid = 0;\r\nqdepth = 1;\r\nsas_device_priv_data = sdev->hostdata;\r\nsas_device_priv_data->configured_lun = 1;\r\nsas_device_priv_data->flags &= ~MPT_DEVICE_FLAGS_INIT;\r\nsas_target_priv_data = sas_device_priv_data->sas_target;\r\nhandle = sas_target_priv_data->handle;\r\nif (sas_target_priv_data->flags & MPT_TARGET_FLAGS_VOLUME) {\r\nspin_lock_irqsave(&ioc->raid_device_lock, flags);\r\nraid_device = _scsih_raid_device_find_by_handle(ioc, handle);\r\nspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\r\nif (!raid_device) {\r\ndfailprintk(ioc, printk(MPT2SAS_WARN_FMT\r\n"failure at %s:%d/%s()!\n", ioc->name, __FILE__,\r\n__LINE__, __func__));\r\nreturn 1;\r\n}\r\nif (_scsih_get_volume_capabilities(ioc, raid_device)) {\r\ndfailprintk(ioc, printk(MPT2SAS_WARN_FMT\r\n"failure at %s:%d/%s()!\n", ioc->name, __FILE__,\r\n__LINE__, __func__));\r\nreturn 1;\r\n}\r\n_scsih_init_warpdrive_properties(ioc, raid_device);\r\nif (raid_device->device_info &\r\nMPI2_SAS_DEVICE_INFO_SSP_TARGET) {\r\nqdepth = MPT2SAS_SAS_QUEUE_DEPTH;\r\nds = "SSP";\r\n} else {\r\nqdepth = MPT2SAS_SATA_QUEUE_DEPTH;\r\nif (raid_device->device_info &\r\nMPI2_SAS_DEVICE_INFO_SATA_DEVICE)\r\nds = "SATA";\r\nelse\r\nds = "STP";\r\n}\r\nswitch (raid_device->volume_type) {\r\ncase MPI2_RAID_VOL_TYPE_RAID0:\r\nr_level = "RAID0";\r\nbreak;\r\ncase MPI2_RAID_VOL_TYPE_RAID1E:\r\nqdepth = MPT2SAS_RAID_QUEUE_DEPTH;\r\nif (ioc->manu_pg10.OEMIdentifier &&\r\n(le32_to_cpu(ioc->manu_pg10.GenericFlags0) &\r\nMFG10_GF0_R10_DISPLAY) &&\r\n!(raid_device->num_pds % 2))\r\nr_level = "RAID10";\r\nelse\r\nr_level = "RAID1E";\r\nbreak;\r\ncase MPI2_RAID_VOL_TYPE_RAID1:\r\nqdepth = MPT2SAS_RAID_QUEUE_DEPTH;\r\nr_level = "RAID1";\r\nbreak;\r\ncase MPI2_RAID_VOL_TYPE_RAID10:\r\nqdepth = MPT2SAS_RAID_QUEUE_DEPTH;\r\nr_level = "RAID10";\r\nbreak;\r\ncase MPI2_RAID_VOL_TYPE_UNKNOWN:\r\ndefault:\r\nqdepth = MPT2SAS_RAID_QUEUE_DEPTH;\r\nr_level = "RAIDX";\r\nbreak;\r\n}\r\nif (!ioc->hide_ir_msg)\r\nsdev_printk(KERN_INFO, sdev, "%s: handle(0x%04x), "\r\n"wwid(0x%016llx), pd_count(%d), type(%s)\n",\r\nr_level, raid_device->handle,\r\n(unsigned long long)raid_device->wwid,\r\nraid_device->num_pds, ds);\r\n_scsih_change_queue_depth(sdev, qdepth);\r\nif (!ioc->is_warpdrive)\r\n_scsih_set_level(sdev, raid_device->volume_type);\r\nreturn 0;\r\n}\r\nif (sas_target_priv_data->flags & MPT_TARGET_FLAGS_RAID_COMPONENT) {\r\nif (mpt2sas_config_get_volume_handle(ioc, handle,\r\n&volume_handle)) {\r\ndfailprintk(ioc, printk(MPT2SAS_WARN_FMT\r\n"failure at %s:%d/%s()!\n", ioc->name,\r\n__FILE__, __LINE__, __func__));\r\nreturn 1;\r\n}\r\nif (volume_handle && mpt2sas_config_get_volume_wwid(ioc,\r\nvolume_handle, &volume_wwid)) {\r\ndfailprintk(ioc, printk(MPT2SAS_WARN_FMT\r\n"failure at %s:%d/%s()!\n", ioc->name,\r\n__FILE__, __LINE__, __func__));\r\nreturn 1;\r\n}\r\n}\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nsas_device = mpt2sas_scsih_sas_device_find_by_sas_address(ioc,\r\nsas_device_priv_data->sas_target->sas_address);\r\nif (!sas_device) {\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\ndfailprintk(ioc, printk(MPT2SAS_WARN_FMT\r\n"failure at %s:%d/%s()!\n", ioc->name, __FILE__,\r\n__LINE__, __func__));\r\nreturn 1;\r\n}\r\nsas_device->volume_handle = volume_handle;\r\nsas_device->volume_wwid = volume_wwid;\r\nif (sas_device->device_info & MPI2_SAS_DEVICE_INFO_SSP_TARGET) {\r\nqdepth = MPT2SAS_SAS_QUEUE_DEPTH;\r\nssp_target = 1;\r\nds = "SSP";\r\n} else {\r\nqdepth = MPT2SAS_SATA_QUEUE_DEPTH;\r\nif (sas_device->device_info & MPI2_SAS_DEVICE_INFO_STP_TARGET)\r\nds = "STP";\r\nelse if (sas_device->device_info &\r\nMPI2_SAS_DEVICE_INFO_SATA_DEVICE)\r\nds = "SATA";\r\n}\r\nsdev_printk(KERN_INFO, sdev, "%s: handle(0x%04x), "\r\n"sas_addr(0x%016llx), phy(%d), device_name(0x%016llx)\n",\r\nds, sas_device->handle,\r\n(unsigned long long)sas_device->sas_address,\r\nsas_device->phy,\r\n(unsigned long long)sas_device->device_name);\r\nsdev_printk(KERN_INFO, sdev, "%s: "\r\n"enclosure_logical_id(0x%016llx), slot(%d)\n", ds,\r\n(unsigned long long) sas_device->enclosure_logical_id,\r\nsas_device->slot);\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\nif (!ssp_target)\r\n_scsih_display_sata_capabilities(ioc, handle, sdev);\r\n_scsih_change_queue_depth(sdev, qdepth);\r\nif (ssp_target) {\r\nsas_read_port_mode_page(sdev);\r\n_scsih_enable_tlr(ioc, sdev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\n_scsih_bios_param(struct scsi_device *sdev, struct block_device *bdev,\r\nsector_t capacity, int params[])\r\n{\r\nint heads;\r\nint sectors;\r\nsector_t cylinders;\r\nulong dummy;\r\nheads = 64;\r\nsectors = 32;\r\ndummy = heads * sectors;\r\ncylinders = capacity;\r\nsector_div(cylinders, dummy);\r\nif ((ulong)capacity >= 0x200000) {\r\nheads = 255;\r\nsectors = 63;\r\ndummy = heads * sectors;\r\ncylinders = capacity;\r\nsector_div(cylinders, dummy);\r\n}\r\nparams[0] = heads;\r\nparams[1] = sectors;\r\nparams[2] = cylinders;\r\nreturn 0;\r\n}\r\nstatic void\r\n_scsih_response_code(struct MPT2SAS_ADAPTER *ioc, u8 response_code)\r\n{\r\nchar *desc;\r\nswitch (response_code) {\r\ncase MPI2_SCSITASKMGMT_RSP_TM_COMPLETE:\r\ndesc = "task management request completed";\r\nbreak;\r\ncase MPI2_SCSITASKMGMT_RSP_INVALID_FRAME:\r\ndesc = "invalid frame";\r\nbreak;\r\ncase MPI2_SCSITASKMGMT_RSP_TM_NOT_SUPPORTED:\r\ndesc = "task management request not supported";\r\nbreak;\r\ncase MPI2_SCSITASKMGMT_RSP_TM_FAILED:\r\ndesc = "task management request failed";\r\nbreak;\r\ncase MPI2_SCSITASKMGMT_RSP_TM_SUCCEEDED:\r\ndesc = "task management request succeeded";\r\nbreak;\r\ncase MPI2_SCSITASKMGMT_RSP_TM_INVALID_LUN:\r\ndesc = "invalid lun";\r\nbreak;\r\ncase 0xA:\r\ndesc = "overlapped tag attempted";\r\nbreak;\r\ncase MPI2_SCSITASKMGMT_RSP_IO_QUEUED_ON_IOC:\r\ndesc = "task queued, however not sent to target";\r\nbreak;\r\ndefault:\r\ndesc = "unknown";\r\nbreak;\r\n}\r\nprintk(MPT2SAS_WARN_FMT "response_code(0x%01x): %s\n",\r\nioc->name, response_code, desc);\r\n}\r\nstatic u8\r\n_scsih_tm_done(struct MPT2SAS_ADAPTER *ioc, u16 smid, u8 msix_index, u32 reply)\r\n{\r\nMPI2DefaultReply_t *mpi_reply;\r\nif (ioc->tm_cmds.status == MPT2_CMD_NOT_USED)\r\nreturn 1;\r\nif (ioc->tm_cmds.smid != smid)\r\nreturn 1;\r\nmpt2sas_base_flush_reply_queues(ioc);\r\nioc->tm_cmds.status |= MPT2_CMD_COMPLETE;\r\nmpi_reply = mpt2sas_base_get_reply_virt_addr(ioc, reply);\r\nif (mpi_reply) {\r\nmemcpy(ioc->tm_cmds.reply, mpi_reply, mpi_reply->MsgLength*4);\r\nioc->tm_cmds.status |= MPT2_CMD_REPLY_VALID;\r\n}\r\nioc->tm_cmds.status &= ~MPT2_CMD_PENDING;\r\ncomplete(&ioc->tm_cmds.done);\r\nreturn 1;\r\n}\r\nvoid\r\nmpt2sas_scsih_set_tm_flag(struct MPT2SAS_ADAPTER *ioc, u16 handle)\r\n{\r\nstruct MPT2SAS_DEVICE *sas_device_priv_data;\r\nstruct scsi_device *sdev;\r\nu8 skip = 0;\r\nshost_for_each_device(sdev, ioc->shost) {\r\nif (skip)\r\ncontinue;\r\nsas_device_priv_data = sdev->hostdata;\r\nif (!sas_device_priv_data)\r\ncontinue;\r\nif (sas_device_priv_data->sas_target->handle == handle) {\r\nsas_device_priv_data->sas_target->tm_busy = 1;\r\nskip = 1;\r\nioc->ignore_loginfos = 1;\r\n}\r\n}\r\n}\r\nvoid\r\nmpt2sas_scsih_clear_tm_flag(struct MPT2SAS_ADAPTER *ioc, u16 handle)\r\n{\r\nstruct MPT2SAS_DEVICE *sas_device_priv_data;\r\nstruct scsi_device *sdev;\r\nu8 skip = 0;\r\nshost_for_each_device(sdev, ioc->shost) {\r\nif (skip)\r\ncontinue;\r\nsas_device_priv_data = sdev->hostdata;\r\nif (!sas_device_priv_data)\r\ncontinue;\r\nif (sas_device_priv_data->sas_target->handle == handle) {\r\nsas_device_priv_data->sas_target->tm_busy = 0;\r\nskip = 1;\r\nioc->ignore_loginfos = 0;\r\n}\r\n}\r\n}\r\nint\r\nmpt2sas_scsih_issue_tm(struct MPT2SAS_ADAPTER *ioc, u16 handle, uint channel,\r\nuint id, uint lun, u8 type, u16 smid_task, ulong timeout,\r\nenum mutex_type m_type)\r\n{\r\nMpi2SCSITaskManagementRequest_t *mpi_request;\r\nMpi2SCSITaskManagementReply_t *mpi_reply;\r\nu16 smid = 0;\r\nu32 ioc_state;\r\nunsigned long timeleft;\r\nstruct scsiio_tracker *scsi_lookup = NULL;\r\nint rc;\r\nif (m_type == TM_MUTEX_ON)\r\nmutex_lock(&ioc->tm_cmds.mutex);\r\nif (ioc->tm_cmds.status != MPT2_CMD_NOT_USED) {\r\nprintk(MPT2SAS_INFO_FMT "%s: tm_cmd busy!!!\n",\r\n__func__, ioc->name);\r\nrc = FAILED;\r\ngoto err_out;\r\n}\r\nif (ioc->shost_recovery || ioc->remove_host ||\r\nioc->pci_error_recovery) {\r\nprintk(MPT2SAS_INFO_FMT "%s: host reset in progress!\n",\r\n__func__, ioc->name);\r\nrc = FAILED;\r\ngoto err_out;\r\n}\r\nioc_state = mpt2sas_base_get_iocstate(ioc, 0);\r\nif (ioc_state & MPI2_DOORBELL_USED) {\r\ndhsprintk(ioc, printk(MPT2SAS_INFO_FMT "unexpected doorbell "\r\n"active!\n", ioc->name));\r\nrc = mpt2sas_base_hard_reset_handler(ioc, CAN_SLEEP,\r\nFORCE_BIG_HAMMER);\r\nrc = (!rc) ? SUCCESS : FAILED;\r\ngoto err_out;\r\n}\r\nif ((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_FAULT) {\r\nmpt2sas_base_fault_info(ioc, ioc_state &\r\nMPI2_DOORBELL_DATA_MASK);\r\nrc = mpt2sas_base_hard_reset_handler(ioc, CAN_SLEEP,\r\nFORCE_BIG_HAMMER);\r\nrc = (!rc) ? SUCCESS : FAILED;\r\ngoto err_out;\r\n}\r\nsmid = mpt2sas_base_get_smid_hpr(ioc, ioc->tm_cb_idx);\r\nif (!smid) {\r\nprintk(MPT2SAS_ERR_FMT "%s: failed obtaining a smid\n",\r\nioc->name, __func__);\r\nrc = FAILED;\r\ngoto err_out;\r\n}\r\nif (type == MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK)\r\nscsi_lookup = &ioc->scsi_lookup[smid_task - 1];\r\ndtmprintk(ioc, printk(MPT2SAS_INFO_FMT "sending tm: handle(0x%04x),"\r\n" task_type(0x%02x), smid(%d)\n", ioc->name, handle, type,\r\nsmid_task));\r\nioc->tm_cmds.status = MPT2_CMD_PENDING;\r\nmpi_request = mpt2sas_base_get_msg_frame(ioc, smid);\r\nioc->tm_cmds.smid = smid;\r\nmemset(mpi_request, 0, sizeof(Mpi2SCSITaskManagementRequest_t));\r\nmemset(ioc->tm_cmds.reply, 0, sizeof(Mpi2SCSITaskManagementReply_t));\r\nmpi_request->Function = MPI2_FUNCTION_SCSI_TASK_MGMT;\r\nmpi_request->DevHandle = cpu_to_le16(handle);\r\nmpi_request->TaskType = type;\r\nmpi_request->TaskMID = cpu_to_le16(smid_task);\r\nint_to_scsilun(lun, (struct scsi_lun *)mpi_request->LUN);\r\nmpt2sas_scsih_set_tm_flag(ioc, handle);\r\ninit_completion(&ioc->tm_cmds.done);\r\nmpt2sas_base_put_smid_hi_priority(ioc, smid);\r\ntimeleft = wait_for_completion_timeout(&ioc->tm_cmds.done, timeout*HZ);\r\nif (!(ioc->tm_cmds.status & MPT2_CMD_COMPLETE)) {\r\nprintk(MPT2SAS_ERR_FMT "%s: timeout\n",\r\nioc->name, __func__);\r\n_debug_dump_mf(mpi_request,\r\nsizeof(Mpi2SCSITaskManagementRequest_t)/4);\r\nif (!(ioc->tm_cmds.status & MPT2_CMD_RESET)) {\r\nrc = mpt2sas_base_hard_reset_handler(ioc, CAN_SLEEP,\r\nFORCE_BIG_HAMMER);\r\nrc = (!rc) ? SUCCESS : FAILED;\r\nioc->tm_cmds.status = MPT2_CMD_NOT_USED;\r\nmpt2sas_scsih_clear_tm_flag(ioc, handle);\r\ngoto err_out;\r\n}\r\n}\r\nif (ioc->tm_cmds.status & MPT2_CMD_REPLY_VALID) {\r\nmpi_reply = ioc->tm_cmds.reply;\r\ndtmprintk(ioc, printk(MPT2SAS_INFO_FMT "complete tm: "\r\n"ioc_status(0x%04x), loginfo(0x%08x), term_count(0x%08x)\n",\r\nioc->name, le16_to_cpu(mpi_reply->IOCStatus),\r\nle32_to_cpu(mpi_reply->IOCLogInfo),\r\nle32_to_cpu(mpi_reply->TerminationCount)));\r\nif (ioc->logging_level & MPT_DEBUG_TM) {\r\n_scsih_response_code(ioc, mpi_reply->ResponseCode);\r\nif (mpi_reply->IOCStatus)\r\n_debug_dump_mf(mpi_request,\r\nsizeof(Mpi2SCSITaskManagementRequest_t)/4);\r\n}\r\n}\r\nswitch (type) {\r\ncase MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK:\r\nrc = SUCCESS;\r\nif (scsi_lookup->scmd == NULL)\r\nbreak;\r\nrc = FAILED;\r\nbreak;\r\ncase MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET:\r\nif (_scsih_scsi_lookup_find_by_target(ioc, id, channel))\r\nrc = FAILED;\r\nelse\r\nrc = SUCCESS;\r\nbreak;\r\ncase MPI2_SCSITASKMGMT_TASKTYPE_ABRT_TASK_SET:\r\ncase MPI2_SCSITASKMGMT_TASKTYPE_LOGICAL_UNIT_RESET:\r\nif (_scsih_scsi_lookup_find_by_lun(ioc, id, lun, channel))\r\nrc = FAILED;\r\nelse\r\nrc = SUCCESS;\r\nbreak;\r\ncase MPI2_SCSITASKMGMT_TASKTYPE_QUERY_TASK:\r\nrc = SUCCESS;\r\nbreak;\r\ndefault:\r\nrc = FAILED;\r\nbreak;\r\n}\r\nmpt2sas_scsih_clear_tm_flag(ioc, handle);\r\nioc->tm_cmds.status = MPT2_CMD_NOT_USED;\r\nif (m_type == TM_MUTEX_ON)\r\nmutex_unlock(&ioc->tm_cmds.mutex);\r\nreturn rc;\r\nerr_out:\r\nif (m_type == TM_MUTEX_ON)\r\nmutex_unlock(&ioc->tm_cmds.mutex);\r\nreturn rc;\r\n}\r\nstatic void\r\n_scsih_tm_display_info(struct MPT2SAS_ADAPTER *ioc, struct scsi_cmnd *scmd)\r\n{\r\nstruct scsi_target *starget = scmd->device->sdev_target;\r\nstruct MPT2SAS_TARGET *priv_target = starget->hostdata;\r\nstruct _sas_device *sas_device = NULL;\r\nunsigned long flags;\r\nchar *device_str = NULL;\r\nif (!priv_target)\r\nreturn;\r\nif (ioc->hide_ir_msg)\r\ndevice_str = "WarpDrive";\r\nelse\r\ndevice_str = "volume";\r\nscsi_print_command(scmd);\r\nif (priv_target->flags & MPT_TARGET_FLAGS_VOLUME) {\r\nstarget_printk(KERN_INFO, starget, "%s handle(0x%04x), "\r\n"%s wwid(0x%016llx)\n", device_str, priv_target->handle,\r\ndevice_str, (unsigned long long)priv_target->sas_address);\r\n} else {\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nsas_device = mpt2sas_scsih_sas_device_find_by_sas_address(ioc,\r\npriv_target->sas_address);\r\nif (sas_device) {\r\nif (priv_target->flags &\r\nMPT_TARGET_FLAGS_RAID_COMPONENT) {\r\nstarget_printk(KERN_INFO, starget,\r\n"volume handle(0x%04x), "\r\n"volume wwid(0x%016llx)\n",\r\nsas_device->volume_handle,\r\n(unsigned long long)sas_device->volume_wwid);\r\n}\r\nstarget_printk(KERN_INFO, starget,\r\n"handle(0x%04x), sas_address(0x%016llx), phy(%d)\n",\r\nsas_device->handle,\r\n(unsigned long long)sas_device->sas_address,\r\nsas_device->phy);\r\nstarget_printk(KERN_INFO, starget,\r\n"enclosure_logical_id(0x%016llx), slot(%d)\n",\r\n(unsigned long long)sas_device->enclosure_logical_id,\r\nsas_device->slot);\r\n}\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\n}\r\n}\r\nstatic int\r\n_scsih_abort(struct scsi_cmnd *scmd)\r\n{\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(scmd->device->host);\r\nstruct MPT2SAS_DEVICE *sas_device_priv_data;\r\nu16 smid;\r\nu16 handle;\r\nint r;\r\nsdev_printk(KERN_INFO, scmd->device, "attempting task abort! "\r\n"scmd(%p)\n", scmd);\r\n_scsih_tm_display_info(ioc, scmd);\r\nsas_device_priv_data = scmd->device->hostdata;\r\nif (!sas_device_priv_data || !sas_device_priv_data->sas_target) {\r\nsdev_printk(KERN_INFO, scmd->device, "device been deleted! "\r\n"scmd(%p)\n", scmd);\r\nscmd->result = DID_NO_CONNECT << 16;\r\nscmd->scsi_done(scmd);\r\nr = SUCCESS;\r\ngoto out;\r\n}\r\nsmid = _scsih_scsi_lookup_find_by_scmd(ioc, scmd);\r\nif (!smid) {\r\nscmd->result = DID_RESET << 16;\r\nr = SUCCESS;\r\ngoto out;\r\n}\r\nif (sas_device_priv_data->sas_target->flags &\r\nMPT_TARGET_FLAGS_RAID_COMPONENT ||\r\nsas_device_priv_data->sas_target->flags & MPT_TARGET_FLAGS_VOLUME) {\r\nscmd->result = DID_RESET << 16;\r\nr = FAILED;\r\ngoto out;\r\n}\r\nmpt2sas_halt_firmware(ioc);\r\nhandle = sas_device_priv_data->sas_target->handle;\r\nr = mpt2sas_scsih_issue_tm(ioc, handle, scmd->device->channel,\r\nscmd->device->id, scmd->device->lun,\r\nMPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK, smid, 30, TM_MUTEX_ON);\r\nout:\r\nsdev_printk(KERN_INFO, scmd->device, "task abort: %s scmd(%p)\n",\r\n((r == SUCCESS) ? "SUCCESS" : "FAILED"), scmd);\r\nreturn r;\r\n}\r\nstatic int\r\n_scsih_dev_reset(struct scsi_cmnd *scmd)\r\n{\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(scmd->device->host);\r\nstruct MPT2SAS_DEVICE *sas_device_priv_data;\r\nstruct _sas_device *sas_device;\r\nunsigned long flags;\r\nu16 handle;\r\nint r;\r\nstruct scsi_target *starget = scmd->device->sdev_target;\r\nstarget_printk(KERN_INFO, starget, "attempting device reset! "\r\n"scmd(%p)\n", scmd);\r\n_scsih_tm_display_info(ioc, scmd);\r\nsas_device_priv_data = scmd->device->hostdata;\r\nif (!sas_device_priv_data || !sas_device_priv_data->sas_target) {\r\nstarget_printk(KERN_INFO, starget, "device been deleted! "\r\n"scmd(%p)\n", scmd);\r\nscmd->result = DID_NO_CONNECT << 16;\r\nscmd->scsi_done(scmd);\r\nr = SUCCESS;\r\ngoto out;\r\n}\r\nhandle = 0;\r\nif (sas_device_priv_data->sas_target->flags &\r\nMPT_TARGET_FLAGS_RAID_COMPONENT) {\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nsas_device = _scsih_sas_device_find_by_handle(ioc,\r\nsas_device_priv_data->sas_target->handle);\r\nif (sas_device)\r\nhandle = sas_device->volume_handle;\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\n} else\r\nhandle = sas_device_priv_data->sas_target->handle;\r\nif (!handle) {\r\nscmd->result = DID_RESET << 16;\r\nr = FAILED;\r\ngoto out;\r\n}\r\nr = mpt2sas_scsih_issue_tm(ioc, handle, scmd->device->channel,\r\nscmd->device->id, scmd->device->lun,\r\nMPI2_SCSITASKMGMT_TASKTYPE_LOGICAL_UNIT_RESET, 0, 30, TM_MUTEX_ON);\r\nout:\r\nsdev_printk(KERN_INFO, scmd->device, "device reset: %s scmd(%p)\n",\r\n((r == SUCCESS) ? "SUCCESS" : "FAILED"), scmd);\r\nreturn r;\r\n}\r\nstatic int\r\n_scsih_target_reset(struct scsi_cmnd *scmd)\r\n{\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(scmd->device->host);\r\nstruct MPT2SAS_DEVICE *sas_device_priv_data;\r\nstruct _sas_device *sas_device;\r\nunsigned long flags;\r\nu16 handle;\r\nint r;\r\nstruct scsi_target *starget = scmd->device->sdev_target;\r\nstarget_printk(KERN_INFO, starget, "attempting target reset! "\r\n"scmd(%p)\n", scmd);\r\n_scsih_tm_display_info(ioc, scmd);\r\nsas_device_priv_data = scmd->device->hostdata;\r\nif (!sas_device_priv_data || !sas_device_priv_data->sas_target) {\r\nstarget_printk(KERN_INFO, starget, "target been deleted! "\r\n"scmd(%p)\n", scmd);\r\nscmd->result = DID_NO_CONNECT << 16;\r\nscmd->scsi_done(scmd);\r\nr = SUCCESS;\r\ngoto out;\r\n}\r\nhandle = 0;\r\nif (sas_device_priv_data->sas_target->flags &\r\nMPT_TARGET_FLAGS_RAID_COMPONENT) {\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nsas_device = _scsih_sas_device_find_by_handle(ioc,\r\nsas_device_priv_data->sas_target->handle);\r\nif (sas_device)\r\nhandle = sas_device->volume_handle;\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\n} else\r\nhandle = sas_device_priv_data->sas_target->handle;\r\nif (!handle) {\r\nscmd->result = DID_RESET << 16;\r\nr = FAILED;\r\ngoto out;\r\n}\r\nr = mpt2sas_scsih_issue_tm(ioc, handle, scmd->device->channel,\r\nscmd->device->id, 0, MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET, 0,\r\n30, TM_MUTEX_ON);\r\nout:\r\nstarget_printk(KERN_INFO, starget, "target reset: %s scmd(%p)\n",\r\n((r == SUCCESS) ? "SUCCESS" : "FAILED"), scmd);\r\nreturn r;\r\n}\r\nstatic int\r\n_scsih_host_reset(struct scsi_cmnd *scmd)\r\n{\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(scmd->device->host);\r\nint r, retval;\r\nprintk(MPT2SAS_INFO_FMT "attempting host reset! scmd(%p)\n",\r\nioc->name, scmd);\r\nscsi_print_command(scmd);\r\nif (ioc->is_driver_loading) {\r\nprintk(MPT2SAS_INFO_FMT "Blocking the host reset\n",\r\nioc->name);\r\nr = FAILED;\r\ngoto out;\r\n}\r\nretval = mpt2sas_base_hard_reset_handler(ioc, CAN_SLEEP,\r\nFORCE_BIG_HAMMER);\r\nr = (retval < 0) ? FAILED : SUCCESS;\r\nout:\r\nprintk(MPT2SAS_INFO_FMT "host reset: %s scmd(%p)\n",\r\nioc->name, ((r == SUCCESS) ? "SUCCESS" : "FAILED"), scmd);\r\nreturn r;\r\n}\r\nstatic void\r\n_scsih_fw_event_add(struct MPT2SAS_ADAPTER *ioc, struct fw_event_work *fw_event)\r\n{\r\nunsigned long flags;\r\nif (ioc->firmware_event_thread == NULL)\r\nreturn;\r\nspin_lock_irqsave(&ioc->fw_event_lock, flags);\r\nlist_add_tail(&fw_event->list, &ioc->fw_event_list);\r\nINIT_DELAYED_WORK(&fw_event->delayed_work, _firmware_event_work);\r\nqueue_delayed_work(ioc->firmware_event_thread,\r\n&fw_event->delayed_work, 0);\r\nspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\r\n}\r\nstatic void\r\n_scsih_fw_event_free(struct MPT2SAS_ADAPTER *ioc, struct fw_event_work\r\n*fw_event)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ioc->fw_event_lock, flags);\r\nlist_del(&fw_event->list);\r\nkfree(fw_event);\r\nspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\r\n}\r\nstatic void\r\n_scsih_error_recovery_delete_devices(struct MPT2SAS_ADAPTER *ioc)\r\n{\r\nstruct fw_event_work *fw_event;\r\nif (ioc->is_driver_loading)\r\nreturn;\r\nfw_event = kzalloc(sizeof(struct fw_event_work), GFP_ATOMIC);\r\nif (!fw_event)\r\nreturn;\r\nfw_event->event = MPT2SAS_REMOVE_UNRESPONDING_DEVICES;\r\nfw_event->ioc = ioc;\r\n_scsih_fw_event_add(ioc, fw_event);\r\n}\r\nvoid\r\nmpt2sas_port_enable_complete(struct MPT2SAS_ADAPTER *ioc)\r\n{\r\nstruct fw_event_work *fw_event;\r\nfw_event = kzalloc(sizeof(struct fw_event_work), GFP_ATOMIC);\r\nif (!fw_event)\r\nreturn;\r\nfw_event->event = MPT2SAS_PORT_ENABLE_COMPLETE;\r\nfw_event->ioc = ioc;\r\n_scsih_fw_event_add(ioc, fw_event);\r\n}\r\nstatic void\r\n_scsih_fw_event_cleanup_queue(struct MPT2SAS_ADAPTER *ioc)\r\n{\r\nstruct fw_event_work *fw_event, *next;\r\nif (list_empty(&ioc->fw_event_list) ||\r\n!ioc->firmware_event_thread || in_interrupt())\r\nreturn;\r\nlist_for_each_entry_safe(fw_event, next, &ioc->fw_event_list, list) {\r\nif (cancel_delayed_work_sync(&fw_event->delayed_work)) {\r\n_scsih_fw_event_free(ioc, fw_event);\r\ncontinue;\r\n}\r\n}\r\n}\r\nstatic void\r\n_scsih_ublock_io_all_device(struct MPT2SAS_ADAPTER *ioc)\r\n{\r\nstruct MPT2SAS_DEVICE *sas_device_priv_data;\r\nstruct scsi_device *sdev;\r\nshost_for_each_device(sdev, ioc->shost) {\r\nsas_device_priv_data = sdev->hostdata;\r\nif (!sas_device_priv_data)\r\ncontinue;\r\nif (!sas_device_priv_data->block)\r\ncontinue;\r\nsas_device_priv_data->block = 0;\r\ndewtprintk(ioc, sdev_printk(KERN_INFO, sdev, "device_running, "\r\n"handle(0x%04x)\n",\r\nsas_device_priv_data->sas_target->handle));\r\nscsi_internal_device_unblock(sdev, SDEV_RUNNING);\r\n}\r\n}\r\nstatic void\r\n_scsih_ublock_io_device(struct MPT2SAS_ADAPTER *ioc, u64 sas_address)\r\n{\r\nstruct MPT2SAS_DEVICE *sas_device_priv_data;\r\nstruct scsi_device *sdev;\r\nshost_for_each_device(sdev, ioc->shost) {\r\nsas_device_priv_data = sdev->hostdata;\r\nif (!sas_device_priv_data)\r\ncontinue;\r\nif (!sas_device_priv_data->block)\r\ncontinue;\r\nif (sas_device_priv_data->sas_target->sas_address ==\r\nsas_address) {\r\ndewtprintk(ioc, sdev_printk(KERN_INFO, sdev,\r\nMPT2SAS_INFO_FMT "SDEV_RUNNING: "\r\n"sas address(0x%016llx)\n", ioc->name,\r\n(unsigned long long)sas_address));\r\nsas_device_priv_data->block = 0;\r\nscsi_internal_device_unblock(sdev, SDEV_RUNNING);\r\n}\r\n}\r\n}\r\nstatic void\r\n_scsih_block_io_all_device(struct MPT2SAS_ADAPTER *ioc)\r\n{\r\nstruct MPT2SAS_DEVICE *sas_device_priv_data;\r\nstruct scsi_device *sdev;\r\nshost_for_each_device(sdev, ioc->shost) {\r\nsas_device_priv_data = sdev->hostdata;\r\nif (!sas_device_priv_data)\r\ncontinue;\r\nif (sas_device_priv_data->block)\r\ncontinue;\r\nsas_device_priv_data->block = 1;\r\ndewtprintk(ioc, sdev_printk(KERN_INFO, sdev, "device_blocked, "\r\n"handle(0x%04x)\n",\r\nsas_device_priv_data->sas_target->handle));\r\nscsi_internal_device_block(sdev);\r\n}\r\n}\r\nstatic void\r\n_scsih_block_io_device(struct MPT2SAS_ADAPTER *ioc, u16 handle)\r\n{\r\nstruct MPT2SAS_DEVICE *sas_device_priv_data;\r\nstruct scsi_device *sdev;\r\nshost_for_each_device(sdev, ioc->shost) {\r\nsas_device_priv_data = sdev->hostdata;\r\nif (!sas_device_priv_data)\r\ncontinue;\r\nif (sas_device_priv_data->block)\r\ncontinue;\r\nif (sas_device_priv_data->sas_target->handle == handle) {\r\ndewtprintk(ioc, sdev_printk(KERN_INFO, sdev,\r\nMPT2SAS_INFO_FMT "SDEV_BLOCK: "\r\n"handle(0x%04x)\n", ioc->name, handle));\r\nsas_device_priv_data->block = 1;\r\nscsi_internal_device_block(sdev);\r\n}\r\n}\r\n}\r\nstatic void\r\n_scsih_block_io_to_children_attached_to_ex(struct MPT2SAS_ADAPTER *ioc,\r\nstruct _sas_node *sas_expander)\r\n{\r\nstruct _sas_port *mpt2sas_port;\r\nstruct _sas_device *sas_device;\r\nstruct _sas_node *expander_sibling;\r\nunsigned long flags;\r\nif (!sas_expander)\r\nreturn;\r\nlist_for_each_entry(mpt2sas_port,\r\n&sas_expander->sas_port_list, port_list) {\r\nif (mpt2sas_port->remote_identify.device_type ==\r\nSAS_END_DEVICE) {\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nsas_device =\r\nmpt2sas_scsih_sas_device_find_by_sas_address(ioc,\r\nmpt2sas_port->remote_identify.sas_address);\r\nif (sas_device)\r\nset_bit(sas_device->handle,\r\nioc->blocking_handles);\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\n}\r\n}\r\nlist_for_each_entry(mpt2sas_port,\r\n&sas_expander->sas_port_list, port_list) {\r\nif (mpt2sas_port->remote_identify.device_type ==\r\nSAS_EDGE_EXPANDER_DEVICE ||\r\nmpt2sas_port->remote_identify.device_type ==\r\nSAS_FANOUT_EXPANDER_DEVICE) {\r\nexpander_sibling =\r\nmpt2sas_scsih_expander_find_by_sas_address(\r\nioc, mpt2sas_port->remote_identify.sas_address);\r\n_scsih_block_io_to_children_attached_to_ex(ioc,\r\nexpander_sibling);\r\n}\r\n}\r\n}\r\nstatic void\r\n_scsih_block_io_to_children_attached_directly(struct MPT2SAS_ADAPTER *ioc,\r\nMpi2EventDataSasTopologyChangeList_t *event_data)\r\n{\r\nint i;\r\nu16 handle;\r\nu16 reason_code;\r\nu8 phy_number;\r\nfor (i = 0; i < event_data->NumEntries; i++) {\r\nhandle = le16_to_cpu(event_data->PHY[i].AttachedDevHandle);\r\nif (!handle)\r\ncontinue;\r\nphy_number = event_data->StartPhyNum + i;\r\nreason_code = event_data->PHY[i].PhyStatus &\r\nMPI2_EVENT_SAS_TOPO_RC_MASK;\r\nif (reason_code == MPI2_EVENT_SAS_TOPO_RC_DELAY_NOT_RESPONDING)\r\n_scsih_block_io_device(ioc, handle);\r\n}\r\n}\r\nstatic void\r\n_scsih_tm_tr_send(struct MPT2SAS_ADAPTER *ioc, u16 handle)\r\n{\r\nMpi2SCSITaskManagementRequest_t *mpi_request;\r\nu16 smid;\r\nstruct _sas_device *sas_device;\r\nstruct MPT2SAS_TARGET *sas_target_priv_data = NULL;\r\nu64 sas_address = 0;\r\nunsigned long flags;\r\nstruct _tr_list *delayed_tr;\r\nu32 ioc_state;\r\nif (ioc->remove_host) {\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: host has been "\r\n"removed: handle(0x%04x)\n", __func__, ioc->name, handle));\r\nreturn;\r\n} else if (ioc->pci_error_recovery) {\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: host in pci "\r\n"error recovery: handle(0x%04x)\n", __func__, ioc->name,\r\nhandle));\r\nreturn;\r\n}\r\nioc_state = mpt2sas_base_get_iocstate(ioc, 1);\r\nif (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: host is not "\r\n"operational: handle(0x%04x)\n", __func__, ioc->name,\r\nhandle));\r\nreturn;\r\n}\r\nif (test_bit(handle, ioc->pd_handles))\r\nreturn;\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nsas_device = _scsih_sas_device_find_by_handle(ioc, handle);\r\nif (sas_device && sas_device->starget &&\r\nsas_device->starget->hostdata) {\r\nsas_target_priv_data = sas_device->starget->hostdata;\r\nsas_target_priv_data->deleted = 1;\r\nsas_address = sas_device->sas_address;\r\n}\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\nif (sas_target_priv_data) {\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT "setting delete flag: "\r\n"handle(0x%04x), sas_addr(0x%016llx)\n", ioc->name, handle,\r\n(unsigned long long)sas_address));\r\n_scsih_ublock_io_device(ioc, sas_address);\r\nsas_target_priv_data->handle = MPT2SAS_INVALID_DEVICE_HANDLE;\r\n}\r\nsmid = mpt2sas_base_get_smid_hpr(ioc, ioc->tm_tr_cb_idx);\r\nif (!smid) {\r\ndelayed_tr = kzalloc(sizeof(*delayed_tr), GFP_ATOMIC);\r\nif (!delayed_tr)\r\nreturn;\r\nINIT_LIST_HEAD(&delayed_tr->list);\r\ndelayed_tr->handle = handle;\r\nlist_add_tail(&delayed_tr->list, &ioc->delayed_tr_list);\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT\r\n"DELAYED:tr:handle(0x%04x), (open)\n",\r\nioc->name, handle));\r\nreturn;\r\n}\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT "tr_send:handle(0x%04x), "\r\n"(open), smid(%d), cb(%d)\n", ioc->name, handle, smid,\r\nioc->tm_tr_cb_idx));\r\nmpi_request = mpt2sas_base_get_msg_frame(ioc, smid);\r\nmemset(mpi_request, 0, sizeof(Mpi2SCSITaskManagementRequest_t));\r\nmpi_request->Function = MPI2_FUNCTION_SCSI_TASK_MGMT;\r\nmpi_request->DevHandle = cpu_to_le16(handle);\r\nmpi_request->TaskType = MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET;\r\nmpt2sas_base_put_smid_hi_priority(ioc, smid);\r\n}\r\nstatic u8\r\n_scsih_sas_control_complete(struct MPT2SAS_ADAPTER *ioc, u16 smid,\r\nu8 msix_index, u32 reply)\r\n{\r\nMpi2SasIoUnitControlReply_t *mpi_reply =\r\nmpt2sas_base_get_reply_virt_addr(ioc, reply);\r\nif (likely(mpi_reply)) {\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT\r\n"sc_complete:handle(0x%04x), (open) "\r\n"smid(%d), ioc_status(0x%04x), loginfo(0x%08x)\n",\r\nioc->name, le16_to_cpu(mpi_reply->DevHandle), smid,\r\nle16_to_cpu(mpi_reply->IOCStatus),\r\nle32_to_cpu(mpi_reply->IOCLogInfo)));\r\n} else {\r\nprintk(MPT2SAS_ERR_FMT "mpi_reply not valid at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\n}\r\nreturn 1;\r\n}\r\nstatic void\r\n_scsih_tm_tr_volume_send(struct MPT2SAS_ADAPTER *ioc, u16 handle)\r\n{\r\nMpi2SCSITaskManagementRequest_t *mpi_request;\r\nu16 smid;\r\nstruct _tr_list *delayed_tr;\r\nif (ioc->shost_recovery || ioc->remove_host ||\r\nioc->pci_error_recovery) {\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: host reset in "\r\n"progress!\n", __func__, ioc->name));\r\nreturn;\r\n}\r\nsmid = mpt2sas_base_get_smid_hpr(ioc, ioc->tm_tr_volume_cb_idx);\r\nif (!smid) {\r\ndelayed_tr = kzalloc(sizeof(*delayed_tr), GFP_ATOMIC);\r\nif (!delayed_tr)\r\nreturn;\r\nINIT_LIST_HEAD(&delayed_tr->list);\r\ndelayed_tr->handle = handle;\r\nlist_add_tail(&delayed_tr->list, &ioc->delayed_tr_volume_list);\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT\r\n"DELAYED:tr:handle(0x%04x), (open)\n",\r\nioc->name, handle));\r\nreturn;\r\n}\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT "tr_send:handle(0x%04x), "\r\n"(open), smid(%d), cb(%d)\n", ioc->name, handle, smid,\r\nioc->tm_tr_volume_cb_idx));\r\nmpi_request = mpt2sas_base_get_msg_frame(ioc, smid);\r\nmemset(mpi_request, 0, sizeof(Mpi2SCSITaskManagementRequest_t));\r\nmpi_request->Function = MPI2_FUNCTION_SCSI_TASK_MGMT;\r\nmpi_request->DevHandle = cpu_to_le16(handle);\r\nmpi_request->TaskType = MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET;\r\nmpt2sas_base_put_smid_hi_priority(ioc, smid);\r\n}\r\nstatic u8\r\n_scsih_tm_volume_tr_complete(struct MPT2SAS_ADAPTER *ioc, u16 smid,\r\nu8 msix_index, u32 reply)\r\n{\r\nu16 handle;\r\nMpi2SCSITaskManagementRequest_t *mpi_request_tm;\r\nMpi2SCSITaskManagementReply_t *mpi_reply =\r\nmpt2sas_base_get_reply_virt_addr(ioc, reply);\r\nif (ioc->shost_recovery || ioc->remove_host ||\r\nioc->pci_error_recovery) {\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: host reset in "\r\n"progress!\n", __func__, ioc->name));\r\nreturn 1;\r\n}\r\nif (unlikely(!mpi_reply)) {\r\nprintk(MPT2SAS_ERR_FMT "mpi_reply not valid at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn 1;\r\n}\r\nmpi_request_tm = mpt2sas_base_get_msg_frame(ioc, smid);\r\nhandle = le16_to_cpu(mpi_request_tm->DevHandle);\r\nif (handle != le16_to_cpu(mpi_reply->DevHandle)) {\r\ndewtprintk(ioc, printk("spurious interrupt: "\r\n"handle(0x%04x:0x%04x), smid(%d)!!!\n", handle,\r\nle16_to_cpu(mpi_reply->DevHandle), smid));\r\nreturn 0;\r\n}\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT\r\n"tr_complete:handle(0x%04x), (open) smid(%d), ioc_status(0x%04x), "\r\n"loginfo(0x%08x), completed(%d)\n", ioc->name,\r\nhandle, smid, le16_to_cpu(mpi_reply->IOCStatus),\r\nle32_to_cpu(mpi_reply->IOCLogInfo),\r\nle32_to_cpu(mpi_reply->TerminationCount)));\r\nreturn _scsih_check_for_pending_tm(ioc, smid);\r\n}\r\nstatic u8\r\n_scsih_tm_tr_complete(struct MPT2SAS_ADAPTER *ioc, u16 smid, u8 msix_index,\r\nu32 reply)\r\n{\r\nu16 handle;\r\nMpi2SCSITaskManagementRequest_t *mpi_request_tm;\r\nMpi2SCSITaskManagementReply_t *mpi_reply =\r\nmpt2sas_base_get_reply_virt_addr(ioc, reply);\r\nMpi2SasIoUnitControlRequest_t *mpi_request;\r\nu16 smid_sas_ctrl;\r\nu32 ioc_state;\r\nif (ioc->remove_host) {\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: host has been "\r\n"removed\n", __func__, ioc->name));\r\nreturn 1;\r\n} else if (ioc->pci_error_recovery) {\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: host in pci "\r\n"error recovery\n", __func__, ioc->name));\r\nreturn 1;\r\n}\r\nioc_state = mpt2sas_base_get_iocstate(ioc, 1);\r\nif (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: host is not "\r\n"operational\n", __func__, ioc->name));\r\nreturn 1;\r\n}\r\nif (unlikely(!mpi_reply)) {\r\nprintk(MPT2SAS_ERR_FMT "mpi_reply not valid at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn 1;\r\n}\r\nmpi_request_tm = mpt2sas_base_get_msg_frame(ioc, smid);\r\nhandle = le16_to_cpu(mpi_request_tm->DevHandle);\r\nif (handle != le16_to_cpu(mpi_reply->DevHandle)) {\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT "spurious interrupt: "\r\n"handle(0x%04x:0x%04x), smid(%d)!!!\n", ioc->name, handle,\r\nle16_to_cpu(mpi_reply->DevHandle), smid));\r\nreturn 0;\r\n}\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT\r\n"tr_complete:handle(0x%04x), (open) smid(%d), ioc_status(0x%04x), "\r\n"loginfo(0x%08x), completed(%d)\n", ioc->name,\r\nhandle, smid, le16_to_cpu(mpi_reply->IOCStatus),\r\nle32_to_cpu(mpi_reply->IOCLogInfo),\r\nle32_to_cpu(mpi_reply->TerminationCount)));\r\nsmid_sas_ctrl = mpt2sas_base_get_smid(ioc, ioc->tm_sas_control_cb_idx);\r\nif (!smid_sas_ctrl) {\r\nprintk(MPT2SAS_ERR_FMT "%s: failed obtaining a smid\n",\r\nioc->name, __func__);\r\nreturn 1;\r\n}\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT "sc_send:handle(0x%04x), "\r\n"(open), smid(%d), cb(%d)\n", ioc->name, handle, smid_sas_ctrl,\r\nioc->tm_sas_control_cb_idx));\r\nmpi_request = mpt2sas_base_get_msg_frame(ioc, smid_sas_ctrl);\r\nmemset(mpi_request, 0, sizeof(Mpi2SasIoUnitControlRequest_t));\r\nmpi_request->Function = MPI2_FUNCTION_SAS_IO_UNIT_CONTROL;\r\nmpi_request->Operation = MPI2_SAS_OP_REMOVE_DEVICE;\r\nmpi_request->DevHandle = mpi_request_tm->DevHandle;\r\nmpt2sas_base_put_smid_default(ioc, smid_sas_ctrl);\r\nreturn _scsih_check_for_pending_tm(ioc, smid);\r\n}\r\nstatic u8\r\n_scsih_check_for_pending_tm(struct MPT2SAS_ADAPTER *ioc, u16 smid)\r\n{\r\nstruct _tr_list *delayed_tr;\r\nif (!list_empty(&ioc->delayed_tr_volume_list)) {\r\ndelayed_tr = list_entry(ioc->delayed_tr_volume_list.next,\r\nstruct _tr_list, list);\r\nmpt2sas_base_free_smid(ioc, smid);\r\n_scsih_tm_tr_volume_send(ioc, delayed_tr->handle);\r\nlist_del(&delayed_tr->list);\r\nkfree(delayed_tr);\r\nreturn 0;\r\n}\r\nif (!list_empty(&ioc->delayed_tr_list)) {\r\ndelayed_tr = list_entry(ioc->delayed_tr_list.next,\r\nstruct _tr_list, list);\r\nmpt2sas_base_free_smid(ioc, smid);\r\n_scsih_tm_tr_send(ioc, delayed_tr->handle);\r\nlist_del(&delayed_tr->list);\r\nkfree(delayed_tr);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void\r\n_scsih_check_topo_delete_events(struct MPT2SAS_ADAPTER *ioc,\r\nMpi2EventDataSasTopologyChangeList_t *event_data)\r\n{\r\nstruct fw_event_work *fw_event;\r\nMpi2EventDataSasTopologyChangeList_t *local_event_data;\r\nu16 expander_handle;\r\nstruct _sas_node *sas_expander;\r\nunsigned long flags;\r\nint i, reason_code;\r\nu16 handle;\r\nfor (i = 0 ; i < event_data->NumEntries; i++) {\r\nhandle = le16_to_cpu(event_data->PHY[i].AttachedDevHandle);\r\nif (!handle)\r\ncontinue;\r\nreason_code = event_data->PHY[i].PhyStatus &\r\nMPI2_EVENT_SAS_TOPO_RC_MASK;\r\nif (reason_code == MPI2_EVENT_SAS_TOPO_RC_TARG_NOT_RESPONDING)\r\n_scsih_tm_tr_send(ioc, handle);\r\n}\r\nexpander_handle = le16_to_cpu(event_data->ExpanderDevHandle);\r\nif (expander_handle < ioc->sas_hba.num_phys) {\r\n_scsih_block_io_to_children_attached_directly(ioc, event_data);\r\nreturn;\r\n}\r\nif (event_data->ExpStatus ==\r\nMPI2_EVENT_SAS_TOPO_ES_DELAY_NOT_RESPONDING) {\r\nspin_lock_irqsave(&ioc->sas_node_lock, flags);\r\nsas_expander = mpt2sas_scsih_expander_find_by_handle(ioc,\r\nexpander_handle);\r\n_scsih_block_io_to_children_attached_to_ex(ioc, sas_expander);\r\nspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\r\ndo {\r\nhandle = find_first_bit(ioc->blocking_handles,\r\nioc->facts.MaxDevHandle);\r\nif (handle < ioc->facts.MaxDevHandle)\r\n_scsih_block_io_device(ioc, handle);\r\n} while (test_and_clear_bit(handle, ioc->blocking_handles));\r\n} else if (event_data->ExpStatus == MPI2_EVENT_SAS_TOPO_ES_RESPONDING)\r\n_scsih_block_io_to_children_attached_directly(ioc, event_data);\r\nif (event_data->ExpStatus != MPI2_EVENT_SAS_TOPO_ES_NOT_RESPONDING)\r\nreturn;\r\nspin_lock_irqsave(&ioc->fw_event_lock, flags);\r\nlist_for_each_entry(fw_event, &ioc->fw_event_list, list) {\r\nif (fw_event->event != MPI2_EVENT_SAS_TOPOLOGY_CHANGE_LIST ||\r\nfw_event->ignore)\r\ncontinue;\r\nlocal_event_data = (Mpi2EventDataSasTopologyChangeList_t *)\r\nfw_event->event_data;\r\nif (local_event_data->ExpStatus ==\r\nMPI2_EVENT_SAS_TOPO_ES_ADDED ||\r\nlocal_event_data->ExpStatus ==\r\nMPI2_EVENT_SAS_TOPO_ES_RESPONDING) {\r\nif (le16_to_cpu(local_event_data->ExpanderDevHandle) ==\r\nexpander_handle) {\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT\r\n"setting ignoring flag\n", ioc->name));\r\nfw_event->ignore = 1;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\r\n}\r\nstatic void\r\n_scsih_set_volume_delete_flag(struct MPT2SAS_ADAPTER *ioc, u16 handle)\r\n{\r\nstruct _raid_device *raid_device;\r\nstruct MPT2SAS_TARGET *sas_target_priv_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ioc->raid_device_lock, flags);\r\nraid_device = _scsih_raid_device_find_by_handle(ioc, handle);\r\nif (raid_device && raid_device->starget &&\r\nraid_device->starget->hostdata) {\r\nsas_target_priv_data =\r\nraid_device->starget->hostdata;\r\nsas_target_priv_data->deleted = 1;\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT\r\n"setting delete flag: handle(0x%04x), "\r\n"wwid(0x%016llx)\n", ioc->name, handle,\r\n(unsigned long long) raid_device->wwid));\r\n}\r\nspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\r\n}\r\nstatic void\r\n_scsih_set_volume_handle_for_tr(u16 handle, u16 *a, u16 *b)\r\n{\r\nif (!handle || handle == *a || handle == *b)\r\nreturn;\r\nif (!*a)\r\n*a = handle;\r\nelse if (!*b)\r\n*b = handle;\r\n}\r\nstatic void\r\n_scsih_check_ir_config_unhide_events(struct MPT2SAS_ADAPTER *ioc,\r\nMpi2EventDataIrConfigChangeList_t *event_data)\r\n{\r\nMpi2EventIrConfigElement_t *element;\r\nint i;\r\nu16 handle, volume_handle, a, b;\r\nstruct _tr_list *delayed_tr;\r\na = 0;\r\nb = 0;\r\nif (ioc->is_warpdrive)\r\nreturn;\r\nelement = (Mpi2EventIrConfigElement_t *)&event_data->ConfigElement[0];\r\nfor (i = 0; i < event_data->NumElements; i++, element++) {\r\nif (element->ReasonCode ==\r\nMPI2_EVENT_IR_CHANGE_RC_VOLUME_DELETED ||\r\nelement->ReasonCode ==\r\nMPI2_EVENT_IR_CHANGE_RC_REMOVED) {\r\nvolume_handle = le16_to_cpu(element->VolDevHandle);\r\n_scsih_set_volume_delete_flag(ioc, volume_handle);\r\n_scsih_set_volume_handle_for_tr(volume_handle, &a, &b);\r\n}\r\n}\r\nelement = (Mpi2EventIrConfigElement_t *)&event_data->ConfigElement[0];\r\nfor (i = 0; i < event_data->NumElements; i++, element++) {\r\nif (le32_to_cpu(event_data->Flags) &\r\nMPI2_EVENT_IR_CHANGE_FLAGS_FOREIGN_CONFIG)\r\ncontinue;\r\nif (element->ReasonCode == MPI2_EVENT_IR_CHANGE_RC_UNHIDE) {\r\nvolume_handle = le16_to_cpu(element->VolDevHandle);\r\n_scsih_set_volume_handle_for_tr(volume_handle, &a, &b);\r\n}\r\n}\r\nif (a)\r\n_scsih_tm_tr_volume_send(ioc, a);\r\nif (b)\r\n_scsih_tm_tr_volume_send(ioc, b);\r\nelement = (Mpi2EventIrConfigElement_t *)&event_data->ConfigElement[0];\r\nfor (i = 0; i < event_data->NumElements; i++, element++) {\r\nif (element->ReasonCode != MPI2_EVENT_IR_CHANGE_RC_UNHIDE)\r\ncontinue;\r\nhandle = le16_to_cpu(element->PhysDiskDevHandle);\r\nvolume_handle = le16_to_cpu(element->VolDevHandle);\r\nclear_bit(handle, ioc->pd_handles);\r\nif (!volume_handle)\r\n_scsih_tm_tr_send(ioc, handle);\r\nelse if (volume_handle == a || volume_handle == b) {\r\ndelayed_tr = kzalloc(sizeof(*delayed_tr), GFP_ATOMIC);\r\nBUG_ON(!delayed_tr);\r\nINIT_LIST_HEAD(&delayed_tr->list);\r\ndelayed_tr->handle = handle;\r\nlist_add_tail(&delayed_tr->list, &ioc->delayed_tr_list);\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT\r\n"DELAYED:tr:handle(0x%04x), (open)\n", ioc->name,\r\nhandle));\r\n} else\r\n_scsih_tm_tr_send(ioc, handle);\r\n}\r\n}\r\nstatic void\r\n_scsih_check_volume_delete_events(struct MPT2SAS_ADAPTER *ioc,\r\nMpi2EventDataIrVolume_t *event_data)\r\n{\r\nu32 state;\r\nif (event_data->ReasonCode != MPI2_EVENT_IR_VOLUME_RC_STATE_CHANGED)\r\nreturn;\r\nstate = le32_to_cpu(event_data->NewValue);\r\nif (state == MPI2_RAID_VOL_STATE_MISSING || state ==\r\nMPI2_RAID_VOL_STATE_FAILED)\r\n_scsih_set_volume_delete_flag(ioc,\r\nle16_to_cpu(event_data->VolDevHandle));\r\n}\r\nstatic void\r\n_scsih_temp_threshold_events(struct MPT2SAS_ADAPTER *ioc,\r\nMpi2EventDataTemperature_t *event_data)\r\n{\r\nif (ioc->temp_sensors_count >= event_data->SensorNum) {\r\nprintk(MPT2SAS_ERR_FMT "Temperature Threshold flags %s%s%s%s"\r\n" exceeded for Sensor: %d !!!\n", ioc->name,\r\n((le16_to_cpu(event_data->Status) & 0x1) == 1) ? "0 " : " ",\r\n((le16_to_cpu(event_data->Status) & 0x2) == 2) ? "1 " : " ",\r\n((le16_to_cpu(event_data->Status) & 0x4) == 4) ? "2 " : " ",\r\n((le16_to_cpu(event_data->Status) & 0x8) == 8) ? "3 " : " ",\r\nevent_data->SensorNum);\r\nprintk(MPT2SAS_ERR_FMT "Current Temp In Celsius: %d\n",\r\nioc->name, event_data->CurrentTemperature);\r\n}\r\n}\r\nstatic void\r\n_scsih_flush_running_cmds(struct MPT2SAS_ADAPTER *ioc)\r\n{\r\nstruct scsi_cmnd *scmd;\r\nu16 smid;\r\nu16 count = 0;\r\nfor (smid = 1; smid <= ioc->scsiio_depth; smid++) {\r\nscmd = _scsih_scsi_lookup_get_clear(ioc, smid);\r\nif (!scmd)\r\ncontinue;\r\ncount++;\r\nmpt2sas_base_free_smid(ioc, smid);\r\nscsi_dma_unmap(scmd);\r\nif (ioc->pci_error_recovery)\r\nscmd->result = DID_NO_CONNECT << 16;\r\nelse\r\nscmd->result = DID_RESET << 16;\r\nscmd->scsi_done(scmd);\r\n}\r\ndtmprintk(ioc, printk(MPT2SAS_INFO_FMT "completing %d cmds\n",\r\nioc->name, count));\r\n}\r\nstatic void\r\n_scsih_setup_eedp(struct scsi_cmnd *scmd, Mpi2SCSIIORequest_t *mpi_request)\r\n{\r\nu16 eedp_flags;\r\nunsigned char prot_op = scsi_get_prot_op(scmd);\r\nunsigned char prot_type = scsi_get_prot_type(scmd);\r\nif (prot_type == SCSI_PROT_DIF_TYPE0 || prot_op == SCSI_PROT_NORMAL)\r\nreturn;\r\nif (prot_op == SCSI_PROT_READ_STRIP)\r\needp_flags = MPI2_SCSIIO_EEDPFLAGS_CHECK_REMOVE_OP;\r\nelse if (prot_op == SCSI_PROT_WRITE_INSERT)\r\needp_flags = MPI2_SCSIIO_EEDPFLAGS_INSERT_OP;\r\nelse\r\nreturn;\r\nswitch (prot_type) {\r\ncase SCSI_PROT_DIF_TYPE1:\r\ncase SCSI_PROT_DIF_TYPE2:\r\needp_flags |= MPI2_SCSIIO_EEDPFLAGS_INC_PRI_REFTAG |\r\nMPI2_SCSIIO_EEDPFLAGS_CHECK_REFTAG |\r\nMPI2_SCSIIO_EEDPFLAGS_CHECK_GUARD;\r\nmpi_request->CDB.EEDP32.PrimaryReferenceTag =\r\ncpu_to_be32(scsi_get_lba(scmd));\r\nbreak;\r\ncase SCSI_PROT_DIF_TYPE3:\r\needp_flags |= MPI2_SCSIIO_EEDPFLAGS_CHECK_GUARD;\r\nbreak;\r\n}\r\nmpi_request->EEDPBlockSize = cpu_to_le32(scmd->device->sector_size);\r\nmpi_request->EEDPFlags = cpu_to_le16(eedp_flags);\r\n}\r\nstatic void\r\n_scsih_eedp_error_handling(struct scsi_cmnd *scmd, u16 ioc_status)\r\n{\r\nu8 ascq;\r\nswitch (ioc_status) {\r\ncase MPI2_IOCSTATUS_EEDP_GUARD_ERROR:\r\nascq = 0x01;\r\nbreak;\r\ncase MPI2_IOCSTATUS_EEDP_APP_TAG_ERROR:\r\nascq = 0x02;\r\nbreak;\r\ncase MPI2_IOCSTATUS_EEDP_REF_TAG_ERROR:\r\nascq = 0x03;\r\nbreak;\r\ndefault:\r\nascq = 0x00;\r\nbreak;\r\n}\r\nscsi_build_sense_buffer(0, scmd->sense_buffer, ILLEGAL_REQUEST, 0x10, ascq);\r\nscmd->result = DRIVER_SENSE << 24 | (DID_ABORT << 16) |\r\nSAM_STAT_CHECK_CONDITION;\r\n}\r\nstatic inline u8\r\n_scsih_scsi_direct_io_get(struct MPT2SAS_ADAPTER *ioc, u16 smid)\r\n{\r\nreturn ioc->scsi_lookup[smid - 1].direct_io;\r\n}\r\nstatic inline void\r\n_scsih_scsi_direct_io_set(struct MPT2SAS_ADAPTER *ioc, u16 smid, u8 direct_io)\r\n{\r\nioc->scsi_lookup[smid - 1].direct_io = direct_io;\r\n}\r\nstatic void\r\n_scsih_setup_direct_io(struct MPT2SAS_ADAPTER *ioc, struct scsi_cmnd *scmd,\r\nstruct _raid_device *raid_device, Mpi2SCSIIORequest_t *mpi_request,\r\nu16 smid)\r\n{\r\nsector_t v_lba, p_lba, stripe_off, column, io_size;\r\nu32 stripe_sz, stripe_exp;\r\nu8 num_pds, cmd = scmd->cmnd[0];\r\nif (cmd != READ_10 && cmd != WRITE_10 &&\r\ncmd != READ_16 && cmd != WRITE_16)\r\nreturn;\r\nif (cmd == READ_10 || cmd == WRITE_10)\r\nv_lba = get_unaligned_be32(&mpi_request->CDB.CDB32[2]);\r\nelse\r\nv_lba = get_unaligned_be64(&mpi_request->CDB.CDB32[2]);\r\nio_size = scsi_bufflen(scmd) >> raid_device->block_exponent;\r\nif (v_lba + io_size - 1 > raid_device->max_lba)\r\nreturn;\r\nstripe_sz = raid_device->stripe_sz;\r\nstripe_exp = raid_device->stripe_exponent;\r\nstripe_off = v_lba & (stripe_sz - 1);\r\nif (stripe_off + io_size > stripe_sz)\r\nreturn;\r\nnum_pds = raid_device->num_pds;\r\np_lba = v_lba >> stripe_exp;\r\ncolumn = sector_div(p_lba, num_pds);\r\np_lba = (p_lba << stripe_exp) + stripe_off;\r\nmpi_request->DevHandle = cpu_to_le16(raid_device->pd_handle[column]);\r\nif (cmd == READ_10 || cmd == WRITE_10)\r\nput_unaligned_be32(lower_32_bits(p_lba),\r\n&mpi_request->CDB.CDB32[2]);\r\nelse\r\nput_unaligned_be64(p_lba, &mpi_request->CDB.CDB32[2]);\r\n_scsih_scsi_direct_io_set(ioc, smid, 1);\r\n}\r\nstatic int\r\n_scsih_qcmd(struct Scsi_Host *shost, struct scsi_cmnd *scmd)\r\n{\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nstruct MPT2SAS_DEVICE *sas_device_priv_data;\r\nstruct MPT2SAS_TARGET *sas_target_priv_data;\r\nstruct _raid_device *raid_device;\r\nMpi2SCSIIORequest_t *mpi_request;\r\nu32 mpi_control;\r\nu16 smid;\r\nsas_device_priv_data = scmd->device->hostdata;\r\nif (!sas_device_priv_data || !sas_device_priv_data->sas_target) {\r\nscmd->result = DID_NO_CONNECT << 16;\r\nscmd->scsi_done(scmd);\r\nreturn 0;\r\n}\r\nif (ioc->pci_error_recovery || ioc->remove_host) {\r\nscmd->result = DID_NO_CONNECT << 16;\r\nscmd->scsi_done(scmd);\r\nreturn 0;\r\n}\r\nsas_target_priv_data = sas_device_priv_data->sas_target;\r\nif (sas_target_priv_data->handle == MPT2SAS_INVALID_DEVICE_HANDLE) {\r\nscmd->result = DID_NO_CONNECT << 16;\r\nscmd->scsi_done(scmd);\r\nreturn 0;\r\n}\r\nif (ioc->shost_recovery || ioc->ioc_link_reset_in_progress)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nelse if (sas_device_priv_data->block || sas_target_priv_data->tm_busy)\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\nelse if (sas_target_priv_data->deleted) {\r\nscmd->result = DID_NO_CONNECT << 16;\r\nscmd->scsi_done(scmd);\r\nreturn 0;\r\n}\r\nif (scmd->sc_data_direction == DMA_FROM_DEVICE)\r\nmpi_control = MPI2_SCSIIO_CONTROL_READ;\r\nelse if (scmd->sc_data_direction == DMA_TO_DEVICE)\r\nmpi_control = MPI2_SCSIIO_CONTROL_WRITE;\r\nelse\r\nmpi_control = MPI2_SCSIIO_CONTROL_NODATATRANSFER;\r\nmpi_control |= MPI2_SCSIIO_CONTROL_SIMPLEQ;\r\nif (!ioc->is_warpdrive && !_scsih_is_raid(&scmd->device->sdev_gendev) &&\r\nsas_is_tlr_enabled(scmd->device) && scmd->cmd_len != 32)\r\nmpi_control |= MPI2_SCSIIO_CONTROL_TLR_ON;\r\nsmid = mpt2sas_base_get_smid_scsiio(ioc, ioc->scsi_io_cb_idx, scmd);\r\nif (!smid) {\r\nprintk(MPT2SAS_ERR_FMT "%s: failed obtaining a smid\n",\r\nioc->name, __func__);\r\ngoto out;\r\n}\r\nmpi_request = mpt2sas_base_get_msg_frame(ioc, smid);\r\nmemset(mpi_request, 0, sizeof(Mpi2SCSIIORequest_t));\r\n_scsih_setup_eedp(scmd, mpi_request);\r\nif (scmd->cmd_len == 32)\r\nmpi_control |= 4 << MPI2_SCSIIO_CONTROL_ADDCDBLEN_SHIFT;\r\nmpi_request->Function = MPI2_FUNCTION_SCSI_IO_REQUEST;\r\nif (sas_device_priv_data->sas_target->flags &\r\nMPT_TARGET_FLAGS_RAID_COMPONENT)\r\nmpi_request->Function = MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH;\r\nelse\r\nmpi_request->Function = MPI2_FUNCTION_SCSI_IO_REQUEST;\r\nmpi_request->DevHandle =\r\ncpu_to_le16(sas_device_priv_data->sas_target->handle);\r\nmpi_request->DataLength = cpu_to_le32(scsi_bufflen(scmd));\r\nmpi_request->Control = cpu_to_le32(mpi_control);\r\nmpi_request->IoFlags = cpu_to_le16(scmd->cmd_len);\r\nmpi_request->MsgFlags = MPI2_SCSIIO_MSGFLAGS_SYSTEM_SENSE_ADDR;\r\nmpi_request->SenseBufferLength = SCSI_SENSE_BUFFERSIZE;\r\nmpi_request->SenseBufferLowAddress =\r\nmpt2sas_base_get_sense_buffer_dma(ioc, smid);\r\nmpi_request->SGLOffset0 = offsetof(Mpi2SCSIIORequest_t, SGL) / 4;\r\nmpi_request->SGLFlags = cpu_to_le16(MPI2_SCSIIO_SGLFLAGS_TYPE_MPI +\r\nMPI2_SCSIIO_SGLFLAGS_SYSTEM_ADDR);\r\nmpi_request->VF_ID = 0;\r\nmpi_request->VP_ID = 0;\r\nint_to_scsilun(sas_device_priv_data->lun, (struct scsi_lun *)\r\nmpi_request->LUN);\r\nmemcpy(mpi_request->CDB.CDB32, scmd->cmnd, scmd->cmd_len);\r\nif (!mpi_request->DataLength) {\r\nmpt2sas_base_build_zero_len_sge(ioc, &mpi_request->SGL);\r\n} else {\r\nif (_scsih_build_scatter_gather(ioc, scmd, smid)) {\r\nmpt2sas_base_free_smid(ioc, smid);\r\ngoto out;\r\n}\r\n}\r\nraid_device = sas_target_priv_data->raid_device;\r\nif (raid_device && raid_device->direct_io_enabled)\r\n_scsih_setup_direct_io(ioc, scmd, raid_device, mpi_request,\r\nsmid);\r\nif (likely(mpi_request->Function == MPI2_FUNCTION_SCSI_IO_REQUEST))\r\nmpt2sas_base_put_smid_scsi_io(ioc, smid,\r\nle16_to_cpu(mpi_request->DevHandle));\r\nelse\r\nmpt2sas_base_put_smid_default(ioc, smid);\r\nreturn 0;\r\nout:\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\nstatic void\r\n_scsih_normalize_sense(char *sense_buffer, struct sense_info *data)\r\n{\r\nif ((sense_buffer[0] & 0x7F) >= 0x72) {\r\ndata->skey = sense_buffer[1] & 0x0F;\r\ndata->asc = sense_buffer[2];\r\ndata->ascq = sense_buffer[3];\r\n} else {\r\ndata->skey = sense_buffer[2] & 0x0F;\r\ndata->asc = sense_buffer[12];\r\ndata->ascq = sense_buffer[13];\r\n}\r\n}\r\nstatic void\r\n_scsih_scsi_ioc_info(struct MPT2SAS_ADAPTER *ioc, struct scsi_cmnd *scmd,\r\nMpi2SCSIIOReply_t *mpi_reply, u16 smid)\r\n{\r\nu32 response_info;\r\nu8 *response_bytes;\r\nu16 ioc_status = le16_to_cpu(mpi_reply->IOCStatus) &\r\nMPI2_IOCSTATUS_MASK;\r\nu8 scsi_state = mpi_reply->SCSIState;\r\nu8 scsi_status = mpi_reply->SCSIStatus;\r\nchar *desc_ioc_state = NULL;\r\nchar *desc_scsi_status = NULL;\r\nchar *desc_scsi_state = ioc->tmp_string;\r\nu32 log_info = le32_to_cpu(mpi_reply->IOCLogInfo);\r\nstruct _sas_device *sas_device = NULL;\r\nunsigned long flags;\r\nstruct scsi_target *starget = scmd->device->sdev_target;\r\nstruct MPT2SAS_TARGET *priv_target = starget->hostdata;\r\nchar *device_str = NULL;\r\nif (!priv_target)\r\nreturn;\r\nif (ioc->hide_ir_msg)\r\ndevice_str = "WarpDrive";\r\nelse\r\ndevice_str = "volume";\r\nif (log_info == 0x31170000)\r\nreturn;\r\nswitch (ioc_status) {\r\ncase MPI2_IOCSTATUS_SUCCESS:\r\ndesc_ioc_state = "success";\r\nbreak;\r\ncase MPI2_IOCSTATUS_INVALID_FUNCTION:\r\ndesc_ioc_state = "invalid function";\r\nbreak;\r\ncase MPI2_IOCSTATUS_SCSI_RECOVERED_ERROR:\r\ndesc_ioc_state = "scsi recovered error";\r\nbreak;\r\ncase MPI2_IOCSTATUS_SCSI_INVALID_DEVHANDLE:\r\ndesc_ioc_state = "scsi invalid dev handle";\r\nbreak;\r\ncase MPI2_IOCSTATUS_SCSI_DEVICE_NOT_THERE:\r\ndesc_ioc_state = "scsi device not there";\r\nbreak;\r\ncase MPI2_IOCSTATUS_SCSI_DATA_OVERRUN:\r\ndesc_ioc_state = "scsi data overrun";\r\nbreak;\r\ncase MPI2_IOCSTATUS_SCSI_DATA_UNDERRUN:\r\ndesc_ioc_state = "scsi data underrun";\r\nbreak;\r\ncase MPI2_IOCSTATUS_SCSI_IO_DATA_ERROR:\r\ndesc_ioc_state = "scsi io data error";\r\nbreak;\r\ncase MPI2_IOCSTATUS_SCSI_PROTOCOL_ERROR:\r\ndesc_ioc_state = "scsi protocol error";\r\nbreak;\r\ncase MPI2_IOCSTATUS_SCSI_TASK_TERMINATED:\r\ndesc_ioc_state = "scsi task terminated";\r\nbreak;\r\ncase MPI2_IOCSTATUS_SCSI_RESIDUAL_MISMATCH:\r\ndesc_ioc_state = "scsi residual mismatch";\r\nbreak;\r\ncase MPI2_IOCSTATUS_SCSI_TASK_MGMT_FAILED:\r\ndesc_ioc_state = "scsi task mgmt failed";\r\nbreak;\r\ncase MPI2_IOCSTATUS_SCSI_IOC_TERMINATED:\r\ndesc_ioc_state = "scsi ioc terminated";\r\nbreak;\r\ncase MPI2_IOCSTATUS_SCSI_EXT_TERMINATED:\r\ndesc_ioc_state = "scsi ext terminated";\r\nbreak;\r\ncase MPI2_IOCSTATUS_EEDP_GUARD_ERROR:\r\ndesc_ioc_state = "eedp guard error";\r\nbreak;\r\ncase MPI2_IOCSTATUS_EEDP_REF_TAG_ERROR:\r\ndesc_ioc_state = "eedp ref tag error";\r\nbreak;\r\ncase MPI2_IOCSTATUS_EEDP_APP_TAG_ERROR:\r\ndesc_ioc_state = "eedp app tag error";\r\nbreak;\r\ndefault:\r\ndesc_ioc_state = "unknown";\r\nbreak;\r\n}\r\nswitch (scsi_status) {\r\ncase MPI2_SCSI_STATUS_GOOD:\r\ndesc_scsi_status = "good";\r\nbreak;\r\ncase MPI2_SCSI_STATUS_CHECK_CONDITION:\r\ndesc_scsi_status = "check condition";\r\nbreak;\r\ncase MPI2_SCSI_STATUS_CONDITION_MET:\r\ndesc_scsi_status = "condition met";\r\nbreak;\r\ncase MPI2_SCSI_STATUS_BUSY:\r\ndesc_scsi_status = "busy";\r\nbreak;\r\ncase MPI2_SCSI_STATUS_INTERMEDIATE:\r\ndesc_scsi_status = "intermediate";\r\nbreak;\r\ncase MPI2_SCSI_STATUS_INTERMEDIATE_CONDMET:\r\ndesc_scsi_status = "intermediate condmet";\r\nbreak;\r\ncase MPI2_SCSI_STATUS_RESERVATION_CONFLICT:\r\ndesc_scsi_status = "reservation conflict";\r\nbreak;\r\ncase MPI2_SCSI_STATUS_COMMAND_TERMINATED:\r\ndesc_scsi_status = "command terminated";\r\nbreak;\r\ncase MPI2_SCSI_STATUS_TASK_SET_FULL:\r\ndesc_scsi_status = "task set full";\r\nbreak;\r\ncase MPI2_SCSI_STATUS_ACA_ACTIVE:\r\ndesc_scsi_status = "aca active";\r\nbreak;\r\ncase MPI2_SCSI_STATUS_TASK_ABORTED:\r\ndesc_scsi_status = "task aborted";\r\nbreak;\r\ndefault:\r\ndesc_scsi_status = "unknown";\r\nbreak;\r\n}\r\ndesc_scsi_state[0] = '\0';\r\nif (!scsi_state)\r\ndesc_scsi_state = " ";\r\nif (scsi_state & MPI2_SCSI_STATE_RESPONSE_INFO_VALID)\r\nstrcat(desc_scsi_state, "response info ");\r\nif (scsi_state & MPI2_SCSI_STATE_TERMINATED)\r\nstrcat(desc_scsi_state, "state terminated ");\r\nif (scsi_state & MPI2_SCSI_STATE_NO_SCSI_STATUS)\r\nstrcat(desc_scsi_state, "no status ");\r\nif (scsi_state & MPI2_SCSI_STATE_AUTOSENSE_FAILED)\r\nstrcat(desc_scsi_state, "autosense failed ");\r\nif (scsi_state & MPI2_SCSI_STATE_AUTOSENSE_VALID)\r\nstrcat(desc_scsi_state, "autosense valid ");\r\nscsi_print_command(scmd);\r\nif (priv_target->flags & MPT_TARGET_FLAGS_VOLUME) {\r\nprintk(MPT2SAS_WARN_FMT "\t%s wwid(0x%016llx)\n", ioc->name,\r\ndevice_str, (unsigned long long)priv_target->sas_address);\r\n} else {\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nsas_device = mpt2sas_scsih_sas_device_find_by_sas_address(ioc,\r\npriv_target->sas_address);\r\nif (sas_device) {\r\nprintk(MPT2SAS_WARN_FMT "\tsas_address(0x%016llx), "\r\n"phy(%d)\n", ioc->name, sas_device->sas_address,\r\nsas_device->phy);\r\nprintk(MPT2SAS_WARN_FMT\r\n"\tenclosure_logical_id(0x%016llx), slot(%d)\n",\r\nioc->name, sas_device->enclosure_logical_id,\r\nsas_device->slot);\r\n}\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\n}\r\nprintk(MPT2SAS_WARN_FMT "\thandle(0x%04x), ioc_status(%s)(0x%04x), "\r\n"smid(%d)\n", ioc->name, le16_to_cpu(mpi_reply->DevHandle),\r\ndesc_ioc_state, ioc_status, smid);\r\nprintk(MPT2SAS_WARN_FMT "\trequest_len(%d), underflow(%d), "\r\n"resid(%d)\n", ioc->name, scsi_bufflen(scmd), scmd->underflow,\r\nscsi_get_resid(scmd));\r\nprintk(MPT2SAS_WARN_FMT "\ttag(%d), transfer_count(%d), "\r\n"sc->result(0x%08x)\n", ioc->name, le16_to_cpu(mpi_reply->TaskTag),\r\nle32_to_cpu(mpi_reply->TransferCount), scmd->result);\r\nprintk(MPT2SAS_WARN_FMT "\tscsi_status(%s)(0x%02x), "\r\n"scsi_state(%s)(0x%02x)\n", ioc->name, desc_scsi_status,\r\nscsi_status, desc_scsi_state, scsi_state);\r\nif (scsi_state & MPI2_SCSI_STATE_AUTOSENSE_VALID) {\r\nstruct sense_info data;\r\n_scsih_normalize_sense(scmd->sense_buffer, &data);\r\nprintk(MPT2SAS_WARN_FMT "\t[sense_key,asc,ascq]: "\r\n"[0x%02x,0x%02x,0x%02x], count(%d)\n", ioc->name, data.skey,\r\ndata.asc, data.ascq, le32_to_cpu(mpi_reply->SenseCount));\r\n}\r\nif (scsi_state & MPI2_SCSI_STATE_RESPONSE_INFO_VALID) {\r\nresponse_info = le32_to_cpu(mpi_reply->ResponseInfo);\r\nresponse_bytes = (u8 *)&response_info;\r\n_scsih_response_code(ioc, response_bytes[0]);\r\n}\r\n}\r\nstatic void\r\n_scsih_turn_on_pfa_led(struct MPT2SAS_ADAPTER *ioc, u16 handle)\r\n{\r\nMpi2SepReply_t mpi_reply;\r\nMpi2SepRequest_t mpi_request;\r\nstruct _sas_device *sas_device;\r\nsas_device = _scsih_sas_device_find_by_handle(ioc, handle);\r\nif (!sas_device)\r\nreturn;\r\nmemset(&mpi_request, 0, sizeof(Mpi2SepRequest_t));\r\nmpi_request.Function = MPI2_FUNCTION_SCSI_ENCLOSURE_PROCESSOR;\r\nmpi_request.Action = MPI2_SEP_REQ_ACTION_WRITE_STATUS;\r\nmpi_request.SlotStatus =\r\ncpu_to_le32(MPI2_SEP_REQ_SLOTSTATUS_PREDICTED_FAULT);\r\nmpi_request.DevHandle = cpu_to_le16(handle);\r\nmpi_request.Flags = MPI2_SEP_REQ_FLAGS_DEVHANDLE_ADDRESS;\r\nif ((mpt2sas_base_scsi_enclosure_processor(ioc, &mpi_reply,\r\n&mpi_request)) != 0) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n", ioc->name,\r\n__FILE__, __LINE__, __func__);\r\nreturn;\r\n}\r\nsas_device->pfa_led_on = 1;\r\nif (mpi_reply.IOCStatus || mpi_reply.IOCLogInfo) {\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT\r\n"enclosure_processor: ioc_status (0x%04x), loginfo(0x%08x)\n",\r\nioc->name, le16_to_cpu(mpi_reply.IOCStatus),\r\nle32_to_cpu(mpi_reply.IOCLogInfo)));\r\nreturn;\r\n}\r\n}\r\nstatic void\r\n_scsih_turn_off_pfa_led(struct MPT2SAS_ADAPTER *ioc,\r\nstruct _sas_device *sas_device)\r\n{\r\nMpi2SepReply_t mpi_reply;\r\nMpi2SepRequest_t mpi_request;\r\nmemset(&mpi_request, 0, sizeof(Mpi2SepRequest_t));\r\nmpi_request.Function = MPI2_FUNCTION_SCSI_ENCLOSURE_PROCESSOR;\r\nmpi_request.Action = MPI2_SEP_REQ_ACTION_WRITE_STATUS;\r\nmpi_request.SlotStatus = 0;\r\nmpi_request.Slot = cpu_to_le16(sas_device->slot);\r\nmpi_request.DevHandle = 0;\r\nmpi_request.EnclosureHandle = cpu_to_le16(sas_device->enclosure_handle);\r\nmpi_request.Flags = MPI2_SEP_REQ_FLAGS_ENCLOSURE_SLOT_ADDRESS;\r\nif ((mpt2sas_base_scsi_enclosure_processor(ioc, &mpi_reply,\r\n&mpi_request)) != 0) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n", ioc->name,\r\n__FILE__, __LINE__, __func__);\r\nreturn;\r\n}\r\nif (mpi_reply.IOCStatus || mpi_reply.IOCLogInfo) {\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT "enclosure_processor: "\r\n"ioc_status (0x%04x), loginfo(0x%08x)\n", ioc->name,\r\nle16_to_cpu(mpi_reply.IOCStatus),\r\nle32_to_cpu(mpi_reply.IOCLogInfo)));\r\nreturn;\r\n}\r\n}\r\nstatic void\r\n_scsih_send_event_to_turn_on_pfa_led(struct MPT2SAS_ADAPTER *ioc, u16 handle)\r\n{\r\nstruct fw_event_work *fw_event;\r\nfw_event = kzalloc(sizeof(struct fw_event_work), GFP_ATOMIC);\r\nif (!fw_event)\r\nreturn;\r\nfw_event->event = MPT2SAS_TURN_ON_PFA_LED;\r\nfw_event->device_handle = handle;\r\nfw_event->ioc = ioc;\r\n_scsih_fw_event_add(ioc, fw_event);\r\n}\r\nstatic void\r\n_scsih_smart_predicted_fault(struct MPT2SAS_ADAPTER *ioc, u16 handle)\r\n{\r\nstruct scsi_target *starget;\r\nstruct MPT2SAS_TARGET *sas_target_priv_data;\r\nMpi2EventNotificationReply_t *event_reply;\r\nMpi2EventDataSasDeviceStatusChange_t *event_data;\r\nstruct _sas_device *sas_device;\r\nssize_t sz;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nsas_device = _scsih_sas_device_find_by_handle(ioc, handle);\r\nif (!sas_device) {\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\nreturn;\r\n}\r\nstarget = sas_device->starget;\r\nsas_target_priv_data = starget->hostdata;\r\nif ((sas_target_priv_data->flags & MPT_TARGET_FLAGS_RAID_COMPONENT) ||\r\n((sas_target_priv_data->flags & MPT_TARGET_FLAGS_VOLUME))) {\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\nreturn;\r\n}\r\nstarget_printk(KERN_WARNING, starget, "predicted fault\n");\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\nif (ioc->pdev->subsystem_vendor == PCI_VENDOR_ID_IBM)\r\n_scsih_send_event_to_turn_on_pfa_led(ioc, handle);\r\nsz = offsetof(Mpi2EventNotificationReply_t, EventData) +\r\nsizeof(Mpi2EventDataSasDeviceStatusChange_t);\r\nevent_reply = kzalloc(sz, GFP_ATOMIC);\r\nif (!event_reply) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn;\r\n}\r\nevent_reply->Function = MPI2_FUNCTION_EVENT_NOTIFICATION;\r\nevent_reply->Event =\r\ncpu_to_le16(MPI2_EVENT_SAS_DEVICE_STATUS_CHANGE);\r\nevent_reply->MsgLength = sz/4;\r\nevent_reply->EventDataLength =\r\ncpu_to_le16(sizeof(Mpi2EventDataSasDeviceStatusChange_t)/4);\r\nevent_data = (Mpi2EventDataSasDeviceStatusChange_t *)\r\nevent_reply->EventData;\r\nevent_data->ReasonCode = MPI2_EVENT_SAS_DEV_STAT_RC_SMART_DATA;\r\nevent_data->ASC = 0x5D;\r\nevent_data->DevHandle = cpu_to_le16(handle);\r\nevent_data->SASAddress = cpu_to_le64(sas_target_priv_data->sas_address);\r\nmpt2sas_ctl_add_to_event_log(ioc, event_reply);\r\nkfree(event_reply);\r\n}\r\nstatic u8\r\n_scsih_io_done(struct MPT2SAS_ADAPTER *ioc, u16 smid, u8 msix_index, u32 reply)\r\n{\r\nMpi2SCSIIORequest_t *mpi_request;\r\nMpi2SCSIIOReply_t *mpi_reply;\r\nstruct scsi_cmnd *scmd;\r\nu16 ioc_status;\r\nu32 xfer_cnt;\r\nu8 scsi_state;\r\nu8 scsi_status;\r\nu32 log_info;\r\nstruct MPT2SAS_DEVICE *sas_device_priv_data;\r\nu32 response_code = 0;\r\nunsigned long flags;\r\nmpi_reply = mpt2sas_base_get_reply_virt_addr(ioc, reply);\r\nscmd = _scsih_scsi_lookup_get_clear(ioc, smid);\r\nif (scmd == NULL)\r\nreturn 1;\r\nmpi_request = mpt2sas_base_get_msg_frame(ioc, smid);\r\nif (mpi_reply == NULL) {\r\nscmd->result = DID_OK << 16;\r\ngoto out;\r\n}\r\nsas_device_priv_data = scmd->device->hostdata;\r\nif (!sas_device_priv_data || !sas_device_priv_data->sas_target ||\r\nsas_device_priv_data->sas_target->deleted) {\r\nscmd->result = DID_NO_CONNECT << 16;\r\ngoto out;\r\n}\r\nioc_status = le16_to_cpu(mpi_reply->IOCStatus);\r\nif (_scsih_scsi_direct_io_get(ioc, smid) &&\r\n((ioc_status & MPI2_IOCSTATUS_MASK)\r\n!= MPI2_IOCSTATUS_SCSI_TASK_TERMINATED)) {\r\nspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\r\nioc->scsi_lookup[smid - 1].scmd = scmd;\r\n_scsih_scsi_direct_io_set(ioc, smid, 0);\r\nspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\r\nmemcpy(mpi_request->CDB.CDB32, scmd->cmnd, scmd->cmd_len);\r\nmpi_request->DevHandle =\r\ncpu_to_le16(sas_device_priv_data->sas_target->handle);\r\nmpt2sas_base_put_smid_scsi_io(ioc, smid,\r\nsas_device_priv_data->sas_target->handle);\r\nreturn 0;\r\n}\r\nscsi_state = mpi_reply->SCSIState;\r\nif (scsi_state & MPI2_SCSI_STATE_RESPONSE_INFO_VALID)\r\nresponse_code =\r\nle32_to_cpu(mpi_reply->ResponseInfo) & 0xFF;\r\nif (!sas_device_priv_data->tlr_snoop_check) {\r\nsas_device_priv_data->tlr_snoop_check++;\r\nif (!ioc->is_warpdrive && !_scsih_is_raid(&scmd->device->sdev_gendev) &&\r\nsas_is_tlr_enabled(scmd->device) &&\r\nresponse_code == MPI2_SCSITASKMGMT_RSP_INVALID_FRAME) {\r\nsas_disable_tlr(scmd->device);\r\nsdev_printk(KERN_INFO, scmd->device, "TLR disabled\n");\r\n}\r\n}\r\nxfer_cnt = le32_to_cpu(mpi_reply->TransferCount);\r\nscsi_set_resid(scmd, scsi_bufflen(scmd) - xfer_cnt);\r\nif (ioc_status & MPI2_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE)\r\nlog_info = le32_to_cpu(mpi_reply->IOCLogInfo);\r\nelse\r\nlog_info = 0;\r\nioc_status &= MPI2_IOCSTATUS_MASK;\r\nscsi_status = mpi_reply->SCSIStatus;\r\nif (ioc_status == MPI2_IOCSTATUS_SCSI_DATA_UNDERRUN && xfer_cnt == 0 &&\r\n(scsi_status == MPI2_SCSI_STATUS_BUSY ||\r\nscsi_status == MPI2_SCSI_STATUS_RESERVATION_CONFLICT ||\r\nscsi_status == MPI2_SCSI_STATUS_TASK_SET_FULL)) {\r\nioc_status = MPI2_IOCSTATUS_SUCCESS;\r\n}\r\nif (scsi_state & MPI2_SCSI_STATE_AUTOSENSE_VALID) {\r\nstruct sense_info data;\r\nconst void *sense_data = mpt2sas_base_get_sense_buffer(ioc,\r\nsmid);\r\nu32 sz = min_t(u32, SCSI_SENSE_BUFFERSIZE,\r\nle32_to_cpu(mpi_reply->SenseCount));\r\nmemcpy(scmd->sense_buffer, sense_data, sz);\r\n_scsih_normalize_sense(scmd->sense_buffer, &data);\r\nif (data.asc == 0x5D)\r\n_scsih_smart_predicted_fault(ioc,\r\nle16_to_cpu(mpi_reply->DevHandle));\r\n}\r\nswitch (ioc_status) {\r\ncase MPI2_IOCSTATUS_BUSY:\r\ncase MPI2_IOCSTATUS_INSUFFICIENT_RESOURCES:\r\nscmd->result = SAM_STAT_BUSY;\r\nbreak;\r\ncase MPI2_IOCSTATUS_SCSI_DEVICE_NOT_THERE:\r\nscmd->result = DID_NO_CONNECT << 16;\r\nbreak;\r\ncase MPI2_IOCSTATUS_SCSI_IOC_TERMINATED:\r\nif (sas_device_priv_data->block) {\r\nscmd->result = DID_TRANSPORT_DISRUPTED << 16;\r\ngoto out;\r\n}\r\nif (log_info == 0x32010081) {\r\nscmd->result = DID_RESET << 16;\r\nbreak;\r\n}\r\nscmd->result = DID_SOFT_ERROR << 16;\r\nbreak;\r\ncase MPI2_IOCSTATUS_SCSI_TASK_TERMINATED:\r\ncase MPI2_IOCSTATUS_SCSI_EXT_TERMINATED:\r\nscmd->result = DID_RESET << 16;\r\nbreak;\r\ncase MPI2_IOCSTATUS_SCSI_RESIDUAL_MISMATCH:\r\nif ((xfer_cnt == 0) || (scmd->underflow > xfer_cnt))\r\nscmd->result = DID_SOFT_ERROR << 16;\r\nelse\r\nscmd->result = (DID_OK << 16) | scsi_status;\r\nbreak;\r\ncase MPI2_IOCSTATUS_SCSI_DATA_UNDERRUN:\r\nscmd->result = (DID_OK << 16) | scsi_status;\r\nif ((scsi_state & MPI2_SCSI_STATE_AUTOSENSE_VALID))\r\nbreak;\r\nif (xfer_cnt < scmd->underflow) {\r\nif (scsi_status == SAM_STAT_BUSY)\r\nscmd->result = SAM_STAT_BUSY;\r\nelse\r\nscmd->result = DID_SOFT_ERROR << 16;\r\n} else if (scsi_state & (MPI2_SCSI_STATE_AUTOSENSE_FAILED |\r\nMPI2_SCSI_STATE_NO_SCSI_STATUS))\r\nscmd->result = DID_SOFT_ERROR << 16;\r\nelse if (scsi_state & MPI2_SCSI_STATE_TERMINATED)\r\nscmd->result = DID_RESET << 16;\r\nelse if (!xfer_cnt && scmd->cmnd[0] == REPORT_LUNS) {\r\nmpi_reply->SCSIState = MPI2_SCSI_STATE_AUTOSENSE_VALID;\r\nmpi_reply->SCSIStatus = SAM_STAT_CHECK_CONDITION;\r\nscmd->result = (DRIVER_SENSE << 24) |\r\nSAM_STAT_CHECK_CONDITION;\r\nscmd->sense_buffer[0] = 0x70;\r\nscmd->sense_buffer[2] = ILLEGAL_REQUEST;\r\nscmd->sense_buffer[12] = 0x20;\r\nscmd->sense_buffer[13] = 0;\r\n}\r\nbreak;\r\ncase MPI2_IOCSTATUS_SCSI_DATA_OVERRUN:\r\nscsi_set_resid(scmd, 0);\r\ncase MPI2_IOCSTATUS_SCSI_RECOVERED_ERROR:\r\ncase MPI2_IOCSTATUS_SUCCESS:\r\nscmd->result = (DID_OK << 16) | scsi_status;\r\nif (response_code ==\r\nMPI2_SCSITASKMGMT_RSP_INVALID_FRAME ||\r\n(scsi_state & (MPI2_SCSI_STATE_AUTOSENSE_FAILED |\r\nMPI2_SCSI_STATE_NO_SCSI_STATUS)))\r\nscmd->result = DID_SOFT_ERROR << 16;\r\nelse if (scsi_state & MPI2_SCSI_STATE_TERMINATED)\r\nscmd->result = DID_RESET << 16;\r\nbreak;\r\ncase MPI2_IOCSTATUS_EEDP_GUARD_ERROR:\r\ncase MPI2_IOCSTATUS_EEDP_REF_TAG_ERROR:\r\ncase MPI2_IOCSTATUS_EEDP_APP_TAG_ERROR:\r\n_scsih_eedp_error_handling(scmd, ioc_status);\r\nbreak;\r\ncase MPI2_IOCSTATUS_SCSI_PROTOCOL_ERROR:\r\ncase MPI2_IOCSTATUS_INVALID_FUNCTION:\r\ncase MPI2_IOCSTATUS_INVALID_SGL:\r\ncase MPI2_IOCSTATUS_INTERNAL_ERROR:\r\ncase MPI2_IOCSTATUS_INVALID_FIELD:\r\ncase MPI2_IOCSTATUS_INVALID_STATE:\r\ncase MPI2_IOCSTATUS_SCSI_IO_DATA_ERROR:\r\ncase MPI2_IOCSTATUS_SCSI_TASK_MGMT_FAILED:\r\ndefault:\r\nscmd->result = DID_SOFT_ERROR << 16;\r\nbreak;\r\n}\r\n#ifdef CONFIG_SCSI_MPT2SAS_LOGGING\r\nif (scmd->result && (ioc->logging_level & MPT_DEBUG_REPLY))\r\n_scsih_scsi_ioc_info(ioc , scmd, mpi_reply, smid);\r\n#endif\r\nout:\r\nscsi_dma_unmap(scmd);\r\nscmd->scsi_done(scmd);\r\nreturn 1;\r\n}\r\nstatic void\r\n_scsih_sas_host_refresh(struct MPT2SAS_ADAPTER *ioc)\r\n{\r\nu16 sz;\r\nu16 ioc_status;\r\nint i;\r\nMpi2ConfigReply_t mpi_reply;\r\nMpi2SasIOUnitPage0_t *sas_iounit_pg0 = NULL;\r\nu16 attached_handle;\r\nu8 link_rate;\r\ndtmprintk(ioc, printk(MPT2SAS_INFO_FMT\r\n"updating handles for sas_host(0x%016llx)\n",\r\nioc->name, (unsigned long long)ioc->sas_hba.sas_address));\r\nsz = offsetof(Mpi2SasIOUnitPage0_t, PhyData) + (ioc->sas_hba.num_phys\r\n* sizeof(Mpi2SasIOUnit0PhyData_t));\r\nsas_iounit_pg0 = kzalloc(sz, GFP_KERNEL);\r\nif (!sas_iounit_pg0) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn;\r\n}\r\nif ((mpt2sas_config_get_sas_iounit_pg0(ioc, &mpi_reply,\r\nsas_iounit_pg0, sz)) != 0)\r\ngoto out;\r\nioc_status = le16_to_cpu(mpi_reply.IOCStatus) & MPI2_IOCSTATUS_MASK;\r\nif (ioc_status != MPI2_IOCSTATUS_SUCCESS)\r\ngoto out;\r\nfor (i = 0; i < ioc->sas_hba.num_phys ; i++) {\r\nlink_rate = sas_iounit_pg0->PhyData[i].NegotiatedLinkRate >> 4;\r\nif (i == 0)\r\nioc->sas_hba.handle = le16_to_cpu(sas_iounit_pg0->\r\nPhyData[0].ControllerDevHandle);\r\nioc->sas_hba.phy[i].handle = ioc->sas_hba.handle;\r\nattached_handle = le16_to_cpu(sas_iounit_pg0->PhyData[i].\r\nAttachedDevHandle);\r\nif (attached_handle && link_rate < MPI2_SAS_NEG_LINK_RATE_1_5)\r\nlink_rate = MPI2_SAS_NEG_LINK_RATE_1_5;\r\nmpt2sas_transport_update_links(ioc, ioc->sas_hba.sas_address,\r\nattached_handle, i, link_rate);\r\n}\r\nout:\r\nkfree(sas_iounit_pg0);\r\n}\r\nstatic void\r\n_scsih_sas_host_add(struct MPT2SAS_ADAPTER *ioc)\r\n{\r\nint i;\r\nMpi2ConfigReply_t mpi_reply;\r\nMpi2SasIOUnitPage0_t *sas_iounit_pg0 = NULL;\r\nMpi2SasIOUnitPage1_t *sas_iounit_pg1 = NULL;\r\nMpi2SasPhyPage0_t phy_pg0;\r\nMpi2SasDevicePage0_t sas_device_pg0;\r\nMpi2SasEnclosurePage0_t enclosure_pg0;\r\nu16 ioc_status;\r\nu16 sz;\r\nu16 device_missing_delay;\r\nmpt2sas_config_get_number_hba_phys(ioc, &ioc->sas_hba.num_phys);\r\nif (!ioc->sas_hba.num_phys) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn;\r\n}\r\nsz = offsetof(Mpi2SasIOUnitPage0_t, PhyData) + (ioc->sas_hba.num_phys *\r\nsizeof(Mpi2SasIOUnit0PhyData_t));\r\nsas_iounit_pg0 = kzalloc(sz, GFP_KERNEL);\r\nif (!sas_iounit_pg0) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn;\r\n}\r\nif ((mpt2sas_config_get_sas_iounit_pg0(ioc, &mpi_reply,\r\nsas_iounit_pg0, sz))) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\ngoto out;\r\n}\r\nioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\r\nMPI2_IOCSTATUS_MASK;\r\nif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\ngoto out;\r\n}\r\nsz = offsetof(Mpi2SasIOUnitPage1_t, PhyData) + (ioc->sas_hba.num_phys *\r\nsizeof(Mpi2SasIOUnit1PhyData_t));\r\nsas_iounit_pg1 = kzalloc(sz, GFP_KERNEL);\r\nif (!sas_iounit_pg1) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\ngoto out;\r\n}\r\nif ((mpt2sas_config_get_sas_iounit_pg1(ioc, &mpi_reply,\r\nsas_iounit_pg1, sz))) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\ngoto out;\r\n}\r\nioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\r\nMPI2_IOCSTATUS_MASK;\r\nif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\ngoto out;\r\n}\r\nioc->io_missing_delay =\r\nle16_to_cpu(sas_iounit_pg1->IODeviceMissingDelay);\r\ndevice_missing_delay =\r\nle16_to_cpu(sas_iounit_pg1->ReportDeviceMissingDelay);\r\nif (device_missing_delay & MPI2_SASIOUNIT1_REPORT_MISSING_UNIT_16)\r\nioc->device_missing_delay = (device_missing_delay &\r\nMPI2_SASIOUNIT1_REPORT_MISSING_TIMEOUT_MASK) * 16;\r\nelse\r\nioc->device_missing_delay = device_missing_delay &\r\nMPI2_SASIOUNIT1_REPORT_MISSING_TIMEOUT_MASK;\r\nioc->sas_hba.parent_dev = &ioc->shost->shost_gendev;\r\nioc->sas_hba.phy = kcalloc(ioc->sas_hba.num_phys,\r\nsizeof(struct _sas_phy), GFP_KERNEL);\r\nif (!ioc->sas_hba.phy) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\ngoto out;\r\n}\r\nfor (i = 0; i < ioc->sas_hba.num_phys ; i++) {\r\nif ((mpt2sas_config_get_phy_pg0(ioc, &mpi_reply, &phy_pg0,\r\ni))) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\ngoto out;\r\n}\r\nioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\r\nMPI2_IOCSTATUS_MASK;\r\nif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\ngoto out;\r\n}\r\nif (i == 0)\r\nioc->sas_hba.handle = le16_to_cpu(sas_iounit_pg0->\r\nPhyData[0].ControllerDevHandle);\r\nioc->sas_hba.phy[i].handle = ioc->sas_hba.handle;\r\nioc->sas_hba.phy[i].phy_id = i;\r\nmpt2sas_transport_add_host_phy(ioc, &ioc->sas_hba.phy[i],\r\nphy_pg0, ioc->sas_hba.parent_dev);\r\n}\r\nif ((mpt2sas_config_get_sas_device_pg0(ioc, &mpi_reply, &sas_device_pg0,\r\nMPI2_SAS_DEVICE_PGAD_FORM_HANDLE, ioc->sas_hba.handle))) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\ngoto out;\r\n}\r\nioc->sas_hba.enclosure_handle =\r\nle16_to_cpu(sas_device_pg0.EnclosureHandle);\r\nioc->sas_hba.sas_address = le64_to_cpu(sas_device_pg0.SASAddress);\r\nprintk(MPT2SAS_INFO_FMT "host_add: handle(0x%04x), "\r\n"sas_addr(0x%016llx), phys(%d)\n", ioc->name, ioc->sas_hba.handle,\r\n(unsigned long long) ioc->sas_hba.sas_address,\r\nioc->sas_hba.num_phys) ;\r\nif (ioc->sas_hba.enclosure_handle) {\r\nif (!(mpt2sas_config_get_enclosure_pg0(ioc, &mpi_reply,\r\n&enclosure_pg0,\r\nMPI2_SAS_ENCLOS_PGAD_FORM_HANDLE,\r\nioc->sas_hba.enclosure_handle))) {\r\nioc->sas_hba.enclosure_logical_id =\r\nle64_to_cpu(enclosure_pg0.EnclosureLogicalID);\r\n}\r\n}\r\nout:\r\nkfree(sas_iounit_pg1);\r\nkfree(sas_iounit_pg0);\r\n}\r\nstatic int\r\n_scsih_expander_add(struct MPT2SAS_ADAPTER *ioc, u16 handle)\r\n{\r\nstruct _sas_node *sas_expander;\r\nMpi2ConfigReply_t mpi_reply;\r\nMpi2ExpanderPage0_t expander_pg0;\r\nMpi2ExpanderPage1_t expander_pg1;\r\nMpi2SasEnclosurePage0_t enclosure_pg0;\r\nu32 ioc_status;\r\nu16 parent_handle;\r\nu64 sas_address, sas_address_parent = 0;\r\nint i;\r\nunsigned long flags;\r\nstruct _sas_port *mpt2sas_port = NULL;\r\nint rc = 0;\r\nif (!handle)\r\nreturn -1;\r\nif (ioc->shost_recovery || ioc->pci_error_recovery)\r\nreturn -1;\r\nif ((mpt2sas_config_get_expander_pg0(ioc, &mpi_reply, &expander_pg0,\r\nMPI2_SAS_EXPAND_PGAD_FORM_HNDL, handle))) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn -1;\r\n}\r\nioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\r\nMPI2_IOCSTATUS_MASK;\r\nif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn -1;\r\n}\r\nparent_handle = le16_to_cpu(expander_pg0.ParentDevHandle);\r\nif (_scsih_get_sas_address(ioc, parent_handle, &sas_address_parent)\r\n!= 0) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn -1;\r\n}\r\nif (sas_address_parent != ioc->sas_hba.sas_address) {\r\nspin_lock_irqsave(&ioc->sas_node_lock, flags);\r\nsas_expander = mpt2sas_scsih_expander_find_by_sas_address(ioc,\r\nsas_address_parent);\r\nspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\r\nif (!sas_expander) {\r\nrc = _scsih_expander_add(ioc, parent_handle);\r\nif (rc != 0)\r\nreturn rc;\r\n}\r\n}\r\nspin_lock_irqsave(&ioc->sas_node_lock, flags);\r\nsas_address = le64_to_cpu(expander_pg0.SASAddress);\r\nsas_expander = mpt2sas_scsih_expander_find_by_sas_address(ioc,\r\nsas_address);\r\nspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\r\nif (sas_expander)\r\nreturn 0;\r\nsas_expander = kzalloc(sizeof(struct _sas_node),\r\nGFP_KERNEL);\r\nif (!sas_expander) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn -1;\r\n}\r\nsas_expander->handle = handle;\r\nsas_expander->num_phys = expander_pg0.NumPhys;\r\nsas_expander->sas_address_parent = sas_address_parent;\r\nsas_expander->sas_address = sas_address;\r\nprintk(MPT2SAS_INFO_FMT "expander_add: handle(0x%04x),"\r\n" parent(0x%04x), sas_addr(0x%016llx), phys(%d)\n", ioc->name,\r\nhandle, parent_handle, (unsigned long long)\r\nsas_expander->sas_address, sas_expander->num_phys);\r\nif (!sas_expander->num_phys)\r\ngoto out_fail;\r\nsas_expander->phy = kcalloc(sas_expander->num_phys,\r\nsizeof(struct _sas_phy), GFP_KERNEL);\r\nif (!sas_expander->phy) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nrc = -1;\r\ngoto out_fail;\r\n}\r\nINIT_LIST_HEAD(&sas_expander->sas_port_list);\r\nmpt2sas_port = mpt2sas_transport_port_add(ioc, handle,\r\nsas_address_parent);\r\nif (!mpt2sas_port) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nrc = -1;\r\ngoto out_fail;\r\n}\r\nsas_expander->parent_dev = &mpt2sas_port->rphy->dev;\r\nfor (i = 0 ; i < sas_expander->num_phys ; i++) {\r\nif ((mpt2sas_config_get_expander_pg1(ioc, &mpi_reply,\r\n&expander_pg1, i, handle))) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nrc = -1;\r\ngoto out_fail;\r\n}\r\nsas_expander->phy[i].handle = handle;\r\nsas_expander->phy[i].phy_id = i;\r\nif ((mpt2sas_transport_add_expander_phy(ioc,\r\n&sas_expander->phy[i], expander_pg1,\r\nsas_expander->parent_dev))) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nrc = -1;\r\ngoto out_fail;\r\n}\r\n}\r\nif (sas_expander->enclosure_handle) {\r\nif (!(mpt2sas_config_get_enclosure_pg0(ioc, &mpi_reply,\r\n&enclosure_pg0, MPI2_SAS_ENCLOS_PGAD_FORM_HANDLE,\r\nsas_expander->enclosure_handle))) {\r\nsas_expander->enclosure_logical_id =\r\nle64_to_cpu(enclosure_pg0.EnclosureLogicalID);\r\n}\r\n}\r\n_scsih_expander_node_add(ioc, sas_expander);\r\nreturn 0;\r\nout_fail:\r\nif (mpt2sas_port)\r\nmpt2sas_transport_port_remove(ioc, sas_expander->sas_address,\r\nsas_address_parent);\r\nkfree(sas_expander);\r\nreturn rc;\r\n}\r\nstatic u8\r\n_scsih_done(struct MPT2SAS_ADAPTER *ioc, u16 smid, u8 msix_index, u32 reply)\r\n{\r\nMPI2DefaultReply_t *mpi_reply;\r\nmpi_reply = mpt2sas_base_get_reply_virt_addr(ioc, reply);\r\nif (ioc->scsih_cmds.status == MPT2_CMD_NOT_USED)\r\nreturn 1;\r\nif (ioc->scsih_cmds.smid != smid)\r\nreturn 1;\r\nioc->scsih_cmds.status |= MPT2_CMD_COMPLETE;\r\nif (mpi_reply) {\r\nmemcpy(ioc->scsih_cmds.reply, mpi_reply,\r\nmpi_reply->MsgLength*4);\r\nioc->scsih_cmds.status |= MPT2_CMD_REPLY_VALID;\r\n}\r\nioc->scsih_cmds.status &= ~MPT2_CMD_PENDING;\r\ncomplete(&ioc->scsih_cmds.done);\r\nreturn 1;\r\n}\r\nvoid\r\nmpt2sas_expander_remove(struct MPT2SAS_ADAPTER *ioc, u64 sas_address)\r\n{\r\nstruct _sas_node *sas_expander;\r\nunsigned long flags;\r\nif (ioc->shost_recovery)\r\nreturn;\r\nspin_lock_irqsave(&ioc->sas_node_lock, flags);\r\nsas_expander = mpt2sas_scsih_expander_find_by_sas_address(ioc,\r\nsas_address);\r\nif (sas_expander)\r\nlist_del(&sas_expander->list);\r\nspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\r\nif (sas_expander)\r\n_scsih_expander_node_remove(ioc, sas_expander);\r\n}\r\nstatic u8\r\n_scsih_check_access_status(struct MPT2SAS_ADAPTER *ioc, u64 sas_address,\r\nu16 handle, u8 access_status)\r\n{\r\nu8 rc = 1;\r\nchar *desc = NULL;\r\nswitch (access_status) {\r\ncase MPI2_SAS_DEVICE0_ASTATUS_NO_ERRORS:\r\ncase MPI2_SAS_DEVICE0_ASTATUS_SATA_NEEDS_INITIALIZATION:\r\nrc = 0;\r\nbreak;\r\ncase MPI2_SAS_DEVICE0_ASTATUS_SATA_CAPABILITY_FAILED:\r\ndesc = "sata capability failed";\r\nbreak;\r\ncase MPI2_SAS_DEVICE0_ASTATUS_SATA_AFFILIATION_CONFLICT:\r\ndesc = "sata affiliation conflict";\r\nbreak;\r\ncase MPI2_SAS_DEVICE0_ASTATUS_ROUTE_NOT_ADDRESSABLE:\r\ndesc = "route not addressable";\r\nbreak;\r\ncase MPI2_SAS_DEVICE0_ASTATUS_SMP_ERROR_NOT_ADDRESSABLE:\r\ndesc = "smp error not addressable";\r\nbreak;\r\ncase MPI2_SAS_DEVICE0_ASTATUS_DEVICE_BLOCKED:\r\ndesc = "device blocked";\r\nbreak;\r\ncase MPI2_SAS_DEVICE0_ASTATUS_SATA_INIT_FAILED:\r\ncase MPI2_SAS_DEVICE0_ASTATUS_SIF_UNKNOWN:\r\ncase MPI2_SAS_DEVICE0_ASTATUS_SIF_AFFILIATION_CONFLICT:\r\ncase MPI2_SAS_DEVICE0_ASTATUS_SIF_DIAG:\r\ncase MPI2_SAS_DEVICE0_ASTATUS_SIF_IDENTIFICATION:\r\ncase MPI2_SAS_DEVICE0_ASTATUS_SIF_CHECK_POWER:\r\ncase MPI2_SAS_DEVICE0_ASTATUS_SIF_PIO_SN:\r\ncase MPI2_SAS_DEVICE0_ASTATUS_SIF_MDMA_SN:\r\ncase MPI2_SAS_DEVICE0_ASTATUS_SIF_UDMA_SN:\r\ncase MPI2_SAS_DEVICE0_ASTATUS_SIF_ZONING_VIOLATION:\r\ncase MPI2_SAS_DEVICE0_ASTATUS_SIF_NOT_ADDRESSABLE:\r\ncase MPI2_SAS_DEVICE0_ASTATUS_SIF_MAX:\r\ndesc = "sata initialization failed";\r\nbreak;\r\ndefault:\r\ndesc = "unknown";\r\nbreak;\r\n}\r\nif (!rc)\r\nreturn 0;\r\nprintk(MPT2SAS_ERR_FMT "discovery errors(%s): sas_address(0x%016llx), "\r\n"handle(0x%04x)\n", ioc->name, desc,\r\n(unsigned long long)sas_address, handle);\r\nreturn rc;\r\n}\r\nstatic void\r\n_scsih_check_device(struct MPT2SAS_ADAPTER *ioc, u16 handle)\r\n{\r\nMpi2ConfigReply_t mpi_reply;\r\nMpi2SasDevicePage0_t sas_device_pg0;\r\nstruct _sas_device *sas_device;\r\nu32 ioc_status;\r\nunsigned long flags;\r\nu64 sas_address;\r\nstruct scsi_target *starget;\r\nstruct MPT2SAS_TARGET *sas_target_priv_data;\r\nu32 device_info;\r\nif ((mpt2sas_config_get_sas_device_pg0(ioc, &mpi_reply, &sas_device_pg0,\r\nMPI2_SAS_DEVICE_PGAD_FORM_HANDLE, handle)))\r\nreturn;\r\nioc_status = le16_to_cpu(mpi_reply.IOCStatus) & MPI2_IOCSTATUS_MASK;\r\nif (ioc_status != MPI2_IOCSTATUS_SUCCESS)\r\nreturn;\r\ndevice_info = le32_to_cpu(sas_device_pg0.DeviceInfo);\r\nif (!(_scsih_is_end_device(device_info)))\r\nreturn;\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nsas_address = le64_to_cpu(sas_device_pg0.SASAddress);\r\nsas_device = mpt2sas_scsih_sas_device_find_by_sas_address(ioc,\r\nsas_address);\r\nif (!sas_device) {\r\nprintk(MPT2SAS_ERR_FMT "device is not present "\r\n"handle(0x%04x), no sas_device!!!\n", ioc->name, handle);\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\nreturn;\r\n}\r\nif (unlikely(sas_device->handle != handle)) {\r\nstarget = sas_device->starget;\r\nsas_target_priv_data = starget->hostdata;\r\nstarget_printk(KERN_INFO, starget, "handle changed from(0x%04x)"\r\n" to (0x%04x)!!!\n", sas_device->handle, handle);\r\nsas_target_priv_data->handle = handle;\r\nsas_device->handle = handle;\r\n}\r\nif (!(le16_to_cpu(sas_device_pg0.Flags) &\r\nMPI2_SAS_DEVICE0_FLAGS_DEVICE_PRESENT)) {\r\nprintk(MPT2SAS_ERR_FMT "device is not present "\r\n"handle(0x%04x), flags!!!\n", ioc->name, handle);\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\nreturn;\r\n}\r\nif (_scsih_check_access_status(ioc, sas_address, handle,\r\nsas_device_pg0.AccessStatus)) {\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\n_scsih_ublock_io_device(ioc, sas_address);\r\n}\r\nstatic int\r\n_scsih_add_device(struct MPT2SAS_ADAPTER *ioc, u16 handle, u8 phy_num, u8 is_pd)\r\n{\r\nMpi2ConfigReply_t mpi_reply;\r\nMpi2SasDevicePage0_t sas_device_pg0;\r\nMpi2SasEnclosurePage0_t enclosure_pg0;\r\nstruct _sas_device *sas_device;\r\nu32 ioc_status;\r\n__le64 sas_address;\r\nu32 device_info;\r\nunsigned long flags;\r\nif ((mpt2sas_config_get_sas_device_pg0(ioc, &mpi_reply, &sas_device_pg0,\r\nMPI2_SAS_DEVICE_PGAD_FORM_HANDLE, handle))) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn -1;\r\n}\r\nioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\r\nMPI2_IOCSTATUS_MASK;\r\nif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn -1;\r\n}\r\nsas_address = le64_to_cpu(sas_device_pg0.SASAddress);\r\nif (!(le16_to_cpu(sas_device_pg0.Flags) &\r\nMPI2_SAS_DEVICE0_FLAGS_DEVICE_PRESENT)) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nprintk(MPT2SAS_ERR_FMT "Flags = 0x%04x\n",\r\nioc->name, le16_to_cpu(sas_device_pg0.Flags));\r\nreturn -1;\r\n}\r\nif (_scsih_check_access_status(ioc, sas_address, handle,\r\nsas_device_pg0.AccessStatus))\r\nreturn -1;\r\ndevice_info = le32_to_cpu(sas_device_pg0.DeviceInfo);\r\nif (!(_scsih_is_end_device(device_info))) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn -1;\r\n}\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nsas_device = mpt2sas_scsih_sas_device_find_by_sas_address(ioc,\r\nsas_address);\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\nif (sas_device)\r\nreturn 0;\r\nsas_device = kzalloc(sizeof(struct _sas_device),\r\nGFP_KERNEL);\r\nif (!sas_device) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn -1;\r\n}\r\nsas_device->handle = handle;\r\nif (_scsih_get_sas_address(ioc, le16_to_cpu\r\n(sas_device_pg0.ParentDevHandle),\r\n&sas_device->sas_address_parent) != 0)\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nsas_device->enclosure_handle =\r\nle16_to_cpu(sas_device_pg0.EnclosureHandle);\r\nsas_device->slot =\r\nle16_to_cpu(sas_device_pg0.Slot);\r\nsas_device->device_info = device_info;\r\nsas_device->sas_address = sas_address;\r\nsas_device->phy = sas_device_pg0.PhyNum;\r\nif (sas_device->enclosure_handle && !(mpt2sas_config_get_enclosure_pg0(\r\nioc, &mpi_reply, &enclosure_pg0, MPI2_SAS_ENCLOS_PGAD_FORM_HANDLE,\r\nsas_device->enclosure_handle)))\r\nsas_device->enclosure_logical_id =\r\nle64_to_cpu(enclosure_pg0.EnclosureLogicalID);\r\nsas_device->device_name = le64_to_cpu(sas_device_pg0.DeviceName);\r\nif (ioc->wait_for_discovery_to_complete)\r\n_scsih_sas_device_init_add(ioc, sas_device);\r\nelse\r\n_scsih_sas_device_add(ioc, sas_device);\r\nreturn 0;\r\n}\r\nstatic void\r\n_scsih_remove_device(struct MPT2SAS_ADAPTER *ioc,\r\nstruct _sas_device *sas_device)\r\n{\r\nstruct MPT2SAS_TARGET *sas_target_priv_data;\r\nif ((ioc->pdev->subsystem_vendor == PCI_VENDOR_ID_IBM) &&\r\n(sas_device->pfa_led_on)) {\r\n_scsih_turn_off_pfa_led(ioc, sas_device);\r\nsas_device->pfa_led_on = 0;\r\n}\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: enter: "\r\n"handle(0x%04x), sas_addr(0x%016llx)\n", ioc->name, __func__,\r\nsas_device->handle, (unsigned long long)\r\nsas_device->sas_address));\r\nif (sas_device->starget && sas_device->starget->hostdata) {\r\nsas_target_priv_data = sas_device->starget->hostdata;\r\nsas_target_priv_data->deleted = 1;\r\n_scsih_ublock_io_device(ioc, sas_device->sas_address);\r\nsas_target_priv_data->handle =\r\nMPT2SAS_INVALID_DEVICE_HANDLE;\r\n}\r\nif (!ioc->hide_drives)\r\nmpt2sas_transport_port_remove(ioc,\r\nsas_device->sas_address,\r\nsas_device->sas_address_parent);\r\nprintk(MPT2SAS_INFO_FMT "removing handle(0x%04x), sas_addr"\r\n"(0x%016llx)\n", ioc->name, sas_device->handle,\r\n(unsigned long long) sas_device->sas_address);\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: exit: "\r\n"handle(0x%04x), sas_addr(0x%016llx)\n", ioc->name, __func__,\r\nsas_device->handle, (unsigned long long)\r\nsas_device->sas_address));\r\nkfree(sas_device);\r\n}\r\nstatic void\r\n_scsih_device_remove_by_handle(struct MPT2SAS_ADAPTER *ioc, u16 handle)\r\n{\r\nstruct _sas_device *sas_device;\r\nunsigned long flags;\r\nif (ioc->shost_recovery)\r\nreturn;\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nsas_device = _scsih_sas_device_find_by_handle(ioc, handle);\r\nif (sas_device)\r\nlist_del(&sas_device->list);\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\nif (sas_device)\r\n_scsih_remove_device(ioc, sas_device);\r\n}\r\nvoid\r\nmpt2sas_device_remove_by_sas_address(struct MPT2SAS_ADAPTER *ioc,\r\nu64 sas_address)\r\n{\r\nstruct _sas_device *sas_device;\r\nunsigned long flags;\r\nif (ioc->shost_recovery)\r\nreturn;\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nsas_device = mpt2sas_scsih_sas_device_find_by_sas_address(ioc,\r\nsas_address);\r\nif (sas_device)\r\nlist_del(&sas_device->list);\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\nif (sas_device)\r\n_scsih_remove_device(ioc, sas_device);\r\n}\r\nstatic void\r\n_scsih_sas_topology_change_event_debug(struct MPT2SAS_ADAPTER *ioc,\r\nMpi2EventDataSasTopologyChangeList_t *event_data)\r\n{\r\nint i;\r\nu16 handle;\r\nu16 reason_code;\r\nu8 phy_number;\r\nchar *status_str = NULL;\r\nu8 link_rate, prev_link_rate;\r\nswitch (event_data->ExpStatus) {\r\ncase MPI2_EVENT_SAS_TOPO_ES_ADDED:\r\nstatus_str = "add";\r\nbreak;\r\ncase MPI2_EVENT_SAS_TOPO_ES_NOT_RESPONDING:\r\nstatus_str = "remove";\r\nbreak;\r\ncase MPI2_EVENT_SAS_TOPO_ES_RESPONDING:\r\ncase 0:\r\nstatus_str = "responding";\r\nbreak;\r\ncase MPI2_EVENT_SAS_TOPO_ES_DELAY_NOT_RESPONDING:\r\nstatus_str = "remove delay";\r\nbreak;\r\ndefault:\r\nstatus_str = "unknown status";\r\nbreak;\r\n}\r\nprintk(MPT2SAS_INFO_FMT "sas topology change: (%s)\n",\r\nioc->name, status_str);\r\nprintk(KERN_INFO "\thandle(0x%04x), enclosure_handle(0x%04x) "\r\n"start_phy(%02d), count(%d)\n",\r\nle16_to_cpu(event_data->ExpanderDevHandle),\r\nle16_to_cpu(event_data->EnclosureHandle),\r\nevent_data->StartPhyNum, event_data->NumEntries);\r\nfor (i = 0; i < event_data->NumEntries; i++) {\r\nhandle = le16_to_cpu(event_data->PHY[i].AttachedDevHandle);\r\nif (!handle)\r\ncontinue;\r\nphy_number = event_data->StartPhyNum + i;\r\nreason_code = event_data->PHY[i].PhyStatus &\r\nMPI2_EVENT_SAS_TOPO_RC_MASK;\r\nswitch (reason_code) {\r\ncase MPI2_EVENT_SAS_TOPO_RC_TARG_ADDED:\r\nstatus_str = "target add";\r\nbreak;\r\ncase MPI2_EVENT_SAS_TOPO_RC_TARG_NOT_RESPONDING:\r\nstatus_str = "target remove";\r\nbreak;\r\ncase MPI2_EVENT_SAS_TOPO_RC_DELAY_NOT_RESPONDING:\r\nstatus_str = "delay target remove";\r\nbreak;\r\ncase MPI2_EVENT_SAS_TOPO_RC_PHY_CHANGED:\r\nstatus_str = "link rate change";\r\nbreak;\r\ncase MPI2_EVENT_SAS_TOPO_RC_NO_CHANGE:\r\nstatus_str = "target responding";\r\nbreak;\r\ndefault:\r\nstatus_str = "unknown";\r\nbreak;\r\n}\r\nlink_rate = event_data->PHY[i].LinkRate >> 4;\r\nprev_link_rate = event_data->PHY[i].LinkRate & 0xF;\r\nprintk(KERN_INFO "\tphy(%02d), attached_handle(0x%04x): %s:"\r\n" link rate: new(0x%02x), old(0x%02x)\n", phy_number,\r\nhandle, status_str, link_rate, prev_link_rate);\r\n}\r\n}\r\nstatic void\r\n_scsih_sas_topology_change_event(struct MPT2SAS_ADAPTER *ioc,\r\nstruct fw_event_work *fw_event)\r\n{\r\nint i;\r\nu16 parent_handle, handle;\r\nu16 reason_code;\r\nu8 phy_number, max_phys;\r\nstruct _sas_node *sas_expander;\r\nu64 sas_address;\r\nunsigned long flags;\r\nu8 link_rate, prev_link_rate;\r\nMpi2EventDataSasTopologyChangeList_t *event_data =\r\n(Mpi2EventDataSasTopologyChangeList_t *)\r\nfw_event->event_data;\r\n#ifdef CONFIG_SCSI_MPT2SAS_LOGGING\r\nif (ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK)\r\n_scsih_sas_topology_change_event_debug(ioc, event_data);\r\n#endif\r\nif (ioc->remove_host || ioc->pci_error_recovery)\r\nreturn;\r\nif (!ioc->sas_hba.num_phys)\r\n_scsih_sas_host_add(ioc);\r\nelse\r\n_scsih_sas_host_refresh(ioc);\r\nif (fw_event->ignore) {\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT "ignoring expander "\r\n"event\n", ioc->name));\r\nreturn;\r\n}\r\nparent_handle = le16_to_cpu(event_data->ExpanderDevHandle);\r\nif (event_data->ExpStatus == MPI2_EVENT_SAS_TOPO_ES_ADDED)\r\nif (_scsih_expander_add(ioc, parent_handle) != 0)\r\nreturn;\r\nspin_lock_irqsave(&ioc->sas_node_lock, flags);\r\nsas_expander = mpt2sas_scsih_expander_find_by_handle(ioc,\r\nparent_handle);\r\nif (sas_expander) {\r\nsas_address = sas_expander->sas_address;\r\nmax_phys = sas_expander->num_phys;\r\n} else if (parent_handle < ioc->sas_hba.num_phys) {\r\nsas_address = ioc->sas_hba.sas_address;\r\nmax_phys = ioc->sas_hba.num_phys;\r\n} else {\r\nspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\r\nfor (i = 0; i < event_data->NumEntries; i++) {\r\nif (fw_event->ignore) {\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT "ignoring "\r\n"expander event\n", ioc->name));\r\nreturn;\r\n}\r\nif (ioc->shost_recovery || ioc->remove_host ||\r\nioc->pci_error_recovery)\r\nreturn;\r\nphy_number = event_data->StartPhyNum + i;\r\nif (phy_number >= max_phys)\r\ncontinue;\r\nreason_code = event_data->PHY[i].PhyStatus &\r\nMPI2_EVENT_SAS_TOPO_RC_MASK;\r\nif ((event_data->PHY[i].PhyStatus &\r\nMPI2_EVENT_SAS_TOPO_PHYSTATUS_VACANT) && (reason_code !=\r\nMPI2_EVENT_SAS_TOPO_RC_TARG_NOT_RESPONDING))\r\ncontinue;\r\nhandle = le16_to_cpu(event_data->PHY[i].AttachedDevHandle);\r\nif (!handle)\r\ncontinue;\r\nlink_rate = event_data->PHY[i].LinkRate >> 4;\r\nprev_link_rate = event_data->PHY[i].LinkRate & 0xF;\r\nswitch (reason_code) {\r\ncase MPI2_EVENT_SAS_TOPO_RC_PHY_CHANGED:\r\nif (ioc->shost_recovery)\r\nbreak;\r\nif (link_rate == prev_link_rate)\r\nbreak;\r\nmpt2sas_transport_update_links(ioc, sas_address,\r\nhandle, phy_number, link_rate);\r\nif (link_rate < MPI2_SAS_NEG_LINK_RATE_1_5)\r\nbreak;\r\n_scsih_check_device(ioc, handle);\r\nbreak;\r\ncase MPI2_EVENT_SAS_TOPO_RC_TARG_ADDED:\r\nif (ioc->shost_recovery)\r\nbreak;\r\nmpt2sas_transport_update_links(ioc, sas_address,\r\nhandle, phy_number, link_rate);\r\n_scsih_add_device(ioc, handle, phy_number, 0);\r\nbreak;\r\ncase MPI2_EVENT_SAS_TOPO_RC_TARG_NOT_RESPONDING:\r\n_scsih_device_remove_by_handle(ioc, handle);\r\nbreak;\r\n}\r\n}\r\nif (event_data->ExpStatus == MPI2_EVENT_SAS_TOPO_ES_NOT_RESPONDING &&\r\nsas_expander)\r\nmpt2sas_expander_remove(ioc, sas_address);\r\n}\r\nstatic void\r\n_scsih_sas_device_status_change_event_debug(struct MPT2SAS_ADAPTER *ioc,\r\nMpi2EventDataSasDeviceStatusChange_t *event_data)\r\n{\r\nchar *reason_str = NULL;\r\nswitch (event_data->ReasonCode) {\r\ncase MPI2_EVENT_SAS_DEV_STAT_RC_SMART_DATA:\r\nreason_str = "smart data";\r\nbreak;\r\ncase MPI2_EVENT_SAS_DEV_STAT_RC_UNSUPPORTED:\r\nreason_str = "unsupported device discovered";\r\nbreak;\r\ncase MPI2_EVENT_SAS_DEV_STAT_RC_INTERNAL_DEVICE_RESET:\r\nreason_str = "internal device reset";\r\nbreak;\r\ncase MPI2_EVENT_SAS_DEV_STAT_RC_TASK_ABORT_INTERNAL:\r\nreason_str = "internal task abort";\r\nbreak;\r\ncase MPI2_EVENT_SAS_DEV_STAT_RC_ABORT_TASK_SET_INTERNAL:\r\nreason_str = "internal task abort set";\r\nbreak;\r\ncase MPI2_EVENT_SAS_DEV_STAT_RC_CLEAR_TASK_SET_INTERNAL:\r\nreason_str = "internal clear task set";\r\nbreak;\r\ncase MPI2_EVENT_SAS_DEV_STAT_RC_QUERY_TASK_INTERNAL:\r\nreason_str = "internal query task";\r\nbreak;\r\ncase MPI2_EVENT_SAS_DEV_STAT_RC_SATA_INIT_FAILURE:\r\nreason_str = "sata init failure";\r\nbreak;\r\ncase MPI2_EVENT_SAS_DEV_STAT_RC_CMP_INTERNAL_DEV_RESET:\r\nreason_str = "internal device reset complete";\r\nbreak;\r\ncase MPI2_EVENT_SAS_DEV_STAT_RC_CMP_TASK_ABORT_INTERNAL:\r\nreason_str = "internal task abort complete";\r\nbreak;\r\ncase MPI2_EVENT_SAS_DEV_STAT_RC_ASYNC_NOTIFICATION:\r\nreason_str = "internal async notification";\r\nbreak;\r\ncase MPI2_EVENT_SAS_DEV_STAT_RC_EXPANDER_REDUCED_FUNCTIONALITY:\r\nreason_str = "expander reduced functionality";\r\nbreak;\r\ncase MPI2_EVENT_SAS_DEV_STAT_RC_CMP_EXPANDER_REDUCED_FUNCTIONALITY:\r\nreason_str = "expander reduced functionality complete";\r\nbreak;\r\ndefault:\r\nreason_str = "unknown reason";\r\nbreak;\r\n}\r\nprintk(MPT2SAS_INFO_FMT "device status change: (%s)\n"\r\n"\thandle(0x%04x), sas address(0x%016llx), tag(%d)",\r\nioc->name, reason_str, le16_to_cpu(event_data->DevHandle),\r\n(unsigned long long)le64_to_cpu(event_data->SASAddress),\r\nle16_to_cpu(event_data->TaskTag));\r\nif (event_data->ReasonCode == MPI2_EVENT_SAS_DEV_STAT_RC_SMART_DATA)\r\nprintk(MPT2SAS_INFO_FMT ", ASC(0x%x), ASCQ(0x%x)\n", ioc->name,\r\nevent_data->ASC, event_data->ASCQ);\r\nprintk(KERN_INFO "\n");\r\n}\r\nstatic void\r\n_scsih_sas_device_status_change_event(struct MPT2SAS_ADAPTER *ioc,\r\nstruct fw_event_work *fw_event)\r\n{\r\nstruct MPT2SAS_TARGET *target_priv_data;\r\nstruct _sas_device *sas_device;\r\nu64 sas_address;\r\nunsigned long flags;\r\nMpi2EventDataSasDeviceStatusChange_t *event_data =\r\n(Mpi2EventDataSasDeviceStatusChange_t *)\r\nfw_event->event_data;\r\n#ifdef CONFIG_SCSI_MPT2SAS_LOGGING\r\nif (ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK)\r\n_scsih_sas_device_status_change_event_debug(ioc,\r\nevent_data);\r\n#endif\r\nif ((ioc->facts.HeaderVersion >> 8) < 0xC)\r\nreturn;\r\nif (event_data->ReasonCode !=\r\nMPI2_EVENT_SAS_DEV_STAT_RC_INTERNAL_DEVICE_RESET &&\r\nevent_data->ReasonCode !=\r\nMPI2_EVENT_SAS_DEV_STAT_RC_CMP_INTERNAL_DEV_RESET)\r\nreturn;\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nsas_address = le64_to_cpu(event_data->SASAddress);\r\nsas_device = mpt2sas_scsih_sas_device_find_by_sas_address(ioc,\r\nsas_address);\r\nif (!sas_device || !sas_device->starget) {\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\nreturn;\r\n}\r\ntarget_priv_data = sas_device->starget->hostdata;\r\nif (!target_priv_data) {\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\nreturn;\r\n}\r\nif (event_data->ReasonCode ==\r\nMPI2_EVENT_SAS_DEV_STAT_RC_INTERNAL_DEVICE_RESET)\r\ntarget_priv_data->tm_busy = 1;\r\nelse\r\ntarget_priv_data->tm_busy = 0;\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\n}\r\nstatic void\r\n_scsih_sas_enclosure_dev_status_change_event_debug(struct MPT2SAS_ADAPTER *ioc,\r\nMpi2EventDataSasEnclDevStatusChange_t *event_data)\r\n{\r\nchar *reason_str = NULL;\r\nswitch (event_data->ReasonCode) {\r\ncase MPI2_EVENT_SAS_ENCL_RC_ADDED:\r\nreason_str = "enclosure add";\r\nbreak;\r\ncase MPI2_EVENT_SAS_ENCL_RC_NOT_RESPONDING:\r\nreason_str = "enclosure remove";\r\nbreak;\r\ndefault:\r\nreason_str = "unknown reason";\r\nbreak;\r\n}\r\nprintk(MPT2SAS_INFO_FMT "enclosure status change: (%s)\n"\r\n"\thandle(0x%04x), enclosure logical id(0x%016llx)"\r\n" number slots(%d)\n", ioc->name, reason_str,\r\nle16_to_cpu(event_data->EnclosureHandle),\r\n(unsigned long long)le64_to_cpu(event_data->EnclosureLogicalID),\r\nle16_to_cpu(event_data->StartSlot));\r\n}\r\nstatic void\r\n_scsih_sas_enclosure_dev_status_change_event(struct MPT2SAS_ADAPTER *ioc,\r\nstruct fw_event_work *fw_event)\r\n{\r\n#ifdef CONFIG_SCSI_MPT2SAS_LOGGING\r\nif (ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK)\r\n_scsih_sas_enclosure_dev_status_change_event_debug(ioc,\r\n(Mpi2EventDataSasEnclDevStatusChange_t *)\r\nfw_event->event_data);\r\n#endif\r\n}\r\nstatic void\r\n_scsih_sas_broadcast_primitive_event(struct MPT2SAS_ADAPTER *ioc,\r\nstruct fw_event_work *fw_event)\r\n{\r\nstruct scsi_cmnd *scmd;\r\nstruct scsi_device *sdev;\r\nu16 smid, handle;\r\nu32 lun;\r\nstruct MPT2SAS_DEVICE *sas_device_priv_data;\r\nu32 termination_count;\r\nu32 query_count;\r\nMpi2SCSITaskManagementReply_t *mpi_reply;\r\nMpi2EventDataSasBroadcastPrimitive_t *event_data =\r\n(Mpi2EventDataSasBroadcastPrimitive_t *)\r\nfw_event->event_data;\r\nu16 ioc_status;\r\nunsigned long flags;\r\nint r;\r\nu8 max_retries = 0;\r\nu8 task_abort_retries;\r\nmutex_lock(&ioc->tm_cmds.mutex);\r\npr_info(MPT2SAS_FMT\r\n"%s: enter: phy number(%d), width(%d)\n",\r\nioc->name, __func__, event_data->PhyNum,\r\nevent_data->PortWidth);\r\n_scsih_block_io_all_device(ioc);\r\nspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\r\nmpi_reply = ioc->tm_cmds.reply;\r\nbroadcast_aen_retry:\r\nif (max_retries++ == 5) {\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: giving up\n",\r\nioc->name, __func__));\r\ngoto out;\r\n} else if (max_retries > 1)\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: %d retry\n",\r\nioc->name, __func__, max_retries - 1));\r\ntermination_count = 0;\r\nquery_count = 0;\r\nfor (smid = 1; smid <= ioc->scsiio_depth; smid++) {\r\nif (ioc->shost_recovery)\r\ngoto out;\r\nscmd = _scsih_scsi_lookup_get(ioc, smid);\r\nif (!scmd)\r\ncontinue;\r\nsdev = scmd->device;\r\nsas_device_priv_data = sdev->hostdata;\r\nif (!sas_device_priv_data || !sas_device_priv_data->sas_target)\r\ncontinue;\r\nif (sas_device_priv_data->sas_target->flags &\r\nMPT_TARGET_FLAGS_RAID_COMPONENT)\r\ncontinue;\r\nif (sas_device_priv_data->sas_target->flags &\r\nMPT_TARGET_FLAGS_VOLUME)\r\ncontinue;\r\nhandle = sas_device_priv_data->sas_target->handle;\r\nlun = sas_device_priv_data->lun;\r\nquery_count++;\r\nif (ioc->shost_recovery)\r\ngoto out;\r\nspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\r\nr = mpt2sas_scsih_issue_tm(ioc, handle, 0, 0, lun,\r\nMPI2_SCSITASKMGMT_TASKTYPE_QUERY_TASK, smid, 30,\r\nTM_MUTEX_OFF);\r\nif (r == FAILED) {\r\nsdev_printk(KERN_WARNING, sdev,\r\n"mpt2sas_scsih_issue_tm: FAILED when sending "\r\n"QUERY_TASK: scmd(%p)\n", scmd);\r\nspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\r\ngoto broadcast_aen_retry;\r\n}\r\nioc_status = le16_to_cpu(mpi_reply->IOCStatus)\r\n& MPI2_IOCSTATUS_MASK;\r\nif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\r\nsdev_printk(KERN_WARNING, sdev, "query task: FAILED "\r\n"with IOCSTATUS(0x%04x), scmd(%p)\n", ioc_status,\r\nscmd);\r\nspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\r\ngoto broadcast_aen_retry;\r\n}\r\nif (mpi_reply->ResponseCode ==\r\nMPI2_SCSITASKMGMT_RSP_TM_SUCCEEDED ||\r\nmpi_reply->ResponseCode ==\r\nMPI2_SCSITASKMGMT_RSP_IO_QUEUED_ON_IOC) {\r\nspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\r\ncontinue;\r\n}\r\ntask_abort_retries = 0;\r\ntm_retry:\r\nif (task_abort_retries++ == 60) {\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT\r\n"%s: ABORT_TASK: giving up\n", ioc->name,\r\n__func__));\r\nspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\r\ngoto broadcast_aen_retry;\r\n}\r\nif (ioc->shost_recovery)\r\ngoto out_no_lock;\r\nr = mpt2sas_scsih_issue_tm(ioc, handle, sdev->channel, sdev->id,\r\nsdev->lun, MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK, smid, 30,\r\nTM_MUTEX_OFF);\r\nif (r == FAILED) {\r\nsdev_printk(KERN_WARNING, sdev,\r\n"mpt2sas_scsih_issue_tm: ABORT_TASK: FAILED : "\r\n"scmd(%p)\n", scmd);\r\ngoto tm_retry;\r\n}\r\nif (task_abort_retries > 1)\r\nsdev_printk(KERN_WARNING, sdev,\r\n"mpt2sas_scsih_issue_tm: ABORT_TASK: RETRIES (%d):"\r\n" scmd(%p)\n",\r\ntask_abort_retries - 1, scmd);\r\ntermination_count += le32_to_cpu(mpi_reply->TerminationCount);\r\nspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\r\n}\r\nif (ioc->broadcast_aen_pending) {\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: loop back due to"\r\n" pending AEN\n", ioc->name, __func__));\r\nioc->broadcast_aen_pending = 0;\r\ngoto broadcast_aen_retry;\r\n}\r\nout:\r\nspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\r\nout_no_lock:\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT\r\n"%s - exit, query_count = %d termination_count = %d\n",\r\nioc->name, __func__, query_count, termination_count));\r\nioc->broadcast_aen_busy = 0;\r\nif (!ioc->shost_recovery)\r\n_scsih_ublock_io_all_device(ioc);\r\nmutex_unlock(&ioc->tm_cmds.mutex);\r\n}\r\nstatic void\r\n_scsih_sas_discovery_event(struct MPT2SAS_ADAPTER *ioc,\r\nstruct fw_event_work *fw_event)\r\n{\r\nMpi2EventDataSasDiscovery_t *event_data =\r\n(Mpi2EventDataSasDiscovery_t *)\r\nfw_event->event_data;\r\n#ifdef CONFIG_SCSI_MPT2SAS_LOGGING\r\nif (ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK) {\r\nprintk(MPT2SAS_INFO_FMT "discovery event: (%s)", ioc->name,\r\n(event_data->ReasonCode == MPI2_EVENT_SAS_DISC_RC_STARTED) ?\r\n"start" : "stop");\r\nif (event_data->DiscoveryStatus)\r\nprintk("discovery_status(0x%08x)",\r\nle32_to_cpu(event_data->DiscoveryStatus));\r\nprintk("\n");\r\n}\r\n#endif\r\nif (event_data->ReasonCode == MPI2_EVENT_SAS_DISC_RC_STARTED &&\r\n!ioc->sas_hba.num_phys) {\r\nif (disable_discovery > 0 && ioc->shost_recovery) {\r\nwhile (ioc->shost_recovery)\r\nssleep(1);\r\n}\r\n_scsih_sas_host_add(ioc);\r\n}\r\n}\r\nstatic void\r\n_scsih_reprobe_lun(struct scsi_device *sdev, void *no_uld_attach)\r\n{\r\nint rc;\r\nsdev->no_uld_attach = no_uld_attach ? 1 : 0;\r\nsdev_printk(KERN_INFO, sdev, "%s raid component\n",\r\nsdev->no_uld_attach ? "hidding" : "exposing");\r\nrc = scsi_device_reprobe(sdev);\r\n}\r\nstatic void\r\n_scsih_sas_volume_add(struct MPT2SAS_ADAPTER *ioc,\r\nMpi2EventIrConfigElement_t *element)\r\n{\r\nstruct _raid_device *raid_device;\r\nunsigned long flags;\r\nu64 wwid;\r\nu16 handle = le16_to_cpu(element->VolDevHandle);\r\nint rc;\r\nmpt2sas_config_get_volume_wwid(ioc, handle, &wwid);\r\nif (!wwid) {\r\nprintk(MPT2SAS_ERR_FMT\r\n"failure at %s:%d/%s()!\n", ioc->name,\r\n__FILE__, __LINE__, __func__);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&ioc->raid_device_lock, flags);\r\nraid_device = _scsih_raid_device_find_by_wwid(ioc, wwid);\r\nspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\r\nif (raid_device)\r\nreturn;\r\nraid_device = kzalloc(sizeof(struct _raid_device), GFP_KERNEL);\r\nif (!raid_device) {\r\nprintk(MPT2SAS_ERR_FMT\r\n"failure at %s:%d/%s()!\n", ioc->name,\r\n__FILE__, __LINE__, __func__);\r\nreturn;\r\n}\r\nraid_device->id = ioc->sas_id++;\r\nraid_device->channel = RAID_CHANNEL;\r\nraid_device->handle = handle;\r\nraid_device->wwid = wwid;\r\n_scsih_raid_device_add(ioc, raid_device);\r\nif (!ioc->wait_for_discovery_to_complete) {\r\nrc = scsi_add_device(ioc->shost, RAID_CHANNEL,\r\nraid_device->id, 0);\r\nif (rc)\r\n_scsih_raid_device_remove(ioc, raid_device);\r\n} else {\r\nspin_lock_irqsave(&ioc->raid_device_lock, flags);\r\n_scsih_determine_boot_device(ioc, raid_device, 1);\r\nspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\r\n}\r\n}\r\nstatic void\r\n_scsih_sas_volume_delete(struct MPT2SAS_ADAPTER *ioc, u16 handle)\r\n{\r\nstruct _raid_device *raid_device;\r\nunsigned long flags;\r\nstruct MPT2SAS_TARGET *sas_target_priv_data;\r\nstruct scsi_target *starget = NULL;\r\nspin_lock_irqsave(&ioc->raid_device_lock, flags);\r\nraid_device = _scsih_raid_device_find_by_handle(ioc, handle);\r\nif (raid_device) {\r\nif (raid_device->starget) {\r\nstarget = raid_device->starget;\r\nsas_target_priv_data = starget->hostdata;\r\nsas_target_priv_data->deleted = 1;\r\n}\r\nprintk(MPT2SAS_INFO_FMT "removing handle(0x%04x), wwid"\r\n"(0x%016llx)\n", ioc->name, raid_device->handle,\r\n(unsigned long long) raid_device->wwid);\r\nlist_del(&raid_device->list);\r\nkfree(raid_device);\r\n}\r\nspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\r\nif (starget)\r\nscsi_remove_target(&starget->dev);\r\n}\r\nstatic void\r\n_scsih_sas_pd_expose(struct MPT2SAS_ADAPTER *ioc,\r\nMpi2EventIrConfigElement_t *element)\r\n{\r\nstruct _sas_device *sas_device;\r\nstruct scsi_target *starget = NULL;\r\nstruct MPT2SAS_TARGET *sas_target_priv_data;\r\nunsigned long flags;\r\nu16 handle = le16_to_cpu(element->PhysDiskDevHandle);\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nsas_device = _scsih_sas_device_find_by_handle(ioc, handle);\r\nif (sas_device) {\r\nsas_device->volume_handle = 0;\r\nsas_device->volume_wwid = 0;\r\nclear_bit(handle, ioc->pd_handles);\r\nif (sas_device->starget && sas_device->starget->hostdata) {\r\nstarget = sas_device->starget;\r\nsas_target_priv_data = starget->hostdata;\r\nsas_target_priv_data->flags &=\r\n~MPT_TARGET_FLAGS_RAID_COMPONENT;\r\n}\r\n}\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\nif (!sas_device)\r\nreturn;\r\nif (starget)\r\nstarget_for_each_device(starget, NULL, _scsih_reprobe_lun);\r\n}\r\nstatic void\r\n_scsih_sas_pd_hide(struct MPT2SAS_ADAPTER *ioc,\r\nMpi2EventIrConfigElement_t *element)\r\n{\r\nstruct _sas_device *sas_device;\r\nstruct scsi_target *starget = NULL;\r\nstruct MPT2SAS_TARGET *sas_target_priv_data;\r\nunsigned long flags;\r\nu16 handle = le16_to_cpu(element->PhysDiskDevHandle);\r\nu16 volume_handle = 0;\r\nu64 volume_wwid = 0;\r\nmpt2sas_config_get_volume_handle(ioc, handle, &volume_handle);\r\nif (volume_handle)\r\nmpt2sas_config_get_volume_wwid(ioc, volume_handle,\r\n&volume_wwid);\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nsas_device = _scsih_sas_device_find_by_handle(ioc, handle);\r\nif (sas_device) {\r\nset_bit(handle, ioc->pd_handles);\r\nif (sas_device->starget && sas_device->starget->hostdata) {\r\nstarget = sas_device->starget;\r\nsas_target_priv_data = starget->hostdata;\r\nsas_target_priv_data->flags |=\r\nMPT_TARGET_FLAGS_RAID_COMPONENT;\r\nsas_device->volume_handle = volume_handle;\r\nsas_device->volume_wwid = volume_wwid;\r\n}\r\n}\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\nif (!sas_device)\r\nreturn;\r\nif (starget)\r\nstarget_for_each_device(starget, (void *)1, _scsih_reprobe_lun);\r\n}\r\nstatic void\r\n_scsih_sas_pd_delete(struct MPT2SAS_ADAPTER *ioc,\r\nMpi2EventIrConfigElement_t *element)\r\n{\r\nu16 handle = le16_to_cpu(element->PhysDiskDevHandle);\r\n_scsih_device_remove_by_handle(ioc, handle);\r\n}\r\nstatic void\r\n_scsih_sas_pd_add(struct MPT2SAS_ADAPTER *ioc,\r\nMpi2EventIrConfigElement_t *element)\r\n{\r\nstruct _sas_device *sas_device;\r\nunsigned long flags;\r\nu16 handle = le16_to_cpu(element->PhysDiskDevHandle);\r\nMpi2ConfigReply_t mpi_reply;\r\nMpi2SasDevicePage0_t sas_device_pg0;\r\nu32 ioc_status;\r\nu64 sas_address;\r\nu16 parent_handle;\r\nset_bit(handle, ioc->pd_handles);\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nsas_device = _scsih_sas_device_find_by_handle(ioc, handle);\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\nif (sas_device)\r\nreturn;\r\nif ((mpt2sas_config_get_sas_device_pg0(ioc, &mpi_reply, &sas_device_pg0,\r\nMPI2_SAS_DEVICE_PGAD_FORM_HANDLE, handle))) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn;\r\n}\r\nioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\r\nMPI2_IOCSTATUS_MASK;\r\nif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn;\r\n}\r\nparent_handle = le16_to_cpu(sas_device_pg0.ParentDevHandle);\r\nif (!_scsih_get_sas_address(ioc, parent_handle, &sas_address))\r\nmpt2sas_transport_update_links(ioc, sas_address, handle,\r\nsas_device_pg0.PhyNum, MPI2_SAS_NEG_LINK_RATE_1_5);\r\n_scsih_add_device(ioc, handle, 0, 1);\r\n}\r\nstatic void\r\n_scsih_sas_ir_config_change_event_debug(struct MPT2SAS_ADAPTER *ioc,\r\nMpi2EventDataIrConfigChangeList_t *event_data)\r\n{\r\nMpi2EventIrConfigElement_t *element;\r\nu8 element_type;\r\nint i;\r\nchar *reason_str = NULL, *element_str = NULL;\r\nelement = (Mpi2EventIrConfigElement_t *)&event_data->ConfigElement[0];\r\nprintk(MPT2SAS_INFO_FMT "raid config change: (%s), elements(%d)\n",\r\nioc->name, (le32_to_cpu(event_data->Flags) &\r\nMPI2_EVENT_IR_CHANGE_FLAGS_FOREIGN_CONFIG) ?\r\n"foreign" : "native", event_data->NumElements);\r\nfor (i = 0; i < event_data->NumElements; i++, element++) {\r\nswitch (element->ReasonCode) {\r\ncase MPI2_EVENT_IR_CHANGE_RC_ADDED:\r\nreason_str = "add";\r\nbreak;\r\ncase MPI2_EVENT_IR_CHANGE_RC_REMOVED:\r\nreason_str = "remove";\r\nbreak;\r\ncase MPI2_EVENT_IR_CHANGE_RC_NO_CHANGE:\r\nreason_str = "no change";\r\nbreak;\r\ncase MPI2_EVENT_IR_CHANGE_RC_HIDE:\r\nreason_str = "hide";\r\nbreak;\r\ncase MPI2_EVENT_IR_CHANGE_RC_UNHIDE:\r\nreason_str = "unhide";\r\nbreak;\r\ncase MPI2_EVENT_IR_CHANGE_RC_VOLUME_CREATED:\r\nreason_str = "volume_created";\r\nbreak;\r\ncase MPI2_EVENT_IR_CHANGE_RC_VOLUME_DELETED:\r\nreason_str = "volume_deleted";\r\nbreak;\r\ncase MPI2_EVENT_IR_CHANGE_RC_PD_CREATED:\r\nreason_str = "pd_created";\r\nbreak;\r\ncase MPI2_EVENT_IR_CHANGE_RC_PD_DELETED:\r\nreason_str = "pd_deleted";\r\nbreak;\r\ndefault:\r\nreason_str = "unknown reason";\r\nbreak;\r\n}\r\nelement_type = le16_to_cpu(element->ElementFlags) &\r\nMPI2_EVENT_IR_CHANGE_EFLAGS_ELEMENT_TYPE_MASK;\r\nswitch (element_type) {\r\ncase MPI2_EVENT_IR_CHANGE_EFLAGS_VOLUME_ELEMENT:\r\nelement_str = "volume";\r\nbreak;\r\ncase MPI2_EVENT_IR_CHANGE_EFLAGS_VOLPHYSDISK_ELEMENT:\r\nelement_str = "phys disk";\r\nbreak;\r\ncase MPI2_EVENT_IR_CHANGE_EFLAGS_HOTSPARE_ELEMENT:\r\nelement_str = "hot spare";\r\nbreak;\r\ndefault:\r\nelement_str = "unknown element";\r\nbreak;\r\n}\r\nprintk(KERN_INFO "\t(%s:%s), vol handle(0x%04x), "\r\n"pd handle(0x%04x), pd num(0x%02x)\n", element_str,\r\nreason_str, le16_to_cpu(element->VolDevHandle),\r\nle16_to_cpu(element->PhysDiskDevHandle),\r\nelement->PhysDiskNum);\r\n}\r\n}\r\nstatic void\r\n_scsih_sas_ir_config_change_event(struct MPT2SAS_ADAPTER *ioc,\r\nstruct fw_event_work *fw_event)\r\n{\r\nMpi2EventIrConfigElement_t *element;\r\nint i;\r\nu8 foreign_config;\r\nMpi2EventDataIrConfigChangeList_t *event_data =\r\n(Mpi2EventDataIrConfigChangeList_t *)\r\nfw_event->event_data;\r\n#ifdef CONFIG_SCSI_MPT2SAS_LOGGING\r\nif ((ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK)\r\n&& !ioc->hide_ir_msg)\r\n_scsih_sas_ir_config_change_event_debug(ioc, event_data);\r\n#endif\r\nif (ioc->shost_recovery)\r\nreturn;\r\nforeign_config = (le32_to_cpu(event_data->Flags) &\r\nMPI2_EVENT_IR_CHANGE_FLAGS_FOREIGN_CONFIG) ? 1 : 0;\r\nelement = (Mpi2EventIrConfigElement_t *)&event_data->ConfigElement[0];\r\nfor (i = 0; i < event_data->NumElements; i++, element++) {\r\nswitch (element->ReasonCode) {\r\ncase MPI2_EVENT_IR_CHANGE_RC_VOLUME_CREATED:\r\ncase MPI2_EVENT_IR_CHANGE_RC_ADDED:\r\nif (!foreign_config)\r\n_scsih_sas_volume_add(ioc, element);\r\nbreak;\r\ncase MPI2_EVENT_IR_CHANGE_RC_VOLUME_DELETED:\r\ncase MPI2_EVENT_IR_CHANGE_RC_REMOVED:\r\nif (!foreign_config)\r\n_scsih_sas_volume_delete(ioc,\r\nle16_to_cpu(element->VolDevHandle));\r\nbreak;\r\ncase MPI2_EVENT_IR_CHANGE_RC_PD_CREATED:\r\nif (!ioc->is_warpdrive)\r\n_scsih_sas_pd_hide(ioc, element);\r\nbreak;\r\ncase MPI2_EVENT_IR_CHANGE_RC_PD_DELETED:\r\nif (!ioc->is_warpdrive)\r\n_scsih_sas_pd_expose(ioc, element);\r\nbreak;\r\ncase MPI2_EVENT_IR_CHANGE_RC_HIDE:\r\nif (!ioc->is_warpdrive)\r\n_scsih_sas_pd_add(ioc, element);\r\nbreak;\r\ncase MPI2_EVENT_IR_CHANGE_RC_UNHIDE:\r\nif (!ioc->is_warpdrive)\r\n_scsih_sas_pd_delete(ioc, element);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void\r\n_scsih_sas_ir_volume_event(struct MPT2SAS_ADAPTER *ioc,\r\nstruct fw_event_work *fw_event)\r\n{\r\nu64 wwid;\r\nunsigned long flags;\r\nstruct _raid_device *raid_device;\r\nu16 handle;\r\nu32 state;\r\nint rc;\r\nMpi2EventDataIrVolume_t *event_data =\r\n(Mpi2EventDataIrVolume_t *)\r\nfw_event->event_data;\r\nif (ioc->shost_recovery)\r\nreturn;\r\nif (event_data->ReasonCode != MPI2_EVENT_IR_VOLUME_RC_STATE_CHANGED)\r\nreturn;\r\nhandle = le16_to_cpu(event_data->VolDevHandle);\r\nstate = le32_to_cpu(event_data->NewValue);\r\nif (!ioc->hide_ir_msg)\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: handle(0x%04x), "\r\n"old(0x%08x), new(0x%08x)\n", ioc->name, __func__, handle,\r\nle32_to_cpu(event_data->PreviousValue), state));\r\nswitch (state) {\r\ncase MPI2_RAID_VOL_STATE_MISSING:\r\ncase MPI2_RAID_VOL_STATE_FAILED:\r\n_scsih_sas_volume_delete(ioc, handle);\r\nbreak;\r\ncase MPI2_RAID_VOL_STATE_ONLINE:\r\ncase MPI2_RAID_VOL_STATE_DEGRADED:\r\ncase MPI2_RAID_VOL_STATE_OPTIMAL:\r\nspin_lock_irqsave(&ioc->raid_device_lock, flags);\r\nraid_device = _scsih_raid_device_find_by_handle(ioc, handle);\r\nspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\r\nif (raid_device)\r\nbreak;\r\nmpt2sas_config_get_volume_wwid(ioc, handle, &wwid);\r\nif (!wwid) {\r\nprintk(MPT2SAS_ERR_FMT\r\n"failure at %s:%d/%s()!\n", ioc->name,\r\n__FILE__, __LINE__, __func__);\r\nbreak;\r\n}\r\nraid_device = kzalloc(sizeof(struct _raid_device), GFP_KERNEL);\r\nif (!raid_device) {\r\nprintk(MPT2SAS_ERR_FMT\r\n"failure at %s:%d/%s()!\n", ioc->name,\r\n__FILE__, __LINE__, __func__);\r\nbreak;\r\n}\r\nraid_device->id = ioc->sas_id++;\r\nraid_device->channel = RAID_CHANNEL;\r\nraid_device->handle = handle;\r\nraid_device->wwid = wwid;\r\n_scsih_raid_device_add(ioc, raid_device);\r\nrc = scsi_add_device(ioc->shost, RAID_CHANNEL,\r\nraid_device->id, 0);\r\nif (rc)\r\n_scsih_raid_device_remove(ioc, raid_device);\r\nbreak;\r\ncase MPI2_RAID_VOL_STATE_INITIALIZING:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void\r\n_scsih_sas_ir_physical_disk_event(struct MPT2SAS_ADAPTER *ioc,\r\nstruct fw_event_work *fw_event)\r\n{\r\nu16 handle, parent_handle;\r\nu32 state;\r\nstruct _sas_device *sas_device;\r\nunsigned long flags;\r\nMpi2ConfigReply_t mpi_reply;\r\nMpi2SasDevicePage0_t sas_device_pg0;\r\nu32 ioc_status;\r\nMpi2EventDataIrPhysicalDisk_t *event_data =\r\n(Mpi2EventDataIrPhysicalDisk_t *)\r\nfw_event->event_data;\r\nu64 sas_address;\r\nif (ioc->shost_recovery)\r\nreturn;\r\nif (event_data->ReasonCode != MPI2_EVENT_IR_PHYSDISK_RC_STATE_CHANGED)\r\nreturn;\r\nhandle = le16_to_cpu(event_data->PhysDiskDevHandle);\r\nstate = le32_to_cpu(event_data->NewValue);\r\nif (!ioc->hide_ir_msg)\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: handle(0x%04x), "\r\n"old(0x%08x), new(0x%08x)\n", ioc->name, __func__, handle,\r\nle32_to_cpu(event_data->PreviousValue), state));\r\nswitch (state) {\r\ncase MPI2_RAID_PD_STATE_ONLINE:\r\ncase MPI2_RAID_PD_STATE_DEGRADED:\r\ncase MPI2_RAID_PD_STATE_REBUILDING:\r\ncase MPI2_RAID_PD_STATE_OPTIMAL:\r\ncase MPI2_RAID_PD_STATE_HOT_SPARE:\r\nif (!ioc->is_warpdrive)\r\nset_bit(handle, ioc->pd_handles);\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nsas_device = _scsih_sas_device_find_by_handle(ioc, handle);\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\nif (sas_device)\r\nreturn;\r\nif ((mpt2sas_config_get_sas_device_pg0(ioc, &mpi_reply,\r\n&sas_device_pg0, MPI2_SAS_DEVICE_PGAD_FORM_HANDLE,\r\nhandle))) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn;\r\n}\r\nioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\r\nMPI2_IOCSTATUS_MASK;\r\nif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn;\r\n}\r\nparent_handle = le16_to_cpu(sas_device_pg0.ParentDevHandle);\r\nif (!_scsih_get_sas_address(ioc, parent_handle, &sas_address))\r\nmpt2sas_transport_update_links(ioc, sas_address, handle,\r\nsas_device_pg0.PhyNum, MPI2_SAS_NEG_LINK_RATE_1_5);\r\n_scsih_add_device(ioc, handle, 0, 1);\r\nbreak;\r\ncase MPI2_RAID_PD_STATE_OFFLINE:\r\ncase MPI2_RAID_PD_STATE_NOT_CONFIGURED:\r\ncase MPI2_RAID_PD_STATE_NOT_COMPATIBLE:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void\r\n_scsih_sas_ir_operation_status_event_debug(struct MPT2SAS_ADAPTER *ioc,\r\nMpi2EventDataIrOperationStatus_t *event_data)\r\n{\r\nchar *reason_str = NULL;\r\nswitch (event_data->RAIDOperation) {\r\ncase MPI2_EVENT_IR_RAIDOP_RESYNC:\r\nreason_str = "resync";\r\nbreak;\r\ncase MPI2_EVENT_IR_RAIDOP_ONLINE_CAP_EXPANSION:\r\nreason_str = "online capacity expansion";\r\nbreak;\r\ncase MPI2_EVENT_IR_RAIDOP_CONSISTENCY_CHECK:\r\nreason_str = "consistency check";\r\nbreak;\r\ncase MPI2_EVENT_IR_RAIDOP_BACKGROUND_INIT:\r\nreason_str = "background init";\r\nbreak;\r\ncase MPI2_EVENT_IR_RAIDOP_MAKE_DATA_CONSISTENT:\r\nreason_str = "make data consistent";\r\nbreak;\r\n}\r\nif (!reason_str)\r\nreturn;\r\nprintk(MPT2SAS_INFO_FMT "raid operational status: (%s)"\r\n"\thandle(0x%04x), percent complete(%d)\n",\r\nioc->name, reason_str,\r\nle16_to_cpu(event_data->VolDevHandle),\r\nevent_data->PercentComplete);\r\n}\r\nstatic void\r\n_scsih_sas_ir_operation_status_event(struct MPT2SAS_ADAPTER *ioc,\r\nstruct fw_event_work *fw_event)\r\n{\r\nMpi2EventDataIrOperationStatus_t *event_data =\r\n(Mpi2EventDataIrOperationStatus_t *)\r\nfw_event->event_data;\r\nstatic struct _raid_device *raid_device;\r\nunsigned long flags;\r\nu16 handle;\r\n#ifdef CONFIG_SCSI_MPT2SAS_LOGGING\r\nif ((ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK)\r\n&& !ioc->hide_ir_msg)\r\n_scsih_sas_ir_operation_status_event_debug(ioc,\r\nevent_data);\r\n#endif\r\nif (event_data->RAIDOperation == MPI2_EVENT_IR_RAIDOP_RESYNC) {\r\nspin_lock_irqsave(&ioc->raid_device_lock, flags);\r\nhandle = le16_to_cpu(event_data->VolDevHandle);\r\nraid_device = _scsih_raid_device_find_by_handle(ioc, handle);\r\nif (raid_device)\r\nraid_device->percent_complete =\r\nevent_data->PercentComplete;\r\nspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\r\n}\r\n}\r\nstatic void\r\n_scsih_prep_device_scan(struct MPT2SAS_ADAPTER *ioc)\r\n{\r\nstruct MPT2SAS_DEVICE *sas_device_priv_data;\r\nstruct scsi_device *sdev;\r\nshost_for_each_device(sdev, ioc->shost) {\r\nsas_device_priv_data = sdev->hostdata;\r\nif (sas_device_priv_data && sas_device_priv_data->sas_target)\r\nsas_device_priv_data->sas_target->deleted = 1;\r\n}\r\n}\r\nstatic void\r\n_scsih_mark_responding_sas_device(struct MPT2SAS_ADAPTER *ioc, u64 sas_address,\r\nu16 slot, u16 handle)\r\n{\r\nstruct MPT2SAS_TARGET *sas_target_priv_data = NULL;\r\nstruct scsi_target *starget;\r\nstruct _sas_device *sas_device;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nlist_for_each_entry(sas_device, &ioc->sas_device_list, list) {\r\nif (sas_device->sas_address == sas_address &&\r\nsas_device->slot == slot) {\r\nsas_device->responding = 1;\r\nstarget = sas_device->starget;\r\nif (starget && starget->hostdata) {\r\nsas_target_priv_data = starget->hostdata;\r\nsas_target_priv_data->tm_busy = 0;\r\nsas_target_priv_data->deleted = 0;\r\n} else\r\nsas_target_priv_data = NULL;\r\nif (starget)\r\nstarget_printk(KERN_INFO, starget,\r\n"handle(0x%04x), sas_addr(0x%016llx), "\r\n"enclosure logical id(0x%016llx), "\r\n"slot(%d)\n", handle,\r\n(unsigned long long)sas_device->sas_address,\r\n(unsigned long long)\r\nsas_device->enclosure_logical_id,\r\nsas_device->slot);\r\nif (sas_device->handle == handle)\r\ngoto out;\r\nprintk(KERN_INFO "\thandle changed from(0x%04x)!!!\n",\r\nsas_device->handle);\r\nsas_device->handle = handle;\r\nif (sas_target_priv_data)\r\nsas_target_priv_data->handle = handle;\r\ngoto out;\r\n}\r\n}\r\nout:\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\n}\r\nstatic void\r\n_scsih_search_responding_sas_devices(struct MPT2SAS_ADAPTER *ioc)\r\n{\r\nMpi2SasDevicePage0_t sas_device_pg0;\r\nMpi2ConfigReply_t mpi_reply;\r\nu16 ioc_status;\r\n__le64 sas_address;\r\nu16 handle;\r\nu32 device_info;\r\nu16 slot;\r\nprintk(MPT2SAS_INFO_FMT "search for end-devices: start\n", ioc->name);\r\nif (list_empty(&ioc->sas_device_list))\r\ngoto out;\r\nhandle = 0xFFFF;\r\nwhile (!(mpt2sas_config_get_sas_device_pg0(ioc, &mpi_reply,\r\n&sas_device_pg0, MPI2_SAS_DEVICE_PGAD_FORM_GET_NEXT_HANDLE,\r\nhandle))) {\r\nioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\r\nMPI2_IOCSTATUS_MASK;\r\nif (ioc_status != MPI2_IOCSTATUS_SUCCESS)\r\nbreak;\r\nhandle = le16_to_cpu(sas_device_pg0.DevHandle);\r\ndevice_info = le32_to_cpu(sas_device_pg0.DeviceInfo);\r\nif (!(_scsih_is_end_device(device_info)))\r\ncontinue;\r\nsas_address = le64_to_cpu(sas_device_pg0.SASAddress);\r\nslot = le16_to_cpu(sas_device_pg0.Slot);\r\n_scsih_mark_responding_sas_device(ioc, sas_address, slot,\r\nhandle);\r\n}\r\nout:\r\nprintk(MPT2SAS_INFO_FMT "search for end-devices: complete\n",\r\nioc->name);\r\n}\r\nstatic void\r\n_scsih_mark_responding_raid_device(struct MPT2SAS_ADAPTER *ioc, u64 wwid,\r\nu16 handle)\r\n{\r\nstruct MPT2SAS_TARGET *sas_target_priv_data;\r\nstruct scsi_target *starget;\r\nstruct _raid_device *raid_device;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ioc->raid_device_lock, flags);\r\nlist_for_each_entry(raid_device, &ioc->raid_device_list, list) {\r\nif (raid_device->wwid == wwid && raid_device->starget) {\r\nstarget = raid_device->starget;\r\nif (starget && starget->hostdata) {\r\nsas_target_priv_data = starget->hostdata;\r\nsas_target_priv_data->deleted = 0;\r\n} else\r\nsas_target_priv_data = NULL;\r\nraid_device->responding = 1;\r\nspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\r\nstarget_printk(KERN_INFO, raid_device->starget,\r\n"handle(0x%04x), wwid(0x%016llx)\n", handle,\r\n(unsigned long long)raid_device->wwid);\r\n_scsih_init_warpdrive_properties(ioc, raid_device);\r\nspin_lock_irqsave(&ioc->raid_device_lock, flags);\r\nif (raid_device->handle == handle) {\r\nspin_unlock_irqrestore(&ioc->raid_device_lock,\r\nflags);\r\nreturn;\r\n}\r\nprintk(KERN_INFO "\thandle changed from(0x%04x)!!!\n",\r\nraid_device->handle);\r\nraid_device->handle = handle;\r\nif (sas_target_priv_data)\r\nsas_target_priv_data->handle = handle;\r\nspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\r\nreturn;\r\n}\r\n}\r\nspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\r\n}\r\nstatic void\r\n_scsih_search_responding_raid_devices(struct MPT2SAS_ADAPTER *ioc)\r\n{\r\nMpi2RaidVolPage1_t volume_pg1;\r\nMpi2RaidVolPage0_t volume_pg0;\r\nMpi2RaidPhysDiskPage0_t pd_pg0;\r\nMpi2ConfigReply_t mpi_reply;\r\nu16 ioc_status;\r\nu16 handle;\r\nu8 phys_disk_num;\r\nif (!ioc->ir_firmware)\r\nreturn;\r\nprintk(MPT2SAS_INFO_FMT "search for raid volumes: start\n",\r\nioc->name);\r\nif (list_empty(&ioc->raid_device_list))\r\ngoto out;\r\nhandle = 0xFFFF;\r\nwhile (!(mpt2sas_config_get_raid_volume_pg1(ioc, &mpi_reply,\r\n&volume_pg1, MPI2_RAID_VOLUME_PGAD_FORM_GET_NEXT_HANDLE, handle))) {\r\nioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\r\nMPI2_IOCSTATUS_MASK;\r\nif (ioc_status != MPI2_IOCSTATUS_SUCCESS)\r\nbreak;\r\nhandle = le16_to_cpu(volume_pg1.DevHandle);\r\nif (mpt2sas_config_get_raid_volume_pg0(ioc, &mpi_reply,\r\n&volume_pg0, MPI2_RAID_VOLUME_PGAD_FORM_HANDLE, handle,\r\nsizeof(Mpi2RaidVolPage0_t)))\r\ncontinue;\r\nif (volume_pg0.VolumeState == MPI2_RAID_VOL_STATE_OPTIMAL ||\r\nvolume_pg0.VolumeState == MPI2_RAID_VOL_STATE_ONLINE ||\r\nvolume_pg0.VolumeState == MPI2_RAID_VOL_STATE_DEGRADED)\r\n_scsih_mark_responding_raid_device(ioc,\r\nle64_to_cpu(volume_pg1.WWID), handle);\r\n}\r\nif (!ioc->is_warpdrive) {\r\nphys_disk_num = 0xFF;\r\nmemset(ioc->pd_handles, 0, ioc->pd_handles_sz);\r\nwhile (!(mpt2sas_config_get_phys_disk_pg0(ioc, &mpi_reply,\r\n&pd_pg0, MPI2_PHYSDISK_PGAD_FORM_GET_NEXT_PHYSDISKNUM,\r\nphys_disk_num))) {\r\nioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\r\nMPI2_IOCSTATUS_MASK;\r\nif (ioc_status != MPI2_IOCSTATUS_SUCCESS)\r\nbreak;\r\nphys_disk_num = pd_pg0.PhysDiskNum;\r\nhandle = le16_to_cpu(pd_pg0.DevHandle);\r\nset_bit(handle, ioc->pd_handles);\r\n}\r\n}\r\nout:\r\nprintk(MPT2SAS_INFO_FMT "search for responding raid volumes: "\r\n"complete\n", ioc->name);\r\n}\r\nstatic void\r\n_scsih_mark_responding_expander(struct MPT2SAS_ADAPTER *ioc, u64 sas_address,\r\nu16 handle)\r\n{\r\nstruct _sas_node *sas_expander;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&ioc->sas_node_lock, flags);\r\nlist_for_each_entry(sas_expander, &ioc->sas_expander_list, list) {\r\nif (sas_expander->sas_address != sas_address)\r\ncontinue;\r\nsas_expander->responding = 1;\r\nif (sas_expander->handle == handle)\r\ngoto out;\r\nprintk(KERN_INFO "\texpander(0x%016llx): handle changed"\r\n" from(0x%04x) to (0x%04x)!!!\n",\r\n(unsigned long long)sas_expander->sas_address,\r\nsas_expander->handle, handle);\r\nsas_expander->handle = handle;\r\nfor (i = 0 ; i < sas_expander->num_phys ; i++)\r\nsas_expander->phy[i].handle = handle;\r\ngoto out;\r\n}\r\nout:\r\nspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\r\n}\r\nstatic void\r\n_scsih_search_responding_expanders(struct MPT2SAS_ADAPTER *ioc)\r\n{\r\nMpi2ExpanderPage0_t expander_pg0;\r\nMpi2ConfigReply_t mpi_reply;\r\nu16 ioc_status;\r\nu64 sas_address;\r\nu16 handle;\r\nprintk(MPT2SAS_INFO_FMT "search for expanders: start\n", ioc->name);\r\nif (list_empty(&ioc->sas_expander_list))\r\ngoto out;\r\nhandle = 0xFFFF;\r\nwhile (!(mpt2sas_config_get_expander_pg0(ioc, &mpi_reply, &expander_pg0,\r\nMPI2_SAS_EXPAND_PGAD_FORM_GET_NEXT_HNDL, handle))) {\r\nioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\r\nMPI2_IOCSTATUS_MASK;\r\nif (ioc_status != MPI2_IOCSTATUS_SUCCESS)\r\nbreak;\r\nhandle = le16_to_cpu(expander_pg0.DevHandle);\r\nsas_address = le64_to_cpu(expander_pg0.SASAddress);\r\nprintk(KERN_INFO "\texpander present: handle(0x%04x), "\r\n"sas_addr(0x%016llx)\n", handle,\r\n(unsigned long long)sas_address);\r\n_scsih_mark_responding_expander(ioc, sas_address, handle);\r\n}\r\nout:\r\nprintk(MPT2SAS_INFO_FMT "search for expanders: complete\n", ioc->name);\r\n}\r\nstatic void\r\n_scsih_remove_unresponding_sas_devices(struct MPT2SAS_ADAPTER *ioc)\r\n{\r\nstruct _sas_device *sas_device, *sas_device_next;\r\nstruct _sas_node *sas_expander, *sas_expander_next;\r\nstruct _raid_device *raid_device, *raid_device_next;\r\nstruct list_head tmp_list;\r\nunsigned long flags;\r\nprintk(MPT2SAS_INFO_FMT "removing unresponding devices: start\n",\r\nioc->name);\r\nprintk(MPT2SAS_INFO_FMT "removing unresponding devices: end-devices\n",\r\nioc->name);\r\nlist_for_each_entry_safe(sas_device, sas_device_next,\r\n&ioc->sas_device_list, list) {\r\nif (!sas_device->responding)\r\nmpt2sas_device_remove_by_sas_address(ioc,\r\nsas_device->sas_address);\r\nelse\r\nsas_device->responding = 0;\r\n}\r\nif (ioc->ir_firmware) {\r\nprintk(MPT2SAS_INFO_FMT "removing unresponding devices: "\r\n"volumes\n", ioc->name);\r\nlist_for_each_entry_safe(raid_device, raid_device_next,\r\n&ioc->raid_device_list, list) {\r\nif (!raid_device->responding)\r\n_scsih_sas_volume_delete(ioc,\r\nraid_device->handle);\r\nelse\r\nraid_device->responding = 0;\r\n}\r\n}\r\nprintk(MPT2SAS_INFO_FMT "removing unresponding devices: expanders\n",\r\nioc->name);\r\nspin_lock_irqsave(&ioc->sas_node_lock, flags);\r\nINIT_LIST_HEAD(&tmp_list);\r\nlist_for_each_entry_safe(sas_expander, sas_expander_next,\r\n&ioc->sas_expander_list, list) {\r\nif (!sas_expander->responding)\r\nlist_move_tail(&sas_expander->list, &tmp_list);\r\nelse\r\nsas_expander->responding = 0;\r\n}\r\nspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\r\nlist_for_each_entry_safe(sas_expander, sas_expander_next, &tmp_list,\r\nlist) {\r\nlist_del(&sas_expander->list);\r\n_scsih_expander_node_remove(ioc, sas_expander);\r\n}\r\nprintk(MPT2SAS_INFO_FMT "removing unresponding devices: complete\n",\r\nioc->name);\r\n_scsih_ublock_io_all_device(ioc);\r\n}\r\nstatic void\r\n_scsih_refresh_expander_links(struct MPT2SAS_ADAPTER *ioc,\r\nstruct _sas_node *sas_expander, u16 handle)\r\n{\r\nMpi2ExpanderPage1_t expander_pg1;\r\nMpi2ConfigReply_t mpi_reply;\r\nint i;\r\nfor (i = 0 ; i < sas_expander->num_phys ; i++) {\r\nif ((mpt2sas_config_get_expander_pg1(ioc, &mpi_reply,\r\n&expander_pg1, i, handle))) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn;\r\n}\r\nmpt2sas_transport_update_links(ioc, sas_expander->sas_address,\r\nle16_to_cpu(expander_pg1.AttachedDevHandle), i,\r\nexpander_pg1.NegotiatedLinkRate >> 4);\r\n}\r\n}\r\nstatic void\r\n_scsih_scan_for_devices_after_reset(struct MPT2SAS_ADAPTER *ioc)\r\n{\r\nMpi2ExpanderPage0_t expander_pg0;\r\nMpi2SasDevicePage0_t sas_device_pg0;\r\nMpi2RaidVolPage1_t volume_pg1;\r\nMpi2RaidVolPage0_t volume_pg0;\r\nMpi2RaidPhysDiskPage0_t pd_pg0;\r\nMpi2EventIrConfigElement_t element;\r\nMpi2ConfigReply_t mpi_reply;\r\nu8 phys_disk_num;\r\nu16 ioc_status;\r\nu16 handle, parent_handle;\r\nu64 sas_address;\r\nstruct _sas_device *sas_device;\r\nstruct _sas_node *expander_device;\r\nstatic struct _raid_device *raid_device;\r\nu8 retry_count;\r\nunsigned long flags;\r\nprintk(MPT2SAS_INFO_FMT "scan devices: start\n", ioc->name);\r\n_scsih_sas_host_refresh(ioc);\r\nprintk(MPT2SAS_INFO_FMT "\tscan devices: expanders start\n",\r\nioc->name);\r\nhandle = 0xFFFF;\r\nwhile (!(mpt2sas_config_get_expander_pg0(ioc, &mpi_reply, &expander_pg0,\r\nMPI2_SAS_EXPAND_PGAD_FORM_GET_NEXT_HNDL, handle))) {\r\nioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\r\nMPI2_IOCSTATUS_MASK;\r\nif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\r\nprintk(MPT2SAS_INFO_FMT "\tbreak from expander scan: "\r\n"ioc_status(0x%04x), loginfo(0x%08x)\n",\r\nioc->name, ioc_status,\r\nle32_to_cpu(mpi_reply.IOCLogInfo));\r\nbreak;\r\n}\r\nhandle = le16_to_cpu(expander_pg0.DevHandle);\r\nspin_lock_irqsave(&ioc->sas_node_lock, flags);\r\nexpander_device = mpt2sas_scsih_expander_find_by_sas_address(\r\nioc, le64_to_cpu(expander_pg0.SASAddress));\r\nspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\r\nif (expander_device)\r\n_scsih_refresh_expander_links(ioc, expander_device,\r\nhandle);\r\nelse {\r\nprintk(MPT2SAS_INFO_FMT "\tBEFORE adding expander: "\r\n"handle (0x%04x), sas_addr(0x%016llx)\n",\r\nioc->name, handle, (unsigned long long)\r\nle64_to_cpu(expander_pg0.SASAddress));\r\n_scsih_expander_add(ioc, handle);\r\nprintk(MPT2SAS_INFO_FMT "\tAFTER adding expander: "\r\n"handle (0x%04x), sas_addr(0x%016llx)\n",\r\nioc->name, handle, (unsigned long long)\r\nle64_to_cpu(expander_pg0.SASAddress));\r\n}\r\n}\r\nprintk(MPT2SAS_INFO_FMT "\tscan devices: expanders complete\n",\r\nioc->name);\r\nif (!ioc->ir_firmware)\r\ngoto skip_to_sas;\r\nprintk(MPT2SAS_INFO_FMT "\tscan devices phys disk start\n", ioc->name);\r\nphys_disk_num = 0xFF;\r\nwhile (!(mpt2sas_config_get_phys_disk_pg0(ioc, &mpi_reply,\r\n&pd_pg0, MPI2_PHYSDISK_PGAD_FORM_GET_NEXT_PHYSDISKNUM,\r\nphys_disk_num))) {\r\nioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\r\nMPI2_IOCSTATUS_MASK;\r\nif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\r\nprintk(MPT2SAS_INFO_FMT "\tbreak from phys disk scan:"\r\n"ioc_status(0x%04x), loginfo(0x%08x)\n",\r\nioc->name, ioc_status,\r\nle32_to_cpu(mpi_reply.IOCLogInfo));\r\nbreak;\r\n}\r\nphys_disk_num = pd_pg0.PhysDiskNum;\r\nhandle = le16_to_cpu(pd_pg0.DevHandle);\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nsas_device = _scsih_sas_device_find_by_handle(ioc, handle);\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\nif (sas_device)\r\ncontinue;\r\nif (mpt2sas_config_get_sas_device_pg0(ioc, &mpi_reply,\r\n&sas_device_pg0, MPI2_SAS_DEVICE_PGAD_FORM_HANDLE,\r\nhandle) != 0)\r\ncontinue;\r\nioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\r\nMPI2_IOCSTATUS_MASK;\r\nif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\r\nprintk(MPT2SAS_INFO_FMT "\tbreak from phys disk scan "\r\n"ioc_status(0x%04x), loginfo(0x%08x)\n",\r\nioc->name, ioc_status,\r\nle32_to_cpu(mpi_reply.IOCLogInfo));\r\nbreak;\r\n}\r\nparent_handle = le16_to_cpu(sas_device_pg0.ParentDevHandle);\r\nif (!_scsih_get_sas_address(ioc, parent_handle,\r\n&sas_address)) {\r\nprintk(MPT2SAS_INFO_FMT "\tBEFORE adding phys disk: "\r\n" handle (0x%04x), sas_addr(0x%016llx)\n",\r\nioc->name, handle, (unsigned long long)\r\nle64_to_cpu(sas_device_pg0.SASAddress));\r\nmpt2sas_transport_update_links(ioc, sas_address,\r\nhandle, sas_device_pg0.PhyNum,\r\nMPI2_SAS_NEG_LINK_RATE_1_5);\r\nset_bit(handle, ioc->pd_handles);\r\nretry_count = 0;\r\nwhile (_scsih_add_device(ioc, handle, retry_count++,\r\n1)) {\r\nssleep(1);\r\n}\r\nprintk(MPT2SAS_INFO_FMT "\tAFTER adding phys disk: "\r\n" handle (0x%04x), sas_addr(0x%016llx)\n",\r\nioc->name, handle, (unsigned long long)\r\nle64_to_cpu(sas_device_pg0.SASAddress));\r\n}\r\n}\r\nprintk(MPT2SAS_INFO_FMT "\tscan devices: phys disk complete\n",\r\nioc->name);\r\nprintk(MPT2SAS_INFO_FMT "\tscan devices: volumes start\n", ioc->name);\r\nhandle = 0xFFFF;\r\nwhile (!(mpt2sas_config_get_raid_volume_pg1(ioc, &mpi_reply,\r\n&volume_pg1, MPI2_RAID_VOLUME_PGAD_FORM_GET_NEXT_HANDLE, handle))) {\r\nioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\r\nMPI2_IOCSTATUS_MASK;\r\nif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\r\nprintk(MPT2SAS_INFO_FMT "\tbreak from volume scan: "\r\n"ioc_status(0x%04x), loginfo(0x%08x)\n",\r\nioc->name, ioc_status,\r\nle32_to_cpu(mpi_reply.IOCLogInfo));\r\nbreak;\r\n}\r\nhandle = le16_to_cpu(volume_pg1.DevHandle);\r\nspin_lock_irqsave(&ioc->raid_device_lock, flags);\r\nraid_device = _scsih_raid_device_find_by_wwid(ioc,\r\nle64_to_cpu(volume_pg1.WWID));\r\nspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\r\nif (raid_device)\r\ncontinue;\r\nif (mpt2sas_config_get_raid_volume_pg0(ioc, &mpi_reply,\r\n&volume_pg0, MPI2_RAID_VOLUME_PGAD_FORM_HANDLE, handle,\r\nsizeof(Mpi2RaidVolPage0_t)))\r\ncontinue;\r\nioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\r\nMPI2_IOCSTATUS_MASK;\r\nif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\r\nprintk(MPT2SAS_INFO_FMT "\tbreak from volume scan: "\r\n"ioc_status(0x%04x), loginfo(0x%08x)\n",\r\nioc->name, ioc_status,\r\nle32_to_cpu(mpi_reply.IOCLogInfo));\r\nbreak;\r\n}\r\nif (volume_pg0.VolumeState == MPI2_RAID_VOL_STATE_OPTIMAL ||\r\nvolume_pg0.VolumeState == MPI2_RAID_VOL_STATE_ONLINE ||\r\nvolume_pg0.VolumeState == MPI2_RAID_VOL_STATE_DEGRADED) {\r\nmemset(&element, 0, sizeof(Mpi2EventIrConfigElement_t));\r\nelement.ReasonCode = MPI2_EVENT_IR_CHANGE_RC_ADDED;\r\nelement.VolDevHandle = volume_pg1.DevHandle;\r\nprintk(MPT2SAS_INFO_FMT "\tBEFORE adding volume: "\r\n" handle (0x%04x)\n", ioc->name,\r\nvolume_pg1.DevHandle);\r\n_scsih_sas_volume_add(ioc, &element);\r\nprintk(MPT2SAS_INFO_FMT "\tAFTER adding volume: "\r\n" handle (0x%04x)\n", ioc->name,\r\nvolume_pg1.DevHandle);\r\n}\r\n}\r\nprintk(MPT2SAS_INFO_FMT "\tscan devices: volumes complete\n",\r\nioc->name);\r\nskip_to_sas:\r\nprintk(MPT2SAS_INFO_FMT "\tscan devices: end devices start\n",\r\nioc->name);\r\nhandle = 0xFFFF;\r\nwhile (!(mpt2sas_config_get_sas_device_pg0(ioc, &mpi_reply,\r\n&sas_device_pg0, MPI2_SAS_DEVICE_PGAD_FORM_GET_NEXT_HANDLE,\r\nhandle))) {\r\nioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\r\nMPI2_IOCSTATUS_MASK;\r\nif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\r\nprintk(MPT2SAS_INFO_FMT "\tbreak from end device scan:"\r\n" ioc_status(0x%04x), loginfo(0x%08x)\n",\r\nioc->name, ioc_status,\r\nle32_to_cpu(mpi_reply.IOCLogInfo));\r\nbreak;\r\n}\r\nhandle = le16_to_cpu(sas_device_pg0.DevHandle);\r\nif (!(_scsih_is_end_device(\r\nle32_to_cpu(sas_device_pg0.DeviceInfo))))\r\ncontinue;\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nsas_device = mpt2sas_scsih_sas_device_find_by_sas_address(ioc,\r\nle64_to_cpu(sas_device_pg0.SASAddress));\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\nif (sas_device)\r\ncontinue;\r\nparent_handle = le16_to_cpu(sas_device_pg0.ParentDevHandle);\r\nif (!_scsih_get_sas_address(ioc, parent_handle, &sas_address)) {\r\nprintk(MPT2SAS_INFO_FMT "\tBEFORE adding end device: "\r\n"handle (0x%04x), sas_addr(0x%016llx)\n",\r\nioc->name, handle, (unsigned long long)\r\nle64_to_cpu(sas_device_pg0.SASAddress));\r\nmpt2sas_transport_update_links(ioc, sas_address, handle,\r\nsas_device_pg0.PhyNum, MPI2_SAS_NEG_LINK_RATE_1_5);\r\nretry_count = 0;\r\nwhile (_scsih_add_device(ioc, handle, retry_count++,\r\n0)) {\r\nssleep(1);\r\n}\r\nprintk(MPT2SAS_INFO_FMT "\tAFTER adding end device: "\r\n"handle (0x%04x), sas_addr(0x%016llx)\n",\r\nioc->name, handle, (unsigned long long)\r\nle64_to_cpu(sas_device_pg0.SASAddress));\r\n}\r\n}\r\nprintk(MPT2SAS_INFO_FMT "\tscan devices: end devices complete\n",\r\nioc->name);\r\nprintk(MPT2SAS_INFO_FMT "scan devices: complete\n", ioc->name);\r\n}\r\nvoid\r\nmpt2sas_scsih_reset_handler(struct MPT2SAS_ADAPTER *ioc, int reset_phase)\r\n{\r\nswitch (reset_phase) {\r\ncase MPT2_IOC_PRE_RESET:\r\ndtmprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: "\r\n"MPT2_IOC_PRE_RESET\n", ioc->name, __func__));\r\nbreak;\r\ncase MPT2_IOC_AFTER_RESET:\r\ndtmprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: "\r\n"MPT2_IOC_AFTER_RESET\n", ioc->name, __func__));\r\nif (ioc->scsih_cmds.status & MPT2_CMD_PENDING) {\r\nioc->scsih_cmds.status |= MPT2_CMD_RESET;\r\nmpt2sas_base_free_smid(ioc, ioc->scsih_cmds.smid);\r\ncomplete(&ioc->scsih_cmds.done);\r\n}\r\nif (ioc->tm_cmds.status & MPT2_CMD_PENDING) {\r\nioc->tm_cmds.status |= MPT2_CMD_RESET;\r\nmpt2sas_base_free_smid(ioc, ioc->tm_cmds.smid);\r\ncomplete(&ioc->tm_cmds.done);\r\n}\r\n_scsih_fw_event_cleanup_queue(ioc);\r\n_scsih_flush_running_cmds(ioc);\r\nbreak;\r\ncase MPT2_IOC_DONE_RESET:\r\ndtmprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: "\r\n"MPT2_IOC_DONE_RESET\n", ioc->name, __func__));\r\n_scsih_sas_host_refresh(ioc);\r\n_scsih_prep_device_scan(ioc);\r\n_scsih_search_responding_sas_devices(ioc);\r\n_scsih_search_responding_raid_devices(ioc);\r\n_scsih_search_responding_expanders(ioc);\r\nif ((!ioc->is_driver_loading) && !(disable_discovery > 0 &&\r\n!ioc->sas_hba.num_phys)) {\r\n_scsih_prep_device_scan(ioc);\r\n_scsih_search_responding_sas_devices(ioc);\r\n_scsih_search_responding_raid_devices(ioc);\r\n_scsih_search_responding_expanders(ioc);\r\n_scsih_error_recovery_delete_devices(ioc);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void\r\n_firmware_event_work(struct work_struct *work)\r\n{\r\nstruct fw_event_work *fw_event = container_of(work,\r\nstruct fw_event_work, delayed_work.work);\r\nstruct MPT2SAS_ADAPTER *ioc = fw_event->ioc;\r\nif (ioc->remove_host ||\r\nioc->pci_error_recovery) {\r\n_scsih_fw_event_free(ioc, fw_event);\r\nreturn;\r\n}\r\nswitch (fw_event->event) {\r\ncase MPT2SAS_REMOVE_UNRESPONDING_DEVICES:\r\nwhile (scsi_host_in_recovery(ioc->shost) || ioc->shost_recovery)\r\nssleep(1);\r\n_scsih_remove_unresponding_sas_devices(ioc);\r\n_scsih_scan_for_devices_after_reset(ioc);\r\nbreak;\r\ncase MPT2SAS_PORT_ENABLE_COMPLETE:\r\nioc->start_scan = 0;\r\nif (missing_delay[0] != -1 && missing_delay[1] != -1)\r\nmpt2sas_base_update_missing_delay(ioc, missing_delay[0],\r\nmissing_delay[1]);\r\ndewtprintk(ioc, printk(MPT2SAS_INFO_FMT "port enable: complete "\r\n"from worker thread\n", ioc->name));\r\nbreak;\r\ncase MPT2SAS_TURN_ON_PFA_LED:\r\n_scsih_turn_on_pfa_led(ioc, fw_event->device_handle);\r\nbreak;\r\ncase MPI2_EVENT_SAS_TOPOLOGY_CHANGE_LIST:\r\n_scsih_sas_topology_change_event(ioc, fw_event);\r\nbreak;\r\ncase MPI2_EVENT_SAS_DEVICE_STATUS_CHANGE:\r\n_scsih_sas_device_status_change_event(ioc,\r\nfw_event);\r\nbreak;\r\ncase MPI2_EVENT_SAS_DISCOVERY:\r\n_scsih_sas_discovery_event(ioc,\r\nfw_event);\r\nbreak;\r\ncase MPI2_EVENT_SAS_BROADCAST_PRIMITIVE:\r\n_scsih_sas_broadcast_primitive_event(ioc,\r\nfw_event);\r\nbreak;\r\ncase MPI2_EVENT_SAS_ENCL_DEVICE_STATUS_CHANGE:\r\n_scsih_sas_enclosure_dev_status_change_event(ioc,\r\nfw_event);\r\nbreak;\r\ncase MPI2_EVENT_IR_CONFIGURATION_CHANGE_LIST:\r\n_scsih_sas_ir_config_change_event(ioc, fw_event);\r\nbreak;\r\ncase MPI2_EVENT_IR_VOLUME:\r\n_scsih_sas_ir_volume_event(ioc, fw_event);\r\nbreak;\r\ncase MPI2_EVENT_IR_PHYSICAL_DISK:\r\n_scsih_sas_ir_physical_disk_event(ioc, fw_event);\r\nbreak;\r\ncase MPI2_EVENT_IR_OPERATION_STATUS:\r\n_scsih_sas_ir_operation_status_event(ioc, fw_event);\r\nbreak;\r\n}\r\n_scsih_fw_event_free(ioc, fw_event);\r\n}\r\nvoid\r\nmpt2sas_scsih_event_callback(struct MPT2SAS_ADAPTER *ioc, u8 msix_index,\r\nu32 reply)\r\n{\r\nstruct fw_event_work *fw_event;\r\nMpi2EventNotificationReply_t *mpi_reply;\r\nu16 event;\r\nu16 sz;\r\nif (ioc->remove_host || ioc->pci_error_recovery)\r\nreturn;\r\nmpi_reply = mpt2sas_base_get_reply_virt_addr(ioc, reply);\r\nif (unlikely(!mpi_reply)) {\r\nprintk(MPT2SAS_ERR_FMT "mpi_reply not valid at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn;\r\n}\r\nevent = le16_to_cpu(mpi_reply->Event);\r\nswitch (event) {\r\ncase MPI2_EVENT_SAS_BROADCAST_PRIMITIVE:\r\n{\r\nMpi2EventDataSasBroadcastPrimitive_t *baen_data =\r\n(Mpi2EventDataSasBroadcastPrimitive_t *)\r\nmpi_reply->EventData;\r\nif (baen_data->Primitive !=\r\nMPI2_EVENT_PRIMITIVE_ASYNCHRONOUS_EVENT)\r\nreturn;\r\nif (ioc->broadcast_aen_busy) {\r\nioc->broadcast_aen_pending++;\r\nreturn;\r\n} else\r\nioc->broadcast_aen_busy = 1;\r\nbreak;\r\n}\r\ncase MPI2_EVENT_SAS_TOPOLOGY_CHANGE_LIST:\r\n_scsih_check_topo_delete_events(ioc,\r\n(Mpi2EventDataSasTopologyChangeList_t *)\r\nmpi_reply->EventData);\r\nbreak;\r\ncase MPI2_EVENT_IR_CONFIGURATION_CHANGE_LIST:\r\n_scsih_check_ir_config_unhide_events(ioc,\r\n(Mpi2EventDataIrConfigChangeList_t *)\r\nmpi_reply->EventData);\r\nbreak;\r\ncase MPI2_EVENT_IR_VOLUME:\r\n_scsih_check_volume_delete_events(ioc,\r\n(Mpi2EventDataIrVolume_t *)\r\nmpi_reply->EventData);\r\nbreak;\r\ncase MPI2_EVENT_LOG_ENTRY_ADDED:\r\n{\r\nMpi2EventDataLogEntryAdded_t *log_entry;\r\n__le32 *log_code;\r\nif (!ioc->is_warpdrive)\r\nbreak;\r\nlog_entry = (Mpi2EventDataLogEntryAdded_t *)\r\nmpi_reply->EventData;\r\nlog_code = (__le32 *)log_entry->LogData;\r\nif (le16_to_cpu(log_entry->LogEntryQualifier)\r\n!= MPT2_WARPDRIVE_LOGENTRY)\r\nbreak;\r\nswitch (le32_to_cpu(*log_code)) {\r\ncase MPT2_WARPDRIVE_LC_SSDT:\r\nprintk(MPT2SAS_WARN_FMT "WarpDrive Warning: "\r\n"IO Throttling has occurred in the WarpDrive "\r\n"subsystem. Check WarpDrive documentation for "\r\n"additional details.\n", ioc->name);\r\nbreak;\r\ncase MPT2_WARPDRIVE_LC_SSDLW:\r\nprintk(MPT2SAS_WARN_FMT "WarpDrive Warning: "\r\n"Program/Erase Cycles for the WarpDrive subsystem "\r\n"in degraded range. Check WarpDrive documentation "\r\n"for additional details.\n", ioc->name);\r\nbreak;\r\ncase MPT2_WARPDRIVE_LC_SSDLF:\r\nprintk(MPT2SAS_ERR_FMT "WarpDrive Fatal Error: "\r\n"There are no Program/Erase Cycles for the "\r\n"WarpDrive subsystem. The storage device will be "\r\n"in read-only mode. Check WarpDrive documentation "\r\n"for additional details.\n", ioc->name);\r\nbreak;\r\ncase MPT2_WARPDRIVE_LC_BRMF:\r\nprintk(MPT2SAS_ERR_FMT "WarpDrive Fatal Error: "\r\n"The Backup Rail Monitor has failed on the "\r\n"WarpDrive subsystem. Check WarpDrive "\r\n"documentation for additional details.\n",\r\nioc->name);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase MPI2_EVENT_SAS_DEVICE_STATUS_CHANGE:\r\ncase MPI2_EVENT_IR_OPERATION_STATUS:\r\ncase MPI2_EVENT_SAS_DISCOVERY:\r\ncase MPI2_EVENT_SAS_ENCL_DEVICE_STATUS_CHANGE:\r\ncase MPI2_EVENT_IR_PHYSICAL_DISK:\r\nbreak;\r\ncase MPI2_EVENT_TEMP_THRESHOLD:\r\n_scsih_temp_threshold_events(ioc,\r\n(Mpi2EventDataTemperature_t *)\r\nmpi_reply->EventData);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nsz = le16_to_cpu(mpi_reply->EventDataLength) * 4;\r\nfw_event = kzalloc(sizeof(*fw_event) + sz, GFP_ATOMIC);\r\nif (!fw_event) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn;\r\n}\r\nmemcpy(fw_event->event_data, mpi_reply->EventData, sz);\r\nfw_event->ioc = ioc;\r\nfw_event->VF_ID = mpi_reply->VF_ID;\r\nfw_event->VP_ID = mpi_reply->VP_ID;\r\nfw_event->event = event;\r\n_scsih_fw_event_add(ioc, fw_event);\r\nreturn;\r\n}\r\nstatic void\r\n_scsih_expander_node_remove(struct MPT2SAS_ADAPTER *ioc,\r\nstruct _sas_node *sas_expander)\r\n{\r\nstruct _sas_port *mpt2sas_port, *next;\r\nlist_for_each_entry_safe(mpt2sas_port, next,\r\n&sas_expander->sas_port_list, port_list) {\r\nif (ioc->shost_recovery)\r\nreturn;\r\nif (mpt2sas_port->remote_identify.device_type ==\r\nSAS_END_DEVICE)\r\nmpt2sas_device_remove_by_sas_address(ioc,\r\nmpt2sas_port->remote_identify.sas_address);\r\nelse if (mpt2sas_port->remote_identify.device_type ==\r\nSAS_EDGE_EXPANDER_DEVICE ||\r\nmpt2sas_port->remote_identify.device_type ==\r\nSAS_FANOUT_EXPANDER_DEVICE)\r\nmpt2sas_expander_remove(ioc,\r\nmpt2sas_port->remote_identify.sas_address);\r\n}\r\nmpt2sas_transport_port_remove(ioc, sas_expander->sas_address,\r\nsas_expander->sas_address_parent);\r\nprintk(MPT2SAS_INFO_FMT "expander_remove: handle"\r\n"(0x%04x), sas_addr(0x%016llx)\n", ioc->name,\r\nsas_expander->handle, (unsigned long long)\r\nsas_expander->sas_address);\r\nkfree(sas_expander->phy);\r\nkfree(sas_expander);\r\n}\r\nstatic void\r\n_scsih_ir_shutdown(struct MPT2SAS_ADAPTER *ioc)\r\n{\r\nMpi2RaidActionRequest_t *mpi_request;\r\nMpi2RaidActionReply_t *mpi_reply;\r\nu16 smid;\r\nif (!ioc->ir_firmware)\r\nreturn;\r\nmutex_lock(&ioc->scsih_cmds.mutex);\r\nif (ioc->scsih_cmds.status != MPT2_CMD_NOT_USED) {\r\nprintk(MPT2SAS_ERR_FMT "%s: scsih_cmd in use\n",\r\nioc->name, __func__);\r\ngoto out;\r\n}\r\nioc->scsih_cmds.status = MPT2_CMD_PENDING;\r\nsmid = mpt2sas_base_get_smid(ioc, ioc->scsih_cb_idx);\r\nif (!smid) {\r\nprintk(MPT2SAS_ERR_FMT "%s: failed obtaining a smid\n",\r\nioc->name, __func__);\r\nioc->scsih_cmds.status = MPT2_CMD_NOT_USED;\r\ngoto out;\r\n}\r\nmpi_request = mpt2sas_base_get_msg_frame(ioc, smid);\r\nioc->scsih_cmds.smid = smid;\r\nmemset(mpi_request, 0, sizeof(Mpi2RaidActionRequest_t));\r\nmpi_request->Function = MPI2_FUNCTION_RAID_ACTION;\r\nmpi_request->Action = MPI2_RAID_ACTION_SYSTEM_SHUTDOWN_INITIATED;\r\nif (!ioc->hide_ir_msg)\r\nprintk(MPT2SAS_INFO_FMT "IR shutdown (sending)\n", ioc->name);\r\ninit_completion(&ioc->scsih_cmds.done);\r\nmpt2sas_base_put_smid_default(ioc, smid);\r\nwait_for_completion_timeout(&ioc->scsih_cmds.done, 10*HZ);\r\nif (!(ioc->scsih_cmds.status & MPT2_CMD_COMPLETE)) {\r\nprintk(MPT2SAS_ERR_FMT "%s: timeout\n",\r\nioc->name, __func__);\r\ngoto out;\r\n}\r\nif (ioc->scsih_cmds.status & MPT2_CMD_REPLY_VALID) {\r\nmpi_reply = ioc->scsih_cmds.reply;\r\nif (!ioc->hide_ir_msg)\r\nprintk(MPT2SAS_INFO_FMT "IR shutdown (complete): "\r\n"ioc_status(0x%04x), loginfo(0x%08x)\n",\r\nioc->name, le16_to_cpu(mpi_reply->IOCStatus),\r\nle32_to_cpu(mpi_reply->IOCLogInfo));\r\n}\r\nout:\r\nioc->scsih_cmds.status = MPT2_CMD_NOT_USED;\r\nmutex_unlock(&ioc->scsih_cmds.mutex);\r\n}\r\nstatic void\r\n_scsih_shutdown(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nstruct workqueue_struct *wq;\r\nunsigned long flags;\r\nioc->remove_host = 1;\r\n_scsih_fw_event_cleanup_queue(ioc);\r\nspin_lock_irqsave(&ioc->fw_event_lock, flags);\r\nwq = ioc->firmware_event_thread;\r\nioc->firmware_event_thread = NULL;\r\nspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\r\nif (wq)\r\ndestroy_workqueue(wq);\r\n_scsih_ir_shutdown(ioc);\r\nmpt2sas_base_detach(ioc);\r\n}\r\nstatic void\r\n_scsih_remove(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nstruct _sas_port *mpt2sas_port, *next_port;\r\nstruct _raid_device *raid_device, *next;\r\nstruct MPT2SAS_TARGET *sas_target_priv_data;\r\nstruct workqueue_struct *wq;\r\nunsigned long flags;\r\nioc->remove_host = 1;\r\n_scsih_fw_event_cleanup_queue(ioc);\r\nspin_lock_irqsave(&ioc->fw_event_lock, flags);\r\nwq = ioc->firmware_event_thread;\r\nioc->firmware_event_thread = NULL;\r\nspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\r\nif (wq)\r\ndestroy_workqueue(wq);\r\n_scsih_ir_shutdown(ioc);\r\nlist_for_each_entry_safe(raid_device, next, &ioc->raid_device_list,\r\nlist) {\r\nif (raid_device->starget) {\r\nsas_target_priv_data =\r\nraid_device->starget->hostdata;\r\nsas_target_priv_data->deleted = 1;\r\nscsi_remove_target(&raid_device->starget->dev);\r\n}\r\nprintk(MPT2SAS_INFO_FMT "removing handle(0x%04x), wwid"\r\n"(0x%016llx)\n", ioc->name, raid_device->handle,\r\n(unsigned long long) raid_device->wwid);\r\n_scsih_raid_device_remove(ioc, raid_device);\r\n}\r\nlist_for_each_entry_safe(mpt2sas_port, next_port,\r\n&ioc->sas_hba.sas_port_list, port_list) {\r\nif (mpt2sas_port->remote_identify.device_type ==\r\nSAS_END_DEVICE)\r\nmpt2sas_device_remove_by_sas_address(ioc,\r\nmpt2sas_port->remote_identify.sas_address);\r\nelse if (mpt2sas_port->remote_identify.device_type ==\r\nSAS_EDGE_EXPANDER_DEVICE ||\r\nmpt2sas_port->remote_identify.device_type ==\r\nSAS_FANOUT_EXPANDER_DEVICE)\r\nmpt2sas_expander_remove(ioc,\r\nmpt2sas_port->remote_identify.sas_address);\r\n}\r\nif (ioc->sas_hba.num_phys) {\r\nkfree(ioc->sas_hba.phy);\r\nioc->sas_hba.phy = NULL;\r\nioc->sas_hba.num_phys = 0;\r\n}\r\nsas_remove_host(shost);\r\nscsi_remove_host(shost);\r\nmpt2sas_base_detach(ioc);\r\nlist_del(&ioc->list);\r\nscsi_host_put(shost);\r\n}\r\nstatic void\r\n_scsih_probe_boot_devices(struct MPT2SAS_ADAPTER *ioc)\r\n{\r\nu8 is_raid;\r\nvoid *device;\r\nstruct _sas_device *sas_device;\r\nstruct _raid_device *raid_device;\r\nu16 handle;\r\nu64 sas_address_parent;\r\nu64 sas_address;\r\nunsigned long flags;\r\nint rc;\r\nif (!ioc->bios_pg3.BiosVersion)\r\nreturn;\r\ndevice = NULL;\r\nis_raid = 0;\r\nif (ioc->req_boot_device.device) {\r\ndevice = ioc->req_boot_device.device;\r\nis_raid = ioc->req_boot_device.is_raid;\r\n} else if (ioc->req_alt_boot_device.device) {\r\ndevice = ioc->req_alt_boot_device.device;\r\nis_raid = ioc->req_alt_boot_device.is_raid;\r\n} else if (ioc->current_boot_device.device) {\r\ndevice = ioc->current_boot_device.device;\r\nis_raid = ioc->current_boot_device.is_raid;\r\n}\r\nif (!device)\r\nreturn;\r\nif (is_raid) {\r\nraid_device = device;\r\nrc = scsi_add_device(ioc->shost, RAID_CHANNEL,\r\nraid_device->id, 0);\r\nif (rc)\r\n_scsih_raid_device_remove(ioc, raid_device);\r\n} else {\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nsas_device = device;\r\nhandle = sas_device->handle;\r\nsas_address_parent = sas_device->sas_address_parent;\r\nsas_address = sas_device->sas_address;\r\nlist_move_tail(&sas_device->list, &ioc->sas_device_list);\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\nif (ioc->hide_drives)\r\nreturn;\r\nif (!mpt2sas_transport_port_add(ioc, sas_device->handle,\r\nsas_device->sas_address_parent)) {\r\n_scsih_sas_device_remove(ioc, sas_device);\r\n} else if (!sas_device->starget) {\r\nif (!ioc->is_driver_loading) {\r\nmpt2sas_transport_port_remove(ioc,\r\nsas_address,\r\nsas_address_parent);\r\n_scsih_sas_device_remove(ioc, sas_device);\r\n}\r\n}\r\n}\r\n}\r\nstatic void\r\n_scsih_probe_raid(struct MPT2SAS_ADAPTER *ioc)\r\n{\r\nstruct _raid_device *raid_device, *raid_next;\r\nint rc;\r\nlist_for_each_entry_safe(raid_device, raid_next,\r\n&ioc->raid_device_list, list) {\r\nif (raid_device->starget)\r\ncontinue;\r\nrc = scsi_add_device(ioc->shost, RAID_CHANNEL,\r\nraid_device->id, 0);\r\nif (rc)\r\n_scsih_raid_device_remove(ioc, raid_device);\r\n}\r\n}\r\nstatic void\r\n_scsih_probe_sas(struct MPT2SAS_ADAPTER *ioc)\r\n{\r\nstruct _sas_device *sas_device, *next;\r\nunsigned long flags;\r\nlist_for_each_entry_safe(sas_device, next, &ioc->sas_device_init_list,\r\nlist) {\r\nif (ioc->hide_drives)\r\ncontinue;\r\nif (!mpt2sas_transport_port_add(ioc, sas_device->handle,\r\nsas_device->sas_address_parent)) {\r\nlist_del(&sas_device->list);\r\nkfree(sas_device);\r\ncontinue;\r\n} else if (!sas_device->starget) {\r\nif (!ioc->is_driver_loading) {\r\nmpt2sas_transport_port_remove(ioc,\r\nsas_device->sas_address,\r\nsas_device->sas_address_parent);\r\nlist_del(&sas_device->list);\r\nkfree(sas_device);\r\ncontinue;\r\n}\r\n}\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nlist_move_tail(&sas_device->list, &ioc->sas_device_list);\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\n}\r\n}\r\nstatic void\r\n_scsih_probe_devices(struct MPT2SAS_ADAPTER *ioc)\r\n{\r\nu16 volume_mapping_flags;\r\nif (!(ioc->facts.ProtocolFlags & MPI2_IOCFACTS_PROTOCOL_SCSI_INITIATOR))\r\nreturn;\r\n_scsih_probe_boot_devices(ioc);\r\nif (ioc->ir_firmware) {\r\nvolume_mapping_flags =\r\nle16_to_cpu(ioc->ioc_pg8.IRVolumeMappingFlags) &\r\nMPI2_IOCPAGE8_IRFLAGS_MASK_VOLUME_MAPPING_MODE;\r\nif (volume_mapping_flags ==\r\nMPI2_IOCPAGE8_IRFLAGS_LOW_VOLUME_MAPPING) {\r\n_scsih_probe_raid(ioc);\r\n_scsih_probe_sas(ioc);\r\n} else {\r\n_scsih_probe_sas(ioc);\r\n_scsih_probe_raid(ioc);\r\n}\r\n} else\r\n_scsih_probe_sas(ioc);\r\n}\r\nstatic void\r\n_scsih_scan_start(struct Scsi_Host *shost)\r\n{\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nint rc;\r\nif (diag_buffer_enable != -1 && diag_buffer_enable != 0)\r\nmpt2sas_enable_diag_buffer(ioc, diag_buffer_enable);\r\nif (disable_discovery > 0)\r\nreturn;\r\nioc->start_scan = 1;\r\nrc = mpt2sas_port_enable(ioc);\r\nif (rc != 0)\r\nprintk(MPT2SAS_INFO_FMT "port enable: FAILED\n", ioc->name);\r\n}\r\nstatic int\r\n_scsih_scan_finished(struct Scsi_Host *shost, unsigned long time)\r\n{\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nif (disable_discovery > 0) {\r\nioc->is_driver_loading = 0;\r\nioc->wait_for_discovery_to_complete = 0;\r\nreturn 1;\r\n}\r\nif (time >= (300 * HZ)) {\r\nioc->base_cmds.status = MPT2_CMD_NOT_USED;\r\nprintk(MPT2SAS_INFO_FMT "port enable: FAILED with timeout "\r\n"(timeout=300s)\n", ioc->name);\r\nioc->is_driver_loading = 0;\r\nreturn 1;\r\n}\r\nif (ioc->start_scan)\r\nreturn 0;\r\nif (ioc->start_scan_failed) {\r\nprintk(MPT2SAS_INFO_FMT "port enable: FAILED with "\r\n"(ioc_status=0x%08x)\n", ioc->name, ioc->start_scan_failed);\r\nioc->is_driver_loading = 0;\r\nioc->wait_for_discovery_to_complete = 0;\r\nioc->remove_host = 1;\r\nreturn 1;\r\n}\r\nprintk(MPT2SAS_INFO_FMT "port enable: SUCCESS\n", ioc->name);\r\nioc->base_cmds.status = MPT2_CMD_NOT_USED;\r\nif (ioc->wait_for_discovery_to_complete) {\r\nioc->wait_for_discovery_to_complete = 0;\r\n_scsih_probe_devices(ioc);\r\n}\r\nmpt2sas_base_start_watchdog(ioc);\r\nioc->is_driver_loading = 0;\r\nreturn 1;\r\n}\r\nstatic int\r\n_scsih_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstruct MPT2SAS_ADAPTER *ioc;\r\nstruct Scsi_Host *shost;\r\nint rv;\r\nshost = scsi_host_alloc(&scsih_driver_template,\r\nsizeof(struct MPT2SAS_ADAPTER));\r\nif (!shost)\r\nreturn -ENODEV;\r\nioc = shost_priv(shost);\r\nmemset(ioc, 0, sizeof(struct MPT2SAS_ADAPTER));\r\nINIT_LIST_HEAD(&ioc->list);\r\nlist_add_tail(&ioc->list, &mpt2sas_ioc_list);\r\nioc->shost = shost;\r\nioc->id = mpt_ids++;\r\nsprintf(ioc->name, "%s%d", MPT2SAS_DRIVER_NAME, ioc->id);\r\nioc->pdev = pdev;\r\nif (id->device == MPI2_MFGPAGE_DEVID_SSS6200) {\r\nioc->is_warpdrive = 1;\r\nioc->hide_ir_msg = 1;\r\n} else\r\nioc->mfg_pg10_hide_flag = MFG_PAGE10_EXPOSE_ALL_DISKS;\r\nioc->scsi_io_cb_idx = scsi_io_cb_idx;\r\nioc->tm_cb_idx = tm_cb_idx;\r\nioc->ctl_cb_idx = ctl_cb_idx;\r\nioc->base_cb_idx = base_cb_idx;\r\nioc->port_enable_cb_idx = port_enable_cb_idx;\r\nioc->transport_cb_idx = transport_cb_idx;\r\nioc->scsih_cb_idx = scsih_cb_idx;\r\nioc->config_cb_idx = config_cb_idx;\r\nioc->tm_tr_cb_idx = tm_tr_cb_idx;\r\nioc->tm_tr_volume_cb_idx = tm_tr_volume_cb_idx;\r\nioc->tm_sas_control_cb_idx = tm_sas_control_cb_idx;\r\nioc->logging_level = logging_level;\r\nioc->schedule_dead_ioc_flush_running_cmds = &_scsih_flush_running_cmds;\r\nmutex_init(&ioc->reset_in_progress_mutex);\r\nspin_lock_init(&ioc->ioc_reset_in_progress_lock);\r\nspin_lock_init(&ioc->scsi_lookup_lock);\r\nspin_lock_init(&ioc->sas_device_lock);\r\nspin_lock_init(&ioc->sas_node_lock);\r\nspin_lock_init(&ioc->fw_event_lock);\r\nspin_lock_init(&ioc->raid_device_lock);\r\nINIT_LIST_HEAD(&ioc->sas_device_list);\r\nINIT_LIST_HEAD(&ioc->sas_device_init_list);\r\nINIT_LIST_HEAD(&ioc->sas_expander_list);\r\nINIT_LIST_HEAD(&ioc->fw_event_list);\r\nINIT_LIST_HEAD(&ioc->raid_device_list);\r\nINIT_LIST_HEAD(&ioc->sas_hba.sas_port_list);\r\nINIT_LIST_HEAD(&ioc->delayed_tr_list);\r\nINIT_LIST_HEAD(&ioc->delayed_tr_volume_list);\r\nINIT_LIST_HEAD(&ioc->reply_queue_list);\r\nshost->max_cmd_len = 32;\r\nshost->max_lun = max_lun;\r\nshost->transportt = mpt2sas_transport_template;\r\nshost->unique_id = ioc->id;\r\nif (max_sectors != 0xFFFF) {\r\nif (max_sectors < 64) {\r\nshost->max_sectors = 64;\r\nprintk(MPT2SAS_WARN_FMT "Invalid value %d passed "\r\n"for max_sectors, range is 64 to 32767. Assigning "\r\n"value of 64.\n", ioc->name, max_sectors);\r\n} else if (max_sectors > 32767) {\r\nshost->max_sectors = 32767;\r\nprintk(MPT2SAS_WARN_FMT "Invalid value %d passed "\r\n"for max_sectors, range is 64 to 8192. Assigning "\r\n"default value of 32767.\n", ioc->name,\r\nmax_sectors);\r\n} else {\r\nshost->max_sectors = max_sectors & 0xFFFE;\r\nprintk(MPT2SAS_INFO_FMT "The max_sectors value is "\r\n"set to %d\n", ioc->name, shost->max_sectors);\r\n}\r\n}\r\nif (prot_mask)\r\nscsi_host_set_prot(shost, prot_mask);\r\nelse\r\nscsi_host_set_prot(shost, SHOST_DIF_TYPE1_PROTECTION\r\n| SHOST_DIF_TYPE2_PROTECTION\r\n| SHOST_DIF_TYPE3_PROTECTION);\r\nscsi_host_set_guard(shost, SHOST_DIX_GUARD_CRC);\r\nsnprintf(ioc->firmware_event_name, sizeof(ioc->firmware_event_name),\r\n"fw_event%d", ioc->id);\r\nioc->firmware_event_thread = create_singlethread_workqueue(\r\nioc->firmware_event_name);\r\nif (!ioc->firmware_event_thread) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nrv = -ENODEV;\r\ngoto out_thread_fail;\r\n}\r\nioc->is_driver_loading = 1;\r\nif ((mpt2sas_base_attach(ioc))) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nrv = -ENODEV;\r\ngoto out_attach_fail;\r\n}\r\nif (ioc->is_warpdrive) {\r\nif (ioc->mfg_pg10_hide_flag == MFG_PAGE10_EXPOSE_ALL_DISKS)\r\nioc->hide_drives = 0;\r\nelse if (ioc->mfg_pg10_hide_flag == MFG_PAGE10_HIDE_ALL_DISKS)\r\nioc->hide_drives = 1;\r\nelse {\r\nif (_scsih_get_num_volumes(ioc))\r\nioc->hide_drives = 1;\r\nelse\r\nioc->hide_drives = 0;\r\n}\r\n} else\r\nioc->hide_drives = 0;\r\nrv = scsi_add_host(shost, &pdev->dev);\r\nif (rv) {\r\nprintk(MPT2SAS_ERR_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\ngoto out_add_shost_fail;\r\n}\r\nscsi_scan_host(shost);\r\nreturn 0;\r\nout_add_shost_fail:\r\nmpt2sas_base_detach(ioc);\r\nout_attach_fail:\r\ndestroy_workqueue(ioc->firmware_event_thread);\r\nout_thread_fail:\r\nlist_del(&ioc->list);\r\nscsi_host_put(shost);\r\nreturn rv;\r\n}\r\nstatic int\r\n_scsih_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\npci_power_t device_state;\r\nmpt2sas_base_stop_watchdog(ioc);\r\nscsi_block_requests(shost);\r\n_scsih_ir_shutdown(ioc);\r\ndevice_state = pci_choose_state(pdev, state);\r\nprintk(MPT2SAS_INFO_FMT "pdev=0x%p, slot=%s, entering "\r\n"operating state [D%d]\n", ioc->name, pdev,\r\npci_name(pdev), device_state);\r\nmpt2sas_base_free_resources(ioc);\r\npci_save_state(pdev);\r\npci_set_power_state(pdev, device_state);\r\nreturn 0;\r\n}\r\nstatic int\r\n_scsih_resume(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\npci_power_t device_state = pdev->current_state;\r\nint r;\r\nprintk(MPT2SAS_INFO_FMT "pdev=0x%p, slot=%s, previous "\r\n"operating state [D%d]\n", ioc->name, pdev,\r\npci_name(pdev), device_state);\r\npci_set_power_state(pdev, PCI_D0);\r\npci_enable_wake(pdev, PCI_D0, 0);\r\npci_restore_state(pdev);\r\nioc->pdev = pdev;\r\nr = mpt2sas_base_map_resources(ioc);\r\nif (r)\r\nreturn r;\r\nmpt2sas_base_hard_reset_handler(ioc, CAN_SLEEP, SOFT_RESET);\r\nscsi_unblock_requests(shost);\r\nmpt2sas_base_start_watchdog(ioc);\r\nreturn 0;\r\n}\r\nstatic pci_ers_result_t\r\n_scsih_pci_error_detected(struct pci_dev *pdev, pci_channel_state_t state)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nprintk(MPT2SAS_INFO_FMT "PCI error: detected callback, state(%d)!!\n",\r\nioc->name, state);\r\nswitch (state) {\r\ncase pci_channel_io_normal:\r\nreturn PCI_ERS_RESULT_CAN_RECOVER;\r\ncase pci_channel_io_frozen:\r\nioc->pci_error_recovery = 1;\r\nscsi_block_requests(ioc->shost);\r\nmpt2sas_base_stop_watchdog(ioc);\r\nmpt2sas_base_free_resources(ioc);\r\nreturn PCI_ERS_RESULT_NEED_RESET;\r\ncase pci_channel_io_perm_failure:\r\nioc->pci_error_recovery = 1;\r\nmpt2sas_base_stop_watchdog(ioc);\r\n_scsih_flush_running_cmds(ioc);\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\n}\r\nreturn PCI_ERS_RESULT_NEED_RESET;\r\n}\r\nstatic pci_ers_result_t\r\n_scsih_pci_slot_reset(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nint rc;\r\nprintk(MPT2SAS_INFO_FMT "PCI error: slot reset callback!!\n",\r\nioc->name);\r\nioc->pci_error_recovery = 0;\r\nioc->pdev = pdev;\r\npci_restore_state(pdev);\r\nrc = mpt2sas_base_map_resources(ioc);\r\nif (rc)\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\nrc = mpt2sas_base_hard_reset_handler(ioc, CAN_SLEEP,\r\nFORCE_BIG_HAMMER);\r\nprintk(MPT2SAS_WARN_FMT "hard reset: %s\n", ioc->name,\r\n(rc == 0) ? "success" : "failed");\r\nif (!rc)\r\nreturn PCI_ERS_RESULT_RECOVERED;\r\nelse\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\n}\r\nstatic void\r\n_scsih_pci_resume(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nprintk(MPT2SAS_INFO_FMT "PCI error: resume callback!!\n", ioc->name);\r\npci_cleanup_aer_uncorrect_error_status(pdev);\r\nmpt2sas_base_start_watchdog(ioc);\r\nscsi_unblock_requests(ioc->shost);\r\n}\r\nstatic pci_ers_result_t\r\n_scsih_pci_mmio_enabled(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nprintk(MPT2SAS_INFO_FMT "PCI error: mmio enabled callback!!\n",\r\nioc->name);\r\nreturn PCI_ERS_RESULT_NEED_RESET;\r\n}\r\nstatic int __init\r\n_scsih_init(void)\r\n{\r\nint error;\r\nmpt_ids = 0;\r\nprintk(KERN_INFO "%s version %s loaded\n", MPT2SAS_DRIVER_NAME,\r\nMPT2SAS_DRIVER_VERSION);\r\nmpt2sas_transport_template =\r\nsas_attach_transport(&mpt2sas_transport_functions);\r\nif (!mpt2sas_transport_template)\r\nreturn -ENODEV;\r\nmpt2sas_raid_template = raid_class_attach(&mpt2sas_raid_functions);\r\nif (!mpt2sas_raid_template) {\r\nsas_release_transport(mpt2sas_transport_template);\r\nreturn -ENODEV;\r\n}\r\nmpt2sas_base_initialize_callback_handler();\r\nscsi_io_cb_idx = mpt2sas_base_register_callback_handler(_scsih_io_done);\r\ntm_cb_idx = mpt2sas_base_register_callback_handler(_scsih_tm_done);\r\nbase_cb_idx = mpt2sas_base_register_callback_handler(mpt2sas_base_done);\r\nport_enable_cb_idx = mpt2sas_base_register_callback_handler(\r\nmpt2sas_port_enable_done);\r\ntransport_cb_idx = mpt2sas_base_register_callback_handler(\r\nmpt2sas_transport_done);\r\nscsih_cb_idx = mpt2sas_base_register_callback_handler(_scsih_done);\r\nconfig_cb_idx = mpt2sas_base_register_callback_handler(\r\nmpt2sas_config_done);\r\nctl_cb_idx = mpt2sas_base_register_callback_handler(mpt2sas_ctl_done);\r\ntm_tr_cb_idx = mpt2sas_base_register_callback_handler(\r\n_scsih_tm_tr_complete);\r\ntm_tr_volume_cb_idx = mpt2sas_base_register_callback_handler(\r\n_scsih_tm_volume_tr_complete);\r\ntm_sas_control_cb_idx = mpt2sas_base_register_callback_handler(\r\n_scsih_sas_control_complete);\r\nmpt2sas_ctl_init();\r\nerror = pci_register_driver(&scsih_driver);\r\nif (error) {\r\nraid_class_release(mpt2sas_raid_template);\r\nsas_release_transport(mpt2sas_transport_template);\r\n}\r\nreturn error;\r\n}\r\nstatic void __exit\r\n_scsih_exit(void)\r\n{\r\nprintk(KERN_INFO "mpt2sas version %s unloading\n",\r\nMPT2SAS_DRIVER_VERSION);\r\npci_unregister_driver(&scsih_driver);\r\nmpt2sas_ctl_exit();\r\nmpt2sas_base_release_callback_handler(scsi_io_cb_idx);\r\nmpt2sas_base_release_callback_handler(tm_cb_idx);\r\nmpt2sas_base_release_callback_handler(base_cb_idx);\r\nmpt2sas_base_release_callback_handler(port_enable_cb_idx);\r\nmpt2sas_base_release_callback_handler(transport_cb_idx);\r\nmpt2sas_base_release_callback_handler(scsih_cb_idx);\r\nmpt2sas_base_release_callback_handler(config_cb_idx);\r\nmpt2sas_base_release_callback_handler(ctl_cb_idx);\r\nmpt2sas_base_release_callback_handler(tm_tr_cb_idx);\r\nmpt2sas_base_release_callback_handler(tm_tr_volume_cb_idx);\r\nmpt2sas_base_release_callback_handler(tm_sas_control_cb_idx);\r\nraid_class_release(mpt2sas_raid_template);\r\nsas_release_transport(mpt2sas_transport_template);\r\n}
