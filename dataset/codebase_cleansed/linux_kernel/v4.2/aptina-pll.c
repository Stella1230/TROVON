int aptina_pll_calculate(struct device *dev,\r\nconst struct aptina_pll_limits *limits,\r\nstruct aptina_pll *pll)\r\n{\r\nunsigned int mf_min;\r\nunsigned int mf_max;\r\nunsigned int p1_min;\r\nunsigned int p1_max;\r\nunsigned int p1;\r\nunsigned int div;\r\ndev_dbg(dev, "PLL: ext clock %u pix clock %u\n",\r\npll->ext_clock, pll->pix_clock);\r\nif (pll->ext_clock < limits->ext_clock_min ||\r\npll->ext_clock > limits->ext_clock_max) {\r\ndev_err(dev, "pll: invalid external clock frequency.\n");\r\nreturn -EINVAL;\r\n}\r\nif (pll->pix_clock == 0 || pll->pix_clock > limits->pix_clock_max) {\r\ndev_err(dev, "pll: invalid pixel clock frequency.\n");\r\nreturn -EINVAL;\r\n}\r\ndiv = gcd(pll->pix_clock, pll->ext_clock);\r\npll->m = pll->pix_clock / div;\r\ndiv = pll->ext_clock / div;\r\nmf_min = DIV_ROUND_UP(limits->m_min, pll->m);\r\nmf_min = max(mf_min, limits->out_clock_min /\r\n(pll->ext_clock / limits->n_min * pll->m));\r\nmf_min = max(mf_min, limits->n_min * limits->p1_min / div);\r\nmf_max = limits->m_max / pll->m;\r\nmf_max = min(mf_max, limits->out_clock_max /\r\n(pll->ext_clock / limits->n_max * pll->m));\r\nmf_max = min(mf_max, DIV_ROUND_UP(limits->n_max * limits->p1_max, div));\r\ndev_dbg(dev, "pll: mf min %u max %u\n", mf_min, mf_max);\r\nif (mf_min > mf_max) {\r\ndev_err(dev, "pll: no valid combined N*P1 divisor.\n");\r\nreturn -EINVAL;\r\n}\r\nif (limits->p1_min == 0) {\r\ndev_err(dev, "pll: P1 minimum value must be >0.\n");\r\nreturn -EINVAL;\r\n}\r\np1_min = max(limits->p1_min, DIV_ROUND_UP(limits->out_clock_min * div,\r\npll->ext_clock * pll->m));\r\np1_max = min(limits->p1_max, limits->out_clock_max * div /\r\n(pll->ext_clock * pll->m));\r\nfor (p1 = p1_max & ~1; p1 >= p1_min; p1 -= 2) {\r\nunsigned int mf_inc = p1 / gcd(div, p1);\r\nunsigned int mf_high;\r\nunsigned int mf_low;\r\nmf_low = roundup(max(mf_min, DIV_ROUND_UP(pll->ext_clock * p1,\r\nlimits->int_clock_max * div)), mf_inc);\r\nmf_high = min(mf_max, pll->ext_clock * p1 /\r\n(limits->int_clock_min * div));\r\nif (mf_low > mf_high)\r\ncontinue;\r\npll->n = div * mf_low / p1;\r\npll->m *= mf_low;\r\npll->p1 = p1;\r\ndev_dbg(dev, "PLL: N %u M %u P1 %u\n", pll->n, pll->m, pll->p1);\r\nreturn 0;\r\n}\r\ndev_err(dev, "pll: no valid N and P1 divisors found.\n");\r\nreturn -EINVAL;\r\n}
