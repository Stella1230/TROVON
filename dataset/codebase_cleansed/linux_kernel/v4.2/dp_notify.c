static void dp_detach_port_notify(struct vport *vport)\r\n{\r\nstruct sk_buff *notify;\r\nstruct datapath *dp;\r\ndp = vport->dp;\r\nnotify = ovs_vport_cmd_build_info(vport, 0, 0,\r\nOVS_VPORT_CMD_DEL);\r\novs_dp_detach_port(vport);\r\nif (IS_ERR(notify)) {\r\ngenl_set_err(&dp_vport_genl_family, ovs_dp_get_net(dp), 0,\r\n0, PTR_ERR(notify));\r\nreturn;\r\n}\r\ngenlmsg_multicast_netns(&dp_vport_genl_family,\r\novs_dp_get_net(dp), notify, 0,\r\n0, GFP_KERNEL);\r\n}\r\nvoid ovs_dp_notify_wq(struct work_struct *work)\r\n{\r\nstruct ovs_net *ovs_net = container_of(work, struct ovs_net, dp_notify_work);\r\nstruct datapath *dp;\r\novs_lock();\r\nlist_for_each_entry(dp, &ovs_net->dps, list_node) {\r\nint i;\r\nfor (i = 0; i < DP_VPORT_HASH_BUCKETS; i++) {\r\nstruct vport *vport;\r\nstruct hlist_node *n;\r\nhlist_for_each_entry_safe(vport, n, &dp->ports[i], dp_hash_node) {\r\nstruct netdev_vport *netdev_vport;\r\nif (vport->ops->type != OVS_VPORT_TYPE_NETDEV)\r\ncontinue;\r\nnetdev_vport = netdev_vport_priv(vport);\r\nif (!(netdev_vport->dev->priv_flags & IFF_OVS_DATAPATH))\r\ndp_detach_port_notify(vport);\r\n}\r\n}\r\n}\r\novs_unlock();\r\n}\r\nstatic int dp_device_event(struct notifier_block *unused, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct ovs_net *ovs_net;\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct vport *vport = NULL;\r\nif (!ovs_is_internal_dev(dev))\r\nvport = ovs_netdev_get_vport(dev);\r\nif (!vport)\r\nreturn NOTIFY_DONE;\r\nif (event == NETDEV_UNREGISTER) {\r\novs_netdev_detach_dev(vport);\r\novs_net = net_generic(dev_net(dev), ovs_net_id);\r\nqueue_work(system_wq, &ovs_net->dp_notify_work);\r\n}\r\nreturn NOTIFY_DONE;\r\n}
