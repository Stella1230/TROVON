static void zero_autoresume(unsigned long _c)\r\n{\r\nstruct usb_composite_dev *cdev = (void *)_c;\r\nstruct usb_gadget *g = cdev->gadget;\r\nif (!cdev->config)\r\nreturn;\r\nif (g->speed != USB_SPEED_UNKNOWN) {\r\nint status = usb_gadget_wakeup(g);\r\nINFO(cdev, "%s --> %d\n", __func__, status);\r\n}\r\n}\r\nstatic void zero_suspend(struct usb_composite_dev *cdev)\r\n{\r\nif (cdev->gadget->speed == USB_SPEED_UNKNOWN)\r\nreturn;\r\nif (autoresume) {\r\nif (max_autoresume &&\r\n(autoresume_step_ms > max_autoresume * 1000))\r\nautoresume_step_ms = autoresume * 1000;\r\nmod_timer(&autoresume_timer, jiffies +\r\nmsecs_to_jiffies(autoresume_step_ms));\r\nDBG(cdev, "suspend, wakeup in %d milliseconds\n",\r\nautoresume_step_ms);\r\nautoresume_step_ms += autoresume_interval_ms;\r\n} else\r\nDBG(cdev, "%s\n", __func__);\r\n}\r\nstatic void zero_resume(struct usb_composite_dev *cdev)\r\n{\r\nDBG(cdev, "%s\n", __func__);\r\ndel_timer(&autoresume_timer);\r\n}\r\nstatic int ss_config_setup(struct usb_configuration *c,\r\nconst struct usb_ctrlrequest *ctrl)\r\n{\r\nswitch (ctrl->bRequest) {\r\ncase 0x5b:\r\ncase 0x5c:\r\nreturn func_ss->setup(func_ss, ctrl);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int zero_bind(struct usb_composite_dev *cdev)\r\n{\r\nstruct f_ss_opts *ss_opts;\r\nstruct f_lb_opts *lb_opts;\r\nint status;\r\nstatus = usb_string_ids_tab(cdev, strings_dev);\r\nif (status < 0)\r\nreturn status;\r\ndevice_desc.iManufacturer = strings_dev[USB_GADGET_MANUFACTURER_IDX].id;\r\ndevice_desc.iProduct = strings_dev[USB_GADGET_PRODUCT_IDX].id;\r\ndevice_desc.iSerialNumber = strings_dev[USB_GADGET_SERIAL_IDX].id;\r\nsetup_timer(&autoresume_timer, zero_autoresume, (unsigned long) cdev);\r\nfunc_inst_ss = usb_get_function_instance("SourceSink");\r\nif (IS_ERR(func_inst_ss))\r\nreturn PTR_ERR(func_inst_ss);\r\nss_opts = container_of(func_inst_ss, struct f_ss_opts, func_inst);\r\nss_opts->pattern = gzero_options.pattern;\r\nss_opts->isoc_interval = gzero_options.isoc_interval;\r\nss_opts->isoc_maxpacket = gzero_options.isoc_maxpacket;\r\nss_opts->isoc_mult = gzero_options.isoc_mult;\r\nss_opts->isoc_maxburst = gzero_options.isoc_maxburst;\r\nss_opts->bulk_buflen = gzero_options.bulk_buflen;\r\nfunc_ss = usb_get_function(func_inst_ss);\r\nif (IS_ERR(func_ss)) {\r\nstatus = PTR_ERR(func_ss);\r\ngoto err_put_func_inst_ss;\r\n}\r\nfunc_inst_lb = usb_get_function_instance("Loopback");\r\nif (IS_ERR(func_inst_lb)) {\r\nstatus = PTR_ERR(func_inst_lb);\r\ngoto err_put_func_ss;\r\n}\r\nlb_opts = container_of(func_inst_lb, struct f_lb_opts, func_inst);\r\nlb_opts->bulk_buflen = gzero_options.bulk_buflen;\r\nlb_opts->qlen = gzero_options.qlen;\r\nfunc_lb = usb_get_function(func_inst_lb);\r\nif (IS_ERR(func_lb)) {\r\nstatus = PTR_ERR(func_lb);\r\ngoto err_put_func_inst_lb;\r\n}\r\nsourcesink_driver.iConfiguration = strings_dev[USB_GZERO_SS_DESC].id;\r\nloopback_driver.iConfiguration = strings_dev[USB_GZERO_LB_DESC].id;\r\nsourcesink_driver.bmAttributes &= ~USB_CONFIG_ATT_WAKEUP;\r\nloopback_driver.bmAttributes &= ~USB_CONFIG_ATT_WAKEUP;\r\nsourcesink_driver.descriptors = NULL;\r\nloopback_driver.descriptors = NULL;\r\nif (autoresume) {\r\nsourcesink_driver.bmAttributes |= USB_CONFIG_ATT_WAKEUP;\r\nloopback_driver.bmAttributes |= USB_CONFIG_ATT_WAKEUP;\r\nautoresume_step_ms = autoresume * 1000;\r\n}\r\nif (gadget_is_otg(cdev->gadget)) {\r\nsourcesink_driver.descriptors = otg_desc;\r\nsourcesink_driver.bmAttributes |= USB_CONFIG_ATT_WAKEUP;\r\nloopback_driver.descriptors = otg_desc;\r\nloopback_driver.bmAttributes |= USB_CONFIG_ATT_WAKEUP;\r\n}\r\nif (loopdefault) {\r\nusb_add_config_only(cdev, &loopback_driver);\r\nusb_add_config_only(cdev, &sourcesink_driver);\r\n} else {\r\nusb_add_config_only(cdev, &sourcesink_driver);\r\nusb_add_config_only(cdev, &loopback_driver);\r\n}\r\nstatus = usb_add_function(&sourcesink_driver, func_ss);\r\nif (status)\r\ngoto err_conf_flb;\r\nusb_ep_autoconfig_reset(cdev->gadget);\r\nstatus = usb_add_function(&loopback_driver, func_lb);\r\nif (status)\r\ngoto err_conf_flb;\r\nusb_ep_autoconfig_reset(cdev->gadget);\r\nusb_composite_overwrite_options(cdev, &coverwrite);\r\nINFO(cdev, "%s, version: " DRIVER_VERSION "\n", longname);\r\nreturn 0;\r\nerr_conf_flb:\r\nusb_put_function(func_lb);\r\nfunc_lb = NULL;\r\nerr_put_func_inst_lb:\r\nusb_put_function_instance(func_inst_lb);\r\nfunc_inst_lb = NULL;\r\nerr_put_func_ss:\r\nusb_put_function(func_ss);\r\nfunc_ss = NULL;\r\nerr_put_func_inst_ss:\r\nusb_put_function_instance(func_inst_ss);\r\nfunc_inst_ss = NULL;\r\nreturn status;\r\n}\r\nstatic int zero_unbind(struct usb_composite_dev *cdev)\r\n{\r\ndel_timer_sync(&autoresume_timer);\r\nif (!IS_ERR_OR_NULL(func_ss))\r\nusb_put_function(func_ss);\r\nusb_put_function_instance(func_inst_ss);\r\nif (!IS_ERR_OR_NULL(func_lb))\r\nusb_put_function(func_lb);\r\nusb_put_function_instance(func_inst_lb);\r\nreturn 0;\r\n}
