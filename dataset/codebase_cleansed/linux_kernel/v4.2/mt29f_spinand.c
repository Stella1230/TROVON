static inline struct spinand_state *mtd_to_state(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = (struct nand_chip *)mtd->priv;\r\nstruct spinand_info *info = (struct spinand_info *)chip->priv;\r\nstruct spinand_state *state = (struct spinand_state *)info->priv;\r\nreturn state;\r\n}\r\nstatic int spinand_cmd(struct spi_device *spi, struct spinand_cmd *cmd)\r\n{\r\nstruct spi_message message;\r\nstruct spi_transfer x[4];\r\nu8 dummy = 0xff;\r\nspi_message_init(&message);\r\nmemset(x, 0, sizeof(x));\r\nx[0].len = 1;\r\nx[0].tx_buf = &cmd->cmd;\r\nspi_message_add_tail(&x[0], &message);\r\nif (cmd->n_addr) {\r\nx[1].len = cmd->n_addr;\r\nx[1].tx_buf = cmd->addr;\r\nspi_message_add_tail(&x[1], &message);\r\n}\r\nif (cmd->n_dummy) {\r\nx[2].len = cmd->n_dummy;\r\nx[2].tx_buf = &dummy;\r\nspi_message_add_tail(&x[2], &message);\r\n}\r\nif (cmd->n_tx) {\r\nx[3].len = cmd->n_tx;\r\nx[3].tx_buf = cmd->tx_buf;\r\nspi_message_add_tail(&x[3], &message);\r\n}\r\nif (cmd->n_rx) {\r\nx[3].len = cmd->n_rx;\r\nx[3].rx_buf = cmd->rx_buf;\r\nspi_message_add_tail(&x[3], &message);\r\n}\r\nreturn spi_sync(spi, &message);\r\n}\r\nstatic int spinand_read_id(struct spi_device *spi_nand, u8 *id)\r\n{\r\nint retval;\r\nu8 nand_id[3];\r\nstruct spinand_cmd cmd = {0};\r\ncmd.cmd = CMD_READ_ID;\r\ncmd.n_rx = 3;\r\ncmd.rx_buf = &nand_id[0];\r\nretval = spinand_cmd(spi_nand, &cmd);\r\nif (retval < 0) {\r\ndev_err(&spi_nand->dev, "error %d reading id\n", retval);\r\nreturn retval;\r\n}\r\nid[0] = nand_id[1];\r\nid[1] = nand_id[2];\r\nreturn retval;\r\n}\r\nstatic int spinand_read_status(struct spi_device *spi_nand, uint8_t *status)\r\n{\r\nstruct spinand_cmd cmd = {0};\r\nint ret;\r\ncmd.cmd = CMD_READ_REG;\r\ncmd.n_addr = 1;\r\ncmd.addr[0] = REG_STATUS;\r\ncmd.n_rx = 1;\r\ncmd.rx_buf = status;\r\nret = spinand_cmd(spi_nand, &cmd);\r\nif (ret < 0)\r\ndev_err(&spi_nand->dev, "err: %d read status register\n", ret);\r\nreturn ret;\r\n}\r\nstatic int wait_till_ready(struct spi_device *spi_nand)\r\n{\r\nunsigned long deadline;\r\nint retval;\r\nu8 stat = 0;\r\ndeadline = jiffies + MAX_WAIT_JIFFIES;\r\ndo {\r\nretval = spinand_read_status(spi_nand, &stat);\r\nif (retval < 0)\r\nreturn -1;\r\nelse if (!(stat & 0x1))\r\nbreak;\r\ncond_resched();\r\n} while (!time_after_eq(jiffies, deadline));\r\nif ((stat & 0x1) == 0)\r\nreturn 0;\r\nreturn -1;\r\n}\r\nstatic int spinand_get_otp(struct spi_device *spi_nand, u8 *otp)\r\n{\r\nstruct spinand_cmd cmd = {0};\r\nint retval;\r\ncmd.cmd = CMD_READ_REG;\r\ncmd.n_addr = 1;\r\ncmd.addr[0] = REG_OTP;\r\ncmd.n_rx = 1;\r\ncmd.rx_buf = otp;\r\nretval = spinand_cmd(spi_nand, &cmd);\r\nif (retval < 0)\r\ndev_err(&spi_nand->dev, "error %d get otp\n", retval);\r\nreturn retval;\r\n}\r\nstatic int spinand_set_otp(struct spi_device *spi_nand, u8 *otp)\r\n{\r\nint retval;\r\nstruct spinand_cmd cmd = {0};\r\ncmd.cmd = CMD_WRITE_REG,\r\ncmd.n_addr = 1,\r\ncmd.addr[0] = REG_OTP,\r\ncmd.n_tx = 1,\r\ncmd.tx_buf = otp,\r\nretval = spinand_cmd(spi_nand, &cmd);\r\nif (retval < 0)\r\ndev_err(&spi_nand->dev, "error %d set otp\n", retval);\r\nreturn retval;\r\n}\r\nstatic int spinand_enable_ecc(struct spi_device *spi_nand)\r\n{\r\nint retval;\r\nu8 otp = 0;\r\nretval = spinand_get_otp(spi_nand, &otp);\r\nif (retval < 0)\r\nreturn retval;\r\nif ((otp & OTP_ECC_MASK) == OTP_ECC_MASK)\r\nreturn 0;\r\notp |= OTP_ECC_MASK;\r\nretval = spinand_set_otp(spi_nand, &otp);\r\nif (retval < 0)\r\nreturn retval;\r\nreturn spinand_get_otp(spi_nand, &otp);\r\n}\r\nstatic int spinand_disable_ecc(struct spi_device *spi_nand)\r\n{\r\nint retval;\r\nu8 otp = 0;\r\nretval = spinand_get_otp(spi_nand, &otp);\r\nif (retval < 0)\r\nreturn retval;\r\nif ((otp & OTP_ECC_MASK) == OTP_ECC_MASK) {\r\notp &= ~OTP_ECC_MASK;\r\nretval = spinand_set_otp(spi_nand, &otp);\r\nif (retval < 0)\r\nreturn retval;\r\nreturn spinand_get_otp(spi_nand, &otp);\r\n}\r\nreturn 0;\r\n}\r\nstatic int spinand_write_enable(struct spi_device *spi_nand)\r\n{\r\nstruct spinand_cmd cmd = {0};\r\ncmd.cmd = CMD_WR_ENABLE;\r\nreturn spinand_cmd(spi_nand, &cmd);\r\n}\r\nstatic int spinand_read_page_to_cache(struct spi_device *spi_nand, u16 page_id)\r\n{\r\nstruct spinand_cmd cmd = {0};\r\nu16 row;\r\nrow = page_id;\r\ncmd.cmd = CMD_READ;\r\ncmd.n_addr = 3;\r\ncmd.addr[1] = (u8)((row & 0xff00) >> 8);\r\ncmd.addr[2] = (u8)(row & 0x00ff);\r\nreturn spinand_cmd(spi_nand, &cmd);\r\n}\r\nstatic int spinand_read_from_cache(struct spi_device *spi_nand, u16 page_id,\r\nu16 byte_id, u16 len, u8 *rbuf)\r\n{\r\nstruct spinand_cmd cmd = {0};\r\nu16 column;\r\ncolumn = byte_id;\r\ncmd.cmd = CMD_READ_RDM;\r\ncmd.n_addr = 3;\r\ncmd.addr[0] = (u8)((column & 0xff00) >> 8);\r\ncmd.addr[0] |= (u8)(((page_id >> 6) & 0x1) << 4);\r\ncmd.addr[1] = (u8)(column & 0x00ff);\r\ncmd.addr[2] = (u8)(0xff);\r\ncmd.n_dummy = 0;\r\ncmd.n_rx = len;\r\ncmd.rx_buf = rbuf;\r\nreturn spinand_cmd(spi_nand, &cmd);\r\n}\r\nstatic int spinand_read_page(struct spi_device *spi_nand, u16 page_id,\r\nu16 offset, u16 len, u8 *rbuf)\r\n{\r\nint ret;\r\nu8 status = 0;\r\n#ifdef CONFIG_MTD_SPINAND_ONDIEECC\r\nif (enable_read_hw_ecc) {\r\nif (spinand_enable_ecc(spi_nand) < 0)\r\ndev_err(&spi_nand->dev, "enable HW ECC failed!");\r\n}\r\n#endif\r\nret = spinand_read_page_to_cache(spi_nand, page_id);\r\nif (ret < 0)\r\nreturn ret;\r\nif (wait_till_ready(spi_nand))\r\ndev_err(&spi_nand->dev, "WAIT timedout!!!\n");\r\nwhile (1) {\r\nret = spinand_read_status(spi_nand, &status);\r\nif (ret < 0) {\r\ndev_err(&spi_nand->dev,\r\n"err %d read status register\n", ret);\r\nreturn ret;\r\n}\r\nif ((status & STATUS_OIP_MASK) == STATUS_READY) {\r\nif ((status & STATUS_ECC_MASK) == STATUS_ECC_ERROR) {\r\ndev_err(&spi_nand->dev, "ecc error, page=%d\n",\r\npage_id);\r\nreturn 0;\r\n}\r\nbreak;\r\n}\r\n}\r\nret = spinand_read_from_cache(spi_nand, page_id, offset, len, rbuf);\r\nif (ret < 0) {\r\ndev_err(&spi_nand->dev, "read from cache failed!!\n");\r\nreturn ret;\r\n}\r\n#ifdef CONFIG_MTD_SPINAND_ONDIEECC\r\nif (enable_read_hw_ecc) {\r\nret = spinand_disable_ecc(spi_nand);\r\nif (ret < 0) {\r\ndev_err(&spi_nand->dev, "disable ecc failed!!\n");\r\nreturn ret;\r\n}\r\nenable_read_hw_ecc = 0;\r\n}\r\n#endif\r\nreturn ret;\r\n}\r\nstatic int spinand_program_data_to_cache(struct spi_device *spi_nand,\r\nu16 page_id, u16 byte_id, u16 len, u8 *wbuf)\r\n{\r\nstruct spinand_cmd cmd = {0};\r\nu16 column;\r\ncolumn = byte_id;\r\ncmd.cmd = CMD_PROG_PAGE_CLRCACHE;\r\ncmd.n_addr = 2;\r\ncmd.addr[0] = (u8)((column & 0xff00) >> 8);\r\ncmd.addr[0] |= (u8)(((page_id >> 6) & 0x1) << 4);\r\ncmd.addr[1] = (u8)(column & 0x00ff);\r\ncmd.n_tx = len;\r\ncmd.tx_buf = wbuf;\r\nreturn spinand_cmd(spi_nand, &cmd);\r\n}\r\nstatic int spinand_program_execute(struct spi_device *spi_nand, u16 page_id)\r\n{\r\nstruct spinand_cmd cmd = {0};\r\nu16 row;\r\nrow = page_id;\r\ncmd.cmd = CMD_PROG_PAGE_EXC;\r\ncmd.n_addr = 3;\r\ncmd.addr[1] = (u8)((row & 0xff00) >> 8);\r\ncmd.addr[2] = (u8)(row & 0x00ff);\r\nreturn spinand_cmd(spi_nand, &cmd);\r\n}\r\nstatic int spinand_program_page(struct spi_device *spi_nand,\r\nu16 page_id, u16 offset, u16 len, u8 *buf)\r\n{\r\nint retval;\r\nu8 status = 0;\r\nuint8_t *wbuf;\r\n#ifdef CONFIG_MTD_SPINAND_ONDIEECC\r\nunsigned int i, j;\r\nenable_read_hw_ecc = 0;\r\nwbuf = devm_kzalloc(&spi_nand->dev, CACHE_BUF, GFP_KERNEL);\r\nspinand_read_page(spi_nand, page_id, 0, CACHE_BUF, wbuf);\r\nfor (i = offset, j = 0; i < len; i++, j++)\r\nwbuf[i] &= buf[j];\r\nif (enable_hw_ecc) {\r\nretval = spinand_enable_ecc(spi_nand);\r\nif (retval < 0) {\r\ndev_err(&spi_nand->dev, "enable ecc failed!!\n");\r\nreturn retval;\r\n}\r\n}\r\n#else\r\nwbuf = buf;\r\n#endif\r\nretval = spinand_write_enable(spi_nand);\r\nif (retval < 0) {\r\ndev_err(&spi_nand->dev, "write enable failed!!\n");\r\nreturn retval;\r\n}\r\nif (wait_till_ready(spi_nand))\r\ndev_err(&spi_nand->dev, "wait timedout!!!\n");\r\nretval = spinand_program_data_to_cache(spi_nand, page_id,\r\noffset, len, wbuf);\r\nif (retval < 0)\r\nreturn retval;\r\nretval = spinand_program_execute(spi_nand, page_id);\r\nif (retval < 0)\r\nreturn retval;\r\nwhile (1) {\r\nretval = spinand_read_status(spi_nand, &status);\r\nif (retval < 0) {\r\ndev_err(&spi_nand->dev,\r\n"error %d reading status register\n",\r\nretval);\r\nreturn retval;\r\n}\r\nif ((status & STATUS_OIP_MASK) == STATUS_READY) {\r\nif ((status & STATUS_P_FAIL_MASK) == STATUS_P_FAIL) {\r\ndev_err(&spi_nand->dev,\r\n"program error, page %d\n", page_id);\r\nreturn -1;\r\n}\r\nbreak;\r\n}\r\n}\r\n#ifdef CONFIG_MTD_SPINAND_ONDIEECC\r\nif (enable_hw_ecc) {\r\nretval = spinand_disable_ecc(spi_nand);\r\nif (retval < 0) {\r\ndev_err(&spi_nand->dev, "disable ecc failed!!\n");\r\nreturn retval;\r\n}\r\nenable_hw_ecc = 0;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int spinand_erase_block_erase(struct spi_device *spi_nand, u16 block_id)\r\n{\r\nstruct spinand_cmd cmd = {0};\r\nu16 row;\r\nrow = block_id;\r\ncmd.cmd = CMD_ERASE_BLK;\r\ncmd.n_addr = 3;\r\ncmd.addr[1] = (u8)((row & 0xff00) >> 8);\r\ncmd.addr[2] = (u8)(row & 0x00ff);\r\nreturn spinand_cmd(spi_nand, &cmd);\r\n}\r\nstatic int spinand_erase_block(struct spi_device *spi_nand, u16 block_id)\r\n{\r\nint retval;\r\nu8 status = 0;\r\nretval = spinand_write_enable(spi_nand);\r\nif (wait_till_ready(spi_nand))\r\ndev_err(&spi_nand->dev, "wait timedout!!!\n");\r\nretval = spinand_erase_block_erase(spi_nand, block_id);\r\nwhile (1) {\r\nretval = spinand_read_status(spi_nand, &status);\r\nif (retval < 0) {\r\ndev_err(&spi_nand->dev,\r\n"error %d reading status register\n",\r\n(int) retval);\r\nreturn retval;\r\n}\r\nif ((status & STATUS_OIP_MASK) == STATUS_READY) {\r\nif ((status & STATUS_E_FAIL_MASK) == STATUS_E_FAIL) {\r\ndev_err(&spi_nand->dev,\r\n"erase error, block %d\n", block_id);\r\nreturn -1;\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int spinand_write_page_hwecc(struct mtd_info *mtd,\r\nstruct nand_chip *chip, const uint8_t *buf, int oob_required)\r\n{\r\nconst uint8_t *p = buf;\r\nint eccsize = chip->ecc.size;\r\nint eccsteps = chip->ecc.steps;\r\nenable_hw_ecc = 1;\r\nchip->write_buf(mtd, p, eccsize * eccsteps);\r\nreturn 0;\r\n}\r\nstatic int spinand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint8_t *buf, int oob_required, int page)\r\n{\r\nint retval;\r\nu8 status;\r\nuint8_t *p = buf;\r\nint eccsize = chip->ecc.size;\r\nint eccsteps = chip->ecc.steps;\r\nstruct spinand_info *info = (struct spinand_info *)chip->priv;\r\nenable_read_hw_ecc = 1;\r\nchip->read_buf(mtd, p, eccsize * eccsteps);\r\nif (oob_required)\r\nchip->read_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nwhile (1) {\r\nretval = spinand_read_status(info->spi, &status);\r\nif (retval < 0) {\r\ndev_err(&mtd->dev,\r\n"error %d reading status register\n",\r\nretval);\r\nreturn retval;\r\n}\r\nif ((status & STATUS_OIP_MASK) == STATUS_READY) {\r\nif ((status & STATUS_ECC_MASK) == STATUS_ECC_ERROR) {\r\npr_info("spinand: ECC error\n");\r\nmtd->ecc_stats.failed++;\r\n} else if ((status & STATUS_ECC_MASK) ==\r\nSTATUS_ECC_1BIT_CORRECTED)\r\nmtd->ecc_stats.corrected++;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void spinand_select_chip(struct mtd_info *mtd, int dev)\r\n{\r\n}\r\nstatic uint8_t spinand_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct spinand_state *state = mtd_to_state(mtd);\r\nu8 data;\r\ndata = state->buf[state->buf_ptr];\r\nstate->buf_ptr++;\r\nreturn data;\r\n}\r\nstatic int spinand_wait(struct mtd_info *mtd, struct nand_chip *chip)\r\n{\r\nstruct spinand_info *info = (struct spinand_info *)chip->priv;\r\nunsigned long timeo = jiffies;\r\nint retval, state = chip->state;\r\nu8 status;\r\nif (state == FL_ERASING)\r\ntimeo += (HZ * 400) / 1000;\r\nelse\r\ntimeo += (HZ * 20) / 1000;\r\nwhile (time_before(jiffies, timeo)) {\r\nretval = spinand_read_status(info->spi, &status);\r\nif (retval < 0) {\r\ndev_err(&mtd->dev,\r\n"error %d reading status register\n",\r\nretval);\r\nreturn retval;\r\n}\r\nif ((status & STATUS_OIP_MASK) == STATUS_READY)\r\nreturn 0;\r\ncond_resched();\r\n}\r\nreturn 0;\r\n}\r\nstatic void spinand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)\r\n{\r\nstruct spinand_state *state = mtd_to_state(mtd);\r\nmemcpy(state->buf + state->buf_ptr, buf, len);\r\nstate->buf_ptr += len;\r\n}\r\nstatic void spinand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)\r\n{\r\nstruct spinand_state *state = mtd_to_state(mtd);\r\nmemcpy(buf, state->buf + state->buf_ptr, len);\r\nstate->buf_ptr += len;\r\n}\r\nstatic void spinand_reset(struct spi_device *spi_nand)\r\n{\r\nstruct spinand_cmd cmd = {0};\r\ncmd.cmd = CMD_RESET;\r\nif (spinand_cmd(spi_nand, &cmd) < 0)\r\npr_info("spinand reset failed!\n");\r\nudelay(1000);\r\nif (wait_till_ready(spi_nand))\r\ndev_err(&spi_nand->dev, "wait timedout!\n");\r\n}\r\nstatic void spinand_cmdfunc(struct mtd_info *mtd, unsigned int command,\r\nint column, int page)\r\n{\r\nstruct nand_chip *chip = (struct nand_chip *)mtd->priv;\r\nstruct spinand_info *info = (struct spinand_info *)chip->priv;\r\nstruct spinand_state *state = (struct spinand_state *)info->priv;\r\nswitch (command) {\r\ncase NAND_CMD_READ1:\r\ncase NAND_CMD_READ0:\r\nstate->buf_ptr = 0;\r\nspinand_read_page(info->spi, page, 0x0, 0x840, state->buf);\r\nbreak;\r\ncase NAND_CMD_READOOB:\r\nstate->buf_ptr = 0;\r\nspinand_read_page(info->spi, page, 0x800, 0x40, state->buf);\r\nbreak;\r\ncase NAND_CMD_RNDOUT:\r\nstate->buf_ptr = column;\r\nbreak;\r\ncase NAND_CMD_READID:\r\nstate->buf_ptr = 0;\r\nspinand_read_id(info->spi, state->buf);\r\nbreak;\r\ncase NAND_CMD_PARAM:\r\nstate->buf_ptr = 0;\r\nbreak;\r\ncase NAND_CMD_ERASE1:\r\nspinand_erase_block(info->spi, page);\r\nbreak;\r\ncase NAND_CMD_ERASE2:\r\nbreak;\r\ncase NAND_CMD_SEQIN:\r\nstate->col = column;\r\nstate->row = page;\r\nstate->buf_ptr = 0;\r\nbreak;\r\ncase NAND_CMD_PAGEPROG:\r\nspinand_program_page(info->spi, state->row, state->col,\r\nstate->buf_ptr, state->buf);\r\nbreak;\r\ncase NAND_CMD_STATUS:\r\nspinand_get_otp(info->spi, state->buf);\r\nif (!(state->buf[0] & 0x80))\r\nstate->buf[0] = 0x80;\r\nstate->buf_ptr = 0;\r\nbreak;\r\ncase NAND_CMD_RESET:\r\nif (wait_till_ready(info->spi))\r\ndev_err(&info->spi->dev, "WAIT timedout!!!\n");\r\nudelay(250);\r\nspinand_reset(info->spi);\r\nbreak;\r\ndefault:\r\ndev_err(&mtd->dev, "Unknown CMD: 0x%x\n", command);\r\n}\r\n}\r\nstatic int spinand_lock_block(struct spi_device *spi_nand, u8 lock)\r\n{\r\nstruct spinand_cmd cmd = {0};\r\nint ret;\r\nu8 otp = 0;\r\nret = spinand_get_otp(spi_nand, &otp);\r\ncmd.cmd = CMD_WRITE_REG;\r\ncmd.n_addr = 1;\r\ncmd.addr[0] = REG_BLOCK_LOCK;\r\ncmd.n_tx = 1;\r\ncmd.tx_buf = &lock;\r\nret = spinand_cmd(spi_nand, &cmd);\r\nif (ret < 0)\r\ndev_err(&spi_nand->dev, "error %d lock block\n", ret);\r\nreturn ret;\r\n}\r\nstatic int spinand_probe(struct spi_device *spi_nand)\r\n{\r\nstruct mtd_info *mtd;\r\nstruct nand_chip *chip;\r\nstruct spinand_info *info;\r\nstruct spinand_state *state;\r\nstruct mtd_part_parser_data ppdata;\r\ninfo = devm_kzalloc(&spi_nand->dev, sizeof(struct spinand_info),\r\nGFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->spi = spi_nand;\r\nspinand_lock_block(spi_nand, BL_ALL_UNLOCKED);\r\nstate = devm_kzalloc(&spi_nand->dev, sizeof(struct spinand_state),\r\nGFP_KERNEL);\r\nif (!state)\r\nreturn -ENOMEM;\r\ninfo->priv = state;\r\nstate->buf_ptr = 0;\r\nstate->buf = devm_kzalloc(&spi_nand->dev, BUFSIZE, GFP_KERNEL);\r\nif (!state->buf)\r\nreturn -ENOMEM;\r\nchip = devm_kzalloc(&spi_nand->dev, sizeof(struct nand_chip),\r\nGFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\n#ifdef CONFIG_MTD_SPINAND_ONDIEECC\r\nchip->ecc.mode = NAND_ECC_HW;\r\nchip->ecc.size = 0x200;\r\nchip->ecc.bytes = 0x6;\r\nchip->ecc.steps = 0x4;\r\nchip->ecc.strength = 1;\r\nchip->ecc.total = chip->ecc.steps * chip->ecc.bytes;\r\nchip->ecc.layout = &spinand_oob_64;\r\nchip->ecc.read_page = spinand_read_page_hwecc;\r\nchip->ecc.write_page = spinand_write_page_hwecc;\r\n#else\r\nchip->ecc.mode = NAND_ECC_SOFT;\r\nif (spinand_disable_ecc(spi_nand) < 0)\r\npr_info("%s: disable ecc failed!\n", __func__);\r\n#endif\r\nchip->priv = info;\r\nchip->read_buf = spinand_read_buf;\r\nchip->write_buf = spinand_write_buf;\r\nchip->read_byte = spinand_read_byte;\r\nchip->cmdfunc = spinand_cmdfunc;\r\nchip->waitfunc = spinand_wait;\r\nchip->options |= NAND_CACHEPRG;\r\nchip->select_chip = spinand_select_chip;\r\nmtd = devm_kzalloc(&spi_nand->dev, sizeof(struct mtd_info), GFP_KERNEL);\r\nif (!mtd)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(&spi_nand->dev, mtd);\r\nmtd->priv = chip;\r\nmtd->name = dev_name(&spi_nand->dev);\r\nmtd->owner = THIS_MODULE;\r\nmtd->oobsize = 64;\r\nif (nand_scan(mtd, 1))\r\nreturn -ENXIO;\r\nppdata.of_node = spi_nand->dev.of_node;\r\nreturn mtd_device_parse_register(mtd, NULL, &ppdata, NULL, 0);\r\n}\r\nstatic int spinand_remove(struct spi_device *spi)\r\n{\r\nmtd_device_unregister(dev_get_drvdata(&spi->dev));\r\nreturn 0;\r\n}
