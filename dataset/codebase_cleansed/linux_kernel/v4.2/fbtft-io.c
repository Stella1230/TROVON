int fbtft_write_spi(struct fbtft_par *par, void *buf, size_t len)\r\n{\r\nstruct spi_transfer t = {\r\n.tx_buf = buf,\r\n.len = len,\r\n};\r\nstruct spi_message m;\r\nfbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,\r\n"%s(len=%d): ", __func__, len);\r\nif (!par->spi) {\r\ndev_err(par->info->device,\r\n"%s: par->spi is unexpectedly NULL\n", __func__);\r\nreturn -1;\r\n}\r\nspi_message_init(&m);\r\nif (par->txbuf.dma && buf == par->txbuf.buf) {\r\nt.tx_dma = par->txbuf.dma;\r\nm.is_dma_mapped = 1;\r\n}\r\nspi_message_add_tail(&t, &m);\r\nreturn spi_sync(par->spi, &m);\r\n}\r\nint fbtft_write_spi_emulate_9(struct fbtft_par *par, void *buf, size_t len)\r\n{\r\nu16 *src = buf;\r\nu8 *dst = par->extra;\r\nsize_t size = len / 2;\r\nsize_t added = 0;\r\nint bits, i, j;\r\nu64 val, dc, tmp;\r\nfbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,\r\n"%s(len=%d): ", __func__, len);\r\nif (!par->extra) {\r\ndev_err(par->info->device, "%s: error: par->extra is NULL\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif ((len % 8) != 0) {\r\ndev_err(par->info->device,\r\n"error: len=%zu must be divisible by 8\n", len);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < size; i += 8) {\r\ntmp = 0;\r\nbits = 63;\r\nfor (j = 0; j < 7; j++) {\r\ndc = (*src & 0x0100) ? 1 : 0;\r\nval = *src & 0x00FF;\r\ntmp |= dc << bits;\r\nbits -= 8;\r\ntmp |= val << bits--;\r\nsrc++;\r\n}\r\ntmp |= ((*src & 0x0100) ? 1 : 0);\r\n*(u64 *)dst = cpu_to_be64(tmp);\r\ndst += 8;\r\n*dst++ = (u8)(*src++ & 0x00FF);\r\nadded++;\r\n}\r\nreturn spi_write(par->spi, par->extra, size + added);\r\n}\r\nint fbtft_read_spi(struct fbtft_par *par, void *buf, size_t len)\r\n{\r\nint ret;\r\nu8 txbuf[32] = { 0, };\r\nstruct spi_transfer t = {\r\n.speed_hz = 2000000,\r\n.rx_buf = buf,\r\n.len = len,\r\n};\r\nstruct spi_message m;\r\nif (!par->spi) {\r\ndev_err(par->info->device,\r\n"%s: par->spi is unexpectedly NULL\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nif (par->startbyte) {\r\nif (len > 32) {\r\ndev_err(par->info->device,\r\n"len=%zu can't be larger than 32 when using 'startbyte'\n",\r\nlen);\r\nreturn -EINVAL;\r\n}\r\ntxbuf[0] = par->startbyte | 0x3;\r\nt.tx_buf = txbuf;\r\nfbtft_par_dbg_hex(DEBUG_READ, par, par->info->device, u8,\r\ntxbuf, len, "%s(len=%d) txbuf => ", __func__, len);\r\n}\r\nspi_message_init(&m);\r\nspi_message_add_tail(&t, &m);\r\nret = spi_sync(par->spi, &m);\r\nfbtft_par_dbg_hex(DEBUG_READ, par, par->info->device, u8, buf, len,\r\n"%s(len=%d) buf <= ", __func__, len);\r\nreturn ret;\r\n}\r\nint fbtft_write_gpio8_wr(struct fbtft_par *par, void *buf, size_t len)\r\n{\r\nu8 data;\r\nint i;\r\n#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO\r\nstatic u8 prev_data;\r\n#endif\r\nfbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,\r\n"%s(len=%d): ", __func__, len);\r\nwhile (len--) {\r\ndata = *(u8 *) buf;\r\ngpio_set_value(par->gpio.wr, 0);\r\n#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO\r\nif (data == prev_data) {\r\ngpio_set_value(par->gpio.wr, 0);\r\n} else {\r\nfor (i = 0; i < 8; i++) {\r\nif ((data & 1) != (prev_data & 1))\r\ngpio_set_value(par->gpio.db[i],\r\ndata & 1);\r\ndata >>= 1;\r\nprev_data >>= 1;\r\n}\r\n}\r\n#else\r\nfor (i = 0; i < 8; i++) {\r\ngpio_set_value(par->gpio.db[i], data & 1);\r\ndata >>= 1;\r\n}\r\n#endif\r\ngpio_set_value(par->gpio.wr, 1);\r\n#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO\r\nprev_data = *(u8 *) buf;\r\n#endif\r\nbuf++;\r\n}\r\nreturn 0;\r\n}\r\nint fbtft_write_gpio16_wr(struct fbtft_par *par, void *buf, size_t len)\r\n{\r\nu16 data;\r\nint i;\r\n#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO\r\nstatic u16 prev_data;\r\n#endif\r\nfbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,\r\n"%s(len=%d): ", __func__, len);\r\nwhile (len) {\r\ndata = *(u16 *) buf;\r\ngpio_set_value(par->gpio.wr, 0);\r\n#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO\r\nif (data == prev_data) {\r\ngpio_set_value(par->gpio.wr, 0);\r\n} else {\r\nfor (i = 0; i < 16; i++) {\r\nif ((data & 1) != (prev_data & 1))\r\ngpio_set_value(par->gpio.db[i],\r\ndata & 1);\r\ndata >>= 1;\r\nprev_data >>= 1;\r\n}\r\n}\r\n#else\r\nfor (i = 0; i < 16; i++) {\r\ngpio_set_value(par->gpio.db[i], data & 1);\r\ndata >>= 1;\r\n}\r\n#endif\r\ngpio_set_value(par->gpio.wr, 1);\r\n#ifndef DO_NOT_OPTIMIZE_FBTFT_WRITE_GPIO\r\nprev_data = *(u16 *) buf;\r\n#endif\r\nbuf += 2;\r\nlen -= 2;\r\n}\r\nreturn 0;\r\n}\r\nint fbtft_write_gpio16_wr_latched(struct fbtft_par *par, void *buf, size_t len)\r\n{\r\ndev_err(par->info->device, "%s: function not implemented\n", __func__);\r\nreturn -1;\r\n}
