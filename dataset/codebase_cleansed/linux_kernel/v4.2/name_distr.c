static void publ_to_item(struct distr_item *i, struct publication *p)\r\n{\r\ni->type = htonl(p->type);\r\ni->lower = htonl(p->lower);\r\ni->upper = htonl(p->upper);\r\ni->ref = htonl(p->ref);\r\ni->key = htonl(p->key);\r\n}\r\nstatic struct sk_buff *named_prepare_buf(struct net *net, u32 type, u32 size,\r\nu32 dest)\r\n{\r\nstruct tipc_net *tn = net_generic(net, tipc_net_id);\r\nstruct sk_buff *buf = tipc_buf_acquire(INT_H_SIZE + size);\r\nstruct tipc_msg *msg;\r\nif (buf != NULL) {\r\nmsg = buf_msg(buf);\r\ntipc_msg_init(tn->own_addr, msg, NAME_DISTRIBUTOR, type,\r\nINT_H_SIZE, dest);\r\nmsg_set_size(msg, INT_H_SIZE + size);\r\n}\r\nreturn buf;\r\n}\r\nvoid named_cluster_distribute(struct net *net, struct sk_buff *skb)\r\n{\r\nstruct tipc_net *tn = net_generic(net, tipc_net_id);\r\nstruct sk_buff *oskb;\r\nstruct tipc_node *node;\r\nu32 dnode;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(node, &tn->node_list, list) {\r\ndnode = node->addr;\r\nif (in_own_node(net, dnode))\r\ncontinue;\r\nif (!tipc_node_active_links(node))\r\ncontinue;\r\noskb = pskb_copy(skb, GFP_ATOMIC);\r\nif (!oskb)\r\nbreak;\r\nmsg_set_destnode(buf_msg(oskb), dnode);\r\ntipc_link_xmit_skb(net, oskb, dnode, dnode);\r\n}\r\nrcu_read_unlock();\r\nkfree_skb(skb);\r\n}\r\nstruct sk_buff *tipc_named_publish(struct net *net, struct publication *publ)\r\n{\r\nstruct tipc_net *tn = net_generic(net, tipc_net_id);\r\nstruct sk_buff *buf;\r\nstruct distr_item *item;\r\nlist_add_tail_rcu(&publ->local_list,\r\n&tn->nametbl->publ_list[publ->scope]);\r\nif (publ->scope == TIPC_NODE_SCOPE)\r\nreturn NULL;\r\nbuf = named_prepare_buf(net, PUBLICATION, ITEM_SIZE, 0);\r\nif (!buf) {\r\npr_warn("Publication distribution failure\n");\r\nreturn NULL;\r\n}\r\nitem = (struct distr_item *)msg_data(buf_msg(buf));\r\npubl_to_item(item, publ);\r\nreturn buf;\r\n}\r\nstruct sk_buff *tipc_named_withdraw(struct net *net, struct publication *publ)\r\n{\r\nstruct sk_buff *buf;\r\nstruct distr_item *item;\r\nlist_del(&publ->local_list);\r\nif (publ->scope == TIPC_NODE_SCOPE)\r\nreturn NULL;\r\nbuf = named_prepare_buf(net, WITHDRAWAL, ITEM_SIZE, 0);\r\nif (!buf) {\r\npr_warn("Withdrawal distribution failure\n");\r\nreturn NULL;\r\n}\r\nitem = (struct distr_item *)msg_data(buf_msg(buf));\r\npubl_to_item(item, publ);\r\nreturn buf;\r\n}\r\nstatic void named_distribute(struct net *net, struct sk_buff_head *list,\r\nu32 dnode, struct list_head *pls)\r\n{\r\nstruct publication *publ;\r\nstruct sk_buff *skb = NULL;\r\nstruct distr_item *item = NULL;\r\nuint msg_dsz = (tipc_node_get_mtu(net, dnode, 0) / ITEM_SIZE) *\r\nITEM_SIZE;\r\nuint msg_rem = msg_dsz;\r\nlist_for_each_entry(publ, pls, local_list) {\r\nif (!skb) {\r\nskb = named_prepare_buf(net, PUBLICATION, msg_rem,\r\ndnode);\r\nif (!skb) {\r\npr_warn("Bulk publication failure\n");\r\nreturn;\r\n}\r\nitem = (struct distr_item *)msg_data(buf_msg(skb));\r\n}\r\npubl_to_item(item, publ);\r\nitem++;\r\nmsg_rem -= ITEM_SIZE;\r\nif (!msg_rem) {\r\n__skb_queue_tail(list, skb);\r\nskb = NULL;\r\nmsg_rem = msg_dsz;\r\n}\r\n}\r\nif (skb) {\r\nmsg_set_size(buf_msg(skb), INT_H_SIZE + (msg_dsz - msg_rem));\r\nskb_trim(skb, INT_H_SIZE + (msg_dsz - msg_rem));\r\n__skb_queue_tail(list, skb);\r\n}\r\n}\r\nvoid tipc_named_node_up(struct net *net, u32 dnode)\r\n{\r\nstruct tipc_net *tn = net_generic(net, tipc_net_id);\r\nstruct sk_buff_head head;\r\n__skb_queue_head_init(&head);\r\nrcu_read_lock();\r\nnamed_distribute(net, &head, dnode,\r\n&tn->nametbl->publ_list[TIPC_CLUSTER_SCOPE]);\r\nnamed_distribute(net, &head, dnode,\r\n&tn->nametbl->publ_list[TIPC_ZONE_SCOPE]);\r\nrcu_read_unlock();\r\ntipc_link_xmit(net, &head, dnode, dnode);\r\n}\r\nstatic void tipc_publ_subscribe(struct net *net, struct publication *publ,\r\nu32 addr)\r\n{\r\nstruct tipc_node *node;\r\nif (in_own_node(net, addr))\r\nreturn;\r\nnode = tipc_node_find(net, addr);\r\nif (!node) {\r\npr_warn("Node subscription rejected, unknown node 0x%x\n",\r\naddr);\r\nreturn;\r\n}\r\ntipc_node_lock(node);\r\nlist_add_tail(&publ->nodesub_list, &node->publ_list);\r\ntipc_node_unlock(node);\r\ntipc_node_put(node);\r\n}\r\nstatic void tipc_publ_unsubscribe(struct net *net, struct publication *publ,\r\nu32 addr)\r\n{\r\nstruct tipc_node *node;\r\nnode = tipc_node_find(net, addr);\r\nif (!node)\r\nreturn;\r\ntipc_node_lock(node);\r\nlist_del_init(&publ->nodesub_list);\r\ntipc_node_unlock(node);\r\ntipc_node_put(node);\r\n}\r\nstatic void tipc_publ_purge(struct net *net, struct publication *publ, u32 addr)\r\n{\r\nstruct tipc_net *tn = net_generic(net, tipc_net_id);\r\nstruct publication *p;\r\nspin_lock_bh(&tn->nametbl_lock);\r\np = tipc_nametbl_remove_publ(net, publ->type, publ->lower,\r\npubl->node, publ->ref, publ->key);\r\nif (p)\r\ntipc_publ_unsubscribe(net, p, addr);\r\nspin_unlock_bh(&tn->nametbl_lock);\r\nif (p != publ) {\r\npr_err("Unable to remove publication from failed node\n"\r\n" (type=%u, lower=%u, node=0x%x, ref=%u, key=%u)\n",\r\npubl->type, publ->lower, publ->node, publ->ref,\r\npubl->key);\r\n}\r\nkfree_rcu(p, rcu);\r\n}\r\nvoid tipc_publ_notify(struct net *net, struct list_head *nsub_list, u32 addr)\r\n{\r\nstruct publication *publ, *tmp;\r\nlist_for_each_entry_safe(publ, tmp, nsub_list, nodesub_list)\r\ntipc_publ_purge(net, publ, addr);\r\n}\r\nstatic bool tipc_update_nametbl(struct net *net, struct distr_item *i,\r\nu32 node, u32 dtype)\r\n{\r\nstruct publication *publ = NULL;\r\nif (dtype == PUBLICATION) {\r\npubl = tipc_nametbl_insert_publ(net, ntohl(i->type),\r\nntohl(i->lower),\r\nntohl(i->upper),\r\nTIPC_CLUSTER_SCOPE, node,\r\nntohl(i->ref), ntohl(i->key));\r\nif (publ) {\r\ntipc_publ_subscribe(net, publ, node);\r\nreturn true;\r\n}\r\n} else if (dtype == WITHDRAWAL) {\r\npubl = tipc_nametbl_remove_publ(net, ntohl(i->type),\r\nntohl(i->lower),\r\nnode, ntohl(i->ref),\r\nntohl(i->key));\r\nif (publ) {\r\ntipc_publ_unsubscribe(net, publ, node);\r\nkfree_rcu(publ, rcu);\r\nreturn true;\r\n}\r\n} else {\r\npr_warn("Unrecognized name table message received\n");\r\n}\r\nreturn false;\r\n}\r\nstatic void tipc_named_add_backlog(struct distr_item *i, u32 type, u32 node)\r\n{\r\nstruct distr_queue_item *e;\r\nunsigned long now = get_jiffies_64();\r\ne = kzalloc(sizeof(*e), GFP_ATOMIC);\r\nif (!e)\r\nreturn;\r\ne->dtype = type;\r\ne->node = node;\r\ne->expires = now + msecs_to_jiffies(sysctl_tipc_named_timeout);\r\nmemcpy(e, i, sizeof(*i));\r\nlist_add_tail(&e->next, &tipc_dist_queue);\r\n}\r\nvoid tipc_named_process_backlog(struct net *net)\r\n{\r\nstruct distr_queue_item *e, *tmp;\r\nchar addr[16];\r\nunsigned long now = get_jiffies_64();\r\nlist_for_each_entry_safe(e, tmp, &tipc_dist_queue, next) {\r\nif (time_after(e->expires, now)) {\r\nif (!tipc_update_nametbl(net, &e->i, e->node, e->dtype))\r\ncontinue;\r\n} else {\r\ntipc_addr_string_fill(addr, e->node);\r\npr_warn_ratelimited("Dropping name table update (%d) of {%u, %u, %u} from %s key=%u\n",\r\ne->dtype, ntohl(e->i.type),\r\nntohl(e->i.lower),\r\nntohl(e->i.upper),\r\naddr, ntohl(e->i.key));\r\n}\r\nlist_del(&e->next);\r\nkfree(e);\r\n}\r\n}\r\nvoid tipc_named_rcv(struct net *net, struct sk_buff_head *inputq)\r\n{\r\nstruct tipc_net *tn = net_generic(net, tipc_net_id);\r\nstruct tipc_msg *msg;\r\nstruct distr_item *item;\r\nuint count;\r\nu32 node;\r\nstruct sk_buff *skb;\r\nint mtype;\r\nspin_lock_bh(&tn->nametbl_lock);\r\nfor (skb = skb_dequeue(inputq); skb; skb = skb_dequeue(inputq)) {\r\nmsg = buf_msg(skb);\r\nmtype = msg_type(msg);\r\nitem = (struct distr_item *)msg_data(msg);\r\ncount = msg_data_sz(msg) / ITEM_SIZE;\r\nnode = msg_orignode(msg);\r\nwhile (count--) {\r\nif (!tipc_update_nametbl(net, item, node, mtype))\r\ntipc_named_add_backlog(item, mtype, node);\r\nitem++;\r\n}\r\nkfree_skb(skb);\r\ntipc_named_process_backlog(net);\r\n}\r\nspin_unlock_bh(&tn->nametbl_lock);\r\n}\r\nvoid tipc_named_reinit(struct net *net)\r\n{\r\nstruct tipc_net *tn = net_generic(net, tipc_net_id);\r\nstruct publication *publ;\r\nint scope;\r\nspin_lock_bh(&tn->nametbl_lock);\r\nfor (scope = TIPC_ZONE_SCOPE; scope <= TIPC_NODE_SCOPE; scope++)\r\nlist_for_each_entry_rcu(publ, &tn->nametbl->publ_list[scope],\r\nlocal_list)\r\npubl->node = tn->own_addr;\r\nspin_unlock_bh(&tn->nametbl_lock);\r\n}
