static int show_msp_pci_counts(struct seq_file *m, void *v)\r\n{\r\nint i;\r\nunsigned int intcount, total = 0;\r\nfor (i = 0; i < 32; ++i) {\r\nintcount = pci_int_count[i];\r\nif (intcount != 0) {\r\nseq_printf(m, "[%d] = %u\n", i, intcount);\r\ntotal += intcount;\r\n}\r\n}\r\nseq_printf(m, "total = %u\n", total);\r\nreturn 0;\r\n}\r\nstatic int msp_pci_rd_cnt_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, show_msp_pci_counts, NULL);\r\n}\r\nstatic int gen_pci_cfg_wr_show(struct seq_file *m, void *v)\r\n{\r\nunsigned char where = 0;\r\nunsigned char bus_num = 0;\r\nunsigned char dev_fn = 0xF;\r\nu32 wr_data = 0xFF00AA00;\r\nstruct msp_pci_regs *preg = (void *)PCI_BASE_REG;\r\nunsigned long value;\r\nint intr;\r\nseq_puts(m, "PMC MSP PCI: Beginning\n");\r\nif (proc_init == 0) {\r\npci_proc_init();\r\nproc_init = ~0;\r\n}\r\nseq_puts(m, "PMC MSP PCI: Before Cfg Wr\n");\r\npreg->if_status = ~(BPCI_IFSTATUS_BC0F | BPCI_IFSTATUS_BC1F);\r\npreg->config_addr = BPCI_CFGADDR_ENABLE |\r\n(bus_num << BPCI_CFGADDR_BUSNUM_SHF) |\r\n(dev_fn << BPCI_CFGADDR_FUNCTNUM_SHF) |\r\n(where & 0xFC);\r\nvalue = cpu_to_le32(wr_data);\r\n*PCI_CONFIG_SPACE_REG = value;\r\nintr = preg->if_status;\r\nseq_puts(m, "PMC MSP PCI: After Cfg Wr\n");\r\nreturn 0;\r\n}\r\nstatic int gen_pci_cfg_wr_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, gen_pci_cfg_wr_show, NULL);\r\n}\r\nstatic void pci_proc_init(void)\r\n{\r\nproc_create("pmc_msp_pci_rd_cnt", 0, NULL, &msp_pci_rd_cnt_fops);\r\nproc_create("pmc_msp_pci_cfg_wr", 0, NULL, &gen_pci_cfg_wr_fops);\r\n}\r\nstatic irqreturn_t bpci_interrupt(int irq, void *dev_id)\r\n{\r\nstruct msp_pci_regs *preg = (void *)PCI_BASE_REG;\r\nunsigned int stat = preg->if_status;\r\n#if defined(CONFIG_PROC_FS) && defined(PCI_COUNTERS)\r\nint i;\r\nfor (i = 0; i < 32; ++i) {\r\nif ((1 << i) & stat)\r\n++pci_int_count[i];\r\n}\r\n#endif\r\npreg->if_status = stat;\r\nreturn IRQ_HANDLED;\r\n}\r\nint msp_pcibios_config_access(unsigned char access_type,\r\nstruct pci_bus *bus,\r\nunsigned int devfn,\r\nunsigned char where,\r\nu32 *data)\r\n{\r\nstruct msp_pci_regs *preg = (void *)PCI_BASE_REG;\r\nunsigned char bus_num = bus->number;\r\nunsigned char dev_fn = (unsigned char)devfn;\r\nunsigned long intr;\r\nunsigned long value;\r\nstatic char pciirqflag;\r\nint ret;\r\n#if defined(CONFIG_PMC_MSP7120_GW) || defined(CONFIG_PMC_MSP7120_EVAL)\r\nunsigned int vpe_status;\r\n#endif\r\n#if defined(CONFIG_PROC_FS) && defined(PCI_COUNTERS)\r\nif (proc_init == 0) {\r\npci_proc_init();\r\nproc_init = ~0;\r\n}\r\n#endif\r\nif (pciirqflag == 0) {\r\nret = request_irq(MSP_INT_PCI,\r\nbpci_interrupt,\r\nIRQF_SHARED,\r\n"PMC MSP PCI Host",\r\npreg);\r\nif (ret != 0)\r\nreturn ret;\r\npciirqflag = ~0;\r\n}\r\n#if defined(CONFIG_PMC_MSP7120_GW) || defined(CONFIG_PMC_MSP7120_EVAL)\r\nvpe_status = dvpe();\r\n#endif\r\npreg->if_status = ~(BPCI_IFSTATUS_BC0F | BPCI_IFSTATUS_BC1F);\r\npreg->config_addr = BPCI_CFGADDR_ENABLE |\r\n(bus_num << BPCI_CFGADDR_BUSNUM_SHF) |\r\n(dev_fn << BPCI_CFGADDR_FUNCTNUM_SHF) |\r\n(where & 0xFC);\r\nif (access_type == PCI_ACCESS_WRITE) {\r\nvalue = cpu_to_le32(*data);\r\n*PCI_CONFIG_SPACE_REG = value;\r\n} else {\r\nvalue = le32_to_cpu(*PCI_CONFIG_SPACE_REG);\r\n*data = value;\r\n}\r\nintr = preg->if_status;\r\npreg->config_addr = 0;\r\nif (intr & ~(BPCI_IFSTATUS_BC0F | BPCI_IFSTATUS_BC1F)) {\r\npreg->if_status = ~(BPCI_IFSTATUS_BC0F | BPCI_IFSTATUS_BC1F);\r\n#if defined(CONFIG_PMC_MSP7120_GW) || defined(CONFIG_PMC_MSP7120_EVAL)\r\nevpe(vpe_status);\r\n#endif\r\nreturn -1;\r\n}\r\n#if defined(CONFIG_PMC_MSP7120_GW) || defined(CONFIG_PMC_MSP7120_EVAL)\r\nevpe(vpe_status);\r\n#endif\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int\r\nmsp_pcibios_read_config_byte(struct pci_bus *bus,\r\nunsigned int devfn,\r\nint where,\r\nu32 *val)\r\n{\r\nu32 data = 0;\r\nif (msp_pcibios_config_access(PCI_ACCESS_READ, bus, devfn,\r\nwhere, &data)) {\r\n*val = 0xFFFFFFFF;\r\nreturn -1;\r\n}\r\n*val = (data >> ((where & 3) << 3)) & 0x0ff;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int\r\nmsp_pcibios_read_config_word(struct pci_bus *bus,\r\nunsigned int devfn,\r\nint where,\r\nu32 *val)\r\n{\r\nu32 data = 0;\r\nif ((where & 3) == 3) {\r\n*val = 0xFFFFFFFF;\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\n}\r\nif (msp_pcibios_config_access(PCI_ACCESS_READ, bus, devfn,\r\nwhere, &data)) {\r\n*val = 0xFFFFFFFF;\r\nreturn -1;\r\n}\r\n*val = (data >> ((where & 3) << 3)) & 0x0ffff;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int\r\nmsp_pcibios_read_config_dword(struct pci_bus *bus,\r\nunsigned int devfn,\r\nint where,\r\nu32 *val)\r\n{\r\nu32 data = 0;\r\nif (where & 3) {\r\n*val = 0xFFFFFFFF;\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\n}\r\nif (msp_pcibios_config_access(PCI_ACCESS_READ, bus, devfn,\r\nwhere, &data)) {\r\n*val = 0xFFFFFFFF;\r\nreturn -1;\r\n}\r\n*val = data;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int\r\nmsp_pcibios_write_config_byte(struct pci_bus *bus,\r\nunsigned int devfn,\r\nint where,\r\nu8 val)\r\n{\r\nu32 data = 0;\r\nif (msp_pcibios_config_access(PCI_ACCESS_READ, bus, devfn,\r\nwhere, &data))\r\nreturn -1;\r\ndata = (data & ~(0xff << ((where & 3) << 3))) |\r\n(val << ((where & 3) << 3));\r\nif (msp_pcibios_config_access(PCI_ACCESS_WRITE, bus, devfn,\r\nwhere, &data))\r\nreturn -1;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int\r\nmsp_pcibios_write_config_word(struct pci_bus *bus,\r\nunsigned int devfn,\r\nint where,\r\nu16 val)\r\n{\r\nu32 data = 0;\r\nif ((where & 3) == 3)\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\nif (msp_pcibios_config_access(PCI_ACCESS_READ, bus, devfn,\r\nwhere, &data))\r\nreturn -1;\r\ndata = (data & ~(0xffff << ((where & 3) << 3))) |\r\n(val << ((where & 3) << 3));\r\nif (msp_pcibios_config_access(PCI_ACCESS_WRITE, bus, devfn,\r\nwhere, &data))\r\nreturn -1;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int\r\nmsp_pcibios_write_config_dword(struct pci_bus *bus,\r\nunsigned int devfn,\r\nint where,\r\nu32 val)\r\n{\r\nif (where & 3)\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\nif (msp_pcibios_config_access(PCI_ACCESS_WRITE, bus, devfn,\r\nwhere, &val))\r\nreturn -1;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nint\r\nmsp_pcibios_read_config(struct pci_bus *bus,\r\nunsigned int devfn,\r\nint where,\r\nint size,\r\nu32 *val)\r\n{\r\nif (size == 1) {\r\nif (msp_pcibios_read_config_byte(bus, devfn, where, val)) {\r\nreturn -1;\r\n}\r\n} else if (size == 2) {\r\nif (msp_pcibios_read_config_word(bus, devfn, where, val)) {\r\nreturn -1;\r\n}\r\n} else if (size == 4) {\r\nif (msp_pcibios_read_config_dword(bus, devfn, where, val)) {\r\nreturn -1;\r\n}\r\n} else {\r\n*val = 0xFFFFFFFF;\r\nreturn -1;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nint\r\nmsp_pcibios_write_config(struct pci_bus *bus,\r\nunsigned int devfn,\r\nint where,\r\nint size,\r\nu32 val)\r\n{\r\nif (size == 1) {\r\nif (msp_pcibios_write_config_byte(bus, devfn,\r\nwhere, (u8)(0xFF & val))) {\r\nreturn -1;\r\n}\r\n} else if (size == 2) {\r\nif (msp_pcibios_write_config_word(bus, devfn,\r\nwhere, (u16)(0xFFFF & val))) {\r\nreturn -1;\r\n}\r\n} else if (size == 4) {\r\nif (msp_pcibios_write_config_dword(bus, devfn, where, val)) {\r\nreturn -1;\r\n}\r\n} else {\r\nreturn -1;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nvoid __init msp_pci_init(void)\r\n{\r\nstruct msp_pci_regs *preg = (void *)PCI_BASE_REG;\r\nu32 id;\r\nid = read_reg32(PCI_JTAG_DEVID_REG, 0xFFFF) >> 12;\r\nif (!MSP_HAS_PCI(id)) {\r\nprintk(KERN_WARNING "PCI: No PCI; id reads as %x\n", id);\r\ngoto no_pci;\r\n}\r\n*(unsigned long *)QFLUSH_REG_1 = 3;\r\npreg->if_status = ~0;\r\npreg->config_addr = 0;\r\npreg->oatran = MSP_PCI_OATRAN;\r\npreg->if_mask = 0xF8BF87C0;\r\nset_io_port_base(MSP_PCI_IOSPACE_BASE);\r\nregister_pci_controller(&msp_pci_controller);\r\nreturn;\r\nno_pci:\r\nprintk(KERN_WARNING "PCI: no host PCI bus detected\n");\r\n}
