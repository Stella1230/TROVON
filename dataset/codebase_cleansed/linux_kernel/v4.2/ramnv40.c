int\r\nnv40_ram_calc(struct nvkm_fb *pfb, u32 freq)\r\n{\r\nstruct nvkm_bios *bios = nvkm_bios(pfb);\r\nstruct nv40_ram *ram = (void *)pfb->ram;\r\nstruct nvbios_pll pll;\r\nint N1, M1, N2, M2;\r\nint log2P, ret;\r\nret = nvbios_pll_parse(bios, 0x04, &pll);\r\nif (ret) {\r\nnv_error(pfb, "mclk pll data not found\n");\r\nreturn ret;\r\n}\r\nret = nv04_pll_calc(nv_subdev(pfb), &pll, freq,\r\n&N1, &M1, &N2, &M2, &log2P);\r\nif (ret < 0)\r\nreturn ret;\r\nram->ctrl = 0x80000000 | (log2P << 16);\r\nram->ctrl |= min(pll.bias_p + log2P, (int)pll.max_p) << 20;\r\nif (N2 == M2) {\r\nram->ctrl |= 0x00000100;\r\nram->coef = (N1 << 8) | M1;\r\n} else {\r\nram->ctrl |= 0x40000000;\r\nram->coef = (N2 << 24) | (M2 << 16) | (N1 << 8) | M1;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nnv40_ram_prog(struct nvkm_fb *pfb)\r\n{\r\nstruct nvkm_bios *bios = nvkm_bios(pfb);\r\nstruct nv40_ram *ram = (void *)pfb->ram;\r\nstruct bit_entry M;\r\nu32 crtc_mask = 0;\r\nu8 sr1[2];\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nu32 vbl = nv_rd32(pfb, 0x600808 + (i * 0x2000));\r\nu32 cnt = 0;\r\ndo {\r\nif (vbl != nv_rd32(pfb, 0x600808 + (i * 0x2000))) {\r\nnv_wr08(pfb, 0x0c03c4 + (i * 0x2000), 0x01);\r\nsr1[i] = nv_rd08(pfb, 0x0c03c5 + (i * 0x2000));\r\nif (!(sr1[i] & 0x20))\r\ncrtc_mask |= (1 << i);\r\nbreak;\r\n}\r\nudelay(1);\r\n} while (cnt++ < 32);\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nif (!(crtc_mask & (1 << i)))\r\ncontinue;\r\nnv_wait(pfb, 0x600808 + (i * 0x2000), 0x00010000, 0x00000000);\r\nnv_wait(pfb, 0x600808 + (i * 0x2000), 0x00010000, 0x00010000);\r\nnv_wr08(pfb, 0x0c03c4 + (i * 0x2000), 0x01);\r\nnv_wr08(pfb, 0x0c03c5 + (i * 0x2000), sr1[i] | 0x20);\r\n}\r\nnv_wr32(pfb, 0x1002d4, 0x00000001);\r\nnv_wr32(pfb, 0x1002d0, 0x00000001);\r\nnv_wr32(pfb, 0x1002d0, 0x00000001);\r\nnv_mask(pfb, 0x100210, 0x80000000, 0x00000000);\r\nnv_wr32(pfb, 0x1002dc, 0x00000001);\r\nnv_mask(pfb, 0x00c040, 0x0000c000, 0x00000000);\r\nswitch (nv_device(pfb)->chipset) {\r\ncase 0x40:\r\ncase 0x45:\r\ncase 0x41:\r\ncase 0x42:\r\ncase 0x47:\r\nnv_mask(pfb, 0x004044, 0xc0771100, ram->ctrl);\r\nnv_mask(pfb, 0x00402c, 0xc0771100, ram->ctrl);\r\nnv_wr32(pfb, 0x004048, ram->coef);\r\nnv_wr32(pfb, 0x004030, ram->coef);\r\ncase 0x43:\r\ncase 0x49:\r\ncase 0x4b:\r\nnv_mask(pfb, 0x004038, 0xc0771100, ram->ctrl);\r\nnv_wr32(pfb, 0x00403c, ram->coef);\r\ndefault:\r\nnv_mask(pfb, 0x004020, 0xc0771100, ram->ctrl);\r\nnv_wr32(pfb, 0x004024, ram->coef);\r\nbreak;\r\n}\r\nudelay(100);\r\nnv_mask(pfb, 0x00c040, 0x0000c000, 0x0000c000);\r\nnv_wr32(pfb, 0x1002dc, 0x00000000);\r\nnv_mask(pfb, 0x100210, 0x80000000, 0x80000000);\r\nudelay(100);\r\nif (!bit_entry(bios, 'M', &M)) {\r\nstruct nvbios_init init = {\r\n.subdev = nv_subdev(pfb),\r\n.bios = bios,\r\n.offset = nv_ro16(bios, M.offset + 0x00),\r\n.execute = 1,\r\n};\r\nnvbios_exec(&init);\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nif (!(crtc_mask & (1 << i)))\r\ncontinue;\r\nnv_wait(pfb, 0x600808 + (i * 0x2000), 0x00010000, 0x00010000);\r\nnv_wr08(pfb, 0x0c03c4 + (i * 0x2000), 0x01);\r\nnv_wr08(pfb, 0x0c03c5 + (i * 0x2000), sr1[i]);\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nnv40_ram_tidy(struct nvkm_fb *pfb)\r\n{\r\n}\r\nstatic int\r\nnv40_ram_create(struct nvkm_object *parent, struct nvkm_object *engine,\r\nstruct nvkm_oclass *oclass, void *data, u32 size,\r\nstruct nvkm_object **pobject)\r\n{\r\nstruct nvkm_fb *pfb = nvkm_fb(parent);\r\nstruct nv40_ram *ram;\r\nu32 pbus1218 = nv_rd32(pfb, 0x001218);\r\nint ret;\r\nret = nvkm_ram_create(parent, engine, oclass, &ram);\r\n*pobject = nv_object(ram);\r\nif (ret)\r\nreturn ret;\r\nswitch (pbus1218 & 0x00000300) {\r\ncase 0x00000000: ram->base.type = NV_MEM_TYPE_SDRAM; break;\r\ncase 0x00000100: ram->base.type = NV_MEM_TYPE_DDR1; break;\r\ncase 0x00000200: ram->base.type = NV_MEM_TYPE_GDDR3; break;\r\ncase 0x00000300: ram->base.type = NV_MEM_TYPE_DDR2; break;\r\n}\r\nram->base.size = nv_rd32(pfb, 0x10020c) & 0xff000000;\r\nram->base.parts = (nv_rd32(pfb, 0x100200) & 0x00000003) + 1;\r\nram->base.tags = nv_rd32(pfb, 0x100320);\r\nram->base.calc = nv40_ram_calc;\r\nram->base.prog = nv40_ram_prog;\r\nram->base.tidy = nv40_ram_tidy;\r\nreturn 0;\r\n}
