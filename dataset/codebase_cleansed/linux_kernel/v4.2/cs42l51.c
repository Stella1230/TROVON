static int cs42l51_get_chan_mix(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nunsigned long value = snd_soc_read(codec, CS42L51_PCM_MIXER)&3;\r\nswitch (value) {\r\ndefault:\r\ncase 0:\r\nucontrol->value.integer.value[0] = 0;\r\nbreak;\r\ncase 1:\r\ncase 2:\r\nucontrol->value.integer.value[0] = 1;\r\nbreak;\r\ncase 3:\r\nucontrol->value.integer.value[0] = 2;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs42l51_set_chan_mix(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nunsigned char val;\r\nswitch (ucontrol->value.integer.value[0]) {\r\ndefault:\r\ncase 0:\r\nval = CHAN_MIX_NORMAL;\r\nbreak;\r\ncase 1:\r\nval = CHAN_MIX_BOTH;\r\nbreak;\r\ncase 2:\r\nval = CHAN_MIX_SWAP;\r\nbreak;\r\n}\r\nsnd_soc_write(codec, CS42L51_PCM_MIXER, val);\r\nreturn 1;\r\n}\r\nstatic int cs42l51_pdn_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nsnd_soc_update_bits(codec, CS42L51_POWER_CTL1,\r\nCS42L51_POWER_CTL1_PDN,\r\nCS42L51_POWER_CTL1_PDN);\r\nbreak;\r\ndefault:\r\ncase SND_SOC_DAPM_POST_PMD:\r\nsnd_soc_update_bits(codec, CS42L51_POWER_CTL1,\r\nCS42L51_POWER_CTL1_PDN, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs42l51_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int format)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct cs42l51_private *cs42l51 = snd_soc_codec_get_drvdata(codec);\r\nswitch (format & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ncs42l51->audio_mode = format & SND_SOC_DAIFMT_FORMAT_MASK;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "invalid DAI format\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (format & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\ncs42l51->func = MODE_MASTER;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\ncs42l51->func = MODE_SLAVE_AUTO;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unknown master/slave configuration\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs42l51_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct cs42l51_private *cs42l51 = snd_soc_codec_get_drvdata(codec);\r\ncs42l51->mclk = freq;\r\nreturn 0;\r\n}\r\nstatic int cs42l51_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct cs42l51_private *cs42l51 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nunsigned int i;\r\nunsigned int rate;\r\nunsigned int ratio;\r\nstruct cs42l51_ratios *ratios = NULL;\r\nint nr_ratios = 0;\r\nint intf_ctl, power_ctl, fmt;\r\nswitch (cs42l51->func) {\r\ncase MODE_MASTER:\r\nreturn -EINVAL;\r\ncase MODE_SLAVE:\r\nratios = slave_ratios;\r\nnr_ratios = ARRAY_SIZE(slave_ratios);\r\nbreak;\r\ncase MODE_SLAVE_AUTO:\r\nratios = slave_auto_ratios;\r\nnr_ratios = ARRAY_SIZE(slave_auto_ratios);\r\nbreak;\r\n}\r\nrate = params_rate(params);\r\nratio = cs42l51->mclk / rate;\r\nfor (i = 0; i < nr_ratios; i++) {\r\nif (ratios[i].ratio == ratio)\r\nbreak;\r\n}\r\nif (i == nr_ratios) {\r\ndev_err(codec->dev, "could not find matching ratio\n");\r\nreturn -EINVAL;\r\n}\r\nintf_ctl = snd_soc_read(codec, CS42L51_INTF_CTL);\r\npower_ctl = snd_soc_read(codec, CS42L51_MIC_POWER_CTL);\r\nintf_ctl &= ~(CS42L51_INTF_CTL_MASTER | CS42L51_INTF_CTL_ADC_I2S\r\n| CS42L51_INTF_CTL_DAC_FORMAT(7));\r\npower_ctl &= ~(CS42L51_MIC_POWER_CTL_SPEED(3)\r\n| CS42L51_MIC_POWER_CTL_MCLK_DIV2);\r\nswitch (cs42l51->func) {\r\ncase MODE_MASTER:\r\nintf_ctl |= CS42L51_INTF_CTL_MASTER;\r\npower_ctl |= CS42L51_MIC_POWER_CTL_SPEED(ratios[i].speed_mode);\r\nbreak;\r\ncase MODE_SLAVE:\r\npower_ctl |= CS42L51_MIC_POWER_CTL_SPEED(ratios[i].speed_mode);\r\nbreak;\r\ncase MODE_SLAVE_AUTO:\r\npower_ctl |= CS42L51_MIC_POWER_CTL_AUTO;\r\nbreak;\r\n}\r\nswitch (cs42l51->audio_mode) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nintf_ctl |= CS42L51_INTF_CTL_ADC_I2S;\r\nintf_ctl |= CS42L51_INTF_CTL_DAC_FORMAT(CS42L51_DAC_DIF_I2S);\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nintf_ctl |= CS42L51_INTF_CTL_DAC_FORMAT(CS42L51_DAC_DIF_LJ24);\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nswitch (params_width(params)) {\r\ncase 16:\r\nfmt = CS42L51_DAC_DIF_RJ16;\r\nbreak;\r\ncase 18:\r\nfmt = CS42L51_DAC_DIF_RJ18;\r\nbreak;\r\ncase 20:\r\nfmt = CS42L51_DAC_DIF_RJ20;\r\nbreak;\r\ncase 24:\r\nfmt = CS42L51_DAC_DIF_RJ24;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "unknown format\n");\r\nreturn -EINVAL;\r\n}\r\nintf_ctl |= CS42L51_INTF_CTL_DAC_FORMAT(fmt);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "unknown format\n");\r\nreturn -EINVAL;\r\n}\r\nif (ratios[i].mclk)\r\npower_ctl |= CS42L51_MIC_POWER_CTL_MCLK_DIV2;\r\nret = snd_soc_write(codec, CS42L51_INTF_CTL, intf_ctl);\r\nif (ret < 0)\r\nreturn ret;\r\nret = snd_soc_write(codec, CS42L51_MIC_POWER_CTL, power_ctl);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int cs42l51_dai_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nint reg;\r\nint mask = CS42L51_DAC_OUT_CTL_DACA_MUTE|CS42L51_DAC_OUT_CTL_DACB_MUTE;\r\nreg = snd_soc_read(codec, CS42L51_DAC_OUT_CTL);\r\nif (mute)\r\nreg |= mask;\r\nelse\r\nreg &= ~mask;\r\nreturn snd_soc_write(codec, CS42L51_DAC_OUT_CTL, reg);\r\n}\r\nstatic int cs42l51_codec_probe(struct snd_soc_codec *codec)\r\n{\r\nint ret, reg;\r\nreg = CS42L51_DAC_CTL_DATA_SEL(1)\r\n| CS42L51_DAC_CTL_AMUTE | CS42L51_DAC_CTL_DACSZ(0);\r\nret = snd_soc_write(codec, CS42L51_DAC_CTL, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nint cs42l51_probe(struct device *dev, struct regmap *regmap)\r\n{\r\nstruct cs42l51_private *cs42l51;\r\nunsigned int val;\r\nint ret;\r\nif (IS_ERR(regmap))\r\nreturn PTR_ERR(regmap);\r\ncs42l51 = devm_kzalloc(dev, sizeof(struct cs42l51_private),\r\nGFP_KERNEL);\r\nif (!cs42l51)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(dev, cs42l51);\r\nret = regmap_read(regmap, CS42L51_CHIP_REV_ID, &val);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to read I2C\n");\r\ngoto error;\r\n}\r\nif ((val != CS42L51_MK_CHIP_REV(CS42L51_CHIP_ID, CS42L51_CHIP_REV_A)) &&\r\n(val != CS42L51_MK_CHIP_REV(CS42L51_CHIP_ID, CS42L51_CHIP_REV_B))) {\r\ndev_err(dev, "Invalid chip id: %x\n", val);\r\nret = -ENODEV;\r\ngoto error;\r\n}\r\ndev_info(dev, "Cirrus Logic CS42L51, Revision: %02X\n",\r\nval & CS42L51_CHIP_REV_MASK);\r\nret = snd_soc_register_codec(dev,\r\n&soc_codec_device_cs42l51, &cs42l51_dai, 1);\r\nerror:\r\nreturn ret;\r\n}
