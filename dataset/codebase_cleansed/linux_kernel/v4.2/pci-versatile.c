static int __init versatile_pci_slot_ignore(char *str)\r\n{\r\nint retval;\r\nint slot;\r\nwhile ((retval = get_option(&str, &slot))) {\r\nif ((slot < 0) || (slot > 31))\r\npr_err("Illegal slot value: %d\n", slot);\r\nelse\r\npci_slot_ignore |= (1 << slot);\r\n}\r\nreturn 1;\r\n}\r\nstatic void __iomem *versatile_map_bus(struct pci_bus *bus,\r\nunsigned int devfn, int offset)\r\n{\r\nunsigned int busnr = bus->number;\r\nif (pci_slot_ignore & (1 << PCI_SLOT(devfn)))\r\nreturn NULL;\r\nreturn versatile_cfg_base[1] + ((busnr << 16) | (devfn << 8) | offset);\r\n}\r\nstatic int versatile_pci_parse_request_of_pci_ranges(struct device *dev,\r\nstruct list_head *res)\r\n{\r\nint err, mem = 1, res_valid = 0;\r\nstruct device_node *np = dev->of_node;\r\nresource_size_t iobase;\r\nstruct resource_entry *win;\r\nerr = of_pci_get_host_bridge_resources(np, 0, 0xff, res, &iobase);\r\nif (err)\r\nreturn err;\r\nresource_list_for_each_entry(win, res) {\r\nstruct resource *parent, *res = win->res;\r\nswitch (resource_type(res)) {\r\ncase IORESOURCE_IO:\r\nparent = &ioport_resource;\r\nerr = pci_remap_iospace(res, iobase);\r\nif (err) {\r\ndev_warn(dev, "error %d: failed to map resource %pR\n",\r\nerr, res);\r\ncontinue;\r\n}\r\nbreak;\r\ncase IORESOURCE_MEM:\r\nparent = &iomem_resource;\r\nres_valid |= !(res->flags & IORESOURCE_PREFETCH);\r\nwritel(res->start >> 28, PCI_IMAP(mem));\r\nwritel(PHYS_OFFSET >> 28, PCI_SMAP(mem));\r\nmem++;\r\nbreak;\r\ncase IORESOURCE_BUS:\r\ndefault:\r\ncontinue;\r\n}\r\nerr = devm_request_resource(dev, parent, res);\r\nif (err)\r\ngoto out_release_res;\r\n}\r\nif (!res_valid) {\r\ndev_err(dev, "non-prefetchable memory resource required\n");\r\nerr = -EINVAL;\r\ngoto out_release_res;\r\n}\r\nreturn 0;\r\nout_release_res:\r\npci_free_resource_list(res);\r\nreturn err;\r\n}\r\nstatic int versatile_pci_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nint ret, i, myslot = -1;\r\nu32 val;\r\nvoid __iomem *local_pci_cfg_base;\r\nstruct pci_bus *bus;\r\nLIST_HEAD(pci_res);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nversatile_pci_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(versatile_pci_base))\r\nreturn PTR_ERR(versatile_pci_base);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nversatile_cfg_base[0] = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(versatile_cfg_base[0]))\r\nreturn PTR_ERR(versatile_cfg_base[0]);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 2);\r\nversatile_cfg_base[1] = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(versatile_cfg_base[1]))\r\nreturn PTR_ERR(versatile_cfg_base[1]);\r\nret = versatile_pci_parse_request_of_pci_ranges(&pdev->dev, &pci_res);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < 32; i++) {\r\nif ((readl(versatile_cfg_base[0] + (i << 11) + PCI_VENDOR_ID) == VP_PCI_DEVICE_ID) &&\r\n(readl(versatile_cfg_base[0] + (i << 11) + PCI_CLASS_REVISION) == VP_PCI_CLASS_ID)) {\r\nmyslot = i;\r\nbreak;\r\n}\r\n}\r\nif (myslot == -1) {\r\ndev_err(&pdev->dev, "Cannot find PCI core!\n");\r\nreturn -EIO;\r\n}\r\npci_slot_ignore |= (1 << myslot);\r\ndev_info(&pdev->dev, "PCI core found (slot %d)\n", myslot);\r\nwritel(myslot, PCI_SELFID);\r\nlocal_pci_cfg_base = versatile_cfg_base[1] + (myslot << 11);\r\nval = readl(local_pci_cfg_base + PCI_COMMAND);\r\nval |= PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_INVALIDATE;\r\nwritel(val, local_pci_cfg_base + PCI_COMMAND);\r\nwritel(PHYS_OFFSET, local_pci_cfg_base + PCI_BASE_ADDRESS_0);\r\nwritel(PHYS_OFFSET, local_pci_cfg_base + PCI_BASE_ADDRESS_1);\r\nwritel(PHYS_OFFSET, local_pci_cfg_base + PCI_BASE_ADDRESS_2);\r\nwritel(0, versatile_cfg_base[0] + PCI_INTERRUPT_LINE);\r\npci_add_flags(PCI_ENABLE_PROC_DOMAINS);\r\npci_add_flags(PCI_REASSIGN_ALL_BUS | PCI_REASSIGN_ALL_RSRC);\r\nbus = pci_scan_root_bus(&pdev->dev, 0, &pci_versatile_ops, &sys, &pci_res);\r\nif (!bus)\r\nreturn -ENOMEM;\r\npci_fixup_irqs(pci_common_swizzle, of_irq_parse_and_map_pci);\r\npci_assign_unassigned_bus_resources(bus);\r\npci_bus_add_devices(bus);\r\nreturn 0;\r\n}
