static void gicv2m_mask_msi_irq(struct irq_data *d)\r\n{\r\npci_msi_mask_irq(d);\r\nirq_chip_mask_parent(d);\r\n}\r\nstatic void gicv2m_unmask_msi_irq(struct irq_data *d)\r\n{\r\npci_msi_unmask_irq(d);\r\nirq_chip_unmask_parent(d);\r\n}\r\nstatic int gicv2m_set_affinity(struct irq_data *irq_data,\r\nconst struct cpumask *mask, bool force)\r\n{\r\nint ret;\r\nret = irq_chip_set_affinity_parent(irq_data, mask, force);\r\nif (ret == IRQ_SET_MASK_OK)\r\nret = IRQ_SET_MASK_OK_DONE;\r\nreturn ret;\r\n}\r\nstatic void gicv2m_compose_msi_msg(struct irq_data *data, struct msi_msg *msg)\r\n{\r\nstruct v2m_data *v2m = irq_data_get_irq_chip_data(data);\r\nphys_addr_t addr = v2m->res.start + V2M_MSI_SETSPI_NS;\r\nmsg->address_hi = (u32) (addr >> 32);\r\nmsg->address_lo = (u32) (addr);\r\nmsg->data = data->hwirq;\r\n}\r\nstatic int gicv2m_irq_gic_domain_alloc(struct irq_domain *domain,\r\nunsigned int virq,\r\nirq_hw_number_t hwirq)\r\n{\r\nstruct of_phandle_args args;\r\nstruct irq_data *d;\r\nint err;\r\nargs.np = domain->parent->of_node;\r\nargs.args_count = 3;\r\nargs.args[0] = 0;\r\nargs.args[1] = hwirq - 32;\r\nargs.args[2] = IRQ_TYPE_EDGE_RISING;\r\nerr = irq_domain_alloc_irqs_parent(domain, virq, 1, &args);\r\nif (err)\r\nreturn err;\r\nd = irq_domain_get_irq_data(domain->parent, virq);\r\nd->chip->irq_set_type(d, IRQ_TYPE_EDGE_RISING);\r\nreturn 0;\r\n}\r\nstatic void gicv2m_unalloc_msi(struct v2m_data *v2m, unsigned int hwirq)\r\n{\r\nint pos;\r\npos = hwirq - v2m->spi_start;\r\nif (pos < 0 || pos >= v2m->nr_spis) {\r\npr_err("Failed to teardown msi. Invalid hwirq %d\n", hwirq);\r\nreturn;\r\n}\r\nspin_lock(&v2m->msi_cnt_lock);\r\n__clear_bit(pos, v2m->bm);\r\nspin_unlock(&v2m->msi_cnt_lock);\r\n}\r\nstatic int gicv2m_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,\r\nunsigned int nr_irqs, void *args)\r\n{\r\nstruct v2m_data *v2m = domain->host_data;\r\nint hwirq, offset, err = 0;\r\nspin_lock(&v2m->msi_cnt_lock);\r\noffset = find_first_zero_bit(v2m->bm, v2m->nr_spis);\r\nif (offset < v2m->nr_spis)\r\n__set_bit(offset, v2m->bm);\r\nelse\r\nerr = -ENOSPC;\r\nspin_unlock(&v2m->msi_cnt_lock);\r\nif (err)\r\nreturn err;\r\nhwirq = v2m->spi_start + offset;\r\nerr = gicv2m_irq_gic_domain_alloc(domain, virq, hwirq);\r\nif (err) {\r\ngicv2m_unalloc_msi(v2m, hwirq);\r\nreturn err;\r\n}\r\nirq_domain_set_hwirq_and_chip(domain, virq, hwirq,\r\n&gicv2m_irq_chip, v2m);\r\nreturn 0;\r\n}\r\nstatic void gicv2m_irq_domain_free(struct irq_domain *domain,\r\nunsigned int virq, unsigned int nr_irqs)\r\n{\r\nstruct irq_data *d = irq_domain_get_irq_data(domain, virq);\r\nstruct v2m_data *v2m = irq_data_get_irq_chip_data(d);\r\nBUG_ON(nr_irqs != 1);\r\ngicv2m_unalloc_msi(v2m, d->hwirq);\r\nirq_domain_free_irqs_parent(domain, virq, nr_irqs);\r\n}\r\nstatic bool is_msi_spi_valid(u32 base, u32 num)\r\n{\r\nif (base < V2M_MIN_SPI) {\r\npr_err("Invalid MSI base SPI (base:%u)\n", base);\r\nreturn false;\r\n}\r\nif ((num == 0) || (base + num > V2M_MAX_SPI)) {\r\npr_err("Number of SPIs (%u) exceed maximum (%u)\n",\r\nnum, V2M_MAX_SPI - V2M_MIN_SPI + 1);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int __init gicv2m_init_one(struct device_node *node,\r\nstruct irq_domain *parent)\r\n{\r\nint ret;\r\nstruct v2m_data *v2m;\r\nv2m = kzalloc(sizeof(struct v2m_data), GFP_KERNEL);\r\nif (!v2m) {\r\npr_err("Failed to allocate struct v2m_data.\n");\r\nreturn -ENOMEM;\r\n}\r\nret = of_address_to_resource(node, 0, &v2m->res);\r\nif (ret) {\r\npr_err("Failed to allocate v2m resource.\n");\r\ngoto err_free_v2m;\r\n}\r\nv2m->base = ioremap(v2m->res.start, resource_size(&v2m->res));\r\nif (!v2m->base) {\r\npr_err("Failed to map GICv2m resource\n");\r\nret = -ENOMEM;\r\ngoto err_free_v2m;\r\n}\r\nif (!of_property_read_u32(node, "arm,msi-base-spi", &v2m->spi_start) &&\r\n!of_property_read_u32(node, "arm,msi-num-spis", &v2m->nr_spis)) {\r\npr_info("Overriding V2M MSI_TYPER (base:%u, num:%u)\n",\r\nv2m->spi_start, v2m->nr_spis);\r\n} else {\r\nu32 typer = readl_relaxed(v2m->base + V2M_MSI_TYPER);\r\nv2m->spi_start = V2M_MSI_TYPER_BASE_SPI(typer);\r\nv2m->nr_spis = V2M_MSI_TYPER_NUM_SPI(typer);\r\n}\r\nif (!is_msi_spi_valid(v2m->spi_start, v2m->nr_spis)) {\r\nret = -EINVAL;\r\ngoto err_iounmap;\r\n}\r\nv2m->bm = kzalloc(sizeof(long) * BITS_TO_LONGS(v2m->nr_spis),\r\nGFP_KERNEL);\r\nif (!v2m->bm) {\r\nret = -ENOMEM;\r\ngoto err_iounmap;\r\n}\r\nv2m->domain = irq_domain_add_tree(NULL, &gicv2m_domain_ops, v2m);\r\nif (!v2m->domain) {\r\npr_err("Failed to create GICv2m domain\n");\r\nret = -ENOMEM;\r\ngoto err_free_bm;\r\n}\r\nv2m->domain->parent = parent;\r\nv2m->mchip.of_node = node;\r\nv2m->mchip.domain = pci_msi_create_irq_domain(node,\r\n&gicv2m_msi_domain_info,\r\nv2m->domain);\r\nif (!v2m->mchip.domain) {\r\npr_err("Failed to create MSI domain\n");\r\nret = -ENOMEM;\r\ngoto err_free_domains;\r\n}\r\nspin_lock_init(&v2m->msi_cnt_lock);\r\nret = of_pci_msi_chip_add(&v2m->mchip);\r\nif (ret) {\r\npr_err("Failed to add msi_chip.\n");\r\ngoto err_free_domains;\r\n}\r\npr_info("Node %s: range[%#lx:%#lx], SPI[%d:%d]\n", node->name,\r\n(unsigned long)v2m->res.start, (unsigned long)v2m->res.end,\r\nv2m->spi_start, (v2m->spi_start + v2m->nr_spis));\r\nreturn 0;\r\nerr_free_domains:\r\nif (v2m->mchip.domain)\r\nirq_domain_remove(v2m->mchip.domain);\r\nif (v2m->domain)\r\nirq_domain_remove(v2m->domain);\r\nerr_free_bm:\r\nkfree(v2m->bm);\r\nerr_iounmap:\r\niounmap(v2m->base);\r\nerr_free_v2m:\r\nkfree(v2m);\r\nreturn ret;\r\n}\r\nint __init gicv2m_of_init(struct device_node *node, struct irq_domain *parent)\r\n{\r\nint ret = 0;\r\nstruct device_node *child;\r\nfor (child = of_find_matching_node(node, gicv2m_device_id); child;\r\nchild = of_find_matching_node(child, gicv2m_device_id)) {\r\nif (!of_find_property(child, "msi-controller", NULL))\r\ncontinue;\r\nret = gicv2m_init_one(child, parent);\r\nif (ret) {\r\nof_node_put(node);\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}
