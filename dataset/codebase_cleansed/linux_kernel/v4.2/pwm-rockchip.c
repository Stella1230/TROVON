static inline struct rockchip_pwm_chip *to_rockchip_pwm_chip(struct pwm_chip *c)\r\n{\r\nreturn container_of(c, struct rockchip_pwm_chip, chip);\r\n}\r\nstatic void rockchip_pwm_set_enable_v1(struct pwm_chip *chip,\r\nstruct pwm_device *pwm, bool enable)\r\n{\r\nstruct rockchip_pwm_chip *pc = to_rockchip_pwm_chip(chip);\r\nu32 enable_conf = PWM_CTRL_OUTPUT_EN | PWM_CTRL_TIMER_EN;\r\nu32 val;\r\nval = readl_relaxed(pc->base + pc->data->regs.ctrl);\r\nif (enable)\r\nval |= enable_conf;\r\nelse\r\nval &= ~enable_conf;\r\nwritel_relaxed(val, pc->base + pc->data->regs.ctrl);\r\n}\r\nstatic void rockchip_pwm_set_enable_v2(struct pwm_chip *chip,\r\nstruct pwm_device *pwm, bool enable)\r\n{\r\nstruct rockchip_pwm_chip *pc = to_rockchip_pwm_chip(chip);\r\nu32 enable_conf = PWM_OUTPUT_LEFT | PWM_LP_DISABLE | PWM_ENABLE |\r\nPWM_CONTINUOUS;\r\nu32 val;\r\nif (pwm->polarity == PWM_POLARITY_INVERSED)\r\nenable_conf |= PWM_DUTY_NEGATIVE | PWM_INACTIVE_POSITIVE;\r\nelse\r\nenable_conf |= PWM_DUTY_POSITIVE | PWM_INACTIVE_NEGATIVE;\r\nval = readl_relaxed(pc->base + pc->data->regs.ctrl);\r\nif (enable)\r\nval |= enable_conf;\r\nelse\r\nval &= ~enable_conf;\r\nwritel_relaxed(val, pc->base + pc->data->regs.ctrl);\r\n}\r\nstatic int rockchip_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\r\nint duty_ns, int period_ns)\r\n{\r\nstruct rockchip_pwm_chip *pc = to_rockchip_pwm_chip(chip);\r\nunsigned long period, duty;\r\nu64 clk_rate, div;\r\nint ret;\r\nclk_rate = clk_get_rate(pc->clk);\r\ndiv = clk_rate * period_ns;\r\ndo_div(div, pc->data->prescaler * NSEC_PER_SEC);\r\nperiod = div;\r\ndiv = clk_rate * duty_ns;\r\ndo_div(div, pc->data->prescaler * NSEC_PER_SEC);\r\nduty = div;\r\nret = clk_enable(pc->clk);\r\nif (ret)\r\nreturn ret;\r\nwritel(period, pc->base + pc->data->regs.period);\r\nwritel(duty, pc->base + pc->data->regs.duty);\r\nwritel(0, pc->base + pc->data->regs.cntr);\r\nclk_disable(pc->clk);\r\nreturn 0;\r\n}\r\nstatic int rockchip_pwm_set_polarity(struct pwm_chip *chip,\r\nstruct pwm_device *pwm,\r\nenum pwm_polarity polarity)\r\n{\r\nreturn 0;\r\n}\r\nstatic int rockchip_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct rockchip_pwm_chip *pc = to_rockchip_pwm_chip(chip);\r\nint ret;\r\nret = clk_enable(pc->clk);\r\nif (ret)\r\nreturn ret;\r\npc->data->set_enable(chip, pwm, true);\r\nreturn 0;\r\n}\r\nstatic void rockchip_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct rockchip_pwm_chip *pc = to_rockchip_pwm_chip(chip);\r\npc->data->set_enable(chip, pwm, false);\r\nclk_disable(pc->clk);\r\n}\r\nstatic int rockchip_pwm_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *id;\r\nstruct rockchip_pwm_chip *pc;\r\nstruct resource *r;\r\nint ret;\r\nid = of_match_device(rockchip_pwm_dt_ids, &pdev->dev);\r\nif (!id)\r\nreturn -EINVAL;\r\npc = devm_kzalloc(&pdev->dev, sizeof(*pc), GFP_KERNEL);\r\nif (!pc)\r\nreturn -ENOMEM;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npc->base = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(pc->base))\r\nreturn PTR_ERR(pc->base);\r\npc->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(pc->clk))\r\nreturn PTR_ERR(pc->clk);\r\nret = clk_prepare(pc->clk);\r\nif (ret)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, pc);\r\npc->data = id->data;\r\npc->chip.dev = &pdev->dev;\r\npc->chip.ops = pc->data->ops;\r\npc->chip.base = -1;\r\npc->chip.npwm = 1;\r\nif (pc->data->ops->set_polarity) {\r\npc->chip.of_xlate = of_pwm_xlate_with_flags;\r\npc->chip.of_pwm_n_cells = 3;\r\n}\r\nret = pwmchip_add(&pc->chip);\r\nif (ret < 0) {\r\nclk_unprepare(pc->clk);\r\ndev_err(&pdev->dev, "pwmchip_add() failed: %d\n", ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic int rockchip_pwm_remove(struct platform_device *pdev)\r\n{\r\nstruct rockchip_pwm_chip *pc = platform_get_drvdata(pdev);\r\nclk_unprepare(pc->clk);\r\nreturn pwmchip_remove(&pc->chip);\r\n}
