static void TsSetupTimeOut(unsigned long data)\r\n{\r\n}\r\nstatic void TsInactTimeout(unsigned long data)\r\n{\r\n}\r\nstatic void RxPktPendingTimeout(unsigned long data)\r\n{\r\nPRX_TS_RECORD pRxTs = (PRX_TS_RECORD)data;\r\nstruct ieee80211_device *ieee = container_of(pRxTs, struct ieee80211_device, RxTsRecord[pRxTs->num]);\r\nPRX_REORDER_ENTRY pReorderEntry = NULL;\r\nunsigned long flags = 0;\r\nstruct ieee80211_rxb *stats_IndicateArray[REORDER_WIN_SIZE];\r\nu8 index = 0;\r\nbool bPktInBuf = false;\r\nspin_lock_irqsave(&(ieee->reorder_spinlock), flags);\r\nIEEE80211_DEBUG(IEEE80211_DL_REORDER,"==================>%s()\n",__func__);\r\nif(pRxTs->RxTimeoutIndicateSeq != 0xffff)\r\n{\r\nwhile(!list_empty(&pRxTs->RxPendingPktList))\r\n{\r\npReorderEntry = (PRX_REORDER_ENTRY)list_entry(pRxTs->RxPendingPktList.prev,RX_REORDER_ENTRY,List);\r\nif(index == 0)\r\npRxTs->RxIndicateSeq = pReorderEntry->SeqNum;\r\nif( SN_LESS(pReorderEntry->SeqNum, pRxTs->RxIndicateSeq) ||\r\nSN_EQUAL(pReorderEntry->SeqNum, pRxTs->RxIndicateSeq) )\r\n{\r\nlist_del_init(&pReorderEntry->List);\r\nif(SN_EQUAL(pReorderEntry->SeqNum, pRxTs->RxIndicateSeq))\r\npRxTs->RxIndicateSeq = (pRxTs->RxIndicateSeq + 1) % 4096;\r\nIEEE80211_DEBUG(IEEE80211_DL_REORDER,"RxPktPendingTimeout(): IndicateSeq: %d\n", pReorderEntry->SeqNum);\r\nstats_IndicateArray[index] = pReorderEntry->prxb;\r\nindex++;\r\nlist_add_tail(&pReorderEntry->List, &ieee->RxReorder_Unused_List);\r\n}\r\nelse\r\n{\r\nbPktInBuf = true;\r\nbreak;\r\n}\r\n}\r\n}\r\nif(index>0)\r\n{\r\npRxTs->RxTimeoutIndicateSeq = 0xffff;\r\nif(index > REORDER_WIN_SIZE){\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "RxReorderIndicatePacket(): Rx Reorer buffer full!! \n");\r\nspin_unlock_irqrestore(&(ieee->reorder_spinlock), flags);\r\nreturn;\r\n}\r\nieee80211_indicate_packets(ieee, stats_IndicateArray, index);\r\n}\r\nif(bPktInBuf && (pRxTs->RxTimeoutIndicateSeq==0xffff))\r\n{\r\npRxTs->RxTimeoutIndicateSeq = pRxTs->RxIndicateSeq;\r\nmod_timer(&pRxTs->RxPktPendingTimer, jiffies + MSECS(ieee->pHTInfo->RxReorderPendingTime));\r\n}\r\nspin_unlock_irqrestore(&(ieee->reorder_spinlock), flags);\r\n}\r\nstatic void TsAddBaProcess(unsigned long data)\r\n{\r\nPTX_TS_RECORD pTxTs = (PTX_TS_RECORD)data;\r\nu8 num = pTxTs->num;\r\nstruct ieee80211_device *ieee = container_of(pTxTs, struct ieee80211_device, TxTsRecord[num]);\r\nTsInitAddBA(ieee, pTxTs, BA_POLICY_IMMEDIATE, false);\r\nIEEE80211_DEBUG(IEEE80211_DL_BA, "TsAddBaProcess(): ADDBA Req is started!! \n");\r\n}\r\nstatic void ResetTsCommonInfo(PTS_COMMON_INFO pTsCommonInfo)\r\n{\r\nmemset(pTsCommonInfo->Addr, 0, 6);\r\nmemset(&pTsCommonInfo->TSpec, 0, sizeof(TSPEC_BODY));\r\nmemset(&pTsCommonInfo->TClass, 0, sizeof(QOS_TCLAS)*TCLAS_NUM);\r\npTsCommonInfo->TClasProc = 0;\r\npTsCommonInfo->TClasNum = 0;\r\n}\r\nstatic void ResetTxTsEntry(PTX_TS_RECORD pTS)\r\n{\r\nResetTsCommonInfo(&pTS->TsCommonInfo);\r\npTS->TxCurSeq = 0;\r\npTS->bAddBaReqInProgress = false;\r\npTS->bAddBaReqDelayed = false;\r\npTS->bUsingBa = false;\r\nResetBaEntry(&pTS->TxAdmittedBARecord);\r\nResetBaEntry(&pTS->TxPendingBARecord);\r\n}\r\nstatic void ResetRxTsEntry(PRX_TS_RECORD pTS)\r\n{\r\nResetTsCommonInfo(&pTS->TsCommonInfo);\r\npTS->RxIndicateSeq = 0xffff;\r\npTS->RxTimeoutIndicateSeq = 0xffff;\r\nResetBaEntry(&pTS->RxAdmittedBARecord);\r\n}\r\nvoid TSInitialize(struct ieee80211_device *ieee)\r\n{\r\nPTX_TS_RECORD pTxTS = ieee->TxTsRecord;\r\nPRX_TS_RECORD pRxTS = ieee->RxTsRecord;\r\nPRX_REORDER_ENTRY pRxReorderEntry = ieee->RxReorderEntry;\r\nu8 count = 0;\r\nIEEE80211_DEBUG(IEEE80211_DL_TS, "==========>%s()\n", __func__);\r\nINIT_LIST_HEAD(&ieee->Tx_TS_Admit_List);\r\nINIT_LIST_HEAD(&ieee->Tx_TS_Pending_List);\r\nINIT_LIST_HEAD(&ieee->Tx_TS_Unused_List);\r\nfor(count = 0; count < TOTAL_TS_NUM; count++)\r\n{\r\npTxTS->num = count;\r\nsetup_timer(&pTxTS->TsCommonInfo.SetupTimer, TsSetupTimeOut,\r\n(unsigned long)pTxTS);\r\nsetup_timer(&pTxTS->TsCommonInfo.InactTimer, TsInactTimeout,\r\n(unsigned long)pTxTS);\r\nsetup_timer(&pTxTS->TsAddBaTimer, TsAddBaProcess,\r\n(unsigned long)pTxTS);\r\nsetup_timer(&pTxTS->TxPendingBARecord.Timer, BaSetupTimeOut,\r\n(unsigned long)pTxTS);\r\nsetup_timer(&pTxTS->TxAdmittedBARecord.Timer,\r\nTxBaInactTimeout, (unsigned long)pTxTS);\r\nResetTxTsEntry(pTxTS);\r\nlist_add_tail(&pTxTS->TsCommonInfo.List, &ieee->Tx_TS_Unused_List);\r\npTxTS++;\r\n}\r\nINIT_LIST_HEAD(&ieee->Rx_TS_Admit_List);\r\nINIT_LIST_HEAD(&ieee->Rx_TS_Pending_List);\r\nINIT_LIST_HEAD(&ieee->Rx_TS_Unused_List);\r\nfor(count = 0; count < TOTAL_TS_NUM; count++)\r\n{\r\npRxTS->num = count;\r\nINIT_LIST_HEAD(&pRxTS->RxPendingPktList);\r\nsetup_timer(&pRxTS->TsCommonInfo.SetupTimer, TsSetupTimeOut,\r\n(unsigned long)pRxTS);\r\nsetup_timer(&pRxTS->TsCommonInfo.InactTimer, TsInactTimeout,\r\n(unsigned long)pRxTS);\r\nsetup_timer(&pRxTS->RxAdmittedBARecord.Timer,\r\nRxBaInactTimeout, (unsigned long)pRxTS);\r\nsetup_timer(&pRxTS->RxPktPendingTimer, RxPktPendingTimeout,\r\n(unsigned long)pRxTS);\r\nResetRxTsEntry(pRxTS);\r\nlist_add_tail(&pRxTS->TsCommonInfo.List, &ieee->Rx_TS_Unused_List);\r\npRxTS++;\r\n}\r\nINIT_LIST_HEAD(&ieee->RxReorder_Unused_List);\r\nfor(count = 0; count < REORDER_ENTRY_NUM; count++)\r\n{\r\nlist_add_tail( &pRxReorderEntry->List,&ieee->RxReorder_Unused_List);\r\nif(count == (REORDER_ENTRY_NUM-1))\r\nbreak;\r\npRxReorderEntry = &ieee->RxReorderEntry[count+1];\r\n}\r\n}\r\nstatic void AdmitTS(struct ieee80211_device *ieee,\r\nPTS_COMMON_INFO pTsCommonInfo, u32 InactTime)\r\n{\r\ndel_timer_sync(&pTsCommonInfo->SetupTimer);\r\ndel_timer_sync(&pTsCommonInfo->InactTimer);\r\nif(InactTime!=0)\r\nmod_timer(&pTsCommonInfo->InactTimer, jiffies + MSECS(InactTime));\r\n}\r\nstatic PTS_COMMON_INFO SearchAdmitTRStream(struct ieee80211_device *ieee,\r\nu8 *Addr, u8 TID,\r\nTR_SELECT TxRxSelect)\r\n{\r\nu8 dir;\r\nbool search_dir[4] = {0};\r\nstruct list_head *psearch_list;\r\nPTS_COMMON_INFO pRet = NULL;\r\nif(ieee->iw_mode == IW_MODE_MASTER)\r\n{\r\nif(TxRxSelect == TX_DIR)\r\n{\r\nsearch_dir[DIR_DOWN] = true;\r\nsearch_dir[DIR_BI_DIR]= true;\r\n}\r\nelse\r\n{\r\nsearch_dir[DIR_UP] = true;\r\nsearch_dir[DIR_BI_DIR]= true;\r\n}\r\n}\r\nelse if(ieee->iw_mode == IW_MODE_ADHOC)\r\n{\r\nif(TxRxSelect == TX_DIR)\r\nsearch_dir[DIR_UP] = true;\r\nelse\r\nsearch_dir[DIR_DOWN] = true;\r\n}\r\nelse\r\n{\r\nif(TxRxSelect == TX_DIR)\r\n{\r\nsearch_dir[DIR_UP] = true;\r\nsearch_dir[DIR_BI_DIR]= true;\r\nsearch_dir[DIR_DIRECT]= true;\r\n}\r\nelse\r\n{\r\nsearch_dir[DIR_DOWN] = true;\r\nsearch_dir[DIR_BI_DIR]= true;\r\nsearch_dir[DIR_DIRECT]= true;\r\n}\r\n}\r\nif(TxRxSelect == TX_DIR)\r\npsearch_list = &ieee->Tx_TS_Admit_List;\r\nelse\r\npsearch_list = &ieee->Rx_TS_Admit_List;\r\nfor(dir = 0; dir <= DIR_BI_DIR; dir++)\r\n{\r\nif (!search_dir[dir])\r\ncontinue;\r\nlist_for_each_entry(pRet, psearch_list, List){\r\nif (memcmp(pRet->Addr, Addr, 6) == 0)\r\nif (pRet->TSpec.f.TSInfo.field.ucTSID == TID)\r\nif(pRet->TSpec.f.TSInfo.field.ucDirection == dir)\r\n{\r\nbreak;\r\n}\r\n}\r\nif(&pRet->List != psearch_list)\r\nbreak;\r\n}\r\nif(&pRet->List != psearch_list){\r\nreturn pRet ;\r\n}\r\nelse\r\nreturn NULL;\r\n}\r\nstatic void MakeTSEntry(PTS_COMMON_INFO pTsCommonInfo, u8 *Addr,\r\nPTSPEC_BODY pTSPEC, PQOS_TCLAS pTCLAS, u8 TCLAS_Num,\r\nu8 TCLAS_Proc)\r\n{\r\nu8 count;\r\nif(pTsCommonInfo == NULL)\r\nreturn;\r\nmemcpy(pTsCommonInfo->Addr, Addr, 6);\r\nif(pTSPEC != NULL)\r\nmemcpy((u8 *)(&(pTsCommonInfo->TSpec)), (u8 *)pTSPEC, sizeof(TSPEC_BODY));\r\nfor(count = 0; count < TCLAS_Num; count++)\r\nmemcpy((u8 *)(&(pTsCommonInfo->TClass[count])), (u8 *)pTCLAS, sizeof(QOS_TCLAS));\r\npTsCommonInfo->TClasProc = TCLAS_Proc;\r\npTsCommonInfo->TClasNum = TCLAS_Num;\r\n}\r\nbool GetTs(\r\nstruct ieee80211_device *ieee,\r\nPTS_COMMON_INFO *ppTS,\r\nu8 *Addr,\r\nu8 TID,\r\nTR_SELECT TxRxSelect,\r\nbool bAddNewTs\r\n)\r\n{\r\nu8 UP = 0;\r\nif (is_multicast_ether_addr(Addr))\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "get TS for Broadcast or Multicast\n");\r\nreturn false;\r\n}\r\nif (ieee->current_network.qos_data.supported == 0)\r\nUP = 0;\r\nelse\r\n{\r\nif (!IsACValid(TID))\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, " in %s(), TID(%d) is not valid\n", __func__, TID);\r\nreturn false;\r\n}\r\nswitch (TID)\r\n{\r\ncase 0:\r\ncase 3:\r\nUP = 0;\r\nbreak;\r\ncase 1:\r\ncase 2:\r\nUP = 2;\r\nbreak;\r\ncase 4:\r\ncase 5:\r\nUP = 5;\r\nbreak;\r\ncase 6:\r\ncase 7:\r\nUP = 7;\r\nbreak;\r\n}\r\n}\r\n*ppTS = SearchAdmitTRStream(\r\nieee,\r\nAddr,\r\nUP,\r\nTxRxSelect);\r\nif(*ppTS != NULL)\r\n{\r\nreturn true;\r\n}\r\nelse\r\n{\r\nif (!bAddNewTs) {\r\nIEEE80211_DEBUG(IEEE80211_DL_TS, "add new TS failed(tid:%d)\n", UP);\r\nreturn false;\r\n}\r\nelse\r\n{\r\nTSPEC_BODY TSpec;\r\nPQOS_TSINFO pTSInfo = &TSpec.f.TSInfo;\r\nstruct list_head *pUnusedList =\r\n(TxRxSelect == TX_DIR)?\r\n(&ieee->Tx_TS_Unused_List):\r\n(&ieee->Rx_TS_Unused_List);\r\nstruct list_head *pAddmitList =\r\n(TxRxSelect == TX_DIR)?\r\n(&ieee->Tx_TS_Admit_List):\r\n(&ieee->Rx_TS_Admit_List);\r\nDIRECTION_VALUE Dir = (ieee->iw_mode == IW_MODE_MASTER)?\r\n((TxRxSelect==TX_DIR)?DIR_DOWN:DIR_UP):\r\n((TxRxSelect==TX_DIR)?DIR_UP:DIR_DOWN);\r\nIEEE80211_DEBUG(IEEE80211_DL_TS, "to add Ts\n");\r\nif(!list_empty(pUnusedList))\r\n{\r\n(*ppTS) = list_entry(pUnusedList->next, TS_COMMON_INFO, List);\r\nlist_del_init(&(*ppTS)->List);\r\nif(TxRxSelect==TX_DIR)\r\n{\r\nPTX_TS_RECORD tmp = container_of(*ppTS, TX_TS_RECORD, TsCommonInfo);\r\nResetTxTsEntry(tmp);\r\n}\r\nelse{\r\nPRX_TS_RECORD tmp = container_of(*ppTS, RX_TS_RECORD, TsCommonInfo);\r\nResetRxTsEntry(tmp);\r\n}\r\nIEEE80211_DEBUG(IEEE80211_DL_TS, "to init current TS, UP:%d, Dir:%d, addr:%pM\n", UP, Dir, Addr);\r\npTSInfo->field.ucTrafficType = 0;\r\npTSInfo->field.ucTSID = UP;\r\npTSInfo->field.ucDirection = Dir;\r\npTSInfo->field.ucAccessPolicy = 1;\r\npTSInfo->field.ucAggregation = 0;\r\npTSInfo->field.ucPSB = 0;\r\npTSInfo->field.ucUP = UP;\r\npTSInfo->field.ucTSInfoAckPolicy = 0;\r\npTSInfo->field.ucSchedule = 0;\r\nMakeTSEntry(*ppTS, Addr, &TSpec, NULL, 0, 0);\r\nAdmitTS(ieee, *ppTS, 0);\r\nlist_add_tail(&((*ppTS)->List), pAddmitList);\r\nreturn true;\r\n}\r\nelse\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "in function %s() There is not enough TS record to be used!!", __func__);\r\nreturn false;\r\n}\r\n}\r\n}\r\n}\r\nstatic void RemoveTsEntry(struct ieee80211_device *ieee, PTS_COMMON_INFO pTs,\r\nTR_SELECT TxRxSelect)\r\n{\r\nunsigned long flags = 0;\r\ndel_timer_sync(&pTs->SetupTimer);\r\ndel_timer_sync(&pTs->InactTimer);\r\nTsInitDelBA(ieee, pTs, TxRxSelect);\r\nif(TxRxSelect == RX_DIR)\r\n{\r\nPRX_REORDER_ENTRY pRxReorderEntry;\r\nPRX_TS_RECORD pRxTS = (PRX_TS_RECORD)pTs;\r\nif(timer_pending(&pRxTS->RxPktPendingTimer))\r\ndel_timer_sync(&pRxTS->RxPktPendingTimer);\r\nwhile(!list_empty(&pRxTS->RxPendingPktList))\r\n{\r\nspin_lock_irqsave(&(ieee->reorder_spinlock), flags);\r\npRxReorderEntry = (PRX_REORDER_ENTRY)list_entry(pRxTS->RxPendingPktList.prev,RX_REORDER_ENTRY,List);\r\nlist_del_init(&pRxReorderEntry->List);\r\n{\r\nint i = 0;\r\nstruct ieee80211_rxb *prxb = pRxReorderEntry->prxb;\r\nif (unlikely(!prxb))\r\n{\r\nspin_unlock_irqrestore(&(ieee->reorder_spinlock), flags);\r\nreturn;\r\n}\r\nfor(i =0; i < prxb->nr_subframes; i++) {\r\ndev_kfree_skb(prxb->subframes[i]);\r\n}\r\nkfree(prxb);\r\nprxb = NULL;\r\n}\r\nlist_add_tail(&pRxReorderEntry->List,&ieee->RxReorder_Unused_List);\r\nspin_unlock_irqrestore(&(ieee->reorder_spinlock), flags);\r\n}\r\n}\r\nelse\r\n{\r\nPTX_TS_RECORD pTxTS = (PTX_TS_RECORD)pTs;\r\ndel_timer_sync(&pTxTS->TsAddBaTimer);\r\n}\r\n}\r\nvoid RemovePeerTS(struct ieee80211_device *ieee, u8 *Addr)\r\n{\r\nPTS_COMMON_INFO pTS, pTmpTS;\r\nprintk("===========>RemovePeerTS,%pM\n", Addr);\r\nlist_for_each_entry_safe(pTS, pTmpTS, &ieee->Tx_TS_Pending_List, List)\r\n{\r\nif (memcmp(pTS->Addr, Addr, 6) == 0)\r\n{\r\nRemoveTsEntry(ieee, pTS, TX_DIR);\r\nlist_del_init(&pTS->List);\r\nlist_add_tail(&pTS->List, &ieee->Tx_TS_Unused_List);\r\n}\r\n}\r\nlist_for_each_entry_safe(pTS, pTmpTS, &ieee->Tx_TS_Admit_List, List)\r\n{\r\nif (memcmp(pTS->Addr, Addr, 6) == 0)\r\n{\r\nprintk("====>remove Tx_TS_admin_list\n");\r\nRemoveTsEntry(ieee, pTS, TX_DIR);\r\nlist_del_init(&pTS->List);\r\nlist_add_tail(&pTS->List, &ieee->Tx_TS_Unused_List);\r\n}\r\n}\r\nlist_for_each_entry_safe(pTS, pTmpTS, &ieee->Rx_TS_Pending_List, List)\r\n{\r\nif (memcmp(pTS->Addr, Addr, 6) == 0)\r\n{\r\nRemoveTsEntry(ieee, pTS, RX_DIR);\r\nlist_del_init(&pTS->List);\r\nlist_add_tail(&pTS->List, &ieee->Rx_TS_Unused_List);\r\n}\r\n}\r\nlist_for_each_entry_safe(pTS, pTmpTS, &ieee->Rx_TS_Admit_List, List)\r\n{\r\nif (memcmp(pTS->Addr, Addr, 6) == 0)\r\n{\r\nRemoveTsEntry(ieee, pTS, RX_DIR);\r\nlist_del_init(&pTS->List);\r\nlist_add_tail(&pTS->List, &ieee->Rx_TS_Unused_List);\r\n}\r\n}\r\n}\r\nvoid RemoveAllTS(struct ieee80211_device *ieee)\r\n{\r\nPTS_COMMON_INFO pTS, pTmpTS;\r\nlist_for_each_entry_safe(pTS, pTmpTS, &ieee->Tx_TS_Pending_List, List)\r\n{\r\nRemoveTsEntry(ieee, pTS, TX_DIR);\r\nlist_del_init(&pTS->List);\r\nlist_add_tail(&pTS->List, &ieee->Tx_TS_Unused_List);\r\n}\r\nlist_for_each_entry_safe(pTS, pTmpTS, &ieee->Tx_TS_Admit_List, List)\r\n{\r\nRemoveTsEntry(ieee, pTS, TX_DIR);\r\nlist_del_init(&pTS->List);\r\nlist_add_tail(&pTS->List, &ieee->Tx_TS_Unused_List);\r\n}\r\nlist_for_each_entry_safe(pTS, pTmpTS, &ieee->Rx_TS_Pending_List, List)\r\n{\r\nRemoveTsEntry(ieee, pTS, RX_DIR);\r\nlist_del_init(&pTS->List);\r\nlist_add_tail(&pTS->List, &ieee->Rx_TS_Unused_List);\r\n}\r\nlist_for_each_entry_safe(pTS, pTmpTS, &ieee->Rx_TS_Admit_List, List)\r\n{\r\nRemoveTsEntry(ieee, pTS, RX_DIR);\r\nlist_del_init(&pTS->List);\r\nlist_add_tail(&pTS->List, &ieee->Rx_TS_Unused_List);\r\n}\r\n}\r\nvoid TsStartAddBaProcess(struct ieee80211_device *ieee, PTX_TS_RECORD pTxTS)\r\n{\r\nif(pTxTS->bAddBaReqInProgress == false)\r\n{\r\npTxTS->bAddBaReqInProgress = true;\r\nif(pTxTS->bAddBaReqDelayed)\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_BA, "TsStartAddBaProcess(): Delayed Start ADDBA after 60 sec!!\n");\r\nmod_timer(&pTxTS->TsAddBaTimer, jiffies + MSECS(TS_ADDBA_DELAY));\r\n}\r\nelse\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_BA,"TsStartAddBaProcess(): Immediately Start ADDBA now!!\n");\r\nmod_timer(&pTxTS->TsAddBaTimer, jiffies+10);\r\n}\r\n}\r\nelse\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "%s()==>BA timer is already added\n", __func__);\r\n}
