static int\r\nnv40_get_intensity(struct backlight_device *bd)\r\n{\r\nstruct nouveau_drm *drm = bl_get_data(bd);\r\nstruct nvif_device *device = &drm->device;\r\nint val = (nvif_rd32(device, NV40_PMC_BACKLIGHT) &\r\nNV40_PMC_BACKLIGHT_MASK) >> 16;\r\nreturn val;\r\n}\r\nstatic int\r\nnv40_set_intensity(struct backlight_device *bd)\r\n{\r\nstruct nouveau_drm *drm = bl_get_data(bd);\r\nstruct nvif_device *device = &drm->device;\r\nint val = bd->props.brightness;\r\nint reg = nvif_rd32(device, NV40_PMC_BACKLIGHT);\r\nnvif_wr32(device, NV40_PMC_BACKLIGHT,\r\n(val << 16) | (reg & ~NV40_PMC_BACKLIGHT_MASK));\r\nreturn 0;\r\n}\r\nstatic int\r\nnv40_backlight_init(struct drm_connector *connector)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(connector->dev);\r\nstruct nvif_device *device = &drm->device;\r\nstruct backlight_properties props;\r\nstruct backlight_device *bd;\r\nif (!(nvif_rd32(device, NV40_PMC_BACKLIGHT) & NV40_PMC_BACKLIGHT_MASK))\r\nreturn 0;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = 31;\r\nbd = backlight_device_register("nv_backlight", connector->kdev, drm,\r\n&nv40_bl_ops, &props);\r\nif (IS_ERR(bd))\r\nreturn PTR_ERR(bd);\r\ndrm->backlight = bd;\r\nbd->props.brightness = nv40_get_intensity(bd);\r\nbacklight_update_status(bd);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_get_intensity(struct backlight_device *bd)\r\n{\r\nstruct nouveau_encoder *nv_encoder = bl_get_data(bd);\r\nstruct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);\r\nstruct nvif_device *device = &drm->device;\r\nint or = nv_encoder->or;\r\nu32 div = 1025;\r\nu32 val;\r\nval = nvif_rd32(device, NV50_PDISP_SOR_PWM_CTL(or));\r\nval &= NV50_PDISP_SOR_PWM_CTL_VAL;\r\nreturn ((val * 100) + (div / 2)) / div;\r\n}\r\nstatic int\r\nnv50_set_intensity(struct backlight_device *bd)\r\n{\r\nstruct nouveau_encoder *nv_encoder = bl_get_data(bd);\r\nstruct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);\r\nstruct nvif_device *device = &drm->device;\r\nint or = nv_encoder->or;\r\nu32 div = 1025;\r\nu32 val = (bd->props.brightness * div) / 100;\r\nnvif_wr32(device, NV50_PDISP_SOR_PWM_CTL(or),\r\nNV50_PDISP_SOR_PWM_CTL_NEW | val);\r\nreturn 0;\r\n}\r\nstatic int\r\nnva3_get_intensity(struct backlight_device *bd)\r\n{\r\nstruct nouveau_encoder *nv_encoder = bl_get_data(bd);\r\nstruct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);\r\nstruct nvif_device *device = &drm->device;\r\nint or = nv_encoder->or;\r\nu32 div, val;\r\ndiv = nvif_rd32(device, NV50_PDISP_SOR_PWM_DIV(or));\r\nval = nvif_rd32(device, NV50_PDISP_SOR_PWM_CTL(or));\r\nval &= NVA3_PDISP_SOR_PWM_CTL_VAL;\r\nif (div && div >= val)\r\nreturn ((val * 100) + (div / 2)) / div;\r\nreturn 100;\r\n}\r\nstatic int\r\nnva3_set_intensity(struct backlight_device *bd)\r\n{\r\nstruct nouveau_encoder *nv_encoder = bl_get_data(bd);\r\nstruct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);\r\nstruct nvif_device *device = &drm->device;\r\nint or = nv_encoder->or;\r\nu32 div, val;\r\ndiv = nvif_rd32(device, NV50_PDISP_SOR_PWM_DIV(or));\r\nval = (bd->props.brightness * div) / 100;\r\nif (div) {\r\nnvif_wr32(device, NV50_PDISP_SOR_PWM_CTL(or), val |\r\nNV50_PDISP_SOR_PWM_CTL_NEW |\r\nNVA3_PDISP_SOR_PWM_CTL_UNK);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nnv50_backlight_init(struct drm_connector *connector)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(connector->dev);\r\nstruct nvif_device *device = &drm->device;\r\nstruct nouveau_encoder *nv_encoder;\r\nstruct backlight_properties props;\r\nstruct backlight_device *bd;\r\nconst struct backlight_ops *ops;\r\nnv_encoder = find_encoder(connector, DCB_OUTPUT_LVDS);\r\nif (!nv_encoder) {\r\nnv_encoder = find_encoder(connector, DCB_OUTPUT_DP);\r\nif (!nv_encoder)\r\nreturn -ENODEV;\r\n}\r\nif (!nvif_rd32(device, NV50_PDISP_SOR_PWM_CTL(nv_encoder->or)))\r\nreturn 0;\r\nif (device->info.chipset <= 0xa0 ||\r\ndevice->info.chipset == 0xaa ||\r\ndevice->info.chipset == 0xac)\r\nops = &nv50_bl_ops;\r\nelse\r\nops = &nva3_bl_ops;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = 100;\r\nbd = backlight_device_register("nv_backlight", connector->kdev,\r\nnv_encoder, ops, &props);\r\nif (IS_ERR(bd))\r\nreturn PTR_ERR(bd);\r\ndrm->backlight = bd;\r\nbd->props.brightness = bd->ops->get_brightness(bd);\r\nbacklight_update_status(bd);\r\nreturn 0;\r\n}\r\nint\r\nnouveau_backlight_init(struct drm_device *dev)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nvif_device *device = &drm->device;\r\nstruct drm_connector *connector;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nif (connector->connector_type != DRM_MODE_CONNECTOR_LVDS &&\r\nconnector->connector_type != DRM_MODE_CONNECTOR_eDP)\r\ncontinue;\r\nswitch (device->info.family) {\r\ncase NV_DEVICE_INFO_V0_CURIE:\r\nreturn nv40_backlight_init(connector);\r\ncase NV_DEVICE_INFO_V0_TESLA:\r\ncase NV_DEVICE_INFO_V0_FERMI:\r\ncase NV_DEVICE_INFO_V0_KEPLER:\r\nreturn nv50_backlight_init(connector);\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nnouveau_backlight_exit(struct drm_device *dev)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nif (drm->backlight) {\r\nbacklight_device_unregister(drm->backlight);\r\ndrm->backlight = NULL;\r\n}\r\n}
