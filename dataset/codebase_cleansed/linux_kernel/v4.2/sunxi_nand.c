static inline struct sunxi_nand_chip *to_sunxi_nand(struct nand_chip *nand)\r\n{\r\nreturn container_of(nand, struct sunxi_nand_chip, nand);\r\n}\r\nstatic inline struct sunxi_nfc *to_sunxi_nfc(struct nand_hw_control *ctrl)\r\n{\r\nreturn container_of(ctrl, struct sunxi_nfc, controller);\r\n}\r\nstatic irqreturn_t sunxi_nfc_interrupt(int irq, void *dev_id)\r\n{\r\nstruct sunxi_nfc *nfc = dev_id;\r\nu32 st = readl(nfc->regs + NFC_REG_ST);\r\nu32 ien = readl(nfc->regs + NFC_REG_INT);\r\nif (!(ien & st))\r\nreturn IRQ_NONE;\r\nif ((ien & st) == ien)\r\ncomplete(&nfc->complete);\r\nwritel(st & NFC_INT_MASK, nfc->regs + NFC_REG_ST);\r\nwritel(~st & ien & NFC_INT_MASK, nfc->regs + NFC_REG_INT);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sunxi_nfc_wait_int(struct sunxi_nfc *nfc, u32 flags,\r\nunsigned int timeout_ms)\r\n{\r\ninit_completion(&nfc->complete);\r\nwritel(flags, nfc->regs + NFC_REG_INT);\r\nif (!timeout_ms)\r\ntimeout_ms = NFC_DEFAULT_TIMEOUT_MS;\r\nif (!wait_for_completion_timeout(&nfc->complete,\r\nmsecs_to_jiffies(timeout_ms))) {\r\ndev_err(nfc->dev, "wait interrupt timedout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sunxi_nfc_wait_cmd_fifo_empty(struct sunxi_nfc *nfc)\r\n{\r\nunsigned long timeout = jiffies +\r\nmsecs_to_jiffies(NFC_DEFAULT_TIMEOUT_MS);\r\ndo {\r\nif (!(readl(nfc->regs + NFC_REG_ST) & NFC_CMD_FIFO_STATUS))\r\nreturn 0;\r\n} while (time_before(jiffies, timeout));\r\ndev_err(nfc->dev, "wait for empty cmd FIFO timedout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int sunxi_nfc_rst(struct sunxi_nfc *nfc)\r\n{\r\nunsigned long timeout = jiffies +\r\nmsecs_to_jiffies(NFC_DEFAULT_TIMEOUT_MS);\r\nwritel(0, nfc->regs + NFC_REG_ECC_CTL);\r\nwritel(NFC_RESET, nfc->regs + NFC_REG_CTL);\r\ndo {\r\nif (!(readl(nfc->regs + NFC_REG_CTL) & NFC_RESET))\r\nreturn 0;\r\n} while (time_before(jiffies, timeout));\r\ndev_err(nfc->dev, "wait for NAND controller reset timedout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int sunxi_nfc_dev_ready(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand = mtd->priv;\r\nstruct sunxi_nand_chip *sunxi_nand = to_sunxi_nand(nand);\r\nstruct sunxi_nfc *nfc = to_sunxi_nfc(sunxi_nand->nand.controller);\r\nstruct sunxi_nand_rb *rb;\r\nunsigned long timeo = (sunxi_nand->nand.state == FL_ERASING ? 400 : 20);\r\nint ret;\r\nif (sunxi_nand->selected < 0)\r\nreturn 0;\r\nrb = &sunxi_nand->sels[sunxi_nand->selected].rb;\r\nswitch (rb->type) {\r\ncase RB_NATIVE:\r\nret = !!(readl(nfc->regs + NFC_REG_ST) &\r\n(NFC_RB_STATE0 << rb->info.nativeid));\r\nif (ret)\r\nbreak;\r\nsunxi_nfc_wait_int(nfc, NFC_RB_B2R, timeo);\r\nret = !!(readl(nfc->regs + NFC_REG_ST) &\r\n(NFC_RB_STATE0 << rb->info.nativeid));\r\nbreak;\r\ncase RB_GPIO:\r\nret = gpio_get_value(rb->info.gpio);\r\nbreak;\r\ncase RB_NONE:\r\ndefault:\r\nret = 0;\r\ndev_err(nfc->dev, "cannot check R/B NAND status!\n");\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void sunxi_nfc_select_chip(struct mtd_info *mtd, int chip)\r\n{\r\nstruct nand_chip *nand = mtd->priv;\r\nstruct sunxi_nand_chip *sunxi_nand = to_sunxi_nand(nand);\r\nstruct sunxi_nfc *nfc = to_sunxi_nfc(sunxi_nand->nand.controller);\r\nstruct sunxi_nand_chip_sel *sel;\r\nu32 ctl;\r\nif (chip > 0 && chip >= sunxi_nand->nsels)\r\nreturn;\r\nif (chip == sunxi_nand->selected)\r\nreturn;\r\nctl = readl(nfc->regs + NFC_REG_CTL) &\r\n~(NFC_CE_SEL | NFC_RB_SEL | NFC_EN);\r\nif (chip >= 0) {\r\nsel = &sunxi_nand->sels[chip];\r\nctl |= (sel->cs << 24) | NFC_EN |\r\n(((nand->page_shift - 10) & 0xf) << 8);\r\nif (sel->rb.type == RB_NONE) {\r\nnand->dev_ready = NULL;\r\n} else {\r\nnand->dev_ready = sunxi_nfc_dev_ready;\r\nif (sel->rb.type == RB_NATIVE)\r\nctl |= (sel->rb.info.nativeid << 3);\r\n}\r\nwritel(mtd->writesize, nfc->regs + NFC_REG_SPARE_AREA);\r\nif (nfc->clk_rate != sunxi_nand->clk_rate) {\r\nclk_set_rate(nfc->mod_clk, sunxi_nand->clk_rate);\r\nnfc->clk_rate = sunxi_nand->clk_rate;\r\n}\r\n}\r\nwritel(ctl, nfc->regs + NFC_REG_CTL);\r\nsunxi_nand->selected = chip;\r\n}\r\nstatic void sunxi_nfc_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)\r\n{\r\nstruct nand_chip *nand = mtd->priv;\r\nstruct sunxi_nand_chip *sunxi_nand = to_sunxi_nand(nand);\r\nstruct sunxi_nfc *nfc = to_sunxi_nfc(sunxi_nand->nand.controller);\r\nint ret;\r\nint cnt;\r\nint offs = 0;\r\nu32 tmp;\r\nwhile (len > offs) {\r\ncnt = min(len - offs, NFC_SRAM_SIZE);\r\nret = sunxi_nfc_wait_cmd_fifo_empty(nfc);\r\nif (ret)\r\nbreak;\r\nwritel(cnt, nfc->regs + NFC_REG_CNT);\r\ntmp = NFC_DATA_TRANS | NFC_DATA_SWAP_METHOD;\r\nwritel(tmp, nfc->regs + NFC_REG_CMD);\r\nret = sunxi_nfc_wait_int(nfc, NFC_CMD_INT_FLAG, 0);\r\nif (ret)\r\nbreak;\r\nif (buf)\r\nmemcpy_fromio(buf + offs, nfc->regs + NFC_RAM0_BASE,\r\ncnt);\r\noffs += cnt;\r\n}\r\n}\r\nstatic void sunxi_nfc_write_buf(struct mtd_info *mtd, const uint8_t *buf,\r\nint len)\r\n{\r\nstruct nand_chip *nand = mtd->priv;\r\nstruct sunxi_nand_chip *sunxi_nand = to_sunxi_nand(nand);\r\nstruct sunxi_nfc *nfc = to_sunxi_nfc(sunxi_nand->nand.controller);\r\nint ret;\r\nint cnt;\r\nint offs = 0;\r\nu32 tmp;\r\nwhile (len > offs) {\r\ncnt = min(len - offs, NFC_SRAM_SIZE);\r\nret = sunxi_nfc_wait_cmd_fifo_empty(nfc);\r\nif (ret)\r\nbreak;\r\nwritel(cnt, nfc->regs + NFC_REG_CNT);\r\nmemcpy_toio(nfc->regs + NFC_RAM0_BASE, buf + offs, cnt);\r\ntmp = NFC_DATA_TRANS | NFC_DATA_SWAP_METHOD |\r\nNFC_ACCESS_DIR;\r\nwritel(tmp, nfc->regs + NFC_REG_CMD);\r\nret = sunxi_nfc_wait_int(nfc, NFC_CMD_INT_FLAG, 0);\r\nif (ret)\r\nbreak;\r\noffs += cnt;\r\n}\r\n}\r\nstatic uint8_t sunxi_nfc_read_byte(struct mtd_info *mtd)\r\n{\r\nuint8_t ret;\r\nsunxi_nfc_read_buf(mtd, &ret, 1);\r\nreturn ret;\r\n}\r\nstatic void sunxi_nfc_cmd_ctrl(struct mtd_info *mtd, int dat,\r\nunsigned int ctrl)\r\n{\r\nstruct nand_chip *nand = mtd->priv;\r\nstruct sunxi_nand_chip *sunxi_nand = to_sunxi_nand(nand);\r\nstruct sunxi_nfc *nfc = to_sunxi_nfc(sunxi_nand->nand.controller);\r\nint ret;\r\nu32 tmp;\r\nret = sunxi_nfc_wait_cmd_fifo_empty(nfc);\r\nif (ret)\r\nreturn;\r\nif (ctrl & NAND_CTRL_CHANGE) {\r\ntmp = readl(nfc->regs + NFC_REG_CTL);\r\nif (ctrl & NAND_NCE)\r\ntmp |= NFC_CE_CTL;\r\nelse\r\ntmp &= ~NFC_CE_CTL;\r\nwritel(tmp, nfc->regs + NFC_REG_CTL);\r\n}\r\nif (dat == NAND_CMD_NONE)\r\nreturn;\r\nif (ctrl & NAND_CLE) {\r\nwritel(NFC_SEND_CMD1 | dat, nfc->regs + NFC_REG_CMD);\r\n} else {\r\nwritel(dat, nfc->regs + NFC_REG_ADDR_LOW);\r\nwritel(NFC_SEND_ADR, nfc->regs + NFC_REG_CMD);\r\n}\r\nsunxi_nfc_wait_int(nfc, NFC_CMD_INT_FLAG, 0);\r\n}\r\nstatic int sunxi_nfc_hw_ecc_read_page(struct mtd_info *mtd,\r\nstruct nand_chip *chip, uint8_t *buf,\r\nint oob_required, int page)\r\n{\r\nstruct sunxi_nfc *nfc = to_sunxi_nfc(chip->controller);\r\nstruct nand_ecc_ctrl *ecc = &chip->ecc;\r\nstruct nand_ecclayout *layout = ecc->layout;\r\nstruct sunxi_nand_hw_ecc *data = ecc->priv;\r\nunsigned int max_bitflips = 0;\r\nint offset;\r\nint ret;\r\nu32 tmp;\r\nint i;\r\nint cnt;\r\ntmp = readl(nfc->regs + NFC_REG_ECC_CTL);\r\ntmp &= ~(NFC_ECC_MODE | NFC_ECC_PIPELINE | NFC_ECC_BLOCK_SIZE);\r\ntmp |= NFC_ECC_EN | (data->mode << NFC_ECC_MODE_SHIFT) |\r\nNFC_ECC_EXCEPTION;\r\nwritel(tmp, nfc->regs + NFC_REG_ECC_CTL);\r\nfor (i = 0; i < ecc->steps; i++) {\r\nif (i)\r\nchip->cmdfunc(mtd, NAND_CMD_RNDOUT, i * ecc->size, -1);\r\noffset = mtd->writesize + layout->eccpos[i * ecc->bytes] - 4;\r\nchip->read_buf(mtd, NULL, ecc->size);\r\nchip->cmdfunc(mtd, NAND_CMD_RNDOUT, offset, -1);\r\nret = sunxi_nfc_wait_cmd_fifo_empty(nfc);\r\nif (ret)\r\nreturn ret;\r\ntmp = NFC_DATA_TRANS | NFC_DATA_SWAP_METHOD | (1 << 30);\r\nwritel(tmp, nfc->regs + NFC_REG_CMD);\r\nret = sunxi_nfc_wait_int(nfc, NFC_CMD_INT_FLAG, 0);\r\nif (ret)\r\nreturn ret;\r\nmemcpy_fromio(buf + (i * ecc->size),\r\nnfc->regs + NFC_RAM0_BASE, ecc->size);\r\nif (readl(nfc->regs + NFC_REG_ECC_ST) & 0x1) {\r\nmtd->ecc_stats.failed++;\r\n} else {\r\ntmp = readl(nfc->regs + NFC_REG_ECC_CNT0) & 0xff;\r\nmtd->ecc_stats.corrected += tmp;\r\nmax_bitflips = max_t(unsigned int, max_bitflips, tmp);\r\n}\r\nif (oob_required) {\r\nchip->cmdfunc(mtd, NAND_CMD_RNDOUT, offset, -1);\r\nret = sunxi_nfc_wait_cmd_fifo_empty(nfc);\r\nif (ret)\r\nreturn ret;\r\noffset -= mtd->writesize;\r\nchip->read_buf(mtd, chip->oob_poi + offset,\r\necc->bytes + 4);\r\n}\r\n}\r\nif (oob_required) {\r\ncnt = ecc->layout->oobfree[ecc->steps].length;\r\nif (cnt > 0) {\r\noffset = mtd->writesize +\r\necc->layout->oobfree[ecc->steps].offset;\r\nchip->cmdfunc(mtd, NAND_CMD_RNDOUT, offset, -1);\r\noffset -= mtd->writesize;\r\nchip->read_buf(mtd, chip->oob_poi + offset, cnt);\r\n}\r\n}\r\ntmp = readl(nfc->regs + NFC_REG_ECC_CTL);\r\ntmp &= ~NFC_ECC_EN;\r\nwritel(tmp, nfc->regs + NFC_REG_ECC_CTL);\r\nreturn max_bitflips;\r\n}\r\nstatic int sunxi_nfc_hw_ecc_write_page(struct mtd_info *mtd,\r\nstruct nand_chip *chip,\r\nconst uint8_t *buf, int oob_required)\r\n{\r\nstruct sunxi_nfc *nfc = to_sunxi_nfc(chip->controller);\r\nstruct nand_ecc_ctrl *ecc = &chip->ecc;\r\nstruct nand_ecclayout *layout = ecc->layout;\r\nstruct sunxi_nand_hw_ecc *data = ecc->priv;\r\nint offset;\r\nint ret;\r\nu32 tmp;\r\nint i;\r\nint cnt;\r\ntmp = readl(nfc->regs + NFC_REG_ECC_CTL);\r\ntmp &= ~(NFC_ECC_MODE | NFC_ECC_PIPELINE | NFC_ECC_BLOCK_SIZE);\r\ntmp |= NFC_ECC_EN | (data->mode << NFC_ECC_MODE_SHIFT) |\r\nNFC_ECC_EXCEPTION;\r\nwritel(tmp, nfc->regs + NFC_REG_ECC_CTL);\r\nfor (i = 0; i < ecc->steps; i++) {\r\nif (i)\r\nchip->cmdfunc(mtd, NAND_CMD_RNDIN, i * ecc->size, -1);\r\nchip->write_buf(mtd, buf + (i * ecc->size), ecc->size);\r\noffset = layout->eccpos[i * ecc->bytes] - 4 + mtd->writesize;\r\nif (oob_required) {\r\ntmp = 0xffffffff;\r\nmemcpy_toio(nfc->regs + NFC_REG_USER_DATA_BASE, &tmp,\r\n4);\r\n} else {\r\nmemcpy_toio(nfc->regs + NFC_REG_USER_DATA_BASE,\r\nchip->oob_poi + offset - mtd->writesize,\r\n4);\r\n}\r\nchip->cmdfunc(mtd, NAND_CMD_RNDIN, offset, -1);\r\nret = sunxi_nfc_wait_cmd_fifo_empty(nfc);\r\nif (ret)\r\nreturn ret;\r\ntmp = NFC_DATA_TRANS | NFC_DATA_SWAP_METHOD | NFC_ACCESS_DIR |\r\n(1 << 30);\r\nwritel(tmp, nfc->regs + NFC_REG_CMD);\r\nret = sunxi_nfc_wait_int(nfc, NFC_CMD_INT_FLAG, 0);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (oob_required) {\r\ncnt = ecc->layout->oobfree[i].length;\r\nif (cnt > 0) {\r\noffset = mtd->writesize +\r\necc->layout->oobfree[i].offset;\r\nchip->cmdfunc(mtd, NAND_CMD_RNDIN, offset, -1);\r\noffset -= mtd->writesize;\r\nchip->write_buf(mtd, chip->oob_poi + offset, cnt);\r\n}\r\n}\r\ntmp = readl(nfc->regs + NFC_REG_ECC_CTL);\r\ntmp &= ~NFC_ECC_EN;\r\nwritel(tmp, nfc->regs + NFC_REG_ECC_CTL);\r\nreturn 0;\r\n}\r\nstatic int sunxi_nfc_hw_syndrome_ecc_read_page(struct mtd_info *mtd,\r\nstruct nand_chip *chip,\r\nuint8_t *buf, int oob_required,\r\nint page)\r\n{\r\nstruct sunxi_nfc *nfc = to_sunxi_nfc(chip->controller);\r\nstruct nand_ecc_ctrl *ecc = &chip->ecc;\r\nstruct sunxi_nand_hw_ecc *data = ecc->priv;\r\nunsigned int max_bitflips = 0;\r\nuint8_t *oob = chip->oob_poi;\r\nint offset = 0;\r\nint ret;\r\nint cnt;\r\nu32 tmp;\r\nint i;\r\ntmp = readl(nfc->regs + NFC_REG_ECC_CTL);\r\ntmp &= ~(NFC_ECC_MODE | NFC_ECC_PIPELINE | NFC_ECC_BLOCK_SIZE);\r\ntmp |= NFC_ECC_EN | (data->mode << NFC_ECC_MODE_SHIFT) |\r\nNFC_ECC_EXCEPTION;\r\nwritel(tmp, nfc->regs + NFC_REG_ECC_CTL);\r\nfor (i = 0; i < ecc->steps; i++) {\r\nchip->read_buf(mtd, NULL, ecc->size);\r\ntmp = NFC_DATA_TRANS | NFC_DATA_SWAP_METHOD | (1 << 30);\r\nwritel(tmp, nfc->regs + NFC_REG_CMD);\r\nret = sunxi_nfc_wait_int(nfc, NFC_CMD_INT_FLAG, 0);\r\nif (ret)\r\nreturn ret;\r\nmemcpy_fromio(buf, nfc->regs + NFC_RAM0_BASE, ecc->size);\r\nbuf += ecc->size;\r\noffset += ecc->size;\r\nif (readl(nfc->regs + NFC_REG_ECC_ST) & 0x1) {\r\nmtd->ecc_stats.failed++;\r\n} else {\r\ntmp = readl(nfc->regs + NFC_REG_ECC_CNT0) & 0xff;\r\nmtd->ecc_stats.corrected += tmp;\r\nmax_bitflips = max_t(unsigned int, max_bitflips, tmp);\r\n}\r\nif (oob_required) {\r\nchip->cmdfunc(mtd, NAND_CMD_RNDOUT, offset, -1);\r\nchip->read_buf(mtd, oob, ecc->bytes + ecc->prepad);\r\noob += ecc->bytes + ecc->prepad;\r\n}\r\noffset += ecc->bytes + ecc->prepad;\r\n}\r\nif (oob_required) {\r\ncnt = mtd->oobsize - (oob - chip->oob_poi);\r\nif (cnt > 0) {\r\nchip->cmdfunc(mtd, NAND_CMD_RNDOUT, offset, -1);\r\nchip->read_buf(mtd, oob, cnt);\r\n}\r\n}\r\nwritel(readl(nfc->regs + NFC_REG_ECC_CTL) & ~NFC_ECC_EN,\r\nnfc->regs + NFC_REG_ECC_CTL);\r\nreturn max_bitflips;\r\n}\r\nstatic int sunxi_nfc_hw_syndrome_ecc_write_page(struct mtd_info *mtd,\r\nstruct nand_chip *chip,\r\nconst uint8_t *buf,\r\nint oob_required)\r\n{\r\nstruct sunxi_nfc *nfc = to_sunxi_nfc(chip->controller);\r\nstruct nand_ecc_ctrl *ecc = &chip->ecc;\r\nstruct sunxi_nand_hw_ecc *data = ecc->priv;\r\nuint8_t *oob = chip->oob_poi;\r\nint offset = 0;\r\nint ret;\r\nint cnt;\r\nu32 tmp;\r\nint i;\r\ntmp = readl(nfc->regs + NFC_REG_ECC_CTL);\r\ntmp &= ~(NFC_ECC_MODE | NFC_ECC_PIPELINE | NFC_ECC_BLOCK_SIZE);\r\ntmp |= NFC_ECC_EN | (data->mode << NFC_ECC_MODE_SHIFT) |\r\nNFC_ECC_EXCEPTION;\r\nwritel(tmp, nfc->regs + NFC_REG_ECC_CTL);\r\nfor (i = 0; i < ecc->steps; i++) {\r\nchip->write_buf(mtd, buf + (i * ecc->size), ecc->size);\r\noffset += ecc->size;\r\nif (oob_required) {\r\ntmp = 0xffffffff;\r\nmemcpy_toio(nfc->regs + NFC_REG_USER_DATA_BASE, &tmp,\r\n4);\r\n} else {\r\nmemcpy_toio(nfc->regs + NFC_REG_USER_DATA_BASE, oob,\r\n4);\r\n}\r\ntmp = NFC_DATA_TRANS | NFC_DATA_SWAP_METHOD | NFC_ACCESS_DIR |\r\n(1 << 30);\r\nwritel(tmp, nfc->regs + NFC_REG_CMD);\r\nret = sunxi_nfc_wait_int(nfc, NFC_CMD_INT_FLAG, 0);\r\nif (ret)\r\nreturn ret;\r\noffset += ecc->bytes + ecc->prepad;\r\noob += ecc->bytes + ecc->prepad;\r\n}\r\nif (oob_required) {\r\ncnt = mtd->oobsize - (oob - chip->oob_poi);\r\nif (cnt > 0) {\r\nchip->cmdfunc(mtd, NAND_CMD_RNDIN, offset, -1);\r\nchip->write_buf(mtd, oob, cnt);\r\n}\r\n}\r\ntmp = readl(nfc->regs + NFC_REG_ECC_CTL);\r\ntmp &= ~NFC_ECC_EN;\r\nwritel(tmp, nfc->regs + NFC_REG_ECC_CTL);\r\nreturn 0;\r\n}\r\nstatic int sunxi_nand_chip_set_timings(struct sunxi_nand_chip *chip,\r\nconst struct nand_sdr_timings *timings)\r\n{\r\nu32 min_clk_period = 0;\r\nif (timings->tCLS_min > min_clk_period)\r\nmin_clk_period = timings->tCLS_min;\r\nif (timings->tCLH_min > min_clk_period)\r\nmin_clk_period = timings->tCLH_min;\r\nif (timings->tCS_min > min_clk_period)\r\nmin_clk_period = timings->tCS_min;\r\nif (timings->tCH_min > min_clk_period)\r\nmin_clk_period = timings->tCH_min;\r\nif (timings->tWP_min > min_clk_period)\r\nmin_clk_period = timings->tWP_min;\r\nif (timings->tWH_min > min_clk_period)\r\nmin_clk_period = timings->tWH_min;\r\nif (timings->tALS_min > min_clk_period)\r\nmin_clk_period = timings->tALS_min;\r\nif (timings->tDS_min > min_clk_period)\r\nmin_clk_period = timings->tDS_min;\r\nif (timings->tDH_min > min_clk_period)\r\nmin_clk_period = timings->tDH_min;\r\nif (timings->tRR_min > (min_clk_period * 3))\r\nmin_clk_period = DIV_ROUND_UP(timings->tRR_min, 3);\r\nif (timings->tALH_min > min_clk_period)\r\nmin_clk_period = timings->tALH_min;\r\nif (timings->tRP_min > min_clk_period)\r\nmin_clk_period = timings->tRP_min;\r\nif (timings->tREH_min > min_clk_period)\r\nmin_clk_period = timings->tREH_min;\r\nif (timings->tRC_min > (min_clk_period * 2))\r\nmin_clk_period = DIV_ROUND_UP(timings->tRC_min, 2);\r\nif (timings->tWC_min > (min_clk_period * 2))\r\nmin_clk_period = DIV_ROUND_UP(timings->tWC_min, 2);\r\nmin_clk_period = DIV_ROUND_UP(min_clk_period, 1000);\r\nchip->clk_rate = (2 * NSEC_PER_SEC) / min_clk_period;\r\nreturn 0;\r\n}\r\nstatic int sunxi_nand_chip_init_timings(struct sunxi_nand_chip *chip,\r\nstruct device_node *np)\r\n{\r\nconst struct nand_sdr_timings *timings;\r\nint ret;\r\nint mode;\r\nmode = onfi_get_async_timing_mode(&chip->nand);\r\nif (mode == ONFI_TIMING_MODE_UNKNOWN) {\r\nmode = chip->nand.onfi_timing_mode_default;\r\n} else {\r\nuint8_t feature[ONFI_SUBFEATURE_PARAM_LEN] = {};\r\nmode = fls(mode) - 1;\r\nif (mode < 0)\r\nmode = 0;\r\nfeature[0] = mode;\r\nret = chip->nand.onfi_set_features(&chip->mtd, &chip->nand,\r\nONFI_FEATURE_ADDR_TIMING_MODE,\r\nfeature);\r\nif (ret)\r\nreturn ret;\r\n}\r\ntimings = onfi_async_timing_mode_to_sdr_timings(mode);\r\nif (IS_ERR(timings))\r\nreturn PTR_ERR(timings);\r\nreturn sunxi_nand_chip_set_timings(chip, timings);\r\n}\r\nstatic int sunxi_nand_hw_common_ecc_ctrl_init(struct mtd_info *mtd,\r\nstruct nand_ecc_ctrl *ecc,\r\nstruct device_node *np)\r\n{\r\nstatic const u8 strengths[] = { 16, 24, 28, 32, 40, 48, 56, 60, 64 };\r\nstruct nand_chip *nand = mtd->priv;\r\nstruct sunxi_nand_chip *sunxi_nand = to_sunxi_nand(nand);\r\nstruct sunxi_nfc *nfc = to_sunxi_nfc(sunxi_nand->nand.controller);\r\nstruct sunxi_nand_hw_ecc *data;\r\nstruct nand_ecclayout *layout;\r\nint nsectors;\r\nint ret;\r\nint i;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ARRAY_SIZE(strengths); i++) {\r\nif (ecc->strength <= strengths[i])\r\nbreak;\r\n}\r\nif (i >= ARRAY_SIZE(strengths)) {\r\ndev_err(nfc->dev, "unsupported strength\n");\r\nret = -ENOTSUPP;\r\ngoto err;\r\n}\r\ndata->mode = i;\r\necc->bytes = DIV_ROUND_UP(ecc->strength * fls(8 * 1024), 8);\r\necc->bytes = ALIGN(ecc->bytes, 2);\r\nlayout = &data->layout;\r\nnsectors = mtd->writesize / ecc->size;\r\nif (mtd->oobsize < ((ecc->bytes + 4) * nsectors)) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nlayout->eccbytes = (ecc->bytes * nsectors);\r\necc->layout = layout;\r\necc->priv = data;\r\nreturn 0;\r\nerr:\r\nkfree(data);\r\nreturn ret;\r\n}\r\nstatic void sunxi_nand_hw_common_ecc_ctrl_cleanup(struct nand_ecc_ctrl *ecc)\r\n{\r\nkfree(ecc->priv);\r\n}\r\nstatic int sunxi_nand_hw_ecc_ctrl_init(struct mtd_info *mtd,\r\nstruct nand_ecc_ctrl *ecc,\r\nstruct device_node *np)\r\n{\r\nstruct nand_ecclayout *layout;\r\nint nsectors;\r\nint i, j;\r\nint ret;\r\nret = sunxi_nand_hw_common_ecc_ctrl_init(mtd, ecc, np);\r\nif (ret)\r\nreturn ret;\r\necc->read_page = sunxi_nfc_hw_ecc_read_page;\r\necc->write_page = sunxi_nfc_hw_ecc_write_page;\r\nlayout = ecc->layout;\r\nnsectors = mtd->writesize / ecc->size;\r\nfor (i = 0; i < nsectors; i++) {\r\nif (i) {\r\nlayout->oobfree[i].offset =\r\nlayout->oobfree[i - 1].offset +\r\nlayout->oobfree[i - 1].length +\r\necc->bytes;\r\nlayout->oobfree[i].length = 4;\r\n} else {\r\nlayout->oobfree[i].length = 2;\r\nlayout->oobfree[i].offset = 2;\r\n}\r\nfor (j = 0; j < ecc->bytes; j++)\r\nlayout->eccpos[(ecc->bytes * i) + j] =\r\nlayout->oobfree[i].offset +\r\nlayout->oobfree[i].length + j;\r\n}\r\nif (mtd->oobsize > (ecc->bytes + 4) * nsectors) {\r\nlayout->oobfree[nsectors].offset =\r\nlayout->oobfree[nsectors - 1].offset +\r\nlayout->oobfree[nsectors - 1].length +\r\necc->bytes;\r\nlayout->oobfree[nsectors].length = mtd->oobsize -\r\n((ecc->bytes + 4) * nsectors);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sunxi_nand_hw_syndrome_ecc_ctrl_init(struct mtd_info *mtd,\r\nstruct nand_ecc_ctrl *ecc,\r\nstruct device_node *np)\r\n{\r\nstruct nand_ecclayout *layout;\r\nint nsectors;\r\nint i;\r\nint ret;\r\nret = sunxi_nand_hw_common_ecc_ctrl_init(mtd, ecc, np);\r\nif (ret)\r\nreturn ret;\r\necc->prepad = 4;\r\necc->read_page = sunxi_nfc_hw_syndrome_ecc_read_page;\r\necc->write_page = sunxi_nfc_hw_syndrome_ecc_write_page;\r\nlayout = ecc->layout;\r\nnsectors = mtd->writesize / ecc->size;\r\nfor (i = 0; i < (ecc->bytes * nsectors); i++)\r\nlayout->eccpos[i] = i;\r\nlayout->oobfree[0].length = mtd->oobsize - i;\r\nlayout->oobfree[0].offset = i;\r\nreturn 0;\r\n}\r\nstatic void sunxi_nand_ecc_cleanup(struct nand_ecc_ctrl *ecc)\r\n{\r\nswitch (ecc->mode) {\r\ncase NAND_ECC_HW:\r\ncase NAND_ECC_HW_SYNDROME:\r\nsunxi_nand_hw_common_ecc_ctrl_cleanup(ecc);\r\nbreak;\r\ncase NAND_ECC_NONE:\r\nkfree(ecc->layout);\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int sunxi_nand_ecc_init(struct mtd_info *mtd, struct nand_ecc_ctrl *ecc,\r\nstruct device_node *np)\r\n{\r\nstruct nand_chip *nand = mtd->priv;\r\nint strength;\r\nint blk_size;\r\nint ret;\r\nblk_size = of_get_nand_ecc_step_size(np);\r\nstrength = of_get_nand_ecc_strength(np);\r\nif (blk_size > 0 && strength > 0) {\r\necc->size = blk_size;\r\necc->strength = strength;\r\n} else {\r\necc->size = nand->ecc_step_ds;\r\necc->strength = nand->ecc_strength_ds;\r\n}\r\nif (!ecc->size || !ecc->strength)\r\nreturn -EINVAL;\r\necc->mode = NAND_ECC_HW;\r\nret = of_get_nand_ecc_mode(np);\r\nif (ret >= 0)\r\necc->mode = ret;\r\nswitch (ecc->mode) {\r\ncase NAND_ECC_SOFT_BCH:\r\nbreak;\r\ncase NAND_ECC_HW:\r\nret = sunxi_nand_hw_ecc_ctrl_init(mtd, ecc, np);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase NAND_ECC_HW_SYNDROME:\r\nret = sunxi_nand_hw_syndrome_ecc_ctrl_init(mtd, ecc, np);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase NAND_ECC_NONE:\r\necc->layout = kzalloc(sizeof(*ecc->layout), GFP_KERNEL);\r\nif (!ecc->layout)\r\nreturn -ENOMEM;\r\necc->layout->oobfree[0].length = mtd->oobsize;\r\ncase NAND_ECC_SOFT:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sunxi_nand_chip_init(struct device *dev, struct sunxi_nfc *nfc,\r\nstruct device_node *np)\r\n{\r\nconst struct nand_sdr_timings *timings;\r\nstruct sunxi_nand_chip *chip;\r\nstruct mtd_part_parser_data ppdata;\r\nstruct mtd_info *mtd;\r\nstruct nand_chip *nand;\r\nint nsels;\r\nint ret;\r\nint i;\r\nu32 tmp;\r\nif (!of_get_property(np, "reg", &nsels))\r\nreturn -EINVAL;\r\nnsels /= sizeof(u32);\r\nif (!nsels) {\r\ndev_err(dev, "invalid reg property size\n");\r\nreturn -EINVAL;\r\n}\r\nchip = devm_kzalloc(dev,\r\nsizeof(*chip) +\r\n(nsels * sizeof(struct sunxi_nand_chip_sel)),\r\nGFP_KERNEL);\r\nif (!chip) {\r\ndev_err(dev, "could not allocate chip\n");\r\nreturn -ENOMEM;\r\n}\r\nchip->nsels = nsels;\r\nchip->selected = -1;\r\nfor (i = 0; i < nsels; i++) {\r\nret = of_property_read_u32_index(np, "reg", i, &tmp);\r\nif (ret) {\r\ndev_err(dev, "could not retrieve reg property: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nif (tmp > NFC_MAX_CS) {\r\ndev_err(dev,\r\n"invalid reg value: %u (max CS = 7)\n",\r\ntmp);\r\nreturn -EINVAL;\r\n}\r\nif (test_and_set_bit(tmp, &nfc->assigned_cs)) {\r\ndev_err(dev, "CS %d already assigned\n", tmp);\r\nreturn -EINVAL;\r\n}\r\nchip->sels[i].cs = tmp;\r\nif (!of_property_read_u32_index(np, "allwinner,rb", i, &tmp) &&\r\ntmp < 2) {\r\nchip->sels[i].rb.type = RB_NATIVE;\r\nchip->sels[i].rb.info.nativeid = tmp;\r\n} else {\r\nret = of_get_named_gpio(np, "rb-gpios", i);\r\nif (ret >= 0) {\r\ntmp = ret;\r\nchip->sels[i].rb.type = RB_GPIO;\r\nchip->sels[i].rb.info.gpio = tmp;\r\nret = devm_gpio_request(dev, tmp, "nand-rb");\r\nif (ret)\r\nreturn ret;\r\nret = gpio_direction_input(tmp);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nchip->sels[i].rb.type = RB_NONE;\r\n}\r\n}\r\n}\r\ntimings = onfi_async_timing_mode_to_sdr_timings(0);\r\nif (IS_ERR(timings)) {\r\nret = PTR_ERR(timings);\r\ndev_err(dev,\r\n"could not retrieve timings for ONFI mode 0: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = sunxi_nand_chip_set_timings(chip, timings);\r\nif (ret) {\r\ndev_err(dev, "could not configure chip timings: %d\n", ret);\r\nreturn ret;\r\n}\r\nnand = &chip->nand;\r\nnand->chip_delay = 200;\r\nnand->controller = &nfc->controller;\r\nnand->select_chip = sunxi_nfc_select_chip;\r\nnand->cmd_ctrl = sunxi_nfc_cmd_ctrl;\r\nnand->read_buf = sunxi_nfc_read_buf;\r\nnand->write_buf = sunxi_nfc_write_buf;\r\nnand->read_byte = sunxi_nfc_read_byte;\r\nif (of_get_nand_on_flash_bbt(np))\r\nnand->bbt_options |= NAND_BBT_USE_FLASH | NAND_BBT_NO_OOB;\r\nmtd = &chip->mtd;\r\nmtd->dev.parent = dev;\r\nmtd->priv = nand;\r\nmtd->owner = THIS_MODULE;\r\nret = nand_scan_ident(mtd, nsels, NULL);\r\nif (ret)\r\nreturn ret;\r\nret = sunxi_nand_chip_init_timings(chip, np);\r\nif (ret) {\r\ndev_err(dev, "could not configure chip timings: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = sunxi_nand_ecc_init(mtd, &nand->ecc, np);\r\nif (ret) {\r\ndev_err(dev, "ECC init failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = nand_scan_tail(mtd);\r\nif (ret) {\r\ndev_err(dev, "nand_scan_tail failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nppdata.of_node = np;\r\nret = mtd_device_parse_register(mtd, NULL, &ppdata, NULL, 0);\r\nif (ret) {\r\ndev_err(dev, "failed to register mtd device: %d\n", ret);\r\nnand_release(mtd);\r\nreturn ret;\r\n}\r\nlist_add_tail(&chip->node, &nfc->chips);\r\nreturn 0;\r\n}\r\nstatic int sunxi_nand_chips_init(struct device *dev, struct sunxi_nfc *nfc)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nstruct device_node *nand_np;\r\nint nchips = of_get_child_count(np);\r\nint ret;\r\nif (nchips > 8) {\r\ndev_err(dev, "too many NAND chips: %d (max = 8)\n", nchips);\r\nreturn -EINVAL;\r\n}\r\nfor_each_child_of_node(np, nand_np) {\r\nret = sunxi_nand_chip_init(dev, nfc, nand_np);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sunxi_nand_chips_cleanup(struct sunxi_nfc *nfc)\r\n{\r\nstruct sunxi_nand_chip *chip;\r\nwhile (!list_empty(&nfc->chips)) {\r\nchip = list_first_entry(&nfc->chips, struct sunxi_nand_chip,\r\nnode);\r\nnand_release(&chip->mtd);\r\nsunxi_nand_ecc_cleanup(&chip->nand.ecc);\r\n}\r\n}\r\nstatic int sunxi_nfc_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *r;\r\nstruct sunxi_nfc *nfc;\r\nint irq;\r\nint ret;\r\nnfc = devm_kzalloc(dev, sizeof(*nfc), GFP_KERNEL);\r\nif (!nfc)\r\nreturn -ENOMEM;\r\nnfc->dev = dev;\r\nspin_lock_init(&nfc->controller.lock);\r\ninit_waitqueue_head(&nfc->controller.wq);\r\nINIT_LIST_HEAD(&nfc->chips);\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nnfc->regs = devm_ioremap_resource(dev, r);\r\nif (IS_ERR(nfc->regs))\r\nreturn PTR_ERR(nfc->regs);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(dev, "failed to retrieve irq\n");\r\nreturn irq;\r\n}\r\nnfc->ahb_clk = devm_clk_get(dev, "ahb");\r\nif (IS_ERR(nfc->ahb_clk)) {\r\ndev_err(dev, "failed to retrieve ahb clk\n");\r\nreturn PTR_ERR(nfc->ahb_clk);\r\n}\r\nret = clk_prepare_enable(nfc->ahb_clk);\r\nif (ret)\r\nreturn ret;\r\nnfc->mod_clk = devm_clk_get(dev, "mod");\r\nif (IS_ERR(nfc->mod_clk)) {\r\ndev_err(dev, "failed to retrieve mod clk\n");\r\nret = PTR_ERR(nfc->mod_clk);\r\ngoto out_ahb_clk_unprepare;\r\n}\r\nret = clk_prepare_enable(nfc->mod_clk);\r\nif (ret)\r\ngoto out_ahb_clk_unprepare;\r\nret = sunxi_nfc_rst(nfc);\r\nif (ret)\r\ngoto out_mod_clk_unprepare;\r\nwritel(0, nfc->regs + NFC_REG_INT);\r\nret = devm_request_irq(dev, irq, sunxi_nfc_interrupt,\r\n0, "sunxi-nand", nfc);\r\nif (ret)\r\ngoto out_mod_clk_unprepare;\r\nplatform_set_drvdata(pdev, nfc);\r\nwritel(0x100, nfc->regs + NFC_REG_TIMING_CTL);\r\nwritel(0x7ff, nfc->regs + NFC_REG_TIMING_CFG);\r\nret = sunxi_nand_chips_init(dev, nfc);\r\nif (ret) {\r\ndev_err(dev, "failed to init nand chips\n");\r\ngoto out_mod_clk_unprepare;\r\n}\r\nreturn 0;\r\nout_mod_clk_unprepare:\r\nclk_disable_unprepare(nfc->mod_clk);\r\nout_ahb_clk_unprepare:\r\nclk_disable_unprepare(nfc->ahb_clk);\r\nreturn ret;\r\n}\r\nstatic int sunxi_nfc_remove(struct platform_device *pdev)\r\n{\r\nstruct sunxi_nfc *nfc = platform_get_drvdata(pdev);\r\nsunxi_nand_chips_cleanup(nfc);\r\nreturn 0;\r\n}
