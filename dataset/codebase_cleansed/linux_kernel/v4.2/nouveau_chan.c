int\r\nnouveau_channel_idle(struct nouveau_channel *chan)\r\n{\r\nstruct nouveau_cli *cli = (void *)nvif_client(chan->object);\r\nstruct nouveau_fence *fence = NULL;\r\nint ret;\r\nret = nouveau_fence_new(chan, false, &fence);\r\nif (!ret) {\r\nret = nouveau_fence_wait(fence, false, false);\r\nnouveau_fence_unref(&fence);\r\n}\r\nif (ret)\r\nNV_PRINTK(error, cli, "failed to idle channel 0x%08x [%s]\n",\r\nchan->object->handle, nvxx_client(&cli->base)->name);\r\nreturn ret;\r\n}\r\nvoid\r\nnouveau_channel_del(struct nouveau_channel **pchan)\r\n{\r\nstruct nouveau_channel *chan = *pchan;\r\nif (chan) {\r\nif (chan->fence) {\r\nnouveau_channel_idle(chan);\r\nnouveau_fence(chan->drm)->context_del(chan);\r\n}\r\nnvif_object_fini(&chan->nvsw);\r\nnvif_object_fini(&chan->gart);\r\nnvif_object_fini(&chan->vram);\r\nnvif_object_ref(NULL, &chan->object);\r\nnvif_object_fini(&chan->push.ctxdma);\r\nnouveau_bo_vma_del(chan->push.buffer, &chan->push.vma);\r\nnouveau_bo_unmap(chan->push.buffer);\r\nif (chan->push.buffer && chan->push.buffer->pin_refcnt)\r\nnouveau_bo_unpin(chan->push.buffer);\r\nnouveau_bo_ref(NULL, &chan->push.buffer);\r\nnvif_device_ref(NULL, &chan->device);\r\nkfree(chan);\r\n}\r\n*pchan = NULL;\r\n}\r\nstatic int\r\nnouveau_channel_prep(struct nouveau_drm *drm, struct nvif_device *device,\r\nu32 handle, u32 size, struct nouveau_channel **pchan)\r\n{\r\nstruct nouveau_cli *cli = (void *)nvif_client(&device->base);\r\nstruct nvkm_mmu *mmu = nvxx_mmu(device);\r\nstruct nv_dma_v0 args = {};\r\nstruct nouveau_channel *chan;\r\nu32 target;\r\nint ret;\r\nchan = *pchan = kzalloc(sizeof(*chan), GFP_KERNEL);\r\nif (!chan)\r\nreturn -ENOMEM;\r\nnvif_device_ref(device, &chan->device);\r\nchan->drm = drm;\r\ntarget = TTM_PL_FLAG_TT | TTM_PL_FLAG_UNCACHED;\r\nif (nouveau_vram_pushbuf)\r\ntarget = TTM_PL_FLAG_VRAM;\r\nret = nouveau_bo_new(drm->dev, size, 0, target, 0, 0, NULL, NULL,\r\n&chan->push.buffer);\r\nif (ret == 0) {\r\nret = nouveau_bo_pin(chan->push.buffer, target, false);\r\nif (ret == 0)\r\nret = nouveau_bo_map(chan->push.buffer);\r\n}\r\nif (ret) {\r\nnouveau_channel_del(pchan);\r\nreturn ret;\r\n}\r\nchan->push.vma.offset = chan->push.buffer->bo.offset;\r\nif (device->info.family >= NV_DEVICE_INFO_V0_TESLA) {\r\nret = nouveau_bo_vma_add(chan->push.buffer, cli->vm,\r\n&chan->push.vma);\r\nif (ret) {\r\nnouveau_channel_del(pchan);\r\nreturn ret;\r\n}\r\nargs.target = NV_DMA_V0_TARGET_VM;\r\nargs.access = NV_DMA_V0_ACCESS_VM;\r\nargs.start = 0;\r\nargs.limit = cli->vm->mmu->limit - 1;\r\n} else\r\nif (chan->push.buffer->bo.mem.mem_type == TTM_PL_VRAM) {\r\nif (device->info.family == NV_DEVICE_INFO_V0_TNT) {\r\nargs.target = NV_DMA_V0_TARGET_PCI;\r\nargs.access = NV_DMA_V0_ACCESS_RDWR;\r\nargs.start = nv_device_resource_start(nvxx_device(device), 1);\r\nargs.limit = args.start + device->info.ram_user - 1;\r\n} else {\r\nargs.target = NV_DMA_V0_TARGET_VRAM;\r\nargs.access = NV_DMA_V0_ACCESS_RDWR;\r\nargs.start = 0;\r\nargs.limit = device->info.ram_user - 1;\r\n}\r\n} else {\r\nif (chan->drm->agp.stat == ENABLED) {\r\nargs.target = NV_DMA_V0_TARGET_AGP;\r\nargs.access = NV_DMA_V0_ACCESS_RDWR;\r\nargs.start = chan->drm->agp.base;\r\nargs.limit = chan->drm->agp.base +\r\nchan->drm->agp.size - 1;\r\n} else {\r\nargs.target = NV_DMA_V0_TARGET_VM;\r\nargs.access = NV_DMA_V0_ACCESS_RDWR;\r\nargs.start = 0;\r\nargs.limit = mmu->limit - 1;\r\n}\r\n}\r\nret = nvif_object_init(nvif_object(device), NULL, NVDRM_PUSH |\r\n(handle & 0xffff), NV_DMA_FROM_MEMORY,\r\n&args, sizeof(args), &chan->push.ctxdma);\r\nif (ret) {\r\nnouveau_channel_del(pchan);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnouveau_channel_ind(struct nouveau_drm *drm, struct nvif_device *device,\r\nu32 handle, u32 engine, struct nouveau_channel **pchan)\r\n{\r\nstatic const u16 oclasses[] = { MAXWELL_CHANNEL_GPFIFO_A,\r\nKEPLER_CHANNEL_GPFIFO_A,\r\nFERMI_CHANNEL_GPFIFO,\r\nG82_CHANNEL_GPFIFO,\r\nNV50_CHANNEL_GPFIFO,\r\n0 };\r\nconst u16 *oclass = oclasses;\r\nunion {\r\nstruct nv50_channel_gpfifo_v0 nv50;\r\nstruct kepler_channel_gpfifo_a_v0 kepler;\r\n} args, *retn;\r\nstruct nouveau_channel *chan;\r\nu32 size;\r\nint ret;\r\nret = nouveau_channel_prep(drm, device, handle, 0x12000, &chan);\r\n*pchan = chan;\r\nif (ret)\r\nreturn ret;\r\ndo {\r\nif (oclass[0] >= KEPLER_CHANNEL_GPFIFO_A) {\r\nargs.kepler.version = 0;\r\nargs.kepler.engine = engine;\r\nargs.kepler.pushbuf = chan->push.ctxdma.handle;\r\nargs.kepler.ilength = 0x02000;\r\nargs.kepler.ioffset = 0x10000 + chan->push.vma.offset;\r\nsize = sizeof(args.kepler);\r\n} else {\r\nargs.nv50.version = 0;\r\nargs.nv50.pushbuf = chan->push.ctxdma.handle;\r\nargs.nv50.ilength = 0x02000;\r\nargs.nv50.ioffset = 0x10000 + chan->push.vma.offset;\r\nsize = sizeof(args.nv50);\r\n}\r\nret = nvif_object_new(nvif_object(device), handle, *oclass++,\r\n&args, size, &chan->object);\r\nif (ret == 0) {\r\nretn = chan->object->data;\r\nif (chan->object->oclass >= KEPLER_CHANNEL_GPFIFO_A)\r\nchan->chid = retn->kepler.chid;\r\nelse\r\nchan->chid = retn->nv50.chid;\r\nreturn ret;\r\n}\r\n} while (*oclass);\r\nnouveau_channel_del(pchan);\r\nreturn ret;\r\n}\r\nstatic int\r\nnouveau_channel_dma(struct nouveau_drm *drm, struct nvif_device *device,\r\nu32 handle, struct nouveau_channel **pchan)\r\n{\r\nstatic const u16 oclasses[] = { NV40_CHANNEL_DMA,\r\nNV17_CHANNEL_DMA,\r\nNV10_CHANNEL_DMA,\r\nNV03_CHANNEL_DMA,\r\n0 };\r\nconst u16 *oclass = oclasses;\r\nstruct nv03_channel_dma_v0 args, *retn;\r\nstruct nouveau_channel *chan;\r\nint ret;\r\nret = nouveau_channel_prep(drm, device, handle, 0x10000, &chan);\r\n*pchan = chan;\r\nif (ret)\r\nreturn ret;\r\nargs.version = 0;\r\nargs.pushbuf = chan->push.ctxdma.handle;\r\nargs.offset = chan->push.vma.offset;\r\ndo {\r\nret = nvif_object_new(nvif_object(device), handle, *oclass++,\r\n&args, sizeof(args), &chan->object);\r\nif (ret == 0) {\r\nretn = chan->object->data;\r\nchan->chid = retn->chid;\r\nreturn ret;\r\n}\r\n} while (ret && *oclass);\r\nnouveau_channel_del(pchan);\r\nreturn ret;\r\n}\r\nstatic int\r\nnouveau_channel_init(struct nouveau_channel *chan, u32 vram, u32 gart)\r\n{\r\nstruct nvif_device *device = chan->device;\r\nstruct nouveau_cli *cli = (void *)nvif_client(&device->base);\r\nstruct nvkm_mmu *mmu = nvxx_mmu(device);\r\nstruct nvkm_sw_chan *swch;\r\nstruct nv_dma_v0 args = {};\r\nint ret, i;\r\nnvif_object_map(chan->object);\r\nif (device->info.family < NV_DEVICE_INFO_V0_FERMI) {\r\nif (device->info.family >= NV_DEVICE_INFO_V0_TESLA) {\r\nargs.target = NV_DMA_V0_TARGET_VM;\r\nargs.access = NV_DMA_V0_ACCESS_VM;\r\nargs.start = 0;\r\nargs.limit = cli->vm->mmu->limit - 1;\r\n} else {\r\nargs.target = NV_DMA_V0_TARGET_VRAM;\r\nargs.access = NV_DMA_V0_ACCESS_RDWR;\r\nargs.start = 0;\r\nargs.limit = device->info.ram_user - 1;\r\n}\r\nret = nvif_object_init(chan->object, NULL, vram,\r\nNV_DMA_IN_MEMORY, &args,\r\nsizeof(args), &chan->vram);\r\nif (ret)\r\nreturn ret;\r\nif (device->info.family >= NV_DEVICE_INFO_V0_TESLA) {\r\nargs.target = NV_DMA_V0_TARGET_VM;\r\nargs.access = NV_DMA_V0_ACCESS_VM;\r\nargs.start = 0;\r\nargs.limit = cli->vm->mmu->limit - 1;\r\n} else\r\nif (chan->drm->agp.stat == ENABLED) {\r\nargs.target = NV_DMA_V0_TARGET_AGP;\r\nargs.access = NV_DMA_V0_ACCESS_RDWR;\r\nargs.start = chan->drm->agp.base;\r\nargs.limit = chan->drm->agp.base +\r\nchan->drm->agp.size - 1;\r\n} else {\r\nargs.target = NV_DMA_V0_TARGET_VM;\r\nargs.access = NV_DMA_V0_ACCESS_RDWR;\r\nargs.start = 0;\r\nargs.limit = mmu->limit - 1;\r\n}\r\nret = nvif_object_init(chan->object, NULL, gart,\r\nNV_DMA_IN_MEMORY, &args,\r\nsizeof(args), &chan->gart);\r\nif (ret)\r\nreturn ret;\r\n}\r\nswitch (chan->object->oclass & 0x00ff) {\r\ncase 0x006b:\r\ncase 0x006e:\r\nchan->user_put = 0x40;\r\nchan->user_get = 0x44;\r\nchan->dma.max = (0x10000 / 4) - 2;\r\nbreak;\r\ndefault:\r\nchan->user_put = 0x40;\r\nchan->user_get = 0x44;\r\nchan->user_get_hi = 0x60;\r\nchan->dma.ib_base = 0x10000 / 4;\r\nchan->dma.ib_max = (0x02000 / 8) - 1;\r\nchan->dma.ib_put = 0;\r\nchan->dma.ib_free = chan->dma.ib_max - chan->dma.ib_put;\r\nchan->dma.max = chan->dma.ib_base;\r\nbreak;\r\n}\r\nchan->dma.put = 0;\r\nchan->dma.cur = chan->dma.put;\r\nchan->dma.free = chan->dma.max - chan->dma.cur;\r\nret = RING_SPACE(chan, NOUVEAU_DMA_SKIPS);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < NOUVEAU_DMA_SKIPS; i++)\r\nOUT_RING(chan, 0x00000000);\r\nif (device->info.family < NV_DEVICE_INFO_V0_CELSIUS) {\r\nret = nvif_object_init(chan->object, NULL, 0x006e, 0x006e,\r\nNULL, 0, &chan->nvsw);\r\nif (ret)\r\nreturn ret;\r\nswch = (void *)nvxx_object(&chan->nvsw)->parent;\r\nswch->flip = nouveau_flip_complete;\r\nswch->flip_data = chan;\r\nret = RING_SPACE(chan, 2);\r\nif (ret)\r\nreturn ret;\r\nBEGIN_NV04(chan, NvSubSw, 0x0000, 1);\r\nOUT_RING (chan, chan->nvsw.handle);\r\nFIRE_RING (chan);\r\n}\r\nreturn nouveau_fence(chan->drm)->context_new(chan);\r\n}\r\nint\r\nnouveau_channel_new(struct nouveau_drm *drm, struct nvif_device *device,\r\nu32 handle, u32 arg0, u32 arg1,\r\nstruct nouveau_channel **pchan)\r\n{\r\nstruct nouveau_cli *cli = (void *)nvif_client(&device->base);\r\nbool super;\r\nint ret;\r\nsuper = cli->base.super;\r\ncli->base.super = true;\r\nret = nouveau_channel_ind(drm, device, handle, arg0, pchan);\r\nif (ret) {\r\nNV_PRINTK(debug, cli, "ib channel create, %d\n", ret);\r\nret = nouveau_channel_dma(drm, device, handle, pchan);\r\nif (ret) {\r\nNV_PRINTK(debug, cli, "dma channel create, %d\n", ret);\r\ngoto done;\r\n}\r\n}\r\nret = nouveau_channel_init(*pchan, arg0, arg1);\r\nif (ret) {\r\nNV_PRINTK(error, cli, "channel failed to initialise, %d\n", ret);\r\nnouveau_channel_del(pchan);\r\n}\r\ndone:\r\ncli->base.super = super;\r\nreturn ret;\r\n}
