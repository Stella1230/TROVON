static int init_hw(struct echoaudio *chip, u16 device_id, u16 subdevice_id)\r\n{\r\nint err;\r\nif (snd_BUG_ON((subdevice_id & 0xfff0) != GINA24))\r\nreturn -ENODEV;\r\nif ((err = init_dsp_comm_page(chip))) {\r\ndev_err(chip->card->dev,\r\n"init_hw - could not initialize DSP comm page\n");\r\nreturn err;\r\n}\r\nchip->device_id = device_id;\r\nchip->subdevice_id = subdevice_id;\r\nchip->bad_board = TRUE;\r\nchip->input_clock_types =\r\nECHO_CLOCK_BIT_INTERNAL | ECHO_CLOCK_BIT_SPDIF |\r\nECHO_CLOCK_BIT_ESYNC | ECHO_CLOCK_BIT_ESYNC96 |\r\nECHO_CLOCK_BIT_ADAT;\r\nif (chip->device_id == DEVICE_ID_56361) {\r\nchip->dsp_code_to_load = FW_GINA24_361_DSP;\r\nchip->digital_modes =\r\nECHOCAPS_HAS_DIGITAL_MODE_SPDIF_RCA |\r\nECHOCAPS_HAS_DIGITAL_MODE_SPDIF_OPTICAL |\r\nECHOCAPS_HAS_DIGITAL_MODE_ADAT;\r\n} else {\r\nchip->dsp_code_to_load = FW_GINA24_301_DSP;\r\nchip->digital_modes =\r\nECHOCAPS_HAS_DIGITAL_MODE_SPDIF_RCA |\r\nECHOCAPS_HAS_DIGITAL_MODE_SPDIF_OPTICAL |\r\nECHOCAPS_HAS_DIGITAL_MODE_ADAT |\r\nECHOCAPS_HAS_DIGITAL_MODE_SPDIF_CDROM;\r\n}\r\nif ((err = load_firmware(chip)) < 0)\r\nreturn err;\r\nchip->bad_board = FALSE;\r\nreturn err;\r\n}\r\nstatic int set_mixer_defaults(struct echoaudio *chip)\r\n{\r\nchip->digital_mode = DIGITAL_MODE_SPDIF_RCA;\r\nchip->professional_spdif = FALSE;\r\nchip->digital_in_automute = TRUE;\r\nreturn init_line_levels(chip);\r\n}\r\nstatic u32 detect_input_clocks(const struct echoaudio *chip)\r\n{\r\nu32 clocks_from_dsp, clock_bits;\r\nclocks_from_dsp = le32_to_cpu(chip->comm_page->status_clocks);\r\nclock_bits = ECHO_CLOCK_BIT_INTERNAL;\r\nif (clocks_from_dsp & GML_CLOCK_DETECT_BIT_SPDIF)\r\nclock_bits |= ECHO_CLOCK_BIT_SPDIF;\r\nif (clocks_from_dsp & GML_CLOCK_DETECT_BIT_ADAT)\r\nclock_bits |= ECHO_CLOCK_BIT_ADAT;\r\nif (clocks_from_dsp & GML_CLOCK_DETECT_BIT_ESYNC)\r\nclock_bits |= ECHO_CLOCK_BIT_ESYNC | ECHO_CLOCK_BIT_ESYNC96;\r\nreturn clock_bits;\r\n}\r\nstatic int load_asic(struct echoaudio *chip)\r\n{\r\nu32 control_reg;\r\nint err;\r\nshort asic;\r\nif (chip->asic_loaded)\r\nreturn 1;\r\nmdelay(10);\r\nif (chip->device_id == DEVICE_ID_56361)\r\nasic = FW_GINA24_361_ASIC;\r\nelse\r\nasic = FW_GINA24_301_ASIC;\r\nerr = load_asic_generic(chip, DSP_FNC_LOAD_GINA24_ASIC, asic);\r\nif (err < 0)\r\nreturn err;\r\nchip->asic_code = asic;\r\nmdelay(10);\r\nerr = check_asic_status(chip);\r\nif (!err) {\r\ncontrol_reg = GML_CONVERTER_ENABLE | GML_48KHZ;\r\nerr = write_control_reg(chip, control_reg, TRUE);\r\n}\r\nreturn err;\r\n}\r\nstatic int set_sample_rate(struct echoaudio *chip, u32 rate)\r\n{\r\nu32 control_reg, clock;\r\nif (snd_BUG_ON(rate >= 50000 &&\r\nchip->digital_mode == DIGITAL_MODE_ADAT))\r\nreturn -EINVAL;\r\nif (chip->input_clock != ECHO_CLOCK_INTERNAL) {\r\ndev_warn(chip->card->dev,\r\n"Cannot set sample rate - clock not set to CLK_CLOCKININTERNAL\n");\r\nchip->comm_page->sample_rate = cpu_to_le32(rate);\r\nchip->sample_rate = rate;\r\nreturn 0;\r\n}\r\nclock = 0;\r\ncontrol_reg = le32_to_cpu(chip->comm_page->control_register);\r\ncontrol_reg &= GML_CLOCK_CLEAR_MASK & GML_SPDIF_RATE_CLEAR_MASK;\r\nswitch (rate) {\r\ncase 96000:\r\nclock = GML_96KHZ;\r\nbreak;\r\ncase 88200:\r\nclock = GML_88KHZ;\r\nbreak;\r\ncase 48000:\r\nclock = GML_48KHZ | GML_SPDIF_SAMPLE_RATE1;\r\nbreak;\r\ncase 44100:\r\nclock = GML_44KHZ;\r\nif (control_reg & GML_SPDIF_PRO_MODE)\r\nclock |= GML_SPDIF_SAMPLE_RATE0;\r\nbreak;\r\ncase 32000:\r\nclock = GML_32KHZ | GML_SPDIF_SAMPLE_RATE0 |\r\nGML_SPDIF_SAMPLE_RATE1;\r\nbreak;\r\ncase 22050:\r\nclock = GML_22KHZ;\r\nbreak;\r\ncase 16000:\r\nclock = GML_16KHZ;\r\nbreak;\r\ncase 11025:\r\nclock = GML_11KHZ;\r\nbreak;\r\ncase 8000:\r\nclock = GML_8KHZ;\r\nbreak;\r\ndefault:\r\ndev_err(chip->card->dev,\r\n"set_sample_rate: %d invalid!\n", rate);\r\nreturn -EINVAL;\r\n}\r\ncontrol_reg |= clock;\r\nchip->comm_page->sample_rate = cpu_to_le32(rate);\r\nchip->sample_rate = rate;\r\ndev_dbg(chip->card->dev, "set_sample_rate: %d clock %d\n", rate, clock);\r\nreturn write_control_reg(chip, control_reg, FALSE);\r\n}\r\nstatic int set_input_clock(struct echoaudio *chip, u16 clock)\r\n{\r\nu32 control_reg, clocks_from_dsp;\r\ncontrol_reg = le32_to_cpu(chip->comm_page->control_register) &\r\nGML_CLOCK_CLEAR_MASK;\r\nclocks_from_dsp = le32_to_cpu(chip->comm_page->status_clocks);\r\nswitch (clock) {\r\ncase ECHO_CLOCK_INTERNAL:\r\nchip->input_clock = ECHO_CLOCK_INTERNAL;\r\nreturn set_sample_rate(chip, chip->sample_rate);\r\ncase ECHO_CLOCK_SPDIF:\r\nif (chip->digital_mode == DIGITAL_MODE_ADAT)\r\nreturn -EAGAIN;\r\ncontrol_reg |= GML_SPDIF_CLOCK;\r\nif (clocks_from_dsp & GML_CLOCK_DETECT_BIT_SPDIF96)\r\ncontrol_reg |= GML_DOUBLE_SPEED_MODE;\r\nelse\r\ncontrol_reg &= ~GML_DOUBLE_SPEED_MODE;\r\nbreak;\r\ncase ECHO_CLOCK_ADAT:\r\nif (chip->digital_mode != DIGITAL_MODE_ADAT)\r\nreturn -EAGAIN;\r\ncontrol_reg |= GML_ADAT_CLOCK;\r\ncontrol_reg &= ~GML_DOUBLE_SPEED_MODE;\r\nbreak;\r\ncase ECHO_CLOCK_ESYNC:\r\ncontrol_reg |= GML_ESYNC_CLOCK;\r\ncontrol_reg &= ~GML_DOUBLE_SPEED_MODE;\r\nbreak;\r\ncase ECHO_CLOCK_ESYNC96:\r\ncontrol_reg |= GML_ESYNC_CLOCK | GML_DOUBLE_SPEED_MODE;\r\nbreak;\r\ndefault:\r\ndev_err(chip->card->dev,\r\n"Input clock 0x%x not supported for Gina24\n", clock);\r\nreturn -EINVAL;\r\n}\r\nchip->input_clock = clock;\r\nreturn write_control_reg(chip, control_reg, TRUE);\r\n}\r\nstatic int dsp_set_digital_mode(struct echoaudio *chip, u8 mode)\r\n{\r\nu32 control_reg;\r\nint err, incompatible_clock;\r\nincompatible_clock = FALSE;\r\nswitch (mode) {\r\ncase DIGITAL_MODE_SPDIF_OPTICAL:\r\ncase DIGITAL_MODE_SPDIF_CDROM:\r\ncase DIGITAL_MODE_SPDIF_RCA:\r\nif (chip->input_clock == ECHO_CLOCK_ADAT)\r\nincompatible_clock = TRUE;\r\nbreak;\r\ncase DIGITAL_MODE_ADAT:\r\nif (chip->input_clock == ECHO_CLOCK_SPDIF)\r\nincompatible_clock = TRUE;\r\nbreak;\r\ndefault:\r\ndev_err(chip->card->dev,\r\n"Digital mode not supported: %d\n", mode);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irq(&chip->lock);\r\nif (incompatible_clock) {\r\nchip->sample_rate = 48000;\r\nset_input_clock(chip, ECHO_CLOCK_INTERNAL);\r\n}\r\ncontrol_reg = le32_to_cpu(chip->comm_page->control_register);\r\ncontrol_reg &= GML_DIGITAL_MODE_CLEAR_MASK;\r\nswitch (mode) {\r\ncase DIGITAL_MODE_SPDIF_OPTICAL:\r\ncontrol_reg |= GML_SPDIF_OPTICAL_MODE;\r\nbreak;\r\ncase DIGITAL_MODE_SPDIF_CDROM:\r\nif (chip->device_id == DEVICE_ID_56301)\r\ncontrol_reg |= GML_SPDIF_CDROM_MODE;\r\nbreak;\r\ncase DIGITAL_MODE_SPDIF_RCA:\r\nbreak;\r\ncase DIGITAL_MODE_ADAT:\r\ncontrol_reg |= GML_ADAT_MODE;\r\ncontrol_reg &= ~GML_DOUBLE_SPEED_MODE;\r\nbreak;\r\n}\r\nerr = write_control_reg(chip, control_reg, TRUE);\r\nspin_unlock_irq(&chip->lock);\r\nif (err < 0)\r\nreturn err;\r\nchip->digital_mode = mode;\r\ndev_dbg(chip->card->dev,\r\n"set_digital_mode to %d\n", chip->digital_mode);\r\nreturn incompatible_clock;\r\n}
