static inline struct childless *to_childless(struct config_item *item)\r\n{\r\nreturn item ? container_of(to_configfs_subsystem(to_config_group(item)), struct childless, subsys) : NULL;\r\n}\r\nstatic ssize_t childless_showme_read(struct childless *childless,\r\nchar *page)\r\n{\r\nssize_t pos;\r\npos = sprintf(page, "%d\n", childless->showme);\r\nchildless->showme++;\r\nreturn pos;\r\n}\r\nstatic ssize_t childless_storeme_read(struct childless *childless,\r\nchar *page)\r\n{\r\nreturn sprintf(page, "%d\n", childless->storeme);\r\n}\r\nstatic ssize_t childless_storeme_write(struct childless *childless,\r\nconst char *page,\r\nsize_t count)\r\n{\r\nunsigned long tmp;\r\nchar *p = (char *) page;\r\ntmp = simple_strtoul(p, &p, 10);\r\nif ((*p != '\0') && (*p != '\n'))\r\nreturn -EINVAL;\r\nif (tmp > INT_MAX)\r\nreturn -ERANGE;\r\nchildless->storeme = tmp;\r\nreturn count;\r\n}\r\nstatic ssize_t childless_description_read(struct childless *childless,\r\nchar *page)\r\n{\r\nreturn sprintf(page,\r\n"[01-childless]\n"\r\n"\n"\r\n"The childless subsystem is the simplest possible subsystem in\n"\r\n"configfs. It does not support the creation of child config_items.\n"\r\n"It only has a few attributes. In fact, it isn't much different\n"\r\n"than a directory in /proc.\n");\r\n}\r\nstatic ssize_t childless_attr_show(struct config_item *item,\r\nstruct configfs_attribute *attr,\r\nchar *page)\r\n{\r\nstruct childless *childless = to_childless(item);\r\nstruct childless_attribute *childless_attr =\r\ncontainer_of(attr, struct childless_attribute, attr);\r\nssize_t ret = 0;\r\nif (childless_attr->show)\r\nret = childless_attr->show(childless, page);\r\nreturn ret;\r\n}\r\nstatic ssize_t childless_attr_store(struct config_item *item,\r\nstruct configfs_attribute *attr,\r\nconst char *page, size_t count)\r\n{\r\nstruct childless *childless = to_childless(item);\r\nstruct childless_attribute *childless_attr =\r\ncontainer_of(attr, struct childless_attribute, attr);\r\nssize_t ret = -EINVAL;\r\nif (childless_attr->store)\r\nret = childless_attr->store(childless, page, count);\r\nreturn ret;\r\n}\r\nstatic inline struct simple_child *to_simple_child(struct config_item *item)\r\n{\r\nreturn item ? container_of(item, struct simple_child, item) : NULL;\r\n}\r\nstatic ssize_t simple_child_attr_show(struct config_item *item,\r\nstruct configfs_attribute *attr,\r\nchar *page)\r\n{\r\nssize_t count;\r\nstruct simple_child *simple_child = to_simple_child(item);\r\ncount = sprintf(page, "%d\n", simple_child->storeme);\r\nreturn count;\r\n}\r\nstatic ssize_t simple_child_attr_store(struct config_item *item,\r\nstruct configfs_attribute *attr,\r\nconst char *page, size_t count)\r\n{\r\nstruct simple_child *simple_child = to_simple_child(item);\r\nunsigned long tmp;\r\nchar *p = (char *) page;\r\ntmp = simple_strtoul(p, &p, 10);\r\nif (!p || (*p && (*p != '\n')))\r\nreturn -EINVAL;\r\nif (tmp > INT_MAX)\r\nreturn -ERANGE;\r\nsimple_child->storeme = tmp;\r\nreturn count;\r\n}\r\nstatic void simple_child_release(struct config_item *item)\r\n{\r\nkfree(to_simple_child(item));\r\n}\r\nstatic inline struct simple_children *to_simple_children(struct config_item *item)\r\n{\r\nreturn item ? container_of(to_config_group(item), struct simple_children, group) : NULL;\r\n}\r\nstatic struct config_item *simple_children_make_item(struct config_group *group, const char *name)\r\n{\r\nstruct simple_child *simple_child;\r\nsimple_child = kzalloc(sizeof(struct simple_child), GFP_KERNEL);\r\nif (!simple_child)\r\nreturn ERR_PTR(-ENOMEM);\r\nconfig_item_init_type_name(&simple_child->item, name,\r\n&simple_child_type);\r\nsimple_child->storeme = 0;\r\nreturn &simple_child->item;\r\n}\r\nstatic ssize_t simple_children_attr_show(struct config_item *item,\r\nstruct configfs_attribute *attr,\r\nchar *page)\r\n{\r\nreturn sprintf(page,\r\n"[02-simple-children]\n"\r\n"\n"\r\n"This subsystem allows the creation of child config_items. These\n"\r\n"items have only one attribute that is readable and writeable.\n");\r\n}\r\nstatic void simple_children_release(struct config_item *item)\r\n{\r\nkfree(to_simple_children(item));\r\n}\r\nstatic struct config_group *group_children_make_group(struct config_group *group, const char *name)\r\n{\r\nstruct simple_children *simple_children;\r\nsimple_children = kzalloc(sizeof(struct simple_children),\r\nGFP_KERNEL);\r\nif (!simple_children)\r\nreturn ERR_PTR(-ENOMEM);\r\nconfig_group_init_type_name(&simple_children->group, name,\r\n&simple_children_type);\r\nreturn &simple_children->group;\r\n}\r\nstatic ssize_t group_children_attr_show(struct config_item *item,\r\nstruct configfs_attribute *attr,\r\nchar *page)\r\n{\r\nreturn sprintf(page,\r\n"[03-group-children]\n"\r\n"\n"\r\n"This subsystem allows the creation of child config_groups. These\n"\r\n"groups are like the subsystem simple-children.\n");\r\n}\r\nstatic int __init configfs_example_init(void)\r\n{\r\nint ret;\r\nint i;\r\nstruct configfs_subsystem *subsys;\r\nfor (i = 0; example_subsys[i]; i++) {\r\nsubsys = example_subsys[i];\r\nconfig_group_init(&subsys->su_group);\r\nmutex_init(&subsys->su_mutex);\r\nret = configfs_register_subsystem(subsys);\r\nif (ret) {\r\nprintk(KERN_ERR "Error %d while registering subsystem %s\n",\r\nret,\r\nsubsys->su_group.cg_item.ci_namebuf);\r\ngoto out_unregister;\r\n}\r\n}\r\nreturn 0;\r\nout_unregister:\r\nfor (i--; i >= 0; i--)\r\nconfigfs_unregister_subsystem(example_subsys[i]);\r\nreturn ret;\r\n}\r\nstatic void __exit configfs_example_exit(void)\r\n{\r\nint i;\r\nfor (i = 0; example_subsys[i]; i++)\r\nconfigfs_unregister_subsystem(example_subsys[i]);\r\n}
