static struct atm_dev *__alloc_atm_dev(const char *type)\r\n{\r\nstruct atm_dev *dev;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn NULL;\r\ndev->type = type;\r\ndev->signal = ATM_PHY_SIG_UNKNOWN;\r\ndev->link_rate = ATM_OC3_PCR;\r\nspin_lock_init(&dev->lock);\r\nINIT_LIST_HEAD(&dev->local);\r\nINIT_LIST_HEAD(&dev->lecs);\r\nreturn dev;\r\n}\r\nstatic struct atm_dev *__atm_dev_lookup(int number)\r\n{\r\nstruct atm_dev *dev;\r\nstruct list_head *p;\r\nlist_for_each(p, &atm_devs) {\r\ndev = list_entry(p, struct atm_dev, dev_list);\r\nif (dev->number == number) {\r\natm_dev_hold(dev);\r\nreturn dev;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstruct atm_dev *atm_dev_lookup(int number)\r\n{\r\nstruct atm_dev *dev;\r\nmutex_lock(&atm_dev_mutex);\r\ndev = __atm_dev_lookup(number);\r\nmutex_unlock(&atm_dev_mutex);\r\nreturn dev;\r\n}\r\nstruct atm_dev *atm_dev_register(const char *type, struct device *parent,\r\nconst struct atmdev_ops *ops, int number,\r\nunsigned long *flags)\r\n{\r\nstruct atm_dev *dev, *inuse;\r\ndev = __alloc_atm_dev(type);\r\nif (!dev) {\r\npr_err("no space for dev %s\n", type);\r\nreturn NULL;\r\n}\r\nmutex_lock(&atm_dev_mutex);\r\nif (number != -1) {\r\ninuse = __atm_dev_lookup(number);\r\nif (inuse) {\r\natm_dev_put(inuse);\r\nmutex_unlock(&atm_dev_mutex);\r\nkfree(dev);\r\nreturn NULL;\r\n}\r\ndev->number = number;\r\n} else {\r\ndev->number = 0;\r\nwhile ((inuse = __atm_dev_lookup(dev->number))) {\r\natm_dev_put(inuse);\r\ndev->number++;\r\n}\r\n}\r\ndev->ops = ops;\r\nif (flags)\r\ndev->flags = *flags;\r\nelse\r\nmemset(&dev->flags, 0, sizeof(dev->flags));\r\nmemset(&dev->stats, 0, sizeof(dev->stats));\r\natomic_set(&dev->refcnt, 1);\r\nif (atm_proc_dev_register(dev) < 0) {\r\npr_err("atm_proc_dev_register failed for dev %s\n", type);\r\ngoto out_fail;\r\n}\r\nif (atm_register_sysfs(dev, parent) < 0) {\r\npr_err("atm_register_sysfs failed for dev %s\n", type);\r\natm_proc_dev_deregister(dev);\r\ngoto out_fail;\r\n}\r\nlist_add_tail(&dev->dev_list, &atm_devs);\r\nout:\r\nmutex_unlock(&atm_dev_mutex);\r\nreturn dev;\r\nout_fail:\r\nkfree(dev);\r\ndev = NULL;\r\ngoto out;\r\n}\r\nvoid atm_dev_deregister(struct atm_dev *dev)\r\n{\r\nBUG_ON(test_bit(ATM_DF_REMOVED, &dev->flags));\r\nset_bit(ATM_DF_REMOVED, &dev->flags);\r\nmutex_lock(&atm_dev_mutex);\r\nlist_del(&dev->dev_list);\r\nmutex_unlock(&atm_dev_mutex);\r\natm_dev_release_vccs(dev);\r\natm_unregister_sysfs(dev);\r\natm_proc_dev_deregister(dev);\r\natm_dev_put(dev);\r\n}\r\nstatic void copy_aal_stats(struct k_atm_aal_stats *from,\r\nstruct atm_aal_stats *to)\r\n{\r\n#define __HANDLE_ITEM(i) to->i = atomic_read(&from->i)\r\n__AAL_STAT_ITEMS\r\n#undef __HANDLE_ITEM\r\n}\r\nstatic void subtract_aal_stats(struct k_atm_aal_stats *from,\r\nstruct atm_aal_stats *to)\r\n{\r\n#define __HANDLE_ITEM(i) atomic_sub(to->i, &from->i)\r\n__AAL_STAT_ITEMS\r\n#undef __HANDLE_ITEM\r\n}\r\nstatic int fetch_stats(struct atm_dev *dev, struct atm_dev_stats __user *arg,\r\nint zero)\r\n{\r\nstruct atm_dev_stats tmp;\r\nint error = 0;\r\ncopy_aal_stats(&dev->stats.aal0, &tmp.aal0);\r\ncopy_aal_stats(&dev->stats.aal34, &tmp.aal34);\r\ncopy_aal_stats(&dev->stats.aal5, &tmp.aal5);\r\nif (arg)\r\nerror = copy_to_user(arg, &tmp, sizeof(tmp));\r\nif (zero && !error) {\r\nsubtract_aal_stats(&dev->stats.aal0, &tmp.aal0);\r\nsubtract_aal_stats(&dev->stats.aal34, &tmp.aal34);\r\nsubtract_aal_stats(&dev->stats.aal5, &tmp.aal5);\r\n}\r\nreturn error ? -EFAULT : 0;\r\n}\r\nint atm_dev_ioctl(unsigned int cmd, void __user *arg, int compat)\r\n{\r\nvoid __user *buf;\r\nint error, len, number, size = 0;\r\nstruct atm_dev *dev;\r\nstruct list_head *p;\r\nint *tmp_buf, *tmp_p;\r\nint __user *sioc_len;\r\nint __user *iobuf_len;\r\n#ifndef CONFIG_COMPAT\r\ncompat = 0;\r\n#endif\r\nswitch (cmd) {\r\ncase ATM_GETNAMES:\r\nif (compat) {\r\n#ifdef CONFIG_COMPAT\r\nstruct compat_atm_iobuf __user *ciobuf = arg;\r\ncompat_uptr_t cbuf;\r\niobuf_len = &ciobuf->length;\r\nif (get_user(cbuf, &ciobuf->buffer))\r\nreturn -EFAULT;\r\nbuf = compat_ptr(cbuf);\r\n#endif\r\n} else {\r\nstruct atm_iobuf __user *iobuf = arg;\r\niobuf_len = &iobuf->length;\r\nif (get_user(buf, &iobuf->buffer))\r\nreturn -EFAULT;\r\n}\r\nif (get_user(len, iobuf_len))\r\nreturn -EFAULT;\r\nmutex_lock(&atm_dev_mutex);\r\nlist_for_each(p, &atm_devs)\r\nsize += sizeof(int);\r\nif (size > len) {\r\nmutex_unlock(&atm_dev_mutex);\r\nreturn -E2BIG;\r\n}\r\ntmp_buf = kmalloc(size, GFP_ATOMIC);\r\nif (!tmp_buf) {\r\nmutex_unlock(&atm_dev_mutex);\r\nreturn -ENOMEM;\r\n}\r\ntmp_p = tmp_buf;\r\nlist_for_each(p, &atm_devs) {\r\ndev = list_entry(p, struct atm_dev, dev_list);\r\n*tmp_p++ = dev->number;\r\n}\r\nmutex_unlock(&atm_dev_mutex);\r\nerror = ((copy_to_user(buf, tmp_buf, size)) ||\r\nput_user(size, iobuf_len))\r\n? -EFAULT : 0;\r\nkfree(tmp_buf);\r\nreturn error;\r\ndefault:\r\nbreak;\r\n}\r\nif (compat) {\r\n#ifdef CONFIG_COMPAT\r\nstruct compat_atmif_sioc __user *csioc = arg;\r\ncompat_uptr_t carg;\r\nsioc_len = &csioc->length;\r\nif (get_user(carg, &csioc->arg))\r\nreturn -EFAULT;\r\nbuf = compat_ptr(carg);\r\nif (get_user(len, &csioc->length))\r\nreturn -EFAULT;\r\nif (get_user(number, &csioc->number))\r\nreturn -EFAULT;\r\n#endif\r\n} else {\r\nstruct atmif_sioc __user *sioc = arg;\r\nsioc_len = &sioc->length;\r\nif (get_user(buf, &sioc->arg))\r\nreturn -EFAULT;\r\nif (get_user(len, &sioc->length))\r\nreturn -EFAULT;\r\nif (get_user(number, &sioc->number))\r\nreturn -EFAULT;\r\n}\r\ndev = try_then_request_module(atm_dev_lookup(number), "atm-device-%d",\r\nnumber);\r\nif (!dev)\r\nreturn -ENODEV;\r\nswitch (cmd) {\r\ncase ATM_GETTYPE:\r\nsize = strlen(dev->type) + 1;\r\nif (copy_to_user(buf, dev->type, size)) {\r\nerror = -EFAULT;\r\ngoto done;\r\n}\r\nbreak;\r\ncase ATM_GETESI:\r\nsize = ESI_LEN;\r\nif (copy_to_user(buf, dev->esi, size)) {\r\nerror = -EFAULT;\r\ngoto done;\r\n}\r\nbreak;\r\ncase ATM_SETESI:\r\n{\r\nint i;\r\nfor (i = 0; i < ESI_LEN; i++)\r\nif (dev->esi[i]) {\r\nerror = -EEXIST;\r\ngoto done;\r\n}\r\n}\r\ncase ATM_SETESIF:\r\n{\r\nunsigned char esi[ESI_LEN];\r\nif (!capable(CAP_NET_ADMIN)) {\r\nerror = -EPERM;\r\ngoto done;\r\n}\r\nif (copy_from_user(esi, buf, ESI_LEN)) {\r\nerror = -EFAULT;\r\ngoto done;\r\n}\r\nmemcpy(dev->esi, esi, ESI_LEN);\r\nerror = ESI_LEN;\r\ngoto done;\r\n}\r\ncase ATM_GETSTATZ:\r\nif (!capable(CAP_NET_ADMIN)) {\r\nerror = -EPERM;\r\ngoto done;\r\n}\r\ncase ATM_GETSTAT:\r\nsize = sizeof(struct atm_dev_stats);\r\nerror = fetch_stats(dev, buf, cmd == ATM_GETSTATZ);\r\nif (error)\r\ngoto done;\r\nbreak;\r\ncase ATM_GETCIRANGE:\r\nsize = sizeof(struct atm_cirange);\r\nif (copy_to_user(buf, &dev->ci_range, size)) {\r\nerror = -EFAULT;\r\ngoto done;\r\n}\r\nbreak;\r\ncase ATM_GETLINKRATE:\r\nsize = sizeof(int);\r\nif (copy_to_user(buf, &dev->link_rate, size)) {\r\nerror = -EFAULT;\r\ngoto done;\r\n}\r\nbreak;\r\ncase ATM_RSTADDR:\r\nif (!capable(CAP_NET_ADMIN)) {\r\nerror = -EPERM;\r\ngoto done;\r\n}\r\natm_reset_addr(dev, ATM_ADDR_LOCAL);\r\nbreak;\r\ncase ATM_ADDADDR:\r\ncase ATM_DELADDR:\r\ncase ATM_ADDLECSADDR:\r\ncase ATM_DELLECSADDR:\r\n{\r\nstruct sockaddr_atmsvc addr;\r\nif (!capable(CAP_NET_ADMIN)) {\r\nerror = -EPERM;\r\ngoto done;\r\n}\r\nif (copy_from_user(&addr, buf, sizeof(addr))) {\r\nerror = -EFAULT;\r\ngoto done;\r\n}\r\nif (cmd == ATM_ADDADDR || cmd == ATM_ADDLECSADDR)\r\nerror = atm_add_addr(dev, &addr,\r\n(cmd == ATM_ADDADDR ?\r\nATM_ADDR_LOCAL : ATM_ADDR_LECS));\r\nelse\r\nerror = atm_del_addr(dev, &addr,\r\n(cmd == ATM_DELADDR ?\r\nATM_ADDR_LOCAL : ATM_ADDR_LECS));\r\ngoto done;\r\n}\r\ncase ATM_GETADDR:\r\ncase ATM_GETLECSADDR:\r\nerror = atm_get_addr(dev, buf, len,\r\n(cmd == ATM_GETADDR ?\r\nATM_ADDR_LOCAL : ATM_ADDR_LECS));\r\nif (error < 0)\r\ngoto done;\r\nsize = error;\r\nerror = put_user(size, sioc_len) ? -EFAULT : 0;\r\ngoto done;\r\ncase ATM_SETLOOP:\r\nif (__ATM_LM_XTRMT((int) (unsigned long) buf) &&\r\n__ATM_LM_XTLOC((int) (unsigned long) buf) >\r\n__ATM_LM_XTRMT((int) (unsigned long) buf)) {\r\nerror = -EINVAL;\r\ngoto done;\r\n}\r\ncase ATM_SETCIRANGE:\r\ncase SONET_GETSTATZ:\r\ncase SONET_SETDIAG:\r\ncase SONET_CLRDIAG:\r\ncase SONET_SETFRAMING:\r\nif (!capable(CAP_NET_ADMIN)) {\r\nerror = -EPERM;\r\ngoto done;\r\n}\r\ndefault:\r\nif (compat) {\r\n#ifdef CONFIG_COMPAT\r\nif (!dev->ops->compat_ioctl) {\r\nerror = -EINVAL;\r\ngoto done;\r\n}\r\nsize = dev->ops->compat_ioctl(dev, cmd, buf);\r\n#endif\r\n} else {\r\nif (!dev->ops->ioctl) {\r\nerror = -EINVAL;\r\ngoto done;\r\n}\r\nsize = dev->ops->ioctl(dev, cmd, buf);\r\n}\r\nif (size < 0) {\r\nerror = (size == -ENOIOCTLCMD ? -ENOTTY : size);\r\ngoto done;\r\n}\r\n}\r\nif (size)\r\nerror = put_user(size, sioc_len) ? -EFAULT : 0;\r\nelse\r\nerror = 0;\r\ndone:\r\natm_dev_put(dev);\r\nreturn error;\r\n}\r\nvoid *atm_dev_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nmutex_lock(&atm_dev_mutex);\r\nreturn seq_list_start_head(&atm_devs, *pos);\r\n}\r\nvoid atm_dev_seq_stop(struct seq_file *seq, void *v)\r\n{\r\nmutex_unlock(&atm_dev_mutex);\r\n}\r\nvoid *atm_dev_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nreturn seq_list_next(v, &atm_devs, pos);\r\n}
