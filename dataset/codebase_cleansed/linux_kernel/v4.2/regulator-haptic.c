static int regulator_haptic_toggle(struct regulator_haptic *haptic, bool on)\r\n{\r\nint error;\r\nif (haptic->active != on) {\r\nerror = on ? regulator_enable(haptic->regulator) :\r\nregulator_disable(haptic->regulator);\r\nif (error) {\r\ndev_err(haptic->dev,\r\n"failed to switch regulator %s: %d\n",\r\non ? "on" : "off", error);\r\nreturn error;\r\n}\r\nhaptic->active = on;\r\n}\r\nreturn 0;\r\n}\r\nstatic int regulator_haptic_set_voltage(struct regulator_haptic *haptic,\r\nunsigned int magnitude)\r\n{\r\nu64 volt_mag_multi;\r\nunsigned int intensity;\r\nint error;\r\nvolt_mag_multi = (u64)(haptic->max_volt - haptic->min_volt) * magnitude;\r\nintensity = (unsigned int)(volt_mag_multi >> MAX_MAGNITUDE_SHIFT);\r\nerror = regulator_set_voltage(haptic->regulator,\r\nintensity + haptic->min_volt,\r\nhaptic->max_volt);\r\nif (error) {\r\ndev_err(haptic->dev, "cannot set regulator voltage to %d: %d\n",\r\nintensity + haptic->min_volt, error);\r\nreturn error;\r\n}\r\nregulator_haptic_toggle(haptic, !!magnitude);\r\nreturn 0;\r\n}\r\nstatic void regulator_haptic_work(struct work_struct *work)\r\n{\r\nstruct regulator_haptic *haptic = container_of(work,\r\nstruct regulator_haptic, work);\r\nmutex_lock(&haptic->mutex);\r\nif (!haptic->suspended)\r\nregulator_haptic_set_voltage(haptic, haptic->magnitude);\r\nmutex_unlock(&haptic->mutex);\r\n}\r\nstatic int regulator_haptic_play_effect(struct input_dev *input, void *data,\r\nstruct ff_effect *effect)\r\n{\r\nstruct regulator_haptic *haptic = input_get_drvdata(input);\r\nhaptic->magnitude = effect->u.rumble.strong_magnitude;\r\nif (!haptic->magnitude)\r\nhaptic->magnitude = effect->u.rumble.weak_magnitude;\r\nschedule_work(&haptic->work);\r\nreturn 0;\r\n}\r\nstatic void regulator_haptic_close(struct input_dev *input)\r\n{\r\nstruct regulator_haptic *haptic = input_get_drvdata(input);\r\ncancel_work_sync(&haptic->work);\r\nregulator_haptic_set_voltage(haptic, 0);\r\n}\r\nstatic int __maybe_unused\r\nregulator_haptic_parse_dt(struct device *dev, struct regulator_haptic *haptic)\r\n{\r\nstruct device_node *node;\r\nint error;\r\nnode = dev->of_node;\r\nif(!node) {\r\ndev_err(dev, "Missing dveice tree data\n");\r\nreturn -EINVAL;\r\n}\r\nerror = of_property_read_u32(node, "max-microvolt", &haptic->max_volt);\r\nif (error) {\r\ndev_err(dev, "cannot parse max-microvolt\n");\r\nreturn error;\r\n}\r\nerror = of_property_read_u32(node, "min-microvolt", &haptic->min_volt);\r\nif (error) {\r\ndev_err(dev, "cannot parse min-microvolt\n");\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int regulator_haptic_probe(struct platform_device *pdev)\r\n{\r\nconst struct regulator_haptic_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct regulator_haptic *haptic;\r\nstruct input_dev *input_dev;\r\nint error;\r\nhaptic = devm_kzalloc(&pdev->dev, sizeof(*haptic), GFP_KERNEL);\r\nif (!haptic)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, haptic);\r\nhaptic->dev = &pdev->dev;\r\nmutex_init(&haptic->mutex);\r\nINIT_WORK(&haptic->work, regulator_haptic_work);\r\nif (pdata) {\r\nhaptic->max_volt = pdata->max_volt;\r\nhaptic->min_volt = pdata->min_volt;\r\n} else if (IS_ENABLED(CONFIG_OF)) {\r\nerror = regulator_haptic_parse_dt(&pdev->dev, haptic);\r\nif (error)\r\nreturn error;\r\n} else {\r\ndev_err(&pdev->dev, "Missing platform data\n");\r\nreturn -EINVAL;\r\n}\r\nhaptic->regulator = devm_regulator_get_exclusive(&pdev->dev, "haptic");\r\nif (IS_ERR(haptic->regulator)) {\r\ndev_err(&pdev->dev, "failed to get regulator\n");\r\nreturn PTR_ERR(haptic->regulator);\r\n}\r\ninput_dev = devm_input_allocate_device(&pdev->dev);\r\nif (!input_dev)\r\nreturn -ENOMEM;\r\nhaptic->input_dev = input_dev;\r\nhaptic->input_dev->name = "regulator-haptic";\r\nhaptic->input_dev->dev.parent = &pdev->dev;\r\nhaptic->input_dev->close = regulator_haptic_close;\r\ninput_set_drvdata(haptic->input_dev, haptic);\r\ninput_set_capability(haptic->input_dev, EV_FF, FF_RUMBLE);\r\nerror = input_ff_create_memless(input_dev, NULL,\r\nregulator_haptic_play_effect);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to create force-feedback\n");\r\nreturn error;\r\n}\r\nerror = input_register_device(haptic->input_dev);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to register input device\n");\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused regulator_haptic_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct regulator_haptic *haptic = platform_get_drvdata(pdev);\r\nint error;\r\nerror = mutex_lock_interruptible(&haptic->mutex);\r\nif (error)\r\nreturn error;\r\nregulator_haptic_set_voltage(haptic, 0);\r\nhaptic->suspended = true;\r\nmutex_unlock(&haptic->mutex);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused regulator_haptic_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct regulator_haptic *haptic = platform_get_drvdata(pdev);\r\nunsigned int magnitude;\r\nmutex_lock(&haptic->mutex);\r\nhaptic->suspended = false;\r\nmagnitude = ACCESS_ONCE(haptic->magnitude);\r\nif (magnitude)\r\nregulator_haptic_set_voltage(haptic, magnitude);\r\nmutex_unlock(&haptic->mutex);\r\nreturn 0;\r\n}
