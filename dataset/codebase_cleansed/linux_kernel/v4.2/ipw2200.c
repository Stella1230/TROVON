static int snprint_line(char *buf, size_t count,\r\nconst u8 * data, u32 len, u32 ofs)\r\n{\r\nint out, i, j, l;\r\nchar c;\r\nout = snprintf(buf, count, "%08X", ofs);\r\nfor (l = 0, i = 0; i < 2; i++) {\r\nout += snprintf(buf + out, count - out, " ");\r\nfor (j = 0; j < 8 && l < len; j++, l++)\r\nout += snprintf(buf + out, count - out, "%02X ",\r\ndata[(i * 8 + j)]);\r\nfor (; j < 8; j++)\r\nout += snprintf(buf + out, count - out, " ");\r\n}\r\nout += snprintf(buf + out, count - out, " ");\r\nfor (l = 0, i = 0; i < 2; i++) {\r\nout += snprintf(buf + out, count - out, " ");\r\nfor (j = 0; j < 8 && l < len; j++, l++) {\r\nc = data[(i * 8 + j)];\r\nif (!isascii(c) || !isprint(c))\r\nc = '.';\r\nout += snprintf(buf + out, count - out, "%c", c);\r\n}\r\nfor (; j < 8; j++)\r\nout += snprintf(buf + out, count - out, " ");\r\n}\r\nreturn out;\r\n}\r\nstatic void printk_buf(int level, const u8 * data, u32 len)\r\n{\r\nchar line[81];\r\nu32 ofs = 0;\r\nif (!(ipw_debug_level & level))\r\nreturn;\r\nwhile (len) {\r\nsnprint_line(line, sizeof(line), &data[ofs],\r\nmin(len, 16U), ofs);\r\nprintk(KERN_DEBUG "%s\n", line);\r\nofs += 16;\r\nlen -= min(len, 16U);\r\n}\r\n}\r\nstatic int snprintk_buf(u8 * output, size_t size, const u8 * data, size_t len)\r\n{\r\nsize_t out = size;\r\nu32 ofs = 0;\r\nint total = 0;\r\nwhile (size && len) {\r\nout = snprint_line(output, size, &data[ofs],\r\nmin_t(size_t, len, 16U), ofs);\r\nofs += 16;\r\noutput += out;\r\nsize -= out;\r\nlen -= min_t(size_t, len, 16U);\r\ntotal += out;\r\n}\r\nreturn total;\r\n}\r\nstatic inline void ipw_write_reg8(struct ipw_priv *a, u32 b, u8 c)\r\n{\r\nIPW_DEBUG_IO("%s %d: write_indirect8(0x%08X, 0x%08X)\n", __FILE__,\r\n__LINE__, (u32) (b), (u32) (c));\r\n_ipw_write_reg8(a, b, c);\r\n}\r\nstatic inline void ipw_write_reg16(struct ipw_priv *a, u32 b, u16 c)\r\n{\r\nIPW_DEBUG_IO("%s %d: write_indirect16(0x%08X, 0x%08X)\n", __FILE__,\r\n__LINE__, (u32) (b), (u32) (c));\r\n_ipw_write_reg16(a, b, c);\r\n}\r\nstatic inline void ipw_write_reg32(struct ipw_priv *a, u32 b, u32 c)\r\n{\r\nIPW_DEBUG_IO("%s %d: write_indirect32(0x%08X, 0x%08X)\n", __FILE__,\r\n__LINE__, (u32) (b), (u32) (c));\r\n_ipw_write_reg32(a, b, c);\r\n}\r\nstatic inline void _ipw_write8(struct ipw_priv *ipw, unsigned long ofs,\r\nu8 val)\r\n{\r\nwriteb(val, ipw->hw_base + ofs);\r\n}\r\nstatic inline void _ipw_write16(struct ipw_priv *ipw, unsigned long ofs,\r\nu16 val)\r\n{\r\nwritew(val, ipw->hw_base + ofs);\r\n}\r\nstatic inline void _ipw_write32(struct ipw_priv *ipw, unsigned long ofs,\r\nu32 val)\r\n{\r\nwritel(val, ipw->hw_base + ofs);\r\n}\r\nstatic inline u8 _ipw_read8(struct ipw_priv *ipw, unsigned long ofs)\r\n{\r\nreturn readb(ipw->hw_base + ofs);\r\n}\r\nstatic inline u16 _ipw_read16(struct ipw_priv *ipw, unsigned long ofs)\r\n{\r\nreturn readw(ipw->hw_base + ofs);\r\n}\r\nstatic inline u32 _ipw_read32(struct ipw_priv *ipw, unsigned long ofs)\r\n{\r\nreturn readl(ipw->hw_base + ofs);\r\n}\r\nstatic void _ipw_write_reg32(struct ipw_priv *priv, u32 reg, u32 value)\r\n{\r\nIPW_DEBUG_IO(" %p : reg = 0x%8X : value = 0x%8X\n", priv, reg, value);\r\n_ipw_write32(priv, IPW_INDIRECT_ADDR, reg);\r\n_ipw_write32(priv, IPW_INDIRECT_DATA, value);\r\n}\r\nstatic void _ipw_write_reg8(struct ipw_priv *priv, u32 reg, u8 value)\r\n{\r\nu32 aligned_addr = reg & IPW_INDIRECT_ADDR_MASK;\r\nu32 dif_len = reg - aligned_addr;\r\nIPW_DEBUG_IO(" reg = 0x%8X : value = 0x%8X\n", reg, value);\r\n_ipw_write32(priv, IPW_INDIRECT_ADDR, aligned_addr);\r\n_ipw_write8(priv, IPW_INDIRECT_DATA + dif_len, value);\r\n}\r\nstatic void _ipw_write_reg16(struct ipw_priv *priv, u32 reg, u16 value)\r\n{\r\nu32 aligned_addr = reg & IPW_INDIRECT_ADDR_MASK;\r\nu32 dif_len = (reg - aligned_addr) & (~0x1ul);\r\nIPW_DEBUG_IO(" reg = 0x%8X : value = 0x%8X\n", reg, value);\r\n_ipw_write32(priv, IPW_INDIRECT_ADDR, aligned_addr);\r\n_ipw_write16(priv, IPW_INDIRECT_DATA + dif_len, value);\r\n}\r\nstatic u8 _ipw_read_reg8(struct ipw_priv *priv, u32 reg)\r\n{\r\nu32 word;\r\n_ipw_write32(priv, IPW_INDIRECT_ADDR, reg & IPW_INDIRECT_ADDR_MASK);\r\nIPW_DEBUG_IO(" reg = 0x%8X :\n", reg);\r\nword = _ipw_read32(priv, IPW_INDIRECT_DATA);\r\nreturn (word >> ((reg & 0x3) * 8)) & 0xff;\r\n}\r\nstatic u32 _ipw_read_reg32(struct ipw_priv *priv, u32 reg)\r\n{\r\nu32 value;\r\nIPW_DEBUG_IO("%p : reg = 0x%08x\n", priv, reg);\r\n_ipw_write32(priv, IPW_INDIRECT_ADDR, reg);\r\nvalue = _ipw_read32(priv, IPW_INDIRECT_DATA);\r\nIPW_DEBUG_IO(" reg = 0x%4X : value = 0x%4x\n", reg, value);\r\nreturn value;\r\n}\r\nstatic void _ipw_read_indirect(struct ipw_priv *priv, u32 addr, u8 * buf,\r\nint num)\r\n{\r\nu32 aligned_addr = addr & IPW_INDIRECT_ADDR_MASK;\r\nu32 dif_len = addr - aligned_addr;\r\nu32 i;\r\nIPW_DEBUG_IO("addr = %i, buf = %p, num = %i\n", addr, buf, num);\r\nif (num <= 0) {\r\nreturn;\r\n}\r\nif (unlikely(dif_len)) {\r\n_ipw_write32(priv, IPW_INDIRECT_ADDR, aligned_addr);\r\nfor (i = dif_len; ((i < 4) && (num > 0)); i++, num--)\r\n*buf++ = _ipw_read8(priv, IPW_INDIRECT_DATA + i);\r\naligned_addr += 4;\r\n}\r\n_ipw_write32(priv, IPW_AUTOINC_ADDR, aligned_addr);\r\nfor (; num >= 4; buf += 4, aligned_addr += 4, num -= 4)\r\n*(u32 *) buf = _ipw_read32(priv, IPW_AUTOINC_DATA);\r\nif (unlikely(num)) {\r\n_ipw_write32(priv, IPW_INDIRECT_ADDR, aligned_addr);\r\nfor (i = 0; num > 0; i++, num--)\r\n*buf++ = ipw_read8(priv, IPW_INDIRECT_DATA + i);\r\n}\r\n}\r\nstatic void _ipw_write_indirect(struct ipw_priv *priv, u32 addr, u8 * buf,\r\nint num)\r\n{\r\nu32 aligned_addr = addr & IPW_INDIRECT_ADDR_MASK;\r\nu32 dif_len = addr - aligned_addr;\r\nu32 i;\r\nIPW_DEBUG_IO("addr = %i, buf = %p, num = %i\n", addr, buf, num);\r\nif (num <= 0) {\r\nreturn;\r\n}\r\nif (unlikely(dif_len)) {\r\n_ipw_write32(priv, IPW_INDIRECT_ADDR, aligned_addr);\r\nfor (i = dif_len; ((i < 4) && (num > 0)); i++, num--, buf++)\r\n_ipw_write8(priv, IPW_INDIRECT_DATA + i, *buf);\r\naligned_addr += 4;\r\n}\r\n_ipw_write32(priv, IPW_AUTOINC_ADDR, aligned_addr);\r\nfor (; num >= 4; buf += 4, aligned_addr += 4, num -= 4)\r\n_ipw_write32(priv, IPW_AUTOINC_DATA, *(u32 *) buf);\r\nif (unlikely(num)) {\r\n_ipw_write32(priv, IPW_INDIRECT_ADDR, aligned_addr);\r\nfor (i = 0; num > 0; i++, num--, buf++)\r\n_ipw_write8(priv, IPW_INDIRECT_DATA + i, *buf);\r\n}\r\n}\r\nstatic void ipw_write_direct(struct ipw_priv *priv, u32 addr, void *buf,\r\nint num)\r\n{\r\nmemcpy_toio((priv->hw_base + addr), buf, num);\r\n}\r\nstatic inline void ipw_set_bit(struct ipw_priv *priv, u32 reg, u32 mask)\r\n{\r\nipw_write32(priv, reg, ipw_read32(priv, reg) | mask);\r\n}\r\nstatic inline void ipw_clear_bit(struct ipw_priv *priv, u32 reg, u32 mask)\r\n{\r\nipw_write32(priv, reg, ipw_read32(priv, reg) & ~mask);\r\n}\r\nstatic inline void __ipw_enable_interrupts(struct ipw_priv *priv)\r\n{\r\nif (priv->status & STATUS_INT_ENABLED)\r\nreturn;\r\npriv->status |= STATUS_INT_ENABLED;\r\nipw_write32(priv, IPW_INTA_MASK_R, IPW_INTA_MASK_ALL);\r\n}\r\nstatic inline void __ipw_disable_interrupts(struct ipw_priv *priv)\r\n{\r\nif (!(priv->status & STATUS_INT_ENABLED))\r\nreturn;\r\npriv->status &= ~STATUS_INT_ENABLED;\r\nipw_write32(priv, IPW_INTA_MASK_R, ~IPW_INTA_MASK_ALL);\r\n}\r\nstatic inline void ipw_enable_interrupts(struct ipw_priv *priv)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->irq_lock, flags);\r\n__ipw_enable_interrupts(priv);\r\nspin_unlock_irqrestore(&priv->irq_lock, flags);\r\n}\r\nstatic inline void ipw_disable_interrupts(struct ipw_priv *priv)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->irq_lock, flags);\r\n__ipw_disable_interrupts(priv);\r\nspin_unlock_irqrestore(&priv->irq_lock, flags);\r\n}\r\nstatic char *ipw_error_desc(u32 val)\r\n{\r\nswitch (val) {\r\ncase IPW_FW_ERROR_OK:\r\nreturn "ERROR_OK";\r\ncase IPW_FW_ERROR_FAIL:\r\nreturn "ERROR_FAIL";\r\ncase IPW_FW_ERROR_MEMORY_UNDERFLOW:\r\nreturn "MEMORY_UNDERFLOW";\r\ncase IPW_FW_ERROR_MEMORY_OVERFLOW:\r\nreturn "MEMORY_OVERFLOW";\r\ncase IPW_FW_ERROR_BAD_PARAM:\r\nreturn "BAD_PARAM";\r\ncase IPW_FW_ERROR_BAD_CHECKSUM:\r\nreturn "BAD_CHECKSUM";\r\ncase IPW_FW_ERROR_NMI_INTERRUPT:\r\nreturn "NMI_INTERRUPT";\r\ncase IPW_FW_ERROR_BAD_DATABASE:\r\nreturn "BAD_DATABASE";\r\ncase IPW_FW_ERROR_ALLOC_FAIL:\r\nreturn "ALLOC_FAIL";\r\ncase IPW_FW_ERROR_DMA_UNDERRUN:\r\nreturn "DMA_UNDERRUN";\r\ncase IPW_FW_ERROR_DMA_STATUS:\r\nreturn "DMA_STATUS";\r\ncase IPW_FW_ERROR_DINO_ERROR:\r\nreturn "DINO_ERROR";\r\ncase IPW_FW_ERROR_EEPROM_ERROR:\r\nreturn "EEPROM_ERROR";\r\ncase IPW_FW_ERROR_SYSASSERT:\r\nreturn "SYSASSERT";\r\ncase IPW_FW_ERROR_FATAL_ERROR:\r\nreturn "FATAL_ERROR";\r\ndefault:\r\nreturn "UNKNOWN_ERROR";\r\n}\r\n}\r\nstatic void ipw_dump_error_log(struct ipw_priv *priv,\r\nstruct ipw_fw_error *error)\r\n{\r\nu32 i;\r\nif (!error) {\r\nIPW_ERROR("Error allocating and capturing error log. "\r\n"Nothing to dump.\n");\r\nreturn;\r\n}\r\nIPW_ERROR("Start IPW Error Log Dump:\n");\r\nIPW_ERROR("Status: 0x%08X, Config: %08X\n",\r\nerror->status, error->config);\r\nfor (i = 0; i < error->elem_len; i++)\r\nIPW_ERROR("%s %i 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n",\r\nipw_error_desc(error->elem[i].desc),\r\nerror->elem[i].time,\r\nerror->elem[i].blink1,\r\nerror->elem[i].blink2,\r\nerror->elem[i].link1,\r\nerror->elem[i].link2, error->elem[i].data);\r\nfor (i = 0; i < error->log_len; i++)\r\nIPW_ERROR("%i\t0x%08x\t%i\n",\r\nerror->log[i].time,\r\nerror->log[i].data, error->log[i].event);\r\n}\r\nstatic inline int ipw_is_init(struct ipw_priv *priv)\r\n{\r\nreturn (priv->status & STATUS_INIT) ? 1 : 0;\r\n}\r\nstatic int ipw_get_ordinal(struct ipw_priv *priv, u32 ord, void *val, u32 * len)\r\n{\r\nu32 addr, field_info, field_len, field_count, total_len;\r\nIPW_DEBUG_ORD("ordinal = %i\n", ord);\r\nif (!priv || !val || !len) {\r\nIPW_DEBUG_ORD("Invalid argument\n");\r\nreturn -EINVAL;\r\n}\r\nif (!priv->table0_addr || !priv->table1_addr || !priv->table2_addr) {\r\nIPW_DEBUG_ORD("Access ordinals before initialization\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (IPW_ORD_TABLE_ID_MASK & ord) {\r\ncase IPW_ORD_TABLE_0_MASK:\r\nord &= IPW_ORD_TABLE_VALUE_MASK;\r\nif (ord > priv->table0_len) {\r\nIPW_DEBUG_ORD("ordinal value (%i) longer then "\r\n"max (%i)\n", ord, priv->table0_len);\r\nreturn -EINVAL;\r\n}\r\nif (*len < sizeof(u32)) {\r\nIPW_DEBUG_ORD("ordinal buffer length too small, "\r\n"need %zd\n", sizeof(u32));\r\nreturn -EINVAL;\r\n}\r\nIPW_DEBUG_ORD("Reading TABLE0[%i] from offset 0x%08x\n",\r\nord, priv->table0_addr + (ord << 2));\r\n*len = sizeof(u32);\r\nord <<= 2;\r\n*((u32 *) val) = ipw_read32(priv, priv->table0_addr + ord);\r\nbreak;\r\ncase IPW_ORD_TABLE_1_MASK:\r\nord &= IPW_ORD_TABLE_VALUE_MASK;\r\nif (ord > priv->table1_len) {\r\nIPW_DEBUG_ORD("ordinal value too long\n");\r\nreturn -EINVAL;\r\n}\r\nif (*len < sizeof(u32)) {\r\nIPW_DEBUG_ORD("ordinal buffer length too small, "\r\n"need %zd\n", sizeof(u32));\r\nreturn -EINVAL;\r\n}\r\n*((u32 *) val) =\r\nipw_read_reg32(priv, (priv->table1_addr + (ord << 2)));\r\n*len = sizeof(u32);\r\nbreak;\r\ncase IPW_ORD_TABLE_2_MASK:\r\nord &= IPW_ORD_TABLE_VALUE_MASK;\r\nif (ord > priv->table2_len) {\r\nIPW_DEBUG_ORD("ordinal value too long\n");\r\nreturn -EINVAL;\r\n}\r\naddr = ipw_read_reg32(priv, priv->table2_addr + (ord << 3));\r\nfield_info =\r\nipw_read_reg32(priv,\r\npriv->table2_addr + (ord << 3) +\r\nsizeof(u32));\r\nfield_len = *((u16 *) & field_info);\r\nfield_count = *(((u16 *) & field_info) + 1);\r\ntotal_len = field_len * field_count;\r\nif (total_len > *len) {\r\n*len = total_len;\r\nreturn -EINVAL;\r\n}\r\n*len = total_len;\r\nif (!total_len)\r\nreturn 0;\r\nIPW_DEBUG_ORD("addr = 0x%08x, total_len = %i, "\r\n"field_info = 0x%08x\n",\r\naddr, total_len, field_info);\r\nipw_read_indirect(priv, addr, val, total_len);\r\nbreak;\r\ndefault:\r\nIPW_DEBUG_ORD("Invalid ordinal!\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ipw_init_ordinals(struct ipw_priv *priv)\r\n{\r\npriv->table0_addr = IPW_ORDINALS_TABLE_LOWER;\r\npriv->table0_len = ipw_read32(priv, priv->table0_addr);\r\nIPW_DEBUG_ORD("table 0 offset at 0x%08x, len = %i\n",\r\npriv->table0_addr, priv->table0_len);\r\npriv->table1_addr = ipw_read32(priv, IPW_ORDINALS_TABLE_1);\r\npriv->table1_len = ipw_read_reg32(priv, priv->table1_addr);\r\nIPW_DEBUG_ORD("table 1 offset at 0x%08x, len = %i\n",\r\npriv->table1_addr, priv->table1_len);\r\npriv->table2_addr = ipw_read32(priv, IPW_ORDINALS_TABLE_2);\r\npriv->table2_len = ipw_read_reg32(priv, priv->table2_addr);\r\npriv->table2_len &= 0x0000ffff;\r\nIPW_DEBUG_ORD("table 2 offset at 0x%08x, len = %i\n",\r\npriv->table2_addr, priv->table2_len);\r\n}\r\nstatic u32 ipw_register_toggle(u32 reg)\r\n{\r\nreg &= ~IPW_START_STANDBY;\r\nif (reg & IPW_GATE_ODMA)\r\nreg &= ~IPW_GATE_ODMA;\r\nif (reg & IPW_GATE_IDMA)\r\nreg &= ~IPW_GATE_IDMA;\r\nif (reg & IPW_GATE_ADMA)\r\nreg &= ~IPW_GATE_ADMA;\r\nreturn reg;\r\n}\r\nstatic void ipw_led_link_on(struct ipw_priv *priv)\r\n{\r\nunsigned long flags;\r\nu32 led;\r\nif (priv->config & CFG_NO_LED || priv->nic_type == EEPROM_NIC_TYPE_1)\r\nreturn;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (!(priv->status & STATUS_RF_KILL_MASK) &&\r\n!(priv->status & STATUS_LED_LINK_ON)) {\r\nIPW_DEBUG_LED("Link LED On\n");\r\nled = ipw_read_reg32(priv, IPW_EVENT_REG);\r\nled |= priv->led_association_on;\r\nled = ipw_register_toggle(led);\r\nIPW_DEBUG_LED("Reg: 0x%08X\n", led);\r\nipw_write_reg32(priv, IPW_EVENT_REG, led);\r\npriv->status |= STATUS_LED_LINK_ON;\r\nif (!(priv->status & STATUS_ASSOCIATED))\r\nschedule_delayed_work(&priv->led_link_off,\r\nLD_TIME_LINK_ON);\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic void ipw_bg_led_link_on(struct work_struct *work)\r\n{\r\nstruct ipw_priv *priv =\r\ncontainer_of(work, struct ipw_priv, led_link_on.work);\r\nmutex_lock(&priv->mutex);\r\nipw_led_link_on(priv);\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic void ipw_led_link_off(struct ipw_priv *priv)\r\n{\r\nunsigned long flags;\r\nu32 led;\r\nif (priv->config & CFG_NO_LED || priv->nic_type == EEPROM_NIC_TYPE_1)\r\nreturn;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->status & STATUS_LED_LINK_ON) {\r\nled = ipw_read_reg32(priv, IPW_EVENT_REG);\r\nled &= priv->led_association_off;\r\nled = ipw_register_toggle(led);\r\nIPW_DEBUG_LED("Reg: 0x%08X\n", led);\r\nipw_write_reg32(priv, IPW_EVENT_REG, led);\r\nIPW_DEBUG_LED("Link LED Off\n");\r\npriv->status &= ~STATUS_LED_LINK_ON;\r\nif (!(priv->status & STATUS_RF_KILL_MASK) &&\r\n!(priv->status & STATUS_ASSOCIATED))\r\nschedule_delayed_work(&priv->led_link_on,\r\nLD_TIME_LINK_OFF);\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic void ipw_bg_led_link_off(struct work_struct *work)\r\n{\r\nstruct ipw_priv *priv =\r\ncontainer_of(work, struct ipw_priv, led_link_off.work);\r\nmutex_lock(&priv->mutex);\r\nipw_led_link_off(priv);\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic void __ipw_led_activity_on(struct ipw_priv *priv)\r\n{\r\nu32 led;\r\nif (priv->config & CFG_NO_LED)\r\nreturn;\r\nif (priv->status & STATUS_RF_KILL_MASK)\r\nreturn;\r\nif (!(priv->status & STATUS_LED_ACT_ON)) {\r\nled = ipw_read_reg32(priv, IPW_EVENT_REG);\r\nled |= priv->led_activity_on;\r\nled = ipw_register_toggle(led);\r\nIPW_DEBUG_LED("Reg: 0x%08X\n", led);\r\nipw_write_reg32(priv, IPW_EVENT_REG, led);\r\nIPW_DEBUG_LED("Activity LED On\n");\r\npriv->status |= STATUS_LED_ACT_ON;\r\ncancel_delayed_work(&priv->led_act_off);\r\nschedule_delayed_work(&priv->led_act_off, LD_TIME_ACT_ON);\r\n} else {\r\ncancel_delayed_work(&priv->led_act_off);\r\nschedule_delayed_work(&priv->led_act_off, LD_TIME_ACT_ON);\r\n}\r\n}\r\nstatic void ipw_led_activity_off(struct ipw_priv *priv)\r\n{\r\nunsigned long flags;\r\nu32 led;\r\nif (priv->config & CFG_NO_LED)\r\nreturn;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->status & STATUS_LED_ACT_ON) {\r\nled = ipw_read_reg32(priv, IPW_EVENT_REG);\r\nled &= priv->led_activity_off;\r\nled = ipw_register_toggle(led);\r\nIPW_DEBUG_LED("Reg: 0x%08X\n", led);\r\nipw_write_reg32(priv, IPW_EVENT_REG, led);\r\nIPW_DEBUG_LED("Activity LED Off\n");\r\npriv->status &= ~STATUS_LED_ACT_ON;\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic void ipw_bg_led_activity_off(struct work_struct *work)\r\n{\r\nstruct ipw_priv *priv =\r\ncontainer_of(work, struct ipw_priv, led_act_off.work);\r\nmutex_lock(&priv->mutex);\r\nipw_led_activity_off(priv);\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic void ipw_led_band_on(struct ipw_priv *priv)\r\n{\r\nunsigned long flags;\r\nu32 led;\r\nif (priv->config & CFG_NO_LED ||\r\npriv->nic_type != EEPROM_NIC_TYPE_1 || !priv->assoc_network)\r\nreturn;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nled = ipw_read_reg32(priv, IPW_EVENT_REG);\r\nif (priv->assoc_network->mode == IEEE_A) {\r\nled |= priv->led_ofdm_on;\r\nled &= priv->led_association_off;\r\nIPW_DEBUG_LED("Mode LED On: 802.11a\n");\r\n} else if (priv->assoc_network->mode == IEEE_G) {\r\nled |= priv->led_ofdm_on;\r\nled |= priv->led_association_on;\r\nIPW_DEBUG_LED("Mode LED On: 802.11g\n");\r\n} else {\r\nled &= priv->led_ofdm_off;\r\nled |= priv->led_association_on;\r\nIPW_DEBUG_LED("Mode LED On: 802.11b\n");\r\n}\r\nled = ipw_register_toggle(led);\r\nIPW_DEBUG_LED("Reg: 0x%08X\n", led);\r\nipw_write_reg32(priv, IPW_EVENT_REG, led);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic void ipw_led_band_off(struct ipw_priv *priv)\r\n{\r\nunsigned long flags;\r\nu32 led;\r\nif (priv->config & CFG_NO_LED || priv->nic_type != EEPROM_NIC_TYPE_1)\r\nreturn;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nled = ipw_read_reg32(priv, IPW_EVENT_REG);\r\nled &= priv->led_ofdm_off;\r\nled &= priv->led_association_off;\r\nled = ipw_register_toggle(led);\r\nIPW_DEBUG_LED("Reg: 0x%08X\n", led);\r\nipw_write_reg32(priv, IPW_EVENT_REG, led);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic void ipw_led_radio_on(struct ipw_priv *priv)\r\n{\r\nipw_led_link_on(priv);\r\n}\r\nstatic void ipw_led_radio_off(struct ipw_priv *priv)\r\n{\r\nipw_led_activity_off(priv);\r\nipw_led_link_off(priv);\r\n}\r\nstatic void ipw_led_link_up(struct ipw_priv *priv)\r\n{\r\nipw_led_link_on(priv);\r\n}\r\nstatic void ipw_led_link_down(struct ipw_priv *priv)\r\n{\r\nipw_led_activity_off(priv);\r\nipw_led_link_off(priv);\r\nif (priv->status & STATUS_RF_KILL_MASK)\r\nipw_led_radio_off(priv);\r\n}\r\nstatic void ipw_led_init(struct ipw_priv *priv)\r\n{\r\npriv->nic_type = priv->eeprom[EEPROM_NIC_TYPE];\r\npriv->led_activity_on = IPW_ACTIVITY_LED;\r\npriv->led_activity_off = ~(IPW_ACTIVITY_LED);\r\npriv->led_association_on = IPW_ASSOCIATED_LED;\r\npriv->led_association_off = ~(IPW_ASSOCIATED_LED);\r\npriv->led_ofdm_on = IPW_OFDM_LED;\r\npriv->led_ofdm_off = ~(IPW_OFDM_LED);\r\nswitch (priv->nic_type) {\r\ncase EEPROM_NIC_TYPE_1:\r\npriv->led_activity_on = IPW_ASSOCIATED_LED;\r\npriv->led_activity_off = ~(IPW_ASSOCIATED_LED);\r\npriv->led_association_on = IPW_ACTIVITY_LED;\r\npriv->led_association_off = ~(IPW_ACTIVITY_LED);\r\nif (!(priv->config & CFG_NO_LED))\r\nipw_led_band_on(priv);\r\nreturn;\r\ncase EEPROM_NIC_TYPE_3:\r\ncase EEPROM_NIC_TYPE_2:\r\ncase EEPROM_NIC_TYPE_4:\r\ncase EEPROM_NIC_TYPE_0:\r\nbreak;\r\ndefault:\r\nIPW_DEBUG_INFO("Unknown NIC type from EEPROM: %d\n",\r\npriv->nic_type);\r\npriv->nic_type = EEPROM_NIC_TYPE_0;\r\nbreak;\r\n}\r\nif (!(priv->config & CFG_NO_LED)) {\r\nif (priv->status & STATUS_ASSOCIATED)\r\nipw_led_link_on(priv);\r\nelse\r\nipw_led_link_off(priv);\r\n}\r\n}\r\nstatic void ipw_led_shutdown(struct ipw_priv *priv)\r\n{\r\nipw_led_activity_off(priv);\r\nipw_led_link_off(priv);\r\nipw_led_band_off(priv);\r\ncancel_delayed_work(&priv->led_link_on);\r\ncancel_delayed_work(&priv->led_link_off);\r\ncancel_delayed_work(&priv->led_act_off);\r\n}\r\nstatic ssize_t show_debug_level(struct device_driver *d, char *buf)\r\n{\r\nreturn sprintf(buf, "0x%08X\n", ipw_debug_level);\r\n}\r\nstatic ssize_t store_debug_level(struct device_driver *d, const char *buf,\r\nsize_t count)\r\n{\r\nchar *p = (char *)buf;\r\nu32 val;\r\nif (p[1] == 'x' || p[1] == 'X' || p[0] == 'x' || p[0] == 'X') {\r\np++;\r\nif (p[0] == 'x' || p[0] == 'X')\r\np++;\r\nval = simple_strtoul(p, &p, 16);\r\n} else\r\nval = simple_strtoul(p, &p, 10);\r\nif (p == buf)\r\nprintk(KERN_INFO DRV_NAME\r\n": %s is not in hex or decimal form.\n", buf);\r\nelse\r\nipw_debug_level = val;\r\nreturn strnlen(buf, count);\r\n}\r\nstatic inline u32 ipw_get_event_log_len(struct ipw_priv *priv)\r\n{\r\nreturn ipw_read_reg32(priv, ipw_read32(priv, IPW_EVENT_LOG));\r\n}\r\nstatic void ipw_capture_event_log(struct ipw_priv *priv,\r\nu32 log_len, struct ipw_event *log)\r\n{\r\nu32 base;\r\nif (log_len) {\r\nbase = ipw_read32(priv, IPW_EVENT_LOG);\r\nipw_read_indirect(priv, base + sizeof(base) + sizeof(u32),\r\n(u8 *) log, sizeof(*log) * log_len);\r\n}\r\n}\r\nstatic struct ipw_fw_error *ipw_alloc_error_log(struct ipw_priv *priv)\r\n{\r\nstruct ipw_fw_error *error;\r\nu32 log_len = ipw_get_event_log_len(priv);\r\nu32 base = ipw_read32(priv, IPW_ERROR_LOG);\r\nu32 elem_len = ipw_read_reg32(priv, base);\r\nerror = kmalloc(sizeof(*error) +\r\nsizeof(*error->elem) * elem_len +\r\nsizeof(*error->log) * log_len, GFP_ATOMIC);\r\nif (!error) {\r\nIPW_ERROR("Memory allocation for firmware error log "\r\n"failed.\n");\r\nreturn NULL;\r\n}\r\nerror->jiffies = jiffies;\r\nerror->status = priv->status;\r\nerror->config = priv->config;\r\nerror->elem_len = elem_len;\r\nerror->log_len = log_len;\r\nerror->elem = (struct ipw_error_elem *)error->payload;\r\nerror->log = (struct ipw_event *)(error->elem + elem_len);\r\nipw_capture_event_log(priv, log_len, error->log);\r\nif (elem_len)\r\nipw_read_indirect(priv, base + sizeof(base), (u8 *) error->elem,\r\nsizeof(*error->elem) * elem_len);\r\nreturn error;\r\n}\r\nstatic ssize_t show_event_log(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ipw_priv *priv = dev_get_drvdata(d);\r\nu32 log_len = ipw_get_event_log_len(priv);\r\nu32 log_size;\r\nstruct ipw_event *log;\r\nu32 len = 0, i;\r\nlog_size = PAGE_SIZE / sizeof(*log) > log_len ?\r\nsizeof(*log) * log_len : PAGE_SIZE;\r\nlog = kzalloc(log_size, GFP_KERNEL);\r\nif (!log) {\r\nIPW_ERROR("Unable to allocate memory for log\n");\r\nreturn 0;\r\n}\r\nlog_len = log_size / sizeof(*log);\r\nipw_capture_event_log(priv, log_len, log);\r\nlen += snprintf(buf + len, PAGE_SIZE - len, "%08X", log_len);\r\nfor (i = 0; i < log_len; i++)\r\nlen += snprintf(buf + len, PAGE_SIZE - len,\r\n"\n%08X%08X%08X",\r\nlog[i].time, log[i].event, log[i].data);\r\nlen += snprintf(buf + len, PAGE_SIZE - len, "\n");\r\nkfree(log);\r\nreturn len;\r\n}\r\nstatic ssize_t show_error(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ipw_priv *priv = dev_get_drvdata(d);\r\nu32 len = 0, i;\r\nif (!priv->error)\r\nreturn 0;\r\nlen += snprintf(buf + len, PAGE_SIZE - len,\r\n"%08lX%08X%08X%08X",\r\npriv->error->jiffies,\r\npriv->error->status,\r\npriv->error->config, priv->error->elem_len);\r\nfor (i = 0; i < priv->error->elem_len; i++)\r\nlen += snprintf(buf + len, PAGE_SIZE - len,\r\n"\n%08X%08X%08X%08X%08X%08X%08X",\r\npriv->error->elem[i].time,\r\npriv->error->elem[i].desc,\r\npriv->error->elem[i].blink1,\r\npriv->error->elem[i].blink2,\r\npriv->error->elem[i].link1,\r\npriv->error->elem[i].link2,\r\npriv->error->elem[i].data);\r\nlen += snprintf(buf + len, PAGE_SIZE - len,\r\n"\n%08X", priv->error->log_len);\r\nfor (i = 0; i < priv->error->log_len; i++)\r\nlen += snprintf(buf + len, PAGE_SIZE - len,\r\n"\n%08X%08X%08X",\r\npriv->error->log[i].time,\r\npriv->error->log[i].event,\r\npriv->error->log[i].data);\r\nlen += snprintf(buf + len, PAGE_SIZE - len, "\n");\r\nreturn len;\r\n}\r\nstatic ssize_t clear_error(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ipw_priv *priv = dev_get_drvdata(d);\r\nkfree(priv->error);\r\npriv->error = NULL;\r\nreturn count;\r\n}\r\nstatic ssize_t show_cmd_log(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ipw_priv *priv = dev_get_drvdata(d);\r\nu32 len = 0, i;\r\nif (!priv->cmdlog)\r\nreturn 0;\r\nfor (i = (priv->cmdlog_pos + 1) % priv->cmdlog_len;\r\n(i != priv->cmdlog_pos) && (len < PAGE_SIZE);\r\ni = (i + 1) % priv->cmdlog_len) {\r\nlen +=\r\nsnprintf(buf + len, PAGE_SIZE - len,\r\n"\n%08lX%08X%08X%08X\n", priv->cmdlog[i].jiffies,\r\npriv->cmdlog[i].retcode, priv->cmdlog[i].cmd.cmd,\r\npriv->cmdlog[i].cmd.len);\r\nlen +=\r\nsnprintk_buf(buf + len, PAGE_SIZE - len,\r\n(u8 *) priv->cmdlog[i].cmd.param,\r\npriv->cmdlog[i].cmd.len);\r\nlen += snprintf(buf + len, PAGE_SIZE - len, "\n");\r\n}\r\nlen += snprintf(buf + len, PAGE_SIZE - len, "\n");\r\nreturn len;\r\n}\r\nstatic ssize_t store_rtap_iface(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ipw_priv *priv = dev_get_drvdata(d);\r\nint rc = 0;\r\nif (count < 1)\r\nreturn -EINVAL;\r\nswitch (buf[0]) {\r\ncase '0':\r\nif (!rtap_iface)\r\nreturn count;\r\nif (netif_running(priv->prom_net_dev)) {\r\nIPW_WARNING("Interface is up. Cannot unregister.\n");\r\nreturn count;\r\n}\r\nipw_prom_free(priv);\r\nrtap_iface = 0;\r\nbreak;\r\ncase '1':\r\nif (rtap_iface)\r\nreturn count;\r\nrc = ipw_prom_alloc(priv);\r\nif (!rc)\r\nrtap_iface = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (rc) {\r\nIPW_ERROR("Failed to register promiscuous network "\r\n"device (error %d).\n", rc);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t show_rtap_iface(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipw_priv *priv = dev_get_drvdata(d);\r\nif (rtap_iface)\r\nreturn sprintf(buf, "%s", priv->prom_net_dev->name);\r\nelse {\r\nbuf[0] = '-';\r\nbuf[1] = '1';\r\nbuf[2] = '\0';\r\nreturn 3;\r\n}\r\n}\r\nstatic ssize_t store_rtap_filter(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ipw_priv *priv = dev_get_drvdata(d);\r\nif (!priv->prom_priv) {\r\nIPW_ERROR("Attempting to set filter without "\r\n"rtap_iface enabled.\n");\r\nreturn -EPERM;\r\n}\r\npriv->prom_priv->filter = simple_strtol(buf, NULL, 0);\r\nIPW_DEBUG_INFO("Setting rtap filter to " BIT_FMT16 "\n",\r\nBIT_ARG16(priv->prom_priv->filter));\r\nreturn count;\r\n}\r\nstatic ssize_t show_rtap_filter(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipw_priv *priv = dev_get_drvdata(d);\r\nreturn sprintf(buf, "0x%04X",\r\npriv->prom_priv ? priv->prom_priv->filter : 0);\r\n}\r\nstatic ssize_t show_scan_age(struct device *d, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipw_priv *priv = dev_get_drvdata(d);\r\nreturn sprintf(buf, "%d\n", priv->ieee->scan_age);\r\n}\r\nstatic ssize_t store_scan_age(struct device *d, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ipw_priv *priv = dev_get_drvdata(d);\r\nstruct net_device *dev = priv->net_dev;\r\nchar buffer[] = "00000000";\r\nunsigned long len =\r\n(sizeof(buffer) - 1) > count ? count : sizeof(buffer) - 1;\r\nunsigned long val;\r\nchar *p = buffer;\r\nIPW_DEBUG_INFO("enter\n");\r\nstrncpy(buffer, buf, len);\r\nbuffer[len] = 0;\r\nif (p[1] == 'x' || p[1] == 'X' || p[0] == 'x' || p[0] == 'X') {\r\np++;\r\nif (p[0] == 'x' || p[0] == 'X')\r\np++;\r\nval = simple_strtoul(p, &p, 16);\r\n} else\r\nval = simple_strtoul(p, &p, 10);\r\nif (p == buffer) {\r\nIPW_DEBUG_INFO("%s: user supplied invalid value.\n", dev->name);\r\n} else {\r\npriv->ieee->scan_age = val;\r\nIPW_DEBUG_INFO("set scan_age = %u\n", priv->ieee->scan_age);\r\n}\r\nIPW_DEBUG_INFO("exit\n");\r\nreturn len;\r\n}\r\nstatic ssize_t show_led(struct device *d, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipw_priv *priv = dev_get_drvdata(d);\r\nreturn sprintf(buf, "%d\n", (priv->config & CFG_NO_LED) ? 0 : 1);\r\n}\r\nstatic ssize_t store_led(struct device *d, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ipw_priv *priv = dev_get_drvdata(d);\r\nIPW_DEBUG_INFO("enter\n");\r\nif (count == 0)\r\nreturn 0;\r\nif (*buf == 0) {\r\nIPW_DEBUG_LED("Disabling LED control.\n");\r\npriv->config |= CFG_NO_LED;\r\nipw_led_shutdown(priv);\r\n} else {\r\nIPW_DEBUG_LED("Enabling LED control.\n");\r\npriv->config &= ~CFG_NO_LED;\r\nipw_led_init(priv);\r\n}\r\nIPW_DEBUG_INFO("exit\n");\r\nreturn count;\r\n}\r\nstatic ssize_t show_status(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ipw_priv *p = dev_get_drvdata(d);\r\nreturn sprintf(buf, "0x%08x\n", (int)p->status);\r\n}\r\nstatic ssize_t show_cfg(struct device *d, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipw_priv *p = dev_get_drvdata(d);\r\nreturn sprintf(buf, "0x%08x\n", (int)p->config);\r\n}\r\nstatic ssize_t show_nic_type(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ipw_priv *priv = dev_get_drvdata(d);\r\nreturn sprintf(buf, "TYPE: %d\n", priv->nic_type);\r\n}\r\nstatic ssize_t show_ucode_version(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nu32 len = sizeof(u32), tmp = 0;\r\nstruct ipw_priv *p = dev_get_drvdata(d);\r\nif (ipw_get_ordinal(p, IPW_ORD_STAT_UCODE_VERSION, &tmp, &len))\r\nreturn 0;\r\nreturn sprintf(buf, "0x%08x\n", tmp);\r\n}\r\nstatic ssize_t show_rtc(struct device *d, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu32 len = sizeof(u32), tmp = 0;\r\nstruct ipw_priv *p = dev_get_drvdata(d);\r\nif (ipw_get_ordinal(p, IPW_ORD_STAT_RTC, &tmp, &len))\r\nreturn 0;\r\nreturn sprintf(buf, "0x%08x\n", tmp);\r\n}\r\nstatic ssize_t show_eeprom_delay(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ipw_priv *p = dev_get_drvdata(d);\r\nint n = p->eeprom_delay;\r\nreturn sprintf(buf, "%i\n", n);\r\n}\r\nstatic ssize_t store_eeprom_delay(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ipw_priv *p = dev_get_drvdata(d);\r\nsscanf(buf, "%i", &p->eeprom_delay);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t show_command_event_reg(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nu32 reg = 0;\r\nstruct ipw_priv *p = dev_get_drvdata(d);\r\nreg = ipw_read_reg32(p, IPW_INTERNAL_CMD_EVENT);\r\nreturn sprintf(buf, "0x%08x\n", reg);\r\n}\r\nstatic ssize_t store_command_event_reg(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nu32 reg;\r\nstruct ipw_priv *p = dev_get_drvdata(d);\r\nsscanf(buf, "%x", &reg);\r\nipw_write_reg32(p, IPW_INTERNAL_CMD_EVENT, reg);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t show_mem_gpio_reg(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nu32 reg = 0;\r\nstruct ipw_priv *p = dev_get_drvdata(d);\r\nreg = ipw_read_reg32(p, 0x301100);\r\nreturn sprintf(buf, "0x%08x\n", reg);\r\n}\r\nstatic ssize_t store_mem_gpio_reg(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nu32 reg;\r\nstruct ipw_priv *p = dev_get_drvdata(d);\r\nsscanf(buf, "%x", &reg);\r\nipw_write_reg32(p, 0x301100, reg);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t show_indirect_dword(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nu32 reg = 0;\r\nstruct ipw_priv *priv = dev_get_drvdata(d);\r\nif (priv->status & STATUS_INDIRECT_DWORD)\r\nreg = ipw_read_reg32(priv, priv->indirect_dword);\r\nelse\r\nreg = 0;\r\nreturn sprintf(buf, "0x%08x\n", reg);\r\n}\r\nstatic ssize_t store_indirect_dword(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ipw_priv *priv = dev_get_drvdata(d);\r\nsscanf(buf, "%x", &priv->indirect_dword);\r\npriv->status |= STATUS_INDIRECT_DWORD;\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t show_indirect_byte(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nu8 reg = 0;\r\nstruct ipw_priv *priv = dev_get_drvdata(d);\r\nif (priv->status & STATUS_INDIRECT_BYTE)\r\nreg = ipw_read_reg8(priv, priv->indirect_byte);\r\nelse\r\nreg = 0;\r\nreturn sprintf(buf, "0x%02x\n", reg);\r\n}\r\nstatic ssize_t store_indirect_byte(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ipw_priv *priv = dev_get_drvdata(d);\r\nsscanf(buf, "%x", &priv->indirect_byte);\r\npriv->status |= STATUS_INDIRECT_BYTE;\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t show_direct_dword(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nu32 reg = 0;\r\nstruct ipw_priv *priv = dev_get_drvdata(d);\r\nif (priv->status & STATUS_DIRECT_DWORD)\r\nreg = ipw_read32(priv, priv->direct_dword);\r\nelse\r\nreg = 0;\r\nreturn sprintf(buf, "0x%08x\n", reg);\r\n}\r\nstatic ssize_t store_direct_dword(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ipw_priv *priv = dev_get_drvdata(d);\r\nsscanf(buf, "%x", &priv->direct_dword);\r\npriv->status |= STATUS_DIRECT_DWORD;\r\nreturn strnlen(buf, count);\r\n}\r\nstatic int rf_kill_active(struct ipw_priv *priv)\r\n{\r\nif (0 == (ipw_read32(priv, 0x30) & 0x10000)) {\r\npriv->status |= STATUS_RF_KILL_HW;\r\nwiphy_rfkill_set_hw_state(priv->ieee->wdev.wiphy, true);\r\n} else {\r\npriv->status &= ~STATUS_RF_KILL_HW;\r\nwiphy_rfkill_set_hw_state(priv->ieee->wdev.wiphy, false);\r\n}\r\nreturn (priv->status & STATUS_RF_KILL_HW) ? 1 : 0;\r\n}\r\nstatic ssize_t show_rf_kill(struct device *d, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipw_priv *priv = dev_get_drvdata(d);\r\nint val = ((priv->status & STATUS_RF_KILL_SW) ? 0x1 : 0x0) |\r\n(rf_kill_active(priv) ? 0x2 : 0x0);\r\nreturn sprintf(buf, "%i\n", val);\r\n}\r\nstatic int ipw_radio_kill_sw(struct ipw_priv *priv, int disable_radio)\r\n{\r\nif ((disable_radio ? 1 : 0) ==\r\n((priv->status & STATUS_RF_KILL_SW) ? 1 : 0))\r\nreturn 0;\r\nIPW_DEBUG_RF_KILL("Manual SW RF Kill set to: RADIO %s\n",\r\ndisable_radio ? "OFF" : "ON");\r\nif (disable_radio) {\r\npriv->status |= STATUS_RF_KILL_SW;\r\ncancel_delayed_work(&priv->request_scan);\r\ncancel_delayed_work(&priv->request_direct_scan);\r\ncancel_delayed_work(&priv->request_passive_scan);\r\ncancel_delayed_work(&priv->scan_event);\r\nschedule_work(&priv->down);\r\n} else {\r\npriv->status &= ~STATUS_RF_KILL_SW;\r\nif (rf_kill_active(priv)) {\r\nIPW_DEBUG_RF_KILL("Can not turn radio back on - "\r\n"disabled by HW switch\n");\r\ncancel_delayed_work(&priv->rf_kill);\r\nschedule_delayed_work(&priv->rf_kill,\r\nround_jiffies_relative(2 * HZ));\r\n} else\r\nschedule_work(&priv->up);\r\n}\r\nreturn 1;\r\n}\r\nstatic ssize_t store_rf_kill(struct device *d, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ipw_priv *priv = dev_get_drvdata(d);\r\nipw_radio_kill_sw(priv, buf[0] == '1');\r\nreturn count;\r\n}\r\nstatic ssize_t show_speed_scan(struct device *d, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipw_priv *priv = dev_get_drvdata(d);\r\nint pos = 0, len = 0;\r\nif (priv->config & CFG_SPEED_SCAN) {\r\nwhile (priv->speed_scan[pos] != 0)\r\nlen += sprintf(&buf[len], "%d ",\r\npriv->speed_scan[pos++]);\r\nreturn len + sprintf(&buf[len], "\n");\r\n}\r\nreturn sprintf(buf, "0\n");\r\n}\r\nstatic ssize_t store_speed_scan(struct device *d, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ipw_priv *priv = dev_get_drvdata(d);\r\nint channel, pos = 0;\r\nconst char *p = buf;\r\nwhile ((channel = simple_strtol(p, NULL, 0))) {\r\nif (pos == MAX_SPEED_SCAN - 1) {\r\npriv->speed_scan[pos] = 0;\r\nbreak;\r\n}\r\nif (libipw_is_valid_channel(priv->ieee, channel))\r\npriv->speed_scan[pos++] = channel;\r\nelse\r\nIPW_WARNING("Skipping invalid channel request: %d\n",\r\nchannel);\r\np = strchr(p, ' ');\r\nif (!p)\r\nbreak;\r\nwhile (*p == ' ' || *p == '\t')\r\np++;\r\n}\r\nif (pos == 0)\r\npriv->config &= ~CFG_SPEED_SCAN;\r\nelse {\r\npriv->speed_scan_pos = 0;\r\npriv->config |= CFG_SPEED_SCAN;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t show_net_stats(struct device *d, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipw_priv *priv = dev_get_drvdata(d);\r\nreturn sprintf(buf, "%c\n", (priv->config & CFG_NET_STATS) ? '1' : '0');\r\n}\r\nstatic ssize_t store_net_stats(struct device *d, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ipw_priv *priv = dev_get_drvdata(d);\r\nif (buf[0] == '1')\r\npriv->config |= CFG_NET_STATS;\r\nelse\r\npriv->config &= ~CFG_NET_STATS;\r\nreturn count;\r\n}\r\nstatic ssize_t show_channels(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipw_priv *priv = dev_get_drvdata(d);\r\nconst struct libipw_geo *geo = libipw_get_geo(priv->ieee);\r\nint len = 0, i;\r\nlen = sprintf(&buf[len],\r\n"Displaying %d channels in 2.4Ghz band "\r\n"(802.11bg):\n", geo->bg_channels);\r\nfor (i = 0; i < geo->bg_channels; i++) {\r\nlen += sprintf(&buf[len], "%d: BSS%s%s, %s, Band %s.\n",\r\ngeo->bg[i].channel,\r\ngeo->bg[i].flags & LIBIPW_CH_RADAR_DETECT ?\r\n" (radar spectrum)" : "",\r\n((geo->bg[i].flags & LIBIPW_CH_NO_IBSS) ||\r\n(geo->bg[i].flags & LIBIPW_CH_RADAR_DETECT))\r\n? "" : ", IBSS",\r\ngeo->bg[i].flags & LIBIPW_CH_PASSIVE_ONLY ?\r\n"passive only" : "active/passive",\r\ngeo->bg[i].flags & LIBIPW_CH_B_ONLY ?\r\n"B" : "B/G");\r\n}\r\nlen += sprintf(&buf[len],\r\n"Displaying %d channels in 5.2Ghz band "\r\n"(802.11a):\n", geo->a_channels);\r\nfor (i = 0; i < geo->a_channels; i++) {\r\nlen += sprintf(&buf[len], "%d: BSS%s%s, %s.\n",\r\ngeo->a[i].channel,\r\ngeo->a[i].flags & LIBIPW_CH_RADAR_DETECT ?\r\n" (radar spectrum)" : "",\r\n((geo->a[i].flags & LIBIPW_CH_NO_IBSS) ||\r\n(geo->a[i].flags & LIBIPW_CH_RADAR_DETECT))\r\n? "" : ", IBSS",\r\ngeo->a[i].flags & LIBIPW_CH_PASSIVE_ONLY ?\r\n"passive only" : "active/passive");\r\n}\r\nreturn len;\r\n}\r\nstatic void notify_wx_assoc_event(struct ipw_priv *priv)\r\n{\r\nunion iwreq_data wrqu;\r\nwrqu.ap_addr.sa_family = ARPHRD_ETHER;\r\nif (priv->status & STATUS_ASSOCIATED)\r\nmemcpy(wrqu.ap_addr.sa_data, priv->bssid, ETH_ALEN);\r\nelse\r\neth_zero_addr(wrqu.ap_addr.sa_data);\r\nwireless_send_event(priv->net_dev, SIOCGIWAP, &wrqu, NULL);\r\n}\r\nstatic void ipw_irq_tasklet(struct ipw_priv *priv)\r\n{\r\nu32 inta, inta_mask, handled = 0;\r\nunsigned long flags;\r\nint rc = 0;\r\nspin_lock_irqsave(&priv->irq_lock, flags);\r\ninta = ipw_read32(priv, IPW_INTA_RW);\r\ninta_mask = ipw_read32(priv, IPW_INTA_MASK_R);\r\nif (inta == 0xFFFFFFFF) {\r\nIPW_WARNING("TASKLET INTA == 0xFFFFFFFF\n");\r\ninta = 0;\r\n}\r\ninta &= (IPW_INTA_MASK_ALL & inta_mask);\r\ninta |= priv->isr_inta;\r\nspin_unlock_irqrestore(&priv->irq_lock, flags);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (inta & IPW_INTA_BIT_RX_TRANSFER) {\r\nipw_rx(priv);\r\nhandled |= IPW_INTA_BIT_RX_TRANSFER;\r\n}\r\nif (inta & IPW_INTA_BIT_TX_CMD_QUEUE) {\r\nIPW_DEBUG_HC("Command completed.\n");\r\nrc = ipw_queue_tx_reclaim(priv, &priv->txq_cmd, -1);\r\npriv->status &= ~STATUS_HCMD_ACTIVE;\r\nwake_up_interruptible(&priv->wait_command_queue);\r\nhandled |= IPW_INTA_BIT_TX_CMD_QUEUE;\r\n}\r\nif (inta & IPW_INTA_BIT_TX_QUEUE_1) {\r\nIPW_DEBUG_TX("TX_QUEUE_1\n");\r\nrc = ipw_queue_tx_reclaim(priv, &priv->txq[0], 0);\r\nhandled |= IPW_INTA_BIT_TX_QUEUE_1;\r\n}\r\nif (inta & IPW_INTA_BIT_TX_QUEUE_2) {\r\nIPW_DEBUG_TX("TX_QUEUE_2\n");\r\nrc = ipw_queue_tx_reclaim(priv, &priv->txq[1], 1);\r\nhandled |= IPW_INTA_BIT_TX_QUEUE_2;\r\n}\r\nif (inta & IPW_INTA_BIT_TX_QUEUE_3) {\r\nIPW_DEBUG_TX("TX_QUEUE_3\n");\r\nrc = ipw_queue_tx_reclaim(priv, &priv->txq[2], 2);\r\nhandled |= IPW_INTA_BIT_TX_QUEUE_3;\r\n}\r\nif (inta & IPW_INTA_BIT_TX_QUEUE_4) {\r\nIPW_DEBUG_TX("TX_QUEUE_4\n");\r\nrc = ipw_queue_tx_reclaim(priv, &priv->txq[3], 3);\r\nhandled |= IPW_INTA_BIT_TX_QUEUE_4;\r\n}\r\nif (inta & IPW_INTA_BIT_STATUS_CHANGE) {\r\nIPW_WARNING("STATUS_CHANGE\n");\r\nhandled |= IPW_INTA_BIT_STATUS_CHANGE;\r\n}\r\nif (inta & IPW_INTA_BIT_BEACON_PERIOD_EXPIRED) {\r\nIPW_WARNING("TX_PERIOD_EXPIRED\n");\r\nhandled |= IPW_INTA_BIT_BEACON_PERIOD_EXPIRED;\r\n}\r\nif (inta & IPW_INTA_BIT_SLAVE_MODE_HOST_CMD_DONE) {\r\nIPW_WARNING("HOST_CMD_DONE\n");\r\nhandled |= IPW_INTA_BIT_SLAVE_MODE_HOST_CMD_DONE;\r\n}\r\nif (inta & IPW_INTA_BIT_FW_INITIALIZATION_DONE) {\r\nIPW_WARNING("FW_INITIALIZATION_DONE\n");\r\nhandled |= IPW_INTA_BIT_FW_INITIALIZATION_DONE;\r\n}\r\nif (inta & IPW_INTA_BIT_FW_CARD_DISABLE_PHY_OFF_DONE) {\r\nIPW_WARNING("PHY_OFF_DONE\n");\r\nhandled |= IPW_INTA_BIT_FW_CARD_DISABLE_PHY_OFF_DONE;\r\n}\r\nif (inta & IPW_INTA_BIT_RF_KILL_DONE) {\r\nIPW_DEBUG_RF_KILL("RF_KILL_DONE\n");\r\npriv->status |= STATUS_RF_KILL_HW;\r\nwiphy_rfkill_set_hw_state(priv->ieee->wdev.wiphy, true);\r\nwake_up_interruptible(&priv->wait_command_queue);\r\npriv->status &= ~(STATUS_ASSOCIATED | STATUS_ASSOCIATING);\r\ncancel_delayed_work(&priv->request_scan);\r\ncancel_delayed_work(&priv->request_direct_scan);\r\ncancel_delayed_work(&priv->request_passive_scan);\r\ncancel_delayed_work(&priv->scan_event);\r\nschedule_work(&priv->link_down);\r\nschedule_delayed_work(&priv->rf_kill, 2 * HZ);\r\nhandled |= IPW_INTA_BIT_RF_KILL_DONE;\r\n}\r\nif (inta & IPW_INTA_BIT_FATAL_ERROR) {\r\nIPW_WARNING("Firmware error detected. Restarting.\n");\r\nif (priv->error) {\r\nIPW_DEBUG_FW("Sysfs 'error' log already exists.\n");\r\nif (ipw_debug_level & IPW_DL_FW_ERRORS) {\r\nstruct ipw_fw_error *error =\r\nipw_alloc_error_log(priv);\r\nipw_dump_error_log(priv, error);\r\nkfree(error);\r\n}\r\n} else {\r\npriv->error = ipw_alloc_error_log(priv);\r\nif (priv->error)\r\nIPW_DEBUG_FW("Sysfs 'error' log captured.\n");\r\nelse\r\nIPW_DEBUG_FW("Error allocating sysfs 'error' "\r\n"log.\n");\r\nif (ipw_debug_level & IPW_DL_FW_ERRORS)\r\nipw_dump_error_log(priv, priv->error);\r\n}\r\nif (priv->ieee->sec.encrypt) {\r\npriv->status &= ~STATUS_ASSOCIATED;\r\nnotify_wx_assoc_event(priv);\r\n}\r\npriv->status &= ~STATUS_INIT;\r\npriv->status &= ~STATUS_HCMD_ACTIVE;\r\nwake_up_interruptible(&priv->wait_command_queue);\r\nschedule_work(&priv->adapter_restart);\r\nhandled |= IPW_INTA_BIT_FATAL_ERROR;\r\n}\r\nif (inta & IPW_INTA_BIT_PARITY_ERROR) {\r\nIPW_ERROR("Parity error\n");\r\nhandled |= IPW_INTA_BIT_PARITY_ERROR;\r\n}\r\nif (handled != inta) {\r\nIPW_ERROR("Unhandled INTA bits 0x%08x\n", inta & ~handled);\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nipw_enable_interrupts(priv);\r\n}\r\nstatic char *get_cmd_string(u8 cmd)\r\n{\r\nswitch (cmd) {\r\nIPW_CMD(HOST_COMPLETE);\r\nIPW_CMD(POWER_DOWN);\r\nIPW_CMD(SYSTEM_CONFIG);\r\nIPW_CMD(MULTICAST_ADDRESS);\r\nIPW_CMD(SSID);\r\nIPW_CMD(ADAPTER_ADDRESS);\r\nIPW_CMD(PORT_TYPE);\r\nIPW_CMD(RTS_THRESHOLD);\r\nIPW_CMD(FRAG_THRESHOLD);\r\nIPW_CMD(POWER_MODE);\r\nIPW_CMD(WEP_KEY);\r\nIPW_CMD(TGI_TX_KEY);\r\nIPW_CMD(SCAN_REQUEST);\r\nIPW_CMD(SCAN_REQUEST_EXT);\r\nIPW_CMD(ASSOCIATE);\r\nIPW_CMD(SUPPORTED_RATES);\r\nIPW_CMD(SCAN_ABORT);\r\nIPW_CMD(TX_FLUSH);\r\nIPW_CMD(QOS_PARAMETERS);\r\nIPW_CMD(DINO_CONFIG);\r\nIPW_CMD(RSN_CAPABILITIES);\r\nIPW_CMD(RX_KEY);\r\nIPW_CMD(CARD_DISABLE);\r\nIPW_CMD(SEED_NUMBER);\r\nIPW_CMD(TX_POWER);\r\nIPW_CMD(COUNTRY_INFO);\r\nIPW_CMD(AIRONET_INFO);\r\nIPW_CMD(AP_TX_POWER);\r\nIPW_CMD(CCKM_INFO);\r\nIPW_CMD(CCX_VER_INFO);\r\nIPW_CMD(SET_CALIBRATION);\r\nIPW_CMD(SENSITIVITY_CALIB);\r\nIPW_CMD(RETRY_LIMIT);\r\nIPW_CMD(IPW_PRE_POWER_DOWN);\r\nIPW_CMD(VAP_BEACON_TEMPLATE);\r\nIPW_CMD(VAP_DTIM_PERIOD);\r\nIPW_CMD(EXT_SUPPORTED_RATES);\r\nIPW_CMD(VAP_LOCAL_TX_PWR_CONSTRAINT);\r\nIPW_CMD(VAP_QUIET_INTERVALS);\r\nIPW_CMD(VAP_CHANNEL_SWITCH);\r\nIPW_CMD(VAP_MANDATORY_CHANNELS);\r\nIPW_CMD(VAP_CELL_PWR_LIMIT);\r\nIPW_CMD(VAP_CF_PARAM_SET);\r\nIPW_CMD(VAP_SET_BEACONING_STATE);\r\nIPW_CMD(MEASUREMENT);\r\nIPW_CMD(POWER_CAPABILITY);\r\nIPW_CMD(SUPPORTED_CHANNELS);\r\nIPW_CMD(TPC_REPORT);\r\nIPW_CMD(WME_INFO);\r\nIPW_CMD(PRODUCTION_COMMAND);\r\ndefault:\r\nreturn "UNKNOWN";\r\n}\r\n}\r\nstatic int __ipw_send_cmd(struct ipw_priv *priv, struct host_cmd *cmd)\r\n{\r\nint rc = 0;\r\nunsigned long flags;\r\nunsigned long now, end;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->status & STATUS_HCMD_ACTIVE) {\r\nIPW_ERROR("Failed to send %s: Already sending a command.\n",\r\nget_cmd_string(cmd->cmd));\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn -EAGAIN;\r\n}\r\npriv->status |= STATUS_HCMD_ACTIVE;\r\nif (priv->cmdlog) {\r\npriv->cmdlog[priv->cmdlog_pos].jiffies = jiffies;\r\npriv->cmdlog[priv->cmdlog_pos].cmd.cmd = cmd->cmd;\r\npriv->cmdlog[priv->cmdlog_pos].cmd.len = cmd->len;\r\nmemcpy(priv->cmdlog[priv->cmdlog_pos].cmd.param, cmd->param,\r\ncmd->len);\r\npriv->cmdlog[priv->cmdlog_pos].retcode = -1;\r\n}\r\nIPW_DEBUG_HC("%s command (#%d) %d bytes: 0x%08X\n",\r\nget_cmd_string(cmd->cmd), cmd->cmd, cmd->len,\r\npriv->status);\r\n#ifndef DEBUG_CMD_WEP_KEY\r\nif (cmd->cmd == IPW_CMD_WEP_KEY)\r\nIPW_DEBUG_HC("WEP_KEY command masked out for secure.\n");\r\nelse\r\n#endif\r\nprintk_buf(IPW_DL_HOST_COMMAND, (u8 *) cmd->param, cmd->len);\r\nrc = ipw_queue_tx_hcmd(priv, cmd->cmd, cmd->param, cmd->len, 0);\r\nif (rc) {\r\npriv->status &= ~STATUS_HCMD_ACTIVE;\r\nIPW_ERROR("Failed to send %s: Reason %d\n",\r\nget_cmd_string(cmd->cmd), rc);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ngoto exit;\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nnow = jiffies;\r\nend = now + HOST_COMPLETE_TIMEOUT;\r\nagain:\r\nrc = wait_event_interruptible_timeout(priv->wait_command_queue,\r\n!(priv->\r\nstatus & STATUS_HCMD_ACTIVE),\r\nend - now);\r\nif (rc < 0) {\r\nnow = jiffies;\r\nif (time_before(now, end))\r\ngoto again;\r\nrc = 0;\r\n}\r\nif (rc == 0) {\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->status & STATUS_HCMD_ACTIVE) {\r\nIPW_ERROR("Failed to send %s: Command timed out.\n",\r\nget_cmd_string(cmd->cmd));\r\npriv->status &= ~STATUS_HCMD_ACTIVE;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nrc = -EIO;\r\ngoto exit;\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n} else\r\nrc = 0;\r\nif (priv->status & STATUS_RF_KILL_HW) {\r\nIPW_ERROR("Failed to send %s: Aborted due to RF kill switch.\n",\r\nget_cmd_string(cmd->cmd));\r\nrc = -EIO;\r\ngoto exit;\r\n}\r\nexit:\r\nif (priv->cmdlog) {\r\npriv->cmdlog[priv->cmdlog_pos++].retcode = rc;\r\npriv->cmdlog_pos %= priv->cmdlog_len;\r\n}\r\nreturn rc;\r\n}\r\nstatic int ipw_send_cmd_simple(struct ipw_priv *priv, u8 command)\r\n{\r\nstruct host_cmd cmd = {\r\n.cmd = command,\r\n};\r\nreturn __ipw_send_cmd(priv, &cmd);\r\n}\r\nstatic int ipw_send_cmd_pdu(struct ipw_priv *priv, u8 command, u8 len,\r\nvoid *data)\r\n{\r\nstruct host_cmd cmd = {\r\n.cmd = command,\r\n.len = len,\r\n.param = data,\r\n};\r\nreturn __ipw_send_cmd(priv, &cmd);\r\n}\r\nstatic int ipw_send_host_complete(struct ipw_priv *priv)\r\n{\r\nif (!priv) {\r\nIPW_ERROR("Invalid args\n");\r\nreturn -1;\r\n}\r\nreturn ipw_send_cmd_simple(priv, IPW_CMD_HOST_COMPLETE);\r\n}\r\nstatic int ipw_send_system_config(struct ipw_priv *priv)\r\n{\r\nreturn ipw_send_cmd_pdu(priv, IPW_CMD_SYSTEM_CONFIG,\r\nsizeof(priv->sys_config),\r\n&priv->sys_config);\r\n}\r\nstatic int ipw_send_ssid(struct ipw_priv *priv, u8 * ssid, int len)\r\n{\r\nif (!priv || !ssid) {\r\nIPW_ERROR("Invalid args\n");\r\nreturn -1;\r\n}\r\nreturn ipw_send_cmd_pdu(priv, IPW_CMD_SSID, min(len, IW_ESSID_MAX_SIZE),\r\nssid);\r\n}\r\nstatic int ipw_send_adapter_address(struct ipw_priv *priv, u8 * mac)\r\n{\r\nif (!priv || !mac) {\r\nIPW_ERROR("Invalid args\n");\r\nreturn -1;\r\n}\r\nIPW_DEBUG_INFO("%s: Setting MAC to %pM\n",\r\npriv->net_dev->name, mac);\r\nreturn ipw_send_cmd_pdu(priv, IPW_CMD_ADAPTER_ADDRESS, ETH_ALEN, mac);\r\n}\r\nstatic void ipw_adapter_restart(void *adapter)\r\n{\r\nstruct ipw_priv *priv = adapter;\r\nif (priv->status & STATUS_RF_KILL_MASK)\r\nreturn;\r\nipw_down(priv);\r\nif (priv->assoc_network &&\r\n(priv->assoc_network->capability & WLAN_CAPABILITY_IBSS))\r\nipw_remove_current_network(priv);\r\nif (ipw_up(priv)) {\r\nIPW_ERROR("Failed to up device\n");\r\nreturn;\r\n}\r\n}\r\nstatic void ipw_bg_adapter_restart(struct work_struct *work)\r\n{\r\nstruct ipw_priv *priv =\r\ncontainer_of(work, struct ipw_priv, adapter_restart);\r\nmutex_lock(&priv->mutex);\r\nipw_adapter_restart(priv);\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic void ipw_scan_check(void *data)\r\n{\r\nstruct ipw_priv *priv = data;\r\nif (priv->status & STATUS_SCAN_ABORTING) {\r\nIPW_DEBUG_SCAN("Scan completion watchdog resetting "\r\n"adapter after (%dms).\n",\r\njiffies_to_msecs(IPW_SCAN_CHECK_WATCHDOG));\r\nschedule_work(&priv->adapter_restart);\r\n} else if (priv->status & STATUS_SCANNING) {\r\nIPW_DEBUG_SCAN("Scan completion watchdog aborting scan "\r\n"after (%dms).\n",\r\njiffies_to_msecs(IPW_SCAN_CHECK_WATCHDOG));\r\nipw_abort_scan(priv);\r\nschedule_delayed_work(&priv->scan_check, HZ);\r\n}\r\n}\r\nstatic void ipw_bg_scan_check(struct work_struct *work)\r\n{\r\nstruct ipw_priv *priv =\r\ncontainer_of(work, struct ipw_priv, scan_check.work);\r\nmutex_lock(&priv->mutex);\r\nipw_scan_check(priv);\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic int ipw_send_scan_request_ext(struct ipw_priv *priv,\r\nstruct ipw_scan_request_ext *request)\r\n{\r\nreturn ipw_send_cmd_pdu(priv, IPW_CMD_SCAN_REQUEST_EXT,\r\nsizeof(*request), request);\r\n}\r\nstatic int ipw_send_scan_abort(struct ipw_priv *priv)\r\n{\r\nif (!priv) {\r\nIPW_ERROR("Invalid args\n");\r\nreturn -1;\r\n}\r\nreturn ipw_send_cmd_simple(priv, IPW_CMD_SCAN_ABORT);\r\n}\r\nstatic int ipw_set_sensitivity(struct ipw_priv *priv, u16 sens)\r\n{\r\nstruct ipw_sensitivity_calib calib = {\r\n.beacon_rssi_raw = cpu_to_le16(sens),\r\n};\r\nreturn ipw_send_cmd_pdu(priv, IPW_CMD_SENSITIVITY_CALIB, sizeof(calib),\r\n&calib);\r\n}\r\nstatic int ipw_send_associate(struct ipw_priv *priv,\r\nstruct ipw_associate *associate)\r\n{\r\nif (!priv || !associate) {\r\nIPW_ERROR("Invalid args\n");\r\nreturn -1;\r\n}\r\nreturn ipw_send_cmd_pdu(priv, IPW_CMD_ASSOCIATE, sizeof(*associate),\r\nassociate);\r\n}\r\nstatic int ipw_send_supported_rates(struct ipw_priv *priv,\r\nstruct ipw_supported_rates *rates)\r\n{\r\nif (!priv || !rates) {\r\nIPW_ERROR("Invalid args\n");\r\nreturn -1;\r\n}\r\nreturn ipw_send_cmd_pdu(priv, IPW_CMD_SUPPORTED_RATES, sizeof(*rates),\r\nrates);\r\n}\r\nstatic int ipw_set_random_seed(struct ipw_priv *priv)\r\n{\r\nu32 val;\r\nif (!priv) {\r\nIPW_ERROR("Invalid args\n");\r\nreturn -1;\r\n}\r\nget_random_bytes(&val, sizeof(val));\r\nreturn ipw_send_cmd_pdu(priv, IPW_CMD_SEED_NUMBER, sizeof(val), &val);\r\n}\r\nstatic int ipw_send_card_disable(struct ipw_priv *priv, u32 phy_off)\r\n{\r\n__le32 v = cpu_to_le32(phy_off);\r\nif (!priv) {\r\nIPW_ERROR("Invalid args\n");\r\nreturn -1;\r\n}\r\nreturn ipw_send_cmd_pdu(priv, IPW_CMD_CARD_DISABLE, sizeof(v), &v);\r\n}\r\nstatic int ipw_send_tx_power(struct ipw_priv *priv, struct ipw_tx_power *power)\r\n{\r\nif (!priv || !power) {\r\nIPW_ERROR("Invalid args\n");\r\nreturn -1;\r\n}\r\nreturn ipw_send_cmd_pdu(priv, IPW_CMD_TX_POWER, sizeof(*power), power);\r\n}\r\nstatic int ipw_set_tx_power(struct ipw_priv *priv)\r\n{\r\nconst struct libipw_geo *geo = libipw_get_geo(priv->ieee);\r\nstruct ipw_tx_power tx_power;\r\ns8 max_power;\r\nint i;\r\nmemset(&tx_power, 0, sizeof(tx_power));\r\ntx_power.ieee_mode = IPW_G_MODE;\r\ntx_power.num_channels = geo->bg_channels;\r\nfor (i = 0; i < geo->bg_channels; i++) {\r\nmax_power = geo->bg[i].max_power;\r\ntx_power.channels_tx_power[i].channel_number =\r\ngeo->bg[i].channel;\r\ntx_power.channels_tx_power[i].tx_power = max_power ?\r\nmin(max_power, priv->tx_power) : priv->tx_power;\r\n}\r\nif (ipw_send_tx_power(priv, &tx_power))\r\nreturn -EIO;\r\ntx_power.ieee_mode = IPW_B_MODE;\r\nif (ipw_send_tx_power(priv, &tx_power))\r\nreturn -EIO;\r\nif (priv->ieee->abg_true) {\r\ntx_power.ieee_mode = IPW_A_MODE;\r\ntx_power.num_channels = geo->a_channels;\r\nfor (i = 0; i < tx_power.num_channels; i++) {\r\nmax_power = geo->a[i].max_power;\r\ntx_power.channels_tx_power[i].channel_number =\r\ngeo->a[i].channel;\r\ntx_power.channels_tx_power[i].tx_power = max_power ?\r\nmin(max_power, priv->tx_power) : priv->tx_power;\r\n}\r\nif (ipw_send_tx_power(priv, &tx_power))\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ipw_send_rts_threshold(struct ipw_priv *priv, u16 rts)\r\n{\r\nstruct ipw_rts_threshold rts_threshold = {\r\n.rts_threshold = cpu_to_le16(rts),\r\n};\r\nif (!priv) {\r\nIPW_ERROR("Invalid args\n");\r\nreturn -1;\r\n}\r\nreturn ipw_send_cmd_pdu(priv, IPW_CMD_RTS_THRESHOLD,\r\nsizeof(rts_threshold), &rts_threshold);\r\n}\r\nstatic int ipw_send_frag_threshold(struct ipw_priv *priv, u16 frag)\r\n{\r\nstruct ipw_frag_threshold frag_threshold = {\r\n.frag_threshold = cpu_to_le16(frag),\r\n};\r\nif (!priv) {\r\nIPW_ERROR("Invalid args\n");\r\nreturn -1;\r\n}\r\nreturn ipw_send_cmd_pdu(priv, IPW_CMD_FRAG_THRESHOLD,\r\nsizeof(frag_threshold), &frag_threshold);\r\n}\r\nstatic int ipw_send_power_mode(struct ipw_priv *priv, u32 mode)\r\n{\r\n__le32 param;\r\nif (!priv) {\r\nIPW_ERROR("Invalid args\n");\r\nreturn -1;\r\n}\r\nswitch (mode) {\r\ncase IPW_POWER_BATTERY:\r\nparam = cpu_to_le32(IPW_POWER_INDEX_3);\r\nbreak;\r\ncase IPW_POWER_AC:\r\nparam = cpu_to_le32(IPW_POWER_MODE_CAM);\r\nbreak;\r\ndefault:\r\nparam = cpu_to_le32(mode);\r\nbreak;\r\n}\r\nreturn ipw_send_cmd_pdu(priv, IPW_CMD_POWER_MODE, sizeof(param),\r\n&param);\r\n}\r\nstatic int ipw_send_retry_limit(struct ipw_priv *priv, u8 slimit, u8 llimit)\r\n{\r\nstruct ipw_retry_limit retry_limit = {\r\n.short_retry_limit = slimit,\r\n.long_retry_limit = llimit\r\n};\r\nif (!priv) {\r\nIPW_ERROR("Invalid args\n");\r\nreturn -1;\r\n}\r\nreturn ipw_send_cmd_pdu(priv, IPW_CMD_RETRY_LIMIT, sizeof(retry_limit),\r\n&retry_limit);\r\n}\r\nstatic inline void eeprom_write_reg(struct ipw_priv *p, u32 data)\r\n{\r\nipw_write_reg32(p, FW_MEM_REG_EEPROM_ACCESS, data);\r\nudelay(p->eeprom_delay);\r\n}\r\nstatic void eeprom_cs(struct ipw_priv *priv)\r\n{\r\neeprom_write_reg(priv, 0);\r\neeprom_write_reg(priv, EEPROM_BIT_CS);\r\neeprom_write_reg(priv, EEPROM_BIT_CS | EEPROM_BIT_SK);\r\neeprom_write_reg(priv, EEPROM_BIT_CS);\r\n}\r\nstatic void eeprom_disable_cs(struct ipw_priv *priv)\r\n{\r\neeprom_write_reg(priv, EEPROM_BIT_CS);\r\neeprom_write_reg(priv, 0);\r\neeprom_write_reg(priv, EEPROM_BIT_SK);\r\n}\r\nstatic inline void eeprom_write_bit(struct ipw_priv *p, u8 bit)\r\n{\r\nint d = (bit ? EEPROM_BIT_DI : 0);\r\neeprom_write_reg(p, EEPROM_BIT_CS | d);\r\neeprom_write_reg(p, EEPROM_BIT_CS | d | EEPROM_BIT_SK);\r\n}\r\nstatic void eeprom_op(struct ipw_priv *priv, u8 op, u8 addr)\r\n{\r\nint i;\r\neeprom_cs(priv);\r\neeprom_write_bit(priv, 1);\r\neeprom_write_bit(priv, op & 2);\r\neeprom_write_bit(priv, op & 1);\r\nfor (i = 7; i >= 0; i--) {\r\neeprom_write_bit(priv, addr & (1 << i));\r\n}\r\n}\r\nstatic u16 eeprom_read_u16(struct ipw_priv *priv, u8 addr)\r\n{\r\nint i;\r\nu16 r = 0;\r\neeprom_op(priv, EEPROM_CMD_READ, addr);\r\neeprom_write_reg(priv, EEPROM_BIT_CS);\r\nfor (i = 0; i < 16; i++) {\r\nu32 data = 0;\r\neeprom_write_reg(priv, EEPROM_BIT_CS | EEPROM_BIT_SK);\r\neeprom_write_reg(priv, EEPROM_BIT_CS);\r\ndata = ipw_read_reg32(priv, FW_MEM_REG_EEPROM_ACCESS);\r\nr = (r << 1) | ((data & EEPROM_BIT_DO) ? 1 : 0);\r\n}\r\neeprom_write_reg(priv, 0);\r\neeprom_disable_cs(priv);\r\nreturn r;\r\n}\r\nstatic void eeprom_parse_mac(struct ipw_priv *priv, u8 * mac)\r\n{\r\nmemcpy(mac, &priv->eeprom[EEPROM_MAC_ADDRESS], ETH_ALEN);\r\n}\r\nstatic void ipw_read_eeprom(struct ipw_priv *priv)\r\n{\r\nint i;\r\n__le16 *eeprom = (__le16 *) priv->eeprom;\r\nIPW_DEBUG_TRACE(">>\n");\r\nfor (i = 0; i < 128; i++)\r\neeprom[i] = cpu_to_le16(eeprom_read_u16(priv, (u8) i));\r\nIPW_DEBUG_TRACE("<<\n");\r\n}\r\nstatic void ipw_eeprom_init_sram(struct ipw_priv *priv)\r\n{\r\nint i;\r\nIPW_DEBUG_TRACE(">>\n");\r\nif (priv->eeprom[EEPROM_VERSION] != 0) {\r\nIPW_DEBUG_INFO("Writing EEPROM data into SRAM\n");\r\nfor (i = 0; i < IPW_EEPROM_IMAGE_SIZE; i++)\r\nipw_write8(priv, IPW_EEPROM_DATA + i, priv->eeprom[i]);\r\nipw_write32(priv, IPW_EEPROM_LOAD_DISABLE, 0);\r\n} else {\r\nIPW_DEBUG_INFO("Enabling FW initializationg of SRAM\n");\r\nipw_write32(priv, IPW_EEPROM_LOAD_DISABLE, 1);\r\n}\r\nIPW_DEBUG_TRACE("<<\n");\r\n}\r\nstatic void ipw_zero_memory(struct ipw_priv *priv, u32 start, u32 count)\r\n{\r\ncount >>= 2;\r\nif (!count)\r\nreturn;\r\n_ipw_write32(priv, IPW_AUTOINC_ADDR, start);\r\nwhile (count--)\r\n_ipw_write32(priv, IPW_AUTOINC_DATA, 0);\r\n}\r\nstatic inline void ipw_fw_dma_reset_command_blocks(struct ipw_priv *priv)\r\n{\r\nipw_zero_memory(priv, IPW_SHARED_SRAM_DMA_CONTROL,\r\nCB_NUMBER_OF_ELEMENTS_SMALL *\r\nsizeof(struct command_block));\r\n}\r\nstatic int ipw_fw_dma_enable(struct ipw_priv *priv)\r\n{\r\nIPW_DEBUG_FW(">> :\n");\r\nipw_fw_dma_reset_command_blocks(priv);\r\nipw_write_reg32(priv, IPW_DMA_I_CB_BASE, IPW_SHARED_SRAM_DMA_CONTROL);\r\nIPW_DEBUG_FW("<< :\n");\r\nreturn 0;\r\n}\r\nstatic void ipw_fw_dma_abort(struct ipw_priv *priv)\r\n{\r\nu32 control = 0;\r\nIPW_DEBUG_FW(">> :\n");\r\ncontrol = DMA_CONTROL_SMALL_CB_CONST_VALUE | DMA_CB_STOP_AND_ABORT;\r\nipw_write_reg32(priv, IPW_DMA_I_DMA_CONTROL, control);\r\npriv->sram_desc.last_cb_index = 0;\r\nIPW_DEBUG_FW("<<\n");\r\n}\r\nstatic int ipw_fw_dma_write_command_block(struct ipw_priv *priv, int index,\r\nstruct command_block *cb)\r\n{\r\nu32 address =\r\nIPW_SHARED_SRAM_DMA_CONTROL +\r\n(sizeof(struct command_block) * index);\r\nIPW_DEBUG_FW(">> :\n");\r\nipw_write_indirect(priv, address, (u8 *) cb,\r\n(int)sizeof(struct command_block));\r\nIPW_DEBUG_FW("<< :\n");\r\nreturn 0;\r\n}\r\nstatic int ipw_fw_dma_kick(struct ipw_priv *priv)\r\n{\r\nu32 control = 0;\r\nu32 index = 0;\r\nIPW_DEBUG_FW(">> :\n");\r\nfor (index = 0; index < priv->sram_desc.last_cb_index; index++)\r\nipw_fw_dma_write_command_block(priv, index,\r\n&priv->sram_desc.cb_list[index]);\r\nipw_clear_bit(priv, IPW_RESET_REG,\r\nIPW_RESET_REG_MASTER_DISABLED |\r\nIPW_RESET_REG_STOP_MASTER);\r\ncontrol = DMA_CONTROL_SMALL_CB_CONST_VALUE | DMA_CB_START;\r\nipw_write_reg32(priv, IPW_DMA_I_DMA_CONTROL, control);\r\nIPW_DEBUG_FW("<< :\n");\r\nreturn 0;\r\n}\r\nstatic void ipw_fw_dma_dump_command_block(struct ipw_priv *priv)\r\n{\r\nu32 address;\r\nu32 register_value = 0;\r\nu32 cb_fields_address = 0;\r\nIPW_DEBUG_FW(">> :\n");\r\naddress = ipw_read_reg32(priv, IPW_DMA_I_CURRENT_CB);\r\nIPW_DEBUG_FW_INFO("Current CB is 0x%x\n", address);\r\nregister_value = ipw_read_reg32(priv, IPW_DMA_I_DMA_CONTROL);\r\nIPW_DEBUG_FW_INFO("IPW_DMA_I_DMA_CONTROL is 0x%x\n", register_value);\r\ncb_fields_address = address;\r\nregister_value = ipw_read_reg32(priv, cb_fields_address);\r\nIPW_DEBUG_FW_INFO("Current CB Control Field is 0x%x\n", register_value);\r\ncb_fields_address += sizeof(u32);\r\nregister_value = ipw_read_reg32(priv, cb_fields_address);\r\nIPW_DEBUG_FW_INFO("Current CB Source Field is 0x%x\n", register_value);\r\ncb_fields_address += sizeof(u32);\r\nregister_value = ipw_read_reg32(priv, cb_fields_address);\r\nIPW_DEBUG_FW_INFO("Current CB Destination Field is 0x%x\n",\r\nregister_value);\r\ncb_fields_address += sizeof(u32);\r\nregister_value = ipw_read_reg32(priv, cb_fields_address);\r\nIPW_DEBUG_FW_INFO("Current CB Status Field is 0x%x\n", register_value);\r\nIPW_DEBUG_FW(">> :\n");\r\n}\r\nstatic int ipw_fw_dma_command_block_index(struct ipw_priv *priv)\r\n{\r\nu32 current_cb_address = 0;\r\nu32 current_cb_index = 0;\r\nIPW_DEBUG_FW("<< :\n");\r\ncurrent_cb_address = ipw_read_reg32(priv, IPW_DMA_I_CURRENT_CB);\r\ncurrent_cb_index = (current_cb_address - IPW_SHARED_SRAM_DMA_CONTROL) /\r\nsizeof(struct command_block);\r\nIPW_DEBUG_FW_INFO("Current CB index 0x%x address = 0x%X\n",\r\ncurrent_cb_index, current_cb_address);\r\nIPW_DEBUG_FW(">> :\n");\r\nreturn current_cb_index;\r\n}\r\nstatic int ipw_fw_dma_add_command_block(struct ipw_priv *priv,\r\nu32 src_address,\r\nu32 dest_address,\r\nu32 length,\r\nint interrupt_enabled, int is_last)\r\n{\r\nu32 control = CB_VALID | CB_SRC_LE | CB_DEST_LE | CB_SRC_AUTOINC |\r\nCB_SRC_IO_GATED | CB_DEST_AUTOINC | CB_SRC_SIZE_LONG |\r\nCB_DEST_SIZE_LONG;\r\nstruct command_block *cb;\r\nu32 last_cb_element = 0;\r\nIPW_DEBUG_FW_INFO("src_address=0x%x dest_address=0x%x length=0x%x\n",\r\nsrc_address, dest_address, length);\r\nif (priv->sram_desc.last_cb_index >= CB_NUMBER_OF_ELEMENTS_SMALL)\r\nreturn -1;\r\nlast_cb_element = priv->sram_desc.last_cb_index;\r\ncb = &priv->sram_desc.cb_list[last_cb_element];\r\npriv->sram_desc.last_cb_index++;\r\nif (interrupt_enabled)\r\ncontrol |= CB_INT_ENABLED;\r\nif (is_last)\r\ncontrol |= CB_LAST_VALID;\r\ncontrol |= length;\r\ncb->status = control ^ src_address ^ dest_address;\r\ncb->dest_addr = dest_address;\r\ncb->source_addr = src_address;\r\ncb->control = control;\r\nreturn 0;\r\n}\r\nstatic int ipw_fw_dma_add_buffer(struct ipw_priv *priv, dma_addr_t *src_address,\r\nint nr, u32 dest_address, u32 len)\r\n{\r\nint ret, i;\r\nu32 size;\r\nIPW_DEBUG_FW(">>\n");\r\nIPW_DEBUG_FW_INFO("nr=%d dest_address=0x%x len=0x%x\n",\r\nnr, dest_address, len);\r\nfor (i = 0; i < nr; i++) {\r\nsize = min_t(u32, len - i * CB_MAX_LENGTH, CB_MAX_LENGTH);\r\nret = ipw_fw_dma_add_command_block(priv, src_address[i],\r\ndest_address +\r\ni * CB_MAX_LENGTH, size,\r\n0, 0);\r\nif (ret) {\r\nIPW_DEBUG_FW_INFO(": Failed\n");\r\nreturn -1;\r\n} else\r\nIPW_DEBUG_FW_INFO(": Added new cb\n");\r\n}\r\nIPW_DEBUG_FW("<<\n");\r\nreturn 0;\r\n}\r\nstatic int ipw_fw_dma_wait(struct ipw_priv *priv)\r\n{\r\nu32 current_index = 0, previous_index;\r\nu32 watchdog = 0;\r\nIPW_DEBUG_FW(">> :\n");\r\ncurrent_index = ipw_fw_dma_command_block_index(priv);\r\nIPW_DEBUG_FW_INFO("sram_desc.last_cb_index:0x%08X\n",\r\n(int)priv->sram_desc.last_cb_index);\r\nwhile (current_index < priv->sram_desc.last_cb_index) {\r\nudelay(50);\r\nprevious_index = current_index;\r\ncurrent_index = ipw_fw_dma_command_block_index(priv);\r\nif (previous_index < current_index) {\r\nwatchdog = 0;\r\ncontinue;\r\n}\r\nif (++watchdog > 400) {\r\nIPW_DEBUG_FW_INFO("Timeout\n");\r\nipw_fw_dma_dump_command_block(priv);\r\nipw_fw_dma_abort(priv);\r\nreturn -1;\r\n}\r\n}\r\nipw_fw_dma_abort(priv);\r\nipw_set_bit(priv, IPW_RESET_REG,\r\nIPW_RESET_REG_MASTER_DISABLED | IPW_RESET_REG_STOP_MASTER);\r\nIPW_DEBUG_FW("<< dmaWaitSync\n");\r\nreturn 0;\r\n}\r\nstatic void ipw_remove_current_network(struct ipw_priv *priv)\r\n{\r\nstruct list_head *element, *safe;\r\nstruct libipw_network *network = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->ieee->lock, flags);\r\nlist_for_each_safe(element, safe, &priv->ieee->network_list) {\r\nnetwork = list_entry(element, struct libipw_network, list);\r\nif (ether_addr_equal(network->bssid, priv->bssid)) {\r\nlist_del(element);\r\nlist_add_tail(&network->list,\r\n&priv->ieee->network_free_list);\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->ieee->lock, flags);\r\n}\r\nstatic inline int ipw_alive(struct ipw_priv *priv)\r\n{\r\nreturn ipw_read32(priv, 0x90) == 0xd55555d5;\r\n}\r\nstatic int ipw_poll_bit(struct ipw_priv *priv, u32 addr, u32 mask,\r\nint timeout)\r\n{\r\nint i = 0;\r\ndo {\r\nif ((ipw_read32(priv, addr) & mask) == mask)\r\nreturn i;\r\nmdelay(10);\r\ni += 10;\r\n} while (i < timeout);\r\nreturn -ETIME;\r\n}\r\nstatic int ipw_stop_master(struct ipw_priv *priv)\r\n{\r\nint rc;\r\nIPW_DEBUG_TRACE(">>\n");\r\nipw_set_bit(priv, IPW_RESET_REG, IPW_RESET_REG_STOP_MASTER);\r\nrc = ipw_poll_bit(priv, IPW_RESET_REG,\r\nIPW_RESET_REG_MASTER_DISABLED, 100);\r\nif (rc < 0) {\r\nIPW_ERROR("wait for stop master failed after 100ms\n");\r\nreturn -1;\r\n}\r\nIPW_DEBUG_INFO("stop master %dms\n", rc);\r\nreturn rc;\r\n}\r\nstatic void ipw_arc_release(struct ipw_priv *priv)\r\n{\r\nIPW_DEBUG_TRACE(">>\n");\r\nmdelay(5);\r\nipw_clear_bit(priv, IPW_RESET_REG, CBD_RESET_REG_PRINCETON_RESET);\r\nmdelay(5);\r\n}\r\nstatic int ipw_load_ucode(struct ipw_priv *priv, u8 * data, size_t len)\r\n{\r\nint rc = 0, i, addr;\r\nu8 cr = 0;\r\n__le16 *image;\r\nimage = (__le16 *) data;\r\nIPW_DEBUG_TRACE(">>\n");\r\nrc = ipw_stop_master(priv);\r\nif (rc < 0)\r\nreturn rc;\r\nfor (addr = IPW_SHARED_LOWER_BOUND;\r\naddr < IPW_REGISTER_DOMAIN1_END; addr += 4) {\r\nipw_write32(priv, addr, 0);\r\n}\r\nmemset(&priv->dino_alive, 0, sizeof(priv->dino_alive));\r\nipw_write_reg32(priv, IPW_MEM_HALT_AND_RESET, IPW_BIT_HALT_RESET_ON);\r\nipw_arc_release(priv);\r\nipw_write_reg32(priv, IPW_MEM_HALT_AND_RESET, IPW_BIT_HALT_RESET_OFF);\r\nmdelay(1);\r\nipw_write_reg32(priv, IPW_INTERNAL_CMD_EVENT, IPW_BASEBAND_POWER_DOWN);\r\nmdelay(1);\r\nipw_write_reg32(priv, IPW_INTERNAL_CMD_EVENT, 0);\r\nmdelay(1);\r\nipw_write_reg8(priv, IPW_BASEBAND_CONTROL_STATUS, 0x0);\r\nipw_write_reg8(priv, IPW_BASEBAND_CONTROL_STATUS, DINO_ENABLE_CS);\r\nmdelay(1);\r\nfor (i = 0; i < len / 2; i++)\r\nipw_write_reg16(priv, IPW_BASEBAND_CONTROL_STORE,\r\nle16_to_cpu(image[i]));\r\nipw_write_reg8(priv, IPW_BASEBAND_CONTROL_STATUS, 0);\r\nipw_write_reg8(priv, IPW_BASEBAND_CONTROL_STATUS, DINO_ENABLE_SYSTEM);\r\nfor (i = 0; i < 100; i++) {\r\ncr = ipw_read_reg8(priv, IPW_BASEBAND_CONTROL_STATUS);\r\nif (cr & DINO_RXFIFO_DATA)\r\nbreak;\r\nmdelay(1);\r\n}\r\nif (cr & DINO_RXFIFO_DATA) {\r\n__le32 response_buffer[(sizeof(priv->dino_alive) + 3) / 4];\r\nfor (i = 0; i < ARRAY_SIZE(response_buffer); i++)\r\nresponse_buffer[i] =\r\ncpu_to_le32(ipw_read_reg32(priv,\r\nIPW_BASEBAND_RX_FIFO_READ));\r\nmemcpy(&priv->dino_alive, response_buffer,\r\nsizeof(priv->dino_alive));\r\nif (priv->dino_alive.alive_command == 1\r\n&& priv->dino_alive.ucode_valid == 1) {\r\nrc = 0;\r\nIPW_DEBUG_INFO\r\n("Microcode OK, rev. %d (0x%x) dev. %d (0x%x) "\r\n"of %02d/%02d/%02d %02d:%02d\n",\r\npriv->dino_alive.software_revision,\r\npriv->dino_alive.software_revision,\r\npriv->dino_alive.device_identifier,\r\npriv->dino_alive.device_identifier,\r\npriv->dino_alive.time_stamp[0],\r\npriv->dino_alive.time_stamp[1],\r\npriv->dino_alive.time_stamp[2],\r\npriv->dino_alive.time_stamp[3],\r\npriv->dino_alive.time_stamp[4]);\r\n} else {\r\nIPW_DEBUG_INFO("Microcode is not alive\n");\r\nrc = -EINVAL;\r\n}\r\n} else {\r\nIPW_DEBUG_INFO("No alive response from DINO\n");\r\nrc = -ETIME;\r\n}\r\nipw_write_reg8(priv, IPW_BASEBAND_CONTROL_STATUS, 0);\r\nreturn rc;\r\n}\r\nstatic int ipw_load_firmware(struct ipw_priv *priv, u8 * data, size_t len)\r\n{\r\nint ret = -1;\r\nint offset = 0;\r\nstruct fw_chunk *chunk;\r\nint total_nr = 0;\r\nint i;\r\nstruct pci_pool *pool;\r\nvoid **virts;\r\ndma_addr_t *phys;\r\nIPW_DEBUG_TRACE("<< :\n");\r\nvirts = kmalloc(sizeof(void *) * CB_NUMBER_OF_ELEMENTS_SMALL,\r\nGFP_KERNEL);\r\nif (!virts)\r\nreturn -ENOMEM;\r\nphys = kmalloc(sizeof(dma_addr_t) * CB_NUMBER_OF_ELEMENTS_SMALL,\r\nGFP_KERNEL);\r\nif (!phys) {\r\nkfree(virts);\r\nreturn -ENOMEM;\r\n}\r\npool = pci_pool_create("ipw2200", priv->pci_dev, CB_MAX_LENGTH, 0, 0);\r\nif (!pool) {\r\nIPW_ERROR("pci_pool_create failed\n");\r\nkfree(phys);\r\nkfree(virts);\r\nreturn -ENOMEM;\r\n}\r\nret = ipw_fw_dma_enable(priv);\r\nBUG_ON(priv->sram_desc.last_cb_index > 0);\r\ndo {\r\nu32 chunk_len;\r\nu8 *start;\r\nint size;\r\nint nr = 0;\r\nchunk = (struct fw_chunk *)(data + offset);\r\noffset += sizeof(struct fw_chunk);\r\nchunk_len = le32_to_cpu(chunk->length);\r\nstart = data + offset;\r\nnr = (chunk_len + CB_MAX_LENGTH - 1) / CB_MAX_LENGTH;\r\nfor (i = 0; i < nr; i++) {\r\nvirts[total_nr] = pci_pool_alloc(pool, GFP_KERNEL,\r\n&phys[total_nr]);\r\nif (!virts[total_nr]) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nsize = min_t(u32, chunk_len - i * CB_MAX_LENGTH,\r\nCB_MAX_LENGTH);\r\nmemcpy(virts[total_nr], start, size);\r\nstart += size;\r\ntotal_nr++;\r\nBUG_ON(total_nr > CB_NUMBER_OF_ELEMENTS_SMALL);\r\n}\r\nret = ipw_fw_dma_add_buffer(priv, &phys[total_nr - nr],\r\nnr, le32_to_cpu(chunk->address),\r\nchunk_len);\r\nif (ret) {\r\nIPW_DEBUG_INFO("dmaAddBuffer Failed\n");\r\ngoto out;\r\n}\r\noffset += chunk_len;\r\n} while (offset < len);\r\nret = ipw_fw_dma_kick(priv);\r\nif (ret) {\r\nIPW_ERROR("dmaKick Failed\n");\r\ngoto out;\r\n}\r\nret = ipw_fw_dma_wait(priv);\r\nif (ret) {\r\nIPW_ERROR("dmaWaitSync Failed\n");\r\ngoto out;\r\n}\r\nout:\r\nfor (i = 0; i < total_nr; i++)\r\npci_pool_free(pool, virts[i], phys[i]);\r\npci_pool_destroy(pool);\r\nkfree(phys);\r\nkfree(virts);\r\nreturn ret;\r\n}\r\nstatic int ipw_stop_nic(struct ipw_priv *priv)\r\n{\r\nint rc = 0;\r\nipw_write32(priv, IPW_RESET_REG, IPW_RESET_REG_STOP_MASTER);\r\nrc = ipw_poll_bit(priv, IPW_RESET_REG,\r\nIPW_RESET_REG_MASTER_DISABLED, 500);\r\nif (rc < 0) {\r\nIPW_ERROR("wait for reg master disabled failed after 500ms\n");\r\nreturn rc;\r\n}\r\nipw_set_bit(priv, IPW_RESET_REG, CBD_RESET_REG_PRINCETON_RESET);\r\nreturn rc;\r\n}\r\nstatic void ipw_start_nic(struct ipw_priv *priv)\r\n{\r\nIPW_DEBUG_TRACE(">>\n");\r\nipw_clear_bit(priv, IPW_RESET_REG,\r\nIPW_RESET_REG_MASTER_DISABLED |\r\nIPW_RESET_REG_STOP_MASTER |\r\nCBD_RESET_REG_PRINCETON_RESET);\r\nipw_set_bit(priv, IPW_GP_CNTRL_RW,\r\nIPW_GP_CNTRL_BIT_HOST_ALLOWS_STANDBY);\r\nIPW_DEBUG_TRACE("<<\n");\r\n}\r\nstatic int ipw_init_nic(struct ipw_priv *priv)\r\n{\r\nint rc;\r\nIPW_DEBUG_TRACE(">>\n");\r\nipw_set_bit(priv, IPW_GP_CNTRL_RW, IPW_GP_CNTRL_BIT_INIT_DONE);\r\nipw_write32(priv, IPW_READ_INT_REGISTER,\r\nIPW_BIT_INT_HOST_SRAM_READ_INT_REGISTER);\r\nrc = ipw_poll_bit(priv, IPW_GP_CNTRL_RW,\r\nIPW_GP_CNTRL_BIT_CLOCK_READY, 250);\r\nif (rc < 0)\r\nIPW_DEBUG_INFO("FAILED wait for clock stablization\n");\r\nipw_set_bit(priv, IPW_RESET_REG, IPW_RESET_REG_SW_RESET);\r\nudelay(10);\r\nipw_set_bit(priv, IPW_GP_CNTRL_RW, IPW_GP_CNTRL_BIT_INIT_DONE);\r\nIPW_DEBUG_TRACE(">>\n");\r\nreturn 0;\r\n}\r\nstatic int ipw_reset_nic(struct ipw_priv *priv)\r\n{\r\nint rc = 0;\r\nunsigned long flags;\r\nIPW_DEBUG_TRACE(">>\n");\r\nrc = ipw_init_nic(priv);\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->status &= ~STATUS_HCMD_ACTIVE;\r\nwake_up_interruptible(&priv->wait_command_queue);\r\npriv->status &= ~(STATUS_SCANNING | STATUS_SCAN_ABORTING);\r\nwake_up_interruptible(&priv->wait_state);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nIPW_DEBUG_TRACE("<<\n");\r\nreturn rc;\r\n}\r\nstatic int ipw_get_fw(struct ipw_priv *priv,\r\nconst struct firmware **raw, const char *name)\r\n{\r\nstruct ipw_fw *fw;\r\nint rc;\r\nrc = request_firmware(raw, name, &priv->pci_dev->dev);\r\nif (rc < 0) {\r\nIPW_ERROR("%s request_firmware failed: Reason %d\n", name, rc);\r\nreturn rc;\r\n}\r\nif ((*raw)->size < sizeof(*fw)) {\r\nIPW_ERROR("%s is too small (%zd)\n", name, (*raw)->size);\r\nreturn -EINVAL;\r\n}\r\nfw = (void *)(*raw)->data;\r\nif ((*raw)->size < sizeof(*fw) + le32_to_cpu(fw->boot_size) +\r\nle32_to_cpu(fw->ucode_size) + le32_to_cpu(fw->fw_size)) {\r\nIPW_ERROR("%s is too small or corrupt (%zd)\n",\r\nname, (*raw)->size);\r\nreturn -EINVAL;\r\n}\r\nIPW_DEBUG_INFO("Read firmware '%s' image v%d.%d (%zd bytes)\n",\r\nname,\r\nle32_to_cpu(fw->ver) >> 16,\r\nle32_to_cpu(fw->ver) & 0xff,\r\n(*raw)->size - sizeof(*fw));\r\nreturn 0;\r\n}\r\nstatic void ipw_rx_queue_reset(struct ipw_priv *priv,\r\nstruct ipw_rx_queue *rxq)\r\n{\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&rxq->lock, flags);\r\nINIT_LIST_HEAD(&rxq->rx_free);\r\nINIT_LIST_HEAD(&rxq->rx_used);\r\nfor (i = 0; i < RX_FREE_BUFFERS + RX_QUEUE_SIZE; i++) {\r\nif (rxq->pool[i].skb != NULL) {\r\npci_unmap_single(priv->pci_dev, rxq->pool[i].dma_addr,\r\nIPW_RX_BUF_SIZE, PCI_DMA_FROMDEVICE);\r\ndev_kfree_skb(rxq->pool[i].skb);\r\nrxq->pool[i].skb = NULL;\r\n}\r\nlist_add_tail(&rxq->pool[i].list, &rxq->rx_used);\r\n}\r\nrxq->read = rxq->write = 0;\r\nrxq->free_count = 0;\r\nspin_unlock_irqrestore(&rxq->lock, flags);\r\n}\r\nstatic void free_firmware(void)\r\n{\r\nif (fw_loaded) {\r\nrelease_firmware(raw);\r\nraw = NULL;\r\nfw_loaded = 0;\r\n}\r\n}\r\nstatic int ipw_load(struct ipw_priv *priv)\r\n{\r\n#ifndef CONFIG_PM\r\nconst struct firmware *raw = NULL;\r\n#endif\r\nstruct ipw_fw *fw;\r\nu8 *boot_img, *ucode_img, *fw_img;\r\nu8 *name = NULL;\r\nint rc = 0, retries = 3;\r\nswitch (priv->ieee->iw_mode) {\r\ncase IW_MODE_ADHOC:\r\nname = "ipw2200-ibss.fw";\r\nbreak;\r\n#ifdef CONFIG_IPW2200_MONITOR\r\ncase IW_MODE_MONITOR:\r\nname = "ipw2200-sniffer.fw";\r\nbreak;\r\n#endif\r\ncase IW_MODE_INFRA:\r\nname = "ipw2200-bss.fw";\r\nbreak;\r\n}\r\nif (!name) {\r\nrc = -EINVAL;\r\ngoto error;\r\n}\r\n#ifdef CONFIG_PM\r\nif (!fw_loaded) {\r\n#endif\r\nrc = ipw_get_fw(priv, &raw, name);\r\nif (rc < 0)\r\ngoto error;\r\n#ifdef CONFIG_PM\r\n}\r\n#endif\r\nfw = (void *)raw->data;\r\nboot_img = &fw->data[0];\r\nucode_img = &fw->data[le32_to_cpu(fw->boot_size)];\r\nfw_img = &fw->data[le32_to_cpu(fw->boot_size) +\r\nle32_to_cpu(fw->ucode_size)];\r\nif (rc < 0)\r\ngoto error;\r\nif (!priv->rxq)\r\npriv->rxq = ipw_rx_queue_alloc(priv);\r\nelse\r\nipw_rx_queue_reset(priv, priv->rxq);\r\nif (!priv->rxq) {\r\nIPW_ERROR("Unable to initialize Rx queue\n");\r\nrc = -ENOMEM;\r\ngoto error;\r\n}\r\nretry:\r\nipw_write32(priv, IPW_INTA_MASK_R, ~IPW_INTA_MASK_ALL);\r\npriv->status &= ~STATUS_INT_ENABLED;\r\nipw_write32(priv, IPW_INTA_RW, IPW_INTA_MASK_ALL);\r\nipw_stop_nic(priv);\r\nrc = ipw_reset_nic(priv);\r\nif (rc < 0) {\r\nIPW_ERROR("Unable to reset NIC\n");\r\ngoto error;\r\n}\r\nipw_zero_memory(priv, IPW_NIC_SRAM_LOWER_BOUND,\r\nIPW_NIC_SRAM_UPPER_BOUND - IPW_NIC_SRAM_LOWER_BOUND);\r\nrc = ipw_load_firmware(priv, boot_img, le32_to_cpu(fw->boot_size));\r\nif (rc < 0) {\r\nIPW_ERROR("Unable to load boot firmware: %d\n", rc);\r\ngoto error;\r\n}\r\nipw_start_nic(priv);\r\nrc = ipw_poll_bit(priv, IPW_INTA_RW,\r\nIPW_INTA_BIT_FW_INITIALIZATION_DONE, 500);\r\nif (rc < 0) {\r\nIPW_ERROR("device failed to boot initial fw image\n");\r\ngoto error;\r\n}\r\nIPW_DEBUG_INFO("initial device response after %dms\n", rc);\r\nipw_write32(priv, IPW_INTA_RW, IPW_INTA_BIT_FW_INITIALIZATION_DONE);\r\nrc = ipw_load_ucode(priv, ucode_img, le32_to_cpu(fw->ucode_size));\r\nif (rc < 0) {\r\nIPW_ERROR("Unable to load ucode: %d\n", rc);\r\ngoto error;\r\n}\r\nipw_stop_nic(priv);\r\nrc = ipw_load_firmware(priv, fw_img, le32_to_cpu(fw->fw_size));\r\nif (rc < 0) {\r\nIPW_ERROR("Unable to load firmware: %d\n", rc);\r\ngoto error;\r\n}\r\n#ifdef CONFIG_PM\r\nfw_loaded = 1;\r\n#endif\r\nipw_write32(priv, IPW_EEPROM_LOAD_DISABLE, 0);\r\nrc = ipw_queue_reset(priv);\r\nif (rc < 0) {\r\nIPW_ERROR("Unable to initialize queues\n");\r\ngoto error;\r\n}\r\nipw_write32(priv, IPW_INTA_MASK_R, ~IPW_INTA_MASK_ALL);\r\nipw_write32(priv, IPW_INTA_RW, IPW_INTA_MASK_ALL);\r\nipw_start_nic(priv);\r\nif (ipw_read32(priv, IPW_INTA_RW) & IPW_INTA_BIT_PARITY_ERROR) {\r\nif (retries > 0) {\r\nIPW_WARNING("Parity error. Retrying init.\n");\r\nretries--;\r\ngoto retry;\r\n}\r\nIPW_ERROR("TODO: Handle parity error -- schedule restart?\n");\r\nrc = -EIO;\r\ngoto error;\r\n}\r\nrc = ipw_poll_bit(priv, IPW_INTA_RW,\r\nIPW_INTA_BIT_FW_INITIALIZATION_DONE, 500);\r\nif (rc < 0) {\r\nIPW_ERROR("device failed to start within 500ms\n");\r\ngoto error;\r\n}\r\nIPW_DEBUG_INFO("device response after %dms\n", rc);\r\nipw_write32(priv, IPW_INTA_RW, IPW_INTA_BIT_FW_INITIALIZATION_DONE);\r\npriv->eeprom_delay = 1;\r\nipw_read_eeprom(priv);\r\nipw_eeprom_init_sram(priv);\r\nipw_enable_interrupts(priv);\r\nipw_rx_queue_replenish(priv);\r\nipw_write32(priv, IPW_RX_READ_INDEX, priv->rxq->read);\r\nipw_write32(priv, IPW_INTA_RW, IPW_INTA_MASK_ALL);\r\n#ifndef CONFIG_PM\r\nrelease_firmware(raw);\r\n#endif\r\nreturn 0;\r\nerror:\r\nif (priv->rxq) {\r\nipw_rx_queue_free(priv, priv->rxq);\r\npriv->rxq = NULL;\r\n}\r\nipw_tx_queue_free(priv);\r\nrelease_firmware(raw);\r\n#ifdef CONFIG_PM\r\nfw_loaded = 0;\r\nraw = NULL;\r\n#endif\r\nreturn rc;\r\n}\r\nstatic int ipw_rx_queue_space(const struct ipw_rx_queue *q)\r\n{\r\nint s = q->read - q->write;\r\nif (s <= 0)\r\ns += RX_QUEUE_SIZE;\r\ns -= 2;\r\nif (s < 0)\r\ns = 0;\r\nreturn s;\r\n}\r\nstatic inline int ipw_tx_queue_space(const struct clx2_queue *q)\r\n{\r\nint s = q->last_used - q->first_empty;\r\nif (s <= 0)\r\ns += q->n_bd;\r\ns -= 2;\r\nif (s < 0)\r\ns = 0;\r\nreturn s;\r\n}\r\nstatic inline int ipw_queue_inc_wrap(int index, int n_bd)\r\n{\r\nreturn (++index == n_bd) ? 0 : index;\r\n}\r\nstatic void ipw_queue_init(struct ipw_priv *priv, struct clx2_queue *q,\r\nint count, u32 read, u32 write, u32 base, u32 size)\r\n{\r\nq->n_bd = count;\r\nq->low_mark = q->n_bd / 4;\r\nif (q->low_mark < 4)\r\nq->low_mark = 4;\r\nq->high_mark = q->n_bd / 8;\r\nif (q->high_mark < 2)\r\nq->high_mark = 2;\r\nq->first_empty = q->last_used = 0;\r\nq->reg_r = read;\r\nq->reg_w = write;\r\nipw_write32(priv, base, q->dma_addr);\r\nipw_write32(priv, size, count);\r\nipw_write32(priv, read, 0);\r\nipw_write32(priv, write, 0);\r\n_ipw_read32(priv, 0x90);\r\n}\r\nstatic int ipw_queue_tx_init(struct ipw_priv *priv,\r\nstruct clx2_tx_queue *q,\r\nint count, u32 read, u32 write, u32 base, u32 size)\r\n{\r\nstruct pci_dev *dev = priv->pci_dev;\r\nq->txb = kmalloc(sizeof(q->txb[0]) * count, GFP_KERNEL);\r\nif (!q->txb) {\r\nIPW_ERROR("vmalloc for auxiliary BD structures failed\n");\r\nreturn -ENOMEM;\r\n}\r\nq->bd =\r\npci_alloc_consistent(dev, sizeof(q->bd[0]) * count, &q->q.dma_addr);\r\nif (!q->bd) {\r\nIPW_ERROR("pci_alloc_consistent(%zd) failed\n",\r\nsizeof(q->bd[0]) * count);\r\nkfree(q->txb);\r\nq->txb = NULL;\r\nreturn -ENOMEM;\r\n}\r\nipw_queue_init(priv, &q->q, count, read, write, base, size);\r\nreturn 0;\r\n}\r\nstatic void ipw_queue_tx_free_tfd(struct ipw_priv *priv,\r\nstruct clx2_tx_queue *txq)\r\n{\r\nstruct tfd_frame *bd = &txq->bd[txq->q.last_used];\r\nstruct pci_dev *dev = priv->pci_dev;\r\nint i;\r\nif (bd->control_flags.message_type == TX_HOST_COMMAND_TYPE)\r\nreturn;\r\nif (le32_to_cpu(bd->u.data.num_chunks) > NUM_TFD_CHUNKS) {\r\nIPW_ERROR("Too many chunks: %i\n",\r\nle32_to_cpu(bd->u.data.num_chunks));\r\nreturn;\r\n}\r\nfor (i = 0; i < le32_to_cpu(bd->u.data.num_chunks); i++) {\r\npci_unmap_single(dev, le32_to_cpu(bd->u.data.chunk_ptr[i]),\r\nle16_to_cpu(bd->u.data.chunk_len[i]),\r\nPCI_DMA_TODEVICE);\r\nif (txq->txb[txq->q.last_used]) {\r\nlibipw_txb_free(txq->txb[txq->q.last_used]);\r\ntxq->txb[txq->q.last_used] = NULL;\r\n}\r\n}\r\n}\r\nstatic void ipw_queue_tx_free(struct ipw_priv *priv, struct clx2_tx_queue *txq)\r\n{\r\nstruct clx2_queue *q = &txq->q;\r\nstruct pci_dev *dev = priv->pci_dev;\r\nif (q->n_bd == 0)\r\nreturn;\r\nfor (; q->first_empty != q->last_used;\r\nq->last_used = ipw_queue_inc_wrap(q->last_used, q->n_bd)) {\r\nipw_queue_tx_free_tfd(priv, txq);\r\n}\r\npci_free_consistent(dev, sizeof(txq->bd[0]) * q->n_bd, txq->bd,\r\nq->dma_addr);\r\nkfree(txq->txb);\r\nmemset(txq, 0, sizeof(*txq));\r\n}\r\nstatic void ipw_tx_queue_free(struct ipw_priv *priv)\r\n{\r\nipw_queue_tx_free(priv, &priv->txq_cmd);\r\nipw_queue_tx_free(priv, &priv->txq[0]);\r\nipw_queue_tx_free(priv, &priv->txq[1]);\r\nipw_queue_tx_free(priv, &priv->txq[2]);\r\nipw_queue_tx_free(priv, &priv->txq[3]);\r\n}\r\nstatic void ipw_create_bssid(struct ipw_priv *priv, u8 * bssid)\r\n{\r\nbssid[0] = priv->mac_addr[0];\r\nbssid[1] = priv->mac_addr[1];\r\nbssid[2] = priv->mac_addr[2];\r\nget_random_bytes(&bssid[3], ETH_ALEN - 3);\r\nbssid[0] &= 0xfe;\r\nbssid[0] |= 0x02;\r\n}\r\nstatic u8 ipw_add_station(struct ipw_priv *priv, u8 * bssid)\r\n{\r\nstruct ipw_station_entry entry;\r\nint i;\r\nfor (i = 0; i < priv->num_stations; i++) {\r\nif (ether_addr_equal(priv->stations[i], bssid)) {\r\npriv->missed_adhoc_beacons = 0;\r\nif (!(priv->config & CFG_STATIC_CHANNEL))\r\npriv->config &= ~CFG_ADHOC_PERSIST;\r\nreturn i;\r\n}\r\n}\r\nif (i == MAX_STATIONS)\r\nreturn IPW_INVALID_STATION;\r\nIPW_DEBUG_SCAN("Adding AdHoc station: %pM\n", bssid);\r\nentry.reserved = 0;\r\nentry.support_mode = 0;\r\nmemcpy(entry.mac_addr, bssid, ETH_ALEN);\r\nmemcpy(priv->stations[i], bssid, ETH_ALEN);\r\nipw_write_direct(priv, IPW_STATION_TABLE_LOWER + i * sizeof(entry),\r\n&entry, sizeof(entry));\r\npriv->num_stations++;\r\nreturn i;\r\n}\r\nstatic u8 ipw_find_station(struct ipw_priv *priv, u8 * bssid)\r\n{\r\nint i;\r\nfor (i = 0; i < priv->num_stations; i++)\r\nif (ether_addr_equal(priv->stations[i], bssid))\r\nreturn i;\r\nreturn IPW_INVALID_STATION;\r\n}\r\nstatic void ipw_send_disassociate(struct ipw_priv *priv, int quiet)\r\n{\r\nint err;\r\nif (priv->status & STATUS_ASSOCIATING) {\r\nIPW_DEBUG_ASSOC("Disassociating while associating.\n");\r\nschedule_work(&priv->disassociate);\r\nreturn;\r\n}\r\nif (!(priv->status & STATUS_ASSOCIATED)) {\r\nIPW_DEBUG_ASSOC("Disassociating while not associated.\n");\r\nreturn;\r\n}\r\nIPW_DEBUG_ASSOC("Disassocation attempt from %pM "\r\n"on channel %d.\n",\r\npriv->assoc_request.bssid,\r\npriv->assoc_request.channel);\r\npriv->status &= ~(STATUS_ASSOCIATING | STATUS_ASSOCIATED);\r\npriv->status |= STATUS_DISASSOCIATING;\r\nif (quiet)\r\npriv->assoc_request.assoc_type = HC_DISASSOC_QUIET;\r\nelse\r\npriv->assoc_request.assoc_type = HC_DISASSOCIATE;\r\nerr = ipw_send_associate(priv, &priv->assoc_request);\r\nif (err) {\r\nIPW_DEBUG_HC("Attempt to send [dis]associate command "\r\n"failed.\n");\r\nreturn;\r\n}\r\n}\r\nstatic int ipw_disassociate(void *data)\r\n{\r\nstruct ipw_priv *priv = data;\r\nif (!(priv->status & (STATUS_ASSOCIATED | STATUS_ASSOCIATING)))\r\nreturn 0;\r\nipw_send_disassociate(data, 0);\r\nnetif_carrier_off(priv->net_dev);\r\nreturn 1;\r\n}\r\nstatic void ipw_bg_disassociate(struct work_struct *work)\r\n{\r\nstruct ipw_priv *priv =\r\ncontainer_of(work, struct ipw_priv, disassociate);\r\nmutex_lock(&priv->mutex);\r\nipw_disassociate(priv);\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic void ipw_system_config(struct work_struct *work)\r\n{\r\nstruct ipw_priv *priv =\r\ncontainer_of(work, struct ipw_priv, system_config);\r\n#ifdef CONFIG_IPW2200_PROMISCUOUS\r\nif (priv->prom_net_dev && netif_running(priv->prom_net_dev)) {\r\npriv->sys_config.accept_all_data_frames = 1;\r\npriv->sys_config.accept_non_directed_frames = 1;\r\npriv->sys_config.accept_all_mgmt_bcpr = 1;\r\npriv->sys_config.accept_all_mgmt_frames = 1;\r\n}\r\n#endif\r\nipw_send_system_config(priv);\r\n}\r\nstatic const char *ipw_get_status_code(u16 status)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(ipw_status_codes); i++)\r\nif (ipw_status_codes[i].status == (status & 0xff))\r\nreturn ipw_status_codes[i].reason;\r\nreturn "Unknown status value.";\r\n}\r\nstatic void inline average_init(struct average *avg)\r\n{\r\nmemset(avg, 0, sizeof(*avg));\r\n}\r\nstatic s16 exponential_average(s16 prev_avg, s16 val, u8 depth)\r\n{\r\nreturn ((depth-1)*prev_avg + val)/depth;\r\n}\r\nstatic void average_add(struct average *avg, s16 val)\r\n{\r\navg->sum -= avg->entries[avg->pos];\r\navg->sum += val;\r\navg->entries[avg->pos++] = val;\r\nif (unlikely(avg->pos == AVG_ENTRIES)) {\r\navg->init = 1;\r\navg->pos = 0;\r\n}\r\n}\r\nstatic s16 average_value(struct average *avg)\r\n{\r\nif (!unlikely(avg->init)) {\r\nif (avg->pos)\r\nreturn avg->sum / avg->pos;\r\nreturn 0;\r\n}\r\nreturn avg->sum / AVG_ENTRIES;\r\n}\r\nstatic void ipw_reset_stats(struct ipw_priv *priv)\r\n{\r\nu32 len = sizeof(u32);\r\npriv->quality = 0;\r\naverage_init(&priv->average_missed_beacons);\r\npriv->exp_avg_rssi = -60;\r\npriv->exp_avg_noise = -85 + 0x100;\r\npriv->last_rate = 0;\r\npriv->last_missed_beacons = 0;\r\npriv->last_rx_packets = 0;\r\npriv->last_tx_packets = 0;\r\npriv->last_tx_failures = 0;\r\nipw_get_ordinal(priv, IPW_ORD_STAT_RX_ERR_CRC,\r\n&priv->last_rx_err, &len);\r\nipw_get_ordinal(priv, IPW_ORD_STAT_TX_FAILURE,\r\n&priv->last_tx_failures, &len);\r\npriv->missed_adhoc_beacons = 0;\r\npriv->missed_beacons = 0;\r\npriv->tx_packets = 0;\r\npriv->rx_packets = 0;\r\n}\r\nstatic u32 ipw_get_max_rate(struct ipw_priv *priv)\r\n{\r\nu32 i = 0x80000000;\r\nu32 mask = priv->rates_mask;\r\nif (priv->assoc_request.ieee_mode == IPW_B_MODE)\r\nmask &= LIBIPW_CCK_RATES_MASK;\r\nwhile (i && !(mask & i))\r\ni >>= 1;\r\nswitch (i) {\r\ncase LIBIPW_CCK_RATE_1MB_MASK:\r\nreturn 1000000;\r\ncase LIBIPW_CCK_RATE_2MB_MASK:\r\nreturn 2000000;\r\ncase LIBIPW_CCK_RATE_5MB_MASK:\r\nreturn 5500000;\r\ncase LIBIPW_OFDM_RATE_6MB_MASK:\r\nreturn 6000000;\r\ncase LIBIPW_OFDM_RATE_9MB_MASK:\r\nreturn 9000000;\r\ncase LIBIPW_CCK_RATE_11MB_MASK:\r\nreturn 11000000;\r\ncase LIBIPW_OFDM_RATE_12MB_MASK:\r\nreturn 12000000;\r\ncase LIBIPW_OFDM_RATE_18MB_MASK:\r\nreturn 18000000;\r\ncase LIBIPW_OFDM_RATE_24MB_MASK:\r\nreturn 24000000;\r\ncase LIBIPW_OFDM_RATE_36MB_MASK:\r\nreturn 36000000;\r\ncase LIBIPW_OFDM_RATE_48MB_MASK:\r\nreturn 48000000;\r\ncase LIBIPW_OFDM_RATE_54MB_MASK:\r\nreturn 54000000;\r\n}\r\nif (priv->ieee->mode == IEEE_B)\r\nreturn 11000000;\r\nelse\r\nreturn 54000000;\r\n}\r\nstatic u32 ipw_get_current_rate(struct ipw_priv *priv)\r\n{\r\nu32 rate, len = sizeof(rate);\r\nint err;\r\nif (!(priv->status & STATUS_ASSOCIATED))\r\nreturn 0;\r\nif (priv->tx_packets > IPW_REAL_RATE_RX_PACKET_THRESHOLD) {\r\nerr = ipw_get_ordinal(priv, IPW_ORD_STAT_TX_CURR_RATE, &rate,\r\n&len);\r\nif (err) {\r\nIPW_DEBUG_INFO("failed querying ordinals.\n");\r\nreturn 0;\r\n}\r\n} else\r\nreturn ipw_get_max_rate(priv);\r\nswitch (rate) {\r\ncase IPW_TX_RATE_1MB:\r\nreturn 1000000;\r\ncase IPW_TX_RATE_2MB:\r\nreturn 2000000;\r\ncase IPW_TX_RATE_5MB:\r\nreturn 5500000;\r\ncase IPW_TX_RATE_6MB:\r\nreturn 6000000;\r\ncase IPW_TX_RATE_9MB:\r\nreturn 9000000;\r\ncase IPW_TX_RATE_11MB:\r\nreturn 11000000;\r\ncase IPW_TX_RATE_12MB:\r\nreturn 12000000;\r\ncase IPW_TX_RATE_18MB:\r\nreturn 18000000;\r\ncase IPW_TX_RATE_24MB:\r\nreturn 24000000;\r\ncase IPW_TX_RATE_36MB:\r\nreturn 36000000;\r\ncase IPW_TX_RATE_48MB:\r\nreturn 48000000;\r\ncase IPW_TX_RATE_54MB:\r\nreturn 54000000;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ipw_gather_stats(struct ipw_priv *priv)\r\n{\r\nu32 rx_err, rx_err_delta, rx_packets_delta;\r\nu32 tx_failures, tx_failures_delta, tx_packets_delta;\r\nu32 missed_beacons_percent, missed_beacons_delta;\r\nu32 quality = 0;\r\nu32 len = sizeof(u32);\r\ns16 rssi;\r\nu32 beacon_quality, signal_quality, tx_quality, rx_quality,\r\nrate_quality;\r\nu32 max_rate;\r\nif (!(priv->status & STATUS_ASSOCIATED)) {\r\npriv->quality = 0;\r\nreturn;\r\n}\r\nipw_get_ordinal(priv, IPW_ORD_STAT_MISSED_BEACONS,\r\n&priv->missed_beacons, &len);\r\nmissed_beacons_delta = priv->missed_beacons - priv->last_missed_beacons;\r\npriv->last_missed_beacons = priv->missed_beacons;\r\nif (priv->assoc_request.beacon_interval) {\r\nmissed_beacons_percent = missed_beacons_delta *\r\n(HZ * le16_to_cpu(priv->assoc_request.beacon_interval)) /\r\n(IPW_STATS_INTERVAL * 10);\r\n} else {\r\nmissed_beacons_percent = 0;\r\n}\r\naverage_add(&priv->average_missed_beacons, missed_beacons_percent);\r\nipw_get_ordinal(priv, IPW_ORD_STAT_RX_ERR_CRC, &rx_err, &len);\r\nrx_err_delta = rx_err - priv->last_rx_err;\r\npriv->last_rx_err = rx_err;\r\nipw_get_ordinal(priv, IPW_ORD_STAT_TX_FAILURE, &tx_failures, &len);\r\ntx_failures_delta = tx_failures - priv->last_tx_failures;\r\npriv->last_tx_failures = tx_failures;\r\nrx_packets_delta = priv->rx_packets - priv->last_rx_packets;\r\npriv->last_rx_packets = priv->rx_packets;\r\ntx_packets_delta = priv->tx_packets - priv->last_tx_packets;\r\npriv->last_tx_packets = priv->tx_packets;\r\n#define BEACON_THRESHOLD 5\r\nbeacon_quality = 100 - missed_beacons_percent;\r\nif (beacon_quality < BEACON_THRESHOLD)\r\nbeacon_quality = 0;\r\nelse\r\nbeacon_quality = (beacon_quality - BEACON_THRESHOLD) * 100 /\r\n(100 - BEACON_THRESHOLD);\r\nIPW_DEBUG_STATS("Missed beacon: %3d%% (%d%%)\n",\r\nbeacon_quality, missed_beacons_percent);\r\npriv->last_rate = ipw_get_current_rate(priv);\r\nmax_rate = ipw_get_max_rate(priv);\r\nrate_quality = priv->last_rate * 40 / max_rate + 60;\r\nIPW_DEBUG_STATS("Rate quality : %3d%% (%dMbs)\n",\r\nrate_quality, priv->last_rate / 1000000);\r\nif (rx_packets_delta > 100 && rx_packets_delta + rx_err_delta)\r\nrx_quality = 100 - (rx_err_delta * 100) /\r\n(rx_packets_delta + rx_err_delta);\r\nelse\r\nrx_quality = 100;\r\nIPW_DEBUG_STATS("Rx quality : %3d%% (%u errors, %u packets)\n",\r\nrx_quality, rx_err_delta, rx_packets_delta);\r\nif (tx_packets_delta > 100 && tx_packets_delta + tx_failures_delta)\r\ntx_quality = 100 - (tx_failures_delta * 100) /\r\n(tx_packets_delta + tx_failures_delta);\r\nelse\r\ntx_quality = 100;\r\nIPW_DEBUG_STATS("Tx quality : %3d%% (%u errors, %u packets)\n",\r\ntx_quality, tx_failures_delta, tx_packets_delta);\r\nrssi = priv->exp_avg_rssi;\r\nsignal_quality =\r\n(100 *\r\n(priv->ieee->perfect_rssi - priv->ieee->worst_rssi) *\r\n(priv->ieee->perfect_rssi - priv->ieee->worst_rssi) -\r\n(priv->ieee->perfect_rssi - rssi) *\r\n(15 * (priv->ieee->perfect_rssi - priv->ieee->worst_rssi) +\r\n62 * (priv->ieee->perfect_rssi - rssi))) /\r\n((priv->ieee->perfect_rssi - priv->ieee->worst_rssi) *\r\n(priv->ieee->perfect_rssi - priv->ieee->worst_rssi));\r\nif (signal_quality > 100)\r\nsignal_quality = 100;\r\nelse if (signal_quality < 1)\r\nsignal_quality = 0;\r\nIPW_DEBUG_STATS("Signal level : %3d%% (%d dBm)\n",\r\nsignal_quality, rssi);\r\nquality = min(rx_quality, signal_quality);\r\nquality = min(tx_quality, quality);\r\nquality = min(rate_quality, quality);\r\nquality = min(beacon_quality, quality);\r\nif (quality == beacon_quality)\r\nIPW_DEBUG_STATS("Quality (%d%%): Clamped to missed beacons.\n",\r\nquality);\r\nif (quality == rate_quality)\r\nIPW_DEBUG_STATS("Quality (%d%%): Clamped to rate quality.\n",\r\nquality);\r\nif (quality == tx_quality)\r\nIPW_DEBUG_STATS("Quality (%d%%): Clamped to Tx quality.\n",\r\nquality);\r\nif (quality == rx_quality)\r\nIPW_DEBUG_STATS("Quality (%d%%): Clamped to Rx quality.\n",\r\nquality);\r\nif (quality == signal_quality)\r\nIPW_DEBUG_STATS("Quality (%d%%): Clamped to signal quality.\n",\r\nquality);\r\npriv->quality = quality;\r\nschedule_delayed_work(&priv->gather_stats, IPW_STATS_INTERVAL);\r\n}\r\nstatic void ipw_bg_gather_stats(struct work_struct *work)\r\n{\r\nstruct ipw_priv *priv =\r\ncontainer_of(work, struct ipw_priv, gather_stats.work);\r\nmutex_lock(&priv->mutex);\r\nipw_gather_stats(priv);\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic void ipw_handle_missed_beacon(struct ipw_priv *priv,\r\nint missed_count)\r\n{\r\npriv->notif_missed_beacons = missed_count;\r\nif (missed_count > priv->disassociate_threshold &&\r\npriv->status & STATUS_ASSOCIATED) {\r\nIPW_DEBUG(IPW_DL_INFO | IPW_DL_NOTIF |\r\nIPW_DL_STATE | IPW_DL_ASSOC,\r\n"Missed beacon: %d - disassociate\n", missed_count);\r\npriv->status &= ~STATUS_ROAMING;\r\nif (priv->status & STATUS_SCANNING) {\r\nIPW_DEBUG(IPW_DL_INFO | IPW_DL_NOTIF |\r\nIPW_DL_STATE,\r\n"Aborting scan with missed beacon.\n");\r\nschedule_work(&priv->abort_scan);\r\n}\r\nschedule_work(&priv->disassociate);\r\nreturn;\r\n}\r\nif (priv->status & STATUS_ROAMING) {\r\nIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE,\r\n"Missed beacon: %d - roam in progress\n",\r\nmissed_count);\r\nreturn;\r\n}\r\nif (roaming &&\r\n(missed_count > priv->roaming_threshold &&\r\nmissed_count <= priv->disassociate_threshold)) {\r\nIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE,\r\n"Missed beacon: %d - initiate "\r\n"roaming\n", missed_count);\r\nif (!(priv->status & STATUS_ROAMING)) {\r\npriv->status |= STATUS_ROAMING;\r\nif (!(priv->status & STATUS_SCANNING))\r\nschedule_delayed_work(&priv->request_scan, 0);\r\n}\r\nreturn;\r\n}\r\nif (priv->status & STATUS_SCANNING &&\r\nmissed_count > IPW_MB_SCAN_CANCEL_THRESHOLD) {\r\nIPW_DEBUG(IPW_DL_INFO | IPW_DL_NOTIF | IPW_DL_STATE,\r\n"Aborting scan with missed beacon.\n");\r\nschedule_work(&priv->abort_scan);\r\n}\r\nIPW_DEBUG_NOTIF("Missed beacon: %d\n", missed_count);\r\n}\r\nstatic void ipw_scan_event(struct work_struct *work)\r\n{\r\nunion iwreq_data wrqu;\r\nstruct ipw_priv *priv =\r\ncontainer_of(work, struct ipw_priv, scan_event.work);\r\nwrqu.data.length = 0;\r\nwrqu.data.flags = 0;\r\nwireless_send_event(priv->net_dev, SIOCGIWSCAN, &wrqu, NULL);\r\n}\r\nstatic void handle_scan_event(struct ipw_priv *priv)\r\n{\r\nif (!priv->user_requested_scan) {\r\nschedule_delayed_work(&priv->scan_event,\r\nround_jiffies_relative(msecs_to_jiffies(4000)));\r\n} else {\r\npriv->user_requested_scan = 0;\r\nmod_delayed_work(system_wq, &priv->scan_event, 0);\r\n}\r\n}\r\nstatic void ipw_rx_notification(struct ipw_priv *priv,\r\nstruct ipw_rx_notification *notif)\r\n{\r\nu16 size = le16_to_cpu(notif->size);\r\nIPW_DEBUG_NOTIF("type = %i (%d bytes)\n", notif->subtype, size);\r\nswitch (notif->subtype) {\r\ncase HOST_NOTIFICATION_STATUS_ASSOCIATED:{\r\nstruct notif_association *assoc = &notif->u.assoc;\r\nswitch (assoc->state) {\r\ncase CMAS_ASSOCIATED:{\r\nIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\r\nIPW_DL_ASSOC,\r\n"associated: '%*pE' %pM\n",\r\npriv->essid_len, priv->essid,\r\npriv->bssid);\r\nswitch (priv->ieee->iw_mode) {\r\ncase IW_MODE_INFRA:\r\nmemcpy(priv->ieee->bssid,\r\npriv->bssid, ETH_ALEN);\r\nbreak;\r\ncase IW_MODE_ADHOC:\r\nmemcpy(priv->ieee->bssid,\r\npriv->bssid, ETH_ALEN);\r\npriv->num_stations = 0;\r\nIPW_DEBUG_ASSOC\r\n("queueing adhoc check\n");\r\nschedule_delayed_work(\r\n&priv->adhoc_check,\r\nle16_to_cpu(priv->\r\nassoc_request.\r\nbeacon_interval));\r\nbreak;\r\n}\r\npriv->status &= ~STATUS_ASSOCIATING;\r\npriv->status |= STATUS_ASSOCIATED;\r\nschedule_work(&priv->system_config);\r\n#ifdef CONFIG_IPW2200_QOS\r\n#define IPW_GET_PACKET_STYPE(x) WLAN_FC_GET_STYPE( \\r\nle16_to_cpu(((struct ieee80211_hdr *)(x))->frame_control))\r\nif ((priv->status & STATUS_AUTH) &&\r\n(IPW_GET_PACKET_STYPE(&notif->u.raw)\r\n== IEEE80211_STYPE_ASSOC_RESP)) {\r\nif ((sizeof\r\n(struct\r\nlibipw_assoc_response)\r\n<= size)\r\n&& (size <= 2314)) {\r\nstruct\r\nlibipw_rx_stats\r\nstats = {\r\n.len = size - 1,\r\n};\r\nIPW_DEBUG_QOS\r\n("QoS Associate "\r\n"size %d\n", size);\r\nlibipw_rx_mgt(priv->\r\nieee,\r\n(struct\r\nlibipw_hdr_4addr\r\n*)\r\n&notif->u.raw, &stats);\r\n}\r\n}\r\n#endif\r\nschedule_work(&priv->link_up);\r\nbreak;\r\n}\r\ncase CMAS_AUTHENTICATED:{\r\nif (priv->\r\nstatus & (STATUS_ASSOCIATED |\r\nSTATUS_AUTH)) {\r\nstruct notif_authenticate *auth\r\n= &notif->u.auth;\r\nIPW_DEBUG(IPW_DL_NOTIF |\r\nIPW_DL_STATE |\r\nIPW_DL_ASSOC,\r\n"deauthenticated: '%*pE' %pM: (0x%04X) - %s\n",\r\npriv->essid_len,\r\npriv->essid,\r\npriv->bssid,\r\nle16_to_cpu(auth->status),\r\nipw_get_status_code\r\n(le16_to_cpu\r\n(auth->status)));\r\npriv->status &=\r\n~(STATUS_ASSOCIATING |\r\nSTATUS_AUTH |\r\nSTATUS_ASSOCIATED);\r\nschedule_work(&priv->link_down);\r\nbreak;\r\n}\r\nIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\r\nIPW_DL_ASSOC,\r\n"authenticated: '%*pE' %pM\n",\r\npriv->essid_len, priv->essid,\r\npriv->bssid);\r\nbreak;\r\n}\r\ncase CMAS_INIT:{\r\nif (priv->status & STATUS_AUTH) {\r\nstruct\r\nlibipw_assoc_response\r\n*resp;\r\nresp =\r\n(struct\r\nlibipw_assoc_response\r\n*)&notif->u.raw;\r\nIPW_DEBUG(IPW_DL_NOTIF |\r\nIPW_DL_STATE |\r\nIPW_DL_ASSOC,\r\n"association failed (0x%04X): %s\n",\r\nle16_to_cpu(resp->status),\r\nipw_get_status_code\r\n(le16_to_cpu\r\n(resp->status)));\r\n}\r\nIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\r\nIPW_DL_ASSOC,\r\n"disassociated: '%*pE' %pM\n",\r\npriv->essid_len, priv->essid,\r\npriv->bssid);\r\npriv->status &=\r\n~(STATUS_DISASSOCIATING |\r\nSTATUS_ASSOCIATING |\r\nSTATUS_ASSOCIATED | STATUS_AUTH);\r\nif (priv->assoc_network\r\n&& (priv->assoc_network->\r\ncapability &\r\nWLAN_CAPABILITY_IBSS))\r\nipw_remove_current_network\r\n(priv);\r\nschedule_work(&priv->link_down);\r\nbreak;\r\n}\r\ncase CMAS_RX_ASSOC_RESP:\r\nbreak;\r\ndefault:\r\nIPW_ERROR("assoc: unknown (%d)\n",\r\nassoc->state);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase HOST_NOTIFICATION_STATUS_AUTHENTICATE:{\r\nstruct notif_authenticate *auth = &notif->u.auth;\r\nswitch (auth->state) {\r\ncase CMAS_AUTHENTICATED:\r\nIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE,\r\n"authenticated: '%*pE' %pM\n",\r\npriv->essid_len, priv->essid,\r\npriv->bssid);\r\npriv->status |= STATUS_AUTH;\r\nbreak;\r\ncase CMAS_INIT:\r\nif (priv->status & STATUS_AUTH) {\r\nIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\r\nIPW_DL_ASSOC,\r\n"authentication failed (0x%04X): %s\n",\r\nle16_to_cpu(auth->status),\r\nipw_get_status_code(le16_to_cpu\r\n(auth->\r\nstatus)));\r\n}\r\nIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\r\nIPW_DL_ASSOC,\r\n"deauthenticated: '%*pE' %pM\n",\r\npriv->essid_len, priv->essid,\r\npriv->bssid);\r\npriv->status &= ~(STATUS_ASSOCIATING |\r\nSTATUS_AUTH |\r\nSTATUS_ASSOCIATED);\r\nschedule_work(&priv->link_down);\r\nbreak;\r\ncase CMAS_TX_AUTH_SEQ_1:\r\nIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\r\nIPW_DL_ASSOC, "AUTH_SEQ_1\n");\r\nbreak;\r\ncase CMAS_RX_AUTH_SEQ_2:\r\nIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\r\nIPW_DL_ASSOC, "AUTH_SEQ_2\n");\r\nbreak;\r\ncase CMAS_AUTH_SEQ_1_PASS:\r\nIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\r\nIPW_DL_ASSOC, "AUTH_SEQ_1_PASS\n");\r\nbreak;\r\ncase CMAS_AUTH_SEQ_1_FAIL:\r\nIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\r\nIPW_DL_ASSOC, "AUTH_SEQ_1_FAIL\n");\r\nbreak;\r\ncase CMAS_TX_AUTH_SEQ_3:\r\nIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\r\nIPW_DL_ASSOC, "AUTH_SEQ_3\n");\r\nbreak;\r\ncase CMAS_RX_AUTH_SEQ_4:\r\nIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\r\nIPW_DL_ASSOC, "RX_AUTH_SEQ_4\n");\r\nbreak;\r\ncase CMAS_AUTH_SEQ_2_PASS:\r\nIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\r\nIPW_DL_ASSOC, "AUTH_SEQ_2_PASS\n");\r\nbreak;\r\ncase CMAS_AUTH_SEQ_2_FAIL:\r\nIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\r\nIPW_DL_ASSOC, "AUT_SEQ_2_FAIL\n");\r\nbreak;\r\ncase CMAS_TX_ASSOC:\r\nIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\r\nIPW_DL_ASSOC, "TX_ASSOC\n");\r\nbreak;\r\ncase CMAS_RX_ASSOC_RESP:\r\nIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\r\nIPW_DL_ASSOC, "RX_ASSOC_RESP\n");\r\nbreak;\r\ncase CMAS_ASSOCIATED:\r\nIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\r\nIPW_DL_ASSOC, "ASSOCIATED\n");\r\nbreak;\r\ndefault:\r\nIPW_DEBUG_NOTIF("auth: failure - %d\n",\r\nauth->state);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase HOST_NOTIFICATION_STATUS_SCAN_CHANNEL_RESULT:{\r\nstruct notif_channel_result *x =\r\n&notif->u.channel_result;\r\nif (size == sizeof(*x)) {\r\nIPW_DEBUG_SCAN("Scan result for channel %d\n",\r\nx->channel_num);\r\n} else {\r\nIPW_DEBUG_SCAN("Scan result of wrong size %d "\r\n"(should be %zd)\n",\r\nsize, sizeof(*x));\r\n}\r\nbreak;\r\n}\r\ncase HOST_NOTIFICATION_STATUS_SCAN_COMPLETED:{\r\nstruct notif_scan_complete *x = &notif->u.scan_complete;\r\nif (size == sizeof(*x)) {\r\nIPW_DEBUG_SCAN\r\n("Scan completed: type %d, %d channels, "\r\n"%d status\n", x->scan_type,\r\nx->num_channels, x->status);\r\n} else {\r\nIPW_ERROR("Scan completed of wrong size %d "\r\n"(should be %zd)\n",\r\nsize, sizeof(*x));\r\n}\r\npriv->status &=\r\n~(STATUS_SCANNING | STATUS_SCAN_ABORTING);\r\nwake_up_interruptible(&priv->wait_state);\r\ncancel_delayed_work(&priv->scan_check);\r\nif (priv->status & STATUS_EXIT_PENDING)\r\nbreak;\r\npriv->ieee->scans++;\r\n#ifdef CONFIG_IPW2200_MONITOR\r\nif (priv->ieee->iw_mode == IW_MODE_MONITOR) {\r\npriv->status |= STATUS_SCAN_FORCED;\r\nschedule_delayed_work(&priv->request_scan, 0);\r\nbreak;\r\n}\r\npriv->status &= ~STATUS_SCAN_FORCED;\r\n#endif\r\nif (priv->status & STATUS_DIRECT_SCAN_PENDING)\r\nschedule_delayed_work(&priv->request_direct_scan, 0);\r\nif (!(priv->status & (STATUS_ASSOCIATED |\r\nSTATUS_ASSOCIATING |\r\nSTATUS_ROAMING |\r\nSTATUS_DISASSOCIATING)))\r\nschedule_work(&priv->associate);\r\nelse if (priv->status & STATUS_ROAMING) {\r\nif (x->status == SCAN_COMPLETED_STATUS_COMPLETE)\r\nschedule_work(&priv->roam);\r\nelse\r\npriv->status &= ~STATUS_ROAMING;\r\n} else if (priv->status & STATUS_SCAN_PENDING)\r\nschedule_delayed_work(&priv->request_scan, 0);\r\nelse if (priv->config & CFG_BACKGROUND_SCAN\r\n&& priv->status & STATUS_ASSOCIATED)\r\nschedule_delayed_work(&priv->request_scan,\r\nround_jiffies_relative(HZ));\r\nif (x->status == SCAN_COMPLETED_STATUS_COMPLETE)\r\nhandle_scan_event(priv);\r\nbreak;\r\n}\r\ncase HOST_NOTIFICATION_STATUS_FRAG_LENGTH:{\r\nstruct notif_frag_length *x = &notif->u.frag_len;\r\nif (size == sizeof(*x))\r\nIPW_ERROR("Frag length: %d\n",\r\nle16_to_cpu(x->frag_length));\r\nelse\r\nIPW_ERROR("Frag length of wrong size %d "\r\n"(should be %zd)\n",\r\nsize, sizeof(*x));\r\nbreak;\r\n}\r\ncase HOST_NOTIFICATION_STATUS_LINK_DETERIORATION:{\r\nstruct notif_link_deterioration *x =\r\n&notif->u.link_deterioration;\r\nif (size == sizeof(*x)) {\r\nIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE,\r\n"link deterioration: type %d, cnt %d\n",\r\nx->silence_notification_type,\r\nx->silence_count);\r\nmemcpy(&priv->last_link_deterioration, x,\r\nsizeof(*x));\r\n} else {\r\nIPW_ERROR("Link Deterioration of wrong size %d "\r\n"(should be %zd)\n",\r\nsize, sizeof(*x));\r\n}\r\nbreak;\r\n}\r\ncase HOST_NOTIFICATION_DINO_CONFIG_RESPONSE:{\r\nIPW_ERROR("Dino config\n");\r\nif (priv->hcmd\r\n&& priv->hcmd->cmd != HOST_CMD_DINO_CONFIG)\r\nIPW_ERROR("Unexpected DINO_CONFIG_RESPONSE\n");\r\nbreak;\r\n}\r\ncase HOST_NOTIFICATION_STATUS_BEACON_STATE:{\r\nstruct notif_beacon_state *x = &notif->u.beacon_state;\r\nif (size != sizeof(*x)) {\r\nIPW_ERROR\r\n("Beacon state of wrong size %d (should "\r\n"be %zd)\n", size, sizeof(*x));\r\nbreak;\r\n}\r\nif (le32_to_cpu(x->state) ==\r\nHOST_NOTIFICATION_STATUS_BEACON_MISSING)\r\nipw_handle_missed_beacon(priv,\r\nle32_to_cpu(x->\r\nnumber));\r\nbreak;\r\n}\r\ncase HOST_NOTIFICATION_STATUS_TGI_TX_KEY:{\r\nstruct notif_tgi_tx_key *x = &notif->u.tgi_tx_key;\r\nif (size == sizeof(*x)) {\r\nIPW_ERROR("TGi Tx Key: state 0x%02x sec type "\r\n"0x%02x station %d\n",\r\nx->key_state, x->security_type,\r\nx->station_index);\r\nbreak;\r\n}\r\nIPW_ERROR\r\n("TGi Tx Key of wrong size %d (should be %zd)\n",\r\nsize, sizeof(*x));\r\nbreak;\r\n}\r\ncase HOST_NOTIFICATION_CALIB_KEEP_RESULTS:{\r\nstruct notif_calibration *x = &notif->u.calibration;\r\nif (size == sizeof(*x)) {\r\nmemcpy(&priv->calib, x, sizeof(*x));\r\nIPW_DEBUG_INFO("TODO: Calibration\n");\r\nbreak;\r\n}\r\nIPW_ERROR\r\n("Calibration of wrong size %d (should be %zd)\n",\r\nsize, sizeof(*x));\r\nbreak;\r\n}\r\ncase HOST_NOTIFICATION_NOISE_STATS:{\r\nif (size == sizeof(u32)) {\r\npriv->exp_avg_noise =\r\nexponential_average(priv->exp_avg_noise,\r\n(u8) (le32_to_cpu(notif->u.noise.value) & 0xff),\r\nDEPTH_NOISE);\r\nbreak;\r\n}\r\nIPW_ERROR\r\n("Noise stat is wrong size %d (should be %zd)\n",\r\nsize, sizeof(u32));\r\nbreak;\r\n}\r\ndefault:\r\nIPW_DEBUG_NOTIF("Unknown notification: "\r\n"subtype=%d,flags=0x%2x,size=%d\n",\r\nnotif->subtype, notif->flags, size);\r\n}\r\n}\r\nstatic int ipw_queue_reset(struct ipw_priv *priv)\r\n{\r\nint rc = 0;\r\nint nTx = 64, nTxCmd = 8;\r\nipw_tx_queue_free(priv);\r\nrc = ipw_queue_tx_init(priv, &priv->txq_cmd, nTxCmd,\r\nIPW_TX_CMD_QUEUE_READ_INDEX,\r\nIPW_TX_CMD_QUEUE_WRITE_INDEX,\r\nIPW_TX_CMD_QUEUE_BD_BASE,\r\nIPW_TX_CMD_QUEUE_BD_SIZE);\r\nif (rc) {\r\nIPW_ERROR("Tx Cmd queue init failed\n");\r\ngoto error;\r\n}\r\nrc = ipw_queue_tx_init(priv, &priv->txq[0], nTx,\r\nIPW_TX_QUEUE_0_READ_INDEX,\r\nIPW_TX_QUEUE_0_WRITE_INDEX,\r\nIPW_TX_QUEUE_0_BD_BASE, IPW_TX_QUEUE_0_BD_SIZE);\r\nif (rc) {\r\nIPW_ERROR("Tx 0 queue init failed\n");\r\ngoto error;\r\n}\r\nrc = ipw_queue_tx_init(priv, &priv->txq[1], nTx,\r\nIPW_TX_QUEUE_1_READ_INDEX,\r\nIPW_TX_QUEUE_1_WRITE_INDEX,\r\nIPW_TX_QUEUE_1_BD_BASE, IPW_TX_QUEUE_1_BD_SIZE);\r\nif (rc) {\r\nIPW_ERROR("Tx 1 queue init failed\n");\r\ngoto error;\r\n}\r\nrc = ipw_queue_tx_init(priv, &priv->txq[2], nTx,\r\nIPW_TX_QUEUE_2_READ_INDEX,\r\nIPW_TX_QUEUE_2_WRITE_INDEX,\r\nIPW_TX_QUEUE_2_BD_BASE, IPW_TX_QUEUE_2_BD_SIZE);\r\nif (rc) {\r\nIPW_ERROR("Tx 2 queue init failed\n");\r\ngoto error;\r\n}\r\nrc = ipw_queue_tx_init(priv, &priv->txq[3], nTx,\r\nIPW_TX_QUEUE_3_READ_INDEX,\r\nIPW_TX_QUEUE_3_WRITE_INDEX,\r\nIPW_TX_QUEUE_3_BD_BASE, IPW_TX_QUEUE_3_BD_SIZE);\r\nif (rc) {\r\nIPW_ERROR("Tx 3 queue init failed\n");\r\ngoto error;\r\n}\r\npriv->rx_bufs_min = 0;\r\npriv->rx_pend_max = 0;\r\nreturn rc;\r\nerror:\r\nipw_tx_queue_free(priv);\r\nreturn rc;\r\n}\r\nstatic int ipw_queue_tx_reclaim(struct ipw_priv *priv,\r\nstruct clx2_tx_queue *txq, int qindex)\r\n{\r\nu32 hw_tail;\r\nint used;\r\nstruct clx2_queue *q = &txq->q;\r\nhw_tail = ipw_read32(priv, q->reg_r);\r\nif (hw_tail >= q->n_bd) {\r\nIPW_ERROR\r\n("Read index for DMA queue (%d) is out of range [0-%d)\n",\r\nhw_tail, q->n_bd);\r\ngoto done;\r\n}\r\nfor (; q->last_used != hw_tail;\r\nq->last_used = ipw_queue_inc_wrap(q->last_used, q->n_bd)) {\r\nipw_queue_tx_free_tfd(priv, txq);\r\npriv->tx_packets++;\r\n}\r\ndone:\r\nif ((ipw_tx_queue_space(q) > q->low_mark) &&\r\n(qindex >= 0))\r\nnetif_wake_queue(priv->net_dev);\r\nused = q->first_empty - q->last_used;\r\nif (used < 0)\r\nused += q->n_bd;\r\nreturn used;\r\n}\r\nstatic int ipw_queue_tx_hcmd(struct ipw_priv *priv, int hcmd, void *buf,\r\nint len, int sync)\r\n{\r\nstruct clx2_tx_queue *txq = &priv->txq_cmd;\r\nstruct clx2_queue *q = &txq->q;\r\nstruct tfd_frame *tfd;\r\nif (ipw_tx_queue_space(q) < (sync ? 1 : 2)) {\r\nIPW_ERROR("No space for Tx\n");\r\nreturn -EBUSY;\r\n}\r\ntfd = &txq->bd[q->first_empty];\r\ntxq->txb[q->first_empty] = NULL;\r\nmemset(tfd, 0, sizeof(*tfd));\r\ntfd->control_flags.message_type = TX_HOST_COMMAND_TYPE;\r\ntfd->control_flags.control_bits = TFD_NEED_IRQ_MASK;\r\npriv->hcmd_seq++;\r\ntfd->u.cmd.index = hcmd;\r\ntfd->u.cmd.length = len;\r\nmemcpy(tfd->u.cmd.payload, buf, len);\r\nq->first_empty = ipw_queue_inc_wrap(q->first_empty, q->n_bd);\r\nipw_write32(priv, q->reg_w, q->first_empty);\r\n_ipw_read32(priv, 0x90);\r\nreturn 0;\r\n}\r\nstatic void ipw_rx_queue_restock(struct ipw_priv *priv)\r\n{\r\nstruct ipw_rx_queue *rxq = priv->rxq;\r\nstruct list_head *element;\r\nstruct ipw_rx_mem_buffer *rxb;\r\nunsigned long flags;\r\nint write;\r\nspin_lock_irqsave(&rxq->lock, flags);\r\nwrite = rxq->write;\r\nwhile ((ipw_rx_queue_space(rxq) > 0) && (rxq->free_count)) {\r\nelement = rxq->rx_free.next;\r\nrxb = list_entry(element, struct ipw_rx_mem_buffer, list);\r\nlist_del(element);\r\nipw_write32(priv, IPW_RFDS_TABLE_LOWER + rxq->write * RFD_SIZE,\r\nrxb->dma_addr);\r\nrxq->queue[rxq->write] = rxb;\r\nrxq->write = (rxq->write + 1) % RX_QUEUE_SIZE;\r\nrxq->free_count--;\r\n}\r\nspin_unlock_irqrestore(&rxq->lock, flags);\r\nif (rxq->free_count <= RX_LOW_WATERMARK)\r\nschedule_work(&priv->rx_replenish);\r\nif (write != rxq->write)\r\nipw_write32(priv, IPW_RX_WRITE_INDEX, rxq->write);\r\n}\r\nstatic void ipw_rx_queue_replenish(void *data)\r\n{\r\nstruct ipw_priv *priv = data;\r\nstruct ipw_rx_queue *rxq = priv->rxq;\r\nstruct list_head *element;\r\nstruct ipw_rx_mem_buffer *rxb;\r\nunsigned long flags;\r\nspin_lock_irqsave(&rxq->lock, flags);\r\nwhile (!list_empty(&rxq->rx_used)) {\r\nelement = rxq->rx_used.next;\r\nrxb = list_entry(element, struct ipw_rx_mem_buffer, list);\r\nrxb->skb = alloc_skb(IPW_RX_BUF_SIZE, GFP_ATOMIC);\r\nif (!rxb->skb) {\r\nprintk(KERN_CRIT "%s: Can not allocate SKB buffers.\n",\r\npriv->net_dev->name);\r\nbreak;\r\n}\r\nlist_del(element);\r\nrxb->dma_addr =\r\npci_map_single(priv->pci_dev, rxb->skb->data,\r\nIPW_RX_BUF_SIZE, PCI_DMA_FROMDEVICE);\r\nlist_add_tail(&rxb->list, &rxq->rx_free);\r\nrxq->free_count++;\r\n}\r\nspin_unlock_irqrestore(&rxq->lock, flags);\r\nipw_rx_queue_restock(priv);\r\n}\r\nstatic void ipw_bg_rx_queue_replenish(struct work_struct *work)\r\n{\r\nstruct ipw_priv *priv =\r\ncontainer_of(work, struct ipw_priv, rx_replenish);\r\nmutex_lock(&priv->mutex);\r\nipw_rx_queue_replenish(priv);\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic void ipw_rx_queue_free(struct ipw_priv *priv, struct ipw_rx_queue *rxq)\r\n{\r\nint i;\r\nif (!rxq)\r\nreturn;\r\nfor (i = 0; i < RX_QUEUE_SIZE + RX_FREE_BUFFERS; i++) {\r\nif (rxq->pool[i].skb != NULL) {\r\npci_unmap_single(priv->pci_dev, rxq->pool[i].dma_addr,\r\nIPW_RX_BUF_SIZE, PCI_DMA_FROMDEVICE);\r\ndev_kfree_skb(rxq->pool[i].skb);\r\n}\r\n}\r\nkfree(rxq);\r\n}\r\nstatic struct ipw_rx_queue *ipw_rx_queue_alloc(struct ipw_priv *priv)\r\n{\r\nstruct ipw_rx_queue *rxq;\r\nint i;\r\nrxq = kzalloc(sizeof(*rxq), GFP_KERNEL);\r\nif (unlikely(!rxq)) {\r\nIPW_ERROR("memory allocation failed\n");\r\nreturn NULL;\r\n}\r\nspin_lock_init(&rxq->lock);\r\nINIT_LIST_HEAD(&rxq->rx_free);\r\nINIT_LIST_HEAD(&rxq->rx_used);\r\nfor (i = 0; i < RX_FREE_BUFFERS + RX_QUEUE_SIZE; i++)\r\nlist_add_tail(&rxq->pool[i].list, &rxq->rx_used);\r\nrxq->read = rxq->write = 0;\r\nrxq->free_count = 0;\r\nreturn rxq;\r\n}\r\nstatic int ipw_is_rate_in_mask(struct ipw_priv *priv, int ieee_mode, u8 rate)\r\n{\r\nrate &= ~LIBIPW_BASIC_RATE_MASK;\r\nif (ieee_mode == IEEE_A) {\r\nswitch (rate) {\r\ncase LIBIPW_OFDM_RATE_6MB:\r\nreturn priv->rates_mask & LIBIPW_OFDM_RATE_6MB_MASK ?\r\n1 : 0;\r\ncase LIBIPW_OFDM_RATE_9MB:\r\nreturn priv->rates_mask & LIBIPW_OFDM_RATE_9MB_MASK ?\r\n1 : 0;\r\ncase LIBIPW_OFDM_RATE_12MB:\r\nreturn priv->\r\nrates_mask & LIBIPW_OFDM_RATE_12MB_MASK ? 1 : 0;\r\ncase LIBIPW_OFDM_RATE_18MB:\r\nreturn priv->\r\nrates_mask & LIBIPW_OFDM_RATE_18MB_MASK ? 1 : 0;\r\ncase LIBIPW_OFDM_RATE_24MB:\r\nreturn priv->\r\nrates_mask & LIBIPW_OFDM_RATE_24MB_MASK ? 1 : 0;\r\ncase LIBIPW_OFDM_RATE_36MB:\r\nreturn priv->\r\nrates_mask & LIBIPW_OFDM_RATE_36MB_MASK ? 1 : 0;\r\ncase LIBIPW_OFDM_RATE_48MB:\r\nreturn priv->\r\nrates_mask & LIBIPW_OFDM_RATE_48MB_MASK ? 1 : 0;\r\ncase LIBIPW_OFDM_RATE_54MB:\r\nreturn priv->\r\nrates_mask & LIBIPW_OFDM_RATE_54MB_MASK ? 1 : 0;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nswitch (rate) {\r\ncase LIBIPW_CCK_RATE_1MB:\r\nreturn priv->rates_mask & LIBIPW_CCK_RATE_1MB_MASK ? 1 : 0;\r\ncase LIBIPW_CCK_RATE_2MB:\r\nreturn priv->rates_mask & LIBIPW_CCK_RATE_2MB_MASK ? 1 : 0;\r\ncase LIBIPW_CCK_RATE_5MB:\r\nreturn priv->rates_mask & LIBIPW_CCK_RATE_5MB_MASK ? 1 : 0;\r\ncase LIBIPW_CCK_RATE_11MB:\r\nreturn priv->rates_mask & LIBIPW_CCK_RATE_11MB_MASK ? 1 : 0;\r\n}\r\nif (ieee_mode == IEEE_B)\r\nreturn 0;\r\nswitch (rate) {\r\ncase LIBIPW_OFDM_RATE_6MB:\r\nreturn priv->rates_mask & LIBIPW_OFDM_RATE_6MB_MASK ? 1 : 0;\r\ncase LIBIPW_OFDM_RATE_9MB:\r\nreturn priv->rates_mask & LIBIPW_OFDM_RATE_9MB_MASK ? 1 : 0;\r\ncase LIBIPW_OFDM_RATE_12MB:\r\nreturn priv->rates_mask & LIBIPW_OFDM_RATE_12MB_MASK ? 1 : 0;\r\ncase LIBIPW_OFDM_RATE_18MB:\r\nreturn priv->rates_mask & LIBIPW_OFDM_RATE_18MB_MASK ? 1 : 0;\r\ncase LIBIPW_OFDM_RATE_24MB:\r\nreturn priv->rates_mask & LIBIPW_OFDM_RATE_24MB_MASK ? 1 : 0;\r\ncase LIBIPW_OFDM_RATE_36MB:\r\nreturn priv->rates_mask & LIBIPW_OFDM_RATE_36MB_MASK ? 1 : 0;\r\ncase LIBIPW_OFDM_RATE_48MB:\r\nreturn priv->rates_mask & LIBIPW_OFDM_RATE_48MB_MASK ? 1 : 0;\r\ncase LIBIPW_OFDM_RATE_54MB:\r\nreturn priv->rates_mask & LIBIPW_OFDM_RATE_54MB_MASK ? 1 : 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ipw_compatible_rates(struct ipw_priv *priv,\r\nconst struct libipw_network *network,\r\nstruct ipw_supported_rates *rates)\r\n{\r\nint num_rates, i;\r\nmemset(rates, 0, sizeof(*rates));\r\nnum_rates = min(network->rates_len, (u8) IPW_MAX_RATES);\r\nrates->num_rates = 0;\r\nfor (i = 0; i < num_rates; i++) {\r\nif (!ipw_is_rate_in_mask(priv, network->mode,\r\nnetwork->rates[i])) {\r\nif (network->rates[i] & LIBIPW_BASIC_RATE_MASK) {\r\nIPW_DEBUG_SCAN("Adding masked mandatory "\r\n"rate %02X\n",\r\nnetwork->rates[i]);\r\nrates->supported_rates[rates->num_rates++] =\r\nnetwork->rates[i];\r\ncontinue;\r\n}\r\nIPW_DEBUG_SCAN("Rate %02X masked : 0x%08X\n",\r\nnetwork->rates[i], priv->rates_mask);\r\ncontinue;\r\n}\r\nrates->supported_rates[rates->num_rates++] = network->rates[i];\r\n}\r\nnum_rates = min(network->rates_ex_len,\r\n(u8) (IPW_MAX_RATES - num_rates));\r\nfor (i = 0; i < num_rates; i++) {\r\nif (!ipw_is_rate_in_mask(priv, network->mode,\r\nnetwork->rates_ex[i])) {\r\nif (network->rates_ex[i] & LIBIPW_BASIC_RATE_MASK) {\r\nIPW_DEBUG_SCAN("Adding masked mandatory "\r\n"rate %02X\n",\r\nnetwork->rates_ex[i]);\r\nrates->supported_rates[rates->num_rates++] =\r\nnetwork->rates[i];\r\ncontinue;\r\n}\r\nIPW_DEBUG_SCAN("Rate %02X masked : 0x%08X\n",\r\nnetwork->rates_ex[i], priv->rates_mask);\r\ncontinue;\r\n}\r\nrates->supported_rates[rates->num_rates++] =\r\nnetwork->rates_ex[i];\r\n}\r\nreturn 1;\r\n}\r\nstatic void ipw_copy_rates(struct ipw_supported_rates *dest,\r\nconst struct ipw_supported_rates *src)\r\n{\r\nu8 i;\r\nfor (i = 0; i < src->num_rates; i++)\r\ndest->supported_rates[i] = src->supported_rates[i];\r\ndest->num_rates = src->num_rates;\r\n}\r\nstatic void ipw_add_cck_scan_rates(struct ipw_supported_rates *rates,\r\nu8 modulation, u32 rate_mask)\r\n{\r\nu8 basic_mask = (LIBIPW_OFDM_MODULATION == modulation) ?\r\nLIBIPW_BASIC_RATE_MASK : 0;\r\nif (rate_mask & LIBIPW_CCK_RATE_1MB_MASK)\r\nrates->supported_rates[rates->num_rates++] =\r\nLIBIPW_BASIC_RATE_MASK | LIBIPW_CCK_RATE_1MB;\r\nif (rate_mask & LIBIPW_CCK_RATE_2MB_MASK)\r\nrates->supported_rates[rates->num_rates++] =\r\nLIBIPW_BASIC_RATE_MASK | LIBIPW_CCK_RATE_2MB;\r\nif (rate_mask & LIBIPW_CCK_RATE_5MB_MASK)\r\nrates->supported_rates[rates->num_rates++] = basic_mask |\r\nLIBIPW_CCK_RATE_5MB;\r\nif (rate_mask & LIBIPW_CCK_RATE_11MB_MASK)\r\nrates->supported_rates[rates->num_rates++] = basic_mask |\r\nLIBIPW_CCK_RATE_11MB;\r\n}\r\nstatic void ipw_add_ofdm_scan_rates(struct ipw_supported_rates *rates,\r\nu8 modulation, u32 rate_mask)\r\n{\r\nu8 basic_mask = (LIBIPW_OFDM_MODULATION == modulation) ?\r\nLIBIPW_BASIC_RATE_MASK : 0;\r\nif (rate_mask & LIBIPW_OFDM_RATE_6MB_MASK)\r\nrates->supported_rates[rates->num_rates++] = basic_mask |\r\nLIBIPW_OFDM_RATE_6MB;\r\nif (rate_mask & LIBIPW_OFDM_RATE_9MB_MASK)\r\nrates->supported_rates[rates->num_rates++] =\r\nLIBIPW_OFDM_RATE_9MB;\r\nif (rate_mask & LIBIPW_OFDM_RATE_12MB_MASK)\r\nrates->supported_rates[rates->num_rates++] = basic_mask |\r\nLIBIPW_OFDM_RATE_12MB;\r\nif (rate_mask & LIBIPW_OFDM_RATE_18MB_MASK)\r\nrates->supported_rates[rates->num_rates++] =\r\nLIBIPW_OFDM_RATE_18MB;\r\nif (rate_mask & LIBIPW_OFDM_RATE_24MB_MASK)\r\nrates->supported_rates[rates->num_rates++] = basic_mask |\r\nLIBIPW_OFDM_RATE_24MB;\r\nif (rate_mask & LIBIPW_OFDM_RATE_36MB_MASK)\r\nrates->supported_rates[rates->num_rates++] =\r\nLIBIPW_OFDM_RATE_36MB;\r\nif (rate_mask & LIBIPW_OFDM_RATE_48MB_MASK)\r\nrates->supported_rates[rates->num_rates++] =\r\nLIBIPW_OFDM_RATE_48MB;\r\nif (rate_mask & LIBIPW_OFDM_RATE_54MB_MASK)\r\nrates->supported_rates[rates->num_rates++] =\r\nLIBIPW_OFDM_RATE_54MB;\r\n}\r\nstatic int ipw_find_adhoc_network(struct ipw_priv *priv,\r\nstruct ipw_network_match *match,\r\nstruct libipw_network *network,\r\nint roaming)\r\n{\r\nstruct ipw_supported_rates rates;\r\nif ((priv->ieee->iw_mode == IW_MODE_ADHOC &&\r\n!(network->capability & WLAN_CAPABILITY_IBSS))) {\r\nIPW_DEBUG_MERGE("Network '%*pE (%pM)' excluded due to capability mismatch.\n",\r\nnetwork->ssid_len, network->ssid,\r\nnetwork->bssid);\r\nreturn 0;\r\n}\r\nif (unlikely(roaming)) {\r\nif ((network->ssid_len != match->network->ssid_len) ||\r\nmemcmp(network->ssid, match->network->ssid,\r\nnetwork->ssid_len)) {\r\nIPW_DEBUG_MERGE("Network '%*pE (%pM)' excluded because of non-network ESSID.\n",\r\nnetwork->ssid_len, network->ssid,\r\nnetwork->bssid);\r\nreturn 0;\r\n}\r\n} else {\r\nif ((priv->config & CFG_STATIC_ESSID) &&\r\n((network->ssid_len != priv->essid_len) ||\r\nmemcmp(network->ssid, priv->essid,\r\nmin(network->ssid_len, priv->essid_len)))) {\r\nIPW_DEBUG_MERGE("Network '%*pE (%pM)' excluded because of ESSID mismatch: '%*pE'.\n",\r\nnetwork->ssid_len, network->ssid,\r\nnetwork->bssid, priv->essid_len,\r\npriv->essid);\r\nreturn 0;\r\n}\r\n}\r\nif (network->time_stamp[0] < match->network->time_stamp[0]) {\r\nIPW_DEBUG_MERGE("Network '%*pE excluded because newer than current network.\n",\r\nmatch->network->ssid_len, match->network->ssid);\r\nreturn 0;\r\n} else if (network->time_stamp[1] < match->network->time_stamp[1]) {\r\nIPW_DEBUG_MERGE("Network '%*pE excluded because newer than current network.\n",\r\nmatch->network->ssid_len, match->network->ssid);\r\nreturn 0;\r\n}\r\nif (priv->ieee->scan_age != 0 &&\r\ntime_after(jiffies, network->last_scanned + priv->ieee->scan_age)) {\r\nIPW_DEBUG_MERGE("Network '%*pE (%pM)' excluded because of age: %ums.\n",\r\nnetwork->ssid_len, network->ssid,\r\nnetwork->bssid,\r\njiffies_to_msecs(jiffies -\r\nnetwork->last_scanned));\r\nreturn 0;\r\n}\r\nif ((priv->config & CFG_STATIC_CHANNEL) &&\r\n(network->channel != priv->channel)) {\r\nIPW_DEBUG_MERGE("Network '%*pE (%pM)' excluded because of channel mismatch: %d != %d.\n",\r\nnetwork->ssid_len, network->ssid,\r\nnetwork->bssid,\r\nnetwork->channel, priv->channel);\r\nreturn 0;\r\n}\r\nif (((priv->capability & CAP_PRIVACY_ON) ? 1 : 0) !=\r\n((network->capability & WLAN_CAPABILITY_PRIVACY) ? 1 : 0)) {\r\nIPW_DEBUG_MERGE("Network '%*pE (%pM)' excluded because of privacy mismatch: %s != %s.\n",\r\nnetwork->ssid_len, network->ssid,\r\nnetwork->bssid,\r\npriv->\r\ncapability & CAP_PRIVACY_ON ? "on" : "off",\r\nnetwork->\r\ncapability & WLAN_CAPABILITY_PRIVACY ? "on" :\r\n"off");\r\nreturn 0;\r\n}\r\nif (ether_addr_equal(network->bssid, priv->bssid)) {\r\nIPW_DEBUG_MERGE("Network '%*pE (%pM)' excluded because of the same BSSID match: %pM.\n",\r\nnetwork->ssid_len, network->ssid,\r\nnetwork->bssid, priv->bssid);\r\nreturn 0;\r\n}\r\nif (!libipw_is_valid_mode(priv->ieee, network->mode)) {\r\nIPW_DEBUG_MERGE("Network '%*pE (%pM)' excluded because of invalid frequency/mode combination.\n",\r\nnetwork->ssid_len, network->ssid,\r\nnetwork->bssid);\r\nreturn 0;\r\n}\r\nif (!ipw_compatible_rates(priv, network, &rates)) {\r\nIPW_DEBUG_MERGE("Network '%*pE (%pM)' excluded because configured rate mask excludes AP mandatory rate.\n",\r\nnetwork->ssid_len, network->ssid,\r\nnetwork->bssid);\r\nreturn 0;\r\n}\r\nif (rates.num_rates == 0) {\r\nIPW_DEBUG_MERGE("Network '%*pE (%pM)' excluded because of no compatible rates.\n",\r\nnetwork->ssid_len, network->ssid,\r\nnetwork->bssid);\r\nreturn 0;\r\n}\r\nipw_copy_rates(&match->rates, &rates);\r\nmatch->network = network;\r\nIPW_DEBUG_MERGE("Network '%*pE (%pM)' is a viable match.\n",\r\nnetwork->ssid_len, network->ssid, network->bssid);\r\nreturn 1;\r\n}\r\nstatic void ipw_merge_adhoc_network(struct work_struct *work)\r\n{\r\nstruct ipw_priv *priv =\r\ncontainer_of(work, struct ipw_priv, merge_networks);\r\nstruct libipw_network *network = NULL;\r\nstruct ipw_network_match match = {\r\n.network = priv->assoc_network\r\n};\r\nif ((priv->status & STATUS_ASSOCIATED) &&\r\n(priv->ieee->iw_mode == IW_MODE_ADHOC)) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->ieee->lock, flags);\r\nlist_for_each_entry(network, &priv->ieee->network_list, list) {\r\nif (network != priv->assoc_network)\r\nipw_find_adhoc_network(priv, &match, network,\r\n1);\r\n}\r\nspin_unlock_irqrestore(&priv->ieee->lock, flags);\r\nif (match.network == priv->assoc_network) {\r\nIPW_DEBUG_MERGE("No better ADHOC in this network to "\r\n"merge to.\n");\r\nreturn;\r\n}\r\nmutex_lock(&priv->mutex);\r\nif ((priv->ieee->iw_mode == IW_MODE_ADHOC)) {\r\nIPW_DEBUG_MERGE("remove network %*pE\n",\r\npriv->essid_len, priv->essid);\r\nipw_remove_current_network(priv);\r\n}\r\nipw_disassociate(priv);\r\npriv->assoc_network = match.network;\r\nmutex_unlock(&priv->mutex);\r\nreturn;\r\n}\r\n}\r\nstatic int ipw_best_network(struct ipw_priv *priv,\r\nstruct ipw_network_match *match,\r\nstruct libipw_network *network, int roaming)\r\n{\r\nstruct ipw_supported_rates rates;\r\nif ((priv->ieee->iw_mode == IW_MODE_INFRA &&\r\n!(network->capability & WLAN_CAPABILITY_ESS)) ||\r\n(priv->ieee->iw_mode == IW_MODE_ADHOC &&\r\n!(network->capability & WLAN_CAPABILITY_IBSS))) {\r\nIPW_DEBUG_ASSOC("Network '%*pE (%pM)' excluded due to capability mismatch.\n",\r\nnetwork->ssid_len, network->ssid,\r\nnetwork->bssid);\r\nreturn 0;\r\n}\r\nif (unlikely(roaming)) {\r\nif ((network->ssid_len != match->network->ssid_len) ||\r\nmemcmp(network->ssid, match->network->ssid,\r\nnetwork->ssid_len)) {\r\nIPW_DEBUG_ASSOC("Network '%*pE (%pM)' excluded because of non-network ESSID.\n",\r\nnetwork->ssid_len, network->ssid,\r\nnetwork->bssid);\r\nreturn 0;\r\n}\r\n} else {\r\nif ((priv->config & CFG_STATIC_ESSID) &&\r\n((network->ssid_len != priv->essid_len) ||\r\nmemcmp(network->ssid, priv->essid,\r\nmin(network->ssid_len, priv->essid_len)))) {\r\nIPW_DEBUG_ASSOC("Network '%*pE (%pM)' excluded because of ESSID mismatch: '%*pE'.\n",\r\nnetwork->ssid_len, network->ssid,\r\nnetwork->bssid, priv->essid_len,\r\npriv->essid);\r\nreturn 0;\r\n}\r\n}\r\nif (match->network && match->network->stats.rssi > network->stats.rssi) {\r\nIPW_DEBUG_ASSOC("Network '%*pE (%pM)' excluded because '%*pE (%pM)' has a stronger signal.\n",\r\nnetwork->ssid_len, network->ssid,\r\nnetwork->bssid, match->network->ssid_len,\r\nmatch->network->ssid, match->network->bssid);\r\nreturn 0;\r\n}\r\nif (network->last_associate &&\r\ntime_after(network->last_associate + (HZ * 3UL), jiffies)) {\r\nIPW_DEBUG_ASSOC("Network '%*pE (%pM)' excluded because of storming (%ums since last assoc attempt).\n",\r\nnetwork->ssid_len, network->ssid,\r\nnetwork->bssid,\r\njiffies_to_msecs(jiffies -\r\nnetwork->last_associate));\r\nreturn 0;\r\n}\r\nif (priv->ieee->scan_age != 0 &&\r\ntime_after(jiffies, network->last_scanned + priv->ieee->scan_age)) {\r\nIPW_DEBUG_ASSOC("Network '%*pE (%pM)' excluded because of age: %ums.\n",\r\nnetwork->ssid_len, network->ssid,\r\nnetwork->bssid,\r\njiffies_to_msecs(jiffies -\r\nnetwork->last_scanned));\r\nreturn 0;\r\n}\r\nif ((priv->config & CFG_STATIC_CHANNEL) &&\r\n(network->channel != priv->channel)) {\r\nIPW_DEBUG_ASSOC("Network '%*pE (%pM)' excluded because of channel mismatch: %d != %d.\n",\r\nnetwork->ssid_len, network->ssid,\r\nnetwork->bssid,\r\nnetwork->channel, priv->channel);\r\nreturn 0;\r\n}\r\nif (((priv->capability & CAP_PRIVACY_ON) ? 1 : 0) !=\r\n((network->capability & WLAN_CAPABILITY_PRIVACY) ? 1 : 0)) {\r\nIPW_DEBUG_ASSOC("Network '%*pE (%pM)' excluded because of privacy mismatch: %s != %s.\n",\r\nnetwork->ssid_len, network->ssid,\r\nnetwork->bssid,\r\npriv->capability & CAP_PRIVACY_ON ? "on" :\r\n"off",\r\nnetwork->capability &\r\nWLAN_CAPABILITY_PRIVACY ? "on" : "off");\r\nreturn 0;\r\n}\r\nif ((priv->config & CFG_STATIC_BSSID) &&\r\n!ether_addr_equal(network->bssid, priv->bssid)) {\r\nIPW_DEBUG_ASSOC("Network '%*pE (%pM)' excluded because of BSSID mismatch: %pM.\n",\r\nnetwork->ssid_len, network->ssid,\r\nnetwork->bssid, priv->bssid);\r\nreturn 0;\r\n}\r\nif (!libipw_is_valid_mode(priv->ieee, network->mode)) {\r\nIPW_DEBUG_ASSOC("Network '%*pE (%pM)' excluded because of invalid frequency/mode combination.\n",\r\nnetwork->ssid_len, network->ssid,\r\nnetwork->bssid);\r\nreturn 0;\r\n}\r\nif (!libipw_is_valid_channel(priv->ieee, network->channel)) {\r\nIPW_DEBUG_ASSOC("Network '%*pE (%pM)' excluded because of invalid channel in current GEO\n",\r\nnetwork->ssid_len, network->ssid,\r\nnetwork->bssid);\r\nreturn 0;\r\n}\r\nif (!ipw_compatible_rates(priv, network, &rates)) {\r\nIPW_DEBUG_ASSOC("Network '%*pE (%pM)' excluded because configured rate mask excludes AP mandatory rate.\n",\r\nnetwork->ssid_len, network->ssid,\r\nnetwork->bssid);\r\nreturn 0;\r\n}\r\nif (rates.num_rates == 0) {\r\nIPW_DEBUG_ASSOC("Network '%*pE (%pM)' excluded because of no compatible rates.\n",\r\nnetwork->ssid_len, network->ssid,\r\nnetwork->bssid);\r\nreturn 0;\r\n}\r\nipw_copy_rates(&match->rates, &rates);\r\nmatch->network = network;\r\nIPW_DEBUG_ASSOC("Network '%*pE (%pM)' is a viable match.\n",\r\nnetwork->ssid_len, network->ssid, network->bssid);\r\nreturn 1;\r\n}\r\nstatic void ipw_adhoc_create(struct ipw_priv *priv,\r\nstruct libipw_network *network)\r\n{\r\nconst struct libipw_geo *geo = libipw_get_geo(priv->ieee);\r\nint i;\r\nswitch (libipw_is_valid_channel(priv->ieee, priv->channel)) {\r\ncase LIBIPW_52GHZ_BAND:\r\nnetwork->mode = IEEE_A;\r\ni = libipw_channel_to_index(priv->ieee, priv->channel);\r\nBUG_ON(i == -1);\r\nif (geo->a[i].flags & LIBIPW_CH_PASSIVE_ONLY) {\r\nIPW_WARNING("Overriding invalid channel\n");\r\npriv->channel = geo->a[0].channel;\r\n}\r\nbreak;\r\ncase LIBIPW_24GHZ_BAND:\r\nif (priv->ieee->mode & IEEE_G)\r\nnetwork->mode = IEEE_G;\r\nelse\r\nnetwork->mode = IEEE_B;\r\ni = libipw_channel_to_index(priv->ieee, priv->channel);\r\nBUG_ON(i == -1);\r\nif (geo->bg[i].flags & LIBIPW_CH_PASSIVE_ONLY) {\r\nIPW_WARNING("Overriding invalid channel\n");\r\npriv->channel = geo->bg[0].channel;\r\n}\r\nbreak;\r\ndefault:\r\nIPW_WARNING("Overriding invalid channel\n");\r\nif (priv->ieee->mode & IEEE_A) {\r\nnetwork->mode = IEEE_A;\r\npriv->channel = geo->a[0].channel;\r\n} else if (priv->ieee->mode & IEEE_G) {\r\nnetwork->mode = IEEE_G;\r\npriv->channel = geo->bg[0].channel;\r\n} else {\r\nnetwork->mode = IEEE_B;\r\npriv->channel = geo->bg[0].channel;\r\n}\r\nbreak;\r\n}\r\nnetwork->channel = priv->channel;\r\npriv->config |= CFG_ADHOC_PERSIST;\r\nipw_create_bssid(priv, network->bssid);\r\nnetwork->ssid_len = priv->essid_len;\r\nmemcpy(network->ssid, priv->essid, priv->essid_len);\r\nmemset(&network->stats, 0, sizeof(network->stats));\r\nnetwork->capability = WLAN_CAPABILITY_IBSS;\r\nif (!(priv->config & CFG_PREAMBLE_LONG))\r\nnetwork->capability |= WLAN_CAPABILITY_SHORT_PREAMBLE;\r\nif (priv->capability & CAP_PRIVACY_ON)\r\nnetwork->capability |= WLAN_CAPABILITY_PRIVACY;\r\nnetwork->rates_len = min(priv->rates.num_rates, MAX_RATES_LENGTH);\r\nmemcpy(network->rates, priv->rates.supported_rates, network->rates_len);\r\nnetwork->rates_ex_len = priv->rates.num_rates - network->rates_len;\r\nmemcpy(network->rates_ex,\r\n&priv->rates.supported_rates[network->rates_len],\r\nnetwork->rates_ex_len);\r\nnetwork->last_scanned = 0;\r\nnetwork->flags = 0;\r\nnetwork->last_associate = 0;\r\nnetwork->time_stamp[0] = 0;\r\nnetwork->time_stamp[1] = 0;\r\nnetwork->beacon_interval = 100;\r\nnetwork->listen_interval = 10;\r\nnetwork->atim_window = 0;\r\nnetwork->wpa_ie_len = 0;\r\nnetwork->rsn_ie_len = 0;\r\n}\r\nstatic void ipw_send_tgi_tx_key(struct ipw_priv *priv, int type, int index)\r\n{\r\nstruct ipw_tgi_tx_key key;\r\nif (!(priv->ieee->sec.flags & (1 << index)))\r\nreturn;\r\nkey.key_id = index;\r\nmemcpy(key.key, priv->ieee->sec.keys[index], SCM_TEMPORAL_KEY_LENGTH);\r\nkey.security_type = type;\r\nkey.station_index = 0;\r\nkey.flags = 0;\r\nkey.tx_counter[0] = cpu_to_le32(0);\r\nkey.tx_counter[1] = cpu_to_le32(0);\r\nipw_send_cmd_pdu(priv, IPW_CMD_TGI_TX_KEY, sizeof(key), &key);\r\n}\r\nstatic void ipw_send_wep_keys(struct ipw_priv *priv, int type)\r\n{\r\nstruct ipw_wep_key key;\r\nint i;\r\nkey.cmd_id = DINO_CMD_WEP_KEY;\r\nkey.seq_num = 0;\r\nfor (i = 0; i < 4; i++) {\r\nkey.key_index = i | type;\r\nif (!(priv->ieee->sec.flags & (1 << i))) {\r\nkey.key_size = 0;\r\ncontinue;\r\n}\r\nkey.key_size = priv->ieee->sec.key_sizes[i];\r\nmemcpy(key.key, priv->ieee->sec.keys[i], key.key_size);\r\nipw_send_cmd_pdu(priv, IPW_CMD_WEP_KEY, sizeof(key), &key);\r\n}\r\n}\r\nstatic void ipw_set_hw_decrypt_unicast(struct ipw_priv *priv, int level)\r\n{\r\nif (priv->ieee->host_encrypt)\r\nreturn;\r\nswitch (level) {\r\ncase SEC_LEVEL_3:\r\npriv->sys_config.disable_unicast_decryption = 0;\r\npriv->ieee->host_decrypt = 0;\r\nbreak;\r\ncase SEC_LEVEL_2:\r\npriv->sys_config.disable_unicast_decryption = 1;\r\npriv->ieee->host_decrypt = 1;\r\nbreak;\r\ncase SEC_LEVEL_1:\r\npriv->sys_config.disable_unicast_decryption = 0;\r\npriv->ieee->host_decrypt = 0;\r\nbreak;\r\ncase SEC_LEVEL_0:\r\npriv->sys_config.disable_unicast_decryption = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void ipw_set_hw_decrypt_multicast(struct ipw_priv *priv, int level)\r\n{\r\nif (priv->ieee->host_encrypt)\r\nreturn;\r\nswitch (level) {\r\ncase SEC_LEVEL_3:\r\npriv->sys_config.disable_multicast_decryption = 0;\r\nbreak;\r\ncase SEC_LEVEL_2:\r\npriv->sys_config.disable_multicast_decryption = 1;\r\nbreak;\r\ncase SEC_LEVEL_1:\r\npriv->sys_config.disable_multicast_decryption = 0;\r\nbreak;\r\ncase SEC_LEVEL_0:\r\npriv->sys_config.disable_multicast_decryption = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void ipw_set_hwcrypto_keys(struct ipw_priv *priv)\r\n{\r\nswitch (priv->ieee->sec.level) {\r\ncase SEC_LEVEL_3:\r\nif (priv->ieee->sec.flags & SEC_ACTIVE_KEY)\r\nipw_send_tgi_tx_key(priv,\r\nDCT_FLAG_EXT_SECURITY_CCM,\r\npriv->ieee->sec.active_key);\r\nif (!priv->ieee->host_mc_decrypt)\r\nipw_send_wep_keys(priv, DCW_WEP_KEY_SEC_TYPE_CCM);\r\nbreak;\r\ncase SEC_LEVEL_2:\r\nif (priv->ieee->sec.flags & SEC_ACTIVE_KEY)\r\nipw_send_tgi_tx_key(priv,\r\nDCT_FLAG_EXT_SECURITY_TKIP,\r\npriv->ieee->sec.active_key);\r\nbreak;\r\ncase SEC_LEVEL_1:\r\nipw_send_wep_keys(priv, DCW_WEP_KEY_SEC_TYPE_WEP);\r\nipw_set_hw_decrypt_unicast(priv, priv->ieee->sec.level);\r\nipw_set_hw_decrypt_multicast(priv, priv->ieee->sec.level);\r\nbreak;\r\ncase SEC_LEVEL_0:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void ipw_adhoc_check(void *data)\r\n{\r\nstruct ipw_priv *priv = data;\r\nif (priv->missed_adhoc_beacons++ > priv->disassociate_threshold &&\r\n!(priv->config & CFG_ADHOC_PERSIST)) {\r\nIPW_DEBUG(IPW_DL_INFO | IPW_DL_NOTIF |\r\nIPW_DL_STATE | IPW_DL_ASSOC,\r\n"Missed beacon: %d - disassociate\n",\r\npriv->missed_adhoc_beacons);\r\nipw_remove_current_network(priv);\r\nipw_disassociate(priv);\r\nreturn;\r\n}\r\nschedule_delayed_work(&priv->adhoc_check,\r\nle16_to_cpu(priv->assoc_request.beacon_interval));\r\n}\r\nstatic void ipw_bg_adhoc_check(struct work_struct *work)\r\n{\r\nstruct ipw_priv *priv =\r\ncontainer_of(work, struct ipw_priv, adhoc_check.work);\r\nmutex_lock(&priv->mutex);\r\nipw_adhoc_check(priv);\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic void ipw_debug_config(struct ipw_priv *priv)\r\n{\r\nIPW_DEBUG_INFO("Scan completed, no valid APs matched "\r\n"[CFG 0x%08X]\n", priv->config);\r\nif (priv->config & CFG_STATIC_CHANNEL)\r\nIPW_DEBUG_INFO("Channel locked to %d\n", priv->channel);\r\nelse\r\nIPW_DEBUG_INFO("Channel unlocked.\n");\r\nif (priv->config & CFG_STATIC_ESSID)\r\nIPW_DEBUG_INFO("ESSID locked to '%*pE'\n",\r\npriv->essid_len, priv->essid);\r\nelse\r\nIPW_DEBUG_INFO("ESSID unlocked.\n");\r\nif (priv->config & CFG_STATIC_BSSID)\r\nIPW_DEBUG_INFO("BSSID locked to %pM\n", priv->bssid);\r\nelse\r\nIPW_DEBUG_INFO("BSSID unlocked.\n");\r\nif (priv->capability & CAP_PRIVACY_ON)\r\nIPW_DEBUG_INFO("PRIVACY on\n");\r\nelse\r\nIPW_DEBUG_INFO("PRIVACY off\n");\r\nIPW_DEBUG_INFO("RATE MASK: 0x%08X\n", priv->rates_mask);\r\n}\r\nstatic void ipw_set_fixed_rate(struct ipw_priv *priv, int mode)\r\n{\r\nstruct ipw_fixed_rate fr;\r\nu32 reg;\r\nu16 mask = 0;\r\nu16 new_tx_rates = priv->rates_mask;\r\nswitch (priv->ieee->freq_band) {\r\ncase LIBIPW_52GHZ_BAND:\r\nif (priv->rates_mask & ~LIBIPW_OFDM_RATES_MASK) {\r\nIPW_DEBUG_WX\r\n("invalid fixed rate mask in ipw_set_fixed_rate\n");\r\nnew_tx_rates = 0;\r\nbreak;\r\n}\r\nnew_tx_rates >>= LIBIPW_OFDM_SHIFT_MASK_A;\r\nbreak;\r\ndefault:\r\nif (mode == IEEE_B) {\r\nif (new_tx_rates & ~LIBIPW_CCK_RATES_MASK) {\r\nIPW_DEBUG_WX\r\n("invalid fixed rate mask in ipw_set_fixed_rate\n");\r\nnew_tx_rates = 0;\r\n}\r\nbreak;\r\n}\r\nif (new_tx_rates & ~(LIBIPW_CCK_RATES_MASK |\r\nLIBIPW_OFDM_RATES_MASK)) {\r\nIPW_DEBUG_WX\r\n("invalid fixed rate mask in ipw_set_fixed_rate\n");\r\nnew_tx_rates = 0;\r\nbreak;\r\n}\r\nif (LIBIPW_OFDM_RATE_6MB_MASK & new_tx_rates) {\r\nmask |= (LIBIPW_OFDM_RATE_6MB_MASK >> 1);\r\nnew_tx_rates &= ~LIBIPW_OFDM_RATE_6MB_MASK;\r\n}\r\nif (LIBIPW_OFDM_RATE_9MB_MASK & new_tx_rates) {\r\nmask |= (LIBIPW_OFDM_RATE_9MB_MASK >> 1);\r\nnew_tx_rates &= ~LIBIPW_OFDM_RATE_9MB_MASK;\r\n}\r\nif (LIBIPW_OFDM_RATE_12MB_MASK & new_tx_rates) {\r\nmask |= (LIBIPW_OFDM_RATE_12MB_MASK >> 1);\r\nnew_tx_rates &= ~LIBIPW_OFDM_RATE_12MB_MASK;\r\n}\r\nnew_tx_rates |= mask;\r\nbreak;\r\n}\r\nfr.tx_rates = cpu_to_le16(new_tx_rates);\r\nreg = ipw_read32(priv, IPW_MEM_FIXED_OVERRIDE);\r\nipw_write_reg32(priv, reg, *(u32 *) & fr);\r\n}\r\nstatic void ipw_abort_scan(struct ipw_priv *priv)\r\n{\r\nint err;\r\nif (priv->status & STATUS_SCAN_ABORTING) {\r\nIPW_DEBUG_HC("Ignoring concurrent scan abort request.\n");\r\nreturn;\r\n}\r\npriv->status |= STATUS_SCAN_ABORTING;\r\nerr = ipw_send_scan_abort(priv);\r\nif (err)\r\nIPW_DEBUG_HC("Request to abort scan failed.\n");\r\n}\r\nstatic void ipw_add_scan_channels(struct ipw_priv *priv,\r\nstruct ipw_scan_request_ext *scan,\r\nint scan_type)\r\n{\r\nint channel_index = 0;\r\nconst struct libipw_geo *geo;\r\nint i;\r\ngeo = libipw_get_geo(priv->ieee);\r\nif (priv->ieee->freq_band & LIBIPW_52GHZ_BAND) {\r\nint start = channel_index;\r\nfor (i = 0; i < geo->a_channels; i++) {\r\nif ((priv->status & STATUS_ASSOCIATED) &&\r\ngeo->a[i].channel == priv->channel)\r\ncontinue;\r\nchannel_index++;\r\nscan->channels_list[channel_index] = geo->a[i].channel;\r\nipw_set_scan_type(scan, channel_index,\r\ngeo->a[i].\r\nflags & LIBIPW_CH_PASSIVE_ONLY ?\r\nIPW_SCAN_PASSIVE_FULL_DWELL_SCAN :\r\nscan_type);\r\n}\r\nif (start != channel_index) {\r\nscan->channels_list[start] = (u8) (IPW_A_MODE << 6) |\r\n(channel_index - start);\r\nchannel_index++;\r\n}\r\n}\r\nif (priv->ieee->freq_band & LIBIPW_24GHZ_BAND) {\r\nint start = channel_index;\r\nif (priv->config & CFG_SPEED_SCAN) {\r\nint index;\r\nu8 channels[LIBIPW_24GHZ_CHANNELS] = {\r\n[0] = 0\r\n};\r\nu8 channel;\r\nwhile (channel_index < IPW_SCAN_CHANNELS - 1) {\r\nchannel =\r\npriv->speed_scan[priv->speed_scan_pos];\r\nif (channel == 0) {\r\npriv->speed_scan_pos = 0;\r\nchannel = priv->speed_scan[0];\r\n}\r\nif ((priv->status & STATUS_ASSOCIATED) &&\r\nchannel == priv->channel) {\r\npriv->speed_scan_pos++;\r\ncontinue;\r\n}\r\nif (channels[channel - 1] != 0)\r\nbreak;\r\nchannels[channel - 1] = 1;\r\npriv->speed_scan_pos++;\r\nchannel_index++;\r\nscan->channels_list[channel_index] = channel;\r\nindex =\r\nlibipw_channel_to_index(priv->ieee, channel);\r\nipw_set_scan_type(scan, channel_index,\r\ngeo->bg[index].\r\nflags &\r\nLIBIPW_CH_PASSIVE_ONLY ?\r\nIPW_SCAN_PASSIVE_FULL_DWELL_SCAN\r\n: scan_type);\r\n}\r\n} else {\r\nfor (i = 0; i < geo->bg_channels; i++) {\r\nif ((priv->status & STATUS_ASSOCIATED) &&\r\ngeo->bg[i].channel == priv->channel)\r\ncontinue;\r\nchannel_index++;\r\nscan->channels_list[channel_index] =\r\ngeo->bg[i].channel;\r\nipw_set_scan_type(scan, channel_index,\r\ngeo->bg[i].\r\nflags &\r\nLIBIPW_CH_PASSIVE_ONLY ?\r\nIPW_SCAN_PASSIVE_FULL_DWELL_SCAN\r\n: scan_type);\r\n}\r\n}\r\nif (start != channel_index) {\r\nscan->channels_list[start] = (u8) (IPW_B_MODE << 6) |\r\n(channel_index - start);\r\n}\r\n}\r\n}\r\nstatic int ipw_passive_dwell_time(struct ipw_priv *priv)\r\n{\r\nif (priv->status & STATUS_ASSOCIATED\r\n&& priv->assoc_network->beacon_interval > 10)\r\nreturn priv->assoc_network->beacon_interval - 10;\r\nelse\r\nreturn 120;\r\n}\r\nstatic int ipw_request_scan_helper(struct ipw_priv *priv, int type, int direct)\r\n{\r\nstruct ipw_scan_request_ext scan;\r\nint err = 0, scan_type;\r\nif (!(priv->status & STATUS_INIT) ||\r\n(priv->status & STATUS_EXIT_PENDING))\r\nreturn 0;\r\nmutex_lock(&priv->mutex);\r\nif (direct && (priv->direct_scan_ssid_len == 0)) {\r\nIPW_DEBUG_HC("Direct scan requested but no SSID to scan for\n");\r\npriv->status &= ~STATUS_DIRECT_SCAN_PENDING;\r\ngoto done;\r\n}\r\nif (priv->status & STATUS_SCANNING) {\r\nIPW_DEBUG_HC("Concurrent scan requested. Queuing.\n");\r\npriv->status |= direct ? STATUS_DIRECT_SCAN_PENDING :\r\nSTATUS_SCAN_PENDING;\r\ngoto done;\r\n}\r\nif (!(priv->status & STATUS_SCAN_FORCED) &&\r\npriv->status & STATUS_SCAN_ABORTING) {\r\nIPW_DEBUG_HC("Scan request while abort pending. Queuing.\n");\r\npriv->status |= direct ? STATUS_DIRECT_SCAN_PENDING :\r\nSTATUS_SCAN_PENDING;\r\ngoto done;\r\n}\r\nif (priv->status & STATUS_RF_KILL_MASK) {\r\nIPW_DEBUG_HC("Queuing scan due to RF Kill activation\n");\r\npriv->status |= direct ? STATUS_DIRECT_SCAN_PENDING :\r\nSTATUS_SCAN_PENDING;\r\ngoto done;\r\n}\r\nmemset(&scan, 0, sizeof(scan));\r\nscan.full_scan_index = cpu_to_le32(libipw_get_scans(priv->ieee));\r\nif (type == IW_SCAN_TYPE_PASSIVE) {\r\nIPW_DEBUG_WX("use passive scanning\n");\r\nscan_type = IPW_SCAN_PASSIVE_FULL_DWELL_SCAN;\r\nscan.dwell_time[IPW_SCAN_PASSIVE_FULL_DWELL_SCAN] =\r\ncpu_to_le16(ipw_passive_dwell_time(priv));\r\nipw_add_scan_channels(priv, &scan, scan_type);\r\ngoto send_request;\r\n}\r\nif (priv->config & CFG_SPEED_SCAN)\r\nscan.dwell_time[IPW_SCAN_ACTIVE_BROADCAST_SCAN] =\r\ncpu_to_le16(30);\r\nelse\r\nscan.dwell_time[IPW_SCAN_ACTIVE_BROADCAST_SCAN] =\r\ncpu_to_le16(20);\r\nscan.dwell_time[IPW_SCAN_ACTIVE_BROADCAST_AND_DIRECT_SCAN] =\r\ncpu_to_le16(20);\r\nscan.dwell_time[IPW_SCAN_PASSIVE_FULL_DWELL_SCAN] =\r\ncpu_to_le16(ipw_passive_dwell_time(priv));\r\nscan.dwell_time[IPW_SCAN_ACTIVE_DIRECT_SCAN] = cpu_to_le16(20);\r\n#ifdef CONFIG_IPW2200_MONITOR\r\nif (priv->ieee->iw_mode == IW_MODE_MONITOR) {\r\nu8 channel;\r\nu8 band = 0;\r\nswitch (libipw_is_valid_channel(priv->ieee, priv->channel)) {\r\ncase LIBIPW_52GHZ_BAND:\r\nband = (u8) (IPW_A_MODE << 6) | 1;\r\nchannel = priv->channel;\r\nbreak;\r\ncase LIBIPW_24GHZ_BAND:\r\nband = (u8) (IPW_B_MODE << 6) | 1;\r\nchannel = priv->channel;\r\nbreak;\r\ndefault:\r\nband = (u8) (IPW_B_MODE << 6) | 1;\r\nchannel = 9;\r\nbreak;\r\n}\r\nscan.channels_list[0] = band;\r\nscan.channels_list[1] = channel;\r\nipw_set_scan_type(&scan, 1, IPW_SCAN_PASSIVE_FULL_DWELL_SCAN);\r\nscan.dwell_time[IPW_SCAN_PASSIVE_FULL_DWELL_SCAN] =\r\ncpu_to_le16(2000);\r\n} else {\r\n#endif\r\nif (direct) {\r\nerr = ipw_send_ssid(priv, priv->direct_scan_ssid,\r\npriv->direct_scan_ssid_len);\r\nif (err) {\r\nIPW_DEBUG_HC("Attempt to send SSID command "\r\n"failed\n");\r\ngoto done;\r\n}\r\nscan_type = IPW_SCAN_ACTIVE_BROADCAST_AND_DIRECT_SCAN;\r\n} else if ((priv->status & STATUS_ROAMING)\r\n|| (!(priv->status & STATUS_ASSOCIATED)\r\n&& (priv->config & CFG_STATIC_ESSID)\r\n&& (le32_to_cpu(scan.full_scan_index) % 2))) {\r\nerr = ipw_send_ssid(priv, priv->essid, priv->essid_len);\r\nif (err) {\r\nIPW_DEBUG_HC("Attempt to send SSID command "\r\n"failed.\n");\r\ngoto done;\r\n}\r\nscan_type = IPW_SCAN_ACTIVE_BROADCAST_AND_DIRECT_SCAN;\r\n} else\r\nscan_type = IPW_SCAN_ACTIVE_BROADCAST_SCAN;\r\nipw_add_scan_channels(priv, &scan, scan_type);\r\n#ifdef CONFIG_IPW2200_MONITOR\r\n}\r\n#endif\r\nsend_request:\r\nerr = ipw_send_scan_request_ext(priv, &scan);\r\nif (err) {\r\nIPW_DEBUG_HC("Sending scan command failed: %08X\n", err);\r\ngoto done;\r\n}\r\npriv->status |= STATUS_SCANNING;\r\nif (direct) {\r\npriv->status &= ~STATUS_DIRECT_SCAN_PENDING;\r\npriv->direct_scan_ssid_len = 0;\r\n} else\r\npriv->status &= ~STATUS_SCAN_PENDING;\r\nschedule_delayed_work(&priv->scan_check, IPW_SCAN_CHECK_WATCHDOG);\r\ndone:\r\nmutex_unlock(&priv->mutex);\r\nreturn err;\r\n}\r\nstatic void ipw_request_passive_scan(struct work_struct *work)\r\n{\r\nstruct ipw_priv *priv =\r\ncontainer_of(work, struct ipw_priv, request_passive_scan.work);\r\nipw_request_scan_helper(priv, IW_SCAN_TYPE_PASSIVE, 0);\r\n}\r\nstatic void ipw_request_scan(struct work_struct *work)\r\n{\r\nstruct ipw_priv *priv =\r\ncontainer_of(work, struct ipw_priv, request_scan.work);\r\nipw_request_scan_helper(priv, IW_SCAN_TYPE_ACTIVE, 0);\r\n}\r\nstatic void ipw_request_direct_scan(struct work_struct *work)\r\n{\r\nstruct ipw_priv *priv =\r\ncontainer_of(work, struct ipw_priv, request_direct_scan.work);\r\nipw_request_scan_helper(priv, IW_SCAN_TYPE_ACTIVE, 1);\r\n}\r\nstatic void ipw_bg_abort_scan(struct work_struct *work)\r\n{\r\nstruct ipw_priv *priv =\r\ncontainer_of(work, struct ipw_priv, abort_scan);\r\nmutex_lock(&priv->mutex);\r\nipw_abort_scan(priv);\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic int ipw_wpa_enable(struct ipw_priv *priv, int value)\r\n{\r\npriv->ieee->wpa_enabled = value;\r\nreturn 0;\r\n}\r\nstatic int ipw_wpa_set_auth_algs(struct ipw_priv *priv, int value)\r\n{\r\nstruct libipw_device *ieee = priv->ieee;\r\nstruct libipw_security sec = {\r\n.flags = SEC_AUTH_MODE,\r\n};\r\nint ret = 0;\r\nif (value & IW_AUTH_ALG_SHARED_KEY) {\r\nsec.auth_mode = WLAN_AUTH_SHARED_KEY;\r\nieee->open_wep = 0;\r\n} else if (value & IW_AUTH_ALG_OPEN_SYSTEM) {\r\nsec.auth_mode = WLAN_AUTH_OPEN;\r\nieee->open_wep = 1;\r\n} else if (value & IW_AUTH_ALG_LEAP) {\r\nsec.auth_mode = WLAN_AUTH_LEAP;\r\nieee->open_wep = 1;\r\n} else\r\nreturn -EINVAL;\r\nif (ieee->set_security)\r\nieee->set_security(ieee->dev, &sec);\r\nelse\r\nret = -EOPNOTSUPP;\r\nreturn ret;\r\n}\r\nstatic void ipw_wpa_assoc_frame(struct ipw_priv *priv, char *wpa_ie,\r\nint wpa_ie_len)\r\n{\r\nipw_wpa_enable(priv, 1);\r\n}\r\nstatic int ipw_set_rsn_capa(struct ipw_priv *priv,\r\nchar *capabilities, int length)\r\n{\r\nIPW_DEBUG_HC("HOST_CMD_RSN_CAPABILITIES\n");\r\nreturn ipw_send_cmd_pdu(priv, IPW_CMD_RSN_CAPABILITIES, length,\r\ncapabilities);\r\n}\r\nstatic int ipw_wx_set_genie(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nstruct libipw_device *ieee = priv->ieee;\r\nu8 *buf;\r\nint err = 0;\r\nif (wrqu->data.length > MAX_WPA_IE_LEN ||\r\n(wrqu->data.length && extra == NULL))\r\nreturn -EINVAL;\r\nif (wrqu->data.length) {\r\nbuf = kmemdup(extra, wrqu->data.length, GFP_KERNEL);\r\nif (buf == NULL) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nkfree(ieee->wpa_ie);\r\nieee->wpa_ie = buf;\r\nieee->wpa_ie_len = wrqu->data.length;\r\n} else {\r\nkfree(ieee->wpa_ie);\r\nieee->wpa_ie = NULL;\r\nieee->wpa_ie_len = 0;\r\n}\r\nipw_wpa_assoc_frame(priv, ieee->wpa_ie, ieee->wpa_ie_len);\r\nout:\r\nreturn err;\r\n}\r\nstatic int ipw_wx_get_genie(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nstruct libipw_device *ieee = priv->ieee;\r\nint err = 0;\r\nif (ieee->wpa_ie_len == 0 || ieee->wpa_ie == NULL) {\r\nwrqu->data.length = 0;\r\ngoto out;\r\n}\r\nif (wrqu->data.length < ieee->wpa_ie_len) {\r\nerr = -E2BIG;\r\ngoto out;\r\n}\r\nwrqu->data.length = ieee->wpa_ie_len;\r\nmemcpy(extra, ieee->wpa_ie, ieee->wpa_ie_len);\r\nout:\r\nreturn err;\r\n}\r\nstatic int wext_cipher2level(int cipher)\r\n{\r\nswitch (cipher) {\r\ncase IW_AUTH_CIPHER_NONE:\r\nreturn SEC_LEVEL_0;\r\ncase IW_AUTH_CIPHER_WEP40:\r\ncase IW_AUTH_CIPHER_WEP104:\r\nreturn SEC_LEVEL_1;\r\ncase IW_AUTH_CIPHER_TKIP:\r\nreturn SEC_LEVEL_2;\r\ncase IW_AUTH_CIPHER_CCMP:\r\nreturn SEC_LEVEL_3;\r\ndefault:\r\nreturn -1;\r\n}\r\n}\r\nstatic int ipw_wx_set_auth(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nstruct libipw_device *ieee = priv->ieee;\r\nstruct iw_param *param = &wrqu->param;\r\nstruct lib80211_crypt_data *crypt;\r\nunsigned long flags;\r\nint ret = 0;\r\nswitch (param->flags & IW_AUTH_INDEX) {\r\ncase IW_AUTH_WPA_VERSION:\r\nbreak;\r\ncase IW_AUTH_CIPHER_PAIRWISE:\r\nipw_set_hw_decrypt_unicast(priv,\r\nwext_cipher2level(param->value));\r\nbreak;\r\ncase IW_AUTH_CIPHER_GROUP:\r\nipw_set_hw_decrypt_multicast(priv,\r\nwext_cipher2level(param->value));\r\nbreak;\r\ncase IW_AUTH_KEY_MGMT:\r\nbreak;\r\ncase IW_AUTH_TKIP_COUNTERMEASURES:\r\ncrypt = priv->ieee->crypt_info.crypt[priv->ieee->crypt_info.tx_keyidx];\r\nif (!crypt || !crypt->ops->set_flags || !crypt->ops->get_flags)\r\nbreak;\r\nflags = crypt->ops->get_flags(crypt->priv);\r\nif (param->value)\r\nflags |= IEEE80211_CRYPTO_TKIP_COUNTERMEASURES;\r\nelse\r\nflags &= ~IEEE80211_CRYPTO_TKIP_COUNTERMEASURES;\r\ncrypt->ops->set_flags(flags, crypt->priv);\r\nbreak;\r\ncase IW_AUTH_DROP_UNENCRYPTED:{\r\nstruct libipw_security sec = {\r\n.flags = SEC_ENABLED,\r\n.enabled = param->value,\r\n};\r\npriv->ieee->drop_unencrypted = param->value;\r\nif (!param->value) {\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_0;\r\n} else {\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_1;\r\n}\r\nif (priv->ieee->set_security)\r\npriv->ieee->set_security(priv->ieee->dev, &sec);\r\nbreak;\r\n}\r\ncase IW_AUTH_80211_AUTH_ALG:\r\nret = ipw_wpa_set_auth_algs(priv, param->value);\r\nbreak;\r\ncase IW_AUTH_WPA_ENABLED:\r\nret = ipw_wpa_enable(priv, param->value);\r\nipw_disassociate(priv);\r\nbreak;\r\ncase IW_AUTH_RX_UNENCRYPTED_EAPOL:\r\nieee->ieee802_1x = param->value;\r\nbreak;\r\ncase IW_AUTH_PRIVACY_INVOKED:\r\nieee->privacy_invoked = param->value;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ipw_wx_get_auth(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nstruct libipw_device *ieee = priv->ieee;\r\nstruct lib80211_crypt_data *crypt;\r\nstruct iw_param *param = &wrqu->param;\r\nswitch (param->flags & IW_AUTH_INDEX) {\r\ncase IW_AUTH_WPA_VERSION:\r\ncase IW_AUTH_CIPHER_PAIRWISE:\r\ncase IW_AUTH_CIPHER_GROUP:\r\ncase IW_AUTH_KEY_MGMT:\r\nreturn -EOPNOTSUPP;\r\ncase IW_AUTH_TKIP_COUNTERMEASURES:\r\ncrypt = priv->ieee->crypt_info.crypt[priv->ieee->crypt_info.tx_keyidx];\r\nif (!crypt || !crypt->ops->get_flags)\r\nbreak;\r\nparam->value = (crypt->ops->get_flags(crypt->priv) &\r\nIEEE80211_CRYPTO_TKIP_COUNTERMEASURES) ? 1 : 0;\r\nbreak;\r\ncase IW_AUTH_DROP_UNENCRYPTED:\r\nparam->value = ieee->drop_unencrypted;\r\nbreak;\r\ncase IW_AUTH_80211_AUTH_ALG:\r\nparam->value = ieee->sec.auth_mode;\r\nbreak;\r\ncase IW_AUTH_WPA_ENABLED:\r\nparam->value = ieee->wpa_enabled;\r\nbreak;\r\ncase IW_AUTH_RX_UNENCRYPTED_EAPOL:\r\nparam->value = ieee->ieee802_1x;\r\nbreak;\r\ncase IW_AUTH_ROAMING_CONTROL:\r\ncase IW_AUTH_PRIVACY_INVOKED:\r\nparam->value = ieee->privacy_invoked;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_set_encodeext(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\r\nif (hwcrypto) {\r\nif (ext->alg == IW_ENCODE_ALG_TKIP) {\r\nif (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY)\r\npriv->ieee->host_mc_decrypt = 1;\r\nelse {\r\npriv->ieee->host_encrypt = 0;\r\npriv->ieee->host_encrypt_msdu = 1;\r\npriv->ieee->host_decrypt = 1;\r\n}\r\n} else {\r\npriv->ieee->host_encrypt = 0;\r\npriv->ieee->host_encrypt_msdu = 0;\r\npriv->ieee->host_decrypt = 0;\r\npriv->ieee->host_mc_decrypt = 0;\r\n}\r\n}\r\nreturn libipw_wx_set_encodeext(priv->ieee, info, wrqu, extra);\r\n}\r\nstatic int ipw_wx_get_encodeext(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nreturn libipw_wx_get_encodeext(priv->ieee, info, wrqu, extra);\r\n}\r\nstatic int ipw_wx_set_mlme(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nstruct iw_mlme *mlme = (struct iw_mlme *)extra;\r\n__le16 reason;\r\nreason = cpu_to_le16(mlme->reason_code);\r\nswitch (mlme->cmd) {\r\ncase IW_MLME_DEAUTH:\r\nbreak;\r\ncase IW_MLME_DISASSOC:\r\nipw_disassociate(priv);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic u8 ipw_qos_current_mode(struct ipw_priv * priv)\r\n{\r\nu8 mode = 0;\r\nif (priv->status & STATUS_ASSOCIATED) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->ieee->lock, flags);\r\nmode = priv->assoc_network->mode;\r\nspin_unlock_irqrestore(&priv->ieee->lock, flags);\r\n} else {\r\nmode = priv->ieee->mode;\r\n}\r\nIPW_DEBUG_QOS("QoS network/card mode %d\n", mode);\r\nreturn mode;\r\n}\r\nstatic int ipw_qos_handle_probe_response(struct ipw_priv *priv,\r\nint active_network,\r\nstruct libipw_network *network)\r\n{\r\nu32 size = sizeof(struct libipw_qos_parameters);\r\nif (network->capability & WLAN_CAPABILITY_IBSS)\r\nnetwork->qos_data.active = network->qos_data.supported;\r\nif (network->flags & NETWORK_HAS_QOS_MASK) {\r\nif (active_network &&\r\n(network->flags & NETWORK_HAS_QOS_PARAMETERS))\r\nnetwork->qos_data.active = network->qos_data.supported;\r\nif ((network->qos_data.active == 1) && (active_network == 1) &&\r\n(network->flags & NETWORK_HAS_QOS_PARAMETERS) &&\r\n(network->qos_data.old_param_count !=\r\nnetwork->qos_data.param_count)) {\r\nnetwork->qos_data.old_param_count =\r\nnetwork->qos_data.param_count;\r\nschedule_work(&priv->qos_activate);\r\nIPW_DEBUG_QOS("QoS parameters change call "\r\n"qos_activate\n");\r\n}\r\n} else {\r\nif ((priv->ieee->mode == IEEE_B) || (network->mode == IEEE_B))\r\nmemcpy(&network->qos_data.parameters,\r\n&def_parameters_CCK, size);\r\nelse\r\nmemcpy(&network->qos_data.parameters,\r\n&def_parameters_OFDM, size);\r\nif ((network->qos_data.active == 1) && (active_network == 1)) {\r\nIPW_DEBUG_QOS("QoS was disabled call qos_activate\n");\r\nschedule_work(&priv->qos_activate);\r\n}\r\nnetwork->qos_data.active = 0;\r\nnetwork->qos_data.supported = 0;\r\n}\r\nif ((priv->status & STATUS_ASSOCIATED) &&\r\n(priv->ieee->iw_mode == IW_MODE_ADHOC) && (active_network == 0)) {\r\nif (!ether_addr_equal(network->bssid, priv->bssid))\r\nif (network->capability & WLAN_CAPABILITY_IBSS)\r\nif ((network->ssid_len ==\r\npriv->assoc_network->ssid_len) &&\r\n!memcmp(network->ssid,\r\npriv->assoc_network->ssid,\r\nnetwork->ssid_len)) {\r\nschedule_work(&priv->merge_networks);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ipw_qos_activate(struct ipw_priv *priv,\r\nstruct libipw_qos_data *qos_network_data)\r\n{\r\nint err;\r\nstruct libipw_qos_parameters qos_parameters[QOS_QOS_SETS];\r\nstruct libipw_qos_parameters *active_one = NULL;\r\nu32 size = sizeof(struct libipw_qos_parameters);\r\nu32 burst_duration;\r\nint i;\r\nu8 type;\r\ntype = ipw_qos_current_mode(priv);\r\nactive_one = &(qos_parameters[QOS_PARAM_SET_DEF_CCK]);\r\nmemcpy(active_one, priv->qos_data.def_qos_parm_CCK, size);\r\nactive_one = &(qos_parameters[QOS_PARAM_SET_DEF_OFDM]);\r\nmemcpy(active_one, priv->qos_data.def_qos_parm_OFDM, size);\r\nif (qos_network_data == NULL) {\r\nif (type == IEEE_B) {\r\nIPW_DEBUG_QOS("QoS activate network mode %d\n", type);\r\nactive_one = &def_parameters_CCK;\r\n} else\r\nactive_one = &def_parameters_OFDM;\r\nmemcpy(&qos_parameters[QOS_PARAM_SET_ACTIVE], active_one, size);\r\nburst_duration = ipw_qos_get_burst_duration(priv);\r\nfor (i = 0; i < QOS_QUEUE_NUM; i++)\r\nqos_parameters[QOS_PARAM_SET_ACTIVE].tx_op_limit[i] =\r\ncpu_to_le16(burst_duration);\r\n} else if (priv->ieee->iw_mode == IW_MODE_ADHOC) {\r\nif (type == IEEE_B) {\r\nIPW_DEBUG_QOS("QoS activate IBSS network mode %d\n",\r\ntype);\r\nif (priv->qos_data.qos_enable == 0)\r\nactive_one = &def_parameters_CCK;\r\nelse\r\nactive_one = priv->qos_data.def_qos_parm_CCK;\r\n} else {\r\nif (priv->qos_data.qos_enable == 0)\r\nactive_one = &def_parameters_OFDM;\r\nelse\r\nactive_one = priv->qos_data.def_qos_parm_OFDM;\r\n}\r\nmemcpy(&qos_parameters[QOS_PARAM_SET_ACTIVE], active_one, size);\r\n} else {\r\nunsigned long flags;\r\nint active;\r\nspin_lock_irqsave(&priv->ieee->lock, flags);\r\nactive_one = &(qos_network_data->parameters);\r\nqos_network_data->old_param_count =\r\nqos_network_data->param_count;\r\nmemcpy(&qos_parameters[QOS_PARAM_SET_ACTIVE], active_one, size);\r\nactive = qos_network_data->supported;\r\nspin_unlock_irqrestore(&priv->ieee->lock, flags);\r\nif (active == 0) {\r\nburst_duration = ipw_qos_get_burst_duration(priv);\r\nfor (i = 0; i < QOS_QUEUE_NUM; i++)\r\nqos_parameters[QOS_PARAM_SET_ACTIVE].\r\ntx_op_limit[i] = cpu_to_le16(burst_duration);\r\n}\r\n}\r\nIPW_DEBUG_QOS("QoS sending IPW_CMD_QOS_PARAMETERS\n");\r\nerr = ipw_send_qos_params_command(priv, &qos_parameters[0]);\r\nif (err)\r\nIPW_DEBUG_QOS("QoS IPW_CMD_QOS_PARAMETERS failed\n");\r\nreturn err;\r\n}\r\nstatic int ipw_qos_set_info_element(struct ipw_priv *priv)\r\n{\r\nint ret = 0;\r\nstruct libipw_qos_information_element qos_info;\r\nif (priv == NULL)\r\nreturn -1;\r\nqos_info.elementID = QOS_ELEMENT_ID;\r\nqos_info.length = sizeof(struct libipw_qos_information_element) - 2;\r\nqos_info.version = QOS_VERSION_1;\r\nqos_info.ac_info = 0;\r\nmemcpy(qos_info.qui, qos_oui, QOS_OUI_LEN);\r\nqos_info.qui_type = QOS_OUI_TYPE;\r\nqos_info.qui_subtype = QOS_OUI_INFO_SUB_TYPE;\r\nret = ipw_send_qos_info_command(priv, &qos_info);\r\nif (ret != 0) {\r\nIPW_DEBUG_QOS("QoS error calling ipw_send_qos_info_command\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic int ipw_qos_association(struct ipw_priv *priv,\r\nstruct libipw_network *network)\r\n{\r\nint err = 0;\r\nstruct libipw_qos_data *qos_data = NULL;\r\nstruct libipw_qos_data ibss_data = {\r\n.supported = 1,\r\n.active = 1,\r\n};\r\nswitch (priv->ieee->iw_mode) {\r\ncase IW_MODE_ADHOC:\r\nBUG_ON(!(network->capability & WLAN_CAPABILITY_IBSS));\r\nqos_data = &ibss_data;\r\nbreak;\r\ncase IW_MODE_INFRA:\r\nqos_data = &network->qos_data;\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nerr = ipw_qos_activate(priv, qos_data);\r\nif (err) {\r\npriv->assoc_request.policy_support &= ~HC_QOS_SUPPORT_ASSOC;\r\nreturn err;\r\n}\r\nif (priv->qos_data.qos_enable && qos_data->supported) {\r\nIPW_DEBUG_QOS("QoS will be enabled for this association\n");\r\npriv->assoc_request.policy_support |= HC_QOS_SUPPORT_ASSOC;\r\nreturn ipw_qos_set_info_element(priv);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ipw_qos_association_resp(struct ipw_priv *priv,\r\nstruct libipw_network *network)\r\n{\r\nint ret = 0;\r\nunsigned long flags;\r\nu32 size = sizeof(struct libipw_qos_parameters);\r\nint set_qos_param = 0;\r\nif ((priv == NULL) || (network == NULL) ||\r\n(priv->assoc_network == NULL))\r\nreturn ret;\r\nif (!(priv->status & STATUS_ASSOCIATED))\r\nreturn ret;\r\nif ((priv->ieee->iw_mode != IW_MODE_INFRA))\r\nreturn ret;\r\nspin_lock_irqsave(&priv->ieee->lock, flags);\r\nif (network->flags & NETWORK_HAS_QOS_PARAMETERS) {\r\nmemcpy(&priv->assoc_network->qos_data, &network->qos_data,\r\nsizeof(struct libipw_qos_data));\r\npriv->assoc_network->qos_data.active = 1;\r\nif ((network->qos_data.old_param_count !=\r\nnetwork->qos_data.param_count)) {\r\nset_qos_param = 1;\r\nnetwork->qos_data.old_param_count =\r\nnetwork->qos_data.param_count;\r\n}\r\n} else {\r\nif ((network->mode == IEEE_B) || (priv->ieee->mode == IEEE_B))\r\nmemcpy(&priv->assoc_network->qos_data.parameters,\r\n&def_parameters_CCK, size);\r\nelse\r\nmemcpy(&priv->assoc_network->qos_data.parameters,\r\n&def_parameters_OFDM, size);\r\npriv->assoc_network->qos_data.active = 0;\r\npriv->assoc_network->qos_data.supported = 0;\r\nset_qos_param = 1;\r\n}\r\nspin_unlock_irqrestore(&priv->ieee->lock, flags);\r\nif (set_qos_param == 1)\r\nschedule_work(&priv->qos_activate);\r\nreturn ret;\r\n}\r\nstatic u32 ipw_qos_get_burst_duration(struct ipw_priv *priv)\r\n{\r\nu32 ret = 0;\r\nif ((priv == NULL))\r\nreturn 0;\r\nif (!(priv->ieee->modulation & LIBIPW_OFDM_MODULATION))\r\nret = priv->qos_data.burst_duration_CCK;\r\nelse\r\nret = priv->qos_data.burst_duration_OFDM;\r\nreturn ret;\r\n}\r\nstatic void ipw_qos_init(struct ipw_priv *priv, int enable,\r\nint burst_enable, u32 burst_duration_CCK,\r\nu32 burst_duration_OFDM)\r\n{\r\npriv->qos_data.qos_enable = enable;\r\nif (priv->qos_data.qos_enable) {\r\npriv->qos_data.def_qos_parm_CCK = &def_qos_parameters_CCK;\r\npriv->qos_data.def_qos_parm_OFDM = &def_qos_parameters_OFDM;\r\nIPW_DEBUG_QOS("QoS is enabled\n");\r\n} else {\r\npriv->qos_data.def_qos_parm_CCK = &def_parameters_CCK;\r\npriv->qos_data.def_qos_parm_OFDM = &def_parameters_OFDM;\r\nIPW_DEBUG_QOS("QoS is not enabled\n");\r\n}\r\npriv->qos_data.burst_enable = burst_enable;\r\nif (burst_enable) {\r\npriv->qos_data.burst_duration_CCK = burst_duration_CCK;\r\npriv->qos_data.burst_duration_OFDM = burst_duration_OFDM;\r\n} else {\r\npriv->qos_data.burst_duration_CCK = 0;\r\npriv->qos_data.burst_duration_OFDM = 0;\r\n}\r\n}\r\nstatic int ipw_get_tx_queue_number(struct ipw_priv *priv, u16 priority)\r\n{\r\nif (priority > 7 || !priv->qos_data.qos_enable)\r\npriority = 0;\r\nreturn from_priority_to_tx_queue[priority] - 1;\r\n}\r\nstatic int ipw_is_qos_active(struct net_device *dev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nstruct libipw_qos_data *qos_data = NULL;\r\nint active, supported;\r\nu8 *daddr = skb->data + ETH_ALEN;\r\nint unicast = !is_multicast_ether_addr(daddr);\r\nif (!(priv->status & STATUS_ASSOCIATED))\r\nreturn 0;\r\nqos_data = &priv->assoc_network->qos_data;\r\nif (priv->ieee->iw_mode == IW_MODE_ADHOC) {\r\nif (unicast == 0)\r\nqos_data->active = 0;\r\nelse\r\nqos_data->active = qos_data->supported;\r\n}\r\nactive = qos_data->active;\r\nsupported = qos_data->supported;\r\nIPW_DEBUG_QOS("QoS %d network is QoS active %d supported %d "\r\n"unicast %d\n",\r\npriv->qos_data.qos_enable, active, supported, unicast);\r\nif (active && priv->qos_data.qos_enable)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int ipw_qos_set_tx_queue_command(struct ipw_priv *priv,\r\nu16 priority,\r\nstruct tfd_data *tfd)\r\n{\r\nint tx_queue_id = 0;\r\ntx_queue_id = from_priority_to_tx_queue[priority] - 1;\r\ntfd->tx_flags_ext |= DCT_FLAG_EXT_QOS_ENABLED;\r\nif (priv->qos_data.qos_no_ack_mask & (1UL << tx_queue_id)) {\r\ntfd->tx_flags &= ~DCT_FLAG_ACK_REQD;\r\ntfd->tfd.tfd_26.mchdr.qos_ctrl |= cpu_to_le16(CTRL_QOS_NO_ACK);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ipw_bg_qos_activate(struct work_struct *work)\r\n{\r\nstruct ipw_priv *priv =\r\ncontainer_of(work, struct ipw_priv, qos_activate);\r\nmutex_lock(&priv->mutex);\r\nif (priv->status & STATUS_ASSOCIATED)\r\nipw_qos_activate(priv, &(priv->assoc_network->qos_data));\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic int ipw_handle_probe_response(struct net_device *dev,\r\nstruct libipw_probe_response *resp,\r\nstruct libipw_network *network)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nint active_network = ((priv->status & STATUS_ASSOCIATED) &&\r\n(network == priv->assoc_network));\r\nipw_qos_handle_probe_response(priv, active_network, network);\r\nreturn 0;\r\n}\r\nstatic int ipw_handle_beacon(struct net_device *dev,\r\nstruct libipw_beacon *resp,\r\nstruct libipw_network *network)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nint active_network = ((priv->status & STATUS_ASSOCIATED) &&\r\n(network == priv->assoc_network));\r\nipw_qos_handle_probe_response(priv, active_network, network);\r\nreturn 0;\r\n}\r\nstatic int ipw_handle_assoc_response(struct net_device *dev,\r\nstruct libipw_assoc_response *resp,\r\nstruct libipw_network *network)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nipw_qos_association_resp(priv, network);\r\nreturn 0;\r\n}\r\nstatic int ipw_send_qos_params_command(struct ipw_priv *priv, struct libipw_qos_parameters\r\n*qos_param)\r\n{\r\nreturn ipw_send_cmd_pdu(priv, IPW_CMD_QOS_PARAMETERS,\r\nsizeof(*qos_param) * 3, qos_param);\r\n}\r\nstatic int ipw_send_qos_info_command(struct ipw_priv *priv, struct libipw_qos_information_element\r\n*qos_param)\r\n{\r\nreturn ipw_send_cmd_pdu(priv, IPW_CMD_WME_INFO, sizeof(*qos_param),\r\nqos_param);\r\n}\r\nstatic int ipw_associate_network(struct ipw_priv *priv,\r\nstruct libipw_network *network,\r\nstruct ipw_supported_rates *rates, int roaming)\r\n{\r\nint err;\r\nif (priv->config & CFG_FIXED_RATE)\r\nipw_set_fixed_rate(priv, network->mode);\r\nif (!(priv->config & CFG_STATIC_ESSID)) {\r\npriv->essid_len = min(network->ssid_len,\r\n(u8) IW_ESSID_MAX_SIZE);\r\nmemcpy(priv->essid, network->ssid, priv->essid_len);\r\n}\r\nnetwork->last_associate = jiffies;\r\nmemset(&priv->assoc_request, 0, sizeof(priv->assoc_request));\r\npriv->assoc_request.channel = network->channel;\r\npriv->assoc_request.auth_key = 0;\r\nif ((priv->capability & CAP_PRIVACY_ON) &&\r\n(priv->ieee->sec.auth_mode == WLAN_AUTH_SHARED_KEY)) {\r\npriv->assoc_request.auth_type = AUTH_SHARED_KEY;\r\npriv->assoc_request.auth_key = priv->ieee->sec.active_key;\r\nif (priv->ieee->sec.level == SEC_LEVEL_1)\r\nipw_send_wep_keys(priv, DCW_WEP_KEY_SEC_TYPE_WEP);\r\n} else if ((priv->capability & CAP_PRIVACY_ON) &&\r\n(priv->ieee->sec.auth_mode == WLAN_AUTH_LEAP))\r\npriv->assoc_request.auth_type = AUTH_LEAP;\r\nelse\r\npriv->assoc_request.auth_type = AUTH_OPEN;\r\nif (priv->ieee->wpa_ie_len) {\r\npriv->assoc_request.policy_support = cpu_to_le16(0x02);\r\nipw_set_rsn_capa(priv, priv->ieee->wpa_ie,\r\npriv->ieee->wpa_ie_len);\r\n}\r\nif (network->mode & priv->ieee->mode & IEEE_A)\r\npriv->assoc_request.ieee_mode = IPW_A_MODE;\r\nelse if (network->mode & priv->ieee->mode & IEEE_G)\r\npriv->assoc_request.ieee_mode = IPW_G_MODE;\r\nelse if (network->mode & priv->ieee->mode & IEEE_B)\r\npriv->assoc_request.ieee_mode = IPW_B_MODE;\r\npriv->assoc_request.capability = cpu_to_le16(network->capability);\r\nif ((network->capability & WLAN_CAPABILITY_SHORT_PREAMBLE)\r\n&& !(priv->config & CFG_PREAMBLE_LONG)) {\r\npriv->assoc_request.preamble_length = DCT_FLAG_SHORT_PREAMBLE;\r\n} else {\r\npriv->assoc_request.preamble_length = DCT_FLAG_LONG_PREAMBLE;\r\npriv->assoc_request.capability &=\r\n~cpu_to_le16(WLAN_CAPABILITY_SHORT_PREAMBLE);\r\n}\r\nif (priv->ieee->iw_mode == IW_MODE_ADHOC)\r\npriv->assoc_request.capability &=\r\n~cpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT_TIME);\r\nIPW_DEBUG_ASSOC("%ssociation attempt: '%*pE', channel %d, 802.11%c [%d], %s[:%s], enc=%s%s%s%c%c\n",\r\nroaming ? "Rea" : "A",\r\npriv->essid_len, priv->essid,\r\nnetwork->channel,\r\nipw_modes[priv->assoc_request.ieee_mode],\r\nrates->num_rates,\r\n(priv->assoc_request.preamble_length ==\r\nDCT_FLAG_LONG_PREAMBLE) ? "long" : "short",\r\nnetwork->capability &\r\nWLAN_CAPABILITY_SHORT_PREAMBLE ? "short" : "long",\r\npriv->capability & CAP_PRIVACY_ON ? "on " : "off",\r\npriv->capability & CAP_PRIVACY_ON ?\r\n(priv->capability & CAP_SHARED_KEY ? "(shared)" :\r\n"(open)") : "",\r\npriv->capability & CAP_PRIVACY_ON ? " key=" : "",\r\npriv->capability & CAP_PRIVACY_ON ?\r\n'1' + priv->ieee->sec.active_key : '.',\r\npriv->capability & CAP_PRIVACY_ON ? '.' : ' ');\r\npriv->assoc_request.beacon_interval = cpu_to_le16(network->beacon_interval);\r\nif ((priv->ieee->iw_mode == IW_MODE_ADHOC) &&\r\n(network->time_stamp[0] == 0) && (network->time_stamp[1] == 0)) {\r\npriv->assoc_request.assoc_type = HC_IBSS_START;\r\npriv->assoc_request.assoc_tsf_msw = 0;\r\npriv->assoc_request.assoc_tsf_lsw = 0;\r\n} else {\r\nif (unlikely(roaming))\r\npriv->assoc_request.assoc_type = HC_REASSOCIATE;\r\nelse\r\npriv->assoc_request.assoc_type = HC_ASSOCIATE;\r\npriv->assoc_request.assoc_tsf_msw = cpu_to_le32(network->time_stamp[1]);\r\npriv->assoc_request.assoc_tsf_lsw = cpu_to_le32(network->time_stamp[0]);\r\n}\r\nmemcpy(priv->assoc_request.bssid, network->bssid, ETH_ALEN);\r\nif (priv->ieee->iw_mode == IW_MODE_ADHOC) {\r\neth_broadcast_addr(priv->assoc_request.dest);\r\npriv->assoc_request.atim_window = cpu_to_le16(network->atim_window);\r\n} else {\r\nmemcpy(priv->assoc_request.dest, network->bssid, ETH_ALEN);\r\npriv->assoc_request.atim_window = 0;\r\n}\r\npriv->assoc_request.listen_interval = cpu_to_le16(network->listen_interval);\r\nerr = ipw_send_ssid(priv, priv->essid, priv->essid_len);\r\nif (err) {\r\nIPW_DEBUG_HC("Attempt to send SSID command failed.\n");\r\nreturn err;\r\n}\r\nrates->ieee_mode = priv->assoc_request.ieee_mode;\r\nrates->purpose = IPW_RATE_CONNECT;\r\nipw_send_supported_rates(priv, rates);\r\nif (priv->assoc_request.ieee_mode == IPW_G_MODE)\r\npriv->sys_config.dot11g_auto_detection = 1;\r\nelse\r\npriv->sys_config.dot11g_auto_detection = 0;\r\nif (priv->ieee->iw_mode == IW_MODE_ADHOC)\r\npriv->sys_config.answer_broadcast_ssid_probe = 1;\r\nelse\r\npriv->sys_config.answer_broadcast_ssid_probe = 0;\r\nerr = ipw_send_system_config(priv);\r\nif (err) {\r\nIPW_DEBUG_HC("Attempt to send sys config command failed.\n");\r\nreturn err;\r\n}\r\nIPW_DEBUG_ASSOC("Association sensitivity: %d\n", network->stats.rssi);\r\nerr = ipw_set_sensitivity(priv, network->stats.rssi + IPW_RSSI_TO_DBM);\r\nif (err) {\r\nIPW_DEBUG_HC("Attempt to send associate command failed.\n");\r\nreturn err;\r\n}\r\npriv->channel = network->channel;\r\nmemcpy(priv->bssid, network->bssid, ETH_ALEN);\r\npriv->status |= STATUS_ASSOCIATING;\r\npriv->status &= ~STATUS_SECURITY_UPDATED;\r\npriv->assoc_network = network;\r\n#ifdef CONFIG_IPW2200_QOS\r\nipw_qos_association(priv, network);\r\n#endif\r\nerr = ipw_send_associate(priv, &priv->assoc_request);\r\nif (err) {\r\nIPW_DEBUG_HC("Attempt to send associate command failed.\n");\r\nreturn err;\r\n}\r\nIPW_DEBUG(IPW_DL_STATE, "associating: '%*pE' %pM\n",\r\npriv->essid_len, priv->essid, priv->bssid);\r\nreturn 0;\r\n}\r\nstatic void ipw_roam(void *data)\r\n{\r\nstruct ipw_priv *priv = data;\r\nstruct libipw_network *network = NULL;\r\nstruct ipw_network_match match = {\r\n.network = priv->assoc_network\r\n};\r\nif (!(priv->status & (STATUS_ASSOCIATED | STATUS_ROAMING)))\r\nreturn;\r\nif (priv->status & STATUS_ASSOCIATED) {\r\nunsigned long flags;\r\nu8 rssi = priv->assoc_network->stats.rssi;\r\npriv->assoc_network->stats.rssi = -128;\r\nspin_lock_irqsave(&priv->ieee->lock, flags);\r\nlist_for_each_entry(network, &priv->ieee->network_list, list) {\r\nif (network != priv->assoc_network)\r\nipw_best_network(priv, &match, network, 1);\r\n}\r\nspin_unlock_irqrestore(&priv->ieee->lock, flags);\r\npriv->assoc_network->stats.rssi = rssi;\r\nif (match.network == priv->assoc_network) {\r\nIPW_DEBUG_ASSOC("No better APs in this network to "\r\n"roam to.\n");\r\npriv->status &= ~STATUS_ROAMING;\r\nipw_debug_config(priv);\r\nreturn;\r\n}\r\nipw_send_disassociate(priv, 1);\r\npriv->assoc_network = match.network;\r\nreturn;\r\n}\r\nipw_compatible_rates(priv, priv->assoc_network, &match.rates);\r\nipw_associate_network(priv, priv->assoc_network, &match.rates, 1);\r\npriv->status &= ~STATUS_ROAMING;\r\n}\r\nstatic void ipw_bg_roam(struct work_struct *work)\r\n{\r\nstruct ipw_priv *priv =\r\ncontainer_of(work, struct ipw_priv, roam);\r\nmutex_lock(&priv->mutex);\r\nipw_roam(priv);\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic int ipw_associate(void *data)\r\n{\r\nstruct ipw_priv *priv = data;\r\nstruct libipw_network *network = NULL;\r\nstruct ipw_network_match match = {\r\n.network = NULL\r\n};\r\nstruct ipw_supported_rates *rates;\r\nstruct list_head *element;\r\nunsigned long flags;\r\nif (priv->ieee->iw_mode == IW_MODE_MONITOR) {\r\nIPW_DEBUG_ASSOC("Not attempting association (monitor mode)\n");\r\nreturn 0;\r\n}\r\nif (priv->status & (STATUS_ASSOCIATED | STATUS_ASSOCIATING)) {\r\nIPW_DEBUG_ASSOC("Not attempting association (already in "\r\n"progress)\n");\r\nreturn 0;\r\n}\r\nif (priv->status & STATUS_DISASSOCIATING) {\r\nIPW_DEBUG_ASSOC("Not attempting association (in "\r\n"disassociating)\n ");\r\nschedule_work(&priv->associate);\r\nreturn 0;\r\n}\r\nif (!ipw_is_init(priv) || (priv->status & STATUS_SCANNING)) {\r\nIPW_DEBUG_ASSOC("Not attempting association (scanning or not "\r\n"initialized)\n");\r\nreturn 0;\r\n}\r\nif (!(priv->config & CFG_ASSOCIATE) &&\r\n!(priv->config & (CFG_STATIC_ESSID | CFG_STATIC_BSSID))) {\r\nIPW_DEBUG_ASSOC("Not attempting association (associate=0)\n");\r\nreturn 0;\r\n}\r\nspin_lock_irqsave(&priv->ieee->lock, flags);\r\nlist_for_each_entry(network, &priv->ieee->network_list, list)\r\nipw_best_network(priv, &match, network, 0);\r\nnetwork = match.network;\r\nrates = &match.rates;\r\nif (network == NULL &&\r\npriv->ieee->iw_mode == IW_MODE_ADHOC &&\r\npriv->config & CFG_ADHOC_CREATE &&\r\npriv->config & CFG_STATIC_ESSID &&\r\npriv->config & CFG_STATIC_CHANNEL) {\r\nif (list_empty(&priv->ieee->network_free_list)) {\r\nstruct libipw_network *oldest = NULL;\r\nstruct libipw_network *target;\r\nlist_for_each_entry(target, &priv->ieee->network_list, list) {\r\nif ((oldest == NULL) ||\r\n(target->last_scanned < oldest->last_scanned))\r\noldest = target;\r\n}\r\nlist_del(&oldest->list);\r\ntarget = oldest;\r\nIPW_DEBUG_ASSOC("Expired '%*pE' (%pM) from network list.\n",\r\ntarget->ssid_len, target->ssid,\r\ntarget->bssid);\r\nlist_add_tail(&target->list,\r\n&priv->ieee->network_free_list);\r\n}\r\nelement = priv->ieee->network_free_list.next;\r\nnetwork = list_entry(element, struct libipw_network, list);\r\nipw_adhoc_create(priv, network);\r\nrates = &priv->rates;\r\nlist_del(element);\r\nlist_add_tail(&network->list, &priv->ieee->network_list);\r\n}\r\nspin_unlock_irqrestore(&priv->ieee->lock, flags);\r\nif (!network) {\r\nipw_debug_config(priv);\r\nif (!(priv->status & STATUS_SCANNING)) {\r\nif (!(priv->config & CFG_SPEED_SCAN))\r\nschedule_delayed_work(&priv->request_scan,\r\nSCAN_INTERVAL);\r\nelse\r\nschedule_delayed_work(&priv->request_scan, 0);\r\n}\r\nreturn 0;\r\n}\r\nipw_associate_network(priv, network, rates, 0);\r\nreturn 1;\r\n}\r\nstatic void ipw_bg_associate(struct work_struct *work)\r\n{\r\nstruct ipw_priv *priv =\r\ncontainer_of(work, struct ipw_priv, associate);\r\nmutex_lock(&priv->mutex);\r\nipw_associate(priv);\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic void ipw_rebuild_decrypted_skb(struct ipw_priv *priv,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_hdr *hdr;\r\nu16 fc;\r\nhdr = (struct ieee80211_hdr *)skb->data;\r\nfc = le16_to_cpu(hdr->frame_control);\r\nif (!(fc & IEEE80211_FCTL_PROTECTED))\r\nreturn;\r\nfc &= ~IEEE80211_FCTL_PROTECTED;\r\nhdr->frame_control = cpu_to_le16(fc);\r\nswitch (priv->ieee->sec.level) {\r\ncase SEC_LEVEL_3:\r\nmemmove(skb->data + LIBIPW_3ADDR_LEN,\r\nskb->data + LIBIPW_3ADDR_LEN + 8,\r\nskb->len - LIBIPW_3ADDR_LEN - 8);\r\nskb_trim(skb, skb->len - 16);\r\nbreak;\r\ncase SEC_LEVEL_2:\r\nbreak;\r\ncase SEC_LEVEL_1:\r\nmemmove(skb->data + LIBIPW_3ADDR_LEN,\r\nskb->data + LIBIPW_3ADDR_LEN + 4,\r\nskb->len - LIBIPW_3ADDR_LEN - 4);\r\nskb_trim(skb, skb->len - 8);\r\nbreak;\r\ncase SEC_LEVEL_0:\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "Unknown security level %d\n",\r\npriv->ieee->sec.level);\r\nbreak;\r\n}\r\n}\r\nstatic void ipw_handle_data_packet(struct ipw_priv *priv,\r\nstruct ipw_rx_mem_buffer *rxb,\r\nstruct libipw_rx_stats *stats)\r\n{\r\nstruct net_device *dev = priv->net_dev;\r\nstruct libipw_hdr_4addr *hdr;\r\nstruct ipw_rx_packet *pkt = (struct ipw_rx_packet *)rxb->skb->data;\r\ndev->trans_start = jiffies;\r\nif (unlikely((le16_to_cpu(pkt->u.frame.length) + IPW_RX_FRAME_SIZE) >\r\nskb_tailroom(rxb->skb))) {\r\ndev->stats.rx_errors++;\r\npriv->wstats.discard.misc++;\r\nIPW_DEBUG_DROP("Corruption detected! Oh no!\n");\r\nreturn;\r\n} else if (unlikely(!netif_running(priv->net_dev))) {\r\ndev->stats.rx_dropped++;\r\npriv->wstats.discard.misc++;\r\nIPW_DEBUG_DROP("Dropping packet while interface is not up.\n");\r\nreturn;\r\n}\r\nskb_reserve(rxb->skb, offsetof(struct ipw_rx_packet, u.frame.data));\r\nskb_put(rxb->skb, le16_to_cpu(pkt->u.frame.length));\r\nIPW_DEBUG_RX("Rx packet of %d bytes.\n", rxb->skb->len);\r\nhdr = (struct libipw_hdr_4addr *)rxb->skb->data;\r\nif (priv->ieee->iw_mode != IW_MODE_MONITOR &&\r\n(is_multicast_ether_addr(hdr->addr1) ?\r\n!priv->ieee->host_mc_decrypt : !priv->ieee->host_decrypt))\r\nipw_rebuild_decrypted_skb(priv, rxb->skb);\r\nif (!libipw_rx(priv->ieee, rxb->skb, stats))\r\ndev->stats.rx_errors++;\r\nelse {\r\nrxb->skb = NULL;\r\n__ipw_led_activity_on(priv);\r\n}\r\n}\r\nstatic void ipw_handle_data_packet_monitor(struct ipw_priv *priv,\r\nstruct ipw_rx_mem_buffer *rxb,\r\nstruct libipw_rx_stats *stats)\r\n{\r\nstruct net_device *dev = priv->net_dev;\r\nstruct ipw_rx_packet *pkt = (struct ipw_rx_packet *)rxb->skb->data;\r\nstruct ipw_rx_frame *frame = &pkt->u.frame;\r\nu16 received_channel = frame->received_channel;\r\nu8 antennaAndPhy = frame->antennaAndPhy;\r\ns8 antsignal = frame->rssi_dbm - IPW_RSSI_TO_DBM;\r\nu16 pktrate = frame->rate;\r\nstruct ipw_rt_hdr *ipw_rt;\r\nunsigned short len = le16_to_cpu(pkt->u.frame.length);\r\ndev->trans_start = jiffies;\r\nif (unlikely((le16_to_cpu(pkt->u.frame.length) + IPW_RX_FRAME_SIZE) >\r\nskb_tailroom(rxb->skb))) {\r\ndev->stats.rx_errors++;\r\npriv->wstats.discard.misc++;\r\nIPW_DEBUG_DROP("Corruption detected! Oh no!\n");\r\nreturn;\r\n} else if (unlikely(!netif_running(priv->net_dev))) {\r\ndev->stats.rx_dropped++;\r\npriv->wstats.discard.misc++;\r\nIPW_DEBUG_DROP("Dropping packet while interface is not up.\n");\r\nreturn;\r\n}\r\nif (len > IPW_RX_BUF_SIZE - sizeof(struct ipw_rt_hdr)) {\r\ndev->stats.rx_dropped++;\r\npriv->wstats.discard.misc++;\r\nIPW_DEBUG_DROP("Dropping too large packet in monitor\n");\r\nreturn;\r\n}\r\nmemmove(rxb->skb->data + sizeof(struct ipw_rt_hdr),\r\nrxb->skb->data + IPW_RX_FRAME_SIZE, len);\r\nipw_rt = (struct ipw_rt_hdr *)rxb->skb->data;\r\nipw_rt->rt_hdr.it_version = PKTHDR_RADIOTAP_VERSION;\r\nipw_rt->rt_hdr.it_pad = 0;\r\nipw_rt->rt_hdr.it_len = cpu_to_le16(sizeof(struct ipw_rt_hdr));\r\nipw_rt->rt_hdr.it_present = cpu_to_le32(\r\n(1 << IEEE80211_RADIOTAP_TSFT) |\r\n(1 << IEEE80211_RADIOTAP_FLAGS) |\r\n(1 << IEEE80211_RADIOTAP_RATE) |\r\n(1 << IEEE80211_RADIOTAP_CHANNEL) |\r\n(1 << IEEE80211_RADIOTAP_DBM_ANTSIGNAL) |\r\n(1 << IEEE80211_RADIOTAP_DBM_ANTNOISE) |\r\n(1 << IEEE80211_RADIOTAP_ANTENNA));\r\nipw_rt->rt_flags = 0;\r\nipw_rt->rt_tsf = (u64)(frame->parent_tsf[3] << 24 |\r\nframe->parent_tsf[2] << 16 |\r\nframe->parent_tsf[1] << 8 |\r\nframe->parent_tsf[0]);\r\nipw_rt->rt_dbmsignal = antsignal;\r\nipw_rt->rt_dbmnoise = (s8) le16_to_cpu(frame->noise);\r\nipw_rt->rt_channel = cpu_to_le16(ieee80211chan2mhz(received_channel));\r\nif (received_channel > 14) {\r\nipw_rt->rt_chbitmask =\r\ncpu_to_le16((IEEE80211_CHAN_OFDM | IEEE80211_CHAN_5GHZ));\r\n} else if (antennaAndPhy & 32) {\r\nipw_rt->rt_chbitmask =\r\ncpu_to_le16((IEEE80211_CHAN_CCK | IEEE80211_CHAN_2GHZ));\r\n} else {\r\nipw_rt->rt_chbitmask =\r\ncpu_to_le16(IEEE80211_CHAN_OFDM | IEEE80211_CHAN_2GHZ);\r\n}\r\nswitch (pktrate) {\r\ncase IPW_TX_RATE_1MB:\r\nipw_rt->rt_rate = 2;\r\nbreak;\r\ncase IPW_TX_RATE_2MB:\r\nipw_rt->rt_rate = 4;\r\nbreak;\r\ncase IPW_TX_RATE_5MB:\r\nipw_rt->rt_rate = 10;\r\nbreak;\r\ncase IPW_TX_RATE_6MB:\r\nipw_rt->rt_rate = 12;\r\nbreak;\r\ncase IPW_TX_RATE_9MB:\r\nipw_rt->rt_rate = 18;\r\nbreak;\r\ncase IPW_TX_RATE_11MB:\r\nipw_rt->rt_rate = 22;\r\nbreak;\r\ncase IPW_TX_RATE_12MB:\r\nipw_rt->rt_rate = 24;\r\nbreak;\r\ncase IPW_TX_RATE_18MB:\r\nipw_rt->rt_rate = 36;\r\nbreak;\r\ncase IPW_TX_RATE_24MB:\r\nipw_rt->rt_rate = 48;\r\nbreak;\r\ncase IPW_TX_RATE_36MB:\r\nipw_rt->rt_rate = 72;\r\nbreak;\r\ncase IPW_TX_RATE_48MB:\r\nipw_rt->rt_rate = 96;\r\nbreak;\r\ncase IPW_TX_RATE_54MB:\r\nipw_rt->rt_rate = 108;\r\nbreak;\r\ndefault:\r\nipw_rt->rt_rate = 0;\r\nbreak;\r\n}\r\nipw_rt->rt_antenna = (antennaAndPhy & 3);\r\nif ((antennaAndPhy & 64))\r\nipw_rt->rt_flags |= IEEE80211_RADIOTAP_F_SHORTPRE;\r\nskb_put(rxb->skb, len + sizeof(struct ipw_rt_hdr));\r\nIPW_DEBUG_RX("Rx packet of %d bytes.\n", rxb->skb->len);\r\nif (!libipw_rx(priv->ieee, rxb->skb, stats))\r\ndev->stats.rx_errors++;\r\nelse {\r\nrxb->skb = NULL;\r\n}\r\n}\r\nstatic void ipw_handle_promiscuous_rx(struct ipw_priv *priv,\r\nstruct ipw_rx_mem_buffer *rxb,\r\nstruct libipw_rx_stats *stats)\r\n{\r\nstruct net_device *dev = priv->prom_net_dev;\r\nstruct ipw_rx_packet *pkt = (struct ipw_rx_packet *)rxb->skb->data;\r\nstruct ipw_rx_frame *frame = &pkt->u.frame;\r\nstruct ipw_rt_hdr *ipw_rt;\r\nstruct ieee80211_hdr *hdr;\r\nu16 channel = frame->received_channel;\r\nu8 phy_flags = frame->antennaAndPhy;\r\ns8 signal = frame->rssi_dbm - IPW_RSSI_TO_DBM;\r\ns8 noise = (s8) le16_to_cpu(frame->noise);\r\nu8 rate = frame->rate;\r\nunsigned short len = le16_to_cpu(pkt->u.frame.length);\r\nstruct sk_buff *skb;\r\nint hdr_only = 0;\r\nu16 filter = priv->prom_priv->filter;\r\nif (filter & IPW_PROM_NO_RX)\r\nreturn;\r\ndev->trans_start = jiffies;\r\nif (unlikely((len + IPW_RX_FRAME_SIZE) > skb_tailroom(rxb->skb))) {\r\ndev->stats.rx_errors++;\r\nIPW_DEBUG_DROP("Corruption detected! Oh no!\n");\r\nreturn;\r\n}\r\nif (unlikely(!netif_running(dev))) {\r\ndev->stats.rx_dropped++;\r\nIPW_DEBUG_DROP("Dropping packet while interface is not up.\n");\r\nreturn;\r\n}\r\nif (len > IPW_RX_BUF_SIZE - sizeof(struct ipw_rt_hdr)) {\r\ndev->stats.rx_dropped++;\r\nIPW_DEBUG_DROP("Dropping too large packet in monitor\n");\r\nreturn;\r\n}\r\nhdr = (void *)rxb->skb->data + IPW_RX_FRAME_SIZE;\r\nif (libipw_is_management(le16_to_cpu(hdr->frame_control))) {\r\nif (filter & IPW_PROM_NO_MGMT)\r\nreturn;\r\nif (filter & IPW_PROM_MGMT_HEADER_ONLY)\r\nhdr_only = 1;\r\n} else if (libipw_is_control(le16_to_cpu(hdr->frame_control))) {\r\nif (filter & IPW_PROM_NO_CTL)\r\nreturn;\r\nif (filter & IPW_PROM_CTL_HEADER_ONLY)\r\nhdr_only = 1;\r\n} else if (libipw_is_data(le16_to_cpu(hdr->frame_control))) {\r\nif (filter & IPW_PROM_NO_DATA)\r\nreturn;\r\nif (filter & IPW_PROM_DATA_HEADER_ONLY)\r\nhdr_only = 1;\r\n}\r\nskb = skb_copy(rxb->skb, GFP_ATOMIC);\r\nif (skb == NULL) {\r\nIPW_ERROR("skb_clone failed for promiscuous copy.\n");\r\nreturn;\r\n}\r\nipw_rt = (void *)skb->data;\r\nif (hdr_only)\r\nlen = libipw_get_hdrlen(le16_to_cpu(hdr->frame_control));\r\nmemcpy(ipw_rt->payload, hdr, len);\r\nipw_rt->rt_hdr.it_version = PKTHDR_RADIOTAP_VERSION;\r\nipw_rt->rt_hdr.it_pad = 0;\r\nipw_rt->rt_hdr.it_len = cpu_to_le16(sizeof(*ipw_rt));\r\nskb_put(skb, sizeof(*ipw_rt) + len);\r\nipw_rt->rt_hdr.it_present = cpu_to_le32(\r\n(1 << IEEE80211_RADIOTAP_TSFT) |\r\n(1 << IEEE80211_RADIOTAP_FLAGS) |\r\n(1 << IEEE80211_RADIOTAP_RATE) |\r\n(1 << IEEE80211_RADIOTAP_CHANNEL) |\r\n(1 << IEEE80211_RADIOTAP_DBM_ANTSIGNAL) |\r\n(1 << IEEE80211_RADIOTAP_DBM_ANTNOISE) |\r\n(1 << IEEE80211_RADIOTAP_ANTENNA));\r\nipw_rt->rt_flags = 0;\r\nipw_rt->rt_tsf = (u64)(frame->parent_tsf[3] << 24 |\r\nframe->parent_tsf[2] << 16 |\r\nframe->parent_tsf[1] << 8 |\r\nframe->parent_tsf[0]);\r\nipw_rt->rt_dbmsignal = signal;\r\nipw_rt->rt_dbmnoise = noise;\r\nipw_rt->rt_channel = cpu_to_le16(ieee80211chan2mhz(channel));\r\nif (channel > 14) {\r\nipw_rt->rt_chbitmask =\r\ncpu_to_le16((IEEE80211_CHAN_OFDM | IEEE80211_CHAN_5GHZ));\r\n} else if (phy_flags & (1 << 5)) {\r\nipw_rt->rt_chbitmask =\r\ncpu_to_le16((IEEE80211_CHAN_CCK | IEEE80211_CHAN_2GHZ));\r\n} else {\r\nipw_rt->rt_chbitmask =\r\ncpu_to_le16(IEEE80211_CHAN_OFDM | IEEE80211_CHAN_2GHZ);\r\n}\r\nswitch (rate) {\r\ncase IPW_TX_RATE_1MB:\r\nipw_rt->rt_rate = 2;\r\nbreak;\r\ncase IPW_TX_RATE_2MB:\r\nipw_rt->rt_rate = 4;\r\nbreak;\r\ncase IPW_TX_RATE_5MB:\r\nipw_rt->rt_rate = 10;\r\nbreak;\r\ncase IPW_TX_RATE_6MB:\r\nipw_rt->rt_rate = 12;\r\nbreak;\r\ncase IPW_TX_RATE_9MB:\r\nipw_rt->rt_rate = 18;\r\nbreak;\r\ncase IPW_TX_RATE_11MB:\r\nipw_rt->rt_rate = 22;\r\nbreak;\r\ncase IPW_TX_RATE_12MB:\r\nipw_rt->rt_rate = 24;\r\nbreak;\r\ncase IPW_TX_RATE_18MB:\r\nipw_rt->rt_rate = 36;\r\nbreak;\r\ncase IPW_TX_RATE_24MB:\r\nipw_rt->rt_rate = 48;\r\nbreak;\r\ncase IPW_TX_RATE_36MB:\r\nipw_rt->rt_rate = 72;\r\nbreak;\r\ncase IPW_TX_RATE_48MB:\r\nipw_rt->rt_rate = 96;\r\nbreak;\r\ncase IPW_TX_RATE_54MB:\r\nipw_rt->rt_rate = 108;\r\nbreak;\r\ndefault:\r\nipw_rt->rt_rate = 0;\r\nbreak;\r\n}\r\nipw_rt->rt_antenna = (phy_flags & 3);\r\nif (phy_flags & (1 << 6))\r\nipw_rt->rt_flags |= IEEE80211_RADIOTAP_F_SHORTPRE;\r\nIPW_DEBUG_RX("Rx packet of %d bytes.\n", skb->len);\r\nif (!libipw_rx(priv->prom_priv->ieee, skb, stats)) {\r\ndev->stats.rx_errors++;\r\ndev_kfree_skb_any(skb);\r\n}\r\n}\r\nstatic int is_network_packet(struct ipw_priv *priv,\r\nstruct libipw_hdr_4addr *header)\r\n{\r\nswitch (priv->ieee->iw_mode) {\r\ncase IW_MODE_ADHOC:\r\nif (ether_addr_equal(header->addr2, priv->net_dev->dev_addr))\r\nreturn 0;\r\nif (is_multicast_ether_addr(header->addr1))\r\nreturn ether_addr_equal(header->addr3, priv->bssid);\r\nreturn ether_addr_equal(header->addr1,\r\npriv->net_dev->dev_addr);\r\ncase IW_MODE_INFRA:\r\nif (ether_addr_equal(header->addr3, priv->net_dev->dev_addr))\r\nreturn 0;\r\nif (is_multicast_ether_addr(header->addr1))\r\nreturn ether_addr_equal(header->addr2, priv->bssid);\r\nreturn ether_addr_equal(header->addr1,\r\npriv->net_dev->dev_addr);\r\n}\r\nreturn 1;\r\n}\r\nstatic int is_duplicate_packet(struct ipw_priv *priv,\r\nstruct libipw_hdr_4addr *header)\r\n{\r\nu16 sc = le16_to_cpu(header->seq_ctl);\r\nu16 seq = WLAN_GET_SEQ_SEQ(sc);\r\nu16 frag = WLAN_GET_SEQ_FRAG(sc);\r\nu16 *last_seq, *last_frag;\r\nunsigned long *last_time;\r\nswitch (priv->ieee->iw_mode) {\r\ncase IW_MODE_ADHOC:\r\n{\r\nstruct list_head *p;\r\nstruct ipw_ibss_seq *entry = NULL;\r\nu8 *mac = header->addr2;\r\nint index = mac[5] % IPW_IBSS_MAC_HASH_SIZE;\r\nlist_for_each(p, &priv->ibss_mac_hash[index]) {\r\nentry =\r\nlist_entry(p, struct ipw_ibss_seq, list);\r\nif (ether_addr_equal(entry->mac, mac))\r\nbreak;\r\n}\r\nif (p == &priv->ibss_mac_hash[index]) {\r\nentry = kmalloc(sizeof(*entry), GFP_ATOMIC);\r\nif (!entry) {\r\nIPW_ERROR\r\n("Cannot malloc new mac entry\n");\r\nreturn 0;\r\n}\r\nmemcpy(entry->mac, mac, ETH_ALEN);\r\nentry->seq_num = seq;\r\nentry->frag_num = frag;\r\nentry->packet_time = jiffies;\r\nlist_add(&entry->list,\r\n&priv->ibss_mac_hash[index]);\r\nreturn 0;\r\n}\r\nlast_seq = &entry->seq_num;\r\nlast_frag = &entry->frag_num;\r\nlast_time = &entry->packet_time;\r\nbreak;\r\n}\r\ncase IW_MODE_INFRA:\r\nlast_seq = &priv->last_seq_num;\r\nlast_frag = &priv->last_frag_num;\r\nlast_time = &priv->last_packet_time;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif ((*last_seq == seq) &&\r\ntime_after(*last_time + IPW_PACKET_RETRY_TIME, jiffies)) {\r\nif (*last_frag == frag)\r\ngoto drop;\r\nif (*last_frag + 1 != frag)\r\ngoto drop;\r\n} else\r\n*last_seq = seq;\r\n*last_frag = frag;\r\n*last_time = jiffies;\r\nreturn 0;\r\ndrop:\r\nreturn 1;\r\n}\r\nstatic void ipw_handle_mgmt_packet(struct ipw_priv *priv,\r\nstruct ipw_rx_mem_buffer *rxb,\r\nstruct libipw_rx_stats *stats)\r\n{\r\nstruct sk_buff *skb = rxb->skb;\r\nstruct ipw_rx_packet *pkt = (struct ipw_rx_packet *)skb->data;\r\nstruct libipw_hdr_4addr *header = (struct libipw_hdr_4addr *)\r\n(skb->data + IPW_RX_FRAME_SIZE);\r\nlibipw_rx_mgt(priv->ieee, header, stats);\r\nif (priv->ieee->iw_mode == IW_MODE_ADHOC &&\r\n((WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl)) ==\r\nIEEE80211_STYPE_PROBE_RESP) ||\r\n(WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl)) ==\r\nIEEE80211_STYPE_BEACON))) {\r\nif (ether_addr_equal(header->addr3, priv->bssid))\r\nipw_add_station(priv, header->addr2);\r\n}\r\nif (priv->config & CFG_NET_STATS) {\r\nIPW_DEBUG_HC("sending stat packet\n");\r\nskb_put(skb, le16_to_cpu(pkt->u.frame.length) +\r\nIPW_RX_FRAME_SIZE);\r\nskb_pull(skb, IPW_RX_FRAME_SIZE);\r\nmemcpy(skb_push(skb, sizeof(*stats)), stats, sizeof(*stats));\r\nskb->dev = priv->ieee->dev;\r\nskb_reset_mac_header(skb);\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nskb->protocol = cpu_to_be16(ETH_P_80211_STATS);\r\nmemset(skb->cb, 0, sizeof(rxb->skb->cb));\r\nnetif_rx(skb);\r\nrxb->skb = NULL;\r\n}\r\n}\r\nstatic void ipw_rx(struct ipw_priv *priv)\r\n{\r\nstruct ipw_rx_mem_buffer *rxb;\r\nstruct ipw_rx_packet *pkt;\r\nstruct libipw_hdr_4addr *header;\r\nu32 r, w, i;\r\nu8 network_packet;\r\nu8 fill_rx = 0;\r\nr = ipw_read32(priv, IPW_RX_READ_INDEX);\r\nw = ipw_read32(priv, IPW_RX_WRITE_INDEX);\r\ni = priv->rxq->read;\r\nif (ipw_rx_queue_space (priv->rxq) > (RX_QUEUE_SIZE / 2))\r\nfill_rx = 1;\r\nwhile (i != r) {\r\nrxb = priv->rxq->queue[i];\r\nif (unlikely(rxb == NULL)) {\r\nprintk(KERN_CRIT "Queue not allocated!\n");\r\nbreak;\r\n}\r\npriv->rxq->queue[i] = NULL;\r\npci_dma_sync_single_for_cpu(priv->pci_dev, rxb->dma_addr,\r\nIPW_RX_BUF_SIZE,\r\nPCI_DMA_FROMDEVICE);\r\npkt = (struct ipw_rx_packet *)rxb->skb->data;\r\nIPW_DEBUG_RX("Packet: type=%02X seq=%02X bits=%02X\n",\r\npkt->header.message_type,\r\npkt->header.rx_seq_num, pkt->header.control_bits);\r\nswitch (pkt->header.message_type) {\r\ncase RX_FRAME_TYPE: {\r\nstruct libipw_rx_stats stats = {\r\n.rssi = pkt->u.frame.rssi_dbm -\r\nIPW_RSSI_TO_DBM,\r\n.signal =\r\npkt->u.frame.rssi_dbm -\r\nIPW_RSSI_TO_DBM + 0x100,\r\n.noise =\r\nle16_to_cpu(pkt->u.frame.noise),\r\n.rate = pkt->u.frame.rate,\r\n.mac_time = jiffies,\r\n.received_channel =\r\npkt->u.frame.received_channel,\r\n.freq =\r\n(pkt->u.frame.\r\ncontrol & (1 << 0)) ?\r\nLIBIPW_24GHZ_BAND :\r\nLIBIPW_52GHZ_BAND,\r\n.len = le16_to_cpu(pkt->u.frame.length),\r\n};\r\nif (stats.rssi != 0)\r\nstats.mask |= LIBIPW_STATMASK_RSSI;\r\nif (stats.signal != 0)\r\nstats.mask |= LIBIPW_STATMASK_SIGNAL;\r\nif (stats.noise != 0)\r\nstats.mask |= LIBIPW_STATMASK_NOISE;\r\nif (stats.rate != 0)\r\nstats.mask |= LIBIPW_STATMASK_RATE;\r\npriv->rx_packets++;\r\n#ifdef CONFIG_IPW2200_PROMISCUOUS\r\nif (priv->prom_net_dev && netif_running(priv->prom_net_dev))\r\nipw_handle_promiscuous_rx(priv, rxb, &stats);\r\n#endif\r\n#ifdef CONFIG_IPW2200_MONITOR\r\nif (priv->ieee->iw_mode == IW_MODE_MONITOR) {\r\n#ifdef CONFIG_IPW2200_RADIOTAP\r\nipw_handle_data_packet_monitor(priv,\r\nrxb,\r\n&stats);\r\n#else\r\nipw_handle_data_packet(priv, rxb,\r\n&stats);\r\n#endif\r\nbreak;\r\n}\r\n#endif\r\nheader =\r\n(struct libipw_hdr_4addr *)(rxb->skb->\r\ndata +\r\nIPW_RX_FRAME_SIZE);\r\nnetwork_packet =\r\nis_network_packet(priv, header);\r\nif (network_packet && priv->assoc_network) {\r\npriv->assoc_network->stats.rssi =\r\nstats.rssi;\r\npriv->exp_avg_rssi =\r\nexponential_average(priv->exp_avg_rssi,\r\nstats.rssi, DEPTH_RSSI);\r\n}\r\nIPW_DEBUG_RX("Frame: len=%u\n",\r\nle16_to_cpu(pkt->u.frame.length));\r\nif (le16_to_cpu(pkt->u.frame.length) <\r\nlibipw_get_hdrlen(le16_to_cpu(\r\nheader->frame_ctl))) {\r\nIPW_DEBUG_DROP\r\n("Received packet is too small. "\r\n"Dropping.\n");\r\npriv->net_dev->stats.rx_errors++;\r\npriv->wstats.discard.misc++;\r\nbreak;\r\n}\r\nswitch (WLAN_FC_GET_TYPE\r\n(le16_to_cpu(header->frame_ctl))) {\r\ncase IEEE80211_FTYPE_MGMT:\r\nipw_handle_mgmt_packet(priv, rxb,\r\n&stats);\r\nbreak;\r\ncase IEEE80211_FTYPE_CTL:\r\nbreak;\r\ncase IEEE80211_FTYPE_DATA:\r\nif (unlikely(!network_packet ||\r\nis_duplicate_packet(priv,\r\nheader)))\r\n{\r\nIPW_DEBUG_DROP("Dropping: "\r\n"%pM, "\r\n"%pM, "\r\n"%pM\n",\r\nheader->addr1,\r\nheader->addr2,\r\nheader->addr3);\r\nbreak;\r\n}\r\nipw_handle_data_packet(priv, rxb,\r\n&stats);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase RX_HOST_NOTIFICATION_TYPE:{\r\nIPW_DEBUG_RX\r\n("Notification: subtype=%02X flags=%02X size=%d\n",\r\npkt->u.notification.subtype,\r\npkt->u.notification.flags,\r\nle16_to_cpu(pkt->u.notification.size));\r\nipw_rx_notification(priv, &pkt->u.notification);\r\nbreak;\r\n}\r\ndefault:\r\nIPW_DEBUG_RX("Bad Rx packet of type %d\n",\r\npkt->header.message_type);\r\nbreak;\r\n}\r\nif (rxb->skb != NULL) {\r\ndev_kfree_skb_any(rxb->skb);\r\nrxb->skb = NULL;\r\n}\r\npci_unmap_single(priv->pci_dev, rxb->dma_addr,\r\nIPW_RX_BUF_SIZE, PCI_DMA_FROMDEVICE);\r\nlist_add_tail(&rxb->list, &priv->rxq->rx_used);\r\ni = (i + 1) % RX_QUEUE_SIZE;\r\nif (fill_rx) {\r\npriv->rxq->read = i;\r\nipw_rx_queue_replenish(priv);\r\n}\r\n}\r\npriv->rxq->read = i;\r\nipw_rx_queue_restock(priv);\r\n}\r\nstatic int ipw_sw_reset(struct ipw_priv *priv, int option)\r\n{\r\nint band, modulation;\r\nint old_mode = priv->ieee->iw_mode;\r\npriv->config = 0;\r\nif (!led_support)\r\npriv->config |= CFG_NO_LED;\r\nif (associate)\r\npriv->config |= CFG_ASSOCIATE;\r\nelse\r\nIPW_DEBUG_INFO("Auto associate disabled.\n");\r\nif (auto_create)\r\npriv->config |= CFG_ADHOC_CREATE;\r\nelse\r\nIPW_DEBUG_INFO("Auto adhoc creation disabled.\n");\r\npriv->config &= ~CFG_STATIC_ESSID;\r\npriv->essid_len = 0;\r\nmemset(priv->essid, 0, IW_ESSID_MAX_SIZE);\r\nif (disable && option) {\r\npriv->status |= STATUS_RF_KILL_SW;\r\nIPW_DEBUG_INFO("Radio disabled.\n");\r\n}\r\nif (default_channel != 0) {\r\npriv->config |= CFG_STATIC_CHANNEL;\r\npriv->channel = default_channel;\r\nIPW_DEBUG_INFO("Bind to static channel %d\n", default_channel);\r\n}\r\n#ifdef CONFIG_IPW2200_QOS\r\nipw_qos_init(priv, qos_enable, qos_burst_enable,\r\nburst_duration_CCK, burst_duration_OFDM);\r\n#endif\r\nswitch (network_mode) {\r\ncase 1:\r\npriv->ieee->iw_mode = IW_MODE_ADHOC;\r\npriv->net_dev->type = ARPHRD_ETHER;\r\nbreak;\r\n#ifdef CONFIG_IPW2200_MONITOR\r\ncase 2:\r\npriv->ieee->iw_mode = IW_MODE_MONITOR;\r\n#ifdef CONFIG_IPW2200_RADIOTAP\r\npriv->net_dev->type = ARPHRD_IEEE80211_RADIOTAP;\r\n#else\r\npriv->net_dev->type = ARPHRD_IEEE80211;\r\n#endif\r\nbreak;\r\n#endif\r\ndefault:\r\ncase 0:\r\npriv->net_dev->type = ARPHRD_ETHER;\r\npriv->ieee->iw_mode = IW_MODE_INFRA;\r\nbreak;\r\n}\r\nif (hwcrypto) {\r\npriv->ieee->host_encrypt = 0;\r\npriv->ieee->host_encrypt_msdu = 0;\r\npriv->ieee->host_decrypt = 0;\r\npriv->ieee->host_mc_decrypt = 0;\r\n}\r\nIPW_DEBUG_INFO("Hardware crypto [%s]\n", hwcrypto ? "on" : "off");\r\npriv->ieee->host_open_frag = 0;\r\nif ((priv->pci_dev->device == 0x4223) ||\r\n(priv->pci_dev->device == 0x4224)) {\r\nif (option == 1)\r\nprintk(KERN_INFO DRV_NAME\r\n": Detected Intel PRO/Wireless 2915ABG Network "\r\n"Connection\n");\r\npriv->ieee->abg_true = 1;\r\nband = LIBIPW_52GHZ_BAND | LIBIPW_24GHZ_BAND;\r\nmodulation = LIBIPW_OFDM_MODULATION |\r\nLIBIPW_CCK_MODULATION;\r\npriv->adapter = IPW_2915ABG;\r\npriv->ieee->mode = IEEE_A | IEEE_G | IEEE_B;\r\n} else {\r\nif (option == 1)\r\nprintk(KERN_INFO DRV_NAME\r\n": Detected Intel PRO/Wireless 2200BG Network "\r\n"Connection\n");\r\npriv->ieee->abg_true = 0;\r\nband = LIBIPW_24GHZ_BAND;\r\nmodulation = LIBIPW_OFDM_MODULATION |\r\nLIBIPW_CCK_MODULATION;\r\npriv->adapter = IPW_2200BG;\r\npriv->ieee->mode = IEEE_G | IEEE_B;\r\n}\r\npriv->ieee->freq_band = band;\r\npriv->ieee->modulation = modulation;\r\npriv->rates_mask = LIBIPW_DEFAULT_RATES_MASK;\r\npriv->disassociate_threshold = IPW_MB_DISASSOCIATE_THRESHOLD_DEFAULT;\r\npriv->roaming_threshold = IPW_MB_ROAMING_THRESHOLD_DEFAULT;\r\npriv->rts_threshold = DEFAULT_RTS_THRESHOLD;\r\npriv->short_retry_limit = DEFAULT_SHORT_RETRY_LIMIT;\r\npriv->long_retry_limit = DEFAULT_LONG_RETRY_LIMIT;\r\npriv->power_mode = IPW_POWER_AC;\r\npriv->tx_power = IPW_TX_POWER_DEFAULT;\r\nreturn old_mode == priv->ieee->iw_mode;\r\n}\r\nstatic int ipw_set_channel(struct ipw_priv *priv, u8 channel)\r\n{\r\nif (channel == 0) {\r\nIPW_DEBUG_INFO("Setting channel to ANY (0)\n");\r\npriv->config &= ~CFG_STATIC_CHANNEL;\r\nIPW_DEBUG_ASSOC("Attempting to associate with new "\r\n"parameters.\n");\r\nipw_associate(priv);\r\nreturn 0;\r\n}\r\npriv->config |= CFG_STATIC_CHANNEL;\r\nif (priv->channel == channel) {\r\nIPW_DEBUG_INFO("Request to set channel to current value (%d)\n",\r\nchannel);\r\nreturn 0;\r\n}\r\nIPW_DEBUG_INFO("Setting channel to %i\n", (int)channel);\r\npriv->channel = channel;\r\n#ifdef CONFIG_IPW2200_MONITOR\r\nif (priv->ieee->iw_mode == IW_MODE_MONITOR) {\r\nint i;\r\nif (priv->status & STATUS_SCANNING) {\r\nIPW_DEBUG_SCAN("Scan abort triggered due to "\r\n"channel change.\n");\r\nipw_abort_scan(priv);\r\n}\r\nfor (i = 1000; i && (priv->status & STATUS_SCANNING); i--)\r\nudelay(10);\r\nif (priv->status & STATUS_SCANNING)\r\nIPW_DEBUG_SCAN("Still scanning...\n");\r\nelse\r\nIPW_DEBUG_SCAN("Took %dms to abort current scan\n",\r\n1000 - i);\r\nreturn 0;\r\n}\r\n#endif\r\nIPW_DEBUG_ASSOC("[re]association triggered due to channel change.\n");\r\nif (!ipw_disassociate(priv))\r\nipw_associate(priv);\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_set_freq(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nconst struct libipw_geo *geo = libipw_get_geo(priv->ieee);\r\nstruct iw_freq *fwrq = &wrqu->freq;\r\nint ret = 0, i;\r\nu8 channel, flags;\r\nint band;\r\nif (fwrq->m == 0) {\r\nIPW_DEBUG_WX("SET Freq/Channel -> any\n");\r\nmutex_lock(&priv->mutex);\r\nret = ipw_set_channel(priv, 0);\r\nmutex_unlock(&priv->mutex);\r\nreturn ret;\r\n}\r\nif (fwrq->e == 1) {\r\nchannel = libipw_freq_to_channel(priv->ieee, fwrq->m);\r\nif (channel == 0)\r\nreturn -EINVAL;\r\n} else\r\nchannel = fwrq->m;\r\nif (!(band = libipw_is_valid_channel(priv->ieee, channel)))\r\nreturn -EINVAL;\r\nif (priv->ieee->iw_mode == IW_MODE_ADHOC) {\r\ni = libipw_channel_to_index(priv->ieee, channel);\r\nif (i == -1)\r\nreturn -EINVAL;\r\nflags = (band == LIBIPW_24GHZ_BAND) ?\r\ngeo->bg[i].flags : geo->a[i].flags;\r\nif (flags & LIBIPW_CH_PASSIVE_ONLY) {\r\nIPW_DEBUG_WX("Invalid Ad-Hoc channel for 802.11a\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nIPW_DEBUG_WX("SET Freq/Channel -> %d\n", fwrq->m);\r\nmutex_lock(&priv->mutex);\r\nret = ipw_set_channel(priv, channel);\r\nmutex_unlock(&priv->mutex);\r\nreturn ret;\r\n}\r\nstatic int ipw_wx_get_freq(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nwrqu->freq.e = 0;\r\nmutex_lock(&priv->mutex);\r\nif (priv->config & CFG_STATIC_CHANNEL ||\r\npriv->status & (STATUS_ASSOCIATING | STATUS_ASSOCIATED)) {\r\nint i;\r\ni = libipw_channel_to_index(priv->ieee, priv->channel);\r\nBUG_ON(i == -1);\r\nwrqu->freq.e = 1;\r\nswitch (libipw_is_valid_channel(priv->ieee, priv->channel)) {\r\ncase LIBIPW_52GHZ_BAND:\r\nwrqu->freq.m = priv->ieee->geo.a[i].freq * 100000;\r\nbreak;\r\ncase LIBIPW_24GHZ_BAND:\r\nwrqu->freq.m = priv->ieee->geo.bg[i].freq * 100000;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n} else\r\nwrqu->freq.m = 0;\r\nmutex_unlock(&priv->mutex);\r\nIPW_DEBUG_WX("GET Freq/Channel -> %d\n", priv->channel);\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_set_mode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nint err = 0;\r\nIPW_DEBUG_WX("Set MODE: %d\n", wrqu->mode);\r\nswitch (wrqu->mode) {\r\n#ifdef CONFIG_IPW2200_MONITOR\r\ncase IW_MODE_MONITOR:\r\n#endif\r\ncase IW_MODE_ADHOC:\r\ncase IW_MODE_INFRA:\r\nbreak;\r\ncase IW_MODE_AUTO:\r\nwrqu->mode = IW_MODE_INFRA;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (wrqu->mode == priv->ieee->iw_mode)\r\nreturn 0;\r\nmutex_lock(&priv->mutex);\r\nipw_sw_reset(priv, 0);\r\n#ifdef CONFIG_IPW2200_MONITOR\r\nif (priv->ieee->iw_mode == IW_MODE_MONITOR)\r\npriv->net_dev->type = ARPHRD_ETHER;\r\nif (wrqu->mode == IW_MODE_MONITOR)\r\n#ifdef CONFIG_IPW2200_RADIOTAP\r\npriv->net_dev->type = ARPHRD_IEEE80211_RADIOTAP;\r\n#else\r\npriv->net_dev->type = ARPHRD_IEEE80211;\r\n#endif\r\n#endif\r\nfree_firmware();\r\npriv->ieee->iw_mode = wrqu->mode;\r\nschedule_work(&priv->adapter_restart);\r\nmutex_unlock(&priv->mutex);\r\nreturn err;\r\n}\r\nstatic int ipw_wx_get_mode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nmutex_lock(&priv->mutex);\r\nwrqu->mode = priv->ieee->iw_mode;\r\nIPW_DEBUG_WX("Get MODE -> %d\n", wrqu->mode);\r\nmutex_unlock(&priv->mutex);\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_get_range(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nstruct iw_range *range = (struct iw_range *)extra;\r\nconst struct libipw_geo *geo = libipw_get_geo(priv->ieee);\r\nint i = 0, j;\r\nwrqu->data.length = sizeof(*range);\r\nmemset(range, 0, sizeof(*range));\r\nrange->throughput = 27 * 1000 * 1000;\r\nrange->max_qual.qual = 100;\r\nrange->max_qual.level = 0;\r\nrange->max_qual.noise = 0;\r\nrange->max_qual.updated = 7;\r\nrange->avg_qual.qual = 70;\r\nrange->avg_qual.level = 0;\r\nrange->avg_qual.noise = 0;\r\nrange->avg_qual.updated = 7;\r\nmutex_lock(&priv->mutex);\r\nrange->num_bitrates = min(priv->rates.num_rates, (u8) IW_MAX_BITRATES);\r\nfor (i = 0; i < range->num_bitrates; i++)\r\nrange->bitrate[i] = (priv->rates.supported_rates[i] & 0x7F) *\r\n500000;\r\nrange->max_rts = DEFAULT_RTS_THRESHOLD;\r\nrange->min_frag = MIN_FRAG_THRESHOLD;\r\nrange->max_frag = MAX_FRAG_THRESHOLD;\r\nrange->encoding_size[0] = 5;\r\nrange->encoding_size[1] = 13;\r\nrange->num_encoding_sizes = 2;\r\nrange->max_encoding_tokens = WEP_KEYS;\r\nrange->we_version_compiled = WIRELESS_EXT;\r\nrange->we_version_source = 18;\r\ni = 0;\r\nif (priv->ieee->mode & (IEEE_B | IEEE_G)) {\r\nfor (j = 0; j < geo->bg_channels && i < IW_MAX_FREQUENCIES; j++) {\r\nif ((priv->ieee->iw_mode == IW_MODE_ADHOC) &&\r\n(geo->bg[j].flags & LIBIPW_CH_PASSIVE_ONLY))\r\ncontinue;\r\nrange->freq[i].i = geo->bg[j].channel;\r\nrange->freq[i].m = geo->bg[j].freq * 100000;\r\nrange->freq[i].e = 1;\r\ni++;\r\n}\r\n}\r\nif (priv->ieee->mode & IEEE_A) {\r\nfor (j = 0; j < geo->a_channels && i < IW_MAX_FREQUENCIES; j++) {\r\nif ((priv->ieee->iw_mode == IW_MODE_ADHOC) &&\r\n(geo->a[j].flags & LIBIPW_CH_PASSIVE_ONLY))\r\ncontinue;\r\nrange->freq[i].i = geo->a[j].channel;\r\nrange->freq[i].m = geo->a[j].freq * 100000;\r\nrange->freq[i].e = 1;\r\ni++;\r\n}\r\n}\r\nrange->num_channels = i;\r\nrange->num_frequency = i;\r\nmutex_unlock(&priv->mutex);\r\nrange->event_capa[0] = (IW_EVENT_CAPA_K_0 |\r\nIW_EVENT_CAPA_MASK(SIOCGIWTHRSPY) |\r\nIW_EVENT_CAPA_MASK(SIOCGIWAP) |\r\nIW_EVENT_CAPA_MASK(SIOCGIWSCAN));\r\nrange->event_capa[1] = IW_EVENT_CAPA_K_1;\r\nrange->enc_capa = IW_ENC_CAPA_WPA | IW_ENC_CAPA_WPA2 |\r\nIW_ENC_CAPA_CIPHER_TKIP | IW_ENC_CAPA_CIPHER_CCMP;\r\nrange->scan_capa = IW_SCAN_CAPA_ESSID | IW_SCAN_CAPA_TYPE;\r\nIPW_DEBUG_WX("GET Range\n");\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_set_wap(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nif (wrqu->ap_addr.sa_family != ARPHRD_ETHER)\r\nreturn -EINVAL;\r\nmutex_lock(&priv->mutex);\r\nif (is_broadcast_ether_addr(wrqu->ap_addr.sa_data) ||\r\nis_zero_ether_addr(wrqu->ap_addr.sa_data)) {\r\nIPW_DEBUG_WX("Setting AP BSSID to ANY\n");\r\npriv->config &= ~CFG_STATIC_BSSID;\r\nIPW_DEBUG_ASSOC("Attempting to associate with new "\r\n"parameters.\n");\r\nipw_associate(priv);\r\nmutex_unlock(&priv->mutex);\r\nreturn 0;\r\n}\r\npriv->config |= CFG_STATIC_BSSID;\r\nif (ether_addr_equal(priv->bssid, wrqu->ap_addr.sa_data)) {\r\nIPW_DEBUG_WX("BSSID set to current BSSID.\n");\r\nmutex_unlock(&priv->mutex);\r\nreturn 0;\r\n}\r\nIPW_DEBUG_WX("Setting mandatory BSSID to %pM\n",\r\nwrqu->ap_addr.sa_data);\r\nmemcpy(priv->bssid, wrqu->ap_addr.sa_data, ETH_ALEN);\r\nIPW_DEBUG_ASSOC("[re]association triggered due to BSSID change.\n");\r\nif (!ipw_disassociate(priv))\r\nipw_associate(priv);\r\nmutex_unlock(&priv->mutex);\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_get_wap(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nmutex_lock(&priv->mutex);\r\nif (priv->config & CFG_STATIC_BSSID ||\r\npriv->status & (STATUS_ASSOCIATED | STATUS_ASSOCIATING)) {\r\nwrqu->ap_addr.sa_family = ARPHRD_ETHER;\r\nmemcpy(wrqu->ap_addr.sa_data, priv->bssid, ETH_ALEN);\r\n} else\r\neth_zero_addr(wrqu->ap_addr.sa_data);\r\nIPW_DEBUG_WX("Getting WAP BSSID: %pM\n",\r\nwrqu->ap_addr.sa_data);\r\nmutex_unlock(&priv->mutex);\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_set_essid(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nint length;\r\nmutex_lock(&priv->mutex);\r\nif (!wrqu->essid.flags)\r\n{\r\nIPW_DEBUG_WX("Setting ESSID to ANY\n");\r\nipw_disassociate(priv);\r\npriv->config &= ~CFG_STATIC_ESSID;\r\nipw_associate(priv);\r\nmutex_unlock(&priv->mutex);\r\nreturn 0;\r\n}\r\nlength = min((int)wrqu->essid.length, IW_ESSID_MAX_SIZE);\r\npriv->config |= CFG_STATIC_ESSID;\r\nif (priv->essid_len == length && !memcmp(priv->essid, extra, length)\r\n&& (priv->status & (STATUS_ASSOCIATED | STATUS_ASSOCIATING))) {\r\nIPW_DEBUG_WX("ESSID set to current ESSID.\n");\r\nmutex_unlock(&priv->mutex);\r\nreturn 0;\r\n}\r\nIPW_DEBUG_WX("Setting ESSID: '%*pE' (%d)\n", length, extra, length);\r\npriv->essid_len = length;\r\nmemcpy(priv->essid, extra, priv->essid_len);\r\nIPW_DEBUG_ASSOC("[re]association triggered due to ESSID change.\n");\r\nif (!ipw_disassociate(priv))\r\nipw_associate(priv);\r\nmutex_unlock(&priv->mutex);\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_get_essid(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nmutex_lock(&priv->mutex);\r\nif (priv->config & CFG_STATIC_ESSID ||\r\npriv->status & (STATUS_ASSOCIATED | STATUS_ASSOCIATING)) {\r\nIPW_DEBUG_WX("Getting essid: '%*pE'\n",\r\npriv->essid_len, priv->essid);\r\nmemcpy(extra, priv->essid, priv->essid_len);\r\nwrqu->essid.length = priv->essid_len;\r\nwrqu->essid.flags = 1;\r\n} else {\r\nIPW_DEBUG_WX("Getting essid: ANY\n");\r\nwrqu->essid.length = 0;\r\nwrqu->essid.flags = 0;\r\n}\r\nmutex_unlock(&priv->mutex);\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_set_nick(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nIPW_DEBUG_WX("Setting nick to '%s'\n", extra);\r\nif (wrqu->data.length > IW_ESSID_MAX_SIZE)\r\nreturn -E2BIG;\r\nmutex_lock(&priv->mutex);\r\nwrqu->data.length = min_t(size_t, wrqu->data.length, sizeof(priv->nick));\r\nmemset(priv->nick, 0, sizeof(priv->nick));\r\nmemcpy(priv->nick, extra, wrqu->data.length);\r\nIPW_DEBUG_TRACE("<<\n");\r\nmutex_unlock(&priv->mutex);\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_get_nick(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nIPW_DEBUG_WX("Getting nick\n");\r\nmutex_lock(&priv->mutex);\r\nwrqu->data.length = strlen(priv->nick);\r\nmemcpy(extra, priv->nick, wrqu->data.length);\r\nwrqu->data.flags = 1;\r\nmutex_unlock(&priv->mutex);\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_set_sens(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nint err = 0;\r\nIPW_DEBUG_WX("Setting roaming threshold to %d\n", wrqu->sens.value);\r\nIPW_DEBUG_WX("Setting disassociate threshold to %d\n", 3*wrqu->sens.value);\r\nmutex_lock(&priv->mutex);\r\nif (wrqu->sens.fixed == 0)\r\n{\r\npriv->roaming_threshold = IPW_MB_ROAMING_THRESHOLD_DEFAULT;\r\npriv->disassociate_threshold = IPW_MB_DISASSOCIATE_THRESHOLD_DEFAULT;\r\ngoto out;\r\n}\r\nif ((wrqu->sens.value > IPW_MB_ROAMING_THRESHOLD_MAX) ||\r\n(wrqu->sens.value < IPW_MB_ROAMING_THRESHOLD_MIN)) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\npriv->roaming_threshold = wrqu->sens.value;\r\npriv->disassociate_threshold = 3*wrqu->sens.value;\r\nout:\r\nmutex_unlock(&priv->mutex);\r\nreturn err;\r\n}\r\nstatic int ipw_wx_get_sens(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nmutex_lock(&priv->mutex);\r\nwrqu->sens.fixed = 1;\r\nwrqu->sens.value = priv->roaming_threshold;\r\nmutex_unlock(&priv->mutex);\r\nIPW_DEBUG_WX("GET roaming threshold -> %s %d\n",\r\nwrqu->power.disabled ? "OFF" : "ON", wrqu->power.value);\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_set_rate(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nu32 target_rate = wrqu->bitrate.value;\r\nu32 fixed, mask;\r\nif (target_rate == -1) {\r\nfixed = 0;\r\nmask = LIBIPW_DEFAULT_RATES_MASK;\r\ngoto apply;\r\n}\r\nmask = 0;\r\nfixed = wrqu->bitrate.fixed;\r\nif (target_rate == 1000000 || !fixed)\r\nmask |= LIBIPW_CCK_RATE_1MB_MASK;\r\nif (target_rate == 1000000)\r\ngoto apply;\r\nif (target_rate == 2000000 || !fixed)\r\nmask |= LIBIPW_CCK_RATE_2MB_MASK;\r\nif (target_rate == 2000000)\r\ngoto apply;\r\nif (target_rate == 5500000 || !fixed)\r\nmask |= LIBIPW_CCK_RATE_5MB_MASK;\r\nif (target_rate == 5500000)\r\ngoto apply;\r\nif (target_rate == 6000000 || !fixed)\r\nmask |= LIBIPW_OFDM_RATE_6MB_MASK;\r\nif (target_rate == 6000000)\r\ngoto apply;\r\nif (target_rate == 9000000 || !fixed)\r\nmask |= LIBIPW_OFDM_RATE_9MB_MASK;\r\nif (target_rate == 9000000)\r\ngoto apply;\r\nif (target_rate == 11000000 || !fixed)\r\nmask |= LIBIPW_CCK_RATE_11MB_MASK;\r\nif (target_rate == 11000000)\r\ngoto apply;\r\nif (target_rate == 12000000 || !fixed)\r\nmask |= LIBIPW_OFDM_RATE_12MB_MASK;\r\nif (target_rate == 12000000)\r\ngoto apply;\r\nif (target_rate == 18000000 || !fixed)\r\nmask |= LIBIPW_OFDM_RATE_18MB_MASK;\r\nif (target_rate == 18000000)\r\ngoto apply;\r\nif (target_rate == 24000000 || !fixed)\r\nmask |= LIBIPW_OFDM_RATE_24MB_MASK;\r\nif (target_rate == 24000000)\r\ngoto apply;\r\nif (target_rate == 36000000 || !fixed)\r\nmask |= LIBIPW_OFDM_RATE_36MB_MASK;\r\nif (target_rate == 36000000)\r\ngoto apply;\r\nif (target_rate == 48000000 || !fixed)\r\nmask |= LIBIPW_OFDM_RATE_48MB_MASK;\r\nif (target_rate == 48000000)\r\ngoto apply;\r\nif (target_rate == 54000000 || !fixed)\r\nmask |= LIBIPW_OFDM_RATE_54MB_MASK;\r\nif (target_rate == 54000000)\r\ngoto apply;\r\nIPW_DEBUG_WX("invalid rate specified, returning error\n");\r\nreturn -EINVAL;\r\napply:\r\nIPW_DEBUG_WX("Setting rate mask to 0x%08X [%s]\n",\r\nmask, fixed ? "fixed" : "sub-rates");\r\nmutex_lock(&priv->mutex);\r\nif (mask == LIBIPW_DEFAULT_RATES_MASK) {\r\npriv->config &= ~CFG_FIXED_RATE;\r\nipw_set_fixed_rate(priv, priv->ieee->mode);\r\n} else\r\npriv->config |= CFG_FIXED_RATE;\r\nif (priv->rates_mask == mask) {\r\nIPW_DEBUG_WX("Mask set to current mask.\n");\r\nmutex_unlock(&priv->mutex);\r\nreturn 0;\r\n}\r\npriv->rates_mask = mask;\r\nIPW_DEBUG_ASSOC("[re]association triggered due to rates change.\n");\r\nif (!ipw_disassociate(priv))\r\nipw_associate(priv);\r\nmutex_unlock(&priv->mutex);\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_get_rate(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nmutex_lock(&priv->mutex);\r\nwrqu->bitrate.value = priv->last_rate;\r\nwrqu->bitrate.fixed = (priv->config & CFG_FIXED_RATE) ? 1 : 0;\r\nmutex_unlock(&priv->mutex);\r\nIPW_DEBUG_WX("GET Rate -> %d\n", wrqu->bitrate.value);\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_set_rts(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nmutex_lock(&priv->mutex);\r\nif (wrqu->rts.disabled || !wrqu->rts.fixed)\r\npriv->rts_threshold = DEFAULT_RTS_THRESHOLD;\r\nelse {\r\nif (wrqu->rts.value < MIN_RTS_THRESHOLD ||\r\nwrqu->rts.value > MAX_RTS_THRESHOLD) {\r\nmutex_unlock(&priv->mutex);\r\nreturn -EINVAL;\r\n}\r\npriv->rts_threshold = wrqu->rts.value;\r\n}\r\nipw_send_rts_threshold(priv, priv->rts_threshold);\r\nmutex_unlock(&priv->mutex);\r\nIPW_DEBUG_WX("SET RTS Threshold -> %d\n", priv->rts_threshold);\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_get_rts(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nmutex_lock(&priv->mutex);\r\nwrqu->rts.value = priv->rts_threshold;\r\nwrqu->rts.fixed = 0;\r\nwrqu->rts.disabled = (wrqu->rts.value == DEFAULT_RTS_THRESHOLD);\r\nmutex_unlock(&priv->mutex);\r\nIPW_DEBUG_WX("GET RTS Threshold -> %d\n", wrqu->rts.value);\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_set_txpow(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nint err = 0;\r\nmutex_lock(&priv->mutex);\r\nif (ipw_radio_kill_sw(priv, wrqu->power.disabled)) {\r\nerr = -EINPROGRESS;\r\ngoto out;\r\n}\r\nif (!wrqu->power.fixed)\r\nwrqu->power.value = IPW_TX_POWER_DEFAULT;\r\nif (wrqu->power.flags != IW_TXPOW_DBM) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif ((wrqu->power.value > IPW_TX_POWER_MAX) ||\r\n(wrqu->power.value < IPW_TX_POWER_MIN)) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\npriv->tx_power = wrqu->power.value;\r\nerr = ipw_set_tx_power(priv);\r\nout:\r\nmutex_unlock(&priv->mutex);\r\nreturn err;\r\n}\r\nstatic int ipw_wx_get_txpow(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nmutex_lock(&priv->mutex);\r\nwrqu->power.value = priv->tx_power;\r\nwrqu->power.fixed = 1;\r\nwrqu->power.flags = IW_TXPOW_DBM;\r\nwrqu->power.disabled = (priv->status & STATUS_RF_KILL_MASK) ? 1 : 0;\r\nmutex_unlock(&priv->mutex);\r\nIPW_DEBUG_WX("GET TX Power -> %s %d\n",\r\nwrqu->power.disabled ? "OFF" : "ON", wrqu->power.value);\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_set_frag(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nmutex_lock(&priv->mutex);\r\nif (wrqu->frag.disabled || !wrqu->frag.fixed)\r\npriv->ieee->fts = DEFAULT_FTS;\r\nelse {\r\nif (wrqu->frag.value < MIN_FRAG_THRESHOLD ||\r\nwrqu->frag.value > MAX_FRAG_THRESHOLD) {\r\nmutex_unlock(&priv->mutex);\r\nreturn -EINVAL;\r\n}\r\npriv->ieee->fts = wrqu->frag.value & ~0x1;\r\n}\r\nipw_send_frag_threshold(priv, wrqu->frag.value);\r\nmutex_unlock(&priv->mutex);\r\nIPW_DEBUG_WX("SET Frag Threshold -> %d\n", wrqu->frag.value);\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_get_frag(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nmutex_lock(&priv->mutex);\r\nwrqu->frag.value = priv->ieee->fts;\r\nwrqu->frag.fixed = 0;\r\nwrqu->frag.disabled = (wrqu->frag.value == DEFAULT_FTS);\r\nmutex_unlock(&priv->mutex);\r\nIPW_DEBUG_WX("GET Frag Threshold -> %d\n", wrqu->frag.value);\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_set_retry(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nif (wrqu->retry.flags & IW_RETRY_LIFETIME || wrqu->retry.disabled)\r\nreturn -EINVAL;\r\nif (!(wrqu->retry.flags & IW_RETRY_LIMIT))\r\nreturn 0;\r\nif (wrqu->retry.value < 0 || wrqu->retry.value >= 255)\r\nreturn -EINVAL;\r\nmutex_lock(&priv->mutex);\r\nif (wrqu->retry.flags & IW_RETRY_SHORT)\r\npriv->short_retry_limit = (u8) wrqu->retry.value;\r\nelse if (wrqu->retry.flags & IW_RETRY_LONG)\r\npriv->long_retry_limit = (u8) wrqu->retry.value;\r\nelse {\r\npriv->short_retry_limit = (u8) wrqu->retry.value;\r\npriv->long_retry_limit = (u8) wrqu->retry.value;\r\n}\r\nipw_send_retry_limit(priv, priv->short_retry_limit,\r\npriv->long_retry_limit);\r\nmutex_unlock(&priv->mutex);\r\nIPW_DEBUG_WX("SET retry limit -> short:%d long:%d\n",\r\npriv->short_retry_limit, priv->long_retry_limit);\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_get_retry(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nmutex_lock(&priv->mutex);\r\nwrqu->retry.disabled = 0;\r\nif ((wrqu->retry.flags & IW_RETRY_TYPE) == IW_RETRY_LIFETIME) {\r\nmutex_unlock(&priv->mutex);\r\nreturn -EINVAL;\r\n}\r\nif (wrqu->retry.flags & IW_RETRY_LONG) {\r\nwrqu->retry.flags = IW_RETRY_LIMIT | IW_RETRY_LONG;\r\nwrqu->retry.value = priv->long_retry_limit;\r\n} else if (wrqu->retry.flags & IW_RETRY_SHORT) {\r\nwrqu->retry.flags = IW_RETRY_LIMIT | IW_RETRY_SHORT;\r\nwrqu->retry.value = priv->short_retry_limit;\r\n} else {\r\nwrqu->retry.flags = IW_RETRY_LIMIT;\r\nwrqu->retry.value = priv->short_retry_limit;\r\n}\r\nmutex_unlock(&priv->mutex);\r\nIPW_DEBUG_WX("GET retry -> %d\n", wrqu->retry.value);\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_set_scan(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nstruct iw_scan_req *req = (struct iw_scan_req *)extra;\r\nstruct delayed_work *work = NULL;\r\nmutex_lock(&priv->mutex);\r\npriv->user_requested_scan = 1;\r\nif (wrqu->data.length == sizeof(struct iw_scan_req)) {\r\nif (wrqu->data.flags & IW_SCAN_THIS_ESSID) {\r\nint len = min((int)req->essid_len,\r\n(int)sizeof(priv->direct_scan_ssid));\r\nmemcpy(priv->direct_scan_ssid, req->essid, len);\r\npriv->direct_scan_ssid_len = len;\r\nwork = &priv->request_direct_scan;\r\n} else if (req->scan_type == IW_SCAN_TYPE_PASSIVE) {\r\nwork = &priv->request_passive_scan;\r\n}\r\n} else {\r\nwork = &priv->request_scan;\r\n}\r\nmutex_unlock(&priv->mutex);\r\nIPW_DEBUG_WX("Start scan\n");\r\nschedule_delayed_work(work, 0);\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_get_scan(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nreturn libipw_wx_get_scan(priv->ieee, info, wrqu, extra);\r\n}\r\nstatic int ipw_wx_set_encode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *key)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nint ret;\r\nu32 cap = priv->capability;\r\nmutex_lock(&priv->mutex);\r\nret = libipw_wx_set_encode(priv->ieee, info, wrqu, key);\r\nif (cap != priv->capability &&\r\npriv->ieee->iw_mode == IW_MODE_ADHOC &&\r\npriv->status & STATUS_ASSOCIATED)\r\nipw_disassociate(priv);\r\nmutex_unlock(&priv->mutex);\r\nreturn ret;\r\n}\r\nstatic int ipw_wx_get_encode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *key)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nreturn libipw_wx_get_encode(priv->ieee, info, wrqu, key);\r\n}\r\nstatic int ipw_wx_set_power(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nint err;\r\nmutex_lock(&priv->mutex);\r\nif (wrqu->power.disabled) {\r\npriv->power_mode = IPW_POWER_LEVEL(priv->power_mode);\r\nerr = ipw_send_power_mode(priv, IPW_POWER_MODE_CAM);\r\nif (err) {\r\nIPW_DEBUG_WX("failed setting power mode.\n");\r\nmutex_unlock(&priv->mutex);\r\nreturn err;\r\n}\r\nIPW_DEBUG_WX("SET Power Management Mode -> off\n");\r\nmutex_unlock(&priv->mutex);\r\nreturn 0;\r\n}\r\nswitch (wrqu->power.flags & IW_POWER_MODE) {\r\ncase IW_POWER_ON:\r\ncase IW_POWER_MODE:\r\ncase IW_POWER_ALL_R:\r\nbreak;\r\ndefault:\r\nIPW_DEBUG_WX("SET PM Mode: %X not supported.\n",\r\nwrqu->power.flags);\r\nmutex_unlock(&priv->mutex);\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (IPW_POWER_LEVEL(priv->power_mode) == IPW_POWER_AC)\r\npriv->power_mode = IPW_POWER_ENABLED | IPW_POWER_BATTERY;\r\nelse\r\npriv->power_mode = IPW_POWER_ENABLED | priv->power_mode;\r\nerr = ipw_send_power_mode(priv, IPW_POWER_LEVEL(priv->power_mode));\r\nif (err) {\r\nIPW_DEBUG_WX("failed setting power mode.\n");\r\nmutex_unlock(&priv->mutex);\r\nreturn err;\r\n}\r\nIPW_DEBUG_WX("SET Power Management Mode -> 0x%02X\n", priv->power_mode);\r\nmutex_unlock(&priv->mutex);\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_get_power(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nmutex_lock(&priv->mutex);\r\nif (!(priv->power_mode & IPW_POWER_ENABLED))\r\nwrqu->power.disabled = 1;\r\nelse\r\nwrqu->power.disabled = 0;\r\nmutex_unlock(&priv->mutex);\r\nIPW_DEBUG_WX("GET Power Management Mode -> %02X\n", priv->power_mode);\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_set_powermode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nint mode = *(int *)extra;\r\nint err;\r\nmutex_lock(&priv->mutex);\r\nif ((mode < 1) || (mode > IPW_POWER_LIMIT))\r\nmode = IPW_POWER_AC;\r\nif (IPW_POWER_LEVEL(priv->power_mode) != mode) {\r\nerr = ipw_send_power_mode(priv, mode);\r\nif (err) {\r\nIPW_DEBUG_WX("failed setting power mode.\n");\r\nmutex_unlock(&priv->mutex);\r\nreturn err;\r\n}\r\npriv->power_mode = IPW_POWER_ENABLED | mode;\r\n}\r\nmutex_unlock(&priv->mutex);\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_get_powermode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nint level = IPW_POWER_LEVEL(priv->power_mode);\r\nchar *p = extra;\r\np += snprintf(p, MAX_WX_STRING, "Power save level: %d ", level);\r\nswitch (level) {\r\ncase IPW_POWER_AC:\r\np += snprintf(p, MAX_WX_STRING - (p - extra), "(AC)");\r\nbreak;\r\ncase IPW_POWER_BATTERY:\r\np += snprintf(p, MAX_WX_STRING - (p - extra), "(BATTERY)");\r\nbreak;\r\ndefault:\r\np += snprintf(p, MAX_WX_STRING - (p - extra),\r\n"(Timeout %dms, Period %dms)",\r\ntimeout_duration[level - 1] / 1000,\r\nperiod_duration[level - 1] / 1000);\r\n}\r\nif (!(priv->power_mode & IPW_POWER_ENABLED))\r\np += snprintf(p, MAX_WX_STRING - (p - extra), " OFF");\r\nwrqu->data.length = p - extra + 1;\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_set_wireless_mode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nint mode = *(int *)extra;\r\nu8 band = 0, modulation = 0;\r\nif (mode == 0 || mode & ~IEEE_MODE_MASK) {\r\nIPW_WARNING("Attempt to set invalid wireless mode: %d\n", mode);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&priv->mutex);\r\nif (priv->adapter == IPW_2915ABG) {\r\npriv->ieee->abg_true = 1;\r\nif (mode & IEEE_A) {\r\nband |= LIBIPW_52GHZ_BAND;\r\nmodulation |= LIBIPW_OFDM_MODULATION;\r\n} else\r\npriv->ieee->abg_true = 0;\r\n} else {\r\nif (mode & IEEE_A) {\r\nIPW_WARNING("Attempt to set 2200BG into "\r\n"802.11a mode\n");\r\nmutex_unlock(&priv->mutex);\r\nreturn -EINVAL;\r\n}\r\npriv->ieee->abg_true = 0;\r\n}\r\nif (mode & IEEE_B) {\r\nband |= LIBIPW_24GHZ_BAND;\r\nmodulation |= LIBIPW_CCK_MODULATION;\r\n} else\r\npriv->ieee->abg_true = 0;\r\nif (mode & IEEE_G) {\r\nband |= LIBIPW_24GHZ_BAND;\r\nmodulation |= LIBIPW_OFDM_MODULATION;\r\n} else\r\npriv->ieee->abg_true = 0;\r\npriv->ieee->mode = mode;\r\npriv->ieee->freq_band = band;\r\npriv->ieee->modulation = modulation;\r\ninit_supported_rates(priv, &priv->rates);\r\nIPW_DEBUG_ASSOC("[re]association triggered due to mode change.\n");\r\nif (!ipw_disassociate(priv)) {\r\nipw_send_supported_rates(priv, &priv->rates);\r\nipw_associate(priv);\r\n}\r\nipw_led_band_on(priv);\r\nIPW_DEBUG_WX("PRIV SET MODE: %c%c%c\n",\r\nmode & IEEE_A ? 'a' : '.',\r\nmode & IEEE_B ? 'b' : '.', mode & IEEE_G ? 'g' : '.');\r\nmutex_unlock(&priv->mutex);\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_get_wireless_mode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nmutex_lock(&priv->mutex);\r\nswitch (priv->ieee->mode) {\r\ncase IEEE_A:\r\nstrncpy(extra, "802.11a (1)", MAX_WX_STRING);\r\nbreak;\r\ncase IEEE_B:\r\nstrncpy(extra, "802.11b (2)", MAX_WX_STRING);\r\nbreak;\r\ncase IEEE_A | IEEE_B:\r\nstrncpy(extra, "802.11ab (3)", MAX_WX_STRING);\r\nbreak;\r\ncase IEEE_G:\r\nstrncpy(extra, "802.11g (4)", MAX_WX_STRING);\r\nbreak;\r\ncase IEEE_A | IEEE_G:\r\nstrncpy(extra, "802.11ag (5)", MAX_WX_STRING);\r\nbreak;\r\ncase IEEE_B | IEEE_G:\r\nstrncpy(extra, "802.11bg (6)", MAX_WX_STRING);\r\nbreak;\r\ncase IEEE_A | IEEE_B | IEEE_G:\r\nstrncpy(extra, "802.11abg (7)", MAX_WX_STRING);\r\nbreak;\r\ndefault:\r\nstrncpy(extra, "unknown", MAX_WX_STRING);\r\nbreak;\r\n}\r\nextra[MAX_WX_STRING - 1] = '\0';\r\nIPW_DEBUG_WX("PRIV GET MODE: %s\n", extra);\r\nwrqu->data.length = strlen(extra) + 1;\r\nmutex_unlock(&priv->mutex);\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_set_preamble(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nint mode = *(int *)extra;\r\nmutex_lock(&priv->mutex);\r\nif (mode == 1) {\r\nif (!(priv->config & CFG_PREAMBLE_LONG)) {\r\npriv->config |= CFG_PREAMBLE_LONG;\r\nIPW_DEBUG_ASSOC\r\n("[re]association triggered due to preamble change.\n");\r\nif (!ipw_disassociate(priv))\r\nipw_associate(priv);\r\n}\r\ngoto done;\r\n}\r\nif (mode == 0) {\r\npriv->config &= ~CFG_PREAMBLE_LONG;\r\ngoto done;\r\n}\r\nmutex_unlock(&priv->mutex);\r\nreturn -EINVAL;\r\ndone:\r\nmutex_unlock(&priv->mutex);\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_get_preamble(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nmutex_lock(&priv->mutex);\r\nif (priv->config & CFG_PREAMBLE_LONG)\r\nsnprintf(wrqu->name, IFNAMSIZ, "long (1)");\r\nelse\r\nsnprintf(wrqu->name, IFNAMSIZ, "auto (0)");\r\nmutex_unlock(&priv->mutex);\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_set_monitor(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nint *parms = (int *)extra;\r\nint enable = (parms[0] > 0);\r\nmutex_lock(&priv->mutex);\r\nIPW_DEBUG_WX("SET MONITOR: %d %d\n", enable, parms[1]);\r\nif (enable) {\r\nif (priv->ieee->iw_mode != IW_MODE_MONITOR) {\r\n#ifdef CONFIG_IPW2200_RADIOTAP\r\npriv->net_dev->type = ARPHRD_IEEE80211_RADIOTAP;\r\n#else\r\npriv->net_dev->type = ARPHRD_IEEE80211;\r\n#endif\r\nschedule_work(&priv->adapter_restart);\r\n}\r\nipw_set_channel(priv, parms[1]);\r\n} else {\r\nif (priv->ieee->iw_mode != IW_MODE_MONITOR) {\r\nmutex_unlock(&priv->mutex);\r\nreturn 0;\r\n}\r\npriv->net_dev->type = ARPHRD_ETHER;\r\nschedule_work(&priv->adapter_restart);\r\n}\r\nmutex_unlock(&priv->mutex);\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_reset(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nIPW_DEBUG_WX("RESET\n");\r\nschedule_work(&priv->adapter_restart);\r\nreturn 0;\r\n}\r\nstatic int ipw_wx_sw_reset(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nunion iwreq_data wrqu_sec = {\r\n.encoding = {\r\n.flags = IW_ENCODE_DISABLED,\r\n},\r\n};\r\nint ret;\r\nIPW_DEBUG_WX("SW_RESET\n");\r\nmutex_lock(&priv->mutex);\r\nret = ipw_sw_reset(priv, 2);\r\nif (!ret) {\r\nfree_firmware();\r\nipw_adapter_restart(priv);\r\n}\r\nipw_radio_kill_sw(priv, priv->status & STATUS_RF_KILL_SW);\r\nmutex_unlock(&priv->mutex);\r\nlibipw_wx_set_encode(priv->ieee, info, &wrqu_sec, NULL);\r\nmutex_lock(&priv->mutex);\r\nif (!(priv->status & STATUS_RF_KILL_MASK)) {\r\nIPW_DEBUG_ASSOC("[re]association triggered due to sw "\r\n"reset.\n");\r\nif (!ipw_disassociate(priv))\r\nipw_associate(priv);\r\n}\r\nmutex_unlock(&priv->mutex);\r\nreturn 0;\r\n}\r\nstatic struct iw_statistics *ipw_get_wireless_stats(struct net_device *dev)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nstruct iw_statistics *wstats;\r\nwstats = &priv->wstats;\r\nif (!(priv->status & STATUS_ASSOCIATED)) {\r\nwstats->miss.beacon = 0;\r\nwstats->discard.retries = 0;\r\nwstats->qual.qual = 0;\r\nwstats->qual.level = 0;\r\nwstats->qual.noise = 0;\r\nwstats->qual.updated = 7;\r\nwstats->qual.updated |= IW_QUAL_NOISE_INVALID |\r\nIW_QUAL_QUAL_INVALID | IW_QUAL_LEVEL_INVALID;\r\nreturn wstats;\r\n}\r\nwstats->qual.qual = priv->quality;\r\nwstats->qual.level = priv->exp_avg_rssi;\r\nwstats->qual.noise = priv->exp_avg_noise;\r\nwstats->qual.updated = IW_QUAL_QUAL_UPDATED | IW_QUAL_LEVEL_UPDATED |\r\nIW_QUAL_NOISE_UPDATED | IW_QUAL_DBM;\r\nwstats->miss.beacon = average_value(&priv->average_missed_beacons);\r\nwstats->discard.retries = priv->last_tx_failures;\r\nwstats->discard.code = priv->ieee->ieee_stats.rx_discards_undecryptable;\r\nreturn wstats;\r\n}\r\nstatic void init_sys_config(struct ipw_sys_config *sys_config)\r\n{\r\nmemset(sys_config, 0, sizeof(struct ipw_sys_config));\r\nsys_config->bt_coexistence = 0;\r\nsys_config->answer_broadcast_ssid_probe = 0;\r\nsys_config->accept_all_data_frames = 0;\r\nsys_config->accept_non_directed_frames = 1;\r\nsys_config->exclude_unicast_unencrypted = 0;\r\nsys_config->disable_unicast_decryption = 1;\r\nsys_config->exclude_multicast_unencrypted = 0;\r\nsys_config->disable_multicast_decryption = 1;\r\nif (antenna < CFG_SYS_ANTENNA_BOTH || antenna > CFG_SYS_ANTENNA_B)\r\nantenna = CFG_SYS_ANTENNA_BOTH;\r\nsys_config->antenna_diversity = antenna;\r\nsys_config->pass_crc_to_host = 0;\r\nsys_config->dot11g_auto_detection = 0;\r\nsys_config->enable_cts_to_self = 0;\r\nsys_config->bt_coexist_collision_thr = 0;\r\nsys_config->pass_noise_stats_to_host = 1;\r\nsys_config->silence_threshold = 0x1e;\r\n}\r\nstatic int ipw_net_open(struct net_device *dev)\r\n{\r\nIPW_DEBUG_INFO("dev->open\n");\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int ipw_net_stop(struct net_device *dev)\r\n{\r\nIPW_DEBUG_INFO("dev->close\n");\r\nnetif_stop_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int ipw_tx_skb(struct ipw_priv *priv, struct libipw_txb *txb,\r\nint pri)\r\n{\r\nstruct libipw_hdr_3addrqos *hdr = (struct libipw_hdr_3addrqos *)\r\ntxb->fragments[0]->data;\r\nint i = 0;\r\nstruct tfd_frame *tfd;\r\n#ifdef CONFIG_IPW2200_QOS\r\nint tx_id = ipw_get_tx_queue_number(priv, pri);\r\nstruct clx2_tx_queue *txq = &priv->txq[tx_id];\r\n#else\r\nstruct clx2_tx_queue *txq = &priv->txq[0];\r\n#endif\r\nstruct clx2_queue *q = &txq->q;\r\nu8 id, hdr_len, unicast;\r\nint fc;\r\nif (!(priv->status & STATUS_ASSOCIATED))\r\ngoto drop;\r\nhdr_len = libipw_get_hdrlen(le16_to_cpu(hdr->frame_ctl));\r\nswitch (priv->ieee->iw_mode) {\r\ncase IW_MODE_ADHOC:\r\nunicast = !is_multicast_ether_addr(hdr->addr1);\r\nid = ipw_find_station(priv, hdr->addr1);\r\nif (id == IPW_INVALID_STATION) {\r\nid = ipw_add_station(priv, hdr->addr1);\r\nif (id == IPW_INVALID_STATION) {\r\nIPW_WARNING("Attempt to send data to "\r\n"invalid cell: %pM\n",\r\nhdr->addr1);\r\ngoto drop;\r\n}\r\n}\r\nbreak;\r\ncase IW_MODE_INFRA:\r\ndefault:\r\nunicast = !is_multicast_ether_addr(hdr->addr3);\r\nid = 0;\r\nbreak;\r\n}\r\ntfd = &txq->bd[q->first_empty];\r\ntxq->txb[q->first_empty] = txb;\r\nmemset(tfd, 0, sizeof(*tfd));\r\ntfd->u.data.station_number = id;\r\ntfd->control_flags.message_type = TX_FRAME_TYPE;\r\ntfd->control_flags.control_bits = TFD_NEED_IRQ_MASK;\r\ntfd->u.data.cmd_id = DINO_CMD_TX;\r\ntfd->u.data.len = cpu_to_le16(txb->payload_size);\r\nif (priv->assoc_request.ieee_mode == IPW_B_MODE)\r\ntfd->u.data.tx_flags_ext |= DCT_FLAG_EXT_MODE_CCK;\r\nelse\r\ntfd->u.data.tx_flags_ext |= DCT_FLAG_EXT_MODE_OFDM;\r\nif (priv->assoc_request.preamble_length == DCT_FLAG_SHORT_PREAMBLE)\r\ntfd->u.data.tx_flags |= DCT_FLAG_SHORT_PREAMBLE;\r\nfc = le16_to_cpu(hdr->frame_ctl);\r\nhdr->frame_ctl = cpu_to_le16(fc & ~IEEE80211_FCTL_MOREFRAGS);\r\nmemcpy(&tfd->u.data.tfd.tfd_24.mchdr, hdr, hdr_len);\r\nif (likely(unicast))\r\ntfd->u.data.tx_flags |= DCT_FLAG_ACK_REQD;\r\nif (txb->encrypted && !priv->ieee->host_encrypt) {\r\nswitch (priv->ieee->sec.level) {\r\ncase SEC_LEVEL_3:\r\ntfd->u.data.tfd.tfd_24.mchdr.frame_ctl |=\r\ncpu_to_le16(IEEE80211_FCTL_PROTECTED);\r\nif (!unicast)\r\ntfd->u.data.tx_flags |= DCT_FLAG_ACK_REQD;\r\ntfd->u.data.tx_flags &= ~DCT_FLAG_NO_WEP;\r\ntfd->u.data.tx_flags_ext |= DCT_FLAG_EXT_SECURITY_CCM;\r\ntfd->u.data.key_index = 0;\r\ntfd->u.data.key_index |= DCT_WEP_INDEX_USE_IMMEDIATE;\r\nbreak;\r\ncase SEC_LEVEL_2:\r\ntfd->u.data.tfd.tfd_24.mchdr.frame_ctl |=\r\ncpu_to_le16(IEEE80211_FCTL_PROTECTED);\r\ntfd->u.data.tx_flags &= ~DCT_FLAG_NO_WEP;\r\ntfd->u.data.tx_flags_ext |= DCT_FLAG_EXT_SECURITY_TKIP;\r\ntfd->u.data.key_index = DCT_WEP_INDEX_USE_IMMEDIATE;\r\nbreak;\r\ncase SEC_LEVEL_1:\r\ntfd->u.data.tfd.tfd_24.mchdr.frame_ctl |=\r\ncpu_to_le16(IEEE80211_FCTL_PROTECTED);\r\ntfd->u.data.key_index = priv->ieee->crypt_info.tx_keyidx;\r\nif (priv->ieee->sec.key_sizes[priv->ieee->crypt_info.tx_keyidx] <=\r\n40)\r\ntfd->u.data.key_index |= DCT_WEP_KEY_64Bit;\r\nelse\r\ntfd->u.data.key_index |= DCT_WEP_KEY_128Bit;\r\nbreak;\r\ncase SEC_LEVEL_0:\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "Unknown security level %d\n",\r\npriv->ieee->sec.level);\r\nbreak;\r\n}\r\n} else\r\ntfd->u.data.tx_flags |= DCT_FLAG_NO_WEP;\r\n#ifdef CONFIG_IPW2200_QOS\r\nif (fc & IEEE80211_STYPE_QOS_DATA)\r\nipw_qos_set_tx_queue_command(priv, pri, &(tfd->u.data));\r\n#endif\r\ntfd->u.data.num_chunks = cpu_to_le32(min((u8) (NUM_TFD_CHUNKS - 2),\r\ntxb->nr_frags));\r\nIPW_DEBUG_FRAG("%i fragments being sent as %i chunks.\n",\r\ntxb->nr_frags, le32_to_cpu(tfd->u.data.num_chunks));\r\nfor (i = 0; i < le32_to_cpu(tfd->u.data.num_chunks); i++) {\r\nIPW_DEBUG_FRAG("Adding fragment %i of %i (%d bytes).\n",\r\ni, le32_to_cpu(tfd->u.data.num_chunks),\r\ntxb->fragments[i]->len - hdr_len);\r\nIPW_DEBUG_TX("Dumping TX packet frag %i of %i (%d bytes):\n",\r\ni, tfd->u.data.num_chunks,\r\ntxb->fragments[i]->len - hdr_len);\r\nprintk_buf(IPW_DL_TX, txb->fragments[i]->data + hdr_len,\r\ntxb->fragments[i]->len - hdr_len);\r\ntfd->u.data.chunk_ptr[i] =\r\ncpu_to_le32(pci_map_single\r\n(priv->pci_dev,\r\ntxb->fragments[i]->data + hdr_len,\r\ntxb->fragments[i]->len - hdr_len,\r\nPCI_DMA_TODEVICE));\r\ntfd->u.data.chunk_len[i] =\r\ncpu_to_le16(txb->fragments[i]->len - hdr_len);\r\n}\r\nif (i != txb->nr_frags) {\r\nstruct sk_buff *skb;\r\nu16 remaining_bytes = 0;\r\nint j;\r\nfor (j = i; j < txb->nr_frags; j++)\r\nremaining_bytes += txb->fragments[j]->len - hdr_len;\r\nprintk(KERN_INFO "Trying to reallocate for %d bytes\n",\r\nremaining_bytes);\r\nskb = alloc_skb(remaining_bytes, GFP_ATOMIC);\r\nif (skb != NULL) {\r\ntfd->u.data.chunk_len[i] = cpu_to_le16(remaining_bytes);\r\nfor (j = i; j < txb->nr_frags; j++) {\r\nint size = txb->fragments[j]->len - hdr_len;\r\nprintk(KERN_INFO "Adding frag %d %d...\n",\r\nj, size);\r\nmemcpy(skb_put(skb, size),\r\ntxb->fragments[j]->data + hdr_len, size);\r\n}\r\ndev_kfree_skb_any(txb->fragments[i]);\r\ntxb->fragments[i] = skb;\r\ntfd->u.data.chunk_ptr[i] =\r\ncpu_to_le32(pci_map_single\r\n(priv->pci_dev, skb->data,\r\nremaining_bytes,\r\nPCI_DMA_TODEVICE));\r\nle32_add_cpu(&tfd->u.data.num_chunks, 1);\r\n}\r\n}\r\nq->first_empty = ipw_queue_inc_wrap(q->first_empty, q->n_bd);\r\nipw_write32(priv, q->reg_w, q->first_empty);\r\nif (ipw_tx_queue_space(q) < q->high_mark)\r\nnetif_stop_queue(priv->net_dev);\r\nreturn NETDEV_TX_OK;\r\ndrop:\r\nIPW_DEBUG_DROP("Silently dropping Tx packet.\n");\r\nlibipw_txb_free(txb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int ipw_net_is_queue_full(struct net_device *dev, int pri)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\n#ifdef CONFIG_IPW2200_QOS\r\nint tx_id = ipw_get_tx_queue_number(priv, pri);\r\nstruct clx2_tx_queue *txq = &priv->txq[tx_id];\r\n#else\r\nstruct clx2_tx_queue *txq = &priv->txq[0];\r\n#endif\r\nif (ipw_tx_queue_space(&txq->q) < txq->q.high_mark)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void ipw_handle_promiscuous_tx(struct ipw_priv *priv,\r\nstruct libipw_txb *txb)\r\n{\r\nstruct libipw_rx_stats dummystats;\r\nstruct ieee80211_hdr *hdr;\r\nu8 n;\r\nu16 filter = priv->prom_priv->filter;\r\nint hdr_only = 0;\r\nif (filter & IPW_PROM_NO_TX)\r\nreturn;\r\nmemset(&dummystats, 0, sizeof(dummystats));\r\nhdr = (void *)txb->fragments[0]->data;\r\nif (libipw_is_management(le16_to_cpu(hdr->frame_control))) {\r\nif (filter & IPW_PROM_NO_MGMT)\r\nreturn;\r\nif (filter & IPW_PROM_MGMT_HEADER_ONLY)\r\nhdr_only = 1;\r\n} else if (libipw_is_control(le16_to_cpu(hdr->frame_control))) {\r\nif (filter & IPW_PROM_NO_CTL)\r\nreturn;\r\nif (filter & IPW_PROM_CTL_HEADER_ONLY)\r\nhdr_only = 1;\r\n} else if (libipw_is_data(le16_to_cpu(hdr->frame_control))) {\r\nif (filter & IPW_PROM_NO_DATA)\r\nreturn;\r\nif (filter & IPW_PROM_DATA_HEADER_ONLY)\r\nhdr_only = 1;\r\n}\r\nfor(n=0; n<txb->nr_frags; ++n) {\r\nstruct sk_buff *src = txb->fragments[n];\r\nstruct sk_buff *dst;\r\nstruct ieee80211_radiotap_header *rt_hdr;\r\nint len;\r\nif (hdr_only) {\r\nhdr = (void *)src->data;\r\nlen = libipw_get_hdrlen(le16_to_cpu(hdr->frame_control));\r\n} else\r\nlen = src->len;\r\ndst = alloc_skb(len + sizeof(*rt_hdr) + sizeof(u16)*2, GFP_ATOMIC);\r\nif (!dst)\r\ncontinue;\r\nrt_hdr = (void *)skb_put(dst, sizeof(*rt_hdr));\r\nrt_hdr->it_version = PKTHDR_RADIOTAP_VERSION;\r\nrt_hdr->it_pad = 0;\r\nrt_hdr->it_present = 0;\r\nrt_hdr->it_present |= cpu_to_le32(1 << IEEE80211_RADIOTAP_CHANNEL);\r\n*(__le16*)skb_put(dst, sizeof(u16)) = cpu_to_le16(\r\nieee80211chan2mhz(priv->channel));\r\nif (priv->channel > 14)\r\n*(__le16*)skb_put(dst, sizeof(u16)) =\r\ncpu_to_le16(IEEE80211_CHAN_OFDM |\r\nIEEE80211_CHAN_5GHZ);\r\nelse if (priv->ieee->mode == IEEE_B)\r\n*(__le16*)skb_put(dst, sizeof(u16)) =\r\ncpu_to_le16(IEEE80211_CHAN_CCK |\r\nIEEE80211_CHAN_2GHZ);\r\nelse\r\n*(__le16*)skb_put(dst, sizeof(u16)) =\r\ncpu_to_le16(IEEE80211_CHAN_OFDM |\r\nIEEE80211_CHAN_2GHZ);\r\nrt_hdr->it_len = cpu_to_le16(dst->len);\r\nskb_copy_from_linear_data(src, skb_put(dst, len), len);\r\nif (!libipw_rx(priv->prom_priv->ieee, dst, &dummystats))\r\ndev_kfree_skb_any(dst);\r\n}\r\n}\r\nstatic netdev_tx_t ipw_net_hard_start_xmit(struct libipw_txb *txb,\r\nstruct net_device *dev, int pri)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nunsigned long flags;\r\nnetdev_tx_t ret;\r\nIPW_DEBUG_TX("dev->xmit(%d bytes)\n", txb->payload_size);\r\nspin_lock_irqsave(&priv->lock, flags);\r\n#ifdef CONFIG_IPW2200_PROMISCUOUS\r\nif (rtap_iface && netif_running(priv->prom_net_dev))\r\nipw_handle_promiscuous_tx(priv, txb);\r\n#endif\r\nret = ipw_tx_skb(priv, txb, pri);\r\nif (ret == NETDEV_TX_OK)\r\n__ipw_led_activity_on(priv);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void ipw_net_set_multicast_list(struct net_device *dev)\r\n{\r\n}\r\nstatic int ipw_net_set_mac_address(struct net_device *dev, void *p)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nstruct sockaddr *addr = p;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmutex_lock(&priv->mutex);\r\npriv->config |= CFG_CUSTOM_MAC;\r\nmemcpy(priv->mac_addr, addr->sa_data, ETH_ALEN);\r\nprintk(KERN_INFO "%s: Setting MAC to %pM\n",\r\npriv->net_dev->name, priv->mac_addr);\r\nschedule_work(&priv->adapter_restart);\r\nmutex_unlock(&priv->mutex);\r\nreturn 0;\r\n}\r\nstatic void ipw_ethtool_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct ipw_priv *p = libipw_priv(dev);\r\nchar vers[64];\r\nchar date[32];\r\nu32 len;\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nlen = sizeof(vers);\r\nipw_get_ordinal(p, IPW_ORD_STAT_FW_VERSION, vers, &len);\r\nlen = sizeof(date);\r\nipw_get_ordinal(p, IPW_ORD_STAT_FW_DATE, date, &len);\r\nsnprintf(info->fw_version, sizeof(info->fw_version), "%s (%s)",\r\nvers, date);\r\nstrlcpy(info->bus_info, pci_name(p->pci_dev),\r\nsizeof(info->bus_info));\r\ninfo->eedump_len = IPW_EEPROM_IMAGE_SIZE;\r\n}\r\nstatic u32 ipw_ethtool_get_link(struct net_device *dev)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nreturn (priv->status & STATUS_ASSOCIATED) != 0;\r\n}\r\nstatic int ipw_ethtool_get_eeprom_len(struct net_device *dev)\r\n{\r\nreturn IPW_EEPROM_IMAGE_SIZE;\r\n}\r\nstatic int ipw_ethtool_get_eeprom(struct net_device *dev,\r\nstruct ethtool_eeprom *eeprom, u8 * bytes)\r\n{\r\nstruct ipw_priv *p = libipw_priv(dev);\r\nif (eeprom->offset + eeprom->len > IPW_EEPROM_IMAGE_SIZE)\r\nreturn -EINVAL;\r\nmutex_lock(&p->mutex);\r\nmemcpy(bytes, &p->eeprom[eeprom->offset], eeprom->len);\r\nmutex_unlock(&p->mutex);\r\nreturn 0;\r\n}\r\nstatic int ipw_ethtool_set_eeprom(struct net_device *dev,\r\nstruct ethtool_eeprom *eeprom, u8 * bytes)\r\n{\r\nstruct ipw_priv *p = libipw_priv(dev);\r\nint i;\r\nif (eeprom->offset + eeprom->len > IPW_EEPROM_IMAGE_SIZE)\r\nreturn -EINVAL;\r\nmutex_lock(&p->mutex);\r\nmemcpy(&p->eeprom[eeprom->offset], bytes, eeprom->len);\r\nfor (i = 0; i < IPW_EEPROM_IMAGE_SIZE; i++)\r\nipw_write8(p, i + IPW_EEPROM_DATA, p->eeprom[i]);\r\nmutex_unlock(&p->mutex);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t ipw_isr(int irq, void *data)\r\n{\r\nstruct ipw_priv *priv = data;\r\nu32 inta, inta_mask;\r\nif (!priv)\r\nreturn IRQ_NONE;\r\nspin_lock(&priv->irq_lock);\r\nif (!(priv->status & STATUS_INT_ENABLED)) {\r\ngoto none;\r\n}\r\ninta = ipw_read32(priv, IPW_INTA_RW);\r\ninta_mask = ipw_read32(priv, IPW_INTA_MASK_R);\r\nif (inta == 0xFFFFFFFF) {\r\nIPW_WARNING("IRQ INTA == 0xFFFFFFFF\n");\r\ngoto none;\r\n}\r\nif (!(inta & (IPW_INTA_MASK_ALL & inta_mask))) {\r\ngoto none;\r\n}\r\n__ipw_disable_interrupts(priv);\r\ninta &= (IPW_INTA_MASK_ALL & inta_mask);\r\nipw_write32(priv, IPW_INTA_RW, inta);\r\npriv->isr_inta = inta;\r\ntasklet_schedule(&priv->irq_tasklet);\r\nspin_unlock(&priv->irq_lock);\r\nreturn IRQ_HANDLED;\r\nnone:\r\nspin_unlock(&priv->irq_lock);\r\nreturn IRQ_NONE;\r\n}\r\nstatic void ipw_rf_kill(void *adapter)\r\n{\r\nstruct ipw_priv *priv = adapter;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (rf_kill_active(priv)) {\r\nIPW_DEBUG_RF_KILL("RF Kill active, rescheduling GPIO check\n");\r\nschedule_delayed_work(&priv->rf_kill, 2 * HZ);\r\ngoto exit_unlock;\r\n}\r\nif (!(priv->status & STATUS_RF_KILL_MASK)) {\r\nIPW_DEBUG_RF_KILL("HW RF Kill no longer active, restarting "\r\n"device\n");\r\nschedule_work(&priv->adapter_restart);\r\n} else\r\nIPW_DEBUG_RF_KILL("HW RF Kill deactivated. SW RF Kill still "\r\n"enabled\n");\r\nexit_unlock:\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic void ipw_bg_rf_kill(struct work_struct *work)\r\n{\r\nstruct ipw_priv *priv =\r\ncontainer_of(work, struct ipw_priv, rf_kill.work);\r\nmutex_lock(&priv->mutex);\r\nipw_rf_kill(priv);\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic void ipw_link_up(struct ipw_priv *priv)\r\n{\r\npriv->last_seq_num = -1;\r\npriv->last_frag_num = -1;\r\npriv->last_packet_time = 0;\r\nnetif_carrier_on(priv->net_dev);\r\ncancel_delayed_work(&priv->request_scan);\r\ncancel_delayed_work(&priv->request_direct_scan);\r\ncancel_delayed_work(&priv->request_passive_scan);\r\ncancel_delayed_work(&priv->scan_event);\r\nipw_reset_stats(priv);\r\npriv->last_rate = ipw_get_current_rate(priv);\r\nipw_gather_stats(priv);\r\nipw_led_link_up(priv);\r\nnotify_wx_assoc_event(priv);\r\nif (priv->config & CFG_BACKGROUND_SCAN)\r\nschedule_delayed_work(&priv->request_scan, HZ);\r\n}\r\nstatic void ipw_bg_link_up(struct work_struct *work)\r\n{\r\nstruct ipw_priv *priv =\r\ncontainer_of(work, struct ipw_priv, link_up);\r\nmutex_lock(&priv->mutex);\r\nipw_link_up(priv);\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic void ipw_link_down(struct ipw_priv *priv)\r\n{\r\nipw_led_link_down(priv);\r\nnetif_carrier_off(priv->net_dev);\r\nnotify_wx_assoc_event(priv);\r\ncancel_delayed_work(&priv->request_scan);\r\ncancel_delayed_work(&priv->request_direct_scan);\r\ncancel_delayed_work(&priv->request_passive_scan);\r\ncancel_delayed_work(&priv->adhoc_check);\r\ncancel_delayed_work(&priv->gather_stats);\r\nipw_reset_stats(priv);\r\nif (!(priv->status & STATUS_EXIT_PENDING)) {\r\nschedule_delayed_work(&priv->request_scan, 0);\r\n} else\r\ncancel_delayed_work(&priv->scan_event);\r\n}\r\nstatic void ipw_bg_link_down(struct work_struct *work)\r\n{\r\nstruct ipw_priv *priv =\r\ncontainer_of(work, struct ipw_priv, link_down);\r\nmutex_lock(&priv->mutex);\r\nipw_link_down(priv);\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic int ipw_setup_deferred_work(struct ipw_priv *priv)\r\n{\r\nint ret = 0;\r\ninit_waitqueue_head(&priv->wait_command_queue);\r\ninit_waitqueue_head(&priv->wait_state);\r\nINIT_DELAYED_WORK(&priv->adhoc_check, ipw_bg_adhoc_check);\r\nINIT_WORK(&priv->associate, ipw_bg_associate);\r\nINIT_WORK(&priv->disassociate, ipw_bg_disassociate);\r\nINIT_WORK(&priv->system_config, ipw_system_config);\r\nINIT_WORK(&priv->rx_replenish, ipw_bg_rx_queue_replenish);\r\nINIT_WORK(&priv->adapter_restart, ipw_bg_adapter_restart);\r\nINIT_DELAYED_WORK(&priv->rf_kill, ipw_bg_rf_kill);\r\nINIT_WORK(&priv->up, ipw_bg_up);\r\nINIT_WORK(&priv->down, ipw_bg_down);\r\nINIT_DELAYED_WORK(&priv->request_scan, ipw_request_scan);\r\nINIT_DELAYED_WORK(&priv->request_direct_scan, ipw_request_direct_scan);\r\nINIT_DELAYED_WORK(&priv->request_passive_scan, ipw_request_passive_scan);\r\nINIT_DELAYED_WORK(&priv->scan_event, ipw_scan_event);\r\nINIT_DELAYED_WORK(&priv->gather_stats, ipw_bg_gather_stats);\r\nINIT_WORK(&priv->abort_scan, ipw_bg_abort_scan);\r\nINIT_WORK(&priv->roam, ipw_bg_roam);\r\nINIT_DELAYED_WORK(&priv->scan_check, ipw_bg_scan_check);\r\nINIT_WORK(&priv->link_up, ipw_bg_link_up);\r\nINIT_WORK(&priv->link_down, ipw_bg_link_down);\r\nINIT_DELAYED_WORK(&priv->led_link_on, ipw_bg_led_link_on);\r\nINIT_DELAYED_WORK(&priv->led_link_off, ipw_bg_led_link_off);\r\nINIT_DELAYED_WORK(&priv->led_act_off, ipw_bg_led_activity_off);\r\nINIT_WORK(&priv->merge_networks, ipw_merge_adhoc_network);\r\n#ifdef CONFIG_IPW2200_QOS\r\nINIT_WORK(&priv->qos_activate, ipw_bg_qos_activate);\r\n#endif\r\ntasklet_init(&priv->irq_tasklet, (void (*)(unsigned long))\r\nipw_irq_tasklet, (unsigned long)priv);\r\nreturn ret;\r\n}\r\nstatic void shim__set_security(struct net_device *dev,\r\nstruct libipw_security *sec)\r\n{\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nint i;\r\nfor (i = 0; i < 4; i++) {\r\nif (sec->flags & (1 << i)) {\r\npriv->ieee->sec.encode_alg[i] = sec->encode_alg[i];\r\npriv->ieee->sec.key_sizes[i] = sec->key_sizes[i];\r\nif (sec->key_sizes[i] == 0)\r\npriv->ieee->sec.flags &= ~(1 << i);\r\nelse {\r\nmemcpy(priv->ieee->sec.keys[i], sec->keys[i],\r\nsec->key_sizes[i]);\r\npriv->ieee->sec.flags |= (1 << i);\r\n}\r\npriv->status |= STATUS_SECURITY_UPDATED;\r\n} else if (sec->level != SEC_LEVEL_1)\r\npriv->ieee->sec.flags &= ~(1 << i);\r\n}\r\nif (sec->flags & SEC_ACTIVE_KEY) {\r\nif (sec->active_key <= 3) {\r\npriv->ieee->sec.active_key = sec->active_key;\r\npriv->ieee->sec.flags |= SEC_ACTIVE_KEY;\r\n} else\r\npriv->ieee->sec.flags &= ~SEC_ACTIVE_KEY;\r\npriv->status |= STATUS_SECURITY_UPDATED;\r\n} else\r\npriv->ieee->sec.flags &= ~SEC_ACTIVE_KEY;\r\nif ((sec->flags & SEC_AUTH_MODE) &&\r\n(priv->ieee->sec.auth_mode != sec->auth_mode)) {\r\npriv->ieee->sec.auth_mode = sec->auth_mode;\r\npriv->ieee->sec.flags |= SEC_AUTH_MODE;\r\nif (sec->auth_mode == WLAN_AUTH_SHARED_KEY)\r\npriv->capability |= CAP_SHARED_KEY;\r\nelse\r\npriv->capability &= ~CAP_SHARED_KEY;\r\npriv->status |= STATUS_SECURITY_UPDATED;\r\n}\r\nif (sec->flags & SEC_ENABLED && priv->ieee->sec.enabled != sec->enabled) {\r\npriv->ieee->sec.flags |= SEC_ENABLED;\r\npriv->ieee->sec.enabled = sec->enabled;\r\npriv->status |= STATUS_SECURITY_UPDATED;\r\nif (sec->enabled)\r\npriv->capability |= CAP_PRIVACY_ON;\r\nelse\r\npriv->capability &= ~CAP_PRIVACY_ON;\r\n}\r\nif (sec->flags & SEC_ENCRYPT)\r\npriv->ieee->sec.encrypt = sec->encrypt;\r\nif (sec->flags & SEC_LEVEL && priv->ieee->sec.level != sec->level) {\r\npriv->ieee->sec.level = sec->level;\r\npriv->ieee->sec.flags |= SEC_LEVEL;\r\npriv->status |= STATUS_SECURITY_UPDATED;\r\n}\r\nif (!priv->ieee->host_encrypt && (sec->flags & SEC_ENCRYPT))\r\nipw_set_hwcrypto_keys(priv);\r\n#if 0\r\nif ((priv->status & (STATUS_ASSOCIATED | STATUS_ASSOCIATING)) &&\r\n(((priv->assoc_request.capability &\r\ncpu_to_le16(WLAN_CAPABILITY_PRIVACY)) && !sec->enabled) ||\r\n(!(priv->assoc_request.capability &\r\ncpu_to_le16(WLAN_CAPABILITY_PRIVACY)) && sec->enabled))) {\r\nIPW_DEBUG_ASSOC("Disassociating due to capability "\r\n"change.\n");\r\nipw_disassociate(priv);\r\n}\r\n#endif\r\n}\r\nstatic int init_supported_rates(struct ipw_priv *priv,\r\nstruct ipw_supported_rates *rates)\r\n{\r\nmemset(rates, 0, sizeof(*rates));\r\nswitch (priv->ieee->freq_band) {\r\ncase LIBIPW_52GHZ_BAND:\r\nrates->ieee_mode = IPW_A_MODE;\r\nrates->purpose = IPW_RATE_CAPABILITIES;\r\nipw_add_ofdm_scan_rates(rates, LIBIPW_CCK_MODULATION,\r\nLIBIPW_OFDM_DEFAULT_RATES_MASK);\r\nbreak;\r\ndefault:\r\nrates->ieee_mode = IPW_G_MODE;\r\nrates->purpose = IPW_RATE_CAPABILITIES;\r\nipw_add_cck_scan_rates(rates, LIBIPW_CCK_MODULATION,\r\nLIBIPW_CCK_DEFAULT_RATES_MASK);\r\nif (priv->ieee->modulation & LIBIPW_OFDM_MODULATION) {\r\nipw_add_ofdm_scan_rates(rates, LIBIPW_CCK_MODULATION,\r\nLIBIPW_OFDM_DEFAULT_RATES_MASK);\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ipw_config(struct ipw_priv *priv)\r\n{\r\nif (ipw_set_tx_power(priv))\r\ngoto error;\r\nif (ipw_send_adapter_address(priv, priv->net_dev->dev_addr))\r\ngoto error;\r\ninit_sys_config(&priv->sys_config);\r\nif (bt_coexist) {\r\nunsigned char bt_caps = priv->eeprom[EEPROM_SKU_CAPABILITY];\r\nif (bt_caps & EEPROM_SKU_CAP_BT_CHANNEL_SIG)\r\npriv->sys_config.bt_coexistence\r\n|= CFG_BT_COEXISTENCE_SIGNAL_CHNL;\r\nif (bt_caps & EEPROM_SKU_CAP_BT_OOB)\r\npriv->sys_config.bt_coexistence\r\n|= CFG_BT_COEXISTENCE_OOB;\r\n}\r\n#ifdef CONFIG_IPW2200_PROMISCUOUS\r\nif (priv->prom_net_dev && netif_running(priv->prom_net_dev)) {\r\npriv->sys_config.accept_all_data_frames = 1;\r\npriv->sys_config.accept_non_directed_frames = 1;\r\npriv->sys_config.accept_all_mgmt_bcpr = 1;\r\npriv->sys_config.accept_all_mgmt_frames = 1;\r\n}\r\n#endif\r\nif (priv->ieee->iw_mode == IW_MODE_ADHOC)\r\npriv->sys_config.answer_broadcast_ssid_probe = 1;\r\nelse\r\npriv->sys_config.answer_broadcast_ssid_probe = 0;\r\nif (ipw_send_system_config(priv))\r\ngoto error;\r\ninit_supported_rates(priv, &priv->rates);\r\nif (ipw_send_supported_rates(priv, &priv->rates))\r\ngoto error;\r\nif (priv->rts_threshold) {\r\nif (ipw_send_rts_threshold(priv, priv->rts_threshold))\r\ngoto error;\r\n}\r\n#ifdef CONFIG_IPW2200_QOS\r\nIPW_DEBUG_QOS("QoS: call ipw_qos_activate\n");\r\nipw_qos_activate(priv, NULL);\r\n#endif\r\nif (ipw_set_random_seed(priv))\r\ngoto error;\r\nif (ipw_send_host_complete(priv))\r\ngoto error;\r\npriv->status |= STATUS_INIT;\r\nipw_led_init(priv);\r\nipw_led_radio_on(priv);\r\npriv->notif_missed_beacons = 0;\r\nif ((priv->capability & CAP_PRIVACY_ON) &&\r\n(priv->ieee->sec.level == SEC_LEVEL_1) &&\r\n!(priv->ieee->host_encrypt || priv->ieee->host_decrypt))\r\nipw_set_hwcrypto_keys(priv);\r\nreturn 0;\r\nerror:\r\nreturn -EIO;\r\n}\r\nstatic void ipw_set_geo(struct ipw_priv *priv)\r\n{\r\nint j;\r\nfor (j = 0; j < ARRAY_SIZE(ipw_geos); j++) {\r\nif (!memcmp(&priv->eeprom[EEPROM_COUNTRY_CODE],\r\nipw_geos[j].name, 3))\r\nbreak;\r\n}\r\nif (j == ARRAY_SIZE(ipw_geos)) {\r\nIPW_WARNING("SKU [%c%c%c] not recognized.\n",\r\npriv->eeprom[EEPROM_COUNTRY_CODE + 0],\r\npriv->eeprom[EEPROM_COUNTRY_CODE + 1],\r\npriv->eeprom[EEPROM_COUNTRY_CODE + 2]);\r\nj = 0;\r\n}\r\nlibipw_set_geo(priv->ieee, &ipw_geos[j]);\r\n}\r\nstatic int ipw_up(struct ipw_priv *priv)\r\n{\r\nint rc, i;\r\nif (priv->suspend_time) {\r\nlibipw_networks_age(priv->ieee, priv->suspend_time);\r\npriv->suspend_time = 0;\r\n}\r\nif (priv->status & STATUS_EXIT_PENDING)\r\nreturn -EIO;\r\nif (cmdlog && !priv->cmdlog) {\r\npriv->cmdlog = kcalloc(cmdlog, sizeof(*priv->cmdlog),\r\nGFP_KERNEL);\r\nif (priv->cmdlog == NULL) {\r\nIPW_ERROR("Error allocating %d command log entries.\n",\r\ncmdlog);\r\nreturn -ENOMEM;\r\n} else {\r\npriv->cmdlog_len = cmdlog;\r\n}\r\n}\r\nfor (i = 0; i < MAX_HW_RESTARTS; i++) {\r\nrc = ipw_load(priv);\r\nif (rc) {\r\nIPW_ERROR("Unable to load firmware: %d\n", rc);\r\nreturn rc;\r\n}\r\nipw_init_ordinals(priv);\r\nif (!(priv->config & CFG_CUSTOM_MAC))\r\neeprom_parse_mac(priv, priv->mac_addr);\r\nmemcpy(priv->net_dev->dev_addr, priv->mac_addr, ETH_ALEN);\r\nipw_set_geo(priv);\r\nif (priv->status & STATUS_RF_KILL_SW) {\r\nIPW_WARNING("Radio disabled by module parameter.\n");\r\nreturn 0;\r\n} else if (rf_kill_active(priv)) {\r\nIPW_WARNING("Radio Frequency Kill Switch is On:\n"\r\n"Kill switch must be turned off for "\r\n"wireless networking to work.\n");\r\nschedule_delayed_work(&priv->rf_kill, 2 * HZ);\r\nreturn 0;\r\n}\r\nrc = ipw_config(priv);\r\nif (!rc) {\r\nIPW_DEBUG_INFO("Configured device on count %i\n", i);\r\nschedule_delayed_work(&priv->request_scan, 0);\r\nreturn 0;\r\n}\r\nIPW_DEBUG_INFO("Device configuration failed: 0x%08X\n", rc);\r\nIPW_DEBUG_INFO("Failed to config device on retry %d of %d\n",\r\ni, MAX_HW_RESTARTS);\r\nipw_down(priv);\r\n}\r\nIPW_ERROR("Unable to initialize device after %d attempts.\n", i);\r\nreturn -EIO;\r\n}\r\nstatic void ipw_bg_up(struct work_struct *work)\r\n{\r\nstruct ipw_priv *priv =\r\ncontainer_of(work, struct ipw_priv, up);\r\nmutex_lock(&priv->mutex);\r\nipw_up(priv);\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic void ipw_deinit(struct ipw_priv *priv)\r\n{\r\nint i;\r\nif (priv->status & STATUS_SCANNING) {\r\nIPW_DEBUG_INFO("Aborting scan during shutdown.\n");\r\nipw_abort_scan(priv);\r\n}\r\nif (priv->status & STATUS_ASSOCIATED) {\r\nIPW_DEBUG_INFO("Disassociating during shutdown.\n");\r\nipw_disassociate(priv);\r\n}\r\nipw_led_shutdown(priv);\r\nfor (i = 1000; i && (priv->status &\r\n(STATUS_DISASSOCIATING |\r\nSTATUS_ASSOCIATED | STATUS_SCANNING)); i--)\r\nudelay(10);\r\nif (priv->status & (STATUS_DISASSOCIATING |\r\nSTATUS_ASSOCIATED | STATUS_SCANNING))\r\nIPW_DEBUG_INFO("Still associated or scanning...\n");\r\nelse\r\nIPW_DEBUG_INFO("Took %dms to de-init\n", 1000 - i);\r\nipw_send_card_disable(priv, 0);\r\npriv->status &= ~STATUS_INIT;\r\n}\r\nstatic void ipw_down(struct ipw_priv *priv)\r\n{\r\nint exit_pending = priv->status & STATUS_EXIT_PENDING;\r\npriv->status |= STATUS_EXIT_PENDING;\r\nif (ipw_is_init(priv))\r\nipw_deinit(priv);\r\nif (!exit_pending)\r\npriv->status &= ~STATUS_EXIT_PENDING;\r\nipw_disable_interrupts(priv);\r\npriv->status &= STATUS_RF_KILL_MASK | STATUS_EXIT_PENDING;\r\nnetif_carrier_off(priv->net_dev);\r\nipw_stop_nic(priv);\r\nipw_led_radio_off(priv);\r\n}\r\nstatic void ipw_bg_down(struct work_struct *work)\r\n{\r\nstruct ipw_priv *priv =\r\ncontainer_of(work, struct ipw_priv, down);\r\nmutex_lock(&priv->mutex);\r\nipw_down(priv);\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic int ipw_wdev_init(struct net_device *dev)\r\n{\r\nint i, rc = 0;\r\nstruct ipw_priv *priv = libipw_priv(dev);\r\nconst struct libipw_geo *geo = libipw_get_geo(priv->ieee);\r\nstruct wireless_dev *wdev = &priv->ieee->wdev;\r\nmemcpy(wdev->wiphy->perm_addr, priv->mac_addr, ETH_ALEN);\r\nif (geo->bg_channels) {\r\nstruct ieee80211_supported_band *bg_band = &priv->ieee->bg_band;\r\nbg_band->band = IEEE80211_BAND_2GHZ;\r\nbg_band->n_channels = geo->bg_channels;\r\nbg_band->channels = kcalloc(geo->bg_channels,\r\nsizeof(struct ieee80211_channel),\r\nGFP_KERNEL);\r\nif (!bg_band->channels) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nfor (i = 0; i < geo->bg_channels; i++) {\r\nbg_band->channels[i].band = IEEE80211_BAND_2GHZ;\r\nbg_band->channels[i].center_freq = geo->bg[i].freq;\r\nbg_band->channels[i].hw_value = geo->bg[i].channel;\r\nbg_band->channels[i].max_power = geo->bg[i].max_power;\r\nif (geo->bg[i].flags & LIBIPW_CH_PASSIVE_ONLY)\r\nbg_band->channels[i].flags |=\r\nIEEE80211_CHAN_NO_IR;\r\nif (geo->bg[i].flags & LIBIPW_CH_NO_IBSS)\r\nbg_band->channels[i].flags |=\r\nIEEE80211_CHAN_NO_IR;\r\nif (geo->bg[i].flags & LIBIPW_CH_RADAR_DETECT)\r\nbg_band->channels[i].flags |=\r\nIEEE80211_CHAN_RADAR;\r\n}\r\nbg_band->bitrates = ipw2200_bg_rates;\r\nbg_band->n_bitrates = ipw2200_num_bg_rates;\r\nwdev->wiphy->bands[IEEE80211_BAND_2GHZ] = bg_band;\r\n}\r\nif (geo->a_channels) {\r\nstruct ieee80211_supported_band *a_band = &priv->ieee->a_band;\r\na_band->band = IEEE80211_BAND_5GHZ;\r\na_band->n_channels = geo->a_channels;\r\na_band->channels = kcalloc(geo->a_channels,\r\nsizeof(struct ieee80211_channel),\r\nGFP_KERNEL);\r\nif (!a_band->channels) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nfor (i = 0; i < geo->a_channels; i++) {\r\na_band->channels[i].band = IEEE80211_BAND_5GHZ;\r\na_band->channels[i].center_freq = geo->a[i].freq;\r\na_band->channels[i].hw_value = geo->a[i].channel;\r\na_band->channels[i].max_power = geo->a[i].max_power;\r\nif (geo->a[i].flags & LIBIPW_CH_PASSIVE_ONLY)\r\na_band->channels[i].flags |=\r\nIEEE80211_CHAN_NO_IR;\r\nif (geo->a[i].flags & LIBIPW_CH_NO_IBSS)\r\na_band->channels[i].flags |=\r\nIEEE80211_CHAN_NO_IR;\r\nif (geo->a[i].flags & LIBIPW_CH_RADAR_DETECT)\r\na_band->channels[i].flags |=\r\nIEEE80211_CHAN_RADAR;\r\n}\r\na_band->bitrates = ipw2200_a_rates;\r\na_band->n_bitrates = ipw2200_num_a_rates;\r\nwdev->wiphy->bands[IEEE80211_BAND_5GHZ] = a_band;\r\n}\r\nwdev->wiphy->cipher_suites = ipw_cipher_suites;\r\nwdev->wiphy->n_cipher_suites = ARRAY_SIZE(ipw_cipher_suites);\r\nset_wiphy_dev(wdev->wiphy, &priv->pci_dev->dev);\r\nif (wiphy_register(wdev->wiphy))\r\nrc = -EIO;\r\nout:\r\nreturn rc;\r\n}\r\nstatic int ipw_prom_open(struct net_device *dev)\r\n{\r\nstruct ipw_prom_priv *prom_priv = libipw_priv(dev);\r\nstruct ipw_priv *priv = prom_priv->priv;\r\nIPW_DEBUG_INFO("prom dev->open\n");\r\nnetif_carrier_off(dev);\r\nif (priv->ieee->iw_mode != IW_MODE_MONITOR) {\r\npriv->sys_config.accept_all_data_frames = 1;\r\npriv->sys_config.accept_non_directed_frames = 1;\r\npriv->sys_config.accept_all_mgmt_bcpr = 1;\r\npriv->sys_config.accept_all_mgmt_frames = 1;\r\nipw_send_system_config(priv);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ipw_prom_stop(struct net_device *dev)\r\n{\r\nstruct ipw_prom_priv *prom_priv = libipw_priv(dev);\r\nstruct ipw_priv *priv = prom_priv->priv;\r\nIPW_DEBUG_INFO("prom dev->stop\n");\r\nif (priv->ieee->iw_mode != IW_MODE_MONITOR) {\r\npriv->sys_config.accept_all_data_frames = 0;\r\npriv->sys_config.accept_non_directed_frames = 0;\r\npriv->sys_config.accept_all_mgmt_bcpr = 0;\r\npriv->sys_config.accept_all_mgmt_frames = 0;\r\nipw_send_system_config(priv);\r\n}\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t ipw_prom_hard_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nIPW_DEBUG_INFO("prom dev->xmit\n");\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int ipw_prom_alloc(struct ipw_priv *priv)\r\n{\r\nint rc = 0;\r\nif (priv->prom_net_dev)\r\nreturn -EPERM;\r\npriv->prom_net_dev = alloc_libipw(sizeof(struct ipw_prom_priv), 1);\r\nif (priv->prom_net_dev == NULL)\r\nreturn -ENOMEM;\r\npriv->prom_priv = libipw_priv(priv->prom_net_dev);\r\npriv->prom_priv->ieee = netdev_priv(priv->prom_net_dev);\r\npriv->prom_priv->priv = priv;\r\nstrcpy(priv->prom_net_dev->name, "rtap%d");\r\nmemcpy(priv->prom_net_dev->dev_addr, priv->mac_addr, ETH_ALEN);\r\npriv->prom_net_dev->type = ARPHRD_IEEE80211_RADIOTAP;\r\npriv->prom_net_dev->netdev_ops = &ipw_prom_netdev_ops;\r\npriv->prom_priv->ieee->iw_mode = IW_MODE_MONITOR;\r\nSET_NETDEV_DEV(priv->prom_net_dev, &priv->pci_dev->dev);\r\nrc = register_netdev(priv->prom_net_dev);\r\nif (rc) {\r\nfree_libipw(priv->prom_net_dev, 1);\r\npriv->prom_net_dev = NULL;\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ipw_prom_free(struct ipw_priv *priv)\r\n{\r\nif (!priv->prom_net_dev)\r\nreturn;\r\nunregister_netdev(priv->prom_net_dev);\r\nfree_libipw(priv->prom_net_dev, 1);\r\npriv->prom_net_dev = NULL;\r\n}\r\nstatic int ipw_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nint err = 0;\r\nstruct net_device *net_dev;\r\nvoid __iomem *base;\r\nu32 length, val;\r\nstruct ipw_priv *priv;\r\nint i;\r\nnet_dev = alloc_libipw(sizeof(struct ipw_priv), 0);\r\nif (net_dev == NULL) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\npriv = libipw_priv(net_dev);\r\npriv->ieee = netdev_priv(net_dev);\r\npriv->net_dev = net_dev;\r\npriv->pci_dev = pdev;\r\nipw_debug_level = debug;\r\nspin_lock_init(&priv->irq_lock);\r\nspin_lock_init(&priv->lock);\r\nfor (i = 0; i < IPW_IBSS_MAC_HASH_SIZE; i++)\r\nINIT_LIST_HEAD(&priv->ibss_mac_hash[i]);\r\nmutex_init(&priv->mutex);\r\nif (pci_enable_device(pdev)) {\r\nerr = -ENODEV;\r\ngoto out_free_libipw;\r\n}\r\npci_set_master(pdev);\r\nerr = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (!err)\r\nerr = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (err) {\r\nprintk(KERN_WARNING DRV_NAME ": No suitable DMA available.\n");\r\ngoto out_pci_disable_device;\r\n}\r\npci_set_drvdata(pdev, priv);\r\nerr = pci_request_regions(pdev, DRV_NAME);\r\nif (err)\r\ngoto out_pci_disable_device;\r\npci_read_config_dword(pdev, 0x40, &val);\r\nif ((val & 0x0000ff00) != 0)\r\npci_write_config_dword(pdev, 0x40, val & 0xffff00ff);\r\nlength = pci_resource_len(pdev, 0);\r\npriv->hw_len = length;\r\nbase = pci_ioremap_bar(pdev, 0);\r\nif (!base) {\r\nerr = -ENODEV;\r\ngoto out_pci_release_regions;\r\n}\r\npriv->hw_base = base;\r\nIPW_DEBUG_INFO("pci_resource_len = 0x%08x\n", length);\r\nIPW_DEBUG_INFO("pci_resource_base = %p\n", base);\r\nerr = ipw_setup_deferred_work(priv);\r\nif (err) {\r\nIPW_ERROR("Unable to setup deferred work\n");\r\ngoto out_iounmap;\r\n}\r\nipw_sw_reset(priv, 1);\r\nerr = request_irq(pdev->irq, ipw_isr, IRQF_SHARED, DRV_NAME, priv);\r\nif (err) {\r\nIPW_ERROR("Error allocating IRQ %d\n", pdev->irq);\r\ngoto out_iounmap;\r\n}\r\nSET_NETDEV_DEV(net_dev, &pdev->dev);\r\nmutex_lock(&priv->mutex);\r\npriv->ieee->hard_start_xmit = ipw_net_hard_start_xmit;\r\npriv->ieee->set_security = shim__set_security;\r\npriv->ieee->is_queue_full = ipw_net_is_queue_full;\r\n#ifdef CONFIG_IPW2200_QOS\r\npriv->ieee->is_qos_active = ipw_is_qos_active;\r\npriv->ieee->handle_probe_response = ipw_handle_beacon;\r\npriv->ieee->handle_beacon = ipw_handle_probe_response;\r\npriv->ieee->handle_assoc_response = ipw_handle_assoc_response;\r\n#endif\r\npriv->ieee->perfect_rssi = -20;\r\npriv->ieee->worst_rssi = -85;\r\nnet_dev->netdev_ops = &ipw_netdev_ops;\r\npriv->wireless_data.spy_data = &priv->ieee->spy_data;\r\nnet_dev->wireless_data = &priv->wireless_data;\r\nnet_dev->wireless_handlers = &ipw_wx_handler_def;\r\nnet_dev->ethtool_ops = &ipw_ethtool_ops;\r\nerr = sysfs_create_group(&pdev->dev.kobj, &ipw_attribute_group);\r\nif (err) {\r\nIPW_ERROR("failed to create sysfs device attributes\n");\r\nmutex_unlock(&priv->mutex);\r\ngoto out_release_irq;\r\n}\r\nif (ipw_up(priv)) {\r\nmutex_unlock(&priv->mutex);\r\nerr = -EIO;\r\ngoto out_remove_sysfs;\r\n}\r\nmutex_unlock(&priv->mutex);\r\nerr = ipw_wdev_init(net_dev);\r\nif (err) {\r\nIPW_ERROR("failed to register wireless device\n");\r\ngoto out_remove_sysfs;\r\n}\r\nerr = register_netdev(net_dev);\r\nif (err) {\r\nIPW_ERROR("failed to register network device\n");\r\ngoto out_unregister_wiphy;\r\n}\r\n#ifdef CONFIG_IPW2200_PROMISCUOUS\r\nif (rtap_iface) {\r\nerr = ipw_prom_alloc(priv);\r\nif (err) {\r\nIPW_ERROR("Failed to register promiscuous network "\r\n"device (error %d).\n", err);\r\nunregister_netdev(priv->net_dev);\r\ngoto out_unregister_wiphy;\r\n}\r\n}\r\n#endif\r\nprintk(KERN_INFO DRV_NAME ": Detected geography %s (%d 802.11bg "\r\n"channels, %d 802.11a channels)\n",\r\npriv->ieee->geo.name, priv->ieee->geo.bg_channels,\r\npriv->ieee->geo.a_channels);\r\nreturn 0;\r\nout_unregister_wiphy:\r\nwiphy_unregister(priv->ieee->wdev.wiphy);\r\nkfree(priv->ieee->a_band.channels);\r\nkfree(priv->ieee->bg_band.channels);\r\nout_remove_sysfs:\r\nsysfs_remove_group(&pdev->dev.kobj, &ipw_attribute_group);\r\nout_release_irq:\r\nfree_irq(pdev->irq, priv);\r\nout_iounmap:\r\niounmap(priv->hw_base);\r\nout_pci_release_regions:\r\npci_release_regions(pdev);\r\nout_pci_disable_device:\r\npci_disable_device(pdev);\r\nout_free_libipw:\r\nfree_libipw(priv->net_dev, 0);\r\nout:\r\nreturn err;\r\n}\r\nstatic void ipw_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct ipw_priv *priv = pci_get_drvdata(pdev);\r\nstruct list_head *p, *q;\r\nint i;\r\nif (!priv)\r\nreturn;\r\nmutex_lock(&priv->mutex);\r\npriv->status |= STATUS_EXIT_PENDING;\r\nipw_down(priv);\r\nsysfs_remove_group(&pdev->dev.kobj, &ipw_attribute_group);\r\nmutex_unlock(&priv->mutex);\r\nunregister_netdev(priv->net_dev);\r\nif (priv->rxq) {\r\nipw_rx_queue_free(priv, priv->rxq);\r\npriv->rxq = NULL;\r\n}\r\nipw_tx_queue_free(priv);\r\nif (priv->cmdlog) {\r\nkfree(priv->cmdlog);\r\npriv->cmdlog = NULL;\r\n}\r\ncancel_delayed_work_sync(&priv->adhoc_check);\r\ncancel_work_sync(&priv->associate);\r\ncancel_work_sync(&priv->disassociate);\r\ncancel_work_sync(&priv->system_config);\r\ncancel_work_sync(&priv->rx_replenish);\r\ncancel_work_sync(&priv->adapter_restart);\r\ncancel_delayed_work_sync(&priv->rf_kill);\r\ncancel_work_sync(&priv->up);\r\ncancel_work_sync(&priv->down);\r\ncancel_delayed_work_sync(&priv->request_scan);\r\ncancel_delayed_work_sync(&priv->request_direct_scan);\r\ncancel_delayed_work_sync(&priv->request_passive_scan);\r\ncancel_delayed_work_sync(&priv->scan_event);\r\ncancel_delayed_work_sync(&priv->gather_stats);\r\ncancel_work_sync(&priv->abort_scan);\r\ncancel_work_sync(&priv->roam);\r\ncancel_delayed_work_sync(&priv->scan_check);\r\ncancel_work_sync(&priv->link_up);\r\ncancel_work_sync(&priv->link_down);\r\ncancel_delayed_work_sync(&priv->led_link_on);\r\ncancel_delayed_work_sync(&priv->led_link_off);\r\ncancel_delayed_work_sync(&priv->led_act_off);\r\ncancel_work_sync(&priv->merge_networks);\r\nfor (i = 0; i < IPW_IBSS_MAC_HASH_SIZE; i++) {\r\nlist_for_each_safe(p, q, &priv->ibss_mac_hash[i]) {\r\nlist_del(p);\r\nkfree(list_entry(p, struct ipw_ibss_seq, list));\r\n}\r\n}\r\nkfree(priv->error);\r\npriv->error = NULL;\r\n#ifdef CONFIG_IPW2200_PROMISCUOUS\r\nipw_prom_free(priv);\r\n#endif\r\nfree_irq(pdev->irq, priv);\r\niounmap(priv->hw_base);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nwiphy_unregister(priv->ieee->wdev.wiphy);\r\nkfree(priv->ieee->a_band.channels);\r\nkfree(priv->ieee->bg_band.channels);\r\nfree_libipw(priv->net_dev, 0);\r\nfree_firmware();\r\n}\r\nstatic int ipw_pci_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct ipw_priv *priv = pci_get_drvdata(pdev);\r\nstruct net_device *dev = priv->net_dev;\r\nprintk(KERN_INFO "%s: Going into suspend...\n", dev->name);\r\nipw_down(priv);\r\nnetif_device_detach(dev);\r\npci_save_state(pdev);\r\npci_disable_device(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\npriv->suspend_at = get_seconds();\r\nreturn 0;\r\n}\r\nstatic int ipw_pci_resume(struct pci_dev *pdev)\r\n{\r\nstruct ipw_priv *priv = pci_get_drvdata(pdev);\r\nstruct net_device *dev = priv->net_dev;\r\nint err;\r\nu32 val;\r\nprintk(KERN_INFO "%s: Coming out of suspend...\n", dev->name);\r\npci_set_power_state(pdev, PCI_D0);\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\nprintk(KERN_ERR "%s: pci_enable_device failed on resume\n",\r\ndev->name);\r\nreturn err;\r\n}\r\npci_restore_state(pdev);\r\npci_read_config_dword(pdev, 0x40, &val);\r\nif ((val & 0x0000ff00) != 0)\r\npci_write_config_dword(pdev, 0x40, val & 0xffff00ff);\r\nnetif_device_attach(dev);\r\npriv->suspend_time = get_seconds() - priv->suspend_at;\r\nschedule_work(&priv->up);\r\nreturn 0;\r\n}\r\nstatic void ipw_pci_shutdown(struct pci_dev *pdev)\r\n{\r\nstruct ipw_priv *priv = pci_get_drvdata(pdev);\r\nipw_down(priv);\r\npci_disable_device(pdev);\r\n}\r\nstatic int __init ipw_init(void)\r\n{\r\nint ret;\r\nprintk(KERN_INFO DRV_NAME ": " DRV_DESCRIPTION ", " DRV_VERSION "\n");\r\nprintk(KERN_INFO DRV_NAME ": " DRV_COPYRIGHT "\n");\r\nret = pci_register_driver(&ipw_driver);\r\nif (ret) {\r\nIPW_ERROR("Unable to initialize PCI module\n");\r\nreturn ret;\r\n}\r\nret = driver_create_file(&ipw_driver.driver, &driver_attr_debug_level);\r\nif (ret) {\r\nIPW_ERROR("Unable to create driver sysfs file\n");\r\npci_unregister_driver(&ipw_driver);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit ipw_exit(void)\r\n{\r\ndriver_remove_file(&ipw_driver.driver, &driver_attr_debug_level);\r\npci_unregister_driver(&ipw_driver);\r\n}
