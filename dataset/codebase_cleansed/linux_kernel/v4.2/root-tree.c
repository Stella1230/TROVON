static void btrfs_read_root_item(struct extent_buffer *eb, int slot,\r\nstruct btrfs_root_item *item)\r\n{\r\nuuid_le uuid;\r\nint len;\r\nint need_reset = 0;\r\nlen = btrfs_item_size_nr(eb, slot);\r\nread_extent_buffer(eb, item, btrfs_item_ptr_offset(eb, slot),\r\nmin_t(int, len, (int)sizeof(*item)));\r\nif (len < sizeof(*item))\r\nneed_reset = 1;\r\nif (!need_reset && btrfs_root_generation(item)\r\n!= btrfs_root_generation_v2(item)) {\r\nif (btrfs_root_generation_v2(item) != 0) {\r\nprintk(KERN_WARNING "BTRFS: mismatching "\r\n"generation and generation_v2 "\r\n"found in root item. This root "\r\n"was probably mounted with an "\r\n"older kernel. Resetting all "\r\n"new fields.\n");\r\n}\r\nneed_reset = 1;\r\n}\r\nif (need_reset) {\r\nmemset(&item->generation_v2, 0,\r\nsizeof(*item) - offsetof(struct btrfs_root_item,\r\ngeneration_v2));\r\nuuid_le_gen(&uuid);\r\nmemcpy(item->uuid, uuid.b, BTRFS_UUID_SIZE);\r\n}\r\n}\r\nint btrfs_find_root(struct btrfs_root *root, struct btrfs_key *search_key,\r\nstruct btrfs_path *path, struct btrfs_root_item *root_item,\r\nstruct btrfs_key *root_key)\r\n{\r\nstruct btrfs_key found_key;\r\nstruct extent_buffer *l;\r\nint ret;\r\nint slot;\r\nret = btrfs_search_slot(NULL, root, search_key, path, 0, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nif (search_key->offset != -1ULL) {\r\nif (ret > 0)\r\ngoto out;\r\n} else {\r\nBUG_ON(ret == 0);\r\nif (path->slots[0] == 0)\r\ngoto out;\r\npath->slots[0]--;\r\nret = 0;\r\n}\r\nl = path->nodes[0];\r\nslot = path->slots[0];\r\nbtrfs_item_key_to_cpu(l, &found_key, slot);\r\nif (found_key.objectid != search_key->objectid ||\r\nfound_key.type != BTRFS_ROOT_ITEM_KEY) {\r\nret = 1;\r\ngoto out;\r\n}\r\nif (root_item)\r\nbtrfs_read_root_item(l, slot, root_item);\r\nif (root_key)\r\nmemcpy(root_key, &found_key, sizeof(found_key));\r\nout:\r\nbtrfs_release_path(path);\r\nreturn ret;\r\n}\r\nvoid btrfs_set_root_node(struct btrfs_root_item *item,\r\nstruct extent_buffer *node)\r\n{\r\nbtrfs_set_root_bytenr(item, node->start);\r\nbtrfs_set_root_level(item, btrfs_header_level(node));\r\nbtrfs_set_root_generation(item, btrfs_header_generation(node));\r\n}\r\nint btrfs_update_root(struct btrfs_trans_handle *trans, struct btrfs_root\r\n*root, struct btrfs_key *key, struct btrfs_root_item\r\n*item)\r\n{\r\nstruct btrfs_path *path;\r\nstruct extent_buffer *l;\r\nint ret;\r\nint slot;\r\nunsigned long ptr;\r\nint old_len;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nret = btrfs_search_slot(trans, root, key, path, 0, 1);\r\nif (ret < 0) {\r\nbtrfs_abort_transaction(trans, root, ret);\r\ngoto out;\r\n}\r\nif (ret != 0) {\r\nbtrfs_print_leaf(root, path->nodes[0]);\r\nbtrfs_crit(root->fs_info, "unable to update root key %llu %u %llu",\r\nkey->objectid, key->type, key->offset);\r\nBUG_ON(1);\r\n}\r\nl = path->nodes[0];\r\nslot = path->slots[0];\r\nptr = btrfs_item_ptr_offset(l, slot);\r\nold_len = btrfs_item_size_nr(l, slot);\r\nif (old_len < sizeof(*item)) {\r\nbtrfs_release_path(path);\r\nret = btrfs_search_slot(trans, root, key, path,\r\n-1, 1);\r\nif (ret < 0) {\r\nbtrfs_abort_transaction(trans, root, ret);\r\ngoto out;\r\n}\r\nret = btrfs_del_item(trans, root, path);\r\nif (ret < 0) {\r\nbtrfs_abort_transaction(trans, root, ret);\r\ngoto out;\r\n}\r\nbtrfs_release_path(path);\r\nret = btrfs_insert_empty_item(trans, root, path,\r\nkey, sizeof(*item));\r\nif (ret < 0) {\r\nbtrfs_abort_transaction(trans, root, ret);\r\ngoto out;\r\n}\r\nl = path->nodes[0];\r\nslot = path->slots[0];\r\nptr = btrfs_item_ptr_offset(l, slot);\r\n}\r\nbtrfs_set_root_generation_v2(item, btrfs_root_generation(item));\r\nwrite_extent_buffer(l, item, ptr, sizeof(*item));\r\nbtrfs_mark_buffer_dirty(path->nodes[0]);\r\nout:\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nint btrfs_insert_root(struct btrfs_trans_handle *trans, struct btrfs_root *root,\r\nstruct btrfs_key *key, struct btrfs_root_item *item)\r\n{\r\nbtrfs_set_root_generation_v2(item, btrfs_root_generation(item));\r\nreturn btrfs_insert_item(trans, root, key, item, sizeof(*item));\r\n}\r\nint btrfs_find_orphan_roots(struct btrfs_root *tree_root)\r\n{\r\nstruct extent_buffer *leaf;\r\nstruct btrfs_path *path;\r\nstruct btrfs_key key;\r\nstruct btrfs_key root_key;\r\nstruct btrfs_root *root;\r\nint err = 0;\r\nint ret;\r\nbool can_recover = true;\r\nif (tree_root->fs_info->sb->s_flags & MS_RDONLY)\r\ncan_recover = false;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nkey.objectid = BTRFS_ORPHAN_OBJECTID;\r\nkey.type = BTRFS_ORPHAN_ITEM_KEY;\r\nkey.offset = 0;\r\nroot_key.type = BTRFS_ROOT_ITEM_KEY;\r\nroot_key.offset = (u64)-1;\r\nwhile (1) {\r\nret = btrfs_search_slot(NULL, tree_root, &key, path, 0, 0);\r\nif (ret < 0) {\r\nerr = ret;\r\nbreak;\r\n}\r\nleaf = path->nodes[0];\r\nif (path->slots[0] >= btrfs_header_nritems(leaf)) {\r\nret = btrfs_next_leaf(tree_root, path);\r\nif (ret < 0)\r\nerr = ret;\r\nif (ret != 0)\r\nbreak;\r\nleaf = path->nodes[0];\r\n}\r\nbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\r\nbtrfs_release_path(path);\r\nif (key.objectid != BTRFS_ORPHAN_OBJECTID ||\r\nkey.type != BTRFS_ORPHAN_ITEM_KEY)\r\nbreak;\r\nroot_key.objectid = key.offset;\r\nkey.offset++;\r\nroot = btrfs_read_fs_root(tree_root, &root_key);\r\nerr = PTR_ERR_OR_ZERO(root);\r\nif (err && err != -ENOENT) {\r\nbreak;\r\n} else if (err == -ENOENT) {\r\nstruct btrfs_trans_handle *trans;\r\nbtrfs_release_path(path);\r\ntrans = btrfs_join_transaction(tree_root);\r\nif (IS_ERR(trans)) {\r\nerr = PTR_ERR(trans);\r\nbtrfs_error(tree_root->fs_info, err,\r\n"Failed to start trans to delete "\r\n"orphan item");\r\nbreak;\r\n}\r\nerr = btrfs_del_orphan_item(trans, tree_root,\r\nroot_key.objectid);\r\nbtrfs_end_transaction(trans, tree_root);\r\nif (err) {\r\nbtrfs_error(tree_root->fs_info, err,\r\n"Failed to delete root orphan "\r\n"item");\r\nbreak;\r\n}\r\ncontinue;\r\n}\r\nerr = btrfs_init_fs_root(root);\r\nif (err) {\r\nbtrfs_free_fs_root(root);\r\nbreak;\r\n}\r\nset_bit(BTRFS_ROOT_ORPHAN_ITEM_INSERTED, &root->state);\r\nerr = btrfs_insert_fs_root(root->fs_info, root);\r\nif (err) {\r\nBUG_ON(err == -EEXIST);\r\nbtrfs_free_fs_root(root);\r\nbreak;\r\n}\r\nif (btrfs_root_refs(&root->root_item) == 0)\r\nbtrfs_add_dead_root(root);\r\n}\r\nbtrfs_free_path(path);\r\nreturn err;\r\n}\r\nint btrfs_del_root(struct btrfs_trans_handle *trans, struct btrfs_root *root,\r\nstruct btrfs_key *key)\r\n{\r\nstruct btrfs_path *path;\r\nint ret;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nret = btrfs_search_slot(trans, root, key, path, -1, 1);\r\nif (ret < 0)\r\ngoto out;\r\nBUG_ON(ret != 0);\r\nret = btrfs_del_item(trans, root, path);\r\nout:\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nint btrfs_del_root_ref(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *tree_root,\r\nu64 root_id, u64 ref_id, u64 dirid, u64 *sequence,\r\nconst char *name, int name_len)\r\n{\r\nstruct btrfs_path *path;\r\nstruct btrfs_root_ref *ref;\r\nstruct extent_buffer *leaf;\r\nstruct btrfs_key key;\r\nunsigned long ptr;\r\nint err = 0;\r\nint ret;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nkey.objectid = root_id;\r\nkey.type = BTRFS_ROOT_BACKREF_KEY;\r\nkey.offset = ref_id;\r\nagain:\r\nret = btrfs_search_slot(trans, tree_root, &key, path, -1, 1);\r\nBUG_ON(ret < 0);\r\nif (ret == 0) {\r\nleaf = path->nodes[0];\r\nref = btrfs_item_ptr(leaf, path->slots[0],\r\nstruct btrfs_root_ref);\r\nWARN_ON(btrfs_root_ref_dirid(leaf, ref) != dirid);\r\nWARN_ON(btrfs_root_ref_name_len(leaf, ref) != name_len);\r\nptr = (unsigned long)(ref + 1);\r\nWARN_ON(memcmp_extent_buffer(leaf, name, ptr, name_len));\r\n*sequence = btrfs_root_ref_sequence(leaf, ref);\r\nret = btrfs_del_item(trans, tree_root, path);\r\nif (ret) {\r\nerr = ret;\r\ngoto out;\r\n}\r\n} else\r\nerr = -ENOENT;\r\nif (key.type == BTRFS_ROOT_BACKREF_KEY) {\r\nbtrfs_release_path(path);\r\nkey.objectid = ref_id;\r\nkey.type = BTRFS_ROOT_REF_KEY;\r\nkey.offset = root_id;\r\ngoto again;\r\n}\r\nout:\r\nbtrfs_free_path(path);\r\nreturn err;\r\n}\r\nint btrfs_add_root_ref(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *tree_root,\r\nu64 root_id, u64 ref_id, u64 dirid, u64 sequence,\r\nconst char *name, int name_len)\r\n{\r\nstruct btrfs_key key;\r\nint ret;\r\nstruct btrfs_path *path;\r\nstruct btrfs_root_ref *ref;\r\nstruct extent_buffer *leaf;\r\nunsigned long ptr;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nkey.objectid = root_id;\r\nkey.type = BTRFS_ROOT_BACKREF_KEY;\r\nkey.offset = ref_id;\r\nagain:\r\nret = btrfs_insert_empty_item(trans, tree_root, path, &key,\r\nsizeof(*ref) + name_len);\r\nif (ret) {\r\nbtrfs_abort_transaction(trans, tree_root, ret);\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nleaf = path->nodes[0];\r\nref = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_root_ref);\r\nbtrfs_set_root_ref_dirid(leaf, ref, dirid);\r\nbtrfs_set_root_ref_sequence(leaf, ref, sequence);\r\nbtrfs_set_root_ref_name_len(leaf, ref, name_len);\r\nptr = (unsigned long)(ref + 1);\r\nwrite_extent_buffer(leaf, name, ptr, name_len);\r\nbtrfs_mark_buffer_dirty(leaf);\r\nif (key.type == BTRFS_ROOT_BACKREF_KEY) {\r\nbtrfs_release_path(path);\r\nkey.objectid = ref_id;\r\nkey.type = BTRFS_ROOT_REF_KEY;\r\nkey.offset = root_id;\r\ngoto again;\r\n}\r\nbtrfs_free_path(path);\r\nreturn 0;\r\n}\r\nvoid btrfs_check_and_init_root_item(struct btrfs_root_item *root_item)\r\n{\r\nu64 inode_flags = btrfs_stack_inode_flags(&root_item->inode);\r\nif (!(inode_flags & BTRFS_INODE_ROOT_ITEM_INIT)) {\r\ninode_flags |= BTRFS_INODE_ROOT_ITEM_INIT;\r\nbtrfs_set_stack_inode_flags(&root_item->inode, inode_flags);\r\nbtrfs_set_root_flags(root_item, 0);\r\nbtrfs_set_root_limit(root_item, 0);\r\n}\r\n}\r\nvoid btrfs_update_root_times(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root)\r\n{\r\nstruct btrfs_root_item *item = &root->root_item;\r\nstruct timespec ct = CURRENT_TIME;\r\nspin_lock(&root->root_item_lock);\r\nbtrfs_set_root_ctransid(item, trans->transid);\r\nbtrfs_set_stack_timespec_sec(&item->ctime, ct.tv_sec);\r\nbtrfs_set_stack_timespec_nsec(&item->ctime, ct.tv_nsec);\r\nspin_unlock(&root->root_item_lock);\r\n}
