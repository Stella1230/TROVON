static void dmm32at_ai_set_chanspec(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int chanspec, int nchan)\r\n{\r\nunsigned int chan = CR_CHAN(chanspec);\r\nunsigned int range = CR_RANGE(chanspec);\r\nunsigned int last_chan = (chan + nchan - 1) % s->n_chan;\r\noutb(DMM32AT_FIFO_CTRL_FIFORST, dev->iobase + DMM32AT_FIFO_CTRL_REG);\r\nif (nchan > 1)\r\noutb(DMM32AT_FIFO_CTRL_SCANEN,\r\ndev->iobase + DMM32AT_FIFO_CTRL_REG);\r\noutb(chan, dev->iobase + DMM32AT_AI_LO_CHAN_REG);\r\noutb(last_chan, dev->iobase + DMM32AT_AI_HI_CHAN_REG);\r\noutb(dmm32at_rangebits[range], dev->iobase + DMM32AT_AI_CFG_REG);\r\n}\r\nstatic unsigned int dmm32at_ai_get_sample(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nunsigned int val;\r\nval = inb(dev->iobase + DMM32AT_AI_LSB_REG);\r\nval |= (inb(dev->iobase + DMM32AT_AI_MSB_REG) << 8);\r\nreturn comedi_offset_munge(s, val);\r\n}\r\nstatic int dmm32at_ai_status(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nunsigned char status;\r\nstatus = inb(dev->iobase + context);\r\nif ((status & DMM32AT_AI_STATUS_STS) == 0)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int dmm32at_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint ret;\r\nint i;\r\ndmm32at_ai_set_chanspec(dev, s, insn->chanspec, 1);\r\nret = comedi_timeout(dev, s, insn, dmm32at_ai_status,\r\nDMM32AT_AI_READBACK_REG);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < insn->n; i++) {\r\noutb(0xff, dev->iobase + DMM32AT_AI_START_CONV_REG);\r\nret = comedi_timeout(dev, s, insn, dmm32at_ai_status,\r\nDMM32AT_AI_STATUS_REG);\r\nif (ret)\r\nreturn ret;\r\ndata[i] = dmm32at_ai_get_sample(dev, s);\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int dmm32at_ai_check_chanlist(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nunsigned int chan0 = CR_CHAN(cmd->chanlist[0]);\r\nunsigned int range0 = CR_RANGE(cmd->chanlist[0]);\r\nint i;\r\nfor (i = 1; i < cmd->chanlist_len; i++) {\r\nunsigned int chan = CR_CHAN(cmd->chanlist[i]);\r\nunsigned int range = CR_RANGE(cmd->chanlist[i]);\r\nif (chan != (chan0 + i) % s->n_chan) {\r\ndev_dbg(dev->class_dev,\r\n"entries in chanlist must be consecutive channels, counting upwards\n");\r\nreturn -EINVAL;\r\n}\r\nif (range != range0) {\r\ndev_dbg(dev->class_dev,\r\n"entries in chanlist must all have the same gain\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dmm32at_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nunsigned int arg;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_TIMER);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nerr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg, 1000000);\r\nerr |= comedi_check_trigger_arg_max(&cmd->scan_begin_arg, 1000000000);\r\nif (cmd->convert_arg >= 17500)\r\ncmd->convert_arg = 20000;\r\nelse if (cmd->convert_arg >= 12500)\r\ncmd->convert_arg = 15000;\r\nelse if (cmd->convert_arg >= 7500)\r\ncmd->convert_arg = 10000;\r\nelse\r\ncmd->convert_arg = 5000;\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\narg = cmd->convert_arg * cmd->scan_end_arg;\r\nerr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg, arg);\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist && cmd->chanlist_len > 0)\r\nerr |= dmm32at_ai_check_chanlist(dev, s, cmd);\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic void dmm32at_setaitimer(struct comedi_device *dev, unsigned int nansec)\r\n{\r\nunsigned char lo1, lo2, hi2;\r\nunsigned short both2;\r\nlo1 = 200;\r\nboth2 = nansec / 20000;\r\nhi2 = (both2 & 0xff00) >> 8;\r\nlo2 = both2 & 0x00ff;\r\noutb(0, dev->iobase + DMM32AT_CTRDIO_CFG_REG);\r\noutb(DMM32AT_CTRL_PAGE_8254, dev->iobase + DMM32AT_CTRL_REG);\r\noutb(DMM32AT_CLKCT1, dev->iobase + DMM32AT_CLKCT);\r\noutb(lo1, dev->iobase + DMM32AT_CLK1);\r\noutb(DMM32AT_CLKCT2, dev->iobase + DMM32AT_CLKCT);\r\noutb(lo2, dev->iobase + DMM32AT_CLK2);\r\noutb(hi2, dev->iobase + DMM32AT_CLK2);\r\noutb(DMM32AT_INTCLK_ADINT |\r\nDMM32AT_INTCLK_CLKEN | DMM32AT_INTCLK_CLKSEL,\r\ndev->iobase + DMM32AT_INTCLK_REG);\r\n}\r\nstatic int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nint ret;\r\ndmm32at_ai_set_chanspec(dev, s, cmd->chanlist[0], cmd->chanlist_len);\r\noutb(DMM32AT_CTRL_INTRST, dev->iobase + DMM32AT_CTRL_REG);\r\nret = comedi_timeout(dev, s, NULL, dmm32at_ai_status,\r\nDMM32AT_AI_READBACK_REG);\r\nif (ret)\r\nreturn ret;\r\nif (cmd->stop_src == TRIG_NONE || cmd->stop_arg > 1) {\r\ndmm32at_setaitimer(dev, cmd->scan_begin_arg);\r\n} else {\r\noutb(DMM32AT_INTCLK_ADINT, dev->iobase + DMM32AT_INTCLK_REG);\r\noutb(0xff, dev->iobase + DMM32AT_AI_START_CONV_REG);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dmm32at_ai_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\noutb(0x0, dev->iobase + DMM32AT_INTCLK_REG);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t dmm32at_isr(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nunsigned char intstat;\r\nunsigned int val;\r\nint i;\r\nif (!dev->attached) {\r\ndev_err(dev->class_dev, "spurious interrupt\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nintstat = inb(dev->iobase + DMM32AT_INTCLK_REG);\r\nif (intstat & DMM32AT_INTCLK_ADINT) {\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nval = dmm32at_ai_get_sample(dev, s);\r\ncomedi_buf_write_samples(s, &val, 1);\r\n}\r\nif (cmd->stop_src == TRIG_COUNT &&\r\ns->async->scans_done >= cmd->stop_arg)\r\ns->async->events |= COMEDI_CB_EOA;\r\ncomedi_handle_events(dev, s);\r\n}\r\noutb(DMM32AT_CTRL_INTRST, dev->iobase + DMM32AT_CTRL_REG);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int dmm32at_ao_eoc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nunsigned char status;\r\nstatus = inb(dev->iobase + DMM32AT_AUX_DI_REG);\r\nif ((status & DMM32AT_AUX_DI_DACBUSY) == 0)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int dmm32at_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nint i;\r\nfor (i = 0; i < insn->n; i++) {\r\nunsigned int val = data[i];\r\nint ret;\r\noutb(val & 0xff, dev->iobase + DMM32AT_AO_LSB_REG);\r\noutb((val >> 8) | DMM32AT_AO_MSB_DACH(chan),\r\ndev->iobase + DMM32AT_AO_MSB_REG);\r\nret = comedi_timeout(dev, s, insn, dmm32at_ao_eoc, 0);\r\nif (ret)\r\nreturn ret;\r\ninb(dev->iobase + DMM32AT_AO_MSB_REG);\r\ns->readback[chan] = val;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int dmm32at_8255_io(struct comedi_device *dev,\r\nint dir, int port, int data, unsigned long regbase)\r\n{\r\noutb(DMM32AT_CTRL_PAGE_8255, dev->iobase + DMM32AT_CTRL_REG);\r\nif (dir) {\r\noutb(data, dev->iobase + regbase + port);\r\nreturn 0;\r\n}\r\nreturn inb(dev->iobase + regbase + port);\r\n}\r\nstatic int dmm32at_reset(struct comedi_device *dev)\r\n{\r\nunsigned char aihi, ailo, fifostat, aistat, intstat, airback;\r\noutb(DMM32AT_CTRL_RESETA, dev->iobase + DMM32AT_CTRL_REG);\r\nudelay(1000);\r\noutb(0x0, dev->iobase + DMM32AT_FIFO_CTRL_REG);\r\noutb(0x0, dev->iobase + DMM32AT_INTCLK_REG);\r\noutb(0x80, dev->iobase + DMM32AT_AI_LO_CHAN_REG);\r\noutb(0xff, dev->iobase + DMM32AT_AI_HI_CHAN_REG);\r\noutb(DMM32AT_RANGE_U10, dev->iobase + DMM32AT_AI_CFG_REG);\r\nudelay(100);\r\nailo = inb(dev->iobase + DMM32AT_AI_LO_CHAN_REG);\r\naihi = inb(dev->iobase + DMM32AT_AI_HI_CHAN_REG);\r\nfifostat = inb(dev->iobase + DMM32AT_FIFO_STATUS_REG);\r\naistat = inb(dev->iobase + DMM32AT_AI_STATUS_REG);\r\nintstat = inb(dev->iobase + DMM32AT_INTCLK_REG);\r\nairback = inb(dev->iobase + DMM32AT_AI_READBACK_REG);\r\nif (ailo != 0x00 || aihi != 0x1f ||\r\nfifostat != DMM32AT_FIFO_STATUS_EF ||\r\naistat != (DMM32AT_AI_STATUS_SD1 | DMM32AT_AI_STATUS_SD0) ||\r\nintstat != 0x00 || airback != 0x0c)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int dmm32at_attach(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nstruct comedi_subdevice *s;\r\nint ret;\r\nret = comedi_request_region(dev, it->options[0], 0x10);\r\nif (ret)\r\nreturn ret;\r\nret = dmm32at_reset(dev);\r\nif (ret) {\r\ndev_err(dev->class_dev, "board detection failed\n");\r\nreturn ret;\r\n}\r\nif (it->options[1]) {\r\nret = request_irq(it->options[1], dmm32at_isr, 0,\r\ndev->board_name, dev);\r\nif (ret == 0)\r\ndev->irq = it->options[1];\r\n}\r\nret = comedi_alloc_subdevices(dev, 3);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF;\r\ns->n_chan = 32;\r\ns->maxdata = 0xffff;\r\ns->range_table = &dmm32at_airanges;\r\ns->insn_read = dmm32at_ai_insn_read;\r\nif (dev->irq) {\r\ndev->read_subdev = s;\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->len_chanlist = s->n_chan;\r\ns->do_cmd = dmm32at_ai_cmd;\r\ns->do_cmdtest = dmm32at_ai_cmdtest;\r\ns->cancel = dmm32at_ai_cancel;\r\n}\r\ns = &dev->subdevices[1];\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 4;\r\ns->maxdata = 0x0fff;\r\ns->range_table = &dmm32at_aoranges;\r\ns->insn_write = dmm32at_ao_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[2];\r\nret = subdev_8255_init(dev, s, dmm32at_8255_io, DMM32AT_8255_IOBASE);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}
