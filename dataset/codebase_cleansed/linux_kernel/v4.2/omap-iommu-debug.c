static inline bool is_omap_iommu_detached(struct omap_iommu *obj)\r\n{\r\nreturn !obj->domain;\r\n}\r\nstatic ssize_t debug_read_regs(struct file *file, char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct omap_iommu *obj = file->private_data;\r\nchar *p, *buf;\r\nssize_t bytes;\r\nif (is_omap_iommu_detached(obj))\r\nreturn -EPERM;\r\nbuf = kmalloc(count, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\np = buf;\r\nmutex_lock(&iommu_debug_lock);\r\nbytes = omap_iommu_dump_ctx(obj, p, count);\r\nbytes = simple_read_from_buffer(userbuf, count, ppos, buf, bytes);\r\nmutex_unlock(&iommu_debug_lock);\r\nkfree(buf);\r\nreturn bytes;\r\n}\r\nstatic ssize_t debug_read_tlb(struct file *file, char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct omap_iommu *obj = file->private_data;\r\nchar *p, *buf;\r\nssize_t bytes, rest;\r\nif (is_omap_iommu_detached(obj))\r\nreturn -EPERM;\r\nbuf = kmalloc(count, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\np = buf;\r\nmutex_lock(&iommu_debug_lock);\r\np += sprintf(p, "%8s %8s\n", "cam:", "ram:");\r\np += sprintf(p, "-----------------------------------------\n");\r\nrest = count - (p - buf);\r\np += omap_dump_tlb_entries(obj, p, rest);\r\nbytes = simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);\r\nmutex_unlock(&iommu_debug_lock);\r\nkfree(buf);\r\nreturn bytes;\r\n}\r\nstatic void dump_ioptable(struct seq_file *s)\r\n{\r\nint i, j;\r\nu32 da;\r\nu32 *iopgd, *iopte;\r\nstruct omap_iommu *obj = s->private;\r\nspin_lock(&obj->page_table_lock);\r\niopgd = iopgd_offset(obj, 0);\r\nfor (i = 0; i < PTRS_PER_IOPGD; i++, iopgd++) {\r\nif (!*iopgd)\r\ncontinue;\r\nif (!(*iopgd & IOPGD_TABLE)) {\r\nda = i << IOPGD_SHIFT;\r\nseq_printf(s, "1: 0x%08x 0x%08x\n", da, *iopgd);\r\ncontinue;\r\n}\r\niopte = iopte_offset(iopgd, 0);\r\nfor (j = 0; j < PTRS_PER_IOPTE; j++, iopte++) {\r\nif (!*iopte)\r\ncontinue;\r\nda = (i << IOPGD_SHIFT) + (j << IOPTE_SHIFT);\r\nseq_printf(s, "2: 0x%08x 0x%08x\n", da, *iopte);\r\n}\r\n}\r\nspin_unlock(&obj->page_table_lock);\r\n}\r\nstatic int debug_read_pagetable(struct seq_file *s, void *data)\r\n{\r\nstruct omap_iommu *obj = s->private;\r\nif (is_omap_iommu_detached(obj))\r\nreturn -EPERM;\r\nmutex_lock(&iommu_debug_lock);\r\nseq_printf(s, "L: %8s %8s\n", "da:", "pte:");\r\nseq_puts(s, "--------------------------\n");\r\ndump_ioptable(s);\r\nmutex_unlock(&iommu_debug_lock);\r\nreturn 0;\r\n}\r\nvoid omap_iommu_debugfs_add(struct omap_iommu *obj)\r\n{\r\nstruct dentry *d;\r\nif (!iommu_debug_root)\r\nreturn;\r\nobj->debug_dir = debugfs_create_dir(obj->name, iommu_debug_root);\r\nif (!obj->debug_dir)\r\nreturn;\r\nd = debugfs_create_u8("nr_tlb_entries", 0400, obj->debug_dir,\r\n(u8 *)&obj->nr_tlb_entries);\r\nif (!d)\r\nreturn;\r\nDEBUG_ADD_FILE_RO(regs);\r\nDEBUG_ADD_FILE_RO(tlb);\r\nDEBUG_ADD_FILE_RO(pagetable);\r\nreturn;\r\nerr:\r\ndebugfs_remove_recursive(obj->debug_dir);\r\n}\r\nvoid omap_iommu_debugfs_remove(struct omap_iommu *obj)\r\n{\r\nif (!obj->debug_dir)\r\nreturn;\r\ndebugfs_remove_recursive(obj->debug_dir);\r\n}\r\nvoid __init omap_iommu_debugfs_init(void)\r\n{\r\niommu_debug_root = debugfs_create_dir("omap_iommu", NULL);\r\nif (!iommu_debug_root)\r\npr_err("can't create debugfs dir\n");\r\n}\r\nvoid __exit omap_iommu_debugfs_exit(void)\r\n{\r\ndebugfs_remove(iommu_debug_root);\r\n}
