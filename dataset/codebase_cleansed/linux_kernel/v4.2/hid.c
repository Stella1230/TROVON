static int do_config(struct usb_configuration *c)\r\n{\r\nstruct hidg_func_node *e, *n;\r\nint status = 0;\r\nif (gadget_is_otg(c->cdev->gadget)) {\r\nc->descriptors = otg_desc;\r\nc->bmAttributes |= USB_CONFIG_ATT_WAKEUP;\r\n}\r\nlist_for_each_entry(e, &hidg_func_list, node) {\r\ne->f = usb_get_function(e->fi);\r\nif (IS_ERR(e->f))\r\ngoto put;\r\nstatus = usb_add_function(c, e->f);\r\nif (status < 0) {\r\nusb_put_function(e->f);\r\ngoto put;\r\n}\r\n}\r\nreturn 0;\r\nput:\r\nlist_for_each_entry(n, &hidg_func_list, node) {\r\nif (n == e)\r\nbreak;\r\nusb_remove_function(c, n->f);\r\nusb_put_function(n->f);\r\n}\r\nreturn status;\r\n}\r\nstatic int hid_bind(struct usb_composite_dev *cdev)\r\n{\r\nstruct usb_gadget *gadget = cdev->gadget;\r\nstruct list_head *tmp;\r\nstruct hidg_func_node *n, *m;\r\nstruct f_hid_opts *hid_opts;\r\nint status, funcs = 0;\r\nlist_for_each(tmp, &hidg_func_list)\r\nfuncs++;\r\nif (!funcs)\r\nreturn -ENODEV;\r\nlist_for_each_entry(n, &hidg_func_list, node) {\r\nn->fi = usb_get_function_instance("hid");\r\nif (IS_ERR(n->fi)) {\r\nstatus = PTR_ERR(n->fi);\r\ngoto put;\r\n}\r\nhid_opts = container_of(n->fi, struct f_hid_opts, func_inst);\r\nhid_opts->subclass = n->func->subclass;\r\nhid_opts->protocol = n->func->protocol;\r\nhid_opts->report_length = n->func->report_length;\r\nhid_opts->report_desc_length = n->func->report_desc_length;\r\nhid_opts->report_desc = n->func->report_desc;\r\n}\r\nstatus = usb_string_ids_tab(cdev, strings_dev);\r\nif (status < 0)\r\ngoto put;\r\ndevice_desc.iManufacturer = strings_dev[USB_GADGET_MANUFACTURER_IDX].id;\r\ndevice_desc.iProduct = strings_dev[USB_GADGET_PRODUCT_IDX].id;\r\nstatus = usb_add_config(cdev, &config_driver, do_config);\r\nif (status < 0)\r\ngoto put;\r\nusb_composite_overwrite_options(cdev, &coverwrite);\r\ndev_info(&gadget->dev, DRIVER_DESC ", version: " DRIVER_VERSION "\n");\r\nreturn 0;\r\nput:\r\nlist_for_each_entry(m, &hidg_func_list, node) {\r\nif (m == n)\r\nbreak;\r\nusb_put_function_instance(m->fi);\r\n}\r\nreturn status;\r\n}\r\nstatic int hid_unbind(struct usb_composite_dev *cdev)\r\n{\r\nstruct hidg_func_node *n;\r\nlist_for_each_entry(n, &hidg_func_list, node) {\r\nusb_put_function(n->f);\r\nusb_put_function_instance(n->fi);\r\n}\r\nreturn 0;\r\n}\r\nstatic int hidg_plat_driver_probe(struct platform_device *pdev)\r\n{\r\nstruct hidg_func_descriptor *func = dev_get_platdata(&pdev->dev);\r\nstruct hidg_func_node *entry;\r\nif (!func) {\r\ndev_err(&pdev->dev, "Platform data missing\n");\r\nreturn -ENODEV;\r\n}\r\nentry = kzalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry)\r\nreturn -ENOMEM;\r\nentry->func = func;\r\nlist_add_tail(&entry->node, &hidg_func_list);\r\nreturn 0;\r\n}\r\nstatic int hidg_plat_driver_remove(struct platform_device *pdev)\r\n{\r\nstruct hidg_func_node *e, *n;\r\nlist_for_each_entry_safe(e, n, &hidg_func_list, node) {\r\nlist_del(&e->node);\r\nkfree(e);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init hidg_init(void)\r\n{\r\nint status;\r\nstatus = platform_driver_probe(&hidg_plat_driver,\r\nhidg_plat_driver_probe);\r\nif (status < 0)\r\nreturn status;\r\nstatus = usb_composite_probe(&hidg_driver);\r\nif (status < 0)\r\nplatform_driver_unregister(&hidg_plat_driver);\r\nreturn status;\r\n}\r\nstatic void __exit hidg_cleanup(void)\r\n{\r\nusb_composite_unregister(&hidg_driver);\r\nplatform_driver_unregister(&hidg_plat_driver);\r\n}
