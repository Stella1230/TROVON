static inline bool is_power_reg(u8 reg)\r\n{\r\nreturn reg < LTC2945_SENSE_H;\r\n}\r\nstatic long long ltc2945_reg_to_val(struct device *dev, u8 reg)\r\n{\r\nstruct regmap *regmap = dev_get_drvdata(dev);\r\nunsigned int control;\r\nu8 buf[3];\r\nlong long val;\r\nint ret;\r\nret = regmap_bulk_read(regmap, reg, buf,\r\nis_power_reg(reg) ? 3 : 2);\r\nif (ret < 0)\r\nreturn ret;\r\nif (is_power_reg(reg)) {\r\nval = (buf[0] << 16) + (buf[1] << 8) + buf[2];\r\n} else {\r\nval = (buf[0] << 4) + (buf[1] >> 4);\r\n}\r\nswitch (reg) {\r\ncase LTC2945_POWER_H:\r\ncase LTC2945_MAX_POWER_H:\r\ncase LTC2945_MIN_POWER_H:\r\ncase LTC2945_MAX_POWER_THRES_H:\r\ncase LTC2945_MIN_POWER_THRES_H:\r\nret = regmap_read(regmap, LTC2945_CONTROL, &control);\r\nif (ret < 0)\r\nreturn ret;\r\nif (control & CONTROL_MULT_SELECT) {\r\nval *= 625LL;\r\n} else {\r\nval = (val * 25LL) >> 1;\r\n}\r\nbreak;\r\ncase LTC2945_VIN_H:\r\ncase LTC2945_MAX_VIN_H:\r\ncase LTC2945_MIN_VIN_H:\r\ncase LTC2945_MAX_VIN_THRES_H:\r\ncase LTC2945_MIN_VIN_THRES_H:\r\nval *= 25;\r\nbreak;\r\ncase LTC2945_ADIN_H:\r\ncase LTC2945_MAX_ADIN_H:\r\ncase LTC2945_MIN_ADIN_THRES_H:\r\ncase LTC2945_MAX_ADIN_THRES_H:\r\ncase LTC2945_MIN_ADIN_H:\r\nval = val >> 1;\r\nbreak;\r\ncase LTC2945_SENSE_H:\r\ncase LTC2945_MAX_SENSE_H:\r\ncase LTC2945_MIN_SENSE_H:\r\ncase LTC2945_MAX_SENSE_THRES_H:\r\ncase LTC2945_MIN_SENSE_THRES_H:\r\nval *= 25;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn val;\r\n}\r\nstatic int ltc2945_val_to_reg(struct device *dev, u8 reg,\r\nunsigned long val)\r\n{\r\nstruct regmap *regmap = dev_get_drvdata(dev);\r\nunsigned int control;\r\nint ret;\r\nswitch (reg) {\r\ncase LTC2945_POWER_H:\r\ncase LTC2945_MAX_POWER_H:\r\ncase LTC2945_MIN_POWER_H:\r\ncase LTC2945_MAX_POWER_THRES_H:\r\ncase LTC2945_MIN_POWER_THRES_H:\r\nret = regmap_read(regmap, LTC2945_CONTROL, &control);\r\nif (ret < 0)\r\nreturn ret;\r\nif (control & CONTROL_MULT_SELECT) {\r\nval = DIV_ROUND_CLOSEST(val, 625);\r\n} else {\r\nval = DIV_ROUND_CLOSEST(val, 25) * 2;\r\n}\r\nbreak;\r\ncase LTC2945_VIN_H:\r\ncase LTC2945_MAX_VIN_H:\r\ncase LTC2945_MIN_VIN_H:\r\ncase LTC2945_MAX_VIN_THRES_H:\r\ncase LTC2945_MIN_VIN_THRES_H:\r\nval /= 25;\r\nbreak;\r\ncase LTC2945_ADIN_H:\r\ncase LTC2945_MAX_ADIN_H:\r\ncase LTC2945_MIN_ADIN_THRES_H:\r\ncase LTC2945_MAX_ADIN_THRES_H:\r\ncase LTC2945_MIN_ADIN_H:\r\nval *= 2;\r\nbreak;\r\ncase LTC2945_SENSE_H:\r\ncase LTC2945_MAX_SENSE_H:\r\ncase LTC2945_MIN_SENSE_H:\r\ncase LTC2945_MAX_SENSE_THRES_H:\r\ncase LTC2945_MIN_SENSE_THRES_H:\r\nval = DIV_ROUND_CLOSEST(val, 25);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn val;\r\n}\r\nstatic ssize_t ltc2945_show_value(struct device *dev,\r\nstruct device_attribute *da, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nlong long value;\r\nvalue = ltc2945_reg_to_val(dev, attr->index);\r\nif (value < 0)\r\nreturn value;\r\nreturn snprintf(buf, PAGE_SIZE, "%lld\n", value);\r\n}\r\nstatic ssize_t ltc2945_set_value(struct device *dev,\r\nstruct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct regmap *regmap = dev_get_drvdata(dev);\r\nu8 reg = attr->index;\r\nunsigned long val;\r\nu8 regbuf[3];\r\nint num_regs;\r\nint regval;\r\nint ret;\r\nret = kstrtoul(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nregval = ltc2945_val_to_reg(dev, reg, val);\r\nif (is_power_reg(reg)) {\r\nregval = clamp_val(regval, 0, 0xffffff);\r\nregbuf[0] = regval >> 16;\r\nregbuf[1] = (regval >> 8) & 0xff;\r\nregbuf[2] = regval;\r\nnum_regs = 3;\r\n} else {\r\nregval = clamp_val(regval, 0, 0xfff) << 4;\r\nregbuf[0] = regval >> 8;\r\nregbuf[1] = regval & 0xff;\r\nnum_regs = 2;\r\n}\r\nret = regmap_bulk_write(regmap, reg, regbuf, num_regs);\r\nreturn ret < 0 ? ret : count;\r\n}\r\nstatic ssize_t ltc2945_reset_history(struct device *dev,\r\nstruct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct regmap *regmap = dev_get_drvdata(dev);\r\nu8 reg = attr->index;\r\nint num_regs = is_power_reg(reg) ? 3 : 2;\r\nu8 buf_min[3] = { 0xff, 0xff, 0xff };\r\nu8 buf_max[3] = { 0, 0, 0 };\r\nunsigned long val;\r\nint ret;\r\nret = kstrtoul(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val != 1)\r\nreturn -EINVAL;\r\nret = regmap_update_bits(regmap, LTC2945_CONTROL, CONTROL_TEST_MODE,\r\nCONTROL_TEST_MODE);\r\nret = regmap_bulk_write(regmap, reg, buf_min, num_regs);\r\nif (ret)\r\nreturn ret;\r\nswitch (reg) {\r\ncase LTC2945_MIN_POWER_H:\r\nreg = LTC2945_MAX_POWER_H;\r\nbreak;\r\ncase LTC2945_MIN_SENSE_H:\r\nreg = LTC2945_MAX_SENSE_H;\r\nbreak;\r\ncase LTC2945_MIN_VIN_H:\r\nreg = LTC2945_MAX_VIN_H;\r\nbreak;\r\ncase LTC2945_MIN_ADIN_H:\r\nreg = LTC2945_MAX_ADIN_H;\r\nbreak;\r\ndefault:\r\nWARN_ONCE(1, "Bad register: 0x%x\n", reg);\r\nreturn -EINVAL;\r\n}\r\nret = regmap_bulk_write(regmap, reg, buf_max, num_regs);\r\nregmap_update_bits(regmap, LTC2945_CONTROL, CONTROL_TEST_MODE, 0);\r\nreturn ret ? : count;\r\n}\r\nstatic ssize_t ltc2945_show_bool(struct device *dev,\r\nstruct device_attribute *da, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct regmap *regmap = dev_get_drvdata(dev);\r\nunsigned int fault;\r\nint ret;\r\nret = regmap_read(regmap, LTC2945_FAULT, &fault);\r\nif (ret < 0)\r\nreturn ret;\r\nfault &= attr->index;\r\nif (fault)\r\nregmap_update_bits(regmap, LTC2945_FAULT, attr->index, 0);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", !!fault);\r\n}\r\nstatic int ltc2945_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct device *hwmon_dev;\r\nstruct regmap *regmap;\r\nregmap = devm_regmap_init_i2c(client, &ltc2945_regmap_config);\r\nif (IS_ERR(regmap)) {\r\ndev_err(dev, "failed to allocate register map\n");\r\nreturn PTR_ERR(regmap);\r\n}\r\nregmap_write(regmap, LTC2945_FAULT, 0x00);\r\nhwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\r\nregmap,\r\nltc2945_groups);\r\nreturn PTR_ERR_OR_ZERO(hwmon_dev);\r\n}
