static void usbdux_unlink_urbs(struct urb **urbs, int num_urbs)\r\n{\r\nint i;\r\nfor (i = 0; i < num_urbs; i++)\r\nusb_kill_urb(urbs[i]);\r\n}\r\nstatic void usbdux_ai_stop(struct comedi_device *dev, int do_unlink)\r\n{\r\nstruct usbdux_private *devpriv = dev->private;\r\nif (do_unlink && devpriv->ai_urbs)\r\nusbdux_unlink_urbs(devpriv->ai_urbs, devpriv->n_ai_urbs);\r\ndevpriv->ai_cmd_running = 0;\r\n}\r\nstatic int usbdux_ai_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct usbdux_private *devpriv = dev->private;\r\ndown(&devpriv->sem);\r\nusbdux_ai_stop(dev, devpriv->ai_cmd_running);\r\nup(&devpriv->sem);\r\nreturn 0;\r\n}\r\nstatic void usbduxsub_ai_handle_urb(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct urb *urb)\r\n{\r\nstruct usbdux_private *devpriv = dev->private;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nint ret;\r\nint i;\r\ndevpriv->ai_counter--;\r\nif (devpriv->ai_counter == 0) {\r\ndevpriv->ai_counter = devpriv->ai_timer;\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nunsigned int range = CR_RANGE(cmd->chanlist[i]);\r\nuint16_t val = le16_to_cpu(devpriv->in_buf[i]);\r\nif (comedi_range_is_bipolar(s, range))\r\nval ^= ((s->maxdata + 1) >> 1);\r\nif (!comedi_buf_write_samples(s, &val, 1))\r\nreturn;\r\n}\r\nif (cmd->stop_src == TRIG_COUNT &&\r\nasync->scans_done >= cmd->stop_arg)\r\nasync->events |= COMEDI_CB_EOA;\r\n}\r\nif (!(async->events & COMEDI_CB_CANCEL_MASK)) {\r\nurb->dev = comedi_to_usb_dev(dev);\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret < 0) {\r\ndev_err(dev->class_dev,\r\n"urb resubmit failed in int-context! err=%d\n",\r\nret);\r\nif (ret == -EL2NSYNC)\r\ndev_err(dev->class_dev,\r\n"buggy USB host controller or bug in IRQ handler!\n");\r\nasync->events |= COMEDI_CB_ERROR;\r\n}\r\n}\r\n}\r\nstatic void usbduxsub_ai_isoc_irq(struct urb *urb)\r\n{\r\nstruct comedi_device *dev = urb->context;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_async *async = s->async;\r\nstruct usbdux_private *devpriv = dev->private;\r\nif (!devpriv->ai_cmd_running)\r\nreturn;\r\nswitch (urb->status) {\r\ncase 0:\r\nmemcpy(devpriv->in_buf, urb->transfer_buffer, SIZEINBUF);\r\nusbduxsub_ai_handle_urb(dev, s, urb);\r\nbreak;\r\ncase -EILSEQ:\r\ndev_dbg(dev->class_dev, "CRC error in ISO IN stream\n");\r\nusbduxsub_ai_handle_urb(dev, s, urb);\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ncase -ECONNABORTED:\r\nasync->events |= COMEDI_CB_ERROR;\r\nbreak;\r\ndefault:\r\ndev_err(dev->class_dev,\r\n"Non-zero urb status received in ai intr context: %d\n",\r\nurb->status);\r\nasync->events |= COMEDI_CB_ERROR;\r\nbreak;\r\n}\r\nif (async->events & COMEDI_CB_CANCEL_MASK)\r\nusbdux_ai_stop(dev, 0);\r\ncomedi_event(dev, s);\r\n}\r\nstatic void usbdux_ao_stop(struct comedi_device *dev, int do_unlink)\r\n{\r\nstruct usbdux_private *devpriv = dev->private;\r\nif (do_unlink && devpriv->ao_urbs)\r\nusbdux_unlink_urbs(devpriv->ao_urbs, devpriv->n_ao_urbs);\r\ndevpriv->ao_cmd_running = 0;\r\n}\r\nstatic int usbdux_ao_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct usbdux_private *devpriv = dev->private;\r\ndown(&devpriv->sem);\r\nusbdux_ao_stop(dev, devpriv->ao_cmd_running);\r\nup(&devpriv->sem);\r\nreturn 0;\r\n}\r\nstatic void usbduxsub_ao_handle_urb(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct urb *urb)\r\n{\r\nstruct usbdux_private *devpriv = dev->private;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nuint8_t *datap;\r\nint ret;\r\nint i;\r\ndevpriv->ao_counter--;\r\nif (devpriv->ao_counter == 0) {\r\ndevpriv->ao_counter = devpriv->ao_timer;\r\nif (cmd->stop_src == TRIG_COUNT &&\r\nasync->scans_done >= cmd->stop_arg) {\r\nasync->events |= COMEDI_CB_EOA;\r\nreturn;\r\n}\r\ndatap = urb->transfer_buffer;\r\n*datap++ = cmd->chanlist_len;\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nunsigned int chan = CR_CHAN(cmd->chanlist[i]);\r\nunsigned short val;\r\nif (!comedi_buf_read_samples(s, &val, 1)) {\r\ndev_err(dev->class_dev, "buffer underflow\n");\r\nasync->events |= COMEDI_CB_OVERFLOW;\r\nreturn;\r\n}\r\n*datap++ = val & 0xff;\r\n*datap++ = (val >> 8) & 0xff;\r\n*datap++ = chan << 6;\r\ns->readback[chan] = val;\r\n}\r\n}\r\nif (!(async->events & COMEDI_CB_CANCEL_MASK)) {\r\nurb->transfer_buffer_length = SIZEOUTBUF;\r\nurb->dev = comedi_to_usb_dev(dev);\r\nurb->status = 0;\r\nif (devpriv->high_speed)\r\nurb->interval = 8;\r\nelse\r\nurb->interval = 1;\r\nurb->number_of_packets = 1;\r\nurb->iso_frame_desc[0].offset = 0;\r\nurb->iso_frame_desc[0].length = SIZEOUTBUF;\r\nurb->iso_frame_desc[0].status = 0;\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret < 0) {\r\ndev_err(dev->class_dev,\r\n"ao urb resubm failed in int-cont. ret=%d",\r\nret);\r\nif (ret == -EL2NSYNC)\r\ndev_err(dev->class_dev,\r\n"buggy USB host controller or bug in IRQ handling!\n");\r\nasync->events |= COMEDI_CB_ERROR;\r\n}\r\n}\r\n}\r\nstatic void usbduxsub_ao_isoc_irq(struct urb *urb)\r\n{\r\nstruct comedi_device *dev = urb->context;\r\nstruct comedi_subdevice *s = dev->write_subdev;\r\nstruct comedi_async *async = s->async;\r\nstruct usbdux_private *devpriv = dev->private;\r\nif (!devpriv->ao_cmd_running)\r\nreturn;\r\nswitch (urb->status) {\r\ncase 0:\r\nusbduxsub_ao_handle_urb(dev, s, urb);\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ncase -ECONNABORTED:\r\nasync->events |= COMEDI_CB_ERROR;\r\nbreak;\r\ndefault:\r\ndev_err(dev->class_dev,\r\n"Non-zero urb status received in ao intr context: %d\n",\r\nurb->status);\r\nasync->events |= COMEDI_CB_ERROR;\r\nbreak;\r\n}\r\nif (async->events & COMEDI_CB_CANCEL_MASK)\r\nusbdux_ao_stop(dev, 0);\r\ncomedi_event(dev, s);\r\n}\r\nstatic int usbdux_submit_urbs(struct comedi_device *dev,\r\nstruct urb **urbs, int num_urbs,\r\nint input_urb)\r\n{\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\nstruct usbdux_private *devpriv = dev->private;\r\nstruct urb *urb;\r\nint ret;\r\nint i;\r\nfor (i = 0; i < num_urbs; i++) {\r\nurb = urbs[i];\r\nif (input_urb)\r\nurb->interval = devpriv->ai_interval;\r\nurb->context = dev;\r\nurb->dev = usb;\r\nurb->status = 0;\r\nurb->transfer_flags = URB_ISO_ASAP;\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int usbdux_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nstruct usbdux_private *this_usbduxsub = dev->private;\r\nint err = 0, i;\r\nunsigned int tmp_timer;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->start_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nif (cmd->scan_begin_src == TRIG_FOLLOW)\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nif (this_usbduxsub->high_speed) {\r\ni = 1;\r\nwhile (i < (cmd->chanlist_len))\r\ni = i * 2;\r\nerr |= comedi_check_trigger_arg_min(&cmd->\r\nscan_begin_arg,\r\n1000000 / 8 * i);\r\ntmp_timer =\r\n((unsigned int)(cmd->scan_begin_arg / 125000)) *\r\n125000;\r\n} else {\r\nerr |= comedi_check_trigger_arg_min(&cmd->\r\nscan_begin_arg,\r\n1000000);\r\ntmp_timer = ((unsigned int)(cmd->scan_begin_arg /\r\n1000000)) * 1000000;\r\n}\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg,\r\ntmp_timer);\r\n}\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nreturn 0;\r\n}\r\nstatic uint8_t create_adc_command(unsigned int chan, unsigned int range)\r\n{\r\nuint8_t p = (range <= 1);\r\nuint8_t r = ((range % 2) == 0);\r\nreturn (chan << 4) | ((p == 1) << 2) | ((r == 1) << 3);\r\n}\r\nstatic int send_dux_commands(struct comedi_device *dev, unsigned int cmd_type)\r\n{\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\nstruct usbdux_private *devpriv = dev->private;\r\nint nsent;\r\ndevpriv->dux_commands[0] = cmd_type;\r\nreturn usb_bulk_msg(usb, usb_sndbulkpipe(usb, 1),\r\ndevpriv->dux_commands, SIZEOFDUXBUFFER,\r\n&nsent, BULK_TIMEOUT);\r\n}\r\nstatic int receive_dux_commands(struct comedi_device *dev, unsigned int command)\r\n{\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\nstruct usbdux_private *devpriv = dev->private;\r\nint ret;\r\nint nrec;\r\nint i;\r\nfor (i = 0; i < RETRIES; i++) {\r\nret = usb_bulk_msg(usb, usb_rcvbulkpipe(usb, 8),\r\ndevpriv->insn_buf, SIZEINSNBUF,\r\n&nrec, BULK_TIMEOUT);\r\nif (ret < 0)\r\nreturn ret;\r\nif (le16_to_cpu(devpriv->insn_buf[0]) == command)\r\nreturn ret;\r\n}\r\nreturn -EFAULT;\r\n}\r\nstatic int usbdux_ai_inttrig(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nstruct usbdux_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nint ret;\r\nif (trig_num != cmd->start_arg)\r\nreturn -EINVAL;\r\ndown(&devpriv->sem);\r\nif (!devpriv->ai_cmd_running) {\r\ndevpriv->ai_cmd_running = 1;\r\nret = usbdux_submit_urbs(dev, devpriv->ai_urbs,\r\ndevpriv->n_ai_urbs, 1);\r\nif (ret < 0) {\r\ndevpriv->ai_cmd_running = 0;\r\ngoto ai_trig_exit;\r\n}\r\ns->async->inttrig = NULL;\r\n} else {\r\nret = -EBUSY;\r\n}\r\nai_trig_exit:\r\nup(&devpriv->sem);\r\nreturn ret;\r\n}\r\nstatic int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct usbdux_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nint len = cmd->chanlist_len;\r\nint ret = -EBUSY;\r\nint i;\r\ndown(&devpriv->sem);\r\nif (devpriv->ai_cmd_running)\r\ngoto ai_cmd_exit;\r\ndevpriv->dux_commands[1] = len;\r\nfor (i = 0; i < len; ++i) {\r\nunsigned int chan = CR_CHAN(cmd->chanlist[i]);\r\nunsigned int range = CR_RANGE(cmd->chanlist[i]);\r\ndevpriv->dux_commands[i + 2] = create_adc_command(chan, range);\r\n}\r\nret = send_dux_commands(dev, USBDUX_CMD_MULT_AI);\r\nif (ret < 0)\r\ngoto ai_cmd_exit;\r\nif (devpriv->high_speed) {\r\ndevpriv->ai_interval = 1;\r\nwhile (devpriv->ai_interval < len)\r\ndevpriv->ai_interval *= 2;\r\ndevpriv->ai_timer = cmd->scan_begin_arg /\r\n(125000 * devpriv->ai_interval);\r\n} else {\r\ndevpriv->ai_interval = 1;\r\ndevpriv->ai_timer = cmd->scan_begin_arg / 1000000;\r\n}\r\nif (devpriv->ai_timer < 1) {\r\nret = -EINVAL;\r\ngoto ai_cmd_exit;\r\n}\r\ndevpriv->ai_counter = devpriv->ai_timer;\r\nif (cmd->start_src == TRIG_NOW) {\r\ndevpriv->ai_cmd_running = 1;\r\nret = usbdux_submit_urbs(dev, devpriv->ai_urbs,\r\ndevpriv->n_ai_urbs, 1);\r\nif (ret < 0) {\r\ndevpriv->ai_cmd_running = 0;\r\ngoto ai_cmd_exit;\r\n}\r\ns->async->inttrig = NULL;\r\n} else {\r\ns->async->inttrig = usbdux_ai_inttrig;\r\n}\r\nai_cmd_exit:\r\nup(&devpriv->sem);\r\nreturn ret;\r\n}\r\nstatic int usbdux_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct usbdux_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int range = CR_RANGE(insn->chanspec);\r\nunsigned int val;\r\nint ret = -EBUSY;\r\nint i;\r\ndown(&devpriv->sem);\r\nif (devpriv->ai_cmd_running)\r\ngoto ai_read_exit;\r\ndevpriv->dux_commands[1] = create_adc_command(chan, range);\r\nret = send_dux_commands(dev, USBDUX_CMD_SINGLE_AI);\r\nif (ret < 0)\r\ngoto ai_read_exit;\r\nfor (i = 0; i < insn->n; i++) {\r\nret = receive_dux_commands(dev, USBDUX_CMD_SINGLE_AI);\r\nif (ret < 0)\r\ngoto ai_read_exit;\r\nval = le16_to_cpu(devpriv->insn_buf[1]);\r\nif (comedi_range_is_bipolar(s, range))\r\nval ^= ((s->maxdata + 1) >> 1);\r\ndata[i] = val;\r\n}\r\nai_read_exit:\r\nup(&devpriv->sem);\r\nreturn ret ? ret : insn->n;\r\n}\r\nstatic int usbdux_ao_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct usbdux_private *devpriv = dev->private;\r\nint ret;\r\ndown(&devpriv->sem);\r\nret = comedi_readback_insn_read(dev, s, insn, data);\r\nup(&devpriv->sem);\r\nreturn ret;\r\n}\r\nstatic int usbdux_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct usbdux_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int val = s->readback[chan];\r\n__le16 *p = (__le16 *)&devpriv->dux_commands[2];\r\nint ret = -EBUSY;\r\nint i;\r\ndown(&devpriv->sem);\r\nif (devpriv->ao_cmd_running)\r\ngoto ao_write_exit;\r\ndevpriv->dux_commands[1] = 1;\r\ndevpriv->dux_commands[4] = chan << 6;\r\nfor (i = 0; i < insn->n; i++) {\r\nval = data[i];\r\n*p = cpu_to_le16(val);\r\nret = send_dux_commands(dev, USBDUX_CMD_AO);\r\nif (ret < 0)\r\ngoto ao_write_exit;\r\ns->readback[chan] = val;\r\n}\r\nao_write_exit:\r\nup(&devpriv->sem);\r\nreturn ret ? ret : insn->n;\r\n}\r\nstatic int usbdux_ao_inttrig(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nstruct usbdux_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nint ret;\r\nif (trig_num != cmd->start_arg)\r\nreturn -EINVAL;\r\ndown(&devpriv->sem);\r\nif (!devpriv->ao_cmd_running) {\r\ndevpriv->ao_cmd_running = 1;\r\nret = usbdux_submit_urbs(dev, devpriv->ao_urbs,\r\ndevpriv->n_ao_urbs, 0);\r\nif (ret < 0) {\r\ndevpriv->ao_cmd_running = 0;\r\ngoto ao_trig_exit;\r\n}\r\ns->async->inttrig = NULL;\r\n} else {\r\nret = -EBUSY;\r\n}\r\nao_trig_exit:\r\nup(&devpriv->sem);\r\nreturn ret;\r\n}\r\nstatic int usbdux_ao_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nstruct usbdux_private *this_usbduxsub = dev->private;\r\nint err = 0;\r\nunsigned int flags;\r\nif (!this_usbduxsub)\r\nreturn -EFAULT;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);\r\nif (0) {\r\nflags = TRIG_FOLLOW;\r\n} else {\r\nflags = TRIG_TIMER;\r\n}\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src, flags);\r\nif (0) {\r\nflags = TRIG_TIMER;\r\n} else {\r\nflags = TRIG_NOW;\r\n}\r\nerr |= comedi_check_trigger_src(&cmd->convert_src, flags);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->start_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nif (cmd->scan_begin_src == TRIG_FOLLOW)\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nerr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\r\n1000000);\r\n}\r\nif (cmd->convert_src == TRIG_TIMER)\r\nerr |= comedi_check_trigger_arg_min(&cmd->convert_arg, 125000);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nreturn 0;\r\n}\r\nstatic int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct usbdux_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nint ret = -EBUSY;\r\ndown(&devpriv->sem);\r\nif (devpriv->ao_cmd_running)\r\ngoto ao_cmd_exit;\r\nif (0) {\r\ndevpriv->ao_timer = cmd->convert_arg / 125000;\r\n} else {\r\ndevpriv->ao_timer = cmd->scan_begin_arg / 1000000;\r\nif (devpriv->ao_timer < 1) {\r\nret = -EINVAL;\r\ngoto ao_cmd_exit;\r\n}\r\n}\r\ndevpriv->ao_counter = devpriv->ao_timer;\r\nif (cmd->start_src == TRIG_NOW) {\r\ndevpriv->ao_cmd_running = 1;\r\nret = usbdux_submit_urbs(dev, devpriv->ao_urbs,\r\ndevpriv->n_ao_urbs, 0);\r\nif (ret < 0) {\r\ndevpriv->ao_cmd_running = 0;\r\ngoto ao_cmd_exit;\r\n}\r\ns->async->inttrig = NULL;\r\n} else {\r\ns->async->inttrig = usbdux_ao_inttrig;\r\n}\r\nao_cmd_exit:\r\nup(&devpriv->sem);\r\nreturn ret;\r\n}\r\nstatic int usbdux_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint ret;\r\nret = comedi_dio_insn_config(dev, s, insn, data, 0);\r\nif (ret)\r\nreturn ret;\r\nreturn insn->n;\r\n}\r\nstatic int usbdux_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct usbdux_private *devpriv = dev->private;\r\nint ret;\r\ndown(&devpriv->sem);\r\ncomedi_dio_update_state(s, data);\r\ndevpriv->dux_commands[1] = s->io_bits;\r\ndevpriv->dux_commands[2] = s->state;\r\nret = send_dux_commands(dev, USBDUX_CMD_DIO_BITS);\r\nif (ret < 0)\r\ngoto dio_exit;\r\nret = receive_dux_commands(dev, USBDUX_CMD_DIO_BITS);\r\nif (ret < 0)\r\ngoto dio_exit;\r\ndata[1] = le16_to_cpu(devpriv->insn_buf[1]);\r\ndio_exit:\r\nup(&devpriv->sem);\r\nreturn ret ? ret : insn->n;\r\n}\r\nstatic int usbdux_counter_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct usbdux_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nint ret = 0;\r\nint i;\r\ndown(&devpriv->sem);\r\nfor (i = 0; i < insn->n; i++) {\r\nret = send_dux_commands(dev, USBDUX_CMD_TIMER_RD);\r\nif (ret < 0)\r\ngoto counter_read_exit;\r\nret = receive_dux_commands(dev, USBDUX_CMD_TIMER_RD);\r\nif (ret < 0)\r\ngoto counter_read_exit;\r\ndata[i] = le16_to_cpu(devpriv->insn_buf[chan + 1]);\r\n}\r\ncounter_read_exit:\r\nup(&devpriv->sem);\r\nreturn ret ? ret : insn->n;\r\n}\r\nstatic int usbdux_counter_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct usbdux_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\n__le16 *p = (__le16 *)&devpriv->dux_commands[2];\r\nint ret = 0;\r\nint i;\r\ndown(&devpriv->sem);\r\ndevpriv->dux_commands[1] = chan;\r\nfor (i = 0; i < insn->n; i++) {\r\n*p = cpu_to_le16(data[i]);\r\nret = send_dux_commands(dev, USBDUX_CMD_TIMER_WR);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nup(&devpriv->sem);\r\nreturn ret ? ret : insn->n;\r\n}\r\nstatic int usbdux_counter_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nreturn 2;\r\n}\r\nstatic void usbduxsub_unlink_pwm_urbs(struct comedi_device *dev)\r\n{\r\nstruct usbdux_private *devpriv = dev->private;\r\nusb_kill_urb(devpriv->pwm_urb);\r\n}\r\nstatic void usbdux_pwm_stop(struct comedi_device *dev, int do_unlink)\r\n{\r\nstruct usbdux_private *devpriv = dev->private;\r\nif (do_unlink)\r\nusbduxsub_unlink_pwm_urbs(dev);\r\ndevpriv->pwm_cmd_running = 0;\r\n}\r\nstatic int usbdux_pwm_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct usbdux_private *devpriv = dev->private;\r\nint ret;\r\ndown(&devpriv->sem);\r\nusbdux_pwm_stop(dev, devpriv->pwm_cmd_running);\r\nret = send_dux_commands(dev, USBDUX_CMD_PWM_OFF);\r\nup(&devpriv->sem);\r\nreturn ret;\r\n}\r\nstatic void usbduxsub_pwm_irq(struct urb *urb)\r\n{\r\nstruct comedi_device *dev = urb->context;\r\nstruct usbdux_private *devpriv = dev->private;\r\nint ret;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ncase -ECONNABORTED:\r\nif (devpriv->pwm_cmd_running)\r\nusbdux_pwm_stop(dev, 0);\r\nreturn;\r\ndefault:\r\nif (devpriv->pwm_cmd_running) {\r\ndev_err(dev->class_dev,\r\n"Non-zero urb status received in pwm intr context: %d\n",\r\nurb->status);\r\nusbdux_pwm_stop(dev, 0);\r\n}\r\nreturn;\r\n}\r\nif (!devpriv->pwm_cmd_running)\r\nreturn;\r\nurb->transfer_buffer_length = devpriv->pwm_buf_sz;\r\nurb->dev = comedi_to_usb_dev(dev);\r\nurb->status = 0;\r\nif (devpriv->pwm_cmd_running) {\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret < 0) {\r\ndev_err(dev->class_dev,\r\n"pwm urb resubm failed in int-cont. ret=%d",\r\nret);\r\nif (ret == -EL2NSYNC)\r\ndev_err(dev->class_dev,\r\n"buggy USB host controller or bug in IRQ handling!\n");\r\nusbdux_pwm_stop(dev, 0);\r\n}\r\n}\r\n}\r\nstatic int usbduxsub_submit_pwm_urbs(struct comedi_device *dev)\r\n{\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\nstruct usbdux_private *devpriv = dev->private;\r\nstruct urb *urb = devpriv->pwm_urb;\r\nusb_fill_bulk_urb(urb, usb, usb_sndbulkpipe(usb, 4),\r\nurb->transfer_buffer,\r\ndevpriv->pwm_buf_sz,\r\nusbduxsub_pwm_irq,\r\ndev);\r\nreturn usb_submit_urb(urb, GFP_ATOMIC);\r\n}\r\nstatic int usbdux_pwm_period(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int period)\r\n{\r\nstruct usbdux_private *devpriv = dev->private;\r\nint fx2delay = 255;\r\nif (period < MIN_PWM_PERIOD)\r\nreturn -EAGAIN;\r\nfx2delay = (period / (6 * 512 * 1000 / 33)) - 6;\r\nif (fx2delay > 255)\r\nreturn -EAGAIN;\r\ndevpriv->pwm_delay = fx2delay;\r\ndevpriv->pwm_period = period;\r\nreturn 0;\r\n}\r\nstatic int usbdux_pwm_start(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct usbdux_private *devpriv = dev->private;\r\nint ret = 0;\r\ndown(&devpriv->sem);\r\nif (devpriv->pwm_cmd_running)\r\ngoto pwm_start_exit;\r\ndevpriv->dux_commands[1] = devpriv->pwm_delay;\r\nret = send_dux_commands(dev, USBDUX_CMD_PWM_ON);\r\nif (ret < 0)\r\ngoto pwm_start_exit;\r\nmemset(devpriv->pwm_urb->transfer_buffer, 0, devpriv->pwm_buf_sz);\r\ndevpriv->pwm_cmd_running = 1;\r\nret = usbduxsub_submit_pwm_urbs(dev);\r\nif (ret < 0)\r\ndevpriv->pwm_cmd_running = 0;\r\npwm_start_exit:\r\nup(&devpriv->sem);\r\nreturn ret;\r\n}\r\nstatic void usbdux_pwm_pattern(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int chan,\r\nunsigned int value,\r\nunsigned int sign)\r\n{\r\nstruct usbdux_private *devpriv = dev->private;\r\nchar pwm_mask = (1 << chan);\r\nchar sgn_mask = (16 << chan);\r\nchar *buf = (char *)(devpriv->pwm_urb->transfer_buffer);\r\nint szbuf = devpriv->pwm_buf_sz;\r\nint i;\r\nfor (i = 0; i < szbuf; i++) {\r\nchar c = *buf;\r\nc &= ~pwm_mask;\r\nif (i < value)\r\nc |= pwm_mask;\r\nif (!sign)\r\nc &= ~sgn_mask;\r\nelse\r\nc |= sgn_mask;\r\n*buf++ = c;\r\n}\r\n}\r\nstatic int usbdux_pwm_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nif (insn->n != 1)\r\nreturn -EINVAL;\r\nusbdux_pwm_pattern(dev, s, chan, data[0], 0);\r\nreturn insn->n;\r\n}\r\nstatic int usbdux_pwm_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct usbdux_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_ARM:\r\nif (data[1] != 0)\r\nreturn -EINVAL;\r\nreturn usbdux_pwm_start(dev, s);\r\ncase INSN_CONFIG_DISARM:\r\nreturn usbdux_pwm_cancel(dev, s);\r\ncase INSN_CONFIG_GET_PWM_STATUS:\r\ndata[1] = devpriv->pwm_cmd_running;\r\nreturn 0;\r\ncase INSN_CONFIG_PWM_SET_PERIOD:\r\nreturn usbdux_pwm_period(dev, s, data[1]);\r\ncase INSN_CONFIG_PWM_GET_PERIOD:\r\ndata[1] = devpriv->pwm_period;\r\nreturn 0;\r\ncase INSN_CONFIG_PWM_SET_H_BRIDGE:\r\nusbdux_pwm_pattern(dev, s, chan, data[1], (data[2] != 0));\r\nreturn 0;\r\ncase INSN_CONFIG_PWM_GET_H_BRIDGE:\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int usbdux_firmware_upload(struct comedi_device *dev,\r\nconst u8 *data, size_t size,\r\nunsigned long context)\r\n{\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\nuint8_t *buf;\r\nuint8_t *tmp;\r\nint ret;\r\nif (!data)\r\nreturn 0;\r\nif (size > USBDUX_FIRMWARE_MAX_LEN) {\r\ndev_err(dev->class_dev,\r\n"usbdux firmware binary it too large for FX2.\n");\r\nreturn -ENOMEM;\r\n}\r\nbuf = kmemdup(data, size, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\ntmp = kmalloc(1, GFP_KERNEL);\r\nif (!tmp) {\r\nkfree(buf);\r\nreturn -ENOMEM;\r\n}\r\n*tmp = 1;\r\nret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),\r\nUSBDUX_FIRMWARE_CMD,\r\nVENDOR_DIR_OUT,\r\nUSBDUX_CPU_CS, 0x0000,\r\ntmp, 1,\r\nBULK_TIMEOUT);\r\nif (ret < 0) {\r\ndev_err(dev->class_dev, "can not stop firmware\n");\r\ngoto done;\r\n}\r\nret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),\r\nUSBDUX_FIRMWARE_CMD,\r\nVENDOR_DIR_OUT,\r\n0, 0x0000,\r\nbuf, size,\r\nBULK_TIMEOUT);\r\nif (ret < 0) {\r\ndev_err(dev->class_dev, "firmware upload failed\n");\r\ngoto done;\r\n}\r\n*tmp = 0;\r\nret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),\r\nUSBDUX_FIRMWARE_CMD,\r\nVENDOR_DIR_OUT,\r\nUSBDUX_CPU_CS, 0x0000,\r\ntmp, 1,\r\nBULK_TIMEOUT);\r\nif (ret < 0)\r\ndev_err(dev->class_dev, "can not start firmware\n");\r\ndone:\r\nkfree(tmp);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int usbdux_alloc_usb_buffers(struct comedi_device *dev)\r\n{\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\nstruct usbdux_private *devpriv = dev->private;\r\nstruct urb *urb;\r\nint i;\r\ndevpriv->dux_commands = kzalloc(SIZEOFDUXBUFFER, GFP_KERNEL);\r\ndevpriv->in_buf = kzalloc(SIZEINBUF, GFP_KERNEL);\r\ndevpriv->insn_buf = kzalloc(SIZEINSNBUF, GFP_KERNEL);\r\ndevpriv->ai_urbs = kcalloc(devpriv->n_ai_urbs, sizeof(void *),\r\nGFP_KERNEL);\r\ndevpriv->ao_urbs = kcalloc(devpriv->n_ao_urbs, sizeof(void *),\r\nGFP_KERNEL);\r\nif (!devpriv->dux_commands || !devpriv->in_buf || !devpriv->insn_buf ||\r\n!devpriv->ai_urbs || !devpriv->ao_urbs)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < devpriv->n_ai_urbs; i++) {\r\nurb = usb_alloc_urb(1, GFP_KERNEL);\r\nif (!urb)\r\nreturn -ENOMEM;\r\ndevpriv->ai_urbs[i] = urb;\r\nurb->dev = usb;\r\nurb->context = dev;\r\nurb->pipe = usb_rcvisocpipe(usb, 6);\r\nurb->transfer_flags = URB_ISO_ASAP;\r\nurb->transfer_buffer = kzalloc(SIZEINBUF, GFP_KERNEL);\r\nif (!urb->transfer_buffer)\r\nreturn -ENOMEM;\r\nurb->complete = usbduxsub_ai_isoc_irq;\r\nurb->number_of_packets = 1;\r\nurb->transfer_buffer_length = SIZEINBUF;\r\nurb->iso_frame_desc[0].offset = 0;\r\nurb->iso_frame_desc[0].length = SIZEINBUF;\r\n}\r\nfor (i = 0; i < devpriv->n_ao_urbs; i++) {\r\nurb = usb_alloc_urb(1, GFP_KERNEL);\r\nif (!urb)\r\nreturn -ENOMEM;\r\ndevpriv->ao_urbs[i] = urb;\r\nurb->dev = usb;\r\nurb->context = dev;\r\nurb->pipe = usb_sndisocpipe(usb, 2);\r\nurb->transfer_flags = URB_ISO_ASAP;\r\nurb->transfer_buffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);\r\nif (!urb->transfer_buffer)\r\nreturn -ENOMEM;\r\nurb->complete = usbduxsub_ao_isoc_irq;\r\nurb->number_of_packets = 1;\r\nurb->transfer_buffer_length = SIZEOUTBUF;\r\nurb->iso_frame_desc[0].offset = 0;\r\nurb->iso_frame_desc[0].length = SIZEOUTBUF;\r\nif (devpriv->high_speed)\r\nurb->interval = 8;\r\nelse\r\nurb->interval = 1;\r\n}\r\nif (devpriv->pwm_buf_sz) {\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb)\r\nreturn -ENOMEM;\r\ndevpriv->pwm_urb = urb;\r\nurb->transfer_buffer = kzalloc(devpriv->pwm_buf_sz,\r\nGFP_KERNEL);\r\nif (!urb->transfer_buffer)\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void usbdux_free_usb_buffers(struct comedi_device *dev)\r\n{\r\nstruct usbdux_private *devpriv = dev->private;\r\nstruct urb *urb;\r\nint i;\r\nurb = devpriv->pwm_urb;\r\nif (urb) {\r\nkfree(urb->transfer_buffer);\r\nusb_free_urb(urb);\r\n}\r\nif (devpriv->ao_urbs) {\r\nfor (i = 0; i < devpriv->n_ao_urbs; i++) {\r\nurb = devpriv->ao_urbs[i];\r\nif (urb) {\r\nkfree(urb->transfer_buffer);\r\nusb_free_urb(urb);\r\n}\r\n}\r\nkfree(devpriv->ao_urbs);\r\n}\r\nif (devpriv->ai_urbs) {\r\nfor (i = 0; i < devpriv->n_ai_urbs; i++) {\r\nurb = devpriv->ai_urbs[i];\r\nif (urb) {\r\nkfree(urb->transfer_buffer);\r\nusb_free_urb(urb);\r\n}\r\n}\r\nkfree(devpriv->ai_urbs);\r\n}\r\nkfree(devpriv->insn_buf);\r\nkfree(devpriv->in_buf);\r\nkfree(devpriv->dux_commands);\r\n}\r\nstatic int usbdux_auto_attach(struct comedi_device *dev,\r\nunsigned long context_unused)\r\n{\r\nstruct usb_interface *intf = comedi_to_usb_interface(dev);\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\nstruct usbdux_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint ret;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nsema_init(&devpriv->sem, 1);\r\nusb_set_intfdata(intf, devpriv);\r\ndevpriv->high_speed = (usb->speed == USB_SPEED_HIGH);\r\nif (devpriv->high_speed) {\r\ndevpriv->n_ai_urbs = NUMOFINBUFFERSHIGH;\r\ndevpriv->n_ao_urbs = NUMOFOUTBUFFERSHIGH;\r\ndevpriv->pwm_buf_sz = 512;\r\n} else {\r\ndevpriv->n_ai_urbs = NUMOFINBUFFERSFULL;\r\ndevpriv->n_ao_urbs = NUMOFOUTBUFFERSFULL;\r\n}\r\nret = usbdux_alloc_usb_buffers(dev);\r\nif (ret)\r\nreturn ret;\r\nret = usb_set_interface(usb, intf->altsetting->desc.bInterfaceNumber,\r\n3);\r\nif (ret < 0) {\r\ndev_err(dev->class_dev,\r\n"could not set alternate setting 3 in high speed\n");\r\nreturn ret;\r\n}\r\nret = comedi_load_firmware(dev, &usb->dev, USBDUX_FIRMWARE,\r\nusbdux_firmware_upload, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = comedi_alloc_subdevices(dev, (devpriv->high_speed) ? 5 : 4);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ndev->read_subdev = s;\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_CMD_READ;\r\ns->n_chan = 8;\r\ns->maxdata = 0x0fff;\r\ns->len_chanlist = 8;\r\ns->range_table = &range_usbdux_ai_range;\r\ns->insn_read = usbdux_ai_insn_read;\r\ns->do_cmdtest = usbdux_ai_cmdtest;\r\ns->do_cmd = usbdux_ai_cmd;\r\ns->cancel = usbdux_ai_cancel;\r\ns = &dev->subdevices[1];\r\ndev->write_subdev = s;\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;\r\ns->n_chan = 4;\r\ns->maxdata = 0x0fff;\r\ns->len_chanlist = s->n_chan;\r\ns->range_table = &range_usbdux_ao_range;\r\ns->do_cmdtest = usbdux_ao_cmdtest;\r\ns->do_cmd = usbdux_ao_cmd;\r\ns->cancel = usbdux_ao_cancel;\r\ns->insn_read = usbdux_ao_insn_read;\r\ns->insn_write = usbdux_ao_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = 8;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = usbdux_dio_insn_bits;\r\ns->insn_config = usbdux_dio_insn_config;\r\ns = &dev->subdevices[3];\r\ns->type = COMEDI_SUBD_COUNTER;\r\ns->subdev_flags = SDF_WRITABLE | SDF_READABLE;\r\ns->n_chan = 4;\r\ns->maxdata = 0xffff;\r\ns->insn_read = usbdux_counter_read;\r\ns->insn_write = usbdux_counter_write;\r\ns->insn_config = usbdux_counter_config;\r\nif (devpriv->high_speed) {\r\ns = &dev->subdevices[4];\r\ns->type = COMEDI_SUBD_PWM;\r\ns->subdev_flags = SDF_WRITABLE | SDF_PWM_HBRIDGE;\r\ns->n_chan = 8;\r\ns->maxdata = devpriv->pwm_buf_sz;\r\ns->insn_write = usbdux_pwm_write;\r\ns->insn_config = usbdux_pwm_config;\r\nusbdux_pwm_period(dev, s, PWM_DEFAULT_PERIOD);\r\n}\r\nreturn 0;\r\n}\r\nstatic void usbdux_detach(struct comedi_device *dev)\r\n{\r\nstruct usb_interface *intf = comedi_to_usb_interface(dev);\r\nstruct usbdux_private *devpriv = dev->private;\r\nusb_set_intfdata(intf, NULL);\r\nif (!devpriv)\r\nreturn;\r\ndown(&devpriv->sem);\r\nusbdux_pwm_stop(dev, 1);\r\nusbdux_ao_stop(dev, 1);\r\nusbdux_ai_stop(dev, 1);\r\nusbdux_free_usb_buffers(dev);\r\nup(&devpriv->sem);\r\n}\r\nstatic int usbdux_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn comedi_usb_auto_config(intf, &usbdux_driver, 0);\r\n}
