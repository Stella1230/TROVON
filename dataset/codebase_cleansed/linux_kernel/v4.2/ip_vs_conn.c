static inline void ct_write_lock_bh(unsigned int key)\r\n{\r\nspin_lock_bh(&__ip_vs_conntbl_lock_array[key&CT_LOCKARRAY_MASK].l);\r\n}\r\nstatic inline void ct_write_unlock_bh(unsigned int key)\r\n{\r\nspin_unlock_bh(&__ip_vs_conntbl_lock_array[key&CT_LOCKARRAY_MASK].l);\r\n}\r\nstatic unsigned int ip_vs_conn_hashkey(struct net *net, int af, unsigned int proto,\r\nconst union nf_inet_addr *addr,\r\n__be16 port)\r\n{\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (af == AF_INET6)\r\nreturn (jhash_3words(jhash(addr, 16, ip_vs_conn_rnd),\r\n(__force u32)port, proto, ip_vs_conn_rnd) ^\r\n((size_t)net>>8)) & ip_vs_conn_tab_mask;\r\n#endif\r\nreturn (jhash_3words((__force u32)addr->ip, (__force u32)port, proto,\r\nip_vs_conn_rnd) ^\r\n((size_t)net>>8)) & ip_vs_conn_tab_mask;\r\n}\r\nstatic unsigned int ip_vs_conn_hashkey_param(const struct ip_vs_conn_param *p,\r\nbool inverse)\r\n{\r\nconst union nf_inet_addr *addr;\r\n__be16 port;\r\nif (p->pe_data && p->pe->hashkey_raw)\r\nreturn p->pe->hashkey_raw(p, ip_vs_conn_rnd, inverse) &\r\nip_vs_conn_tab_mask;\r\nif (likely(!inverse)) {\r\naddr = p->caddr;\r\nport = p->cport;\r\n} else {\r\naddr = p->vaddr;\r\nport = p->vport;\r\n}\r\nreturn ip_vs_conn_hashkey(p->net, p->af, p->protocol, addr, port);\r\n}\r\nstatic unsigned int ip_vs_conn_hashkey_conn(const struct ip_vs_conn *cp)\r\n{\r\nstruct ip_vs_conn_param p;\r\nip_vs_conn_fill_param(ip_vs_conn_net(cp), cp->af, cp->protocol,\r\n&cp->caddr, cp->cport, NULL, 0, &p);\r\nif (cp->pe) {\r\np.pe = cp->pe;\r\np.pe_data = cp->pe_data;\r\np.pe_data_len = cp->pe_data_len;\r\n}\r\nreturn ip_vs_conn_hashkey_param(&p, false);\r\n}\r\nstatic inline int ip_vs_conn_hash(struct ip_vs_conn *cp)\r\n{\r\nunsigned int hash;\r\nint ret;\r\nif (cp->flags & IP_VS_CONN_F_ONE_PACKET)\r\nreturn 0;\r\nhash = ip_vs_conn_hashkey_conn(cp);\r\nct_write_lock_bh(hash);\r\nspin_lock(&cp->lock);\r\nif (!(cp->flags & IP_VS_CONN_F_HASHED)) {\r\ncp->flags |= IP_VS_CONN_F_HASHED;\r\natomic_inc(&cp->refcnt);\r\nhlist_add_head_rcu(&cp->c_list, &ip_vs_conn_tab[hash]);\r\nret = 1;\r\n} else {\r\npr_err("%s(): request for already hashed, called from %pF\n",\r\n__func__, __builtin_return_address(0));\r\nret = 0;\r\n}\r\nspin_unlock(&cp->lock);\r\nct_write_unlock_bh(hash);\r\nreturn ret;\r\n}\r\nstatic inline int ip_vs_conn_unhash(struct ip_vs_conn *cp)\r\n{\r\nunsigned int hash;\r\nint ret;\r\nhash = ip_vs_conn_hashkey_conn(cp);\r\nct_write_lock_bh(hash);\r\nspin_lock(&cp->lock);\r\nif (cp->flags & IP_VS_CONN_F_HASHED) {\r\nhlist_del_rcu(&cp->c_list);\r\ncp->flags &= ~IP_VS_CONN_F_HASHED;\r\natomic_dec(&cp->refcnt);\r\nret = 1;\r\n} else\r\nret = 0;\r\nspin_unlock(&cp->lock);\r\nct_write_unlock_bh(hash);\r\nreturn ret;\r\n}\r\nstatic inline bool ip_vs_conn_unlink(struct ip_vs_conn *cp)\r\n{\r\nunsigned int hash;\r\nbool ret;\r\nhash = ip_vs_conn_hashkey_conn(cp);\r\nct_write_lock_bh(hash);\r\nspin_lock(&cp->lock);\r\nif (cp->flags & IP_VS_CONN_F_HASHED) {\r\nret = false;\r\nif (atomic_cmpxchg(&cp->refcnt, 1, 0) == 1) {\r\nhlist_del_rcu(&cp->c_list);\r\ncp->flags &= ~IP_VS_CONN_F_HASHED;\r\nret = true;\r\n}\r\n} else\r\nret = atomic_read(&cp->refcnt) ? false : true;\r\nspin_unlock(&cp->lock);\r\nct_write_unlock_bh(hash);\r\nreturn ret;\r\n}\r\nstatic inline struct ip_vs_conn *\r\n__ip_vs_conn_in_get(const struct ip_vs_conn_param *p)\r\n{\r\nunsigned int hash;\r\nstruct ip_vs_conn *cp;\r\nhash = ip_vs_conn_hashkey_param(p, false);\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(cp, &ip_vs_conn_tab[hash], c_list) {\r\nif (p->cport == cp->cport && p->vport == cp->vport &&\r\ncp->af == p->af &&\r\nip_vs_addr_equal(p->af, p->caddr, &cp->caddr) &&\r\nip_vs_addr_equal(p->af, p->vaddr, &cp->vaddr) &&\r\n((!p->cport) ^ (!(cp->flags & IP_VS_CONN_F_NO_CPORT))) &&\r\np->protocol == cp->protocol &&\r\nip_vs_conn_net_eq(cp, p->net)) {\r\nif (!__ip_vs_conn_get(cp))\r\ncontinue;\r\nrcu_read_unlock();\r\nreturn cp;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn NULL;\r\n}\r\nstruct ip_vs_conn *ip_vs_conn_in_get(const struct ip_vs_conn_param *p)\r\n{\r\nstruct ip_vs_conn *cp;\r\ncp = __ip_vs_conn_in_get(p);\r\nif (!cp && atomic_read(&ip_vs_conn_no_cport_cnt)) {\r\nstruct ip_vs_conn_param cport_zero_p = *p;\r\ncport_zero_p.cport = 0;\r\ncp = __ip_vs_conn_in_get(&cport_zero_p);\r\n}\r\nIP_VS_DBG_BUF(9, "lookup/in %s %s:%d->%s:%d %s\n",\r\nip_vs_proto_name(p->protocol),\r\nIP_VS_DBG_ADDR(p->af, p->caddr), ntohs(p->cport),\r\nIP_VS_DBG_ADDR(p->af, p->vaddr), ntohs(p->vport),\r\ncp ? "hit" : "not hit");\r\nreturn cp;\r\n}\r\nstatic int\r\nip_vs_conn_fill_param_proto(int af, const struct sk_buff *skb,\r\nconst struct ip_vs_iphdr *iph,\r\nint inverse, struct ip_vs_conn_param *p)\r\n{\r\n__be16 _ports[2], *pptr;\r\nstruct net *net = skb_net(skb);\r\npptr = frag_safe_skb_hp(skb, iph->len, sizeof(_ports), _ports, iph);\r\nif (pptr == NULL)\r\nreturn 1;\r\nif (likely(!inverse))\r\nip_vs_conn_fill_param(net, af, iph->protocol, &iph->saddr,\r\npptr[0], &iph->daddr, pptr[1], p);\r\nelse\r\nip_vs_conn_fill_param(net, af, iph->protocol, &iph->daddr,\r\npptr[1], &iph->saddr, pptr[0], p);\r\nreturn 0;\r\n}\r\nstruct ip_vs_conn *\r\nip_vs_conn_in_get_proto(int af, const struct sk_buff *skb,\r\nconst struct ip_vs_iphdr *iph, int inverse)\r\n{\r\nstruct ip_vs_conn_param p;\r\nif (ip_vs_conn_fill_param_proto(af, skb, iph, inverse, &p))\r\nreturn NULL;\r\nreturn ip_vs_conn_in_get(&p);\r\n}\r\nstruct ip_vs_conn *ip_vs_ct_in_get(const struct ip_vs_conn_param *p)\r\n{\r\nunsigned int hash;\r\nstruct ip_vs_conn *cp;\r\nhash = ip_vs_conn_hashkey_param(p, false);\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(cp, &ip_vs_conn_tab[hash], c_list) {\r\nif (unlikely(p->pe_data && p->pe->ct_match)) {\r\nif (!ip_vs_conn_net_eq(cp, p->net))\r\ncontinue;\r\nif (p->pe == cp->pe && p->pe->ct_match(p, cp)) {\r\nif (__ip_vs_conn_get(cp))\r\ngoto out;\r\n}\r\ncontinue;\r\n}\r\nif (cp->af == p->af &&\r\nip_vs_addr_equal(p->af, p->caddr, &cp->caddr) &&\r\nip_vs_addr_equal(p->protocol == IPPROTO_IP ? AF_UNSPEC :\r\np->af, p->vaddr, &cp->vaddr) &&\r\np->vport == cp->vport && p->cport == cp->cport &&\r\ncp->flags & IP_VS_CONN_F_TEMPLATE &&\r\np->protocol == cp->protocol &&\r\nip_vs_conn_net_eq(cp, p->net)) {\r\nif (__ip_vs_conn_get(cp))\r\ngoto out;\r\n}\r\n}\r\ncp = NULL;\r\nout:\r\nrcu_read_unlock();\r\nIP_VS_DBG_BUF(9, "template lookup/in %s %s:%d->%s:%d %s\n",\r\nip_vs_proto_name(p->protocol),\r\nIP_VS_DBG_ADDR(p->af, p->caddr), ntohs(p->cport),\r\nIP_VS_DBG_ADDR(p->af, p->vaddr), ntohs(p->vport),\r\ncp ? "hit" : "not hit");\r\nreturn cp;\r\n}\r\nstruct ip_vs_conn *ip_vs_conn_out_get(const struct ip_vs_conn_param *p)\r\n{\r\nunsigned int hash;\r\nstruct ip_vs_conn *cp, *ret=NULL;\r\nhash = ip_vs_conn_hashkey_param(p, true);\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(cp, &ip_vs_conn_tab[hash], c_list) {\r\nif (p->vport == cp->cport && p->cport == cp->dport &&\r\ncp->af == p->af &&\r\nip_vs_addr_equal(p->af, p->vaddr, &cp->caddr) &&\r\nip_vs_addr_equal(p->af, p->caddr, &cp->daddr) &&\r\np->protocol == cp->protocol &&\r\nip_vs_conn_net_eq(cp, p->net)) {\r\nif (!__ip_vs_conn_get(cp))\r\ncontinue;\r\nret = cp;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nIP_VS_DBG_BUF(9, "lookup/out %s %s:%d->%s:%d %s\n",\r\nip_vs_proto_name(p->protocol),\r\nIP_VS_DBG_ADDR(p->af, p->caddr), ntohs(p->cport),\r\nIP_VS_DBG_ADDR(p->af, p->vaddr), ntohs(p->vport),\r\nret ? "hit" : "not hit");\r\nreturn ret;\r\n}\r\nstruct ip_vs_conn *\r\nip_vs_conn_out_get_proto(int af, const struct sk_buff *skb,\r\nconst struct ip_vs_iphdr *iph, int inverse)\r\n{\r\nstruct ip_vs_conn_param p;\r\nif (ip_vs_conn_fill_param_proto(af, skb, iph, inverse, &p))\r\nreturn NULL;\r\nreturn ip_vs_conn_out_get(&p);\r\n}\r\nvoid ip_vs_conn_put(struct ip_vs_conn *cp)\r\n{\r\nunsigned long t = (cp->flags & IP_VS_CONN_F_ONE_PACKET) ?\r\n0 : cp->timeout;\r\nmod_timer(&cp->timer, jiffies+t);\r\n__ip_vs_conn_put(cp);\r\n}\r\nvoid ip_vs_conn_fill_cport(struct ip_vs_conn *cp, __be16 cport)\r\n{\r\nif (ip_vs_conn_unhash(cp)) {\r\nspin_lock_bh(&cp->lock);\r\nif (cp->flags & IP_VS_CONN_F_NO_CPORT) {\r\natomic_dec(&ip_vs_conn_no_cport_cnt);\r\ncp->flags &= ~IP_VS_CONN_F_NO_CPORT;\r\ncp->cport = cport;\r\n}\r\nspin_unlock_bh(&cp->lock);\r\nip_vs_conn_hash(cp);\r\n}\r\n}\r\nstatic inline void ip_vs_bind_xmit(struct ip_vs_conn *cp)\r\n{\r\nswitch (IP_VS_FWD_METHOD(cp)) {\r\ncase IP_VS_CONN_F_MASQ:\r\ncp->packet_xmit = ip_vs_nat_xmit;\r\nbreak;\r\ncase IP_VS_CONN_F_TUNNEL:\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (cp->daf == AF_INET6)\r\ncp->packet_xmit = ip_vs_tunnel_xmit_v6;\r\nelse\r\n#endif\r\ncp->packet_xmit = ip_vs_tunnel_xmit;\r\nbreak;\r\ncase IP_VS_CONN_F_DROUTE:\r\ncp->packet_xmit = ip_vs_dr_xmit;\r\nbreak;\r\ncase IP_VS_CONN_F_LOCALNODE:\r\ncp->packet_xmit = ip_vs_null_xmit;\r\nbreak;\r\ncase IP_VS_CONN_F_BYPASS:\r\ncp->packet_xmit = ip_vs_bypass_xmit;\r\nbreak;\r\n}\r\n}\r\nstatic inline void ip_vs_bind_xmit_v6(struct ip_vs_conn *cp)\r\n{\r\nswitch (IP_VS_FWD_METHOD(cp)) {\r\ncase IP_VS_CONN_F_MASQ:\r\ncp->packet_xmit = ip_vs_nat_xmit_v6;\r\nbreak;\r\ncase IP_VS_CONN_F_TUNNEL:\r\nif (cp->daf == AF_INET6)\r\ncp->packet_xmit = ip_vs_tunnel_xmit_v6;\r\nelse\r\ncp->packet_xmit = ip_vs_tunnel_xmit;\r\nbreak;\r\ncase IP_VS_CONN_F_DROUTE:\r\ncp->packet_xmit = ip_vs_dr_xmit_v6;\r\nbreak;\r\ncase IP_VS_CONN_F_LOCALNODE:\r\ncp->packet_xmit = ip_vs_null_xmit;\r\nbreak;\r\ncase IP_VS_CONN_F_BYPASS:\r\ncp->packet_xmit = ip_vs_bypass_xmit_v6;\r\nbreak;\r\n}\r\n}\r\nstatic inline int ip_vs_dest_totalconns(struct ip_vs_dest *dest)\r\n{\r\nreturn atomic_read(&dest->activeconns)\r\n+ atomic_read(&dest->inactconns);\r\n}\r\nstatic inline void\r\nip_vs_bind_dest(struct ip_vs_conn *cp, struct ip_vs_dest *dest)\r\n{\r\nunsigned int conn_flags;\r\n__u32 flags;\r\nif (!dest)\r\nreturn;\r\nip_vs_dest_hold(dest);\r\nconn_flags = atomic_read(&dest->conn_flags);\r\nif (cp->protocol != IPPROTO_UDP)\r\nconn_flags &= ~IP_VS_CONN_F_ONE_PACKET;\r\nflags = cp->flags;\r\nif (flags & IP_VS_CONN_F_SYNC) {\r\nif (!(flags & IP_VS_CONN_F_TEMPLATE))\r\nconn_flags &= ~IP_VS_CONN_F_INACTIVE;\r\nflags &= ~(IP_VS_CONN_F_FWD_MASK | IP_VS_CONN_F_NOOUTPUT);\r\n}\r\nflags |= conn_flags;\r\ncp->flags = flags;\r\ncp->dest = dest;\r\nIP_VS_DBG_BUF(7, "Bind-dest %s c:%s:%d v:%s:%d "\r\n"d:%s:%d fwd:%c s:%u conn->flags:%X conn->refcnt:%d "\r\n"dest->refcnt:%d\n",\r\nip_vs_proto_name(cp->protocol),\r\nIP_VS_DBG_ADDR(cp->af, &cp->caddr), ntohs(cp->cport),\r\nIP_VS_DBG_ADDR(cp->af, &cp->vaddr), ntohs(cp->vport),\r\nIP_VS_DBG_ADDR(cp->daf, &cp->daddr), ntohs(cp->dport),\r\nip_vs_fwd_tag(cp), cp->state,\r\ncp->flags, atomic_read(&cp->refcnt),\r\natomic_read(&dest->refcnt));\r\nif (!(flags & IP_VS_CONN_F_TEMPLATE)) {\r\nif (!(flags & IP_VS_CONN_F_INACTIVE))\r\natomic_inc(&dest->activeconns);\r\nelse\r\natomic_inc(&dest->inactconns);\r\n} else {\r\natomic_inc(&dest->persistconns);\r\n}\r\nif (dest->u_threshold != 0 &&\r\nip_vs_dest_totalconns(dest) >= dest->u_threshold)\r\ndest->flags |= IP_VS_DEST_F_OVERLOAD;\r\n}\r\nvoid ip_vs_try_bind_dest(struct ip_vs_conn *cp)\r\n{\r\nstruct ip_vs_dest *dest;\r\nrcu_read_lock();\r\ndest = ip_vs_find_dest(ip_vs_conn_net(cp), cp->af, cp->af, &cp->daddr,\r\ncp->dport, &cp->vaddr, cp->vport,\r\ncp->protocol, cp->fwmark, cp->flags);\r\nif (dest) {\r\nstruct ip_vs_proto_data *pd;\r\nspin_lock_bh(&cp->lock);\r\nif (cp->dest) {\r\nspin_unlock_bh(&cp->lock);\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\nif (cp->app)\r\nip_vs_unbind_app(cp);\r\nip_vs_bind_dest(cp, dest);\r\nspin_unlock_bh(&cp->lock);\r\ncp->packet_xmit = NULL;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (cp->af == AF_INET6)\r\nip_vs_bind_xmit_v6(cp);\r\nelse\r\n#endif\r\nip_vs_bind_xmit(cp);\r\npd = ip_vs_proto_data_get(ip_vs_conn_net(cp), cp->protocol);\r\nif (pd && atomic_read(&pd->appcnt))\r\nip_vs_bind_app(cp, pd->pp);\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic inline void ip_vs_unbind_dest(struct ip_vs_conn *cp)\r\n{\r\nstruct ip_vs_dest *dest = cp->dest;\r\nif (!dest)\r\nreturn;\r\nIP_VS_DBG_BUF(7, "Unbind-dest %s c:%s:%d v:%s:%d "\r\n"d:%s:%d fwd:%c s:%u conn->flags:%X conn->refcnt:%d "\r\n"dest->refcnt:%d\n",\r\nip_vs_proto_name(cp->protocol),\r\nIP_VS_DBG_ADDR(cp->af, &cp->caddr), ntohs(cp->cport),\r\nIP_VS_DBG_ADDR(cp->af, &cp->vaddr), ntohs(cp->vport),\r\nIP_VS_DBG_ADDR(cp->daf, &cp->daddr), ntohs(cp->dport),\r\nip_vs_fwd_tag(cp), cp->state,\r\ncp->flags, atomic_read(&cp->refcnt),\r\natomic_read(&dest->refcnt));\r\nif (!(cp->flags & IP_VS_CONN_F_TEMPLATE)) {\r\nif (cp->flags & IP_VS_CONN_F_INACTIVE) {\r\natomic_dec(&dest->inactconns);\r\n} else {\r\natomic_dec(&dest->activeconns);\r\n}\r\n} else {\r\natomic_dec(&dest->persistconns);\r\n}\r\nif (dest->l_threshold != 0) {\r\nif (ip_vs_dest_totalconns(dest) < dest->l_threshold)\r\ndest->flags &= ~IP_VS_DEST_F_OVERLOAD;\r\n} else if (dest->u_threshold != 0) {\r\nif (ip_vs_dest_totalconns(dest) * 4 < dest->u_threshold * 3)\r\ndest->flags &= ~IP_VS_DEST_F_OVERLOAD;\r\n} else {\r\nif (dest->flags & IP_VS_DEST_F_OVERLOAD)\r\ndest->flags &= ~IP_VS_DEST_F_OVERLOAD;\r\n}\r\nip_vs_dest_put(dest);\r\n}\r\nstatic int expire_quiescent_template(struct netns_ipvs *ipvs,\r\nstruct ip_vs_dest *dest)\r\n{\r\n#ifdef CONFIG_SYSCTL\r\nreturn ipvs->sysctl_expire_quiescent_template &&\r\n(atomic_read(&dest->weight) == 0);\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nint ip_vs_check_template(struct ip_vs_conn *ct)\r\n{\r\nstruct ip_vs_dest *dest = ct->dest;\r\nstruct netns_ipvs *ipvs = net_ipvs(ip_vs_conn_net(ct));\r\nif ((dest == NULL) ||\r\n!(dest->flags & IP_VS_DEST_F_AVAILABLE) ||\r\nexpire_quiescent_template(ipvs, dest)) {\r\nIP_VS_DBG_BUF(9, "check_template: dest not available for "\r\n"protocol %s s:%s:%d v:%s:%d "\r\n"-> d:%s:%d\n",\r\nip_vs_proto_name(ct->protocol),\r\nIP_VS_DBG_ADDR(ct->af, &ct->caddr),\r\nntohs(ct->cport),\r\nIP_VS_DBG_ADDR(ct->af, &ct->vaddr),\r\nntohs(ct->vport),\r\nIP_VS_DBG_ADDR(ct->daf, &ct->daddr),\r\nntohs(ct->dport));\r\nif (ct->vport != htons(0xffff)) {\r\nif (ip_vs_conn_unhash(ct)) {\r\nct->dport = htons(0xffff);\r\nct->vport = htons(0xffff);\r\nct->cport = 0;\r\nip_vs_conn_hash(ct);\r\n}\r\n}\r\n__ip_vs_conn_put(ct);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void ip_vs_conn_rcu_free(struct rcu_head *head)\r\n{\r\nstruct ip_vs_conn *cp = container_of(head, struct ip_vs_conn,\r\nrcu_head);\r\nip_vs_pe_put(cp->pe);\r\nkfree(cp->pe_data);\r\nkmem_cache_free(ip_vs_conn_cachep, cp);\r\n}\r\nstatic void ip_vs_conn_expire(unsigned long data)\r\n{\r\nstruct ip_vs_conn *cp = (struct ip_vs_conn *)data;\r\nstruct net *net = ip_vs_conn_net(cp);\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\nif (atomic_read(&cp->n_control))\r\ngoto expire_later;\r\nif (likely(ip_vs_conn_unlink(cp))) {\r\ndel_timer(&cp->timer);\r\nif (cp->control)\r\nip_vs_control_del(cp);\r\nif (cp->flags & IP_VS_CONN_F_NFCT) {\r\nsmp_rmb();\r\nif (ipvs->enable)\r\nip_vs_conn_drop_conntrack(cp);\r\n}\r\nif (unlikely(cp->app != NULL))\r\nip_vs_unbind_app(cp);\r\nip_vs_unbind_dest(cp);\r\nif (cp->flags & IP_VS_CONN_F_NO_CPORT)\r\natomic_dec(&ip_vs_conn_no_cport_cnt);\r\ncall_rcu(&cp->rcu_head, ip_vs_conn_rcu_free);\r\natomic_dec(&ipvs->conn_count);\r\nreturn;\r\n}\r\nexpire_later:\r\nIP_VS_DBG(7, "delayed: conn->refcnt=%d conn->n_control=%d\n",\r\natomic_read(&cp->refcnt),\r\natomic_read(&cp->n_control));\r\natomic_inc(&cp->refcnt);\r\ncp->timeout = 60*HZ;\r\nif (ipvs->sync_state & IP_VS_STATE_MASTER)\r\nip_vs_sync_conn(net, cp, sysctl_sync_threshold(ipvs));\r\nip_vs_conn_put(cp);\r\n}\r\nvoid ip_vs_conn_expire_now(struct ip_vs_conn *cp)\r\n{\r\nif (timer_pending(&cp->timer) &&\r\ntime_after(cp->timer.expires, jiffies))\r\nmod_timer_pending(&cp->timer, jiffies);\r\n}\r\nstruct ip_vs_conn *\r\nip_vs_conn_new(const struct ip_vs_conn_param *p, int dest_af,\r\nconst union nf_inet_addr *daddr, __be16 dport, unsigned int flags,\r\nstruct ip_vs_dest *dest, __u32 fwmark)\r\n{\r\nstruct ip_vs_conn *cp;\r\nstruct netns_ipvs *ipvs = net_ipvs(p->net);\r\nstruct ip_vs_proto_data *pd = ip_vs_proto_data_get(p->net,\r\np->protocol);\r\ncp = kmem_cache_alloc(ip_vs_conn_cachep, GFP_ATOMIC);\r\nif (cp == NULL) {\r\nIP_VS_ERR_RL("%s(): no memory\n", __func__);\r\nreturn NULL;\r\n}\r\nINIT_HLIST_NODE(&cp->c_list);\r\nsetup_timer(&cp->timer, ip_vs_conn_expire, (unsigned long)cp);\r\nip_vs_conn_net_set(cp, p->net);\r\ncp->af = p->af;\r\ncp->daf = dest_af;\r\ncp->protocol = p->protocol;\r\nip_vs_addr_set(p->af, &cp->caddr, p->caddr);\r\ncp->cport = p->cport;\r\nip_vs_addr_set(p->protocol == IPPROTO_IP ? AF_UNSPEC : p->af,\r\n&cp->vaddr, p->vaddr);\r\ncp->vport = p->vport;\r\nip_vs_addr_set(cp->daf, &cp->daddr, daddr);\r\ncp->dport = dport;\r\ncp->flags = flags;\r\ncp->fwmark = fwmark;\r\nif (flags & IP_VS_CONN_F_TEMPLATE && p->pe) {\r\nip_vs_pe_get(p->pe);\r\ncp->pe = p->pe;\r\ncp->pe_data = p->pe_data;\r\ncp->pe_data_len = p->pe_data_len;\r\n} else {\r\ncp->pe = NULL;\r\ncp->pe_data = NULL;\r\ncp->pe_data_len = 0;\r\n}\r\nspin_lock_init(&cp->lock);\r\natomic_set(&cp->refcnt, 1);\r\ncp->control = NULL;\r\natomic_set(&cp->n_control, 0);\r\natomic_set(&cp->in_pkts, 0);\r\ncp->packet_xmit = NULL;\r\ncp->app = NULL;\r\ncp->app_data = NULL;\r\ncp->in_seq.delta = 0;\r\ncp->out_seq.delta = 0;\r\natomic_inc(&ipvs->conn_count);\r\nif (flags & IP_VS_CONN_F_NO_CPORT)\r\natomic_inc(&ip_vs_conn_no_cport_cnt);\r\ncp->dest = NULL;\r\nip_vs_bind_dest(cp, dest);\r\ncp->state = 0;\r\ncp->old_state = 0;\r\ncp->timeout = 3*HZ;\r\ncp->sync_endtime = jiffies & ~3UL;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (p->af == AF_INET6)\r\nip_vs_bind_xmit_v6(cp);\r\nelse\r\n#endif\r\nip_vs_bind_xmit(cp);\r\nif (unlikely(pd && atomic_read(&pd->appcnt)))\r\nip_vs_bind_app(cp, pd->pp);\r\nif (ip_vs_conntrack_enabled(ipvs))\r\ncp->flags |= IP_VS_CONN_F_NFCT;\r\nip_vs_conn_hash(cp);\r\nreturn cp;\r\n}\r\nstatic void *ip_vs_conn_array(struct seq_file *seq, loff_t pos)\r\n{\r\nint idx;\r\nstruct ip_vs_conn *cp;\r\nstruct ip_vs_iter_state *iter = seq->private;\r\nfor (idx = 0; idx < ip_vs_conn_tab_size; idx++) {\r\nhlist_for_each_entry_rcu(cp, &ip_vs_conn_tab[idx], c_list) {\r\nif (pos-- == 0) {\r\niter->l = &ip_vs_conn_tab[idx];\r\nreturn cp;\r\n}\r\n}\r\ncond_resched_rcu();\r\n}\r\nreturn NULL;\r\n}\r\nstatic void *ip_vs_conn_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(RCU)\r\n{\r\nstruct ip_vs_iter_state *iter = seq->private;\r\niter->l = NULL;\r\nrcu_read_lock();\r\nreturn *pos ? ip_vs_conn_array(seq, *pos - 1) :SEQ_START_TOKEN;\r\n}\r\nstatic void *ip_vs_conn_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct ip_vs_conn *cp = v;\r\nstruct ip_vs_iter_state *iter = seq->private;\r\nstruct hlist_node *e;\r\nstruct hlist_head *l = iter->l;\r\nint idx;\r\n++*pos;\r\nif (v == SEQ_START_TOKEN)\r\nreturn ip_vs_conn_array(seq, 0);\r\ne = rcu_dereference(hlist_next_rcu(&cp->c_list));\r\nif (e)\r\nreturn hlist_entry(e, struct ip_vs_conn, c_list);\r\nidx = l - ip_vs_conn_tab;\r\nwhile (++idx < ip_vs_conn_tab_size) {\r\nhlist_for_each_entry_rcu(cp, &ip_vs_conn_tab[idx], c_list) {\r\niter->l = &ip_vs_conn_tab[idx];\r\nreturn cp;\r\n}\r\ncond_resched_rcu();\r\n}\r\niter->l = NULL;\r\nreturn NULL;\r\n}\r\nstatic void ip_vs_conn_seq_stop(struct seq_file *seq, void *v)\r\n__releases(RCU)\r\n{\r\nrcu_read_unlock();\r\n}\r\nstatic int ip_vs_conn_seq_show(struct seq_file *seq, void *v)\r\n{\r\nif (v == SEQ_START_TOKEN)\r\nseq_puts(seq,\r\n"Pro FromIP FPrt ToIP TPrt DestIP DPrt State Expires PEName PEData\n");\r\nelse {\r\nconst struct ip_vs_conn *cp = v;\r\nstruct net *net = seq_file_net(seq);\r\nchar pe_data[IP_VS_PENAME_MAXLEN + IP_VS_PEDATA_MAXLEN + 3];\r\nsize_t len = 0;\r\nchar dbuf[IP_VS_ADDRSTRLEN];\r\nif (!ip_vs_conn_net_eq(cp, net))\r\nreturn 0;\r\nif (cp->pe_data) {\r\npe_data[0] = ' ';\r\nlen = strlen(cp->pe->name);\r\nmemcpy(pe_data + 1, cp->pe->name, len);\r\npe_data[len + 1] = ' ';\r\nlen += 2;\r\nlen += cp->pe->show_pe_data(cp, pe_data + len);\r\n}\r\npe_data[len] = '\0';\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (cp->daf == AF_INET6)\r\nsnprintf(dbuf, sizeof(dbuf), "%pI6", &cp->daddr.in6);\r\nelse\r\n#endif\r\nsnprintf(dbuf, sizeof(dbuf), "%08X",\r\nntohl(cp->daddr.ip));\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (cp->af == AF_INET6)\r\nseq_printf(seq, "%-3s %pI6 %04X %pI6 %04X "\r\n"%s %04X %-11s %7lu%s\n",\r\nip_vs_proto_name(cp->protocol),\r\n&cp->caddr.in6, ntohs(cp->cport),\r\n&cp->vaddr.in6, ntohs(cp->vport),\r\ndbuf, ntohs(cp->dport),\r\nip_vs_state_name(cp->protocol, cp->state),\r\n(cp->timer.expires-jiffies)/HZ, pe_data);\r\nelse\r\n#endif\r\nseq_printf(seq,\r\n"%-3s %08X %04X %08X %04X"\r\n" %s %04X %-11s %7lu%s\n",\r\nip_vs_proto_name(cp->protocol),\r\nntohl(cp->caddr.ip), ntohs(cp->cport),\r\nntohl(cp->vaddr.ip), ntohs(cp->vport),\r\ndbuf, ntohs(cp->dport),\r\nip_vs_state_name(cp->protocol, cp->state),\r\n(cp->timer.expires-jiffies)/HZ, pe_data);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ip_vs_conn_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &ip_vs_conn_seq_ops,\r\nsizeof(struct ip_vs_iter_state));\r\n}\r\nstatic const char *ip_vs_origin_name(unsigned int flags)\r\n{\r\nif (flags & IP_VS_CONN_F_SYNC)\r\nreturn "SYNC";\r\nelse\r\nreturn "LOCAL";\r\n}\r\nstatic int ip_vs_conn_sync_seq_show(struct seq_file *seq, void *v)\r\n{\r\nchar dbuf[IP_VS_ADDRSTRLEN];\r\nif (v == SEQ_START_TOKEN)\r\nseq_puts(seq,\r\n"Pro FromIP FPrt ToIP TPrt DestIP DPrt State Origin Expires\n");\r\nelse {\r\nconst struct ip_vs_conn *cp = v;\r\nstruct net *net = seq_file_net(seq);\r\nif (!ip_vs_conn_net_eq(cp, net))\r\nreturn 0;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (cp->daf == AF_INET6)\r\nsnprintf(dbuf, sizeof(dbuf), "%pI6", &cp->daddr.in6);\r\nelse\r\n#endif\r\nsnprintf(dbuf, sizeof(dbuf), "%08X",\r\nntohl(cp->daddr.ip));\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (cp->af == AF_INET6)\r\nseq_printf(seq, "%-3s %pI6 %04X %pI6 %04X "\r\n"%s %04X %-11s %-6s %7lu\n",\r\nip_vs_proto_name(cp->protocol),\r\n&cp->caddr.in6, ntohs(cp->cport),\r\n&cp->vaddr.in6, ntohs(cp->vport),\r\ndbuf, ntohs(cp->dport),\r\nip_vs_state_name(cp->protocol, cp->state),\r\nip_vs_origin_name(cp->flags),\r\n(cp->timer.expires-jiffies)/HZ);\r\nelse\r\n#endif\r\nseq_printf(seq,\r\n"%-3s %08X %04X %08X %04X "\r\n"%s %04X %-11s %-6s %7lu\n",\r\nip_vs_proto_name(cp->protocol),\r\nntohl(cp->caddr.ip), ntohs(cp->cport),\r\nntohl(cp->vaddr.ip), ntohs(cp->vport),\r\ndbuf, ntohs(cp->dport),\r\nip_vs_state_name(cp->protocol, cp->state),\r\nip_vs_origin_name(cp->flags),\r\n(cp->timer.expires-jiffies)/HZ);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ip_vs_conn_sync_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &ip_vs_conn_sync_seq_ops,\r\nsizeof(struct ip_vs_iter_state));\r\n}\r\nstatic inline int todrop_entry(struct ip_vs_conn *cp)\r\n{\r\nstatic const char todrop_rate[9] = {0, 1, 2, 3, 4, 5, 6, 7, 8};\r\nstatic char todrop_counter[9] = {0};\r\nint i;\r\nif (time_before(cp->timeout + jiffies, cp->timer.expires + 60*HZ))\r\nreturn 0;\r\ni = atomic_read(&cp->in_pkts);\r\nif (i > 8 || i < 0) return 0;\r\nif (!todrop_rate[i]) return 0;\r\nif (--todrop_counter[i] > 0) return 0;\r\ntodrop_counter[i] = todrop_rate[i];\r\nreturn 1;\r\n}\r\nvoid ip_vs_random_dropentry(struct net *net)\r\n{\r\nint idx;\r\nstruct ip_vs_conn *cp, *cp_c;\r\nrcu_read_lock();\r\nfor (idx = 0; idx < (ip_vs_conn_tab_size>>5); idx++) {\r\nunsigned int hash = prandom_u32() & ip_vs_conn_tab_mask;\r\nhlist_for_each_entry_rcu(cp, &ip_vs_conn_tab[hash], c_list) {\r\nif (cp->flags & IP_VS_CONN_F_TEMPLATE)\r\ncontinue;\r\nif (!ip_vs_conn_net_eq(cp, net))\r\ncontinue;\r\nif (cp->protocol == IPPROTO_TCP) {\r\nswitch(cp->state) {\r\ncase IP_VS_TCP_S_SYN_RECV:\r\ncase IP_VS_TCP_S_SYNACK:\r\nbreak;\r\ncase IP_VS_TCP_S_ESTABLISHED:\r\nif (todrop_entry(cp))\r\nbreak;\r\ncontinue;\r\ndefault:\r\ncontinue;\r\n}\r\n} else if (cp->protocol == IPPROTO_SCTP) {\r\nswitch (cp->state) {\r\ncase IP_VS_SCTP_S_INIT1:\r\ncase IP_VS_SCTP_S_INIT:\r\nbreak;\r\ncase IP_VS_SCTP_S_ESTABLISHED:\r\nif (todrop_entry(cp))\r\nbreak;\r\ncontinue;\r\ndefault:\r\ncontinue;\r\n}\r\n} else {\r\nif (!todrop_entry(cp))\r\ncontinue;\r\n}\r\nIP_VS_DBG(4, "del connection\n");\r\nip_vs_conn_expire_now(cp);\r\ncp_c = cp->control;\r\nif (cp_c && __ip_vs_conn_get(cp)) {\r\nIP_VS_DBG(4, "del conn template\n");\r\nip_vs_conn_expire_now(cp_c);\r\n__ip_vs_conn_put(cp);\r\n}\r\n}\r\ncond_resched_rcu();\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void ip_vs_conn_flush(struct net *net)\r\n{\r\nint idx;\r\nstruct ip_vs_conn *cp, *cp_c;\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\nflush_again:\r\nrcu_read_lock();\r\nfor (idx = 0; idx < ip_vs_conn_tab_size; idx++) {\r\nhlist_for_each_entry_rcu(cp, &ip_vs_conn_tab[idx], c_list) {\r\nif (!ip_vs_conn_net_eq(cp, net))\r\ncontinue;\r\nIP_VS_DBG(4, "del connection\n");\r\nip_vs_conn_expire_now(cp);\r\ncp_c = cp->control;\r\nif (cp_c && __ip_vs_conn_get(cp)) {\r\nIP_VS_DBG(4, "del conn template\n");\r\nip_vs_conn_expire_now(cp_c);\r\n__ip_vs_conn_put(cp);\r\n}\r\n}\r\ncond_resched_rcu();\r\n}\r\nrcu_read_unlock();\r\nif (atomic_read(&ipvs->conn_count) != 0) {\r\nschedule();\r\ngoto flush_again;\r\n}\r\n}\r\nint __net_init ip_vs_conn_net_init(struct net *net)\r\n{\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\natomic_set(&ipvs->conn_count, 0);\r\nproc_create("ip_vs_conn", 0, net->proc_net, &ip_vs_conn_fops);\r\nproc_create("ip_vs_conn_sync", 0, net->proc_net, &ip_vs_conn_sync_fops);\r\nreturn 0;\r\n}\r\nvoid __net_exit ip_vs_conn_net_cleanup(struct net *net)\r\n{\r\nip_vs_conn_flush(net);\r\nremove_proc_entry("ip_vs_conn", net->proc_net);\r\nremove_proc_entry("ip_vs_conn_sync", net->proc_net);\r\n}\r\nint __init ip_vs_conn_init(void)\r\n{\r\nint idx;\r\nip_vs_conn_tab_size = 1 << ip_vs_conn_tab_bits;\r\nip_vs_conn_tab_mask = ip_vs_conn_tab_size - 1;\r\nip_vs_conn_tab = vmalloc(ip_vs_conn_tab_size * sizeof(*ip_vs_conn_tab));\r\nif (!ip_vs_conn_tab)\r\nreturn -ENOMEM;\r\nip_vs_conn_cachep = kmem_cache_create("ip_vs_conn",\r\nsizeof(struct ip_vs_conn), 0,\r\nSLAB_HWCACHE_ALIGN, NULL);\r\nif (!ip_vs_conn_cachep) {\r\nvfree(ip_vs_conn_tab);\r\nreturn -ENOMEM;\r\n}\r\npr_info("Connection hash table configured "\r\n"(size=%d, memory=%ldKbytes)\n",\r\nip_vs_conn_tab_size,\r\n(long)(ip_vs_conn_tab_size*sizeof(struct list_head))/1024);\r\nIP_VS_DBG(0, "Each connection entry needs %Zd bytes at least\n",\r\nsizeof(struct ip_vs_conn));\r\nfor (idx = 0; idx < ip_vs_conn_tab_size; idx++)\r\nINIT_HLIST_HEAD(&ip_vs_conn_tab[idx]);\r\nfor (idx = 0; idx < CT_LOCKARRAY_SIZE; idx++) {\r\nspin_lock_init(&__ip_vs_conntbl_lock_array[idx].l);\r\n}\r\nget_random_bytes(&ip_vs_conn_rnd, sizeof(ip_vs_conn_rnd));\r\nreturn 0;\r\n}\r\nvoid ip_vs_conn_cleanup(void)\r\n{\r\nrcu_barrier();\r\nkmem_cache_destroy(ip_vs_conn_cachep);\r\nvfree(ip_vs_conn_tab);\r\n}
