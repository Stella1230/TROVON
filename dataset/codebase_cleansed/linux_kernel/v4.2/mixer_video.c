static int find_reg_callback(struct device *dev, void *p)\r\n{\r\nstruct v4l2_subdev **sd = p;\r\n*sd = dev_get_drvdata(dev);\r\nreturn 1;\r\n}\r\nstatic struct v4l2_subdev *find_and_register_subdev(\r\nstruct mxr_device *mdev, char *module_name)\r\n{\r\nstruct device_driver *drv;\r\nstruct v4l2_subdev *sd = NULL;\r\nint ret;\r\ndrv = driver_find(module_name, &platform_bus_type);\r\nif (!drv) {\r\nmxr_warn(mdev, "module %s is missing\n", module_name);\r\nreturn NULL;\r\n}\r\nret = driver_for_each_device(drv, NULL, &sd, find_reg_callback);\r\nif (sd == NULL) {\r\nmxr_warn(mdev, "module %s provides no subdev!\n", module_name);\r\ngoto done;\r\n}\r\nret = v4l2_device_register_subdev(&mdev->v4l2_dev, sd);\r\nif (ret) {\r\nmxr_warn(mdev, "failed to register subdev %s\n", sd->name);\r\nsd = NULL;\r\n}\r\ndone:\r\nreturn sd;\r\n}\r\nint mxr_acquire_video(struct mxr_device *mdev,\r\nstruct mxr_output_conf *output_conf, int output_count)\r\n{\r\nstruct device *dev = mdev->dev;\r\nstruct v4l2_device *v4l2_dev = &mdev->v4l2_dev;\r\nint i;\r\nint ret = 0;\r\nstruct v4l2_subdev *sd;\r\nstrlcpy(v4l2_dev->name, dev_name(mdev->dev), sizeof(v4l2_dev->name));\r\nret = v4l2_device_register(dev, v4l2_dev);\r\nif (ret) {\r\nmxr_err(mdev, "could not register v4l2 device.\n");\r\ngoto fail;\r\n}\r\nmdev->alloc_ctx = vb2_dma_contig_init_ctx(mdev->dev);\r\nif (IS_ERR(mdev->alloc_ctx)) {\r\nmxr_err(mdev, "could not acquire vb2 allocator\n");\r\nret = PTR_ERR(mdev->alloc_ctx);\r\ngoto fail_v4l2_dev;\r\n}\r\nmdev->output_cnt = 0;\r\nfor (i = 0; i < output_count; ++i) {\r\nstruct mxr_output_conf *conf = &output_conf[i];\r\nstruct mxr_output *out;\r\nsd = find_and_register_subdev(mdev, conf->module_name);\r\nif (sd == NULL)\r\ncontinue;\r\nout = kzalloc(sizeof(*out), GFP_KERNEL);\r\nif (out == NULL) {\r\nmxr_err(mdev, "no memory for '%s'\n",\r\nconf->output_name);\r\nret = -ENOMEM;\r\ngoto fail_output;\r\n}\r\nstrlcpy(out->name, conf->output_name, sizeof(out->name));\r\nout->sd = sd;\r\nout->cookie = conf->cookie;\r\nmdev->output[mdev->output_cnt++] = out;\r\nmxr_info(mdev, "added output '%s' from module '%s'\n",\r\nconf->output_name, conf->module_name);\r\nif (mdev->output_cnt >= MXR_MAX_OUTPUTS)\r\nbreak;\r\n}\r\nif (mdev->output_cnt == 0) {\r\nmxr_err(mdev, "failed to register any output\n");\r\nret = -ENODEV;\r\ngoto fail_vb2_allocator;\r\n}\r\nreturn 0;\r\nfail_output:\r\nfor (i = 0; i < mdev->output_cnt; ++i)\r\nkfree(mdev->output[i]);\r\nmemset(mdev->output, 0, sizeof(mdev->output));\r\nfail_vb2_allocator:\r\nvb2_dma_contig_cleanup_ctx(mdev->alloc_ctx);\r\nfail_v4l2_dev:\r\nv4l2_device_unregister(v4l2_dev);\r\nfail:\r\nreturn ret;\r\n}\r\nvoid mxr_release_video(struct mxr_device *mdev)\r\n{\r\nint i;\r\nfor (i = 0; i < mdev->output_cnt; ++i)\r\nkfree(mdev->output[i]);\r\nvb2_dma_contig_cleanup_ctx(mdev->alloc_ctx);\r\nv4l2_device_unregister(&mdev->v4l2_dev);\r\n}\r\nstatic int mxr_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct mxr_layer *layer = video_drvdata(file);\r\nmxr_dbg(layer->mdev, "%s:%d\n", __func__, __LINE__);\r\nstrlcpy(cap->driver, MXR_DRIVER_NAME, sizeof(cap->driver));\r\nstrlcpy(cap->card, layer->vfd.name, sizeof(cap->card));\r\nsprintf(cap->bus_info, "%d", layer->idx);\r\ncap->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_OUTPUT_MPLANE;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic void mxr_geometry_dump(struct mxr_device *mdev, struct mxr_geometry *geo)\r\n{\r\nmxr_dbg(mdev, "src.full_size = (%u, %u)\n",\r\ngeo->src.full_width, geo->src.full_height);\r\nmxr_dbg(mdev, "src.size = (%u, %u)\n",\r\ngeo->src.width, geo->src.height);\r\nmxr_dbg(mdev, "src.offset = (%u, %u)\n",\r\ngeo->src.x_offset, geo->src.y_offset);\r\nmxr_dbg(mdev, "dst.full_size = (%u, %u)\n",\r\ngeo->dst.full_width, geo->dst.full_height);\r\nmxr_dbg(mdev, "dst.size = (%u, %u)\n",\r\ngeo->dst.width, geo->dst.height);\r\nmxr_dbg(mdev, "dst.offset = (%u, %u)\n",\r\ngeo->dst.x_offset, geo->dst.y_offset);\r\nmxr_dbg(mdev, "ratio = (%u, %u)\n",\r\ngeo->x_ratio, geo->y_ratio);\r\n}\r\nstatic void mxr_layer_default_geo(struct mxr_layer *layer)\r\n{\r\nstruct mxr_device *mdev = layer->mdev;\r\nstruct v4l2_mbus_framefmt mbus_fmt;\r\nmemset(&layer->geo, 0, sizeof(layer->geo));\r\nmxr_get_mbus_fmt(mdev, &mbus_fmt);\r\nlayer->geo.dst.full_width = mbus_fmt.width;\r\nlayer->geo.dst.full_height = mbus_fmt.height;\r\nlayer->geo.dst.width = layer->geo.dst.full_width;\r\nlayer->geo.dst.height = layer->geo.dst.full_height;\r\nlayer->geo.dst.field = mbus_fmt.field;\r\nlayer->geo.src.full_width = mbus_fmt.width;\r\nlayer->geo.src.full_height = mbus_fmt.height;\r\nlayer->geo.src.width = layer->geo.src.full_width;\r\nlayer->geo.src.height = layer->geo.src.full_height;\r\nmxr_geometry_dump(mdev, &layer->geo);\r\nlayer->ops.fix_geometry(layer, MXR_GEOMETRY_SINK, 0);\r\nmxr_geometry_dump(mdev, &layer->geo);\r\n}\r\nstatic void mxr_layer_update_output(struct mxr_layer *layer)\r\n{\r\nstruct mxr_device *mdev = layer->mdev;\r\nstruct v4l2_mbus_framefmt mbus_fmt;\r\nmxr_get_mbus_fmt(mdev, &mbus_fmt);\r\nif (layer->geo.dst.full_width == mbus_fmt.width &&\r\nlayer->geo.dst.full_height == mbus_fmt.width)\r\nreturn;\r\nlayer->geo.dst.full_width = mbus_fmt.width;\r\nlayer->geo.dst.full_height = mbus_fmt.height;\r\nlayer->geo.dst.field = mbus_fmt.field;\r\nlayer->ops.fix_geometry(layer, MXR_GEOMETRY_SINK, 0);\r\nmxr_geometry_dump(mdev, &layer->geo);\r\n}\r\nstatic int mxr_enum_fmt(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct mxr_layer *layer = video_drvdata(file);\r\nstruct mxr_device *mdev = layer->mdev;\r\nconst struct mxr_format *fmt;\r\nmxr_dbg(mdev, "%s\n", __func__);\r\nfmt = find_format_by_index(layer, f->index);\r\nif (fmt == NULL)\r\nreturn -EINVAL;\r\nstrlcpy(f->description, fmt->name, sizeof(f->description));\r\nf->pixelformat = fmt->fourcc;\r\nreturn 0;\r\n}\r\nstatic unsigned int divup(unsigned int divident, unsigned int divisor)\r\n{\r\nreturn (divident + divisor - 1) / divisor;\r\n}\r\nunsigned long mxr_get_plane_size(const struct mxr_block *blk,\r\nunsigned int width, unsigned int height)\r\n{\r\nunsigned int bl_width = divup(width, blk->width);\r\nunsigned int bl_height = divup(height, blk->height);\r\nreturn bl_width * bl_height * blk->size;\r\n}\r\nstatic void mxr_mplane_fill(struct v4l2_plane_pix_format *planes,\r\nconst struct mxr_format *fmt, u32 width, u32 height)\r\n{\r\nint i;\r\nif (!planes)\r\nreturn;\r\nmemset(planes, 0, sizeof(*planes) * fmt->num_subframes);\r\nfor (i = 0; i < fmt->num_planes; ++i) {\r\nstruct v4l2_plane_pix_format *plane = planes\r\n+ fmt->plane2subframe[i];\r\nconst struct mxr_block *blk = &fmt->plane[i];\r\nu32 bl_width = divup(width, blk->width);\r\nu32 bl_height = divup(height, blk->height);\r\nu32 sizeimage = bl_width * bl_height * blk->size;\r\nu32 bytesperline = bl_width * blk->size / blk->height;\r\nplane->sizeimage += sizeimage;\r\nplane->bytesperline = max(plane->bytesperline, bytesperline);\r\n}\r\n}\r\nstatic int mxr_g_fmt(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct mxr_layer *layer = video_drvdata(file);\r\nstruct v4l2_pix_format_mplane *pix = &f->fmt.pix_mp;\r\nmxr_dbg(layer->mdev, "%s:%d\n", __func__, __LINE__);\r\npix->width = layer->geo.src.full_width;\r\npix->height = layer->geo.src.full_height;\r\npix->field = V4L2_FIELD_NONE;\r\npix->pixelformat = layer->fmt->fourcc;\r\npix->colorspace = layer->fmt->colorspace;\r\nmxr_mplane_fill(pix->plane_fmt, layer->fmt, pix->width, pix->height);\r\nreturn 0;\r\n}\r\nstatic int mxr_s_fmt(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct mxr_layer *layer = video_drvdata(file);\r\nconst struct mxr_format *fmt;\r\nstruct v4l2_pix_format_mplane *pix;\r\nstruct mxr_device *mdev = layer->mdev;\r\nstruct mxr_geometry *geo = &layer->geo;\r\nmxr_dbg(mdev, "%s:%d\n", __func__, __LINE__);\r\npix = &f->fmt.pix_mp;\r\nfmt = find_format_by_fourcc(layer, pix->pixelformat);\r\nif (fmt == NULL) {\r\nmxr_warn(mdev, "not recognized fourcc: %08x\n",\r\npix->pixelformat);\r\nreturn -EINVAL;\r\n}\r\nlayer->fmt = fmt;\r\ngeo->src.full_width = max(geo->dst.full_width, pix->width);\r\ngeo->src.full_height = max(geo->dst.full_height, pix->height);\r\nlayer->ops.fix_geometry(layer, MXR_GEOMETRY_SOURCE, 0);\r\nmxr_geometry_dump(mdev, &layer->geo);\r\ngeo->src.width = pix->width;\r\ngeo->src.height = pix->height;\r\ngeo->src.x_offset = 0;\r\ngeo->src.y_offset = 0;\r\nlayer->ops.fix_geometry(layer, MXR_GEOMETRY_CROP, MXR_NO_OFFSET);\r\nmxr_geometry_dump(mdev, &layer->geo);\r\ngeo->src.full_width = 0;\r\ngeo->src.full_height = 0;\r\nlayer->ops.fix_geometry(layer, MXR_GEOMETRY_SOURCE, 0);\r\nmxr_geometry_dump(mdev, &layer->geo);\r\nmxr_g_fmt(file, priv, f);\r\nreturn 0;\r\n}\r\nstatic int mxr_g_selection(struct file *file, void *fh,\r\nstruct v4l2_selection *s)\r\n{\r\nstruct mxr_layer *layer = video_drvdata(file);\r\nstruct mxr_geometry *geo = &layer->geo;\r\nmxr_dbg(layer->mdev, "%s:%d\n", __func__, __LINE__);\r\nif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT &&\r\ns->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\r\nreturn -EINVAL;\r\nswitch (s->target) {\r\ncase V4L2_SEL_TGT_CROP:\r\ns->r.left = geo->src.x_offset;\r\ns->r.top = geo->src.y_offset;\r\ns->r.width = geo->src.width;\r\ns->r.height = geo->src.height;\r\nbreak;\r\ncase V4L2_SEL_TGT_CROP_DEFAULT:\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\ns->r.left = 0;\r\ns->r.top = 0;\r\ns->r.width = geo->src.full_width;\r\ns->r.height = geo->src.full_height;\r\nbreak;\r\ncase V4L2_SEL_TGT_COMPOSE:\r\ncase V4L2_SEL_TGT_COMPOSE_PADDED:\r\ns->r.left = geo->dst.x_offset;\r\ns->r.top = geo->dst.y_offset;\r\ns->r.width = geo->dst.width;\r\ns->r.height = geo->dst.height;\r\nbreak;\r\ncase V4L2_SEL_TGT_COMPOSE_DEFAULT:\r\ncase V4L2_SEL_TGT_COMPOSE_BOUNDS:\r\ns->r.left = 0;\r\ns->r.top = 0;\r\ns->r.width = geo->dst.full_width;\r\ns->r.height = geo->dst.full_height;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxr_is_rect_inside(struct v4l2_rect *a, struct v4l2_rect *b)\r\n{\r\nif (a->left < b->left)\r\nreturn 0;\r\nif (a->top < b->top)\r\nreturn 0;\r\nif (a->left + a->width > b->left + b->width)\r\nreturn 0;\r\nif (a->top + a->height > b->top + b->height)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int mxr_s_selection(struct file *file, void *fh,\r\nstruct v4l2_selection *s)\r\n{\r\nstruct mxr_layer *layer = video_drvdata(file);\r\nstruct mxr_geometry *geo = &layer->geo;\r\nstruct mxr_crop *target = NULL;\r\nenum mxr_geometry_stage stage;\r\nstruct mxr_geometry tmp;\r\nstruct v4l2_rect res;\r\nmemset(&res, 0, sizeof(res));\r\nmxr_dbg(layer->mdev, "%s: rect: %dx%d@%d,%d\n", __func__,\r\ns->r.width, s->r.height, s->r.left, s->r.top);\r\nif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT &&\r\ns->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\r\nreturn -EINVAL;\r\nswitch (s->target) {\r\ncase V4L2_SEL_TGT_CROP_DEFAULT:\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\nres.width = geo->src.full_width;\r\nres.height = geo->src.full_height;\r\nbreak;\r\ncase V4L2_SEL_TGT_COMPOSE_DEFAULT:\r\ncase V4L2_SEL_TGT_COMPOSE_BOUNDS:\r\nres.width = geo->dst.full_width;\r\nres.height = geo->dst.full_height;\r\nbreak;\r\ncase V4L2_SEL_TGT_CROP:\r\ntarget = &geo->src;\r\nstage = MXR_GEOMETRY_CROP;\r\nbreak;\r\ncase V4L2_SEL_TGT_COMPOSE:\r\ncase V4L2_SEL_TGT_COMPOSE_PADDED:\r\ntarget = &geo->dst;\r\nstage = MXR_GEOMETRY_COMPOSE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (target) {\r\nmemcpy(&tmp, geo, sizeof(tmp));\r\ntarget->x_offset = s->r.left;\r\ntarget->y_offset = s->r.top;\r\ntarget->width = s->r.width;\r\ntarget->height = s->r.height;\r\nlayer->ops.fix_geometry(layer, stage, s->flags);\r\nres.left = target->x_offset;\r\nres.top = target->y_offset;\r\nres.width = target->width;\r\nres.height = target->height;\r\nmxr_geometry_dump(layer->mdev, &layer->geo);\r\n}\r\nif ((s->flags & V4L2_SEL_FLAG_LE) && !mxr_is_rect_inside(&res, &s->r))\r\ngoto fail;\r\nif ((s->flags & V4L2_SEL_FLAG_GE) && !mxr_is_rect_inside(&s->r, &res))\r\ngoto fail;\r\ns->r = res;\r\nreturn 0;\r\nfail:\r\nif (target)\r\nmemcpy(geo, &tmp, sizeof(tmp));\r\nreturn -ERANGE;\r\n}\r\nstatic int mxr_enum_dv_timings(struct file *file, void *fh,\r\nstruct v4l2_enum_dv_timings *timings)\r\n{\r\nstruct mxr_layer *layer = video_drvdata(file);\r\nstruct mxr_device *mdev = layer->mdev;\r\nint ret;\r\ntimings->pad = 0;\r\nmutex_lock(&mdev->mutex);\r\nret = v4l2_subdev_call(to_outsd(mdev), pad, enum_dv_timings, timings);\r\nmutex_unlock(&mdev->mutex);\r\nreturn ret ? -EINVAL : 0;\r\n}\r\nstatic int mxr_s_dv_timings(struct file *file, void *fh,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct mxr_layer *layer = video_drvdata(file);\r\nstruct mxr_device *mdev = layer->mdev;\r\nint ret;\r\nmutex_lock(&mdev->mutex);\r\nif (mdev->n_output > 0) {\r\nmutex_unlock(&mdev->mutex);\r\nreturn -EBUSY;\r\n}\r\nret = v4l2_subdev_call(to_outsd(mdev), video, s_dv_timings, timings);\r\nmutex_unlock(&mdev->mutex);\r\nmxr_layer_update_output(layer);\r\nreturn ret ? -EINVAL : 0;\r\n}\r\nstatic int mxr_g_dv_timings(struct file *file, void *fh,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct mxr_layer *layer = video_drvdata(file);\r\nstruct mxr_device *mdev = layer->mdev;\r\nint ret;\r\nmutex_lock(&mdev->mutex);\r\nret = v4l2_subdev_call(to_outsd(mdev), video, g_dv_timings, timings);\r\nmutex_unlock(&mdev->mutex);\r\nreturn ret ? -EINVAL : 0;\r\n}\r\nstatic int mxr_dv_timings_cap(struct file *file, void *fh,\r\nstruct v4l2_dv_timings_cap *cap)\r\n{\r\nstruct mxr_layer *layer = video_drvdata(file);\r\nstruct mxr_device *mdev = layer->mdev;\r\nint ret;\r\ncap->pad = 0;\r\nmutex_lock(&mdev->mutex);\r\nret = v4l2_subdev_call(to_outsd(mdev), pad, dv_timings_cap, cap);\r\nmutex_unlock(&mdev->mutex);\r\nreturn ret ? -EINVAL : 0;\r\n}\r\nstatic int mxr_s_std(struct file *file, void *fh, v4l2_std_id norm)\r\n{\r\nstruct mxr_layer *layer = video_drvdata(file);\r\nstruct mxr_device *mdev = layer->mdev;\r\nint ret;\r\nmutex_lock(&mdev->mutex);\r\nif (mdev->n_output > 0) {\r\nmutex_unlock(&mdev->mutex);\r\nreturn -EBUSY;\r\n}\r\nret = v4l2_subdev_call(to_outsd(mdev), video, s_std_output, norm);\r\nmutex_unlock(&mdev->mutex);\r\nmxr_layer_update_output(layer);\r\nreturn ret ? -EINVAL : 0;\r\n}\r\nstatic int mxr_g_std(struct file *file, void *fh, v4l2_std_id *norm)\r\n{\r\nstruct mxr_layer *layer = video_drvdata(file);\r\nstruct mxr_device *mdev = layer->mdev;\r\nint ret;\r\nmutex_lock(&mdev->mutex);\r\nret = v4l2_subdev_call(to_outsd(mdev), video, g_std_output, norm);\r\nmutex_unlock(&mdev->mutex);\r\nreturn ret ? -EINVAL : 0;\r\n}\r\nstatic int mxr_enum_output(struct file *file, void *fh, struct v4l2_output *a)\r\n{\r\nstruct mxr_layer *layer = video_drvdata(file);\r\nstruct mxr_device *mdev = layer->mdev;\r\nstruct mxr_output *out;\r\nstruct v4l2_subdev *sd;\r\nif (a->index >= mdev->output_cnt)\r\nreturn -EINVAL;\r\nout = mdev->output[a->index];\r\nBUG_ON(out == NULL);\r\nsd = out->sd;\r\nstrlcpy(a->name, out->name, sizeof(a->name));\r\nv4l2_subdev_call(sd, video, g_tvnorms_output, &a->std);\r\na->capabilities = 0;\r\nif (sd->ops->video && sd->ops->video->s_dv_timings)\r\na->capabilities |= V4L2_OUT_CAP_DV_TIMINGS;\r\nif (sd->ops->video && sd->ops->video->s_std_output)\r\na->capabilities |= V4L2_OUT_CAP_STD;\r\na->type = V4L2_OUTPUT_TYPE_ANALOG;\r\nreturn 0;\r\n}\r\nstatic int mxr_s_output(struct file *file, void *fh, unsigned int i)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct mxr_layer *layer = video_drvdata(file);\r\nstruct mxr_device *mdev = layer->mdev;\r\nif (i >= mdev->output_cnt || mdev->output[i] == NULL)\r\nreturn -EINVAL;\r\nmutex_lock(&mdev->mutex);\r\nif (mdev->n_output > 0) {\r\nmutex_unlock(&mdev->mutex);\r\nreturn -EBUSY;\r\n}\r\nmdev->current_output = i;\r\nvfd->tvnorms = 0;\r\nv4l2_subdev_call(to_outsd(mdev), video, g_tvnorms_output,\r\n&vfd->tvnorms);\r\nmutex_unlock(&mdev->mutex);\r\nmxr_layer_update_output(layer);\r\nmxr_dbg(mdev, "tvnorms = %08llx\n", vfd->tvnorms);\r\nreturn 0;\r\n}\r\nstatic int mxr_g_output(struct file *file, void *fh, unsigned int *p)\r\n{\r\nstruct mxr_layer *layer = video_drvdata(file);\r\nstruct mxr_device *mdev = layer->mdev;\r\nmutex_lock(&mdev->mutex);\r\n*p = mdev->current_output;\r\nmutex_unlock(&mdev->mutex);\r\nreturn 0;\r\n}\r\nstatic int mxr_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *p)\r\n{\r\nstruct mxr_layer *layer = video_drvdata(file);\r\nmxr_dbg(layer->mdev, "%s:%d\n", __func__, __LINE__);\r\nreturn vb2_reqbufs(&layer->vb_queue, p);\r\n}\r\nstatic int mxr_querybuf(struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nstruct mxr_layer *layer = video_drvdata(file);\r\nmxr_dbg(layer->mdev, "%s:%d\n", __func__, __LINE__);\r\nreturn vb2_querybuf(&layer->vb_queue, p);\r\n}\r\nstatic int mxr_qbuf(struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nstruct mxr_layer *layer = video_drvdata(file);\r\nmxr_dbg(layer->mdev, "%s:%d(%d)\n", __func__, __LINE__, p->index);\r\nreturn vb2_qbuf(&layer->vb_queue, p);\r\n}\r\nstatic int mxr_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nstruct mxr_layer *layer = video_drvdata(file);\r\nmxr_dbg(layer->mdev, "%s:%d\n", __func__, __LINE__);\r\nreturn vb2_dqbuf(&layer->vb_queue, p, file->f_flags & O_NONBLOCK);\r\n}\r\nstatic int mxr_expbuf(struct file *file, void *priv,\r\nstruct v4l2_exportbuffer *eb)\r\n{\r\nstruct mxr_layer *layer = video_drvdata(file);\r\nmxr_dbg(layer->mdev, "%s:%d\n", __func__, __LINE__);\r\nreturn vb2_expbuf(&layer->vb_queue, eb);\r\n}\r\nstatic int mxr_streamon(struct file *file, void *priv, enum v4l2_buf_type i)\r\n{\r\nstruct mxr_layer *layer = video_drvdata(file);\r\nmxr_dbg(layer->mdev, "%s:%d\n", __func__, __LINE__);\r\nreturn vb2_streamon(&layer->vb_queue, i);\r\n}\r\nstatic int mxr_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)\r\n{\r\nstruct mxr_layer *layer = video_drvdata(file);\r\nmxr_dbg(layer->mdev, "%s:%d\n", __func__, __LINE__);\r\nreturn vb2_streamoff(&layer->vb_queue, i);\r\n}\r\nstatic int mxr_video_open(struct file *file)\r\n{\r\nstruct mxr_layer *layer = video_drvdata(file);\r\nstruct mxr_device *mdev = layer->mdev;\r\nint ret = 0;\r\nmxr_dbg(mdev, "%s:%d\n", __func__, __LINE__);\r\nif (mutex_lock_interruptible(&layer->mutex))\r\nreturn -ERESTARTSYS;\r\nwait_for_device_probe();\r\nret = v4l2_fh_open(file);\r\nif (ret) {\r\nmxr_err(mdev, "v4l2_fh_open failed\n");\r\ngoto unlock;\r\n}\r\nif (!v4l2_fh_is_singular_file(file))\r\ngoto unlock;\r\nret = mxr_power_get(mdev);\r\nif (ret) {\r\nmxr_err(mdev, "power on failed\n");\r\ngoto fail_fh_open;\r\n}\r\nret = vb2_queue_init(&layer->vb_queue);\r\nif (ret != 0) {\r\nmxr_err(mdev, "failed to initialize vb2 queue\n");\r\ngoto fail_power;\r\n}\r\nlayer->fmt = layer->fmt_array[0];\r\nmxr_layer_default_geo(layer);\r\nmutex_unlock(&layer->mutex);\r\nreturn 0;\r\nfail_power:\r\nmxr_power_put(mdev);\r\nfail_fh_open:\r\nv4l2_fh_release(file);\r\nunlock:\r\nmutex_unlock(&layer->mutex);\r\nreturn ret;\r\n}\r\nstatic unsigned int\r\nmxr_video_poll(struct file *file, struct poll_table_struct *wait)\r\n{\r\nstruct mxr_layer *layer = video_drvdata(file);\r\nunsigned int res;\r\nmxr_dbg(layer->mdev, "%s:%d\n", __func__, __LINE__);\r\nmutex_lock(&layer->mutex);\r\nres = vb2_poll(&layer->vb_queue, file, wait);\r\nmutex_unlock(&layer->mutex);\r\nreturn res;\r\n}\r\nstatic int mxr_video_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct mxr_layer *layer = video_drvdata(file);\r\nint ret;\r\nmxr_dbg(layer->mdev, "%s:%d\n", __func__, __LINE__);\r\nif (mutex_lock_interruptible(&layer->mutex))\r\nreturn -ERESTARTSYS;\r\nret = vb2_mmap(&layer->vb_queue, vma);\r\nmutex_unlock(&layer->mutex);\r\nreturn ret;\r\n}\r\nstatic int mxr_video_release(struct file *file)\r\n{\r\nstruct mxr_layer *layer = video_drvdata(file);\r\nmxr_dbg(layer->mdev, "%s:%d\n", __func__, __LINE__);\r\nmutex_lock(&layer->mutex);\r\nif (v4l2_fh_is_singular_file(file)) {\r\nvb2_queue_release(&layer->vb_queue);\r\nmxr_power_put(layer->mdev);\r\n}\r\nv4l2_fh_release(file);\r\nmutex_unlock(&layer->mutex);\r\nreturn 0;\r\n}\r\nstatic int queue_setup(struct vb2_queue *vq, const struct v4l2_format *pfmt,\r\nunsigned int *nbuffers, unsigned int *nplanes, unsigned int sizes[],\r\nvoid *alloc_ctxs[])\r\n{\r\nstruct mxr_layer *layer = vb2_get_drv_priv(vq);\r\nconst struct mxr_format *fmt = layer->fmt;\r\nint i;\r\nstruct mxr_device *mdev = layer->mdev;\r\nstruct v4l2_plane_pix_format planes[3];\r\nmxr_dbg(mdev, "%s\n", __func__);\r\nif (fmt == NULL)\r\nreturn -EINVAL;\r\nmxr_dbg(mdev, "fmt = %s\n", fmt->name);\r\nmxr_mplane_fill(planes, fmt, layer->geo.src.full_width,\r\nlayer->geo.src.full_height);\r\n*nplanes = fmt->num_subframes;\r\nfor (i = 0; i < fmt->num_subframes; ++i) {\r\nalloc_ctxs[i] = layer->mdev->alloc_ctx;\r\nsizes[i] = planes[i].sizeimage;\r\nmxr_dbg(mdev, "size[%d] = %08x\n", i, sizes[i]);\r\n}\r\nif (*nbuffers == 0)\r\n*nbuffers = 1;\r\nreturn 0;\r\n}\r\nstatic void buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct mxr_buffer *buffer = container_of(vb, struct mxr_buffer, vb);\r\nstruct mxr_layer *layer = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct mxr_device *mdev = layer->mdev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&layer->enq_slock, flags);\r\nlist_add_tail(&buffer->list, &layer->enq_list);\r\nspin_unlock_irqrestore(&layer->enq_slock, flags);\r\nmxr_dbg(mdev, "queuing buffer\n");\r\n}\r\nstatic int start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct mxr_layer *layer = vb2_get_drv_priv(vq);\r\nstruct mxr_device *mdev = layer->mdev;\r\nunsigned long flags;\r\nmxr_dbg(mdev, "%s\n", __func__);\r\nmxr_output_get(mdev);\r\nmxr_layer_update_output(layer);\r\nlayer->ops.format_set(layer);\r\nspin_lock_irqsave(&layer->enq_slock, flags);\r\nlayer->state = MXR_LAYER_STREAMING;\r\nspin_unlock_irqrestore(&layer->enq_slock, flags);\r\nlayer->ops.stream_set(layer, MXR_ENABLE);\r\nmxr_streamer_get(mdev);\r\nreturn 0;\r\n}\r\nstatic void mxr_watchdog(unsigned long arg)\r\n{\r\nstruct mxr_layer *layer = (struct mxr_layer *) arg;\r\nstruct mxr_device *mdev = layer->mdev;\r\nunsigned long flags;\r\nmxr_err(mdev, "watchdog fired for layer %s\n", layer->vfd.name);\r\nspin_lock_irqsave(&layer->enq_slock, flags);\r\nif (layer->update_buf == layer->shadow_buf)\r\nlayer->update_buf = NULL;\r\nif (layer->update_buf) {\r\nvb2_buffer_done(&layer->update_buf->vb, VB2_BUF_STATE_ERROR);\r\nlayer->update_buf = NULL;\r\n}\r\nif (layer->shadow_buf) {\r\nvb2_buffer_done(&layer->shadow_buf->vb, VB2_BUF_STATE_ERROR);\r\nlayer->shadow_buf = NULL;\r\n}\r\nspin_unlock_irqrestore(&layer->enq_slock, flags);\r\n}\r\nstatic void stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct mxr_layer *layer = vb2_get_drv_priv(vq);\r\nstruct mxr_device *mdev = layer->mdev;\r\nunsigned long flags;\r\nstruct timer_list watchdog;\r\nstruct mxr_buffer *buf, *buf_tmp;\r\nmxr_dbg(mdev, "%s\n", __func__);\r\nspin_lock_irqsave(&layer->enq_slock, flags);\r\nlayer->state = MXR_LAYER_STREAMING_FINISH;\r\nlist_for_each_entry_safe(buf, buf_tmp, &layer->enq_list, list) {\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irqrestore(&layer->enq_slock, flags);\r\nsetup_timer_on_stack(&watchdog, mxr_watchdog,\r\n(unsigned long)layer);\r\nmod_timer(&watchdog, jiffies + msecs_to_jiffies(1000));\r\nvb2_wait_for_all_buffers(vq);\r\ndel_timer_sync(&watchdog);\r\ndestroy_timer_on_stack(&watchdog);\r\nspin_lock_irqsave(&layer->enq_slock, flags);\r\nlayer->state = MXR_LAYER_IDLE;\r\nspin_unlock_irqrestore(&layer->enq_slock, flags);\r\nlayer->ops.stream_set(layer, MXR_DISABLE);\r\nmxr_streamer_put(mdev);\r\nmxr_output_put(mdev);\r\n}\r\nint mxr_base_layer_register(struct mxr_layer *layer)\r\n{\r\nstruct mxr_device *mdev = layer->mdev;\r\nint ret;\r\nret = video_register_device(&layer->vfd, VFL_TYPE_GRABBER, -1);\r\nif (ret)\r\nmxr_err(mdev, "failed to register video device\n");\r\nelse\r\nmxr_info(mdev, "registered layer %s as /dev/video%d\n",\r\nlayer->vfd.name, layer->vfd.num);\r\nreturn ret;\r\n}\r\nvoid mxr_base_layer_unregister(struct mxr_layer *layer)\r\n{\r\nvideo_unregister_device(&layer->vfd);\r\n}\r\nvoid mxr_layer_release(struct mxr_layer *layer)\r\n{\r\nif (layer->ops.release)\r\nlayer->ops.release(layer);\r\n}\r\nvoid mxr_base_layer_release(struct mxr_layer *layer)\r\n{\r\nkfree(layer);\r\n}\r\nstatic void mxr_vfd_release(struct video_device *vdev)\r\n{\r\npr_info("video device release\n");\r\n}\r\nstruct mxr_layer *mxr_base_layer_create(struct mxr_device *mdev,\r\nint idx, char *name, struct mxr_layer_ops *ops)\r\n{\r\nstruct mxr_layer *layer;\r\nlayer = kzalloc(sizeof(*layer), GFP_KERNEL);\r\nif (layer == NULL) {\r\nmxr_err(mdev, "not enough memory for layer.\n");\r\ngoto fail;\r\n}\r\nlayer->mdev = mdev;\r\nlayer->idx = idx;\r\nlayer->ops = *ops;\r\nspin_lock_init(&layer->enq_slock);\r\nINIT_LIST_HEAD(&layer->enq_list);\r\nmutex_init(&layer->mutex);\r\nlayer->vfd = (struct video_device) {\r\n.minor = -1,\r\n.release = mxr_vfd_release,\r\n.fops = &mxr_fops,\r\n.vfl_dir = VFL_DIR_TX,\r\n.ioctl_ops = &mxr_ioctl_ops,\r\n};\r\nstrlcpy(layer->vfd.name, name, sizeof(layer->vfd.name));\r\nvideo_set_drvdata(&layer->vfd, layer);\r\nlayer->vfd.lock = &layer->mutex;\r\nlayer->vfd.v4l2_dev = &mdev->v4l2_dev;\r\nlayer->vb_queue = (struct vb2_queue) {\r\n.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,\r\n.io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF,\r\n.drv_priv = layer,\r\n.buf_struct_size = sizeof(struct mxr_buffer),\r\n.ops = &mxr_video_qops,\r\n.min_buffers_needed = 1,\r\n.mem_ops = &vb2_dma_contig_memops,\r\n.lock = &layer->mutex,\r\n};\r\nreturn layer;\r\nfail:\r\nreturn NULL;\r\n}\r\nstatic const struct mxr_format *find_format_by_fourcc(\r\nstruct mxr_layer *layer, unsigned long fourcc)\r\n{\r\nint i;\r\nfor (i = 0; i < layer->fmt_array_size; ++i)\r\nif (layer->fmt_array[i]->fourcc == fourcc)\r\nreturn layer->fmt_array[i];\r\nreturn NULL;\r\n}\r\nstatic const struct mxr_format *find_format_by_index(\r\nstruct mxr_layer *layer, unsigned long index)\r\n{\r\nif (index >= layer->fmt_array_size)\r\nreturn NULL;\r\nreturn layer->fmt_array[index];\r\n}
