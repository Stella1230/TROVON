static int init_powernv_pstates(void)\r\n{\r\nstruct device_node *power_mgt;\r\nint i, pstate_min, pstate_max, pstate_nominal, nr_pstates = 0;\r\nconst __be32 *pstate_ids, *pstate_freqs;\r\nu32 len_ids, len_freqs;\r\npower_mgt = of_find_node_by_path("/ibm,opal/power-mgt");\r\nif (!power_mgt) {\r\npr_warn("power-mgt node not found\n");\r\nreturn -ENODEV;\r\n}\r\nif (of_property_read_u32(power_mgt, "ibm,pstate-min", &pstate_min)) {\r\npr_warn("ibm,pstate-min node not found\n");\r\nreturn -ENODEV;\r\n}\r\nif (of_property_read_u32(power_mgt, "ibm,pstate-max", &pstate_max)) {\r\npr_warn("ibm,pstate-max node not found\n");\r\nreturn -ENODEV;\r\n}\r\nif (of_property_read_u32(power_mgt, "ibm,pstate-nominal",\r\n&pstate_nominal)) {\r\npr_warn("ibm,pstate-nominal not found\n");\r\nreturn -ENODEV;\r\n}\r\npr_info("cpufreq pstate min %d nominal %d max %d\n", pstate_min,\r\npstate_nominal, pstate_max);\r\npstate_ids = of_get_property(power_mgt, "ibm,pstate-ids", &len_ids);\r\nif (!pstate_ids) {\r\npr_warn("ibm,pstate-ids not found\n");\r\nreturn -ENODEV;\r\n}\r\npstate_freqs = of_get_property(power_mgt, "ibm,pstate-frequencies-mhz",\r\n&len_freqs);\r\nif (!pstate_freqs) {\r\npr_warn("ibm,pstate-frequencies-mhz not found\n");\r\nreturn -ENODEV;\r\n}\r\nif (len_ids != len_freqs) {\r\npr_warn("Entries in ibm,pstate-ids and "\r\n"ibm,pstate-frequencies-mhz does not match\n");\r\n}\r\nnr_pstates = min(len_ids, len_freqs) / sizeof(u32);\r\nif (!nr_pstates) {\r\npr_warn("No PStates found\n");\r\nreturn -ENODEV;\r\n}\r\npr_debug("NR PStates %d\n", nr_pstates);\r\nfor (i = 0; i < nr_pstates; i++) {\r\nu32 id = be32_to_cpu(pstate_ids[i]);\r\nu32 freq = be32_to_cpu(pstate_freqs[i]);\r\npr_debug("PState id %d freq %d MHz\n", id, freq);\r\npowernv_freqs[i].frequency = freq * 1000;\r\npowernv_freqs[i].driver_data = id;\r\n}\r\npowernv_freqs[i].frequency = CPUFREQ_TABLE_END;\r\npowernv_pstate_info.min = pstate_min;\r\npowernv_pstate_info.max = pstate_max;\r\npowernv_pstate_info.nominal = pstate_nominal;\r\npowernv_pstate_info.nr_pstates = nr_pstates;\r\nreturn 0;\r\n}\r\nstatic unsigned int pstate_id_to_freq(int pstate_id)\r\n{\r\nint i;\r\ni = powernv_pstate_info.max - pstate_id;\r\nif (i >= powernv_pstate_info.nr_pstates || i < 0) {\r\npr_warn("PState id %d outside of PState table, "\r\n"reporting nominal id %d instead\n",\r\npstate_id, powernv_pstate_info.nominal);\r\ni = powernv_pstate_info.max - powernv_pstate_info.nominal;\r\n}\r\nreturn powernv_freqs[i].frequency;\r\n}\r\nstatic ssize_t cpuinfo_nominal_freq_show(struct cpufreq_policy *policy,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%u\n",\r\npstate_id_to_freq(powernv_pstate_info.nominal));\r\n}\r\nstatic inline unsigned long get_pmspr(unsigned long sprn)\r\n{\r\nswitch (sprn) {\r\ncase SPRN_PMCR:\r\nreturn mfspr(SPRN_PMCR);\r\ncase SPRN_PMICR:\r\nreturn mfspr(SPRN_PMICR);\r\ncase SPRN_PMSR:\r\nreturn mfspr(SPRN_PMSR);\r\n}\r\nBUG();\r\n}\r\nstatic inline void set_pmspr(unsigned long sprn, unsigned long val)\r\n{\r\nswitch (sprn) {\r\ncase SPRN_PMCR:\r\nmtspr(SPRN_PMCR, val);\r\nreturn;\r\ncase SPRN_PMICR:\r\nmtspr(SPRN_PMICR, val);\r\nreturn;\r\n}\r\nBUG();\r\n}\r\nstatic void powernv_read_cpu_freq(void *arg)\r\n{\r\nunsigned long pmspr_val;\r\ns8 local_pstate_id;\r\nstruct powernv_smp_call_data *freq_data = arg;\r\npmspr_val = get_pmspr(SPRN_PMSR);\r\nlocal_pstate_id = (pmspr_val >> 48) & 0xFF;\r\nfreq_data->pstate_id = local_pstate_id;\r\nfreq_data->freq = pstate_id_to_freq(freq_data->pstate_id);\r\npr_debug("cpu %d pmsr %016lX pstate_id %d frequency %d kHz\n",\r\nraw_smp_processor_id(), pmspr_val, freq_data->pstate_id,\r\nfreq_data->freq);\r\n}\r\nstatic unsigned int powernv_cpufreq_get(unsigned int cpu)\r\n{\r\nstruct powernv_smp_call_data freq_data;\r\nsmp_call_function_any(cpu_sibling_mask(cpu), powernv_read_cpu_freq,\r\n&freq_data, 1);\r\nreturn freq_data.freq;\r\n}\r\nstatic void set_pstate(void *freq_data)\r\n{\r\nunsigned long val;\r\nunsigned long pstate_ul =\r\n((struct powernv_smp_call_data *) freq_data)->pstate_id;\r\nval = get_pmspr(SPRN_PMCR);\r\nval = val & 0x0000FFFFFFFFFFFFULL;\r\npstate_ul = pstate_ul & 0xFF;\r\nval = val | (pstate_ul << 56) | (pstate_ul << 48);\r\npr_debug("Setting cpu %d pmcr to %016lX\n",\r\nraw_smp_processor_id(), val);\r\nset_pmspr(SPRN_PMCR, val);\r\n}\r\nstatic inline unsigned int get_nominal_index(void)\r\n{\r\nreturn powernv_pstate_info.max - powernv_pstate_info.nominal;\r\n}\r\nstatic void powernv_cpufreq_throttle_check(unsigned int cpu)\r\n{\r\nunsigned long pmsr;\r\nint pmsr_pmax, pmsr_lp;\r\npmsr = get_pmspr(SPRN_PMSR);\r\npmsr_pmax = (s8)PMSR_MAX(pmsr);\r\nif (pmsr_pmax != powernv_pstate_info.max) {\r\nthrottled = true;\r\npr_info("CPU %d Pmax is reduced to %d\n", cpu, pmsr_pmax);\r\npr_info("Max allowed Pstate is capped\n");\r\n}\r\npmsr_lp = (s8)PMSR_LP(pmsr);\r\nif ((pmsr_lp < powernv_pstate_info.min) ||\r\n(pmsr & PMSR_PSAFE_ENABLE)) {\r\nthrottled = true;\r\npr_info("Pstate set to safe frequency\n");\r\n}\r\nif (pmsr & PMSR_SPR_EM_DISABLE) {\r\nthrottled = true;\r\npr_info("Frequency Control disabled from OS\n");\r\n}\r\nif (throttled) {\r\npr_info("PMSR = %16lx\n", pmsr);\r\npr_crit("CPU Frequency could be throttled\n");\r\n}\r\n}\r\nstatic int powernv_cpufreq_target_index(struct cpufreq_policy *policy,\r\nunsigned int new_index)\r\n{\r\nstruct powernv_smp_call_data freq_data;\r\nif (unlikely(rebooting) && new_index != get_nominal_index())\r\nreturn 0;\r\nif (!throttled)\r\npowernv_cpufreq_throttle_check(smp_processor_id());\r\nfreq_data.pstate_id = powernv_freqs[new_index].driver_data;\r\nsmp_call_function_any(policy->cpus, set_pstate, &freq_data, 1);\r\nreturn 0;\r\n}\r\nstatic int powernv_cpufreq_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nint base, i;\r\nbase = cpu_first_thread_sibling(policy->cpu);\r\nfor (i = 0; i < threads_per_core; i++)\r\ncpumask_set_cpu(base + i, policy->cpus);\r\nreturn cpufreq_table_validate_and_show(policy, powernv_freqs);\r\n}\r\nstatic int powernv_cpufreq_reboot_notifier(struct notifier_block *nb,\r\nunsigned long action, void *unused)\r\n{\r\nint cpu;\r\nstruct cpufreq_policy cpu_policy;\r\nrebooting = true;\r\nfor_each_online_cpu(cpu) {\r\ncpufreq_get_policy(&cpu_policy, cpu);\r\npowernv_cpufreq_target_index(&cpu_policy, get_nominal_index());\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void powernv_cpufreq_stop_cpu(struct cpufreq_policy *policy)\r\n{\r\nstruct powernv_smp_call_data freq_data;\r\nfreq_data.pstate_id = powernv_pstate_info.min;\r\nsmp_call_function_single(policy->cpu, set_pstate, &freq_data, 1);\r\n}\r\nstatic int __init powernv_cpufreq_init(void)\r\n{\r\nint rc = 0;\r\nif (!firmware_has_feature(FW_FEATURE_OPALv3))\r\nreturn -ENODEV;\r\nrc = init_powernv_pstates();\r\nif (rc) {\r\npr_info("powernv-cpufreq disabled. System does not support PState control\n");\r\nreturn rc;\r\n}\r\nregister_reboot_notifier(&powernv_cpufreq_reboot_nb);\r\nreturn cpufreq_register_driver(&powernv_cpufreq_driver);\r\n}\r\nstatic void __exit powernv_cpufreq_exit(void)\r\n{\r\nunregister_reboot_notifier(&powernv_cpufreq_reboot_nb);\r\ncpufreq_unregister_driver(&powernv_cpufreq_driver);\r\n}
