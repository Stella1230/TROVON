static inline bool sdhci_acpi_flag(struct sdhci_acpi_host *c, unsigned int flag)\r\n{\r\nreturn c->slot && (c->slot->flags & flag);\r\n}\r\nstatic int sdhci_acpi_enable_dma(struct sdhci_host *host)\r\n{\r\nstruct sdhci_acpi_host *c = sdhci_priv(host);\r\nstruct device *dev = &c->pdev->dev;\r\nint err = -1;\r\nif (c->dma_setup)\r\nreturn 0;\r\nif (host->flags & SDHCI_USE_64_BIT_DMA) {\r\nif (host->quirks2 & SDHCI_QUIRK2_BROKEN_64_BIT_DMA) {\r\nhost->flags &= ~SDHCI_USE_64_BIT_DMA;\r\n} else {\r\nerr = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(64));\r\nif (err)\r\ndev_warn(dev, "Failed to set 64-bit DMA mask\n");\r\n}\r\n}\r\nif (err)\r\nerr = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));\r\nc->dma_setup = !err;\r\nreturn err;\r\n}\r\nstatic void sdhci_acpi_int_hw_reset(struct sdhci_host *host)\r\n{\r\nu8 reg;\r\nreg = sdhci_readb(host, SDHCI_POWER_CONTROL);\r\nreg |= 0x10;\r\nsdhci_writeb(host, reg, SDHCI_POWER_CONTROL);\r\nudelay(9);\r\nreg &= ~0x10;\r\nsdhci_writeb(host, reg, SDHCI_POWER_CONTROL);\r\nusleep_range(300, 1000);\r\n}\r\nstatic int sdhci_acpi_emmc_probe_slot(struct platform_device *pdev,\r\nconst char *hid, const char *uid)\r\n{\r\nstruct sdhci_acpi_host *c = platform_get_drvdata(pdev);\r\nstruct sdhci_host *host;\r\nif (!c || !c->host)\r\nreturn 0;\r\nhost = c->host;\r\nif (hid && uid && !strcmp(hid, "80860F14") && !strcmp(uid, "1") &&\r\nsdhci_readl(host, SDHCI_CAPABILITIES) == 0x446cc8b2 &&\r\nsdhci_readl(host, SDHCI_CAPABILITIES_1) == 0x00000807)\r\nhost->timeout_clk = 1000;\r\nreturn 0;\r\n}\r\nstatic int sdhci_acpi_sdio_probe_slot(struct platform_device *pdev,\r\nconst char *hid, const char *uid)\r\n{\r\nstruct sdhci_acpi_host *c = platform_get_drvdata(pdev);\r\nstruct sdhci_host *host;\r\nif (!c || !c->host)\r\nreturn 0;\r\nhost = c->host;\r\nreturn 0;\r\n}\r\nstatic int sdhci_acpi_sd_probe_slot(struct platform_device *pdev,\r\nconst char *hid, const char *uid)\r\n{\r\nstruct sdhci_acpi_host *c = platform_get_drvdata(pdev);\r\nstruct sdhci_host *host;\r\nif (!c || !c->host || !c->slot)\r\nreturn 0;\r\nhost = c->host;\r\nreturn 0;\r\n}\r\nstatic const struct sdhci_acpi_slot *sdhci_acpi_get_slot(const char *hid,\r\nconst char *uid)\r\n{\r\nconst struct sdhci_acpi_uid_slot *u;\r\nfor (u = sdhci_acpi_uids; u->hid; u++) {\r\nif (strcmp(u->hid, hid))\r\ncontinue;\r\nif (!u->uid)\r\nreturn u->slot;\r\nif (uid && !strcmp(u->uid, uid))\r\nreturn u->slot;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int sdhci_acpi_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nacpi_handle handle = ACPI_HANDLE(dev);\r\nstruct acpi_device *device;\r\nstruct sdhci_acpi_host *c;\r\nstruct sdhci_host *host;\r\nstruct resource *iomem;\r\nresource_size_t len;\r\nconst char *hid;\r\nconst char *uid;\r\nint err;\r\nif (acpi_bus_get_device(handle, &device))\r\nreturn -ENODEV;\r\nif (acpi_bus_get_status(device) || !device->status.present)\r\nreturn -ENODEV;\r\nhid = acpi_device_hid(device);\r\nuid = device->pnp.unique_id;\r\niomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!iomem)\r\nreturn -ENOMEM;\r\nlen = resource_size(iomem);\r\nif (len < 0x100)\r\ndev_err(dev, "Invalid iomem size!\n");\r\nif (!devm_request_mem_region(dev, iomem->start, len, dev_name(dev)))\r\nreturn -ENOMEM;\r\nhost = sdhci_alloc_host(dev, sizeof(struct sdhci_acpi_host));\r\nif (IS_ERR(host))\r\nreturn PTR_ERR(host);\r\nc = sdhci_priv(host);\r\nc->host = host;\r\nc->slot = sdhci_acpi_get_slot(hid, uid);\r\nc->pdev = pdev;\r\nc->use_runtime_pm = sdhci_acpi_flag(c, SDHCI_ACPI_RUNTIME_PM);\r\nplatform_set_drvdata(pdev, c);\r\nhost->hw_name = "ACPI";\r\nhost->ops = &sdhci_acpi_ops_dflt;\r\nhost->irq = platform_get_irq(pdev, 0);\r\nhost->ioaddr = devm_ioremap_nocache(dev, iomem->start,\r\nresource_size(iomem));\r\nif (host->ioaddr == NULL) {\r\nerr = -ENOMEM;\r\ngoto err_free;\r\n}\r\nif (c->slot) {\r\nif (c->slot->probe_slot) {\r\nerr = c->slot->probe_slot(pdev, hid, uid);\r\nif (err)\r\ngoto err_free;\r\n}\r\nif (c->slot->chip) {\r\nhost->ops = c->slot->chip->ops;\r\nhost->quirks |= c->slot->chip->quirks;\r\nhost->quirks2 |= c->slot->chip->quirks2;\r\nhost->mmc->caps |= c->slot->chip->caps;\r\nhost->mmc->caps2 |= c->slot->chip->caps2;\r\nhost->mmc->pm_caps |= c->slot->chip->pm_caps;\r\n}\r\nhost->quirks |= c->slot->quirks;\r\nhost->quirks2 |= c->slot->quirks2;\r\nhost->mmc->caps |= c->slot->caps;\r\nhost->mmc->caps2 |= c->slot->caps2;\r\nhost->mmc->pm_caps |= c->slot->pm_caps;\r\n}\r\nhost->mmc->caps2 |= MMC_CAP2_NO_PRESCAN_POWERUP;\r\nif (sdhci_acpi_flag(c, SDHCI_ACPI_SD_CD)) {\r\nbool v = sdhci_acpi_flag(c, SDHCI_ACPI_SD_CD_OVERRIDE_LEVEL);\r\nif (mmc_gpiod_request_cd(host->mmc, NULL, 0, v, 0, NULL)) {\r\ndev_warn(dev, "failed to setup card detect gpio\n");\r\nc->use_runtime_pm = false;\r\n}\r\n}\r\nerr = sdhci_add_host(host);\r\nif (err)\r\ngoto err_free;\r\nif (c->use_runtime_pm) {\r\npm_runtime_set_active(dev);\r\npm_suspend_ignore_children(dev, 1);\r\npm_runtime_set_autosuspend_delay(dev, 50);\r\npm_runtime_use_autosuspend(dev);\r\npm_runtime_enable(dev);\r\n}\r\nreturn 0;\r\nerr_free:\r\nsdhci_free_host(c->host);\r\nreturn err;\r\n}\r\nstatic int sdhci_acpi_remove(struct platform_device *pdev)\r\n{\r\nstruct sdhci_acpi_host *c = platform_get_drvdata(pdev);\r\nstruct device *dev = &pdev->dev;\r\nint dead;\r\nif (c->use_runtime_pm) {\r\npm_runtime_get_sync(dev);\r\npm_runtime_disable(dev);\r\npm_runtime_put_noidle(dev);\r\n}\r\nif (c->slot && c->slot->remove_slot)\r\nc->slot->remove_slot(pdev);\r\ndead = (sdhci_readl(c->host, SDHCI_INT_STATUS) == ~0);\r\nsdhci_remove_host(c->host, dead);\r\nsdhci_free_host(c->host);\r\nreturn 0;\r\n}\r\nstatic int sdhci_acpi_suspend(struct device *dev)\r\n{\r\nstruct sdhci_acpi_host *c = dev_get_drvdata(dev);\r\nreturn sdhci_suspend_host(c->host);\r\n}\r\nstatic int sdhci_acpi_resume(struct device *dev)\r\n{\r\nstruct sdhci_acpi_host *c = dev_get_drvdata(dev);\r\nreturn sdhci_resume_host(c->host);\r\n}\r\nstatic int sdhci_acpi_runtime_suspend(struct device *dev)\r\n{\r\nstruct sdhci_acpi_host *c = dev_get_drvdata(dev);\r\nreturn sdhci_runtime_suspend_host(c->host);\r\n}\r\nstatic int sdhci_acpi_runtime_resume(struct device *dev)\r\n{\r\nstruct sdhci_acpi_host *c = dev_get_drvdata(dev);\r\nreturn sdhci_runtime_resume_host(c->host);\r\n}
