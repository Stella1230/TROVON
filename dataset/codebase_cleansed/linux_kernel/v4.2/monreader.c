static void dcss_mkname(char *ascii_name, char *ebcdic_name)\r\n{\r\nint i;\r\nfor (i = 0; i < 8; i++) {\r\nif (ascii_name[i] == '\0')\r\nbreak;\r\nebcdic_name[i] = toupper(ascii_name[i]);\r\n};\r\nfor (; i < 8; i++)\r\nebcdic_name[i] = ' ';\r\nASCEBC(ebcdic_name, 8);\r\n}\r\nstatic inline unsigned long mon_mca_start(struct mon_msg *monmsg)\r\n{\r\nreturn *(u32 *) &monmsg->msg.rmmsg;\r\n}\r\nstatic inline unsigned long mon_mca_end(struct mon_msg *monmsg)\r\n{\r\nreturn *(u32 *) &monmsg->msg.rmmsg[4];\r\n}\r\nstatic inline u8 mon_mca_type(struct mon_msg *monmsg, u8 index)\r\n{\r\nreturn *((u8 *) mon_mca_start(monmsg) + monmsg->mca_offset + index);\r\n}\r\nstatic inline u32 mon_mca_size(struct mon_msg *monmsg)\r\n{\r\nreturn mon_mca_end(monmsg) - mon_mca_start(monmsg) + 1;\r\n}\r\nstatic inline u32 mon_rec_start(struct mon_msg *monmsg)\r\n{\r\nreturn *((u32 *) (mon_mca_start(monmsg) + monmsg->mca_offset + 4));\r\n}\r\nstatic inline u32 mon_rec_end(struct mon_msg *monmsg)\r\n{\r\nreturn *((u32 *) (mon_mca_start(monmsg) + monmsg->mca_offset + 8));\r\n}\r\nstatic int mon_check_mca(struct mon_msg *monmsg)\r\n{\r\nif ((mon_rec_end(monmsg) <= mon_rec_start(monmsg)) ||\r\n(mon_rec_start(monmsg) < mon_dcss_start) ||\r\n(mon_rec_end(monmsg) > mon_dcss_end) ||\r\n(mon_mca_type(monmsg, 0) == 0) ||\r\n(mon_mca_size(monmsg) % 12 != 0) ||\r\n(mon_mca_end(monmsg) <= mon_mca_start(monmsg)) ||\r\n(mon_mca_end(monmsg) > mon_dcss_end) ||\r\n(mon_mca_start(monmsg) < mon_dcss_start) ||\r\n((mon_mca_type(monmsg, 1) == 0) && (mon_mca_type(monmsg, 2) == 0)))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int mon_send_reply(struct mon_msg *monmsg,\r\nstruct mon_private *monpriv)\r\n{\r\nint rc;\r\nrc = iucv_message_reply(monpriv->path, &monmsg->msg,\r\nIUCV_IPRMDATA, NULL, 0);\r\natomic_dec(&monpriv->msglim_count);\r\nif (likely(!monmsg->msglim_reached)) {\r\nmonmsg->pos = 0;\r\nmonmsg->mca_offset = 0;\r\nmonpriv->read_index = (monpriv->read_index + 1) %\r\nMON_MSGLIM;\r\natomic_dec(&monpriv->read_ready);\r\n} else\r\nmonmsg->replied_msglim = 1;\r\nif (rc) {\r\npr_err("Reading monitor data failed with rc=%i\n", rc);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mon_free_mem(struct mon_private *monpriv)\r\n{\r\nint i;\r\nfor (i = 0; i < MON_MSGLIM; i++)\r\nkfree(monpriv->msg_array[i]);\r\nkfree(monpriv);\r\n}\r\nstatic struct mon_private *mon_alloc_mem(void)\r\n{\r\nint i;\r\nstruct mon_private *monpriv;\r\nmonpriv = kzalloc(sizeof(struct mon_private), GFP_KERNEL);\r\nif (!monpriv)\r\nreturn NULL;\r\nfor (i = 0; i < MON_MSGLIM; i++) {\r\nmonpriv->msg_array[i] = kzalloc(sizeof(struct mon_msg),\r\nGFP_KERNEL);\r\nif (!monpriv->msg_array[i]) {\r\nmon_free_mem(monpriv);\r\nreturn NULL;\r\n}\r\n}\r\nreturn monpriv;\r\n}\r\nstatic inline void mon_next_mca(struct mon_msg *monmsg)\r\n{\r\nif (likely((mon_mca_size(monmsg) - monmsg->mca_offset) == 12))\r\nreturn;\r\nmonmsg->mca_offset += 12;\r\nmonmsg->pos = 0;\r\n}\r\nstatic struct mon_msg *mon_next_message(struct mon_private *monpriv)\r\n{\r\nstruct mon_msg *monmsg;\r\nif (!atomic_read(&monpriv->read_ready))\r\nreturn NULL;\r\nmonmsg = monpriv->msg_array[monpriv->read_index];\r\nif (unlikely(monmsg->replied_msglim)) {\r\nmonmsg->replied_msglim = 0;\r\nmonmsg->msglim_reached = 0;\r\nmonmsg->pos = 0;\r\nmonmsg->mca_offset = 0;\r\nmonpriv->read_index = (monpriv->read_index + 1) %\r\nMON_MSGLIM;\r\natomic_dec(&monpriv->read_ready);\r\nreturn ERR_PTR(-EOVERFLOW);\r\n}\r\nreturn monmsg;\r\n}\r\nstatic void mon_iucv_path_complete(struct iucv_path *path, u8 ipuser[16])\r\n{\r\nstruct mon_private *monpriv = path->private;\r\natomic_set(&monpriv->iucv_connected, 1);\r\nwake_up(&mon_conn_wait_queue);\r\n}\r\nstatic void mon_iucv_path_severed(struct iucv_path *path, u8 ipuser[16])\r\n{\r\nstruct mon_private *monpriv = path->private;\r\npr_err("z/VM *MONITOR system service disconnected with rc=%i\n",\r\nipuser[0]);\r\niucv_path_sever(path, NULL);\r\natomic_set(&monpriv->iucv_severed, 1);\r\nwake_up(&mon_conn_wait_queue);\r\nwake_up_interruptible(&mon_read_wait_queue);\r\n}\r\nstatic void mon_iucv_message_pending(struct iucv_path *path,\r\nstruct iucv_message *msg)\r\n{\r\nstruct mon_private *monpriv = path->private;\r\nmemcpy(&monpriv->msg_array[monpriv->write_index]->msg,\r\nmsg, sizeof(*msg));\r\nif (atomic_inc_return(&monpriv->msglim_count) == MON_MSGLIM) {\r\npr_warning("The read queue for monitor data is full\n");\r\nmonpriv->msg_array[monpriv->write_index]->msglim_reached = 1;\r\n}\r\nmonpriv->write_index = (monpriv->write_index + 1) % MON_MSGLIM;\r\natomic_inc(&monpriv->read_ready);\r\nwake_up_interruptible(&mon_read_wait_queue);\r\n}\r\nstatic int mon_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct mon_private *monpriv;\r\nint rc;\r\nrc = -EBUSY;\r\nif (test_and_set_bit(MON_IN_USE, &mon_in_use))\r\ngoto out;\r\nrc = -ENOMEM;\r\nmonpriv = mon_alloc_mem();\r\nif (!monpriv)\r\ngoto out_use;\r\nmonpriv->path = iucv_path_alloc(MON_MSGLIM, IUCV_IPRMDATA, GFP_KERNEL);\r\nif (!monpriv->path)\r\ngoto out_priv;\r\nrc = iucv_path_connect(monpriv->path, &monreader_iucv_handler,\r\nMON_SERVICE, NULL, user_data_connect, monpriv);\r\nif (rc) {\r\npr_err("Connecting to the z/VM *MONITOR system service "\r\n"failed with rc=%i\n", rc);\r\nrc = -EIO;\r\ngoto out_path;\r\n}\r\nwait_event(mon_conn_wait_queue,\r\natomic_read(&monpriv->iucv_connected) ||\r\natomic_read(&monpriv->iucv_severed));\r\nif (atomic_read(&monpriv->iucv_severed)) {\r\natomic_set(&monpriv->iucv_severed, 0);\r\natomic_set(&monpriv->iucv_connected, 0);\r\nrc = -EIO;\r\ngoto out_path;\r\n}\r\nfilp->private_data = monpriv;\r\ndev_set_drvdata(monreader_device, monpriv);\r\nreturn nonseekable_open(inode, filp);\r\nout_path:\r\niucv_path_free(monpriv->path);\r\nout_priv:\r\nmon_free_mem(monpriv);\r\nout_use:\r\nclear_bit(MON_IN_USE, &mon_in_use);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int mon_close(struct inode *inode, struct file *filp)\r\n{\r\nint rc, i;\r\nstruct mon_private *monpriv = filp->private_data;\r\nif (monpriv->path) {\r\nrc = iucv_path_sever(monpriv->path, user_data_sever);\r\nif (rc)\r\npr_warning("Disconnecting the z/VM *MONITOR system "\r\n"service failed with rc=%i\n", rc);\r\niucv_path_free(monpriv->path);\r\n}\r\natomic_set(&monpriv->iucv_severed, 0);\r\natomic_set(&monpriv->iucv_connected, 0);\r\natomic_set(&monpriv->read_ready, 0);\r\natomic_set(&monpriv->msglim_count, 0);\r\nmonpriv->write_index = 0;\r\nmonpriv->read_index = 0;\r\ndev_set_drvdata(monreader_device, NULL);\r\nfor (i = 0; i < MON_MSGLIM; i++)\r\nkfree(monpriv->msg_array[i]);\r\nkfree(monpriv);\r\nclear_bit(MON_IN_USE, &mon_in_use);\r\nreturn 0;\r\n}\r\nstatic ssize_t mon_read(struct file *filp, char __user *data,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct mon_private *monpriv = filp->private_data;\r\nstruct mon_msg *monmsg;\r\nint ret;\r\nu32 mce_start;\r\nmonmsg = mon_next_message(monpriv);\r\nif (IS_ERR(monmsg))\r\nreturn PTR_ERR(monmsg);\r\nif (!monmsg) {\r\nif (filp->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nret = wait_event_interruptible(mon_read_wait_queue,\r\natomic_read(&monpriv->read_ready) ||\r\natomic_read(&monpriv->iucv_severed));\r\nif (ret)\r\nreturn ret;\r\nif (unlikely(atomic_read(&monpriv->iucv_severed)))\r\nreturn -EIO;\r\nmonmsg = monpriv->msg_array[monpriv->read_index];\r\n}\r\nif (!monmsg->pos)\r\nmonmsg->pos = mon_mca_start(monmsg) + monmsg->mca_offset;\r\nif (mon_check_mca(monmsg))\r\ngoto reply;\r\nmce_start = mon_mca_start(monmsg) + monmsg->mca_offset;\r\nif ((monmsg->pos >= mce_start) && (monmsg->pos < mce_start + 12)) {\r\ncount = min(count, (size_t) mce_start + 12 - monmsg->pos);\r\nret = copy_to_user(data, (void *) (unsigned long) monmsg->pos,\r\ncount);\r\nif (ret)\r\nreturn -EFAULT;\r\nmonmsg->pos += count;\r\nif (monmsg->pos == mce_start + 12)\r\nmonmsg->pos = mon_rec_start(monmsg);\r\ngoto out_copy;\r\n}\r\nif (monmsg->pos <= mon_rec_end(monmsg)) {\r\ncount = min(count, (size_t) mon_rec_end(monmsg) - monmsg->pos\r\n+ 1);\r\nret = copy_to_user(data, (void *) (unsigned long) monmsg->pos,\r\ncount);\r\nif (ret)\r\nreturn -EFAULT;\r\nmonmsg->pos += count;\r\nif (monmsg->pos > mon_rec_end(monmsg))\r\nmon_next_mca(monmsg);\r\ngoto out_copy;\r\n}\r\nreply:\r\nret = mon_send_reply(monmsg, monpriv);\r\nreturn ret;\r\nout_copy:\r\n*ppos += count;\r\nreturn count;\r\n}\r\nstatic unsigned int mon_poll(struct file *filp, struct poll_table_struct *p)\r\n{\r\nstruct mon_private *monpriv = filp->private_data;\r\npoll_wait(filp, &mon_read_wait_queue, p);\r\nif (unlikely(atomic_read(&monpriv->iucv_severed)))\r\nreturn POLLERR;\r\nif (atomic_read(&monpriv->read_ready))\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic int monreader_freeze(struct device *dev)\r\n{\r\nstruct mon_private *monpriv = dev_get_drvdata(dev);\r\nint rc;\r\nif (!monpriv)\r\nreturn 0;\r\nif (monpriv->path) {\r\nrc = iucv_path_sever(monpriv->path, user_data_sever);\r\nif (rc)\r\npr_warning("Disconnecting the z/VM *MONITOR system "\r\n"service failed with rc=%i\n", rc);\r\niucv_path_free(monpriv->path);\r\n}\r\natomic_set(&monpriv->iucv_severed, 0);\r\natomic_set(&monpriv->iucv_connected, 0);\r\natomic_set(&monpriv->read_ready, 0);\r\natomic_set(&monpriv->msglim_count, 0);\r\nmonpriv->write_index = 0;\r\nmonpriv->read_index = 0;\r\nmonpriv->path = NULL;\r\nreturn 0;\r\n}\r\nstatic int monreader_thaw(struct device *dev)\r\n{\r\nstruct mon_private *monpriv = dev_get_drvdata(dev);\r\nint rc;\r\nif (!monpriv)\r\nreturn 0;\r\nrc = -ENOMEM;\r\nmonpriv->path = iucv_path_alloc(MON_MSGLIM, IUCV_IPRMDATA, GFP_KERNEL);\r\nif (!monpriv->path)\r\ngoto out;\r\nrc = iucv_path_connect(monpriv->path, &monreader_iucv_handler,\r\nMON_SERVICE, NULL, user_data_connect, monpriv);\r\nif (rc) {\r\npr_err("Connecting to the z/VM *MONITOR system service "\r\n"failed with rc=%i\n", rc);\r\ngoto out_path;\r\n}\r\nwait_event(mon_conn_wait_queue,\r\natomic_read(&monpriv->iucv_connected) ||\r\natomic_read(&monpriv->iucv_severed));\r\nif (atomic_read(&monpriv->iucv_severed))\r\ngoto out_path;\r\nreturn 0;\r\nout_path:\r\nrc = -EIO;\r\niucv_path_free(monpriv->path);\r\nmonpriv->path = NULL;\r\nout:\r\natomic_set(&monpriv->iucv_severed, 1);\r\nreturn rc;\r\n}\r\nstatic int monreader_restore(struct device *dev)\r\n{\r\nint rc;\r\nsegment_unload(mon_dcss_name);\r\nrc = segment_load(mon_dcss_name, SEGMENT_SHARED,\r\n&mon_dcss_start, &mon_dcss_end);\r\nif (rc < 0) {\r\nsegment_warning(rc, mon_dcss_name);\r\npanic("fatal monreader resume error: no monitor dcss\n");\r\n}\r\nreturn monreader_thaw(dev);\r\n}\r\nstatic int __init mon_init(void)\r\n{\r\nint rc;\r\nif (!MACHINE_IS_VM) {\r\npr_err("The z/VM *MONITOR record device driver cannot be "\r\n"loaded without z/VM\n");\r\nreturn -ENODEV;\r\n}\r\nrc = iucv_register(&monreader_iucv_handler, 1);\r\nif (rc) {\r\npr_err("The z/VM *MONITOR record device driver failed to "\r\n"register with IUCV\n");\r\nreturn rc;\r\n}\r\nrc = driver_register(&monreader_driver);\r\nif (rc)\r\ngoto out_iucv;\r\nmonreader_device = kzalloc(sizeof(struct device), GFP_KERNEL);\r\nif (!monreader_device) {\r\nrc = -ENOMEM;\r\ngoto out_driver;\r\n}\r\ndev_set_name(monreader_device, "monreader-dev");\r\nmonreader_device->bus = &iucv_bus;\r\nmonreader_device->parent = iucv_root;\r\nmonreader_device->driver = &monreader_driver;\r\nmonreader_device->release = (void (*)(struct device *))kfree;\r\nrc = device_register(monreader_device);\r\nif (rc) {\r\nput_device(monreader_device);\r\ngoto out_driver;\r\n}\r\nrc = segment_type(mon_dcss_name);\r\nif (rc < 0) {\r\nsegment_warning(rc, mon_dcss_name);\r\ngoto out_device;\r\n}\r\nif (rc != SEG_TYPE_SC) {\r\npr_err("The specified *MONITOR DCSS %s does not have the "\r\n"required type SC\n", mon_dcss_name);\r\nrc = -EINVAL;\r\ngoto out_device;\r\n}\r\nrc = segment_load(mon_dcss_name, SEGMENT_SHARED,\r\n&mon_dcss_start, &mon_dcss_end);\r\nif (rc < 0) {\r\nsegment_warning(rc, mon_dcss_name);\r\nrc = -EINVAL;\r\ngoto out_device;\r\n}\r\ndcss_mkname(mon_dcss_name, &user_data_connect[8]);\r\nrc = misc_register(&mon_dev);\r\nif (rc < 0 )\r\ngoto out;\r\nreturn 0;\r\nout:\r\nsegment_unload(mon_dcss_name);\r\nout_device:\r\ndevice_unregister(monreader_device);\r\nout_driver:\r\ndriver_unregister(&monreader_driver);\r\nout_iucv:\r\niucv_unregister(&monreader_iucv_handler, 1);\r\nreturn rc;\r\n}\r\nstatic void __exit mon_exit(void)\r\n{\r\nsegment_unload(mon_dcss_name);\r\nmisc_deregister(&mon_dev);\r\ndevice_unregister(monreader_device);\r\ndriver_unregister(&monreader_driver);\r\niucv_unregister(&monreader_iucv_handler, 1);\r\nreturn;\r\n}
