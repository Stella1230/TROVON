static int check_args(struct pci_bus *bus, u32 devfn, u32 * bus_num)\r\n{\r\nif (bus->parent != NULL) {\r\n*bus_num = bus->number;\r\ndb_assert(bus_num != NULL);\r\n} else\r\n*bus_num = 0;\r\nif (*bus_num == 0) {\r\nif (PCI_SLOT(devfn) >= 10)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n} else {\r\nif ((*bus_num >= 64) || (PCI_SLOT(devfn) >= 16))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int set_pci_configuration_address(unsigned char bus_num,\r\nunsigned int devfn, int where)\r\n{\r\nu32 config_win0;\r\nemma2rh_out32(EMMA2RH_PCI_INT, ~RMABORT);\r\nif (bus_num == 0)\r\nconfig_win0 = (1 << (22 + PCI_SLOT(devfn))) | (5 << 9);\r\nelse\r\nconfig_win0 = (bus_num << 26) | (PCI_SLOT(devfn) << 22) |\r\n(1 << 15) | (5 << 9);\r\nemma2rh_out32(EMMA2RH_PCI_IWIN0_CTR, config_win0);\r\nreturn 0;\r\n}\r\nstatic int pci_config_read(struct pci_bus *bus, unsigned int devfn, int where,\r\nint size, uint32_t * val)\r\n{\r\nu32 bus_num;\r\nu32 base = KSEG1ADDR(EMMA2RH_PCI_CONFIG_BASE);\r\nu32 backup_win0;\r\nu32 data;\r\n*val = 0xffffffffU;\r\nif (check_args(bus, devfn, &bus_num) == PCIBIOS_DEVICE_NOT_FOUND)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nbackup_win0 = emma2rh_in32(EMMA2RH_PCI_IWIN0_CTR);\r\nif (set_pci_configuration_address(bus_num, devfn, where) < 0)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\ndata =\r\n*(volatile u32 *)(base + (PCI_FUNC(devfn) << 8) +\r\n(where & 0xfffffffc));\r\nswitch (size) {\r\ncase 1:\r\n*val = (data >> ((where & 3) << 3)) & 0xffU;\r\nbreak;\r\ncase 2:\r\n*val = (data >> ((where & 2) << 3)) & 0xffffU;\r\nbreak;\r\ncase 4:\r\n*val = data;\r\nbreak;\r\ndefault:\r\nemma2rh_out32(EMMA2RH_PCI_IWIN0_CTR, backup_win0);\r\nreturn PCIBIOS_FUNC_NOT_SUPPORTED;\r\n}\r\nemma2rh_out32(EMMA2RH_PCI_IWIN0_CTR, backup_win0);\r\nif (emma2rh_in32(EMMA2RH_PCI_INT) & RMABORT)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int pci_config_write(struct pci_bus *bus, unsigned int devfn, int where,\r\nint size, u32 val)\r\n{\r\nu32 bus_num;\r\nu32 base = KSEG1ADDR(EMMA2RH_PCI_CONFIG_BASE);\r\nu32 backup_win0;\r\nu32 data;\r\nint shift;\r\nif (check_args(bus, devfn, &bus_num) == PCIBIOS_DEVICE_NOT_FOUND)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nbackup_win0 = emma2rh_in32(EMMA2RH_PCI_IWIN0_CTR);\r\nif (set_pci_configuration_address(bus_num, devfn, where) < 0)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\ndata =\r\n*(volatile u32 *)(base + (PCI_FUNC(devfn) << 8) +\r\n(where & 0xfffffffc));\r\nswitch (size) {\r\ncase 1:\r\nshift = (where & 3) << 3;\r\ndata &= ~(0xffU << shift);\r\ndata |= ((val & 0xffU) << shift);\r\nbreak;\r\ncase 2:\r\nshift = (where & 2) << 3;\r\ndata &= ~(0xffffU << shift);\r\ndata |= ((val & 0xffffU) << shift);\r\nbreak;\r\ncase 4:\r\ndata = val;\r\nbreak;\r\ndefault:\r\nemma2rh_out32(EMMA2RH_PCI_IWIN0_CTR, backup_win0);\r\nreturn PCIBIOS_FUNC_NOT_SUPPORTED;\r\n}\r\n*(volatile u32 *)(base + (PCI_FUNC(devfn) << 8) +\r\n(where & 0xfffffffc)) = data;\r\nemma2rh_out32(EMMA2RH_PCI_IWIN0_CTR, backup_win0);\r\nif (emma2rh_in32(EMMA2RH_PCI_INT) & RMABORT)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}
