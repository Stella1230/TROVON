static int pci_conf1_read(unsigned int seg, unsigned int bus,\r\nunsigned int devfn, int reg, int len, u32 *value)\r\n{\r\nunsigned long flags;\r\nif (seg || (bus > 255) || (devfn > 255) || (reg > 4095)) {\r\n*value = -1;\r\nreturn -EINVAL;\r\n}\r\nraw_spin_lock_irqsave(&pci_config_lock, flags);\r\noutl(PCI_CONF1_ADDRESS(bus, devfn, reg), 0xCF8);\r\nswitch (len) {\r\ncase 1:\r\n*value = inb(0xCFC + (reg & 3));\r\nbreak;\r\ncase 2:\r\n*value = inw(0xCFC + (reg & 2));\r\nbreak;\r\ncase 4:\r\n*value = inl(0xCFC);\r\nbreak;\r\n}\r\nraw_spin_unlock_irqrestore(&pci_config_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int pci_conf1_write(unsigned int seg, unsigned int bus,\r\nunsigned int devfn, int reg, int len, u32 value)\r\n{\r\nunsigned long flags;\r\nif (seg || (bus > 255) || (devfn > 255) || (reg > 4095))\r\nreturn -EINVAL;\r\nraw_spin_lock_irqsave(&pci_config_lock, flags);\r\noutl(PCI_CONF1_ADDRESS(bus, devfn, reg), 0xCF8);\r\nswitch (len) {\r\ncase 1:\r\noutb((u8)value, 0xCFC + (reg & 3));\r\nbreak;\r\ncase 2:\r\noutw((u16)value, 0xCFC + (reg & 2));\r\nbreak;\r\ncase 4:\r\noutl((u32)value, 0xCFC);\r\nbreak;\r\n}\r\nraw_spin_unlock_irqrestore(&pci_config_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int pci_conf2_read(unsigned int seg, unsigned int bus,\r\nunsigned int devfn, int reg, int len, u32 *value)\r\n{\r\nunsigned long flags;\r\nint dev, fn;\r\nWARN_ON(seg);\r\nif ((bus > 255) || (devfn > 255) || (reg > 255)) {\r\n*value = -1;\r\nreturn -EINVAL;\r\n}\r\ndev = PCI_SLOT(devfn);\r\nfn = PCI_FUNC(devfn);\r\nif (dev & 0x10)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nraw_spin_lock_irqsave(&pci_config_lock, flags);\r\noutb((u8)(0xF0 | (fn << 1)), 0xCF8);\r\noutb((u8)bus, 0xCFA);\r\nswitch (len) {\r\ncase 1:\r\n*value = inb(PCI_CONF2_ADDRESS(dev, reg));\r\nbreak;\r\ncase 2:\r\n*value = inw(PCI_CONF2_ADDRESS(dev, reg));\r\nbreak;\r\ncase 4:\r\n*value = inl(PCI_CONF2_ADDRESS(dev, reg));\r\nbreak;\r\n}\r\noutb(0, 0xCF8);\r\nraw_spin_unlock_irqrestore(&pci_config_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int pci_conf2_write(unsigned int seg, unsigned int bus,\r\nunsigned int devfn, int reg, int len, u32 value)\r\n{\r\nunsigned long flags;\r\nint dev, fn;\r\nWARN_ON(seg);\r\nif ((bus > 255) || (devfn > 255) || (reg > 255))\r\nreturn -EINVAL;\r\ndev = PCI_SLOT(devfn);\r\nfn = PCI_FUNC(devfn);\r\nif (dev & 0x10)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nraw_spin_lock_irqsave(&pci_config_lock, flags);\r\noutb((u8)(0xF0 | (fn << 1)), 0xCF8);\r\noutb((u8)bus, 0xCFA);\r\nswitch (len) {\r\ncase 1:\r\noutb((u8)value, PCI_CONF2_ADDRESS(dev, reg));\r\nbreak;\r\ncase 2:\r\noutw((u16)value, PCI_CONF2_ADDRESS(dev, reg));\r\nbreak;\r\ncase 4:\r\noutl((u32)value, PCI_CONF2_ADDRESS(dev, reg));\r\nbreak;\r\n}\r\noutb(0, 0xCF8);\r\nraw_spin_unlock_irqrestore(&pci_config_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int __init pci_sanity_check(const struct pci_raw_ops *o)\r\n{\r\nu32 x = 0;\r\nint year, devfn;\r\nif (pci_probe & PCI_NO_CHECKS)\r\nreturn 1;\r\ndmi_get_date(DMI_BIOS_DATE, &year, NULL, NULL);\r\nif (year >= 2001)\r\nreturn 1;\r\nfor (devfn = 0; devfn < 0x100; devfn++) {\r\nif (o->read(0, 0, devfn, PCI_CLASS_DEVICE, 2, &x))\r\ncontinue;\r\nif (x == PCI_CLASS_BRIDGE_HOST || x == PCI_CLASS_DISPLAY_VGA)\r\nreturn 1;\r\nif (o->read(0, 0, devfn, PCI_VENDOR_ID, 2, &x))\r\ncontinue;\r\nif (x == PCI_VENDOR_ID_INTEL || x == PCI_VENDOR_ID_COMPAQ)\r\nreturn 1;\r\n}\r\nDBG(KERN_WARNING "PCI: Sanity check failed\n");\r\nreturn 0;\r\n}\r\nstatic int __init pci_check_type1(void)\r\n{\r\nunsigned long flags;\r\nunsigned int tmp;\r\nint works = 0;\r\nlocal_irq_save(flags);\r\noutb(0x01, 0xCFB);\r\ntmp = inl(0xCF8);\r\noutl(0x80000000, 0xCF8);\r\nif (inl(0xCF8) == 0x80000000 && pci_sanity_check(&pci_direct_conf1)) {\r\nworks = 1;\r\n}\r\noutl(tmp, 0xCF8);\r\nlocal_irq_restore(flags);\r\nreturn works;\r\n}\r\nstatic int __init pci_check_type2(void)\r\n{\r\nunsigned long flags;\r\nint works = 0;\r\nlocal_irq_save(flags);\r\noutb(0x00, 0xCFB);\r\noutb(0x00, 0xCF8);\r\noutb(0x00, 0xCFA);\r\nif (inb(0xCF8) == 0x00 && inb(0xCFA) == 0x00 &&\r\npci_sanity_check(&pci_direct_conf2)) {\r\nworks = 1;\r\n}\r\nlocal_irq_restore(flags);\r\nreturn works;\r\n}\r\nvoid __init pci_direct_init(int type)\r\n{\r\nif (type == 0)\r\nreturn;\r\nprintk(KERN_INFO "PCI: Using configuration type %d for base access\n",\r\ntype);\r\nif (type == 1) {\r\nraw_pci_ops = &pci_direct_conf1;\r\nif (raw_pci_ext_ops)\r\nreturn;\r\nif (!(pci_probe & PCI_HAS_IO_ECS))\r\nreturn;\r\nprintk(KERN_INFO "PCI: Using configuration type 1 "\r\n"for extended access\n");\r\nraw_pci_ext_ops = &pci_direct_conf1;\r\nreturn;\r\n}\r\nraw_pci_ops = &pci_direct_conf2;\r\n}\r\nint __init pci_direct_probe(void)\r\n{\r\nif ((pci_probe & PCI_PROBE_CONF1) == 0)\r\ngoto type2;\r\nif (!request_region(0xCF8, 8, "PCI conf1"))\r\ngoto type2;\r\nif (pci_check_type1()) {\r\nraw_pci_ops = &pci_direct_conf1;\r\nport_cf9_safe = true;\r\nreturn 1;\r\n}\r\nrelease_region(0xCF8, 8);\r\ntype2:\r\nif ((pci_probe & PCI_PROBE_CONF2) == 0)\r\nreturn 0;\r\nif (!request_region(0xCF8, 4, "PCI conf2"))\r\nreturn 0;\r\nif (!request_region(0xC000, 0x1000, "PCI conf2"))\r\ngoto fail2;\r\nif (pci_check_type2()) {\r\nraw_pci_ops = &pci_direct_conf2;\r\nport_cf9_safe = true;\r\nreturn 2;\r\n}\r\nrelease_region(0xC000, 0x1000);\r\nfail2:\r\nrelease_region(0xCF8, 4);\r\nreturn 0;\r\n}
