static ssize_t dw_spi_show_regs(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct dw_spi *dws = file->private_data;\r\nchar *buf;\r\nu32 len = 0;\r\nssize_t ret;\r\nbuf = kzalloc(SPI_REGS_BUFSIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn 0;\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"%s registers:\n", dev_name(&dws->master->dev));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"=================================\n");\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"CTRL0: \t\t0x%08x\n", dw_readl(dws, DW_SPI_CTRL0));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"CTRL1: \t\t0x%08x\n", dw_readl(dws, DW_SPI_CTRL1));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"SSIENR: \t0x%08x\n", dw_readl(dws, DW_SPI_SSIENR));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"SER: \t\t0x%08x\n", dw_readl(dws, DW_SPI_SER));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"BAUDR: \t\t0x%08x\n", dw_readl(dws, DW_SPI_BAUDR));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"TXFTLR: \t0x%08x\n", dw_readl(dws, DW_SPI_TXFLTR));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"RXFTLR: \t0x%08x\n", dw_readl(dws, DW_SPI_RXFLTR));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"TXFLR: \t\t0x%08x\n", dw_readl(dws, DW_SPI_TXFLR));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"RXFLR: \t\t0x%08x\n", dw_readl(dws, DW_SPI_RXFLR));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"SR: \t\t0x%08x\n", dw_readl(dws, DW_SPI_SR));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"IMR: \t\t0x%08x\n", dw_readl(dws, DW_SPI_IMR));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"ISR: \t\t0x%08x\n", dw_readl(dws, DW_SPI_ISR));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"DMACR: \t\t0x%08x\n", dw_readl(dws, DW_SPI_DMACR));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"DMATDLR: \t0x%08x\n", dw_readl(dws, DW_SPI_DMATDLR));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"DMARDLR: \t0x%08x\n", dw_readl(dws, DW_SPI_DMARDLR));\r\nlen += snprintf(buf + len, SPI_REGS_BUFSIZE - len,\r\n"=================================\n");\r\nret = simple_read_from_buffer(user_buf, count, ppos, buf, len);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int dw_spi_debugfs_init(struct dw_spi *dws)\r\n{\r\ndws->debugfs = debugfs_create_dir("dw_spi", NULL);\r\nif (!dws->debugfs)\r\nreturn -ENOMEM;\r\ndebugfs_create_file("registers", S_IFREG | S_IRUGO,\r\ndws->debugfs, (void *)dws, &dw_spi_regs_ops);\r\nreturn 0;\r\n}\r\nstatic void dw_spi_debugfs_remove(struct dw_spi *dws)\r\n{\r\ndebugfs_remove_recursive(dws->debugfs);\r\n}\r\nstatic inline int dw_spi_debugfs_init(struct dw_spi *dws)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void dw_spi_debugfs_remove(struct dw_spi *dws)\r\n{\r\n}\r\nstatic void dw_spi_set_cs(struct spi_device *spi, bool enable)\r\n{\r\nstruct dw_spi *dws = spi_master_get_devdata(spi->master);\r\nstruct chip_data *chip = spi_get_ctldata(spi);\r\nif (chip && chip->cs_control)\r\nchip->cs_control(!enable);\r\nif (!enable)\r\ndw_writel(dws, DW_SPI_SER, BIT(spi->chip_select));\r\n}\r\nstatic inline u32 tx_max(struct dw_spi *dws)\r\n{\r\nu32 tx_left, tx_room, rxtx_gap;\r\ntx_left = (dws->tx_end - dws->tx) / dws->n_bytes;\r\ntx_room = dws->fifo_len - dw_readl(dws, DW_SPI_TXFLR);\r\nrxtx_gap = ((dws->rx_end - dws->rx) - (dws->tx_end - dws->tx))\r\n/ dws->n_bytes;\r\nreturn min3(tx_left, tx_room, (u32) (dws->fifo_len - rxtx_gap));\r\n}\r\nstatic inline u32 rx_max(struct dw_spi *dws)\r\n{\r\nu32 rx_left = (dws->rx_end - dws->rx) / dws->n_bytes;\r\nreturn min_t(u32, rx_left, dw_readl(dws, DW_SPI_RXFLR));\r\n}\r\nstatic void dw_writer(struct dw_spi *dws)\r\n{\r\nu32 max = tx_max(dws);\r\nu16 txw = 0;\r\nwhile (max--) {\r\nif (dws->tx_end - dws->len) {\r\nif (dws->n_bytes == 1)\r\ntxw = *(u8 *)(dws->tx);\r\nelse\r\ntxw = *(u16 *)(dws->tx);\r\n}\r\ndw_writel(dws, DW_SPI_DR, txw);\r\ndws->tx += dws->n_bytes;\r\n}\r\n}\r\nstatic void dw_reader(struct dw_spi *dws)\r\n{\r\nu32 max = rx_max(dws);\r\nu16 rxw;\r\nwhile (max--) {\r\nrxw = dw_readl(dws, DW_SPI_DR);\r\nif (dws->rx_end - dws->len) {\r\nif (dws->n_bytes == 1)\r\n*(u8 *)(dws->rx) = rxw;\r\nelse\r\n*(u16 *)(dws->rx) = rxw;\r\n}\r\ndws->rx += dws->n_bytes;\r\n}\r\n}\r\nstatic void int_error_stop(struct dw_spi *dws, const char *msg)\r\n{\r\nspi_reset_chip(dws);\r\ndev_err(&dws->master->dev, "%s\n", msg);\r\ndws->master->cur_msg->status = -EIO;\r\nspi_finalize_current_transfer(dws->master);\r\n}\r\nstatic irqreturn_t interrupt_transfer(struct dw_spi *dws)\r\n{\r\nu16 irq_status = dw_readl(dws, DW_SPI_ISR);\r\nif (irq_status & (SPI_INT_TXOI | SPI_INT_RXOI | SPI_INT_RXUI)) {\r\ndw_readl(dws, DW_SPI_ICR);\r\nint_error_stop(dws, "interrupt_transfer: fifo overrun/underrun");\r\nreturn IRQ_HANDLED;\r\n}\r\ndw_reader(dws);\r\nif (dws->rx_end == dws->rx) {\r\nspi_mask_intr(dws, SPI_INT_TXEI);\r\nspi_finalize_current_transfer(dws->master);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (irq_status & SPI_INT_TXEI) {\r\nspi_mask_intr(dws, SPI_INT_TXEI);\r\ndw_writer(dws);\r\nspi_umask_intr(dws, SPI_INT_TXEI);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t dw_spi_irq(int irq, void *dev_id)\r\n{\r\nstruct spi_master *master = dev_id;\r\nstruct dw_spi *dws = spi_master_get_devdata(master);\r\nu16 irq_status = dw_readl(dws, DW_SPI_ISR) & 0x3f;\r\nif (!irq_status)\r\nreturn IRQ_NONE;\r\nif (!master->cur_msg) {\r\nspi_mask_intr(dws, SPI_INT_TXEI);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn dws->transfer_handler(dws);\r\n}\r\nstatic int poll_transfer(struct dw_spi *dws)\r\n{\r\ndo {\r\ndw_writer(dws);\r\ndw_reader(dws);\r\ncpu_relax();\r\n} while (dws->rx_end > dws->rx);\r\nreturn 0;\r\n}\r\nstatic int dw_spi_transfer_one(struct spi_master *master,\r\nstruct spi_device *spi, struct spi_transfer *transfer)\r\n{\r\nstruct dw_spi *dws = spi_master_get_devdata(master);\r\nstruct chip_data *chip = spi_get_ctldata(spi);\r\nu8 imask = 0;\r\nu16 txlevel = 0;\r\nu16 clk_div = 0;\r\nu32 speed = 0;\r\nu32 cr0 = 0;\r\nint ret;\r\ndws->dma_mapped = 0;\r\ndws->n_bytes = chip->n_bytes;\r\ndws->dma_width = chip->dma_width;\r\ndws->tx = (void *)transfer->tx_buf;\r\ndws->tx_end = dws->tx + transfer->len;\r\ndws->rx = transfer->rx_buf;\r\ndws->rx_end = dws->rx + transfer->len;\r\ndws->len = transfer->len;\r\nspi_enable_chip(dws, 0);\r\ncr0 = chip->cr0;\r\nif (transfer->speed_hz) {\r\nspeed = chip->speed_hz;\r\nif ((transfer->speed_hz != speed) || !chip->clk_div) {\r\nspeed = transfer->speed_hz;\r\nclk_div = (dws->max_freq / speed + 1) & 0xfffe;\r\nchip->speed_hz = speed;\r\nchip->clk_div = clk_div;\r\nspi_set_clk(dws, chip->clk_div);\r\n}\r\n}\r\nif (transfer->bits_per_word) {\r\nif (transfer->bits_per_word == 8) {\r\ndws->n_bytes = 1;\r\ndws->dma_width = 1;\r\n} else if (transfer->bits_per_word == 16) {\r\ndws->n_bytes = 2;\r\ndws->dma_width = 2;\r\n}\r\ncr0 = (transfer->bits_per_word - 1)\r\n| (chip->type << SPI_FRF_OFFSET)\r\n| (spi->mode << SPI_MODE_OFFSET)\r\n| (chip->tmode << SPI_TMOD_OFFSET);\r\n}\r\nif (chip->cs_control) {\r\nif (dws->rx && dws->tx)\r\nchip->tmode = SPI_TMOD_TR;\r\nelse if (dws->rx)\r\nchip->tmode = SPI_TMOD_RO;\r\nelse\r\nchip->tmode = SPI_TMOD_TO;\r\ncr0 &= ~SPI_TMOD_MASK;\r\ncr0 |= (chip->tmode << SPI_TMOD_OFFSET);\r\n}\r\ndw_writel(dws, DW_SPI_CTRL0, cr0);\r\nif (master->can_dma && master->can_dma(master, spi, transfer))\r\ndws->dma_mapped = master->cur_msg_mapped;\r\nspi_mask_intr(dws, 0xff);\r\nif (dws->dma_mapped) {\r\nret = dws->dma_ops->dma_setup(dws, transfer);\r\nif (ret < 0) {\r\nspi_enable_chip(dws, 1);\r\nreturn ret;\r\n}\r\n} else if (!chip->poll_mode) {\r\ntxlevel = min_t(u16, dws->fifo_len / 2, dws->len / dws->n_bytes);\r\ndw_writel(dws, DW_SPI_TXFLTR, txlevel);\r\nimask |= SPI_INT_TXEI | SPI_INT_TXOI |\r\nSPI_INT_RXUI | SPI_INT_RXOI;\r\nspi_umask_intr(dws, imask);\r\ndws->transfer_handler = interrupt_transfer;\r\n}\r\nspi_enable_chip(dws, 1);\r\nif (dws->dma_mapped) {\r\nret = dws->dma_ops->dma_transfer(dws, transfer);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (chip->poll_mode)\r\nreturn poll_transfer(dws);\r\nreturn 1;\r\n}\r\nstatic void dw_spi_handle_err(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nstruct dw_spi *dws = spi_master_get_devdata(master);\r\nif (dws->dma_mapped)\r\ndws->dma_ops->dma_stop(dws);\r\nspi_reset_chip(dws);\r\n}\r\nstatic int dw_spi_setup(struct spi_device *spi)\r\n{\r\nstruct dw_spi_chip *chip_info = NULL;\r\nstruct chip_data *chip;\r\nint ret;\r\nchip = spi_get_ctldata(spi);\r\nif (!chip) {\r\nchip = kzalloc(sizeof(struct chip_data), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nspi_set_ctldata(spi, chip);\r\n}\r\nchip_info = spi->controller_data;\r\nif (chip_info) {\r\nif (chip_info->cs_control)\r\nchip->cs_control = chip_info->cs_control;\r\nchip->poll_mode = chip_info->poll_mode;\r\nchip->type = chip_info->type;\r\nchip->rx_threshold = 0;\r\nchip->tx_threshold = 0;\r\n}\r\nif (spi->bits_per_word == 8) {\r\nchip->n_bytes = 1;\r\nchip->dma_width = 1;\r\n} else if (spi->bits_per_word == 16) {\r\nchip->n_bytes = 2;\r\nchip->dma_width = 2;\r\n}\r\nchip->bits_per_word = spi->bits_per_word;\r\nif (!spi->max_speed_hz) {\r\ndev_err(&spi->dev, "No max speed HZ parameter\n");\r\nreturn -EINVAL;\r\n}\r\nchip->tmode = 0;\r\nchip->cr0 = (chip->bits_per_word - 1)\r\n| (chip->type << SPI_FRF_OFFSET)\r\n| (spi->mode << SPI_MODE_OFFSET)\r\n| (chip->tmode << SPI_TMOD_OFFSET);\r\nif (spi->mode & SPI_LOOP)\r\nchip->cr0 |= 1 << SPI_SRL_OFFSET;\r\nif (gpio_is_valid(spi->cs_gpio)) {\r\nret = gpio_direction_output(spi->cs_gpio,\r\n!(spi->mode & SPI_CS_HIGH));\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dw_spi_cleanup(struct spi_device *spi)\r\n{\r\nstruct chip_data *chip = spi_get_ctldata(spi);\r\nkfree(chip);\r\nspi_set_ctldata(spi, NULL);\r\n}\r\nstatic void spi_hw_init(struct device *dev, struct dw_spi *dws)\r\n{\r\nspi_reset_chip(dws);\r\nif (!dws->fifo_len) {\r\nu32 fifo;\r\nfor (fifo = 1; fifo < 256; fifo++) {\r\ndw_writel(dws, DW_SPI_TXFLTR, fifo);\r\nif (fifo != dw_readl(dws, DW_SPI_TXFLTR))\r\nbreak;\r\n}\r\ndw_writel(dws, DW_SPI_TXFLTR, 0);\r\ndws->fifo_len = (fifo == 1) ? 0 : fifo;\r\ndev_dbg(dev, "Detected FIFO size: %u bytes\n", dws->fifo_len);\r\n}\r\n}\r\nint dw_spi_add_host(struct device *dev, struct dw_spi *dws)\r\n{\r\nstruct spi_master *master;\r\nint ret;\r\nBUG_ON(dws == NULL);\r\nmaster = spi_alloc_master(dev, 0);\r\nif (!master)\r\nreturn -ENOMEM;\r\ndws->master = master;\r\ndws->type = SSI_MOTO_SPI;\r\ndws->dma_inited = 0;\r\ndws->dma_addr = (dma_addr_t)(dws->paddr + 0x60);\r\nsnprintf(dws->name, sizeof(dws->name), "dw_spi%d", dws->bus_num);\r\nret = devm_request_irq(dev, dws->irq, dw_spi_irq, IRQF_SHARED,\r\ndws->name, master);\r\nif (ret < 0) {\r\ndev_err(&master->dev, "can not get IRQ\n");\r\ngoto err_free_master;\r\n}\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LOOP;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(8) | SPI_BPW_MASK(16);\r\nmaster->bus_num = dws->bus_num;\r\nmaster->num_chipselect = dws->num_cs;\r\nmaster->setup = dw_spi_setup;\r\nmaster->cleanup = dw_spi_cleanup;\r\nmaster->set_cs = dw_spi_set_cs;\r\nmaster->transfer_one = dw_spi_transfer_one;\r\nmaster->handle_err = dw_spi_handle_err;\r\nmaster->max_speed_hz = dws->max_freq;\r\nmaster->dev.of_node = dev->of_node;\r\nspi_hw_init(dev, dws);\r\nif (dws->dma_ops && dws->dma_ops->dma_init) {\r\nret = dws->dma_ops->dma_init(dws);\r\nif (ret) {\r\ndev_warn(dev, "DMA init failed\n");\r\ndws->dma_inited = 0;\r\n} else {\r\nmaster->can_dma = dws->dma_ops->can_dma;\r\n}\r\n}\r\nspi_master_set_devdata(master, dws);\r\nret = devm_spi_register_master(dev, master);\r\nif (ret) {\r\ndev_err(&master->dev, "problem registering spi master\n");\r\ngoto err_dma_exit;\r\n}\r\ndw_spi_debugfs_init(dws);\r\nreturn 0;\r\nerr_dma_exit:\r\nif (dws->dma_ops && dws->dma_ops->dma_exit)\r\ndws->dma_ops->dma_exit(dws);\r\nspi_enable_chip(dws, 0);\r\nerr_free_master:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nvoid dw_spi_remove_host(struct dw_spi *dws)\r\n{\r\nif (!dws)\r\nreturn;\r\ndw_spi_debugfs_remove(dws);\r\nif (dws->dma_ops && dws->dma_ops->dma_exit)\r\ndws->dma_ops->dma_exit(dws);\r\nspi_enable_chip(dws, 0);\r\nspi_set_clk(dws, 0);\r\n}\r\nint dw_spi_suspend_host(struct dw_spi *dws)\r\n{\r\nint ret = 0;\r\nret = spi_master_suspend(dws->master);\r\nif (ret)\r\nreturn ret;\r\nspi_enable_chip(dws, 0);\r\nspi_set_clk(dws, 0);\r\nreturn ret;\r\n}\r\nint dw_spi_resume_host(struct dw_spi *dws)\r\n{\r\nint ret;\r\nspi_hw_init(&dws->master->dev, dws);\r\nret = spi_master_resume(dws->master);\r\nif (ret)\r\ndev_err(&dws->master->dev, "fail to start queue (%d)\n", ret);\r\nreturn ret;\r\n}
