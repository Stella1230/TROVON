static void mousedev_touchpad_event(struct input_dev *dev,\r\nstruct mousedev *mousedev,\r\nunsigned int code, int value)\r\n{\r\nint size, tmp;\r\nenum { FRACTION_DENOM = 128 };\r\nswitch (code) {\r\ncase ABS_X:\r\nfx(0) = value;\r\nif (mousedev->touch && mousedev->pkt_count >= 2) {\r\nsize = input_abs_get_max(dev, ABS_X) -\r\ninput_abs_get_min(dev, ABS_X);\r\nif (size == 0)\r\nsize = 256 * 2;\r\ntmp = ((value - fx(2)) * 256 * FRACTION_DENOM) / size;\r\ntmp += mousedev->frac_dx;\r\nmousedev->packet.dx = tmp / FRACTION_DENOM;\r\nmousedev->frac_dx =\r\ntmp - mousedev->packet.dx * FRACTION_DENOM;\r\n}\r\nbreak;\r\ncase ABS_Y:\r\nfy(0) = value;\r\nif (mousedev->touch && mousedev->pkt_count >= 2) {\r\nsize = input_abs_get_max(dev, ABS_X) -\r\ninput_abs_get_min(dev, ABS_X);\r\nif (size == 0)\r\nsize = 256 * 2;\r\ntmp = -((value - fy(2)) * 256 * FRACTION_DENOM) / size;\r\ntmp += mousedev->frac_dy;\r\nmousedev->packet.dy = tmp / FRACTION_DENOM;\r\nmousedev->frac_dy = tmp -\r\nmousedev->packet.dy * FRACTION_DENOM;\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void mousedev_abs_event(struct input_dev *dev, struct mousedev *mousedev,\r\nunsigned int code, int value)\r\n{\r\nint min, max, size;\r\nswitch (code) {\r\ncase ABS_X:\r\nmin = input_abs_get_min(dev, ABS_X);\r\nmax = input_abs_get_max(dev, ABS_X);\r\nsize = max - min;\r\nif (size == 0)\r\nsize = xres ? : 1;\r\nvalue = clamp(value, min, max);\r\nmousedev->packet.x = ((value - min) * xres) / size;\r\nmousedev->packet.abs_event = 1;\r\nbreak;\r\ncase ABS_Y:\r\nmin = input_abs_get_min(dev, ABS_Y);\r\nmax = input_abs_get_max(dev, ABS_Y);\r\nsize = max - min;\r\nif (size == 0)\r\nsize = yres ? : 1;\r\nvalue = clamp(value, min, max);\r\nmousedev->packet.y = yres - ((value - min) * yres) / size;\r\nmousedev->packet.abs_event = 1;\r\nbreak;\r\n}\r\n}\r\nstatic void mousedev_rel_event(struct mousedev *mousedev,\r\nunsigned int code, int value)\r\n{\r\nswitch (code) {\r\ncase REL_X:\r\nmousedev->packet.dx += value;\r\nbreak;\r\ncase REL_Y:\r\nmousedev->packet.dy -= value;\r\nbreak;\r\ncase REL_WHEEL:\r\nmousedev->packet.dz -= value;\r\nbreak;\r\n}\r\n}\r\nstatic void mousedev_key_event(struct mousedev *mousedev,\r\nunsigned int code, int value)\r\n{\r\nint index;\r\nswitch (code) {\r\ncase BTN_TOUCH:\r\ncase BTN_0:\r\ncase BTN_LEFT: index = 0; break;\r\ncase BTN_STYLUS:\r\ncase BTN_1:\r\ncase BTN_RIGHT: index = 1; break;\r\ncase BTN_2:\r\ncase BTN_FORWARD:\r\ncase BTN_STYLUS2:\r\ncase BTN_MIDDLE: index = 2; break;\r\ncase BTN_3:\r\ncase BTN_BACK:\r\ncase BTN_SIDE: index = 3; break;\r\ncase BTN_4:\r\ncase BTN_EXTRA: index = 4; break;\r\ndefault: return;\r\n}\r\nif (value) {\r\nset_bit(index, &mousedev->packet.buttons);\r\nset_bit(index, &mousedev_mix->packet.buttons);\r\n} else {\r\nclear_bit(index, &mousedev->packet.buttons);\r\nclear_bit(index, &mousedev_mix->packet.buttons);\r\n}\r\n}\r\nstatic void mousedev_notify_readers(struct mousedev *mousedev,\r\nstruct mousedev_hw_data *packet)\r\n{\r\nstruct mousedev_client *client;\r\nstruct mousedev_motion *p;\r\nunsigned int new_head;\r\nint wake_readers = 0;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(client, &mousedev->client_list, node) {\r\nspin_lock(&client->packet_lock);\r\np = &client->packets[client->head];\r\nif (client->ready && p->buttons != mousedev->packet.buttons) {\r\nnew_head = (client->head + 1) % PACKET_QUEUE_LEN;\r\nif (new_head != client->tail) {\r\np = &client->packets[client->head = new_head];\r\nmemset(p, 0, sizeof(struct mousedev_motion));\r\n}\r\n}\r\nif (packet->abs_event) {\r\np->dx += packet->x - client->pos_x;\r\np->dy += packet->y - client->pos_y;\r\nclient->pos_x = packet->x;\r\nclient->pos_y = packet->y;\r\n}\r\nclient->pos_x += packet->dx;\r\nclient->pos_x = client->pos_x < 0 ?\r\n0 : (client->pos_x >= xres ? xres : client->pos_x);\r\nclient->pos_y += packet->dy;\r\nclient->pos_y = client->pos_y < 0 ?\r\n0 : (client->pos_y >= yres ? yres : client->pos_y);\r\np->dx += packet->dx;\r\np->dy += packet->dy;\r\np->dz += packet->dz;\r\np->buttons = mousedev->packet.buttons;\r\nif (p->dx || p->dy || p->dz ||\r\np->buttons != client->last_buttons)\r\nclient->ready = 1;\r\nspin_unlock(&client->packet_lock);\r\nif (client->ready) {\r\nkill_fasync(&client->fasync, SIGIO, POLL_IN);\r\nwake_readers = 1;\r\n}\r\n}\r\nrcu_read_unlock();\r\nif (wake_readers)\r\nwake_up_interruptible(&mousedev->wait);\r\n}\r\nstatic void mousedev_touchpad_touch(struct mousedev *mousedev, int value)\r\n{\r\nif (!value) {\r\nif (mousedev->touch &&\r\ntime_before(jiffies,\r\nmousedev->touch + msecs_to_jiffies(tap_time))) {\r\nset_bit(0, &mousedev->packet.buttons);\r\nset_bit(0, &mousedev_mix->packet.buttons);\r\nmousedev_notify_readers(mousedev, &mousedev_mix->packet);\r\nmousedev_notify_readers(mousedev_mix,\r\n&mousedev_mix->packet);\r\nclear_bit(0, &mousedev->packet.buttons);\r\nclear_bit(0, &mousedev_mix->packet.buttons);\r\n}\r\nmousedev->touch = mousedev->pkt_count = 0;\r\nmousedev->frac_dx = 0;\r\nmousedev->frac_dy = 0;\r\n} else if (!mousedev->touch)\r\nmousedev->touch = jiffies;\r\n}\r\nstatic void mousedev_event(struct input_handle *handle,\r\nunsigned int type, unsigned int code, int value)\r\n{\r\nstruct mousedev *mousedev = handle->private;\r\nswitch (type) {\r\ncase EV_ABS:\r\nif (test_bit(BTN_TRIGGER, handle->dev->keybit))\r\nreturn;\r\nif (test_bit(BTN_TOOL_FINGER, handle->dev->keybit))\r\nmousedev_touchpad_event(handle->dev,\r\nmousedev, code, value);\r\nelse\r\nmousedev_abs_event(handle->dev, mousedev, code, value);\r\nbreak;\r\ncase EV_REL:\r\nmousedev_rel_event(mousedev, code, value);\r\nbreak;\r\ncase EV_KEY:\r\nif (value != 2) {\r\nif (code == BTN_TOUCH &&\r\ntest_bit(BTN_TOOL_FINGER, handle->dev->keybit))\r\nmousedev_touchpad_touch(mousedev, value);\r\nelse\r\nmousedev_key_event(mousedev, code, value);\r\n}\r\nbreak;\r\ncase EV_SYN:\r\nif (code == SYN_REPORT) {\r\nif (mousedev->touch) {\r\nmousedev->pkt_count++;\r\nfx(0) = fx(1);\r\nfy(0) = fy(1);\r\n}\r\nmousedev_notify_readers(mousedev, &mousedev->packet);\r\nmousedev_notify_readers(mousedev_mix, &mousedev->packet);\r\nmousedev->packet.dx = mousedev->packet.dy =\r\nmousedev->packet.dz = 0;\r\nmousedev->packet.abs_event = 0;\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic int mousedev_fasync(int fd, struct file *file, int on)\r\n{\r\nstruct mousedev_client *client = file->private_data;\r\nreturn fasync_helper(fd, file, on, &client->fasync);\r\n}\r\nstatic void mousedev_free(struct device *dev)\r\n{\r\nstruct mousedev *mousedev = container_of(dev, struct mousedev, dev);\r\ninput_put_device(mousedev->handle.dev);\r\nkfree(mousedev);\r\n}\r\nstatic int mousedev_open_device(struct mousedev *mousedev)\r\n{\r\nint retval;\r\nretval = mutex_lock_interruptible(&mousedev->mutex);\r\nif (retval)\r\nreturn retval;\r\nif (!mousedev->exist)\r\nretval = -ENODEV;\r\nelse if (!mousedev->open++) {\r\nretval = input_open_device(&mousedev->handle);\r\nif (retval)\r\nmousedev->open--;\r\n}\r\nmutex_unlock(&mousedev->mutex);\r\nreturn retval;\r\n}\r\nstatic void mousedev_close_device(struct mousedev *mousedev)\r\n{\r\nmutex_lock(&mousedev->mutex);\r\nif (mousedev->exist && !--mousedev->open)\r\ninput_close_device(&mousedev->handle);\r\nmutex_unlock(&mousedev->mutex);\r\n}\r\nstatic int mixdev_open_devices(struct mousedev *mixdev)\r\n{\r\nint error;\r\nerror = mutex_lock_interruptible(&mixdev->mutex);\r\nif (error)\r\nreturn error;\r\nif (!mixdev->open++) {\r\nstruct mousedev *mousedev;\r\nlist_for_each_entry(mousedev, &mousedev_mix_list, mixdev_node) {\r\nif (!mousedev->opened_by_mixdev) {\r\nif (mousedev_open_device(mousedev))\r\ncontinue;\r\nmousedev->opened_by_mixdev = true;\r\n}\r\n}\r\n}\r\nmutex_unlock(&mixdev->mutex);\r\nreturn 0;\r\n}\r\nstatic void mixdev_close_devices(struct mousedev *mixdev)\r\n{\r\nmutex_lock(&mixdev->mutex);\r\nif (!--mixdev->open) {\r\nstruct mousedev *mousedev;\r\nlist_for_each_entry(mousedev, &mousedev_mix_list, mixdev_node) {\r\nif (mousedev->opened_by_mixdev) {\r\nmousedev->opened_by_mixdev = false;\r\nmousedev_close_device(mousedev);\r\n}\r\n}\r\n}\r\nmutex_unlock(&mixdev->mutex);\r\n}\r\nstatic void mousedev_attach_client(struct mousedev *mousedev,\r\nstruct mousedev_client *client)\r\n{\r\nspin_lock(&mousedev->client_lock);\r\nlist_add_tail_rcu(&client->node, &mousedev->client_list);\r\nspin_unlock(&mousedev->client_lock);\r\n}\r\nstatic void mousedev_detach_client(struct mousedev *mousedev,\r\nstruct mousedev_client *client)\r\n{\r\nspin_lock(&mousedev->client_lock);\r\nlist_del_rcu(&client->node);\r\nspin_unlock(&mousedev->client_lock);\r\nsynchronize_rcu();\r\n}\r\nstatic int mousedev_release(struct inode *inode, struct file *file)\r\n{\r\nstruct mousedev_client *client = file->private_data;\r\nstruct mousedev *mousedev = client->mousedev;\r\nmousedev_detach_client(mousedev, client);\r\nkfree(client);\r\nmousedev->close_device(mousedev);\r\nreturn 0;\r\n}\r\nstatic int mousedev_open(struct inode *inode, struct file *file)\r\n{\r\nstruct mousedev_client *client;\r\nstruct mousedev *mousedev;\r\nint error;\r\n#ifdef CONFIG_INPUT_MOUSEDEV_PSAUX\r\nif (imajor(inode) == MISC_MAJOR)\r\nmousedev = mousedev_mix;\r\nelse\r\n#endif\r\nmousedev = container_of(inode->i_cdev, struct mousedev, cdev);\r\nclient = kzalloc(sizeof(struct mousedev_client), GFP_KERNEL);\r\nif (!client)\r\nreturn -ENOMEM;\r\nspin_lock_init(&client->packet_lock);\r\nclient->pos_x = xres / 2;\r\nclient->pos_y = yres / 2;\r\nclient->mousedev = mousedev;\r\nmousedev_attach_client(mousedev, client);\r\nerror = mousedev->open_device(mousedev);\r\nif (error)\r\ngoto err_free_client;\r\nfile->private_data = client;\r\nnonseekable_open(inode, file);\r\nreturn 0;\r\nerr_free_client:\r\nmousedev_detach_client(mousedev, client);\r\nkfree(client);\r\nreturn error;\r\n}\r\nstatic inline int mousedev_limit_delta(int delta, int limit)\r\n{\r\nreturn delta > limit ? limit : (delta < -limit ? -limit : delta);\r\n}\r\nstatic void mousedev_packet(struct mousedev_client *client,\r\nsigned char *ps2_data)\r\n{\r\nstruct mousedev_motion *p = &client->packets[client->tail];\r\nps2_data[0] = 0x08 |\r\n((p->dx < 0) << 4) | ((p->dy < 0) << 5) | (p->buttons & 0x07);\r\nps2_data[1] = mousedev_limit_delta(p->dx, 127);\r\nps2_data[2] = mousedev_limit_delta(p->dy, 127);\r\np->dx -= ps2_data[1];\r\np->dy -= ps2_data[2];\r\nswitch (client->mode) {\r\ncase MOUSEDEV_EMUL_EXPS:\r\nps2_data[3] = mousedev_limit_delta(p->dz, 7);\r\np->dz -= ps2_data[3];\r\nps2_data[3] = (ps2_data[3] & 0x0f) | ((p->buttons & 0x18) << 1);\r\nclient->bufsiz = 4;\r\nbreak;\r\ncase MOUSEDEV_EMUL_IMPS:\r\nps2_data[0] |=\r\n((p->buttons & 0x10) >> 3) | ((p->buttons & 0x08) >> 1);\r\nps2_data[3] = mousedev_limit_delta(p->dz, 127);\r\np->dz -= ps2_data[3];\r\nclient->bufsiz = 4;\r\nbreak;\r\ncase MOUSEDEV_EMUL_PS2:\r\ndefault:\r\nps2_data[0] |=\r\n((p->buttons & 0x10) >> 3) | ((p->buttons & 0x08) >> 1);\r\np->dz = 0;\r\nclient->bufsiz = 3;\r\nbreak;\r\n}\r\nif (!p->dx && !p->dy && !p->dz) {\r\nif (client->tail == client->head) {\r\nclient->ready = 0;\r\nclient->last_buttons = p->buttons;\r\n} else\r\nclient->tail = (client->tail + 1) % PACKET_QUEUE_LEN;\r\n}\r\n}\r\nstatic void mousedev_generate_response(struct mousedev_client *client,\r\nint command)\r\n{\r\nclient->ps2[0] = 0xfa;\r\nswitch (command) {\r\ncase 0xeb:\r\nmousedev_packet(client, &client->ps2[1]);\r\nclient->bufsiz++;\r\nbreak;\r\ncase 0xf2:\r\nswitch (client->mode) {\r\ncase MOUSEDEV_EMUL_PS2:\r\nclient->ps2[1] = 0;\r\nbreak;\r\ncase MOUSEDEV_EMUL_IMPS:\r\nclient->ps2[1] = 3;\r\nbreak;\r\ncase MOUSEDEV_EMUL_EXPS:\r\nclient->ps2[1] = 4;\r\nbreak;\r\n}\r\nclient->bufsiz = 2;\r\nbreak;\r\ncase 0xe9:\r\nclient->ps2[1] = 0x60; client->ps2[2] = 3; client->ps2[3] = 200;\r\nclient->bufsiz = 4;\r\nbreak;\r\ncase 0xff:\r\nclient->impsseq = client->imexseq = 0;\r\nclient->mode = MOUSEDEV_EMUL_PS2;\r\nclient->ps2[1] = 0xaa; client->ps2[2] = 0x00;\r\nclient->bufsiz = 3;\r\nbreak;\r\ndefault:\r\nclient->bufsiz = 1;\r\nbreak;\r\n}\r\nclient->buffer = client->bufsiz;\r\n}\r\nstatic ssize_t mousedev_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct mousedev_client *client = file->private_data;\r\nunsigned char c;\r\nunsigned int i;\r\nfor (i = 0; i < count; i++) {\r\nif (get_user(c, buffer + i))\r\nreturn -EFAULT;\r\nspin_lock_irq(&client->packet_lock);\r\nif (c == mousedev_imex_seq[client->imexseq]) {\r\nif (++client->imexseq == MOUSEDEV_SEQ_LEN) {\r\nclient->imexseq = 0;\r\nclient->mode = MOUSEDEV_EMUL_EXPS;\r\n}\r\n} else\r\nclient->imexseq = 0;\r\nif (c == mousedev_imps_seq[client->impsseq]) {\r\nif (++client->impsseq == MOUSEDEV_SEQ_LEN) {\r\nclient->impsseq = 0;\r\nclient->mode = MOUSEDEV_EMUL_IMPS;\r\n}\r\n} else\r\nclient->impsseq = 0;\r\nmousedev_generate_response(client, c);\r\nspin_unlock_irq(&client->packet_lock);\r\n}\r\nkill_fasync(&client->fasync, SIGIO, POLL_IN);\r\nwake_up_interruptible(&client->mousedev->wait);\r\nreturn count;\r\n}\r\nstatic ssize_t mousedev_read(struct file *file, char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct mousedev_client *client = file->private_data;\r\nstruct mousedev *mousedev = client->mousedev;\r\nsigned char data[sizeof(client->ps2)];\r\nint retval = 0;\r\nif (!client->ready && !client->buffer && mousedev->exist &&\r\n(file->f_flags & O_NONBLOCK))\r\nreturn -EAGAIN;\r\nretval = wait_event_interruptible(mousedev->wait,\r\n!mousedev->exist || client->ready || client->buffer);\r\nif (retval)\r\nreturn retval;\r\nif (!mousedev->exist)\r\nreturn -ENODEV;\r\nspin_lock_irq(&client->packet_lock);\r\nif (!client->buffer && client->ready) {\r\nmousedev_packet(client, client->ps2);\r\nclient->buffer = client->bufsiz;\r\n}\r\nif (count > client->buffer)\r\ncount = client->buffer;\r\nmemcpy(data, client->ps2 + client->bufsiz - client->buffer, count);\r\nclient->buffer -= count;\r\nspin_unlock_irq(&client->packet_lock);\r\nif (copy_to_user(buffer, data, count))\r\nreturn -EFAULT;\r\nreturn count;\r\n}\r\nstatic unsigned int mousedev_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct mousedev_client *client = file->private_data;\r\nstruct mousedev *mousedev = client->mousedev;\r\nunsigned int mask;\r\npoll_wait(file, &mousedev->wait, wait);\r\nmask = mousedev->exist ? POLLOUT | POLLWRNORM : POLLHUP | POLLERR;\r\nif (client->ready || client->buffer)\r\nmask |= POLLIN | POLLRDNORM;\r\nreturn mask;\r\n}\r\nstatic void mousedev_mark_dead(struct mousedev *mousedev)\r\n{\r\nmutex_lock(&mousedev->mutex);\r\nmousedev->exist = false;\r\nmutex_unlock(&mousedev->mutex);\r\n}\r\nstatic void mousedev_hangup(struct mousedev *mousedev)\r\n{\r\nstruct mousedev_client *client;\r\nspin_lock(&mousedev->client_lock);\r\nlist_for_each_entry(client, &mousedev->client_list, node)\r\nkill_fasync(&client->fasync, SIGIO, POLL_HUP);\r\nspin_unlock(&mousedev->client_lock);\r\nwake_up_interruptible(&mousedev->wait);\r\n}\r\nstatic void mousedev_cleanup(struct mousedev *mousedev)\r\n{\r\nstruct input_handle *handle = &mousedev->handle;\r\nmousedev_mark_dead(mousedev);\r\nmousedev_hangup(mousedev);\r\ncdev_del(&mousedev->cdev);\r\nif (mousedev->open)\r\ninput_close_device(handle);\r\n}\r\nstatic int mousedev_reserve_minor(bool mixdev)\r\n{\r\nint minor;\r\nif (mixdev) {\r\nminor = input_get_new_minor(MOUSEDEV_MIX, 1, false);\r\nif (minor < 0)\r\npr_err("failed to reserve mixdev minor: %d\n", minor);\r\n} else {\r\nminor = input_get_new_minor(MOUSEDEV_MINOR_BASE,\r\nMOUSEDEV_MINORS, true);\r\nif (minor < 0)\r\npr_err("failed to reserve new minor: %d\n", minor);\r\n}\r\nreturn minor;\r\n}\r\nstatic struct mousedev *mousedev_create(struct input_dev *dev,\r\nstruct input_handler *handler,\r\nbool mixdev)\r\n{\r\nstruct mousedev *mousedev;\r\nint minor;\r\nint error;\r\nminor = mousedev_reserve_minor(mixdev);\r\nif (minor < 0) {\r\nerror = minor;\r\ngoto err_out;\r\n}\r\nmousedev = kzalloc(sizeof(struct mousedev), GFP_KERNEL);\r\nif (!mousedev) {\r\nerror = -ENOMEM;\r\ngoto err_free_minor;\r\n}\r\nINIT_LIST_HEAD(&mousedev->client_list);\r\nINIT_LIST_HEAD(&mousedev->mixdev_node);\r\nspin_lock_init(&mousedev->client_lock);\r\nmutex_init(&mousedev->mutex);\r\nlockdep_set_subclass(&mousedev->mutex,\r\nmixdev ? SINGLE_DEPTH_NESTING : 0);\r\ninit_waitqueue_head(&mousedev->wait);\r\nif (mixdev) {\r\ndev_set_name(&mousedev->dev, "mice");\r\nmousedev->open_device = mixdev_open_devices;\r\nmousedev->close_device = mixdev_close_devices;\r\n} else {\r\nint dev_no = minor;\r\nif (dev_no < MOUSEDEV_MINOR_BASE + MOUSEDEV_MINORS)\r\ndev_no -= MOUSEDEV_MINOR_BASE;\r\ndev_set_name(&mousedev->dev, "mouse%d", dev_no);\r\nmousedev->open_device = mousedev_open_device;\r\nmousedev->close_device = mousedev_close_device;\r\n}\r\nmousedev->exist = true;\r\nmousedev->handle.dev = input_get_device(dev);\r\nmousedev->handle.name = dev_name(&mousedev->dev);\r\nmousedev->handle.handler = handler;\r\nmousedev->handle.private = mousedev;\r\nmousedev->dev.class = &input_class;\r\nif (dev)\r\nmousedev->dev.parent = &dev->dev;\r\nmousedev->dev.devt = MKDEV(INPUT_MAJOR, minor);\r\nmousedev->dev.release = mousedev_free;\r\ndevice_initialize(&mousedev->dev);\r\nif (!mixdev) {\r\nerror = input_register_handle(&mousedev->handle);\r\nif (error)\r\ngoto err_free_mousedev;\r\n}\r\ncdev_init(&mousedev->cdev, &mousedev_fops);\r\nmousedev->cdev.kobj.parent = &mousedev->dev.kobj;\r\nerror = cdev_add(&mousedev->cdev, mousedev->dev.devt, 1);\r\nif (error)\r\ngoto err_unregister_handle;\r\nerror = device_add(&mousedev->dev);\r\nif (error)\r\ngoto err_cleanup_mousedev;\r\nreturn mousedev;\r\nerr_cleanup_mousedev:\r\nmousedev_cleanup(mousedev);\r\nerr_unregister_handle:\r\nif (!mixdev)\r\ninput_unregister_handle(&mousedev->handle);\r\nerr_free_mousedev:\r\nput_device(&mousedev->dev);\r\nerr_free_minor:\r\ninput_free_minor(minor);\r\nerr_out:\r\nreturn ERR_PTR(error);\r\n}\r\nstatic void mousedev_destroy(struct mousedev *mousedev)\r\n{\r\ndevice_del(&mousedev->dev);\r\nmousedev_cleanup(mousedev);\r\ninput_free_minor(MINOR(mousedev->dev.devt));\r\nif (mousedev != mousedev_mix)\r\ninput_unregister_handle(&mousedev->handle);\r\nput_device(&mousedev->dev);\r\n}\r\nstatic int mixdev_add_device(struct mousedev *mousedev)\r\n{\r\nint retval;\r\nretval = mutex_lock_interruptible(&mousedev_mix->mutex);\r\nif (retval)\r\nreturn retval;\r\nif (mousedev_mix->open) {\r\nretval = mousedev_open_device(mousedev);\r\nif (retval)\r\ngoto out;\r\nmousedev->opened_by_mixdev = true;\r\n}\r\nget_device(&mousedev->dev);\r\nlist_add_tail(&mousedev->mixdev_node, &mousedev_mix_list);\r\nout:\r\nmutex_unlock(&mousedev_mix->mutex);\r\nreturn retval;\r\n}\r\nstatic void mixdev_remove_device(struct mousedev *mousedev)\r\n{\r\nmutex_lock(&mousedev_mix->mutex);\r\nif (mousedev->opened_by_mixdev) {\r\nmousedev->opened_by_mixdev = false;\r\nmousedev_close_device(mousedev);\r\n}\r\nlist_del_init(&mousedev->mixdev_node);\r\nmutex_unlock(&mousedev_mix->mutex);\r\nput_device(&mousedev->dev);\r\n}\r\nstatic int mousedev_connect(struct input_handler *handler,\r\nstruct input_dev *dev,\r\nconst struct input_device_id *id)\r\n{\r\nstruct mousedev *mousedev;\r\nint error;\r\nmousedev = mousedev_create(dev, handler, false);\r\nif (IS_ERR(mousedev))\r\nreturn PTR_ERR(mousedev);\r\nerror = mixdev_add_device(mousedev);\r\nif (error) {\r\nmousedev_destroy(mousedev);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mousedev_disconnect(struct input_handle *handle)\r\n{\r\nstruct mousedev *mousedev = handle->private;\r\nmixdev_remove_device(mousedev);\r\nmousedev_destroy(mousedev);\r\n}\r\nstatic void __init mousedev_psaux_register(void)\r\n{\r\nint error;\r\nerror = misc_register(&psaux_mouse);\r\nif (error)\r\npr_warn("could not register psaux device, error: %d\n",\r\nerror);\r\nelse\r\npsaux_registered = true;\r\n}\r\nstatic void __exit mousedev_psaux_unregister(void)\r\n{\r\nif (psaux_registered)\r\nmisc_deregister(&psaux_mouse);\r\n}\r\nstatic inline void mousedev_psaux_register(void) { }\r\nstatic inline void mousedev_psaux_unregister(void) { }\r\nstatic int __init mousedev_init(void)\r\n{\r\nint error;\r\nmousedev_mix = mousedev_create(NULL, &mousedev_handler, true);\r\nif (IS_ERR(mousedev_mix))\r\nreturn PTR_ERR(mousedev_mix);\r\nerror = input_register_handler(&mousedev_handler);\r\nif (error) {\r\nmousedev_destroy(mousedev_mix);\r\nreturn error;\r\n}\r\nmousedev_psaux_register();\r\npr_info("PS/2 mouse device common for all mice\n");\r\nreturn 0;\r\n}\r\nstatic void __exit mousedev_exit(void)\r\n{\r\nmousedev_psaux_unregister();\r\ninput_unregister_handler(&mousedev_handler);\r\nmousedev_destroy(mousedev_mix);\r\n}
