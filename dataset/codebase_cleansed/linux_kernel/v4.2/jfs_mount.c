int jfs_mount(struct super_block *sb)\r\n{\r\nint rc = 0;\r\nstruct jfs_sb_info *sbi = JFS_SBI(sb);\r\nstruct inode *ipaimap = NULL;\r\nstruct inode *ipaimap2 = NULL;\r\nstruct inode *ipimap = NULL;\r\nstruct inode *ipbmap = NULL;\r\nif ((rc = chkSuper(sb))) {\r\ngoto errout20;\r\n}\r\nipaimap = diReadSpecial(sb, AGGREGATE_I, 0);\r\nif (ipaimap == NULL) {\r\njfs_err("jfs_mount: Failed to read AGGREGATE_I");\r\nrc = -EIO;\r\ngoto errout20;\r\n}\r\nsbi->ipaimap = ipaimap;\r\njfs_info("jfs_mount: ipaimap:0x%p", ipaimap);\r\nif ((rc = diMount(ipaimap))) {\r\njfs_err("jfs_mount: diMount(ipaimap) failed w/rc = %d", rc);\r\ngoto errout21;\r\n}\r\nipbmap = diReadSpecial(sb, BMAP_I, 0);\r\nif (ipbmap == NULL) {\r\nrc = -EIO;\r\ngoto errout22;\r\n}\r\njfs_info("jfs_mount: ipbmap:0x%p", ipbmap);\r\nsbi->ipbmap = ipbmap;\r\nif ((rc = dbMount(ipbmap))) {\r\njfs_err("jfs_mount: dbMount failed w/rc = %d", rc);\r\ngoto errout22;\r\n}\r\nif ((sbi->mntflag & JFS_BAD_SAIT) == 0) {\r\nipaimap2 = diReadSpecial(sb, AGGREGATE_I, 1);\r\nif (!ipaimap2) {\r\njfs_err("jfs_mount: Failed to read AGGREGATE_I");\r\nrc = -EIO;\r\ngoto errout35;\r\n}\r\nsbi->ipaimap2 = ipaimap2;\r\njfs_info("jfs_mount: ipaimap2:0x%p", ipaimap2);\r\nif ((rc = diMount(ipaimap2))) {\r\njfs_err("jfs_mount: diMount(ipaimap2) failed, rc = %d",\r\nrc);\r\ngoto errout35;\r\n}\r\n} else\r\nsbi->ipaimap2 = NULL;\r\nipimap = diReadSpecial(sb, FILESYSTEM_I, 0);\r\nif (ipimap == NULL) {\r\njfs_err("jfs_mount: Failed to read FILESYSTEM_I");\r\nrc = -EIO;\r\ngoto errout40;\r\n}\r\njfs_info("jfs_mount: ipimap:0x%p", ipimap);\r\nsbi->ipimap = ipimap;\r\nif ((rc = diMount(ipimap))) {\r\njfs_err("jfs_mount: diMount failed w/rc = %d", rc);\r\ngoto errout41;\r\n}\r\ngoto out;\r\nerrout41:\r\ndiFreeSpecial(ipimap);\r\nerrout40:\r\nif (ipaimap2) {\r\ndiUnmount(ipaimap2, 1);\r\ndiFreeSpecial(ipaimap2);\r\n}\r\nerrout35:\r\ndbUnmount(ipbmap, 1);\r\ndiFreeSpecial(ipbmap);\r\nerrout22:\r\ndiUnmount(ipaimap, 1);\r\nerrout21:\r\ndiFreeSpecial(ipaimap);\r\nerrout20:\r\nout:\r\nif (rc)\r\njfs_err("Mount JFS Failure: %d", rc);\r\nreturn rc;\r\n}\r\nint jfs_mount_rw(struct super_block *sb, int remount)\r\n{\r\nstruct jfs_sb_info *sbi = JFS_SBI(sb);\r\nint rc;\r\nif (remount) {\r\nif (chkSuper(sb) || (sbi->state != FM_CLEAN))\r\nreturn -EINVAL;\r\ntruncate_inode_pages(sbi->ipimap->i_mapping, 0);\r\ntruncate_inode_pages(sbi->ipbmap->i_mapping, 0);\r\ndiUnmount(sbi->ipimap, 1);\r\nif ((rc = diMount(sbi->ipimap))) {\r\njfs_err("jfs_mount_rw: diMount failed!");\r\nreturn rc;\r\n}\r\ndbUnmount(sbi->ipbmap, 1);\r\nif ((rc = dbMount(sbi->ipbmap))) {\r\njfs_err("jfs_mount_rw: dbMount failed!");\r\nreturn rc;\r\n}\r\n}\r\nif ((rc = lmLogOpen(sb)))\r\nreturn rc;\r\nif ((rc = updateSuper(sb, FM_MOUNT))) {\r\njfs_err("jfs_mount: updateSuper failed w/rc = %d", rc);\r\nlmLogClose(sb);\r\nreturn rc;\r\n}\r\nlogMOUNT(sb);\r\nreturn rc;\r\n}\r\nstatic int chkSuper(struct super_block *sb)\r\n{\r\nint rc = 0;\r\nstruct jfs_sb_info *sbi = JFS_SBI(sb);\r\nstruct jfs_superblock *j_sb;\r\nstruct buffer_head *bh;\r\nint AIM_bytesize, AIT_bytesize;\r\nint expected_AIM_bytesize, expected_AIT_bytesize;\r\ns64 AIM_byte_addr, AIT_byte_addr, fsckwsp_addr;\r\ns64 byte_addr_diff0, byte_addr_diff1;\r\ns32 bsize;\r\nif ((rc = readSuper(sb, &bh)))\r\nreturn rc;\r\nj_sb = (struct jfs_superblock *)bh->b_data;\r\nif (strncmp(j_sb->s_magic, JFS_MAGIC, 4) ||\r\nle32_to_cpu(j_sb->s_version) > JFS_VERSION) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nbsize = le32_to_cpu(j_sb->s_bsize);\r\n#ifdef _JFS_4K\r\nif (bsize != PSIZE) {\r\njfs_err("Currently only 4K block size supported!");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\n#endif\r\njfs_info("superblock: flag:0x%08x state:0x%08x size:0x%Lx",\r\nle32_to_cpu(j_sb->s_flag), le32_to_cpu(j_sb->s_state),\r\n(unsigned long long) le64_to_cpu(j_sb->s_size));\r\nif ((j_sb->s_flag & cpu_to_le32(JFS_BAD_SAIT)) !=\r\ncpu_to_le32(JFS_BAD_SAIT)) {\r\nexpected_AIM_bytesize = 2 * PSIZE;\r\nAIM_bytesize = lengthPXD(&(j_sb->s_aim2)) * bsize;\r\nexpected_AIT_bytesize = 4 * PSIZE;\r\nAIT_bytesize = lengthPXD(&(j_sb->s_ait2)) * bsize;\r\nAIM_byte_addr = addressPXD(&(j_sb->s_aim2)) * bsize;\r\nAIT_byte_addr = addressPXD(&(j_sb->s_ait2)) * bsize;\r\nbyte_addr_diff0 = AIT_byte_addr - AIM_byte_addr;\r\nfsckwsp_addr = addressPXD(&(j_sb->s_fsckpxd)) * bsize;\r\nbyte_addr_diff1 = fsckwsp_addr - AIT_byte_addr;\r\nif ((AIM_bytesize != expected_AIM_bytesize) ||\r\n(AIT_bytesize != expected_AIT_bytesize) ||\r\n(byte_addr_diff0 != AIM_bytesize) ||\r\n(byte_addr_diff1 <= AIT_bytesize))\r\nj_sb->s_flag |= cpu_to_le32(JFS_BAD_SAIT);\r\n}\r\nif ((j_sb->s_flag & cpu_to_le32(JFS_GROUPCOMMIT)) !=\r\ncpu_to_le32(JFS_GROUPCOMMIT))\r\nj_sb->s_flag |= cpu_to_le32(JFS_GROUPCOMMIT);\r\nif (j_sb->s_state != cpu_to_le32(FM_CLEAN) &&\r\n!(sb->s_flags & MS_RDONLY)) {\r\njfs_err("jfs_mount: Mount Failure: File System Dirty.");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nsbi->state = le32_to_cpu(j_sb->s_state);\r\nsbi->mntflag = le32_to_cpu(j_sb->s_flag);\r\nsbi->bsize = bsize;\r\nsbi->l2bsize = le16_to_cpu(j_sb->s_l2bsize);\r\nsbi->nbperpage = PSIZE >> sbi->l2bsize;\r\nsbi->l2nbperpage = L2PSIZE - sbi->l2bsize;\r\nsbi->l2niperblk = sbi->l2bsize - L2DISIZE;\r\nif (sbi->mntflag & JFS_INLINELOG)\r\nsbi->logpxd = j_sb->s_logpxd;\r\nelse {\r\nsbi->logdev = new_decode_dev(le32_to_cpu(j_sb->s_logdev));\r\nmemcpy(sbi->uuid, j_sb->s_uuid, sizeof(sbi->uuid));\r\nmemcpy(sbi->loguuid, j_sb->s_loguuid, sizeof(sbi->uuid));\r\n}\r\nsbi->fsckpxd = j_sb->s_fsckpxd;\r\nsbi->ait2 = j_sb->s_ait2;\r\nout:\r\nbrelse(bh);\r\nreturn rc;\r\n}\r\nint updateSuper(struct super_block *sb, uint state)\r\n{\r\nstruct jfs_superblock *j_sb;\r\nstruct jfs_sb_info *sbi = JFS_SBI(sb);\r\nstruct buffer_head *bh;\r\nint rc;\r\nif (sbi->flag & JFS_NOINTEGRITY) {\r\nif (state == FM_DIRTY) {\r\nsbi->p_state = state;\r\nreturn 0;\r\n} else if (state == FM_MOUNT) {\r\nsbi->p_state = sbi->state;\r\nstate = FM_DIRTY;\r\n} else if (state == FM_CLEAN) {\r\nstate = sbi->p_state;\r\n} else\r\njfs_err("updateSuper: bad state");\r\n} else if (sbi->state == FM_DIRTY)\r\nreturn 0;\r\nif ((rc = readSuper(sb, &bh)))\r\nreturn rc;\r\nj_sb = (struct jfs_superblock *)bh->b_data;\r\nj_sb->s_state = cpu_to_le32(state);\r\nsbi->state = state;\r\nif (state == FM_MOUNT) {\r\nj_sb->s_logdev = cpu_to_le32(new_encode_dev(sbi->log->bdev->bd_dev));\r\nj_sb->s_logserial = cpu_to_le32(sbi->log->serial);\r\n} else if (state == FM_CLEAN) {\r\nif (j_sb->s_flag & cpu_to_le32(JFS_DASD_ENABLED))\r\nj_sb->s_flag |= cpu_to_le32(JFS_DASD_PRIME);\r\n}\r\nmark_buffer_dirty(bh);\r\nsync_dirty_buffer(bh);\r\nbrelse(bh);\r\nreturn 0;\r\n}\r\nint readSuper(struct super_block *sb, struct buffer_head **bpp)\r\n{\r\n*bpp = sb_bread(sb, SUPER1_OFF >> sb->s_blocksize_bits);\r\nif (*bpp)\r\nreturn 0;\r\n*bpp = sb_bread(sb, SUPER2_OFF >> sb->s_blocksize_bits);\r\nif (*bpp)\r\nreturn 0;\r\nreturn -EIO;\r\n}\r\nstatic int logMOUNT(struct super_block *sb)\r\n{\r\nstruct jfs_log *log = JFS_SBI(sb)->log;\r\nstruct lrd lrd;\r\nlrd.logtid = 0;\r\nlrd.backchain = 0;\r\nlrd.type = cpu_to_le16(LOG_MOUNT);\r\nlrd.length = 0;\r\nlrd.aggregate = cpu_to_le32(new_encode_dev(sb->s_bdev->bd_dev));\r\nlmLog(log, NULL, &lrd, NULL);\r\nreturn 0;\r\n}
