static struct sock *icmp_sk(struct net *net)\r\n{\r\nreturn *this_cpu_ptr(net->ipv4.icmp_sk);\r\n}\r\nstatic inline struct sock *icmp_xmit_lock(struct net *net)\r\n{\r\nstruct sock *sk;\r\nlocal_bh_disable();\r\nsk = icmp_sk(net);\r\nif (unlikely(!spin_trylock(&sk->sk_lock.slock))) {\r\nlocal_bh_enable();\r\nreturn NULL;\r\n}\r\nreturn sk;\r\n}\r\nstatic inline void icmp_xmit_unlock(struct sock *sk)\r\n{\r\nspin_unlock_bh(&sk->sk_lock.slock);\r\n}\r\nbool icmp_global_allow(void)\r\n{\r\nu32 credit, delta, incr = 0, now = (u32)jiffies;\r\nbool rc = false;\r\nif (!icmp_global.credit) {\r\ndelta = min_t(u32, now - icmp_global.stamp, HZ);\r\nif (delta < HZ / 50)\r\nreturn false;\r\n}\r\nspin_lock(&icmp_global.lock);\r\ndelta = min_t(u32, now - icmp_global.stamp, HZ);\r\nif (delta >= HZ / 50) {\r\nincr = sysctl_icmp_msgs_per_sec * delta / HZ ;\r\nif (incr)\r\nicmp_global.stamp = now;\r\n}\r\ncredit = min_t(u32, icmp_global.credit + incr, sysctl_icmp_msgs_burst);\r\nif (credit) {\r\ncredit--;\r\nrc = true;\r\n}\r\nicmp_global.credit = credit;\r\nspin_unlock(&icmp_global.lock);\r\nreturn rc;\r\n}\r\nstatic bool icmpv4_xrlim_allow(struct net *net, struct rtable *rt,\r\nstruct flowi4 *fl4, int type, int code)\r\n{\r\nstruct dst_entry *dst = &rt->dst;\r\nbool rc = true;\r\nif (type > NR_ICMP_TYPES)\r\ngoto out;\r\nif (type == ICMP_DEST_UNREACH && code == ICMP_FRAG_NEEDED)\r\ngoto out;\r\nif (dst->dev && (dst->dev->flags&IFF_LOOPBACK))\r\ngoto out;\r\nif (!((1 << type) & net->ipv4.sysctl_icmp_ratemask))\r\ngoto out;\r\nrc = false;\r\nif (icmp_global_allow()) {\r\nstruct inet_peer *peer;\r\npeer = inet_getpeer_v4(net->ipv4.peers, fl4->daddr, 1);\r\nrc = inet_peer_xrlim_allow(peer,\r\nnet->ipv4.sysctl_icmp_ratelimit);\r\nif (peer)\r\ninet_putpeer(peer);\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nvoid icmp_out_count(struct net *net, unsigned char type)\r\n{\r\nICMPMSGOUT_INC_STATS(net, type);\r\nICMP_INC_STATS(net, ICMP_MIB_OUTMSGS);\r\n}\r\nstatic int icmp_glue_bits(void *from, char *to, int offset, int len, int odd,\r\nstruct sk_buff *skb)\r\n{\r\nstruct icmp_bxm *icmp_param = (struct icmp_bxm *)from;\r\n__wsum csum;\r\ncsum = skb_copy_and_csum_bits(icmp_param->skb,\r\nicmp_param->offset + offset,\r\nto, len, 0);\r\nskb->csum = csum_block_add(skb->csum, csum, odd);\r\nif (icmp_pointers[icmp_param->data.icmph.type].error)\r\nnf_ct_attach(skb, icmp_param->skb);\r\nreturn 0;\r\n}\r\nstatic void icmp_push_reply(struct icmp_bxm *icmp_param,\r\nstruct flowi4 *fl4,\r\nstruct ipcm_cookie *ipc, struct rtable **rt)\r\n{\r\nstruct sock *sk;\r\nstruct sk_buff *skb;\r\nsk = icmp_sk(dev_net((*rt)->dst.dev));\r\nif (ip_append_data(sk, fl4, icmp_glue_bits, icmp_param,\r\nicmp_param->data_len+icmp_param->head_len,\r\nicmp_param->head_len,\r\nipc, rt, MSG_DONTWAIT) < 0) {\r\nICMP_INC_STATS_BH(sock_net(sk), ICMP_MIB_OUTERRORS);\r\nip_flush_pending_frames(sk);\r\n} else if ((skb = skb_peek(&sk->sk_write_queue)) != NULL) {\r\nstruct icmphdr *icmph = icmp_hdr(skb);\r\n__wsum csum = 0;\r\nstruct sk_buff *skb1;\r\nskb_queue_walk(&sk->sk_write_queue, skb1) {\r\ncsum = csum_add(csum, skb1->csum);\r\n}\r\ncsum = csum_partial_copy_nocheck((void *)&icmp_param->data,\r\n(char *)icmph,\r\nicmp_param->head_len, csum);\r\nicmph->checksum = csum_fold(csum);\r\nskb->ip_summed = CHECKSUM_NONE;\r\nip_push_pending_frames(sk, fl4);\r\n}\r\n}\r\nstatic void icmp_reply(struct icmp_bxm *icmp_param, struct sk_buff *skb)\r\n{\r\nstruct ipcm_cookie ipc;\r\nstruct rtable *rt = skb_rtable(skb);\r\nstruct net *net = dev_net(rt->dst.dev);\r\nstruct flowi4 fl4;\r\nstruct sock *sk;\r\nstruct inet_sock *inet;\r\n__be32 daddr, saddr;\r\nu32 mark = IP4_REPLY_MARK(net, skb->mark);\r\nif (ip_options_echo(&icmp_param->replyopts.opt.opt, skb))\r\nreturn;\r\nsk = icmp_xmit_lock(net);\r\nif (!sk)\r\nreturn;\r\ninet = inet_sk(sk);\r\nicmp_param->data.icmph.checksum = 0;\r\ninet->tos = ip_hdr(skb)->tos;\r\nsk->sk_mark = mark;\r\ndaddr = ipc.addr = ip_hdr(skb)->saddr;\r\nsaddr = fib_compute_spec_dst(skb);\r\nipc.opt = NULL;\r\nipc.tx_flags = 0;\r\nipc.ttl = 0;\r\nipc.tos = -1;\r\nif (icmp_param->replyopts.opt.opt.optlen) {\r\nipc.opt = &icmp_param->replyopts.opt;\r\nif (ipc.opt->opt.srr)\r\ndaddr = icmp_param->replyopts.opt.opt.faddr;\r\n}\r\nmemset(&fl4, 0, sizeof(fl4));\r\nfl4.daddr = daddr;\r\nfl4.saddr = saddr;\r\nfl4.flowi4_mark = mark;\r\nfl4.flowi4_tos = RT_TOS(ip_hdr(skb)->tos);\r\nfl4.flowi4_proto = IPPROTO_ICMP;\r\nsecurity_skb_classify_flow(skb, flowi4_to_flowi(&fl4));\r\nrt = ip_route_output_key(net, &fl4);\r\nif (IS_ERR(rt))\r\ngoto out_unlock;\r\nif (icmpv4_xrlim_allow(net, rt, &fl4, icmp_param->data.icmph.type,\r\nicmp_param->data.icmph.code))\r\nicmp_push_reply(icmp_param, &fl4, &ipc, &rt);\r\nip_rt_put(rt);\r\nout_unlock:\r\nicmp_xmit_unlock(sk);\r\n}\r\nstatic struct rtable *icmp_route_lookup(struct net *net,\r\nstruct flowi4 *fl4,\r\nstruct sk_buff *skb_in,\r\nconst struct iphdr *iph,\r\n__be32 saddr, u8 tos, u32 mark,\r\nint type, int code,\r\nstruct icmp_bxm *param)\r\n{\r\nstruct rtable *rt, *rt2;\r\nstruct flowi4 fl4_dec;\r\nint err;\r\nmemset(fl4, 0, sizeof(*fl4));\r\nfl4->daddr = (param->replyopts.opt.opt.srr ?\r\nparam->replyopts.opt.opt.faddr : iph->saddr);\r\nfl4->saddr = saddr;\r\nfl4->flowi4_mark = mark;\r\nfl4->flowi4_tos = RT_TOS(tos);\r\nfl4->flowi4_proto = IPPROTO_ICMP;\r\nfl4->fl4_icmp_type = type;\r\nfl4->fl4_icmp_code = code;\r\nsecurity_skb_classify_flow(skb_in, flowi4_to_flowi(fl4));\r\nrt = __ip_route_output_key(net, fl4);\r\nif (IS_ERR(rt))\r\nreturn rt;\r\nrt2 = rt;\r\nrt = (struct rtable *) xfrm_lookup(net, &rt->dst,\r\nflowi4_to_flowi(fl4), NULL, 0);\r\nif (!IS_ERR(rt)) {\r\nif (rt != rt2)\r\nreturn rt;\r\n} else if (PTR_ERR(rt) == -EPERM) {\r\nrt = NULL;\r\n} else\r\nreturn rt;\r\nerr = xfrm_decode_session_reverse(skb_in, flowi4_to_flowi(&fl4_dec), AF_INET);\r\nif (err)\r\ngoto relookup_failed;\r\nif (inet_addr_type(net, fl4_dec.saddr) == RTN_LOCAL) {\r\nrt2 = __ip_route_output_key(net, &fl4_dec);\r\nif (IS_ERR(rt2))\r\nerr = PTR_ERR(rt2);\r\n} else {\r\nstruct flowi4 fl4_2 = {};\r\nunsigned long orefdst;\r\nfl4_2.daddr = fl4_dec.saddr;\r\nrt2 = ip_route_output_key(net, &fl4_2);\r\nif (IS_ERR(rt2)) {\r\nerr = PTR_ERR(rt2);\r\ngoto relookup_failed;\r\n}\r\norefdst = skb_in->_skb_refdst;\r\nerr = ip_route_input(skb_in, fl4_dec.daddr, fl4_dec.saddr,\r\nRT_TOS(tos), rt2->dst.dev);\r\ndst_release(&rt2->dst);\r\nrt2 = skb_rtable(skb_in);\r\nskb_in->_skb_refdst = orefdst;\r\n}\r\nif (err)\r\ngoto relookup_failed;\r\nrt2 = (struct rtable *) xfrm_lookup(net, &rt2->dst,\r\nflowi4_to_flowi(&fl4_dec), NULL,\r\nXFRM_LOOKUP_ICMP);\r\nif (!IS_ERR(rt2)) {\r\ndst_release(&rt->dst);\r\nmemcpy(fl4, &fl4_dec, sizeof(*fl4));\r\nrt = rt2;\r\n} else if (PTR_ERR(rt2) == -EPERM) {\r\nif (rt)\r\ndst_release(&rt->dst);\r\nreturn rt2;\r\n} else {\r\nerr = PTR_ERR(rt2);\r\ngoto relookup_failed;\r\n}\r\nreturn rt;\r\nrelookup_failed:\r\nif (rt)\r\nreturn rt;\r\nreturn ERR_PTR(err);\r\n}\r\nvoid icmp_send(struct sk_buff *skb_in, int type, int code, __be32 info)\r\n{\r\nstruct iphdr *iph;\r\nint room;\r\nstruct icmp_bxm *icmp_param;\r\nstruct rtable *rt = skb_rtable(skb_in);\r\nstruct ipcm_cookie ipc;\r\nstruct flowi4 fl4;\r\n__be32 saddr;\r\nu8 tos;\r\nu32 mark;\r\nstruct net *net;\r\nstruct sock *sk;\r\nif (!rt)\r\ngoto out;\r\nnet = dev_net(rt->dst.dev);\r\niph = ip_hdr(skb_in);\r\nif ((u8 *)iph < skb_in->head ||\r\n(skb_network_header(skb_in) + sizeof(*iph)) >\r\nskb_tail_pointer(skb_in))\r\ngoto out;\r\nif (skb_in->pkt_type != PACKET_HOST)\r\ngoto out;\r\nif (rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))\r\ngoto out;\r\nif (iph->frag_off & htons(IP_OFFSET))\r\ngoto out;\r\nif (icmp_pointers[type].error) {\r\nif (iph->protocol == IPPROTO_ICMP) {\r\nu8 _inner_type, *itp;\r\nitp = skb_header_pointer(skb_in,\r\nskb_network_header(skb_in) +\r\n(iph->ihl << 2) +\r\noffsetof(struct icmphdr,\r\ntype) -\r\nskb_in->data,\r\nsizeof(_inner_type),\r\n&_inner_type);\r\nif (!itp)\r\ngoto out;\r\nif (*itp > NR_ICMP_TYPES ||\r\nicmp_pointers[*itp].error)\r\ngoto out;\r\n}\r\n}\r\nicmp_param = kmalloc(sizeof(*icmp_param), GFP_ATOMIC);\r\nif (!icmp_param)\r\nreturn;\r\nsk = icmp_xmit_lock(net);\r\nif (!sk)\r\ngoto out_free;\r\nsaddr = iph->daddr;\r\nif (!(rt->rt_flags & RTCF_LOCAL)) {\r\nstruct net_device *dev = NULL;\r\nrcu_read_lock();\r\nif (rt_is_input_route(rt) &&\r\nnet->ipv4.sysctl_icmp_errors_use_inbound_ifaddr)\r\ndev = dev_get_by_index_rcu(net, inet_iif(skb_in));\r\nif (dev)\r\nsaddr = inet_select_addr(dev, 0, RT_SCOPE_LINK);\r\nelse\r\nsaddr = 0;\r\nrcu_read_unlock();\r\n}\r\ntos = icmp_pointers[type].error ? ((iph->tos & IPTOS_TOS_MASK) |\r\nIPTOS_PREC_INTERNETCONTROL) :\r\niph->tos;\r\nmark = IP4_REPLY_MARK(net, skb_in->mark);\r\nif (ip_options_echo(&icmp_param->replyopts.opt.opt, skb_in))\r\ngoto out_unlock;\r\nicmp_param->data.icmph.type = type;\r\nicmp_param->data.icmph.code = code;\r\nicmp_param->data.icmph.un.gateway = info;\r\nicmp_param->data.icmph.checksum = 0;\r\nicmp_param->skb = skb_in;\r\nicmp_param->offset = skb_network_offset(skb_in);\r\ninet_sk(sk)->tos = tos;\r\nsk->sk_mark = mark;\r\nipc.addr = iph->saddr;\r\nipc.opt = &icmp_param->replyopts.opt;\r\nipc.tx_flags = 0;\r\nipc.ttl = 0;\r\nipc.tos = -1;\r\nrt = icmp_route_lookup(net, &fl4, skb_in, iph, saddr, tos, mark,\r\ntype, code, icmp_param);\r\nif (IS_ERR(rt))\r\ngoto out_unlock;\r\nif (!icmpv4_xrlim_allow(net, rt, &fl4, type, code))\r\ngoto ende;\r\nroom = dst_mtu(&rt->dst);\r\nif (room > 576)\r\nroom = 576;\r\nroom -= sizeof(struct iphdr) + icmp_param->replyopts.opt.opt.optlen;\r\nroom -= sizeof(struct icmphdr);\r\nicmp_param->data_len = skb_in->len - icmp_param->offset;\r\nif (icmp_param->data_len > room)\r\nicmp_param->data_len = room;\r\nicmp_param->head_len = sizeof(struct icmphdr);\r\nicmp_push_reply(icmp_param, &fl4, &ipc, &rt);\r\nende:\r\nip_rt_put(rt);\r\nout_unlock:\r\nicmp_xmit_unlock(sk);\r\nout_free:\r\nkfree(icmp_param);\r\nout:;\r\n}\r\nstatic void icmp_socket_deliver(struct sk_buff *skb, u32 info)\r\n{\r\nconst struct iphdr *iph = (const struct iphdr *) skb->data;\r\nconst struct net_protocol *ipprot;\r\nint protocol = iph->protocol;\r\nif (!pskb_may_pull(skb, iph->ihl * 4 + 8)) {\r\nICMP_INC_STATS_BH(dev_net(skb->dev), ICMP_MIB_INERRORS);\r\nreturn;\r\n}\r\nraw_icmp_error(skb, protocol, info);\r\nipprot = rcu_dereference(inet_protos[protocol]);\r\nif (ipprot && ipprot->err_handler)\r\nipprot->err_handler(skb, info);\r\n}\r\nstatic bool icmp_tag_validation(int proto)\r\n{\r\nbool ok;\r\nrcu_read_lock();\r\nok = rcu_dereference(inet_protos[proto])->icmp_strict_tag_validation;\r\nrcu_read_unlock();\r\nreturn ok;\r\n}\r\nstatic bool icmp_unreach(struct sk_buff *skb)\r\n{\r\nconst struct iphdr *iph;\r\nstruct icmphdr *icmph;\r\nstruct net *net;\r\nu32 info = 0;\r\nnet = dev_net(skb_dst(skb)->dev);\r\nif (!pskb_may_pull(skb, sizeof(struct iphdr)))\r\ngoto out_err;\r\nicmph = icmp_hdr(skb);\r\niph = (const struct iphdr *)skb->data;\r\nif (iph->ihl < 5)\r\ngoto out_err;\r\nif (icmph->type == ICMP_DEST_UNREACH) {\r\nswitch (icmph->code & 15) {\r\ncase ICMP_NET_UNREACH:\r\ncase ICMP_HOST_UNREACH:\r\ncase ICMP_PROT_UNREACH:\r\ncase ICMP_PORT_UNREACH:\r\nbreak;\r\ncase ICMP_FRAG_NEEDED:\r\nswitch (net->ipv4.sysctl_ip_no_pmtu_disc) {\r\ndefault:\r\nnet_dbg_ratelimited("%pI4: fragmentation needed and DF set\n",\r\n&iph->daddr);\r\nbreak;\r\ncase 2:\r\ngoto out;\r\ncase 3:\r\nif (!icmp_tag_validation(iph->protocol))\r\ngoto out;\r\ncase 0:\r\ninfo = ntohs(icmph->un.frag.mtu);\r\n}\r\nbreak;\r\ncase ICMP_SR_FAILED:\r\nnet_dbg_ratelimited("%pI4: Source Route Failed\n",\r\n&iph->daddr);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (icmph->code > NR_ICMP_UNREACH)\r\ngoto out;\r\n} else if (icmph->type == ICMP_PARAMETERPROB)\r\ninfo = ntohl(icmph->un.gateway) >> 24;\r\nif (!net->ipv4.sysctl_icmp_ignore_bogus_error_responses &&\r\ninet_addr_type(net, iph->daddr) == RTN_BROADCAST) {\r\nnet_warn_ratelimited("%pI4 sent an invalid ICMP type %u, code %u error to a broadcast: %pI4 on %s\n",\r\n&ip_hdr(skb)->saddr,\r\nicmph->type, icmph->code,\r\n&iph->daddr, skb->dev->name);\r\ngoto out;\r\n}\r\nicmp_socket_deliver(skb, info);\r\nout:\r\nreturn true;\r\nout_err:\r\nICMP_INC_STATS_BH(net, ICMP_MIB_INERRORS);\r\nreturn false;\r\n}\r\nstatic bool icmp_redirect(struct sk_buff *skb)\r\n{\r\nif (skb->len < sizeof(struct iphdr)) {\r\nICMP_INC_STATS_BH(dev_net(skb->dev), ICMP_MIB_INERRORS);\r\nreturn false;\r\n}\r\nif (!pskb_may_pull(skb, sizeof(struct iphdr))) {\r\nreturn false;\r\n}\r\nicmp_socket_deliver(skb, icmp_hdr(skb)->un.gateway);\r\nreturn true;\r\n}\r\nstatic bool icmp_echo(struct sk_buff *skb)\r\n{\r\nstruct net *net;\r\nnet = dev_net(skb_dst(skb)->dev);\r\nif (!net->ipv4.sysctl_icmp_echo_ignore_all) {\r\nstruct icmp_bxm icmp_param;\r\nicmp_param.data.icmph = *icmp_hdr(skb);\r\nicmp_param.data.icmph.type = ICMP_ECHOREPLY;\r\nicmp_param.skb = skb;\r\nicmp_param.offset = 0;\r\nicmp_param.data_len = skb->len;\r\nicmp_param.head_len = sizeof(struct icmphdr);\r\nicmp_reply(&icmp_param, skb);\r\n}\r\nreturn true;\r\n}\r\nstatic bool icmp_timestamp(struct sk_buff *skb)\r\n{\r\nstruct timespec tv;\r\nstruct icmp_bxm icmp_param;\r\nif (skb->len < 4)\r\ngoto out_err;\r\ngetnstimeofday(&tv);\r\nicmp_param.data.times[1] = htonl((tv.tv_sec % 86400) * MSEC_PER_SEC +\r\ntv.tv_nsec / NSEC_PER_MSEC);\r\nicmp_param.data.times[2] = icmp_param.data.times[1];\r\nif (skb_copy_bits(skb, 0, &icmp_param.data.times[0], 4))\r\nBUG();\r\nicmp_param.data.icmph = *icmp_hdr(skb);\r\nicmp_param.data.icmph.type = ICMP_TIMESTAMPREPLY;\r\nicmp_param.data.icmph.code = 0;\r\nicmp_param.skb = skb;\r\nicmp_param.offset = 0;\r\nicmp_param.data_len = 0;\r\nicmp_param.head_len = sizeof(struct icmphdr) + 12;\r\nicmp_reply(&icmp_param, skb);\r\nreturn true;\r\nout_err:\r\nICMP_INC_STATS_BH(dev_net(skb_dst(skb)->dev), ICMP_MIB_INERRORS);\r\nreturn false;\r\n}\r\nstatic bool icmp_discard(struct sk_buff *skb)\r\n{\r\nreturn true;\r\n}\r\nint icmp_rcv(struct sk_buff *skb)\r\n{\r\nstruct icmphdr *icmph;\r\nstruct rtable *rt = skb_rtable(skb);\r\nstruct net *net = dev_net(rt->dst.dev);\r\nbool success;\r\nif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {\r\nstruct sec_path *sp = skb_sec_path(skb);\r\nint nh;\r\nif (!(sp && sp->xvec[sp->len - 1]->props.flags &\r\nXFRM_STATE_ICMP))\r\ngoto drop;\r\nif (!pskb_may_pull(skb, sizeof(*icmph) + sizeof(struct iphdr)))\r\ngoto drop;\r\nnh = skb_network_offset(skb);\r\nskb_set_network_header(skb, sizeof(*icmph));\r\nif (!xfrm4_policy_check_reverse(NULL, XFRM_POLICY_IN, skb))\r\ngoto drop;\r\nskb_set_network_header(skb, nh);\r\n}\r\nICMP_INC_STATS_BH(net, ICMP_MIB_INMSGS);\r\nif (skb_checksum_simple_validate(skb))\r\ngoto csum_error;\r\nif (!pskb_pull(skb, sizeof(*icmph)))\r\ngoto error;\r\nicmph = icmp_hdr(skb);\r\nICMPMSGIN_INC_STATS_BH(net, icmph->type);\r\nif (icmph->type > NR_ICMP_TYPES)\r\ngoto error;\r\nif (rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST)) {\r\nif ((icmph->type == ICMP_ECHO ||\r\nicmph->type == ICMP_TIMESTAMP) &&\r\nnet->ipv4.sysctl_icmp_echo_ignore_broadcasts) {\r\ngoto error;\r\n}\r\nif (icmph->type != ICMP_ECHO &&\r\nicmph->type != ICMP_TIMESTAMP &&\r\nicmph->type != ICMP_ADDRESS &&\r\nicmph->type != ICMP_ADDRESSREPLY) {\r\ngoto error;\r\n}\r\n}\r\nsuccess = icmp_pointers[icmph->type].handler(skb);\r\nif (success) {\r\nconsume_skb(skb);\r\nreturn 0;\r\n}\r\ndrop:\r\nkfree_skb(skb);\r\nreturn 0;\r\ncsum_error:\r\nICMP_INC_STATS_BH(net, ICMP_MIB_CSUMERRORS);\r\nerror:\r\nICMP_INC_STATS_BH(net, ICMP_MIB_INERRORS);\r\ngoto drop;\r\n}\r\nvoid icmp_err(struct sk_buff *skb, u32 info)\r\n{\r\nstruct iphdr *iph = (struct iphdr *)skb->data;\r\nint offset = iph->ihl<<2;\r\nstruct icmphdr *icmph = (struct icmphdr *)(skb->data + offset);\r\nint type = icmp_hdr(skb)->type;\r\nint code = icmp_hdr(skb)->code;\r\nstruct net *net = dev_net(skb->dev);\r\nif (icmph->type != ICMP_ECHOREPLY) {\r\nping_err(skb, offset, info);\r\nreturn;\r\n}\r\nif (type == ICMP_DEST_UNREACH && code == ICMP_FRAG_NEEDED)\r\nipv4_update_pmtu(skb, net, info, 0, 0, IPPROTO_ICMP, 0);\r\nelse if (type == ICMP_REDIRECT)\r\nipv4_redirect(skb, net, 0, 0, IPPROTO_ICMP, 0);\r\n}\r\nstatic void __net_exit icmp_sk_exit(struct net *net)\r\n{\r\nint i;\r\nfor_each_possible_cpu(i)\r\ninet_ctl_sock_destroy(*per_cpu_ptr(net->ipv4.icmp_sk, i));\r\nfree_percpu(net->ipv4.icmp_sk);\r\nnet->ipv4.icmp_sk = NULL;\r\n}\r\nstatic int __net_init icmp_sk_init(struct net *net)\r\n{\r\nint i, err;\r\nnet->ipv4.icmp_sk = alloc_percpu(struct sock *);\r\nif (!net->ipv4.icmp_sk)\r\nreturn -ENOMEM;\r\nfor_each_possible_cpu(i) {\r\nstruct sock *sk;\r\nerr = inet_ctl_sock_create(&sk, PF_INET,\r\nSOCK_RAW, IPPROTO_ICMP, net);\r\nif (err < 0)\r\ngoto fail;\r\n*per_cpu_ptr(net->ipv4.icmp_sk, i) = sk;\r\nsk->sk_sndbuf = 2 * SKB_TRUESIZE(64 * 1024);\r\nsock_set_flag(sk, SOCK_USE_WRITE_QUEUE);\r\ninet_sk(sk)->pmtudisc = IP_PMTUDISC_DONT;\r\n}\r\nnet->ipv4.sysctl_icmp_echo_ignore_all = 0;\r\nnet->ipv4.sysctl_icmp_echo_ignore_broadcasts = 1;\r\nnet->ipv4.sysctl_icmp_ignore_bogus_error_responses = 1;\r\nnet->ipv4.sysctl_icmp_ratelimit = 1 * HZ;\r\nnet->ipv4.sysctl_icmp_ratemask = 0x1818;\r\nnet->ipv4.sysctl_icmp_errors_use_inbound_ifaddr = 0;\r\nreturn 0;\r\nfail:\r\nfor_each_possible_cpu(i)\r\ninet_ctl_sock_destroy(*per_cpu_ptr(net->ipv4.icmp_sk, i));\r\nfree_percpu(net->ipv4.icmp_sk);\r\nreturn err;\r\n}\r\nint __init icmp_init(void)\r\n{\r\nreturn register_pernet_subsys(&icmp_sk_ops);\r\n}
