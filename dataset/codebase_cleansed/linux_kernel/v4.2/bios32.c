struct msi_controller *pcibios_msi_controller(struct pci_dev *dev)\r\n{\r\nstruct pci_sys_data *sysdata = dev->bus->sysdata;\r\nreturn sysdata->msi_ctrl;\r\n}\r\nstatic void pcibios_bus_report_status(struct pci_bus *bus, u_int status_mask, int warn)\r\n{\r\nstruct pci_dev *dev;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nu16 status;\r\nif (dev->bus->number == 0 && dev->devfn == 0)\r\ncontinue;\r\npci_read_config_word(dev, PCI_STATUS, &status);\r\nif (status == 0xffff)\r\ncontinue;\r\nif ((status & status_mask) == 0)\r\ncontinue;\r\npci_write_config_word(dev, PCI_STATUS, status & status_mask);\r\nif (warn)\r\nprintk("(%s: %04X) ", pci_name(dev), status);\r\n}\r\nlist_for_each_entry(dev, &bus->devices, bus_list)\r\nif (dev->subordinate)\r\npcibios_bus_report_status(dev->subordinate, status_mask, warn);\r\n}\r\nvoid pcibios_report_status(u_int status_mask, int warn)\r\n{\r\nstruct pci_bus *bus;\r\nlist_for_each_entry(bus, &pci_root_buses, node)\r\npcibios_bus_report_status(bus, status_mask, warn);\r\n}\r\nstatic void pci_fixup_83c553(struct pci_dev *dev)\r\n{\r\npci_write_config_dword(dev, PCI_BASE_ADDRESS_0, PCI_BASE_ADDRESS_SPACE_MEMORY);\r\npci_write_config_word(dev, PCI_COMMAND, PCI_COMMAND_IO);\r\ndev->resource[0].end -= dev->resource[0].start;\r\ndev->resource[0].start = 0;\r\npci_write_config_byte(dev, 0x48, 0xff);\r\npci_write_config_byte(dev, 0x42, 0x01);\r\npci_write_config_byte(dev, 0x40, 0x22);\r\npci_write_config_byte(dev, 0x83, 0x02);\r\npci_write_config_byte(dev, 0x80, 0x11);\r\npci_write_config_byte(dev, 0x81, 0x00);\r\npci_write_config_word(dev, 0x44, 0xb000);\r\noutb(0x08, 0x4d1);\r\n}\r\nstatic void pci_fixup_unassign(struct pci_dev *dev)\r\n{\r\ndev->resource[0].end -= dev->resource[0].start;\r\ndev->resource[0].start = 0;\r\n}\r\nstatic void pci_fixup_dec21285(struct pci_dev *dev)\r\n{\r\nint i;\r\nif (dev->devfn == 0) {\r\ndev->class &= 0xff;\r\ndev->class |= PCI_CLASS_BRIDGE_HOST << 8;\r\nfor (i = 0; i < PCI_NUM_RESOURCES; i++) {\r\ndev->resource[i].start = 0;\r\ndev->resource[i].end = 0;\r\ndev->resource[i].flags = 0;\r\n}\r\n}\r\n}\r\nstatic void pci_fixup_ide_bases(struct pci_dev *dev)\r\n{\r\nstruct resource *r;\r\nint i;\r\nif ((dev->class >> 8) != PCI_CLASS_STORAGE_IDE)\r\nreturn;\r\nfor (i = 0; i < PCI_NUM_RESOURCES; i++) {\r\nr = dev->resource + i;\r\nif ((r->start & ~0x80) == 0x374) {\r\nr->start |= 2;\r\nr->end = r->start;\r\n}\r\n}\r\n}\r\nstatic void pci_fixup_dec21142(struct pci_dev *dev)\r\n{\r\npci_write_config_dword(dev, 0x40, 0x80000000);\r\n}\r\nstatic void pci_fixup_cy82c693(struct pci_dev *dev)\r\n{\r\nif ((dev->class >> 8) == PCI_CLASS_STORAGE_IDE) {\r\nu32 base0, base1;\r\nif (dev->class & 0x80) {\r\nbase0 = 0x1f0;\r\nbase1 = 0x3f4;\r\n} else {\r\nbase0 = 0x170;\r\nbase1 = 0x374;\r\n}\r\npci_write_config_dword(dev, PCI_BASE_ADDRESS_0,\r\nbase0 | PCI_BASE_ADDRESS_SPACE_IO);\r\npci_write_config_dword(dev, PCI_BASE_ADDRESS_1,\r\nbase1 | PCI_BASE_ADDRESS_SPACE_IO);\r\ndev->resource[0].start = 0;\r\ndev->resource[0].end = 0;\r\ndev->resource[0].flags = 0;\r\ndev->resource[1].start = 0;\r\ndev->resource[1].end = 0;\r\ndev->resource[1].flags = 0;\r\n} else if (PCI_FUNC(dev->devfn) == 0) {\r\npci_write_config_byte(dev, 0x4b, 14);\r\npci_write_config_byte(dev, 0x4c, 15);\r\npci_write_config_byte(dev, 0x4d, 0x41);\r\npci_write_config_byte(dev, 0x44, 0x17);\r\npci_write_config_byte(dev, 0x45, 0x03);\r\n}\r\n}\r\nstatic void pci_fixup_it8152(struct pci_dev *dev)\r\n{\r\nint i;\r\nif ((dev->class >> 8) == PCI_CLASS_BRIDGE_HOST ||\r\ndev->class == 0x68000 ||\r\ndev->class == 0x80103) {\r\nfor (i = 0; i < PCI_NUM_RESOURCES; i++) {\r\ndev->resource[i].start = 0;\r\ndev->resource[i].end = 0;\r\ndev->resource[i].flags = 0;\r\n}\r\n}\r\n}\r\nstatic inline int pdev_bad_for_parity(struct pci_dev *dev)\r\n{\r\nreturn ((dev->vendor == PCI_VENDOR_ID_INTERG &&\r\n(dev->device == PCI_DEVICE_ID_INTERG_2000 ||\r\ndev->device == PCI_DEVICE_ID_INTERG_2010)) ||\r\n(dev->vendor == PCI_VENDOR_ID_ITE &&\r\ndev->device == PCI_DEVICE_ID_ITE_8152));\r\n}\r\nvoid pcibios_fixup_bus(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *dev;\r\nu16 features = PCI_COMMAND_SERR | PCI_COMMAND_PARITY | PCI_COMMAND_FAST_BACK;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nu16 status;\r\npci_read_config_word(dev, PCI_STATUS, &status);\r\nif (!(status & PCI_STATUS_FAST_BACK))\r\nfeatures &= ~PCI_COMMAND_FAST_BACK;\r\nif (pdev_bad_for_parity(dev))\r\nfeatures &= ~(PCI_COMMAND_SERR | PCI_COMMAND_PARITY);\r\nswitch (dev->class >> 8) {\r\ncase PCI_CLASS_BRIDGE_PCI:\r\npci_read_config_word(dev, PCI_BRIDGE_CONTROL, &status);\r\nstatus |= PCI_BRIDGE_CTL_PARITY|PCI_BRIDGE_CTL_MASTER_ABORT;\r\nstatus &= ~(PCI_BRIDGE_CTL_BUS_RESET|PCI_BRIDGE_CTL_FAST_BACK);\r\npci_write_config_word(dev, PCI_BRIDGE_CONTROL, status);\r\nbreak;\r\ncase PCI_CLASS_BRIDGE_CARDBUS:\r\npci_read_config_word(dev, PCI_CB_BRIDGE_CONTROL, &status);\r\nstatus |= PCI_CB_BRIDGE_CTL_PARITY|PCI_CB_BRIDGE_CTL_MASTER_ABORT;\r\npci_write_config_word(dev, PCI_CB_BRIDGE_CONTROL, status);\r\nbreak;\r\n}\r\n}\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nu16 cmd;\r\npci_read_config_word(dev, PCI_COMMAND, &cmd);\r\ncmd |= features;\r\npci_write_config_word(dev, PCI_COMMAND, cmd);\r\npci_write_config_byte(dev, PCI_CACHE_LINE_SIZE,\r\nL1_CACHE_BYTES >> 2);\r\n}\r\nif (bus->self && bus->self->hdr_type == PCI_HEADER_TYPE_BRIDGE) {\r\nif (features & PCI_COMMAND_FAST_BACK)\r\nbus->bridge_ctl |= PCI_BRIDGE_CTL_FAST_BACK;\r\nif (features & PCI_COMMAND_PARITY)\r\nbus->bridge_ctl |= PCI_BRIDGE_CTL_PARITY;\r\n}\r\npr_info("PCI: bus%d: Fast back to back transfers %sabled\n",\r\nbus->number, (features & PCI_COMMAND_FAST_BACK) ? "en" : "dis");\r\n}\r\nstatic u8 pcibios_swizzle(struct pci_dev *dev, u8 *pin)\r\n{\r\nstruct pci_sys_data *sys = dev->sysdata;\r\nint slot, oldpin = *pin;\r\nif (sys->swizzle)\r\nslot = sys->swizzle(dev, pin);\r\nelse\r\nslot = pci_common_swizzle(dev, pin);\r\nif (debug_pci)\r\nprintk("PCI: %s swizzling pin %d => pin %d slot %d\n",\r\npci_name(dev), oldpin, *pin, slot);\r\nreturn slot;\r\n}\r\nstatic int pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\r\n{\r\nstruct pci_sys_data *sys = dev->sysdata;\r\nint irq = -1;\r\nif (sys->map_irq)\r\nirq = sys->map_irq(dev, slot, pin);\r\nif (debug_pci)\r\nprintk("PCI: %s mapping slot %d pin %d => irq %d\n",\r\npci_name(dev), slot, pin, irq);\r\nreturn irq;\r\n}\r\nstatic int pcibios_init_resources(int busnr, struct pci_sys_data *sys)\r\n{\r\nint ret;\r\nstruct resource_entry *window;\r\nif (list_empty(&sys->resources)) {\r\npci_add_resource_offset(&sys->resources,\r\n&iomem_resource, sys->mem_offset);\r\n}\r\nresource_list_for_each_entry(window, &sys->resources)\r\nif (resource_type(window->res) == IORESOURCE_IO)\r\nreturn 0;\r\nsys->io_res.start = (busnr * SZ_64K) ? : pcibios_min_io;\r\nsys->io_res.end = (busnr + 1) * SZ_64K - 1;\r\nsys->io_res.flags = IORESOURCE_IO;\r\nsys->io_res.name = sys->io_res_name;\r\nsprintf(sys->io_res_name, "PCI%d I/O", busnr);\r\nret = request_resource(&ioport_resource, &sys->io_res);\r\nif (ret) {\r\npr_err("PCI: unable to allocate I/O port region (%d)\n", ret);\r\nreturn ret;\r\n}\r\npci_add_resource_offset(&sys->resources, &sys->io_res,\r\nsys->io_offset);\r\nreturn 0;\r\n}\r\nstatic void pcibios_init_hw(struct device *parent, struct hw_pci *hw,\r\nstruct list_head *head)\r\n{\r\nstruct pci_sys_data *sys = NULL;\r\nint ret;\r\nint nr, busnr;\r\nfor (nr = busnr = 0; nr < hw->nr_controllers; nr++) {\r\nsys = kzalloc(sizeof(struct pci_sys_data), GFP_KERNEL);\r\nif (!sys)\r\npanic("PCI: unable to allocate sys data!");\r\n#ifdef CONFIG_PCI_MSI\r\nsys->msi_ctrl = hw->msi_ctrl;\r\n#endif\r\nsys->busnr = busnr;\r\nsys->swizzle = hw->swizzle;\r\nsys->map_irq = hw->map_irq;\r\nsys->align_resource = hw->align_resource;\r\nINIT_LIST_HEAD(&sys->resources);\r\nif (hw->private_data)\r\nsys->private_data = hw->private_data[nr];\r\nret = hw->setup(nr, sys);\r\nif (ret > 0) {\r\nret = pcibios_init_resources(nr, sys);\r\nif (ret) {\r\nkfree(sys);\r\nbreak;\r\n}\r\nif (hw->scan)\r\nsys->bus = hw->scan(nr, sys);\r\nelse\r\nsys->bus = pci_scan_root_bus(parent, sys->busnr,\r\nhw->ops, sys, &sys->resources);\r\nif (!sys->bus)\r\npanic("PCI: unable to scan bus!");\r\nbusnr = sys->bus->busn_res.end + 1;\r\nlist_add(&sys->node, head);\r\n} else {\r\nkfree(sys);\r\nif (ret < 0)\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid pci_common_init_dev(struct device *parent, struct hw_pci *hw)\r\n{\r\nstruct pci_sys_data *sys;\r\nLIST_HEAD(head);\r\npci_add_flags(PCI_REASSIGN_ALL_RSRC);\r\nif (hw->preinit)\r\nhw->preinit();\r\npcibios_init_hw(parent, hw, &head);\r\nif (hw->postinit)\r\nhw->postinit();\r\npci_fixup_irqs(pcibios_swizzle, pcibios_map_irq);\r\nlist_for_each_entry(sys, &head, node) {\r\nstruct pci_bus *bus = sys->bus;\r\nif (!pci_has_flag(PCI_PROBE_ONLY)) {\r\npci_bus_size_bridges(bus);\r\npci_bus_assign_resources(bus);\r\n}\r\npci_bus_add_devices(bus);\r\n}\r\nlist_for_each_entry(sys, &head, node) {\r\nstruct pci_bus *bus = sys->bus;\r\nif (bus && !pci_has_flag(PCI_PROBE_ONLY)) {\r\nstruct pci_bus *child;\r\nlist_for_each_entry(child, &bus->children, node)\r\npcie_bus_configure_settings(child);\r\n}\r\n}\r\n}\r\nvoid pcibios_set_master(struct pci_dev *dev)\r\n{\r\n}\r\nchar * __init pcibios_setup(char *str)\r\n{\r\nif (!strcmp(str, "debug")) {\r\ndebug_pci = 1;\r\nreturn NULL;\r\n} else if (!strcmp(str, "firmware")) {\r\npci_add_flags(PCI_PROBE_ONLY);\r\nreturn NULL;\r\n}\r\nreturn str;\r\n}\r\nresource_size_t pcibios_align_resource(void *data, const struct resource *res,\r\nresource_size_t size, resource_size_t align)\r\n{\r\nstruct pci_dev *dev = data;\r\nstruct pci_sys_data *sys = dev->sysdata;\r\nresource_size_t start = res->start;\r\nif (res->flags & IORESOURCE_IO && start & 0x300)\r\nstart = (start + 0x3ff) & ~0x3ff;\r\nstart = (start + align - 1) & ~(align - 1);\r\nif (sys->align_resource)\r\nreturn sys->align_resource(dev, res, start, size, align);\r\nreturn start;\r\n}\r\nint pcibios_enable_device(struct pci_dev *dev, int mask)\r\n{\r\nif (pci_has_flag(PCI_PROBE_ONLY))\r\nreturn 0;\r\nreturn pci_enable_resources(dev, mask);\r\n}\r\nint pci_mmap_page_range(struct pci_dev *dev, struct vm_area_struct *vma,\r\nenum pci_mmap_state mmap_state, int write_combine)\r\n{\r\nif (mmap_state == pci_mmap_io)\r\nreturn -EINVAL;\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\nif (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,\r\nvma->vm_end - vma->vm_start,\r\nvma->vm_page_prot))\r\nreturn -EAGAIN;\r\nreturn 0;\r\n}\r\nvoid __init pci_map_io_early(unsigned long pfn)\r\n{\r\nstruct map_desc pci_io_desc = {\r\n.virtual = PCI_IO_VIRT_BASE,\r\n.type = MT_DEVICE,\r\n.length = SZ_64K,\r\n};\r\npci_io_desc.pfn = pfn;\r\niotable_init(&pci_io_desc, 1);\r\n}
