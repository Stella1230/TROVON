static int apci3501_wait_for_dac(struct comedi_device *dev)\r\n{\r\nunsigned int status;\r\ndo {\r\nstatus = inl(dev->iobase + APCI3501_AO_CTRL_STATUS_REG);\r\n} while (!(status & APCI3501_AO_STATUS_READY));\r\nreturn 0;\r\n}\r\nstatic int apci3501_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int range = CR_RANGE(insn->chanspec);\r\nunsigned int cfg = APCI3501_AO_DATA_CHAN(chan);\r\nint ret;\r\nint i;\r\nif (range) {\r\noutl(0, dev->iobase + APCI3501_AO_CTRL_STATUS_REG);\r\n} else {\r\ncfg |= APCI3501_AO_DATA_BIPOLAR;\r\noutl(APCI3501_AO_CTRL_BIPOLAR,\r\ndev->iobase + APCI3501_AO_CTRL_STATUS_REG);\r\n}\r\nfor (i = 0; i < insn->n; i++) {\r\nunsigned int val = data[i];\r\nif (range == 1) {\r\nif (data[i] > 0x1fff) {\r\ndev_err(dev->class_dev,\r\n"Unipolar resolution is only 13-bits\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nret = apci3501_wait_for_dac(dev);\r\nif (ret)\r\nreturn ret;\r\noutl(cfg | APCI3501_AO_DATA_VAL(val),\r\ndev->iobase + APCI3501_AO_DATA_REG);\r\ns->readback[chan] = val;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int apci3501_di_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\ndata[1] = inl(dev->iobase + APCI3501_DI_REG) & 0x3;\r\nreturn insn->n;\r\n}\r\nstatic int apci3501_do_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\ns->state = inl(dev->iobase + APCI3501_DO_REG);\r\nif (comedi_dio_update_state(s, data))\r\noutl(s->state, dev->iobase + APCI3501_DO_REG);\r\ndata[1] = s->state;\r\nreturn insn->n;\r\n}\r\nstatic void apci3501_eeprom_wait(unsigned long iobase)\r\n{\r\nunsigned char val;\r\ndo {\r\nval = inb(iobase + AMCC_OP_REG_MCSR_NVCMD);\r\n} while (val & 0x80);\r\n}\r\nstatic unsigned short apci3501_eeprom_readw(unsigned long iobase,\r\nunsigned short addr)\r\n{\r\nunsigned short val = 0;\r\nunsigned char tmp;\r\nunsigned char i;\r\naddr += NVRAM_USER_DATA_START;\r\nfor (i = 0; i < 2; i++) {\r\noutb(NVCMD_LOAD_LOW, iobase + AMCC_OP_REG_MCSR_NVCMD);\r\napci3501_eeprom_wait(iobase);\r\noutb((addr + i) & 0xff, iobase + AMCC_OP_REG_MCSR_NVDATA);\r\napci3501_eeprom_wait(iobase);\r\noutb(NVCMD_LOAD_HIGH, iobase + AMCC_OP_REG_MCSR_NVCMD);\r\napci3501_eeprom_wait(iobase);\r\noutb(((addr + i) >> 8) & 0xff,\r\niobase + AMCC_OP_REG_MCSR_NVDATA);\r\napci3501_eeprom_wait(iobase);\r\noutb(NVCMD_BEGIN_READ, iobase + AMCC_OP_REG_MCSR_NVCMD);\r\napci3501_eeprom_wait(iobase);\r\ntmp = inb(iobase + AMCC_OP_REG_MCSR_NVDATA);\r\napci3501_eeprom_wait(iobase);\r\nif (i == 0)\r\nval |= tmp;\r\nelse\r\nval |= (tmp << 8);\r\n}\r\nreturn val;\r\n}\r\nstatic int apci3501_eeprom_get_ao_n_chan(struct comedi_device *dev)\r\n{\r\nstruct apci3501_private *devpriv = dev->private;\r\nunsigned long iobase = devpriv->i_IobaseAmcc;\r\nunsigned char nfuncs;\r\nint i;\r\nnfuncs = apci3501_eeprom_readw(iobase, 10) & 0xff;\r\nfor (i = 0; i < nfuncs; i++) {\r\nunsigned short offset = i * 4;\r\nunsigned short addr;\r\nunsigned char func;\r\nunsigned short val;\r\nfunc = apci3501_eeprom_readw(iobase, 12 + offset) & 0x3f;\r\naddr = apci3501_eeprom_readw(iobase, 14 + offset);\r\nif (func == EEPROM_ANALOGOUTPUT) {\r\nval = apci3501_eeprom_readw(iobase, addr + 10);\r\nreturn (val >> 4) & 0x3ff;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int apci3501_eeprom_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct apci3501_private *devpriv = dev->private;\r\nunsigned short addr = CR_CHAN(insn->chanspec);\r\ndata[0] = apci3501_eeprom_readw(devpriv->i_IobaseAmcc, 2 * addr);\r\nreturn insn->n;\r\n}\r\nstatic irqreturn_t apci3501_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct apci3501_private *devpriv = dev->private;\r\nunsigned int ui_Timer_AOWatchdog;\r\nunsigned long ul_Command1;\r\nul_Command1 = inl(dev->iobase + APCI3501_TIMER_CTRL_REG);\r\nul_Command1 = ul_Command1 & 0xFFFFF9FDul;\r\noutl(ul_Command1, dev->iobase + APCI3501_TIMER_CTRL_REG);\r\nui_Timer_AOWatchdog = inl(dev->iobase + APCI3501_TIMER_IRQ_REG) & 0x1;\r\nif ((!ui_Timer_AOWatchdog)) {\r\ndev_err(dev->class_dev, "IRQ from unknown source\n");\r\nreturn IRQ_NONE;\r\n}\r\nsend_sig(SIGIO, devpriv->tsk_Current, 0);\r\nul_Command1 = inl(dev->iobase + APCI3501_TIMER_CTRL_REG);\r\nul_Command1 = (ul_Command1 & 0xFFFFF9FDul) | 1 << 1;\r\noutl(ul_Command1, dev->iobase + APCI3501_TIMER_CTRL_REG);\r\ninl(dev->iobase + APCI3501_TIMER_STATUS_REG);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int apci3501_reset(struct comedi_device *dev)\r\n{\r\nunsigned int val;\r\nint chan;\r\nint ret;\r\noutl(0x0, dev->iobase + APCI3501_DO_REG);\r\noutl(APCI3501_AO_CTRL_BIPOLAR,\r\ndev->iobase + APCI3501_AO_CTRL_STATUS_REG);\r\nval = APCI3501_AO_DATA_BIPOLAR | APCI3501_AO_DATA_VAL(0);\r\nfor (chan = 0; chan < 8; chan++) {\r\nret = apci3501_wait_for_dac(dev);\r\nif (ret) {\r\ndev_warn(dev->class_dev,\r\n"%s: DAC not-ready for channel %i\n",\r\n__func__, chan);\r\n} else {\r\noutl(val | APCI3501_AO_DATA_CHAN(chan),\r\ndev->iobase + APCI3501_AO_DATA_REG);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int apci3501_auto_attach(struct comedi_device *dev,\r\nunsigned long context_unused)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nstruct apci3501_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint ao_n_chan;\r\nint ret;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nret = comedi_pci_enable(dev);\r\nif (ret)\r\nreturn ret;\r\ndev->iobase = pci_resource_start(pcidev, 1);\r\ndevpriv->i_IobaseAmcc = pci_resource_start(pcidev, 0);\r\nao_n_chan = apci3501_eeprom_get_ao_n_chan(dev);\r\nif (pcidev->irq > 0) {\r\nret = request_irq(pcidev->irq, apci3501_interrupt, IRQF_SHARED,\r\ndev->board_name, dev);\r\nif (ret == 0)\r\ndev->irq = pcidev->irq;\r\n}\r\nret = comedi_alloc_subdevices(dev, 5);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\nif (ao_n_chan) {\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_COMMON;\r\ns->n_chan = ao_n_chan;\r\ns->maxdata = 0x3fff;\r\ns->range_table = &apci3501_ao_range;\r\ns->insn_write = apci3501_ao_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[1];\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 2;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = apci3501_di_insn_bits;\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 2;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = apci3501_do_insn_bits;\r\ns = &dev->subdevices[3];\r\ns->type = COMEDI_SUBD_TIMER;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 1;\r\ns->maxdata = 0;\r\ns->len_chanlist = 1;\r\ns->range_table = &range_digital;\r\ns->insn_write = apci3501_write_insn_timer;\r\ns->insn_read = apci3501_read_insn_timer;\r\ns->insn_config = apci3501_config_insn_timer;\r\ns = &dev->subdevices[4];\r\ns->type = COMEDI_SUBD_MEMORY;\r\ns->subdev_flags = SDF_READABLE | SDF_INTERNAL;\r\ns->n_chan = 256;\r\ns->maxdata = 0xffff;\r\ns->insn_read = apci3501_eeprom_insn_read;\r\napci3501_reset(dev);\r\nreturn 0;\r\n}\r\nstatic void apci3501_detach(struct comedi_device *dev)\r\n{\r\nif (dev->iobase)\r\napci3501_reset(dev);\r\ncomedi_pci_detach(dev);\r\n}\r\nstatic int apci3501_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nreturn comedi_pci_auto_config(dev, &apci3501_driver, id->driver_data);\r\n}
