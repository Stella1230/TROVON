static inline void wait_for_xmitr(struct uart_port *port)\r\n{\r\nwhile (!(msm_read(port, UART_SR) & UART_SR_TX_EMPTY)) {\r\nif (msm_read(port, UART_ISR) & UART_ISR_TX_READY)\r\nbreak;\r\nudelay(1);\r\n}\r\nmsm_write(port, UART_CR_CMD_RESET_TX_READY, UART_CR);\r\n}\r\nstatic void msm_stop_tx(struct uart_port *port)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nmsm_port->imr &= ~UART_IMR_TXLEV;\r\nmsm_write(port, msm_port->imr, UART_IMR);\r\n}\r\nstatic void msm_start_tx(struct uart_port *port)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nmsm_port->imr |= UART_IMR_TXLEV;\r\nmsm_write(port, msm_port->imr, UART_IMR);\r\n}\r\nstatic void msm_stop_rx(struct uart_port *port)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nmsm_port->imr &= ~(UART_IMR_RXLEV | UART_IMR_RXSTALE);\r\nmsm_write(port, msm_port->imr, UART_IMR);\r\n}\r\nstatic void msm_enable_ms(struct uart_port *port)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nmsm_port->imr |= UART_IMR_DELTA_CTS;\r\nmsm_write(port, msm_port->imr, UART_IMR);\r\n}\r\nstatic void handle_rx_dm(struct uart_port *port, unsigned int misr)\r\n{\r\nstruct tty_port *tport = &port->state->port;\r\nunsigned int sr;\r\nint count = 0;\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nif ((msm_read(port, UART_SR) & UART_SR_OVERRUN)) {\r\nport->icount.overrun++;\r\ntty_insert_flip_char(tport, 0, TTY_OVERRUN);\r\nmsm_write(port, UART_CR_CMD_RESET_ERR, UART_CR);\r\n}\r\nif (misr & UART_IMR_RXSTALE) {\r\ncount = msm_read(port, UARTDM_RX_TOTAL_SNAP) -\r\nmsm_port->old_snap_state;\r\nmsm_port->old_snap_state = 0;\r\n} else {\r\ncount = 4 * (msm_read(port, UART_RFWR));\r\nmsm_port->old_snap_state += count;\r\n}\r\nport->icount.rx += count;\r\nwhile (count > 0) {\r\nunsigned char buf[4];\r\nint sysrq, r_count, i;\r\nsr = msm_read(port, UART_SR);\r\nif ((sr & UART_SR_RX_READY) == 0) {\r\nmsm_port->old_snap_state -= count;\r\nbreak;\r\n}\r\nioread32_rep(port->membase + UARTDM_RF, buf, 1);\r\nr_count = min_t(int, count, sizeof(buf));\r\nfor (i = 0; i < r_count; i++) {\r\nchar flag = TTY_NORMAL;\r\nif (msm_port->break_detected && buf[i] == 0) {\r\nport->icount.brk++;\r\nflag = TTY_BREAK;\r\nmsm_port->break_detected = false;\r\nif (uart_handle_break(port))\r\ncontinue;\r\n}\r\nif (!(port->read_status_mask & UART_SR_RX_BREAK))\r\nflag = TTY_NORMAL;\r\nspin_unlock(&port->lock);\r\nsysrq = uart_handle_sysrq_char(port, buf[i]);\r\nspin_lock(&port->lock);\r\nif (!sysrq)\r\ntty_insert_flip_char(tport, buf[i], flag);\r\n}\r\ncount -= r_count;\r\n}\r\nspin_unlock(&port->lock);\r\ntty_flip_buffer_push(tport);\r\nspin_lock(&port->lock);\r\nif (misr & (UART_IMR_RXSTALE))\r\nmsm_write(port, UART_CR_CMD_RESET_STALE_INT, UART_CR);\r\nmsm_write(port, 0xFFFFFF, UARTDM_DMRX);\r\nmsm_write(port, UART_CR_CMD_STALE_EVENT_ENABLE, UART_CR);\r\n}\r\nstatic void handle_rx(struct uart_port *port)\r\n{\r\nstruct tty_port *tport = &port->state->port;\r\nunsigned int sr;\r\nif ((msm_read(port, UART_SR) & UART_SR_OVERRUN)) {\r\nport->icount.overrun++;\r\ntty_insert_flip_char(tport, 0, TTY_OVERRUN);\r\nmsm_write(port, UART_CR_CMD_RESET_ERR, UART_CR);\r\n}\r\nwhile ((sr = msm_read(port, UART_SR)) & UART_SR_RX_READY) {\r\nunsigned int c;\r\nchar flag = TTY_NORMAL;\r\nint sysrq;\r\nc = msm_read(port, UART_RF);\r\nif (sr & UART_SR_RX_BREAK) {\r\nport->icount.brk++;\r\nif (uart_handle_break(port))\r\ncontinue;\r\n} else if (sr & UART_SR_PAR_FRAME_ERR) {\r\nport->icount.frame++;\r\n} else {\r\nport->icount.rx++;\r\n}\r\nsr &= port->read_status_mask;\r\nif (sr & UART_SR_RX_BREAK)\r\nflag = TTY_BREAK;\r\nelse if (sr & UART_SR_PAR_FRAME_ERR)\r\nflag = TTY_FRAME;\r\nspin_unlock(&port->lock);\r\nsysrq = uart_handle_sysrq_char(port, c);\r\nspin_lock(&port->lock);\r\nif (!sysrq)\r\ntty_insert_flip_char(tport, c, flag);\r\n}\r\nspin_unlock(&port->lock);\r\ntty_flip_buffer_push(tport);\r\nspin_lock(&port->lock);\r\n}\r\nstatic void reset_dm_count(struct uart_port *port, int count)\r\n{\r\nwait_for_xmitr(port);\r\nmsm_write(port, count, UARTDM_NCF_TX);\r\nmsm_read(port, UARTDM_NCF_TX);\r\n}\r\nstatic void handle_tx(struct uart_port *port)\r\n{\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nunsigned int tx_count, num_chars;\r\nunsigned int tf_pointer = 0;\r\nvoid __iomem *tf;\r\nif (msm_port->is_uartdm)\r\ntf = port->membase + UARTDM_TF;\r\nelse\r\ntf = port->membase + UART_TF;\r\ntx_count = uart_circ_chars_pending(xmit);\r\ntx_count = min3(tx_count, (unsigned int)UART_XMIT_SIZE - xmit->tail,\r\nport->fifosize);\r\nif (port->x_char) {\r\nif (msm_port->is_uartdm)\r\nreset_dm_count(port, tx_count + 1);\r\niowrite8_rep(tf, &port->x_char, 1);\r\nport->icount.tx++;\r\nport->x_char = 0;\r\n} else if (tx_count && msm_port->is_uartdm) {\r\nreset_dm_count(port, tx_count);\r\n}\r\nwhile (tf_pointer < tx_count) {\r\nint i;\r\nchar buf[4] = { 0 };\r\nif (!(msm_read(port, UART_SR) & UART_SR_TX_READY))\r\nbreak;\r\nif (msm_port->is_uartdm)\r\nnum_chars = min(tx_count - tf_pointer,\r\n(unsigned int)sizeof(buf));\r\nelse\r\nnum_chars = 1;\r\nfor (i = 0; i < num_chars; i++) {\r\nbuf[i] = xmit->buf[xmit->tail + i];\r\nport->icount.tx++;\r\n}\r\niowrite32_rep(tf, buf, 1);\r\nxmit->tail = (xmit->tail + num_chars) & (UART_XMIT_SIZE - 1);\r\ntf_pointer += num_chars;\r\n}\r\nif (uart_circ_empty(xmit))\r\nmsm_stop_tx(port);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\n}\r\nstatic void handle_delta_cts(struct uart_port *port)\r\n{\r\nmsm_write(port, UART_CR_CMD_RESET_CTS, UART_CR);\r\nport->icount.cts++;\r\nwake_up_interruptible(&port->state->port.delta_msr_wait);\r\n}\r\nstatic irqreturn_t msm_irq(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = dev_id;\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nunsigned int misr;\r\nspin_lock(&port->lock);\r\nmisr = msm_read(port, UART_MISR);\r\nmsm_write(port, 0, UART_IMR);\r\nif (misr & UART_IMR_RXBREAK_START) {\r\nmsm_port->break_detected = true;\r\nmsm_write(port, UART_CR_CMD_RESET_RXBREAK_START, UART_CR);\r\n}\r\nif (misr & (UART_IMR_RXLEV | UART_IMR_RXSTALE)) {\r\nif (msm_port->is_uartdm)\r\nhandle_rx_dm(port, misr);\r\nelse\r\nhandle_rx(port);\r\n}\r\nif (misr & UART_IMR_TXLEV)\r\nhandle_tx(port);\r\nif (misr & UART_IMR_DELTA_CTS)\r\nhandle_delta_cts(port);\r\nmsm_write(port, msm_port->imr, UART_IMR);\r\nspin_unlock(&port->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int msm_tx_empty(struct uart_port *port)\r\n{\r\nreturn (msm_read(port, UART_SR) & UART_SR_TX_EMPTY) ? TIOCSER_TEMT : 0;\r\n}\r\nstatic unsigned int msm_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_CAR | TIOCM_CTS | TIOCM_DSR | TIOCM_RTS;\r\n}\r\nstatic void msm_reset(struct uart_port *port)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nmsm_write(port, UART_CR_CMD_RESET_RX, UART_CR);\r\nmsm_write(port, UART_CR_CMD_RESET_TX, UART_CR);\r\nmsm_write(port, UART_CR_CMD_RESET_ERR, UART_CR);\r\nmsm_write(port, UART_CR_CMD_RESET_BREAK_INT, UART_CR);\r\nmsm_write(port, UART_CR_CMD_RESET_CTS, UART_CR);\r\nmsm_write(port, UART_CR_CMD_SET_RFR, UART_CR);\r\nif (msm_port->is_uartdm)\r\nmsm_write(port, 0, UARTDM_DMEN);\r\n}\r\nstatic void msm_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nunsigned int mr;\r\nmr = msm_read(port, UART_MR1);\r\nif (!(mctrl & TIOCM_RTS)) {\r\nmr &= ~UART_MR1_RX_RDY_CTL;\r\nmsm_write(port, mr, UART_MR1);\r\nmsm_write(port, UART_CR_CMD_RESET_RFR, UART_CR);\r\n} else {\r\nmr |= UART_MR1_RX_RDY_CTL;\r\nmsm_write(port, mr, UART_MR1);\r\n}\r\n}\r\nstatic void msm_break_ctl(struct uart_port *port, int break_ctl)\r\n{\r\nif (break_ctl)\r\nmsm_write(port, UART_CR_CMD_START_BREAK, UART_CR);\r\nelse\r\nmsm_write(port, UART_CR_CMD_STOP_BREAK, UART_CR);\r\n}\r\nstatic const struct msm_baud_map *\r\nmsm_find_best_baud(struct uart_port *port, unsigned int baud)\r\n{\r\nunsigned int i, divisor;\r\nconst struct msm_baud_map *entry;\r\nstatic const struct msm_baud_map table[] = {\r\n{ 1536, 0x00, 1 },\r\n{ 768, 0x11, 1 },\r\n{ 384, 0x22, 1 },\r\n{ 192, 0x33, 1 },\r\n{ 96, 0x44, 1 },\r\n{ 48, 0x55, 1 },\r\n{ 32, 0x66, 1 },\r\n{ 24, 0x77, 1 },\r\n{ 16, 0x88, 1 },\r\n{ 12, 0x99, 6 },\r\n{ 8, 0xaa, 6 },\r\n{ 6, 0xbb, 6 },\r\n{ 4, 0xcc, 6 },\r\n{ 3, 0xdd, 8 },\r\n{ 2, 0xee, 16 },\r\n{ 1, 0xff, 31 },\r\n};\r\ndivisor = uart_get_divisor(port, baud);\r\nfor (i = 0, entry = table; i < ARRAY_SIZE(table); i++, entry++)\r\nif (entry->divisor <= divisor)\r\nbreak;\r\nreturn entry;\r\n}\r\nstatic int msm_set_baud_rate(struct uart_port *port, unsigned int baud)\r\n{\r\nunsigned int rxstale, watermark;\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nconst struct msm_baud_map *entry;\r\nentry = msm_find_best_baud(port, baud);\r\nmsm_write(port, entry->code, UART_CSR);\r\nrxstale = entry->rxstale;\r\nwatermark = UART_IPR_STALE_LSB & rxstale;\r\nwatermark |= UART_IPR_RXSTALE_LAST;\r\nwatermark |= UART_IPR_STALE_TIMEOUT_MSB & (rxstale << 2);\r\nmsm_write(port, watermark, UART_IPR);\r\nwatermark = (port->fifosize * 3) / 4;\r\nmsm_write(port, watermark, UART_RFWR);\r\nmsm_write(port, 10, UART_TFWR);\r\nmsm_write(port, UART_CR_CMD_PROTECTION_EN, UART_CR);\r\nmsm_reset(port);\r\nmsm_write(port, UART_CR_TX_ENABLE | UART_CR_RX_ENABLE, UART_CR);\r\nmsm_port->imr = UART_IMR_RXLEV | UART_IMR_RXSTALE |\r\nUART_IMR_CURRENT_CTS | UART_IMR_RXBREAK_START;\r\nmsm_write(port, msm_port->imr, UART_IMR);\r\nif (msm_port->is_uartdm) {\r\nmsm_write(port, UART_CR_CMD_RESET_STALE_INT, UART_CR);\r\nmsm_write(port, 0xFFFFFF, UARTDM_DMRX);\r\nmsm_write(port, UART_CR_CMD_STALE_EVENT_ENABLE, UART_CR);\r\n}\r\nreturn baud;\r\n}\r\nstatic void msm_init_clock(struct uart_port *port)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nclk_prepare_enable(msm_port->clk);\r\nclk_prepare_enable(msm_port->pclk);\r\nmsm_serial_set_mnd_regs(port);\r\n}\r\nstatic int msm_startup(struct uart_port *port)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nunsigned int data, rfr_level;\r\nint ret;\r\nsnprintf(msm_port->name, sizeof(msm_port->name),\r\n"msm_serial%d", port->line);\r\nret = request_irq(port->irq, msm_irq, IRQF_TRIGGER_HIGH,\r\nmsm_port->name, port);\r\nif (unlikely(ret))\r\nreturn ret;\r\nmsm_init_clock(port);\r\nif (likely(port->fifosize > 12))\r\nrfr_level = port->fifosize - 12;\r\nelse\r\nrfr_level = port->fifosize;\r\ndata = msm_read(port, UART_MR1);\r\ndata &= ~UART_MR1_AUTO_RFR_LEVEL1;\r\ndata &= ~UART_MR1_AUTO_RFR_LEVEL0;\r\ndata |= UART_MR1_AUTO_RFR_LEVEL1 & (rfr_level << 2);\r\ndata |= UART_MR1_AUTO_RFR_LEVEL0 & rfr_level;\r\nmsm_write(port, data, UART_MR1);\r\nreturn 0;\r\n}\r\nstatic void msm_shutdown(struct uart_port *port)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nmsm_port->imr = 0;\r\nmsm_write(port, 0, UART_IMR);\r\nclk_disable_unprepare(msm_port->clk);\r\nfree_irq(port->irq, port);\r\n}\r\nstatic void msm_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nunsigned long flags;\r\nunsigned int baud, mr;\r\nspin_lock_irqsave(&port->lock, flags);\r\nbaud = uart_get_baud_rate(port, termios, old, 300, 115200);\r\nbaud = msm_set_baud_rate(port, baud);\r\nif (tty_termios_baud_rate(termios))\r\ntty_termios_encode_baud_rate(termios, baud, baud);\r\nmr = msm_read(port, UART_MR2);\r\nmr &= ~UART_MR2_PARITY_MODE;\r\nif (termios->c_cflag & PARENB) {\r\nif (termios->c_cflag & PARODD)\r\nmr |= UART_MR2_PARITY_MODE_ODD;\r\nelse if (termios->c_cflag & CMSPAR)\r\nmr |= UART_MR2_PARITY_MODE_SPACE;\r\nelse\r\nmr |= UART_MR2_PARITY_MODE_EVEN;\r\n}\r\nmr &= ~UART_MR2_BITS_PER_CHAR;\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\nmr |= UART_MR2_BITS_PER_CHAR_5;\r\nbreak;\r\ncase CS6:\r\nmr |= UART_MR2_BITS_PER_CHAR_6;\r\nbreak;\r\ncase CS7:\r\nmr |= UART_MR2_BITS_PER_CHAR_7;\r\nbreak;\r\ncase CS8:\r\ndefault:\r\nmr |= UART_MR2_BITS_PER_CHAR_8;\r\nbreak;\r\n}\r\nmr &= ~(UART_MR2_STOP_BIT_LEN_ONE | UART_MR2_STOP_BIT_LEN_TWO);\r\nif (termios->c_cflag & CSTOPB)\r\nmr |= UART_MR2_STOP_BIT_LEN_TWO;\r\nelse\r\nmr |= UART_MR2_STOP_BIT_LEN_ONE;\r\nmsm_write(port, mr, UART_MR2);\r\nmr = msm_read(port, UART_MR1);\r\nmr &= ~(UART_MR1_CTS_CTL | UART_MR1_RX_RDY_CTL);\r\nif (termios->c_cflag & CRTSCTS) {\r\nmr |= UART_MR1_CTS_CTL;\r\nmr |= UART_MR1_RX_RDY_CTL;\r\n}\r\nmsm_write(port, mr, UART_MR1);\r\nport->read_status_mask = 0;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= UART_SR_PAR_FRAME_ERR;\r\nif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\r\nport->read_status_mask |= UART_SR_RX_BREAK;\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic const char *msm_type(struct uart_port *port)\r\n{\r\nreturn "MSM";\r\n}\r\nstatic void msm_release_port(struct uart_port *port)\r\n{\r\nstruct platform_device *pdev = to_platform_device(port->dev);\r\nstruct resource *uart_resource;\r\nresource_size_t size;\r\nuart_resource = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (unlikely(!uart_resource))\r\nreturn;\r\nsize = resource_size(uart_resource);\r\nrelease_mem_region(port->mapbase, size);\r\niounmap(port->membase);\r\nport->membase = NULL;\r\n}\r\nstatic int msm_request_port(struct uart_port *port)\r\n{\r\nstruct platform_device *pdev = to_platform_device(port->dev);\r\nstruct resource *uart_resource;\r\nresource_size_t size;\r\nint ret;\r\nuart_resource = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (unlikely(!uart_resource))\r\nreturn -ENXIO;\r\nsize = resource_size(uart_resource);\r\nif (!request_mem_region(port->mapbase, size, "msm_serial"))\r\nreturn -EBUSY;\r\nport->membase = ioremap(port->mapbase, size);\r\nif (!port->membase) {\r\nret = -EBUSY;\r\ngoto fail_release_port;\r\n}\r\nreturn 0;\r\nfail_release_port:\r\nrelease_mem_region(port->mapbase, size);\r\nreturn ret;\r\n}\r\nstatic void msm_config_port(struct uart_port *port, int flags)\r\n{\r\nint ret;\r\nif (flags & UART_CONFIG_TYPE) {\r\nport->type = PORT_MSM;\r\nret = msm_request_port(port);\r\nif (ret)\r\nreturn;\r\n}\r\n}\r\nstatic int msm_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nif (unlikely(ser->type != PORT_UNKNOWN && ser->type != PORT_MSM))\r\nreturn -EINVAL;\r\nif (unlikely(port->irq != ser->irq))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void msm_power(struct uart_port *port, unsigned int state,\r\nunsigned int oldstate)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nswitch (state) {\r\ncase 0:\r\nclk_prepare_enable(msm_port->clk);\r\nclk_prepare_enable(msm_port->pclk);\r\nbreak;\r\ncase 3:\r\nclk_disable_unprepare(msm_port->clk);\r\nclk_disable_unprepare(msm_port->pclk);\r\nbreak;\r\ndefault:\r\npr_err("msm_serial: Unknown PM state %d\n", state);\r\n}\r\n}\r\nstatic int msm_poll_get_char_single(struct uart_port *port)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nunsigned int rf_reg = msm_port->is_uartdm ? UARTDM_RF : UART_RF;\r\nif (!(msm_read(port, UART_SR) & UART_SR_RX_READY))\r\nreturn NO_POLL_CHAR;\r\nreturn msm_read(port, rf_reg) & 0xff;\r\n}\r\nstatic int msm_poll_get_char_dm(struct uart_port *port)\r\n{\r\nint c;\r\nstatic u32 slop;\r\nstatic int count;\r\nunsigned char *sp = (unsigned char *)&slop;\r\nif (count) {\r\nc = sp[sizeof(slop) - count];\r\ncount--;\r\n} else if (!(msm_read(port, UART_SR) & UART_SR_RX_READY)) {\r\ncount = msm_read(port, UARTDM_RXFS);\r\ncount = (count >> UARTDM_RXFS_BUF_SHIFT) & UARTDM_RXFS_BUF_MASK;\r\nif (count) {\r\nmsm_write(port, UART_CR_CMD_FORCE_STALE, UART_CR);\r\nslop = msm_read(port, UARTDM_RF);\r\nc = sp[0];\r\ncount--;\r\nmsm_write(port, UART_CR_CMD_RESET_STALE_INT, UART_CR);\r\nmsm_write(port, 0xFFFFFF, UARTDM_DMRX);\r\nmsm_write(port, UART_CR_CMD_STALE_EVENT_ENABLE,\r\nUART_CR);\r\n} else {\r\nc = NO_POLL_CHAR;\r\n}\r\n} else {\r\nslop = msm_read(port, UARTDM_RF);\r\nc = sp[0];\r\ncount = sizeof(slop) - 1;\r\n}\r\nreturn c;\r\n}\r\nstatic int msm_poll_get_char(struct uart_port *port)\r\n{\r\nu32 imr;\r\nint c;\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nimr = msm_read(port, UART_IMR);\r\nmsm_write(port, 0, UART_IMR);\r\nif (msm_port->is_uartdm)\r\nc = msm_poll_get_char_dm(port);\r\nelse\r\nc = msm_poll_get_char_single(port);\r\nmsm_write(port, imr, UART_IMR);\r\nreturn c;\r\n}\r\nstatic void msm_poll_put_char(struct uart_port *port, unsigned char c)\r\n{\r\nu32 imr;\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nimr = msm_read(port, UART_IMR);\r\nmsm_write(port, 0, UART_IMR);\r\nif (msm_port->is_uartdm)\r\nreset_dm_count(port, 1);\r\nwhile (!(msm_read(port, UART_SR) & UART_SR_TX_READY))\r\ncpu_relax();\r\nmsm_write(port, c, msm_port->is_uartdm ? UARTDM_TF : UART_TF);\r\nwhile (!(msm_read(port, UART_SR) & UART_SR_TX_READY))\r\ncpu_relax();\r\nmsm_write(port, imr, UART_IMR);\r\n}\r\nstatic inline struct uart_port *get_port_from_line(unsigned int line)\r\n{\r\nreturn &msm_uart_ports[line].uart;\r\n}\r\nstatic void __msm_console_write(struct uart_port *port, const char *s,\r\nunsigned int count, bool is_uartdm)\r\n{\r\nint i;\r\nint num_newlines = 0;\r\nbool replaced = false;\r\nvoid __iomem *tf;\r\nif (is_uartdm)\r\ntf = port->membase + UARTDM_TF;\r\nelse\r\ntf = port->membase + UART_TF;\r\nfor (i = 0; i < count; i++)\r\nif (s[i] == '\n')\r\nnum_newlines++;\r\ncount += num_newlines;\r\nspin_lock(&port->lock);\r\nif (is_uartdm)\r\nreset_dm_count(port, count);\r\ni = 0;\r\nwhile (i < count) {\r\nint j;\r\nunsigned int num_chars;\r\nchar buf[4] = { 0 };\r\nif (is_uartdm)\r\nnum_chars = min(count - i, (unsigned int)sizeof(buf));\r\nelse\r\nnum_chars = 1;\r\nfor (j = 0; j < num_chars; j++) {\r\nchar c = *s;\r\nif (c == '\n' && !replaced) {\r\nbuf[j] = '\r';\r\nj++;\r\nreplaced = true;\r\n}\r\nif (j < num_chars) {\r\nbuf[j] = c;\r\ns++;\r\nreplaced = false;\r\n}\r\n}\r\nwhile (!(msm_read(port, UART_SR) & UART_SR_TX_READY))\r\ncpu_relax();\r\niowrite32_rep(tf, buf, 1);\r\ni += num_chars;\r\n}\r\nspin_unlock(&port->lock);\r\n}\r\nstatic void msm_console_write(struct console *co, const char *s,\r\nunsigned int count)\r\n{\r\nstruct uart_port *port;\r\nstruct msm_port *msm_port;\r\nBUG_ON(co->index < 0 || co->index >= UART_NR);\r\nport = get_port_from_line(co->index);\r\nmsm_port = UART_TO_MSM(port);\r\n__msm_console_write(port, s, count, msm_port->is_uartdm);\r\n}\r\nstatic int __init msm_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_port *port;\r\nint baud = 115200;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (unlikely(co->index >= UART_NR || co->index < 0))\r\nreturn -ENXIO;\r\nport = get_port_from_line(co->index);\r\nif (unlikely(!port->membase))\r\nreturn -ENXIO;\r\nmsm_init_clock(port);\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\npr_info("msm_serial: console setup on port #%d\n", port->line);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic void\r\nmsm_serial_early_write(struct console *con, const char *s, unsigned n)\r\n{\r\nstruct earlycon_device *dev = con->data;\r\n__msm_console_write(&dev->port, s, n, false);\r\n}\r\nstatic int __init\r\nmsm_serial_early_console_setup(struct earlycon_device *device, const char *opt)\r\n{\r\nif (!device->port.membase)\r\nreturn -ENODEV;\r\ndevice->con->write = msm_serial_early_write;\r\nreturn 0;\r\n}\r\nstatic void\r\nmsm_serial_early_write_dm(struct console *con, const char *s, unsigned n)\r\n{\r\nstruct earlycon_device *dev = con->data;\r\n__msm_console_write(&dev->port, s, n, true);\r\n}\r\nstatic int __init\r\nmsm_serial_early_console_setup_dm(struct earlycon_device *device,\r\nconst char *opt)\r\n{\r\nif (!device->port.membase)\r\nreturn -ENODEV;\r\ndevice->con->write = msm_serial_early_write_dm;\r\nreturn 0;\r\n}\r\nstatic int msm_serial_probe(struct platform_device *pdev)\r\n{\r\nstruct msm_port *msm_port;\r\nstruct resource *resource;\r\nstruct uart_port *port;\r\nconst struct of_device_id *id;\r\nint irq, line;\r\nif (pdev->dev.of_node)\r\nline = of_alias_get_id(pdev->dev.of_node, "serial");\r\nelse\r\nline = pdev->id;\r\nif (line < 0)\r\nline = atomic_inc_return(&msm_uart_next_id) - 1;\r\nif (unlikely(line < 0 || line >= UART_NR))\r\nreturn -ENXIO;\r\ndev_info(&pdev->dev, "msm_serial: detected port #%d\n", line);\r\nport = get_port_from_line(line);\r\nport->dev = &pdev->dev;\r\nmsm_port = UART_TO_MSM(port);\r\nid = of_match_device(msm_uartdm_table, &pdev->dev);\r\nif (id)\r\nmsm_port->is_uartdm = (unsigned long)id->data;\r\nelse\r\nmsm_port->is_uartdm = 0;\r\nmsm_port->clk = devm_clk_get(&pdev->dev, "core");\r\nif (IS_ERR(msm_port->clk))\r\nreturn PTR_ERR(msm_port->clk);\r\nif (msm_port->is_uartdm) {\r\nmsm_port->pclk = devm_clk_get(&pdev->dev, "iface");\r\nif (IS_ERR(msm_port->pclk))\r\nreturn PTR_ERR(msm_port->pclk);\r\nclk_set_rate(msm_port->clk, 1843200);\r\n}\r\nport->uartclk = clk_get_rate(msm_port->clk);\r\ndev_info(&pdev->dev, "uartclk = %d\n", port->uartclk);\r\nresource = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (unlikely(!resource))\r\nreturn -ENXIO;\r\nport->mapbase = resource->start;\r\nirq = platform_get_irq(pdev, 0);\r\nif (unlikely(irq < 0))\r\nreturn -ENXIO;\r\nport->irq = irq;\r\nplatform_set_drvdata(pdev, port);\r\nreturn uart_add_one_port(&msm_uart_driver, port);\r\n}\r\nstatic int msm_serial_remove(struct platform_device *pdev)\r\n{\r\nstruct uart_port *port = platform_get_drvdata(pdev);\r\nuart_remove_one_port(&msm_uart_driver, port);\r\nreturn 0;\r\n}\r\nstatic int __init msm_serial_init(void)\r\n{\r\nint ret;\r\nret = uart_register_driver(&msm_uart_driver);\r\nif (unlikely(ret))\r\nreturn ret;\r\nret = platform_driver_register(&msm_platform_driver);\r\nif (unlikely(ret))\r\nuart_unregister_driver(&msm_uart_driver);\r\npr_info("msm_serial: driver initialized\n");\r\nreturn ret;\r\n}\r\nstatic void __exit msm_serial_exit(void)\r\n{\r\nplatform_driver_unregister(&msm_platform_driver);\r\nuart_unregister_driver(&msm_uart_driver);\r\n}
