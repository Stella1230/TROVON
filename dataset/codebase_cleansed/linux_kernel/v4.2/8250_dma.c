static void __dma_tx_complete(void *param)\r\n{\r\nstruct uart_8250_port *p = param;\r\nstruct uart_8250_dma *dma = p->dma;\r\nstruct circ_buf *xmit = &p->port.state->xmit;\r\nunsigned long flags;\r\nint ret;\r\ndma_sync_single_for_cpu(dma->txchan->device->dev, dma->tx_addr,\r\nUART_XMIT_SIZE, DMA_TO_DEVICE);\r\nspin_lock_irqsave(&p->port.lock, flags);\r\ndma->tx_running = 0;\r\nxmit->tail += dma->tx_size;\r\nxmit->tail &= UART_XMIT_SIZE - 1;\r\np->port.icount.tx += dma->tx_size;\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&p->port);\r\nret = serial8250_tx_dma(p);\r\nif (ret) {\r\np->ier |= UART_IER_THRI;\r\nserial_port_out(&p->port, UART_IER, p->ier);\r\n}\r\nspin_unlock_irqrestore(&p->port.lock, flags);\r\n}\r\nstatic void __dma_rx_complete(void *param)\r\n{\r\nstruct uart_8250_port *p = param;\r\nstruct uart_8250_dma *dma = p->dma;\r\nstruct tty_port *tty_port = &p->port.state->port;\r\nstruct dma_tx_state state;\r\nint count;\r\ndma_sync_single_for_cpu(dma->rxchan->device->dev, dma->rx_addr,\r\ndma->rx_size, DMA_FROM_DEVICE);\r\ndma->rx_running = 0;\r\ndmaengine_tx_status(dma->rxchan, dma->rx_cookie, &state);\r\ncount = dma->rx_size - state.residue;\r\ntty_insert_flip_string(tty_port, dma->rx_buf, count);\r\np->port.icount.rx += count;\r\ntty_flip_buffer_push(tty_port);\r\n}\r\nint serial8250_tx_dma(struct uart_8250_port *p)\r\n{\r\nstruct uart_8250_dma *dma = p->dma;\r\nstruct circ_buf *xmit = &p->port.state->xmit;\r\nstruct dma_async_tx_descriptor *desc;\r\nint ret;\r\nif (uart_tx_stopped(&p->port) || dma->tx_running ||\r\nuart_circ_empty(xmit))\r\nreturn 0;\r\ndma->tx_size = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);\r\nif (dma->tx_size < p->port.fifosize) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\ndesc = dmaengine_prep_slave_single(dma->txchan,\r\ndma->tx_addr + xmit->tail,\r\ndma->tx_size, DMA_MEM_TO_DEV,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc) {\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\ndma->tx_running = 1;\r\ndesc->callback = __dma_tx_complete;\r\ndesc->callback_param = p;\r\ndma->tx_cookie = dmaengine_submit(desc);\r\ndma_sync_single_for_device(dma->txchan->device->dev, dma->tx_addr,\r\nUART_XMIT_SIZE, DMA_TO_DEVICE);\r\ndma_async_issue_pending(dma->txchan);\r\nif (dma->tx_err) {\r\ndma->tx_err = 0;\r\nif (p->ier & UART_IER_THRI) {\r\np->ier &= ~UART_IER_THRI;\r\nserial_out(p, UART_IER, p->ier);\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\ndma->tx_err = 1;\r\nreturn ret;\r\n}\r\nint serial8250_rx_dma(struct uart_8250_port *p, unsigned int iir)\r\n{\r\nstruct uart_8250_dma *dma = p->dma;\r\nstruct dma_async_tx_descriptor *desc;\r\nswitch (iir & 0x3f) {\r\ncase UART_IIR_RLSI:\r\nreturn -EIO;\r\ncase UART_IIR_RX_TIMEOUT:\r\nif (dma->rx_running) {\r\ndmaengine_pause(dma->rxchan);\r\n__dma_rx_complete(p);\r\ndmaengine_terminate_all(dma->rxchan);\r\n}\r\nreturn -ETIMEDOUT;\r\ndefault:\r\nbreak;\r\n}\r\nif (dma->rx_running)\r\nreturn 0;\r\ndesc = dmaengine_prep_slave_single(dma->rxchan, dma->rx_addr,\r\ndma->rx_size, DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc)\r\nreturn -EBUSY;\r\ndma->rx_running = 1;\r\ndesc->callback = __dma_rx_complete;\r\ndesc->callback_param = p;\r\ndma->rx_cookie = dmaengine_submit(desc);\r\ndma_sync_single_for_device(dma->rxchan->device->dev, dma->rx_addr,\r\ndma->rx_size, DMA_FROM_DEVICE);\r\ndma_async_issue_pending(dma->rxchan);\r\nreturn 0;\r\n}\r\nint serial8250_request_dma(struct uart_8250_port *p)\r\n{\r\nstruct uart_8250_dma *dma = p->dma;\r\ndma_cap_mask_t mask;\r\ndma->rxconf.direction = DMA_DEV_TO_MEM;\r\ndma->rxconf.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\ndma->rxconf.src_addr = p->port.mapbase + UART_RX;\r\ndma->txconf.direction = DMA_MEM_TO_DEV;\r\ndma->txconf.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\ndma->txconf.dst_addr = p->port.mapbase + UART_TX;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\ndma->rxchan = dma_request_slave_channel_compat(mask,\r\ndma->fn, dma->rx_param,\r\np->port.dev, "rx");\r\nif (!dma->rxchan)\r\nreturn -ENODEV;\r\ndmaengine_slave_config(dma->rxchan, &dma->rxconf);\r\ndma->txchan = dma_request_slave_channel_compat(mask,\r\ndma->fn, dma->tx_param,\r\np->port.dev, "tx");\r\nif (!dma->txchan) {\r\ndma_release_channel(dma->rxchan);\r\nreturn -ENODEV;\r\n}\r\ndmaengine_slave_config(dma->txchan, &dma->txconf);\r\nif (!dma->rx_size)\r\ndma->rx_size = PAGE_SIZE;\r\ndma->rx_buf = dma_alloc_coherent(dma->rxchan->device->dev, dma->rx_size,\r\n&dma->rx_addr, GFP_KERNEL);\r\nif (!dma->rx_buf)\r\ngoto err;\r\ndma->tx_addr = dma_map_single(dma->txchan->device->dev,\r\np->port.state->xmit.buf,\r\nUART_XMIT_SIZE,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(dma->txchan->device->dev, dma->tx_addr)) {\r\ndma_free_coherent(dma->rxchan->device->dev, dma->rx_size,\r\ndma->rx_buf, dma->rx_addr);\r\ngoto err;\r\n}\r\ndev_dbg_ratelimited(p->port.dev, "got both dma channels\n");\r\nreturn 0;\r\nerr:\r\ndma_release_channel(dma->rxchan);\r\ndma_release_channel(dma->txchan);\r\nreturn -ENOMEM;\r\n}\r\nvoid serial8250_release_dma(struct uart_8250_port *p)\r\n{\r\nstruct uart_8250_dma *dma = p->dma;\r\nif (!dma)\r\nreturn;\r\ndmaengine_terminate_all(dma->rxchan);\r\ndma_free_coherent(dma->rxchan->device->dev, dma->rx_size, dma->rx_buf,\r\ndma->rx_addr);\r\ndma_release_channel(dma->rxchan);\r\ndma->rxchan = NULL;\r\ndmaengine_terminate_all(dma->txchan);\r\ndma_unmap_single(dma->txchan->device->dev, dma->tx_addr,\r\nUART_XMIT_SIZE, DMA_TO_DEVICE);\r\ndma_release_channel(dma->txchan);\r\ndma->txchan = NULL;\r\ndma->tx_running = 0;\r\ndev_dbg_ratelimited(p->port.dev, "dma channels released\n");\r\n}
