static inline void\r\nsuperio_outb(int ioreg, int reg, int val)\r\n{\r\noutb(reg, ioreg);\r\noutb(val, ioreg + 1);\r\n}\r\nstatic inline int\r\nsuperio_inb(int ioreg, int reg)\r\n{\r\noutb(reg, ioreg);\r\nreturn inb(ioreg + 1);\r\n}\r\nstatic inline void\r\nsuperio_select(int ioreg, int ld)\r\n{\r\noutb(SIO_REG_LDSEL, ioreg);\r\noutb(ld, ioreg + 1);\r\n}\r\nstatic inline int\r\nsuperio_enter(int ioreg)\r\n{\r\nif (!request_muxed_region(ioreg, 2, DRVNAME))\r\nreturn -EBUSY;\r\noutb(0x87, ioreg);\r\noutb(0x87, ioreg);\r\nreturn 0;\r\n}\r\nstatic inline void\r\nsuperio_exit(int ioreg)\r\n{\r\noutb(0xaa, ioreg);\r\noutb(0x02, ioreg);\r\noutb(0x02, ioreg + 1);\r\nrelease_region(ioreg, 2);\r\n}\r\nstatic enum pwm_enable reg_to_pwm_enable(int pwm, int mode)\r\n{\r\nif (mode == 0 && pwm == 255)\r\nreturn off;\r\nreturn mode + 1;\r\n}\r\nstatic int pwm_enable_to_reg(enum pwm_enable mode)\r\n{\r\nif (mode == off)\r\nreturn 0;\r\nreturn mode - 1;\r\n}\r\nstatic unsigned int step_time_from_reg(u8 reg, u8 mode)\r\n{\r\nreturn mode ? 400 * reg : 100 * reg;\r\n}\r\nstatic u8 step_time_to_reg(unsigned int msec, u8 mode)\r\n{\r\nreturn clamp_val((mode ? (msec + 200) / 400 :\r\n(msec + 50) / 100), 1, 255);\r\n}\r\nstatic unsigned int fan_from_reg8(u16 reg, unsigned int divreg)\r\n{\r\nif (reg == 0 || reg == 255)\r\nreturn 0;\r\nreturn 1350000U / (reg << divreg);\r\n}\r\nstatic unsigned int fan_from_reg13(u16 reg, unsigned int divreg)\r\n{\r\nif ((reg & 0xff1f) == 0xff1f)\r\nreturn 0;\r\nreg = (reg & 0x1f) | ((reg & 0xff00) >> 3);\r\nif (reg == 0)\r\nreturn 0;\r\nreturn 1350000U / reg;\r\n}\r\nstatic unsigned int fan_from_reg16(u16 reg, unsigned int divreg)\r\n{\r\nif (reg == 0 || reg == 0xffff)\r\nreturn 0;\r\nreturn 1350000U / (reg << divreg);\r\n}\r\nstatic u16 fan_to_reg(u32 fan, unsigned int divreg)\r\n{\r\nif (!fan)\r\nreturn 0;\r\nreturn (1350000U / fan) >> divreg;\r\n}\r\nstatic inline unsigned int\r\ndiv_from_reg(u8 reg)\r\n{\r\nreturn 1 << reg;\r\n}\r\nstatic inline long in_from_reg(u8 reg, u8 nr)\r\n{\r\nreturn DIV_ROUND_CLOSEST(reg * scale_in[nr], 100);\r\n}\r\nstatic inline u8 in_to_reg(u32 val, u8 nr)\r\n{\r\nreturn clamp_val(DIV_ROUND_CLOSEST(val * 100, scale_in[nr]), 0, 255);\r\n}\r\nstatic struct attribute_group *\r\nnct6775_create_attr_group(struct device *dev, struct sensor_template_group *tg,\r\nint repeat)\r\n{\r\nstruct attribute_group *group;\r\nstruct sensor_device_attr_u *su;\r\nstruct sensor_device_attribute *a;\r\nstruct sensor_device_attribute_2 *a2;\r\nstruct attribute **attrs;\r\nstruct sensor_device_template **t;\r\nint i, count;\r\nif (repeat <= 0)\r\nreturn ERR_PTR(-EINVAL);\r\nt = tg->templates;\r\nfor (count = 0; *t; t++, count++)\r\n;\r\nif (count == 0)\r\nreturn ERR_PTR(-EINVAL);\r\ngroup = devm_kzalloc(dev, sizeof(*group), GFP_KERNEL);\r\nif (group == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nattrs = devm_kzalloc(dev, sizeof(*attrs) * (repeat * count + 1),\r\nGFP_KERNEL);\r\nif (attrs == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nsu = devm_kzalloc(dev, sizeof(*su) * repeat * count,\r\nGFP_KERNEL);\r\nif (su == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\ngroup->attrs = attrs;\r\ngroup->is_visible = tg->is_visible;\r\nfor (i = 0; i < repeat; i++) {\r\nt = tg->templates;\r\nwhile (*t != NULL) {\r\nsnprintf(su->name, sizeof(su->name),\r\n(*t)->dev_attr.attr.name, tg->base + i);\r\nif ((*t)->s2) {\r\na2 = &su->u.a2;\r\nsysfs_attr_init(&a2->dev_attr.attr);\r\na2->dev_attr.attr.name = su->name;\r\na2->nr = (*t)->u.s.nr + i;\r\na2->index = (*t)->u.s.index;\r\na2->dev_attr.attr.mode =\r\n(*t)->dev_attr.attr.mode;\r\na2->dev_attr.show = (*t)->dev_attr.show;\r\na2->dev_attr.store = (*t)->dev_attr.store;\r\n*attrs = &a2->dev_attr.attr;\r\n} else {\r\na = &su->u.a1;\r\nsysfs_attr_init(&a->dev_attr.attr);\r\na->dev_attr.attr.name = su->name;\r\na->index = (*t)->u.index + i;\r\na->dev_attr.attr.mode =\r\n(*t)->dev_attr.attr.mode;\r\na->dev_attr.show = (*t)->dev_attr.show;\r\na->dev_attr.store = (*t)->dev_attr.store;\r\n*attrs = &a->dev_attr.attr;\r\n}\r\nattrs++;\r\nsu++;\r\nt++;\r\n}\r\n}\r\nreturn group;\r\n}\r\nstatic bool is_word_sized(struct nct6775_data *data, u16 reg)\r\n{\r\nswitch (data->kind) {\r\ncase nct6106:\r\nreturn reg == 0x20 || reg == 0x22 || reg == 0x24 ||\r\nreg == 0xe0 || reg == 0xe2 || reg == 0xe4 ||\r\nreg == 0x111 || reg == 0x121 || reg == 0x131;\r\ncase nct6775:\r\nreturn (((reg & 0xff00) == 0x100 ||\r\n(reg & 0xff00) == 0x200) &&\r\n((reg & 0x00ff) == 0x50 ||\r\n(reg & 0x00ff) == 0x53 ||\r\n(reg & 0x00ff) == 0x55)) ||\r\n(reg & 0xfff0) == 0x630 ||\r\nreg == 0x640 || reg == 0x642 ||\r\nreg == 0x662 ||\r\n((reg & 0xfff0) == 0x650 && (reg & 0x000f) >= 0x06) ||\r\nreg == 0x73 || reg == 0x75 || reg == 0x77;\r\ncase nct6776:\r\nreturn (((reg & 0xff00) == 0x100 ||\r\n(reg & 0xff00) == 0x200) &&\r\n((reg & 0x00ff) == 0x50 ||\r\n(reg & 0x00ff) == 0x53 ||\r\n(reg & 0x00ff) == 0x55)) ||\r\n(reg & 0xfff0) == 0x630 ||\r\nreg == 0x402 ||\r\nreg == 0x640 || reg == 0x642 ||\r\n((reg & 0xfff0) == 0x650 && (reg & 0x000f) >= 0x06) ||\r\nreg == 0x73 || reg == 0x75 || reg == 0x77;\r\ncase nct6779:\r\ncase nct6791:\r\ncase nct6792:\r\nreturn reg == 0x150 || reg == 0x153 || reg == 0x155 ||\r\n((reg & 0xfff0) == 0x4b0 && (reg & 0x000f) < 0x0b) ||\r\nreg == 0x402 ||\r\nreg == 0x63a || reg == 0x63c || reg == 0x63e ||\r\nreg == 0x640 || reg == 0x642 ||\r\nreg == 0x73 || reg == 0x75 || reg == 0x77 || reg == 0x79 ||\r\nreg == 0x7b || reg == 0x7d;\r\n}\r\nreturn false;\r\n}\r\nstatic inline void nct6775_set_bank(struct nct6775_data *data, u16 reg)\r\n{\r\nu8 bank = reg >> 8;\r\nif (data->bank != bank) {\r\noutb_p(NCT6775_REG_BANK, data->addr + ADDR_REG_OFFSET);\r\noutb_p(bank, data->addr + DATA_REG_OFFSET);\r\ndata->bank = bank;\r\n}\r\n}\r\nstatic u16 nct6775_read_value(struct nct6775_data *data, u16 reg)\r\n{\r\nint res, word_sized = is_word_sized(data, reg);\r\nnct6775_set_bank(data, reg);\r\noutb_p(reg & 0xff, data->addr + ADDR_REG_OFFSET);\r\nres = inb_p(data->addr + DATA_REG_OFFSET);\r\nif (word_sized) {\r\noutb_p((reg & 0xff) + 1,\r\ndata->addr + ADDR_REG_OFFSET);\r\nres = (res << 8) + inb_p(data->addr + DATA_REG_OFFSET);\r\n}\r\nreturn res;\r\n}\r\nstatic int nct6775_write_value(struct nct6775_data *data, u16 reg, u16 value)\r\n{\r\nint word_sized = is_word_sized(data, reg);\r\nnct6775_set_bank(data, reg);\r\noutb_p(reg & 0xff, data->addr + ADDR_REG_OFFSET);\r\nif (word_sized) {\r\noutb_p(value >> 8, data->addr + DATA_REG_OFFSET);\r\noutb_p((reg & 0xff) + 1,\r\ndata->addr + ADDR_REG_OFFSET);\r\n}\r\noutb_p(value & 0xff, data->addr + DATA_REG_OFFSET);\r\nreturn 0;\r\n}\r\nstatic u16 nct6775_read_temp(struct nct6775_data *data, u16 reg)\r\n{\r\nu16 res;\r\nres = nct6775_read_value(data, reg);\r\nif (!is_word_sized(data, reg))\r\nres <<= 8;\r\nreturn res;\r\n}\r\nstatic int nct6775_write_temp(struct nct6775_data *data, u16 reg, u16 value)\r\n{\r\nif (!is_word_sized(data, reg))\r\nvalue >>= 8;\r\nreturn nct6775_write_value(data, reg, value);\r\n}\r\nstatic void nct6775_write_fan_div(struct nct6775_data *data, int nr)\r\n{\r\nu8 reg;\r\nswitch (nr) {\r\ncase 0:\r\nreg = (nct6775_read_value(data, NCT6775_REG_FANDIV1) & 0x70)\r\n| (data->fan_div[0] & 0x7);\r\nnct6775_write_value(data, NCT6775_REG_FANDIV1, reg);\r\nbreak;\r\ncase 1:\r\nreg = (nct6775_read_value(data, NCT6775_REG_FANDIV1) & 0x7)\r\n| ((data->fan_div[1] << 4) & 0x70);\r\nnct6775_write_value(data, NCT6775_REG_FANDIV1, reg);\r\nbreak;\r\ncase 2:\r\nreg = (nct6775_read_value(data, NCT6775_REG_FANDIV2) & 0x70)\r\n| (data->fan_div[2] & 0x7);\r\nnct6775_write_value(data, NCT6775_REG_FANDIV2, reg);\r\nbreak;\r\ncase 3:\r\nreg = (nct6775_read_value(data, NCT6775_REG_FANDIV2) & 0x7)\r\n| ((data->fan_div[3] << 4) & 0x70);\r\nnct6775_write_value(data, NCT6775_REG_FANDIV2, reg);\r\nbreak;\r\n}\r\n}\r\nstatic void nct6775_write_fan_div_common(struct nct6775_data *data, int nr)\r\n{\r\nif (data->kind == nct6775)\r\nnct6775_write_fan_div(data, nr);\r\n}\r\nstatic void nct6775_update_fan_div(struct nct6775_data *data)\r\n{\r\nu8 i;\r\ni = nct6775_read_value(data, NCT6775_REG_FANDIV1);\r\ndata->fan_div[0] = i & 0x7;\r\ndata->fan_div[1] = (i & 0x70) >> 4;\r\ni = nct6775_read_value(data, NCT6775_REG_FANDIV2);\r\ndata->fan_div[2] = i & 0x7;\r\nif (data->has_fan & (1 << 3))\r\ndata->fan_div[3] = (i & 0x70) >> 4;\r\n}\r\nstatic void nct6775_update_fan_div_common(struct nct6775_data *data)\r\n{\r\nif (data->kind == nct6775)\r\nnct6775_update_fan_div(data);\r\n}\r\nstatic void nct6775_init_fan_div(struct nct6775_data *data)\r\n{\r\nint i;\r\nnct6775_update_fan_div_common(data);\r\nfor (i = 0; i < ARRAY_SIZE(data->fan_div); i++) {\r\nif (!(data->has_fan & (1 << i)))\r\ncontinue;\r\nif (data->fan_div[i] == 0) {\r\ndata->fan_div[i] = 7;\r\nnct6775_write_fan_div_common(data, i);\r\n}\r\n}\r\n}\r\nstatic void nct6775_init_fan_common(struct device *dev,\r\nstruct nct6775_data *data)\r\n{\r\nint i;\r\nu8 reg;\r\nif (data->has_fan_div)\r\nnct6775_init_fan_div(data);\r\nfor (i = 0; i < ARRAY_SIZE(data->fan_min); i++) {\r\nif (data->has_fan_min & (1 << i)) {\r\nreg = nct6775_read_value(data, data->REG_FAN_MIN[i]);\r\nif (!reg)\r\nnct6775_write_value(data, data->REG_FAN_MIN[i],\r\ndata->has_fan_div ? 0xff\r\n: 0xff1f);\r\n}\r\n}\r\n}\r\nstatic void nct6775_select_fan_div(struct device *dev,\r\nstruct nct6775_data *data, int nr, u16 reg)\r\n{\r\nu8 fan_div = data->fan_div[nr];\r\nu16 fan_min;\r\nif (!data->has_fan_div)\r\nreturn;\r\nif (reg == 0x00 && fan_div < 0x07)\r\nfan_div++;\r\nelse if (reg != 0x00 && reg < 0x30 && fan_div > 0)\r\nfan_div--;\r\nif (fan_div != data->fan_div[nr]) {\r\ndev_dbg(dev, "Modifying fan%d clock divider from %u to %u\n",\r\nnr + 1, div_from_reg(data->fan_div[nr]),\r\ndiv_from_reg(fan_div));\r\nif (data->has_fan_min & (1 << nr)) {\r\nfan_min = data->fan_min[nr];\r\nif (fan_div > data->fan_div[nr]) {\r\nif (fan_min != 255 && fan_min > 1)\r\nfan_min >>= 1;\r\n} else {\r\nif (fan_min != 255) {\r\nfan_min <<= 1;\r\nif (fan_min > 254)\r\nfan_min = 254;\r\n}\r\n}\r\nif (fan_min != data->fan_min[nr]) {\r\ndata->fan_min[nr] = fan_min;\r\nnct6775_write_value(data, data->REG_FAN_MIN[nr],\r\nfan_min);\r\n}\r\n}\r\ndata->fan_div[nr] = fan_div;\r\nnct6775_write_fan_div_common(data, nr);\r\n}\r\n}\r\nstatic void nct6775_update_pwm(struct device *dev)\r\n{\r\nstruct nct6775_data *data = dev_get_drvdata(dev);\r\nint i, j;\r\nint fanmodecfg, reg;\r\nbool duty_is_dc;\r\nfor (i = 0; i < data->pwm_num; i++) {\r\nif (!(data->has_pwm & (1 << i)))\r\ncontinue;\r\nduty_is_dc = data->REG_PWM_MODE[i] &&\r\n(nct6775_read_value(data, data->REG_PWM_MODE[i])\r\n& data->PWM_MODE_MASK[i]);\r\ndata->pwm_mode[i] = duty_is_dc;\r\nfanmodecfg = nct6775_read_value(data, data->REG_FAN_MODE[i]);\r\nfor (j = 0; j < ARRAY_SIZE(data->REG_PWM); j++) {\r\nif (data->REG_PWM[j] && data->REG_PWM[j][i]) {\r\ndata->pwm[j][i]\r\n= nct6775_read_value(data,\r\ndata->REG_PWM[j][i]);\r\n}\r\n}\r\ndata->pwm_enable[i] = reg_to_pwm_enable(data->pwm[0][i],\r\n(fanmodecfg >> 4) & 7);\r\nif (!data->temp_tolerance[0][i] ||\r\ndata->pwm_enable[i] != speed_cruise)\r\ndata->temp_tolerance[0][i] = fanmodecfg & 0x0f;\r\nif (!data->target_speed_tolerance[i] ||\r\ndata->pwm_enable[i] == speed_cruise) {\r\nu8 t = fanmodecfg & 0x0f;\r\nif (data->REG_TOLERANCE_H) {\r\nt |= (nct6775_read_value(data,\r\ndata->REG_TOLERANCE_H[i]) & 0x70) >> 1;\r\n}\r\ndata->target_speed_tolerance[i] = t;\r\n}\r\ndata->temp_tolerance[1][i] =\r\nnct6775_read_value(data,\r\ndata->REG_CRITICAL_TEMP_TOLERANCE[i]);\r\nreg = nct6775_read_value(data, data->REG_TEMP_SEL[i]);\r\ndata->pwm_temp_sel[i] = reg & 0x1f;\r\nif (reg & 0x80)\r\ndata->pwm[2][i] = 0;\r\nif (!data->REG_WEIGHT_TEMP_SEL[i])\r\ncontinue;\r\nreg = nct6775_read_value(data, data->REG_WEIGHT_TEMP_SEL[i]);\r\ndata->pwm_weight_temp_sel[i] = reg & 0x1f;\r\nif (j == 1 && !(reg & 0x80))\r\ndata->pwm_weight_temp_sel[i] = 0;\r\nfor (j = 0; j < ARRAY_SIZE(data->weight_temp); j++) {\r\ndata->weight_temp[j][i]\r\n= nct6775_read_value(data,\r\ndata->REG_WEIGHT_TEMP[j][i]);\r\n}\r\n}\r\n}\r\nstatic void nct6775_update_pwm_limits(struct device *dev)\r\n{\r\nstruct nct6775_data *data = dev_get_drvdata(dev);\r\nint i, j;\r\nu8 reg;\r\nu16 reg_t;\r\nfor (i = 0; i < data->pwm_num; i++) {\r\nif (!(data->has_pwm & (1 << i)))\r\ncontinue;\r\nfor (j = 0; j < ARRAY_SIZE(data->fan_time); j++) {\r\ndata->fan_time[j][i] =\r\nnct6775_read_value(data, data->REG_FAN_TIME[j][i]);\r\n}\r\nreg_t = nct6775_read_value(data, data->REG_TARGET[i]);\r\nif (!data->target_temp[i] ||\r\ndata->pwm_enable[i] == thermal_cruise)\r\ndata->target_temp[i] = reg_t & data->target_temp_mask;\r\nif (!data->target_speed[i] ||\r\ndata->pwm_enable[i] == speed_cruise) {\r\nif (data->REG_TOLERANCE_H) {\r\nreg_t |= (nct6775_read_value(data,\r\ndata->REG_TOLERANCE_H[i]) & 0x0f) << 8;\r\n}\r\ndata->target_speed[i] = reg_t;\r\n}\r\nfor (j = 0; j < data->auto_pwm_num; j++) {\r\ndata->auto_pwm[i][j] =\r\nnct6775_read_value(data,\r\nNCT6775_AUTO_PWM(data, i, j));\r\ndata->auto_temp[i][j] =\r\nnct6775_read_value(data,\r\nNCT6775_AUTO_TEMP(data, i, j));\r\n}\r\ndata->auto_temp[i][data->auto_pwm_num] =\r\nnct6775_read_value(data, data->REG_CRITICAL_TEMP[i]);\r\nswitch (data->kind) {\r\ncase nct6775:\r\nreg = nct6775_read_value(data,\r\nNCT6775_REG_CRITICAL_ENAB[i]);\r\ndata->auto_pwm[i][data->auto_pwm_num] =\r\n(reg & 0x02) ? 0xff : 0x00;\r\nbreak;\r\ncase nct6776:\r\ndata->auto_pwm[i][data->auto_pwm_num] = 0xff;\r\nbreak;\r\ncase nct6106:\r\ncase nct6779:\r\ncase nct6791:\r\ncase nct6792:\r\nreg = nct6775_read_value(data,\r\ndata->REG_CRITICAL_PWM_ENABLE[i]);\r\nif (reg & data->CRITICAL_PWM_ENABLE_MASK)\r\nreg = nct6775_read_value(data,\r\ndata->REG_CRITICAL_PWM[i]);\r\nelse\r\nreg = 0xff;\r\ndata->auto_pwm[i][data->auto_pwm_num] = reg;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic struct nct6775_data *nct6775_update_device(struct device *dev)\r\n{\r\nstruct nct6775_data *data = dev_get_drvdata(dev);\r\nint i, j;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + HZ + HZ / 2)\r\n|| !data->valid) {\r\nnct6775_update_fan_div_common(data);\r\nfor (i = 0; i < data->in_num; i++) {\r\nif (!(data->have_in & (1 << i)))\r\ncontinue;\r\ndata->in[i][0] = nct6775_read_value(data,\r\ndata->REG_VIN[i]);\r\ndata->in[i][1] = nct6775_read_value(data,\r\ndata->REG_IN_MINMAX[0][i]);\r\ndata->in[i][2] = nct6775_read_value(data,\r\ndata->REG_IN_MINMAX[1][i]);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(data->rpm); i++) {\r\nu16 reg;\r\nif (!(data->has_fan & (1 << i)))\r\ncontinue;\r\nreg = nct6775_read_value(data, data->REG_FAN[i]);\r\ndata->rpm[i] = data->fan_from_reg(reg,\r\ndata->fan_div[i]);\r\nif (data->has_fan_min & (1 << i))\r\ndata->fan_min[i] = nct6775_read_value(data,\r\ndata->REG_FAN_MIN[i]);\r\ndata->fan_pulses[i] =\r\n(nct6775_read_value(data, data->REG_FAN_PULSES[i])\r\n>> data->FAN_PULSE_SHIFT[i]) & 0x03;\r\nnct6775_select_fan_div(dev, data, i, reg);\r\n}\r\nnct6775_update_pwm(dev);\r\nnct6775_update_pwm_limits(dev);\r\nfor (i = 0; i < NUM_TEMP; i++) {\r\nif (!(data->have_temp & (1 << i)))\r\ncontinue;\r\nfor (j = 0; j < ARRAY_SIZE(data->reg_temp); j++) {\r\nif (data->reg_temp[j][i])\r\ndata->temp[j][i]\r\n= nct6775_read_temp(data,\r\ndata->reg_temp[j][i]);\r\n}\r\nif (i >= NUM_TEMP_FIXED ||\r\n!(data->have_temp_fixed & (1 << i)))\r\ncontinue;\r\ndata->temp_offset[i]\r\n= nct6775_read_value(data, data->REG_TEMP_OFFSET[i]);\r\n}\r\ndata->alarms = 0;\r\nfor (i = 0; i < NUM_REG_ALARM; i++) {\r\nu8 alarm;\r\nif (!data->REG_ALARM[i])\r\ncontinue;\r\nalarm = nct6775_read_value(data, data->REG_ALARM[i]);\r\ndata->alarms |= ((u64)alarm) << (i << 3);\r\n}\r\ndata->beeps = 0;\r\nfor (i = 0; i < NUM_REG_BEEP; i++) {\r\nu8 beep;\r\nif (!data->REG_BEEP[i])\r\ncontinue;\r\nbeep = nct6775_read_value(data, data->REG_BEEP[i]);\r\ndata->beeps |= ((u64)beep) << (i << 3);\r\n}\r\ndata->last_updated = jiffies;\r\ndata->valid = true;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic ssize_t\r\nshow_in_reg(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct nct6775_data *data = nct6775_update_device(dev);\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nint index = sattr->index;\r\nint nr = sattr->nr;\r\nreturn sprintf(buf, "%ld\n", in_from_reg(data->in[nr][index], nr));\r\n}\r\nstatic ssize_t\r\nstore_in_reg(struct device *dev, struct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct nct6775_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nint index = sattr->index;\r\nint nr = sattr->nr;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->in[nr][index] = in_to_reg(val, nr);\r\nnct6775_write_value(data, data->REG_IN_MINMAX[index - 1][nr],\r\ndata->in[nr][index]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_alarm(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct nct6775_data *data = nct6775_update_device(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nint nr = data->ALARM_BITS[sattr->index];\r\nreturn sprintf(buf, "%u\n",\r\n(unsigned int)((data->alarms >> nr) & 0x01));\r\n}\r\nstatic int find_temp_source(struct nct6775_data *data, int index, int count)\r\n{\r\nint source = data->temp_src[index];\r\nint nr;\r\nfor (nr = 0; nr < count; nr++) {\r\nint src;\r\nsrc = nct6775_read_value(data,\r\ndata->REG_TEMP_SOURCE[nr]) & 0x1f;\r\nif (src == source)\r\nreturn nr;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic ssize_t\r\nshow_temp_alarm(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nstruct nct6775_data *data = nct6775_update_device(dev);\r\nunsigned int alarm = 0;\r\nint nr;\r\nnr = find_temp_source(data, sattr->index, data->num_temp_alarms);\r\nif (nr >= 0) {\r\nint bit = data->ALARM_BITS[nr + TEMP_ALARM_BASE];\r\nalarm = (data->alarms >> bit) & 0x01;\r\n}\r\nreturn sprintf(buf, "%u\n", alarm);\r\n}\r\nstatic ssize_t\r\nshow_beep(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nstruct nct6775_data *data = nct6775_update_device(dev);\r\nint nr = data->BEEP_BITS[sattr->index];\r\nreturn sprintf(buf, "%u\n",\r\n(unsigned int)((data->beeps >> nr) & 0x01));\r\n}\r\nstatic ssize_t\r\nstore_beep(struct device *dev, struct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nstruct nct6775_data *data = dev_get_drvdata(dev);\r\nint nr = data->BEEP_BITS[sattr->index];\r\nint regindex = nr >> 3;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nif (val > 1)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nif (val)\r\ndata->beeps |= (1ULL << nr);\r\nelse\r\ndata->beeps &= ~(1ULL << nr);\r\nnct6775_write_value(data, data->REG_BEEP[regindex],\r\n(data->beeps >> (regindex << 3)) & 0xff);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_temp_beep(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nstruct nct6775_data *data = nct6775_update_device(dev);\r\nunsigned int beep = 0;\r\nint nr;\r\nnr = find_temp_source(data, sattr->index, data->num_temp_beeps);\r\nif (nr >= 0) {\r\nint bit = data->BEEP_BITS[nr + TEMP_ALARM_BASE];\r\nbeep = (data->beeps >> bit) & 0x01;\r\n}\r\nreturn sprintf(buf, "%u\n", beep);\r\n}\r\nstatic ssize_t\r\nstore_temp_beep(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nstruct nct6775_data *data = dev_get_drvdata(dev);\r\nint nr, bit, regindex;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nif (val > 1)\r\nreturn -EINVAL;\r\nnr = find_temp_source(data, sattr->index, data->num_temp_beeps);\r\nif (nr < 0)\r\nreturn nr;\r\nbit = data->BEEP_BITS[nr + TEMP_ALARM_BASE];\r\nregindex = bit >> 3;\r\nmutex_lock(&data->update_lock);\r\nif (val)\r\ndata->beeps |= (1ULL << bit);\r\nelse\r\ndata->beeps &= ~(1ULL << bit);\r\nnct6775_write_value(data, data->REG_BEEP[regindex],\r\n(data->beeps >> (regindex << 3)) & 0xff);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic umode_t nct6775_in_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int index)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct nct6775_data *data = dev_get_drvdata(dev);\r\nint in = index / 5;\r\nif (!(data->have_in & (1 << in)))\r\nreturn 0;\r\nreturn attr->mode;\r\n}\r\nstatic ssize_t\r\nshow_fan(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct nct6775_data *data = nct6775_update_device(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nint nr = sattr->index;\r\nreturn sprintf(buf, "%d\n", data->rpm[nr]);\r\n}\r\nstatic ssize_t\r\nshow_fan_min(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct nct6775_data *data = nct6775_update_device(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nint nr = sattr->index;\r\nreturn sprintf(buf, "%d\n",\r\ndata->fan_from_reg_min(data->fan_min[nr],\r\ndata->fan_div[nr]));\r\n}\r\nstatic ssize_t\r\nshow_fan_div(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct nct6775_data *data = nct6775_update_device(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nint nr = sattr->index;\r\nreturn sprintf(buf, "%u\n", div_from_reg(data->fan_div[nr]));\r\n}\r\nstatic ssize_t\r\nstore_fan_min(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct nct6775_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nint nr = sattr->index;\r\nunsigned long val;\r\nunsigned int reg;\r\nu8 new_div;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nif (!data->has_fan_div) {\r\nif (!val) {\r\nval = 0xff1f;\r\n} else {\r\nif (val > 1350000U)\r\nval = 135000U;\r\nval = 1350000U / val;\r\nval = (val & 0x1f) | ((val << 3) & 0xff00);\r\n}\r\ndata->fan_min[nr] = val;\r\ngoto write_min;\r\n}\r\nif (!val) {\r\ndata->fan_min[nr] = 255;\r\nnew_div = data->fan_div[nr];\r\ndev_info(dev, "fan%u low limit and alarm disabled\n", nr + 1);\r\ngoto write_div;\r\n}\r\nreg = 1350000U / val;\r\nif (reg >= 128 * 255) {\r\ndata->fan_min[nr] = 254;\r\nnew_div = 7;\r\ndev_warn(dev,\r\n"fan%u low limit %lu below minimum %u, set to minimum\n",\r\nnr + 1, val, data->fan_from_reg_min(254, 7));\r\n} else if (!reg) {\r\ndata->fan_min[nr] = 1;\r\nnew_div = 0;\r\ndev_warn(dev,\r\n"fan%u low limit %lu above maximum %u, set to maximum\n",\r\nnr + 1, val, data->fan_from_reg_min(1, 0));\r\n} else {\r\nnew_div = 0;\r\nwhile (reg > 192 && new_div < 7) {\r\nreg >>= 1;\r\nnew_div++;\r\n}\r\ndata->fan_min[nr] = reg;\r\n}\r\nwrite_div:\r\nif (new_div != data->fan_div[nr]) {\r\ndev_dbg(dev, "fan%u clock divider changed from %u to %u\n",\r\nnr + 1, div_from_reg(data->fan_div[nr]),\r\ndiv_from_reg(new_div));\r\ndata->fan_div[nr] = new_div;\r\nnct6775_write_fan_div_common(data, nr);\r\ndata->last_updated = jiffies;\r\n}\r\nwrite_min:\r\nnct6775_write_value(data, data->REG_FAN_MIN[nr], data->fan_min[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_fan_pulses(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct nct6775_data *data = nct6775_update_device(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nint p = data->fan_pulses[sattr->index];\r\nreturn sprintf(buf, "%d\n", p ? : 4);\r\n}\r\nstatic ssize_t\r\nstore_fan_pulses(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct nct6775_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nint nr = sattr->index;\r\nunsigned long val;\r\nint err;\r\nu8 reg;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nif (val > 4)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->fan_pulses[nr] = val & 3;\r\nreg = nct6775_read_value(data, data->REG_FAN_PULSES[nr]);\r\nreg &= ~(0x03 << data->FAN_PULSE_SHIFT[nr]);\r\nreg |= (val & 3) << data->FAN_PULSE_SHIFT[nr];\r\nnct6775_write_value(data, data->REG_FAN_PULSES[nr], reg);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic umode_t nct6775_fan_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int index)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct nct6775_data *data = dev_get_drvdata(dev);\r\nint fan = index / 6;\r\nint nr = index % 6;\r\nif (!(data->has_fan & (1 << fan)))\r\nreturn 0;\r\nif (nr == 1 && data->ALARM_BITS[FAN_ALARM_BASE + fan] == -1)\r\nreturn 0;\r\nif (nr == 2 && data->BEEP_BITS[FAN_ALARM_BASE + fan] == -1)\r\nreturn 0;\r\nif (nr == 4 && !(data->has_fan_min & (1 << fan)))\r\nreturn 0;\r\nif (nr == 5 && data->kind != nct6775)\r\nreturn 0;\r\nreturn attr->mode;\r\n}\r\nstatic ssize_t\r\nshow_temp_label(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct nct6775_data *data = nct6775_update_device(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nint nr = sattr->index;\r\nreturn sprintf(buf, "%s\n", data->temp_label[data->temp_src[nr]]);\r\n}\r\nstatic ssize_t\r\nshow_temp(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct nct6775_data *data = nct6775_update_device(dev);\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nint nr = sattr->nr;\r\nint index = sattr->index;\r\nreturn sprintf(buf, "%d\n", LM75_TEMP_FROM_REG(data->temp[index][nr]));\r\n}\r\nstatic ssize_t\r\nstore_temp(struct device *dev, struct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct nct6775_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nint nr = sattr->nr;\r\nint index = sattr->index;\r\nint err;\r\nlong val;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->temp[index][nr] = LM75_TEMP_TO_REG(val);\r\nnct6775_write_temp(data, data->reg_temp[index][nr],\r\ndata->temp[index][nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_temp_offset(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct nct6775_data *data = nct6775_update_device(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nreturn sprintf(buf, "%d\n", data->temp_offset[sattr->index] * 1000);\r\n}\r\nstatic ssize_t\r\nstore_temp_offset(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct nct6775_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nint nr = sattr->index;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nval = clamp_val(DIV_ROUND_CLOSEST(val, 1000), -128, 127);\r\nmutex_lock(&data->update_lock);\r\ndata->temp_offset[nr] = val;\r\nnct6775_write_value(data, data->REG_TEMP_OFFSET[nr], val);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_temp_type(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct nct6775_data *data = nct6775_update_device(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nint nr = sattr->index;\r\nreturn sprintf(buf, "%d\n", (int)data->temp_type[nr]);\r\n}\r\nstatic ssize_t\r\nstore_temp_type(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct nct6775_data *data = nct6775_update_device(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nint nr = sattr->index;\r\nunsigned long val;\r\nint err;\r\nu8 vbat, diode, vbit, dbit;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nif (val != 1 && val != 3 && val != 4)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->temp_type[nr] = val;\r\nvbit = 0x02 << nr;\r\ndbit = data->DIODE_MASK << nr;\r\nvbat = nct6775_read_value(data, data->REG_VBAT) & ~vbit;\r\ndiode = nct6775_read_value(data, data->REG_DIODE) & ~dbit;\r\nswitch (val) {\r\ncase 1:\r\nvbat |= vbit;\r\ndiode |= dbit;\r\nbreak;\r\ncase 3:\r\nvbat |= dbit;\r\nbreak;\r\ncase 4:\r\nbreak;\r\n}\r\nnct6775_write_value(data, data->REG_VBAT, vbat);\r\nnct6775_write_value(data, data->REG_DIODE, diode);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic umode_t nct6775_temp_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int index)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct nct6775_data *data = dev_get_drvdata(dev);\r\nint temp = index / 10;\r\nint nr = index % 10;\r\nif (!(data->have_temp & (1 << temp)))\r\nreturn 0;\r\nif (nr == 2 && find_temp_source(data, temp, data->num_temp_alarms) < 0)\r\nreturn 0;\r\nif (nr == 3 && find_temp_source(data, temp, data->num_temp_beeps) < 0)\r\nreturn 0;\r\nif (nr == 4 && !data->reg_temp[1][temp])\r\nreturn 0;\r\nif (nr == 5 && !data->reg_temp[2][temp])\r\nreturn 0;\r\nif (nr == 6 && !data->reg_temp[3][temp])\r\nreturn 0;\r\nif (nr == 7 && !data->reg_temp[4][temp])\r\nreturn 0;\r\nif (nr > 7 && !(data->have_temp_fixed & (1 << temp)))\r\nreturn 0;\r\nreturn attr->mode;\r\n}\r\nstatic ssize_t\r\nshow_pwm_mode(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct nct6775_data *data = nct6775_update_device(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nreturn sprintf(buf, "%d\n", !data->pwm_mode[sattr->index]);\r\n}\r\nstatic ssize_t\r\nstore_pwm_mode(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct nct6775_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nint nr = sattr->index;\r\nunsigned long val;\r\nint err;\r\nu8 reg;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nif (val > 1)\r\nreturn -EINVAL;\r\nif (data->REG_PWM_MODE[nr] == 0) {\r\nif (val)\r\nreturn -EINVAL;\r\nreturn count;\r\n}\r\nmutex_lock(&data->update_lock);\r\ndata->pwm_mode[nr] = val;\r\nreg = nct6775_read_value(data, data->REG_PWM_MODE[nr]);\r\nreg &= ~data->PWM_MODE_MASK[nr];\r\nif (val)\r\nreg |= data->PWM_MODE_MASK[nr];\r\nnct6775_write_value(data, data->REG_PWM_MODE[nr], reg);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_pwm(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct nct6775_data *data = nct6775_update_device(dev);\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nint nr = sattr->nr;\r\nint index = sattr->index;\r\nint pwm;\r\nif (index == 0 && data->pwm_enable[nr] > manual)\r\npwm = nct6775_read_value(data, data->REG_PWM_READ[nr]);\r\nelse\r\npwm = data->pwm[index][nr];\r\nreturn sprintf(buf, "%d\n", pwm);\r\n}\r\nstatic ssize_t\r\nstore_pwm(struct device *dev, struct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct nct6775_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nint nr = sattr->nr;\r\nint index = sattr->index;\r\nunsigned long val;\r\nint minval[7] = { 0, 1, 1, data->pwm[2][nr], 0, 0, 0 };\r\nint maxval[7]\r\n= { 255, 255, data->pwm[3][nr] ? : 255, 255, 255, 255, 255 };\r\nint err;\r\nu8 reg;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nval = clamp_val(val, minval[index], maxval[index]);\r\nmutex_lock(&data->update_lock);\r\ndata->pwm[index][nr] = val;\r\nnct6775_write_value(data, data->REG_PWM[index][nr], val);\r\nif (index == 2) {\r\nreg = nct6775_read_value(data, data->REG_TEMP_SEL[nr]);\r\nreg &= 0x7f;\r\nif (val)\r\nreg |= 0x80;\r\nnct6775_write_value(data, data->REG_TEMP_SEL[nr], reg);\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic int check_trip_points(struct nct6775_data *data, int nr)\r\n{\r\nint i;\r\nfor (i = 0; i < data->auto_pwm_num - 1; i++) {\r\nif (data->auto_temp[nr][i] > data->auto_temp[nr][i + 1])\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < data->auto_pwm_num - 1; i++) {\r\nif (data->auto_pwm[nr][i] > data->auto_pwm[nr][i + 1])\r\nreturn -EINVAL;\r\n}\r\nif (data->auto_pwm[nr][data->auto_pwm_num]) {\r\nif (data->auto_temp[nr][data->auto_pwm_num - 1] >\r\ndata->auto_temp[nr][data->auto_pwm_num] ||\r\ndata->auto_pwm[nr][data->auto_pwm_num - 1] >\r\ndata->auto_pwm[nr][data->auto_pwm_num])\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pwm_update_registers(struct nct6775_data *data, int nr)\r\n{\r\nu8 reg;\r\nswitch (data->pwm_enable[nr]) {\r\ncase off:\r\ncase manual:\r\nbreak;\r\ncase speed_cruise:\r\nreg = nct6775_read_value(data, data->REG_FAN_MODE[nr]);\r\nreg = (reg & ~data->tolerance_mask) |\r\n(data->target_speed_tolerance[nr] & data->tolerance_mask);\r\nnct6775_write_value(data, data->REG_FAN_MODE[nr], reg);\r\nnct6775_write_value(data, data->REG_TARGET[nr],\r\ndata->target_speed[nr] & 0xff);\r\nif (data->REG_TOLERANCE_H) {\r\nreg = (data->target_speed[nr] >> 8) & 0x0f;\r\nreg |= (data->target_speed_tolerance[nr] & 0x38) << 1;\r\nnct6775_write_value(data,\r\ndata->REG_TOLERANCE_H[nr],\r\nreg);\r\n}\r\nbreak;\r\ncase thermal_cruise:\r\nnct6775_write_value(data, data->REG_TARGET[nr],\r\ndata->target_temp[nr]);\r\ndefault:\r\nreg = nct6775_read_value(data, data->REG_FAN_MODE[nr]);\r\nreg = (reg & ~data->tolerance_mask) |\r\ndata->temp_tolerance[0][nr];\r\nnct6775_write_value(data, data->REG_FAN_MODE[nr], reg);\r\nbreak;\r\n}\r\n}\r\nstatic ssize_t\r\nshow_pwm_enable(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct nct6775_data *data = nct6775_update_device(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nreturn sprintf(buf, "%d\n", data->pwm_enable[sattr->index]);\r\n}\r\nstatic ssize_t\r\nstore_pwm_enable(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct nct6775_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nint nr = sattr->index;\r\nunsigned long val;\r\nint err;\r\nu16 reg;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nif (val > sf4)\r\nreturn -EINVAL;\r\nif (val == sf3 && data->kind != nct6775)\r\nreturn -EINVAL;\r\nif (val == sf4 && check_trip_points(data, nr)) {\r\ndev_err(dev, "Inconsistent trip points, not switching to SmartFan IV mode\n");\r\ndev_err(dev, "Adjust trip points and try again\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&data->update_lock);\r\ndata->pwm_enable[nr] = val;\r\nif (val == off) {\r\ndata->pwm[0][nr] = 255;\r\nnct6775_write_value(data, data->REG_PWM[0][nr], 255);\r\n}\r\npwm_update_registers(data, nr);\r\nreg = nct6775_read_value(data, data->REG_FAN_MODE[nr]);\r\nreg &= 0x0f;\r\nreg |= pwm_enable_to_reg(val) << 4;\r\nnct6775_write_value(data, data->REG_FAN_MODE[nr], reg);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_pwm_temp_sel_common(struct nct6775_data *data, char *buf, int src)\r\n{\r\nint i, sel = 0;\r\nfor (i = 0; i < NUM_TEMP; i++) {\r\nif (!(data->have_temp & (1 << i)))\r\ncontinue;\r\nif (src == data->temp_src[i]) {\r\nsel = i + 1;\r\nbreak;\r\n}\r\n}\r\nreturn sprintf(buf, "%d\n", sel);\r\n}\r\nstatic ssize_t\r\nshow_pwm_temp_sel(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct nct6775_data *data = nct6775_update_device(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nint index = sattr->index;\r\nreturn show_pwm_temp_sel_common(data, buf, data->pwm_temp_sel[index]);\r\n}\r\nstatic ssize_t\r\nstore_pwm_temp_sel(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct nct6775_data *data = nct6775_update_device(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nint nr = sattr->index;\r\nunsigned long val;\r\nint err, reg, src;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nif (val == 0 || val > NUM_TEMP)\r\nreturn -EINVAL;\r\nif (!(data->have_temp & (1 << (val - 1))) || !data->temp_src[val - 1])\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nsrc = data->temp_src[val - 1];\r\ndata->pwm_temp_sel[nr] = src;\r\nreg = nct6775_read_value(data, data->REG_TEMP_SEL[nr]);\r\nreg &= 0xe0;\r\nreg |= src;\r\nnct6775_write_value(data, data->REG_TEMP_SEL[nr], reg);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_pwm_weight_temp_sel(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct nct6775_data *data = nct6775_update_device(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nint index = sattr->index;\r\nreturn show_pwm_temp_sel_common(data, buf,\r\ndata->pwm_weight_temp_sel[index]);\r\n}\r\nstatic ssize_t\r\nstore_pwm_weight_temp_sel(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct nct6775_data *data = nct6775_update_device(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nint nr = sattr->index;\r\nunsigned long val;\r\nint err, reg, src;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nif (val > NUM_TEMP)\r\nreturn -EINVAL;\r\nif (val && (!(data->have_temp & (1 << (val - 1))) ||\r\n!data->temp_src[val - 1]))\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nif (val) {\r\nsrc = data->temp_src[val - 1];\r\ndata->pwm_weight_temp_sel[nr] = src;\r\nreg = nct6775_read_value(data, data->REG_WEIGHT_TEMP_SEL[nr]);\r\nreg &= 0xe0;\r\nreg |= (src | 0x80);\r\nnct6775_write_value(data, data->REG_WEIGHT_TEMP_SEL[nr], reg);\r\n} else {\r\ndata->pwm_weight_temp_sel[nr] = 0;\r\nreg = nct6775_read_value(data, data->REG_WEIGHT_TEMP_SEL[nr]);\r\nreg &= 0x7f;\r\nnct6775_write_value(data, data->REG_WEIGHT_TEMP_SEL[nr], reg);\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_target_temp(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct nct6775_data *data = nct6775_update_device(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nreturn sprintf(buf, "%d\n", data->target_temp[sattr->index] * 1000);\r\n}\r\nstatic ssize_t\r\nstore_target_temp(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct nct6775_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nint nr = sattr->index;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nval = clamp_val(DIV_ROUND_CLOSEST(val, 1000), 0,\r\ndata->target_temp_mask);\r\nmutex_lock(&data->update_lock);\r\ndata->target_temp[nr] = val;\r\npwm_update_registers(data, nr);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_target_speed(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct nct6775_data *data = nct6775_update_device(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nint nr = sattr->index;\r\nreturn sprintf(buf, "%d\n",\r\nfan_from_reg16(data->target_speed[nr],\r\ndata->fan_div[nr]));\r\n}\r\nstatic ssize_t\r\nstore_target_speed(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct nct6775_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nint nr = sattr->index;\r\nunsigned long val;\r\nint err;\r\nu16 speed;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nval = clamp_val(val, 0, 1350000U);\r\nspeed = fan_to_reg(val, data->fan_div[nr]);\r\nmutex_lock(&data->update_lock);\r\ndata->target_speed[nr] = speed;\r\npwm_update_registers(data, nr);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_temp_tolerance(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct nct6775_data *data = nct6775_update_device(dev);\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nint nr = sattr->nr;\r\nint index = sattr->index;\r\nreturn sprintf(buf, "%d\n", data->temp_tolerance[index][nr] * 1000);\r\n}\r\nstatic ssize_t\r\nstore_temp_tolerance(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct nct6775_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nint nr = sattr->nr;\r\nint index = sattr->index;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nval = clamp_val(DIV_ROUND_CLOSEST(val, 1000), 0, data->tolerance_mask);\r\nmutex_lock(&data->update_lock);\r\ndata->temp_tolerance[index][nr] = val;\r\nif (index)\r\npwm_update_registers(data, nr);\r\nelse\r\nnct6775_write_value(data,\r\ndata->REG_CRITICAL_TEMP_TOLERANCE[nr],\r\nval);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_speed_tolerance(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct nct6775_data *data = nct6775_update_device(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nint nr = sattr->index;\r\nint low = data->target_speed[nr] - data->target_speed_tolerance[nr];\r\nint high = data->target_speed[nr] + data->target_speed_tolerance[nr];\r\nint tolerance;\r\nif (low <= 0)\r\nlow = 1;\r\nif (high > 0xffff)\r\nhigh = 0xffff;\r\nif (high < low)\r\nhigh = low;\r\ntolerance = (fan_from_reg16(low, data->fan_div[nr])\r\n- fan_from_reg16(high, data->fan_div[nr])) / 2;\r\nreturn sprintf(buf, "%d\n", tolerance);\r\n}\r\nstatic ssize_t\r\nstore_speed_tolerance(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct nct6775_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);\r\nint nr = sattr->index;\r\nunsigned long val;\r\nint err;\r\nint low, high;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nhigh = fan_from_reg16(data->target_speed[nr],\r\ndata->fan_div[nr]) + val;\r\nlow = fan_from_reg16(data->target_speed[nr],\r\ndata->fan_div[nr]) - val;\r\nif (low <= 0)\r\nlow = 1;\r\nif (high < low)\r\nhigh = low;\r\nval = (fan_to_reg(low, data->fan_div[nr]) -\r\nfan_to_reg(high, data->fan_div[nr])) / 2;\r\nval = clamp_val(val, 0, data->speed_tolerance_limit);\r\nmutex_lock(&data->update_lock);\r\ndata->target_speed_tolerance[nr] = val;\r\npwm_update_registers(data, nr);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_weight_temp(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct nct6775_data *data = nct6775_update_device(dev);\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nint nr = sattr->nr;\r\nint index = sattr->index;\r\nreturn sprintf(buf, "%d\n", data->weight_temp[index][nr] * 1000);\r\n}\r\nstatic ssize_t\r\nstore_weight_temp(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct nct6775_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nint nr = sattr->nr;\r\nint index = sattr->index;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nval = clamp_val(DIV_ROUND_CLOSEST(val, 1000), 0, 255);\r\nmutex_lock(&data->update_lock);\r\ndata->weight_temp[index][nr] = val;\r\nnct6775_write_value(data, data->REG_WEIGHT_TEMP[index][nr], val);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_fan_time(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct nct6775_data *data = nct6775_update_device(dev);\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nint nr = sattr->nr;\r\nint index = sattr->index;\r\nreturn sprintf(buf, "%d\n",\r\nstep_time_from_reg(data->fan_time[index][nr],\r\ndata->pwm_mode[nr]));\r\n}\r\nstatic ssize_t\r\nstore_fan_time(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct nct6775_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nint nr = sattr->nr;\r\nint index = sattr->index;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nval = step_time_to_reg(val, data->pwm_mode[nr]);\r\nmutex_lock(&data->update_lock);\r\ndata->fan_time[index][nr] = val;\r\nnct6775_write_value(data, data->REG_FAN_TIME[index][nr], val);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_auto_pwm(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct nct6775_data *data = nct6775_update_device(dev);\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nreturn sprintf(buf, "%d\n", data->auto_pwm[sattr->nr][sattr->index]);\r\n}\r\nstatic ssize_t\r\nstore_auto_pwm(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct nct6775_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nint nr = sattr->nr;\r\nint point = sattr->index;\r\nunsigned long val;\r\nint err;\r\nu8 reg;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nif (val > 255)\r\nreturn -EINVAL;\r\nif (point == data->auto_pwm_num) {\r\nif (data->kind != nct6775 && !val)\r\nreturn -EINVAL;\r\nif (data->kind != nct6779 && val)\r\nval = 0xff;\r\n}\r\nmutex_lock(&data->update_lock);\r\ndata->auto_pwm[nr][point] = val;\r\nif (point < data->auto_pwm_num) {\r\nnct6775_write_value(data,\r\nNCT6775_AUTO_PWM(data, nr, point),\r\ndata->auto_pwm[nr][point]);\r\n} else {\r\nswitch (data->kind) {\r\ncase nct6775:\r\nreg = nct6775_read_value(data,\r\nNCT6775_REG_CRITICAL_ENAB[nr]);\r\nif (val)\r\nreg |= 0x02;\r\nelse\r\nreg &= ~0x02;\r\nnct6775_write_value(data, NCT6775_REG_CRITICAL_ENAB[nr],\r\nreg);\r\nbreak;\r\ncase nct6776:\r\nbreak;\r\ncase nct6106:\r\ncase nct6779:\r\ncase nct6791:\r\ncase nct6792:\r\nnct6775_write_value(data, data->REG_CRITICAL_PWM[nr],\r\nval);\r\nreg = nct6775_read_value(data,\r\ndata->REG_CRITICAL_PWM_ENABLE[nr]);\r\nif (val == 255)\r\nreg &= ~data->CRITICAL_PWM_ENABLE_MASK;\r\nelse\r\nreg |= data->CRITICAL_PWM_ENABLE_MASK;\r\nnct6775_write_value(data,\r\ndata->REG_CRITICAL_PWM_ENABLE[nr],\r\nreg);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_auto_temp(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct nct6775_data *data = nct6775_update_device(dev);\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nint nr = sattr->nr;\r\nint point = sattr->index;\r\nreturn sprintf(buf, "%d\n", data->auto_temp[nr][point] * 1000);\r\n}\r\nstatic ssize_t\r\nstore_auto_temp(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct nct6775_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nint nr = sattr->nr;\r\nint point = sattr->index;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nif (val > 255000)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->auto_temp[nr][point] = DIV_ROUND_CLOSEST(val, 1000);\r\nif (point < data->auto_pwm_num) {\r\nnct6775_write_value(data,\r\nNCT6775_AUTO_TEMP(data, nr, point),\r\ndata->auto_temp[nr][point]);\r\n} else {\r\nnct6775_write_value(data, data->REG_CRITICAL_TEMP[nr],\r\ndata->auto_temp[nr][point]);\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic umode_t nct6775_pwm_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int index)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct nct6775_data *data = dev_get_drvdata(dev);\r\nint pwm = index / 36;\r\nint nr = index % 36;\r\nif (!(data->has_pwm & (1 << pwm)))\r\nreturn 0;\r\nif ((nr >= 14 && nr <= 18) || nr == 21)\r\nif (!data->REG_WEIGHT_TEMP_SEL[pwm])\r\nreturn 0;\r\nif (nr == 19 && data->REG_PWM[3] == NULL)\r\nreturn 0;\r\nif (nr == 20 && data->REG_PWM[4] == NULL)\r\nreturn 0;\r\nif (nr == 21 && data->REG_PWM[6] == NULL)\r\nreturn 0;\r\nif (nr >= 22 && nr <= 35) {\r\nint api = (nr - 22) / 2;\r\nif (api > data->auto_pwm_num)\r\nreturn 0;\r\n}\r\nreturn attr->mode;\r\n}\r\nstatic ssize_t\r\nshow_vid(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct nct6775_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", vid_from_reg(data->vid, data->vrm));\r\n}\r\nstatic ssize_t\r\nclear_caseopen(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct nct6775_data *data = dev_get_drvdata(dev);\r\nint nr = to_sensor_dev_attr(attr)->index - INTRUSION_ALARM_BASE;\r\nunsigned long val;\r\nu8 reg;\r\nint ret;\r\nif (kstrtoul(buf, 10, &val) || val != 0)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nret = superio_enter(data->sioreg);\r\nif (ret) {\r\ncount = ret;\r\ngoto error;\r\n}\r\nsuperio_select(data->sioreg, NCT6775_LD_ACPI);\r\nreg = superio_inb(data->sioreg, NCT6775_REG_CR_CASEOPEN_CLR[nr]);\r\nreg |= NCT6775_CR_CASEOPEN_CLR_MASK[nr];\r\nsuperio_outb(data->sioreg, NCT6775_REG_CR_CASEOPEN_CLR[nr], reg);\r\nreg &= ~NCT6775_CR_CASEOPEN_CLR_MASK[nr];\r\nsuperio_outb(data->sioreg, NCT6775_REG_CR_CASEOPEN_CLR[nr], reg);\r\nsuperio_exit(data->sioreg);\r\ndata->valid = false;\r\nerror:\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic umode_t nct6775_other_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int index)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct nct6775_data *data = dev_get_drvdata(dev);\r\nif (index == 0 && !data->have_vid)\r\nreturn 0;\r\nif (index == 1 || index == 2) {\r\nif (data->ALARM_BITS[INTRUSION_ALARM_BASE + index - 1] < 0)\r\nreturn 0;\r\n}\r\nif (index == 3 || index == 4) {\r\nif (data->BEEP_BITS[INTRUSION_ALARM_BASE + index - 3] < 0)\r\nreturn 0;\r\n}\r\nreturn attr->mode;\r\n}\r\nstatic inline void nct6775_init_device(struct nct6775_data *data)\r\n{\r\nint i;\r\nu8 tmp, diode;\r\nif (data->REG_CONFIG) {\r\ntmp = nct6775_read_value(data, data->REG_CONFIG);\r\nif (!(tmp & 0x01))\r\nnct6775_write_value(data, data->REG_CONFIG, tmp | 0x01);\r\n}\r\nfor (i = 0; i < NUM_TEMP; i++) {\r\nif (!(data->have_temp & (1 << i)))\r\ncontinue;\r\nif (!data->reg_temp_config[i])\r\ncontinue;\r\ntmp = nct6775_read_value(data, data->reg_temp_config[i]);\r\nif (tmp & 0x01)\r\nnct6775_write_value(data, data->reg_temp_config[i],\r\ntmp & 0xfe);\r\n}\r\ntmp = nct6775_read_value(data, data->REG_VBAT);\r\nif (!(tmp & 0x01))\r\nnct6775_write_value(data, data->REG_VBAT, tmp | 0x01);\r\ndiode = nct6775_read_value(data, data->REG_DIODE);\r\nfor (i = 0; i < data->temp_fixed_num; i++) {\r\nif (!(data->have_temp_fixed & (1 << i)))\r\ncontinue;\r\nif ((tmp & (data->DIODE_MASK << i)))\r\ndata->temp_type[i]\r\n= 3 - ((diode >> i) & data->DIODE_MASK);\r\nelse\r\ndata->temp_type[i] = 4;\r\n}\r\n}\r\nstatic void\r\nnct6775_check_fan_inputs(struct nct6775_data *data)\r\n{\r\nbool fan3pin, fan4pin, fan4min, fan5pin, fan6pin;\r\nbool pwm3pin, pwm4pin, pwm5pin, pwm6pin;\r\nint sioreg = data->sioreg;\r\nint regval;\r\nsuperio_select(sioreg, NCT6775_LD_HWM);\r\ndata->sio_reg_enable = superio_inb(sioreg, SIO_REG_ENABLE);\r\nif (data->kind == nct6775) {\r\nregval = superio_inb(sioreg, 0x2c);\r\nfan3pin = regval & (1 << 6);\r\npwm3pin = regval & (1 << 7);\r\nfan4pin = !(superio_inb(sioreg, 0x2A) & 0x80);\r\nfan4min = false;\r\nfan5pin = false;\r\nfan6pin = false;\r\npwm4pin = false;\r\npwm5pin = false;\r\npwm6pin = false;\r\n} else if (data->kind == nct6776) {\r\nbool gpok = superio_inb(sioreg, 0x27) & 0x80;\r\nconst char *board_vendor, *board_name;\r\nboard_vendor = dmi_get_system_info(DMI_BOARD_VENDOR);\r\nboard_name = dmi_get_system_info(DMI_BOARD_NAME);\r\nif (board_name && board_vendor &&\r\n!strcmp(board_vendor, "ASRock")) {\r\nif (!strcmp(board_name, "Z77 Pro4-M")) {\r\nif ((data->sio_reg_enable & 0xe0) != 0xe0) {\r\ndata->sio_reg_enable |= 0xe0;\r\nsuperio_outb(sioreg, SIO_REG_ENABLE,\r\ndata->sio_reg_enable);\r\n}\r\n}\r\n}\r\nif (data->sio_reg_enable & 0x80)\r\nfan3pin = gpok;\r\nelse\r\nfan3pin = !(superio_inb(sioreg, 0x24) & 0x40);\r\nif (data->sio_reg_enable & 0x40)\r\nfan4pin = gpok;\r\nelse\r\nfan4pin = superio_inb(sioreg, 0x1C) & 0x01;\r\nif (data->sio_reg_enable & 0x20)\r\nfan5pin = gpok;\r\nelse\r\nfan5pin = superio_inb(sioreg, 0x1C) & 0x02;\r\nfan4min = fan4pin;\r\nfan6pin = false;\r\npwm3pin = fan3pin;\r\npwm4pin = false;\r\npwm5pin = false;\r\npwm6pin = false;\r\n} else if (data->kind == nct6106) {\r\nregval = superio_inb(sioreg, 0x24);\r\nfan3pin = !(regval & 0x80);\r\npwm3pin = regval & 0x08;\r\nfan4pin = false;\r\nfan4min = false;\r\nfan5pin = false;\r\nfan6pin = false;\r\npwm4pin = false;\r\npwm5pin = false;\r\npwm6pin = false;\r\n} else {\r\nregval = superio_inb(sioreg, 0x1c);\r\nfan3pin = !(regval & (1 << 5));\r\nfan4pin = !(regval & (1 << 6));\r\nfan5pin = !(regval & (1 << 7));\r\npwm3pin = !(regval & (1 << 0));\r\npwm4pin = !(regval & (1 << 1));\r\npwm5pin = !(regval & (1 << 2));\r\nfan4min = fan4pin;\r\nif (data->kind == nct6791 || data->kind == nct6792) {\r\nregval = superio_inb(sioreg, 0x2d);\r\nfan6pin = (regval & (1 << 1));\r\npwm6pin = (regval & (1 << 0));\r\n} else {\r\nfan6pin = false;\r\npwm6pin = false;\r\n}\r\n}\r\ndata->has_fan = 0x03 | (fan3pin << 2) | (fan4pin << 3) |\r\n(fan5pin << 4) | (fan6pin << 5);\r\ndata->has_fan_min = 0x03 | (fan3pin << 2) | (fan4min << 3) |\r\n(fan5pin << 4);\r\ndata->has_pwm = 0x03 | (pwm3pin << 2) | (pwm4pin << 3) |\r\n(pwm5pin << 4) | (pwm6pin << 5);\r\n}\r\nstatic void add_temp_sensors(struct nct6775_data *data, const u16 *regp,\r\nint *available, int *mask)\r\n{\r\nint i;\r\nu8 src;\r\nfor (i = 0; i < data->pwm_num && *available; i++) {\r\nint index;\r\nif (!regp[i])\r\ncontinue;\r\nsrc = nct6775_read_value(data, regp[i]);\r\nsrc &= 0x1f;\r\nif (!src || (*mask & (1 << src)))\r\ncontinue;\r\nif (src >= data->temp_label_num ||\r\n!strlen(data->temp_label[src]))\r\ncontinue;\r\nindex = __ffs(*available);\r\nnct6775_write_value(data, data->REG_TEMP_SOURCE[index], src);\r\n*available &= ~(1 << index);\r\n*mask |= 1 << src;\r\n}\r\n}\r\nstatic int nct6775_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct nct6775_sio_data *sio_data = dev_get_platdata(dev);\r\nstruct nct6775_data *data;\r\nstruct resource *res;\r\nint i, s, err = 0;\r\nint src, mask, available;\r\nconst u16 *reg_temp, *reg_temp_over, *reg_temp_hyst, *reg_temp_config;\r\nconst u16 *reg_temp_mon, *reg_temp_alternate, *reg_temp_crit;\r\nconst u16 *reg_temp_crit_l = NULL, *reg_temp_crit_h = NULL;\r\nint num_reg_temp, num_reg_temp_mon;\r\nu8 cr2a;\r\nstruct attribute_group *group;\r\nstruct device *hwmon_dev;\r\nint num_attr_groups = 0;\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (!devm_request_region(&pdev->dev, res->start, IOREGION_LENGTH,\r\nDRVNAME))\r\nreturn -EBUSY;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(struct nct6775_data),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->kind = sio_data->kind;\r\ndata->sioreg = sio_data->sioreg;\r\ndata->addr = res->start;\r\nmutex_init(&data->update_lock);\r\ndata->name = nct6775_device_names[data->kind];\r\ndata->bank = 0xff;\r\nplatform_set_drvdata(pdev, data);\r\nswitch (data->kind) {\r\ncase nct6106:\r\ndata->in_num = 9;\r\ndata->pwm_num = 3;\r\ndata->auto_pwm_num = 4;\r\ndata->temp_fixed_num = 3;\r\ndata->num_temp_alarms = 6;\r\ndata->num_temp_beeps = 6;\r\ndata->fan_from_reg = fan_from_reg13;\r\ndata->fan_from_reg_min = fan_from_reg13;\r\ndata->temp_label = nct6776_temp_label;\r\ndata->temp_label_num = ARRAY_SIZE(nct6776_temp_label);\r\ndata->REG_VBAT = NCT6106_REG_VBAT;\r\ndata->REG_DIODE = NCT6106_REG_DIODE;\r\ndata->DIODE_MASK = NCT6106_DIODE_MASK;\r\ndata->REG_VIN = NCT6106_REG_IN;\r\ndata->REG_IN_MINMAX[0] = NCT6106_REG_IN_MIN;\r\ndata->REG_IN_MINMAX[1] = NCT6106_REG_IN_MAX;\r\ndata->REG_TARGET = NCT6106_REG_TARGET;\r\ndata->REG_FAN = NCT6106_REG_FAN;\r\ndata->REG_FAN_MODE = NCT6106_REG_FAN_MODE;\r\ndata->REG_FAN_MIN = NCT6106_REG_FAN_MIN;\r\ndata->REG_FAN_PULSES = NCT6106_REG_FAN_PULSES;\r\ndata->FAN_PULSE_SHIFT = NCT6106_FAN_PULSE_SHIFT;\r\ndata->REG_FAN_TIME[0] = NCT6106_REG_FAN_STOP_TIME;\r\ndata->REG_FAN_TIME[1] = NCT6106_REG_FAN_STEP_UP_TIME;\r\ndata->REG_FAN_TIME[2] = NCT6106_REG_FAN_STEP_DOWN_TIME;\r\ndata->REG_PWM[0] = NCT6106_REG_PWM;\r\ndata->REG_PWM[1] = NCT6106_REG_FAN_START_OUTPUT;\r\ndata->REG_PWM[2] = NCT6106_REG_FAN_STOP_OUTPUT;\r\ndata->REG_PWM[5] = NCT6106_REG_WEIGHT_DUTY_STEP;\r\ndata->REG_PWM[6] = NCT6106_REG_WEIGHT_DUTY_BASE;\r\ndata->REG_PWM_READ = NCT6106_REG_PWM_READ;\r\ndata->REG_PWM_MODE = NCT6106_REG_PWM_MODE;\r\ndata->PWM_MODE_MASK = NCT6106_PWM_MODE_MASK;\r\ndata->REG_AUTO_TEMP = NCT6106_REG_AUTO_TEMP;\r\ndata->REG_AUTO_PWM = NCT6106_REG_AUTO_PWM;\r\ndata->REG_CRITICAL_TEMP = NCT6106_REG_CRITICAL_TEMP;\r\ndata->REG_CRITICAL_TEMP_TOLERANCE\r\n= NCT6106_REG_CRITICAL_TEMP_TOLERANCE;\r\ndata->REG_CRITICAL_PWM_ENABLE = NCT6106_REG_CRITICAL_PWM_ENABLE;\r\ndata->CRITICAL_PWM_ENABLE_MASK\r\n= NCT6106_CRITICAL_PWM_ENABLE_MASK;\r\ndata->REG_CRITICAL_PWM = NCT6106_REG_CRITICAL_PWM;\r\ndata->REG_TEMP_OFFSET = NCT6106_REG_TEMP_OFFSET;\r\ndata->REG_TEMP_SOURCE = NCT6106_REG_TEMP_SOURCE;\r\ndata->REG_TEMP_SEL = NCT6106_REG_TEMP_SEL;\r\ndata->REG_WEIGHT_TEMP_SEL = NCT6106_REG_WEIGHT_TEMP_SEL;\r\ndata->REG_WEIGHT_TEMP[0] = NCT6106_REG_WEIGHT_TEMP_STEP;\r\ndata->REG_WEIGHT_TEMP[1] = NCT6106_REG_WEIGHT_TEMP_STEP_TOL;\r\ndata->REG_WEIGHT_TEMP[2] = NCT6106_REG_WEIGHT_TEMP_BASE;\r\ndata->REG_ALARM = NCT6106_REG_ALARM;\r\ndata->ALARM_BITS = NCT6106_ALARM_BITS;\r\ndata->REG_BEEP = NCT6106_REG_BEEP;\r\ndata->BEEP_BITS = NCT6106_BEEP_BITS;\r\nreg_temp = NCT6106_REG_TEMP;\r\nreg_temp_mon = NCT6106_REG_TEMP_MON;\r\nnum_reg_temp = ARRAY_SIZE(NCT6106_REG_TEMP);\r\nnum_reg_temp_mon = ARRAY_SIZE(NCT6106_REG_TEMP_MON);\r\nreg_temp_over = NCT6106_REG_TEMP_OVER;\r\nreg_temp_hyst = NCT6106_REG_TEMP_HYST;\r\nreg_temp_config = NCT6106_REG_TEMP_CONFIG;\r\nreg_temp_alternate = NCT6106_REG_TEMP_ALTERNATE;\r\nreg_temp_crit = NCT6106_REG_TEMP_CRIT;\r\nreg_temp_crit_l = NCT6106_REG_TEMP_CRIT_L;\r\nreg_temp_crit_h = NCT6106_REG_TEMP_CRIT_H;\r\nbreak;\r\ncase nct6775:\r\ndata->in_num = 9;\r\ndata->pwm_num = 3;\r\ndata->auto_pwm_num = 6;\r\ndata->has_fan_div = true;\r\ndata->temp_fixed_num = 3;\r\ndata->num_temp_alarms = 3;\r\ndata->num_temp_beeps = 3;\r\ndata->ALARM_BITS = NCT6775_ALARM_BITS;\r\ndata->BEEP_BITS = NCT6775_BEEP_BITS;\r\ndata->fan_from_reg = fan_from_reg16;\r\ndata->fan_from_reg_min = fan_from_reg8;\r\ndata->target_temp_mask = 0x7f;\r\ndata->tolerance_mask = 0x0f;\r\ndata->speed_tolerance_limit = 15;\r\ndata->temp_label = nct6775_temp_label;\r\ndata->temp_label_num = ARRAY_SIZE(nct6775_temp_label);\r\ndata->REG_CONFIG = NCT6775_REG_CONFIG;\r\ndata->REG_VBAT = NCT6775_REG_VBAT;\r\ndata->REG_DIODE = NCT6775_REG_DIODE;\r\ndata->DIODE_MASK = NCT6775_DIODE_MASK;\r\ndata->REG_VIN = NCT6775_REG_IN;\r\ndata->REG_IN_MINMAX[0] = NCT6775_REG_IN_MIN;\r\ndata->REG_IN_MINMAX[1] = NCT6775_REG_IN_MAX;\r\ndata->REG_TARGET = NCT6775_REG_TARGET;\r\ndata->REG_FAN = NCT6775_REG_FAN;\r\ndata->REG_FAN_MODE = NCT6775_REG_FAN_MODE;\r\ndata->REG_FAN_MIN = NCT6775_REG_FAN_MIN;\r\ndata->REG_FAN_PULSES = NCT6775_REG_FAN_PULSES;\r\ndata->FAN_PULSE_SHIFT = NCT6775_FAN_PULSE_SHIFT;\r\ndata->REG_FAN_TIME[0] = NCT6775_REG_FAN_STOP_TIME;\r\ndata->REG_FAN_TIME[1] = NCT6775_REG_FAN_STEP_UP_TIME;\r\ndata->REG_FAN_TIME[2] = NCT6775_REG_FAN_STEP_DOWN_TIME;\r\ndata->REG_PWM[0] = NCT6775_REG_PWM;\r\ndata->REG_PWM[1] = NCT6775_REG_FAN_START_OUTPUT;\r\ndata->REG_PWM[2] = NCT6775_REG_FAN_STOP_OUTPUT;\r\ndata->REG_PWM[3] = NCT6775_REG_FAN_MAX_OUTPUT;\r\ndata->REG_PWM[4] = NCT6775_REG_FAN_STEP_OUTPUT;\r\ndata->REG_PWM[5] = NCT6775_REG_WEIGHT_DUTY_STEP;\r\ndata->REG_PWM_READ = NCT6775_REG_PWM_READ;\r\ndata->REG_PWM_MODE = NCT6775_REG_PWM_MODE;\r\ndata->PWM_MODE_MASK = NCT6775_PWM_MODE_MASK;\r\ndata->REG_AUTO_TEMP = NCT6775_REG_AUTO_TEMP;\r\ndata->REG_AUTO_PWM = NCT6775_REG_AUTO_PWM;\r\ndata->REG_CRITICAL_TEMP = NCT6775_REG_CRITICAL_TEMP;\r\ndata->REG_CRITICAL_TEMP_TOLERANCE\r\n= NCT6775_REG_CRITICAL_TEMP_TOLERANCE;\r\ndata->REG_TEMP_OFFSET = NCT6775_REG_TEMP_OFFSET;\r\ndata->REG_TEMP_SOURCE = NCT6775_REG_TEMP_SOURCE;\r\ndata->REG_TEMP_SEL = NCT6775_REG_TEMP_SEL;\r\ndata->REG_WEIGHT_TEMP_SEL = NCT6775_REG_WEIGHT_TEMP_SEL;\r\ndata->REG_WEIGHT_TEMP[0] = NCT6775_REG_WEIGHT_TEMP_STEP;\r\ndata->REG_WEIGHT_TEMP[1] = NCT6775_REG_WEIGHT_TEMP_STEP_TOL;\r\ndata->REG_WEIGHT_TEMP[2] = NCT6775_REG_WEIGHT_TEMP_BASE;\r\ndata->REG_ALARM = NCT6775_REG_ALARM;\r\ndata->REG_BEEP = NCT6775_REG_BEEP;\r\nreg_temp = NCT6775_REG_TEMP;\r\nreg_temp_mon = NCT6775_REG_TEMP_MON;\r\nnum_reg_temp = ARRAY_SIZE(NCT6775_REG_TEMP);\r\nnum_reg_temp_mon = ARRAY_SIZE(NCT6775_REG_TEMP_MON);\r\nreg_temp_over = NCT6775_REG_TEMP_OVER;\r\nreg_temp_hyst = NCT6775_REG_TEMP_HYST;\r\nreg_temp_config = NCT6775_REG_TEMP_CONFIG;\r\nreg_temp_alternate = NCT6775_REG_TEMP_ALTERNATE;\r\nreg_temp_crit = NCT6775_REG_TEMP_CRIT;\r\nbreak;\r\ncase nct6776:\r\ndata->in_num = 9;\r\ndata->pwm_num = 3;\r\ndata->auto_pwm_num = 4;\r\ndata->has_fan_div = false;\r\ndata->temp_fixed_num = 3;\r\ndata->num_temp_alarms = 3;\r\ndata->num_temp_beeps = 6;\r\ndata->ALARM_BITS = NCT6776_ALARM_BITS;\r\ndata->BEEP_BITS = NCT6776_BEEP_BITS;\r\ndata->fan_from_reg = fan_from_reg13;\r\ndata->fan_from_reg_min = fan_from_reg13;\r\ndata->target_temp_mask = 0xff;\r\ndata->tolerance_mask = 0x07;\r\ndata->speed_tolerance_limit = 63;\r\ndata->temp_label = nct6776_temp_label;\r\ndata->temp_label_num = ARRAY_SIZE(nct6776_temp_label);\r\ndata->REG_CONFIG = NCT6775_REG_CONFIG;\r\ndata->REG_VBAT = NCT6775_REG_VBAT;\r\ndata->REG_DIODE = NCT6775_REG_DIODE;\r\ndata->DIODE_MASK = NCT6775_DIODE_MASK;\r\ndata->REG_VIN = NCT6775_REG_IN;\r\ndata->REG_IN_MINMAX[0] = NCT6775_REG_IN_MIN;\r\ndata->REG_IN_MINMAX[1] = NCT6775_REG_IN_MAX;\r\ndata->REG_TARGET = NCT6775_REG_TARGET;\r\ndata->REG_FAN = NCT6775_REG_FAN;\r\ndata->REG_FAN_MODE = NCT6775_REG_FAN_MODE;\r\ndata->REG_FAN_MIN = NCT6776_REG_FAN_MIN;\r\ndata->REG_FAN_PULSES = NCT6776_REG_FAN_PULSES;\r\ndata->FAN_PULSE_SHIFT = NCT6775_FAN_PULSE_SHIFT;\r\ndata->REG_FAN_TIME[0] = NCT6775_REG_FAN_STOP_TIME;\r\ndata->REG_FAN_TIME[1] = NCT6775_REG_FAN_STEP_UP_TIME;\r\ndata->REG_FAN_TIME[2] = NCT6775_REG_FAN_STEP_DOWN_TIME;\r\ndata->REG_TOLERANCE_H = NCT6776_REG_TOLERANCE_H;\r\ndata->REG_PWM[0] = NCT6775_REG_PWM;\r\ndata->REG_PWM[1] = NCT6775_REG_FAN_START_OUTPUT;\r\ndata->REG_PWM[2] = NCT6775_REG_FAN_STOP_OUTPUT;\r\ndata->REG_PWM[5] = NCT6775_REG_WEIGHT_DUTY_STEP;\r\ndata->REG_PWM[6] = NCT6776_REG_WEIGHT_DUTY_BASE;\r\ndata->REG_PWM_READ = NCT6775_REG_PWM_READ;\r\ndata->REG_PWM_MODE = NCT6776_REG_PWM_MODE;\r\ndata->PWM_MODE_MASK = NCT6776_PWM_MODE_MASK;\r\ndata->REG_AUTO_TEMP = NCT6775_REG_AUTO_TEMP;\r\ndata->REG_AUTO_PWM = NCT6775_REG_AUTO_PWM;\r\ndata->REG_CRITICAL_TEMP = NCT6775_REG_CRITICAL_TEMP;\r\ndata->REG_CRITICAL_TEMP_TOLERANCE\r\n= NCT6775_REG_CRITICAL_TEMP_TOLERANCE;\r\ndata->REG_TEMP_OFFSET = NCT6775_REG_TEMP_OFFSET;\r\ndata->REG_TEMP_SOURCE = NCT6775_REG_TEMP_SOURCE;\r\ndata->REG_TEMP_SEL = NCT6775_REG_TEMP_SEL;\r\ndata->REG_WEIGHT_TEMP_SEL = NCT6775_REG_WEIGHT_TEMP_SEL;\r\ndata->REG_WEIGHT_TEMP[0] = NCT6775_REG_WEIGHT_TEMP_STEP;\r\ndata->REG_WEIGHT_TEMP[1] = NCT6775_REG_WEIGHT_TEMP_STEP_TOL;\r\ndata->REG_WEIGHT_TEMP[2] = NCT6775_REG_WEIGHT_TEMP_BASE;\r\ndata->REG_ALARM = NCT6775_REG_ALARM;\r\ndata->REG_BEEP = NCT6776_REG_BEEP;\r\nreg_temp = NCT6775_REG_TEMP;\r\nreg_temp_mon = NCT6775_REG_TEMP_MON;\r\nnum_reg_temp = ARRAY_SIZE(NCT6775_REG_TEMP);\r\nnum_reg_temp_mon = ARRAY_SIZE(NCT6775_REG_TEMP_MON);\r\nreg_temp_over = NCT6775_REG_TEMP_OVER;\r\nreg_temp_hyst = NCT6775_REG_TEMP_HYST;\r\nreg_temp_config = NCT6776_REG_TEMP_CONFIG;\r\nreg_temp_alternate = NCT6776_REG_TEMP_ALTERNATE;\r\nreg_temp_crit = NCT6776_REG_TEMP_CRIT;\r\nbreak;\r\ncase nct6779:\r\ndata->in_num = 15;\r\ndata->pwm_num = 5;\r\ndata->auto_pwm_num = 4;\r\ndata->has_fan_div = false;\r\ndata->temp_fixed_num = 6;\r\ndata->num_temp_alarms = 2;\r\ndata->num_temp_beeps = 2;\r\ndata->ALARM_BITS = NCT6779_ALARM_BITS;\r\ndata->BEEP_BITS = NCT6779_BEEP_BITS;\r\ndata->fan_from_reg = fan_from_reg13;\r\ndata->fan_from_reg_min = fan_from_reg13;\r\ndata->target_temp_mask = 0xff;\r\ndata->tolerance_mask = 0x07;\r\ndata->speed_tolerance_limit = 63;\r\ndata->temp_label = nct6779_temp_label;\r\ndata->temp_label_num = ARRAY_SIZE(nct6779_temp_label);\r\ndata->REG_CONFIG = NCT6775_REG_CONFIG;\r\ndata->REG_VBAT = NCT6775_REG_VBAT;\r\ndata->REG_DIODE = NCT6775_REG_DIODE;\r\ndata->DIODE_MASK = NCT6775_DIODE_MASK;\r\ndata->REG_VIN = NCT6779_REG_IN;\r\ndata->REG_IN_MINMAX[0] = NCT6775_REG_IN_MIN;\r\ndata->REG_IN_MINMAX[1] = NCT6775_REG_IN_MAX;\r\ndata->REG_TARGET = NCT6775_REG_TARGET;\r\ndata->REG_FAN = NCT6779_REG_FAN;\r\ndata->REG_FAN_MODE = NCT6775_REG_FAN_MODE;\r\ndata->REG_FAN_MIN = NCT6776_REG_FAN_MIN;\r\ndata->REG_FAN_PULSES = NCT6779_REG_FAN_PULSES;\r\ndata->FAN_PULSE_SHIFT = NCT6775_FAN_PULSE_SHIFT;\r\ndata->REG_FAN_TIME[0] = NCT6775_REG_FAN_STOP_TIME;\r\ndata->REG_FAN_TIME[1] = NCT6775_REG_FAN_STEP_UP_TIME;\r\ndata->REG_FAN_TIME[2] = NCT6775_REG_FAN_STEP_DOWN_TIME;\r\ndata->REG_TOLERANCE_H = NCT6776_REG_TOLERANCE_H;\r\ndata->REG_PWM[0] = NCT6775_REG_PWM;\r\ndata->REG_PWM[1] = NCT6775_REG_FAN_START_OUTPUT;\r\ndata->REG_PWM[2] = NCT6775_REG_FAN_STOP_OUTPUT;\r\ndata->REG_PWM[5] = NCT6775_REG_WEIGHT_DUTY_STEP;\r\ndata->REG_PWM[6] = NCT6776_REG_WEIGHT_DUTY_BASE;\r\ndata->REG_PWM_READ = NCT6775_REG_PWM_READ;\r\ndata->REG_PWM_MODE = NCT6776_REG_PWM_MODE;\r\ndata->PWM_MODE_MASK = NCT6776_PWM_MODE_MASK;\r\ndata->REG_AUTO_TEMP = NCT6775_REG_AUTO_TEMP;\r\ndata->REG_AUTO_PWM = NCT6775_REG_AUTO_PWM;\r\ndata->REG_CRITICAL_TEMP = NCT6775_REG_CRITICAL_TEMP;\r\ndata->REG_CRITICAL_TEMP_TOLERANCE\r\n= NCT6775_REG_CRITICAL_TEMP_TOLERANCE;\r\ndata->REG_CRITICAL_PWM_ENABLE = NCT6779_REG_CRITICAL_PWM_ENABLE;\r\ndata->CRITICAL_PWM_ENABLE_MASK\r\n= NCT6779_CRITICAL_PWM_ENABLE_MASK;\r\ndata->REG_CRITICAL_PWM = NCT6779_REG_CRITICAL_PWM;\r\ndata->REG_TEMP_OFFSET = NCT6779_REG_TEMP_OFFSET;\r\ndata->REG_TEMP_SOURCE = NCT6775_REG_TEMP_SOURCE;\r\ndata->REG_TEMP_SEL = NCT6775_REG_TEMP_SEL;\r\ndata->REG_WEIGHT_TEMP_SEL = NCT6775_REG_WEIGHT_TEMP_SEL;\r\ndata->REG_WEIGHT_TEMP[0] = NCT6775_REG_WEIGHT_TEMP_STEP;\r\ndata->REG_WEIGHT_TEMP[1] = NCT6775_REG_WEIGHT_TEMP_STEP_TOL;\r\ndata->REG_WEIGHT_TEMP[2] = NCT6775_REG_WEIGHT_TEMP_BASE;\r\ndata->REG_ALARM = NCT6779_REG_ALARM;\r\ndata->REG_BEEP = NCT6776_REG_BEEP;\r\nreg_temp = NCT6779_REG_TEMP;\r\nreg_temp_mon = NCT6779_REG_TEMP_MON;\r\nnum_reg_temp = ARRAY_SIZE(NCT6779_REG_TEMP);\r\nnum_reg_temp_mon = ARRAY_SIZE(NCT6779_REG_TEMP_MON);\r\nreg_temp_over = NCT6779_REG_TEMP_OVER;\r\nreg_temp_hyst = NCT6779_REG_TEMP_HYST;\r\nreg_temp_config = NCT6779_REG_TEMP_CONFIG;\r\nreg_temp_alternate = NCT6779_REG_TEMP_ALTERNATE;\r\nreg_temp_crit = NCT6779_REG_TEMP_CRIT;\r\nbreak;\r\ncase nct6791:\r\ncase nct6792:\r\ndata->in_num = 15;\r\ndata->pwm_num = 6;\r\ndata->auto_pwm_num = 4;\r\ndata->has_fan_div = false;\r\ndata->temp_fixed_num = 6;\r\ndata->num_temp_alarms = 2;\r\ndata->num_temp_beeps = 2;\r\ndata->ALARM_BITS = NCT6791_ALARM_BITS;\r\ndata->BEEP_BITS = NCT6779_BEEP_BITS;\r\ndata->fan_from_reg = fan_from_reg13;\r\ndata->fan_from_reg_min = fan_from_reg13;\r\ndata->target_temp_mask = 0xff;\r\ndata->tolerance_mask = 0x07;\r\ndata->speed_tolerance_limit = 63;\r\ndata->temp_label = nct6779_temp_label;\r\ndata->temp_label_num = ARRAY_SIZE(nct6779_temp_label);\r\ndata->REG_CONFIG = NCT6775_REG_CONFIG;\r\ndata->REG_VBAT = NCT6775_REG_VBAT;\r\ndata->REG_DIODE = NCT6775_REG_DIODE;\r\ndata->DIODE_MASK = NCT6775_DIODE_MASK;\r\ndata->REG_VIN = NCT6779_REG_IN;\r\ndata->REG_IN_MINMAX[0] = NCT6775_REG_IN_MIN;\r\ndata->REG_IN_MINMAX[1] = NCT6775_REG_IN_MAX;\r\ndata->REG_TARGET = NCT6775_REG_TARGET;\r\ndata->REG_FAN = NCT6779_REG_FAN;\r\ndata->REG_FAN_MODE = NCT6775_REG_FAN_MODE;\r\ndata->REG_FAN_MIN = NCT6776_REG_FAN_MIN;\r\ndata->REG_FAN_PULSES = NCT6779_REG_FAN_PULSES;\r\ndata->FAN_PULSE_SHIFT = NCT6775_FAN_PULSE_SHIFT;\r\ndata->REG_FAN_TIME[0] = NCT6775_REG_FAN_STOP_TIME;\r\ndata->REG_FAN_TIME[1] = NCT6775_REG_FAN_STEP_UP_TIME;\r\ndata->REG_FAN_TIME[2] = NCT6775_REG_FAN_STEP_DOWN_TIME;\r\ndata->REG_TOLERANCE_H = NCT6776_REG_TOLERANCE_H;\r\ndata->REG_PWM[0] = NCT6775_REG_PWM;\r\ndata->REG_PWM[1] = NCT6775_REG_FAN_START_OUTPUT;\r\ndata->REG_PWM[2] = NCT6775_REG_FAN_STOP_OUTPUT;\r\ndata->REG_PWM[5] = NCT6791_REG_WEIGHT_DUTY_STEP;\r\ndata->REG_PWM[6] = NCT6791_REG_WEIGHT_DUTY_BASE;\r\ndata->REG_PWM_READ = NCT6775_REG_PWM_READ;\r\ndata->REG_PWM_MODE = NCT6776_REG_PWM_MODE;\r\ndata->PWM_MODE_MASK = NCT6776_PWM_MODE_MASK;\r\ndata->REG_AUTO_TEMP = NCT6775_REG_AUTO_TEMP;\r\ndata->REG_AUTO_PWM = NCT6775_REG_AUTO_PWM;\r\ndata->REG_CRITICAL_TEMP = NCT6775_REG_CRITICAL_TEMP;\r\ndata->REG_CRITICAL_TEMP_TOLERANCE\r\n= NCT6775_REG_CRITICAL_TEMP_TOLERANCE;\r\ndata->REG_CRITICAL_PWM_ENABLE = NCT6779_REG_CRITICAL_PWM_ENABLE;\r\ndata->CRITICAL_PWM_ENABLE_MASK\r\n= NCT6779_CRITICAL_PWM_ENABLE_MASK;\r\ndata->REG_CRITICAL_PWM = NCT6779_REG_CRITICAL_PWM;\r\ndata->REG_TEMP_OFFSET = NCT6779_REG_TEMP_OFFSET;\r\ndata->REG_TEMP_SOURCE = NCT6775_REG_TEMP_SOURCE;\r\ndata->REG_TEMP_SEL = NCT6775_REG_TEMP_SEL;\r\ndata->REG_WEIGHT_TEMP_SEL = NCT6791_REG_WEIGHT_TEMP_SEL;\r\ndata->REG_WEIGHT_TEMP[0] = NCT6791_REG_WEIGHT_TEMP_STEP;\r\ndata->REG_WEIGHT_TEMP[1] = NCT6791_REG_WEIGHT_TEMP_STEP_TOL;\r\ndata->REG_WEIGHT_TEMP[2] = NCT6791_REG_WEIGHT_TEMP_BASE;\r\ndata->REG_ALARM = NCT6791_REG_ALARM;\r\nif (data->kind == nct6791)\r\ndata->REG_BEEP = NCT6776_REG_BEEP;\r\nelse\r\ndata->REG_BEEP = NCT6792_REG_BEEP;\r\nreg_temp = NCT6779_REG_TEMP;\r\nnum_reg_temp = ARRAY_SIZE(NCT6779_REG_TEMP);\r\nif (data->kind == nct6791) {\r\nreg_temp_mon = NCT6779_REG_TEMP_MON;\r\nnum_reg_temp_mon = ARRAY_SIZE(NCT6779_REG_TEMP_MON);\r\n} else {\r\nreg_temp_mon = NCT6792_REG_TEMP_MON;\r\nnum_reg_temp_mon = ARRAY_SIZE(NCT6792_REG_TEMP_MON);\r\n}\r\nreg_temp_over = NCT6779_REG_TEMP_OVER;\r\nreg_temp_hyst = NCT6779_REG_TEMP_HYST;\r\nreg_temp_config = NCT6779_REG_TEMP_CONFIG;\r\nreg_temp_alternate = NCT6779_REG_TEMP_ALTERNATE;\r\nreg_temp_crit = NCT6779_REG_TEMP_CRIT;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\ndata->have_in = (1 << data->in_num) - 1;\r\ndata->have_temp = 0;\r\nmask = 0;\r\navailable = 0;\r\nfor (i = 0; i < num_reg_temp; i++) {\r\nif (reg_temp[i] == 0)\r\ncontinue;\r\nsrc = nct6775_read_value(data, data->REG_TEMP_SOURCE[i]) & 0x1f;\r\nif (!src || (mask & (1 << src)))\r\navailable |= 1 << i;\r\nmask |= 1 << src;\r\n}\r\nadd_temp_sensors(data, data->REG_TEMP_SEL, &available, &mask);\r\nadd_temp_sensors(data, data->REG_WEIGHT_TEMP_SEL, &available, &mask);\r\nmask = 0;\r\ns = NUM_TEMP_FIXED;\r\nfor (i = 0; i < num_reg_temp; i++) {\r\nif (reg_temp[i] == 0)\r\ncontinue;\r\nsrc = nct6775_read_value(data, data->REG_TEMP_SOURCE[i]) & 0x1f;\r\nif (!src || (mask & (1 << src)))\r\ncontinue;\r\nif (src >= data->temp_label_num ||\r\n!strlen(data->temp_label[src])) {\r\ndev_info(dev,\r\n"Invalid temperature source %d at index %d, source register 0x%x, temp register 0x%x\n",\r\nsrc, i, data->REG_TEMP_SOURCE[i], reg_temp[i]);\r\ncontinue;\r\n}\r\nmask |= 1 << src;\r\nif (src <= data->temp_fixed_num) {\r\ndata->have_temp |= 1 << (src - 1);\r\ndata->have_temp_fixed |= 1 << (src - 1);\r\ndata->reg_temp[0][src - 1] = reg_temp[i];\r\ndata->reg_temp[1][src - 1] = reg_temp_over[i];\r\ndata->reg_temp[2][src - 1] = reg_temp_hyst[i];\r\nif (reg_temp_crit_h && reg_temp_crit_h[i])\r\ndata->reg_temp[3][src - 1] = reg_temp_crit_h[i];\r\nelse if (reg_temp_crit[src - 1])\r\ndata->reg_temp[3][src - 1]\r\n= reg_temp_crit[src - 1];\r\nif (reg_temp_crit_l && reg_temp_crit_l[i])\r\ndata->reg_temp[4][src - 1] = reg_temp_crit_l[i];\r\ndata->reg_temp_config[src - 1] = reg_temp_config[i];\r\ndata->temp_src[src - 1] = src;\r\ncontinue;\r\n}\r\nif (s >= NUM_TEMP)\r\ncontinue;\r\ndata->have_temp |= 1 << s;\r\ndata->reg_temp[0][s] = reg_temp[i];\r\ndata->reg_temp[1][s] = reg_temp_over[i];\r\ndata->reg_temp[2][s] = reg_temp_hyst[i];\r\ndata->reg_temp_config[s] = reg_temp_config[i];\r\nif (reg_temp_crit_h && reg_temp_crit_h[i])\r\ndata->reg_temp[3][s] = reg_temp_crit_h[i];\r\nelse if (reg_temp_crit[src - 1])\r\ndata->reg_temp[3][s] = reg_temp_crit[src - 1];\r\nif (reg_temp_crit_l && reg_temp_crit_l[i])\r\ndata->reg_temp[4][s] = reg_temp_crit_l[i];\r\ndata->temp_src[s] = src;\r\ns++;\r\n}\r\nfor (i = 0; i < num_reg_temp_mon; i++) {\r\nif (reg_temp_mon[i] == 0)\r\ncontinue;\r\nsrc = nct6775_read_value(data, data->REG_TEMP_SEL[i]) & 0x1f;\r\nif (!src || (mask & (1 << src)))\r\ncontinue;\r\nif (src >= data->temp_label_num ||\r\n!strlen(data->temp_label[src])) {\r\ndev_info(dev,\r\n"Invalid temperature source %d at index %d, source register 0x%x, temp register 0x%x\n",\r\nsrc, i, data->REG_TEMP_SEL[i],\r\nreg_temp_mon[i]);\r\ncontinue;\r\n}\r\nmask |= 1 << src;\r\nif (src <= data->temp_fixed_num) {\r\nif (data->have_temp & (1 << (src - 1)))\r\ncontinue;\r\ndata->have_temp |= 1 << (src - 1);\r\ndata->have_temp_fixed |= 1 << (src - 1);\r\ndata->reg_temp[0][src - 1] = reg_temp_mon[i];\r\ndata->temp_src[src - 1] = src;\r\ncontinue;\r\n}\r\nif (s >= NUM_TEMP)\r\ncontinue;\r\ndata->have_temp |= 1 << s;\r\ndata->reg_temp[0][s] = reg_temp_mon[i];\r\ndata->temp_src[s] = src;\r\ns++;\r\n}\r\n#ifdef USE_ALTERNATE\r\nfor (i = 0; i < data->temp_label_num - 1; i++) {\r\nif (!reg_temp_alternate[i])\r\ncontinue;\r\nif (mask & (1 << (i + 1)))\r\ncontinue;\r\nif (i < data->temp_fixed_num) {\r\nif (data->have_temp & (1 << i))\r\ncontinue;\r\ndata->have_temp |= 1 << i;\r\ndata->have_temp_fixed |= 1 << i;\r\ndata->reg_temp[0][i] = reg_temp_alternate[i];\r\nif (i < num_reg_temp) {\r\ndata->reg_temp[1][i] = reg_temp_over[i];\r\ndata->reg_temp[2][i] = reg_temp_hyst[i];\r\n}\r\ndata->temp_src[i] = i + 1;\r\ncontinue;\r\n}\r\nif (s >= NUM_TEMP)\r\nbreak;\r\ndata->have_temp |= 1 << s;\r\ndata->reg_temp[0][s] = reg_temp_alternate[i];\r\ndata->temp_src[s] = i + 1;\r\ns++;\r\n}\r\n#endif\r\nnct6775_init_device(data);\r\nerr = superio_enter(sio_data->sioreg);\r\nif (err)\r\nreturn err;\r\ncr2a = superio_inb(sio_data->sioreg, 0x2a);\r\nswitch (data->kind) {\r\ncase nct6775:\r\ndata->have_vid = (cr2a & 0x40);\r\nbreak;\r\ncase nct6776:\r\ndata->have_vid = (cr2a & 0x60) == 0x40;\r\nbreak;\r\ncase nct6106:\r\ncase nct6779:\r\ncase nct6791:\r\ncase nct6792:\r\nbreak;\r\n}\r\nif (data->have_vid) {\r\nsuperio_select(sio_data->sioreg, NCT6775_LD_VID);\r\ndata->vid = superio_inb(sio_data->sioreg, 0xe3);\r\ndata->vrm = vid_which_vrm();\r\n}\r\nif (fan_debounce) {\r\nu8 tmp;\r\nsuperio_select(sio_data->sioreg, NCT6775_LD_HWM);\r\ntmp = superio_inb(sio_data->sioreg,\r\nNCT6775_REG_CR_FAN_DEBOUNCE);\r\nswitch (data->kind) {\r\ncase nct6106:\r\ntmp |= 0xe0;\r\nbreak;\r\ncase nct6775:\r\ntmp |= 0x1e;\r\nbreak;\r\ncase nct6776:\r\ncase nct6779:\r\ntmp |= 0x3e;\r\nbreak;\r\ncase nct6791:\r\ncase nct6792:\r\ntmp |= 0x7e;\r\nbreak;\r\n}\r\nsuperio_outb(sio_data->sioreg, NCT6775_REG_CR_FAN_DEBOUNCE,\r\ntmp);\r\ndev_info(&pdev->dev, "Enabled fan debounce for chip %s\n",\r\ndata->name);\r\n}\r\nnct6775_check_fan_inputs(data);\r\nsuperio_exit(sio_data->sioreg);\r\nnct6775_init_fan_common(dev, data);\r\ngroup = nct6775_create_attr_group(dev, &nct6775_pwm_template_group,\r\ndata->pwm_num);\r\nif (IS_ERR(group))\r\nreturn PTR_ERR(group);\r\ndata->groups[num_attr_groups++] = group;\r\ngroup = nct6775_create_attr_group(dev, &nct6775_in_template_group,\r\nfls(data->have_in));\r\nif (IS_ERR(group))\r\nreturn PTR_ERR(group);\r\ndata->groups[num_attr_groups++] = group;\r\ngroup = nct6775_create_attr_group(dev, &nct6775_fan_template_group,\r\nfls(data->has_fan));\r\nif (IS_ERR(group))\r\nreturn PTR_ERR(group);\r\ndata->groups[num_attr_groups++] = group;\r\ngroup = nct6775_create_attr_group(dev, &nct6775_temp_template_group,\r\nfls(data->have_temp));\r\nif (IS_ERR(group))\r\nreturn PTR_ERR(group);\r\ndata->groups[num_attr_groups++] = group;\r\ndata->groups[num_attr_groups++] = &nct6775_group_other;\r\nhwmon_dev = devm_hwmon_device_register_with_groups(dev, data->name,\r\ndata, data->groups);\r\nreturn PTR_ERR_OR_ZERO(hwmon_dev);\r\n}\r\nstatic void nct6791_enable_io_mapping(int sioaddr)\r\n{\r\nint val;\r\nval = superio_inb(sioaddr, NCT6791_REG_HM_IO_SPACE_LOCK_ENABLE);\r\nif (val & 0x10) {\r\npr_info("Enabling hardware monitor logical device mappings.\n");\r\nsuperio_outb(sioaddr, NCT6791_REG_HM_IO_SPACE_LOCK_ENABLE,\r\nval & ~0x10);\r\n}\r\n}\r\nstatic int __maybe_unused nct6775_suspend(struct device *dev)\r\n{\r\nstruct nct6775_data *data = nct6775_update_device(dev);\r\nmutex_lock(&data->update_lock);\r\ndata->vbat = nct6775_read_value(data, data->REG_VBAT);\r\nif (data->kind == nct6775) {\r\ndata->fandiv1 = nct6775_read_value(data, NCT6775_REG_FANDIV1);\r\ndata->fandiv2 = nct6775_read_value(data, NCT6775_REG_FANDIV2);\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused nct6775_resume(struct device *dev)\r\n{\r\nstruct nct6775_data *data = dev_get_drvdata(dev);\r\nint sioreg = data->sioreg;\r\nint i, j, err = 0;\r\nu8 reg;\r\nmutex_lock(&data->update_lock);\r\ndata->bank = 0xff;\r\nerr = superio_enter(sioreg);\r\nif (err)\r\ngoto abort;\r\nsuperio_select(sioreg, NCT6775_LD_HWM);\r\nreg = superio_inb(sioreg, SIO_REG_ENABLE);\r\nif (reg != data->sio_reg_enable)\r\nsuperio_outb(sioreg, SIO_REG_ENABLE, data->sio_reg_enable);\r\nif (data->kind == nct6791 || data->kind == nct6792)\r\nnct6791_enable_io_mapping(sioreg);\r\nsuperio_exit(sioreg);\r\nfor (i = 0; i < data->in_num; i++) {\r\nif (!(data->have_in & (1 << i)))\r\ncontinue;\r\nnct6775_write_value(data, data->REG_IN_MINMAX[0][i],\r\ndata->in[i][1]);\r\nnct6775_write_value(data, data->REG_IN_MINMAX[1][i],\r\ndata->in[i][2]);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(data->fan_min); i++) {\r\nif (!(data->has_fan_min & (1 << i)))\r\ncontinue;\r\nnct6775_write_value(data, data->REG_FAN_MIN[i],\r\ndata->fan_min[i]);\r\n}\r\nfor (i = 0; i < NUM_TEMP; i++) {\r\nif (!(data->have_temp & (1 << i)))\r\ncontinue;\r\nfor (j = 1; j < ARRAY_SIZE(data->reg_temp); j++)\r\nif (data->reg_temp[j][i])\r\nnct6775_write_temp(data, data->reg_temp[j][i],\r\ndata->temp[j][i]);\r\n}\r\nnct6775_write_value(data, data->REG_VBAT, data->vbat);\r\nif (data->kind == nct6775) {\r\nnct6775_write_value(data, NCT6775_REG_FANDIV1, data->fandiv1);\r\nnct6775_write_value(data, NCT6775_REG_FANDIV2, data->fandiv2);\r\n}\r\nabort:\r\ndata->valid = false;\r\nmutex_unlock(&data->update_lock);\r\nreturn err;\r\n}\r\nstatic int __init nct6775_find(int sioaddr, struct nct6775_sio_data *sio_data)\r\n{\r\nu16 val;\r\nint err;\r\nint addr;\r\nerr = superio_enter(sioaddr);\r\nif (err)\r\nreturn err;\r\nif (force_id)\r\nval = force_id;\r\nelse\r\nval = (superio_inb(sioaddr, SIO_REG_DEVID) << 8)\r\n| superio_inb(sioaddr, SIO_REG_DEVID + 1);\r\nswitch (val & SIO_ID_MASK) {\r\ncase SIO_NCT6106_ID:\r\nsio_data->kind = nct6106;\r\nbreak;\r\ncase SIO_NCT6775_ID:\r\nsio_data->kind = nct6775;\r\nbreak;\r\ncase SIO_NCT6776_ID:\r\nsio_data->kind = nct6776;\r\nbreak;\r\ncase SIO_NCT6779_ID:\r\nsio_data->kind = nct6779;\r\nbreak;\r\ncase SIO_NCT6791_ID:\r\nsio_data->kind = nct6791;\r\nbreak;\r\ncase SIO_NCT6792_ID:\r\nsio_data->kind = nct6792;\r\nbreak;\r\ndefault:\r\nif (val != 0xffff)\r\npr_debug("unsupported chip ID: 0x%04x\n", val);\r\nsuperio_exit(sioaddr);\r\nreturn -ENODEV;\r\n}\r\nsuperio_select(sioaddr, NCT6775_LD_HWM);\r\nval = (superio_inb(sioaddr, SIO_REG_ADDR) << 8)\r\n| superio_inb(sioaddr, SIO_REG_ADDR + 1);\r\naddr = val & IOREGION_ALIGNMENT;\r\nif (addr == 0) {\r\npr_err("Refusing to enable a Super-I/O device with a base I/O port 0\n");\r\nsuperio_exit(sioaddr);\r\nreturn -ENODEV;\r\n}\r\nval = superio_inb(sioaddr, SIO_REG_ENABLE);\r\nif (!(val & 0x01)) {\r\npr_warn("Forcibly enabling Super-I/O. Sensor is probably unusable.\n");\r\nsuperio_outb(sioaddr, SIO_REG_ENABLE, val | 0x01);\r\n}\r\nif (sio_data->kind == nct6791 || sio_data->kind == nct6792)\r\nnct6791_enable_io_mapping(sioaddr);\r\nsuperio_exit(sioaddr);\r\npr_info("Found %s or compatible chip at %#x:%#x\n",\r\nnct6775_sio_names[sio_data->kind], sioaddr, addr);\r\nsio_data->sioreg = sioaddr;\r\nreturn addr;\r\n}\r\nstatic int __init sensors_nct6775_init(void)\r\n{\r\nint i, err;\r\nbool found = false;\r\nint address;\r\nstruct resource res;\r\nstruct nct6775_sio_data sio_data;\r\nint sioaddr[2] = { 0x2e, 0x4e };\r\nerr = platform_driver_register(&nct6775_driver);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < ARRAY_SIZE(pdev); i++) {\r\naddress = nct6775_find(sioaddr[i], &sio_data);\r\nif (address <= 0)\r\ncontinue;\r\nfound = true;\r\npdev[i] = platform_device_alloc(DRVNAME, address);\r\nif (!pdev[i]) {\r\nerr = -ENOMEM;\r\ngoto exit_device_unregister;\r\n}\r\nerr = platform_device_add_data(pdev[i], &sio_data,\r\nsizeof(struct nct6775_sio_data));\r\nif (err)\r\ngoto exit_device_put;\r\nmemset(&res, 0, sizeof(res));\r\nres.name = DRVNAME;\r\nres.start = address + IOREGION_OFFSET;\r\nres.end = address + IOREGION_OFFSET + IOREGION_LENGTH - 1;\r\nres.flags = IORESOURCE_IO;\r\nerr = acpi_check_resource_conflict(&res);\r\nif (err) {\r\nplatform_device_put(pdev[i]);\r\npdev[i] = NULL;\r\ncontinue;\r\n}\r\nerr = platform_device_add_resources(pdev[i], &res, 1);\r\nif (err)\r\ngoto exit_device_put;\r\nerr = platform_device_add(pdev[i]);\r\nif (err)\r\ngoto exit_device_put;\r\n}\r\nif (!found) {\r\nerr = -ENODEV;\r\ngoto exit_unregister;\r\n}\r\nreturn 0;\r\nexit_device_put:\r\nplatform_device_put(pdev[i]);\r\nexit_device_unregister:\r\nwhile (--i >= 0) {\r\nif (pdev[i])\r\nplatform_device_unregister(pdev[i]);\r\n}\r\nexit_unregister:\r\nplatform_driver_unregister(&nct6775_driver);\r\nreturn err;\r\n}\r\nstatic void __exit sensors_nct6775_exit(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(pdev); i++) {\r\nif (pdev[i])\r\nplatform_device_unregister(pdev[i]);\r\n}\r\nplatform_driver_unregister(&nct6775_driver);\r\n}
