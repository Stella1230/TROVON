int dln2_register_event_cb(struct platform_device *pdev, u16 id,\r\ndln2_event_cb_t event_cb)\r\n{\r\nstruct dln2_dev *dln2 = dev_get_drvdata(pdev->dev.parent);\r\nstruct dln2_event_cb_entry *i, *entry;\r\nunsigned long flags;\r\nint ret = 0;\r\nentry = kzalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry)\r\nreturn -ENOMEM;\r\nentry->id = id;\r\nentry->callback = event_cb;\r\nentry->pdev = pdev;\r\nspin_lock_irqsave(&dln2->event_cb_lock, flags);\r\nlist_for_each_entry(i, &dln2->event_cb_list, list) {\r\nif (i->id == id) {\r\nret = -EBUSY;\r\nbreak;\r\n}\r\n}\r\nif (!ret)\r\nlist_add_rcu(&entry->list, &dln2->event_cb_list);\r\nspin_unlock_irqrestore(&dln2->event_cb_lock, flags);\r\nif (ret)\r\nkfree(entry);\r\nreturn ret;\r\n}\r\nvoid dln2_unregister_event_cb(struct platform_device *pdev, u16 id)\r\n{\r\nstruct dln2_dev *dln2 = dev_get_drvdata(pdev->dev.parent);\r\nstruct dln2_event_cb_entry *i;\r\nunsigned long flags;\r\nbool found = false;\r\nspin_lock_irqsave(&dln2->event_cb_lock, flags);\r\nlist_for_each_entry(i, &dln2->event_cb_list, list) {\r\nif (i->id == id) {\r\nlist_del_rcu(&i->list);\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&dln2->event_cb_lock, flags);\r\nif (found) {\r\nsynchronize_rcu();\r\nkfree(i);\r\n}\r\n}\r\nstatic bool dln2_transfer_complete(struct dln2_dev *dln2, struct urb *urb,\r\nu16 handle, u16 rx_slot)\r\n{\r\nstruct device *dev = &dln2->interface->dev;\r\nstruct dln2_mod_rx_slots *rxs = &dln2->mod_rx_slots[handle];\r\nstruct dln2_rx_context *rxc;\r\nbool valid_slot = false;\r\nif (rx_slot >= DLN2_MAX_RX_SLOTS)\r\ngoto out;\r\nrxc = &rxs->slots[rx_slot];\r\nspin_lock(&rxs->lock);\r\nif (rxc->in_use && !rxc->urb) {\r\nrxc->urb = urb;\r\ncomplete(&rxc->done);\r\nvalid_slot = true;\r\n}\r\nspin_unlock(&rxs->lock);\r\nout:\r\nif (!valid_slot)\r\ndev_warn(dev, "bad/late response %d/%d\n", handle, rx_slot);\r\nreturn valid_slot;\r\n}\r\nstatic void dln2_run_event_callbacks(struct dln2_dev *dln2, u16 id, u16 echo,\r\nvoid *data, int len)\r\n{\r\nstruct dln2_event_cb_entry *i;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(i, &dln2->event_cb_list, list) {\r\nif (i->id == id) {\r\ni->callback(i->pdev, echo, data, len);\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void dln2_rx(struct urb *urb)\r\n{\r\nstruct dln2_dev *dln2 = urb->context;\r\nstruct dln2_header *hdr = urb->transfer_buffer;\r\nstruct device *dev = &dln2->interface->dev;\r\nu16 id, echo, handle, size;\r\nu8 *data;\r\nint len;\r\nint err;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ncase -EPIPE:\r\ndev_dbg(dev, "urb shutting down with status %d\n", urb->status);\r\nreturn;\r\ndefault:\r\ndev_dbg(dev, "nonzero urb status received %d\n", urb->status);\r\ngoto out;\r\n}\r\nif (urb->actual_length < sizeof(struct dln2_header)) {\r\ndev_err(dev, "short response: %d\n", urb->actual_length);\r\ngoto out;\r\n}\r\nhandle = le16_to_cpu(hdr->handle);\r\nid = le16_to_cpu(hdr->id);\r\necho = le16_to_cpu(hdr->echo);\r\nsize = le16_to_cpu(hdr->size);\r\nif (size != urb->actual_length) {\r\ndev_err(dev, "size mismatch: handle %x cmd %x echo %x size %d actual %d\n",\r\nhandle, id, echo, size, urb->actual_length);\r\ngoto out;\r\n}\r\nif (handle >= DLN2_HANDLES) {\r\ndev_warn(dev, "invalid handle %d\n", handle);\r\ngoto out;\r\n}\r\ndata = urb->transfer_buffer + sizeof(struct dln2_header);\r\nlen = urb->actual_length - sizeof(struct dln2_header);\r\nif (handle == DLN2_HANDLE_EVENT) {\r\ndln2_run_event_callbacks(dln2, id, echo, data, len);\r\n} else {\r\nif (dln2_transfer_complete(dln2, urb, handle, echo))\r\nreturn;\r\n}\r\nout:\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err < 0)\r\ndev_err(dev, "failed to resubmit RX URB: %d\n", err);\r\n}\r\nstatic void *dln2_prep_buf(u16 handle, u16 cmd, u16 echo, const void *obuf,\r\nint *obuf_len, gfp_t gfp)\r\n{\r\nint len;\r\nvoid *buf;\r\nstruct dln2_header *hdr;\r\nlen = *obuf_len + sizeof(*hdr);\r\nbuf = kmalloc(len, gfp);\r\nif (!buf)\r\nreturn NULL;\r\nhdr = (struct dln2_header *)buf;\r\nhdr->id = cpu_to_le16(cmd);\r\nhdr->size = cpu_to_le16(len);\r\nhdr->echo = cpu_to_le16(echo);\r\nhdr->handle = cpu_to_le16(handle);\r\nmemcpy(buf + sizeof(*hdr), obuf, *obuf_len);\r\n*obuf_len = len;\r\nreturn buf;\r\n}\r\nstatic int dln2_send_wait(struct dln2_dev *dln2, u16 handle, u16 cmd, u16 echo,\r\nconst void *obuf, int obuf_len)\r\n{\r\nint ret = 0;\r\nint len = obuf_len;\r\nvoid *buf;\r\nint actual;\r\nbuf = dln2_prep_buf(handle, cmd, echo, obuf, &len, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = usb_bulk_msg(dln2->usb_dev,\r\nusb_sndbulkpipe(dln2->usb_dev, dln2->ep_out),\r\nbuf, len, &actual, DLN2_USB_TIMEOUT);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic bool find_free_slot(struct dln2_dev *dln2, u16 handle, int *slot)\r\n{\r\nstruct dln2_mod_rx_slots *rxs;\r\nunsigned long flags;\r\nif (dln2->disconnect) {\r\n*slot = -ENODEV;\r\nreturn true;\r\n}\r\nrxs = &dln2->mod_rx_slots[handle];\r\nspin_lock_irqsave(&rxs->lock, flags);\r\n*slot = find_first_zero_bit(rxs->bmap, DLN2_MAX_RX_SLOTS);\r\nif (*slot < DLN2_MAX_RX_SLOTS) {\r\nstruct dln2_rx_context *rxc = &rxs->slots[*slot];\r\nset_bit(*slot, rxs->bmap);\r\nrxc->in_use = true;\r\n}\r\nspin_unlock_irqrestore(&rxs->lock, flags);\r\nreturn *slot < DLN2_MAX_RX_SLOTS;\r\n}\r\nstatic int alloc_rx_slot(struct dln2_dev *dln2, u16 handle)\r\n{\r\nint ret;\r\nint slot;\r\nret = wait_event_interruptible(dln2->mod_rx_slots[handle].wq,\r\nfind_free_slot(dln2, handle, &slot));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn slot;\r\n}\r\nstatic void free_rx_slot(struct dln2_dev *dln2, u16 handle, int slot)\r\n{\r\nstruct dln2_mod_rx_slots *rxs;\r\nstruct urb *urb = NULL;\r\nunsigned long flags;\r\nstruct dln2_rx_context *rxc;\r\nrxs = &dln2->mod_rx_slots[handle];\r\nspin_lock_irqsave(&rxs->lock, flags);\r\nclear_bit(slot, rxs->bmap);\r\nrxc = &rxs->slots[slot];\r\nrxc->in_use = false;\r\nurb = rxc->urb;\r\nrxc->urb = NULL;\r\nreinit_completion(&rxc->done);\r\nspin_unlock_irqrestore(&rxs->lock, flags);\r\nif (urb) {\r\nint err;\r\nstruct device *dev = &dln2->interface->dev;\r\nerr = usb_submit_urb(urb, GFP_KERNEL);\r\nif (err < 0)\r\ndev_err(dev, "failed to resubmit RX URB: %d\n", err);\r\n}\r\nwake_up_interruptible(&rxs->wq);\r\n}\r\nstatic int _dln2_transfer(struct dln2_dev *dln2, u16 handle, u16 cmd,\r\nconst void *obuf, unsigned obuf_len,\r\nvoid *ibuf, unsigned *ibuf_len)\r\n{\r\nint ret = 0;\r\nint rx_slot;\r\nstruct dln2_response *rsp;\r\nstruct dln2_rx_context *rxc;\r\nstruct device *dev = &dln2->interface->dev;\r\nconst unsigned long timeout = msecs_to_jiffies(DLN2_USB_TIMEOUT);\r\nstruct dln2_mod_rx_slots *rxs = &dln2->mod_rx_slots[handle];\r\nint size;\r\nspin_lock(&dln2->disconnect_lock);\r\nif (!dln2->disconnect)\r\ndln2->active_transfers++;\r\nelse\r\nret = -ENODEV;\r\nspin_unlock(&dln2->disconnect_lock);\r\nif (ret)\r\nreturn ret;\r\nrx_slot = alloc_rx_slot(dln2, handle);\r\nif (rx_slot < 0) {\r\nret = rx_slot;\r\ngoto out_decr;\r\n}\r\nret = dln2_send_wait(dln2, handle, cmd, rx_slot, obuf, obuf_len);\r\nif (ret < 0) {\r\ndev_err(dev, "USB write failed: %d\n", ret);\r\ngoto out_free_rx_slot;\r\n}\r\nrxc = &rxs->slots[rx_slot];\r\nret = wait_for_completion_interruptible_timeout(&rxc->done, timeout);\r\nif (ret <= 0) {\r\nif (!ret)\r\nret = -ETIMEDOUT;\r\ngoto out_free_rx_slot;\r\n} else {\r\nret = 0;\r\n}\r\nif (dln2->disconnect) {\r\nret = -ENODEV;\r\ngoto out_free_rx_slot;\r\n}\r\nrsp = rxc->urb->transfer_buffer;\r\nsize = le16_to_cpu(rsp->hdr.size);\r\nif (size < sizeof(*rsp)) {\r\nret = -EPROTO;\r\ngoto out_free_rx_slot;\r\n}\r\nif (le16_to_cpu(rsp->result) > 0x80) {\r\ndev_dbg(dev, "%d received response with error %d\n",\r\nhandle, le16_to_cpu(rsp->result));\r\nret = -EREMOTEIO;\r\ngoto out_free_rx_slot;\r\n}\r\nif (!ibuf)\r\ngoto out_free_rx_slot;\r\nif (*ibuf_len > size - sizeof(*rsp))\r\n*ibuf_len = size - sizeof(*rsp);\r\nmemcpy(ibuf, rsp + 1, *ibuf_len);\r\nout_free_rx_slot:\r\nfree_rx_slot(dln2, handle, rx_slot);\r\nout_decr:\r\nspin_lock(&dln2->disconnect_lock);\r\ndln2->active_transfers--;\r\nspin_unlock(&dln2->disconnect_lock);\r\nif (dln2->disconnect)\r\nwake_up(&dln2->disconnect_wq);\r\nreturn ret;\r\n}\r\nint dln2_transfer(struct platform_device *pdev, u16 cmd,\r\nconst void *obuf, unsigned obuf_len,\r\nvoid *ibuf, unsigned *ibuf_len)\r\n{\r\nstruct dln2_platform_data *dln2_pdata;\r\nstruct dln2_dev *dln2;\r\nu16 handle;\r\ndln2 = dev_get_drvdata(pdev->dev.parent);\r\ndln2_pdata = dev_get_platdata(&pdev->dev);\r\nhandle = dln2_pdata->handle;\r\nreturn _dln2_transfer(dln2, handle, cmd, obuf, obuf_len, ibuf,\r\nibuf_len);\r\n}\r\nstatic int dln2_check_hw(struct dln2_dev *dln2)\r\n{\r\nint ret;\r\n__le32 hw_type;\r\nint len = sizeof(hw_type);\r\nret = _dln2_transfer(dln2, DLN2_HANDLE_CTRL, CMD_GET_DEVICE_VER,\r\nNULL, 0, &hw_type, &len);\r\nif (ret < 0)\r\nreturn ret;\r\nif (len < sizeof(hw_type))\r\nreturn -EREMOTEIO;\r\nif (le32_to_cpu(hw_type) != DLN2_HW_ID) {\r\ndev_err(&dln2->interface->dev, "Device ID 0x%x not supported\n",\r\nle32_to_cpu(hw_type));\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dln2_print_serialno(struct dln2_dev *dln2)\r\n{\r\nint ret;\r\n__le32 serial_no;\r\nint len = sizeof(serial_no);\r\nstruct device *dev = &dln2->interface->dev;\r\nret = _dln2_transfer(dln2, DLN2_HANDLE_CTRL, CMD_GET_DEVICE_SN, NULL, 0,\r\n&serial_no, &len);\r\nif (ret < 0)\r\nreturn ret;\r\nif (len < sizeof(serial_no))\r\nreturn -EREMOTEIO;\r\ndev_info(dev, "Diolan DLN2 serial %u\n", le32_to_cpu(serial_no));\r\nreturn 0;\r\n}\r\nstatic int dln2_hw_init(struct dln2_dev *dln2)\r\n{\r\nint ret;\r\nret = dln2_check_hw(dln2);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn dln2_print_serialno(dln2);\r\n}\r\nstatic void dln2_free_rx_urbs(struct dln2_dev *dln2)\r\n{\r\nint i;\r\nfor (i = 0; i < DLN2_MAX_URBS; i++) {\r\nusb_free_urb(dln2->rx_urb[i]);\r\nkfree(dln2->rx_buf[i]);\r\n}\r\n}\r\nstatic void dln2_stop_rx_urbs(struct dln2_dev *dln2)\r\n{\r\nint i;\r\nfor (i = 0; i < DLN2_MAX_URBS; i++)\r\nusb_kill_urb(dln2->rx_urb[i]);\r\n}\r\nstatic void dln2_free(struct dln2_dev *dln2)\r\n{\r\ndln2_free_rx_urbs(dln2);\r\nusb_put_dev(dln2->usb_dev);\r\nkfree(dln2);\r\n}\r\nstatic int dln2_setup_rx_urbs(struct dln2_dev *dln2,\r\nstruct usb_host_interface *hostif)\r\n{\r\nint i;\r\nconst int rx_max_size = DLN2_RX_BUF_SIZE;\r\nfor (i = 0; i < DLN2_MAX_URBS; i++) {\r\ndln2->rx_buf[i] = kmalloc(rx_max_size, GFP_KERNEL);\r\nif (!dln2->rx_buf[i])\r\nreturn -ENOMEM;\r\ndln2->rx_urb[i] = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!dln2->rx_urb[i])\r\nreturn -ENOMEM;\r\nusb_fill_bulk_urb(dln2->rx_urb[i], dln2->usb_dev,\r\nusb_rcvbulkpipe(dln2->usb_dev, dln2->ep_in),\r\ndln2->rx_buf[i], rx_max_size, dln2_rx, dln2);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dln2_start_rx_urbs(struct dln2_dev *dln2, gfp_t gfp)\r\n{\r\nstruct device *dev = &dln2->interface->dev;\r\nint ret;\r\nint i;\r\nfor (i = 0; i < DLN2_MAX_URBS; i++) {\r\nret = usb_submit_urb(dln2->rx_urb[i], gfp);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to submit RX URB: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void dln2_stop(struct dln2_dev *dln2)\r\n{\r\nint i, j;\r\nspin_lock(&dln2->disconnect_lock);\r\ndln2->disconnect = true;\r\nspin_unlock(&dln2->disconnect_lock);\r\nfor (i = 0; i < DLN2_HANDLES; i++) {\r\nstruct dln2_mod_rx_slots *rxs = &dln2->mod_rx_slots[i];\r\nunsigned long flags;\r\nspin_lock_irqsave(&rxs->lock, flags);\r\nfor (j = 0; j < DLN2_MAX_RX_SLOTS; j++) {\r\nstruct dln2_rx_context *rxc = &rxs->slots[j];\r\nif (rxc->in_use)\r\ncomplete(&rxc->done);\r\n}\r\nspin_unlock_irqrestore(&rxs->lock, flags);\r\n}\r\nwait_event(dln2->disconnect_wq, !dln2->active_transfers);\r\ndln2_stop_rx_urbs(dln2);\r\n}\r\nstatic void dln2_disconnect(struct usb_interface *interface)\r\n{\r\nstruct dln2_dev *dln2 = usb_get_intfdata(interface);\r\ndln2_stop(dln2);\r\nmfd_remove_devices(&interface->dev);\r\ndln2_free(dln2);\r\n}\r\nstatic int dln2_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *usb_id)\r\n{\r\nstruct usb_host_interface *hostif = interface->cur_altsetting;\r\nstruct device *dev = &interface->dev;\r\nstruct dln2_dev *dln2;\r\nint ret;\r\nint i, j;\r\nif (hostif->desc.bInterfaceNumber != 0 ||\r\nhostif->desc.bNumEndpoints < 2)\r\nreturn -ENODEV;\r\ndln2 = kzalloc(sizeof(*dln2), GFP_KERNEL);\r\nif (!dln2)\r\nreturn -ENOMEM;\r\ndln2->ep_out = hostif->endpoint[0].desc.bEndpointAddress;\r\ndln2->ep_in = hostif->endpoint[1].desc.bEndpointAddress;\r\ndln2->usb_dev = usb_get_dev(interface_to_usbdev(interface));\r\ndln2->interface = interface;\r\nusb_set_intfdata(interface, dln2);\r\ninit_waitqueue_head(&dln2->disconnect_wq);\r\nfor (i = 0; i < DLN2_HANDLES; i++) {\r\ninit_waitqueue_head(&dln2->mod_rx_slots[i].wq);\r\nspin_lock_init(&dln2->mod_rx_slots[i].lock);\r\nfor (j = 0; j < DLN2_MAX_RX_SLOTS; j++)\r\ninit_completion(&dln2->mod_rx_slots[i].slots[j].done);\r\n}\r\nspin_lock_init(&dln2->event_cb_lock);\r\nspin_lock_init(&dln2->disconnect_lock);\r\nINIT_LIST_HEAD(&dln2->event_cb_list);\r\nret = dln2_setup_rx_urbs(dln2, hostif);\r\nif (ret)\r\ngoto out_free;\r\nret = dln2_start_rx_urbs(dln2, GFP_KERNEL);\r\nif (ret)\r\ngoto out_stop_rx;\r\nret = dln2_hw_init(dln2);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to initialize hardware\n");\r\ngoto out_stop_rx;\r\n}\r\nret = mfd_add_hotplug_devices(dev, dln2_devs, ARRAY_SIZE(dln2_devs));\r\nif (ret != 0) {\r\ndev_err(dev, "failed to add mfd devices to core\n");\r\ngoto out_stop_rx;\r\n}\r\nreturn 0;\r\nout_stop_rx:\r\ndln2_stop_rx_urbs(dln2);\r\nout_free:\r\ndln2_free(dln2);\r\nreturn ret;\r\n}\r\nstatic int dln2_suspend(struct usb_interface *iface, pm_message_t message)\r\n{\r\nstruct dln2_dev *dln2 = usb_get_intfdata(iface);\r\ndln2_stop(dln2);\r\nreturn 0;\r\n}\r\nstatic int dln2_resume(struct usb_interface *iface)\r\n{\r\nstruct dln2_dev *dln2 = usb_get_intfdata(iface);\r\ndln2->disconnect = false;\r\nreturn dln2_start_rx_urbs(dln2, GFP_NOIO);\r\n}
