static void atmel_nand_enable(struct atmel_nand_host *host)\r\n{\r\nif (gpio_is_valid(host->board.enable_pin))\r\ngpio_set_value(host->board.enable_pin, 0);\r\n}\r\nstatic void atmel_nand_disable(struct atmel_nand_host *host)\r\n{\r\nif (gpio_is_valid(host->board.enable_pin))\r\ngpio_set_value(host->board.enable_pin, 1);\r\n}\r\nstatic void atmel_nand_cmd_ctrl(struct mtd_info *mtd, int cmd, unsigned int ctrl)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nif (ctrl & NAND_CTRL_CHANGE) {\r\nif (ctrl & NAND_NCE)\r\natmel_nand_enable(host);\r\nelse\r\natmel_nand_disable(host);\r\n}\r\nif (cmd == NAND_CMD_NONE)\r\nreturn;\r\nif (ctrl & NAND_CLE)\r\nwriteb(cmd, host->io_base + (1 << host->board.cle));\r\nelse\r\nwriteb(cmd, host->io_base + (1 << host->board.ale));\r\n}\r\nstatic int atmel_nand_device_ready(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nreturn gpio_get_value(host->board.rdy_pin) ^\r\n!!host->board.rdy_pin_active_low;\r\n}\r\nstatic int atmel_nand_set_enable_ready_pins(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct atmel_nand_host *host = chip->priv;\r\nint res = 0;\r\nif (gpio_is_valid(host->board.rdy_pin)) {\r\nres = devm_gpio_request(host->dev,\r\nhost->board.rdy_pin, "nand_rdy");\r\nif (res < 0) {\r\ndev_err(host->dev,\r\n"can't request rdy gpio %d\n",\r\nhost->board.rdy_pin);\r\nreturn res;\r\n}\r\nres = gpio_direction_input(host->board.rdy_pin);\r\nif (res < 0) {\r\ndev_err(host->dev,\r\n"can't request input direction rdy gpio %d\n",\r\nhost->board.rdy_pin);\r\nreturn res;\r\n}\r\nchip->dev_ready = atmel_nand_device_ready;\r\n}\r\nif (gpio_is_valid(host->board.enable_pin)) {\r\nres = devm_gpio_request(host->dev,\r\nhost->board.enable_pin, "nand_enable");\r\nif (res < 0) {\r\ndev_err(host->dev,\r\n"can't request enable gpio %d\n",\r\nhost->board.enable_pin);\r\nreturn res;\r\n}\r\nres = gpio_direction_output(host->board.enable_pin, 1);\r\nif (res < 0) {\r\ndev_err(host->dev,\r\n"can't request output direction enable gpio %d\n",\r\nhost->board.enable_pin);\r\nreturn res;\r\n}\r\n}\r\nreturn res;\r\n}\r\nstatic void atmel_read_buf8(struct mtd_info *mtd, u8 *buf, int len)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nif (host->nfc && host->nfc->use_nfc_sram && host->nfc->data_in_sram) {\r\nmemcpy(buf, host->nfc->data_in_sram, len);\r\nhost->nfc->data_in_sram += len;\r\n} else {\r\n__raw_readsb(nand_chip->IO_ADDR_R, buf, len);\r\n}\r\n}\r\nstatic void atmel_read_buf16(struct mtd_info *mtd, u8 *buf, int len)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nif (host->nfc && host->nfc->use_nfc_sram && host->nfc->data_in_sram) {\r\nmemcpy(buf, host->nfc->data_in_sram, len);\r\nhost->nfc->data_in_sram += len;\r\n} else {\r\n__raw_readsw(nand_chip->IO_ADDR_R, buf, len / 2);\r\n}\r\n}\r\nstatic void atmel_write_buf8(struct mtd_info *mtd, const u8 *buf, int len)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\n__raw_writesb(nand_chip->IO_ADDR_W, buf, len);\r\n}\r\nstatic void atmel_write_buf16(struct mtd_info *mtd, const u8 *buf, int len)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\n__raw_writesw(nand_chip->IO_ADDR_W, buf, len / 2);\r\n}\r\nstatic void dma_complete_func(void *completion)\r\n{\r\ncomplete(completion);\r\n}\r\nstatic int nfc_set_sram_bank(struct atmel_nand_host *host, unsigned int bank)\r\n{\r\nif (bank > 1)\r\nreturn -EINVAL;\r\nif (bank) {\r\nif (host->mtd.writesize > 2048)\r\nreturn -EINVAL;\r\nnfc_writel(host->nfc->hsmc_regs, BANK, ATMEL_HSMC_NFC_BANK1);\r\n} else {\r\nnfc_writel(host->nfc->hsmc_regs, BANK, ATMEL_HSMC_NFC_BANK0);\r\n}\r\nreturn 0;\r\n}\r\nstatic uint nfc_get_sram_off(struct atmel_nand_host *host)\r\n{\r\nif (nfc_readl(host->nfc->hsmc_regs, BANK) & ATMEL_HSMC_NFC_BANK1)\r\nreturn NFC_SRAM_BANK1_OFFSET;\r\nelse\r\nreturn 0;\r\n}\r\nstatic dma_addr_t nfc_sram_phys(struct atmel_nand_host *host)\r\n{\r\nif (nfc_readl(host->nfc->hsmc_regs, BANK) & ATMEL_HSMC_NFC_BANK1)\r\nreturn host->nfc->sram_bank0_phys + NFC_SRAM_BANK1_OFFSET;\r\nelse\r\nreturn host->nfc->sram_bank0_phys;\r\n}\r\nstatic int atmel_nand_dma_op(struct mtd_info *mtd, void *buf, int len,\r\nint is_read)\r\n{\r\nstruct dma_device *dma_dev;\r\nenum dma_ctrl_flags flags;\r\ndma_addr_t dma_src_addr, dma_dst_addr, phys_addr;\r\nstruct dma_async_tx_descriptor *tx = NULL;\r\ndma_cookie_t cookie;\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct atmel_nand_host *host = chip->priv;\r\nvoid *p = buf;\r\nint err = -EIO;\r\nenum dma_data_direction dir = is_read ? DMA_FROM_DEVICE : DMA_TO_DEVICE;\r\nstruct atmel_nfc *nfc = host->nfc;\r\nif (buf >= high_memory)\r\ngoto err_buf;\r\ndma_dev = host->dma_chan->device;\r\nflags = DMA_CTRL_ACK | DMA_PREP_INTERRUPT;\r\nphys_addr = dma_map_single(dma_dev->dev, p, len, dir);\r\nif (dma_mapping_error(dma_dev->dev, phys_addr)) {\r\ndev_err(host->dev, "Failed to dma_map_single\n");\r\ngoto err_buf;\r\n}\r\nif (is_read) {\r\nif (nfc && nfc->data_in_sram)\r\ndma_src_addr = nfc_sram_phys(host) + (nfc->data_in_sram\r\n- (nfc->sram_bank0 + nfc_get_sram_off(host)));\r\nelse\r\ndma_src_addr = host->io_phys;\r\ndma_dst_addr = phys_addr;\r\n} else {\r\ndma_src_addr = phys_addr;\r\nif (nfc && nfc->write_by_sram)\r\ndma_dst_addr = nfc_sram_phys(host);\r\nelse\r\ndma_dst_addr = host->io_phys;\r\n}\r\ntx = dma_dev->device_prep_dma_memcpy(host->dma_chan, dma_dst_addr,\r\ndma_src_addr, len, flags);\r\nif (!tx) {\r\ndev_err(host->dev, "Failed to prepare DMA memcpy\n");\r\ngoto err_dma;\r\n}\r\ninit_completion(&host->comp);\r\ntx->callback = dma_complete_func;\r\ntx->callback_param = &host->comp;\r\ncookie = tx->tx_submit(tx);\r\nif (dma_submit_error(cookie)) {\r\ndev_err(host->dev, "Failed to do DMA tx_submit\n");\r\ngoto err_dma;\r\n}\r\ndma_async_issue_pending(host->dma_chan);\r\nwait_for_completion(&host->comp);\r\nif (is_read && nfc && nfc->data_in_sram)\r\nnfc->data_in_sram += len;\r\nerr = 0;\r\nerr_dma:\r\ndma_unmap_single(dma_dev->dev, phys_addr, len, dir);\r\nerr_buf:\r\nif (err != 0)\r\ndev_dbg(host->dev, "Fall back to CPU I/O\n");\r\nreturn err;\r\n}\r\nstatic void atmel_read_buf(struct mtd_info *mtd, u8 *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct atmel_nand_host *host = chip->priv;\r\nif (use_dma && len > mtd->oobsize)\r\nif (atmel_nand_dma_op(mtd, buf, len, 1) == 0)\r\nreturn;\r\nif (host->board.bus_width_16)\r\natmel_read_buf16(mtd, buf, len);\r\nelse\r\natmel_read_buf8(mtd, buf, len);\r\n}\r\nstatic void atmel_write_buf(struct mtd_info *mtd, const u8 *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct atmel_nand_host *host = chip->priv;\r\nif (use_dma && len > mtd->oobsize)\r\nif (atmel_nand_dma_op(mtd, (void *)buf, len, 0) == 0)\r\nreturn;\r\nif (host->board.bus_width_16)\r\natmel_write_buf16(mtd, buf, len);\r\nelse\r\natmel_write_buf8(mtd, buf, len);\r\n}\r\nstatic int pmecc_get_ecc_bytes(int cap, int sector_size)\r\n{\r\nint m = 12 + sector_size / 512;\r\nreturn (m * cap + 7) / 8;\r\n}\r\nstatic void pmecc_config_ecc_layout(struct nand_ecclayout *layout,\r\nint oobsize, int ecc_len)\r\n{\r\nint i;\r\nlayout->eccbytes = ecc_len;\r\nfor (i = 0; i < ecc_len; i++)\r\nlayout->eccpos[i] = oobsize - ecc_len + i;\r\nlayout->oobfree[0].offset = PMECC_OOB_RESERVED_BYTES;\r\nlayout->oobfree[0].length =\r\noobsize - ecc_len - layout->oobfree[0].offset;\r\n}\r\nstatic void __iomem *pmecc_get_alpha_to(struct atmel_nand_host *host)\r\n{\r\nint table_size;\r\ntable_size = host->pmecc_sector_size == 512 ?\r\nPMECC_LOOKUP_TABLE_SIZE_512 : PMECC_LOOKUP_TABLE_SIZE_1024;\r\nreturn host->pmecc_rom_base + host->pmecc_lookup_table_offset +\r\ntable_size * sizeof(int16_t);\r\n}\r\nstatic int pmecc_data_alloc(struct atmel_nand_host *host)\r\n{\r\nconst int cap = host->pmecc_corr_cap;\r\nint size;\r\nsize = (2 * cap + 1) * sizeof(int16_t);\r\nhost->pmecc_partial_syn = devm_kzalloc(host->dev, size, GFP_KERNEL);\r\nhost->pmecc_si = devm_kzalloc(host->dev, size, GFP_KERNEL);\r\nhost->pmecc_lmu = devm_kzalloc(host->dev,\r\n(cap + 1) * sizeof(int16_t), GFP_KERNEL);\r\nhost->pmecc_smu = devm_kzalloc(host->dev,\r\n(cap + 2) * size, GFP_KERNEL);\r\nsize = (cap + 1) * sizeof(int);\r\nhost->pmecc_mu = devm_kzalloc(host->dev, size, GFP_KERNEL);\r\nhost->pmecc_dmu = devm_kzalloc(host->dev, size, GFP_KERNEL);\r\nhost->pmecc_delta = devm_kzalloc(host->dev, size, GFP_KERNEL);\r\nif (!host->pmecc_partial_syn ||\r\n!host->pmecc_si ||\r\n!host->pmecc_lmu ||\r\n!host->pmecc_smu ||\r\n!host->pmecc_mu ||\r\n!host->pmecc_dmu ||\r\n!host->pmecc_delta)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void pmecc_gen_syndrome(struct mtd_info *mtd, int sector)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nint i;\r\nuint32_t value;\r\nfor (i = 0; i < host->pmecc_corr_cap; i++) {\r\nvalue = pmecc_readl_rem_relaxed(host->ecc, sector, i / 2);\r\nif (i & 1)\r\nvalue >>= 16;\r\nvalue &= 0xffff;\r\nhost->pmecc_partial_syn[(2 * i) + 1] = (int16_t)value;\r\n}\r\n}\r\nstatic void pmecc_substitute(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nint16_t __iomem *alpha_to = host->pmecc_alpha_to;\r\nint16_t __iomem *index_of = host->pmecc_index_of;\r\nint16_t *partial_syn = host->pmecc_partial_syn;\r\nconst int cap = host->pmecc_corr_cap;\r\nint16_t *si;\r\nint i, j;\r\nsi = host->pmecc_si;\r\nmemset(&si[1], 0, sizeof(int16_t) * (2 * cap - 1));\r\nfor (i = 1; i < 2 * cap; i += 2) {\r\nfor (j = 0; j < host->pmecc_degree; j++) {\r\nif (partial_syn[i] & ((unsigned short)0x1 << j))\r\nsi[i] = readw_relaxed(alpha_to + i * j) ^ si[i];\r\n}\r\n}\r\nfor (i = 2, j = 1; j <= cap; i = ++j << 1) {\r\nif (si[j] == 0) {\r\nsi[i] = 0;\r\n} else {\r\nint16_t tmp;\r\ntmp = readw_relaxed(index_of + si[j]);\r\ntmp = (tmp * 2) % host->pmecc_cw_len;\r\nsi[i] = readw_relaxed(alpha_to + tmp);\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic void pmecc_get_sigma(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nint16_t *lmu = host->pmecc_lmu;\r\nint16_t *si = host->pmecc_si;\r\nint *mu = host->pmecc_mu;\r\nint *dmu = host->pmecc_dmu;\r\nint *delta = host->pmecc_delta;\r\nint cw_len = host->pmecc_cw_len;\r\nconst int16_t cap = host->pmecc_corr_cap;\r\nconst int num = 2 * cap + 1;\r\nint16_t __iomem *index_of = host->pmecc_index_of;\r\nint16_t __iomem *alpha_to = host->pmecc_alpha_to;\r\nint i, j, k;\r\nuint32_t dmu_0_count, tmp;\r\nint16_t *smu = host->pmecc_smu;\r\nint ro;\r\nint largest;\r\nint diff;\r\ndmu_0_count = 0;\r\nmu[0] = -1;\r\nmemset(smu, 0, sizeof(int16_t) * num);\r\nsmu[0] = 1;\r\ndmu[0] = 1;\r\nlmu[0] = 0;\r\ndelta[0] = (mu[0] * 2 - lmu[0]) >> 1;\r\nmu[1] = 0;\r\nmemset(&smu[num], 0, sizeof(int16_t) * num);\r\nsmu[num] = 1;\r\ndmu[1] = si[1];\r\nlmu[1] = 0;\r\ndelta[1] = (mu[1] * 2 - lmu[1]) >> 1;\r\nmemset(&smu[(cap + 1) * num], 0, sizeof(int16_t) * num);\r\nfor (i = 1; i <= cap; i++) {\r\nmu[i + 1] = i << 1;\r\nif (dmu[i] == 0) {\r\ndmu_0_count++;\r\ntmp = ((cap - (lmu[i] >> 1) - 1) / 2);\r\nif ((cap - (lmu[i] >> 1) - 1) & 0x1)\r\ntmp += 2;\r\nelse\r\ntmp += 1;\r\nif (dmu_0_count == tmp) {\r\nfor (j = 0; j <= (lmu[i] >> 1) + 1; j++)\r\nsmu[(cap + 1) * num + j] =\r\nsmu[i * num + j];\r\nlmu[cap + 1] = lmu[i];\r\nreturn;\r\n}\r\nfor (j = 0; j <= lmu[i] >> 1; j++)\r\nsmu[(i + 1) * num + j] = smu[i * num + j];\r\nlmu[i + 1] = lmu[i];\r\n} else {\r\nro = 0;\r\nlargest = -1;\r\nfor (j = 0; j < i; j++) {\r\nif ((dmu[j]) && (delta[j] > largest)) {\r\nlargest = delta[j];\r\nro = j;\r\n}\r\n}\r\ndiff = (mu[i] - mu[ro]);\r\nif ((lmu[i] >> 1) > ((lmu[ro] >> 1) + diff))\r\nlmu[i + 1] = lmu[i];\r\nelse\r\nlmu[i + 1] = ((lmu[ro] >> 1) + diff) * 2;\r\nfor (k = 0; k < num; k++)\r\nsmu[(i + 1) * num + k] = 0;\r\nfor (k = 0; k <= lmu[ro] >> 1; k++) {\r\nint16_t a, b, c;\r\nif (!(smu[ro * num + k] && dmu[i]))\r\ncontinue;\r\na = readw_relaxed(index_of + dmu[i]);\r\nb = readw_relaxed(index_of + dmu[ro]);\r\nc = readw_relaxed(index_of + smu[ro * num + k]);\r\ntmp = a + (cw_len - b) + c;\r\na = readw_relaxed(alpha_to + tmp % cw_len);\r\nsmu[(i + 1) * num + (k + diff)] = a;\r\n}\r\nfor (k = 0; k <= lmu[i] >> 1; k++)\r\nsmu[(i + 1) * num + k] ^= smu[i * num + k];\r\n}\r\ndelta[i + 1] = (mu[i + 1] * 2 - lmu[i + 1]) >> 1;\r\nif (i >= cap)\r\ncontinue;\r\nfor (k = 0; k <= (lmu[i + 1] >> 1); k++) {\r\ntmp = 2 * (i - 1);\r\nif (k == 0) {\r\ndmu[i + 1] = si[tmp + 3];\r\n} else if (smu[(i + 1) * num + k] && si[tmp + 3 - k]) {\r\nint16_t a, b, c;\r\na = readw_relaxed(index_of +\r\nsmu[(i + 1) * num + k]);\r\nb = si[2 * (i - 1) + 3 - k];\r\nc = readw_relaxed(index_of + b);\r\ntmp = a + c;\r\ntmp %= cw_len;\r\ndmu[i + 1] = readw_relaxed(alpha_to + tmp) ^\r\ndmu[i + 1];\r\n}\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic int pmecc_err_location(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nunsigned long end_time;\r\nconst int cap = host->pmecc_corr_cap;\r\nconst int num = 2 * cap + 1;\r\nint sector_size = host->pmecc_sector_size;\r\nint err_nbr = 0;\r\nint roots_nbr;\r\nint i;\r\nuint32_t val;\r\nint16_t *smu = host->pmecc_smu;\r\npmerrloc_writel(host->pmerrloc_base, ELDIS, PMERRLOC_DISABLE);\r\nfor (i = 0; i <= host->pmecc_lmu[cap + 1] >> 1; i++) {\r\npmerrloc_writel_sigma_relaxed(host->pmerrloc_base, i,\r\nsmu[(cap + 1) * num + i]);\r\nerr_nbr++;\r\n}\r\nval = (err_nbr - 1) << 16;\r\nif (sector_size == 1024)\r\nval |= 1;\r\npmerrloc_writel(host->pmerrloc_base, ELCFG, val);\r\npmerrloc_writel(host->pmerrloc_base, ELEN,\r\nsector_size * 8 + host->pmecc_degree * cap);\r\nend_time = jiffies + msecs_to_jiffies(PMECC_MAX_TIMEOUT_MS);\r\nwhile (!(pmerrloc_readl_relaxed(host->pmerrloc_base, ELISR)\r\n& PMERRLOC_CALC_DONE)) {\r\nif (unlikely(time_after(jiffies, end_time))) {\r\ndev_err(host->dev, "PMECC: Timeout to calculate error location.\n");\r\nreturn -1;\r\n}\r\ncpu_relax();\r\n}\r\nroots_nbr = (pmerrloc_readl_relaxed(host->pmerrloc_base, ELISR)\r\n& PMERRLOC_ERR_NUM_MASK) >> 8;\r\nif (roots_nbr == host->pmecc_lmu[cap + 1] >> 1)\r\nreturn err_nbr - 1;\r\nreturn -1;\r\n}\r\nstatic void pmecc_correct_data(struct mtd_info *mtd, uint8_t *buf, uint8_t *ecc,\r\nint sector_num, int extra_bytes, int err_nbr)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nint i = 0;\r\nint byte_pos, bit_pos, sector_size, pos;\r\nuint32_t tmp;\r\nuint8_t err_byte;\r\nsector_size = host->pmecc_sector_size;\r\nwhile (err_nbr) {\r\ntmp = pmerrloc_readl_el_relaxed(host->pmerrloc_base, i) - 1;\r\nbyte_pos = tmp / 8;\r\nbit_pos = tmp % 8;\r\nif (byte_pos >= (sector_size + extra_bytes))\r\nBUG();\r\nif (byte_pos < sector_size) {\r\nerr_byte = *(buf + byte_pos);\r\n*(buf + byte_pos) ^= (1 << bit_pos);\r\npos = sector_num * host->pmecc_sector_size + byte_pos;\r\ndev_info(host->dev, "Bit flip in data area, byte_pos: %d, bit_pos: %d, 0x%02x -> 0x%02x\n",\r\npos, bit_pos, err_byte, *(buf + byte_pos));\r\n} else {\r\ntmp = sector_num * nand_chip->ecc.bytes\r\n+ (byte_pos - sector_size);\r\nerr_byte = ecc[tmp];\r\necc[tmp] ^= (1 << bit_pos);\r\npos = tmp + nand_chip->ecc.layout->eccpos[0];\r\ndev_info(host->dev, "Bit flip in OOB, oob_byte_pos: %d, bit_pos: %d, 0x%02x -> 0x%02x\n",\r\npos, bit_pos, err_byte, ecc[tmp]);\r\n}\r\ni++;\r\nerr_nbr--;\r\n}\r\nreturn;\r\n}\r\nstatic int pmecc_correction(struct mtd_info *mtd, u32 pmecc_stat, uint8_t *buf,\r\nu8 *ecc)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nint i, err_nbr;\r\nuint8_t *buf_pos;\r\nint max_bitflips = 0;\r\nif (host->caps->pmecc_correct_erase_page)\r\ngoto normal_check;\r\nfor (i = 0; i < nand_chip->ecc.total; i++)\r\nif (ecc[i] != 0xff)\r\ngoto normal_check;\r\nreturn 0;\r\nnormal_check:\r\nfor (i = 0; i < nand_chip->ecc.steps; i++) {\r\nerr_nbr = 0;\r\nif (pmecc_stat & 0x1) {\r\nbuf_pos = buf + i * host->pmecc_sector_size;\r\npmecc_gen_syndrome(mtd, i);\r\npmecc_substitute(mtd);\r\npmecc_get_sigma(mtd);\r\nerr_nbr = pmecc_err_location(mtd);\r\nif (err_nbr == -1) {\r\ndev_err(host->dev, "PMECC: Too many errors\n");\r\nmtd->ecc_stats.failed++;\r\nreturn -EIO;\r\n} else {\r\npmecc_correct_data(mtd, buf_pos, ecc, i,\r\nnand_chip->ecc.bytes, err_nbr);\r\nmtd->ecc_stats.corrected += err_nbr;\r\nmax_bitflips = max_t(int, max_bitflips, err_nbr);\r\n}\r\n}\r\npmecc_stat >>= 1;\r\n}\r\nreturn max_bitflips;\r\n}\r\nstatic void pmecc_enable(struct atmel_nand_host *host, int ecc_op)\r\n{\r\nu32 val;\r\nif (ecc_op != NAND_ECC_READ && ecc_op != NAND_ECC_WRITE) {\r\ndev_err(host->dev, "atmel_nand: wrong pmecc operation type!");\r\nreturn;\r\n}\r\npmecc_writel(host->ecc, CTRL, PMECC_CTRL_RST);\r\npmecc_writel(host->ecc, CTRL, PMECC_CTRL_DISABLE);\r\nval = pmecc_readl_relaxed(host->ecc, CFG);\r\nif (ecc_op == NAND_ECC_READ)\r\npmecc_writel(host->ecc, CFG, (val & ~PMECC_CFG_WRITE_OP)\r\n| PMECC_CFG_AUTO_ENABLE);\r\nelse\r\npmecc_writel(host->ecc, CFG, (val | PMECC_CFG_WRITE_OP)\r\n& ~PMECC_CFG_AUTO_ENABLE);\r\npmecc_writel(host->ecc, CTRL, PMECC_CTRL_ENABLE);\r\npmecc_writel(host->ecc, CTRL, PMECC_CTRL_DATA);\r\n}\r\nstatic int atmel_nand_pmecc_read_page(struct mtd_info *mtd,\r\nstruct nand_chip *chip, uint8_t *buf, int oob_required, int page)\r\n{\r\nstruct atmel_nand_host *host = chip->priv;\r\nint eccsize = chip->ecc.size * chip->ecc.steps;\r\nuint8_t *oob = chip->oob_poi;\r\nuint32_t *eccpos = chip->ecc.layout->eccpos;\r\nuint32_t stat;\r\nunsigned long end_time;\r\nint bitflips = 0;\r\nif (!host->nfc || !host->nfc->use_nfc_sram)\r\npmecc_enable(host, NAND_ECC_READ);\r\nchip->read_buf(mtd, buf, eccsize);\r\nchip->read_buf(mtd, oob, mtd->oobsize);\r\nend_time = jiffies + msecs_to_jiffies(PMECC_MAX_TIMEOUT_MS);\r\nwhile ((pmecc_readl_relaxed(host->ecc, SR) & PMECC_SR_BUSY)) {\r\nif (unlikely(time_after(jiffies, end_time))) {\r\ndev_err(host->dev, "PMECC: Timeout to get error status.\n");\r\nreturn -EIO;\r\n}\r\ncpu_relax();\r\n}\r\nstat = pmecc_readl_relaxed(host->ecc, ISR);\r\nif (stat != 0) {\r\nbitflips = pmecc_correction(mtd, stat, buf, &oob[eccpos[0]]);\r\nif (bitflips < 0)\r\nreturn 0;\r\n}\r\nreturn bitflips;\r\n}\r\nstatic int atmel_nand_pmecc_write_page(struct mtd_info *mtd,\r\nstruct nand_chip *chip, const uint8_t *buf, int oob_required)\r\n{\r\nstruct atmel_nand_host *host = chip->priv;\r\nuint32_t *eccpos = chip->ecc.layout->eccpos;\r\nint i, j;\r\nunsigned long end_time;\r\nif (!host->nfc || !host->nfc->write_by_sram) {\r\npmecc_enable(host, NAND_ECC_WRITE);\r\nchip->write_buf(mtd, (u8 *)buf, mtd->writesize);\r\n}\r\nend_time = jiffies + msecs_to_jiffies(PMECC_MAX_TIMEOUT_MS);\r\nwhile ((pmecc_readl_relaxed(host->ecc, SR) & PMECC_SR_BUSY)) {\r\nif (unlikely(time_after(jiffies, end_time))) {\r\ndev_err(host->dev, "PMECC: Timeout to get ECC value.\n");\r\nreturn -EIO;\r\n}\r\ncpu_relax();\r\n}\r\nfor (i = 0; i < chip->ecc.steps; i++) {\r\nfor (j = 0; j < chip->ecc.bytes; j++) {\r\nint pos;\r\npos = i * chip->ecc.bytes + j;\r\nchip->oob_poi[eccpos[pos]] =\r\npmecc_readb_ecc_relaxed(host->ecc, i, j);\r\n}\r\n}\r\nchip->write_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nreturn 0;\r\n}\r\nstatic void atmel_pmecc_core_init(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nuint32_t val = 0;\r\nstruct nand_ecclayout *ecc_layout;\r\npmecc_writel(host->ecc, CTRL, PMECC_CTRL_RST);\r\npmecc_writel(host->ecc, CTRL, PMECC_CTRL_DISABLE);\r\nswitch (host->pmecc_corr_cap) {\r\ncase 2:\r\nval = PMECC_CFG_BCH_ERR2;\r\nbreak;\r\ncase 4:\r\nval = PMECC_CFG_BCH_ERR4;\r\nbreak;\r\ncase 8:\r\nval = PMECC_CFG_BCH_ERR8;\r\nbreak;\r\ncase 12:\r\nval = PMECC_CFG_BCH_ERR12;\r\nbreak;\r\ncase 24:\r\nval = PMECC_CFG_BCH_ERR24;\r\nbreak;\r\n}\r\nif (host->pmecc_sector_size == 512)\r\nval |= PMECC_CFG_SECTOR512;\r\nelse if (host->pmecc_sector_size == 1024)\r\nval |= PMECC_CFG_SECTOR1024;\r\nswitch (nand_chip->ecc.steps) {\r\ncase 1:\r\nval |= PMECC_CFG_PAGE_1SECTOR;\r\nbreak;\r\ncase 2:\r\nval |= PMECC_CFG_PAGE_2SECTORS;\r\nbreak;\r\ncase 4:\r\nval |= PMECC_CFG_PAGE_4SECTORS;\r\nbreak;\r\ncase 8:\r\nval |= PMECC_CFG_PAGE_8SECTORS;\r\nbreak;\r\n}\r\nval |= (PMECC_CFG_READ_OP | PMECC_CFG_SPARE_DISABLE\r\n| PMECC_CFG_AUTO_DISABLE);\r\npmecc_writel(host->ecc, CFG, val);\r\necc_layout = nand_chip->ecc.layout;\r\npmecc_writel(host->ecc, SAREA, mtd->oobsize - 1);\r\npmecc_writel(host->ecc, SADDR, ecc_layout->eccpos[0]);\r\npmecc_writel(host->ecc, EADDR,\r\necc_layout->eccpos[ecc_layout->eccbytes - 1]);\r\npmecc_writel(host->ecc, CLK, 2);\r\npmecc_writel(host->ecc, IDR, 0xff);\r\npmecc_writel(host->ecc, CTRL, PMECC_CTRL_ENABLE);\r\n}\r\nstatic int pmecc_choose_ecc(struct atmel_nand_host *host,\r\nint *cap, int *sector_size)\r\n{\r\nif (host->nand_chip.ecc_strength_ds) {\r\n*cap = host->nand_chip.ecc_strength_ds;\r\n*sector_size = host->nand_chip.ecc_step_ds;\r\ndev_info(host->dev, "minimum ECC: %d bits in %d bytes\n",\r\n*cap, *sector_size);\r\n} else {\r\n*cap = 2;\r\n*sector_size = 512;\r\ndev_info(host->dev, "can't detect min. ECC, assume 2 bits in 512 bytes\n");\r\n}\r\nif (host->pmecc_corr_cap == 0) {\r\nif (*cap <= 2)\r\nhost->pmecc_corr_cap = 2;\r\nelse if (*cap <= 4)\r\nhost->pmecc_corr_cap = 4;\r\nelse if (*cap <= 8)\r\nhost->pmecc_corr_cap = 8;\r\nelse if (*cap <= 12)\r\nhost->pmecc_corr_cap = 12;\r\nelse if (*cap <= 24)\r\nhost->pmecc_corr_cap = 24;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nif (host->pmecc_sector_size == 0) {\r\nif (*sector_size >= 1024)\r\nhost->pmecc_sector_size = 1024;\r\nelse if (*sector_size >= 512)\r\nhost->pmecc_sector_size = 512;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int deg(unsigned int poly)\r\n{\r\nreturn fls(poly) - 1;\r\n}\r\nstatic int build_gf_tables(int mm, unsigned int poly,\r\nint16_t *index_of, int16_t *alpha_to)\r\n{\r\nunsigned int i, x = 1;\r\nconst unsigned int k = 1 << deg(poly);\r\nunsigned int nn = (1 << mm) - 1;\r\nif (k != (1u << mm))\r\nreturn -EINVAL;\r\nfor (i = 0; i < nn; i++) {\r\nalpha_to[i] = x;\r\nindex_of[x] = i;\r\nif (i && (x == 1))\r\nreturn -EINVAL;\r\nx <<= 1;\r\nif (x & k)\r\nx ^= poly;\r\n}\r\nalpha_to[nn] = 1;\r\nindex_of[0] = 0;\r\nreturn 0;\r\n}\r\nstatic uint16_t *create_lookup_table(struct device *dev, int sector_size)\r\n{\r\nint degree = (sector_size == 512) ?\r\nPMECC_GF_DIMENSION_13 :\r\nPMECC_GF_DIMENSION_14;\r\nunsigned int poly = (sector_size == 512) ?\r\nPMECC_GF_13_PRIMITIVE_POLY :\r\nPMECC_GF_14_PRIMITIVE_POLY;\r\nint table_size = (sector_size == 512) ?\r\nPMECC_LOOKUP_TABLE_SIZE_512 :\r\nPMECC_LOOKUP_TABLE_SIZE_1024;\r\nint16_t *addr = devm_kzalloc(dev, 2 * table_size * sizeof(uint16_t),\r\nGFP_KERNEL);\r\nif (addr && build_gf_tables(degree, poly, addr, addr + table_size))\r\nreturn NULL;\r\nreturn addr;\r\n}\r\nstatic int atmel_pmecc_nand_init_params(struct platform_device *pdev,\r\nstruct atmel_nand_host *host)\r\n{\r\nstruct mtd_info *mtd = &host->mtd;\r\nstruct nand_chip *nand_chip = &host->nand_chip;\r\nstruct resource *regs, *regs_pmerr, *regs_rom;\r\nuint16_t *galois_table;\r\nint cap, sector_size, err_no;\r\nerr_no = pmecc_choose_ecc(host, &cap, &sector_size);\r\nif (err_no) {\r\ndev_err(host->dev, "The NAND flash's ECC requirement are not support!");\r\nreturn err_no;\r\n}\r\nif (cap > host->pmecc_corr_cap ||\r\nsector_size != host->pmecc_sector_size)\r\ndev_info(host->dev, "WARNING: Be Caution! Using different PMECC parameters from Nand ONFI ECC reqirement.\n");\r\ncap = host->pmecc_corr_cap;\r\nsector_size = host->pmecc_sector_size;\r\nhost->pmecc_lookup_table_offset = (sector_size == 512) ?\r\nhost->pmecc_lookup_table_offset_512 :\r\nhost->pmecc_lookup_table_offset_1024;\r\ndev_info(host->dev, "Initialize PMECC params, cap: %d, sector: %d\n",\r\ncap, sector_size);\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!regs) {\r\ndev_warn(host->dev,\r\n"Can't get I/O resource regs for PMECC controller, rolling back on software ECC\n");\r\nnand_chip->ecc.mode = NAND_ECC_SOFT;\r\nreturn 0;\r\n}\r\nhost->ecc = devm_ioremap_resource(&pdev->dev, regs);\r\nif (IS_ERR(host->ecc)) {\r\nerr_no = PTR_ERR(host->ecc);\r\ngoto err;\r\n}\r\nregs_pmerr = platform_get_resource(pdev, IORESOURCE_MEM, 2);\r\nhost->pmerrloc_base = devm_ioremap_resource(&pdev->dev, regs_pmerr);\r\nif (IS_ERR(host->pmerrloc_base)) {\r\nerr_no = PTR_ERR(host->pmerrloc_base);\r\ngoto err;\r\n}\r\nif (!host->has_no_lookup_table) {\r\nregs_rom = platform_get_resource(pdev, IORESOURCE_MEM, 3);\r\nhost->pmecc_rom_base = devm_ioremap_resource(&pdev->dev,\r\nregs_rom);\r\nif (IS_ERR(host->pmecc_rom_base)) {\r\ndev_err(host->dev, "Can not get I/O resource for ROM, will build a lookup table in runtime!\n");\r\nhost->has_no_lookup_table = true;\r\n}\r\n}\r\nif (host->has_no_lookup_table) {\r\ngalois_table = create_lookup_table(host->dev, sector_size);\r\nif (!galois_table) {\r\ndev_err(host->dev, "Failed to build a lookup table in runtime!\n");\r\nerr_no = -EINVAL;\r\ngoto err;\r\n}\r\nhost->pmecc_rom_base = (void __iomem *)galois_table;\r\nhost->pmecc_lookup_table_offset = 0;\r\n}\r\nnand_chip->ecc.size = sector_size;\r\nswitch (mtd->writesize) {\r\ncase 512:\r\ncase 1024:\r\ncase 2048:\r\ncase 4096:\r\ncase 8192:\r\nif (sector_size > mtd->writesize) {\r\ndev_err(host->dev, "pmecc sector size is bigger than the page size!\n");\r\nerr_no = -EINVAL;\r\ngoto err;\r\n}\r\nhost->pmecc_degree = (sector_size == 512) ?\r\nPMECC_GF_DIMENSION_13 : PMECC_GF_DIMENSION_14;\r\nhost->pmecc_cw_len = (1 << host->pmecc_degree) - 1;\r\nhost->pmecc_alpha_to = pmecc_get_alpha_to(host);\r\nhost->pmecc_index_of = host->pmecc_rom_base +\r\nhost->pmecc_lookup_table_offset;\r\nnand_chip->ecc.strength = cap;\r\nnand_chip->ecc.bytes = pmecc_get_ecc_bytes(cap, sector_size);\r\nnand_chip->ecc.steps = mtd->writesize / sector_size;\r\nnand_chip->ecc.total = nand_chip->ecc.bytes *\r\nnand_chip->ecc.steps;\r\nif (nand_chip->ecc.total >\r\nmtd->oobsize - PMECC_OOB_RESERVED_BYTES) {\r\ndev_err(host->dev, "No room for ECC bytes\n");\r\nerr_no = -EINVAL;\r\ngoto err;\r\n}\r\npmecc_config_ecc_layout(&atmel_pmecc_oobinfo,\r\nmtd->oobsize,\r\nnand_chip->ecc.total);\r\nnand_chip->ecc.layout = &atmel_pmecc_oobinfo;\r\nbreak;\r\ndefault:\r\ndev_warn(host->dev,\r\n"Unsupported page size for PMECC, use Software ECC\n");\r\nnand_chip->ecc.mode = NAND_ECC_SOFT;\r\nreturn 0;\r\n}\r\nerr_no = pmecc_data_alloc(host);\r\nif (err_no) {\r\ndev_err(host->dev,\r\n"Cannot allocate memory for PMECC computation!\n");\r\ngoto err;\r\n}\r\nnand_chip->options |= NAND_NO_SUBPAGE_WRITE;\r\nnand_chip->ecc.read_page = atmel_nand_pmecc_read_page;\r\nnand_chip->ecc.write_page = atmel_nand_pmecc_write_page;\r\natmel_pmecc_core_init(mtd);\r\nreturn 0;\r\nerr:\r\nreturn err_no;\r\n}\r\nstatic int atmel_nand_calculate(struct mtd_info *mtd,\r\nconst u_char *dat, unsigned char *ecc_code)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nunsigned int ecc_value;\r\necc_value = ecc_readl(host->ecc, PR);\r\necc_code[0] = ecc_value & 0xFF;\r\necc_code[1] = (ecc_value >> 8) & 0xFF;\r\necc_value = ecc_readl(host->ecc, NPR) & ATMEL_ECC_NPARITY;\r\necc_code[2] = ecc_value & 0xFF;\r\necc_code[3] = (ecc_value >> 8) & 0xFF;\r\nreturn 0;\r\n}\r\nstatic int atmel_nand_read_page(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint8_t *buf, int oob_required, int page)\r\n{\r\nint eccsize = chip->ecc.size;\r\nint eccbytes = chip->ecc.bytes;\r\nuint32_t *eccpos = chip->ecc.layout->eccpos;\r\nuint8_t *p = buf;\r\nuint8_t *oob = chip->oob_poi;\r\nuint8_t *ecc_pos;\r\nint stat;\r\nunsigned int max_bitflips = 0;\r\nstruct atmel_nand_host *host = chip->priv;\r\nif (host->board.need_reset_workaround)\r\necc_writel(host->ecc, CR, ATMEL_ECC_RST);\r\nchip->read_buf(mtd, p, eccsize);\r\nif (eccpos[0] != 0) {\r\nchip->cmdfunc(mtd, NAND_CMD_RNDOUT,\r\nmtd->writesize + eccpos[0], -1);\r\n}\r\necc_pos = oob + eccpos[0];\r\nchip->read_buf(mtd, ecc_pos, eccbytes);\r\nstat = chip->ecc.correct(mtd, p, oob, NULL);\r\nif (stat < 0) {\r\nmtd->ecc_stats.failed++;\r\n} else {\r\nmtd->ecc_stats.corrected += stat;\r\nmax_bitflips = max_t(unsigned int, max_bitflips, stat);\r\n}\r\nchip->cmdfunc(mtd, NAND_CMD_RNDOUT, mtd->writesize, -1);\r\nchip->read_buf(mtd, oob, mtd->oobsize);\r\nreturn max_bitflips;\r\n}\r\nstatic int atmel_nand_correct(struct mtd_info *mtd, u_char *dat,\r\nu_char *read_ecc, u_char *isnull)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nunsigned int ecc_status;\r\nunsigned int ecc_word, ecc_bit;\r\necc_status = ecc_readl(host->ecc, SR);\r\nif (likely(!(ecc_status & ATMEL_ECC_RECERR)))\r\nreturn 0;\r\necc_bit = ecc_readl(host->ecc, PR) & ATMEL_ECC_BITADDR;\r\necc_word = ecc_readl(host->ecc, PR) & ATMEL_ECC_WORDADDR;\r\necc_word >>= 4;\r\nif (ecc_status & ATMEL_ECC_MULERR) {\r\nif ((ecc_bit == ATMEL_ECC_BITADDR)\r\n&& (ecc_word == (ATMEL_ECC_WORDADDR >> 4))) {\r\nreturn 0;\r\n}\r\ndev_dbg(host->dev, "atmel_nand : multiple errors detected."\r\n" Unable to correct.\n");\r\nreturn -EIO;\r\n}\r\nif (ecc_status & ATMEL_ECC_ECCERR) {\r\ndev_dbg(host->dev, "atmel_nand : one bit error on ECC code."\r\n" Nothing to correct\n");\r\nreturn 0;\r\n}\r\ndev_dbg(host->dev, "atmel_nand : one bit error on data."\r\n" (word offset in the page :"\r\n" 0x%x bit offset : 0x%x)\n",\r\necc_word, ecc_bit);\r\nif (nand_chip->options & NAND_BUSWIDTH_16) {\r\n((unsigned short *) dat)[ecc_word] ^= (1 << ecc_bit);\r\n} else {\r\ndat[ecc_word] ^= (1 << ecc_bit);\r\n}\r\ndev_dbg(host->dev, "atmel_nand : error corrected\n");\r\nreturn 1;\r\n}\r\nstatic void atmel_nand_hwctl(struct mtd_info *mtd, int mode)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nif (host->board.need_reset_workaround)\r\necc_writel(host->ecc, CR, ATMEL_ECC_RST);\r\n}\r\nstatic int atmel_of_init_port(struct atmel_nand_host *host,\r\nstruct device_node *np)\r\n{\r\nu32 val;\r\nu32 offset[2];\r\nint ecc_mode;\r\nstruct atmel_nand_data *board = &host->board;\r\nenum of_gpio_flags flags = 0;\r\nhost->caps = (struct atmel_nand_caps *)\r\nof_match_device(atmel_nand_dt_ids, host->dev)->data;\r\nif (of_property_read_u32(np, "atmel,nand-addr-offset", &val) == 0) {\r\nif (val >= 32) {\r\ndev_err(host->dev, "invalid addr-offset %u\n", val);\r\nreturn -EINVAL;\r\n}\r\nboard->ale = val;\r\n}\r\nif (of_property_read_u32(np, "atmel,nand-cmd-offset", &val) == 0) {\r\nif (val >= 32) {\r\ndev_err(host->dev, "invalid cmd-offset %u\n", val);\r\nreturn -EINVAL;\r\n}\r\nboard->cle = val;\r\n}\r\necc_mode = of_get_nand_ecc_mode(np);\r\nboard->ecc_mode = ecc_mode < 0 ? NAND_ECC_SOFT : ecc_mode;\r\nboard->on_flash_bbt = of_get_nand_on_flash_bbt(np);\r\nboard->has_dma = of_property_read_bool(np, "atmel,nand-has-dma");\r\nif (of_get_nand_bus_width(np) == 16)\r\nboard->bus_width_16 = 1;\r\nboard->rdy_pin = of_get_gpio_flags(np, 0, &flags);\r\nboard->rdy_pin_active_low = (flags == OF_GPIO_ACTIVE_LOW);\r\nboard->enable_pin = of_get_gpio(np, 1);\r\nboard->det_pin = of_get_gpio(np, 2);\r\nhost->has_pmecc = of_property_read_bool(np, "atmel,has-pmecc");\r\nof_platform_populate(np, NULL, NULL, host->dev);\r\nif (!(board->ecc_mode == NAND_ECC_HW) || !host->has_pmecc)\r\nreturn 0;\r\nif (of_property_read_u32(np, "atmel,pmecc-cap", &val) == 0) {\r\nif ((val != 2) && (val != 4) && (val != 8) && (val != 12) &&\r\n(val != 24)) {\r\ndev_err(host->dev,\r\n"Unsupported PMECC correction capability: %d; should be 2, 4, 8, 12 or 24\n",\r\nval);\r\nreturn -EINVAL;\r\n}\r\nhost->pmecc_corr_cap = (u8)val;\r\n}\r\nif (of_property_read_u32(np, "atmel,pmecc-sector-size", &val) == 0) {\r\nif ((val != 512) && (val != 1024)) {\r\ndev_err(host->dev,\r\n"Unsupported PMECC sector size: %d; should be 512 or 1024 bytes\n",\r\nval);\r\nreturn -EINVAL;\r\n}\r\nhost->pmecc_sector_size = (u16)val;\r\n}\r\nif (of_property_read_u32_array(np, "atmel,pmecc-lookup-table-offset",\r\noffset, 2) != 0) {\r\ndev_err(host->dev, "Cannot get PMECC lookup table offset, will build a lookup table in runtime.\n");\r\nhost->has_no_lookup_table = true;\r\nreturn 0;\r\n}\r\nif (!offset[0] && !offset[1]) {\r\ndev_err(host->dev, "Invalid PMECC lookup table offset\n");\r\nreturn -EINVAL;\r\n}\r\nhost->pmecc_lookup_table_offset_512 = offset[0];\r\nhost->pmecc_lookup_table_offset_1024 = offset[1];\r\nreturn 0;\r\n}\r\nstatic int atmel_hw_nand_init_params(struct platform_device *pdev,\r\nstruct atmel_nand_host *host)\r\n{\r\nstruct mtd_info *mtd = &host->mtd;\r\nstruct nand_chip *nand_chip = &host->nand_chip;\r\nstruct resource *regs;\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!regs) {\r\ndev_err(host->dev,\r\n"Can't get I/O resource regs, use software ECC\n");\r\nnand_chip->ecc.mode = NAND_ECC_SOFT;\r\nreturn 0;\r\n}\r\nhost->ecc = devm_ioremap_resource(&pdev->dev, regs);\r\nif (IS_ERR(host->ecc))\r\nreturn PTR_ERR(host->ecc);\r\nnand_chip->ecc.size = mtd->writesize;\r\nswitch (mtd->writesize) {\r\ncase 512:\r\nnand_chip->ecc.layout = &atmel_oobinfo_small;\r\necc_writel(host->ecc, MR, ATMEL_ECC_PAGESIZE_528);\r\nbreak;\r\ncase 1024:\r\nnand_chip->ecc.layout = &atmel_oobinfo_large;\r\necc_writel(host->ecc, MR, ATMEL_ECC_PAGESIZE_1056);\r\nbreak;\r\ncase 2048:\r\nnand_chip->ecc.layout = &atmel_oobinfo_large;\r\necc_writel(host->ecc, MR, ATMEL_ECC_PAGESIZE_2112);\r\nbreak;\r\ncase 4096:\r\nnand_chip->ecc.layout = &atmel_oobinfo_large;\r\necc_writel(host->ecc, MR, ATMEL_ECC_PAGESIZE_4224);\r\nbreak;\r\ndefault:\r\nnand_chip->ecc.mode = NAND_ECC_SOFT;\r\nreturn 0;\r\n}\r\nnand_chip->ecc.calculate = atmel_nand_calculate;\r\nnand_chip->ecc.correct = atmel_nand_correct;\r\nnand_chip->ecc.hwctl = atmel_nand_hwctl;\r\nnand_chip->ecc.read_page = atmel_nand_read_page;\r\nnand_chip->ecc.bytes = 4;\r\nnand_chip->ecc.strength = 1;\r\nreturn 0;\r\n}\r\nstatic inline u32 nfc_read_status(struct atmel_nand_host *host)\r\n{\r\nu32 err_flags = NFC_SR_DTOE | NFC_SR_UNDEF | NFC_SR_AWB | NFC_SR_ASE;\r\nu32 nfc_status = nfc_readl(host->nfc->hsmc_regs, SR);\r\nif (unlikely(nfc_status & err_flags)) {\r\nif (nfc_status & NFC_SR_DTOE)\r\ndev_err(host->dev, "NFC: Waiting Nand R/B Timeout Error\n");\r\nelse if (nfc_status & NFC_SR_UNDEF)\r\ndev_err(host->dev, "NFC: Access Undefined Area Error\n");\r\nelse if (nfc_status & NFC_SR_AWB)\r\ndev_err(host->dev, "NFC: Access memory While NFC is busy\n");\r\nelse if (nfc_status & NFC_SR_ASE)\r\ndev_err(host->dev, "NFC: Access memory Size Error\n");\r\n}\r\nreturn nfc_status;\r\n}\r\nstatic irqreturn_t hsmc_interrupt(int irq, void *dev_id)\r\n{\r\nstruct atmel_nand_host *host = dev_id;\r\nu32 status, mask, pending;\r\nirqreturn_t ret = IRQ_NONE;\r\nstatus = nfc_read_status(host);\r\nmask = nfc_readl(host->nfc->hsmc_regs, IMR);\r\npending = status & mask;\r\nif (pending & NFC_SR_XFR_DONE) {\r\ncomplete(&host->nfc->comp_xfer_done);\r\nnfc_writel(host->nfc->hsmc_regs, IDR, NFC_SR_XFR_DONE);\r\nret = IRQ_HANDLED;\r\n}\r\nif (pending & NFC_SR_RB_EDGE) {\r\ncomplete(&host->nfc->comp_ready);\r\nnfc_writel(host->nfc->hsmc_regs, IDR, NFC_SR_RB_EDGE);\r\nret = IRQ_HANDLED;\r\n}\r\nif (pending & NFC_SR_CMD_DONE) {\r\ncomplete(&host->nfc->comp_cmd_done);\r\nnfc_writel(host->nfc->hsmc_regs, IDR, NFC_SR_CMD_DONE);\r\nret = IRQ_HANDLED;\r\n}\r\nreturn ret;\r\n}\r\nstatic void nfc_prepare_interrupt(struct atmel_nand_host *host, u32 flag)\r\n{\r\nif (flag & NFC_SR_XFR_DONE)\r\ninit_completion(&host->nfc->comp_xfer_done);\r\nif (flag & NFC_SR_RB_EDGE)\r\ninit_completion(&host->nfc->comp_ready);\r\nif (flag & NFC_SR_CMD_DONE)\r\ninit_completion(&host->nfc->comp_cmd_done);\r\nnfc_writel(host->nfc->hsmc_regs, IER, flag);\r\n}\r\nstatic int nfc_wait_interrupt(struct atmel_nand_host *host, u32 flag)\r\n{\r\nint i, index = 0;\r\nstruct completion *comp[3];\r\nif (flag & NFC_SR_XFR_DONE)\r\ncomp[index++] = &host->nfc->comp_xfer_done;\r\nif (flag & NFC_SR_RB_EDGE)\r\ncomp[index++] = &host->nfc->comp_ready;\r\nif (flag & NFC_SR_CMD_DONE)\r\ncomp[index++] = &host->nfc->comp_cmd_done;\r\nif (index == 0) {\r\ndev_err(host->dev, "Unknown interrupt flag: 0x%08x\n", flag);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < index; i++) {\r\nif (wait_for_completion_timeout(comp[i],\r\nmsecs_to_jiffies(NFC_TIME_OUT_MS)))\r\ncontinue;\r\nelse\r\ngoto err_timeout;\r\n}\r\nreturn 0;\r\nerr_timeout:\r\ndev_err(host->dev, "Time out to wait for interrupt: 0x%08x\n", flag);\r\nnfc_writel(host->nfc->hsmc_regs, IDR, flag);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int nfc_send_command(struct atmel_nand_host *host,\r\nunsigned int cmd, unsigned int addr, unsigned char cycle0)\r\n{\r\nunsigned long timeout;\r\nu32 flag = NFC_SR_CMD_DONE;\r\nflag |= cmd & NFCADDR_CMD_DATAEN ? NFC_SR_XFR_DONE : 0;\r\ndev_dbg(host->dev,\r\n"nfc_cmd: 0x%08x, addr1234: 0x%08x, cycle0: 0x%02x\n",\r\ncmd, addr, cycle0);\r\ntimeout = jiffies + msecs_to_jiffies(NFC_TIME_OUT_MS);\r\nwhile (nfc_readl(host->nfc->hsmc_regs, SR) & NFC_SR_BUSY) {\r\nif (time_after(jiffies, timeout)) {\r\ndev_err(host->dev,\r\n"Time out to wait for NFC ready!\n");\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\nnfc_prepare_interrupt(host, flag);\r\nnfc_writel(host->nfc->hsmc_regs, CYCLE0, cycle0);\r\nnfc_cmd_addr1234_writel(cmd, addr, host->nfc->base_cmd_regs);\r\nreturn nfc_wait_interrupt(host, flag);\r\n}\r\nstatic int nfc_device_ready(struct mtd_info *mtd)\r\n{\r\nu32 status, mask;\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nstatus = nfc_read_status(host);\r\nmask = nfc_readl(host->nfc->hsmc_regs, IMR);\r\nif (unlikely(mask & status))\r\ndev_err(host->dev, "Lost the interrupt flags: 0x%08x\n",\r\nmask & status);\r\nreturn status & NFC_SR_RB_EDGE;\r\n}\r\nstatic void nfc_select_chip(struct mtd_info *mtd, int chip)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct atmel_nand_host *host = nand_chip->priv;\r\nif (chip == -1)\r\nnfc_writel(host->nfc->hsmc_regs, CTRL, NFC_CTRL_DISABLE);\r\nelse\r\nnfc_writel(host->nfc->hsmc_regs, CTRL, NFC_CTRL_ENABLE);\r\n}\r\nstatic int nfc_make_addr(struct mtd_info *mtd, int command, int column,\r\nint page_addr, unsigned int *addr1234, unsigned int *cycle0)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nint acycle = 0;\r\nunsigned char addr_bytes[8];\r\nint index = 0, bit_shift;\r\nBUG_ON(addr1234 == NULL || cycle0 == NULL);\r\n*cycle0 = 0;\r\n*addr1234 = 0;\r\nif (column != -1) {\r\nif (chip->options & NAND_BUSWIDTH_16 &&\r\n!nand_opcode_8bits(command))\r\ncolumn >>= 1;\r\naddr_bytes[acycle++] = column & 0xff;\r\nif (mtd->writesize > 512)\r\naddr_bytes[acycle++] = (column >> 8) & 0xff;\r\n}\r\nif (page_addr != -1) {\r\naddr_bytes[acycle++] = page_addr & 0xff;\r\naddr_bytes[acycle++] = (page_addr >> 8) & 0xff;\r\nif (chip->chipsize > (128 << 20))\r\naddr_bytes[acycle++] = (page_addr >> 16) & 0xff;\r\n}\r\nif (acycle > 4)\r\n*cycle0 = addr_bytes[index++];\r\nfor (bit_shift = 0; index < acycle; bit_shift += 8)\r\n*addr1234 += addr_bytes[index++] << bit_shift;\r\nreturn acycle << NFCADDR_CMD_ACYCLE_BIT_POS;\r\n}\r\nstatic void nfc_nand_command(struct mtd_info *mtd, unsigned int command,\r\nint column, int page_addr)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct atmel_nand_host *host = chip->priv;\r\nunsigned long timeout;\r\nunsigned int nfc_addr_cmd = 0;\r\nunsigned int cmd1 = command << NFCADDR_CMD_CMD1_BIT_POS;\r\nunsigned int cmd2 = 0;\r\nunsigned int vcmd2 = 0;\r\nint acycle = NFCADDR_CMD_ACYCLE_NONE;\r\nint csid = NFCADDR_CMD_CSID_3;\r\nint dataen = NFCADDR_CMD_DATADIS;\r\nint nfcwr = NFCADDR_CMD_NFCRD;\r\nunsigned int addr1234 = 0;\r\nunsigned int cycle0 = 0;\r\nbool do_addr = true;\r\nhost->nfc->data_in_sram = NULL;\r\ndev_dbg(host->dev, "%s: cmd = 0x%02x, col = 0x%08x, page = 0x%08x\n",\r\n__func__, command, column, page_addr);\r\nswitch (command) {\r\ncase NAND_CMD_RESET:\r\nnfc_addr_cmd = cmd1 | acycle | csid | dataen | nfcwr;\r\nnfc_send_command(host, nfc_addr_cmd, addr1234, cycle0);\r\nudelay(chip->chip_delay);\r\nnfc_nand_command(mtd, NAND_CMD_STATUS, -1, -1);\r\ntimeout = jiffies + msecs_to_jiffies(NFC_TIME_OUT_MS);\r\nwhile (!(chip->read_byte(mtd) & NAND_STATUS_READY)) {\r\nif (time_after(jiffies, timeout)) {\r\ndev_err(host->dev,\r\n"Time out to wait status ready!\n");\r\nbreak;\r\n}\r\n}\r\nreturn;\r\ncase NAND_CMD_STATUS:\r\ndo_addr = false;\r\nbreak;\r\ncase NAND_CMD_PARAM:\r\ncase NAND_CMD_READID:\r\ndo_addr = false;\r\nacycle = NFCADDR_CMD_ACYCLE_1;\r\nif (column != -1)\r\naddr1234 = column;\r\nbreak;\r\ncase NAND_CMD_RNDOUT:\r\ncmd2 = NAND_CMD_RNDOUTSTART << NFCADDR_CMD_CMD2_BIT_POS;\r\nvcmd2 = NFCADDR_CMD_VCMD2;\r\nbreak;\r\ncase NAND_CMD_READ0:\r\ncase NAND_CMD_READOOB:\r\nif (command == NAND_CMD_READOOB) {\r\ncolumn += mtd->writesize;\r\ncommand = NAND_CMD_READ0;\r\ncmd1 = command << NFCADDR_CMD_CMD1_BIT_POS;\r\n}\r\nif (host->nfc->use_nfc_sram) {\r\ndataen = NFCADDR_CMD_DATAEN;\r\nif (chip->ecc.mode == NAND_ECC_HW && host->has_pmecc)\r\npmecc_enable(host, NAND_ECC_READ);\r\n}\r\ncmd2 = NAND_CMD_READSTART << NFCADDR_CMD_CMD2_BIT_POS;\r\nvcmd2 = NFCADDR_CMD_VCMD2;\r\nbreak;\r\ncase NAND_CMD_PAGEPROG:\r\ncase NAND_CMD_SEQIN:\r\ncase NAND_CMD_RNDIN:\r\nnfcwr = NFCADDR_CMD_NFCWR;\r\nif (host->nfc->will_write_sram && command == NAND_CMD_SEQIN)\r\ndataen = NFCADDR_CMD_DATAEN;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (do_addr)\r\nacycle = nfc_make_addr(mtd, command, column, page_addr,\r\n&addr1234, &cycle0);\r\nnfc_addr_cmd = cmd1 | cmd2 | vcmd2 | acycle | csid | dataen | nfcwr;\r\nnfc_send_command(host, nfc_addr_cmd, addr1234, cycle0);\r\nswitch (command) {\r\ncase NAND_CMD_CACHEDPROG:\r\ncase NAND_CMD_PAGEPROG:\r\ncase NAND_CMD_ERASE1:\r\ncase NAND_CMD_ERASE2:\r\ncase NAND_CMD_RNDIN:\r\ncase NAND_CMD_STATUS:\r\ncase NAND_CMD_RNDOUT:\r\ncase NAND_CMD_SEQIN:\r\ncase NAND_CMD_READID:\r\nreturn;\r\ncase NAND_CMD_READ0:\r\nif (dataen == NFCADDR_CMD_DATAEN) {\r\nhost->nfc->data_in_sram = host->nfc->sram_bank0 +\r\nnfc_get_sram_off(host);\r\nreturn;\r\n}\r\ndefault:\r\nnfc_prepare_interrupt(host, NFC_SR_RB_EDGE);\r\nnfc_wait_interrupt(host, NFC_SR_RB_EDGE);\r\n}\r\n}\r\nstatic int nfc_sram_write_page(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint32_t offset, int data_len, const uint8_t *buf,\r\nint oob_required, int page, int cached, int raw)\r\n{\r\nint cfg, len;\r\nint status = 0;\r\nstruct atmel_nand_host *host = chip->priv;\r\nvoid *sram = host->nfc->sram_bank0 + nfc_get_sram_off(host);\r\nif (offset || (data_len < mtd->writesize))\r\nreturn -EINVAL;\r\nlen = mtd->writesize;\r\nif (use_dma) {\r\nif (atmel_nand_dma_op(mtd, (void *)buf, len, 0) != 0)\r\nmemcpy(sram, buf, len);\r\n} else {\r\nmemcpy(sram, buf, len);\r\n}\r\ncfg = nfc_readl(host->nfc->hsmc_regs, CFG);\r\nif (unlikely(raw) && oob_required) {\r\nmemcpy(sram + len, chip->oob_poi, mtd->oobsize);\r\nlen += mtd->oobsize;\r\nnfc_writel(host->nfc->hsmc_regs, CFG, cfg | NFC_CFG_WSPARE);\r\n} else {\r\nnfc_writel(host->nfc->hsmc_regs, CFG, cfg & ~NFC_CFG_WSPARE);\r\n}\r\nif (chip->ecc.mode == NAND_ECC_HW && host->has_pmecc)\r\npmecc_enable(host, NAND_ECC_WRITE);\r\nhost->nfc->will_write_sram = true;\r\nchip->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);\r\nhost->nfc->will_write_sram = false;\r\nif (likely(!raw))\r\nstatus = chip->ecc.write_page(mtd, chip, buf, oob_required);\r\nif (status < 0)\r\nreturn status;\r\nchip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);\r\nstatus = chip->waitfunc(mtd, chip);\r\nif ((status & NAND_STATUS_FAIL) && (chip->errstat))\r\nstatus = chip->errstat(mtd, chip, FL_WRITING, status, page);\r\nif (status & NAND_STATUS_FAIL)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int nfc_sram_init(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct atmel_nand_host *host = chip->priv;\r\nint res = 0;\r\nunsigned int cfg_nfc = 0;\r\nswitch (mtd->writesize) {\r\ncase 512:\r\ncfg_nfc = NFC_CFG_PAGESIZE_512;\r\nbreak;\r\ncase 1024:\r\ncfg_nfc = NFC_CFG_PAGESIZE_1024;\r\nbreak;\r\ncase 2048:\r\ncfg_nfc = NFC_CFG_PAGESIZE_2048;\r\nbreak;\r\ncase 4096:\r\ncfg_nfc = NFC_CFG_PAGESIZE_4096;\r\nbreak;\r\ncase 8192:\r\ncfg_nfc = NFC_CFG_PAGESIZE_8192;\r\nbreak;\r\ndefault:\r\ndev_err(host->dev, "Unsupported page size for NFC.\n");\r\nres = -ENXIO;\r\nreturn res;\r\n}\r\ncfg_nfc |= (((mtd->oobsize / 4) - 1) << NFC_CFG_NFC_SPARESIZE_BIT_POS\r\n& NFC_CFG_NFC_SPARESIZE);\r\ncfg_nfc |= NFC_CFG_RSPARE |\r\nNFC_CFG_NFC_DTOCYC | NFC_CFG_NFC_DTOMUL;\r\nnfc_writel(host->nfc->hsmc_regs, CFG, cfg_nfc);\r\nhost->nfc->will_write_sram = false;\r\nnfc_set_sram_bank(host, 0);\r\nif (host->nfc->write_by_sram) {\r\nif ((chip->ecc.mode == NAND_ECC_HW && host->has_pmecc) ||\r\nchip->ecc.mode == NAND_ECC_NONE)\r\nchip->write_page = nfc_sram_write_page;\r\nelse\r\nhost->nfc->write_by_sram = false;\r\n}\r\ndev_info(host->dev, "Using NFC Sram read %s\n",\r\nhost->nfc->write_by_sram ? "and write" : "");\r\nreturn 0;\r\n}\r\nstatic int atmel_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct atmel_nand_host *host;\r\nstruct mtd_info *mtd;\r\nstruct nand_chip *nand_chip;\r\nstruct resource *mem;\r\nstruct mtd_part_parser_data ppdata = {};\r\nint res, irq;\r\nhost = devm_kzalloc(&pdev->dev, sizeof(*host), GFP_KERNEL);\r\nif (!host)\r\nreturn -ENOMEM;\r\nres = platform_driver_register(&atmel_nand_nfc_driver);\r\nif (res)\r\ndev_err(&pdev->dev, "atmel_nand: can't register NFC driver\n");\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nhost->io_base = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(host->io_base)) {\r\nres = PTR_ERR(host->io_base);\r\ngoto err_nand_ioremap;\r\n}\r\nhost->io_phys = (dma_addr_t)mem->start;\r\nmtd = &host->mtd;\r\nnand_chip = &host->nand_chip;\r\nhost->dev = &pdev->dev;\r\nif (IS_ENABLED(CONFIG_OF) && pdev->dev.of_node) {\r\nres = atmel_of_init_port(host, pdev->dev.of_node);\r\nif (res)\r\ngoto err_nand_ioremap;\r\n} else {\r\nmemcpy(&host->board, dev_get_platdata(&pdev->dev),\r\nsizeof(struct atmel_nand_data));\r\n}\r\nnand_chip->priv = host;\r\nmtd->priv = nand_chip;\r\nmtd->owner = THIS_MODULE;\r\nnand_chip->IO_ADDR_R = host->io_base;\r\nnand_chip->IO_ADDR_W = host->io_base;\r\nif (nand_nfc.is_initialized) {\r\nhost->nfc = &nand_nfc;\r\nnand_chip->select_chip = nfc_select_chip;\r\nnand_chip->dev_ready = nfc_device_ready;\r\nnand_chip->cmdfunc = nfc_nand_command;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(host->dev, "Cannot get HSMC irq!\n");\r\nres = irq;\r\ngoto err_nand_ioremap;\r\n}\r\nres = devm_request_irq(&pdev->dev, irq, hsmc_interrupt,\r\n0, "hsmc", host);\r\nif (res) {\r\ndev_err(&pdev->dev, "Unable to request HSMC irq %d\n",\r\nirq);\r\ngoto err_nand_ioremap;\r\n}\r\n} else {\r\nres = atmel_nand_set_enable_ready_pins(mtd);\r\nif (res)\r\ngoto err_nand_ioremap;\r\nnand_chip->cmd_ctrl = atmel_nand_cmd_ctrl;\r\n}\r\nnand_chip->ecc.mode = host->board.ecc_mode;\r\nnand_chip->chip_delay = 40;\r\nif (host->board.bus_width_16)\r\nnand_chip->options |= NAND_BUSWIDTH_16;\r\nnand_chip->read_buf = atmel_read_buf;\r\nnand_chip->write_buf = atmel_write_buf;\r\nplatform_set_drvdata(pdev, host);\r\natmel_nand_enable(host);\r\nif (gpio_is_valid(host->board.det_pin)) {\r\nres = devm_gpio_request(&pdev->dev,\r\nhost->board.det_pin, "nand_det");\r\nif (res < 0) {\r\ndev_err(&pdev->dev,\r\n"can't request det gpio %d\n",\r\nhost->board.det_pin);\r\ngoto err_no_card;\r\n}\r\nres = gpio_direction_input(host->board.det_pin);\r\nif (res < 0) {\r\ndev_err(&pdev->dev,\r\n"can't request input direction det gpio %d\n",\r\nhost->board.det_pin);\r\ngoto err_no_card;\r\n}\r\nif (gpio_get_value(host->board.det_pin)) {\r\ndev_info(&pdev->dev, "No SmartMedia card inserted.\n");\r\nres = -ENXIO;\r\ngoto err_no_card;\r\n}\r\n}\r\nif (host->board.on_flash_bbt || on_flash_bbt) {\r\ndev_info(&pdev->dev, "Use On Flash BBT\n");\r\nnand_chip->bbt_options |= NAND_BBT_USE_FLASH;\r\n}\r\nif (!host->board.has_dma)\r\nuse_dma = 0;\r\nif (use_dma) {\r\ndma_cap_mask_t mask;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_MEMCPY, mask);\r\nhost->dma_chan = dma_request_channel(mask, NULL, NULL);\r\nif (!host->dma_chan) {\r\ndev_err(host->dev, "Failed to request DMA channel\n");\r\nuse_dma = 0;\r\n}\r\n}\r\nif (use_dma)\r\ndev_info(host->dev, "Using %s for DMA transfers.\n",\r\ndma_chan_name(host->dma_chan));\r\nelse\r\ndev_info(host->dev, "No DMA support for NAND access.\n");\r\nif (nand_scan_ident(mtd, 1, NULL)) {\r\nres = -ENXIO;\r\ngoto err_scan_ident;\r\n}\r\nif (nand_chip->ecc.mode == NAND_ECC_HW) {\r\nif (host->has_pmecc)\r\nres = atmel_pmecc_nand_init_params(pdev, host);\r\nelse\r\nres = atmel_hw_nand_init_params(pdev, host);\r\nif (res != 0)\r\ngoto err_hw_ecc;\r\n}\r\nif (host->nfc && host->nfc->use_nfc_sram) {\r\nres = nfc_sram_init(mtd);\r\nif (res) {\r\nhost->nfc->use_nfc_sram = false;\r\ndev_err(host->dev, "Disable use nfc sram for data transfer.\n");\r\n}\r\n}\r\nif (nand_scan_tail(mtd)) {\r\nres = -ENXIO;\r\ngoto err_scan_tail;\r\n}\r\nmtd->name = "atmel_nand";\r\nppdata.of_node = pdev->dev.of_node;\r\nres = mtd_device_parse_register(mtd, NULL, &ppdata,\r\nhost->board.parts, host->board.num_parts);\r\nif (!res)\r\nreturn res;\r\nerr_scan_tail:\r\nif (host->has_pmecc && host->nand_chip.ecc.mode == NAND_ECC_HW)\r\npmecc_writel(host->ecc, CTRL, PMECC_CTRL_DISABLE);\r\nerr_hw_ecc:\r\nerr_scan_ident:\r\nerr_no_card:\r\natmel_nand_disable(host);\r\nif (host->dma_chan)\r\ndma_release_channel(host->dma_chan);\r\nerr_nand_ioremap:\r\nreturn res;\r\n}\r\nstatic int atmel_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct atmel_nand_host *host = platform_get_drvdata(pdev);\r\nstruct mtd_info *mtd = &host->mtd;\r\nnand_release(mtd);\r\natmel_nand_disable(host);\r\nif (host->has_pmecc && host->nand_chip.ecc.mode == NAND_ECC_HW) {\r\npmecc_writel(host->ecc, CTRL, PMECC_CTRL_DISABLE);\r\npmerrloc_writel(host->pmerrloc_base, ELDIS,\r\nPMERRLOC_DISABLE);\r\n}\r\nif (host->dma_chan)\r\ndma_release_channel(host->dma_chan);\r\nplatform_driver_unregister(&atmel_nand_nfc_driver);\r\nreturn 0;\r\n}\r\nstatic int atmel_nand_nfc_probe(struct platform_device *pdev)\r\n{\r\nstruct atmel_nfc *nfc = &nand_nfc;\r\nstruct resource *nfc_cmd_regs, *nfc_hsmc_regs, *nfc_sram;\r\nint ret;\r\nnfc_cmd_regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nnfc->base_cmd_regs = devm_ioremap_resource(&pdev->dev, nfc_cmd_regs);\r\nif (IS_ERR(nfc->base_cmd_regs))\r\nreturn PTR_ERR(nfc->base_cmd_regs);\r\nnfc_hsmc_regs = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nnfc->hsmc_regs = devm_ioremap_resource(&pdev->dev, nfc_hsmc_regs);\r\nif (IS_ERR(nfc->hsmc_regs))\r\nreturn PTR_ERR(nfc->hsmc_regs);\r\nnfc_sram = platform_get_resource(pdev, IORESOURCE_MEM, 2);\r\nif (nfc_sram) {\r\nnfc->sram_bank0 = (void * __force)\r\ndevm_ioremap_resource(&pdev->dev, nfc_sram);\r\nif (IS_ERR(nfc->sram_bank0)) {\r\ndev_warn(&pdev->dev, "Fail to ioremap the NFC sram with error: %ld. So disable NFC sram.\n",\r\nPTR_ERR(nfc->sram_bank0));\r\n} else {\r\nnfc->use_nfc_sram = true;\r\nnfc->sram_bank0_phys = (dma_addr_t)nfc_sram->start;\r\nif (pdev->dev.of_node)\r\nnfc->write_by_sram = of_property_read_bool(\r\npdev->dev.of_node,\r\n"atmel,write-by-sram");\r\n}\r\n}\r\nnfc_writel(nfc->hsmc_regs, IDR, 0xffffffff);\r\nnfc_readl(nfc->hsmc_regs, SR);\r\nnfc->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (!IS_ERR(nfc->clk)) {\r\nret = clk_prepare_enable(nfc->clk);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\ndev_warn(&pdev->dev, "NFC clock missing, update your Device Tree");\r\n}\r\nnfc->is_initialized = true;\r\ndev_info(&pdev->dev, "NFC is probed.\n");\r\nreturn 0;\r\n}\r\nstatic int atmel_nand_nfc_remove(struct platform_device *pdev)\r\n{\r\nstruct atmel_nfc *nfc = &nand_nfc;\r\nif (!IS_ERR(nfc->clk))\r\nclk_disable_unprepare(nfc->clk);\r\nreturn 0;\r\n}
