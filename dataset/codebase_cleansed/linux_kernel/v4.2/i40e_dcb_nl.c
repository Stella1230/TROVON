static void i40e_get_pfc_delay(struct i40e_hw *hw, u16 *delay)\r\n{\r\nu32 val;\r\nval = rd32(hw, I40E_PRTDCB_GENC);\r\n*delay = (u16)((val & I40E_PRTDCB_GENC_PFCLDA_MASK) >>\r\nI40E_PRTDCB_GENC_PFCLDA_SHIFT);\r\n}\r\nstatic int i40e_dcbnl_ieee_getets(struct net_device *dev,\r\nstruct ieee_ets *ets)\r\n{\r\nstruct i40e_pf *pf = i40e_netdev_to_pf(dev);\r\nstruct i40e_dcbx_config *dcbxcfg;\r\nstruct i40e_hw *hw = &pf->hw;\r\nif (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_IEEE))\r\nreturn -EINVAL;\r\ndcbxcfg = &hw->local_dcbx_config;\r\nets->willing = dcbxcfg->etscfg.willing;\r\nets->ets_cap = dcbxcfg->etscfg.maxtcs;\r\nets->cbs = dcbxcfg->etscfg.cbs;\r\nmemcpy(ets->tc_tx_bw, dcbxcfg->etscfg.tcbwtable,\r\nsizeof(ets->tc_tx_bw));\r\nmemcpy(ets->tc_rx_bw, dcbxcfg->etscfg.tcbwtable,\r\nsizeof(ets->tc_rx_bw));\r\nmemcpy(ets->tc_tsa, dcbxcfg->etscfg.tsatable,\r\nsizeof(ets->tc_tsa));\r\nmemcpy(ets->prio_tc, dcbxcfg->etscfg.prioritytable,\r\nsizeof(ets->prio_tc));\r\nmemcpy(ets->tc_reco_bw, dcbxcfg->etsrec.tcbwtable,\r\nsizeof(ets->tc_reco_bw));\r\nmemcpy(ets->tc_reco_tsa, dcbxcfg->etsrec.tsatable,\r\nsizeof(ets->tc_reco_tsa));\r\nmemcpy(ets->reco_prio_tc, dcbxcfg->etscfg.prioritytable,\r\nsizeof(ets->reco_prio_tc));\r\nreturn 0;\r\n}\r\nstatic int i40e_dcbnl_ieee_getpfc(struct net_device *dev,\r\nstruct ieee_pfc *pfc)\r\n{\r\nstruct i40e_pf *pf = i40e_netdev_to_pf(dev);\r\nstruct i40e_dcbx_config *dcbxcfg;\r\nstruct i40e_hw *hw = &pf->hw;\r\nint i;\r\nif (!(pf->dcbx_cap & DCB_CAP_DCBX_VER_IEEE))\r\nreturn -EINVAL;\r\ndcbxcfg = &hw->local_dcbx_config;\r\npfc->pfc_cap = dcbxcfg->pfc.pfccap;\r\npfc->pfc_en = dcbxcfg->pfc.pfcenable;\r\npfc->mbc = dcbxcfg->pfc.mbc;\r\ni40e_get_pfc_delay(hw, &pfc->delay);\r\nfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\r\npfc->requests[i] = pf->stats.priority_xoff_tx[i];\r\npfc->indications[i] = pf->stats.priority_xoff_rx[i];\r\n}\r\nreturn 0;\r\n}\r\nstatic u8 i40e_dcbnl_getdcbx(struct net_device *dev)\r\n{\r\nstruct i40e_pf *pf = i40e_netdev_to_pf(dev);\r\nreturn pf->dcbx_cap;\r\n}\r\nstatic void i40e_dcbnl_get_perm_hw_addr(struct net_device *dev,\r\nu8 *perm_addr)\r\n{\r\nstruct i40e_pf *pf = i40e_netdev_to_pf(dev);\r\nint i, j;\r\nmemset(perm_addr, 0xff, MAX_ADDR_LEN);\r\nfor (i = 0; i < dev->addr_len; i++)\r\nperm_addr[i] = pf->hw.mac.perm_addr[i];\r\nfor (j = 0; j < dev->addr_len; j++, i++)\r\nperm_addr[i] = pf->hw.mac.san_addr[j];\r\n}\r\nvoid i40e_dcbnl_set_all(struct i40e_vsi *vsi)\r\n{\r\nstruct net_device *dev = vsi->netdev;\r\nstruct i40e_pf *pf = i40e_netdev_to_pf(dev);\r\nstruct i40e_dcbx_config *dcbxcfg;\r\nstruct i40e_hw *hw = &pf->hw;\r\nstruct dcb_app sapp;\r\nu8 prio, tc_map;\r\nint i;\r\nif (!(pf->flags & I40E_FLAG_DCB_ENABLED))\r\nreturn;\r\nif ((pf->flags & I40E_FLAG_MFP_ENABLED) && !(pf->hw.func_caps.iscsi))\r\nreturn;\r\ndcbxcfg = &hw->local_dcbx_config;\r\nfor (i = 0; i < dcbxcfg->numapps; i++) {\r\nprio = dcbxcfg->app[i].priority;\r\ntc_map = (1 << dcbxcfg->etscfg.prioritytable[prio]);\r\nif (tc_map & vsi->tc_config.enabled_tc) {\r\nsapp.selector = dcbxcfg->app[i].selector;\r\nsapp.protocol = dcbxcfg->app[i].protocolid;\r\nsapp.priority = prio;\r\ndcb_ieee_setapp(dev, &sapp);\r\n}\r\n}\r\ndcbnl_ieee_notify(dev, RTM_SETDCB, DCB_CMD_IEEE_SET, 0, 0);\r\n}\r\nstatic int i40e_dcbnl_vsi_del_app(struct i40e_vsi *vsi,\r\nstruct i40e_dcb_app_priority_table *app)\r\n{\r\nstruct net_device *dev = vsi->netdev;\r\nstruct dcb_app sapp;\r\nif (!dev)\r\nreturn -EINVAL;\r\nsapp.selector = app->selector;\r\nsapp.protocol = app->protocolid;\r\nsapp.priority = app->priority;\r\nreturn dcb_ieee_delapp(dev, &sapp);\r\n}\r\nstatic void i40e_dcbnl_del_app(struct i40e_pf *pf,\r\nstruct i40e_dcb_app_priority_table *app)\r\n{\r\nint v, err;\r\nfor (v = 0; v < pf->num_alloc_vsi; v++) {\r\nif (pf->vsi[v] && pf->vsi[v]->netdev) {\r\nerr = i40e_dcbnl_vsi_del_app(pf->vsi[v], app);\r\nif (err)\r\ndev_info(&pf->pdev->dev, "%s: Failed deleting app for VSI seid=%d err=%d sel=%d proto=0x%x prio=%d\n",\r\n__func__, pf->vsi[v]->seid,\r\nerr, app->selector,\r\napp->protocolid, app->priority);\r\n}\r\n}\r\n}\r\nstatic bool i40e_dcbnl_find_app(struct i40e_dcbx_config *cfg,\r\nstruct i40e_dcb_app_priority_table *app)\r\n{\r\nint i;\r\nfor (i = 0; i < cfg->numapps; i++) {\r\nif (app->selector == cfg->app[i].selector &&\r\napp->protocolid == cfg->app[i].protocolid &&\r\napp->priority == cfg->app[i].priority)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nvoid i40e_dcbnl_flush_apps(struct i40e_pf *pf,\r\nstruct i40e_dcbx_config *old_cfg,\r\nstruct i40e_dcbx_config *new_cfg)\r\n{\r\nstruct i40e_dcb_app_priority_table app;\r\nint i;\r\nif ((pf->flags & I40E_FLAG_MFP_ENABLED) && !(pf->hw.func_caps.iscsi))\r\nreturn;\r\nfor (i = 0; i < old_cfg->numapps; i++) {\r\napp = old_cfg->app[i];\r\nif (!i40e_dcbnl_find_app(new_cfg, &app))\r\ni40e_dcbnl_del_app(pf, &app);\r\n}\r\n}\r\nvoid i40e_dcbnl_setup(struct i40e_vsi *vsi)\r\n{\r\nstruct net_device *dev = vsi->netdev;\r\nstruct i40e_pf *pf = i40e_netdev_to_pf(dev);\r\nif (!(pf->flags & I40E_FLAG_DCB_CAPABLE))\r\nreturn;\r\ndev->dcbnl_ops = &dcbnl_ops;\r\ni40e_dcbnl_set_all(vsi);\r\n}
