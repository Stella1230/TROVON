static int as3722_current_to_index(int min_uA, int max_uA,\r\nconst int *curr_table, int n_currents)\r\n{\r\nint i;\r\nfor (i = n_currents - 1; i >= 0; i--) {\r\nif ((min_uA <= curr_table[i]) && (curr_table[i] <= max_uA))\r\nreturn i;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int as3722_ldo_get_current_limit(struct regulator_dev *rdev)\r\n{\r\nstruct as3722_regulators *as3722_regs = rdev_get_drvdata(rdev);\r\nstruct as3722 *as3722 = as3722_regs->as3722;\r\nint id = rdev_get_id(rdev);\r\nu32 val;\r\nint ret;\r\nret = as3722_read(as3722, as3722_reg_lookup[id].vsel_reg, &val);\r\nif (ret < 0) {\r\ndev_err(as3722_regs->dev, "Reg 0x%02x read failed: %d\n",\r\nas3722_reg_lookup[id].vsel_reg, ret);\r\nreturn ret;\r\n}\r\nif (val & AS3722_LDO_ILIMIT_MASK)\r\nreturn 300000;\r\nreturn 150000;\r\n}\r\nstatic int as3722_ldo_set_current_limit(struct regulator_dev *rdev,\r\nint min_uA, int max_uA)\r\n{\r\nstruct as3722_regulators *as3722_regs = rdev_get_drvdata(rdev);\r\nstruct as3722 *as3722 = as3722_regs->as3722;\r\nint id = rdev_get_id(rdev);\r\nint ret;\r\nu32 reg = 0;\r\nret = as3722_current_to_index(min_uA, max_uA, as3722_ldo_current,\r\nARRAY_SIZE(as3722_ldo_current));\r\nif (ret < 0) {\r\ndev_err(as3722_regs->dev,\r\n"Current range min:max = %d:%d does not support\n",\r\nmin_uA, max_uA);\r\nreturn ret;\r\n}\r\nif (ret)\r\nreg = AS3722_LDO_ILIMIT_BIT;\r\nreturn as3722_update_bits(as3722, as3722_reg_lookup[id].vsel_reg,\r\nAS3722_LDO_ILIMIT_MASK, reg);\r\n}\r\nstatic int as3722_ldo3_set_tracking_mode(struct as3722_regulators *as3722_reg,\r\nint id, u8 mode)\r\n{\r\nstruct as3722 *as3722 = as3722_reg->as3722;\r\nswitch (mode) {\r\ncase AS3722_LDO3_MODE_PMOS:\r\ncase AS3722_LDO3_MODE_PMOS_TRACKING:\r\ncase AS3722_LDO3_MODE_NMOS:\r\ncase AS3722_LDO3_MODE_SWITCH:\r\nreturn as3722_update_bits(as3722,\r\nas3722_reg_lookup[id].vsel_reg,\r\nAS3722_LDO3_MODE_MASK, mode);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int as3722_ldo3_get_current_limit(struct regulator_dev *rdev)\r\n{\r\nreturn 150000;\r\n}\r\nstatic unsigned int as3722_sd_get_mode(struct regulator_dev *rdev)\r\n{\r\nstruct as3722_regulators *as3722_regs = rdev_get_drvdata(rdev);\r\nstruct as3722 *as3722 = as3722_regs->as3722;\r\nint id = rdev_get_id(rdev);\r\nu32 val;\r\nint ret;\r\nif (!as3722_reg_lookup[id].control_reg)\r\nreturn -ENOTSUPP;\r\nret = as3722_read(as3722, as3722_reg_lookup[id].control_reg, &val);\r\nif (ret < 0) {\r\ndev_err(as3722_regs->dev, "Reg 0x%02x read failed: %d\n",\r\nas3722_reg_lookup[id].control_reg, ret);\r\nreturn ret;\r\n}\r\nif (val & as3722_reg_lookup[id].mode_mask)\r\nreturn REGULATOR_MODE_FAST;\r\nelse\r\nreturn REGULATOR_MODE_NORMAL;\r\n}\r\nstatic int as3722_sd_set_mode(struct regulator_dev *rdev,\r\nunsigned int mode)\r\n{\r\nstruct as3722_regulators *as3722_regs = rdev_get_drvdata(rdev);\r\nstruct as3722 *as3722 = as3722_regs->as3722;\r\nu8 id = rdev_get_id(rdev);\r\nu8 val = 0;\r\nint ret;\r\nif (!as3722_reg_lookup[id].control_reg)\r\nreturn -ERANGE;\r\nswitch (mode) {\r\ncase REGULATOR_MODE_FAST:\r\nval = as3722_reg_lookup[id].mode_mask;\r\ncase REGULATOR_MODE_NORMAL:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = as3722_update_bits(as3722, as3722_reg_lookup[id].control_reg,\r\nas3722_reg_lookup[id].mode_mask, val);\r\nif (ret < 0) {\r\ndev_err(as3722_regs->dev, "Reg 0x%02x update failed: %d\n",\r\nas3722_reg_lookup[id].control_reg, ret);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int as3722_sd016_get_current_limit(struct regulator_dev *rdev)\r\n{\r\nstruct as3722_regulators *as3722_regs = rdev_get_drvdata(rdev);\r\nstruct as3722 *as3722 = as3722_regs->as3722;\r\nint id = rdev_get_id(rdev);\r\nu32 val, reg;\r\nint mask;\r\nint ret;\r\nswitch (id) {\r\ncase AS3722_REGULATOR_ID_SD0:\r\nreg = AS3722_OVCURRENT_REG;\r\nmask = AS3722_OVCURRENT_SD0_TRIP_MASK;\r\nbreak;\r\ncase AS3722_REGULATOR_ID_SD1:\r\nreg = AS3722_OVCURRENT_REG;\r\nmask = AS3722_OVCURRENT_SD1_TRIP_MASK;\r\nbreak;\r\ncase AS3722_REGULATOR_ID_SD6:\r\nreg = AS3722_OVCURRENT_DEB_REG;\r\nmask = AS3722_OVCURRENT_SD6_TRIP_MASK;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = as3722_read(as3722, reg, &val);\r\nif (ret < 0) {\r\ndev_err(as3722_regs->dev, "Reg 0x%02x read failed: %d\n",\r\nreg, ret);\r\nreturn ret;\r\n}\r\nval &= mask;\r\nval >>= ffs(mask) - 1;\r\nif (val == 3)\r\nreturn -EINVAL;\r\nreturn as3722_sd016_current[val];\r\n}\r\nstatic int as3722_sd016_set_current_limit(struct regulator_dev *rdev,\r\nint min_uA, int max_uA)\r\n{\r\nstruct as3722_regulators *as3722_regs = rdev_get_drvdata(rdev);\r\nstruct as3722 *as3722 = as3722_regs->as3722;\r\nint id = rdev_get_id(rdev);\r\nint ret;\r\nint val;\r\nint mask;\r\nu32 reg;\r\nret = as3722_current_to_index(min_uA, max_uA, as3722_sd016_current,\r\nARRAY_SIZE(as3722_sd016_current));\r\nif (ret < 0) {\r\ndev_err(as3722_regs->dev,\r\n"Current range min:max = %d:%d does not support\n",\r\nmin_uA, max_uA);\r\nreturn ret;\r\n}\r\nswitch (id) {\r\ncase AS3722_REGULATOR_ID_SD0:\r\nreg = AS3722_OVCURRENT_REG;\r\nmask = AS3722_OVCURRENT_SD0_TRIP_MASK;\r\nbreak;\r\ncase AS3722_REGULATOR_ID_SD1:\r\nreg = AS3722_OVCURRENT_REG;\r\nmask = AS3722_OVCURRENT_SD1_TRIP_MASK;\r\nbreak;\r\ncase AS3722_REGULATOR_ID_SD6:\r\nreg = AS3722_OVCURRENT_DEB_REG;\r\nmask = AS3722_OVCURRENT_SD6_TRIP_MASK;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret <<= ffs(mask) - 1;\r\nval = ret & mask;\r\nreturn as3722_update_bits(as3722, reg, mask, val);\r\n}\r\nstatic bool as3722_sd0_is_low_voltage(struct as3722_regulators *as3722_regs)\r\n{\r\nint err;\r\nunsigned val;\r\nerr = as3722_read(as3722_regs->as3722, AS3722_FUSE7_REG, &val);\r\nif (err < 0) {\r\ndev_err(as3722_regs->dev, "Reg 0x%02x read failed: %d\n",\r\nAS3722_FUSE7_REG, err);\r\nreturn false;\r\n}\r\nif (val & AS3722_FUSE7_SD0_LOW_VOLTAGE)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int as3722_extreg_init(struct as3722_regulators *as3722_regs, int id,\r\nint ext_pwr_ctrl)\r\n{\r\nint ret;\r\nunsigned int val;\r\nif ((ext_pwr_ctrl < AS3722_EXT_CONTROL_ENABLE1) ||\r\n(ext_pwr_ctrl > AS3722_EXT_CONTROL_ENABLE3))\r\nreturn -EINVAL;\r\nval = ext_pwr_ctrl << (ffs(as3722_reg_lookup[id].sleep_ctrl_mask) - 1);\r\nret = as3722_update_bits(as3722_regs->as3722,\r\nas3722_reg_lookup[id].sleep_ctrl_reg,\r\nas3722_reg_lookup[id].sleep_ctrl_mask, val);\r\nif (ret < 0)\r\ndev_err(as3722_regs->dev, "Reg 0x%02x update failed: %d\n",\r\nas3722_reg_lookup[id].sleep_ctrl_reg, ret);\r\nreturn ret;\r\n}\r\nstatic int as3722_get_regulator_dt_data(struct platform_device *pdev,\r\nstruct as3722_regulators *as3722_regs)\r\n{\r\nstruct device_node *np;\r\nstruct as3722_regulator_config_data *reg_config;\r\nu32 prop;\r\nint id;\r\nint ret;\r\nnp = of_get_child_by_name(pdev->dev.parent->of_node, "regulators");\r\nif (!np) {\r\ndev_err(&pdev->dev, "Device is not having regulators node\n");\r\nreturn -ENODEV;\r\n}\r\npdev->dev.of_node = np;\r\nret = of_regulator_match(&pdev->dev, np, as3722_regulator_matches,\r\nARRAY_SIZE(as3722_regulator_matches));\r\nof_node_put(np);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Parsing of regulator node failed: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nfor (id = 0; id < ARRAY_SIZE(as3722_regulator_matches); ++id) {\r\nstruct device_node *reg_node;\r\nreg_config = &as3722_regs->reg_config_data[id];\r\nreg_config->reg_init = as3722_regulator_matches[id].init_data;\r\nreg_node = as3722_regulator_matches[id].of_node;\r\nif (!reg_config->reg_init || !reg_node)\r\ncontinue;\r\nret = of_property_read_u32(reg_node, "ams,ext-control", &prop);\r\nif (!ret) {\r\nif (prop < 3)\r\nreg_config->ext_control = prop;\r\nelse\r\ndev_warn(&pdev->dev,\r\n"ext-control have invalid option: %u\n",\r\nprop);\r\n}\r\nreg_config->enable_tracking =\r\nof_property_read_bool(reg_node, "ams,enable-tracking");\r\n}\r\nreturn 0;\r\n}\r\nstatic int as3722_regulator_probe(struct platform_device *pdev)\r\n{\r\nstruct as3722 *as3722 = dev_get_drvdata(pdev->dev.parent);\r\nstruct as3722_regulators *as3722_regs;\r\nstruct as3722_regulator_config_data *reg_config;\r\nstruct regulator_dev *rdev;\r\nstruct regulator_config config = { };\r\nstruct regulator_ops *ops;\r\nint id;\r\nint ret;\r\nas3722_regs = devm_kzalloc(&pdev->dev, sizeof(*as3722_regs),\r\nGFP_KERNEL);\r\nif (!as3722_regs)\r\nreturn -ENOMEM;\r\nas3722_regs->dev = &pdev->dev;\r\nas3722_regs->as3722 = as3722;\r\nplatform_set_drvdata(pdev, as3722_regs);\r\nret = as3722_get_regulator_dt_data(pdev, as3722_regs);\r\nif (ret < 0)\r\nreturn ret;\r\nconfig.dev = &pdev->dev;\r\nconfig.driver_data = as3722_regs;\r\nconfig.regmap = as3722->regmap;\r\nfor (id = 0; id < AS3722_REGULATOR_ID_MAX; id++) {\r\nreg_config = &as3722_regs->reg_config_data[id];\r\nas3722_regs->desc[id].name = as3722_reg_lookup[id].name;\r\nas3722_regs->desc[id].supply_name = as3722_reg_lookup[id].sname;\r\nas3722_regs->desc[id].id = as3722_reg_lookup[id].regulator_id;\r\nas3722_regs->desc[id].n_voltages =\r\nas3722_reg_lookup[id].n_voltages;\r\nas3722_regs->desc[id].type = REGULATOR_VOLTAGE;\r\nas3722_regs->desc[id].owner = THIS_MODULE;\r\nas3722_regs->desc[id].enable_reg =\r\nas3722_reg_lookup[id].enable_reg;\r\nas3722_regs->desc[id].enable_mask =\r\nas3722_reg_lookup[id].enable_mask;\r\nas3722_regs->desc[id].vsel_reg = as3722_reg_lookup[id].vsel_reg;\r\nas3722_regs->desc[id].vsel_mask =\r\nas3722_reg_lookup[id].vsel_mask;\r\nswitch (id) {\r\ncase AS3722_REGULATOR_ID_LDO0:\r\nif (reg_config->ext_control)\r\nops = &as3722_ldo0_extcntrl_ops;\r\nelse\r\nops = &as3722_ldo0_ops;\r\nas3722_regs->desc[id].min_uV = 825000;\r\nas3722_regs->desc[id].uV_step = 25000;\r\nas3722_regs->desc[id].linear_min_sel = 1;\r\nas3722_regs->desc[id].enable_time = 500;\r\nbreak;\r\ncase AS3722_REGULATOR_ID_LDO3:\r\nif (reg_config->ext_control)\r\nops = &as3722_ldo3_extcntrl_ops;\r\nelse\r\nops = &as3722_ldo3_ops;\r\nas3722_regs->desc[id].min_uV = 620000;\r\nas3722_regs->desc[id].uV_step = 20000;\r\nas3722_regs->desc[id].linear_min_sel = 1;\r\nas3722_regs->desc[id].enable_time = 500;\r\nif (reg_config->enable_tracking) {\r\nret = as3722_ldo3_set_tracking_mode(as3722_regs,\r\nid, AS3722_LDO3_MODE_PMOS_TRACKING);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev,\r\n"LDO3 tracking failed: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nbreak;\r\ncase AS3722_REGULATOR_ID_SD0:\r\ncase AS3722_REGULATOR_ID_SD1:\r\ncase AS3722_REGULATOR_ID_SD6:\r\nif (reg_config->ext_control)\r\nops = &as3722_sd016_extcntrl_ops;\r\nelse\r\nops = &as3722_sd016_ops;\r\nif (id == AS3722_REGULATOR_ID_SD0 &&\r\nas3722_sd0_is_low_voltage(as3722_regs)) {\r\nas3722_regs->desc[id].n_voltages =\r\nAS3722_SD0_VSEL_LOW_VOL_MAX + 1;\r\nas3722_regs->desc[id].min_uV = 410000;\r\n} else {\r\nas3722_regs->desc[id].n_voltages =\r\nAS3722_SD0_VSEL_MAX + 1,\r\nas3722_regs->desc[id].min_uV = 610000;\r\n}\r\nas3722_regs->desc[id].uV_step = 10000;\r\nas3722_regs->desc[id].linear_min_sel = 1;\r\nas3722_regs->desc[id].enable_time = 600;\r\nbreak;\r\ncase AS3722_REGULATOR_ID_SD2:\r\ncase AS3722_REGULATOR_ID_SD3:\r\ncase AS3722_REGULATOR_ID_SD4:\r\ncase AS3722_REGULATOR_ID_SD5:\r\nif (reg_config->ext_control)\r\nops = &as3722_sd2345_extcntrl_ops;\r\nelse\r\nops = &as3722_sd2345_ops;\r\nas3722_regs->desc[id].linear_ranges =\r\nas3722_sd2345_ranges;\r\nas3722_regs->desc[id].n_linear_ranges =\r\nARRAY_SIZE(as3722_sd2345_ranges);\r\nbreak;\r\ndefault:\r\nif (reg_config->ext_control)\r\nops = &as3722_ldo_extcntrl_ops;\r\nelse\r\nops = &as3722_ldo_ops;\r\nas3722_regs->desc[id].enable_time = 500;\r\nas3722_regs->desc[id].linear_ranges = as3722_ldo_ranges;\r\nas3722_regs->desc[id].n_linear_ranges =\r\nARRAY_SIZE(as3722_ldo_ranges);\r\nbreak;\r\n}\r\nas3722_regs->desc[id].ops = ops;\r\nconfig.init_data = reg_config->reg_init;\r\nconfig.of_node = as3722_regulator_matches[id].of_node;\r\nrdev = devm_regulator_register(&pdev->dev,\r\n&as3722_regs->desc[id], &config);\r\nif (IS_ERR(rdev)) {\r\nret = PTR_ERR(rdev);\r\ndev_err(&pdev->dev, "regulator %d register failed %d\n",\r\nid, ret);\r\nreturn ret;\r\n}\r\nas3722_regs->rdevs[id] = rdev;\r\nif (reg_config->ext_control) {\r\nret = regulator_enable_regmap(rdev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev,\r\n"Regulator %d enable failed: %d\n",\r\nid, ret);\r\nreturn ret;\r\n}\r\nret = as3722_extreg_init(as3722_regs, id,\r\nreg_config->ext_control);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev,\r\n"AS3722 ext control failed: %d", ret);\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}
