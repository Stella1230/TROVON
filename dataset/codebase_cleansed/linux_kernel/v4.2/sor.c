static inline struct tegra_sor *\r\nhost1x_client_to_sor(struct host1x_client *client)\r\n{\r\nreturn container_of(client, struct tegra_sor, client);\r\n}\r\nstatic inline struct tegra_sor *to_sor(struct tegra_output *output)\r\n{\r\nreturn container_of(output, struct tegra_sor, output);\r\n}\r\nstatic inline u32 tegra_sor_readl(struct tegra_sor *sor, unsigned long offset)\r\n{\r\nreturn readl(sor->regs + (offset << 2));\r\n}\r\nstatic inline void tegra_sor_writel(struct tegra_sor *sor, u32 value,\r\nunsigned long offset)\r\n{\r\nwritel(value, sor->regs + (offset << 2));\r\n}\r\nstatic int tegra_sor_dp_train_fast(struct tegra_sor *sor,\r\nstruct drm_dp_link *link)\r\n{\r\nunsigned int i;\r\nu8 pattern;\r\nu32 value;\r\nint err;\r\nvalue = SOR_LANE_DRIVE_CURRENT_LANE3(0x40) |\r\nSOR_LANE_DRIVE_CURRENT_LANE2(0x40) |\r\nSOR_LANE_DRIVE_CURRENT_LANE1(0x40) |\r\nSOR_LANE_DRIVE_CURRENT_LANE0(0x40);\r\ntegra_sor_writel(sor, value, SOR_LANE_DRIVE_CURRENT_0);\r\nvalue = SOR_LANE_PREEMPHASIS_LANE3(0x0f) |\r\nSOR_LANE_PREEMPHASIS_LANE2(0x0f) |\r\nSOR_LANE_PREEMPHASIS_LANE1(0x0f) |\r\nSOR_LANE_PREEMPHASIS_LANE0(0x0f);\r\ntegra_sor_writel(sor, value, SOR_LANE_PREEMPHASIS_0);\r\nvalue = SOR_LANE_POST_CURSOR_LANE3(0x00) |\r\nSOR_LANE_POST_CURSOR_LANE2(0x00) |\r\nSOR_LANE_POST_CURSOR_LANE1(0x00) |\r\nSOR_LANE_POST_CURSOR_LANE0(0x00);\r\ntegra_sor_writel(sor, value, SOR_LANE_POST_CURSOR_0);\r\ntegra_sor_writel(sor, 0, SOR_LVDS);\r\nvalue = tegra_sor_readl(sor, SOR_DP_PADCTL_0);\r\nvalue |= SOR_DP_PADCTL_TX_PU_ENABLE;\r\nvalue &= ~SOR_DP_PADCTL_TX_PU_MASK;\r\nvalue |= SOR_DP_PADCTL_TX_PU(2);\r\ntegra_sor_writel(sor, value, SOR_DP_PADCTL_0);\r\nvalue = tegra_sor_readl(sor, SOR_DP_PADCTL_0);\r\nvalue |= SOR_DP_PADCTL_CM_TXD_3 | SOR_DP_PADCTL_CM_TXD_2 |\r\nSOR_DP_PADCTL_CM_TXD_1 | SOR_DP_PADCTL_CM_TXD_0;\r\ntegra_sor_writel(sor, value, SOR_DP_PADCTL_0);\r\nusleep_range(10, 100);\r\nvalue = tegra_sor_readl(sor, SOR_DP_PADCTL_0);\r\nvalue &= ~(SOR_DP_PADCTL_CM_TXD_3 | SOR_DP_PADCTL_CM_TXD_2 |\r\nSOR_DP_PADCTL_CM_TXD_1 | SOR_DP_PADCTL_CM_TXD_0);\r\ntegra_sor_writel(sor, value, SOR_DP_PADCTL_0);\r\nerr = tegra_dpaux_prepare(sor->dpaux, DP_SET_ANSI_8B10B);\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0, value = 0; i < link->num_lanes; i++) {\r\nunsigned long lane = SOR_DP_TPG_CHANNEL_CODING |\r\nSOR_DP_TPG_SCRAMBLER_NONE |\r\nSOR_DP_TPG_PATTERN_TRAIN1;\r\nvalue = (value << 8) | lane;\r\n}\r\ntegra_sor_writel(sor, value, SOR_DP_TPG);\r\npattern = DP_TRAINING_PATTERN_1;\r\nerr = tegra_dpaux_train(sor->dpaux, link, pattern);\r\nif (err < 0)\r\nreturn err;\r\nvalue = tegra_sor_readl(sor, SOR_DP_SPARE_0);\r\nvalue |= SOR_DP_SPARE_SEQ_ENABLE;\r\nvalue &= ~SOR_DP_SPARE_PANEL_INTERNAL;\r\nvalue |= SOR_DP_SPARE_MACRO_SOR_CLK;\r\ntegra_sor_writel(sor, value, SOR_DP_SPARE_0);\r\nfor (i = 0, value = 0; i < link->num_lanes; i++) {\r\nunsigned long lane = SOR_DP_TPG_CHANNEL_CODING |\r\nSOR_DP_TPG_SCRAMBLER_NONE |\r\nSOR_DP_TPG_PATTERN_TRAIN2;\r\nvalue = (value << 8) | lane;\r\n}\r\ntegra_sor_writel(sor, value, SOR_DP_TPG);\r\npattern = DP_LINK_SCRAMBLING_DISABLE | DP_TRAINING_PATTERN_2;\r\nerr = tegra_dpaux_train(sor->dpaux, link, pattern);\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0, value = 0; i < link->num_lanes; i++) {\r\nunsigned long lane = SOR_DP_TPG_CHANNEL_CODING |\r\nSOR_DP_TPG_SCRAMBLER_GALIOS |\r\nSOR_DP_TPG_PATTERN_NONE;\r\nvalue = (value << 8) | lane;\r\n}\r\ntegra_sor_writel(sor, value, SOR_DP_TPG);\r\npattern = DP_TRAINING_PATTERN_DISABLE;\r\nerr = tegra_dpaux_train(sor->dpaux, link, pattern);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void tegra_sor_super_update(struct tegra_sor *sor)\r\n{\r\ntegra_sor_writel(sor, 0, SOR_SUPER_STATE_0);\r\ntegra_sor_writel(sor, 1, SOR_SUPER_STATE_0);\r\ntegra_sor_writel(sor, 0, SOR_SUPER_STATE_0);\r\n}\r\nstatic void tegra_sor_update(struct tegra_sor *sor)\r\n{\r\ntegra_sor_writel(sor, 0, SOR_STATE_0);\r\ntegra_sor_writel(sor, 1, SOR_STATE_0);\r\ntegra_sor_writel(sor, 0, SOR_STATE_0);\r\n}\r\nstatic int tegra_sor_setup_pwm(struct tegra_sor *sor, unsigned long timeout)\r\n{\r\nu32 value;\r\nvalue = tegra_sor_readl(sor, SOR_PWM_DIV);\r\nvalue &= ~SOR_PWM_DIV_MASK;\r\nvalue |= 0x400;\r\ntegra_sor_writel(sor, value, SOR_PWM_DIV);\r\nvalue = tegra_sor_readl(sor, SOR_PWM_CTL);\r\nvalue &= ~SOR_PWM_CTL_DUTY_CYCLE_MASK;\r\nvalue |= 0x400;\r\nvalue &= ~SOR_PWM_CTL_CLK_SEL;\r\nvalue |= SOR_PWM_CTL_TRIGGER;\r\ntegra_sor_writel(sor, value, SOR_PWM_CTL);\r\ntimeout = jiffies + msecs_to_jiffies(timeout);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = tegra_sor_readl(sor, SOR_PWM_CTL);\r\nif ((value & SOR_PWM_CTL_TRIGGER) == 0)\r\nreturn 0;\r\nusleep_range(25, 100);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int tegra_sor_attach(struct tegra_sor *sor)\r\n{\r\nunsigned long value, timeout;\r\nvalue = tegra_sor_readl(sor, SOR_SUPER_STATE_1);\r\nvalue |= SOR_SUPER_STATE_HEAD_MODE_AWAKE;\r\nvalue |= SOR_SUPER_STATE_MODE_NORMAL;\r\ntegra_sor_writel(sor, value, SOR_SUPER_STATE_1);\r\ntegra_sor_super_update(sor);\r\nvalue = tegra_sor_readl(sor, SOR_SUPER_STATE_1);\r\nvalue |= SOR_SUPER_STATE_ATTACHED;\r\ntegra_sor_writel(sor, value, SOR_SUPER_STATE_1);\r\ntegra_sor_super_update(sor);\r\ntimeout = jiffies + msecs_to_jiffies(250);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = tegra_sor_readl(sor, SOR_TEST);\r\nif ((value & SOR_TEST_ATTACHED) != 0)\r\nreturn 0;\r\nusleep_range(25, 100);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int tegra_sor_wakeup(struct tegra_sor *sor)\r\n{\r\nunsigned long value, timeout;\r\ntimeout = jiffies + msecs_to_jiffies(250);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = tegra_sor_readl(sor, SOR_TEST);\r\nvalue &= SOR_TEST_HEAD_MODE_MASK;\r\nif (value == SOR_TEST_HEAD_MODE_AWAKE)\r\nreturn 0;\r\nusleep_range(25, 100);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int tegra_sor_power_up(struct tegra_sor *sor, unsigned long timeout)\r\n{\r\nu32 value;\r\nvalue = tegra_sor_readl(sor, SOR_PWR);\r\nvalue |= SOR_PWR_TRIGGER | SOR_PWR_NORMAL_STATE_PU;\r\ntegra_sor_writel(sor, value, SOR_PWR);\r\ntimeout = jiffies + msecs_to_jiffies(timeout);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = tegra_sor_readl(sor, SOR_PWR);\r\nif ((value & SOR_PWR_TRIGGER) == 0)\r\nreturn 0;\r\nusleep_range(25, 100);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int tegra_sor_compute_params(struct tegra_sor *sor,\r\nstruct tegra_sor_params *params,\r\nunsigned int tu_size)\r\n{\r\nu64 active_sym, active_count, frac, approx;\r\nu32 active_polarity, active_frac = 0;\r\nconst u64 f = params->precision;\r\ns64 error;\r\nactive_sym = params->ratio * tu_size;\r\nactive_count = div_u64(active_sym, f) * f;\r\nfrac = active_sym - active_count;\r\nif (frac >= (f / 2)) {\r\nactive_polarity = 1;\r\nfrac = f - frac;\r\n} else {\r\nactive_polarity = 0;\r\n}\r\nif (frac != 0) {\r\nfrac = div_u64(f * f, frac);\r\nif (frac <= (15 * f)) {\r\nactive_frac = div_u64(frac, f);\r\nif (active_polarity)\r\nactive_frac++;\r\n} else {\r\nactive_frac = active_polarity ? 1 : 15;\r\n}\r\n}\r\nif (active_frac == 1)\r\nactive_polarity = 0;\r\nif (active_polarity == 1) {\r\nif (active_frac) {\r\napprox = active_count + (active_frac * (f - 1)) * f;\r\napprox = div_u64(approx, active_frac * f);\r\n} else {\r\napprox = active_count + f;\r\n}\r\n} else {\r\nif (active_frac)\r\napprox = active_count + div_u64(f, active_frac);\r\nelse\r\napprox = active_count;\r\n}\r\nerror = div_s64(active_sym - approx, tu_size);\r\nerror *= params->num_clocks;\r\nif (error <= 0 && abs64(error) < params->error) {\r\nparams->active_count = div_u64(active_count, f);\r\nparams->active_polarity = active_polarity;\r\nparams->active_frac = active_frac;\r\nparams->error = abs64(error);\r\nparams->tu_size = tu_size;\r\nif (error == 0)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int tegra_sor_calc_config(struct tegra_sor *sor,\r\nstruct drm_display_mode *mode,\r\nstruct tegra_sor_config *config,\r\nstruct drm_dp_link *link)\r\n{\r\nconst u64 f = 100000, link_rate = link->rate * 1000;\r\nconst u64 pclk = mode->clock * 1000;\r\nu64 input, output, watermark, num;\r\nstruct tegra_sor_params params;\r\nu32 num_syms_per_line;\r\nunsigned int i;\r\nif (!link_rate || !link->num_lanes || !pclk || !config->bits_per_pixel)\r\nreturn -EINVAL;\r\noutput = link_rate * 8 * link->num_lanes;\r\ninput = pclk * config->bits_per_pixel;\r\nif (input >= output)\r\nreturn -ERANGE;\r\nmemset(&params, 0, sizeof(params));\r\nparams.ratio = div64_u64(input * f, output);\r\nparams.num_clocks = div_u64(link_rate * mode->hdisplay, pclk);\r\nparams.precision = f;\r\nparams.error = 64 * f;\r\nparams.tu_size = 64;\r\nfor (i = params.tu_size; i >= 32; i--)\r\nif (tegra_sor_compute_params(sor, &params, i))\r\nbreak;\r\nif (params.active_frac == 0) {\r\nconfig->active_polarity = 0;\r\nconfig->active_count = params.active_count;\r\nif (!params.active_polarity)\r\nconfig->active_count--;\r\nconfig->tu_size = params.tu_size;\r\nconfig->active_frac = 1;\r\n} else {\r\nconfig->active_polarity = params.active_polarity;\r\nconfig->active_count = params.active_count;\r\nconfig->active_frac = params.active_frac;\r\nconfig->tu_size = params.tu_size;\r\n}\r\ndev_dbg(sor->dev,\r\n"polarity: %d active count: %d tu size: %d active frac: %d\n",\r\nconfig->active_polarity, config->active_count,\r\nconfig->tu_size, config->active_frac);\r\nwatermark = params.ratio * config->tu_size * (f - params.ratio);\r\nwatermark = div_u64(watermark, f);\r\nwatermark = div_u64(watermark + params.error, f);\r\nconfig->watermark = watermark + (config->bits_per_pixel / 8) + 2;\r\nnum_syms_per_line = (mode->hdisplay * config->bits_per_pixel) *\r\n(link->num_lanes * 8);\r\nif (config->watermark > 30) {\r\nconfig->watermark = 30;\r\ndev_err(sor->dev,\r\n"unable to compute TU size, forcing watermark to %u\n",\r\nconfig->watermark);\r\n} else if (config->watermark > num_syms_per_line) {\r\nconfig->watermark = num_syms_per_line;\r\ndev_err(sor->dev, "watermark too high, forcing to %u\n",\r\nconfig->watermark);\r\n}\r\nnum = ((mode->htotal - mode->hdisplay) - 7) * link_rate;\r\nconfig->hblank_symbols = div_u64(num, pclk);\r\nif (link->capabilities & DP_LINK_CAP_ENHANCED_FRAMING)\r\nconfig->hblank_symbols -= 3;\r\nconfig->hblank_symbols -= 12 / link->num_lanes;\r\nnum = (mode->hdisplay - 25) * link_rate;\r\nconfig->vblank_symbols = div_u64(num, pclk);\r\nconfig->vblank_symbols -= 36 / link->num_lanes + 4;\r\ndev_dbg(sor->dev, "blank symbols: H:%u V:%u\n", config->hblank_symbols,\r\nconfig->vblank_symbols);\r\nreturn 0;\r\n}\r\nstatic int tegra_sor_detach(struct tegra_sor *sor)\r\n{\r\nunsigned long value, timeout;\r\nvalue = tegra_sor_readl(sor, SOR_SUPER_STATE_1);\r\nvalue &= ~SOR_SUPER_STATE_MODE_NORMAL;\r\ntegra_sor_writel(sor, value, SOR_SUPER_STATE_1);\r\ntegra_sor_super_update(sor);\r\ntimeout = jiffies + msecs_to_jiffies(250);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = tegra_sor_readl(sor, SOR_PWR);\r\nif (value & SOR_PWR_MODE_SAFE)\r\nbreak;\r\n}\r\nif ((value & SOR_PWR_MODE_SAFE) == 0)\r\nreturn -ETIMEDOUT;\r\nvalue = tegra_sor_readl(sor, SOR_SUPER_STATE_1);\r\nvalue &= ~SOR_SUPER_STATE_HEAD_MODE_MASK;\r\ntegra_sor_writel(sor, value, SOR_SUPER_STATE_1);\r\ntegra_sor_super_update(sor);\r\nvalue = tegra_sor_readl(sor, SOR_SUPER_STATE_1);\r\nvalue &= ~SOR_SUPER_STATE_ATTACHED;\r\ntegra_sor_writel(sor, value, SOR_SUPER_STATE_1);\r\ntegra_sor_super_update(sor);\r\ntimeout = jiffies + msecs_to_jiffies(250);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = tegra_sor_readl(sor, SOR_TEST);\r\nif ((value & SOR_TEST_ATTACHED) == 0)\r\nbreak;\r\nusleep_range(25, 100);\r\n}\r\nif ((value & SOR_TEST_ATTACHED) != 0)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int tegra_sor_power_down(struct tegra_sor *sor)\r\n{\r\nunsigned long value, timeout;\r\nint err;\r\nvalue = tegra_sor_readl(sor, SOR_PWR);\r\nvalue &= ~SOR_PWR_NORMAL_STATE_PU;\r\nvalue |= SOR_PWR_TRIGGER;\r\ntegra_sor_writel(sor, value, SOR_PWR);\r\ntimeout = jiffies + msecs_to_jiffies(250);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = tegra_sor_readl(sor, SOR_PWR);\r\nif ((value & SOR_PWR_TRIGGER) == 0)\r\nreturn 0;\r\nusleep_range(25, 100);\r\n}\r\nif ((value & SOR_PWR_TRIGGER) != 0)\r\nreturn -ETIMEDOUT;\r\nerr = clk_set_parent(sor->clk, sor->clk_safe);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to set safe parent clock: %d\n", err);\r\nvalue = tegra_sor_readl(sor, SOR_DP_PADCTL_0);\r\nvalue &= ~(SOR_DP_PADCTL_PD_TXD_3 | SOR_DP_PADCTL_PD_TXD_0 |\r\nSOR_DP_PADCTL_PD_TXD_1 | SOR_DP_PADCTL_PD_TXD_2);\r\ntegra_sor_writel(sor, value, SOR_DP_PADCTL_0);\r\nvalue = SOR_LANE_SEQ_CTL_TRIGGER | SOR_LANE_SEQ_CTL_SEQUENCE_UP |\r\nSOR_LANE_SEQ_CTL_POWER_STATE_DOWN;\r\ntegra_sor_writel(sor, value, SOR_LANE_SEQ_CTL);\r\ntimeout = jiffies + msecs_to_jiffies(250);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = tegra_sor_readl(sor, SOR_LANE_SEQ_CTL);\r\nif ((value & SOR_LANE_SEQ_CTL_TRIGGER) == 0)\r\nbreak;\r\nusleep_range(25, 100);\r\n}\r\nif ((value & SOR_LANE_SEQ_CTL_TRIGGER) != 0)\r\nreturn -ETIMEDOUT;\r\nvalue = tegra_sor_readl(sor, SOR_PLL_2);\r\nvalue |= SOR_PLL_2_PORT_POWERDOWN;\r\ntegra_sor_writel(sor, value, SOR_PLL_2);\r\nusleep_range(20, 100);\r\nvalue = tegra_sor_readl(sor, SOR_PLL_0);\r\nvalue |= SOR_PLL_0_POWER_OFF;\r\nvalue |= SOR_PLL_0_VCOPD;\r\ntegra_sor_writel(sor, value, SOR_PLL_0);\r\nvalue = tegra_sor_readl(sor, SOR_PLL_2);\r\nvalue |= SOR_PLL_2_SEQ_PLLCAPPD;\r\nvalue |= SOR_PLL_2_SEQ_PLLCAPPD_ENFORCE;\r\ntegra_sor_writel(sor, value, SOR_PLL_2);\r\nusleep_range(20, 100);\r\nreturn 0;\r\n}\r\nstatic int tegra_sor_crc_open(struct inode *inode, struct file *file)\r\n{\r\nfile->private_data = inode->i_private;\r\nreturn 0;\r\n}\r\nstatic int tegra_sor_crc_release(struct inode *inode, struct file *file)\r\n{\r\nreturn 0;\r\n}\r\nstatic int tegra_sor_crc_wait(struct tegra_sor *sor, unsigned long timeout)\r\n{\r\nu32 value;\r\ntimeout = jiffies + msecs_to_jiffies(timeout);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = tegra_sor_readl(sor, SOR_CRC_A);\r\nif (value & SOR_CRC_A_VALID)\r\nreturn 0;\r\nusleep_range(100, 200);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic ssize_t tegra_sor_crc_read(struct file *file, char __user *buffer,\r\nsize_t size, loff_t *ppos)\r\n{\r\nstruct tegra_sor *sor = file->private_data;\r\nssize_t num, err;\r\nchar buf[10];\r\nu32 value;\r\nmutex_lock(&sor->lock);\r\nif (!sor->enabled) {\r\nerr = -EAGAIN;\r\ngoto unlock;\r\n}\r\nvalue = tegra_sor_readl(sor, SOR_STATE_1);\r\nvalue &= ~SOR_STATE_ASY_CRC_MODE_MASK;\r\ntegra_sor_writel(sor, value, SOR_STATE_1);\r\nvalue = tegra_sor_readl(sor, SOR_CRC_CNTRL);\r\nvalue |= SOR_CRC_CNTRL_ENABLE;\r\ntegra_sor_writel(sor, value, SOR_CRC_CNTRL);\r\nvalue = tegra_sor_readl(sor, SOR_TEST);\r\nvalue &= ~SOR_TEST_CRC_POST_SERIALIZE;\r\ntegra_sor_writel(sor, value, SOR_TEST);\r\nerr = tegra_sor_crc_wait(sor, 100);\r\nif (err < 0)\r\ngoto unlock;\r\ntegra_sor_writel(sor, SOR_CRC_A_RESET, SOR_CRC_A);\r\nvalue = tegra_sor_readl(sor, SOR_CRC_B);\r\nnum = scnprintf(buf, sizeof(buf), "%08x\n", value);\r\nerr = simple_read_from_buffer(buffer, size, ppos, buf, num);\r\nunlock:\r\nmutex_unlock(&sor->lock);\r\nreturn err;\r\n}\r\nstatic int tegra_sor_show_regs(struct seq_file *s, void *data)\r\n{\r\nstruct drm_info_node *node = s->private;\r\nstruct tegra_sor *sor = node->info_ent->data;\r\n#define DUMP_REG(name) \\r\nseq_printf(s, "%-38s %#05x %08x\n", #name, name, \\r\ntegra_sor_readl(sor, name))\r\nDUMP_REG(SOR_CTXSW);\r\nDUMP_REG(SOR_SUPER_STATE_0);\r\nDUMP_REG(SOR_SUPER_STATE_1);\r\nDUMP_REG(SOR_STATE_0);\r\nDUMP_REG(SOR_STATE_1);\r\nDUMP_REG(SOR_HEAD_STATE_0(0));\r\nDUMP_REG(SOR_HEAD_STATE_0(1));\r\nDUMP_REG(SOR_HEAD_STATE_1(0));\r\nDUMP_REG(SOR_HEAD_STATE_1(1));\r\nDUMP_REG(SOR_HEAD_STATE_2(0));\r\nDUMP_REG(SOR_HEAD_STATE_2(1));\r\nDUMP_REG(SOR_HEAD_STATE_3(0));\r\nDUMP_REG(SOR_HEAD_STATE_3(1));\r\nDUMP_REG(SOR_HEAD_STATE_4(0));\r\nDUMP_REG(SOR_HEAD_STATE_4(1));\r\nDUMP_REG(SOR_HEAD_STATE_5(0));\r\nDUMP_REG(SOR_HEAD_STATE_5(1));\r\nDUMP_REG(SOR_CRC_CNTRL);\r\nDUMP_REG(SOR_DP_DEBUG_MVID);\r\nDUMP_REG(SOR_CLK_CNTRL);\r\nDUMP_REG(SOR_CAP);\r\nDUMP_REG(SOR_PWR);\r\nDUMP_REG(SOR_TEST);\r\nDUMP_REG(SOR_PLL_0);\r\nDUMP_REG(SOR_PLL_1);\r\nDUMP_REG(SOR_PLL_2);\r\nDUMP_REG(SOR_PLL_3);\r\nDUMP_REG(SOR_CSTM);\r\nDUMP_REG(SOR_LVDS);\r\nDUMP_REG(SOR_CRC_A);\r\nDUMP_REG(SOR_CRC_B);\r\nDUMP_REG(SOR_BLANK);\r\nDUMP_REG(SOR_SEQ_CTL);\r\nDUMP_REG(SOR_LANE_SEQ_CTL);\r\nDUMP_REG(SOR_SEQ_INST(0));\r\nDUMP_REG(SOR_SEQ_INST(1));\r\nDUMP_REG(SOR_SEQ_INST(2));\r\nDUMP_REG(SOR_SEQ_INST(3));\r\nDUMP_REG(SOR_SEQ_INST(4));\r\nDUMP_REG(SOR_SEQ_INST(5));\r\nDUMP_REG(SOR_SEQ_INST(6));\r\nDUMP_REG(SOR_SEQ_INST(7));\r\nDUMP_REG(SOR_SEQ_INST(8));\r\nDUMP_REG(SOR_SEQ_INST(9));\r\nDUMP_REG(SOR_SEQ_INST(10));\r\nDUMP_REG(SOR_SEQ_INST(11));\r\nDUMP_REG(SOR_SEQ_INST(12));\r\nDUMP_REG(SOR_SEQ_INST(13));\r\nDUMP_REG(SOR_SEQ_INST(14));\r\nDUMP_REG(SOR_SEQ_INST(15));\r\nDUMP_REG(SOR_PWM_DIV);\r\nDUMP_REG(SOR_PWM_CTL);\r\nDUMP_REG(SOR_VCRC_A_0);\r\nDUMP_REG(SOR_VCRC_A_1);\r\nDUMP_REG(SOR_VCRC_B_0);\r\nDUMP_REG(SOR_VCRC_B_1);\r\nDUMP_REG(SOR_CCRC_A_0);\r\nDUMP_REG(SOR_CCRC_A_1);\r\nDUMP_REG(SOR_CCRC_B_0);\r\nDUMP_REG(SOR_CCRC_B_1);\r\nDUMP_REG(SOR_EDATA_A_0);\r\nDUMP_REG(SOR_EDATA_A_1);\r\nDUMP_REG(SOR_EDATA_B_0);\r\nDUMP_REG(SOR_EDATA_B_1);\r\nDUMP_REG(SOR_COUNT_A_0);\r\nDUMP_REG(SOR_COUNT_A_1);\r\nDUMP_REG(SOR_COUNT_B_0);\r\nDUMP_REG(SOR_COUNT_B_1);\r\nDUMP_REG(SOR_DEBUG_A_0);\r\nDUMP_REG(SOR_DEBUG_A_1);\r\nDUMP_REG(SOR_DEBUG_B_0);\r\nDUMP_REG(SOR_DEBUG_B_1);\r\nDUMP_REG(SOR_TRIG);\r\nDUMP_REG(SOR_MSCHECK);\r\nDUMP_REG(SOR_XBAR_CTRL);\r\nDUMP_REG(SOR_XBAR_POL);\r\nDUMP_REG(SOR_DP_LINKCTL_0);\r\nDUMP_REG(SOR_DP_LINKCTL_1);\r\nDUMP_REG(SOR_LANE_DRIVE_CURRENT_0);\r\nDUMP_REG(SOR_LANE_DRIVE_CURRENT_1);\r\nDUMP_REG(SOR_LANE4_DRIVE_CURRENT_0);\r\nDUMP_REG(SOR_LANE4_DRIVE_CURRENT_1);\r\nDUMP_REG(SOR_LANE_PREEMPHASIS_0);\r\nDUMP_REG(SOR_LANE_PREEMPHASIS_1);\r\nDUMP_REG(SOR_LANE4_PREEMPHASIS_0);\r\nDUMP_REG(SOR_LANE4_PREEMPHASIS_1);\r\nDUMP_REG(SOR_LANE_POST_CURSOR_0);\r\nDUMP_REG(SOR_LANE_POST_CURSOR_1);\r\nDUMP_REG(SOR_DP_CONFIG_0);\r\nDUMP_REG(SOR_DP_CONFIG_1);\r\nDUMP_REG(SOR_DP_MN_0);\r\nDUMP_REG(SOR_DP_MN_1);\r\nDUMP_REG(SOR_DP_PADCTL_0);\r\nDUMP_REG(SOR_DP_PADCTL_1);\r\nDUMP_REG(SOR_DP_DEBUG_0);\r\nDUMP_REG(SOR_DP_DEBUG_1);\r\nDUMP_REG(SOR_DP_SPARE_0);\r\nDUMP_REG(SOR_DP_SPARE_1);\r\nDUMP_REG(SOR_DP_AUDIO_CTRL);\r\nDUMP_REG(SOR_DP_AUDIO_HBLANK_SYMBOLS);\r\nDUMP_REG(SOR_DP_AUDIO_VBLANK_SYMBOLS);\r\nDUMP_REG(SOR_DP_GENERIC_INFOFRAME_HEADER);\r\nDUMP_REG(SOR_DP_GENERIC_INFOFRAME_SUBPACK_0);\r\nDUMP_REG(SOR_DP_GENERIC_INFOFRAME_SUBPACK_1);\r\nDUMP_REG(SOR_DP_GENERIC_INFOFRAME_SUBPACK_2);\r\nDUMP_REG(SOR_DP_GENERIC_INFOFRAME_SUBPACK_3);\r\nDUMP_REG(SOR_DP_GENERIC_INFOFRAME_SUBPACK_4);\r\nDUMP_REG(SOR_DP_GENERIC_INFOFRAME_SUBPACK_5);\r\nDUMP_REG(SOR_DP_GENERIC_INFOFRAME_SUBPACK_6);\r\nDUMP_REG(SOR_DP_TPG);\r\nDUMP_REG(SOR_DP_TPG_CONFIG);\r\nDUMP_REG(SOR_DP_LQ_CSTM_0);\r\nDUMP_REG(SOR_DP_LQ_CSTM_1);\r\nDUMP_REG(SOR_DP_LQ_CSTM_2);\r\n#undef DUMP_REG\r\nreturn 0;\r\n}\r\nstatic int tegra_sor_debugfs_init(struct tegra_sor *sor,\r\nstruct drm_minor *minor)\r\n{\r\nstruct dentry *entry;\r\nunsigned int i;\r\nint err = 0;\r\nsor->debugfs = debugfs_create_dir("sor", minor->debugfs_root);\r\nif (!sor->debugfs)\r\nreturn -ENOMEM;\r\nsor->debugfs_files = kmemdup(debugfs_files, sizeof(debugfs_files),\r\nGFP_KERNEL);\r\nif (!sor->debugfs_files) {\r\nerr = -ENOMEM;\r\ngoto remove;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(debugfs_files); i++)\r\nsor->debugfs_files[i].data = sor;\r\nerr = drm_debugfs_create_files(sor->debugfs_files,\r\nARRAY_SIZE(debugfs_files),\r\nsor->debugfs, minor);\r\nif (err < 0)\r\ngoto free;\r\nentry = debugfs_create_file("crc", 0644, sor->debugfs, sor,\r\n&tegra_sor_crc_fops);\r\nif (!entry) {\r\nerr = -ENOMEM;\r\ngoto free;\r\n}\r\nreturn err;\r\nfree:\r\nkfree(sor->debugfs_files);\r\nsor->debugfs_files = NULL;\r\nremove:\r\ndebugfs_remove_recursive(sor->debugfs);\r\nsor->debugfs = NULL;\r\nreturn err;\r\n}\r\nstatic void tegra_sor_debugfs_exit(struct tegra_sor *sor)\r\n{\r\ndrm_debugfs_remove_files(sor->debugfs_files, ARRAY_SIZE(debugfs_files),\r\nsor->minor);\r\nsor->minor = NULL;\r\nkfree(sor->debugfs_files);\r\nsor->debugfs = NULL;\r\ndebugfs_remove_recursive(sor->debugfs);\r\nsor->debugfs_files = NULL;\r\n}\r\nstatic void tegra_sor_connector_dpms(struct drm_connector *connector, int mode)\r\n{\r\n}\r\nstatic enum drm_connector_status\r\ntegra_sor_connector_detect(struct drm_connector *connector, bool force)\r\n{\r\nstruct tegra_output *output = connector_to_output(connector);\r\nstruct tegra_sor *sor = to_sor(output);\r\nif (sor->dpaux)\r\nreturn tegra_dpaux_detect(sor->dpaux);\r\nreturn connector_status_unknown;\r\n}\r\nstatic int tegra_sor_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct tegra_output *output = connector_to_output(connector);\r\nstruct tegra_sor *sor = to_sor(output);\r\nint err;\r\nif (sor->dpaux)\r\ntegra_dpaux_enable(sor->dpaux);\r\nerr = tegra_output_connector_get_modes(connector);\r\nif (sor->dpaux)\r\ntegra_dpaux_disable(sor->dpaux);\r\nreturn err;\r\n}\r\nstatic enum drm_mode_status\r\ntegra_sor_connector_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nreturn MODE_OK;\r\n}\r\nstatic void tegra_sor_encoder_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\n}\r\nstatic void tegra_sor_encoder_prepare(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic void tegra_sor_encoder_commit(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic void tegra_sor_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted)\r\n{\r\nstruct tegra_output *output = encoder_to_output(encoder);\r\nstruct tegra_dc *dc = to_tegra_dc(encoder->crtc);\r\nunsigned int vbe, vse, hbe, hse, vbs, hbs, i;\r\nstruct tegra_sor *sor = to_sor(output);\r\nstruct tegra_sor_config config;\r\nstruct drm_dp_link link;\r\nstruct drm_dp_aux *aux;\r\nint err = 0;\r\nu32 value;\r\nmutex_lock(&sor->lock);\r\nif (sor->enabled)\r\ngoto unlock;\r\nerr = clk_prepare_enable(sor->clk);\r\nif (err < 0)\r\ngoto unlock;\r\nreset_control_deassert(sor->rst);\r\nif (output->panel)\r\ndrm_panel_prepare(output->panel);\r\naux = (struct drm_dp_aux *)sor->dpaux;\r\nif (sor->dpaux) {\r\nerr = tegra_dpaux_enable(sor->dpaux);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to enable DP: %d\n", err);\r\nerr = drm_dp_link_probe(aux, &link);\r\nif (err < 0) {\r\ndev_err(sor->dev, "failed to probe eDP link: %d\n",\r\nerr);\r\ngoto unlock;\r\n}\r\n}\r\nerr = clk_set_parent(sor->clk, sor->clk_safe);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to set safe parent clock: %d\n", err);\r\nmemset(&config, 0, sizeof(config));\r\nconfig.bits_per_pixel = output->connector.display_info.bpc * 3;\r\nerr = tegra_sor_calc_config(sor, mode, &config, &link);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to compute link configuration: %d\n",\r\nerr);\r\nvalue = tegra_sor_readl(sor, SOR_CLK_CNTRL);\r\nvalue &= ~SOR_CLK_CNTRL_DP_CLK_SEL_MASK;\r\nvalue |= SOR_CLK_CNTRL_DP_CLK_SEL_SINGLE_DPCLK;\r\ntegra_sor_writel(sor, value, SOR_CLK_CNTRL);\r\nvalue = tegra_sor_readl(sor, SOR_PLL_2);\r\nvalue &= ~SOR_PLL_2_BANDGAP_POWERDOWN;\r\ntegra_sor_writel(sor, value, SOR_PLL_2);\r\nusleep_range(20, 100);\r\nvalue = tegra_sor_readl(sor, SOR_PLL_3);\r\nvalue |= SOR_PLL_3_PLL_VDD_MODE_V3_3;\r\ntegra_sor_writel(sor, value, SOR_PLL_3);\r\nvalue = SOR_PLL_0_ICHPMP(0xf) | SOR_PLL_0_VCOCAP_RST |\r\nSOR_PLL_0_PLLREG_LEVEL_V45 | SOR_PLL_0_RESISTOR_EXT;\r\ntegra_sor_writel(sor, value, SOR_PLL_0);\r\nvalue = tegra_sor_readl(sor, SOR_PLL_2);\r\nvalue |= SOR_PLL_2_SEQ_PLLCAPPD;\r\nvalue &= ~SOR_PLL_2_SEQ_PLLCAPPD_ENFORCE;\r\nvalue |= SOR_PLL_2_LVDS_ENABLE;\r\ntegra_sor_writel(sor, value, SOR_PLL_2);\r\nvalue = SOR_PLL_1_TERM_COMPOUT | SOR_PLL_1_TMDS_TERM;\r\ntegra_sor_writel(sor, value, SOR_PLL_1);\r\nwhile (true) {\r\nvalue = tegra_sor_readl(sor, SOR_PLL_2);\r\nif ((value & SOR_PLL_2_SEQ_PLLCAPPD_ENFORCE) == 0)\r\nbreak;\r\nusleep_range(250, 1000);\r\n}\r\nvalue = tegra_sor_readl(sor, SOR_PLL_2);\r\nvalue &= ~SOR_PLL_2_POWERDOWN_OVERRIDE;\r\nvalue &= ~SOR_PLL_2_PORT_POWERDOWN;\r\ntegra_sor_writel(sor, value, SOR_PLL_2);\r\nvalue = tegra_sor_readl(sor, SOR_CLK_CNTRL);\r\nvalue &= ~SOR_CLK_CNTRL_DP_LINK_SPEED_MASK;\r\nvalue |= SOR_CLK_CNTRL_DP_LINK_SPEED_G1_62;\r\ntegra_sor_writel(sor, value, SOR_CLK_CNTRL);\r\nvalue = tegra_sor_readl(sor, SOR_PLL_2);\r\nvalue |= SOR_PLL_2_SEQ_PLLCAPPD_ENFORCE | SOR_PLL_2_PORT_POWERDOWN |\r\nSOR_PLL_2_BANDGAP_POWERDOWN;\r\ntegra_sor_writel(sor, value, SOR_PLL_2);\r\nvalue = tegra_sor_readl(sor, SOR_PLL_0);\r\nvalue |= SOR_PLL_0_VCOPD | SOR_PLL_0_POWER_OFF;\r\ntegra_sor_writel(sor, value, SOR_PLL_0);\r\nvalue = tegra_sor_readl(sor, SOR_DP_PADCTL_0);\r\nvalue &= ~SOR_DP_PADCTL_PAD_CAL_PD;\r\ntegra_sor_writel(sor, value, SOR_DP_PADCTL_0);\r\nerr = tegra_io_rail_power_on(TEGRA_IO_RAIL_LVDS);\r\nif (err < 0) {\r\ndev_err(sor->dev, "failed to power on I/O rail: %d\n", err);\r\ngoto unlock;\r\n}\r\nusleep_range(5, 100);\r\nvalue = tegra_sor_readl(sor, SOR_PLL_2);\r\nvalue &= ~SOR_PLL_2_BANDGAP_POWERDOWN;\r\ntegra_sor_writel(sor, value, SOR_PLL_2);\r\nusleep_range(20, 100);\r\nvalue = tegra_sor_readl(sor, SOR_PLL_0);\r\nvalue &= ~SOR_PLL_0_POWER_OFF;\r\nvalue &= ~SOR_PLL_0_VCOPD;\r\ntegra_sor_writel(sor, value, SOR_PLL_0);\r\nvalue = tegra_sor_readl(sor, SOR_PLL_2);\r\nvalue &= ~SOR_PLL_2_SEQ_PLLCAPPD_ENFORCE;\r\ntegra_sor_writel(sor, value, SOR_PLL_2);\r\nusleep_range(200, 1000);\r\nvalue = tegra_sor_readl(sor, SOR_PLL_2);\r\nvalue &= ~SOR_PLL_2_PORT_POWERDOWN;\r\ntegra_sor_writel(sor, value, SOR_PLL_2);\r\nerr = clk_set_parent(sor->clk, sor->clk_dp);\r\nif (err < 0)\r\ndev_err(sor->dev, "failed to set DP parent clock: %d\n", err);\r\nvalue = tegra_sor_readl(sor, SOR_DP_PADCTL_0);\r\nif (link.num_lanes <= 2)\r\nvalue &= ~(SOR_DP_PADCTL_PD_TXD_3 | SOR_DP_PADCTL_PD_TXD_2);\r\nelse\r\nvalue |= SOR_DP_PADCTL_PD_TXD_3 | SOR_DP_PADCTL_PD_TXD_2;\r\nif (link.num_lanes <= 1)\r\nvalue &= ~SOR_DP_PADCTL_PD_TXD_1;\r\nelse\r\nvalue |= SOR_DP_PADCTL_PD_TXD_1;\r\nif (link.num_lanes == 0)\r\nvalue &= ~SOR_DP_PADCTL_PD_TXD_0;\r\nelse\r\nvalue |= SOR_DP_PADCTL_PD_TXD_0;\r\ntegra_sor_writel(sor, value, SOR_DP_PADCTL_0);\r\nvalue = tegra_sor_readl(sor, SOR_DP_LINKCTL_0);\r\nvalue &= ~SOR_DP_LINKCTL_LANE_COUNT_MASK;\r\nvalue |= SOR_DP_LINKCTL_LANE_COUNT(link.num_lanes);\r\ntegra_sor_writel(sor, value, SOR_DP_LINKCTL_0);\r\nvalue = SOR_LANE_SEQ_CTL_TRIGGER | SOR_LANE_SEQ_CTL_SEQUENCE_DOWN |\r\nSOR_LANE_SEQ_CTL_POWER_STATE_UP;\r\ntegra_sor_writel(sor, value, SOR_LANE_SEQ_CTL);\r\nwhile (true) {\r\nvalue = tegra_sor_readl(sor, SOR_LANE_SEQ_CTL);\r\nif ((value & SOR_LANE_SEQ_CTL_TRIGGER) == 0)\r\nbreak;\r\nusleep_range(250, 1000);\r\n}\r\nvalue = tegra_sor_readl(sor, SOR_CLK_CNTRL);\r\nvalue &= ~SOR_CLK_CNTRL_DP_LINK_SPEED_MASK;\r\nvalue |= drm_dp_link_rate_to_bw_code(link.rate) << 2;\r\ntegra_sor_writel(sor, value, SOR_CLK_CNTRL);\r\nvalue = tegra_sor_readl(sor, SOR_DP_LINKCTL_0);\r\nvalue |= SOR_DP_LINKCTL_ENABLE;\r\nvalue &= ~SOR_DP_LINKCTL_TU_SIZE_MASK;\r\nvalue |= SOR_DP_LINKCTL_TU_SIZE(config.tu_size);\r\nvalue |= SOR_DP_LINKCTL_ENHANCED_FRAME;\r\ntegra_sor_writel(sor, value, SOR_DP_LINKCTL_0);\r\nfor (i = 0, value = 0; i < 4; i++) {\r\nunsigned long lane = SOR_DP_TPG_CHANNEL_CODING |\r\nSOR_DP_TPG_SCRAMBLER_GALIOS |\r\nSOR_DP_TPG_PATTERN_NONE;\r\nvalue = (value << 8) | lane;\r\n}\r\ntegra_sor_writel(sor, value, SOR_DP_TPG);\r\nvalue = tegra_sor_readl(sor, SOR_DP_CONFIG_0);\r\nvalue &= ~SOR_DP_CONFIG_WATERMARK_MASK;\r\nvalue |= SOR_DP_CONFIG_WATERMARK(config.watermark);\r\nvalue &= ~SOR_DP_CONFIG_ACTIVE_SYM_COUNT_MASK;\r\nvalue |= SOR_DP_CONFIG_ACTIVE_SYM_COUNT(config.active_count);\r\nvalue &= ~SOR_DP_CONFIG_ACTIVE_SYM_FRAC_MASK;\r\nvalue |= SOR_DP_CONFIG_ACTIVE_SYM_FRAC(config.active_frac);\r\nif (config.active_polarity)\r\nvalue |= SOR_DP_CONFIG_ACTIVE_SYM_POLARITY;\r\nelse\r\nvalue &= ~SOR_DP_CONFIG_ACTIVE_SYM_POLARITY;\r\nvalue |= SOR_DP_CONFIG_ACTIVE_SYM_ENABLE;\r\nvalue |= SOR_DP_CONFIG_DISPARITY_NEGATIVE;\r\ntegra_sor_writel(sor, value, SOR_DP_CONFIG_0);\r\nvalue = tegra_sor_readl(sor, SOR_DP_AUDIO_HBLANK_SYMBOLS);\r\nvalue &= ~SOR_DP_AUDIO_HBLANK_SYMBOLS_MASK;\r\nvalue |= config.hblank_symbols & 0xffff;\r\ntegra_sor_writel(sor, value, SOR_DP_AUDIO_HBLANK_SYMBOLS);\r\nvalue = tegra_sor_readl(sor, SOR_DP_AUDIO_VBLANK_SYMBOLS);\r\nvalue &= ~SOR_DP_AUDIO_VBLANK_SYMBOLS_MASK;\r\nvalue |= config.vblank_symbols & 0xffff;\r\ntegra_sor_writel(sor, value, SOR_DP_AUDIO_VBLANK_SYMBOLS);\r\nvalue = tegra_sor_readl(sor, SOR_DP_PADCTL_0);\r\nvalue |= SOR_DP_PADCTL_PAD_CAL_PD;\r\ntegra_sor_writel(sor, value, SOR_DP_PADCTL_0);\r\nif (sor->dpaux) {\r\nu8 rate, lanes;\r\nerr = drm_dp_link_probe(aux, &link);\r\nif (err < 0) {\r\ndev_err(sor->dev, "failed to probe eDP link: %d\n",\r\nerr);\r\ngoto unlock;\r\n}\r\nerr = drm_dp_link_power_up(aux, &link);\r\nif (err < 0) {\r\ndev_err(sor->dev, "failed to power up eDP link: %d\n",\r\nerr);\r\ngoto unlock;\r\n}\r\nerr = drm_dp_link_configure(aux, &link);\r\nif (err < 0) {\r\ndev_err(sor->dev, "failed to configure eDP link: %d\n",\r\nerr);\r\ngoto unlock;\r\n}\r\nrate = drm_dp_link_rate_to_bw_code(link.rate);\r\nlanes = link.num_lanes;\r\nvalue = tegra_sor_readl(sor, SOR_CLK_CNTRL);\r\nvalue &= ~SOR_CLK_CNTRL_DP_LINK_SPEED_MASK;\r\nvalue |= SOR_CLK_CNTRL_DP_LINK_SPEED(rate);\r\ntegra_sor_writel(sor, value, SOR_CLK_CNTRL);\r\nvalue = tegra_sor_readl(sor, SOR_DP_LINKCTL_0);\r\nvalue &= ~SOR_DP_LINKCTL_LANE_COUNT_MASK;\r\nvalue |= SOR_DP_LINKCTL_LANE_COUNT(lanes);\r\nif (link.capabilities & DP_LINK_CAP_ENHANCED_FRAMING)\r\nvalue |= SOR_DP_LINKCTL_ENHANCED_FRAME;\r\ntegra_sor_writel(sor, value, SOR_DP_LINKCTL_0);\r\nfor (i = 0; i < link.num_lanes; i++) {\r\nunsigned long lane = SOR_DP_TPG_CHANNEL_CODING |\r\nSOR_DP_TPG_SCRAMBLER_GALIOS |\r\nSOR_DP_TPG_PATTERN_NONE;\r\nvalue = (value << 8) | lane;\r\n}\r\ntegra_sor_writel(sor, value, SOR_DP_TPG);\r\nerr = tegra_sor_dp_train_fast(sor, &link);\r\nif (err < 0) {\r\ndev_err(sor->dev, "DP fast link training failed: %d\n",\r\nerr);\r\ngoto unlock;\r\n}\r\ndev_dbg(sor->dev, "fast link training succeeded\n");\r\n}\r\nerr = tegra_sor_power_up(sor, 250);\r\nif (err < 0) {\r\ndev_err(sor->dev, "failed to power up SOR: %d\n", err);\r\ngoto unlock;\r\n}\r\nvalue = SOR_STATE_ASY_PROTOCOL_DP_A |\r\nSOR_STATE_ASY_CRC_MODE_COMPLETE |\r\nSOR_STATE_ASY_OWNER(dc->pipe + 1);\r\nif (mode->flags & DRM_MODE_FLAG_PHSYNC)\r\nvalue &= ~SOR_STATE_ASY_HSYNCPOL;\r\nif (mode->flags & DRM_MODE_FLAG_NHSYNC)\r\nvalue |= SOR_STATE_ASY_HSYNCPOL;\r\nif (mode->flags & DRM_MODE_FLAG_PVSYNC)\r\nvalue &= ~SOR_STATE_ASY_VSYNCPOL;\r\nif (mode->flags & DRM_MODE_FLAG_NVSYNC)\r\nvalue |= SOR_STATE_ASY_VSYNCPOL;\r\nswitch (config.bits_per_pixel) {\r\ncase 24:\r\nvalue |= SOR_STATE_ASY_PIXELDEPTH_BPP_24_444;\r\nbreak;\r\ncase 18:\r\nvalue |= SOR_STATE_ASY_PIXELDEPTH_BPP_18_444;\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\ntegra_sor_writel(sor, value, SOR_STATE_1);\r\nvalue = ((mode->vtotal & 0x7fff) << 16) | (mode->htotal & 0x7fff);\r\ntegra_sor_writel(sor, value, SOR_HEAD_STATE_1(0));\r\nvse = mode->vsync_end - mode->vsync_start - 1;\r\nhse = mode->hsync_end - mode->hsync_start - 1;\r\nvalue = ((vse & 0x7fff) << 16) | (hse & 0x7fff);\r\ntegra_sor_writel(sor, value, SOR_HEAD_STATE_2(0));\r\nvbe = vse + (mode->vsync_start - mode->vdisplay);\r\nhbe = hse + (mode->hsync_start - mode->hdisplay);\r\nvalue = ((vbe & 0x7fff) << 16) | (hbe & 0x7fff);\r\ntegra_sor_writel(sor, value, SOR_HEAD_STATE_3(0));\r\nvbs = vbe + mode->vdisplay;\r\nhbs = hbe + mode->hdisplay;\r\nvalue = ((vbs & 0x7fff) << 16) | (hbs & 0x7fff);\r\ntegra_sor_writel(sor, value, SOR_HEAD_STATE_4(0));\r\nvalue = SOR_CSTM_LVDS | SOR_CSTM_LINK_ACT_A | SOR_CSTM_LINK_ACT_B |\r\nSOR_CSTM_UPPER;\r\ntegra_sor_writel(sor, value, SOR_CSTM);\r\nerr = tegra_sor_setup_pwm(sor, 250);\r\nif (err < 0) {\r\ndev_err(sor->dev, "failed to setup PWM: %d\n", err);\r\ngoto unlock;\r\n}\r\ntegra_sor_update(sor);\r\nvalue = tegra_dc_readl(dc, DC_DISP_DISP_WIN_OPTIONS);\r\nvalue |= SOR_ENABLE;\r\ntegra_dc_writel(dc, value, DC_DISP_DISP_WIN_OPTIONS);\r\ntegra_dc_commit(dc);\r\nerr = tegra_sor_attach(sor);\r\nif (err < 0) {\r\ndev_err(sor->dev, "failed to attach SOR: %d\n", err);\r\ngoto unlock;\r\n}\r\nerr = tegra_sor_wakeup(sor);\r\nif (err < 0) {\r\ndev_err(sor->dev, "failed to enable DC: %d\n", err);\r\ngoto unlock;\r\n}\r\nif (output->panel)\r\ndrm_panel_enable(output->panel);\r\nsor->enabled = true;\r\nunlock:\r\nmutex_unlock(&sor->lock);\r\n}\r\nstatic void tegra_sor_encoder_disable(struct drm_encoder *encoder)\r\n{\r\nstruct tegra_output *output = encoder_to_output(encoder);\r\nstruct tegra_dc *dc = to_tegra_dc(encoder->crtc);\r\nstruct tegra_sor *sor = to_sor(output);\r\nu32 value;\r\nint err;\r\nmutex_lock(&sor->lock);\r\nif (!sor->enabled)\r\ngoto unlock;\r\nif (output->panel)\r\ndrm_panel_disable(output->panel);\r\nerr = tegra_sor_detach(sor);\r\nif (err < 0) {\r\ndev_err(sor->dev, "failed to detach SOR: %d\n", err);\r\ngoto unlock;\r\n}\r\ntegra_sor_writel(sor, 0, SOR_STATE_1);\r\ntegra_sor_update(sor);\r\nif (dc) {\r\nvalue = tegra_dc_readl(dc, DC_DISP_DISP_WIN_OPTIONS);\r\nvalue &= ~SOR_ENABLE;\r\ntegra_dc_writel(dc, value, DC_DISP_DISP_WIN_OPTIONS);\r\ntegra_dc_commit(dc);\r\n}\r\nerr = tegra_sor_power_down(sor);\r\nif (err < 0) {\r\ndev_err(sor->dev, "failed to power down SOR: %d\n", err);\r\ngoto unlock;\r\n}\r\nif (sor->dpaux) {\r\nerr = tegra_dpaux_disable(sor->dpaux);\r\nif (err < 0) {\r\ndev_err(sor->dev, "failed to disable DP: %d\n", err);\r\ngoto unlock;\r\n}\r\n}\r\nerr = tegra_io_rail_power_off(TEGRA_IO_RAIL_LVDS);\r\nif (err < 0) {\r\ndev_err(sor->dev, "failed to power off I/O rail: %d\n", err);\r\ngoto unlock;\r\n}\r\nif (output->panel)\r\ndrm_panel_unprepare(output->panel);\r\nclk_disable_unprepare(sor->clk);\r\nreset_control_assert(sor->rst);\r\nsor->enabled = false;\r\nunlock:\r\nmutex_unlock(&sor->lock);\r\n}\r\nstatic int\r\ntegra_sor_encoder_atomic_check(struct drm_encoder *encoder,\r\nstruct drm_crtc_state *crtc_state,\r\nstruct drm_connector_state *conn_state)\r\n{\r\nstruct tegra_output *output = encoder_to_output(encoder);\r\nstruct tegra_dc *dc = to_tegra_dc(conn_state->crtc);\r\nunsigned long pclk = crtc_state->mode.clock * 1000;\r\nstruct tegra_sor *sor = to_sor(output);\r\nint err;\r\nerr = tegra_dc_state_setup_clock(dc, crtc_state, sor->clk_parent,\r\npclk, 0);\r\nif (err < 0) {\r\ndev_err(output->dev, "failed to setup CRTC state: %d\n", err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tegra_sor_init(struct host1x_client *client)\r\n{\r\nstruct drm_device *drm = dev_get_drvdata(client->parent);\r\nstruct tegra_sor *sor = host1x_client_to_sor(client);\r\nint err;\r\nif (!sor->dpaux)\r\nreturn -ENODEV;\r\nsor->output.dev = sor->dev;\r\ndrm_connector_init(drm, &sor->output.connector,\r\n&tegra_sor_connector_funcs,\r\nDRM_MODE_CONNECTOR_eDP);\r\ndrm_connector_helper_add(&sor->output.connector,\r\n&tegra_sor_connector_helper_funcs);\r\nsor->output.connector.dpms = DRM_MODE_DPMS_OFF;\r\ndrm_encoder_init(drm, &sor->output.encoder, &tegra_sor_encoder_funcs,\r\nDRM_MODE_ENCODER_TMDS);\r\ndrm_encoder_helper_add(&sor->output.encoder,\r\n&tegra_sor_encoder_helper_funcs);\r\ndrm_mode_connector_attach_encoder(&sor->output.connector,\r\n&sor->output.encoder);\r\ndrm_connector_register(&sor->output.connector);\r\nerr = tegra_output_init(drm, &sor->output);\r\nif (err < 0) {\r\ndev_err(client->dev, "failed to initialize output: %d\n", err);\r\nreturn err;\r\n}\r\nsor->output.encoder.possible_crtcs = 0x3;\r\nif (IS_ENABLED(CONFIG_DEBUG_FS)) {\r\nerr = tegra_sor_debugfs_init(sor, drm->primary);\r\nif (err < 0)\r\ndev_err(sor->dev, "debugfs setup failed: %d\n", err);\r\n}\r\nif (sor->dpaux) {\r\nerr = tegra_dpaux_attach(sor->dpaux, &sor->output);\r\nif (err < 0) {\r\ndev_err(sor->dev, "failed to attach DP: %d\n", err);\r\nreturn err;\r\n}\r\n}\r\nerr = reset_control_assert(sor->rst);\r\nif (err < 0) {\r\ndev_err(sor->dev, "failed to assert SOR reset: %d\n", err);\r\nreturn err;\r\n}\r\nerr = clk_prepare_enable(sor->clk);\r\nif (err < 0) {\r\ndev_err(sor->dev, "failed to enable clock: %d\n", err);\r\nreturn err;\r\n}\r\nusleep_range(1000, 3000);\r\nerr = reset_control_deassert(sor->rst);\r\nif (err < 0) {\r\ndev_err(sor->dev, "failed to deassert SOR reset: %d\n", err);\r\nreturn err;\r\n}\r\nerr = clk_prepare_enable(sor->clk_safe);\r\nif (err < 0)\r\nreturn err;\r\nerr = clk_prepare_enable(sor->clk_dp);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int tegra_sor_exit(struct host1x_client *client)\r\n{\r\nstruct tegra_sor *sor = host1x_client_to_sor(client);\r\nint err;\r\ntegra_output_exit(&sor->output);\r\nif (sor->dpaux) {\r\nerr = tegra_dpaux_detach(sor->dpaux);\r\nif (err < 0) {\r\ndev_err(sor->dev, "failed to detach DP: %d\n", err);\r\nreturn err;\r\n}\r\n}\r\nclk_disable_unprepare(sor->clk_safe);\r\nclk_disable_unprepare(sor->clk_dp);\r\nclk_disable_unprepare(sor->clk);\r\nif (IS_ENABLED(CONFIG_DEBUG_FS))\r\ntegra_sor_debugfs_exit(sor);\r\nreturn 0;\r\n}\r\nstatic int tegra_sor_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np;\r\nstruct tegra_sor *sor;\r\nstruct resource *regs;\r\nint err;\r\nsor = devm_kzalloc(&pdev->dev, sizeof(*sor), GFP_KERNEL);\r\nif (!sor)\r\nreturn -ENOMEM;\r\nsor->output.dev = sor->dev = &pdev->dev;\r\nnp = of_parse_phandle(pdev->dev.of_node, "nvidia,dpaux", 0);\r\nif (np) {\r\nsor->dpaux = tegra_dpaux_find_by_of_node(np);\r\nof_node_put(np);\r\nif (!sor->dpaux)\r\nreturn -EPROBE_DEFER;\r\n}\r\nerr = tegra_output_probe(&sor->output);\r\nif (err < 0)\r\nreturn err;\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nsor->regs = devm_ioremap_resource(&pdev->dev, regs);\r\nif (IS_ERR(sor->regs))\r\nreturn PTR_ERR(sor->regs);\r\nsor->rst = devm_reset_control_get(&pdev->dev, "sor");\r\nif (IS_ERR(sor->rst))\r\nreturn PTR_ERR(sor->rst);\r\nsor->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(sor->clk))\r\nreturn PTR_ERR(sor->clk);\r\nsor->clk_parent = devm_clk_get(&pdev->dev, "parent");\r\nif (IS_ERR(sor->clk_parent))\r\nreturn PTR_ERR(sor->clk_parent);\r\nsor->clk_safe = devm_clk_get(&pdev->dev, "safe");\r\nif (IS_ERR(sor->clk_safe))\r\nreturn PTR_ERR(sor->clk_safe);\r\nsor->clk_dp = devm_clk_get(&pdev->dev, "dp");\r\nif (IS_ERR(sor->clk_dp))\r\nreturn PTR_ERR(sor->clk_dp);\r\nINIT_LIST_HEAD(&sor->client.list);\r\nsor->client.ops = &sor_client_ops;\r\nsor->client.dev = &pdev->dev;\r\nmutex_init(&sor->lock);\r\nerr = host1x_client_register(&sor->client);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to register host1x client: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nplatform_set_drvdata(pdev, sor);\r\nreturn 0;\r\n}\r\nstatic int tegra_sor_remove(struct platform_device *pdev)\r\n{\r\nstruct tegra_sor *sor = platform_get_drvdata(pdev);\r\nint err;\r\nerr = host1x_client_unregister(&sor->client);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to unregister host1x client: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\ntegra_output_remove(&sor->output);\r\nreturn 0;\r\n}
