static void radeon_fence_write(struct radeon_device *rdev, u32 seq, int ring)\r\n{\r\nstruct radeon_fence_driver *drv = &rdev->fence_drv[ring];\r\nif (likely(rdev->wb.enabled || !drv->scratch_reg)) {\r\nif (drv->cpu_addr) {\r\n*drv->cpu_addr = cpu_to_le32(seq);\r\n}\r\n} else {\r\nWREG32(drv->scratch_reg, seq);\r\n}\r\n}\r\nstatic u32 radeon_fence_read(struct radeon_device *rdev, int ring)\r\n{\r\nstruct radeon_fence_driver *drv = &rdev->fence_drv[ring];\r\nu32 seq = 0;\r\nif (likely(rdev->wb.enabled || !drv->scratch_reg)) {\r\nif (drv->cpu_addr) {\r\nseq = le32_to_cpu(*drv->cpu_addr);\r\n} else {\r\nseq = lower_32_bits(atomic64_read(&drv->last_seq));\r\n}\r\n} else {\r\nseq = RREG32(drv->scratch_reg);\r\n}\r\nreturn seq;\r\n}\r\nstatic void radeon_fence_schedule_check(struct radeon_device *rdev, int ring)\r\n{\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&rdev->fence_drv[ring].lockup_work,\r\nRADEON_FENCE_JIFFIES_TIMEOUT);\r\n}\r\nint radeon_fence_emit(struct radeon_device *rdev,\r\nstruct radeon_fence **fence,\r\nint ring)\r\n{\r\nu64 seq = ++rdev->fence_drv[ring].sync_seq[ring];\r\n*fence = kmalloc(sizeof(struct radeon_fence), GFP_KERNEL);\r\nif ((*fence) == NULL) {\r\nreturn -ENOMEM;\r\n}\r\n(*fence)->rdev = rdev;\r\n(*fence)->seq = seq;\r\n(*fence)->ring = ring;\r\n(*fence)->is_vm_update = false;\r\nfence_init(&(*fence)->base, &radeon_fence_ops,\r\n&rdev->fence_queue.lock, rdev->fence_context + ring, seq);\r\nradeon_fence_ring_emit(rdev, ring, *fence);\r\ntrace_radeon_fence_emit(rdev->ddev, ring, (*fence)->seq);\r\nradeon_fence_schedule_check(rdev, ring);\r\nreturn 0;\r\n}\r\nstatic int radeon_fence_check_signaled(wait_queue_t *wait, unsigned mode, int flags, void *key)\r\n{\r\nstruct radeon_fence *fence;\r\nu64 seq;\r\nfence = container_of(wait, struct radeon_fence, fence_wake);\r\nseq = atomic64_read(&fence->rdev->fence_drv[fence->ring].last_seq);\r\nif (seq >= fence->seq) {\r\nint ret = fence_signal_locked(&fence->base);\r\nif (!ret)\r\nFENCE_TRACE(&fence->base, "signaled from irq context\n");\r\nelse\r\nFENCE_TRACE(&fence->base, "was already signaled\n");\r\nradeon_irq_kms_sw_irq_put(fence->rdev, fence->ring);\r\n__remove_wait_queue(&fence->rdev->fence_queue, &fence->fence_wake);\r\nfence_put(&fence->base);\r\n} else\r\nFENCE_TRACE(&fence->base, "pending\n");\r\nreturn 0;\r\n}\r\nstatic bool radeon_fence_activity(struct radeon_device *rdev, int ring)\r\n{\r\nuint64_t seq, last_seq, last_emitted;\r\nunsigned count_loop = 0;\r\nbool wake = false;\r\nlast_seq = atomic64_read(&rdev->fence_drv[ring].last_seq);\r\ndo {\r\nlast_emitted = rdev->fence_drv[ring].sync_seq[ring];\r\nseq = radeon_fence_read(rdev, ring);\r\nseq |= last_seq & 0xffffffff00000000LL;\r\nif (seq < last_seq) {\r\nseq &= 0xffffffff;\r\nseq |= last_emitted & 0xffffffff00000000LL;\r\n}\r\nif (seq <= last_seq || seq > last_emitted) {\r\nbreak;\r\n}\r\nwake = true;\r\nlast_seq = seq;\r\nif ((count_loop++) > 10) {\r\nbreak;\r\n}\r\n} while (atomic64_xchg(&rdev->fence_drv[ring].last_seq, seq) > seq);\r\nif (seq < last_emitted)\r\nradeon_fence_schedule_check(rdev, ring);\r\nreturn wake;\r\n}\r\nstatic void radeon_fence_check_lockup(struct work_struct *work)\r\n{\r\nstruct radeon_fence_driver *fence_drv;\r\nstruct radeon_device *rdev;\r\nint ring;\r\nfence_drv = container_of(work, struct radeon_fence_driver,\r\nlockup_work.work);\r\nrdev = fence_drv->rdev;\r\nring = fence_drv - &rdev->fence_drv[0];\r\nif (!down_read_trylock(&rdev->exclusive_lock)) {\r\nradeon_fence_schedule_check(rdev, ring);\r\nreturn;\r\n}\r\nif (fence_drv->delayed_irq && rdev->ddev->irq_enabled) {\r\nunsigned long irqflags;\r\nfence_drv->delayed_irq = false;\r\nspin_lock_irqsave(&rdev->irq.lock, irqflags);\r\nradeon_irq_set(rdev);\r\nspin_unlock_irqrestore(&rdev->irq.lock, irqflags);\r\n}\r\nif (radeon_fence_activity(rdev, ring))\r\nwake_up_all(&rdev->fence_queue);\r\nelse if (radeon_ring_is_lockup(rdev, ring, &rdev->ring[ring])) {\r\ndev_warn(rdev->dev, "GPU lockup (current fence id "\r\n"0x%016llx last fence id 0x%016llx on ring %d)\n",\r\n(uint64_t)atomic64_read(&fence_drv->last_seq),\r\nfence_drv->sync_seq[ring], ring);\r\nrdev->needs_reset = true;\r\nwake_up_all(&rdev->fence_queue);\r\n}\r\nup_read(&rdev->exclusive_lock);\r\n}\r\nvoid radeon_fence_process(struct radeon_device *rdev, int ring)\r\n{\r\nif (radeon_fence_activity(rdev, ring))\r\nwake_up_all(&rdev->fence_queue);\r\n}\r\nstatic bool radeon_fence_seq_signaled(struct radeon_device *rdev,\r\nu64 seq, unsigned ring)\r\n{\r\nif (atomic64_read(&rdev->fence_drv[ring].last_seq) >= seq) {\r\nreturn true;\r\n}\r\nradeon_fence_process(rdev, ring);\r\nif (atomic64_read(&rdev->fence_drv[ring].last_seq) >= seq) {\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool radeon_fence_is_signaled(struct fence *f)\r\n{\r\nstruct radeon_fence *fence = to_radeon_fence(f);\r\nstruct radeon_device *rdev = fence->rdev;\r\nunsigned ring = fence->ring;\r\nu64 seq = fence->seq;\r\nif (atomic64_read(&rdev->fence_drv[ring].last_seq) >= seq) {\r\nreturn true;\r\n}\r\nif (down_read_trylock(&rdev->exclusive_lock)) {\r\nradeon_fence_process(rdev, ring);\r\nup_read(&rdev->exclusive_lock);\r\nif (atomic64_read(&rdev->fence_drv[ring].last_seq) >= seq) {\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic bool radeon_fence_enable_signaling(struct fence *f)\r\n{\r\nstruct radeon_fence *fence = to_radeon_fence(f);\r\nstruct radeon_device *rdev = fence->rdev;\r\nif (atomic64_read(&rdev->fence_drv[fence->ring].last_seq) >= fence->seq)\r\nreturn false;\r\nif (down_read_trylock(&rdev->exclusive_lock)) {\r\nradeon_irq_kms_sw_irq_get(rdev, fence->ring);\r\nif (radeon_fence_activity(rdev, fence->ring))\r\nwake_up_all_locked(&rdev->fence_queue);\r\nif (atomic64_read(&rdev->fence_drv[fence->ring].last_seq) >= fence->seq) {\r\nradeon_irq_kms_sw_irq_put(rdev, fence->ring);\r\nup_read(&rdev->exclusive_lock);\r\nreturn false;\r\n}\r\nup_read(&rdev->exclusive_lock);\r\n} else {\r\nif (radeon_irq_kms_sw_irq_get_delayed(rdev, fence->ring))\r\nrdev->fence_drv[fence->ring].delayed_irq = true;\r\nradeon_fence_schedule_check(rdev, fence->ring);\r\n}\r\nfence->fence_wake.flags = 0;\r\nfence->fence_wake.private = NULL;\r\nfence->fence_wake.func = radeon_fence_check_signaled;\r\n__add_wait_queue(&rdev->fence_queue, &fence->fence_wake);\r\nfence_get(f);\r\nFENCE_TRACE(&fence->base, "armed on ring %i!\n", fence->ring);\r\nreturn true;\r\n}\r\nbool radeon_fence_signaled(struct radeon_fence *fence)\r\n{\r\nif (!fence)\r\nreturn true;\r\nif (radeon_fence_seq_signaled(fence->rdev, fence->seq, fence->ring)) {\r\nint ret;\r\nret = fence_signal(&fence->base);\r\nif (!ret)\r\nFENCE_TRACE(&fence->base, "signaled from radeon_fence_signaled\n");\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool radeon_fence_any_seq_signaled(struct radeon_device *rdev, u64 *seq)\r\n{\r\nunsigned i;\r\nfor (i = 0; i < RADEON_NUM_RINGS; ++i) {\r\nif (seq[i] && radeon_fence_seq_signaled(rdev, seq[i], i))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic long radeon_fence_wait_seq_timeout(struct radeon_device *rdev,\r\nu64 *target_seq, bool intr,\r\nlong timeout)\r\n{\r\nlong r;\r\nint i;\r\nif (radeon_fence_any_seq_signaled(rdev, target_seq))\r\nreturn timeout;\r\nfor (i = 0; i < RADEON_NUM_RINGS; ++i) {\r\nif (!target_seq[i])\r\ncontinue;\r\ntrace_radeon_fence_wait_begin(rdev->ddev, i, target_seq[i]);\r\nradeon_irq_kms_sw_irq_get(rdev, i);\r\n}\r\nif (intr) {\r\nr = wait_event_interruptible_timeout(rdev->fence_queue, (\r\nradeon_fence_any_seq_signaled(rdev, target_seq)\r\n|| rdev->needs_reset), timeout);\r\n} else {\r\nr = wait_event_timeout(rdev->fence_queue, (\r\nradeon_fence_any_seq_signaled(rdev, target_seq)\r\n|| rdev->needs_reset), timeout);\r\n}\r\nif (rdev->needs_reset)\r\nr = -EDEADLK;\r\nfor (i = 0; i < RADEON_NUM_RINGS; ++i) {\r\nif (!target_seq[i])\r\ncontinue;\r\nradeon_irq_kms_sw_irq_put(rdev, i);\r\ntrace_radeon_fence_wait_end(rdev->ddev, i, target_seq[i]);\r\n}\r\nreturn r;\r\n}\r\nint radeon_fence_wait(struct radeon_fence *fence, bool intr)\r\n{\r\nuint64_t seq[RADEON_NUM_RINGS] = {};\r\nlong r;\r\nif (WARN_ON_ONCE(!to_radeon_fence(&fence->base)))\r\nreturn fence_wait(&fence->base, intr);\r\nseq[fence->ring] = fence->seq;\r\nr = radeon_fence_wait_seq_timeout(fence->rdev, seq, intr, MAX_SCHEDULE_TIMEOUT);\r\nif (r < 0) {\r\nreturn r;\r\n}\r\nr = fence_signal(&fence->base);\r\nif (!r)\r\nFENCE_TRACE(&fence->base, "signaled from fence_wait\n");\r\nreturn 0;\r\n}\r\nint radeon_fence_wait_any(struct radeon_device *rdev,\r\nstruct radeon_fence **fences,\r\nbool intr)\r\n{\r\nuint64_t seq[RADEON_NUM_RINGS];\r\nunsigned i, num_rings = 0;\r\nlong r;\r\nfor (i = 0; i < RADEON_NUM_RINGS; ++i) {\r\nseq[i] = 0;\r\nif (!fences[i]) {\r\ncontinue;\r\n}\r\nseq[i] = fences[i]->seq;\r\n++num_rings;\r\n}\r\nif (num_rings == 0)\r\nreturn -ENOENT;\r\nr = radeon_fence_wait_seq_timeout(rdev, seq, intr, MAX_SCHEDULE_TIMEOUT);\r\nif (r < 0) {\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nint radeon_fence_wait_next(struct radeon_device *rdev, int ring)\r\n{\r\nuint64_t seq[RADEON_NUM_RINGS] = {};\r\nlong r;\r\nseq[ring] = atomic64_read(&rdev->fence_drv[ring].last_seq) + 1ULL;\r\nif (seq[ring] >= rdev->fence_drv[ring].sync_seq[ring]) {\r\nreturn -ENOENT;\r\n}\r\nr = radeon_fence_wait_seq_timeout(rdev, seq, false, MAX_SCHEDULE_TIMEOUT);\r\nif (r < 0)\r\nreturn r;\r\nreturn 0;\r\n}\r\nint radeon_fence_wait_empty(struct radeon_device *rdev, int ring)\r\n{\r\nuint64_t seq[RADEON_NUM_RINGS] = {};\r\nlong r;\r\nseq[ring] = rdev->fence_drv[ring].sync_seq[ring];\r\nif (!seq[ring])\r\nreturn 0;\r\nr = radeon_fence_wait_seq_timeout(rdev, seq, false, MAX_SCHEDULE_TIMEOUT);\r\nif (r < 0) {\r\nif (r == -EDEADLK)\r\nreturn -EDEADLK;\r\ndev_err(rdev->dev, "error waiting for ring[%d] to become idle (%ld)\n",\r\nring, r);\r\n}\r\nreturn 0;\r\n}\r\nstruct radeon_fence *radeon_fence_ref(struct radeon_fence *fence)\r\n{\r\nfence_get(&fence->base);\r\nreturn fence;\r\n}\r\nvoid radeon_fence_unref(struct radeon_fence **fence)\r\n{\r\nstruct radeon_fence *tmp = *fence;\r\n*fence = NULL;\r\nif (tmp) {\r\nfence_put(&tmp->base);\r\n}\r\n}\r\nunsigned radeon_fence_count_emitted(struct radeon_device *rdev, int ring)\r\n{\r\nuint64_t emitted;\r\nradeon_fence_process(rdev, ring);\r\nemitted = rdev->fence_drv[ring].sync_seq[ring]\r\n- atomic64_read(&rdev->fence_drv[ring].last_seq);\r\nif (emitted > 0x10000000) {\r\nemitted = 0x10000000;\r\n}\r\nreturn (unsigned)emitted;\r\n}\r\nbool radeon_fence_need_sync(struct radeon_fence *fence, int dst_ring)\r\n{\r\nstruct radeon_fence_driver *fdrv;\r\nif (!fence) {\r\nreturn false;\r\n}\r\nif (fence->ring == dst_ring) {\r\nreturn false;\r\n}\r\nfdrv = &fence->rdev->fence_drv[dst_ring];\r\nif (fence->seq <= fdrv->sync_seq[fence->ring]) {\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nvoid radeon_fence_note_sync(struct radeon_fence *fence, int dst_ring)\r\n{\r\nstruct radeon_fence_driver *dst, *src;\r\nunsigned i;\r\nif (!fence) {\r\nreturn;\r\n}\r\nif (fence->ring == dst_ring) {\r\nreturn;\r\n}\r\nsrc = &fence->rdev->fence_drv[fence->ring];\r\ndst = &fence->rdev->fence_drv[dst_ring];\r\nfor (i = 0; i < RADEON_NUM_RINGS; ++i) {\r\nif (i == dst_ring) {\r\ncontinue;\r\n}\r\ndst->sync_seq[i] = max(dst->sync_seq[i], src->sync_seq[i]);\r\n}\r\n}\r\nint radeon_fence_driver_start_ring(struct radeon_device *rdev, int ring)\r\n{\r\nuint64_t index;\r\nint r;\r\nradeon_scratch_free(rdev, rdev->fence_drv[ring].scratch_reg);\r\nif (rdev->wb.use_event || !radeon_ring_supports_scratch_reg(rdev, &rdev->ring[ring])) {\r\nrdev->fence_drv[ring].scratch_reg = 0;\r\nif (ring != R600_RING_TYPE_UVD_INDEX) {\r\nindex = R600_WB_EVENT_OFFSET + ring * 4;\r\nrdev->fence_drv[ring].cpu_addr = &rdev->wb.wb[index/4];\r\nrdev->fence_drv[ring].gpu_addr = rdev->wb.gpu_addr +\r\nindex;\r\n} else {\r\nindex = ALIGN(rdev->uvd_fw->size, 8);\r\nrdev->fence_drv[ring].cpu_addr = rdev->uvd.cpu_addr + index;\r\nrdev->fence_drv[ring].gpu_addr = rdev->uvd.gpu_addr + index;\r\n}\r\n} else {\r\nr = radeon_scratch_get(rdev, &rdev->fence_drv[ring].scratch_reg);\r\nif (r) {\r\ndev_err(rdev->dev, "fence failed to get scratch register\n");\r\nreturn r;\r\n}\r\nindex = RADEON_WB_SCRATCH_OFFSET +\r\nrdev->fence_drv[ring].scratch_reg -\r\nrdev->scratch.reg_base;\r\nrdev->fence_drv[ring].cpu_addr = &rdev->wb.wb[index/4];\r\nrdev->fence_drv[ring].gpu_addr = rdev->wb.gpu_addr + index;\r\n}\r\nradeon_fence_write(rdev, atomic64_read(&rdev->fence_drv[ring].last_seq), ring);\r\nrdev->fence_drv[ring].initialized = true;\r\ndev_info(rdev->dev, "fence driver on ring %d use gpu addr 0x%016llx and cpu addr 0x%p\n",\r\nring, rdev->fence_drv[ring].gpu_addr, rdev->fence_drv[ring].cpu_addr);\r\nreturn 0;\r\n}\r\nstatic void radeon_fence_driver_init_ring(struct radeon_device *rdev, int ring)\r\n{\r\nint i;\r\nrdev->fence_drv[ring].scratch_reg = -1;\r\nrdev->fence_drv[ring].cpu_addr = NULL;\r\nrdev->fence_drv[ring].gpu_addr = 0;\r\nfor (i = 0; i < RADEON_NUM_RINGS; ++i)\r\nrdev->fence_drv[ring].sync_seq[i] = 0;\r\natomic64_set(&rdev->fence_drv[ring].last_seq, 0);\r\nrdev->fence_drv[ring].initialized = false;\r\nINIT_DELAYED_WORK(&rdev->fence_drv[ring].lockup_work,\r\nradeon_fence_check_lockup);\r\nrdev->fence_drv[ring].rdev = rdev;\r\n}\r\nint radeon_fence_driver_init(struct radeon_device *rdev)\r\n{\r\nint ring;\r\ninit_waitqueue_head(&rdev->fence_queue);\r\nfor (ring = 0; ring < RADEON_NUM_RINGS; ring++) {\r\nradeon_fence_driver_init_ring(rdev, ring);\r\n}\r\nif (radeon_debugfs_fence_init(rdev)) {\r\ndev_err(rdev->dev, "fence debugfs file creation failed\n");\r\n}\r\nreturn 0;\r\n}\r\nvoid radeon_fence_driver_fini(struct radeon_device *rdev)\r\n{\r\nint ring, r;\r\nmutex_lock(&rdev->ring_lock);\r\nfor (ring = 0; ring < RADEON_NUM_RINGS; ring++) {\r\nif (!rdev->fence_drv[ring].initialized)\r\ncontinue;\r\nr = radeon_fence_wait_empty(rdev, ring);\r\nif (r) {\r\nradeon_fence_driver_force_completion(rdev, ring);\r\n}\r\ncancel_delayed_work_sync(&rdev->fence_drv[ring].lockup_work);\r\nwake_up_all(&rdev->fence_queue);\r\nradeon_scratch_free(rdev, rdev->fence_drv[ring].scratch_reg);\r\nrdev->fence_drv[ring].initialized = false;\r\n}\r\nmutex_unlock(&rdev->ring_lock);\r\n}\r\nvoid radeon_fence_driver_force_completion(struct radeon_device *rdev, int ring)\r\n{\r\nif (rdev->fence_drv[ring].initialized) {\r\nradeon_fence_write(rdev, rdev->fence_drv[ring].sync_seq[ring], ring);\r\ncancel_delayed_work_sync(&rdev->fence_drv[ring].lockup_work);\r\n}\r\n}\r\nstatic int radeon_debugfs_fence_info(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *)m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nint i, j;\r\nfor (i = 0; i < RADEON_NUM_RINGS; ++i) {\r\nif (!rdev->fence_drv[i].initialized)\r\ncontinue;\r\nradeon_fence_process(rdev, i);\r\nseq_printf(m, "--- ring %d ---\n", i);\r\nseq_printf(m, "Last signaled fence 0x%016llx\n",\r\n(unsigned long long)atomic64_read(&rdev->fence_drv[i].last_seq));\r\nseq_printf(m, "Last emitted 0x%016llx\n",\r\nrdev->fence_drv[i].sync_seq[i]);\r\nfor (j = 0; j < RADEON_NUM_RINGS; ++j) {\r\nif (i != j && rdev->fence_drv[j].initialized)\r\nseq_printf(m, "Last sync to ring %d 0x%016llx\n",\r\nj, rdev->fence_drv[i].sync_seq[j]);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int radeon_debugfs_gpu_reset(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *) m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\ndown_read(&rdev->exclusive_lock);\r\nseq_printf(m, "%d\n", rdev->needs_reset);\r\nrdev->needs_reset = true;\r\nwake_up_all(&rdev->fence_queue);\r\nup_read(&rdev->exclusive_lock);\r\nreturn 0;\r\n}\r\nint radeon_debugfs_fence_init(struct radeon_device *rdev)\r\n{\r\n#if defined(CONFIG_DEBUG_FS)\r\nreturn radeon_debugfs_add_files(rdev, radeon_debugfs_fence_list, 2);\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic const char *radeon_fence_get_driver_name(struct fence *fence)\r\n{\r\nreturn "radeon";\r\n}\r\nstatic const char *radeon_fence_get_timeline_name(struct fence *f)\r\n{\r\nstruct radeon_fence *fence = to_radeon_fence(f);\r\nswitch (fence->ring) {\r\ncase RADEON_RING_TYPE_GFX_INDEX: return "radeon.gfx";\r\ncase CAYMAN_RING_TYPE_CP1_INDEX: return "radeon.cp1";\r\ncase CAYMAN_RING_TYPE_CP2_INDEX: return "radeon.cp2";\r\ncase R600_RING_TYPE_DMA_INDEX: return "radeon.dma";\r\ncase CAYMAN_RING_TYPE_DMA1_INDEX: return "radeon.dma1";\r\ncase R600_RING_TYPE_UVD_INDEX: return "radeon.uvd";\r\ncase TN_RING_TYPE_VCE1_INDEX: return "radeon.vce1";\r\ncase TN_RING_TYPE_VCE2_INDEX: return "radeon.vce2";\r\ndefault: WARN_ON_ONCE(1); return "radeon.unk";\r\n}\r\n}\r\nstatic inline bool radeon_test_signaled(struct radeon_fence *fence)\r\n{\r\nreturn test_bit(FENCE_FLAG_SIGNALED_BIT, &fence->base.flags);\r\n}\r\nstatic void\r\nradeon_fence_wait_cb(struct fence *fence, struct fence_cb *cb)\r\n{\r\nstruct radeon_wait_cb *wait =\r\ncontainer_of(cb, struct radeon_wait_cb, base);\r\nwake_up_process(wait->task);\r\n}\r\nstatic signed long radeon_fence_default_wait(struct fence *f, bool intr,\r\nsigned long t)\r\n{\r\nstruct radeon_fence *fence = to_radeon_fence(f);\r\nstruct radeon_device *rdev = fence->rdev;\r\nstruct radeon_wait_cb cb;\r\ncb.task = current;\r\nif (fence_add_callback(f, &cb.base, radeon_fence_wait_cb))\r\nreturn t;\r\nwhile (t > 0) {\r\nif (intr)\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nelse\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nif (radeon_test_signaled(fence))\r\nbreak;\r\nif (rdev->needs_reset) {\r\nt = -EDEADLK;\r\nbreak;\r\n}\r\nt = schedule_timeout(t);\r\nif (t > 0 && intr && signal_pending(current))\r\nt = -ERESTARTSYS;\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nfence_remove_callback(f, &cb.base);\r\nreturn t;\r\n}
