static struct adc128_data *adc128_update_device(struct device *dev)\r\n{\r\nstruct adc128_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nstruct adc128_data *ret = data;\r\nint i, rv;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + HZ) || !data->valid) {\r\nfor (i = 0; i < 7; i++) {\r\nrv = i2c_smbus_read_word_swapped(client,\r\nADC128_REG_IN(i));\r\nif (rv < 0)\r\ngoto abort;\r\ndata->in[0][i] = rv >> 4;\r\nrv = i2c_smbus_read_byte_data(client,\r\nADC128_REG_IN_MIN(i));\r\nif (rv < 0)\r\ngoto abort;\r\ndata->in[1][i] = rv << 4;\r\nrv = i2c_smbus_read_byte_data(client,\r\nADC128_REG_IN_MAX(i));\r\nif (rv < 0)\r\ngoto abort;\r\ndata->in[2][i] = rv << 4;\r\n}\r\nrv = i2c_smbus_read_word_swapped(client, ADC128_REG_TEMP);\r\nif (rv < 0)\r\ngoto abort;\r\ndata->temp[0] = rv >> 7;\r\nrv = i2c_smbus_read_byte_data(client, ADC128_REG_TEMP_MAX);\r\nif (rv < 0)\r\ngoto abort;\r\ndata->temp[1] = rv << 1;\r\nrv = i2c_smbus_read_byte_data(client, ADC128_REG_TEMP_HYST);\r\nif (rv < 0)\r\ngoto abort;\r\ndata->temp[2] = rv << 1;\r\nrv = i2c_smbus_read_byte_data(client, ADC128_REG_ALARM);\r\nif (rv < 0)\r\ngoto abort;\r\ndata->alarms |= rv;\r\ndata->last_updated = jiffies;\r\ndata->valid = true;\r\n}\r\ngoto done;\r\nabort:\r\nret = ERR_PTR(rv);\r\ndata->valid = false;\r\ndone:\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t adc128_show_in(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct adc128_data *data = adc128_update_device(dev);\r\nint index = to_sensor_dev_attr_2(attr)->index;\r\nint nr = to_sensor_dev_attr_2(attr)->nr;\r\nint val;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nval = DIV_ROUND_CLOSEST(data->in[index][nr] * data->vref, 4095);\r\nreturn sprintf(buf, "%d\n", val);\r\n}\r\nstatic ssize_t adc128_set_in(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct adc128_data *data = dev_get_drvdata(dev);\r\nint index = to_sensor_dev_attr_2(attr)->index;\r\nint nr = to_sensor_dev_attr_2(attr)->nr;\r\nu8 reg, regval;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nregval = clamp_val(DIV_ROUND_CLOSEST(val, 10), 0, 255);\r\ndata->in[index][nr] = regval << 4;\r\nreg = index == 1 ? ADC128_REG_IN_MIN(nr) : ADC128_REG_IN_MAX(nr);\r\ni2c_smbus_write_byte_data(data->client, reg, regval);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t adc128_show_temp(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct adc128_data *data = adc128_update_device(dev);\r\nint index = to_sensor_dev_attr(attr)->index;\r\nint temp;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\ntemp = sign_extend32(data->temp[index], 8);\r\nreturn sprintf(buf, "%d\n", temp * 500);\r\n}\r\nstatic ssize_t adc128_set_temp(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct adc128_data *data = dev_get_drvdata(dev);\r\nint index = to_sensor_dev_attr(attr)->index;\r\nlong val;\r\nint err;\r\ns8 regval;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err < 0)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nregval = clamp_val(DIV_ROUND_CLOSEST(val, 1000), -128, 127);\r\ndata->temp[index] = regval << 1;\r\ni2c_smbus_write_byte_data(data->client,\r\nindex == 1 ? ADC128_REG_TEMP_MAX\r\n: ADC128_REG_TEMP_HYST,\r\nregval);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t adc128_show_alarm(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct adc128_data *data = adc128_update_device(dev);\r\nint mask = 1 << to_sensor_dev_attr(attr)->index;\r\nu8 alarms;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nalarms = data->alarms;\r\ndata->alarms &= ~mask;\r\nreturn sprintf(buf, "%u\n", !!(alarms & mask));\r\n}\r\nstatic int adc128_detect(struct i2c_client *client, struct i2c_board_info *info)\r\n{\r\nint man_id, dev_id;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA |\r\nI2C_FUNC_SMBUS_WORD_DATA))\r\nreturn -ENODEV;\r\nman_id = i2c_smbus_read_byte_data(client, ADC128_REG_MAN_ID);\r\ndev_id = i2c_smbus_read_byte_data(client, ADC128_REG_DEV_ID);\r\nif (man_id != 0x01 || dev_id != 0x09)\r\nreturn -ENODEV;\r\nif (i2c_smbus_read_byte_data(client, ADC128_REG_CONFIG) & 0xf4)\r\nreturn -ENODEV;\r\nif (i2c_smbus_read_byte_data(client, ADC128_REG_CONV_RATE) & 0xfe)\r\nreturn -ENODEV;\r\nif (i2c_smbus_read_byte_data(client, ADC128_REG_ONESHOT) & 0xfe)\r\nreturn -ENODEV;\r\nif (i2c_smbus_read_byte_data(client, ADC128_REG_SHUTDOWN) & 0xfe)\r\nreturn -ENODEV;\r\nif (i2c_smbus_read_byte_data(client, ADC128_REG_CONFIG_ADV) & 0xf8)\r\nreturn -ENODEV;\r\nif (i2c_smbus_read_byte_data(client, ADC128_REG_BUSY_STATUS) & 0xfc)\r\nreturn -ENODEV;\r\nstrlcpy(info->type, "adc128d818", I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic int adc128_init_client(struct adc128_data *data)\r\n{\r\nstruct i2c_client *client = data->client;\r\nint err;\r\nerr = i2c_smbus_write_byte_data(client, ADC128_REG_CONFIG, 0x80);\r\nif (err)\r\nreturn err;\r\nerr = i2c_smbus_write_byte_data(client, ADC128_REG_CONFIG, 0x01);\r\nif (err)\r\nreturn err;\r\nif (data->regulator) {\r\nerr = i2c_smbus_write_byte_data(client,\r\nADC128_REG_CONFIG_ADV, 0x01);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adc128_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct regulator *regulator;\r\nstruct device *hwmon_dev;\r\nstruct adc128_data *data;\r\nint err, vref;\r\ndata = devm_kzalloc(dev, sizeof(struct adc128_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nregulator = devm_regulator_get_optional(dev, "vref");\r\nif (!IS_ERR(regulator)) {\r\ndata->regulator = regulator;\r\nerr = regulator_enable(regulator);\r\nif (err < 0)\r\nreturn err;\r\nvref = regulator_get_voltage(regulator);\r\nif (vref < 0) {\r\nerr = vref;\r\ngoto error;\r\n}\r\ndata->vref = DIV_ROUND_CLOSEST(vref, 1000);\r\n} else {\r\ndata->vref = 2560;\r\n}\r\ndata->client = client;\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->update_lock);\r\nerr = adc128_init_client(data);\r\nif (err < 0)\r\ngoto error;\r\nhwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\r\ndata, adc128_groups);\r\nif (IS_ERR(hwmon_dev)) {\r\nerr = PTR_ERR(hwmon_dev);\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nif (data->regulator)\r\nregulator_disable(data->regulator);\r\nreturn err;\r\n}\r\nstatic int adc128_remove(struct i2c_client *client)\r\n{\r\nstruct adc128_data *data = i2c_get_clientdata(client);\r\nif (data->regulator)\r\nregulator_disable(data->regulator);\r\nreturn 0;\r\n}
