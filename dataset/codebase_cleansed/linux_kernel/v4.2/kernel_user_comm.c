int libcfs_kkuc_msg_put(struct file *filp, void *payload)\r\n{\r\nstruct kuc_hdr *kuch = (struct kuc_hdr *)payload;\r\nssize_t count = kuch->kuc_msglen;\r\nloff_t offset = 0;\r\nmm_segment_t fs;\r\nint rc = -ENOSYS;\r\nif (filp == NULL || IS_ERR(filp))\r\nreturn -EBADF;\r\nif (kuch->kuc_magic != KUC_MAGIC) {\r\nCERROR("KernelComm: bad magic %x\n", kuch->kuc_magic);\r\nreturn -ENOSYS;\r\n}\r\nfs = get_fs();\r\nset_fs(KERNEL_DS);\r\nwhile (count > 0) {\r\nrc = vfs_write(filp, (void __force __user *)payload,\r\ncount, &offset);\r\nif (rc < 0)\r\nbreak;\r\ncount -= rc;\r\npayload += rc;\r\nrc = 0;\r\n}\r\nset_fs(fs);\r\nif (rc < 0)\r\nCWARN("message send failed (%d)\n", rc);\r\nelse\r\nCDEBUG(D_KUC, "Sent message rc=%d, fp=%p\n", rc, filp);\r\nreturn rc;\r\n}\r\nint libcfs_kkuc_group_add(struct file *filp, int uid, int group, __u32 data)\r\n{\r\nstruct kkuc_reg *reg;\r\nif (group > KUC_GRP_MAX) {\r\nCDEBUG(D_WARNING, "Kernelcomm: bad group %d\n", group);\r\nreturn -EINVAL;\r\n}\r\nif (filp == NULL)\r\nreturn -EBADF;\r\nreg = kmalloc(sizeof(*reg), 0);\r\nif (reg == NULL)\r\nreturn -ENOMEM;\r\nreg->kr_fp = filp;\r\nreg->kr_uid = uid;\r\nreg->kr_data = data;\r\ndown_write(&kg_sem);\r\nif (kkuc_groups[group].next == NULL)\r\nINIT_LIST_HEAD(&kkuc_groups[group]);\r\nlist_add(&reg->kr_chain, &kkuc_groups[group]);\r\nup_write(&kg_sem);\r\nCDEBUG(D_KUC, "Added uid=%d fp=%p to group %d\n", uid, filp, group);\r\nreturn 0;\r\n}\r\nint libcfs_kkuc_group_rem(int uid, int group)\r\n{\r\nstruct kkuc_reg *reg, *next;\r\nif (kkuc_groups[group].next == NULL)\r\nreturn 0;\r\nif (uid == 0) {\r\nstruct kuc_hdr lh;\r\nlh.kuc_magic = KUC_MAGIC;\r\nlh.kuc_transport = KUC_TRANSPORT_GENERIC;\r\nlh.kuc_msgtype = KUC_MSG_SHUTDOWN;\r\nlh.kuc_msglen = sizeof(lh);\r\nlibcfs_kkuc_group_put(group, &lh);\r\n}\r\ndown_write(&kg_sem);\r\nlist_for_each_entry_safe(reg, next, &kkuc_groups[group], kr_chain) {\r\nif ((uid == 0) || (uid == reg->kr_uid)) {\r\nlist_del(&reg->kr_chain);\r\nCDEBUG(D_KUC, "Removed uid=%d fp=%p from group %d\n",\r\nreg->kr_uid, reg->kr_fp, group);\r\nif (reg->kr_fp != NULL)\r\nfput(reg->kr_fp);\r\nkfree(reg);\r\n}\r\n}\r\nup_write(&kg_sem);\r\nreturn 0;\r\n}\r\nint libcfs_kkuc_group_put(int group, void *payload)\r\n{\r\nstruct kkuc_reg *reg;\r\nint rc = 0;\r\nint one_success = 0;\r\ndown_read(&kg_sem);\r\nlist_for_each_entry(reg, &kkuc_groups[group], kr_chain) {\r\nif (reg->kr_fp != NULL) {\r\nrc = libcfs_kkuc_msg_put(reg->kr_fp, payload);\r\nif (rc == 0)\r\none_success = 1;\r\nelse if (rc == -EPIPE) {\r\nfput(reg->kr_fp);\r\nreg->kr_fp = NULL;\r\n}\r\n}\r\n}\r\nup_read(&kg_sem);\r\nif (one_success)\r\nrc = 0;\r\nreturn rc;\r\n}\r\nint libcfs_kkuc_group_foreach(int group, libcfs_kkuc_cb_t cb_func,\r\nvoid *cb_arg)\r\n{\r\nstruct kkuc_reg *reg;\r\nint rc = 0;\r\nif (group > KUC_GRP_MAX) {\r\nCDEBUG(D_WARNING, "Kernelcomm: bad group %d\n", group);\r\nreturn -EINVAL;\r\n}\r\nif (kkuc_groups[group].next == NULL)\r\nreturn 0;\r\ndown_write(&kg_sem);\r\nlist_for_each_entry(reg, &kkuc_groups[group], kr_chain) {\r\nif (reg->kr_fp != NULL)\r\nrc = cb_func(reg->kr_data, cb_arg);\r\n}\r\nup_write(&kg_sem);\r\nreturn rc;\r\n}
