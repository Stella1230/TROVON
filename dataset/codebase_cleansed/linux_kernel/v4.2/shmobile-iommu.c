static struct shmobile_iommu_domain *to_sh_domain(struct iommu_domain *dom)\r\n{\r\nreturn container_of(dom, struct shmobile_iommu_domain, domain);\r\n}\r\nstatic int pgtable_alloc(struct shmobile_iommu_domain_pgtable *pgtable,\r\nstruct kmem_cache *cache, size_t size)\r\n{\r\npgtable->pgtable = kmem_cache_zalloc(cache, GFP_ATOMIC);\r\nif (!pgtable->pgtable)\r\nreturn -ENOMEM;\r\npgtable->handle = dma_map_single(NULL, pgtable->pgtable, size,\r\nDMA_TO_DEVICE);\r\nreturn 0;\r\n}\r\nstatic void pgtable_free(struct shmobile_iommu_domain_pgtable *pgtable,\r\nstruct kmem_cache *cache, size_t size)\r\n{\r\ndma_unmap_single(NULL, pgtable->handle, size, DMA_TO_DEVICE);\r\nkmem_cache_free(cache, pgtable->pgtable);\r\n}\r\nstatic uint32_t pgtable_read(struct shmobile_iommu_domain_pgtable *pgtable,\r\nunsigned int index)\r\n{\r\nreturn pgtable->pgtable[index];\r\n}\r\nstatic void pgtable_write(struct shmobile_iommu_domain_pgtable *pgtable,\r\nunsigned int index, unsigned int count, uint32_t val)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < count; i++)\r\npgtable->pgtable[index + i] = val;\r\ndma_sync_single_for_device(NULL, pgtable->handle + index * sizeof(val),\r\nsizeof(val) * count, DMA_TO_DEVICE);\r\n}\r\nstatic struct iommu_domain *shmobile_iommu_domain_alloc(unsigned type)\r\n{\r\nstruct shmobile_iommu_domain *sh_domain;\r\nint i, ret;\r\nif (type != IOMMU_DOMAIN_UNMANAGED)\r\nreturn NULL;\r\nsh_domain = kzalloc(sizeof(*sh_domain), GFP_KERNEL);\r\nif (!sh_domain)\r\nreturn NULL;\r\nret = pgtable_alloc(&sh_domain->l1, l1cache, L1_SIZE);\r\nif (ret < 0) {\r\nkfree(sh_domain);\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < L1_LEN; i++)\r\nsh_domain->l2[i].pgtable = NULL;\r\nspin_lock_init(&sh_domain->map_lock);\r\nspin_lock_init(&sh_domain->attached_list_lock);\r\nINIT_LIST_HEAD(&sh_domain->attached_list);\r\nreturn &sh_domain->domain;\r\n}\r\nstatic void shmobile_iommu_domain_free(struct iommu_domain *domain)\r\n{\r\nstruct shmobile_iommu_domain *sh_domain = to_sh_domain(domain);\r\nint i;\r\nfor (i = 0; i < L1_LEN; i++) {\r\nif (sh_domain->l2[i].pgtable)\r\npgtable_free(&sh_domain->l2[i], l2cache, L2_SIZE);\r\n}\r\npgtable_free(&sh_domain->l1, l1cache, L1_SIZE);\r\nkfree(sh_domain);\r\n}\r\nstatic int shmobile_iommu_attach_device(struct iommu_domain *domain,\r\nstruct device *dev)\r\n{\r\nstruct shmobile_iommu_archdata *archdata = dev->archdata.iommu;\r\nstruct shmobile_iommu_domain *sh_domain = to_sh_domain(domain);\r\nint ret = -EBUSY;\r\nif (!archdata)\r\nreturn -ENODEV;\r\nspin_lock(&sh_domain->attached_list_lock);\r\nspin_lock(&archdata->attach_lock);\r\nif (archdata->attached != sh_domain) {\r\nif (archdata->attached)\r\ngoto err;\r\nipmmu_tlb_set(archdata->ipmmu, sh_domain->l1.handle, L1_SIZE,\r\n0);\r\nipmmu_tlb_flush(archdata->ipmmu);\r\narchdata->attached = sh_domain;\r\narchdata->num_attached_devices = 0;\r\nlist_add(&archdata->attached_list, &sh_domain->attached_list);\r\n}\r\narchdata->num_attached_devices++;\r\nret = 0;\r\nerr:\r\nspin_unlock(&archdata->attach_lock);\r\nspin_unlock(&sh_domain->attached_list_lock);\r\nreturn ret;\r\n}\r\nstatic void shmobile_iommu_detach_device(struct iommu_domain *domain,\r\nstruct device *dev)\r\n{\r\nstruct shmobile_iommu_archdata *archdata = dev->archdata.iommu;\r\nstruct shmobile_iommu_domain *sh_domain = to_sh_domain(domain);\r\nif (!archdata)\r\nreturn;\r\nspin_lock(&sh_domain->attached_list_lock);\r\nspin_lock(&archdata->attach_lock);\r\narchdata->num_attached_devices--;\r\nif (!archdata->num_attached_devices) {\r\nipmmu_tlb_set(archdata->ipmmu, 0, 0, 0);\r\nipmmu_tlb_flush(archdata->ipmmu);\r\narchdata->attached = NULL;\r\nlist_del(&archdata->attached_list);\r\n}\r\nspin_unlock(&archdata->attach_lock);\r\nspin_unlock(&sh_domain->attached_list_lock);\r\n}\r\nstatic void domain_tlb_flush(struct shmobile_iommu_domain *sh_domain)\r\n{\r\nstruct shmobile_iommu_archdata *archdata;\r\nspin_lock(&sh_domain->attached_list_lock);\r\nlist_for_each_entry(archdata, &sh_domain->attached_list, attached_list)\r\nipmmu_tlb_flush(archdata->ipmmu);\r\nspin_unlock(&sh_domain->attached_list_lock);\r\n}\r\nstatic int l2alloc(struct shmobile_iommu_domain *sh_domain,\r\nunsigned int l1index)\r\n{\r\nint ret;\r\nif (!sh_domain->l2[l1index].pgtable) {\r\nret = pgtable_alloc(&sh_domain->l2[l1index], l2cache, L2_SIZE);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\npgtable_write(&sh_domain->l1, l1index, 1,\r\nsh_domain->l2[l1index].handle | 0x1);\r\nreturn 0;\r\n}\r\nstatic void l2realfree(struct shmobile_iommu_domain_pgtable *l2)\r\n{\r\nif (l2->pgtable)\r\npgtable_free(l2, l2cache, L2_SIZE);\r\n}\r\nstatic void l2free(struct shmobile_iommu_domain *sh_domain,\r\nunsigned int l1index,\r\nstruct shmobile_iommu_domain_pgtable *l2)\r\n{\r\npgtable_write(&sh_domain->l1, l1index, 1, 0);\r\nif (sh_domain->l2[l1index].pgtable) {\r\n*l2 = sh_domain->l2[l1index];\r\nsh_domain->l2[l1index].pgtable = NULL;\r\n}\r\n}\r\nstatic int shmobile_iommu_map(struct iommu_domain *domain, unsigned long iova,\r\nphys_addr_t paddr, size_t size, int prot)\r\n{\r\nstruct shmobile_iommu_domain_pgtable l2 = { .pgtable = NULL };\r\nstruct shmobile_iommu_domain *sh_domain = to_sh_domain(domain);\r\nunsigned int l1index, l2index;\r\nint ret;\r\nl1index = iova >> 20;\r\nswitch (size) {\r\ncase SZ_4K:\r\nl2index = (iova >> 12) & 0xff;\r\nspin_lock(&sh_domain->map_lock);\r\nret = l2alloc(sh_domain, l1index);\r\nif (!ret)\r\npgtable_write(&sh_domain->l2[l1index], l2index, 1,\r\npaddr | 0xff2);\r\nspin_unlock(&sh_domain->map_lock);\r\nbreak;\r\ncase SZ_64K:\r\nl2index = (iova >> 12) & 0xf0;\r\nspin_lock(&sh_domain->map_lock);\r\nret = l2alloc(sh_domain, l1index);\r\nif (!ret)\r\npgtable_write(&sh_domain->l2[l1index], l2index, 0x10,\r\npaddr | 0xff1);\r\nspin_unlock(&sh_domain->map_lock);\r\nbreak;\r\ncase SZ_1M:\r\nspin_lock(&sh_domain->map_lock);\r\nl2free(sh_domain, l1index, &l2);\r\npgtable_write(&sh_domain->l1, l1index, 1, paddr | 0xc02);\r\nspin_unlock(&sh_domain->map_lock);\r\nret = 0;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nif (!ret)\r\ndomain_tlb_flush(sh_domain);\r\nl2realfree(&l2);\r\nreturn ret;\r\n}\r\nstatic size_t shmobile_iommu_unmap(struct iommu_domain *domain,\r\nunsigned long iova, size_t size)\r\n{\r\nstruct shmobile_iommu_domain_pgtable l2 = { .pgtable = NULL };\r\nstruct shmobile_iommu_domain *sh_domain = to_sh_domain(domain);\r\nunsigned int l1index, l2index;\r\nuint32_t l2entry = 0;\r\nsize_t ret = 0;\r\nl1index = iova >> 20;\r\nif (!(iova & 0xfffff) && size >= SZ_1M) {\r\nspin_lock(&sh_domain->map_lock);\r\nl2free(sh_domain, l1index, &l2);\r\nspin_unlock(&sh_domain->map_lock);\r\nret = SZ_1M;\r\ngoto done;\r\n}\r\nl2index = (iova >> 12) & 0xff;\r\nspin_lock(&sh_domain->map_lock);\r\nif (sh_domain->l2[l1index].pgtable)\r\nl2entry = pgtable_read(&sh_domain->l2[l1index], l2index);\r\nswitch (l2entry & 3) {\r\ncase 1:\r\nif (l2index & 0xf)\r\nbreak;\r\npgtable_write(&sh_domain->l2[l1index], l2index, 0x10, 0);\r\nret = SZ_64K;\r\nbreak;\r\ncase 2:\r\npgtable_write(&sh_domain->l2[l1index], l2index, 1, 0);\r\nret = SZ_4K;\r\nbreak;\r\n}\r\nspin_unlock(&sh_domain->map_lock);\r\ndone:\r\nif (ret)\r\ndomain_tlb_flush(sh_domain);\r\nl2realfree(&l2);\r\nreturn ret;\r\n}\r\nstatic phys_addr_t shmobile_iommu_iova_to_phys(struct iommu_domain *domain,\r\ndma_addr_t iova)\r\n{\r\nstruct shmobile_iommu_domain *sh_domain = to_sh_domain(domain);\r\nuint32_t l1entry = 0, l2entry = 0;\r\nunsigned int l1index, l2index;\r\nl1index = iova >> 20;\r\nl2index = (iova >> 12) & 0xff;\r\nspin_lock(&sh_domain->map_lock);\r\nif (sh_domain->l2[l1index].pgtable)\r\nl2entry = pgtable_read(&sh_domain->l2[l1index], l2index);\r\nelse\r\nl1entry = pgtable_read(&sh_domain->l1, l1index);\r\nspin_unlock(&sh_domain->map_lock);\r\nswitch (l2entry & 3) {\r\ncase 1:\r\nreturn (l2entry & ~0xffff) | (iova & 0xffff);\r\ncase 2:\r\nreturn (l2entry & ~0xfff) | (iova & 0xfff);\r\ndefault:\r\nif ((l1entry & 3) == 2)\r\nreturn (l1entry & ~0xfffff) | (iova & 0xfffff);\r\nreturn 0;\r\n}\r\n}\r\nstatic int find_dev_name(struct shmobile_ipmmu *ipmmu, const char *dev_name)\r\n{\r\nunsigned int i, n = ipmmu->num_dev_names;\r\nfor (i = 0; i < n; i++) {\r\nif (strcmp(ipmmu->dev_names[i], dev_name) == 0)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int shmobile_iommu_add_device(struct device *dev)\r\n{\r\nstruct shmobile_iommu_archdata *archdata = ipmmu_archdata;\r\nstruct dma_iommu_mapping *mapping;\r\nif (!find_dev_name(archdata->ipmmu, dev_name(dev)))\r\nreturn 0;\r\nmapping = archdata->iommu_mapping;\r\nif (!mapping) {\r\nmapping = arm_iommu_create_mapping(&platform_bus_type, 0,\r\nL1_LEN << 20);\r\nif (IS_ERR(mapping))\r\nreturn PTR_ERR(mapping);\r\narchdata->iommu_mapping = mapping;\r\n}\r\ndev->archdata.iommu = archdata;\r\nif (arm_iommu_attach_device(dev, mapping))\r\npr_err("arm_iommu_attach_device failed\n");\r\nreturn 0;\r\n}\r\nint ipmmu_iommu_init(struct shmobile_ipmmu *ipmmu)\r\n{\r\nstatic struct shmobile_iommu_archdata *archdata;\r\nl1cache = kmem_cache_create("shmobile-iommu-pgtable1", L1_SIZE,\r\nL1_ALIGN, SLAB_HWCACHE_ALIGN, NULL);\r\nif (!l1cache)\r\nreturn -ENOMEM;\r\nl2cache = kmem_cache_create("shmobile-iommu-pgtable2", L2_SIZE,\r\nL2_ALIGN, SLAB_HWCACHE_ALIGN, NULL);\r\nif (!l2cache) {\r\nkmem_cache_destroy(l1cache);\r\nreturn -ENOMEM;\r\n}\r\narchdata = kzalloc(sizeof(*archdata), GFP_KERNEL);\r\nif (!archdata) {\r\nkmem_cache_destroy(l1cache);\r\nkmem_cache_destroy(l2cache);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&archdata->attach_lock);\r\narchdata->ipmmu = ipmmu;\r\nipmmu_archdata = archdata;\r\nbus_set_iommu(&platform_bus_type, &shmobile_iommu_ops);\r\nreturn 0;\r\n}
