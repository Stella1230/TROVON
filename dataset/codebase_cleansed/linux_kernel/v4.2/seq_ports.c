struct snd_seq_client_port *snd_seq_port_use_ptr(struct snd_seq_client *client,\r\nint num)\r\n{\r\nstruct snd_seq_client_port *port;\r\nif (client == NULL)\r\nreturn NULL;\r\nread_lock(&client->ports_lock);\r\nlist_for_each_entry(port, &client->ports_list_head, list) {\r\nif (port->addr.port == num) {\r\nif (port->closing)\r\nbreak;\r\nsnd_use_lock_use(&port->use_lock);\r\nread_unlock(&client->ports_lock);\r\nreturn port;\r\n}\r\n}\r\nread_unlock(&client->ports_lock);\r\nreturn NULL;\r\n}\r\nstruct snd_seq_client_port *snd_seq_port_query_nearest(struct snd_seq_client *client,\r\nstruct snd_seq_port_info *pinfo)\r\n{\r\nint num;\r\nstruct snd_seq_client_port *port, *found;\r\nnum = pinfo->addr.port;\r\nfound = NULL;\r\nread_lock(&client->ports_lock);\r\nlist_for_each_entry(port, &client->ports_list_head, list) {\r\nif (port->addr.port < num)\r\ncontinue;\r\nif (port->addr.port == num) {\r\nfound = port;\r\nbreak;\r\n}\r\nif (found == NULL || port->addr.port < found->addr.port)\r\nfound = port;\r\n}\r\nif (found) {\r\nif (found->closing)\r\nfound = NULL;\r\nelse\r\nsnd_use_lock_use(&found->use_lock);\r\n}\r\nread_unlock(&client->ports_lock);\r\nreturn found;\r\n}\r\nstatic void port_subs_info_init(struct snd_seq_port_subs_info *grp)\r\n{\r\nINIT_LIST_HEAD(&grp->list_head);\r\ngrp->count = 0;\r\ngrp->exclusive = 0;\r\nrwlock_init(&grp->list_lock);\r\ninit_rwsem(&grp->list_mutex);\r\ngrp->open = NULL;\r\ngrp->close = NULL;\r\n}\r\nstruct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\r\nint port)\r\n{\r\nunsigned long flags;\r\nstruct snd_seq_client_port *new_port, *p;\r\nint num = -1;\r\nif (snd_BUG_ON(!client))\r\nreturn NULL;\r\nif (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {\r\npr_warn("ALSA: seq: too many ports for client %d\n", client->number);\r\nreturn NULL;\r\n}\r\nnew_port = kzalloc(sizeof(*new_port), GFP_KERNEL);\r\nif (!new_port)\r\nreturn NULL;\r\nnew_port->addr.client = client->number;\r\nnew_port->addr.port = -1;\r\nnew_port->owner = THIS_MODULE;\r\nsprintf(new_port->name, "port-%d", num);\r\nsnd_use_lock_init(&new_port->use_lock);\r\nport_subs_info_init(&new_port->c_src);\r\nport_subs_info_init(&new_port->c_dest);\r\nnum = port >= 0 ? port : 0;\r\nmutex_lock(&client->ports_mutex);\r\nwrite_lock_irqsave(&client->ports_lock, flags);\r\nlist_for_each_entry(p, &client->ports_list_head, list) {\r\nif (p->addr.port > num)\r\nbreak;\r\nif (port < 0)\r\nnum = p->addr.port + 1;\r\n}\r\nlist_add_tail(&new_port->list, &p->list);\r\nclient->num_ports++;\r\nnew_port->addr.port = num;\r\nwrite_unlock_irqrestore(&client->ports_lock, flags);\r\nmutex_unlock(&client->ports_mutex);\r\nsprintf(new_port->name, "port-%d", num);\r\nreturn new_port;\r\n}\r\nstatic struct snd_seq_client_port *get_client_port(struct snd_seq_addr *addr,\r\nstruct snd_seq_client **cp)\r\n{\r\nstruct snd_seq_client_port *p;\r\n*cp = snd_seq_client_use_ptr(addr->client);\r\nif (*cp) {\r\np = snd_seq_port_use_ptr(*cp, addr->port);\r\nif (! p) {\r\nsnd_seq_client_unlock(*cp);\r\n*cp = NULL;\r\n}\r\nreturn p;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void clear_subscriber_list(struct snd_seq_client *client,\r\nstruct snd_seq_client_port *port,\r\nstruct snd_seq_port_subs_info *grp,\r\nint grptype)\r\n{\r\nstruct list_head *p, *n;\r\nlist_for_each_safe(p, n, &grp->list_head) {\r\nstruct snd_seq_subscribers *subs;\r\nstruct snd_seq_client *c;\r\nstruct snd_seq_client_port *aport;\r\nif (grptype == SRC_LIST) {\r\nsubs = list_entry(p, struct snd_seq_subscribers, src_list);\r\naport = get_client_port(&subs->info.dest, &c);\r\n} else {\r\nsubs = list_entry(p, struct snd_seq_subscribers, dest_list);\r\naport = get_client_port(&subs->info.sender, &c);\r\n}\r\nlist_del(p);\r\nunsubscribe_port(client, port, grp, &subs->info, 0);\r\nif (!aport) {\r\nif (atomic_dec_and_test(&subs->ref_count))\r\nkfree(subs);\r\n} else {\r\nstruct snd_seq_port_subs_info *agrp;\r\nagrp = (grptype == SRC_LIST) ? &aport->c_dest : &aport->c_src;\r\ndown_write(&agrp->list_mutex);\r\nif (grptype == SRC_LIST)\r\nlist_del(&subs->dest_list);\r\nelse\r\nlist_del(&subs->src_list);\r\nup_write(&agrp->list_mutex);\r\nunsubscribe_port(c, aport, agrp, &subs->info, 1);\r\nkfree(subs);\r\nsnd_seq_port_unlock(aport);\r\nsnd_seq_client_unlock(c);\r\n}\r\n}\r\n}\r\nstatic int port_delete(struct snd_seq_client *client,\r\nstruct snd_seq_client_port *port)\r\n{\r\nport->closing = 1;\r\nsnd_use_lock_sync(&port->use_lock);\r\nclear_subscriber_list(client, port, &port->c_src, SRC_LIST);\r\nclear_subscriber_list(client, port, &port->c_dest, DEST_LIST);\r\nif (port->private_free)\r\nport->private_free(port->private_data);\r\nsnd_BUG_ON(port->c_src.count != 0);\r\nsnd_BUG_ON(port->c_dest.count != 0);\r\nkfree(port);\r\nreturn 0;\r\n}\r\nint snd_seq_delete_port(struct snd_seq_client *client, int port)\r\n{\r\nunsigned long flags;\r\nstruct snd_seq_client_port *found = NULL, *p;\r\nmutex_lock(&client->ports_mutex);\r\nwrite_lock_irqsave(&client->ports_lock, flags);\r\nlist_for_each_entry(p, &client->ports_list_head, list) {\r\nif (p->addr.port == port) {\r\nlist_del(&p->list);\r\nclient->num_ports--;\r\nfound = p;\r\nbreak;\r\n}\r\n}\r\nwrite_unlock_irqrestore(&client->ports_lock, flags);\r\nmutex_unlock(&client->ports_mutex);\r\nif (found)\r\nreturn port_delete(client, found);\r\nelse\r\nreturn -ENOENT;\r\n}\r\nint snd_seq_delete_all_ports(struct snd_seq_client *client)\r\n{\r\nunsigned long flags;\r\nstruct list_head deleted_list;\r\nstruct snd_seq_client_port *port, *tmp;\r\nmutex_lock(&client->ports_mutex);\r\nwrite_lock_irqsave(&client->ports_lock, flags);\r\nif (! list_empty(&client->ports_list_head)) {\r\nlist_add(&deleted_list, &client->ports_list_head);\r\nlist_del_init(&client->ports_list_head);\r\n} else {\r\nINIT_LIST_HEAD(&deleted_list);\r\n}\r\nclient->num_ports = 0;\r\nwrite_unlock_irqrestore(&client->ports_lock, flags);\r\nlist_for_each_entry_safe(port, tmp, &deleted_list, list) {\r\nlist_del(&port->list);\r\nsnd_seq_system_client_ev_port_exit(port->addr.client, port->addr.port);\r\nport_delete(client, port);\r\n}\r\nmutex_unlock(&client->ports_mutex);\r\nreturn 0;\r\n}\r\nint snd_seq_set_port_info(struct snd_seq_client_port * port,\r\nstruct snd_seq_port_info * info)\r\n{\r\nif (snd_BUG_ON(!port || !info))\r\nreturn -EINVAL;\r\nif (info->name[0])\r\nstrlcpy(port->name, info->name, sizeof(port->name));\r\nport->capability = info->capability;\r\nport->type = info->type;\r\nport->midi_channels = info->midi_channels;\r\nport->midi_voices = info->midi_voices;\r\nport->synth_voices = info->synth_voices;\r\nport->timestamping = (info->flags & SNDRV_SEQ_PORT_FLG_TIMESTAMP) ? 1 : 0;\r\nport->time_real = (info->flags & SNDRV_SEQ_PORT_FLG_TIME_REAL) ? 1 : 0;\r\nport->time_queue = info->time_queue;\r\nreturn 0;\r\n}\r\nint snd_seq_get_port_info(struct snd_seq_client_port * port,\r\nstruct snd_seq_port_info * info)\r\n{\r\nif (snd_BUG_ON(!port || !info))\r\nreturn -EINVAL;\r\nstrlcpy(info->name, port->name, sizeof(info->name));\r\ninfo->capability = port->capability;\r\ninfo->type = port->type;\r\ninfo->midi_channels = port->midi_channels;\r\ninfo->midi_voices = port->midi_voices;\r\ninfo->synth_voices = port->synth_voices;\r\ninfo->read_use = port->c_src.count;\r\ninfo->write_use = port->c_dest.count;\r\ninfo->flags = 0;\r\nif (port->timestamping) {\r\ninfo->flags |= SNDRV_SEQ_PORT_FLG_TIMESTAMP;\r\nif (port->time_real)\r\ninfo->flags |= SNDRV_SEQ_PORT_FLG_TIME_REAL;\r\ninfo->time_queue = port->time_queue;\r\n}\r\nreturn 0;\r\n}\r\nstatic int subscribe_port(struct snd_seq_client *client,\r\nstruct snd_seq_client_port *port,\r\nstruct snd_seq_port_subs_info *grp,\r\nstruct snd_seq_port_subscribe *info,\r\nint send_ack)\r\n{\r\nint err = 0;\r\nif (!try_module_get(port->owner))\r\nreturn -EFAULT;\r\ngrp->count++;\r\nif (grp->open && grp->count == 1) {\r\nerr = grp->open(port->private_data, info);\r\nif (err < 0) {\r\nmodule_put(port->owner);\r\ngrp->count--;\r\n}\r\n}\r\nif (err >= 0 && send_ack && client->type == USER_CLIENT)\r\nsnd_seq_client_notify_subscription(port->addr.client, port->addr.port,\r\ninfo, SNDRV_SEQ_EVENT_PORT_SUBSCRIBED);\r\nreturn err;\r\n}\r\nstatic int unsubscribe_port(struct snd_seq_client *client,\r\nstruct snd_seq_client_port *port,\r\nstruct snd_seq_port_subs_info *grp,\r\nstruct snd_seq_port_subscribe *info,\r\nint send_ack)\r\n{\r\nint err = 0;\r\nif (! grp->count)\r\nreturn -EINVAL;\r\ngrp->count--;\r\nif (grp->close && grp->count == 0)\r\nerr = grp->close(port->private_data, info);\r\nif (send_ack && client->type == USER_CLIENT)\r\nsnd_seq_client_notify_subscription(port->addr.client, port->addr.port,\r\ninfo, SNDRV_SEQ_EVENT_PORT_UNSUBSCRIBED);\r\nmodule_put(port->owner);\r\nreturn err;\r\n}\r\nstatic inline int addr_match(struct snd_seq_addr *r, struct snd_seq_addr *s)\r\n{\r\nreturn (r->client == s->client) && (r->port == s->port);\r\n}\r\nstatic int match_subs_info(struct snd_seq_port_subscribe *r,\r\nstruct snd_seq_port_subscribe *s)\r\n{\r\nif (addr_match(&r->sender, &s->sender) &&\r\naddr_match(&r->dest, &s->dest)) {\r\nif (r->flags && r->flags == s->flags)\r\nreturn r->queue == s->queue;\r\nelse if (! r->flags)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint snd_seq_port_connect(struct snd_seq_client *connector,\r\nstruct snd_seq_client *src_client,\r\nstruct snd_seq_client_port *src_port,\r\nstruct snd_seq_client *dest_client,\r\nstruct snd_seq_client_port *dest_port,\r\nstruct snd_seq_port_subscribe *info)\r\n{\r\nstruct snd_seq_port_subs_info *src = &src_port->c_src;\r\nstruct snd_seq_port_subs_info *dest = &dest_port->c_dest;\r\nstruct snd_seq_subscribers *subs, *s;\r\nint err, src_called = 0;\r\nunsigned long flags;\r\nint exclusive;\r\nsubs = kzalloc(sizeof(*subs), GFP_KERNEL);\r\nif (! subs)\r\nreturn -ENOMEM;\r\nsubs->info = *info;\r\natomic_set(&subs->ref_count, 2);\r\ndown_write(&src->list_mutex);\r\ndown_write_nested(&dest->list_mutex, SINGLE_DEPTH_NESTING);\r\nexclusive = info->flags & SNDRV_SEQ_PORT_SUBS_EXCLUSIVE ? 1 : 0;\r\nerr = -EBUSY;\r\nif (exclusive) {\r\nif (! list_empty(&src->list_head) || ! list_empty(&dest->list_head))\r\ngoto __error;\r\n} else {\r\nif (src->exclusive || dest->exclusive)\r\ngoto __error;\r\nlist_for_each_entry(s, &src->list_head, src_list) {\r\nif (match_subs_info(info, &s->info))\r\ngoto __error;\r\n}\r\nlist_for_each_entry(s, &dest->list_head, dest_list) {\r\nif (match_subs_info(info, &s->info))\r\ngoto __error;\r\n}\r\n}\r\nif ((err = subscribe_port(src_client, src_port, src, info,\r\nconnector->number != src_client->number)) < 0)\r\ngoto __error;\r\nsrc_called = 1;\r\nif ((err = subscribe_port(dest_client, dest_port, dest, info,\r\nconnector->number != dest_client->number)) < 0)\r\ngoto __error;\r\nwrite_lock_irqsave(&src->list_lock, flags);\r\nlist_add_tail(&subs->src_list, &src->list_head);\r\nlist_add_tail(&subs->dest_list, &dest->list_head);\r\nwrite_unlock_irqrestore(&src->list_lock, flags);\r\nsrc->exclusive = dest->exclusive = exclusive;\r\nup_write(&dest->list_mutex);\r\nup_write(&src->list_mutex);\r\nreturn 0;\r\n__error:\r\nif (src_called)\r\nunsubscribe_port(src_client, src_port, src, info,\r\nconnector->number != src_client->number);\r\nkfree(subs);\r\nup_write(&dest->list_mutex);\r\nup_write(&src->list_mutex);\r\nreturn err;\r\n}\r\nint snd_seq_port_disconnect(struct snd_seq_client *connector,\r\nstruct snd_seq_client *src_client,\r\nstruct snd_seq_client_port *src_port,\r\nstruct snd_seq_client *dest_client,\r\nstruct snd_seq_client_port *dest_port,\r\nstruct snd_seq_port_subscribe *info)\r\n{\r\nstruct snd_seq_port_subs_info *src = &src_port->c_src;\r\nstruct snd_seq_port_subs_info *dest = &dest_port->c_dest;\r\nstruct snd_seq_subscribers *subs;\r\nint err = -ENOENT;\r\nunsigned long flags;\r\ndown_write(&src->list_mutex);\r\ndown_write_nested(&dest->list_mutex, SINGLE_DEPTH_NESTING);\r\nlist_for_each_entry(subs, &src->list_head, src_list) {\r\nif (match_subs_info(info, &subs->info)) {\r\nwrite_lock_irqsave(&src->list_lock, flags);\r\nlist_del(&subs->src_list);\r\nlist_del(&subs->dest_list);\r\nwrite_unlock_irqrestore(&src->list_lock, flags);\r\nsrc->exclusive = dest->exclusive = 0;\r\nunsubscribe_port(src_client, src_port, src, info,\r\nconnector->number != src_client->number);\r\nunsubscribe_port(dest_client, dest_port, dest, info,\r\nconnector->number != dest_client->number);\r\nkfree(subs);\r\nerr = 0;\r\nbreak;\r\n}\r\n}\r\nup_write(&dest->list_mutex);\r\nup_write(&src->list_mutex);\r\nreturn err;\r\n}\r\nstruct snd_seq_subscribers *snd_seq_port_get_subscription(struct snd_seq_port_subs_info *src_grp,\r\nstruct snd_seq_addr *dest_addr)\r\n{\r\nstruct snd_seq_subscribers *s, *found = NULL;\r\ndown_read(&src_grp->list_mutex);\r\nlist_for_each_entry(s, &src_grp->list_head, src_list) {\r\nif (addr_match(dest_addr, &s->info.dest)) {\r\nfound = s;\r\nbreak;\r\n}\r\n}\r\nup_read(&src_grp->list_mutex);\r\nreturn found;\r\n}\r\nint snd_seq_event_port_attach(int client,\r\nstruct snd_seq_port_callback *pcbp,\r\nint cap, int type, int midi_channels,\r\nint midi_voices, char *portname)\r\n{\r\nstruct snd_seq_port_info portinfo;\r\nint ret;\r\nmemset(&portinfo, 0, sizeof(portinfo));\r\nportinfo.addr.client = client;\r\nstrlcpy(portinfo.name, portname ? portname : "Unamed port",\r\nsizeof(portinfo.name));\r\nportinfo.capability = cap;\r\nportinfo.type = type;\r\nportinfo.kernel = pcbp;\r\nportinfo.midi_channels = midi_channels;\r\nportinfo.midi_voices = midi_voices;\r\nret = snd_seq_kernel_client_ctl(client,\r\nSNDRV_SEQ_IOCTL_CREATE_PORT,\r\n&portinfo);\r\nif (ret >= 0)\r\nret = portinfo.addr.port;\r\nreturn ret;\r\n}\r\nint snd_seq_event_port_detach(int client, int port)\r\n{\r\nstruct snd_seq_port_info portinfo;\r\nint err;\r\nmemset(&portinfo, 0, sizeof(portinfo));\r\nportinfo.addr.client = client;\r\nportinfo.addr.port = port;\r\nerr = snd_seq_kernel_client_ctl(client,\r\nSNDRV_SEQ_IOCTL_DELETE_PORT,\r\n&portinfo);\r\nreturn err;\r\n}
