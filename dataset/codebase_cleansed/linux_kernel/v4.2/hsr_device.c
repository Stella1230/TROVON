static bool is_admin_up(struct net_device *dev)\r\n{\r\nreturn dev && (dev->flags & IFF_UP);\r\n}\r\nstatic bool is_slave_up(struct net_device *dev)\r\n{\r\nreturn dev && is_admin_up(dev) && netif_oper_up(dev);\r\n}\r\nstatic void __hsr_set_operstate(struct net_device *dev, int transition)\r\n{\r\nwrite_lock_bh(&dev_base_lock);\r\nif (dev->operstate != transition) {\r\ndev->operstate = transition;\r\nwrite_unlock_bh(&dev_base_lock);\r\nnetdev_state_change(dev);\r\n} else {\r\nwrite_unlock_bh(&dev_base_lock);\r\n}\r\n}\r\nstatic void hsr_set_operstate(struct hsr_port *master, bool has_carrier)\r\n{\r\nif (!is_admin_up(master->dev)) {\r\n__hsr_set_operstate(master->dev, IF_OPER_DOWN);\r\nreturn;\r\n}\r\nif (has_carrier)\r\n__hsr_set_operstate(master->dev, IF_OPER_UP);\r\nelse\r\n__hsr_set_operstate(master->dev, IF_OPER_LOWERLAYERDOWN);\r\n}\r\nstatic bool hsr_check_carrier(struct hsr_port *master)\r\n{\r\nstruct hsr_port *port;\r\nbool has_carrier;\r\nhas_carrier = false;\r\nrcu_read_lock();\r\nhsr_for_each_port(master->hsr, port)\r\nif ((port->type != HSR_PT_MASTER) && is_slave_up(port->dev)) {\r\nhas_carrier = true;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nif (has_carrier)\r\nnetif_carrier_on(master->dev);\r\nelse\r\nnetif_carrier_off(master->dev);\r\nreturn has_carrier;\r\n}\r\nstatic void hsr_check_announce(struct net_device *hsr_dev,\r\nunsigned char old_operstate)\r\n{\r\nstruct hsr_priv *hsr;\r\nhsr = netdev_priv(hsr_dev);\r\nif ((hsr_dev->operstate == IF_OPER_UP) && (old_operstate != IF_OPER_UP)) {\r\nhsr->announce_count = 0;\r\nhsr->announce_timer.expires = jiffies +\r\nmsecs_to_jiffies(HSR_ANNOUNCE_INTERVAL);\r\nadd_timer(&hsr->announce_timer);\r\n}\r\nif ((hsr_dev->operstate != IF_OPER_UP) && (old_operstate == IF_OPER_UP))\r\ndel_timer(&hsr->announce_timer);\r\n}\r\nvoid hsr_check_carrier_and_operstate(struct hsr_priv *hsr)\r\n{\r\nstruct hsr_port *master;\r\nunsigned char old_operstate;\r\nbool has_carrier;\r\nmaster = hsr_port_get_hsr(hsr, HSR_PT_MASTER);\r\nold_operstate = master->dev->operstate;\r\nhas_carrier = hsr_check_carrier(master);\r\nhsr_set_operstate(master, has_carrier);\r\nhsr_check_announce(master->dev, old_operstate);\r\n}\r\nint hsr_get_max_mtu(struct hsr_priv *hsr)\r\n{\r\nunsigned int mtu_max;\r\nstruct hsr_port *port;\r\nmtu_max = ETH_DATA_LEN;\r\nrcu_read_lock();\r\nhsr_for_each_port(hsr, port)\r\nif (port->type != HSR_PT_MASTER)\r\nmtu_max = min(port->dev->mtu, mtu_max);\r\nrcu_read_unlock();\r\nif (mtu_max < HSR_HLEN)\r\nreturn 0;\r\nreturn mtu_max - HSR_HLEN;\r\n}\r\nstatic int hsr_dev_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nstruct hsr_priv *hsr;\r\nstruct hsr_port *master;\r\nhsr = netdev_priv(dev);\r\nmaster = hsr_port_get_hsr(hsr, HSR_PT_MASTER);\r\nif (new_mtu > hsr_get_max_mtu(hsr)) {\r\nnetdev_info(master->dev, "A HSR master's MTU cannot be greater than the smallest MTU of its slaves minus the HSR Tag length (%d octets).\n",\r\nHSR_HLEN);\r\nreturn -EINVAL;\r\n}\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic int hsr_dev_open(struct net_device *dev)\r\n{\r\nstruct hsr_priv *hsr;\r\nstruct hsr_port *port;\r\nchar designation;\r\nhsr = netdev_priv(dev);\r\ndesignation = '\0';\r\nrcu_read_lock();\r\nhsr_for_each_port(hsr, port) {\r\nif (port->type == HSR_PT_MASTER)\r\ncontinue;\r\nswitch (port->type) {\r\ncase HSR_PT_SLAVE_A:\r\ndesignation = 'A';\r\nbreak;\r\ncase HSR_PT_SLAVE_B:\r\ndesignation = 'B';\r\nbreak;\r\ndefault:\r\ndesignation = '?';\r\n}\r\nif (!is_slave_up(port->dev))\r\nnetdev_warn(dev, "Slave %c (%s) is not up; please bring it up to get a fully working HSR network\n",\r\ndesignation, port->dev->name);\r\n}\r\nrcu_read_unlock();\r\nif (designation == '\0')\r\nnetdev_warn(dev, "No slave devices configured\n");\r\nreturn 0;\r\n}\r\nstatic int hsr_dev_close(struct net_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic netdev_features_t hsr_features_recompute(struct hsr_priv *hsr,\r\nnetdev_features_t features)\r\n{\r\nnetdev_features_t mask;\r\nstruct hsr_port *port;\r\nmask = features;\r\nfeatures &= ~NETIF_F_ONE_FOR_ALL;\r\nhsr_for_each_port(hsr, port)\r\nfeatures = netdev_increment_features(features,\r\nport->dev->features,\r\nmask);\r\nreturn features;\r\n}\r\nstatic netdev_features_t hsr_fix_features(struct net_device *dev,\r\nnetdev_features_t features)\r\n{\r\nstruct hsr_priv *hsr = netdev_priv(dev);\r\nreturn hsr_features_recompute(hsr, features);\r\n}\r\nstatic int hsr_dev_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct hsr_priv *hsr = netdev_priv(dev);\r\nstruct hsr_port *master;\r\nmaster = hsr_port_get_hsr(hsr, HSR_PT_MASTER);\r\nskb->dev = master->dev;\r\nhsr_forward_skb(skb, master);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int hsr_pad(int size)\r\n{\r\nconst int min_size = ETH_ZLEN - HSR_HLEN - ETH_HLEN;\r\nif (size >= min_size)\r\nreturn size;\r\nreturn min_size;\r\n}\r\nstatic void send_hsr_supervision_frame(struct hsr_port *master, u8 type)\r\n{\r\nstruct sk_buff *skb;\r\nint hlen, tlen;\r\nstruct hsr_sup_tag *hsr_stag;\r\nstruct hsr_sup_payload *hsr_sp;\r\nunsigned long irqflags;\r\nhlen = LL_RESERVED_SPACE(master->dev);\r\ntlen = master->dev->needed_tailroom;\r\nskb = alloc_skb(hsr_pad(sizeof(struct hsr_sup_payload)) + hlen + tlen,\r\nGFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn;\r\nskb_reserve(skb, hlen);\r\nskb->dev = master->dev;\r\nskb->protocol = htons(ETH_P_PRP);\r\nskb->priority = TC_PRIO_CONTROL;\r\nif (dev_hard_header(skb, skb->dev, ETH_P_PRP,\r\nmaster->hsr->sup_multicast_addr,\r\nskb->dev->dev_addr, skb->len) <= 0)\r\ngoto out;\r\nskb_reset_mac_header(skb);\r\nhsr_stag = (typeof(hsr_stag)) skb_put(skb, sizeof(*hsr_stag));\r\nset_hsr_stag_path(hsr_stag, 0xf);\r\nset_hsr_stag_HSR_Ver(hsr_stag, 0);\r\nspin_lock_irqsave(&master->hsr->seqnr_lock, irqflags);\r\nhsr_stag->sequence_nr = htons(master->hsr->sequence_nr);\r\nmaster->hsr->sequence_nr++;\r\nspin_unlock_irqrestore(&master->hsr->seqnr_lock, irqflags);\r\nhsr_stag->HSR_TLV_Type = type;\r\nhsr_stag->HSR_TLV_Length = 12;\r\nhsr_sp = (typeof(hsr_sp)) skb_put(skb, sizeof(*hsr_sp));\r\nether_addr_copy(hsr_sp->MacAddressA, master->dev->dev_addr);\r\nhsr_forward_skb(skb, master);\r\nreturn;\r\nout:\r\nWARN_ON_ONCE("HSR: Could not send supervision frame\n");\r\nkfree_skb(skb);\r\n}\r\nstatic void hsr_announce(unsigned long data)\r\n{\r\nstruct hsr_priv *hsr;\r\nstruct hsr_port *master;\r\nhsr = (struct hsr_priv *) data;\r\nrcu_read_lock();\r\nmaster = hsr_port_get_hsr(hsr, HSR_PT_MASTER);\r\nif (hsr->announce_count < 3) {\r\nsend_hsr_supervision_frame(master, HSR_TLV_ANNOUNCE);\r\nhsr->announce_count++;\r\n} else {\r\nsend_hsr_supervision_frame(master, HSR_TLV_LIFE_CHECK);\r\n}\r\nif (hsr->announce_count < 3)\r\nhsr->announce_timer.expires = jiffies +\r\nmsecs_to_jiffies(HSR_ANNOUNCE_INTERVAL);\r\nelse\r\nhsr->announce_timer.expires = jiffies +\r\nmsecs_to_jiffies(HSR_LIFE_CHECK_INTERVAL);\r\nif (is_admin_up(master->dev))\r\nadd_timer(&hsr->announce_timer);\r\nrcu_read_unlock();\r\n}\r\nstatic void hsr_dev_destroy(struct net_device *hsr_dev)\r\n{\r\nstruct hsr_priv *hsr;\r\nstruct hsr_port *port;\r\nhsr = netdev_priv(hsr_dev);\r\nrtnl_lock();\r\nhsr_for_each_port(hsr, port)\r\nhsr_del_port(port);\r\nrtnl_unlock();\r\ndel_timer_sync(&hsr->prune_timer);\r\ndel_timer_sync(&hsr->announce_timer);\r\nsynchronize_rcu();\r\nfree_netdev(hsr_dev);\r\n}\r\nvoid hsr_dev_setup(struct net_device *dev)\r\n{\r\nrandom_ether_addr(dev->dev_addr);\r\nether_setup(dev);\r\ndev->header_ops = &hsr_header_ops;\r\ndev->netdev_ops = &hsr_device_ops;\r\nSET_NETDEV_DEVTYPE(dev, &hsr_type);\r\ndev->tx_queue_len = 0;\r\ndev->destructor = hsr_dev_destroy;\r\ndev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST | NETIF_F_HIGHDMA |\r\nNETIF_F_GSO_MASK | NETIF_F_HW_CSUM |\r\nNETIF_F_HW_VLAN_CTAG_TX;\r\ndev->features = dev->hw_features;\r\ndev->features |= NETIF_F_LLTX;\r\ndev->features |= NETIF_F_VLAN_CHALLENGED;\r\ndev->features |= NETIF_F_NETNS_LOCAL;\r\n}\r\ninline bool is_hsr_master(struct net_device *dev)\r\n{\r\nreturn (dev->netdev_ops->ndo_start_xmit == hsr_dev_xmit);\r\n}\r\nint hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],\r\nunsigned char multicast_spec)\r\n{\r\nstruct hsr_priv *hsr;\r\nstruct hsr_port *port;\r\nint res;\r\nhsr = netdev_priv(hsr_dev);\r\nINIT_LIST_HEAD(&hsr->ports);\r\nINIT_LIST_HEAD(&hsr->node_db);\r\nINIT_LIST_HEAD(&hsr->self_node_db);\r\nether_addr_copy(hsr_dev->dev_addr, slave[0]->dev_addr);\r\nres = hsr_create_self_node(&hsr->self_node_db, hsr_dev->dev_addr,\r\nslave[1]->dev_addr);\r\nif (res < 0)\r\nreturn res;\r\nspin_lock_init(&hsr->seqnr_lock);\r\nhsr->sequence_nr = HSR_SEQNR_START;\r\ninit_timer(&hsr->announce_timer);\r\nhsr->announce_timer.function = hsr_announce;\r\nhsr->announce_timer.data = (unsigned long) hsr;\r\ninit_timer(&hsr->prune_timer);\r\nhsr->prune_timer.function = hsr_prune_nodes;\r\nhsr->prune_timer.data = (unsigned long) hsr;\r\nether_addr_copy(hsr->sup_multicast_addr, def_multicast_addr);\r\nhsr->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;\r\nnetif_carrier_off(hsr_dev);\r\nres = hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER);\r\nif (res)\r\nreturn res;\r\nres = register_netdevice(hsr_dev);\r\nif (res)\r\ngoto fail;\r\nres = hsr_add_port(hsr, slave[0], HSR_PT_SLAVE_A);\r\nif (res)\r\ngoto fail;\r\nres = hsr_add_port(hsr, slave[1], HSR_PT_SLAVE_B);\r\nif (res)\r\ngoto fail;\r\nhsr->prune_timer.expires = jiffies + msecs_to_jiffies(PRUNE_PERIOD);\r\nadd_timer(&hsr->prune_timer);\r\nreturn 0;\r\nfail:\r\nhsr_for_each_port(hsr, port)\r\nhsr_del_port(port);\r\nreturn res;\r\n}
