acpi_status acpi_ev_initialize_op_regions(void)\r\n{\r\nacpi_status status;\r\nu32 i;\r\nACPI_FUNCTION_TRACE(ev_initialize_op_regions);\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nfor (i = 0; i < ACPI_NUM_DEFAULT_SPACES; i++) {\r\nif (acpi_ev_has_default_handler(acpi_gbl_root_node,\r\nacpi_gbl_default_address_spaces\r\n[i])) {\r\nstatus =\r\nacpi_ev_execute_reg_methods(acpi_gbl_root_node,\r\nacpi_gbl_default_address_spaces\r\n[i]);\r\n}\r\n}\r\nacpi_gbl_reg_methods_executed = TRUE;\r\n(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_ev_address_space_dispatch(union acpi_operand_object *region_obj,\r\nunion acpi_operand_object *field_obj,\r\nu32 function,\r\nu32 region_offset, u32 bit_width, u64 *value)\r\n{\r\nacpi_status status;\r\nacpi_adr_space_handler handler;\r\nacpi_adr_space_setup region_setup;\r\nunion acpi_operand_object *handler_desc;\r\nunion acpi_operand_object *region_obj2;\r\nvoid *region_context = NULL;\r\nstruct acpi_connection_info *context;\r\nacpi_physical_address address;\r\nACPI_FUNCTION_TRACE(ev_address_space_dispatch);\r\nregion_obj2 = acpi_ns_get_secondary_object(region_obj);\r\nif (!region_obj2) {\r\nreturn_ACPI_STATUS(AE_NOT_EXIST);\r\n}\r\nhandler_desc = region_obj->region.handler;\r\nif (!handler_desc) {\r\nACPI_ERROR((AE_INFO,\r\n"No handler for Region [%4.4s] (%p) [%s]",\r\nacpi_ut_get_node_name(region_obj->region.node),\r\nregion_obj,\r\nacpi_ut_get_region_name(region_obj->region.\r\nspace_id)));\r\nreturn_ACPI_STATUS(AE_NOT_EXIST);\r\n}\r\ncontext = handler_desc->address_space.context;\r\nif (!(region_obj->region.flags & AOPOBJ_SETUP_COMPLETE)) {\r\nregion_setup = handler_desc->address_space.setup;\r\nif (!region_setup) {\r\nACPI_ERROR((AE_INFO,\r\n"No init routine for region(%p) [%s]",\r\nregion_obj,\r\nacpi_ut_get_region_name(region_obj->region.\r\nspace_id)));\r\nreturn_ACPI_STATUS(AE_NOT_EXIST);\r\n}\r\nacpi_ex_exit_interpreter();\r\nstatus = region_setup(region_obj, ACPI_REGION_ACTIVATE,\r\ncontext, &region_context);\r\nacpi_ex_enter_interpreter();\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"During region initialization: [%s]",\r\nacpi_ut_get_region_name(region_obj->\r\nregion.\r\nspace_id)));\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (!(region_obj->region.flags & AOPOBJ_SETUP_COMPLETE)) {\r\nregion_obj->region.flags |= AOPOBJ_SETUP_COMPLETE;\r\nif (!(region_obj2->extra.region_context)) {\r\nregion_obj2->extra.region_context =\r\nregion_context;\r\n}\r\n}\r\n}\r\nhandler = handler_desc->address_space.handler;\r\naddress = (region_obj->region.address + region_offset);\r\nif ((region_obj->region.space_id == ACPI_ADR_SPACE_GSBUS) &&\r\ncontext && field_obj) {\r\ncontext->connection = field_obj->field.resource_buffer;\r\ncontext->length = field_obj->field.resource_length;\r\ncontext->access_length = field_obj->field.access_length;\r\n}\r\nif ((region_obj->region.space_id == ACPI_ADR_SPACE_GPIO) &&\r\ncontext && field_obj) {\r\ncontext->connection = field_obj->field.resource_buffer;\r\ncontext->length = field_obj->field.resource_length;\r\ncontext->access_length = field_obj->field.access_length;\r\naddress = field_obj->field.pin_number_index;\r\nbit_width = field_obj->field.bit_length;\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_OPREGION,\r\n"Handler %p (@%p) Address %8.8X%8.8X [%s]\n",\r\n&region_obj->region.handler->address_space, handler,\r\nACPI_FORMAT_UINT64(address),\r\nacpi_ut_get_region_name(region_obj->region.\r\nspace_id)));\r\nif (!(handler_desc->address_space.handler_flags &\r\nACPI_ADDR_HANDLER_DEFAULT_INSTALLED)) {\r\nacpi_ex_exit_interpreter();\r\n}\r\nstatus = handler(function, address, bit_width, value, context,\r\nregion_obj2->extra.region_context);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "Returned by Handler for [%s]",\r\nacpi_ut_get_region_name(region_obj->region.\r\nspace_id)));\r\n}\r\nif (!(handler_desc->address_space.handler_flags &\r\nACPI_ADDR_HANDLER_DEFAULT_INSTALLED)) {\r\nacpi_ex_enter_interpreter();\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nvoid\r\nacpi_ev_detach_region(union acpi_operand_object *region_obj,\r\nu8 acpi_ns_is_locked)\r\n{\r\nunion acpi_operand_object *handler_obj;\r\nunion acpi_operand_object *obj_desc;\r\nunion acpi_operand_object *start_desc;\r\nunion acpi_operand_object **last_obj_ptr;\r\nacpi_adr_space_setup region_setup;\r\nvoid **region_context;\r\nunion acpi_operand_object *region_obj2;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(ev_detach_region);\r\nregion_obj2 = acpi_ns_get_secondary_object(region_obj);\r\nif (!region_obj2) {\r\nreturn_VOID;\r\n}\r\nregion_context = &region_obj2->extra.region_context;\r\nhandler_obj = region_obj->region.handler;\r\nif (!handler_obj) {\r\nreturn_VOID;\r\n}\r\nobj_desc = handler_obj->address_space.region_list;\r\nstart_desc = obj_desc;\r\nlast_obj_ptr = &handler_obj->address_space.region_list;\r\nwhile (obj_desc) {\r\nif (obj_desc == region_obj) {\r\nACPI_DEBUG_PRINT((ACPI_DB_OPREGION,\r\n"Removing Region %p from address handler %p\n",\r\nregion_obj, handler_obj));\r\n*last_obj_ptr = obj_desc->region.next;\r\nobj_desc->region.next = NULL;\r\nif (acpi_ns_is_locked) {\r\nstatus =\r\nacpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_VOID;\r\n}\r\n}\r\nstatus =\r\nacpi_ev_execute_reg_method(region_obj,\r\nACPI_REG_DISCONNECT);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"from region _REG, [%s]",\r\nacpi_ut_get_region_name\r\n(region_obj->region.space_id)));\r\n}\r\nif (acpi_ns_is_locked) {\r\nstatus =\r\nacpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_VOID;\r\n}\r\n}\r\nif (region_obj->region.flags & AOPOBJ_SETUP_COMPLETE) {\r\nregion_setup = handler_obj->address_space.setup;\r\nstatus =\r\nregion_setup(region_obj,\r\nACPI_REGION_DEACTIVATE,\r\nhandler_obj->address_space.\r\ncontext, region_context);\r\nif (region_context) {\r\n*region_context = NULL;\r\n}\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"from region handler - deactivate, [%s]",\r\nacpi_ut_get_region_name\r\n(region_obj->region.\r\nspace_id)));\r\n}\r\nregion_obj->region.flags &=\r\n~(AOPOBJ_SETUP_COMPLETE);\r\n}\r\nregion_obj->region.handler = NULL;\r\nacpi_ut_remove_reference(handler_obj);\r\nreturn_VOID;\r\n}\r\nlast_obj_ptr = &obj_desc->region.next;\r\nobj_desc = obj_desc->region.next;\r\nif (obj_desc == start_desc) {\r\nACPI_ERROR((AE_INFO,\r\n"Circular handler list in region object %p",\r\nregion_obj));\r\nreturn_VOID;\r\n}\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_OPREGION,\r\n"Cannot remove region %p from address handler %p\n",\r\nregion_obj, handler_obj));\r\nreturn_VOID;\r\n}\r\nacpi_status\r\nacpi_ev_attach_region(union acpi_operand_object *handler_obj,\r\nunion acpi_operand_object *region_obj,\r\nu8 acpi_ns_is_locked)\r\n{\r\nACPI_FUNCTION_TRACE(ev_attach_region);\r\nACPI_DEBUG_PRINT((ACPI_DB_OPREGION,\r\n"Adding Region [%4.4s] %p to address handler %p [%s]\n",\r\nacpi_ut_get_node_name(region_obj->region.node),\r\nregion_obj, handler_obj,\r\nacpi_ut_get_region_name(region_obj->region.\r\nspace_id)));\r\nregion_obj->region.next = handler_obj->address_space.region_list;\r\nhandler_obj->address_space.region_list = region_obj;\r\nif (region_obj->region.handler) {\r\nreturn_ACPI_STATUS(AE_ALREADY_EXISTS);\r\n}\r\nregion_obj->region.handler = handler_obj;\r\nacpi_ut_add_reference(handler_obj);\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status\r\nacpi_ev_execute_reg_method(union acpi_operand_object *region_obj, u32 function)\r\n{\r\nstruct acpi_evaluate_info *info;\r\nunion acpi_operand_object *args[3];\r\nunion acpi_operand_object *region_obj2;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(ev_execute_reg_method);\r\nregion_obj2 = acpi_ns_get_secondary_object(region_obj);\r\nif (!region_obj2) {\r\nreturn_ACPI_STATUS(AE_NOT_EXIST);\r\n}\r\nif (region_obj2->extra.method_REG == NULL) {\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\ninfo = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_evaluate_info));\r\nif (!info) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\ninfo->prefix_node = region_obj2->extra.method_REG;\r\ninfo->relative_pathname = NULL;\r\ninfo->parameters = args;\r\ninfo->flags = ACPI_IGNORE_RETURN_VALUE;\r\nargs[0] =\r\nacpi_ut_create_integer_object((u64)region_obj->region.space_id);\r\nif (!args[0]) {\r\nstatus = AE_NO_MEMORY;\r\ngoto cleanup1;\r\n}\r\nargs[1] = acpi_ut_create_integer_object((u64)function);\r\nif (!args[1]) {\r\nstatus = AE_NO_MEMORY;\r\ngoto cleanup2;\r\n}\r\nargs[2] = NULL;\r\nACPI_DEBUG_EXEC(acpi_ut_display_init_pathname\r\n(ACPI_TYPE_METHOD, info->prefix_node, NULL));\r\nstatus = acpi_ns_evaluate(info);\r\nacpi_ut_remove_reference(args[1]);\r\ncleanup2:\r\nacpi_ut_remove_reference(args[0]);\r\ncleanup1:\r\nACPI_FREE(info);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_ev_execute_reg_methods(struct acpi_namespace_node *node,\r\nacpi_adr_space_type space_id)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(ev_execute_reg_methods);\r\nstatus = acpi_ns_walk_namespace(ACPI_TYPE_ANY, node, ACPI_UINT32_MAX,\r\nACPI_NS_WALK_UNLOCK, acpi_ev_reg_run,\r\nNULL, &space_id, NULL);\r\nif (space_id == ACPI_ADR_SPACE_EC) {\r\nacpi_ev_orphan_ec_reg_method(node);\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatic acpi_status\r\nacpi_ev_reg_run(acpi_handle obj_handle,\r\nu32 level, void *context, void **return_value)\r\n{\r\nunion acpi_operand_object *obj_desc;\r\nstruct acpi_namespace_node *node;\r\nacpi_adr_space_type space_id;\r\nacpi_status status;\r\nspace_id = *ACPI_CAST_PTR(acpi_adr_space_type, context);\r\nnode = acpi_ns_validate_handle(obj_handle);\r\nif (!node) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nif ((node->type != ACPI_TYPE_REGION) && (node != acpi_gbl_root_node)) {\r\nreturn (AE_OK);\r\n}\r\nobj_desc = acpi_ns_get_attached_object(node);\r\nif (!obj_desc) {\r\nreturn (AE_OK);\r\n}\r\nif (obj_desc->region.space_id != space_id) {\r\nreturn (AE_OK);\r\n}\r\nstatus = acpi_ev_execute_reg_method(obj_desc, ACPI_REG_CONNECT);\r\nreturn (status);\r\n}\r\nstatic void\r\nacpi_ev_orphan_ec_reg_method(struct acpi_namespace_node *ec_device_node)\r\n{\r\nacpi_handle reg_method;\r\nstruct acpi_namespace_node *next_node;\r\nacpi_status status;\r\nstruct acpi_object_list args;\r\nunion acpi_object objects[2];\r\nACPI_FUNCTION_TRACE(ev_orphan_ec_reg_method);\r\nif (!ec_device_node) {\r\nreturn_VOID;\r\n}\r\n(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nstatus = acpi_get_handle(ec_device_node, METHOD_NAME__REG, &reg_method);\r\nif (ACPI_FAILURE(status)) {\r\ngoto exit;\r\n}\r\nnext_node = acpi_ns_get_next_node(ec_device_node, NULL);\r\nwhile (next_node) {\r\nif ((next_node->type == ACPI_TYPE_REGION) &&\r\n(next_node->object) &&\r\n(next_node->object->region.space_id == ACPI_ADR_SPACE_EC)) {\r\ngoto exit;\r\n}\r\nnext_node = acpi_ns_get_next_node(ec_device_node, next_node);\r\n}\r\nargs.count = 2;\r\nargs.pointer = objects;\r\nobjects[0].type = ACPI_TYPE_INTEGER;\r\nobjects[0].integer.value = ACPI_ADR_SPACE_EC;\r\nobjects[1].type = ACPI_TYPE_INTEGER;\r\nobjects[1].integer.value = ACPI_REG_CONNECT;\r\nstatus = acpi_evaluate_object(reg_method, NULL, &args, NULL);\r\nexit:\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\r\nreturn_VOID;\r\n}
