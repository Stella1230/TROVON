static int __ocfs2_move_extent(handle_t *handle,\r\nstruct ocfs2_move_extents_context *context,\r\nu32 cpos, u32 len, u32 p_cpos, u32 new_p_cpos,\r\nint ext_flags)\r\n{\r\nint ret = 0, index;\r\nstruct inode *inode = context->inode;\r\nstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\r\nstruct ocfs2_extent_rec *rec, replace_rec;\r\nstruct ocfs2_path *path = NULL;\r\nstruct ocfs2_extent_list *el;\r\nu64 ino = ocfs2_metadata_cache_owner(context->et.et_ci);\r\nu64 old_blkno = ocfs2_clusters_to_blocks(inode->i_sb, p_cpos);\r\nret = ocfs2_duplicate_clusters_by_page(handle, inode, cpos,\r\np_cpos, new_p_cpos, len);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nmemset(&replace_rec, 0, sizeof(replace_rec));\r\nreplace_rec.e_cpos = cpu_to_le32(cpos);\r\nreplace_rec.e_leaf_clusters = cpu_to_le16(len);\r\nreplace_rec.e_blkno = cpu_to_le64(ocfs2_clusters_to_blocks(inode->i_sb,\r\nnew_p_cpos));\r\npath = ocfs2_new_path_from_et(&context->et);\r\nif (!path) {\r\nret = -ENOMEM;\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = ocfs2_find_path(INODE_CACHE(inode), path, cpos);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nel = path_leaf_el(path);\r\nindex = ocfs2_search_extent_list(el, cpos);\r\nif (index == -1) {\r\nocfs2_error(inode->i_sb,\r\n"Inode %llu has an extent at cpos %u which can no "\r\n"longer be found.\n",\r\n(unsigned long long)ino, cpos);\r\nret = -EROFS;\r\ngoto out;\r\n}\r\nrec = &el->l_recs[index];\r\nBUG_ON(ext_flags != rec->e_flags);\r\nreplace_rec.e_flags = ext_flags & ~OCFS2_EXT_REFCOUNTED;\r\nret = ocfs2_journal_access_di(handle, INODE_CACHE(inode),\r\ncontext->et.et_root_bh,\r\nOCFS2_JOURNAL_ACCESS_WRITE);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = ocfs2_split_extent(handle, &context->et, path, index,\r\n&replace_rec, context->meta_ac,\r\n&context->dealloc);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nocfs2_journal_dirty(handle, context->et.et_root_bh);\r\ncontext->new_phys_cpos = new_p_cpos;\r\nif (old_blkno) {\r\nif (ext_flags & OCFS2_EXT_REFCOUNTED)\r\nret = ocfs2_decrease_refcount(inode, handle,\r\nocfs2_blocks_to_clusters(osb->sb,\r\nold_blkno),\r\nlen, context->meta_ac,\r\n&context->dealloc, 1);\r\nelse\r\nret = ocfs2_truncate_log_append(osb, handle,\r\nold_blkno, len);\r\n}\r\nocfs2_update_inode_fsync_trans(handle, inode, 0);\r\nout:\r\nocfs2_free_path(path);\r\nreturn ret;\r\n}\r\nstatic int ocfs2_lock_allocators_move_extents(struct inode *inode,\r\nstruct ocfs2_extent_tree *et,\r\nu32 clusters_to_move,\r\nu32 extents_to_split,\r\nstruct ocfs2_alloc_context **meta_ac,\r\nstruct ocfs2_alloc_context **data_ac,\r\nint extra_blocks,\r\nint *credits)\r\n{\r\nint ret, num_free_extents;\r\nunsigned int max_recs_needed = 2 * extents_to_split + clusters_to_move;\r\nstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\r\nnum_free_extents = ocfs2_num_free_extents(osb, et);\r\nif (num_free_extents < 0) {\r\nret = num_free_extents;\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nif (!num_free_extents ||\r\n(ocfs2_sparse_alloc(osb) && num_free_extents < max_recs_needed))\r\nextra_blocks += ocfs2_extend_meta_needed(et->et_root_el);\r\nret = ocfs2_reserve_new_metadata_blocks(osb, extra_blocks, meta_ac);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nif (data_ac) {\r\nret = ocfs2_reserve_clusters(osb, clusters_to_move, data_ac);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\n}\r\n*credits += ocfs2_calc_extend_credits(osb->sb, et->et_root_el);\r\nmlog(0, "reserve metadata_blocks: %d, data_clusters: %u, credits: %d\n",\r\nextra_blocks, clusters_to_move, *credits);\r\nout:\r\nif (ret) {\r\nif (*meta_ac) {\r\nocfs2_free_alloc_context(*meta_ac);\r\n*meta_ac = NULL;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int ocfs2_defrag_extent(struct ocfs2_move_extents_context *context,\r\nu32 cpos, u32 phys_cpos, u32 *len, int ext_flags)\r\n{\r\nint ret, credits = 0, extra_blocks = 0, partial = context->partial;\r\nhandle_t *handle;\r\nstruct inode *inode = context->inode;\r\nstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\r\nstruct inode *tl_inode = osb->osb_tl_inode;\r\nstruct ocfs2_refcount_tree *ref_tree = NULL;\r\nu32 new_phys_cpos, new_len;\r\nu64 phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\r\nif ((ext_flags & OCFS2_EXT_REFCOUNTED) && *len) {\r\nBUG_ON(!(OCFS2_I(inode)->ip_dyn_features &\r\nOCFS2_HAS_REFCOUNT_FL));\r\nBUG_ON(!context->refcount_loc);\r\nret = ocfs2_lock_refcount_tree(osb, context->refcount_loc, 1,\r\n&ref_tree, NULL);\r\nif (ret) {\r\nmlog_errno(ret);\r\nreturn ret;\r\n}\r\nret = ocfs2_prepare_refcount_change_for_del(inode,\r\ncontext->refcount_loc,\r\nphys_blkno,\r\n*len,\r\n&credits,\r\n&extra_blocks);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\n}\r\nret = ocfs2_lock_allocators_move_extents(inode, &context->et, *len, 1,\r\n&context->meta_ac,\r\n&context->data_ac,\r\nextra_blocks, &credits);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nmutex_lock(&tl_inode->i_mutex);\r\nif (ocfs2_truncate_log_needs_flush(osb)) {\r\nret = __ocfs2_flush_truncate_log(osb);\r\nif (ret < 0) {\r\nmlog_errno(ret);\r\ngoto out_unlock_mutex;\r\n}\r\n}\r\nhandle = ocfs2_start_trans(osb, credits);\r\nif (IS_ERR(handle)) {\r\nret = PTR_ERR(handle);\r\nmlog_errno(ret);\r\ngoto out_unlock_mutex;\r\n}\r\nret = __ocfs2_claim_clusters(handle, context->data_ac, 1, *len,\r\n&new_phys_cpos, &new_len);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out_commit;\r\n}\r\nif (new_len != *len) {\r\nmlog(0, "len_claimed: %u, len: %u\n", new_len, *len);\r\nif (!partial) {\r\ncontext->range->me_flags &= ~OCFS2_MOVE_EXT_FL_COMPLETE;\r\nret = -ENOSPC;\r\ngoto out_commit;\r\n}\r\n}\r\nmlog(0, "cpos: %u, phys_cpos: %u, new_phys_cpos: %u\n", cpos,\r\nphys_cpos, new_phys_cpos);\r\nret = __ocfs2_move_extent(handle, context, cpos, new_len, phys_cpos,\r\nnew_phys_cpos, ext_flags);\r\nif (ret)\r\nmlog_errno(ret);\r\nif (partial && (new_len != *len))\r\n*len = new_len;\r\nret = ocfs2_cow_sync_writeback(inode->i_sb, context->inode, cpos, *len);\r\nif (ret)\r\nmlog_errno(ret);\r\nout_commit:\r\nocfs2_commit_trans(osb, handle);\r\nout_unlock_mutex:\r\nmutex_unlock(&tl_inode->i_mutex);\r\nif (context->data_ac) {\r\nocfs2_free_alloc_context(context->data_ac);\r\ncontext->data_ac = NULL;\r\n}\r\nif (context->meta_ac) {\r\nocfs2_free_alloc_context(context->meta_ac);\r\ncontext->meta_ac = NULL;\r\n}\r\nout:\r\nif (ref_tree)\r\nocfs2_unlock_refcount_tree(osb, ref_tree, 1);\r\nreturn ret;\r\n}\r\nstatic int ocfs2_find_victim_alloc_group(struct inode *inode,\r\nu64 vict_blkno,\r\nint type, int slot,\r\nint *vict_bit,\r\nstruct buffer_head **ret_bh)\r\n{\r\nint ret, i, bits_per_unit = 0;\r\nu64 blkno;\r\nchar namebuf[40];\r\nstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\r\nstruct buffer_head *ac_bh = NULL, *gd_bh = NULL;\r\nstruct ocfs2_chain_list *cl;\r\nstruct ocfs2_chain_rec *rec;\r\nstruct ocfs2_dinode *ac_dinode;\r\nstruct ocfs2_group_desc *bg;\r\nocfs2_sprintf_system_inode_name(namebuf, sizeof(namebuf), type, slot);\r\nret = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\r\nstrlen(namebuf), &blkno);\r\nif (ret) {\r\nret = -ENOENT;\r\ngoto out;\r\n}\r\nret = ocfs2_read_blocks_sync(osb, blkno, 1, &ac_bh);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nac_dinode = (struct ocfs2_dinode *)ac_bh->b_data;\r\ncl = &(ac_dinode->id2.i_chain);\r\nrec = &(cl->cl_recs[0]);\r\nif (type == GLOBAL_BITMAP_SYSTEM_INODE)\r\nbits_per_unit = osb->s_clustersize_bits -\r\ninode->i_sb->s_blocksize_bits;\r\nif ((vict_blkno < le64_to_cpu(rec->c_blkno)) ||\r\n(vict_blkno >= ((u64)le32_to_cpu(ac_dinode->id1.bitmap1.i_total) <<\r\nbits_per_unit))) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nfor (i = 0; i < le16_to_cpu(cl->cl_next_free_rec); i++) {\r\nrec = &(cl->cl_recs[i]);\r\nif (!rec)\r\ncontinue;\r\nbg = NULL;\r\ndo {\r\nif (!bg)\r\nblkno = le64_to_cpu(rec->c_blkno);\r\nelse\r\nblkno = le64_to_cpu(bg->bg_next_group);\r\nif (gd_bh) {\r\nbrelse(gd_bh);\r\ngd_bh = NULL;\r\n}\r\nret = ocfs2_read_blocks_sync(osb, blkno, 1, &gd_bh);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nbg = (struct ocfs2_group_desc *)gd_bh->b_data;\r\nif (vict_blkno < (le64_to_cpu(bg->bg_blkno) +\r\nle16_to_cpu(bg->bg_bits))) {\r\n*ret_bh = gd_bh;\r\n*vict_bit = (vict_blkno - blkno) >>\r\nbits_per_unit;\r\nmlog(0, "find the victim group: #%llu, "\r\n"total_bits: %u, vict_bit: %u\n",\r\nblkno, le16_to_cpu(bg->bg_bits),\r\n*vict_bit);\r\ngoto out;\r\n}\r\n} while (le64_to_cpu(bg->bg_next_group));\r\n}\r\nret = -EINVAL;\r\nout:\r\nbrelse(ac_bh);\r\nreturn ret;\r\n}\r\nstatic int ocfs2_validate_and_adjust_move_goal(struct inode *inode,\r\nstruct ocfs2_move_extents *range)\r\n{\r\nint ret, goal_bit = 0;\r\nstruct buffer_head *gd_bh = NULL;\r\nstruct ocfs2_group_desc *bg;\r\nstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\r\nint c_to_b = 1 << (osb->s_clustersize_bits -\r\ninode->i_sb->s_blocksize_bits);\r\nrange->me_goal = ocfs2_block_to_cluster_start(inode->i_sb,\r\nrange->me_goal);\r\nret = ocfs2_find_victim_alloc_group(inode, range->me_goal,\r\nGLOBAL_BITMAP_SYSTEM_INODE,\r\nOCFS2_INVALID_SLOT,\r\n&goal_bit, &gd_bh);\r\nif (ret)\r\ngoto out;\r\nbg = (struct ocfs2_group_desc *)gd_bh->b_data;\r\nif (range->me_goal == le64_to_cpu(bg->bg_blkno))\r\nrange->me_goal += c_to_b;\r\nif ((le16_to_cpu(bg->bg_bits) - goal_bit) * osb->s_clustersize <\r\nrange->me_len) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nmlog(0, "extents get ready to be moved to #%llu block\n",\r\nrange->me_goal);\r\nout:\r\nbrelse(gd_bh);\r\nreturn ret;\r\n}\r\nstatic void ocfs2_probe_alloc_group(struct inode *inode, struct buffer_head *bh,\r\nint *goal_bit, u32 move_len, u32 max_hop,\r\nu32 *phys_cpos)\r\n{\r\nint i, used, last_free_bits = 0, base_bit = *goal_bit;\r\nstruct ocfs2_group_desc *gd = (struct ocfs2_group_desc *)bh->b_data;\r\nu32 base_cpos = ocfs2_blocks_to_clusters(inode->i_sb,\r\nle64_to_cpu(gd->bg_blkno));\r\nfor (i = base_bit; i < le16_to_cpu(gd->bg_bits); i++) {\r\nused = ocfs2_test_bit(i, (unsigned long *)gd->bg_bitmap);\r\nif (used) {\r\nif ((i - base_bit) > max_hop) {\r\n*phys_cpos = 0;\r\nbreak;\r\n}\r\nif (last_free_bits)\r\nlast_free_bits = 0;\r\ncontinue;\r\n} else\r\nlast_free_bits++;\r\nif (last_free_bits == move_len) {\r\n*goal_bit = i;\r\n*phys_cpos = base_cpos + i;\r\nbreak;\r\n}\r\n}\r\nmlog(0, "found phys_cpos: %u to fit the wanted moving.\n", *phys_cpos);\r\n}\r\nstatic int ocfs2_move_extent(struct ocfs2_move_extents_context *context,\r\nu32 cpos, u32 phys_cpos, u32 *new_phys_cpos,\r\nu32 len, int ext_flags)\r\n{\r\nint ret, credits = 0, extra_blocks = 0, goal_bit = 0;\r\nhandle_t *handle;\r\nstruct inode *inode = context->inode;\r\nstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\r\nstruct inode *tl_inode = osb->osb_tl_inode;\r\nstruct inode *gb_inode = NULL;\r\nstruct buffer_head *gb_bh = NULL;\r\nstruct buffer_head *gd_bh = NULL;\r\nstruct ocfs2_group_desc *gd;\r\nstruct ocfs2_refcount_tree *ref_tree = NULL;\r\nu32 move_max_hop = ocfs2_blocks_to_clusters(inode->i_sb,\r\ncontext->range->me_threshold);\r\nu64 phys_blkno, new_phys_blkno;\r\nphys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\r\nif ((ext_flags & OCFS2_EXT_REFCOUNTED) && len) {\r\nBUG_ON(!(OCFS2_I(inode)->ip_dyn_features &\r\nOCFS2_HAS_REFCOUNT_FL));\r\nBUG_ON(!context->refcount_loc);\r\nret = ocfs2_lock_refcount_tree(osb, context->refcount_loc, 1,\r\n&ref_tree, NULL);\r\nif (ret) {\r\nmlog_errno(ret);\r\nreturn ret;\r\n}\r\nret = ocfs2_prepare_refcount_change_for_del(inode,\r\ncontext->refcount_loc,\r\nphys_blkno,\r\nlen,\r\n&credits,\r\n&extra_blocks);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\n}\r\nret = ocfs2_lock_allocators_move_extents(inode, &context->et, len, 1,\r\n&context->meta_ac,\r\nNULL, extra_blocks, &credits);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\ncredits += OCFS2_INODE_UPDATE_CREDITS + 1;\r\ngb_inode = ocfs2_get_system_file_inode(osb, GLOBAL_BITMAP_SYSTEM_INODE,\r\nOCFS2_INVALID_SLOT);\r\nif (!gb_inode) {\r\nmlog(ML_ERROR, "unable to get global_bitmap inode\n");\r\nret = -EIO;\r\ngoto out;\r\n}\r\nmutex_lock(&gb_inode->i_mutex);\r\nret = ocfs2_inode_lock(gb_inode, &gb_bh, 1);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out_unlock_gb_mutex;\r\n}\r\nmutex_lock(&tl_inode->i_mutex);\r\nhandle = ocfs2_start_trans(osb, credits);\r\nif (IS_ERR(handle)) {\r\nret = PTR_ERR(handle);\r\nmlog_errno(ret);\r\ngoto out_unlock_tl_inode;\r\n}\r\nnew_phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, *new_phys_cpos);\r\nret = ocfs2_find_victim_alloc_group(inode, new_phys_blkno,\r\nGLOBAL_BITMAP_SYSTEM_INODE,\r\nOCFS2_INVALID_SLOT,\r\n&goal_bit, &gd_bh);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out_commit;\r\n}\r\nocfs2_probe_alloc_group(inode, gd_bh, &goal_bit, len, move_max_hop,\r\nnew_phys_cpos);\r\nif (!*new_phys_cpos) {\r\nret = -ENOSPC;\r\ngoto out_commit;\r\n}\r\nret = __ocfs2_move_extent(handle, context, cpos, len, phys_cpos,\r\n*new_phys_cpos, ext_flags);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out_commit;\r\n}\r\ngd = (struct ocfs2_group_desc *)gd_bh->b_data;\r\nret = ocfs2_alloc_dinode_update_counts(gb_inode, handle, gb_bh, len,\r\nle16_to_cpu(gd->bg_chain));\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out_commit;\r\n}\r\nret = ocfs2_block_group_set_bits(handle, gb_inode, gd, gd_bh,\r\ngoal_bit, len);\r\nif (ret) {\r\nocfs2_rollback_alloc_dinode_counts(gb_inode, gb_bh, len,\r\nle16_to_cpu(gd->bg_chain));\r\nmlog_errno(ret);\r\n}\r\nret = ocfs2_cow_sync_writeback(inode->i_sb, context->inode, cpos, len);\r\nif (ret)\r\nmlog_errno(ret);\r\nout_commit:\r\nocfs2_commit_trans(osb, handle);\r\nbrelse(gd_bh);\r\nout_unlock_tl_inode:\r\nmutex_unlock(&tl_inode->i_mutex);\r\nocfs2_inode_unlock(gb_inode, 1);\r\nout_unlock_gb_mutex:\r\nmutex_unlock(&gb_inode->i_mutex);\r\nbrelse(gb_bh);\r\niput(gb_inode);\r\nout:\r\nif (context->meta_ac) {\r\nocfs2_free_alloc_context(context->meta_ac);\r\ncontext->meta_ac = NULL;\r\n}\r\nif (ref_tree)\r\nocfs2_unlock_refcount_tree(osb, ref_tree, 1);\r\nreturn ret;\r\n}\r\nstatic void ocfs2_calc_extent_defrag_len(u32 *alloc_size, u32 *len_defraged,\r\nu32 threshold, int *skip)\r\n{\r\nif ((*alloc_size + *len_defraged) < threshold) {\r\n*len_defraged += *alloc_size;\r\n} else if (*len_defraged == 0) {\r\n*skip = 1;\r\n} else {\r\n*alloc_size = threshold - *len_defraged;\r\n*len_defraged = 0;\r\n}\r\n}\r\nstatic int __ocfs2_move_extents_range(struct buffer_head *di_bh,\r\nstruct ocfs2_move_extents_context *context)\r\n{\r\nint ret = 0, flags, do_defrag, skip = 0;\r\nu32 cpos, phys_cpos, move_start, len_to_move, alloc_size;\r\nu32 len_defraged = 0, defrag_thresh = 0, new_phys_cpos = 0;\r\nstruct inode *inode = context->inode;\r\nstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\r\nstruct ocfs2_move_extents *range = context->range;\r\nstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\r\nif ((i_size_read(inode) == 0) || (range->me_len == 0))\r\nreturn 0;\r\nif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\r\nreturn 0;\r\ncontext->refcount_loc = le64_to_cpu(di->i_refcount_loc);\r\nocfs2_init_dinode_extent_tree(&context->et, INODE_CACHE(inode), di_bh);\r\nocfs2_init_dealloc_ctxt(&context->dealloc);\r\ndo_defrag = context->auto_defrag;\r\nmove_start = ocfs2_clusters_for_bytes(osb->sb, range->me_start);\r\nlen_to_move = (range->me_start + range->me_len) >>\r\nosb->s_clustersize_bits;\r\nif (len_to_move >= move_start)\r\nlen_to_move -= move_start;\r\nelse\r\nlen_to_move = 0;\r\nif (do_defrag) {\r\ndefrag_thresh = range->me_threshold >> osb->s_clustersize_bits;\r\nif (defrag_thresh <= 1)\r\ngoto done;\r\n} else\r\nnew_phys_cpos = ocfs2_blocks_to_clusters(inode->i_sb,\r\nrange->me_goal);\r\nmlog(0, "Inode: %llu, start: %llu, len: %llu, cstart: %u, clen: %u, "\r\n"thresh: %u\n",\r\n(unsigned long long)OCFS2_I(inode)->ip_blkno,\r\n(unsigned long long)range->me_start,\r\n(unsigned long long)range->me_len,\r\nmove_start, len_to_move, defrag_thresh);\r\ncpos = move_start;\r\nwhile (len_to_move) {\r\nret = ocfs2_get_clusters(inode, cpos, &phys_cpos, &alloc_size,\r\n&flags);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nif (alloc_size > len_to_move)\r\nalloc_size = len_to_move;\r\nif (!phys_cpos) {\r\nif (do_defrag)\r\nlen_defraged = 0;\r\ngoto next;\r\n}\r\nif (do_defrag) {\r\nocfs2_calc_extent_defrag_len(&alloc_size, &len_defraged,\r\ndefrag_thresh, &skip);\r\nif (skip) {\r\nskip = 0;\r\ngoto next;\r\n}\r\nmlog(0, "#Defrag: cpos: %u, phys_cpos: %u, "\r\n"alloc_size: %u, len_defraged: %u\n",\r\ncpos, phys_cpos, alloc_size, len_defraged);\r\nret = ocfs2_defrag_extent(context, cpos, phys_cpos,\r\n&alloc_size, flags);\r\n} else {\r\nret = ocfs2_move_extent(context, cpos, phys_cpos,\r\n&new_phys_cpos, alloc_size,\r\nflags);\r\nnew_phys_cpos += alloc_size;\r\n}\r\nif (ret < 0) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\ncontext->clusters_moved += alloc_size;\r\nnext:\r\ncpos += alloc_size;\r\nlen_to_move -= alloc_size;\r\n}\r\ndone:\r\nrange->me_flags |= OCFS2_MOVE_EXT_FL_COMPLETE;\r\nout:\r\nrange->me_moved_len = ocfs2_clusters_to_bytes(osb->sb,\r\ncontext->clusters_moved);\r\nrange->me_new_offset = ocfs2_clusters_to_bytes(osb->sb,\r\ncontext->new_phys_cpos);\r\nocfs2_schedule_truncate_log_flush(osb, 1);\r\nocfs2_run_deallocs(osb, &context->dealloc);\r\nreturn ret;\r\n}\r\nstatic int ocfs2_move_extents(struct ocfs2_move_extents_context *context)\r\n{\r\nint status;\r\nhandle_t *handle;\r\nstruct inode *inode = context->inode;\r\nstruct ocfs2_dinode *di;\r\nstruct buffer_head *di_bh = NULL;\r\nstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\r\nif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb))\r\nreturn -EROFS;\r\nmutex_lock(&inode->i_mutex);\r\nstatus = ocfs2_rw_lock(inode, 1);\r\nif (status) {\r\nmlog_errno(status);\r\ngoto out;\r\n}\r\nstatus = ocfs2_inode_lock(inode, &di_bh, 1);\r\nif (status) {\r\nmlog_errno(status);\r\ngoto out_rw_unlock;\r\n}\r\ndown_write(&OCFS2_I(inode)->ip_alloc_sem);\r\nstatus = __ocfs2_move_extents_range(di_bh, context);\r\nup_write(&OCFS2_I(inode)->ip_alloc_sem);\r\nif (status) {\r\nmlog_errno(status);\r\ngoto out_inode_unlock;\r\n}\r\nhandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\r\nif (IS_ERR(handle)) {\r\nstatus = PTR_ERR(handle);\r\nmlog_errno(status);\r\ngoto out_inode_unlock;\r\n}\r\nstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\r\nOCFS2_JOURNAL_ACCESS_WRITE);\r\nif (status) {\r\nmlog_errno(status);\r\ngoto out_commit;\r\n}\r\ndi = (struct ocfs2_dinode *)di_bh->b_data;\r\ninode->i_ctime = CURRENT_TIME;\r\ndi->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\r\ndi->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\r\nocfs2_update_inode_fsync_trans(handle, inode, 0);\r\nocfs2_journal_dirty(handle, di_bh);\r\nout_commit:\r\nocfs2_commit_trans(osb, handle);\r\nout_inode_unlock:\r\nbrelse(di_bh);\r\nocfs2_inode_unlock(inode, 1);\r\nout_rw_unlock:\r\nocfs2_rw_unlock(inode, 1);\r\nout:\r\nmutex_unlock(&inode->i_mutex);\r\nreturn status;\r\n}\r\nint ocfs2_ioctl_move_extents(struct file *filp, void __user *argp)\r\n{\r\nint status;\r\nstruct inode *inode = file_inode(filp);\r\nstruct ocfs2_move_extents range;\r\nstruct ocfs2_move_extents_context *context;\r\nif (!argp)\r\nreturn -EINVAL;\r\nstatus = mnt_want_write_file(filp);\r\nif (status)\r\nreturn status;\r\nif ((!S_ISREG(inode->i_mode)) || !(filp->f_mode & FMODE_WRITE)) {\r\nstatus = -EPERM;\r\ngoto out_drop;\r\n}\r\nif (inode->i_flags & (S_IMMUTABLE|S_APPEND)) {\r\nstatus = -EPERM;\r\ngoto out_drop;\r\n}\r\ncontext = kzalloc(sizeof(struct ocfs2_move_extents_context), GFP_NOFS);\r\nif (!context) {\r\nstatus = -ENOMEM;\r\nmlog_errno(status);\r\ngoto out_drop;\r\n}\r\ncontext->inode = inode;\r\ncontext->file = filp;\r\nif (copy_from_user(&range, argp, sizeof(range))) {\r\nstatus = -EFAULT;\r\ngoto out_free;\r\n}\r\nif (range.me_start > i_size_read(inode)) {\r\nstatus = -EINVAL;\r\ngoto out_free;\r\n}\r\nif (range.me_start + range.me_len > i_size_read(inode))\r\nrange.me_len = i_size_read(inode) - range.me_start;\r\ncontext->range = &range;\r\nif (range.me_flags & OCFS2_MOVE_EXT_FL_AUTO_DEFRAG) {\r\ncontext->auto_defrag = 1;\r\nif (!range.me_threshold)\r\nrange.me_threshold = 1024 * 1024;\r\nif (range.me_threshold > i_size_read(inode))\r\nrange.me_threshold = i_size_read(inode);\r\nif (range.me_flags & OCFS2_MOVE_EXT_FL_PART_DEFRAG)\r\ncontext->partial = 1;\r\n} else {\r\nstatus = ocfs2_validate_and_adjust_move_goal(inode, &range);\r\nif (status)\r\ngoto out_copy;\r\n}\r\nstatus = ocfs2_move_extents(context);\r\nif (status)\r\nmlog_errno(status);\r\nout_copy:\r\nif (copy_to_user(argp, &range, sizeof(range)))\r\nstatus = -EFAULT;\r\nout_free:\r\nkfree(context);\r\nout_drop:\r\nmnt_drop_write_file(filp);\r\nreturn status;\r\n}
