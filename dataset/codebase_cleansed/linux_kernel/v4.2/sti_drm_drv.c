static void sti_drm_atomic_schedule(struct sti_drm_private *private,\r\nstruct drm_atomic_state *state)\r\n{\r\nprivate->commit.state = state;\r\nschedule_work(&private->commit.work);\r\n}\r\nstatic void sti_drm_atomic_complete(struct sti_drm_private *private,\r\nstruct drm_atomic_state *state)\r\n{\r\nstruct drm_device *drm = private->drm_dev;\r\ndrm_atomic_helper_commit_modeset_disables(drm, state);\r\ndrm_atomic_helper_commit_planes(drm, state);\r\ndrm_atomic_helper_commit_modeset_enables(drm, state);\r\ndrm_atomic_helper_wait_for_vblanks(drm, state);\r\ndrm_atomic_helper_cleanup_planes(drm, state);\r\ndrm_atomic_state_free(state);\r\n}\r\nstatic void sti_drm_atomic_work(struct work_struct *work)\r\n{\r\nstruct sti_drm_private *private = container_of(work,\r\nstruct sti_drm_private, commit.work);\r\nsti_drm_atomic_complete(private, private->commit.state);\r\n}\r\nstatic int sti_drm_atomic_commit(struct drm_device *drm,\r\nstruct drm_atomic_state *state, bool async)\r\n{\r\nstruct sti_drm_private *private = drm->dev_private;\r\nint err;\r\nerr = drm_atomic_helper_prepare_planes(drm, state);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&private->commit.lock);\r\nflush_work(&private->commit.work);\r\ndrm_atomic_helper_swap_state(drm, state);\r\nif (async)\r\nsti_drm_atomic_schedule(private, state);\r\nelse\r\nsti_drm_atomic_complete(private, state);\r\nmutex_unlock(&private->commit.lock);\r\nreturn 0;\r\n}\r\nstatic void sti_drm_mode_config_init(struct drm_device *dev)\r\n{\r\ndev->mode_config.min_width = 0;\r\ndev->mode_config.min_height = 0;\r\ndev->mode_config.max_width = STI_MAX_FB_HEIGHT;\r\ndev->mode_config.max_height = STI_MAX_FB_WIDTH;\r\ndev->mode_config.funcs = &sti_drm_mode_config_funcs;\r\n}\r\nstatic int sti_drm_load(struct drm_device *dev, unsigned long flags)\r\n{\r\nstruct sti_drm_private *private;\r\nint ret;\r\nprivate = kzalloc(sizeof(struct sti_drm_private), GFP_KERNEL);\r\nif (!private) {\r\nDRM_ERROR("Failed to allocate private\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->dev_private = (void *)private;\r\nprivate->drm_dev = dev;\r\nmutex_init(&private->commit.lock);\r\nINIT_WORK(&private->commit.work, sti_drm_atomic_work);\r\ndrm_mode_config_init(dev);\r\ndrm_kms_helper_poll_init(dev);\r\nsti_drm_mode_config_init(dev);\r\nret = component_bind_all(dev->dev, dev);\r\nif (ret) {\r\ndrm_kms_helper_poll_fini(dev);\r\ndrm_mode_config_cleanup(dev);\r\nkfree(private);\r\nreturn ret;\r\n}\r\ndrm_mode_config_reset(dev);\r\n#ifdef CONFIG_DRM_STI_FBDEV\r\ndrm_fbdev_cma_init(dev, 32,\r\ndev->mode_config.num_crtc,\r\ndev->mode_config.num_connector);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic struct dma_buf *sti_drm_gem_prime_export(struct drm_device *dev,\r\nstruct drm_gem_object *obj,\r\nint flags)\r\n{\r\nflags |= O_RDWR;\r\nreturn drm_gem_prime_export(dev, obj, flags);\r\n}\r\nstatic int compare_of(struct device *dev, void *data)\r\n{\r\nreturn dev->of_node == data;\r\n}\r\nstatic int sti_drm_bind(struct device *dev)\r\n{\r\nreturn drm_platform_init(&sti_drm_driver, to_platform_device(dev));\r\n}\r\nstatic void sti_drm_unbind(struct device *dev)\r\n{\r\ndrm_put_dev(dev_get_drvdata(dev));\r\n}\r\nstatic int sti_drm_master_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *node = dev->parent->of_node;\r\nstruct device_node *child_np;\r\nstruct component_match *match = NULL;\r\ndma_set_coherent_mask(dev, DMA_BIT_MASK(32));\r\nchild_np = of_get_next_available_child(node, NULL);\r\nwhile (child_np) {\r\ncomponent_match_add(dev, &match, compare_of, child_np);\r\nof_node_put(child_np);\r\nchild_np = of_get_next_available_child(node, child_np);\r\n}\r\nreturn component_master_add_with_match(dev, &sti_drm_ops, match);\r\n}\r\nstatic int sti_drm_master_remove(struct platform_device *pdev)\r\n{\r\ncomponent_master_del(&pdev->dev, &sti_drm_ops);\r\nreturn 0;\r\n}\r\nstatic int sti_drm_platform_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *node = dev->of_node;\r\nstruct platform_device *master;\r\nof_platform_populate(node, NULL, NULL, dev);\r\nplatform_driver_register(&sti_drm_master_driver);\r\nmaster = platform_device_register_resndata(dev,\r\nDRIVER_NAME "__master", -1,\r\nNULL, 0, NULL, 0);\r\nif (IS_ERR(master))\r\nreturn PTR_ERR(master);\r\nplatform_set_drvdata(pdev, master);\r\nreturn 0;\r\n}\r\nstatic int sti_drm_platform_remove(struct platform_device *pdev)\r\n{\r\nstruct platform_device *master = platform_get_drvdata(pdev);\r\nof_platform_depopulate(&pdev->dev);\r\nplatform_device_unregister(master);\r\nplatform_driver_unregister(&sti_drm_master_driver);\r\nreturn 0;\r\n}
