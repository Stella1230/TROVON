static int __unioxx5_define_chan_offset(int chan_num)\r\n{\r\nif (chan_num < 0 || chan_num > 23)\r\nreturn -1;\r\nreturn (chan_num >> 3) + 1;\r\n}\r\nstatic void __unioxx5_analog_config(struct unioxx5_subd_priv *usp, int channel)\r\n{\r\nint chan_a, chan_b, conf, channel_offset;\r\nchannel_offset = __unioxx5_define_chan_offset(channel);\r\nconf = usp->usp_prev_cn_val[channel_offset - 1];\r\nchan_a = chan_b = 1;\r\nif (channel % 2 == 0) {\r\nchan_a <<= channel & 0x07;\r\nchan_b <<= (channel + 1) & 0x07;\r\n} else {\r\nchan_a <<= (channel - 1) & 0x07;\r\nchan_b <<= channel & 0x07;\r\n}\r\nconf |= chan_a;\r\nconf &= ~chan_b;\r\noutb(1, usp->usp_iobase + 0);\r\noutb(conf, usp->usp_iobase + channel_offset);\r\noutb(0, usp->usp_iobase + 0);\r\nusp->usp_prev_cn_val[channel_offset - 1] = conf;\r\n}\r\nstatic int __unioxx5_digital_read(struct comedi_subdevice *s,\r\nunsigned int *data, int channel, int minor)\r\n{\r\nstruct unioxx5_subd_priv *usp = s->private;\r\nstruct device *csdev = s->device->class_dev;\r\nint channel_offset, mask = 1 << (channel & 0x07);\r\nchannel_offset = __unioxx5_define_chan_offset(channel);\r\nif (channel_offset < 0) {\r\ndev_err(csdev,\r\n"undefined channel %d. channel range is 0 .. 23\n",\r\nchannel);\r\nreturn 0;\r\n}\r\n*data = inb(usp->usp_iobase + channel_offset);\r\n*data &= mask;\r\nif (channel_offset > 1)\r\nchannel -= 2 << channel_offset;\r\n*data >>= channel;\r\nreturn 1;\r\n}\r\nstatic int __unioxx5_analog_read(struct comedi_subdevice *s,\r\nunsigned int *data, int channel, int minor)\r\n{\r\nstruct unioxx5_subd_priv *usp = s->private;\r\nstruct device *csdev = s->device->class_dev;\r\nint module_no, read_ch;\r\nchar control;\r\nmodule_no = channel / 2;\r\nread_ch = channel % 2;\r\nif (usp->usp_module_type[module_no] & MODULE_OUTPUT_MASK) {\r\ndev_err(csdev,\r\n"module in position %d with id 0x%02x is for output only",\r\nmodule_no, usp->usp_module_type[module_no]);\r\nreturn 0;\r\n}\r\n__unioxx5_analog_config(usp, channel);\r\noutb(module_no + 1, usp->usp_iobase + 5);\r\noutb('V', usp->usp_iobase + 6);\r\ncontrol = inb(usp->usp_iobase);\r\nwhile (!((control = inb(usp->usp_iobase + 0)) & Rx4CA))\r\n;\r\nif ((control & Rx4CA_ERR_MASK)) {\r\ndev_err(csdev, "4 bytes error\n");\r\nreturn 0;\r\n}\r\nif (read_ch)\r\n*data = inw(usp->usp_iobase + 6);\r\nelse\r\n*data = inw(usp->usp_iobase + 4);\r\nreturn 1;\r\n}\r\nstatic int __unioxx5_digital_write(struct comedi_subdevice *s,\r\nunsigned int *data, int channel, int minor)\r\n{\r\nstruct unioxx5_subd_priv *usp = s->private;\r\nstruct device *csdev = s->device->class_dev;\r\nint channel_offset, val;\r\nint mask = 1 << (channel & 0x07);\r\nchannel_offset = __unioxx5_define_chan_offset(channel);\r\nif (channel_offset < 0) {\r\ndev_err(csdev,\r\n"undefined channel %d. channel range is 0 .. 23\n",\r\nchannel);\r\nreturn 0;\r\n}\r\nval = usp->usp_prev_wr_val[channel_offset - 1];\r\nif (*data)\r\nval |= mask;\r\nelse\r\nval &= ~mask;\r\noutb(val, usp->usp_iobase + channel_offset);\r\nusp->usp_prev_wr_val[channel_offset - 1] = val;\r\nreturn 1;\r\n}\r\nstatic int __unioxx5_analog_write(struct comedi_subdevice *s,\r\nunsigned int *data, int channel, int minor)\r\n{\r\nstruct unioxx5_subd_priv *usp = s->private;\r\nstruct device *csdev = s->device->class_dev;\r\nint module, i;\r\nmodule = channel / 2;\r\ni = (channel % 2) << 1;\r\nif (!(usp->usp_module_type[module] & MODULE_OUTPUT_MASK)) {\r\ndev_err(csdev,\r\n"module in position %d with id 0x%0x is for input only!\n",\r\nmodule, usp->usp_module_type[module]);\r\nreturn 0;\r\n}\r\n__unioxx5_analog_config(usp, channel);\r\nusp->usp_extra_data[module][i++] = (unsigned char)(*data & 0x00FF);\r\nusp->usp_extra_data[module][i] = (unsigned char)((*data & 0xFF00) >> 8);\r\noutb(module + 1, usp->usp_iobase + 5);\r\noutb('W', usp->usp_iobase + 6);\r\nfor (i = 0; i < 4; i++) {\r\nwhile (!((inb(usp->usp_iobase + 0)) & TxBE))\r\n;\r\noutb(usp->usp_extra_data[module][i], usp->usp_iobase + 6);\r\n}\r\nreturn 1;\r\n}\r\nstatic int unioxx5_subdev_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *subdev,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct unioxx5_subd_priv *usp = subdev->private;\r\nint channel, type;\r\nchannel = CR_CHAN(insn->chanspec);\r\ntype = usp->usp_module_type[channel / 2];\r\nif (type == MODULE_DIGITAL) {\r\nif (!__unioxx5_digital_read(subdev, data, channel, dev->minor))\r\nreturn -1;\r\n} else {\r\nif (!__unioxx5_analog_read(subdev, data, channel, dev->minor))\r\nreturn -1;\r\n}\r\nreturn 1;\r\n}\r\nstatic int unioxx5_subdev_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *subdev,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct unioxx5_subd_priv *usp = subdev->private;\r\nint channel, type;\r\nchannel = CR_CHAN(insn->chanspec);\r\ntype = usp->usp_module_type[channel / 2];\r\nif (type == MODULE_DIGITAL) {\r\nif (!__unioxx5_digital_write(subdev, data, channel, dev->minor))\r\nreturn -1;\r\n} else {\r\nif (!__unioxx5_analog_write(subdev, data, channel, dev->minor))\r\nreturn -1;\r\n}\r\nreturn 1;\r\n}\r\nstatic int unioxx5_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *subdev,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint channel_offset, flags, channel = CR_CHAN(insn->chanspec), type;\r\nstruct unioxx5_subd_priv *usp = subdev->private;\r\nint mask = 1 << (channel & 0x07);\r\ntype = usp->usp_module_type[channel / 2];\r\nif (type != MODULE_DIGITAL) {\r\ndev_err(dev->class_dev,\r\n"channel configuration accessible only for digital modules\n");\r\nreturn -1;\r\n}\r\nchannel_offset = __unioxx5_define_chan_offset(channel);\r\nif (channel_offset < 0) {\r\ndev_err(dev->class_dev,\r\n"undefined channel %d. channel range is 0 .. 23\n",\r\nchannel);\r\nreturn -1;\r\n}\r\nflags = usp->usp_prev_cn_val[channel_offset - 1];\r\nswitch (*data) {\r\ncase COMEDI_INPUT:\r\nflags &= ~mask;\r\nbreak;\r\ncase COMEDI_OUTPUT:\r\nflags |= mask;\r\nbreak;\r\ndefault:\r\ndev_err(dev->class_dev, "unknown flag\n");\r\nreturn -1;\r\n}\r\noutb(1, usp->usp_iobase + 0);\r\noutb(flags, usp->usp_iobase + channel_offset);\r\noutb(0, usp->usp_iobase + 0);\r\nusp->usp_prev_cn_val[channel_offset - 1] = flags;\r\nreturn 0;\r\n}\r\nstatic int __unioxx5_subdev_init(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nint iobase)\r\n{\r\nstruct unioxx5_subd_priv *usp;\r\nint i, to, ndef_flag = 0;\r\nint ret;\r\nusp = comedi_alloc_spriv(s, sizeof(*usp));\r\nif (!usp)\r\nreturn -ENOMEM;\r\nret = __comedi_request_region(dev, iobase, UNIOXX5_SIZE);\r\nif (ret)\r\nreturn ret;\r\nusp->usp_iobase = iobase;\r\nfor (i = 0; i < 12; i++) {\r\nto = 10000;\r\n__unioxx5_analog_config(usp, i * 2);\r\noutb(i + 1, iobase + 5);\r\noutb('H', iobase + 6);\r\nwhile (!(inb(iobase + 0) & TxBE))\r\n;\r\noutb(0, iobase + 6);\r\nwhile (!(inb(iobase + 0) & Rx2CA)) {\r\nif (--to <= 0) {\r\nndef_flag = 1;\r\nbreak;\r\n}\r\n}\r\nif (ndef_flag) {\r\nusp->usp_module_type[i] = 0;\r\nndef_flag = 0;\r\n} else {\r\nusp->usp_module_type[i] = inb(iobase + 6);\r\n}\r\nudelay(1);\r\n}\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = UNIOXX5_NUM_OF_CHANS;\r\ns->maxdata = 0xFFF;\r\ns->range_table = &range_digital;\r\ns->insn_read = unioxx5_subdev_read;\r\ns->insn_write = unioxx5_subdev_write;\r\ns->insn_config = unioxx5_insn_config;\r\nreturn 0;\r\n}\r\nstatic int unioxx5_attach(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nstruct comedi_subdevice *s;\r\nint iobase, i, n_subd;\r\nint id, num, ba;\r\nint ret;\r\niobase = it->options[0];\r\ndev->iobase = iobase;\r\niobase += UNIOXX5_SUBDEV_BASE;\r\nn_subd = 0;\r\nfor (i = 0, ba = iobase; i < 4; i++, ba += UNIOXX5_SUBDEV_ODDS) {\r\nid = inb(ba + 0xE);\r\nnum = inb(ba + 0xF);\r\nif (id != 'g' || num != 1)\r\ncontinue;\r\nn_subd++;\r\n}\r\nif (n_subd < 2) {\r\ndev_err(dev->class_dev,\r\n"your card must has at least 2 'g01' subdevices\n");\r\nreturn -1;\r\n}\r\nret = comedi_alloc_subdevices(dev, n_subd);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < n_subd; i++, iobase += UNIOXX5_SUBDEV_ODDS) {\r\ns = &dev->subdevices[i];\r\nret = __unioxx5_subdev_init(dev, s, iobase);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void unioxx5_detach(struct comedi_device *dev)\r\n{\r\nstruct comedi_subdevice *s;\r\nstruct unioxx5_subd_priv *spriv;\r\nint i;\r\nfor (i = 0; i < dev->n_subdevices; i++) {\r\ns = &dev->subdevices[i];\r\nspriv = s->private;\r\nif (spriv && spriv->usp_iobase)\r\nrelease_region(spriv->usp_iobase, UNIOXX5_SIZE);\r\n}\r\n}
