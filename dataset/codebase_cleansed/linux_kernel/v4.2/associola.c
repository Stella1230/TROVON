static struct sctp_association *sctp_association_init(struct sctp_association *asoc,\r\nconst struct sctp_endpoint *ep,\r\nconst struct sock *sk,\r\nsctp_scope_t scope,\r\ngfp_t gfp)\r\n{\r\nstruct net *net = sock_net(sk);\r\nstruct sctp_sock *sp;\r\nint i;\r\nsctp_paramhdr_t *p;\r\nint err;\r\nsp = sctp_sk((struct sock *)sk);\r\nasoc->ep = (struct sctp_endpoint *)ep;\r\nasoc->base.sk = (struct sock *)sk;\r\nsctp_endpoint_hold(asoc->ep);\r\nsock_hold(asoc->base.sk);\r\nasoc->base.type = SCTP_EP_TYPE_ASSOCIATION;\r\natomic_set(&asoc->base.refcnt, 1);\r\nsctp_bind_addr_init(&asoc->base.bind_addr, ep->base.bind_addr.port);\r\nasoc->state = SCTP_STATE_CLOSED;\r\nasoc->cookie_life = ms_to_ktime(sp->assocparams.sasoc_cookie_life);\r\nasoc->user_frag = sp->user_frag;\r\nasoc->max_retrans = sp->assocparams.sasoc_asocmaxrxt;\r\nasoc->pf_retrans = net->sctp.pf_retrans;\r\nasoc->rto_initial = msecs_to_jiffies(sp->rtoinfo.srto_initial);\r\nasoc->rto_max = msecs_to_jiffies(sp->rtoinfo.srto_max);\r\nasoc->rto_min = msecs_to_jiffies(sp->rtoinfo.srto_min);\r\nasoc->hbinterval = msecs_to_jiffies(sp->hbinterval);\r\nasoc->pathmaxrxt = sp->pathmaxrxt;\r\nasoc->pathmtu = sp->pathmtu;\r\nasoc->sackdelay = msecs_to_jiffies(sp->sackdelay);\r\nasoc->sackfreq = sp->sackfreq;\r\nasoc->param_flags = sp->param_flags;\r\nasoc->max_burst = sp->max_burst;\r\nasoc->timeouts[SCTP_EVENT_TIMEOUT_T1_COOKIE] = asoc->rto_initial;\r\nasoc->timeouts[SCTP_EVENT_TIMEOUT_T1_INIT] = asoc->rto_initial;\r\nasoc->timeouts[SCTP_EVENT_TIMEOUT_T2_SHUTDOWN] = asoc->rto_initial;\r\nasoc->timeouts[SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD]\r\n= 5 * asoc->rto_max;\r\nasoc->timeouts[SCTP_EVENT_TIMEOUT_SACK] = asoc->sackdelay;\r\nasoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE] = sp->autoclose * HZ;\r\nfor (i = SCTP_EVENT_TIMEOUT_NONE; i < SCTP_NUM_TIMEOUT_TYPES; ++i)\r\nsetup_timer(&asoc->timers[i], sctp_timer_events[i],\r\n(unsigned long)asoc);\r\nasoc->c.sinit_max_instreams = sp->initmsg.sinit_max_instreams;\r\nasoc->c.sinit_num_ostreams = sp->initmsg.sinit_num_ostreams;\r\nasoc->max_init_attempts = sp->initmsg.sinit_max_attempts;\r\nasoc->max_init_timeo =\r\nmsecs_to_jiffies(sp->initmsg.sinit_max_init_timeo);\r\nif ((sk->sk_rcvbuf/2) < SCTP_DEFAULT_MINWINDOW)\r\nasoc->rwnd = SCTP_DEFAULT_MINWINDOW;\r\nelse\r\nasoc->rwnd = sk->sk_rcvbuf/2;\r\nasoc->a_rwnd = asoc->rwnd;\r\nasoc->peer.rwnd = SCTP_DEFAULT_MAXWINDOW;\r\natomic_set(&asoc->rmem_alloc, 0);\r\ninit_waitqueue_head(&asoc->wait);\r\nasoc->c.my_vtag = sctp_generate_tag(ep);\r\nasoc->c.my_port = ep->base.bind_addr.port;\r\nasoc->c.initial_tsn = sctp_generate_tsn(ep);\r\nasoc->next_tsn = asoc->c.initial_tsn;\r\nasoc->ctsn_ack_point = asoc->next_tsn - 1;\r\nasoc->adv_peer_ack_point = asoc->ctsn_ack_point;\r\nasoc->highest_sacked = asoc->ctsn_ack_point;\r\nasoc->last_cwr_tsn = asoc->ctsn_ack_point;\r\nasoc->addip_serial = asoc->c.initial_tsn;\r\nINIT_LIST_HEAD(&asoc->addip_chunk_list);\r\nINIT_LIST_HEAD(&asoc->asconf_ack_list);\r\nINIT_LIST_HEAD(&asoc->peer.transport_addr_list);\r\nasoc->peer.sack_needed = 1;\r\nasoc->peer.sack_generation = 1;\r\nif (net->sctp.addip_noauth)\r\nasoc->peer.asconf_capable = 1;\r\nsctp_inq_init(&asoc->base.inqueue);\r\nsctp_inq_set_th_handler(&asoc->base.inqueue, sctp_assoc_bh_rcv);\r\nsctp_outq_init(asoc, &asoc->outqueue);\r\nif (!sctp_ulpq_init(&asoc->ulpq, asoc))\r\ngoto fail_init;\r\nasoc->peer.ipv4_address = 1;\r\nif (asoc->base.sk->sk_family == PF_INET6)\r\nasoc->peer.ipv6_address = 1;\r\nINIT_LIST_HEAD(&asoc->asocs);\r\nasoc->default_stream = sp->default_stream;\r\nasoc->default_ppid = sp->default_ppid;\r\nasoc->default_flags = sp->default_flags;\r\nasoc->default_context = sp->default_context;\r\nasoc->default_timetolive = sp->default_timetolive;\r\nasoc->default_rcv_context = sp->default_rcv_context;\r\nINIT_LIST_HEAD(&asoc->endpoint_shared_keys);\r\nerr = sctp_auth_asoc_copy_shkeys(ep, asoc, gfp);\r\nif (err)\r\ngoto fail_init;\r\nasoc->active_key_id = ep->active_key_id;\r\nif (ep->auth_hmacs_list)\r\nmemcpy(asoc->c.auth_hmacs, ep->auth_hmacs_list,\r\nntohs(ep->auth_hmacs_list->param_hdr.length));\r\nif (ep->auth_chunk_list)\r\nmemcpy(asoc->c.auth_chunks, ep->auth_chunk_list,\r\nntohs(ep->auth_chunk_list->param_hdr.length));\r\np = (sctp_paramhdr_t *)asoc->c.auth_random;\r\np->type = SCTP_PARAM_RANDOM;\r\np->length = htons(sizeof(sctp_paramhdr_t) + SCTP_AUTH_RANDOM_LENGTH);\r\nget_random_bytes(p+1, SCTP_AUTH_RANDOM_LENGTH);\r\nreturn asoc;\r\nfail_init:\r\nsock_put(asoc->base.sk);\r\nsctp_endpoint_put(asoc->ep);\r\nreturn NULL;\r\n}\r\nstruct sctp_association *sctp_association_new(const struct sctp_endpoint *ep,\r\nconst struct sock *sk,\r\nsctp_scope_t scope,\r\ngfp_t gfp)\r\n{\r\nstruct sctp_association *asoc;\r\nasoc = kzalloc(sizeof(*asoc), gfp);\r\nif (!asoc)\r\ngoto fail;\r\nif (!sctp_association_init(asoc, ep, sk, scope, gfp))\r\ngoto fail_init;\r\nSCTP_DBG_OBJCNT_INC(assoc);\r\npr_debug("Created asoc %p\n", asoc);\r\nreturn asoc;\r\nfail_init:\r\nkfree(asoc);\r\nfail:\r\nreturn NULL;\r\n}\r\nvoid sctp_association_free(struct sctp_association *asoc)\r\n{\r\nstruct sock *sk = asoc->base.sk;\r\nstruct sctp_transport *transport;\r\nstruct list_head *pos, *temp;\r\nint i;\r\nif (!list_empty(&asoc->asocs)) {\r\nlist_del(&asoc->asocs);\r\nif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING))\r\nsk->sk_ack_backlog--;\r\n}\r\nasoc->base.dead = true;\r\nsctp_outq_free(&asoc->outqueue);\r\nsctp_ulpq_free(&asoc->ulpq);\r\nsctp_inq_free(&asoc->base.inqueue);\r\nsctp_tsnmap_free(&asoc->peer.tsn_map);\r\nsctp_ssnmap_free(asoc->ssnmap);\r\nsctp_bind_addr_free(&asoc->base.bind_addr);\r\nfor (i = SCTP_EVENT_TIMEOUT_NONE; i < SCTP_NUM_TIMEOUT_TYPES; ++i) {\r\nif (del_timer(&asoc->timers[i]))\r\nsctp_association_put(asoc);\r\n}\r\nkfree(asoc->peer.cookie);\r\nkfree(asoc->peer.peer_random);\r\nkfree(asoc->peer.peer_chunks);\r\nkfree(asoc->peer.peer_hmacs);\r\nlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\r\ntransport = list_entry(pos, struct sctp_transport, transports);\r\nlist_del_rcu(pos);\r\nsctp_transport_free(transport);\r\n}\r\nasoc->peer.transport_count = 0;\r\nsctp_asconf_queue_teardown(asoc);\r\nkfree(asoc->asconf_addr_del_pending);\r\nsctp_auth_destroy_keys(&asoc->endpoint_shared_keys);\r\nsctp_auth_key_put(asoc->asoc_shared_key);\r\nsctp_association_put(asoc);\r\n}\r\nstatic void sctp_association_destroy(struct sctp_association *asoc)\r\n{\r\nif (unlikely(!asoc->base.dead)) {\r\nWARN(1, "Attempt to destroy undead association %p!\n", asoc);\r\nreturn;\r\n}\r\nsctp_endpoint_put(asoc->ep);\r\nsock_put(asoc->base.sk);\r\nif (asoc->assoc_id != 0) {\r\nspin_lock_bh(&sctp_assocs_id_lock);\r\nidr_remove(&sctp_assocs_id, asoc->assoc_id);\r\nspin_unlock_bh(&sctp_assocs_id_lock);\r\n}\r\nWARN_ON(atomic_read(&asoc->rmem_alloc));\r\nkfree(asoc);\r\nSCTP_DBG_OBJCNT_DEC(assoc);\r\n}\r\nvoid sctp_assoc_set_primary(struct sctp_association *asoc,\r\nstruct sctp_transport *transport)\r\n{\r\nint changeover = 0;\r\nif (asoc->peer.primary_path != NULL &&\r\nasoc->peer.primary_path != transport)\r\nchangeover = 1 ;\r\nasoc->peer.primary_path = transport;\r\nmemcpy(&asoc->peer.primary_addr, &transport->ipaddr,\r\nsizeof(union sctp_addr));\r\nif ((transport->state == SCTP_ACTIVE) ||\r\n(transport->state == SCTP_UNKNOWN))\r\nasoc->peer.active_path = transport;\r\nif (!asoc->outqueue.outstanding_bytes && !asoc->outqueue.out_qlen)\r\nreturn;\r\nif (transport->cacc.changeover_active)\r\ntransport->cacc.cycling_changeover = changeover;\r\ntransport->cacc.changeover_active = changeover;\r\ntransport->cacc.next_tsn_at_change = asoc->next_tsn;\r\n}\r\nvoid sctp_assoc_rm_peer(struct sctp_association *asoc,\r\nstruct sctp_transport *peer)\r\n{\r\nstruct list_head *pos;\r\nstruct sctp_transport *transport;\r\npr_debug("%s: association:%p addr:%pISpc\n",\r\n__func__, asoc, &peer->ipaddr.sa);\r\nif (asoc->peer.retran_path == peer)\r\nsctp_assoc_update_retran_path(asoc);\r\nlist_del_rcu(&peer->transports);\r\npos = asoc->peer.transport_addr_list.next;\r\ntransport = list_entry(pos, struct sctp_transport, transports);\r\nif (asoc->peer.primary_path == peer)\r\nsctp_assoc_set_primary(asoc, transport);\r\nif (asoc->peer.active_path == peer)\r\nasoc->peer.active_path = transport;\r\nif (asoc->peer.retran_path == peer)\r\nasoc->peer.retran_path = transport;\r\nif (asoc->peer.last_data_from == peer)\r\nasoc->peer.last_data_from = transport;\r\nif (asoc->init_last_sent_to == peer)\r\nasoc->init_last_sent_to = NULL;\r\nif (asoc->shutdown_last_sent_to == peer)\r\nasoc->shutdown_last_sent_to = NULL;\r\nif (asoc->addip_last_asconf &&\r\nasoc->addip_last_asconf->transport == peer)\r\nasoc->addip_last_asconf->transport = NULL;\r\nif (!list_empty(&peer->transmitted)) {\r\nstruct sctp_transport *active = asoc->peer.active_path;\r\nstruct sctp_chunk *ch;\r\nlist_for_each_entry(ch, &peer->transmitted,\r\ntransmitted_list) {\r\nch->transport = NULL;\r\nch->rtt_in_progress = 0;\r\n}\r\nlist_splice_tail_init(&peer->transmitted,\r\n&active->transmitted);\r\nif (!timer_pending(&active->T3_rtx_timer))\r\nif (!mod_timer(&active->T3_rtx_timer,\r\njiffies + active->rto))\r\nsctp_transport_hold(active);\r\n}\r\nasoc->peer.transport_count--;\r\nsctp_transport_free(peer);\r\n}\r\nstruct sctp_transport *sctp_assoc_add_peer(struct sctp_association *asoc,\r\nconst union sctp_addr *addr,\r\nconst gfp_t gfp,\r\nconst int peer_state)\r\n{\r\nstruct net *net = sock_net(asoc->base.sk);\r\nstruct sctp_transport *peer;\r\nstruct sctp_sock *sp;\r\nunsigned short port;\r\nsp = sctp_sk(asoc->base.sk);\r\nport = ntohs(addr->v4.sin_port);\r\npr_debug("%s: association:%p addr:%pISpc state:%d\n", __func__,\r\nasoc, &addr->sa, peer_state);\r\nif (0 == asoc->peer.port)\r\nasoc->peer.port = port;\r\npeer = sctp_assoc_lookup_paddr(asoc, addr);\r\nif (peer) {\r\nif (peer->state == SCTP_UNKNOWN) {\r\npeer->state = SCTP_ACTIVE;\r\n}\r\nreturn peer;\r\n}\r\npeer = sctp_transport_new(net, addr, gfp);\r\nif (!peer)\r\nreturn NULL;\r\nsctp_transport_set_owner(peer, asoc);\r\npeer->hbinterval = asoc->hbinterval;\r\npeer->pathmaxrxt = asoc->pathmaxrxt;\r\npeer->pf_retrans = asoc->pf_retrans;\r\npeer->sackdelay = asoc->sackdelay;\r\npeer->sackfreq = asoc->sackfreq;\r\npeer->param_flags = asoc->param_flags;\r\nsctp_transport_route(peer, NULL, sp);\r\nif (peer->param_flags & SPP_PMTUD_DISABLE) {\r\nif (asoc->pathmtu)\r\npeer->pathmtu = asoc->pathmtu;\r\nelse\r\npeer->pathmtu = SCTP_DEFAULT_MAXSEGMENT;\r\n}\r\nif (asoc->pathmtu)\r\nasoc->pathmtu = min_t(int, peer->pathmtu, asoc->pathmtu);\r\nelse\r\nasoc->pathmtu = peer->pathmtu;\r\npr_debug("%s: association:%p PMTU set to %d\n", __func__, asoc,\r\nasoc->pathmtu);\r\npeer->pmtu_pending = 0;\r\nasoc->frag_point = sctp_frag_point(asoc, asoc->pathmtu);\r\nsctp_packet_init(&peer->packet, peer, asoc->base.bind_addr.port,\r\nasoc->peer.port);\r\npeer->cwnd = min(4*asoc->pathmtu, max_t(__u32, 2*asoc->pathmtu, 4380));\r\npeer->ssthresh = SCTP_DEFAULT_MAXWINDOW;\r\npeer->partial_bytes_acked = 0;\r\npeer->flight_size = 0;\r\npeer->burst_limited = 0;\r\npeer->rto = asoc->rto_initial;\r\nsctp_max_rto(asoc, peer);\r\npeer->state = peer_state;\r\nlist_add_tail_rcu(&peer->transports, &asoc->peer.transport_addr_list);\r\nasoc->peer.transport_count++;\r\nif (!asoc->peer.primary_path) {\r\nsctp_assoc_set_primary(asoc, peer);\r\nasoc->peer.retran_path = peer;\r\n}\r\nif (asoc->peer.active_path == asoc->peer.retran_path &&\r\npeer->state != SCTP_UNCONFIRMED) {\r\nasoc->peer.retran_path = peer;\r\n}\r\nreturn peer;\r\n}\r\nvoid sctp_assoc_del_peer(struct sctp_association *asoc,\r\nconst union sctp_addr *addr)\r\n{\r\nstruct list_head *pos;\r\nstruct list_head *temp;\r\nstruct sctp_transport *transport;\r\nlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\r\ntransport = list_entry(pos, struct sctp_transport, transports);\r\nif (sctp_cmp_addr_exact(addr, &transport->ipaddr)) {\r\nsctp_assoc_rm_peer(asoc, transport);\r\nbreak;\r\n}\r\n}\r\n}\r\nstruct sctp_transport *sctp_assoc_lookup_paddr(\r\nconst struct sctp_association *asoc,\r\nconst union sctp_addr *address)\r\n{\r\nstruct sctp_transport *t;\r\nlist_for_each_entry(t, &asoc->peer.transport_addr_list,\r\ntransports) {\r\nif (sctp_cmp_addr_exact(address, &t->ipaddr))\r\nreturn t;\r\n}\r\nreturn NULL;\r\n}\r\nvoid sctp_assoc_del_nonprimary_peers(struct sctp_association *asoc,\r\nstruct sctp_transport *primary)\r\n{\r\nstruct sctp_transport *temp;\r\nstruct sctp_transport *t;\r\nlist_for_each_entry_safe(t, temp, &asoc->peer.transport_addr_list,\r\ntransports) {\r\nif (t != primary)\r\nsctp_assoc_rm_peer(asoc, t);\r\n}\r\n}\r\nvoid sctp_assoc_control_transport(struct sctp_association *asoc,\r\nstruct sctp_transport *transport,\r\nsctp_transport_cmd_t command,\r\nsctp_sn_error_t error)\r\n{\r\nstruct sctp_ulpevent *event;\r\nstruct sockaddr_storage addr;\r\nint spc_state = 0;\r\nbool ulp_notify = true;\r\nswitch (command) {\r\ncase SCTP_TRANSPORT_UP:\r\nif (SCTP_UNCONFIRMED == transport->state &&\r\nSCTP_HEARTBEAT_SUCCESS == error)\r\nspc_state = SCTP_ADDR_CONFIRMED;\r\nelse\r\nspc_state = SCTP_ADDR_AVAILABLE;\r\nif (transport->state == SCTP_PF) {\r\nulp_notify = false;\r\ntransport->cwnd = asoc->pathmtu;\r\n}\r\ntransport->state = SCTP_ACTIVE;\r\nbreak;\r\ncase SCTP_TRANSPORT_DOWN:\r\nif (transport->state != SCTP_UNCONFIRMED)\r\ntransport->state = SCTP_INACTIVE;\r\nelse {\r\ndst_release(transport->dst);\r\ntransport->dst = NULL;\r\nulp_notify = false;\r\n}\r\nspc_state = SCTP_ADDR_UNREACHABLE;\r\nbreak;\r\ncase SCTP_TRANSPORT_PF:\r\ntransport->state = SCTP_PF;\r\nulp_notify = false;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nif (ulp_notify) {\r\nmemset(&addr, 0, sizeof(struct sockaddr_storage));\r\nmemcpy(&addr, &transport->ipaddr,\r\ntransport->af_specific->sockaddr_len);\r\nevent = sctp_ulpevent_make_peer_addr_change(asoc, &addr,\r\n0, spc_state, error, GFP_ATOMIC);\r\nif (event)\r\nsctp_ulpq_tail_event(&asoc->ulpq, event);\r\n}\r\nsctp_select_active_and_retran_path(asoc);\r\n}\r\nvoid sctp_association_hold(struct sctp_association *asoc)\r\n{\r\natomic_inc(&asoc->base.refcnt);\r\n}\r\nvoid sctp_association_put(struct sctp_association *asoc)\r\n{\r\nif (atomic_dec_and_test(&asoc->base.refcnt))\r\nsctp_association_destroy(asoc);\r\n}\r\n__u32 sctp_association_get_next_tsn(struct sctp_association *asoc)\r\n{\r\n__u32 retval = asoc->next_tsn;\r\nasoc->next_tsn++;\r\nasoc->unack_data++;\r\nreturn retval;\r\n}\r\nint sctp_cmp_addr_exact(const union sctp_addr *ss1,\r\nconst union sctp_addr *ss2)\r\n{\r\nstruct sctp_af *af;\r\naf = sctp_get_af_specific(ss1->sa.sa_family);\r\nif (unlikely(!af))\r\nreturn 0;\r\nreturn af->cmp_addr(ss1, ss2);\r\n}\r\nstruct sctp_chunk *sctp_get_ecne_prepend(struct sctp_association *asoc)\r\n{\r\nif (!asoc->need_ecne)\r\nreturn NULL;\r\nreturn sctp_make_ecne(asoc, asoc->last_ecne_tsn);\r\n}\r\nstruct sctp_transport *sctp_assoc_lookup_tsn(struct sctp_association *asoc,\r\n__u32 tsn)\r\n{\r\nstruct sctp_transport *active;\r\nstruct sctp_transport *match;\r\nstruct sctp_transport *transport;\r\nstruct sctp_chunk *chunk;\r\n__be32 key = htonl(tsn);\r\nmatch = NULL;\r\nactive = asoc->peer.active_path;\r\nlist_for_each_entry(chunk, &active->transmitted,\r\ntransmitted_list) {\r\nif (key == chunk->subh.data_hdr->tsn) {\r\nmatch = active;\r\ngoto out;\r\n}\r\n}\r\nlist_for_each_entry(transport, &asoc->peer.transport_addr_list,\r\ntransports) {\r\nif (transport == active)\r\ncontinue;\r\nlist_for_each_entry(chunk, &transport->transmitted,\r\ntransmitted_list) {\r\nif (key == chunk->subh.data_hdr->tsn) {\r\nmatch = transport;\r\ngoto out;\r\n}\r\n}\r\n}\r\nout:\r\nreturn match;\r\n}\r\nstruct sctp_transport *sctp_assoc_is_match(struct sctp_association *asoc,\r\nstruct net *net,\r\nconst union sctp_addr *laddr,\r\nconst union sctp_addr *paddr)\r\n{\r\nstruct sctp_transport *transport;\r\nif ((htons(asoc->base.bind_addr.port) == laddr->v4.sin_port) &&\r\n(htons(asoc->peer.port) == paddr->v4.sin_port) &&\r\nnet_eq(sock_net(asoc->base.sk), net)) {\r\ntransport = sctp_assoc_lookup_paddr(asoc, paddr);\r\nif (!transport)\r\ngoto out;\r\nif (sctp_bind_addr_match(&asoc->base.bind_addr, laddr,\r\nsctp_sk(asoc->base.sk)))\r\ngoto out;\r\n}\r\ntransport = NULL;\r\nout:\r\nreturn transport;\r\n}\r\nstatic void sctp_assoc_bh_rcv(struct work_struct *work)\r\n{\r\nstruct sctp_association *asoc =\r\ncontainer_of(work, struct sctp_association,\r\nbase.inqueue.immediate);\r\nstruct net *net = sock_net(asoc->base.sk);\r\nstruct sctp_endpoint *ep;\r\nstruct sctp_chunk *chunk;\r\nstruct sctp_inq *inqueue;\r\nint state;\r\nsctp_subtype_t subtype;\r\nint error = 0;\r\nep = asoc->ep;\r\ninqueue = &asoc->base.inqueue;\r\nsctp_association_hold(asoc);\r\nwhile (NULL != (chunk = sctp_inq_pop(inqueue))) {\r\nstate = asoc->state;\r\nsubtype = SCTP_ST_CHUNK(chunk->chunk_hdr->type);\r\nif (sctp_auth_recv_cid(subtype.chunk, asoc) && !chunk->auth)\r\ncontinue;\r\nif (sctp_chunk_is_data(chunk))\r\nasoc->peer.last_data_from = chunk->transport;\r\nelse {\r\nSCTP_INC_STATS(net, SCTP_MIB_INCTRLCHUNKS);\r\nasoc->stats.ictrlchunks++;\r\nif (chunk->chunk_hdr->type == SCTP_CID_SACK)\r\nasoc->stats.isacks++;\r\n}\r\nif (chunk->transport)\r\nchunk->transport->last_time_heard = ktime_get();\r\nerror = sctp_do_sm(net, SCTP_EVENT_T_CHUNK, subtype,\r\nstate, ep, asoc, chunk, GFP_ATOMIC);\r\nif (asoc->base.dead)\r\nbreak;\r\nif (error && chunk)\r\nchunk->pdiscard = 1;\r\n}\r\nsctp_association_put(asoc);\r\n}\r\nvoid sctp_assoc_migrate(struct sctp_association *assoc, struct sock *newsk)\r\n{\r\nstruct sctp_sock *newsp = sctp_sk(newsk);\r\nstruct sock *oldsk = assoc->base.sk;\r\nlist_del_init(&assoc->asocs);\r\nif (sctp_style(oldsk, TCP))\r\noldsk->sk_ack_backlog--;\r\nsctp_endpoint_put(assoc->ep);\r\nsock_put(assoc->base.sk);\r\nassoc->ep = newsp->ep;\r\nsctp_endpoint_hold(assoc->ep);\r\nassoc->base.sk = newsk;\r\nsock_hold(assoc->base.sk);\r\nsctp_endpoint_add_asoc(newsp->ep, assoc);\r\n}\r\nvoid sctp_assoc_update(struct sctp_association *asoc,\r\nstruct sctp_association *new)\r\n{\r\nstruct sctp_transport *trans;\r\nstruct list_head *pos, *temp;\r\nasoc->c = new->c;\r\nasoc->peer.rwnd = new->peer.rwnd;\r\nasoc->peer.sack_needed = new->peer.sack_needed;\r\nasoc->peer.auth_capable = new->peer.auth_capable;\r\nasoc->peer.i = new->peer.i;\r\nsctp_tsnmap_init(&asoc->peer.tsn_map, SCTP_TSN_MAP_INITIAL,\r\nasoc->peer.i.initial_tsn, GFP_ATOMIC);\r\nlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\r\ntrans = list_entry(pos, struct sctp_transport, transports);\r\nif (!sctp_assoc_lookup_paddr(new, &trans->ipaddr)) {\r\nsctp_assoc_rm_peer(asoc, trans);\r\ncontinue;\r\n}\r\nif (asoc->state >= SCTP_STATE_ESTABLISHED)\r\nsctp_transport_reset(trans);\r\n}\r\nif (asoc->state >= SCTP_STATE_ESTABLISHED) {\r\nasoc->next_tsn = new->next_tsn;\r\nasoc->ctsn_ack_point = new->ctsn_ack_point;\r\nasoc->adv_peer_ack_point = new->adv_peer_ack_point;\r\nsctp_ssnmap_clear(asoc->ssnmap);\r\nsctp_ulpq_flush(&asoc->ulpq);\r\nasoc->overall_error_count = 0;\r\n} else {\r\nlist_for_each_entry(trans, &new->peer.transport_addr_list,\r\ntransports) {\r\nif (!sctp_assoc_lookup_paddr(asoc, &trans->ipaddr))\r\nsctp_assoc_add_peer(asoc, &trans->ipaddr,\r\nGFP_ATOMIC, trans->state);\r\n}\r\nasoc->ctsn_ack_point = asoc->next_tsn - 1;\r\nasoc->adv_peer_ack_point = asoc->ctsn_ack_point;\r\nif (!asoc->ssnmap) {\r\nasoc->ssnmap = new->ssnmap;\r\nnew->ssnmap = NULL;\r\n}\r\nif (!asoc->assoc_id) {\r\nsctp_assoc_set_id(asoc, GFP_ATOMIC);\r\n}\r\n}\r\nkfree(asoc->peer.peer_random);\r\nasoc->peer.peer_random = new->peer.peer_random;\r\nnew->peer.peer_random = NULL;\r\nkfree(asoc->peer.peer_chunks);\r\nasoc->peer.peer_chunks = new->peer.peer_chunks;\r\nnew->peer.peer_chunks = NULL;\r\nkfree(asoc->peer.peer_hmacs);\r\nasoc->peer.peer_hmacs = new->peer.peer_hmacs;\r\nnew->peer.peer_hmacs = NULL;\r\nsctp_auth_asoc_init_active_key(asoc, GFP_ATOMIC);\r\n}\r\nstatic u8 sctp_trans_score(const struct sctp_transport *trans)\r\n{\r\nreturn sctp_trans_state_to_prio_map[trans->state];\r\n}\r\nstatic struct sctp_transport *sctp_trans_elect_tie(struct sctp_transport *trans1,\r\nstruct sctp_transport *trans2)\r\n{\r\nif (trans1->error_count > trans2->error_count) {\r\nreturn trans2;\r\n} else if (trans1->error_count == trans2->error_count &&\r\nktime_after(trans2->last_time_heard,\r\ntrans1->last_time_heard)) {\r\nreturn trans2;\r\n} else {\r\nreturn trans1;\r\n}\r\n}\r\nstatic struct sctp_transport *sctp_trans_elect_best(struct sctp_transport *curr,\r\nstruct sctp_transport *best)\r\n{\r\nu8 score_curr, score_best;\r\nif (best == NULL || curr == best)\r\nreturn curr;\r\nscore_curr = sctp_trans_score(curr);\r\nscore_best = sctp_trans_score(best);\r\nif (score_curr > score_best)\r\nreturn curr;\r\nelse if (score_curr == score_best)\r\nreturn sctp_trans_elect_tie(curr, best);\r\nelse\r\nreturn best;\r\n}\r\nvoid sctp_assoc_update_retran_path(struct sctp_association *asoc)\r\n{\r\nstruct sctp_transport *trans = asoc->peer.retran_path;\r\nstruct sctp_transport *trans_next = NULL;\r\nif (asoc->peer.transport_count == 1)\r\nreturn;\r\nif (asoc->peer.active_path == asoc->peer.retran_path &&\r\nasoc->peer.active_path->state == SCTP_ACTIVE)\r\nreturn;\r\nfor (trans = list_next_entry(trans, transports); 1;\r\ntrans = list_next_entry(trans, transports)) {\r\nif (&trans->transports == &asoc->peer.transport_addr_list)\r\ncontinue;\r\nif (trans->state == SCTP_UNCONFIRMED)\r\ncontinue;\r\ntrans_next = sctp_trans_elect_best(trans, trans_next);\r\nif (trans_next->state == SCTP_ACTIVE)\r\nbreak;\r\nif (trans == asoc->peer.retran_path)\r\nbreak;\r\n}\r\nasoc->peer.retran_path = trans_next;\r\npr_debug("%s: association:%p updated new path to addr:%pISpc\n",\r\n__func__, asoc, &asoc->peer.retran_path->ipaddr.sa);\r\n}\r\nstatic void sctp_select_active_and_retran_path(struct sctp_association *asoc)\r\n{\r\nstruct sctp_transport *trans, *trans_pri = NULL, *trans_sec = NULL;\r\nstruct sctp_transport *trans_pf = NULL;\r\nlist_for_each_entry(trans, &asoc->peer.transport_addr_list,\r\ntransports) {\r\nif (trans->state == SCTP_INACTIVE ||\r\ntrans->state == SCTP_UNCONFIRMED)\r\ncontinue;\r\nif (trans->state == SCTP_PF) {\r\ntrans_pf = sctp_trans_elect_best(trans, trans_pf);\r\ncontinue;\r\n}\r\nif (trans_pri == NULL ||\r\nktime_after(trans->last_time_heard,\r\ntrans_pri->last_time_heard)) {\r\ntrans_sec = trans_pri;\r\ntrans_pri = trans;\r\n} else if (trans_sec == NULL ||\r\nktime_after(trans->last_time_heard,\r\ntrans_sec->last_time_heard)) {\r\ntrans_sec = trans;\r\n}\r\n}\r\nif ((asoc->peer.primary_path->state == SCTP_ACTIVE ||\r\nasoc->peer.primary_path->state == SCTP_UNKNOWN) &&\r\nasoc->peer.primary_path != trans_pri) {\r\ntrans_sec = trans_pri;\r\ntrans_pri = asoc->peer.primary_path;\r\n}\r\nif (trans_sec == NULL)\r\ntrans_sec = trans_pri;\r\nif (trans_pri == NULL) {\r\ntrans_pri = sctp_trans_elect_best(asoc->peer.active_path, trans_pf);\r\ntrans_sec = trans_pri;\r\n}\r\nasoc->peer.active_path = trans_pri;\r\nasoc->peer.retran_path = trans_sec;\r\n}\r\nstruct sctp_transport *\r\nsctp_assoc_choose_alter_transport(struct sctp_association *asoc,\r\nstruct sctp_transport *last_sent_to)\r\n{\r\nif (last_sent_to == NULL) {\r\nreturn asoc->peer.active_path;\r\n} else {\r\nif (last_sent_to == asoc->peer.retran_path)\r\nsctp_assoc_update_retran_path(asoc);\r\nreturn asoc->peer.retran_path;\r\n}\r\n}\r\nvoid sctp_assoc_sync_pmtu(struct sock *sk, struct sctp_association *asoc)\r\n{\r\nstruct sctp_transport *t;\r\n__u32 pmtu = 0;\r\nif (!asoc)\r\nreturn;\r\nlist_for_each_entry(t, &asoc->peer.transport_addr_list,\r\ntransports) {\r\nif (t->pmtu_pending && t->dst) {\r\nsctp_transport_update_pmtu(sk, t, dst_mtu(t->dst));\r\nt->pmtu_pending = 0;\r\n}\r\nif (!pmtu || (t->pathmtu < pmtu))\r\npmtu = t->pathmtu;\r\n}\r\nif (pmtu) {\r\nasoc->pathmtu = pmtu;\r\nasoc->frag_point = sctp_frag_point(asoc, pmtu);\r\n}\r\npr_debug("%s: asoc:%p, pmtu:%d, frag_point:%d\n", __func__, asoc,\r\nasoc->pathmtu, asoc->frag_point);\r\n}\r\nstatic inline bool sctp_peer_needs_update(struct sctp_association *asoc)\r\n{\r\nstruct net *net = sock_net(asoc->base.sk);\r\nswitch (asoc->state) {\r\ncase SCTP_STATE_ESTABLISHED:\r\ncase SCTP_STATE_SHUTDOWN_PENDING:\r\ncase SCTP_STATE_SHUTDOWN_RECEIVED:\r\ncase SCTP_STATE_SHUTDOWN_SENT:\r\nif ((asoc->rwnd > asoc->a_rwnd) &&\r\n((asoc->rwnd - asoc->a_rwnd) >= max_t(__u32,\r\n(asoc->base.sk->sk_rcvbuf >> net->sctp.rwnd_upd_shift),\r\nasoc->pathmtu)))\r\nreturn true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn false;\r\n}\r\nvoid sctp_assoc_rwnd_increase(struct sctp_association *asoc, unsigned int len)\r\n{\r\nstruct sctp_chunk *sack;\r\nstruct timer_list *timer;\r\nif (asoc->rwnd_over) {\r\nif (asoc->rwnd_over >= len) {\r\nasoc->rwnd_over -= len;\r\n} else {\r\nasoc->rwnd += (len - asoc->rwnd_over);\r\nasoc->rwnd_over = 0;\r\n}\r\n} else {\r\nasoc->rwnd += len;\r\n}\r\nif (asoc->rwnd_press && asoc->rwnd >= asoc->rwnd_press) {\r\nint change = min(asoc->pathmtu, asoc->rwnd_press);\r\nasoc->rwnd += change;\r\nasoc->rwnd_press -= change;\r\n}\r\npr_debug("%s: asoc:%p rwnd increased by %d to (%u, %u) - %u\n",\r\n__func__, asoc, len, asoc->rwnd, asoc->rwnd_over,\r\nasoc->a_rwnd);\r\nif (sctp_peer_needs_update(asoc)) {\r\nasoc->a_rwnd = asoc->rwnd;\r\npr_debug("%s: sending window update SACK- asoc:%p rwnd:%u "\r\n"a_rwnd:%u\n", __func__, asoc, asoc->rwnd,\r\nasoc->a_rwnd);\r\nsack = sctp_make_sack(asoc);\r\nif (!sack)\r\nreturn;\r\nasoc->peer.sack_needed = 0;\r\nsctp_outq_tail(&asoc->outqueue, sack);\r\ntimer = &asoc->timers[SCTP_EVENT_TIMEOUT_SACK];\r\nif (del_timer(timer))\r\nsctp_association_put(asoc);\r\n}\r\n}\r\nvoid sctp_assoc_rwnd_decrease(struct sctp_association *asoc, unsigned int len)\r\n{\r\nint rx_count;\r\nint over = 0;\r\nif (unlikely(!asoc->rwnd || asoc->rwnd_over))\r\npr_debug("%s: association:%p has asoc->rwnd:%u, "\r\n"asoc->rwnd_over:%u!\n", __func__, asoc,\r\nasoc->rwnd, asoc->rwnd_over);\r\nif (asoc->ep->rcvbuf_policy)\r\nrx_count = atomic_read(&asoc->rmem_alloc);\r\nelse\r\nrx_count = atomic_read(&asoc->base.sk->sk_rmem_alloc);\r\nif (rx_count >= asoc->base.sk->sk_rcvbuf)\r\nover = 1;\r\nif (asoc->rwnd >= len) {\r\nasoc->rwnd -= len;\r\nif (over) {\r\nasoc->rwnd_press += asoc->rwnd;\r\nasoc->rwnd = 0;\r\n}\r\n} else {\r\nasoc->rwnd_over = len - asoc->rwnd;\r\nasoc->rwnd = 0;\r\n}\r\npr_debug("%s: asoc:%p rwnd decreased by %d to (%u, %u, %u)\n",\r\n__func__, asoc, len, asoc->rwnd, asoc->rwnd_over,\r\nasoc->rwnd_press);\r\n}\r\nint sctp_assoc_set_bind_addr_from_ep(struct sctp_association *asoc,\r\nsctp_scope_t scope, gfp_t gfp)\r\n{\r\nint flags;\r\nflags = (PF_INET6 == asoc->base.sk->sk_family) ? SCTP_ADDR6_ALLOWED : 0;\r\nif (asoc->peer.ipv4_address)\r\nflags |= SCTP_ADDR4_PEERSUPP;\r\nif (asoc->peer.ipv6_address)\r\nflags |= SCTP_ADDR6_PEERSUPP;\r\nreturn sctp_bind_addr_copy(sock_net(asoc->base.sk),\r\n&asoc->base.bind_addr,\r\n&asoc->ep->base.bind_addr,\r\nscope, gfp, flags);\r\n}\r\nint sctp_assoc_set_bind_addr_from_cookie(struct sctp_association *asoc,\r\nstruct sctp_cookie *cookie,\r\ngfp_t gfp)\r\n{\r\nint var_size2 = ntohs(cookie->peer_init->chunk_hdr.length);\r\nint var_size3 = cookie->raw_addr_list_len;\r\n__u8 *raw = (__u8 *)cookie->peer_init + var_size2;\r\nreturn sctp_raw_to_bind_addrs(&asoc->base.bind_addr, raw, var_size3,\r\nasoc->ep->base.bind_addr.port, gfp);\r\n}\r\nint sctp_assoc_lookup_laddr(struct sctp_association *asoc,\r\nconst union sctp_addr *laddr)\r\n{\r\nint found = 0;\r\nif ((asoc->base.bind_addr.port == ntohs(laddr->v4.sin_port)) &&\r\nsctp_bind_addr_match(&asoc->base.bind_addr, laddr,\r\nsctp_sk(asoc->base.sk)))\r\nfound = 1;\r\nreturn found;\r\n}\r\nint sctp_assoc_set_id(struct sctp_association *asoc, gfp_t gfp)\r\n{\r\nbool preload = !!(gfp & __GFP_WAIT);\r\nint ret;\r\nif (asoc->assoc_id)\r\nreturn 0;\r\nif (preload)\r\nidr_preload(gfp);\r\nspin_lock_bh(&sctp_assocs_id_lock);\r\nret = idr_alloc_cyclic(&sctp_assocs_id, asoc, 1, 0, GFP_NOWAIT);\r\nspin_unlock_bh(&sctp_assocs_id_lock);\r\nif (preload)\r\nidr_preload_end();\r\nif (ret < 0)\r\nreturn ret;\r\nasoc->assoc_id = (sctp_assoc_t)ret;\r\nreturn 0;\r\n}\r\nstatic void sctp_assoc_free_asconf_queue(struct sctp_association *asoc)\r\n{\r\nstruct sctp_chunk *asconf;\r\nstruct sctp_chunk *tmp;\r\nlist_for_each_entry_safe(asconf, tmp, &asoc->addip_chunk_list, list) {\r\nlist_del_init(&asconf->list);\r\nsctp_chunk_free(asconf);\r\n}\r\n}\r\nstatic void sctp_assoc_free_asconf_acks(struct sctp_association *asoc)\r\n{\r\nstruct sctp_chunk *ack;\r\nstruct sctp_chunk *tmp;\r\nlist_for_each_entry_safe(ack, tmp, &asoc->asconf_ack_list,\r\ntransmitted_list) {\r\nlist_del_init(&ack->transmitted_list);\r\nsctp_chunk_free(ack);\r\n}\r\n}\r\nvoid sctp_assoc_clean_asconf_ack_cache(const struct sctp_association *asoc)\r\n{\r\nstruct sctp_chunk *ack;\r\nstruct sctp_chunk *tmp;\r\nlist_for_each_entry_safe(ack, tmp, &asoc->asconf_ack_list,\r\ntransmitted_list) {\r\nif (ack->subh.addip_hdr->serial ==\r\nhtonl(asoc->peer.addip_serial))\r\nbreak;\r\nlist_del_init(&ack->transmitted_list);\r\nsctp_chunk_free(ack);\r\n}\r\n}\r\nstruct sctp_chunk *sctp_assoc_lookup_asconf_ack(\r\nconst struct sctp_association *asoc,\r\n__be32 serial)\r\n{\r\nstruct sctp_chunk *ack;\r\nlist_for_each_entry(ack, &asoc->asconf_ack_list, transmitted_list) {\r\nif (sctp_chunk_pending(ack))\r\ncontinue;\r\nif (ack->subh.addip_hdr->serial == serial) {\r\nsctp_chunk_hold(ack);\r\nreturn ack;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nvoid sctp_asconf_queue_teardown(struct sctp_association *asoc)\r\n{\r\nsctp_assoc_free_asconf_acks(asoc);\r\nsctp_assoc_free_asconf_queue(asoc);\r\nif (asoc->addip_last_asconf)\r\nsctp_chunk_free(asoc->addip_last_asconf);\r\n}
