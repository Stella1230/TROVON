static int pkcs7_digest(struct pkcs7_message *pkcs7,\r\nstruct pkcs7_signed_info *sinfo)\r\n{\r\nstruct crypto_shash *tfm;\r\nstruct shash_desc *desc;\r\nsize_t digest_size, desc_size;\r\nvoid *digest;\r\nint ret;\r\nkenter(",%u,%u", sinfo->index, sinfo->sig.pkey_hash_algo);\r\nif (sinfo->sig.pkey_hash_algo >= PKEY_HASH__LAST ||\r\n!hash_algo_name[sinfo->sig.pkey_hash_algo])\r\nreturn -ENOPKG;\r\ntfm = crypto_alloc_shash(hash_algo_name[sinfo->sig.pkey_hash_algo],\r\n0, 0);\r\nif (IS_ERR(tfm))\r\nreturn (PTR_ERR(tfm) == -ENOENT) ? -ENOPKG : PTR_ERR(tfm);\r\ndesc_size = crypto_shash_descsize(tfm) + sizeof(*desc);\r\nsinfo->sig.digest_size = digest_size = crypto_shash_digestsize(tfm);\r\nret = -ENOMEM;\r\ndigest = kzalloc(digest_size + desc_size, GFP_KERNEL);\r\nif (!digest)\r\ngoto error_no_desc;\r\ndesc = digest + digest_size;\r\ndesc->tfm = tfm;\r\ndesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\r\nret = crypto_shash_init(desc);\r\nif (ret < 0)\r\ngoto error;\r\nret = crypto_shash_finup(desc, pkcs7->data, pkcs7->data_len, digest);\r\nif (ret < 0)\r\ngoto error;\r\npr_devel("MsgDigest = [%*ph]\n", 8, digest);\r\nif (sinfo->msgdigest) {\r\nu8 tag;\r\nif (sinfo->msgdigest_len != sinfo->sig.digest_size) {\r\npr_debug("Sig %u: Invalid digest size (%u)\n",\r\nsinfo->index, sinfo->msgdigest_len);\r\nret = -EBADMSG;\r\ngoto error;\r\n}\r\nif (memcmp(digest, sinfo->msgdigest, sinfo->msgdigest_len) != 0) {\r\npr_debug("Sig %u: Message digest doesn't match\n",\r\nsinfo->index);\r\nret = -EKEYREJECTED;\r\ngoto error;\r\n}\r\nmemset(digest, 0, sinfo->sig.digest_size);\r\nret = crypto_shash_init(desc);\r\nif (ret < 0)\r\ngoto error;\r\ntag = ASN1_CONS_BIT | ASN1_SET;\r\nret = crypto_shash_update(desc, &tag, 1);\r\nif (ret < 0)\r\ngoto error;\r\nret = crypto_shash_finup(desc, sinfo->authattrs,\r\nsinfo->authattrs_len, digest);\r\nif (ret < 0)\r\ngoto error;\r\npr_devel("AADigest = [%*ph]\n", 8, digest);\r\n}\r\nsinfo->sig.digest = digest;\r\ndigest = NULL;\r\nerror:\r\nkfree(digest);\r\nerror_no_desc:\r\ncrypto_free_shash(tfm);\r\nkleave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstatic int pkcs7_find_key(struct pkcs7_message *pkcs7,\r\nstruct pkcs7_signed_info *sinfo)\r\n{\r\nstruct x509_certificate *x509;\r\nunsigned certix = 1;\r\nkenter("%u", sinfo->index);\r\nfor (x509 = pkcs7->certs; x509; x509 = x509->next, certix++) {\r\nif (!asymmetric_key_id_same(x509->id, sinfo->signing_cert_id))\r\ncontinue;\r\npr_devel("Sig %u: Found cert serial match X.509[%u]\n",\r\nsinfo->index, certix);\r\nif (x509->pub->pkey_algo != sinfo->sig.pkey_algo) {\r\npr_warn("Sig %u: X.509 algo and PKCS#7 sig algo don't match\n",\r\nsinfo->index);\r\ncontinue;\r\n}\r\nsinfo->signer = x509;\r\nreturn 0;\r\n}\r\npr_debug("Sig %u: Issuing X.509 cert not found (#%*phN)\n",\r\nsinfo->index,\r\nsinfo->signing_cert_id->len, sinfo->signing_cert_id->data);\r\nreturn 0;\r\n}\r\nstatic int pkcs7_verify_sig_chain(struct pkcs7_message *pkcs7,\r\nstruct pkcs7_signed_info *sinfo)\r\n{\r\nstruct x509_certificate *x509 = sinfo->signer, *p;\r\nint ret;\r\nkenter("");\r\nfor (p = pkcs7->certs; p; p = p->next)\r\np->seen = false;\r\nfor (;;) {\r\npr_debug("verify %s: %*phN\n",\r\nx509->subject,\r\nx509->raw_serial_size, x509->raw_serial);\r\nx509->seen = true;\r\nret = x509_get_sig_params(x509);\r\nif (ret < 0)\r\ngoto maybe_missing_crypto_in_x509;\r\npr_debug("- issuer %s\n", x509->issuer);\r\nif (x509->authority)\r\npr_debug("- authkeyid %*phN\n",\r\nx509->authority->len, x509->authority->data);\r\nif (!x509->authority ||\r\nstrcmp(x509->subject, x509->issuer) == 0) {\r\npr_debug("- no auth?\n");\r\nif (x509->raw_subject_size != x509->raw_issuer_size ||\r\nmemcmp(x509->raw_subject, x509->raw_issuer,\r\nx509->raw_issuer_size) != 0)\r\nreturn 0;\r\nret = x509_check_signature(x509->pub, x509);\r\nif (ret < 0)\r\ngoto maybe_missing_crypto_in_x509;\r\nx509->signer = x509;\r\npr_debug("- self-signed\n");\r\nreturn 0;\r\n}\r\npr_debug("- want %*phN\n",\r\nx509->authority->len, x509->authority->data);\r\nfor (p = pkcs7->certs; p; p = p->next) {\r\nif (!p->skid)\r\ncontinue;\r\npr_debug("- cmp [%u] %*phN\n",\r\np->index, p->skid->len, p->skid->data);\r\nif (asymmetric_key_id_same(p->skid, x509->authority))\r\ngoto found_issuer;\r\n}\r\npr_debug("- top\n");\r\nreturn 0;\r\nfound_issuer:\r\npr_debug("- subject %s\n", p->subject);\r\nif (p->seen) {\r\npr_warn("Sig %u: X.509 chain contains loop\n",\r\nsinfo->index);\r\nreturn 0;\r\n}\r\nret = x509_check_signature(p->pub, x509);\r\nif (ret < 0)\r\nreturn ret;\r\nx509->signer = p;\r\nif (x509 == p) {\r\npr_debug("- self-signed\n");\r\nreturn 0;\r\n}\r\nx509 = p;\r\nmight_sleep();\r\n}\r\nmaybe_missing_crypto_in_x509:\r\nif (ret == -ENOPKG)\r\nreturn 0;\r\nreturn ret;\r\n}\r\nstatic int pkcs7_verify_one(struct pkcs7_message *pkcs7,\r\nstruct pkcs7_signed_info *sinfo)\r\n{\r\nint ret;\r\nkenter(",%u", sinfo->index);\r\nret = pkcs7_digest(pkcs7, sinfo);\r\nif (ret < 0)\r\nreturn ret;\r\nret = pkcs7_find_key(pkcs7, sinfo);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!sinfo->signer)\r\nreturn 0;\r\npr_devel("Using X.509[%u] for sig %u\n",\r\nsinfo->signer->index, sinfo->index);\r\nret = public_key_verify_signature(sinfo->signer->pub, &sinfo->sig);\r\nif (ret < 0)\r\nreturn ret;\r\npr_devel("Verified signature %u\n", sinfo->index);\r\nreturn pkcs7_verify_sig_chain(pkcs7, sinfo);\r\n}\r\nint pkcs7_verify(struct pkcs7_message *pkcs7)\r\n{\r\nstruct pkcs7_signed_info *sinfo;\r\nstruct x509_certificate *x509;\r\nint enopkg = -ENOPKG;\r\nint ret, n;\r\nkenter("");\r\nfor (n = 0, x509 = pkcs7->certs; x509; x509 = x509->next, n++) {\r\nret = x509_get_sig_params(x509);\r\nif (ret < 0)\r\nreturn ret;\r\npr_debug("X.509[%u] %*phN\n",\r\nn, x509->authority->len, x509->authority->data);\r\n}\r\nfor (sinfo = pkcs7->signed_infos; sinfo; sinfo = sinfo->next) {\r\nret = pkcs7_verify_one(pkcs7, sinfo);\r\nif (ret < 0) {\r\nif (ret == -ENOPKG) {\r\nsinfo->unsupported_crypto = true;\r\ncontinue;\r\n}\r\nkleave(" = %d", ret);\r\nreturn ret;\r\n}\r\nenopkg = 0;\r\n}\r\nkleave(" = %d", enopkg);\r\nreturn enopkg;\r\n}
