static int ntrig_version_string(unsigned char *raw, char *buf)\r\n{\r\n__u8 a = (raw[1] & 0x0e) >> 1;\r\n__u8 b = (raw[0] & 0x3c) >> 2;\r\n__u8 c = ((raw[0] & 0x03) << 3) | ((raw[3] & 0xe0) >> 5);\r\n__u8 d = ((raw[3] & 0x07) << 3) | ((raw[2] & 0xe0) >> 5);\r\n__u8 e = raw[2] & 0x07;\r\nreturn sprintf(buf, "%u.%u.%u.%u.%u", a, b, c, d, e);\r\n}\r\nstatic inline int ntrig_get_mode(struct hid_device *hdev)\r\n{\r\nstruct hid_report *report = hdev->report_enum[HID_FEATURE_REPORT].\r\nreport_id_hash[0x0d];\r\nif (!report || report->maxfield < 1 ||\r\nreport->field[0]->report_count < 1)\r\nreturn -EINVAL;\r\nhid_hw_request(hdev, report, HID_REQ_GET_REPORT);\r\nhid_hw_wait(hdev);\r\nreturn (int)report->field[0]->value[0];\r\n}\r\nstatic inline void ntrig_set_mode(struct hid_device *hdev, const int mode)\r\n{\r\nstruct hid_report *report;\r\n__u8 mode_commands[4] = { 0xe, 0xf, 0x1b, 0x10 };\r\nif (mode < 0 || mode > 3)\r\nreturn;\r\nreport = hdev->report_enum[HID_FEATURE_REPORT].\r\nreport_id_hash[mode_commands[mode]];\r\nif (!report)\r\nreturn;\r\nhid_hw_request(hdev, report, HID_REQ_GET_REPORT);\r\n}\r\nstatic void ntrig_report_version(struct hid_device *hdev)\r\n{\r\nint ret;\r\nchar buf[20];\r\nstruct usb_device *usb_dev = hid_to_usb_dev(hdev);\r\nunsigned char *data = kmalloc(8, GFP_KERNEL);\r\nif (!data)\r\ngoto err_free;\r\nret = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0),\r\nUSB_REQ_CLEAR_FEATURE,\r\nUSB_TYPE_CLASS | USB_RECIP_INTERFACE |\r\nUSB_DIR_IN,\r\n0x30c, 1, data, 8,\r\nUSB_CTRL_SET_TIMEOUT);\r\nif (ret == 8) {\r\nret = ntrig_version_string(&data[2], buf);\r\nhid_info(hdev, "Firmware version: %s (%02x%02x %02x%02x)\n",\r\nbuf, data[2], data[3], data[4], data[5]);\r\n}\r\nerr_free:\r\nkfree(data);\r\n}\r\nstatic ssize_t show_phys_width(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct ntrig_data *nd = hid_get_drvdata(hdev);\r\nreturn sprintf(buf, "%d\n", nd->sensor_physical_width);\r\n}\r\nstatic ssize_t show_phys_height(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct ntrig_data *nd = hid_get_drvdata(hdev);\r\nreturn sprintf(buf, "%d\n", nd->sensor_physical_height);\r\n}\r\nstatic ssize_t show_log_width(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct ntrig_data *nd = hid_get_drvdata(hdev);\r\nreturn sprintf(buf, "%d\n", nd->sensor_logical_width);\r\n}\r\nstatic ssize_t show_log_height(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct ntrig_data *nd = hid_get_drvdata(hdev);\r\nreturn sprintf(buf, "%d\n", nd->sensor_logical_height);\r\n}\r\nstatic ssize_t show_min_width(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct ntrig_data *nd = hid_get_drvdata(hdev);\r\nreturn sprintf(buf, "%d\n", nd->min_width *\r\nnd->sensor_physical_width /\r\nnd->sensor_logical_width);\r\n}\r\nstatic ssize_t set_min_width(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct ntrig_data *nd = hid_get_drvdata(hdev);\r\nunsigned long val;\r\nif (kstrtoul(buf, 0, &val))\r\nreturn -EINVAL;\r\nif (val > nd->sensor_physical_width)\r\nreturn -EINVAL;\r\nnd->min_width = val * nd->sensor_logical_width /\r\nnd->sensor_physical_width;\r\nreturn count;\r\n}\r\nstatic ssize_t show_min_height(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct ntrig_data *nd = hid_get_drvdata(hdev);\r\nreturn sprintf(buf, "%d\n", nd->min_height *\r\nnd->sensor_physical_height /\r\nnd->sensor_logical_height);\r\n}\r\nstatic ssize_t set_min_height(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct ntrig_data *nd = hid_get_drvdata(hdev);\r\nunsigned long val;\r\nif (kstrtoul(buf, 0, &val))\r\nreturn -EINVAL;\r\nif (val > nd->sensor_physical_height)\r\nreturn -EINVAL;\r\nnd->min_height = val * nd->sensor_logical_height /\r\nnd->sensor_physical_height;\r\nreturn count;\r\n}\r\nstatic ssize_t show_activate_slack(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct ntrig_data *nd = hid_get_drvdata(hdev);\r\nreturn sprintf(buf, "%d\n", nd->activate_slack);\r\n}\r\nstatic ssize_t set_activate_slack(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct ntrig_data *nd = hid_get_drvdata(hdev);\r\nunsigned long val;\r\nif (kstrtoul(buf, 0, &val))\r\nreturn -EINVAL;\r\nif (val > 0x7f)\r\nreturn -EINVAL;\r\nnd->activate_slack = val;\r\nreturn count;\r\n}\r\nstatic ssize_t show_activation_width(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct ntrig_data *nd = hid_get_drvdata(hdev);\r\nreturn sprintf(buf, "%d\n", nd->activation_width *\r\nnd->sensor_physical_width /\r\nnd->sensor_logical_width);\r\n}\r\nstatic ssize_t set_activation_width(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct ntrig_data *nd = hid_get_drvdata(hdev);\r\nunsigned long val;\r\nif (kstrtoul(buf, 0, &val))\r\nreturn -EINVAL;\r\nif (val > nd->sensor_physical_width)\r\nreturn -EINVAL;\r\nnd->activation_width = val * nd->sensor_logical_width /\r\nnd->sensor_physical_width;\r\nreturn count;\r\n}\r\nstatic ssize_t show_activation_height(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct ntrig_data *nd = hid_get_drvdata(hdev);\r\nreturn sprintf(buf, "%d\n", nd->activation_height *\r\nnd->sensor_physical_height /\r\nnd->sensor_logical_height);\r\n}\r\nstatic ssize_t set_activation_height(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct ntrig_data *nd = hid_get_drvdata(hdev);\r\nunsigned long val;\r\nif (kstrtoul(buf, 0, &val))\r\nreturn -EINVAL;\r\nif (val > nd->sensor_physical_height)\r\nreturn -EINVAL;\r\nnd->activation_height = val * nd->sensor_logical_height /\r\nnd->sensor_physical_height;\r\nreturn count;\r\n}\r\nstatic ssize_t show_deactivate_slack(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct ntrig_data *nd = hid_get_drvdata(hdev);\r\nreturn sprintf(buf, "%d\n", -nd->deactivate_slack);\r\n}\r\nstatic ssize_t set_deactivate_slack(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct ntrig_data *nd = hid_get_drvdata(hdev);\r\nunsigned long val;\r\nif (kstrtoul(buf, 0, &val))\r\nreturn -EINVAL;\r\nif (val > 7)\r\nreturn -EINVAL;\r\nnd->deactivate_slack = -val;\r\nreturn count;\r\n}\r\nstatic int ntrig_input_mapping(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nstruct ntrig_data *nd = hid_get_drvdata(hdev);\r\nif (field->physical)\r\nreturn 0;\r\nswitch (usage->hid & HID_USAGE_PAGE) {\r\ncase HID_UP_GENDESK:\r\nswitch (usage->hid) {\r\ncase HID_GD_X:\r\nhid_map_usage(hi, usage, bit, max,\r\nEV_ABS, ABS_MT_POSITION_X);\r\ninput_set_abs_params(hi->input, ABS_X,\r\nfield->logical_minimum,\r\nfield->logical_maximum, 0, 0);\r\nif (!nd->sensor_logical_width) {\r\nnd->sensor_logical_width =\r\nfield->logical_maximum -\r\nfield->logical_minimum;\r\nnd->sensor_physical_width =\r\nfield->physical_maximum -\r\nfield->physical_minimum;\r\nnd->activation_width = activation_width *\r\nnd->sensor_logical_width /\r\nnd->sensor_physical_width;\r\nnd->min_width = min_width *\r\nnd->sensor_logical_width /\r\nnd->sensor_physical_width;\r\n}\r\nreturn 1;\r\ncase HID_GD_Y:\r\nhid_map_usage(hi, usage, bit, max,\r\nEV_ABS, ABS_MT_POSITION_Y);\r\ninput_set_abs_params(hi->input, ABS_Y,\r\nfield->logical_minimum,\r\nfield->logical_maximum, 0, 0);\r\nif (!nd->sensor_logical_height) {\r\nnd->sensor_logical_height =\r\nfield->logical_maximum -\r\nfield->logical_minimum;\r\nnd->sensor_physical_height =\r\nfield->physical_maximum -\r\nfield->physical_minimum;\r\nnd->activation_height = activation_height *\r\nnd->sensor_logical_height /\r\nnd->sensor_physical_height;\r\nnd->min_height = min_height *\r\nnd->sensor_logical_height /\r\nnd->sensor_physical_height;\r\n}\r\nreturn 1;\r\n}\r\nreturn 0;\r\ncase HID_UP_DIGITIZER:\r\nswitch (usage->hid) {\r\ncase HID_DG_CONTACTID:\r\ncase HID_DG_INPUTMODE:\r\ncase HID_DG_DEVICEINDEX:\r\ncase HID_DG_CONTACTMAX:\r\nreturn -1;\r\ncase HID_DG_WIDTH:\r\nhid_map_usage(hi, usage, bit, max,\r\nEV_ABS, ABS_MT_TOUCH_MAJOR);\r\nreturn 1;\r\ncase HID_DG_HEIGHT:\r\nhid_map_usage(hi, usage, bit, max,\r\nEV_ABS, ABS_MT_TOUCH_MINOR);\r\ninput_set_abs_params(hi->input, ABS_MT_ORIENTATION,\r\n0, 1, 0, 0);\r\nreturn 1;\r\n}\r\nreturn 0;\r\ncase 0xff000000:\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ntrig_input_mapped(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nif (field->physical)\r\nreturn 0;\r\nif (usage->type == EV_KEY || usage->type == EV_REL\r\n|| usage->type == EV_ABS)\r\nclear_bit(usage->code, *bit);\r\nreturn 0;\r\n}\r\nstatic int ntrig_event (struct hid_device *hid, struct hid_field *field,\r\nstruct hid_usage *usage, __s32 value)\r\n{\r\nstruct ntrig_data *nd = hid_get_drvdata(hid);\r\nstruct input_dev *input;\r\nif (!(hid->claimed & HID_CLAIMED_INPUT))\r\ngoto not_claimed_input;\r\nif(!(field->hidinput && field->hidinput->input))\r\nreturn -EINVAL;\r\ninput = field->hidinput->input;\r\nif (field->application == HID_DG_PEN)\r\nreturn 0;\r\nswitch (usage->hid) {\r\ncase 0xff000001:\r\nnd->reading_mt = 1;\r\nnd->first_contact_touch = 0;\r\nbreak;\r\ncase HID_DG_TIPSWITCH:\r\nnd->tipswitch = value;\r\nreturn 1;\r\ncase HID_DG_CONFIDENCE:\r\nnd->confidence = value;\r\nbreak;\r\ncase HID_GD_X:\r\nnd->x = value;\r\nnd->mt_foot_count = 0;\r\nbreak;\r\ncase HID_GD_Y:\r\nnd->y = value;\r\nbreak;\r\ncase HID_DG_CONTACTID:\r\nnd->id = value;\r\nbreak;\r\ncase HID_DG_WIDTH:\r\nnd->w = value;\r\nbreak;\r\ncase HID_DG_HEIGHT:\r\nnd->h = value;\r\nif (!nd->reading_mt) {\r\ninput_report_key(input, BTN_TOUCH,\r\nnd->tipswitch);\r\ninput_report_key(input, BTN_TOOL_DOUBLETAP,\r\nnd->tipswitch);\r\ninput_event(input, EV_ABS, ABS_X, nd->x);\r\ninput_event(input, EV_ABS, ABS_Y, nd->y);\r\n}\r\nbreak;\r\ncase 0xff000002:\r\nif (nd->mt_foot_count >= 4)\r\nbreak;\r\nnd->mt_footer[nd->mt_foot_count++] = value;\r\nif (nd->mt_foot_count != 4)\r\nbreak;\r\nif (nd->mt_footer[2]) {\r\nnd->act_state = deactivate_slack - 1;\r\nnd->confidence = 0;\r\nbreak;\r\n}\r\nif (nd->mt_footer[0]) {\r\nif (nd->w < nd->min_width ||\r\nnd->h < nd->min_height)\r\nnd->confidence = 0;\r\n} else\r\nbreak;\r\nif (nd->act_state > 0) {\r\nif (nd->w >= nd->activation_width &&\r\nnd->h >= nd->activation_height) {\r\nif (nd->id)\r\nnd->act_state = 0;\r\nelse {\r\nnd->act_state = 1;\r\nbreak;\r\n}\r\n} else\r\nbreak;\r\n}\r\nif (!nd->confidence)\r\nbreak;\r\nif (nd->id == 0) {\r\nnd->first_contact_touch = nd->confidence;\r\ninput_event(input, EV_ABS, ABS_X, nd->x);\r\ninput_event(input, EV_ABS, ABS_Y, nd->y);\r\n}\r\ninput_event(input, EV_ABS, ABS_MT_POSITION_X, nd->x);\r\ninput_event(input, EV_ABS, ABS_MT_POSITION_Y, nd->y);\r\nif (nd->w > nd->h) {\r\ninput_event(input, EV_ABS,\r\nABS_MT_ORIENTATION, 1);\r\ninput_event(input, EV_ABS,\r\nABS_MT_TOUCH_MAJOR, nd->w);\r\ninput_event(input, EV_ABS,\r\nABS_MT_TOUCH_MINOR, nd->h);\r\n} else {\r\ninput_event(input, EV_ABS,\r\nABS_MT_ORIENTATION, 0);\r\ninput_event(input, EV_ABS,\r\nABS_MT_TOUCH_MAJOR, nd->h);\r\ninput_event(input, EV_ABS,\r\nABS_MT_TOUCH_MINOR, nd->w);\r\n}\r\ninput_mt_sync(field->hidinput->input);\r\nbreak;\r\ncase HID_DG_CONTACTCOUNT:\r\nif (!nd->reading_mt)\r\nbreak;\r\nnd->reading_mt = 0;\r\nif (nd->act_state > 0) {\r\nif (value)\r\nnd->act_state = (nd->act_state > value)\r\n? nd->act_state - value\r\n: 0;\r\nelse\r\nnd->act_state = nd->activate_slack;\r\nbreak;\r\n} else {\r\nif (value && nd->act_state >=\r\nnd->deactivate_slack)\r\nnd->act_state = 0;\r\nelse if (nd->act_state <= nd->deactivate_slack)\r\nnd->act_state =\r\nnd->activate_slack;\r\nelse {\r\nnd->act_state--;\r\nbreak;\r\n}\r\n}\r\nif (nd->first_contact_touch && nd->act_state <= 0) {\r\ninput_report_key(input, BTN_TOOL_DOUBLETAP, 1);\r\ninput_report_key(input, BTN_TOUCH, 1);\r\n} else {\r\ninput_report_key(input, BTN_TOOL_DOUBLETAP, 0);\r\ninput_report_key(input, BTN_TOUCH, 0);\r\n}\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nnot_claimed_input:\r\nif ((hid->claimed & HID_CLAIMED_HIDDEV) && hid->hiddev_hid_event)\r\nhid->hiddev_hid_event(hid, field, usage, value);\r\nreturn 1;\r\n}\r\nstatic void ntrig_input_configured(struct hid_device *hid,\r\nstruct hid_input *hidinput)\r\n{\r\nstruct input_dev *input = hidinput->input;\r\nif (hidinput->report->maxfield < 1)\r\nreturn;\r\nswitch (hidinput->report->field[0]->application) {\r\ncase HID_DG_PEN:\r\ninput->name = "N-Trig Pen";\r\nbreak;\r\ncase HID_DG_TOUCHSCREEN:\r\n__clear_bit(BTN_TOOL_PEN, input->keybit);\r\n__clear_bit(BTN_TOOL_FINGER, input->keybit);\r\n__clear_bit(BTN_0, input->keybit);\r\n__set_bit(BTN_TOOL_DOUBLETAP, input->keybit);\r\ninput->name = (hidinput->report->field[0]->physical) ?\r\n"N-Trig Touchscreen" :\r\n"N-Trig MultiTouch";\r\nbreak;\r\n}\r\n}\r\nstatic int ntrig_probe(struct hid_device *hdev, const struct hid_device_id *id)\r\n{\r\nint ret;\r\nstruct ntrig_data *nd;\r\nstruct hid_report *report;\r\nif (id->driver_data)\r\nhdev->quirks |= HID_QUIRK_MULTI_INPUT\r\n| HID_QUIRK_NO_INIT_REPORTS;\r\nnd = kmalloc(sizeof(struct ntrig_data), GFP_KERNEL);\r\nif (!nd) {\r\nhid_err(hdev, "cannot allocate N-Trig data\n");\r\nreturn -ENOMEM;\r\n}\r\nnd->reading_mt = 0;\r\nnd->min_width = 0;\r\nnd->min_height = 0;\r\nnd->activate_slack = activate_slack;\r\nnd->act_state = activate_slack;\r\nnd->deactivate_slack = -deactivate_slack;\r\nnd->sensor_logical_width = 1;\r\nnd->sensor_logical_height = 1;\r\nnd->sensor_physical_width = 1;\r\nnd->sensor_physical_height = 1;\r\nhid_set_drvdata(hdev, nd);\r\nret = hid_parse(hdev);\r\nif (ret) {\r\nhid_err(hdev, "parse failed\n");\r\ngoto err_free;\r\n}\r\nret = hid_hw_start(hdev, HID_CONNECT_DEFAULT & ~HID_CONNECT_FF);\r\nif (ret) {\r\nhid_err(hdev, "hw start failed\n");\r\ngoto err_free;\r\n}\r\nreport = hdev->report_enum[HID_FEATURE_REPORT].report_id_hash[0x0a];\r\nif (report) {\r\nhid_hw_wait(hdev);\r\nhid_hw_request(hdev, report, HID_REQ_GET_REPORT);\r\nif (ntrig_get_mode(hdev) >= 4)\r\nntrig_set_mode(hdev, 3);\r\n}\r\nntrig_report_version(hdev);\r\nret = sysfs_create_group(&hdev->dev.kobj,\r\n&ntrig_attribute_group);\r\nreturn 0;\r\nerr_free:\r\nkfree(nd);\r\nreturn ret;\r\n}\r\nstatic void ntrig_remove(struct hid_device *hdev)\r\n{\r\nsysfs_remove_group(&hdev->dev.kobj,\r\n&ntrig_attribute_group);\r\nhid_hw_stop(hdev);\r\nkfree(hid_get_drvdata(hdev));\r\n}
