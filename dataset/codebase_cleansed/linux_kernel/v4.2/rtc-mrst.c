static inline int is_intr(u8 rtc_intr)\r\n{\r\nif (!(rtc_intr & RTC_IRQF))\r\nreturn 0;\r\nreturn rtc_intr & RTC_IRQMASK;\r\n}\r\nstatic inline unsigned char vrtc_is_updating(void)\r\n{\r\nunsigned char uip;\r\nunsigned long flags;\r\nspin_lock_irqsave(&rtc_lock, flags);\r\nuip = (vrtc_cmos_read(RTC_FREQ_SELECT) & RTC_UIP);\r\nspin_unlock_irqrestore(&rtc_lock, flags);\r\nreturn uip;\r\n}\r\nstatic int mrst_read_time(struct device *dev, struct rtc_time *time)\r\n{\r\nunsigned long flags;\r\nif (vrtc_is_updating())\r\nmdelay(20);\r\nspin_lock_irqsave(&rtc_lock, flags);\r\ntime->tm_sec = vrtc_cmos_read(RTC_SECONDS);\r\ntime->tm_min = vrtc_cmos_read(RTC_MINUTES);\r\ntime->tm_hour = vrtc_cmos_read(RTC_HOURS);\r\ntime->tm_mday = vrtc_cmos_read(RTC_DAY_OF_MONTH);\r\ntime->tm_mon = vrtc_cmos_read(RTC_MONTH);\r\ntime->tm_year = vrtc_cmos_read(RTC_YEAR);\r\nspin_unlock_irqrestore(&rtc_lock, flags);\r\ntime->tm_year += 72;\r\ntime->tm_mon--;\r\nreturn rtc_valid_tm(time);\r\n}\r\nstatic int mrst_set_time(struct device *dev, struct rtc_time *time)\r\n{\r\nint ret;\r\nunsigned long flags;\r\nunsigned char mon, day, hrs, min, sec;\r\nunsigned int yrs;\r\nyrs = time->tm_year;\r\nmon = time->tm_mon + 1;\r\nday = time->tm_mday;\r\nhrs = time->tm_hour;\r\nmin = time->tm_min;\r\nsec = time->tm_sec;\r\nif (yrs < 72 || yrs > 138)\r\nreturn -EINVAL;\r\nyrs -= 72;\r\nspin_lock_irqsave(&rtc_lock, flags);\r\nvrtc_cmos_write(yrs, RTC_YEAR);\r\nvrtc_cmos_write(mon, RTC_MONTH);\r\nvrtc_cmos_write(day, RTC_DAY_OF_MONTH);\r\nvrtc_cmos_write(hrs, RTC_HOURS);\r\nvrtc_cmos_write(min, RTC_MINUTES);\r\nvrtc_cmos_write(sec, RTC_SECONDS);\r\nspin_unlock_irqrestore(&rtc_lock, flags);\r\nret = intel_scu_ipc_simple_command(IPCMSG_VRTC, IPC_CMD_VRTC_SETTIME);\r\nreturn ret;\r\n}\r\nstatic int mrst_read_alarm(struct device *dev, struct rtc_wkalrm *t)\r\n{\r\nstruct mrst_rtc *mrst = dev_get_drvdata(dev);\r\nunsigned char rtc_control;\r\nif (mrst->irq <= 0)\r\nreturn -EIO;\r\nt->time.tm_mday = -1;\r\nt->time.tm_mon = -1;\r\nt->time.tm_year = -1;\r\nspin_lock_irq(&rtc_lock);\r\nt->time.tm_sec = vrtc_cmos_read(RTC_SECONDS_ALARM);\r\nt->time.tm_min = vrtc_cmos_read(RTC_MINUTES_ALARM);\r\nt->time.tm_hour = vrtc_cmos_read(RTC_HOURS_ALARM);\r\nrtc_control = vrtc_cmos_read(RTC_CONTROL);\r\nspin_unlock_irq(&rtc_lock);\r\nt->enabled = !!(rtc_control & RTC_AIE);\r\nt->pending = 0;\r\nreturn 0;\r\n}\r\nstatic void mrst_checkintr(struct mrst_rtc *mrst, unsigned char rtc_control)\r\n{\r\nunsigned char rtc_intr;\r\nrtc_intr = vrtc_cmos_read(RTC_INTR_FLAGS);\r\nrtc_intr &= (rtc_control & RTC_IRQMASK) | RTC_IRQF;\r\nif (is_intr(rtc_intr))\r\nrtc_update_irq(mrst->rtc, 1, rtc_intr);\r\n}\r\nstatic void mrst_irq_enable(struct mrst_rtc *mrst, unsigned char mask)\r\n{\r\nunsigned char rtc_control;\r\nrtc_control = vrtc_cmos_read(RTC_CONTROL);\r\nmrst_checkintr(mrst, rtc_control);\r\nrtc_control |= mask;\r\nvrtc_cmos_write(rtc_control, RTC_CONTROL);\r\nmrst_checkintr(mrst, rtc_control);\r\n}\r\nstatic void mrst_irq_disable(struct mrst_rtc *mrst, unsigned char mask)\r\n{\r\nunsigned char rtc_control;\r\nrtc_control = vrtc_cmos_read(RTC_CONTROL);\r\nrtc_control &= ~mask;\r\nvrtc_cmos_write(rtc_control, RTC_CONTROL);\r\nmrst_checkintr(mrst, rtc_control);\r\n}\r\nstatic int mrst_set_alarm(struct device *dev, struct rtc_wkalrm *t)\r\n{\r\nstruct mrst_rtc *mrst = dev_get_drvdata(dev);\r\nunsigned char hrs, min, sec;\r\nint ret = 0;\r\nif (!mrst->irq)\r\nreturn -EIO;\r\nhrs = t->time.tm_hour;\r\nmin = t->time.tm_min;\r\nsec = t->time.tm_sec;\r\nspin_lock_irq(&rtc_lock);\r\nmrst_irq_disable(mrst, RTC_AIE);\r\nvrtc_cmos_write(hrs, RTC_HOURS_ALARM);\r\nvrtc_cmos_write(min, RTC_MINUTES_ALARM);\r\nvrtc_cmos_write(sec, RTC_SECONDS_ALARM);\r\nspin_unlock_irq(&rtc_lock);\r\nret = intel_scu_ipc_simple_command(IPCMSG_VRTC, IPC_CMD_VRTC_SETALARM);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_irq(&rtc_lock);\r\nif (t->enabled)\r\nmrst_irq_enable(mrst, RTC_AIE);\r\nspin_unlock_irq(&rtc_lock);\r\nreturn 0;\r\n}\r\nstatic int mrst_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct mrst_rtc *mrst = dev_get_drvdata(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&rtc_lock, flags);\r\nif (enabled)\r\nmrst_irq_enable(mrst, RTC_AIE);\r\nelse\r\nmrst_irq_disable(mrst, RTC_AIE);\r\nspin_unlock_irqrestore(&rtc_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mrst_procfs(struct device *dev, struct seq_file *seq)\r\n{\r\nunsigned char rtc_control, valid;\r\nspin_lock_irq(&rtc_lock);\r\nrtc_control = vrtc_cmos_read(RTC_CONTROL);\r\nvalid = vrtc_cmos_read(RTC_VALID);\r\nspin_unlock_irq(&rtc_lock);\r\nseq_printf(seq,\r\n"periodic_IRQ\t: %s\n"\r\n"alarm\t\t: %s\n"\r\n"BCD\t\t: no\n"\r\n"periodic_freq\t: daily (not adjustable)\n",\r\n(rtc_control & RTC_PIE) ? "on" : "off",\r\n(rtc_control & RTC_AIE) ? "on" : "off");\r\nreturn 0;\r\n}\r\nstatic irqreturn_t mrst_rtc_irq(int irq, void *p)\r\n{\r\nu8 irqstat;\r\nspin_lock(&rtc_lock);\r\nirqstat = vrtc_cmos_read(RTC_INTR_FLAGS);\r\nspin_unlock(&rtc_lock);\r\nirqstat &= RTC_IRQMASK | RTC_IRQF;\r\nif (is_intr(irqstat)) {\r\nrtc_update_irq(p, 1, irqstat);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic int vrtc_mrst_do_probe(struct device *dev, struct resource *iomem,\r\nint rtc_irq)\r\n{\r\nint retval = 0;\r\nunsigned char rtc_control;\r\nif (mrst_rtc.dev)\r\nreturn -EBUSY;\r\nif (!iomem)\r\nreturn -ENODEV;\r\niomem = request_mem_region(iomem->start, resource_size(iomem),\r\ndriver_name);\r\nif (!iomem) {\r\ndev_dbg(dev, "i/o mem already in use.\n");\r\nreturn -EBUSY;\r\n}\r\nmrst_rtc.irq = rtc_irq;\r\nmrst_rtc.iomem = iomem;\r\nmrst_rtc.dev = dev;\r\ndev_set_drvdata(dev, &mrst_rtc);\r\nmrst_rtc.rtc = rtc_device_register(driver_name, dev,\r\n&mrst_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(mrst_rtc.rtc)) {\r\nretval = PTR_ERR(mrst_rtc.rtc);\r\ngoto cleanup0;\r\n}\r\nrename_region(iomem, dev_name(&mrst_rtc.rtc->dev));\r\nspin_lock_irq(&rtc_lock);\r\nmrst_irq_disable(&mrst_rtc, RTC_PIE | RTC_AIE);\r\nrtc_control = vrtc_cmos_read(RTC_CONTROL);\r\nspin_unlock_irq(&rtc_lock);\r\nif (!(rtc_control & RTC_24H) || (rtc_control & (RTC_DM_BINARY)))\r\ndev_dbg(dev, "TODO: support more than 24-hr BCD mode\n");\r\nif (rtc_irq) {\r\nretval = request_irq(rtc_irq, mrst_rtc_irq,\r\n0, dev_name(&mrst_rtc.rtc->dev),\r\nmrst_rtc.rtc);\r\nif (retval < 0) {\r\ndev_dbg(dev, "IRQ %d is already in use, err %d\n",\r\nrtc_irq, retval);\r\ngoto cleanup1;\r\n}\r\n}\r\ndev_dbg(dev, "initialised\n");\r\nreturn 0;\r\ncleanup1:\r\nrtc_device_unregister(mrst_rtc.rtc);\r\ncleanup0:\r\nmrst_rtc.dev = NULL;\r\nrelease_mem_region(iomem->start, resource_size(iomem));\r\ndev_err(dev, "rtc-mrst: unable to initialise\n");\r\nreturn retval;\r\n}\r\nstatic void rtc_mrst_do_shutdown(void)\r\n{\r\nspin_lock_irq(&rtc_lock);\r\nmrst_irq_disable(&mrst_rtc, RTC_IRQMASK);\r\nspin_unlock_irq(&rtc_lock);\r\n}\r\nstatic void rtc_mrst_do_remove(struct device *dev)\r\n{\r\nstruct mrst_rtc *mrst = dev_get_drvdata(dev);\r\nstruct resource *iomem;\r\nrtc_mrst_do_shutdown();\r\nif (mrst->irq)\r\nfree_irq(mrst->irq, mrst->rtc);\r\nrtc_device_unregister(mrst->rtc);\r\nmrst->rtc = NULL;\r\niomem = mrst->iomem;\r\nrelease_mem_region(iomem->start, resource_size(iomem));\r\nmrst->iomem = NULL;\r\nmrst->dev = NULL;\r\n}\r\nstatic int mrst_suspend(struct device *dev)\r\n{\r\nstruct mrst_rtc *mrst = dev_get_drvdata(dev);\r\nunsigned char tmp;\r\nspin_lock_irq(&rtc_lock);\r\nmrst->suspend_ctrl = tmp = vrtc_cmos_read(RTC_CONTROL);\r\nif (tmp & (RTC_PIE | RTC_AIE)) {\r\nunsigned char mask;\r\nif (device_may_wakeup(dev))\r\nmask = RTC_IRQMASK & ~RTC_AIE;\r\nelse\r\nmask = RTC_IRQMASK;\r\ntmp &= ~mask;\r\nvrtc_cmos_write(tmp, RTC_CONTROL);\r\nmrst_checkintr(mrst, tmp);\r\n}\r\nspin_unlock_irq(&rtc_lock);\r\nif (tmp & RTC_AIE) {\r\nmrst->enabled_wake = 1;\r\nenable_irq_wake(mrst->irq);\r\n}\r\ndev_dbg(&mrst_rtc.rtc->dev, "suspend%s, ctrl %02x\n",\r\n(tmp & RTC_AIE) ? ", alarm may wake" : "",\r\ntmp);\r\nreturn 0;\r\n}\r\nstatic inline int mrst_poweroff(struct device *dev)\r\n{\r\nreturn mrst_suspend(dev);\r\n}\r\nstatic int mrst_resume(struct device *dev)\r\n{\r\nstruct mrst_rtc *mrst = dev_get_drvdata(dev);\r\nunsigned char tmp = mrst->suspend_ctrl;\r\nif (tmp & RTC_IRQMASK) {\r\nunsigned char mask;\r\nif (mrst->enabled_wake) {\r\ndisable_irq_wake(mrst->irq);\r\nmrst->enabled_wake = 0;\r\n}\r\nspin_lock_irq(&rtc_lock);\r\ndo {\r\nvrtc_cmos_write(tmp, RTC_CONTROL);\r\nmask = vrtc_cmos_read(RTC_INTR_FLAGS);\r\nmask &= (tmp & RTC_IRQMASK) | RTC_IRQF;\r\nif (!is_intr(mask))\r\nbreak;\r\nrtc_update_irq(mrst->rtc, 1, mask);\r\ntmp &= ~RTC_AIE;\r\n} while (mask & RTC_AIE);\r\nspin_unlock_irq(&rtc_lock);\r\n}\r\ndev_dbg(&mrst_rtc.rtc->dev, "resume, ctrl %02x\n", tmp);\r\nreturn 0;\r\n}\r\nstatic inline int mrst_poweroff(struct device *dev)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int vrtc_mrst_platform_probe(struct platform_device *pdev)\r\n{\r\nreturn vrtc_mrst_do_probe(&pdev->dev,\r\nplatform_get_resource(pdev, IORESOURCE_MEM, 0),\r\nplatform_get_irq(pdev, 0));\r\n}\r\nstatic int vrtc_mrst_platform_remove(struct platform_device *pdev)\r\n{\r\nrtc_mrst_do_remove(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic void vrtc_mrst_platform_shutdown(struct platform_device *pdev)\r\n{\r\nif (system_state == SYSTEM_POWER_OFF && !mrst_poweroff(&pdev->dev))\r\nreturn;\r\nrtc_mrst_do_shutdown();\r\n}
