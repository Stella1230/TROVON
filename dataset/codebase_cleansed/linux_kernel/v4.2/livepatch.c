int klp_write_module_reloc(struct module *mod, unsigned long type,\r\nunsigned long loc, unsigned long value)\r\n{\r\nint ret, numpages, size = 4;\r\nbool readonly;\r\nunsigned long val;\r\nunsigned long core = (unsigned long)mod->module_core;\r\nunsigned long core_ro_size = mod->core_ro_size;\r\nunsigned long core_size = mod->core_size;\r\nswitch (type) {\r\ncase R_X86_64_NONE:\r\nreturn 0;\r\ncase R_X86_64_64:\r\nval = value;\r\nsize = 8;\r\nbreak;\r\ncase R_X86_64_32:\r\nval = (u32)value;\r\nbreak;\r\ncase R_X86_64_32S:\r\nval = (s32)value;\r\nbreak;\r\ncase R_X86_64_PC32:\r\nval = (u32)(value - loc);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (loc < core || loc >= core + core_size)\r\nreturn -EINVAL;\r\nif (loc < core + core_ro_size)\r\nreadonly = true;\r\nelse\r\nreadonly = false;\r\nnumpages = ((loc & PAGE_MASK) == ((loc + size) & PAGE_MASK)) ? 1 : 2;\r\nif (readonly)\r\nset_memory_rw(loc & PAGE_MASK, numpages);\r\nret = probe_kernel_write((void *)loc, &val, size);\r\nif (readonly)\r\nset_memory_ro(loc & PAGE_MASK, numpages);\r\nreturn ret;\r\n}
