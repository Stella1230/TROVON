static void sun3x_esp_write8(struct esp *esp, u8 val, unsigned long reg)\r\n{\r\nwriteb(val, esp->regs + (reg * 4UL));\r\n}\r\nstatic u8 sun3x_esp_read8(struct esp *esp, unsigned long reg)\r\n{\r\nreturn readb(esp->regs + (reg * 4UL));\r\n}\r\nstatic dma_addr_t sun3x_esp_map_single(struct esp *esp, void *buf,\r\nsize_t sz, int dir)\r\n{\r\nreturn dma_map_single(esp->dev, buf, sz, dir);\r\n}\r\nstatic int sun3x_esp_map_sg(struct esp *esp, struct scatterlist *sg,\r\nint num_sg, int dir)\r\n{\r\nreturn dma_map_sg(esp->dev, sg, num_sg, dir);\r\n}\r\nstatic void sun3x_esp_unmap_single(struct esp *esp, dma_addr_t addr,\r\nsize_t sz, int dir)\r\n{\r\ndma_unmap_single(esp->dev, addr, sz, dir);\r\n}\r\nstatic void sun3x_esp_unmap_sg(struct esp *esp, struct scatterlist *sg,\r\nint num_sg, int dir)\r\n{\r\ndma_unmap_sg(esp->dev, sg, num_sg, dir);\r\n}\r\nstatic int sun3x_esp_irq_pending(struct esp *esp)\r\n{\r\nif (dma_read32(DMA_CSR) & (DMA_HNDL_INTR | DMA_HNDL_ERROR))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void sun3x_esp_reset_dma(struct esp *esp)\r\n{\r\nu32 val;\r\nval = dma_read32(DMA_CSR);\r\ndma_write32(val | DMA_RST_SCSI, DMA_CSR);\r\ndma_write32(val & ~DMA_RST_SCSI, DMA_CSR);\r\nval = dma_read32(DMA_CSR);\r\ndma_write32(val | DMA_INT_ENAB, DMA_CSR);\r\n}\r\nstatic void sun3x_esp_dma_drain(struct esp *esp)\r\n{\r\nu32 csr;\r\nint lim;\r\ncsr = dma_read32(DMA_CSR);\r\nif (!(csr & DMA_FIFO_ISDRAIN))\r\nreturn;\r\ndma_write32(csr | DMA_FIFO_STDRAIN, DMA_CSR);\r\nlim = 1000;\r\nwhile (dma_read32(DMA_CSR) & DMA_FIFO_ISDRAIN) {\r\nif (--lim == 0) {\r\nprintk(KERN_ALERT PFX "esp%d: DMA will not drain!\n",\r\nesp->host->unique_id);\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\n}\r\nstatic void sun3x_esp_dma_invalidate(struct esp *esp)\r\n{\r\nu32 val;\r\nint lim;\r\nlim = 1000;\r\nwhile ((val = dma_read32(DMA_CSR)) & DMA_PEND_READ) {\r\nif (--lim == 0) {\r\nprintk(KERN_ALERT PFX "esp%d: DMA will not "\r\n"invalidate!\n", esp->host->unique_id);\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\nval &= ~(DMA_ENABLE | DMA_ST_WRITE | DMA_BCNT_ENAB);\r\nval |= DMA_FIFO_INV;\r\ndma_write32(val, DMA_CSR);\r\nval &= ~DMA_FIFO_INV;\r\ndma_write32(val, DMA_CSR);\r\n}\r\nstatic void sun3x_esp_send_dma_cmd(struct esp *esp, u32 addr, u32 esp_count,\r\nu32 dma_count, int write, u8 cmd)\r\n{\r\nu32 csr;\r\nBUG_ON(!(cmd & ESP_CMD_DMA));\r\nsun3x_esp_write8(esp, (esp_count >> 0) & 0xff, ESP_TCLOW);\r\nsun3x_esp_write8(esp, (esp_count >> 8) & 0xff, ESP_TCMED);\r\ncsr = dma_read32(DMA_CSR);\r\ncsr |= DMA_ENABLE;\r\nif (write)\r\ncsr |= DMA_ST_WRITE;\r\nelse\r\ncsr &= ~DMA_ST_WRITE;\r\ndma_write32(csr, DMA_CSR);\r\ndma_write32(addr, DMA_ADDR);\r\nscsi_esp_cmd(esp, cmd);\r\n}\r\nstatic int sun3x_esp_dma_error(struct esp *esp)\r\n{\r\nu32 csr = dma_read32(DMA_CSR);\r\nif (csr & DMA_HNDL_ERROR)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int esp_sun3x_probe(struct platform_device *dev)\r\n{\r\nstruct scsi_host_template *tpnt = &scsi_esp_template;\r\nstruct Scsi_Host *host;\r\nstruct esp *esp;\r\nstruct resource *res;\r\nint err = -ENOMEM;\r\nhost = scsi_host_alloc(tpnt, sizeof(struct esp));\r\nif (!host)\r\ngoto fail;\r\nhost->max_id = 8;\r\nesp = shost_priv(host);\r\nesp->host = host;\r\nesp->dev = dev;\r\nesp->ops = &sun3x_esp_ops;\r\nres = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nif (!res || !res->start)\r\ngoto fail_unlink;\r\nesp->regs = ioremap_nocache(res->start, 0x20);\r\nif (!esp->regs)\r\ngoto fail_unmap_regs;\r\nres = platform_get_resource(dev, IORESOURCE_MEM, 1);\r\nif (!res || !res->start)\r\ngoto fail_unmap_regs;\r\nesp->dma_regs = ioremap_nocache(res->start, 0x10);\r\nesp->command_block = dma_alloc_coherent(esp->dev, 16,\r\n&esp->command_block_dma,\r\nGFP_KERNEL);\r\nif (!esp->command_block)\r\ngoto fail_unmap_regs_dma;\r\nhost->irq = platform_get_irq(dev, 0);\r\nerr = request_irq(host->irq, scsi_esp_intr, IRQF_SHARED,\r\n"SUN3X ESP", esp);\r\nif (err < 0)\r\ngoto fail_unmap_command_block;\r\nesp->scsi_id = 7;\r\nesp->host->this_id = esp->scsi_id;\r\nesp->scsi_id_mask = (1 << esp->scsi_id);\r\nesp->cfreq = 20000000;\r\ndev_set_drvdata(&dev->dev, esp);\r\nerr = scsi_esp_register(esp, &dev->dev);\r\nif (err)\r\ngoto fail_free_irq;\r\nreturn 0;\r\nfail_free_irq:\r\nfree_irq(host->irq, esp);\r\nfail_unmap_command_block:\r\ndma_free_coherent(esp->dev, 16,\r\nesp->command_block,\r\nesp->command_block_dma);\r\nfail_unmap_regs_dma:\r\niounmap(esp->dma_regs);\r\nfail_unmap_regs:\r\niounmap(esp->regs);\r\nfail_unlink:\r\nscsi_host_put(host);\r\nfail:\r\nreturn err;\r\n}\r\nstatic int esp_sun3x_remove(struct platform_device *dev)\r\n{\r\nstruct esp *esp = dev_get_drvdata(&dev->dev);\r\nunsigned int irq = esp->host->irq;\r\nu32 val;\r\nscsi_esp_unregister(esp);\r\nval = dma_read32(DMA_CSR);\r\ndma_write32(val & ~DMA_INT_ENAB, DMA_CSR);\r\nfree_irq(irq, esp);\r\ndma_free_coherent(esp->dev, 16,\r\nesp->command_block,\r\nesp->command_block_dma);\r\nscsi_host_put(esp->host);\r\nreturn 0;\r\n}\r\nstatic int __init sun3x_esp_init(void)\r\n{\r\nreturn platform_driver_register(&esp_sun3x_driver);\r\n}\r\nstatic void __exit sun3x_esp_exit(void)\r\n{\r\nplatform_driver_unregister(&esp_sun3x_driver);\r\n}
