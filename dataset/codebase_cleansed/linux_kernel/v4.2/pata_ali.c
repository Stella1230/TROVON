static int ali_cable_override(struct pci_dev *pdev)\r\n{\r\nif (pdev->subsystem_vendor == 0x10CF && pdev->subsystem_device == 0x10AF)\r\nreturn 1;\r\nif (pdev->subsystem_vendor == 0x1071 && pdev->subsystem_device == 0x8317)\r\nreturn 1;\r\nif (dmi_check_system(cable_dmi_table))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int ali_c2_cable_detect(struct ata_port *ap)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nu8 ata66;\r\nif (ali_cable_override(pdev))\r\nreturn ATA_CBL_PATA40_SHORT;\r\npci_read_config_byte(pdev, 0x4A, &ata66);\r\nif (ata66 & (1 << ap->port_no))\r\nreturn ATA_CBL_PATA40;\r\nelse\r\nreturn ATA_CBL_PATA80;\r\n}\r\nstatic unsigned long ali_20_filter(struct ata_device *adev, unsigned long mask)\r\n{\r\nchar model_num[ATA_ID_PROD_LEN + 1];\r\nif (adev->class != ATA_DEV_ATA)\r\nmask &= ~(ATA_MASK_MWDMA | ATA_MASK_UDMA);\r\nata_id_c_string(adev->id, model_num, ATA_ID_PROD, sizeof(model_num));\r\nif (strstr(model_num, "WDC"))\r\nreturn mask &= ~ATA_MASK_UDMA;\r\nreturn mask;\r\n}\r\nstatic void ali_fifo_control(struct ata_port *ap, struct ata_device *adev, int on)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nint pio_fifo = 0x54 + ap->port_no;\r\nu8 fifo;\r\nint shift = 4 * adev->devno;\r\npci_read_config_byte(pdev, pio_fifo, &fifo);\r\nfifo &= ~(0x0F << shift);\r\nfifo |= (on << shift);\r\npci_write_config_byte(pdev, pio_fifo, fifo);\r\n}\r\nstatic void ali_program_modes(struct ata_port *ap, struct ata_device *adev, struct ata_timing *t, u8 ultra)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nint cas = 0x58 + 4 * ap->port_no;\r\nint cbt = 0x59 + 4 * ap->port_no;\r\nint drwt = 0x5A + 4 * ap->port_no + adev->devno;\r\nint udmat = 0x56 + ap->port_no;\r\nint shift = 4 * adev->devno;\r\nu8 udma;\r\nif (t != NULL) {\r\nt->setup = clamp_val(t->setup, 1, 8) & 7;\r\nt->act8b = clamp_val(t->act8b, 1, 8) & 7;\r\nt->rec8b = clamp_val(t->rec8b, 1, 16) & 15;\r\nt->active = clamp_val(t->active, 1, 8) & 7;\r\nt->recover = clamp_val(t->recover, 1, 16) & 15;\r\npci_write_config_byte(pdev, cas, t->setup);\r\npci_write_config_byte(pdev, cbt, (t->act8b << 4) | t->rec8b);\r\npci_write_config_byte(pdev, drwt, (t->active << 4) | t->recover);\r\n}\r\npci_read_config_byte(pdev, udmat, &udma);\r\nudma &= ~(0x0F << shift);\r\nudma |= ultra << shift;\r\npci_write_config_byte(pdev, udmat, udma);\r\n}\r\nstatic void ali_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstruct ata_device *pair = ata_dev_pair(adev);\r\nstruct ata_timing t;\r\nunsigned long T = 1000000000 / 33333;\r\nata_timing_compute(adev, adev->pio_mode, &t, T, 1);\r\nif (pair) {\r\nstruct ata_timing p;\r\nata_timing_compute(pair, pair->pio_mode, &p, T, 1);\r\nata_timing_merge(&p, &t, &t, ATA_TIMING_SETUP|ATA_TIMING_8BIT);\r\nif (pair->dma_mode) {\r\nata_timing_compute(pair, pair->dma_mode, &p, T, 1);\r\nata_timing_merge(&p, &t, &t, ATA_TIMING_SETUP|ATA_TIMING_8BIT);\r\n}\r\n}\r\nif (adev->class != ATA_DEV_ATA)\r\nali_fifo_control(ap, adev, 0x00);\r\nali_program_modes(ap, adev, &t, 0);\r\nif (adev->class == ATA_DEV_ATA)\r\nali_fifo_control(ap, adev, 0x05);\r\n}\r\nstatic void ali_set_dmamode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstatic u8 udma_timing[7] = { 0xC, 0xB, 0xA, 0x9, 0x8, 0xF, 0xD };\r\nstruct ata_device *pair = ata_dev_pair(adev);\r\nstruct ata_timing t;\r\nunsigned long T = 1000000000 / 33333;\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nif (adev->class == ATA_DEV_ATA)\r\nali_fifo_control(ap, adev, 0x08);\r\nif (adev->dma_mode >= XFER_UDMA_0) {\r\nali_program_modes(ap, adev, NULL, udma_timing[adev->dma_mode - XFER_UDMA_0]);\r\nif (adev->dma_mode >= XFER_UDMA_3) {\r\nu8 reg4b;\r\npci_read_config_byte(pdev, 0x4B, &reg4b);\r\nreg4b |= 1;\r\npci_write_config_byte(pdev, 0x4B, reg4b);\r\n}\r\n} else {\r\nata_timing_compute(adev, adev->dma_mode, &t, T, 1);\r\nif (pair) {\r\nstruct ata_timing p;\r\nata_timing_compute(pair, pair->pio_mode, &p, T, 1);\r\nata_timing_merge(&p, &t, &t, ATA_TIMING_SETUP|ATA_TIMING_8BIT);\r\nif (pair->dma_mode) {\r\nata_timing_compute(pair, pair->dma_mode, &p, T, 1);\r\nata_timing_merge(&p, &t, &t, ATA_TIMING_SETUP|ATA_TIMING_8BIT);\r\n}\r\n}\r\nali_program_modes(ap, adev, &t, 0);\r\n}\r\n}\r\nstatic void ali_warn_atapi_dma(struct ata_device *adev)\r\n{\r\nstruct ata_eh_context *ehc = &adev->link->eh_context;\r\nint print_info = ehc->i.flags & ATA_EHI_PRINTINFO;\r\nif (print_info && adev->class == ATA_DEV_ATAPI && !ali_atapi_dma) {\r\nata_dev_warn(adev,\r\n"WARNING: ATAPI DMA disabled for reliability issues. It can be enabled\n");\r\nata_dev_warn(adev,\r\n"WARNING: via pata_ali.atapi_dma modparam or corresponding sysfs node.\n");\r\n}\r\n}\r\nstatic void ali_lock_sectors(struct ata_device *adev)\r\n{\r\nadev->max_sectors = 255;\r\nali_warn_atapi_dma(adev);\r\n}\r\nstatic int ali_check_atapi_dma(struct ata_queued_cmd *qc)\r\n{\r\nif (!ali_atapi_dma) {\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (atapi_cmd_type(qc->cdb[0]) == ATAPI_MISC)\r\nreturn -EOPNOTSUPP;\r\nreturn 0;\r\n}\r\nstatic void ali_c2_c3_postreset(struct ata_link *link, unsigned int *classes)\r\n{\r\nu8 r;\r\nint port_bit = 4 << link->ap->port_no;\r\nif (ali_isa_bridge) {\r\npci_read_config_byte(ali_isa_bridge, 0x58, &r);\r\nr &= ~port_bit;\r\npci_write_config_byte(ali_isa_bridge, 0x58, r);\r\nr |= port_bit;\r\npci_write_config_byte(ali_isa_bridge, 0x58, r);\r\n}\r\nata_sff_postreset(link, classes);\r\n}\r\nstatic void ali_init_chipset(struct pci_dev *pdev)\r\n{\r\nu8 tmp;\r\nstruct pci_dev *north;\r\nif (pdev->revision <= 0x20) {\r\npci_read_config_byte(pdev, 0x53, &tmp);\r\ntmp |= 0x03;\r\npci_write_config_byte(pdev, 0x53, tmp);\r\n} else {\r\npci_read_config_byte(pdev, 0x4a, &tmp);\r\npci_write_config_byte(pdev, 0x4a, tmp | 0x20);\r\npci_read_config_byte(pdev, 0x4B, &tmp);\r\nif (pdev->revision < 0xC2)\r\ntmp &= 0x7F;\r\nif (pdev->revision >= 0xc2)\r\ntmp |= 0x01;\r\npci_write_config_byte(pdev, 0x4B, tmp | 0x08);\r\npci_read_config_byte(pdev, 0x53, &tmp);\r\nif (pdev->revision >= 0xc7)\r\ntmp |= 0x03;\r\nelse\r\ntmp |= 0x01;\r\npci_write_config_byte(pdev, 0x53, tmp);\r\n}\r\nnorth = pci_get_bus_and_slot(0, PCI_DEVFN(0,0));\r\nif (north && north->vendor == PCI_VENDOR_ID_AL && ali_isa_bridge) {\r\npci_read_config_byte(ali_isa_bridge, 0x79, &tmp);\r\nif (pdev->revision == 0xC2)\r\npci_write_config_byte(ali_isa_bridge, 0x79, tmp | 0x04);\r\nelse if (pdev->revision > 0xC2 && pdev->revision < 0xC5)\r\npci_write_config_byte(ali_isa_bridge, 0x79, tmp | 0x02);\r\n}\r\npci_dev_put(north);\r\nata_pci_bmdma_clear_simplex(pdev);\r\n}\r\nstatic int ali_init_one(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstatic const struct ata_port_info info_early = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.port_ops = &ali_early_port_ops\r\n};\r\nstatic const struct ata_port_info info_20 = {\r\n.flags = ATA_FLAG_SLAVE_POSS | ATA_FLAG_PIO_LBA48 |\r\nATA_FLAG_IGN_SIMPLEX,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.port_ops = &ali_20_port_ops\r\n};\r\nstatic const struct ata_port_info info_20_udma = {\r\n.flags = ATA_FLAG_SLAVE_POSS | ATA_FLAG_PIO_LBA48 |\r\nATA_FLAG_IGN_SIMPLEX,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA2,\r\n.port_ops = &ali_20_port_ops\r\n};\r\nstatic const struct ata_port_info info_c2 = {\r\n.flags = ATA_FLAG_SLAVE_POSS | ATA_FLAG_PIO_LBA48 |\r\nATA_FLAG_IGN_SIMPLEX,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA4,\r\n.port_ops = &ali_c2_port_ops\r\n};\r\nstatic const struct ata_port_info info_c3 = {\r\n.flags = ATA_FLAG_SLAVE_POSS | ATA_FLAG_PIO_LBA48 |\r\nATA_FLAG_IGN_SIMPLEX,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA4,\r\n.port_ops = &ali_c2_port_ops\r\n};\r\nstatic const struct ata_port_info info_c4 = {\r\n.flags = ATA_FLAG_SLAVE_POSS | ATA_FLAG_PIO_LBA48 |\r\nATA_FLAG_IGN_SIMPLEX,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA5,\r\n.port_ops = &ali_c4_port_ops\r\n};\r\nstatic const struct ata_port_info info_c5 = {\r\n.flags = ATA_FLAG_SLAVE_POSS | ATA_FLAG_IGN_SIMPLEX,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA6,\r\n.port_ops = &ali_c5_port_ops\r\n};\r\nconst struct ata_port_info *ppi[] = { NULL, NULL };\r\nu8 tmp;\r\nint rc;\r\nrc = pcim_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nif (pdev->revision < 0x20) {\r\nppi[0] = &info_early;\r\n} else if (pdev->revision < 0xC2) {\r\nppi[0] = &info_20;\r\n} else if (pdev->revision == 0xC2) {\r\nppi[0] = &info_c2;\r\n} else if (pdev->revision == 0xC3) {\r\nppi[0] = &info_c3;\r\n} else if (pdev->revision == 0xC4) {\r\nppi[0] = &info_c4;\r\n} else\r\nppi[0] = &info_c5;\r\nali_init_chipset(pdev);\r\nif (ali_isa_bridge && pdev->revision >= 0x20 && pdev->revision < 0xC2) {\r\npci_read_config_byte(ali_isa_bridge, 0x5E, &tmp);\r\nif ((tmp & 0x1E) == 0x12)\r\nppi[0] = &info_20_udma;\r\n}\r\nif (!ppi[0]->mwdma_mask && !ppi[0]->udma_mask)\r\nreturn ata_pci_sff_init_one(pdev, ppi, &ali_sht, NULL, 0);\r\nelse\r\nreturn ata_pci_bmdma_init_one(pdev, ppi, &ali_sht, NULL, 0);\r\n}\r\nstatic int ali_reinit_one(struct pci_dev *pdev)\r\n{\r\nstruct ata_host *host = pci_get_drvdata(pdev);\r\nint rc;\r\nrc = ata_pci_device_do_resume(pdev);\r\nif (rc)\r\nreturn rc;\r\nali_init_chipset(pdev);\r\nata_host_resume(host);\r\nreturn 0;\r\n}\r\nstatic int __init ali_init(void)\r\n{\r\nint ret;\r\nali_isa_bridge = pci_get_device(PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M1533, NULL);\r\nret = pci_register_driver(&ali_pci_driver);\r\nif (ret < 0)\r\npci_dev_put(ali_isa_bridge);\r\nreturn ret;\r\n}\r\nstatic void __exit ali_exit(void)\r\n{\r\npci_unregister_driver(&ali_pci_driver);\r\npci_dev_put(ali_isa_bridge);\r\n}
