static void internal_container_klist_get(struct klist_node *n)\r\n{\r\nstruct internal_container *ic =\r\ncontainer_of(n, struct internal_container, node);\r\nget_device(&ic->classdev);\r\n}\r\nstatic void internal_container_klist_put(struct klist_node *n)\r\n{\r\nstruct internal_container *ic =\r\ncontainer_of(n, struct internal_container, node);\r\nput_device(&ic->classdev);\r\n}\r\nstruct attribute_container *\r\nattribute_container_classdev_to_container(struct device *classdev)\r\n{\r\nstruct internal_container *ic =\r\ncontainer_of(classdev, struct internal_container, classdev);\r\nreturn ic->cont;\r\n}\r\nint\r\nattribute_container_register(struct attribute_container *cont)\r\n{\r\nINIT_LIST_HEAD(&cont->node);\r\nklist_init(&cont->containers, internal_container_klist_get,\r\ninternal_container_klist_put);\r\nmutex_lock(&attribute_container_mutex);\r\nlist_add_tail(&cont->node, &attribute_container_list);\r\nmutex_unlock(&attribute_container_mutex);\r\nreturn 0;\r\n}\r\nint\r\nattribute_container_unregister(struct attribute_container *cont)\r\n{\r\nint retval = -EBUSY;\r\nmutex_lock(&attribute_container_mutex);\r\nspin_lock(&cont->containers.k_lock);\r\nif (!list_empty(&cont->containers.k_list))\r\ngoto out;\r\nretval = 0;\r\nlist_del(&cont->node);\r\nout:\r\nspin_unlock(&cont->containers.k_lock);\r\nmutex_unlock(&attribute_container_mutex);\r\nreturn retval;\r\n}\r\nstatic void attribute_container_release(struct device *classdev)\r\n{\r\nstruct internal_container *ic\r\n= container_of(classdev, struct internal_container, classdev);\r\nstruct device *dev = classdev->parent;\r\nkfree(ic);\r\nput_device(dev);\r\n}\r\nvoid\r\nattribute_container_add_device(struct device *dev,\r\nint (*fn)(struct attribute_container *,\r\nstruct device *,\r\nstruct device *))\r\n{\r\nstruct attribute_container *cont;\r\nmutex_lock(&attribute_container_mutex);\r\nlist_for_each_entry(cont, &attribute_container_list, node) {\r\nstruct internal_container *ic;\r\nif (attribute_container_no_classdevs(cont))\r\ncontinue;\r\nif (!cont->match(cont, dev))\r\ncontinue;\r\nic = kzalloc(sizeof(*ic), GFP_KERNEL);\r\nif (!ic) {\r\ndev_err(dev, "failed to allocate class container\n");\r\ncontinue;\r\n}\r\nic->cont = cont;\r\ndevice_initialize(&ic->classdev);\r\nic->classdev.parent = get_device(dev);\r\nic->classdev.class = cont->class;\r\ncont->class->dev_release = attribute_container_release;\r\ndev_set_name(&ic->classdev, "%s", dev_name(dev));\r\nif (fn)\r\nfn(cont, dev, &ic->classdev);\r\nelse\r\nattribute_container_add_class_device(&ic->classdev);\r\nklist_add_tail(&ic->node, &cont->containers);\r\n}\r\nmutex_unlock(&attribute_container_mutex);\r\n}\r\nvoid\r\nattribute_container_remove_device(struct device *dev,\r\nvoid (*fn)(struct attribute_container *,\r\nstruct device *,\r\nstruct device *))\r\n{\r\nstruct attribute_container *cont;\r\nmutex_lock(&attribute_container_mutex);\r\nlist_for_each_entry(cont, &attribute_container_list, node) {\r\nstruct internal_container *ic;\r\nstruct klist_iter iter;\r\nif (attribute_container_no_classdevs(cont))\r\ncontinue;\r\nif (!cont->match(cont, dev))\r\ncontinue;\r\nklist_for_each_entry(ic, &cont->containers, node, &iter) {\r\nif (dev != ic->classdev.parent)\r\ncontinue;\r\nklist_del(&ic->node);\r\nif (fn)\r\nfn(cont, dev, &ic->classdev);\r\nelse {\r\nattribute_container_remove_attrs(&ic->classdev);\r\ndevice_unregister(&ic->classdev);\r\n}\r\n}\r\n}\r\nmutex_unlock(&attribute_container_mutex);\r\n}\r\nvoid\r\nattribute_container_device_trigger(struct device *dev,\r\nint (*fn)(struct attribute_container *,\r\nstruct device *,\r\nstruct device *))\r\n{\r\nstruct attribute_container *cont;\r\nmutex_lock(&attribute_container_mutex);\r\nlist_for_each_entry(cont, &attribute_container_list, node) {\r\nstruct internal_container *ic;\r\nstruct klist_iter iter;\r\nif (!cont->match(cont, dev))\r\ncontinue;\r\nif (attribute_container_no_classdevs(cont)) {\r\nfn(cont, dev, NULL);\r\ncontinue;\r\n}\r\nklist_for_each_entry(ic, &cont->containers, node, &iter) {\r\nif (dev == ic->classdev.parent)\r\nfn(cont, dev, &ic->classdev);\r\n}\r\n}\r\nmutex_unlock(&attribute_container_mutex);\r\n}\r\nvoid\r\nattribute_container_trigger(struct device *dev,\r\nint (*fn)(struct attribute_container *,\r\nstruct device *))\r\n{\r\nstruct attribute_container *cont;\r\nmutex_lock(&attribute_container_mutex);\r\nlist_for_each_entry(cont, &attribute_container_list, node) {\r\nif (cont->match(cont, dev))\r\nfn(cont, dev);\r\n}\r\nmutex_unlock(&attribute_container_mutex);\r\n}\r\nint\r\nattribute_container_add_attrs(struct device *classdev)\r\n{\r\nstruct attribute_container *cont =\r\nattribute_container_classdev_to_container(classdev);\r\nstruct device_attribute **attrs = cont->attrs;\r\nint i, error;\r\nBUG_ON(attrs && cont->grp);\r\nif (!attrs && !cont->grp)\r\nreturn 0;\r\nif (cont->grp)\r\nreturn sysfs_create_group(&classdev->kobj, cont->grp);\r\nfor (i = 0; attrs[i]; i++) {\r\nsysfs_attr_init(&attrs[i]->attr);\r\nerror = device_create_file(classdev, attrs[i]);\r\nif (error)\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nattribute_container_add_class_device(struct device *classdev)\r\n{\r\nint error = device_add(classdev);\r\nif (error)\r\nreturn error;\r\nreturn attribute_container_add_attrs(classdev);\r\n}\r\nint\r\nattribute_container_add_class_device_adapter(struct attribute_container *cont,\r\nstruct device *dev,\r\nstruct device *classdev)\r\n{\r\nreturn attribute_container_add_class_device(classdev);\r\n}\r\nvoid\r\nattribute_container_remove_attrs(struct device *classdev)\r\n{\r\nstruct attribute_container *cont =\r\nattribute_container_classdev_to_container(classdev);\r\nstruct device_attribute **attrs = cont->attrs;\r\nint i;\r\nif (!attrs && !cont->grp)\r\nreturn;\r\nif (cont->grp) {\r\nsysfs_remove_group(&classdev->kobj, cont->grp);\r\nreturn ;\r\n}\r\nfor (i = 0; attrs[i]; i++)\r\ndevice_remove_file(classdev, attrs[i]);\r\n}\r\nvoid\r\nattribute_container_class_device_del(struct device *classdev)\r\n{\r\nattribute_container_remove_attrs(classdev);\r\ndevice_del(classdev);\r\n}\r\nstruct device *\r\nattribute_container_find_class_device(struct attribute_container *cont,\r\nstruct device *dev)\r\n{\r\nstruct device *cdev = NULL;\r\nstruct internal_container *ic;\r\nstruct klist_iter iter;\r\nklist_for_each_entry(ic, &cont->containers, node, &iter) {\r\nif (ic->classdev.parent == dev) {\r\ncdev = &ic->classdev;\r\nklist_iter_exit(&iter);\r\nbreak;\r\n}\r\n}\r\nreturn cdev;\r\n}
