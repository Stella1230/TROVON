static s32 pm121_correct(s32 new_setpoint,\r\nunsigned int control_id,\r\ns32 min)\r\n{\r\ns32 new_min;\r\nstruct pm121_correction *correction;\r\ncorrection = &corrections[control_id][pm121_mach_model - 2];\r\nnew_min = (average_power * correction->slope) >> 16;\r\nnew_min += correction->offset;\r\nnew_min = (new_min >> 16) + min;\r\nreturn max3(new_setpoint, new_min, 0);\r\n}\r\nstatic s32 pm121_connect(unsigned int control_id, s32 setpoint)\r\n{\r\ns32 new_min, value, new_setpoint;\r\nif (pm121_connection->control_id == control_id) {\r\ncontrols[control_id]->ops->get_value(controls[control_id],\r\n&value);\r\nnew_min = value * pm121_connection->correction.slope;\r\nnew_min += pm121_connection->correction.offset;\r\nif (new_min > 0) {\r\nnew_setpoint = max(setpoint, (new_min >> 16));\r\nif (new_setpoint != setpoint) {\r\npr_debug("pm121: %s depending on %s, "\r\n"corrected from %d to %d RPM\n",\r\ncontrols[control_id]->name,\r\ncontrols[pm121_connection->ref_id]->name,\r\n(int) setpoint, (int) new_setpoint);\r\n}\r\n} else\r\nnew_setpoint = setpoint;\r\n}\r\nelse\r\nnew_setpoint = setpoint;\r\nreturn new_setpoint;\r\n}\r\nstatic void pm121_create_sys_fans(int loop_id)\r\n{\r\nstruct pm121_sys_param *param = NULL;\r\nstruct wf_pid_param pid_param;\r\nstruct wf_control *control = NULL;\r\nint i;\r\nfor (i = 0; i < PM121_NUM_CONFIGS; i++) {\r\nif (pm121_sys_all_params[loop_id][i].model_id == pm121_mach_model) {\r\nparam = &(pm121_sys_all_params[loop_id][i]);\r\nbreak;\r\n}\r\n}\r\nif (param == NULL) {\r\nprintk(KERN_WARNING "pm121: %s fan config not found "\r\n" for this machine model\n",\r\nloop_names[loop_id]);\r\ngoto fail;\r\n}\r\ncontrol = controls[param->control_id];\r\npm121_sys_state[loop_id] = kmalloc(sizeof(struct pm121_sys_state),\r\nGFP_KERNEL);\r\nif (pm121_sys_state[loop_id] == NULL) {\r\nprintk(KERN_WARNING "pm121: Memory allocation error\n");\r\ngoto fail;\r\n}\r\npm121_sys_state[loop_id]->ticks = 1;\r\npid_param.gd = PM121_SYS_GD;\r\npid_param.gp = param->gp;\r\npid_param.gr = PM121_SYS_GR;\r\npid_param.interval = PM121_SYS_INTERVAL;\r\npid_param.history_len = PM121_SYS_HISTORY_SIZE;\r\npid_param.itarget = param->itarget;\r\nif(control)\r\n{\r\npid_param.min = control->ops->get_min(control);\r\npid_param.max = control->ops->get_max(control);\r\n} else {\r\npid_param.min = 0;\r\npid_param.max = 0;\r\n}\r\nwf_pid_init(&pm121_sys_state[loop_id]->pid, &pid_param);\r\npr_debug("pm121: %s Fan control loop initialized.\n"\r\n" itarged=%d.%03d, min=%d RPM, max=%d RPM\n",\r\nloop_names[loop_id], FIX32TOPRINT(pid_param.itarget),\r\npid_param.min, pid_param.max);\r\nreturn;\r\nfail:\r\nprintk(KERN_WARNING "pm121: failed to set up %s loop "\r\n"setting \"%s\" to max speed.\n",\r\nloop_names[loop_id], control ? control->name : "uninitialized value");\r\nif (control)\r\nwf_control_set_max(control);\r\n}\r\nstatic void pm121_sys_fans_tick(int loop_id)\r\n{\r\nstruct pm121_sys_param *param;\r\nstruct pm121_sys_state *st;\r\nstruct wf_sensor *sensor;\r\nstruct wf_control *control;\r\ns32 temp, new_setpoint;\r\nint rc;\r\nparam = &(pm121_sys_all_params[loop_id][pm121_mach_model-2]);\r\nst = pm121_sys_state[loop_id];\r\nsensor = *(param->sensor);\r\ncontrol = controls[param->control_id];\r\nif (--st->ticks != 0) {\r\nif (pm121_readjust)\r\ngoto readjust;\r\nreturn;\r\n}\r\nst->ticks = PM121_SYS_INTERVAL;\r\nrc = sensor->ops->get_value(sensor, &temp);\r\nif (rc) {\r\nprintk(KERN_WARNING "windfarm: %s sensor error %d\n",\r\nsensor->name, rc);\r\npm121_failure_state |= FAILURE_SENSOR;\r\nreturn;\r\n}\r\npr_debug("pm121: %s Fan tick ! %s: %d.%03d\n",\r\nloop_names[loop_id], sensor->name,\r\nFIX32TOPRINT(temp));\r\nnew_setpoint = wf_pid_run(&st->pid, temp);\r\nnew_setpoint = pm121_correct(new_setpoint,\r\nparam->control_id,\r\nst->pid.param.min);\r\nnew_setpoint = pm121_connect(param->control_id, new_setpoint);\r\nif (new_setpoint == st->setpoint)\r\nreturn;\r\nst->setpoint = new_setpoint;\r\npr_debug("pm121: %s corrected setpoint: %d RPM\n",\r\ncontrol->name, (int)new_setpoint);\r\nreadjust:\r\nif (control && pm121_failure_state == 0) {\r\nrc = control->ops->set_value(control, st->setpoint);\r\nif (rc) {\r\nprintk(KERN_WARNING "windfarm: %s fan error %d\n",\r\ncontrol->name, rc);\r\npm121_failure_state |= FAILURE_FAN;\r\n}\r\n}\r\n}\r\nstatic void pm121_create_cpu_fans(void)\r\n{\r\nstruct wf_cpu_pid_param pid_param;\r\nconst struct smu_sdbp_header *hdr;\r\nstruct smu_sdbp_cpupiddata *piddata;\r\nstruct smu_sdbp_fvt *fvt;\r\nstruct wf_control *fan_cpu;\r\ns32 tmax, tdelta, maxpow, powadj;\r\nfan_cpu = controls[FAN_CPU];\r\nhdr = smu_get_sdb_partition(SMU_SDB_CPUPIDDATA_ID, NULL);\r\nif (hdr == 0) {\r\nprintk(KERN_WARNING "pm121: CPU PID fan config not found.\n");\r\ngoto fail;\r\n}\r\npiddata = (struct smu_sdbp_cpupiddata *)&hdr[1];\r\nhdr = smu_get_sdb_partition(SMU_SDB_FVT_ID, NULL);\r\nif (hdr) {\r\nfvt = (struct smu_sdbp_fvt *)&hdr[1];\r\ntmax = ((s32)fvt->maxtemp) << 16;\r\n} else\r\ntmax = 0x5e0000;\r\npm121_cpu_state = kmalloc(sizeof(struct pm121_cpu_state),\r\nGFP_KERNEL);\r\nif (pm121_cpu_state == NULL)\r\ngoto fail;\r\npm121_cpu_state->ticks = 1;\r\npid_param.interval = PM121_CPU_INTERVAL;\r\npid_param.history_len = piddata->history_len;\r\nif (pid_param.history_len > WF_CPU_PID_MAX_HISTORY) {\r\nprintk(KERN_WARNING "pm121: History size overflow on "\r\n"CPU control loop (%d)\n", piddata->history_len);\r\npid_param.history_len = WF_CPU_PID_MAX_HISTORY;\r\n}\r\npid_param.gd = piddata->gd;\r\npid_param.gp = piddata->gp;\r\npid_param.gr = piddata->gr / pid_param.history_len;\r\ntdelta = ((s32)piddata->target_temp_delta) << 16;\r\nmaxpow = ((s32)piddata->max_power) << 16;\r\npowadj = ((s32)piddata->power_adj) << 16;\r\npid_param.tmax = tmax;\r\npid_param.ttarget = tmax - tdelta;\r\npid_param.pmaxadj = maxpow - powadj;\r\npid_param.min = fan_cpu->ops->get_min(fan_cpu);\r\npid_param.max = fan_cpu->ops->get_max(fan_cpu);\r\nwf_cpu_pid_init(&pm121_cpu_state->pid, &pid_param);\r\npr_debug("pm121: CPU Fan control initialized.\n");\r\npr_debug(" ttarged=%d.%03d, tmax=%d.%03d, min=%d RPM, max=%d RPM,\n",\r\nFIX32TOPRINT(pid_param.ttarget), FIX32TOPRINT(pid_param.tmax),\r\npid_param.min, pid_param.max);\r\nreturn;\r\nfail:\r\nprintk(KERN_WARNING "pm121: CPU fan config not found, max fan speed\n");\r\nif (controls[CPUFREQ])\r\nwf_control_set_max(controls[CPUFREQ]);\r\nif (fan_cpu)\r\nwf_control_set_max(fan_cpu);\r\n}\r\nstatic void pm121_cpu_fans_tick(struct pm121_cpu_state *st)\r\n{\r\ns32 new_setpoint, temp, power;\r\nstruct wf_control *fan_cpu = NULL;\r\nint rc;\r\nif (--st->ticks != 0) {\r\nif (pm121_readjust)\r\ngoto readjust;\r\nreturn;\r\n}\r\nst->ticks = PM121_CPU_INTERVAL;\r\nfan_cpu = controls[FAN_CPU];\r\nrc = sensor_cpu_temp->ops->get_value(sensor_cpu_temp, &temp);\r\nif (rc) {\r\nprintk(KERN_WARNING "pm121: CPU temp sensor error %d\n",\r\nrc);\r\npm121_failure_state |= FAILURE_SENSOR;\r\nreturn;\r\n}\r\nrc = sensor_cpu_power->ops->get_value(sensor_cpu_power, &power);\r\nif (rc) {\r\nprintk(KERN_WARNING "pm121: CPU power sensor error %d\n",\r\nrc);\r\npm121_failure_state |= FAILURE_SENSOR;\r\nreturn;\r\n}\r\npr_debug("pm121: CPU Fans tick ! CPU temp: %d.%03dÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢&#8218;ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â°C, power: %d.%03d\n",\r\nFIX32TOPRINT(temp), FIX32TOPRINT(power));\r\nif (temp > st->pid.param.tmax)\r\npm121_failure_state |= FAILURE_OVERTEMP;\r\nnew_setpoint = wf_cpu_pid_run(&st->pid, power, temp);\r\nnew_setpoint = pm121_correct(new_setpoint,\r\nFAN_CPU,\r\nst->pid.param.min);\r\nnew_setpoint = pm121_connect(FAN_CPU, new_setpoint);\r\nif (st->setpoint == new_setpoint)\r\nreturn;\r\nst->setpoint = new_setpoint;\r\npr_debug("pm121: CPU corrected setpoint: %d RPM\n", (int)new_setpoint);\r\nreadjust:\r\nif (fan_cpu && pm121_failure_state == 0) {\r\nrc = fan_cpu->ops->set_value(fan_cpu, st->setpoint);\r\nif (rc) {\r\nprintk(KERN_WARNING "pm121: %s fan error %d\n",\r\nfan_cpu->name, rc);\r\npm121_failure_state |= FAILURE_FAN;\r\n}\r\n}\r\n}\r\nstatic void pm121_tick(void)\r\n{\r\nunsigned int last_failure = pm121_failure_state;\r\nunsigned int new_failure;\r\ns32 total_power;\r\nint i;\r\nif (!pm121_started) {\r\npr_debug("pm121: creating control loops !\n");\r\nfor (i = 0; i < N_LOOPS; i++)\r\npm121_create_sys_fans(i);\r\npm121_create_cpu_fans();\r\npm121_started = 1;\r\n}\r\nif (pm121_skipping && --pm121_skipping)\r\nreturn;\r\ntotal_power = 0;\r\nfor (i = 0; i < pm121_cpu_state->pid.param.history_len; i++)\r\ntotal_power += pm121_cpu_state->pid.powers[i];\r\naverage_power = total_power / pm121_cpu_state->pid.param.history_len;\r\npm121_failure_state = 0;\r\nfor (i = 0 ; i < N_LOOPS; i++) {\r\nif (pm121_sys_state[i])\r\npm121_sys_fans_tick(i);\r\n}\r\nif (pm121_cpu_state)\r\npm121_cpu_fans_tick(pm121_cpu_state);\r\npm121_readjust = 0;\r\nnew_failure = pm121_failure_state & ~last_failure;\r\nif (pm121_failure_state && !last_failure) {\r\nfor (i = 0; i < N_CONTROLS; i++) {\r\nif (controls[i])\r\nwf_control_set_max(controls[i]);\r\n}\r\n}\r\nif (!pm121_failure_state && last_failure) {\r\nif (controls[CPUFREQ])\r\nwf_control_set_min(controls[CPUFREQ]);\r\npm121_readjust = 1;\r\n}\r\nif (new_failure & FAILURE_OVERTEMP) {\r\nwf_set_overtemp();\r\npm121_skipping = 2;\r\npm121_overtemp = true;\r\n}\r\nif (!pm121_failure_state && pm121_overtemp) {\r\nwf_clear_overtemp();\r\npm121_overtemp = false;\r\n}\r\n}\r\nstatic struct wf_control* pm121_register_control(struct wf_control *ct,\r\nconst char *match,\r\nunsigned int id)\r\n{\r\nif (controls[id] == NULL && !strcmp(ct->name, match)) {\r\nif (wf_get_control(ct) == 0)\r\ncontrols[id] = ct;\r\n}\r\nreturn controls[id];\r\n}\r\nstatic void pm121_new_control(struct wf_control *ct)\r\n{\r\nint all = 1;\r\nif (pm121_all_controls_ok)\r\nreturn;\r\nall = pm121_register_control(ct, "optical-drive-fan", FAN_OD) && all;\r\nall = pm121_register_control(ct, "hard-drive-fan", FAN_HD) && all;\r\nall = pm121_register_control(ct, "cpu-fan", FAN_CPU) && all;\r\nall = pm121_register_control(ct, "cpufreq-clamp", CPUFREQ) && all;\r\nif (all)\r\npm121_all_controls_ok = 1;\r\n}\r\nstatic struct wf_sensor* pm121_register_sensor(struct wf_sensor *sensor,\r\nconst char *match,\r\nstruct wf_sensor **var)\r\n{\r\nif (*var == NULL && !strcmp(sensor->name, match)) {\r\nif (wf_get_sensor(sensor) == 0)\r\n*var = sensor;\r\n}\r\nreturn *var;\r\n}\r\nstatic void pm121_new_sensor(struct wf_sensor *sr)\r\n{\r\nint all = 1;\r\nif (pm121_all_sensors_ok)\r\nreturn;\r\nall = pm121_register_sensor(sr, "cpu-temp",\r\n&sensor_cpu_temp) && all;\r\nall = pm121_register_sensor(sr, "cpu-current",\r\n&sensor_cpu_current) && all;\r\nall = pm121_register_sensor(sr, "cpu-voltage",\r\n&sensor_cpu_voltage) && all;\r\nall = pm121_register_sensor(sr, "cpu-power",\r\n&sensor_cpu_power) && all;\r\nall = pm121_register_sensor(sr, "hard-drive-temp",\r\n&sensor_hard_drive_temp) && all;\r\nall = pm121_register_sensor(sr, "optical-drive-temp",\r\n&sensor_optical_drive_temp) && all;\r\nall = pm121_register_sensor(sr, "incoming-air-temp",\r\n&sensor_incoming_air_temp) && all;\r\nall = pm121_register_sensor(sr, "north-bridge-temp",\r\n&sensor_north_bridge_temp) && all;\r\nall = pm121_register_sensor(sr, "gpu-temp",\r\n&sensor_gpu_temp) && all;\r\nif (all)\r\npm121_all_sensors_ok = 1;\r\n}\r\nstatic int pm121_notify(struct notifier_block *self,\r\nunsigned long event, void *data)\r\n{\r\nswitch (event) {\r\ncase WF_EVENT_NEW_CONTROL:\r\npr_debug("pm121: new control %s detected\n",\r\n((struct wf_control *)data)->name);\r\npm121_new_control(data);\r\nbreak;\r\ncase WF_EVENT_NEW_SENSOR:\r\npr_debug("pm121: new sensor %s detected\n",\r\n((struct wf_sensor *)data)->name);\r\npm121_new_sensor(data);\r\nbreak;\r\ncase WF_EVENT_TICK:\r\nif (pm121_all_controls_ok && pm121_all_sensors_ok)\r\npm121_tick();\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pm121_init_pm(void)\r\n{\r\nconst struct smu_sdbp_header *hdr;\r\nhdr = smu_get_sdb_partition(SMU_SDB_SENSORTREE_ID, NULL);\r\nif (hdr != 0) {\r\nstruct smu_sdbp_sensortree *st =\r\n(struct smu_sdbp_sensortree *)&hdr[1];\r\npm121_mach_model = st->model_id;\r\n}\r\npm121_connection = &pm121_connections[pm121_mach_model - 2];\r\nprintk(KERN_INFO "pm121: Initializing for iMac G5 iSight model ID %d\n",\r\npm121_mach_model);\r\nreturn 0;\r\n}\r\nstatic int pm121_probe(struct platform_device *ddev)\r\n{\r\nwf_register_client(&pm121_events);\r\nreturn 0;\r\n}\r\nstatic int pm121_remove(struct platform_device *ddev)\r\n{\r\nwf_unregister_client(&pm121_events);\r\nreturn 0;\r\n}\r\nstatic int __init pm121_init(void)\r\n{\r\nint rc = -ENODEV;\r\nif (of_machine_is_compatible("PowerMac12,1"))\r\nrc = pm121_init_pm();\r\nif (rc == 0) {\r\nrequest_module("windfarm_smu_controls");\r\nrequest_module("windfarm_smu_sensors");\r\nrequest_module("windfarm_smu_sat");\r\nrequest_module("windfarm_lm75_sensor");\r\nrequest_module("windfarm_max6690_sensor");\r\nrequest_module("windfarm_cpufreq_clamp");\r\nplatform_driver_register(&pm121_driver);\r\n}\r\nreturn rc;\r\n}\r\nstatic void __exit pm121_exit(void)\r\n{\r\nplatform_driver_unregister(&pm121_driver);\r\n}
