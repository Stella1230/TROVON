static inline void *dma_alloc(dma_addr_t *daddr)\r\n{\r\nreturn kmalloc(SPI_DMA_BUF_LEN, GFP_KERNEL);\r\n}\r\nstatic inline void dma_free(void *cpu_addr, dma_addr_t handle)\r\n{\r\nkfree(cpu_addr);\r\n}\r\nstatic inline void *dma_alloc(dma_addr_t *daddr)\r\n{\r\nreturn dma_alloc_coherent(NULL, SPI_DMA_BUF_LEN, daddr,\r\nGFP_KERNEL);\r\n}\r\nstatic inline void dma_free(void *cpu_addr, dma_addr_t handle)\r\n{\r\ndma_free_coherent(NULL, SPI_DMA_BUF_LEN, cpu_addr, handle);\r\n}\r\nstatic inline void driver_debugfs_create(void)\r\n{\r\ndbgfs_root = debugfs_create_dir(cfspi_spi_driver.driver.name, NULL);\r\n}\r\nstatic inline void driver_debugfs_remove(void)\r\n{\r\ndebugfs_remove(dbgfs_root);\r\n}\r\nstatic inline void dev_debugfs_rem(struct cfspi *cfspi)\r\n{\r\ndebugfs_remove(cfspi->dbgfs_frame);\r\ndebugfs_remove(cfspi->dbgfs_state);\r\ndebugfs_remove(cfspi->dbgfs_dir);\r\n}\r\nstatic ssize_t dbgfs_state(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar *buf;\r\nint len = 0;\r\nssize_t size;\r\nstruct cfspi *cfspi = file->private_data;\r\nbuf = kzalloc(DEBUGFS_BUF_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn 0;\r\nlen += snprintf((buf + len), (DEBUGFS_BUF_SIZE - len),\r\n"CAIF SPI debug information:\n");\r\nlen += snprintf((buf + len), (DEBUGFS_BUF_SIZE - len), FLAVOR);\r\nlen += snprintf((buf + len), (DEBUGFS_BUF_SIZE - len),\r\n"STATE: %d\n", cfspi->dbg_state);\r\nlen += snprintf((buf + len), (DEBUGFS_BUF_SIZE - len),\r\n"Previous CMD: 0x%x\n", cfspi->pcmd);\r\nlen += snprintf((buf + len), (DEBUGFS_BUF_SIZE - len),\r\n"Current CMD: 0x%x\n", cfspi->cmd);\r\nlen += snprintf((buf + len), (DEBUGFS_BUF_SIZE - len),\r\n"Previous TX len: %d\n", cfspi->tx_ppck_len);\r\nlen += snprintf((buf + len), (DEBUGFS_BUF_SIZE - len),\r\n"Previous RX len: %d\n", cfspi->rx_ppck_len);\r\nlen += snprintf((buf + len), (DEBUGFS_BUF_SIZE - len),\r\n"Current TX len: %d\n", cfspi->tx_cpck_len);\r\nlen += snprintf((buf + len), (DEBUGFS_BUF_SIZE - len),\r\n"Current RX len: %d\n", cfspi->rx_cpck_len);\r\nlen += snprintf((buf + len), (DEBUGFS_BUF_SIZE - len),\r\n"Next TX len: %d\n", cfspi->tx_npck_len);\r\nlen += snprintf((buf + len), (DEBUGFS_BUF_SIZE - len),\r\n"Next RX len: %d\n", cfspi->rx_npck_len);\r\nif (len > DEBUGFS_BUF_SIZE)\r\nlen = DEBUGFS_BUF_SIZE;\r\nsize = simple_read_from_buffer(user_buf, count, ppos, buf, len);\r\nkfree(buf);\r\nreturn size;\r\n}\r\nstatic ssize_t print_frame(char *buf, size_t size, char *frm,\r\nsize_t count, size_t cut)\r\n{\r\nint len = 0;\r\nint i;\r\nfor (i = 0; i < count; i++) {\r\nlen += snprintf((buf + len), (size - len),\r\n"[0x" BYTE_HEX_FMT "]",\r\nfrm[i]);\r\nif ((i == cut) && (count > (cut * 2))) {\r\ni = count - cut;\r\nlen += snprintf((buf + len), (size - len),\r\n"--- %u bytes skipped ---\n",\r\n(int)(count - (cut * 2)));\r\n}\r\nif ((!(i % 10)) && i) {\r\nlen += snprintf((buf + len), (DEBUGFS_BUF_SIZE - len),\r\n"\n");\r\n}\r\n}\r\nlen += snprintf((buf + len), (DEBUGFS_BUF_SIZE - len), "\n");\r\nreturn len;\r\n}\r\nstatic ssize_t dbgfs_frame(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar *buf;\r\nint len = 0;\r\nssize_t size;\r\nstruct cfspi *cfspi;\r\ncfspi = file->private_data;\r\nbuf = kzalloc(DEBUGFS_BUF_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn 0;\r\nlen += snprintf((buf + len), (DEBUGFS_BUF_SIZE - len),\r\n"Current frame:\n");\r\nlen += snprintf((buf + len), (DEBUGFS_BUF_SIZE - len),\r\n"Tx data (Len: %d):\n", cfspi->tx_cpck_len);\r\nlen += print_frame((buf + len), (DEBUGFS_BUF_SIZE - len),\r\ncfspi->xfer.va_tx[0],\r\n(cfspi->tx_cpck_len + SPI_CMD_SZ), 100);\r\nlen += snprintf((buf + len), (DEBUGFS_BUF_SIZE - len),\r\n"Rx data (Len: %d):\n", cfspi->rx_cpck_len);\r\nlen += print_frame((buf + len), (DEBUGFS_BUF_SIZE - len),\r\ncfspi->xfer.va_rx,\r\n(cfspi->rx_cpck_len + SPI_CMD_SZ), 100);\r\nsize = simple_read_from_buffer(user_buf, count, ppos, buf, len);\r\nkfree(buf);\r\nreturn size;\r\n}\r\nstatic inline void dev_debugfs_add(struct cfspi *cfspi)\r\n{\r\ncfspi->dbgfs_dir = debugfs_create_dir(cfspi->pdev->name, dbgfs_root);\r\ncfspi->dbgfs_state = debugfs_create_file("state", S_IRUGO,\r\ncfspi->dbgfs_dir, cfspi,\r\n&dbgfs_state_fops);\r\ncfspi->dbgfs_frame = debugfs_create_file("frame", S_IRUGO,\r\ncfspi->dbgfs_dir, cfspi,\r\n&dbgfs_frame_fops);\r\n}\r\ninline void cfspi_dbg_state(struct cfspi *cfspi, int state)\r\n{\r\ncfspi->dbg_state = state;\r\n}\r\nstatic inline void driver_debugfs_create(void)\r\n{\r\n}\r\nstatic inline void driver_debugfs_remove(void)\r\n{\r\n}\r\nstatic inline void dev_debugfs_add(struct cfspi *cfspi)\r\n{\r\n}\r\nstatic inline void dev_debugfs_rem(struct cfspi *cfspi)\r\n{\r\n}\r\ninline void cfspi_dbg_state(struct cfspi *cfspi, int state)\r\n{\r\n}\r\nstatic ssize_t show_up_head_align(struct device_driver *driver, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", spi_up_head_align);\r\n}\r\nstatic ssize_t show_up_tail_align(struct device_driver *driver, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", spi_up_tail_align);\r\n}\r\nstatic ssize_t show_down_head_align(struct device_driver *driver, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", spi_down_head_align);\r\n}\r\nstatic ssize_t show_down_tail_align(struct device_driver *driver, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", spi_down_tail_align);\r\n}\r\nstatic ssize_t show_frame_align(struct device_driver *driver, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", spi_frm_align);\r\n}\r\nint cfspi_xmitfrm(struct cfspi *cfspi, u8 *buf, size_t len)\r\n{\r\nu8 *dst = buf;\r\ncaif_assert(buf);\r\nif (cfspi->slave && !cfspi->slave_talked)\r\ncfspi->slave_talked = true;\r\ndo {\r\nstruct sk_buff *skb;\r\nstruct caif_payload_info *info;\r\nint spad = 0;\r\nint epad;\r\nskb = skb_dequeue(&cfspi->chead);\r\nif (!skb)\r\nbreak;\r\ninfo = (struct caif_payload_info *)&skb->cb;\r\nif (spi_up_head_align > 1) {\r\nspad = 1 + PAD_POW2((info->hdr_len + 1), spi_up_head_align);\r\n*dst = (u8)(spad - 1);\r\ndst += spad;\r\n}\r\nskb_copy_bits(skb, 0, dst, skb->len);\r\ndst += skb->len;\r\ncfspi->ndev->stats.tx_packets++;\r\ncfspi->ndev->stats.tx_bytes += skb->len;\r\nepad = PAD_POW2((skb->len + spad), spi_up_tail_align);\r\ndst += epad;\r\ndev_kfree_skb(skb);\r\n} while ((dst - buf) < len);\r\nreturn dst - buf;\r\n}\r\nint cfspi_xmitlen(struct cfspi *cfspi)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nint frm_len = 0;\r\nint pkts = 0;\r\nwhile (skb_peek(&cfspi->chead)) {\r\nskb = skb_dequeue_tail(&cfspi->chead);\r\nskb_queue_head(&cfspi->qhead, skb);\r\n}\r\ndo {\r\nstruct caif_payload_info *info = NULL;\r\nint spad = 0;\r\nint epad = 0;\r\nskb = skb_dequeue(&cfspi->qhead);\r\nif (!skb)\r\nbreak;\r\ninfo = (struct caif_payload_info *)&skb->cb;\r\nif (spi_up_head_align > 1)\r\nspad = 1 + PAD_POW2((info->hdr_len + 1), spi_up_head_align);\r\nepad = PAD_POW2((skb->len + spad), spi_up_tail_align);\r\nif ((skb->len + spad + epad + frm_len) <= CAIF_MAX_SPI_FRAME) {\r\nskb_queue_tail(&cfspi->chead, skb);\r\npkts++;\r\nfrm_len += skb->len + spad + epad;\r\n} else {\r\nskb_queue_head(&cfspi->qhead, skb);\r\nbreak;\r\n}\r\n} while (pkts <= CAIF_MAX_SPI_PKTS);\r\nif (cfspi->flow_off_sent && cfspi->qhead.qlen < cfspi->qd_low_mark &&\r\ncfspi->cfdev.flowctrl) {\r\ncfspi->flow_off_sent = 0;\r\ncfspi->cfdev.flowctrl(cfspi->ndev, 1);\r\n}\r\nreturn frm_len;\r\n}\r\nstatic void cfspi_ss_cb(bool assert, struct cfspi_ifc *ifc)\r\n{\r\nstruct cfspi *cfspi = (struct cfspi *)ifc->priv;\r\nif (cfspi->slave && !cfspi->slave_talked) {\r\nprintk(KERN_WARNING "CFSPI: Spurious SS interrupt.\n");\r\nreturn;\r\n}\r\nif (!in_interrupt())\r\nspin_lock(&cfspi->lock);\r\nif (assert) {\r\nset_bit(SPI_SS_ON, &cfspi->state);\r\nset_bit(SPI_XFER, &cfspi->state);\r\n} else {\r\nset_bit(SPI_SS_OFF, &cfspi->state);\r\n}\r\nif (!in_interrupt())\r\nspin_unlock(&cfspi->lock);\r\nif (assert)\r\nwake_up_interruptible(&cfspi->wait);\r\n}\r\nstatic void cfspi_xfer_done_cb(struct cfspi_ifc *ifc)\r\n{\r\nstruct cfspi *cfspi = (struct cfspi *)ifc->priv;\r\ncomplete(&cfspi->comp);\r\n}\r\nstatic int cfspi_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct cfspi *cfspi = NULL;\r\nunsigned long flags;\r\nif (!dev)\r\nreturn -EINVAL;\r\ncfspi = netdev_priv(dev);\r\nskb_queue_tail(&cfspi->qhead, skb);\r\nspin_lock_irqsave(&cfspi->lock, flags);\r\nif (!test_and_set_bit(SPI_XFER, &cfspi->state)) {\r\nwake_up_interruptible(&cfspi->wait);\r\n}\r\nspin_unlock_irqrestore(&cfspi->lock, flags);\r\nif (!cfspi->flow_off_sent &&\r\ncfspi->qhead.qlen > cfspi->qd_high_mark &&\r\ncfspi->cfdev.flowctrl) {\r\ncfspi->flow_off_sent = 1;\r\ncfspi->cfdev.flowctrl(cfspi->ndev, 0);\r\n}\r\nreturn 0;\r\n}\r\nint cfspi_rxfrm(struct cfspi *cfspi, u8 *buf, size_t len)\r\n{\r\nu8 *src = buf;\r\ncaif_assert(buf != NULL);\r\ndo {\r\nint res;\r\nstruct sk_buff *skb = NULL;\r\nint spad = 0;\r\nint epad = 0;\r\nu8 *dst = NULL;\r\nint pkt_len = 0;\r\nif (spi_down_head_align > 1) {\r\nspad = 1 + *src;\r\nsrc += spad;\r\n}\r\npkt_len = *src;\r\npkt_len |= ((*(src+1)) << 8) & 0xFF00;\r\npkt_len += 2;\r\nskb = netdev_alloc_skb(cfspi->ndev, pkt_len + 1);\r\ncaif_assert(skb != NULL);\r\ndst = skb_put(skb, pkt_len);\r\nmemcpy(dst, src, pkt_len);\r\nsrc += pkt_len;\r\nskb->protocol = htons(ETH_P_CAIF);\r\nskb_reset_mac_header(skb);\r\nif (!spi_loop)\r\nres = netif_rx_ni(skb);\r\nelse\r\nres = cfspi_xmit(skb, cfspi->ndev);\r\nif (!res) {\r\ncfspi->ndev->stats.rx_packets++;\r\ncfspi->ndev->stats.rx_bytes += pkt_len;\r\n} else\r\ncfspi->ndev->stats.rx_dropped++;\r\nepad = PAD_POW2((pkt_len + spad), spi_down_tail_align);\r\nsrc += epad;\r\n} while ((src - buf) < len);\r\nreturn src - buf;\r\n}\r\nstatic int cfspi_open(struct net_device *dev)\r\n{\r\nnetif_wake_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int cfspi_close(struct net_device *dev)\r\n{\r\nnetif_stop_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int cfspi_init(struct net_device *dev)\r\n{\r\nint res = 0;\r\nstruct cfspi *cfspi = netdev_priv(dev);\r\ncfspi->flow_off_sent = 0;\r\ncfspi->qd_low_mark = LOW_WATER_MARK;\r\ncfspi->qd_high_mark = HIGH_WATER_MARK;\r\nif (!strncmp(cfspi_spi_driver.driver.name, "cfspi_sspi", 10)) {\r\ncfspi->slave = true;\r\ncfspi->slave_talked = false;\r\n} else {\r\ncfspi->slave = false;\r\ncfspi->slave_talked = false;\r\n}\r\ncfspi->xfer.va_tx[0] = dma_alloc(&cfspi->xfer.pa_tx[0]);\r\nif (!cfspi->xfer.va_tx[0]) {\r\nres = -ENODEV;\r\ngoto err_dma_alloc_tx_0;\r\n}\r\ncfspi->xfer.va_rx = dma_alloc(&cfspi->xfer.pa_rx);\r\nif (!cfspi->xfer.va_rx) {\r\nres = -ENODEV;\r\ngoto err_dma_alloc_rx;\r\n}\r\nINIT_WORK(&cfspi->work, cfspi_xfer);\r\nspin_lock_init(&cfspi->lock);\r\ncfspi->flow_stop = false;\r\ninit_waitqueue_head(&cfspi->wait);\r\ncfspi->wq = create_singlethread_workqueue(dev->name);\r\nif (!cfspi->wq) {\r\nprintk(KERN_WARNING "CFSPI: failed to create work queue.\n");\r\nres = -ENODEV;\r\ngoto err_create_wq;\r\n}\r\ninit_completion(&cfspi->comp);\r\ndev_debugfs_add(cfspi);\r\ncfspi->ifc.ss_cb = cfspi_ss_cb;\r\ncfspi->ifc.xfer_done_cb = cfspi_xfer_done_cb;\r\ncfspi->ifc.priv = cfspi;\r\nspin_lock(&cfspi_list_lock);\r\nlist_add_tail(&cfspi->list, &cfspi_list);\r\nspin_unlock(&cfspi_list_lock);\r\nqueue_work(cfspi->wq, &cfspi->work);\r\nreturn 0;\r\nerr_create_wq:\r\ndma_free(cfspi->xfer.va_rx, cfspi->xfer.pa_rx);\r\nerr_dma_alloc_rx:\r\ndma_free(cfspi->xfer.va_tx[0], cfspi->xfer.pa_tx[0]);\r\nerr_dma_alloc_tx_0:\r\nreturn res;\r\n}\r\nstatic void cfspi_uninit(struct net_device *dev)\r\n{\r\nstruct cfspi *cfspi = netdev_priv(dev);\r\nspin_lock(&cfspi_list_lock);\r\nlist_del(&cfspi->list);\r\nspin_unlock(&cfspi_list_lock);\r\ncfspi->ndev = NULL;\r\ndma_free(cfspi->xfer.va_rx, cfspi->xfer.pa_rx);\r\ndma_free(cfspi->xfer.va_tx[0], cfspi->xfer.pa_tx[0]);\r\nset_bit(SPI_TERMINATE, &cfspi->state);\r\nwake_up_interruptible(&cfspi->wait);\r\ndestroy_workqueue(cfspi->wq);\r\ndev_debugfs_rem(cfspi);\r\nreturn;\r\n}\r\nstatic void cfspi_setup(struct net_device *dev)\r\n{\r\nstruct cfspi *cfspi = netdev_priv(dev);\r\ndev->features = 0;\r\ndev->netdev_ops = &cfspi_ops;\r\ndev->type = ARPHRD_CAIF;\r\ndev->flags = IFF_NOARP | IFF_POINTOPOINT;\r\ndev->tx_queue_len = 0;\r\ndev->mtu = SPI_MAX_PAYLOAD_SIZE;\r\ndev->destructor = free_netdev;\r\nskb_queue_head_init(&cfspi->qhead);\r\nskb_queue_head_init(&cfspi->chead);\r\ncfspi->cfdev.link_select = CAIF_LINK_HIGH_BANDW;\r\ncfspi->cfdev.use_frag = false;\r\ncfspi->cfdev.use_stx = false;\r\ncfspi->cfdev.use_fcs = false;\r\ncfspi->ndev = dev;\r\n}\r\nint cfspi_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct cfspi *cfspi = NULL;\r\nstruct net_device *ndev;\r\nstruct cfspi_dev *dev;\r\nint res;\r\ndev = (struct cfspi_dev *)pdev->dev.platform_data;\r\nndev = alloc_netdev(sizeof(struct cfspi), "cfspi%d",\r\nNET_NAME_UNKNOWN, cfspi_setup);\r\nif (!dev)\r\nreturn -ENODEV;\r\ncfspi = netdev_priv(ndev);\r\nnetif_stop_queue(ndev);\r\ncfspi->ndev = ndev;\r\ncfspi->pdev = pdev;\r\ncfspi->dev = dev;\r\ndev->ifc = &cfspi->ifc;\r\nres = register_netdev(ndev);\r\nif (res) {\r\nprintk(KERN_ERR "CFSPI: Reg. error: %d.\n", res);\r\ngoto err_net_reg;\r\n}\r\nreturn res;\r\nerr_net_reg:\r\nfree_netdev(ndev);\r\nreturn res;\r\n}\r\nint cfspi_spi_remove(struct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit cfspi_exit_module(void)\r\n{\r\nstruct list_head *list_node;\r\nstruct list_head *n;\r\nstruct cfspi *cfspi = NULL;\r\nlist_for_each_safe(list_node, n, &cfspi_list) {\r\ncfspi = list_entry(list_node, struct cfspi, list);\r\nunregister_netdev(cfspi->ndev);\r\n}\r\ndriver_remove_file(&cfspi_spi_driver.driver,\r\n&driver_attr_up_head_align);\r\ndriver_remove_file(&cfspi_spi_driver.driver,\r\n&driver_attr_up_tail_align);\r\ndriver_remove_file(&cfspi_spi_driver.driver,\r\n&driver_attr_down_head_align);\r\ndriver_remove_file(&cfspi_spi_driver.driver,\r\n&driver_attr_down_tail_align);\r\ndriver_remove_file(&cfspi_spi_driver.driver, &driver_attr_frame_align);\r\nplatform_driver_unregister(&cfspi_spi_driver);\r\ndriver_debugfs_remove();\r\n}\r\nstatic int __init cfspi_init_module(void)\r\n{\r\nint result;\r\nspin_lock_init(&cfspi_list_lock);\r\nresult = platform_driver_register(&cfspi_spi_driver);\r\nif (result) {\r\nprintk(KERN_ERR "Could not register platform SPI driver.\n");\r\ngoto err_dev_register;\r\n}\r\nresult =\r\ndriver_create_file(&cfspi_spi_driver.driver,\r\n&driver_attr_up_head_align);\r\nif (result) {\r\nprintk(KERN_ERR "Sysfs creation failed 1.\n");\r\ngoto err_create_up_head_align;\r\n}\r\nresult =\r\ndriver_create_file(&cfspi_spi_driver.driver,\r\n&driver_attr_up_tail_align);\r\nif (result) {\r\nprintk(KERN_ERR "Sysfs creation failed 2.\n");\r\ngoto err_create_up_tail_align;\r\n}\r\nresult =\r\ndriver_create_file(&cfspi_spi_driver.driver,\r\n&driver_attr_down_head_align);\r\nif (result) {\r\nprintk(KERN_ERR "Sysfs creation failed 3.\n");\r\ngoto err_create_down_head_align;\r\n}\r\nresult =\r\ndriver_create_file(&cfspi_spi_driver.driver,\r\n&driver_attr_down_tail_align);\r\nif (result) {\r\nprintk(KERN_ERR "Sysfs creation failed 4.\n");\r\ngoto err_create_down_tail_align;\r\n}\r\nresult =\r\ndriver_create_file(&cfspi_spi_driver.driver,\r\n&driver_attr_frame_align);\r\nif (result) {\r\nprintk(KERN_ERR "Sysfs creation failed 5.\n");\r\ngoto err_create_frame_align;\r\n}\r\ndriver_debugfs_create();\r\nreturn result;\r\nerr_create_frame_align:\r\ndriver_remove_file(&cfspi_spi_driver.driver,\r\n&driver_attr_down_tail_align);\r\nerr_create_down_tail_align:\r\ndriver_remove_file(&cfspi_spi_driver.driver,\r\n&driver_attr_down_head_align);\r\nerr_create_down_head_align:\r\ndriver_remove_file(&cfspi_spi_driver.driver,\r\n&driver_attr_up_tail_align);\r\nerr_create_up_tail_align:\r\ndriver_remove_file(&cfspi_spi_driver.driver,\r\n&driver_attr_up_head_align);\r\nerr_create_up_head_align:\r\nplatform_driver_unregister(&cfspi_spi_driver);\r\nerr_dev_register:\r\nreturn result;\r\n}
