static int pcc_cpufreq_verify(struct cpufreq_policy *policy)\r\n{\r\ncpufreq_verify_within_cpu_limits(policy);\r\nreturn 0;\r\n}\r\nstatic inline void pcc_cmd(void)\r\n{\r\nu64 doorbell_value;\r\nint i;\r\nacpi_read(&doorbell_value, &doorbell);\r\nacpi_write((doorbell_value & doorbell_preserve) | doorbell_write,\r\n&doorbell);\r\nfor (i = 0; i < POLL_LOOPS; i++) {\r\nif (ioread16(&pcch_hdr->status) & CMD_COMPLETE)\r\nbreak;\r\n}\r\n}\r\nstatic inline void pcc_clear_mapping(void)\r\n{\r\nif (pcch_virt_addr)\r\niounmap(pcch_virt_addr);\r\npcch_virt_addr = NULL;\r\n}\r\nstatic unsigned int pcc_get_freq(unsigned int cpu)\r\n{\r\nstruct pcc_cpu *pcc_cpu_data;\r\nunsigned int curr_freq;\r\nunsigned int freq_limit;\r\nu16 status;\r\nu32 input_buffer;\r\nu32 output_buffer;\r\nspin_lock(&pcc_lock);\r\npr_debug("get: get_freq for CPU %d\n", cpu);\r\npcc_cpu_data = per_cpu_ptr(pcc_cpu_info, cpu);\r\ninput_buffer = 0x1;\r\niowrite32(input_buffer,\r\n(pcch_virt_addr + pcc_cpu_data->input_offset));\r\niowrite16(CMD_GET_FREQ, &pcch_hdr->command);\r\npcc_cmd();\r\noutput_buffer =\r\nioread32(pcch_virt_addr + pcc_cpu_data->output_offset);\r\nmemset_io((pcch_virt_addr + pcc_cpu_data->input_offset), 0, BUF_SZ);\r\nstatus = ioread16(&pcch_hdr->status);\r\nif (status != CMD_COMPLETE) {\r\npr_debug("get: FAILED: for CPU %d, status is %d\n",\r\ncpu, status);\r\ngoto cmd_incomplete;\r\n}\r\niowrite16(0, &pcch_hdr->status);\r\ncurr_freq = (((ioread32(&pcch_hdr->nominal) * (output_buffer & 0xff))\r\n/ 100) * 1000);\r\npr_debug("get: SUCCESS: (virtual) output_offset for cpu %d is "\r\n"0x%p, contains a value of: 0x%x. Speed is: %d MHz\n",\r\ncpu, (pcch_virt_addr + pcc_cpu_data->output_offset),\r\noutput_buffer, curr_freq);\r\nfreq_limit = (output_buffer >> 8) & 0xff;\r\nif (freq_limit != 0xff) {\r\npr_debug("get: frequency for cpu %d is being temporarily"\r\n" capped at %d\n", cpu, curr_freq);\r\n}\r\nspin_unlock(&pcc_lock);\r\nreturn curr_freq;\r\ncmd_incomplete:\r\niowrite16(0, &pcch_hdr->status);\r\nspin_unlock(&pcc_lock);\r\nreturn 0;\r\n}\r\nstatic int pcc_cpufreq_target(struct cpufreq_policy *policy,\r\nunsigned int target_freq,\r\nunsigned int relation)\r\n{\r\nstruct pcc_cpu *pcc_cpu_data;\r\nstruct cpufreq_freqs freqs;\r\nu16 status;\r\nu32 input_buffer;\r\nint cpu;\r\ncpu = policy->cpu;\r\npcc_cpu_data = per_cpu_ptr(pcc_cpu_info, cpu);\r\npr_debug("target: CPU %d should go to target freq: %d "\r\n"(virtual) input_offset is 0x%p\n",\r\ncpu, target_freq,\r\n(pcch_virt_addr + pcc_cpu_data->input_offset));\r\nfreqs.old = policy->cur;\r\nfreqs.new = target_freq;\r\ncpufreq_freq_transition_begin(policy, &freqs);\r\nspin_lock(&pcc_lock);\r\ninput_buffer = 0x1 | (((target_freq * 100)\r\n/ (ioread32(&pcch_hdr->nominal) * 1000)) << 8);\r\niowrite32(input_buffer,\r\n(pcch_virt_addr + pcc_cpu_data->input_offset));\r\niowrite16(CMD_SET_FREQ, &pcch_hdr->command);\r\npcc_cmd();\r\nmemset_io((pcch_virt_addr + pcc_cpu_data->input_offset), 0, BUF_SZ);\r\nstatus = ioread16(&pcch_hdr->status);\r\niowrite16(0, &pcch_hdr->status);\r\ncpufreq_freq_transition_end(policy, &freqs, status != CMD_COMPLETE);\r\nspin_unlock(&pcc_lock);\r\nif (status != CMD_COMPLETE) {\r\npr_debug("target: FAILED for cpu %d, with status: 0x%x\n",\r\ncpu, status);\r\nreturn -EINVAL;\r\n}\r\npr_debug("target: was SUCCESSFUL for cpu %d\n", cpu);\r\nreturn 0;\r\n}\r\nstatic int pcc_get_offset(int cpu)\r\n{\r\nacpi_status status;\r\nstruct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};\r\nunion acpi_object *pccp, *offset;\r\nstruct pcc_cpu *pcc_cpu_data;\r\nstruct acpi_processor *pr;\r\nint ret = 0;\r\npr = per_cpu(processors, cpu);\r\npcc_cpu_data = per_cpu_ptr(pcc_cpu_info, cpu);\r\nif (!pr)\r\nreturn -ENODEV;\r\nstatus = acpi_evaluate_object(pr->handle, "PCCP", NULL, &buffer);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\npccp = buffer.pointer;\r\nif (!pccp || pccp->type != ACPI_TYPE_PACKAGE) {\r\nret = -ENODEV;\r\ngoto out_free;\r\n};\r\noffset = &(pccp->package.elements[0]);\r\nif (!offset || offset->type != ACPI_TYPE_INTEGER) {\r\nret = -ENODEV;\r\ngoto out_free;\r\n}\r\npcc_cpu_data->input_offset = offset->integer.value;\r\noffset = &(pccp->package.elements[1]);\r\nif (!offset || offset->type != ACPI_TYPE_INTEGER) {\r\nret = -ENODEV;\r\ngoto out_free;\r\n}\r\npcc_cpu_data->output_offset = offset->integer.value;\r\nmemset_io((pcch_virt_addr + pcc_cpu_data->input_offset), 0, BUF_SZ);\r\nmemset_io((pcch_virt_addr + pcc_cpu_data->output_offset), 0, BUF_SZ);\r\npr_debug("pcc_get_offset: for CPU %d: pcc_cpu_data "\r\n"input_offset: 0x%x, pcc_cpu_data output_offset: 0x%x\n",\r\ncpu, pcc_cpu_data->input_offset, pcc_cpu_data->output_offset);\r\nout_free:\r\nkfree(buffer.pointer);\r\nreturn ret;\r\n}\r\nstatic int __init pcc_cpufreq_do_osc(acpi_handle *handle)\r\n{\r\nacpi_status status;\r\nstruct acpi_object_list input;\r\nstruct acpi_buffer output = {ACPI_ALLOCATE_BUFFER, NULL};\r\nunion acpi_object in_params[4];\r\nunion acpi_object *out_obj;\r\nu32 capabilities[2];\r\nu32 errors;\r\nu32 supported;\r\nint ret = 0;\r\ninput.count = 4;\r\ninput.pointer = in_params;\r\nin_params[0].type = ACPI_TYPE_BUFFER;\r\nin_params[0].buffer.length = 16;\r\nin_params[0].buffer.pointer = OSC_UUID;\r\nin_params[1].type = ACPI_TYPE_INTEGER;\r\nin_params[1].integer.value = 1;\r\nin_params[2].type = ACPI_TYPE_INTEGER;\r\nin_params[2].integer.value = 2;\r\nin_params[3].type = ACPI_TYPE_BUFFER;\r\nin_params[3].buffer.length = 8;\r\nin_params[3].buffer.pointer = (u8 *)&capabilities;\r\ncapabilities[0] = OSC_QUERY_ENABLE;\r\ncapabilities[1] = 0x1;\r\nstatus = acpi_evaluate_object(*handle, "_OSC", &input, &output);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\nif (!output.length)\r\nreturn -ENODEV;\r\nout_obj = output.pointer;\r\nif (out_obj->type != ACPI_TYPE_BUFFER) {\r\nret = -ENODEV;\r\ngoto out_free;\r\n}\r\nerrors = *((u32 *)out_obj->buffer.pointer) & ~(1 << 0);\r\nif (errors) {\r\nret = -ENODEV;\r\ngoto out_free;\r\n}\r\nsupported = *((u32 *)(out_obj->buffer.pointer + 4));\r\nif (!(supported & 0x1)) {\r\nret = -ENODEV;\r\ngoto out_free;\r\n}\r\nkfree(output.pointer);\r\ncapabilities[0] = 0x0;\r\ncapabilities[1] = 0x1;\r\nstatus = acpi_evaluate_object(*handle, "_OSC", &input, &output);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\nif (!output.length)\r\nreturn -ENODEV;\r\nout_obj = output.pointer;\r\nif (out_obj->type != ACPI_TYPE_BUFFER) {\r\nret = -ENODEV;\r\ngoto out_free;\r\n}\r\nerrors = *((u32 *)out_obj->buffer.pointer) & ~(1 << 0);\r\nif (errors) {\r\nret = -ENODEV;\r\ngoto out_free;\r\n}\r\nsupported = *((u32 *)(out_obj->buffer.pointer + 4));\r\nif (!(supported & 0x1)) {\r\nret = -ENODEV;\r\ngoto out_free;\r\n}\r\nout_free:\r\nkfree(output.pointer);\r\nreturn ret;\r\n}\r\nstatic int __init pcc_cpufreq_probe(void)\r\n{\r\nacpi_status status;\r\nstruct acpi_buffer output = {ACPI_ALLOCATE_BUFFER, NULL};\r\nstruct pcc_memory_resource *mem_resource;\r\nstruct pcc_register_resource *reg_resource;\r\nunion acpi_object *out_obj, *member;\r\nacpi_handle handle, osc_handle;\r\nint ret = 0;\r\nstatus = acpi_get_handle(NULL, "\\_SB", &handle);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\nif (!acpi_has_method(handle, "PCCH"))\r\nreturn -ENODEV;\r\nstatus = acpi_get_handle(handle, "_OSC", &osc_handle);\r\nif (ACPI_SUCCESS(status)) {\r\nret = pcc_cpufreq_do_osc(&osc_handle);\r\nif (ret)\r\npr_debug("probe: _OSC evaluation did not succeed\n");\r\nret = 0;\r\n}\r\nstatus = acpi_evaluate_object(handle, "PCCH", NULL, &output);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\nout_obj = output.pointer;\r\nif (out_obj->type != ACPI_TYPE_PACKAGE) {\r\nret = -ENODEV;\r\ngoto out_free;\r\n}\r\nmember = &out_obj->package.elements[0];\r\nif (member->type != ACPI_TYPE_BUFFER) {\r\nret = -ENODEV;\r\ngoto out_free;\r\n}\r\nmem_resource = (struct pcc_memory_resource *)member->buffer.pointer;\r\npr_debug("probe: mem_resource descriptor: 0x%x,"\r\n" length: %d, space_id: %d, resource_usage: %d,"\r\n" type_specific: %d, granularity: 0x%llx,"\r\n" minimum: 0x%llx, maximum: 0x%llx,"\r\n" translation_offset: 0x%llx, address_length: 0x%llx\n",\r\nmem_resource->descriptor, mem_resource->length,\r\nmem_resource->space_id, mem_resource->resource_usage,\r\nmem_resource->type_specific, mem_resource->granularity,\r\nmem_resource->minimum, mem_resource->maximum,\r\nmem_resource->translation_offset,\r\nmem_resource->address_length);\r\nif (mem_resource->space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY) {\r\nret = -ENODEV;\r\ngoto out_free;\r\n}\r\npcch_virt_addr = ioremap_nocache(mem_resource->minimum,\r\nmem_resource->address_length);\r\nif (pcch_virt_addr == NULL) {\r\npr_debug("probe: could not map shared mem region\n");\r\nret = -ENOMEM;\r\ngoto out_free;\r\n}\r\npcch_hdr = pcch_virt_addr;\r\npr_debug("probe: PCCH header (virtual) addr: 0x%p\n", pcch_hdr);\r\npr_debug("probe: PCCH header is at physical address: 0x%llx,"\r\n" signature: 0x%x, length: %d bytes, major: %d, minor: %d,"\r\n" supported features: 0x%x, command field: 0x%x,"\r\n" status field: 0x%x, nominal latency: %d us\n",\r\nmem_resource->minimum, ioread32(&pcch_hdr->signature),\r\nioread16(&pcch_hdr->length), ioread8(&pcch_hdr->major),\r\nioread8(&pcch_hdr->minor), ioread32(&pcch_hdr->features),\r\nioread16(&pcch_hdr->command), ioread16(&pcch_hdr->status),\r\nioread32(&pcch_hdr->latency));\r\npr_debug("probe: min time between commands: %d us,"\r\n" max time between commands: %d us,"\r\n" nominal CPU frequency: %d MHz,"\r\n" minimum CPU frequency: %d MHz,"\r\n" minimum CPU frequency without throttling: %d MHz\n",\r\nioread32(&pcch_hdr->minimum_time),\r\nioread32(&pcch_hdr->maximum_time),\r\nioread32(&pcch_hdr->nominal),\r\nioread32(&pcch_hdr->throttled_frequency),\r\nioread32(&pcch_hdr->minimum_frequency));\r\nmember = &out_obj->package.elements[1];\r\nif (member->type != ACPI_TYPE_BUFFER) {\r\nret = -ENODEV;\r\ngoto pcch_free;\r\n}\r\nreg_resource = (struct pcc_register_resource *)member->buffer.pointer;\r\ndoorbell.space_id = reg_resource->space_id;\r\ndoorbell.bit_width = reg_resource->bit_width;\r\ndoorbell.bit_offset = reg_resource->bit_offset;\r\ndoorbell.access_width = 64;\r\ndoorbell.address = reg_resource->address;\r\npr_debug("probe: doorbell: space_id is %d, bit_width is %d, "\r\n"bit_offset is %d, access_width is %d, address is 0x%llx\n",\r\ndoorbell.space_id, doorbell.bit_width, doorbell.bit_offset,\r\ndoorbell.access_width, reg_resource->address);\r\nmember = &out_obj->package.elements[2];\r\nif (member->type != ACPI_TYPE_INTEGER) {\r\nret = -ENODEV;\r\ngoto pcch_free;\r\n}\r\ndoorbell_preserve = member->integer.value;\r\nmember = &out_obj->package.elements[3];\r\nif (member->type != ACPI_TYPE_INTEGER) {\r\nret = -ENODEV;\r\ngoto pcch_free;\r\n}\r\ndoorbell_write = member->integer.value;\r\npr_debug("probe: doorbell_preserve: 0x%llx,"\r\n" doorbell_write: 0x%llx\n",\r\ndoorbell_preserve, doorbell_write);\r\npcc_cpu_info = alloc_percpu(struct pcc_cpu);\r\nif (!pcc_cpu_info) {\r\nret = -ENOMEM;\r\ngoto pcch_free;\r\n}\r\nprintk(KERN_DEBUG "pcc-cpufreq: (v%s) driver loaded with frequency"\r\n" limits: %d MHz, %d MHz\n", PCC_VERSION,\r\nioread32(&pcch_hdr->minimum_frequency),\r\nioread32(&pcch_hdr->nominal));\r\nkfree(output.pointer);\r\nreturn ret;\r\npcch_free:\r\npcc_clear_mapping();\r\nout_free:\r\nkfree(output.pointer);\r\nreturn ret;\r\n}\r\nstatic int pcc_cpufreq_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nunsigned int cpu = policy->cpu;\r\nunsigned int result = 0;\r\nif (!pcch_virt_addr) {\r\nresult = -1;\r\ngoto out;\r\n}\r\nresult = pcc_get_offset(cpu);\r\nif (result) {\r\npr_debug("init: PCCP evaluation failed\n");\r\ngoto out;\r\n}\r\npolicy->max = policy->cpuinfo.max_freq =\r\nioread32(&pcch_hdr->nominal) * 1000;\r\npolicy->min = policy->cpuinfo.min_freq =\r\nioread32(&pcch_hdr->minimum_frequency) * 1000;\r\npr_debug("init: policy->max is %d, policy->min is %d\n",\r\npolicy->max, policy->min);\r\nout:\r\nreturn result;\r\n}\r\nstatic int pcc_cpufreq_cpu_exit(struct cpufreq_policy *policy)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init pcc_cpufreq_init(void)\r\n{\r\nint ret;\r\nif (acpi_disabled)\r\nreturn 0;\r\nret = pcc_cpufreq_probe();\r\nif (ret) {\r\npr_debug("pcc_cpufreq_init: PCCH evaluation failed\n");\r\nreturn ret;\r\n}\r\nret = cpufreq_register_driver(&pcc_cpufreq_driver);\r\nreturn ret;\r\n}\r\nstatic void __exit pcc_cpufreq_exit(void)\r\n{\r\ncpufreq_unregister_driver(&pcc_cpufreq_driver);\r\npcc_clear_mapping();\r\nfree_percpu(pcc_cpu_info);\r\n}
