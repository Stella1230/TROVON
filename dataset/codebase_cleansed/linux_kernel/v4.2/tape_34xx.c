static void __tape_34xx_medium_sense(struct tape_request *request)\r\n{\r\nstruct tape_device *device = request->device;\r\nunsigned char *sense;\r\nif (request->rc == 0) {\r\nsense = request->cpdata;\r\nif (sense[0] & SENSE_INTERVENTION_REQUIRED)\r\ntape_med_state_set(device, MS_UNLOADED);\r\nelse\r\ntape_med_state_set(device, MS_LOADED);\r\nif (sense[1] & SENSE_WRITE_PROTECT)\r\ndevice->tape_generic_status |= GMT_WR_PROT(~0);\r\nelse\r\ndevice->tape_generic_status &= ~GMT_WR_PROT(~0);\r\n} else\r\nDBF_EVENT(4, "tape_34xx: medium sense failed with rc=%d\n",\r\nrequest->rc);\r\ntape_free_request(request);\r\n}\r\nstatic int tape_34xx_medium_sense(struct tape_device *device)\r\n{\r\nstruct tape_request *request;\r\nint rc;\r\nrequest = tape_alloc_request(1, 32);\r\nif (IS_ERR(request)) {\r\nDBF_EXCEPTION(6, "MSEN fail\n");\r\nreturn PTR_ERR(request);\r\n}\r\nrequest->op = TO_MSEN;\r\ntape_ccw_end(request->cpaddr, SENSE, 32, request->cpdata);\r\nrc = tape_do_io_interruptible(device, request);\r\n__tape_34xx_medium_sense(request);\r\nreturn rc;\r\n}\r\nstatic void tape_34xx_medium_sense_async(struct tape_device *device)\r\n{\r\nstruct tape_request *request;\r\nrequest = tape_alloc_request(1, 32);\r\nif (IS_ERR(request)) {\r\nDBF_EXCEPTION(6, "MSEN fail\n");\r\nreturn;\r\n}\r\nrequest->op = TO_MSEN;\r\ntape_ccw_end(request->cpaddr, SENSE, 32, request->cpdata);\r\nrequest->callback = (void *) __tape_34xx_medium_sense;\r\nrequest->callback_data = NULL;\r\ntape_do_io_async(device, request);\r\n}\r\nstatic void\r\ntape_34xx_work_handler(struct work_struct *work)\r\n{\r\nstruct tape_34xx_work *p =\r\ncontainer_of(work, struct tape_34xx_work, work);\r\nstruct tape_device *device = p->device;\r\nswitch(p->op) {\r\ncase TO_MSEN:\r\ntape_34xx_medium_sense_async(device);\r\nbreak;\r\ndefault:\r\nDBF_EVENT(3, "T34XX: internal error: unknown work\n");\r\n}\r\ntape_put_device(device);\r\nkfree(p);\r\n}\r\nstatic int\r\ntape_34xx_schedule_work(struct tape_device *device, enum tape_op op)\r\n{\r\nstruct tape_34xx_work *p;\r\nif ((p = kzalloc(sizeof(*p), GFP_ATOMIC)) == NULL)\r\nreturn -ENOMEM;\r\nINIT_WORK(&p->work, tape_34xx_work_handler);\r\np->device = tape_get_device(device);\r\np->op = op;\r\nschedule_work(&p->work);\r\nreturn 0;\r\n}\r\nstatic inline int\r\ntape_34xx_done(struct tape_request *request)\r\n{\r\nDBF_EVENT(6, "%s done\n", tape_op_verbose[request->op]);\r\nswitch (request->op) {\r\ncase TO_DSE:\r\ncase TO_RUN:\r\ncase TO_WRI:\r\ncase TO_WTM:\r\ncase TO_ASSIGN:\r\ncase TO_UNASSIGN:\r\ntape_34xx_delete_sbid_from(request->device, 0);\r\nbreak;\r\ndefault:\r\n;\r\n}\r\nreturn TAPE_IO_SUCCESS;\r\n}\r\nstatic inline int\r\ntape_34xx_erp_failed(struct tape_request *request, int rc)\r\n{\r\nDBF_EVENT(3, "Error recovery failed for %s (RC=%d)\n",\r\ntape_op_verbose[request->op], rc);\r\nreturn rc;\r\n}\r\nstatic inline int\r\ntape_34xx_erp_succeeded(struct tape_request *request)\r\n{\r\nDBF_EVENT(3, "Error Recovery successful for %s\n",\r\ntape_op_verbose[request->op]);\r\nreturn tape_34xx_done(request);\r\n}\r\nstatic inline int\r\ntape_34xx_erp_retry(struct tape_request *request)\r\n{\r\nDBF_EVENT(3, "xerp retr %s\n", tape_op_verbose[request->op]);\r\nreturn TAPE_IO_RETRY;\r\n}\r\nstatic int\r\ntape_34xx_unsolicited_irq(struct tape_device *device, struct irb *irb)\r\n{\r\nif (irb->scsw.cmd.dstat == 0x85) {\r\nDBF_EVENT(6, "xuud med\n");\r\ntape_34xx_delete_sbid_from(device, 0);\r\ntape_34xx_schedule_work(device, TO_MSEN);\r\n} else {\r\nDBF_EVENT(3, "unsol.irq! dev end: %08x\n", device->cdev_id);\r\ntape_dump_sense_dbf(device, NULL, irb);\r\n}\r\nreturn TAPE_IO_SUCCESS;\r\n}\r\nstatic int\r\ntape_34xx_erp_read_opposite(struct tape_device *device,\r\nstruct tape_request *request)\r\n{\r\nif (request->op == TO_RFO) {\r\ntape_std_read_backward(device, request);\r\nreturn tape_34xx_erp_retry(request);\r\n}\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\n}\r\nstatic int\r\ntape_34xx_erp_bug(struct tape_device *device, struct tape_request *request,\r\nstruct irb *irb, int no)\r\n{\r\nif (request->op != TO_ASSIGN) {\r\ndev_err(&device->cdev->dev, "An unexpected condition %d "\r\n"occurred in tape error recovery\n", no);\r\ntape_dump_sense_dbf(device, request, irb);\r\n}\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\n}\r\nstatic int\r\ntape_34xx_erp_overrun(struct tape_device *device, struct tape_request *request,\r\nstruct irb *irb)\r\n{\r\nif (irb->ecw[3] == 0x40) {\r\ndev_warn (&device->cdev->dev, "A data overrun occurred between"\r\n" the control unit and tape unit\n");\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\n}\r\nreturn tape_34xx_erp_bug(device, request, irb, -1);\r\n}\r\nstatic int\r\ntape_34xx_erp_sequence(struct tape_device *device,\r\nstruct tape_request *request, struct irb *irb)\r\n{\r\nif (irb->ecw[3] == 0x41) {\r\ndev_warn (&device->cdev->dev, "The block ID sequence on the "\r\n"tape is incorrect\n");\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\n}\r\nreturn tape_34xx_erp_bug(device, request, irb, -2);\r\n}\r\nstatic int\r\ntape_34xx_unit_check(struct tape_device *device, struct tape_request *request,\r\nstruct irb *irb)\r\n{\r\nint inhibit_cu_recovery;\r\n__u8* sense;\r\ninhibit_cu_recovery = (*device->modeset_byte & 0x80) ? 1 : 0;\r\nsense = irb->ecw;\r\nif (\r\nsense[0] & SENSE_COMMAND_REJECT &&\r\nsense[1] & SENSE_WRITE_PROTECT\r\n) {\r\nif (\r\nrequest->op == TO_DSE ||\r\nrequest->op == TO_WRI ||\r\nrequest->op == TO_WTM\r\n) {\r\nreturn tape_34xx_erp_failed(request, -EACCES);\r\n} else {\r\nreturn tape_34xx_erp_bug(device, request, irb, -3);\r\n}\r\n}\r\nif ((\r\nsense[0] == SENSE_DATA_CHECK ||\r\nsense[0] == SENSE_EQUIPMENT_CHECK ||\r\nsense[0] == SENSE_EQUIPMENT_CHECK + SENSE_DEFERRED_UNIT_CHECK\r\n) && (\r\nsense[1] == SENSE_DRIVE_ONLINE ||\r\nsense[1] == SENSE_BEGINNING_OF_TAPE + SENSE_WRITE_MODE\r\n)) {\r\nswitch (request->op) {\r\ncase TO_FSF:\r\ncase TO_FSB:\r\nreturn tape_34xx_erp_failed(request, -ENOSPC);\r\ncase TO_BSB:\r\nreturn tape_34xx_erp_retry(request);\r\ncase TO_LBL:\r\ntape_34xx_delete_sbid_from(device, 0);\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\ncase TO_RFO:\r\nreturn tape_34xx_erp_failed(request, 0);\r\ncase TO_WRI:\r\nreturn tape_34xx_erp_failed(request, -ENOSPC);\r\ndefault:\r\nreturn tape_34xx_erp_failed(request, 0);\r\n}\r\n}\r\nif (sense[0] & SENSE_BUS_OUT_CHECK)\r\nreturn tape_34xx_erp_retry(request);\r\nif (sense[0] & SENSE_DATA_CHECK) {\r\nswitch (sense[3]) {\r\ncase 0x23:\r\nif ((sense[2] & SENSE_TAPE_SYNC_MODE) ||\r\ninhibit_cu_recovery)\r\nreturn tape_34xx_erp_bug(device, request,\r\nirb, -4);\r\ndev_warn (&device->cdev->dev, "A read error occurred "\r\n"that cannot be recovered\n");\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\ncase 0x25:\r\nif ((sense[2] & SENSE_TAPE_SYNC_MODE) ||\r\ninhibit_cu_recovery)\r\nreturn tape_34xx_erp_bug(device, request,\r\nirb, -5);\r\ndev_warn (&device->cdev->dev, "A write error on the "\r\n"tape cannot be recovered\n");\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\ncase 0x26:\r\nreturn tape_34xx_erp_read_opposite(device, request);\r\ncase 0x28:\r\ndev_warn (&device->cdev->dev, "Writing the ID-mark "\r\n"failed\n");\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\ncase 0x31:\r\ndev_warn (&device->cdev->dev, "Reading the tape beyond"\r\n" the end of the recorded area failed\n");\r\nreturn tape_34xx_erp_failed(request, -ENOSPC);\r\ncase 0x41:\r\ndev_warn (&device->cdev->dev, "The tape contains an "\r\n"incorrect block ID sequence\n");\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\ndefault:\r\nif (device->cdev->id.driver_info == tape_3480)\r\nreturn tape_34xx_erp_bug(device, request,\r\nirb, -6);\r\n}\r\n}\r\nif (sense[0] & SENSE_OVERRUN)\r\nreturn tape_34xx_erp_overrun(device, request, irb);\r\nif (sense[1] & SENSE_RECORD_SEQUENCE_ERR)\r\nreturn tape_34xx_erp_sequence(device, request, irb);\r\nswitch (sense[3]) {\r\ncase 0x00:\r\nreturn TAPE_IO_SUCCESS;\r\ncase 0x21:\r\nreturn tape_34xx_erp_retry(request);\r\ncase 0x22:\r\ndev_warn (&device->cdev->dev, "A path equipment check occurred"\r\n" for the tape device\n");\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\ncase 0x24:\r\nreturn tape_34xx_erp_succeeded(request);\r\ncase 0x27:\r\nreturn tape_34xx_erp_retry(request);\r\ncase 0x29:\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\ncase 0x2a:\r\nreturn tape_34xx_erp_retry(request);\r\ncase 0x2b:\r\nif (request->op == TO_RUN) {\r\ntape_med_state_set(device, MS_UNLOADED);\r\nreturn tape_34xx_erp_succeeded(request);\r\n}\r\nreturn tape_34xx_erp_bug(device, request, irb, sense[3]);\r\ncase 0x2c:\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\ncase 0x2d:\r\nif (request->op == TO_DSE)\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\nreturn tape_34xx_erp_bug(device, request, irb, sense[3]);\r\ncase 0x2e:\r\ndev_warn (&device->cdev->dev, "The tape unit cannot process "\r\n"the tape format\n");\r\nreturn tape_34xx_erp_failed(request, -EMEDIUMTYPE);\r\ncase 0x30:\r\ndev_warn (&device->cdev->dev, "The tape medium is write-"\r\n"protected\n");\r\nreturn tape_34xx_erp_failed(request, -EACCES);\r\ncase 0x32:\r\ndev_warn (&device->cdev->dev, "The tape does not have the "\r\n"required tape tension\n");\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\ncase 0x33:\r\ndev_warn (&device->cdev->dev, "The tape unit failed to load"\r\n" the cartridge\n");\r\ntape_34xx_delete_sbid_from(device, 0);\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\ncase 0x34:\r\ndev_warn (&device->cdev->dev, "Automatic unloading of the tape"\r\n" cartridge failed\n");\r\nif (request->op == TO_RUN)\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\nreturn tape_34xx_erp_bug(device, request, irb, sense[3]);\r\ncase 0x35:\r\ndev_warn (&device->cdev->dev, "An equipment check has occurred"\r\n" on the tape unit\n");\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\ncase 0x36:\r\nif (device->cdev->id.driver_info == tape_3490)\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\nreturn tape_34xx_erp_bug(device, request, irb, sense[3]);\r\ncase 0x37:\r\ndev_warn (&device->cdev->dev, "The tape information states an"\r\n" incorrect length\n");\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\ncase 0x38:\r\nif (request->op==TO_WRI ||\r\nrequest->op==TO_DSE ||\r\nrequest->op==TO_WTM)\r\nreturn tape_34xx_erp_failed(request, -ENOSPC);\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\ncase 0x39:\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\ncase 0x3a:\r\ndev_warn (&device->cdev->dev, "The tape unit is not ready\n");\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\ncase 0x3b:\r\ndev_warn (&device->cdev->dev, "The tape medium has been "\r\n"rewound or unloaded manually\n");\r\ntape_34xx_delete_sbid_from(device, 0);\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\ncase 0x42:\r\ndev_warn (&device->cdev->dev, "The tape subsystem is running "\r\n"in degraded mode\n");\r\nreturn tape_34xx_erp_retry(request);\r\ncase 0x43:\r\ntape_34xx_delete_sbid_from(device, 0);\r\ntape_med_state_set(device, MS_UNLOADED);\r\nif (sense[1] & SENSE_DRIVE_ONLINE) {\r\nswitch(request->op) {\r\ncase TO_ASSIGN:\r\ncase TO_UNASSIGN:\r\ncase TO_DIS:\r\ncase TO_NOP:\r\nreturn tape_34xx_done(request);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn tape_34xx_erp_failed(request, -ENOMEDIUM);\r\ncase 0x44:\r\nif (request->op != TO_BLOCK && request->op != TO_LBL)\r\nreturn tape_34xx_erp_bug(device, request,\r\nirb, sense[3]);\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\ncase 0x45:\r\ndev_warn (&device->cdev->dev, "The tape unit is already "\r\n"assigned\n");\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\ncase 0x46:\r\ndev_warn (&device->cdev->dev, "The tape unit is not online\n");\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\ncase 0x47:\r\ndev_warn (&device->cdev->dev, "The control unit has fenced "\r\n"access to the tape volume\n");\r\ntape_34xx_delete_sbid_from(device, 0);\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\ncase 0x48:\r\nreturn tape_34xx_erp_retry(request);\r\ncase 0x49:\r\ndev_warn (&device->cdev->dev, "A parity error occurred on the "\r\n"tape bus\n");\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\ncase 0x4a:\r\ndev_warn (&device->cdev->dev, "I/O error recovery failed on "\r\n"the tape control unit\n");\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\ncase 0x4b:\r\ndev_warn (&device->cdev->dev, "The tape unit requires a "\r\n"firmware update\n");\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\ncase 0x4c:\r\nreturn tape_34xx_erp_retry(request);\r\ncase 0x4d:\r\nif (device->cdev->id.driver_info == tape_3490)\r\nreturn tape_34xx_erp_retry(request);\r\nreturn tape_34xx_erp_bug(device, request, irb, sense[3]);\r\ncase 0x4e:\r\nif (device->cdev->id.driver_info == tape_3490) {\r\ndev_warn (&device->cdev->dev, "The maximum block size"\r\n" for buffered mode is exceeded\n");\r\nreturn tape_34xx_erp_failed(request, -ENOBUFS);\r\n}\r\nreturn tape_34xx_erp_bug(device, request, irb, sense[3]);\r\ncase 0x50:\r\nreturn tape_34xx_erp_retry(request);\r\ncase 0x51:\r\nreturn tape_34xx_erp_retry(request);\r\ncase 0x52:\r\nif (request->op == TO_RUN) {\r\ntape_med_state_set(device, MS_UNLOADED);\r\ntape_34xx_delete_sbid_from(device, 0);\r\nreturn tape_34xx_erp_succeeded(request);\r\n}\r\nreturn tape_34xx_erp_bug(device, request, irb, sense[3]);\r\ncase 0x53:\r\nreturn tape_34xx_erp_retry(request);\r\ncase 0x54:\r\nreturn tape_34xx_erp_retry(request);\r\ncase 0x55:\r\ndev_warn (&device->cdev->dev, "A channel interface error cannot be"\r\n" recovered\n");\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\ncase 0x56:\r\ndev_warn (&device->cdev->dev, "A channel protocol error "\r\n"occurred\n");\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\ncase 0x57:\r\nreturn tape_34xx_erp_retry(request);\r\ncase 0x5a:\r\ndev_warn (&device->cdev->dev, "The tape unit does not support "\r\n"the tape length\n");\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\ncase 0x5b:\r\nif (sense[1] & SENSE_BEGINNING_OF_TAPE)\r\nreturn tape_34xx_erp_retry(request);\r\ndev_warn (&device->cdev->dev, "The tape unit does not support"\r\n" format 3480 XF\n");\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\ncase 0x5c:\r\ndev_warn (&device->cdev->dev, "The tape unit does not support tape "\r\n"format 3480-2 XF\n");\r\nreturn tape_34xx_erp_failed(request, -EIO);\r\ncase 0x5d:\r\ndev_warn (&device->cdev->dev, "The tape unit does not support"\r\n" the current tape length\n");\r\nreturn tape_34xx_erp_failed(request, -EMEDIUMTYPE);\r\ncase 0x5e:\r\ndev_warn (&device->cdev->dev, "The tape unit does not support"\r\n" the compaction algorithm\n");\r\nreturn tape_34xx_erp_failed(request, -EMEDIUMTYPE);\r\ncase 0x23:\r\ncase 0x25:\r\ncase 0x26:\r\ncase 0x28:\r\ncase 0x31:\r\ncase 0x40:\r\ncase 0x41:\r\ndefault:\r\nreturn tape_34xx_erp_bug(device, request, irb, sense[3]);\r\n}\r\n}\r\nstatic int\r\ntape_34xx_irq(struct tape_device *device, struct tape_request *request,\r\nstruct irb *irb)\r\n{\r\nif (request == NULL)\r\nreturn tape_34xx_unsolicited_irq(device, irb);\r\nif ((irb->scsw.cmd.dstat & DEV_STAT_UNIT_EXCEP) &&\r\n(irb->scsw.cmd.dstat & DEV_STAT_DEV_END) &&\r\n(request->op == TO_WRI)) {\r\nreturn tape_34xx_erp_failed(request, -ENOSPC);\r\n}\r\nif (irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK)\r\nreturn tape_34xx_unit_check(device, request, irb);\r\nif (irb->scsw.cmd.dstat & DEV_STAT_DEV_END) {\r\nif (irb->scsw.cmd.dstat & DEV_STAT_UNIT_EXCEP) {\r\nif (request->op == TO_BSB || request->op == TO_FSB)\r\nrequest->rescnt++;\r\nelse\r\nDBF_EVENT(5, "Unit Exception!\n");\r\n}\r\nreturn tape_34xx_done(request);\r\n}\r\nDBF_EVENT(6, "xunknownirq\n");\r\ntape_dump_sense_dbf(device, request, irb);\r\nreturn TAPE_IO_STOP;\r\n}\r\nstatic int\r\ntape_34xx_ioctl(struct tape_device *device, unsigned int cmd, unsigned long arg)\r\n{\r\nif (cmd == TAPE390_DISPLAY) {\r\nstruct display_struct disp;\r\nif (copy_from_user(&disp, (char __user *) arg, sizeof(disp)) != 0)\r\nreturn -EFAULT;\r\nreturn tape_std_display(device, &disp);\r\n} else\r\nreturn -EINVAL;\r\n}\r\nstatic inline void\r\ntape_34xx_append_new_sbid(struct tape_34xx_block_id bid, struct list_head *l)\r\n{\r\nstruct tape_34xx_sbid * new_sbid;\r\nnew_sbid = kmalloc(sizeof(*new_sbid), GFP_ATOMIC);\r\nif (!new_sbid)\r\nreturn;\r\nnew_sbid->bid = bid;\r\nlist_add(&new_sbid->list, l);\r\n}\r\nstatic void\r\ntape_34xx_add_sbid(struct tape_device *device, struct tape_34xx_block_id bid)\r\n{\r\nstruct list_head * sbid_list;\r\nstruct tape_34xx_sbid * sbid;\r\nstruct list_head * l;\r\nsbid_list = (struct list_head *) device->discdata;\r\nif (!sbid_list || (bid.segment < 2 && bid.wrap == 0))\r\nreturn;\r\nlist_for_each(l, sbid_list) {\r\nsbid = list_entry(l, struct tape_34xx_sbid, list);\r\nif (\r\n(sbid->bid.segment == bid.segment) &&\r\n(sbid->bid.wrap == bid.wrap)\r\n) {\r\nif (bid.block < sbid->bid.block)\r\nsbid->bid = bid;\r\nelse return;\r\nbreak;\r\n}\r\nif (bid.block < sbid->bid.block) {\r\ntape_34xx_append_new_sbid(bid, l->prev);\r\nbreak;\r\n}\r\n}\r\nif (l == sbid_list)\r\ntape_34xx_append_new_sbid(bid, l->prev);\r\nDBF_LH(4, "Current list is:\n");\r\nlist_for_each(l, sbid_list) {\r\nsbid = list_entry(l, struct tape_34xx_sbid, list);\r\nDBF_LH(4, "%d:%03d@%05d\n",\r\nsbid->bid.wrap,\r\nsbid->bid.segment,\r\nsbid->bid.block\r\n);\r\n}\r\n}\r\nstatic void\r\ntape_34xx_delete_sbid_from(struct tape_device *device, int from)\r\n{\r\nstruct list_head * sbid_list;\r\nstruct tape_34xx_sbid * sbid;\r\nstruct list_head * l;\r\nstruct list_head * n;\r\nsbid_list = (struct list_head *) device->discdata;\r\nif (!sbid_list)\r\nreturn;\r\nlist_for_each_safe(l, n, sbid_list) {\r\nsbid = list_entry(l, struct tape_34xx_sbid, list);\r\nif (sbid->bid.block >= from) {\r\nDBF_LH(4, "Delete sbid %d:%03d@%05d\n",\r\nsbid->bid.wrap,\r\nsbid->bid.segment,\r\nsbid->bid.block\r\n);\r\nlist_del(l);\r\nkfree(sbid);\r\n}\r\n}\r\n}\r\nstatic void\r\ntape_34xx_merge_sbid(\r\nstruct tape_device * device,\r\nstruct tape_34xx_block_id * bid\r\n) {\r\nstruct tape_34xx_sbid * sbid;\r\nstruct tape_34xx_sbid * sbid_to_use;\r\nstruct list_head * sbid_list;\r\nstruct list_head * l;\r\nsbid_list = (struct list_head *) device->discdata;\r\nbid->wrap = 0;\r\nbid->segment = 1;\r\nif (!sbid_list || list_empty(sbid_list))\r\nreturn;\r\nsbid_to_use = NULL;\r\nlist_for_each(l, sbid_list) {\r\nsbid = list_entry(l, struct tape_34xx_sbid, list);\r\nif (sbid->bid.block >= bid->block)\r\nbreak;\r\nsbid_to_use = sbid;\r\n}\r\nif (sbid_to_use) {\r\nbid->wrap = sbid_to_use->bid.wrap;\r\nbid->segment = sbid_to_use->bid.segment;\r\nDBF_LH(4, "Use %d:%03d@%05d for %05d\n",\r\nsbid_to_use->bid.wrap,\r\nsbid_to_use->bid.segment,\r\nsbid_to_use->bid.block,\r\nbid->block\r\n);\r\n}\r\n}\r\nstatic int\r\ntape_34xx_setup_device(struct tape_device * device)\r\n{\r\nint rc;\r\nstruct list_head * discdata;\r\nDBF_EVENT(6, "34xx device setup\n");\r\nif ((rc = tape_std_assign(device)) == 0) {\r\nif ((rc = tape_34xx_medium_sense(device)) != 0) {\r\nDBF_LH(3, "34xx medium sense returned %d\n", rc);\r\n}\r\n}\r\ndiscdata = kmalloc(sizeof(struct list_head), GFP_KERNEL);\r\nif (discdata) {\r\nINIT_LIST_HEAD(discdata);\r\ndevice->discdata = discdata;\r\n}\r\nreturn rc;\r\n}\r\nstatic void\r\ntape_34xx_cleanup_device(struct tape_device *device)\r\n{\r\ntape_std_unassign(device);\r\nif (device->discdata) {\r\ntape_34xx_delete_sbid_from(device, 0);\r\nkfree(device->discdata);\r\ndevice->discdata = NULL;\r\n}\r\n}\r\nstatic int\r\ntape_34xx_mttell(struct tape_device *device, int mt_count)\r\n{\r\nstruct {\r\nstruct tape_34xx_block_id cbid;\r\nstruct tape_34xx_block_id dbid;\r\n} __attribute__ ((packed)) block_id;\r\nint rc;\r\nrc = tape_std_read_block_id(device, (__u64 *) &block_id);\r\nif (rc)\r\nreturn rc;\r\ntape_34xx_add_sbid(device, block_id.cbid);\r\nreturn block_id.cbid.block;\r\n}\r\nstatic int\r\ntape_34xx_mtseek(struct tape_device *device, int mt_count)\r\n{\r\nstruct tape_request *request;\r\nstruct tape_34xx_block_id * bid;\r\nif (mt_count > 0x3fffff) {\r\nDBF_EXCEPTION(6, "xsee parm\n");\r\nreturn -EINVAL;\r\n}\r\nrequest = tape_alloc_request(3, 4);\r\nif (IS_ERR(request))\r\nreturn PTR_ERR(request);\r\nrequest->op = TO_LBL;\r\nbid = (struct tape_34xx_block_id *) request->cpdata;\r\nbid->format = (*device->modeset_byte & 0x08) ?\r\nTAPE34XX_FMT_3480_XF : TAPE34XX_FMT_3480;\r\nbid->block = mt_count;\r\ntape_34xx_merge_sbid(device, bid);\r\ntape_ccw_cc(request->cpaddr, MODE_SET_DB, 1, device->modeset_byte);\r\ntape_ccw_cc(request->cpaddr + 1, LOCATE, 4, request->cpdata);\r\ntape_ccw_end(request->cpaddr + 2, NOP, 0, NULL);\r\nreturn tape_do_io_free(device, request);\r\n}\r\nstatic int\r\ntape_34xx_online(struct ccw_device *cdev)\r\n{\r\nreturn tape_generic_online(\r\ndev_get_drvdata(&cdev->dev),\r\n&tape_discipline_34xx\r\n);\r\n}\r\nstatic int\r\ntape_34xx_init (void)\r\n{\r\nint rc;\r\nTAPE_DBF_AREA = debug_register ( "tape_34xx", 2, 2, 4*sizeof(long));\r\ndebug_register_view(TAPE_DBF_AREA, &debug_sprintf_view);\r\n#ifdef DBF_LIKE_HELL\r\ndebug_set_level(TAPE_DBF_AREA, 6);\r\n#endif\r\nDBF_EVENT(3, "34xx init\n");\r\nrc = ccw_driver_register(&tape_34xx_driver);\r\nif (rc)\r\nDBF_EVENT(3, "34xx init failed\n");\r\nelse\r\nDBF_EVENT(3, "34xx registered\n");\r\nreturn rc;\r\n}\r\nstatic void\r\ntape_34xx_exit(void)\r\n{\r\nccw_driver_unregister(&tape_34xx_driver);\r\ndebug_unregister(TAPE_DBF_AREA);\r\n}
