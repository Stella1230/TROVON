int adf_devmgr_add_dev(struct adf_accel_dev *accel_dev)\r\n{\r\nstruct list_head *itr;\r\nif (num_devices == ADF_MAX_DEVICES) {\r\ndev_err(&GET_DEV(accel_dev), "Only support up to %d devices\n",\r\nADF_MAX_DEVICES);\r\nreturn -EFAULT;\r\n}\r\nmutex_lock(&table_lock);\r\nlist_for_each(itr, &accel_table) {\r\nstruct adf_accel_dev *ptr =\r\nlist_entry(itr, struct adf_accel_dev, list);\r\nif (ptr == accel_dev) {\r\nmutex_unlock(&table_lock);\r\nreturn -EEXIST;\r\n}\r\n}\r\natomic_set(&accel_dev->ref_count, 0);\r\nlist_add_tail(&accel_dev->list, &accel_table);\r\naccel_dev->accel_id = num_devices++;\r\nmutex_unlock(&table_lock);\r\nreturn 0;\r\n}\r\nstruct list_head *adf_devmgr_get_head(void)\r\n{\r\nreturn &accel_table;\r\n}\r\nvoid adf_devmgr_rm_dev(struct adf_accel_dev *accel_dev)\r\n{\r\nmutex_lock(&table_lock);\r\nlist_del(&accel_dev->list);\r\nnum_devices--;\r\nmutex_unlock(&table_lock);\r\n}\r\nstruct adf_accel_dev *adf_devmgr_get_first(void)\r\n{\r\nstruct adf_accel_dev *dev = NULL;\r\nif (!list_empty(&accel_table))\r\ndev = list_first_entry(&accel_table, struct adf_accel_dev,\r\nlist);\r\nreturn dev;\r\n}\r\nstruct adf_accel_dev *adf_devmgr_pci_to_accel_dev(struct pci_dev *pci_dev)\r\n{\r\nstruct list_head *itr;\r\nmutex_lock(&table_lock);\r\nlist_for_each(itr, &accel_table) {\r\nstruct adf_accel_dev *ptr =\r\nlist_entry(itr, struct adf_accel_dev, list);\r\nif (ptr->accel_pci_dev.pci_dev == pci_dev) {\r\nmutex_unlock(&table_lock);\r\nreturn ptr;\r\n}\r\n}\r\nmutex_unlock(&table_lock);\r\nreturn NULL;\r\n}\r\nstruct adf_accel_dev *adf_devmgr_get_dev_by_id(uint32_t id)\r\n{\r\nstruct list_head *itr;\r\nmutex_lock(&table_lock);\r\nlist_for_each(itr, &accel_table) {\r\nstruct adf_accel_dev *ptr =\r\nlist_entry(itr, struct adf_accel_dev, list);\r\nif (ptr->accel_id == id) {\r\nmutex_unlock(&table_lock);\r\nreturn ptr;\r\n}\r\n}\r\nmutex_unlock(&table_lock);\r\nreturn NULL;\r\n}\r\nint adf_devmgr_verify_id(uint32_t id)\r\n{\r\nif (id == ADF_CFG_ALL_DEVICES)\r\nreturn 0;\r\nif (adf_devmgr_get_dev_by_id(id))\r\nreturn 0;\r\nreturn -ENODEV;\r\n}\r\nvoid adf_devmgr_get_num_dev(uint32_t *num)\r\n{\r\nstruct list_head *itr;\r\n*num = 0;\r\nlist_for_each(itr, &accel_table) {\r\n(*num)++;\r\n}\r\n}\r\nint adf_dev_in_use(struct adf_accel_dev *accel_dev)\r\n{\r\nreturn atomic_read(&accel_dev->ref_count) != 0;\r\n}\r\nint adf_dev_get(struct adf_accel_dev *accel_dev)\r\n{\r\nif (atomic_add_return(1, &accel_dev->ref_count) == 1)\r\nif (!try_module_get(accel_dev->owner))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nvoid adf_dev_put(struct adf_accel_dev *accel_dev)\r\n{\r\nif (atomic_sub_return(1, &accel_dev->ref_count) == 0)\r\nmodule_put(accel_dev->owner);\r\n}\r\nint adf_devmgr_in_reset(struct adf_accel_dev *accel_dev)\r\n{\r\nreturn test_bit(ADF_STATUS_RESTARTING, &accel_dev->status);\r\n}\r\nint adf_dev_started(struct adf_accel_dev *accel_dev)\r\n{\r\nreturn test_bit(ADF_STATUS_STARTED, &accel_dev->status);\r\n}
