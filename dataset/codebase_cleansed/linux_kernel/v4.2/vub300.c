static inline int interface_to_InterfaceNumber(struct usb_interface *interface)\r\n{\r\nif (!interface)\r\nreturn -1;\r\nif (!interface->cur_altsetting)\r\nreturn -1;\r\nreturn interface->cur_altsetting->desc.bInterfaceNumber;\r\n}\r\nstatic void vub300_delete(struct kref *kref)\r\n{\r\nstruct vub300_mmc_host *vub300 = kref_to_vub300_mmc_host(kref);\r\nstruct mmc_host *mmc = vub300->mmc;\r\nusb_free_urb(vub300->command_out_urb);\r\nvub300->command_out_urb = NULL;\r\nusb_free_urb(vub300->command_res_urb);\r\nvub300->command_res_urb = NULL;\r\nusb_put_dev(vub300->udev);\r\nmmc_free_host(mmc);\r\n}\r\nstatic void vub300_queue_cmnd_work(struct vub300_mmc_host *vub300)\r\n{\r\nkref_get(&vub300->kref);\r\nif (queue_work(cmndworkqueue, &vub300->cmndwork)) {\r\n} else {\r\nkref_put(&vub300->kref, vub300_delete);\r\n}\r\n}\r\nstatic void vub300_queue_poll_work(struct vub300_mmc_host *vub300, int delay)\r\n{\r\nkref_get(&vub300->kref);\r\nif (queue_delayed_work(pollworkqueue, &vub300->pollwork, delay)) {\r\n} else {\r\nkref_put(&vub300->kref, vub300_delete);\r\n}\r\n}\r\nstatic void vub300_queue_dead_work(struct vub300_mmc_host *vub300)\r\n{\r\nkref_get(&vub300->kref);\r\nif (queue_work(deadworkqueue, &vub300->deadwork)) {\r\n} else {\r\nkref_put(&vub300->kref, vub300_delete);\r\n}\r\n}\r\nstatic void irqpoll_res_completed(struct urb *urb)\r\n{\r\nstruct vub300_mmc_host *vub300 = (struct vub300_mmc_host *)urb->context;\r\nif (urb->status)\r\nvub300->usb_transport_fail = urb->status;\r\ncomplete(&vub300->irqpoll_complete);\r\n}\r\nstatic void irqpoll_out_completed(struct urb *urb)\r\n{\r\nstruct vub300_mmc_host *vub300 = (struct vub300_mmc_host *)urb->context;\r\nif (urb->status) {\r\nvub300->usb_transport_fail = urb->status;\r\ncomplete(&vub300->irqpoll_complete);\r\nreturn;\r\n} else {\r\nint ret;\r\nunsigned int pipe =\r\nusb_rcvbulkpipe(vub300->udev, vub300->cmnd_res_ep);\r\nusb_fill_bulk_urb(vub300->command_res_urb, vub300->udev, pipe,\r\n&vub300->resp, sizeof(vub300->resp),\r\nirqpoll_res_completed, vub300);\r\nvub300->command_res_urb->actual_length = 0;\r\nret = usb_submit_urb(vub300->command_res_urb, GFP_ATOMIC);\r\nif (ret) {\r\nvub300->usb_transport_fail = ret;\r\ncomplete(&vub300->irqpoll_complete);\r\n}\r\nreturn;\r\n}\r\n}\r\nstatic void send_irqpoll(struct vub300_mmc_host *vub300)\r\n{\r\nint retval;\r\nint timeout = 0xFFFF & (0x0001FFFF - firmware_irqpoll_timeout);\r\nvub300->cmnd.poll.header_size = 22;\r\nvub300->cmnd.poll.header_type = 1;\r\nvub300->cmnd.poll.port_number = 0;\r\nvub300->cmnd.poll.command_type = 2;\r\nvub300->cmnd.poll.poll_timeout_lsb = 0xFF & (unsigned)timeout;\r\nvub300->cmnd.poll.poll_timeout_msb = 0xFF & (unsigned)(timeout >> 8);\r\nusb_fill_bulk_urb(vub300->command_out_urb, vub300->udev,\r\nusb_sndbulkpipe(vub300->udev, vub300->cmnd_out_ep)\r\n, &vub300->cmnd, sizeof(vub300->cmnd)\r\n, irqpoll_out_completed, vub300);\r\nretval = usb_submit_urb(vub300->command_out_urb, GFP_KERNEL);\r\nif (0 > retval) {\r\nvub300->usb_transport_fail = retval;\r\nvub300_queue_poll_work(vub300, 1);\r\ncomplete(&vub300->irqpoll_complete);\r\nreturn;\r\n} else {\r\nreturn;\r\n}\r\n}\r\nstatic void new_system_port_status(struct vub300_mmc_host *vub300)\r\n{\r\nint old_card_present = vub300->card_present;\r\nint new_card_present =\r\n(0x0001 & vub300->system_port_status.port_flags) ? 1 : 0;\r\nvub300->read_only =\r\n(0x0010 & vub300->system_port_status.port_flags) ? 1 : 0;\r\nif (new_card_present && !old_card_present) {\r\ndev_info(&vub300->udev->dev, "card just inserted\n");\r\nvub300->card_present = 1;\r\nvub300->bus_width = 0;\r\nif (disable_offload_processing)\r\nstrncpy(vub300->vub_name, "EMPTY Processing Disabled",\r\nsizeof(vub300->vub_name));\r\nelse\r\nvub300->vub_name[0] = 0;\r\nmmc_detect_change(vub300->mmc, 1);\r\n} else if (!new_card_present && old_card_present) {\r\ndev_info(&vub300->udev->dev, "card just ejected\n");\r\nvub300->card_present = 0;\r\nmmc_detect_change(vub300->mmc, 0);\r\n} else {\r\n}\r\n}\r\nstatic void __add_offloaded_reg_to_fifo(struct vub300_mmc_host *vub300,\r\nstruct offload_registers_access\r\n*register_access, u8 func)\r\n{\r\nu8 r = vub300->fn[func].offload_point + vub300->fn[func].offload_count;\r\nmemcpy(&vub300->fn[func].reg[MAXREGMASK & r], register_access,\r\nsizeof(struct offload_registers_access));\r\nvub300->fn[func].offload_count += 1;\r\nvub300->total_offload_count += 1;\r\n}\r\nstatic void add_offloaded_reg(struct vub300_mmc_host *vub300,\r\nstruct offload_registers_access *register_access)\r\n{\r\nu32 Register = ((0x03 & register_access->command_byte[0]) << 15)\r\n| ((0xFF & register_access->command_byte[1]) << 7)\r\n| ((0xFE & register_access->command_byte[2]) >> 1);\r\nu8 func = ((0x70 & register_access->command_byte[0]) >> 4);\r\nu8 regs = vub300->dynamic_register_count;\r\nu8 i = 0;\r\nwhile (0 < regs-- && 1 == vub300->sdio_register[i].activate) {\r\nif (vub300->sdio_register[i].func_num == func &&\r\nvub300->sdio_register[i].sdio_reg == Register) {\r\nif (vub300->sdio_register[i].prepared == 0)\r\nvub300->sdio_register[i].prepared = 1;\r\nvub300->sdio_register[i].response =\r\nregister_access->Respond_Byte[2];\r\nvub300->sdio_register[i].regvalue =\r\nregister_access->Respond_Byte[3];\r\nreturn;\r\n} else {\r\ni += 1;\r\ncontinue;\r\n}\r\n};\r\n__add_offloaded_reg_to_fifo(vub300, register_access, func);\r\n}\r\nstatic void check_vub300_port_status(struct vub300_mmc_host *vub300)\r\n{\r\nint retval;\r\nretval =\r\nusb_control_msg(vub300->udev, usb_rcvctrlpipe(vub300->udev, 0),\r\nGET_SYSTEM_PORT_STATUS,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0x0000, 0x0000, &vub300->system_port_status,\r\nsizeof(vub300->system_port_status), HZ);\r\nif (sizeof(vub300->system_port_status) == retval)\r\nnew_system_port_status(vub300);\r\n}\r\nstatic void __vub300_irqpoll_response(struct vub300_mmc_host *vub300)\r\n{\r\nif (vub300->command_res_urb->actual_length == 0)\r\nreturn;\r\nswitch (vub300->resp.common.header_type) {\r\ncase RESPONSE_INTERRUPT:\r\nmutex_lock(&vub300->irq_mutex);\r\nif (vub300->irq_enabled)\r\nmmc_signal_sdio_irq(vub300->mmc);\r\nelse\r\nvub300->irqs_queued += 1;\r\nvub300->irq_disabled = 1;\r\nmutex_unlock(&vub300->irq_mutex);\r\nbreak;\r\ncase RESPONSE_ERROR:\r\nif (vub300->resp.error.error_code == SD_ERROR_NO_DEVICE)\r\ncheck_vub300_port_status(vub300);\r\nbreak;\r\ncase RESPONSE_STATUS:\r\nvub300->system_port_status = vub300->resp.status;\r\nnew_system_port_status(vub300);\r\nif (!vub300->card_present)\r\nvub300_queue_poll_work(vub300, HZ / 5);\r\nbreak;\r\ncase RESPONSE_IRQ_DISABLED:\r\n{\r\nint offloaded_data_length = vub300->resp.common.header_size - 3;\r\nint register_count = offloaded_data_length >> 3;\r\nint ri = 0;\r\nwhile (register_count--) {\r\nadd_offloaded_reg(vub300, &vub300->resp.irq.reg[ri]);\r\nri += 1;\r\n}\r\nmutex_lock(&vub300->irq_mutex);\r\nif (vub300->irq_enabled)\r\nmmc_signal_sdio_irq(vub300->mmc);\r\nelse\r\nvub300->irqs_queued += 1;\r\nvub300->irq_disabled = 1;\r\nmutex_unlock(&vub300->irq_mutex);\r\nbreak;\r\n}\r\ncase RESPONSE_IRQ_ENABLED:\r\n{\r\nint offloaded_data_length = vub300->resp.common.header_size - 3;\r\nint register_count = offloaded_data_length >> 3;\r\nint ri = 0;\r\nwhile (register_count--) {\r\nadd_offloaded_reg(vub300, &vub300->resp.irq.reg[ri]);\r\nri += 1;\r\n}\r\nmutex_lock(&vub300->irq_mutex);\r\nif (vub300->irq_enabled)\r\nmmc_signal_sdio_irq(vub300->mmc);\r\nelse if (vub300->irqs_queued)\r\nvub300->irqs_queued += 1;\r\nelse\r\nvub300->irqs_queued += 1;\r\nvub300->irq_disabled = 0;\r\nmutex_unlock(&vub300->irq_mutex);\r\nbreak;\r\n}\r\ncase RESPONSE_NO_INTERRUPT:\r\nvub300_queue_poll_work(vub300, 1);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void __do_poll(struct vub300_mmc_host *vub300)\r\n{\r\nunsigned long commretval;\r\nmod_timer(&vub300->inactivity_timer, jiffies + HZ);\r\ninit_completion(&vub300->irqpoll_complete);\r\nsend_irqpoll(vub300);\r\ncommretval = wait_for_completion_timeout(&vub300->irqpoll_complete,\r\nmsecs_to_jiffies(500));\r\nif (vub300->usb_transport_fail) {\r\n} else if (commretval == 0) {\r\nvub300->usb_timed_out = 1;\r\nusb_kill_urb(vub300->command_out_urb);\r\nusb_kill_urb(vub300->command_res_urb);\r\n} else {\r\n__vub300_irqpoll_response(vub300);\r\n}\r\n}\r\nstatic void vub300_pollwork_thread(struct work_struct *work)\r\n{\r\nstruct vub300_mmc_host *vub300 = container_of(work,\r\nstruct vub300_mmc_host, pollwork.work);\r\nif (!vub300->interface) {\r\nkref_put(&vub300->kref, vub300_delete);\r\nreturn;\r\n}\r\nmutex_lock(&vub300->cmd_mutex);\r\nif (vub300->cmd) {\r\nvub300_queue_poll_work(vub300, 1);\r\n} else if (!vub300->card_present) {\r\n} else {\r\nmutex_lock(&vub300->irq_mutex);\r\nif (!vub300->irq_enabled) {\r\nmutex_unlock(&vub300->irq_mutex);\r\n} else if (vub300->irqs_queued) {\r\nvub300->irqs_queued -= 1;\r\nmmc_signal_sdio_irq(vub300->mmc);\r\nmod_timer(&vub300->inactivity_timer, jiffies + HZ);\r\nmutex_unlock(&vub300->irq_mutex);\r\n} else {\r\nmutex_unlock(&vub300->irq_mutex);\r\n__do_poll(vub300);\r\n}\r\n}\r\nmutex_unlock(&vub300->cmd_mutex);\r\nkref_put(&vub300->kref, vub300_delete);\r\n}\r\nstatic void vub300_deadwork_thread(struct work_struct *work)\r\n{\r\nstruct vub300_mmc_host *vub300 =\r\ncontainer_of(work, struct vub300_mmc_host, deadwork);\r\nif (!vub300->interface) {\r\nkref_put(&vub300->kref, vub300_delete);\r\nreturn;\r\n}\r\nmutex_lock(&vub300->cmd_mutex);\r\nif (vub300->cmd) {\r\n} else if (vub300->card_present) {\r\ncheck_vub300_port_status(vub300);\r\n} else if (vub300->mmc && vub300->mmc->card &&\r\nmmc_card_present(vub300->mmc->card)) {\r\n} else {\r\ncheck_vub300_port_status(vub300);\r\n}\r\nmod_timer(&vub300->inactivity_timer, jiffies + HZ);\r\nmutex_unlock(&vub300->cmd_mutex);\r\nkref_put(&vub300->kref, vub300_delete);\r\n}\r\nstatic void vub300_inactivity_timer_expired(unsigned long data)\r\n{\r\nstruct vub300_mmc_host *vub300 = (struct vub300_mmc_host *)data;\r\nif (!vub300->interface) {\r\nkref_put(&vub300->kref, vub300_delete);\r\n} else if (vub300->cmd) {\r\nmod_timer(&vub300->inactivity_timer, jiffies + HZ);\r\n} else {\r\nvub300_queue_dead_work(vub300);\r\nmod_timer(&vub300->inactivity_timer, jiffies + HZ);\r\n}\r\n}\r\nstatic int vub300_response_error(u8 error_code)\r\n{\r\nswitch (error_code) {\r\ncase SD_ERROR_PIO_TIMEOUT:\r\ncase SD_ERROR_1BIT_TIMEOUT:\r\ncase SD_ERROR_4BIT_TIMEOUT:\r\nreturn -ETIMEDOUT;\r\ncase SD_ERROR_STAT_DATA:\r\ncase SD_ERROR_OVERRUN:\r\ncase SD_ERROR_STAT_CMD:\r\ncase SD_ERROR_STAT_CMD_TIMEOUT:\r\ncase SD_ERROR_SDCRDY_STUCK:\r\ncase SD_ERROR_UNHANDLED:\r\ncase SD_ERROR_1BIT_CRC_WRONG:\r\ncase SD_ERROR_4BIT_CRC_WRONG:\r\ncase SD_ERROR_1BIT_CRC_ERROR:\r\ncase SD_ERROR_4BIT_CRC_ERROR:\r\ncase SD_ERROR_NO_CMD_ENDBIT:\r\ncase SD_ERROR_NO_1BIT_DATEND:\r\ncase SD_ERROR_NO_4BIT_DATEND:\r\ncase SD_ERROR_1BIT_DATA_TIMEOUT:\r\ncase SD_ERROR_4BIT_DATA_TIMEOUT:\r\ncase SD_ERROR_1BIT_UNEXPECTED_TIMEOUT:\r\ncase SD_ERROR_4BIT_UNEXPECTED_TIMEOUT:\r\nreturn -EILSEQ;\r\ncase 33:\r\nreturn -EILSEQ;\r\ncase SD_ERROR_ILLEGAL_COMMAND:\r\nreturn -EINVAL;\r\ncase SD_ERROR_NO_DEVICE:\r\nreturn -ENOMEDIUM;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\n}\r\nstatic void command_res_completed(struct urb *urb)\r\n{\r\nstruct vub300_mmc_host *vub300 = (struct vub300_mmc_host *)urb->context;\r\nif (urb->status) {\r\n} else if (vub300->command_res_urb->actual_length == 0) {\r\n} else if (!vub300->data) {\r\n} else if (vub300->resp.common.header_type != 0x02) {\r\n} else if (vub300->urb) {\r\nvub300->cmd->error =\r\nvub300_response_error(vub300->resp.error.error_code);\r\nusb_unlink_urb(vub300->urb);\r\n} else {\r\nvub300->cmd->error =\r\nvub300_response_error(vub300->resp.error.error_code);\r\nusb_sg_cancel(&vub300->sg_request);\r\n}\r\ncomplete(&vub300->command_complete);\r\n}\r\nstatic void command_out_completed(struct urb *urb)\r\n{\r\nstruct vub300_mmc_host *vub300 = (struct vub300_mmc_host *)urb->context;\r\nif (urb->status) {\r\ncomplete(&vub300->command_complete);\r\n} else {\r\nint ret;\r\nunsigned int pipe =\r\nusb_rcvbulkpipe(vub300->udev, vub300->cmnd_res_ep);\r\nusb_fill_bulk_urb(vub300->command_res_urb, vub300->udev, pipe,\r\n&vub300->resp, sizeof(vub300->resp),\r\ncommand_res_completed, vub300);\r\nvub300->command_res_urb->actual_length = 0;\r\nret = usb_submit_urb(vub300->command_res_urb, GFP_ATOMIC);\r\nif (ret == 0) {\r\n} else {\r\ncomplete(&vub300->command_complete);\r\n}\r\n}\r\n}\r\nstatic void snoop_block_size_and_bus_width(struct vub300_mmc_host *vub300,\r\nu32 cmd_arg)\r\n{\r\nif ((0xFBFFFE00 & cmd_arg) == 0x80022200)\r\nvub300->fbs[1] = (cmd_arg << 8) | (0x00FF & vub300->fbs[1]);\r\nelse if ((0xFBFFFE00 & cmd_arg) == 0x80022000)\r\nvub300->fbs[1] = (0xFF & cmd_arg) | (0xFF00 & vub300->fbs[1]);\r\nelse if ((0xFBFFFE00 & cmd_arg) == 0x80042200)\r\nvub300->fbs[2] = (cmd_arg << 8) | (0x00FF & vub300->fbs[2]);\r\nelse if ((0xFBFFFE00 & cmd_arg) == 0x80042000)\r\nvub300->fbs[2] = (0xFF & cmd_arg) | (0xFF00 & vub300->fbs[2]);\r\nelse if ((0xFBFFFE00 & cmd_arg) == 0x80062200)\r\nvub300->fbs[3] = (cmd_arg << 8) | (0x00FF & vub300->fbs[3]);\r\nelse if ((0xFBFFFE00 & cmd_arg) == 0x80062000)\r\nvub300->fbs[3] = (0xFF & cmd_arg) | (0xFF00 & vub300->fbs[3]);\r\nelse if ((0xFBFFFE00 & cmd_arg) == 0x80082200)\r\nvub300->fbs[4] = (cmd_arg << 8) | (0x00FF & vub300->fbs[4]);\r\nelse if ((0xFBFFFE00 & cmd_arg) == 0x80082000)\r\nvub300->fbs[4] = (0xFF & cmd_arg) | (0xFF00 & vub300->fbs[4]);\r\nelse if ((0xFBFFFE00 & cmd_arg) == 0x800A2200)\r\nvub300->fbs[5] = (cmd_arg << 8) | (0x00FF & vub300->fbs[5]);\r\nelse if ((0xFBFFFE00 & cmd_arg) == 0x800A2000)\r\nvub300->fbs[5] = (0xFF & cmd_arg) | (0xFF00 & vub300->fbs[5]);\r\nelse if ((0xFBFFFE00 & cmd_arg) == 0x800C2200)\r\nvub300->fbs[6] = (cmd_arg << 8) | (0x00FF & vub300->fbs[6]);\r\nelse if ((0xFBFFFE00 & cmd_arg) == 0x800C2000)\r\nvub300->fbs[6] = (0xFF & cmd_arg) | (0xFF00 & vub300->fbs[6]);\r\nelse if ((0xFBFFFE00 & cmd_arg) == 0x800E2200)\r\nvub300->fbs[7] = (cmd_arg << 8) | (0x00FF & vub300->fbs[7]);\r\nelse if ((0xFBFFFE00 & cmd_arg) == 0x800E2000)\r\nvub300->fbs[7] = (0xFF & cmd_arg) | (0xFF00 & vub300->fbs[7]);\r\nelse if ((0xFBFFFE03 & cmd_arg) == 0x80000E00)\r\nvub300->bus_width = 1;\r\nelse if ((0xFBFFFE03 & cmd_arg) == 0x80000E02)\r\nvub300->bus_width = 4;\r\n}\r\nstatic void send_command(struct vub300_mmc_host *vub300)\r\n{\r\nstruct mmc_command *cmd = vub300->cmd;\r\nstruct mmc_data *data = vub300->data;\r\nint retval;\r\nint i;\r\nu8 response_type;\r\nif (vub300->app_spec) {\r\nswitch (cmd->opcode) {\r\ncase 6:\r\nresponse_type = SDRT_1;\r\nvub300->resp_len = 6;\r\nif (0x00000000 == (0x00000003 & cmd->arg))\r\nvub300->bus_width = 1;\r\nelse if (0x00000002 == (0x00000003 & cmd->arg))\r\nvub300->bus_width = 4;\r\nelse\r\ndev_err(&vub300->udev->dev,\r\n"unexpected ACMD6 bus_width=%d\n",\r\n0x00000003 & cmd->arg);\r\nbreak;\r\ncase 13:\r\nresponse_type = SDRT_1;\r\nvub300->resp_len = 6;\r\nbreak;\r\ncase 22:\r\nresponse_type = SDRT_1;\r\nvub300->resp_len = 6;\r\nbreak;\r\ncase 23:\r\nresponse_type = SDRT_1;\r\nvub300->resp_len = 6;\r\nbreak;\r\ncase 41:\r\nresponse_type = SDRT_3;\r\nvub300->resp_len = 6;\r\nbreak;\r\ncase 42:\r\nresponse_type = SDRT_1;\r\nvub300->resp_len = 6;\r\nbreak;\r\ncase 51:\r\nresponse_type = SDRT_1;\r\nvub300->resp_len = 6;\r\nbreak;\r\ncase 55:\r\nresponse_type = SDRT_1;\r\nvub300->resp_len = 6;\r\nbreak;\r\ndefault:\r\nvub300->resp_len = 0;\r\ncmd->error = -EINVAL;\r\ncomplete(&vub300->command_complete);\r\nreturn;\r\n}\r\nvub300->app_spec = 0;\r\n} else {\r\nswitch (cmd->opcode) {\r\ncase 0:\r\nresponse_type = SDRT_NONE;\r\nvub300->resp_len = 0;\r\nbreak;\r\ncase 1:\r\nresponse_type = SDRT_3;\r\nvub300->resp_len = 6;\r\nbreak;\r\ncase 2:\r\nresponse_type = SDRT_2;\r\nvub300->resp_len = 17;\r\nbreak;\r\ncase 3:\r\nresponse_type = SDRT_6;\r\nvub300->resp_len = 6;\r\nbreak;\r\ncase 4:\r\nresponse_type = SDRT_NONE;\r\nvub300->resp_len = 0;\r\nbreak;\r\ncase 5:\r\nresponse_type = SDRT_4;\r\nvub300->resp_len = 6;\r\nbreak;\r\ncase 6:\r\nresponse_type = SDRT_1;\r\nvub300->resp_len = 6;\r\nbreak;\r\ncase 7:\r\nresponse_type = SDRT_1B;\r\nvub300->resp_len = 6;\r\nbreak;\r\ncase 8:\r\nresponse_type = SDRT_7;\r\nvub300->resp_len = 6;\r\nbreak;\r\ncase 9:\r\nresponse_type = SDRT_2;\r\nvub300->resp_len = 17;\r\nbreak;\r\ncase 10:\r\nresponse_type = SDRT_2;\r\nvub300->resp_len = 17;\r\nbreak;\r\ncase 12:\r\nresponse_type = SDRT_1B;\r\nvub300->resp_len = 6;\r\nbreak;\r\ncase 13:\r\nresponse_type = SDRT_1;\r\nvub300->resp_len = 6;\r\nbreak;\r\ncase 15:\r\nresponse_type = SDRT_NONE;\r\nvub300->resp_len = 0;\r\nbreak;\r\ncase 16:\r\nfor (i = 0; i < ARRAY_SIZE(vub300->fbs); i++)\r\nvub300->fbs[i] = 0xFFFF & cmd->arg;\r\nresponse_type = SDRT_1;\r\nvub300->resp_len = 6;\r\nbreak;\r\ncase 17:\r\ncase 18:\r\ncase 24:\r\ncase 25:\r\ncase 27:\r\nresponse_type = SDRT_1;\r\nvub300->resp_len = 6;\r\nbreak;\r\ncase 28:\r\ncase 29:\r\nresponse_type = SDRT_1B;\r\nvub300->resp_len = 6;\r\nbreak;\r\ncase 30:\r\ncase 32:\r\ncase 33:\r\nresponse_type = SDRT_1;\r\nvub300->resp_len = 6;\r\nbreak;\r\ncase 38:\r\nresponse_type = SDRT_1B;\r\nvub300->resp_len = 6;\r\nbreak;\r\ncase 42:\r\nresponse_type = SDRT_1;\r\nvub300->resp_len = 6;\r\nbreak;\r\ncase 52:\r\nresponse_type = SDRT_5;\r\nvub300->resp_len = 6;\r\nsnoop_block_size_and_bus_width(vub300, cmd->arg);\r\nbreak;\r\ncase 53:\r\nresponse_type = SDRT_5;\r\nvub300->resp_len = 6;\r\nbreak;\r\ncase 55:\r\nresponse_type = SDRT_1;\r\nvub300->resp_len = 6;\r\nvub300->app_spec = 1;\r\nbreak;\r\ncase 56:\r\nresponse_type = SDRT_1;\r\nvub300->resp_len = 6;\r\nbreak;\r\ndefault:\r\nvub300->resp_len = 0;\r\ncmd->error = -EINVAL;\r\ncomplete(&vub300->command_complete);\r\nreturn;\r\n}\r\n}\r\nvub300->cmnd.head.header_size = 20;\r\nvub300->cmnd.head.header_type = 0x00;\r\nvub300->cmnd.head.port_number = 0;\r\nvub300->cmnd.head.command_type = 0x00;\r\nvub300->cmnd.head.response_type = response_type;\r\nvub300->cmnd.head.command_index = cmd->opcode;\r\nvub300->cmnd.head.arguments[0] = cmd->arg >> 24;\r\nvub300->cmnd.head.arguments[1] = cmd->arg >> 16;\r\nvub300->cmnd.head.arguments[2] = cmd->arg >> 8;\r\nvub300->cmnd.head.arguments[3] = cmd->arg >> 0;\r\nif (cmd->opcode == 52) {\r\nint fn = 0x7 & (cmd->arg >> 28);\r\nvub300->cmnd.head.block_count[0] = 0;\r\nvub300->cmnd.head.block_count[1] = 0;\r\nvub300->cmnd.head.block_size[0] = (vub300->fbs[fn] >> 8) & 0xFF;\r\nvub300->cmnd.head.block_size[1] = (vub300->fbs[fn] >> 0) & 0xFF;\r\nvub300->cmnd.head.command_type = 0x00;\r\nvub300->cmnd.head.transfer_size[0] = 0;\r\nvub300->cmnd.head.transfer_size[1] = 0;\r\nvub300->cmnd.head.transfer_size[2] = 0;\r\nvub300->cmnd.head.transfer_size[3] = 0;\r\n} else if (!data) {\r\nvub300->cmnd.head.block_count[0] = 0;\r\nvub300->cmnd.head.block_count[1] = 0;\r\nvub300->cmnd.head.block_size[0] = (vub300->fbs[0] >> 8) & 0xFF;\r\nvub300->cmnd.head.block_size[1] = (vub300->fbs[0] >> 0) & 0xFF;\r\nvub300->cmnd.head.command_type = 0x00;\r\nvub300->cmnd.head.transfer_size[0] = 0;\r\nvub300->cmnd.head.transfer_size[1] = 0;\r\nvub300->cmnd.head.transfer_size[2] = 0;\r\nvub300->cmnd.head.transfer_size[3] = 0;\r\n} else if (cmd->opcode == 53) {\r\nint fn = 0x7 & (cmd->arg >> 28);\r\nif (0x08 & vub300->cmnd.head.arguments[0]) {\r\nvub300->cmnd.head.block_count[0] =\r\n(data->blocks >> 8) & 0xFF;\r\nvub300->cmnd.head.block_count[1] =\r\n(data->blocks >> 0) & 0xFF;\r\nvub300->cmnd.head.block_size[0] =\r\n(data->blksz >> 8) & 0xFF;\r\nvub300->cmnd.head.block_size[1] =\r\n(data->blksz >> 0) & 0xFF;\r\n} else {\r\nvub300->cmnd.head.block_count[0] = 0;\r\nvub300->cmnd.head.block_count[1] = 0;\r\nvub300->cmnd.head.block_size[0] =\r\n(vub300->datasize >> 8) & 0xFF;\r\nvub300->cmnd.head.block_size[1] =\r\n(vub300->datasize >> 0) & 0xFF;\r\n}\r\nvub300->cmnd.head.command_type =\r\n(MMC_DATA_READ & data->flags) ? 0x00 : 0x80;\r\nvub300->cmnd.head.transfer_size[0] =\r\n(vub300->datasize >> 24) & 0xFF;\r\nvub300->cmnd.head.transfer_size[1] =\r\n(vub300->datasize >> 16) & 0xFF;\r\nvub300->cmnd.head.transfer_size[2] =\r\n(vub300->datasize >> 8) & 0xFF;\r\nvub300->cmnd.head.transfer_size[3] =\r\n(vub300->datasize >> 0) & 0xFF;\r\nif (vub300->datasize < vub300->fbs[fn]) {\r\nvub300->cmnd.head.block_count[0] = 0;\r\nvub300->cmnd.head.block_count[1] = 0;\r\n}\r\n} else {\r\nvub300->cmnd.head.block_count[0] = (data->blocks >> 8) & 0xFF;\r\nvub300->cmnd.head.block_count[1] = (data->blocks >> 0) & 0xFF;\r\nvub300->cmnd.head.block_size[0] = (data->blksz >> 8) & 0xFF;\r\nvub300->cmnd.head.block_size[1] = (data->blksz >> 0) & 0xFF;\r\nvub300->cmnd.head.command_type =\r\n(MMC_DATA_READ & data->flags) ? 0x00 : 0x80;\r\nvub300->cmnd.head.transfer_size[0] =\r\n(vub300->datasize >> 24) & 0xFF;\r\nvub300->cmnd.head.transfer_size[1] =\r\n(vub300->datasize >> 16) & 0xFF;\r\nvub300->cmnd.head.transfer_size[2] =\r\n(vub300->datasize >> 8) & 0xFF;\r\nvub300->cmnd.head.transfer_size[3] =\r\n(vub300->datasize >> 0) & 0xFF;\r\nif (vub300->datasize < vub300->fbs[0]) {\r\nvub300->cmnd.head.block_count[0] = 0;\r\nvub300->cmnd.head.block_count[1] = 0;\r\n}\r\n}\r\nif (vub300->cmnd.head.block_size[0] || vub300->cmnd.head.block_size[1]) {\r\nu16 block_size = vub300->cmnd.head.block_size[1] |\r\n(vub300->cmnd.head.block_size[0] << 8);\r\nu16 block_boundary = FIRMWARE_BLOCK_BOUNDARY -\r\n(FIRMWARE_BLOCK_BOUNDARY % block_size);\r\nvub300->cmnd.head.block_boundary[0] =\r\n(block_boundary >> 8) & 0xFF;\r\nvub300->cmnd.head.block_boundary[1] =\r\n(block_boundary >> 0) & 0xFF;\r\n} else {\r\nvub300->cmnd.head.block_boundary[0] = 0;\r\nvub300->cmnd.head.block_boundary[1] = 0;\r\n}\r\nusb_fill_bulk_urb(vub300->command_out_urb, vub300->udev,\r\nusb_sndbulkpipe(vub300->udev, vub300->cmnd_out_ep),\r\n&vub300->cmnd, sizeof(vub300->cmnd),\r\ncommand_out_completed, vub300);\r\nretval = usb_submit_urb(vub300->command_out_urb, GFP_KERNEL);\r\nif (retval < 0) {\r\ncmd->error = retval;\r\ncomplete(&vub300->command_complete);\r\nreturn;\r\n} else {\r\nreturn;\r\n}\r\n}\r\nstatic void vub300_sg_timed_out(unsigned long data)\r\n{\r\nstruct vub300_mmc_host *vub300 = (struct vub300_mmc_host *)data;\r\nvub300->usb_timed_out = 1;\r\nusb_sg_cancel(&vub300->sg_request);\r\nusb_unlink_urb(vub300->command_out_urb);\r\nusb_unlink_urb(vub300->command_res_urb);\r\n}\r\nstatic u16 roundup_to_multiple_of_64(u16 number)\r\n{\r\nreturn 0xFFC0 & (0x3F + number);\r\n}\r\nstatic void __download_offload_pseudocode(struct vub300_mmc_host *vub300,\r\nconst struct firmware *fw)\r\n{\r\nu8 register_count = 0;\r\nu16 ts = 0;\r\nu16 interrupt_size = 0;\r\nconst u8 *data = fw->data;\r\nint size = fw->size;\r\nu8 c;\r\ndev_info(&vub300->udev->dev, "using %s for SDIO offload processing\n",\r\nvub300->vub_name);\r\ndo {\r\nc = *data++;\r\n} while (size-- && c);\r\ndev_info(&vub300->udev->dev, "using offload firmware %s %s\n", fw->data,\r\nvub300->vub_name);\r\nif (size < 4) {\r\ndev_err(&vub300->udev->dev,\r\n"corrupt offload pseudocode in firmware %s\n",\r\nvub300->vub_name);\r\nstrncpy(vub300->vub_name, "corrupt offload pseudocode",\r\nsizeof(vub300->vub_name));\r\nreturn;\r\n}\r\ninterrupt_size += *data++;\r\nsize -= 1;\r\ninterrupt_size <<= 8;\r\ninterrupt_size += *data++;\r\nsize -= 1;\r\nif (interrupt_size < size) {\r\nu16 xfer_length = roundup_to_multiple_of_64(interrupt_size);\r\nu8 *xfer_buffer = kmalloc(xfer_length, GFP_KERNEL);\r\nif (xfer_buffer) {\r\nint retval;\r\nmemcpy(xfer_buffer, data, interrupt_size);\r\nmemset(xfer_buffer + interrupt_size, 0,\r\nxfer_length - interrupt_size);\r\nsize -= interrupt_size;\r\ndata += interrupt_size;\r\nretval =\r\nusb_control_msg(vub300->udev,\r\nusb_sndctrlpipe(vub300->udev, 0),\r\nSET_INTERRUPT_PSEUDOCODE,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_DEVICE, 0x0000, 0x0000,\r\nxfer_buffer, xfer_length, HZ);\r\nkfree(xfer_buffer);\r\nif (retval < 0) {\r\nstrncpy(vub300->vub_name,\r\n"SDIO pseudocode download failed",\r\nsizeof(vub300->vub_name));\r\nreturn;\r\n}\r\n} else {\r\ndev_err(&vub300->udev->dev,\r\n"not enough memory for xfer buffer to send"\r\n" INTERRUPT_PSEUDOCODE for %s %s\n", fw->data,\r\nvub300->vub_name);\r\nstrncpy(vub300->vub_name,\r\n"SDIO interrupt pseudocode download failed",\r\nsizeof(vub300->vub_name));\r\nreturn;\r\n}\r\n} else {\r\ndev_err(&vub300->udev->dev,\r\n"corrupt interrupt pseudocode in firmware %s %s\n",\r\nfw->data, vub300->vub_name);\r\nstrncpy(vub300->vub_name, "corrupt interrupt pseudocode",\r\nsizeof(vub300->vub_name));\r\nreturn;\r\n}\r\nts += *data++;\r\nsize -= 1;\r\nts <<= 8;\r\nts += *data++;\r\nsize -= 1;\r\nif (ts < size) {\r\nu16 xfer_length = roundup_to_multiple_of_64(ts);\r\nu8 *xfer_buffer = kmalloc(xfer_length, GFP_KERNEL);\r\nif (xfer_buffer) {\r\nint retval;\r\nmemcpy(xfer_buffer, data, ts);\r\nmemset(xfer_buffer + ts, 0,\r\nxfer_length - ts);\r\nsize -= ts;\r\ndata += ts;\r\nretval =\r\nusb_control_msg(vub300->udev,\r\nusb_sndctrlpipe(vub300->udev, 0),\r\nSET_TRANSFER_PSEUDOCODE,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_DEVICE, 0x0000, 0x0000,\r\nxfer_buffer, xfer_length, HZ);\r\nkfree(xfer_buffer);\r\nif (retval < 0) {\r\nstrncpy(vub300->vub_name,\r\n"SDIO pseudocode download failed",\r\nsizeof(vub300->vub_name));\r\nreturn;\r\n}\r\n} else {\r\ndev_err(&vub300->udev->dev,\r\n"not enough memory for xfer buffer to send"\r\n" TRANSFER_PSEUDOCODE for %s %s\n", fw->data,\r\nvub300->vub_name);\r\nstrncpy(vub300->vub_name,\r\n"SDIO transfer pseudocode download failed",\r\nsizeof(vub300->vub_name));\r\nreturn;\r\n}\r\n} else {\r\ndev_err(&vub300->udev->dev,\r\n"corrupt transfer pseudocode in firmware %s %s\n",\r\nfw->data, vub300->vub_name);\r\nstrncpy(vub300->vub_name, "corrupt transfer pseudocode",\r\nsizeof(vub300->vub_name));\r\nreturn;\r\n}\r\nregister_count += *data++;\r\nsize -= 1;\r\nif (register_count * 4 == size) {\r\nint I = vub300->dynamic_register_count = register_count;\r\nint i = 0;\r\nwhile (I--) {\r\nunsigned int func_num = 0;\r\nvub300->sdio_register[i].func_num = *data++;\r\nsize -= 1;\r\nfunc_num += *data++;\r\nsize -= 1;\r\nfunc_num <<= 8;\r\nfunc_num += *data++;\r\nsize -= 1;\r\nfunc_num <<= 8;\r\nfunc_num += *data++;\r\nsize -= 1;\r\nvub300->sdio_register[i].sdio_reg = func_num;\r\nvub300->sdio_register[i].activate = 1;\r\nvub300->sdio_register[i].prepared = 0;\r\ni += 1;\r\n}\r\ndev_info(&vub300->udev->dev,\r\n"initialized %d dynamic pseudocode registers\n",\r\nvub300->dynamic_register_count);\r\nreturn;\r\n} else {\r\ndev_err(&vub300->udev->dev,\r\n"corrupt dynamic registers in firmware %s\n",\r\nvub300->vub_name);\r\nstrncpy(vub300->vub_name, "corrupt dynamic registers",\r\nsizeof(vub300->vub_name));\r\nreturn;\r\n}\r\n}\r\nstatic void download_offload_pseudocode(struct vub300_mmc_host *vub300)\r\n{\r\nstruct mmc_card *card = vub300->mmc->card;\r\nint sdio_funcs = card->sdio_funcs;\r\nconst struct firmware *fw = NULL;\r\nint l = snprintf(vub300->vub_name, sizeof(vub300->vub_name),\r\n"vub_%04X%04X", card->cis.vendor, card->cis.device);\r\nint n = 0;\r\nint retval;\r\nfor (n = 0; n < sdio_funcs; n++) {\r\nstruct sdio_func *sf = card->sdio_func[n];\r\nl += snprintf(vub300->vub_name + l,\r\nsizeof(vub300->vub_name) - l, "_%04X%04X",\r\nsf->vendor, sf->device);\r\n};\r\nsnprintf(vub300->vub_name + l, sizeof(vub300->vub_name) - l, ".bin");\r\ndev_info(&vub300->udev->dev, "requesting offload firmware %s\n",\r\nvub300->vub_name);\r\nretval = request_firmware(&fw, vub300->vub_name, &card->dev);\r\nif (retval < 0) {\r\nstrncpy(vub300->vub_name, "vub_default.bin",\r\nsizeof(vub300->vub_name));\r\nretval = request_firmware(&fw, vub300->vub_name, &card->dev);\r\nif (retval < 0) {\r\nstrncpy(vub300->vub_name,\r\n"no SDIO offload firmware found",\r\nsizeof(vub300->vub_name));\r\n} else {\r\n__download_offload_pseudocode(vub300, fw);\r\nrelease_firmware(fw);\r\n}\r\n} else {\r\n__download_offload_pseudocode(vub300, fw);\r\nrelease_firmware(fw);\r\n}\r\n}\r\nstatic void vub300_usb_bulk_msg_completion(struct urb *urb)\r\n{\r\ncomplete((struct completion *)urb->context);\r\n}\r\nstatic int vub300_usb_bulk_msg(struct vub300_mmc_host *vub300,\r\nunsigned int pipe, void *data, int len,\r\nint *actual_length, int timeout_msecs)\r\n{\r\nstruct usb_device *usb_dev = vub300->udev;\r\nstruct completion done;\r\nint retval;\r\nvub300->urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!vub300->urb)\r\nreturn -ENOMEM;\r\nusb_fill_bulk_urb(vub300->urb, usb_dev, pipe, data, len,\r\nvub300_usb_bulk_msg_completion, NULL);\r\ninit_completion(&done);\r\nvub300->urb->context = &done;\r\nvub300->urb->actual_length = 0;\r\nretval = usb_submit_urb(vub300->urb, GFP_KERNEL);\r\nif (unlikely(retval))\r\ngoto out;\r\nif (!wait_for_completion_timeout\r\n(&done, msecs_to_jiffies(timeout_msecs))) {\r\nretval = -ETIMEDOUT;\r\nusb_kill_urb(vub300->urb);\r\n} else {\r\nretval = vub300->urb->status;\r\n}\r\nout:\r\n*actual_length = vub300->urb->actual_length;\r\nusb_free_urb(vub300->urb);\r\nvub300->urb = NULL;\r\nreturn retval;\r\n}\r\nstatic int __command_read_data(struct vub300_mmc_host *vub300,\r\nstruct mmc_command *cmd, struct mmc_data *data)\r\n{\r\nint linear_length = vub300->datasize;\r\nint padded_length = vub300->large_usb_packets ?\r\n((511 + linear_length) >> 9) << 9 :\r\n((63 + linear_length) >> 6) << 6;\r\nif ((padded_length == linear_length) || !pad_input_to_usb_pkt) {\r\nint result;\r\nunsigned pipe;\r\npipe = usb_rcvbulkpipe(vub300->udev, vub300->data_inp_ep);\r\nresult = usb_sg_init(&vub300->sg_request, vub300->udev,\r\npipe, 0, data->sg,\r\ndata->sg_len, 0, GFP_KERNEL);\r\nif (result < 0) {\r\nusb_unlink_urb(vub300->command_out_urb);\r\nusb_unlink_urb(vub300->command_res_urb);\r\ncmd->error = result;\r\ndata->bytes_xfered = 0;\r\nreturn 0;\r\n} else {\r\nvub300->sg_transfer_timer.expires =\r\njiffies + msecs_to_jiffies(2000 +\r\n(linear_length / 16384));\r\nadd_timer(&vub300->sg_transfer_timer);\r\nusb_sg_wait(&vub300->sg_request);\r\ndel_timer(&vub300->sg_transfer_timer);\r\nif (vub300->sg_request.status < 0) {\r\ncmd->error = vub300->sg_request.status;\r\ndata->bytes_xfered = 0;\r\nreturn 0;\r\n} else {\r\ndata->bytes_xfered = vub300->datasize;\r\nreturn linear_length;\r\n}\r\n}\r\n} else {\r\nu8 *buf = kmalloc(padded_length, GFP_KERNEL);\r\nif (buf) {\r\nint result;\r\nunsigned pipe = usb_rcvbulkpipe(vub300->udev,\r\nvub300->data_inp_ep);\r\nint actual_length = 0;\r\nresult = vub300_usb_bulk_msg(vub300, pipe, buf,\r\npadded_length, &actual_length,\r\n2000 + (padded_length / 16384));\r\nif (result < 0) {\r\ncmd->error = result;\r\ndata->bytes_xfered = 0;\r\nkfree(buf);\r\nreturn 0;\r\n} else if (actual_length < linear_length) {\r\ncmd->error = -EREMOTEIO;\r\ndata->bytes_xfered = 0;\r\nkfree(buf);\r\nreturn 0;\r\n} else {\r\nsg_copy_from_buffer(data->sg, data->sg_len, buf,\r\nlinear_length);\r\nkfree(buf);\r\ndata->bytes_xfered = vub300->datasize;\r\nreturn linear_length;\r\n}\r\n} else {\r\ncmd->error = -ENOMEM;\r\ndata->bytes_xfered = 0;\r\nreturn 0;\r\n}\r\n}\r\n}\r\nstatic int __command_write_data(struct vub300_mmc_host *vub300,\r\nstruct mmc_command *cmd, struct mmc_data *data)\r\n{\r\nunsigned pipe = usb_sndbulkpipe(vub300->udev, vub300->data_out_ep);\r\nint linear_length = vub300->datasize;\r\nint modulo_64_length = linear_length & 0x003F;\r\nint modulo_512_length = linear_length & 0x01FF;\r\nif (linear_length < 64) {\r\nint result;\r\nint actual_length;\r\nsg_copy_to_buffer(data->sg, data->sg_len,\r\nvub300->padded_buffer,\r\nsizeof(vub300->padded_buffer));\r\nmemset(vub300->padded_buffer + linear_length, 0,\r\nsizeof(vub300->padded_buffer) - linear_length);\r\nresult = vub300_usb_bulk_msg(vub300, pipe, vub300->padded_buffer,\r\nsizeof(vub300->padded_buffer),\r\n&actual_length, 2000 +\r\n(sizeof(vub300->padded_buffer) /\r\n16384));\r\nif (result < 0) {\r\ncmd->error = result;\r\ndata->bytes_xfered = 0;\r\n} else {\r\ndata->bytes_xfered = vub300->datasize;\r\n}\r\n} else if ((!vub300->large_usb_packets && (0 < modulo_64_length)) ||\r\n(vub300->large_usb_packets && (64 > modulo_512_length))\r\n) {\r\nint padded_length = ((63 + linear_length) >> 6) << 6;\r\nu8 *buf = kmalloc(padded_length, GFP_KERNEL);\r\nif (buf) {\r\nint result;\r\nint actual_length;\r\nsg_copy_to_buffer(data->sg, data->sg_len, buf,\r\npadded_length);\r\nmemset(buf + linear_length, 0,\r\npadded_length - linear_length);\r\nresult =\r\nvub300_usb_bulk_msg(vub300, pipe, buf,\r\npadded_length, &actual_length,\r\n2000 + padded_length / 16384);\r\nkfree(buf);\r\nif (result < 0) {\r\ncmd->error = result;\r\ndata->bytes_xfered = 0;\r\n} else {\r\ndata->bytes_xfered = vub300->datasize;\r\n}\r\n} else {\r\ncmd->error = -ENOMEM;\r\ndata->bytes_xfered = 0;\r\n}\r\n} else {\r\nint result;\r\nunsigned char buf[64 * 4];\r\nsg_copy_to_buffer(data->sg, data->sg_len, buf, sizeof(buf));\r\nresult = usb_sg_init(&vub300->sg_request, vub300->udev,\r\npipe, 0, data->sg,\r\ndata->sg_len, 0, GFP_KERNEL);\r\nif (result < 0) {\r\nusb_unlink_urb(vub300->command_out_urb);\r\nusb_unlink_urb(vub300->command_res_urb);\r\ncmd->error = result;\r\ndata->bytes_xfered = 0;\r\n} else {\r\nvub300->sg_transfer_timer.expires =\r\njiffies + msecs_to_jiffies(2000 +\r\nlinear_length / 16384);\r\nadd_timer(&vub300->sg_transfer_timer);\r\nusb_sg_wait(&vub300->sg_request);\r\nif (cmd->error) {\r\ndata->bytes_xfered = 0;\r\n} else {\r\ndel_timer(&vub300->sg_transfer_timer);\r\nif (vub300->sg_request.status < 0) {\r\ncmd->error = vub300->sg_request.status;\r\ndata->bytes_xfered = 0;\r\n} else {\r\ndata->bytes_xfered = vub300->datasize;\r\n}\r\n}\r\n}\r\n}\r\nreturn linear_length;\r\n}\r\nstatic void __vub300_command_response(struct vub300_mmc_host *vub300,\r\nstruct mmc_command *cmd,\r\nstruct mmc_data *data, int data_length)\r\n{\r\nlong respretval;\r\nint msec_timeout = 1000 + data_length / 4;\r\nrespretval =\r\nwait_for_completion_timeout(&vub300->command_complete,\r\nmsecs_to_jiffies(msec_timeout));\r\nif (respretval == 0) {\r\nint result;\r\nvub300->usb_timed_out = 1;\r\nusb_kill_urb(vub300->command_out_urb);\r\nusb_kill_urb(vub300->command_res_urb);\r\ncmd->error = -ETIMEDOUT;\r\nresult = usb_lock_device_for_reset(vub300->udev,\r\nvub300->interface);\r\nif (result == 0) {\r\nresult = usb_reset_device(vub300->udev);\r\nusb_unlock_device(vub300->udev);\r\n}\r\n} else if (respretval < 0) {\r\nusb_kill_urb(vub300->command_out_urb);\r\nusb_kill_urb(vub300->command_res_urb);\r\ncmd->error = respretval;\r\n} else if (cmd->error) {\r\n} else if (vub300->command_out_urb->status) {\r\nvub300->usb_transport_fail = vub300->command_out_urb->status;\r\ncmd->error = -EPROTO == vub300->command_out_urb->status ?\r\n-ESHUTDOWN : vub300->command_out_urb->status;\r\n} else if (vub300->command_res_urb->status) {\r\nvub300->usb_transport_fail = vub300->command_res_urb->status;\r\ncmd->error = -EPROTO == vub300->command_res_urb->status ?\r\n-ESHUTDOWN : vub300->command_res_urb->status;\r\n} else if (vub300->resp.common.header_type == 0x00) {\r\n} else if (vub300->resp.common.header_type == RESPONSE_ERROR) {\r\ncmd->error =\r\nvub300_response_error(vub300->resp.error.error_code);\r\nif (vub300->data)\r\nusb_sg_cancel(&vub300->sg_request);\r\n} else if (vub300->resp.common.header_type == RESPONSE_PIGGYBACKED) {\r\nint offloaded_data_length =\r\nvub300->resp.common.header_size -\r\nsizeof(struct sd_register_header);\r\nint register_count = offloaded_data_length >> 3;\r\nint ri = 0;\r\nwhile (register_count--) {\r\nadd_offloaded_reg(vub300, &vub300->resp.pig.reg[ri]);\r\nri += 1;\r\n}\r\nvub300->resp.common.header_size =\r\nsizeof(struct sd_register_header);\r\nvub300->resp.common.header_type = 0x00;\r\ncmd->error = 0;\r\n} else if (vub300->resp.common.header_type == RESPONSE_PIG_DISABLED) {\r\nint offloaded_data_length =\r\nvub300->resp.common.header_size -\r\nsizeof(struct sd_register_header);\r\nint register_count = offloaded_data_length >> 3;\r\nint ri = 0;\r\nwhile (register_count--) {\r\nadd_offloaded_reg(vub300, &vub300->resp.pig.reg[ri]);\r\nri += 1;\r\n}\r\nmutex_lock(&vub300->irq_mutex);\r\nif (vub300->irqs_queued) {\r\nvub300->irqs_queued += 1;\r\n} else if (vub300->irq_enabled) {\r\nvub300->irqs_queued += 1;\r\nvub300_queue_poll_work(vub300, 0);\r\n} else {\r\nvub300->irqs_queued += 1;\r\n}\r\nvub300->irq_disabled = 1;\r\nmutex_unlock(&vub300->irq_mutex);\r\nvub300->resp.common.header_size =\r\nsizeof(struct sd_register_header);\r\nvub300->resp.common.header_type = 0x00;\r\ncmd->error = 0;\r\n} else if (vub300->resp.common.header_type == RESPONSE_PIG_ENABLED) {\r\nint offloaded_data_length =\r\nvub300->resp.common.header_size -\r\nsizeof(struct sd_register_header);\r\nint register_count = offloaded_data_length >> 3;\r\nint ri = 0;\r\nwhile (register_count--) {\r\nadd_offloaded_reg(vub300, &vub300->resp.pig.reg[ri]);\r\nri += 1;\r\n}\r\nmutex_lock(&vub300->irq_mutex);\r\nif (vub300->irqs_queued) {\r\nvub300->irqs_queued += 1;\r\n} else if (vub300->irq_enabled) {\r\nvub300->irqs_queued += 1;\r\nvub300_queue_poll_work(vub300, 0);\r\n} else {\r\nvub300->irqs_queued += 1;\r\n}\r\nvub300->irq_disabled = 0;\r\nmutex_unlock(&vub300->irq_mutex);\r\nvub300->resp.common.header_size =\r\nsizeof(struct sd_register_header);\r\nvub300->resp.common.header_type = 0x00;\r\ncmd->error = 0;\r\n} else {\r\ncmd->error = -EINVAL;\r\n}\r\n}\r\nstatic void construct_request_response(struct vub300_mmc_host *vub300,\r\nstruct mmc_command *cmd)\r\n{\r\nint resp_len = vub300->resp_len;\r\nint less_cmd = (17 == resp_len) ? resp_len : resp_len - 1;\r\nint bytes = 3 & less_cmd;\r\nint words = less_cmd >> 2;\r\nu8 *r = vub300->resp.response.command_response;\r\nif (bytes == 3) {\r\ncmd->resp[words] = (r[1 + (words << 2)] << 24)\r\n| (r[2 + (words << 2)] << 16)\r\n| (r[3 + (words << 2)] << 8);\r\n} else if (bytes == 2) {\r\ncmd->resp[words] = (r[1 + (words << 2)] << 24)\r\n| (r[2 + (words << 2)] << 16);\r\n} else if (bytes == 1) {\r\ncmd->resp[words] = (r[1 + (words << 2)] << 24);\r\n}\r\nwhile (words-- > 0) {\r\ncmd->resp[words] = (r[1 + (words << 2)] << 24)\r\n| (r[2 + (words << 2)] << 16)\r\n| (r[3 + (words << 2)] << 8)\r\n| (r[4 + (words << 2)] << 0);\r\n}\r\nif ((cmd->opcode == 53) && (0x000000FF & cmd->resp[0]))\r\ncmd->resp[0] &= 0xFFFFFF00;\r\n}\r\nstatic void vub300_cmndwork_thread(struct work_struct *work)\r\n{\r\nstruct vub300_mmc_host *vub300 =\r\ncontainer_of(work, struct vub300_mmc_host, cmndwork);\r\nif (!vub300->interface) {\r\nkref_put(&vub300->kref, vub300_delete);\r\nreturn;\r\n} else {\r\nstruct mmc_request *req = vub300->req;\r\nstruct mmc_command *cmd = vub300->cmd;\r\nstruct mmc_data *data = vub300->data;\r\nint data_length;\r\nmutex_lock(&vub300->cmd_mutex);\r\ninit_completion(&vub300->command_complete);\r\nif (likely(vub300->vub_name[0]) || !vub300->mmc->card ||\r\n!mmc_card_present(vub300->mmc->card)) {\r\n} else if (0 == vub300->mmc->card->sdio_funcs) {\r\nstrncpy(vub300->vub_name, "SD memory device",\r\nsizeof(vub300->vub_name));\r\n} else {\r\ndownload_offload_pseudocode(vub300);\r\n}\r\nsend_command(vub300);\r\nif (!data)\r\ndata_length = 0;\r\nelse if (MMC_DATA_READ & data->flags)\r\ndata_length = __command_read_data(vub300, cmd, data);\r\nelse\r\ndata_length = __command_write_data(vub300, cmd, data);\r\n__vub300_command_response(vub300, cmd, data, data_length);\r\nvub300->req = NULL;\r\nvub300->cmd = NULL;\r\nvub300->data = NULL;\r\nif (cmd->error) {\r\nif (cmd->error == -ENOMEDIUM)\r\ncheck_vub300_port_status(vub300);\r\nmutex_unlock(&vub300->cmd_mutex);\r\nmmc_request_done(vub300->mmc, req);\r\nkref_put(&vub300->kref, vub300_delete);\r\nreturn;\r\n} else {\r\nconstruct_request_response(vub300, cmd);\r\nvub300->resp_len = 0;\r\nmutex_unlock(&vub300->cmd_mutex);\r\nkref_put(&vub300->kref, vub300_delete);\r\nmmc_request_done(vub300->mmc, req);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic int examine_cyclic_buffer(struct vub300_mmc_host *vub300,\r\nstruct mmc_command *cmd, u8 Function)\r\n{\r\nu8 cmd0 = 0xFF & (cmd->arg >> 24);\r\nu8 cmd1 = 0xFF & (cmd->arg >> 16);\r\nu8 cmd2 = 0xFF & (cmd->arg >> 8);\r\nu8 cmd3 = 0xFF & (cmd->arg >> 0);\r\nint first = MAXREGMASK & vub300->fn[Function].offload_point;\r\nstruct offload_registers_access *rf = &vub300->fn[Function].reg[first];\r\nif (cmd0 == rf->command_byte[0] &&\r\ncmd1 == rf->command_byte[1] &&\r\ncmd2 == rf->command_byte[2] &&\r\ncmd3 == rf->command_byte[3]) {\r\nu8 checksum = 0x00;\r\ncmd->resp[1] = checksum << 24;\r\ncmd->resp[0] = (rf->Respond_Byte[0] << 24)\r\n| (rf->Respond_Byte[1] << 16)\r\n| (rf->Respond_Byte[2] << 8)\r\n| (rf->Respond_Byte[3] << 0);\r\nvub300->fn[Function].offload_point += 1;\r\nvub300->fn[Function].offload_count -= 1;\r\nvub300->total_offload_count -= 1;\r\nreturn 1;\r\n} else {\r\nint delta = 1;\r\nu8 register_count = vub300->fn[Function].offload_count - 1;\r\nu32 register_point = vub300->fn[Function].offload_point + 1;\r\nwhile (0 < register_count) {\r\nint point = MAXREGMASK & register_point;\r\nstruct offload_registers_access *r =\r\n&vub300->fn[Function].reg[point];\r\nif (cmd0 == r->command_byte[0] &&\r\ncmd1 == r->command_byte[1] &&\r\ncmd2 == r->command_byte[2] &&\r\ncmd3 == r->command_byte[3]) {\r\nu8 checksum = 0x00;\r\ncmd->resp[1] = checksum << 24;\r\ncmd->resp[0] = (r->Respond_Byte[0] << 24)\r\n| (r->Respond_Byte[1] << 16)\r\n| (r->Respond_Byte[2] << 8)\r\n| (r->Respond_Byte[3] << 0);\r\nvub300->fn[Function].offload_point += delta;\r\nvub300->fn[Function].offload_count -= delta;\r\nvub300->total_offload_count -= delta;\r\nreturn 1;\r\n} else {\r\nregister_point += 1;\r\nregister_count -= 1;\r\ndelta += 1;\r\ncontinue;\r\n}\r\n}\r\nreturn 0;\r\n}\r\n}\r\nstatic int satisfy_request_from_offloaded_data(struct vub300_mmc_host *vub300,\r\nstruct mmc_command *cmd)\r\n{\r\nu8 regs = vub300->dynamic_register_count;\r\nu8 i = 0;\r\nu8 func = FUN(cmd);\r\nu32 reg = REG(cmd);\r\nwhile (0 < regs--) {\r\nif ((vub300->sdio_register[i].func_num == func) &&\r\n(vub300->sdio_register[i].sdio_reg == reg)) {\r\nif (!vub300->sdio_register[i].prepared) {\r\nreturn 0;\r\n} else if ((0x80000000 & cmd->arg) == 0x80000000) {\r\nvub300->sdio_register[i].prepared = 0;\r\nreturn 0;\r\n} else {\r\nu8 checksum = 0x00;\r\nu8 rsp0 = 0x00;\r\nu8 rsp1 = 0x00;\r\nu8 rsp2 = vub300->sdio_register[i].response;\r\nu8 rsp3 = vub300->sdio_register[i].regvalue;\r\nvub300->sdio_register[i].prepared = 0;\r\ncmd->resp[1] = checksum << 24;\r\ncmd->resp[0] = (rsp0 << 24)\r\n| (rsp1 << 16)\r\n| (rsp2 << 8)\r\n| (rsp3 << 0);\r\nreturn 1;\r\n}\r\n} else {\r\ni += 1;\r\ncontinue;\r\n}\r\n};\r\nif (vub300->total_offload_count == 0)\r\nreturn 0;\r\nelse if (vub300->fn[func].offload_count == 0)\r\nreturn 0;\r\nelse\r\nreturn examine_cyclic_buffer(vub300, cmd, func);\r\n}\r\nstatic void vub300_mmc_request(struct mmc_host *mmc, struct mmc_request *req)\r\n{\r\nstruct mmc_command *cmd = req->cmd;\r\nstruct vub300_mmc_host *vub300 = mmc_priv(mmc);\r\nif (!vub300->interface) {\r\ncmd->error = -ESHUTDOWN;\r\nmmc_request_done(mmc, req);\r\nreturn;\r\n} else {\r\nstruct mmc_data *data = req->data;\r\nif (!vub300->card_powered) {\r\ncmd->error = -ENOMEDIUM;\r\nmmc_request_done(mmc, req);\r\nreturn;\r\n}\r\nif (!vub300->card_present) {\r\ncmd->error = -ENOMEDIUM;\r\nmmc_request_done(mmc, req);\r\nreturn;\r\n}\r\nif (vub300->usb_transport_fail) {\r\ncmd->error = vub300->usb_transport_fail;\r\nmmc_request_done(mmc, req);\r\nreturn;\r\n}\r\nif (!vub300->interface) {\r\ncmd->error = -ENODEV;\r\nmmc_request_done(mmc, req);\r\nreturn;\r\n}\r\nkref_get(&vub300->kref);\r\nmutex_lock(&vub300->cmd_mutex);\r\nmod_timer(&vub300->inactivity_timer, jiffies + HZ);\r\nif (cmd->opcode == 52 &&\r\nsatisfy_request_from_offloaded_data(vub300, cmd)) {\r\ncmd->error = 0;\r\nmutex_unlock(&vub300->cmd_mutex);\r\nkref_put(&vub300->kref, vub300_delete);\r\nmmc_request_done(mmc, req);\r\nreturn;\r\n} else {\r\nvub300->cmd = cmd;\r\nvub300->req = req;\r\nvub300->data = data;\r\nif (data)\r\nvub300->datasize = data->blksz * data->blocks;\r\nelse\r\nvub300->datasize = 0;\r\nvub300_queue_cmnd_work(vub300);\r\nmutex_unlock(&vub300->cmd_mutex);\r\nkref_put(&vub300->kref, vub300_delete);\r\n}\r\n}\r\n}\r\nstatic void __set_clock_speed(struct vub300_mmc_host *vub300, u8 buf[8],\r\nstruct mmc_ios *ios)\r\n{\r\nint buf_array_size = 8;\r\nint retval;\r\nu32 kHzClock;\r\nif (ios->clock >= 48000000)\r\nkHzClock = 48000;\r\nelse if (ios->clock >= 24000000)\r\nkHzClock = 24000;\r\nelse if (ios->clock >= 20000000)\r\nkHzClock = 20000;\r\nelse if (ios->clock >= 15000000)\r\nkHzClock = 15000;\r\nelse if (ios->clock >= 200000)\r\nkHzClock = 200;\r\nelse\r\nkHzClock = 0;\r\n{\r\nint i;\r\nu64 c = kHzClock;\r\nfor (i = 0; i < buf_array_size; i++) {\r\nbuf[i] = c;\r\nc >>= 8;\r\n}\r\n}\r\nretval =\r\nusb_control_msg(vub300->udev, usb_sndctrlpipe(vub300->udev, 0),\r\nSET_CLOCK_SPEED,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0x00, 0x00, buf, buf_array_size, HZ);\r\nif (retval != 8) {\r\ndev_err(&vub300->udev->dev, "SET_CLOCK_SPEED"\r\n" %dkHz failed with retval=%d\n", kHzClock, retval);\r\n} else {\r\ndev_dbg(&vub300->udev->dev, "SET_CLOCK_SPEED"\r\n" %dkHz\n", kHzClock);\r\n}\r\n}\r\nstatic void vub300_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct vub300_mmc_host *vub300 = mmc_priv(mmc);\r\nif (!vub300->interface)\r\nreturn;\r\nkref_get(&vub300->kref);\r\nmutex_lock(&vub300->cmd_mutex);\r\nif ((ios->power_mode == MMC_POWER_OFF) && vub300->card_powered) {\r\nvub300->card_powered = 0;\r\nusb_control_msg(vub300->udev, usb_sndctrlpipe(vub300->udev, 0),\r\nSET_SD_POWER,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0x0000, 0x0000, NULL, 0, HZ);\r\nmsleep(600);\r\n} else if ((ios->power_mode == MMC_POWER_UP) && !vub300->card_powered) {\r\nusb_control_msg(vub300->udev, usb_sndctrlpipe(vub300->udev, 0),\r\nSET_SD_POWER,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0x0001, 0x0000, NULL, 0, HZ);\r\nmsleep(600);\r\nvub300->card_powered = 1;\r\n} else if (ios->power_mode == MMC_POWER_ON) {\r\nu8 *buf = kmalloc(8, GFP_KERNEL);\r\nif (buf) {\r\n__set_clock_speed(vub300, buf, ios);\r\nkfree(buf);\r\n}\r\n} else {\r\n}\r\nmutex_unlock(&vub300->cmd_mutex);\r\nkref_put(&vub300->kref, vub300_delete);\r\n}\r\nstatic int vub300_mmc_get_ro(struct mmc_host *mmc)\r\n{\r\nstruct vub300_mmc_host *vub300 = mmc_priv(mmc);\r\nreturn vub300->read_only;\r\n}\r\nstatic void vub300_enable_sdio_irq(struct mmc_host *mmc, int enable)\r\n{\r\nstruct vub300_mmc_host *vub300 = mmc_priv(mmc);\r\nif (!vub300->interface)\r\nreturn;\r\nkref_get(&vub300->kref);\r\nif (enable) {\r\nmutex_lock(&vub300->irq_mutex);\r\nif (vub300->irqs_queued) {\r\nvub300->irqs_queued -= 1;\r\nmmc_signal_sdio_irq(vub300->mmc);\r\n} else if (vub300->irq_disabled) {\r\nvub300->irq_disabled = 0;\r\nvub300->irq_enabled = 1;\r\nvub300_queue_poll_work(vub300, 0);\r\n} else if (vub300->irq_enabled) {\r\n} else {\r\nvub300->irq_enabled = 1;\r\nvub300_queue_poll_work(vub300, 0);\r\n}\r\nmutex_unlock(&vub300->irq_mutex);\r\n} else {\r\nvub300->irq_enabled = 0;\r\n}\r\nkref_put(&vub300->kref, vub300_delete);\r\n}\r\nstatic void vub300_init_card(struct mmc_host *mmc, struct mmc_card *card)\r\n{\r\nstruct vub300_mmc_host *vub300 = mmc_priv(mmc);\r\ndev_info(&vub300->udev->dev, "NO host QUIRKS for this card\n");\r\n}\r\nstatic int vub300_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct vub300_mmc_host *vub300;\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_device *udev = usb_get_dev(interface_to_usbdev(interface));\r\nint i;\r\nint retval = -ENOMEM;\r\nstruct urb *command_out_urb;\r\nstruct urb *command_res_urb;\r\nstruct mmc_host *mmc;\r\nchar manufacturer[48];\r\nchar product[32];\r\nchar serial_number[32];\r\nusb_string(udev, udev->descriptor.iManufacturer, manufacturer,\r\nsizeof(manufacturer));\r\nusb_string(udev, udev->descriptor.iProduct, product, sizeof(product));\r\nusb_string(udev, udev->descriptor.iSerialNumber, serial_number,\r\nsizeof(serial_number));\r\ndev_info(&udev->dev, "probing VID:PID(%04X:%04X) %s %s %s\n",\r\nudev->descriptor.idVendor, udev->descriptor.idProduct,\r\nmanufacturer, product, serial_number);\r\ncommand_out_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!command_out_urb) {\r\nretval = -ENOMEM;\r\ndev_err(&udev->dev, "not enough memory for command_out_urb\n");\r\ngoto error0;\r\n}\r\ncommand_res_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!command_res_urb) {\r\nretval = -ENOMEM;\r\ndev_err(&udev->dev, "not enough memory for command_res_urb\n");\r\ngoto error1;\r\n}\r\nmmc = mmc_alloc_host(sizeof(struct vub300_mmc_host), &udev->dev);\r\nif (!mmc) {\r\nretval = -ENOMEM;\r\ndev_err(&udev->dev, "not enough memory for the mmc_host\n");\r\ngoto error4;\r\n}\r\nmmc->caps = 0;\r\nif (!force_1_bit_data_xfers)\r\nmmc->caps |= MMC_CAP_4_BIT_DATA;\r\nif (!force_polling_for_irqs)\r\nmmc->caps |= MMC_CAP_SDIO_IRQ;\r\nmmc->caps &= ~MMC_CAP_NEEDS_POLL;\r\nif (limit_speed_to_24_MHz) {\r\nmmc->caps |= MMC_CAP_MMC_HIGHSPEED;\r\nmmc->caps |= MMC_CAP_SD_HIGHSPEED;\r\nmmc->f_max = 24000000;\r\ndev_info(&udev->dev, "limiting SDIO speed to 24_MHz\n");\r\n} else {\r\nmmc->caps |= MMC_CAP_MMC_HIGHSPEED;\r\nmmc->caps |= MMC_CAP_SD_HIGHSPEED;\r\nmmc->f_max = 48000000;\r\n}\r\nmmc->f_min = 200000;\r\nmmc->max_blk_count = 511;\r\nmmc->max_blk_size = 512;\r\nmmc->max_segs = 128;\r\nif (force_max_req_size)\r\nmmc->max_req_size = force_max_req_size * 1024;\r\nelse\r\nmmc->max_req_size = 64 * 1024;\r\nmmc->max_seg_size = mmc->max_req_size;\r\nmmc->ocr_avail = 0;\r\nmmc->ocr_avail |= MMC_VDD_165_195;\r\nmmc->ocr_avail |= MMC_VDD_20_21;\r\nmmc->ocr_avail |= MMC_VDD_21_22;\r\nmmc->ocr_avail |= MMC_VDD_22_23;\r\nmmc->ocr_avail |= MMC_VDD_23_24;\r\nmmc->ocr_avail |= MMC_VDD_24_25;\r\nmmc->ocr_avail |= MMC_VDD_25_26;\r\nmmc->ocr_avail |= MMC_VDD_26_27;\r\nmmc->ocr_avail |= MMC_VDD_27_28;\r\nmmc->ocr_avail |= MMC_VDD_28_29;\r\nmmc->ocr_avail |= MMC_VDD_29_30;\r\nmmc->ocr_avail |= MMC_VDD_30_31;\r\nmmc->ocr_avail |= MMC_VDD_31_32;\r\nmmc->ocr_avail |= MMC_VDD_32_33;\r\nmmc->ocr_avail |= MMC_VDD_33_34;\r\nmmc->ocr_avail |= MMC_VDD_34_35;\r\nmmc->ocr_avail |= MMC_VDD_35_36;\r\nmmc->ops = &vub300_mmc_ops;\r\nvub300 = mmc_priv(mmc);\r\nvub300->mmc = mmc;\r\nvub300->card_powered = 0;\r\nvub300->bus_width = 0;\r\nvub300->cmnd.head.block_size[0] = 0x00;\r\nvub300->cmnd.head.block_size[1] = 0x00;\r\nvub300->app_spec = 0;\r\nmutex_init(&vub300->cmd_mutex);\r\nmutex_init(&vub300->irq_mutex);\r\nvub300->command_out_urb = command_out_urb;\r\nvub300->command_res_urb = command_res_urb;\r\nvub300->usb_timed_out = 0;\r\nvub300->dynamic_register_count = 0;\r\nfor (i = 0; i < ARRAY_SIZE(vub300->fn); i++) {\r\nvub300->fn[i].offload_point = 0;\r\nvub300->fn[i].offload_count = 0;\r\n}\r\nvub300->total_offload_count = 0;\r\nvub300->irq_enabled = 0;\r\nvub300->irq_disabled = 0;\r\nvub300->irqs_queued = 0;\r\nfor (i = 0; i < ARRAY_SIZE(vub300->sdio_register); i++)\r\nvub300->sdio_register[i++].activate = 0;\r\nvub300->udev = udev;\r\nvub300->interface = interface;\r\nvub300->cmnd_res_ep = 0;\r\nvub300->cmnd_out_ep = 0;\r\nvub300->data_inp_ep = 0;\r\nvub300->data_out_ep = 0;\r\nfor (i = 0; i < ARRAY_SIZE(vub300->fbs); i++)\r\nvub300->fbs[i] = 512;\r\nvub300->large_usb_packets = 0;\r\niface_desc = interface->cur_altsetting;\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\r\nstruct usb_endpoint_descriptor *endpoint =\r\n&iface_desc->endpoint[i].desc;\r\ndev_info(&vub300->udev->dev,\r\n"vub300 testing %s EndPoint(%d) %02X\n",\r\nusb_endpoint_is_bulk_in(endpoint) ? "BULK IN" :\r\nusb_endpoint_is_bulk_out(endpoint) ? "BULK OUT" :\r\n"UNKNOWN", i, endpoint->bEndpointAddress);\r\nif (endpoint->wMaxPacketSize > 64)\r\nvub300->large_usb_packets = 1;\r\nif (usb_endpoint_is_bulk_in(endpoint)) {\r\nif (!vub300->cmnd_res_ep) {\r\nvub300->cmnd_res_ep =\r\nendpoint->bEndpointAddress;\r\n} else if (!vub300->data_inp_ep) {\r\nvub300->data_inp_ep =\r\nendpoint->bEndpointAddress;\r\n} else {\r\ndev_warn(&vub300->udev->dev,\r\n"ignoring"\r\n" unexpected bulk_in endpoint");\r\n}\r\n} else if (usb_endpoint_is_bulk_out(endpoint)) {\r\nif (!vub300->cmnd_out_ep) {\r\nvub300->cmnd_out_ep =\r\nendpoint->bEndpointAddress;\r\n} else if (!vub300->data_out_ep) {\r\nvub300->data_out_ep =\r\nendpoint->bEndpointAddress;\r\n} else {\r\ndev_warn(&vub300->udev->dev,\r\n"ignoring"\r\n" unexpected bulk_out endpoint");\r\n}\r\n} else {\r\ndev_warn(&vub300->udev->dev,\r\n"vub300 ignoring EndPoint(%d) %02X", i,\r\nendpoint->bEndpointAddress);\r\n}\r\n}\r\nif (vub300->cmnd_res_ep && vub300->cmnd_out_ep &&\r\nvub300->data_inp_ep && vub300->data_out_ep) {\r\ndev_info(&vub300->udev->dev,\r\n"vub300 %s packets"\r\n" using EndPoints %02X %02X %02X %02X\n",\r\nvub300->large_usb_packets ? "LARGE" : "SMALL",\r\nvub300->cmnd_out_ep, vub300->cmnd_res_ep,\r\nvub300->data_out_ep, vub300->data_inp_ep);\r\n} else {\r\ndev_err(&vub300->udev->dev,\r\n"Could not find two sets of bulk-in/out endpoint pairs\n");\r\nretval = -EINVAL;\r\ngoto error5;\r\n}\r\nretval =\r\nusb_control_msg(vub300->udev, usb_rcvctrlpipe(vub300->udev, 0),\r\nGET_HC_INF0,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0x0000, 0x0000, &vub300->hc_info,\r\nsizeof(vub300->hc_info), HZ);\r\nif (retval < 0)\r\ngoto error5;\r\nretval =\r\nusb_control_msg(vub300->udev, usb_rcvctrlpipe(vub300->udev, 0),\r\nSET_ROM_WAIT_STATES,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nfirmware_rom_wait_states, 0x0000, NULL, 0, HZ);\r\nif (retval < 0)\r\ngoto error5;\r\ndev_info(&vub300->udev->dev,\r\n"operating_mode = %s %s %d MHz %s %d byte USB packets\n",\r\n(mmc->caps & MMC_CAP_SDIO_IRQ) ? "IRQs" : "POLL",\r\n(mmc->caps & MMC_CAP_4_BIT_DATA) ? "4-bit" : "1-bit",\r\nmmc->f_max / 1000000,\r\npad_input_to_usb_pkt ? "padding input data to" : "with",\r\nvub300->large_usb_packets ? 512 : 64);\r\nretval =\r\nusb_control_msg(vub300->udev, usb_rcvctrlpipe(vub300->udev, 0),\r\nGET_SYSTEM_PORT_STATUS,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0x0000, 0x0000, &vub300->system_port_status,\r\nsizeof(vub300->system_port_status), HZ);\r\nif (retval < 0) {\r\ngoto error4;\r\n} else if (sizeof(vub300->system_port_status) == retval) {\r\nvub300->card_present =\r\n(0x0001 & vub300->system_port_status.port_flags) ? 1 : 0;\r\nvub300->read_only =\r\n(0x0010 & vub300->system_port_status.port_flags) ? 1 : 0;\r\n} else {\r\ngoto error4;\r\n}\r\nusb_set_intfdata(interface, vub300);\r\nINIT_DELAYED_WORK(&vub300->pollwork, vub300_pollwork_thread);\r\nINIT_WORK(&vub300->cmndwork, vub300_cmndwork_thread);\r\nINIT_WORK(&vub300->deadwork, vub300_deadwork_thread);\r\nkref_init(&vub300->kref);\r\ninit_timer(&vub300->sg_transfer_timer);\r\nvub300->sg_transfer_timer.data = (unsigned long)vub300;\r\nvub300->sg_transfer_timer.function = vub300_sg_timed_out;\r\nkref_get(&vub300->kref);\r\ninit_timer(&vub300->inactivity_timer);\r\nvub300->inactivity_timer.data = (unsigned long)vub300;\r\nvub300->inactivity_timer.function = vub300_inactivity_timer_expired;\r\nvub300->inactivity_timer.expires = jiffies + HZ;\r\nadd_timer(&vub300->inactivity_timer);\r\nif (vub300->card_present)\r\ndev_info(&vub300->udev->dev,\r\n"USB vub300 remote SDIO host controller[%d]"\r\n"connected with SD/SDIO card inserted\n",\r\ninterface_to_InterfaceNumber(interface));\r\nelse\r\ndev_info(&vub300->udev->dev,\r\n"USB vub300 remote SDIO host controller[%d]"\r\n"connected with no SD/SDIO card inserted\n",\r\ninterface_to_InterfaceNumber(interface));\r\nmmc_add_host(mmc);\r\nreturn 0;\r\nerror5:\r\nmmc_free_host(mmc);\r\nerror4:\r\nusb_free_urb(command_res_urb);\r\nerror1:\r\nusb_free_urb(command_out_urb);\r\nerror0:\r\nusb_put_dev(udev);\r\nreturn retval;\r\n}\r\nstatic void vub300_disconnect(struct usb_interface *interface)\r\n{\r\nstruct vub300_mmc_host *vub300 = usb_get_intfdata(interface);\r\nif (!vub300 || !vub300->mmc) {\r\nreturn;\r\n} else {\r\nstruct mmc_host *mmc = vub300->mmc;\r\nif (!vub300->mmc) {\r\nreturn;\r\n} else {\r\nint ifnum = interface_to_InterfaceNumber(interface);\r\nusb_set_intfdata(interface, NULL);\r\nvub300->interface = NULL;\r\nkref_put(&vub300->kref, vub300_delete);\r\nmmc_remove_host(mmc);\r\npr_info("USB vub300 remote SDIO host controller[%d]"\r\n" now disconnected", ifnum);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic int vub300_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nreturn 0;\r\n}\r\nstatic int vub300_resume(struct usb_interface *intf)\r\n{\r\nreturn 0;\r\n}\r\nstatic int vub300_pre_reset(struct usb_interface *intf)\r\n{\r\nstruct vub300_mmc_host *vub300 = usb_get_intfdata(intf);\r\nmutex_lock(&vub300->cmd_mutex);\r\nreturn 0;\r\n}\r\nstatic int vub300_post_reset(struct usb_interface *intf)\r\n{\r\nstruct vub300_mmc_host *vub300 = usb_get_intfdata(intf);\r\nvub300->errors = -EPIPE;\r\nmutex_unlock(&vub300->cmd_mutex);\r\nreturn 0;\r\n}\r\nstatic int __init vub300_init(void)\r\n{\r\nint result;\r\npr_info("VUB300 Driver rom wait states = %02X irqpoll timeout = %04X",\r\nfirmware_rom_wait_states, 0x0FFFF & firmware_irqpoll_timeout);\r\ncmndworkqueue = create_singlethread_workqueue("kvub300c");\r\nif (!cmndworkqueue) {\r\npr_err("not enough memory for the REQUEST workqueue");\r\nresult = -ENOMEM;\r\ngoto out1;\r\n}\r\npollworkqueue = create_singlethread_workqueue("kvub300p");\r\nif (!pollworkqueue) {\r\npr_err("not enough memory for the IRQPOLL workqueue");\r\nresult = -ENOMEM;\r\ngoto out2;\r\n}\r\ndeadworkqueue = create_singlethread_workqueue("kvub300d");\r\nif (!deadworkqueue) {\r\npr_err("not enough memory for the EXPIRED workqueue");\r\nresult = -ENOMEM;\r\ngoto out3;\r\n}\r\nresult = usb_register(&vub300_driver);\r\nif (result) {\r\npr_err("usb_register failed. Error number %d", result);\r\ngoto out4;\r\n}\r\nreturn 0;\r\nout4:\r\ndestroy_workqueue(deadworkqueue);\r\nout3:\r\ndestroy_workqueue(pollworkqueue);\r\nout2:\r\ndestroy_workqueue(cmndworkqueue);\r\nout1:\r\nreturn result;\r\n}\r\nstatic void __exit vub300_exit(void)\r\n{\r\nusb_deregister(&vub300_driver);\r\nflush_workqueue(cmndworkqueue);\r\nflush_workqueue(pollworkqueue);\r\nflush_workqueue(deadworkqueue);\r\ndestroy_workqueue(cmndworkqueue);\r\ndestroy_workqueue(pollworkqueue);\r\ndestroy_workqueue(deadworkqueue);\r\n}
