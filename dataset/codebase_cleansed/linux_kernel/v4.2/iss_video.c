const struct iss_format_info *\r\nomap4iss_video_format_info(u32 code)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(formats); ++i) {\r\nif (formats[i].code == code)\r\nreturn &formats[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic unsigned int iss_video_mbus_to_pix(const struct iss_video *video,\r\nconst struct v4l2_mbus_framefmt *mbus,\r\nstruct v4l2_pix_format *pix)\r\n{\r\nunsigned int bpl = pix->bytesperline;\r\nunsigned int min_bpl;\r\nunsigned int i;\r\nmemset(pix, 0, sizeof(*pix));\r\npix->width = mbus->width;\r\npix->height = mbus->height;\r\nfor (i = 0; i < ARRAY_SIZE(formats) - 1; ++i) {\r\nif (formats[i].code == mbus->code)\r\nbreak;\r\n}\r\nmin_bpl = pix->width * ALIGN(formats[i].bpp, 8) / 8;\r\nif (video->bpl_max)\r\nbpl = clamp(bpl, min_bpl, video->bpl_max);\r\nelse\r\nbpl = min_bpl;\r\nif (!video->bpl_zero_padding || bpl != min_bpl)\r\nbpl = ALIGN(bpl, video->bpl_alignment);\r\npix->pixelformat = formats[i].pixelformat;\r\npix->bytesperline = bpl;\r\npix->sizeimage = pix->bytesperline * pix->height;\r\npix->colorspace = mbus->colorspace;\r\npix->field = mbus->field;\r\nif (pix->pixelformat == V4L2_PIX_FMT_NV12)\r\npix->sizeimage += (pix->bytesperline * pix->height) / 2;\r\nreturn bpl - min_bpl;\r\n}\r\nstatic void iss_video_pix_to_mbus(const struct v4l2_pix_format *pix,\r\nstruct v4l2_mbus_framefmt *mbus)\r\n{\r\nunsigned int i;\r\nmemset(mbus, 0, sizeof(*mbus));\r\nmbus->width = pix->width;\r\nmbus->height = pix->height;\r\nfor (i = 0; i < ARRAY_SIZE(formats) - 1; ++i) {\r\nif (formats[i].pixelformat == pix->pixelformat)\r\nbreak;\r\n}\r\nmbus->code = formats[i].code;\r\nmbus->colorspace = pix->colorspace;\r\nmbus->field = pix->field;\r\n}\r\nstatic struct v4l2_subdev *\r\niss_video_remote_subdev(struct iss_video *video, u32 *pad)\r\n{\r\nstruct media_pad *remote;\r\nremote = media_entity_remote_pad(&video->pad);\r\nif (remote == NULL ||\r\nmedia_entity_type(remote->entity) != MEDIA_ENT_T_V4L2_SUBDEV)\r\nreturn NULL;\r\nif (pad)\r\n*pad = remote->index;\r\nreturn media_entity_to_v4l2_subdev(remote->entity);\r\n}\r\nstatic struct iss_video *\r\niss_video_far_end(struct iss_video *video)\r\n{\r\nstruct media_entity_graph graph;\r\nstruct media_entity *entity = &video->video.entity;\r\nstruct media_device *mdev = entity->parent;\r\nstruct iss_video *far_end = NULL;\r\nmutex_lock(&mdev->graph_mutex);\r\nmedia_entity_graph_walk_start(&graph, entity);\r\nwhile ((entity = media_entity_graph_walk_next(&graph))) {\r\nif (entity == &video->video.entity)\r\ncontinue;\r\nif (media_entity_type(entity) != MEDIA_ENT_T_DEVNODE)\r\ncontinue;\r\nfar_end = to_iss_video(media_entity_to_video_device(entity));\r\nif (far_end->type != video->type)\r\nbreak;\r\nfar_end = NULL;\r\n}\r\nmutex_unlock(&mdev->graph_mutex);\r\nreturn far_end;\r\n}\r\nstatic int\r\n__iss_video_get_format(struct iss_video *video,\r\nstruct v4l2_mbus_framefmt *format)\r\n{\r\nstruct v4l2_subdev_format fmt;\r\nstruct v4l2_subdev *subdev;\r\nu32 pad;\r\nint ret;\r\nsubdev = iss_video_remote_subdev(video, &pad);\r\nif (subdev == NULL)\r\nreturn -EINVAL;\r\nmemset(&fmt, 0, sizeof(fmt));\r\nfmt.pad = pad;\r\nfmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nmutex_lock(&video->mutex);\r\nret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &fmt);\r\nmutex_unlock(&video->mutex);\r\nif (ret)\r\nreturn ret;\r\n*format = fmt.format;\r\nreturn 0;\r\n}\r\nstatic int\r\niss_video_check_format(struct iss_video *video, struct iss_video_fh *vfh)\r\n{\r\nstruct v4l2_mbus_framefmt format;\r\nstruct v4l2_pix_format pixfmt;\r\nint ret;\r\nret = __iss_video_get_format(video, &format);\r\nif (ret < 0)\r\nreturn ret;\r\npixfmt.bytesperline = 0;\r\nret = iss_video_mbus_to_pix(video, &format, &pixfmt);\r\nif (vfh->format.fmt.pix.pixelformat != pixfmt.pixelformat ||\r\nvfh->format.fmt.pix.height != pixfmt.height ||\r\nvfh->format.fmt.pix.width != pixfmt.width ||\r\nvfh->format.fmt.pix.bytesperline != pixfmt.bytesperline ||\r\nvfh->format.fmt.pix.sizeimage != pixfmt.sizeimage)\r\nreturn -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int iss_video_queue_setup(struct vb2_queue *vq,\r\nconst struct v4l2_format *fmt,\r\nunsigned int *count, unsigned int *num_planes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct iss_video_fh *vfh = vb2_get_drv_priv(vq);\r\nstruct iss_video *video = vfh->video;\r\n*num_planes = 1;\r\nsizes[0] = vfh->format.fmt.pix.sizeimage;\r\nif (sizes[0] == 0)\r\nreturn -EINVAL;\r\nalloc_ctxs[0] = video->alloc_ctx;\r\n*count = min(*count, video->capture_mem / PAGE_ALIGN(sizes[0]));\r\nreturn 0;\r\n}\r\nstatic void iss_video_buf_cleanup(struct vb2_buffer *vb)\r\n{\r\nstruct iss_buffer *buffer = container_of(vb, struct iss_buffer, vb);\r\nif (buffer->iss_addr)\r\nbuffer->iss_addr = 0;\r\n}\r\nstatic int iss_video_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct iss_video_fh *vfh = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct iss_buffer *buffer = container_of(vb, struct iss_buffer, vb);\r\nstruct iss_video *video = vfh->video;\r\nunsigned long size = vfh->format.fmt.pix.sizeimage;\r\ndma_addr_t addr;\r\nif (vb2_plane_size(vb, 0) < size)\r\nreturn -ENOBUFS;\r\naddr = vb2_dma_contig_plane_dma_addr(vb, 0);\r\nif (!IS_ALIGNED(addr, 32)) {\r\ndev_dbg(video->iss->dev,\r\n"Buffer address must be aligned to 32 bytes boundary.\n");\r\nreturn -EINVAL;\r\n}\r\nvb2_set_plane_payload(vb, 0, size);\r\nbuffer->iss_addr = addr;\r\nreturn 0;\r\n}\r\nstatic void iss_video_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct iss_video_fh *vfh = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct iss_video *video = vfh->video;\r\nstruct iss_buffer *buffer = container_of(vb, struct iss_buffer, vb);\r\nstruct iss_pipeline *pipe = to_iss_pipeline(&video->video.entity);\r\nunsigned long flags;\r\nbool empty;\r\nspin_lock_irqsave(&video->qlock, flags);\r\nif (unlikely(video->error)) {\r\nvb2_buffer_done(vb, VB2_BUF_STATE_ERROR);\r\nspin_unlock_irqrestore(&video->qlock, flags);\r\nreturn;\r\n}\r\nempty = list_empty(&video->dmaqueue);\r\nlist_add_tail(&buffer->list, &video->dmaqueue);\r\nspin_unlock_irqrestore(&video->qlock, flags);\r\nif (empty) {\r\nenum iss_pipeline_state state;\r\nunsigned int start;\r\nif (video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nstate = ISS_PIPELINE_QUEUE_OUTPUT;\r\nelse\r\nstate = ISS_PIPELINE_QUEUE_INPUT;\r\nspin_lock_irqsave(&pipe->lock, flags);\r\npipe->state |= state;\r\nvideo->ops->queue(video, buffer);\r\nvideo->dmaqueue_flags |= ISS_VIDEO_DMAQUEUE_QUEUED;\r\nstart = iss_pipeline_ready(pipe);\r\nif (start)\r\npipe->state |= ISS_PIPELINE_STREAM;\r\nspin_unlock_irqrestore(&pipe->lock, flags);\r\nif (start)\r\nomap4iss_pipeline_set_stream(pipe,\r\nISS_PIPELINE_STREAM_SINGLESHOT);\r\n}\r\n}\r\nstruct iss_buffer *omap4iss_video_buffer_next(struct iss_video *video)\r\n{\r\nstruct iss_pipeline *pipe = to_iss_pipeline(&video->video.entity);\r\nenum iss_pipeline_state state;\r\nstruct iss_buffer *buf;\r\nunsigned long flags;\r\nstruct timespec ts;\r\nspin_lock_irqsave(&video->qlock, flags);\r\nif (WARN_ON(list_empty(&video->dmaqueue))) {\r\nspin_unlock_irqrestore(&video->qlock, flags);\r\nreturn NULL;\r\n}\r\nbuf = list_first_entry(&video->dmaqueue, struct iss_buffer,\r\nlist);\r\nlist_del(&buf->list);\r\nspin_unlock_irqrestore(&video->qlock, flags);\r\nktime_get_ts(&ts);\r\nbuf->vb.v4l2_buf.timestamp.tv_sec = ts.tv_sec;\r\nbuf->vb.v4l2_buf.timestamp.tv_usec = ts.tv_nsec / NSEC_PER_USEC;\r\nif (video == pipe->output && !pipe->do_propagation)\r\nbuf->vb.v4l2_buf.sequence =\r\natomic_inc_return(&pipe->frame_number);\r\nelse\r\nbuf->vb.v4l2_buf.sequence = atomic_read(&pipe->frame_number);\r\nvb2_buffer_done(&buf->vb, pipe->error ?\r\nVB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);\r\npipe->error = false;\r\nspin_lock_irqsave(&video->qlock, flags);\r\nif (list_empty(&video->dmaqueue)) {\r\nspin_unlock_irqrestore(&video->qlock, flags);\r\nif (video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nstate = ISS_PIPELINE_QUEUE_OUTPUT\r\n| ISS_PIPELINE_STREAM;\r\nelse\r\nstate = ISS_PIPELINE_QUEUE_INPUT\r\n| ISS_PIPELINE_STREAM;\r\nspin_lock_irqsave(&pipe->lock, flags);\r\npipe->state &= ~state;\r\nif (video->pipe.stream_state == ISS_PIPELINE_STREAM_CONTINUOUS)\r\nvideo->dmaqueue_flags |= ISS_VIDEO_DMAQUEUE_UNDERRUN;\r\nspin_unlock_irqrestore(&pipe->lock, flags);\r\nreturn NULL;\r\n}\r\nif (video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE && pipe->input != NULL) {\r\nspin_lock(&pipe->lock);\r\npipe->state &= ~ISS_PIPELINE_STREAM;\r\nspin_unlock(&pipe->lock);\r\n}\r\nbuf = list_first_entry(&video->dmaqueue, struct iss_buffer,\r\nlist);\r\nspin_unlock_irqrestore(&video->qlock, flags);\r\nbuf->vb.state = VB2_BUF_STATE_ACTIVE;\r\nreturn buf;\r\n}\r\nvoid omap4iss_video_cancel_stream(struct iss_video *video)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&video->qlock, flags);\r\nwhile (!list_empty(&video->dmaqueue)) {\r\nstruct iss_buffer *buf;\r\nbuf = list_first_entry(&video->dmaqueue, struct iss_buffer,\r\nlist);\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);\r\n}\r\nvb2_queue_error(video->queue);\r\nvideo->error = true;\r\nspin_unlock_irqrestore(&video->qlock, flags);\r\n}\r\nstatic int\r\niss_video_querycap(struct file *file, void *fh, struct v4l2_capability *cap)\r\n{\r\nstruct iss_video *video = video_drvdata(file);\r\nstrlcpy(cap->driver, ISS_VIDEO_DRIVER_NAME, sizeof(cap->driver));\r\nstrlcpy(cap->card, video->video.name, sizeof(cap->card));\r\nstrlcpy(cap->bus_info, "media", sizeof(cap->bus_info));\r\nif (video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;\r\nelse\r\ncap->device_caps = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_STREAMING;\r\ncap->capabilities = V4L2_CAP_DEVICE_CAPS | V4L2_CAP_STREAMING\r\n| V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT;\r\nreturn 0;\r\n}\r\nstatic int\r\niss_video_enum_format(struct file *file, void *fh, struct v4l2_fmtdesc *f)\r\n{\r\nstruct iss_video *video = video_drvdata(file);\r\nstruct v4l2_mbus_framefmt format;\r\nunsigned int index = f->index;\r\nunsigned int i;\r\nint ret;\r\nif (f->type != video->type)\r\nreturn -EINVAL;\r\nret = __iss_video_get_format(video, &format);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < ARRAY_SIZE(formats); ++i) {\r\nconst struct iss_format_info *info = &formats[i];\r\nif (format.code != info->code)\r\ncontinue;\r\nif (index == 0) {\r\nf->pixelformat = info->pixelformat;\r\nstrlcpy(f->description, info->description,\r\nsizeof(f->description));\r\nreturn 0;\r\n}\r\nindex--;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\niss_video_get_format(struct file *file, void *fh, struct v4l2_format *format)\r\n{\r\nstruct iss_video_fh *vfh = to_iss_video_fh(fh);\r\nstruct iss_video *video = video_drvdata(file);\r\nif (format->type != video->type)\r\nreturn -EINVAL;\r\nmutex_lock(&video->mutex);\r\n*format = vfh->format;\r\nmutex_unlock(&video->mutex);\r\nreturn 0;\r\n}\r\nstatic int\r\niss_video_set_format(struct file *file, void *fh, struct v4l2_format *format)\r\n{\r\nstruct iss_video_fh *vfh = to_iss_video_fh(fh);\r\nstruct iss_video *video = video_drvdata(file);\r\nstruct v4l2_mbus_framefmt fmt;\r\nif (format->type != video->type)\r\nreturn -EINVAL;\r\nmutex_lock(&video->mutex);\r\niss_video_pix_to_mbus(&format->fmt.pix, &fmt);\r\niss_video_mbus_to_pix(video, &fmt, &format->fmt.pix);\r\nvfh->format = *format;\r\nmutex_unlock(&video->mutex);\r\nreturn 0;\r\n}\r\nstatic int\r\niss_video_try_format(struct file *file, void *fh, struct v4l2_format *format)\r\n{\r\nstruct iss_video *video = video_drvdata(file);\r\nstruct v4l2_subdev_format fmt;\r\nstruct v4l2_subdev *subdev;\r\nu32 pad;\r\nint ret;\r\nif (format->type != video->type)\r\nreturn -EINVAL;\r\nsubdev = iss_video_remote_subdev(video, &pad);\r\nif (subdev == NULL)\r\nreturn -EINVAL;\r\niss_video_pix_to_mbus(&format->fmt.pix, &fmt.format);\r\nfmt.pad = pad;\r\nfmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &fmt);\r\nif (ret)\r\nreturn ret;\r\niss_video_mbus_to_pix(video, &fmt.format, &format->fmt.pix);\r\nreturn 0;\r\n}\r\nstatic int\r\niss_video_cropcap(struct file *file, void *fh, struct v4l2_cropcap *cropcap)\r\n{\r\nstruct iss_video *video = video_drvdata(file);\r\nstruct v4l2_subdev *subdev;\r\nint ret;\r\nsubdev = iss_video_remote_subdev(video, NULL);\r\nif (subdev == NULL)\r\nreturn -EINVAL;\r\nmutex_lock(&video->mutex);\r\nret = v4l2_subdev_call(subdev, video, cropcap, cropcap);\r\nmutex_unlock(&video->mutex);\r\nreturn ret == -ENOIOCTLCMD ? -ENOTTY : ret;\r\n}\r\nstatic int\r\niss_video_get_crop(struct file *file, void *fh, struct v4l2_crop *crop)\r\n{\r\nstruct iss_video *video = video_drvdata(file);\r\nstruct v4l2_subdev_format format;\r\nstruct v4l2_subdev *subdev;\r\nu32 pad;\r\nint ret;\r\nsubdev = iss_video_remote_subdev(video, &pad);\r\nif (subdev == NULL)\r\nreturn -EINVAL;\r\nret = v4l2_subdev_call(subdev, video, g_crop, crop);\r\nif (ret != -ENOIOCTLCMD)\r\nreturn ret;\r\nformat.pad = pad;\r\nformat.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &format);\r\nif (ret < 0)\r\nreturn ret == -ENOIOCTLCMD ? -ENOTTY : ret;\r\ncrop->c.left = 0;\r\ncrop->c.top = 0;\r\ncrop->c.width = format.format.width;\r\ncrop->c.height = format.format.height;\r\nreturn 0;\r\n}\r\nstatic int\r\niss_video_set_crop(struct file *file, void *fh, const struct v4l2_crop *crop)\r\n{\r\nstruct iss_video *video = video_drvdata(file);\r\nstruct v4l2_subdev *subdev;\r\nint ret;\r\nsubdev = iss_video_remote_subdev(video, NULL);\r\nif (subdev == NULL)\r\nreturn -EINVAL;\r\nmutex_lock(&video->mutex);\r\nret = v4l2_subdev_call(subdev, video, s_crop, crop);\r\nmutex_unlock(&video->mutex);\r\nreturn ret == -ENOIOCTLCMD ? -ENOTTY : ret;\r\n}\r\nstatic int\r\niss_video_get_param(struct file *file, void *fh, struct v4l2_streamparm *a)\r\n{\r\nstruct iss_video_fh *vfh = to_iss_video_fh(fh);\r\nstruct iss_video *video = video_drvdata(file);\r\nif (video->type != V4L2_BUF_TYPE_VIDEO_OUTPUT ||\r\nvideo->type != a->type)\r\nreturn -EINVAL;\r\nmemset(a, 0, sizeof(*a));\r\na->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\na->parm.output.capability = V4L2_CAP_TIMEPERFRAME;\r\na->parm.output.timeperframe = vfh->timeperframe;\r\nreturn 0;\r\n}\r\nstatic int\r\niss_video_set_param(struct file *file, void *fh, struct v4l2_streamparm *a)\r\n{\r\nstruct iss_video_fh *vfh = to_iss_video_fh(fh);\r\nstruct iss_video *video = video_drvdata(file);\r\nif (video->type != V4L2_BUF_TYPE_VIDEO_OUTPUT ||\r\nvideo->type != a->type)\r\nreturn -EINVAL;\r\nif (a->parm.output.timeperframe.denominator == 0)\r\na->parm.output.timeperframe.denominator = 1;\r\nvfh->timeperframe = a->parm.output.timeperframe;\r\nreturn 0;\r\n}\r\nstatic int\r\niss_video_reqbufs(struct file *file, void *fh, struct v4l2_requestbuffers *rb)\r\n{\r\nstruct iss_video_fh *vfh = to_iss_video_fh(fh);\r\nreturn vb2_reqbufs(&vfh->queue, rb);\r\n}\r\nstatic int\r\niss_video_querybuf(struct file *file, void *fh, struct v4l2_buffer *b)\r\n{\r\nstruct iss_video_fh *vfh = to_iss_video_fh(fh);\r\nreturn vb2_querybuf(&vfh->queue, b);\r\n}\r\nstatic int\r\niss_video_qbuf(struct file *file, void *fh, struct v4l2_buffer *b)\r\n{\r\nstruct iss_video_fh *vfh = to_iss_video_fh(fh);\r\nreturn vb2_qbuf(&vfh->queue, b);\r\n}\r\nstatic int\r\niss_video_expbuf(struct file *file, void *fh, struct v4l2_exportbuffer *e)\r\n{\r\nstruct iss_video_fh *vfh = to_iss_video_fh(fh);\r\nreturn vb2_expbuf(&vfh->queue, e);\r\n}\r\nstatic int\r\niss_video_dqbuf(struct file *file, void *fh, struct v4l2_buffer *b)\r\n{\r\nstruct iss_video_fh *vfh = to_iss_video_fh(fh);\r\nreturn vb2_dqbuf(&vfh->queue, b, file->f_flags & O_NONBLOCK);\r\n}\r\nstatic int\r\niss_video_streamon(struct file *file, void *fh, enum v4l2_buf_type type)\r\n{\r\nstruct iss_video_fh *vfh = to_iss_video_fh(fh);\r\nstruct iss_video *video = video_drvdata(file);\r\nstruct media_entity_graph graph;\r\nstruct media_entity *entity;\r\nenum iss_pipeline_state state;\r\nstruct iss_pipeline *pipe;\r\nstruct iss_video *far_end;\r\nunsigned long flags;\r\nint ret;\r\nif (type != video->type)\r\nreturn -EINVAL;\r\nmutex_lock(&video->stream_lock);\r\npipe = video->video.entity.pipe\r\n? to_iss_pipeline(&video->video.entity) : &video->pipe;\r\npipe->external = NULL;\r\npipe->external_rate = 0;\r\npipe->external_bpp = 0;\r\npipe->entities = 0;\r\nif (video->iss->pdata->set_constraints)\r\nvideo->iss->pdata->set_constraints(video->iss, true);\r\nret = media_entity_pipeline_start(&video->video.entity, &pipe->pipe);\r\nif (ret < 0)\r\ngoto err_media_entity_pipeline_start;\r\nentity = &video->video.entity;\r\nmedia_entity_graph_walk_start(&graph, entity);\r\nwhile ((entity = media_entity_graph_walk_next(&graph)))\r\npipe->entities |= 1 << entity->id;\r\nret = iss_video_check_format(video, vfh);\r\nif (ret < 0)\r\ngoto err_iss_video_check_format;\r\nvideo->bpl_padding = ret;\r\nvideo->bpl_value = vfh->format.fmt.pix.bytesperline;\r\nfar_end = iss_video_far_end(video);\r\nif (video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nstate = ISS_PIPELINE_STREAM_OUTPUT | ISS_PIPELINE_IDLE_OUTPUT;\r\npipe->input = far_end;\r\npipe->output = video;\r\n} else {\r\nif (far_end == NULL) {\r\nret = -EPIPE;\r\ngoto err_iss_video_check_format;\r\n}\r\nstate = ISS_PIPELINE_STREAM_INPUT | ISS_PIPELINE_IDLE_INPUT;\r\npipe->input = video;\r\npipe->output = far_end;\r\n}\r\nspin_lock_irqsave(&pipe->lock, flags);\r\npipe->state &= ~ISS_PIPELINE_STREAM;\r\npipe->state |= state;\r\nspin_unlock_irqrestore(&pipe->lock, flags);\r\nif (video->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\npipe->max_timeperframe = vfh->timeperframe;\r\nvideo->queue = &vfh->queue;\r\nINIT_LIST_HEAD(&video->dmaqueue);\r\nvideo->error = false;\r\natomic_set(&pipe->frame_number, -1);\r\nret = vb2_streamon(&vfh->queue, type);\r\nif (ret < 0)\r\ngoto err_iss_video_check_format;\r\nif (pipe->input == NULL) {\r\nunsigned long flags;\r\nret = omap4iss_pipeline_set_stream(pipe,\r\nISS_PIPELINE_STREAM_CONTINUOUS);\r\nif (ret < 0)\r\ngoto err_omap4iss_set_stream;\r\nspin_lock_irqsave(&video->qlock, flags);\r\nif (list_empty(&video->dmaqueue))\r\nvideo->dmaqueue_flags |= ISS_VIDEO_DMAQUEUE_UNDERRUN;\r\nspin_unlock_irqrestore(&video->qlock, flags);\r\n}\r\nmutex_unlock(&video->stream_lock);\r\nreturn 0;\r\nerr_omap4iss_set_stream:\r\nvb2_streamoff(&vfh->queue, type);\r\nerr_iss_video_check_format:\r\nmedia_entity_pipeline_stop(&video->video.entity);\r\nerr_media_entity_pipeline_start:\r\nif (video->iss->pdata->set_constraints)\r\nvideo->iss->pdata->set_constraints(video->iss, false);\r\nvideo->queue = NULL;\r\nmutex_unlock(&video->stream_lock);\r\nreturn ret;\r\n}\r\nstatic int\r\niss_video_streamoff(struct file *file, void *fh, enum v4l2_buf_type type)\r\n{\r\nstruct iss_video_fh *vfh = to_iss_video_fh(fh);\r\nstruct iss_video *video = video_drvdata(file);\r\nstruct iss_pipeline *pipe = to_iss_pipeline(&video->video.entity);\r\nenum iss_pipeline_state state;\r\nunsigned long flags;\r\nif (type != video->type)\r\nreturn -EINVAL;\r\nmutex_lock(&video->stream_lock);\r\nif (!vb2_is_streaming(&vfh->queue))\r\ngoto done;\r\nif (video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nstate = ISS_PIPELINE_STREAM_OUTPUT\r\n| ISS_PIPELINE_QUEUE_OUTPUT;\r\nelse\r\nstate = ISS_PIPELINE_STREAM_INPUT\r\n| ISS_PIPELINE_QUEUE_INPUT;\r\nspin_lock_irqsave(&pipe->lock, flags);\r\npipe->state &= ~state;\r\nspin_unlock_irqrestore(&pipe->lock, flags);\r\nomap4iss_pipeline_set_stream(pipe, ISS_PIPELINE_STREAM_STOPPED);\r\nvb2_streamoff(&vfh->queue, type);\r\nvideo->queue = NULL;\r\nif (video->iss->pdata->set_constraints)\r\nvideo->iss->pdata->set_constraints(video->iss, false);\r\nmedia_entity_pipeline_stop(&video->video.entity);\r\ndone:\r\nmutex_unlock(&video->stream_lock);\r\nreturn 0;\r\n}\r\nstatic int\r\niss_video_enum_input(struct file *file, void *fh, struct v4l2_input *input)\r\n{\r\nif (input->index > 0)\r\nreturn -EINVAL;\r\nstrlcpy(input->name, "camera", sizeof(input->name));\r\ninput->type = V4L2_INPUT_TYPE_CAMERA;\r\nreturn 0;\r\n}\r\nstatic int\r\niss_video_g_input(struct file *file, void *fh, unsigned int *input)\r\n{\r\n*input = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\niss_video_s_input(struct file *file, void *fh, unsigned int input)\r\n{\r\nreturn input == 0 ? 0 : -EINVAL;\r\n}\r\nstatic int iss_video_open(struct file *file)\r\n{\r\nstruct iss_video *video = video_drvdata(file);\r\nstruct iss_video_fh *handle;\r\nstruct vb2_queue *q;\r\nint ret = 0;\r\nhandle = kzalloc(sizeof(*handle), GFP_KERNEL);\r\nif (handle == NULL)\r\nreturn -ENOMEM;\r\nv4l2_fh_init(&handle->vfh, &video->video);\r\nv4l2_fh_add(&handle->vfh);\r\nif (omap4iss_get(video->iss) == NULL) {\r\nret = -EBUSY;\r\ngoto done;\r\n}\r\nret = omap4iss_pipeline_pm_use(&video->video.entity, 1);\r\nif (ret < 0) {\r\nomap4iss_put(video->iss);\r\ngoto done;\r\n}\r\nvideo->alloc_ctx = vb2_dma_contig_init_ctx(video->iss->dev);\r\nif (IS_ERR(video->alloc_ctx)) {\r\nret = PTR_ERR(video->alloc_ctx);\r\nomap4iss_put(video->iss);\r\ngoto done;\r\n}\r\nq = &handle->queue;\r\nq->type = video->type;\r\nq->io_modes = VB2_MMAP | VB2_DMABUF;\r\nq->drv_priv = handle;\r\nq->ops = &iss_video_vb2ops;\r\nq->mem_ops = &vb2_dma_contig_memops;\r\nq->buf_struct_size = sizeof(struct iss_buffer);\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nret = vb2_queue_init(q);\r\nif (ret) {\r\nomap4iss_put(video->iss);\r\ngoto done;\r\n}\r\nmemset(&handle->format, 0, sizeof(handle->format));\r\nhandle->format.type = video->type;\r\nhandle->timeperframe.denominator = 1;\r\nhandle->video = video;\r\nfile->private_data = &handle->vfh;\r\ndone:\r\nif (ret < 0) {\r\nv4l2_fh_del(&handle->vfh);\r\nkfree(handle);\r\n}\r\nreturn ret;\r\n}\r\nstatic int iss_video_release(struct file *file)\r\n{\r\nstruct iss_video *video = video_drvdata(file);\r\nstruct v4l2_fh *vfh = file->private_data;\r\nstruct iss_video_fh *handle = to_iss_video_fh(vfh);\r\niss_video_streamoff(file, vfh, video->type);\r\nomap4iss_pipeline_pm_use(&video->video.entity, 0);\r\nvb2_queue_release(&handle->queue);\r\nv4l2_fh_del(vfh);\r\nkfree(handle);\r\nfile->private_data = NULL;\r\nomap4iss_put(video->iss);\r\nreturn 0;\r\n}\r\nstatic unsigned int iss_video_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct iss_video_fh *vfh = to_iss_video_fh(file->private_data);\r\nreturn vb2_poll(&vfh->queue, file, wait);\r\n}\r\nstatic int iss_video_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct iss_video_fh *vfh = to_iss_video_fh(file->private_data);\r\nreturn vb2_mmap(&vfh->queue, vma);\r\n}\r\nint omap4iss_video_init(struct iss_video *video, const char *name)\r\n{\r\nconst char *direction;\r\nint ret;\r\nswitch (video->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\ndirection = "output";\r\nvideo->pad.flags = MEDIA_PAD_FL_SINK;\r\nbreak;\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT:\r\ndirection = "input";\r\nvideo->pad.flags = MEDIA_PAD_FL_SOURCE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = media_entity_init(&video->video.entity, 1, &video->pad, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nspin_lock_init(&video->qlock);\r\nmutex_init(&video->mutex);\r\natomic_set(&video->active, 0);\r\nspin_lock_init(&video->pipe.lock);\r\nmutex_init(&video->stream_lock);\r\nif (video->ops == NULL)\r\nvideo->ops = &iss_video_dummy_ops;\r\nvideo->video.fops = &iss_video_fops;\r\nsnprintf(video->video.name, sizeof(video->video.name),\r\n"OMAP4 ISS %s %s", name, direction);\r\nvideo->video.vfl_type = VFL_TYPE_GRABBER;\r\nvideo->video.release = video_device_release_empty;\r\nvideo->video.ioctl_ops = &iss_video_ioctl_ops;\r\nvideo->pipe.stream_state = ISS_PIPELINE_STREAM_STOPPED;\r\nvideo_set_drvdata(&video->video, video);\r\nreturn 0;\r\n}\r\nvoid omap4iss_video_cleanup(struct iss_video *video)\r\n{\r\nmedia_entity_cleanup(&video->video.entity);\r\nmutex_destroy(&video->stream_lock);\r\nmutex_destroy(&video->mutex);\r\n}\r\nint omap4iss_video_register(struct iss_video *video, struct v4l2_device *vdev)\r\n{\r\nint ret;\r\nvideo->video.v4l2_dev = vdev;\r\nret = video_register_device(&video->video, VFL_TYPE_GRABBER, -1);\r\nif (ret < 0)\r\ndev_err(video->iss->dev,\r\n"could not register video device (%d)\n", ret);\r\nreturn ret;\r\n}\r\nvoid omap4iss_video_unregister(struct iss_video *video)\r\n{\r\nvideo_unregister_device(&video->video);\r\n}
