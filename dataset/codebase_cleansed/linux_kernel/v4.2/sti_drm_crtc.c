static void sti_drm_crtc_dpms(struct drm_crtc *crtc, int mode)\r\n{\r\nDRM_DEBUG_KMS("\n");\r\n}\r\nstatic void sti_drm_crtc_prepare(struct drm_crtc *crtc)\r\n{\r\nstruct sti_mixer *mixer = to_sti_mixer(crtc);\r\nstruct device *dev = mixer->dev;\r\nstruct sti_compositor *compo = dev_get_drvdata(dev);\r\nmixer->enabled = true;\r\nif (mixer->id == STI_MIXER_MAIN) {\r\nif (clk_prepare_enable(compo->clk_compo_main))\r\nDRM_INFO("Failed to prepare/enable compo_main clk\n");\r\n} else {\r\nif (clk_prepare_enable(compo->clk_compo_aux))\r\nDRM_INFO("Failed to prepare/enable compo_aux clk\n");\r\n}\r\nsti_mixer_clear_all_layers(mixer);\r\n}\r\nstatic void sti_drm_crtc_commit(struct drm_crtc *crtc)\r\n{\r\nstruct sti_mixer *mixer = to_sti_mixer(crtc);\r\nstruct device *dev = mixer->dev;\r\nstruct sti_compositor *compo = dev_get_drvdata(dev);\r\nstruct sti_layer *layer;\r\nif ((!mixer || !compo)) {\r\nDRM_ERROR("Can not find mixer or compositor)\n");\r\nreturn;\r\n}\r\nlayer = to_sti_layer(crtc->primary);\r\nif (layer)\r\nsti_layer_commit(layer);\r\nelse\r\nDRM_ERROR("Can not find CRTC dedicated plane (GDP0)\n");\r\nif (sti_mixer_set_layer_status(mixer, layer, true))\r\nDRM_ERROR("Can not enable layer at mixer\n");\r\ndrm_crtc_vblank_on(crtc);\r\n}\r\nstatic bool sti_drm_crtc_mode_fixup(struct drm_crtc *crtc,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic int\r\nsti_drm_crtc_mode_set(struct drm_crtc *crtc, struct drm_display_mode *mode)\r\n{\r\nstruct sti_mixer *mixer = to_sti_mixer(crtc);\r\nstruct device *dev = mixer->dev;\r\nstruct sti_compositor *compo = dev_get_drvdata(dev);\r\nstruct clk *clk;\r\nint rate = mode->clock * 1000;\r\nint res;\r\nDRM_DEBUG_KMS("CRTC:%d (%s) mode:%d (%s)\n",\r\ncrtc->base.id, sti_mixer_to_str(mixer),\r\nmode->base.id, mode->name);\r\nDRM_DEBUG_KMS("%d %d %d %d %d %d %d %d %d %d 0x%x 0x%x\n",\r\nmode->vrefresh, mode->clock,\r\nmode->hdisplay,\r\nmode->hsync_start, mode->hsync_end,\r\nmode->htotal,\r\nmode->vdisplay,\r\nmode->vsync_start, mode->vsync_end,\r\nmode->vtotal, mode->type, mode->flags);\r\nif (mixer->id == STI_MIXER_MAIN)\r\nclk = compo->clk_pix_main;\r\nelse\r\nclk = compo->clk_pix_aux;\r\nres = clk_set_rate(clk, rate);\r\nif (res < 0) {\r\nDRM_ERROR("Cannot set rate (%dHz) for pix clk\n", rate);\r\nreturn -EINVAL;\r\n}\r\nif (clk_prepare_enable(clk)) {\r\nDRM_ERROR("Failed to prepare/enable pix clk\n");\r\nreturn -EINVAL;\r\n}\r\nsti_vtg_set_config(mixer->id == STI_MIXER_MAIN ?\r\ncompo->vtg_main : compo->vtg_aux, &crtc->mode);\r\nres = sti_mixer_active_video_area(mixer, &crtc->mode);\r\nif (res) {\r\nDRM_ERROR("Can not set active video area\n");\r\nreturn -EINVAL;\r\n}\r\nreturn res;\r\n}\r\nstatic void sti_drm_crtc_disable(struct drm_crtc *crtc)\r\n{\r\nstruct sti_mixer *mixer = to_sti_mixer(crtc);\r\nstruct device *dev = mixer->dev;\r\nstruct sti_compositor *compo = dev_get_drvdata(dev);\r\nif (!mixer->enabled)\r\nreturn;\r\nDRM_DEBUG_KMS("CRTC:%d (%s)\n", crtc->base.id, sti_mixer_to_str(mixer));\r\nsti_mixer_set_background_status(mixer, false);\r\ndrm_crtc_vblank_off(crtc);\r\nif (mixer->id == STI_MIXER_MAIN) {\r\nclk_disable_unprepare(compo->clk_pix_main);\r\nclk_disable_unprepare(compo->clk_compo_main);\r\n} else {\r\nclk_disable_unprepare(compo->clk_pix_aux);\r\nclk_disable_unprepare(compo->clk_compo_aux);\r\n}\r\nmixer->enabled = false;\r\n}\r\nstatic void\r\nsti_drm_crtc_mode_set_nofb(struct drm_crtc *crtc)\r\n{\r\nsti_drm_crtc_prepare(crtc);\r\nsti_drm_crtc_mode_set(crtc, &crtc->state->adjusted_mode);\r\n}\r\nstatic void sti_drm_atomic_begin(struct drm_crtc *crtc)\r\n{\r\nstruct sti_mixer *mixer = to_sti_mixer(crtc);\r\nif (crtc->state->event) {\r\ncrtc->state->event->pipe = drm_crtc_index(crtc);\r\nWARN_ON(drm_crtc_vblank_get(crtc) != 0);\r\nmixer->pending_event = crtc->state->event;\r\ncrtc->state->event = NULL;\r\n}\r\n}\r\nstatic void sti_drm_atomic_flush(struct drm_crtc *crtc)\r\n{\r\n}\r\nstatic void sti_drm_crtc_destroy(struct drm_crtc *crtc)\r\n{\r\nDRM_DEBUG_KMS("\n");\r\ndrm_crtc_cleanup(crtc);\r\n}\r\nstatic int sti_drm_crtc_set_property(struct drm_crtc *crtc,\r\nstruct drm_property *property,\r\nuint64_t val)\r\n{\r\nDRM_DEBUG_KMS("\n");\r\nreturn 0;\r\n}\r\nint sti_drm_crtc_vblank_cb(struct notifier_block *nb,\r\nunsigned long event, void *data)\r\n{\r\nstruct drm_device *drm_dev;\r\nstruct sti_compositor *compo =\r\ncontainer_of(nb, struct sti_compositor, vtg_vblank_nb);\r\nint *crtc = data;\r\nunsigned long flags;\r\nstruct sti_drm_private *priv;\r\ndrm_dev = compo->mixer[*crtc]->drm_crtc.dev;\r\npriv = drm_dev->dev_private;\r\nif ((event != VTG_TOP_FIELD_EVENT) &&\r\n(event != VTG_BOTTOM_FIELD_EVENT)) {\r\nDRM_ERROR("unknown event: %lu\n", event);\r\nreturn -EINVAL;\r\n}\r\ndrm_handle_vblank(drm_dev, *crtc);\r\nspin_lock_irqsave(&drm_dev->event_lock, flags);\r\nif (compo->mixer[*crtc]->pending_event) {\r\ndrm_send_vblank_event(drm_dev, -1,\r\ncompo->mixer[*crtc]->pending_event);\r\ndrm_vblank_put(drm_dev, *crtc);\r\ncompo->mixer[*crtc]->pending_event = NULL;\r\n}\r\nspin_unlock_irqrestore(&drm_dev->event_lock, flags);\r\nreturn 0;\r\n}\r\nint sti_drm_crtc_enable_vblank(struct drm_device *dev, int crtc)\r\n{\r\nstruct sti_drm_private *dev_priv = dev->dev_private;\r\nstruct sti_compositor *compo = dev_priv->compo;\r\nstruct notifier_block *vtg_vblank_nb = &compo->vtg_vblank_nb;\r\nif (sti_vtg_register_client(crtc == STI_MIXER_MAIN ?\r\ncompo->vtg_main : compo->vtg_aux,\r\nvtg_vblank_nb, crtc)) {\r\nDRM_ERROR("Cannot register VTG notifier\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid sti_drm_crtc_disable_vblank(struct drm_device *dev, int crtc)\r\n{\r\nstruct sti_drm_private *priv = dev->dev_private;\r\nstruct sti_compositor *compo = priv->compo;\r\nstruct notifier_block *vtg_vblank_nb = &compo->vtg_vblank_nb;\r\nDRM_DEBUG_DRIVER("\n");\r\nif (sti_vtg_unregister_client(crtc == STI_MIXER_MAIN ?\r\ncompo->vtg_main : compo->vtg_aux, vtg_vblank_nb))\r\nDRM_DEBUG_DRIVER("Warning: cannot unregister VTG notifier\n");\r\nif (compo->mixer[crtc]->pending_event) {\r\ndrm_vblank_put(dev, crtc);\r\ncompo->mixer[crtc]->pending_event = NULL;\r\n}\r\n}\r\nbool sti_drm_crtc_is_main(struct drm_crtc *crtc)\r\n{\r\nstruct sti_mixer *mixer = to_sti_mixer(crtc);\r\nif (mixer->id == STI_MIXER_MAIN)\r\nreturn true;\r\nreturn false;\r\n}\r\nint sti_drm_crtc_init(struct drm_device *drm_dev, struct sti_mixer *mixer,\r\nstruct drm_plane *primary, struct drm_plane *cursor)\r\n{\r\nstruct drm_crtc *crtc = &mixer->drm_crtc;\r\nint res;\r\nres = drm_crtc_init_with_planes(drm_dev, crtc, primary, cursor,\r\n&sti_crtc_funcs);\r\nif (res) {\r\nDRM_ERROR("Can not initialze CRTC\n");\r\nreturn -EINVAL;\r\n}\r\ndrm_crtc_helper_add(crtc, &sti_crtc_helper_funcs);\r\nDRM_DEBUG_DRIVER("drm CRTC:%d mapped to %s\n",\r\ncrtc->base.id, sti_mixer_to_str(mixer));\r\nreturn 0;\r\n}
