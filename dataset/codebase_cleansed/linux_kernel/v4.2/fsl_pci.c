static void quirk_fsl_pcie_early(struct pci_dev *dev)\r\n{\r\nu8 hdr_type;\r\nif (!pci_is_pcie(dev))\r\nreturn;\r\npci_read_config_byte(dev, PCI_HEADER_TYPE, &hdr_type);\r\nif ((hdr_type & 0x7f) != PCI_HEADER_TYPE_BRIDGE)\r\nreturn;\r\ndev->class = PCI_CLASS_BRIDGE_PCI << 8;\r\nfsl_pcie_bus_fixup = 1;\r\nreturn;\r\n}\r\nstatic int fsl_pcie_check_link(struct pci_controller *hose)\r\n{\r\nu32 val = 0;\r\nif (hose->indirect_type & PPC_INDIRECT_TYPE_FSL_CFG_REG_LINK) {\r\nif (hose->ops->read == fsl_indirect_read_config)\r\n__indirect_read_config(hose, hose->first_busno, 0,\r\nPCIE_LTSSM, 4, &val);\r\nelse\r\nearly_read_config_dword(hose, 0, 0, PCIE_LTSSM, &val);\r\nif (val < PCIE_LTSSM_L0)\r\nreturn 1;\r\n} else {\r\nstruct ccsr_pci __iomem *pci = hose->private_data;\r\nval = (in_be32(&pci->pex_csr0) & PEX_CSR0_LTSSM_MASK)\r\n>> PEX_CSR0_LTSSM_SHIFT;\r\nif (val != PEX_CSR0_LTSSM_L0)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_indirect_read_config(struct pci_bus *bus, unsigned int devfn,\r\nint offset, int len, u32 *val)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nif (fsl_pcie_check_link(hose))\r\nhose->indirect_type |= PPC_INDIRECT_TYPE_NO_PCIE_LINK;\r\nelse\r\nhose->indirect_type &= ~PPC_INDIRECT_TYPE_NO_PCIE_LINK;\r\nreturn indirect_read_config(bus, devfn, offset, len, val);\r\n}\r\nstatic void setup_swiotlb_ops(struct pci_controller *hose)\r\n{\r\nif (ppc_swiotlb_enable) {\r\nhose->controller_ops.dma_dev_setup = pci_dma_dev_setup_swiotlb;\r\nset_pci_dma_ops(&swiotlb_dma_ops);\r\n}\r\n}\r\nstatic inline void setup_swiotlb_ops(struct pci_controller *hose) {}\r\nstatic int fsl_pci_dma_set_mask(struct device *dev, u64 dma_mask)\r\n{\r\nif (!dev->dma_mask || !dma_supported(dev, dma_mask))\r\nreturn -EIO;\r\nif ((dev_is_pci(dev)) &&\r\ndma_mask >= DMA_BIT_MASK(MAX_PHYS_ADDR_BITS)) {\r\nset_dma_ops(dev, &dma_direct_ops);\r\nset_dma_offset(dev, pci64_dma_offset);\r\n}\r\n*dev->dma_mask = dma_mask;\r\nreturn 0;\r\n}\r\nstatic int setup_one_atmu(struct ccsr_pci __iomem *pci,\r\nunsigned int index, const struct resource *res,\r\nresource_size_t offset)\r\n{\r\nresource_size_t pci_addr = res->start - offset;\r\nresource_size_t phys_addr = res->start;\r\nresource_size_t size = resource_size(res);\r\nu32 flags = 0x80044000;\r\nunsigned int i;\r\npr_debug("PCI MEM resource start 0x%016llx, size 0x%016llx.\n",\r\n(u64)res->start, (u64)size);\r\nif (res->flags & IORESOURCE_PREFETCH)\r\nflags |= 0x10000000;\r\nfor (i = 0; size > 0; i++) {\r\nunsigned int bits = min_t(u32, ilog2(size),\r\n__ffs(pci_addr | phys_addr));\r\nif (index + i >= 5)\r\nreturn -1;\r\nout_be32(&pci->pow[index + i].potar, pci_addr >> 12);\r\nout_be32(&pci->pow[index + i].potear, (u64)pci_addr >> 44);\r\nout_be32(&pci->pow[index + i].powbar, phys_addr >> 12);\r\nout_be32(&pci->pow[index + i].powar, flags | (bits - 1));\r\npci_addr += (resource_size_t)1U << bits;\r\nphys_addr += (resource_size_t)1U << bits;\r\nsize -= (resource_size_t)1U << bits;\r\n}\r\nreturn i;\r\n}\r\nstatic void setup_pci_atmu(struct pci_controller *hose)\r\n{\r\nstruct ccsr_pci __iomem *pci = hose->private_data;\r\nint i, j, n, mem_log, win_idx = 3, start_idx = 1, end_idx = 4;\r\nu64 mem, sz, paddr_hi = 0;\r\nu64 offset = 0, paddr_lo = ULLONG_MAX;\r\nu32 pcicsrbar = 0, pcicsrbar_sz;\r\nu32 piwar = PIWAR_EN | PIWAR_PF | PIWAR_TGI_LOCAL |\r\nPIWAR_READ_SNOOP | PIWAR_WRITE_SNOOP;\r\nconst char *name = hose->dn->full_name;\r\nconst u64 *reg;\r\nint len;\r\nif (early_find_capability(hose, 0, 0, PCI_CAP_ID_EXP)) {\r\nif (in_be32(&pci->block_rev1) >= PCIE_IP_REV_2_2) {\r\nwin_idx = 2;\r\nstart_idx = 0;\r\nend_idx = 3;\r\n}\r\n}\r\nfor(i = 1; i < 5; i++)\r\nout_be32(&pci->pow[i].powar, 0);\r\nfor (i = start_idx; i < end_idx; i++)\r\nout_be32(&pci->piw[i].piwar, 0);\r\nfor(i = 0, j = 1; i < 3; i++) {\r\nif (!(hose->mem_resources[i].flags & IORESOURCE_MEM))\r\ncontinue;\r\npaddr_lo = min(paddr_lo, (u64)hose->mem_resources[i].start);\r\npaddr_hi = max(paddr_hi, (u64)hose->mem_resources[i].end);\r\noffset = hose->mem_offset[i];\r\nn = setup_one_atmu(pci, j, &hose->mem_resources[i], offset);\r\nif (n < 0 || j >= 5) {\r\npr_err("Ran out of outbound PCI ATMUs for resource %d!\n", i);\r\nhose->mem_resources[i].flags |= IORESOURCE_DISABLED;\r\n} else\r\nj += n;\r\n}\r\nif (hose->io_resource.flags & IORESOURCE_IO) {\r\nif (j >= 5) {\r\npr_err("Ran out of outbound PCI ATMUs for IO resource\n");\r\n} else {\r\npr_debug("PCI IO resource start 0x%016llx, size 0x%016llx, "\r\n"phy base 0x%016llx.\n",\r\n(u64)hose->io_resource.start,\r\n(u64)resource_size(&hose->io_resource),\r\n(u64)hose->io_base_phys);\r\nout_be32(&pci->pow[j].potar, (hose->io_resource.start >> 12));\r\nout_be32(&pci->pow[j].potear, 0);\r\nout_be32(&pci->pow[j].powbar, (hose->io_base_phys >> 12));\r\nout_be32(&pci->pow[j].powar, 0x80088000\r\n| (ilog2(hose->io_resource.end\r\n- hose->io_resource.start + 1) - 1));\r\n}\r\n}\r\npaddr_hi -= offset;\r\npaddr_lo -= offset;\r\nif (paddr_hi == paddr_lo) {\r\npr_err("%s: No outbound window space\n", name);\r\nreturn;\r\n}\r\nif (paddr_lo == 0) {\r\npr_err("%s: No space for inbound window\n", name);\r\nreturn;\r\n}\r\nearly_write_config_dword(hose, 0, 0, PCI_BASE_ADDRESS_0, 0xffffffff);\r\nearly_read_config_dword(hose, 0, 0, PCI_BASE_ADDRESS_0, &pcicsrbar_sz);\r\npcicsrbar_sz = ~pcicsrbar_sz + 1;\r\nif (paddr_hi < (0x100000000ull - pcicsrbar_sz) ||\r\n(paddr_lo > 0x100000000ull))\r\npcicsrbar = 0x100000000ull - pcicsrbar_sz;\r\nelse\r\npcicsrbar = (paddr_lo - pcicsrbar_sz) & -pcicsrbar_sz;\r\nearly_write_config_dword(hose, 0, 0, PCI_BASE_ADDRESS_0, pcicsrbar);\r\npaddr_lo = min(paddr_lo, (u64)pcicsrbar);\r\npr_info("%s: PCICSRBAR @ 0x%x\n", name, pcicsrbar);\r\nmem = memblock_end_of_DRAM();\r\nreg = of_get_property(hose->dn, "msi-address-64", &len);\r\nif (reg && (len == sizeof(u64))) {\r\nu64 address = be64_to_cpup(reg);\r\nif ((address >= mem) && (address < (mem + PAGE_SIZE))) {\r\npr_info("%s: extending DDR ATMU to cover MSIIR", name);\r\nmem += PAGE_SIZE;\r\n} else {\r\npr_warn("%s: msi-address-64 address of %llx is "\r\n"unsupported\n", name, address);\r\n}\r\n}\r\nsz = min(mem, paddr_lo);\r\nmem_log = ilog2(sz);\r\nif (early_find_capability(hose, 0, 0, PCI_CAP_ID_EXP)) {\r\nif ((1ull << mem_log) != mem) {\r\nmem_log++;\r\nif ((1ull << mem_log) > mem)\r\npr_info("%s: Setting PCI inbound window "\r\n"greater than memory size\n", name);\r\n}\r\npiwar |= ((mem_log - 1) & PIWAR_SZ_MASK);\r\nout_be32(&pci->piw[win_idx].pitar, 0x00000000);\r\nout_be32(&pci->piw[win_idx].piwbar, 0x00000000);\r\nout_be32(&pci->piw[win_idx].piwar, piwar);\r\nwin_idx--;\r\nhose->dma_window_base_cur = 0x00000000;\r\nhose->dma_window_size = (resource_size_t)sz;\r\nif (sz != mem) {\r\nmem_log = ilog2(mem);\r\nif ((1ull << mem_log) != mem)\r\nmem_log++;\r\npiwar = (piwar & ~PIWAR_SZ_MASK) | (mem_log - 1);\r\nout_be32(&pci->piw[win_idx].pitar, 0x00000000);\r\nout_be32(&pci->piw[win_idx].piwbear,\r\npci64_dma_offset >> 44);\r\nout_be32(&pci->piw[win_idx].piwbar,\r\npci64_dma_offset >> 12);\r\nout_be32(&pci->piw[win_idx].piwar, piwar);\r\nppc_md.dma_set_mask = fsl_pci_dma_set_mask;\r\npr_info("%s: Setup 64-bit PCI DMA window\n", name);\r\n}\r\n} else {\r\nu64 paddr = 0;\r\nout_be32(&pci->piw[win_idx].pitar, paddr >> 12);\r\nout_be32(&pci->piw[win_idx].piwbar, paddr >> 12);\r\nout_be32(&pci->piw[win_idx].piwar, (piwar | (mem_log - 1)));\r\nwin_idx--;\r\npaddr += 1ull << mem_log;\r\nsz -= 1ull << mem_log;\r\nif (sz) {\r\nmem_log = ilog2(sz);\r\npiwar |= (mem_log - 1);\r\nout_be32(&pci->piw[win_idx].pitar, paddr >> 12);\r\nout_be32(&pci->piw[win_idx].piwbar, paddr >> 12);\r\nout_be32(&pci->piw[win_idx].piwar, piwar);\r\nwin_idx--;\r\npaddr += 1ull << mem_log;\r\n}\r\nhose->dma_window_base_cur = 0x00000000;\r\nhose->dma_window_size = (resource_size_t)paddr;\r\n}\r\nif (hose->dma_window_size < mem) {\r\n#ifdef CONFIG_SWIOTLB\r\nppc_swiotlb_enable = 1;\r\n#else\r\npr_err("%s: ERROR: Memory size exceeds PCI ATMU ability to "\r\n"map - enable CONFIG_SWIOTLB to avoid dma errors.\n",\r\nname);\r\n#endif\r\nif (paddr_hi < 0xffffffffull)\r\npr_warning("%s: WARNING: Outbound window cfg leaves "\r\n"gaps in memory map. Adjusting the memory map "\r\n"could reduce unnecessary bounce buffering.\n",\r\nname);\r\npr_info("%s: DMA window size is 0x%llx\n", name,\r\n(u64)hose->dma_window_size);\r\n}\r\n}\r\nstatic void __init setup_pci_cmd(struct pci_controller *hose)\r\n{\r\nu16 cmd;\r\nint cap_x;\r\nearly_read_config_word(hose, 0, 0, PCI_COMMAND, &cmd);\r\ncmd |= PCI_COMMAND_SERR | PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY\r\n| PCI_COMMAND_IO;\r\nearly_write_config_word(hose, 0, 0, PCI_COMMAND, cmd);\r\ncap_x = early_find_capability(hose, 0, 0, PCI_CAP_ID_PCIX);\r\nif (cap_x) {\r\nint pci_x_cmd = cap_x + PCI_X_CMD;\r\ncmd = PCI_X_CMD_MAX_SPLIT | PCI_X_CMD_MAX_READ\r\n| PCI_X_CMD_ERO | PCI_X_CMD_DPERR_E;\r\nearly_write_config_word(hose, 0, 0, pci_x_cmd, cmd);\r\n} else {\r\nearly_write_config_byte(hose, 0, 0, PCI_LATENCY_TIMER, 0x80);\r\n}\r\n}\r\nvoid fsl_pcibios_fixup_bus(struct pci_bus *bus)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nint i, is_pcie = 0, no_link;\r\nif (fsl_pcie_bus_fixup)\r\nis_pcie = early_find_capability(hose, 0, 0, PCI_CAP_ID_EXP);\r\nno_link = !!(hose->indirect_type & PPC_INDIRECT_TYPE_NO_PCIE_LINK);\r\nif (bus->parent == hose->bus && (is_pcie || no_link)) {\r\nfor (i = 0; i < PCI_BRIDGE_RESOURCE_NUM; ++i) {\r\nstruct resource *res = bus->resource[i];\r\nstruct resource *par;\r\nif (!res)\r\ncontinue;\r\nif (i == 0)\r\npar = &hose->io_resource;\r\nelse if (i < 4)\r\npar = &hose->mem_resources[i-1];\r\nelse par = NULL;\r\nres->start = par ? par->start : 0;\r\nres->end = par ? par->end : 0;\r\nres->flags = par ? par->flags : 0;\r\n}\r\n}\r\n}\r\nint fsl_add_bridge(struct platform_device *pdev, int is_primary)\r\n{\r\nint len;\r\nstruct pci_controller *hose;\r\nstruct resource rsrc;\r\nconst int *bus_range;\r\nu8 hdr_type, progif;\r\nstruct device_node *dev;\r\nstruct ccsr_pci __iomem *pci;\r\ndev = pdev->dev.of_node;\r\nif (!of_device_is_available(dev)) {\r\npr_warning("%s: disabled\n", dev->full_name);\r\nreturn -ENODEV;\r\n}\r\npr_debug("Adding PCI host bridge %s\n", dev->full_name);\r\nif (of_address_to_resource(dev, 0, &rsrc)) {\r\nprintk(KERN_WARNING "Can't get pci register base!");\r\nreturn -ENOMEM;\r\n}\r\nbus_range = of_get_property(dev, "bus-range", &len);\r\nif (bus_range == NULL || len < 2 * sizeof(int))\r\nprintk(KERN_WARNING "Can't get bus-range for %s, assume"\r\n" bus 0\n", dev->full_name);\r\npci_add_flags(PCI_REASSIGN_ALL_BUS);\r\nhose = pcibios_alloc_controller(dev);\r\nif (!hose)\r\nreturn -ENOMEM;\r\nhose->parent = &pdev->dev;\r\nhose->first_busno = bus_range ? bus_range[0] : 0x0;\r\nhose->last_busno = bus_range ? bus_range[1] : 0xff;\r\npr_debug("PCI memory map start 0x%016llx, size 0x%016llx\n",\r\n(u64)rsrc.start, (u64)resource_size(&rsrc));\r\npci = hose->private_data = ioremap(rsrc.start, resource_size(&rsrc));\r\nif (!hose->private_data)\r\ngoto no_bridge;\r\nsetup_indirect_pci(hose, rsrc.start, rsrc.start + 0x4,\r\nPPC_INDIRECT_TYPE_BIG_ENDIAN);\r\nif (in_be32(&pci->block_rev1) < PCIE_IP_REV_3_0)\r\nhose->indirect_type |= PPC_INDIRECT_TYPE_FSL_CFG_REG_LINK;\r\nif (early_find_capability(hose, 0, 0, PCI_CAP_ID_EXP)) {\r\nhose->ops = &fsl_indirect_pcie_ops;\r\nearly_read_config_byte(hose, 0, 0, PCI_HEADER_TYPE, &hdr_type);\r\nif ((hdr_type & 0x7f) != PCI_HEADER_TYPE_BRIDGE)\r\ngoto no_bridge;\r\n} else {\r\nearly_read_config_byte(hose, 0, 0, PCI_CLASS_PROG, &progif);\r\nif ((progif & 1) &&\r\n!of_property_read_bool(dev, "fsl,pci-agent-force-enum"))\r\ngoto no_bridge;\r\n}\r\nsetup_pci_cmd(hose);\r\nif (early_find_capability(hose, 0, 0, PCI_CAP_ID_EXP)) {\r\nhose->indirect_type |= PPC_INDIRECT_TYPE_EXT_REG |\r\nPPC_INDIRECT_TYPE_SURPRESS_PRIMARY_BUS;\r\nif (fsl_pcie_check_link(hose))\r\nhose->indirect_type |= PPC_INDIRECT_TYPE_NO_PCIE_LINK;\r\n}\r\nprintk(KERN_INFO "Found FSL PCI host bridge at 0x%016llx. "\r\n"Firmware bus number: %d->%d\n",\r\n(unsigned long long)rsrc.start, hose->first_busno,\r\nhose->last_busno);\r\npr_debug(" ->Hose at 0x%p, cfg_addr=0x%p,cfg_data=0x%p\n",\r\nhose, hose->cfg_addr, hose->cfg_data);\r\npci_process_bridge_OF_ranges(hose, dev, is_primary);\r\nsetup_pci_atmu(hose);\r\nsetup_swiotlb_ops(hose);\r\nreturn 0;\r\nno_bridge:\r\niounmap(hose->private_data);\r\nif (((unsigned long)hose->cfg_data & PAGE_MASK) !=\r\n((unsigned long)hose->cfg_addr & PAGE_MASK))\r\niounmap(hose->cfg_data);\r\niounmap(hose->cfg_addr);\r\npcibios_free_controller(hose);\r\nreturn -ENODEV;\r\n}\r\nstatic int mpc83xx_pcie_exclude_device(struct pci_bus *bus, unsigned int devfn)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nif (hose->indirect_type & PPC_INDIRECT_TYPE_NO_PCIE_LINK)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (bus->number == hose->first_busno ||\r\nbus->primary == hose->first_busno) {\r\nif (devfn & 0xf8)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nif (ppc_md.pci_exclude_device) {\r\nif (ppc_md.pci_exclude_device(hose, bus->number, devfn))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic void __iomem *mpc83xx_pcie_remap_cfg(struct pci_bus *bus,\r\nunsigned int devfn, int offset)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nstruct mpc83xx_pcie_priv *pcie = hose->dn->data;\r\nu32 dev_base = bus->number << 24 | devfn << 16;\r\nint ret;\r\nret = mpc83xx_pcie_exclude_device(bus, devfn);\r\nif (ret)\r\nreturn NULL;\r\noffset &= 0xfff;\r\nif (bus->number == hose->first_busno)\r\nreturn pcie->cfg_type0 + offset;\r\nif (pcie->dev_base == dev_base)\r\ngoto mapped;\r\nout_le32(pcie->cfg_type0 + PEX_OUTWIN0_TAL, dev_base);\r\npcie->dev_base = dev_base;\r\nmapped:\r\nreturn pcie->cfg_type1 + offset;\r\n}\r\nstatic int mpc83xx_pcie_write_config(struct pci_bus *bus, unsigned int devfn,\r\nint offset, int len, u32 val)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nif (offset == PCI_PRIMARY_BUS && bus->number == hose->first_busno)\r\nval &= 0xffffff00;\r\nreturn pci_generic_config_write(bus, devfn, offset, len, val);\r\n}\r\nstatic int __init mpc83xx_pcie_setup(struct pci_controller *hose,\r\nstruct resource *reg)\r\n{\r\nstruct mpc83xx_pcie_priv *pcie;\r\nu32 cfg_bar;\r\nint ret = -ENOMEM;\r\npcie = zalloc_maybe_bootmem(sizeof(*pcie), GFP_KERNEL);\r\nif (!pcie)\r\nreturn ret;\r\npcie->cfg_type0 = ioremap(reg->start, resource_size(reg));\r\nif (!pcie->cfg_type0)\r\ngoto err0;\r\ncfg_bar = in_le32(pcie->cfg_type0 + PEX_OUTWIN0_BAR);\r\nif (!cfg_bar) {\r\nret = -ENODEV;\r\ngoto err1;\r\n}\r\npcie->cfg_type1 = ioremap(cfg_bar, 0x1000);\r\nif (!pcie->cfg_type1)\r\ngoto err1;\r\nWARN_ON(hose->dn->data);\r\nhose->dn->data = pcie;\r\nhose->ops = &mpc83xx_pcie_ops;\r\nhose->indirect_type |= PPC_INDIRECT_TYPE_FSL_CFG_REG_LINK;\r\nout_le32(pcie->cfg_type0 + PEX_OUTWIN0_TAH, 0);\r\nout_le32(pcie->cfg_type0 + PEX_OUTWIN0_TAL, 0);\r\nif (fsl_pcie_check_link(hose))\r\nhose->indirect_type |= PPC_INDIRECT_TYPE_NO_PCIE_LINK;\r\nreturn 0;\r\nerr1:\r\niounmap(pcie->cfg_type0);\r\nerr0:\r\nkfree(pcie);\r\nreturn ret;\r\n}\r\nint __init mpc83xx_add_bridge(struct device_node *dev)\r\n{\r\nint ret;\r\nint len;\r\nstruct pci_controller *hose;\r\nstruct resource rsrc_reg;\r\nstruct resource rsrc_cfg;\r\nconst int *bus_range;\r\nint primary;\r\nis_mpc83xx_pci = 1;\r\nif (!of_device_is_available(dev)) {\r\npr_warning("%s: disabled by the firmware.\n",\r\ndev->full_name);\r\nreturn -ENODEV;\r\n}\r\npr_debug("Adding PCI host bridge %s\n", dev->full_name);\r\nif (of_address_to_resource(dev, 0, &rsrc_reg)) {\r\nprintk(KERN_WARNING "Can't get pci register base!\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(&rsrc_cfg, 0, sizeof(rsrc_cfg));\r\nif (of_address_to_resource(dev, 1, &rsrc_cfg)) {\r\nprintk(KERN_WARNING\r\n"No pci config register base in dev tree, "\r\n"using default\n");\r\nif ((rsrc_reg.start & 0xfffff) == 0x8500)\r\nrsrc_cfg.start = (rsrc_reg.start & 0xfff00000) + 0x8300;\r\nelse if ((rsrc_reg.start & 0xfffff) == 0x8600)\r\nrsrc_cfg.start = (rsrc_reg.start & 0xfff00000) + 0x8380;\r\n}\r\nif ((rsrc_reg.start & 0xfffff) == 0x8500)\r\nprimary = 1;\r\nelse\r\nprimary = 0;\r\nbus_range = of_get_property(dev, "bus-range", &len);\r\nif (bus_range == NULL || len < 2 * sizeof(int)) {\r\nprintk(KERN_WARNING "Can't get bus-range for %s, assume"\r\n" bus 0\n", dev->full_name);\r\n}\r\npci_add_flags(PCI_REASSIGN_ALL_BUS);\r\nhose = pcibios_alloc_controller(dev);\r\nif (!hose)\r\nreturn -ENOMEM;\r\nhose->first_busno = bus_range ? bus_range[0] : 0;\r\nhose->last_busno = bus_range ? bus_range[1] : 0xff;\r\nif (of_device_is_compatible(dev, "fsl,mpc8314-pcie")) {\r\nret = mpc83xx_pcie_setup(hose, &rsrc_reg);\r\nif (ret)\r\ngoto err0;\r\n} else {\r\nsetup_indirect_pci(hose, rsrc_cfg.start,\r\nrsrc_cfg.start + 4, 0);\r\n}\r\nprintk(KERN_INFO "Found FSL PCI host bridge at 0x%016llx. "\r\n"Firmware bus number: %d->%d\n",\r\n(unsigned long long)rsrc_reg.start, hose->first_busno,\r\nhose->last_busno);\r\npr_debug(" ->Hose at 0x%p, cfg_addr=0x%p,cfg_data=0x%p\n",\r\nhose, hose->cfg_addr, hose->cfg_data);\r\npci_process_bridge_OF_ranges(hose, dev, primary);\r\nreturn 0;\r\nerr0:\r\npcibios_free_controller(hose);\r\nreturn ret;\r\n}\r\nu64 fsl_pci_immrbar_base(struct pci_controller *hose)\r\n{\r\n#ifdef CONFIG_PPC_83xx\r\nif (is_mpc83xx_pci) {\r\nstruct mpc83xx_pcie_priv *pcie = hose->dn->data;\r\nstruct pex_inbound_window *in;\r\nint i;\r\nin = pcie->cfg_type0 + PEX_RC_INWIN_BASE;\r\nfor (i = 0; i < 4; i++) {\r\nif (!(in_le32(&in[i].ar) & PEX_RCIWARn_EN))\r\ncontinue;\r\nif (get_immrbase() == in_le32(&in[i].tar))\r\nreturn (u64)in_le32(&in[i].barh) << 32 |\r\nin_le32(&in[i].barl);\r\n}\r\nprintk(KERN_WARNING "could not find PCI BAR matching IMMR\n");\r\n}\r\n#endif\r\n#if defined(CONFIG_FSL_SOC_BOOKE) || defined(CONFIG_PPC_86xx)\r\nif (!is_mpc83xx_pci) {\r\nu32 base;\r\npci_bus_read_config_dword(hose->bus,\r\nPCI_DEVFN(0, 0), PCI_BASE_ADDRESS_0, &base);\r\nbase &= PCI_BASE_ADDRESS_MEM_MASK;\r\nreturn base;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int mcheck_handle_load(struct pt_regs *regs, u32 inst)\r\n{\r\nunsigned int rd, ra, rb, d;\r\nrd = get_rt(inst);\r\nra = get_ra(inst);\r\nrb = get_rb(inst);\r\nd = get_d(inst);\r\nswitch (get_op(inst)) {\r\ncase 31:\r\nswitch (get_xop(inst)) {\r\ncase OP_31_XOP_LWZX:\r\ncase OP_31_XOP_LWBRX:\r\nregs->gpr[rd] = 0xffffffff;\r\nbreak;\r\ncase OP_31_XOP_LWZUX:\r\nregs->gpr[rd] = 0xffffffff;\r\nregs->gpr[ra] += regs->gpr[rb];\r\nbreak;\r\ncase OP_31_XOP_LBZX:\r\nregs->gpr[rd] = 0xff;\r\nbreak;\r\ncase OP_31_XOP_LBZUX:\r\nregs->gpr[rd] = 0xff;\r\nregs->gpr[ra] += regs->gpr[rb];\r\nbreak;\r\ncase OP_31_XOP_LHZX:\r\ncase OP_31_XOP_LHBRX:\r\nregs->gpr[rd] = 0xffff;\r\nbreak;\r\ncase OP_31_XOP_LHZUX:\r\nregs->gpr[rd] = 0xffff;\r\nregs->gpr[ra] += regs->gpr[rb];\r\nbreak;\r\ncase OP_31_XOP_LHAX:\r\nregs->gpr[rd] = ~0UL;\r\nbreak;\r\ncase OP_31_XOP_LHAUX:\r\nregs->gpr[rd] = ~0UL;\r\nregs->gpr[ra] += regs->gpr[rb];\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nbreak;\r\ncase OP_LWZ:\r\nregs->gpr[rd] = 0xffffffff;\r\nbreak;\r\ncase OP_LWZU:\r\nregs->gpr[rd] = 0xffffffff;\r\nregs->gpr[ra] += (s16)d;\r\nbreak;\r\ncase OP_LBZ:\r\nregs->gpr[rd] = 0xff;\r\nbreak;\r\ncase OP_LBZU:\r\nregs->gpr[rd] = 0xff;\r\nregs->gpr[ra] += (s16)d;\r\nbreak;\r\ncase OP_LHZ:\r\nregs->gpr[rd] = 0xffff;\r\nbreak;\r\ncase OP_LHZU:\r\nregs->gpr[rd] = 0xffff;\r\nregs->gpr[ra] += (s16)d;\r\nbreak;\r\ncase OP_LHA:\r\nregs->gpr[rd] = ~0UL;\r\nbreak;\r\ncase OP_LHAU:\r\nregs->gpr[rd] = ~0UL;\r\nregs->gpr[ra] += (s16)d;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int is_in_pci_mem_space(phys_addr_t addr)\r\n{\r\nstruct pci_controller *hose;\r\nstruct resource *res;\r\nint i;\r\nlist_for_each_entry(hose, &hose_list, list_node) {\r\nif (!(hose->indirect_type & PPC_INDIRECT_TYPE_EXT_REG))\r\ncontinue;\r\nfor (i = 0; i < 3; i++) {\r\nres = &hose->mem_resources[i];\r\nif ((res->flags & IORESOURCE_MEM) &&\r\naddr >= res->start && addr <= res->end)\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint fsl_pci_mcheck_exception(struct pt_regs *regs)\r\n{\r\nu32 inst;\r\nint ret;\r\nphys_addr_t addr = 0;\r\nif (regs->msr & MSR_GS)\r\nreturn 0;\r\n#ifdef CONFIG_PHYS_64BIT\r\naddr = mfspr(SPRN_MCARU);\r\naddr <<= 32;\r\n#endif\r\naddr += mfspr(SPRN_MCAR);\r\nif (is_in_pci_mem_space(addr)) {\r\nif (user_mode(regs)) {\r\npagefault_disable();\r\nret = get_user(regs->nip, &inst);\r\npagefault_enable();\r\n} else {\r\nret = probe_kernel_address(regs->nip, inst);\r\n}\r\nif (mcheck_handle_load(regs, inst)) {\r\nregs->nip += 4;\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid fsl_pci_assign_primary(void)\r\n{\r\nstruct device_node *np;\r\nif (fsl_pci_primary)\r\nreturn;\r\nnp = of_find_node_by_type(NULL, "isa");\r\nwhile ((fsl_pci_primary = of_get_parent(np))) {\r\nof_node_put(np);\r\nnp = fsl_pci_primary;\r\nif (of_match_node(pci_ids, np) && of_device_is_available(np))\r\nreturn;\r\n}\r\nfor_each_matching_node(np, pci_ids) {\r\nif (of_device_is_available(np)) {\r\nfsl_pci_primary = np;\r\nof_node_put(np);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic irqreturn_t fsl_pci_pme_handle(int irq, void *dev_id)\r\n{\r\nstruct pci_controller *hose = dev_id;\r\nstruct ccsr_pci __iomem *pci = hose->private_data;\r\nu32 dr;\r\ndr = in_be32(&pci->pex_pme_mes_dr);\r\nif (!dr)\r\nreturn IRQ_NONE;\r\nout_be32(&pci->pex_pme_mes_dr, dr);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int fsl_pci_pme_probe(struct pci_controller *hose)\r\n{\r\nstruct ccsr_pci __iomem *pci;\r\nstruct pci_dev *dev;\r\nint pme_irq;\r\nint res;\r\nu16 pms;\r\ndev = list_first_entry(&hose->bus->devices, typeof(*dev), bus_list);\r\npci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pms);\r\npms &= ~PCI_PM_CTRL_PME_ENABLE;\r\npci_write_config_word(dev, dev->pm_cap + PCI_PM_CTRL, pms);\r\npme_irq = irq_of_parse_and_map(hose->dn, 0);\r\nif (!pme_irq) {\r\ndev_err(&dev->dev, "Failed to map PME interrupt.\n");\r\nreturn -ENXIO;\r\n}\r\nres = devm_request_irq(hose->parent, pme_irq,\r\nfsl_pci_pme_handle,\r\nIRQF_SHARED,\r\n"[PCI] PME", hose);\r\nif (res < 0) {\r\ndev_err(&dev->dev, "Unable to requiest irq %d for PME\n", pme_irq);\r\nirq_dispose_mapping(pme_irq);\r\nreturn -ENODEV;\r\n}\r\npci = hose->private_data;\r\nclrbits32(&pci->pex_pme_mes_disr,\r\nPME_DISR_EN_PTOD | PME_DISR_EN_ENL23D | PME_DISR_EN_EXL23D);\r\nout_be32(&pci->pex_pme_mes_ier, 0);\r\nsetbits32(&pci->pex_pme_mes_ier,\r\nPME_DISR_EN_PTOD | PME_DISR_EN_ENL23D | PME_DISR_EN_EXL23D);\r\npci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pms);\r\npms |= PCI_PM_CTRL_PME_ENABLE;\r\npci_write_config_word(dev, dev->pm_cap + PCI_PM_CTRL, pms);\r\nreturn 0;\r\n}\r\nstatic void send_pme_turnoff_message(struct pci_controller *hose)\r\n{\r\nstruct ccsr_pci __iomem *pci = hose->private_data;\r\nu32 dr;\r\nint i;\r\nsetbits32(&pci->pex_pmcr, PEX_PMCR_PTOMR);\r\nfor (i = 0; i < 150; i++) {\r\ndr = in_be32(&pci->pex_pme_mes_dr);\r\nif (dr) {\r\nout_be32(&pci->pex_pme_mes_dr, dr);\r\nbreak;\r\n}\r\nudelay(1000);\r\n}\r\n}\r\nstatic void fsl_pci_syscore_do_suspend(struct pci_controller *hose)\r\n{\r\nsend_pme_turnoff_message(hose);\r\n}\r\nstatic int fsl_pci_syscore_suspend(void)\r\n{\r\nstruct pci_controller *hose, *tmp;\r\nlist_for_each_entry_safe(hose, tmp, &hose_list, list_node)\r\nfsl_pci_syscore_do_suspend(hose);\r\nreturn 0;\r\n}\r\nstatic void fsl_pci_syscore_do_resume(struct pci_controller *hose)\r\n{\r\nstruct ccsr_pci __iomem *pci = hose->private_data;\r\nu32 dr;\r\nint i;\r\nsetbits32(&pci->pex_pmcr, PEX_PMCR_EXL2S);\r\nfor (i = 0; i < 150; i++) {\r\ndr = in_be32(&pci->pex_pme_mes_dr);\r\nif (dr) {\r\nout_be32(&pci->pex_pme_mes_dr, dr);\r\nbreak;\r\n}\r\nudelay(1000);\r\n}\r\nsetup_pci_atmu(hose);\r\n}\r\nstatic void fsl_pci_syscore_resume(void)\r\n{\r\nstruct pci_controller *hose, *tmp;\r\nlist_for_each_entry_safe(hose, tmp, &hose_list, list_node)\r\nfsl_pci_syscore_do_resume(hose);\r\n}\r\nvoid fsl_pcibios_fixup_phb(struct pci_controller *phb)\r\n{\r\n#ifdef CONFIG_PM_SLEEP\r\nfsl_pci_pme_probe(phb);\r\n#endif\r\n}\r\nstatic int fsl_pci_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *node;\r\nint ret;\r\nnode = pdev->dev.of_node;\r\nret = fsl_add_bridge(pdev, fsl_pci_primary == node);\r\nmpc85xx_pci_err_probe(pdev);\r\nreturn 0;\r\n}\r\nstatic int __init fsl_pci_init(void)\r\n{\r\n#ifdef CONFIG_PM_SLEEP\r\nregister_syscore_ops(&pci_syscore_pm_ops);\r\n#endif\r\nreturn platform_driver_register(&fsl_pci_driver);\r\n}
