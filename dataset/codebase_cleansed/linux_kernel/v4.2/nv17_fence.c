int\r\nnv17_fence_sync(struct nouveau_fence *fence,\r\nstruct nouveau_channel *prev, struct nouveau_channel *chan)\r\n{\r\nstruct nouveau_cli *cli = (void *)nvif_client(&prev->device->base);\r\nstruct nv10_fence_priv *priv = chan->drm->fence;\r\nstruct nv10_fence_chan *fctx = chan->fence;\r\nu32 value;\r\nint ret;\r\nif (!mutex_trylock(&cli->mutex))\r\nreturn -EBUSY;\r\nspin_lock(&priv->lock);\r\nvalue = priv->sequence;\r\npriv->sequence += 2;\r\nspin_unlock(&priv->lock);\r\nret = RING_SPACE(prev, 5);\r\nif (!ret) {\r\nBEGIN_NV04(prev, 0, NV11_SUBCHAN_DMA_SEMAPHORE, 4);\r\nOUT_RING (prev, fctx->sema.handle);\r\nOUT_RING (prev, 0);\r\nOUT_RING (prev, value + 0);\r\nOUT_RING (prev, value + 1);\r\nFIRE_RING (prev);\r\n}\r\nif (!ret && !(ret = RING_SPACE(chan, 5))) {\r\nBEGIN_NV04(chan, 0, NV11_SUBCHAN_DMA_SEMAPHORE, 4);\r\nOUT_RING (chan, fctx->sema.handle);\r\nOUT_RING (chan, 0);\r\nOUT_RING (chan, value + 1);\r\nOUT_RING (chan, value + 2);\r\nFIRE_RING (chan);\r\n}\r\nmutex_unlock(&cli->mutex);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv17_fence_context_new(struct nouveau_channel *chan)\r\n{\r\nstruct nv10_fence_priv *priv = chan->drm->fence;\r\nstruct nv10_fence_chan *fctx;\r\nstruct ttm_mem_reg *mem = &priv->bo->bo.mem;\r\nu32 start = mem->start * PAGE_SIZE;\r\nu32 limit = start + mem->size - 1;\r\nint ret = 0;\r\nfctx = chan->fence = kzalloc(sizeof(*fctx), GFP_KERNEL);\r\nif (!fctx)\r\nreturn -ENOMEM;\r\nnouveau_fence_context_new(chan, &fctx->base);\r\nfctx->base.emit = nv10_fence_emit;\r\nfctx->base.read = nv10_fence_read;\r\nfctx->base.sync = nv17_fence_sync;\r\nret = nvif_object_init(chan->object, NULL, NvSema, NV_DMA_FROM_MEMORY,\r\n&(struct nv_dma_v0) {\r\n.target = NV_DMA_V0_TARGET_VRAM,\r\n.access = NV_DMA_V0_ACCESS_RDWR,\r\n.start = start,\r\n.limit = limit,\r\n}, sizeof(struct nv_dma_v0),\r\n&fctx->sema);\r\nif (ret)\r\nnv10_fence_context_del(chan);\r\nreturn ret;\r\n}\r\nvoid\r\nnv17_fence_resume(struct nouveau_drm *drm)\r\n{\r\nstruct nv10_fence_priv *priv = drm->fence;\r\nnouveau_bo_wr32(priv->bo, 0, priv->sequence);\r\n}\r\nint\r\nnv17_fence_create(struct nouveau_drm *drm)\r\n{\r\nstruct nv10_fence_priv *priv;\r\nint ret = 0;\r\npriv = drm->fence = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->base.dtor = nv10_fence_destroy;\r\npriv->base.resume = nv17_fence_resume;\r\npriv->base.context_new = nv17_fence_context_new;\r\npriv->base.context_del = nv10_fence_context_del;\r\npriv->base.contexts = 31;\r\npriv->base.context_base = fence_context_alloc(priv->base.contexts);\r\nspin_lock_init(&priv->lock);\r\nret = nouveau_bo_new(drm->dev, 4096, 0x1000, TTM_PL_FLAG_VRAM,\r\n0, 0x0000, NULL, NULL, &priv->bo);\r\nif (!ret) {\r\nret = nouveau_bo_pin(priv->bo, TTM_PL_FLAG_VRAM, false);\r\nif (!ret) {\r\nret = nouveau_bo_map(priv->bo);\r\nif (ret)\r\nnouveau_bo_unpin(priv->bo);\r\n}\r\nif (ret)\r\nnouveau_bo_ref(NULL, &priv->bo);\r\n}\r\nif (ret) {\r\nnv10_fence_destroy(drm);\r\nreturn ret;\r\n}\r\nnouveau_bo_wr32(priv->bo, 0x000, 0x00000000);\r\nreturn ret;\r\n}
