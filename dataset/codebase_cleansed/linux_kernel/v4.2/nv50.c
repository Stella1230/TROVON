static int\r\nnv50_bar_kmap(struct nvkm_bar *bar, struct nvkm_mem *mem, u32 flags,\r\nstruct nvkm_vma *vma)\r\n{\r\nstruct nv50_bar_priv *priv = (void *)bar;\r\nint ret;\r\nret = nvkm_vm_get(priv->bar3_vm, mem->size << 12, 12, flags, vma);\r\nif (ret)\r\nreturn ret;\r\nnvkm_vm_map(vma, mem);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_bar_umap(struct nvkm_bar *bar, struct nvkm_mem *mem, u32 flags,\r\nstruct nvkm_vma *vma)\r\n{\r\nstruct nv50_bar_priv *priv = (void *)bar;\r\nint ret;\r\nret = nvkm_vm_get(priv->bar1_vm, mem->size << 12, 12, flags, vma);\r\nif (ret)\r\nreturn ret;\r\nnvkm_vm_map(vma, mem);\r\nreturn 0;\r\n}\r\nstatic void\r\nnv50_bar_unmap(struct nvkm_bar *bar, struct nvkm_vma *vma)\r\n{\r\nnvkm_vm_unmap(vma);\r\nnvkm_vm_put(vma);\r\n}\r\nstatic void\r\nnv50_bar_flush(struct nvkm_bar *bar)\r\n{\r\nstruct nv50_bar_priv *priv = (void *)bar;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nnv_wr32(priv, 0x00330c, 0x00000001);\r\nif (!nv_wait(priv, 0x00330c, 0x00000002, 0x00000000))\r\nnv_warn(priv, "flush timeout\n");\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nvoid\r\ng84_bar_flush(struct nvkm_bar *bar)\r\n{\r\nstruct nv50_bar_priv *priv = (void *)bar;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nnv_wr32(bar, 0x070000, 0x00000001);\r\nif (!nv_wait(priv, 0x070000, 0x00000002, 0x00000000))\r\nnv_warn(priv, "flush timeout\n");\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic int\r\nnv50_bar_ctor(struct nvkm_object *parent, struct nvkm_object *engine,\r\nstruct nvkm_oclass *oclass, void *data, u32 size,\r\nstruct nvkm_object **pobject)\r\n{\r\nstruct nvkm_device *device = nv_device(parent);\r\nstruct nvkm_object *heap;\r\nstruct nvkm_vm *vm;\r\nstruct nv50_bar_priv *priv;\r\nu64 start, limit;\r\nint ret;\r\nret = nvkm_bar_create(parent, engine, oclass, &priv);\r\n*pobject = nv_object(priv);\r\nif (ret)\r\nreturn ret;\r\nret = nvkm_gpuobj_new(nv_object(priv), NULL, 0x20000, 0,\r\nNVOBJ_FLAG_HEAP, &priv->mem);\r\nheap = nv_object(priv->mem);\r\nif (ret)\r\nreturn ret;\r\nret = nvkm_gpuobj_new(nv_object(priv), heap,\r\n(device->chipset == 0x50) ? 0x1400 : 0x0200,\r\n0, 0, &priv->pad);\r\nif (ret)\r\nreturn ret;\r\nret = nvkm_gpuobj_new(nv_object(priv), heap, 0x4000, 0, 0, &priv->pgd);\r\nif (ret)\r\nreturn ret;\r\nstart = 0x0100000000ULL;\r\nlimit = start + nv_device_resource_len(device, 3);\r\nret = nvkm_vm_new(device, start, limit, start, &vm);\r\nif (ret)\r\nreturn ret;\r\natomic_inc(&vm->engref[NVDEV_SUBDEV_BAR]);\r\nret = nvkm_gpuobj_new(nv_object(priv), heap,\r\n((limit-- - start) >> 12) * 8, 0x1000,\r\nNVOBJ_FLAG_ZERO_ALLOC, &vm->pgt[0].obj[0]);\r\nvm->pgt[0].refcount[0] = 1;\r\nif (ret)\r\nreturn ret;\r\nret = nvkm_vm_ref(vm, &priv->bar3_vm, priv->pgd);\r\nnvkm_vm_ref(NULL, &vm, NULL);\r\nif (ret)\r\nreturn ret;\r\nret = nvkm_gpuobj_new(nv_object(priv), heap, 24, 16, 0, &priv->bar3);\r\nif (ret)\r\nreturn ret;\r\nnv_wo32(priv->bar3, 0x00, 0x7fc00000);\r\nnv_wo32(priv->bar3, 0x04, lower_32_bits(limit));\r\nnv_wo32(priv->bar3, 0x08, lower_32_bits(start));\r\nnv_wo32(priv->bar3, 0x0c, upper_32_bits(limit) << 24 |\r\nupper_32_bits(start));\r\nnv_wo32(priv->bar3, 0x10, 0x00000000);\r\nnv_wo32(priv->bar3, 0x14, 0x00000000);\r\nstart = 0x0000000000ULL;\r\nlimit = start + nv_device_resource_len(device, 1);\r\nret = nvkm_vm_new(device, start, limit--, start, &vm);\r\nif (ret)\r\nreturn ret;\r\natomic_inc(&vm->engref[NVDEV_SUBDEV_BAR]);\r\nret = nvkm_vm_ref(vm, &priv->bar1_vm, priv->pgd);\r\nnvkm_vm_ref(NULL, &vm, NULL);\r\nif (ret)\r\nreturn ret;\r\nret = nvkm_gpuobj_new(nv_object(priv), heap, 24, 16, 0, &priv->bar1);\r\nif (ret)\r\nreturn ret;\r\nnv_wo32(priv->bar1, 0x00, 0x7fc00000);\r\nnv_wo32(priv->bar1, 0x04, lower_32_bits(limit));\r\nnv_wo32(priv->bar1, 0x08, lower_32_bits(start));\r\nnv_wo32(priv->bar1, 0x0c, upper_32_bits(limit) << 24 |\r\nupper_32_bits(start));\r\nnv_wo32(priv->bar1, 0x10, 0x00000000);\r\nnv_wo32(priv->bar1, 0x14, 0x00000000);\r\npriv->base.alloc = nvkm_bar_alloc;\r\npriv->base.kmap = nv50_bar_kmap;\r\npriv->base.umap = nv50_bar_umap;\r\npriv->base.unmap = nv50_bar_unmap;\r\nif (device->chipset == 0x50)\r\npriv->base.flush = nv50_bar_flush;\r\nelse\r\npriv->base.flush = g84_bar_flush;\r\nspin_lock_init(&priv->lock);\r\nreturn 0;\r\n}\r\nstatic void\r\nnv50_bar_dtor(struct nvkm_object *object)\r\n{\r\nstruct nv50_bar_priv *priv = (void *)object;\r\nnvkm_gpuobj_ref(NULL, &priv->bar1);\r\nnvkm_vm_ref(NULL, &priv->bar1_vm, priv->pgd);\r\nnvkm_gpuobj_ref(NULL, &priv->bar3);\r\nif (priv->bar3_vm) {\r\nnvkm_gpuobj_ref(NULL, &priv->bar3_vm->pgt[0].obj[0]);\r\nnvkm_vm_ref(NULL, &priv->bar3_vm, priv->pgd);\r\n}\r\nnvkm_gpuobj_ref(NULL, &priv->pgd);\r\nnvkm_gpuobj_ref(NULL, &priv->pad);\r\nnvkm_gpuobj_ref(NULL, &priv->mem);\r\nnvkm_bar_destroy(&priv->base);\r\n}\r\nstatic int\r\nnv50_bar_init(struct nvkm_object *object)\r\n{\r\nstruct nv50_bar_priv *priv = (void *)object;\r\nint ret, i;\r\nret = nvkm_bar_init(&priv->base);\r\nif (ret)\r\nreturn ret;\r\nnv_mask(priv, 0x000200, 0x00000100, 0x00000000);\r\nnv_mask(priv, 0x000200, 0x00000100, 0x00000100);\r\nnv_wr32(priv, 0x100c80, 0x00060001);\r\nif (!nv_wait(priv, 0x100c80, 0x00000001, 0x00000000)) {\r\nnv_error(priv, "vm flush timeout\n");\r\nreturn -EBUSY;\r\n}\r\nnv_wr32(priv, 0x001704, 0x00000000 | priv->mem->addr >> 12);\r\nnv_wr32(priv, 0x001704, 0x40000000 | priv->mem->addr >> 12);\r\nnv_wr32(priv, 0x001708, 0x80000000 | priv->bar1->node->offset >> 4);\r\nnv_wr32(priv, 0x00170c, 0x80000000 | priv->bar3->node->offset >> 4);\r\nfor (i = 0; i < 8; i++)\r\nnv_wr32(priv, 0x001900 + (i * 4), 0x00000000);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_bar_fini(struct nvkm_object *object, bool suspend)\r\n{\r\nstruct nv50_bar_priv *priv = (void *)object;\r\nreturn nvkm_bar_fini(&priv->base, suspend);\r\n}
