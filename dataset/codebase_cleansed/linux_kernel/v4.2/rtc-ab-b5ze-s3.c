static int abb5zes3_i2c_validate_chip(struct regmap *regmap)\r\n{\r\nu8 regs[ABB5ZES3_MEM_MAP_LEN];\r\nstatic const u8 mask[ABB5ZES3_MEM_MAP_LEN] = { 0x00, 0x00, 0x10, 0x00,\r\n0x80, 0xc0, 0xc0, 0xf8,\r\n0xe0, 0x00, 0x00, 0x40,\r\n0x40, 0x78, 0x00, 0x00,\r\n0xf8, 0x00, 0x88, 0x00 };\r\nint ret, i;\r\nret = regmap_bulk_read(regmap, 0, regs, ABB5ZES3_MEM_MAP_LEN);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < ABB5ZES3_MEM_MAP_LEN; ++i) {\r\nif (regs[i] & mask[i])\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int _abb5zes3_rtc_clear_alarm(struct device *dev)\r\n{\r\nstruct abb5zes3_rtc_data *data = dev_get_drvdata(dev);\r\nint ret;\r\nret = regmap_update_bits(data->regmap, ABB5ZES3_REG_CTRL2,\r\nABB5ZES3_REG_CTRL2_AF, 0);\r\nif (ret)\r\ndev_err(dev, "%s: clearing alarm failed (%d)\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int _abb5zes3_rtc_update_alarm(struct device *dev, bool enable)\r\n{\r\nstruct abb5zes3_rtc_data *data = dev_get_drvdata(dev);\r\nint ret;\r\nret = regmap_update_bits(data->regmap, ABB5ZES3_REG_CTRL1,\r\nABB5ZES3_REG_CTRL1_AIE,\r\nenable ? ABB5ZES3_REG_CTRL1_AIE : 0);\r\nif (ret)\r\ndev_err(dev, "%s: writing alarm INT failed (%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nstatic int _abb5zes3_rtc_update_timer(struct device *dev, bool enable)\r\n{\r\nstruct abb5zes3_rtc_data *data = dev_get_drvdata(dev);\r\nint ret;\r\nret = regmap_update_bits(data->regmap, ABB5ZES3_REG_CTRL2,\r\nABB5ZES3_REG_CTRL2_WTAIE,\r\nenable ? ABB5ZES3_REG_CTRL2_WTAIE : 0);\r\nif (ret)\r\ndev_err(dev, "%s: writing timer INT failed (%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nstatic int _abb5zes3_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct abb5zes3_rtc_data *data = dev_get_drvdata(dev);\r\nu8 regs[ABB5ZES3_REG_RTC_SC + ABB5ZES3_RTC_SEC_LEN];\r\nint ret;\r\nret = regmap_bulk_read(data->regmap, ABB5ZES3_REG_CTRL1, regs,\r\nsizeof(regs));\r\nif (ret) {\r\ndev_err(dev, "%s: reading RTC time failed (%d)\n",\r\n__func__, ret);\r\ngoto err;\r\n}\r\nif (regs[ABB5ZES3_REG_RTC_SC] & ABB5ZES3_REG_RTC_SC_OSC) {\r\nret = -ENODATA;\r\ngoto err;\r\n}\r\ntm->tm_sec = bcd2bin(regs[ABB5ZES3_REG_RTC_SC] & 0x7F);\r\ntm->tm_min = bcd2bin(regs[ABB5ZES3_REG_RTC_MN]);\r\nif (regs[ABB5ZES3_REG_CTRL1] & ABB5ZES3_REG_CTRL1_PM) {\r\ntm->tm_hour = bcd2bin(regs[ABB5ZES3_REG_RTC_HR] & 0x1f);\r\nif (regs[ABB5ZES3_REG_RTC_HR] & ABB5ZES3_REG_RTC_HR_PM)\r\ntm->tm_hour += 12;\r\n} else {\r\ntm->tm_hour = bcd2bin(regs[ABB5ZES3_REG_RTC_HR]);\r\n}\r\ntm->tm_mday = bcd2bin(regs[ABB5ZES3_REG_RTC_DT]);\r\ntm->tm_wday = bcd2bin(regs[ABB5ZES3_REG_RTC_DW]);\r\ntm->tm_mon = bcd2bin(regs[ABB5ZES3_REG_RTC_MO]) - 1;\r\ntm->tm_year = bcd2bin(regs[ABB5ZES3_REG_RTC_YR]) + 100;\r\nret = rtc_valid_tm(tm);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int abb5zes3_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct abb5zes3_rtc_data *data = dev_get_drvdata(dev);\r\nu8 regs[ABB5ZES3_REG_RTC_SC + ABB5ZES3_RTC_SEC_LEN];\r\nint ret;\r\nif (tm->tm_year < 100)\r\nreturn -EINVAL;\r\nregs[ABB5ZES3_REG_RTC_SC] = bin2bcd(tm->tm_sec);\r\nregs[ABB5ZES3_REG_RTC_MN] = bin2bcd(tm->tm_min);\r\nregs[ABB5ZES3_REG_RTC_HR] = bin2bcd(tm->tm_hour);\r\nregs[ABB5ZES3_REG_RTC_DT] = bin2bcd(tm->tm_mday);\r\nregs[ABB5ZES3_REG_RTC_DW] = bin2bcd(tm->tm_wday);\r\nregs[ABB5ZES3_REG_RTC_MO] = bin2bcd(tm->tm_mon + 1);\r\nregs[ABB5ZES3_REG_RTC_YR] = bin2bcd(tm->tm_year - 100);\r\nmutex_lock(&data->lock);\r\nret = regmap_bulk_write(data->regmap, ABB5ZES3_REG_RTC_SC,\r\nregs + ABB5ZES3_REG_RTC_SC,\r\nABB5ZES3_RTC_SEC_LEN);\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nstatic inline void sec_to_timer_a(u8 secs, u8 *taq, u8 *timer_a)\r\n{\r\n*taq = ABB5ZES3_REG_TIMA_CLK_TAQ1;\r\n*timer_a = secs;\r\n}\r\nstatic inline int sec_from_timer_a(u8 *secs, u8 taq, u8 timer_a)\r\n{\r\nif (taq != ABB5ZES3_REG_TIMA_CLK_TAQ1)\r\nreturn -EINVAL;\r\n*secs = timer_a;\r\nreturn 0;\r\n}\r\nstatic int _abb5zes3_rtc_read_timer(struct device *dev,\r\nstruct rtc_wkalrm *alarm)\r\n{\r\nstruct abb5zes3_rtc_data *data = dev_get_drvdata(dev);\r\nstruct rtc_time rtc_tm, *alarm_tm = &alarm->time;\r\nu8 regs[ABB5ZES3_TIMA_SEC_LEN + 1];\r\nunsigned long rtc_secs;\r\nunsigned int reg;\r\nu8 timer_secs;\r\nint ret;\r\nret = regmap_bulk_read(data->regmap, ABB5ZES3_REG_TIM_CLK, regs,\r\nABB5ZES3_TIMA_SEC_LEN + 1);\r\nif (ret) {\r\ndev_err(dev, "%s: reading Timer A section failed (%d)\n",\r\n__func__, ret);\r\ngoto err;\r\n}\r\nret = _abb5zes3_rtc_read_time(dev, &rtc_tm);\r\nif (ret)\r\ngoto err;\r\nret = rtc_tm_to_time(&rtc_tm, &rtc_secs);\r\nif (ret)\r\ngoto err;\r\nret = sec_from_timer_a(&timer_secs, regs[1], regs[2]);\r\nif (ret)\r\ngoto err;\r\nrtc_time_to_tm(rtc_secs + timer_secs, alarm_tm);\r\nret = regmap_read(data->regmap, ABB5ZES3_REG_CTRL2, &reg);\r\nif (ret) {\r\ndev_err(dev, "%s: reading ctrl reg failed (%d)\n",\r\n__func__, ret);\r\ngoto err;\r\n}\r\nalarm->enabled = !!(reg & ABB5ZES3_REG_CTRL2_WTAIE);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int _abb5zes3_rtc_read_alarm(struct device *dev,\r\nstruct rtc_wkalrm *alarm)\r\n{\r\nstruct abb5zes3_rtc_data *data = dev_get_drvdata(dev);\r\nstruct rtc_time rtc_tm, *alarm_tm = &alarm->time;\r\nunsigned long rtc_secs, alarm_secs;\r\nu8 regs[ABB5ZES3_ALRM_SEC_LEN];\r\nunsigned int reg;\r\nint ret;\r\nret = regmap_bulk_read(data->regmap, ABB5ZES3_REG_ALRM_MN, regs,\r\nABB5ZES3_ALRM_SEC_LEN);\r\nif (ret) {\r\ndev_err(dev, "%s: reading alarm section failed (%d)\n",\r\n__func__, ret);\r\ngoto err;\r\n}\r\nalarm_tm->tm_sec = 0;\r\nalarm_tm->tm_min = bcd2bin(regs[0] & 0x7f);\r\nalarm_tm->tm_hour = bcd2bin(regs[1] & 0x3f);\r\nalarm_tm->tm_mday = bcd2bin(regs[2] & 0x3f);\r\nalarm_tm->tm_wday = -1;\r\nret = _abb5zes3_rtc_read_time(dev, &rtc_tm);\r\nif (ret)\r\ngoto err;\r\nalarm_tm->tm_year = rtc_tm.tm_year;\r\nalarm_tm->tm_mon = rtc_tm.tm_mon;\r\nret = rtc_tm_to_time(&rtc_tm, &rtc_secs);\r\nif (ret)\r\ngoto err;\r\nret = rtc_tm_to_time(alarm_tm, &alarm_secs);\r\nif (ret)\r\ngoto err;\r\nif (alarm_secs < rtc_secs) {\r\nif (alarm_tm->tm_mon == 11) {\r\nalarm_tm->tm_mon = 0;\r\nalarm_tm->tm_year += 1;\r\n} else {\r\nalarm_tm->tm_mon += 1;\r\n}\r\n}\r\nret = regmap_read(data->regmap, ABB5ZES3_REG_CTRL1, &reg);\r\nif (ret) {\r\ndev_err(dev, "%s: reading ctrl reg failed (%d)\n",\r\n__func__, ret);\r\ngoto err;\r\n}\r\nalarm->enabled = !!(reg & ABB5ZES3_REG_CTRL1_AIE);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int abb5zes3_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nstruct abb5zes3_rtc_data *data = dev_get_drvdata(dev);\r\nint ret;\r\nmutex_lock(&data->lock);\r\nif (data->timer_alarm)\r\nret = _abb5zes3_rtc_read_timer(dev, alarm);\r\nelse\r\nret = _abb5zes3_rtc_read_alarm(dev, alarm);\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nstatic int _abb5zes3_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nstruct abb5zes3_rtc_data *data = dev_get_drvdata(dev);\r\nstruct rtc_time *alarm_tm = &alarm->time;\r\nunsigned long rtc_secs, alarm_secs;\r\nu8 regs[ABB5ZES3_ALRM_SEC_LEN];\r\nstruct rtc_time rtc_tm;\r\nint ret, enable = 1;\r\nret = _abb5zes3_rtc_read_time(dev, &rtc_tm);\r\nif (ret)\r\ngoto err;\r\nret = rtc_tm_to_time(&rtc_tm, &rtc_secs);\r\nif (ret)\r\ngoto err;\r\nret = rtc_tm_to_time(alarm_tm, &alarm_secs);\r\nif (ret)\r\ngoto err;\r\nif (!alarm->enabled || alarm_secs <= rtc_secs) {\r\nenable = 0;\r\n} else {\r\nif (rtc_tm.tm_mon == 11) {\r\nrtc_tm.tm_mon = 0;\r\nrtc_tm.tm_year += 1;\r\n} else {\r\nrtc_tm.tm_mon += 1;\r\n}\r\nret = rtc_tm_to_time(&rtc_tm, &rtc_secs);\r\nif (ret)\r\ngoto err;\r\nif (alarm_secs > rtc_secs) {\r\ndev_err(dev, "%s: alarm maximum is one month in the "\r\n"future (%d)\n", __func__, ret);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\n}\r\nregs[0] = bin2bcd(alarm_tm->tm_min) & 0x7f;\r\nregs[1] = bin2bcd(alarm_tm->tm_hour) & 0x3f;\r\nregs[2] = bin2bcd(alarm_tm->tm_mday) & 0x3f;\r\nregs[3] = ABB5ZES3_REG_ALRM_DW_AE;\r\nret = regmap_bulk_write(data->regmap, ABB5ZES3_REG_ALRM_MN, regs,\r\nABB5ZES3_ALRM_SEC_LEN);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: writing ALARM section failed (%d)\n",\r\n__func__, ret);\r\ngoto err;\r\n}\r\ndata->timer_alarm = 0;\r\nret = _abb5zes3_rtc_update_alarm(dev, enable);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int _abb5zes3_rtc_set_timer(struct device *dev, struct rtc_wkalrm *alarm,\r\nu8 secs)\r\n{\r\nstruct abb5zes3_rtc_data *data = dev_get_drvdata(dev);\r\nu8 regs[ABB5ZES3_TIMA_SEC_LEN];\r\nu8 mask = ABB5ZES3_REG_TIM_CLK_TAC0 | ABB5ZES3_REG_TIM_CLK_TAC1;\r\nint ret = 0;\r\nsec_to_timer_a(secs, &regs[0], &regs[1]);\r\nret = regmap_bulk_write(data->regmap, ABB5ZES3_REG_TIMA_CLK, regs,\r\nABB5ZES3_TIMA_SEC_LEN);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: writing timer section failed\n", __func__);\r\ngoto err;\r\n}\r\nret = regmap_update_bits(data->regmap, ABB5ZES3_REG_TIM_CLK,\r\nmask, ABB5ZES3_REG_TIM_CLK_TAC1);\r\nif (ret)\r\ndev_err(dev, "%s: failed to update timer\n", __func__);\r\ndata->timer_alarm = 1;\r\nret = _abb5zes3_rtc_update_timer(dev, alarm->enabled);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int abb5zes3_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nstruct abb5zes3_rtc_data *data = dev_get_drvdata(dev);\r\nstruct rtc_time *alarm_tm = &alarm->time;\r\nunsigned long rtc_secs, alarm_secs;\r\nstruct rtc_time rtc_tm;\r\nint ret;\r\nmutex_lock(&data->lock);\r\nret = _abb5zes3_rtc_read_time(dev, &rtc_tm);\r\nif (ret)\r\ngoto err;\r\nret = rtc_tm_to_time(&rtc_tm, &rtc_secs);\r\nif (ret)\r\ngoto err;\r\nret = rtc_tm_to_time(alarm_tm, &alarm_secs);\r\nif (ret)\r\ngoto err;\r\nret = _abb5zes3_rtc_update_alarm(dev, false);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: unable to disable alarm (%d)\n", __func__,\r\nret);\r\ngoto err;\r\n}\r\nret = _abb5zes3_rtc_update_timer(dev, false);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: unable to disable timer (%d)\n", __func__,\r\nret);\r\ngoto err;\r\n}\r\ndata->timer_alarm = 0;\r\nif ((alarm_secs > rtc_secs) && ((alarm_secs - rtc_secs) <= 240))\r\nret = _abb5zes3_rtc_set_timer(dev, alarm,\r\nalarm_secs - rtc_secs);\r\nelse\r\nret = _abb5zes3_rtc_set_alarm(dev, alarm);\r\nerr:\r\nmutex_unlock(&data->lock);\r\nif (ret)\r\ndev_err(dev, "%s: unable to configure alarm (%d)\n", __func__,\r\nret);\r\nreturn ret;\r\n}\r\nstatic inline int _abb5zes3_rtc_battery_low_irq_enable(struct regmap *regmap,\r\nbool enable)\r\n{\r\nreturn regmap_update_bits(regmap, ABB5ZES3_REG_CTRL3,\r\nABB5ZES3_REG_CTRL3_BLIE,\r\nenable ? ABB5ZES3_REG_CTRL3_BLIE : 0);\r\n}\r\nstatic int abb5zes3_rtc_check_setup(struct device *dev)\r\n{\r\nstruct abb5zes3_rtc_data *data = dev_get_drvdata(dev);\r\nstruct regmap *regmap = data->regmap;\r\nunsigned int reg;\r\nint ret;\r\nu8 mask;\r\nmask = (ABB5ZES3_REG_TIM_CLK_TBC | ABB5ZES3_REG_TIM_CLK_TAC0 |\r\nABB5ZES3_REG_TIM_CLK_TAC1 | ABB5ZES3_REG_TIM_CLK_COF0 |\r\nABB5ZES3_REG_TIM_CLK_COF1 | ABB5ZES3_REG_TIM_CLK_COF2 |\r\nABB5ZES3_REG_TIM_CLK_TBM | ABB5ZES3_REG_TIM_CLK_TAM);\r\nret = regmap_update_bits(regmap, ABB5ZES3_REG_TIM_CLK, mask,\r\nABB5ZES3_REG_TIM_CLK_COF0 | ABB5ZES3_REG_TIM_CLK_COF1 |\r\nABB5ZES3_REG_TIM_CLK_COF2);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: unable to initialize clkout register (%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nmask = (ABB5ZES3_REG_ALRM_MN_AE | ABB5ZES3_REG_ALRM_HR_AE |\r\nABB5ZES3_REG_ALRM_DT_AE | ABB5ZES3_REG_ALRM_DW_AE);\r\nret = regmap_update_bits(regmap, ABB5ZES3_REG_CTRL2, mask, mask);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: unable to disable alarm setting (%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nmask = (ABB5ZES3_REG_CTRL1_CIE | ABB5ZES3_REG_CTRL1_AIE |\r\nABB5ZES3_REG_CTRL1_SIE | ABB5ZES3_REG_CTRL1_PM |\r\nABB5ZES3_REG_CTRL1_CAP | ABB5ZES3_REG_CTRL1_STOP);\r\nret = regmap_update_bits(regmap, ABB5ZES3_REG_CTRL1, mask, 0);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: unable to initialize CTRL1 register (%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nmask = (ABB5ZES3_REG_CTRL2_CTBIE | ABB5ZES3_REG_CTRL2_CTAIE |\r\nABB5ZES3_REG_CTRL2_WTAIE | ABB5ZES3_REG_CTRL2_AF |\r\nABB5ZES3_REG_CTRL2_SF | ABB5ZES3_REG_CTRL2_CTBF |\r\nABB5ZES3_REG_CTRL2_CTAF);\r\nret = regmap_update_bits(regmap, ABB5ZES3_REG_CTRL2, mask, 0);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: unable to initialize CTRL2 register (%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nmask = (ABB5ZES3_REG_CTRL3_PM0 | ABB5ZES3_REG_CTRL3_PM1 |\r\nABB5ZES3_REG_CTRL3_PM2 | ABB5ZES3_REG_CTRL3_BLIE |\r\nABB5ZES3_REG_CTRL3_BSIE| ABB5ZES3_REG_CTRL3_BSF);\r\nret = regmap_update_bits(regmap, ABB5ZES3_REG_CTRL3, mask, 0);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: unable to initialize CTRL3 register (%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nret = regmap_read(regmap, ABB5ZES3_REG_RTC_SC, &reg);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: unable to read osc. integrity flag (%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nif (reg & ABB5ZES3_REG_RTC_SC_OSC) {\r\ndev_err(dev, "clock integrity not guaranteed. Osc. has stopped "\r\n"or has been interrupted.\n");\r\ndev_err(dev, "change battery (if not already done) and "\r\n"then set time to reset osc. failure flag.\n");\r\n}\r\nret = regmap_read(regmap, ABB5ZES3_REG_CTRL3, &reg);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: unable to read battery low flag (%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\ndata->battery_low = reg & ABB5ZES3_REG_CTRL3_BLF;\r\nif (data->battery_low) {\r\ndev_err(dev, "RTC battery is low; please, consider "\r\n"changing it!\n");\r\nret = _abb5zes3_rtc_battery_low_irq_enable(regmap, false);\r\nif (ret)\r\ndev_err(dev, "%s: disabling battery low interrupt "\r\n"generation failed (%d)\n", __func__, ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic int abb5zes3_rtc_alarm_irq_enable(struct device *dev,\r\nunsigned int enable)\r\n{\r\nstruct abb5zes3_rtc_data *rtc_data = dev_get_drvdata(dev);\r\nint ret = 0;\r\nif (rtc_data->irq) {\r\nmutex_lock(&rtc_data->lock);\r\nif (rtc_data->timer_alarm)\r\nret = _abb5zes3_rtc_update_timer(dev, enable);\r\nelse\r\nret = _abb5zes3_rtc_update_alarm(dev, enable);\r\nmutex_unlock(&rtc_data->lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic irqreturn_t _abb5zes3_rtc_interrupt(int irq, void *data)\r\n{\r\nstruct i2c_client *client = data;\r\nstruct device *dev = &client->dev;\r\nstruct abb5zes3_rtc_data *rtc_data = dev_get_drvdata(dev);\r\nstruct rtc_device *rtc = rtc_data->rtc;\r\nu8 regs[ABB5ZES3_CTRL_SEC_LEN];\r\nint ret, handled = IRQ_NONE;\r\nret = regmap_bulk_read(rtc_data->regmap, 0, regs,\r\nABB5ZES3_CTRL_SEC_LEN);\r\nif (ret) {\r\ndev_err(dev, "%s: unable to read control section (%d)!\n",\r\n__func__, ret);\r\nreturn handled;\r\n}\r\nif (regs[ABB5ZES3_REG_CTRL3] & ABB5ZES3_REG_CTRL3_BLF) {\r\ndev_err(dev, "RTC battery is low; please change it!\n");\r\n_abb5zes3_rtc_battery_low_irq_enable(rtc_data->regmap, false);\r\nhandled = IRQ_HANDLED;\r\n}\r\nif (regs[ABB5ZES3_REG_CTRL2] & ABB5ZES3_REG_CTRL2_AF) {\r\ndev_dbg(dev, "RTC alarm!\n");\r\nrtc_update_irq(rtc, 1, RTC_IRQF | RTC_AF);\r\n_abb5zes3_rtc_clear_alarm(dev);\r\n_abb5zes3_rtc_update_alarm(dev, 0);\r\nhandled = IRQ_HANDLED;\r\n}\r\nif (regs[ABB5ZES3_REG_CTRL2] & ABB5ZES3_REG_CTRL2_WTAF) {\r\ndev_dbg(dev, "RTC timer!\n");\r\nrtc_update_irq(rtc, 1, RTC_IRQF | RTC_AF);\r\n_abb5zes3_rtc_update_timer(dev, 0);\r\nrtc_data->timer_alarm = 0;\r\nhandled = IRQ_HANDLED;\r\n}\r\nreturn handled;\r\n}\r\nstatic int abb5zes3_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct abb5zes3_rtc_data *data = NULL;\r\nstruct device *dev = &client->dev;\r\nstruct regmap *regmap;\r\nint ret;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C |\r\nI2C_FUNC_SMBUS_BYTE_DATA |\r\nI2C_FUNC_SMBUS_I2C_BLOCK)) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nregmap = devm_regmap_init_i2c(client, &abb5zes3_rtc_regmap_config);\r\nif (IS_ERR(regmap)) {\r\nret = PTR_ERR(regmap);\r\ndev_err(dev, "%s: regmap allocation failed: %d\n",\r\n__func__, ret);\r\ngoto err;\r\n}\r\nret = abb5zes3_i2c_validate_chip(regmap);\r\nif (ret)\r\ngoto err;\r\ndata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\r\nif (!data) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nmutex_init(&data->lock);\r\ndata->regmap = regmap;\r\ndev_set_drvdata(dev, data);\r\nret = abb5zes3_rtc_check_setup(dev);\r\nif (ret)\r\ngoto err;\r\nif (client->irq > 0) {\r\nret = devm_request_threaded_irq(dev, client->irq, NULL,\r\n_abb5zes3_rtc_interrupt,\r\nIRQF_SHARED|IRQF_ONESHOT,\r\nDRV_NAME, client);\r\nif (!ret) {\r\ndevice_init_wakeup(dev, true);\r\ndata->irq = client->irq;\r\ndev_dbg(dev, "%s: irq %d used by RTC\n", __func__,\r\nclient->irq);\r\n} else {\r\ndev_err(dev, "%s: irq %d unavailable (%d)\n",\r\n__func__, client->irq, ret);\r\ngoto err;\r\n}\r\n}\r\ndata->rtc = devm_rtc_device_register(dev, DRV_NAME, &rtc_ops,\r\nTHIS_MODULE);\r\nret = PTR_ERR_OR_ZERO(data->rtc);\r\nif (ret) {\r\ndev_err(dev, "%s: unable to register RTC device (%d)\n",\r\n__func__, ret);\r\ngoto err;\r\n}\r\nif (!data->battery_low && data->irq) {\r\nret = _abb5zes3_rtc_battery_low_irq_enable(regmap, true);\r\nif (ret) {\r\ndev_err(dev, "%s: enabling battery low interrupt "\r\n"generation failed (%d)\n", __func__, ret);\r\ngoto err;\r\n}\r\n}\r\nerr:\r\nif (ret && data && data->irq)\r\ndevice_init_wakeup(dev, false);\r\nreturn ret;\r\n}\r\nstatic int abb5zes3_remove(struct i2c_client *client)\r\n{\r\nstruct abb5zes3_rtc_data *rtc_data = dev_get_drvdata(&client->dev);\r\nif (rtc_data->irq > 0)\r\ndevice_init_wakeup(&client->dev, false);\r\nreturn 0;\r\n}\r\nstatic int abb5zes3_rtc_suspend(struct device *dev)\r\n{\r\nstruct abb5zes3_rtc_data *rtc_data = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev))\r\nreturn enable_irq_wake(rtc_data->irq);\r\nreturn 0;\r\n}\r\nstatic int abb5zes3_rtc_resume(struct device *dev)\r\n{\r\nstruct abb5zes3_rtc_data *rtc_data = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev))\r\nreturn disable_irq_wake(rtc_data->irq);\r\nreturn 0;\r\n}
