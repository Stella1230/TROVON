void ast_set_index_reg_mask(struct ast_private *ast,\r\nuint32_t base, uint8_t index,\r\nuint8_t mask, uint8_t val)\r\n{\r\nu8 tmp;\r\nast_io_write8(ast, base, index);\r\ntmp = (ast_io_read8(ast, base + 1) & mask) | val;\r\nast_set_index_reg(ast, base, index, tmp);\r\n}\r\nuint8_t ast_get_index_reg(struct ast_private *ast,\r\nuint32_t base, uint8_t index)\r\n{\r\nuint8_t ret;\r\nast_io_write8(ast, base, index);\r\nret = ast_io_read8(ast, base + 1);\r\nreturn ret;\r\n}\r\nuint8_t ast_get_index_reg_mask(struct ast_private *ast,\r\nuint32_t base, uint8_t index, uint8_t mask)\r\n{\r\nuint8_t ret;\r\nast_io_write8(ast, base, index);\r\nret = ast_io_read8(ast, base + 1) & mask;\r\nreturn ret;\r\n}\r\nstatic int ast_detect_chip(struct drm_device *dev, bool *need_post)\r\n{\r\nstruct ast_private *ast = dev->dev_private;\r\nuint32_t data, jreg;\r\nast_open_key(ast);\r\nif (dev->pdev->device == PCI_CHIP_AST1180) {\r\nast->chip = AST1100;\r\nDRM_INFO("AST 1180 detected\n");\r\n} else {\r\nif (dev->pdev->revision >= 0x30) {\r\nast->chip = AST2400;\r\nDRM_INFO("AST 2400 detected\n");\r\n} else if (dev->pdev->revision >= 0x20) {\r\nast->chip = AST2300;\r\nDRM_INFO("AST 2300 detected\n");\r\n} else if (dev->pdev->revision >= 0x10) {\r\nuint32_t data;\r\nast_write32(ast, 0xf004, 0x1e6e0000);\r\nast_write32(ast, 0xf000, 0x1);\r\ndata = ast_read32(ast, 0x1207c);\r\nswitch (data & 0x0300) {\r\ncase 0x0200:\r\nast->chip = AST1100;\r\nDRM_INFO("AST 1100 detected\n");\r\nbreak;\r\ncase 0x0100:\r\nast->chip = AST2200;\r\nDRM_INFO("AST 2200 detected\n");\r\nbreak;\r\ncase 0x0000:\r\nast->chip = AST2150;\r\nDRM_INFO("AST 2150 detected\n");\r\nbreak;\r\ndefault:\r\nast->chip = AST2100;\r\nDRM_INFO("AST 2100 detected\n");\r\nbreak;\r\n}\r\nast->vga2_clone = false;\r\n} else {\r\nast->chip = AST2000;\r\nDRM_INFO("AST 2000 detected\n");\r\n}\r\n}\r\nif (!ast_is_vga_enabled(dev)) {\r\nast_enable_vga(dev);\r\nast_enable_mmio(dev);\r\nDRM_INFO("VGA not enabled on entry, requesting chip POST\n");\r\n*need_post = true;\r\n} else\r\n*need_post = false;\r\nswitch (ast->chip) {\r\ncase AST1180:\r\nast->support_wide_screen = true;\r\nbreak;\r\ncase AST2000:\r\nast->support_wide_screen = false;\r\nbreak;\r\ndefault:\r\njreg = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd0, 0xff);\r\nif (!(jreg & 0x80))\r\nast->support_wide_screen = true;\r\nelse if (jreg & 0x01)\r\nast->support_wide_screen = true;\r\nelse {\r\nast->support_wide_screen = false;\r\nast_write32(ast, 0xf004, 0x1e6e0000);\r\nast_write32(ast, 0xf000, 0x1);\r\ndata = ast_read32(ast, 0x1207c);\r\ndata &= 0x300;\r\nif (ast->chip == AST2300 && data == 0x0)\r\nast->support_wide_screen = true;\r\nif (ast->chip == AST2400 && data == 0x100)\r\nast->support_wide_screen = true;\r\n}\r\nbreak;\r\n}\r\nast->tx_chip_type = AST_TX_NONE;\r\nif (!*need_post) {\r\njreg = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xa3, 0xff);\r\nif (jreg & 0x80)\r\nast->tx_chip_type = AST_TX_SIL164;\r\n}\r\nif ((ast->chip == AST2300) || (ast->chip == AST2400)) {\r\njreg = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd1, 0xff);\r\nswitch (jreg) {\r\ncase 0x04:\r\nast->tx_chip_type = AST_TX_SIL164;\r\nbreak;\r\ncase 0x08:\r\nast->dp501_fw_addr = kzalloc(32*1024, GFP_KERNEL);\r\nif (ast->dp501_fw_addr) {\r\nif (ast_backup_fw(dev, ast->dp501_fw_addr, 32*1024)) {\r\nkfree(ast->dp501_fw_addr);\r\nast->dp501_fw_addr = NULL;\r\n}\r\n}\r\ncase 0x0c:\r\nast->tx_chip_type = AST_TX_DP501;\r\n}\r\n}\r\nswitch(ast->tx_chip_type) {\r\ncase AST_TX_SIL164:\r\nDRM_INFO("Using Sil164 TMDS transmitter\n");\r\nbreak;\r\ncase AST_TX_DP501:\r\nDRM_INFO("Using DP501 DisplayPort transmitter\n");\r\nbreak;\r\ndefault:\r\nDRM_INFO("Analog VGA only\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int ast_get_dram_info(struct drm_device *dev)\r\n{\r\nstruct ast_private *ast = dev->dev_private;\r\nuint32_t data, data2;\r\nuint32_t denum, num, div, ref_pll;\r\nast_write32(ast, 0xf004, 0x1e6e0000);\r\nast_write32(ast, 0xf000, 0x1);\r\nast_write32(ast, 0x10000, 0xfc600309);\r\ndo {\r\n;\r\n} while (ast_read32(ast, 0x10000) != 0x01);\r\ndata = ast_read32(ast, 0x10004);\r\nif (data & 0x400)\r\nast->dram_bus_width = 16;\r\nelse\r\nast->dram_bus_width = 32;\r\nif (ast->chip == AST2300 || ast->chip == AST2400) {\r\nswitch (data & 0x03) {\r\ncase 0:\r\nast->dram_type = AST_DRAM_512Mx16;\r\nbreak;\r\ndefault:\r\ncase 1:\r\nast->dram_type = AST_DRAM_1Gx16;\r\nbreak;\r\ncase 2:\r\nast->dram_type = AST_DRAM_2Gx16;\r\nbreak;\r\ncase 3:\r\nast->dram_type = AST_DRAM_4Gx16;\r\nbreak;\r\n}\r\n} else {\r\nswitch (data & 0x0c) {\r\ncase 0:\r\ncase 4:\r\nast->dram_type = AST_DRAM_512Mx16;\r\nbreak;\r\ncase 8:\r\nif (data & 0x40)\r\nast->dram_type = AST_DRAM_1Gx16;\r\nelse\r\nast->dram_type = AST_DRAM_512Mx32;\r\nbreak;\r\ncase 0xc:\r\nast->dram_type = AST_DRAM_1Gx32;\r\nbreak;\r\n}\r\n}\r\ndata = ast_read32(ast, 0x10120);\r\ndata2 = ast_read32(ast, 0x10170);\r\nif (data2 & 0x2000)\r\nref_pll = 14318;\r\nelse\r\nref_pll = 12000;\r\ndenum = data & 0x1f;\r\nnum = (data & 0x3fe0) >> 5;\r\ndata = (data & 0xc000) >> 14;\r\nswitch (data) {\r\ncase 3:\r\ndiv = 0x4;\r\nbreak;\r\ncase 2:\r\ncase 1:\r\ndiv = 0x2;\r\nbreak;\r\ndefault:\r\ndiv = 0x1;\r\nbreak;\r\n}\r\nast->mclk = ref_pll * (num + 2) / (denum + 2) * (div * 1000);\r\nreturn 0;\r\n}\r\nstatic void ast_user_framebuffer_destroy(struct drm_framebuffer *fb)\r\n{\r\nstruct ast_framebuffer *ast_fb = to_ast_framebuffer(fb);\r\nif (ast_fb->obj)\r\ndrm_gem_object_unreference_unlocked(ast_fb->obj);\r\ndrm_framebuffer_cleanup(fb);\r\nkfree(fb);\r\n}\r\nint ast_framebuffer_init(struct drm_device *dev,\r\nstruct ast_framebuffer *ast_fb,\r\nstruct drm_mode_fb_cmd2 *mode_cmd,\r\nstruct drm_gem_object *obj)\r\n{\r\nint ret;\r\ndrm_helper_mode_fill_fb_struct(&ast_fb->base, mode_cmd);\r\nast_fb->obj = obj;\r\nret = drm_framebuffer_init(dev, &ast_fb->base, &ast_fb_funcs);\r\nif (ret) {\r\nDRM_ERROR("framebuffer init failed %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct drm_framebuffer *\r\nast_user_framebuffer_create(struct drm_device *dev,\r\nstruct drm_file *filp,\r\nstruct drm_mode_fb_cmd2 *mode_cmd)\r\n{\r\nstruct drm_gem_object *obj;\r\nstruct ast_framebuffer *ast_fb;\r\nint ret;\r\nobj = drm_gem_object_lookup(dev, filp, mode_cmd->handles[0]);\r\nif (obj == NULL)\r\nreturn ERR_PTR(-ENOENT);\r\nast_fb = kzalloc(sizeof(*ast_fb), GFP_KERNEL);\r\nif (!ast_fb) {\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nret = ast_framebuffer_init(dev, ast_fb, mode_cmd, obj);\r\nif (ret) {\r\ndrm_gem_object_unreference_unlocked(obj);\r\nkfree(ast_fb);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn &ast_fb->base;\r\n}\r\nstatic u32 ast_get_vram_info(struct drm_device *dev)\r\n{\r\nstruct ast_private *ast = dev->dev_private;\r\nu8 jreg;\r\nu32 vram_size;\r\nast_open_key(ast);\r\nvram_size = AST_VIDMEM_DEFAULT_SIZE;\r\njreg = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xaa, 0xff);\r\nswitch (jreg & 3) {\r\ncase 0: vram_size = AST_VIDMEM_SIZE_8M; break;\r\ncase 1: vram_size = AST_VIDMEM_SIZE_16M; break;\r\ncase 2: vram_size = AST_VIDMEM_SIZE_32M; break;\r\ncase 3: vram_size = AST_VIDMEM_SIZE_64M; break;\r\n}\r\njreg = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x99, 0xff);\r\nswitch (jreg & 0x03) {\r\ncase 1:\r\nvram_size -= 0x100000;\r\nbreak;\r\ncase 2:\r\nvram_size -= 0x200000;\r\nbreak;\r\ncase 3:\r\nvram_size -= 0x400000;\r\nbreak;\r\n}\r\nreturn vram_size;\r\n}\r\nint ast_driver_load(struct drm_device *dev, unsigned long flags)\r\n{\r\nstruct ast_private *ast;\r\nbool need_post;\r\nint ret = 0;\r\nast = kzalloc(sizeof(struct ast_private), GFP_KERNEL);\r\nif (!ast)\r\nreturn -ENOMEM;\r\ndev->dev_private = ast;\r\nast->dev = dev;\r\nast->regs = pci_iomap(dev->pdev, 1, 0);\r\nif (!ast->regs) {\r\nret = -EIO;\r\ngoto out_free;\r\n}\r\nif (!(pci_resource_flags(dev->pdev, 2) & IORESOURCE_IO)) {\r\nDRM_INFO("platform has no IO space, trying MMIO\n");\r\nast->ioregs = ast->regs + AST_IO_MM_OFFSET;\r\n}\r\nif (!ast->ioregs) {\r\nast->ioregs = pci_iomap(dev->pdev, 2, 0);\r\nif (!ast->ioregs) {\r\nret = -EIO;\r\ngoto out_free;\r\n}\r\n}\r\nast_detect_chip(dev, &need_post);\r\nif (ast->chip != AST1180) {\r\nast_get_dram_info(dev);\r\nast->vram_size = ast_get_vram_info(dev);\r\nDRM_INFO("dram %d %d %d %08x\n", ast->mclk, ast->dram_type, ast->dram_bus_width, ast->vram_size);\r\n}\r\nif (need_post)\r\nast_post_gpu(dev);\r\nret = ast_mm_init(ast);\r\nif (ret)\r\ngoto out_free;\r\ndrm_mode_config_init(dev);\r\ndev->mode_config.funcs = (void *)&ast_mode_funcs;\r\ndev->mode_config.min_width = 0;\r\ndev->mode_config.min_height = 0;\r\ndev->mode_config.preferred_depth = 24;\r\ndev->mode_config.prefer_shadow = 1;\r\nif (ast->chip == AST2100 ||\r\nast->chip == AST2200 ||\r\nast->chip == AST2300 ||\r\nast->chip == AST2400 ||\r\nast->chip == AST1180) {\r\ndev->mode_config.max_width = 1920;\r\ndev->mode_config.max_height = 2048;\r\n} else {\r\ndev->mode_config.max_width = 1600;\r\ndev->mode_config.max_height = 1200;\r\n}\r\nret = ast_mode_init(dev);\r\nif (ret)\r\ngoto out_free;\r\nret = ast_fbdev_init(dev);\r\nif (ret)\r\ngoto out_free;\r\nreturn 0;\r\nout_free:\r\nkfree(ast);\r\ndev->dev_private = NULL;\r\nreturn ret;\r\n}\r\nint ast_driver_unload(struct drm_device *dev)\r\n{\r\nstruct ast_private *ast = dev->dev_private;\r\nkfree(ast->dp501_fw_addr);\r\nast_mode_fini(dev);\r\nast_fbdev_fini(dev);\r\ndrm_mode_config_cleanup(dev);\r\nast_mm_fini(ast);\r\npci_iounmap(dev->pdev, ast->ioregs);\r\npci_iounmap(dev->pdev, ast->regs);\r\nkfree(ast);\r\nreturn 0;\r\n}\r\nint ast_gem_create(struct drm_device *dev,\r\nu32 size, bool iskernel,\r\nstruct drm_gem_object **obj)\r\n{\r\nstruct ast_bo *astbo;\r\nint ret;\r\n*obj = NULL;\r\nsize = roundup(size, PAGE_SIZE);\r\nif (size == 0)\r\nreturn -EINVAL;\r\nret = ast_bo_create(dev, size, 0, 0, &astbo);\r\nif (ret) {\r\nif (ret != -ERESTARTSYS)\r\nDRM_ERROR("failed to allocate GEM object\n");\r\nreturn ret;\r\n}\r\n*obj = &astbo->gem;\r\nreturn 0;\r\n}\r\nint ast_dumb_create(struct drm_file *file,\r\nstruct drm_device *dev,\r\nstruct drm_mode_create_dumb *args)\r\n{\r\nint ret;\r\nstruct drm_gem_object *gobj;\r\nu32 handle;\r\nargs->pitch = args->width * ((args->bpp + 7) / 8);\r\nargs->size = args->pitch * args->height;\r\nret = ast_gem_create(dev, args->size, false,\r\n&gobj);\r\nif (ret)\r\nreturn ret;\r\nret = drm_gem_handle_create(file, gobj, &handle);\r\ndrm_gem_object_unreference_unlocked(gobj);\r\nif (ret)\r\nreturn ret;\r\nargs->handle = handle;\r\nreturn 0;\r\n}\r\nstatic void ast_bo_unref(struct ast_bo **bo)\r\n{\r\nstruct ttm_buffer_object *tbo;\r\nif ((*bo) == NULL)\r\nreturn;\r\ntbo = &((*bo)->bo);\r\nttm_bo_unref(&tbo);\r\n*bo = NULL;\r\n}\r\nvoid ast_gem_free_object(struct drm_gem_object *obj)\r\n{\r\nstruct ast_bo *ast_bo = gem_to_ast_bo(obj);\r\nast_bo_unref(&ast_bo);\r\n}\r\nstatic inline u64 ast_bo_mmap_offset(struct ast_bo *bo)\r\n{\r\nreturn drm_vma_node_offset_addr(&bo->bo.vma_node);\r\n}\r\nint\r\nast_dumb_mmap_offset(struct drm_file *file,\r\nstruct drm_device *dev,\r\nuint32_t handle,\r\nuint64_t *offset)\r\n{\r\nstruct drm_gem_object *obj;\r\nint ret;\r\nstruct ast_bo *bo;\r\nmutex_lock(&dev->struct_mutex);\r\nobj = drm_gem_object_lookup(dev, file, handle);\r\nif (obj == NULL) {\r\nret = -ENOENT;\r\ngoto out_unlock;\r\n}\r\nbo = gem_to_ast_bo(obj);\r\n*offset = ast_bo_mmap_offset(bo);\r\ndrm_gem_object_unreference(obj);\r\nret = 0;\r\nout_unlock:\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn ret;\r\n}
