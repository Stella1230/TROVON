static inline u32 vnet_tx_dring_avail(struct vio_dring_state *dr)\r\n{\r\nreturn vio_dring_avail(dr, VNET_TX_RING_SIZE);\r\n}\r\nstatic int vnet_handle_unknown(struct vnet_port *port, void *arg)\r\n{\r\nstruct vio_msg_tag *pkt = arg;\r\npr_err("Received unknown msg [%02x:%02x:%04x:%08x]\n",\r\npkt->type, pkt->stype, pkt->stype_env, pkt->sid);\r\npr_err("Resetting connection\n");\r\nldc_disconnect(port->vio.lp);\r\nreturn -ECONNRESET;\r\n}\r\nstatic int vnet_send_attr(struct vio_driver_state *vio)\r\n{\r\nstruct vnet_port *port = to_vnet_port(vio);\r\nstruct net_device *dev = port->vp->dev;\r\nstruct vio_net_attr_info pkt;\r\nint framelen = ETH_FRAME_LEN;\r\nint i, err;\r\nerr = vnet_port_alloc_tx_ring(to_vnet_port(vio));\r\nif (err)\r\nreturn err;\r\nmemset(&pkt, 0, sizeof(pkt));\r\npkt.tag.type = VIO_TYPE_CTRL;\r\npkt.tag.stype = VIO_SUBTYPE_INFO;\r\npkt.tag.stype_env = VIO_ATTR_INFO;\r\npkt.tag.sid = vio_send_sid(vio);\r\nif (vio_version_before(vio, 1, 2))\r\npkt.xfer_mode = VIO_DRING_MODE;\r\nelse\r\npkt.xfer_mode = VIO_NEW_DRING_MODE;\r\npkt.addr_type = VNET_ADDR_ETHERMAC;\r\npkt.ack_freq = 0;\r\nfor (i = 0; i < 6; i++)\r\npkt.addr |= (u64)dev->dev_addr[i] << ((5 - i) * 8);\r\nif (vio_version_after(vio, 1, 3)) {\r\nif (port->rmtu) {\r\nport->rmtu = min(VNET_MAXPACKET, port->rmtu);\r\npkt.mtu = port->rmtu;\r\n} else {\r\nport->rmtu = VNET_MAXPACKET;\r\npkt.mtu = port->rmtu;\r\n}\r\nif (vio_version_after_eq(vio, 1, 6))\r\npkt.options = VIO_TX_DRING;\r\n} else if (vio_version_before(vio, 1, 3)) {\r\npkt.mtu = framelen;\r\n} else {\r\npkt.mtu = framelen + VLAN_HLEN;\r\n}\r\npkt.cflags = 0;\r\nif (vio_version_after_eq(vio, 1, 7) && port->tso) {\r\npkt.cflags |= VNET_LSO_IPV4_CAPAB;\r\nif (!port->tsolen)\r\nport->tsolen = VNET_MAXTSO;\r\npkt.ipv4_lso_maxlen = port->tsolen;\r\n}\r\npkt.plnk_updt = PHYSLINK_UPDATE_NONE;\r\nviodbg(HS, "SEND NET ATTR xmode[0x%x] atype[0x%x] addr[%llx] "\r\n"ackfreq[%u] plnk_updt[0x%02x] opts[0x%02x] mtu[%llu] "\r\n"cflags[0x%04x] lso_max[%u]\n",\r\npkt.xfer_mode, pkt.addr_type,\r\n(unsigned long long)pkt.addr,\r\npkt.ack_freq, pkt.plnk_updt, pkt.options,\r\n(unsigned long long)pkt.mtu, pkt.cflags, pkt.ipv4_lso_maxlen);\r\nreturn vio_ldc_send(vio, &pkt, sizeof(pkt));\r\n}\r\nstatic int handle_attr_info(struct vio_driver_state *vio,\r\nstruct vio_net_attr_info *pkt)\r\n{\r\nstruct vnet_port *port = to_vnet_port(vio);\r\nu64 localmtu;\r\nu8 xfer_mode;\r\nviodbg(HS, "GOT NET ATTR xmode[0x%x] atype[0x%x] addr[%llx] "\r\n"ackfreq[%u] plnk_updt[0x%02x] opts[0x%02x] mtu[%llu] "\r\n" (rmtu[%llu]) cflags[0x%04x] lso_max[%u]\n",\r\npkt->xfer_mode, pkt->addr_type,\r\n(unsigned long long)pkt->addr,\r\npkt->ack_freq, pkt->plnk_updt, pkt->options,\r\n(unsigned long long)pkt->mtu, port->rmtu, pkt->cflags,\r\npkt->ipv4_lso_maxlen);\r\npkt->tag.sid = vio_send_sid(vio);\r\nxfer_mode = pkt->xfer_mode;\r\nif (vio_version_before(vio, 1, 2) && xfer_mode == VIO_DRING_MODE)\r\nxfer_mode = VIO_NEW_DRING_MODE;\r\nif (vio_version_before(vio, 1, 3)) {\r\nlocalmtu = ETH_FRAME_LEN;\r\n} else if (vio_version_after(vio, 1, 3)) {\r\nlocalmtu = port->rmtu ? port->rmtu : VNET_MAXPACKET;\r\nlocalmtu = min(pkt->mtu, localmtu);\r\npkt->mtu = localmtu;\r\n} else {\r\nlocalmtu = ETH_FRAME_LEN + VLAN_HLEN;\r\n}\r\nport->rmtu = localmtu;\r\nif (vio_version_after_eq(vio, 1, 7))\r\nport->tso &= !!(pkt->cflags & VNET_LSO_IPV4_CAPAB);\r\nelse\r\nport->tso = false;\r\nif (port->tso) {\r\nif (!port->tsolen)\r\nport->tsolen = VNET_MAXTSO;\r\nport->tsolen = min(port->tsolen, pkt->ipv4_lso_maxlen);\r\nif (port->tsolen < VNET_MINTSO) {\r\nport->tso = false;\r\nport->tsolen = 0;\r\npkt->cflags &= ~VNET_LSO_IPV4_CAPAB;\r\n}\r\npkt->ipv4_lso_maxlen = port->tsolen;\r\n} else {\r\npkt->cflags &= ~VNET_LSO_IPV4_CAPAB;\r\npkt->ipv4_lso_maxlen = 0;\r\n}\r\nif (vio_version_after_eq(vio, 1, 6)) {\r\npkt->xfer_mode = VIO_NEW_DRING_MODE;\r\npkt->options = VIO_TX_DRING;\r\n}\r\nif (!(xfer_mode | VIO_NEW_DRING_MODE) ||\r\npkt->addr_type != VNET_ADDR_ETHERMAC ||\r\npkt->mtu != localmtu) {\r\nviodbg(HS, "SEND NET ATTR NACK\n");\r\npkt->tag.stype = VIO_SUBTYPE_NACK;\r\n(void) vio_ldc_send(vio, pkt, sizeof(*pkt));\r\nreturn -ECONNRESET;\r\n} else {\r\nviodbg(HS, "SEND NET ATTR ACK xmode[0x%x] atype[0x%x] "\r\n"addr[%llx] ackfreq[%u] plnk_updt[0x%02x] opts[0x%02x] "\r\n"mtu[%llu] (rmtu[%llu]) cflags[0x%04x] lso_max[%u]\n",\r\npkt->xfer_mode, pkt->addr_type,\r\n(unsigned long long)pkt->addr,\r\npkt->ack_freq, pkt->plnk_updt, pkt->options,\r\n(unsigned long long)pkt->mtu, port->rmtu, pkt->cflags,\r\npkt->ipv4_lso_maxlen);\r\npkt->tag.stype = VIO_SUBTYPE_ACK;\r\nreturn vio_ldc_send(vio, pkt, sizeof(*pkt));\r\n}\r\n}\r\nstatic int handle_attr_ack(struct vio_driver_state *vio,\r\nstruct vio_net_attr_info *pkt)\r\n{\r\nviodbg(HS, "GOT NET ATTR ACK\n");\r\nreturn 0;\r\n}\r\nstatic int handle_attr_nack(struct vio_driver_state *vio,\r\nstruct vio_net_attr_info *pkt)\r\n{\r\nviodbg(HS, "GOT NET ATTR NACK\n");\r\nreturn -ECONNRESET;\r\n}\r\nstatic int vnet_handle_attr(struct vio_driver_state *vio, void *arg)\r\n{\r\nstruct vio_net_attr_info *pkt = arg;\r\nswitch (pkt->tag.stype) {\r\ncase VIO_SUBTYPE_INFO:\r\nreturn handle_attr_info(vio, pkt);\r\ncase VIO_SUBTYPE_ACK:\r\nreturn handle_attr_ack(vio, pkt);\r\ncase VIO_SUBTYPE_NACK:\r\nreturn handle_attr_nack(vio, pkt);\r\ndefault:\r\nreturn -ECONNRESET;\r\n}\r\n}\r\nstatic void vnet_handshake_complete(struct vio_driver_state *vio)\r\n{\r\nstruct vio_dring_state *dr;\r\ndr = &vio->drings[VIO_DRIVER_RX_RING];\r\ndr->snd_nxt = dr->rcv_nxt = 1;\r\ndr = &vio->drings[VIO_DRIVER_TX_RING];\r\ndr->snd_nxt = dr->rcv_nxt = 1;\r\n}\r\nstatic struct sk_buff *alloc_and_align_skb(struct net_device *dev,\r\nunsigned int len)\r\n{\r\nstruct sk_buff *skb = netdev_alloc_skb(dev, len+VNET_PACKET_SKIP+8+8);\r\nunsigned long addr, off;\r\nif (unlikely(!skb))\r\nreturn NULL;\r\naddr = (unsigned long) skb->data;\r\noff = ((addr + 7UL) & ~7UL) - addr;\r\nif (off)\r\nskb_reserve(skb, off);\r\nreturn skb;\r\n}\r\nstatic inline void vnet_fullcsum(struct sk_buff *skb)\r\n{\r\nstruct iphdr *iph = ip_hdr(skb);\r\nint offset = skb_transport_offset(skb);\r\nif (skb->protocol != htons(ETH_P_IP))\r\nreturn;\r\nif (iph->protocol != IPPROTO_TCP &&\r\niph->protocol != IPPROTO_UDP)\r\nreturn;\r\nskb->ip_summed = CHECKSUM_NONE;\r\nskb->csum_level = 1;\r\nskb->csum = 0;\r\nif (iph->protocol == IPPROTO_TCP) {\r\nstruct tcphdr *ptcp = tcp_hdr(skb);\r\nptcp->check = 0;\r\nskb->csum = skb_checksum(skb, offset, skb->len - offset, 0);\r\nptcp->check = csum_tcpudp_magic(iph->saddr, iph->daddr,\r\nskb->len - offset, IPPROTO_TCP,\r\nskb->csum);\r\n} else if (iph->protocol == IPPROTO_UDP) {\r\nstruct udphdr *pudp = udp_hdr(skb);\r\npudp->check = 0;\r\nskb->csum = skb_checksum(skb, offset, skb->len - offset, 0);\r\npudp->check = csum_tcpudp_magic(iph->saddr, iph->daddr,\r\nskb->len - offset, IPPROTO_UDP,\r\nskb->csum);\r\n}\r\n}\r\nstatic int vnet_rx_one(struct vnet_port *port, struct vio_net_desc *desc)\r\n{\r\nstruct net_device *dev = port->vp->dev;\r\nunsigned int len = desc->size;\r\nunsigned int copy_len;\r\nstruct sk_buff *skb;\r\nint maxlen;\r\nint err;\r\nerr = -EMSGSIZE;\r\nif (port->tso && port->tsolen > port->rmtu)\r\nmaxlen = port->tsolen;\r\nelse\r\nmaxlen = port->rmtu;\r\nif (unlikely(len < ETH_ZLEN || len > maxlen)) {\r\ndev->stats.rx_length_errors++;\r\ngoto out_dropped;\r\n}\r\nskb = alloc_and_align_skb(dev, len);\r\nerr = -ENOMEM;\r\nif (unlikely(!skb)) {\r\ndev->stats.rx_missed_errors++;\r\ngoto out_dropped;\r\n}\r\ncopy_len = (len + VNET_PACKET_SKIP + 7U) & ~7U;\r\nskb_put(skb, copy_len);\r\nerr = ldc_copy(port->vio.lp, LDC_COPY_IN,\r\nskb->data, copy_len, 0,\r\ndesc->cookies, desc->ncookies);\r\nif (unlikely(err < 0)) {\r\ndev->stats.rx_frame_errors++;\r\ngoto out_free_skb;\r\n}\r\nskb_pull(skb, VNET_PACKET_SKIP);\r\nskb_trim(skb, len);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nif (vio_version_after_eq(&port->vio, 1, 8)) {\r\nstruct vio_net_dext *dext = vio_net_ext(desc);\r\nif (dext->flags & VNET_PKT_HCK_IPV4_HDRCKSUM) {\r\nif (skb->protocol == ETH_P_IP) {\r\nstruct iphdr *iph = (struct iphdr *)skb->data;\r\niph->check = 0;\r\nip_send_check(iph);\r\n}\r\n}\r\nif ((dext->flags & VNET_PKT_HCK_FULLCKSUM) &&\r\nskb->ip_summed == CHECKSUM_NONE)\r\nvnet_fullcsum(skb);\r\nif (dext->flags & VNET_PKT_HCK_IPV4_HDRCKSUM_OK) {\r\nskb->ip_summed = CHECKSUM_PARTIAL;\r\nskb->csum_level = 0;\r\nif (dext->flags & VNET_PKT_HCK_FULLCKSUM_OK)\r\nskb->csum_level = 1;\r\n}\r\n}\r\nskb->ip_summed = port->switch_port ? CHECKSUM_NONE : CHECKSUM_PARTIAL;\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += len;\r\nnapi_gro_receive(&port->napi, skb);\r\nreturn 0;\r\nout_free_skb:\r\nkfree_skb(skb);\r\nout_dropped:\r\ndev->stats.rx_dropped++;\r\nreturn err;\r\n}\r\nstatic int vnet_send_ack(struct vnet_port *port, struct vio_dring_state *dr,\r\nu32 start, u32 end, u8 vio_dring_state)\r\n{\r\nstruct vio_dring_data hdr = {\r\n.tag = {\r\n.type = VIO_TYPE_DATA,\r\n.stype = VIO_SUBTYPE_ACK,\r\n.stype_env = VIO_DRING_DATA,\r\n.sid = vio_send_sid(&port->vio),\r\n},\r\n.dring_ident = dr->ident,\r\n.start_idx = start,\r\n.end_idx = end,\r\n.state = vio_dring_state,\r\n};\r\nint err, delay;\r\nint retries = 0;\r\nhdr.seq = dr->snd_nxt;\r\ndelay = 1;\r\ndo {\r\nerr = vio_ldc_send(&port->vio, &hdr, sizeof(hdr));\r\nif (err > 0) {\r\ndr->snd_nxt++;\r\nbreak;\r\n}\r\nudelay(delay);\r\nif ((delay <<= 1) > 128)\r\ndelay = 128;\r\nif (retries++ > VNET_MAX_RETRIES) {\r\npr_info("ECONNRESET %x:%x:%x:%x:%x:%x\n",\r\nport->raddr[0], port->raddr[1],\r\nport->raddr[2], port->raddr[3],\r\nport->raddr[4], port->raddr[5]);\r\nbreak;\r\n}\r\n} while (err == -EAGAIN);\r\nif (err <= 0 && vio_dring_state == VIO_DRING_STOPPED) {\r\nport->stop_rx_idx = end;\r\nport->stop_rx = true;\r\n} else {\r\nport->stop_rx_idx = 0;\r\nport->stop_rx = false;\r\n}\r\nreturn err;\r\n}\r\nstatic struct vio_net_desc *get_rx_desc(struct vnet_port *port,\r\nstruct vio_dring_state *dr,\r\nu32 index)\r\n{\r\nstruct vio_net_desc *desc = port->vio.desc_buf;\r\nint err;\r\nerr = ldc_get_dring_entry(port->vio.lp, desc, dr->entry_size,\r\n(index * dr->entry_size),\r\ndr->cookies, dr->ncookies);\r\nif (err < 0)\r\nreturn ERR_PTR(err);\r\nreturn desc;\r\n}\r\nstatic int put_rx_desc(struct vnet_port *port,\r\nstruct vio_dring_state *dr,\r\nstruct vio_net_desc *desc,\r\nu32 index)\r\n{\r\nint err;\r\nerr = ldc_put_dring_entry(port->vio.lp, desc, dr->entry_size,\r\n(index * dr->entry_size),\r\ndr->cookies, dr->ncookies);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int vnet_walk_rx_one(struct vnet_port *port,\r\nstruct vio_dring_state *dr,\r\nu32 index, int *needs_ack)\r\n{\r\nstruct vio_net_desc *desc = get_rx_desc(port, dr, index);\r\nstruct vio_driver_state *vio = &port->vio;\r\nint err;\r\nBUG_ON(desc == NULL);\r\nif (IS_ERR(desc))\r\nreturn PTR_ERR(desc);\r\nif (desc->hdr.state != VIO_DESC_READY)\r\nreturn 1;\r\ndma_rmb();\r\nviodbg(DATA, "vio_walk_rx_one desc[%02x:%02x:%08x:%08x:%llx:%llx]\n",\r\ndesc->hdr.state, desc->hdr.ack,\r\ndesc->size, desc->ncookies,\r\ndesc->cookies[0].cookie_addr,\r\ndesc->cookies[0].cookie_size);\r\nerr = vnet_rx_one(port, desc);\r\nif (err == -ECONNRESET)\r\nreturn err;\r\ndesc->hdr.state = VIO_DESC_DONE;\r\nerr = put_rx_desc(port, dr, desc, index);\r\nif (err < 0)\r\nreturn err;\r\n*needs_ack = desc->hdr.ack;\r\nreturn 0;\r\n}\r\nstatic int vnet_walk_rx(struct vnet_port *port, struct vio_dring_state *dr,\r\nu32 start, u32 end, int *npkts, int budget)\r\n{\r\nstruct vio_driver_state *vio = &port->vio;\r\nint ack_start = -1, ack_end = -1;\r\nbool send_ack = true;\r\nend = (end == (u32) -1) ? vio_dring_prev(dr, start)\r\n: vio_dring_next(dr, end);\r\nviodbg(DATA, "vnet_walk_rx start[%08x] end[%08x]\n", start, end);\r\nwhile (start != end) {\r\nint ack = 0, err = vnet_walk_rx_one(port, dr, start, &ack);\r\nif (err == -ECONNRESET)\r\nreturn err;\r\nif (err != 0)\r\nbreak;\r\n(*npkts)++;\r\nif (ack_start == -1)\r\nack_start = start;\r\nack_end = start;\r\nstart = vio_dring_next(dr, start);\r\nif (ack && start != end) {\r\nerr = vnet_send_ack(port, dr, ack_start, ack_end,\r\nVIO_DRING_ACTIVE);\r\nif (err == -ECONNRESET)\r\nreturn err;\r\nack_start = -1;\r\n}\r\nif ((*npkts) >= budget) {\r\nsend_ack = false;\r\nbreak;\r\n}\r\n}\r\nif (unlikely(ack_start == -1))\r\nack_start = ack_end = vio_dring_prev(dr, start);\r\nif (send_ack) {\r\nport->napi_resume = false;\r\nreturn vnet_send_ack(port, dr, ack_start, ack_end,\r\nVIO_DRING_STOPPED);\r\n} else {\r\nport->napi_resume = true;\r\nport->napi_stop_idx = ack_end;\r\nreturn 1;\r\n}\r\n}\r\nstatic int vnet_rx(struct vnet_port *port, void *msgbuf, int *npkts,\r\nint budget)\r\n{\r\nstruct vio_dring_data *pkt = msgbuf;\r\nstruct vio_dring_state *dr = &port->vio.drings[VIO_DRIVER_RX_RING];\r\nstruct vio_driver_state *vio = &port->vio;\r\nviodbg(DATA, "vnet_rx stype_env[%04x] seq[%016llx] rcv_nxt[%016llx]\n",\r\npkt->tag.stype_env, pkt->seq, dr->rcv_nxt);\r\nif (unlikely(pkt->tag.stype_env != VIO_DRING_DATA))\r\nreturn 0;\r\nif (unlikely(pkt->seq != dr->rcv_nxt)) {\r\npr_err("RX out of sequence seq[0x%llx] rcv_nxt[0x%llx]\n",\r\npkt->seq, dr->rcv_nxt);\r\nreturn 0;\r\n}\r\nif (!port->napi_resume)\r\ndr->rcv_nxt++;\r\nreturn vnet_walk_rx(port, dr, pkt->start_idx, pkt->end_idx,\r\nnpkts, budget);\r\n}\r\nstatic int idx_is_pending(struct vio_dring_state *dr, u32 end)\r\n{\r\nu32 idx = dr->cons;\r\nint found = 0;\r\nwhile (idx != dr->prod) {\r\nif (idx == end) {\r\nfound = 1;\r\nbreak;\r\n}\r\nidx = vio_dring_next(dr, idx);\r\n}\r\nreturn found;\r\n}\r\nstatic int vnet_ack(struct vnet_port *port, void *msgbuf)\r\n{\r\nstruct vio_dring_state *dr = &port->vio.drings[VIO_DRIVER_TX_RING];\r\nstruct vio_dring_data *pkt = msgbuf;\r\nstruct net_device *dev;\r\nstruct vnet *vp;\r\nu32 end;\r\nstruct vio_net_desc *desc;\r\nstruct netdev_queue *txq;\r\nif (unlikely(pkt->tag.stype_env != VIO_DRING_DATA))\r\nreturn 0;\r\nend = pkt->end_idx;\r\nvp = port->vp;\r\ndev = vp->dev;\r\nnetif_tx_lock(dev);\r\nif (unlikely(!idx_is_pending(dr, end))) {\r\nnetif_tx_unlock(dev);\r\nreturn 0;\r\n}\r\ndr->cons = vio_dring_next(dr, end);\r\ndesc = vio_dring_entry(dr, dr->cons);\r\nif (desc->hdr.state == VIO_DESC_READY && !port->start_cons) {\r\nif (__vnet_tx_trigger(port, dr->cons) > 0)\r\nport->start_cons = false;\r\nelse\r\nport->start_cons = true;\r\n} else {\r\nport->start_cons = true;\r\n}\r\nnetif_tx_unlock(dev);\r\ntxq = netdev_get_tx_queue(dev, port->q_index);\r\nif (unlikely(netif_tx_queue_stopped(txq) &&\r\nvnet_tx_dring_avail(dr) >= VNET_TX_WAKEUP_THRESH(dr)))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int vnet_nack(struct vnet_port *port, void *msgbuf)\r\n{\r\nreturn 0;\r\n}\r\nstatic int handle_mcast(struct vnet_port *port, void *msgbuf)\r\n{\r\nstruct vio_net_mcast_info *pkt = msgbuf;\r\nif (pkt->tag.stype != VIO_SUBTYPE_ACK)\r\npr_err("%s: Got unexpected MCAST reply [%02x:%02x:%04x:%08x]\n",\r\nport->vp->dev->name,\r\npkt->tag.type,\r\npkt->tag.stype,\r\npkt->tag.stype_env,\r\npkt->tag.sid);\r\nreturn 0;\r\n}\r\nstatic void maybe_tx_wakeup(struct vnet_port *port)\r\n{\r\nstruct netdev_queue *txq;\r\ntxq = netdev_get_tx_queue(port->vp->dev, port->q_index);\r\n__netif_tx_lock(txq, smp_processor_id());\r\nif (likely(netif_tx_queue_stopped(txq))) {\r\nstruct vio_dring_state *dr;\r\ndr = &port->vio.drings[VIO_DRIVER_TX_RING];\r\nnetif_tx_wake_queue(txq);\r\n}\r\n__netif_tx_unlock(txq);\r\n}\r\nstatic inline bool port_is_up(struct vnet_port *vnet)\r\n{\r\nstruct vio_driver_state *vio = &vnet->vio;\r\nreturn !!(vio->hs_state & VIO_HS_COMPLETE);\r\n}\r\nstatic int vnet_event_napi(struct vnet_port *port, int budget)\r\n{\r\nstruct vio_driver_state *vio = &port->vio;\r\nint tx_wakeup, err;\r\nint npkts = 0;\r\nint event = (port->rx_event & LDC_EVENT_RESET);\r\nldc_ctrl:\r\nif (unlikely(event == LDC_EVENT_RESET ||\r\nevent == LDC_EVENT_UP)) {\r\nvio_link_state_change(vio, event);\r\nif (event == LDC_EVENT_RESET) {\r\nvnet_port_reset(port);\r\nvio_port_up(vio);\r\n}\r\nport->rx_event = 0;\r\nreturn 0;\r\n}\r\nevent = (port->rx_event & LDC_EVENT_UP);\r\nport->rx_event &= ~(LDC_EVENT_RESET|LDC_EVENT_UP);\r\nif (event == LDC_EVENT_UP)\r\ngoto ldc_ctrl;\r\nevent = port->rx_event;\r\nif (!(event & LDC_EVENT_DATA_READY))\r\nreturn 0;\r\nBUG_ON(event != LDC_EVENT_DATA_READY);\r\ntx_wakeup = err = 0;\r\nwhile (1) {\r\nunion {\r\nstruct vio_msg_tag tag;\r\nu64 raw[8];\r\n} msgbuf;\r\nif (port->napi_resume) {\r\nstruct vio_dring_data *pkt =\r\n(struct vio_dring_data *)&msgbuf;\r\nstruct vio_dring_state *dr =\r\n&port->vio.drings[VIO_DRIVER_RX_RING];\r\npkt->tag.type = VIO_TYPE_DATA;\r\npkt->tag.stype = VIO_SUBTYPE_INFO;\r\npkt->tag.stype_env = VIO_DRING_DATA;\r\npkt->seq = dr->rcv_nxt;\r\npkt->start_idx = vio_dring_next(dr, port->napi_stop_idx);\r\npkt->end_idx = -1;\r\ngoto napi_resume;\r\n}\r\nerr = ldc_read(vio->lp, &msgbuf, sizeof(msgbuf));\r\nif (unlikely(err < 0)) {\r\nif (err == -ECONNRESET)\r\nvio_conn_reset(vio);\r\nbreak;\r\n}\r\nif (err == 0)\r\nbreak;\r\nviodbg(DATA, "TAG [%02x:%02x:%04x:%08x]\n",\r\nmsgbuf.tag.type,\r\nmsgbuf.tag.stype,\r\nmsgbuf.tag.stype_env,\r\nmsgbuf.tag.sid);\r\nerr = vio_validate_sid(vio, &msgbuf.tag);\r\nif (err < 0)\r\nbreak;\r\nnapi_resume:\r\nif (likely(msgbuf.tag.type == VIO_TYPE_DATA)) {\r\nif (msgbuf.tag.stype == VIO_SUBTYPE_INFO) {\r\nif (!port_is_up(port)) {\r\nerr = -ECONNRESET;\r\nbreak;\r\n}\r\nerr = vnet_rx(port, &msgbuf, &npkts, budget);\r\nif (npkts >= budget)\r\nbreak;\r\nif (npkts == 0)\r\nbreak;\r\n} else if (msgbuf.tag.stype == VIO_SUBTYPE_ACK) {\r\nerr = vnet_ack(port, &msgbuf);\r\nif (err > 0)\r\ntx_wakeup |= err;\r\n} else if (msgbuf.tag.stype == VIO_SUBTYPE_NACK) {\r\nerr = vnet_nack(port, &msgbuf);\r\n}\r\n} else if (msgbuf.tag.type == VIO_TYPE_CTRL) {\r\nif (msgbuf.tag.stype_env == VNET_MCAST_INFO)\r\nerr = handle_mcast(port, &msgbuf);\r\nelse\r\nerr = vio_control_pkt_engine(vio, &msgbuf);\r\nif (err)\r\nbreak;\r\n} else {\r\nerr = vnet_handle_unknown(port, &msgbuf);\r\n}\r\nif (err == -ECONNRESET)\r\nbreak;\r\n}\r\nif (unlikely(tx_wakeup && err != -ECONNRESET))\r\nmaybe_tx_wakeup(port);\r\nreturn npkts;\r\n}\r\nstatic int vnet_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct vnet_port *port = container_of(napi, struct vnet_port, napi);\r\nstruct vio_driver_state *vio = &port->vio;\r\nint processed = vnet_event_napi(port, budget);\r\nif (processed < budget) {\r\nnapi_complete(napi);\r\nport->rx_event &= ~LDC_EVENT_DATA_READY;\r\nvio_set_intr(vio->vdev->rx_ino, HV_INTR_ENABLED);\r\n}\r\nreturn processed;\r\n}\r\nstatic void vnet_event(void *arg, int event)\r\n{\r\nstruct vnet_port *port = arg;\r\nstruct vio_driver_state *vio = &port->vio;\r\nport->rx_event |= event;\r\nvio_set_intr(vio->vdev->rx_ino, HV_INTR_DISABLED);\r\nnapi_schedule(&port->napi);\r\n}\r\nstatic int __vnet_tx_trigger(struct vnet_port *port, u32 start)\r\n{\r\nstruct vio_dring_state *dr = &port->vio.drings[VIO_DRIVER_TX_RING];\r\nstruct vio_dring_data hdr = {\r\n.tag = {\r\n.type = VIO_TYPE_DATA,\r\n.stype = VIO_SUBTYPE_INFO,\r\n.stype_env = VIO_DRING_DATA,\r\n.sid = vio_send_sid(&port->vio),\r\n},\r\n.dring_ident = dr->ident,\r\n.start_idx = start,\r\n.end_idx = (u32) -1,\r\n};\r\nint err, delay;\r\nint retries = 0;\r\nif (port->stop_rx) {\r\nerr = vnet_send_ack(port,\r\n&port->vio.drings[VIO_DRIVER_RX_RING],\r\nport->stop_rx_idx, -1,\r\nVIO_DRING_STOPPED);\r\nif (err <= 0)\r\nreturn err;\r\n}\r\nhdr.seq = dr->snd_nxt;\r\ndelay = 1;\r\ndo {\r\nerr = vio_ldc_send(&port->vio, &hdr, sizeof(hdr));\r\nif (err > 0) {\r\ndr->snd_nxt++;\r\nbreak;\r\n}\r\nudelay(delay);\r\nif ((delay <<= 1) > 128)\r\ndelay = 128;\r\nif (retries++ > VNET_MAX_RETRIES)\r\nbreak;\r\n} while (err == -EAGAIN);\r\nreturn err;\r\n}\r\nstruct vnet_port *__tx_port_find(struct vnet *vp, struct sk_buff *skb)\r\n{\r\nunsigned int hash = vnet_hashfn(skb->data);\r\nstruct hlist_head *hp = &vp->port_hash[hash];\r\nstruct vnet_port *port;\r\nhlist_for_each_entry_rcu(port, hp, hash) {\r\nif (!port_is_up(port))\r\ncontinue;\r\nif (ether_addr_equal(port->raddr, skb->data))\r\nreturn port;\r\n}\r\nlist_for_each_entry_rcu(port, &vp->port_list, list) {\r\nif (!port->switch_port)\r\ncontinue;\r\nif (!port_is_up(port))\r\ncontinue;\r\nreturn port;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct sk_buff *vnet_clean_tx_ring(struct vnet_port *port,\r\nunsigned *pending)\r\n{\r\nstruct vio_dring_state *dr = &port->vio.drings[VIO_DRIVER_TX_RING];\r\nstruct sk_buff *skb = NULL;\r\nint i, txi;\r\n*pending = 0;\r\ntxi = dr->prod;\r\nfor (i = 0; i < VNET_TX_RING_SIZE; ++i) {\r\nstruct vio_net_desc *d;\r\n--txi;\r\nif (txi < 0)\r\ntxi = VNET_TX_RING_SIZE-1;\r\nd = vio_dring_entry(dr, txi);\r\nif (d->hdr.state == VIO_DESC_READY) {\r\n(*pending)++;\r\ncontinue;\r\n}\r\nif (port->tx_bufs[txi].skb) {\r\nif (d->hdr.state != VIO_DESC_DONE)\r\npr_notice("invalid ring buffer state %d\n",\r\nd->hdr.state);\r\nBUG_ON(port->tx_bufs[txi].skb->next);\r\nport->tx_bufs[txi].skb->next = skb;\r\nskb = port->tx_bufs[txi].skb;\r\nport->tx_bufs[txi].skb = NULL;\r\nldc_unmap(port->vio.lp,\r\nport->tx_bufs[txi].cookies,\r\nport->tx_bufs[txi].ncookies);\r\n} else if (d->hdr.state == VIO_DESC_FREE)\r\nbreak;\r\nd->hdr.state = VIO_DESC_FREE;\r\n}\r\nreturn skb;\r\n}\r\nstatic inline void vnet_free_skbs(struct sk_buff *skb)\r\n{\r\nstruct sk_buff *next;\r\nwhile (skb) {\r\nnext = skb->next;\r\nskb->next = NULL;\r\ndev_kfree_skb(skb);\r\nskb = next;\r\n}\r\n}\r\nstatic void vnet_clean_timer_expire(unsigned long port0)\r\n{\r\nstruct vnet_port *port = (struct vnet_port *)port0;\r\nstruct sk_buff *freeskbs;\r\nunsigned pending;\r\nnetif_tx_lock(port->vp->dev);\r\nfreeskbs = vnet_clean_tx_ring(port, &pending);\r\nnetif_tx_unlock(port->vp->dev);\r\nvnet_free_skbs(freeskbs);\r\nif (pending)\r\n(void)mod_timer(&port->clean_timer,\r\njiffies + VNET_CLEAN_TIMEOUT);\r\nelse\r\ndel_timer(&port->clean_timer);\r\n}\r\nstatic inline int vnet_skb_map(struct ldc_channel *lp, struct sk_buff *skb,\r\nstruct ldc_trans_cookie *cookies, int ncookies,\r\nunsigned int map_perm)\r\n{\r\nint i, nc, err, blen;\r\nblen = skb_headlen(skb);\r\nif (blen < ETH_ZLEN)\r\nblen = ETH_ZLEN;\r\nblen += VNET_PACKET_SKIP;\r\nblen += 8 - (blen & 7);\r\nerr = ldc_map_single(lp, skb->data-VNET_PACKET_SKIP, blen, cookies,\r\nncookies, map_perm);\r\nif (err < 0)\r\nreturn err;\r\nnc = err;\r\nfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\r\nskb_frag_t *f = &skb_shinfo(skb)->frags[i];\r\nu8 *vaddr;\r\nif (nc < ncookies) {\r\nvaddr = kmap_atomic(skb_frag_page(f));\r\nblen = skb_frag_size(f);\r\nblen += 8 - (blen & 7);\r\nerr = ldc_map_single(lp, vaddr + f->page_offset,\r\nblen, cookies + nc, ncookies - nc,\r\nmap_perm);\r\nkunmap_atomic(vaddr);\r\n} else {\r\nerr = -EMSGSIZE;\r\n}\r\nif (err < 0) {\r\nldc_unmap(lp, cookies, nc);\r\nreturn err;\r\n}\r\nnc += err;\r\n}\r\nreturn nc;\r\n}\r\nstatic inline struct sk_buff *vnet_skb_shape(struct sk_buff *skb, int ncookies)\r\n{\r\nstruct sk_buff *nskb;\r\nint i, len, pad, docopy;\r\nlen = skb->len;\r\npad = 0;\r\nif (len < ETH_ZLEN) {\r\npad += ETH_ZLEN - skb->len;\r\nlen += pad;\r\n}\r\nlen += VNET_PACKET_SKIP;\r\npad += 8 - (len & 7);\r\ndocopy = skb_shinfo(skb)->nr_frags >= ncookies;\r\nfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\r\nskb_frag_t *f = &skb_shinfo(skb)->frags[i];\r\ndocopy |= f->page_offset & 7;\r\n}\r\nif (((unsigned long)skb->data & 7) != VNET_PACKET_SKIP ||\r\nskb_tailroom(skb) < pad ||\r\nskb_headroom(skb) < VNET_PACKET_SKIP || docopy) {\r\nint start = 0, offset;\r\n__wsum csum;\r\nlen = skb->len > ETH_ZLEN ? skb->len : ETH_ZLEN;\r\nnskb = alloc_and_align_skb(skb->dev, len);\r\nif (nskb == NULL) {\r\ndev_kfree_skb(skb);\r\nreturn NULL;\r\n}\r\nskb_reserve(nskb, VNET_PACKET_SKIP);\r\nnskb->protocol = skb->protocol;\r\noffset = skb_mac_header(skb) - skb->data;\r\nskb_set_mac_header(nskb, offset);\r\noffset = skb_network_header(skb) - skb->data;\r\nskb_set_network_header(nskb, offset);\r\noffset = skb_transport_header(skb) - skb->data;\r\nskb_set_transport_header(nskb, offset);\r\noffset = 0;\r\nnskb->csum_offset = skb->csum_offset;\r\nnskb->ip_summed = skb->ip_summed;\r\nif (skb->ip_summed == CHECKSUM_PARTIAL)\r\nstart = skb_checksum_start_offset(skb);\r\nif (start) {\r\nstruct iphdr *iph = ip_hdr(nskb);\r\nint offset = start + nskb->csum_offset;\r\nif (skb_copy_bits(skb, 0, nskb->data, start)) {\r\ndev_kfree_skb(nskb);\r\ndev_kfree_skb(skb);\r\nreturn NULL;\r\n}\r\n*(__sum16 *)(skb->data + offset) = 0;\r\ncsum = skb_copy_and_csum_bits(skb, start,\r\nnskb->data + start,\r\nskb->len - start, 0);\r\nif (iph->protocol == IPPROTO_TCP ||\r\niph->protocol == IPPROTO_UDP) {\r\ncsum = csum_tcpudp_magic(iph->saddr, iph->daddr,\r\nskb->len - start,\r\niph->protocol, csum);\r\n}\r\n*(__sum16 *)(nskb->data + offset) = csum;\r\nnskb->ip_summed = CHECKSUM_NONE;\r\n} else if (skb_copy_bits(skb, 0, nskb->data, skb->len)) {\r\ndev_kfree_skb(nskb);\r\ndev_kfree_skb(skb);\r\nreturn NULL;\r\n}\r\n(void)skb_put(nskb, skb->len);\r\nif (skb_is_gso(skb)) {\r\nskb_shinfo(nskb)->gso_size = skb_shinfo(skb)->gso_size;\r\nskb_shinfo(nskb)->gso_type = skb_shinfo(skb)->gso_type;\r\n}\r\nnskb->queue_mapping = skb->queue_mapping;\r\ndev_kfree_skb(skb);\r\nskb = nskb;\r\n}\r\nreturn skb;\r\n}\r\nstatic u16\r\nvnet_select_queue(struct net_device *dev, struct sk_buff *skb,\r\nvoid *accel_priv, select_queue_fallback_t fallback)\r\n{\r\nstruct vnet *vp = netdev_priv(dev);\r\nstruct vnet_port *port = __tx_port_find(vp, skb);\r\nif (port == NULL)\r\nreturn 0;\r\nreturn port->q_index;\r\n}\r\nstatic int vnet_handle_offloads(struct vnet_port *port, struct sk_buff *skb)\r\n{\r\nstruct net_device *dev = port->vp->dev;\r\nstruct vio_dring_state *dr = &port->vio.drings[VIO_DRIVER_TX_RING];\r\nstruct sk_buff *segs;\r\nint maclen, datalen;\r\nint status;\r\nint gso_size, gso_type, gso_segs;\r\nint hlen = skb_transport_header(skb) - skb_mac_header(skb);\r\nint proto = IPPROTO_IP;\r\nif (skb->protocol == htons(ETH_P_IP))\r\nproto = ip_hdr(skb)->protocol;\r\nelse if (skb->protocol == htons(ETH_P_IPV6))\r\nproto = ipv6_hdr(skb)->nexthdr;\r\nif (proto == IPPROTO_TCP)\r\nhlen += tcp_hdr(skb)->doff * 4;\r\nelse if (proto == IPPROTO_UDP)\r\nhlen += sizeof(struct udphdr);\r\nelse {\r\npr_err("vnet_handle_offloads GSO with unknown transport "\r\n"protocol %d tproto %d\n", skb->protocol, proto);\r\nhlen = 128;\r\n}\r\ndatalen = port->tsolen - hlen;\r\ngso_size = skb_shinfo(skb)->gso_size;\r\ngso_type = skb_shinfo(skb)->gso_type;\r\ngso_segs = skb_shinfo(skb)->gso_segs;\r\nif (port->tso && gso_size < datalen)\r\ngso_segs = DIV_ROUND_UP(skb->len - hlen, datalen);\r\nif (unlikely(vnet_tx_dring_avail(dr) < gso_segs)) {\r\nstruct netdev_queue *txq;\r\ntxq = netdev_get_tx_queue(dev, port->q_index);\r\nnetif_tx_stop_queue(txq);\r\nif (vnet_tx_dring_avail(dr) < skb_shinfo(skb)->gso_segs)\r\nreturn NETDEV_TX_BUSY;\r\nnetif_tx_wake_queue(txq);\r\n}\r\nmaclen = skb_network_header(skb) - skb_mac_header(skb);\r\nskb_pull(skb, maclen);\r\nif (port->tso && gso_size < datalen) {\r\nif (skb_unclone(skb, GFP_ATOMIC))\r\ngoto out_dropped;\r\nskb_shinfo(skb)->gso_size = datalen;\r\nskb_shinfo(skb)->gso_segs = gso_segs;\r\n}\r\nsegs = skb_gso_segment(skb, dev->features & ~NETIF_F_TSO);\r\nif (IS_ERR(segs))\r\ngoto out_dropped;\r\nskb_push(skb, maclen);\r\nskb_reset_mac_header(skb);\r\nstatus = 0;\r\nwhile (segs) {\r\nstruct sk_buff *curr = segs;\r\nsegs = segs->next;\r\ncurr->next = NULL;\r\nif (port->tso && curr->len > dev->mtu) {\r\nskb_shinfo(curr)->gso_size = gso_size;\r\nskb_shinfo(curr)->gso_type = gso_type;\r\nskb_shinfo(curr)->gso_segs =\r\nDIV_ROUND_UP(curr->len - hlen, gso_size);\r\n} else\r\nskb_shinfo(curr)->gso_size = 0;\r\nskb_push(curr, maclen);\r\nskb_reset_mac_header(curr);\r\nmemcpy(skb_mac_header(curr), skb_mac_header(skb),\r\nmaclen);\r\ncurr->csum_start = skb_transport_header(curr) - curr->head;\r\nif (ip_hdr(curr)->protocol == IPPROTO_TCP)\r\ncurr->csum_offset = offsetof(struct tcphdr, check);\r\nelse if (ip_hdr(curr)->protocol == IPPROTO_UDP)\r\ncurr->csum_offset = offsetof(struct udphdr, check);\r\nif (!(status & NETDEV_TX_MASK))\r\nstatus = vnet_start_xmit(curr, dev);\r\nif (status & NETDEV_TX_MASK)\r\ndev_kfree_skb_any(curr);\r\n}\r\nif (!(status & NETDEV_TX_MASK))\r\ndev_kfree_skb_any(skb);\r\nreturn status;\r\nout_dropped:\r\ndev->stats.tx_dropped++;\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int vnet_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct vnet *vp = netdev_priv(dev);\r\nstruct vnet_port *port = NULL;\r\nstruct vio_dring_state *dr;\r\nstruct vio_net_desc *d;\r\nunsigned int len;\r\nstruct sk_buff *freeskbs = NULL;\r\nint i, err, txi;\r\nunsigned pending = 0;\r\nstruct netdev_queue *txq;\r\nrcu_read_lock();\r\nport = __tx_port_find(vp, skb);\r\nif (unlikely(!port)) {\r\nrcu_read_unlock();\r\ngoto out_dropped;\r\n}\r\nif (skb_is_gso(skb) && skb->len > port->tsolen) {\r\nerr = vnet_handle_offloads(port, skb);\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nif (!skb_is_gso(skb) && skb->len > port->rmtu) {\r\nunsigned long localmtu = port->rmtu - ETH_HLEN;\r\nif (vio_version_after_eq(&port->vio, 1, 3))\r\nlocalmtu -= VLAN_HLEN;\r\nif (skb->protocol == htons(ETH_P_IP)) {\r\nstruct flowi4 fl4;\r\nstruct rtable *rt = NULL;\r\nmemset(&fl4, 0, sizeof(fl4));\r\nfl4.flowi4_oif = dev->ifindex;\r\nfl4.flowi4_tos = RT_TOS(ip_hdr(skb)->tos);\r\nfl4.daddr = ip_hdr(skb)->daddr;\r\nfl4.saddr = ip_hdr(skb)->saddr;\r\nrt = ip_route_output_key(dev_net(dev), &fl4);\r\nrcu_read_unlock();\r\nif (!IS_ERR(rt)) {\r\nskb_dst_set(skb, &rt->dst);\r\nicmp_send(skb, ICMP_DEST_UNREACH,\r\nICMP_FRAG_NEEDED,\r\nhtonl(localmtu));\r\n}\r\n}\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nelse if (skb->protocol == htons(ETH_P_IPV6))\r\nicmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, localmtu);\r\n#endif\r\ngoto out_dropped;\r\n}\r\nskb = vnet_skb_shape(skb, 2);\r\nif (unlikely(!skb))\r\ngoto out_dropped;\r\nif (skb->ip_summed == CHECKSUM_PARTIAL)\r\nvnet_fullcsum(skb);\r\ndr = &port->vio.drings[VIO_DRIVER_TX_RING];\r\ni = skb_get_queue_mapping(skb);\r\ntxq = netdev_get_tx_queue(dev, i);\r\nif (unlikely(vnet_tx_dring_avail(dr) < 1)) {\r\nif (!netif_tx_queue_stopped(txq)) {\r\nnetif_tx_stop_queue(txq);\r\nnetdev_err(dev, "BUG! Tx Ring full when queue awake!\n");\r\ndev->stats.tx_errors++;\r\n}\r\nrcu_read_unlock();\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nd = vio_dring_cur(dr);\r\ntxi = dr->prod;\r\nfreeskbs = vnet_clean_tx_ring(port, &pending);\r\nBUG_ON(port->tx_bufs[txi].skb);\r\nlen = skb->len;\r\nif (len < ETH_ZLEN)\r\nlen = ETH_ZLEN;\r\nerr = vnet_skb_map(port->vio.lp, skb, port->tx_bufs[txi].cookies, 2,\r\n(LDC_MAP_SHADOW | LDC_MAP_DIRECT | LDC_MAP_RW));\r\nif (err < 0) {\r\nnetdev_info(dev, "tx buffer map error %d\n", err);\r\ngoto out_dropped;\r\n}\r\nport->tx_bufs[txi].skb = skb;\r\nskb = NULL;\r\nport->tx_bufs[txi].ncookies = err;\r\nd->hdr.ack = VIO_ACK_DISABLE;\r\nd->size = len;\r\nd->ncookies = port->tx_bufs[txi].ncookies;\r\nfor (i = 0; i < d->ncookies; i++)\r\nd->cookies[i] = port->tx_bufs[txi].cookies[i];\r\nif (vio_version_after_eq(&port->vio, 1, 7)) {\r\nstruct vio_net_dext *dext = vio_net_ext(d);\r\nmemset(dext, 0, sizeof(*dext));\r\nif (skb_is_gso(port->tx_bufs[txi].skb)) {\r\ndext->ipv4_lso_mss = skb_shinfo(port->tx_bufs[txi].skb)\r\n->gso_size;\r\ndext->flags |= VNET_PKT_IPV4_LSO;\r\n}\r\nif (vio_version_after_eq(&port->vio, 1, 8) &&\r\n!port->switch_port) {\r\ndext->flags |= VNET_PKT_HCK_IPV4_HDRCKSUM_OK;\r\ndext->flags |= VNET_PKT_HCK_FULLCKSUM_OK;\r\n}\r\n}\r\ndma_wmb();\r\nd->hdr.state = VIO_DESC_READY;\r\nif (!port->start_cons)\r\ngoto ldc_start_done;\r\nerr = __vnet_tx_trigger(port, dr->cons);\r\nif (unlikely(err < 0)) {\r\nnetdev_info(dev, "TX trigger error %d\n", err);\r\nd->hdr.state = VIO_DESC_FREE;\r\nskb = port->tx_bufs[txi].skb;\r\nport->tx_bufs[txi].skb = NULL;\r\ndev->stats.tx_carrier_errors++;\r\ngoto out_dropped;\r\n}\r\nldc_start_done:\r\nport->start_cons = false;\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += port->tx_bufs[txi].skb->len;\r\ndr->prod = (dr->prod + 1) & (VNET_TX_RING_SIZE - 1);\r\nif (unlikely(vnet_tx_dring_avail(dr) < 1)) {\r\nnetif_tx_stop_queue(txq);\r\nif (vnet_tx_dring_avail(dr) > VNET_TX_WAKEUP_THRESH(dr))\r\nnetif_tx_wake_queue(txq);\r\n}\r\n(void)mod_timer(&port->clean_timer, jiffies + VNET_CLEAN_TIMEOUT);\r\nrcu_read_unlock();\r\nvnet_free_skbs(freeskbs);\r\nreturn NETDEV_TX_OK;\r\nout_dropped:\r\nif (pending)\r\n(void)mod_timer(&port->clean_timer,\r\njiffies + VNET_CLEAN_TIMEOUT);\r\nelse if (port)\r\ndel_timer(&port->clean_timer);\r\nif (port)\r\nrcu_read_unlock();\r\nif (skb)\r\ndev_kfree_skb(skb);\r\nvnet_free_skbs(freeskbs);\r\ndev->stats.tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void vnet_tx_timeout(struct net_device *dev)\r\n{\r\n}\r\nstatic int vnet_open(struct net_device *dev)\r\n{\r\nnetif_carrier_on(dev);\r\nnetif_tx_start_all_queues(dev);\r\nreturn 0;\r\n}\r\nstatic int vnet_close(struct net_device *dev)\r\n{\r\nnetif_tx_stop_all_queues(dev);\r\nnetif_carrier_off(dev);\r\nreturn 0;\r\n}\r\nstatic struct vnet_mcast_entry *__vnet_mc_find(struct vnet *vp, u8 *addr)\r\n{\r\nstruct vnet_mcast_entry *m;\r\nfor (m = vp->mcast_list; m; m = m->next) {\r\nif (ether_addr_equal(m->addr, addr))\r\nreturn m;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void __update_mc_list(struct vnet *vp, struct net_device *dev)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nstruct vnet_mcast_entry *m;\r\nm = __vnet_mc_find(vp, ha->addr);\r\nif (m) {\r\nm->hit = 1;\r\ncontinue;\r\n}\r\nif (!m) {\r\nm = kzalloc(sizeof(*m), GFP_ATOMIC);\r\nif (!m)\r\ncontinue;\r\nmemcpy(m->addr, ha->addr, ETH_ALEN);\r\nm->hit = 1;\r\nm->next = vp->mcast_list;\r\nvp->mcast_list = m;\r\n}\r\n}\r\n}\r\nstatic void __send_mc_list(struct vnet *vp, struct vnet_port *port)\r\n{\r\nstruct vio_net_mcast_info info;\r\nstruct vnet_mcast_entry *m, **pp;\r\nint n_addrs;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.tag.type = VIO_TYPE_CTRL;\r\ninfo.tag.stype = VIO_SUBTYPE_INFO;\r\ninfo.tag.stype_env = VNET_MCAST_INFO;\r\ninfo.tag.sid = vio_send_sid(&port->vio);\r\ninfo.set = 1;\r\nn_addrs = 0;\r\nfor (m = vp->mcast_list; m; m = m->next) {\r\nif (m->sent)\r\ncontinue;\r\nm->sent = 1;\r\nmemcpy(&info.mcast_addr[n_addrs * ETH_ALEN],\r\nm->addr, ETH_ALEN);\r\nif (++n_addrs == VNET_NUM_MCAST) {\r\ninfo.count = n_addrs;\r\n(void) vio_ldc_send(&port->vio, &info,\r\nsizeof(info));\r\nn_addrs = 0;\r\n}\r\n}\r\nif (n_addrs) {\r\ninfo.count = n_addrs;\r\n(void) vio_ldc_send(&port->vio, &info, sizeof(info));\r\n}\r\ninfo.set = 0;\r\nn_addrs = 0;\r\npp = &vp->mcast_list;\r\nwhile ((m = *pp) != NULL) {\r\nif (m->hit) {\r\nm->hit = 0;\r\npp = &m->next;\r\ncontinue;\r\n}\r\nmemcpy(&info.mcast_addr[n_addrs * ETH_ALEN],\r\nm->addr, ETH_ALEN);\r\nif (++n_addrs == VNET_NUM_MCAST) {\r\ninfo.count = n_addrs;\r\n(void) vio_ldc_send(&port->vio, &info,\r\nsizeof(info));\r\nn_addrs = 0;\r\n}\r\n*pp = m->next;\r\nkfree(m);\r\n}\r\nif (n_addrs) {\r\ninfo.count = n_addrs;\r\n(void) vio_ldc_send(&port->vio, &info, sizeof(info));\r\n}\r\n}\r\nstatic void vnet_set_rx_mode(struct net_device *dev)\r\n{\r\nstruct vnet *vp = netdev_priv(dev);\r\nstruct vnet_port *port;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(port, &vp->port_list, list) {\r\nif (port->switch_port) {\r\n__update_mc_list(vp, dev);\r\n__send_mc_list(vp, port);\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic int vnet_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif (new_mtu < 68 || new_mtu > 65535)\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic int vnet_set_mac_addr(struct net_device *dev, void *p)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic void vnet_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));\r\n}\r\nstatic u32 vnet_get_msglevel(struct net_device *dev)\r\n{\r\nstruct vnet *vp = netdev_priv(dev);\r\nreturn vp->msg_enable;\r\n}\r\nstatic void vnet_set_msglevel(struct net_device *dev, u32 value)\r\n{\r\nstruct vnet *vp = netdev_priv(dev);\r\nvp->msg_enable = value;\r\n}\r\nstatic void vnet_port_free_tx_bufs(struct vnet_port *port)\r\n{\r\nstruct vio_dring_state *dr;\r\nint i;\r\ndr = &port->vio.drings[VIO_DRIVER_TX_RING];\r\nif (dr->base == NULL)\r\nreturn;\r\nfor (i = 0; i < VNET_TX_RING_SIZE; i++) {\r\nstruct vio_net_desc *d;\r\nvoid *skb = port->tx_bufs[i].skb;\r\nif (!skb)\r\ncontinue;\r\nd = vio_dring_entry(dr, i);\r\nldc_unmap(port->vio.lp,\r\nport->tx_bufs[i].cookies,\r\nport->tx_bufs[i].ncookies);\r\ndev_kfree_skb(skb);\r\nport->tx_bufs[i].skb = NULL;\r\nd->hdr.state = VIO_DESC_FREE;\r\n}\r\nldc_free_exp_dring(port->vio.lp, dr->base,\r\n(dr->entry_size * dr->num_entries),\r\ndr->cookies, dr->ncookies);\r\ndr->base = NULL;\r\ndr->entry_size = 0;\r\ndr->num_entries = 0;\r\ndr->pending = 0;\r\ndr->ncookies = 0;\r\n}\r\nstatic void vnet_port_reset(struct vnet_port *port)\r\n{\r\ndel_timer(&port->clean_timer);\r\nvnet_port_free_tx_bufs(port);\r\nport->rmtu = 0;\r\nport->tso = true;\r\nport->tsolen = 0;\r\n}\r\nstatic int vnet_port_alloc_tx_ring(struct vnet_port *port)\r\n{\r\nstruct vio_dring_state *dr;\r\nunsigned long len, elen;\r\nint i, err, ncookies;\r\nvoid *dring;\r\ndr = &port->vio.drings[VIO_DRIVER_TX_RING];\r\nelen = sizeof(struct vio_net_desc) +\r\nsizeof(struct ldc_trans_cookie) * 2;\r\nif (vio_version_after_eq(&port->vio, 1, 7))\r\nelen += sizeof(struct vio_net_dext);\r\nlen = VNET_TX_RING_SIZE * elen;\r\nncookies = VIO_MAX_RING_COOKIES;\r\ndring = ldc_alloc_exp_dring(port->vio.lp, len,\r\ndr->cookies, &ncookies,\r\n(LDC_MAP_SHADOW |\r\nLDC_MAP_DIRECT |\r\nLDC_MAP_RW));\r\nif (IS_ERR(dring)) {\r\nerr = PTR_ERR(dring);\r\ngoto err_out;\r\n}\r\ndr->base = dring;\r\ndr->entry_size = elen;\r\ndr->num_entries = VNET_TX_RING_SIZE;\r\ndr->prod = dr->cons = 0;\r\nport->start_cons = true;\r\ndr->pending = VNET_TX_RING_SIZE;\r\ndr->ncookies = ncookies;\r\nfor (i = 0; i < VNET_TX_RING_SIZE; ++i) {\r\nstruct vio_net_desc *d;\r\nd = vio_dring_entry(dr, i);\r\nd->hdr.state = VIO_DESC_FREE;\r\n}\r\nreturn 0;\r\nerr_out:\r\nvnet_port_free_tx_bufs(port);\r\nreturn err;\r\n}\r\nstatic void vnet_poll_controller(struct net_device *dev)\r\n{\r\nstruct vnet *vp = netdev_priv(dev);\r\nstruct vnet_port *port;\r\nunsigned long flags;\r\nspin_lock_irqsave(&vp->lock, flags);\r\nif (!list_empty(&vp->port_list)) {\r\nport = list_entry(vp->port_list.next, struct vnet_port, list);\r\nnapi_schedule(&port->napi);\r\n}\r\nspin_unlock_irqrestore(&vp->lock, flags);\r\n}\r\nstatic struct vnet *vnet_new(const u64 *local_mac)\r\n{\r\nstruct net_device *dev;\r\nstruct vnet *vp;\r\nint err, i;\r\ndev = alloc_etherdev_mqs(sizeof(*vp), VNET_MAX_TXQS, 1);\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\ndev->needed_headroom = VNET_PACKET_SKIP + 8;\r\ndev->needed_tailroom = 8;\r\nfor (i = 0; i < ETH_ALEN; i++)\r\ndev->dev_addr[i] = (*local_mac >> (5 - i) * 8) & 0xff;\r\nvp = netdev_priv(dev);\r\nspin_lock_init(&vp->lock);\r\nvp->dev = dev;\r\nINIT_LIST_HEAD(&vp->port_list);\r\nfor (i = 0; i < VNET_PORT_HASH_SIZE; i++)\r\nINIT_HLIST_HEAD(&vp->port_hash[i]);\r\nINIT_LIST_HEAD(&vp->list);\r\nvp->local_mac = *local_mac;\r\ndev->netdev_ops = &vnet_ops;\r\ndev->ethtool_ops = &vnet_ethtool_ops;\r\ndev->watchdog_timeo = VNET_TX_TIMEOUT;\r\ndev->hw_features = NETIF_F_TSO | NETIF_F_GSO | NETIF_F_GSO_SOFTWARE |\r\nNETIF_F_HW_CSUM | NETIF_F_SG;\r\ndev->features = dev->hw_features;\r\nerr = register_netdev(dev);\r\nif (err) {\r\npr_err("Cannot register net device, aborting\n");\r\ngoto err_out_free_dev;\r\n}\r\nnetdev_info(dev, "Sun LDOM vnet %pM\n", dev->dev_addr);\r\nlist_add(&vp->list, &vnet_list);\r\nreturn vp;\r\nerr_out_free_dev:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic struct vnet *vnet_find_or_create(const u64 *local_mac)\r\n{\r\nstruct vnet *iter, *vp;\r\nmutex_lock(&vnet_list_mutex);\r\nvp = NULL;\r\nlist_for_each_entry(iter, &vnet_list, list) {\r\nif (iter->local_mac == *local_mac) {\r\nvp = iter;\r\nbreak;\r\n}\r\n}\r\nif (!vp)\r\nvp = vnet_new(local_mac);\r\nmutex_unlock(&vnet_list_mutex);\r\nreturn vp;\r\n}\r\nstatic void vnet_cleanup(void)\r\n{\r\nstruct vnet *vp;\r\nstruct net_device *dev;\r\nmutex_lock(&vnet_list_mutex);\r\nwhile (!list_empty(&vnet_list)) {\r\nvp = list_first_entry(&vnet_list, struct vnet, list);\r\nlist_del(&vp->list);\r\ndev = vp->dev;\r\nBUG_ON(!list_empty(&vp->port_list));\r\nunregister_netdev(dev);\r\nfree_netdev(dev);\r\n}\r\nmutex_unlock(&vnet_list_mutex);\r\n}\r\nstatic struct vnet *vnet_find_parent(struct mdesc_handle *hp,\r\nu64 port_node)\r\n{\r\nconst u64 *local_mac = NULL;\r\nu64 a;\r\nmdesc_for_each_arc(a, hp, port_node, MDESC_ARC_TYPE_BACK) {\r\nu64 target = mdesc_arc_target(hp, a);\r\nconst char *name;\r\nname = mdesc_get_property(hp, target, "name", NULL);\r\nif (!name || strcmp(name, "network"))\r\ncontinue;\r\nlocal_mac = mdesc_get_property(hp, target,\r\nlocal_mac_prop, NULL);\r\nif (local_mac)\r\nbreak;\r\n}\r\nif (!local_mac)\r\nreturn ERR_PTR(-ENODEV);\r\nreturn vnet_find_or_create(local_mac);\r\n}\r\nstatic void print_version(void)\r\n{\r\nprintk_once(KERN_INFO "%s", version);\r\n}\r\nstatic void\r\nvnet_port_add_txq(struct vnet_port *port)\r\n{\r\nstruct vnet *vp = port->vp;\r\nint n;\r\nn = vp->nports++;\r\nn = n & (VNET_MAX_TXQS - 1);\r\nport->q_index = n;\r\nnetif_tx_wake_queue(netdev_get_tx_queue(vp->dev, port->q_index));\r\n}\r\nstatic void\r\nvnet_port_rm_txq(struct vnet_port *port)\r\n{\r\nport->vp->nports--;\r\nnetif_tx_stop_queue(netdev_get_tx_queue(port->vp->dev, port->q_index));\r\n}\r\nstatic int vnet_port_probe(struct vio_dev *vdev, const struct vio_device_id *id)\r\n{\r\nstruct mdesc_handle *hp;\r\nstruct vnet_port *port;\r\nunsigned long flags;\r\nstruct vnet *vp;\r\nconst u64 *rmac;\r\nint len, i, err, switch_port;\r\nprint_version();\r\nhp = mdesc_grab();\r\nvp = vnet_find_parent(hp, vdev->mp);\r\nif (IS_ERR(vp)) {\r\npr_err("Cannot find port parent vnet\n");\r\nerr = PTR_ERR(vp);\r\ngoto err_out_put_mdesc;\r\n}\r\nrmac = mdesc_get_property(hp, vdev->mp, remote_macaddr_prop, &len);\r\nerr = -ENODEV;\r\nif (!rmac) {\r\npr_err("Port lacks %s property\n", remote_macaddr_prop);\r\ngoto err_out_put_mdesc;\r\n}\r\nport = kzalloc(sizeof(*port), GFP_KERNEL);\r\nerr = -ENOMEM;\r\nif (!port)\r\ngoto err_out_put_mdesc;\r\nfor (i = 0; i < ETH_ALEN; i++)\r\nport->raddr[i] = (*rmac >> (5 - i) * 8) & 0xff;\r\nport->vp = vp;\r\nerr = vio_driver_init(&port->vio, vdev, VDEV_NETWORK,\r\nvnet_versions, ARRAY_SIZE(vnet_versions),\r\n&vnet_vio_ops, vp->dev->name);\r\nif (err)\r\ngoto err_out_free_port;\r\nerr = vio_ldc_alloc(&port->vio, &vnet_ldc_cfg, port);\r\nif (err)\r\ngoto err_out_free_port;\r\nnetif_napi_add(port->vp->dev, &port->napi, vnet_poll, NAPI_POLL_WEIGHT);\r\nINIT_HLIST_NODE(&port->hash);\r\nINIT_LIST_HEAD(&port->list);\r\nswitch_port = 0;\r\nif (mdesc_get_property(hp, vdev->mp, "switch-port", NULL) != NULL)\r\nswitch_port = 1;\r\nport->switch_port = switch_port;\r\nport->tso = true;\r\nport->tsolen = 0;\r\nspin_lock_irqsave(&vp->lock, flags);\r\nif (switch_port)\r\nlist_add_rcu(&port->list, &vp->port_list);\r\nelse\r\nlist_add_tail_rcu(&port->list, &vp->port_list);\r\nhlist_add_head_rcu(&port->hash,\r\n&vp->port_hash[vnet_hashfn(port->raddr)]);\r\nvnet_port_add_txq(port);\r\nspin_unlock_irqrestore(&vp->lock, flags);\r\ndev_set_drvdata(&vdev->dev, port);\r\npr_info("%s: PORT ( remote-mac %pM%s )\n",\r\nvp->dev->name, port->raddr, switch_port ? " switch-port" : "");\r\nsetup_timer(&port->clean_timer, vnet_clean_timer_expire,\r\n(unsigned long)port);\r\nnapi_enable(&port->napi);\r\nvio_port_up(&port->vio);\r\nmdesc_release(hp);\r\nreturn 0;\r\nerr_out_free_port:\r\nkfree(port);\r\nerr_out_put_mdesc:\r\nmdesc_release(hp);\r\nreturn err;\r\n}\r\nstatic int vnet_port_remove(struct vio_dev *vdev)\r\n{\r\nstruct vnet_port *port = dev_get_drvdata(&vdev->dev);\r\nif (port) {\r\ndel_timer_sync(&port->vio.timer);\r\nnapi_disable(&port->napi);\r\nlist_del_rcu(&port->list);\r\nhlist_del_rcu(&port->hash);\r\nsynchronize_rcu();\r\ndel_timer_sync(&port->clean_timer);\r\nvnet_port_rm_txq(port);\r\nnetif_napi_del(&port->napi);\r\nvnet_port_free_tx_bufs(port);\r\nvio_ldc_free(&port->vio);\r\ndev_set_drvdata(&vdev->dev, NULL);\r\nkfree(port);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init vnet_init(void)\r\n{\r\nreturn vio_register_driver(&vnet_port_driver);\r\n}\r\nstatic void __exit vnet_exit(void)\r\n{\r\nvio_unregister_driver(&vnet_port_driver);\r\nvnet_cleanup();\r\n}
