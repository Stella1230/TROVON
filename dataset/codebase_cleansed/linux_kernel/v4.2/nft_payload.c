static void nft_payload_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_payload *priv = nft_expr_priv(expr);\r\nconst struct sk_buff *skb = pkt->skb;\r\nu32 *dest = &regs->data[priv->dreg];\r\nint offset;\r\nswitch (priv->base) {\r\ncase NFT_PAYLOAD_LL_HEADER:\r\nif (!skb_mac_header_was_set(skb))\r\ngoto err;\r\noffset = skb_mac_header(skb) - skb->data;\r\nbreak;\r\ncase NFT_PAYLOAD_NETWORK_HEADER:\r\noffset = skb_network_offset(skb);\r\nbreak;\r\ncase NFT_PAYLOAD_TRANSPORT_HEADER:\r\noffset = pkt->xt.thoff;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\noffset += priv->offset;\r\ndest[priv->len / NFT_REG32_SIZE] = 0;\r\nif (skb_copy_bits(skb, offset, dest, priv->len) < 0)\r\ngoto err;\r\nreturn;\r\nerr:\r\nregs->verdict.code = NFT_BREAK;\r\n}\r\nstatic int nft_payload_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_payload *priv = nft_expr_priv(expr);\r\npriv->base = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_BASE]));\r\npriv->offset = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_OFFSET]));\r\npriv->len = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_LEN]));\r\npriv->dreg = nft_parse_register(tb[NFTA_PAYLOAD_DREG]);\r\nreturn nft_validate_register_store(ctx, priv->dreg, NULL,\r\nNFT_DATA_VALUE, priv->len);\r\n}\r\nstatic int nft_payload_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_payload *priv = nft_expr_priv(expr);\r\nif (nft_dump_register(skb, NFTA_PAYLOAD_DREG, priv->dreg) ||\r\nnla_put_be32(skb, NFTA_PAYLOAD_BASE, htonl(priv->base)) ||\r\nnla_put_be32(skb, NFTA_PAYLOAD_OFFSET, htonl(priv->offset)) ||\r\nnla_put_be32(skb, NFTA_PAYLOAD_LEN, htonl(priv->len)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic const struct nft_expr_ops *\r\nnft_payload_select_ops(const struct nft_ctx *ctx,\r\nconst struct nlattr * const tb[])\r\n{\r\nenum nft_payload_bases base;\r\nunsigned int offset, len;\r\nif (tb[NFTA_PAYLOAD_DREG] == NULL ||\r\ntb[NFTA_PAYLOAD_BASE] == NULL ||\r\ntb[NFTA_PAYLOAD_OFFSET] == NULL ||\r\ntb[NFTA_PAYLOAD_LEN] == NULL)\r\nreturn ERR_PTR(-EINVAL);\r\nbase = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_BASE]));\r\nswitch (base) {\r\ncase NFT_PAYLOAD_LL_HEADER:\r\ncase NFT_PAYLOAD_NETWORK_HEADER:\r\ncase NFT_PAYLOAD_TRANSPORT_HEADER:\r\nbreak;\r\ndefault:\r\nreturn ERR_PTR(-EOPNOTSUPP);\r\n}\r\noffset = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_OFFSET]));\r\nlen = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_LEN]));\r\nif (len <= 4 && is_power_of_2(len) && IS_ALIGNED(offset, len) &&\r\nbase != NFT_PAYLOAD_LL_HEADER)\r\nreturn &nft_payload_fast_ops;\r\nelse\r\nreturn &nft_payload_ops;\r\n}\r\nint __init nft_payload_module_init(void)\r\n{\r\nreturn nft_register_expr(&nft_payload_type);\r\n}\r\nvoid nft_payload_module_exit(void)\r\n{\r\nnft_unregister_expr(&nft_payload_type);\r\n}
