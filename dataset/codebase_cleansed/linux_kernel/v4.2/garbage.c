struct sock *unix_get_socket(struct file *filp)\r\n{\r\nstruct sock *u_sock = NULL;\r\nstruct inode *inode = file_inode(filp);\r\nif (S_ISSOCK(inode->i_mode) && !(filp->f_mode & FMODE_PATH)) {\r\nstruct socket *sock = SOCKET_I(inode);\r\nstruct sock *s = sock->sk;\r\nif (s && sock->ops && sock->ops->family == PF_UNIX)\r\nu_sock = s;\r\n}\r\nreturn u_sock;\r\n}\r\nvoid unix_inflight(struct file *fp)\r\n{\r\nstruct sock *s = unix_get_socket(fp);\r\nif (s) {\r\nstruct unix_sock *u = unix_sk(s);\r\nspin_lock(&unix_gc_lock);\r\nif (atomic_long_inc_return(&u->inflight) == 1) {\r\nBUG_ON(!list_empty(&u->link));\r\nlist_add_tail(&u->link, &gc_inflight_list);\r\n} else {\r\nBUG_ON(list_empty(&u->link));\r\n}\r\nunix_tot_inflight++;\r\nspin_unlock(&unix_gc_lock);\r\n}\r\n}\r\nvoid unix_notinflight(struct file *fp)\r\n{\r\nstruct sock *s = unix_get_socket(fp);\r\nif (s) {\r\nstruct unix_sock *u = unix_sk(s);\r\nspin_lock(&unix_gc_lock);\r\nBUG_ON(list_empty(&u->link));\r\nif (atomic_long_dec_and_test(&u->inflight))\r\nlist_del_init(&u->link);\r\nunix_tot_inflight--;\r\nspin_unlock(&unix_gc_lock);\r\n}\r\n}\r\nstatic void scan_inflight(struct sock *x, void (*func)(struct unix_sock *),\r\nstruct sk_buff_head *hitlist)\r\n{\r\nstruct sk_buff *skb;\r\nstruct sk_buff *next;\r\nspin_lock(&x->sk_receive_queue.lock);\r\nskb_queue_walk_safe(&x->sk_receive_queue, skb, next) {\r\nif (UNIXCB(skb).fp) {\r\nbool hit = false;\r\nint nfd = UNIXCB(skb).fp->count;\r\nstruct file **fp = UNIXCB(skb).fp->fp;\r\nwhile (nfd--) {\r\nstruct sock *sk = unix_get_socket(*fp++);\r\nif (sk) {\r\nstruct unix_sock *u = unix_sk(sk);\r\nif (test_bit(UNIX_GC_CANDIDATE, &u->gc_flags)) {\r\nhit = true;\r\nfunc(u);\r\n}\r\n}\r\n}\r\nif (hit && hitlist != NULL) {\r\n__skb_unlink(skb, &x->sk_receive_queue);\r\n__skb_queue_tail(hitlist, skb);\r\n}\r\n}\r\n}\r\nspin_unlock(&x->sk_receive_queue.lock);\r\n}\r\nstatic void scan_children(struct sock *x, void (*func)(struct unix_sock *),\r\nstruct sk_buff_head *hitlist)\r\n{\r\nif (x->sk_state != TCP_LISTEN) {\r\nscan_inflight(x, func, hitlist);\r\n} else {\r\nstruct sk_buff *skb;\r\nstruct sk_buff *next;\r\nstruct unix_sock *u;\r\nLIST_HEAD(embryos);\r\nspin_lock(&x->sk_receive_queue.lock);\r\nskb_queue_walk_safe(&x->sk_receive_queue, skb, next) {\r\nu = unix_sk(skb->sk);\r\nBUG_ON(!list_empty(&u->link));\r\nlist_add_tail(&u->link, &embryos);\r\n}\r\nspin_unlock(&x->sk_receive_queue.lock);\r\nwhile (!list_empty(&embryos)) {\r\nu = list_entry(embryos.next, struct unix_sock, link);\r\nscan_inflight(&u->sk, func, hitlist);\r\nlist_del_init(&u->link);\r\n}\r\n}\r\n}\r\nstatic void dec_inflight(struct unix_sock *usk)\r\n{\r\natomic_long_dec(&usk->inflight);\r\n}\r\nstatic void inc_inflight(struct unix_sock *usk)\r\n{\r\natomic_long_inc(&usk->inflight);\r\n}\r\nstatic void inc_inflight_move_tail(struct unix_sock *u)\r\n{\r\natomic_long_inc(&u->inflight);\r\nif (test_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags))\r\nlist_move_tail(&u->link, &gc_candidates);\r\n}\r\nvoid wait_for_unix_gc(void)\r\n{\r\nif (unix_tot_inflight > UNIX_INFLIGHT_TRIGGER_GC && !gc_in_progress)\r\nunix_gc();\r\nwait_event(unix_gc_wait, gc_in_progress == false);\r\n}\r\nvoid unix_gc(void)\r\n{\r\nstruct unix_sock *u;\r\nstruct unix_sock *next;\r\nstruct sk_buff_head hitlist;\r\nstruct list_head cursor;\r\nLIST_HEAD(not_cycle_list);\r\nspin_lock(&unix_gc_lock);\r\nif (gc_in_progress)\r\ngoto out;\r\ngc_in_progress = true;\r\nlist_for_each_entry_safe(u, next, &gc_inflight_list, link) {\r\nlong total_refs;\r\nlong inflight_refs;\r\ntotal_refs = file_count(u->sk.sk_socket->file);\r\ninflight_refs = atomic_long_read(&u->inflight);\r\nBUG_ON(inflight_refs < 1);\r\nBUG_ON(total_refs < inflight_refs);\r\nif (total_refs == inflight_refs) {\r\nlist_move_tail(&u->link, &gc_candidates);\r\n__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);\r\n__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);\r\n}\r\n}\r\nlist_for_each_entry(u, &gc_candidates, link)\r\nscan_children(&u->sk, dec_inflight, NULL);\r\nlist_add(&cursor, &gc_candidates);\r\nwhile (cursor.next != &gc_candidates) {\r\nu = list_entry(cursor.next, struct unix_sock, link);\r\nlist_move(&cursor, &u->link);\r\nif (atomic_long_read(&u->inflight) > 0) {\r\nlist_move_tail(&u->link, &not_cycle_list);\r\n__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);\r\nscan_children(&u->sk, inc_inflight_move_tail, NULL);\r\n}\r\n}\r\nlist_del(&cursor);\r\nwhile (!list_empty(&not_cycle_list)) {\r\nu = list_entry(not_cycle_list.next, struct unix_sock, link);\r\n__clear_bit(UNIX_GC_CANDIDATE, &u->gc_flags);\r\nlist_move_tail(&u->link, &gc_inflight_list);\r\n}\r\nskb_queue_head_init(&hitlist);\r\nlist_for_each_entry(u, &gc_candidates, link)\r\nscan_children(&u->sk, inc_inflight, &hitlist);\r\nspin_unlock(&unix_gc_lock);\r\n__skb_queue_purge(&hitlist);\r\nspin_lock(&unix_gc_lock);\r\nBUG_ON(!list_empty(&gc_candidates));\r\ngc_in_progress = false;\r\nwake_up(&unix_gc_wait);\r\nout:\r\nspin_unlock(&unix_gc_lock);\r\n}
