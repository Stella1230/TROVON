static void sh7786_pci_fixup(struct pci_dev *dev)\r\n{\r\nif (pci_is_root_bus(dev->bus) && dev->devfn == 0) {\r\nint i;\r\nfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\r\ndev->resource[i].start = 0;\r\ndev->resource[i].end = 0;\r\ndev->resource[i].flags = 0;\r\n}\r\n}\r\n}\r\nstatic int __init phy_wait_for_ack(struct pci_channel *chan)\r\n{\r\nunsigned int timeout = 100;\r\nwhile (timeout--) {\r\nif (pci_read_reg(chan, SH4A_PCIEPHYADRR) & (1 << BITS_ACK))\r\nreturn 0;\r\nudelay(100);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int __init pci_wait_for_irq(struct pci_channel *chan, unsigned int mask)\r\n{\r\nunsigned int timeout = 100;\r\nwhile (timeout--) {\r\nif ((pci_read_reg(chan, SH4A_PCIEINTR) & mask) == mask)\r\nreturn 0;\r\nudelay(100);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void __init phy_write_reg(struct pci_channel *chan, unsigned int addr,\r\nunsigned int lane, unsigned int data)\r\n{\r\nunsigned long phyaddr;\r\nphyaddr = (1 << BITS_CMD) + ((lane & 0xf) << BITS_LANE) +\r\n((addr & 0xff) << BITS_ADR);\r\npci_write_reg(chan, data, SH4A_PCIEPHYDOUTR);\r\npci_write_reg(chan, phyaddr, SH4A_PCIEPHYADRR);\r\nphy_wait_for_ack(chan);\r\npci_write_reg(chan, 0, SH4A_PCIEPHYDOUTR);\r\npci_write_reg(chan, 0, SH4A_PCIEPHYADRR);\r\nphy_wait_for_ack(chan);\r\n}\r\nstatic int __init pcie_clk_init(struct sh7786_pcie_port *port)\r\n{\r\nstruct pci_channel *chan = port->hose;\r\nstruct clk *clk;\r\nchar fclk_name[16];\r\nint ret;\r\nret = clk_register(&fixed_pciexclkp);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nsnprintf(fclk_name, sizeof(fclk_name), "pcie%d_fck", port->index);\r\nport->fclk = clk_get(NULL, fclk_name);\r\nif (IS_ERR(port->fclk)) {\r\nret = PTR_ERR(port->fclk);\r\ngoto err_fclk;\r\n}\r\nclk_enable(port->fclk);\r\nclk = &port->phy_clk;\r\nmemset(clk, 0, sizeof(struct clk));\r\nclk->parent = &fixed_pciexclkp;\r\nclk->enable_reg = (void __iomem *)(chan->reg_base + SH4A_PCIEPHYCTLR);\r\nclk->enable_bit = BITS_CKE;\r\nret = sh_clk_mstp_register(clk, 1);\r\nif (unlikely(ret < 0))\r\ngoto err_phy;\r\nreturn 0;\r\nerr_phy:\r\nclk_disable(port->fclk);\r\nclk_put(port->fclk);\r\nerr_fclk:\r\nclk_unregister(&fixed_pciexclkp);\r\nreturn ret;\r\n}\r\nstatic int __init phy_init(struct sh7786_pcie_port *port)\r\n{\r\nstruct pci_channel *chan = port->hose;\r\nunsigned int timeout = 100;\r\nclk_enable(&port->phy_clk);\r\nphy_write_reg(chan, 0x60, 0xf, 0x004b008b);\r\nphy_write_reg(chan, 0x61, 0xf, 0x00007b41);\r\nphy_write_reg(chan, 0x64, 0xf, 0x00ff4f00);\r\nphy_write_reg(chan, 0x65, 0xf, 0x09070907);\r\nphy_write_reg(chan, 0x66, 0xf, 0x00000010);\r\nphy_write_reg(chan, 0x74, 0xf, 0x0007001c);\r\nphy_write_reg(chan, 0x79, 0xf, 0x01fc000d);\r\nphy_write_reg(chan, 0xb0, 0xf, 0x00000610);\r\nphy_write_reg(chan, 0x67, 0x1, 0x00000400);\r\nclk_disable(&port->phy_clk);\r\nwhile (timeout--) {\r\nif (pci_read_reg(chan, SH4A_PCIEPHYSR))\r\nreturn 0;\r\nudelay(100);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void __init pcie_reset(struct sh7786_pcie_port *port)\r\n{\r\nstruct pci_channel *chan = port->hose;\r\npci_write_reg(chan, 1, SH4A_PCIESRSTR);\r\npci_write_reg(chan, 0, SH4A_PCIETCTLR);\r\npci_write_reg(chan, 0, SH4A_PCIESRSTR);\r\npci_write_reg(chan, 0, SH4A_PCIETXVC0SR);\r\n}\r\nstatic int __init pcie_init(struct sh7786_pcie_port *port)\r\n{\r\nstruct pci_channel *chan = port->hose;\r\nunsigned int data;\r\nphys_addr_t memphys;\r\nsize_t memsize;\r\nint ret, i, win;\r\npcie_reset(port);\r\npci_write_reg(chan, PCI_CLASS_BRIDGE_PCI << 16, SH4A_PCIEIDSETR1);\r\ndata = pci_read_reg(chan, SH4A_PCIEEXPCAP0);\r\ndata &= ~(PCI_EXP_FLAGS_TYPE << 16);\r\nif (port->endpoint)\r\ndata |= PCI_EXP_TYPE_ENDPOINT << 20;\r\nelse\r\ndata |= PCI_EXP_TYPE_ROOT_PORT << 20;\r\ndata |= PCI_CAP_ID_EXP;\r\npci_write_reg(chan, data, SH4A_PCIEEXPCAP0);\r\npci_write_reg(chan, PCI_EXP_LNKCAP_DLLLARC, SH4A_PCIEEXPCAP3);\r\ndata = pci_read_reg(chan, SH4A_PCIEEXPCAP4);\r\ndata &= ~PCI_EXP_LNKCTL_ASPMC;\r\ndata |= PCI_EXP_LNKCTL_ES | 1;\r\npci_write_reg(chan, data, SH4A_PCIEEXPCAP4);\r\ndata = pci_read_reg(chan, SH4A_PCIEEXPCAP5);\r\ndata &= ~PCI_EXP_SLTCAP_PSN;\r\ndata |= (port->index + 1) << 19;\r\npci_write_reg(chan, data, SH4A_PCIEEXPCAP5);\r\ndata = pci_read_reg(chan, SH4A_PCIETLCTLR);\r\ndata &= ~0x3f00;\r\ndata |= 0x32 << 8;\r\npci_write_reg(chan, data, SH4A_PCIETLCTLR);\r\ndata = pci_read_reg(chan, SH4A_PCIEMACCTLR);\r\ndata &= ~PCIEMACCTLR_SCR_DIS;\r\ndata |= (0xff << 16);\r\npci_write_reg(chan, data, SH4A_PCIEMACCTLR);\r\nmemphys = __pa(memory_start);\r\nmemsize = roundup_pow_of_two(memory_end - memory_start);\r\nif (memsize > SZ_512M) {\r\npci_write_reg(chan, memphys + SZ_512M, SH4A_PCIELAR1);\r\npci_write_reg(chan, ((memsize - SZ_512M) - SZ_256) | 1,\r\nSH4A_PCIELAMR1);\r\nmemsize = SZ_512M;\r\n} else {\r\npci_write_reg(chan, 0, SH4A_PCIELAR1);\r\npci_write_reg(chan, 0, SH4A_PCIELAMR1);\r\n}\r\npci_write_reg(chan, memphys, SH4A_PCIELAR0);\r\npci_write_reg(chan, (memsize - SZ_256) | 1, SH4A_PCIELAMR0);\r\ndata = pci_read_reg(chan, SH4A_PCIETCTLR);\r\ndata |= 0x1;\r\npci_write_reg(chan, data, SH4A_PCIETCTLR);\r\nmdelay(100);\r\ndata = pci_read_reg(chan, SH4A_PCIEDLINTENR);\r\ndata |= PCIEDLINTENR_DLL_ACT_ENABLE;\r\npci_write_reg(chan, data, SH4A_PCIEDLINTENR);\r\ndata = pci_read_reg(chan, SH4A_PCIEMACCTLR);\r\ndata |= PCIEMACCTLR_SCR_DIS | (0xff << 16);\r\npci_write_reg(chan, data, SH4A_PCIEMACCTLR);\r\nret = pci_wait_for_irq(chan, MASK_INT_TX_CTRL);\r\ndata = pci_read_reg(chan, SH4A_PCIEPCICONF1);\r\ndata &= ~(PCI_STATUS_DEVSEL_MASK << 16);\r\ndata |= PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER |\r\n(PCI_STATUS_CAP_LIST | PCI_STATUS_DEVSEL_FAST) << 16;\r\npci_write_reg(chan, data, SH4A_PCIEPCICONF1);\r\npci_write_reg(chan, 0x80888000, SH4A_PCIETXVC0DCTLR);\r\npci_write_reg(chan, 0x00222000, SH4A_PCIERXVC0DCTLR);\r\nwmb();\r\nif (ret == 0) {\r\ndata = pci_read_reg(chan, SH4A_PCIEMACSR);\r\nprintk(KERN_NOTICE "PCI: PCIe#%d x%d link detected\n",\r\nport->index, (data >> 20) & 0x3f);\r\n} else\r\nprintk(KERN_NOTICE "PCI: PCIe#%d link down\n",\r\nport->index);\r\nfor (i = win = 0; i < chan->nr_resources; i++) {\r\nstruct resource *res = chan->resources + i;\r\nresource_size_t size;\r\nu32 mask;\r\nif ((res->flags & IORESOURCE_MEM_32BIT) && __in_29bit_mode())\r\ncontinue;\r\npci_write_reg(chan, 0x00000000, SH4A_PCIEPTCTLR(win));\r\nsize = resource_size(res);\r\nmask = (roundup_pow_of_two(size) / SZ_256K) - 1;\r\npci_write_reg(chan, mask << 18, SH4A_PCIEPAMR(win));\r\npci_write_reg(chan, upper_32_bits(res->start),\r\nSH4A_PCIEPARH(win));\r\npci_write_reg(chan, lower_32_bits(res->start),\r\nSH4A_PCIEPARL(win));\r\nmask = MASK_PARE;\r\nif (res->flags & IORESOURCE_IO)\r\nmask |= MASK_SPC;\r\npci_write_reg(chan, mask, SH4A_PCIEPTCTLR(win));\r\nwin++;\r\n}\r\nreturn 0;\r\n}\r\nint __init pcibios_map_platform_irq(const struct pci_dev *pdev, u8 slot, u8 pin)\r\n{\r\nreturn evt2irq(0xae0);\r\n}\r\nstatic int __init sh7786_pcie_core_init(void)\r\n{\r\nreturn test_mode_pin(MODE_PIN12) ? 3 : 2;\r\n}\r\nstatic void __init sh7786_pcie_init_hw(void *data, async_cookie_t cookie)\r\n{\r\nstruct sh7786_pcie_port *port = data;\r\nint ret;\r\nport->endpoint = test_mode_pin(MODE_PIN11);\r\nret = pcie_clk_init(port);\r\nif (unlikely(ret < 0)) {\r\npr_err("clock initialization failed for port#%d\n",\r\nport->index);\r\nreturn;\r\n}\r\nret = phy_init(port);\r\nif (unlikely(ret < 0)) {\r\npr_err("phy initialization failed for port#%d\n",\r\nport->index);\r\nreturn;\r\n}\r\nret = pcie_init(port);\r\nif (unlikely(ret < 0)) {\r\npr_err("core initialization failed for port#%d\n",\r\nport->index);\r\nreturn;\r\n}\r\nasync_synchronize_cookie(cookie);\r\nregister_pci_controller(port->hose);\r\n}\r\nstatic int __init sh7786_pcie_init(void)\r\n{\r\nstruct clk *platclk;\r\nint i;\r\nprintk(KERN_NOTICE "PCI: Starting initialization.\n");\r\nsh7786_pcie_hwops = &sh7786_65nm_pcie_hwops;\r\nnr_ports = sh7786_pcie_hwops->core_init();\r\nBUG_ON(nr_ports > ARRAY_SIZE(sh7786_pci_channels));\r\nif (unlikely(nr_ports == 0))\r\nreturn -ENODEV;\r\nsh7786_pcie_ports = kzalloc(nr_ports * sizeof(struct sh7786_pcie_port),\r\nGFP_KERNEL);\r\nif (unlikely(!sh7786_pcie_ports))\r\nreturn -ENOMEM;\r\nplatclk = clk_get(NULL, "pcie_plat_clk");\r\nif (IS_ERR(platclk)) {\r\nplatclk = NULL;\r\n}\r\nclk_enable(platclk);\r\nprintk(KERN_NOTICE "PCI: probing %d ports.\n", nr_ports);\r\nfor (i = 0; i < nr_ports; i++) {\r\nstruct sh7786_pcie_port *port = sh7786_pcie_ports + i;\r\nport->index = i;\r\nport->hose = sh7786_pci_channels + i;\r\nport->hose->io_map_base = port->hose->resources[0].start;\r\nasync_schedule(sh7786_pcie_hwops->port_init_hw, port);\r\n}\r\nasync_synchronize_full();\r\nreturn 0;\r\n}
