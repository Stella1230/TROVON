static void pmic_program_irqtype(int gpio, int type)\r\n{\r\nif (type & IRQ_TYPE_EDGE_RISING)\r\nintel_scu_ipc_update_register(GPIO0 + gpio, 0x20, 0x20);\r\nelse\r\nintel_scu_ipc_update_register(GPIO0 + gpio, 0x00, 0x20);\r\nif (type & IRQ_TYPE_EDGE_FALLING)\r\nintel_scu_ipc_update_register(GPIO0 + gpio, 0x10, 0x10);\r\nelse\r\nintel_scu_ipc_update_register(GPIO0 + gpio, 0x00, 0x10);\r\n}\r\nstatic int pmic_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nif (offset >= 8) {\r\npr_err("only pin 0-7 support input\n");\r\nreturn -1;\r\n}\r\nreturn intel_scu_ipc_update_register(GPIO0 + offset,\r\nGPIO_DIR, GPIO_DIR);\r\n}\r\nstatic int pmic_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nint rc = 0;\r\nif (offset < 8)\r\nrc = intel_scu_ipc_update_register(GPIO0 + offset,\r\nGPIO_DRV | (value ? GPIO_DOU : 0),\r\nGPIO_DRV | GPIO_DOU | GPIO_DIR);\r\nelse if (offset < 16)\r\nrc = intel_scu_ipc_update_register(GPOSWCTL0 + offset - 8,\r\nGPOSW_DRV | (value ? GPOSW_DOU : 0),\r\nGPOSW_DRV | GPOSW_DOU | GPOSW_RDRV);\r\nelse if (offset > 15 && offset < 24)\r\nrc = intel_scu_ipc_update_register(GPO,\r\nvalue ? 1 << (offset - 16) : 0,\r\n1 << (offset - 16));\r\nelse {\r\npr_err("invalid PMIC GPIO pin %d!\n", offset);\r\nWARN_ON(1);\r\n}\r\nreturn rc;\r\n}\r\nstatic int pmic_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nu8 r;\r\nint ret;\r\nif (offset >= 8)\r\nreturn -EOPNOTSUPP;\r\nret = intel_scu_ipc_ioread8(GPIO0 + offset, &r);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn r & GPIO_DIN;\r\n}\r\nstatic void pmic_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nif (offset < 8)\r\nintel_scu_ipc_update_register(GPIO0 + offset,\r\nGPIO_DRV | (value ? GPIO_DOU : 0),\r\nGPIO_DRV | GPIO_DOU);\r\nelse if (offset < 16)\r\nintel_scu_ipc_update_register(GPOSWCTL0 + offset - 8,\r\nGPOSW_DRV | (value ? GPOSW_DOU : 0),\r\nGPOSW_DRV | GPOSW_DOU | GPOSW_RDRV);\r\nelse if (offset > 15 && offset < 24)\r\nintel_scu_ipc_update_register(GPO,\r\nvalue ? 1 << (offset - 16) : 0,\r\n1 << (offset - 16));\r\n}\r\nstatic int pmic_irq_type(struct irq_data *data, unsigned type)\r\n{\r\nstruct pmic_gpio *pg = irq_data_get_irq_chip_data(data);\r\nu32 gpio = data->irq - pg->irq_base;\r\nif (gpio >= pg->chip.ngpio)\r\nreturn -EINVAL;\r\npg->trigger_type = type;\r\npg->update_type = gpio | GPIO_UPDATE_TYPE;\r\nreturn 0;\r\n}\r\nstatic int pmic_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct pmic_gpio *pg = container_of(chip, struct pmic_gpio, chip);\r\nreturn pg->irq_base + offset;\r\n}\r\nstatic void pmic_bus_lock(struct irq_data *data)\r\n{\r\nstruct pmic_gpio *pg = irq_data_get_irq_chip_data(data);\r\nmutex_lock(&pg->buslock);\r\n}\r\nstatic void pmic_bus_sync_unlock(struct irq_data *data)\r\n{\r\nstruct pmic_gpio *pg = irq_data_get_irq_chip_data(data);\r\nif (pg->update_type) {\r\nunsigned int gpio = pg->update_type & ~GPIO_UPDATE_TYPE;\r\npmic_program_irqtype(gpio, pg->trigger_type);\r\npg->update_type = 0;\r\n}\r\nmutex_unlock(&pg->buslock);\r\n}\r\nstatic void pmic_irq_unmask(struct irq_data *data) { }\r\nstatic void pmic_irq_mask(struct irq_data *data) { }\r\nstatic irqreturn_t pmic_irq_handler(int irq, void *data)\r\n{\r\nstruct pmic_gpio *pg = data;\r\nu8 intsts = *((u8 *)pg->gpiointr + 4);\r\nint gpio;\r\nirqreturn_t ret = IRQ_NONE;\r\nfor (gpio = 0; gpio < 8; gpio++) {\r\nif (intsts & (1 << gpio)) {\r\npr_debug("pmic pin %d triggered\n", gpio);\r\ngeneric_handle_irq(pg->irq_base + gpio);\r\nret = IRQ_HANDLED;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int platform_pmic_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nint irq = platform_get_irq(pdev, 0);\r\nstruct intel_pmic_gpio_platform_data *pdata = dev->platform_data;\r\nstruct pmic_gpio *pg;\r\nint retval;\r\nint i;\r\nif (irq < 0) {\r\ndev_dbg(dev, "no IRQ line\n");\r\nreturn -EINVAL;\r\n}\r\nif (!pdata || !pdata->gpio_base || !pdata->irq_base) {\r\ndev_dbg(dev, "incorrect or missing platform data\n");\r\nreturn -EINVAL;\r\n}\r\npg = kzalloc(sizeof(*pg), GFP_KERNEL);\r\nif (!pg)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(dev, pg);\r\npg->irq = irq;\r\npg->gpiointr = ioremap_nocache(pdata->gpiointr, 8);\r\nif (!pg->gpiointr) {\r\npr_err("Can not map GPIOINT\n");\r\nretval = -EINVAL;\r\ngoto err2;\r\n}\r\npg->irq_base = pdata->irq_base;\r\npg->chip.label = "intel_pmic";\r\npg->chip.direction_input = pmic_gpio_direction_input;\r\npg->chip.direction_output = pmic_gpio_direction_output;\r\npg->chip.get = pmic_gpio_get;\r\npg->chip.set = pmic_gpio_set;\r\npg->chip.to_irq = pmic_gpio_to_irq;\r\npg->chip.base = pdata->gpio_base;\r\npg->chip.ngpio = NUM_GPIO;\r\npg->chip.can_sleep = 1;\r\npg->chip.dev = dev;\r\nmutex_init(&pg->buslock);\r\npg->chip.dev = dev;\r\nretval = gpiochip_add(&pg->chip);\r\nif (retval) {\r\npr_err("Can not add pmic gpio chip\n");\r\ngoto err;\r\n}\r\nretval = request_irq(pg->irq, pmic_irq_handler, 0, "pmic", pg);\r\nif (retval) {\r\npr_warn("Interrupt request failed\n");\r\ngoto fail_request_irq;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\nirq_set_chip_and_handler_name(i + pg->irq_base,\r\n&pmic_irqchip,\r\nhandle_simple_irq,\r\n"demux");\r\nirq_set_chip_data(i + pg->irq_base, pg);\r\n}\r\nreturn 0;\r\nfail_request_irq:\r\ngpiochip_remove(&pg->chip);\r\nerr:\r\niounmap(pg->gpiointr);\r\nerr2:\r\nkfree(pg);\r\nreturn retval;\r\n}\r\nstatic int __init platform_pmic_gpio_init(void)\r\n{\r\nreturn platform_driver_register(&platform_pmic_gpio_driver);\r\n}
