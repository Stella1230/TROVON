int mga_do_wait_for_idle(drm_mga_private_t *dev_priv)\r\n{\r\nu32 status = 0;\r\nint i;\r\nDRM_DEBUG("\n");\r\nfor (i = 0; i < dev_priv->usec_timeout; i++) {\r\nstatus = MGA_READ(MGA_STATUS) & MGA_ENGINE_IDLE_MASK;\r\nif (status == MGA_ENDPRDMASTS) {\r\nMGA_WRITE8(MGA_CRTC_INDEX, 0);\r\nreturn 0;\r\n}\r\nDRM_UDELAY(1);\r\n}\r\n#if MGA_DMA_DEBUG\r\nDRM_ERROR("failed!\n");\r\nDRM_INFO(" status=0x%08x\n", status);\r\n#endif\r\nreturn -EBUSY;\r\n}\r\nstatic int mga_do_dma_reset(drm_mga_private_t *dev_priv)\r\n{\r\ndrm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\ndrm_mga_primary_buffer_t *primary = &dev_priv->prim;\r\nDRM_DEBUG("\n");\r\nprimary->tail = 0;\r\nprimary->space = primary->size;\r\nprimary->last_flush = 0;\r\nsarea_priv->last_wrap = 0;\r\nreturn 0;\r\n}\r\nvoid mga_do_dma_flush(drm_mga_private_t *dev_priv)\r\n{\r\ndrm_mga_primary_buffer_t *primary = &dev_priv->prim;\r\nu32 head, tail;\r\nu32 status = 0;\r\nint i;\r\nDMA_LOCALS;\r\nDRM_DEBUG("\n");\r\nfor (i = 0; i < dev_priv->usec_timeout; i++) {\r\nstatus = MGA_READ(MGA_STATUS) & MGA_ENGINE_IDLE_MASK;\r\nif (status == MGA_ENDPRDMASTS)\r\nbreak;\r\nDRM_UDELAY(1);\r\n}\r\nif (primary->tail == primary->last_flush) {\r\nDRM_DEBUG(" bailing out...\n");\r\nreturn;\r\n}\r\ntail = primary->tail + dev_priv->primary->offset;\r\nBEGIN_DMA(1);\r\nDMA_BLOCK(MGA_DMAPAD, 0x00000000,\r\nMGA_DMAPAD, 0x00000000,\r\nMGA_DMAPAD, 0x00000000, MGA_DMAPAD, 0x00000000);\r\nADVANCE_DMA();\r\nprimary->last_flush = primary->tail;\r\nhead = MGA_READ(MGA_PRIMADDRESS);\r\nif (head <= tail)\r\nprimary->space = primary->size - primary->tail;\r\nelse\r\nprimary->space = head - tail;\r\nDRM_DEBUG(" head = 0x%06lx\n", (unsigned long)(head - dev_priv->primary->offset));\r\nDRM_DEBUG(" tail = 0x%06lx\n", (unsigned long)(tail - dev_priv->primary->offset));\r\nDRM_DEBUG(" space = 0x%06x\n", primary->space);\r\nmga_flush_write_combine();\r\nMGA_WRITE(MGA_PRIMEND, tail | dev_priv->dma_access);\r\nDRM_DEBUG("done.\n");\r\n}\r\nvoid mga_do_dma_wrap_start(drm_mga_private_t *dev_priv)\r\n{\r\ndrm_mga_primary_buffer_t *primary = &dev_priv->prim;\r\nu32 head, tail;\r\nDMA_LOCALS;\r\nDRM_DEBUG("\n");\r\nBEGIN_DMA_WRAP();\r\nDMA_BLOCK(MGA_DMAPAD, 0x00000000,\r\nMGA_DMAPAD, 0x00000000,\r\nMGA_DMAPAD, 0x00000000, MGA_DMAPAD, 0x00000000);\r\nADVANCE_DMA();\r\ntail = primary->tail + dev_priv->primary->offset;\r\nprimary->tail = 0;\r\nprimary->last_flush = 0;\r\nprimary->last_wrap++;\r\nhead = MGA_READ(MGA_PRIMADDRESS);\r\nif (head == dev_priv->primary->offset)\r\nprimary->space = primary->size;\r\nelse\r\nprimary->space = head - dev_priv->primary->offset;\r\nDRM_DEBUG(" head = 0x%06lx\n", (unsigned long)(head - dev_priv->primary->offset));\r\nDRM_DEBUG(" tail = 0x%06x\n", primary->tail);\r\nDRM_DEBUG(" wrap = %d\n", primary->last_wrap);\r\nDRM_DEBUG(" space = 0x%06x\n", primary->space);\r\nmga_flush_write_combine();\r\nMGA_WRITE(MGA_PRIMEND, tail | dev_priv->dma_access);\r\nset_bit(0, &primary->wrapped);\r\nDRM_DEBUG("done.\n");\r\n}\r\nvoid mga_do_dma_wrap_end(drm_mga_private_t *dev_priv)\r\n{\r\ndrm_mga_primary_buffer_t *primary = &dev_priv->prim;\r\ndrm_mga_sarea_t *sarea_priv = dev_priv->sarea_priv;\r\nu32 head = dev_priv->primary->offset;\r\nDRM_DEBUG("\n");\r\nsarea_priv->last_wrap++;\r\nDRM_DEBUG(" wrap = %d\n", sarea_priv->last_wrap);\r\nmga_flush_write_combine();\r\nMGA_WRITE(MGA_PRIMADDRESS, head | MGA_DMA_GENERAL);\r\nclear_bit(0, &primary->wrapped);\r\nDRM_DEBUG("done.\n");\r\n}\r\nstatic void mga_freelist_print(struct drm_device *dev)\r\n{\r\ndrm_mga_private_t *dev_priv = dev->dev_private;\r\ndrm_mga_freelist_t *entry;\r\nDRM_INFO("\n");\r\nDRM_INFO("current dispatch: last=0x%x done=0x%x\n",\r\ndev_priv->sarea_priv->last_dispatch,\r\n(unsigned int)(MGA_READ(MGA_PRIMADDRESS) -\r\ndev_priv->primary->offset));\r\nDRM_INFO("current freelist:\n");\r\nfor (entry = dev_priv->head->next; entry; entry = entry->next) {\r\nDRM_INFO(" %p idx=%2d age=0x%x 0x%06lx\n",\r\nentry, entry->buf->idx, entry->age.head,\r\n(unsigned long)(entry->age.head - dev_priv->primary->offset));\r\n}\r\nDRM_INFO("\n");\r\n}\r\nstatic int mga_freelist_init(struct drm_device *dev, drm_mga_private_t *dev_priv)\r\n{\r\nstruct drm_device_dma *dma = dev->dma;\r\nstruct drm_buf *buf;\r\ndrm_mga_buf_priv_t *buf_priv;\r\ndrm_mga_freelist_t *entry;\r\nint i;\r\nDRM_DEBUG("count=%d\n", dma->buf_count);\r\ndev_priv->head = kzalloc(sizeof(drm_mga_freelist_t), GFP_KERNEL);\r\nif (dev_priv->head == NULL)\r\nreturn -ENOMEM;\r\nSET_AGE(&dev_priv->head->age, MGA_BUFFER_USED, 0);\r\nfor (i = 0; i < dma->buf_count; i++) {\r\nbuf = dma->buflist[i];\r\nbuf_priv = buf->dev_private;\r\nentry = kzalloc(sizeof(drm_mga_freelist_t), GFP_KERNEL);\r\nif (entry == NULL)\r\nreturn -ENOMEM;\r\nentry->next = dev_priv->head->next;\r\nentry->prev = dev_priv->head;\r\nSET_AGE(&entry->age, MGA_BUFFER_FREE, 0);\r\nentry->buf = buf;\r\nif (dev_priv->head->next != NULL)\r\ndev_priv->head->next->prev = entry;\r\nif (entry->next == NULL)\r\ndev_priv->tail = entry;\r\nbuf_priv->list_entry = entry;\r\nbuf_priv->discard = 0;\r\nbuf_priv->dispatched = 0;\r\ndev_priv->head->next = entry;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mga_freelist_cleanup(struct drm_device *dev)\r\n{\r\ndrm_mga_private_t *dev_priv = dev->dev_private;\r\ndrm_mga_freelist_t *entry;\r\ndrm_mga_freelist_t *next;\r\nDRM_DEBUG("\n");\r\nentry = dev_priv->head;\r\nwhile (entry) {\r\nnext = entry->next;\r\nkfree(entry);\r\nentry = next;\r\n}\r\ndev_priv->head = dev_priv->tail = NULL;\r\n}\r\nstatic struct drm_buf *mga_freelist_get(struct drm_device * dev)\r\n{\r\ndrm_mga_private_t *dev_priv = dev->dev_private;\r\ndrm_mga_freelist_t *next;\r\ndrm_mga_freelist_t *prev;\r\ndrm_mga_freelist_t *tail = dev_priv->tail;\r\nu32 head, wrap;\r\nDRM_DEBUG("\n");\r\nhead = MGA_READ(MGA_PRIMADDRESS);\r\nwrap = dev_priv->sarea_priv->last_wrap;\r\nDRM_DEBUG(" tail=0x%06lx %d\n",\r\ntail->age.head ?\r\n(unsigned long)(tail->age.head - dev_priv->primary->offset) : 0,\r\ntail->age.wrap);\r\nDRM_DEBUG(" head=0x%06lx %d\n",\r\n(unsigned long)(head - dev_priv->primary->offset), wrap);\r\nif (TEST_AGE(&tail->age, head, wrap)) {\r\nprev = dev_priv->tail->prev;\r\nnext = dev_priv->tail;\r\nprev->next = NULL;\r\nnext->prev = next->next = NULL;\r\ndev_priv->tail = prev;\r\nSET_AGE(&next->age, MGA_BUFFER_USED, 0);\r\nreturn next->buf;\r\n}\r\nDRM_DEBUG("returning NULL!\n");\r\nreturn NULL;\r\n}\r\nint mga_freelist_put(struct drm_device *dev, struct drm_buf *buf)\r\n{\r\ndrm_mga_private_t *dev_priv = dev->dev_private;\r\ndrm_mga_buf_priv_t *buf_priv = buf->dev_private;\r\ndrm_mga_freelist_t *head, *entry, *prev;\r\nDRM_DEBUG("age=0x%06lx wrap=%d\n",\r\n(unsigned long)(buf_priv->list_entry->age.head -\r\ndev_priv->primary->offset),\r\nbuf_priv->list_entry->age.wrap);\r\nentry = buf_priv->list_entry;\r\nhead = dev_priv->head;\r\nif (buf_priv->list_entry->age.head == MGA_BUFFER_USED) {\r\nSET_AGE(&entry->age, MGA_BUFFER_FREE, 0);\r\nprev = dev_priv->tail;\r\nprev->next = entry;\r\nentry->prev = prev;\r\nentry->next = NULL;\r\n} else {\r\nprev = head->next;\r\nhead->next = entry;\r\nprev->prev = entry;\r\nentry->prev = head;\r\nentry->next = prev;\r\n}\r\nreturn 0;\r\n}\r\nint mga_driver_load(struct drm_device *dev, unsigned long flags)\r\n{\r\ndrm_mga_private_t *dev_priv;\r\nint ret;\r\ndev_priv = kzalloc(sizeof(drm_mga_private_t), GFP_KERNEL);\r\nif (!dev_priv)\r\nreturn -ENOMEM;\r\ndev->dev_private = (void *)dev_priv;\r\ndev_priv->usec_timeout = MGA_DEFAULT_USEC_TIMEOUT;\r\ndev_priv->chipset = flags;\r\npci_set_master(dev->pdev);\r\ndev_priv->mmio_base = pci_resource_start(dev->pdev, 1);\r\ndev_priv->mmio_size = pci_resource_len(dev->pdev, 1);\r\nret = drm_vblank_init(dev, 1);\r\nif (ret) {\r\n(void) mga_driver_unload(dev);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mga_do_agp_dma_bootstrap(struct drm_device *dev,\r\ndrm_mga_dma_bootstrap_t *dma_bs)\r\n{\r\ndrm_mga_private_t *const dev_priv =\r\n(drm_mga_private_t *) dev->dev_private;\r\nunsigned int warp_size = MGA_WARP_UCODE_SIZE;\r\nint err;\r\nunsigned offset;\r\nconst unsigned secondary_size = dma_bs->secondary_bin_count\r\n* dma_bs->secondary_bin_size;\r\nconst unsigned agp_size = (dma_bs->agp_size << 20);\r\nstruct drm_buf_desc req;\r\nstruct drm_agp_mode mode;\r\nstruct drm_agp_info info;\r\nstruct drm_agp_buffer agp_req;\r\nstruct drm_agp_binding bind_req;\r\nerr = drm_agp_acquire(dev);\r\nif (err) {\r\nDRM_ERROR("Unable to acquire AGP: %d\n", err);\r\nreturn err;\r\n}\r\nerr = drm_agp_info(dev, &info);\r\nif (err) {\r\nDRM_ERROR("Unable to get AGP info: %d\n", err);\r\nreturn err;\r\n}\r\nmode.mode = (info.mode & ~0x07) | dma_bs->agp_mode;\r\nerr = drm_agp_enable(dev, mode);\r\nif (err) {\r\nDRM_ERROR("Unable to enable AGP (mode = 0x%lx)\n", mode.mode);\r\nreturn err;\r\n}\r\nif (dev_priv->chipset == MGA_CARD_TYPE_G200) {\r\nif (mode.mode & 0x02)\r\nMGA_WRITE(MGA_AGP_PLL, MGA_AGP2XPLL_ENABLE);\r\nelse\r\nMGA_WRITE(MGA_AGP_PLL, MGA_AGP2XPLL_DISABLE);\r\n}\r\nagp_req.size = agp_size;\r\nagp_req.type = 0;\r\nerr = drm_agp_alloc(dev, &agp_req);\r\nif (err) {\r\ndev_priv->agp_size = 0;\r\nDRM_ERROR("Unable to allocate %uMB AGP memory\n",\r\ndma_bs->agp_size);\r\nreturn err;\r\n}\r\ndev_priv->agp_size = agp_size;\r\ndev_priv->agp_handle = agp_req.handle;\r\nbind_req.handle = agp_req.handle;\r\nbind_req.offset = 0;\r\nerr = drm_agp_bind(dev, &bind_req);\r\nif (err) {\r\nDRM_ERROR("Unable to bind AGP memory: %d\n", err);\r\nreturn err;\r\n}\r\nif (warp_size < PAGE_SIZE)\r\nwarp_size = PAGE_SIZE;\r\noffset = 0;\r\nerr = drm_legacy_addmap(dev, offset, warp_size,\r\n_DRM_AGP, _DRM_READ_ONLY, &dev_priv->warp);\r\nif (err) {\r\nDRM_ERROR("Unable to map WARP microcode: %d\n", err);\r\nreturn err;\r\n}\r\noffset += warp_size;\r\nerr = drm_legacy_addmap(dev, offset, dma_bs->primary_size,\r\n_DRM_AGP, _DRM_READ_ONLY, &dev_priv->primary);\r\nif (err) {\r\nDRM_ERROR("Unable to map primary DMA region: %d\n", err);\r\nreturn err;\r\n}\r\noffset += dma_bs->primary_size;\r\nerr = drm_legacy_addmap(dev, offset, secondary_size,\r\n_DRM_AGP, 0, &dev->agp_buffer_map);\r\nif (err) {\r\nDRM_ERROR("Unable to map secondary DMA region: %d\n", err);\r\nreturn err;\r\n}\r\n(void)memset(&req, 0, sizeof(req));\r\nreq.count = dma_bs->secondary_bin_count;\r\nreq.size = dma_bs->secondary_bin_size;\r\nreq.flags = _DRM_AGP_BUFFER;\r\nreq.agp_start = offset;\r\nerr = drm_legacy_addbufs_agp(dev, &req);\r\nif (err) {\r\nDRM_ERROR("Unable to add secondary DMA buffers: %d\n", err);\r\nreturn err;\r\n}\r\n{\r\nstruct drm_map_list *_entry;\r\nunsigned long agp_token = 0;\r\nlist_for_each_entry(_entry, &dev->maplist, head) {\r\nif (_entry->map == dev->agp_buffer_map)\r\nagp_token = _entry->user_token;\r\n}\r\nif (!agp_token)\r\nreturn -EFAULT;\r\ndev->agp_buffer_token = agp_token;\r\n}\r\noffset += secondary_size;\r\nerr = drm_legacy_addmap(dev, offset, agp_size - offset,\r\n_DRM_AGP, 0, &dev_priv->agp_textures);\r\nif (err) {\r\nDRM_ERROR("Unable to map AGP texture region %d\n", err);\r\nreturn err;\r\n}\r\ndrm_legacy_ioremap(dev_priv->warp, dev);\r\ndrm_legacy_ioremap(dev_priv->primary, dev);\r\ndrm_legacy_ioremap(dev->agp_buffer_map, dev);\r\nif (!dev_priv->warp->handle ||\r\n!dev_priv->primary->handle || !dev->agp_buffer_map->handle) {\r\nDRM_ERROR("failed to ioremap agp regions! (%p, %p, %p)\n",\r\ndev_priv->warp->handle, dev_priv->primary->handle,\r\ndev->agp_buffer_map->handle);\r\nreturn -ENOMEM;\r\n}\r\ndev_priv->dma_access = MGA_PAGPXFER;\r\ndev_priv->wagp_enable = MGA_WAGP_ENABLE;\r\nDRM_INFO("Initialized card for AGP DMA.\n");\r\nreturn 0;\r\n}\r\nstatic int mga_do_agp_dma_bootstrap(struct drm_device *dev,\r\ndrm_mga_dma_bootstrap_t *dma_bs)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int mga_do_pci_dma_bootstrap(struct drm_device *dev,\r\ndrm_mga_dma_bootstrap_t *dma_bs)\r\n{\r\ndrm_mga_private_t *const dev_priv =\r\n(drm_mga_private_t *) dev->dev_private;\r\nunsigned int warp_size = MGA_WARP_UCODE_SIZE;\r\nunsigned int primary_size;\r\nunsigned int bin_count;\r\nint err;\r\nstruct drm_buf_desc req;\r\nif (dev->dma == NULL) {\r\nDRM_ERROR("dev->dma is NULL\n");\r\nreturn -EFAULT;\r\n}\r\nif (warp_size < PAGE_SIZE)\r\nwarp_size = PAGE_SIZE;\r\nerr = drm_legacy_addmap(dev, 0, warp_size, _DRM_CONSISTENT,\r\n_DRM_READ_ONLY, &dev_priv->warp);\r\nif (err != 0) {\r\nDRM_ERROR("Unable to create mapping for WARP microcode: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nfor (primary_size = dma_bs->primary_size; primary_size != 0;\r\nprimary_size >>= 1) {\r\nerr = drm_legacy_addmap(dev, 0, primary_size, _DRM_CONSISTENT,\r\n_DRM_READ_ONLY, &dev_priv->primary);\r\nif (!err)\r\nbreak;\r\n}\r\nif (err != 0) {\r\nDRM_ERROR("Unable to allocate primary DMA region: %d\n", err);\r\nreturn -ENOMEM;\r\n}\r\nif (dev_priv->primary->size != dma_bs->primary_size) {\r\nDRM_INFO("Primary DMA buffer size reduced from %u to %u.\n",\r\ndma_bs->primary_size,\r\n(unsigned)dev_priv->primary->size);\r\ndma_bs->primary_size = dev_priv->primary->size;\r\n}\r\nfor (bin_count = dma_bs->secondary_bin_count; bin_count > 0;\r\nbin_count--) {\r\n(void)memset(&req, 0, sizeof(req));\r\nreq.count = bin_count;\r\nreq.size = dma_bs->secondary_bin_size;\r\nerr = drm_legacy_addbufs_pci(dev, &req);\r\nif (!err)\r\nbreak;\r\n}\r\nif (bin_count == 0) {\r\nDRM_ERROR("Unable to add secondary DMA buffers: %d\n", err);\r\nreturn err;\r\n}\r\nif (bin_count != dma_bs->secondary_bin_count) {\r\nDRM_INFO("Secondary PCI DMA buffer bin count reduced from %u "\r\n"to %u.\n", dma_bs->secondary_bin_count, bin_count);\r\ndma_bs->secondary_bin_count = bin_count;\r\n}\r\ndev_priv->dma_access = 0;\r\ndev_priv->wagp_enable = 0;\r\ndma_bs->agp_mode = 0;\r\nDRM_INFO("Initialized card for PCI DMA.\n");\r\nreturn 0;\r\n}\r\nstatic int mga_do_dma_bootstrap(struct drm_device *dev,\r\ndrm_mga_dma_bootstrap_t *dma_bs)\r\n{\r\nconst int is_agp = (dma_bs->agp_mode != 0) && drm_pci_device_is_agp(dev);\r\nint err;\r\ndrm_mga_private_t *const dev_priv =\r\n(drm_mga_private_t *) dev->dev_private;\r\ndev_priv->used_new_dma_init = 1;\r\nerr = drm_legacy_addmap(dev, dev_priv->mmio_base, dev_priv->mmio_size,\r\n_DRM_REGISTERS, _DRM_READ_ONLY,\r\n&dev_priv->mmio);\r\nif (err) {\r\nDRM_ERROR("Unable to map MMIO region: %d\n", err);\r\nreturn err;\r\n}\r\nerr = drm_legacy_addmap(dev, 0, SAREA_MAX, _DRM_SHM,\r\n_DRM_READ_ONLY | _DRM_LOCKED | _DRM_KERNEL,\r\n&dev_priv->status);\r\nif (err) {\r\nDRM_ERROR("Unable to map status region: %d\n", err);\r\nreturn err;\r\n}\r\nif (is_agp)\r\nerr = mga_do_agp_dma_bootstrap(dev, dma_bs);\r\nif (err)\r\nmga_do_cleanup_dma(dev, MINIMAL_CLEANUP);\r\nif (!is_agp || err)\r\nerr = mga_do_pci_dma_bootstrap(dev, dma_bs);\r\nreturn err;\r\n}\r\nint mga_dma_bootstrap(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\ndrm_mga_dma_bootstrap_t *bootstrap = data;\r\nint err;\r\nstatic const int modes[] = { 0, 1, 2, 2, 4, 4, 4, 4 };\r\nconst drm_mga_private_t *const dev_priv =\r\n(drm_mga_private_t *) dev->dev_private;\r\nerr = mga_do_dma_bootstrap(dev, bootstrap);\r\nif (err) {\r\nmga_do_cleanup_dma(dev, FULL_CLEANUP);\r\nreturn err;\r\n}\r\nif (dev_priv->agp_textures != NULL) {\r\nbootstrap->texture_handle = dev_priv->agp_textures->offset;\r\nbootstrap->texture_size = dev_priv->agp_textures->size;\r\n} else {\r\nbootstrap->texture_handle = 0;\r\nbootstrap->texture_size = 0;\r\n}\r\nbootstrap->agp_mode = modes[bootstrap->agp_mode & 0x07];\r\nreturn err;\r\n}\r\nstatic int mga_do_init_dma(struct drm_device *dev, drm_mga_init_t *init)\r\n{\r\ndrm_mga_private_t *dev_priv;\r\nint ret;\r\nDRM_DEBUG("\n");\r\ndev_priv = dev->dev_private;\r\nif (init->sgram)\r\ndev_priv->clear_cmd = MGA_DWGCTL_CLEAR | MGA_ATYPE_BLK;\r\nelse\r\ndev_priv->clear_cmd = MGA_DWGCTL_CLEAR | MGA_ATYPE_RSTR;\r\ndev_priv->maccess = init->maccess;\r\ndev_priv->fb_cpp = init->fb_cpp;\r\ndev_priv->front_offset = init->front_offset;\r\ndev_priv->front_pitch = init->front_pitch;\r\ndev_priv->back_offset = init->back_offset;\r\ndev_priv->back_pitch = init->back_pitch;\r\ndev_priv->depth_cpp = init->depth_cpp;\r\ndev_priv->depth_offset = init->depth_offset;\r\ndev_priv->depth_pitch = init->depth_pitch;\r\ndev_priv->texture_offset = init->texture_offset[0];\r\ndev_priv->texture_size = init->texture_size[0];\r\ndev_priv->sarea = drm_legacy_getsarea(dev);\r\nif (!dev_priv->sarea) {\r\nDRM_ERROR("failed to find sarea!\n");\r\nreturn -EINVAL;\r\n}\r\nif (!dev_priv->used_new_dma_init) {\r\ndev_priv->dma_access = MGA_PAGPXFER;\r\ndev_priv->wagp_enable = MGA_WAGP_ENABLE;\r\ndev_priv->status = drm_legacy_findmap(dev, init->status_offset);\r\nif (!dev_priv->status) {\r\nDRM_ERROR("failed to find status page!\n");\r\nreturn -EINVAL;\r\n}\r\ndev_priv->mmio = drm_legacy_findmap(dev, init->mmio_offset);\r\nif (!dev_priv->mmio) {\r\nDRM_ERROR("failed to find mmio region!\n");\r\nreturn -EINVAL;\r\n}\r\ndev_priv->warp = drm_legacy_findmap(dev, init->warp_offset);\r\nif (!dev_priv->warp) {\r\nDRM_ERROR("failed to find warp microcode region!\n");\r\nreturn -EINVAL;\r\n}\r\ndev_priv->primary = drm_legacy_findmap(dev, init->primary_offset);\r\nif (!dev_priv->primary) {\r\nDRM_ERROR("failed to find primary dma region!\n");\r\nreturn -EINVAL;\r\n}\r\ndev->agp_buffer_token = init->buffers_offset;\r\ndev->agp_buffer_map =\r\ndrm_legacy_findmap(dev, init->buffers_offset);\r\nif (!dev->agp_buffer_map) {\r\nDRM_ERROR("failed to find dma buffer region!\n");\r\nreturn -EINVAL;\r\n}\r\ndrm_legacy_ioremap(dev_priv->warp, dev);\r\ndrm_legacy_ioremap(dev_priv->primary, dev);\r\ndrm_legacy_ioremap(dev->agp_buffer_map, dev);\r\n}\r\ndev_priv->sarea_priv =\r\n(drm_mga_sarea_t *) ((u8 *) dev_priv->sarea->handle +\r\ninit->sarea_priv_offset);\r\nif (!dev_priv->warp->handle ||\r\n!dev_priv->primary->handle ||\r\n((dev_priv->dma_access != 0) &&\r\n((dev->agp_buffer_map == NULL) ||\r\n(dev->agp_buffer_map->handle == NULL)))) {\r\nDRM_ERROR("failed to ioremap agp regions!\n");\r\nreturn -ENOMEM;\r\n}\r\nret = mga_warp_install_microcode(dev_priv);\r\nif (ret < 0) {\r\nDRM_ERROR("failed to install WARP ucode!: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = mga_warp_init(dev_priv);\r\nif (ret < 0) {\r\nDRM_ERROR("failed to init WARP engine!: %d\n", ret);\r\nreturn ret;\r\n}\r\ndev_priv->prim.status = (u32 *) dev_priv->status->handle;\r\nmga_do_wait_for_idle(dev_priv);\r\nMGA_WRITE(MGA_PRIMADDRESS, dev_priv->primary->offset | MGA_DMA_GENERAL);\r\n#if 0\r\nMGA_WRITE(MGA_PRIMPTR, virt_to_bus((void *)dev_priv->prim.status) | MGA_PRIMPTREN0 |\r\nMGA_PRIMPTREN1);\r\n#endif\r\ndev_priv->prim.start = (u8 *) dev_priv->primary->handle;\r\ndev_priv->prim.end = ((u8 *) dev_priv->primary->handle\r\n+ dev_priv->primary->size);\r\ndev_priv->prim.size = dev_priv->primary->size;\r\ndev_priv->prim.tail = 0;\r\ndev_priv->prim.space = dev_priv->prim.size;\r\ndev_priv->prim.wrapped = 0;\r\ndev_priv->prim.last_flush = 0;\r\ndev_priv->prim.last_wrap = 0;\r\ndev_priv->prim.high_mark = 256 * DMA_BLOCK_SIZE;\r\ndev_priv->prim.status[0] = dev_priv->primary->offset;\r\ndev_priv->prim.status[1] = 0;\r\ndev_priv->sarea_priv->last_wrap = 0;\r\ndev_priv->sarea_priv->last_frame.head = 0;\r\ndev_priv->sarea_priv->last_frame.wrap = 0;\r\nif (mga_freelist_init(dev, dev_priv) < 0) {\r\nDRM_ERROR("could not initialize freelist\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mga_do_cleanup_dma(struct drm_device *dev, int full_cleanup)\r\n{\r\nint err = 0;\r\nDRM_DEBUG("\n");\r\nif (dev->irq_enabled)\r\ndrm_irq_uninstall(dev);\r\nif (dev->dev_private) {\r\ndrm_mga_private_t *dev_priv = dev->dev_private;\r\nif ((dev_priv->warp != NULL)\r\n&& (dev_priv->warp->type != _DRM_CONSISTENT))\r\ndrm_legacy_ioremapfree(dev_priv->warp, dev);\r\nif ((dev_priv->primary != NULL)\r\n&& (dev_priv->primary->type != _DRM_CONSISTENT))\r\ndrm_legacy_ioremapfree(dev_priv->primary, dev);\r\nif (dev->agp_buffer_map != NULL)\r\ndrm_legacy_ioremapfree(dev->agp_buffer_map, dev);\r\nif (dev_priv->used_new_dma_init) {\r\n#if __OS_HAS_AGP\r\nif (dev_priv->agp_handle != 0) {\r\nstruct drm_agp_binding unbind_req;\r\nstruct drm_agp_buffer free_req;\r\nunbind_req.handle = dev_priv->agp_handle;\r\ndrm_agp_unbind(dev, &unbind_req);\r\nfree_req.handle = dev_priv->agp_handle;\r\ndrm_agp_free(dev, &free_req);\r\ndev_priv->agp_textures = NULL;\r\ndev_priv->agp_size = 0;\r\ndev_priv->agp_handle = 0;\r\n}\r\nif ((dev->agp != NULL) && dev->agp->acquired)\r\nerr = drm_agp_release(dev);\r\n#endif\r\n}\r\ndev_priv->warp = NULL;\r\ndev_priv->primary = NULL;\r\ndev_priv->sarea = NULL;\r\ndev_priv->sarea_priv = NULL;\r\ndev->agp_buffer_map = NULL;\r\nif (full_cleanup) {\r\ndev_priv->mmio = NULL;\r\ndev_priv->status = NULL;\r\ndev_priv->used_new_dma_init = 0;\r\n}\r\nmemset(&dev_priv->prim, 0, sizeof(dev_priv->prim));\r\ndev_priv->warp_pipe = 0;\r\nmemset(dev_priv->warp_pipe_phys, 0,\r\nsizeof(dev_priv->warp_pipe_phys));\r\nif (dev_priv->head != NULL)\r\nmga_freelist_cleanup(dev);\r\n}\r\nreturn err;\r\n}\r\nint mga_dma_init(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\ndrm_mga_init_t *init = data;\r\nint err;\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nswitch (init->func) {\r\ncase MGA_INIT_DMA:\r\nerr = mga_do_init_dma(dev, init);\r\nif (err)\r\n(void)mga_do_cleanup_dma(dev, FULL_CLEANUP);\r\nreturn err;\r\ncase MGA_CLEANUP_DMA:\r\nreturn mga_do_cleanup_dma(dev, FULL_CLEANUP);\r\n}\r\nreturn -EINVAL;\r\n}\r\nint mga_dma_flush(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\ndrm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;\r\nstruct drm_lock *lock = data;\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nDRM_DEBUG("%s%s%s\n",\r\n(lock->flags & _DRM_LOCK_FLUSH) ? "flush, " : "",\r\n(lock->flags & _DRM_LOCK_FLUSH_ALL) ? "flush all, " : "",\r\n(lock->flags & _DRM_LOCK_QUIESCENT) ? "idle, " : "");\r\nWRAP_WAIT_WITH_RETURN(dev_priv);\r\nif (lock->flags & (_DRM_LOCK_FLUSH | _DRM_LOCK_FLUSH_ALL))\r\nmga_do_dma_flush(dev_priv);\r\nif (lock->flags & _DRM_LOCK_QUIESCENT) {\r\n#if MGA_DMA_DEBUG\r\nint ret = mga_do_wait_for_idle(dev_priv);\r\nif (ret < 0)\r\nDRM_INFO("-EBUSY\n");\r\nreturn ret;\r\n#else\r\nreturn mga_do_wait_for_idle(dev_priv);\r\n#endif\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nint mga_dma_reset(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\ndrm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nreturn mga_do_dma_reset(dev_priv);\r\n}\r\nstatic int mga_dma_get_buffers(struct drm_device *dev,\r\nstruct drm_file *file_priv, struct drm_dma *d)\r\n{\r\nstruct drm_buf *buf;\r\nint i;\r\nfor (i = d->granted_count; i < d->request_count; i++) {\r\nbuf = mga_freelist_get(dev);\r\nif (!buf)\r\nreturn -EAGAIN;\r\nbuf->file_priv = file_priv;\r\nif (copy_to_user(&d->request_indices[i],\r\n&buf->idx, sizeof(buf->idx)))\r\nreturn -EFAULT;\r\nif (copy_to_user(&d->request_sizes[i],\r\n&buf->total, sizeof(buf->total)))\r\nreturn -EFAULT;\r\nd->granted_count++;\r\n}\r\nreturn 0;\r\n}\r\nint mga_dma_buffers(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_device_dma *dma = dev->dma;\r\ndrm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;\r\nstruct drm_dma *d = data;\r\nint ret = 0;\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nif (d->send_count != 0) {\r\nDRM_ERROR("Process %d trying to send %d buffers via drmDMA\n",\r\nDRM_CURRENTPID, d->send_count);\r\nreturn -EINVAL;\r\n}\r\nif (d->request_count < 0 || d->request_count > dma->buf_count) {\r\nDRM_ERROR("Process %d trying to get %d buffers (of %d max)\n",\r\nDRM_CURRENTPID, d->request_count, dma->buf_count);\r\nreturn -EINVAL;\r\n}\r\nWRAP_TEST_WITH_RETURN(dev_priv);\r\nd->granted_count = 0;\r\nif (d->request_count)\r\nret = mga_dma_get_buffers(dev, file_priv, d);\r\nreturn ret;\r\n}\r\nint mga_driver_unload(struct drm_device *dev)\r\n{\r\nkfree(dev->dev_private);\r\ndev->dev_private = NULL;\r\nreturn 0;\r\n}\r\nvoid mga_driver_lastclose(struct drm_device *dev)\r\n{\r\nmga_do_cleanup_dma(dev, FULL_CLEANUP);\r\n}\r\nint mga_driver_dma_quiescent(struct drm_device *dev)\r\n{\r\ndrm_mga_private_t *dev_priv = dev->dev_private;\r\nreturn mga_do_wait_for_idle(dev_priv);\r\n}
