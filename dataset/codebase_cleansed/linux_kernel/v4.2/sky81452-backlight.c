static int sky81452_bl_update_status(struct backlight_device *bd)\r\n{\r\nconst struct sky81452_bl_platform_data *pdata =\r\ndev_get_platdata(bd->dev.parent);\r\nconst unsigned int brightness = (unsigned int)bd->props.brightness;\r\nstruct regmap *regmap = bl_get_data(bd);\r\nint ret;\r\nif (brightness > 0) {\r\nret = regmap_write(regmap, SKY81452_REG0, brightness - 1);\r\nif (IS_ERR_VALUE(ret))\r\nreturn ret;\r\nreturn regmap_update_bits(regmap, SKY81452_REG1, SKY81452_EN,\r\npdata->enable << CTZ(SKY81452_EN));\r\n}\r\nreturn regmap_update_bits(regmap, SKY81452_REG1, SKY81452_EN, 0);\r\n}\r\nstatic ssize_t sky81452_bl_store_enable(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct regmap *regmap = bl_get_data(to_backlight_device(dev));\r\nunsigned long value;\r\nint ret;\r\nret = kstrtoul(buf, 16, &value);\r\nif (IS_ERR_VALUE(ret))\r\nreturn ret;\r\nret = regmap_update_bits(regmap, SKY81452_REG1, SKY81452_EN,\r\nvalue << CTZ(SKY81452_EN));\r\nif (IS_ERR_VALUE(ret))\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t sky81452_bl_show_open_short(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct regmap *regmap = bl_get_data(to_backlight_device(dev));\r\nunsigned int reg, value = 0;\r\nchar tmp[3];\r\nint i, ret;\r\nreg = !strcmp(attr->attr.name, "open") ? SKY81452_REG5 : SKY81452_REG4;\r\nret = regmap_read(regmap, reg, &value);\r\nif (IS_ERR_VALUE(ret))\r\nreturn ret;\r\nif (value & SKY81452_SHRT) {\r\n*buf = 0;\r\nfor (i = 0; i < 6; i++) {\r\nif (value & 0x01) {\r\nsprintf(tmp, "%d ", i + 1);\r\nstrcat(buf, tmp);\r\n}\r\nvalue >>= 1;\r\n}\r\nstrcat(buf, "\n");\r\n} else {\r\nstrcpy(buf, "none\n");\r\n}\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t sky81452_bl_show_fault(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct regmap *regmap = bl_get_data(to_backlight_device(dev));\r\nunsigned int value = 0;\r\nint ret;\r\nret = regmap_read(regmap, SKY81452_REG4, &value);\r\nif (IS_ERR_VALUE(ret))\r\nreturn ret;\r\n*buf = 0;\r\nif (value & SKY81452_OCP)\r\nstrcat(buf, "over-current ");\r\nif (value & SKY81452_OTMP)\r\nstrcat(buf, "over-temperature");\r\nstrcat(buf, "\n");\r\nreturn strlen(buf);\r\n}\r\nstatic struct sky81452_bl_platform_data *sky81452_bl_parse_dt(\r\nstruct device *dev)\r\n{\r\nstruct device_node *np = of_node_get(dev->of_node);\r\nstruct sky81452_bl_platform_data *pdata;\r\nint num_entry;\r\nunsigned int sources[6];\r\nint ret;\r\nif (!np) {\r\ndev_err(dev, "backlight node not found.\n");\r\nreturn ERR_PTR(-ENODATA);\r\n}\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata) {\r\nof_node_put(np);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nof_property_read_string(np, "name", &pdata->name);\r\npdata->ignore_pwm = of_property_read_bool(np, "skyworks,ignore-pwm");\r\npdata->dpwm_mode = of_property_read_bool(np, "skyworks,dpwm-mode");\r\npdata->phase_shift = of_property_read_bool(np, "skyworks,phase-shift");\r\npdata->gpio_enable = of_get_gpio(np, 0);\r\nret = of_property_count_u32_elems(np, "led-sources");\r\nif (IS_ERR_VALUE(ret)) {\r\npdata->enable = SKY81452_EN >> CTZ(SKY81452_EN);\r\n} else {\r\nnum_entry = ret;\r\nif (num_entry > 6)\r\nnum_entry = 6;\r\nret = of_property_read_u32_array(np, "led-sources", sources,\r\nnum_entry);\r\nif (IS_ERR_VALUE(ret)) {\r\ndev_err(dev, "led-sources node is invalid.\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\npdata->enable = 0;\r\nwhile (--num_entry)\r\npdata->enable |= (1 << sources[num_entry]);\r\n}\r\nret = of_property_read_u32(np,\r\n"skyworks,short-detection-threshold-volt",\r\n&pdata->short_detection_threshold);\r\nif (IS_ERR_VALUE(ret))\r\npdata->short_detection_threshold = 7;\r\nret = of_property_read_u32(np, "skyworks,current-limit-mA",\r\n&pdata->boost_current_limit);\r\nif (IS_ERR_VALUE(ret))\r\npdata->boost_current_limit = 2750;\r\nof_node_put(np);\r\nreturn pdata;\r\n}\r\nstatic struct sky81452_bl_platform_data *sky81452_bl_parse_dt(\r\nstruct device *dev)\r\n{\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic int sky81452_bl_init_device(struct regmap *regmap,\r\nstruct sky81452_bl_platform_data *pdata)\r\n{\r\nunsigned int value;\r\nvalue = pdata->ignore_pwm ? SKY81452_IGPW : 0;\r\nvalue |= pdata->dpwm_mode ? SKY81452_PWMMD : 0;\r\nvalue |= pdata->phase_shift ? 0 : SKY81452_PHASE;\r\nif (pdata->boost_current_limit == 2300)\r\nvalue |= SKY81452_ILIM;\r\nelse if (pdata->boost_current_limit != 2750)\r\nreturn -EINVAL;\r\nif (pdata->short_detection_threshold < 4 ||\r\npdata->short_detection_threshold > 7)\r\nreturn -EINVAL;\r\nvalue |= (7 - pdata->short_detection_threshold) << CTZ(SKY81452_VSHRT);\r\nreturn regmap_write(regmap, SKY81452_REG2, value);\r\n}\r\nstatic int sky81452_bl_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct regmap *regmap = dev_get_drvdata(dev->parent);\r\nstruct sky81452_bl_platform_data *pdata = dev_get_platdata(dev);\r\nstruct backlight_device *bd;\r\nstruct backlight_properties props;\r\nconst char *name;\r\nint ret;\r\nif (!pdata) {\r\npdata = sky81452_bl_parse_dt(dev);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\n}\r\nif (gpio_is_valid(pdata->gpio_enable)) {\r\nret = devm_gpio_request_one(dev, pdata->gpio_enable,\r\nGPIOF_OUT_INIT_HIGH, "sky81452-en");\r\nif (IS_ERR_VALUE(ret)) {\r\ndev_err(dev, "failed to request GPIO. err=%d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nret = sky81452_bl_init_device(regmap, pdata);\r\nif (IS_ERR_VALUE(ret)) {\r\ndev_err(dev, "failed to initialize. err=%d\n", ret);\r\nreturn ret;\r\n}\r\nmemset(&props, 0, sizeof(props));\r\nprops.max_brightness = SKY81452_MAX_BRIGHTNESS,\r\nname = pdata->name ? pdata->name : SKY81452_DEFAULT_NAME;\r\nbd = devm_backlight_device_register(dev, name, dev, regmap,\r\n&sky81452_bl_ops, &props);\r\nif (IS_ERR(bd)) {\r\ndev_err(dev, "failed to register. err=%ld\n", PTR_ERR(bd));\r\nreturn PTR_ERR(bd);\r\n}\r\nplatform_set_drvdata(pdev, bd);\r\nret = sysfs_create_group(&bd->dev.kobj, &sky81452_bl_attr_group);\r\nif (IS_ERR_VALUE(ret)) {\r\ndev_err(dev, "failed to create attribute. err=%d\n", ret);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int sky81452_bl_remove(struct platform_device *pdev)\r\n{\r\nconst struct sky81452_bl_platform_data *pdata =\r\ndev_get_platdata(&pdev->dev);\r\nstruct backlight_device *bd = platform_get_drvdata(pdev);\r\nsysfs_remove_group(&bd->dev.kobj, &sky81452_bl_attr_group);\r\nbd->props.power = FB_BLANK_UNBLANK;\r\nbd->props.brightness = 0;\r\nbacklight_update_status(bd);\r\nif (gpio_is_valid(pdata->gpio_enable))\r\ngpio_set_value_cansleep(pdata->gpio_enable, 0);\r\nreturn 0;\r\n}
