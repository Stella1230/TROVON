static int how_many_channels(struct pci_dev *pdev)\r\n{\r\nint n_channels;\r\nunsigned char capid0_2b;\r\npci_read_config_byte(pdev, IE31200_CAPID0 + 1, &capid0_2b);\r\nif (capid0_2b & IE31200_CAPID0_PDCD) {\r\nedac_dbg(0, "In single channel mode\n");\r\nn_channels = 1;\r\n} else {\r\nedac_dbg(0, "In dual channel mode\n");\r\nn_channels = 2;\r\n}\r\nif (capid0_2b & IE31200_CAPID0_DDPCD)\r\nedac_dbg(0, "2 DIMMS per channel disabled\n");\r\nelse\r\nedac_dbg(0, "2 DIMMS per channel enabled\n");\r\nreturn n_channels;\r\n}\r\nstatic bool ecc_capable(struct pci_dev *pdev)\r\n{\r\nunsigned char capid0_4b;\r\npci_read_config_byte(pdev, IE31200_CAPID0 + 3, &capid0_4b);\r\nif (capid0_4b & IE31200_CAPID0_ECC)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int eccerrlog_row(int channel, u64 log)\r\n{\r\nint rank = ((log & IE31200_ECCERRLOG_RANK_BITS) >>\r\nIE31200_ECCERRLOG_RANK_SHIFT);\r\nreturn rank | (channel * IE31200_RANKS_PER_CHANNEL);\r\n}\r\nstatic void ie31200_clear_error_info(struct mem_ctl_info *mci)\r\n{\r\npci_write_bits16(to_pci_dev(mci->pdev), IE31200_ERRSTS,\r\nIE31200_ERRSTS_BITS, IE31200_ERRSTS_BITS);\r\n}\r\nstatic void ie31200_get_and_clear_error_info(struct mem_ctl_info *mci,\r\nstruct ie31200_error_info *info)\r\n{\r\nstruct pci_dev *pdev;\r\nstruct ie31200_priv *priv = mci->pvt_info;\r\nvoid __iomem *window = priv->window;\r\npdev = to_pci_dev(mci->pdev);\r\npci_read_config_word(pdev, IE31200_ERRSTS, &info->errsts);\r\nif (!(info->errsts & IE31200_ERRSTS_BITS))\r\nreturn;\r\ninfo->eccerrlog[0] = lo_hi_readq(window + IE31200_C0ECCERRLOG);\r\nif (nr_channels == 2)\r\ninfo->eccerrlog[1] = lo_hi_readq(window + IE31200_C1ECCERRLOG);\r\npci_read_config_word(pdev, IE31200_ERRSTS, &info->errsts2);\r\nif ((info->errsts ^ info->errsts2) & IE31200_ERRSTS_BITS) {\r\ninfo->eccerrlog[0] = lo_hi_readq(window + IE31200_C0ECCERRLOG);\r\nif (nr_channels == 2)\r\ninfo->eccerrlog[1] =\r\nlo_hi_readq(window + IE31200_C1ECCERRLOG);\r\n}\r\nie31200_clear_error_info(mci);\r\n}\r\nstatic void ie31200_process_error_info(struct mem_ctl_info *mci,\r\nstruct ie31200_error_info *info)\r\n{\r\nint channel;\r\nu64 log;\r\nif (!(info->errsts & IE31200_ERRSTS_BITS))\r\nreturn;\r\nif ((info->errsts ^ info->errsts2) & IE31200_ERRSTS_BITS) {\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1, 0, 0, 0,\r\n-1, -1, -1, "UE overwrote CE", "");\r\ninfo->errsts = info->errsts2;\r\n}\r\nfor (channel = 0; channel < nr_channels; channel++) {\r\nlog = info->eccerrlog[channel];\r\nif (log & IE31200_ECCERRLOG_UE) {\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\r\n0, 0, 0,\r\neccerrlog_row(channel, log),\r\nchannel, -1,\r\n"ie31200 UE", "");\r\n} else if (log & IE31200_ECCERRLOG_CE) {\r\nedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\r\n0, 0,\r\nIE31200_ECCERRLOG_SYNDROME(log),\r\neccerrlog_row(channel, log),\r\nchannel, -1,\r\n"ie31200 CE", "");\r\n}\r\n}\r\n}\r\nstatic void ie31200_check(struct mem_ctl_info *mci)\r\n{\r\nstruct ie31200_error_info info;\r\nedac_dbg(1, "MC%d\n", mci->mc_idx);\r\nie31200_get_and_clear_error_info(mci, &info);\r\nie31200_process_error_info(mci, &info);\r\n}\r\nstatic void __iomem *ie31200_map_mchbar(struct pci_dev *pdev)\r\n{\r\nunion {\r\nu64 mchbar;\r\nstruct {\r\nu32 mchbar_low;\r\nu32 mchbar_high;\r\n};\r\n} u;\r\nvoid __iomem *window;\r\npci_read_config_dword(pdev, IE31200_MCHBAR_LOW, &u.mchbar_low);\r\npci_read_config_dword(pdev, IE31200_MCHBAR_HIGH, &u.mchbar_high);\r\nu.mchbar &= IE31200_MCHBAR_MASK;\r\nif (u.mchbar != (resource_size_t)u.mchbar) {\r\nie31200_printk(KERN_ERR, "mmio space beyond accessible range (0x%llx)\n",\r\n(unsigned long long)u.mchbar);\r\nreturn NULL;\r\n}\r\nwindow = ioremap_nocache(u.mchbar, IE31200_MMR_WINDOW_SIZE);\r\nif (!window)\r\nie31200_printk(KERN_ERR, "Cannot map mmio space at 0x%llx\n",\r\n(unsigned long long)u.mchbar);\r\nreturn window;\r\n}\r\nstatic int ie31200_probe1(struct pci_dev *pdev, int dev_idx)\r\n{\r\nint i, j, ret;\r\nstruct mem_ctl_info *mci = NULL;\r\nstruct edac_mc_layer layers[2];\r\nstruct dimm_data dimm_info[IE31200_CHANNELS][IE31200_DIMMS_PER_CHANNEL];\r\nvoid __iomem *window;\r\nstruct ie31200_priv *priv;\r\nu32 addr_decode;\r\nedac_dbg(0, "MC:\n");\r\nif (!ecc_capable(pdev)) {\r\nie31200_printk(KERN_INFO, "No ECC support\n");\r\nreturn -ENODEV;\r\n}\r\nnr_channels = how_many_channels(pdev);\r\nlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\r\nlayers[0].size = IE31200_DIMMS;\r\nlayers[0].is_virt_csrow = true;\r\nlayers[1].type = EDAC_MC_LAYER_CHANNEL;\r\nlayers[1].size = nr_channels;\r\nlayers[1].is_virt_csrow = false;\r\nmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers,\r\nsizeof(struct ie31200_priv));\r\nif (!mci)\r\nreturn -ENOMEM;\r\nwindow = ie31200_map_mchbar(pdev);\r\nif (!window) {\r\nret = -ENODEV;\r\ngoto fail_free;\r\n}\r\nedac_dbg(3, "MC: init mci\n");\r\nmci->pdev = &pdev->dev;\r\nmci->mtype_cap = MEM_FLAG_DDR3;\r\nmci->edac_ctl_cap = EDAC_FLAG_SECDED;\r\nmci->edac_cap = EDAC_FLAG_SECDED;\r\nmci->mod_name = EDAC_MOD_STR;\r\nmci->mod_ver = IE31200_REVISION;\r\nmci->ctl_name = ie31200_devs[dev_idx].ctl_name;\r\nmci->dev_name = pci_name(pdev);\r\nmci->edac_check = ie31200_check;\r\nmci->ctl_page_to_phys = NULL;\r\npriv = mci->pvt_info;\r\npriv->window = window;\r\nfor (i = 0; i < IE31200_CHANNELS; i++) {\r\naddr_decode = readl(window + IE31200_MAD_DIMM_0_OFFSET +\r\n(i * 4));\r\nedac_dbg(0, "addr_decode: 0x%x\n", addr_decode);\r\nfor (j = 0; j < IE31200_DIMMS_PER_CHANNEL; j++) {\r\ndimm_info[i][j].size = (addr_decode >> (j * 8)) &\r\nIE31200_MAD_DIMM_SIZE;\r\ndimm_info[i][j].dual_rank = (addr_decode &\r\n(IE31200_MAD_DIMM_A_RANK << j)) ? 1 : 0;\r\ndimm_info[i][j].x16_width = (addr_decode &\r\n(IE31200_MAD_DIMM_A_WIDTH << j)) ? 1 : 0;\r\nedac_dbg(0, "size: 0x%x, rank: %d, width: %d\n",\r\ndimm_info[i][j].size,\r\ndimm_info[i][j].dual_rank,\r\ndimm_info[i][j].x16_width);\r\n}\r\n}\r\nfor (i = 0; i < IE31200_DIMMS_PER_CHANNEL; i++) {\r\nfor (j = 0; j < IE31200_CHANNELS; j++) {\r\nstruct dimm_info *dimm;\r\nunsigned long nr_pages;\r\nnr_pages = IE31200_PAGES(dimm_info[j][i].size);\r\nif (nr_pages == 0)\r\ncontinue;\r\nif (dimm_info[j][i].dual_rank) {\r\nnr_pages = nr_pages / 2;\r\ndimm = EDAC_DIMM_PTR(mci->layers, mci->dimms,\r\nmci->n_layers, (i * 2) + 1,\r\nj, 0);\r\ndimm->nr_pages = nr_pages;\r\nedac_dbg(0, "set nr pages: 0x%lx\n", nr_pages);\r\ndimm->grain = 8;\r\ndimm->mtype = MEM_DDR3;\r\ndimm->dtype = DEV_UNKNOWN;\r\ndimm->edac_mode = EDAC_UNKNOWN;\r\n}\r\ndimm = EDAC_DIMM_PTR(mci->layers, mci->dimms,\r\nmci->n_layers, i * 2, j, 0);\r\ndimm->nr_pages = nr_pages;\r\nedac_dbg(0, "set nr pages: 0x%lx\n", nr_pages);\r\ndimm->grain = 8;\r\ndimm->mtype = MEM_DDR3;\r\ndimm->dtype = DEV_UNKNOWN;\r\ndimm->edac_mode = EDAC_UNKNOWN;\r\n}\r\n}\r\nie31200_clear_error_info(mci);\r\nif (edac_mc_add_mc(mci)) {\r\nedac_dbg(3, "MC: failed edac_mc_add_mc()\n");\r\nret = -ENODEV;\r\ngoto fail_unmap;\r\n}\r\nedac_dbg(3, "MC: success\n");\r\nreturn 0;\r\nfail_unmap:\r\niounmap(window);\r\nfail_free:\r\nedac_mc_free(mci);\r\nreturn ret;\r\n}\r\nstatic int ie31200_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nedac_dbg(0, "MC:\n");\r\nif (pci_enable_device(pdev) < 0)\r\nreturn -EIO;\r\nreturn ie31200_probe1(pdev, ent->driver_data);\r\n}\r\nstatic void ie31200_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct ie31200_priv *priv;\r\nedac_dbg(0, "\n");\r\nmci = edac_mc_del_mc(&pdev->dev);\r\nif (!mci)\r\nreturn;\r\npriv = mci->pvt_info;\r\niounmap(priv->window);\r\nedac_mc_free(mci);\r\n}\r\nstatic int __init ie31200_init(void)\r\n{\r\nedac_dbg(3, "MC:\n");\r\nopstate_init();\r\nreturn pci_register_driver(&ie31200_driver);\r\n}\r\nstatic void __exit ie31200_exit(void)\r\n{\r\nedac_dbg(3, "MC:\n");\r\npci_unregister_driver(&ie31200_driver);\r\n}
