static void *alloc_upcall(int opcode, int size)\r\n{\r\nunion inputArgs *inp;\r\nCODA_ALLOC(inp, union inputArgs *, size);\r\nif (!inp)\r\nreturn ERR_PTR(-ENOMEM);\r\ninp->ih.opcode = opcode;\r\ninp->ih.pid = task_pid_nr_ns(current, &init_pid_ns);\r\ninp->ih.pgid = task_pgrp_nr_ns(current, &init_pid_ns);\r\ninp->ih.uid = from_kuid(&init_user_ns, current_fsuid());\r\nreturn (void*)inp;\r\n}\r\nint venus_rootfid(struct super_block *sb, struct CodaFid *fidp)\r\n{\r\nunion inputArgs *inp;\r\nunion outputArgs *outp;\r\nint insize, outsize, error;\r\ninsize = SIZE(root);\r\nUPARG(CODA_ROOT);\r\nerror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\r\nif (!error)\r\n*fidp = outp->coda_root.VFid;\r\nCODA_FREE(inp, insize);\r\nreturn error;\r\n}\r\nint venus_getattr(struct super_block *sb, struct CodaFid *fid,\r\nstruct coda_vattr *attr)\r\n{\r\nunion inputArgs *inp;\r\nunion outputArgs *outp;\r\nint insize, outsize, error;\r\ninsize = SIZE(getattr);\r\nUPARG(CODA_GETATTR);\r\ninp->coda_getattr.VFid = *fid;\r\nerror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\r\nif (!error)\r\n*attr = outp->coda_getattr.attr;\r\nCODA_FREE(inp, insize);\r\nreturn error;\r\n}\r\nint venus_setattr(struct super_block *sb, struct CodaFid *fid,\r\nstruct coda_vattr *vattr)\r\n{\r\nunion inputArgs *inp;\r\nunion outputArgs *outp;\r\nint insize, outsize, error;\r\ninsize = SIZE(setattr);\r\nUPARG(CODA_SETATTR);\r\ninp->coda_setattr.VFid = *fid;\r\ninp->coda_setattr.attr = *vattr;\r\nerror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\r\nCODA_FREE(inp, insize);\r\nreturn error;\r\n}\r\nint venus_lookup(struct super_block *sb, struct CodaFid *fid,\r\nconst char *name, int length, int * type,\r\nstruct CodaFid *resfid)\r\n{\r\nunion inputArgs *inp;\r\nunion outputArgs *outp;\r\nint insize, outsize, error;\r\nint offset;\r\noffset = INSIZE(lookup);\r\ninsize = max_t(unsigned int, offset + length +1, OUTSIZE(lookup));\r\nUPARG(CODA_LOOKUP);\r\ninp->coda_lookup.VFid = *fid;\r\ninp->coda_lookup.name = offset;\r\ninp->coda_lookup.flags = CLU_CASE_SENSITIVE;\r\nmemcpy((char *)(inp) + offset, name, length);\r\n*((char *)inp + offset + length) = '\0';\r\nerror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\r\nif (!error) {\r\n*resfid = outp->coda_lookup.VFid;\r\n*type = outp->coda_lookup.vtype;\r\n}\r\nCODA_FREE(inp, insize);\r\nreturn error;\r\n}\r\nint venus_close(struct super_block *sb, struct CodaFid *fid, int flags,\r\nkuid_t uid)\r\n{\r\nunion inputArgs *inp;\r\nunion outputArgs *outp;\r\nint insize, outsize, error;\r\ninsize = SIZE(release);\r\nUPARG(CODA_CLOSE);\r\ninp->ih.uid = from_kuid(&init_user_ns, uid);\r\ninp->coda_close.VFid = *fid;\r\ninp->coda_close.flags = flags;\r\nerror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\r\nCODA_FREE(inp, insize);\r\nreturn error;\r\n}\r\nint venus_open(struct super_block *sb, struct CodaFid *fid,\r\nint flags, struct file **fh)\r\n{\r\nunion inputArgs *inp;\r\nunion outputArgs *outp;\r\nint insize, outsize, error;\r\ninsize = SIZE(open_by_fd);\r\nUPARG(CODA_OPEN_BY_FD);\r\ninp->coda_open_by_fd.VFid = *fid;\r\ninp->coda_open_by_fd.flags = flags;\r\nerror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\r\nif (!error)\r\n*fh = outp->coda_open_by_fd.fh;\r\nCODA_FREE(inp, insize);\r\nreturn error;\r\n}\r\nint venus_mkdir(struct super_block *sb, struct CodaFid *dirfid,\r\nconst char *name, int length,\r\nstruct CodaFid *newfid, struct coda_vattr *attrs)\r\n{\r\nunion inputArgs *inp;\r\nunion outputArgs *outp;\r\nint insize, outsize, error;\r\nint offset;\r\noffset = INSIZE(mkdir);\r\ninsize = max_t(unsigned int, offset + length + 1, OUTSIZE(mkdir));\r\nUPARG(CODA_MKDIR);\r\ninp->coda_mkdir.VFid = *dirfid;\r\ninp->coda_mkdir.attr = *attrs;\r\ninp->coda_mkdir.name = offset;\r\nmemcpy((char *)(inp) + offset, name, length);\r\n*((char *)inp + offset + length) = '\0';\r\nerror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\r\nif (!error) {\r\n*attrs = outp->coda_mkdir.attr;\r\n*newfid = outp->coda_mkdir.VFid;\r\n}\r\nCODA_FREE(inp, insize);\r\nreturn error;\r\n}\r\nint venus_rename(struct super_block *sb, struct CodaFid *old_fid,\r\nstruct CodaFid *new_fid, size_t old_length,\r\nsize_t new_length, const char *old_name,\r\nconst char *new_name)\r\n{\r\nunion inputArgs *inp;\r\nunion outputArgs *outp;\r\nint insize, outsize, error;\r\nint offset, s;\r\noffset = INSIZE(rename);\r\ninsize = max_t(unsigned int, offset + new_length + old_length + 8,\r\nOUTSIZE(rename));\r\nUPARG(CODA_RENAME);\r\ninp->coda_rename.sourceFid = *old_fid;\r\ninp->coda_rename.destFid = *new_fid;\r\ninp->coda_rename.srcname = offset;\r\ns = ( old_length & ~0x3) +4;\r\nmemcpy((char *)(inp) + offset, old_name, old_length);\r\n*((char *)inp + offset + old_length) = '\0';\r\noffset += s;\r\ninp->coda_rename.destname = offset;\r\ns = ( new_length & ~0x3) +4;\r\nmemcpy((char *)(inp) + offset, new_name, new_length);\r\n*((char *)inp + offset + new_length) = '\0';\r\nerror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\r\nCODA_FREE(inp, insize);\r\nreturn error;\r\n}\r\nint venus_create(struct super_block *sb, struct CodaFid *dirfid,\r\nconst char *name, int length, int excl, int mode,\r\nstruct CodaFid *newfid, struct coda_vattr *attrs)\r\n{\r\nunion inputArgs *inp;\r\nunion outputArgs *outp;\r\nint insize, outsize, error;\r\nint offset;\r\noffset = INSIZE(create);\r\ninsize = max_t(unsigned int, offset + length + 1, OUTSIZE(create));\r\nUPARG(CODA_CREATE);\r\ninp->coda_create.VFid = *dirfid;\r\ninp->coda_create.attr.va_mode = mode;\r\ninp->coda_create.excl = excl;\r\ninp->coda_create.mode = mode;\r\ninp->coda_create.name = offset;\r\nmemcpy((char *)(inp) + offset, name, length);\r\n*((char *)inp + offset + length) = '\0';\r\nerror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\r\nif (!error) {\r\n*attrs = outp->coda_create.attr;\r\n*newfid = outp->coda_create.VFid;\r\n}\r\nCODA_FREE(inp, insize);\r\nreturn error;\r\n}\r\nint venus_rmdir(struct super_block *sb, struct CodaFid *dirfid,\r\nconst char *name, int length)\r\n{\r\nunion inputArgs *inp;\r\nunion outputArgs *outp;\r\nint insize, outsize, error;\r\nint offset;\r\noffset = INSIZE(rmdir);\r\ninsize = max_t(unsigned int, offset + length + 1, OUTSIZE(rmdir));\r\nUPARG(CODA_RMDIR);\r\ninp->coda_rmdir.VFid = *dirfid;\r\ninp->coda_rmdir.name = offset;\r\nmemcpy((char *)(inp) + offset, name, length);\r\n*((char *)inp + offset + length) = '\0';\r\nerror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\r\nCODA_FREE(inp, insize);\r\nreturn error;\r\n}\r\nint venus_remove(struct super_block *sb, struct CodaFid *dirfid,\r\nconst char *name, int length)\r\n{\r\nunion inputArgs *inp;\r\nunion outputArgs *outp;\r\nint error=0, insize, outsize, offset;\r\noffset = INSIZE(remove);\r\ninsize = max_t(unsigned int, offset + length + 1, OUTSIZE(remove));\r\nUPARG(CODA_REMOVE);\r\ninp->coda_remove.VFid = *dirfid;\r\ninp->coda_remove.name = offset;\r\nmemcpy((char *)(inp) + offset, name, length);\r\n*((char *)inp + offset + length) = '\0';\r\nerror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\r\nCODA_FREE(inp, insize);\r\nreturn error;\r\n}\r\nint venus_readlink(struct super_block *sb, struct CodaFid *fid,\r\nchar *buffer, int *length)\r\n{\r\nunion inputArgs *inp;\r\nunion outputArgs *outp;\r\nint insize, outsize, error;\r\nint retlen;\r\nchar *result;\r\ninsize = max_t(unsigned int,\r\nINSIZE(readlink), OUTSIZE(readlink)+ *length + 1);\r\nUPARG(CODA_READLINK);\r\ninp->coda_readlink.VFid = *fid;\r\nerror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\r\nif (!error) {\r\nretlen = outp->coda_readlink.count;\r\nif ( retlen > *length )\r\nretlen = *length;\r\n*length = retlen;\r\nresult = (char *)outp + (long)outp->coda_readlink.data;\r\nmemcpy(buffer, result, retlen);\r\n*(buffer + retlen) = '\0';\r\n}\r\nCODA_FREE(inp, insize);\r\nreturn error;\r\n}\r\nint venus_link(struct super_block *sb, struct CodaFid *fid,\r\nstruct CodaFid *dirfid, const char *name, int len )\r\n{\r\nunion inputArgs *inp;\r\nunion outputArgs *outp;\r\nint insize, outsize, error;\r\nint offset;\r\noffset = INSIZE(link);\r\ninsize = max_t(unsigned int, offset + len + 1, OUTSIZE(link));\r\nUPARG(CODA_LINK);\r\ninp->coda_link.sourceFid = *fid;\r\ninp->coda_link.destFid = *dirfid;\r\ninp->coda_link.tname = offset;\r\nmemcpy((char *)(inp) + offset, name, len);\r\n*((char *)inp + offset + len) = '\0';\r\nerror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\r\nCODA_FREE(inp, insize);\r\nreturn error;\r\n}\r\nint venus_symlink(struct super_block *sb, struct CodaFid *fid,\r\nconst char *name, int len,\r\nconst char *symname, int symlen)\r\n{\r\nunion inputArgs *inp;\r\nunion outputArgs *outp;\r\nint insize, outsize, error;\r\nint offset, s;\r\noffset = INSIZE(symlink);\r\ninsize = max_t(unsigned int, offset + len + symlen + 8, OUTSIZE(symlink));\r\nUPARG(CODA_SYMLINK);\r\ninp->coda_symlink.VFid = *fid;\r\ninp->coda_symlink.srcname = offset;\r\ns = ( symlen & ~0x3 ) + 4;\r\nmemcpy((char *)(inp) + offset, symname, symlen);\r\n*((char *)inp + offset + symlen) = '\0';\r\noffset += s;\r\ninp->coda_symlink.tname = offset;\r\ns = (len & ~0x3) + 4;\r\nmemcpy((char *)(inp) + offset, name, len);\r\n*((char *)inp + offset + len) = '\0';\r\nerror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\r\nCODA_FREE(inp, insize);\r\nreturn error;\r\n}\r\nint venus_fsync(struct super_block *sb, struct CodaFid *fid)\r\n{\r\nunion inputArgs *inp;\r\nunion outputArgs *outp;\r\nint insize, outsize, error;\r\ninsize=SIZE(fsync);\r\nUPARG(CODA_FSYNC);\r\ninp->coda_fsync.VFid = *fid;\r\nerror = coda_upcall(coda_vcp(sb), sizeof(union inputArgs),\r\n&outsize, inp);\r\nCODA_FREE(inp, insize);\r\nreturn error;\r\n}\r\nint venus_access(struct super_block *sb, struct CodaFid *fid, int mask)\r\n{\r\nunion inputArgs *inp;\r\nunion outputArgs *outp;\r\nint insize, outsize, error;\r\ninsize = SIZE(access);\r\nUPARG(CODA_ACCESS);\r\ninp->coda_access.VFid = *fid;\r\ninp->coda_access.flags = mask;\r\nerror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\r\nCODA_FREE(inp, insize);\r\nreturn error;\r\n}\r\nint venus_pioctl(struct super_block *sb, struct CodaFid *fid,\r\nunsigned int cmd, struct PioctlData *data)\r\n{\r\nunion inputArgs *inp;\r\nunion outputArgs *outp;\r\nint insize, outsize, error;\r\nint iocsize;\r\ninsize = VC_MAXMSGSIZE;\r\nUPARG(CODA_IOCTL);\r\nif (data->vi.in_size > VC_MAXDATASIZE) {\r\nerror = -EINVAL;\r\ngoto exit;\r\n}\r\nif (data->vi.out_size > VC_MAXDATASIZE) {\r\nerror = -EINVAL;\r\ngoto exit;\r\n}\r\ninp->coda_ioctl.VFid = *fid;\r\ninp->coda_ioctl.cmd = (cmd & ~(PIOCPARM_MASK << 16));\r\niocsize = ((cmd >> 16) & PIOCPARM_MASK) - sizeof(char *) - sizeof(int);\r\ninp->coda_ioctl.cmd |= (iocsize & PIOCPARM_MASK) << 16;\r\ninp->coda_ioctl.len = data->vi.in_size;\r\ninp->coda_ioctl.data = (char *)(INSIZE(ioctl));\r\nif (copy_from_user((char *)inp + (long)inp->coda_ioctl.data,\r\ndata->vi.in, data->vi.in_size)) {\r\nerror = -EINVAL;\r\ngoto exit;\r\n}\r\nerror = coda_upcall(coda_vcp(sb), SIZE(ioctl) + data->vi.in_size,\r\n&outsize, inp);\r\nif (error) {\r\npr_warn("%s: Venus returns: %d for %s\n",\r\n__func__, error, coda_f2s(fid));\r\ngoto exit;\r\n}\r\nif (outsize < (long)outp->coda_ioctl.data + outp->coda_ioctl.len) {\r\nerror = -EINVAL;\r\ngoto exit;\r\n}\r\nif (outp->coda_ioctl.len > data->vi.out_size) {\r\nerror = -EINVAL;\r\ngoto exit;\r\n}\r\nif (copy_to_user(data->vi.out,\r\n(char *)outp + (long)outp->coda_ioctl.data,\r\noutp->coda_ioctl.len)) {\r\nerror = -EFAULT;\r\ngoto exit;\r\n}\r\nexit:\r\nCODA_FREE(inp, insize);\r\nreturn error;\r\n}\r\nint venus_statfs(struct dentry *dentry, struct kstatfs *sfs)\r\n{\r\nunion inputArgs *inp;\r\nunion outputArgs *outp;\r\nint insize, outsize, error;\r\ninsize = max_t(unsigned int, INSIZE(statfs), OUTSIZE(statfs));\r\nUPARG(CODA_STATFS);\r\nerror = coda_upcall(coda_vcp(dentry->d_sb), insize, &outsize, inp);\r\nif (!error) {\r\nsfs->f_blocks = outp->coda_statfs.stat.f_blocks;\r\nsfs->f_bfree = outp->coda_statfs.stat.f_bfree;\r\nsfs->f_bavail = outp->coda_statfs.stat.f_bavail;\r\nsfs->f_files = outp->coda_statfs.stat.f_files;\r\nsfs->f_ffree = outp->coda_statfs.stat.f_ffree;\r\n}\r\nCODA_FREE(inp, insize);\r\nreturn error;\r\n}\r\nstatic void coda_block_signals(sigset_t *old)\r\n{\r\nspin_lock_irq(&current->sighand->siglock);\r\n*old = current->blocked;\r\nsigfillset(&current->blocked);\r\nsigdelset(&current->blocked, SIGKILL);\r\nsigdelset(&current->blocked, SIGSTOP);\r\nsigdelset(&current->blocked, SIGINT);\r\nrecalc_sigpending();\r\nspin_unlock_irq(&current->sighand->siglock);\r\n}\r\nstatic void coda_unblock_signals(sigset_t *old)\r\n{\r\nspin_lock_irq(&current->sighand->siglock);\r\ncurrent->blocked = *old;\r\nrecalc_sigpending();\r\nspin_unlock_irq(&current->sighand->siglock);\r\n}\r\nstatic inline void coda_waitfor_upcall(struct venus_comm *vcp,\r\nstruct upc_req *req)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nunsigned long timeout = jiffies + coda_timeout * HZ;\r\nsigset_t old;\r\nint blocked;\r\ncoda_block_signals(&old);\r\nblocked = 1;\r\nadd_wait_queue(&req->uc_sleep, &wait);\r\nfor (;;) {\r\nif (CODA_INTERRUPTIBLE(req))\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nelse\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nif (req->uc_flags & (CODA_REQ_WRITE | CODA_REQ_ABORT))\r\nbreak;\r\nif (blocked && time_after(jiffies, timeout) &&\r\nCODA_INTERRUPTIBLE(req))\r\n{\r\ncoda_unblock_signals(&old);\r\nblocked = 0;\r\n}\r\nif (signal_pending(current)) {\r\nlist_del(&req->uc_chain);\r\nbreak;\r\n}\r\nmutex_unlock(&vcp->vc_mutex);\r\nif (blocked)\r\nschedule_timeout(HZ);\r\nelse\r\nschedule();\r\nmutex_lock(&vcp->vc_mutex);\r\n}\r\nif (blocked)\r\ncoda_unblock_signals(&old);\r\nremove_wait_queue(&req->uc_sleep, &wait);\r\nset_current_state(TASK_RUNNING);\r\n}\r\nstatic int coda_upcall(struct venus_comm *vcp,\r\nint inSize, int *outSize,\r\nunion inputArgs *buffer)\r\n{\r\nunion outputArgs *out;\r\nunion inputArgs *sig_inputArgs;\r\nstruct upc_req *req = NULL, *sig_req;\r\nint error;\r\nmutex_lock(&vcp->vc_mutex);\r\nif (!vcp->vc_inuse) {\r\npr_notice("Venus dead, not sending upcall\n");\r\nerror = -ENXIO;\r\ngoto exit;\r\n}\r\nreq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\r\nif (!req) {\r\nerror = -ENOMEM;\r\ngoto exit;\r\n}\r\nreq->uc_data = (void *)buffer;\r\nreq->uc_flags = 0;\r\nreq->uc_inSize = inSize;\r\nreq->uc_outSize = *outSize ? *outSize : inSize;\r\nreq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\r\nreq->uc_unique = ++vcp->vc_seq;\r\ninit_waitqueue_head(&req->uc_sleep);\r\n((union inputArgs *)buffer)->ih.unique = req->uc_unique;\r\nlist_add_tail(&req->uc_chain, &vcp->vc_pending);\r\nwake_up_interruptible(&vcp->vc_waitq);\r\ncoda_waitfor_upcall(vcp, req);\r\nif (req->uc_flags & CODA_REQ_WRITE) {\r\nout = (union outputArgs *)req->uc_data;\r\nerror = -out->oh.result;\r\n*outSize = req->uc_outSize;\r\ngoto exit;\r\n}\r\nerror = -EINTR;\r\nif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\r\npr_warn("Unexpected interruption.\n");\r\ngoto exit;\r\n}\r\nif (!(req->uc_flags & CODA_REQ_READ))\r\ngoto exit;\r\nif (!vcp->vc_inuse) {\r\npr_info("Venus dead, not sending signal.\n");\r\ngoto exit;\r\n}\r\nerror = -ENOMEM;\r\nsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\r\nif (!sig_req) goto exit;\r\nCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\r\nif (!sig_req->uc_data) {\r\nkfree(sig_req);\r\ngoto exit;\r\n}\r\nerror = -EINTR;\r\nsig_inputArgs = (union inputArgs *)sig_req->uc_data;\r\nsig_inputArgs->ih.opcode = CODA_SIGNAL;\r\nsig_inputArgs->ih.unique = req->uc_unique;\r\nsig_req->uc_flags = CODA_REQ_ASYNC;\r\nsig_req->uc_opcode = sig_inputArgs->ih.opcode;\r\nsig_req->uc_unique = sig_inputArgs->ih.unique;\r\nsig_req->uc_inSize = sizeof(struct coda_in_hdr);\r\nsig_req->uc_outSize = sizeof(struct coda_in_hdr);\r\nlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\r\nwake_up_interruptible(&vcp->vc_waitq);\r\nexit:\r\nkfree(req);\r\nmutex_unlock(&vcp->vc_mutex);\r\nreturn error;\r\n}\r\nint coda_downcall(struct venus_comm *vcp, int opcode, union outputArgs *out)\r\n{\r\nstruct inode *inode = NULL;\r\nstruct CodaFid *fid = NULL, *newfid;\r\nstruct super_block *sb;\r\nmutex_lock(&vcp->vc_mutex);\r\nsb = vcp->vc_sb;\r\nif (!sb || !sb->s_root)\r\ngoto unlock_out;\r\nswitch (opcode) {\r\ncase CODA_FLUSH:\r\ncoda_cache_clear_all(sb);\r\nshrink_dcache_sb(sb);\r\nif (d_really_is_positive(sb->s_root))\r\ncoda_flag_inode(d_inode(sb->s_root), C_FLUSH);\r\nbreak;\r\ncase CODA_PURGEUSER:\r\ncoda_cache_clear_all(sb);\r\nbreak;\r\ncase CODA_ZAPDIR:\r\nfid = &out->coda_zapdir.CodaFid;\r\nbreak;\r\ncase CODA_ZAPFILE:\r\nfid = &out->coda_zapfile.CodaFid;\r\nbreak;\r\ncase CODA_PURGEFID:\r\nfid = &out->coda_purgefid.CodaFid;\r\nbreak;\r\ncase CODA_REPLACE:\r\nfid = &out->coda_replace.OldFid;\r\nbreak;\r\n}\r\nif (fid)\r\ninode = coda_fid_to_inode(fid, sb);\r\nunlock_out:\r\nmutex_unlock(&vcp->vc_mutex);\r\nif (!inode)\r\nreturn 0;\r\nswitch (opcode) {\r\ncase CODA_ZAPDIR:\r\ncoda_flag_inode_children(inode, C_PURGE);\r\ncoda_flag_inode(inode, C_VATTR);\r\nbreak;\r\ncase CODA_ZAPFILE:\r\ncoda_flag_inode(inode, C_VATTR);\r\nbreak;\r\ncase CODA_PURGEFID:\r\ncoda_flag_inode_children(inode, C_PURGE);\r\ncoda_flag_inode(inode, C_PURGE);\r\nd_prune_aliases(inode);\r\nbreak;\r\ncase CODA_REPLACE:\r\nnewfid = &out->coda_replace.NewFid;\r\ncoda_replace_fid(inode, fid, newfid);\r\nbreak;\r\n}\r\niput(inode);\r\nreturn 0;\r\n}
