static s32 loff_t_to_s32(loff_t offset)\r\n{\r\ns32 res;\r\nif (offset >= NLM_OFFSET_MAX)\r\nres = NLM_OFFSET_MAX;\r\nelse if (offset <= -NLM_OFFSET_MAX)\r\nres = -NLM_OFFSET_MAX;\r\nelse\r\nres = offset;\r\nreturn res;\r\n}\r\nstatic void nlm_compute_offsets(const struct nlm_lock *lock,\r\nu32 *l_offset, u32 *l_len)\r\n{\r\nconst struct file_lock *fl = &lock->fl;\r\n*l_offset = loff_t_to_s32(fl->fl_start);\r\nif (fl->fl_end == OFFSET_MAX)\r\n*l_len = 0;\r\nelse\r\n*l_len = loff_t_to_s32(fl->fl_end - fl->fl_start + 1);\r\n}\r\nstatic void print_overflow_msg(const char *func, const struct xdr_stream *xdr)\r\n{\r\ndprintk("lockd: %s prematurely hit the end of our receive buffer. "\r\n"Remaining buffer length is %tu words.\n",\r\nfunc, xdr->end - xdr->p);\r\n}\r\nstatic void encode_bool(struct xdr_stream *xdr, const int value)\r\n{\r\n__be32 *p;\r\np = xdr_reserve_space(xdr, 4);\r\n*p = value ? xdr_one : xdr_zero;\r\n}\r\nstatic void encode_int32(struct xdr_stream *xdr, const s32 value)\r\n{\r\n__be32 *p;\r\np = xdr_reserve_space(xdr, 4);\r\n*p = cpu_to_be32(value);\r\n}\r\nstatic void encode_netobj(struct xdr_stream *xdr,\r\nconst u8 *data, const unsigned int length)\r\n{\r\n__be32 *p;\r\np = xdr_reserve_space(xdr, 4 + length);\r\nxdr_encode_opaque(p, data, length);\r\n}\r\nstatic int decode_netobj(struct xdr_stream *xdr,\r\nstruct xdr_netobj *obj)\r\n{\r\nu32 length;\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nlength = be32_to_cpup(p++);\r\nif (unlikely(length > XDR_MAX_NETOBJ))\r\ngoto out_size;\r\nobj->len = length;\r\nobj->data = (u8 *)p;\r\nreturn 0;\r\nout_size:\r\ndprintk("NFS: returned netobj was too long: %u\n", length);\r\nreturn -EIO;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic void encode_cookie(struct xdr_stream *xdr,\r\nconst struct nlm_cookie *cookie)\r\n{\r\nencode_netobj(xdr, (u8 *)&cookie->data, cookie->len);\r\n}\r\nstatic int decode_cookie(struct xdr_stream *xdr,\r\nstruct nlm_cookie *cookie)\r\n{\r\nu32 length;\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nlength = be32_to_cpup(p++);\r\nif (length == 0)\r\ngoto out_hpux;\r\nif (length > NLM_MAXCOOKIELEN)\r\ngoto out_size;\r\np = xdr_inline_decode(xdr, length);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\ncookie->len = length;\r\nmemcpy(cookie->data, p, length);\r\nreturn 0;\r\nout_hpux:\r\ncookie->len = 4;\r\nmemset(cookie->data, 0, 4);\r\nreturn 0;\r\nout_size:\r\ndprintk("NFS: returned cookie was too long: %u\n", length);\r\nreturn -EIO;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic void encode_fh(struct xdr_stream *xdr, const struct nfs_fh *fh)\r\n{\r\nencode_netobj(xdr, (u8 *)&fh->data, NFS2_FHSIZE);\r\n}\r\nstatic void encode_nlm_stat(struct xdr_stream *xdr,\r\nconst __be32 stat)\r\n{\r\n__be32 *p;\r\nWARN_ON_ONCE(be32_to_cpu(stat) > NLM_LCK_DENIED_GRACE_PERIOD);\r\np = xdr_reserve_space(xdr, 4);\r\n*p = stat;\r\n}\r\nstatic int decode_nlm_stat(struct xdr_stream *xdr,\r\n__be32 *stat)\r\n{\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nif (unlikely(ntohl(*p) > ntohl(nlm_lck_denied_grace_period)))\r\ngoto out_enum;\r\n*stat = *p;\r\nreturn 0;\r\nout_enum:\r\ndprintk("%s: server returned invalid nlm_stats value: %u\n",\r\n__func__, be32_to_cpup(p));\r\nreturn -EIO;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic void encode_nlm_holder(struct xdr_stream *xdr,\r\nconst struct nlm_res *result)\r\n{\r\nconst struct nlm_lock *lock = &result->lock;\r\nu32 l_offset, l_len;\r\n__be32 *p;\r\nencode_bool(xdr, lock->fl.fl_type == F_RDLCK);\r\nencode_int32(xdr, lock->svid);\r\nencode_netobj(xdr, lock->oh.data, lock->oh.len);\r\np = xdr_reserve_space(xdr, 4 + 4);\r\nnlm_compute_offsets(lock, &l_offset, &l_len);\r\n*p++ = cpu_to_be32(l_offset);\r\n*p = cpu_to_be32(l_len);\r\n}\r\nstatic int decode_nlm_holder(struct xdr_stream *xdr, struct nlm_res *result)\r\n{\r\nstruct nlm_lock *lock = &result->lock;\r\nstruct file_lock *fl = &lock->fl;\r\nu32 exclusive, l_offset, l_len;\r\nint error;\r\n__be32 *p;\r\ns32 end;\r\nmemset(lock, 0, sizeof(*lock));\r\nlocks_init_lock(fl);\r\np = xdr_inline_decode(xdr, 4 + 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nexclusive = be32_to_cpup(p++);\r\nlock->svid = be32_to_cpup(p);\r\nfl->fl_pid = (pid_t)lock->svid;\r\nerror = decode_netobj(xdr, &lock->oh);\r\nif (unlikely(error))\r\ngoto out;\r\np = xdr_inline_decode(xdr, 4 + 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nfl->fl_flags = FL_POSIX;\r\nfl->fl_type = exclusive != 0 ? F_WRLCK : F_RDLCK;\r\nl_offset = be32_to_cpup(p++);\r\nl_len = be32_to_cpup(p);\r\nend = l_offset + l_len - 1;\r\nfl->fl_start = (loff_t)l_offset;\r\nif (l_len == 0 || end < 0)\r\nfl->fl_end = OFFSET_MAX;\r\nelse\r\nfl->fl_end = (loff_t)end;\r\nerror = 0;\r\nout:\r\nreturn error;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic void encode_caller_name(struct xdr_stream *xdr, const char *name)\r\n{\r\nu32 length = strlen(name);\r\n__be32 *p;\r\np = xdr_reserve_space(xdr, 4 + length);\r\nxdr_encode_opaque(p, name, length);\r\n}\r\nstatic void encode_nlm_lock(struct xdr_stream *xdr,\r\nconst struct nlm_lock *lock)\r\n{\r\nu32 l_offset, l_len;\r\n__be32 *p;\r\nencode_caller_name(xdr, lock->caller);\r\nencode_fh(xdr, &lock->fh);\r\nencode_netobj(xdr, lock->oh.data, lock->oh.len);\r\np = xdr_reserve_space(xdr, 4 + 4 + 4);\r\n*p++ = cpu_to_be32(lock->svid);\r\nnlm_compute_offsets(lock, &l_offset, &l_len);\r\n*p++ = cpu_to_be32(l_offset);\r\n*p = cpu_to_be32(l_len);\r\n}\r\nstatic void nlm_xdr_enc_testargs(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nlm_args *args)\r\n{\r\nconst struct nlm_lock *lock = &args->lock;\r\nencode_cookie(xdr, &args->cookie);\r\nencode_bool(xdr, lock->fl.fl_type == F_WRLCK);\r\nencode_nlm_lock(xdr, lock);\r\n}\r\nstatic void nlm_xdr_enc_lockargs(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nlm_args *args)\r\n{\r\nconst struct nlm_lock *lock = &args->lock;\r\nencode_cookie(xdr, &args->cookie);\r\nencode_bool(xdr, args->block);\r\nencode_bool(xdr, lock->fl.fl_type == F_WRLCK);\r\nencode_nlm_lock(xdr, lock);\r\nencode_bool(xdr, args->reclaim);\r\nencode_int32(xdr, args->state);\r\n}\r\nstatic void nlm_xdr_enc_cancargs(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nlm_args *args)\r\n{\r\nconst struct nlm_lock *lock = &args->lock;\r\nencode_cookie(xdr, &args->cookie);\r\nencode_bool(xdr, args->block);\r\nencode_bool(xdr, lock->fl.fl_type == F_WRLCK);\r\nencode_nlm_lock(xdr, lock);\r\n}\r\nstatic void nlm_xdr_enc_unlockargs(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nlm_args *args)\r\n{\r\nconst struct nlm_lock *lock = &args->lock;\r\nencode_cookie(xdr, &args->cookie);\r\nencode_nlm_lock(xdr, lock);\r\n}\r\nstatic void nlm_xdr_enc_res(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nlm_res *result)\r\n{\r\nencode_cookie(xdr, &result->cookie);\r\nencode_nlm_stat(xdr, result->status);\r\n}\r\nstatic void encode_nlm_testrply(struct xdr_stream *xdr,\r\nconst struct nlm_res *result)\r\n{\r\nif (result->status == nlm_lck_denied)\r\nencode_nlm_holder(xdr, result);\r\n}\r\nstatic void nlm_xdr_enc_testres(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nconst struct nlm_res *result)\r\n{\r\nencode_cookie(xdr, &result->cookie);\r\nencode_nlm_stat(xdr, result->status);\r\nencode_nlm_testrply(xdr, result);\r\n}\r\nstatic int decode_nlm_testrply(struct xdr_stream *xdr,\r\nstruct nlm_res *result)\r\n{\r\nint error;\r\nerror = decode_nlm_stat(xdr, &result->status);\r\nif (unlikely(error))\r\ngoto out;\r\nif (result->status == nlm_lck_denied)\r\nerror = decode_nlm_holder(xdr, result);\r\nout:\r\nreturn error;\r\n}\r\nstatic int nlm_xdr_dec_testres(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nstruct nlm_res *result)\r\n{\r\nint error;\r\nerror = decode_cookie(xdr, &result->cookie);\r\nif (unlikely(error))\r\ngoto out;\r\nerror = decode_nlm_testrply(xdr, result);\r\nout:\r\nreturn error;\r\n}\r\nstatic int nlm_xdr_dec_res(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nstruct nlm_res *result)\r\n{\r\nint error;\r\nerror = decode_cookie(xdr, &result->cookie);\r\nif (unlikely(error))\r\ngoto out;\r\nerror = decode_nlm_stat(xdr, &result->status);\r\nout:\r\nreturn error;\r\n}
