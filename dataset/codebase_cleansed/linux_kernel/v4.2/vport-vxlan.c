static inline struct vxlan_port *vxlan_vport(const struct vport *vport)\r\n{\r\nreturn vport_priv(vport);\r\n}\r\nstatic void vxlan_rcv(struct vxlan_sock *vs, struct sk_buff *skb,\r\nstruct vxlan_metadata *md)\r\n{\r\nstruct ovs_tunnel_info tun_info;\r\nstruct vxlan_port *vxlan_port;\r\nstruct vport *vport = vs->data;\r\nstruct iphdr *iph;\r\nstruct ovs_vxlan_opts opts = {\r\n.gbp = md->gbp,\r\n};\r\n__be64 key;\r\n__be16 flags;\r\nflags = TUNNEL_KEY | (udp_hdr(skb)->check != 0 ? TUNNEL_CSUM : 0);\r\nvxlan_port = vxlan_vport(vport);\r\nif (vxlan_port->exts & VXLAN_F_GBP && md->gbp)\r\nflags |= TUNNEL_VXLAN_OPT;\r\niph = ip_hdr(skb);\r\nkey = cpu_to_be64(ntohl(md->vni) >> 8);\r\novs_flow_tun_info_init(&tun_info, iph,\r\nudp_hdr(skb)->source, udp_hdr(skb)->dest,\r\nkey, flags, &opts, sizeof(opts));\r\novs_vport_receive(vport, skb, &tun_info);\r\n}\r\nstatic int vxlan_get_options(const struct vport *vport, struct sk_buff *skb)\r\n{\r\nstruct vxlan_port *vxlan_port = vxlan_vport(vport);\r\n__be16 dst_port = inet_sk(vxlan_port->vs->sock->sk)->inet_sport;\r\nif (nla_put_u16(skb, OVS_TUNNEL_ATTR_DST_PORT, ntohs(dst_port)))\r\nreturn -EMSGSIZE;\r\nif (vxlan_port->exts) {\r\nstruct nlattr *exts;\r\nexts = nla_nest_start(skb, OVS_TUNNEL_ATTR_EXTENSION);\r\nif (!exts)\r\nreturn -EMSGSIZE;\r\nif (vxlan_port->exts & VXLAN_F_GBP &&\r\nnla_put_flag(skb, OVS_VXLAN_EXT_GBP))\r\nreturn -EMSGSIZE;\r\nnla_nest_end(skb, exts);\r\n}\r\nreturn 0;\r\n}\r\nstatic void vxlan_tnl_destroy(struct vport *vport)\r\n{\r\nstruct vxlan_port *vxlan_port = vxlan_vport(vport);\r\nvxlan_sock_release(vxlan_port->vs);\r\novs_vport_deferred_free(vport);\r\n}\r\nstatic int vxlan_configure_exts(struct vport *vport, struct nlattr *attr)\r\n{\r\nstruct nlattr *exts[OVS_VXLAN_EXT_MAX+1];\r\nstruct vxlan_port *vxlan_port;\r\nint err;\r\nif (nla_len(attr) < sizeof(struct nlattr))\r\nreturn -EINVAL;\r\nerr = nla_parse_nested(exts, OVS_VXLAN_EXT_MAX, attr, exts_policy);\r\nif (err < 0)\r\nreturn err;\r\nvxlan_port = vxlan_vport(vport);\r\nif (exts[OVS_VXLAN_EXT_GBP])\r\nvxlan_port->exts |= VXLAN_F_GBP;\r\nreturn 0;\r\n}\r\nstatic struct vport *vxlan_tnl_create(const struct vport_parms *parms)\r\n{\r\nstruct net *net = ovs_dp_get_net(parms->dp);\r\nstruct nlattr *options = parms->options;\r\nstruct vxlan_port *vxlan_port;\r\nstruct vxlan_sock *vs;\r\nstruct vport *vport;\r\nstruct nlattr *a;\r\nu16 dst_port;\r\nint err;\r\nif (!options) {\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\na = nla_find_nested(options, OVS_TUNNEL_ATTR_DST_PORT);\r\nif (a && nla_len(a) == sizeof(u16)) {\r\ndst_port = nla_get_u16(a);\r\n} else {\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\nvport = ovs_vport_alloc(sizeof(struct vxlan_port),\r\n&ovs_vxlan_vport_ops, parms);\r\nif (IS_ERR(vport))\r\nreturn vport;\r\nvxlan_port = vxlan_vport(vport);\r\nstrncpy(vxlan_port->name, parms->name, IFNAMSIZ);\r\na = nla_find_nested(options, OVS_TUNNEL_ATTR_EXTENSION);\r\nif (a) {\r\nerr = vxlan_configure_exts(vport, a);\r\nif (err) {\r\novs_vport_free(vport);\r\ngoto error;\r\n}\r\n}\r\nvs = vxlan_sock_add(net, htons(dst_port), vxlan_rcv, vport, true,\r\nvxlan_port->exts);\r\nif (IS_ERR(vs)) {\r\novs_vport_free(vport);\r\nreturn (void *)vs;\r\n}\r\nvxlan_port->vs = vs;\r\nreturn vport;\r\nerror:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int vxlan_ext_gbp(struct sk_buff *skb)\r\n{\r\nconst struct ovs_tunnel_info *tun_info;\r\nconst struct ovs_vxlan_opts *opts;\r\ntun_info = OVS_CB(skb)->egress_tun_info;\r\nopts = tun_info->options;\r\nif (tun_info->tunnel.tun_flags & TUNNEL_VXLAN_OPT &&\r\ntun_info->options_len >= sizeof(*opts))\r\nreturn opts->gbp;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int vxlan_tnl_send(struct vport *vport, struct sk_buff *skb)\r\n{\r\nstruct net *net = ovs_dp_get_net(vport->dp);\r\nstruct vxlan_port *vxlan_port = vxlan_vport(vport);\r\nstruct sock *sk = vxlan_port->vs->sock->sk;\r\n__be16 dst_port = inet_sk(sk)->inet_sport;\r\nconst struct ovs_key_ipv4_tunnel *tun_key;\r\nstruct vxlan_metadata md = {0};\r\nstruct rtable *rt;\r\nstruct flowi4 fl;\r\n__be16 src_port;\r\n__be16 df;\r\nint err;\r\nu32 vxflags;\r\nif (unlikely(!OVS_CB(skb)->egress_tun_info)) {\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\ntun_key = &OVS_CB(skb)->egress_tun_info->tunnel;\r\nrt = ovs_tunnel_route_lookup(net, tun_key, skb->mark, &fl, IPPROTO_UDP);\r\nif (IS_ERR(rt)) {\r\nerr = PTR_ERR(rt);\r\ngoto error;\r\n}\r\ndf = tun_key->tun_flags & TUNNEL_DONT_FRAGMENT ?\r\nhtons(IP_DF) : 0;\r\nskb->ignore_df = 1;\r\nsrc_port = udp_flow_src_port(net, skb, 0, 0, true);\r\nmd.vni = htonl(be64_to_cpu(tun_key->tun_id) << 8);\r\nmd.gbp = vxlan_ext_gbp(skb);\r\nvxflags = vxlan_port->exts |\r\n(tun_key->tun_flags & TUNNEL_CSUM ? VXLAN_F_UDP_CSUM : 0);\r\nerr = vxlan_xmit_skb(rt, sk, skb, fl.saddr, tun_key->ipv4_dst,\r\ntun_key->ipv4_tos, tun_key->ipv4_ttl, df,\r\nsrc_port, dst_port,\r\n&md, false, vxflags);\r\nif (err < 0)\r\nip_rt_put(rt);\r\nreturn err;\r\nerror:\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\nstatic int vxlan_get_egress_tun_info(struct vport *vport, struct sk_buff *skb,\r\nstruct ovs_tunnel_info *egress_tun_info)\r\n{\r\nstruct net *net = ovs_dp_get_net(vport->dp);\r\nstruct vxlan_port *vxlan_port = vxlan_vport(vport);\r\n__be16 dst_port = inet_sk(vxlan_port->vs->sock->sk)->inet_sport;\r\n__be16 src_port;\r\nint port_min;\r\nint port_max;\r\ninet_get_local_port_range(net, &port_min, &port_max);\r\nsrc_port = udp_flow_src_port(net, skb, 0, 0, true);\r\nreturn ovs_tunnel_get_egress_info(egress_tun_info, net,\r\nOVS_CB(skb)->egress_tun_info,\r\nIPPROTO_UDP, skb->mark,\r\nsrc_port, dst_port);\r\n}\r\nstatic const char *vxlan_get_name(const struct vport *vport)\r\n{\r\nstruct vxlan_port *vxlan_port = vxlan_vport(vport);\r\nreturn vxlan_port->name;\r\n}\r\nstatic int __init ovs_vxlan_tnl_init(void)\r\n{\r\nreturn ovs_vport_ops_register(&ovs_vxlan_vport_ops);\r\n}\r\nstatic void __exit ovs_vxlan_tnl_exit(void)\r\n{\r\novs_vport_ops_unregister(&ovs_vxlan_vport_ops);\r\n}
