static int coresight_id_match(struct device *dev, void *data)\r\n{\r\nint trace_id, i_trace_id;\r\nstruct coresight_device *csdev, *i_csdev;\r\ncsdev = data;\r\ni_csdev = to_coresight_device(dev);\r\nif (i_csdev == csdev || !i_csdev->enable ||\r\ni_csdev->type != CORESIGHT_DEV_TYPE_SOURCE)\r\nreturn 0;\r\ntrace_id = source_ops(csdev)->trace_id(csdev);\r\ni_trace_id = source_ops(i_csdev)->trace_id(i_csdev);\r\nif (trace_id == i_trace_id)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int coresight_source_is_unique(struct coresight_device *csdev)\r\n{\r\nint trace_id = source_ops(csdev)->trace_id(csdev);\r\nif (trace_id < 0)\r\nreturn 0;\r\nreturn !bus_for_each_dev(&coresight_bustype, NULL,\r\ncsdev, coresight_id_match);\r\n}\r\nstatic int coresight_find_link_inport(struct coresight_device *csdev)\r\n{\r\nint i;\r\nstruct coresight_device *parent;\r\nstruct coresight_connection *conn;\r\nparent = container_of(csdev->path_link.next,\r\nstruct coresight_device, path_link);\r\nfor (i = 0; i < parent->nr_outport; i++) {\r\nconn = &parent->conns[i];\r\nif (conn->child_dev == csdev)\r\nreturn conn->child_port;\r\n}\r\ndev_err(&csdev->dev, "couldn't find inport, parent: %s, child: %s\n",\r\ndev_name(&parent->dev), dev_name(&csdev->dev));\r\nreturn 0;\r\n}\r\nstatic int coresight_find_link_outport(struct coresight_device *csdev)\r\n{\r\nint i;\r\nstruct coresight_device *child;\r\nstruct coresight_connection *conn;\r\nchild = container_of(csdev->path_link.prev,\r\nstruct coresight_device, path_link);\r\nfor (i = 0; i < csdev->nr_outport; i++) {\r\nconn = &csdev->conns[i];\r\nif (conn->child_dev == child)\r\nreturn conn->outport;\r\n}\r\ndev_err(&csdev->dev, "couldn't find outport, parent: %s, child: %s\n",\r\ndev_name(&csdev->dev), dev_name(&child->dev));\r\nreturn 0;\r\n}\r\nstatic int coresight_enable_sink(struct coresight_device *csdev)\r\n{\r\nint ret;\r\nif (!csdev->enable) {\r\nif (sink_ops(csdev)->enable) {\r\nret = sink_ops(csdev)->enable(csdev);\r\nif (ret)\r\nreturn ret;\r\n}\r\ncsdev->enable = true;\r\n}\r\natomic_inc(csdev->refcnt);\r\nreturn 0;\r\n}\r\nstatic void coresight_disable_sink(struct coresight_device *csdev)\r\n{\r\nif (atomic_dec_return(csdev->refcnt) == 0) {\r\nif (sink_ops(csdev)->disable) {\r\nsink_ops(csdev)->disable(csdev);\r\ncsdev->enable = false;\r\n}\r\n}\r\n}\r\nstatic int coresight_enable_link(struct coresight_device *csdev)\r\n{\r\nint ret;\r\nint link_subtype;\r\nint refport, inport, outport;\r\ninport = coresight_find_link_inport(csdev);\r\noutport = coresight_find_link_outport(csdev);\r\nlink_subtype = csdev->subtype.link_subtype;\r\nif (link_subtype == CORESIGHT_DEV_SUBTYPE_LINK_MERG)\r\nrefport = inport;\r\nelse if (link_subtype == CORESIGHT_DEV_SUBTYPE_LINK_SPLIT)\r\nrefport = outport;\r\nelse\r\nrefport = 0;\r\nif (atomic_inc_return(&csdev->refcnt[refport]) == 1) {\r\nif (link_ops(csdev)->enable) {\r\nret = link_ops(csdev)->enable(csdev, inport, outport);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\ncsdev->enable = true;\r\nreturn 0;\r\n}\r\nstatic void coresight_disable_link(struct coresight_device *csdev)\r\n{\r\nint i, nr_conns;\r\nint link_subtype;\r\nint refport, inport, outport;\r\ninport = coresight_find_link_inport(csdev);\r\noutport = coresight_find_link_outport(csdev);\r\nlink_subtype = csdev->subtype.link_subtype;\r\nif (link_subtype == CORESIGHT_DEV_SUBTYPE_LINK_MERG) {\r\nrefport = inport;\r\nnr_conns = csdev->nr_inport;\r\n} else if (link_subtype == CORESIGHT_DEV_SUBTYPE_LINK_SPLIT) {\r\nrefport = outport;\r\nnr_conns = csdev->nr_outport;\r\n} else {\r\nrefport = 0;\r\nnr_conns = 1;\r\n}\r\nif (atomic_dec_return(&csdev->refcnt[refport]) == 0) {\r\nif (link_ops(csdev)->disable)\r\nlink_ops(csdev)->disable(csdev, inport, outport);\r\n}\r\nfor (i = 0; i < nr_conns; i++)\r\nif (atomic_read(&csdev->refcnt[i]) != 0)\r\nreturn;\r\ncsdev->enable = false;\r\n}\r\nstatic int coresight_enable_source(struct coresight_device *csdev)\r\n{\r\nint ret;\r\nif (!coresight_source_is_unique(csdev)) {\r\ndev_warn(&csdev->dev, "traceID %d not unique\n",\r\nsource_ops(csdev)->trace_id(csdev));\r\nreturn -EINVAL;\r\n}\r\nif (!csdev->enable) {\r\nif (source_ops(csdev)->enable) {\r\nret = source_ops(csdev)->enable(csdev);\r\nif (ret)\r\nreturn ret;\r\n}\r\ncsdev->enable = true;\r\n}\r\natomic_inc(csdev->refcnt);\r\nreturn 0;\r\n}\r\nstatic void coresight_disable_source(struct coresight_device *csdev)\r\n{\r\nif (atomic_dec_return(csdev->refcnt) == 0) {\r\nif (source_ops(csdev)->disable) {\r\nsource_ops(csdev)->disable(csdev);\r\ncsdev->enable = false;\r\n}\r\n}\r\n}\r\nstatic int coresight_enable_path(struct list_head *path)\r\n{\r\nint ret = 0;\r\nstruct coresight_device *cd;\r\nlist_for_each_entry(cd, path, path_link) {\r\nif (cd == list_first_entry(path, struct coresight_device,\r\npath_link)) {\r\nret = coresight_enable_sink(cd);\r\n} else if (list_is_last(&cd->path_link, path)) {\r\n;\r\n} else {\r\nret = coresight_enable_link(cd);\r\n}\r\nif (ret)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nlist_for_each_entry_continue_reverse(cd, path, path_link) {\r\nif (cd == list_first_entry(path, struct coresight_device,\r\npath_link)) {\r\ncoresight_disable_sink(cd);\r\n} else if (list_is_last(&cd->path_link, path)) {\r\n;\r\n} else {\r\ncoresight_disable_link(cd);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int coresight_disable_path(struct list_head *path)\r\n{\r\nstruct coresight_device *cd;\r\nlist_for_each_entry_reverse(cd, path, path_link) {\r\nif (cd == list_first_entry(path, struct coresight_device,\r\npath_link)) {\r\ncoresight_disable_sink(cd);\r\n} else if (list_is_last(&cd->path_link, path)) {\r\n;\r\n} else {\r\ncoresight_disable_link(cd);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int coresight_build_paths(struct coresight_device *csdev,\r\nstruct list_head *path,\r\nbool enable)\r\n{\r\nint i, ret = -EINVAL;\r\nstruct coresight_connection *conn;\r\nlist_add(&csdev->path_link, path);\r\nif ((csdev->type == CORESIGHT_DEV_TYPE_SINK ||\r\ncsdev->type == CORESIGHT_DEV_TYPE_LINKSINK) &&\r\ncsdev->activated) {\r\nif (enable)\r\nret = coresight_enable_path(path);\r\nelse\r\nret = coresight_disable_path(path);\r\n} else {\r\nfor (i = 0; i < csdev->nr_outport; i++) {\r\nconn = &csdev->conns[i];\r\nif (coresight_build_paths(conn->child_dev,\r\npath, enable) == 0)\r\nret = 0;\r\n}\r\n}\r\nif (list_first_entry(path, struct coresight_device, path_link) != csdev)\r\ndev_err(&csdev->dev, "wrong device in %s\n", __func__);\r\nlist_del(&csdev->path_link);\r\nreturn ret;\r\n}\r\nint coresight_enable(struct coresight_device *csdev)\r\n{\r\nint ret = 0;\r\nLIST_HEAD(path);\r\nmutex_lock(&coresight_mutex);\r\nif (csdev->type != CORESIGHT_DEV_TYPE_SOURCE) {\r\nret = -EINVAL;\r\ndev_err(&csdev->dev, "wrong device type in %s\n", __func__);\r\ngoto out;\r\n}\r\nif (csdev->enable)\r\ngoto out;\r\nif (coresight_build_paths(csdev, &path, true)) {\r\ndev_err(&csdev->dev, "building path(s) failed\n");\r\ngoto out;\r\n}\r\nif (coresight_enable_source(csdev))\r\ndev_err(&csdev->dev, "source enable failed\n");\r\nout:\r\nmutex_unlock(&coresight_mutex);\r\nreturn ret;\r\n}\r\nvoid coresight_disable(struct coresight_device *csdev)\r\n{\r\nLIST_HEAD(path);\r\nmutex_lock(&coresight_mutex);\r\nif (csdev->type != CORESIGHT_DEV_TYPE_SOURCE) {\r\ndev_err(&csdev->dev, "wrong device type in %s\n", __func__);\r\ngoto out;\r\n}\r\nif (!csdev->enable)\r\ngoto out;\r\ncoresight_disable_source(csdev);\r\nif (coresight_build_paths(csdev, &path, false))\r\ndev_err(&csdev->dev, "releasing path(s) failed\n");\r\nout:\r\nmutex_unlock(&coresight_mutex);\r\n}\r\nstatic ssize_t enable_sink_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct coresight_device *csdev = to_coresight_device(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", (unsigned)csdev->activated);\r\n}\r\nstatic ssize_t enable_sink_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret;\r\nunsigned long val;\r\nstruct coresight_device *csdev = to_coresight_device(dev);\r\nret = kstrtoul(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val)\r\ncsdev->activated = true;\r\nelse\r\ncsdev->activated = false;\r\nreturn size;\r\n}\r\nstatic ssize_t enable_source_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct coresight_device *csdev = to_coresight_device(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", (unsigned)csdev->enable);\r\n}\r\nstatic ssize_t enable_source_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret = 0;\r\nunsigned long val;\r\nstruct coresight_device *csdev = to_coresight_device(dev);\r\nret = kstrtoul(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val) {\r\nret = coresight_enable(csdev);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\ncoresight_disable(csdev);\r\n}\r\nreturn size;\r\n}\r\nstatic void coresight_device_release(struct device *dev)\r\n{\r\nstruct coresight_device *csdev = to_coresight_device(dev);\r\nkfree(csdev);\r\n}\r\nstatic int coresight_orphan_match(struct device *dev, void *data)\r\n{\r\nint i;\r\nbool still_orphan = false;\r\nstruct coresight_device *csdev, *i_csdev;\r\nstruct coresight_connection *conn;\r\ncsdev = data;\r\ni_csdev = to_coresight_device(dev);\r\nif (csdev == i_csdev)\r\nreturn 0;\r\nif (!i_csdev->orphan)\r\nreturn 0;\r\nfor (i = 0; i < i_csdev->nr_outport; i++) {\r\nconn = &i_csdev->conns[i];\r\nif (conn->child_dev == NULL) {\r\nif (!strcmp(dev_name(&csdev->dev), conn->child_name)) {\r\nconn->child_dev = csdev;\r\n} else {\r\nstill_orphan = true;\r\n}\r\n}\r\n}\r\ni_csdev->orphan = still_orphan;\r\nreturn 0;\r\n}\r\nstatic void coresight_fixup_orphan_conns(struct coresight_device *csdev)\r\n{\r\nbus_for_each_dev(&coresight_bustype, NULL,\r\ncsdev, coresight_orphan_match);\r\n}\r\nstatic int coresight_name_match(struct device *dev, void *data)\r\n{\r\nchar *to_match;\r\nstruct coresight_device *i_csdev;\r\nto_match = data;\r\ni_csdev = to_coresight_device(dev);\r\nif (!strcmp(to_match, dev_name(&i_csdev->dev)))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void coresight_fixup_device_conns(struct coresight_device *csdev)\r\n{\r\nint i;\r\nstruct device *dev = NULL;\r\nstruct coresight_connection *conn;\r\nfor (i = 0; i < csdev->nr_outport; i++) {\r\nconn = &csdev->conns[i];\r\ndev = bus_find_device(&coresight_bustype, NULL,\r\n(void *)conn->child_name,\r\ncoresight_name_match);\r\nif (dev) {\r\nconn->child_dev = to_coresight_device(dev);\r\n} else {\r\ncsdev->orphan = true;\r\nconn->child_dev = NULL;\r\n}\r\n}\r\n}\r\nint coresight_timeout(void __iomem *addr, u32 offset, int position, int value)\r\n{\r\nint i;\r\nu32 val;\r\nfor (i = TIMEOUT_US; i > 0; i--) {\r\nval = __raw_readl(addr + offset);\r\nif (value) {\r\nif (val & BIT(position))\r\nreturn 0;\r\n} else {\r\nif (!(val & BIT(position)))\r\nreturn 0;\r\n}\r\nif (i - 1)\r\nudelay(1);\r\n}\r\nreturn -EAGAIN;\r\n}\r\nstatic int __init coresight_init(void)\r\n{\r\nreturn bus_register(&coresight_bustype);\r\n}\r\nstruct coresight_device *coresight_register(struct coresight_desc *desc)\r\n{\r\nint i;\r\nint ret;\r\nint link_subtype;\r\nint nr_refcnts = 1;\r\natomic_t *refcnts = NULL;\r\nstruct coresight_device *csdev;\r\nstruct coresight_connection *conns;\r\ncsdev = kzalloc(sizeof(*csdev), GFP_KERNEL);\r\nif (!csdev) {\r\nret = -ENOMEM;\r\ngoto err_kzalloc_csdev;\r\n}\r\nif (desc->type == CORESIGHT_DEV_TYPE_LINK ||\r\ndesc->type == CORESIGHT_DEV_TYPE_LINKSINK) {\r\nlink_subtype = desc->subtype.link_subtype;\r\nif (link_subtype == CORESIGHT_DEV_SUBTYPE_LINK_MERG)\r\nnr_refcnts = desc->pdata->nr_inport;\r\nelse if (link_subtype == CORESIGHT_DEV_SUBTYPE_LINK_SPLIT)\r\nnr_refcnts = desc->pdata->nr_outport;\r\n}\r\nrefcnts = kcalloc(nr_refcnts, sizeof(*refcnts), GFP_KERNEL);\r\nif (!refcnts) {\r\nret = -ENOMEM;\r\ngoto err_kzalloc_refcnts;\r\n}\r\ncsdev->refcnt = refcnts;\r\ncsdev->nr_inport = desc->pdata->nr_inport;\r\ncsdev->nr_outport = desc->pdata->nr_outport;\r\nconns = kcalloc(csdev->nr_outport, sizeof(*conns), GFP_KERNEL);\r\nif (!conns) {\r\nret = -ENOMEM;\r\ngoto err_kzalloc_conns;\r\n}\r\nfor (i = 0; i < csdev->nr_outport; i++) {\r\nconns[i].outport = desc->pdata->outports[i];\r\nconns[i].child_name = desc->pdata->child_names[i];\r\nconns[i].child_port = desc->pdata->child_ports[i];\r\n}\r\ncsdev->conns = conns;\r\ncsdev->type = desc->type;\r\ncsdev->subtype = desc->subtype;\r\ncsdev->ops = desc->ops;\r\ncsdev->orphan = false;\r\ncsdev->dev.type = &coresight_dev_type[desc->type];\r\ncsdev->dev.groups = desc->groups;\r\ncsdev->dev.parent = desc->dev;\r\ncsdev->dev.release = coresight_device_release;\r\ncsdev->dev.bus = &coresight_bustype;\r\ndev_set_name(&csdev->dev, "%s", desc->pdata->name);\r\nret = device_register(&csdev->dev);\r\nif (ret)\r\ngoto err_device_register;\r\nmutex_lock(&coresight_mutex);\r\ncoresight_fixup_device_conns(csdev);\r\ncoresight_fixup_orphan_conns(csdev);\r\nmutex_unlock(&coresight_mutex);\r\nreturn csdev;\r\nerr_device_register:\r\nkfree(conns);\r\nerr_kzalloc_conns:\r\nkfree(refcnts);\r\nerr_kzalloc_refcnts:\r\nkfree(csdev);\r\nerr_kzalloc_csdev:\r\nreturn ERR_PTR(ret);\r\n}\r\nvoid coresight_unregister(struct coresight_device *csdev)\r\n{\r\nmutex_lock(&coresight_mutex);\r\nkfree(csdev->conns);\r\ndevice_unregister(&csdev->dev);\r\nmutex_unlock(&coresight_mutex);\r\n}
