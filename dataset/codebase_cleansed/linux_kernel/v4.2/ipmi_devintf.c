static void file_receive_handler(struct ipmi_recv_msg *msg,\r\nvoid *handler_data)\r\n{\r\nstruct ipmi_file_private *priv = handler_data;\r\nint was_empty;\r\nunsigned long flags;\r\nspin_lock_irqsave(&(priv->recv_msg_lock), flags);\r\nwas_empty = list_empty(&(priv->recv_msgs));\r\nlist_add_tail(&(msg->link), &(priv->recv_msgs));\r\nif (was_empty) {\r\nwake_up_interruptible(&priv->wait);\r\nkill_fasync(&priv->fasync_queue, SIGIO, POLL_IN);\r\n}\r\nspin_unlock_irqrestore(&(priv->recv_msg_lock), flags);\r\n}\r\nstatic unsigned int ipmi_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct ipmi_file_private *priv = file->private_data;\r\nunsigned int mask = 0;\r\nunsigned long flags;\r\npoll_wait(file, &priv->wait, wait);\r\nspin_lock_irqsave(&priv->recv_msg_lock, flags);\r\nif (!list_empty(&(priv->recv_msgs)))\r\nmask |= (POLLIN | POLLRDNORM);\r\nspin_unlock_irqrestore(&priv->recv_msg_lock, flags);\r\nreturn mask;\r\n}\r\nstatic int ipmi_fasync(int fd, struct file *file, int on)\r\n{\r\nstruct ipmi_file_private *priv = file->private_data;\r\nint result;\r\nmutex_lock(&ipmi_mutex);\r\nresult = fasync_helper(fd, file, on, &priv->fasync_queue);\r\nmutex_unlock(&ipmi_mutex);\r\nreturn (result);\r\n}\r\nstatic int ipmi_open(struct inode *inode, struct file *file)\r\n{\r\nint if_num = iminor(inode);\r\nint rv;\r\nstruct ipmi_file_private *priv;\r\npriv = kmalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nmutex_lock(&ipmi_mutex);\r\npriv->file = file;\r\nrv = ipmi_create_user(if_num,\r\n&ipmi_hndlrs,\r\npriv,\r\n&(priv->user));\r\nif (rv) {\r\nkfree(priv);\r\ngoto out;\r\n}\r\nfile->private_data = priv;\r\nspin_lock_init(&(priv->recv_msg_lock));\r\nINIT_LIST_HEAD(&(priv->recv_msgs));\r\ninit_waitqueue_head(&priv->wait);\r\npriv->fasync_queue = NULL;\r\nmutex_init(&priv->recv_mutex);\r\npriv->default_retries = -1;\r\npriv->default_retry_time_ms = 0;\r\nout:\r\nmutex_unlock(&ipmi_mutex);\r\nreturn rv;\r\n}\r\nstatic int ipmi_release(struct inode *inode, struct file *file)\r\n{\r\nstruct ipmi_file_private *priv = file->private_data;\r\nint rv;\r\nstruct ipmi_recv_msg *msg, *next;\r\nrv = ipmi_destroy_user(priv->user);\r\nif (rv)\r\nreturn rv;\r\nlist_for_each_entry_safe(msg, next, &priv->recv_msgs, link)\r\nipmi_free_recv_msg(msg);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic int handle_send_req(ipmi_user_t user,\r\nstruct ipmi_req *req,\r\nint retries,\r\nunsigned int retry_time_ms)\r\n{\r\nint rv;\r\nstruct ipmi_addr addr;\r\nstruct kernel_ipmi_msg msg;\r\nif (req->addr_len > sizeof(struct ipmi_addr))\r\nreturn -EINVAL;\r\nif (copy_from_user(&addr, req->addr, req->addr_len))\r\nreturn -EFAULT;\r\nmsg.netfn = req->msg.netfn;\r\nmsg.cmd = req->msg.cmd;\r\nmsg.data_len = req->msg.data_len;\r\nmsg.data = kmalloc(IPMI_MAX_MSG_LENGTH, GFP_KERNEL);\r\nif (!msg.data)\r\nreturn -ENOMEM;\r\nrv = ipmi_validate_addr(&addr, req->addr_len);\r\nif (rv)\r\ngoto out;\r\nif (req->msg.data != NULL) {\r\nif (req->msg.data_len > IPMI_MAX_MSG_LENGTH) {\r\nrv = -EMSGSIZE;\r\ngoto out;\r\n}\r\nif (copy_from_user(msg.data,\r\nreq->msg.data,\r\nreq->msg.data_len))\r\n{\r\nrv = -EFAULT;\r\ngoto out;\r\n}\r\n} else {\r\nmsg.data_len = 0;\r\n}\r\nrv = ipmi_request_settime(user,\r\n&addr,\r\nreq->msgid,\r\n&msg,\r\nNULL,\r\n0,\r\nretries,\r\nretry_time_ms);\r\nout:\r\nkfree(msg.data);\r\nreturn rv;\r\n}\r\nstatic int ipmi_ioctl(struct file *file,\r\nunsigned int cmd,\r\nunsigned long data)\r\n{\r\nint rv = -EINVAL;\r\nstruct ipmi_file_private *priv = file->private_data;\r\nvoid __user *arg = (void __user *)data;\r\nswitch (cmd)\r\n{\r\ncase IPMICTL_SEND_COMMAND:\r\n{\r\nstruct ipmi_req req;\r\nif (copy_from_user(&req, arg, sizeof(req))) {\r\nrv = -EFAULT;\r\nbreak;\r\n}\r\nrv = handle_send_req(priv->user,\r\n&req,\r\npriv->default_retries,\r\npriv->default_retry_time_ms);\r\nbreak;\r\n}\r\ncase IPMICTL_SEND_COMMAND_SETTIME:\r\n{\r\nstruct ipmi_req_settime req;\r\nif (copy_from_user(&req, arg, sizeof(req))) {\r\nrv = -EFAULT;\r\nbreak;\r\n}\r\nrv = handle_send_req(priv->user,\r\n&req.req,\r\nreq.retries,\r\nreq.retry_time_ms);\r\nbreak;\r\n}\r\ncase IPMICTL_RECEIVE_MSG:\r\ncase IPMICTL_RECEIVE_MSG_TRUNC:\r\n{\r\nstruct ipmi_recv rsp;\r\nint addr_len;\r\nstruct list_head *entry;\r\nstruct ipmi_recv_msg *msg;\r\nunsigned long flags;\r\nrv = 0;\r\nif (copy_from_user(&rsp, arg, sizeof(rsp))) {\r\nrv = -EFAULT;\r\nbreak;\r\n}\r\nmutex_lock(&priv->recv_mutex);\r\nspin_lock_irqsave(&(priv->recv_msg_lock), flags);\r\nif (list_empty(&(priv->recv_msgs))) {\r\nspin_unlock_irqrestore(&(priv->recv_msg_lock), flags);\r\nrv = -EAGAIN;\r\ngoto recv_err;\r\n}\r\nentry = priv->recv_msgs.next;\r\nmsg = list_entry(entry, struct ipmi_recv_msg, link);\r\nlist_del(entry);\r\nspin_unlock_irqrestore(&(priv->recv_msg_lock), flags);\r\naddr_len = ipmi_addr_length(msg->addr.addr_type);\r\nif (rsp.addr_len < addr_len)\r\n{\r\nrv = -EINVAL;\r\ngoto recv_putback_on_err;\r\n}\r\nif (copy_to_user(rsp.addr, &(msg->addr), addr_len)) {\r\nrv = -EFAULT;\r\ngoto recv_putback_on_err;\r\n}\r\nrsp.addr_len = addr_len;\r\nrsp.recv_type = msg->recv_type;\r\nrsp.msgid = msg->msgid;\r\nrsp.msg.netfn = msg->msg.netfn;\r\nrsp.msg.cmd = msg->msg.cmd;\r\nif (msg->msg.data_len > 0) {\r\nif (rsp.msg.data_len < msg->msg.data_len) {\r\nrv = -EMSGSIZE;\r\nif (cmd == IPMICTL_RECEIVE_MSG_TRUNC) {\r\nmsg->msg.data_len = rsp.msg.data_len;\r\n} else {\r\ngoto recv_putback_on_err;\r\n}\r\n}\r\nif (copy_to_user(rsp.msg.data,\r\nmsg->msg.data,\r\nmsg->msg.data_len))\r\n{\r\nrv = -EFAULT;\r\ngoto recv_putback_on_err;\r\n}\r\nrsp.msg.data_len = msg->msg.data_len;\r\n} else {\r\nrsp.msg.data_len = 0;\r\n}\r\nif (copy_to_user(arg, &rsp, sizeof(rsp))) {\r\nrv = -EFAULT;\r\ngoto recv_putback_on_err;\r\n}\r\nmutex_unlock(&priv->recv_mutex);\r\nipmi_free_recv_msg(msg);\r\nbreak;\r\nrecv_putback_on_err:\r\nspin_lock_irqsave(&(priv->recv_msg_lock), flags);\r\nlist_add(entry, &(priv->recv_msgs));\r\nspin_unlock_irqrestore(&(priv->recv_msg_lock), flags);\r\nmutex_unlock(&priv->recv_mutex);\r\nbreak;\r\nrecv_err:\r\nmutex_unlock(&priv->recv_mutex);\r\nbreak;\r\n}\r\ncase IPMICTL_REGISTER_FOR_CMD:\r\n{\r\nstruct ipmi_cmdspec val;\r\nif (copy_from_user(&val, arg, sizeof(val))) {\r\nrv = -EFAULT;\r\nbreak;\r\n}\r\nrv = ipmi_register_for_cmd(priv->user, val.netfn, val.cmd,\r\nIPMI_CHAN_ALL);\r\nbreak;\r\n}\r\ncase IPMICTL_UNREGISTER_FOR_CMD:\r\n{\r\nstruct ipmi_cmdspec val;\r\nif (copy_from_user(&val, arg, sizeof(val))) {\r\nrv = -EFAULT;\r\nbreak;\r\n}\r\nrv = ipmi_unregister_for_cmd(priv->user, val.netfn, val.cmd,\r\nIPMI_CHAN_ALL);\r\nbreak;\r\n}\r\ncase IPMICTL_REGISTER_FOR_CMD_CHANS:\r\n{\r\nstruct ipmi_cmdspec_chans val;\r\nif (copy_from_user(&val, arg, sizeof(val))) {\r\nrv = -EFAULT;\r\nbreak;\r\n}\r\nrv = ipmi_register_for_cmd(priv->user, val.netfn, val.cmd,\r\nval.chans);\r\nbreak;\r\n}\r\ncase IPMICTL_UNREGISTER_FOR_CMD_CHANS:\r\n{\r\nstruct ipmi_cmdspec_chans val;\r\nif (copy_from_user(&val, arg, sizeof(val))) {\r\nrv = -EFAULT;\r\nbreak;\r\n}\r\nrv = ipmi_unregister_for_cmd(priv->user, val.netfn, val.cmd,\r\nval.chans);\r\nbreak;\r\n}\r\ncase IPMICTL_SET_GETS_EVENTS_CMD:\r\n{\r\nint val;\r\nif (copy_from_user(&val, arg, sizeof(val))) {\r\nrv = -EFAULT;\r\nbreak;\r\n}\r\nrv = ipmi_set_gets_events(priv->user, val);\r\nbreak;\r\n}\r\ncase IPMICTL_SET_MY_ADDRESS_CMD:\r\n{\r\nunsigned int val;\r\nif (copy_from_user(&val, arg, sizeof(val))) {\r\nrv = -EFAULT;\r\nbreak;\r\n}\r\nrv = ipmi_set_my_address(priv->user, 0, val);\r\nbreak;\r\n}\r\ncase IPMICTL_GET_MY_ADDRESS_CMD:\r\n{\r\nunsigned int val;\r\nunsigned char rval;\r\nrv = ipmi_get_my_address(priv->user, 0, &rval);\r\nif (rv)\r\nbreak;\r\nval = rval;\r\nif (copy_to_user(arg, &val, sizeof(val))) {\r\nrv = -EFAULT;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase IPMICTL_SET_MY_LUN_CMD:\r\n{\r\nunsigned int val;\r\nif (copy_from_user(&val, arg, sizeof(val))) {\r\nrv = -EFAULT;\r\nbreak;\r\n}\r\nrv = ipmi_set_my_LUN(priv->user, 0, val);\r\nbreak;\r\n}\r\ncase IPMICTL_GET_MY_LUN_CMD:\r\n{\r\nunsigned int val;\r\nunsigned char rval;\r\nrv = ipmi_get_my_LUN(priv->user, 0, &rval);\r\nif (rv)\r\nbreak;\r\nval = rval;\r\nif (copy_to_user(arg, &val, sizeof(val))) {\r\nrv = -EFAULT;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase IPMICTL_SET_MY_CHANNEL_ADDRESS_CMD:\r\n{\r\nstruct ipmi_channel_lun_address_set val;\r\nif (copy_from_user(&val, arg, sizeof(val))) {\r\nrv = -EFAULT;\r\nbreak;\r\n}\r\nreturn ipmi_set_my_address(priv->user, val.channel, val.value);\r\nbreak;\r\n}\r\ncase IPMICTL_GET_MY_CHANNEL_ADDRESS_CMD:\r\n{\r\nstruct ipmi_channel_lun_address_set val;\r\nif (copy_from_user(&val, arg, sizeof(val))) {\r\nrv = -EFAULT;\r\nbreak;\r\n}\r\nrv = ipmi_get_my_address(priv->user, val.channel, &val.value);\r\nif (rv)\r\nbreak;\r\nif (copy_to_user(arg, &val, sizeof(val))) {\r\nrv = -EFAULT;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase IPMICTL_SET_MY_CHANNEL_LUN_CMD:\r\n{\r\nstruct ipmi_channel_lun_address_set val;\r\nif (copy_from_user(&val, arg, sizeof(val))) {\r\nrv = -EFAULT;\r\nbreak;\r\n}\r\nrv = ipmi_set_my_LUN(priv->user, val.channel, val.value);\r\nbreak;\r\n}\r\ncase IPMICTL_GET_MY_CHANNEL_LUN_CMD:\r\n{\r\nstruct ipmi_channel_lun_address_set val;\r\nif (copy_from_user(&val, arg, sizeof(val))) {\r\nrv = -EFAULT;\r\nbreak;\r\n}\r\nrv = ipmi_get_my_LUN(priv->user, val.channel, &val.value);\r\nif (rv)\r\nbreak;\r\nif (copy_to_user(arg, &val, sizeof(val))) {\r\nrv = -EFAULT;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase IPMICTL_SET_TIMING_PARMS_CMD:\r\n{\r\nstruct ipmi_timing_parms parms;\r\nif (copy_from_user(&parms, arg, sizeof(parms))) {\r\nrv = -EFAULT;\r\nbreak;\r\n}\r\npriv->default_retries = parms.retries;\r\npriv->default_retry_time_ms = parms.retry_time_ms;\r\nrv = 0;\r\nbreak;\r\n}\r\ncase IPMICTL_GET_TIMING_PARMS_CMD:\r\n{\r\nstruct ipmi_timing_parms parms;\r\nparms.retries = priv->default_retries;\r\nparms.retry_time_ms = priv->default_retry_time_ms;\r\nif (copy_to_user(arg, &parms, sizeof(parms))) {\r\nrv = -EFAULT;\r\nbreak;\r\n}\r\nrv = 0;\r\nbreak;\r\n}\r\ncase IPMICTL_GET_MAINTENANCE_MODE_CMD:\r\n{\r\nint mode;\r\nmode = ipmi_get_maintenance_mode(priv->user);\r\nif (copy_to_user(arg, &mode, sizeof(mode))) {\r\nrv = -EFAULT;\r\nbreak;\r\n}\r\nrv = 0;\r\nbreak;\r\n}\r\ncase IPMICTL_SET_MAINTENANCE_MODE_CMD:\r\n{\r\nint mode;\r\nif (copy_from_user(&mode, arg, sizeof(mode))) {\r\nrv = -EFAULT;\r\nbreak;\r\n}\r\nrv = ipmi_set_maintenance_mode(priv->user, mode);\r\nbreak;\r\n}\r\n}\r\nreturn rv;\r\n}\r\nstatic long ipmi_unlocked_ioctl(struct file *file,\r\nunsigned int cmd,\r\nunsigned long data)\r\n{\r\nint ret;\r\nmutex_lock(&ipmi_mutex);\r\nret = ipmi_ioctl(file, cmd, data);\r\nmutex_unlock(&ipmi_mutex);\r\nreturn ret;\r\n}\r\nstatic long get_compat_ipmi_msg(struct ipmi_msg *p64,\r\nstruct compat_ipmi_msg __user *p32)\r\n{\r\ncompat_uptr_t tmp;\r\nif (!access_ok(VERIFY_READ, p32, sizeof(*p32)) ||\r\n__get_user(p64->netfn, &p32->netfn) ||\r\n__get_user(p64->cmd, &p32->cmd) ||\r\n__get_user(p64->data_len, &p32->data_len) ||\r\n__get_user(tmp, &p32->data))\r\nreturn -EFAULT;\r\np64->data = compat_ptr(tmp);\r\nreturn 0;\r\n}\r\nstatic long put_compat_ipmi_msg(struct ipmi_msg *p64,\r\nstruct compat_ipmi_msg __user *p32)\r\n{\r\nif (!access_ok(VERIFY_WRITE, p32, sizeof(*p32)) ||\r\n__put_user(p64->netfn, &p32->netfn) ||\r\n__put_user(p64->cmd, &p32->cmd) ||\r\n__put_user(p64->data_len, &p32->data_len))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long get_compat_ipmi_req(struct ipmi_req *p64,\r\nstruct compat_ipmi_req __user *p32)\r\n{\r\ncompat_uptr_t tmp;\r\nif (!access_ok(VERIFY_READ, p32, sizeof(*p32)) ||\r\n__get_user(tmp, &p32->addr) ||\r\n__get_user(p64->addr_len, &p32->addr_len) ||\r\n__get_user(p64->msgid, &p32->msgid) ||\r\nget_compat_ipmi_msg(&p64->msg, &p32->msg))\r\nreturn -EFAULT;\r\np64->addr = compat_ptr(tmp);\r\nreturn 0;\r\n}\r\nstatic long get_compat_ipmi_req_settime(struct ipmi_req_settime *p64,\r\nstruct compat_ipmi_req_settime __user *p32)\r\n{\r\nif (!access_ok(VERIFY_READ, p32, sizeof(*p32)) ||\r\nget_compat_ipmi_req(&p64->req, &p32->req) ||\r\n__get_user(p64->retries, &p32->retries) ||\r\n__get_user(p64->retry_time_ms, &p32->retry_time_ms))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long get_compat_ipmi_recv(struct ipmi_recv *p64,\r\nstruct compat_ipmi_recv __user *p32)\r\n{\r\ncompat_uptr_t tmp;\r\nif (!access_ok(VERIFY_READ, p32, sizeof(*p32)) ||\r\n__get_user(p64->recv_type, &p32->recv_type) ||\r\n__get_user(tmp, &p32->addr) ||\r\n__get_user(p64->addr_len, &p32->addr_len) ||\r\n__get_user(p64->msgid, &p32->msgid) ||\r\nget_compat_ipmi_msg(&p64->msg, &p32->msg))\r\nreturn -EFAULT;\r\np64->addr = compat_ptr(tmp);\r\nreturn 0;\r\n}\r\nstatic long put_compat_ipmi_recv(struct ipmi_recv *p64,\r\nstruct compat_ipmi_recv __user *p32)\r\n{\r\nif (!access_ok(VERIFY_WRITE, p32, sizeof(*p32)) ||\r\n__put_user(p64->recv_type, &p32->recv_type) ||\r\n__put_user(p64->addr_len, &p32->addr_len) ||\r\n__put_user(p64->msgid, &p32->msgid) ||\r\nput_compat_ipmi_msg(&p64->msg, &p32->msg))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long compat_ipmi_ioctl(struct file *filep, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint rc;\r\nstruct ipmi_file_private *priv = filep->private_data;\r\nswitch(cmd) {\r\ncase COMPAT_IPMICTL_SEND_COMMAND:\r\n{\r\nstruct ipmi_req rp;\r\nif (get_compat_ipmi_req(&rp, compat_ptr(arg)))\r\nreturn -EFAULT;\r\nreturn handle_send_req(priv->user, &rp,\r\npriv->default_retries,\r\npriv->default_retry_time_ms);\r\n}\r\ncase COMPAT_IPMICTL_SEND_COMMAND_SETTIME:\r\n{\r\nstruct ipmi_req_settime sp;\r\nif (get_compat_ipmi_req_settime(&sp, compat_ptr(arg)))\r\nreturn -EFAULT;\r\nreturn handle_send_req(priv->user, &sp.req,\r\nsp.retries, sp.retry_time_ms);\r\n}\r\ncase COMPAT_IPMICTL_RECEIVE_MSG:\r\ncase COMPAT_IPMICTL_RECEIVE_MSG_TRUNC:\r\n{\r\nstruct ipmi_recv __user *precv64;\r\nstruct ipmi_recv recv64;\r\nmemset(&recv64, 0, sizeof(recv64));\r\nif (get_compat_ipmi_recv(&recv64, compat_ptr(arg)))\r\nreturn -EFAULT;\r\nprecv64 = compat_alloc_user_space(sizeof(recv64));\r\nif (copy_to_user(precv64, &recv64, sizeof(recv64)))\r\nreturn -EFAULT;\r\nrc = ipmi_ioctl(filep,\r\n((cmd == COMPAT_IPMICTL_RECEIVE_MSG)\r\n? IPMICTL_RECEIVE_MSG\r\n: IPMICTL_RECEIVE_MSG_TRUNC),\r\n(unsigned long) precv64);\r\nif (rc != 0)\r\nreturn rc;\r\nif (copy_from_user(&recv64, precv64, sizeof(recv64)))\r\nreturn -EFAULT;\r\nif (put_compat_ipmi_recv(&recv64, compat_ptr(arg)))\r\nreturn -EFAULT;\r\nreturn rc;\r\n}\r\ndefault:\r\nreturn ipmi_ioctl(filep, cmd, arg);\r\n}\r\n}\r\nstatic long unlocked_compat_ipmi_ioctl(struct file *filep, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint ret;\r\nmutex_lock(&ipmi_mutex);\r\nret = compat_ipmi_ioctl(filep, cmd, arg);\r\nmutex_unlock(&ipmi_mutex);\r\nreturn ret;\r\n}\r\nstatic void ipmi_new_smi(int if_num, struct device *device)\r\n{\r\ndev_t dev = MKDEV(ipmi_major, if_num);\r\nstruct ipmi_reg_list *entry;\r\nentry = kmalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry) {\r\nprintk(KERN_ERR "ipmi_devintf: Unable to create the"\r\n" ipmi class device link\n");\r\nreturn;\r\n}\r\nentry->dev = dev;\r\nmutex_lock(&reg_list_mutex);\r\ndevice_create(ipmi_class, device, dev, NULL, "ipmi%d", if_num);\r\nlist_add(&entry->link, &reg_list);\r\nmutex_unlock(&reg_list_mutex);\r\n}\r\nstatic void ipmi_smi_gone(int if_num)\r\n{\r\ndev_t dev = MKDEV(ipmi_major, if_num);\r\nstruct ipmi_reg_list *entry;\r\nmutex_lock(&reg_list_mutex);\r\nlist_for_each_entry(entry, &reg_list, link) {\r\nif (entry->dev == dev) {\r\nlist_del(&entry->link);\r\nkfree(entry);\r\nbreak;\r\n}\r\n}\r\ndevice_destroy(ipmi_class, dev);\r\nmutex_unlock(&reg_list_mutex);\r\n}\r\nstatic int __init init_ipmi_devintf(void)\r\n{\r\nint rv;\r\nif (ipmi_major < 0)\r\nreturn -EINVAL;\r\nprintk(KERN_INFO "ipmi device interface\n");\r\nipmi_class = class_create(THIS_MODULE, "ipmi");\r\nif (IS_ERR(ipmi_class)) {\r\nprintk(KERN_ERR "ipmi: can't register device class\n");\r\nreturn PTR_ERR(ipmi_class);\r\n}\r\nrv = register_chrdev(ipmi_major, DEVICE_NAME, &ipmi_fops);\r\nif (rv < 0) {\r\nclass_destroy(ipmi_class);\r\nprintk(KERN_ERR "ipmi: can't get major %d\n", ipmi_major);\r\nreturn rv;\r\n}\r\nif (ipmi_major == 0) {\r\nipmi_major = rv;\r\n}\r\nrv = ipmi_smi_watcher_register(&smi_watcher);\r\nif (rv) {\r\nunregister_chrdev(ipmi_major, DEVICE_NAME);\r\nclass_destroy(ipmi_class);\r\nprintk(KERN_WARNING "ipmi: can't register smi watcher\n");\r\nreturn rv;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit cleanup_ipmi(void)\r\n{\r\nstruct ipmi_reg_list *entry, *entry2;\r\nmutex_lock(&reg_list_mutex);\r\nlist_for_each_entry_safe(entry, entry2, &reg_list, link) {\r\nlist_del(&entry->link);\r\ndevice_destroy(ipmi_class, entry->dev);\r\nkfree(entry);\r\n}\r\nmutex_unlock(&reg_list_mutex);\r\nclass_destroy(ipmi_class);\r\nipmi_smi_watcher_unregister(&smi_watcher);\r\nunregister_chrdev(ipmi_major, DEVICE_NAME);\r\n}
