static u32 rk_tsadcv2_temp_to_code(long temp)\r\n{\r\nint high, low, mid;\r\nlow = 0;\r\nhigh = ARRAY_SIZE(v2_code_table) - 1;\r\nmid = (high + low) / 2;\r\nif (temp < v2_code_table[low].temp || temp > v2_code_table[high].temp)\r\nreturn 0;\r\nwhile (low <= high) {\r\nif (temp == v2_code_table[mid].temp)\r\nreturn v2_code_table[mid].code;\r\nelse if (temp < v2_code_table[mid].temp)\r\nhigh = mid - 1;\r\nelse\r\nlow = mid + 1;\r\nmid = (low + high) / 2;\r\n}\r\nreturn 0;\r\n}\r\nstatic long rk_tsadcv2_code_to_temp(u32 code)\r\n{\r\nunsigned int low = 0;\r\nunsigned int high = ARRAY_SIZE(v2_code_table) - 1;\r\nunsigned int mid = (low + high) / 2;\r\nunsigned int num;\r\nunsigned long denom;\r\nif (code > TSADCV2_DATA_MASK)\r\nreturn -EAGAIN;\r\nwhile (low <= high && mid) {\r\nif (code >= v2_code_table[mid].code &&\r\ncode < v2_code_table[mid - 1].code)\r\nbreak;\r\nelse if (code < v2_code_table[mid].code)\r\nlow = mid + 1;\r\nelse\r\nhigh = mid - 1;\r\nmid = (low + high) / 2;\r\n}\r\nnum = v2_code_table[mid].temp - v2_code_table[mid - 1].temp;\r\nnum *= v2_code_table[mid - 1].code - code;\r\ndenom = v2_code_table[mid - 1].code - v2_code_table[mid].code;\r\nreturn v2_code_table[mid - 1].temp + (num / denom);\r\n}\r\nstatic void rk_tsadcv2_initialize(void __iomem *regs,\r\nenum tshut_polarity tshut_polarity)\r\n{\r\nif (tshut_polarity == TSHUT_HIGH_ACTIVE)\r\nwritel_relaxed(0 | (TSADCV2_AUTO_TSHUT_POLARITY_HIGH),\r\nregs + TSADCV2_AUTO_CON);\r\nelse\r\nwritel_relaxed(0 | (TSADCV2_AUTO_TSHUT_POLARITY_LOW),\r\nregs + TSADCV2_AUTO_CON);\r\nwritel_relaxed(TSADCV2_AUTO_PERIOD_TIME, regs + TSADCV2_AUTO_PERIOD);\r\nwritel_relaxed(TSADCV2_HIGHT_INT_DEBOUNCE_COUNT,\r\nregs + TSADCV2_HIGHT_INT_DEBOUNCE);\r\nwritel_relaxed(TSADCV2_AUTO_PERIOD_HT_TIME,\r\nregs + TSADCV2_AUTO_PERIOD_HT);\r\nwritel_relaxed(TSADCV2_HIGHT_TSHUT_DEBOUNCE_COUNT,\r\nregs + TSADCV2_HIGHT_TSHUT_DEBOUNCE);\r\n}\r\nstatic void rk_tsadcv2_irq_ack(void __iomem *regs)\r\n{\r\nu32 val;\r\nval = readl_relaxed(regs + TSADCV2_INT_PD);\r\nwritel_relaxed(val & TSADCV2_INT_PD_CLEAR, regs + TSADCV2_INT_PD);\r\n}\r\nstatic void rk_tsadcv2_control(void __iomem *regs, bool enable)\r\n{\r\nu32 val;\r\nval = readl_relaxed(regs + TSADCV2_AUTO_CON);\r\nif (enable)\r\nval |= TSADCV2_AUTO_EN;\r\nelse\r\nval &= ~TSADCV2_AUTO_EN;\r\nwritel_relaxed(val, regs + TSADCV2_AUTO_CON);\r\n}\r\nstatic int rk_tsadcv2_get_temp(int chn, void __iomem *regs, long *temp)\r\n{\r\nu32 val;\r\nval = readl_relaxed(regs + TSADCV2_DATA(chn));\r\nif (val == 0)\r\nreturn -EAGAIN;\r\n*temp = rk_tsadcv2_code_to_temp(val);\r\nreturn 0;\r\n}\r\nstatic void rk_tsadcv2_tshut_temp(int chn, void __iomem *regs, long temp)\r\n{\r\nu32 tshut_value, val;\r\ntshut_value = rk_tsadcv2_temp_to_code(temp);\r\nwritel_relaxed(tshut_value, regs + TSADCV2_COMP_SHUT(chn));\r\nval = readl_relaxed(regs + TSADCV2_AUTO_CON);\r\nwritel_relaxed(val | TSADCV2_AUTO_SRC_EN(chn), regs + TSADCV2_AUTO_CON);\r\n}\r\nstatic void rk_tsadcv2_tshut_mode(int chn, void __iomem *regs,\r\nenum tshut_mode mode)\r\n{\r\nu32 val;\r\nval = readl_relaxed(regs + TSADCV2_INT_EN);\r\nif (mode == TSHUT_MODE_GPIO) {\r\nval &= ~TSADCV2_SHUT_2CRU_SRC_EN(chn);\r\nval |= TSADCV2_SHUT_2GPIO_SRC_EN(chn);\r\n} else {\r\nval &= ~TSADCV2_SHUT_2GPIO_SRC_EN(chn);\r\nval |= TSADCV2_SHUT_2CRU_SRC_EN(chn);\r\n}\r\nwritel_relaxed(val, regs + TSADCV2_INT_EN);\r\n}\r\nstatic void\r\nrockchip_thermal_toggle_sensor(struct rockchip_thermal_sensor *sensor, bool on)\r\n{\r\nstruct thermal_zone_device *tzd = sensor->tzd;\r\ntzd->ops->set_mode(tzd,\r\non ? THERMAL_DEVICE_ENABLED : THERMAL_DEVICE_DISABLED);\r\n}\r\nstatic irqreturn_t rockchip_thermal_alarm_irq_thread(int irq, void *dev)\r\n{\r\nstruct rockchip_thermal_data *thermal = dev;\r\nint i;\r\ndev_dbg(&thermal->pdev->dev, "thermal alarm\n");\r\nthermal->chip->irq_ack(thermal->regs);\r\nfor (i = 0; i < ARRAY_SIZE(thermal->sensors); i++)\r\nthermal_zone_device_update(thermal->sensors[i].tzd);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int rockchip_thermal_get_temp(void *_sensor, long *out_temp)\r\n{\r\nstruct rockchip_thermal_sensor *sensor = _sensor;\r\nstruct rockchip_thermal_data *thermal = sensor->thermal;\r\nconst struct rockchip_tsadc_chip *tsadc = sensor->thermal->chip;\r\nint retval;\r\nretval = tsadc->get_temp(sensor->id, thermal->regs, out_temp);\r\ndev_dbg(&thermal->pdev->dev, "sensor %d - temp: %ld, retval: %d\n",\r\nsensor->id, *out_temp, retval);\r\nreturn retval;\r\n}\r\nstatic int rockchip_configure_from_dt(struct device *dev,\r\nstruct device_node *np,\r\nstruct rockchip_thermal_data *thermal)\r\n{\r\nu32 shut_temp, tshut_mode, tshut_polarity;\r\nif (of_property_read_u32(np, "rockchip,hw-tshut-temp", &shut_temp)) {\r\ndev_warn(dev,\r\n"Missing tshut temp property, using default %ld\n",\r\nthermal->chip->tshut_temp);\r\nthermal->tshut_temp = thermal->chip->tshut_temp;\r\n} else {\r\nthermal->tshut_temp = shut_temp;\r\n}\r\nif (thermal->tshut_temp > INT_MAX) {\r\ndev_err(dev, "Invalid tshut temperature specified: %ld\n",\r\nthermal->tshut_temp);\r\nreturn -ERANGE;\r\n}\r\nif (of_property_read_u32(np, "rockchip,hw-tshut-mode", &tshut_mode)) {\r\ndev_warn(dev,\r\n"Missing tshut mode property, using default (%s)\n",\r\nthermal->chip->tshut_mode == TSHUT_MODE_GPIO ?\r\n"gpio" : "cru");\r\nthermal->tshut_mode = thermal->chip->tshut_mode;\r\n} else {\r\nthermal->tshut_mode = tshut_mode;\r\n}\r\nif (thermal->tshut_mode > 1) {\r\ndev_err(dev, "Invalid tshut mode specified: %d\n",\r\nthermal->tshut_mode);\r\nreturn -EINVAL;\r\n}\r\nif (of_property_read_u32(np, "rockchip,hw-tshut-polarity",\r\n&tshut_polarity)) {\r\ndev_warn(dev,\r\n"Missing tshut-polarity property, using default (%s)\n",\r\nthermal->chip->tshut_polarity == TSHUT_LOW_ACTIVE ?\r\n"low" : "high");\r\nthermal->tshut_polarity = thermal->chip->tshut_polarity;\r\n} else {\r\nthermal->tshut_polarity = tshut_polarity;\r\n}\r\nif (thermal->tshut_polarity > 1) {\r\ndev_err(dev, "Invalid tshut-polarity specified: %d\n",\r\nthermal->tshut_polarity);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nrockchip_thermal_register_sensor(struct platform_device *pdev,\r\nstruct rockchip_thermal_data *thermal,\r\nstruct rockchip_thermal_sensor *sensor,\r\nenum sensor_id id)\r\n{\r\nconst struct rockchip_tsadc_chip *tsadc = thermal->chip;\r\nint error;\r\ntsadc->set_tshut_mode(id, thermal->regs, thermal->tshut_mode);\r\ntsadc->set_tshut_temp(id, thermal->regs, thermal->tshut_temp);\r\nsensor->thermal = thermal;\r\nsensor->id = id;\r\nsensor->tzd = thermal_zone_of_sensor_register(&pdev->dev, id, sensor,\r\n&rockchip_of_thermal_ops);\r\nif (IS_ERR(sensor->tzd)) {\r\nerror = PTR_ERR(sensor->tzd);\r\ndev_err(&pdev->dev, "failed to register sensor %d: %d\n",\r\nid, error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rockchip_thermal_reset_controller(struct reset_control *reset)\r\n{\r\nreset_control_assert(reset);\r\nusleep_range(10, 20);\r\nreset_control_deassert(reset);\r\n}\r\nstatic int rockchip_thermal_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct rockchip_thermal_data *thermal;\r\nconst struct of_device_id *match;\r\nstruct resource *res;\r\nint irq;\r\nint i;\r\nint error;\r\nmatch = of_match_node(of_rockchip_thermal_match, np);\r\nif (!match)\r\nreturn -ENXIO;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no irq resource?\n");\r\nreturn -EINVAL;\r\n}\r\nthermal = devm_kzalloc(&pdev->dev, sizeof(struct rockchip_thermal_data),\r\nGFP_KERNEL);\r\nif (!thermal)\r\nreturn -ENOMEM;\r\nthermal->pdev = pdev;\r\nthermal->chip = (const struct rockchip_tsadc_chip *)match->data;\r\nif (!thermal->chip)\r\nreturn -EINVAL;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nthermal->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(thermal->regs))\r\nreturn PTR_ERR(thermal->regs);\r\nthermal->reset = devm_reset_control_get(&pdev->dev, "tsadc-apb");\r\nif (IS_ERR(thermal->reset)) {\r\nerror = PTR_ERR(thermal->reset);\r\ndev_err(&pdev->dev, "failed to get tsadc reset: %d\n", error);\r\nreturn error;\r\n}\r\nthermal->clk = devm_clk_get(&pdev->dev, "tsadc");\r\nif (IS_ERR(thermal->clk)) {\r\nerror = PTR_ERR(thermal->clk);\r\ndev_err(&pdev->dev, "failed to get tsadc clock: %d\n", error);\r\nreturn error;\r\n}\r\nthermal->pclk = devm_clk_get(&pdev->dev, "apb_pclk");\r\nif (IS_ERR(thermal->pclk)) {\r\nerror = PTR_ERR(thermal->pclk);\r\ndev_err(&pdev->dev, "failed to get apb_pclk clock: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = clk_prepare_enable(thermal->clk);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to enable converter clock: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = clk_prepare_enable(thermal->pclk);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to enable pclk: %d\n", error);\r\ngoto err_disable_clk;\r\n}\r\nrockchip_thermal_reset_controller(thermal->reset);\r\nerror = rockchip_configure_from_dt(&pdev->dev, np, thermal);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to parse device tree data: %d\n",\r\nerror);\r\ngoto err_disable_pclk;\r\n}\r\nthermal->chip->initialize(thermal->regs, thermal->tshut_polarity);\r\nerror = rockchip_thermal_register_sensor(pdev, thermal,\r\n&thermal->sensors[0],\r\nSENSOR_CPU);\r\nif (error) {\r\ndev_err(&pdev->dev,\r\n"failed to register CPU thermal sensor: %d\n", error);\r\ngoto err_disable_pclk;\r\n}\r\nerror = rockchip_thermal_register_sensor(pdev, thermal,\r\n&thermal->sensors[1],\r\nSENSOR_GPU);\r\nif (error) {\r\ndev_err(&pdev->dev,\r\n"failed to register GPU thermal sensor: %d\n", error);\r\ngoto err_unregister_cpu_sensor;\r\n}\r\nerror = devm_request_threaded_irq(&pdev->dev, irq, NULL,\r\n&rockchip_thermal_alarm_irq_thread,\r\nIRQF_ONESHOT,\r\n"rockchip_thermal", thermal);\r\nif (error) {\r\ndev_err(&pdev->dev,\r\n"failed to request tsadc irq: %d\n", error);\r\ngoto err_unregister_gpu_sensor;\r\n}\r\nthermal->chip->control(thermal->regs, true);\r\nfor (i = 0; i < ARRAY_SIZE(thermal->sensors); i++)\r\nrockchip_thermal_toggle_sensor(&thermal->sensors[i], true);\r\nplatform_set_drvdata(pdev, thermal);\r\nreturn 0;\r\nerr_unregister_gpu_sensor:\r\nthermal_zone_of_sensor_unregister(&pdev->dev, thermal->sensors[1].tzd);\r\nerr_unregister_cpu_sensor:\r\nthermal_zone_of_sensor_unregister(&pdev->dev, thermal->sensors[0].tzd);\r\nerr_disable_pclk:\r\nclk_disable_unprepare(thermal->pclk);\r\nerr_disable_clk:\r\nclk_disable_unprepare(thermal->clk);\r\nreturn error;\r\n}\r\nstatic int rockchip_thermal_remove(struct platform_device *pdev)\r\n{\r\nstruct rockchip_thermal_data *thermal = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(thermal->sensors); i++) {\r\nstruct rockchip_thermal_sensor *sensor = &thermal->sensors[i];\r\nrockchip_thermal_toggle_sensor(sensor, false);\r\nthermal_zone_of_sensor_unregister(&pdev->dev, sensor->tzd);\r\n}\r\nthermal->chip->control(thermal->regs, false);\r\nclk_disable_unprepare(thermal->pclk);\r\nclk_disable_unprepare(thermal->clk);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused rockchip_thermal_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct rockchip_thermal_data *thermal = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(thermal->sensors); i++)\r\nrockchip_thermal_toggle_sensor(&thermal->sensors[i], false);\r\nthermal->chip->control(thermal->regs, false);\r\nclk_disable(thermal->pclk);\r\nclk_disable(thermal->clk);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused rockchip_thermal_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct rockchip_thermal_data *thermal = platform_get_drvdata(pdev);\r\nint i;\r\nint error;\r\nerror = clk_enable(thermal->clk);\r\nif (error)\r\nreturn error;\r\nerror = clk_enable(thermal->pclk);\r\nif (error)\r\nreturn error;\r\nrockchip_thermal_reset_controller(thermal->reset);\r\nthermal->chip->initialize(thermal->regs, thermal->tshut_polarity);\r\nfor (i = 0; i < ARRAY_SIZE(thermal->sensors); i++) {\r\nenum sensor_id id = thermal->sensors[i].id;\r\nthermal->chip->set_tshut_mode(id, thermal->regs,\r\nthermal->tshut_mode);\r\nthermal->chip->set_tshut_temp(id, thermal->regs,\r\nthermal->tshut_temp);\r\n}\r\nthermal->chip->control(thermal->regs, true);\r\nfor (i = 0; i < ARRAY_SIZE(thermal->sensors); i++)\r\nrockchip_thermal_toggle_sensor(&thermal->sensors[i], true);\r\nreturn 0;\r\n}
