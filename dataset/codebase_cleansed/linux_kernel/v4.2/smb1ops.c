static int\r\nsend_nt_cancel(struct TCP_Server_Info *server, void *buf,\r\nstruct mid_q_entry *mid)\r\n{\r\nint rc = 0;\r\nstruct smb_hdr *in_buf = (struct smb_hdr *)buf;\r\nin_buf->smb_buf_length = cpu_to_be32(sizeof(struct smb_hdr) - 4 + 2);\r\nin_buf->Command = SMB_COM_NT_CANCEL;\r\nin_buf->WordCount = 0;\r\nput_bcc(0, in_buf);\r\nmutex_lock(&server->srv_mutex);\r\nrc = cifs_sign_smb(in_buf, server, &mid->sequence_number);\r\nif (rc) {\r\nmutex_unlock(&server->srv_mutex);\r\nreturn rc;\r\n}\r\n--server->sequence_number;\r\nrc = smb_send(server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\r\nif (rc < 0)\r\nserver->sequence_number--;\r\nmutex_unlock(&server->srv_mutex);\r\ncifs_dbg(FYI, "issued NT_CANCEL for mid %u, rc = %d\n",\r\nget_mid(in_buf), rc);\r\nreturn rc;\r\n}\r\nstatic bool\r\ncifs_compare_fids(struct cifsFileInfo *ob1, struct cifsFileInfo *ob2)\r\n{\r\nreturn ob1->fid.netfid == ob2->fid.netfid;\r\n}\r\nstatic unsigned int\r\ncifs_read_data_offset(char *buf)\r\n{\r\nREAD_RSP *rsp = (READ_RSP *)buf;\r\nreturn le16_to_cpu(rsp->DataOffset);\r\n}\r\nstatic unsigned int\r\ncifs_read_data_length(char *buf)\r\n{\r\nREAD_RSP *rsp = (READ_RSP *)buf;\r\nreturn (le16_to_cpu(rsp->DataLengthHigh) << 16) +\r\nle16_to_cpu(rsp->DataLength);\r\n}\r\nstatic struct mid_q_entry *\r\ncifs_find_mid(struct TCP_Server_Info *server, char *buffer)\r\n{\r\nstruct smb_hdr *buf = (struct smb_hdr *)buffer;\r\nstruct mid_q_entry *mid;\r\nspin_lock(&GlobalMid_Lock);\r\nlist_for_each_entry(mid, &server->pending_mid_q, qhead) {\r\nif (compare_mid(mid->mid, buf) &&\r\nmid->mid_state == MID_REQUEST_SUBMITTED &&\r\nle16_to_cpu(mid->command) == buf->Command) {\r\nspin_unlock(&GlobalMid_Lock);\r\nreturn mid;\r\n}\r\n}\r\nspin_unlock(&GlobalMid_Lock);\r\nreturn NULL;\r\n}\r\nstatic void\r\ncifs_add_credits(struct TCP_Server_Info *server, const unsigned int add,\r\nconst int optype)\r\n{\r\nspin_lock(&server->req_lock);\r\nserver->credits += add;\r\nserver->in_flight--;\r\nspin_unlock(&server->req_lock);\r\nwake_up(&server->request_q);\r\n}\r\nstatic void\r\ncifs_set_credits(struct TCP_Server_Info *server, const int val)\r\n{\r\nspin_lock(&server->req_lock);\r\nserver->credits = val;\r\nserver->oplocks = val > 1 ? enable_oplocks : false;\r\nspin_unlock(&server->req_lock);\r\n}\r\nstatic int *\r\ncifs_get_credits_field(struct TCP_Server_Info *server, const int optype)\r\n{\r\nreturn &server->credits;\r\n}\r\nstatic unsigned int\r\ncifs_get_credits(struct mid_q_entry *mid)\r\n{\r\nreturn 1;\r\n}\r\nstatic __u64\r\ncifs_get_next_mid(struct TCP_Server_Info *server)\r\n{\r\n__u64 mid = 0;\r\n__u16 last_mid, cur_mid;\r\nbool collision;\r\nspin_lock(&GlobalMid_Lock);\r\ncur_mid = (__u16)((server->CurrentMid) & 0xffff);\r\nlast_mid = cur_mid;\r\ncur_mid++;\r\nwhile (cur_mid != last_mid) {\r\nstruct mid_q_entry *mid_entry;\r\nunsigned int num_mids;\r\ncollision = false;\r\nif (cur_mid == 0)\r\ncur_mid++;\r\nnum_mids = 0;\r\nlist_for_each_entry(mid_entry, &server->pending_mid_q, qhead) {\r\n++num_mids;\r\nif (mid_entry->mid == cur_mid &&\r\nmid_entry->mid_state == MID_REQUEST_SUBMITTED) {\r\ncollision = true;\r\nbreak;\r\n}\r\n}\r\nif (num_mids > 32768)\r\nserver->tcpStatus = CifsNeedReconnect;\r\nif (!collision) {\r\nmid = (__u64)cur_mid;\r\nserver->CurrentMid = mid;\r\nbreak;\r\n}\r\ncur_mid++;\r\n}\r\nspin_unlock(&GlobalMid_Lock);\r\nreturn mid;\r\n}\r\nstatic int\r\ncheck2ndT2(char *buf)\r\n{\r\nstruct smb_hdr *pSMB = (struct smb_hdr *)buf;\r\nstruct smb_t2_rsp *pSMBt;\r\nint remaining;\r\n__u16 total_data_size, data_in_this_rsp;\r\nif (pSMB->Command != SMB_COM_TRANSACTION2)\r\nreturn 0;\r\nif (pSMB->WordCount != 10) {\r\ncifs_dbg(FYI, "invalid transact2 word count\n");\r\nreturn -EINVAL;\r\n}\r\npSMBt = (struct smb_t2_rsp *)pSMB;\r\ntotal_data_size = get_unaligned_le16(&pSMBt->t2_rsp.TotalDataCount);\r\ndata_in_this_rsp = get_unaligned_le16(&pSMBt->t2_rsp.DataCount);\r\nif (total_data_size == data_in_this_rsp)\r\nreturn 0;\r\nelse if (total_data_size < data_in_this_rsp) {\r\ncifs_dbg(FYI, "total data %d smaller than data in frame %d\n",\r\ntotal_data_size, data_in_this_rsp);\r\nreturn -EINVAL;\r\n}\r\nremaining = total_data_size - data_in_this_rsp;\r\ncifs_dbg(FYI, "missing %d bytes from transact2, check next response\n",\r\nremaining);\r\nif (total_data_size > CIFSMaxBufSize) {\r\ncifs_dbg(VFS, "TotalDataSize %d is over maximum buffer %d\n",\r\ntotal_data_size, CIFSMaxBufSize);\r\nreturn -EINVAL;\r\n}\r\nreturn remaining;\r\n}\r\nstatic int\r\ncoalesce_t2(char *second_buf, struct smb_hdr *target_hdr)\r\n{\r\nstruct smb_t2_rsp *pSMBs = (struct smb_t2_rsp *)second_buf;\r\nstruct smb_t2_rsp *pSMBt = (struct smb_t2_rsp *)target_hdr;\r\nchar *data_area_of_tgt;\r\nchar *data_area_of_src;\r\nint remaining;\r\nunsigned int byte_count, total_in_tgt;\r\n__u16 tgt_total_cnt, src_total_cnt, total_in_src;\r\nsrc_total_cnt = get_unaligned_le16(&pSMBs->t2_rsp.TotalDataCount);\r\ntgt_total_cnt = get_unaligned_le16(&pSMBt->t2_rsp.TotalDataCount);\r\nif (tgt_total_cnt != src_total_cnt)\r\ncifs_dbg(FYI, "total data count of primary and secondary t2 differ source=%hu target=%hu\n",\r\nsrc_total_cnt, tgt_total_cnt);\r\ntotal_in_tgt = get_unaligned_le16(&pSMBt->t2_rsp.DataCount);\r\nremaining = tgt_total_cnt - total_in_tgt;\r\nif (remaining < 0) {\r\ncifs_dbg(FYI, "Server sent too much data. tgt_total_cnt=%hu total_in_tgt=%hu\n",\r\ntgt_total_cnt, total_in_tgt);\r\nreturn -EPROTO;\r\n}\r\nif (remaining == 0) {\r\ncifs_dbg(FYI, "no more data remains\n");\r\nreturn 0;\r\n}\r\ntotal_in_src = get_unaligned_le16(&pSMBs->t2_rsp.DataCount);\r\nif (remaining < total_in_src)\r\ncifs_dbg(FYI, "transact2 2nd response contains too much data\n");\r\ndata_area_of_tgt = (char *)&pSMBt->hdr.Protocol +\r\nget_unaligned_le16(&pSMBt->t2_rsp.DataOffset);\r\ndata_area_of_src = (char *)&pSMBs->hdr.Protocol +\r\nget_unaligned_le16(&pSMBs->t2_rsp.DataOffset);\r\ndata_area_of_tgt += total_in_tgt;\r\ntotal_in_tgt += total_in_src;\r\nif (total_in_tgt > USHRT_MAX) {\r\ncifs_dbg(FYI, "coalesced DataCount too large (%u)\n",\r\ntotal_in_tgt);\r\nreturn -EPROTO;\r\n}\r\nput_unaligned_le16(total_in_tgt, &pSMBt->t2_rsp.DataCount);\r\nbyte_count = get_bcc(target_hdr);\r\nbyte_count += total_in_src;\r\nif (byte_count > USHRT_MAX) {\r\ncifs_dbg(FYI, "coalesced BCC too large (%u)\n", byte_count);\r\nreturn -EPROTO;\r\n}\r\nput_bcc(byte_count, target_hdr);\r\nbyte_count = be32_to_cpu(target_hdr->smb_buf_length);\r\nbyte_count += total_in_src;\r\nif (byte_count > CIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4) {\r\ncifs_dbg(FYI, "coalesced BCC exceeds buffer size (%u)\n",\r\nbyte_count);\r\nreturn -ENOBUFS;\r\n}\r\ntarget_hdr->smb_buf_length = cpu_to_be32(byte_count);\r\nmemcpy(data_area_of_tgt, data_area_of_src, total_in_src);\r\nif (remaining != total_in_src) {\r\ncifs_dbg(FYI, "waiting for more secondary responses\n");\r\nreturn 1;\r\n}\r\ncifs_dbg(FYI, "found the last secondary response\n");\r\nreturn 0;\r\n}\r\nstatic void\r\ncifs_downgrade_oplock(struct TCP_Server_Info *server,\r\nstruct cifsInodeInfo *cinode, bool set_level2)\r\n{\r\nif (set_level2)\r\ncifs_set_oplock_level(cinode, OPLOCK_READ);\r\nelse\r\ncifs_set_oplock_level(cinode, 0);\r\n}\r\nstatic bool\r\ncifs_check_trans2(struct mid_q_entry *mid, struct TCP_Server_Info *server,\r\nchar *buf, int malformed)\r\n{\r\nif (malformed)\r\nreturn false;\r\nif (check2ndT2(buf) <= 0)\r\nreturn false;\r\nmid->multiRsp = true;\r\nif (mid->resp_buf) {\r\nmalformed = coalesce_t2(buf, mid->resp_buf);\r\nif (malformed > 0)\r\nreturn true;\r\nmid->multiEnd = true;\r\ndequeue_mid(mid, malformed);\r\nreturn true;\r\n}\r\nif (!server->large_buf) {\r\ncifs_dbg(VFS, "1st trans2 resp needs bigbuf\n");\r\n} else {\r\nmid->resp_buf = buf;\r\nmid->large_buf = true;\r\nserver->bigbuf = NULL;\r\n}\r\nreturn true;\r\n}\r\nstatic bool\r\ncifs_need_neg(struct TCP_Server_Info *server)\r\n{\r\nreturn server->maxBuf == 0;\r\n}\r\nstatic int\r\ncifs_negotiate(const unsigned int xid, struct cifs_ses *ses)\r\n{\r\nint rc;\r\nrc = CIFSSMBNegotiate(xid, ses);\r\nif (rc == -EAGAIN) {\r\nset_credits(ses->server, 1);\r\nrc = CIFSSMBNegotiate(xid, ses);\r\nif (rc == -EAGAIN)\r\nrc = -EHOSTDOWN;\r\n}\r\nreturn rc;\r\n}\r\nstatic unsigned int\r\ncifs_negotiate_wsize(struct cifs_tcon *tcon, struct smb_vol *volume_info)\r\n{\r\n__u64 unix_cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\r\nstruct TCP_Server_Info *server = tcon->ses->server;\r\nunsigned int wsize;\r\nif (volume_info->wsize)\r\nwsize = volume_info->wsize;\r\nelse if (tcon->unix_ext && (unix_cap & CIFS_UNIX_LARGE_WRITE_CAP))\r\nwsize = CIFS_DEFAULT_IOSIZE;\r\nelse\r\nwsize = CIFS_DEFAULT_NON_POSIX_WSIZE;\r\nif (!tcon->unix_ext || !(unix_cap & CIFS_UNIX_LARGE_WRITE_CAP))\r\nwsize = min_t(unsigned int, wsize, CIFS_MAX_RFC1002_WSIZE);\r\nif (!(server->capabilities & CAP_LARGE_WRITE_X) ||\r\n(!(server->capabilities & CAP_UNIX) && server->sign))\r\nwsize = min_t(unsigned int, wsize,\r\nserver->maxBuf - sizeof(WRITE_REQ) + 4);\r\nwsize = min_t(unsigned int, wsize, CIFS_MAX_WSIZE);\r\nreturn wsize;\r\n}\r\nstatic unsigned int\r\ncifs_negotiate_rsize(struct cifs_tcon *tcon, struct smb_vol *volume_info)\r\n{\r\n__u64 unix_cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\r\nstruct TCP_Server_Info *server = tcon->ses->server;\r\nunsigned int rsize, defsize;\r\nif (tcon->unix_ext && (unix_cap & CIFS_UNIX_LARGE_READ_CAP))\r\ndefsize = CIFS_DEFAULT_IOSIZE;\r\nelse if (server->capabilities & CAP_LARGE_READ_X)\r\ndefsize = CIFS_DEFAULT_NON_POSIX_RSIZE;\r\nelse\r\ndefsize = server->maxBuf - sizeof(READ_RSP);\r\nrsize = volume_info->rsize ? volume_info->rsize : defsize;\r\nif (!(server->capabilities & CAP_LARGE_READ_X))\r\nrsize = min_t(unsigned int, CIFSMaxBufSize, rsize);\r\nrsize = min_t(unsigned int, rsize, CIFS_MAX_RSIZE);\r\nreturn rsize;\r\n}\r\nstatic void\r\ncifs_qfs_tcon(const unsigned int xid, struct cifs_tcon *tcon)\r\n{\r\nCIFSSMBQFSDeviceInfo(xid, tcon);\r\nCIFSSMBQFSAttributeInfo(xid, tcon);\r\n}\r\nstatic int\r\ncifs_is_path_accessible(const unsigned int xid, struct cifs_tcon *tcon,\r\nstruct cifs_sb_info *cifs_sb, const char *full_path)\r\n{\r\nint rc;\r\nFILE_ALL_INFO *file_info;\r\nfile_info = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);\r\nif (file_info == NULL)\r\nreturn -ENOMEM;\r\nrc = CIFSSMBQPathInfo(xid, tcon, full_path, file_info,\r\n0 , cifs_sb->local_nls,\r\ncifs_remap(cifs_sb));\r\nif (rc == -EOPNOTSUPP || rc == -EINVAL)\r\nrc = SMBQueryInformation(xid, tcon, full_path, file_info,\r\ncifs_sb->local_nls, cifs_remap(cifs_sb));\r\nkfree(file_info);\r\nreturn rc;\r\n}\r\nstatic int\r\ncifs_query_path_info(const unsigned int xid, struct cifs_tcon *tcon,\r\nstruct cifs_sb_info *cifs_sb, const char *full_path,\r\nFILE_ALL_INFO *data, bool *adjustTZ, bool *symlink)\r\n{\r\nint rc;\r\n*symlink = false;\r\nrc = CIFSSMBQPathInfo(xid, tcon, full_path, data, 0 ,\r\ncifs_sb->local_nls, cifs_remap(cifs_sb));\r\nif ((rc == -EOPNOTSUPP) || (rc == -EINVAL)) {\r\nrc = SMBQueryInformation(xid, tcon, full_path, data,\r\ncifs_sb->local_nls,\r\ncifs_remap(cifs_sb));\r\n*adjustTZ = true;\r\n}\r\nif (!rc && (le32_to_cpu(data->Attributes) & ATTR_REPARSE)) {\r\nint tmprc;\r\nint oplock = 0;\r\nstruct cifs_fid fid;\r\nstruct cifs_open_parms oparms;\r\noparms.tcon = tcon;\r\noparms.cifs_sb = cifs_sb;\r\noparms.desired_access = FILE_READ_ATTRIBUTES;\r\noparms.create_options = 0;\r\noparms.disposition = FILE_OPEN;\r\noparms.path = full_path;\r\noparms.fid = &fid;\r\noparms.reconnect = false;\r\ntmprc = CIFS_open(xid, &oparms, &oplock, NULL);\r\nif (tmprc == -EOPNOTSUPP)\r\n*symlink = true;\r\nelse if (tmprc == 0)\r\nCIFSSMBClose(xid, tcon, fid.netfid);\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\ncifs_get_srv_inum(const unsigned int xid, struct cifs_tcon *tcon,\r\nstruct cifs_sb_info *cifs_sb, const char *full_path,\r\nu64 *uniqueid, FILE_ALL_INFO *data)\r\n{\r\nreturn CIFSGetSrvInodeNumber(xid, tcon, full_path, uniqueid,\r\ncifs_sb->local_nls,\r\ncifs_remap(cifs_sb));\r\n}\r\nstatic int\r\ncifs_query_file_info(const unsigned int xid, struct cifs_tcon *tcon,\r\nstruct cifs_fid *fid, FILE_ALL_INFO *data)\r\n{\r\nreturn CIFSSMBQFileInfo(xid, tcon, fid->netfid, data);\r\n}\r\nstatic void\r\ncifs_clear_stats(struct cifs_tcon *tcon)\r\n{\r\n#ifdef CONFIG_CIFS_STATS\r\natomic_set(&tcon->stats.cifs_stats.num_writes, 0);\r\natomic_set(&tcon->stats.cifs_stats.num_reads, 0);\r\natomic_set(&tcon->stats.cifs_stats.num_flushes, 0);\r\natomic_set(&tcon->stats.cifs_stats.num_oplock_brks, 0);\r\natomic_set(&tcon->stats.cifs_stats.num_opens, 0);\r\natomic_set(&tcon->stats.cifs_stats.num_posixopens, 0);\r\natomic_set(&tcon->stats.cifs_stats.num_posixmkdirs, 0);\r\natomic_set(&tcon->stats.cifs_stats.num_closes, 0);\r\natomic_set(&tcon->stats.cifs_stats.num_deletes, 0);\r\natomic_set(&tcon->stats.cifs_stats.num_mkdirs, 0);\r\natomic_set(&tcon->stats.cifs_stats.num_rmdirs, 0);\r\natomic_set(&tcon->stats.cifs_stats.num_renames, 0);\r\natomic_set(&tcon->stats.cifs_stats.num_t2renames, 0);\r\natomic_set(&tcon->stats.cifs_stats.num_ffirst, 0);\r\natomic_set(&tcon->stats.cifs_stats.num_fnext, 0);\r\natomic_set(&tcon->stats.cifs_stats.num_fclose, 0);\r\natomic_set(&tcon->stats.cifs_stats.num_hardlinks, 0);\r\natomic_set(&tcon->stats.cifs_stats.num_symlinks, 0);\r\natomic_set(&tcon->stats.cifs_stats.num_locks, 0);\r\natomic_set(&tcon->stats.cifs_stats.num_acl_get, 0);\r\natomic_set(&tcon->stats.cifs_stats.num_acl_set, 0);\r\n#endif\r\n}\r\nstatic void\r\ncifs_print_stats(struct seq_file *m, struct cifs_tcon *tcon)\r\n{\r\n#ifdef CONFIG_CIFS_STATS\r\nseq_printf(m, " Oplocks breaks: %d",\r\natomic_read(&tcon->stats.cifs_stats.num_oplock_brks));\r\nseq_printf(m, "\nReads: %d Bytes: %llu",\r\natomic_read(&tcon->stats.cifs_stats.num_reads),\r\n(long long)(tcon->bytes_read));\r\nseq_printf(m, "\nWrites: %d Bytes: %llu",\r\natomic_read(&tcon->stats.cifs_stats.num_writes),\r\n(long long)(tcon->bytes_written));\r\nseq_printf(m, "\nFlushes: %d",\r\natomic_read(&tcon->stats.cifs_stats.num_flushes));\r\nseq_printf(m, "\nLocks: %d HardLinks: %d Symlinks: %d",\r\natomic_read(&tcon->stats.cifs_stats.num_locks),\r\natomic_read(&tcon->stats.cifs_stats.num_hardlinks),\r\natomic_read(&tcon->stats.cifs_stats.num_symlinks));\r\nseq_printf(m, "\nOpens: %d Closes: %d Deletes: %d",\r\natomic_read(&tcon->stats.cifs_stats.num_opens),\r\natomic_read(&tcon->stats.cifs_stats.num_closes),\r\natomic_read(&tcon->stats.cifs_stats.num_deletes));\r\nseq_printf(m, "\nPosix Opens: %d Posix Mkdirs: %d",\r\natomic_read(&tcon->stats.cifs_stats.num_posixopens),\r\natomic_read(&tcon->stats.cifs_stats.num_posixmkdirs));\r\nseq_printf(m, "\nMkdirs: %d Rmdirs: %d",\r\natomic_read(&tcon->stats.cifs_stats.num_mkdirs),\r\natomic_read(&tcon->stats.cifs_stats.num_rmdirs));\r\nseq_printf(m, "\nRenames: %d T2 Renames %d",\r\natomic_read(&tcon->stats.cifs_stats.num_renames),\r\natomic_read(&tcon->stats.cifs_stats.num_t2renames));\r\nseq_printf(m, "\nFindFirst: %d FNext %d FClose %d",\r\natomic_read(&tcon->stats.cifs_stats.num_ffirst),\r\natomic_read(&tcon->stats.cifs_stats.num_fnext),\r\natomic_read(&tcon->stats.cifs_stats.num_fclose));\r\n#endif\r\n}\r\nstatic void\r\ncifs_mkdir_setinfo(struct inode *inode, const char *full_path,\r\nstruct cifs_sb_info *cifs_sb, struct cifs_tcon *tcon,\r\nconst unsigned int xid)\r\n{\r\nFILE_BASIC_INFO info;\r\nstruct cifsInodeInfo *cifsInode;\r\nu32 dosattrs;\r\nint rc;\r\nmemset(&info, 0, sizeof(info));\r\ncifsInode = CIFS_I(inode);\r\ndosattrs = cifsInode->cifsAttrs|ATTR_READONLY;\r\ninfo.Attributes = cpu_to_le32(dosattrs);\r\nrc = CIFSSMBSetPathInfo(xid, tcon, full_path, &info, cifs_sb->local_nls,\r\ncifs_remap(cifs_sb));\r\nif (rc == 0)\r\ncifsInode->cifsAttrs = dosattrs;\r\n}\r\nstatic int\r\ncifs_open_file(const unsigned int xid, struct cifs_open_parms *oparms,\r\n__u32 *oplock, FILE_ALL_INFO *buf)\r\n{\r\nif (!(oparms->tcon->ses->capabilities & CAP_NT_SMBS))\r\nreturn SMBLegacyOpen(xid, oparms->tcon, oparms->path,\r\noparms->disposition,\r\noparms->desired_access,\r\noparms->create_options,\r\n&oparms->fid->netfid, oplock, buf,\r\noparms->cifs_sb->local_nls,\r\ncifs_remap(oparms->cifs_sb));\r\nreturn CIFS_open(xid, oparms, oplock, buf);\r\n}\r\nstatic void\r\ncifs_set_fid(struct cifsFileInfo *cfile, struct cifs_fid *fid, __u32 oplock)\r\n{\r\nstruct cifsInodeInfo *cinode = CIFS_I(d_inode(cfile->dentry));\r\ncfile->fid.netfid = fid->netfid;\r\ncifs_set_oplock_level(cinode, oplock);\r\ncinode->can_cache_brlcks = CIFS_CACHE_WRITE(cinode);\r\n}\r\nstatic void\r\ncifs_close_file(const unsigned int xid, struct cifs_tcon *tcon,\r\nstruct cifs_fid *fid)\r\n{\r\nCIFSSMBClose(xid, tcon, fid->netfid);\r\n}\r\nstatic int\r\ncifs_flush_file(const unsigned int xid, struct cifs_tcon *tcon,\r\nstruct cifs_fid *fid)\r\n{\r\nreturn CIFSSMBFlush(xid, tcon, fid->netfid);\r\n}\r\nstatic int\r\ncifs_sync_read(const unsigned int xid, struct cifs_fid *pfid,\r\nstruct cifs_io_parms *parms, unsigned int *bytes_read,\r\nchar **buf, int *buf_type)\r\n{\r\nparms->netfid = pfid->netfid;\r\nreturn CIFSSMBRead(xid, parms, bytes_read, buf, buf_type);\r\n}\r\nstatic int\r\ncifs_sync_write(const unsigned int xid, struct cifs_fid *pfid,\r\nstruct cifs_io_parms *parms, unsigned int *written,\r\nstruct kvec *iov, unsigned long nr_segs)\r\n{\r\nparms->netfid = pfid->netfid;\r\nreturn CIFSSMBWrite2(xid, parms, written, iov, nr_segs);\r\n}\r\nstatic int\r\nsmb_set_file_info(struct inode *inode, const char *full_path,\r\nFILE_BASIC_INFO *buf, const unsigned int xid)\r\n{\r\nint oplock = 0;\r\nint rc;\r\n__u32 netpid;\r\nstruct cifs_fid fid;\r\nstruct cifs_open_parms oparms;\r\nstruct cifsFileInfo *open_file;\r\nstruct cifsInodeInfo *cinode = CIFS_I(inode);\r\nstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\r\nstruct tcon_link *tlink = NULL;\r\nstruct cifs_tcon *tcon;\r\nopen_file = find_writable_file(cinode, true);\r\nif (open_file) {\r\nfid.netfid = open_file->fid.netfid;\r\nnetpid = open_file->pid;\r\ntcon = tlink_tcon(open_file->tlink);\r\ngoto set_via_filehandle;\r\n}\r\ntlink = cifs_sb_tlink(cifs_sb);\r\nif (IS_ERR(tlink)) {\r\nrc = PTR_ERR(tlink);\r\ntlink = NULL;\r\ngoto out;\r\n}\r\ntcon = tlink_tcon(tlink);\r\nrc = CIFSSMBSetPathInfo(xid, tcon, full_path, buf, cifs_sb->local_nls,\r\ncifs_remap(cifs_sb));\r\nif (rc == 0) {\r\ncinode->cifsAttrs = le32_to_cpu(buf->Attributes);\r\ngoto out;\r\n} else if (rc != -EOPNOTSUPP && rc != -EINVAL) {\r\ngoto out;\r\n}\r\noparms.tcon = tcon;\r\noparms.cifs_sb = cifs_sb;\r\noparms.desired_access = SYNCHRONIZE | FILE_WRITE_ATTRIBUTES;\r\noparms.create_options = CREATE_NOT_DIR;\r\noparms.disposition = FILE_OPEN;\r\noparms.path = full_path;\r\noparms.fid = &fid;\r\noparms.reconnect = false;\r\ncifs_dbg(FYI, "calling SetFileInfo since SetPathInfo for times not supported by this server\n");\r\nrc = CIFS_open(xid, &oparms, &oplock, NULL);\r\nif (rc != 0) {\r\nif (rc == -EIO)\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nnetpid = current->tgid;\r\nset_via_filehandle:\r\nrc = CIFSSMBSetFileInfo(xid, tcon, buf, fid.netfid, netpid);\r\nif (!rc)\r\ncinode->cifsAttrs = le32_to_cpu(buf->Attributes);\r\nif (open_file == NULL)\r\nCIFSSMBClose(xid, tcon, fid.netfid);\r\nelse\r\ncifsFileInfo_put(open_file);\r\nout:\r\nif (tlink != NULL)\r\ncifs_put_tlink(tlink);\r\nreturn rc;\r\n}\r\nstatic int\r\ncifs_set_compression(const unsigned int xid, struct cifs_tcon *tcon,\r\nstruct cifsFileInfo *cfile)\r\n{\r\nreturn CIFSSMB_set_compression(xid, tcon, cfile->fid.netfid);\r\n}\r\nstatic int\r\ncifs_query_dir_first(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst char *path, struct cifs_sb_info *cifs_sb,\r\nstruct cifs_fid *fid, __u16 search_flags,\r\nstruct cifs_search_info *srch_inf)\r\n{\r\nreturn CIFSFindFirst(xid, tcon, path, cifs_sb,\r\n&fid->netfid, search_flags, srch_inf, true);\r\n}\r\nstatic int\r\ncifs_query_dir_next(const unsigned int xid, struct cifs_tcon *tcon,\r\nstruct cifs_fid *fid, __u16 search_flags,\r\nstruct cifs_search_info *srch_inf)\r\n{\r\nreturn CIFSFindNext(xid, tcon, fid->netfid, search_flags, srch_inf);\r\n}\r\nstatic int\r\ncifs_close_dir(const unsigned int xid, struct cifs_tcon *tcon,\r\nstruct cifs_fid *fid)\r\n{\r\nreturn CIFSFindClose(xid, tcon, fid->netfid);\r\n}\r\nstatic int\r\ncifs_oplock_response(struct cifs_tcon *tcon, struct cifs_fid *fid,\r\nstruct cifsInodeInfo *cinode)\r\n{\r\nreturn CIFSSMBLock(0, tcon, fid->netfid, current->tgid, 0, 0, 0, 0,\r\nLOCKING_ANDX_OPLOCK_RELEASE, false,\r\nCIFS_CACHE_READ(cinode) ? 1 : 0);\r\n}\r\nstatic int\r\ncifs_queryfs(const unsigned int xid, struct cifs_tcon *tcon,\r\nstruct kstatfs *buf)\r\n{\r\nint rc = -EOPNOTSUPP;\r\nbuf->f_type = CIFS_MAGIC_NUMBER;\r\nif ((tcon->ses->capabilities & CAP_UNIX) &&\r\n(CIFS_POSIX_EXTENSIONS & le64_to_cpu(tcon->fsUnixInfo.Capability)))\r\nrc = CIFSSMBQFSPosixInfo(xid, tcon, buf);\r\nif (rc && (tcon->ses->capabilities & CAP_NT_SMBS))\r\nrc = CIFSSMBQFSInfo(xid, tcon, buf);\r\nif (rc)\r\nrc = SMBOldQFSInfo(xid, tcon, buf);\r\nreturn rc;\r\n}\r\nstatic int\r\ncifs_mand_lock(const unsigned int xid, struct cifsFileInfo *cfile, __u64 offset,\r\n__u64 length, __u32 type, int lock, int unlock, bool wait)\r\n{\r\nreturn CIFSSMBLock(xid, tlink_tcon(cfile->tlink), cfile->fid.netfid,\r\ncurrent->tgid, length, offset, unlock, lock,\r\n(__u8)type, wait, 0);\r\n}\r\nstatic int\r\ncifs_unix_dfs_readlink(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst unsigned char *searchName, char **symlinkinfo,\r\nconst struct nls_table *nls_codepage)\r\n{\r\n#ifdef CONFIG_CIFS_DFS_UPCALL\r\nint rc;\r\nunsigned int num_referrals = 0;\r\nstruct dfs_info3_param *referrals = NULL;\r\nrc = get_dfs_path(xid, tcon->ses, searchName, nls_codepage,\r\n&num_referrals, &referrals, 0);\r\nif (!rc && num_referrals > 0) {\r\n*symlinkinfo = kstrndup(referrals->node_name,\r\nstrlen(referrals->node_name),\r\nGFP_KERNEL);\r\nif (!*symlinkinfo)\r\nrc = -ENOMEM;\r\nfree_dfs_info_array(referrals, num_referrals);\r\n}\r\nreturn rc;\r\n#else\r\nreturn -EREMOTE;\r\n#endif\r\n}\r\nstatic int\r\ncifs_query_symlink(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst char *full_path, char **target_path,\r\nstruct cifs_sb_info *cifs_sb)\r\n{\r\nint rc;\r\nint oplock = 0;\r\nstruct cifs_fid fid;\r\nstruct cifs_open_parms oparms;\r\ncifs_dbg(FYI, "%s: path: %s\n", __func__, full_path);\r\nif (cap_unix(tcon->ses)) {\r\nrc = CIFSSMBUnixQuerySymLink(xid, tcon, full_path, target_path,\r\ncifs_sb->local_nls,\r\ncifs_remap(cifs_sb));\r\nif (rc == -EREMOTE)\r\nrc = cifs_unix_dfs_readlink(xid, tcon, full_path,\r\ntarget_path,\r\ncifs_sb->local_nls);\r\ngoto out;\r\n}\r\noparms.tcon = tcon;\r\noparms.cifs_sb = cifs_sb;\r\noparms.desired_access = FILE_READ_ATTRIBUTES;\r\noparms.create_options = OPEN_REPARSE_POINT;\r\noparms.disposition = FILE_OPEN;\r\noparms.path = full_path;\r\noparms.fid = &fid;\r\noparms.reconnect = false;\r\nrc = CIFS_open(xid, &oparms, &oplock, NULL);\r\nif (rc)\r\ngoto out;\r\nrc = CIFSSMBQuerySymLink(xid, tcon, fid.netfid, target_path,\r\ncifs_sb->local_nls);\r\nif (rc)\r\ngoto out_close;\r\nconvert_delimiter(*target_path, '/');\r\nout_close:\r\nCIFSSMBClose(xid, tcon, fid.netfid);\r\nout:\r\nif (!rc)\r\ncifs_dbg(FYI, "%s: target path: %s\n", __func__, *target_path);\r\nreturn rc;\r\n}\r\nstatic bool\r\ncifs_is_read_op(__u32 oplock)\r\n{\r\nreturn oplock == OPLOCK_READ;\r\n}\r\nstatic unsigned int\r\ncifs_wp_retry_size(struct inode *inode)\r\n{\r\nreturn CIFS_SB(inode->i_sb)->wsize;\r\n}\r\nstatic bool\r\ncifs_dir_needs_close(struct cifsFileInfo *cfile)\r\n{\r\nreturn !cfile->srch_inf.endOfSearch && !cfile->invalidHandle;\r\n}
