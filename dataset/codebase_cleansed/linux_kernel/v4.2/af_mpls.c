static struct mpls_route *mpls_route_input_rcu(struct net *net, unsigned index)\r\n{\r\nstruct mpls_route *rt = NULL;\r\nif (index < net->mpls.platform_labels) {\r\nstruct mpls_route __rcu **platform_label =\r\nrcu_dereference(net->mpls.platform_label);\r\nrt = rcu_dereference(platform_label[index]);\r\n}\r\nreturn rt;\r\n}\r\nstatic inline struct mpls_dev *mpls_dev_get(const struct net_device *dev)\r\n{\r\nreturn rcu_dereference_rtnl(dev->mpls_ptr);\r\n}\r\nstatic bool mpls_output_possible(const struct net_device *dev)\r\n{\r\nreturn dev && (dev->flags & IFF_UP) && netif_carrier_ok(dev);\r\n}\r\nstatic unsigned int mpls_rt_header_size(const struct mpls_route *rt)\r\n{\r\nreturn rt->rt_labels * sizeof(struct mpls_shim_hdr);\r\n}\r\nstatic unsigned int mpls_dev_mtu(const struct net_device *dev)\r\n{\r\nreturn dev->mtu;\r\n}\r\nstatic bool mpls_pkt_too_big(const struct sk_buff *skb, unsigned int mtu)\r\n{\r\nif (skb->len <= mtu)\r\nreturn false;\r\nif (skb_is_gso(skb) && skb_gso_network_seglen(skb) <= mtu)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool mpls_egress(struct mpls_route *rt, struct sk_buff *skb,\r\nstruct mpls_entry_decoded dec)\r\n{\r\nstruct iphdr *hdr4;\r\nbool success = true;\r\nif (!pskb_may_pull(skb, 12))\r\nreturn false;\r\nhdr4 = ip_hdr(skb);\r\nif (hdr4->version == 4) {\r\nskb->protocol = htons(ETH_P_IP);\r\ncsum_replace2(&hdr4->check,\r\nhtons(hdr4->ttl << 8),\r\nhtons(dec.ttl << 8));\r\nhdr4->ttl = dec.ttl;\r\n}\r\nelse if (hdr4->version == 6) {\r\nstruct ipv6hdr *hdr6 = ipv6_hdr(skb);\r\nskb->protocol = htons(ETH_P_IPV6);\r\nhdr6->hop_limit = dec.ttl;\r\n}\r\nelse\r\nsuccess = false;\r\nreturn success;\r\n}\r\nstatic int mpls_forward(struct sk_buff *skb, struct net_device *dev,\r\nstruct packet_type *pt, struct net_device *orig_dev)\r\n{\r\nstruct net *net = dev_net(dev);\r\nstruct mpls_shim_hdr *hdr;\r\nstruct mpls_route *rt;\r\nstruct mpls_entry_decoded dec;\r\nstruct net_device *out_dev;\r\nstruct mpls_dev *mdev;\r\nunsigned int hh_len;\r\nunsigned int new_header_size;\r\nunsigned int mtu;\r\nint err;\r\nmdev = mpls_dev_get(dev);\r\nif (!mdev || !mdev->input_enabled)\r\ngoto drop;\r\nif (skb->pkt_type != PACKET_HOST)\r\ngoto drop;\r\nif ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL)\r\ngoto drop;\r\nif (!pskb_may_pull(skb, sizeof(*hdr)))\r\ngoto drop;\r\nhdr = mpls_hdr(skb);\r\ndec = mpls_entry_decode(hdr);\r\nskb_pull(skb, sizeof(*hdr));\r\nskb_reset_network_header(skb);\r\nskb_orphan(skb);\r\nrt = mpls_route_input_rcu(net, dec.label);\r\nif (!rt)\r\ngoto drop;\r\nout_dev = rcu_dereference(rt->rt_dev);\r\nif (!mpls_output_possible(out_dev))\r\ngoto drop;\r\nif (skb_warn_if_lro(skb))\r\ngoto drop;\r\nskb_forward_csum(skb);\r\nif (dec.ttl <= 1)\r\ngoto drop;\r\ndec.ttl -= 1;\r\nnew_header_size = mpls_rt_header_size(rt);\r\nmtu = mpls_dev_mtu(out_dev);\r\nif (mpls_pkt_too_big(skb, mtu - new_header_size))\r\ngoto drop;\r\nhh_len = LL_RESERVED_SPACE(out_dev);\r\nif (!out_dev->header_ops)\r\nhh_len = 0;\r\nif (skb_cow(skb, hh_len + new_header_size))\r\ngoto drop;\r\nskb->dev = out_dev;\r\nskb->protocol = htons(ETH_P_MPLS_UC);\r\nif (unlikely(!new_header_size && dec.bos)) {\r\nif (!mpls_egress(rt, skb, dec))\r\ngoto drop;\r\n} else {\r\nbool bos;\r\nint i;\r\nskb_push(skb, new_header_size);\r\nskb_reset_network_header(skb);\r\nhdr = mpls_hdr(skb);\r\nbos = dec.bos;\r\nfor (i = rt->rt_labels - 1; i >= 0; i--) {\r\nhdr[i] = mpls_entry_encode(rt->rt_label[i], dec.ttl, 0, bos);\r\nbos = false;\r\n}\r\n}\r\nerr = neigh_xmit(rt->rt_via_table, out_dev, rt->rt_via, skb);\r\nif (err)\r\nnet_dbg_ratelimited("%s: packet transmission failed: %d\n",\r\n__func__, err);\r\nreturn 0;\r\ndrop:\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nstatic struct mpls_route *mpls_rt_alloc(size_t alen)\r\n{\r\nstruct mpls_route *rt;\r\nrt = kzalloc(sizeof(*rt) + alen, GFP_KERNEL);\r\nif (rt)\r\nrt->rt_via_alen = alen;\r\nreturn rt;\r\n}\r\nstatic void mpls_rt_free(struct mpls_route *rt)\r\n{\r\nif (rt)\r\nkfree_rcu(rt, rt_rcu);\r\n}\r\nstatic void mpls_notify_route(struct net *net, unsigned index,\r\nstruct mpls_route *old, struct mpls_route *new,\r\nconst struct nl_info *info)\r\n{\r\nstruct nlmsghdr *nlh = info ? info->nlh : NULL;\r\nunsigned portid = info ? info->portid : 0;\r\nint event = new ? RTM_NEWROUTE : RTM_DELROUTE;\r\nstruct mpls_route *rt = new ? new : old;\r\nunsigned nlm_flags = (old && new) ? NLM_F_REPLACE : 0;\r\nif (rt && (index >= 16))\r\nrtmsg_lfib(event, index, rt, nlh, net, portid, nlm_flags);\r\n}\r\nstatic void mpls_route_update(struct net *net, unsigned index,\r\nstruct net_device *dev, struct mpls_route *new,\r\nconst struct nl_info *info)\r\n{\r\nstruct mpls_route __rcu **platform_label;\r\nstruct mpls_route *rt, *old = NULL;\r\nASSERT_RTNL();\r\nplatform_label = rtnl_dereference(net->mpls.platform_label);\r\nrt = rtnl_dereference(platform_label[index]);\r\nif (!dev || (rt && (rtnl_dereference(rt->rt_dev) == dev))) {\r\nrcu_assign_pointer(platform_label[index], new);\r\nold = rt;\r\n}\r\nmpls_notify_route(net, index, old, new, info);\r\nmpls_rt_free(old);\r\n}\r\nstatic unsigned find_free_label(struct net *net)\r\n{\r\nstruct mpls_route __rcu **platform_label;\r\nsize_t platform_labels;\r\nunsigned index;\r\nplatform_label = rtnl_dereference(net->mpls.platform_label);\r\nplatform_labels = net->mpls.platform_labels;\r\nfor (index = 16; index < platform_labels; index++) {\r\nif (!rtnl_dereference(platform_label[index]))\r\nreturn index;\r\n}\r\nreturn LABEL_NOT_SPECIFIED;\r\n}\r\nstatic int mpls_route_add(struct mpls_route_config *cfg)\r\n{\r\nstruct mpls_route __rcu **platform_label;\r\nstruct net *net = cfg->rc_nlinfo.nl_net;\r\nstruct net_device *dev = NULL;\r\nstruct mpls_route *rt, *old;\r\nunsigned index;\r\nint i;\r\nint err = -EINVAL;\r\nindex = cfg->rc_label;\r\nif ((index == LABEL_NOT_SPECIFIED) &&\r\n(cfg->rc_nlflags & NLM_F_CREATE)) {\r\nindex = find_free_label(net);\r\n}\r\nif (index < 16)\r\ngoto errout;\r\nif (index >= net->mpls.platform_labels)\r\ngoto errout;\r\nif (cfg->rc_output_labels > MAX_NEW_LABELS)\r\ngoto errout;\r\nerr = -ENODEV;\r\ndev = dev_get_by_index(net, cfg->rc_ifindex);\r\nif (!dev)\r\ngoto errout;\r\nerr = -EINVAL;\r\nif (!mpls_dev_get(dev))\r\ngoto errout;\r\nerr = -EINVAL;\r\nif ((cfg->rc_via_table == NEIGH_LINK_TABLE) &&\r\n(dev->addr_len != cfg->rc_via_alen))\r\ngoto errout;\r\nerr = -EOPNOTSUPP;\r\nif (cfg->rc_nlflags & NLM_F_APPEND)\r\ngoto errout;\r\nerr = -EEXIST;\r\nplatform_label = rtnl_dereference(net->mpls.platform_label);\r\nold = rtnl_dereference(platform_label[index]);\r\nif ((cfg->rc_nlflags & NLM_F_EXCL) && old)\r\ngoto errout;\r\nerr = -EEXIST;\r\nif (!(cfg->rc_nlflags & NLM_F_REPLACE) && old)\r\ngoto errout;\r\nerr = -ENOENT;\r\nif (!(cfg->rc_nlflags & NLM_F_CREATE) && !old)\r\ngoto errout;\r\nerr = -ENOMEM;\r\nrt = mpls_rt_alloc(cfg->rc_via_alen);\r\nif (!rt)\r\ngoto errout;\r\nrt->rt_labels = cfg->rc_output_labels;\r\nfor (i = 0; i < rt->rt_labels; i++)\r\nrt->rt_label[i] = cfg->rc_output_label[i];\r\nrt->rt_protocol = cfg->rc_protocol;\r\nRCU_INIT_POINTER(rt->rt_dev, dev);\r\nrt->rt_via_table = cfg->rc_via_table;\r\nmemcpy(rt->rt_via, cfg->rc_via, cfg->rc_via_alen);\r\nmpls_route_update(net, index, NULL, rt, &cfg->rc_nlinfo);\r\ndev_put(dev);\r\nreturn 0;\r\nerrout:\r\nif (dev)\r\ndev_put(dev);\r\nreturn err;\r\n}\r\nstatic int mpls_route_del(struct mpls_route_config *cfg)\r\n{\r\nstruct net *net = cfg->rc_nlinfo.nl_net;\r\nunsigned index;\r\nint err = -EINVAL;\r\nindex = cfg->rc_label;\r\nif (index < 16)\r\ngoto errout;\r\nif (index >= net->mpls.platform_labels)\r\ngoto errout;\r\nmpls_route_update(net, index, NULL, NULL, &cfg->rc_nlinfo);\r\nerr = 0;\r\nerrout:\r\nreturn err;\r\n}\r\nstatic int mpls_dev_sysctl_register(struct net_device *dev,\r\nstruct mpls_dev *mdev)\r\n{\r\nchar path[sizeof("net/mpls/conf/") + IFNAMSIZ];\r\nstruct ctl_table *table;\r\nint i;\r\ntable = kmemdup(&mpls_dev_table, sizeof(mpls_dev_table), GFP_KERNEL);\r\nif (!table)\r\ngoto out;\r\nfor (i = 0; i < ARRAY_SIZE(mpls_dev_table); i++)\r\ntable[i].data = (char *)mdev + (uintptr_t)table[i].data;\r\nsnprintf(path, sizeof(path), "net/mpls/conf/%s", dev->name);\r\nmdev->sysctl = register_net_sysctl(dev_net(dev), path, table);\r\nif (!mdev->sysctl)\r\ngoto free;\r\nreturn 0;\r\nfree:\r\nkfree(table);\r\nout:\r\nreturn -ENOBUFS;\r\n}\r\nstatic void mpls_dev_sysctl_unregister(struct mpls_dev *mdev)\r\n{\r\nstruct ctl_table *table;\r\ntable = mdev->sysctl->ctl_table_arg;\r\nunregister_net_sysctl_table(mdev->sysctl);\r\nkfree(table);\r\n}\r\nstatic struct mpls_dev *mpls_add_dev(struct net_device *dev)\r\n{\r\nstruct mpls_dev *mdev;\r\nint err = -ENOMEM;\r\nASSERT_RTNL();\r\nmdev = kzalloc(sizeof(*mdev), GFP_KERNEL);\r\nif (!mdev)\r\nreturn ERR_PTR(err);\r\nerr = mpls_dev_sysctl_register(dev, mdev);\r\nif (err)\r\ngoto free;\r\nrcu_assign_pointer(dev->mpls_ptr, mdev);\r\nreturn mdev;\r\nfree:\r\nkfree(mdev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void mpls_ifdown(struct net_device *dev)\r\n{\r\nstruct mpls_route __rcu **platform_label;\r\nstruct net *net = dev_net(dev);\r\nstruct mpls_dev *mdev;\r\nunsigned index;\r\nplatform_label = rtnl_dereference(net->mpls.platform_label);\r\nfor (index = 0; index < net->mpls.platform_labels; index++) {\r\nstruct mpls_route *rt = rtnl_dereference(platform_label[index]);\r\nif (!rt)\r\ncontinue;\r\nif (rtnl_dereference(rt->rt_dev) != dev)\r\ncontinue;\r\nrt->rt_dev = NULL;\r\n}\r\nmdev = mpls_dev_get(dev);\r\nif (!mdev)\r\nreturn;\r\nmpls_dev_sysctl_unregister(mdev);\r\nRCU_INIT_POINTER(dev->mpls_ptr, NULL);\r\nkfree_rcu(mdev, rcu);\r\n}\r\nstatic int mpls_dev_notify(struct notifier_block *this, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct mpls_dev *mdev;\r\nswitch(event) {\r\ncase NETDEV_REGISTER:\r\nif ((dev->type == ARPHRD_ETHER) ||\r\n(dev->type == ARPHRD_LOOPBACK)) {\r\nmdev = mpls_add_dev(dev);\r\nif (IS_ERR(mdev))\r\nreturn notifier_from_errno(PTR_ERR(mdev));\r\n}\r\nbreak;\r\ncase NETDEV_UNREGISTER:\r\nmpls_ifdown(dev);\r\nbreak;\r\ncase NETDEV_CHANGENAME:\r\nmdev = mpls_dev_get(dev);\r\nif (mdev) {\r\nint err;\r\nmpls_dev_sysctl_unregister(mdev);\r\nerr = mpls_dev_sysctl_register(dev, mdev);\r\nif (err)\r\nreturn notifier_from_errno(err);\r\n}\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int nla_put_via(struct sk_buff *skb,\r\nu8 table, const void *addr, int alen)\r\n{\r\nstatic const int table_to_family[NEIGH_NR_TABLES + 1] = {\r\nAF_INET, AF_INET6, AF_DECnet, AF_PACKET,\r\n};\r\nstruct nlattr *nla;\r\nstruct rtvia *via;\r\nint family = AF_UNSPEC;\r\nnla = nla_reserve(skb, RTA_VIA, alen + 2);\r\nif (!nla)\r\nreturn -EMSGSIZE;\r\nif (table <= NEIGH_NR_TABLES)\r\nfamily = table_to_family[table];\r\nvia = nla_data(nla);\r\nvia->rtvia_family = family;\r\nmemcpy(via->rtvia_addr, addr, alen);\r\nreturn 0;\r\n}\r\nint nla_put_labels(struct sk_buff *skb, int attrtype,\r\nu8 labels, const u32 label[])\r\n{\r\nstruct nlattr *nla;\r\nstruct mpls_shim_hdr *nla_label;\r\nbool bos;\r\nint i;\r\nnla = nla_reserve(skb, attrtype, labels*4);\r\nif (!nla)\r\nreturn -EMSGSIZE;\r\nnla_label = nla_data(nla);\r\nbos = true;\r\nfor (i = labels - 1; i >= 0; i--) {\r\nnla_label[i] = mpls_entry_encode(label[i], 0, 0, bos);\r\nbos = false;\r\n}\r\nreturn 0;\r\n}\r\nint nla_get_labels(const struct nlattr *nla,\r\nu32 max_labels, u32 *labels, u32 label[])\r\n{\r\nunsigned len = nla_len(nla);\r\nunsigned nla_labels;\r\nstruct mpls_shim_hdr *nla_label;\r\nbool bos;\r\nint i;\r\nif (len & 3)\r\nreturn -EINVAL;\r\nnla_labels = len/4;\r\nif (nla_labels > max_labels)\r\nreturn -EINVAL;\r\nnla_label = nla_data(nla);\r\nbos = true;\r\nfor (i = nla_labels - 1; i >= 0; i--, bos = false) {\r\nstruct mpls_entry_decoded dec;\r\ndec = mpls_entry_decode(nla_label + i);\r\nif ((dec.bos != bos) || dec.ttl || dec.tc)\r\nreturn -EINVAL;\r\nswitch (dec.label) {\r\ncase MPLS_LABEL_IMPLNULL:\r\nreturn -EINVAL;\r\n}\r\nlabel[i] = dec.label;\r\n}\r\n*labels = nla_labels;\r\nreturn 0;\r\n}\r\nstatic int rtm_to_route_config(struct sk_buff *skb, struct nlmsghdr *nlh,\r\nstruct mpls_route_config *cfg)\r\n{\r\nstruct rtmsg *rtm;\r\nstruct nlattr *tb[RTA_MAX+1];\r\nint index;\r\nint err;\r\nerr = nlmsg_parse(nlh, sizeof(*rtm), tb, RTA_MAX, rtm_mpls_policy);\r\nif (err < 0)\r\ngoto errout;\r\nerr = -EINVAL;\r\nrtm = nlmsg_data(nlh);\r\nmemset(cfg, 0, sizeof(*cfg));\r\nif (rtm->rtm_family != AF_MPLS)\r\ngoto errout;\r\nif (rtm->rtm_dst_len != 20)\r\ngoto errout;\r\nif (rtm->rtm_src_len != 0)\r\ngoto errout;\r\nif (rtm->rtm_tos != 0)\r\ngoto errout;\r\nif (rtm->rtm_table != RT_TABLE_MAIN)\r\ngoto errout;\r\nif (rtm->rtm_scope != RT_SCOPE_UNIVERSE)\r\ngoto errout;\r\nif (rtm->rtm_type != RTN_UNICAST)\r\ngoto errout;\r\nif (rtm->rtm_flags != 0)\r\ngoto errout;\r\ncfg->rc_label = LABEL_NOT_SPECIFIED;\r\ncfg->rc_protocol = rtm->rtm_protocol;\r\ncfg->rc_nlflags = nlh->nlmsg_flags;\r\ncfg->rc_nlinfo.portid = NETLINK_CB(skb).portid;\r\ncfg->rc_nlinfo.nlh = nlh;\r\ncfg->rc_nlinfo.nl_net = sock_net(skb->sk);\r\nfor (index = 0; index <= RTA_MAX; index++) {\r\nstruct nlattr *nla = tb[index];\r\nif (!nla)\r\ncontinue;\r\nswitch(index) {\r\ncase RTA_OIF:\r\ncfg->rc_ifindex = nla_get_u32(nla);\r\nbreak;\r\ncase RTA_NEWDST:\r\nif (nla_get_labels(nla, MAX_NEW_LABELS,\r\n&cfg->rc_output_labels,\r\ncfg->rc_output_label))\r\ngoto errout;\r\nbreak;\r\ncase RTA_DST:\r\n{\r\nu32 label_count;\r\nif (nla_get_labels(nla, 1, &label_count,\r\n&cfg->rc_label))\r\ngoto errout;\r\nif (cfg->rc_label < 16)\r\ngoto errout;\r\nbreak;\r\n}\r\ncase RTA_VIA:\r\n{\r\nstruct rtvia *via = nla_data(nla);\r\nif (nla_len(nla) < offsetof(struct rtvia, rtvia_addr))\r\ngoto errout;\r\ncfg->rc_via_alen = nla_len(nla) -\r\noffsetof(struct rtvia, rtvia_addr);\r\nif (cfg->rc_via_alen > MAX_VIA_ALEN)\r\ngoto errout;\r\nswitch(via->rtvia_family) {\r\ncase AF_PACKET:\r\ncfg->rc_via_table = NEIGH_LINK_TABLE;\r\nbreak;\r\ncase AF_INET:\r\ncfg->rc_via_table = NEIGH_ARP_TABLE;\r\nif (cfg->rc_via_alen != 4)\r\ngoto errout;\r\nbreak;\r\ncase AF_INET6:\r\ncfg->rc_via_table = NEIGH_ND_TABLE;\r\nif (cfg->rc_via_alen != 16)\r\ngoto errout;\r\nbreak;\r\ndefault:\r\ngoto errout;\r\n}\r\nmemcpy(cfg->rc_via, via->rtvia_addr, cfg->rc_via_alen);\r\nbreak;\r\n}\r\ndefault:\r\ngoto errout;\r\n}\r\n}\r\nerr = 0;\r\nerrout:\r\nreturn err;\r\n}\r\nstatic int mpls_rtm_delroute(struct sk_buff *skb, struct nlmsghdr *nlh)\r\n{\r\nstruct mpls_route_config cfg;\r\nint err;\r\nerr = rtm_to_route_config(skb, nlh, &cfg);\r\nif (err < 0)\r\nreturn err;\r\nreturn mpls_route_del(&cfg);\r\n}\r\nstatic int mpls_rtm_newroute(struct sk_buff *skb, struct nlmsghdr *nlh)\r\n{\r\nstruct mpls_route_config cfg;\r\nint err;\r\nerr = rtm_to_route_config(skb, nlh, &cfg);\r\nif (err < 0)\r\nreturn err;\r\nreturn mpls_route_add(&cfg);\r\n}\r\nstatic int mpls_dump_route(struct sk_buff *skb, u32 portid, u32 seq, int event,\r\nu32 label, struct mpls_route *rt, int flags)\r\n{\r\nstruct net_device *dev;\r\nstruct nlmsghdr *nlh;\r\nstruct rtmsg *rtm;\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(*rtm), flags);\r\nif (nlh == NULL)\r\nreturn -EMSGSIZE;\r\nrtm = nlmsg_data(nlh);\r\nrtm->rtm_family = AF_MPLS;\r\nrtm->rtm_dst_len = 20;\r\nrtm->rtm_src_len = 0;\r\nrtm->rtm_tos = 0;\r\nrtm->rtm_table = RT_TABLE_MAIN;\r\nrtm->rtm_protocol = rt->rt_protocol;\r\nrtm->rtm_scope = RT_SCOPE_UNIVERSE;\r\nrtm->rtm_type = RTN_UNICAST;\r\nrtm->rtm_flags = 0;\r\nif (rt->rt_labels &&\r\nnla_put_labels(skb, RTA_NEWDST, rt->rt_labels, rt->rt_label))\r\ngoto nla_put_failure;\r\nif (nla_put_via(skb, rt->rt_via_table, rt->rt_via, rt->rt_via_alen))\r\ngoto nla_put_failure;\r\ndev = rtnl_dereference(rt->rt_dev);\r\nif (dev && nla_put_u32(skb, RTA_OIF, dev->ifindex))\r\ngoto nla_put_failure;\r\nif (nla_put_labels(skb, RTA_DST, 1, &label))\r\ngoto nla_put_failure;\r\nnlmsg_end(skb, nlh);\r\nreturn 0;\r\nnla_put_failure:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int mpls_dump_routes(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct mpls_route __rcu **platform_label;\r\nsize_t platform_labels;\r\nunsigned int index;\r\nASSERT_RTNL();\r\nindex = cb->args[0];\r\nif (index < 16)\r\nindex = 16;\r\nplatform_label = rtnl_dereference(net->mpls.platform_label);\r\nplatform_labels = net->mpls.platform_labels;\r\nfor (; index < platform_labels; index++) {\r\nstruct mpls_route *rt;\r\nrt = rtnl_dereference(platform_label[index]);\r\nif (!rt)\r\ncontinue;\r\nif (mpls_dump_route(skb, NETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, RTM_NEWROUTE,\r\nindex, rt, NLM_F_MULTI) < 0)\r\nbreak;\r\n}\r\ncb->args[0] = index;\r\nreturn skb->len;\r\n}\r\nstatic inline size_t lfib_nlmsg_size(struct mpls_route *rt)\r\n{\r\nsize_t payload =\r\nNLMSG_ALIGN(sizeof(struct rtmsg))\r\n+ nla_total_size(2 + rt->rt_via_alen)\r\n+ nla_total_size(4);\r\nif (rt->rt_labels)\r\npayload += nla_total_size(rt->rt_labels * 4);\r\nif (rt->rt_dev)\r\npayload += nla_total_size(4);\r\nreturn payload;\r\n}\r\nstatic void rtmsg_lfib(int event, u32 label, struct mpls_route *rt,\r\nstruct nlmsghdr *nlh, struct net *net, u32 portid,\r\nunsigned int nlm_flags)\r\n{\r\nstruct sk_buff *skb;\r\nu32 seq = nlh ? nlh->nlmsg_seq : 0;\r\nint err = -ENOBUFS;\r\nskb = nlmsg_new(lfib_nlmsg_size(rt), GFP_KERNEL);\r\nif (skb == NULL)\r\ngoto errout;\r\nerr = mpls_dump_route(skb, portid, seq, event, label, rt, nlm_flags);\r\nif (err < 0) {\r\nWARN_ON(err == -EMSGSIZE);\r\nkfree_skb(skb);\r\ngoto errout;\r\n}\r\nrtnl_notify(skb, net, portid, RTNLGRP_MPLS_ROUTE, nlh, GFP_KERNEL);\r\nreturn;\r\nerrout:\r\nif (err < 0)\r\nrtnl_set_sk_err(net, RTNLGRP_MPLS_ROUTE, err);\r\n}\r\nstatic int resize_platform_label_table(struct net *net, size_t limit)\r\n{\r\nsize_t size = sizeof(struct mpls_route *) * limit;\r\nsize_t old_limit;\r\nsize_t cp_size;\r\nstruct mpls_route __rcu **labels = NULL, **old;\r\nstruct mpls_route *rt0 = NULL, *rt2 = NULL;\r\nunsigned index;\r\nif (size) {\r\nlabels = kzalloc(size, GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\r\nif (!labels)\r\nlabels = vzalloc(size);\r\nif (!labels)\r\ngoto nolabels;\r\n}\r\nif (limit > MPLS_LABEL_IPV4NULL) {\r\nstruct net_device *lo = net->loopback_dev;\r\nrt0 = mpls_rt_alloc(lo->addr_len);\r\nif (!rt0)\r\ngoto nort0;\r\nRCU_INIT_POINTER(rt0->rt_dev, lo);\r\nrt0->rt_protocol = RTPROT_KERNEL;\r\nrt0->rt_via_table = NEIGH_LINK_TABLE;\r\nmemcpy(rt0->rt_via, lo->dev_addr, lo->addr_len);\r\n}\r\nif (limit > MPLS_LABEL_IPV6NULL) {\r\nstruct net_device *lo = net->loopback_dev;\r\nrt2 = mpls_rt_alloc(lo->addr_len);\r\nif (!rt2)\r\ngoto nort2;\r\nRCU_INIT_POINTER(rt2->rt_dev, lo);\r\nrt2->rt_protocol = RTPROT_KERNEL;\r\nrt2->rt_via_table = NEIGH_LINK_TABLE;\r\nmemcpy(rt2->rt_via, lo->dev_addr, lo->addr_len);\r\n}\r\nrtnl_lock();\r\nold = rtnl_dereference(net->mpls.platform_label);\r\nold_limit = net->mpls.platform_labels;\r\nfor (index = limit; index < old_limit; index++)\r\nmpls_route_update(net, index, NULL, NULL, NULL);\r\ncp_size = size;\r\nif (old_limit < limit)\r\ncp_size = old_limit * sizeof(struct mpls_route *);\r\nmemcpy(labels, old, cp_size);\r\nif ((old_limit <= MPLS_LABEL_IPV6NULL) &&\r\n(limit > MPLS_LABEL_IPV6NULL)) {\r\nRCU_INIT_POINTER(labels[MPLS_LABEL_IPV6NULL], rt2);\r\nrt2 = NULL;\r\n}\r\nif ((old_limit <= MPLS_LABEL_IPV4NULL) &&\r\n(limit > MPLS_LABEL_IPV4NULL)) {\r\nRCU_INIT_POINTER(labels[MPLS_LABEL_IPV4NULL], rt0);\r\nrt0 = NULL;\r\n}\r\nnet->mpls.platform_labels = limit;\r\nrcu_assign_pointer(net->mpls.platform_label, labels);\r\nrtnl_unlock();\r\nmpls_rt_free(rt2);\r\nmpls_rt_free(rt0);\r\nif (old) {\r\nsynchronize_rcu();\r\nkvfree(old);\r\n}\r\nreturn 0;\r\nnort2:\r\nmpls_rt_free(rt0);\r\nnort0:\r\nkvfree(labels);\r\nnolabels:\r\nreturn -ENOMEM;\r\n}\r\nstatic int mpls_platform_labels(struct ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nstruct net *net = table->data;\r\nint platform_labels = net->mpls.platform_labels;\r\nint ret;\r\nstruct ctl_table tmp = {\r\n.procname = table->procname,\r\n.data = &platform_labels,\r\n.maxlen = sizeof(int),\r\n.mode = table->mode,\r\n.extra1 = &zero,\r\n.extra2 = &label_limit,\r\n};\r\nret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);\r\nif (write && ret == 0)\r\nret = resize_platform_label_table(net, platform_labels);\r\nreturn ret;\r\n}\r\nstatic int mpls_net_init(struct net *net)\r\n{\r\nstruct ctl_table *table;\r\nnet->mpls.platform_labels = 0;\r\nnet->mpls.platform_label = NULL;\r\ntable = kmemdup(mpls_table, sizeof(mpls_table), GFP_KERNEL);\r\nif (table == NULL)\r\nreturn -ENOMEM;\r\ntable[0].data = net;\r\nnet->mpls.ctl = register_net_sysctl(net, "net/mpls", table);\r\nif (net->mpls.ctl == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void mpls_net_exit(struct net *net)\r\n{\r\nstruct mpls_route __rcu **platform_label;\r\nsize_t platform_labels;\r\nstruct ctl_table *table;\r\nunsigned int index;\r\ntable = net->mpls.ctl->ctl_table_arg;\r\nunregister_net_sysctl_table(net->mpls.ctl);\r\nkfree(table);\r\nrtnl_lock();\r\nplatform_label = rtnl_dereference(net->mpls.platform_label);\r\nplatform_labels = net->mpls.platform_labels;\r\nfor (index = 0; index < platform_labels; index++) {\r\nstruct mpls_route *rt = rtnl_dereference(platform_label[index]);\r\nRCU_INIT_POINTER(platform_label[index], NULL);\r\nmpls_rt_free(rt);\r\n}\r\nrtnl_unlock();\r\nkvfree(platform_label);\r\n}\r\nstatic int __init mpls_init(void)\r\n{\r\nint err;\r\nBUILD_BUG_ON(sizeof(struct mpls_shim_hdr) != 4);\r\nerr = register_pernet_subsys(&mpls_net_ops);\r\nif (err)\r\ngoto out;\r\nerr = register_netdevice_notifier(&mpls_dev_notifier);\r\nif (err)\r\ngoto out_unregister_pernet;\r\ndev_add_pack(&mpls_packet_type);\r\nrtnl_register(PF_MPLS, RTM_NEWROUTE, mpls_rtm_newroute, NULL, NULL);\r\nrtnl_register(PF_MPLS, RTM_DELROUTE, mpls_rtm_delroute, NULL, NULL);\r\nrtnl_register(PF_MPLS, RTM_GETROUTE, NULL, mpls_dump_routes, NULL);\r\nerr = 0;\r\nout:\r\nreturn err;\r\nout_unregister_pernet:\r\nunregister_pernet_subsys(&mpls_net_ops);\r\ngoto out;\r\n}\r\nstatic void __exit mpls_exit(void)\r\n{\r\nrtnl_unregister_all(PF_MPLS);\r\ndev_remove_pack(&mpls_packet_type);\r\nunregister_netdevice_notifier(&mpls_dev_notifier);\r\nunregister_pernet_subsys(&mpls_net_ops);\r\n}
