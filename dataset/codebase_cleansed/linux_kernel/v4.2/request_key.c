void complete_request_key(struct key_construction *cons, int error)\r\n{\r\nkenter("{%d,%d},%d", cons->key->serial, cons->authkey->serial, error);\r\nif (error < 0)\r\nkey_negate_and_link(cons->key, key_negative_timeout, NULL,\r\ncons->authkey);\r\nelse\r\nkey_revoke(cons->authkey);\r\nkey_put(cons->key);\r\nkey_put(cons->authkey);\r\nkfree(cons);\r\n}\r\nstatic int umh_keys_init(struct subprocess_info *info, struct cred *cred)\r\n{\r\nstruct key *keyring = info->data;\r\nreturn install_session_keyring_to_cred(cred, keyring);\r\n}\r\nstatic void umh_keys_cleanup(struct subprocess_info *info)\r\n{\r\nstruct key *keyring = info->data;\r\nkey_put(keyring);\r\n}\r\nstatic int call_usermodehelper_keys(char *path, char **argv, char **envp,\r\nstruct key *session_keyring, int wait)\r\n{\r\nstruct subprocess_info *info;\r\ninfo = call_usermodehelper_setup(path, argv, envp, GFP_KERNEL,\r\numh_keys_init, umh_keys_cleanup,\r\nsession_keyring);\r\nif (!info)\r\nreturn -ENOMEM;\r\nkey_get(session_keyring);\r\nreturn call_usermodehelper_exec(info, wait);\r\n}\r\nstatic int call_sbin_request_key(struct key_construction *cons,\r\nconst char *op,\r\nvoid *aux)\r\n{\r\nconst struct cred *cred = current_cred();\r\nkey_serial_t prkey, sskey;\r\nstruct key *key = cons->key, *authkey = cons->authkey, *keyring,\r\n*session;\r\nchar *argv[9], *envp[3], uid_str[12], gid_str[12];\r\nchar key_str[12], keyring_str[3][12];\r\nchar desc[20];\r\nint ret, i;\r\nkenter("{%d},{%d},%s", key->serial, authkey->serial, op);\r\nret = install_user_keyrings();\r\nif (ret < 0)\r\ngoto error_alloc;\r\nsprintf(desc, "_req.%u", key->serial);\r\ncred = get_current_cred();\r\nkeyring = keyring_alloc(desc, cred->fsuid, cred->fsgid, cred,\r\nKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ,\r\nKEY_ALLOC_QUOTA_OVERRUN, NULL);\r\nput_cred(cred);\r\nif (IS_ERR(keyring)) {\r\nret = PTR_ERR(keyring);\r\ngoto error_alloc;\r\n}\r\nret = key_link(keyring, authkey);\r\nif (ret < 0)\r\ngoto error_link;\r\nsprintf(uid_str, "%d", from_kuid(&init_user_ns, cred->fsuid));\r\nsprintf(gid_str, "%d", from_kgid(&init_user_ns, cred->fsgid));\r\nsprintf(key_str, "%d", key->serial);\r\nsprintf(keyring_str[0], "%d",\r\ncred->thread_keyring ? cred->thread_keyring->serial : 0);\r\nprkey = 0;\r\nif (cred->process_keyring)\r\nprkey = cred->process_keyring->serial;\r\nsprintf(keyring_str[1], "%d", prkey);\r\nrcu_read_lock();\r\nsession = rcu_dereference(cred->session_keyring);\r\nif (!session)\r\nsession = cred->user->session_keyring;\r\nsskey = session->serial;\r\nrcu_read_unlock();\r\nsprintf(keyring_str[2], "%d", sskey);\r\ni = 0;\r\nenvp[i++] = "HOME=/";\r\nenvp[i++] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";\r\nenvp[i] = NULL;\r\ni = 0;\r\nargv[i++] = "/sbin/request-key";\r\nargv[i++] = (char *) op;\r\nargv[i++] = key_str;\r\nargv[i++] = uid_str;\r\nargv[i++] = gid_str;\r\nargv[i++] = keyring_str[0];\r\nargv[i++] = keyring_str[1];\r\nargv[i++] = keyring_str[2];\r\nargv[i] = NULL;\r\nret = call_usermodehelper_keys(argv[0], argv, envp, keyring,\r\nUMH_WAIT_PROC);\r\nkdebug("usermode -> 0x%x", ret);\r\nif (ret >= 0) {\r\nif (test_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags) ||\r\nkey_validate(key) < 0)\r\nret = -ENOKEY;\r\nelse\r\nret = 0;\r\n}\r\nerror_link:\r\nkey_put(keyring);\r\nerror_alloc:\r\ncomplete_request_key(cons, ret);\r\nkleave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstatic int construct_key(struct key *key, const void *callout_info,\r\nsize_t callout_len, void *aux,\r\nstruct key *dest_keyring)\r\n{\r\nstruct key_construction *cons;\r\nrequest_key_actor_t actor;\r\nstruct key *authkey;\r\nint ret;\r\nkenter("%d,%p,%zu,%p", key->serial, callout_info, callout_len, aux);\r\ncons = kmalloc(sizeof(*cons), GFP_KERNEL);\r\nif (!cons)\r\nreturn -ENOMEM;\r\nauthkey = request_key_auth_new(key, callout_info, callout_len,\r\ndest_keyring);\r\nif (IS_ERR(authkey)) {\r\nkfree(cons);\r\nret = PTR_ERR(authkey);\r\nauthkey = NULL;\r\n} else {\r\ncons->authkey = key_get(authkey);\r\ncons->key = key_get(key);\r\nactor = call_sbin_request_key;\r\nif (key->type->request_key)\r\nactor = key->type->request_key;\r\nret = actor(cons, "create", aux);\r\nWARN_ON(ret < 0 &&\r\n!test_bit(KEY_FLAG_REVOKED, &authkey->flags));\r\nkey_put(authkey);\r\n}\r\nkleave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstatic void construct_get_dest_keyring(struct key **_dest_keyring)\r\n{\r\nstruct request_key_auth *rka;\r\nconst struct cred *cred = current_cred();\r\nstruct key *dest_keyring = *_dest_keyring, *authkey;\r\nkenter("%p", dest_keyring);\r\nif (dest_keyring) {\r\nkey_get(dest_keyring);\r\n} else {\r\nswitch (cred->jit_keyring) {\r\ncase KEY_REQKEY_DEFL_DEFAULT:\r\ncase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\r\nif (cred->request_key_auth) {\r\nauthkey = cred->request_key_auth;\r\ndown_read(&authkey->sem);\r\nrka = authkey->payload.data;\r\nif (!test_bit(KEY_FLAG_REVOKED,\r\n&authkey->flags))\r\ndest_keyring =\r\nkey_get(rka->dest_keyring);\r\nup_read(&authkey->sem);\r\nif (dest_keyring)\r\nbreak;\r\n}\r\ncase KEY_REQKEY_DEFL_THREAD_KEYRING:\r\ndest_keyring = key_get(cred->thread_keyring);\r\nif (dest_keyring)\r\nbreak;\r\ncase KEY_REQKEY_DEFL_PROCESS_KEYRING:\r\ndest_keyring = key_get(cred->process_keyring);\r\nif (dest_keyring)\r\nbreak;\r\ncase KEY_REQKEY_DEFL_SESSION_KEYRING:\r\nrcu_read_lock();\r\ndest_keyring = key_get(\r\nrcu_dereference(cred->session_keyring));\r\nrcu_read_unlock();\r\nif (dest_keyring)\r\nbreak;\r\ncase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\r\ndest_keyring =\r\nkey_get(cred->user->session_keyring);\r\nbreak;\r\ncase KEY_REQKEY_DEFL_USER_KEYRING:\r\ndest_keyring = key_get(cred->user->uid_keyring);\r\nbreak;\r\ncase KEY_REQKEY_DEFL_GROUP_KEYRING:\r\ndefault:\r\nBUG();\r\n}\r\n}\r\n*_dest_keyring = dest_keyring;\r\nkleave(" [dk %d]", key_serial(dest_keyring));\r\nreturn;\r\n}\r\nstatic int construct_alloc_key(struct keyring_search_context *ctx,\r\nstruct key *dest_keyring,\r\nunsigned long flags,\r\nstruct key_user *user,\r\nstruct key **_key)\r\n{\r\nstruct assoc_array_edit *edit;\r\nstruct key *key;\r\nkey_perm_t perm;\r\nkey_ref_t key_ref;\r\nint ret;\r\nkenter("%s,%s,,,",\r\nctx->index_key.type->name, ctx->index_key.description);\r\n*_key = NULL;\r\nmutex_lock(&user->cons_lock);\r\nperm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR;\r\nperm |= KEY_USR_VIEW;\r\nif (ctx->index_key.type->read)\r\nperm |= KEY_POS_READ;\r\nif (ctx->index_key.type == &key_type_keyring ||\r\nctx->index_key.type->update)\r\nperm |= KEY_POS_WRITE;\r\nkey = key_alloc(ctx->index_key.type, ctx->index_key.description,\r\nctx->cred->fsuid, ctx->cred->fsgid, ctx->cred,\r\nperm, flags);\r\nif (IS_ERR(key))\r\ngoto alloc_failed;\r\nset_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags);\r\nif (dest_keyring) {\r\nret = __key_link_begin(dest_keyring, &ctx->index_key, &edit);\r\nif (ret < 0)\r\ngoto link_prealloc_failed;\r\n}\r\nmutex_lock(&key_construction_mutex);\r\nkey_ref = search_process_keyrings(ctx);\r\nif (!IS_ERR(key_ref))\r\ngoto key_already_present;\r\nif (dest_keyring)\r\n__key_link(key, &edit);\r\nmutex_unlock(&key_construction_mutex);\r\nif (dest_keyring)\r\n__key_link_end(dest_keyring, &ctx->index_key, edit);\r\nmutex_unlock(&user->cons_lock);\r\n*_key = key;\r\nkleave(" = 0 [%d]", key_serial(key));\r\nreturn 0;\r\nkey_already_present:\r\nkey_put(key);\r\nmutex_unlock(&key_construction_mutex);\r\nkey = key_ref_to_ptr(key_ref);\r\nif (dest_keyring) {\r\nret = __key_link_check_live_key(dest_keyring, key);\r\nif (ret == 0)\r\n__key_link(key, &edit);\r\n__key_link_end(dest_keyring, &ctx->index_key, edit);\r\nif (ret < 0)\r\ngoto link_check_failed;\r\n}\r\nmutex_unlock(&user->cons_lock);\r\n*_key = key;\r\nkleave(" = -EINPROGRESS [%d]", key_serial(key));\r\nreturn -EINPROGRESS;\r\nlink_check_failed:\r\nmutex_unlock(&user->cons_lock);\r\nkey_put(key);\r\nkleave(" = %d [linkcheck]", ret);\r\nreturn ret;\r\nlink_prealloc_failed:\r\nmutex_unlock(&user->cons_lock);\r\nkey_put(key);\r\nkleave(" = %d [prelink]", ret);\r\nreturn ret;\r\nalloc_failed:\r\nmutex_unlock(&user->cons_lock);\r\nkleave(" = %ld", PTR_ERR(key));\r\nreturn PTR_ERR(key);\r\n}\r\nstatic struct key *construct_key_and_link(struct keyring_search_context *ctx,\r\nconst char *callout_info,\r\nsize_t callout_len,\r\nvoid *aux,\r\nstruct key *dest_keyring,\r\nunsigned long flags)\r\n{\r\nstruct key_user *user;\r\nstruct key *key;\r\nint ret;\r\nkenter("");\r\nuser = key_user_lookup(current_fsuid());\r\nif (!user)\r\nreturn ERR_PTR(-ENOMEM);\r\nconstruct_get_dest_keyring(&dest_keyring);\r\nret = construct_alloc_key(ctx, dest_keyring, flags, user, &key);\r\nkey_user_put(user);\r\nif (ret == 0) {\r\nret = construct_key(key, callout_info, callout_len, aux,\r\ndest_keyring);\r\nif (ret < 0) {\r\nkdebug("cons failed");\r\ngoto construction_failed;\r\n}\r\n} else if (ret == -EINPROGRESS) {\r\nret = 0;\r\n} else {\r\ngoto couldnt_alloc_key;\r\n}\r\nkey_put(dest_keyring);\r\nkleave(" = key %d", key_serial(key));\r\nreturn key;\r\nconstruction_failed:\r\nkey_negate_and_link(key, key_negative_timeout, NULL, NULL);\r\nkey_put(key);\r\ncouldnt_alloc_key:\r\nkey_put(dest_keyring);\r\nkleave(" = %d", ret);\r\nreturn ERR_PTR(ret);\r\n}\r\nstruct key *request_key_and_link(struct key_type *type,\r\nconst char *description,\r\nconst void *callout_info,\r\nsize_t callout_len,\r\nvoid *aux,\r\nstruct key *dest_keyring,\r\nunsigned long flags)\r\n{\r\nstruct keyring_search_context ctx = {\r\n.index_key.type = type,\r\n.index_key.description = description,\r\n.cred = current_cred(),\r\n.match_data.cmp = key_default_cmp,\r\n.match_data.raw_data = description,\r\n.match_data.lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT,\r\n.flags = (KEYRING_SEARCH_DO_STATE_CHECK |\r\nKEYRING_SEARCH_SKIP_EXPIRED),\r\n};\r\nstruct key *key;\r\nkey_ref_t key_ref;\r\nint ret;\r\nkenter("%s,%s,%p,%zu,%p,%p,%lx",\r\nctx.index_key.type->name, ctx.index_key.description,\r\ncallout_info, callout_len, aux, dest_keyring, flags);\r\nif (type->match_preparse) {\r\nret = type->match_preparse(&ctx.match_data);\r\nif (ret < 0) {\r\nkey = ERR_PTR(ret);\r\ngoto error;\r\n}\r\n}\r\nkey_ref = search_process_keyrings(&ctx);\r\nif (!IS_ERR(key_ref)) {\r\nkey = key_ref_to_ptr(key_ref);\r\nif (dest_keyring) {\r\nconstruct_get_dest_keyring(&dest_keyring);\r\nret = key_link(dest_keyring, key);\r\nkey_put(dest_keyring);\r\nif (ret < 0) {\r\nkey_put(key);\r\nkey = ERR_PTR(ret);\r\ngoto error_free;\r\n}\r\n}\r\n} else if (PTR_ERR(key_ref) != -EAGAIN) {\r\nkey = ERR_CAST(key_ref);\r\n} else {\r\nkey = ERR_PTR(-ENOKEY);\r\nif (!callout_info)\r\ngoto error_free;\r\nkey = construct_key_and_link(&ctx, callout_info, callout_len,\r\naux, dest_keyring, flags);\r\n}\r\nerror_free:\r\nif (type->match_free)\r\ntype->match_free(&ctx.match_data);\r\nerror:\r\nkleave(" = %p", key);\r\nreturn key;\r\n}\r\nint wait_for_key_construction(struct key *key, bool intr)\r\n{\r\nint ret;\r\nret = wait_on_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT,\r\nintr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\r\nif (ret)\r\nreturn -ERESTARTSYS;\r\nif (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {\r\nsmp_rmb();\r\nreturn key->type_data.reject_error;\r\n}\r\nreturn key_validate(key);\r\n}\r\nstruct key *request_key(struct key_type *type,\r\nconst char *description,\r\nconst char *callout_info)\r\n{\r\nstruct key *key;\r\nsize_t callout_len = 0;\r\nint ret;\r\nif (callout_info)\r\ncallout_len = strlen(callout_info);\r\nkey = request_key_and_link(type, description, callout_info, callout_len,\r\nNULL, NULL, KEY_ALLOC_IN_QUOTA);\r\nif (!IS_ERR(key)) {\r\nret = wait_for_key_construction(key, false);\r\nif (ret < 0) {\r\nkey_put(key);\r\nreturn ERR_PTR(ret);\r\n}\r\n}\r\nreturn key;\r\n}\r\nstruct key *request_key_with_auxdata(struct key_type *type,\r\nconst char *description,\r\nconst void *callout_info,\r\nsize_t callout_len,\r\nvoid *aux)\r\n{\r\nstruct key *key;\r\nint ret;\r\nkey = request_key_and_link(type, description, callout_info, callout_len,\r\naux, NULL, KEY_ALLOC_IN_QUOTA);\r\nif (!IS_ERR(key)) {\r\nret = wait_for_key_construction(key, false);\r\nif (ret < 0) {\r\nkey_put(key);\r\nreturn ERR_PTR(ret);\r\n}\r\n}\r\nreturn key;\r\n}\r\nstruct key *request_key_async(struct key_type *type,\r\nconst char *description,\r\nconst void *callout_info,\r\nsize_t callout_len)\r\n{\r\nreturn request_key_and_link(type, description, callout_info,\r\ncallout_len, NULL, NULL,\r\nKEY_ALLOC_IN_QUOTA);\r\n}\r\nstruct key *request_key_async_with_auxdata(struct key_type *type,\r\nconst char *description,\r\nconst void *callout_info,\r\nsize_t callout_len,\r\nvoid *aux)\r\n{\r\nreturn request_key_and_link(type, description, callout_info,\r\ncallout_len, aux, NULL, KEY_ALLOC_IN_QUOTA);\r\n}
