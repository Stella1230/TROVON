static int khazad_setkey(struct crypto_tfm *tfm, const u8 *in_key,\r\nunsigned int key_len)\r\n{\r\nstruct khazad_ctx *ctx = crypto_tfm_ctx(tfm);\r\nconst __be32 *key = (const __be32 *)in_key;\r\nint r;\r\nconst u64 *S = T7;\r\nu64 K2, K1;\r\nK2 = ((u64)be32_to_cpu(key[0]) << 32) | be32_to_cpu(key[1]);\r\nK1 = ((u64)be32_to_cpu(key[2]) << 32) | be32_to_cpu(key[3]);\r\nfor (r = 0; r <= KHAZAD_ROUNDS; r++) {\r\nctx->E[r] = T0[(int)(K1 >> 56) ] ^\r\nT1[(int)(K1 >> 48) & 0xff] ^\r\nT2[(int)(K1 >> 40) & 0xff] ^\r\nT3[(int)(K1 >> 32) & 0xff] ^\r\nT4[(int)(K1 >> 24) & 0xff] ^\r\nT5[(int)(K1 >> 16) & 0xff] ^\r\nT6[(int)(K1 >> 8) & 0xff] ^\r\nT7[(int)(K1 ) & 0xff] ^\r\nc[r] ^ K2;\r\nK2 = K1;\r\nK1 = ctx->E[r];\r\n}\r\nctx->D[0] = ctx->E[KHAZAD_ROUNDS];\r\nfor (r = 1; r < KHAZAD_ROUNDS; r++) {\r\nK1 = ctx->E[KHAZAD_ROUNDS - r];\r\nctx->D[r] = T0[(int)S[(int)(K1 >> 56) ] & 0xff] ^\r\nT1[(int)S[(int)(K1 >> 48) & 0xff] & 0xff] ^\r\nT2[(int)S[(int)(K1 >> 40) & 0xff] & 0xff] ^\r\nT3[(int)S[(int)(K1 >> 32) & 0xff] & 0xff] ^\r\nT4[(int)S[(int)(K1 >> 24) & 0xff] & 0xff] ^\r\nT5[(int)S[(int)(K1 >> 16) & 0xff] & 0xff] ^\r\nT6[(int)S[(int)(K1 >> 8) & 0xff] & 0xff] ^\r\nT7[(int)S[(int)(K1 ) & 0xff] & 0xff];\r\n}\r\nctx->D[KHAZAD_ROUNDS] = ctx->E[0];\r\nreturn 0;\r\n}\r\nstatic void khazad_crypt(const u64 roundKey[KHAZAD_ROUNDS + 1],\r\nu8 *ciphertext, const u8 *plaintext)\r\n{\r\nconst __be64 *src = (const __be64 *)plaintext;\r\n__be64 *dst = (__be64 *)ciphertext;\r\nint r;\r\nu64 state;\r\nstate = be64_to_cpu(*src) ^ roundKey[0];\r\nfor (r = 1; r < KHAZAD_ROUNDS; r++) {\r\nstate = T0[(int)(state >> 56) ] ^\r\nT1[(int)(state >> 48) & 0xff] ^\r\nT2[(int)(state >> 40) & 0xff] ^\r\nT3[(int)(state >> 32) & 0xff] ^\r\nT4[(int)(state >> 24) & 0xff] ^\r\nT5[(int)(state >> 16) & 0xff] ^\r\nT6[(int)(state >> 8) & 0xff] ^\r\nT7[(int)(state ) & 0xff] ^\r\nroundKey[r];\r\n}\r\nstate = (T0[(int)(state >> 56) ] & 0xff00000000000000ULL) ^\r\n(T1[(int)(state >> 48) & 0xff] & 0x00ff000000000000ULL) ^\r\n(T2[(int)(state >> 40) & 0xff] & 0x0000ff0000000000ULL) ^\r\n(T3[(int)(state >> 32) & 0xff] & 0x000000ff00000000ULL) ^\r\n(T4[(int)(state >> 24) & 0xff] & 0x00000000ff000000ULL) ^\r\n(T5[(int)(state >> 16) & 0xff] & 0x0000000000ff0000ULL) ^\r\n(T6[(int)(state >> 8) & 0xff] & 0x000000000000ff00ULL) ^\r\n(T7[(int)(state ) & 0xff] & 0x00000000000000ffULL) ^\r\nroundKey[KHAZAD_ROUNDS];\r\n*dst = cpu_to_be64(state);\r\n}\r\nstatic void khazad_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\r\n{\r\nstruct khazad_ctx *ctx = crypto_tfm_ctx(tfm);\r\nkhazad_crypt(ctx->E, dst, src);\r\n}\r\nstatic void khazad_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\r\n{\r\nstruct khazad_ctx *ctx = crypto_tfm_ctx(tfm);\r\nkhazad_crypt(ctx->D, dst, src);\r\n}\r\nstatic int __init khazad_mod_init(void)\r\n{\r\nint ret = 0;\r\nret = crypto_register_alg(&khazad_alg);\r\nreturn ret;\r\n}\r\nstatic void __exit khazad_mod_fini(void)\r\n{\r\ncrypto_unregister_alg(&khazad_alg);\r\n}
