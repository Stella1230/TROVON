void\r\nprint_tuple(struct seq_file *s, const struct nf_conntrack_tuple *tuple,\r\nconst struct nf_conntrack_l3proto *l3proto,\r\nconst struct nf_conntrack_l4proto *l4proto)\r\n{\r\nl3proto->print_tuple(s, tuple);\r\nl4proto->print_tuple(s, tuple);\r\n}\r\nstatic struct hlist_nulls_node *ct_get_first(struct seq_file *seq)\r\n{\r\nstruct net *net = seq_file_net(seq);\r\nstruct ct_iter_state *st = seq->private;\r\nstruct hlist_nulls_node *n;\r\nfor (st->bucket = 0;\r\nst->bucket < net->ct.htable_size;\r\nst->bucket++) {\r\nn = rcu_dereference(hlist_nulls_first_rcu(&net->ct.hash[st->bucket]));\r\nif (!is_a_nulls(n))\r\nreturn n;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct hlist_nulls_node *ct_get_next(struct seq_file *seq,\r\nstruct hlist_nulls_node *head)\r\n{\r\nstruct net *net = seq_file_net(seq);\r\nstruct ct_iter_state *st = seq->private;\r\nhead = rcu_dereference(hlist_nulls_next_rcu(head));\r\nwhile (is_a_nulls(head)) {\r\nif (likely(get_nulls_value(head) == st->bucket)) {\r\nif (++st->bucket >= net->ct.htable_size)\r\nreturn NULL;\r\n}\r\nhead = rcu_dereference(\r\nhlist_nulls_first_rcu(\r\n&net->ct.hash[st->bucket]));\r\n}\r\nreturn head;\r\n}\r\nstatic struct hlist_nulls_node *ct_get_idx(struct seq_file *seq, loff_t pos)\r\n{\r\nstruct hlist_nulls_node *head = ct_get_first(seq);\r\nif (head)\r\nwhile (pos && (head = ct_get_next(seq, head)))\r\npos--;\r\nreturn pos ? NULL : head;\r\n}\r\nstatic void *ct_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(RCU)\r\n{\r\nstruct ct_iter_state *st = seq->private;\r\nst->time_now = ktime_get_real_ns();\r\nrcu_read_lock();\r\nreturn ct_get_idx(seq, *pos);\r\n}\r\nstatic void *ct_seq_next(struct seq_file *s, void *v, loff_t *pos)\r\n{\r\n(*pos)++;\r\nreturn ct_get_next(s, v);\r\n}\r\nstatic void ct_seq_stop(struct seq_file *s, void *v)\r\n__releases(RCU)\r\n{\r\nrcu_read_unlock();\r\n}\r\nstatic void ct_show_secctx(struct seq_file *s, const struct nf_conn *ct)\r\n{\r\nint ret;\r\nu32 len;\r\nchar *secctx;\r\nret = security_secid_to_secctx(ct->secmark, &secctx, &len);\r\nif (ret)\r\nreturn;\r\nseq_printf(s, "secctx=%s ", secctx);\r\nsecurity_release_secctx(secctx, len);\r\n}\r\nstatic inline void ct_show_secctx(struct seq_file *s, const struct nf_conn *ct)\r\n{\r\n}\r\nstatic void ct_show_delta_time(struct seq_file *s, const struct nf_conn *ct)\r\n{\r\nstruct ct_iter_state *st = s->private;\r\nstruct nf_conn_tstamp *tstamp;\r\ns64 delta_time;\r\ntstamp = nf_conn_tstamp_find(ct);\r\nif (tstamp) {\r\ndelta_time = st->time_now - tstamp->start;\r\nif (delta_time > 0)\r\ndelta_time = div_s64(delta_time, NSEC_PER_SEC);\r\nelse\r\ndelta_time = 0;\r\nseq_printf(s, "delta-time=%llu ",\r\n(unsigned long long)delta_time);\r\n}\r\nreturn;\r\n}\r\nstatic inline void\r\nct_show_delta_time(struct seq_file *s, const struct nf_conn *ct)\r\n{\r\n}\r\nstatic int ct_seq_show(struct seq_file *s, void *v)\r\n{\r\nstruct nf_conntrack_tuple_hash *hash = v;\r\nstruct nf_conn *ct = nf_ct_tuplehash_to_ctrack(hash);\r\nconst struct nf_conntrack_l3proto *l3proto;\r\nconst struct nf_conntrack_l4proto *l4proto;\r\nint ret = 0;\r\nNF_CT_ASSERT(ct);\r\nif (unlikely(!atomic_inc_not_zero(&ct->ct_general.use)))\r\nreturn 0;\r\nif (NF_CT_DIRECTION(hash))\r\ngoto release;\r\nl3proto = __nf_ct_l3proto_find(nf_ct_l3num(ct));\r\nNF_CT_ASSERT(l3proto);\r\nl4proto = __nf_ct_l4proto_find(nf_ct_l3num(ct), nf_ct_protonum(ct));\r\nNF_CT_ASSERT(l4proto);\r\nret = -ENOSPC;\r\nseq_printf(s, "%-8s %u %-8s %u %ld ",\r\nl3proto->name, nf_ct_l3num(ct),\r\nl4proto->name, nf_ct_protonum(ct),\r\ntimer_pending(&ct->timeout)\r\n? (long)(ct->timeout.expires - jiffies)/HZ : 0);\r\nif (l4proto->print_conntrack)\r\nl4proto->print_conntrack(s, ct);\r\nprint_tuple(s, &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple,\r\nl3proto, l4proto);\r\nif (seq_has_overflowed(s))\r\ngoto release;\r\nif (seq_print_acct(s, ct, IP_CT_DIR_ORIGINAL))\r\ngoto release;\r\nif (!(test_bit(IPS_SEEN_REPLY_BIT, &ct->status)))\r\nseq_printf(s, "[UNREPLIED] ");\r\nprint_tuple(s, &ct->tuplehash[IP_CT_DIR_REPLY].tuple,\r\nl3proto, l4proto);\r\nif (seq_print_acct(s, ct, IP_CT_DIR_REPLY))\r\ngoto release;\r\nif (test_bit(IPS_ASSURED_BIT, &ct->status))\r\nseq_printf(s, "[ASSURED] ");\r\nif (seq_has_overflowed(s))\r\ngoto release;\r\n#if defined(CONFIG_NF_CONNTRACK_MARK)\r\nseq_printf(s, "mark=%u ", ct->mark);\r\n#endif\r\nct_show_secctx(s, ct);\r\n#ifdef CONFIG_NF_CONNTRACK_ZONES\r\nseq_printf(s, "zone=%u ", nf_ct_zone(ct));\r\n#endif\r\nct_show_delta_time(s, ct);\r\nseq_printf(s, "use=%u\n", atomic_read(&ct->ct_general.use));\r\nif (seq_has_overflowed(s))\r\ngoto release;\r\nret = 0;\r\nrelease:\r\nnf_ct_put(ct);\r\nreturn ret;\r\n}\r\nstatic int ct_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &ct_seq_ops,\r\nsizeof(struct ct_iter_state));\r\n}\r\nstatic void *ct_cpu_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nstruct net *net = seq_file_net(seq);\r\nint cpu;\r\nif (*pos == 0)\r\nreturn SEQ_START_TOKEN;\r\nfor (cpu = *pos-1; cpu < nr_cpu_ids; ++cpu) {\r\nif (!cpu_possible(cpu))\r\ncontinue;\r\n*pos = cpu + 1;\r\nreturn per_cpu_ptr(net->ct.stat, cpu);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void *ct_cpu_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct net *net = seq_file_net(seq);\r\nint cpu;\r\nfor (cpu = *pos; cpu < nr_cpu_ids; ++cpu) {\r\nif (!cpu_possible(cpu))\r\ncontinue;\r\n*pos = cpu + 1;\r\nreturn per_cpu_ptr(net->ct.stat, cpu);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void ct_cpu_seq_stop(struct seq_file *seq, void *v)\r\n{\r\n}\r\nstatic int ct_cpu_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct net *net = seq_file_net(seq);\r\nunsigned int nr_conntracks = atomic_read(&net->ct.count);\r\nconst struct ip_conntrack_stat *st = v;\r\nif (v == SEQ_START_TOKEN) {\r\nseq_printf(seq, "entries searched found new invalid ignore delete delete_list insert insert_failed drop early_drop icmp_error expect_new expect_create expect_delete search_restart\n");\r\nreturn 0;\r\n}\r\nseq_printf(seq, "%08x %08x %08x %08x %08x %08x %08x %08x "\r\n"%08x %08x %08x %08x %08x %08x %08x %08x %08x\n",\r\nnr_conntracks,\r\nst->searched,\r\nst->found,\r\nst->new,\r\nst->invalid,\r\nst->ignore,\r\nst->delete,\r\nst->delete_list,\r\nst->insert,\r\nst->insert_failed,\r\nst->drop,\r\nst->early_drop,\r\nst->error,\r\nst->expect_new,\r\nst->expect_create,\r\nst->expect_delete,\r\nst->search_restart\r\n);\r\nreturn 0;\r\n}\r\nstatic int ct_cpu_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &ct_cpu_seq_ops,\r\nsizeof(struct seq_net_private));\r\n}\r\nstatic int nf_conntrack_standalone_init_proc(struct net *net)\r\n{\r\nstruct proc_dir_entry *pde;\r\npde = proc_create("nf_conntrack", 0440, net->proc_net, &ct_file_ops);\r\nif (!pde)\r\ngoto out_nf_conntrack;\r\npde = proc_create("nf_conntrack", S_IRUGO, net->proc_net_stat,\r\n&ct_cpu_seq_fops);\r\nif (!pde)\r\ngoto out_stat_nf_conntrack;\r\nreturn 0;\r\nout_stat_nf_conntrack:\r\nremove_proc_entry("nf_conntrack", net->proc_net);\r\nout_nf_conntrack:\r\nreturn -ENOMEM;\r\n}\r\nstatic void nf_conntrack_standalone_fini_proc(struct net *net)\r\n{\r\nremove_proc_entry("nf_conntrack", net->proc_net_stat);\r\nremove_proc_entry("nf_conntrack", net->proc_net);\r\n}\r\nstatic int nf_conntrack_standalone_init_proc(struct net *net)\r\n{\r\nreturn 0;\r\n}\r\nstatic void nf_conntrack_standalone_fini_proc(struct net *net)\r\n{\r\n}\r\nstatic int nf_conntrack_standalone_init_sysctl(struct net *net)\r\n{\r\nstruct ctl_table *table;\r\ntable = kmemdup(nf_ct_sysctl_table, sizeof(nf_ct_sysctl_table),\r\nGFP_KERNEL);\r\nif (!table)\r\ngoto out_kmemdup;\r\ntable[1].data = &net->ct.count;\r\ntable[2].data = &net->ct.htable_size;\r\ntable[3].data = &net->ct.sysctl_checksum;\r\ntable[4].data = &net->ct.sysctl_log_invalid;\r\nif (net->user_ns != &init_user_ns)\r\ntable[0].procname = NULL;\r\nnet->ct.sysctl_header = register_net_sysctl(net, "net/netfilter", table);\r\nif (!net->ct.sysctl_header)\r\ngoto out_unregister_netfilter;\r\nreturn 0;\r\nout_unregister_netfilter:\r\nkfree(table);\r\nout_kmemdup:\r\nreturn -ENOMEM;\r\n}\r\nstatic void nf_conntrack_standalone_fini_sysctl(struct net *net)\r\n{\r\nstruct ctl_table *table;\r\ntable = net->ct.sysctl_header->ctl_table_arg;\r\nunregister_net_sysctl_table(net->ct.sysctl_header);\r\nkfree(table);\r\n}\r\nstatic int nf_conntrack_standalone_init_sysctl(struct net *net)\r\n{\r\nreturn 0;\r\n}\r\nstatic void nf_conntrack_standalone_fini_sysctl(struct net *net)\r\n{\r\n}\r\nstatic int nf_conntrack_pernet_init(struct net *net)\r\n{\r\nint ret;\r\nret = nf_conntrack_init_net(net);\r\nif (ret < 0)\r\ngoto out_init;\r\nret = nf_conntrack_standalone_init_proc(net);\r\nif (ret < 0)\r\ngoto out_proc;\r\nnet->ct.sysctl_checksum = 1;\r\nnet->ct.sysctl_log_invalid = 0;\r\nret = nf_conntrack_standalone_init_sysctl(net);\r\nif (ret < 0)\r\ngoto out_sysctl;\r\nreturn 0;\r\nout_sysctl:\r\nnf_conntrack_standalone_fini_proc(net);\r\nout_proc:\r\nnf_conntrack_cleanup_net(net);\r\nout_init:\r\nreturn ret;\r\n}\r\nstatic void nf_conntrack_pernet_exit(struct list_head *net_exit_list)\r\n{\r\nstruct net *net;\r\nlist_for_each_entry(net, net_exit_list, exit_list) {\r\nnf_conntrack_standalone_fini_sysctl(net);\r\nnf_conntrack_standalone_fini_proc(net);\r\n}\r\nnf_conntrack_cleanup_net_list(net_exit_list);\r\n}\r\nstatic int __init nf_conntrack_standalone_init(void)\r\n{\r\nint ret = nf_conntrack_init_start();\r\nif (ret < 0)\r\ngoto out_start;\r\n#ifdef CONFIG_SYSCTL\r\nnf_ct_netfilter_header =\r\nregister_net_sysctl(&init_net, "net", nf_ct_netfilter_table);\r\nif (!nf_ct_netfilter_header) {\r\npr_err("nf_conntrack: can't register to sysctl.\n");\r\nret = -ENOMEM;\r\ngoto out_sysctl;\r\n}\r\n#endif\r\nret = register_pernet_subsys(&nf_conntrack_net_ops);\r\nif (ret < 0)\r\ngoto out_pernet;\r\nnf_conntrack_init_end();\r\nreturn 0;\r\nout_pernet:\r\n#ifdef CONFIG_SYSCTL\r\nunregister_net_sysctl_table(nf_ct_netfilter_header);\r\nout_sysctl:\r\n#endif\r\nnf_conntrack_cleanup_end();\r\nout_start:\r\nreturn ret;\r\n}\r\nstatic void __exit nf_conntrack_standalone_fini(void)\r\n{\r\nnf_conntrack_cleanup_start();\r\nunregister_pernet_subsys(&nf_conntrack_net_ops);\r\n#ifdef CONFIG_SYSCTL\r\nunregister_net_sysctl_table(nf_ct_netfilter_header);\r\n#endif\r\nnf_conntrack_cleanup_end();\r\n}\r\nvoid need_conntrack(void)\r\n{\r\n}
