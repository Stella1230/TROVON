static void handle_delayed_timer(unsigned long data)\r\n{\r\nstruct delay_c *dc = (struct delay_c *)data;\r\nqueue_work(dc->kdelayd_wq, &dc->flush_expired_bios);\r\n}\r\nstatic void queue_timeout(struct delay_c *dc, unsigned long expires)\r\n{\r\nmutex_lock(&dc->timer_lock);\r\nif (!timer_pending(&dc->delay_timer) || expires < dc->delay_timer.expires)\r\nmod_timer(&dc->delay_timer, expires);\r\nmutex_unlock(&dc->timer_lock);\r\n}\r\nstatic void flush_bios(struct bio *bio)\r\n{\r\nstruct bio *n;\r\nwhile (bio) {\r\nn = bio->bi_next;\r\nbio->bi_next = NULL;\r\ngeneric_make_request(bio);\r\nbio = n;\r\n}\r\n}\r\nstatic struct bio *flush_delayed_bios(struct delay_c *dc, int flush_all)\r\n{\r\nstruct dm_delay_info *delayed, *next;\r\nunsigned long next_expires = 0;\r\nint start_timer = 0;\r\nstruct bio_list flush_bios = { };\r\nmutex_lock(&delayed_bios_lock);\r\nlist_for_each_entry_safe(delayed, next, &dc->delayed_bios, list) {\r\nif (flush_all || time_after_eq(jiffies, delayed->expires)) {\r\nstruct bio *bio = dm_bio_from_per_bio_data(delayed,\r\nsizeof(struct dm_delay_info));\r\nlist_del(&delayed->list);\r\nbio_list_add(&flush_bios, bio);\r\nif ((bio_data_dir(bio) == WRITE))\r\ndelayed->context->writes--;\r\nelse\r\ndelayed->context->reads--;\r\ncontinue;\r\n}\r\nif (!start_timer) {\r\nstart_timer = 1;\r\nnext_expires = delayed->expires;\r\n} else\r\nnext_expires = min(next_expires, delayed->expires);\r\n}\r\nmutex_unlock(&delayed_bios_lock);\r\nif (start_timer)\r\nqueue_timeout(dc, next_expires);\r\nreturn bio_list_get(&flush_bios);\r\n}\r\nstatic void flush_expired_bios(struct work_struct *work)\r\n{\r\nstruct delay_c *dc;\r\ndc = container_of(work, struct delay_c, flush_expired_bios);\r\nflush_bios(flush_delayed_bios(dc, 0));\r\n}\r\nstatic int delay_ctr(struct dm_target *ti, unsigned int argc, char **argv)\r\n{\r\nstruct delay_c *dc;\r\nunsigned long long tmpll;\r\nchar dummy;\r\nif (argc != 3 && argc != 6) {\r\nti->error = "requires exactly 3 or 6 arguments";\r\nreturn -EINVAL;\r\n}\r\ndc = kmalloc(sizeof(*dc), GFP_KERNEL);\r\nif (!dc) {\r\nti->error = "Cannot allocate context";\r\nreturn -ENOMEM;\r\n}\r\ndc->reads = dc->writes = 0;\r\nif (sscanf(argv[1], "%llu%c", &tmpll, &dummy) != 1) {\r\nti->error = "Invalid device sector";\r\ngoto bad;\r\n}\r\ndc->start_read = tmpll;\r\nif (sscanf(argv[2], "%u%c", &dc->read_delay, &dummy) != 1) {\r\nti->error = "Invalid delay";\r\ngoto bad;\r\n}\r\nif (dm_get_device(ti, argv[0], dm_table_get_mode(ti->table),\r\n&dc->dev_read)) {\r\nti->error = "Device lookup failed";\r\ngoto bad;\r\n}\r\ndc->dev_write = NULL;\r\nif (argc == 3)\r\ngoto out;\r\nif (sscanf(argv[4], "%llu%c", &tmpll, &dummy) != 1) {\r\nti->error = "Invalid write device sector";\r\ngoto bad_dev_read;\r\n}\r\ndc->start_write = tmpll;\r\nif (sscanf(argv[5], "%u%c", &dc->write_delay, &dummy) != 1) {\r\nti->error = "Invalid write delay";\r\ngoto bad_dev_read;\r\n}\r\nif (dm_get_device(ti, argv[3], dm_table_get_mode(ti->table),\r\n&dc->dev_write)) {\r\nti->error = "Write device lookup failed";\r\ngoto bad_dev_read;\r\n}\r\nout:\r\ndc->kdelayd_wq = alloc_workqueue("kdelayd", WQ_MEM_RECLAIM, 0);\r\nif (!dc->kdelayd_wq) {\r\nDMERR("Couldn't start kdelayd");\r\ngoto bad_queue;\r\n}\r\nsetup_timer(&dc->delay_timer, handle_delayed_timer, (unsigned long)dc);\r\nINIT_WORK(&dc->flush_expired_bios, flush_expired_bios);\r\nINIT_LIST_HEAD(&dc->delayed_bios);\r\nmutex_init(&dc->timer_lock);\r\natomic_set(&dc->may_delay, 1);\r\nti->num_flush_bios = 1;\r\nti->num_discard_bios = 1;\r\nti->per_bio_data_size = sizeof(struct dm_delay_info);\r\nti->private = dc;\r\nreturn 0;\r\nbad_queue:\r\nif (dc->dev_write)\r\ndm_put_device(ti, dc->dev_write);\r\nbad_dev_read:\r\ndm_put_device(ti, dc->dev_read);\r\nbad:\r\nkfree(dc);\r\nreturn -EINVAL;\r\n}\r\nstatic void delay_dtr(struct dm_target *ti)\r\n{\r\nstruct delay_c *dc = ti->private;\r\ndestroy_workqueue(dc->kdelayd_wq);\r\ndm_put_device(ti, dc->dev_read);\r\nif (dc->dev_write)\r\ndm_put_device(ti, dc->dev_write);\r\nkfree(dc);\r\n}\r\nstatic int delay_bio(struct delay_c *dc, int delay, struct bio *bio)\r\n{\r\nstruct dm_delay_info *delayed;\r\nunsigned long expires = 0;\r\nif (!delay || !atomic_read(&dc->may_delay))\r\nreturn 1;\r\ndelayed = dm_per_bio_data(bio, sizeof(struct dm_delay_info));\r\ndelayed->context = dc;\r\ndelayed->expires = expires = jiffies + msecs_to_jiffies(delay);\r\nmutex_lock(&delayed_bios_lock);\r\nif (bio_data_dir(bio) == WRITE)\r\ndc->writes++;\r\nelse\r\ndc->reads++;\r\nlist_add_tail(&delayed->list, &dc->delayed_bios);\r\nmutex_unlock(&delayed_bios_lock);\r\nqueue_timeout(dc, expires);\r\nreturn 0;\r\n}\r\nstatic void delay_presuspend(struct dm_target *ti)\r\n{\r\nstruct delay_c *dc = ti->private;\r\natomic_set(&dc->may_delay, 0);\r\ndel_timer_sync(&dc->delay_timer);\r\nflush_bios(flush_delayed_bios(dc, 1));\r\n}\r\nstatic void delay_resume(struct dm_target *ti)\r\n{\r\nstruct delay_c *dc = ti->private;\r\natomic_set(&dc->may_delay, 1);\r\n}\r\nstatic int delay_map(struct dm_target *ti, struct bio *bio)\r\n{\r\nstruct delay_c *dc = ti->private;\r\nif ((bio_data_dir(bio) == WRITE) && (dc->dev_write)) {\r\nbio->bi_bdev = dc->dev_write->bdev;\r\nif (bio_sectors(bio))\r\nbio->bi_iter.bi_sector = dc->start_write +\r\ndm_target_offset(ti, bio->bi_iter.bi_sector);\r\nreturn delay_bio(dc, dc->write_delay, bio);\r\n}\r\nbio->bi_bdev = dc->dev_read->bdev;\r\nbio->bi_iter.bi_sector = dc->start_read +\r\ndm_target_offset(ti, bio->bi_iter.bi_sector);\r\nreturn delay_bio(dc, dc->read_delay, bio);\r\n}\r\nstatic void delay_status(struct dm_target *ti, status_type_t type,\r\nunsigned status_flags, char *result, unsigned maxlen)\r\n{\r\nstruct delay_c *dc = ti->private;\r\nint sz = 0;\r\nswitch (type) {\r\ncase STATUSTYPE_INFO:\r\nDMEMIT("%u %u", dc->reads, dc->writes);\r\nbreak;\r\ncase STATUSTYPE_TABLE:\r\nDMEMIT("%s %llu %u", dc->dev_read->name,\r\n(unsigned long long) dc->start_read,\r\ndc->read_delay);\r\nif (dc->dev_write)\r\nDMEMIT(" %s %llu %u", dc->dev_write->name,\r\n(unsigned long long) dc->start_write,\r\ndc->write_delay);\r\nbreak;\r\n}\r\n}\r\nstatic int delay_iterate_devices(struct dm_target *ti,\r\niterate_devices_callout_fn fn, void *data)\r\n{\r\nstruct delay_c *dc = ti->private;\r\nint ret = 0;\r\nret = fn(ti, dc->dev_read, dc->start_read, ti->len, data);\r\nif (ret)\r\ngoto out;\r\nif (dc->dev_write)\r\nret = fn(ti, dc->dev_write, dc->start_write, ti->len, data);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __init dm_delay_init(void)\r\n{\r\nint r;\r\nr = dm_register_target(&delay_target);\r\nif (r < 0) {\r\nDMERR("register failed %d", r);\r\ngoto bad_register;\r\n}\r\nreturn 0;\r\nbad_register:\r\nreturn r;\r\n}\r\nstatic void __exit dm_delay_exit(void)\r\n{\r\ndm_unregister_target(&delay_target);\r\n}
