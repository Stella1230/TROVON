void rtl_btc_init_variables(struct rtl_priv *rtlpriv)\r\n{\r\nexhalbtc_initlize_variables(rtlpriv);\r\n}\r\nvoid rtl_btc_init_hal_vars(struct rtl_priv *rtlpriv)\r\n{\r\nu8 ant_num;\r\nu8 bt_exist;\r\nu8 bt_type;\r\nant_num = rtl_get_hwpg_ant_num(rtlpriv);\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,\r\n"%s, antNum is %d\n", __func__, ant_num);\r\nbt_exist = rtl_get_hwpg_bt_exist(rtlpriv);\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,\r\n"%s, bt_exist is %d\n", __func__, bt_exist);\r\nexhalbtc_set_bt_exist(bt_exist);\r\nbt_type = rtl_get_hwpg_bt_type(rtlpriv);\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "%s, bt_type is %d\n",\r\n__func__, bt_type);\r\nexhalbtc_set_chip_type(bt_type);\r\nexhalbtc_set_ant_num(BT_COEX_ANT_TYPE_PG, ant_num);\r\n}\r\nvoid rtl_btc_init_hw_config(struct rtl_priv *rtlpriv)\r\n{\r\nexhalbtc_init_hw_config(&gl_bt_coexist);\r\nexhalbtc_init_coex_dm(&gl_bt_coexist);\r\n}\r\nvoid rtl_btc_ips_notify(struct rtl_priv *rtlpriv, u8 type)\r\n{\r\nexhalbtc_ips_notify(&gl_bt_coexist, type);\r\n}\r\nvoid rtl_btc_lps_notify(struct rtl_priv *rtlpriv, u8 type)\r\n{\r\nexhalbtc_lps_notify(&gl_bt_coexist, type);\r\n}\r\nvoid rtl_btc_scan_notify(struct rtl_priv *rtlpriv, u8 scantype)\r\n{\r\nexhalbtc_scan_notify(&gl_bt_coexist, scantype);\r\n}\r\nvoid rtl_btc_connect_notify(struct rtl_priv *rtlpriv, u8 action)\r\n{\r\nexhalbtc_connect_notify(&gl_bt_coexist, action);\r\n}\r\nvoid rtl_btc_mediastatus_notify(struct rtl_priv *rtlpriv,\r\nenum rt_media_status mstatus)\r\n{\r\nexhalbtc_mediastatus_notify(&gl_bt_coexist, mstatus);\r\n}\r\nvoid rtl_btc_periodical(struct rtl_priv *rtlpriv)\r\n{\r\nexhalbtc_periodical(&gl_bt_coexist);\r\n}\r\nvoid rtl_btc_halt_notify(void)\r\n{\r\nexhalbtc_halt_notify(&gl_bt_coexist);\r\n}\r\nvoid rtl_btc_btinfo_notify(struct rtl_priv *rtlpriv, u8 *tmp_buf, u8 length)\r\n{\r\nexhalbtc_bt_info_notify(&gl_bt_coexist, tmp_buf, length);\r\n}\r\nbool rtl_btc_is_limited_dig(struct rtl_priv *rtlpriv)\r\n{\r\nreturn gl_bt_coexist.bt_info.limited_dig;\r\n}\r\nbool rtl_btc_is_disable_edca_turbo(struct rtl_priv *rtlpriv)\r\n{\r\nbool bt_change_edca = false;\r\nu32 cur_edca_val;\r\nu32 edca_bt_hs_uplink = 0x5ea42b, edca_bt_hs_downlink = 0x5ea42b;\r\nu32 edca_hs;\r\nu32 edca_addr = 0x504;\r\ncur_edca_val = rtl_read_dword(rtlpriv, edca_addr);\r\nif (halbtc_is_wifi_uplink(rtlpriv)) {\r\nif (cur_edca_val != edca_bt_hs_uplink) {\r\nedca_hs = edca_bt_hs_uplink;\r\nbt_change_edca = true;\r\n}\r\n} else {\r\nif (cur_edca_val != edca_bt_hs_downlink) {\r\nedca_hs = edca_bt_hs_downlink;\r\nbt_change_edca = true;\r\n}\r\n}\r\nif (bt_change_edca)\r\nrtl_write_dword(rtlpriv, edca_addr, edca_hs);\r\nreturn true;\r\n}\r\nbool rtl_btc_is_bt_disabled(struct rtl_priv *rtlpriv)\r\n{\r\nif (gl_bt_coexist.bt_info.bt_disabled)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nvoid rtl_btc_special_packet_notify(struct rtl_priv *rtlpriv, u8 pkt_type)\r\n{\r\nreturn exhalbtc_special_packet_notify(&gl_bt_coexist, pkt_type);\r\n}\r\nstruct rtl_btc_ops *rtl_btc_get_ops_pointer(void)\r\n{\r\nreturn &rtl_btc_operation;\r\n}\r\nu8 rtl_get_hwpg_ant_num(struct rtl_priv *rtlpriv)\r\n{\r\nu8 num;\r\nif (rtlpriv->btcoexist.btc_info.ant_num == ANT_X2)\r\nnum = 2;\r\nelse\r\nnum = 1;\r\nreturn num;\r\n}\r\nenum rt_media_status mgnt_link_status_query(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nenum rt_media_status m_status = RT_MEDIA_DISCONNECT;\r\nu8 bibss = (mac->opmode == NL80211_IFTYPE_ADHOC) ? 1 : 0;\r\nif (bibss || rtlpriv->mac80211.link_state >= MAC80211_LINKED)\r\nm_status = RT_MEDIA_CONNECT;\r\nreturn m_status;\r\n}\r\nu8 rtl_get_hwpg_bt_exist(struct rtl_priv *rtlpriv)\r\n{\r\nreturn rtlpriv->btcoexist.btc_info.btcoexist;\r\n}\r\nu8 rtl_get_hwpg_bt_type(struct rtl_priv *rtlpriv)\r\n{\r\nreturn rtlpriv->btcoexist.btc_info.bt_type;\r\n}\r\nstatic int __init rtl_btcoexist_module_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit rtl_btcoexist_module_exit(void)\r\n{\r\nreturn;\r\n}
