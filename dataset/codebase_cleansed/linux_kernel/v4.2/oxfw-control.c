static int oxfw_mute_command(struct snd_oxfw *oxfw, bool *value,\r\nenum control_action action)\r\n{\r\nu8 *buf;\r\nu8 response_ok;\r\nint err;\r\nbuf = kmalloc(11, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (action == CTL_READ) {\r\nbuf[0] = 0x01;\r\nresponse_ok = 0x0c;\r\n} else {\r\nbuf[0] = 0x00;\r\nresponse_ok = 0x09;\r\n}\r\nbuf[1] = 0x08;\r\nbuf[2] = 0xb8;\r\nbuf[3] = 0x81;\r\nbuf[4] = oxfw->device_info->mute_fb_id;\r\nbuf[5] = 0x10;\r\nbuf[6] = 0x02;\r\nbuf[7] = 0x00;\r\nbuf[8] = 0x01;\r\nbuf[9] = 0x01;\r\nif (action == CTL_READ)\r\nbuf[10] = 0xff;\r\nelse\r\nbuf[10] = *value ? 0x70 : 0x60;\r\nerr = fcp_avc_transaction(oxfw->unit, buf, 11, buf, 11, 0x3fe);\r\nif (err < 0)\r\ngoto error;\r\nif (err < 11) {\r\ndev_err(&oxfw->unit->device, "short FCP response\n");\r\nerr = -EIO;\r\ngoto error;\r\n}\r\nif (buf[0] != response_ok) {\r\ndev_err(&oxfw->unit->device, "mute command failed\n");\r\nerr = -EIO;\r\ngoto error;\r\n}\r\nif (action == CTL_READ)\r\n*value = buf[10] == 0x70;\r\nerr = 0;\r\nerror:\r\nkfree(buf);\r\nreturn err;\r\n}\r\nstatic int oxfw_volume_command(struct snd_oxfw *oxfw, s16 *value,\r\nunsigned int channel,\r\nenum control_attribute attribute,\r\nenum control_action action)\r\n{\r\nu8 *buf;\r\nu8 response_ok;\r\nint err;\r\nbuf = kmalloc(12, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (action == CTL_READ) {\r\nbuf[0] = 0x01;\r\nresponse_ok = 0x0c;\r\n} else {\r\nbuf[0] = 0x00;\r\nresponse_ok = 0x09;\r\n}\r\nbuf[1] = 0x08;\r\nbuf[2] = 0xb8;\r\nbuf[3] = 0x81;\r\nbuf[4] = oxfw->device_info->volume_fb_id;\r\nbuf[5] = attribute;\r\nbuf[6] = 0x02;\r\nbuf[7] = channel;\r\nbuf[8] = 0x02;\r\nbuf[9] = 0x02;\r\nif (action == CTL_READ) {\r\nbuf[10] = 0xff;\r\nbuf[11] = 0xff;\r\n} else {\r\nbuf[10] = *value >> 8;\r\nbuf[11] = *value;\r\n}\r\nerr = fcp_avc_transaction(oxfw->unit, buf, 12, buf, 12, 0x3fe);\r\nif (err < 0)\r\ngoto error;\r\nif (err < 12) {\r\ndev_err(&oxfw->unit->device, "short FCP response\n");\r\nerr = -EIO;\r\ngoto error;\r\n}\r\nif (buf[0] != response_ok) {\r\ndev_err(&oxfw->unit->device, "volume command failed\n");\r\nerr = -EIO;\r\ngoto error;\r\n}\r\nif (action == CTL_READ)\r\n*value = (buf[10] << 8) | buf[11];\r\nerr = 0;\r\nerror:\r\nkfree(buf);\r\nreturn err;\r\n}\r\nstatic int oxfw_mute_get(struct snd_kcontrol *control,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct snd_oxfw *oxfw = control->private_data;\r\nvalue->value.integer.value[0] = !oxfw->mute;\r\nreturn 0;\r\n}\r\nstatic int oxfw_mute_put(struct snd_kcontrol *control,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct snd_oxfw *oxfw = control->private_data;\r\nbool mute;\r\nint err;\r\nmute = !value->value.integer.value[0];\r\nif (mute == oxfw->mute)\r\nreturn 0;\r\nerr = oxfw_mute_command(oxfw, &mute, CTL_WRITE);\r\nif (err < 0)\r\nreturn err;\r\noxfw->mute = mute;\r\nreturn 1;\r\n}\r\nstatic int oxfw_volume_info(struct snd_kcontrol *control,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\nstruct snd_oxfw *oxfw = control->private_data;\r\ninfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\ninfo->count = oxfw->device_info->mixer_channels;\r\ninfo->value.integer.min = oxfw->volume_min;\r\ninfo->value.integer.max = oxfw->volume_max;\r\nreturn 0;\r\n}\r\nstatic int oxfw_volume_get(struct snd_kcontrol *control,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct snd_oxfw *oxfw = control->private_data;\r\nunsigned int i;\r\nfor (i = 0; i < oxfw->device_info->mixer_channels; ++i)\r\nvalue->value.integer.value[channel_map[i]] = oxfw->volume[i];\r\nreturn 0;\r\n}\r\nstatic int oxfw_volume_put(struct snd_kcontrol *control,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct snd_oxfw *oxfw = control->private_data;\r\nunsigned int i, changed_channels;\r\nbool equal_values = true;\r\ns16 volume;\r\nint err;\r\nfor (i = 0; i < oxfw->device_info->mixer_channels; ++i) {\r\nif (value->value.integer.value[i] < oxfw->volume_min ||\r\nvalue->value.integer.value[i] > oxfw->volume_max)\r\nreturn -EINVAL;\r\nif (value->value.integer.value[i] !=\r\nvalue->value.integer.value[0])\r\nequal_values = false;\r\n}\r\nchanged_channels = 0;\r\nfor (i = 0; i < oxfw->device_info->mixer_channels; ++i)\r\nif (value->value.integer.value[channel_map[i]] !=\r\noxfw->volume[i])\r\nchanged_channels |= 1 << (i + 1);\r\nif (equal_values && changed_channels != 0)\r\nchanged_channels = 1 << 0;\r\nfor (i = 0; i <= oxfw->device_info->mixer_channels; ++i) {\r\nvolume = value->value.integer.value[channel_map[i ? i - 1 : 0]];\r\nif (changed_channels & (1 << i)) {\r\nerr = oxfw_volume_command(oxfw, &volume, i,\r\nCTL_CURRENT, CTL_WRITE);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (i > 0)\r\noxfw->volume[i - 1] = volume;\r\n}\r\nreturn changed_channels != 0;\r\n}\r\nint snd_oxfw_create_mixer(struct snd_oxfw *oxfw)\r\n{\r\nstatic const struct snd_kcontrol_new controls[] = {\r\n{\r\n.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\r\n.name = "PCM Playback Switch",\r\n.info = snd_ctl_boolean_mono_info,\r\n.get = oxfw_mute_get,\r\n.put = oxfw_mute_put,\r\n},\r\n{\r\n.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\r\n.name = "PCM Playback Volume",\r\n.info = oxfw_volume_info,\r\n.get = oxfw_volume_get,\r\n.put = oxfw_volume_put,\r\n},\r\n};\r\nunsigned int i, first_ch;\r\nint err;\r\nerr = oxfw_volume_command(oxfw, &oxfw->volume_min,\r\n0, CTL_MIN, CTL_READ);\r\nif (err < 0)\r\nreturn err;\r\nerr = oxfw_volume_command(oxfw, &oxfw->volume_max,\r\n0, CTL_MAX, CTL_READ);\r\nif (err < 0)\r\nreturn err;\r\nerr = oxfw_mute_command(oxfw, &oxfw->mute, CTL_READ);\r\nif (err < 0)\r\nreturn err;\r\nfirst_ch = oxfw->device_info->mixer_channels == 1 ? 0 : 1;\r\nfor (i = 0; i < oxfw->device_info->mixer_channels; ++i) {\r\nerr = oxfw_volume_command(oxfw, &oxfw->volume[i],\r\nfirst_ch + i, CTL_CURRENT, CTL_READ);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(controls); ++i) {\r\nerr = snd_ctl_add(oxfw->card,\r\nsnd_ctl_new1(&controls[i], oxfw));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}
