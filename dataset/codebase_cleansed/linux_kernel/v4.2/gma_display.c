bool gma_pipe_has_type(struct drm_crtc *crtc, int type)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_mode_config *mode_config = &dev->mode_config;\r\nstruct drm_connector *l_entry;\r\nlist_for_each_entry(l_entry, &mode_config->connector_list, head) {\r\nif (l_entry->encoder && l_entry->encoder->crtc == crtc) {\r\nstruct gma_encoder *gma_encoder =\r\ngma_attached_encoder(l_entry);\r\nif (gma_encoder->type == type)\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nvoid gma_wait_for_vblank(struct drm_device *dev)\r\n{\r\nmdelay(20);\r\n}\r\nint gma_pipe_set_base(struct drm_crtc *crtc, int x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\r\nstruct psb_framebuffer *psbfb = to_psb_fb(crtc->primary->fb);\r\nint pipe = gma_crtc->pipe;\r\nconst struct psb_offset *map = &dev_priv->regmap[pipe];\r\nunsigned long start, offset;\r\nu32 dspcntr;\r\nint ret = 0;\r\nif (!gma_power_begin(dev, true))\r\nreturn 0;\r\nif (!crtc->primary->fb) {\r\ndev_err(dev->dev, "No FB bound\n");\r\ngoto gma_pipe_cleaner;\r\n}\r\nret = psb_gtt_pin(psbfb->gtt);\r\nif (ret < 0)\r\ngoto gma_pipe_set_base_exit;\r\nstart = psbfb->gtt->offset;\r\noffset = y * crtc->primary->fb->pitches[0] + x * (crtc->primary->fb->bits_per_pixel / 8);\r\nREG_WRITE(map->stride, crtc->primary->fb->pitches[0]);\r\ndspcntr = REG_READ(map->cntr);\r\ndspcntr &= ~DISPPLANE_PIXFORMAT_MASK;\r\nswitch (crtc->primary->fb->bits_per_pixel) {\r\ncase 8:\r\ndspcntr |= DISPPLANE_8BPP;\r\nbreak;\r\ncase 16:\r\nif (crtc->primary->fb->depth == 15)\r\ndspcntr |= DISPPLANE_15_16BPP;\r\nelse\r\ndspcntr |= DISPPLANE_16BPP;\r\nbreak;\r\ncase 24:\r\ncase 32:\r\ndspcntr |= DISPPLANE_32BPP_NO_ALPHA;\r\nbreak;\r\ndefault:\r\ndev_err(dev->dev, "Unknown color depth\n");\r\nret = -EINVAL;\r\ngoto gma_pipe_set_base_exit;\r\n}\r\nREG_WRITE(map->cntr, dspcntr);\r\ndev_dbg(dev->dev,\r\n"Writing base %08lX %08lX %d %d\n", start, offset, x, y);\r\nif (IS_PSB(dev)) {\r\nREG_WRITE(map->base, offset + start);\r\nREG_READ(map->base);\r\n} else {\r\nREG_WRITE(map->base, offset);\r\nREG_READ(map->base);\r\nREG_WRITE(map->surf, start);\r\nREG_READ(map->surf);\r\n}\r\ngma_pipe_cleaner:\r\nif (old_fb)\r\npsb_gtt_unpin(to_psb_fb(old_fb)->gtt);\r\ngma_pipe_set_base_exit:\r\ngma_power_end(dev);\r\nreturn ret;\r\n}\r\nvoid gma_crtc_load_lut(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\r\nconst struct psb_offset *map = &dev_priv->regmap[gma_crtc->pipe];\r\nint palreg = map->palette;\r\nint i;\r\nif (!crtc->enabled)\r\nreturn;\r\nif (gma_power_begin(dev, false)) {\r\nfor (i = 0; i < 256; i++) {\r\nREG_WRITE(palreg + 4 * i,\r\n((gma_crtc->lut_r[i] +\r\ngma_crtc->lut_adj[i]) << 16) |\r\n((gma_crtc->lut_g[i] +\r\ngma_crtc->lut_adj[i]) << 8) |\r\n(gma_crtc->lut_b[i] +\r\ngma_crtc->lut_adj[i]));\r\n}\r\ngma_power_end(dev);\r\n} else {\r\nfor (i = 0; i < 256; i++) {\r\ndev_priv->regs.pipe[0].palette[i] =\r\n((gma_crtc->lut_r[i] +\r\ngma_crtc->lut_adj[i]) << 16) |\r\n((gma_crtc->lut_g[i] +\r\ngma_crtc->lut_adj[i]) << 8) |\r\n(gma_crtc->lut_b[i] +\r\ngma_crtc->lut_adj[i]);\r\n}\r\n}\r\n}\r\nvoid gma_crtc_gamma_set(struct drm_crtc *crtc, u16 *red, u16 *green, u16 *blue,\r\nu32 start, u32 size)\r\n{\r\nstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\r\nint i;\r\nint end = (start + size > 256) ? 256 : start + size;\r\nfor (i = start; i < end; i++) {\r\ngma_crtc->lut_r[i] = red[i] >> 8;\r\ngma_crtc->lut_g[i] = green[i] >> 8;\r\ngma_crtc->lut_b[i] = blue[i] >> 8;\r\n}\r\ngma_crtc_load_lut(crtc);\r\n}\r\nvoid gma_crtc_dpms(struct drm_crtc *crtc, int mode)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\r\nint pipe = gma_crtc->pipe;\r\nconst struct psb_offset *map = &dev_priv->regmap[pipe];\r\nu32 temp;\r\nif (IS_CDV(dev))\r\ndev_priv->ops->disable_sr(dev);\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\ncase DRM_MODE_DPMS_STANDBY:\r\ncase DRM_MODE_DPMS_SUSPEND:\r\nif (gma_crtc->active)\r\nbreak;\r\ngma_crtc->active = true;\r\ntemp = REG_READ(map->dpll);\r\nif ((temp & DPLL_VCO_ENABLE) == 0) {\r\nREG_WRITE(map->dpll, temp);\r\nREG_READ(map->dpll);\r\nudelay(150);\r\nREG_WRITE(map->dpll, temp | DPLL_VCO_ENABLE);\r\nREG_READ(map->dpll);\r\nudelay(150);\r\nREG_WRITE(map->dpll, temp | DPLL_VCO_ENABLE);\r\nREG_READ(map->dpll);\r\nudelay(150);\r\n}\r\ntemp = REG_READ(map->cntr);\r\nif ((temp & DISPLAY_PLANE_ENABLE) == 0) {\r\nREG_WRITE(map->cntr,\r\ntemp | DISPLAY_PLANE_ENABLE);\r\nREG_WRITE(map->base, REG_READ(map->base));\r\n}\r\nudelay(150);\r\ntemp = REG_READ(map->conf);\r\nif ((temp & PIPEACONF_ENABLE) == 0)\r\nREG_WRITE(map->conf, temp | PIPEACONF_ENABLE);\r\ntemp = REG_READ(map->status);\r\ntemp &= ~(0xFFFF);\r\ntemp |= PIPE_FIFO_UNDERRUN;\r\nREG_WRITE(map->status, temp);\r\nREG_READ(map->status);\r\ngma_crtc_load_lut(crtc);\r\nbreak;\r\ncase DRM_MODE_DPMS_OFF:\r\nif (!gma_crtc->active)\r\nbreak;\r\ngma_crtc->active = false;\r\nREG_WRITE(VGACNTRL, VGA_DISP_DISABLE);\r\ndrm_vblank_off(dev, pipe);\r\ngma_wait_for_vblank(dev);\r\ntemp = REG_READ(map->cntr);\r\nif ((temp & DISPLAY_PLANE_ENABLE) != 0) {\r\nREG_WRITE(map->cntr,\r\ntemp & ~DISPLAY_PLANE_ENABLE);\r\nREG_WRITE(map->base, REG_READ(map->base));\r\nREG_READ(map->base);\r\n}\r\ntemp = REG_READ(map->conf);\r\nif ((temp & PIPEACONF_ENABLE) != 0) {\r\nREG_WRITE(map->conf, temp & ~PIPEACONF_ENABLE);\r\nREG_READ(map->conf);\r\n}\r\ngma_wait_for_vblank(dev);\r\nudelay(150);\r\ntemp = REG_READ(map->dpll);\r\nif ((temp & DPLL_VCO_ENABLE) != 0) {\r\nREG_WRITE(map->dpll, temp & ~DPLL_VCO_ENABLE);\r\nREG_READ(map->dpll);\r\n}\r\nudelay(150);\r\nbreak;\r\n}\r\nif (IS_CDV(dev))\r\ndev_priv->ops->update_wm(dev, crtc);\r\nREG_WRITE(DSPARB, 0x3F3E);\r\n}\r\nint gma_crtc_cursor_set(struct drm_crtc *crtc,\r\nstruct drm_file *file_priv,\r\nuint32_t handle,\r\nuint32_t width, uint32_t height)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\r\nint pipe = gma_crtc->pipe;\r\nuint32_t control = (pipe == 0) ? CURACNTR : CURBCNTR;\r\nuint32_t base = (pipe == 0) ? CURABASE : CURBBASE;\r\nuint32_t temp;\r\nsize_t addr = 0;\r\nstruct gtt_range *gt;\r\nstruct gtt_range *cursor_gt = gma_crtc->cursor_gt;\r\nstruct drm_gem_object *obj;\r\nvoid *tmp_dst, *tmp_src;\r\nint ret = 0, i, cursor_pages;\r\nif (!handle) {\r\ntemp = CURSOR_MODE_DISABLE;\r\nmutex_lock(&dev->struct_mutex);\r\nif (gma_power_begin(dev, false)) {\r\nREG_WRITE(control, temp);\r\nREG_WRITE(base, 0);\r\ngma_power_end(dev);\r\n}\r\nif (gma_crtc->cursor_obj) {\r\ngt = container_of(gma_crtc->cursor_obj,\r\nstruct gtt_range, gem);\r\npsb_gtt_unpin(gt);\r\ndrm_gem_object_unreference(gma_crtc->cursor_obj);\r\ngma_crtc->cursor_obj = NULL;\r\n}\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn 0;\r\n}\r\nif (width != 64 || height != 64) {\r\ndev_dbg(dev->dev, "We currently only support 64x64 cursors\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&dev->struct_mutex);\r\nobj = drm_gem_object_lookup(dev, file_priv, handle);\r\nif (!obj) {\r\nret = -ENOENT;\r\ngoto unlock;\r\n}\r\nif (obj->size < width * height * 4) {\r\ndev_dbg(dev->dev, "Buffer is too small\n");\r\nret = -ENOMEM;\r\ngoto unref_cursor;\r\n}\r\ngt = container_of(obj, struct gtt_range, gem);\r\nret = psb_gtt_pin(gt);\r\nif (ret) {\r\ndev_err(dev->dev, "Can not pin down handle 0x%x\n", handle);\r\ngoto unref_cursor;\r\n}\r\nif (dev_priv->ops->cursor_needs_phys) {\r\nif (cursor_gt == NULL) {\r\ndev_err(dev->dev, "No hardware cursor mem available");\r\nret = -ENOMEM;\r\ngoto unref_cursor;\r\n}\r\nif (gt->npage > 4)\r\ncursor_pages = 4;\r\nelse\r\ncursor_pages = gt->npage;\r\ntmp_dst = dev_priv->vram_addr + cursor_gt->offset;\r\nfor (i = 0; i < cursor_pages; i++) {\r\ntmp_src = kmap(gt->pages[i]);\r\nmemcpy(tmp_dst, tmp_src, PAGE_SIZE);\r\nkunmap(gt->pages[i]);\r\ntmp_dst += PAGE_SIZE;\r\n}\r\naddr = gma_crtc->cursor_addr;\r\n} else {\r\naddr = gt->offset;\r\ngma_crtc->cursor_addr = addr;\r\n}\r\ntemp = 0;\r\ntemp |= (pipe << 28);\r\ntemp |= CURSOR_MODE_64_ARGB_AX | MCURSOR_GAMMA_ENABLE;\r\nif (gma_power_begin(dev, false)) {\r\nREG_WRITE(control, temp);\r\nREG_WRITE(base, addr);\r\ngma_power_end(dev);\r\n}\r\nif (gma_crtc->cursor_obj) {\r\ngt = container_of(gma_crtc->cursor_obj, struct gtt_range, gem);\r\npsb_gtt_unpin(gt);\r\ndrm_gem_object_unreference(gma_crtc->cursor_obj);\r\n}\r\ngma_crtc->cursor_obj = obj;\r\nunlock:\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn ret;\r\nunref_cursor:\r\ndrm_gem_object_unreference(obj);\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn ret;\r\n}\r\nint gma_crtc_cursor_move(struct drm_crtc *crtc, int x, int y)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\r\nint pipe = gma_crtc->pipe;\r\nuint32_t temp = 0;\r\nuint32_t addr;\r\nif (x < 0) {\r\ntemp |= (CURSOR_POS_SIGN << CURSOR_X_SHIFT);\r\nx = -x;\r\n}\r\nif (y < 0) {\r\ntemp |= (CURSOR_POS_SIGN << CURSOR_Y_SHIFT);\r\ny = -y;\r\n}\r\ntemp |= ((x & CURSOR_POS_MASK) << CURSOR_X_SHIFT);\r\ntemp |= ((y & CURSOR_POS_MASK) << CURSOR_Y_SHIFT);\r\naddr = gma_crtc->cursor_addr;\r\nif (gma_power_begin(dev, false)) {\r\nREG_WRITE((pipe == 0) ? CURAPOS : CURBPOS, temp);\r\nREG_WRITE((pipe == 0) ? CURABASE : CURBBASE, addr);\r\ngma_power_end(dev);\r\n}\r\nreturn 0;\r\n}\r\nbool gma_encoder_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nbool gma_crtc_mode_fixup(struct drm_crtc *crtc,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nvoid gma_crtc_prepare(struct drm_crtc *crtc)\r\n{\r\nconst struct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\r\ncrtc_funcs->dpms(crtc, DRM_MODE_DPMS_OFF);\r\n}\r\nvoid gma_crtc_commit(struct drm_crtc *crtc)\r\n{\r\nconst struct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\r\ncrtc_funcs->dpms(crtc, DRM_MODE_DPMS_ON);\r\n}\r\nvoid gma_crtc_disable(struct drm_crtc *crtc)\r\n{\r\nstruct gtt_range *gt;\r\nconst struct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\r\ncrtc_funcs->dpms(crtc, DRM_MODE_DPMS_OFF);\r\nif (crtc->primary->fb) {\r\ngt = to_psb_fb(crtc->primary->fb)->gtt;\r\npsb_gtt_unpin(gt);\r\n}\r\n}\r\nvoid gma_crtc_destroy(struct drm_crtc *crtc)\r\n{\r\nstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\r\nkfree(gma_crtc->crtc_state);\r\ndrm_crtc_cleanup(crtc);\r\nkfree(gma_crtc);\r\n}\r\nint gma_crtc_set_config(struct drm_mode_set *set)\r\n{\r\nstruct drm_device *dev = set->crtc->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nint ret;\r\nif (!dev_priv->rpm_enabled)\r\nreturn drm_crtc_helper_set_config(set);\r\npm_runtime_forbid(&dev->pdev->dev);\r\nret = drm_crtc_helper_set_config(set);\r\npm_runtime_allow(&dev->pdev->dev);\r\nreturn ret;\r\n}\r\nvoid gma_crtc_save(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\r\nstruct psb_intel_crtc_state *crtc_state = gma_crtc->crtc_state;\r\nconst struct psb_offset *map = &dev_priv->regmap[gma_crtc->pipe];\r\nuint32_t palette_reg;\r\nint i;\r\nif (!crtc_state) {\r\ndev_err(dev->dev, "No CRTC state found\n");\r\nreturn;\r\n}\r\ncrtc_state->saveDSPCNTR = REG_READ(map->cntr);\r\ncrtc_state->savePIPECONF = REG_READ(map->conf);\r\ncrtc_state->savePIPESRC = REG_READ(map->src);\r\ncrtc_state->saveFP0 = REG_READ(map->fp0);\r\ncrtc_state->saveFP1 = REG_READ(map->fp1);\r\ncrtc_state->saveDPLL = REG_READ(map->dpll);\r\ncrtc_state->saveHTOTAL = REG_READ(map->htotal);\r\ncrtc_state->saveHBLANK = REG_READ(map->hblank);\r\ncrtc_state->saveHSYNC = REG_READ(map->hsync);\r\ncrtc_state->saveVTOTAL = REG_READ(map->vtotal);\r\ncrtc_state->saveVBLANK = REG_READ(map->vblank);\r\ncrtc_state->saveVSYNC = REG_READ(map->vsync);\r\ncrtc_state->saveDSPSTRIDE = REG_READ(map->stride);\r\ncrtc_state->saveDSPSIZE = REG_READ(map->size);\r\ncrtc_state->saveDSPPOS = REG_READ(map->pos);\r\ncrtc_state->saveDSPBASE = REG_READ(map->base);\r\npalette_reg = map->palette;\r\nfor (i = 0; i < 256; ++i)\r\ncrtc_state->savePalette[i] = REG_READ(palette_reg + (i << 2));\r\n}\r\nvoid gma_crtc_restore(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\r\nstruct psb_intel_crtc_state *crtc_state = gma_crtc->crtc_state;\r\nconst struct psb_offset *map = &dev_priv->regmap[gma_crtc->pipe];\r\nuint32_t palette_reg;\r\nint i;\r\nif (!crtc_state) {\r\ndev_err(dev->dev, "No crtc state\n");\r\nreturn;\r\n}\r\nif (crtc_state->saveDPLL & DPLL_VCO_ENABLE) {\r\nREG_WRITE(map->dpll,\r\ncrtc_state->saveDPLL & ~DPLL_VCO_ENABLE);\r\nREG_READ(map->dpll);\r\nudelay(150);\r\n}\r\nREG_WRITE(map->fp0, crtc_state->saveFP0);\r\nREG_READ(map->fp0);\r\nREG_WRITE(map->fp1, crtc_state->saveFP1);\r\nREG_READ(map->fp1);\r\nREG_WRITE(map->dpll, crtc_state->saveDPLL);\r\nREG_READ(map->dpll);\r\nudelay(150);\r\nREG_WRITE(map->htotal, crtc_state->saveHTOTAL);\r\nREG_WRITE(map->hblank, crtc_state->saveHBLANK);\r\nREG_WRITE(map->hsync, crtc_state->saveHSYNC);\r\nREG_WRITE(map->vtotal, crtc_state->saveVTOTAL);\r\nREG_WRITE(map->vblank, crtc_state->saveVBLANK);\r\nREG_WRITE(map->vsync, crtc_state->saveVSYNC);\r\nREG_WRITE(map->stride, crtc_state->saveDSPSTRIDE);\r\nREG_WRITE(map->size, crtc_state->saveDSPSIZE);\r\nREG_WRITE(map->pos, crtc_state->saveDSPPOS);\r\nREG_WRITE(map->src, crtc_state->savePIPESRC);\r\nREG_WRITE(map->base, crtc_state->saveDSPBASE);\r\nREG_WRITE(map->conf, crtc_state->savePIPECONF);\r\ngma_wait_for_vblank(dev);\r\nREG_WRITE(map->cntr, crtc_state->saveDSPCNTR);\r\nREG_WRITE(map->base, crtc_state->saveDSPBASE);\r\ngma_wait_for_vblank(dev);\r\npalette_reg = map->palette;\r\nfor (i = 0; i < 256; ++i)\r\nREG_WRITE(palette_reg + (i << 2), crtc_state->savePalette[i]);\r\n}\r\nvoid gma_encoder_prepare(struct drm_encoder *encoder)\r\n{\r\nconst struct drm_encoder_helper_funcs *encoder_funcs =\r\nencoder->helper_private;\r\nencoder_funcs->dpms(encoder, DRM_MODE_DPMS_OFF);\r\n}\r\nvoid gma_encoder_commit(struct drm_encoder *encoder)\r\n{\r\nconst struct drm_encoder_helper_funcs *encoder_funcs =\r\nencoder->helper_private;\r\nencoder_funcs->dpms(encoder, DRM_MODE_DPMS_ON);\r\n}\r\nvoid gma_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\nstruct gma_encoder *intel_encoder = to_gma_encoder(encoder);\r\ndrm_encoder_cleanup(encoder);\r\nkfree(intel_encoder);\r\n}\r\nstruct drm_encoder *gma_best_encoder(struct drm_connector *connector)\r\n{\r\nstruct gma_encoder *gma_encoder = gma_attached_encoder(connector);\r\nreturn &gma_encoder->base;\r\n}\r\nvoid gma_connector_attach_encoder(struct gma_connector *connector,\r\nstruct gma_encoder *encoder)\r\n{\r\nconnector->encoder = encoder;\r\ndrm_mode_connector_attach_encoder(&connector->base,\r\n&encoder->base);\r\n}\r\nbool gma_pll_is_valid(struct drm_crtc *crtc,\r\nconst struct gma_limit_t *limit,\r\nstruct gma_clock_t *clock)\r\n{\r\nif (clock->p1 < limit->p1.min || limit->p1.max < clock->p1)\r\nGMA_PLL_INVALID("p1 out of range");\r\nif (clock->p < limit->p.min || limit->p.max < clock->p)\r\nGMA_PLL_INVALID("p out of range");\r\nif (clock->m2 < limit->m2.min || limit->m2.max < clock->m2)\r\nGMA_PLL_INVALID("m2 out of range");\r\nif (clock->m1 < limit->m1.min || limit->m1.max < clock->m1)\r\nGMA_PLL_INVALID("m1 out of range");\r\nif (clock->m1 <= clock->m2 && clock->m1 != 0)\r\nGMA_PLL_INVALID("m1 <= m2 && m1 != 0");\r\nif (clock->m < limit->m.min || limit->m.max < clock->m)\r\nGMA_PLL_INVALID("m out of range");\r\nif (clock->n < limit->n.min || limit->n.max < clock->n)\r\nGMA_PLL_INVALID("n out of range");\r\nif (clock->vco < limit->vco.min || limit->vco.max < clock->vco)\r\nGMA_PLL_INVALID("vco out of range");\r\nif (clock->dot < limit->dot.min || limit->dot.max < clock->dot)\r\nGMA_PLL_INVALID("dot out of range");\r\nreturn true;\r\n}\r\nbool gma_find_best_pll(const struct gma_limit_t *limit,\r\nstruct drm_crtc *crtc, int target, int refclk,\r\nstruct gma_clock_t *best_clock)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nconst struct gma_clock_funcs *clock_funcs =\r\nto_gma_crtc(crtc)->clock_funcs;\r\nstruct gma_clock_t clock;\r\nint err = target;\r\nif (gma_pipe_has_type(crtc, INTEL_OUTPUT_LVDS) &&\r\n(REG_READ(LVDS) & LVDS_PORT_EN) != 0) {\r\nif ((REG_READ(LVDS) & LVDS_CLKB_POWER_MASK) ==\r\nLVDS_CLKB_POWER_UP)\r\nclock.p2 = limit->p2.p2_fast;\r\nelse\r\nclock.p2 = limit->p2.p2_slow;\r\n} else {\r\nif (target < limit->p2.dot_limit)\r\nclock.p2 = limit->p2.p2_slow;\r\nelse\r\nclock.p2 = limit->p2.p2_fast;\r\n}\r\nmemset(best_clock, 0, sizeof(*best_clock));\r\nfor (clock.m1 = limit->m1.min; clock.m1 <= limit->m1.max; clock.m1++) {\r\nfor (clock.m2 = limit->m2.min;\r\n(clock.m2 < clock.m1 || clock.m1 == 0) &&\r\nclock.m2 <= limit->m2.max; clock.m2++) {\r\nfor (clock.n = limit->n.min;\r\nclock.n <= limit->n.max; clock.n++) {\r\nfor (clock.p1 = limit->p1.min;\r\nclock.p1 <= limit->p1.max;\r\nclock.p1++) {\r\nint this_err;\r\nclock_funcs->clock(refclk, &clock);\r\nif (!clock_funcs->pll_is_valid(crtc,\r\nlimit, &clock))\r\ncontinue;\r\nthis_err = abs(clock.dot - target);\r\nif (this_err < err) {\r\n*best_clock = clock;\r\nerr = this_err;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nreturn err != target;\r\n}
