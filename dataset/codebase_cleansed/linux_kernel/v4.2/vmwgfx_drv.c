static void vmw_print_capabilities(uint32_t capabilities)\r\n{\r\nDRM_INFO("Capabilities:\n");\r\nif (capabilities & SVGA_CAP_RECT_COPY)\r\nDRM_INFO(" Rect copy.\n");\r\nif (capabilities & SVGA_CAP_CURSOR)\r\nDRM_INFO(" Cursor.\n");\r\nif (capabilities & SVGA_CAP_CURSOR_BYPASS)\r\nDRM_INFO(" Cursor bypass.\n");\r\nif (capabilities & SVGA_CAP_CURSOR_BYPASS_2)\r\nDRM_INFO(" Cursor bypass 2.\n");\r\nif (capabilities & SVGA_CAP_8BIT_EMULATION)\r\nDRM_INFO(" 8bit emulation.\n");\r\nif (capabilities & SVGA_CAP_ALPHA_CURSOR)\r\nDRM_INFO(" Alpha cursor.\n");\r\nif (capabilities & SVGA_CAP_3D)\r\nDRM_INFO(" 3D.\n");\r\nif (capabilities & SVGA_CAP_EXTENDED_FIFO)\r\nDRM_INFO(" Extended Fifo.\n");\r\nif (capabilities & SVGA_CAP_MULTIMON)\r\nDRM_INFO(" Multimon.\n");\r\nif (capabilities & SVGA_CAP_PITCHLOCK)\r\nDRM_INFO(" Pitchlock.\n");\r\nif (capabilities & SVGA_CAP_IRQMASK)\r\nDRM_INFO(" Irq mask.\n");\r\nif (capabilities & SVGA_CAP_DISPLAY_TOPOLOGY)\r\nDRM_INFO(" Display Topology.\n");\r\nif (capabilities & SVGA_CAP_GMR)\r\nDRM_INFO(" GMR.\n");\r\nif (capabilities & SVGA_CAP_TRACES)\r\nDRM_INFO(" Traces.\n");\r\nif (capabilities & SVGA_CAP_GMR2)\r\nDRM_INFO(" GMR2.\n");\r\nif (capabilities & SVGA_CAP_SCREEN_OBJECT_2)\r\nDRM_INFO(" Screen Object 2.\n");\r\nif (capabilities & SVGA_CAP_COMMAND_BUFFERS)\r\nDRM_INFO(" Command Buffers.\n");\r\nif (capabilities & SVGA_CAP_CMD_BUFFERS_2)\r\nDRM_INFO(" Command Buffers 2.\n");\r\nif (capabilities & SVGA_CAP_GBOBJECTS)\r\nDRM_INFO(" Guest Backed Resources.\n");\r\n}\r\nstatic int vmw_dummy_query_bo_create(struct vmw_private *dev_priv)\r\n{\r\nint ret;\r\nstruct ttm_buffer_object *bo;\r\nstruct ttm_bo_kmap_obj map;\r\nvolatile SVGA3dQueryResult *result;\r\nbool dummy;\r\nret = ttm_bo_create(&dev_priv->bdev,\r\nPAGE_SIZE,\r\nttm_bo_type_device,\r\n&vmw_sys_ne_placement,\r\n0, false, NULL,\r\n&bo);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nret = ttm_bo_reserve(bo, false, true, false, NULL);\r\nBUG_ON(ret != 0);\r\nret = ttm_bo_kmap(bo, 0, 1, &map);\r\nif (likely(ret == 0)) {\r\nresult = ttm_kmap_obj_virtual(&map, &dummy);\r\nresult->totalSize = sizeof(*result);\r\nresult->state = SVGA3D_QUERYSTATE_PENDING;\r\nresult->result32 = 0xff;\r\nttm_bo_kunmap(&map);\r\n}\r\nvmw_bo_pin(bo, false);\r\nttm_bo_unreserve(bo);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Dummy query buffer map failed.\n");\r\nttm_bo_unref(&bo);\r\n} else\r\ndev_priv->dummy_query_bo = bo;\r\nreturn ret;\r\n}\r\nstatic int vmw_request_device(struct vmw_private *dev_priv)\r\n{\r\nint ret;\r\nret = vmw_fifo_init(dev_priv, &dev_priv->fifo);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Unable to initialize FIFO.\n");\r\nreturn ret;\r\n}\r\nvmw_fence_fifo_up(dev_priv->fman);\r\nif (dev_priv->has_mob) {\r\nret = vmw_otables_setup(dev_priv);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Unable to initialize "\r\n"guest Memory OBjects.\n");\r\ngoto out_no_mob;\r\n}\r\n}\r\nret = vmw_dummy_query_bo_create(dev_priv);\r\nif (unlikely(ret != 0))\r\ngoto out_no_query_bo;\r\nreturn 0;\r\nout_no_query_bo:\r\nif (dev_priv->has_mob)\r\nvmw_otables_takedown(dev_priv);\r\nout_no_mob:\r\nvmw_fence_fifo_down(dev_priv->fman);\r\nvmw_fifo_release(dev_priv, &dev_priv->fifo);\r\nreturn ret;\r\n}\r\nstatic void vmw_release_device(struct vmw_private *dev_priv)\r\n{\r\nBUG_ON(dev_priv->pinned_bo != NULL);\r\nttm_bo_unref(&dev_priv->dummy_query_bo);\r\nif (dev_priv->has_mob)\r\nvmw_otables_takedown(dev_priv);\r\nvmw_fence_fifo_down(dev_priv->fman);\r\nvmw_fifo_release(dev_priv, &dev_priv->fifo);\r\n}\r\nint vmw_3d_resource_inc(struct vmw_private *dev_priv,\r\nbool unhide_svga)\r\n{\r\nint ret = 0;\r\nmutex_lock(&dev_priv->release_mutex);\r\nif (unlikely(dev_priv->num_3d_resources++ == 0)) {\r\nret = vmw_request_device(dev_priv);\r\nif (unlikely(ret != 0))\r\n--dev_priv->num_3d_resources;\r\n} else if (unhide_svga) {\r\nvmw_write(dev_priv, SVGA_REG_ENABLE,\r\nvmw_read(dev_priv, SVGA_REG_ENABLE) &\r\n~SVGA_REG_ENABLE_HIDE);\r\n}\r\nmutex_unlock(&dev_priv->release_mutex);\r\nreturn ret;\r\n}\r\nvoid vmw_3d_resource_dec(struct vmw_private *dev_priv,\r\nbool hide_svga)\r\n{\r\nint32_t n3d;\r\nmutex_lock(&dev_priv->release_mutex);\r\nif (unlikely(--dev_priv->num_3d_resources == 0))\r\nvmw_release_device(dev_priv);\r\nelse if (hide_svga)\r\nvmw_write(dev_priv, SVGA_REG_ENABLE,\r\nvmw_read(dev_priv, SVGA_REG_ENABLE) |\r\nSVGA_REG_ENABLE_HIDE);\r\nn3d = (int32_t) dev_priv->num_3d_resources;\r\nmutex_unlock(&dev_priv->release_mutex);\r\nBUG_ON(n3d < 0);\r\n}\r\nstatic void vmw_get_initial_size(struct vmw_private *dev_priv)\r\n{\r\nuint32_t width;\r\nuint32_t height;\r\nwidth = vmw_read(dev_priv, SVGA_REG_WIDTH);\r\nheight = vmw_read(dev_priv, SVGA_REG_HEIGHT);\r\nwidth = max_t(uint32_t, width, VMW_MIN_INITIAL_WIDTH);\r\nheight = max_t(uint32_t, height, VMW_MIN_INITIAL_HEIGHT);\r\nif (width > dev_priv->fb_max_width ||\r\nheight > dev_priv->fb_max_height) {\r\nwidth = VMW_MIN_INITIAL_WIDTH;\r\nheight = VMW_MIN_INITIAL_HEIGHT;\r\n}\r\ndev_priv->initial_width = width;\r\ndev_priv->initial_height = height;\r\n}\r\nstatic int vmw_dma_select_mode(struct vmw_private *dev_priv)\r\n{\r\nstatic const char *names[vmw_dma_map_max] = {\r\n[vmw_dma_phys] = "Using physical TTM page addresses.",\r\n[vmw_dma_alloc_coherent] = "Using coherent TTM pages.",\r\n[vmw_dma_map_populate] = "Keeping DMA mappings.",\r\n[vmw_dma_map_bind] = "Giving up DMA mappings early."};\r\n#ifdef CONFIG_X86\r\nconst struct dma_map_ops *dma_ops = get_dma_ops(dev_priv->dev->dev);\r\n#ifdef CONFIG_INTEL_IOMMU\r\nif (intel_iommu_enabled) {\r\ndev_priv->map_mode = vmw_dma_map_populate;\r\ngoto out_fixup;\r\n}\r\n#endif\r\nif (!(vmw_force_iommu || vmw_force_coherent)) {\r\ndev_priv->map_mode = vmw_dma_phys;\r\nDRM_INFO("DMA map mode: %s\n", names[dev_priv->map_mode]);\r\nreturn 0;\r\n}\r\ndev_priv->map_mode = vmw_dma_map_populate;\r\nif (dma_ops->sync_single_for_cpu)\r\ndev_priv->map_mode = vmw_dma_alloc_coherent;\r\n#ifdef CONFIG_SWIOTLB\r\nif (swiotlb_nr_tbl() == 0)\r\ndev_priv->map_mode = vmw_dma_map_populate;\r\n#endif\r\n#ifdef CONFIG_INTEL_IOMMU\r\nout_fixup:\r\n#endif\r\nif (dev_priv->map_mode == vmw_dma_map_populate &&\r\nvmw_restrict_iommu)\r\ndev_priv->map_mode = vmw_dma_map_bind;\r\nif (vmw_force_coherent)\r\ndev_priv->map_mode = vmw_dma_alloc_coherent;\r\n#if !defined(CONFIG_SWIOTLB) && !defined(CONFIG_INTEL_IOMMU)\r\nif (dev_priv->map_mode == vmw_dma_alloc_coherent)\r\nreturn -EINVAL;\r\n#endif\r\n#else\r\ndev_priv->map_mode = vmw_dma_map_populate;\r\n#endif\r\nDRM_INFO("DMA map mode: %s\n", names[dev_priv->map_mode]);\r\nreturn 0;\r\n}\r\nstatic int vmw_dma_masks(struct vmw_private *dev_priv)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\nif (intel_iommu_enabled &&\r\n(sizeof(unsigned long) == 4 || vmw_restrict_dma_mask)) {\r\nDRM_INFO("Restricting DMA addresses to 44 bits.\n");\r\nreturn dma_set_mask(dev->dev, DMA_BIT_MASK(44));\r\n}\r\nreturn 0;\r\n}\r\nstatic int vmw_dma_masks(struct vmw_private *dev_priv)\r\n{\r\nreturn 0;\r\n}\r\nstatic int vmw_driver_load(struct drm_device *dev, unsigned long chipset)\r\n{\r\nstruct vmw_private *dev_priv;\r\nint ret;\r\nuint32_t svga_id;\r\nenum vmw_res_type i;\r\nbool refuse_dma = false;\r\ndev_priv = kzalloc(sizeof(*dev_priv), GFP_KERNEL);\r\nif (unlikely(dev_priv == NULL)) {\r\nDRM_ERROR("Failed allocating a device private struct.\n");\r\nreturn -ENOMEM;\r\n}\r\npci_set_master(dev->pdev);\r\ndev_priv->dev = dev;\r\ndev_priv->vmw_chipset = chipset;\r\ndev_priv->last_read_seqno = (uint32_t) -100;\r\nmutex_init(&dev_priv->cmdbuf_mutex);\r\nmutex_init(&dev_priv->release_mutex);\r\nmutex_init(&dev_priv->binding_mutex);\r\nrwlock_init(&dev_priv->resource_lock);\r\nttm_lock_init(&dev_priv->reservation_sem);\r\nspin_lock_init(&dev_priv->hw_lock);\r\nspin_lock_init(&dev_priv->waiter_lock);\r\nspin_lock_init(&dev_priv->cap_lock);\r\nfor (i = vmw_res_context; i < vmw_res_max; ++i) {\r\nidr_init(&dev_priv->res_idr[i]);\r\nINIT_LIST_HEAD(&dev_priv->res_lru[i]);\r\n}\r\nmutex_init(&dev_priv->init_mutex);\r\ninit_waitqueue_head(&dev_priv->fence_queue);\r\ninit_waitqueue_head(&dev_priv->fifo_queue);\r\ndev_priv->fence_queue_waiters = 0;\r\natomic_set(&dev_priv->fifo_queue_waiters, 0);\r\ndev_priv->used_memory_size = 0;\r\ndev_priv->io_start = pci_resource_start(dev->pdev, 0);\r\ndev_priv->vram_start = pci_resource_start(dev->pdev, 1);\r\ndev_priv->mmio_start = pci_resource_start(dev->pdev, 2);\r\ndev_priv->enable_fb = enable_fbdev;\r\nvmw_write(dev_priv, SVGA_REG_ID, SVGA_ID_2);\r\nsvga_id = vmw_read(dev_priv, SVGA_REG_ID);\r\nif (svga_id != SVGA_ID_2) {\r\nret = -ENOSYS;\r\nDRM_ERROR("Unsupported SVGA ID 0x%x\n", svga_id);\r\ngoto out_err0;\r\n}\r\ndev_priv->capabilities = vmw_read(dev_priv, SVGA_REG_CAPABILITIES);\r\nret = vmw_dma_select_mode(dev_priv);\r\nif (unlikely(ret != 0)) {\r\nDRM_INFO("Restricting capabilities due to IOMMU setup.\n");\r\nrefuse_dma = true;\r\n}\r\ndev_priv->vram_size = vmw_read(dev_priv, SVGA_REG_VRAM_SIZE);\r\ndev_priv->mmio_size = vmw_read(dev_priv, SVGA_REG_MEM_SIZE);\r\ndev_priv->fb_max_width = vmw_read(dev_priv, SVGA_REG_MAX_WIDTH);\r\ndev_priv->fb_max_height = vmw_read(dev_priv, SVGA_REG_MAX_HEIGHT);\r\nvmw_get_initial_size(dev_priv);\r\nif (dev_priv->capabilities & SVGA_CAP_GMR2) {\r\ndev_priv->max_gmr_ids =\r\nvmw_read(dev_priv, SVGA_REG_GMR_MAX_IDS);\r\ndev_priv->max_gmr_pages =\r\nvmw_read(dev_priv, SVGA_REG_GMRS_MAX_PAGES);\r\ndev_priv->memory_size =\r\nvmw_read(dev_priv, SVGA_REG_MEMORY_SIZE);\r\ndev_priv->memory_size -= dev_priv->vram_size;\r\n} else {\r\ndev_priv->memory_size = 512*1024*1024;\r\n}\r\ndev_priv->max_mob_pages = 0;\r\ndev_priv->max_mob_size = 0;\r\nif (dev_priv->capabilities & SVGA_CAP_GBOBJECTS) {\r\nuint64_t mem_size =\r\nvmw_read(dev_priv,\r\nSVGA_REG_SUGGESTED_GBOBJECT_MEM_SIZE_KB);\r\ndev_priv->max_mob_pages = mem_size * 1024 / PAGE_SIZE;\r\ndev_priv->prim_bb_mem =\r\nvmw_read(dev_priv,\r\nSVGA_REG_MAX_PRIMARY_BOUNDING_BOX_MEM);\r\ndev_priv->max_mob_size =\r\nvmw_read(dev_priv, SVGA_REG_MOB_MAX_SIZE);\r\n} else\r\ndev_priv->prim_bb_mem = dev_priv->vram_size;\r\nret = vmw_dma_masks(dev_priv);\r\nif (unlikely(ret != 0))\r\ngoto out_err0;\r\nif (dev_priv->prim_bb_mem > dev_priv->vram_size)\r\ndev_priv->prim_bb_mem = dev_priv->vram_size;\r\nvmw_print_capabilities(dev_priv->capabilities);\r\nif (dev_priv->capabilities & SVGA_CAP_GMR2) {\r\nDRM_INFO("Max GMR ids is %u\n",\r\n(unsigned)dev_priv->max_gmr_ids);\r\nDRM_INFO("Max number of GMR pages is %u\n",\r\n(unsigned)dev_priv->max_gmr_pages);\r\nDRM_INFO("Max dedicated hypervisor surface memory is %u kiB\n",\r\n(unsigned)dev_priv->memory_size / 1024);\r\n}\r\nDRM_INFO("Maximum display memory size is %u kiB\n",\r\ndev_priv->prim_bb_mem / 1024);\r\nDRM_INFO("VRAM at 0x%08x size is %u kiB\n",\r\ndev_priv->vram_start, dev_priv->vram_size / 1024);\r\nDRM_INFO("MMIO at 0x%08x size is %u kiB\n",\r\ndev_priv->mmio_start, dev_priv->mmio_size / 1024);\r\nret = vmw_ttm_global_init(dev_priv);\r\nif (unlikely(ret != 0))\r\ngoto out_err0;\r\nvmw_master_init(&dev_priv->fbdev_master);\r\nttm_lock_set_kill(&dev_priv->fbdev_master.lock, false, SIGTERM);\r\ndev_priv->active_master = &dev_priv->fbdev_master;\r\nret = ttm_bo_device_init(&dev_priv->bdev,\r\ndev_priv->bo_global_ref.ref.object,\r\n&vmw_bo_driver,\r\ndev->anon_inode->i_mapping,\r\nVMWGFX_FILE_PAGE_OFFSET,\r\nfalse);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Failed initializing TTM buffer object driver.\n");\r\ngoto out_err1;\r\n}\r\ndev_priv->mmio_mtrr = arch_phys_wc_add(dev_priv->mmio_start,\r\ndev_priv->mmio_size);\r\ndev_priv->mmio_virt = ioremap_wc(dev_priv->mmio_start,\r\ndev_priv->mmio_size);\r\nif (unlikely(dev_priv->mmio_virt == NULL)) {\r\nret = -ENOMEM;\r\nDRM_ERROR("Failed mapping MMIO.\n");\r\ngoto out_err3;\r\n}\r\nif (!(dev_priv->capabilities & SVGA_CAP_DISPLAY_TOPOLOGY) &&\r\n!(dev_priv->capabilities & SVGA_CAP_PITCHLOCK) &&\r\n!vmw_fifo_have_pitchlock(dev_priv)) {\r\nret = -ENOSYS;\r\nDRM_ERROR("Hardware has no pitchlock\n");\r\ngoto out_err4;\r\n}\r\ndev_priv->tdev = ttm_object_device_init\r\n(dev_priv->mem_global_ref.object, 12, &vmw_prime_dmabuf_ops);\r\nif (unlikely(dev_priv->tdev == NULL)) {\r\nDRM_ERROR("Unable to initialize TTM object management.\n");\r\nret = -ENOMEM;\r\ngoto out_err4;\r\n}\r\ndev->dev_private = dev_priv;\r\nret = pci_request_regions(dev->pdev, "vmwgfx probe");\r\ndev_priv->stealth = (ret != 0);\r\nif (dev_priv->stealth) {\r\nDRM_INFO("It appears like vesafb is loaded. "\r\n"Ignore above error if any.\n");\r\nret = pci_request_region(dev->pdev, 2, "vmwgfx stealth probe");\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Failed reserving the SVGA MMIO resource.\n");\r\ngoto out_no_device;\r\n}\r\n}\r\nif (dev_priv->capabilities & SVGA_CAP_IRQMASK) {\r\nret = drm_irq_install(dev, dev->pdev->irq);\r\nif (ret != 0) {\r\nDRM_ERROR("Failed installing irq: %d\n", ret);\r\ngoto out_no_irq;\r\n}\r\n}\r\ndev_priv->fman = vmw_fence_manager_init(dev_priv);\r\nif (unlikely(dev_priv->fman == NULL)) {\r\nret = -ENOMEM;\r\ngoto out_no_fman;\r\n}\r\nret = ttm_bo_init_mm(&dev_priv->bdev, TTM_PL_VRAM,\r\n(dev_priv->vram_size >> PAGE_SHIFT));\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Failed initializing memory manager for VRAM.\n");\r\ngoto out_no_vram;\r\n}\r\ndev_priv->has_gmr = true;\r\nif (((dev_priv->capabilities & (SVGA_CAP_GMR | SVGA_CAP_GMR2)) == 0) ||\r\nrefuse_dma || ttm_bo_init_mm(&dev_priv->bdev, VMW_PL_GMR,\r\nVMW_PL_GMR) != 0) {\r\nDRM_INFO("No GMR memory available. "\r\n"Graphics memory resources are very limited.\n");\r\ndev_priv->has_gmr = false;\r\n}\r\nif (dev_priv->capabilities & SVGA_CAP_GBOBJECTS) {\r\ndev_priv->has_mob = true;\r\nif (ttm_bo_init_mm(&dev_priv->bdev, VMW_PL_MOB,\r\nVMW_PL_MOB) != 0) {\r\nDRM_INFO("No MOB memory available. "\r\n"3D will be disabled.\n");\r\ndev_priv->has_mob = false;\r\n}\r\n}\r\nvmw_kms_save_vga(dev_priv);\r\nret = vmw_kms_init(dev_priv);\r\nif (unlikely(ret != 0))\r\ngoto out_no_kms;\r\nvmw_overlay_init(dev_priv);\r\nif (dev_priv->enable_fb) {\r\nret = vmw_3d_resource_inc(dev_priv, true);\r\nif (unlikely(ret != 0))\r\ngoto out_no_fifo;\r\nvmw_fb_init(dev_priv);\r\n}\r\ndev_priv->pm_nb.notifier_call = vmwgfx_pm_notifier;\r\nregister_pm_notifier(&dev_priv->pm_nb);\r\nreturn 0;\r\nout_no_fifo:\r\nvmw_overlay_close(dev_priv);\r\nvmw_kms_close(dev_priv);\r\nout_no_kms:\r\nvmw_kms_restore_vga(dev_priv);\r\nif (dev_priv->has_mob)\r\n(void) ttm_bo_clean_mm(&dev_priv->bdev, VMW_PL_MOB);\r\nif (dev_priv->has_gmr)\r\n(void) ttm_bo_clean_mm(&dev_priv->bdev, VMW_PL_GMR);\r\n(void)ttm_bo_clean_mm(&dev_priv->bdev, TTM_PL_VRAM);\r\nout_no_vram:\r\nvmw_fence_manager_takedown(dev_priv->fman);\r\nout_no_fman:\r\nif (dev_priv->capabilities & SVGA_CAP_IRQMASK)\r\ndrm_irq_uninstall(dev_priv->dev);\r\nout_no_irq:\r\nif (dev_priv->stealth)\r\npci_release_region(dev->pdev, 2);\r\nelse\r\npci_release_regions(dev->pdev);\r\nout_no_device:\r\nttm_object_device_release(&dev_priv->tdev);\r\nout_err4:\r\niounmap(dev_priv->mmio_virt);\r\nout_err3:\r\narch_phys_wc_del(dev_priv->mmio_mtrr);\r\n(void)ttm_bo_device_release(&dev_priv->bdev);\r\nout_err1:\r\nvmw_ttm_global_release(dev_priv);\r\nout_err0:\r\nfor (i = vmw_res_context; i < vmw_res_max; ++i)\r\nidr_destroy(&dev_priv->res_idr[i]);\r\nkfree(dev_priv);\r\nreturn ret;\r\n}\r\nstatic int vmw_driver_unload(struct drm_device *dev)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nenum vmw_res_type i;\r\nunregister_pm_notifier(&dev_priv->pm_nb);\r\nif (dev_priv->ctx.res_ht_initialized)\r\ndrm_ht_remove(&dev_priv->ctx.res_ht);\r\nvfree(dev_priv->ctx.cmd_bounce);\r\nif (dev_priv->enable_fb) {\r\nvmw_fb_close(dev_priv);\r\nvmw_kms_restore_vga(dev_priv);\r\nvmw_3d_resource_dec(dev_priv, false);\r\n}\r\nvmw_kms_close(dev_priv);\r\nvmw_overlay_close(dev_priv);\r\nif (dev_priv->has_mob)\r\n(void) ttm_bo_clean_mm(&dev_priv->bdev, VMW_PL_MOB);\r\nif (dev_priv->has_gmr)\r\n(void)ttm_bo_clean_mm(&dev_priv->bdev, VMW_PL_GMR);\r\n(void)ttm_bo_clean_mm(&dev_priv->bdev, TTM_PL_VRAM);\r\nvmw_fence_manager_takedown(dev_priv->fman);\r\nif (dev_priv->capabilities & SVGA_CAP_IRQMASK)\r\ndrm_irq_uninstall(dev_priv->dev);\r\nif (dev_priv->stealth)\r\npci_release_region(dev->pdev, 2);\r\nelse\r\npci_release_regions(dev->pdev);\r\nttm_object_device_release(&dev_priv->tdev);\r\niounmap(dev_priv->mmio_virt);\r\narch_phys_wc_del(dev_priv->mmio_mtrr);\r\n(void)ttm_bo_device_release(&dev_priv->bdev);\r\nvmw_ttm_global_release(dev_priv);\r\nfor (i = vmw_res_context; i < vmw_res_max; ++i)\r\nidr_destroy(&dev_priv->res_idr[i]);\r\nkfree(dev_priv);\r\nreturn 0;\r\n}\r\nstatic void vmw_preclose(struct drm_device *dev,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct vmw_fpriv *vmw_fp = vmw_fpriv(file_priv);\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nvmw_event_fence_fpriv_gone(dev_priv->fman, &vmw_fp->fence_events);\r\n}\r\nstatic void vmw_postclose(struct drm_device *dev,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct vmw_fpriv *vmw_fp;\r\nvmw_fp = vmw_fpriv(file_priv);\r\nif (vmw_fp->locked_master) {\r\nstruct vmw_master *vmaster =\r\nvmw_master(vmw_fp->locked_master);\r\nttm_lock_set_kill(&vmaster->lock, true, SIGTERM);\r\nttm_vt_unlock(&vmaster->lock);\r\ndrm_master_put(&vmw_fp->locked_master);\r\n}\r\nttm_object_file_release(&vmw_fp->tfile);\r\nkfree(vmw_fp);\r\n}\r\nstatic int vmw_driver_open(struct drm_device *dev, struct drm_file *file_priv)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct vmw_fpriv *vmw_fp;\r\nint ret = -ENOMEM;\r\nvmw_fp = kzalloc(sizeof(*vmw_fp), GFP_KERNEL);\r\nif (unlikely(vmw_fp == NULL))\r\nreturn ret;\r\nINIT_LIST_HEAD(&vmw_fp->fence_events);\r\nvmw_fp->tfile = ttm_object_file_init(dev_priv->tdev, 10);\r\nif (unlikely(vmw_fp->tfile == NULL))\r\ngoto out_no_tfile;\r\nfile_priv->driver_priv = vmw_fp;\r\nreturn 0;\r\nout_no_tfile:\r\nkfree(vmw_fp);\r\nreturn ret;\r\n}\r\nstatic struct vmw_master *vmw_master_check(struct drm_device *dev,\r\nstruct drm_file *file_priv,\r\nunsigned int flags)\r\n{\r\nint ret;\r\nstruct vmw_fpriv *vmw_fp = vmw_fpriv(file_priv);\r\nstruct vmw_master *vmaster;\r\nif (file_priv->minor->type != DRM_MINOR_LEGACY ||\r\n!(flags & DRM_AUTH))\r\nreturn NULL;\r\nret = mutex_lock_interruptible(&dev->master_mutex);\r\nif (unlikely(ret != 0))\r\nreturn ERR_PTR(-ERESTARTSYS);\r\nif (file_priv->is_master) {\r\nmutex_unlock(&dev->master_mutex);\r\nreturn NULL;\r\n}\r\nif (vmw_fp->locked_master) {\r\nmutex_unlock(&dev->master_mutex);\r\nDRM_ERROR("Dropped master trying to access ioctl that "\r\n"requires authentication.\n");\r\nreturn ERR_PTR(-EACCES);\r\n}\r\nmutex_unlock(&dev->master_mutex);\r\nif (!(flags & DRM_UNLOCKED)) {\r\nDRM_ERROR("Refusing locked ioctl access.\n");\r\nreturn ERR_PTR(-EDEADLK);\r\n}\r\nvmaster = vmw_master(file_priv->master);\r\nret = ttm_read_lock(&vmaster->lock, true);\r\nif (unlikely(ret != 0))\r\nvmaster = ERR_PTR(ret);\r\nreturn vmaster;\r\n}\r\nstatic long vmw_generic_ioctl(struct file *filp, unsigned int cmd,\r\nunsigned long arg,\r\nlong (*ioctl_func)(struct file *, unsigned int,\r\nunsigned long))\r\n{\r\nstruct drm_file *file_priv = filp->private_data;\r\nstruct drm_device *dev = file_priv->minor->dev;\r\nunsigned int nr = DRM_IOCTL_NR(cmd);\r\nstruct vmw_master *vmaster;\r\nunsigned int flags;\r\nlong ret;\r\nif ((nr >= DRM_COMMAND_BASE) && (nr < DRM_COMMAND_END)\r\n&& (nr < DRM_COMMAND_BASE + dev->driver->num_ioctls)) {\r\nconst struct drm_ioctl_desc *ioctl =\r\n&vmw_ioctls[nr - DRM_COMMAND_BASE];\r\nif (unlikely(ioctl->cmd != cmd)) {\r\nDRM_ERROR("Invalid command format, ioctl %d\n",\r\nnr - DRM_COMMAND_BASE);\r\nreturn -EINVAL;\r\n}\r\nflags = ioctl->flags;\r\n} else if (!drm_ioctl_flags(nr, &flags))\r\nreturn -EINVAL;\r\nvmaster = vmw_master_check(dev, file_priv, flags);\r\nif (unlikely(IS_ERR(vmaster))) {\r\nret = PTR_ERR(vmaster);\r\nif (ret != -ERESTARTSYS)\r\nDRM_INFO("IOCTL ERROR Command %d, Error %ld.\n",\r\nnr, ret);\r\nreturn ret;\r\n}\r\nret = ioctl_func(filp, cmd, arg);\r\nif (vmaster)\r\nttm_read_unlock(&vmaster->lock);\r\nreturn ret;\r\n}\r\nstatic long vmw_unlocked_ioctl(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nreturn vmw_generic_ioctl(filp, cmd, arg, &drm_ioctl);\r\n}\r\nstatic long vmw_compat_ioctl(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nreturn vmw_generic_ioctl(filp, cmd, arg, &drm_compat_ioctl);\r\n}\r\nstatic void vmw_lastclose(struct drm_device *dev)\r\n{\r\nstruct drm_crtc *crtc;\r\nstruct drm_mode_set set;\r\nint ret;\r\nset.x = 0;\r\nset.y = 0;\r\nset.fb = NULL;\r\nset.mode = NULL;\r\nset.connectors = NULL;\r\nset.num_connectors = 0;\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nset.crtc = crtc;\r\nret = drm_mode_set_config_internal(&set);\r\nWARN_ON(ret != 0);\r\n}\r\n}\r\nstatic void vmw_master_init(struct vmw_master *vmaster)\r\n{\r\nttm_lock_init(&vmaster->lock);\r\nINIT_LIST_HEAD(&vmaster->fb_surf);\r\nmutex_init(&vmaster->fb_surf_mutex);\r\n}\r\nstatic int vmw_master_create(struct drm_device *dev,\r\nstruct drm_master *master)\r\n{\r\nstruct vmw_master *vmaster;\r\nvmaster = kzalloc(sizeof(*vmaster), GFP_KERNEL);\r\nif (unlikely(vmaster == NULL))\r\nreturn -ENOMEM;\r\nvmw_master_init(vmaster);\r\nttm_lock_set_kill(&vmaster->lock, true, SIGTERM);\r\nmaster->driver_priv = vmaster;\r\nreturn 0;\r\n}\r\nstatic void vmw_master_destroy(struct drm_device *dev,\r\nstruct drm_master *master)\r\n{\r\nstruct vmw_master *vmaster = vmw_master(master);\r\nmaster->driver_priv = NULL;\r\nkfree(vmaster);\r\n}\r\nstatic int vmw_master_set(struct drm_device *dev,\r\nstruct drm_file *file_priv,\r\nbool from_open)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct vmw_fpriv *vmw_fp = vmw_fpriv(file_priv);\r\nstruct vmw_master *active = dev_priv->active_master;\r\nstruct vmw_master *vmaster = vmw_master(file_priv->master);\r\nint ret = 0;\r\nif (!dev_priv->enable_fb) {\r\nret = vmw_3d_resource_inc(dev_priv, true);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nvmw_kms_save_vga(dev_priv);\r\nvmw_write(dev_priv, SVGA_REG_TRACES, 0);\r\n}\r\nif (active) {\r\nBUG_ON(active != &dev_priv->fbdev_master);\r\nret = ttm_vt_lock(&active->lock, false, vmw_fp->tfile);\r\nif (unlikely(ret != 0))\r\ngoto out_no_active_lock;\r\nttm_lock_set_kill(&active->lock, true, SIGTERM);\r\nret = ttm_bo_evict_mm(&dev_priv->bdev, TTM_PL_VRAM);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Unable to clean VRAM on "\r\n"master drop.\n");\r\n}\r\ndev_priv->active_master = NULL;\r\n}\r\nttm_lock_set_kill(&vmaster->lock, false, SIGTERM);\r\nif (!from_open) {\r\nttm_vt_unlock(&vmaster->lock);\r\nBUG_ON(vmw_fp->locked_master != file_priv->master);\r\ndrm_master_put(&vmw_fp->locked_master);\r\n}\r\ndev_priv->active_master = vmaster;\r\nreturn 0;\r\nout_no_active_lock:\r\nif (!dev_priv->enable_fb) {\r\nvmw_kms_restore_vga(dev_priv);\r\nvmw_3d_resource_dec(dev_priv, true);\r\nvmw_write(dev_priv, SVGA_REG_TRACES, 1);\r\n}\r\nreturn ret;\r\n}\r\nstatic void vmw_master_drop(struct drm_device *dev,\r\nstruct drm_file *file_priv,\r\nbool from_release)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct vmw_fpriv *vmw_fp = vmw_fpriv(file_priv);\r\nstruct vmw_master *vmaster = vmw_master(file_priv->master);\r\nint ret;\r\nvmw_fp->locked_master = drm_master_get(file_priv->master);\r\nret = ttm_vt_lock(&vmaster->lock, false, vmw_fp->tfile);\r\nif (unlikely((ret != 0))) {\r\nDRM_ERROR("Unable to lock TTM at VT switch.\n");\r\ndrm_master_put(&vmw_fp->locked_master);\r\n}\r\nttm_lock_set_kill(&vmaster->lock, false, SIGTERM);\r\nvmw_execbuf_release_pinned_bo(dev_priv);\r\nif (!dev_priv->enable_fb) {\r\nret = ttm_bo_evict_mm(&dev_priv->bdev, TTM_PL_VRAM);\r\nif (unlikely(ret != 0))\r\nDRM_ERROR("Unable to clean VRAM on master drop.\n");\r\nvmw_kms_restore_vga(dev_priv);\r\nvmw_3d_resource_dec(dev_priv, true);\r\nvmw_write(dev_priv, SVGA_REG_TRACES, 1);\r\n}\r\ndev_priv->active_master = &dev_priv->fbdev_master;\r\nttm_lock_set_kill(&dev_priv->fbdev_master.lock, false, SIGTERM);\r\nttm_vt_unlock(&dev_priv->fbdev_master.lock);\r\nif (dev_priv->enable_fb)\r\nvmw_fb_on(dev_priv);\r\n}\r\nstatic void vmw_remove(struct pci_dev *pdev)\r\n{\r\nstruct drm_device *dev = pci_get_drvdata(pdev);\r\npci_disable_device(pdev);\r\ndrm_put_dev(dev);\r\n}\r\nstatic int vmwgfx_pm_notifier(struct notifier_block *nb, unsigned long val,\r\nvoid *ptr)\r\n{\r\nstruct vmw_private *dev_priv =\r\ncontainer_of(nb, struct vmw_private, pm_nb);\r\nswitch (val) {\r\ncase PM_HIBERNATION_PREPARE:\r\ncase PM_SUSPEND_PREPARE:\r\nttm_suspend_lock(&dev_priv->reservation_sem);\r\nvmw_execbuf_release_pinned_bo(dev_priv);\r\nvmw_resource_evict_all(dev_priv);\r\nttm_bo_swapout_all(&dev_priv->bdev);\r\nbreak;\r\ncase PM_POST_HIBERNATION:\r\ncase PM_POST_SUSPEND:\r\ncase PM_POST_RESTORE:\r\nttm_suspend_unlock(&dev_priv->reservation_sem);\r\nbreak;\r\ncase PM_RESTORE_PREPARE:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vmw_pci_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct drm_device *dev = pci_get_drvdata(pdev);\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nif (dev_priv->num_3d_resources != 0) {\r\nDRM_INFO("Can't suspend or hibernate "\r\n"while 3D resources are active.\n");\r\nreturn -EBUSY;\r\n}\r\npci_save_state(pdev);\r\npci_disable_device(pdev);\r\npci_set_power_state(pdev, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic int vmw_pci_resume(struct pci_dev *pdev)\r\n{\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nreturn pci_enable_device(pdev);\r\n}\r\nstatic int vmw_pm_suspend(struct device *kdev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(kdev);\r\nstruct pm_message dummy;\r\ndummy.event = 0;\r\nreturn vmw_pci_suspend(pdev, dummy);\r\n}\r\nstatic int vmw_pm_resume(struct device *kdev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(kdev);\r\nreturn vmw_pci_resume(pdev);\r\n}\r\nstatic int vmw_pm_prepare(struct device *kdev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(kdev);\r\nstruct drm_device *dev = pci_get_drvdata(pdev);\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\ndev_priv->suspended = true;\r\nif (dev_priv->enable_fb)\r\nvmw_3d_resource_dec(dev_priv, true);\r\nif (dev_priv->num_3d_resources != 0) {\r\nDRM_INFO("Can't suspend or hibernate "\r\n"while 3D resources are active.\n");\r\nif (dev_priv->enable_fb)\r\nvmw_3d_resource_inc(dev_priv, true);\r\ndev_priv->suspended = false;\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic void vmw_pm_complete(struct device *kdev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(kdev);\r\nstruct drm_device *dev = pci_get_drvdata(pdev);\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nvmw_write(dev_priv, SVGA_REG_ID, SVGA_ID_2);\r\n(void) vmw_read(dev_priv, SVGA_REG_ID);\r\nif (dev_priv->enable_fb)\r\nvmw_3d_resource_inc(dev_priv, false);\r\ndev_priv->suspended = false;\r\n}\r\nstatic int vmw_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nreturn drm_get_pci_dev(pdev, ent, &driver);\r\n}\r\nstatic int __init vmwgfx_init(void)\r\n{\r\nint ret;\r\nret = drm_pci_init(&driver, &vmw_pci_driver);\r\nif (ret)\r\nDRM_ERROR("Failed initializing DRM.\n");\r\nreturn ret;\r\n}\r\nstatic void __exit vmwgfx_exit(void)\r\n{\r\ndrm_pci_exit(&driver, &vmw_pci_driver);\r\n}
