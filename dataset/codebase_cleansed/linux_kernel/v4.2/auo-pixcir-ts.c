static int auo_pixcir_collect_data(struct auo_pixcir_ts *ts,\r\nstruct auo_point_t *point)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nconst struct auo_pixcir_ts_platdata *pdata = ts->pdata;\r\nuint8_t raw_coord[8];\r\nuint8_t raw_area[4];\r\nint i, ret;\r\nret = i2c_smbus_read_i2c_block_data(client, AUO_PIXCIR_REG_X1_LSB,\r\n8, raw_coord);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "failed to read coordinate, %d\n", ret);\r\nreturn ret;\r\n}\r\nret = i2c_smbus_read_i2c_block_data(client, AUO_PIXCIR_REG_TOUCHAREA_X1,\r\n4, raw_area);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "could not read touch area, %d\n", ret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < AUO_PIXCIR_REPORT_POINTS; i++) {\r\npoint[i].coord_x =\r\nraw_coord[4 * i + 1] << 8 | raw_coord[4 * i];\r\npoint[i].coord_y =\r\nraw_coord[4 * i + 3] << 8 | raw_coord[4 * i + 2];\r\nif (point[i].coord_x > pdata->x_max ||\r\npoint[i].coord_y > pdata->y_max) {\r\ndev_warn(&client->dev, "coordinates (%d,%d) invalid\n",\r\npoint[i].coord_x, point[i].coord_y);\r\npoint[i].coord_x = point[i].coord_y = 0;\r\n}\r\npoint[i].area_major = max(raw_area[2 * i], raw_area[2 * i + 1]);\r\npoint[i].area_minor = min(raw_area[2 * i], raw_area[2 * i + 1]);\r\npoint[i].orientation = raw_area[2 * i] > raw_area[2 * i + 1];\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t auo_pixcir_interrupt(int irq, void *dev_id)\r\n{\r\nstruct auo_pixcir_ts *ts = dev_id;\r\nconst struct auo_pixcir_ts_platdata *pdata = ts->pdata;\r\nstruct auo_point_t point[AUO_PIXCIR_REPORT_POINTS];\r\nint i;\r\nint ret;\r\nint fingers = 0;\r\nint abs = -1;\r\nwhile (!ts->stopped) {\r\nif (ts->touch_ind_mode) {\r\nif (gpio_get_value(pdata->gpio_int) == 0) {\r\ninput_mt_sync(ts->input);\r\ninput_report_key(ts->input, BTN_TOUCH, 0);\r\ninput_sync(ts->input);\r\nbreak;\r\n}\r\n}\r\nret = auo_pixcir_collect_data(ts, point);\r\nif (ret < 0) {\r\nif (!ts->touch_ind_mode)\r\nbreak;\r\nwait_event_timeout(ts->wait, ts->stopped,\r\nmsecs_to_jiffies(AUO_PIXCIR_PENUP_TIMEOUT_MS));\r\ncontinue;\r\n}\r\nfor (i = 0; i < AUO_PIXCIR_REPORT_POINTS; i++) {\r\nif (point[i].coord_x > 0 || point[i].coord_y > 0) {\r\ninput_report_abs(ts->input, ABS_MT_POSITION_X,\r\npoint[i].coord_x);\r\ninput_report_abs(ts->input, ABS_MT_POSITION_Y,\r\npoint[i].coord_y);\r\ninput_report_abs(ts->input, ABS_MT_TOUCH_MAJOR,\r\npoint[i].area_major);\r\ninput_report_abs(ts->input, ABS_MT_TOUCH_MINOR,\r\npoint[i].area_minor);\r\ninput_report_abs(ts->input, ABS_MT_ORIENTATION,\r\npoint[i].orientation);\r\ninput_mt_sync(ts->input);\r\nif (fingers == 0)\r\nabs = i;\r\nfingers++;\r\n}\r\n}\r\ninput_report_key(ts->input, BTN_TOUCH, fingers > 0);\r\nif (abs > -1) {\r\ninput_report_abs(ts->input, ABS_X, point[abs].coord_x);\r\ninput_report_abs(ts->input, ABS_Y, point[abs].coord_y);\r\n}\r\ninput_sync(ts->input);\r\nif (!ts->touch_ind_mode)\r\nbreak;\r\nwait_event_timeout(ts->wait, ts->stopped,\r\nmsecs_to_jiffies(AUO_PIXCIR_PENUP_TIMEOUT_MS));\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int auo_pixcir_power_mode(struct auo_pixcir_ts *ts, int mode)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nint ret;\r\nret = i2c_smbus_read_byte_data(client, AUO_PIXCIR_REG_POWER_MODE);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "unable to read reg %Xh, %d\n",\r\nAUO_PIXCIR_REG_POWER_MODE, ret);\r\nreturn ret;\r\n}\r\nret &= ~AUO_PIXCIR_POWER_MASK;\r\nret |= mode;\r\nret = i2c_smbus_write_byte_data(client, AUO_PIXCIR_REG_POWER_MODE, ret);\r\nif (ret) {\r\ndev_err(&client->dev, "unable to write reg %Xh, %d\n",\r\nAUO_PIXCIR_REG_POWER_MODE, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int auo_pixcir_int_config(struct auo_pixcir_ts *ts,\r\nint int_setting)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nconst struct auo_pixcir_ts_platdata *pdata = ts->pdata;\r\nint ret;\r\nret = i2c_smbus_read_byte_data(client, AUO_PIXCIR_REG_INT_SETTING);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "unable to read reg %Xh, %d\n",\r\nAUO_PIXCIR_REG_INT_SETTING, ret);\r\nreturn ret;\r\n}\r\nret &= ~AUO_PIXCIR_INT_MODE_MASK;\r\nret |= int_setting;\r\nret |= AUO_PIXCIR_INT_POL_HIGH;\r\nret = i2c_smbus_write_byte_data(client, AUO_PIXCIR_REG_INT_SETTING,\r\nret);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "unable to write reg %Xh, %d\n",\r\nAUO_PIXCIR_REG_INT_SETTING, ret);\r\nreturn ret;\r\n}\r\nts->touch_ind_mode = pdata->int_setting == AUO_PIXCIR_INT_TOUCH_IND;\r\nreturn 0;\r\n}\r\nstatic int auo_pixcir_int_toggle(struct auo_pixcir_ts *ts, bool enable)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nint ret;\r\nret = i2c_smbus_read_byte_data(client, AUO_PIXCIR_REG_INT_SETTING);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "unable to read reg %Xh, %d\n",\r\nAUO_PIXCIR_REG_INT_SETTING, ret);\r\nreturn ret;\r\n}\r\nif (enable)\r\nret |= AUO_PIXCIR_INT_ENABLE;\r\nelse\r\nret &= ~AUO_PIXCIR_INT_ENABLE;\r\nret = i2c_smbus_write_byte_data(client, AUO_PIXCIR_REG_INT_SETTING,\r\nret);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "unable to write reg %Xh, %d\n",\r\nAUO_PIXCIR_REG_INT_SETTING, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int auo_pixcir_start(struct auo_pixcir_ts *ts)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nint ret;\r\nret = auo_pixcir_power_mode(ts, AUO_PIXCIR_POWER_ACTIVE);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "could not set power mode, %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nts->stopped = false;\r\nmb();\r\nenable_irq(client->irq);\r\nret = auo_pixcir_int_toggle(ts, 1);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "could not enable interrupt, %d\n",\r\nret);\r\ndisable_irq(client->irq);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int auo_pixcir_stop(struct auo_pixcir_ts *ts)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nint ret;\r\nret = auo_pixcir_int_toggle(ts, 0);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "could not disable interrupt, %d\n",\r\nret);\r\nreturn ret;\r\n}\r\ndisable_irq(client->irq);\r\nts->stopped = true;\r\nmb();\r\nwake_up(&ts->wait);\r\nreturn auo_pixcir_power_mode(ts, AUO_PIXCIR_POWER_DEEP_SLEEP);\r\n}\r\nstatic int auo_pixcir_input_open(struct input_dev *dev)\r\n{\r\nstruct auo_pixcir_ts *ts = input_get_drvdata(dev);\r\nint ret;\r\nret = auo_pixcir_start(ts);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void auo_pixcir_input_close(struct input_dev *dev)\r\n{\r\nstruct auo_pixcir_ts *ts = input_get_drvdata(dev);\r\nauo_pixcir_stop(ts);\r\nreturn;\r\n}\r\nstatic int __maybe_unused auo_pixcir_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct auo_pixcir_ts *ts = i2c_get_clientdata(client);\r\nstruct input_dev *input = ts->input;\r\nint ret = 0;\r\nmutex_lock(&input->mutex);\r\nif (device_may_wakeup(&client->dev)) {\r\nif (!input->users) {\r\nret = auo_pixcir_start(ts);\r\nif (ret)\r\ngoto unlock;\r\n}\r\nenable_irq_wake(client->irq);\r\nret = auo_pixcir_power_mode(ts, AUO_PIXCIR_POWER_SLEEP);\r\n} else if (input->users) {\r\nret = auo_pixcir_stop(ts);\r\n}\r\nunlock:\r\nmutex_unlock(&input->mutex);\r\nreturn ret;\r\n}\r\nstatic int __maybe_unused auo_pixcir_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct auo_pixcir_ts *ts = i2c_get_clientdata(client);\r\nstruct input_dev *input = ts->input;\r\nint ret = 0;\r\nmutex_lock(&input->mutex);\r\nif (device_may_wakeup(&client->dev)) {\r\ndisable_irq_wake(client->irq);\r\nif (!input->users) {\r\nret = auo_pixcir_stop(ts);\r\nif (ret)\r\ngoto unlock;\r\n}\r\n} else if (input->users) {\r\nret = auo_pixcir_start(ts);\r\n}\r\nunlock:\r\nmutex_unlock(&input->mutex);\r\nreturn ret;\r\n}\r\nstatic struct auo_pixcir_ts_platdata *auo_pixcir_parse_dt(struct device *dev)\r\n{\r\nstruct auo_pixcir_ts_platdata *pdata;\r\nstruct device_node *np = dev->of_node;\r\nif (!np)\r\nreturn ERR_PTR(-ENOENT);\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata) {\r\ndev_err(dev, "failed to allocate platform data\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\npdata->gpio_int = of_get_gpio(np, 0);\r\nif (!gpio_is_valid(pdata->gpio_int)) {\r\ndev_err(dev, "failed to get interrupt gpio\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\npdata->gpio_rst = of_get_gpio(np, 1);\r\nif (!gpio_is_valid(pdata->gpio_rst)) {\r\ndev_err(dev, "failed to get reset gpio\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (of_property_read_u32(np, "x-size", &pdata->x_max)) {\r\ndev_err(dev, "failed to get x-size property\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (of_property_read_u32(np, "y-size", &pdata->y_max)) {\r\ndev_err(dev, "failed to get y-size property\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\npdata->int_setting = AUO_PIXCIR_INT_TOUCH_IND;\r\nreturn pdata;\r\n}\r\nstatic struct auo_pixcir_ts_platdata *auo_pixcir_parse_dt(struct device *dev)\r\n{\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic void auo_pixcir_reset(void *data)\r\n{\r\nstruct auo_pixcir_ts *ts = data;\r\ngpio_set_value(ts->pdata->gpio_rst, 0);\r\n}\r\nstatic int auo_pixcir_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct auo_pixcir_ts_platdata *pdata;\r\nstruct auo_pixcir_ts *ts;\r\nstruct input_dev *input_dev;\r\nint version;\r\nint error;\r\npdata = dev_get_platdata(&client->dev);\r\nif (!pdata) {\r\npdata = auo_pixcir_parse_dt(&client->dev);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\n}\r\nts = devm_kzalloc(&client->dev,\r\nsizeof(struct auo_pixcir_ts), GFP_KERNEL);\r\nif (!ts)\r\nreturn -ENOMEM;\r\ninput_dev = devm_input_allocate_device(&client->dev);\r\nif (!input_dev) {\r\ndev_err(&client->dev, "could not allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\nts->pdata = pdata;\r\nts->client = client;\r\nts->input = input_dev;\r\nts->touch_ind_mode = 0;\r\nts->stopped = true;\r\ninit_waitqueue_head(&ts->wait);\r\nsnprintf(ts->phys, sizeof(ts->phys),\r\n"%s/input0", dev_name(&client->dev));\r\ninput_dev->name = "AUO-Pixcir touchscreen";\r\ninput_dev->phys = ts->phys;\r\ninput_dev->id.bustype = BUS_I2C;\r\ninput_dev->open = auo_pixcir_input_open;\r\ninput_dev->close = auo_pixcir_input_close;\r\n__set_bit(EV_ABS, input_dev->evbit);\r\n__set_bit(EV_KEY, input_dev->evbit);\r\n__set_bit(BTN_TOUCH, input_dev->keybit);\r\ninput_set_abs_params(input_dev, ABS_X, 0, pdata->x_max, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, 0, pdata->y_max, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_POSITION_X, 0,\r\npdata->x_max, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0,\r\npdata->y_max, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0,\r\nAUO_PIXCIR_MAX_AREA, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_TOUCH_MINOR, 0,\r\nAUO_PIXCIR_MAX_AREA, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_ORIENTATION, 0, 1, 0, 0);\r\ninput_set_drvdata(ts->input, ts);\r\nerror = devm_gpio_request_one(&client->dev, pdata->gpio_int,\r\nGPIOF_DIR_IN, "auo_pixcir_ts_int");\r\nif (error) {\r\ndev_err(&client->dev, "request of gpio %d failed, %d\n",\r\npdata->gpio_int, error);\r\nreturn error;\r\n}\r\nerror = devm_gpio_request_one(&client->dev, pdata->gpio_rst,\r\nGPIOF_DIR_OUT | GPIOF_INIT_HIGH,\r\n"auo_pixcir_ts_rst");\r\nif (error) {\r\ndev_err(&client->dev, "request of gpio %d failed, %d\n",\r\npdata->gpio_rst, error);\r\nreturn error;\r\n}\r\nerror = devm_add_action(&client->dev, auo_pixcir_reset, ts);\r\nif (error) {\r\nauo_pixcir_reset(ts);\r\ndev_err(&client->dev, "failed to register reset action, %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nmsleep(200);\r\nversion = i2c_smbus_read_byte_data(client, AUO_PIXCIR_REG_VERSION);\r\nif (version < 0) {\r\nerror = version;\r\nreturn error;\r\n}\r\ndev_info(&client->dev, "firmware version 0x%X\n", version);\r\nerror = auo_pixcir_int_config(ts, pdata->int_setting);\r\nif (error)\r\nreturn error;\r\nerror = devm_request_threaded_irq(&client->dev, client->irq,\r\nNULL, auo_pixcir_interrupt,\r\nIRQF_TRIGGER_RISING | IRQF_ONESHOT,\r\ninput_dev->name, ts);\r\nif (error) {\r\ndev_err(&client->dev, "irq %d requested failed, %d\n",\r\nclient->irq, error);\r\nreturn error;\r\n}\r\nerror = auo_pixcir_stop(ts);\r\nif (error)\r\nreturn error;\r\nerror = input_register_device(input_dev);\r\nif (error) {\r\ndev_err(&client->dev, "could not register input device, %d\n",\r\nerror);\r\nreturn error;\r\n}\r\ni2c_set_clientdata(client, ts);\r\nreturn 0;\r\n}
