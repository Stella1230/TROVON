STATIC struct posix_acl *\r\nxfs_acl_from_disk(\r\nstruct xfs_acl *aclp,\r\nint max_entries)\r\n{\r\nstruct posix_acl_entry *acl_e;\r\nstruct posix_acl *acl;\r\nstruct xfs_acl_entry *ace;\r\nunsigned int count, i;\r\ncount = be32_to_cpu(aclp->acl_cnt);\r\nif (count > max_entries)\r\nreturn ERR_PTR(-EFSCORRUPTED);\r\nacl = posix_acl_alloc(count, GFP_KERNEL);\r\nif (!acl)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (i = 0; i < count; i++) {\r\nacl_e = &acl->a_entries[i];\r\nace = &aclp->acl_entry[i];\r\nacl_e->e_tag = be32_to_cpu(ace->ae_tag);\r\nacl_e->e_perm = be16_to_cpu(ace->ae_perm);\r\nswitch (acl_e->e_tag) {\r\ncase ACL_USER:\r\nacl_e->e_uid = xfs_uid_to_kuid(be32_to_cpu(ace->ae_id));\r\nbreak;\r\ncase ACL_GROUP:\r\nacl_e->e_gid = xfs_gid_to_kgid(be32_to_cpu(ace->ae_id));\r\nbreak;\r\ncase ACL_USER_OBJ:\r\ncase ACL_GROUP_OBJ:\r\ncase ACL_MASK:\r\ncase ACL_OTHER:\r\nbreak;\r\ndefault:\r\ngoto fail;\r\n}\r\n}\r\nreturn acl;\r\nfail:\r\nposix_acl_release(acl);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nSTATIC void\r\nxfs_acl_to_disk(struct xfs_acl *aclp, const struct posix_acl *acl)\r\n{\r\nconst struct posix_acl_entry *acl_e;\r\nstruct xfs_acl_entry *ace;\r\nint i;\r\naclp->acl_cnt = cpu_to_be32(acl->a_count);\r\nfor (i = 0; i < acl->a_count; i++) {\r\nace = &aclp->acl_entry[i];\r\nacl_e = &acl->a_entries[i];\r\nace->ae_tag = cpu_to_be32(acl_e->e_tag);\r\nswitch (acl_e->e_tag) {\r\ncase ACL_USER:\r\nace->ae_id = cpu_to_be32(xfs_kuid_to_uid(acl_e->e_uid));\r\nbreak;\r\ncase ACL_GROUP:\r\nace->ae_id = cpu_to_be32(xfs_kgid_to_gid(acl_e->e_gid));\r\nbreak;\r\ndefault:\r\nace->ae_id = cpu_to_be32(ACL_UNDEFINED_ID);\r\nbreak;\r\n}\r\nace->ae_perm = cpu_to_be16(acl_e->e_perm);\r\n}\r\n}\r\nstruct posix_acl *\r\nxfs_get_acl(struct inode *inode, int type)\r\n{\r\nstruct xfs_inode *ip = XFS_I(inode);\r\nstruct posix_acl *acl = NULL;\r\nstruct xfs_acl *xfs_acl;\r\nunsigned char *ea_name;\r\nint error;\r\nint len;\r\ntrace_xfs_get_acl(ip);\r\nswitch (type) {\r\ncase ACL_TYPE_ACCESS:\r\nea_name = SGI_ACL_FILE;\r\nbreak;\r\ncase ACL_TYPE_DEFAULT:\r\nea_name = SGI_ACL_DEFAULT;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nlen = XFS_ACL_MAX_SIZE(ip->i_mount);\r\nxfs_acl = kmem_zalloc_large(len, KM_SLEEP);\r\nif (!xfs_acl)\r\nreturn ERR_PTR(-ENOMEM);\r\nerror = xfs_attr_get(ip, ea_name, (unsigned char *)xfs_acl,\r\n&len, ATTR_ROOT);\r\nif (error) {\r\nif (error == -ENOATTR)\r\ngoto out_update_cache;\r\ngoto out;\r\n}\r\nacl = xfs_acl_from_disk(xfs_acl, XFS_ACL_MAX_ENTRIES(ip->i_mount));\r\nif (IS_ERR(acl))\r\ngoto out;\r\nout_update_cache:\r\nset_cached_acl(inode, type, acl);\r\nout:\r\nkmem_free(xfs_acl);\r\nreturn acl;\r\n}\r\nSTATIC int\r\n__xfs_set_acl(struct inode *inode, int type, struct posix_acl *acl)\r\n{\r\nstruct xfs_inode *ip = XFS_I(inode);\r\nunsigned char *ea_name;\r\nint error;\r\nswitch (type) {\r\ncase ACL_TYPE_ACCESS:\r\nea_name = SGI_ACL_FILE;\r\nbreak;\r\ncase ACL_TYPE_DEFAULT:\r\nif (!S_ISDIR(inode->i_mode))\r\nreturn acl ? -EACCES : 0;\r\nea_name = SGI_ACL_DEFAULT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (acl) {\r\nstruct xfs_acl *xfs_acl;\r\nint len = XFS_ACL_MAX_SIZE(ip->i_mount);\r\nxfs_acl = kmem_zalloc_large(len, KM_SLEEP);\r\nif (!xfs_acl)\r\nreturn -ENOMEM;\r\nxfs_acl_to_disk(xfs_acl, acl);\r\nlen -= sizeof(struct xfs_acl_entry) *\r\n(XFS_ACL_MAX_ENTRIES(ip->i_mount) - acl->a_count);\r\nerror = xfs_attr_set(ip, ea_name, (unsigned char *)xfs_acl,\r\nlen, ATTR_ROOT);\r\nkmem_free(xfs_acl);\r\n} else {\r\nerror = xfs_attr_remove(ip, ea_name, ATTR_ROOT);\r\nif (error == -ENOATTR)\r\nerror = 0;\r\n}\r\nif (!error)\r\nset_cached_acl(inode, type, acl);\r\nreturn error;\r\n}\r\nstatic int\r\nxfs_set_mode(struct inode *inode, umode_t mode)\r\n{\r\nint error = 0;\r\nif (mode != inode->i_mode) {\r\nstruct iattr iattr;\r\niattr.ia_valid = ATTR_MODE | ATTR_CTIME;\r\niattr.ia_mode = mode;\r\niattr.ia_ctime = current_fs_time(inode->i_sb);\r\nerror = xfs_setattr_nonsize(XFS_I(inode), &iattr, XFS_ATTR_NOACL);\r\n}\r\nreturn error;\r\n}\r\nstatic int\r\nxfs_acl_exists(struct inode *inode, unsigned char *name)\r\n{\r\nint len = XFS_ACL_MAX_SIZE(XFS_M(inode->i_sb));\r\nreturn (xfs_attr_get(XFS_I(inode), name, NULL, &len,\r\nATTR_ROOT|ATTR_KERNOVAL) == 0);\r\n}\r\nint\r\nposix_acl_access_exists(struct inode *inode)\r\n{\r\nreturn xfs_acl_exists(inode, SGI_ACL_FILE);\r\n}\r\nint\r\nposix_acl_default_exists(struct inode *inode)\r\n{\r\nif (!S_ISDIR(inode->i_mode))\r\nreturn 0;\r\nreturn xfs_acl_exists(inode, SGI_ACL_DEFAULT);\r\n}\r\nint\r\nxfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\r\n{\r\nint error = 0;\r\nif (!acl)\r\ngoto set_acl;\r\nerror = -E2BIG;\r\nif (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))\r\nreturn error;\r\nif (type == ACL_TYPE_ACCESS) {\r\numode_t mode = inode->i_mode;\r\nerror = posix_acl_equiv_mode(acl, &mode);\r\nif (error <= 0) {\r\nacl = NULL;\r\nif (error < 0)\r\nreturn error;\r\n}\r\nerror = xfs_set_mode(inode, mode);\r\nif (error)\r\nreturn error;\r\n}\r\nset_acl:\r\nreturn __xfs_set_acl(inode, type, acl);\r\n}
