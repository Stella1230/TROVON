static void bfin_spi_enable(struct bfin_spi_master_data *drv_data)\r\n{\r\nbfin_write_or(&drv_data->regs->ctl, BIT_CTL_ENABLE);\r\n}\r\nstatic void bfin_spi_disable(struct bfin_spi_master_data *drv_data)\r\n{\r\nbfin_write_and(&drv_data->regs->ctl, ~BIT_CTL_ENABLE);\r\n}\r\nstatic u16 hz_to_spi_baud(u32 speed_hz)\r\n{\r\nu_long sclk = get_sclk();\r\nu16 spi_baud = (sclk / (2 * speed_hz));\r\nif ((sclk % (2 * speed_hz)) > 0)\r\nspi_baud++;\r\nif (spi_baud < MIN_SPI_BAUD_VAL)\r\nspi_baud = MIN_SPI_BAUD_VAL;\r\nreturn spi_baud;\r\n}\r\nstatic int bfin_spi_flush(struct bfin_spi_master_data *drv_data)\r\n{\r\nunsigned long limit = loops_per_jiffy << 1;\r\nwhile (!(bfin_read(&drv_data->regs->stat) & BIT_STAT_SPIF) && --limit)\r\ncpu_relax();\r\nbfin_write(&drv_data->regs->stat, BIT_STAT_CLR);\r\nreturn limit;\r\n}\r\nstatic void bfin_spi_cs_active(struct bfin_spi_master_data *drv_data, struct bfin_spi_slave_data *chip)\r\n{\r\nif (likely(chip->chip_select_num < MAX_CTRL_CS))\r\nbfin_write_and(&drv_data->regs->flg, ~chip->flag);\r\nelse\r\ngpio_set_value(chip->cs_gpio, 0);\r\n}\r\nstatic void bfin_spi_cs_deactive(struct bfin_spi_master_data *drv_data,\r\nstruct bfin_spi_slave_data *chip)\r\n{\r\nif (likely(chip->chip_select_num < MAX_CTRL_CS))\r\nbfin_write_or(&drv_data->regs->flg, chip->flag);\r\nelse\r\ngpio_set_value(chip->cs_gpio, 1);\r\nif (chip->cs_chg_udelay)\r\nudelay(chip->cs_chg_udelay);\r\n}\r\nstatic inline void bfin_spi_cs_enable(struct bfin_spi_master_data *drv_data,\r\nstruct bfin_spi_slave_data *chip)\r\n{\r\nif (chip->chip_select_num < MAX_CTRL_CS)\r\nbfin_write_or(&drv_data->regs->flg, chip->flag >> 8);\r\n}\r\nstatic inline void bfin_spi_cs_disable(struct bfin_spi_master_data *drv_data,\r\nstruct bfin_spi_slave_data *chip)\r\n{\r\nif (chip->chip_select_num < MAX_CTRL_CS)\r\nbfin_write_and(&drv_data->regs->flg, ~(chip->flag >> 8));\r\n}\r\nstatic void bfin_spi_restore_state(struct bfin_spi_master_data *drv_data)\r\n{\r\nstruct bfin_spi_slave_data *chip = drv_data->cur_chip;\r\nbfin_write(&drv_data->regs->stat, BIT_STAT_CLR);\r\nbfin_spi_disable(drv_data);\r\ndev_dbg(&drv_data->pdev->dev, "restoring spi ctl state\n");\r\nSSYNC();\r\nbfin_write(&drv_data->regs->ctl, chip->ctl_reg);\r\nbfin_write(&drv_data->regs->baud, chip->baud);\r\nbfin_spi_enable(drv_data);\r\nbfin_spi_cs_active(drv_data, chip);\r\n}\r\nstatic inline void bfin_spi_dummy_read(struct bfin_spi_master_data *drv_data)\r\n{\r\n(void) bfin_read(&drv_data->regs->rdbr);\r\n}\r\nstatic void bfin_spi_u8_writer(struct bfin_spi_master_data *drv_data)\r\n{\r\nbfin_spi_dummy_read(drv_data);\r\nwhile (drv_data->tx < drv_data->tx_end) {\r\nbfin_write(&drv_data->regs->tdbr, (*(u8 *) (drv_data->tx++)));\r\nwhile (!(bfin_read(&drv_data->regs->stat) & BIT_STAT_RXS))\r\ncpu_relax();\r\nbfin_spi_dummy_read(drv_data);\r\n}\r\n}\r\nstatic void bfin_spi_u8_reader(struct bfin_spi_master_data *drv_data)\r\n{\r\nu16 tx_val = drv_data->cur_chip->idle_tx_val;\r\nbfin_spi_dummy_read(drv_data);\r\nwhile (drv_data->rx < drv_data->rx_end) {\r\nbfin_write(&drv_data->regs->tdbr, tx_val);\r\nwhile (!(bfin_read(&drv_data->regs->stat) & BIT_STAT_RXS))\r\ncpu_relax();\r\n*(u8 *) (drv_data->rx++) = bfin_read(&drv_data->regs->rdbr);\r\n}\r\n}\r\nstatic void bfin_spi_u8_duplex(struct bfin_spi_master_data *drv_data)\r\n{\r\nbfin_spi_dummy_read(drv_data);\r\nwhile (drv_data->rx < drv_data->rx_end) {\r\nbfin_write(&drv_data->regs->tdbr, (*(u8 *) (drv_data->tx++)));\r\nwhile (!(bfin_read(&drv_data->regs->stat) & BIT_STAT_RXS))\r\ncpu_relax();\r\n*(u8 *) (drv_data->rx++) = bfin_read(&drv_data->regs->rdbr);\r\n}\r\n}\r\nstatic void bfin_spi_u16_writer(struct bfin_spi_master_data *drv_data)\r\n{\r\nbfin_spi_dummy_read(drv_data);\r\nwhile (drv_data->tx < drv_data->tx_end) {\r\nbfin_write(&drv_data->regs->tdbr, (*(u16 *) (drv_data->tx)));\r\ndrv_data->tx += 2;\r\nwhile (!(bfin_read(&drv_data->regs->stat) & BIT_STAT_RXS))\r\ncpu_relax();\r\nbfin_spi_dummy_read(drv_data);\r\n}\r\n}\r\nstatic void bfin_spi_u16_reader(struct bfin_spi_master_data *drv_data)\r\n{\r\nu16 tx_val = drv_data->cur_chip->idle_tx_val;\r\nbfin_spi_dummy_read(drv_data);\r\nwhile (drv_data->rx < drv_data->rx_end) {\r\nbfin_write(&drv_data->regs->tdbr, tx_val);\r\nwhile (!(bfin_read(&drv_data->regs->stat) & BIT_STAT_RXS))\r\ncpu_relax();\r\n*(u16 *) (drv_data->rx) = bfin_read(&drv_data->regs->rdbr);\r\ndrv_data->rx += 2;\r\n}\r\n}\r\nstatic void bfin_spi_u16_duplex(struct bfin_spi_master_data *drv_data)\r\n{\r\nbfin_spi_dummy_read(drv_data);\r\nwhile (drv_data->rx < drv_data->rx_end) {\r\nbfin_write(&drv_data->regs->tdbr, (*(u16 *) (drv_data->tx)));\r\ndrv_data->tx += 2;\r\nwhile (!(bfin_read(&drv_data->regs->stat) & BIT_STAT_RXS))\r\ncpu_relax();\r\n*(u16 *) (drv_data->rx) = bfin_read(&drv_data->regs->rdbr);\r\ndrv_data->rx += 2;\r\n}\r\n}\r\nstatic void *bfin_spi_next_transfer(struct bfin_spi_master_data *drv_data)\r\n{\r\nstruct spi_message *msg = drv_data->cur_msg;\r\nstruct spi_transfer *trans = drv_data->cur_transfer;\r\nif (trans->transfer_list.next != &msg->transfers) {\r\ndrv_data->cur_transfer =\r\nlist_entry(trans->transfer_list.next,\r\nstruct spi_transfer, transfer_list);\r\nreturn RUNNING_STATE;\r\n} else\r\nreturn DONE_STATE;\r\n}\r\nstatic void bfin_spi_giveback(struct bfin_spi_master_data *drv_data)\r\n{\r\nstruct bfin_spi_slave_data *chip = drv_data->cur_chip;\r\nunsigned long flags;\r\nstruct spi_message *msg;\r\nspin_lock_irqsave(&drv_data->lock, flags);\r\nmsg = drv_data->cur_msg;\r\ndrv_data->cur_msg = NULL;\r\ndrv_data->cur_transfer = NULL;\r\ndrv_data->cur_chip = NULL;\r\nqueue_work(drv_data->workqueue, &drv_data->pump_messages);\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nmsg->state = NULL;\r\nif (!drv_data->cs_change)\r\nbfin_spi_cs_deactive(drv_data, chip);\r\nif (drv_data->tx_dma != 0xFFFF)\r\nbfin_spi_disable(drv_data);\r\nif (msg->complete)\r\nmsg->complete(msg->context);\r\n}\r\nstatic irqreturn_t bfin_spi_pio_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct bfin_spi_master_data *drv_data = dev_id;\r\nstruct bfin_spi_slave_data *chip = drv_data->cur_chip;\r\nstruct spi_message *msg = drv_data->cur_msg;\r\nint n_bytes = drv_data->n_bytes;\r\nint loop = 0;\r\nwhile (!(bfin_read(&drv_data->regs->stat) & BIT_STAT_RXS))\r\ncpu_relax();\r\nif ((drv_data->tx && drv_data->tx >= drv_data->tx_end) ||\r\n(drv_data->rx && drv_data->rx >= (drv_data->rx_end - n_bytes))) {\r\nif (drv_data->rx) {\r\ndev_dbg(&drv_data->pdev->dev, "last read\n");\r\nif (!(n_bytes % 2)) {\r\nu16 *buf = (u16 *)drv_data->rx;\r\nfor (loop = 0; loop < n_bytes / 2; loop++)\r\n*buf++ = bfin_read(&drv_data->regs->rdbr);\r\n} else {\r\nu8 *buf = (u8 *)drv_data->rx;\r\nfor (loop = 0; loop < n_bytes; loop++)\r\n*buf++ = bfin_read(&drv_data->regs->rdbr);\r\n}\r\ndrv_data->rx += n_bytes;\r\n}\r\nmsg->actual_length += drv_data->len_in_bytes;\r\nif (drv_data->cs_change)\r\nbfin_spi_cs_deactive(drv_data, chip);\r\nmsg->state = bfin_spi_next_transfer(drv_data);\r\ndisable_irq_nosync(drv_data->spi_irq);\r\ntasklet_schedule(&drv_data->pump_transfers);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (drv_data->rx && drv_data->tx) {\r\ndev_dbg(&drv_data->pdev->dev, "duplex: write_TDBR\n");\r\nif (!(n_bytes % 2)) {\r\nu16 *buf = (u16 *)drv_data->rx;\r\nu16 *buf2 = (u16 *)drv_data->tx;\r\nfor (loop = 0; loop < n_bytes / 2; loop++) {\r\n*buf++ = bfin_read(&drv_data->regs->rdbr);\r\nbfin_write(&drv_data->regs->tdbr, *buf2++);\r\n}\r\n} else {\r\nu8 *buf = (u8 *)drv_data->rx;\r\nu8 *buf2 = (u8 *)drv_data->tx;\r\nfor (loop = 0; loop < n_bytes; loop++) {\r\n*buf++ = bfin_read(&drv_data->regs->rdbr);\r\nbfin_write(&drv_data->regs->tdbr, *buf2++);\r\n}\r\n}\r\n} else if (drv_data->rx) {\r\ndev_dbg(&drv_data->pdev->dev, "read: write_TDBR\n");\r\nif (!(n_bytes % 2)) {\r\nu16 *buf = (u16 *)drv_data->rx;\r\nfor (loop = 0; loop < n_bytes / 2; loop++) {\r\n*buf++ = bfin_read(&drv_data->regs->rdbr);\r\nbfin_write(&drv_data->regs->tdbr, chip->idle_tx_val);\r\n}\r\n} else {\r\nu8 *buf = (u8 *)drv_data->rx;\r\nfor (loop = 0; loop < n_bytes; loop++) {\r\n*buf++ = bfin_read(&drv_data->regs->rdbr);\r\nbfin_write(&drv_data->regs->tdbr, chip->idle_tx_val);\r\n}\r\n}\r\n} else if (drv_data->tx) {\r\ndev_dbg(&drv_data->pdev->dev, "write: write_TDBR\n");\r\nif (!(n_bytes % 2)) {\r\nu16 *buf = (u16 *)drv_data->tx;\r\nfor (loop = 0; loop < n_bytes / 2; loop++) {\r\nbfin_read(&drv_data->regs->rdbr);\r\nbfin_write(&drv_data->regs->tdbr, *buf++);\r\n}\r\n} else {\r\nu8 *buf = (u8 *)drv_data->tx;\r\nfor (loop = 0; loop < n_bytes; loop++) {\r\nbfin_read(&drv_data->regs->rdbr);\r\nbfin_write(&drv_data->regs->tdbr, *buf++);\r\n}\r\n}\r\n}\r\nif (drv_data->tx)\r\ndrv_data->tx += n_bytes;\r\nif (drv_data->rx)\r\ndrv_data->rx += n_bytes;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t bfin_spi_dma_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct bfin_spi_master_data *drv_data = dev_id;\r\nstruct bfin_spi_slave_data *chip = drv_data->cur_chip;\r\nstruct spi_message *msg = drv_data->cur_msg;\r\nunsigned long timeout;\r\nunsigned short dmastat = get_dma_curr_irqstat(drv_data->dma_channel);\r\nu16 spistat = bfin_read(&drv_data->regs->stat);\r\ndev_dbg(&drv_data->pdev->dev,\r\n"in dma_irq_handler dmastat:0x%x spistat:0x%x\n",\r\ndmastat, spistat);\r\nif (drv_data->rx != NULL) {\r\nu16 cr = bfin_read(&drv_data->regs->ctl);\r\nbfin_spi_dummy_read(drv_data);\r\nbfin_write(&drv_data->regs->ctl, cr & ~BIT_CTL_ENABLE);\r\nbfin_write(&drv_data->regs->ctl, cr & ~BIT_CTL_TIMOD);\r\nbfin_write(&drv_data->regs->stat, BIT_STAT_CLR);\r\n}\r\nclear_dma_irqstat(drv_data->dma_channel);\r\nif (drv_data->tx != NULL) {\r\nwhile ((bfin_read(&drv_data->regs->stat) & BIT_STAT_TXS) ||\r\n(bfin_read(&drv_data->regs->stat) & BIT_STAT_TXS))\r\ncpu_relax();\r\n}\r\ndev_dbg(&drv_data->pdev->dev,\r\n"in dma_irq_handler dmastat:0x%x spistat:0x%x\n",\r\ndmastat, bfin_read(&drv_data->regs->stat));\r\ntimeout = jiffies + HZ;\r\nwhile (!(bfin_read(&drv_data->regs->stat) & BIT_STAT_SPIF))\r\nif (!time_before(jiffies, timeout)) {\r\ndev_warn(&drv_data->pdev->dev, "timeout waiting for SPIF\n");\r\nbreak;\r\n} else\r\ncpu_relax();\r\nif ((dmastat & DMA_ERR) && (spistat & BIT_STAT_RBSY)) {\r\nmsg->state = ERROR_STATE;\r\ndev_err(&drv_data->pdev->dev, "dma receive: fifo/buffer overflow\n");\r\n} else {\r\nmsg->actual_length += drv_data->len_in_bytes;\r\nif (drv_data->cs_change)\r\nbfin_spi_cs_deactive(drv_data, chip);\r\nmsg->state = bfin_spi_next_transfer(drv_data);\r\n}\r\ntasklet_schedule(&drv_data->pump_transfers);\r\ndev_dbg(&drv_data->pdev->dev,\r\n"disable dma channel irq%d\n",\r\ndrv_data->dma_channel);\r\ndma_disable_irq_nosync(drv_data->dma_channel);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void bfin_spi_pump_transfers(unsigned long data)\r\n{\r\nstruct bfin_spi_master_data *drv_data = (struct bfin_spi_master_data *)data;\r\nstruct spi_message *message = NULL;\r\nstruct spi_transfer *transfer = NULL;\r\nstruct spi_transfer *previous = NULL;\r\nstruct bfin_spi_slave_data *chip = NULL;\r\nunsigned int bits_per_word;\r\nu16 cr, cr_width = 0, dma_width, dma_config;\r\nu32 tranf_success = 1;\r\nu8 full_duplex = 0;\r\nmessage = drv_data->cur_msg;\r\ntransfer = drv_data->cur_transfer;\r\nchip = drv_data->cur_chip;\r\nif (message->state == ERROR_STATE) {\r\ndev_dbg(&drv_data->pdev->dev, "transfer: we've hit an error\n");\r\nmessage->status = -EIO;\r\nbfin_spi_giveback(drv_data);\r\nreturn;\r\n}\r\nif (message->state == DONE_STATE) {\r\ndev_dbg(&drv_data->pdev->dev, "transfer: all done!\n");\r\nmessage->status = 0;\r\nbfin_spi_flush(drv_data);\r\nbfin_spi_giveback(drv_data);\r\nreturn;\r\n}\r\nif (message->state == RUNNING_STATE) {\r\ndev_dbg(&drv_data->pdev->dev, "transfer: still running ...\n");\r\nprevious = list_entry(transfer->transfer_list.prev,\r\nstruct spi_transfer, transfer_list);\r\nif (previous->delay_usecs)\r\nudelay(previous->delay_usecs);\r\n}\r\nif (bfin_spi_flush(drv_data) == 0) {\r\ndev_err(&drv_data->pdev->dev, "pump_transfers: flush failed\n");\r\nmessage->status = -EIO;\r\nbfin_spi_giveback(drv_data);\r\nreturn;\r\n}\r\nif (transfer->len == 0) {\r\nmessage->state = bfin_spi_next_transfer(drv_data);\r\ntasklet_schedule(&drv_data->pump_transfers);\r\nreturn;\r\n}\r\nif (transfer->tx_buf != NULL) {\r\ndrv_data->tx = (void *)transfer->tx_buf;\r\ndrv_data->tx_end = drv_data->tx + transfer->len;\r\ndev_dbg(&drv_data->pdev->dev, "tx_buf is %p, tx_end is %p\n",\r\ntransfer->tx_buf, drv_data->tx_end);\r\n} else {\r\ndrv_data->tx = NULL;\r\n}\r\nif (transfer->rx_buf != NULL) {\r\nfull_duplex = transfer->tx_buf != NULL;\r\ndrv_data->rx = transfer->rx_buf;\r\ndrv_data->rx_end = drv_data->rx + transfer->len;\r\ndev_dbg(&drv_data->pdev->dev, "rx_buf is %p, rx_end is %p\n",\r\ntransfer->rx_buf, drv_data->rx_end);\r\n} else {\r\ndrv_data->rx = NULL;\r\n}\r\ndrv_data->rx_dma = transfer->rx_dma;\r\ndrv_data->tx_dma = transfer->tx_dma;\r\ndrv_data->len_in_bytes = transfer->len;\r\ndrv_data->cs_change = transfer->cs_change;\r\nbits_per_word = transfer->bits_per_word;\r\nif (bits_per_word == 16) {\r\ndrv_data->n_bytes = bits_per_word/8;\r\ndrv_data->len = (transfer->len) >> 1;\r\ncr_width = BIT_CTL_WORDSIZE;\r\ndrv_data->ops = &bfin_bfin_spi_transfer_ops_u16;\r\n} else if (bits_per_word == 8) {\r\ndrv_data->n_bytes = bits_per_word/8;\r\ndrv_data->len = transfer->len;\r\ndrv_data->ops = &bfin_bfin_spi_transfer_ops_u8;\r\n}\r\ncr = bfin_read(&drv_data->regs->ctl) & ~(BIT_CTL_TIMOD | BIT_CTL_WORDSIZE);\r\ncr |= cr_width;\r\nbfin_write(&drv_data->regs->ctl, cr);\r\ndev_dbg(&drv_data->pdev->dev,\r\n"transfer: drv_data->ops is %p, chip->ops is %p, u8_ops is %p\n",\r\ndrv_data->ops, chip->ops, &bfin_bfin_spi_transfer_ops_u8);\r\nmessage->state = RUNNING_STATE;\r\ndma_config = 0;\r\nif (transfer->speed_hz)\r\nbfin_write(&drv_data->regs->baud, hz_to_spi_baud(transfer->speed_hz));\r\nelse\r\nbfin_write(&drv_data->regs->baud, chip->baud);\r\nbfin_write(&drv_data->regs->stat, BIT_STAT_CLR);\r\nbfin_spi_cs_active(drv_data, chip);\r\ndev_dbg(&drv_data->pdev->dev,\r\n"now pumping a transfer: width is %d, len is %d\n",\r\ncr_width, transfer->len);\r\nif (!full_duplex && drv_data->cur_chip->enable_dma\r\n&& drv_data->len > 6) {\r\nunsigned long dma_start_addr, flags;\r\ndisable_dma(drv_data->dma_channel);\r\nclear_dma_irqstat(drv_data->dma_channel);\r\ndev_dbg(&drv_data->pdev->dev, "doing dma transfer\n");\r\nset_dma_x_count(drv_data->dma_channel, drv_data->len);\r\nif (cr_width == BIT_CTL_WORDSIZE) {\r\nset_dma_x_modify(drv_data->dma_channel, 2);\r\ndma_width = WDSIZE_16;\r\n} else {\r\nset_dma_x_modify(drv_data->dma_channel, 1);\r\ndma_width = WDSIZE_8;\r\n}\r\nwhile (!(bfin_read(&drv_data->regs->stat) & BIT_STAT_SPIF))\r\ncpu_relax();\r\nif (drv_data->tx_dma == 0xFFFF) {\r\ndev_dbg(&drv_data->pdev->dev,\r\n"doing autobuffer DMA out.\n");\r\ndma_config =\r\n(DMAFLOW_AUTO | RESTART | dma_width | DI_EN);\r\nset_dma_config(drv_data->dma_channel, dma_config);\r\nset_dma_start_addr(drv_data->dma_channel,\r\n(unsigned long)drv_data->tx);\r\nenable_dma(drv_data->dma_channel);\r\nbfin_write(&drv_data->regs->ctl, cr | BIT_CTL_TIMOD_DMA_TX);\r\nmessage->status = 0;\r\nbfin_spi_giveback(drv_data);\r\nreturn;\r\n}\r\ndma_config = (RESTART | dma_width | DI_EN);\r\nif (drv_data->rx != NULL) {\r\ndev_dbg(&drv_data->pdev->dev, "doing DMA in to %p (size %zx)\n",\r\ndrv_data->rx, drv_data->len_in_bytes);\r\nif (bfin_addr_dcacheable((unsigned long) drv_data->rx))\r\ninvalidate_dcache_range((unsigned long) drv_data->rx,\r\n(unsigned long) (drv_data->rx +\r\ndrv_data->len_in_bytes));\r\ndma_config |= WNR;\r\ndma_start_addr = (unsigned long)drv_data->rx;\r\ncr |= BIT_CTL_TIMOD_DMA_RX | BIT_CTL_SENDOPT;\r\n} else if (drv_data->tx != NULL) {\r\ndev_dbg(&drv_data->pdev->dev, "doing DMA out.\n");\r\nif (bfin_addr_dcacheable((unsigned long) drv_data->tx))\r\nflush_dcache_range((unsigned long) drv_data->tx,\r\n(unsigned long) (drv_data->tx +\r\ndrv_data->len_in_bytes));\r\ndma_start_addr = (unsigned long)drv_data->tx;\r\ncr |= BIT_CTL_TIMOD_DMA_TX;\r\n} else\r\nBUG();\r\nset_dma_start_addr(drv_data->dma_channel, dma_start_addr);\r\nset_dma_config(drv_data->dma_channel, dma_config);\r\nlocal_irq_save(flags);\r\nSSYNC();\r\nbfin_write(&drv_data->regs->ctl, cr);\r\nenable_dma(drv_data->dma_channel);\r\ndma_enable_irq(drv_data->dma_channel);\r\nlocal_irq_restore(flags);\r\nreturn;\r\n}\r\nbfin_write(&drv_data->regs->ctl, cr | BIT_CTL_TXMOD);\r\nif (chip->pio_interrupt) {\r\nbfin_spi_dummy_read(drv_data);\r\nif (drv_data->tx == NULL)\r\nbfin_write(&drv_data->regs->tdbr, chip->idle_tx_val);\r\nelse {\r\nint loop;\r\nif (bits_per_word == 16) {\r\nu16 *buf = (u16 *)drv_data->tx;\r\nfor (loop = 0; loop < bits_per_word / 16;\r\nloop++) {\r\nbfin_write(&drv_data->regs->tdbr, *buf++);\r\n}\r\n} else if (bits_per_word == 8) {\r\nu8 *buf = (u8 *)drv_data->tx;\r\nfor (loop = 0; loop < bits_per_word / 8; loop++)\r\nbfin_write(&drv_data->regs->tdbr, *buf++);\r\n}\r\ndrv_data->tx += drv_data->n_bytes;\r\n}\r\nenable_irq(drv_data->spi_irq);\r\nreturn;\r\n}\r\ndev_dbg(&drv_data->pdev->dev, "doing IO transfer\n");\r\nif (full_duplex) {\r\nBUG_ON((drv_data->tx_end - drv_data->tx) !=\r\n(drv_data->rx_end - drv_data->rx));\r\ndev_dbg(&drv_data->pdev->dev,\r\n"IO duplex: cr is 0x%x\n", cr);\r\ndrv_data->ops->duplex(drv_data);\r\nif (drv_data->tx != drv_data->tx_end)\r\ntranf_success = 0;\r\n} else if (drv_data->tx != NULL) {\r\ndev_dbg(&drv_data->pdev->dev,\r\n"IO write: cr is 0x%x\n", cr);\r\ndrv_data->ops->write(drv_data);\r\nif (drv_data->tx != drv_data->tx_end)\r\ntranf_success = 0;\r\n} else if (drv_data->rx != NULL) {\r\ndev_dbg(&drv_data->pdev->dev,\r\n"IO read: cr is 0x%x\n", cr);\r\ndrv_data->ops->read(drv_data);\r\nif (drv_data->rx != drv_data->rx_end)\r\ntranf_success = 0;\r\n}\r\nif (!tranf_success) {\r\ndev_dbg(&drv_data->pdev->dev,\r\n"IO write error!\n");\r\nmessage->state = ERROR_STATE;\r\n} else {\r\nmessage->actual_length += drv_data->len_in_bytes;\r\nmessage->state = bfin_spi_next_transfer(drv_data);\r\nif (drv_data->cs_change && message->state != DONE_STATE) {\r\nbfin_spi_flush(drv_data);\r\nbfin_spi_cs_deactive(drv_data, chip);\r\n}\r\n}\r\ntasklet_schedule(&drv_data->pump_transfers);\r\n}\r\nstatic void bfin_spi_pump_messages(struct work_struct *work)\r\n{\r\nstruct bfin_spi_master_data *drv_data;\r\nunsigned long flags;\r\ndrv_data = container_of(work, struct bfin_spi_master_data, pump_messages);\r\nspin_lock_irqsave(&drv_data->lock, flags);\r\nif (list_empty(&drv_data->queue) || !drv_data->running) {\r\ndrv_data->busy = 0;\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nreturn;\r\n}\r\nif (drv_data->cur_msg) {\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nreturn;\r\n}\r\ndrv_data->cur_msg = list_entry(drv_data->queue.next,\r\nstruct spi_message, queue);\r\ndrv_data->cur_chip = spi_get_ctldata(drv_data->cur_msg->spi);\r\nbfin_spi_restore_state(drv_data);\r\nlist_del_init(&drv_data->cur_msg->queue);\r\ndrv_data->cur_msg->state = START_STATE;\r\ndrv_data->cur_transfer = list_entry(drv_data->cur_msg->transfers.next,\r\nstruct spi_transfer, transfer_list);\r\ndev_dbg(&drv_data->pdev->dev,\r\n"got a message to pump, state is set to: baud "\r\n"%d, flag 0x%x, ctl 0x%x\n",\r\ndrv_data->cur_chip->baud, drv_data->cur_chip->flag,\r\ndrv_data->cur_chip->ctl_reg);\r\ndev_dbg(&drv_data->pdev->dev,\r\n"the first transfer len is %d\n",\r\ndrv_data->cur_transfer->len);\r\ntasklet_schedule(&drv_data->pump_transfers);\r\ndrv_data->busy = 1;\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\n}\r\nstatic int bfin_spi_transfer(struct spi_device *spi, struct spi_message *msg)\r\n{\r\nstruct bfin_spi_master_data *drv_data = spi_master_get_devdata(spi->master);\r\nunsigned long flags;\r\nspin_lock_irqsave(&drv_data->lock, flags);\r\nif (!drv_data->running) {\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nreturn -ESHUTDOWN;\r\n}\r\nmsg->actual_length = 0;\r\nmsg->status = -EINPROGRESS;\r\nmsg->state = START_STATE;\r\ndev_dbg(&spi->dev, "adding an msg in transfer() \n");\r\nlist_add_tail(&msg->queue, &drv_data->queue);\r\nif (drv_data->running && !drv_data->busy)\r\nqueue_work(drv_data->workqueue, &drv_data->pump_messages);\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int bfin_spi_setup(struct spi_device *spi)\r\n{\r\nstruct bfin5xx_spi_chip *chip_info;\r\nstruct bfin_spi_slave_data *chip = NULL;\r\nstruct bfin_spi_master_data *drv_data = spi_master_get_devdata(spi->master);\r\nu16 bfin_ctl_reg;\r\nint ret = -EINVAL;\r\nchip_info = NULL;\r\nchip = spi_get_ctldata(spi);\r\nif (chip == NULL) {\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (!chip) {\r\ndev_err(&spi->dev, "cannot allocate chip data\n");\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nchip->enable_dma = 0;\r\nchip_info = spi->controller_data;\r\n}\r\nbfin_ctl_reg = BIT_CTL_OPENDRAIN | BIT_CTL_EMISO |\r\nBIT_CTL_PSSE | BIT_CTL_GM | BIT_CTL_SZ;\r\nif (chip_info) {\r\nif (chip_info->ctl_reg & ~bfin_ctl_reg) {\r\ndev_err(&spi->dev,\r\n"do not set bits in ctl_reg that the SPI framework manages\n");\r\ngoto error;\r\n}\r\nchip->enable_dma = chip_info->enable_dma != 0\r\n&& drv_data->master_info->enable_dma;\r\nchip->ctl_reg = chip_info->ctl_reg;\r\nchip->cs_chg_udelay = chip_info->cs_chg_udelay;\r\nchip->idle_tx_val = chip_info->idle_tx_val;\r\nchip->pio_interrupt = chip_info->pio_interrupt;\r\n} else {\r\nchip->ctl_reg &= bfin_ctl_reg;\r\n}\r\nif (spi->mode & SPI_CPOL)\r\nchip->ctl_reg |= BIT_CTL_CPOL;\r\nif (spi->mode & SPI_CPHA)\r\nchip->ctl_reg |= BIT_CTL_CPHA;\r\nif (spi->mode & SPI_LSB_FIRST)\r\nchip->ctl_reg |= BIT_CTL_LSBF;\r\nchip->ctl_reg |= BIT_CTL_MASTER;\r\nchip->baud = hz_to_spi_baud(spi->max_speed_hz);\r\nchip->chip_select_num = spi->chip_select;\r\nif (chip->chip_select_num < MAX_CTRL_CS) {\r\nif (!(spi->mode & SPI_CPHA))\r\ndev_warn(&spi->dev,\r\n"Warning: SPI CPHA not set: Slave Select not under software control!\n"\r\n"See Documentation/blackfin/bfin-spi-notes.txt\n");\r\nchip->flag = (1 << spi->chip_select) << 8;\r\n} else\r\nchip->cs_gpio = chip->chip_select_num - MAX_CTRL_CS;\r\nif (chip->enable_dma && chip->pio_interrupt) {\r\ndev_err(&spi->dev,\r\n"enable_dma is set, do not set pio_interrupt\n");\r\ngoto error;\r\n}\r\nif (chip->enable_dma && !drv_data->dma_requested) {\r\nret = request_dma(drv_data->dma_channel, "BFIN_SPI_DMA");\r\nif (ret) {\r\ndev_err(&spi->dev,\r\n"Unable to request BlackFin SPI DMA channel\n");\r\ngoto error;\r\n}\r\ndrv_data->dma_requested = 1;\r\nret = set_dma_callback(drv_data->dma_channel,\r\nbfin_spi_dma_irq_handler, drv_data);\r\nif (ret) {\r\ndev_err(&spi->dev, "Unable to set dma callback\n");\r\ngoto error;\r\n}\r\ndma_disable_irq(drv_data->dma_channel);\r\n}\r\nif (chip->pio_interrupt && !drv_data->irq_requested) {\r\nret = request_irq(drv_data->spi_irq, bfin_spi_pio_irq_handler,\r\n0, "BFIN_SPI", drv_data);\r\nif (ret) {\r\ndev_err(&spi->dev, "Unable to register spi IRQ\n");\r\ngoto error;\r\n}\r\ndrv_data->irq_requested = 1;\r\ndisable_irq(drv_data->spi_irq);\r\n}\r\nif (chip->chip_select_num >= MAX_CTRL_CS) {\r\nif (spi_get_ctldata(spi) == NULL) {\r\nret = gpio_request(chip->cs_gpio, spi->modalias);\r\nif (ret) {\r\ndev_err(&spi->dev, "gpio_request() error\n");\r\ngoto pin_error;\r\n}\r\ngpio_direction_output(chip->cs_gpio, 1);\r\n}\r\n}\r\ndev_dbg(&spi->dev, "setup spi chip %s, width is %d, dma is %d\n",\r\nspi->modalias, spi->bits_per_word, chip->enable_dma);\r\ndev_dbg(&spi->dev, "ctl_reg is 0x%x, flag_reg is 0x%x\n",\r\nchip->ctl_reg, chip->flag);\r\nspi_set_ctldata(spi, chip);\r\ndev_dbg(&spi->dev, "chip select number is %d\n", chip->chip_select_num);\r\nif (chip->chip_select_num < MAX_CTRL_CS) {\r\nret = peripheral_request(ssel[spi->master->bus_num]\r\n[chip->chip_select_num-1], spi->modalias);\r\nif (ret) {\r\ndev_err(&spi->dev, "peripheral_request() error\n");\r\ngoto pin_error;\r\n}\r\n}\r\nbfin_spi_cs_enable(drv_data, chip);\r\nbfin_spi_cs_deactive(drv_data, chip);\r\nreturn 0;\r\npin_error:\r\nif (chip->chip_select_num >= MAX_CTRL_CS)\r\ngpio_free(chip->cs_gpio);\r\nelse\r\nperipheral_free(ssel[spi->master->bus_num]\r\n[chip->chip_select_num - 1]);\r\nerror:\r\nif (chip) {\r\nif (drv_data->dma_requested)\r\nfree_dma(drv_data->dma_channel);\r\ndrv_data->dma_requested = 0;\r\nkfree(chip);\r\nspi_set_ctldata(spi, NULL);\r\n}\r\nreturn ret;\r\n}\r\nstatic void bfin_spi_cleanup(struct spi_device *spi)\r\n{\r\nstruct bfin_spi_slave_data *chip = spi_get_ctldata(spi);\r\nstruct bfin_spi_master_data *drv_data = spi_master_get_devdata(spi->master);\r\nif (!chip)\r\nreturn;\r\nif (chip->chip_select_num < MAX_CTRL_CS) {\r\nperipheral_free(ssel[spi->master->bus_num]\r\n[chip->chip_select_num-1]);\r\nbfin_spi_cs_disable(drv_data, chip);\r\n} else\r\ngpio_free(chip->cs_gpio);\r\nkfree(chip);\r\nspi_set_ctldata(spi, NULL);\r\n}\r\nstatic int bfin_spi_init_queue(struct bfin_spi_master_data *drv_data)\r\n{\r\nINIT_LIST_HEAD(&drv_data->queue);\r\nspin_lock_init(&drv_data->lock);\r\ndrv_data->running = false;\r\ndrv_data->busy = 0;\r\ntasklet_init(&drv_data->pump_transfers,\r\nbfin_spi_pump_transfers, (unsigned long)drv_data);\r\nINIT_WORK(&drv_data->pump_messages, bfin_spi_pump_messages);\r\ndrv_data->workqueue = create_singlethread_workqueue(\r\ndev_name(drv_data->master->dev.parent));\r\nif (drv_data->workqueue == NULL)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int bfin_spi_start_queue(struct bfin_spi_master_data *drv_data)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&drv_data->lock, flags);\r\nif (drv_data->running || drv_data->busy) {\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nreturn -EBUSY;\r\n}\r\ndrv_data->running = true;\r\ndrv_data->cur_msg = NULL;\r\ndrv_data->cur_transfer = NULL;\r\ndrv_data->cur_chip = NULL;\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nqueue_work(drv_data->workqueue, &drv_data->pump_messages);\r\nreturn 0;\r\n}\r\nstatic int bfin_spi_stop_queue(struct bfin_spi_master_data *drv_data)\r\n{\r\nunsigned long flags;\r\nunsigned limit = 500;\r\nint status = 0;\r\nspin_lock_irqsave(&drv_data->lock, flags);\r\ndrv_data->running = false;\r\nwhile ((!list_empty(&drv_data->queue) || drv_data->busy) && limit--) {\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nmsleep(10);\r\nspin_lock_irqsave(&drv_data->lock, flags);\r\n}\r\nif (!list_empty(&drv_data->queue) || drv_data->busy)\r\nstatus = -EBUSY;\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nreturn status;\r\n}\r\nstatic int bfin_spi_destroy_queue(struct bfin_spi_master_data *drv_data)\r\n{\r\nint status;\r\nstatus = bfin_spi_stop_queue(drv_data);\r\nif (status != 0)\r\nreturn status;\r\ndestroy_workqueue(drv_data->workqueue);\r\nreturn 0;\r\n}\r\nstatic int bfin_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct bfin5xx_spi_master *platform_info;\r\nstruct spi_master *master;\r\nstruct bfin_spi_master_data *drv_data;\r\nstruct resource *res;\r\nint status = 0;\r\nplatform_info = dev_get_platdata(dev);\r\nmaster = spi_alloc_master(dev, sizeof(*drv_data));\r\nif (!master) {\r\ndev_err(&pdev->dev, "can not alloc spi_master\n");\r\nreturn -ENOMEM;\r\n}\r\ndrv_data = spi_master_get_devdata(master);\r\ndrv_data->master = master;\r\ndrv_data->master_info = platform_info;\r\ndrv_data->pdev = pdev;\r\ndrv_data->pin_req = platform_info->pin_req;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LSB_FIRST;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(8) | SPI_BPW_MASK(16);\r\nmaster->bus_num = pdev->id;\r\nmaster->num_chipselect = platform_info->num_chipselect;\r\nmaster->cleanup = bfin_spi_cleanup;\r\nmaster->setup = bfin_spi_setup;\r\nmaster->transfer = bfin_spi_transfer;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(dev, "Cannot get IORESOURCE_MEM\n");\r\nstatus = -ENOENT;\r\ngoto out_error_get_res;\r\n}\r\ndrv_data->regs = ioremap(res->start, resource_size(res));\r\nif (drv_data->regs == NULL) {\r\ndev_err(dev, "Cannot map IO\n");\r\nstatus = -ENXIO;\r\ngoto out_error_ioremap;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (res == NULL) {\r\ndev_err(dev, "No DMA channel specified\n");\r\nstatus = -ENOENT;\r\ngoto out_error_free_io;\r\n}\r\ndrv_data->dma_channel = res->start;\r\ndrv_data->spi_irq = platform_get_irq(pdev, 0);\r\nif (drv_data->spi_irq < 0) {\r\ndev_err(dev, "No spi pio irq specified\n");\r\nstatus = -ENOENT;\r\ngoto out_error_free_io;\r\n}\r\nstatus = bfin_spi_init_queue(drv_data);\r\nif (status != 0) {\r\ndev_err(dev, "problem initializing queue\n");\r\ngoto out_error_queue_alloc;\r\n}\r\nstatus = bfin_spi_start_queue(drv_data);\r\nif (status != 0) {\r\ndev_err(dev, "problem starting queue\n");\r\ngoto out_error_queue_alloc;\r\n}\r\nstatus = peripheral_request_list(drv_data->pin_req, DRV_NAME);\r\nif (status != 0) {\r\ndev_err(&pdev->dev, ": Requesting Peripherals failed\n");\r\ngoto out_error_queue_alloc;\r\n}\r\nbfin_write(&drv_data->regs->ctl, BIT_CTL_CPHA | BIT_CTL_MASTER);\r\nbfin_write(&drv_data->regs->flg, 0xFF00);\r\nplatform_set_drvdata(pdev, drv_data);\r\nstatus = spi_register_master(master);\r\nif (status != 0) {\r\ndev_err(dev, "problem registering spi master\n");\r\ngoto out_error_queue_alloc;\r\n}\r\ndev_info(dev, "%s, Version %s, regs@%p, dma channel@%d\n",\r\nDRV_DESC, DRV_VERSION, drv_data->regs,\r\ndrv_data->dma_channel);\r\nreturn status;\r\nout_error_queue_alloc:\r\nbfin_spi_destroy_queue(drv_data);\r\nout_error_free_io:\r\niounmap(drv_data->regs);\r\nout_error_ioremap:\r\nout_error_get_res:\r\nspi_master_put(master);\r\nreturn status;\r\n}\r\nstatic int bfin_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct bfin_spi_master_data *drv_data = platform_get_drvdata(pdev);\r\nint status = 0;\r\nif (!drv_data)\r\nreturn 0;\r\nstatus = bfin_spi_destroy_queue(drv_data);\r\nif (status != 0)\r\nreturn status;\r\nbfin_spi_disable(drv_data);\r\nif (drv_data->master_info->enable_dma) {\r\nif (dma_channel_active(drv_data->dma_channel))\r\nfree_dma(drv_data->dma_channel);\r\n}\r\nif (drv_data->irq_requested) {\r\nfree_irq(drv_data->spi_irq, drv_data);\r\ndrv_data->irq_requested = 0;\r\n}\r\nspi_unregister_master(drv_data->master);\r\nperipheral_free_list(drv_data->pin_req);\r\nreturn 0;\r\n}\r\nstatic int bfin_spi_suspend(struct device *dev)\r\n{\r\nstruct bfin_spi_master_data *drv_data = dev_get_drvdata(dev);\r\nint status = 0;\r\nstatus = bfin_spi_stop_queue(drv_data);\r\nif (status != 0)\r\nreturn status;\r\ndrv_data->ctrl_reg = bfin_read(&drv_data->regs->ctl);\r\ndrv_data->flag_reg = bfin_read(&drv_data->regs->flg);\r\nbfin_write(&drv_data->regs->ctl, BIT_CTL_CPHA | BIT_CTL_MASTER);\r\nbfin_write(&drv_data->regs->flg, 0xFF00);\r\nreturn 0;\r\n}\r\nstatic int bfin_spi_resume(struct device *dev)\r\n{\r\nstruct bfin_spi_master_data *drv_data = dev_get_drvdata(dev);\r\nint status = 0;\r\nbfin_write(&drv_data->regs->ctl, drv_data->ctrl_reg);\r\nbfin_write(&drv_data->regs->flg, drv_data->flag_reg);\r\nstatus = bfin_spi_start_queue(drv_data);\r\nif (status != 0) {\r\ndev_err(dev, "problem starting queue (%d)\n", status);\r\nreturn status;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init bfin_spi_init(void)\r\n{\r\nreturn platform_driver_register(&bfin_spi_driver);\r\n}\r\nstatic void __exit bfin_spi_exit(void)\r\n{\r\nplatform_driver_unregister(&bfin_spi_driver);\r\n}
