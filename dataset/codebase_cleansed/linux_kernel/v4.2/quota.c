static int check_quotactl_permission(struct super_block *sb, int type, int cmd,\r\nqid_t id)\r\n{\r\nswitch (cmd) {\r\ncase Q_GETFMT:\r\ncase Q_SYNC:\r\ncase Q_GETINFO:\r\ncase Q_XGETQSTAT:\r\ncase Q_XGETQSTATV:\r\ncase Q_XQUOTASYNC:\r\nbreak;\r\ncase Q_GETQUOTA:\r\ncase Q_XGETQUOTA:\r\nif ((type == USRQUOTA && uid_eq(current_euid(), make_kuid(current_user_ns(), id))) ||\r\n(type == GRPQUOTA && in_egroup_p(make_kgid(current_user_ns(), id))))\r\nbreak;\r\ndefault:\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\n}\r\nreturn security_quotactl(cmd, type, id, sb);\r\n}\r\nstatic void quota_sync_one(struct super_block *sb, void *arg)\r\n{\r\nint type = *(int *)arg;\r\nif (sb->s_qcop && sb->s_qcop->quota_sync &&\r\n(sb->s_quota_types & (1 << type)))\r\nsb->s_qcop->quota_sync(sb, type);\r\n}\r\nstatic int quota_sync_all(int type)\r\n{\r\nint ret;\r\nif (type >= MAXQUOTAS)\r\nreturn -EINVAL;\r\nret = security_quotactl(Q_SYNC, type, 0, NULL);\r\nif (!ret)\r\niterate_supers(quota_sync_one, &type);\r\nreturn ret;\r\n}\r\nunsigned int qtype_enforce_flag(int type)\r\n{\r\nswitch (type) {\r\ncase USRQUOTA:\r\nreturn FS_QUOTA_UDQ_ENFD;\r\ncase GRPQUOTA:\r\nreturn FS_QUOTA_GDQ_ENFD;\r\ncase PRJQUOTA:\r\nreturn FS_QUOTA_PDQ_ENFD;\r\n}\r\nreturn 0;\r\n}\r\nstatic int quota_quotaon(struct super_block *sb, int type, int cmd, qid_t id,\r\nstruct path *path)\r\n{\r\nif (!sb->s_qcop->quota_on && !sb->s_qcop->quota_enable)\r\nreturn -ENOSYS;\r\nif (sb->s_qcop->quota_enable)\r\nreturn sb->s_qcop->quota_enable(sb, qtype_enforce_flag(type));\r\nif (IS_ERR(path))\r\nreturn PTR_ERR(path);\r\nreturn sb->s_qcop->quota_on(sb, type, id, path);\r\n}\r\nstatic int quota_quotaoff(struct super_block *sb, int type)\r\n{\r\nif (!sb->s_qcop->quota_off && !sb->s_qcop->quota_disable)\r\nreturn -ENOSYS;\r\nif (sb->s_qcop->quota_disable)\r\nreturn sb->s_qcop->quota_disable(sb, qtype_enforce_flag(type));\r\nreturn sb->s_qcop->quota_off(sb, type);\r\n}\r\nstatic int quota_getfmt(struct super_block *sb, int type, void __user *addr)\r\n{\r\n__u32 fmt;\r\nmutex_lock(&sb_dqopt(sb)->dqonoff_mutex);\r\nif (!sb_has_quota_active(sb, type)) {\r\nmutex_unlock(&sb_dqopt(sb)->dqonoff_mutex);\r\nreturn -ESRCH;\r\n}\r\nfmt = sb_dqopt(sb)->info[type].dqi_format->qf_fmt_id;\r\nmutex_unlock(&sb_dqopt(sb)->dqonoff_mutex);\r\nif (copy_to_user(addr, &fmt, sizeof(fmt)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int quota_getinfo(struct super_block *sb, int type, void __user *addr)\r\n{\r\nstruct qc_state state;\r\nstruct qc_type_state *tstate;\r\nstruct if_dqinfo uinfo;\r\nint ret;\r\nBUILD_BUG_ON(MAXQUOTAS > XQM_MAXQUOTAS);\r\nif (!sb->s_qcop->get_state)\r\nreturn -ENOSYS;\r\nret = sb->s_qcop->get_state(sb, &state);\r\nif (ret)\r\nreturn ret;\r\ntstate = state.s_state + type;\r\nif (!(tstate->flags & QCI_ACCT_ENABLED))\r\nreturn -ESRCH;\r\nmemset(&uinfo, 0, sizeof(uinfo));\r\nuinfo.dqi_bgrace = tstate->spc_timelimit;\r\nuinfo.dqi_igrace = tstate->ino_timelimit;\r\nif (tstate->flags & QCI_SYSFILE)\r\nuinfo.dqi_flags |= DQF_SYS_FILE;\r\nif (tstate->flags & QCI_ROOT_SQUASH)\r\nuinfo.dqi_flags |= DQF_ROOT_SQUASH;\r\nuinfo.dqi_valid = IIF_ALL;\r\nif (!ret && copy_to_user(addr, &uinfo, sizeof(uinfo)))\r\nreturn -EFAULT;\r\nreturn ret;\r\n}\r\nstatic int quota_setinfo(struct super_block *sb, int type, void __user *addr)\r\n{\r\nstruct if_dqinfo info;\r\nstruct qc_info qinfo;\r\nif (copy_from_user(&info, addr, sizeof(info)))\r\nreturn -EFAULT;\r\nif (!sb->s_qcop->set_info)\r\nreturn -ENOSYS;\r\nif (info.dqi_valid & ~(IIF_FLAGS | IIF_BGRACE | IIF_IGRACE))\r\nreturn -EINVAL;\r\nmemset(&qinfo, 0, sizeof(qinfo));\r\nif (info.dqi_valid & IIF_FLAGS) {\r\nif (info.dqi_flags & ~DQF_SETINFO_MASK)\r\nreturn -EINVAL;\r\nif (info.dqi_flags & DQF_ROOT_SQUASH)\r\nqinfo.i_flags |= QCI_ROOT_SQUASH;\r\nqinfo.i_fieldmask |= QC_FLAGS;\r\n}\r\nif (info.dqi_valid & IIF_BGRACE) {\r\nqinfo.i_spc_timelimit = info.dqi_bgrace;\r\nqinfo.i_fieldmask |= QC_SPC_TIMER;\r\n}\r\nif (info.dqi_valid & IIF_IGRACE) {\r\nqinfo.i_ino_timelimit = info.dqi_igrace;\r\nqinfo.i_fieldmask |= QC_INO_TIMER;\r\n}\r\nreturn sb->s_qcop->set_info(sb, type, &qinfo);\r\n}\r\nstatic inline qsize_t qbtos(qsize_t blocks)\r\n{\r\nreturn blocks << QIF_DQBLKSIZE_BITS;\r\n}\r\nstatic inline qsize_t stoqb(qsize_t space)\r\n{\r\nreturn (space + QIF_DQBLKSIZE - 1) >> QIF_DQBLKSIZE_BITS;\r\n}\r\nstatic void copy_to_if_dqblk(struct if_dqblk *dst, struct qc_dqblk *src)\r\n{\r\nmemset(dst, 0, sizeof(*dst));\r\ndst->dqb_bhardlimit = stoqb(src->d_spc_hardlimit);\r\ndst->dqb_bsoftlimit = stoqb(src->d_spc_softlimit);\r\ndst->dqb_curspace = src->d_space;\r\ndst->dqb_ihardlimit = src->d_ino_hardlimit;\r\ndst->dqb_isoftlimit = src->d_ino_softlimit;\r\ndst->dqb_curinodes = src->d_ino_count;\r\ndst->dqb_btime = src->d_spc_timer;\r\ndst->dqb_itime = src->d_ino_timer;\r\ndst->dqb_valid = QIF_ALL;\r\n}\r\nstatic int quota_getquota(struct super_block *sb, int type, qid_t id,\r\nvoid __user *addr)\r\n{\r\nstruct kqid qid;\r\nstruct qc_dqblk fdq;\r\nstruct if_dqblk idq;\r\nint ret;\r\nif (!sb->s_qcop->get_dqblk)\r\nreturn -ENOSYS;\r\nqid = make_kqid(current_user_ns(), type, id);\r\nif (!qid_valid(qid))\r\nreturn -EINVAL;\r\nret = sb->s_qcop->get_dqblk(sb, qid, &fdq);\r\nif (ret)\r\nreturn ret;\r\ncopy_to_if_dqblk(&idq, &fdq);\r\nif (copy_to_user(addr, &idq, sizeof(idq)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic void copy_from_if_dqblk(struct qc_dqblk *dst, struct if_dqblk *src)\r\n{\r\ndst->d_spc_hardlimit = qbtos(src->dqb_bhardlimit);\r\ndst->d_spc_softlimit = qbtos(src->dqb_bsoftlimit);\r\ndst->d_space = src->dqb_curspace;\r\ndst->d_ino_hardlimit = src->dqb_ihardlimit;\r\ndst->d_ino_softlimit = src->dqb_isoftlimit;\r\ndst->d_ino_count = src->dqb_curinodes;\r\ndst->d_spc_timer = src->dqb_btime;\r\ndst->d_ino_timer = src->dqb_itime;\r\ndst->d_fieldmask = 0;\r\nif (src->dqb_valid & QIF_BLIMITS)\r\ndst->d_fieldmask |= QC_SPC_SOFT | QC_SPC_HARD;\r\nif (src->dqb_valid & QIF_SPACE)\r\ndst->d_fieldmask |= QC_SPACE;\r\nif (src->dqb_valid & QIF_ILIMITS)\r\ndst->d_fieldmask |= QC_INO_SOFT | QC_INO_HARD;\r\nif (src->dqb_valid & QIF_INODES)\r\ndst->d_fieldmask |= QC_INO_COUNT;\r\nif (src->dqb_valid & QIF_BTIME)\r\ndst->d_fieldmask |= QC_SPC_TIMER;\r\nif (src->dqb_valid & QIF_ITIME)\r\ndst->d_fieldmask |= QC_INO_TIMER;\r\n}\r\nstatic int quota_setquota(struct super_block *sb, int type, qid_t id,\r\nvoid __user *addr)\r\n{\r\nstruct qc_dqblk fdq;\r\nstruct if_dqblk idq;\r\nstruct kqid qid;\r\nif (copy_from_user(&idq, addr, sizeof(idq)))\r\nreturn -EFAULT;\r\nif (!sb->s_qcop->set_dqblk)\r\nreturn -ENOSYS;\r\nqid = make_kqid(current_user_ns(), type, id);\r\nif (!qid_valid(qid))\r\nreturn -EINVAL;\r\ncopy_from_if_dqblk(&fdq, &idq);\r\nreturn sb->s_qcop->set_dqblk(sb, qid, &fdq);\r\n}\r\nstatic int quota_enable(struct super_block *sb, void __user *addr)\r\n{\r\n__u32 flags;\r\nif (copy_from_user(&flags, addr, sizeof(flags)))\r\nreturn -EFAULT;\r\nif (!sb->s_qcop->quota_enable)\r\nreturn -ENOSYS;\r\nreturn sb->s_qcop->quota_enable(sb, flags);\r\n}\r\nstatic int quota_disable(struct super_block *sb, void __user *addr)\r\n{\r\n__u32 flags;\r\nif (copy_from_user(&flags, addr, sizeof(flags)))\r\nreturn -EFAULT;\r\nif (!sb->s_qcop->quota_disable)\r\nreturn -ENOSYS;\r\nreturn sb->s_qcop->quota_disable(sb, flags);\r\n}\r\nstatic int quota_state_to_flags(struct qc_state *state)\r\n{\r\nint flags = 0;\r\nif (state->s_state[USRQUOTA].flags & QCI_ACCT_ENABLED)\r\nflags |= FS_QUOTA_UDQ_ACCT;\r\nif (state->s_state[USRQUOTA].flags & QCI_LIMITS_ENFORCED)\r\nflags |= FS_QUOTA_UDQ_ENFD;\r\nif (state->s_state[GRPQUOTA].flags & QCI_ACCT_ENABLED)\r\nflags |= FS_QUOTA_GDQ_ACCT;\r\nif (state->s_state[GRPQUOTA].flags & QCI_LIMITS_ENFORCED)\r\nflags |= FS_QUOTA_GDQ_ENFD;\r\nif (state->s_state[PRJQUOTA].flags & QCI_ACCT_ENABLED)\r\nflags |= FS_QUOTA_PDQ_ACCT;\r\nif (state->s_state[PRJQUOTA].flags & QCI_LIMITS_ENFORCED)\r\nflags |= FS_QUOTA_PDQ_ENFD;\r\nreturn flags;\r\n}\r\nstatic int quota_getstate(struct super_block *sb, struct fs_quota_stat *fqs)\r\n{\r\nint type;\r\nstruct qc_state state;\r\nint ret;\r\nret = sb->s_qcop->get_state(sb, &state);\r\nif (ret < 0)\r\nreturn ret;\r\nmemset(fqs, 0, sizeof(*fqs));\r\nfqs->qs_version = FS_QSTAT_VERSION;\r\nfqs->qs_flags = quota_state_to_flags(&state);\r\nif (!fqs->qs_flags)\r\nreturn -ENOSYS;\r\nfqs->qs_incoredqs = state.s_incoredqs;\r\nfor (type = 0; type < XQM_MAXQUOTAS; type++)\r\nif (state.s_state[type].flags & QCI_ACCT_ENABLED)\r\nbreak;\r\nBUG_ON(type == XQM_MAXQUOTAS);\r\nfqs->qs_btimelimit = state.s_state[type].spc_timelimit;\r\nfqs->qs_itimelimit = state.s_state[type].ino_timelimit;\r\nfqs->qs_rtbtimelimit = state.s_state[type].rt_spc_timelimit;\r\nfqs->qs_bwarnlimit = state.s_state[type].spc_warnlimit;\r\nfqs->qs_iwarnlimit = state.s_state[type].ino_warnlimit;\r\nif (state.s_state[USRQUOTA].flags & QCI_ACCT_ENABLED) {\r\nfqs->qs_uquota.qfs_ino = state.s_state[USRQUOTA].ino;\r\nfqs->qs_uquota.qfs_nblks = state.s_state[USRQUOTA].blocks;\r\nfqs->qs_uquota.qfs_nextents = state.s_state[USRQUOTA].nextents;\r\n}\r\nif (state.s_state[GRPQUOTA].flags & QCI_ACCT_ENABLED) {\r\nfqs->qs_gquota.qfs_ino = state.s_state[GRPQUOTA].ino;\r\nfqs->qs_gquota.qfs_nblks = state.s_state[GRPQUOTA].blocks;\r\nfqs->qs_gquota.qfs_nextents = state.s_state[GRPQUOTA].nextents;\r\n}\r\nif (state.s_state[PRJQUOTA].flags & QCI_ACCT_ENABLED) {\r\nif (!(state.s_state[GRPQUOTA].flags & QCI_ACCT_ENABLED)) {\r\nfqs->qs_gquota.qfs_ino = state.s_state[PRJQUOTA].ino;\r\nfqs->qs_gquota.qfs_nblks =\r\nstate.s_state[PRJQUOTA].blocks;\r\nfqs->qs_gquota.qfs_nextents =\r\nstate.s_state[PRJQUOTA].nextents;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int quota_getxstate(struct super_block *sb, void __user *addr)\r\n{\r\nstruct fs_quota_stat fqs;\r\nint ret;\r\nif (!sb->s_qcop->get_state)\r\nreturn -ENOSYS;\r\nret = quota_getstate(sb, &fqs);\r\nif (!ret && copy_to_user(addr, &fqs, sizeof(fqs)))\r\nreturn -EFAULT;\r\nreturn ret;\r\n}\r\nstatic int quota_getstatev(struct super_block *sb, struct fs_quota_statv *fqs)\r\n{\r\nint type;\r\nstruct qc_state state;\r\nint ret;\r\nret = sb->s_qcop->get_state(sb, &state);\r\nif (ret < 0)\r\nreturn ret;\r\nmemset(fqs, 0, sizeof(*fqs));\r\nfqs->qs_version = FS_QSTAT_VERSION;\r\nfqs->qs_flags = quota_state_to_flags(&state);\r\nif (!fqs->qs_flags)\r\nreturn -ENOSYS;\r\nfqs->qs_incoredqs = state.s_incoredqs;\r\nfor (type = 0; type < XQM_MAXQUOTAS; type++)\r\nif (state.s_state[type].flags & QCI_ACCT_ENABLED)\r\nbreak;\r\nBUG_ON(type == XQM_MAXQUOTAS);\r\nfqs->qs_btimelimit = state.s_state[type].spc_timelimit;\r\nfqs->qs_itimelimit = state.s_state[type].ino_timelimit;\r\nfqs->qs_rtbtimelimit = state.s_state[type].rt_spc_timelimit;\r\nfqs->qs_bwarnlimit = state.s_state[type].spc_warnlimit;\r\nfqs->qs_iwarnlimit = state.s_state[type].ino_warnlimit;\r\nif (state.s_state[USRQUOTA].flags & QCI_ACCT_ENABLED) {\r\nfqs->qs_uquota.qfs_ino = state.s_state[USRQUOTA].ino;\r\nfqs->qs_uquota.qfs_nblks = state.s_state[USRQUOTA].blocks;\r\nfqs->qs_uquota.qfs_nextents = state.s_state[USRQUOTA].nextents;\r\n}\r\nif (state.s_state[GRPQUOTA].flags & QCI_ACCT_ENABLED) {\r\nfqs->qs_gquota.qfs_ino = state.s_state[GRPQUOTA].ino;\r\nfqs->qs_gquota.qfs_nblks = state.s_state[GRPQUOTA].blocks;\r\nfqs->qs_gquota.qfs_nextents = state.s_state[GRPQUOTA].nextents;\r\n}\r\nif (state.s_state[PRJQUOTA].flags & QCI_ACCT_ENABLED) {\r\nfqs->qs_pquota.qfs_ino = state.s_state[PRJQUOTA].ino;\r\nfqs->qs_pquota.qfs_nblks = state.s_state[PRJQUOTA].blocks;\r\nfqs->qs_pquota.qfs_nextents = state.s_state[PRJQUOTA].nextents;\r\n}\r\nreturn 0;\r\n}\r\nstatic int quota_getxstatev(struct super_block *sb, void __user *addr)\r\n{\r\nstruct fs_quota_statv fqs;\r\nint ret;\r\nif (!sb->s_qcop->get_state)\r\nreturn -ENOSYS;\r\nmemset(&fqs, 0, sizeof(fqs));\r\nif (copy_from_user(&fqs, addr, 1))\r\nreturn -EFAULT;\r\nswitch (fqs.qs_version) {\r\ncase FS_QSTATV_VERSION1:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = quota_getstatev(sb, &fqs);\r\nif (!ret && copy_to_user(addr, &fqs, sizeof(fqs)))\r\nreturn -EFAULT;\r\nreturn ret;\r\n}\r\nstatic inline u64 quota_bbtob(u64 blocks)\r\n{\r\nreturn blocks << XFS_BB_SHIFT;\r\n}\r\nstatic inline u64 quota_btobb(u64 bytes)\r\n{\r\nreturn (bytes + (1 << XFS_BB_SHIFT) - 1) >> XFS_BB_SHIFT;\r\n}\r\nstatic void copy_from_xfs_dqblk(struct qc_dqblk *dst, struct fs_disk_quota *src)\r\n{\r\ndst->d_spc_hardlimit = quota_bbtob(src->d_blk_hardlimit);\r\ndst->d_spc_softlimit = quota_bbtob(src->d_blk_softlimit);\r\ndst->d_ino_hardlimit = src->d_ino_hardlimit;\r\ndst->d_ino_softlimit = src->d_ino_softlimit;\r\ndst->d_space = quota_bbtob(src->d_bcount);\r\ndst->d_ino_count = src->d_icount;\r\ndst->d_ino_timer = src->d_itimer;\r\ndst->d_spc_timer = src->d_btimer;\r\ndst->d_ino_warns = src->d_iwarns;\r\ndst->d_spc_warns = src->d_bwarns;\r\ndst->d_rt_spc_hardlimit = quota_bbtob(src->d_rtb_hardlimit);\r\ndst->d_rt_spc_softlimit = quota_bbtob(src->d_rtb_softlimit);\r\ndst->d_rt_space = quota_bbtob(src->d_rtbcount);\r\ndst->d_rt_spc_timer = src->d_rtbtimer;\r\ndst->d_rt_spc_warns = src->d_rtbwarns;\r\ndst->d_fieldmask = 0;\r\nif (src->d_fieldmask & FS_DQ_ISOFT)\r\ndst->d_fieldmask |= QC_INO_SOFT;\r\nif (src->d_fieldmask & FS_DQ_IHARD)\r\ndst->d_fieldmask |= QC_INO_HARD;\r\nif (src->d_fieldmask & FS_DQ_BSOFT)\r\ndst->d_fieldmask |= QC_SPC_SOFT;\r\nif (src->d_fieldmask & FS_DQ_BHARD)\r\ndst->d_fieldmask |= QC_SPC_HARD;\r\nif (src->d_fieldmask & FS_DQ_RTBSOFT)\r\ndst->d_fieldmask |= QC_RT_SPC_SOFT;\r\nif (src->d_fieldmask & FS_DQ_RTBHARD)\r\ndst->d_fieldmask |= QC_RT_SPC_HARD;\r\nif (src->d_fieldmask & FS_DQ_BTIMER)\r\ndst->d_fieldmask |= QC_SPC_TIMER;\r\nif (src->d_fieldmask & FS_DQ_ITIMER)\r\ndst->d_fieldmask |= QC_INO_TIMER;\r\nif (src->d_fieldmask & FS_DQ_RTBTIMER)\r\ndst->d_fieldmask |= QC_RT_SPC_TIMER;\r\nif (src->d_fieldmask & FS_DQ_BWARNS)\r\ndst->d_fieldmask |= QC_SPC_WARNS;\r\nif (src->d_fieldmask & FS_DQ_IWARNS)\r\ndst->d_fieldmask |= QC_INO_WARNS;\r\nif (src->d_fieldmask & FS_DQ_RTBWARNS)\r\ndst->d_fieldmask |= QC_RT_SPC_WARNS;\r\nif (src->d_fieldmask & FS_DQ_BCOUNT)\r\ndst->d_fieldmask |= QC_SPACE;\r\nif (src->d_fieldmask & FS_DQ_ICOUNT)\r\ndst->d_fieldmask |= QC_INO_COUNT;\r\nif (src->d_fieldmask & FS_DQ_RTBCOUNT)\r\ndst->d_fieldmask |= QC_RT_SPACE;\r\n}\r\nstatic void copy_qcinfo_from_xfs_dqblk(struct qc_info *dst,\r\nstruct fs_disk_quota *src)\r\n{\r\nmemset(dst, 0, sizeof(*dst));\r\ndst->i_spc_timelimit = src->d_btimer;\r\ndst->i_ino_timelimit = src->d_itimer;\r\ndst->i_rt_spc_timelimit = src->d_rtbtimer;\r\ndst->i_ino_warnlimit = src->d_iwarns;\r\ndst->i_spc_warnlimit = src->d_bwarns;\r\ndst->i_rt_spc_warnlimit = src->d_rtbwarns;\r\nif (src->d_fieldmask & FS_DQ_BWARNS)\r\ndst->i_fieldmask |= QC_SPC_WARNS;\r\nif (src->d_fieldmask & FS_DQ_IWARNS)\r\ndst->i_fieldmask |= QC_INO_WARNS;\r\nif (src->d_fieldmask & FS_DQ_RTBWARNS)\r\ndst->i_fieldmask |= QC_RT_SPC_WARNS;\r\nif (src->d_fieldmask & FS_DQ_BTIMER)\r\ndst->i_fieldmask |= QC_SPC_TIMER;\r\nif (src->d_fieldmask & FS_DQ_ITIMER)\r\ndst->i_fieldmask |= QC_INO_TIMER;\r\nif (src->d_fieldmask & FS_DQ_RTBTIMER)\r\ndst->i_fieldmask |= QC_RT_SPC_TIMER;\r\n}\r\nstatic int quota_setxquota(struct super_block *sb, int type, qid_t id,\r\nvoid __user *addr)\r\n{\r\nstruct fs_disk_quota fdq;\r\nstruct qc_dqblk qdq;\r\nstruct kqid qid;\r\nif (copy_from_user(&fdq, addr, sizeof(fdq)))\r\nreturn -EFAULT;\r\nif (!sb->s_qcop->set_dqblk)\r\nreturn -ENOSYS;\r\nqid = make_kqid(current_user_ns(), type, id);\r\nif (!qid_valid(qid))\r\nreturn -EINVAL;\r\nif (from_kqid(&init_user_ns, qid) == 0 &&\r\nfdq.d_fieldmask & (FS_DQ_WARNS_MASK | FS_DQ_TIMER_MASK)) {\r\nstruct qc_info qinfo;\r\nint ret;\r\nif (!sb->s_qcop->set_info)\r\nreturn -EINVAL;\r\ncopy_qcinfo_from_xfs_dqblk(&qinfo, &fdq);\r\nret = sb->s_qcop->set_info(sb, type, &qinfo);\r\nif (ret)\r\nreturn ret;\r\nfdq.d_fieldmask &= ~(FS_DQ_WARNS_MASK | FS_DQ_TIMER_MASK);\r\n}\r\ncopy_from_xfs_dqblk(&qdq, &fdq);\r\nreturn sb->s_qcop->set_dqblk(sb, qid, &qdq);\r\n}\r\nstatic void copy_to_xfs_dqblk(struct fs_disk_quota *dst, struct qc_dqblk *src,\r\nint type, qid_t id)\r\n{\r\nmemset(dst, 0, sizeof(*dst));\r\ndst->d_version = FS_DQUOT_VERSION;\r\ndst->d_id = id;\r\nif (type == USRQUOTA)\r\ndst->d_flags = FS_USER_QUOTA;\r\nelse if (type == PRJQUOTA)\r\ndst->d_flags = FS_PROJ_QUOTA;\r\nelse\r\ndst->d_flags = FS_GROUP_QUOTA;\r\ndst->d_blk_hardlimit = quota_btobb(src->d_spc_hardlimit);\r\ndst->d_blk_softlimit = quota_btobb(src->d_spc_softlimit);\r\ndst->d_ino_hardlimit = src->d_ino_hardlimit;\r\ndst->d_ino_softlimit = src->d_ino_softlimit;\r\ndst->d_bcount = quota_btobb(src->d_space);\r\ndst->d_icount = src->d_ino_count;\r\ndst->d_itimer = src->d_ino_timer;\r\ndst->d_btimer = src->d_spc_timer;\r\ndst->d_iwarns = src->d_ino_warns;\r\ndst->d_bwarns = src->d_spc_warns;\r\ndst->d_rtb_hardlimit = quota_btobb(src->d_rt_spc_hardlimit);\r\ndst->d_rtb_softlimit = quota_btobb(src->d_rt_spc_softlimit);\r\ndst->d_rtbcount = quota_btobb(src->d_rt_space);\r\ndst->d_rtbtimer = src->d_rt_spc_timer;\r\ndst->d_rtbwarns = src->d_rt_spc_warns;\r\n}\r\nstatic int quota_getxquota(struct super_block *sb, int type, qid_t id,\r\nvoid __user *addr)\r\n{\r\nstruct fs_disk_quota fdq;\r\nstruct qc_dqblk qdq;\r\nstruct kqid qid;\r\nint ret;\r\nif (!sb->s_qcop->get_dqblk)\r\nreturn -ENOSYS;\r\nqid = make_kqid(current_user_ns(), type, id);\r\nif (!qid_valid(qid))\r\nreturn -EINVAL;\r\nret = sb->s_qcop->get_dqblk(sb, qid, &qdq);\r\nif (ret)\r\nreturn ret;\r\ncopy_to_xfs_dqblk(&fdq, &qdq, type, id);\r\nif (copy_to_user(addr, &fdq, sizeof(fdq)))\r\nreturn -EFAULT;\r\nreturn ret;\r\n}\r\nstatic int quota_rmxquota(struct super_block *sb, void __user *addr)\r\n{\r\n__u32 flags;\r\nif (copy_from_user(&flags, addr, sizeof(flags)))\r\nreturn -EFAULT;\r\nif (!sb->s_qcop->rm_xquota)\r\nreturn -ENOSYS;\r\nreturn sb->s_qcop->rm_xquota(sb, flags);\r\n}\r\nstatic int do_quotactl(struct super_block *sb, int type, int cmd, qid_t id,\r\nvoid __user *addr, struct path *path)\r\n{\r\nint ret;\r\nif (type >= (XQM_COMMAND(cmd) ? XQM_MAXQUOTAS : MAXQUOTAS))\r\nreturn -EINVAL;\r\nif (!sb->s_qcop)\r\nreturn -ENOSYS;\r\nif (!(sb->s_quota_types & (1 << type)))\r\nreturn -EINVAL;\r\nret = check_quotactl_permission(sb, type, cmd, id);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (cmd) {\r\ncase Q_QUOTAON:\r\nreturn quota_quotaon(sb, type, cmd, id, path);\r\ncase Q_QUOTAOFF:\r\nreturn quota_quotaoff(sb, type);\r\ncase Q_GETFMT:\r\nreturn quota_getfmt(sb, type, addr);\r\ncase Q_GETINFO:\r\nreturn quota_getinfo(sb, type, addr);\r\ncase Q_SETINFO:\r\nreturn quota_setinfo(sb, type, addr);\r\ncase Q_GETQUOTA:\r\nreturn quota_getquota(sb, type, id, addr);\r\ncase Q_SETQUOTA:\r\nreturn quota_setquota(sb, type, id, addr);\r\ncase Q_SYNC:\r\nif (!sb->s_qcop->quota_sync)\r\nreturn -ENOSYS;\r\nreturn sb->s_qcop->quota_sync(sb, type);\r\ncase Q_XQUOTAON:\r\nreturn quota_enable(sb, addr);\r\ncase Q_XQUOTAOFF:\r\nreturn quota_disable(sb, addr);\r\ncase Q_XQUOTARM:\r\nreturn quota_rmxquota(sb, addr);\r\ncase Q_XGETQSTAT:\r\nreturn quota_getxstate(sb, addr);\r\ncase Q_XGETQSTATV:\r\nreturn quota_getxstatev(sb, addr);\r\ncase Q_XSETQLIM:\r\nreturn quota_setxquota(sb, type, id, addr);\r\ncase Q_XGETQUOTA:\r\nreturn quota_getxquota(sb, type, id, addr);\r\ncase Q_XQUOTASYNC:\r\nif (sb->s_flags & MS_RDONLY)\r\nreturn -EROFS;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int quotactl_cmd_write(int cmd)\r\n{\r\nswitch (cmd) {\r\ncase Q_GETFMT:\r\ncase Q_GETINFO:\r\ncase Q_SYNC:\r\ncase Q_XGETQSTAT:\r\ncase Q_XGETQSTATV:\r\ncase Q_XGETQUOTA:\r\ncase Q_XQUOTASYNC:\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic struct super_block *quotactl_block(const char __user *special, int cmd)\r\n{\r\n#ifdef CONFIG_BLOCK\r\nstruct block_device *bdev;\r\nstruct super_block *sb;\r\nstruct filename *tmp = getname(special);\r\nif (IS_ERR(tmp))\r\nreturn ERR_CAST(tmp);\r\nbdev = lookup_bdev(tmp->name);\r\nputname(tmp);\r\nif (IS_ERR(bdev))\r\nreturn ERR_CAST(bdev);\r\nif (quotactl_cmd_write(cmd))\r\nsb = get_super_thawed(bdev);\r\nelse\r\nsb = get_super(bdev);\r\nbdput(bdev);\r\nif (!sb)\r\nreturn ERR_PTR(-ENODEV);\r\nreturn sb;\r\n#else\r\nreturn ERR_PTR(-ENODEV);\r\n#endif\r\n}
