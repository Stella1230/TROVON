static void ntfs_end_buffer_async_read(struct buffer_head *bh, int uptodate)\r\n{\r\nunsigned long flags;\r\nstruct buffer_head *first, *tmp;\r\nstruct page *page;\r\nstruct inode *vi;\r\nntfs_inode *ni;\r\nint page_uptodate = 1;\r\npage = bh->b_page;\r\nvi = page->mapping->host;\r\nni = NTFS_I(vi);\r\nif (likely(uptodate)) {\r\nloff_t i_size;\r\ns64 file_ofs, init_size;\r\nset_buffer_uptodate(bh);\r\nfile_ofs = ((s64)page->index << PAGE_CACHE_SHIFT) +\r\nbh_offset(bh);\r\nread_lock_irqsave(&ni->size_lock, flags);\r\ninit_size = ni->initialized_size;\r\ni_size = i_size_read(vi);\r\nread_unlock_irqrestore(&ni->size_lock, flags);\r\nif (unlikely(init_size > i_size)) {\r\ninit_size = i_size;\r\n}\r\nif (unlikely(file_ofs + bh->b_size > init_size)) {\r\nint ofs;\r\nvoid *kaddr;\r\nofs = 0;\r\nif (file_ofs < init_size)\r\nofs = init_size - file_ofs;\r\nlocal_irq_save(flags);\r\nkaddr = kmap_atomic(page);\r\nmemset(kaddr + bh_offset(bh) + ofs, 0,\r\nbh->b_size - ofs);\r\nflush_dcache_page(page);\r\nkunmap_atomic(kaddr);\r\nlocal_irq_restore(flags);\r\n}\r\n} else {\r\nclear_buffer_uptodate(bh);\r\nSetPageError(page);\r\nntfs_error(ni->vol->sb, "Buffer I/O error, logical block "\r\n"0x%llx.", (unsigned long long)bh->b_blocknr);\r\n}\r\nfirst = page_buffers(page);\r\nlocal_irq_save(flags);\r\nbit_spin_lock(BH_Uptodate_Lock, &first->b_state);\r\nclear_buffer_async_read(bh);\r\nunlock_buffer(bh);\r\ntmp = bh;\r\ndo {\r\nif (!buffer_uptodate(tmp))\r\npage_uptodate = 0;\r\nif (buffer_async_read(tmp)) {\r\nif (likely(buffer_locked(tmp)))\r\ngoto still_busy;\r\nBUG();\r\n}\r\ntmp = tmp->b_this_page;\r\n} while (tmp != bh);\r\nbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\r\nlocal_irq_restore(flags);\r\nif (!NInoMstProtected(ni)) {\r\nif (likely(page_uptodate && !PageError(page)))\r\nSetPageUptodate(page);\r\n} else {\r\nu8 *kaddr;\r\nunsigned int i, recs;\r\nu32 rec_size;\r\nrec_size = ni->itype.index.block_size;\r\nrecs = PAGE_CACHE_SIZE / rec_size;\r\nBUG_ON(!recs);\r\nlocal_irq_save(flags);\r\nkaddr = kmap_atomic(page);\r\nfor (i = 0; i < recs; i++)\r\npost_read_mst_fixup((NTFS_RECORD*)(kaddr +\r\ni * rec_size), rec_size);\r\nkunmap_atomic(kaddr);\r\nlocal_irq_restore(flags);\r\nflush_dcache_page(page);\r\nif (likely(page_uptodate && !PageError(page)))\r\nSetPageUptodate(page);\r\n}\r\nunlock_page(page);\r\nreturn;\r\nstill_busy:\r\nbit_spin_unlock(BH_Uptodate_Lock, &first->b_state);\r\nlocal_irq_restore(flags);\r\nreturn;\r\n}\r\nstatic int ntfs_read_block(struct page *page)\r\n{\r\nloff_t i_size;\r\nVCN vcn;\r\nLCN lcn;\r\ns64 init_size;\r\nstruct inode *vi;\r\nntfs_inode *ni;\r\nntfs_volume *vol;\r\nrunlist_element *rl;\r\nstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\r\nsector_t iblock, lblock, zblock;\r\nunsigned long flags;\r\nunsigned int blocksize, vcn_ofs;\r\nint i, nr;\r\nunsigned char blocksize_bits;\r\nvi = page->mapping->host;\r\nni = NTFS_I(vi);\r\nvol = ni->vol;\r\nBUG_ON(!ni->runlist.rl && !ni->mft_no && !NInoAttr(ni));\r\nblocksize = vol->sb->s_blocksize;\r\nblocksize_bits = vol->sb->s_blocksize_bits;\r\nif (!page_has_buffers(page)) {\r\ncreate_empty_buffers(page, blocksize, 0);\r\nif (unlikely(!page_has_buffers(page))) {\r\nunlock_page(page);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nbh = head = page_buffers(page);\r\nBUG_ON(!bh);\r\niblock = (s64)page->index << (PAGE_CACHE_SHIFT - blocksize_bits);\r\nread_lock_irqsave(&ni->size_lock, flags);\r\nlblock = (ni->allocated_size + blocksize - 1) >> blocksize_bits;\r\ninit_size = ni->initialized_size;\r\ni_size = i_size_read(vi);\r\nread_unlock_irqrestore(&ni->size_lock, flags);\r\nif (unlikely(init_size > i_size)) {\r\ninit_size = i_size;\r\n}\r\nzblock = (init_size + blocksize - 1) >> blocksize_bits;\r\nrl = NULL;\r\nnr = i = 0;\r\ndo {\r\nint err = 0;\r\nif (unlikely(buffer_uptodate(bh)))\r\ncontinue;\r\nif (unlikely(buffer_mapped(bh))) {\r\narr[nr++] = bh;\r\ncontinue;\r\n}\r\nbh->b_bdev = vol->sb->s_bdev;\r\nif (iblock < lblock) {\r\nbool is_retry = false;\r\nvcn = (VCN)iblock << blocksize_bits >>\r\nvol->cluster_size_bits;\r\nvcn_ofs = ((VCN)iblock << blocksize_bits) &\r\nvol->cluster_size_mask;\r\nif (!rl) {\r\nlock_retry_remap:\r\ndown_read(&ni->runlist.lock);\r\nrl = ni->runlist.rl;\r\n}\r\nif (likely(rl != NULL)) {\r\nwhile (rl->length && rl[1].vcn <= vcn)\r\nrl++;\r\nlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\r\n} else\r\nlcn = LCN_RL_NOT_MAPPED;\r\nif (lcn >= 0) {\r\nbh->b_blocknr = ((lcn << vol->cluster_size_bits)\r\n+ vcn_ofs) >> blocksize_bits;\r\nset_buffer_mapped(bh);\r\nif (iblock < zblock) {\r\narr[nr++] = bh;\r\ncontinue;\r\n}\r\ngoto handle_zblock;\r\n}\r\nif (lcn == LCN_HOLE)\r\ngoto handle_hole;\r\nif (!is_retry && lcn == LCN_RL_NOT_MAPPED) {\r\nis_retry = true;\r\nup_read(&ni->runlist.lock);\r\nerr = ntfs_map_runlist(ni, vcn);\r\nif (likely(!err))\r\ngoto lock_retry_remap;\r\nrl = NULL;\r\n} else if (!rl)\r\nup_read(&ni->runlist.lock);\r\nif (err == -ENOENT || lcn == LCN_ENOENT) {\r\nerr = 0;\r\ngoto handle_hole;\r\n}\r\nif (!err)\r\nerr = -EIO;\r\nbh->b_blocknr = -1;\r\nSetPageError(page);\r\nntfs_error(vol->sb, "Failed to read from inode 0x%lx, "\r\n"attribute type 0x%x, vcn 0x%llx, "\r\n"offset 0x%x because its location on "\r\n"disk could not be determined%s "\r\n"(error code %i).", ni->mft_no,\r\nni->type, (unsigned long long)vcn,\r\nvcn_ofs, is_retry ? " even after "\r\n"retrying" : "", err);\r\n}\r\nhandle_hole:\r\nbh->b_blocknr = -1UL;\r\nclear_buffer_mapped(bh);\r\nhandle_zblock:\r\nzero_user(page, i * blocksize, blocksize);\r\nif (likely(!err))\r\nset_buffer_uptodate(bh);\r\n} while (i++, iblock++, (bh = bh->b_this_page) != head);\r\nif (rl)\r\nup_read(&ni->runlist.lock);\r\nif (nr) {\r\nstruct buffer_head *tbh;\r\nfor (i = 0; i < nr; i++) {\r\ntbh = arr[i];\r\nlock_buffer(tbh);\r\ntbh->b_end_io = ntfs_end_buffer_async_read;\r\nset_buffer_async_read(tbh);\r\n}\r\nfor (i = 0; i < nr; i++) {\r\ntbh = arr[i];\r\nif (likely(!buffer_uptodate(tbh)))\r\nsubmit_bh(READ, tbh);\r\nelse\r\nntfs_end_buffer_async_read(tbh, 1);\r\n}\r\nreturn 0;\r\n}\r\nif (likely(!PageError(page)))\r\nSetPageUptodate(page);\r\nelse\r\nnr = -EIO;\r\nunlock_page(page);\r\nreturn nr;\r\n}\r\nstatic int ntfs_readpage(struct file *file, struct page *page)\r\n{\r\nloff_t i_size;\r\nstruct inode *vi;\r\nntfs_inode *ni, *base_ni;\r\nu8 *addr;\r\nntfs_attr_search_ctx *ctx;\r\nMFT_RECORD *mrec;\r\nunsigned long flags;\r\nu32 attr_len;\r\nint err = 0;\r\nretry_readpage:\r\nBUG_ON(!PageLocked(page));\r\nvi = page->mapping->host;\r\ni_size = i_size_read(vi);\r\nif (unlikely(page->index >= (i_size + PAGE_CACHE_SIZE - 1) >>\r\nPAGE_CACHE_SHIFT)) {\r\nzero_user(page, 0, PAGE_CACHE_SIZE);\r\nntfs_debug("Read outside i_size - truncated?");\r\ngoto done;\r\n}\r\nif (PageUptodate(page)) {\r\nunlock_page(page);\r\nreturn 0;\r\n}\r\nni = NTFS_I(vi);\r\nif (ni->type != AT_INDEX_ALLOCATION) {\r\nif (NInoEncrypted(ni)) {\r\nBUG_ON(ni->type != AT_DATA);\r\nerr = -EACCES;\r\ngoto err_out;\r\n}\r\nif (NInoNonResident(ni) && NInoCompressed(ni)) {\r\nBUG_ON(ni->type != AT_DATA);\r\nBUG_ON(ni->name_len);\r\nreturn ntfs_read_compressed_block(page);\r\n}\r\n}\r\nif (NInoNonResident(ni)) {\r\nreturn ntfs_read_block(page);\r\n}\r\nif (unlikely(page->index > 0)) {\r\nzero_user(page, 0, PAGE_CACHE_SIZE);\r\ngoto done;\r\n}\r\nif (!NInoAttr(ni))\r\nbase_ni = ni;\r\nelse\r\nbase_ni = ni->ext.base_ntfs_ino;\r\nmrec = map_mft_record(base_ni);\r\nif (IS_ERR(mrec)) {\r\nerr = PTR_ERR(mrec);\r\ngoto err_out;\r\n}\r\nif (unlikely(NInoNonResident(ni))) {\r\nunmap_mft_record(base_ni);\r\ngoto retry_readpage;\r\n}\r\nctx = ntfs_attr_get_search_ctx(base_ni, mrec);\r\nif (unlikely(!ctx)) {\r\nerr = -ENOMEM;\r\ngoto unm_err_out;\r\n}\r\nerr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\r\nCASE_SENSITIVE, 0, NULL, 0, ctx);\r\nif (unlikely(err))\r\ngoto put_unm_err_out;\r\nattr_len = le32_to_cpu(ctx->attr->data.resident.value_length);\r\nread_lock_irqsave(&ni->size_lock, flags);\r\nif (unlikely(attr_len > ni->initialized_size))\r\nattr_len = ni->initialized_size;\r\ni_size = i_size_read(vi);\r\nread_unlock_irqrestore(&ni->size_lock, flags);\r\nif (unlikely(attr_len > i_size)) {\r\nattr_len = i_size;\r\n}\r\naddr = kmap_atomic(page);\r\nmemcpy(addr, (u8*)ctx->attr +\r\nle16_to_cpu(ctx->attr->data.resident.value_offset),\r\nattr_len);\r\nmemset(addr + attr_len, 0, PAGE_CACHE_SIZE - attr_len);\r\nflush_dcache_page(page);\r\nkunmap_atomic(addr);\r\nput_unm_err_out:\r\nntfs_attr_put_search_ctx(ctx);\r\nunm_err_out:\r\nunmap_mft_record(base_ni);\r\ndone:\r\nSetPageUptodate(page);\r\nerr_out:\r\nunlock_page(page);\r\nreturn err;\r\n}\r\nstatic int ntfs_write_block(struct page *page, struct writeback_control *wbc)\r\n{\r\nVCN vcn;\r\nLCN lcn;\r\ns64 initialized_size;\r\nloff_t i_size;\r\nsector_t block, dblock, iblock;\r\nstruct inode *vi;\r\nntfs_inode *ni;\r\nntfs_volume *vol;\r\nrunlist_element *rl;\r\nstruct buffer_head *bh, *head;\r\nunsigned long flags;\r\nunsigned int blocksize, vcn_ofs;\r\nint err;\r\nbool need_end_writeback;\r\nunsigned char blocksize_bits;\r\nvi = page->mapping->host;\r\nni = NTFS_I(vi);\r\nvol = ni->vol;\r\nntfs_debug("Entering for inode 0x%lx, attribute type 0x%x, page index "\r\n"0x%lx.", ni->mft_no, ni->type, page->index);\r\nBUG_ON(!NInoNonResident(ni));\r\nBUG_ON(NInoMstProtected(ni));\r\nblocksize = vol->sb->s_blocksize;\r\nblocksize_bits = vol->sb->s_blocksize_bits;\r\nif (!page_has_buffers(page)) {\r\nBUG_ON(!PageUptodate(page));\r\ncreate_empty_buffers(page, blocksize,\r\n(1 << BH_Uptodate) | (1 << BH_Dirty));\r\nif (unlikely(!page_has_buffers(page))) {\r\nntfs_warning(vol->sb, "Error allocating page "\r\n"buffers. Redirtying page so we try "\r\n"again later.");\r\nredirty_page_for_writepage(wbc, page);\r\nunlock_page(page);\r\nreturn 0;\r\n}\r\n}\r\nbh = head = page_buffers(page);\r\nBUG_ON(!bh);\r\nblock = (s64)page->index << (PAGE_CACHE_SHIFT - blocksize_bits);\r\nread_lock_irqsave(&ni->size_lock, flags);\r\ni_size = i_size_read(vi);\r\ninitialized_size = ni->initialized_size;\r\nread_unlock_irqrestore(&ni->size_lock, flags);\r\ndblock = (i_size + blocksize - 1) >> blocksize_bits;\r\niblock = initialized_size >> blocksize_bits;\r\nrl = NULL;\r\nerr = 0;\r\ndo {\r\nbool is_retry = false;\r\nif (unlikely(block >= dblock)) {\r\nclear_buffer_dirty(bh);\r\nset_buffer_uptodate(bh);\r\ncontinue;\r\n}\r\nif (!buffer_dirty(bh))\r\ncontinue;\r\nif (unlikely((block >= iblock) &&\r\n(initialized_size < i_size))) {\r\nif (block > iblock) {\r\n}\r\nif (!PageUptodate(page)) {\r\n}\r\nntfs_error(vol->sb, "Writing beyond initialized size "\r\n"is not supported yet. Sorry.");\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nif (buffer_mapped(bh))\r\ncontinue;\r\nbh->b_bdev = vol->sb->s_bdev;\r\nvcn = (VCN)block << blocksize_bits;\r\nvcn_ofs = vcn & vol->cluster_size_mask;\r\nvcn >>= vol->cluster_size_bits;\r\nif (!rl) {\r\nlock_retry_remap:\r\ndown_read(&ni->runlist.lock);\r\nrl = ni->runlist.rl;\r\n}\r\nif (likely(rl != NULL)) {\r\nwhile (rl->length && rl[1].vcn <= vcn)\r\nrl++;\r\nlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\r\n} else\r\nlcn = LCN_RL_NOT_MAPPED;\r\nif (lcn >= 0) {\r\nbh->b_blocknr = ((lcn << vol->cluster_size_bits) +\r\nvcn_ofs) >> blocksize_bits;\r\nset_buffer_mapped(bh);\r\ncontinue;\r\n}\r\nif (lcn == LCN_HOLE) {\r\nu8 *kaddr;\r\nunsigned long *bpos, *bend;\r\nkaddr = kmap_atomic(page);\r\nbpos = (unsigned long *)(kaddr + bh_offset(bh));\r\nbend = (unsigned long *)((u8*)bpos + blocksize);\r\ndo {\r\nif (unlikely(*bpos))\r\nbreak;\r\n} while (likely(++bpos < bend));\r\nkunmap_atomic(kaddr);\r\nif (bpos == bend) {\r\nbh->b_blocknr = -1;\r\nclear_buffer_dirty(bh);\r\ncontinue;\r\n}\r\nntfs_error(vol->sb, "Writing into sparse regions is "\r\n"not supported yet. Sorry.");\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nif (!is_retry && lcn == LCN_RL_NOT_MAPPED) {\r\nis_retry = true;\r\nup_read(&ni->runlist.lock);\r\nerr = ntfs_map_runlist(ni, vcn);\r\nif (likely(!err))\r\ngoto lock_retry_remap;\r\nrl = NULL;\r\n} else if (!rl)\r\nup_read(&ni->runlist.lock);\r\nif (err == -ENOENT || lcn == LCN_ENOENT) {\r\nbh->b_blocknr = -1;\r\nclear_buffer_dirty(bh);\r\nzero_user(page, bh_offset(bh), blocksize);\r\nset_buffer_uptodate(bh);\r\nerr = 0;\r\ncontinue;\r\n}\r\nif (!err)\r\nerr = -EIO;\r\nbh->b_blocknr = -1;\r\nntfs_error(vol->sb, "Failed to write to inode 0x%lx, "\r\n"attribute type 0x%x, vcn 0x%llx, offset 0x%x "\r\n"because its location on disk could not be "\r\n"determined%s (error code %i).", ni->mft_no,\r\nni->type, (unsigned long long)vcn,\r\nvcn_ofs, is_retry ? " even after "\r\n"retrying" : "", err);\r\nbreak;\r\n} while (block++, (bh = bh->b_this_page) != head);\r\nif (rl)\r\nup_read(&ni->runlist.lock);\r\nbh = head;\r\nif (unlikely(!PageUptodate(page))) {\r\nint uptodate = 1;\r\ndo {\r\nif (!buffer_uptodate(bh)) {\r\nuptodate = 0;\r\nbh = head;\r\nbreak;\r\n}\r\n} while ((bh = bh->b_this_page) != head);\r\nif (uptodate)\r\nSetPageUptodate(page);\r\n}\r\ndo {\r\nif (buffer_mapped(bh) && buffer_dirty(bh)) {\r\nlock_buffer(bh);\r\nif (test_clear_buffer_dirty(bh)) {\r\nBUG_ON(!buffer_uptodate(bh));\r\nmark_buffer_async_write(bh);\r\n} else\r\nunlock_buffer(bh);\r\n} else if (unlikely(err)) {\r\nif (err != -ENOMEM)\r\nclear_buffer_dirty(bh);\r\n}\r\n} while ((bh = bh->b_this_page) != head);\r\nif (unlikely(err)) {\r\nif (unlikely(err == -EOPNOTSUPP))\r\nerr = 0;\r\nelse if (err == -ENOMEM) {\r\nntfs_warning(vol->sb, "Error allocating memory. "\r\n"Redirtying page so we try again "\r\n"later.");\r\nredirty_page_for_writepage(wbc, page);\r\nerr = 0;\r\n} else\r\nSetPageError(page);\r\n}\r\nBUG_ON(PageWriteback(page));\r\nset_page_writeback(page);\r\nneed_end_writeback = true;\r\ndo {\r\nstruct buffer_head *next = bh->b_this_page;\r\nif (buffer_async_write(bh)) {\r\nsubmit_bh(WRITE, bh);\r\nneed_end_writeback = false;\r\n}\r\nbh = next;\r\n} while (bh != head);\r\nunlock_page(page);\r\nif (unlikely(need_end_writeback))\r\nend_page_writeback(page);\r\nntfs_debug("Done.");\r\nreturn err;\r\n}\r\nstatic int ntfs_write_mst_block(struct page *page,\r\nstruct writeback_control *wbc)\r\n{\r\nsector_t block, dblock, rec_block;\r\nstruct inode *vi = page->mapping->host;\r\nntfs_inode *ni = NTFS_I(vi);\r\nntfs_volume *vol = ni->vol;\r\nu8 *kaddr;\r\nunsigned int rec_size = ni->itype.index.block_size;\r\nntfs_inode *locked_nis[PAGE_CACHE_SIZE / rec_size];\r\nstruct buffer_head *bh, *head, *tbh, *rec_start_bh;\r\nstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\r\nrunlist_element *rl;\r\nint i, nr_locked_nis, nr_recs, nr_bhs, max_bhs, bhs_per_rec, err, err2;\r\nunsigned bh_size, rec_size_bits;\r\nbool sync, is_mft, page_is_dirty, rec_is_dirty;\r\nunsigned char bh_size_bits;\r\nntfs_debug("Entering for inode 0x%lx, attribute type 0x%x, page index "\r\n"0x%lx.", vi->i_ino, ni->type, page->index);\r\nBUG_ON(!NInoNonResident(ni));\r\nBUG_ON(!NInoMstProtected(ni));\r\nis_mft = (S_ISREG(vi->i_mode) && !vi->i_ino);\r\nBUG_ON(!(is_mft || S_ISDIR(vi->i_mode) ||\r\n(NInoAttr(ni) && ni->type == AT_INDEX_ALLOCATION)));\r\nbh_size = vol->sb->s_blocksize;\r\nbh_size_bits = vol->sb->s_blocksize_bits;\r\nmax_bhs = PAGE_CACHE_SIZE / bh_size;\r\nBUG_ON(!max_bhs);\r\nBUG_ON(max_bhs > MAX_BUF_PER_PAGE);\r\nsync = (wbc->sync_mode == WB_SYNC_ALL);\r\nbh = head = page_buffers(page);\r\nBUG_ON(!bh);\r\nrec_size_bits = ni->itype.index.block_size_bits;\r\nBUG_ON(!(PAGE_CACHE_SIZE >> rec_size_bits));\r\nbhs_per_rec = rec_size >> bh_size_bits;\r\nBUG_ON(!bhs_per_rec);\r\nrec_block = block = (sector_t)page->index <<\r\n(PAGE_CACHE_SHIFT - bh_size_bits);\r\ndblock = (i_size_read(vi) + bh_size - 1) >> bh_size_bits;\r\nrl = NULL;\r\nerr = err2 = nr_bhs = nr_recs = nr_locked_nis = 0;\r\npage_is_dirty = rec_is_dirty = false;\r\nrec_start_bh = NULL;\r\ndo {\r\nbool is_retry = false;\r\nif (likely(block < rec_block)) {\r\nif (unlikely(block >= dblock)) {\r\nclear_buffer_dirty(bh);\r\nset_buffer_uptodate(bh);\r\ncontinue;\r\n}\r\nif (!rec_is_dirty)\r\ncontinue;\r\nif (unlikely(err2)) {\r\nif (err2 != -ENOMEM)\r\nclear_buffer_dirty(bh);\r\ncontinue;\r\n}\r\n} else {\r\nBUG_ON(block > rec_block);\r\nrec_block += bhs_per_rec;\r\nerr2 = 0;\r\nif (unlikely(block >= dblock)) {\r\nclear_buffer_dirty(bh);\r\ncontinue;\r\n}\r\nif (!buffer_dirty(bh)) {\r\nrec_is_dirty = false;\r\ncontinue;\r\n}\r\nrec_is_dirty = true;\r\nrec_start_bh = bh;\r\n}\r\nif (unlikely(!buffer_mapped(bh))) {\r\nVCN vcn;\r\nLCN lcn;\r\nunsigned int vcn_ofs;\r\nbh->b_bdev = vol->sb->s_bdev;\r\nvcn = (VCN)block << bh_size_bits;\r\nvcn_ofs = vcn & vol->cluster_size_mask;\r\nvcn >>= vol->cluster_size_bits;\r\nif (!rl) {\r\nlock_retry_remap:\r\ndown_read(&ni->runlist.lock);\r\nrl = ni->runlist.rl;\r\n}\r\nif (likely(rl != NULL)) {\r\nwhile (rl->length && rl[1].vcn <= vcn)\r\nrl++;\r\nlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\r\n} else\r\nlcn = LCN_RL_NOT_MAPPED;\r\nif (likely(lcn >= 0)) {\r\nbh->b_blocknr = ((lcn <<\r\nvol->cluster_size_bits) +\r\nvcn_ofs) >> bh_size_bits;\r\nset_buffer_mapped(bh);\r\n} else {\r\nif (!is_mft && !is_retry &&\r\nlcn == LCN_RL_NOT_MAPPED) {\r\nis_retry = true;\r\nup_read(&ni->runlist.lock);\r\nerr2 = ntfs_map_runlist(ni, vcn);\r\nif (likely(!err2))\r\ngoto lock_retry_remap;\r\nif (err2 == -ENOMEM)\r\npage_is_dirty = true;\r\nlcn = err2;\r\n} else {\r\nerr2 = -EIO;\r\nif (!rl)\r\nup_read(&ni->runlist.lock);\r\n}\r\nif (!err || err == -ENOMEM)\r\nerr = err2;\r\nbh->b_blocknr = -1;\r\nntfs_error(vol->sb, "Cannot write ntfs record "\r\n"0x%llx (inode 0x%lx, "\r\n"attribute type 0x%x) because "\r\n"its location on disk could "\r\n"not be determined (error "\r\n"code %lli).",\r\n(long long)block <<\r\nbh_size_bits >>\r\nvol->mft_record_size_bits,\r\nni->mft_no, ni->type,\r\n(long long)lcn);\r\nif (rec_start_bh != bh) {\r\nwhile (bhs[--nr_bhs] != rec_start_bh)\r\n;\r\nif (err2 != -ENOMEM) {\r\ndo {\r\nclear_buffer_dirty(\r\nrec_start_bh);\r\n} while ((rec_start_bh =\r\nrec_start_bh->\r\nb_this_page) !=\r\nbh);\r\n}\r\n}\r\ncontinue;\r\n}\r\n}\r\nBUG_ON(!buffer_uptodate(bh));\r\nBUG_ON(nr_bhs >= max_bhs);\r\nbhs[nr_bhs++] = bh;\r\n} while (block++, (bh = bh->b_this_page) != head);\r\nif (unlikely(rl))\r\nup_read(&ni->runlist.lock);\r\nif (!nr_bhs)\r\ngoto done;\r\nkaddr = kmap(page);\r\nBUG_ON(!PageUptodate(page));\r\nClearPageUptodate(page);\r\nfor (i = 0; i < nr_bhs; i++) {\r\nunsigned int ofs;\r\nif (i % bhs_per_rec)\r\ncontinue;\r\ntbh = bhs[i];\r\nofs = bh_offset(tbh);\r\nif (is_mft) {\r\nntfs_inode *tni;\r\nunsigned long mft_no;\r\nmft_no = (((s64)page->index << PAGE_CACHE_SHIFT) + ofs)\r\n>> rec_size_bits;\r\ntni = NULL;\r\nif (!ntfs_may_write_mft_record(vol, mft_no,\r\n(MFT_RECORD*)(kaddr + ofs), &tni)) {\r\npage_is_dirty = true;\r\ndo {\r\nbhs[i] = NULL;\r\n} while (++i % bhs_per_rec);\r\ncontinue;\r\n}\r\nif (tni)\r\nlocked_nis[nr_locked_nis++] = tni;\r\n}\r\nerr2 = pre_write_mst_fixup((NTFS_RECORD*)(kaddr + ofs),\r\nrec_size);\r\nif (unlikely(err2)) {\r\nif (!err || err == -ENOMEM)\r\nerr = -EIO;\r\nntfs_error(vol->sb, "Failed to apply mst fixups "\r\n"(inode 0x%lx, attribute type 0x%x, "\r\n"page index 0x%lx, page offset 0x%x)!"\r\n" Unmount and run chkdsk.", vi->i_ino,\r\nni->type, page->index, ofs);\r\ndo {\r\nclear_buffer_dirty(bhs[i]);\r\nbhs[i] = NULL;\r\n} while (++i % bhs_per_rec);\r\ncontinue;\r\n}\r\nnr_recs++;\r\n}\r\nif (!nr_recs)\r\ngoto unm_done;\r\nflush_dcache_page(page);\r\nfor (i = 0; i < nr_bhs; i++) {\r\ntbh = bhs[i];\r\nif (!tbh)\r\ncontinue;\r\nif (!trylock_buffer(tbh))\r\nBUG();\r\nclear_buffer_dirty(tbh);\r\nBUG_ON(!buffer_uptodate(tbh));\r\nBUG_ON(!buffer_mapped(tbh));\r\nget_bh(tbh);\r\ntbh->b_end_io = end_buffer_write_sync;\r\nsubmit_bh(WRITE, tbh);\r\n}\r\nif (is_mft && !sync)\r\ngoto do_mirror;\r\ndo_wait:\r\nfor (i = 0; i < nr_bhs; i++) {\r\ntbh = bhs[i];\r\nif (!tbh)\r\ncontinue;\r\nwait_on_buffer(tbh);\r\nif (unlikely(!buffer_uptodate(tbh))) {\r\nntfs_error(vol->sb, "I/O error while writing ntfs "\r\n"record buffer (inode 0x%lx, "\r\n"attribute type 0x%x, page index "\r\n"0x%lx, page offset 0x%lx)! Unmount "\r\n"and run chkdsk.", vi->i_ino, ni->type,\r\npage->index, bh_offset(tbh));\r\nif (!err || err == -ENOMEM)\r\nerr = -EIO;\r\nset_buffer_uptodate(tbh);\r\n}\r\n}\r\nif (is_mft && sync) {\r\ndo_mirror:\r\nfor (i = 0; i < nr_bhs; i++) {\r\nunsigned long mft_no;\r\nunsigned int ofs;\r\nif (i % bhs_per_rec)\r\ncontinue;\r\ntbh = bhs[i];\r\nif (!tbh)\r\ncontinue;\r\nofs = bh_offset(tbh);\r\nmft_no = (((s64)page->index << PAGE_CACHE_SHIFT) + ofs)\r\n>> rec_size_bits;\r\nif (mft_no < vol->mftmirr_size)\r\nntfs_sync_mft_mirror(vol, mft_no,\r\n(MFT_RECORD*)(kaddr + ofs),\r\nsync);\r\n}\r\nif (!sync)\r\ngoto do_wait;\r\n}\r\nfor (i = 0; i < nr_bhs; i++) {\r\nif (!(i % bhs_per_rec)) {\r\ntbh = bhs[i];\r\nif (!tbh)\r\ncontinue;\r\npost_write_mst_fixup((NTFS_RECORD*)(kaddr +\r\nbh_offset(tbh)));\r\n}\r\n}\r\nflush_dcache_page(page);\r\nunm_done:\r\nwhile (nr_locked_nis-- > 0) {\r\nntfs_inode *tni, *base_tni;\r\ntni = locked_nis[nr_locked_nis];\r\nmutex_lock(&tni->extent_lock);\r\nif (tni->nr_extents >= 0)\r\nbase_tni = tni;\r\nelse {\r\nbase_tni = tni->ext.base_ntfs_ino;\r\nBUG_ON(!base_tni);\r\n}\r\nmutex_unlock(&tni->extent_lock);\r\nntfs_debug("Unlocking %s inode 0x%lx.",\r\ntni == base_tni ? "base" : "extent",\r\ntni->mft_no);\r\nmutex_unlock(&tni->mrec_lock);\r\natomic_dec(&tni->count);\r\niput(VFS_I(base_tni));\r\n}\r\nSetPageUptodate(page);\r\nkunmap(page);\r\ndone:\r\nif (unlikely(err && err != -ENOMEM)) {\r\nif (ni->itype.index.block_size == PAGE_CACHE_SIZE)\r\nSetPageError(page);\r\nNVolSetErrors(vol);\r\n}\r\nif (page_is_dirty) {\r\nntfs_debug("Page still contains one or more dirty ntfs "\r\n"records. Redirtying the page starting at "\r\n"record 0x%lx.", page->index <<\r\n(PAGE_CACHE_SHIFT - rec_size_bits));\r\nredirty_page_for_writepage(wbc, page);\r\nunlock_page(page);\r\n} else {\r\nBUG_ON(PageWriteback(page));\r\nset_page_writeback(page);\r\nunlock_page(page);\r\nend_page_writeback(page);\r\n}\r\nif (likely(!err))\r\nntfs_debug("Done.");\r\nreturn err;\r\n}\r\nstatic int ntfs_writepage(struct page *page, struct writeback_control *wbc)\r\n{\r\nloff_t i_size;\r\nstruct inode *vi = page->mapping->host;\r\nntfs_inode *base_ni = NULL, *ni = NTFS_I(vi);\r\nchar *addr;\r\nntfs_attr_search_ctx *ctx = NULL;\r\nMFT_RECORD *m = NULL;\r\nu32 attr_len;\r\nint err;\r\nretry_writepage:\r\nBUG_ON(!PageLocked(page));\r\ni_size = i_size_read(vi);\r\nif (unlikely(page->index >= (i_size + PAGE_CACHE_SIZE - 1) >>\r\nPAGE_CACHE_SHIFT)) {\r\nblock_invalidatepage(page, 0, PAGE_CACHE_SIZE);\r\nunlock_page(page);\r\nntfs_debug("Write outside i_size - truncated?");\r\nreturn 0;\r\n}\r\nif (ni->type != AT_INDEX_ALLOCATION) {\r\nif (NInoEncrypted(ni)) {\r\nunlock_page(page);\r\nBUG_ON(ni->type != AT_DATA);\r\nntfs_debug("Denying write access to encrypted file.");\r\nreturn -EACCES;\r\n}\r\nif (NInoNonResident(ni) && NInoCompressed(ni)) {\r\nBUG_ON(ni->type != AT_DATA);\r\nBUG_ON(ni->name_len);\r\nunlock_page(page);\r\nntfs_error(vi->i_sb, "Writing to compressed files is "\r\n"not supported yet. Sorry.");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (NInoNonResident(ni) && NInoSparse(ni)) {\r\nunlock_page(page);\r\nntfs_error(vi->i_sb, "Writing to sparse files is not "\r\n"supported yet. Sorry.");\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nif (NInoNonResident(ni)) {\r\nif (page->index >= (i_size >> PAGE_CACHE_SHIFT)) {\r\nunsigned int ofs = i_size & ~PAGE_CACHE_MASK;\r\nzero_user_segment(page, ofs, PAGE_CACHE_SIZE);\r\n}\r\nif (NInoMstProtected(ni))\r\nreturn ntfs_write_mst_block(page, wbc);\r\nreturn ntfs_write_block(page, wbc);\r\n}\r\nBUG_ON(page_has_buffers(page));\r\nBUG_ON(!PageUptodate(page));\r\nif (unlikely(page->index > 0)) {\r\nntfs_error(vi->i_sb, "BUG()! page->index (0x%lx) > 0. "\r\n"Aborting write.", page->index);\r\nBUG_ON(PageWriteback(page));\r\nset_page_writeback(page);\r\nunlock_page(page);\r\nend_page_writeback(page);\r\nreturn -EIO;\r\n}\r\nif (!NInoAttr(ni))\r\nbase_ni = ni;\r\nelse\r\nbase_ni = ni->ext.base_ntfs_ino;\r\nm = map_mft_record(base_ni);\r\nif (IS_ERR(m)) {\r\nerr = PTR_ERR(m);\r\nm = NULL;\r\nctx = NULL;\r\ngoto err_out;\r\n}\r\nif (unlikely(NInoNonResident(ni))) {\r\nunmap_mft_record(base_ni);\r\ngoto retry_writepage;\r\n}\r\nctx = ntfs_attr_get_search_ctx(base_ni, m);\r\nif (unlikely(!ctx)) {\r\nerr = -ENOMEM;\r\ngoto err_out;\r\n}\r\nerr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\r\nCASE_SENSITIVE, 0, NULL, 0, ctx);\r\nif (unlikely(err))\r\ngoto err_out;\r\nBUG_ON(PageWriteback(page));\r\nset_page_writeback(page);\r\nunlock_page(page);\r\nattr_len = le32_to_cpu(ctx->attr->data.resident.value_length);\r\ni_size = i_size_read(vi);\r\nif (unlikely(attr_len > i_size)) {\r\nattr_len = i_size;\r\nerr = ntfs_resident_attr_value_resize(ctx->mrec, ctx->attr,\r\nattr_len);\r\nBUG_ON(err);\r\n}\r\naddr = kmap_atomic(page);\r\nmemcpy((u8*)ctx->attr +\r\nle16_to_cpu(ctx->attr->data.resident.value_offset),\r\naddr, attr_len);\r\nmemset(addr + attr_len, 0, PAGE_CACHE_SIZE - attr_len);\r\nkunmap_atomic(addr);\r\nflush_dcache_page(page);\r\nflush_dcache_mft_record_page(ctx->ntfs_ino);\r\nend_page_writeback(page);\r\nmark_mft_record_dirty(ctx->ntfs_ino);\r\nntfs_attr_put_search_ctx(ctx);\r\nunmap_mft_record(base_ni);\r\nreturn 0;\r\nerr_out:\r\nif (err == -ENOMEM) {\r\nntfs_warning(vi->i_sb, "Error allocating memory. Redirtying "\r\n"page so we try again later.");\r\nredirty_page_for_writepage(wbc, page);\r\nerr = 0;\r\n} else {\r\nntfs_error(vi->i_sb, "Resident attribute write failed with "\r\n"error %i.", err);\r\nSetPageError(page);\r\nNVolSetErrors(ni->vol);\r\n}\r\nunlock_page(page);\r\nif (ctx)\r\nntfs_attr_put_search_ctx(ctx);\r\nif (m)\r\nunmap_mft_record(base_ni);\r\nreturn err;\r\n}\r\nstatic sector_t ntfs_bmap(struct address_space *mapping, sector_t block)\r\n{\r\ns64 ofs, size;\r\nloff_t i_size;\r\nLCN lcn;\r\nunsigned long blocksize, flags;\r\nntfs_inode *ni = NTFS_I(mapping->host);\r\nntfs_volume *vol = ni->vol;\r\nunsigned delta;\r\nunsigned char blocksize_bits, cluster_size_shift;\r\nntfs_debug("Entering for mft_no 0x%lx, logical block 0x%llx.",\r\nni->mft_no, (unsigned long long)block);\r\nif (ni->type != AT_DATA || !NInoNonResident(ni) || NInoEncrypted(ni)) {\r\nntfs_error(vol->sb, "BMAP does not make sense for %s "\r\n"attributes, returning 0.",\r\n(ni->type != AT_DATA) ? "non-data" :\r\n(!NInoNonResident(ni) ? "resident" :\r\n"encrypted"));\r\nreturn 0;\r\n}\r\nBUG_ON(NInoCompressed(ni));\r\nBUG_ON(NInoMstProtected(ni));\r\nblocksize = vol->sb->s_blocksize;\r\nblocksize_bits = vol->sb->s_blocksize_bits;\r\nofs = (s64)block << blocksize_bits;\r\nread_lock_irqsave(&ni->size_lock, flags);\r\nsize = ni->initialized_size;\r\ni_size = i_size_read(VFS_I(ni));\r\nread_unlock_irqrestore(&ni->size_lock, flags);\r\nif (unlikely(ofs >= size || (ofs + blocksize > size && size < i_size)))\r\ngoto hole;\r\ncluster_size_shift = vol->cluster_size_bits;\r\ndown_read(&ni->runlist.lock);\r\nlcn = ntfs_attr_vcn_to_lcn_nolock(ni, ofs >> cluster_size_shift, false);\r\nup_read(&ni->runlist.lock);\r\nif (unlikely(lcn < LCN_HOLE)) {\r\nswitch ((int)lcn) {\r\ncase LCN_ENOENT:\r\ngoto hole;\r\ncase LCN_ENOMEM:\r\nntfs_error(vol->sb, "Not enough memory to complete "\r\n"mapping for inode 0x%lx. "\r\n"Returning 0.", ni->mft_no);\r\nbreak;\r\ndefault:\r\nntfs_error(vol->sb, "Failed to complete mapping for "\r\n"inode 0x%lx. Run chkdsk. "\r\n"Returning 0.", ni->mft_no);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nif (lcn < 0) {\r\nhole:\r\nntfs_debug("Done (returning hole).");\r\nreturn 0;\r\n}\r\ndelta = ofs & vol->cluster_size_mask;\r\nif (unlikely(sizeof(block) < sizeof(lcn))) {\r\nblock = lcn = ((lcn << cluster_size_shift) + delta) >>\r\nblocksize_bits;\r\nif (unlikely(block != lcn)) {\r\nntfs_error(vol->sb, "Physical block 0x%llx is too "\r\n"large to be returned, returning 0.",\r\n(long long)lcn);\r\nreturn 0;\r\n}\r\n} else\r\nblock = ((lcn << cluster_size_shift) + delta) >>\r\nblocksize_bits;\r\nntfs_debug("Done (returning block 0x%llx).", (unsigned long long)lcn);\r\nreturn block;\r\n}\r\nvoid mark_ntfs_record_dirty(struct page *page, const unsigned int ofs) {\r\nstruct address_space *mapping = page->mapping;\r\nntfs_inode *ni = NTFS_I(mapping->host);\r\nstruct buffer_head *bh, *head, *buffers_to_free = NULL;\r\nunsigned int end, bh_size, bh_ofs;\r\nBUG_ON(!PageUptodate(page));\r\nend = ofs + ni->itype.index.block_size;\r\nbh_size = VFS_I(ni)->i_sb->s_blocksize;\r\nspin_lock(&mapping->private_lock);\r\nif (unlikely(!page_has_buffers(page))) {\r\nspin_unlock(&mapping->private_lock);\r\nbh = head = alloc_page_buffers(page, bh_size, 1);\r\nspin_lock(&mapping->private_lock);\r\nif (likely(!page_has_buffers(page))) {\r\nstruct buffer_head *tail;\r\ndo {\r\nset_buffer_uptodate(bh);\r\ntail = bh;\r\nbh = bh->b_this_page;\r\n} while (bh);\r\ntail->b_this_page = head;\r\nattach_page_buffers(page, head);\r\n} else\r\nbuffers_to_free = bh;\r\n}\r\nbh = head = page_buffers(page);\r\nBUG_ON(!bh);\r\ndo {\r\nbh_ofs = bh_offset(bh);\r\nif (bh_ofs + bh_size <= ofs)\r\ncontinue;\r\nif (unlikely(bh_ofs >= end))\r\nbreak;\r\nset_buffer_dirty(bh);\r\n} while ((bh = bh->b_this_page) != head);\r\nspin_unlock(&mapping->private_lock);\r\n__set_page_dirty_nobuffers(page);\r\nif (unlikely(buffers_to_free)) {\r\ndo {\r\nbh = buffers_to_free->b_this_page;\r\nfree_buffer_head(buffers_to_free);\r\nbuffers_to_free = bh;\r\n} while (buffers_to_free);\r\n}\r\n}
