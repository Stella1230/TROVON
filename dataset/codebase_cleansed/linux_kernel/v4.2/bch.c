static void encode_bch_unaligned(struct bch_control *bch,\r\nconst unsigned char *data, unsigned int len,\r\nuint32_t *ecc)\r\n{\r\nint i;\r\nconst uint32_t *p;\r\nconst int l = BCH_ECC_WORDS(bch)-1;\r\nwhile (len--) {\r\np = bch->mod8_tab + (l+1)*(((ecc[0] >> 24)^(*data++)) & 0xff);\r\nfor (i = 0; i < l; i++)\r\necc[i] = ((ecc[i] << 8)|(ecc[i+1] >> 24))^(*p++);\r\necc[l] = (ecc[l] << 8)^(*p);\r\n}\r\n}\r\nstatic void load_ecc8(struct bch_control *bch, uint32_t *dst,\r\nconst uint8_t *src)\r\n{\r\nuint8_t pad[4] = {0, 0, 0, 0};\r\nunsigned int i, nwords = BCH_ECC_WORDS(bch)-1;\r\nfor (i = 0; i < nwords; i++, src += 4)\r\ndst[i] = (src[0] << 24)|(src[1] << 16)|(src[2] << 8)|src[3];\r\nmemcpy(pad, src, BCH_ECC_BYTES(bch)-4*nwords);\r\ndst[nwords] = (pad[0] << 24)|(pad[1] << 16)|(pad[2] << 8)|pad[3];\r\n}\r\nstatic void store_ecc8(struct bch_control *bch, uint8_t *dst,\r\nconst uint32_t *src)\r\n{\r\nuint8_t pad[4];\r\nunsigned int i, nwords = BCH_ECC_WORDS(bch)-1;\r\nfor (i = 0; i < nwords; i++) {\r\n*dst++ = (src[i] >> 24);\r\n*dst++ = (src[i] >> 16) & 0xff;\r\n*dst++ = (src[i] >> 8) & 0xff;\r\n*dst++ = (src[i] >> 0) & 0xff;\r\n}\r\npad[0] = (src[nwords] >> 24);\r\npad[1] = (src[nwords] >> 16) & 0xff;\r\npad[2] = (src[nwords] >> 8) & 0xff;\r\npad[3] = (src[nwords] >> 0) & 0xff;\r\nmemcpy(dst, pad, BCH_ECC_BYTES(bch)-4*nwords);\r\n}\r\nvoid encode_bch(struct bch_control *bch, const uint8_t *data,\r\nunsigned int len, uint8_t *ecc)\r\n{\r\nconst unsigned int l = BCH_ECC_WORDS(bch)-1;\r\nunsigned int i, mlen;\r\nunsigned long m;\r\nuint32_t w, r[l+1];\r\nconst uint32_t * const tab0 = bch->mod8_tab;\r\nconst uint32_t * const tab1 = tab0 + 256*(l+1);\r\nconst uint32_t * const tab2 = tab1 + 256*(l+1);\r\nconst uint32_t * const tab3 = tab2 + 256*(l+1);\r\nconst uint32_t *pdata, *p0, *p1, *p2, *p3;\r\nif (ecc) {\r\nload_ecc8(bch, bch->ecc_buf, ecc);\r\n} else {\r\nmemset(bch->ecc_buf, 0, sizeof(r));\r\n}\r\nm = ((unsigned long)data) & 3;\r\nif (m) {\r\nmlen = (len < (4-m)) ? len : 4-m;\r\nencode_bch_unaligned(bch, data, mlen, bch->ecc_buf);\r\ndata += mlen;\r\nlen -= mlen;\r\n}\r\npdata = (uint32_t *)data;\r\nmlen = len/4;\r\ndata += 4*mlen;\r\nlen -= 4*mlen;\r\nmemcpy(r, bch->ecc_buf, sizeof(r));\r\nwhile (mlen--) {\r\nw = r[0]^cpu_to_be32(*pdata++);\r\np0 = tab0 + (l+1)*((w >> 0) & 0xff);\r\np1 = tab1 + (l+1)*((w >> 8) & 0xff);\r\np2 = tab2 + (l+1)*((w >> 16) & 0xff);\r\np3 = tab3 + (l+1)*((w >> 24) & 0xff);\r\nfor (i = 0; i < l; i++)\r\nr[i] = r[i+1]^p0[i]^p1[i]^p2[i]^p3[i];\r\nr[l] = p0[l]^p1[l]^p2[l]^p3[l];\r\n}\r\nmemcpy(bch->ecc_buf, r, sizeof(r));\r\nif (len)\r\nencode_bch_unaligned(bch, data, len, bch->ecc_buf);\r\nif (ecc)\r\nstore_ecc8(bch, ecc, bch->ecc_buf);\r\n}\r\nstatic inline int modulo(struct bch_control *bch, unsigned int v)\r\n{\r\nconst unsigned int n = GF_N(bch);\r\nwhile (v >= n) {\r\nv -= n;\r\nv = (v & n) + (v >> GF_M(bch));\r\n}\r\nreturn v;\r\n}\r\nstatic inline int mod_s(struct bch_control *bch, unsigned int v)\r\n{\r\nconst unsigned int n = GF_N(bch);\r\nreturn (v < n) ? v : v-n;\r\n}\r\nstatic inline int deg(unsigned int poly)\r\n{\r\nreturn fls(poly)-1;\r\n}\r\nstatic inline int parity(unsigned int x)\r\n{\r\nx ^= x >> 1;\r\nx ^= x >> 2;\r\nx = (x & 0x11111111U) * 0x11111111U;\r\nreturn (x >> 28) & 1;\r\n}\r\nstatic inline unsigned int gf_mul(struct bch_control *bch, unsigned int a,\r\nunsigned int b)\r\n{\r\nreturn (a && b) ? bch->a_pow_tab[mod_s(bch, bch->a_log_tab[a]+\r\nbch->a_log_tab[b])] : 0;\r\n}\r\nstatic inline unsigned int gf_sqr(struct bch_control *bch, unsigned int a)\r\n{\r\nreturn a ? bch->a_pow_tab[mod_s(bch, 2*bch->a_log_tab[a])] : 0;\r\n}\r\nstatic inline unsigned int gf_div(struct bch_control *bch, unsigned int a,\r\nunsigned int b)\r\n{\r\nreturn a ? bch->a_pow_tab[mod_s(bch, bch->a_log_tab[a]+\r\nGF_N(bch)-bch->a_log_tab[b])] : 0;\r\n}\r\nstatic inline unsigned int gf_inv(struct bch_control *bch, unsigned int a)\r\n{\r\nreturn bch->a_pow_tab[GF_N(bch)-bch->a_log_tab[a]];\r\n}\r\nstatic inline unsigned int a_pow(struct bch_control *bch, int i)\r\n{\r\nreturn bch->a_pow_tab[modulo(bch, i)];\r\n}\r\nstatic inline int a_log(struct bch_control *bch, unsigned int x)\r\n{\r\nreturn bch->a_log_tab[x];\r\n}\r\nstatic inline int a_ilog(struct bch_control *bch, unsigned int x)\r\n{\r\nreturn mod_s(bch, GF_N(bch)-bch->a_log_tab[x]);\r\n}\r\nstatic void compute_syndromes(struct bch_control *bch, uint32_t *ecc,\r\nunsigned int *syn)\r\n{\r\nint i, j, s;\r\nunsigned int m;\r\nuint32_t poly;\r\nconst int t = GF_T(bch);\r\ns = bch->ecc_bits;\r\nm = ((unsigned int)s) & 31;\r\nif (m)\r\necc[s/32] &= ~((1u << (32-m))-1);\r\nmemset(syn, 0, 2*t*sizeof(*syn));\r\ndo {\r\npoly = *ecc++;\r\ns -= 32;\r\nwhile (poly) {\r\ni = deg(poly);\r\nfor (j = 0; j < 2*t; j += 2)\r\nsyn[j] ^= a_pow(bch, (j+1)*(i+s));\r\npoly ^= (1 << i);\r\n}\r\n} while (s > 0);\r\nfor (j = 0; j < t; j++)\r\nsyn[2*j+1] = gf_sqr(bch, syn[j]);\r\n}\r\nstatic void gf_poly_copy(struct gf_poly *dst, struct gf_poly *src)\r\n{\r\nmemcpy(dst, src, GF_POLY_SZ(src->deg));\r\n}\r\nstatic int compute_error_locator_polynomial(struct bch_control *bch,\r\nconst unsigned int *syn)\r\n{\r\nconst unsigned int t = GF_T(bch);\r\nconst unsigned int n = GF_N(bch);\r\nunsigned int i, j, tmp, l, pd = 1, d = syn[0];\r\nstruct gf_poly *elp = bch->elp;\r\nstruct gf_poly *pelp = bch->poly_2t[0];\r\nstruct gf_poly *elp_copy = bch->poly_2t[1];\r\nint k, pp = -1;\r\nmemset(pelp, 0, GF_POLY_SZ(2*t));\r\nmemset(elp, 0, GF_POLY_SZ(2*t));\r\npelp->deg = 0;\r\npelp->c[0] = 1;\r\nelp->deg = 0;\r\nelp->c[0] = 1;\r\nfor (i = 0; (i < t) && (elp->deg <= t); i++) {\r\nif (d) {\r\nk = 2*i-pp;\r\ngf_poly_copy(elp_copy, elp);\r\ntmp = a_log(bch, d)+n-a_log(bch, pd);\r\nfor (j = 0; j <= pelp->deg; j++) {\r\nif (pelp->c[j]) {\r\nl = a_log(bch, pelp->c[j]);\r\nelp->c[j+k] ^= a_pow(bch, tmp+l);\r\n}\r\n}\r\ntmp = pelp->deg+k;\r\nif (tmp > elp->deg) {\r\nelp->deg = tmp;\r\ngf_poly_copy(pelp, elp_copy);\r\npd = d;\r\npp = 2*i;\r\n}\r\n}\r\nif (i < t-1) {\r\nd = syn[2*i+2];\r\nfor (j = 1; j <= elp->deg; j++)\r\nd ^= gf_mul(bch, elp->c[j], syn[2*i+2-j]);\r\n}\r\n}\r\ndbg("elp=%s\n", gf_poly_str(elp));\r\nreturn (elp->deg > t) ? -1 : (int)elp->deg;\r\n}\r\nstatic int solve_linear_system(struct bch_control *bch, unsigned int *rows,\r\nunsigned int *sol, int nsol)\r\n{\r\nconst int m = GF_M(bch);\r\nunsigned int tmp, mask;\r\nint rem, c, r, p, k, param[m];\r\nk = 0;\r\nmask = 1 << m;\r\nfor (c = 0; c < m; c++) {\r\nrem = 0;\r\np = c-k;\r\nfor (r = p; r < m; r++) {\r\nif (rows[r] & mask) {\r\nif (r != p) {\r\ntmp = rows[r];\r\nrows[r] = rows[p];\r\nrows[p] = tmp;\r\n}\r\nrem = r+1;\r\nbreak;\r\n}\r\n}\r\nif (rem) {\r\ntmp = rows[p];\r\nfor (r = rem; r < m; r++) {\r\nif (rows[r] & mask)\r\nrows[r] ^= tmp;\r\n}\r\n} else {\r\nparam[k++] = c;\r\n}\r\nmask >>= 1;\r\n}\r\nif (k > 0) {\r\np = k;\r\nfor (r = m-1; r >= 0; r--) {\r\nif ((r > m-1-k) && rows[r])\r\nreturn 0;\r\nrows[r] = (p && (r == param[p-1])) ?\r\np--, 1u << (m-r) : rows[r-p];\r\n}\r\n}\r\nif (nsol != (1 << k))\r\nreturn 0;\r\nfor (p = 0; p < nsol; p++) {\r\nfor (c = 0; c < k; c++)\r\nrows[param[c]] = (rows[param[c]] & ~1)|((p >> c) & 1);\r\ntmp = 0;\r\nfor (r = m-1; r >= 0; r--) {\r\nmask = rows[r] & (tmp|1);\r\ntmp |= parity(mask) << (m-r);\r\n}\r\nsol[p] = tmp >> 1;\r\n}\r\nreturn nsol;\r\n}\r\nstatic int find_affine4_roots(struct bch_control *bch, unsigned int a,\r\nunsigned int b, unsigned int c,\r\nunsigned int *roots)\r\n{\r\nint i, j, k;\r\nconst int m = GF_M(bch);\r\nunsigned int mask = 0xff, t, rows[16] = {0,};\r\nj = a_log(bch, b);\r\nk = a_log(bch, a);\r\nrows[0] = c;\r\nfor (i = 0; i < m; i++) {\r\nrows[i+1] = bch->a_pow_tab[4*i]^\r\n(a ? bch->a_pow_tab[mod_s(bch, k)] : 0)^\r\n(b ? bch->a_pow_tab[mod_s(bch, j)] : 0);\r\nj++;\r\nk += 2;\r\n}\r\nfor (j = 8; j != 0; j >>= 1, mask ^= (mask << j)) {\r\nfor (k = 0; k < 16; k = (k+j+1) & ~j) {\r\nt = ((rows[k] >> j)^rows[k+j]) & mask;\r\nrows[k] ^= (t << j);\r\nrows[k+j] ^= t;\r\n}\r\n}\r\nreturn solve_linear_system(bch, rows, roots, 4);\r\n}\r\nstatic int find_poly_deg1_roots(struct bch_control *bch, struct gf_poly *poly,\r\nunsigned int *roots)\r\n{\r\nint n = 0;\r\nif (poly->c[0])\r\nroots[n++] = mod_s(bch, GF_N(bch)-bch->a_log_tab[poly->c[0]]+\r\nbch->a_log_tab[poly->c[1]]);\r\nreturn n;\r\n}\r\nstatic int find_poly_deg2_roots(struct bch_control *bch, struct gf_poly *poly,\r\nunsigned int *roots)\r\n{\r\nint n = 0, i, l0, l1, l2;\r\nunsigned int u, v, r;\r\nif (poly->c[0] && poly->c[1]) {\r\nl0 = bch->a_log_tab[poly->c[0]];\r\nl1 = bch->a_log_tab[poly->c[1]];\r\nl2 = bch->a_log_tab[poly->c[2]];\r\nu = a_pow(bch, l0+l2+2*(GF_N(bch)-l1));\r\nr = 0;\r\nv = u;\r\nwhile (v) {\r\ni = deg(v);\r\nr ^= bch->xi_tab[i];\r\nv ^= (1 << i);\r\n}\r\nif ((gf_sqr(bch, r)^r) == u) {\r\nroots[n++] = modulo(bch, 2*GF_N(bch)-l1-\r\nbch->a_log_tab[r]+l2);\r\nroots[n++] = modulo(bch, 2*GF_N(bch)-l1-\r\nbch->a_log_tab[r^1]+l2);\r\n}\r\n}\r\nreturn n;\r\n}\r\nstatic int find_poly_deg3_roots(struct bch_control *bch, struct gf_poly *poly,\r\nunsigned int *roots)\r\n{\r\nint i, n = 0;\r\nunsigned int a, b, c, a2, b2, c2, e3, tmp[4];\r\nif (poly->c[0]) {\r\ne3 = poly->c[3];\r\nc2 = gf_div(bch, poly->c[0], e3);\r\nb2 = gf_div(bch, poly->c[1], e3);\r\na2 = gf_div(bch, poly->c[2], e3);\r\nc = gf_mul(bch, a2, c2);\r\nb = gf_mul(bch, a2, b2)^c2;\r\na = gf_sqr(bch, a2)^b2;\r\nif (find_affine4_roots(bch, a, b, c, tmp) == 4) {\r\nfor (i = 0; i < 4; i++) {\r\nif (tmp[i] != a2)\r\nroots[n++] = a_ilog(bch, tmp[i]);\r\n}\r\n}\r\n}\r\nreturn n;\r\n}\r\nstatic int find_poly_deg4_roots(struct bch_control *bch, struct gf_poly *poly,\r\nunsigned int *roots)\r\n{\r\nint i, l, n = 0;\r\nunsigned int a, b, c, d, e = 0, f, a2, b2, c2, e4;\r\nif (poly->c[0] == 0)\r\nreturn 0;\r\ne4 = poly->c[4];\r\nd = gf_div(bch, poly->c[0], e4);\r\nc = gf_div(bch, poly->c[1], e4);\r\nb = gf_div(bch, poly->c[2], e4);\r\na = gf_div(bch, poly->c[3], e4);\r\nif (a) {\r\nif (c) {\r\nf = gf_div(bch, c, a);\r\nl = a_log(bch, f);\r\nl += (l & 1) ? GF_N(bch) : 0;\r\ne = a_pow(bch, l/2);\r\nd = a_pow(bch, 2*l)^gf_mul(bch, b, f)^d;\r\nb = gf_mul(bch, a, e)^b;\r\n}\r\nif (d == 0)\r\nreturn 0;\r\nc2 = gf_inv(bch, d);\r\nb2 = gf_div(bch, a, d);\r\na2 = gf_div(bch, b, d);\r\n} else {\r\nc2 = d;\r\nb2 = c;\r\na2 = b;\r\n}\r\nif (find_affine4_roots(bch, a2, b2, c2, roots) == 4) {\r\nfor (i = 0; i < 4; i++) {\r\nf = a ? gf_inv(bch, roots[i]) : roots[i];\r\nroots[i] = a_ilog(bch, f^e);\r\n}\r\nn = 4;\r\n}\r\nreturn n;\r\n}\r\nstatic void gf_poly_logrep(struct bch_control *bch,\r\nconst struct gf_poly *a, int *rep)\r\n{\r\nint i, d = a->deg, l = GF_N(bch)-a_log(bch, a->c[a->deg]);\r\nfor (i = 0; i < d; i++)\r\nrep[i] = a->c[i] ? mod_s(bch, a_log(bch, a->c[i])+l) : -1;\r\n}\r\nstatic void gf_poly_mod(struct bch_control *bch, struct gf_poly *a,\r\nconst struct gf_poly *b, int *rep)\r\n{\r\nint la, p, m;\r\nunsigned int i, j, *c = a->c;\r\nconst unsigned int d = b->deg;\r\nif (a->deg < d)\r\nreturn;\r\nif (!rep) {\r\nrep = bch->cache;\r\ngf_poly_logrep(bch, b, rep);\r\n}\r\nfor (j = a->deg; j >= d; j--) {\r\nif (c[j]) {\r\nla = a_log(bch, c[j]);\r\np = j-d;\r\nfor (i = 0; i < d; i++, p++) {\r\nm = rep[i];\r\nif (m >= 0)\r\nc[p] ^= bch->a_pow_tab[mod_s(bch,\r\nm+la)];\r\n}\r\n}\r\n}\r\na->deg = d-1;\r\nwhile (!c[a->deg] && a->deg)\r\na->deg--;\r\n}\r\nstatic void gf_poly_div(struct bch_control *bch, struct gf_poly *a,\r\nconst struct gf_poly *b, struct gf_poly *q)\r\n{\r\nif (a->deg >= b->deg) {\r\nq->deg = a->deg-b->deg;\r\ngf_poly_mod(bch, a, b, NULL);\r\nmemcpy(q->c, &a->c[b->deg], (1+q->deg)*sizeof(unsigned int));\r\n} else {\r\nq->deg = 0;\r\nq->c[0] = 0;\r\n}\r\n}\r\nstatic struct gf_poly *gf_poly_gcd(struct bch_control *bch, struct gf_poly *a,\r\nstruct gf_poly *b)\r\n{\r\nstruct gf_poly *tmp;\r\ndbg("gcd(%s,%s)=", gf_poly_str(a), gf_poly_str(b));\r\nif (a->deg < b->deg) {\r\ntmp = b;\r\nb = a;\r\na = tmp;\r\n}\r\nwhile (b->deg > 0) {\r\ngf_poly_mod(bch, a, b, NULL);\r\ntmp = b;\r\nb = a;\r\na = tmp;\r\n}\r\ndbg("%s\n", gf_poly_str(a));\r\nreturn a;\r\n}\r\nstatic void compute_trace_bk_mod(struct bch_control *bch, int k,\r\nconst struct gf_poly *f, struct gf_poly *z,\r\nstruct gf_poly *out)\r\n{\r\nconst int m = GF_M(bch);\r\nint i, j;\r\nz->deg = 1;\r\nz->c[0] = 0;\r\nz->c[1] = bch->a_pow_tab[k];\r\nout->deg = 0;\r\nmemset(out, 0, GF_POLY_SZ(f->deg));\r\ngf_poly_logrep(bch, f, bch->cache);\r\nfor (i = 0; i < m; i++) {\r\nfor (j = z->deg; j >= 0; j--) {\r\nout->c[j] ^= z->c[j];\r\nz->c[2*j] = gf_sqr(bch, z->c[j]);\r\nz->c[2*j+1] = 0;\r\n}\r\nif (z->deg > out->deg)\r\nout->deg = z->deg;\r\nif (i < m-1) {\r\nz->deg *= 2;\r\ngf_poly_mod(bch, z, f, bch->cache);\r\n}\r\n}\r\nwhile (!out->c[out->deg] && out->deg)\r\nout->deg--;\r\ndbg("Tr(a^%d.X) mod f = %s\n", k, gf_poly_str(out));\r\n}\r\nstatic void factor_polynomial(struct bch_control *bch, int k, struct gf_poly *f,\r\nstruct gf_poly **g, struct gf_poly **h)\r\n{\r\nstruct gf_poly *f2 = bch->poly_2t[0];\r\nstruct gf_poly *q = bch->poly_2t[1];\r\nstruct gf_poly *tk = bch->poly_2t[2];\r\nstruct gf_poly *z = bch->poly_2t[3];\r\nstruct gf_poly *gcd;\r\ndbg("factoring %s...\n", gf_poly_str(f));\r\n*g = f;\r\n*h = NULL;\r\ncompute_trace_bk_mod(bch, k, f, z, tk);\r\nif (tk->deg > 0) {\r\ngf_poly_copy(f2, f);\r\ngcd = gf_poly_gcd(bch, f2, tk);\r\nif (gcd->deg < f->deg) {\r\ngf_poly_div(bch, f, gcd, q);\r\n*h = &((struct gf_poly_deg1 *)f)[gcd->deg].poly;\r\ngf_poly_copy(*g, gcd);\r\ngf_poly_copy(*h, q);\r\n}\r\n}\r\n}\r\nstatic int find_poly_roots(struct bch_control *bch, unsigned int k,\r\nstruct gf_poly *poly, unsigned int *roots)\r\n{\r\nint cnt;\r\nstruct gf_poly *f1, *f2;\r\nswitch (poly->deg) {\r\ncase 1:\r\ncnt = find_poly_deg1_roots(bch, poly, roots);\r\nbreak;\r\ncase 2:\r\ncnt = find_poly_deg2_roots(bch, poly, roots);\r\nbreak;\r\ncase 3:\r\ncnt = find_poly_deg3_roots(bch, poly, roots);\r\nbreak;\r\ncase 4:\r\ncnt = find_poly_deg4_roots(bch, poly, roots);\r\nbreak;\r\ndefault:\r\ncnt = 0;\r\nif (poly->deg && (k <= GF_M(bch))) {\r\nfactor_polynomial(bch, k, poly, &f1, &f2);\r\nif (f1)\r\ncnt += find_poly_roots(bch, k+1, f1, roots);\r\nif (f2)\r\ncnt += find_poly_roots(bch, k+1, f2, roots+cnt);\r\n}\r\nbreak;\r\n}\r\nreturn cnt;\r\n}\r\nstatic int chien_search(struct bch_control *bch, unsigned int len,\r\nstruct gf_poly *p, unsigned int *roots)\r\n{\r\nint m;\r\nunsigned int i, j, syn, syn0, count = 0;\r\nconst unsigned int k = 8*len+bch->ecc_bits;\r\ngf_poly_logrep(bch, p, bch->cache);\r\nbch->cache[p->deg] = 0;\r\nsyn0 = gf_div(bch, p->c[0], p->c[p->deg]);\r\nfor (i = GF_N(bch)-k+1; i <= GF_N(bch); i++) {\r\nfor (j = 1, syn = syn0; j <= p->deg; j++) {\r\nm = bch->cache[j];\r\nif (m >= 0)\r\nsyn ^= a_pow(bch, m+j*i);\r\n}\r\nif (syn == 0) {\r\nroots[count++] = GF_N(bch)-i;\r\nif (count == p->deg)\r\nbreak;\r\n}\r\n}\r\nreturn (count == p->deg) ? count : 0;\r\n}\r\nint decode_bch(struct bch_control *bch, const uint8_t *data, unsigned int len,\r\nconst uint8_t *recv_ecc, const uint8_t *calc_ecc,\r\nconst unsigned int *syn, unsigned int *errloc)\r\n{\r\nconst unsigned int ecc_words = BCH_ECC_WORDS(bch);\r\nunsigned int nbits;\r\nint i, err, nroots;\r\nuint32_t sum;\r\nif (8*len > (bch->n-bch->ecc_bits))\r\nreturn -EINVAL;\r\nif (!syn) {\r\nif (!calc_ecc) {\r\nif (!data || !recv_ecc)\r\nreturn -EINVAL;\r\nencode_bch(bch, data, len, NULL);\r\n} else {\r\nload_ecc8(bch, bch->ecc_buf, calc_ecc);\r\n}\r\nif (recv_ecc) {\r\nload_ecc8(bch, bch->ecc_buf2, recv_ecc);\r\nfor (i = 0, sum = 0; i < (int)ecc_words; i++) {\r\nbch->ecc_buf[i] ^= bch->ecc_buf2[i];\r\nsum |= bch->ecc_buf[i];\r\n}\r\nif (!sum)\r\nreturn 0;\r\n}\r\ncompute_syndromes(bch, bch->ecc_buf, bch->syn);\r\nsyn = bch->syn;\r\n}\r\nerr = compute_error_locator_polynomial(bch, syn);\r\nif (err > 0) {\r\nnroots = find_poly_roots(bch, 1, bch->elp, errloc);\r\nif (err != nroots)\r\nerr = -1;\r\n}\r\nif (err > 0) {\r\nnbits = (len*8)+bch->ecc_bits;\r\nfor (i = 0; i < err; i++) {\r\nif (errloc[i] >= nbits) {\r\nerr = -1;\r\nbreak;\r\n}\r\nerrloc[i] = nbits-1-errloc[i];\r\nerrloc[i] = (errloc[i] & ~7)|(7-(errloc[i] & 7));\r\n}\r\n}\r\nreturn (err >= 0) ? err : -EBADMSG;\r\n}\r\nstatic int build_gf_tables(struct bch_control *bch, unsigned int poly)\r\n{\r\nunsigned int i, x = 1;\r\nconst unsigned int k = 1 << deg(poly);\r\nif (k != (1u << GF_M(bch)))\r\nreturn -1;\r\nfor (i = 0; i < GF_N(bch); i++) {\r\nbch->a_pow_tab[i] = x;\r\nbch->a_log_tab[x] = i;\r\nif (i && (x == 1))\r\nreturn -1;\r\nx <<= 1;\r\nif (x & k)\r\nx ^= poly;\r\n}\r\nbch->a_pow_tab[GF_N(bch)] = 1;\r\nbch->a_log_tab[0] = 0;\r\nreturn 0;\r\n}\r\nstatic void build_mod8_tables(struct bch_control *bch, const uint32_t *g)\r\n{\r\nint i, j, b, d;\r\nuint32_t data, hi, lo, *tab;\r\nconst int l = BCH_ECC_WORDS(bch);\r\nconst int plen = DIV_ROUND_UP(bch->ecc_bits+1, 32);\r\nconst int ecclen = DIV_ROUND_UP(bch->ecc_bits, 32);\r\nmemset(bch->mod8_tab, 0, 4*256*l*sizeof(*bch->mod8_tab));\r\nfor (i = 0; i < 256; i++) {\r\nfor (b = 0; b < 4; b++) {\r\ntab = bch->mod8_tab + (b*256+i)*l;\r\ndata = i << (8*b);\r\nwhile (data) {\r\nd = deg(data);\r\ndata ^= g[0] >> (31-d);\r\nfor (j = 0; j < ecclen; j++) {\r\nhi = (d < 31) ? g[j] << (d+1) : 0;\r\nlo = (j+1 < plen) ?\r\ng[j+1] >> (31-d) : 0;\r\ntab[j] ^= hi|lo;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic int build_deg2_base(struct bch_control *bch)\r\n{\r\nconst int m = GF_M(bch);\r\nint i, j, r;\r\nunsigned int sum, x, y, remaining, ak = 0, xi[m];\r\nfor (i = 0; i < m; i++) {\r\nfor (j = 0, sum = 0; j < m; j++)\r\nsum ^= a_pow(bch, i*(1 << j));\r\nif (sum) {\r\nak = bch->a_pow_tab[i];\r\nbreak;\r\n}\r\n}\r\nremaining = m;\r\nmemset(xi, 0, sizeof(xi));\r\nfor (x = 0; (x <= GF_N(bch)) && remaining; x++) {\r\ny = gf_sqr(bch, x)^x;\r\nfor (i = 0; i < 2; i++) {\r\nr = a_log(bch, y);\r\nif (y && (r < m) && !xi[r]) {\r\nbch->xi_tab[r] = x;\r\nxi[r] = 1;\r\nremaining--;\r\ndbg("x%d = %x\n", r, x);\r\nbreak;\r\n}\r\ny ^= ak;\r\n}\r\n}\r\nreturn remaining ? -1 : 0;\r\n}\r\nstatic void *bch_alloc(size_t size, int *err)\r\n{\r\nvoid *ptr;\r\nptr = kmalloc(size, GFP_KERNEL);\r\nif (ptr == NULL)\r\n*err = 1;\r\nreturn ptr;\r\n}\r\nstatic uint32_t *compute_generator_polynomial(struct bch_control *bch)\r\n{\r\nconst unsigned int m = GF_M(bch);\r\nconst unsigned int t = GF_T(bch);\r\nint n, err = 0;\r\nunsigned int i, j, nbits, r, word, *roots;\r\nstruct gf_poly *g;\r\nuint32_t *genpoly;\r\ng = bch_alloc(GF_POLY_SZ(m*t), &err);\r\nroots = bch_alloc((bch->n+1)*sizeof(*roots), &err);\r\ngenpoly = bch_alloc(DIV_ROUND_UP(m*t+1, 32)*sizeof(*genpoly), &err);\r\nif (err) {\r\nkfree(genpoly);\r\ngenpoly = NULL;\r\ngoto finish;\r\n}\r\nmemset(roots , 0, (bch->n+1)*sizeof(*roots));\r\nfor (i = 0; i < t; i++) {\r\nfor (j = 0, r = 2*i+1; j < m; j++) {\r\nroots[r] = 1;\r\nr = mod_s(bch, 2*r);\r\n}\r\n}\r\ng->deg = 0;\r\ng->c[0] = 1;\r\nfor (i = 0; i < GF_N(bch); i++) {\r\nif (roots[i]) {\r\nr = bch->a_pow_tab[i];\r\ng->c[g->deg+1] = 1;\r\nfor (j = g->deg; j > 0; j--)\r\ng->c[j] = gf_mul(bch, g->c[j], r)^g->c[j-1];\r\ng->c[0] = gf_mul(bch, g->c[0], r);\r\ng->deg++;\r\n}\r\n}\r\nn = g->deg+1;\r\ni = 0;\r\nwhile (n > 0) {\r\nnbits = (n > 32) ? 32 : n;\r\nfor (j = 0, word = 0; j < nbits; j++) {\r\nif (g->c[n-1-j])\r\nword |= 1u << (31-j);\r\n}\r\ngenpoly[i++] = word;\r\nn -= nbits;\r\n}\r\nbch->ecc_bits = g->deg;\r\nfinish:\r\nkfree(g);\r\nkfree(roots);\r\nreturn genpoly;\r\n}\r\nstruct bch_control *init_bch(int m, int t, unsigned int prim_poly)\r\n{\r\nint err = 0;\r\nunsigned int i, words;\r\nuint32_t *genpoly;\r\nstruct bch_control *bch = NULL;\r\nconst int min_m = 5;\r\nconst int max_m = 15;\r\nstatic const unsigned int prim_poly_tab[] = {\r\n0x25, 0x43, 0x83, 0x11d, 0x211, 0x409, 0x805, 0x1053, 0x201b,\r\n0x402b, 0x8003,\r\n};\r\n#if defined(CONFIG_BCH_CONST_PARAMS)\r\nif ((m != (CONFIG_BCH_CONST_M)) || (t != (CONFIG_BCH_CONST_T))) {\r\nprintk(KERN_ERR "bch encoder/decoder was configured to support "\r\n"parameters m=%d, t=%d only!\n",\r\nCONFIG_BCH_CONST_M, CONFIG_BCH_CONST_T);\r\ngoto fail;\r\n}\r\n#endif\r\nif ((m < min_m) || (m > max_m))\r\ngoto fail;\r\nif ((t < 1) || (m*t >= ((1 << m)-1)))\r\ngoto fail;\r\nif (prim_poly == 0)\r\nprim_poly = prim_poly_tab[m-min_m];\r\nbch = kzalloc(sizeof(*bch), GFP_KERNEL);\r\nif (bch == NULL)\r\ngoto fail;\r\nbch->m = m;\r\nbch->t = t;\r\nbch->n = (1 << m)-1;\r\nwords = DIV_ROUND_UP(m*t, 32);\r\nbch->ecc_bytes = DIV_ROUND_UP(m*t, 8);\r\nbch->a_pow_tab = bch_alloc((1+bch->n)*sizeof(*bch->a_pow_tab), &err);\r\nbch->a_log_tab = bch_alloc((1+bch->n)*sizeof(*bch->a_log_tab), &err);\r\nbch->mod8_tab = bch_alloc(words*1024*sizeof(*bch->mod8_tab), &err);\r\nbch->ecc_buf = bch_alloc(words*sizeof(*bch->ecc_buf), &err);\r\nbch->ecc_buf2 = bch_alloc(words*sizeof(*bch->ecc_buf2), &err);\r\nbch->xi_tab = bch_alloc(m*sizeof(*bch->xi_tab), &err);\r\nbch->syn = bch_alloc(2*t*sizeof(*bch->syn), &err);\r\nbch->cache = bch_alloc(2*t*sizeof(*bch->cache), &err);\r\nbch->elp = bch_alloc((t+1)*sizeof(struct gf_poly_deg1), &err);\r\nfor (i = 0; i < ARRAY_SIZE(bch->poly_2t); i++)\r\nbch->poly_2t[i] = bch_alloc(GF_POLY_SZ(2*t), &err);\r\nif (err)\r\ngoto fail;\r\nerr = build_gf_tables(bch, prim_poly);\r\nif (err)\r\ngoto fail;\r\ngenpoly = compute_generator_polynomial(bch);\r\nif (genpoly == NULL)\r\ngoto fail;\r\nbuild_mod8_tables(bch, genpoly);\r\nkfree(genpoly);\r\nerr = build_deg2_base(bch);\r\nif (err)\r\ngoto fail;\r\nreturn bch;\r\nfail:\r\nfree_bch(bch);\r\nreturn NULL;\r\n}\r\nvoid free_bch(struct bch_control *bch)\r\n{\r\nunsigned int i;\r\nif (bch) {\r\nkfree(bch->a_pow_tab);\r\nkfree(bch->a_log_tab);\r\nkfree(bch->mod8_tab);\r\nkfree(bch->ecc_buf);\r\nkfree(bch->ecc_buf2);\r\nkfree(bch->xi_tab);\r\nkfree(bch->syn);\r\nkfree(bch->cache);\r\nkfree(bch->elp);\r\nfor (i = 0; i < ARRAY_SIZE(bch->poly_2t); i++)\r\nkfree(bch->poly_2t[i]);\r\nkfree(bch);\r\n}\r\n}
