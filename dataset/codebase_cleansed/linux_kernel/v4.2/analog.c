static unsigned int get_time_pit(void)\r\n{\r\nunsigned long flags;\r\nunsigned int count;\r\nraw_spin_lock_irqsave(&i8253_lock, flags);\r\noutb_p(0x00, 0x43);\r\ncount = inb_p(0x40);\r\ncount |= inb_p(0x40) << 8;\r\nraw_spin_unlock_irqrestore(&i8253_lock, flags);\r\nreturn count;\r\n}\r\nstatic inline u64 get_time(void)\r\n{\r\nif (use_ktime) {\r\nreturn ktime_get_ns();\r\n} else {\r\nunsigned int x;\r\nGET_TIME(x);\r\nreturn x;\r\n}\r\n}\r\nstatic inline unsigned int delta(u64 x, u64 y)\r\n{\r\nif (use_ktime)\r\nreturn y - x;\r\nelse\r\nreturn DELTA((unsigned int)x, (unsigned int)y);\r\n}\r\nstatic void analog_decode(struct analog *analog, int *axes, int *initial, int buttons)\r\n{\r\nstruct input_dev *dev = analog->dev;\r\nint i, j;\r\nif (analog->mask & ANALOG_HAT_FCS)\r\nfor (i = 0; i < 4; i++)\r\nif (axes[3] < ((initial[3] * ((i << 1) + 1)) >> 3)) {\r\nbuttons |= 1 << (i + 14);\r\nbreak;\r\n}\r\nfor (i = j = 0; i < 6; i++)\r\nif (analog->mask & (0x10 << i))\r\ninput_report_key(dev, analog->buttons[j++], (buttons >> i) & 1);\r\nif (analog->mask & ANALOG_HBTN_CHF)\r\nfor (i = 0; i < 4; i++)\r\ninput_report_key(dev, analog->buttons[j++], (buttons >> (i + 10)) & 1);\r\nif (analog->mask & ANALOG_BTN_TL)\r\ninput_report_key(dev, analog_pads[0], axes[2] < (initial[2] >> 1));\r\nif (analog->mask & ANALOG_BTN_TR)\r\ninput_report_key(dev, analog_pads[1], axes[3] < (initial[3] >> 1));\r\nif (analog->mask & ANALOG_BTN_TL2)\r\ninput_report_key(dev, analog_pads[2], axes[2] > (initial[2] + (initial[2] >> 1)));\r\nif (analog->mask & ANALOG_BTN_TR2)\r\ninput_report_key(dev, analog_pads[3], axes[3] > (initial[3] + (initial[3] >> 1)));\r\nfor (i = j = 0; i < 4; i++)\r\nif (analog->mask & (1 << i))\r\ninput_report_abs(dev, analog_axes[j++], axes[i]);\r\nfor (i = j = 0; i < 3; i++)\r\nif (analog->mask & analog_exts[i]) {\r\ninput_report_abs(dev, analog_hats[j++],\r\n((buttons >> ((i << 2) + 7)) & 1) - ((buttons >> ((i << 2) + 9)) & 1));\r\ninput_report_abs(dev, analog_hats[j++],\r\n((buttons >> ((i << 2) + 8)) & 1) - ((buttons >> ((i << 2) + 6)) & 1));\r\n}\r\ninput_sync(dev);\r\n}\r\nstatic int analog_cooked_read(struct analog_port *port)\r\n{\r\nstruct gameport *gameport = port->gameport;\r\nu64 time[4], start, loop, now;\r\nunsigned int loopout, timeout;\r\nunsigned char data[4], this, last;\r\nunsigned long flags;\r\nint i, j;\r\nloopout = (ANALOG_LOOP_TIME * port->loop) / 1000;\r\ntimeout = ANALOG_MAX_TIME * port->speed;\r\nlocal_irq_save(flags);\r\ngameport_trigger(gameport);\r\nnow = get_time();\r\nlocal_irq_restore(flags);\r\nstart = now;\r\nthis = port->mask;\r\ni = 0;\r\ndo {\r\nloop = now;\r\nlast = this;\r\nlocal_irq_disable();\r\nthis = gameport_read(gameport) & port->mask;\r\nnow = get_time();\r\nlocal_irq_restore(flags);\r\nif ((last ^ this) && (delta(loop, now) < loopout)) {\r\ndata[i] = last ^ this;\r\ntime[i] = now;\r\ni++;\r\n}\r\n} while (this && (i < 4) && (delta(start, now) < timeout));\r\nthis <<= 4;\r\nfor (--i; i >= 0; i--) {\r\nthis |= data[i];\r\nfor (j = 0; j < 4; j++)\r\nif (data[i] & (1 << j))\r\nport->axes[j] = (delta(start, time[i]) << ANALOG_FUZZ_BITS) / port->loop;\r\n}\r\nreturn -(this != port->mask);\r\n}\r\nstatic int analog_button_read(struct analog_port *port, char saitek, char chf)\r\n{\r\nunsigned char u;\r\nint t = 1, i = 0;\r\nint strobe = gameport_time(port->gameport, ANALOG_SAITEK_TIME);\r\nu = gameport_read(port->gameport);\r\nif (!chf) {\r\nport->buttons = (~u >> 4) & 0xf;\r\nreturn 0;\r\n}\r\nport->buttons = 0;\r\nwhile ((~u & 0xf0) && (i < 16) && t) {\r\nport->buttons |= 1 << analog_chf[(~u >> 4) & 0xf];\r\nif (!saitek) return 0;\r\nudelay(ANALOG_SAITEK_DELAY);\r\nt = strobe;\r\ngameport_trigger(port->gameport);\r\nwhile (((u = gameport_read(port->gameport)) & port->mask) && t) t--;\r\ni++;\r\n}\r\nreturn -(!t || (i == 16));\r\n}\r\nstatic void analog_poll(struct gameport *gameport)\r\n{\r\nstruct analog_port *port = gameport_get_drvdata(gameport);\r\nint i;\r\nchar saitek = !!(port->analog[0].mask & ANALOG_SAITEK);\r\nchar chf = !!(port->analog[0].mask & ANALOG_ANY_CHF);\r\nif (port->cooked) {\r\nport->bads -= gameport_cooked_read(port->gameport, port->axes, &port->buttons);\r\nif (chf)\r\nport->buttons = port->buttons ? (1 << analog_chf[port->buttons]) : 0;\r\nport->reads++;\r\n} else {\r\nif (!port->axtime--) {\r\nport->bads -= analog_cooked_read(port);\r\nport->bads -= analog_button_read(port, saitek, chf);\r\nport->reads++;\r\nport->axtime = ANALOG_AXIS_TIME - 1;\r\n} else {\r\nif (!saitek)\r\nanalog_button_read(port, saitek, chf);\r\n}\r\n}\r\nfor (i = 0; i < 2; i++)\r\nif (port->analog[i].mask)\r\nanalog_decode(port->analog + i, port->axes, port->initial, port->buttons);\r\n}\r\nstatic int analog_open(struct input_dev *dev)\r\n{\r\nstruct analog_port *port = input_get_drvdata(dev);\r\ngameport_start_polling(port->gameport);\r\nreturn 0;\r\n}\r\nstatic void analog_close(struct input_dev *dev)\r\n{\r\nstruct analog_port *port = input_get_drvdata(dev);\r\ngameport_stop_polling(port->gameport);\r\n}\r\nstatic void analog_calibrate_timer(struct analog_port *port)\r\n{\r\nstruct gameport *gameport = port->gameport;\r\nunsigned int i, t, tx;\r\nu64 t1, t2, t3;\r\nunsigned long flags;\r\nif (use_ktime) {\r\nport->speed = 1000000;\r\n} else {\r\nlocal_irq_save(flags);\r\nt1 = get_time();\r\n#ifdef FAKE_TIME\r\nanalog_faketime += 830;\r\n#endif\r\nmdelay(1);\r\nt2 = get_time();\r\nt3 = get_time();\r\nlocal_irq_restore(flags);\r\nport->speed = delta(t1, t2) - delta(t2, t3);\r\n}\r\ntx = ~0;\r\nfor (i = 0; i < 50; i++) {\r\nlocal_irq_save(flags);\r\nt1 = get_time();\r\nfor (t = 0; t < 50; t++) {\r\ngameport_read(gameport);\r\nt2 = get_time();\r\n}\r\nt3 = get_time();\r\nlocal_irq_restore(flags);\r\nudelay(i);\r\nt = delta(t1, t2) - delta(t2, t3);\r\nif (t < tx) tx = t;\r\n}\r\nport->loop = tx / 50;\r\n}\r\nstatic void analog_name(struct analog *analog)\r\n{\r\nsnprintf(analog->name, sizeof(analog->name), "Analog %d-axis %d-button",\r\nhweight8(analog->mask & ANALOG_AXES_STD),\r\nhweight8(analog->mask & ANALOG_BTNS_STD) + !!(analog->mask & ANALOG_BTNS_CHF) * 2 +\r\nhweight16(analog->mask & ANALOG_BTNS_GAMEPAD) + !!(analog->mask & ANALOG_HBTN_CHF) * 4);\r\nif (analog->mask & ANALOG_HATS_ALL)\r\nsnprintf(analog->name, sizeof(analog->name), "%s %d-hat",\r\nanalog->name, hweight16(analog->mask & ANALOG_HATS_ALL));\r\nif (analog->mask & ANALOG_HAT_FCS)\r\nstrlcat(analog->name, " FCS", sizeof(analog->name));\r\nif (analog->mask & ANALOG_ANY_CHF)\r\nstrlcat(analog->name, (analog->mask & ANALOG_SAITEK) ? " Saitek" : " CHF",\r\nsizeof(analog->name));\r\nstrlcat(analog->name, (analog->mask & ANALOG_GAMEPAD) ? " gamepad": " joystick",\r\nsizeof(analog->name));\r\n}\r\nstatic int analog_init_device(struct analog_port *port, struct analog *analog, int index)\r\n{\r\nstruct input_dev *input_dev;\r\nint i, j, t, v, w, x, y, z;\r\nint error;\r\nanalog_name(analog);\r\nsnprintf(analog->phys, sizeof(analog->phys),\r\n"%s/input%d", port->gameport->phys, index);\r\nanalog->buttons = (analog->mask & ANALOG_GAMEPAD) ? analog_pad_btn : analog_joy_btn;\r\nanalog->dev = input_dev = input_allocate_device();\r\nif (!input_dev)\r\nreturn -ENOMEM;\r\ninput_dev->name = analog->name;\r\ninput_dev->phys = analog->phys;\r\ninput_dev->id.bustype = BUS_GAMEPORT;\r\ninput_dev->id.vendor = GAMEPORT_ID_VENDOR_ANALOG;\r\ninput_dev->id.product = analog->mask >> 4;\r\ninput_dev->id.version = 0x0100;\r\ninput_dev->dev.parent = &port->gameport->dev;\r\ninput_set_drvdata(input_dev, port);\r\ninput_dev->open = analog_open;\r\ninput_dev->close = analog_close;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\nfor (i = j = 0; i < 4; i++)\r\nif (analog->mask & (1 << i)) {\r\nt = analog_axes[j];\r\nx = port->axes[i];\r\ny = (port->axes[0] + port->axes[1]) >> 1;\r\nz = y - port->axes[i];\r\nz = z > 0 ? z : -z;\r\nv = (x >> 3);\r\nw = (x >> 3);\r\nif ((i == 2 || i == 3) && (j == 2 || j == 3) && (z > (y >> 3)))\r\nx = y;\r\nif (analog->mask & ANALOG_SAITEK) {\r\nif (i == 2) x = port->axes[i];\r\nv = x - (x >> 2);\r\nw = (x >> 4);\r\n}\r\ninput_set_abs_params(input_dev, t, v, (x << 1) - v, port->fuzz, w);\r\nj++;\r\n}\r\nfor (i = j = 0; i < 3; i++)\r\nif (analog->mask & analog_exts[i])\r\nfor (x = 0; x < 2; x++) {\r\nt = analog_hats[j++];\r\ninput_set_abs_params(input_dev, t, -1, 1, 0, 0);\r\n}\r\nfor (i = j = 0; i < 4; i++)\r\nif (analog->mask & (0x10 << i))\r\nset_bit(analog->buttons[j++], input_dev->keybit);\r\nif (analog->mask & ANALOG_BTNS_CHF)\r\nfor (i = 0; i < 2; i++)\r\nset_bit(analog->buttons[j++], input_dev->keybit);\r\nif (analog->mask & ANALOG_HBTN_CHF)\r\nfor (i = 0; i < 4; i++)\r\nset_bit(analog->buttons[j++], input_dev->keybit);\r\nfor (i = 0; i < 4; i++)\r\nif (analog->mask & (ANALOG_BTN_TL << i))\r\nset_bit(analog_pads[i], input_dev->keybit);\r\nanalog_decode(analog, port->axes, port->initial, port->buttons);\r\nerror = input_register_device(analog->dev);\r\nif (error) {\r\ninput_free_device(analog->dev);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int analog_init_masks(struct analog_port *port)\r\n{\r\nint i;\r\nstruct analog *analog = port->analog;\r\nint max[4];\r\nif (!port->mask)\r\nreturn -1;\r\nif ((port->mask & 3) != 3 && port->mask != 0xc) {\r\nprintk(KERN_WARNING "analog.c: Unknown joystick device found "\r\n"(data=%#x, %s), probably not analog joystick.\n",\r\nport->mask, port->gameport->phys);\r\nreturn -1;\r\n}\r\ni = analog_options[0];\r\nanalog[0].mask = i & 0xfffff;\r\nanalog[0].mask &= ~(ANALOG_AXES_STD | ANALOG_HAT_FCS | ANALOG_BTNS_GAMEPAD)\r\n| port->mask | ((port->mask << 8) & ANALOG_HAT_FCS)\r\n| ((port->mask << 10) & ANALOG_BTNS_TLR) | ((port->mask << 12) & ANALOG_BTNS_TLR2);\r\nanalog[0].mask &= ~(ANALOG_HAT2_CHF)\r\n| ((analog[0].mask & ANALOG_HBTN_CHF) ? 0 : ANALOG_HAT2_CHF);\r\nanalog[0].mask &= ~(ANALOG_THROTTLE | ANALOG_BTN_TR | ANALOG_BTN_TR2)\r\n| ((~analog[0].mask & ANALOG_HAT_FCS) >> 8)\r\n| ((~analog[0].mask & ANALOG_HAT_FCS) << 2)\r\n| ((~analog[0].mask & ANALOG_HAT_FCS) << 4);\r\nanalog[0].mask &= ~(ANALOG_THROTTLE | ANALOG_RUDDER)\r\n| (((~analog[0].mask & ANALOG_BTNS_TLR ) >> 10)\r\n& ((~analog[0].mask & ANALOG_BTNS_TLR2) >> 12));\r\nanalog[1].mask = ((i >> 20) & 0xff) | ((i >> 12) & 0xf0000);\r\nanalog[1].mask &= (analog[0].mask & ANALOG_EXTENSIONS) ? ANALOG_GAMEPAD\r\n: (((ANALOG_BTNS_STD | port->mask) & ~analog[0].mask) | ANALOG_GAMEPAD);\r\nif (port->cooked) {\r\nfor (i = 0; i < 4; i++) max[i] = port->axes[i] << 1;\r\nif ((analog[0].mask & 0x7) == 0x7) max[2] = (max[0] + max[1]) >> 1;\r\nif ((analog[0].mask & 0xb) == 0xb) max[3] = (max[0] + max[1]) >> 1;\r\nif ((analog[0].mask & ANALOG_BTN_TL) && !(analog[0].mask & ANALOG_BTN_TL2)) max[2] >>= 1;\r\nif ((analog[0].mask & ANALOG_BTN_TR) && !(analog[0].mask & ANALOG_BTN_TR2)) max[3] >>= 1;\r\nif ((analog[0].mask & ANALOG_HAT_FCS)) max[3] >>= 1;\r\ngameport_calibrate(port->gameport, port->axes, max);\r\n}\r\nfor (i = 0; i < 4; i++)\r\nport->initial[i] = port->axes[i];\r\nreturn -!(analog[0].mask || analog[1].mask);\r\n}\r\nstatic int analog_init_port(struct gameport *gameport, struct gameport_driver *drv, struct analog_port *port)\r\n{\r\nint i, t, u, v;\r\nport->gameport = gameport;\r\ngameport_set_drvdata(gameport, port);\r\nif (!gameport_open(gameport, drv, GAMEPORT_MODE_RAW)) {\r\nanalog_calibrate_timer(port);\r\ngameport_trigger(gameport);\r\nt = gameport_read(gameport);\r\nmsleep(ANALOG_MAX_TIME);\r\nport->mask = (gameport_read(gameport) ^ t) & t & 0xf;\r\nport->fuzz = (port->speed * ANALOG_FUZZ_MAGIC) / port->loop / 1000 + ANALOG_FUZZ_BITS;\r\nfor (i = 0; i < ANALOG_INIT_RETRIES; i++) {\r\nif (!analog_cooked_read(port))\r\nbreak;\r\nmsleep(ANALOG_MAX_TIME);\r\n}\r\nu = v = 0;\r\nmsleep(ANALOG_MAX_TIME);\r\nt = gameport_time(gameport, ANALOG_MAX_TIME * 1000);\r\ngameport_trigger(gameport);\r\nwhile ((gameport_read(port->gameport) & port->mask) && (u < t))\r\nu++;\r\nudelay(ANALOG_SAITEK_DELAY);\r\nt = gameport_time(gameport, ANALOG_SAITEK_TIME);\r\ngameport_trigger(gameport);\r\nwhile ((gameport_read(port->gameport) & port->mask) && (v < t))\r\nv++;\r\nif (v < (u >> 1)) {\r\nanalog_options[0] |=\r\nANALOG_SAITEK | ANALOG_BTNS_CHF | ANALOG_HBTN_CHF | ANALOG_HAT1_CHF;\r\nreturn 0;\r\n}\r\ngameport_close(gameport);\r\n}\r\nif (!gameport_open(gameport, drv, GAMEPORT_MODE_COOKED)) {\r\nfor (i = 0; i < ANALOG_INIT_RETRIES; i++)\r\nif (!gameport_cooked_read(gameport, port->axes, &port->buttons))\r\nbreak;\r\nfor (i = 0; i < 4; i++)\r\nif (port->axes[i] != -1)\r\nport->mask |= 1 << i;\r\nport->fuzz = gameport->fuzz;\r\nport->cooked = 1;\r\nreturn 0;\r\n}\r\nreturn gameport_open(gameport, drv, GAMEPORT_MODE_RAW);\r\n}\r\nstatic int analog_connect(struct gameport *gameport, struct gameport_driver *drv)\r\n{\r\nstruct analog_port *port;\r\nint i;\r\nint err;\r\nif (!(port = kzalloc(sizeof(struct analog_port), GFP_KERNEL)))\r\nreturn - ENOMEM;\r\nerr = analog_init_port(gameport, drv, port);\r\nif (err)\r\ngoto fail1;\r\nerr = analog_init_masks(port);\r\nif (err)\r\ngoto fail2;\r\ngameport_set_poll_handler(gameport, analog_poll);\r\ngameport_set_poll_interval(gameport, 10);\r\nfor (i = 0; i < 2; i++)\r\nif (port->analog[i].mask) {\r\nerr = analog_init_device(port, port->analog + i, i);\r\nif (err)\r\ngoto fail3;\r\n}\r\nreturn 0;\r\nfail3: while (--i >= 0)\r\nif (port->analog[i].mask)\r\ninput_unregister_device(port->analog[i].dev);\r\nfail2: gameport_close(gameport);\r\nfail1: gameport_set_drvdata(gameport, NULL);\r\nkfree(port);\r\nreturn err;\r\n}\r\nstatic void analog_disconnect(struct gameport *gameport)\r\n{\r\nstruct analog_port *port = gameport_get_drvdata(gameport);\r\nint i;\r\nfor (i = 0; i < 2; i++)\r\nif (port->analog[i].mask)\r\ninput_unregister_device(port->analog[i].dev);\r\ngameport_close(gameport);\r\ngameport_set_drvdata(gameport, NULL);\r\nprintk(KERN_INFO "analog.c: %d out of %d reads (%d%%) on %s failed\n",\r\nport->bads, port->reads, port->reads ? (port->bads * 100 / port->reads) : 0,\r\nport->gameport->phys);\r\nkfree(port);\r\n}\r\nstatic void analog_parse_options(void)\r\n{\r\nint i, j;\r\nchar *end;\r\nfor (i = 0; i < js_nargs; i++) {\r\nfor (j = 0; analog_types[j].name; j++)\r\nif (!strcmp(analog_types[j].name, js[i])) {\r\nanalog_options[i] = analog_types[j].value;\r\nbreak;\r\n}\r\nif (analog_types[j].name) continue;\r\nanalog_options[i] = simple_strtoul(js[i], &end, 0);\r\nif (end != js[i]) continue;\r\nanalog_options[i] = 0xff;\r\nif (!strlen(js[i])) continue;\r\nprintk(KERN_WARNING "analog.c: Bad config for port %d - \"%s\"\n", i, js[i]);\r\n}\r\nfor (; i < ANALOG_PORTS; i++)\r\nanalog_options[i] = 0xff;\r\n}\r\nstatic int __init analog_init(void)\r\n{\r\nanalog_parse_options();\r\nreturn gameport_register_driver(&analog_drv);\r\n}\r\nstatic void __exit analog_exit(void)\r\n{\r\ngameport_unregister_driver(&analog_drv);\r\n}
