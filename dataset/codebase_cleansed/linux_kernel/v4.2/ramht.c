static u32\r\nnvkm_ramht_hash(struct nvkm_ramht *ramht, int chid, u32 handle)\r\n{\r\nu32 hash = 0;\r\nwhile (handle) {\r\nhash ^= (handle & ((1 << ramht->bits) - 1));\r\nhandle >>= ramht->bits;\r\n}\r\nhash ^= chid << (ramht->bits - 4);\r\nhash = hash << 3;\r\nreturn hash;\r\n}\r\nint\r\nnvkm_ramht_insert(struct nvkm_ramht *ramht, int chid, u32 handle, u32 context)\r\n{\r\nstruct nvkm_bar *bar = nvkm_bar(ramht);\r\nu32 co, ho;\r\nco = ho = nvkm_ramht_hash(ramht, chid, handle);\r\ndo {\r\nif (!nv_ro32(ramht, co + 4)) {\r\nnv_wo32(ramht, co + 0, handle);\r\nnv_wo32(ramht, co + 4, context);\r\nif (bar)\r\nbar->flush(bar);\r\nreturn co;\r\n}\r\nco += 8;\r\nif (co >= nv_gpuobj(ramht)->size)\r\nco = 0;\r\n} while (co != ho);\r\nreturn -ENOMEM;\r\n}\r\nvoid\r\nnvkm_ramht_remove(struct nvkm_ramht *ramht, int cookie)\r\n{\r\nstruct nvkm_bar *bar = nvkm_bar(ramht);\r\nnv_wo32(ramht, cookie + 0, 0x00000000);\r\nnv_wo32(ramht, cookie + 4, 0x00000000);\r\nif (bar)\r\nbar->flush(bar);\r\n}\r\nint\r\nnvkm_ramht_new(struct nvkm_object *parent, struct nvkm_object *pargpu,\r\nu32 size, u32 align, struct nvkm_ramht **pramht)\r\n{\r\nstruct nvkm_ramht *ramht;\r\nint ret;\r\nret = nvkm_gpuobj_create(parent, parent->engine ?\r\n&parent->engine->subdev.object : parent,\r\n&nvkm_ramht_oclass, 0, pargpu, size,\r\nalign, NVOBJ_FLAG_ZERO_ALLOC, &ramht);\r\n*pramht = ramht;\r\nif (ret)\r\nreturn ret;\r\nramht->bits = order_base_2(nv_gpuobj(ramht)->size >> 3);\r\nreturn 0;\r\n}
