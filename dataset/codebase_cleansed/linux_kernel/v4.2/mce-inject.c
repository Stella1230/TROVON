static void inject_mce(struct mce *m)\r\n{\r\nstruct mce *i = &per_cpu(injectm, m->extcpu);\r\ni->finished = 0;\r\nmb();\r\nm->finished = 0;\r\ni->extcpu = m->extcpu;\r\nmb();\r\nmemcpy(i, m, sizeof(struct mce));\r\nmb();\r\ni->finished = 1;\r\n}\r\nstatic void raise_poll(struct mce *m)\r\n{\r\nunsigned long flags;\r\nmce_banks_t b;\r\nmemset(&b, 0xff, sizeof(mce_banks_t));\r\nlocal_irq_save(flags);\r\nmachine_check_poll(0, &b);\r\nlocal_irq_restore(flags);\r\nm->finished = 0;\r\n}\r\nstatic void raise_exception(struct mce *m, struct pt_regs *pregs)\r\n{\r\nstruct pt_regs regs;\r\nunsigned long flags;\r\nif (!pregs) {\r\nmemset(&regs, 0, sizeof(struct pt_regs));\r\nregs.ip = m->ip;\r\nregs.cs = m->cs;\r\npregs = &regs;\r\n}\r\nlocal_irq_save(flags);\r\ndo_machine_check(pregs, 0);\r\nlocal_irq_restore(flags);\r\nm->finished = 0;\r\n}\r\nstatic int mce_raise_notify(unsigned int cmd, struct pt_regs *regs)\r\n{\r\nint cpu = smp_processor_id();\r\nstruct mce *m = this_cpu_ptr(&injectm);\r\nif (!cpumask_test_cpu(cpu, mce_inject_cpumask))\r\nreturn NMI_DONE;\r\ncpumask_clear_cpu(cpu, mce_inject_cpumask);\r\nif (m->inject_flags & MCJ_EXCEPTION)\r\nraise_exception(m, regs);\r\nelse if (m->status)\r\nraise_poll(m);\r\nreturn NMI_HANDLED;\r\n}\r\nstatic void mce_irq_ipi(void *info)\r\n{\r\nint cpu = smp_processor_id();\r\nstruct mce *m = this_cpu_ptr(&injectm);\r\nif (cpumask_test_cpu(cpu, mce_inject_cpumask) &&\r\nm->inject_flags & MCJ_EXCEPTION) {\r\ncpumask_clear_cpu(cpu, mce_inject_cpumask);\r\nraise_exception(m, NULL);\r\n}\r\n}\r\nstatic int raise_local(void)\r\n{\r\nstruct mce *m = this_cpu_ptr(&injectm);\r\nint context = MCJ_CTX(m->inject_flags);\r\nint ret = 0;\r\nint cpu = m->extcpu;\r\nif (m->inject_flags & MCJ_EXCEPTION) {\r\nprintk(KERN_INFO "Triggering MCE exception on CPU %d\n", cpu);\r\nswitch (context) {\r\ncase MCJ_CTX_IRQ:\r\ncase MCJ_CTX_PROCESS:\r\nraise_exception(m, NULL);\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "Invalid MCE context\n");\r\nret = -EINVAL;\r\n}\r\nprintk(KERN_INFO "MCE exception done on CPU %d\n", cpu);\r\n} else if (m->status) {\r\nprintk(KERN_INFO "Starting machine check poll CPU %d\n", cpu);\r\nraise_poll(m);\r\nmce_notify_irq();\r\nprintk(KERN_INFO "Machine check poll done on CPU %d\n", cpu);\r\n} else\r\nm->finished = 0;\r\nreturn ret;\r\n}\r\nstatic void raise_mce(struct mce *m)\r\n{\r\nint context = MCJ_CTX(m->inject_flags);\r\ninject_mce(m);\r\nif (context == MCJ_CTX_RANDOM)\r\nreturn;\r\n#ifdef CONFIG_X86_LOCAL_APIC\r\nif (m->inject_flags & (MCJ_IRQ_BROADCAST | MCJ_NMI_BROADCAST)) {\r\nunsigned long start;\r\nint cpu;\r\nget_online_cpus();\r\ncpumask_copy(mce_inject_cpumask, cpu_online_mask);\r\ncpumask_clear_cpu(get_cpu(), mce_inject_cpumask);\r\nfor_each_online_cpu(cpu) {\r\nstruct mce *mcpu = &per_cpu(injectm, cpu);\r\nif (!mcpu->finished ||\r\nMCJ_CTX(mcpu->inject_flags) != MCJ_CTX_RANDOM)\r\ncpumask_clear_cpu(cpu, mce_inject_cpumask);\r\n}\r\nif (!cpumask_empty(mce_inject_cpumask)) {\r\nif (m->inject_flags & MCJ_IRQ_BROADCAST) {\r\npreempt_disable();\r\nsmp_call_function_many(mce_inject_cpumask,\r\nmce_irq_ipi, NULL, 0);\r\npreempt_enable();\r\n} else if (m->inject_flags & MCJ_NMI_BROADCAST)\r\napic->send_IPI_mask(mce_inject_cpumask,\r\nNMI_VECTOR);\r\n}\r\nstart = jiffies;\r\nwhile (!cpumask_empty(mce_inject_cpumask)) {\r\nif (!time_before(jiffies, start + 2*HZ)) {\r\nprintk(KERN_ERR\r\n"Timeout waiting for mce inject %lx\n",\r\n*cpumask_bits(mce_inject_cpumask));\r\nbreak;\r\n}\r\ncpu_relax();\r\n}\r\nraise_local();\r\nput_cpu();\r\nput_online_cpus();\r\n} else\r\n#endif\r\n{\r\npreempt_disable();\r\nraise_local();\r\npreempt_enable();\r\n}\r\n}\r\nstatic ssize_t mce_write(struct file *filp, const char __user *ubuf,\r\nsize_t usize, loff_t *off)\r\n{\r\nstruct mce m;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (!boot_cpu_has(X86_FEATURE_MCE) || !boot_cpu_has(X86_FEATURE_MCA))\r\nreturn -EIO;\r\nif ((unsigned long)usize > sizeof(struct mce))\r\nusize = sizeof(struct mce);\r\nif (copy_from_user(&m, ubuf, usize))\r\nreturn -EFAULT;\r\nif (m.extcpu >= num_possible_cpus() || !cpu_online(m.extcpu))\r\nreturn -EINVAL;\r\nschedule_timeout(2);\r\nmutex_lock(&mce_inject_mutex);\r\nraise_mce(&m);\r\nmutex_unlock(&mce_inject_mutex);\r\nreturn usize;\r\n}\r\nstatic int inject_init(void)\r\n{\r\nif (!alloc_cpumask_var(&mce_inject_cpumask, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nprintk(KERN_INFO "Machine check injector initialized\n");\r\nregister_mce_write_callback(mce_write);\r\nregister_nmi_handler(NMI_LOCAL, mce_raise_notify, 0,\r\n"mce_notify");\r\nreturn 0;\r\n}
