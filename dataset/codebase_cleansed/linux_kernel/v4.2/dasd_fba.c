static int\r\ndasd_fba_probe(struct ccw_device *cdev)\r\n{\r\nreturn dasd_generic_probe(cdev, &dasd_fba_discipline);\r\n}\r\nstatic int\r\ndasd_fba_set_online(struct ccw_device *cdev)\r\n{\r\nreturn dasd_generic_set_online(cdev, &dasd_fba_discipline);\r\n}\r\nstatic void\r\ndefine_extent(struct ccw1 * ccw, struct DE_fba_data *data, int rw,\r\nint blksize, int beg, int nr)\r\n{\r\nccw->cmd_code = DASD_FBA_CCW_DEFINE_EXTENT;\r\nccw->flags = 0;\r\nccw->count = 16;\r\nccw->cda = (__u32) __pa(data);\r\nmemset(data, 0, sizeof (struct DE_fba_data));\r\nif (rw == WRITE)\r\n(data->mask).perm = 0x0;\r\nelse if (rw == READ)\r\n(data->mask).perm = 0x1;\r\nelse\r\ndata->mask.perm = 0x2;\r\ndata->blk_size = blksize;\r\ndata->ext_loc = beg;\r\ndata->ext_end = nr - 1;\r\n}\r\nstatic void\r\nlocate_record(struct ccw1 * ccw, struct LO_fba_data *data, int rw,\r\nint block_nr, int block_ct)\r\n{\r\nccw->cmd_code = DASD_FBA_CCW_LOCATE;\r\nccw->flags = 0;\r\nccw->count = 8;\r\nccw->cda = (__u32) __pa(data);\r\nmemset(data, 0, sizeof (struct LO_fba_data));\r\nif (rw == WRITE)\r\ndata->operation.cmd = 0x5;\r\nelse if (rw == READ)\r\ndata->operation.cmd = 0x6;\r\nelse\r\ndata->operation.cmd = 0x8;\r\ndata->blk_nr = block_nr;\r\ndata->blk_ct = block_ct;\r\n}\r\nstatic int\r\ndasd_fba_check_characteristics(struct dasd_device *device)\r\n{\r\nstruct dasd_block *block;\r\nstruct dasd_fba_private *private;\r\nstruct ccw_device *cdev = device->cdev;\r\nint rc;\r\nint readonly;\r\nprivate = (struct dasd_fba_private *) device->private;\r\nif (!private) {\r\nprivate = kzalloc(sizeof(*private), GFP_KERNEL | GFP_DMA);\r\nif (!private) {\r\ndev_warn(&device->cdev->dev,\r\n"Allocating memory for private DASD "\r\n"data failed\n");\r\nreturn -ENOMEM;\r\n}\r\ndevice->private = (void *) private;\r\n} else {\r\nmemset(private, 0, sizeof(*private));\r\n}\r\nblock = dasd_alloc_block();\r\nif (IS_ERR(block)) {\r\nDBF_EVENT_DEVID(DBF_WARNING, cdev, "%s", "could not allocate "\r\n"dasd block structure");\r\ndevice->private = NULL;\r\nkfree(private);\r\nreturn PTR_ERR(block);\r\n}\r\ndevice->block = block;\r\nblock->base = device;\r\nrc = dasd_generic_read_dev_chars(device, DASD_FBA_MAGIC,\r\n&private->rdc_data, 32);\r\nif (rc) {\r\nDBF_EVENT_DEVID(DBF_WARNING, cdev, "Read device "\r\n"characteristics returned error %d", rc);\r\ndevice->block = NULL;\r\ndasd_free_block(block);\r\ndevice->private = NULL;\r\nkfree(private);\r\nreturn rc;\r\n}\r\ndevice->default_expires = DASD_EXPIRES;\r\ndevice->default_retries = FBA_DEFAULT_RETRIES;\r\ndevice->path_data.opm = LPM_ANYPATH;\r\nreadonly = dasd_device_is_ro(device);\r\nif (readonly)\r\nset_bit(DASD_FLAG_DEVICE_RO, &device->flags);\r\ndev_info(&device->cdev->dev,\r\n"New FBA DASD %04X/%02X (CU %04X/%02X) with %d MB "\r\n"and %d B/blk%s\n",\r\ncdev->id.dev_type,\r\ncdev->id.dev_model,\r\ncdev->id.cu_type,\r\ncdev->id.cu_model,\r\n((private->rdc_data.blk_bdsa *\r\n(private->rdc_data.blk_size >> 9)) >> 11),\r\nprivate->rdc_data.blk_size,\r\nreadonly ? ", read-only device" : "");\r\nreturn 0;\r\n}\r\nstatic int dasd_fba_do_analysis(struct dasd_block *block)\r\n{\r\nstruct dasd_fba_private *private;\r\nint sb, rc;\r\nprivate = (struct dasd_fba_private *) block->base->private;\r\nrc = dasd_check_blocksize(private->rdc_data.blk_size);\r\nif (rc) {\r\nDBF_DEV_EVENT(DBF_WARNING, block->base, "unknown blocksize %d",\r\nprivate->rdc_data.blk_size);\r\nreturn rc;\r\n}\r\nblock->blocks = private->rdc_data.blk_bdsa;\r\nblock->bp_block = private->rdc_data.blk_size;\r\nblock->s2b_shift = 0;\r\nfor (sb = 512; sb < private->rdc_data.blk_size; sb = sb << 1)\r\nblock->s2b_shift++;\r\nreturn 0;\r\n}\r\nstatic int dasd_fba_fill_geometry(struct dasd_block *block,\r\nstruct hd_geometry *geo)\r\n{\r\nif (dasd_check_blocksize(block->bp_block) != 0)\r\nreturn -EINVAL;\r\ngeo->cylinders = (block->blocks << block->s2b_shift) >> 10;\r\ngeo->heads = 16;\r\ngeo->sectors = 128 >> block->s2b_shift;\r\nreturn 0;\r\n}\r\nstatic dasd_erp_fn_t\r\ndasd_fba_erp_action(struct dasd_ccw_req * cqr)\r\n{\r\nreturn dasd_default_erp_action;\r\n}\r\nstatic dasd_erp_fn_t\r\ndasd_fba_erp_postaction(struct dasd_ccw_req * cqr)\r\n{\r\nif (cqr->function == dasd_default_erp_action)\r\nreturn dasd_default_erp_postaction;\r\nDBF_DEV_EVENT(DBF_WARNING, cqr->startdev, "unknown ERP action %p",\r\ncqr->function);\r\nreturn NULL;\r\n}\r\nstatic void dasd_fba_check_for_device_change(struct dasd_device *device,\r\nstruct dasd_ccw_req *cqr,\r\nstruct irb *irb)\r\n{\r\nchar mask;\r\nmask = DEV_STAT_ATTENTION | DEV_STAT_DEV_END | DEV_STAT_UNIT_EXCEP;\r\nif ((irb->scsw.cmd.dstat & mask) == mask)\r\ndasd_generic_handle_state_change(device);\r\n}\r\nstatic struct dasd_ccw_req *dasd_fba_build_cp(struct dasd_device * memdev,\r\nstruct dasd_block *block,\r\nstruct request *req)\r\n{\r\nstruct dasd_fba_private *private;\r\nunsigned long *idaws;\r\nstruct LO_fba_data *LO_data;\r\nstruct dasd_ccw_req *cqr;\r\nstruct ccw1 *ccw;\r\nstruct req_iterator iter;\r\nstruct bio_vec bv;\r\nchar *dst;\r\nint count, cidaw, cplength, datasize;\r\nsector_t recid, first_rec, last_rec;\r\nunsigned int blksize, off;\r\nunsigned char cmd;\r\nprivate = (struct dasd_fba_private *) block->base->private;\r\nif (rq_data_dir(req) == READ) {\r\ncmd = DASD_FBA_CCW_READ;\r\n} else if (rq_data_dir(req) == WRITE) {\r\ncmd = DASD_FBA_CCW_WRITE;\r\n} else\r\nreturn ERR_PTR(-EINVAL);\r\nblksize = block->bp_block;\r\nfirst_rec = blk_rq_pos(req) >> block->s2b_shift;\r\nlast_rec =\r\n(blk_rq_pos(req) + blk_rq_sectors(req) - 1) >> block->s2b_shift;\r\ncount = 0;\r\ncidaw = 0;\r\nrq_for_each_segment(bv, req, iter) {\r\nif (bv.bv_len & (blksize - 1))\r\nreturn ERR_PTR(-EINVAL);\r\ncount += bv.bv_len >> (block->s2b_shift + 9);\r\nif (idal_is_needed (page_address(bv.bv_page), bv.bv_len))\r\ncidaw += bv.bv_len / blksize;\r\n}\r\nif (count != last_rec - first_rec + 1)\r\nreturn ERR_PTR(-EINVAL);\r\ncplength = 2 + count;\r\ndatasize = sizeof(struct DE_fba_data) + sizeof(struct LO_fba_data) +\r\ncidaw * sizeof(unsigned long);\r\nif (private->rdc_data.mode.bits.data_chain == 0) {\r\ncplength += count - 1;\r\ndatasize += (count - 1)*sizeof(struct LO_fba_data);\r\n}\r\ncqr = dasd_smalloc_request(DASD_FBA_MAGIC, cplength, datasize, memdev);\r\nif (IS_ERR(cqr))\r\nreturn cqr;\r\nccw = cqr->cpaddr;\r\ndefine_extent(ccw++, cqr->data, rq_data_dir(req),\r\nblock->bp_block, blk_rq_pos(req), blk_rq_sectors(req));\r\nidaws = (unsigned long *) (cqr->data + sizeof(struct DE_fba_data));\r\nLO_data = (struct LO_fba_data *) (idaws + cidaw);\r\nif (private->rdc_data.mode.bits.data_chain != 0) {\r\nccw[-1].flags |= CCW_FLAG_CC;\r\nlocate_record(ccw++, LO_data++, rq_data_dir(req), 0, count);\r\n}\r\nrecid = first_rec;\r\nrq_for_each_segment(bv, req, iter) {\r\ndst = page_address(bv.bv_page) + bv.bv_offset;\r\nif (dasd_page_cache) {\r\nchar *copy = kmem_cache_alloc(dasd_page_cache,\r\nGFP_DMA | __GFP_NOWARN);\r\nif (copy && rq_data_dir(req) == WRITE)\r\nmemcpy(copy + bv.bv_offset, dst, bv.bv_len);\r\nif (copy)\r\ndst = copy + bv.bv_offset;\r\n}\r\nfor (off = 0; off < bv.bv_len; off += blksize) {\r\nif (private->rdc_data.mode.bits.data_chain == 0) {\r\nccw[-1].flags |= CCW_FLAG_CC;\r\nlocate_record(ccw, LO_data++,\r\nrq_data_dir(req),\r\nrecid - first_rec, 1);\r\nccw->flags = CCW_FLAG_CC;\r\nccw++;\r\n} else {\r\nif (recid > first_rec)\r\nccw[-1].flags |= CCW_FLAG_DC;\r\nelse\r\nccw[-1].flags |= CCW_FLAG_CC;\r\n}\r\nccw->cmd_code = cmd;\r\nccw->count = block->bp_block;\r\nif (idal_is_needed(dst, blksize)) {\r\nccw->cda = (__u32)(addr_t) idaws;\r\nccw->flags = CCW_FLAG_IDA;\r\nidaws = idal_create_words(idaws, dst, blksize);\r\n} else {\r\nccw->cda = (__u32)(addr_t) dst;\r\nccw->flags = 0;\r\n}\r\nccw++;\r\ndst += blksize;\r\nrecid++;\r\n}\r\n}\r\nif (blk_noretry_request(req) ||\r\nblock->base->features & DASD_FEATURE_FAILFAST)\r\nset_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags);\r\ncqr->startdev = memdev;\r\ncqr->memdev = memdev;\r\ncqr->block = block;\r\ncqr->expires = memdev->default_expires * HZ;\r\ncqr->retries = memdev->default_retries;\r\ncqr->buildclk = get_tod_clock();\r\ncqr->status = DASD_CQR_FILLED;\r\nreturn cqr;\r\n}\r\nstatic int\r\ndasd_fba_free_cp(struct dasd_ccw_req *cqr, struct request *req)\r\n{\r\nstruct dasd_fba_private *private;\r\nstruct ccw1 *ccw;\r\nstruct req_iterator iter;\r\nstruct bio_vec bv;\r\nchar *dst, *cda;\r\nunsigned int blksize, off;\r\nint status;\r\nif (!dasd_page_cache)\r\ngoto out;\r\nprivate = (struct dasd_fba_private *) cqr->block->base->private;\r\nblksize = cqr->block->bp_block;\r\nccw = cqr->cpaddr;\r\nccw++;\r\nif (private->rdc_data.mode.bits.data_chain != 0)\r\nccw++;\r\nrq_for_each_segment(bv, req, iter) {\r\ndst = page_address(bv.bv_page) + bv.bv_offset;\r\nfor (off = 0; off < bv.bv_len; off += blksize) {\r\nif (private->rdc_data.mode.bits.data_chain == 0)\r\nccw++;\r\nif (dst) {\r\nif (ccw->flags & CCW_FLAG_IDA)\r\ncda = *((char **)((addr_t) ccw->cda));\r\nelse\r\ncda = (char *)((addr_t) ccw->cda);\r\nif (dst != cda) {\r\nif (rq_data_dir(req) == READ)\r\nmemcpy(dst, cda, bv.bv_len);\r\nkmem_cache_free(dasd_page_cache,\r\n(void *)((addr_t)cda & PAGE_MASK));\r\n}\r\ndst = NULL;\r\n}\r\nccw++;\r\n}\r\n}\r\nout:\r\nstatus = cqr->status == DASD_CQR_DONE;\r\ndasd_sfree_request(cqr, cqr->memdev);\r\nreturn status;\r\n}\r\nstatic void dasd_fba_handle_terminated_request(struct dasd_ccw_req *cqr)\r\n{\r\nif (cqr->retries < 0)\r\ncqr->status = DASD_CQR_FAILED;\r\nelse\r\ncqr->status = DASD_CQR_FILLED;\r\n}\r\nstatic int\r\ndasd_fba_fill_info(struct dasd_device * device,\r\nstruct dasd_information2_t * info)\r\n{\r\ninfo->label_block = 1;\r\ninfo->FBA_layout = 1;\r\ninfo->format = DASD_FORMAT_LDL;\r\ninfo->characteristics_size = sizeof(struct dasd_fba_characteristics);\r\nmemcpy(info->characteristics,\r\n&((struct dasd_fba_private *) device->private)->rdc_data,\r\nsizeof (struct dasd_fba_characteristics));\r\ninfo->confdata_size = 0;\r\nreturn 0;\r\n}\r\nstatic void\r\ndasd_fba_dump_sense_dbf(struct dasd_device *device, struct irb *irb,\r\nchar *reason)\r\n{\r\nu64 *sense;\r\nsense = (u64 *) dasd_get_sense(irb);\r\nif (sense) {\r\nDBF_DEV_EVENT(DBF_EMERG, device,\r\n"%s: %s %02x%02x%02x %016llx %016llx %016llx "\r\n"%016llx", reason,\r\nscsw_is_tm(&irb->scsw) ? "t" : "c",\r\nscsw_cc(&irb->scsw), scsw_cstat(&irb->scsw),\r\nscsw_dstat(&irb->scsw), sense[0], sense[1],\r\nsense[2], sense[3]);\r\n} else {\r\nDBF_DEV_EVENT(DBF_EMERG, device, "%s",\r\n"SORRY - NO VALID SENSE AVAILABLE\n");\r\n}\r\n}\r\nstatic void\r\ndasd_fba_dump_sense(struct dasd_device *device, struct dasd_ccw_req * req,\r\nstruct irb *irb)\r\n{\r\nchar *page;\r\nstruct ccw1 *act, *end, *last;\r\nint len, sl, sct, count;\r\npage = (char *) get_zeroed_page(GFP_ATOMIC);\r\nif (page == NULL) {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"No memory to dump sense data");\r\nreturn;\r\n}\r\nlen = sprintf(page, PRINTK_HEADER\r\n" I/O status report for device %s:\n",\r\ndev_name(&device->cdev->dev));\r\nlen += sprintf(page + len, PRINTK_HEADER\r\n" in req: %p CS: 0x%02X DS: 0x%02X\n", req,\r\nirb->scsw.cmd.cstat, irb->scsw.cmd.dstat);\r\nlen += sprintf(page + len, PRINTK_HEADER\r\n" device %s: Failing CCW: %p\n",\r\ndev_name(&device->cdev->dev),\r\n(void *) (addr_t) irb->scsw.cmd.cpa);\r\nif (irb->esw.esw0.erw.cons) {\r\nfor (sl = 0; sl < 4; sl++) {\r\nlen += sprintf(page + len, PRINTK_HEADER\r\n" Sense(hex) %2d-%2d:",\r\n(8 * sl), ((8 * sl) + 7));\r\nfor (sct = 0; sct < 8; sct++) {\r\nlen += sprintf(page + len, " %02x",\r\nirb->ecw[8 * sl + sct]);\r\n}\r\nlen += sprintf(page + len, "\n");\r\n}\r\n} else {\r\nlen += sprintf(page + len, PRINTK_HEADER\r\n" SORRY - NO VALID SENSE AVAILABLE\n");\r\n}\r\nprintk(KERN_ERR "%s", page);\r\nact = req->cpaddr;\r\nfor (last = act; last->flags & (CCW_FLAG_CC | CCW_FLAG_DC); last++);\r\nend = min(act + 8, last);\r\nlen = sprintf(page, PRINTK_HEADER " Related CP in req: %p\n", req);\r\nwhile (act <= end) {\r\nlen += sprintf(page + len, PRINTK_HEADER\r\n" CCW %p: %08X %08X DAT:",\r\nact, ((int *) act)[0], ((int *) act)[1]);\r\nfor (count = 0; count < 32 && count < act->count;\r\ncount += sizeof(int))\r\nlen += sprintf(page + len, " %08X",\r\n((int *) (addr_t) act->cda)\r\n[(count>>2)]);\r\nlen += sprintf(page + len, "\n");\r\nact++;\r\n}\r\nprintk(KERN_ERR "%s", page);\r\nlen = 0;\r\nif (act < ((struct ccw1 *)(addr_t) irb->scsw.cmd.cpa) - 2) {\r\nact = ((struct ccw1 *)(addr_t) irb->scsw.cmd.cpa) - 2;\r\nlen += sprintf(page + len, PRINTK_HEADER "......\n");\r\n}\r\nend = min((struct ccw1 *)(addr_t) irb->scsw.cmd.cpa + 2, last);\r\nwhile (act <= end) {\r\nlen += sprintf(page + len, PRINTK_HEADER\r\n" CCW %p: %08X %08X DAT:",\r\nact, ((int *) act)[0], ((int *) act)[1]);\r\nfor (count = 0; count < 32 && count < act->count;\r\ncount += sizeof(int))\r\nlen += sprintf(page + len, " %08X",\r\n((int *) (addr_t) act->cda)\r\n[(count>>2)]);\r\nlen += sprintf(page + len, "\n");\r\nact++;\r\n}\r\nif (act < last - 2) {\r\nact = last - 2;\r\nlen += sprintf(page + len, PRINTK_HEADER "......\n");\r\n}\r\nwhile (act <= last) {\r\nlen += sprintf(page + len, PRINTK_HEADER\r\n" CCW %p: %08X %08X DAT:",\r\nact, ((int *) act)[0], ((int *) act)[1]);\r\nfor (count = 0; count < 32 && count < act->count;\r\ncount += sizeof(int))\r\nlen += sprintf(page + len, " %08X",\r\n((int *) (addr_t) act->cda)\r\n[(count>>2)]);\r\nlen += sprintf(page + len, "\n");\r\nact++;\r\n}\r\nif (len > 0)\r\nprintk(KERN_ERR "%s", page);\r\nfree_page((unsigned long) page);\r\n}\r\nstatic int __init\r\ndasd_fba_init(void)\r\n{\r\nint ret;\r\nASCEBC(dasd_fba_discipline.ebcname, 4);\r\nret = ccw_driver_register(&dasd_fba_driver);\r\nif (!ret)\r\nwait_for_device_probe();\r\nreturn ret;\r\n}\r\nstatic void __exit\r\ndasd_fba_cleanup(void)\r\n{\r\nccw_driver_unregister(&dasd_fba_driver);\r\n}
