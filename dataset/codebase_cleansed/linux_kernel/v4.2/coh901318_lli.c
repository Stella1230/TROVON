static struct coh901318_lli *\r\ncoh901318_lli_next(struct coh901318_lli *data)\r\n{\r\nif (data == NULL || data->link_addr == 0)\r\nreturn NULL;\r\nreturn (struct coh901318_lli *) data->virt_link_addr;\r\n}\r\nint coh901318_pool_create(struct coh901318_pool *pool,\r\nstruct device *dev,\r\nsize_t size, size_t align)\r\n{\r\nspin_lock_init(&pool->lock);\r\npool->dev = dev;\r\npool->dmapool = dma_pool_create("lli_pool", dev, size, align, 0);\r\nDEBUGFS_POOL_COUNTER_RESET(pool);\r\nreturn 0;\r\n}\r\nint coh901318_pool_destroy(struct coh901318_pool *pool)\r\n{\r\ndma_pool_destroy(pool->dmapool);\r\nreturn 0;\r\n}\r\nstruct coh901318_lli *\r\ncoh901318_lli_alloc(struct coh901318_pool *pool, unsigned int len)\r\n{\r\nint i;\r\nstruct coh901318_lli *head;\r\nstruct coh901318_lli *lli;\r\nstruct coh901318_lli *lli_prev;\r\ndma_addr_t phy;\r\nif (len == 0)\r\nreturn NULL;\r\nspin_lock(&pool->lock);\r\nhead = dma_pool_alloc(pool->dmapool, GFP_NOWAIT, &phy);\r\nif (head == NULL)\r\ngoto err;\r\nDEBUGFS_POOL_COUNTER_ADD(pool, 1);\r\nlli = head;\r\nlli->phy_this = phy;\r\nlli->link_addr = 0x00000000;\r\nlli->virt_link_addr = 0x00000000U;\r\nfor (i = 1; i < len; i++) {\r\nlli_prev = lli;\r\nlli = dma_pool_alloc(pool->dmapool, GFP_NOWAIT, &phy);\r\nif (lli == NULL)\r\ngoto err_clean_up;\r\nDEBUGFS_POOL_COUNTER_ADD(pool, 1);\r\nlli->phy_this = phy;\r\nlli->link_addr = 0x00000000;\r\nlli->virt_link_addr = 0x00000000U;\r\nlli_prev->link_addr = phy;\r\nlli_prev->virt_link_addr = lli;\r\n}\r\nspin_unlock(&pool->lock);\r\nreturn head;\r\nerr:\r\nspin_unlock(&pool->lock);\r\nreturn NULL;\r\nerr_clean_up:\r\nlli_prev->link_addr = 0x00000000U;\r\nspin_unlock(&pool->lock);\r\ncoh901318_lli_free(pool, &head);\r\nreturn NULL;\r\n}\r\nvoid coh901318_lli_free(struct coh901318_pool *pool,\r\nstruct coh901318_lli **lli)\r\n{\r\nstruct coh901318_lli *l;\r\nstruct coh901318_lli *next;\r\nif (lli == NULL)\r\nreturn;\r\nl = *lli;\r\nif (l == NULL)\r\nreturn;\r\nspin_lock(&pool->lock);\r\nwhile (l->link_addr) {\r\nnext = l->virt_link_addr;\r\ndma_pool_free(pool->dmapool, l, l->phy_this);\r\nDEBUGFS_POOL_COUNTER_ADD(pool, -1);\r\nl = next;\r\n}\r\ndma_pool_free(pool->dmapool, l, l->phy_this);\r\nDEBUGFS_POOL_COUNTER_ADD(pool, -1);\r\nspin_unlock(&pool->lock);\r\n*lli = NULL;\r\n}\r\nint\r\ncoh901318_lli_fill_memcpy(struct coh901318_pool *pool,\r\nstruct coh901318_lli *lli,\r\ndma_addr_t source, unsigned int size,\r\ndma_addr_t destination, u32 ctrl_chained,\r\nu32 ctrl_eom)\r\n{\r\nint s = size;\r\ndma_addr_t src = source;\r\ndma_addr_t dst = destination;\r\nlli->src_addr = src;\r\nlli->dst_addr = dst;\r\nwhile (lli->link_addr) {\r\nlli->control = ctrl_chained | MAX_DMA_PACKET_SIZE;\r\nlli->src_addr = src;\r\nlli->dst_addr = dst;\r\ns -= MAX_DMA_PACKET_SIZE;\r\nlli = coh901318_lli_next(lli);\r\nsrc += MAX_DMA_PACKET_SIZE;\r\ndst += MAX_DMA_PACKET_SIZE;\r\n}\r\nlli->control = ctrl_eom | s;\r\nlli->src_addr = src;\r\nlli->dst_addr = dst;\r\nreturn 0;\r\n}\r\nint\r\ncoh901318_lli_fill_single(struct coh901318_pool *pool,\r\nstruct coh901318_lli *lli,\r\ndma_addr_t buf, unsigned int size,\r\ndma_addr_t dev_addr, u32 ctrl_chained, u32 ctrl_eom,\r\nenum dma_transfer_direction dir)\r\n{\r\nint s = size;\r\ndma_addr_t src;\r\ndma_addr_t dst;\r\nif (dir == DMA_MEM_TO_DEV) {\r\nsrc = buf;\r\ndst = dev_addr;\r\n} else if (dir == DMA_DEV_TO_MEM) {\r\nsrc = dev_addr;\r\ndst = buf;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nwhile (lli->link_addr) {\r\nsize_t block_size = MAX_DMA_PACKET_SIZE;\r\nlli->control = ctrl_chained | MAX_DMA_PACKET_SIZE;\r\nif (s < (MAX_DMA_PACKET_SIZE + MAX_DMA_PACKET_SIZE/2))\r\nblock_size = MAX_DMA_PACKET_SIZE/2;\r\ns -= block_size;\r\nlli->src_addr = src;\r\nlli->dst_addr = dst;\r\nlli = coh901318_lli_next(lli);\r\nif (dir == DMA_MEM_TO_DEV)\r\nsrc += block_size;\r\nelse if (dir == DMA_DEV_TO_MEM)\r\ndst += block_size;\r\n}\r\nlli->control = ctrl_eom | s;\r\nlli->src_addr = src;\r\nlli->dst_addr = dst;\r\nreturn 0;\r\n}\r\nint\r\ncoh901318_lli_fill_sg(struct coh901318_pool *pool,\r\nstruct coh901318_lli *lli,\r\nstruct scatterlist *sgl, unsigned int nents,\r\ndma_addr_t dev_addr, u32 ctrl_chained, u32 ctrl,\r\nu32 ctrl_last,\r\nenum dma_transfer_direction dir, u32 ctrl_irq_mask)\r\n{\r\nint i;\r\nstruct scatterlist *sg;\r\nu32 ctrl_sg;\r\ndma_addr_t src = 0;\r\ndma_addr_t dst = 0;\r\nu32 bytes_to_transfer;\r\nu32 elem_size;\r\nif (lli == NULL)\r\ngoto err;\r\nspin_lock(&pool->lock);\r\nif (dir == DMA_MEM_TO_DEV)\r\ndst = dev_addr;\r\nelse if (dir == DMA_DEV_TO_MEM)\r\nsrc = dev_addr;\r\nelse\r\ngoto err;\r\nfor_each_sg(sgl, sg, nents, i) {\r\nif (sg_is_chain(sg)) {\r\nctrl_sg = ctrl_chained;\r\n} else if (i == nents - 1)\r\nctrl_sg = ctrl_last;\r\nelse\r\nctrl_sg = ctrl ? ctrl : ctrl_last;\r\nif (dir == DMA_MEM_TO_DEV)\r\nsrc = sg_dma_address(sg);\r\nelse\r\ndst = sg_dma_address(sg);\r\nbytes_to_transfer = sg_dma_len(sg);\r\nwhile (bytes_to_transfer) {\r\nu32 val;\r\nif (bytes_to_transfer > MAX_DMA_PACKET_SIZE) {\r\nelem_size = MAX_DMA_PACKET_SIZE;\r\nval = ctrl_chained;\r\n} else {\r\nelem_size = bytes_to_transfer;\r\nval = ctrl_sg;\r\n}\r\nlli->control = val | elem_size;\r\nlli->src_addr = src;\r\nlli->dst_addr = dst;\r\nif (dir == DMA_DEV_TO_MEM)\r\ndst += elem_size;\r\nelse\r\nsrc += elem_size;\r\nBUG_ON(lli->link_addr & 3);\r\nbytes_to_transfer -= elem_size;\r\nlli = coh901318_lli_next(lli);\r\n}\r\n}\r\nspin_unlock(&pool->lock);\r\nreturn 0;\r\nerr:\r\nspin_unlock(&pool->lock);\r\nreturn -EINVAL;\r\n}
