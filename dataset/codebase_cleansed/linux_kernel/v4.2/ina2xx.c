static int ina226_reg_to_interval(u16 config)\r\n{\r\nint avg = ina226_avg_tab[INA226_READ_AVG(config)];\r\nreturn DIV_ROUND_CLOSEST(avg * INA226_TOTAL_CONV_TIME_DEFAULT, 1000);\r\n}\r\nstatic u16 ina226_interval_to_reg(int interval, u16 config)\r\n{\r\nint avg, avg_bits;\r\navg = DIV_ROUND_CLOSEST(interval * 1000,\r\nINA226_TOTAL_CONV_TIME_DEFAULT);\r\navg_bits = find_closest(avg, ina226_avg_tab,\r\nARRAY_SIZE(ina226_avg_tab));\r\nreturn (config & ~INA226_AVG_RD_MASK) | INA226_SHIFT_AVG(avg_bits);\r\n}\r\nstatic void ina226_set_update_interval(struct ina2xx_data *data)\r\n{\r\nint ms;\r\nms = ina226_reg_to_interval(data->curr_config);\r\ndata->update_interval = msecs_to_jiffies(ms);\r\n}\r\nstatic int ina2xx_calibrate(struct ina2xx_data *data)\r\n{\r\nu16 val = DIV_ROUND_CLOSEST(data->config->calibration_factor,\r\ndata->rshunt);\r\nreturn i2c_smbus_write_word_swapped(data->client,\r\nINA2XX_CALIBRATION, val);\r\n}\r\nstatic int ina2xx_init(struct ina2xx_data *data)\r\n{\r\nstruct i2c_client *client = data->client;\r\nint ret;\r\nret = i2c_smbus_write_word_swapped(client, INA2XX_CONFIG,\r\ndata->curr_config);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ina2xx_calibrate(data);\r\n}\r\nstatic int ina2xx_do_update(struct device *dev)\r\n{\r\nstruct ina2xx_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint i, rv, retry;\r\ndev_dbg(&client->dev, "Starting ina2xx update\n");\r\nfor (retry = 5; retry; retry--) {\r\nfor (i = 0; i < data->config->registers; i++) {\r\nrv = i2c_smbus_read_word_swapped(client, i);\r\nif (rv < 0)\r\nreturn rv;\r\ndata->regs[i] = rv;\r\n}\r\nif (data->regs[INA2XX_CALIBRATION] == 0) {\r\ndev_warn(dev, "chip not calibrated, reinitializing\n");\r\nrv = ina2xx_init(data);\r\nif (rv < 0)\r\nreturn rv;\r\nmsleep(INA2XX_MAX_DELAY);\r\ncontinue;\r\n}\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\nreturn 0;\r\n}\r\ndev_err(dev, "unable to reinitialize the chip\n");\r\nreturn -ENODEV;\r\n}\r\nstatic struct ina2xx_data *ina2xx_update_device(struct device *dev)\r\n{\r\nstruct ina2xx_data *data = dev_get_drvdata(dev);\r\nstruct ina2xx_data *ret = data;\r\nunsigned long after;\r\nint rv;\r\nmutex_lock(&data->update_lock);\r\nafter = data->last_updated + data->update_interval;\r\nif (time_after(jiffies, after) || !data->valid) {\r\nrv = ina2xx_do_update(dev);\r\nif (rv < 0)\r\nret = ERR_PTR(rv);\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic int ina2xx_get_value(struct ina2xx_data *data, u8 reg)\r\n{\r\nint val;\r\nswitch (reg) {\r\ncase INA2XX_SHUNT_VOLTAGE:\r\nval = DIV_ROUND_CLOSEST((s16)data->regs[reg],\r\ndata->config->shunt_div);\r\nbreak;\r\ncase INA2XX_BUS_VOLTAGE:\r\nval = (data->regs[reg] >> data->config->bus_voltage_shift)\r\n* data->config->bus_voltage_lsb;\r\nval = DIV_ROUND_CLOSEST(val, 1000);\r\nbreak;\r\ncase INA2XX_POWER:\r\nval = data->regs[reg] * data->config->power_lsb;\r\nbreak;\r\ncase INA2XX_CURRENT:\r\nval = (s16)data->regs[reg];\r\nbreak;\r\ncase INA2XX_CALIBRATION:\r\nval = DIV_ROUND_CLOSEST(data->config->calibration_factor,\r\ndata->regs[reg]);\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\nval = 0;\r\nbreak;\r\n}\r\nreturn val;\r\n}\r\nstatic ssize_t ina2xx_show_value(struct device *dev,\r\nstruct device_attribute *da, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct ina2xx_data *data = ina2xx_update_device(dev);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\nina2xx_get_value(data, attr->index));\r\n}\r\nstatic ssize_t ina2xx_set_shunt(struct device *dev,\r\nstruct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ina2xx_data *data = ina2xx_update_device(dev);\r\nunsigned long val;\r\nint status;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nstatus = kstrtoul(buf, 10, &val);\r\nif (status < 0)\r\nreturn status;\r\nif (val == 0 ||\r\nval > data->config->calibration_factor)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->rshunt = val;\r\nstatus = ina2xx_calibrate(data);\r\nmutex_unlock(&data->update_lock);\r\nif (status < 0)\r\nreturn status;\r\nreturn count;\r\n}\r\nstatic ssize_t ina226_set_interval(struct device *dev,\r\nstruct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ina2xx_data *data = dev_get_drvdata(dev);\r\nunsigned long val;\r\nint status;\r\nstatus = kstrtoul(buf, 10, &val);\r\nif (status < 0)\r\nreturn status;\r\nif (val > INT_MAX || val == 0)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->curr_config = ina226_interval_to_reg(val,\r\ndata->regs[INA2XX_CONFIG]);\r\nstatus = i2c_smbus_write_word_swapped(data->client,\r\nINA2XX_CONFIG,\r\ndata->curr_config);\r\nina226_set_update_interval(data);\r\ndata->valid = 0;\r\nmutex_unlock(&data->update_lock);\r\nif (status < 0)\r\nreturn status;\r\nreturn count;\r\n}\r\nstatic ssize_t ina226_show_interval(struct device *dev,\r\nstruct device_attribute *da, char *buf)\r\n{\r\nstruct ina2xx_data *data = ina2xx_update_device(dev);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\nina226_reg_to_interval(data->regs[INA2XX_CONFIG]));\r\n}\r\nstatic int ina2xx_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nstruct ina2xx_platform_data *pdata;\r\nstruct device *dev = &client->dev;\r\nstruct ina2xx_data *data;\r\nstruct device *hwmon_dev;\r\nu32 val;\r\nint ret, group = 0;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA))\r\nreturn -ENODEV;\r\ndata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nif (dev_get_platdata(dev)) {\r\npdata = dev_get_platdata(dev);\r\ndata->rshunt = pdata->shunt_uohms;\r\n} else if (!of_property_read_u32(dev->of_node,\r\n"shunt-resistor", &val)) {\r\ndata->rshunt = val;\r\n} else {\r\ndata->rshunt = INA2XX_RSHUNT_DEFAULT;\r\n}\r\ndata->kind = id->driver_data;\r\ndata->config = &ina2xx_config[data->kind];\r\ndata->curr_config = data->config->config_default;\r\ndata->client = client;\r\nif (data->kind == ina226)\r\nina226_set_update_interval(data);\r\nelse\r\ndata->update_interval = HZ / INA2XX_CONVERSION_RATE;\r\nif (data->rshunt <= 0 ||\r\ndata->rshunt > data->config->calibration_factor)\r\nreturn -ENODEV;\r\nret = ina2xx_init(data);\r\nif (ret < 0) {\r\ndev_err(dev, "error configuring the device: %d\n", ret);\r\nreturn -ENODEV;\r\n}\r\nmutex_init(&data->update_lock);\r\ndata->groups[group++] = &ina2xx_group;\r\nif (data->kind == ina226)\r\ndata->groups[group++] = &ina226_group;\r\nhwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\r\ndata, data->groups);\r\nif (IS_ERR(hwmon_dev))\r\nreturn PTR_ERR(hwmon_dev);\r\ndev_info(dev, "power monitor %s (Rshunt = %li uOhm)\n",\r\nid->name, data->rshunt);\r\nreturn 0;\r\n}
