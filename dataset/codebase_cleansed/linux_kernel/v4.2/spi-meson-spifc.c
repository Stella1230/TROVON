static int meson_spifc_wait_ready(struct meson_spifc *spifc)\r\n{\r\nunsigned long deadline = jiffies + msecs_to_jiffies(5);\r\nu32 data;\r\ndo {\r\nregmap_read(spifc->regmap, REG_SLAVE, &data);\r\nif (data & SLAVE_TRST_DONE)\r\nreturn 0;\r\ncond_resched();\r\n} while (!time_after(jiffies, deadline));\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void meson_spifc_drain_buffer(struct meson_spifc *spifc, u8 *buf,\r\nint len)\r\n{\r\nu32 data;\r\nint i = 0;\r\nwhile (i < len) {\r\nregmap_read(spifc->regmap, REG_C0 + i, &data);\r\nif (len - i >= 4) {\r\n*((u32 *)buf) = data;\r\nbuf += 4;\r\n} else {\r\nmemcpy(buf, &data, len - i);\r\nbreak;\r\n}\r\ni += 4;\r\n}\r\n}\r\nstatic void meson_spifc_fill_buffer(struct meson_spifc *spifc, const u8 *buf,\r\nint len)\r\n{\r\nu32 data;\r\nint i = 0;\r\nwhile (i < len) {\r\nif (len - i >= 4)\r\ndata = *(u32 *)buf;\r\nelse\r\nmemcpy(&data, buf, len - i);\r\nregmap_write(spifc->regmap, REG_C0 + i, data);\r\nbuf += 4;\r\ni += 4;\r\n}\r\n}\r\nstatic void meson_spifc_setup_speed(struct meson_spifc *spifc, u32 speed)\r\n{\r\nunsigned long parent, value;\r\nint n;\r\nparent = clk_get_rate(spifc->clk);\r\nn = max_t(int, parent / speed - 1, 1);\r\ndev_dbg(spifc->dev, "parent %lu, speed %u, n %d\n", parent,\r\nspeed, n);\r\nvalue = (n << CLOCK_DIV_SHIFT) & CLOCK_DIV_MASK;\r\nvalue |= (n << CLOCK_CNT_LOW_SHIFT) & CLOCK_CNT_LOW_MASK;\r\nvalue |= (((n + 1) / 2 - 1) << CLOCK_CNT_HIGH_SHIFT) &\r\nCLOCK_CNT_HIGH_MASK;\r\nregmap_write(spifc->regmap, REG_CLOCK, value);\r\n}\r\nstatic int meson_spifc_txrx(struct meson_spifc *spifc,\r\nstruct spi_transfer *xfer,\r\nint offset, int len, bool last_xfer,\r\nbool last_chunk)\r\n{\r\nbool keep_cs = true;\r\nint ret;\r\nif (xfer->tx_buf)\r\nmeson_spifc_fill_buffer(spifc, xfer->tx_buf + offset, len);\r\nregmap_update_bits(spifc->regmap, REG_USER, USER_UC_MASK,\r\nUSER_UC_DOUT_SEL);\r\nregmap_write(spifc->regmap, REG_USER1,\r\n(8 * len - 1) << USER1_BN_UC_DOUT_SHIFT);\r\nregmap_update_bits(spifc->regmap, REG_USER, USER_DIN_EN_MS,\r\nUSER_DIN_EN_MS);\r\nif (last_chunk) {\r\nif (last_xfer)\r\nkeep_cs = xfer->cs_change;\r\nelse\r\nkeep_cs = !xfer->cs_change;\r\n}\r\nregmap_update_bits(spifc->regmap, REG_USER4, USER4_CS_ACT,\r\nkeep_cs ? USER4_CS_ACT : 0);\r\nregmap_update_bits(spifc->regmap, REG_SLAVE, SLAVE_TRST_DONE, 0);\r\nregmap_update_bits(spifc->regmap, REG_CMD, CMD_USER, CMD_USER);\r\nret = meson_spifc_wait_ready(spifc);\r\nif (!ret && xfer->rx_buf)\r\nmeson_spifc_drain_buffer(spifc, xfer->rx_buf + offset, len);\r\nreturn ret;\r\n}\r\nstatic int meson_spifc_transfer_one(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *xfer)\r\n{\r\nstruct meson_spifc *spifc = spi_master_get_devdata(master);\r\nint len, done = 0, ret = 0;\r\nmeson_spifc_setup_speed(spifc, xfer->speed_hz);\r\nregmap_update_bits(spifc->regmap, REG_CTRL, CTRL_ENABLE_AHB, 0);\r\nwhile (done < xfer->len && !ret) {\r\nlen = min_t(int, xfer->len - done, SPIFC_BUFFER_SIZE);\r\nret = meson_spifc_txrx(spifc, xfer, done, len,\r\nspi_transfer_is_last(master, xfer),\r\ndone + len >= xfer->len);\r\ndone += len;\r\n}\r\nregmap_update_bits(spifc->regmap, REG_CTRL, CTRL_ENABLE_AHB,\r\nCTRL_ENABLE_AHB);\r\nreturn ret;\r\n}\r\nstatic void meson_spifc_hw_init(struct meson_spifc *spifc)\r\n{\r\nregmap_update_bits(spifc->regmap, REG_SLAVE, SLAVE_SW_RST,\r\nSLAVE_SW_RST);\r\nregmap_update_bits(spifc->regmap, REG_USER, USER_CMP_MODE, 0);\r\nregmap_update_bits(spifc->regmap, REG_SLAVE, SLAVE_OP_MODE, 0);\r\n}\r\nstatic int meson_spifc_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct meson_spifc *spifc;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nunsigned int rate;\r\nint ret = 0;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(struct meson_spifc));\r\nif (!master)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, master);\r\nspifc = spi_master_get_devdata(master);\r\nspifc->dev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(spifc->dev, res);\r\nif (IS_ERR(base)) {\r\nret = PTR_ERR(base);\r\ngoto out_err;\r\n}\r\nspifc->regmap = devm_regmap_init_mmio(spifc->dev, base,\r\n&spifc_regmap_config);\r\nif (IS_ERR(spifc->regmap)) {\r\nret = PTR_ERR(spifc->regmap);\r\ngoto out_err;\r\n}\r\nspifc->clk = devm_clk_get(spifc->dev, NULL);\r\nif (IS_ERR(spifc->clk)) {\r\ndev_err(spifc->dev, "missing clock\n");\r\nret = PTR_ERR(spifc->clk);\r\ngoto out_err;\r\n}\r\nret = clk_prepare_enable(spifc->clk);\r\nif (ret) {\r\ndev_err(spifc->dev, "can't prepare clock\n");\r\ngoto out_err;\r\n}\r\nrate = clk_get_rate(spifc->clk);\r\nmaster->num_chipselect = 1;\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(8);\r\nmaster->auto_runtime_pm = true;\r\nmaster->transfer_one = meson_spifc_transfer_one;\r\nmaster->min_speed_hz = rate >> 6;\r\nmaster->max_speed_hz = rate >> 1;\r\nmeson_spifc_hw_init(spifc);\r\npm_runtime_set_active(spifc->dev);\r\npm_runtime_enable(spifc->dev);\r\nret = devm_spi_register_master(spifc->dev, master);\r\nif (ret) {\r\ndev_err(spifc->dev, "failed to register spi master\n");\r\ngoto out_clk;\r\n}\r\nreturn 0;\r\nout_clk:\r\nclk_disable_unprepare(spifc->clk);\r\nout_err:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int meson_spifc_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct meson_spifc *spifc = spi_master_get_devdata(master);\r\npm_runtime_get_sync(&pdev->dev);\r\nclk_disable_unprepare(spifc->clk);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int meson_spifc_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct meson_spifc *spifc = spi_master_get_devdata(master);\r\nint ret;\r\nret = spi_master_suspend(master);\r\nif (ret)\r\nreturn ret;\r\nif (!pm_runtime_suspended(dev))\r\nclk_disable_unprepare(spifc->clk);\r\nreturn 0;\r\n}\r\nstatic int meson_spifc_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct meson_spifc *spifc = spi_master_get_devdata(master);\r\nint ret;\r\nif (!pm_runtime_suspended(dev)) {\r\nret = clk_prepare_enable(spifc->clk);\r\nif (ret)\r\nreturn ret;\r\n}\r\nmeson_spifc_hw_init(spifc);\r\nret = spi_master_resume(master);\r\nif (ret)\r\nclk_disable_unprepare(spifc->clk);\r\nreturn ret;\r\n}\r\nstatic int meson_spifc_runtime_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct meson_spifc *spifc = spi_master_get_devdata(master);\r\nclk_disable_unprepare(spifc->clk);\r\nreturn 0;\r\n}\r\nstatic int meson_spifc_runtime_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct meson_spifc *spifc = spi_master_get_devdata(master);\r\nreturn clk_prepare_enable(spifc->clk);\r\n}
