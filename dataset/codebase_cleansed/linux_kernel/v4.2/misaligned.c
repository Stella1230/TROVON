static inline u32 get_reg_val(struct pt_regs *fp, int reg)\r\n{\r\nu8 *p = ((u8 *)fp) + reg_offsets[reg];\r\nreturn *(u32 *)p;\r\n}\r\nstatic inline void put_reg_val(struct pt_regs *fp, int reg, u32 val)\r\n{\r\nu8 *p = ((u8 *)fp) + reg_offsets[reg];\r\n*(u32 *)p = val;\r\n}\r\nasmlinkage void handle_unaligned_c(struct pt_regs *fp, int cause)\r\n{\r\nu32 isn, addr, val;\r\nint in_kernel;\r\nu8 a, b, d0, d1, d2, d3;\r\nu16 imm16;\r\nunsigned int fault;\r\nfp->ea -= 4;\r\nif (fixup_exception(fp)) {\r\nma_skipped++;\r\nreturn;\r\n}\r\nin_kernel = !user_mode(fp);\r\nisn = *(unsigned long *)(fp->ea);\r\nfault = 0;\r\nif (in_kernel || (ma_usermode & UM_FIXUP)) {\r\na = (isn >> 27) & 0x1f;\r\nb = (isn >> 22) & 0x1f;\r\nimm16 = (isn >> 6) & 0xffff;\r\naddr = get_reg_val(fp, a) + imm16;\r\nswitch (isn & 0x3f) {\r\ncase INST_LDHU:\r\nfault |= __get_user(d0, (u8 *)(addr+0));\r\nfault |= __get_user(d1, (u8 *)(addr+1));\r\nval = (d1 << 8) | d0;\r\nput_reg_val(fp, b, val);\r\nma_half++;\r\nbreak;\r\ncase INST_STH:\r\nval = get_reg_val(fp, b);\r\nd1 = val >> 8;\r\nd0 = val >> 0;\r\npr_debug("sth: ra=%d (%08x) rb=%d (%08x), imm16 %04x addr %08x val %08x\n",\r\na, get_reg_val(fp, a),\r\nb, get_reg_val(fp, b),\r\nimm16, addr, val);\r\nif (in_kernel) {\r\n*(u8 *)(addr+0) = d0;\r\n*(u8 *)(addr+1) = d1;\r\n} else {\r\nfault |= __put_user(d0, (u8 *)(addr+0));\r\nfault |= __put_user(d1, (u8 *)(addr+1));\r\n}\r\nma_half++;\r\nbreak;\r\ncase INST_LDH:\r\nfault |= __get_user(d0, (u8 *)(addr+0));\r\nfault |= __get_user(d1, (u8 *)(addr+1));\r\nval = (short)((d1 << 8) | d0);\r\nput_reg_val(fp, b, val);\r\nma_half++;\r\nbreak;\r\ncase INST_STW:\r\nval = get_reg_val(fp, b);\r\nd3 = val >> 24;\r\nd2 = val >> 16;\r\nd1 = val >> 8;\r\nd0 = val >> 0;\r\nif (in_kernel) {\r\n*(u8 *)(addr+0) = d0;\r\n*(u8 *)(addr+1) = d1;\r\n*(u8 *)(addr+2) = d2;\r\n*(u8 *)(addr+3) = d3;\r\n} else {\r\nfault |= __put_user(d0, (u8 *)(addr+0));\r\nfault |= __put_user(d1, (u8 *)(addr+1));\r\nfault |= __put_user(d2, (u8 *)(addr+2));\r\nfault |= __put_user(d3, (u8 *)(addr+3));\r\n}\r\nma_word++;\r\nbreak;\r\ncase INST_LDW:\r\nfault |= __get_user(d0, (u8 *)(addr+0));\r\nfault |= __get_user(d1, (u8 *)(addr+1));\r\nfault |= __get_user(d2, (u8 *)(addr+2));\r\nfault |= __get_user(d3, (u8 *)(addr+3));\r\nval = (d3 << 24) | (d2 << 16) | (d1 << 8) | d0;\r\nput_reg_val(fp, b, val);\r\nma_word++;\r\nbreak;\r\n}\r\n}\r\naddr = RDCTL(CTL_BADADDR);\r\ncause >>= 2;\r\nif (fault) {\r\nif (in_kernel) {\r\npr_err("fault during kernel misaligned fixup @ %#lx; addr 0x%08x; isn=0x%08x\n",\r\nfp->ea, (unsigned int)addr,\r\n(unsigned int)isn);\r\n} else {\r\npr_err("fault during user misaligned fixup @ %#lx; isn=%08x addr=0x%08x sp=0x%08lx pid=%d\n",\r\nfp->ea,\r\n(unsigned int)isn, addr, fp->sp,\r\ncurrent->pid);\r\n_exception(SIGSEGV, fp, SEGV_MAPERR, fp->ea);\r\nreturn;\r\n}\r\n}\r\nif (in_kernel) {\r\nma_kern++;\r\nfp->ea += 4;\r\nif (ma_usermode & KM_WARN) {\r\npr_err("kernel unaligned access @ %#lx; BADADDR 0x%08x; cause=%d, isn=0x%08x\n",\r\nfp->ea,\r\n(unsigned int)addr, cause,\r\n(unsigned int)isn);\r\n}\r\nreturn;\r\n}\r\nma_user++;\r\nif (ma_usermode & UM_WARN) {\r\npr_err("user unaligned access @ %#lx; isn=0x%08lx ea=0x%08lx ra=0x%08lx sp=0x%08lx\n",\r\n(unsigned long)addr, (unsigned long)isn,\r\nfp->ea, fp->ra, fp->sp);\r\n}\r\nif (ma_usermode & UM_SIGNAL)\r\n_exception(SIGBUS, fp, BUS_ADRALN, fp->ea);\r\nelse\r\nfp->ea += 4;\r\n}\r\nstatic void __init misaligned_calc_reg_offsets(void)\r\n{\r\nint i, r, offset;\r\noffset = 0;\r\nfor (i = 0; i < 16; i++) {\r\nr = sys_stack_frame_reg_offset[i];\r\nreg_offsets[r] = offset;\r\noffset += 4;\r\n}\r\noffset = -sizeof(struct switch_stack);\r\nfor (i = 16; i < 32; i++) {\r\nr = sys_stack_frame_reg_offset[i];\r\nreg_offsets[r] = offset;\r\noffset += 4;\r\n}\r\n}\r\nstatic int __init misaligned_init(void)\r\n{\r\nma_usermode = UM_FIXUP | KM_WARN;\r\nmisaligned_calc_reg_offsets();\r\nreturn 0;\r\n}
