static void au1000_enable_mac(struct net_device *dev, int force_reset)\r\n{\r\nunsigned long flags;\r\nstruct au1000_private *aup = netdev_priv(dev);\r\nspin_lock_irqsave(&aup->lock, flags);\r\nif (force_reset || (!aup->mac_enabled)) {\r\nwritel(MAC_EN_CLOCK_ENABLE, aup->enable);\r\nwmb();\r\nmdelay(2);\r\nwritel((MAC_EN_RESET0 | MAC_EN_RESET1 | MAC_EN_RESET2\r\n| MAC_EN_CLOCK_ENABLE), aup->enable);\r\nwmb();\r\nmdelay(2);\r\naup->mac_enabled = 1;\r\n}\r\nspin_unlock_irqrestore(&aup->lock, flags);\r\n}\r\nstatic int au1000_mdio_read(struct net_device *dev, int phy_addr, int reg)\r\n{\r\nstruct au1000_private *aup = netdev_priv(dev);\r\nu32 *const mii_control_reg = &aup->mac->mii_control;\r\nu32 *const mii_data_reg = &aup->mac->mii_data;\r\nu32 timedout = 20;\r\nu32 mii_control;\r\nwhile (readl(mii_control_reg) & MAC_MII_BUSY) {\r\nmdelay(1);\r\nif (--timedout == 0) {\r\nnetdev_err(dev, "read_MII busy timeout!!\n");\r\nreturn -1;\r\n}\r\n}\r\nmii_control = MAC_SET_MII_SELECT_REG(reg) |\r\nMAC_SET_MII_SELECT_PHY(phy_addr) | MAC_MII_READ;\r\nwritel(mii_control, mii_control_reg);\r\ntimedout = 20;\r\nwhile (readl(mii_control_reg) & MAC_MII_BUSY) {\r\nmdelay(1);\r\nif (--timedout == 0) {\r\nnetdev_err(dev, "mdio_read busy timeout!!\n");\r\nreturn -1;\r\n}\r\n}\r\nreturn readl(mii_data_reg);\r\n}\r\nstatic void au1000_mdio_write(struct net_device *dev, int phy_addr,\r\nint reg, u16 value)\r\n{\r\nstruct au1000_private *aup = netdev_priv(dev);\r\nu32 *const mii_control_reg = &aup->mac->mii_control;\r\nu32 *const mii_data_reg = &aup->mac->mii_data;\r\nu32 timedout = 20;\r\nu32 mii_control;\r\nwhile (readl(mii_control_reg) & MAC_MII_BUSY) {\r\nmdelay(1);\r\nif (--timedout == 0) {\r\nnetdev_err(dev, "mdio_write busy timeout!!\n");\r\nreturn;\r\n}\r\n}\r\nmii_control = MAC_SET_MII_SELECT_REG(reg) |\r\nMAC_SET_MII_SELECT_PHY(phy_addr) | MAC_MII_WRITE;\r\nwritel(value, mii_data_reg);\r\nwritel(mii_control, mii_control_reg);\r\n}\r\nstatic int au1000_mdiobus_read(struct mii_bus *bus, int phy_addr, int regnum)\r\n{\r\nstruct net_device *const dev = bus->priv;\r\nau1000_enable_mac(dev, 0);\r\nreturn au1000_mdio_read(dev, phy_addr, regnum);\r\n}\r\nstatic int au1000_mdiobus_write(struct mii_bus *bus, int phy_addr, int regnum,\r\nu16 value)\r\n{\r\nstruct net_device *const dev = bus->priv;\r\nau1000_enable_mac(dev, 0);\r\nau1000_mdio_write(dev, phy_addr, regnum, value);\r\nreturn 0;\r\n}\r\nstatic int au1000_mdiobus_reset(struct mii_bus *bus)\r\n{\r\nstruct net_device *const dev = bus->priv;\r\nau1000_enable_mac(dev, 0);\r\nreturn 0;\r\n}\r\nstatic void au1000_hard_stop(struct net_device *dev)\r\n{\r\nstruct au1000_private *aup = netdev_priv(dev);\r\nu32 reg;\r\nnetif_dbg(aup, drv, dev, "hard stop\n");\r\nreg = readl(&aup->mac->control);\r\nreg &= ~(MAC_RX_ENABLE | MAC_TX_ENABLE);\r\nwritel(reg, &aup->mac->control);\r\nwmb();\r\nmdelay(10);\r\n}\r\nstatic void au1000_enable_rx_tx(struct net_device *dev)\r\n{\r\nstruct au1000_private *aup = netdev_priv(dev);\r\nu32 reg;\r\nnetif_dbg(aup, hw, dev, "enable_rx_tx\n");\r\nreg = readl(&aup->mac->control);\r\nreg |= (MAC_RX_ENABLE | MAC_TX_ENABLE);\r\nwritel(reg, &aup->mac->control);\r\nwmb();\r\nmdelay(10);\r\n}\r\nstatic void\r\nau1000_adjust_link(struct net_device *dev)\r\n{\r\nstruct au1000_private *aup = netdev_priv(dev);\r\nstruct phy_device *phydev = aup->phy_dev;\r\nunsigned long flags;\r\nu32 reg;\r\nint status_change = 0;\r\nBUG_ON(!aup->phy_dev);\r\nspin_lock_irqsave(&aup->lock, flags);\r\nif (phydev->link && (aup->old_speed != phydev->speed)) {\r\nswitch (phydev->speed) {\r\ncase SPEED_10:\r\ncase SPEED_100:\r\nbreak;\r\ndefault:\r\nnetdev_warn(dev, "Speed (%d) is not 10/100 ???\n",\r\nphydev->speed);\r\nbreak;\r\n}\r\naup->old_speed = phydev->speed;\r\nstatus_change = 1;\r\n}\r\nif (phydev->link && (aup->old_duplex != phydev->duplex)) {\r\nau1000_hard_stop(dev);\r\nreg = readl(&aup->mac->control);\r\nif (DUPLEX_FULL == phydev->duplex) {\r\nreg |= MAC_FULL_DUPLEX;\r\nreg &= ~MAC_DISABLE_RX_OWN;\r\n} else {\r\nreg &= ~MAC_FULL_DUPLEX;\r\nreg |= MAC_DISABLE_RX_OWN;\r\n}\r\nwritel(reg, &aup->mac->control);\r\nwmb();\r\nmdelay(1);\r\nau1000_enable_rx_tx(dev);\r\naup->old_duplex = phydev->duplex;\r\nstatus_change = 1;\r\n}\r\nif (phydev->link != aup->old_link) {\r\nif (!phydev->link) {\r\naup->old_speed = 0;\r\naup->old_duplex = -1;\r\n}\r\naup->old_link = phydev->link;\r\nstatus_change = 1;\r\n}\r\nspin_unlock_irqrestore(&aup->lock, flags);\r\nif (status_change) {\r\nif (phydev->link)\r\nnetdev_info(dev, "link up (%d/%s)\n",\r\nphydev->speed,\r\nDUPLEX_FULL == phydev->duplex ? "Full" : "Half");\r\nelse\r\nnetdev_info(dev, "link down\n");\r\n}\r\n}\r\nstatic int au1000_mii_probe(struct net_device *dev)\r\n{\r\nstruct au1000_private *const aup = netdev_priv(dev);\r\nstruct phy_device *phydev = NULL;\r\nint phy_addr;\r\nif (aup->phy_static_config) {\r\nBUG_ON(aup->mac_id < 0 || aup->mac_id > 1);\r\nif (aup->phy_addr)\r\nphydev = aup->mii_bus->phy_map[aup->phy_addr];\r\nelse\r\nnetdev_info(dev, "using PHY-less setup\n");\r\nreturn 0;\r\n}\r\nfor (phy_addr = 0; phy_addr < PHY_MAX_ADDR; phy_addr++)\r\nif (aup->mii_bus->phy_map[phy_addr]) {\r\nphydev = aup->mii_bus->phy_map[phy_addr];\r\nif (!aup->phy_search_highest_addr)\r\nbreak;\r\n}\r\nif (aup->phy1_search_mac0) {\r\nif (!phydev && (aup->mac_id == 1)) {\r\ndev_info(&dev->dev, ": no PHY found on MAC1, "\r\n"let's see if it's attached to MAC0...\n");\r\nfor (phy_addr = 0; phy_addr < PHY_MAX_ADDR; phy_addr++) {\r\nstruct phy_device *const tmp_phydev =\r\naup->mii_bus->phy_map[phy_addr];\r\nif (aup->mac_id == 1)\r\nbreak;\r\nif (!tmp_phydev)\r\ncontinue;\r\nif (tmp_phydev->attached_dev)\r\ncontinue;\r\nphydev = tmp_phydev;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!phydev) {\r\nnetdev_err(dev, "no PHY found\n");\r\nreturn -1;\r\n}\r\nBUG_ON(phydev->attached_dev);\r\nphydev = phy_connect(dev, dev_name(&phydev->dev),\r\n&au1000_adjust_link, PHY_INTERFACE_MODE_MII);\r\nif (IS_ERR(phydev)) {\r\nnetdev_err(dev, "Could not attach to PHY\n");\r\nreturn PTR_ERR(phydev);\r\n}\r\nphydev->supported &= (SUPPORTED_10baseT_Half\r\n| SUPPORTED_10baseT_Full\r\n| SUPPORTED_100baseT_Half\r\n| SUPPORTED_100baseT_Full\r\n| SUPPORTED_Autoneg\r\n| SUPPORTED_MII\r\n| SUPPORTED_TP);\r\nphydev->advertising = phydev->supported;\r\naup->old_link = 0;\r\naup->old_speed = 0;\r\naup->old_duplex = -1;\r\naup->phy_dev = phydev;\r\nnetdev_info(dev, "attached PHY driver [%s] "\r\n"(mii_bus:phy_addr=%s, irq=%d)\n",\r\nphydev->drv->name, dev_name(&phydev->dev), phydev->irq);\r\nreturn 0;\r\n}\r\nstatic struct db_dest *au1000_GetFreeDB(struct au1000_private *aup)\r\n{\r\nstruct db_dest *pDB;\r\npDB = aup->pDBfree;\r\nif (pDB)\r\naup->pDBfree = pDB->pnext;\r\nreturn pDB;\r\n}\r\nvoid au1000_ReleaseDB(struct au1000_private *aup, struct db_dest *pDB)\r\n{\r\nstruct db_dest *pDBfree = aup->pDBfree;\r\nif (pDBfree)\r\npDBfree->pnext = pDB;\r\naup->pDBfree = pDB;\r\n}\r\nstatic void au1000_reset_mac_unlocked(struct net_device *dev)\r\n{\r\nstruct au1000_private *const aup = netdev_priv(dev);\r\nint i;\r\nau1000_hard_stop(dev);\r\nwritel(MAC_EN_CLOCK_ENABLE, aup->enable);\r\nwmb();\r\nmdelay(2);\r\nwritel(0, aup->enable);\r\nwmb();\r\nmdelay(2);\r\naup->tx_full = 0;\r\nfor (i = 0; i < NUM_RX_DMA; i++) {\r\naup->rx_dma_ring[i]->buff_stat &= ~0xf;\r\n}\r\nfor (i = 0; i < NUM_TX_DMA; i++) {\r\naup->tx_dma_ring[i]->buff_stat &= ~0xf;\r\n}\r\naup->mac_enabled = 0;\r\n}\r\nstatic void au1000_reset_mac(struct net_device *dev)\r\n{\r\nstruct au1000_private *const aup = netdev_priv(dev);\r\nunsigned long flags;\r\nnetif_dbg(aup, hw, dev, "reset mac, aup %x\n",\r\n(unsigned)aup);\r\nspin_lock_irqsave(&aup->lock, flags);\r\nau1000_reset_mac_unlocked(dev);\r\nspin_unlock_irqrestore(&aup->lock, flags);\r\n}\r\nstatic void\r\nau1000_setup_hw_rings(struct au1000_private *aup, void __iomem *tx_base)\r\n{\r\nint i;\r\nfor (i = 0; i < NUM_RX_DMA; i++) {\r\naup->rx_dma_ring[i] = (struct rx_dma *)\r\n(tx_base + 0x100 + sizeof(struct rx_dma) * i);\r\n}\r\nfor (i = 0; i < NUM_TX_DMA; i++) {\r\naup->tx_dma_ring[i] = (struct tx_dma *)\r\n(tx_base + sizeof(struct tx_dma) * i);\r\n}\r\n}\r\nstatic int au1000_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct au1000_private *aup = netdev_priv(dev);\r\nif (aup->phy_dev)\r\nreturn phy_ethtool_gset(aup->phy_dev, cmd);\r\nreturn -EINVAL;\r\n}\r\nstatic int au1000_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct au1000_private *aup = netdev_priv(dev);\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (aup->phy_dev)\r\nreturn phy_ethtool_sset(aup->phy_dev, cmd);\r\nreturn -EINVAL;\r\n}\r\nstatic void\r\nau1000_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nstruct au1000_private *aup = netdev_priv(dev);\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nsnprintf(info->bus_info, sizeof(info->bus_info), "%s %d", DRV_NAME,\r\naup->mac_id);\r\ninfo->regdump_len = 0;\r\n}\r\nstatic void au1000_set_msglevel(struct net_device *dev, u32 value)\r\n{\r\nstruct au1000_private *aup = netdev_priv(dev);\r\naup->msg_enable = value;\r\n}\r\nstatic u32 au1000_get_msglevel(struct net_device *dev)\r\n{\r\nstruct au1000_private *aup = netdev_priv(dev);\r\nreturn aup->msg_enable;\r\n}\r\nstatic int au1000_init(struct net_device *dev)\r\n{\r\nstruct au1000_private *aup = netdev_priv(dev);\r\nunsigned long flags;\r\nint i;\r\nu32 control;\r\nnetif_dbg(aup, hw, dev, "au1000_init\n");\r\nau1000_enable_mac(dev, 1);\r\nspin_lock_irqsave(&aup->lock, flags);\r\nwritel(0, &aup->mac->control);\r\naup->tx_head = (aup->tx_dma_ring[0]->buff_stat & 0xC) >> 2;\r\naup->tx_tail = aup->tx_head;\r\naup->rx_head = (aup->rx_dma_ring[0]->buff_stat & 0xC) >> 2;\r\nwritel(dev->dev_addr[5]<<8 | dev->dev_addr[4],\r\n&aup->mac->mac_addr_high);\r\nwritel(dev->dev_addr[3]<<24 | dev->dev_addr[2]<<16 |\r\ndev->dev_addr[1]<<8 | dev->dev_addr[0],\r\n&aup->mac->mac_addr_low);\r\nfor (i = 0; i < NUM_RX_DMA; i++)\r\naup->rx_dma_ring[i]->buff_stat |= RX_DMA_ENABLE;\r\nwmb();\r\ncontrol = MAC_RX_ENABLE | MAC_TX_ENABLE;\r\n#ifndef CONFIG_CPU_LITTLE_ENDIAN\r\ncontrol |= MAC_BIG_ENDIAN;\r\n#endif\r\nif (aup->phy_dev) {\r\nif (aup->phy_dev->link && (DUPLEX_FULL == aup->phy_dev->duplex))\r\ncontrol |= MAC_FULL_DUPLEX;\r\nelse\r\ncontrol |= MAC_DISABLE_RX_OWN;\r\n} else {\r\ncontrol |= MAC_FULL_DUPLEX;\r\n}\r\nwritel(control, &aup->mac->control);\r\nwritel(0x8100, &aup->mac->vlan1_tag);\r\nwmb();\r\nspin_unlock_irqrestore(&aup->lock, flags);\r\nreturn 0;\r\n}\r\nstatic inline void au1000_update_rx_stats(struct net_device *dev, u32 status)\r\n{\r\nstruct net_device_stats *ps = &dev->stats;\r\nps->rx_packets++;\r\nif (status & RX_MCAST_FRAME)\r\nps->multicast++;\r\nif (status & RX_ERROR) {\r\nps->rx_errors++;\r\nif (status & RX_MISSED_FRAME)\r\nps->rx_missed_errors++;\r\nif (status & (RX_OVERLEN | RX_RUNT | RX_LEN_ERROR))\r\nps->rx_length_errors++;\r\nif (status & RX_CRC_ERROR)\r\nps->rx_crc_errors++;\r\nif (status & RX_COLL)\r\nps->collisions++;\r\n} else\r\nps->rx_bytes += status & RX_FRAME_LEN_MASK;\r\n}\r\nstatic int au1000_rx(struct net_device *dev)\r\n{\r\nstruct au1000_private *aup = netdev_priv(dev);\r\nstruct sk_buff *skb;\r\nstruct rx_dma *prxd;\r\nu32 buff_stat, status;\r\nstruct db_dest *pDB;\r\nu32 frmlen;\r\nnetif_dbg(aup, rx_status, dev, "au1000_rx head %d\n", aup->rx_head);\r\nprxd = aup->rx_dma_ring[aup->rx_head];\r\nbuff_stat = prxd->buff_stat;\r\nwhile (buff_stat & RX_T_DONE) {\r\nstatus = prxd->status;\r\npDB = aup->rx_db_inuse[aup->rx_head];\r\nau1000_update_rx_stats(dev, status);\r\nif (!(status & RX_ERROR)) {\r\nfrmlen = (status & RX_FRAME_LEN_MASK);\r\nfrmlen -= 4;\r\nskb = netdev_alloc_skb(dev, frmlen + 2);\r\nif (skb == NULL) {\r\ndev->stats.rx_dropped++;\r\ncontinue;\r\n}\r\nskb_reserve(skb, 2);\r\nskb_copy_to_linear_data(skb,\r\n(unsigned char *)pDB->vaddr, frmlen);\r\nskb_put(skb, frmlen);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\n} else {\r\nif (au1000_debug > 4) {\r\npr_err("rx_error(s):");\r\nif (status & RX_MISSED_FRAME)\r\npr_cont(" miss");\r\nif (status & RX_WDOG_TIMER)\r\npr_cont(" wdog");\r\nif (status & RX_RUNT)\r\npr_cont(" runt");\r\nif (status & RX_OVERLEN)\r\npr_cont(" overlen");\r\nif (status & RX_COLL)\r\npr_cont(" coll");\r\nif (status & RX_MII_ERROR)\r\npr_cont(" mii error");\r\nif (status & RX_CRC_ERROR)\r\npr_cont(" crc error");\r\nif (status & RX_LEN_ERROR)\r\npr_cont(" len error");\r\nif (status & RX_U_CNTRL_FRAME)\r\npr_cont(" u control frame");\r\npr_cont("\n");\r\n}\r\n}\r\nprxd->buff_stat = (u32)(pDB->dma_addr | RX_DMA_ENABLE);\r\naup->rx_head = (aup->rx_head + 1) & (NUM_RX_DMA - 1);\r\nwmb();\r\nprxd = aup->rx_dma_ring[aup->rx_head];\r\nbuff_stat = prxd->buff_stat;\r\n}\r\nreturn 0;\r\n}\r\nstatic void au1000_update_tx_stats(struct net_device *dev, u32 status)\r\n{\r\nstruct au1000_private *aup = netdev_priv(dev);\r\nstruct net_device_stats *ps = &dev->stats;\r\nif (status & TX_FRAME_ABORTED) {\r\nif (!aup->phy_dev || (DUPLEX_FULL == aup->phy_dev->duplex)) {\r\nif (status & (TX_JAB_TIMEOUT | TX_UNDERRUN)) {\r\nps->tx_errors++;\r\nps->tx_aborted_errors++;\r\n}\r\n} else {\r\nps->tx_errors++;\r\nps->tx_aborted_errors++;\r\nif (status & (TX_NO_CARRIER | TX_LOSS_CARRIER))\r\nps->tx_carrier_errors++;\r\n}\r\n}\r\n}\r\nstatic void au1000_tx_ack(struct net_device *dev)\r\n{\r\nstruct au1000_private *aup = netdev_priv(dev);\r\nstruct tx_dma *ptxd;\r\nptxd = aup->tx_dma_ring[aup->tx_tail];\r\nwhile (ptxd->buff_stat & TX_T_DONE) {\r\nau1000_update_tx_stats(dev, ptxd->status);\r\nptxd->buff_stat &= ~TX_T_DONE;\r\nptxd->len = 0;\r\nwmb();\r\naup->tx_tail = (aup->tx_tail + 1) & (NUM_TX_DMA - 1);\r\nptxd = aup->tx_dma_ring[aup->tx_tail];\r\nif (aup->tx_full) {\r\naup->tx_full = 0;\r\nnetif_wake_queue(dev);\r\n}\r\n}\r\n}\r\nstatic irqreturn_t au1000_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nau1000_rx(dev);\r\nau1000_tx_ack(dev);\r\nreturn IRQ_RETVAL(1);\r\n}\r\nstatic int au1000_open(struct net_device *dev)\r\n{\r\nint retval;\r\nstruct au1000_private *aup = netdev_priv(dev);\r\nnetif_dbg(aup, drv, dev, "open: dev=%p\n", dev);\r\nretval = request_irq(dev->irq, au1000_interrupt, 0,\r\ndev->name, dev);\r\nif (retval) {\r\nnetdev_err(dev, "unable to get IRQ %d\n", dev->irq);\r\nreturn retval;\r\n}\r\nretval = au1000_init(dev);\r\nif (retval) {\r\nnetdev_err(dev, "error in au1000_init\n");\r\nfree_irq(dev->irq, dev);\r\nreturn retval;\r\n}\r\nif (aup->phy_dev) {\r\naup->phy_dev->state = PHY_CHANGELINK;\r\nphy_start(aup->phy_dev);\r\n}\r\nnetif_start_queue(dev);\r\nnetif_dbg(aup, drv, dev, "open: Initialization done.\n");\r\nreturn 0;\r\n}\r\nstatic int au1000_close(struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nstruct au1000_private *const aup = netdev_priv(dev);\r\nnetif_dbg(aup, drv, dev, "close: dev=%p\n", dev);\r\nif (aup->phy_dev)\r\nphy_stop(aup->phy_dev);\r\nspin_lock_irqsave(&aup->lock, flags);\r\nau1000_reset_mac_unlocked(dev);\r\nnetif_stop_queue(dev);\r\nfree_irq(dev->irq, dev);\r\nspin_unlock_irqrestore(&aup->lock, flags);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t au1000_tx(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct au1000_private *aup = netdev_priv(dev);\r\nstruct net_device_stats *ps = &dev->stats;\r\nstruct tx_dma *ptxd;\r\nu32 buff_stat;\r\nstruct db_dest *pDB;\r\nint i;\r\nnetif_dbg(aup, tx_queued, dev, "tx: aup %x len=%d, data=%p, head %d\n",\r\n(unsigned)aup, skb->len,\r\nskb->data, aup->tx_head);\r\nptxd = aup->tx_dma_ring[aup->tx_head];\r\nbuff_stat = ptxd->buff_stat;\r\nif (buff_stat & TX_DMA_ENABLE) {\r\nnetif_stop_queue(dev);\r\naup->tx_full = 1;\r\nreturn NETDEV_TX_BUSY;\r\n} else if (buff_stat & TX_T_DONE) {\r\nau1000_update_tx_stats(dev, ptxd->status);\r\nptxd->len = 0;\r\n}\r\nif (aup->tx_full) {\r\naup->tx_full = 0;\r\nnetif_wake_queue(dev);\r\n}\r\npDB = aup->tx_db_inuse[aup->tx_head];\r\nskb_copy_from_linear_data(skb, (void *)pDB->vaddr, skb->len);\r\nif (skb->len < ETH_ZLEN) {\r\nfor (i = skb->len; i < ETH_ZLEN; i++)\r\n((char *)pDB->vaddr)[i] = 0;\r\nptxd->len = ETH_ZLEN;\r\n} else\r\nptxd->len = skb->len;\r\nps->tx_packets++;\r\nps->tx_bytes += ptxd->len;\r\nptxd->buff_stat = pDB->dma_addr | TX_DMA_ENABLE;\r\nwmb();\r\ndev_kfree_skb(skb);\r\naup->tx_head = (aup->tx_head + 1) & (NUM_TX_DMA - 1);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void au1000_tx_timeout(struct net_device *dev)\r\n{\r\nnetdev_err(dev, "au1000_tx_timeout: dev=%p\n", dev);\r\nau1000_reset_mac(dev);\r\nau1000_init(dev);\r\ndev->trans_start = jiffies;\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void au1000_multicast_list(struct net_device *dev)\r\n{\r\nstruct au1000_private *aup = netdev_priv(dev);\r\nu32 reg;\r\nnetif_dbg(aup, drv, dev, "%s: flags=%x\n", __func__, dev->flags);\r\nreg = readl(&aup->mac->control);\r\nif (dev->flags & IFF_PROMISC) {\r\nreg |= MAC_PROMISCUOUS;\r\n} else if ((dev->flags & IFF_ALLMULTI) ||\r\nnetdev_mc_count(dev) > MULTICAST_FILTER_LIMIT) {\r\nreg |= MAC_PASS_ALL_MULTI;\r\nreg &= ~MAC_PROMISCUOUS;\r\nnetdev_info(dev, "Pass all multicast\n");\r\n} else {\r\nstruct netdev_hw_addr *ha;\r\nu32 mc_filter[2];\r\nmc_filter[1] = mc_filter[0] = 0;\r\nnetdev_for_each_mc_addr(ha, dev)\r\nset_bit(ether_crc(ETH_ALEN, ha->addr)>>26,\r\n(long *)mc_filter);\r\nwritel(mc_filter[1], &aup->mac->multi_hash_high);\r\nwritel(mc_filter[0], &aup->mac->multi_hash_low);\r\nreg &= ~MAC_PROMISCUOUS;\r\nreg |= MAC_HASH_MODE;\r\n}\r\nwritel(reg, &aup->mac->control);\r\n}\r\nstatic int au1000_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct au1000_private *aup = netdev_priv(dev);\r\nif (!netif_running(dev))\r\nreturn -EINVAL;\r\nif (!aup->phy_dev)\r\nreturn -EINVAL;\r\nreturn phy_mii_ioctl(aup->phy_dev, rq, cmd);\r\n}\r\nstatic int au1000_probe(struct platform_device *pdev)\r\n{\r\nstruct au1000_private *aup = NULL;\r\nstruct au1000_eth_platform_data *pd;\r\nstruct net_device *dev = NULL;\r\nstruct db_dest *pDB, *pDBfree;\r\nint irq, i, err = 0;\r\nstruct resource *base, *macen, *macdma;\r\nbase = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!base) {\r\ndev_err(&pdev->dev, "failed to retrieve base register\n");\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nmacen = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!macen) {\r\ndev_err(&pdev->dev, "failed to retrieve MAC Enable register\n");\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "failed to retrieve IRQ\n");\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nmacdma = platform_get_resource(pdev, IORESOURCE_MEM, 2);\r\nif (!macdma) {\r\ndev_err(&pdev->dev, "failed to retrieve MACDMA registers\n");\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nif (!request_mem_region(base->start, resource_size(base),\r\npdev->name)) {\r\ndev_err(&pdev->dev, "failed to request memory region for base registers\n");\r\nerr = -ENXIO;\r\ngoto out;\r\n}\r\nif (!request_mem_region(macen->start, resource_size(macen),\r\npdev->name)) {\r\ndev_err(&pdev->dev, "failed to request memory region for MAC enable register\n");\r\nerr = -ENXIO;\r\ngoto err_request;\r\n}\r\nif (!request_mem_region(macdma->start, resource_size(macdma),\r\npdev->name)) {\r\ndev_err(&pdev->dev, "failed to request MACDMA memory region\n");\r\nerr = -ENXIO;\r\ngoto err_macdma;\r\n}\r\ndev = alloc_etherdev(sizeof(struct au1000_private));\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto err_alloc;\r\n}\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nplatform_set_drvdata(pdev, dev);\r\naup = netdev_priv(dev);\r\nspin_lock_init(&aup->lock);\r\naup->msg_enable = (au1000_debug < 4 ?\r\nAU1000_DEF_MSG_ENABLE : au1000_debug);\r\naup->vaddr = (u32)dma_alloc_noncoherent(NULL, MAX_BUF_SIZE *\r\n(NUM_TX_BUFFS + NUM_RX_BUFFS),\r\n&aup->dma_addr, 0);\r\nif (!aup->vaddr) {\r\ndev_err(&pdev->dev, "failed to allocate data buffers\n");\r\nerr = -ENOMEM;\r\ngoto err_vaddr;\r\n}\r\naup->mac = (struct mac_reg *)\r\nioremap_nocache(base->start, resource_size(base));\r\nif (!aup->mac) {\r\ndev_err(&pdev->dev, "failed to ioremap MAC registers\n");\r\nerr = -ENXIO;\r\ngoto err_remap1;\r\n}\r\naup->enable = (u32 *)ioremap_nocache(macen->start,\r\nresource_size(macen));\r\nif (!aup->enable) {\r\ndev_err(&pdev->dev, "failed to ioremap MAC enable register\n");\r\nerr = -ENXIO;\r\ngoto err_remap2;\r\n}\r\naup->mac_id = pdev->id;\r\naup->macdma = ioremap_nocache(macdma->start, resource_size(macdma));\r\nif (!aup->macdma) {\r\ndev_err(&pdev->dev, "failed to ioremap MACDMA registers\n");\r\nerr = -ENXIO;\r\ngoto err_remap3;\r\n}\r\nau1000_setup_hw_rings(aup, aup->macdma);\r\nwritel(0, aup->enable);\r\naup->mac_enabled = 0;\r\npd = dev_get_platdata(&pdev->dev);\r\nif (!pd) {\r\ndev_info(&pdev->dev, "no platform_data passed,"\r\n" PHY search on MAC0\n");\r\naup->phy1_search_mac0 = 1;\r\n} else {\r\nif (is_valid_ether_addr(pd->mac)) {\r\nmemcpy(dev->dev_addr, pd->mac, ETH_ALEN);\r\n} else {\r\neth_hw_addr_random(dev);\r\n}\r\naup->phy_static_config = pd->phy_static_config;\r\naup->phy_search_highest_addr = pd->phy_search_highest_addr;\r\naup->phy1_search_mac0 = pd->phy1_search_mac0;\r\naup->phy_addr = pd->phy_addr;\r\naup->phy_busid = pd->phy_busid;\r\naup->phy_irq = pd->phy_irq;\r\n}\r\nif (aup->phy_busid && aup->phy_busid > 0) {\r\ndev_err(&pdev->dev, "MAC0-associated PHY attached 2nd MACs MII bus not supported yet\n");\r\nerr = -ENODEV;\r\ngoto err_mdiobus_alloc;\r\n}\r\naup->mii_bus = mdiobus_alloc();\r\nif (aup->mii_bus == NULL) {\r\ndev_err(&pdev->dev, "failed to allocate mdiobus structure\n");\r\nerr = -ENOMEM;\r\ngoto err_mdiobus_alloc;\r\n}\r\naup->mii_bus->priv = dev;\r\naup->mii_bus->read = au1000_mdiobus_read;\r\naup->mii_bus->write = au1000_mdiobus_write;\r\naup->mii_bus->reset = au1000_mdiobus_reset;\r\naup->mii_bus->name = "au1000_eth_mii";\r\nsnprintf(aup->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x",\r\npdev->name, aup->mac_id);\r\naup->mii_bus->irq = kmalloc(sizeof(int)*PHY_MAX_ADDR, GFP_KERNEL);\r\nif (aup->mii_bus->irq == NULL) {\r\nerr = -ENOMEM;\r\ngoto err_out;\r\n}\r\nfor (i = 0; i < PHY_MAX_ADDR; ++i)\r\naup->mii_bus->irq[i] = PHY_POLL;\r\nif (aup->phy_static_config)\r\nif (aup->phy_irq && aup->phy_busid == aup->mac_id)\r\naup->mii_bus->irq[aup->phy_addr] = aup->phy_irq;\r\nerr = mdiobus_register(aup->mii_bus);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to register MDIO bus\n");\r\ngoto err_mdiobus_reg;\r\n}\r\nerr = au1000_mii_probe(dev);\r\nif (err != 0)\r\ngoto err_out;\r\npDBfree = NULL;\r\npDB = aup->db;\r\nfor (i = 0; i < (NUM_TX_BUFFS+NUM_RX_BUFFS); i++) {\r\npDB->pnext = pDBfree;\r\npDBfree = pDB;\r\npDB->vaddr = (u32 *)((unsigned)aup->vaddr + MAX_BUF_SIZE*i);\r\npDB->dma_addr = (dma_addr_t)virt_to_bus(pDB->vaddr);\r\npDB++;\r\n}\r\naup->pDBfree = pDBfree;\r\nerr = -ENODEV;\r\nfor (i = 0; i < NUM_RX_DMA; i++) {\r\npDB = au1000_GetFreeDB(aup);\r\nif (!pDB)\r\ngoto err_out;\r\naup->rx_dma_ring[i]->buff_stat = (unsigned)pDB->dma_addr;\r\naup->rx_db_inuse[i] = pDB;\r\n}\r\nerr = -ENODEV;\r\nfor (i = 0; i < NUM_TX_DMA; i++) {\r\npDB = au1000_GetFreeDB(aup);\r\nif (!pDB)\r\ngoto err_out;\r\naup->tx_dma_ring[i]->buff_stat = (unsigned)pDB->dma_addr;\r\naup->tx_dma_ring[i]->len = 0;\r\naup->tx_db_inuse[i] = pDB;\r\n}\r\ndev->base_addr = base->start;\r\ndev->irq = irq;\r\ndev->netdev_ops = &au1000_netdev_ops;\r\ndev->ethtool_ops = &au1000_ethtool_ops;\r\ndev->watchdog_timeo = ETH_TX_TIMEOUT;\r\nau1000_reset_mac(dev);\r\nerr = register_netdev(dev);\r\nif (err) {\r\nnetdev_err(dev, "Cannot register net device, aborting.\n");\r\ngoto err_out;\r\n}\r\nnetdev_info(dev, "Au1xx0 Ethernet found at 0x%lx, irq %d\n",\r\n(unsigned long)base->start, irq);\r\npr_info_once("%s version %s %s\n", DRV_NAME, DRV_VERSION, DRV_AUTHOR);\r\nreturn 0;\r\nerr_out:\r\nif (aup->mii_bus != NULL)\r\nmdiobus_unregister(aup->mii_bus);\r\nau1000_reset_mac(dev);\r\nfor (i = 0; i < NUM_RX_DMA; i++) {\r\nif (aup->rx_db_inuse[i])\r\nau1000_ReleaseDB(aup, aup->rx_db_inuse[i]);\r\n}\r\nfor (i = 0; i < NUM_TX_DMA; i++) {\r\nif (aup->tx_db_inuse[i])\r\nau1000_ReleaseDB(aup, aup->tx_db_inuse[i]);\r\n}\r\nerr_mdiobus_reg:\r\nmdiobus_free(aup->mii_bus);\r\nerr_mdiobus_alloc:\r\niounmap(aup->macdma);\r\nerr_remap3:\r\niounmap(aup->enable);\r\nerr_remap2:\r\niounmap(aup->mac);\r\nerr_remap1:\r\ndma_free_noncoherent(NULL, MAX_BUF_SIZE * (NUM_TX_BUFFS + NUM_RX_BUFFS),\r\n(void *)aup->vaddr, aup->dma_addr);\r\nerr_vaddr:\r\nfree_netdev(dev);\r\nerr_alloc:\r\nrelease_mem_region(macdma->start, resource_size(macdma));\r\nerr_macdma:\r\nrelease_mem_region(macen->start, resource_size(macen));\r\nerr_request:\r\nrelease_mem_region(base->start, resource_size(base));\r\nout:\r\nreturn err;\r\n}\r\nstatic int au1000_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nstruct au1000_private *aup = netdev_priv(dev);\r\nint i;\r\nstruct resource *base, *macen;\r\nunregister_netdev(dev);\r\nmdiobus_unregister(aup->mii_bus);\r\nmdiobus_free(aup->mii_bus);\r\nfor (i = 0; i < NUM_RX_DMA; i++)\r\nif (aup->rx_db_inuse[i])\r\nau1000_ReleaseDB(aup, aup->rx_db_inuse[i]);\r\nfor (i = 0; i < NUM_TX_DMA; i++)\r\nif (aup->tx_db_inuse[i])\r\nau1000_ReleaseDB(aup, aup->tx_db_inuse[i]);\r\ndma_free_noncoherent(NULL, MAX_BUF_SIZE *\r\n(NUM_TX_BUFFS + NUM_RX_BUFFS),\r\n(void *)aup->vaddr, aup->dma_addr);\r\niounmap(aup->macdma);\r\niounmap(aup->mac);\r\niounmap(aup->enable);\r\nbase = platform_get_resource(pdev, IORESOURCE_MEM, 2);\r\nrelease_mem_region(base->start, resource_size(base));\r\nbase = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(base->start, resource_size(base));\r\nmacen = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nrelease_mem_region(macen->start, resource_size(macen));\r\nfree_netdev(dev);\r\nreturn 0;\r\n}
