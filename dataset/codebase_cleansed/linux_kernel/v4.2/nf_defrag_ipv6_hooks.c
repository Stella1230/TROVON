static enum ip6_defrag_users nf_ct6_defrag_user(unsigned int hooknum,\r\nstruct sk_buff *skb)\r\n{\r\nu16 zone = NF_CT_DEFAULT_ZONE;\r\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\r\nif (skb->nfct)\r\nzone = nf_ct_zone((struct nf_conn *)skb->nfct);\r\n#endif\r\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\r\nif (skb->nf_bridge &&\r\nskb->nf_bridge->mask & BRNF_NF_BRIDGE_PREROUTING)\r\nreturn IP6_DEFRAG_CONNTRACK_BRIDGE_IN + zone;\r\n#endif\r\nif (hooknum == NF_INET_PRE_ROUTING)\r\nreturn IP6_DEFRAG_CONNTRACK_IN + zone;\r\nelse\r\nreturn IP6_DEFRAG_CONNTRACK_OUT + zone;\r\n}\r\nstatic unsigned int ipv6_defrag(const struct nf_hook_ops *ops,\r\nstruct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nstruct sk_buff *reasm;\r\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\r\nif (skb->nfct && !nf_ct_is_template((struct nf_conn *)skb->nfct))\r\nreturn NF_ACCEPT;\r\n#endif\r\nreasm = nf_ct_frag6_gather(skb, nf_ct6_defrag_user(ops->hooknum, skb));\r\nif (reasm == NULL)\r\nreturn NF_STOLEN;\r\nif (reasm == skb)\r\nreturn NF_ACCEPT;\r\nnf_ct_frag6_consume_orig(reasm);\r\nNF_HOOK_THRESH(NFPROTO_IPV6, ops->hooknum, state->sk, reasm,\r\nstate->in, state->out,\r\nstate->okfn, NF_IP6_PRI_CONNTRACK_DEFRAG + 1);\r\nreturn NF_STOLEN;\r\n}\r\nstatic int __init nf_defrag_init(void)\r\n{\r\nint ret = 0;\r\nret = nf_ct_frag6_init();\r\nif (ret < 0) {\r\npr_err("nf_defrag_ipv6: can't initialize frag6.\n");\r\nreturn ret;\r\n}\r\nret = nf_register_hooks(ipv6_defrag_ops, ARRAY_SIZE(ipv6_defrag_ops));\r\nif (ret < 0) {\r\npr_err("nf_defrag_ipv6: can't register hooks\n");\r\ngoto cleanup_frag6;\r\n}\r\nreturn ret;\r\ncleanup_frag6:\r\nnf_ct_frag6_cleanup();\r\nreturn ret;\r\n}\r\nstatic void __exit nf_defrag_fini(void)\r\n{\r\nnf_unregister_hooks(ipv6_defrag_ops, ARRAY_SIZE(ipv6_defrag_ops));\r\nnf_ct_frag6_cleanup();\r\n}\r\nvoid nf_defrag_ipv6_enable(void)\r\n{\r\n}
