static int sun9i_mmc_reset_assert(struct reset_controller_dev *rcdev,\r\nunsigned long id)\r\n{\r\nstruct sun9i_mmc_clk_data *data = container_of(rcdev,\r\nstruct sun9i_mmc_clk_data,\r\nrcdev);\r\nunsigned long flags;\r\nvoid __iomem *reg = data->membase + SUN9I_MMC_WIDTH * id;\r\nu32 val;\r\nclk_prepare_enable(data->clk);\r\nspin_lock_irqsave(&data->lock, flags);\r\nval = readl(reg);\r\nwritel(val & ~BIT(SUN9I_MMC_RESET_BIT), reg);\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nclk_disable_unprepare(data->clk);\r\nreturn 0;\r\n}\r\nstatic int sun9i_mmc_reset_deassert(struct reset_controller_dev *rcdev,\r\nunsigned long id)\r\n{\r\nstruct sun9i_mmc_clk_data *data = container_of(rcdev,\r\nstruct sun9i_mmc_clk_data,\r\nrcdev);\r\nunsigned long flags;\r\nvoid __iomem *reg = data->membase + SUN9I_MMC_WIDTH * id;\r\nu32 val;\r\nclk_prepare_enable(data->clk);\r\nspin_lock_irqsave(&data->lock, flags);\r\nval = readl(reg);\r\nwritel(val | BIT(SUN9I_MMC_RESET_BIT), reg);\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nclk_disable_unprepare(data->clk);\r\nreturn 0;\r\n}\r\nstatic int sun9i_a80_mmc_config_clk_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct sun9i_mmc_clk_data *data;\r\nstruct clk_onecell_data *clk_data;\r\nconst char *clk_name = np->name;\r\nconst char *clk_parent;\r\nstruct resource *r;\r\nint count, i, ret;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nspin_lock_init(&data->lock);\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ncount = DIV_ROUND_UP((r->end - r->start + 1), SUN9I_MMC_WIDTH);\r\ndata->membase = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(data->membase))\r\nreturn PTR_ERR(data->membase);\r\nclk_data = &data->clk_data;\r\nclk_data->clk_num = count;\r\nclk_data->clks = devm_kcalloc(&pdev->dev, count, sizeof(struct clk *),\r\nGFP_KERNEL);\r\nif (!clk_data->clks)\r\nreturn -ENOMEM;\r\ndata->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(data->clk)) {\r\ndev_err(&pdev->dev, "Could not get clock\n");\r\nreturn PTR_ERR(data->clk);\r\n}\r\ndata->reset = devm_reset_control_get(&pdev->dev, NULL);\r\nif (IS_ERR(data->reset)) {\r\ndev_err(&pdev->dev, "Could not get reset control\n");\r\nreturn PTR_ERR(data->reset);\r\n}\r\nret = reset_control_deassert(data->reset);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Reset deassert err %d\n", ret);\r\nreturn ret;\r\n}\r\nclk_parent = __clk_get_name(data->clk);\r\nfor (i = 0; i < count; i++) {\r\nof_property_read_string_index(np, "clock-output-names",\r\ni, &clk_name);\r\nclk_data->clks[i] = clk_register_gate(&pdev->dev, clk_name,\r\nclk_parent, 0,\r\ndata->membase + SUN9I_MMC_WIDTH * i,\r\nSUN9I_MMC_GATE_BIT, 0,\r\n&data->lock);\r\nif (IS_ERR(clk_data->clks[i])) {\r\nret = PTR_ERR(clk_data->clks[i]);\r\ngoto err_clk_register;\r\n}\r\n}\r\nret = of_clk_add_provider(np, of_clk_src_onecell_get, clk_data);\r\nif (ret)\r\ngoto err_clk_provider;\r\ndata->rcdev.owner = THIS_MODULE;\r\ndata->rcdev.nr_resets = count;\r\ndata->rcdev.ops = &sun9i_mmc_reset_ops;\r\ndata->rcdev.of_node = pdev->dev.of_node;\r\nret = reset_controller_register(&data->rcdev);\r\nif (ret)\r\ngoto err_rc_reg;\r\nplatform_set_drvdata(pdev, data);\r\nreturn 0;\r\nerr_rc_reg:\r\nof_clk_del_provider(np);\r\nerr_clk_provider:\r\nfor (i = 0; i < count; i++)\r\nclk_unregister(clk_data->clks[i]);\r\nerr_clk_register:\r\nreset_control_assert(data->reset);\r\nreturn ret;\r\n}\r\nstatic int sun9i_a80_mmc_config_clk_remove(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct sun9i_mmc_clk_data *data = platform_get_drvdata(pdev);\r\nstruct clk_onecell_data *clk_data = &data->clk_data;\r\nint i;\r\nreset_controller_unregister(&data->rcdev);\r\nof_clk_del_provider(np);\r\nfor (i = 0; i < clk_data->clk_num; i++)\r\nclk_unregister(clk_data->clks[i]);\r\nreset_control_assert(data->reset);\r\nreturn 0;\r\n}
