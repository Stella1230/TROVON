static int abx80x_enable_trickle_charger(struct i2c_client *client,\r\nu8 trickle_cfg)\r\n{\r\nint err;\r\nerr = i2c_smbus_write_byte_data(client, ABX8XX_REG_CFG_KEY,\r\nABX8XX_CFG_KEY_MISC);\r\nif (err < 0) {\r\ndev_err(&client->dev, "Unable to write configuration key\n");\r\nreturn -EIO;\r\n}\r\nerr = i2c_smbus_write_byte_data(client, ABX8XX_REG_TRICKLE,\r\nABX8XX_TRICKLE_CHARGE_ENABLE |\r\ntrickle_cfg);\r\nif (err < 0) {\r\ndev_err(&client->dev, "Unable to write trickle register\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int abx80x_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nunsigned char buf[8];\r\nint err;\r\nerr = i2c_smbus_read_i2c_block_data(client, ABX8XX_REG_HTH,\r\nsizeof(buf), buf);\r\nif (err < 0) {\r\ndev_err(&client->dev, "Unable to read date\n");\r\nreturn -EIO;\r\n}\r\ntm->tm_sec = bcd2bin(buf[ABX8XX_REG_SC] & 0x7F);\r\ntm->tm_min = bcd2bin(buf[ABX8XX_REG_MN] & 0x7F);\r\ntm->tm_hour = bcd2bin(buf[ABX8XX_REG_HR] & 0x3F);\r\ntm->tm_wday = buf[ABX8XX_REG_WD] & 0x7;\r\ntm->tm_mday = bcd2bin(buf[ABX8XX_REG_DA] & 0x3F);\r\ntm->tm_mon = bcd2bin(buf[ABX8XX_REG_MO] & 0x1F) - 1;\r\ntm->tm_year = bcd2bin(buf[ABX8XX_REG_YR]) + 100;\r\nerr = rtc_valid_tm(tm);\r\nif (err < 0)\r\ndev_err(&client->dev, "retrieved date/time is not valid.\n");\r\nreturn err;\r\n}\r\nstatic int abx80x_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nunsigned char buf[8];\r\nint err;\r\nif (tm->tm_year < 100)\r\nreturn -EINVAL;\r\nbuf[ABX8XX_REG_HTH] = 0;\r\nbuf[ABX8XX_REG_SC] = bin2bcd(tm->tm_sec);\r\nbuf[ABX8XX_REG_MN] = bin2bcd(tm->tm_min);\r\nbuf[ABX8XX_REG_HR] = bin2bcd(tm->tm_hour);\r\nbuf[ABX8XX_REG_DA] = bin2bcd(tm->tm_mday);\r\nbuf[ABX8XX_REG_MO] = bin2bcd(tm->tm_mon + 1);\r\nbuf[ABX8XX_REG_YR] = bin2bcd(tm->tm_year - 100);\r\nbuf[ABX8XX_REG_WD] = tm->tm_wday;\r\nerr = i2c_smbus_write_i2c_block_data(client, ABX8XX_REG_HTH,\r\nsizeof(buf), buf);\r\nif (err < 0) {\r\ndev_err(&client->dev, "Unable to write to date registers\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int abx80x_dt_trickle_cfg(struct device_node *np)\r\n{\r\nconst char *diode;\r\nint trickle_cfg = 0;\r\nint i, ret;\r\nu32 tmp;\r\nret = of_property_read_string(np, "abracon,tc-diode", &diode);\r\nif (ret)\r\nreturn ret;\r\nif (!strcmp(diode, "standard"))\r\ntrickle_cfg |= ABX8XX_TRICKLE_STANDARD_DIODE;\r\nelse if (!strcmp(diode, "schottky"))\r\ntrickle_cfg |= ABX8XX_TRICKLE_SCHOTTKY_DIODE;\r\nelse\r\nreturn -EINVAL;\r\nret = of_property_read_u32(np, "abracon,tc-resistor", &tmp);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < sizeof(trickle_resistors); i++)\r\nif (trickle_resistors[i] == tmp)\r\nbreak;\r\nif (i == sizeof(trickle_resistors))\r\nreturn -EINVAL;\r\nreturn (trickle_cfg | i);\r\n}\r\nstatic int abx80x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device_node *np = client->dev.of_node;\r\nstruct rtc_device *rtc;\r\nint i, data, err, trickle_cfg = -EINVAL;\r\nchar buf[7];\r\nunsigned int part = id->driver_data;\r\nunsigned int partnumber;\r\nunsigned int majrev, minrev;\r\nunsigned int lot;\r\nunsigned int wafer;\r\nunsigned int uid;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\r\nreturn -ENODEV;\r\nerr = i2c_smbus_read_i2c_block_data(client, ABX8XX_REG_ID0,\r\nsizeof(buf), buf);\r\nif (err < 0) {\r\ndev_err(&client->dev, "Unable to read partnumber\n");\r\nreturn -EIO;\r\n}\r\npartnumber = (buf[0] << 8) | buf[1];\r\nmajrev = buf[2] >> 3;\r\nminrev = buf[2] & 0x7;\r\nlot = ((buf[4] & 0x80) << 2) | ((buf[6] & 0x80) << 1) | buf[3];\r\nuid = ((buf[4] & 0x7f) << 8) | buf[5];\r\nwafer = (buf[6] & 0x7c) >> 2;\r\ndev_info(&client->dev, "model %04x, revision %u.%u, lot %x, wafer %x, uid %x\n",\r\npartnumber, majrev, minrev, lot, wafer, uid);\r\ndata = i2c_smbus_read_byte_data(client, ABX8XX_REG_CTRL1);\r\nif (data < 0) {\r\ndev_err(&client->dev, "Unable to read control register\n");\r\nreturn -EIO;\r\n}\r\nerr = i2c_smbus_write_byte_data(client, ABX8XX_REG_CTRL1,\r\n((data & ~ABX8XX_CTRL_12_24) |\r\nABX8XX_CTRL_WRITE));\r\nif (err < 0) {\r\ndev_err(&client->dev, "Unable to write control register\n");\r\nreturn -EIO;\r\n}\r\nif (part == ABX80X) {\r\nfor (i = 0; abx80x_caps[i].pn; i++)\r\nif (partnumber == abx80x_caps[i].pn)\r\nbreak;\r\nif (abx80x_caps[i].pn == 0) {\r\ndev_err(&client->dev, "Unknown part: %04x\n",\r\npartnumber);\r\nreturn -EINVAL;\r\n}\r\npart = i;\r\n}\r\nif (partnumber != abx80x_caps[part].pn) {\r\ndev_err(&client->dev, "partnumber mismatch %04x != %04x\n",\r\npartnumber, abx80x_caps[part].pn);\r\nreturn -EINVAL;\r\n}\r\nif (np && abx80x_caps[part].has_tc)\r\ntrickle_cfg = abx80x_dt_trickle_cfg(np);\r\nif (trickle_cfg > 0) {\r\ndev_info(&client->dev, "Enabling trickle charger: %02x\n",\r\ntrickle_cfg);\r\nabx80x_enable_trickle_charger(client, trickle_cfg);\r\n}\r\nrtc = devm_rtc_device_register(&client->dev, abx80x_driver.driver.name,\r\n&abx80x_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rtc))\r\nreturn PTR_ERR(rtc);\r\ni2c_set_clientdata(client, rtc);\r\nreturn 0;\r\n}\r\nstatic int abx80x_remove(struct i2c_client *client)\r\n{\r\nreturn 0;\r\n}
