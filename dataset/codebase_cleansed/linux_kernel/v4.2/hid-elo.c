static void elo_input_configured(struct hid_device *hdev,\r\nstruct hid_input *hidinput)\r\n{\r\nstruct input_dev *input = hidinput->input;\r\nset_bit(BTN_TOUCH, input->keybit);\r\nset_bit(ABS_PRESSURE, input->absbit);\r\ninput_set_abs_params(input, ABS_PRESSURE, 0, 256, 0, 0);\r\n}\r\nstatic void elo_process_data(struct input_dev *input, const u8 *data, int size)\r\n{\r\nint press;\r\ninput_report_abs(input, ABS_X, (data[3] << 8) | data[2]);\r\ninput_report_abs(input, ABS_Y, (data[5] << 8) | data[4]);\r\npress = 0;\r\nif (data[1] & 0x80)\r\npress = (data[7] << 8) | data[6];\r\ninput_report_abs(input, ABS_PRESSURE, press);\r\nif (data[1] & 0x03) {\r\ninput_report_key(input, BTN_TOUCH, 1);\r\ninput_sync(input);\r\n}\r\nif (data[1] & 0x04)\r\ninput_report_key(input, BTN_TOUCH, 0);\r\ninput_sync(input);\r\n}\r\nstatic int elo_raw_event(struct hid_device *hdev, struct hid_report *report,\r\nu8 *data, int size)\r\n{\r\nstruct hid_input *hidinput;\r\nif (!(hdev->claimed & HID_CLAIMED_INPUT) || list_empty(&hdev->inputs))\r\nreturn 0;\r\nhidinput = list_first_entry(&hdev->inputs, struct hid_input, list);\r\nswitch (report->id) {\r\ncase 0:\r\nif (data[0] == 'T') {\r\nelo_process_data(hidinput->input, data, size);\r\nreturn 1;\r\n}\r\nbreak;\r\ndefault:\r\nhid_info(hdev, "unknown report type %d\n", report->id);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int elo_smartset_send_get(struct usb_device *dev, u8 command,\r\nvoid *data)\r\n{\r\nunsigned int pipe;\r\nu8 dir;\r\nif (command == ELO_SEND_SMARTSET_COMMAND) {\r\npipe = usb_sndctrlpipe(dev, 0);\r\ndir = USB_DIR_OUT;\r\n} else if (command == ELO_GET_SMARTSET_RESPONSE) {\r\npipe = usb_rcvctrlpipe(dev, 0);\r\ndir = USB_DIR_IN;\r\n} else\r\nreturn -EINVAL;\r\nreturn usb_control_msg(dev, pipe, command,\r\ndir | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0, 0, data, ELO_SMARTSET_PACKET_SIZE,\r\nELO_SMARTSET_CMD_TIMEOUT);\r\n}\r\nstatic int elo_flush_smartset_responses(struct usb_device *dev)\r\n{\r\nreturn usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\nELO_FLUSH_SMARTSET_RESPONSES,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0, 0, NULL, 0, USB_CTRL_SET_TIMEOUT);\r\n}\r\nstatic void elo_work(struct work_struct *work)\r\n{\r\nstruct elo_priv *priv = container_of(work, struct elo_priv, work.work);\r\nstruct usb_device *dev = priv->usbdev;\r\nunsigned char *buffer = priv->buffer;\r\nint ret;\r\nret = elo_flush_smartset_responses(dev);\r\nif (ret < 0) {\r\ndev_err(&dev->dev, "initial FLUSH_SMARTSET_RESPONSES failed, error %d\n",\r\nret);\r\ngoto fail;\r\n}\r\n*buffer = ELO_DIAG;\r\nret = elo_smartset_send_get(dev, ELO_SEND_SMARTSET_COMMAND, buffer);\r\nif (ret < 0) {\r\ndev_err(&dev->dev, "send Diagnostics Command failed, error %d\n",\r\nret);\r\ngoto fail;\r\n}\r\nret = elo_smartset_send_get(dev, ELO_GET_SMARTSET_RESPONSE, buffer);\r\nif (ret < 0) {\r\ndev_err(&dev->dev, "get Diagnostics Command response failed, error %d\n",\r\nret);\r\ngoto fail;\r\n}\r\nif (*buffer != 'A') {\r\nret = elo_smartset_send_get(dev, ELO_GET_SMARTSET_RESPONSE,\r\nbuffer);\r\nif (ret < 0) {\r\ndev_err(&dev->dev, "get acknowledge response failed, error %d\n",\r\nret);\r\ngoto fail;\r\n}\r\n}\r\nfail:\r\nret = elo_flush_smartset_responses(dev);\r\nif (ret < 0)\r\ndev_err(&dev->dev, "final FLUSH_SMARTSET_RESPONSES failed, error %d\n",\r\nret);\r\nqueue_delayed_work(wq, &priv->work, ELO_PERIODIC_READ_INTERVAL);\r\n}\r\nstatic bool elo_broken_firmware(struct usb_device *dev)\r\n{\r\nstruct usb_device *hub = dev->parent;\r\nstruct usb_device *child = NULL;\r\nu16 fw_lvl = le16_to_cpu(dev->descriptor.bcdDevice);\r\nu16 child_vid, child_pid;\r\nint i;\r\nif (!use_fw_quirk)\r\nreturn false;\r\nif (fw_lvl != 0x10d)\r\nreturn false;\r\nusb_hub_for_each_child(hub, i, child) {\r\nchild_vid = le16_to_cpu(child->descriptor.idVendor);\r\nchild_pid = le16_to_cpu(child->descriptor.idProduct);\r\nif (child_vid==0x04b3) {\r\nswitch (child_pid) {\r\ncase 0x4676:\r\ncase 0x4677:\r\ncase 0x4678:\r\ncase 0x4679:\r\nreturn false;\r\n}\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic int elo_probe(struct hid_device *hdev, const struct hid_device_id *id)\r\n{\r\nstruct elo_priv *priv;\r\nint ret;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nINIT_DELAYED_WORK(&priv->work, elo_work);\r\npriv->usbdev = interface_to_usbdev(to_usb_interface(hdev->dev.parent));\r\nhid_set_drvdata(hdev, priv);\r\nret = hid_parse(hdev);\r\nif (ret) {\r\nhid_err(hdev, "parse failed\n");\r\ngoto err_free;\r\n}\r\nret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\r\nif (ret) {\r\nhid_err(hdev, "hw start failed\n");\r\ngoto err_free;\r\n}\r\nif (elo_broken_firmware(priv->usbdev)) {\r\nhid_info(hdev, "broken firmware found, installing workaround\n");\r\nqueue_delayed_work(wq, &priv->work, ELO_PERIODIC_READ_INTERVAL);\r\n}\r\nreturn 0;\r\nerr_free:\r\nkfree(priv);\r\nreturn ret;\r\n}\r\nstatic void elo_remove(struct hid_device *hdev)\r\n{\r\nstruct elo_priv *priv = hid_get_drvdata(hdev);\r\nhid_hw_stop(hdev);\r\nflush_workqueue(wq);\r\nkfree(priv);\r\n}\r\nstatic int __init elo_driver_init(void)\r\n{\r\nint ret;\r\nwq = create_singlethread_workqueue("elousb");\r\nif (!wq)\r\nreturn -ENOMEM;\r\nret = hid_register_driver(&elo_driver);\r\nif (ret)\r\ndestroy_workqueue(wq);\r\nreturn ret;\r\n}\r\nstatic void __exit elo_driver_exit(void)\r\n{\r\nhid_unregister_driver(&elo_driver);\r\ndestroy_workqueue(wq);\r\n}
