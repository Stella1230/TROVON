static void __check_vhtcap_disable(struct ieee80211_sub_if_data *sdata,\r\nstruct ieee80211_sta_vht_cap *vht_cap,\r\nu32 flag)\r\n{\r\n__le32 le_flag = cpu_to_le32(flag);\r\nif (sdata->u.mgd.vht_capa_mask.vht_cap_info & le_flag &&\r\n!(sdata->u.mgd.vht_capa.vht_cap_info & le_flag))\r\nvht_cap->cap &= ~flag;\r\n}\r\nvoid ieee80211_apply_vhtcap_overrides(struct ieee80211_sub_if_data *sdata,\r\nstruct ieee80211_sta_vht_cap *vht_cap)\r\n{\r\nint i;\r\nu16 rxmcs_mask, rxmcs_cap, rxmcs_n, txmcs_mask, txmcs_cap, txmcs_n;\r\nif (!vht_cap->vht_supported)\r\nreturn;\r\nif (sdata->vif.type != NL80211_IFTYPE_STATION)\r\nreturn;\r\n__check_vhtcap_disable(sdata, vht_cap,\r\nIEEE80211_VHT_CAP_RXLDPC);\r\n__check_vhtcap_disable(sdata, vht_cap,\r\nIEEE80211_VHT_CAP_SHORT_GI_80);\r\n__check_vhtcap_disable(sdata, vht_cap,\r\nIEEE80211_VHT_CAP_SHORT_GI_160);\r\n__check_vhtcap_disable(sdata, vht_cap,\r\nIEEE80211_VHT_CAP_TXSTBC);\r\n__check_vhtcap_disable(sdata, vht_cap,\r\nIEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE);\r\n__check_vhtcap_disable(sdata, vht_cap,\r\nIEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE);\r\n__check_vhtcap_disable(sdata, vht_cap,\r\nIEEE80211_VHT_CAP_RX_ANTENNA_PATTERN);\r\n__check_vhtcap_disable(sdata, vht_cap,\r\nIEEE80211_VHT_CAP_TX_ANTENNA_PATTERN);\r\nif (sdata->u.mgd.vht_capa_mask.vht_cap_info &\r\ncpu_to_le32(IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK)) {\r\nu32 cap, n;\r\nn = le32_to_cpu(sdata->u.mgd.vht_capa.vht_cap_info) &\r\nIEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK;\r\nn >>= IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT;\r\ncap = vht_cap->cap & IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK;\r\ncap >>= IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT;\r\nif (n < cap) {\r\nvht_cap->cap &=\r\n~IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK;\r\nvht_cap->cap |=\r\nn << IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT;\r\n}\r\n}\r\nrxmcs_mask =\r\nle16_to_cpu(sdata->u.mgd.vht_capa_mask.supp_mcs.rx_mcs_map);\r\nrxmcs_n = le16_to_cpu(sdata->u.mgd.vht_capa.supp_mcs.rx_mcs_map);\r\nrxmcs_n &= rxmcs_mask;\r\nrxmcs_cap = le16_to_cpu(vht_cap->vht_mcs.rx_mcs_map);\r\ntxmcs_mask =\r\nle16_to_cpu(sdata->u.mgd.vht_capa_mask.supp_mcs.tx_mcs_map);\r\ntxmcs_n = le16_to_cpu(sdata->u.mgd.vht_capa.supp_mcs.tx_mcs_map);\r\ntxmcs_n &= txmcs_mask;\r\ntxmcs_cap = le16_to_cpu(vht_cap->vht_mcs.tx_mcs_map);\r\nfor (i = 0; i < 8; i++) {\r\nu8 m, n, c;\r\nm = (rxmcs_mask >> 2*i) & IEEE80211_VHT_MCS_NOT_SUPPORTED;\r\nn = (rxmcs_n >> 2*i) & IEEE80211_VHT_MCS_NOT_SUPPORTED;\r\nc = (rxmcs_cap >> 2*i) & IEEE80211_VHT_MCS_NOT_SUPPORTED;\r\nif (m && ((c != IEEE80211_VHT_MCS_NOT_SUPPORTED && n < c) ||\r\nn == IEEE80211_VHT_MCS_NOT_SUPPORTED)) {\r\nrxmcs_cap &= ~(3 << 2*i);\r\nrxmcs_cap |= (rxmcs_n & (3 << 2*i));\r\n}\r\nm = (txmcs_mask >> 2*i) & IEEE80211_VHT_MCS_NOT_SUPPORTED;\r\nn = (txmcs_n >> 2*i) & IEEE80211_VHT_MCS_NOT_SUPPORTED;\r\nc = (txmcs_cap >> 2*i) & IEEE80211_VHT_MCS_NOT_SUPPORTED;\r\nif (m && ((c != IEEE80211_VHT_MCS_NOT_SUPPORTED && n < c) ||\r\nn == IEEE80211_VHT_MCS_NOT_SUPPORTED)) {\r\ntxmcs_cap &= ~(3 << 2*i);\r\ntxmcs_cap |= (txmcs_n & (3 << 2*i));\r\n}\r\n}\r\nvht_cap->vht_mcs.rx_mcs_map = cpu_to_le16(rxmcs_cap);\r\nvht_cap->vht_mcs.tx_mcs_map = cpu_to_le16(txmcs_cap);\r\n}\r\nvoid\r\nieee80211_vht_cap_ie_to_sta_vht_cap(struct ieee80211_sub_if_data *sdata,\r\nstruct ieee80211_supported_band *sband,\r\nconst struct ieee80211_vht_cap *vht_cap_ie,\r\nstruct sta_info *sta)\r\n{\r\nstruct ieee80211_sta_vht_cap *vht_cap = &sta->sta.vht_cap;\r\nstruct ieee80211_sta_vht_cap own_cap;\r\nu32 cap_info, i;\r\nmemset(vht_cap, 0, sizeof(*vht_cap));\r\nif (!sta->sta.ht_cap.ht_supported)\r\nreturn;\r\nif (!vht_cap_ie || !sband->vht_cap.vht_supported)\r\nreturn;\r\nvht_cap->vht_supported = true;\r\nown_cap = sband->vht_cap;\r\nif (sdata->vif.type == NL80211_IFTYPE_STATION &&\r\n!test_sta_flag(sta, WLAN_STA_TDLS_PEER))\r\nieee80211_apply_vhtcap_overrides(sdata, &own_cap);\r\ncap_info = le32_to_cpu(vht_cap_ie->vht_cap_info);\r\nvht_cap->cap = cap_info;\r\nvht_cap->cap &= IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_3895 |\r\nIEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991 |\r\nIEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454 |\r\nIEEE80211_VHT_CAP_RXLDPC |\r\nIEEE80211_VHT_CAP_VHT_TXOP_PS |\r\nIEEE80211_VHT_CAP_HTC_VHT |\r\nIEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK |\r\nIEEE80211_VHT_CAP_VHT_LINK_ADAPTATION_VHT_UNSOL_MFB |\r\nIEEE80211_VHT_CAP_VHT_LINK_ADAPTATION_VHT_MRQ_MFB |\r\nIEEE80211_VHT_CAP_RX_ANTENNA_PATTERN |\r\nIEEE80211_VHT_CAP_TX_ANTENNA_PATTERN;\r\nswitch (own_cap.cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK) {\r\ncase IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ:\r\nvht_cap->cap |= cap_info &\r\nIEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ;\r\nbreak;\r\ncase IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ:\r\nvht_cap->cap |= cap_info &\r\nIEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nvht_cap->cap |= cap_info & own_cap.cap &\r\n(IEEE80211_VHT_CAP_SHORT_GI_80 |\r\nIEEE80211_VHT_CAP_SHORT_GI_160);\r\nif (own_cap.cap & IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE)\r\nvht_cap->cap |= cap_info &\r\n(IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE |\r\nIEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_MASK);\r\nif (own_cap.cap & IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE)\r\nvht_cap->cap |= cap_info &\r\n(IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE |\r\nIEEE80211_VHT_CAP_BEAMFORMEE_STS_MASK);\r\nif (own_cap.cap & IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE)\r\nvht_cap->cap |= cap_info &\r\nIEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE;\r\nif (own_cap.cap & IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE)\r\nvht_cap->cap |= cap_info &\r\nIEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE;\r\nif (own_cap.cap & IEEE80211_VHT_CAP_TXSTBC)\r\nvht_cap->cap |= cap_info & IEEE80211_VHT_CAP_RXSTBC_MASK;\r\nif (own_cap.cap & IEEE80211_VHT_CAP_RXSTBC_MASK)\r\nvht_cap->cap |= cap_info & IEEE80211_VHT_CAP_TXSTBC;\r\nmemcpy(&vht_cap->vht_mcs, &vht_cap_ie->supp_mcs,\r\nsizeof(struct ieee80211_vht_mcs_info));\r\nfor (i = 0; i < 8; i++) {\r\nu16 own_rx, own_tx, peer_rx, peer_tx;\r\nown_rx = le16_to_cpu(own_cap.vht_mcs.rx_mcs_map);\r\nown_rx = (own_rx >> i * 2) & IEEE80211_VHT_MCS_NOT_SUPPORTED;\r\nown_tx = le16_to_cpu(own_cap.vht_mcs.tx_mcs_map);\r\nown_tx = (own_tx >> i * 2) & IEEE80211_VHT_MCS_NOT_SUPPORTED;\r\npeer_rx = le16_to_cpu(vht_cap->vht_mcs.rx_mcs_map);\r\npeer_rx = (peer_rx >> i * 2) & IEEE80211_VHT_MCS_NOT_SUPPORTED;\r\npeer_tx = le16_to_cpu(vht_cap->vht_mcs.tx_mcs_map);\r\npeer_tx = (peer_tx >> i * 2) & IEEE80211_VHT_MCS_NOT_SUPPORTED;\r\nif (peer_tx != IEEE80211_VHT_MCS_NOT_SUPPORTED) {\r\nif (own_rx == IEEE80211_VHT_MCS_NOT_SUPPORTED)\r\npeer_tx = IEEE80211_VHT_MCS_NOT_SUPPORTED;\r\nelse if (own_rx < peer_tx)\r\npeer_tx = own_rx;\r\n}\r\nif (peer_rx != IEEE80211_VHT_MCS_NOT_SUPPORTED) {\r\nif (own_tx == IEEE80211_VHT_MCS_NOT_SUPPORTED)\r\npeer_rx = IEEE80211_VHT_MCS_NOT_SUPPORTED;\r\nelse if (own_tx < peer_rx)\r\npeer_rx = own_tx;\r\n}\r\nvht_cap->vht_mcs.rx_mcs_map &=\r\n~cpu_to_le16(IEEE80211_VHT_MCS_NOT_SUPPORTED << i * 2);\r\nvht_cap->vht_mcs.rx_mcs_map |= cpu_to_le16(peer_rx << i * 2);\r\nvht_cap->vht_mcs.tx_mcs_map &=\r\n~cpu_to_le16(IEEE80211_VHT_MCS_NOT_SUPPORTED << i * 2);\r\nvht_cap->vht_mcs.tx_mcs_map |= cpu_to_le16(peer_tx << i * 2);\r\n}\r\nswitch (vht_cap->cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK) {\r\ncase IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ:\r\ncase IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ:\r\nsta->cur_max_bandwidth = IEEE80211_STA_RX_BW_160;\r\nbreak;\r\ndefault:\r\nsta->cur_max_bandwidth = IEEE80211_STA_RX_BW_80;\r\n}\r\nsta->sta.bandwidth = ieee80211_sta_cur_vht_bw(sta);\r\n}\r\nenum ieee80211_sta_rx_bandwidth ieee80211_sta_cap_rx_bw(struct sta_info *sta)\r\n{\r\nstruct ieee80211_sta_vht_cap *vht_cap = &sta->sta.vht_cap;\r\nu32 cap_width;\r\nif (!vht_cap->vht_supported)\r\nreturn sta->sta.ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 ?\r\nIEEE80211_STA_RX_BW_40 :\r\nIEEE80211_STA_RX_BW_20;\r\ncap_width = vht_cap->cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK;\r\nif (cap_width == IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ ||\r\ncap_width == IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ)\r\nreturn IEEE80211_STA_RX_BW_160;\r\nreturn IEEE80211_STA_RX_BW_80;\r\n}\r\nstatic enum ieee80211_sta_rx_bandwidth\r\nieee80211_chan_width_to_rx_bw(enum nl80211_chan_width width)\r\n{\r\nswitch (width) {\r\ncase NL80211_CHAN_WIDTH_20_NOHT:\r\ncase NL80211_CHAN_WIDTH_20:\r\nreturn IEEE80211_STA_RX_BW_20;\r\ncase NL80211_CHAN_WIDTH_40:\r\nreturn IEEE80211_STA_RX_BW_40;\r\ncase NL80211_CHAN_WIDTH_80:\r\nreturn IEEE80211_STA_RX_BW_80;\r\ncase NL80211_CHAN_WIDTH_160:\r\ncase NL80211_CHAN_WIDTH_80P80:\r\nreturn IEEE80211_STA_RX_BW_160;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\nreturn IEEE80211_STA_RX_BW_20;\r\n}\r\n}\r\nenum ieee80211_sta_rx_bandwidth ieee80211_sta_cur_vht_bw(struct sta_info *sta)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nenum ieee80211_sta_rx_bandwidth bw;\r\nbw = ieee80211_chan_width_to_rx_bw(sdata->vif.bss_conf.chandef.width);\r\nbw = min(bw, ieee80211_sta_cap_rx_bw(sta));\r\nbw = min(bw, sta->cur_max_bandwidth);\r\nreturn bw;\r\n}\r\nvoid ieee80211_sta_set_rx_nss(struct sta_info *sta)\r\n{\r\nu8 ht_rx_nss = 0, vht_rx_nss = 0;\r\nif (sta->sta.rx_nss)\r\nreturn;\r\nif (sta->sta.ht_cap.ht_supported) {\r\nif (sta->sta.ht_cap.mcs.rx_mask[0])\r\nht_rx_nss++;\r\nif (sta->sta.ht_cap.mcs.rx_mask[1])\r\nht_rx_nss++;\r\nif (sta->sta.ht_cap.mcs.rx_mask[2])\r\nht_rx_nss++;\r\nif (sta->sta.ht_cap.mcs.rx_mask[3])\r\nht_rx_nss++;\r\n}\r\nif (sta->sta.vht_cap.vht_supported) {\r\nint i;\r\nu16 rx_mcs_map;\r\nrx_mcs_map = le16_to_cpu(sta->sta.vht_cap.vht_mcs.rx_mcs_map);\r\nfor (i = 7; i >= 0; i--) {\r\nu8 mcs = (rx_mcs_map >> (2 * i)) & 3;\r\nif (mcs != IEEE80211_VHT_MCS_NOT_SUPPORTED) {\r\nvht_rx_nss = i + 1;\r\nbreak;\r\n}\r\n}\r\n}\r\nht_rx_nss = max(ht_rx_nss, vht_rx_nss);\r\nsta->sta.rx_nss = max_t(u8, 1, ht_rx_nss);\r\n}\r\nu32 __ieee80211_vht_handle_opmode(struct ieee80211_sub_if_data *sdata,\r\nstruct sta_info *sta, u8 opmode,\r\nenum ieee80211_band band, bool nss_only)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct ieee80211_supported_band *sband;\r\nenum ieee80211_sta_rx_bandwidth new_bw;\r\nu32 changed = 0;\r\nu8 nss;\r\nsband = local->hw.wiphy->bands[band];\r\nif (opmode & IEEE80211_OPMODE_NOTIF_RX_NSS_TYPE_BF)\r\nreturn 0;\r\nnss = opmode & IEEE80211_OPMODE_NOTIF_RX_NSS_MASK;\r\nnss >>= IEEE80211_OPMODE_NOTIF_RX_NSS_SHIFT;\r\nnss += 1;\r\nif (sta->sta.rx_nss != nss) {\r\nsta->sta.rx_nss = nss;\r\nchanged |= IEEE80211_RC_NSS_CHANGED;\r\n}\r\nif (nss_only)\r\nreturn changed;\r\nswitch (opmode & IEEE80211_OPMODE_NOTIF_CHANWIDTH_MASK) {\r\ncase IEEE80211_OPMODE_NOTIF_CHANWIDTH_20MHZ:\r\nsta->cur_max_bandwidth = IEEE80211_STA_RX_BW_20;\r\nbreak;\r\ncase IEEE80211_OPMODE_NOTIF_CHANWIDTH_40MHZ:\r\nsta->cur_max_bandwidth = IEEE80211_STA_RX_BW_40;\r\nbreak;\r\ncase IEEE80211_OPMODE_NOTIF_CHANWIDTH_80MHZ:\r\nsta->cur_max_bandwidth = IEEE80211_STA_RX_BW_80;\r\nbreak;\r\ncase IEEE80211_OPMODE_NOTIF_CHANWIDTH_160MHZ:\r\nsta->cur_max_bandwidth = IEEE80211_STA_RX_BW_160;\r\nbreak;\r\n}\r\nnew_bw = ieee80211_sta_cur_vht_bw(sta);\r\nif (new_bw != sta->sta.bandwidth) {\r\nsta->sta.bandwidth = new_bw;\r\nchanged |= IEEE80211_RC_BW_CHANGED;\r\n}\r\nreturn changed;\r\n}\r\nvoid ieee80211_vht_handle_opmode(struct ieee80211_sub_if_data *sdata,\r\nstruct sta_info *sta, u8 opmode,\r\nenum ieee80211_band band, bool nss_only)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct ieee80211_supported_band *sband = local->hw.wiphy->bands[band];\r\nu32 changed = __ieee80211_vht_handle_opmode(sdata, sta, opmode,\r\nband, nss_only);\r\nif (changed > 0)\r\nrate_control_rate_update(local, sband, sta, changed);\r\n}
