static bool sh_eth_is_gether(struct sh_eth_private *mdp)\r\n{\r\nreturn mdp->reg_offset == sh_eth_offset_gigabit;\r\n}\r\nstatic bool sh_eth_is_rz_fast_ether(struct sh_eth_private *mdp)\r\n{\r\nreturn mdp->reg_offset == sh_eth_offset_fast_rz;\r\n}\r\nstatic void sh_eth_select_mii(struct net_device *ndev)\r\n{\r\nu32 value = 0x0;\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nswitch (mdp->phy_interface) {\r\ncase PHY_INTERFACE_MODE_GMII:\r\nvalue = 0x2;\r\nbreak;\r\ncase PHY_INTERFACE_MODE_MII:\r\nvalue = 0x1;\r\nbreak;\r\ncase PHY_INTERFACE_MODE_RMII:\r\nvalue = 0x0;\r\nbreak;\r\ndefault:\r\nnetdev_warn(ndev,\r\n"PHY interface mode was not setup. Set to MII.\n");\r\nvalue = 0x1;\r\nbreak;\r\n}\r\nsh_eth_write(ndev, value, RMII_MII);\r\n}\r\nstatic void sh_eth_set_duplex(struct net_device *ndev)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nif (mdp->duplex)\r\nsh_eth_write(ndev, sh_eth_read(ndev, ECMR) | ECMR_DM, ECMR);\r\nelse\r\nsh_eth_write(ndev, sh_eth_read(ndev, ECMR) & ~ECMR_DM, ECMR);\r\n}\r\nstatic void sh_eth_set_rate_r8a777x(struct net_device *ndev)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nswitch (mdp->speed) {\r\ncase 10:\r\nsh_eth_write(ndev, sh_eth_read(ndev, ECMR) & ~ECMR_ELB, ECMR);\r\nbreak;\r\ncase 100:\r\nsh_eth_write(ndev, sh_eth_read(ndev, ECMR) | ECMR_ELB, ECMR);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void sh_eth_set_rate_sh7724(struct net_device *ndev)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nswitch (mdp->speed) {\r\ncase 10:\r\nsh_eth_write(ndev, sh_eth_read(ndev, ECMR) & ~ECMR_RTM, ECMR);\r\nbreak;\r\ncase 100:\r\nsh_eth_write(ndev, sh_eth_read(ndev, ECMR) | ECMR_RTM, ECMR);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void sh_eth_set_rate_sh7757(struct net_device *ndev)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nswitch (mdp->speed) {\r\ncase 10:\r\nsh_eth_write(ndev, 0, RTRATE);\r\nbreak;\r\ncase 100:\r\nsh_eth_write(ndev, 1, RTRATE);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void sh_eth_chip_reset_giga(struct net_device *ndev)\r\n{\r\nint i;\r\nu32 mahr[2], malr[2];\r\nfor (i = 0; i < 2; i++) {\r\nmalr[i] = ioread32((void *)GIGA_MALR(i));\r\nmahr[i] = ioread32((void *)GIGA_MAHR(i));\r\n}\r\niowrite32(ARSTR_ARSTR, (void *)(SH_GIGA_ETH_BASE + 0x1800));\r\nmdelay(1);\r\nfor (i = 0; i < 2; i++) {\r\niowrite32(malr[i], (void *)GIGA_MALR(i));\r\niowrite32(mahr[i], (void *)GIGA_MAHR(i));\r\n}\r\n}\r\nstatic void sh_eth_set_rate_giga(struct net_device *ndev)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nswitch (mdp->speed) {\r\ncase 10:\r\nsh_eth_write(ndev, 0x00000000, GECMR);\r\nbreak;\r\ncase 100:\r\nsh_eth_write(ndev, 0x00000010, GECMR);\r\nbreak;\r\ncase 1000:\r\nsh_eth_write(ndev, 0x00000020, GECMR);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void sh_eth_chip_reset(struct net_device *ndev)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nsh_eth_tsu_write(mdp, ARSTR_ARSTR, ARSTR);\r\nmdelay(1);\r\n}\r\nstatic void sh_eth_set_rate_gether(struct net_device *ndev)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nswitch (mdp->speed) {\r\ncase 10:\r\nsh_eth_write(ndev, GECMR_10, GECMR);\r\nbreak;\r\ncase 100:\r\nsh_eth_write(ndev, GECMR_100, GECMR);\r\nbreak;\r\ncase 1000:\r\nsh_eth_write(ndev, GECMR_1000, GECMR);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void sh_eth_chip_reset_r8a7740(struct net_device *ndev)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nsh_eth_tsu_write(mdp, ARSTR_ARSTR, ARSTR);\r\nmdelay(1);\r\nsh_eth_select_mii(ndev);\r\n}\r\nstatic void sh_eth_set_default_cpu_data(struct sh_eth_cpu_data *cd)\r\n{\r\nif (!cd->ecsr_value)\r\ncd->ecsr_value = DEFAULT_ECSR_INIT;\r\nif (!cd->ecsipr_value)\r\ncd->ecsipr_value = DEFAULT_ECSIPR_INIT;\r\nif (!cd->fcftr_value)\r\ncd->fcftr_value = DEFAULT_FIFO_F_D_RFF |\r\nDEFAULT_FIFO_F_D_RFD;\r\nif (!cd->fdr_value)\r\ncd->fdr_value = DEFAULT_FDR_INIT;\r\nif (!cd->tx_check)\r\ncd->tx_check = DEFAULT_TX_CHECK;\r\nif (!cd->eesr_err_check)\r\ncd->eesr_err_check = DEFAULT_EESR_ERR_CHECK;\r\nif (!cd->trscer_err_mask)\r\ncd->trscer_err_mask = DEFAULT_TRSCER_ERR_MASK;\r\n}\r\nstatic int sh_eth_check_reset(struct net_device *ndev)\r\n{\r\nint ret = 0;\r\nint cnt = 100;\r\nwhile (cnt > 0) {\r\nif (!(sh_eth_read(ndev, EDMR) & 0x3))\r\nbreak;\r\nmdelay(1);\r\ncnt--;\r\n}\r\nif (cnt <= 0) {\r\nnetdev_err(ndev, "Device reset failed\n");\r\nret = -ETIMEDOUT;\r\n}\r\nreturn ret;\r\n}\r\nstatic int sh_eth_reset(struct net_device *ndev)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nint ret = 0;\r\nif (sh_eth_is_gether(mdp) || sh_eth_is_rz_fast_ether(mdp)) {\r\nsh_eth_write(ndev, EDSR_ENALL, EDSR);\r\nsh_eth_write(ndev, sh_eth_read(ndev, EDMR) | EDMR_SRST_GETHER,\r\nEDMR);\r\nret = sh_eth_check_reset(ndev);\r\nif (ret)\r\nreturn ret;\r\nsh_eth_write(ndev, 0x0, TDLAR);\r\nsh_eth_write(ndev, 0x0, TDFAR);\r\nsh_eth_write(ndev, 0x0, TDFXR);\r\nsh_eth_write(ndev, 0x0, TDFFR);\r\nsh_eth_write(ndev, 0x0, RDLAR);\r\nsh_eth_write(ndev, 0x0, RDFAR);\r\nsh_eth_write(ndev, 0x0, RDFXR);\r\nsh_eth_write(ndev, 0x0, RDFFR);\r\nif (mdp->cd->hw_crc)\r\nsh_eth_write(ndev, 0x0, CSMR);\r\nif (mdp->cd->select_mii)\r\nsh_eth_select_mii(ndev);\r\n} else {\r\nsh_eth_write(ndev, sh_eth_read(ndev, EDMR) | EDMR_SRST_ETHER,\r\nEDMR);\r\nmdelay(3);\r\nsh_eth_write(ndev, sh_eth_read(ndev, EDMR) & ~EDMR_SRST_ETHER,\r\nEDMR);\r\n}\r\nreturn ret;\r\n}\r\nstatic void sh_eth_set_receive_align(struct sk_buff *skb)\r\n{\r\nuintptr_t reserve = (uintptr_t)skb->data & (SH_ETH_RX_ALIGN - 1);\r\nif (reserve)\r\nskb_reserve(skb, SH_ETH_RX_ALIGN - reserve);\r\n}\r\nstatic inline __u32 cpu_to_edmac(struct sh_eth_private *mdp, u32 x)\r\n{\r\nswitch (mdp->edmac_endian) {\r\ncase EDMAC_LITTLE_ENDIAN:\r\nreturn cpu_to_le32(x);\r\ncase EDMAC_BIG_ENDIAN:\r\nreturn cpu_to_be32(x);\r\n}\r\nreturn x;\r\n}\r\nstatic inline __u32 edmac_to_cpu(struct sh_eth_private *mdp, u32 x)\r\n{\r\nswitch (mdp->edmac_endian) {\r\ncase EDMAC_LITTLE_ENDIAN:\r\nreturn le32_to_cpu(x);\r\ncase EDMAC_BIG_ENDIAN:\r\nreturn be32_to_cpu(x);\r\n}\r\nreturn x;\r\n}\r\nstatic void update_mac_address(struct net_device *ndev)\r\n{\r\nsh_eth_write(ndev,\r\n(ndev->dev_addr[0] << 24) | (ndev->dev_addr[1] << 16) |\r\n(ndev->dev_addr[2] << 8) | (ndev->dev_addr[3]), MAHR);\r\nsh_eth_write(ndev,\r\n(ndev->dev_addr[4] << 8) | (ndev->dev_addr[5]), MALR);\r\n}\r\nstatic void read_mac_address(struct net_device *ndev, unsigned char *mac)\r\n{\r\nif (mac[0] || mac[1] || mac[2] || mac[3] || mac[4] || mac[5]) {\r\nmemcpy(ndev->dev_addr, mac, ETH_ALEN);\r\n} else {\r\nndev->dev_addr[0] = (sh_eth_read(ndev, MAHR) >> 24);\r\nndev->dev_addr[1] = (sh_eth_read(ndev, MAHR) >> 16) & 0xFF;\r\nndev->dev_addr[2] = (sh_eth_read(ndev, MAHR) >> 8) & 0xFF;\r\nndev->dev_addr[3] = (sh_eth_read(ndev, MAHR) & 0xFF);\r\nndev->dev_addr[4] = (sh_eth_read(ndev, MALR) >> 8) & 0xFF;\r\nndev->dev_addr[5] = (sh_eth_read(ndev, MALR) & 0xFF);\r\n}\r\n}\r\nstatic u32 sh_eth_get_edtrr_trns(struct sh_eth_private *mdp)\r\n{\r\nif (sh_eth_is_gether(mdp) || sh_eth_is_rz_fast_ether(mdp))\r\nreturn EDTRR_TRNS_GETHER;\r\nelse\r\nreturn EDTRR_TRNS_ETHER;\r\n}\r\nstatic void bb_set(void *addr, u32 msk)\r\n{\r\niowrite32(ioread32(addr) | msk, addr);\r\n}\r\nstatic void bb_clr(void *addr, u32 msk)\r\n{\r\niowrite32((ioread32(addr) & ~msk), addr);\r\n}\r\nstatic int bb_read(void *addr, u32 msk)\r\n{\r\nreturn (ioread32(addr) & msk) != 0;\r\n}\r\nstatic void sh_mmd_ctrl(struct mdiobb_ctrl *ctrl, int bit)\r\n{\r\nstruct bb_info *bitbang = container_of(ctrl, struct bb_info, ctrl);\r\nif (bitbang->set_gate)\r\nbitbang->set_gate(bitbang->addr);\r\nif (bit)\r\nbb_set(bitbang->addr, bitbang->mmd_msk);\r\nelse\r\nbb_clr(bitbang->addr, bitbang->mmd_msk);\r\n}\r\nstatic void sh_set_mdio(struct mdiobb_ctrl *ctrl, int bit)\r\n{\r\nstruct bb_info *bitbang = container_of(ctrl, struct bb_info, ctrl);\r\nif (bitbang->set_gate)\r\nbitbang->set_gate(bitbang->addr);\r\nif (bit)\r\nbb_set(bitbang->addr, bitbang->mdo_msk);\r\nelse\r\nbb_clr(bitbang->addr, bitbang->mdo_msk);\r\n}\r\nstatic int sh_get_mdio(struct mdiobb_ctrl *ctrl)\r\n{\r\nstruct bb_info *bitbang = container_of(ctrl, struct bb_info, ctrl);\r\nif (bitbang->set_gate)\r\nbitbang->set_gate(bitbang->addr);\r\nreturn bb_read(bitbang->addr, bitbang->mdi_msk);\r\n}\r\nstatic void sh_mdc_ctrl(struct mdiobb_ctrl *ctrl, int bit)\r\n{\r\nstruct bb_info *bitbang = container_of(ctrl, struct bb_info, ctrl);\r\nif (bitbang->set_gate)\r\nbitbang->set_gate(bitbang->addr);\r\nif (bit)\r\nbb_set(bitbang->addr, bitbang->mdc_msk);\r\nelse\r\nbb_clr(bitbang->addr, bitbang->mdc_msk);\r\n}\r\nstatic void sh_eth_ring_free(struct net_device *ndev)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nint i;\r\nif (mdp->rx_skbuff) {\r\nfor (i = 0; i < mdp->num_rx_ring; i++)\r\ndev_kfree_skb(mdp->rx_skbuff[i]);\r\n}\r\nkfree(mdp->rx_skbuff);\r\nmdp->rx_skbuff = NULL;\r\nif (mdp->tx_skbuff) {\r\nfor (i = 0; i < mdp->num_tx_ring; i++)\r\ndev_kfree_skb(mdp->tx_skbuff[i]);\r\n}\r\nkfree(mdp->tx_skbuff);\r\nmdp->tx_skbuff = NULL;\r\n}\r\nstatic void sh_eth_ring_format(struct net_device *ndev)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nint i;\r\nstruct sk_buff *skb;\r\nstruct sh_eth_rxdesc *rxdesc = NULL;\r\nstruct sh_eth_txdesc *txdesc = NULL;\r\nint rx_ringsize = sizeof(*rxdesc) * mdp->num_rx_ring;\r\nint tx_ringsize = sizeof(*txdesc) * mdp->num_tx_ring;\r\nint skbuff_size = mdp->rx_buf_sz + SH_ETH_RX_ALIGN - 1;\r\ndma_addr_t dma_addr;\r\nmdp->cur_rx = 0;\r\nmdp->cur_tx = 0;\r\nmdp->dirty_rx = 0;\r\nmdp->dirty_tx = 0;\r\nmemset(mdp->rx_ring, 0, rx_ringsize);\r\nfor (i = 0; i < mdp->num_rx_ring; i++) {\r\nmdp->rx_skbuff[i] = NULL;\r\nskb = netdev_alloc_skb(ndev, skbuff_size);\r\nif (skb == NULL)\r\nbreak;\r\nsh_eth_set_receive_align(skb);\r\nrxdesc = &mdp->rx_ring[i];\r\nrxdesc->buffer_length = ALIGN(mdp->rx_buf_sz, 16);\r\ndma_addr = dma_map_single(&ndev->dev, skb->data,\r\nrxdesc->buffer_length,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(&ndev->dev, dma_addr)) {\r\nkfree_skb(skb);\r\nbreak;\r\n}\r\nmdp->rx_skbuff[i] = skb;\r\nrxdesc->addr = dma_addr;\r\nrxdesc->status = cpu_to_edmac(mdp, RD_RACT | RD_RFP);\r\nif (i == 0) {\r\nsh_eth_write(ndev, mdp->rx_desc_dma, RDLAR);\r\nif (sh_eth_is_gether(mdp) ||\r\nsh_eth_is_rz_fast_ether(mdp))\r\nsh_eth_write(ndev, mdp->rx_desc_dma, RDFAR);\r\n}\r\n}\r\nmdp->dirty_rx = (u32) (i - mdp->num_rx_ring);\r\nrxdesc->status |= cpu_to_edmac(mdp, RD_RDEL);\r\nmemset(mdp->tx_ring, 0, tx_ringsize);\r\nfor (i = 0; i < mdp->num_tx_ring; i++) {\r\nmdp->tx_skbuff[i] = NULL;\r\ntxdesc = &mdp->tx_ring[i];\r\ntxdesc->status = cpu_to_edmac(mdp, TD_TFP);\r\ntxdesc->buffer_length = 0;\r\nif (i == 0) {\r\nsh_eth_write(ndev, mdp->tx_desc_dma, TDLAR);\r\nif (sh_eth_is_gether(mdp) ||\r\nsh_eth_is_rz_fast_ether(mdp))\r\nsh_eth_write(ndev, mdp->tx_desc_dma, TDFAR);\r\n}\r\n}\r\ntxdesc->status |= cpu_to_edmac(mdp, TD_TDLE);\r\n}\r\nstatic int sh_eth_ring_init(struct net_device *ndev)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nint rx_ringsize, tx_ringsize, ret = 0;\r\nmdp->rx_buf_sz = (ndev->mtu <= 1492 ? PKT_BUF_SZ :\r\n(((ndev->mtu + 26 + 7) & ~7) + 2 + 16));\r\nif (mdp->cd->rpadir)\r\nmdp->rx_buf_sz += NET_IP_ALIGN;\r\nmdp->rx_skbuff = kmalloc_array(mdp->num_rx_ring,\r\nsizeof(*mdp->rx_skbuff), GFP_KERNEL);\r\nif (!mdp->rx_skbuff) {\r\nret = -ENOMEM;\r\nreturn ret;\r\n}\r\nmdp->tx_skbuff = kmalloc_array(mdp->num_tx_ring,\r\nsizeof(*mdp->tx_skbuff), GFP_KERNEL);\r\nif (!mdp->tx_skbuff) {\r\nret = -ENOMEM;\r\ngoto skb_ring_free;\r\n}\r\nrx_ringsize = sizeof(struct sh_eth_rxdesc) * mdp->num_rx_ring;\r\nmdp->rx_ring = dma_alloc_coherent(NULL, rx_ringsize, &mdp->rx_desc_dma,\r\nGFP_KERNEL);\r\nif (!mdp->rx_ring) {\r\nret = -ENOMEM;\r\ngoto desc_ring_free;\r\n}\r\nmdp->dirty_rx = 0;\r\ntx_ringsize = sizeof(struct sh_eth_txdesc) * mdp->num_tx_ring;\r\nmdp->tx_ring = dma_alloc_coherent(NULL, tx_ringsize, &mdp->tx_desc_dma,\r\nGFP_KERNEL);\r\nif (!mdp->tx_ring) {\r\nret = -ENOMEM;\r\ngoto desc_ring_free;\r\n}\r\nreturn ret;\r\ndesc_ring_free:\r\ndma_free_coherent(NULL, rx_ringsize, mdp->rx_ring, mdp->rx_desc_dma);\r\nskb_ring_free:\r\nsh_eth_ring_free(ndev);\r\nmdp->tx_ring = NULL;\r\nmdp->rx_ring = NULL;\r\nreturn ret;\r\n}\r\nstatic void sh_eth_free_dma_buffer(struct sh_eth_private *mdp)\r\n{\r\nint ringsize;\r\nif (mdp->rx_ring) {\r\nringsize = sizeof(struct sh_eth_rxdesc) * mdp->num_rx_ring;\r\ndma_free_coherent(NULL, ringsize, mdp->rx_ring,\r\nmdp->rx_desc_dma);\r\nmdp->rx_ring = NULL;\r\n}\r\nif (mdp->tx_ring) {\r\nringsize = sizeof(struct sh_eth_txdesc) * mdp->num_tx_ring;\r\ndma_free_coherent(NULL, ringsize, mdp->tx_ring,\r\nmdp->tx_desc_dma);\r\nmdp->tx_ring = NULL;\r\n}\r\n}\r\nstatic int sh_eth_dev_init(struct net_device *ndev, bool start)\r\n{\r\nint ret = 0;\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nu32 val;\r\nret = sh_eth_reset(ndev);\r\nif (ret)\r\nreturn ret;\r\nif (mdp->cd->rmiimode)\r\nsh_eth_write(ndev, 0x1, RMIIMODE);\r\nsh_eth_ring_format(ndev);\r\nif (mdp->cd->rpadir)\r\nsh_eth_write(ndev, mdp->cd->rpadir_value, RPADIR);\r\nsh_eth_write(ndev, 0, EESIPR);\r\n#if defined(__LITTLE_ENDIAN)\r\nif (mdp->cd->hw_swap)\r\nsh_eth_write(ndev, EDMR_EL, EDMR);\r\nelse\r\n#endif\r\nsh_eth_write(ndev, 0, EDMR);\r\nsh_eth_write(ndev, mdp->cd->fdr_value, FDR);\r\nsh_eth_write(ndev, 0, TFTR);\r\nsh_eth_write(ndev, RMCR_RNC, RMCR);\r\nsh_eth_write(ndev, mdp->cd->trscer_err_mask, TRSCER);\r\nif (mdp->cd->bculr)\r\nsh_eth_write(ndev, 0x800, BCULR);\r\nsh_eth_write(ndev, mdp->cd->fcftr_value, FCFTR);\r\nif (!mdp->cd->no_trimd)\r\nsh_eth_write(ndev, 0, TRIMD);\r\nsh_eth_write(ndev, ndev->mtu + ETH_HLEN + VLAN_HLEN + ETH_FCS_LEN,\r\nRFLR);\r\nsh_eth_write(ndev, sh_eth_read(ndev, EESR), EESR);\r\nif (start) {\r\nmdp->irq_enabled = true;\r\nsh_eth_write(ndev, mdp->cd->eesipr_value, EESIPR);\r\n}\r\nval = (sh_eth_read(ndev, ECMR) & ECMR_DM) |\r\nECMR_ZPF | (mdp->duplex ? ECMR_DM : 0) | ECMR_TE | ECMR_RE;\r\nsh_eth_write(ndev, val, ECMR);\r\nif (mdp->cd->set_rate)\r\nmdp->cd->set_rate(ndev);\r\nsh_eth_write(ndev, mdp->cd->ecsr_value, ECSR);\r\nif (start)\r\nsh_eth_write(ndev, mdp->cd->ecsipr_value, ECSIPR);\r\nupdate_mac_address(ndev);\r\nif (mdp->cd->apr)\r\nsh_eth_write(ndev, APR_AP, APR);\r\nif (mdp->cd->mpr)\r\nsh_eth_write(ndev, MPR_MP, MPR);\r\nif (mdp->cd->tpauser)\r\nsh_eth_write(ndev, TPAUSER_UNLIMITED, TPAUSER);\r\nif (start) {\r\nsh_eth_write(ndev, EDRRR_R, EDRRR);\r\nnetif_start_queue(ndev);\r\n}\r\nreturn ret;\r\n}\r\nstatic void sh_eth_dev_exit(struct net_device *ndev)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nint i;\r\nfor (i = 0; i < mdp->num_tx_ring; i++)\r\nmdp->tx_ring[i].status &= ~cpu_to_edmac(mdp, TD_TACT);\r\nsh_eth_rcv_snd_disable(ndev);\r\nsh_eth_write(ndev, 0, EDRRR);\r\nmsleep(2);\r\nsh_eth_get_stats(ndev);\r\nsh_eth_reset(ndev);\r\nupdate_mac_address(ndev);\r\n}\r\nstatic int sh_eth_txfree(struct net_device *ndev)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nstruct sh_eth_txdesc *txdesc;\r\nint free_num = 0;\r\nint entry = 0;\r\nfor (; mdp->cur_tx - mdp->dirty_tx > 0; mdp->dirty_tx++) {\r\nentry = mdp->dirty_tx % mdp->num_tx_ring;\r\ntxdesc = &mdp->tx_ring[entry];\r\nif (txdesc->status & cpu_to_edmac(mdp, TD_TACT))\r\nbreak;\r\nrmb();\r\nnetif_info(mdp, tx_done, ndev,\r\n"tx entry %d status 0x%08x\n",\r\nentry, edmac_to_cpu(mdp, txdesc->status));\r\nif (mdp->tx_skbuff[entry]) {\r\ndma_unmap_single(&ndev->dev, txdesc->addr,\r\ntxdesc->buffer_length, DMA_TO_DEVICE);\r\ndev_kfree_skb_irq(mdp->tx_skbuff[entry]);\r\nmdp->tx_skbuff[entry] = NULL;\r\nfree_num++;\r\n}\r\ntxdesc->status = cpu_to_edmac(mdp, TD_TFP);\r\nif (entry >= mdp->num_tx_ring - 1)\r\ntxdesc->status |= cpu_to_edmac(mdp, TD_TDLE);\r\nndev->stats.tx_packets++;\r\nndev->stats.tx_bytes += txdesc->buffer_length;\r\n}\r\nreturn free_num;\r\n}\r\nstatic int sh_eth_rx(struct net_device *ndev, u32 intr_status, int *quota)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nstruct sh_eth_rxdesc *rxdesc;\r\nint entry = mdp->cur_rx % mdp->num_rx_ring;\r\nint boguscnt = (mdp->dirty_rx + mdp->num_rx_ring) - mdp->cur_rx;\r\nint limit;\r\nstruct sk_buff *skb;\r\nu16 pkt_len = 0;\r\nu32 desc_status;\r\nint skbuff_size = mdp->rx_buf_sz + SH_ETH_RX_ALIGN - 1;\r\ndma_addr_t dma_addr;\r\nboguscnt = min(boguscnt, *quota);\r\nlimit = boguscnt;\r\nrxdesc = &mdp->rx_ring[entry];\r\nwhile (!(rxdesc->status & cpu_to_edmac(mdp, RD_RACT))) {\r\nrmb();\r\ndesc_status = edmac_to_cpu(mdp, rxdesc->status);\r\npkt_len = rxdesc->frame_length;\r\nif (--boguscnt < 0)\r\nbreak;\r\nnetif_info(mdp, rx_status, ndev,\r\n"rx entry %d status 0x%08x len %d\n",\r\nentry, desc_status, pkt_len);\r\nif (!(desc_status & RDFEND))\r\nndev->stats.rx_length_errors++;\r\nif (mdp->cd->shift_rd0)\r\ndesc_status >>= 16;\r\nif (desc_status & (RD_RFS1 | RD_RFS2 | RD_RFS3 | RD_RFS4 |\r\nRD_RFS5 | RD_RFS6 | RD_RFS10)) {\r\nndev->stats.rx_errors++;\r\nif (desc_status & RD_RFS1)\r\nndev->stats.rx_crc_errors++;\r\nif (desc_status & RD_RFS2)\r\nndev->stats.rx_frame_errors++;\r\nif (desc_status & RD_RFS3)\r\nndev->stats.rx_length_errors++;\r\nif (desc_status & RD_RFS4)\r\nndev->stats.rx_length_errors++;\r\nif (desc_status & RD_RFS6)\r\nndev->stats.rx_missed_errors++;\r\nif (desc_status & RD_RFS10)\r\nndev->stats.rx_over_errors++;\r\n} else {\r\nif (!mdp->cd->hw_swap)\r\nsh_eth_soft_swap(\r\nphys_to_virt(ALIGN(rxdesc->addr, 4)),\r\npkt_len + 2);\r\nskb = mdp->rx_skbuff[entry];\r\nmdp->rx_skbuff[entry] = NULL;\r\nif (mdp->cd->rpadir)\r\nskb_reserve(skb, NET_IP_ALIGN);\r\ndma_unmap_single(&ndev->dev, rxdesc->addr,\r\nALIGN(mdp->rx_buf_sz, 16),\r\nDMA_FROM_DEVICE);\r\nskb_put(skb, pkt_len);\r\nskb->protocol = eth_type_trans(skb, ndev);\r\nnetif_receive_skb(skb);\r\nndev->stats.rx_packets++;\r\nndev->stats.rx_bytes += pkt_len;\r\nif (desc_status & RD_RFS8)\r\nndev->stats.multicast++;\r\n}\r\nentry = (++mdp->cur_rx) % mdp->num_rx_ring;\r\nrxdesc = &mdp->rx_ring[entry];\r\n}\r\nfor (; mdp->cur_rx - mdp->dirty_rx > 0; mdp->dirty_rx++) {\r\nentry = mdp->dirty_rx % mdp->num_rx_ring;\r\nrxdesc = &mdp->rx_ring[entry];\r\nrxdesc->buffer_length = ALIGN(mdp->rx_buf_sz, 16);\r\nif (mdp->rx_skbuff[entry] == NULL) {\r\nskb = netdev_alloc_skb(ndev, skbuff_size);\r\nif (skb == NULL)\r\nbreak;\r\nsh_eth_set_receive_align(skb);\r\ndma_addr = dma_map_single(&ndev->dev, skb->data,\r\nrxdesc->buffer_length,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(&ndev->dev, dma_addr)) {\r\nkfree_skb(skb);\r\nbreak;\r\n}\r\nmdp->rx_skbuff[entry] = skb;\r\nskb_checksum_none_assert(skb);\r\nrxdesc->addr = dma_addr;\r\n}\r\nwmb();\r\nif (entry >= mdp->num_rx_ring - 1)\r\nrxdesc->status |=\r\ncpu_to_edmac(mdp, RD_RACT | RD_RFP | RD_RDEL);\r\nelse\r\nrxdesc->status |=\r\ncpu_to_edmac(mdp, RD_RACT | RD_RFP);\r\n}\r\nif (!(sh_eth_read(ndev, EDRRR) & EDRRR_R)) {\r\nif (intr_status & EESR_RDE &&\r\nmdp->reg_offset[RDFAR] != SH_ETH_OFFSET_INVALID) {\r\nu32 count = (sh_eth_read(ndev, RDFAR) -\r\nsh_eth_read(ndev, RDLAR)) >> 4;\r\nmdp->cur_rx = count;\r\nmdp->dirty_rx = count;\r\n}\r\nsh_eth_write(ndev, EDRRR_R, EDRRR);\r\n}\r\n*quota -= limit - boguscnt - 1;\r\nreturn *quota <= 0;\r\n}\r\nstatic void sh_eth_rcv_snd_disable(struct net_device *ndev)\r\n{\r\nsh_eth_write(ndev, sh_eth_read(ndev, ECMR) &\r\n~(ECMR_RE | ECMR_TE), ECMR);\r\n}\r\nstatic void sh_eth_rcv_snd_enable(struct net_device *ndev)\r\n{\r\nsh_eth_write(ndev, sh_eth_read(ndev, ECMR) |\r\n(ECMR_RE | ECMR_TE), ECMR);\r\n}\r\nstatic void sh_eth_error(struct net_device *ndev, u32 intr_status)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nu32 felic_stat;\r\nu32 link_stat;\r\nu32 mask;\r\nif (intr_status & EESR_ECI) {\r\nfelic_stat = sh_eth_read(ndev, ECSR);\r\nsh_eth_write(ndev, felic_stat, ECSR);\r\nif (felic_stat & ECSR_ICD)\r\nndev->stats.tx_carrier_errors++;\r\nif (felic_stat & ECSR_LCHNG) {\r\nif (mdp->cd->no_psr || mdp->no_ether_link) {\r\ngoto ignore_link;\r\n} else {\r\nlink_stat = (sh_eth_read(ndev, PSR));\r\nif (mdp->ether_link_active_low)\r\nlink_stat = ~link_stat;\r\n}\r\nif (!(link_stat & PHY_ST_LINK)) {\r\nsh_eth_rcv_snd_disable(ndev);\r\n} else {\r\nsh_eth_write(ndev, sh_eth_read(ndev, EESIPR) &\r\n~DMAC_M_ECI, EESIPR);\r\nsh_eth_write(ndev, sh_eth_read(ndev, ECSR),\r\nECSR);\r\nsh_eth_write(ndev, sh_eth_read(ndev, EESIPR) |\r\nDMAC_M_ECI, EESIPR);\r\nsh_eth_rcv_snd_enable(ndev);\r\n}\r\n}\r\n}\r\nignore_link:\r\nif (intr_status & EESR_TWB) {\r\nif (intr_status & EESR_TABT) {\r\nndev->stats.tx_aborted_errors++;\r\nnetif_err(mdp, tx_err, ndev, "Transmit Abort\n");\r\n}\r\n}\r\nif (intr_status & EESR_RABT) {\r\nif (intr_status & EESR_RFRMER) {\r\nndev->stats.rx_frame_errors++;\r\n}\r\n}\r\nif (intr_status & EESR_TDE) {\r\nndev->stats.tx_fifo_errors++;\r\nnetif_err(mdp, tx_err, ndev, "Transmit Descriptor Empty\n");\r\n}\r\nif (intr_status & EESR_TFE) {\r\nndev->stats.tx_fifo_errors++;\r\nnetif_err(mdp, tx_err, ndev, "Transmit FIFO Under flow\n");\r\n}\r\nif (intr_status & EESR_RDE) {\r\nndev->stats.rx_over_errors++;\r\n}\r\nif (intr_status & EESR_RFE) {\r\nndev->stats.rx_fifo_errors++;\r\n}\r\nif (!mdp->cd->no_ade && (intr_status & EESR_ADE)) {\r\nndev->stats.tx_fifo_errors++;\r\nnetif_err(mdp, tx_err, ndev, "Address Error\n");\r\n}\r\nmask = EESR_TWB | EESR_TABT | EESR_ADE | EESR_TDE | EESR_TFE;\r\nif (mdp->cd->no_ade)\r\nmask &= ~EESR_ADE;\r\nif (intr_status & mask) {\r\nu32 edtrr = sh_eth_read(ndev, EDTRR);\r\nnetdev_err(ndev, "TX error. status=%8.8x cur_tx=%8.8x dirty_tx=%8.8x state=%8.8x EDTRR=%8.8x.\n",\r\nintr_status, mdp->cur_tx, mdp->dirty_tx,\r\n(u32)ndev->state, edtrr);\r\nsh_eth_txfree(ndev);\r\nif (edtrr ^ sh_eth_get_edtrr_trns(mdp)) {\r\nsh_eth_write(ndev, sh_eth_get_edtrr_trns(mdp), EDTRR);\r\n}\r\nnetif_wake_queue(ndev);\r\n}\r\n}\r\nstatic irqreturn_t sh_eth_interrupt(int irq, void *netdev)\r\n{\r\nstruct net_device *ndev = netdev;\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nstruct sh_eth_cpu_data *cd = mdp->cd;\r\nirqreturn_t ret = IRQ_NONE;\r\nu32 intr_status, intr_enable;\r\nspin_lock(&mdp->lock);\r\nintr_status = sh_eth_read(ndev, EESR);\r\nintr_enable = sh_eth_read(ndev, EESIPR);\r\nintr_status &= intr_enable | DMAC_M_ECI;\r\nif (intr_status & (EESR_RX_CHECK | cd->tx_check | cd->eesr_err_check))\r\nret = IRQ_HANDLED;\r\nelse\r\ngoto out;\r\nif (!likely(mdp->irq_enabled)) {\r\nsh_eth_write(ndev, 0, EESIPR);\r\ngoto out;\r\n}\r\nif (intr_status & EESR_RX_CHECK) {\r\nif (napi_schedule_prep(&mdp->napi)) {\r\nsh_eth_write(ndev, intr_enable & ~EESR_RX_CHECK,\r\nEESIPR);\r\n__napi_schedule(&mdp->napi);\r\n} else {\r\nnetdev_warn(ndev,\r\n"ignoring interrupt, status 0x%08x, mask 0x%08x.\n",\r\nintr_status, intr_enable);\r\n}\r\n}\r\nif (intr_status & cd->tx_check) {\r\nsh_eth_write(ndev, intr_status & cd->tx_check, EESR);\r\nsh_eth_txfree(ndev);\r\nnetif_wake_queue(ndev);\r\n}\r\nif (intr_status & cd->eesr_err_check) {\r\nsh_eth_write(ndev, intr_status & cd->eesr_err_check, EESR);\r\nsh_eth_error(ndev, intr_status);\r\n}\r\nout:\r\nspin_unlock(&mdp->lock);\r\nreturn ret;\r\n}\r\nstatic int sh_eth_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct sh_eth_private *mdp = container_of(napi, struct sh_eth_private,\r\nnapi);\r\nstruct net_device *ndev = napi->dev;\r\nint quota = budget;\r\nu32 intr_status;\r\nfor (;;) {\r\nintr_status = sh_eth_read(ndev, EESR);\r\nif (!(intr_status & EESR_RX_CHECK))\r\nbreak;\r\nsh_eth_write(ndev, intr_status & EESR_RX_CHECK, EESR);\r\nif (sh_eth_rx(ndev, intr_status, &quota))\r\ngoto out;\r\n}\r\nnapi_complete(napi);\r\nif (mdp->irq_enabled)\r\nsh_eth_write(ndev, mdp->cd->eesipr_value, EESIPR);\r\nout:\r\nreturn budget - quota;\r\n}\r\nstatic void sh_eth_adjust_link(struct net_device *ndev)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nstruct phy_device *phydev = mdp->phydev;\r\nint new_state = 0;\r\nif (phydev->link) {\r\nif (phydev->duplex != mdp->duplex) {\r\nnew_state = 1;\r\nmdp->duplex = phydev->duplex;\r\nif (mdp->cd->set_duplex)\r\nmdp->cd->set_duplex(ndev);\r\n}\r\nif (phydev->speed != mdp->speed) {\r\nnew_state = 1;\r\nmdp->speed = phydev->speed;\r\nif (mdp->cd->set_rate)\r\nmdp->cd->set_rate(ndev);\r\n}\r\nif (!mdp->link) {\r\nsh_eth_write(ndev,\r\nsh_eth_read(ndev, ECMR) & ~ECMR_TXF,\r\nECMR);\r\nnew_state = 1;\r\nmdp->link = phydev->link;\r\nif (mdp->cd->no_psr || mdp->no_ether_link)\r\nsh_eth_rcv_snd_enable(ndev);\r\n}\r\n} else if (mdp->link) {\r\nnew_state = 1;\r\nmdp->link = 0;\r\nmdp->speed = 0;\r\nmdp->duplex = -1;\r\nif (mdp->cd->no_psr || mdp->no_ether_link)\r\nsh_eth_rcv_snd_disable(ndev);\r\n}\r\nif (new_state && netif_msg_link(mdp))\r\nphy_print_status(phydev);\r\n}\r\nstatic int sh_eth_phy_init(struct net_device *ndev)\r\n{\r\nstruct device_node *np = ndev->dev.parent->of_node;\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nstruct phy_device *phydev = NULL;\r\nmdp->link = 0;\r\nmdp->speed = 0;\r\nmdp->duplex = -1;\r\nif (np) {\r\nstruct device_node *pn;\r\npn = of_parse_phandle(np, "phy-handle", 0);\r\nphydev = of_phy_connect(ndev, pn,\r\nsh_eth_adjust_link, 0,\r\nmdp->phy_interface);\r\nif (!phydev)\r\nphydev = ERR_PTR(-ENOENT);\r\n} else {\r\nchar phy_id[MII_BUS_ID_SIZE + 3];\r\nsnprintf(phy_id, sizeof(phy_id), PHY_ID_FMT,\r\nmdp->mii_bus->id, mdp->phy_id);\r\nphydev = phy_connect(ndev, phy_id, sh_eth_adjust_link,\r\nmdp->phy_interface);\r\n}\r\nif (IS_ERR(phydev)) {\r\nnetdev_err(ndev, "failed to connect PHY\n");\r\nreturn PTR_ERR(phydev);\r\n}\r\nnetdev_info(ndev, "attached PHY %d (IRQ %d) to driver %s\n",\r\nphydev->addr, phydev->irq, phydev->drv->name);\r\nmdp->phydev = phydev;\r\nreturn 0;\r\n}\r\nstatic int sh_eth_phy_start(struct net_device *ndev)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nint ret;\r\nret = sh_eth_phy_init(ndev);\r\nif (ret)\r\nreturn ret;\r\nphy_start(mdp->phydev);\r\nreturn 0;\r\n}\r\nstatic int sh_eth_get_settings(struct net_device *ndev,\r\nstruct ethtool_cmd *ecmd)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nunsigned long flags;\r\nint ret;\r\nif (!mdp->phydev)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&mdp->lock, flags);\r\nret = phy_ethtool_gset(mdp->phydev, ecmd);\r\nspin_unlock_irqrestore(&mdp->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int sh_eth_set_settings(struct net_device *ndev,\r\nstruct ethtool_cmd *ecmd)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nunsigned long flags;\r\nint ret;\r\nif (!mdp->phydev)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&mdp->lock, flags);\r\nsh_eth_rcv_snd_disable(ndev);\r\nret = phy_ethtool_sset(mdp->phydev, ecmd);\r\nif (ret)\r\ngoto error_exit;\r\nif (ecmd->duplex == DUPLEX_FULL)\r\nmdp->duplex = 1;\r\nelse\r\nmdp->duplex = 0;\r\nif (mdp->cd->set_duplex)\r\nmdp->cd->set_duplex(ndev);\r\nerror_exit:\r\nmdelay(1);\r\nsh_eth_rcv_snd_enable(ndev);\r\nspin_unlock_irqrestore(&mdp->lock, flags);\r\nreturn ret;\r\n}\r\nstatic size_t __sh_eth_get_regs(struct net_device *ndev, u32 *buf)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nstruct sh_eth_cpu_data *cd = mdp->cd;\r\nu32 *valid_map;\r\nsize_t len;\r\nBUILD_BUG_ON(SH_ETH_MAX_REGISTER_OFFSET > SH_ETH_REG_DUMP_MAX_REGS);\r\nlen = DIV_ROUND_UP(SH_ETH_REG_DUMP_MAX_REGS, 32);\r\nif (buf) {\r\nvalid_map = buf;\r\nbuf += len;\r\n} else {\r\nvalid_map = NULL;\r\n}\r\n#define mark_reg_valid(reg) valid_map[reg / 32] |= 1U << (reg % 32)\r\n#define add_reg_from(reg, read_expr) do { \\r\nif (mdp->reg_offset[reg] != SH_ETH_OFFSET_INVALID) { \\r\nif (buf) { \\r\nmark_reg_valid(reg); \\r\n*buf++ = read_expr; \\r\n} \\r\n++len; \\r\n} \\r\n} while (0)\r\n#define add_reg(reg) add_reg_from(reg, sh_eth_read(ndev, reg))\r\n#define add_tsu_reg(reg) add_reg_from(reg, sh_eth_tsu_read(mdp, reg))\r\nadd_reg(EDSR);\r\nadd_reg(EDMR);\r\nadd_reg(EDTRR);\r\nadd_reg(EDRRR);\r\nadd_reg(EESR);\r\nadd_reg(EESIPR);\r\nadd_reg(TDLAR);\r\nadd_reg(TDFAR);\r\nadd_reg(TDFXR);\r\nadd_reg(TDFFR);\r\nadd_reg(RDLAR);\r\nadd_reg(RDFAR);\r\nadd_reg(RDFXR);\r\nadd_reg(RDFFR);\r\nadd_reg(TRSCER);\r\nadd_reg(RMFCR);\r\nadd_reg(TFTR);\r\nadd_reg(FDR);\r\nadd_reg(RMCR);\r\nadd_reg(TFUCR);\r\nadd_reg(RFOCR);\r\nif (cd->rmiimode)\r\nadd_reg(RMIIMODE);\r\nadd_reg(FCFTR);\r\nif (cd->rpadir)\r\nadd_reg(RPADIR);\r\nif (!cd->no_trimd)\r\nadd_reg(TRIMD);\r\nadd_reg(ECMR);\r\nadd_reg(ECSR);\r\nadd_reg(ECSIPR);\r\nadd_reg(PIR);\r\nif (!cd->no_psr)\r\nadd_reg(PSR);\r\nadd_reg(RDMLR);\r\nadd_reg(RFLR);\r\nadd_reg(IPGR);\r\nif (cd->apr)\r\nadd_reg(APR);\r\nif (cd->mpr)\r\nadd_reg(MPR);\r\nadd_reg(RFCR);\r\nadd_reg(RFCF);\r\nif (cd->tpauser)\r\nadd_reg(TPAUSER);\r\nadd_reg(TPAUSECR);\r\nadd_reg(GECMR);\r\nif (cd->bculr)\r\nadd_reg(BCULR);\r\nadd_reg(MAHR);\r\nadd_reg(MALR);\r\nadd_reg(TROCR);\r\nadd_reg(CDCR);\r\nadd_reg(LCCR);\r\nadd_reg(CNDCR);\r\nadd_reg(CEFCR);\r\nadd_reg(FRECR);\r\nadd_reg(TSFRCR);\r\nadd_reg(TLFRCR);\r\nadd_reg(CERCR);\r\nadd_reg(CEECR);\r\nadd_reg(MAFCR);\r\nif (cd->rtrate)\r\nadd_reg(RTRATE);\r\nif (cd->hw_crc)\r\nadd_reg(CSMR);\r\nif (cd->select_mii)\r\nadd_reg(RMII_MII);\r\nadd_reg(ARSTR);\r\nif (cd->tsu) {\r\nadd_tsu_reg(TSU_CTRST);\r\nadd_tsu_reg(TSU_FWEN0);\r\nadd_tsu_reg(TSU_FWEN1);\r\nadd_tsu_reg(TSU_FCM);\r\nadd_tsu_reg(TSU_BSYSL0);\r\nadd_tsu_reg(TSU_BSYSL1);\r\nadd_tsu_reg(TSU_PRISL0);\r\nadd_tsu_reg(TSU_PRISL1);\r\nadd_tsu_reg(TSU_FWSL0);\r\nadd_tsu_reg(TSU_FWSL1);\r\nadd_tsu_reg(TSU_FWSLC);\r\nadd_tsu_reg(TSU_QTAG0);\r\nadd_tsu_reg(TSU_QTAG1);\r\nadd_tsu_reg(TSU_QTAGM0);\r\nadd_tsu_reg(TSU_QTAGM1);\r\nadd_tsu_reg(TSU_FWSR);\r\nadd_tsu_reg(TSU_FWINMK);\r\nadd_tsu_reg(TSU_ADQT0);\r\nadd_tsu_reg(TSU_ADQT1);\r\nadd_tsu_reg(TSU_VTAG0);\r\nadd_tsu_reg(TSU_VTAG1);\r\nadd_tsu_reg(TSU_ADSBSY);\r\nadd_tsu_reg(TSU_TEN);\r\nadd_tsu_reg(TSU_POST1);\r\nadd_tsu_reg(TSU_POST2);\r\nadd_tsu_reg(TSU_POST3);\r\nadd_tsu_reg(TSU_POST4);\r\nif (mdp->reg_offset[TSU_ADRH0] != SH_ETH_OFFSET_INVALID) {\r\nif (buf) {\r\nunsigned int i;\r\nmark_reg_valid(TSU_ADRH0);\r\nfor (i = 0; i < SH_ETH_TSU_CAM_ENTRIES * 2; i++)\r\n*buf++ = ioread32(\r\nmdp->tsu_addr +\r\nmdp->reg_offset[TSU_ADRH0] +\r\ni * 4);\r\n}\r\nlen += SH_ETH_TSU_CAM_ENTRIES * 2;\r\n}\r\n}\r\n#undef mark_reg_valid\r\n#undef add_reg_from\r\n#undef add_reg\r\n#undef add_tsu_reg\r\nreturn len * 4;\r\n}\r\nstatic int sh_eth_get_regs_len(struct net_device *ndev)\r\n{\r\nreturn __sh_eth_get_regs(ndev, NULL);\r\n}\r\nstatic void sh_eth_get_regs(struct net_device *ndev, struct ethtool_regs *regs,\r\nvoid *buf)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nregs->version = SH_ETH_REG_DUMP_VERSION;\r\npm_runtime_get_sync(&mdp->pdev->dev);\r\n__sh_eth_get_regs(ndev, buf);\r\npm_runtime_put_sync(&mdp->pdev->dev);\r\n}\r\nstatic int sh_eth_nway_reset(struct net_device *ndev)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nunsigned long flags;\r\nint ret;\r\nif (!mdp->phydev)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&mdp->lock, flags);\r\nret = phy_start_aneg(mdp->phydev);\r\nspin_unlock_irqrestore(&mdp->lock, flags);\r\nreturn ret;\r\n}\r\nstatic u32 sh_eth_get_msglevel(struct net_device *ndev)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nreturn mdp->msg_enable;\r\n}\r\nstatic void sh_eth_set_msglevel(struct net_device *ndev, u32 value)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nmdp->msg_enable = value;\r\n}\r\nstatic int sh_eth_get_sset_count(struct net_device *netdev, int sset)\r\n{\r\nswitch (sset) {\r\ncase ETH_SS_STATS:\r\nreturn SH_ETH_STATS_LEN;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void sh_eth_get_ethtool_stats(struct net_device *ndev,\r\nstruct ethtool_stats *stats, u64 *data)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nint i = 0;\r\ndata[i++] = mdp->cur_rx;\r\ndata[i++] = mdp->cur_tx;\r\ndata[i++] = mdp->dirty_rx;\r\ndata[i++] = mdp->dirty_tx;\r\n}\r\nstatic void sh_eth_get_strings(struct net_device *ndev, u32 stringset, u8 *data)\r\n{\r\nswitch (stringset) {\r\ncase ETH_SS_STATS:\r\nmemcpy(data, *sh_eth_gstrings_stats,\r\nsizeof(sh_eth_gstrings_stats));\r\nbreak;\r\n}\r\n}\r\nstatic void sh_eth_get_ringparam(struct net_device *ndev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nring->rx_max_pending = RX_RING_MAX;\r\nring->tx_max_pending = TX_RING_MAX;\r\nring->rx_pending = mdp->num_rx_ring;\r\nring->tx_pending = mdp->num_tx_ring;\r\n}\r\nstatic int sh_eth_set_ringparam(struct net_device *ndev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nint ret;\r\nif (ring->tx_pending > TX_RING_MAX ||\r\nring->rx_pending > RX_RING_MAX ||\r\nring->tx_pending < TX_RING_MIN ||\r\nring->rx_pending < RX_RING_MIN)\r\nreturn -EINVAL;\r\nif (ring->rx_mini_pending || ring->rx_jumbo_pending)\r\nreturn -EINVAL;\r\nif (netif_running(ndev)) {\r\nnetif_device_detach(ndev);\r\nnetif_tx_disable(ndev);\r\nmdp->irq_enabled = false;\r\nsynchronize_irq(ndev->irq);\r\nnapi_synchronize(&mdp->napi);\r\nsh_eth_write(ndev, 0x0000, EESIPR);\r\nsh_eth_dev_exit(ndev);\r\nsh_eth_ring_free(ndev);\r\nsh_eth_free_dma_buffer(mdp);\r\n}\r\nmdp->num_rx_ring = ring->rx_pending;\r\nmdp->num_tx_ring = ring->tx_pending;\r\nif (netif_running(ndev)) {\r\nret = sh_eth_ring_init(ndev);\r\nif (ret < 0) {\r\nnetdev_err(ndev, "%s: sh_eth_ring_init failed.\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nret = sh_eth_dev_init(ndev, false);\r\nif (ret < 0) {\r\nnetdev_err(ndev, "%s: sh_eth_dev_init failed.\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nmdp->irq_enabled = true;\r\nsh_eth_write(ndev, mdp->cd->eesipr_value, EESIPR);\r\nsh_eth_write(ndev, EDRRR_R, EDRRR);\r\nnetif_device_attach(ndev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sh_eth_open(struct net_device *ndev)\r\n{\r\nint ret = 0;\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\npm_runtime_get_sync(&mdp->pdev->dev);\r\nnapi_enable(&mdp->napi);\r\nret = request_irq(ndev->irq, sh_eth_interrupt,\r\nmdp->cd->irq_flags, ndev->name, ndev);\r\nif (ret) {\r\nnetdev_err(ndev, "Can not assign IRQ number\n");\r\ngoto out_napi_off;\r\n}\r\nret = sh_eth_ring_init(ndev);\r\nif (ret)\r\ngoto out_free_irq;\r\nret = sh_eth_dev_init(ndev, true);\r\nif (ret)\r\ngoto out_free_irq;\r\nret = sh_eth_phy_start(ndev);\r\nif (ret)\r\ngoto out_free_irq;\r\nmdp->is_opened = 1;\r\nreturn ret;\r\nout_free_irq:\r\nfree_irq(ndev->irq, ndev);\r\nout_napi_off:\r\nnapi_disable(&mdp->napi);\r\npm_runtime_put_sync(&mdp->pdev->dev);\r\nreturn ret;\r\n}\r\nstatic void sh_eth_tx_timeout(struct net_device *ndev)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nstruct sh_eth_rxdesc *rxdesc;\r\nint i;\r\nnetif_stop_queue(ndev);\r\nnetif_err(mdp, timer, ndev,\r\n"transmit timed out, status %8.8x, resetting...\n",\r\nsh_eth_read(ndev, EESR));\r\nndev->stats.tx_errors++;\r\nfor (i = 0; i < mdp->num_rx_ring; i++) {\r\nrxdesc = &mdp->rx_ring[i];\r\nrxdesc->status = 0;\r\nrxdesc->addr = 0xBADF00D0;\r\ndev_kfree_skb(mdp->rx_skbuff[i]);\r\nmdp->rx_skbuff[i] = NULL;\r\n}\r\nfor (i = 0; i < mdp->num_tx_ring; i++) {\r\ndev_kfree_skb(mdp->tx_skbuff[i]);\r\nmdp->tx_skbuff[i] = NULL;\r\n}\r\nsh_eth_dev_init(ndev, true);\r\n}\r\nstatic int sh_eth_start_xmit(struct sk_buff *skb, struct net_device *ndev)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nstruct sh_eth_txdesc *txdesc;\r\nu32 entry;\r\nunsigned long flags;\r\nspin_lock_irqsave(&mdp->lock, flags);\r\nif ((mdp->cur_tx - mdp->dirty_tx) >= (mdp->num_tx_ring - 4)) {\r\nif (!sh_eth_txfree(ndev)) {\r\nnetif_warn(mdp, tx_queued, ndev, "TxFD exhausted.\n");\r\nnetif_stop_queue(ndev);\r\nspin_unlock_irqrestore(&mdp->lock, flags);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\n}\r\nspin_unlock_irqrestore(&mdp->lock, flags);\r\nif (skb_put_padto(skb, ETH_ZLEN))\r\nreturn NETDEV_TX_OK;\r\nentry = mdp->cur_tx % mdp->num_tx_ring;\r\nmdp->tx_skbuff[entry] = skb;\r\ntxdesc = &mdp->tx_ring[entry];\r\nif (!mdp->cd->hw_swap)\r\nsh_eth_soft_swap(phys_to_virt(ALIGN(txdesc->addr, 4)),\r\nskb->len + 2);\r\ntxdesc->addr = dma_map_single(&ndev->dev, skb->data, skb->len,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(&ndev->dev, txdesc->addr)) {\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\ntxdesc->buffer_length = skb->len;\r\nwmb();\r\nif (entry >= mdp->num_tx_ring - 1)\r\ntxdesc->status |= cpu_to_edmac(mdp, TD_TACT | TD_TDLE);\r\nelse\r\ntxdesc->status |= cpu_to_edmac(mdp, TD_TACT);\r\nmdp->cur_tx++;\r\nif (!(sh_eth_read(ndev, EDTRR) & sh_eth_get_edtrr_trns(mdp)))\r\nsh_eth_write(ndev, sh_eth_get_edtrr_trns(mdp), EDTRR);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void\r\nsh_eth_update_stat(struct net_device *ndev, unsigned long *stat, int reg)\r\n{\r\nu32 delta = sh_eth_read(ndev, reg);\r\nif (delta) {\r\n*stat += delta;\r\nsh_eth_write(ndev, 0, reg);\r\n}\r\n}\r\nstatic struct net_device_stats *sh_eth_get_stats(struct net_device *ndev)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nif (sh_eth_is_rz_fast_ether(mdp))\r\nreturn &ndev->stats;\r\nif (!mdp->is_opened)\r\nreturn &ndev->stats;\r\nsh_eth_update_stat(ndev, &ndev->stats.tx_dropped, TROCR);\r\nsh_eth_update_stat(ndev, &ndev->stats.collisions, CDCR);\r\nsh_eth_update_stat(ndev, &ndev->stats.tx_carrier_errors, LCCR);\r\nif (sh_eth_is_gether(mdp)) {\r\nsh_eth_update_stat(ndev, &ndev->stats.tx_carrier_errors,\r\nCERCR);\r\nsh_eth_update_stat(ndev, &ndev->stats.tx_carrier_errors,\r\nCEECR);\r\n} else {\r\nsh_eth_update_stat(ndev, &ndev->stats.tx_carrier_errors,\r\nCNDCR);\r\n}\r\nreturn &ndev->stats;\r\n}\r\nstatic int sh_eth_close(struct net_device *ndev)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nnetif_stop_queue(ndev);\r\nmdp->irq_enabled = false;\r\nsynchronize_irq(ndev->irq);\r\nnapi_disable(&mdp->napi);\r\nsh_eth_write(ndev, 0x0000, EESIPR);\r\nsh_eth_dev_exit(ndev);\r\nif (mdp->phydev) {\r\nphy_stop(mdp->phydev);\r\nphy_disconnect(mdp->phydev);\r\nmdp->phydev = NULL;\r\n}\r\nfree_irq(ndev->irq, ndev);\r\nsh_eth_ring_free(ndev);\r\nsh_eth_free_dma_buffer(mdp);\r\npm_runtime_put_sync(&mdp->pdev->dev);\r\nmdp->is_opened = 0;\r\nreturn 0;\r\n}\r\nstatic int sh_eth_do_ioctl(struct net_device *ndev, struct ifreq *rq, int cmd)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nstruct phy_device *phydev = mdp->phydev;\r\nif (!netif_running(ndev))\r\nreturn -EINVAL;\r\nif (!phydev)\r\nreturn -ENODEV;\r\nreturn phy_mii_ioctl(phydev, rq, cmd);\r\n}\r\nstatic void *sh_eth_tsu_get_post_reg_offset(struct sh_eth_private *mdp,\r\nint entry)\r\n{\r\nreturn sh_eth_tsu_get_offset(mdp, TSU_POST1) + (entry / 8 * 4);\r\n}\r\nstatic u32 sh_eth_tsu_get_post_mask(int entry)\r\n{\r\nreturn 0x0f << (28 - ((entry % 8) * 4));\r\n}\r\nstatic u32 sh_eth_tsu_get_post_bit(struct sh_eth_private *mdp, int entry)\r\n{\r\nreturn (0x08 >> (mdp->port << 1)) << (28 - ((entry % 8) * 4));\r\n}\r\nstatic void sh_eth_tsu_enable_cam_entry_post(struct net_device *ndev,\r\nint entry)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nu32 tmp;\r\nvoid *reg_offset;\r\nreg_offset = sh_eth_tsu_get_post_reg_offset(mdp, entry);\r\ntmp = ioread32(reg_offset);\r\niowrite32(tmp | sh_eth_tsu_get_post_bit(mdp, entry), reg_offset);\r\n}\r\nstatic bool sh_eth_tsu_disable_cam_entry_post(struct net_device *ndev,\r\nint entry)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nu32 post_mask, ref_mask, tmp;\r\nvoid *reg_offset;\r\nreg_offset = sh_eth_tsu_get_post_reg_offset(mdp, entry);\r\npost_mask = sh_eth_tsu_get_post_mask(entry);\r\nref_mask = sh_eth_tsu_get_post_bit(mdp, entry) & ~post_mask;\r\ntmp = ioread32(reg_offset);\r\niowrite32(tmp & ~post_mask, reg_offset);\r\nreturn tmp & ref_mask;\r\n}\r\nstatic int sh_eth_tsu_busy(struct net_device *ndev)\r\n{\r\nint timeout = SH_ETH_TSU_TIMEOUT_MS * 100;\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nwhile ((sh_eth_tsu_read(mdp, TSU_ADSBSY) & TSU_ADSBSY_0)) {\r\nudelay(10);\r\ntimeout--;\r\nif (timeout <= 0) {\r\nnetdev_err(ndev, "%s: timeout\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sh_eth_tsu_write_entry(struct net_device *ndev, void *reg,\r\nconst u8 *addr)\r\n{\r\nu32 val;\r\nval = addr[0] << 24 | addr[1] << 16 | addr[2] << 8 | addr[3];\r\niowrite32(val, reg);\r\nif (sh_eth_tsu_busy(ndev) < 0)\r\nreturn -EBUSY;\r\nval = addr[4] << 8 | addr[5];\r\niowrite32(val, reg + 4);\r\nif (sh_eth_tsu_busy(ndev) < 0)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic void sh_eth_tsu_read_entry(void *reg, u8 *addr)\r\n{\r\nu32 val;\r\nval = ioread32(reg);\r\naddr[0] = (val >> 24) & 0xff;\r\naddr[1] = (val >> 16) & 0xff;\r\naddr[2] = (val >> 8) & 0xff;\r\naddr[3] = val & 0xff;\r\nval = ioread32(reg + 4);\r\naddr[4] = (val >> 8) & 0xff;\r\naddr[5] = val & 0xff;\r\n}\r\nstatic int sh_eth_tsu_find_entry(struct net_device *ndev, const u8 *addr)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nvoid *reg_offset = sh_eth_tsu_get_offset(mdp, TSU_ADRH0);\r\nint i;\r\nu8 c_addr[ETH_ALEN];\r\nfor (i = 0; i < SH_ETH_TSU_CAM_ENTRIES; i++, reg_offset += 8) {\r\nsh_eth_tsu_read_entry(reg_offset, c_addr);\r\nif (ether_addr_equal(addr, c_addr))\r\nreturn i;\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic int sh_eth_tsu_find_empty(struct net_device *ndev)\r\n{\r\nu8 blank[ETH_ALEN];\r\nint entry;\r\nmemset(blank, 0, sizeof(blank));\r\nentry = sh_eth_tsu_find_entry(ndev, blank);\r\nreturn (entry < 0) ? -ENOMEM : entry;\r\n}\r\nstatic int sh_eth_tsu_disable_cam_entry_table(struct net_device *ndev,\r\nint entry)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nvoid *reg_offset = sh_eth_tsu_get_offset(mdp, TSU_ADRH0);\r\nint ret;\r\nu8 blank[ETH_ALEN];\r\nsh_eth_tsu_write(mdp, sh_eth_tsu_read(mdp, TSU_TEN) &\r\n~(1 << (31 - entry)), TSU_TEN);\r\nmemset(blank, 0, sizeof(blank));\r\nret = sh_eth_tsu_write_entry(ndev, reg_offset + entry * 8, blank);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int sh_eth_tsu_add_entry(struct net_device *ndev, const u8 *addr)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nvoid *reg_offset = sh_eth_tsu_get_offset(mdp, TSU_ADRH0);\r\nint i, ret;\r\nif (!mdp->cd->tsu)\r\nreturn 0;\r\ni = sh_eth_tsu_find_entry(ndev, addr);\r\nif (i < 0) {\r\ni = sh_eth_tsu_find_empty(ndev);\r\nif (i < 0)\r\nreturn -ENOMEM;\r\nret = sh_eth_tsu_write_entry(ndev, reg_offset + i * 8, addr);\r\nif (ret < 0)\r\nreturn ret;\r\nsh_eth_tsu_write(mdp, sh_eth_tsu_read(mdp, TSU_TEN) |\r\n(1 << (31 - i)), TSU_TEN);\r\n}\r\nsh_eth_tsu_enable_cam_entry_post(ndev, i);\r\nreturn 0;\r\n}\r\nstatic int sh_eth_tsu_del_entry(struct net_device *ndev, const u8 *addr)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nint i, ret;\r\nif (!mdp->cd->tsu)\r\nreturn 0;\r\ni = sh_eth_tsu_find_entry(ndev, addr);\r\nif (i) {\r\nif (sh_eth_tsu_disable_cam_entry_post(ndev, i))\r\ngoto done;\r\nret = sh_eth_tsu_disable_cam_entry_table(ndev, i);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\ndone:\r\nreturn 0;\r\n}\r\nstatic int sh_eth_tsu_purge_all(struct net_device *ndev)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nint i, ret;\r\nif (!mdp->cd->tsu)\r\nreturn 0;\r\nfor (i = 0; i < SH_ETH_TSU_CAM_ENTRIES; i++) {\r\nif (sh_eth_tsu_disable_cam_entry_post(ndev, i))\r\ncontinue;\r\nret = sh_eth_tsu_disable_cam_entry_table(ndev, i);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sh_eth_tsu_purge_mcast(struct net_device *ndev)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nu8 addr[ETH_ALEN];\r\nvoid *reg_offset = sh_eth_tsu_get_offset(mdp, TSU_ADRH0);\r\nint i;\r\nif (!mdp->cd->tsu)\r\nreturn;\r\nfor (i = 0; i < SH_ETH_TSU_CAM_ENTRIES; i++, reg_offset += 8) {\r\nsh_eth_tsu_read_entry(reg_offset, addr);\r\nif (is_multicast_ether_addr(addr))\r\nsh_eth_tsu_del_entry(ndev, addr);\r\n}\r\n}\r\nstatic void sh_eth_set_rx_mode(struct net_device *ndev)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nu32 ecmr_bits;\r\nint mcast_all = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&mdp->lock, flags);\r\necmr_bits = sh_eth_read(ndev, ECMR) & ~ECMR_PRM;\r\nif (mdp->cd->tsu)\r\necmr_bits |= ECMR_MCT;\r\nif (!(ndev->flags & IFF_MULTICAST)) {\r\nsh_eth_tsu_purge_mcast(ndev);\r\nmcast_all = 1;\r\n}\r\nif (ndev->flags & IFF_ALLMULTI) {\r\nsh_eth_tsu_purge_mcast(ndev);\r\necmr_bits &= ~ECMR_MCT;\r\nmcast_all = 1;\r\n}\r\nif (ndev->flags & IFF_PROMISC) {\r\nsh_eth_tsu_purge_all(ndev);\r\necmr_bits = (ecmr_bits & ~ECMR_MCT) | ECMR_PRM;\r\n} else if (mdp->cd->tsu) {\r\nstruct netdev_hw_addr *ha;\r\nnetdev_for_each_mc_addr(ha, ndev) {\r\nif (mcast_all && is_multicast_ether_addr(ha->addr))\r\ncontinue;\r\nif (sh_eth_tsu_add_entry(ndev, ha->addr) < 0) {\r\nif (!mcast_all) {\r\nsh_eth_tsu_purge_mcast(ndev);\r\necmr_bits &= ~ECMR_MCT;\r\nmcast_all = 1;\r\n}\r\n}\r\n}\r\n}\r\nsh_eth_write(ndev, ecmr_bits, ECMR);\r\nspin_unlock_irqrestore(&mdp->lock, flags);\r\n}\r\nstatic int sh_eth_get_vtag_index(struct sh_eth_private *mdp)\r\n{\r\nif (!mdp->port)\r\nreturn TSU_VTAG0;\r\nelse\r\nreturn TSU_VTAG1;\r\n}\r\nstatic int sh_eth_vlan_rx_add_vid(struct net_device *ndev,\r\n__be16 proto, u16 vid)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nint vtag_reg_index = sh_eth_get_vtag_index(mdp);\r\nif (unlikely(!mdp->cd->tsu))\r\nreturn -EPERM;\r\nif (!vid)\r\nreturn 0;\r\nmdp->vlan_num_ids++;\r\nif (mdp->vlan_num_ids > 1) {\r\nsh_eth_tsu_write(mdp, 0, vtag_reg_index);\r\nreturn 0;\r\n}\r\nsh_eth_tsu_write(mdp, TSU_VTAG_ENABLE | (vid & TSU_VTAG_VID_MASK),\r\nvtag_reg_index);\r\nreturn 0;\r\n}\r\nstatic int sh_eth_vlan_rx_kill_vid(struct net_device *ndev,\r\n__be16 proto, u16 vid)\r\n{\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nint vtag_reg_index = sh_eth_get_vtag_index(mdp);\r\nif (unlikely(!mdp->cd->tsu))\r\nreturn -EPERM;\r\nif (!vid)\r\nreturn 0;\r\nmdp->vlan_num_ids--;\r\nsh_eth_tsu_write(mdp, 0, vtag_reg_index);\r\nreturn 0;\r\n}\r\nstatic void sh_eth_tsu_init(struct sh_eth_private *mdp)\r\n{\r\nif (sh_eth_is_rz_fast_ether(mdp)) {\r\nsh_eth_tsu_write(mdp, 0, TSU_TEN);\r\nreturn;\r\n}\r\nsh_eth_tsu_write(mdp, 0, TSU_FWEN0);\r\nsh_eth_tsu_write(mdp, 0, TSU_FWEN1);\r\nsh_eth_tsu_write(mdp, 0, TSU_FCM);\r\nsh_eth_tsu_write(mdp, 0xc, TSU_BSYSL0);\r\nsh_eth_tsu_write(mdp, 0xc, TSU_BSYSL1);\r\nsh_eth_tsu_write(mdp, 0, TSU_PRISL0);\r\nsh_eth_tsu_write(mdp, 0, TSU_PRISL1);\r\nsh_eth_tsu_write(mdp, 0, TSU_FWSL0);\r\nsh_eth_tsu_write(mdp, 0, TSU_FWSL1);\r\nsh_eth_tsu_write(mdp, TSU_FWSLC_POSTENU | TSU_FWSLC_POSTENL, TSU_FWSLC);\r\nif (sh_eth_is_gether(mdp)) {\r\nsh_eth_tsu_write(mdp, 0, TSU_QTAG0);\r\nsh_eth_tsu_write(mdp, 0, TSU_QTAG1);\r\n} else {\r\nsh_eth_tsu_write(mdp, 0, TSU_QTAGM0);\r\nsh_eth_tsu_write(mdp, 0, TSU_QTAGM1);\r\n}\r\nsh_eth_tsu_write(mdp, 0, TSU_FWSR);\r\nsh_eth_tsu_write(mdp, 0, TSU_FWINMK);\r\nsh_eth_tsu_write(mdp, 0, TSU_TEN);\r\nsh_eth_tsu_write(mdp, 0, TSU_POST1);\r\nsh_eth_tsu_write(mdp, 0, TSU_POST2);\r\nsh_eth_tsu_write(mdp, 0, TSU_POST3);\r\nsh_eth_tsu_write(mdp, 0, TSU_POST4);\r\n}\r\nstatic int sh_mdio_release(struct sh_eth_private *mdp)\r\n{\r\nmdiobus_unregister(mdp->mii_bus);\r\nfree_mdio_bitbang(mdp->mii_bus);\r\nreturn 0;\r\n}\r\nstatic int sh_mdio_init(struct sh_eth_private *mdp,\r\nstruct sh_eth_plat_data *pd)\r\n{\r\nint ret, i;\r\nstruct bb_info *bitbang;\r\nstruct platform_device *pdev = mdp->pdev;\r\nstruct device *dev = &mdp->pdev->dev;\r\nbitbang = devm_kzalloc(dev, sizeof(struct bb_info), GFP_KERNEL);\r\nif (!bitbang)\r\nreturn -ENOMEM;\r\nbitbang->addr = mdp->addr + mdp->reg_offset[PIR];\r\nbitbang->set_gate = pd->set_mdio_gate;\r\nbitbang->mdi_msk = PIR_MDI;\r\nbitbang->mdo_msk = PIR_MDO;\r\nbitbang->mmd_msk = PIR_MMD;\r\nbitbang->mdc_msk = PIR_MDC;\r\nbitbang->ctrl.ops = &bb_ops;\r\nmdp->mii_bus = alloc_mdio_bitbang(&bitbang->ctrl);\r\nif (!mdp->mii_bus)\r\nreturn -ENOMEM;\r\nmdp->mii_bus->name = "sh_mii";\r\nmdp->mii_bus->parent = dev;\r\nsnprintf(mdp->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x",\r\npdev->name, pdev->id);\r\nmdp->mii_bus->irq = devm_kmalloc_array(dev, PHY_MAX_ADDR, sizeof(int),\r\nGFP_KERNEL);\r\nif (!mdp->mii_bus->irq) {\r\nret = -ENOMEM;\r\ngoto out_free_bus;\r\n}\r\nif (dev->of_node) {\r\nret = of_mdiobus_register(mdp->mii_bus, dev->of_node);\r\n} else {\r\nfor (i = 0; i < PHY_MAX_ADDR; i++)\r\nmdp->mii_bus->irq[i] = PHY_POLL;\r\nif (pd->phy_irq > 0)\r\nmdp->mii_bus->irq[pd->phy] = pd->phy_irq;\r\nret = mdiobus_register(mdp->mii_bus);\r\n}\r\nif (ret)\r\ngoto out_free_bus;\r\nreturn 0;\r\nout_free_bus:\r\nfree_mdio_bitbang(mdp->mii_bus);\r\nreturn ret;\r\n}\r\nstatic const u16 *sh_eth_get_register_offset(int register_type)\r\n{\r\nconst u16 *reg_offset = NULL;\r\nswitch (register_type) {\r\ncase SH_ETH_REG_GIGABIT:\r\nreg_offset = sh_eth_offset_gigabit;\r\nbreak;\r\ncase SH_ETH_REG_FAST_RZ:\r\nreg_offset = sh_eth_offset_fast_rz;\r\nbreak;\r\ncase SH_ETH_REG_FAST_RCAR:\r\nreg_offset = sh_eth_offset_fast_rcar;\r\nbreak;\r\ncase SH_ETH_REG_FAST_SH4:\r\nreg_offset = sh_eth_offset_fast_sh4;\r\nbreak;\r\ncase SH_ETH_REG_FAST_SH3_SH2:\r\nreg_offset = sh_eth_offset_fast_sh3_sh2;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn reg_offset;\r\n}\r\nstatic struct sh_eth_plat_data *sh_eth_parse_dt(struct device *dev)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nstruct sh_eth_plat_data *pdata;\r\nconst char *mac_addr;\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn NULL;\r\npdata->phy_interface = of_get_phy_mode(np);\r\nmac_addr = of_get_mac_address(np);\r\nif (mac_addr)\r\nmemcpy(pdata->mac_addr, mac_addr, ETH_ALEN);\r\npdata->no_ether_link =\r\nof_property_read_bool(np, "renesas,no-ether-link");\r\npdata->ether_link_active_low =\r\nof_property_read_bool(np, "renesas,ether-link-active-low");\r\nreturn pdata;\r\n}\r\nstatic inline struct sh_eth_plat_data *sh_eth_parse_dt(struct device *dev)\r\n{\r\nreturn NULL;\r\n}\r\nstatic int sh_eth_drv_probe(struct platform_device *pdev)\r\n{\r\nint ret, devno = 0;\r\nstruct resource *res;\r\nstruct net_device *ndev = NULL;\r\nstruct sh_eth_private *mdp = NULL;\r\nstruct sh_eth_plat_data *pd = dev_get_platdata(&pdev->dev);\r\nconst struct platform_device_id *id = platform_get_device_id(pdev);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nndev = alloc_etherdev(sizeof(struct sh_eth_private));\r\nif (!ndev)\r\nreturn -ENOMEM;\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_get_sync(&pdev->dev);\r\ndevno = pdev->id;\r\nif (devno < 0)\r\ndevno = 0;\r\nndev->dma = -1;\r\nret = platform_get_irq(pdev, 0);\r\nif (ret < 0) {\r\nret = -ENODEV;\r\ngoto out_release;\r\n}\r\nndev->irq = ret;\r\nSET_NETDEV_DEV(ndev, &pdev->dev);\r\nmdp = netdev_priv(ndev);\r\nmdp->num_tx_ring = TX_RING_SIZE;\r\nmdp->num_rx_ring = RX_RING_SIZE;\r\nmdp->addr = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(mdp->addr)) {\r\nret = PTR_ERR(mdp->addr);\r\ngoto out_release;\r\n}\r\nndev->base_addr = res->start;\r\nspin_lock_init(&mdp->lock);\r\nmdp->pdev = pdev;\r\nif (pdev->dev.of_node)\r\npd = sh_eth_parse_dt(&pdev->dev);\r\nif (!pd) {\r\ndev_err(&pdev->dev, "no platform data\n");\r\nret = -EINVAL;\r\ngoto out_release;\r\n}\r\nmdp->phy_id = pd->phy;\r\nmdp->phy_interface = pd->phy_interface;\r\nmdp->edmac_endian = pd->edmac_endian;\r\nmdp->no_ether_link = pd->no_ether_link;\r\nmdp->ether_link_active_low = pd->ether_link_active_low;\r\nif (id) {\r\nmdp->cd = (struct sh_eth_cpu_data *)id->driver_data;\r\n} else {\r\nconst struct of_device_id *match;\r\nmatch = of_match_device(of_match_ptr(sh_eth_match_table),\r\n&pdev->dev);\r\nmdp->cd = (struct sh_eth_cpu_data *)match->data;\r\n}\r\nmdp->reg_offset = sh_eth_get_register_offset(mdp->cd->register_type);\r\nif (!mdp->reg_offset) {\r\ndev_err(&pdev->dev, "Unknown register type (%d)\n",\r\nmdp->cd->register_type);\r\nret = -EINVAL;\r\ngoto out_release;\r\n}\r\nsh_eth_set_default_cpu_data(mdp->cd);\r\nif (mdp->cd->tsu)\r\nndev->netdev_ops = &sh_eth_netdev_ops_tsu;\r\nelse\r\nndev->netdev_ops = &sh_eth_netdev_ops;\r\nndev->ethtool_ops = &sh_eth_ethtool_ops;\r\nndev->watchdog_timeo = TX_TIMEOUT;\r\nmdp->msg_enable = SH_ETH_DEF_MSG_ENABLE;\r\nread_mac_address(ndev, pd->mac_addr);\r\nif (!is_valid_ether_addr(ndev->dev_addr)) {\r\ndev_warn(&pdev->dev,\r\n"no valid MAC address supplied, using a random one.\n");\r\neth_hw_addr_random(ndev);\r\n}\r\nif (mdp->cd->tsu) {\r\nstruct resource *rtsu;\r\nrtsu = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nmdp->tsu_addr = devm_ioremap_resource(&pdev->dev, rtsu);\r\nif (IS_ERR(mdp->tsu_addr)) {\r\nret = PTR_ERR(mdp->tsu_addr);\r\ngoto out_release;\r\n}\r\nmdp->port = devno % 2;\r\nndev->features = NETIF_F_HW_VLAN_CTAG_FILTER;\r\n}\r\nif (!devno || pd->needs_init) {\r\nif (mdp->cd->chip_reset)\r\nmdp->cd->chip_reset(ndev);\r\nif (mdp->cd->tsu) {\r\nsh_eth_tsu_init(mdp);\r\n}\r\n}\r\nif (mdp->cd->rmiimode)\r\nsh_eth_write(ndev, 0x1, RMIIMODE);\r\nret = sh_mdio_init(mdp, pd);\r\nif (ret) {\r\ndev_err(&ndev->dev, "failed to initialise MDIO\n");\r\ngoto out_release;\r\n}\r\nnetif_napi_add(ndev, &mdp->napi, sh_eth_poll, 64);\r\nret = register_netdev(ndev);\r\nif (ret)\r\ngoto out_napi_del;\r\nnetdev_info(ndev, "Base address at 0x%x, %pM, IRQ %d.\n",\r\n(u32)ndev->base_addr, ndev->dev_addr, ndev->irq);\r\npm_runtime_put(&pdev->dev);\r\nplatform_set_drvdata(pdev, ndev);\r\nreturn ret;\r\nout_napi_del:\r\nnetif_napi_del(&mdp->napi);\r\nsh_mdio_release(mdp);\r\nout_release:\r\nif (ndev)\r\nfree_netdev(ndev);\r\npm_runtime_put(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn ret;\r\n}\r\nstatic int sh_eth_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct sh_eth_private *mdp = netdev_priv(ndev);\r\nunregister_netdev(ndev);\r\nnetif_napi_del(&mdp->napi);\r\nsh_mdio_release(mdp);\r\npm_runtime_disable(&pdev->dev);\r\nfree_netdev(ndev);\r\nreturn 0;\r\n}\r\nstatic int sh_eth_suspend(struct device *dev)\r\n{\r\nstruct net_device *ndev = dev_get_drvdata(dev);\r\nint ret = 0;\r\nif (netif_running(ndev)) {\r\nnetif_device_detach(ndev);\r\nret = sh_eth_close(ndev);\r\n}\r\nreturn ret;\r\n}\r\nstatic int sh_eth_resume(struct device *dev)\r\n{\r\nstruct net_device *ndev = dev_get_drvdata(dev);\r\nint ret = 0;\r\nif (netif_running(ndev)) {\r\nret = sh_eth_open(ndev);\r\nif (ret < 0)\r\nreturn ret;\r\nnetif_device_attach(ndev);\r\n}\r\nreturn ret;\r\n}\r\nstatic int sh_eth_runtime_nop(struct device *dev)\r\n{\r\nreturn 0;\r\n}
