static int mcp23008_read(struct mcp23s08 *mcp, unsigned reg)\r\n{\r\nreturn i2c_smbus_read_byte_data(mcp->data, reg);\r\n}\r\nstatic int mcp23008_write(struct mcp23s08 *mcp, unsigned reg, unsigned val)\r\n{\r\nreturn i2c_smbus_write_byte_data(mcp->data, reg, val);\r\n}\r\nstatic int\r\nmcp23008_read_regs(struct mcp23s08 *mcp, unsigned reg, u16 *vals, unsigned n)\r\n{\r\nwhile (n--) {\r\nint ret = mcp23008_read(mcp, reg++);\r\nif (ret < 0)\r\nreturn ret;\r\n*vals++ = ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mcp23017_read(struct mcp23s08 *mcp, unsigned reg)\r\n{\r\nreturn i2c_smbus_read_word_data(mcp->data, reg << 1);\r\n}\r\nstatic int mcp23017_write(struct mcp23s08 *mcp, unsigned reg, unsigned val)\r\n{\r\nreturn i2c_smbus_write_word_data(mcp->data, reg << 1, val);\r\n}\r\nstatic int\r\nmcp23017_read_regs(struct mcp23s08 *mcp, unsigned reg, u16 *vals, unsigned n)\r\n{\r\nwhile (n--) {\r\nint ret = mcp23017_read(mcp, reg++);\r\nif (ret < 0)\r\nreturn ret;\r\n*vals++ = ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mcp23s08_read(struct mcp23s08 *mcp, unsigned reg)\r\n{\r\nu8 tx[2], rx[1];\r\nint status;\r\ntx[0] = mcp->addr | 0x01;\r\ntx[1] = reg;\r\nstatus = spi_write_then_read(mcp->data, tx, sizeof(tx), rx, sizeof(rx));\r\nreturn (status < 0) ? status : rx[0];\r\n}\r\nstatic int mcp23s08_write(struct mcp23s08 *mcp, unsigned reg, unsigned val)\r\n{\r\nu8 tx[3];\r\ntx[0] = mcp->addr;\r\ntx[1] = reg;\r\ntx[2] = val;\r\nreturn spi_write_then_read(mcp->data, tx, sizeof(tx), NULL, 0);\r\n}\r\nstatic int\r\nmcp23s08_read_regs(struct mcp23s08 *mcp, unsigned reg, u16 *vals, unsigned n)\r\n{\r\nu8 tx[2], *tmp;\r\nint status;\r\nif ((n + reg) > sizeof(mcp->cache))\r\nreturn -EINVAL;\r\ntx[0] = mcp->addr | 0x01;\r\ntx[1] = reg;\r\ntmp = (u8 *)vals;\r\nstatus = spi_write_then_read(mcp->data, tx, sizeof(tx), tmp, n);\r\nif (status >= 0) {\r\nwhile (n--)\r\nvals[n] = tmp[n];\r\n}\r\nreturn status;\r\n}\r\nstatic int mcp23s17_read(struct mcp23s08 *mcp, unsigned reg)\r\n{\r\nu8 tx[2], rx[2];\r\nint status;\r\ntx[0] = mcp->addr | 0x01;\r\ntx[1] = reg << 1;\r\nstatus = spi_write_then_read(mcp->data, tx, sizeof(tx), rx, sizeof(rx));\r\nreturn (status < 0) ? status : (rx[0] | (rx[1] << 8));\r\n}\r\nstatic int mcp23s17_write(struct mcp23s08 *mcp, unsigned reg, unsigned val)\r\n{\r\nu8 tx[4];\r\ntx[0] = mcp->addr;\r\ntx[1] = reg << 1;\r\ntx[2] = val;\r\ntx[3] = val >> 8;\r\nreturn spi_write_then_read(mcp->data, tx, sizeof(tx), NULL, 0);\r\n}\r\nstatic int\r\nmcp23s17_read_regs(struct mcp23s08 *mcp, unsigned reg, u16 *vals, unsigned n)\r\n{\r\nu8 tx[2];\r\nint status;\r\nif ((n + reg) > sizeof(mcp->cache))\r\nreturn -EINVAL;\r\ntx[0] = mcp->addr | 0x01;\r\ntx[1] = reg << 1;\r\nstatus = spi_write_then_read(mcp->data, tx, sizeof(tx),\r\n(u8 *)vals, n * 2);\r\nif (status >= 0) {\r\nwhile (n--)\r\nvals[n] = __le16_to_cpu((__le16)vals[n]);\r\n}\r\nreturn status;\r\n}\r\nstatic int mcp23s08_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct mcp23s08 *mcp = container_of(chip, struct mcp23s08, chip);\r\nint status;\r\nmutex_lock(&mcp->lock);\r\nmcp->cache[MCP_IODIR] |= (1 << offset);\r\nstatus = mcp->ops->write(mcp, MCP_IODIR, mcp->cache[MCP_IODIR]);\r\nmutex_unlock(&mcp->lock);\r\nreturn status;\r\n}\r\nstatic int mcp23s08_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct mcp23s08 *mcp = container_of(chip, struct mcp23s08, chip);\r\nint status;\r\nmutex_lock(&mcp->lock);\r\nstatus = mcp->ops->read(mcp, MCP_GPIO);\r\nif (status < 0)\r\nstatus = 0;\r\nelse {\r\nmcp->cache[MCP_GPIO] = status;\r\nstatus = !!(status & (1 << offset));\r\n}\r\nmutex_unlock(&mcp->lock);\r\nreturn status;\r\n}\r\nstatic int __mcp23s08_set(struct mcp23s08 *mcp, unsigned mask, int value)\r\n{\r\nunsigned olat = mcp->cache[MCP_OLAT];\r\nif (value)\r\nolat |= mask;\r\nelse\r\nolat &= ~mask;\r\nmcp->cache[MCP_OLAT] = olat;\r\nreturn mcp->ops->write(mcp, MCP_OLAT, olat);\r\n}\r\nstatic void mcp23s08_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct mcp23s08 *mcp = container_of(chip, struct mcp23s08, chip);\r\nunsigned mask = 1 << offset;\r\nmutex_lock(&mcp->lock);\r\n__mcp23s08_set(mcp, mask, value);\r\nmutex_unlock(&mcp->lock);\r\n}\r\nstatic int\r\nmcp23s08_direction_output(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct mcp23s08 *mcp = container_of(chip, struct mcp23s08, chip);\r\nunsigned mask = 1 << offset;\r\nint status;\r\nmutex_lock(&mcp->lock);\r\nstatus = __mcp23s08_set(mcp, mask, value);\r\nif (status == 0) {\r\nmcp->cache[MCP_IODIR] &= ~mask;\r\nstatus = mcp->ops->write(mcp, MCP_IODIR, mcp->cache[MCP_IODIR]);\r\n}\r\nmutex_unlock(&mcp->lock);\r\nreturn status;\r\n}\r\nstatic irqreturn_t mcp23s08_irq(int irq, void *data)\r\n{\r\nstruct mcp23s08 *mcp = data;\r\nint intcap, intf, i;\r\nunsigned int child_irq;\r\nmutex_lock(&mcp->lock);\r\nintf = mcp->ops->read(mcp, MCP_INTF);\r\nif (intf < 0) {\r\nmutex_unlock(&mcp->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nmcp->cache[MCP_INTF] = intf;\r\nintcap = mcp->ops->read(mcp, MCP_INTCAP);\r\nif (intcap < 0) {\r\nmutex_unlock(&mcp->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nmcp->cache[MCP_INTCAP] = intcap;\r\nmutex_unlock(&mcp->lock);\r\nfor (i = 0; i < mcp->chip.ngpio; i++) {\r\nif ((BIT(i) & mcp->cache[MCP_INTF]) &&\r\n((BIT(i) & intcap & mcp->irq_rise) ||\r\n(mcp->irq_fall & ~intcap & BIT(i)))) {\r\nchild_irq = irq_find_mapping(mcp->irq_domain, i);\r\nhandle_nested_irq(child_irq);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mcp23s08_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct mcp23s08 *mcp = container_of(chip, struct mcp23s08, chip);\r\nreturn irq_find_mapping(mcp->irq_domain, offset);\r\n}\r\nstatic void mcp23s08_irq_mask(struct irq_data *data)\r\n{\r\nstruct mcp23s08 *mcp = irq_data_get_irq_chip_data(data);\r\nunsigned int pos = data->hwirq;\r\nmcp->cache[MCP_GPINTEN] &= ~BIT(pos);\r\n}\r\nstatic void mcp23s08_irq_unmask(struct irq_data *data)\r\n{\r\nstruct mcp23s08 *mcp = irq_data_get_irq_chip_data(data);\r\nunsigned int pos = data->hwirq;\r\nmcp->cache[MCP_GPINTEN] |= BIT(pos);\r\n}\r\nstatic int mcp23s08_irq_set_type(struct irq_data *data, unsigned int type)\r\n{\r\nstruct mcp23s08 *mcp = irq_data_get_irq_chip_data(data);\r\nunsigned int pos = data->hwirq;\r\nint status = 0;\r\nif ((type & IRQ_TYPE_EDGE_BOTH) == IRQ_TYPE_EDGE_BOTH) {\r\nmcp->cache[MCP_INTCON] &= ~BIT(pos);\r\nmcp->irq_rise |= BIT(pos);\r\nmcp->irq_fall |= BIT(pos);\r\n} else if (type & IRQ_TYPE_EDGE_RISING) {\r\nmcp->cache[MCP_INTCON] &= ~BIT(pos);\r\nmcp->irq_rise |= BIT(pos);\r\nmcp->irq_fall &= ~BIT(pos);\r\n} else if (type & IRQ_TYPE_EDGE_FALLING) {\r\nmcp->cache[MCP_INTCON] &= ~BIT(pos);\r\nmcp->irq_rise &= ~BIT(pos);\r\nmcp->irq_fall |= BIT(pos);\r\n} else\r\nreturn -EINVAL;\r\nreturn status;\r\n}\r\nstatic void mcp23s08_irq_bus_lock(struct irq_data *data)\r\n{\r\nstruct mcp23s08 *mcp = irq_data_get_irq_chip_data(data);\r\nmutex_lock(&mcp->irq_lock);\r\n}\r\nstatic void mcp23s08_irq_bus_unlock(struct irq_data *data)\r\n{\r\nstruct mcp23s08 *mcp = irq_data_get_irq_chip_data(data);\r\nmutex_lock(&mcp->lock);\r\nmcp->ops->write(mcp, MCP_GPINTEN, mcp->cache[MCP_GPINTEN]);\r\nmcp->ops->write(mcp, MCP_DEFVAL, mcp->cache[MCP_DEFVAL]);\r\nmcp->ops->write(mcp, MCP_INTCON, mcp->cache[MCP_INTCON]);\r\nmutex_unlock(&mcp->lock);\r\nmutex_unlock(&mcp->irq_lock);\r\n}\r\nstatic int mcp23s08_irq_reqres(struct irq_data *data)\r\n{\r\nstruct mcp23s08 *mcp = irq_data_get_irq_chip_data(data);\r\nif (gpiochip_lock_as_irq(&mcp->chip, data->hwirq)) {\r\ndev_err(mcp->chip.dev,\r\n"unable to lock HW IRQ %lu for IRQ usage\n",\r\ndata->hwirq);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mcp23s08_irq_relres(struct irq_data *data)\r\n{\r\nstruct mcp23s08 *mcp = irq_data_get_irq_chip_data(data);\r\ngpiochip_unlock_as_irq(&mcp->chip, data->hwirq);\r\n}\r\nstatic int mcp23s08_irq_setup(struct mcp23s08 *mcp)\r\n{\r\nstruct gpio_chip *chip = &mcp->chip;\r\nint err, irq, j;\r\nunsigned long irqflags = IRQF_ONESHOT | IRQF_SHARED;\r\nmutex_init(&mcp->irq_lock);\r\nmcp->irq_domain = irq_domain_add_linear(chip->dev->of_node, chip->ngpio,\r\n&irq_domain_simple_ops, mcp);\r\nif (!mcp->irq_domain)\r\nreturn -ENODEV;\r\nif (mcp->irq_active_high)\r\nirqflags |= IRQF_TRIGGER_HIGH;\r\nelse\r\nirqflags |= IRQF_TRIGGER_LOW;\r\nerr = devm_request_threaded_irq(chip->dev, mcp->irq, NULL, mcp23s08_irq,\r\nirqflags, dev_name(chip->dev), mcp);\r\nif (err != 0) {\r\ndev_err(chip->dev, "unable to request IRQ#%d: %d\n",\r\nmcp->irq, err);\r\nreturn err;\r\n}\r\nchip->to_irq = mcp23s08_gpio_to_irq;\r\nfor (j = 0; j < mcp->chip.ngpio; j++) {\r\nirq = irq_create_mapping(mcp->irq_domain, j);\r\nirq_set_lockdep_class(irq, &gpio_lock_class);\r\nirq_set_chip_data(irq, mcp);\r\nirq_set_chip(irq, &mcp23s08_irq_chip);\r\nirq_set_nested_thread(irq, true);\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(irq, IRQF_VALID);\r\n#else\r\nirq_set_noprobe(irq);\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic void mcp23s08_irq_teardown(struct mcp23s08 *mcp)\r\n{\r\nunsigned int irq, i;\r\nfor (i = 0; i < mcp->chip.ngpio; i++) {\r\nirq = irq_find_mapping(mcp->irq_domain, i);\r\nif (irq > 0)\r\nirq_dispose_mapping(irq);\r\n}\r\nirq_domain_remove(mcp->irq_domain);\r\n}\r\nstatic void mcp23s08_dbg_show(struct seq_file *s, struct gpio_chip *chip)\r\n{\r\nstruct mcp23s08 *mcp;\r\nchar bank;\r\nint t;\r\nunsigned mask;\r\nmcp = container_of(chip, struct mcp23s08, chip);\r\nbank = '0' + ((mcp->addr >> 1) & 0x7);\r\nmutex_lock(&mcp->lock);\r\nt = mcp->ops->read_regs(mcp, 0, mcp->cache, ARRAY_SIZE(mcp->cache));\r\nif (t < 0) {\r\nseq_printf(s, " I/O ERROR %d\n", t);\r\ngoto done;\r\n}\r\nfor (t = 0, mask = 1; t < chip->ngpio; t++, mask <<= 1) {\r\nconst char *label;\r\nlabel = gpiochip_is_requested(chip, t);\r\nif (!label)\r\ncontinue;\r\nseq_printf(s, " gpio-%-3d P%c.%d (%-12s) %s %s %s",\r\nchip->base + t, bank, t, label,\r\n(mcp->cache[MCP_IODIR] & mask) ? "in " : "out",\r\n(mcp->cache[MCP_GPIO] & mask) ? "hi" : "lo",\r\n(mcp->cache[MCP_GPPU] & mask) ? "up" : " ");\r\nseq_puts(s, "\n");\r\n}\r\ndone:\r\nmutex_unlock(&mcp->lock);\r\n}\r\nstatic int mcp23s08_probe_one(struct mcp23s08 *mcp, struct device *dev,\r\nvoid *data, unsigned addr, unsigned type,\r\nstruct mcp23s08_platform_data *pdata, int cs)\r\n{\r\nint status;\r\nbool mirror = false;\r\nmutex_init(&mcp->lock);\r\nmcp->data = data;\r\nmcp->addr = addr;\r\nmcp->irq_active_high = false;\r\nmcp->chip.direction_input = mcp23s08_direction_input;\r\nmcp->chip.get = mcp23s08_get;\r\nmcp->chip.direction_output = mcp23s08_direction_output;\r\nmcp->chip.set = mcp23s08_set;\r\nmcp->chip.dbg_show = mcp23s08_dbg_show;\r\n#ifdef CONFIG_OF\r\nmcp->chip.of_gpio_n_cells = 2;\r\nmcp->chip.of_node = dev->of_node;\r\n#endif\r\nswitch (type) {\r\n#ifdef CONFIG_SPI_MASTER\r\ncase MCP_TYPE_S08:\r\nmcp->ops = &mcp23s08_ops;\r\nmcp->chip.ngpio = 8;\r\nmcp->chip.label = "mcp23s08";\r\nbreak;\r\ncase MCP_TYPE_S17:\r\nmcp->ops = &mcp23s17_ops;\r\nmcp->chip.ngpio = 16;\r\nmcp->chip.label = "mcp23s17";\r\nbreak;\r\n#endif\r\n#if IS_ENABLED(CONFIG_I2C)\r\ncase MCP_TYPE_008:\r\nmcp->ops = &mcp23008_ops;\r\nmcp->chip.ngpio = 8;\r\nmcp->chip.label = "mcp23008";\r\nbreak;\r\ncase MCP_TYPE_017:\r\nmcp->ops = &mcp23017_ops;\r\nmcp->chip.ngpio = 16;\r\nmcp->chip.label = "mcp23017";\r\nbreak;\r\n#endif\r\ndefault:\r\ndev_err(dev, "invalid device type (%d)\n", type);\r\nreturn -EINVAL;\r\n}\r\nmcp->chip.base = pdata->base;\r\nmcp->chip.can_sleep = true;\r\nmcp->chip.dev = dev;\r\nmcp->chip.owner = THIS_MODULE;\r\nstatus = mcp->ops->read(mcp, MCP_IOCON);\r\nif (status < 0)\r\ngoto fail;\r\nmcp->irq_controller = pdata->irq_controller;\r\nif (mcp->irq && mcp->irq_controller) {\r\nmcp->irq_active_high =\r\nof_property_read_bool(mcp->chip.dev->of_node,\r\n"microchip,irq-active-high");\r\nif (type == MCP_TYPE_017)\r\nmirror = pdata->mirror;\r\n}\r\nif ((status & IOCON_SEQOP) || !(status & IOCON_HAEN) || mirror ||\r\nmcp->irq_active_high) {\r\nstatus &= ~(IOCON_SEQOP | (IOCON_SEQOP << 8));\r\nstatus |= IOCON_HAEN | (IOCON_HAEN << 8);\r\nif (mcp->irq_active_high)\r\nstatus |= IOCON_INTPOL | (IOCON_INTPOL << 8);\r\nelse\r\nstatus &= ~(IOCON_INTPOL | (IOCON_INTPOL << 8));\r\nif (mirror)\r\nstatus |= IOCON_MIRROR | (IOCON_MIRROR << 8);\r\nstatus = mcp->ops->write(mcp, MCP_IOCON, status);\r\nif (status < 0)\r\ngoto fail;\r\n}\r\nstatus = mcp->ops->write(mcp, MCP_GPPU, pdata->chip[cs].pullups);\r\nif (status < 0)\r\ngoto fail;\r\nstatus = mcp->ops->read_regs(mcp, 0, mcp->cache, ARRAY_SIZE(mcp->cache));\r\nif (status < 0)\r\ngoto fail;\r\nif (mcp->cache[MCP_IPOL] != 0) {\r\nmcp->cache[MCP_IPOL] = 0;\r\nstatus = mcp->ops->write(mcp, MCP_IPOL, 0);\r\nif (status < 0)\r\ngoto fail;\r\n}\r\nif (mcp->cache[MCP_GPINTEN] != 0) {\r\nmcp->cache[MCP_GPINTEN] = 0;\r\nstatus = mcp->ops->write(mcp, MCP_GPINTEN, 0);\r\nif (status < 0)\r\ngoto fail;\r\n}\r\nstatus = gpiochip_add(&mcp->chip);\r\nif (status < 0)\r\ngoto fail;\r\nif (mcp->irq && mcp->irq_controller) {\r\nstatus = mcp23s08_irq_setup(mcp);\r\nif (status) {\r\nmcp23s08_irq_teardown(mcp);\r\ngoto fail;\r\n}\r\n}\r\nfail:\r\nif (status < 0)\r\ndev_dbg(dev, "can't setup chip %d, --> %d\n",\r\naddr, status);\r\nreturn status;\r\n}\r\nstatic int mcp230xx_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct mcp23s08_platform_data *pdata, local_pdata;\r\nstruct mcp23s08 *mcp;\r\nint status;\r\nconst struct of_device_id *match;\r\nmatch = of_match_device(of_match_ptr(mcp23s08_i2c_of_match),\r\n&client->dev);\r\nif (match) {\r\npdata = &local_pdata;\r\npdata->base = -1;\r\npdata->chip[0].pullups = 0;\r\npdata->irq_controller = of_property_read_bool(\r\nclient->dev.of_node,\r\n"interrupt-controller");\r\npdata->mirror = of_property_read_bool(client->dev.of_node,\r\n"microchip,irq-mirror");\r\nclient->irq = irq_of_parse_and_map(client->dev.of_node, 0);\r\n} else {\r\npdata = dev_get_platdata(&client->dev);\r\nif (!pdata) {\r\npdata = devm_kzalloc(&client->dev,\r\nsizeof(struct mcp23s08_platform_data),\r\nGFP_KERNEL);\r\npdata->base = -1;\r\n}\r\n}\r\nmcp = kzalloc(sizeof(*mcp), GFP_KERNEL);\r\nif (!mcp)\r\nreturn -ENOMEM;\r\nmcp->irq = client->irq;\r\nstatus = mcp23s08_probe_one(mcp, &client->dev, client, client->addr,\r\nid->driver_data, pdata, 0);\r\nif (status)\r\ngoto fail;\r\ni2c_set_clientdata(client, mcp);\r\nreturn 0;\r\nfail:\r\nkfree(mcp);\r\nreturn status;\r\n}\r\nstatic int mcp230xx_remove(struct i2c_client *client)\r\n{\r\nstruct mcp23s08 *mcp = i2c_get_clientdata(client);\r\nif (client->irq && mcp->irq_controller)\r\nmcp23s08_irq_teardown(mcp);\r\ngpiochip_remove(&mcp->chip);\r\nkfree(mcp);\r\nreturn 0;\r\n}\r\nstatic int __init mcp23s08_i2c_init(void)\r\n{\r\nreturn i2c_add_driver(&mcp230xx_driver);\r\n}\r\nstatic void mcp23s08_i2c_exit(void)\r\n{\r\ni2c_del_driver(&mcp230xx_driver);\r\n}\r\nstatic int __init mcp23s08_i2c_init(void) { return 0; }\r\nstatic void mcp23s08_i2c_exit(void) { }\r\nstatic int mcp23s08_probe(struct spi_device *spi)\r\n{\r\nstruct mcp23s08_platform_data *pdata, local_pdata;\r\nunsigned addr;\r\nint chips = 0;\r\nstruct mcp23s08_driver_data *data;\r\nint status, type;\r\nunsigned ngpio = 0;\r\nconst struct of_device_id *match;\r\nu32 spi_present_mask = 0;\r\nmatch = of_match_device(of_match_ptr(mcp23s08_spi_of_match), &spi->dev);\r\nif (match) {\r\ntype = (int)(uintptr_t)match->data;\r\nstatus = of_property_read_u32(spi->dev.of_node,\r\n"microchip,spi-present-mask", &spi_present_mask);\r\nif (status) {\r\nstatus = of_property_read_u32(spi->dev.of_node,\r\n"mcp,spi-present-mask", &spi_present_mask);\r\nif (status) {\r\ndev_err(&spi->dev,\r\n"DT has no spi-present-mask\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nif ((spi_present_mask <= 0) || (spi_present_mask >= 256)) {\r\ndev_err(&spi->dev, "invalid spi-present-mask\n");\r\nreturn -ENODEV;\r\n}\r\npdata = &local_pdata;\r\npdata->base = -1;\r\nfor (addr = 0; addr < ARRAY_SIZE(pdata->chip); addr++) {\r\npdata->chip[addr].pullups = 0;\r\nif (spi_present_mask & (1 << addr))\r\nchips++;\r\n}\r\npdata->irq_controller = of_property_read_bool(\r\nspi->dev.of_node,\r\n"interrupt-controller");\r\npdata->mirror = of_property_read_bool(spi->dev.of_node,\r\n"microchip,irq-mirror");\r\n} else {\r\ntype = spi_get_device_id(spi)->driver_data;\r\npdata = dev_get_platdata(&spi->dev);\r\nif (!pdata) {\r\npdata = devm_kzalloc(&spi->dev,\r\nsizeof(struct mcp23s08_platform_data),\r\nGFP_KERNEL);\r\npdata->base = -1;\r\n}\r\nfor (addr = 0; addr < ARRAY_SIZE(pdata->chip); addr++) {\r\nif (!pdata->chip[addr].is_present)\r\ncontinue;\r\nchips++;\r\nif ((type == MCP_TYPE_S08) && (addr > 3)) {\r\ndev_err(&spi->dev,\r\n"mcp23s08 only supports address 0..3\n");\r\nreturn -EINVAL;\r\n}\r\nspi_present_mask |= 1 << addr;\r\n}\r\n}\r\nif (!chips)\r\nreturn -ENODEV;\r\ndata = devm_kzalloc(&spi->dev,\r\nsizeof(*data) + chips * sizeof(struct mcp23s08),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nspi_set_drvdata(spi, data);\r\nspi->irq = irq_of_parse_and_map(spi->dev.of_node, 0);\r\nfor (addr = 0; addr < ARRAY_SIZE(pdata->chip); addr++) {\r\nif (!(spi_present_mask & (1 << addr)))\r\ncontinue;\r\nchips--;\r\ndata->mcp[addr] = &data->chip[chips];\r\ndata->mcp[addr]->irq = spi->irq;\r\nstatus = mcp23s08_probe_one(data->mcp[addr], &spi->dev, spi,\r\n0x40 | (addr << 1), type, pdata,\r\naddr);\r\nif (status < 0)\r\ngoto fail;\r\nif (pdata->base != -1)\r\npdata->base += (type == MCP_TYPE_S17) ? 16 : 8;\r\nngpio += (type == MCP_TYPE_S17) ? 16 : 8;\r\n}\r\ndata->ngpio = ngpio;\r\nreturn 0;\r\nfail:\r\nfor (addr = 0; addr < ARRAY_SIZE(data->mcp); addr++) {\r\nif (!data->mcp[addr])\r\ncontinue;\r\ngpiochip_remove(&data->mcp[addr]->chip);\r\n}\r\nreturn status;\r\n}\r\nstatic int mcp23s08_remove(struct spi_device *spi)\r\n{\r\nstruct mcp23s08_driver_data *data = spi_get_drvdata(spi);\r\nunsigned addr;\r\nfor (addr = 0; addr < ARRAY_SIZE(data->mcp); addr++) {\r\nif (!data->mcp[addr])\r\ncontinue;\r\nif (spi->irq && data->mcp[addr]->irq_controller)\r\nmcp23s08_irq_teardown(data->mcp[addr]);\r\ngpiochip_remove(&data->mcp[addr]->chip);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init mcp23s08_spi_init(void)\r\n{\r\nreturn spi_register_driver(&mcp23s08_driver);\r\n}\r\nstatic void mcp23s08_spi_exit(void)\r\n{\r\nspi_unregister_driver(&mcp23s08_driver);\r\n}\r\nstatic int __init mcp23s08_spi_init(void) { return 0; }\r\nstatic void mcp23s08_spi_exit(void) { }\r\nstatic int __init mcp23s08_init(void)\r\n{\r\nint ret;\r\nret = mcp23s08_spi_init();\r\nif (ret)\r\ngoto spi_fail;\r\nret = mcp23s08_i2c_init();\r\nif (ret)\r\ngoto i2c_fail;\r\nreturn 0;\r\ni2c_fail:\r\nmcp23s08_spi_exit();\r\nspi_fail:\r\nreturn ret;\r\n}\r\nstatic void __exit mcp23s08_exit(void)\r\n{\r\nmcp23s08_spi_exit();\r\nmcp23s08_i2c_exit();\r\n}
