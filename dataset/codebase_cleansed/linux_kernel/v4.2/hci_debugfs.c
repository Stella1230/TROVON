static int features_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, features_show, inode->i_private);\r\n}\r\nstatic int device_id_show(struct seq_file *f, void *ptr)\r\n{\r\nstruct hci_dev *hdev = f->private;\r\nhci_dev_lock(hdev);\r\nseq_printf(f, "%4.4x:%4.4x:%4.4x:%4.4x\n", hdev->devid_source,\r\nhdev->devid_vendor, hdev->devid_product, hdev->devid_version);\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int device_id_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, device_id_show, inode->i_private);\r\n}\r\nstatic int device_list_show(struct seq_file *f, void *ptr)\r\n{\r\nstruct hci_dev *hdev = f->private;\r\nstruct hci_conn_params *p;\r\nstruct bdaddr_list *b;\r\nhci_dev_lock(hdev);\r\nlist_for_each_entry(b, &hdev->whitelist, list)\r\nseq_printf(f, "%pMR (type %u)\n", &b->bdaddr, b->bdaddr_type);\r\nlist_for_each_entry(p, &hdev->le_conn_params, list) {\r\nseq_printf(f, "%pMR (type %u) %u\n", &p->addr, p->addr_type,\r\np->auto_connect);\r\n}\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int device_list_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, device_list_show, inode->i_private);\r\n}\r\nstatic int blacklist_show(struct seq_file *f, void *p)\r\n{\r\nstruct hci_dev *hdev = f->private;\r\nstruct bdaddr_list *b;\r\nhci_dev_lock(hdev);\r\nlist_for_each_entry(b, &hdev->blacklist, list)\r\nseq_printf(f, "%pMR (type %u)\n", &b->bdaddr, b->bdaddr_type);\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int blacklist_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, blacklist_show, inode->i_private);\r\n}\r\nstatic int uuids_show(struct seq_file *f, void *p)\r\n{\r\nstruct hci_dev *hdev = f->private;\r\nstruct bt_uuid *uuid;\r\nhci_dev_lock(hdev);\r\nlist_for_each_entry(uuid, &hdev->uuids, list) {\r\nu8 i, val[16];\r\nfor (i = 0; i < 16; i++)\r\nval[i] = uuid->uuid[15 - i];\r\nseq_printf(f, "%pUb\n", val);\r\n}\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int uuids_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, uuids_show, inode->i_private);\r\n}\r\nstatic int remote_oob_show(struct seq_file *f, void *ptr)\r\n{\r\nstruct hci_dev *hdev = f->private;\r\nstruct oob_data *data;\r\nhci_dev_lock(hdev);\r\nlist_for_each_entry(data, &hdev->remote_oob_data, list) {\r\nseq_printf(f, "%pMR (type %u) %u %*phN %*phN %*phN %*phN\n",\r\n&data->bdaddr, data->bdaddr_type, data->present,\r\n16, data->hash192, 16, data->rand192,\r\n16, data->hash256, 16, data->rand256);\r\n}\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int remote_oob_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, remote_oob_show, inode->i_private);\r\n}\r\nstatic int conn_info_min_age_set(void *data, u64 val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nif (val == 0 || val > hdev->conn_info_max_age)\r\nreturn -EINVAL;\r\nhci_dev_lock(hdev);\r\nhdev->conn_info_min_age = val;\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int conn_info_min_age_get(void *data, u64 *val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nhci_dev_lock(hdev);\r\n*val = hdev->conn_info_min_age;\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int conn_info_max_age_set(void *data, u64 val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nif (val == 0 || val < hdev->conn_info_min_age)\r\nreturn -EINVAL;\r\nhci_dev_lock(hdev);\r\nhdev->conn_info_max_age = val;\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int conn_info_max_age_get(void *data, u64 *val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nhci_dev_lock(hdev);\r\n*val = hdev->conn_info_max_age;\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic ssize_t use_debug_keys_read(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct hci_dev *hdev = file->private_data;\r\nchar buf[3];\r\nbuf[0] = hci_dev_test_flag(hdev, HCI_USE_DEBUG_KEYS) ? 'Y': 'N';\r\nbuf[1] = '\n';\r\nbuf[2] = '\0';\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, 2);\r\n}\r\nstatic ssize_t sc_only_mode_read(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct hci_dev *hdev = file->private_data;\r\nchar buf[3];\r\nbuf[0] = hci_dev_test_flag(hdev, HCI_SC_ONLY) ? 'Y': 'N';\r\nbuf[1] = '\n';\r\nbuf[2] = '\0';\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, 2);\r\n}\r\nvoid hci_debugfs_create_common(struct hci_dev *hdev)\r\n{\r\ndebugfs_create_file("features", 0444, hdev->debugfs, hdev,\r\n&features_fops);\r\ndebugfs_create_u16("manufacturer", 0444, hdev->debugfs,\r\n&hdev->manufacturer);\r\ndebugfs_create_u8("hci_version", 0444, hdev->debugfs, &hdev->hci_ver);\r\ndebugfs_create_u16("hci_revision", 0444, hdev->debugfs, &hdev->hci_rev);\r\ndebugfs_create_u8("hardware_error", 0444, hdev->debugfs,\r\n&hdev->hw_error_code);\r\ndebugfs_create_file("device_id", 0444, hdev->debugfs, hdev,\r\n&device_id_fops);\r\ndebugfs_create_file("device_list", 0444, hdev->debugfs, hdev,\r\n&device_list_fops);\r\ndebugfs_create_file("blacklist", 0444, hdev->debugfs, hdev,\r\n&blacklist_fops);\r\ndebugfs_create_file("uuids", 0444, hdev->debugfs, hdev, &uuids_fops);\r\ndebugfs_create_file("remote_oob", 0400, hdev->debugfs, hdev,\r\n&remote_oob_fops);\r\ndebugfs_create_file("conn_info_min_age", 0644, hdev->debugfs, hdev,\r\n&conn_info_min_age_fops);\r\ndebugfs_create_file("conn_info_max_age", 0644, hdev->debugfs, hdev,\r\n&conn_info_max_age_fops);\r\nif (lmp_ssp_capable(hdev) || lmp_le_capable(hdev))\r\ndebugfs_create_file("use_debug_keys", 0444, hdev->debugfs,\r\nhdev, &use_debug_keys_fops);\r\nif (lmp_sc_capable(hdev) || lmp_le_capable(hdev))\r\ndebugfs_create_file("sc_only_mode", 0444, hdev->debugfs,\r\nhdev, &sc_only_mode_fops);\r\n}\r\nstatic int inquiry_cache_show(struct seq_file *f, void *p)\r\n{\r\nstruct hci_dev *hdev = f->private;\r\nstruct discovery_state *cache = &hdev->discovery;\r\nstruct inquiry_entry *e;\r\nhci_dev_lock(hdev);\r\nlist_for_each_entry(e, &cache->all, all) {\r\nstruct inquiry_data *data = &e->data;\r\nseq_printf(f, "%pMR %d %d %d 0x%.2x%.2x%.2x 0x%.4x %d %d %u\n",\r\n&data->bdaddr,\r\ndata->pscan_rep_mode, data->pscan_period_mode,\r\ndata->pscan_mode, data->dev_class[2],\r\ndata->dev_class[1], data->dev_class[0],\r\n__le16_to_cpu(data->clock_offset),\r\ndata->rssi, data->ssp_mode, e->timestamp);\r\n}\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int inquiry_cache_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, inquiry_cache_show, inode->i_private);\r\n}\r\nstatic int link_keys_show(struct seq_file *f, void *ptr)\r\n{\r\nstruct hci_dev *hdev = f->private;\r\nstruct link_key *key;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(key, &hdev->link_keys, list)\r\nseq_printf(f, "%pMR %u %*phN %u\n", &key->bdaddr, key->type,\r\nHCI_LINK_KEY_SIZE, key->val, key->pin_len);\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nstatic int link_keys_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, link_keys_show, inode->i_private);\r\n}\r\nstatic int dev_class_show(struct seq_file *f, void *ptr)\r\n{\r\nstruct hci_dev *hdev = f->private;\r\nhci_dev_lock(hdev);\r\nseq_printf(f, "0x%.2x%.2x%.2x\n", hdev->dev_class[2],\r\nhdev->dev_class[1], hdev->dev_class[0]);\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int dev_class_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, dev_class_show, inode->i_private);\r\n}\r\nstatic int voice_setting_get(void *data, u64 *val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nhci_dev_lock(hdev);\r\n*val = hdev->voice_setting;\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic ssize_t ssp_debug_mode_read(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct hci_dev *hdev = file->private_data;\r\nchar buf[3];\r\nbuf[0] = hdev->ssp_debug_mode ? 'Y': 'N';\r\nbuf[1] = '\n';\r\nbuf[2] = '\0';\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, 2);\r\n}\r\nstatic int auto_accept_delay_set(void *data, u64 val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nhci_dev_lock(hdev);\r\nhdev->auto_accept_delay = val;\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int auto_accept_delay_get(void *data, u64 *val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nhci_dev_lock(hdev);\r\n*val = hdev->auto_accept_delay;\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int idle_timeout_set(void *data, u64 val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nif (val != 0 && (val < 500 || val > 3600000))\r\nreturn -EINVAL;\r\nhci_dev_lock(hdev);\r\nhdev->idle_timeout = val;\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int idle_timeout_get(void *data, u64 *val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nhci_dev_lock(hdev);\r\n*val = hdev->idle_timeout;\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int sniff_min_interval_set(void *data, u64 val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nif (val == 0 || val % 2 || val > hdev->sniff_max_interval)\r\nreturn -EINVAL;\r\nhci_dev_lock(hdev);\r\nhdev->sniff_min_interval = val;\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int sniff_min_interval_get(void *data, u64 *val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nhci_dev_lock(hdev);\r\n*val = hdev->sniff_min_interval;\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int sniff_max_interval_set(void *data, u64 val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nif (val == 0 || val % 2 || val < hdev->sniff_min_interval)\r\nreturn -EINVAL;\r\nhci_dev_lock(hdev);\r\nhdev->sniff_max_interval = val;\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int sniff_max_interval_get(void *data, u64 *val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nhci_dev_lock(hdev);\r\n*val = hdev->sniff_max_interval;\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nvoid hci_debugfs_create_bredr(struct hci_dev *hdev)\r\n{\r\ndebugfs_create_file("inquiry_cache", 0444, hdev->debugfs, hdev,\r\n&inquiry_cache_fops);\r\ndebugfs_create_file("link_keys", 0400, hdev->debugfs, hdev,\r\n&link_keys_fops);\r\ndebugfs_create_file("dev_class", 0444, hdev->debugfs, hdev,\r\n&dev_class_fops);\r\ndebugfs_create_file("voice_setting", 0444, hdev->debugfs, hdev,\r\n&voice_setting_fops);\r\nif (lmp_ssp_capable(hdev)) {\r\ndebugfs_create_file("ssp_debug_mode", 0444, hdev->debugfs,\r\nhdev, &ssp_debug_mode_fops);\r\ndebugfs_create_file("auto_accept_delay", 0644, hdev->debugfs,\r\nhdev, &auto_accept_delay_fops);\r\n}\r\nif (lmp_sniff_capable(hdev)) {\r\ndebugfs_create_file("idle_timeout", 0644, hdev->debugfs,\r\nhdev, &idle_timeout_fops);\r\ndebugfs_create_file("sniff_min_interval", 0644, hdev->debugfs,\r\nhdev, &sniff_min_interval_fops);\r\ndebugfs_create_file("sniff_max_interval", 0644, hdev->debugfs,\r\nhdev, &sniff_max_interval_fops);\r\n}\r\n}\r\nstatic int identity_show(struct seq_file *f, void *p)\r\n{\r\nstruct hci_dev *hdev = f->private;\r\nbdaddr_t addr;\r\nu8 addr_type;\r\nhci_dev_lock(hdev);\r\nhci_copy_identity_address(hdev, &addr, &addr_type);\r\nseq_printf(f, "%pMR (type %u) %*phN %pMR\n", &addr, addr_type,\r\n16, hdev->irk, &hdev->rpa);\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int identity_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, identity_show, inode->i_private);\r\n}\r\nstatic int rpa_timeout_set(void *data, u64 val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nif (val < 30 || val > (60 * 60 * 24))\r\nreturn -EINVAL;\r\nhci_dev_lock(hdev);\r\nhdev->rpa_timeout = val;\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int rpa_timeout_get(void *data, u64 *val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nhci_dev_lock(hdev);\r\n*val = hdev->rpa_timeout;\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int random_address_show(struct seq_file *f, void *p)\r\n{\r\nstruct hci_dev *hdev = f->private;\r\nhci_dev_lock(hdev);\r\nseq_printf(f, "%pMR\n", &hdev->random_addr);\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int random_address_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, random_address_show, inode->i_private);\r\n}\r\nstatic int static_address_show(struct seq_file *f, void *p)\r\n{\r\nstruct hci_dev *hdev = f->private;\r\nhci_dev_lock(hdev);\r\nseq_printf(f, "%pMR\n", &hdev->static_addr);\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int static_address_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, static_address_show, inode->i_private);\r\n}\r\nstatic ssize_t force_static_address_read(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct hci_dev *hdev = file->private_data;\r\nchar buf[3];\r\nbuf[0] = hci_dev_test_flag(hdev, HCI_FORCE_STATIC_ADDR) ? 'Y': 'N';\r\nbuf[1] = '\n';\r\nbuf[2] = '\0';\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, 2);\r\n}\r\nstatic ssize_t force_static_address_write(struct file *file,\r\nconst char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct hci_dev *hdev = file->private_data;\r\nchar buf[32];\r\nsize_t buf_size = min(count, (sizeof(buf)-1));\r\nbool enable;\r\nif (test_bit(HCI_UP, &hdev->flags))\r\nreturn -EBUSY;\r\nif (copy_from_user(buf, user_buf, buf_size))\r\nreturn -EFAULT;\r\nbuf[buf_size] = '\0';\r\nif (strtobool(buf, &enable))\r\nreturn -EINVAL;\r\nif (enable == hci_dev_test_flag(hdev, HCI_FORCE_STATIC_ADDR))\r\nreturn -EALREADY;\r\nhci_dev_change_flag(hdev, HCI_FORCE_STATIC_ADDR);\r\nreturn count;\r\n}\r\nstatic int white_list_show(struct seq_file *f, void *ptr)\r\n{\r\nstruct hci_dev *hdev = f->private;\r\nstruct bdaddr_list *b;\r\nhci_dev_lock(hdev);\r\nlist_for_each_entry(b, &hdev->le_white_list, list)\r\nseq_printf(f, "%pMR (type %u)\n", &b->bdaddr, b->bdaddr_type);\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int white_list_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, white_list_show, inode->i_private);\r\n}\r\nstatic int identity_resolving_keys_show(struct seq_file *f, void *ptr)\r\n{\r\nstruct hci_dev *hdev = f->private;\r\nstruct smp_irk *irk;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(irk, &hdev->identity_resolving_keys, list) {\r\nseq_printf(f, "%pMR (type %u) %*phN %pMR\n",\r\n&irk->bdaddr, irk->addr_type,\r\n16, irk->val, &irk->rpa);\r\n}\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nstatic int identity_resolving_keys_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, identity_resolving_keys_show,\r\ninode->i_private);\r\n}\r\nstatic int long_term_keys_show(struct seq_file *f, void *ptr)\r\n{\r\nstruct hci_dev *hdev = f->private;\r\nstruct smp_ltk *ltk;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(ltk, &hdev->long_term_keys, list)\r\nseq_printf(f, "%pMR (type %u) %u 0x%02x %u %.4x %.16llx %*phN\n",\r\n&ltk->bdaddr, ltk->bdaddr_type, ltk->authenticated,\r\nltk->type, ltk->enc_size, __le16_to_cpu(ltk->ediv),\r\n__le64_to_cpu(ltk->rand), 16, ltk->val);\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nstatic int long_term_keys_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, long_term_keys_show, inode->i_private);\r\n}\r\nstatic int conn_min_interval_set(void *data, u64 val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nif (val < 0x0006 || val > 0x0c80 || val > hdev->le_conn_max_interval)\r\nreturn -EINVAL;\r\nhci_dev_lock(hdev);\r\nhdev->le_conn_min_interval = val;\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int conn_min_interval_get(void *data, u64 *val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nhci_dev_lock(hdev);\r\n*val = hdev->le_conn_min_interval;\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int conn_max_interval_set(void *data, u64 val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nif (val < 0x0006 || val > 0x0c80 || val < hdev->le_conn_min_interval)\r\nreturn -EINVAL;\r\nhci_dev_lock(hdev);\r\nhdev->le_conn_max_interval = val;\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int conn_max_interval_get(void *data, u64 *val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nhci_dev_lock(hdev);\r\n*val = hdev->le_conn_max_interval;\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int conn_latency_set(void *data, u64 val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nif (val > 0x01f3)\r\nreturn -EINVAL;\r\nhci_dev_lock(hdev);\r\nhdev->le_conn_latency = val;\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int conn_latency_get(void *data, u64 *val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nhci_dev_lock(hdev);\r\n*val = hdev->le_conn_latency;\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int supervision_timeout_set(void *data, u64 val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nif (val < 0x000a || val > 0x0c80)\r\nreturn -EINVAL;\r\nhci_dev_lock(hdev);\r\nhdev->le_supv_timeout = val;\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int supervision_timeout_get(void *data, u64 *val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nhci_dev_lock(hdev);\r\n*val = hdev->le_supv_timeout;\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int adv_channel_map_set(void *data, u64 val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nif (val < 0x01 || val > 0x07)\r\nreturn -EINVAL;\r\nhci_dev_lock(hdev);\r\nhdev->le_adv_channel_map = val;\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int adv_channel_map_get(void *data, u64 *val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nhci_dev_lock(hdev);\r\n*val = hdev->le_adv_channel_map;\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int adv_min_interval_set(void *data, u64 val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nif (val < 0x0020 || val > 0x4000 || val > hdev->le_adv_max_interval)\r\nreturn -EINVAL;\r\nhci_dev_lock(hdev);\r\nhdev->le_adv_min_interval = val;\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int adv_min_interval_get(void *data, u64 *val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nhci_dev_lock(hdev);\r\n*val = hdev->le_adv_min_interval;\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int adv_max_interval_set(void *data, u64 val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nif (val < 0x0020 || val > 0x4000 || val < hdev->le_adv_min_interval)\r\nreturn -EINVAL;\r\nhci_dev_lock(hdev);\r\nhdev->le_adv_max_interval = val;\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nstatic int adv_max_interval_get(void *data, u64 *val)\r\n{\r\nstruct hci_dev *hdev = data;\r\nhci_dev_lock(hdev);\r\n*val = hdev->le_adv_max_interval;\r\nhci_dev_unlock(hdev);\r\nreturn 0;\r\n}\r\nvoid hci_debugfs_create_le(struct hci_dev *hdev)\r\n{\r\ndebugfs_create_file("identity", 0400, hdev->debugfs, hdev,\r\n&identity_fops);\r\ndebugfs_create_file("rpa_timeout", 0644, hdev->debugfs, hdev,\r\n&rpa_timeout_fops);\r\ndebugfs_create_file("random_address", 0444, hdev->debugfs, hdev,\r\n&random_address_fops);\r\ndebugfs_create_file("static_address", 0444, hdev->debugfs, hdev,\r\n&static_address_fops);\r\nif (bacmp(&hdev->bdaddr, BDADDR_ANY))\r\ndebugfs_create_file("force_static_address", 0644,\r\nhdev->debugfs, hdev,\r\n&force_static_address_fops);\r\ndebugfs_create_u8("white_list_size", 0444, hdev->debugfs,\r\n&hdev->le_white_list_size);\r\ndebugfs_create_file("white_list", 0444, hdev->debugfs, hdev,\r\n&white_list_fops);\r\ndebugfs_create_file("identity_resolving_keys", 0400, hdev->debugfs,\r\nhdev, &identity_resolving_keys_fops);\r\ndebugfs_create_file("long_term_keys", 0400, hdev->debugfs, hdev,\r\n&long_term_keys_fops);\r\ndebugfs_create_file("conn_min_interval", 0644, hdev->debugfs, hdev,\r\n&conn_min_interval_fops);\r\ndebugfs_create_file("conn_max_interval", 0644, hdev->debugfs, hdev,\r\n&conn_max_interval_fops);\r\ndebugfs_create_file("conn_latency", 0644, hdev->debugfs, hdev,\r\n&conn_latency_fops);\r\ndebugfs_create_file("supervision_timeout", 0644, hdev->debugfs, hdev,\r\n&supervision_timeout_fops);\r\ndebugfs_create_file("adv_channel_map", 0644, hdev->debugfs, hdev,\r\n&adv_channel_map_fops);\r\ndebugfs_create_file("adv_min_interval", 0644, hdev->debugfs, hdev,\r\n&adv_min_interval_fops);\r\ndebugfs_create_file("adv_max_interval", 0644, hdev->debugfs, hdev,\r\n&adv_max_interval_fops);\r\ndebugfs_create_u16("discov_interleaved_timeout", 0644, hdev->debugfs,\r\n&hdev->discov_interleaved_timeout);\r\ndebugfs_create_file("quirk_strict_duplicate_filter", 0644,\r\nhdev->debugfs, hdev,\r\n&quirk_strict_duplicate_filter_fops);\r\ndebugfs_create_file("quirk_simultaneous_discovery", 0644,\r\nhdev->debugfs, hdev,\r\n&quirk_simultaneous_discovery_fops);\r\n}\r\nvoid hci_debugfs_create_conn(struct hci_conn *conn)\r\n{\r\nstruct hci_dev *hdev = conn->hdev;\r\nchar name[6];\r\nif (IS_ERR_OR_NULL(hdev->debugfs))\r\nreturn;\r\nsnprintf(name, sizeof(name), "%u", conn->handle);\r\nconn->debugfs = debugfs_create_dir(name, hdev->debugfs);\r\n}
