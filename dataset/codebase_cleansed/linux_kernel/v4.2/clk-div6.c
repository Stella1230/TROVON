static int cpg_div6_clock_enable(struct clk_hw *hw)\r\n{\r\nstruct div6_clock *clock = to_div6_clock(hw);\r\nu32 val;\r\nval = (clk_readl(clock->reg) & ~(CPG_DIV6_DIV_MASK | CPG_DIV6_CKSTP))\r\n| CPG_DIV6_DIV(clock->div - 1);\r\nclk_writel(val, clock->reg);\r\nreturn 0;\r\n}\r\nstatic void cpg_div6_clock_disable(struct clk_hw *hw)\r\n{\r\nstruct div6_clock *clock = to_div6_clock(hw);\r\nu32 val;\r\nval = clk_readl(clock->reg);\r\nval |= CPG_DIV6_CKSTP;\r\nif (!(val & CPG_DIV6_DIV_MASK))\r\nval |= CPG_DIV6_DIV_MASK;\r\nclk_writel(val, clock->reg);\r\n}\r\nstatic int cpg_div6_clock_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct div6_clock *clock = to_div6_clock(hw);\r\nreturn !(clk_readl(clock->reg) & CPG_DIV6_CKSTP);\r\n}\r\nstatic unsigned long cpg_div6_clock_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct div6_clock *clock = to_div6_clock(hw);\r\nunsigned int div = (clk_readl(clock->reg) & CPG_DIV6_DIV_MASK) + 1;\r\nreturn parent_rate / div;\r\n}\r\nstatic unsigned int cpg_div6_clock_calc_div(unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nunsigned int div;\r\nif (!rate)\r\nrate = 1;\r\ndiv = DIV_ROUND_CLOSEST(parent_rate, rate);\r\nreturn clamp_t(unsigned int, div, 1, 64);\r\n}\r\nstatic long cpg_div6_clock_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nunsigned int div = cpg_div6_clock_calc_div(rate, *parent_rate);\r\nreturn *parent_rate / div;\r\n}\r\nstatic int cpg_div6_clock_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct div6_clock *clock = to_div6_clock(hw);\r\nunsigned int div = cpg_div6_clock_calc_div(rate, parent_rate);\r\nu32 val;\r\nclock->div = div;\r\nval = clk_readl(clock->reg) & ~CPG_DIV6_DIV_MASK;\r\nif (!(val & CPG_DIV6_CKSTP))\r\nclk_writel(val | CPG_DIV6_DIV(clock->div - 1), clock->reg);\r\nreturn 0;\r\n}\r\nstatic u8 cpg_div6_clock_get_parent(struct clk_hw *hw)\r\n{\r\nstruct div6_clock *clock = to_div6_clock(hw);\r\nunsigned int i;\r\nu8 hw_index;\r\nif (clock->src_width == 0)\r\nreturn 0;\r\nhw_index = (clk_readl(clock->reg) >> clock->src_shift) &\r\n(BIT(clock->src_width) - 1);\r\nfor (i = 0; i < __clk_get_num_parents(hw->clk); i++) {\r\nif (clock->parents[i] == hw_index)\r\nreturn i;\r\n}\r\npr_err("%s: %s DIV6 clock set to invalid parent %u\n",\r\n__func__, __clk_get_name(hw->clk), hw_index);\r\nreturn 0;\r\n}\r\nstatic int cpg_div6_clock_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct div6_clock *clock = to_div6_clock(hw);\r\nu8 hw_index;\r\nu32 mask;\r\nif (index >= __clk_get_num_parents(hw->clk))\r\nreturn -EINVAL;\r\nmask = ~((BIT(clock->src_width) - 1) << clock->src_shift);\r\nhw_index = clock->parents[index];\r\nclk_writel((clk_readl(clock->reg) & mask) |\r\n(hw_index << clock->src_shift), clock->reg);\r\nreturn 0;\r\n}\r\nstatic void __init cpg_div6_clock_init(struct device_node *np)\r\n{\r\nunsigned int num_parents, valid_parents;\r\nconst char **parent_names;\r\nstruct clk_init_data init;\r\nstruct div6_clock *clock;\r\nconst char *name;\r\nstruct clk *clk;\r\nunsigned int i;\r\nint ret;\r\nclock = kzalloc(sizeof(*clock), GFP_KERNEL);\r\nif (!clock)\r\nreturn;\r\nnum_parents = of_clk_get_parent_count(np);\r\nif (num_parents < 1) {\r\npr_err("%s: no parent found for %s DIV6 clock\n",\r\n__func__, np->name);\r\nreturn;\r\n}\r\nclock->parents = kmalloc_array(num_parents, sizeof(*clock->parents),\r\nGFP_KERNEL);\r\nparent_names = kmalloc_array(num_parents, sizeof(*parent_names),\r\nGFP_KERNEL);\r\nif (!parent_names)\r\nreturn;\r\nclock->reg = of_iomap(np, 0);\r\nif (clock->reg == NULL) {\r\npr_err("%s: failed to map %s DIV6 clock register\n",\r\n__func__, np->name);\r\ngoto error;\r\n}\r\nclock->div = (clk_readl(clock->reg) & CPG_DIV6_DIV_MASK) + 1;\r\nret = of_property_read_string(np, "clock-output-names", &name);\r\nif (ret < 0) {\r\npr_err("%s: failed to get %s DIV6 clock output name\n",\r\n__func__, np->name);\r\ngoto error;\r\n}\r\nfor (i = 0, valid_parents = 0; i < num_parents; i++) {\r\nconst char *name = of_clk_get_parent_name(np, i);\r\nif (name) {\r\nparent_names[valid_parents] = name;\r\nclock->parents[valid_parents] = i;\r\nvalid_parents++;\r\n}\r\n}\r\nswitch (num_parents) {\r\ncase 1:\r\nclock->src_shift = clock->src_width = 0;\r\nbreak;\r\ncase 4:\r\nclock->src_shift = 6;\r\nclock->src_width = 2;\r\nbreak;\r\ncase 8:\r\nclock->src_shift = 12;\r\nclock->src_width = 3;\r\nbreak;\r\ndefault:\r\npr_err("%s: invalid number of parents for DIV6 clock %s\n",\r\n__func__, np->name);\r\ngoto error;\r\n}\r\ninit.name = name;\r\ninit.ops = &cpg_div6_clock_ops;\r\ninit.flags = CLK_IS_BASIC;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = valid_parents;\r\nclock->hw.init = &init;\r\nclk = clk_register(NULL, &clock->hw);\r\nif (IS_ERR(clk)) {\r\npr_err("%s: failed to register %s DIV6 clock (%ld)\n",\r\n__func__, np->name, PTR_ERR(clk));\r\ngoto error;\r\n}\r\nof_clk_add_provider(np, of_clk_src_simple_get, clk);\r\nkfree(parent_names);\r\nreturn;\r\nerror:\r\nif (clock->reg)\r\niounmap(clock->reg);\r\nkfree(parent_names);\r\nkfree(clock);\r\n}
