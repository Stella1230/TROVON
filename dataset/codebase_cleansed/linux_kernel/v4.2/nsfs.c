static char *ns_dname(struct dentry *dentry, char *buffer, int buflen)\r\n{\r\nstruct inode *inode = d_inode(dentry);\r\nconst struct proc_ns_operations *ns_ops = dentry->d_fsdata;\r\nreturn dynamic_dname(dentry, buffer, buflen, "%s:[%lu]",\r\nns_ops->name, inode->i_ino);\r\n}\r\nstatic void ns_prune_dentry(struct dentry *dentry)\r\n{\r\nstruct inode *inode = d_inode(dentry);\r\nif (inode) {\r\nstruct ns_common *ns = inode->i_private;\r\natomic_long_set(&ns->stashed, 0);\r\n}\r\n}\r\nstatic void nsfs_evict(struct inode *inode)\r\n{\r\nstruct ns_common *ns = inode->i_private;\r\nclear_inode(inode);\r\nns->ops->put(ns);\r\n}\r\nvoid *ns_get_path(struct path *path, struct task_struct *task,\r\nconst struct proc_ns_operations *ns_ops)\r\n{\r\nstruct vfsmount *mnt = mntget(nsfs_mnt);\r\nstruct qstr qname = { .name = "", };\r\nstruct dentry *dentry;\r\nstruct inode *inode;\r\nstruct ns_common *ns;\r\nunsigned long d;\r\nagain:\r\nns = ns_ops->get(task);\r\nif (!ns) {\r\nmntput(mnt);\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nrcu_read_lock();\r\nd = atomic_long_read(&ns->stashed);\r\nif (!d)\r\ngoto slow;\r\ndentry = (struct dentry *)d;\r\nif (!lockref_get_not_dead(&dentry->d_lockref))\r\ngoto slow;\r\nrcu_read_unlock();\r\nns_ops->put(ns);\r\ngot_it:\r\npath->mnt = mnt;\r\npath->dentry = dentry;\r\nreturn NULL;\r\nslow:\r\nrcu_read_unlock();\r\ninode = new_inode_pseudo(mnt->mnt_sb);\r\nif (!inode) {\r\nns_ops->put(ns);\r\nmntput(mnt);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ninode->i_ino = ns->inum;\r\ninode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\r\ninode->i_flags |= S_IMMUTABLE;\r\ninode->i_mode = S_IFREG | S_IRUGO;\r\ninode->i_fop = &ns_file_operations;\r\ninode->i_private = ns;\r\ndentry = d_alloc_pseudo(mnt->mnt_sb, &qname);\r\nif (!dentry) {\r\niput(inode);\r\nmntput(mnt);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nd_instantiate(dentry, inode);\r\ndentry->d_fsdata = (void *)ns_ops;\r\nd = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);\r\nif (d) {\r\nd_delete(dentry);\r\ndput(dentry);\r\ncpu_relax();\r\ngoto again;\r\n}\r\ngoto got_it;\r\n}\r\nint ns_get_name(char *buf, size_t size, struct task_struct *task,\r\nconst struct proc_ns_operations *ns_ops)\r\n{\r\nstruct ns_common *ns;\r\nint res = -ENOENT;\r\nns = ns_ops->get(task);\r\nif (ns) {\r\nres = snprintf(buf, size, "%s:[%u]", ns_ops->name, ns->inum);\r\nns_ops->put(ns);\r\n}\r\nreturn res;\r\n}\r\nstruct file *proc_ns_fget(int fd)\r\n{\r\nstruct file *file;\r\nfile = fget(fd);\r\nif (!file)\r\nreturn ERR_PTR(-EBADF);\r\nif (file->f_op != &ns_file_operations)\r\ngoto out_invalid;\r\nreturn file;\r\nout_invalid:\r\nfput(file);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic struct dentry *nsfs_mount(struct file_system_type *fs_type,\r\nint flags, const char *dev_name, void *data)\r\n{\r\nreturn mount_pseudo(fs_type, "nsfs:", &nsfs_ops,\r\n&ns_dentry_operations, NSFS_MAGIC);\r\n}\r\nvoid __init nsfs_init(void)\r\n{\r\nnsfs_mnt = kern_mount(&nsfs);\r\nif (IS_ERR(nsfs_mnt))\r\npanic("can't set nsfs up\n");\r\nnsfs_mnt->mnt_sb->s_flags &= ~MS_NOUSER;\r\n}
