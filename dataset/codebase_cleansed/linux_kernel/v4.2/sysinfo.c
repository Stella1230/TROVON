int stsi(void *sysinfo, int fc, int sel1, int sel2)\r\n{\r\nregister int r0 asm("0") = (fc << 28) | sel1;\r\nregister int r1 asm("1") = sel2;\r\nint rc = 0;\r\nasm volatile(\r\n" stsi 0(%3)\n"\r\n"0: jz 2f\n"\r\n"1: lhi %1,%4\n"\r\n"2:\n"\r\nEX_TABLE(0b, 1b)\r\n: "+d" (r0), "+d" (rc)\r\n: "d" (r1), "a" (sysinfo), "K" (-EOPNOTSUPP)\r\n: "cc", "memory");\r\nif (rc)\r\nreturn rc;\r\nreturn fc ? 0 : ((unsigned int) r0) >> 28;\r\n}\r\nstatic void stsi_1_1_1(struct seq_file *m, struct sysinfo_1_1_1 *info)\r\n{\r\nint i;\r\nif (stsi(info, 1, 1, 1))\r\nreturn;\r\nEBCASC(info->manufacturer, sizeof(info->manufacturer));\r\nEBCASC(info->type, sizeof(info->type));\r\nEBCASC(info->model, sizeof(info->model));\r\nEBCASC(info->sequence, sizeof(info->sequence));\r\nEBCASC(info->plant, sizeof(info->plant));\r\nEBCASC(info->model_capacity, sizeof(info->model_capacity));\r\nEBCASC(info->model_perm_cap, sizeof(info->model_perm_cap));\r\nEBCASC(info->model_temp_cap, sizeof(info->model_temp_cap));\r\nseq_printf(m, "Manufacturer: %-16.16s\n", info->manufacturer);\r\nseq_printf(m, "Type: %-4.4s\n", info->type);\r\nseq_printf(m, "Model: %-16.16s", info->model_capacity);\r\nif (info->model[0] != '\0')\r\nseq_printf(m, " %-16.16s", info->model);\r\nseq_putc(m, '\n');\r\nseq_printf(m, "Sequence Code: %-16.16s\n", info->sequence);\r\nseq_printf(m, "Plant: %-4.4s\n", info->plant);\r\nseq_printf(m, "Model Capacity: %-16.16s %08u\n",\r\ninfo->model_capacity, info->model_cap_rating);\r\nif (info->model_perm_cap_rating)\r\nseq_printf(m, "Model Perm. Capacity: %-16.16s %08u\n",\r\ninfo->model_perm_cap,\r\ninfo->model_perm_cap_rating);\r\nif (info->model_temp_cap_rating)\r\nseq_printf(m, "Model Temp. Capacity: %-16.16s %08u\n",\r\ninfo->model_temp_cap,\r\ninfo->model_temp_cap_rating);\r\nif (info->ncr)\r\nseq_printf(m, "Nominal Cap. Rating: %08u\n", info->ncr);\r\nif (info->npr)\r\nseq_printf(m, "Nominal Perm. Rating: %08u\n", info->npr);\r\nif (info->ntr)\r\nseq_printf(m, "Nominal Temp. Rating: %08u\n", info->ntr);\r\nif (info->cai) {\r\nseq_printf(m, "Capacity Adj. Ind.: %d\n", info->cai);\r\nseq_printf(m, "Capacity Ch. Reason: %d\n", info->ccr);\r\nseq_printf(m, "Capacity Transient: %d\n", info->t);\r\n}\r\nif (info->p) {\r\nfor (i = 1; i <= ARRAY_SIZE(info->typepct); i++) {\r\nseq_printf(m, "Type %d Percentage: %d\n",\r\ni, info->typepct[i - 1]);\r\n}\r\n}\r\n}\r\nstatic void stsi_15_1_x(struct seq_file *m, struct sysinfo_15_1_x *info)\r\n{\r\nstatic int max_mnest;\r\nint i, rc;\r\nseq_putc(m, '\n');\r\nif (!MACHINE_HAS_TOPOLOGY)\r\nreturn;\r\nif (stsi(info, 15, 1, topology_max_mnest))\r\nreturn;\r\nseq_printf(m, "CPU Topology HW: ");\r\nfor (i = 0; i < TOPOLOGY_NR_MAG; i++)\r\nseq_printf(m, " %d", info->mag[i]);\r\nseq_putc(m, '\n');\r\n#ifdef CONFIG_SCHED_MC\r\nstore_topology(info);\r\nseq_printf(m, "CPU Topology SW: ");\r\nfor (i = 0; i < TOPOLOGY_NR_MAG; i++)\r\nseq_printf(m, " %d", info->mag[i]);\r\nseq_putc(m, '\n');\r\n#endif\r\n}\r\nstatic void stsi_1_2_2(struct seq_file *m, struct sysinfo_1_2_2 *info)\r\n{\r\nstruct sysinfo_1_2_2_extension *ext;\r\nint i;\r\nif (stsi(info, 1, 2, 2))\r\nreturn;\r\next = (struct sysinfo_1_2_2_extension *)\r\n((unsigned long) info + info->acc_offset);\r\nseq_printf(m, "CPUs Total: %d\n", info->cpus_total);\r\nseq_printf(m, "CPUs Configured: %d\n", info->cpus_configured);\r\nseq_printf(m, "CPUs Standby: %d\n", info->cpus_standby);\r\nseq_printf(m, "CPUs Reserved: %d\n", info->cpus_reserved);\r\nseq_printf(m, "Capability: %u", info->capability);\r\nif (info->format == 1)\r\nseq_printf(m, " %u", ext->alt_capability);\r\nseq_putc(m, '\n');\r\nif (info->nominal_cap)\r\nseq_printf(m, "Nominal Capability: %d\n", info->nominal_cap);\r\nif (info->secondary_cap)\r\nseq_printf(m, "Secondary Capability: %d\n", info->secondary_cap);\r\nfor (i = 2; i <= info->cpus_total; i++) {\r\nseq_printf(m, "Adjustment %02d-way: %u",\r\ni, info->adjustment[i-2]);\r\nif (info->format == 1)\r\nseq_printf(m, " %u", ext->alt_adjustment[i-2]);\r\nseq_putc(m, '\n');\r\n}\r\n}\r\nstatic void stsi_2_2_2(struct seq_file *m, struct sysinfo_2_2_2 *info)\r\n{\r\nif (stsi(info, 2, 2, 2))\r\nreturn;\r\nEBCASC(info->name, sizeof(info->name));\r\nseq_putc(m, '\n');\r\nseq_printf(m, "LPAR Number: %d\n", info->lpar_number);\r\nseq_printf(m, "LPAR Characteristics: ");\r\nif (info->characteristics & LPAR_CHAR_DEDICATED)\r\nseq_printf(m, "Dedicated ");\r\nif (info->characteristics & LPAR_CHAR_SHARED)\r\nseq_printf(m, "Shared ");\r\nif (info->characteristics & LPAR_CHAR_LIMITED)\r\nseq_printf(m, "Limited ");\r\nseq_putc(m, '\n');\r\nseq_printf(m, "LPAR Name: %-8.8s\n", info->name);\r\nseq_printf(m, "LPAR Adjustment: %d\n", info->caf);\r\nseq_printf(m, "LPAR CPUs Total: %d\n", info->cpus_total);\r\nseq_printf(m, "LPAR CPUs Configured: %d\n", info->cpus_configured);\r\nseq_printf(m, "LPAR CPUs Standby: %d\n", info->cpus_standby);\r\nseq_printf(m, "LPAR CPUs Reserved: %d\n", info->cpus_reserved);\r\nseq_printf(m, "LPAR CPUs Dedicated: %d\n", info->cpus_dedicated);\r\nseq_printf(m, "LPAR CPUs Shared: %d\n", info->cpus_shared);\r\nif (info->mt_installed & 0x80) {\r\nseq_printf(m, "LPAR CPUs G-MTID: %d\n",\r\ninfo->mt_general & 0x1f);\r\nseq_printf(m, "LPAR CPUs S-MTID: %d\n",\r\ninfo->mt_installed & 0x1f);\r\nseq_printf(m, "LPAR CPUs PS-MTID: %d\n",\r\ninfo->mt_psmtid & 0x1f);\r\n}\r\n}\r\nstatic void print_ext_name(struct seq_file *m, int lvl,\r\nstruct sysinfo_3_2_2 *info)\r\n{\r\nif (info->vm[lvl].ext_name_encoding == 0)\r\nreturn;\r\nif (info->ext_names[lvl][0] == 0)\r\nreturn;\r\nswitch (info->vm[lvl].ext_name_encoding) {\r\ncase 1:\r\nEBCASC(info->ext_names[lvl], sizeof(info->ext_names[lvl]));\r\nbreak;\r\ncase 2:\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nseq_printf(m, "VM%02d Extended Name: %-.256s\n", lvl,\r\ninfo->ext_names[lvl]);\r\n}\r\nstatic void print_uuid(struct seq_file *m, int i, struct sysinfo_3_2_2 *info)\r\n{\r\nif (!memcmp(&info->vm[i].uuid, &NULL_UUID_BE, sizeof(uuid_be)))\r\nreturn;\r\nseq_printf(m, "VM%02d UUID: %pUb\n", i, &info->vm[i].uuid);\r\n}\r\nstatic void stsi_3_2_2(struct seq_file *m, struct sysinfo_3_2_2 *info)\r\n{\r\nint i;\r\nif (stsi(info, 3, 2, 2))\r\nreturn;\r\nfor (i = 0; i < info->count; i++) {\r\nEBCASC(info->vm[i].name, sizeof(info->vm[i].name));\r\nEBCASC(info->vm[i].cpi, sizeof(info->vm[i].cpi));\r\nseq_putc(m, '\n');\r\nseq_printf(m, "VM%02d Name: %-8.8s\n", i, info->vm[i].name);\r\nseq_printf(m, "VM%02d Control Program: %-16.16s\n", i, info->vm[i].cpi);\r\nseq_printf(m, "VM%02d Adjustment: %d\n", i, info->vm[i].caf);\r\nseq_printf(m, "VM%02d CPUs Total: %d\n", i, info->vm[i].cpus_total);\r\nseq_printf(m, "VM%02d CPUs Configured: %d\n", i, info->vm[i].cpus_configured);\r\nseq_printf(m, "VM%02d CPUs Standby: %d\n", i, info->vm[i].cpus_standby);\r\nseq_printf(m, "VM%02d CPUs Reserved: %d\n", i, info->vm[i].cpus_reserved);\r\nprint_ext_name(m, i, info);\r\nprint_uuid(m, i, info);\r\n}\r\n}\r\nstatic int sysinfo_show(struct seq_file *m, void *v)\r\n{\r\nvoid *info = (void *)get_zeroed_page(GFP_KERNEL);\r\nint level;\r\nif (!info)\r\nreturn 0;\r\nlevel = stsi(NULL, 0, 0, 0);\r\nif (level >= 1)\r\nstsi_1_1_1(m, info);\r\nif (level >= 1)\r\nstsi_15_1_x(m, info);\r\nif (level >= 1)\r\nstsi_1_2_2(m, info);\r\nif (level >= 2)\r\nstsi_2_2_2(m, info);\r\nif (level >= 3)\r\nstsi_3_2_2(m, info);\r\nfree_page((unsigned long)info);\r\nreturn 0;\r\n}\r\nstatic int sysinfo_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, sysinfo_show, NULL);\r\n}\r\nstatic int __init sysinfo_create_proc(void)\r\n{\r\nproc_create("sysinfo", 0444, NULL, &sysinfo_fops);\r\nreturn 0;\r\n}\r\nint register_service_level(struct service_level *slr)\r\n{\r\nstruct service_level *ptr;\r\ndown_write(&service_level_sem);\r\nlist_for_each_entry(ptr, &service_level_list, list)\r\nif (ptr == slr) {\r\nup_write(&service_level_sem);\r\nreturn -EEXIST;\r\n}\r\nlist_add_tail(&slr->list, &service_level_list);\r\nup_write(&service_level_sem);\r\nreturn 0;\r\n}\r\nint unregister_service_level(struct service_level *slr)\r\n{\r\nstruct service_level *ptr, *next;\r\nint rc = -ENOENT;\r\ndown_write(&service_level_sem);\r\nlist_for_each_entry_safe(ptr, next, &service_level_list, list) {\r\nif (ptr != slr)\r\ncontinue;\r\nlist_del(&ptr->list);\r\nrc = 0;\r\nbreak;\r\n}\r\nup_write(&service_level_sem);\r\nreturn rc;\r\n}\r\nstatic void *service_level_start(struct seq_file *m, loff_t *pos)\r\n{\r\ndown_read(&service_level_sem);\r\nreturn seq_list_start(&service_level_list, *pos);\r\n}\r\nstatic void *service_level_next(struct seq_file *m, void *p, loff_t *pos)\r\n{\r\nreturn seq_list_next(p, &service_level_list, pos);\r\n}\r\nstatic void service_level_stop(struct seq_file *m, void *p)\r\n{\r\nup_read(&service_level_sem);\r\n}\r\nstatic int service_level_show(struct seq_file *m, void *p)\r\n{\r\nstruct service_level *slr;\r\nslr = list_entry(p, struct service_level, list);\r\nslr->seq_print(m, slr);\r\nreturn 0;\r\n}\r\nstatic int service_level_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &service_level_seq_ops);\r\n}\r\nstatic void service_level_vm_print(struct seq_file *m,\r\nstruct service_level *slr)\r\n{\r\nchar *query_buffer, *str;\r\nquery_buffer = kmalloc(1024, GFP_KERNEL | GFP_DMA);\r\nif (!query_buffer)\r\nreturn;\r\ncpcmd("QUERY CPLEVEL", query_buffer, 1024, NULL);\r\nstr = strchr(query_buffer, '\n');\r\nif (str)\r\n*str = 0;\r\nseq_printf(m, "VM: %s\n", query_buffer);\r\nkfree(query_buffer);\r\n}\r\nstatic __init int create_proc_service_level(void)\r\n{\r\nproc_create("service_levels", 0, NULL, &service_level_ops);\r\nif (MACHINE_IS_VM)\r\nregister_service_level(&service_level_vm);\r\nreturn 0;\r\n}\r\nvoid s390_adjust_jiffies(void)\r\n{\r\nstruct sysinfo_1_2_2 *info;\r\nconst unsigned int fmil = 0x4b189680;\r\nFP_DECL_S(SA); FP_DECL_S(SB); FP_DECL_S(SR);\r\nFP_DECL_EX;\r\nunsigned int capability;\r\ninfo = (void *) get_zeroed_page(GFP_KERNEL);\r\nif (!info)\r\nreturn;\r\nif (stsi(info, 1, 2, 2) == 0) {\r\nFP_UNPACK_SP(SA, &fmil);\r\nif ((info->capability >> 23) == 0)\r\nFP_FROM_INT_S(SB, (long) info->capability, 64, long);\r\nelse\r\nFP_UNPACK_SP(SB, &info->capability);\r\nFP_DIV_S(SR, SA, SB);\r\nFP_TO_INT_S(capability, SR, 32, 0);\r\n} else\r\ncapability = 42;\r\nloops_per_jiffy = capability * (500000/HZ);\r\nfree_page((unsigned long) info);\r\n}\r\nvoid calibrate_delay(void)\r\n{\r\ns390_adjust_jiffies();\r\nprintk(KERN_DEBUG "Calibrating delay loop (skipped)... "\r\n"%lu.%02lu BogoMIPS preset\n", loops_per_jiffy/(500000/HZ),\r\n(loops_per_jiffy/(5000/HZ)) % 100);\r\n}
