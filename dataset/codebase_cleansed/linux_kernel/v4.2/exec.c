void __register_binfmt(struct linux_binfmt * fmt, int insert)\r\n{\r\nBUG_ON(!fmt);\r\nif (WARN_ON(!fmt->load_binary))\r\nreturn;\r\nwrite_lock(&binfmt_lock);\r\ninsert ? list_add(&fmt->lh, &formats) :\r\nlist_add_tail(&fmt->lh, &formats);\r\nwrite_unlock(&binfmt_lock);\r\n}\r\nvoid unregister_binfmt(struct linux_binfmt * fmt)\r\n{\r\nwrite_lock(&binfmt_lock);\r\nlist_del(&fmt->lh);\r\nwrite_unlock(&binfmt_lock);\r\n}\r\nstatic inline void put_binfmt(struct linux_binfmt * fmt)\r\n{\r\nmodule_put(fmt->module);\r\n}\r\nstatic void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)\r\n{\r\nstruct mm_struct *mm = current->mm;\r\nlong diff = (long)(pages - bprm->vma_pages);\r\nif (!mm || !diff)\r\nreturn;\r\nbprm->vma_pages = pages;\r\nadd_mm_counter(mm, MM_ANONPAGES, diff);\r\n}\r\nstatic struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,\r\nint write)\r\n{\r\nstruct page *page;\r\nint ret;\r\n#ifdef CONFIG_STACK_GROWSUP\r\nif (write) {\r\nret = expand_downwards(bprm->vma, pos);\r\nif (ret < 0)\r\nreturn NULL;\r\n}\r\n#endif\r\nret = get_user_pages(current, bprm->mm, pos,\r\n1, write, 1, &page, NULL);\r\nif (ret <= 0)\r\nreturn NULL;\r\nif (write) {\r\nunsigned long size = bprm->vma->vm_end - bprm->vma->vm_start;\r\nstruct rlimit *rlim;\r\nacct_arg_size(bprm, size / PAGE_SIZE);\r\nif (size <= ARG_MAX)\r\nreturn page;\r\nrlim = current->signal->rlim;\r\nif (size > ACCESS_ONCE(rlim[RLIMIT_STACK].rlim_cur) / 4) {\r\nput_page(page);\r\nreturn NULL;\r\n}\r\n}\r\nreturn page;\r\n}\r\nstatic void put_arg_page(struct page *page)\r\n{\r\nput_page(page);\r\n}\r\nstatic void free_arg_page(struct linux_binprm *bprm, int i)\r\n{\r\n}\r\nstatic void free_arg_pages(struct linux_binprm *bprm)\r\n{\r\n}\r\nstatic void flush_arg_page(struct linux_binprm *bprm, unsigned long pos,\r\nstruct page *page)\r\n{\r\nflush_cache_page(bprm->vma, pos, page_to_pfn(page));\r\n}\r\nstatic int __bprm_mm_init(struct linux_binprm *bprm)\r\n{\r\nint err;\r\nstruct vm_area_struct *vma = NULL;\r\nstruct mm_struct *mm = bprm->mm;\r\nbprm->vma = vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);\r\nif (!vma)\r\nreturn -ENOMEM;\r\ndown_write(&mm->mmap_sem);\r\nvma->vm_mm = mm;\r\nBUILD_BUG_ON(VM_STACK_FLAGS & VM_STACK_INCOMPLETE_SETUP);\r\nvma->vm_end = STACK_TOP_MAX;\r\nvma->vm_start = vma->vm_end - PAGE_SIZE;\r\nvma->vm_flags = VM_SOFTDIRTY | VM_STACK_FLAGS | VM_STACK_INCOMPLETE_SETUP;\r\nvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\r\nINIT_LIST_HEAD(&vma->anon_vma_chain);\r\nerr = insert_vm_struct(mm, vma);\r\nif (err)\r\ngoto err;\r\nmm->stack_vm = mm->total_vm = 1;\r\narch_bprm_mm_init(mm, vma);\r\nup_write(&mm->mmap_sem);\r\nbprm->p = vma->vm_end - sizeof(void *);\r\nreturn 0;\r\nerr:\r\nup_write(&mm->mmap_sem);\r\nbprm->vma = NULL;\r\nkmem_cache_free(vm_area_cachep, vma);\r\nreturn err;\r\n}\r\nstatic bool valid_arg_len(struct linux_binprm *bprm, long len)\r\n{\r\nreturn len <= MAX_ARG_STRLEN;\r\n}\r\nstatic inline void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)\r\n{\r\n}\r\nstatic struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,\r\nint write)\r\n{\r\nstruct page *page;\r\npage = bprm->page[pos / PAGE_SIZE];\r\nif (!page && write) {\r\npage = alloc_page(GFP_HIGHUSER|__GFP_ZERO);\r\nif (!page)\r\nreturn NULL;\r\nbprm->page[pos / PAGE_SIZE] = page;\r\n}\r\nreturn page;\r\n}\r\nstatic void put_arg_page(struct page *page)\r\n{\r\n}\r\nstatic void free_arg_page(struct linux_binprm *bprm, int i)\r\n{\r\nif (bprm->page[i]) {\r\n__free_page(bprm->page[i]);\r\nbprm->page[i] = NULL;\r\n}\r\n}\r\nstatic void free_arg_pages(struct linux_binprm *bprm)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_ARG_PAGES; i++)\r\nfree_arg_page(bprm, i);\r\n}\r\nstatic void flush_arg_page(struct linux_binprm *bprm, unsigned long pos,\r\nstruct page *page)\r\n{\r\n}\r\nstatic int __bprm_mm_init(struct linux_binprm *bprm)\r\n{\r\nbprm->p = PAGE_SIZE * MAX_ARG_PAGES - sizeof(void *);\r\nreturn 0;\r\n}\r\nstatic bool valid_arg_len(struct linux_binprm *bprm, long len)\r\n{\r\nreturn len <= bprm->p;\r\n}\r\nstatic int bprm_mm_init(struct linux_binprm *bprm)\r\n{\r\nint err;\r\nstruct mm_struct *mm = NULL;\r\nbprm->mm = mm = mm_alloc();\r\nerr = -ENOMEM;\r\nif (!mm)\r\ngoto err;\r\nerr = __bprm_mm_init(bprm);\r\nif (err)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nif (mm) {\r\nbprm->mm = NULL;\r\nmmdrop(mm);\r\n}\r\nreturn err;\r\n}\r\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\r\n{\r\nconst char __user *native;\r\n#ifdef CONFIG_COMPAT\r\nif (unlikely(argv.is_compat)) {\r\ncompat_uptr_t compat;\r\nif (get_user(compat, argv.ptr.compat + nr))\r\nreturn ERR_PTR(-EFAULT);\r\nreturn compat_ptr(compat);\r\n}\r\n#endif\r\nif (get_user(native, argv.ptr.native + nr))\r\nreturn ERR_PTR(-EFAULT);\r\nreturn native;\r\n}\r\nstatic int count(struct user_arg_ptr argv, int max)\r\n{\r\nint i = 0;\r\nif (argv.ptr.native != NULL) {\r\nfor (;;) {\r\nconst char __user *p = get_user_arg_ptr(argv, i);\r\nif (!p)\r\nbreak;\r\nif (IS_ERR(p))\r\nreturn -EFAULT;\r\nif (i >= max)\r\nreturn -E2BIG;\r\n++i;\r\nif (fatal_signal_pending(current))\r\nreturn -ERESTARTNOHAND;\r\ncond_resched();\r\n}\r\n}\r\nreturn i;\r\n}\r\nstatic int copy_strings(int argc, struct user_arg_ptr argv,\r\nstruct linux_binprm *bprm)\r\n{\r\nstruct page *kmapped_page = NULL;\r\nchar *kaddr = NULL;\r\nunsigned long kpos = 0;\r\nint ret;\r\nwhile (argc-- > 0) {\r\nconst char __user *str;\r\nint len;\r\nunsigned long pos;\r\nret = -EFAULT;\r\nstr = get_user_arg_ptr(argv, argc);\r\nif (IS_ERR(str))\r\ngoto out;\r\nlen = strnlen_user(str, MAX_ARG_STRLEN);\r\nif (!len)\r\ngoto out;\r\nret = -E2BIG;\r\nif (!valid_arg_len(bprm, len))\r\ngoto out;\r\npos = bprm->p;\r\nstr += len;\r\nbprm->p -= len;\r\nwhile (len > 0) {\r\nint offset, bytes_to_copy;\r\nif (fatal_signal_pending(current)) {\r\nret = -ERESTARTNOHAND;\r\ngoto out;\r\n}\r\ncond_resched();\r\noffset = pos % PAGE_SIZE;\r\nif (offset == 0)\r\noffset = PAGE_SIZE;\r\nbytes_to_copy = offset;\r\nif (bytes_to_copy > len)\r\nbytes_to_copy = len;\r\noffset -= bytes_to_copy;\r\npos -= bytes_to_copy;\r\nstr -= bytes_to_copy;\r\nlen -= bytes_to_copy;\r\nif (!kmapped_page || kpos != (pos & PAGE_MASK)) {\r\nstruct page *page;\r\npage = get_arg_page(bprm, pos, 1);\r\nif (!page) {\r\nret = -E2BIG;\r\ngoto out;\r\n}\r\nif (kmapped_page) {\r\nflush_kernel_dcache_page(kmapped_page);\r\nkunmap(kmapped_page);\r\nput_arg_page(kmapped_page);\r\n}\r\nkmapped_page = page;\r\nkaddr = kmap(kmapped_page);\r\nkpos = pos & PAGE_MASK;\r\nflush_arg_page(bprm, kpos, kmapped_page);\r\n}\r\nif (copy_from_user(kaddr+offset, str, bytes_to_copy)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\n}\r\n}\r\nret = 0;\r\nout:\r\nif (kmapped_page) {\r\nflush_kernel_dcache_page(kmapped_page);\r\nkunmap(kmapped_page);\r\nput_arg_page(kmapped_page);\r\n}\r\nreturn ret;\r\n}\r\nint copy_strings_kernel(int argc, const char *const *__argv,\r\nstruct linux_binprm *bprm)\r\n{\r\nint r;\r\nmm_segment_t oldfs = get_fs();\r\nstruct user_arg_ptr argv = {\r\n.ptr.native = (const char __user *const __user *)__argv,\r\n};\r\nset_fs(KERNEL_DS);\r\nr = copy_strings(argc, argv, bprm);\r\nset_fs(oldfs);\r\nreturn r;\r\n}\r\nstatic int shift_arg_pages(struct vm_area_struct *vma, unsigned long shift)\r\n{\r\nstruct mm_struct *mm = vma->vm_mm;\r\nunsigned long old_start = vma->vm_start;\r\nunsigned long old_end = vma->vm_end;\r\nunsigned long length = old_end - old_start;\r\nunsigned long new_start = old_start - shift;\r\nunsigned long new_end = old_end - shift;\r\nstruct mmu_gather tlb;\r\nBUG_ON(new_start > new_end);\r\nif (vma != find_vma(mm, new_start))\r\nreturn -EFAULT;\r\nif (vma_adjust(vma, new_start, old_end, vma->vm_pgoff, NULL))\r\nreturn -ENOMEM;\r\nif (length != move_page_tables(vma, old_start,\r\nvma, new_start, length, false))\r\nreturn -ENOMEM;\r\nlru_add_drain();\r\ntlb_gather_mmu(&tlb, mm, old_start, old_end);\r\nif (new_end > old_start) {\r\nfree_pgd_range(&tlb, new_end, old_end, new_end,\r\nvma->vm_next ? vma->vm_next->vm_start : USER_PGTABLES_CEILING);\r\n} else {\r\nfree_pgd_range(&tlb, old_start, old_end, new_end,\r\nvma->vm_next ? vma->vm_next->vm_start : USER_PGTABLES_CEILING);\r\n}\r\ntlb_finish_mmu(&tlb, old_start, old_end);\r\nvma_adjust(vma, new_start, new_end, vma->vm_pgoff, NULL);\r\nreturn 0;\r\n}\r\nint setup_arg_pages(struct linux_binprm *bprm,\r\nunsigned long stack_top,\r\nint executable_stack)\r\n{\r\nunsigned long ret;\r\nunsigned long stack_shift;\r\nstruct mm_struct *mm = current->mm;\r\nstruct vm_area_struct *vma = bprm->vma;\r\nstruct vm_area_struct *prev = NULL;\r\nunsigned long vm_flags;\r\nunsigned long stack_base;\r\nunsigned long stack_size;\r\nunsigned long stack_expand;\r\nunsigned long rlim_stack;\r\n#ifdef CONFIG_STACK_GROWSUP\r\nstack_base = rlimit_max(RLIMIT_STACK);\r\nif (stack_base > STACK_SIZE_MAX)\r\nstack_base = STACK_SIZE_MAX;\r\nstack_base += (STACK_RND_MASK << PAGE_SHIFT);\r\nif (vma->vm_end - vma->vm_start > stack_base)\r\nreturn -ENOMEM;\r\nstack_base = PAGE_ALIGN(stack_top - stack_base);\r\nstack_shift = vma->vm_start - stack_base;\r\nmm->arg_start = bprm->p - stack_shift;\r\nbprm->p = vma->vm_end - stack_shift;\r\n#else\r\nstack_top = arch_align_stack(stack_top);\r\nstack_top = PAGE_ALIGN(stack_top);\r\nif (unlikely(stack_top < mmap_min_addr) ||\r\nunlikely(vma->vm_end - vma->vm_start >= stack_top - mmap_min_addr))\r\nreturn -ENOMEM;\r\nstack_shift = vma->vm_end - stack_top;\r\nbprm->p -= stack_shift;\r\nmm->arg_start = bprm->p;\r\n#endif\r\nif (bprm->loader)\r\nbprm->loader -= stack_shift;\r\nbprm->exec -= stack_shift;\r\ndown_write(&mm->mmap_sem);\r\nvm_flags = VM_STACK_FLAGS;\r\nif (unlikely(executable_stack == EXSTACK_ENABLE_X))\r\nvm_flags |= VM_EXEC;\r\nelse if (executable_stack == EXSTACK_DISABLE_X)\r\nvm_flags &= ~VM_EXEC;\r\nvm_flags |= mm->def_flags;\r\nvm_flags |= VM_STACK_INCOMPLETE_SETUP;\r\nret = mprotect_fixup(vma, &prev, vma->vm_start, vma->vm_end,\r\nvm_flags);\r\nif (ret)\r\ngoto out_unlock;\r\nBUG_ON(prev != vma);\r\nif (stack_shift) {\r\nret = shift_arg_pages(vma, stack_shift);\r\nif (ret)\r\ngoto out_unlock;\r\n}\r\nvma->vm_flags &= ~VM_STACK_INCOMPLETE_SETUP;\r\nstack_expand = 131072UL;\r\nstack_size = vma->vm_end - vma->vm_start;\r\nrlim_stack = rlimit(RLIMIT_STACK) & PAGE_MASK;\r\n#ifdef CONFIG_STACK_GROWSUP\r\nif (stack_size + stack_expand > rlim_stack)\r\nstack_base = vma->vm_start + rlim_stack;\r\nelse\r\nstack_base = vma->vm_end + stack_expand;\r\n#else\r\nif (stack_size + stack_expand > rlim_stack)\r\nstack_base = vma->vm_end - rlim_stack;\r\nelse\r\nstack_base = vma->vm_start - stack_expand;\r\n#endif\r\ncurrent->mm->start_stack = bprm->p;\r\nret = expand_stack(vma, stack_base);\r\nif (ret)\r\nret = -EFAULT;\r\nout_unlock:\r\nup_write(&mm->mmap_sem);\r\nreturn ret;\r\n}\r\nstatic struct file *do_open_execat(int fd, struct filename *name, int flags)\r\n{\r\nstruct file *file;\r\nint err;\r\nstruct open_flags open_exec_flags = {\r\n.open_flag = O_LARGEFILE | O_RDONLY | __FMODE_EXEC,\r\n.acc_mode = MAY_EXEC | MAY_OPEN,\r\n.intent = LOOKUP_OPEN,\r\n.lookup_flags = LOOKUP_FOLLOW,\r\n};\r\nif ((flags & ~(AT_SYMLINK_NOFOLLOW | AT_EMPTY_PATH)) != 0)\r\nreturn ERR_PTR(-EINVAL);\r\nif (flags & AT_SYMLINK_NOFOLLOW)\r\nopen_exec_flags.lookup_flags &= ~LOOKUP_FOLLOW;\r\nif (flags & AT_EMPTY_PATH)\r\nopen_exec_flags.lookup_flags |= LOOKUP_EMPTY;\r\nfile = do_filp_open(fd, name, &open_exec_flags);\r\nif (IS_ERR(file))\r\ngoto out;\r\nerr = -EACCES;\r\nif (!S_ISREG(file_inode(file)->i_mode))\r\ngoto exit;\r\nif (file->f_path.mnt->mnt_flags & MNT_NOEXEC)\r\ngoto exit;\r\nerr = deny_write_access(file);\r\nif (err)\r\ngoto exit;\r\nif (name->name[0] != '\0')\r\nfsnotify_open(file);\r\nout:\r\nreturn file;\r\nexit:\r\nfput(file);\r\nreturn ERR_PTR(err);\r\n}\r\nstruct file *open_exec(const char *name)\r\n{\r\nstruct filename *filename = getname_kernel(name);\r\nstruct file *f = ERR_CAST(filename);\r\nif (!IS_ERR(filename)) {\r\nf = do_open_execat(AT_FDCWD, filename, 0);\r\nputname(filename);\r\n}\r\nreturn f;\r\n}\r\nint kernel_read(struct file *file, loff_t offset,\r\nchar *addr, unsigned long count)\r\n{\r\nmm_segment_t old_fs;\r\nloff_t pos = offset;\r\nint result;\r\nold_fs = get_fs();\r\nset_fs(get_ds());\r\nresult = vfs_read(file, (void __user *)addr, count, &pos);\r\nset_fs(old_fs);\r\nreturn result;\r\n}\r\nssize_t read_code(struct file *file, unsigned long addr, loff_t pos, size_t len)\r\n{\r\nssize_t res = vfs_read(file, (void __user *)addr, len, &pos);\r\nif (res > 0)\r\nflush_icache_range(addr, addr + len);\r\nreturn res;\r\n}\r\nstatic int exec_mmap(struct mm_struct *mm)\r\n{\r\nstruct task_struct *tsk;\r\nstruct mm_struct *old_mm, *active_mm;\r\ntsk = current;\r\nold_mm = current->mm;\r\nmm_release(tsk, old_mm);\r\nif (old_mm) {\r\nsync_mm_rss(old_mm);\r\ndown_read(&old_mm->mmap_sem);\r\nif (unlikely(old_mm->core_state)) {\r\nup_read(&old_mm->mmap_sem);\r\nreturn -EINTR;\r\n}\r\n}\r\ntask_lock(tsk);\r\nactive_mm = tsk->active_mm;\r\ntsk->mm = mm;\r\ntsk->active_mm = mm;\r\nactivate_mm(active_mm, mm);\r\ntsk->mm->vmacache_seqnum = 0;\r\nvmacache_flush(tsk);\r\ntask_unlock(tsk);\r\nif (old_mm) {\r\nup_read(&old_mm->mmap_sem);\r\nBUG_ON(active_mm != old_mm);\r\nsetmax_mm_hiwater_rss(&tsk->signal->maxrss, old_mm);\r\nmm_update_next_owner(old_mm);\r\nmmput(old_mm);\r\nreturn 0;\r\n}\r\nmmdrop(active_mm);\r\nreturn 0;\r\n}\r\nstatic int de_thread(struct task_struct *tsk)\r\n{\r\nstruct signal_struct *sig = tsk->signal;\r\nstruct sighand_struct *oldsighand = tsk->sighand;\r\nspinlock_t *lock = &oldsighand->siglock;\r\nif (thread_group_empty(tsk))\r\ngoto no_thread_group;\r\nspin_lock_irq(lock);\r\nif (signal_group_exit(sig)) {\r\nspin_unlock_irq(lock);\r\nreturn -EAGAIN;\r\n}\r\nsig->group_exit_task = tsk;\r\nsig->notify_count = zap_other_threads(tsk);\r\nif (!thread_group_leader(tsk))\r\nsig->notify_count--;\r\nwhile (sig->notify_count) {\r\n__set_current_state(TASK_KILLABLE);\r\nspin_unlock_irq(lock);\r\nschedule();\r\nif (unlikely(__fatal_signal_pending(tsk)))\r\ngoto killed;\r\nspin_lock_irq(lock);\r\n}\r\nspin_unlock_irq(lock);\r\nif (!thread_group_leader(tsk)) {\r\nstruct task_struct *leader = tsk->group_leader;\r\nfor (;;) {\r\nthreadgroup_change_begin(tsk);\r\nwrite_lock_irq(&tasklist_lock);\r\nsig->notify_count = -1;\r\nif (likely(leader->exit_state))\r\nbreak;\r\n__set_current_state(TASK_KILLABLE);\r\nwrite_unlock_irq(&tasklist_lock);\r\nthreadgroup_change_end(tsk);\r\nschedule();\r\nif (unlikely(__fatal_signal_pending(tsk)))\r\ngoto killed;\r\n}\r\ntsk->start_time = leader->start_time;\r\ntsk->real_start_time = leader->real_start_time;\r\nBUG_ON(!same_thread_group(leader, tsk));\r\nBUG_ON(has_group_leader_pid(tsk));\r\ntsk->pid = leader->pid;\r\nchange_pid(tsk, PIDTYPE_PID, task_pid(leader));\r\ntransfer_pid(leader, tsk, PIDTYPE_PGID);\r\ntransfer_pid(leader, tsk, PIDTYPE_SID);\r\nlist_replace_rcu(&leader->tasks, &tsk->tasks);\r\nlist_replace_init(&leader->sibling, &tsk->sibling);\r\ntsk->group_leader = tsk;\r\nleader->group_leader = tsk;\r\ntsk->exit_signal = SIGCHLD;\r\nleader->exit_signal = -1;\r\nBUG_ON(leader->exit_state != EXIT_ZOMBIE);\r\nleader->exit_state = EXIT_DEAD;\r\nif (unlikely(leader->ptrace))\r\n__wake_up_parent(leader, leader->parent);\r\nwrite_unlock_irq(&tasklist_lock);\r\nthreadgroup_change_end(tsk);\r\nrelease_task(leader);\r\n}\r\nsig->group_exit_task = NULL;\r\nsig->notify_count = 0;\r\nno_thread_group:\r\ntsk->exit_signal = SIGCHLD;\r\nexit_itimers(sig);\r\nflush_itimer_signals();\r\nif (atomic_read(&oldsighand->count) != 1) {\r\nstruct sighand_struct *newsighand;\r\nnewsighand = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);\r\nif (!newsighand)\r\nreturn -ENOMEM;\r\natomic_set(&newsighand->count, 1);\r\nmemcpy(newsighand->action, oldsighand->action,\r\nsizeof(newsighand->action));\r\nwrite_lock_irq(&tasklist_lock);\r\nspin_lock(&oldsighand->siglock);\r\nrcu_assign_pointer(tsk->sighand, newsighand);\r\nspin_unlock(&oldsighand->siglock);\r\nwrite_unlock_irq(&tasklist_lock);\r\n__cleanup_sighand(oldsighand);\r\n}\r\nBUG_ON(!thread_group_leader(tsk));\r\nreturn 0;\r\nkilled:\r\nread_lock(&tasklist_lock);\r\nsig->group_exit_task = NULL;\r\nsig->notify_count = 0;\r\nread_unlock(&tasklist_lock);\r\nreturn -EAGAIN;\r\n}\r\nchar *get_task_comm(char *buf, struct task_struct *tsk)\r\n{\r\ntask_lock(tsk);\r\nstrncpy(buf, tsk->comm, sizeof(tsk->comm));\r\ntask_unlock(tsk);\r\nreturn buf;\r\n}\r\nvoid __set_task_comm(struct task_struct *tsk, const char *buf, bool exec)\r\n{\r\ntask_lock(tsk);\r\ntrace_task_rename(tsk, buf);\r\nstrlcpy(tsk->comm, buf, sizeof(tsk->comm));\r\ntask_unlock(tsk);\r\nperf_event_comm(tsk, exec);\r\n}\r\nint flush_old_exec(struct linux_binprm * bprm)\r\n{\r\nint retval;\r\nretval = de_thread(current);\r\nif (retval)\r\ngoto out;\r\nset_mm_exe_file(bprm->mm, bprm->file);\r\nacct_arg_size(bprm, 0);\r\nretval = exec_mmap(bprm->mm);\r\nif (retval)\r\ngoto out;\r\nbprm->mm = NULL;\r\nset_fs(USER_DS);\r\ncurrent->flags &= ~(PF_RANDOMIZE | PF_FORKNOEXEC | PF_KTHREAD |\r\nPF_NOFREEZE | PF_NO_SETAFFINITY);\r\nflush_thread();\r\ncurrent->personality &= ~bprm->per_clear;\r\nreturn 0;\r\nout:\r\nreturn retval;\r\n}\r\nvoid would_dump(struct linux_binprm *bprm, struct file *file)\r\n{\r\nif (inode_permission(file_inode(file), MAY_READ) < 0)\r\nbprm->interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP;\r\n}\r\nvoid setup_new_exec(struct linux_binprm * bprm)\r\n{\r\narch_pick_mmap_layout(current->mm);\r\ncurrent->sas_ss_sp = current->sas_ss_size = 0;\r\nif (uid_eq(current_euid(), current_uid()) && gid_eq(current_egid(), current_gid()))\r\nset_dumpable(current->mm, SUID_DUMP_USER);\r\nelse\r\nset_dumpable(current->mm, suid_dumpable);\r\nperf_event_exec();\r\n__set_task_comm(current, kbasename(bprm->filename), true);\r\ncurrent->mm->task_size = TASK_SIZE;\r\nif (!uid_eq(bprm->cred->uid, current_euid()) ||\r\n!gid_eq(bprm->cred->gid, current_egid())) {\r\ncurrent->pdeath_signal = 0;\r\n} else {\r\nwould_dump(bprm, bprm->file);\r\nif (bprm->interp_flags & BINPRM_FLAGS_ENFORCE_NONDUMP)\r\nset_dumpable(current->mm, suid_dumpable);\r\n}\r\ncurrent->self_exec_id++;\r\nflush_signal_handlers(current, 0);\r\ndo_close_on_exec(current->files);\r\n}\r\nint prepare_bprm_creds(struct linux_binprm *bprm)\r\n{\r\nif (mutex_lock_interruptible(&current->signal->cred_guard_mutex))\r\nreturn -ERESTARTNOINTR;\r\nbprm->cred = prepare_exec_creds();\r\nif (likely(bprm->cred))\r\nreturn 0;\r\nmutex_unlock(&current->signal->cred_guard_mutex);\r\nreturn -ENOMEM;\r\n}\r\nstatic void free_bprm(struct linux_binprm *bprm)\r\n{\r\nfree_arg_pages(bprm);\r\nif (bprm->cred) {\r\nmutex_unlock(&current->signal->cred_guard_mutex);\r\nabort_creds(bprm->cred);\r\n}\r\nif (bprm->file) {\r\nallow_write_access(bprm->file);\r\nfput(bprm->file);\r\n}\r\nif (bprm->interp != bprm->filename)\r\nkfree(bprm->interp);\r\nkfree(bprm);\r\n}\r\nint bprm_change_interp(char *interp, struct linux_binprm *bprm)\r\n{\r\nif (bprm->interp != bprm->filename)\r\nkfree(bprm->interp);\r\nbprm->interp = kstrdup(interp, GFP_KERNEL);\r\nif (!bprm->interp)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid install_exec_creds(struct linux_binprm *bprm)\r\n{\r\nsecurity_bprm_committing_creds(bprm);\r\ncommit_creds(bprm->cred);\r\nbprm->cred = NULL;\r\nif (get_dumpable(current->mm) != SUID_DUMP_USER)\r\nperf_event_exit_task(current);\r\nsecurity_bprm_committed_creds(bprm);\r\nmutex_unlock(&current->signal->cred_guard_mutex);\r\n}\r\nstatic void check_unsafe_exec(struct linux_binprm *bprm)\r\n{\r\nstruct task_struct *p = current, *t;\r\nunsigned n_fs;\r\nif (p->ptrace) {\r\nif (p->ptrace & PT_PTRACE_CAP)\r\nbprm->unsafe |= LSM_UNSAFE_PTRACE_CAP;\r\nelse\r\nbprm->unsafe |= LSM_UNSAFE_PTRACE;\r\n}\r\nif (task_no_new_privs(current))\r\nbprm->unsafe |= LSM_UNSAFE_NO_NEW_PRIVS;\r\nt = p;\r\nn_fs = 1;\r\nspin_lock(&p->fs->lock);\r\nrcu_read_lock();\r\nwhile_each_thread(p, t) {\r\nif (t->fs == p->fs)\r\nn_fs++;\r\n}\r\nrcu_read_unlock();\r\nif (p->fs->users > n_fs)\r\nbprm->unsafe |= LSM_UNSAFE_SHARE;\r\nelse\r\np->fs->in_exec = 1;\r\nspin_unlock(&p->fs->lock);\r\n}\r\nstatic void bprm_fill_uid(struct linux_binprm *bprm)\r\n{\r\nstruct inode *inode;\r\nunsigned int mode;\r\nkuid_t uid;\r\nkgid_t gid;\r\nbprm->cred->euid = current_euid();\r\nbprm->cred->egid = current_egid();\r\nif (bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID)\r\nreturn;\r\nif (task_no_new_privs(current))\r\nreturn;\r\ninode = file_inode(bprm->file);\r\nmode = READ_ONCE(inode->i_mode);\r\nif (!(mode & (S_ISUID|S_ISGID)))\r\nreturn;\r\nmutex_lock(&inode->i_mutex);\r\nmode = inode->i_mode;\r\nuid = inode->i_uid;\r\ngid = inode->i_gid;\r\nmutex_unlock(&inode->i_mutex);\r\nif (!kuid_has_mapping(bprm->cred->user_ns, uid) ||\r\n!kgid_has_mapping(bprm->cred->user_ns, gid))\r\nreturn;\r\nif (mode & S_ISUID) {\r\nbprm->per_clear |= PER_CLEAR_ON_SETID;\r\nbprm->cred->euid = uid;\r\n}\r\nif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\r\nbprm->per_clear |= PER_CLEAR_ON_SETID;\r\nbprm->cred->egid = gid;\r\n}\r\n}\r\nint prepare_binprm(struct linux_binprm *bprm)\r\n{\r\nint retval;\r\nbprm_fill_uid(bprm);\r\nretval = security_bprm_set_creds(bprm);\r\nif (retval)\r\nreturn retval;\r\nbprm->cred_prepared = 1;\r\nmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\r\nreturn kernel_read(bprm->file, 0, bprm->buf, BINPRM_BUF_SIZE);\r\n}\r\nint remove_arg_zero(struct linux_binprm *bprm)\r\n{\r\nint ret = 0;\r\nunsigned long offset;\r\nchar *kaddr;\r\nstruct page *page;\r\nif (!bprm->argc)\r\nreturn 0;\r\ndo {\r\noffset = bprm->p & ~PAGE_MASK;\r\npage = get_arg_page(bprm, bprm->p, 0);\r\nif (!page) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nkaddr = kmap_atomic(page);\r\nfor (; offset < PAGE_SIZE && kaddr[offset];\r\noffset++, bprm->p++)\r\n;\r\nkunmap_atomic(kaddr);\r\nput_arg_page(page);\r\nif (offset == PAGE_SIZE)\r\nfree_arg_page(bprm, (bprm->p >> PAGE_SHIFT) - 1);\r\n} while (offset == PAGE_SIZE);\r\nbprm->p++;\r\nbprm->argc--;\r\nret = 0;\r\nout:\r\nreturn ret;\r\n}\r\nint search_binary_handler(struct linux_binprm *bprm)\r\n{\r\nbool need_retry = IS_ENABLED(CONFIG_MODULES);\r\nstruct linux_binfmt *fmt;\r\nint retval;\r\nif (bprm->recursion_depth > 5)\r\nreturn -ELOOP;\r\nretval = security_bprm_check(bprm);\r\nif (retval)\r\nreturn retval;\r\nretval = -ENOENT;\r\nretry:\r\nread_lock(&binfmt_lock);\r\nlist_for_each_entry(fmt, &formats, lh) {\r\nif (!try_module_get(fmt->module))\r\ncontinue;\r\nread_unlock(&binfmt_lock);\r\nbprm->recursion_depth++;\r\nretval = fmt->load_binary(bprm);\r\nread_lock(&binfmt_lock);\r\nput_binfmt(fmt);\r\nbprm->recursion_depth--;\r\nif (retval < 0 && !bprm->mm) {\r\nread_unlock(&binfmt_lock);\r\nforce_sigsegv(SIGSEGV, current);\r\nreturn retval;\r\n}\r\nif (retval != -ENOEXEC || !bprm->file) {\r\nread_unlock(&binfmt_lock);\r\nreturn retval;\r\n}\r\n}\r\nread_unlock(&binfmt_lock);\r\nif (need_retry) {\r\nif (printable(bprm->buf[0]) && printable(bprm->buf[1]) &&\r\nprintable(bprm->buf[2]) && printable(bprm->buf[3]))\r\nreturn retval;\r\nif (request_module("binfmt-%04x", *(ushort *)(bprm->buf + 2)) < 0)\r\nreturn retval;\r\nneed_retry = false;\r\ngoto retry;\r\n}\r\nreturn retval;\r\n}\r\nstatic int exec_binprm(struct linux_binprm *bprm)\r\n{\r\npid_t old_pid, old_vpid;\r\nint ret;\r\nold_pid = current->pid;\r\nrcu_read_lock();\r\nold_vpid = task_pid_nr_ns(current, task_active_pid_ns(current->parent));\r\nrcu_read_unlock();\r\nret = search_binary_handler(bprm);\r\nif (ret >= 0) {\r\naudit_bprm(bprm);\r\ntrace_sched_process_exec(current, old_pid, bprm);\r\nptrace_event(PTRACE_EVENT_EXEC, old_vpid);\r\nproc_exec_connector(current);\r\n}\r\nreturn ret;\r\n}\r\nstatic int do_execveat_common(int fd, struct filename *filename,\r\nstruct user_arg_ptr argv,\r\nstruct user_arg_ptr envp,\r\nint flags)\r\n{\r\nchar *pathbuf = NULL;\r\nstruct linux_binprm *bprm;\r\nstruct file *file;\r\nstruct files_struct *displaced;\r\nint retval;\r\nif (IS_ERR(filename))\r\nreturn PTR_ERR(filename);\r\nif ((current->flags & PF_NPROC_EXCEEDED) &&\r\natomic_read(&current_user()->processes) > rlimit(RLIMIT_NPROC)) {\r\nretval = -EAGAIN;\r\ngoto out_ret;\r\n}\r\ncurrent->flags &= ~PF_NPROC_EXCEEDED;\r\nretval = unshare_files(&displaced);\r\nif (retval)\r\ngoto out_ret;\r\nretval = -ENOMEM;\r\nbprm = kzalloc(sizeof(*bprm), GFP_KERNEL);\r\nif (!bprm)\r\ngoto out_files;\r\nretval = prepare_bprm_creds(bprm);\r\nif (retval)\r\ngoto out_free;\r\ncheck_unsafe_exec(bprm);\r\ncurrent->in_execve = 1;\r\nfile = do_open_execat(fd, filename, flags);\r\nretval = PTR_ERR(file);\r\nif (IS_ERR(file))\r\ngoto out_unmark;\r\nsched_exec();\r\nbprm->file = file;\r\nif (fd == AT_FDCWD || filename->name[0] == '/') {\r\nbprm->filename = filename->name;\r\n} else {\r\nif (filename->name[0] == '\0')\r\npathbuf = kasprintf(GFP_TEMPORARY, "/dev/fd/%d", fd);\r\nelse\r\npathbuf = kasprintf(GFP_TEMPORARY, "/dev/fd/%d/%s",\r\nfd, filename->name);\r\nif (!pathbuf) {\r\nretval = -ENOMEM;\r\ngoto out_unmark;\r\n}\r\nif (close_on_exec(fd, rcu_dereference_raw(current->files->fdt)))\r\nbprm->interp_flags |= BINPRM_FLAGS_PATH_INACCESSIBLE;\r\nbprm->filename = pathbuf;\r\n}\r\nbprm->interp = bprm->filename;\r\nretval = bprm_mm_init(bprm);\r\nif (retval)\r\ngoto out_unmark;\r\nbprm->argc = count(argv, MAX_ARG_STRINGS);\r\nif ((retval = bprm->argc) < 0)\r\ngoto out;\r\nbprm->envc = count(envp, MAX_ARG_STRINGS);\r\nif ((retval = bprm->envc) < 0)\r\ngoto out;\r\nretval = prepare_binprm(bprm);\r\nif (retval < 0)\r\ngoto out;\r\nretval = copy_strings_kernel(1, &bprm->filename, bprm);\r\nif (retval < 0)\r\ngoto out;\r\nbprm->exec = bprm->p;\r\nretval = copy_strings(bprm->envc, envp, bprm);\r\nif (retval < 0)\r\ngoto out;\r\nretval = copy_strings(bprm->argc, argv, bprm);\r\nif (retval < 0)\r\ngoto out;\r\nretval = exec_binprm(bprm);\r\nif (retval < 0)\r\ngoto out;\r\ncurrent->fs->in_exec = 0;\r\ncurrent->in_execve = 0;\r\nacct_update_integrals(current);\r\ntask_numa_free(current);\r\nfree_bprm(bprm);\r\nkfree(pathbuf);\r\nputname(filename);\r\nif (displaced)\r\nput_files_struct(displaced);\r\nreturn retval;\r\nout:\r\nif (bprm->mm) {\r\nacct_arg_size(bprm, 0);\r\nmmput(bprm->mm);\r\n}\r\nout_unmark:\r\ncurrent->fs->in_exec = 0;\r\ncurrent->in_execve = 0;\r\nout_free:\r\nfree_bprm(bprm);\r\nkfree(pathbuf);\r\nout_files:\r\nif (displaced)\r\nreset_files_struct(displaced);\r\nout_ret:\r\nputname(filename);\r\nreturn retval;\r\n}\r\nint do_execve(struct filename *filename,\r\nconst char __user *const __user *__argv,\r\nconst char __user *const __user *__envp)\r\n{\r\nstruct user_arg_ptr argv = { .ptr.native = __argv };\r\nstruct user_arg_ptr envp = { .ptr.native = __envp };\r\nreturn do_execveat_common(AT_FDCWD, filename, argv, envp, 0);\r\n}\r\nint do_execveat(int fd, struct filename *filename,\r\nconst char __user *const __user *__argv,\r\nconst char __user *const __user *__envp,\r\nint flags)\r\n{\r\nstruct user_arg_ptr argv = { .ptr.native = __argv };\r\nstruct user_arg_ptr envp = { .ptr.native = __envp };\r\nreturn do_execveat_common(fd, filename, argv, envp, flags);\r\n}\r\nstatic int compat_do_execve(struct filename *filename,\r\nconst compat_uptr_t __user *__argv,\r\nconst compat_uptr_t __user *__envp)\r\n{\r\nstruct user_arg_ptr argv = {\r\n.is_compat = true,\r\n.ptr.compat = __argv,\r\n};\r\nstruct user_arg_ptr envp = {\r\n.is_compat = true,\r\n.ptr.compat = __envp,\r\n};\r\nreturn do_execveat_common(AT_FDCWD, filename, argv, envp, 0);\r\n}\r\nstatic int compat_do_execveat(int fd, struct filename *filename,\r\nconst compat_uptr_t __user *__argv,\r\nconst compat_uptr_t __user *__envp,\r\nint flags)\r\n{\r\nstruct user_arg_ptr argv = {\r\n.is_compat = true,\r\n.ptr.compat = __argv,\r\n};\r\nstruct user_arg_ptr envp = {\r\n.is_compat = true,\r\n.ptr.compat = __envp,\r\n};\r\nreturn do_execveat_common(fd, filename, argv, envp, flags);\r\n}\r\nvoid set_binfmt(struct linux_binfmt *new)\r\n{\r\nstruct mm_struct *mm = current->mm;\r\nif (mm->binfmt)\r\nmodule_put(mm->binfmt->module);\r\nmm->binfmt = new;\r\nif (new)\r\n__module_get(new->module);\r\n}\r\nvoid set_dumpable(struct mm_struct *mm, int value)\r\n{\r\nunsigned long old, new;\r\nif (WARN_ON((unsigned)value > SUID_DUMP_ROOT))\r\nreturn;\r\ndo {\r\nold = ACCESS_ONCE(mm->flags);\r\nnew = (old & ~MMF_DUMPABLE_MASK) | value;\r\n} while (cmpxchg(&mm->flags, old, new) != old);\r\n}
