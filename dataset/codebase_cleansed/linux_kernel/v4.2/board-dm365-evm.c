static inline int have_imager(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline int have_tvp7002(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic int dm365evm_keyscan_enable(struct device *dev)\r\n{\r\nreturn davinci_cfg_reg(DM365_KEYSCAN);\r\n}\r\nstatic int cpld_mmc_get_cd(int module)\r\n{\r\nif (!cpld)\r\nreturn -ENXIO;\r\nreturn !(__raw_readb(cpld + CPLD_CARDSTAT) & BIT(module ? 4 : 0));\r\n}\r\nstatic int cpld_mmc_get_ro(int module)\r\n{\r\nif (!cpld)\r\nreturn -ENXIO;\r\nreturn !!(__raw_readb(cpld + CPLD_CARDSTAT) & BIT(module ? 5 : 1));\r\n}\r\nstatic void dm365evm_emac_configure(void)\r\n{\r\ndavinci_cfg_reg(DM365_EMAC_TX_EN);\r\ndavinci_cfg_reg(DM365_EMAC_TX_CLK);\r\ndavinci_cfg_reg(DM365_EMAC_COL);\r\ndavinci_cfg_reg(DM365_EMAC_TXD3);\r\ndavinci_cfg_reg(DM365_EMAC_TXD2);\r\ndavinci_cfg_reg(DM365_EMAC_TXD1);\r\ndavinci_cfg_reg(DM365_EMAC_TXD0);\r\ndavinci_cfg_reg(DM365_EMAC_RXD3);\r\ndavinci_cfg_reg(DM365_EMAC_RXD2);\r\ndavinci_cfg_reg(DM365_EMAC_RXD1);\r\ndavinci_cfg_reg(DM365_EMAC_RXD0);\r\ndavinci_cfg_reg(DM365_EMAC_RX_CLK);\r\ndavinci_cfg_reg(DM365_EMAC_RX_DV);\r\ndavinci_cfg_reg(DM365_EMAC_RX_ER);\r\ndavinci_cfg_reg(DM365_EMAC_CRS);\r\ndavinci_cfg_reg(DM365_EMAC_MDIO);\r\ndavinci_cfg_reg(DM365_EMAC_MDCLK);\r\ndavinci_cfg_reg(DM365_INT_EMAC_RXTHRESH);\r\ndavinci_cfg_reg(DM365_INT_EMAC_RXPULSE);\r\ndavinci_cfg_reg(DM365_INT_EMAC_TXPULSE);\r\ndavinci_cfg_reg(DM365_INT_EMAC_MISCPULSE);\r\n}\r\nstatic void dm365evm_mmc_configure(void)\r\n{\r\ndavinci_cfg_reg(DM365_SD1_CLK);\r\ndavinci_cfg_reg(DM365_SD1_CMD);\r\ndavinci_cfg_reg(DM365_SD1_DATA3);\r\ndavinci_cfg_reg(DM365_SD1_DATA2);\r\ndavinci_cfg_reg(DM365_SD1_DATA1);\r\ndavinci_cfg_reg(DM365_SD1_DATA0);\r\n}\r\nstatic void __init evm_init_i2c(void)\r\n{\r\ndavinci_init_i2c(&i2c_pdata);\r\ni2c_register_board_info(1, i2c_info, ARRAY_SIZE(i2c_info));\r\n}\r\nstatic inline int have_leds(void)\r\n{\r\n#ifdef CONFIG_LEDS_CLASS\r\nreturn 1;\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic void cpld_led_set(struct led_classdev *cdev, enum led_brightness b)\r\n{\r\nstruct cpld_led *led = container_of(cdev, struct cpld_led, cdev);\r\nu8 reg = __raw_readb(cpld + CPLD_LEDS);\r\nif (b != LED_OFF)\r\nreg &= ~led->mask;\r\nelse\r\nreg |= led->mask;\r\n__raw_writeb(reg, cpld + CPLD_LEDS);\r\n}\r\nstatic enum led_brightness cpld_led_get(struct led_classdev *cdev)\r\n{\r\nstruct cpld_led *led = container_of(cdev, struct cpld_led, cdev);\r\nu8 reg = __raw_readb(cpld + CPLD_LEDS);\r\nreturn (reg & led->mask) ? LED_OFF : LED_FULL;\r\n}\r\nstatic int __init cpld_leds_init(void)\r\n{\r\nint i;\r\nif (!have_leds() || !cpld)\r\nreturn 0;\r\n__raw_writeb(0xff, cpld + CPLD_LEDS);\r\nfor (i = 0; i < ARRAY_SIZE(cpld_leds); i++) {\r\nstruct cpld_led *led;\r\nled = kzalloc(sizeof(*led), GFP_KERNEL);\r\nif (!led)\r\nbreak;\r\nled->cdev.name = cpld_leds[i].name;\r\nled->cdev.brightness_set = cpld_led_set;\r\nled->cdev.brightness_get = cpld_led_get;\r\nled->cdev.default_trigger = cpld_leds[i].trigger;\r\nled->mask = BIT(i);\r\nif (led_classdev_register(NULL, &led->cdev) < 0) {\r\nkfree(led);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void __init evm_init_cpld(void)\r\n{\r\nu8 mux, resets;\r\nconst char *label;\r\nstruct clk *aemif_clk;\r\naemif_clk = clk_get(NULL, "aemif");\r\nif (IS_ERR(aemif_clk))\r\nreturn;\r\nclk_prepare_enable(aemif_clk);\r\nif (request_mem_region(DM365_ASYNC_EMIF_DATA_CE1_BASE, SECTION_SIZE,\r\n"cpld") == NULL)\r\ngoto fail;\r\ncpld = ioremap(DM365_ASYNC_EMIF_DATA_CE1_BASE, SECTION_SIZE);\r\nif (!cpld) {\r\nrelease_mem_region(DM365_ASYNC_EMIF_DATA_CE1_BASE,\r\nSECTION_SIZE);\r\nfail:\r\npr_err("ERROR: can't map CPLD\n");\r\nclk_disable_unprepare(aemif_clk);\r\nreturn;\r\n}\r\nmux = 0;\r\nif ((__raw_readb(cpld + CPLD_SWITCH) & BIT(5)) == 0) {\r\nmux |= BIT(7);\r\nplatform_add_devices(dm365_evm_nand_devices,\r\nARRAY_SIZE(dm365_evm_nand_devices));\r\n} else {\r\n}\r\nresets = BIT(3) | BIT(2) | BIT(1) | BIT(0);\r\nif (have_imager()) {\r\nlabel = "HD imager";\r\nmux |= 2;\r\nmux |= BIT(6) | BIT(5) | BIT(3);\r\n} else {\r\nstruct davinci_soc_info *soc_info = &davinci_soc_info;\r\ndm365evm_mmc_configure();\r\ndavinci_setup_mmc(1, &dm365evm_mmc_config);\r\ndm365evm_emac_configure();\r\nsoc_info->emac_pdata->phy_id = DM365_EVM_PHY_ID;\r\nresets &= ~BIT(3);\r\nresets &= ~BIT(1);\r\nif (have_tvp7002()) {\r\nmux |= 1;\r\nresets &= ~BIT(2);\r\nlabel = "tvp7002 HD";\r\n} else {\r\nmux |= 5;\r\nresets &= ~BIT(0);\r\nlabel = "tvp5146 SD";\r\n}\r\n}\r\n__raw_writeb(mux, cpld + CPLD_MUX);\r\n__raw_writeb(resets, cpld + CPLD_RESETS);\r\npr_info("EVM: %s video input\n", label);\r\n}\r\nstatic void __init dm365_evm_map_io(void)\r\n{\r\ndm365_init();\r\n}\r\nstatic __init void dm365_evm_init(void)\r\n{\r\nint ret;\r\nret = dm365_gpio_register();\r\nif (ret)\r\npr_warn("%s: GPIO init failed: %d\n", __func__, ret);\r\nevm_init_i2c();\r\ndavinci_serial_init(dm365_serial_device);\r\ndm365evm_emac_configure();\r\ndm365evm_mmc_configure();\r\ndavinci_setup_mmc(0, &dm365evm_mmc_config);\r\ndm365_init_video(&vpfe_cfg, &dm365evm_display_cfg);\r\nevm_init_cpld();\r\n#ifdef CONFIG_SND_DM365_AIC3X_CODEC\r\ndm365_init_asp(&dm365_evm_snd_data);\r\n#elif defined(CONFIG_SND_DM365_VOICE_CODEC)\r\ndm365_init_vc(&dm365_evm_snd_data);\r\n#endif\r\ndm365_init_rtc();\r\ndm365_init_ks(&dm365evm_ks_data);\r\ndm365_init_spi0(BIT(0), dm365_evm_spi_info,\r\nARRAY_SIZE(dm365_evm_spi_info));\r\n}
