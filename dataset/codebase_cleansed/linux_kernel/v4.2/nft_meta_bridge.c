static void nft_meta_bridge_get_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_meta *priv = nft_expr_priv(expr);\r\nconst struct net_device *in = pkt->in, *out = pkt->out;\r\nu32 *dest = &regs->data[priv->dreg];\r\nconst struct net_bridge_port *p;\r\nswitch (priv->key) {\r\ncase NFT_META_BRI_IIFNAME:\r\nif (in == NULL || (p = br_port_get_rcu(in)) == NULL)\r\ngoto err;\r\nbreak;\r\ncase NFT_META_BRI_OIFNAME:\r\nif (out == NULL || (p = br_port_get_rcu(out)) == NULL)\r\ngoto err;\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\nstrncpy((char *)dest, p->br->dev->name, IFNAMSIZ);\r\nreturn;\r\nout:\r\nreturn nft_meta_get_eval(expr, regs, pkt);\r\nerr:\r\nregs->verdict.code = NFT_BREAK;\r\n}\r\nstatic int nft_meta_bridge_get_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_meta *priv = nft_expr_priv(expr);\r\nunsigned int len;\r\npriv->key = ntohl(nla_get_be32(tb[NFTA_META_KEY]));\r\nswitch (priv->key) {\r\ncase NFT_META_BRI_IIFNAME:\r\ncase NFT_META_BRI_OIFNAME:\r\nlen = IFNAMSIZ;\r\nbreak;\r\ndefault:\r\nreturn nft_meta_get_init(ctx, expr, tb);\r\n}\r\npriv->dreg = nft_parse_register(tb[NFTA_META_DREG]);\r\nreturn nft_validate_register_store(ctx, priv->dreg, NULL,\r\nNFT_DATA_VALUE, len);\r\n}\r\nstatic const struct nft_expr_ops *\r\nnft_meta_bridge_select_ops(const struct nft_ctx *ctx,\r\nconst struct nlattr * const tb[])\r\n{\r\nif (tb[NFTA_META_KEY] == NULL)\r\nreturn ERR_PTR(-EINVAL);\r\nif (tb[NFTA_META_DREG] && tb[NFTA_META_SREG])\r\nreturn ERR_PTR(-EINVAL);\r\nif (tb[NFTA_META_DREG])\r\nreturn &nft_meta_bridge_get_ops;\r\nif (tb[NFTA_META_SREG])\r\nreturn &nft_meta_bridge_set_ops;\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic int __init nft_meta_bridge_module_init(void)\r\n{\r\nreturn nft_register_expr(&nft_meta_bridge_type);\r\n}\r\nstatic void __exit nft_meta_bridge_module_exit(void)\r\n{\r\nnft_unregister_expr(&nft_meta_bridge_type);\r\n}
