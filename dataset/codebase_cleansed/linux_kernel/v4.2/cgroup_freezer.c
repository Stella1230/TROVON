static inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\r\n{\r\nreturn css ? container_of(css, struct freezer, css) : NULL;\r\n}\r\nstatic inline struct freezer *task_freezer(struct task_struct *task)\r\n{\r\nreturn css_freezer(task_css(task, freezer_cgrp_id));\r\n}\r\nstatic struct freezer *parent_freezer(struct freezer *freezer)\r\n{\r\nreturn css_freezer(freezer->css.parent);\r\n}\r\nbool cgroup_freezing(struct task_struct *task)\r\n{\r\nbool ret;\r\nrcu_read_lock();\r\nret = task_freezer(task)->state & CGROUP_FREEZING;\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nstatic const char *freezer_state_strs(unsigned int state)\r\n{\r\nif (state & CGROUP_FROZEN)\r\nreturn "FROZEN";\r\nif (state & CGROUP_FREEZING)\r\nreturn "FREEZING";\r\nreturn "THAWED";\r\n}\r\nstatic struct cgroup_subsys_state *\r\nfreezer_css_alloc(struct cgroup_subsys_state *parent_css)\r\n{\r\nstruct freezer *freezer;\r\nfreezer = kzalloc(sizeof(struct freezer), GFP_KERNEL);\r\nif (!freezer)\r\nreturn ERR_PTR(-ENOMEM);\r\nreturn &freezer->css;\r\n}\r\nstatic int freezer_css_online(struct cgroup_subsys_state *css)\r\n{\r\nstruct freezer *freezer = css_freezer(css);\r\nstruct freezer *parent = parent_freezer(freezer);\r\nmutex_lock(&freezer_mutex);\r\nfreezer->state |= CGROUP_FREEZER_ONLINE;\r\nif (parent && (parent->state & CGROUP_FREEZING)) {\r\nfreezer->state |= CGROUP_FREEZING_PARENT | CGROUP_FROZEN;\r\natomic_inc(&system_freezing_cnt);\r\n}\r\nmutex_unlock(&freezer_mutex);\r\nreturn 0;\r\n}\r\nstatic void freezer_css_offline(struct cgroup_subsys_state *css)\r\n{\r\nstruct freezer *freezer = css_freezer(css);\r\nmutex_lock(&freezer_mutex);\r\nif (freezer->state & CGROUP_FREEZING)\r\natomic_dec(&system_freezing_cnt);\r\nfreezer->state = 0;\r\nmutex_unlock(&freezer_mutex);\r\n}\r\nstatic void freezer_css_free(struct cgroup_subsys_state *css)\r\n{\r\nkfree(css_freezer(css));\r\n}\r\nstatic void freezer_attach(struct cgroup_subsys_state *new_css,\r\nstruct cgroup_taskset *tset)\r\n{\r\nstruct freezer *freezer = css_freezer(new_css);\r\nstruct task_struct *task;\r\nbool clear_frozen = false;\r\nmutex_lock(&freezer_mutex);\r\ncgroup_taskset_for_each(task, tset) {\r\nif (!(freezer->state & CGROUP_FREEZING)) {\r\n__thaw_task(task);\r\n} else {\r\nfreeze_task(task);\r\nfreezer->state &= ~CGROUP_FROZEN;\r\nclear_frozen = true;\r\n}\r\n}\r\nwhile (clear_frozen && (freezer = parent_freezer(freezer))) {\r\nfreezer->state &= ~CGROUP_FROZEN;\r\nclear_frozen = freezer->state & CGROUP_FREEZING;\r\n}\r\nmutex_unlock(&freezer_mutex);\r\n}\r\nstatic void freezer_fork(struct task_struct *task)\r\n{\r\nstruct freezer *freezer;\r\nif (task_css_is_root(task, freezer_cgrp_id))\r\nreturn;\r\nmutex_lock(&freezer_mutex);\r\nrcu_read_lock();\r\nfreezer = task_freezer(task);\r\nif (freezer->state & CGROUP_FREEZING)\r\nfreeze_task(task);\r\nrcu_read_unlock();\r\nmutex_unlock(&freezer_mutex);\r\n}\r\nstatic void update_if_frozen(struct cgroup_subsys_state *css)\r\n{\r\nstruct freezer *freezer = css_freezer(css);\r\nstruct cgroup_subsys_state *pos;\r\nstruct css_task_iter it;\r\nstruct task_struct *task;\r\nlockdep_assert_held(&freezer_mutex);\r\nif (!(freezer->state & CGROUP_FREEZING) ||\r\n(freezer->state & CGROUP_FROZEN))\r\nreturn;\r\nrcu_read_lock();\r\ncss_for_each_child(pos, css) {\r\nstruct freezer *child = css_freezer(pos);\r\nif ((child->state & CGROUP_FREEZER_ONLINE) &&\r\n!(child->state & CGROUP_FROZEN)) {\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\n}\r\nrcu_read_unlock();\r\ncss_task_iter_start(css, &it);\r\nwhile ((task = css_task_iter_next(&it))) {\r\nif (freezing(task)) {\r\nif (!frozen(task) && !freezer_should_skip(task))\r\ngoto out_iter_end;\r\n}\r\n}\r\nfreezer->state |= CGROUP_FROZEN;\r\nout_iter_end:\r\ncss_task_iter_end(&it);\r\n}\r\nstatic int freezer_read(struct seq_file *m, void *v)\r\n{\r\nstruct cgroup_subsys_state *css = seq_css(m), *pos;\r\nmutex_lock(&freezer_mutex);\r\nrcu_read_lock();\r\ncss_for_each_descendant_post(pos, css) {\r\nif (!css_tryget_online(pos))\r\ncontinue;\r\nrcu_read_unlock();\r\nupdate_if_frozen(pos);\r\nrcu_read_lock();\r\ncss_put(pos);\r\n}\r\nrcu_read_unlock();\r\nmutex_unlock(&freezer_mutex);\r\nseq_puts(m, freezer_state_strs(css_freezer(css)->state));\r\nseq_putc(m, '\n');\r\nreturn 0;\r\n}\r\nstatic void freeze_cgroup(struct freezer *freezer)\r\n{\r\nstruct css_task_iter it;\r\nstruct task_struct *task;\r\ncss_task_iter_start(&freezer->css, &it);\r\nwhile ((task = css_task_iter_next(&it)))\r\nfreeze_task(task);\r\ncss_task_iter_end(&it);\r\n}\r\nstatic void unfreeze_cgroup(struct freezer *freezer)\r\n{\r\nstruct css_task_iter it;\r\nstruct task_struct *task;\r\ncss_task_iter_start(&freezer->css, &it);\r\nwhile ((task = css_task_iter_next(&it)))\r\n__thaw_task(task);\r\ncss_task_iter_end(&it);\r\n}\r\nstatic void freezer_apply_state(struct freezer *freezer, bool freeze,\r\nunsigned int state)\r\n{\r\nlockdep_assert_held(&freezer_mutex);\r\nif (!(freezer->state & CGROUP_FREEZER_ONLINE))\r\nreturn;\r\nif (freeze) {\r\nif (!(freezer->state & CGROUP_FREEZING))\r\natomic_inc(&system_freezing_cnt);\r\nfreezer->state |= state;\r\nfreeze_cgroup(freezer);\r\n} else {\r\nbool was_freezing = freezer->state & CGROUP_FREEZING;\r\nfreezer->state &= ~state;\r\nif (!(freezer->state & CGROUP_FREEZING)) {\r\nif (was_freezing)\r\natomic_dec(&system_freezing_cnt);\r\nfreezer->state &= ~CGROUP_FROZEN;\r\nunfreeze_cgroup(freezer);\r\n}\r\n}\r\n}\r\nstatic void freezer_change_state(struct freezer *freezer, bool freeze)\r\n{\r\nstruct cgroup_subsys_state *pos;\r\nmutex_lock(&freezer_mutex);\r\nrcu_read_lock();\r\ncss_for_each_descendant_pre(pos, &freezer->css) {\r\nstruct freezer *pos_f = css_freezer(pos);\r\nstruct freezer *parent = parent_freezer(pos_f);\r\nif (!css_tryget_online(pos))\r\ncontinue;\r\nrcu_read_unlock();\r\nif (pos_f == freezer)\r\nfreezer_apply_state(pos_f, freeze,\r\nCGROUP_FREEZING_SELF);\r\nelse\r\nfreezer_apply_state(pos_f,\r\nparent->state & CGROUP_FREEZING,\r\nCGROUP_FREEZING_PARENT);\r\nrcu_read_lock();\r\ncss_put(pos);\r\n}\r\nrcu_read_unlock();\r\nmutex_unlock(&freezer_mutex);\r\n}\r\nstatic ssize_t freezer_write(struct kernfs_open_file *of,\r\nchar *buf, size_t nbytes, loff_t off)\r\n{\r\nbool freeze;\r\nbuf = strstrip(buf);\r\nif (strcmp(buf, freezer_state_strs(0)) == 0)\r\nfreeze = false;\r\nelse if (strcmp(buf, freezer_state_strs(CGROUP_FROZEN)) == 0)\r\nfreeze = true;\r\nelse\r\nreturn -EINVAL;\r\nfreezer_change_state(css_freezer(of_css(of)), freeze);\r\nreturn nbytes;\r\n}\r\nstatic u64 freezer_self_freezing_read(struct cgroup_subsys_state *css,\r\nstruct cftype *cft)\r\n{\r\nstruct freezer *freezer = css_freezer(css);\r\nreturn (bool)(freezer->state & CGROUP_FREEZING_SELF);\r\n}\r\nstatic u64 freezer_parent_freezing_read(struct cgroup_subsys_state *css,\r\nstruct cftype *cft)\r\n{\r\nstruct freezer *freezer = css_freezer(css);\r\nreturn (bool)(freezer->state & CGROUP_FREEZING_PARENT);\r\n}
