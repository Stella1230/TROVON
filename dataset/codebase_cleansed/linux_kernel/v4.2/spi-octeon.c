static void octeon_spi_wait_ready(struct octeon_spi *p)\r\n{\r\nunion cvmx_mpi_sts mpi_sts;\r\nunsigned int loops = 0;\r\ndo {\r\nif (loops++)\r\n__delay(500);\r\nmpi_sts.u64 = cvmx_read_csr(p->register_base + OCTEON_SPI_STS);\r\n} while (mpi_sts.s.busy);\r\n}\r\nstatic int octeon_spi_do_transfer(struct octeon_spi *p,\r\nstruct spi_message *msg,\r\nstruct spi_transfer *xfer,\r\nbool last_xfer)\r\n{\r\nstruct spi_device *spi = msg->spi;\r\nunion cvmx_mpi_cfg mpi_cfg;\r\nunion cvmx_mpi_tx mpi_tx;\r\nunsigned int clkdiv;\r\nunsigned int speed_hz;\r\nint mode;\r\nbool cpha, cpol;\r\nconst u8 *tx_buf;\r\nu8 *rx_buf;\r\nint len;\r\nint i;\r\nmode = spi->mode;\r\ncpha = mode & SPI_CPHA;\r\ncpol = mode & SPI_CPOL;\r\nspeed_hz = xfer->speed_hz ? : spi->max_speed_hz;\r\nclkdiv = octeon_get_io_clock_rate() / (2 * speed_hz);\r\nmpi_cfg.u64 = 0;\r\nmpi_cfg.s.clkdiv = clkdiv;\r\nmpi_cfg.s.cshi = (mode & SPI_CS_HIGH) ? 1 : 0;\r\nmpi_cfg.s.lsbfirst = (mode & SPI_LSB_FIRST) ? 1 : 0;\r\nmpi_cfg.s.wireor = (mode & SPI_3WIRE) ? 1 : 0;\r\nmpi_cfg.s.idlelo = cpha != cpol;\r\nmpi_cfg.s.cslate = cpha ? 1 : 0;\r\nmpi_cfg.s.enable = 1;\r\nif (spi->chip_select < 4)\r\np->cs_enax |= 1ull << (12 + spi->chip_select);\r\nmpi_cfg.u64 |= p->cs_enax;\r\nif (mpi_cfg.u64 != p->last_cfg) {\r\np->last_cfg = mpi_cfg.u64;\r\ncvmx_write_csr(p->register_base + OCTEON_SPI_CFG, mpi_cfg.u64);\r\n}\r\ntx_buf = xfer->tx_buf;\r\nrx_buf = xfer->rx_buf;\r\nlen = xfer->len;\r\nwhile (len > OCTEON_SPI_MAX_BYTES) {\r\nfor (i = 0; i < OCTEON_SPI_MAX_BYTES; i++) {\r\nu8 d;\r\nif (tx_buf)\r\nd = *tx_buf++;\r\nelse\r\nd = 0;\r\ncvmx_write_csr(p->register_base + OCTEON_SPI_DAT0 + (8 * i), d);\r\n}\r\nmpi_tx.u64 = 0;\r\nmpi_tx.s.csid = spi->chip_select;\r\nmpi_tx.s.leavecs = 1;\r\nmpi_tx.s.txnum = tx_buf ? OCTEON_SPI_MAX_BYTES : 0;\r\nmpi_tx.s.totnum = OCTEON_SPI_MAX_BYTES;\r\ncvmx_write_csr(p->register_base + OCTEON_SPI_TX, mpi_tx.u64);\r\nocteon_spi_wait_ready(p);\r\nif (rx_buf)\r\nfor (i = 0; i < OCTEON_SPI_MAX_BYTES; i++) {\r\nu64 v = cvmx_read_csr(p->register_base + OCTEON_SPI_DAT0 + (8 * i));\r\n*rx_buf++ = (u8)v;\r\n}\r\nlen -= OCTEON_SPI_MAX_BYTES;\r\n}\r\nfor (i = 0; i < len; i++) {\r\nu8 d;\r\nif (tx_buf)\r\nd = *tx_buf++;\r\nelse\r\nd = 0;\r\ncvmx_write_csr(p->register_base + OCTEON_SPI_DAT0 + (8 * i), d);\r\n}\r\nmpi_tx.u64 = 0;\r\nmpi_tx.s.csid = spi->chip_select;\r\nif (last_xfer)\r\nmpi_tx.s.leavecs = xfer->cs_change;\r\nelse\r\nmpi_tx.s.leavecs = !xfer->cs_change;\r\nmpi_tx.s.txnum = tx_buf ? len : 0;\r\nmpi_tx.s.totnum = len;\r\ncvmx_write_csr(p->register_base + OCTEON_SPI_TX, mpi_tx.u64);\r\nocteon_spi_wait_ready(p);\r\nif (rx_buf)\r\nfor (i = 0; i < len; i++) {\r\nu64 v = cvmx_read_csr(p->register_base + OCTEON_SPI_DAT0 + (8 * i));\r\n*rx_buf++ = (u8)v;\r\n}\r\nif (xfer->delay_usecs)\r\nudelay(xfer->delay_usecs);\r\nreturn xfer->len;\r\n}\r\nstatic int octeon_spi_transfer_one_message(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nstruct octeon_spi *p = spi_master_get_devdata(master);\r\nunsigned int total_len = 0;\r\nint status = 0;\r\nstruct spi_transfer *xfer;\r\nlist_for_each_entry(xfer, &msg->transfers, transfer_list) {\r\nbool last_xfer = list_is_last(&xfer->transfer_list,\r\n&msg->transfers);\r\nint r = octeon_spi_do_transfer(p, msg, xfer, last_xfer);\r\nif (r < 0) {\r\nstatus = r;\r\ngoto err;\r\n}\r\ntotal_len += r;\r\n}\r\nerr:\r\nmsg->status = status;\r\nmsg->actual_length = total_len;\r\nspi_finalize_current_message(master);\r\nreturn status;\r\n}\r\nstatic int octeon_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res_mem;\r\nstruct spi_master *master;\r\nstruct octeon_spi *p;\r\nint err = -ENOENT;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(struct octeon_spi));\r\nif (!master)\r\nreturn -ENOMEM;\r\np = spi_master_get_devdata(master);\r\nplatform_set_drvdata(pdev, master);\r\nres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res_mem == NULL) {\r\ndev_err(&pdev->dev, "found no memory resource\n");\r\nerr = -ENXIO;\r\ngoto fail;\r\n}\r\nif (!devm_request_mem_region(&pdev->dev, res_mem->start,\r\nresource_size(res_mem), res_mem->name)) {\r\ndev_err(&pdev->dev, "request_mem_region failed\n");\r\ngoto fail;\r\n}\r\np->register_base = (u64)devm_ioremap(&pdev->dev, res_mem->start,\r\nresource_size(res_mem));\r\nmaster->num_chipselect = 4;\r\nmaster->mode_bits = SPI_CPHA |\r\nSPI_CPOL |\r\nSPI_CS_HIGH |\r\nSPI_LSB_FIRST |\r\nSPI_3WIRE;\r\nmaster->transfer_one_message = octeon_spi_transfer_one_message;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(8);\r\nmaster->max_speed_hz = OCTEON_SPI_MAX_CLOCK_HZ;\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nerr = devm_spi_register_master(&pdev->dev, master);\r\nif (err) {\r\ndev_err(&pdev->dev, "register master failed: %d\n", err);\r\ngoto fail;\r\n}\r\ndev_info(&pdev->dev, "OCTEON SPI bus driver\n");\r\nreturn 0;\r\nfail:\r\nspi_master_put(master);\r\nreturn err;\r\n}\r\nstatic int octeon_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct octeon_spi *p = spi_master_get_devdata(master);\r\nu64 register_base = p->register_base;\r\ncvmx_write_csr(register_base + OCTEON_SPI_CFG, 0);\r\nreturn 0;\r\n}
