static int mmp_clk_gate_enable(struct clk_hw *hw)\r\n{\r\nstruct mmp_clk_gate *gate = to_clk_mmp_gate(hw);\r\nstruct clk *clk = hw->clk;\r\nunsigned long flags = 0;\r\nunsigned long rate;\r\nu32 tmp;\r\nif (gate->lock)\r\nspin_lock_irqsave(gate->lock, flags);\r\ntmp = readl(gate->reg);\r\ntmp &= ~gate->mask;\r\ntmp |= gate->val_enable;\r\nwritel(tmp, gate->reg);\r\nif (gate->lock)\r\nspin_unlock_irqrestore(gate->lock, flags);\r\nif (gate->flags & MMP_CLK_GATE_NEED_DELAY) {\r\nrate = __clk_get_rate(clk);\r\nudelay(2000000/rate);\r\n}\r\nreturn 0;\r\n}\r\nstatic void mmp_clk_gate_disable(struct clk_hw *hw)\r\n{\r\nstruct mmp_clk_gate *gate = to_clk_mmp_gate(hw);\r\nunsigned long flags = 0;\r\nu32 tmp;\r\nif (gate->lock)\r\nspin_lock_irqsave(gate->lock, flags);\r\ntmp = readl(gate->reg);\r\ntmp &= ~gate->mask;\r\ntmp |= gate->val_disable;\r\nwritel(tmp, gate->reg);\r\nif (gate->lock)\r\nspin_unlock_irqrestore(gate->lock, flags);\r\n}\r\nstatic int mmp_clk_gate_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct mmp_clk_gate *gate = to_clk_mmp_gate(hw);\r\nunsigned long flags = 0;\r\nu32 tmp;\r\nif (gate->lock)\r\nspin_lock_irqsave(gate->lock, flags);\r\ntmp = readl(gate->reg);\r\nif (gate->lock)\r\nspin_unlock_irqrestore(gate->lock, flags);\r\nreturn (tmp & gate->mask) == gate->val_enable;\r\n}\r\nstruct clk *mmp_clk_register_gate(struct device *dev, const char *name,\r\nconst char *parent_name, unsigned long flags,\r\nvoid __iomem *reg, u32 mask, u32 val_enable, u32 val_disable,\r\nunsigned int gate_flags, spinlock_t *lock)\r\n{\r\nstruct mmp_clk_gate *gate;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\ngate = kzalloc(sizeof(*gate), GFP_KERNEL);\r\nif (!gate) {\r\npr_err("%s:%s could not allocate gate clk\n", __func__, name);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ninit.name = name;\r\ninit.ops = &mmp_clk_gate_ops;\r\ninit.flags = flags | CLK_IS_BASIC;\r\ninit.parent_names = (parent_name ? &parent_name : NULL);\r\ninit.num_parents = (parent_name ? 1 : 0);\r\ngate->reg = reg;\r\ngate->mask = mask;\r\ngate->val_enable = val_enable;\r\ngate->val_disable = val_disable;\r\ngate->flags = gate_flags;\r\ngate->lock = lock;\r\ngate->hw.init = &init;\r\nclk = clk_register(dev, &gate->hw);\r\nif (IS_ERR(clk))\r\nkfree(gate);\r\nreturn clk;\r\n}
