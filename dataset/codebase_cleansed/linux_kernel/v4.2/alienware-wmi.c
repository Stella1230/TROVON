static int __init dmi_matched(const struct dmi_system_id *dmi)\r\n{\r\nquirks = dmi->driver_data;\r\nreturn 1;\r\n}\r\nstatic int parse_rgb(const char *buf, struct platform_zone *zone)\r\n{\r\nlong unsigned int rgb;\r\nint ret;\r\nunion color_union {\r\nstruct color_platform cp;\r\nint package;\r\n} repackager;\r\nret = kstrtoul(buf, 16, &rgb);\r\nif (ret)\r\nreturn ret;\r\nif (rgb > 0xFFFFFF)\r\nreturn -EINVAL;\r\nrepackager.package = rgb & 0x0f0f0f0f;\r\npr_debug("alienware-wmi: r: %d g:%d b: %d\n",\r\nrepackager.cp.red, repackager.cp.green, repackager.cp.blue);\r\nzone->colors = repackager.cp;\r\nreturn 0;\r\n}\r\nstatic struct platform_zone *match_zone(struct device_attribute *attr)\r\n{\r\nint i;\r\nfor (i = 0; i < quirks->num_zones; i++) {\r\nif ((struct device_attribute *)zone_data[i].attr == attr) {\r\npr_debug("alienware-wmi: matched zone location: %d\n",\r\nzone_data[i].location);\r\nreturn &zone_data[i];\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int alienware_update_led(struct platform_zone *zone)\r\n{\r\nint method_id;\r\nacpi_status status;\r\nchar *guid;\r\nstruct acpi_buffer input;\r\nstruct legacy_led_args legacy_args;\r\nstruct wmax_led_args wmax_args;\r\nif (interface == WMAX) {\r\nwmax_args.led_mask = 1 << zone->location;\r\nwmax_args.colors = zone->colors;\r\nwmax_args.state = lighting_control_state;\r\nguid = WMAX_CONTROL_GUID;\r\nmethod_id = WMAX_METHOD_ZONE_CONTROL;\r\ninput.length = (acpi_size) sizeof(wmax_args);\r\ninput.pointer = &wmax_args;\r\n} else {\r\nlegacy_args.colors = zone->colors;\r\nlegacy_args.brightness = global_brightness;\r\nlegacy_args.state = 0;\r\nif (lighting_control_state == LEGACY_BOOTING ||\r\nlighting_control_state == LEGACY_SUSPEND) {\r\nguid = LEGACY_POWER_CONTROL_GUID;\r\nlegacy_args.state = lighting_control_state;\r\n} else\r\nguid = LEGACY_CONTROL_GUID;\r\nmethod_id = zone->location + 1;\r\ninput.length = (acpi_size) sizeof(legacy_args);\r\ninput.pointer = &legacy_args;\r\n}\r\npr_debug("alienware-wmi: guid %s method %d\n", guid, method_id);\r\nstatus = wmi_evaluate_method(guid, 1, method_id, &input, NULL);\r\nif (ACPI_FAILURE(status))\r\npr_err("alienware-wmi: zone set failure: %u\n", status);\r\nreturn ACPI_FAILURE(status);\r\n}\r\nstatic ssize_t zone_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct platform_zone *target_zone;\r\ntarget_zone = match_zone(attr);\r\nif (target_zone == NULL)\r\nreturn sprintf(buf, "red: -1, green: -1, blue: -1\n");\r\nreturn sprintf(buf, "red: %d, green: %d, blue: %d\n",\r\ntarget_zone->colors.red,\r\ntarget_zone->colors.green, target_zone->colors.blue);\r\n}\r\nstatic ssize_t zone_set(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct platform_zone *target_zone;\r\nint ret;\r\ntarget_zone = match_zone(attr);\r\nif (target_zone == NULL) {\r\npr_err("alienware-wmi: invalid target zone\n");\r\nreturn 1;\r\n}\r\nret = parse_rgb(buf, target_zone);\r\nif (ret)\r\nreturn ret;\r\nret = alienware_update_led(target_zone);\r\nreturn ret ? ret : count;\r\n}\r\nstatic int wmax_brightness(int brightness)\r\n{\r\nacpi_status status;\r\nstruct acpi_buffer input;\r\nstruct wmax_brightness_args args = {\r\n.led_mask = 0xFF,\r\n.percentage = brightness,\r\n};\r\ninput.length = (acpi_size) sizeof(args);\r\ninput.pointer = &args;\r\nstatus = wmi_evaluate_method(WMAX_CONTROL_GUID, 1,\r\nWMAX_METHOD_BRIGHTNESS, &input, NULL);\r\nif (ACPI_FAILURE(status))\r\npr_err("alienware-wmi: brightness set failure: %u\n", status);\r\nreturn ACPI_FAILURE(status);\r\n}\r\nstatic void global_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness brightness)\r\n{\r\nint ret;\r\nglobal_brightness = brightness;\r\nif (interface == WMAX)\r\nret = wmax_brightness(brightness);\r\nelse\r\nret = alienware_update_led(&zone_data[0]);\r\nif (ret)\r\npr_err("LED brightness update failed\n");\r\n}\r\nstatic enum led_brightness global_led_get(struct led_classdev *led_cdev)\r\n{\r\nreturn global_brightness;\r\n}\r\nstatic ssize_t show_control_state(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nif (lighting_control_state == LEGACY_BOOTING)\r\nreturn scnprintf(buf, PAGE_SIZE, "[booting] running suspend\n");\r\nelse if (lighting_control_state == LEGACY_SUSPEND)\r\nreturn scnprintf(buf, PAGE_SIZE, "booting running [suspend]\n");\r\nreturn scnprintf(buf, PAGE_SIZE, "booting [running] suspend\n");\r\n}\r\nstatic ssize_t store_control_state(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nlong unsigned int val;\r\nif (strcmp(buf, "booting\n") == 0)\r\nval = LEGACY_BOOTING;\r\nelse if (strcmp(buf, "suspend\n") == 0)\r\nval = LEGACY_SUSPEND;\r\nelse if (interface == LEGACY)\r\nval = LEGACY_RUNNING;\r\nelse\r\nval = WMAX_RUNNING;\r\nlighting_control_state = val;\r\npr_debug("alienware-wmi: updated control state to %d\n",\r\nlighting_control_state);\r\nreturn count;\r\n}\r\nstatic int alienware_zone_init(struct platform_device *dev)\r\n{\r\nint i;\r\nchar buffer[10];\r\nchar *name;\r\nif (interface == WMAX) {\r\nlighting_control_state = WMAX_RUNNING;\r\n} else if (interface == LEGACY) {\r\nlighting_control_state = LEGACY_RUNNING;\r\n}\r\nglobal_led.max_brightness = 0x0F;\r\nglobal_brightness = global_led.max_brightness;\r\nzone_dev_attrs =\r\nkzalloc(sizeof(struct device_attribute) * (quirks->num_zones + 1),\r\nGFP_KERNEL);\r\nif (!zone_dev_attrs)\r\nreturn -ENOMEM;\r\nzone_attrs =\r\nkzalloc(sizeof(struct attribute *) * (quirks->num_zones + 2),\r\nGFP_KERNEL);\r\nif (!zone_attrs)\r\nreturn -ENOMEM;\r\nzone_data =\r\nkzalloc(sizeof(struct platform_zone) * (quirks->num_zones),\r\nGFP_KERNEL);\r\nif (!zone_data)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < quirks->num_zones; i++) {\r\nsprintf(buffer, "zone%02X", i);\r\nname = kstrdup(buffer, GFP_KERNEL);\r\nif (name == NULL)\r\nreturn 1;\r\nsysfs_attr_init(&zone_dev_attrs[i].attr);\r\nzone_dev_attrs[i].attr.name = name;\r\nzone_dev_attrs[i].attr.mode = 0644;\r\nzone_dev_attrs[i].show = zone_show;\r\nzone_dev_attrs[i].store = zone_set;\r\nzone_data[i].location = i;\r\nzone_attrs[i] = &zone_dev_attrs[i].attr;\r\nzone_data[i].attr = &zone_dev_attrs[i];\r\n}\r\nzone_attrs[quirks->num_zones] = &dev_attr_lighting_control_state.attr;\r\nzone_attribute_group.attrs = zone_attrs;\r\nled_classdev_register(&dev->dev, &global_led);\r\nreturn sysfs_create_group(&dev->dev.kobj, &zone_attribute_group);\r\n}\r\nstatic void alienware_zone_exit(struct platform_device *dev)\r\n{\r\nsysfs_remove_group(&dev->dev.kobj, &zone_attribute_group);\r\nled_classdev_unregister(&global_led);\r\nif (zone_dev_attrs) {\r\nint i;\r\nfor (i = 0; i < quirks->num_zones; i++)\r\nkfree(zone_dev_attrs[i].attr.name);\r\n}\r\nkfree(zone_dev_attrs);\r\nkfree(zone_data);\r\nkfree(zone_attrs);\r\n}\r\nstatic acpi_status alienware_hdmi_command(struct hdmi_args *in_args,\r\nu32 command, int *out_data)\r\n{\r\nacpi_status status;\r\nunion acpi_object *obj;\r\nstruct acpi_buffer input;\r\nstruct acpi_buffer output;\r\ninput.length = (acpi_size) sizeof(*in_args);\r\ninput.pointer = in_args;\r\nif (out_data != NULL) {\r\noutput.length = ACPI_ALLOCATE_BUFFER;\r\noutput.pointer = NULL;\r\nstatus = wmi_evaluate_method(WMAX_CONTROL_GUID, 1,\r\ncommand, &input, &output);\r\n} else\r\nstatus = wmi_evaluate_method(WMAX_CONTROL_GUID, 1,\r\ncommand, &input, NULL);\r\nif (ACPI_SUCCESS(status) && out_data != NULL) {\r\nobj = (union acpi_object *)output.pointer;\r\nif (obj && obj->type == ACPI_TYPE_INTEGER)\r\n*out_data = (u32) obj->integer.value;\r\n}\r\nreturn status;\r\n}\r\nstatic ssize_t show_hdmi_cable(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nacpi_status status;\r\nu32 out_data;\r\nstruct hdmi_args in_args = {\r\n.arg = 0,\r\n};\r\nstatus =\r\nalienware_hdmi_command(&in_args, WMAX_METHOD_HDMI_CABLE,\r\n(u32 *) &out_data);\r\nif (ACPI_SUCCESS(status)) {\r\nif (out_data == 0)\r\nreturn scnprintf(buf, PAGE_SIZE,\r\n"[unconnected] connected unknown\n");\r\nelse if (out_data == 1)\r\nreturn scnprintf(buf, PAGE_SIZE,\r\n"unconnected [connected] unknown\n");\r\n}\r\npr_err("alienware-wmi: unknown HDMI cable status: %d\n", status);\r\nreturn scnprintf(buf, PAGE_SIZE, "unconnected connected [unknown]\n");\r\n}\r\nstatic ssize_t show_hdmi_source(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nacpi_status status;\r\nu32 out_data;\r\nstruct hdmi_args in_args = {\r\n.arg = 0,\r\n};\r\nstatus =\r\nalienware_hdmi_command(&in_args, WMAX_METHOD_HDMI_STATUS,\r\n(u32 *) &out_data);\r\nif (ACPI_SUCCESS(status)) {\r\nif (out_data == 1)\r\nreturn scnprintf(buf, PAGE_SIZE,\r\n"[input] gpu unknown\n");\r\nelse if (out_data == 2)\r\nreturn scnprintf(buf, PAGE_SIZE,\r\n"input [gpu] unknown\n");\r\n}\r\npr_err("alienware-wmi: unknown HDMI source status: %d\n", out_data);\r\nreturn scnprintf(buf, PAGE_SIZE, "input gpu [unknown]\n");\r\n}\r\nstatic ssize_t toggle_hdmi_source(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nacpi_status status;\r\nstruct hdmi_args args;\r\nif (strcmp(buf, "gpu\n") == 0)\r\nargs.arg = 1;\r\nelse if (strcmp(buf, "input\n") == 0)\r\nargs.arg = 2;\r\nelse\r\nargs.arg = 3;\r\npr_debug("alienware-wmi: setting hdmi to %d : %s", args.arg, buf);\r\nstatus = alienware_hdmi_command(&args, WMAX_METHOD_HDMI_SOURCE, NULL);\r\nif (ACPI_FAILURE(status))\r\npr_err("alienware-wmi: HDMI toggle failed: results: %u\n",\r\nstatus);\r\nreturn count;\r\n}\r\nstatic void remove_hdmi(struct platform_device *dev)\r\n{\r\nif (quirks->hdmi_mux > 0)\r\nsysfs_remove_group(&dev->dev.kobj, &hdmi_attribute_group);\r\n}\r\nstatic int create_hdmi(struct platform_device *dev)\r\n{\r\nint ret;\r\nret = sysfs_create_group(&dev->dev.kobj, &hdmi_attribute_group);\r\nif (ret)\r\ngoto error_create_hdmi;\r\nreturn 0;\r\nerror_create_hdmi:\r\nremove_hdmi(dev);\r\nreturn ret;\r\n}\r\nstatic int __init alienware_wmi_init(void)\r\n{\r\nint ret;\r\nif (wmi_has_guid(LEGACY_CONTROL_GUID))\r\ninterface = LEGACY;\r\nelse if (wmi_has_guid(WMAX_CONTROL_GUID))\r\ninterface = WMAX;\r\nelse {\r\npr_warn("alienware-wmi: No known WMI GUID found\n");\r\nreturn -ENODEV;\r\n}\r\ndmi_check_system(alienware_quirks);\r\nif (quirks == NULL)\r\nquirks = &quirk_unknown;\r\nret = platform_driver_register(&platform_driver);\r\nif (ret)\r\ngoto fail_platform_driver;\r\nplatform_device = platform_device_alloc("alienware-wmi", -1);\r\nif (!platform_device) {\r\nret = -ENOMEM;\r\ngoto fail_platform_device1;\r\n}\r\nret = platform_device_add(platform_device);\r\nif (ret)\r\ngoto fail_platform_device2;\r\nif (quirks->hdmi_mux > 0) {\r\nret = create_hdmi(platform_device);\r\nif (ret)\r\ngoto fail_prep_hdmi;\r\n}\r\nret = alienware_zone_init(platform_device);\r\nif (ret)\r\ngoto fail_prep_zones;\r\nreturn 0;\r\nfail_prep_zones:\r\nalienware_zone_exit(platform_device);\r\nfail_prep_hdmi:\r\nplatform_device_del(platform_device);\r\nfail_platform_device2:\r\nplatform_device_put(platform_device);\r\nfail_platform_device1:\r\nplatform_driver_unregister(&platform_driver);\r\nfail_platform_driver:\r\nreturn ret;\r\n}\r\nstatic void __exit alienware_wmi_exit(void)\r\n{\r\nif (platform_device) {\r\nalienware_zone_exit(platform_device);\r\nremove_hdmi(platform_device);\r\nplatform_device_unregister(platform_device);\r\nplatform_driver_unregister(&platform_driver);\r\n}\r\n}
