static irqreturn_t dm355evm_keys_irq(int irq, void *_keys)\r\n{\r\nstatic u16 last_event;\r\nstruct dm355evm_keys *keys = _keys;\r\nconst struct key_entry *ke;\r\nunsigned int keycode;\r\nint status;\r\nu16 event;\r\nfor (;;) {\r\nstatus = dm355evm_msp_read(DM355EVM_MSP_INPUT_HIGH);\r\nif (status < 0) {\r\ndev_dbg(keys->dev, "input high err %d\n",\r\nstatus);\r\nbreak;\r\n}\r\nevent = status << 8;\r\nstatus = dm355evm_msp_read(DM355EVM_MSP_INPUT_LOW);\r\nif (status < 0) {\r\ndev_dbg(keys->dev, "input low err %d\n",\r\nstatus);\r\nbreak;\r\n}\r\nevent |= status;\r\nif (event == 0xdead)\r\nbreak;\r\nif (event == last_event) {\r\nlast_event = 0;\r\ncontinue;\r\n}\r\nlast_event = event;\r\nevent &= ~0x0800;\r\nke = sparse_keymap_entry_from_scancode(keys->input, event);\r\nkeycode = ke ? ke->keycode : KEY_UNKNOWN;\r\ndev_dbg(keys->dev,\r\n"input event 0x%04x--> keycode %d\n",\r\nevent, keycode);\r\ninput_report_key(keys->input, keycode, 1);\r\ninput_sync(keys->input);\r\ninput_report_key(keys->input, keycode, 0);\r\ninput_sync(keys->input);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int dm355evm_keys_probe(struct platform_device *pdev)\r\n{\r\nstruct dm355evm_keys *keys;\r\nstruct input_dev *input;\r\nint status;\r\nkeys = kzalloc(sizeof *keys, GFP_KERNEL);\r\ninput = input_allocate_device();\r\nif (!keys || !input) {\r\nstatus = -ENOMEM;\r\ngoto fail1;\r\n}\r\nkeys->dev = &pdev->dev;\r\nkeys->input = input;\r\nstatus = platform_get_irq(pdev, 0);\r\nif (status < 0)\r\ngoto fail1;\r\nkeys->irq = status;\r\ninput_set_drvdata(input, keys);\r\ninput->name = "DM355 EVM Controls";\r\ninput->phys = "dm355evm/input0";\r\ninput->dev.parent = &pdev->dev;\r\ninput->id.bustype = BUS_I2C;\r\ninput->id.product = 0x0355;\r\ninput->id.version = dm355evm_msp_read(DM355EVM_MSP_FIRMREV);\r\nstatus = sparse_keymap_setup(input, dm355evm_keys, NULL);\r\nif (status)\r\ngoto fail1;\r\nstatus = request_threaded_irq(keys->irq, NULL, dm355evm_keys_irq,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\ndev_name(&pdev->dev), keys);\r\nif (status < 0)\r\ngoto fail2;\r\nstatus = input_register_device(input);\r\nif (status < 0)\r\ngoto fail3;\r\nplatform_set_drvdata(pdev, keys);\r\nreturn 0;\r\nfail3:\r\nfree_irq(keys->irq, keys);\r\nfail2:\r\nsparse_keymap_free(input);\r\nfail1:\r\ninput_free_device(input);\r\nkfree(keys);\r\ndev_err(&pdev->dev, "can't register, err %d\n", status);\r\nreturn status;\r\n}\r\nstatic int dm355evm_keys_remove(struct platform_device *pdev)\r\n{\r\nstruct dm355evm_keys *keys = platform_get_drvdata(pdev);\r\nfree_irq(keys->irq, keys);\r\nsparse_keymap_free(keys->input);\r\ninput_unregister_device(keys->input);\r\nkfree(keys);\r\nreturn 0;\r\n}
