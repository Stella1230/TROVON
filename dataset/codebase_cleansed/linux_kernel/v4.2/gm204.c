static void\r\npmu_code(struct nv50_devinit_priv *priv, u32 pmu, u32 img, u32 len, bool sec)\r\n{\r\nstruct nvkm_bios *bios = nvkm_bios(priv);\r\nint i;\r\nnv_wr32(priv, 0x10a180, 0x01000000 | (sec ? 0x10000000 : 0) | pmu);\r\nfor (i = 0; i < len; i += 4) {\r\nif ((i & 0xff) == 0)\r\nnv_wr32(priv, 0x10a188, (pmu + i) >> 8);\r\nnv_wr32(priv, 0x10a184, nv_ro32(bios, img + i));\r\n}\r\nwhile (i & 0xff) {\r\nnv_wr32(priv, 0x10a184, 0x00000000);\r\ni += 4;\r\n}\r\n}\r\nstatic void\r\npmu_data(struct nv50_devinit_priv *priv, u32 pmu, u32 img, u32 len)\r\n{\r\nstruct nvkm_bios *bios = nvkm_bios(priv);\r\nint i;\r\nnv_wr32(priv, 0x10a1c0, 0x01000000 | pmu);\r\nfor (i = 0; i < len; i += 4)\r\nnv_wr32(priv, 0x10a1c4, nv_ro32(bios, img + i));\r\n}\r\nstatic u32\r\npmu_args(struct nv50_devinit_priv *priv, u32 argp, u32 argi)\r\n{\r\nnv_wr32(priv, 0x10a1c0, argp);\r\nnv_wr32(priv, 0x10a1c0, nv_rd32(priv, 0x10a1c4) + argi);\r\nreturn nv_rd32(priv, 0x10a1c4);\r\n}\r\nstatic void\r\npmu_exec(struct nv50_devinit_priv *priv, u32 init_addr)\r\n{\r\nnv_wr32(priv, 0x10a104, init_addr);\r\nnv_wr32(priv, 0x10a10c, 0x00000000);\r\nnv_wr32(priv, 0x10a100, 0x00000002);\r\n}\r\nstatic int\r\npmu_load(struct nv50_devinit_priv *priv, u8 type, bool post,\r\nu32 *init_addr_pmu, u32 *args_addr_pmu)\r\n{\r\nstruct nvkm_bios *bios = nvkm_bios(priv);\r\nstruct nvbios_pmuR pmu;\r\nif (!nvbios_pmuRm(bios, type, &pmu)) {\r\nnv_error(priv, "VBIOS PMU fuc %02x not found\n", type);\r\nreturn -EINVAL;\r\n}\r\nif (!post)\r\nreturn 0;\r\npmu_code(priv, pmu.boot_addr_pmu, pmu.boot_addr, pmu.boot_size, false);\r\npmu_code(priv, pmu.code_addr_pmu, pmu.code_addr, pmu.code_size, true);\r\npmu_data(priv, pmu.data_addr_pmu, pmu.data_addr, pmu.data_size);\r\nif (init_addr_pmu) {\r\n*init_addr_pmu = pmu.init_addr_pmu;\r\n*args_addr_pmu = pmu.args_addr_pmu;\r\nreturn 0;\r\n}\r\nreturn pmu_exec(priv, pmu.init_addr_pmu), 0;\r\n}\r\nstatic int\r\ngm204_devinit_post(struct nvkm_subdev *subdev, bool post)\r\n{\r\nstruct nv50_devinit_priv *priv = (void *)nvkm_devinit(subdev);\r\nstruct nvkm_bios *bios = nvkm_bios(priv);\r\nstruct bit_entry bit_I;\r\nu32 init, args;\r\nint ret;\r\nif (bit_entry(bios, 'I', &bit_I) || bit_I.version != 1 ||\r\nbit_I.length < 0x1c) {\r\nnv_error(priv, "VBIOS PMU init data not found\n");\r\nreturn -EINVAL;\r\n}\r\nif (post) {\r\nnv_mask(priv, 0x000200, 0x00002000, 0x00000000);\r\nnv_mask(priv, 0x000200, 0x00002000, 0x00002000);\r\nnv_rd32(priv, 0x000200);\r\nwhile (nv_rd32(priv, 0x10a10c) & 0x00000006) {\r\n}\r\n}\r\nret = pmu_load(priv, 0x04, post, &init, &args);\r\nif (ret)\r\nreturn ret;\r\nif (post) {\r\nu32 pmu = pmu_args(priv, args + 0x08, 0x08);\r\nu32 img = nv_ro16(bios, bit_I.offset + 0x14);\r\nu32 len = nv_ro16(bios, bit_I.offset + 0x16);\r\npmu_data(priv, pmu, img, len);\r\n}\r\nif (post) {\r\nu32 pmu = pmu_args(priv, args + 0x08, 0x10);\r\nu32 img = nv_ro16(bios, bit_I.offset + 0x18);\r\nu32 len = nv_ro16(bios, bit_I.offset + 0x1a);\r\npmu_data(priv, pmu, img, len);\r\n}\r\nif (post) {\r\nnv_wr32(priv, 0x10a040, 0x00005000);\r\npmu_exec(priv, init);\r\nwhile (!(nv_rd32(priv, 0x10a040) & 0x00002000)) {\r\n}\r\n}\r\nreturn pmu_load(priv, 0x01, post, NULL, NULL);\r\n}
