static void bcm7120_l2_intc_irq_handle(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct bcm7120_l2_intc_data *b = irq_desc_get_handler_data(desc);\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nunsigned int idx;\r\nchained_irq_enter(chip, desc);\r\nfor (idx = 0; idx < b->n_words; idx++) {\r\nint base = idx * IRQS_PER_WORD;\r\nstruct irq_chip_generic *gc =\r\nirq_get_domain_generic_chip(b->domain, base);\r\nunsigned long pending;\r\nint hwirq;\r\nirq_gc_lock(gc);\r\npending = irq_reg_readl(gc, b->stat_offset[idx]) &\r\ngc->mask_cache;\r\nirq_gc_unlock(gc);\r\nfor_each_set_bit(hwirq, &pending, IRQS_PER_WORD) {\r\ngeneric_handle_irq(irq_find_mapping(b->domain,\r\nbase + hwirq));\r\n}\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic void bcm7120_l2_intc_suspend(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct irq_chip_type *ct = irq_data_get_chip_type(d);\r\nstruct bcm7120_l2_intc_data *b = gc->private;\r\nirq_gc_lock(gc);\r\nif (b->can_wake)\r\nirq_reg_writel(gc, gc->mask_cache | gc->wake_active,\r\nct->regs.mask);\r\nirq_gc_unlock(gc);\r\n}\r\nstatic void bcm7120_l2_intc_resume(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct irq_chip_type *ct = irq_data_get_chip_type(d);\r\nirq_gc_lock(gc);\r\nirq_reg_writel(gc, gc->mask_cache, ct->regs.mask);\r\nirq_gc_unlock(gc);\r\n}\r\nstatic int bcm7120_l2_intc_init_one(struct device_node *dn,\r\nstruct bcm7120_l2_intc_data *data,\r\nint irq)\r\n{\r\nint parent_irq;\r\nunsigned int idx;\r\nparent_irq = irq_of_parse_and_map(dn, irq);\r\nif (!parent_irq) {\r\npr_err("failed to map interrupt %d\n", irq);\r\nreturn -EINVAL;\r\n}\r\nfor (idx = 0; idx < data->n_words; idx++) {\r\nif (data->map_mask_prop) {\r\ndata->irq_map_mask[idx] |=\r\nbe32_to_cpup(data->map_mask_prop +\r\nirq * data->n_words + idx);\r\n} else {\r\ndata->irq_map_mask[idx] = 0xffffffff;\r\n}\r\n}\r\nirq_set_handler_data(parent_irq, data);\r\nirq_set_chained_handler(parent_irq, bcm7120_l2_intc_irq_handle);\r\nreturn 0;\r\n}\r\nstatic int __init bcm7120_l2_intc_iomap_7120(struct device_node *dn,\r\nstruct bcm7120_l2_intc_data *data)\r\n{\r\nint ret;\r\ndata->map_base[0] = of_iomap(dn, 0);\r\nif (!data->map_base[0]) {\r\npr_err("unable to map registers\n");\r\nreturn -ENOMEM;\r\n}\r\ndata->pair_base[0] = data->map_base[0];\r\ndata->en_offset[0] = IRQEN;\r\ndata->stat_offset[0] = IRQSTAT;\r\ndata->n_words = 1;\r\nret = of_property_read_u32_array(dn, "brcm,int-fwd-mask",\r\ndata->irq_fwd_mask, data->n_words);\r\nif (ret != 0 && ret != -EINVAL) {\r\npr_err("invalid brcm,int-fwd-mask property\n");\r\nreturn -EINVAL;\r\n}\r\ndata->map_mask_prop = of_get_property(dn, "brcm,int-map-mask", &ret);\r\nif (!data->map_mask_prop ||\r\n(ret != (sizeof(__be32) * data->num_parent_irqs * data->n_words))) {\r\npr_err("invalid brcm,int-map-mask property\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init bcm7120_l2_intc_iomap_3380(struct device_node *dn,\r\nstruct bcm7120_l2_intc_data *data)\r\n{\r\nunsigned int gc_idx;\r\nfor (gc_idx = 0; gc_idx < MAX_WORDS; gc_idx++) {\r\nunsigned int map_idx = gc_idx * 2;\r\nvoid __iomem *en = of_iomap(dn, map_idx + 0);\r\nvoid __iomem *stat = of_iomap(dn, map_idx + 1);\r\nvoid __iomem *base = min(en, stat);\r\ndata->map_base[map_idx + 0] = en;\r\ndata->map_base[map_idx + 1] = stat;\r\nif (!base)\r\nbreak;\r\ndata->pair_base[gc_idx] = base;\r\ndata->en_offset[gc_idx] = en - base;\r\ndata->stat_offset[gc_idx] = stat - base;\r\n}\r\nif (!gc_idx) {\r\npr_err("unable to map registers\n");\r\nreturn -EINVAL;\r\n}\r\ndata->n_words = gc_idx;\r\nreturn 0;\r\n}\r\nint __init bcm7120_l2_intc_probe(struct device_node *dn,\r\nstruct device_node *parent,\r\nint (*iomap_regs_fn)(struct device_node *,\r\nstruct bcm7120_l2_intc_data *),\r\nconst char *intc_name)\r\n{\r\nunsigned int clr = IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN;\r\nstruct bcm7120_l2_intc_data *data;\r\nstruct irq_chip_generic *gc;\r\nstruct irq_chip_type *ct;\r\nint ret = 0;\r\nunsigned int idx, irq, flags;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->num_parent_irqs = of_irq_count(dn);\r\nif (data->num_parent_irqs <= 0) {\r\npr_err("invalid number of parent interrupts\n");\r\nret = -ENOMEM;\r\ngoto out_unmap;\r\n}\r\nret = iomap_regs_fn(dn, data);\r\nif (ret < 0)\r\ngoto out_unmap;\r\nfor (idx = 0; idx < data->n_words; idx++) {\r\n__raw_writel(data->irq_fwd_mask[idx],\r\ndata->pair_base[idx] +\r\ndata->en_offset[idx]);\r\n}\r\nfor (irq = 0; irq < data->num_parent_irqs; irq++) {\r\nret = bcm7120_l2_intc_init_one(dn, data, irq);\r\nif (ret)\r\ngoto out_unmap;\r\n}\r\ndata->domain = irq_domain_add_linear(dn, IRQS_PER_WORD * data->n_words,\r\n&irq_generic_chip_ops, NULL);\r\nif (!data->domain) {\r\nret = -ENOMEM;\r\ngoto out_unmap;\r\n}\r\nflags = IRQ_GC_INIT_MASK_CACHE;\r\nif (IS_ENABLED(CONFIG_MIPS) && IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))\r\nflags |= IRQ_GC_BE_IO;\r\nret = irq_alloc_domain_generic_chips(data->domain, IRQS_PER_WORD, 1,\r\ndn->full_name, handle_level_irq, clr, 0, flags);\r\nif (ret) {\r\npr_err("failed to allocate generic irq chip\n");\r\ngoto out_free_domain;\r\n}\r\nif (of_property_read_bool(dn, "brcm,irq-can-wake"))\r\ndata->can_wake = true;\r\nfor (idx = 0; idx < data->n_words; idx++) {\r\nirq = idx * IRQS_PER_WORD;\r\ngc = irq_get_domain_generic_chip(data->domain, irq);\r\ngc->unused = 0xffffffff & ~data->irq_map_mask[idx];\r\ngc->private = data;\r\nct = gc->chip_types;\r\ngc->reg_base = data->pair_base[idx];\r\nct->regs.mask = data->en_offset[idx];\r\nct->chip.irq_mask = irq_gc_mask_clr_bit;\r\nct->chip.irq_unmask = irq_gc_mask_set_bit;\r\nct->chip.irq_ack = irq_gc_noop;\r\nct->chip.irq_suspend = bcm7120_l2_intc_suspend;\r\nct->chip.irq_resume = bcm7120_l2_intc_resume;\r\nif (data->can_wake) {\r\ngc->wake_enabled = 0xffffffff;\r\ngc->wake_enabled &= ~gc->unused;\r\nct->chip.irq_set_wake = irq_gc_set_wake;\r\n}\r\n}\r\npr_info("registered %s intc (mem: 0x%p, parent IRQ(s): %d)\n",\r\nintc_name, data->map_base[0], data->num_parent_irqs);\r\nreturn 0;\r\nout_free_domain:\r\nirq_domain_remove(data->domain);\r\nout_unmap:\r\nfor (idx = 0; idx < MAX_MAPPINGS; idx++) {\r\nif (data->map_base[idx])\r\niounmap(data->map_base[idx]);\r\n}\r\nkfree(data);\r\nreturn ret;\r\n}\r\nint __init bcm7120_l2_intc_probe_7120(struct device_node *dn,\r\nstruct device_node *parent)\r\n{\r\nreturn bcm7120_l2_intc_probe(dn, parent, bcm7120_l2_intc_iomap_7120,\r\n"BCM7120 L2");\r\n}\r\nint __init bcm7120_l2_intc_probe_3380(struct device_node *dn,\r\nstruct device_node *parent)\r\n{\r\nreturn bcm7120_l2_intc_probe(dn, parent, bcm7120_l2_intc_iomap_3380,\r\n"BCM3380 L2");\r\n}
