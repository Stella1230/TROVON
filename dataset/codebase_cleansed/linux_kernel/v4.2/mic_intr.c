static irqreturn_t mic_thread_fn(int irq, void *dev)\r\n{\r\nstruct mic_device *mdev = dev;\r\nstruct mic_intr_info *intr_info = mdev->intr_info;\r\nstruct mic_irq_info *irq_info = &mdev->irq_info;\r\nstruct mic_intr_cb *intr_cb;\r\nstruct pci_dev *pdev = container_of(mdev->sdev->parent,\r\nstruct pci_dev, dev);\r\nint i;\r\nspin_lock(&irq_info->mic_thread_lock);\r\nfor (i = intr_info->intr_start_idx[MIC_INTR_DB];\r\ni < intr_info->intr_len[MIC_INTR_DB]; i++)\r\nif (test_and_clear_bit(i, &irq_info->mask)) {\r\nlist_for_each_entry(intr_cb, &irq_info->cb_list[i],\r\nlist)\r\nif (intr_cb->thread_fn)\r\nintr_cb->thread_fn(pdev->irq,\r\nintr_cb->data);\r\n}\r\nspin_unlock(&irq_info->mic_thread_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t mic_interrupt(int irq, void *dev)\r\n{\r\nstruct mic_device *mdev = dev;\r\nstruct mic_intr_info *intr_info = mdev->intr_info;\r\nstruct mic_irq_info *irq_info = &mdev->irq_info;\r\nstruct mic_intr_cb *intr_cb;\r\nstruct pci_dev *pdev = container_of(mdev->sdev->parent,\r\nstruct pci_dev, dev);\r\nu32 mask;\r\nint i;\r\nmask = mdev->ops->ack_interrupt(mdev);\r\nif (!mask)\r\nreturn IRQ_NONE;\r\nspin_lock(&irq_info->mic_intr_lock);\r\nfor (i = intr_info->intr_start_idx[MIC_INTR_DB];\r\ni < intr_info->intr_len[MIC_INTR_DB]; i++)\r\nif (mask & BIT(i)) {\r\nlist_for_each_entry(intr_cb, &irq_info->cb_list[i],\r\nlist)\r\nif (intr_cb->handler)\r\nintr_cb->handler(pdev->irq,\r\nintr_cb->data);\r\nset_bit(i, &irq_info->mask);\r\n}\r\nspin_unlock(&irq_info->mic_intr_lock);\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic u16 mic_map_src_to_offset(struct mic_device *mdev,\r\nint intr_src, enum mic_intr_type type)\r\n{\r\nif (type >= MIC_NUM_INTR_TYPES)\r\nreturn MIC_NUM_OFFSETS;\r\nif (intr_src >= mdev->intr_info->intr_len[type])\r\nreturn MIC_NUM_OFFSETS;\r\nreturn mdev->intr_info->intr_start_idx[type] + intr_src;\r\n}\r\nstatic struct msix_entry *mic_get_available_vector(struct mic_device *mdev)\r\n{\r\nint i;\r\nstruct mic_irq_info *info = &mdev->irq_info;\r\nfor (i = 0; i < info->num_vectors; i++)\r\nif (!info->mic_msi_map[i])\r\nreturn &info->msix_entries[i];\r\nreturn NULL;\r\n}\r\nstatic struct mic_intr_cb *mic_register_intr_callback(struct mic_device *mdev,\r\nu8 idx, irq_handler_t handler, irq_handler_t thread_fn,\r\nvoid *data)\r\n{\r\nstruct mic_intr_cb *intr_cb;\r\nunsigned long flags;\r\nint rc;\r\nintr_cb = kmalloc(sizeof(*intr_cb), GFP_KERNEL);\r\nif (!intr_cb)\r\nreturn ERR_PTR(-ENOMEM);\r\nintr_cb->handler = handler;\r\nintr_cb->thread_fn = thread_fn;\r\nintr_cb->data = data;\r\nintr_cb->cb_id = ida_simple_get(&mdev->irq_info.cb_ida,\r\n0, 0, GFP_KERNEL);\r\nif (intr_cb->cb_id < 0) {\r\nrc = intr_cb->cb_id;\r\ngoto ida_fail;\r\n}\r\nspin_lock(&mdev->irq_info.mic_thread_lock);\r\nspin_lock_irqsave(&mdev->irq_info.mic_intr_lock, flags);\r\nlist_add_tail(&intr_cb->list, &mdev->irq_info.cb_list[idx]);\r\nspin_unlock_irqrestore(&mdev->irq_info.mic_intr_lock, flags);\r\nspin_unlock(&mdev->irq_info.mic_thread_lock);\r\nreturn intr_cb;\r\nida_fail:\r\nkfree(intr_cb);\r\nreturn ERR_PTR(rc);\r\n}\r\nstatic u8 mic_unregister_intr_callback(struct mic_device *mdev, u32 idx)\r\n{\r\nstruct list_head *pos, *tmp;\r\nstruct mic_intr_cb *intr_cb;\r\nunsigned long flags;\r\nint i;\r\nspin_lock(&mdev->irq_info.mic_thread_lock);\r\nspin_lock_irqsave(&mdev->irq_info.mic_intr_lock, flags);\r\nfor (i = 0; i < MIC_NUM_OFFSETS; i++) {\r\nlist_for_each_safe(pos, tmp, &mdev->irq_info.cb_list[i]) {\r\nintr_cb = list_entry(pos, struct mic_intr_cb, list);\r\nif (intr_cb->cb_id == idx) {\r\nlist_del(pos);\r\nida_simple_remove(&mdev->irq_info.cb_ida,\r\nintr_cb->cb_id);\r\nkfree(intr_cb);\r\nspin_unlock_irqrestore(\r\n&mdev->irq_info.mic_intr_lock, flags);\r\nspin_unlock(&mdev->irq_info.mic_thread_lock);\r\nreturn i;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&mdev->irq_info.mic_intr_lock, flags);\r\nspin_unlock(&mdev->irq_info.mic_thread_lock);\r\nreturn MIC_NUM_OFFSETS;\r\n}\r\nstatic int mic_setup_msix(struct mic_device *mdev, struct pci_dev *pdev)\r\n{\r\nint rc, i;\r\nint entry_size = sizeof(*mdev->irq_info.msix_entries);\r\nmdev->irq_info.msix_entries = kmalloc_array(MIC_MIN_MSIX,\r\nentry_size, GFP_KERNEL);\r\nif (!mdev->irq_info.msix_entries) {\r\nrc = -ENOMEM;\r\ngoto err_nomem1;\r\n}\r\nfor (i = 0; i < MIC_MIN_MSIX; i++)\r\nmdev->irq_info.msix_entries[i].entry = i;\r\nrc = pci_enable_msix_exact(pdev, mdev->irq_info.msix_entries,\r\nMIC_MIN_MSIX);\r\nif (rc) {\r\ndev_dbg(&pdev->dev, "Error enabling MSIx. rc = %d\n", rc);\r\ngoto err_enable_msix;\r\n}\r\nmdev->irq_info.num_vectors = MIC_MIN_MSIX;\r\nmdev->irq_info.mic_msi_map = kzalloc((sizeof(u32) *\r\nmdev->irq_info.num_vectors), GFP_KERNEL);\r\nif (!mdev->irq_info.mic_msi_map) {\r\nrc = -ENOMEM;\r\ngoto err_nomem2;\r\n}\r\ndev_dbg(mdev->sdev->parent,\r\n"%d MSIx irqs setup\n", mdev->irq_info.num_vectors);\r\nreturn 0;\r\nerr_nomem2:\r\npci_disable_msix(pdev);\r\nerr_enable_msix:\r\nkfree(mdev->irq_info.msix_entries);\r\nerr_nomem1:\r\nmdev->irq_info.num_vectors = 0;\r\nreturn rc;\r\n}\r\nstatic int mic_setup_callbacks(struct mic_device *mdev)\r\n{\r\nint i;\r\nmdev->irq_info.cb_list = kmalloc_array(MIC_NUM_OFFSETS,\r\nsizeof(*mdev->irq_info.cb_list),\r\nGFP_KERNEL);\r\nif (!mdev->irq_info.cb_list)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < MIC_NUM_OFFSETS; i++)\r\nINIT_LIST_HEAD(&mdev->irq_info.cb_list[i]);\r\nida_init(&mdev->irq_info.cb_ida);\r\nspin_lock_init(&mdev->irq_info.mic_intr_lock);\r\nspin_lock_init(&mdev->irq_info.mic_thread_lock);\r\nreturn 0;\r\n}\r\nstatic void mic_release_callbacks(struct mic_device *mdev)\r\n{\r\nunsigned long flags;\r\nstruct list_head *pos, *tmp;\r\nstruct mic_intr_cb *intr_cb;\r\nint i;\r\nspin_lock(&mdev->irq_info.mic_thread_lock);\r\nspin_lock_irqsave(&mdev->irq_info.mic_intr_lock, flags);\r\nfor (i = 0; i < MIC_NUM_OFFSETS; i++) {\r\nif (list_empty(&mdev->irq_info.cb_list[i]))\r\nbreak;\r\nlist_for_each_safe(pos, tmp, &mdev->irq_info.cb_list[i]) {\r\nintr_cb = list_entry(pos, struct mic_intr_cb, list);\r\nlist_del(pos);\r\nida_simple_remove(&mdev->irq_info.cb_ida,\r\nintr_cb->cb_id);\r\nkfree(intr_cb);\r\n}\r\n}\r\nspin_unlock_irqrestore(&mdev->irq_info.mic_intr_lock, flags);\r\nspin_unlock(&mdev->irq_info.mic_thread_lock);\r\nida_destroy(&mdev->irq_info.cb_ida);\r\nkfree(mdev->irq_info.cb_list);\r\n}\r\nstatic int mic_setup_msi(struct mic_device *mdev, struct pci_dev *pdev)\r\n{\r\nint rc;\r\nrc = pci_enable_msi(pdev);\r\nif (rc) {\r\ndev_dbg(&pdev->dev, "Error enabling MSI. rc = %d\n", rc);\r\nreturn rc;\r\n}\r\nmdev->irq_info.num_vectors = 1;\r\nmdev->irq_info.mic_msi_map = kzalloc((sizeof(u32) *\r\nmdev->irq_info.num_vectors), GFP_KERNEL);\r\nif (!mdev->irq_info.mic_msi_map) {\r\nrc = -ENOMEM;\r\ngoto err_nomem1;\r\n}\r\nrc = mic_setup_callbacks(mdev);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Error setting up callbacks\n");\r\ngoto err_nomem2;\r\n}\r\nrc = request_threaded_irq(pdev->irq, mic_interrupt, mic_thread_fn,\r\n0, "mic-msi", mdev);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Error allocating MSI interrupt\n");\r\ngoto err_irq_req_fail;\r\n}\r\ndev_dbg(&pdev->dev, "%d MSI irqs setup\n", mdev->irq_info.num_vectors);\r\nreturn 0;\r\nerr_irq_req_fail:\r\nmic_release_callbacks(mdev);\r\nerr_nomem2:\r\nkfree(mdev->irq_info.mic_msi_map);\r\nerr_nomem1:\r\npci_disable_msi(pdev);\r\nmdev->irq_info.num_vectors = 0;\r\nreturn rc;\r\n}\r\nstatic int mic_setup_intx(struct mic_device *mdev, struct pci_dev *pdev)\r\n{\r\nint rc;\r\npci_intx(pdev, 1);\r\nrc = mic_setup_callbacks(mdev);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Error setting up callbacks\n");\r\ngoto err_nomem;\r\n}\r\nrc = request_threaded_irq(pdev->irq, mic_interrupt, mic_thread_fn,\r\nIRQF_SHARED, "mic-intx", mdev);\r\nif (rc)\r\ngoto err;\r\ndev_dbg(&pdev->dev, "intx irq setup\n");\r\nreturn 0;\r\nerr:\r\nmic_release_callbacks(mdev);\r\nerr_nomem:\r\nreturn rc;\r\n}\r\nint mic_next_db(struct mic_device *mdev)\r\n{\r\nint next_db;\r\nnext_db = mdev->irq_info.next_avail_src %\r\nmdev->intr_info->intr_len[MIC_INTR_DB];\r\nmdev->irq_info.next_avail_src++;\r\nreturn next_db;\r\n}\r\nstruct mic_irq *\r\nmic_request_threaded_irq(struct mic_device *mdev,\r\nirq_handler_t handler, irq_handler_t thread_fn,\r\nconst char *name, void *data, int intr_src,\r\nenum mic_intr_type type)\r\n{\r\nu16 offset;\r\nint rc = 0;\r\nstruct msix_entry *msix = NULL;\r\nunsigned long cookie = 0;\r\nu16 entry;\r\nstruct mic_intr_cb *intr_cb;\r\nstruct pci_dev *pdev = container_of(mdev->sdev->parent,\r\nstruct pci_dev, dev);\r\noffset = mic_map_src_to_offset(mdev, intr_src, type);\r\nif (offset >= MIC_NUM_OFFSETS) {\r\ndev_err(mdev->sdev->parent,\r\n"Error mapping index %d to a valid source id.\n",\r\nintr_src);\r\nrc = -EINVAL;\r\ngoto err;\r\n}\r\nif (mdev->irq_info.num_vectors > 1) {\r\nmsix = mic_get_available_vector(mdev);\r\nif (!msix) {\r\ndev_err(mdev->sdev->parent,\r\n"No MSIx vectors available for use.\n");\r\nrc = -ENOSPC;\r\ngoto err;\r\n}\r\nrc = request_threaded_irq(msix->vector, handler, thread_fn,\r\n0, name, data);\r\nif (rc) {\r\ndev_dbg(mdev->sdev->parent,\r\n"request irq failed rc = %d\n", rc);\r\ngoto err;\r\n}\r\nentry = msix->entry;\r\nmdev->irq_info.mic_msi_map[entry] |= BIT(offset);\r\nmdev->intr_ops->program_msi_to_src_map(mdev,\r\nentry, offset, true);\r\ncookie = MK_COOKIE(entry, offset);\r\ndev_dbg(mdev->sdev->parent, "irq: %d assigned for src: %d\n",\r\nmsix->vector, intr_src);\r\n} else {\r\nintr_cb = mic_register_intr_callback(mdev, offset, handler,\r\nthread_fn, data);\r\nif (IS_ERR(intr_cb)) {\r\ndev_err(mdev->sdev->parent,\r\n"No available callback entries for use\n");\r\nrc = PTR_ERR(intr_cb);\r\ngoto err;\r\n}\r\nentry = 0;\r\nif (pci_dev_msi_enabled(pdev)) {\r\nmdev->irq_info.mic_msi_map[entry] |= (1 << offset);\r\nmdev->intr_ops->program_msi_to_src_map(mdev,\r\nentry, offset, true);\r\n}\r\ncookie = MK_COOKIE(entry, intr_cb->cb_id);\r\ndev_dbg(mdev->sdev->parent, "callback %d registered for src: %d\n",\r\nintr_cb->cb_id, intr_src);\r\n}\r\nreturn (struct mic_irq *)cookie;\r\nerr:\r\nreturn ERR_PTR(rc);\r\n}\r\nvoid mic_free_irq(struct mic_device *mdev,\r\nstruct mic_irq *cookie, void *data)\r\n{\r\nu32 offset;\r\nu32 entry;\r\nu8 src_id;\r\nunsigned int irq;\r\nstruct pci_dev *pdev = container_of(mdev->sdev->parent,\r\nstruct pci_dev, dev);\r\nentry = GET_ENTRY((unsigned long)cookie);\r\noffset = GET_OFFSET((unsigned long)cookie);\r\nif (mdev->irq_info.num_vectors > 1) {\r\nif (entry >= mdev->irq_info.num_vectors) {\r\ndev_warn(mdev->sdev->parent,\r\n"entry %d should be < num_irq %d\n",\r\nentry, mdev->irq_info.num_vectors);\r\nreturn;\r\n}\r\nirq = mdev->irq_info.msix_entries[entry].vector;\r\nfree_irq(irq, data);\r\nmdev->irq_info.mic_msi_map[entry] &= ~(BIT(offset));\r\nmdev->intr_ops->program_msi_to_src_map(mdev,\r\nentry, offset, false);\r\ndev_dbg(mdev->sdev->parent, "irq: %d freed\n", irq);\r\n} else {\r\nirq = pdev->irq;\r\nsrc_id = mic_unregister_intr_callback(mdev, offset);\r\nif (src_id >= MIC_NUM_OFFSETS) {\r\ndev_warn(mdev->sdev->parent, "Error unregistering callback\n");\r\nreturn;\r\n}\r\nif (pci_dev_msi_enabled(pdev)) {\r\nmdev->irq_info.mic_msi_map[entry] &= ~(BIT(src_id));\r\nmdev->intr_ops->program_msi_to_src_map(mdev,\r\nentry, src_id, false);\r\n}\r\ndev_dbg(mdev->sdev->parent, "callback %d unregistered for src: %d\n",\r\noffset, src_id);\r\n}\r\n}\r\nint mic_setup_interrupts(struct mic_device *mdev, struct pci_dev *pdev)\r\n{\r\nint rc;\r\nrc = mic_setup_msix(mdev, pdev);\r\nif (!rc)\r\ngoto done;\r\nrc = mic_setup_msi(mdev, pdev);\r\nif (!rc)\r\ngoto done;\r\nrc = mic_setup_intx(mdev, pdev);\r\nif (rc) {\r\ndev_err(mdev->sdev->parent, "no usable interrupts\n");\r\nreturn rc;\r\n}\r\ndone:\r\nmdev->intr_ops->enable_interrupts(mdev);\r\nreturn 0;\r\n}\r\nvoid mic_free_interrupts(struct mic_device *mdev, struct pci_dev *pdev)\r\n{\r\nint i;\r\nmdev->intr_ops->disable_interrupts(mdev);\r\nif (mdev->irq_info.num_vectors > 1) {\r\nfor (i = 0; i < mdev->irq_info.num_vectors; i++) {\r\nif (mdev->irq_info.mic_msi_map[i])\r\ndev_warn(&pdev->dev, "irq %d may still be in use.\n",\r\nmdev->irq_info.msix_entries[i].vector);\r\n}\r\nkfree(mdev->irq_info.mic_msi_map);\r\nkfree(mdev->irq_info.msix_entries);\r\npci_disable_msix(pdev);\r\n} else {\r\nif (pci_dev_msi_enabled(pdev)) {\r\nfree_irq(pdev->irq, mdev);\r\nkfree(mdev->irq_info.mic_msi_map);\r\npci_disable_msi(pdev);\r\n} else {\r\nfree_irq(pdev->irq, mdev);\r\n}\r\nmic_release_callbacks(mdev);\r\n}\r\n}\r\nvoid mic_intr_restore(struct mic_device *mdev)\r\n{\r\nint entry, offset;\r\nstruct pci_dev *pdev = container_of(mdev->sdev->parent,\r\nstruct pci_dev, dev);\r\nif (!pci_dev_msi_enabled(pdev))\r\nreturn;\r\nfor (entry = 0; entry < mdev->irq_info.num_vectors; entry++) {\r\nfor (offset = 0; offset < MIC_NUM_OFFSETS; offset++) {\r\nif (mdev->irq_info.mic_msi_map[entry] & BIT(offset))\r\nmdev->intr_ops->program_msi_to_src_map(mdev,\r\nentry, offset, true);\r\n}\r\n}\r\n}
