static unsigned int _get_maxdiv(struct mmp_clk_mix *mix)\r\n{\r\nunsigned int div_mask = (1 << mix->reg_info.width_div) - 1;\r\nunsigned int maxdiv = 0;\r\nstruct clk_div_table *clkt;\r\nif (mix->div_flags & CLK_DIVIDER_ONE_BASED)\r\nreturn div_mask;\r\nif (mix->div_flags & CLK_DIVIDER_POWER_OF_TWO)\r\nreturn 1 << div_mask;\r\nif (mix->div_table) {\r\nfor (clkt = mix->div_table; clkt->div; clkt++)\r\nif (clkt->div > maxdiv)\r\nmaxdiv = clkt->div;\r\nreturn maxdiv;\r\n}\r\nreturn div_mask + 1;\r\n}\r\nstatic unsigned int _get_div(struct mmp_clk_mix *mix, unsigned int val)\r\n{\r\nstruct clk_div_table *clkt;\r\nif (mix->div_flags & CLK_DIVIDER_ONE_BASED)\r\nreturn val;\r\nif (mix->div_flags & CLK_DIVIDER_POWER_OF_TWO)\r\nreturn 1 << val;\r\nif (mix->div_table) {\r\nfor (clkt = mix->div_table; clkt->div; clkt++)\r\nif (clkt->val == val)\r\nreturn clkt->div;\r\nif (clkt->div == 0)\r\nreturn 0;\r\n}\r\nreturn val + 1;\r\n}\r\nstatic unsigned int _get_mux(struct mmp_clk_mix *mix, unsigned int val)\r\n{\r\nint num_parents = __clk_get_num_parents(mix->hw.clk);\r\nint i;\r\nif (mix->mux_flags & CLK_MUX_INDEX_BIT)\r\nreturn ffs(val) - 1;\r\nif (mix->mux_flags & CLK_MUX_INDEX_ONE)\r\nreturn val - 1;\r\nif (mix->mux_table) {\r\nfor (i = 0; i < num_parents; i++)\r\nif (mix->mux_table[i] == val)\r\nreturn i;\r\nif (i == num_parents)\r\nreturn 0;\r\n}\r\nreturn val;\r\n}\r\nstatic unsigned int _get_div_val(struct mmp_clk_mix *mix, unsigned int div)\r\n{\r\nstruct clk_div_table *clkt;\r\nif (mix->div_flags & CLK_DIVIDER_ONE_BASED)\r\nreturn div;\r\nif (mix->div_flags & CLK_DIVIDER_POWER_OF_TWO)\r\nreturn __ffs(div);\r\nif (mix->div_table) {\r\nfor (clkt = mix->div_table; clkt->div; clkt++)\r\nif (clkt->div == div)\r\nreturn clkt->val;\r\nif (clkt->div == 0)\r\nreturn 0;\r\n}\r\nreturn div - 1;\r\n}\r\nstatic unsigned int _get_mux_val(struct mmp_clk_mix *mix, unsigned int mux)\r\n{\r\nif (mix->mux_table)\r\nreturn mix->mux_table[mux];\r\nreturn mux;\r\n}\r\nstatic void _filter_clk_table(struct mmp_clk_mix *mix,\r\nstruct mmp_clk_mix_clk_table *table,\r\nunsigned int table_size)\r\n{\r\nint i;\r\nstruct mmp_clk_mix_clk_table *item;\r\nstruct clk *parent, *clk;\r\nunsigned long parent_rate;\r\nclk = mix->hw.clk;\r\nfor (i = 0; i < table_size; i++) {\r\nitem = &table[i];\r\nparent = clk_get_parent_by_index(clk, item->parent_index);\r\nparent_rate = __clk_get_rate(parent);\r\nif (parent_rate % item->rate) {\r\nitem->valid = 0;\r\n} else {\r\nitem->divisor = parent_rate / item->rate;\r\nitem->valid = 1;\r\n}\r\n}\r\n}\r\nstatic int _set_rate(struct mmp_clk_mix *mix, u32 mux_val, u32 div_val,\r\nunsigned int change_mux, unsigned int change_div)\r\n{\r\nstruct mmp_clk_mix_reg_info *ri = &mix->reg_info;\r\nu8 width, shift;\r\nu32 mux_div, fc_req;\r\nint ret, timeout = 50;\r\nunsigned long flags = 0;\r\nif (!change_mux && !change_div)\r\nreturn -EINVAL;\r\nif (mix->lock)\r\nspin_lock_irqsave(mix->lock, flags);\r\nif (mix->type == MMP_CLK_MIX_TYPE_V1\r\n|| mix->type == MMP_CLK_MIX_TYPE_V2)\r\nmux_div = readl(ri->reg_clk_ctrl);\r\nelse\r\nmux_div = readl(ri->reg_clk_sel);\r\nif (change_div) {\r\nwidth = ri->width_div;\r\nshift = ri->shift_div;\r\nmux_div &= ~MMP_CLK_BITS_MASK(width, shift);\r\nmux_div |= MMP_CLK_BITS_SET_VAL(div_val, width, shift);\r\n}\r\nif (change_mux) {\r\nwidth = ri->width_mux;\r\nshift = ri->shift_mux;\r\nmux_div &= ~MMP_CLK_BITS_MASK(width, shift);\r\nmux_div |= MMP_CLK_BITS_SET_VAL(mux_val, width, shift);\r\n}\r\nif (mix->type == MMP_CLK_MIX_TYPE_V1) {\r\nwritel(mux_div, ri->reg_clk_ctrl);\r\n} else if (mix->type == MMP_CLK_MIX_TYPE_V2) {\r\nmux_div |= (1 << ri->bit_fc);\r\nwritel(mux_div, ri->reg_clk_ctrl);\r\ndo {\r\nfc_req = readl(ri->reg_clk_ctrl);\r\ntimeout--;\r\nif (!(fc_req & (1 << ri->bit_fc)))\r\nbreak;\r\n} while (timeout);\r\nif (timeout == 0) {\r\npr_err("%s:%s cannot do frequency change\n",\r\n__func__, __clk_get_name(mix->hw.clk));\r\nret = -EBUSY;\r\ngoto error;\r\n}\r\n} else {\r\nfc_req = readl(ri->reg_clk_ctrl);\r\nfc_req |= 1 << ri->bit_fc;\r\nwritel(fc_req, ri->reg_clk_ctrl);\r\nwritel(mux_div, ri->reg_clk_sel);\r\nfc_req &= ~(1 << ri->bit_fc);\r\n}\r\nret = 0;\r\nerror:\r\nif (mix->lock)\r\nspin_unlock_irqrestore(mix->lock, flags);\r\nreturn ret;\r\n}\r\nstatic long mmp_clk_mix_determine_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long min_rate,\r\nunsigned long max_rate,\r\nunsigned long *best_parent_rate,\r\nstruct clk_hw **best_parent_clk)\r\n{\r\nstruct mmp_clk_mix *mix = to_clk_mix(hw);\r\nstruct mmp_clk_mix_clk_table *item;\r\nstruct clk *parent, *parent_best, *mix_clk;\r\nunsigned long parent_rate, mix_rate, mix_rate_best, parent_rate_best;\r\nunsigned long gap, gap_best;\r\nu32 div_val_max;\r\nunsigned int div;\r\nint i, j;\r\nmix_clk = hw->clk;\r\nparent = NULL;\r\nmix_rate_best = 0;\r\nparent_rate_best = 0;\r\ngap_best = rate;\r\nparent_best = NULL;\r\nif (mix->table) {\r\nfor (i = 0; i < mix->table_size; i++) {\r\nitem = &mix->table[i];\r\nif (item->valid == 0)\r\ncontinue;\r\nparent = clk_get_parent_by_index(mix_clk,\r\nitem->parent_index);\r\nparent_rate = __clk_get_rate(parent);\r\nmix_rate = parent_rate / item->divisor;\r\ngap = abs(mix_rate - rate);\r\nif (parent_best == NULL || gap < gap_best) {\r\nparent_best = parent;\r\nparent_rate_best = parent_rate;\r\nmix_rate_best = mix_rate;\r\ngap_best = gap;\r\nif (gap_best == 0)\r\ngoto found;\r\n}\r\n}\r\n} else {\r\nfor (i = 0; i < __clk_get_num_parents(mix_clk); i++) {\r\nparent = clk_get_parent_by_index(mix_clk, i);\r\nparent_rate = __clk_get_rate(parent);\r\ndiv_val_max = _get_maxdiv(mix);\r\nfor (j = 0; j < div_val_max; j++) {\r\ndiv = _get_div(mix, j);\r\nmix_rate = parent_rate / div;\r\ngap = abs(mix_rate - rate);\r\nif (parent_best == NULL || gap < gap_best) {\r\nparent_best = parent;\r\nparent_rate_best = parent_rate;\r\nmix_rate_best = mix_rate;\r\ngap_best = gap;\r\nif (gap_best == 0)\r\ngoto found;\r\n}\r\n}\r\n}\r\n}\r\nfound:\r\n*best_parent_rate = parent_rate_best;\r\n*best_parent_clk = __clk_get_hw(parent_best);\r\nreturn mix_rate_best;\r\n}\r\nstatic int mmp_clk_mix_set_rate_and_parent(struct clk_hw *hw,\r\nunsigned long rate,\r\nunsigned long parent_rate,\r\nu8 index)\r\n{\r\nstruct mmp_clk_mix *mix = to_clk_mix(hw);\r\nunsigned int div;\r\nu32 div_val, mux_val;\r\ndiv = parent_rate / rate;\r\ndiv_val = _get_div_val(mix, div);\r\nmux_val = _get_mux_val(mix, index);\r\nreturn _set_rate(mix, mux_val, div_val, 1, 1);\r\n}\r\nstatic u8 mmp_clk_mix_get_parent(struct clk_hw *hw)\r\n{\r\nstruct mmp_clk_mix *mix = to_clk_mix(hw);\r\nstruct mmp_clk_mix_reg_info *ri = &mix->reg_info;\r\nunsigned long flags = 0;\r\nu32 mux_div = 0;\r\nu8 width, shift;\r\nu32 mux_val;\r\nif (mix->lock)\r\nspin_lock_irqsave(mix->lock, flags);\r\nif (mix->type == MMP_CLK_MIX_TYPE_V1\r\n|| mix->type == MMP_CLK_MIX_TYPE_V2)\r\nmux_div = readl(ri->reg_clk_ctrl);\r\nelse\r\nmux_div = readl(ri->reg_clk_sel);\r\nif (mix->lock)\r\nspin_unlock_irqrestore(mix->lock, flags);\r\nwidth = mix->reg_info.width_mux;\r\nshift = mix->reg_info.shift_mux;\r\nmux_val = MMP_CLK_BITS_GET_VAL(mux_div, width, shift);\r\nreturn _get_mux(mix, mux_val);\r\n}\r\nstatic unsigned long mmp_clk_mix_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct mmp_clk_mix *mix = to_clk_mix(hw);\r\nstruct mmp_clk_mix_reg_info *ri = &mix->reg_info;\r\nunsigned long flags = 0;\r\nu32 mux_div = 0;\r\nu8 width, shift;\r\nunsigned int div;\r\nif (mix->lock)\r\nspin_lock_irqsave(mix->lock, flags);\r\nif (mix->type == MMP_CLK_MIX_TYPE_V1\r\n|| mix->type == MMP_CLK_MIX_TYPE_V2)\r\nmux_div = readl(ri->reg_clk_ctrl);\r\nelse\r\nmux_div = readl(ri->reg_clk_sel);\r\nif (mix->lock)\r\nspin_unlock_irqrestore(mix->lock, flags);\r\nwidth = mix->reg_info.width_div;\r\nshift = mix->reg_info.shift_div;\r\ndiv = _get_div(mix, MMP_CLK_BITS_GET_VAL(mux_div, width, shift));\r\nreturn parent_rate / div;\r\n}\r\nstatic int mmp_clk_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct mmp_clk_mix *mix = to_clk_mix(hw);\r\nstruct mmp_clk_mix_clk_table *item;\r\nint i;\r\nu32 div_val, mux_val;\r\nif (mix->table) {\r\nfor (i = 0; i < mix->table_size; i++) {\r\nitem = &mix->table[i];\r\nif (item->valid == 0)\r\ncontinue;\r\nif (item->parent_index == index)\r\nbreak;\r\n}\r\nif (i < mix->table_size) {\r\ndiv_val = _get_div_val(mix, item->divisor);\r\nmux_val = _get_mux_val(mix, item->parent_index);\r\n} else\r\nreturn -EINVAL;\r\n} else {\r\nmux_val = _get_mux_val(mix, index);\r\ndiv_val = 0;\r\n}\r\nreturn _set_rate(mix, mux_val, div_val, 1, div_val ? 1 : 0);\r\n}\r\nstatic int mmp_clk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long best_parent_rate)\r\n{\r\nstruct mmp_clk_mix *mix = to_clk_mix(hw);\r\nstruct mmp_clk_mix_clk_table *item;\r\nunsigned long parent_rate;\r\nunsigned int best_divisor;\r\nstruct clk *mix_clk, *parent;\r\nint i;\r\nbest_divisor = best_parent_rate / rate;\r\nmix_clk = hw->clk;\r\nif (mix->table) {\r\nfor (i = 0; i < mix->table_size; i++) {\r\nitem = &mix->table[i];\r\nif (item->valid == 0)\r\ncontinue;\r\nparent = clk_get_parent_by_index(mix_clk,\r\nitem->parent_index);\r\nparent_rate = __clk_get_rate(parent);\r\nif (parent_rate == best_parent_rate\r\n&& item->divisor == best_divisor)\r\nbreak;\r\n}\r\nif (i < mix->table_size)\r\nreturn _set_rate(mix,\r\n_get_mux_val(mix, item->parent_index),\r\n_get_div_val(mix, item->divisor),\r\n1, 1);\r\nelse\r\nreturn -EINVAL;\r\n} else {\r\nfor (i = 0; i < __clk_get_num_parents(mix_clk); i++) {\r\nparent = clk_get_parent_by_index(mix_clk, i);\r\nparent_rate = __clk_get_rate(parent);\r\nif (parent_rate == best_parent_rate)\r\nbreak;\r\n}\r\nif (i < __clk_get_num_parents(mix_clk))\r\nreturn _set_rate(mix, _get_mux_val(mix, i),\r\n_get_div_val(mix, best_divisor), 1, 1);\r\nelse\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void mmp_clk_mix_init(struct clk_hw *hw)\r\n{\r\nstruct mmp_clk_mix *mix = to_clk_mix(hw);\r\nif (mix->table)\r\n_filter_clk_table(mix, mix->table, mix->table_size);\r\n}\r\nstruct clk *mmp_clk_register_mix(struct device *dev,\r\nconst char *name,\r\nconst char **parent_names,\r\nu8 num_parents,\r\nunsigned long flags,\r\nstruct mmp_clk_mix_config *config,\r\nspinlock_t *lock)\r\n{\r\nstruct mmp_clk_mix *mix;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\nsize_t table_bytes;\r\nmix = kzalloc(sizeof(*mix), GFP_KERNEL);\r\nif (!mix) {\r\npr_err("%s:%s: could not allocate mmp mix clk\n",\r\n__func__, name);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ninit.name = name;\r\ninit.flags = flags | CLK_GET_RATE_NOCACHE;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = num_parents;\r\ninit.ops = &mmp_clk_mix_ops;\r\nmemcpy(&mix->reg_info, &config->reg_info, sizeof(config->reg_info));\r\nif (config->table) {\r\ntable_bytes = sizeof(*config->table) * config->table_size;\r\nmix->table = kzalloc(table_bytes, GFP_KERNEL);\r\nif (!mix->table) {\r\npr_err("%s:%s: could not allocate mmp mix table\n",\r\n__func__, name);\r\nkfree(mix);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nmemcpy(mix->table, config->table, table_bytes);\r\nmix->table_size = config->table_size;\r\n}\r\nif (config->mux_table) {\r\ntable_bytes = sizeof(u32) * num_parents;\r\nmix->mux_table = kzalloc(table_bytes, GFP_KERNEL);\r\nif (!mix->mux_table) {\r\npr_err("%s:%s: could not allocate mmp mix mux-table\n",\r\n__func__, name);\r\nkfree(mix->table);\r\nkfree(mix);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nmemcpy(mix->mux_table, config->mux_table, table_bytes);\r\n}\r\nmix->div_flags = config->div_flags;\r\nmix->mux_flags = config->mux_flags;\r\nmix->lock = lock;\r\nmix->hw.init = &init;\r\nif (config->reg_info.bit_fc >= 32)\r\nmix->type = MMP_CLK_MIX_TYPE_V1;\r\nelse if (config->reg_info.reg_clk_sel)\r\nmix->type = MMP_CLK_MIX_TYPE_V3;\r\nelse\r\nmix->type = MMP_CLK_MIX_TYPE_V2;\r\nclk = clk_register(dev, &mix->hw);\r\nif (IS_ERR(clk)) {\r\nkfree(mix->mux_table);\r\nkfree(mix->table);\r\nkfree(mix);\r\n}\r\nreturn clk;\r\n}
