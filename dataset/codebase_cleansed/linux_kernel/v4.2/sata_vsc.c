static int vsc_sata_scr_read(struct ata_link *link,\r\nunsigned int sc_reg, u32 *val)\r\n{\r\nif (sc_reg > SCR_CONTROL)\r\nreturn -EINVAL;\r\n*val = readl(link->ap->ioaddr.scr_addr + (sc_reg * 4));\r\nreturn 0;\r\n}\r\nstatic int vsc_sata_scr_write(struct ata_link *link,\r\nunsigned int sc_reg, u32 val)\r\n{\r\nif (sc_reg > SCR_CONTROL)\r\nreturn -EINVAL;\r\nwritel(val, link->ap->ioaddr.scr_addr + (sc_reg * 4));\r\nreturn 0;\r\n}\r\nstatic void vsc_freeze(struct ata_port *ap)\r\n{\r\nvoid __iomem *mask_addr;\r\nmask_addr = ap->host->iomap[VSC_MMIO_BAR] +\r\nVSC_SATA_INT_MASK_OFFSET + ap->port_no;\r\nwriteb(0, mask_addr);\r\n}\r\nstatic void vsc_thaw(struct ata_port *ap)\r\n{\r\nvoid __iomem *mask_addr;\r\nmask_addr = ap->host->iomap[VSC_MMIO_BAR] +\r\nVSC_SATA_INT_MASK_OFFSET + ap->port_no;\r\nwriteb(0xff, mask_addr);\r\n}\r\nstatic void vsc_intr_mask_update(struct ata_port *ap, u8 ctl)\r\n{\r\nvoid __iomem *mask_addr;\r\nu8 mask;\r\nmask_addr = ap->host->iomap[VSC_MMIO_BAR] +\r\nVSC_SATA_INT_MASK_OFFSET + ap->port_no;\r\nmask = readb(mask_addr);\r\nif (ctl & ATA_NIEN)\r\nmask |= 0x80;\r\nelse\r\nmask &= 0x7F;\r\nwriteb(mask, mask_addr);\r\n}\r\nstatic void vsc_sata_tf_load(struct ata_port *ap, const struct ata_taskfile *tf)\r\n{\r\nstruct ata_ioports *ioaddr = &ap->ioaddr;\r\nunsigned int is_addr = tf->flags & ATA_TFLAG_ISADDR;\r\nif ((tf->ctl & ATA_NIEN) != (ap->last_ctl & ATA_NIEN)) {\r\nap->last_ctl = tf->ctl;\r\nvsc_intr_mask_update(ap, tf->ctl & ATA_NIEN);\r\n}\r\nif (is_addr && (tf->flags & ATA_TFLAG_LBA48)) {\r\nwritew(tf->feature | (((u16)tf->hob_feature) << 8),\r\nioaddr->feature_addr);\r\nwritew(tf->nsect | (((u16)tf->hob_nsect) << 8),\r\nioaddr->nsect_addr);\r\nwritew(tf->lbal | (((u16)tf->hob_lbal) << 8),\r\nioaddr->lbal_addr);\r\nwritew(tf->lbam | (((u16)tf->hob_lbam) << 8),\r\nioaddr->lbam_addr);\r\nwritew(tf->lbah | (((u16)tf->hob_lbah) << 8),\r\nioaddr->lbah_addr);\r\n} else if (is_addr) {\r\nwritew(tf->feature, ioaddr->feature_addr);\r\nwritew(tf->nsect, ioaddr->nsect_addr);\r\nwritew(tf->lbal, ioaddr->lbal_addr);\r\nwritew(tf->lbam, ioaddr->lbam_addr);\r\nwritew(tf->lbah, ioaddr->lbah_addr);\r\n}\r\nif (tf->flags & ATA_TFLAG_DEVICE)\r\nwriteb(tf->device, ioaddr->device_addr);\r\nata_wait_idle(ap);\r\n}\r\nstatic void vsc_sata_tf_read(struct ata_port *ap, struct ata_taskfile *tf)\r\n{\r\nstruct ata_ioports *ioaddr = &ap->ioaddr;\r\nu16 nsect, lbal, lbam, lbah, feature;\r\ntf->command = ata_sff_check_status(ap);\r\ntf->device = readw(ioaddr->device_addr);\r\nfeature = readw(ioaddr->error_addr);\r\nnsect = readw(ioaddr->nsect_addr);\r\nlbal = readw(ioaddr->lbal_addr);\r\nlbam = readw(ioaddr->lbam_addr);\r\nlbah = readw(ioaddr->lbah_addr);\r\ntf->feature = feature;\r\ntf->nsect = nsect;\r\ntf->lbal = lbal;\r\ntf->lbam = lbam;\r\ntf->lbah = lbah;\r\nif (tf->flags & ATA_TFLAG_LBA48) {\r\ntf->hob_feature = feature >> 8;\r\ntf->hob_nsect = nsect >> 8;\r\ntf->hob_lbal = lbal >> 8;\r\ntf->hob_lbam = lbam >> 8;\r\ntf->hob_lbah = lbah >> 8;\r\n}\r\n}\r\nstatic inline void vsc_error_intr(u8 port_status, struct ata_port *ap)\r\n{\r\nif (port_status & (VSC_SATA_INT_PHY_CHANGE | VSC_SATA_INT_ERROR_M))\r\nata_port_freeze(ap);\r\nelse\r\nata_port_abort(ap);\r\n}\r\nstatic void vsc_port_intr(u8 port_status, struct ata_port *ap)\r\n{\r\nstruct ata_queued_cmd *qc;\r\nint handled = 0;\r\nif (unlikely(port_status & VSC_SATA_INT_ERROR)) {\r\nvsc_error_intr(port_status, ap);\r\nreturn;\r\n}\r\nqc = ata_qc_from_tag(ap, ap->link.active_tag);\r\nif (qc && likely(!(qc->tf.flags & ATA_TFLAG_POLLING)))\r\nhandled = ata_bmdma_port_intr(ap, qc);\r\nif (unlikely(!handled))\r\nap->ops->sff_check_status(ap);\r\n}\r\nstatic irqreturn_t vsc_sata_interrupt(int irq, void *dev_instance)\r\n{\r\nstruct ata_host *host = dev_instance;\r\nunsigned int i;\r\nunsigned int handled = 0;\r\nu32 status;\r\nstatus = readl(host->iomap[VSC_MMIO_BAR] + VSC_SATA_INT_STAT_OFFSET);\r\nif (unlikely(status == 0xffffffff || status == 0)) {\r\nif (status)\r\ndev_err(host->dev,\r\n": IRQ status == 0xffffffff, PCI fault or device removal?\n");\r\ngoto out;\r\n}\r\nspin_lock(&host->lock);\r\nfor (i = 0; i < host->n_ports; i++) {\r\nu8 port_status = (status >> (8 * i)) & 0xff;\r\nif (port_status) {\r\nvsc_port_intr(port_status, host->ports[i]);\r\nhandled++;\r\n}\r\n}\r\nspin_unlock(&host->lock);\r\nout:\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void vsc_sata_setup_port(struct ata_ioports *port, void __iomem *base)\r\n{\r\nport->cmd_addr = base + VSC_SATA_TF_CMD_OFFSET;\r\nport->data_addr = base + VSC_SATA_TF_DATA_OFFSET;\r\nport->error_addr = base + VSC_SATA_TF_ERROR_OFFSET;\r\nport->feature_addr = base + VSC_SATA_TF_FEATURE_OFFSET;\r\nport->nsect_addr = base + VSC_SATA_TF_NSECT_OFFSET;\r\nport->lbal_addr = base + VSC_SATA_TF_LBAL_OFFSET;\r\nport->lbam_addr = base + VSC_SATA_TF_LBAM_OFFSET;\r\nport->lbah_addr = base + VSC_SATA_TF_LBAH_OFFSET;\r\nport->device_addr = base + VSC_SATA_TF_DEVICE_OFFSET;\r\nport->status_addr = base + VSC_SATA_TF_STATUS_OFFSET;\r\nport->command_addr = base + VSC_SATA_TF_COMMAND_OFFSET;\r\nport->altstatus_addr = base + VSC_SATA_TF_ALTSTATUS_OFFSET;\r\nport->ctl_addr = base + VSC_SATA_TF_CTL_OFFSET;\r\nport->bmdma_addr = base + VSC_SATA_DMA_CMD_OFFSET;\r\nport->scr_addr = base + VSC_SATA_SCR_STATUS_OFFSET;\r\nwritel(0, base + VSC_SATA_UP_DESCRIPTOR_OFFSET);\r\nwritel(0, base + VSC_SATA_UP_DATA_BUFFER_OFFSET);\r\n}\r\nstatic int vsc_sata_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstatic const struct ata_port_info pi = {\r\n.flags = ATA_FLAG_SATA,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA6,\r\n.port_ops = &vsc_sata_ops,\r\n};\r\nconst struct ata_port_info *ppi[] = { &pi, NULL };\r\nstruct ata_host *host;\r\nvoid __iomem *mmio_base;\r\nint i, rc;\r\nu8 cls;\r\nata_print_version_once(&pdev->dev, DRV_VERSION);\r\nhost = ata_host_alloc_pinfo(&pdev->dev, ppi, 4);\r\nif (!host)\r\nreturn -ENOMEM;\r\nrc = pcim_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nif (pci_resource_len(pdev, 0) == 0)\r\nreturn -ENODEV;\r\nrc = pcim_iomap_regions(pdev, 1 << VSC_MMIO_BAR, DRV_NAME);\r\nif (rc == -EBUSY)\r\npcim_pin_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nhost->iomap = pcim_iomap_table(pdev);\r\nmmio_base = host->iomap[VSC_MMIO_BAR];\r\nfor (i = 0; i < host->n_ports; i++) {\r\nstruct ata_port *ap = host->ports[i];\r\nunsigned int offset = (i + 1) * VSC_SATA_PORT_OFFSET;\r\nvsc_sata_setup_port(&ap->ioaddr, mmio_base + offset);\r\nata_port_pbar_desc(ap, VSC_MMIO_BAR, -1, "mmio");\r\nata_port_pbar_desc(ap, VSC_MMIO_BAR, offset, "port");\r\n}\r\nrc = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\r\nif (rc)\r\nreturn rc;\r\nrc = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));\r\nif (rc)\r\nreturn rc;\r\npci_read_config_byte(pdev, PCI_CACHE_LINE_SIZE, &cls);\r\nif (cls == 0x00)\r\npci_write_config_byte(pdev, PCI_CACHE_LINE_SIZE, 0x80);\r\nif (pci_enable_msi(pdev) == 0)\r\npci_intx(pdev, 0);\r\npci_write_config_dword(pdev, 0x98, 0);\r\npci_set_master(pdev);\r\nreturn ata_host_activate(host, pdev->irq, vsc_sata_interrupt,\r\nIRQF_SHARED, &vsc_sata_sht);\r\n}
