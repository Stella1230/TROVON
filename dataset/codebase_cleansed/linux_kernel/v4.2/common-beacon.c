static u32 ath9k_mod_tsf64_tu(u64 tsf, u32 div_tu)\r\n{\r\nu32 tsf_mod, tsf_hi, tsf_lo, mod_hi, mod_lo;\r\ntsf_mod = tsf & (BIT(10) - 1);\r\ntsf_hi = tsf >> 32;\r\ntsf_lo = ((u32) tsf) >> 10;\r\nmod_hi = tsf_hi % div_tu;\r\nmod_lo = ((mod_hi << 22) + tsf_lo) % div_tu;\r\nreturn (mod_lo << 10) | tsf_mod;\r\n}\r\nstatic u32 ath9k_get_next_tbtt(struct ath_hw *ah, u64 tsf,\r\nunsigned int interval)\r\n{\r\nunsigned int offset;\r\ntsf += TU_TO_USEC(FUDGE + ah->config.sw_beacon_response_time);\r\noffset = ath9k_mod_tsf64_tu(tsf, interval);\r\nreturn (u32) tsf + TU_TO_USEC(interval) - offset;\r\n}\r\nint ath9k_cmn_beacon_config_sta(struct ath_hw *ah,\r\nstruct ath_beacon_config *conf,\r\nstruct ath9k_beacon_state *bs)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nint dtim_intval;\r\nu64 tsf;\r\nif (!test_bit(ATH_OP_PRIM_STA_VIF, &common->op_flags)) {\r\nath_dbg(common, BEACON,\r\n"STA is not yet associated..skipping beacon config\n");\r\nreturn -EPERM;\r\n}\r\nmemset(bs, 0, sizeof(*bs));\r\nconf->intval = conf->beacon_interval;\r\ndtim_intval = conf->intval * conf->dtim_period;\r\ntsf = ath9k_hw_gettsf64(ah);\r\nconf->nexttbtt = ath9k_get_next_tbtt(ah, tsf, conf->intval);\r\nbs->bs_intval = TU_TO_USEC(conf->intval);\r\nbs->bs_dtimperiod = conf->dtim_period * bs->bs_intval;\r\nbs->bs_nexttbtt = conf->nexttbtt;\r\nbs->bs_nextdtim = conf->nexttbtt;\r\nif (conf->dtim_period > 1)\r\nbs->bs_nextdtim = ath9k_get_next_tbtt(ah, tsf, dtim_intval);\r\nbs->bs_bmissthreshold = DIV_ROUND_UP(conf->bmiss_timeout, conf->intval);\r\nif (bs->bs_bmissthreshold > 15)\r\nbs->bs_bmissthreshold = 15;\r\nelse if (bs->bs_bmissthreshold <= 0)\r\nbs->bs_bmissthreshold = 1;\r\nbs->bs_sleepduration = TU_TO_USEC(roundup(IEEE80211_MS_TO_TU(100),\r\nconf->intval));\r\nif (bs->bs_sleepduration > bs->bs_dtimperiod)\r\nbs->bs_sleepduration = bs->bs_dtimperiod;\r\nbs->bs_tsfoor_threshold = ATH9K_TSFOOR_THRESHOLD;\r\nath_dbg(common, BEACON, "bmiss: %u sleep: %u\n",\r\nbs->bs_bmissthreshold, bs->bs_sleepduration);\r\nreturn 0;\r\n}\r\nvoid ath9k_cmn_beacon_config_adhoc(struct ath_hw *ah,\r\nstruct ath_beacon_config *conf)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nconf->intval = TU_TO_USEC(conf->beacon_interval);\r\nif (conf->ibss_creator)\r\nconf->nexttbtt = conf->intval;\r\nelse\r\nconf->nexttbtt = ath9k_get_next_tbtt(ah, ath9k_hw_gettsf64(ah),\r\nconf->beacon_interval);\r\nif (conf->enable_beacon)\r\nah->imask |= ATH9K_INT_SWBA;\r\nelse\r\nah->imask &= ~ATH9K_INT_SWBA;\r\nath_dbg(common, BEACON,\r\n"IBSS (%s) nexttbtt: %u intval: %u conf_intval: %u\n",\r\n(conf->enable_beacon) ? "Enable" : "Disable",\r\nconf->nexttbtt, conf->intval, conf->beacon_interval);\r\n}\r\nvoid ath9k_cmn_beacon_config_ap(struct ath_hw *ah,\r\nstruct ath_beacon_config *conf,\r\nunsigned int bc_buf)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nconf->intval = TU_TO_USEC(conf->beacon_interval);\r\nconf->intval /= bc_buf;\r\nconf->nexttbtt = ath9k_get_next_tbtt(ah, ath9k_hw_gettsf64(ah),\r\nconf->beacon_interval);\r\nif (conf->enable_beacon)\r\nah->imask |= ATH9K_INT_SWBA;\r\nelse\r\nah->imask &= ~ATH9K_INT_SWBA;\r\nath_dbg(common, BEACON,\r\n"AP (%s) nexttbtt: %u intval: %u conf_intval: %u\n",\r\n(conf->enable_beacon) ? "Enable" : "Disable",\r\nconf->nexttbtt, conf->intval, conf->beacon_interval);\r\n}
