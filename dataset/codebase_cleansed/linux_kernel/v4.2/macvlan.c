static u32 macvlan_eth_hash(const unsigned char *addr)\r\n{\r\nu64 value = get_unaligned((u64 *)addr);\r\n#ifdef __BIG_ENDIAN\r\nvalue >>= 16;\r\n#else\r\nvalue <<= 16;\r\n#endif\r\nreturn hash_64(value, MACVLAN_HASH_BITS);\r\n}\r\nstatic struct macvlan_port *macvlan_port_get_rcu(const struct net_device *dev)\r\n{\r\nreturn rcu_dereference(dev->rx_handler_data);\r\n}\r\nstatic struct macvlan_port *macvlan_port_get_rtnl(const struct net_device *dev)\r\n{\r\nreturn rtnl_dereference(dev->rx_handler_data);\r\n}\r\nstatic struct macvlan_dev *macvlan_hash_lookup(const struct macvlan_port *port,\r\nconst unsigned char *addr)\r\n{\r\nstruct macvlan_dev *vlan;\r\nu32 idx = macvlan_eth_hash(addr);\r\nhlist_for_each_entry_rcu(vlan, &port->vlan_hash[idx], hlist) {\r\nif (ether_addr_equal_64bits(vlan->dev->dev_addr, addr))\r\nreturn vlan;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct macvlan_source_entry *macvlan_hash_lookup_source(\r\nconst struct macvlan_dev *vlan,\r\nconst unsigned char *addr)\r\n{\r\nstruct macvlan_source_entry *entry;\r\nu32 idx = macvlan_eth_hash(addr);\r\nstruct hlist_head *h = &vlan->port->vlan_source_hash[idx];\r\nhlist_for_each_entry_rcu(entry, h, hlist) {\r\nif (ether_addr_equal_64bits(entry->addr, addr) &&\r\nentry->vlan == vlan)\r\nreturn entry;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int macvlan_hash_add_source(struct macvlan_dev *vlan,\r\nconst unsigned char *addr)\r\n{\r\nstruct macvlan_port *port = vlan->port;\r\nstruct macvlan_source_entry *entry;\r\nstruct hlist_head *h;\r\nentry = macvlan_hash_lookup_source(vlan, addr);\r\nif (entry)\r\nreturn 0;\r\nentry = kmalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry)\r\nreturn -ENOMEM;\r\nether_addr_copy(entry->addr, addr);\r\nentry->vlan = vlan;\r\nh = &port->vlan_source_hash[macvlan_eth_hash(addr)];\r\nhlist_add_head_rcu(&entry->hlist, h);\r\nvlan->macaddr_count++;\r\nreturn 0;\r\n}\r\nstatic void macvlan_hash_add(struct macvlan_dev *vlan)\r\n{\r\nstruct macvlan_port *port = vlan->port;\r\nconst unsigned char *addr = vlan->dev->dev_addr;\r\nu32 idx = macvlan_eth_hash(addr);\r\nhlist_add_head_rcu(&vlan->hlist, &port->vlan_hash[idx]);\r\n}\r\nstatic void macvlan_hash_del_source(struct macvlan_source_entry *entry)\r\n{\r\nhlist_del_rcu(&entry->hlist);\r\nkfree_rcu(entry, rcu);\r\n}\r\nstatic void macvlan_hash_del(struct macvlan_dev *vlan, bool sync)\r\n{\r\nhlist_del_rcu(&vlan->hlist);\r\nif (sync)\r\nsynchronize_rcu();\r\n}\r\nstatic void macvlan_hash_change_addr(struct macvlan_dev *vlan,\r\nconst unsigned char *addr)\r\n{\r\nmacvlan_hash_del(vlan, true);\r\nmemcpy(vlan->dev->dev_addr, addr, ETH_ALEN);\r\nmacvlan_hash_add(vlan);\r\n}\r\nstatic int macvlan_addr_busy(const struct macvlan_port *port,\r\nconst unsigned char *addr)\r\n{\r\nif (ether_addr_equal_64bits(port->dev->dev_addr, addr))\r\nreturn 1;\r\nif (macvlan_hash_lookup(port, addr))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int macvlan_broadcast_one(struct sk_buff *skb,\r\nconst struct macvlan_dev *vlan,\r\nconst struct ethhdr *eth, bool local)\r\n{\r\nstruct net_device *dev = vlan->dev;\r\nif (local)\r\nreturn __dev_forward_skb(dev, skb);\r\nskb->dev = dev;\r\nif (ether_addr_equal_64bits(eth->h_dest, dev->broadcast))\r\nskb->pkt_type = PACKET_BROADCAST;\r\nelse\r\nskb->pkt_type = PACKET_MULTICAST;\r\nreturn 0;\r\n}\r\nstatic u32 macvlan_hash_mix(const struct macvlan_dev *vlan)\r\n{\r\nreturn (u32)(((unsigned long)vlan) >> L1_CACHE_SHIFT);\r\n}\r\nstatic unsigned int mc_hash(const struct macvlan_dev *vlan,\r\nconst unsigned char *addr)\r\n{\r\nu32 val = __get_unaligned_cpu32(addr + 2);\r\nval ^= macvlan_hash_mix(vlan);\r\nreturn hash_32(val, MACVLAN_MC_FILTER_BITS);\r\n}\r\nstatic void macvlan_broadcast(struct sk_buff *skb,\r\nconst struct macvlan_port *port,\r\nstruct net_device *src,\r\nenum macvlan_mode mode)\r\n{\r\nconst struct ethhdr *eth = eth_hdr(skb);\r\nconst struct macvlan_dev *vlan;\r\nstruct sk_buff *nskb;\r\nunsigned int i;\r\nint err;\r\nunsigned int hash;\r\nif (skb->protocol == htons(ETH_P_PAUSE))\r\nreturn;\r\nfor (i = 0; i < MACVLAN_HASH_SIZE; i++) {\r\nhlist_for_each_entry_rcu(vlan, &port->vlan_hash[i], hlist) {\r\nif (vlan->dev == src || !(vlan->mode & mode))\r\ncontinue;\r\nhash = mc_hash(vlan, eth->h_dest);\r\nif (!test_bit(hash, vlan->mc_filter))\r\ncontinue;\r\nerr = NET_RX_DROP;\r\nnskb = skb_clone(skb, GFP_ATOMIC);\r\nif (likely(nskb))\r\nerr = macvlan_broadcast_one(\r\nnskb, vlan, eth,\r\nmode == MACVLAN_MODE_BRIDGE) ?:\r\nnetif_rx_ni(nskb);\r\nmacvlan_count_rx(vlan, skb->len + ETH_HLEN,\r\nerr == NET_RX_SUCCESS, true);\r\n}\r\n}\r\n}\r\nstatic void macvlan_process_broadcast(struct work_struct *w)\r\n{\r\nstruct macvlan_port *port = container_of(w, struct macvlan_port,\r\nbc_work);\r\nstruct sk_buff *skb;\r\nstruct sk_buff_head list;\r\n__skb_queue_head_init(&list);\r\nspin_lock_bh(&port->bc_queue.lock);\r\nskb_queue_splice_tail_init(&port->bc_queue, &list);\r\nspin_unlock_bh(&port->bc_queue.lock);\r\nwhile ((skb = __skb_dequeue(&list))) {\r\nconst struct macvlan_dev *src = MACVLAN_SKB_CB(skb)->src;\r\nrcu_read_lock();\r\nif (!src)\r\nmacvlan_broadcast(skb, port, NULL,\r\nMACVLAN_MODE_PRIVATE |\r\nMACVLAN_MODE_VEPA |\r\nMACVLAN_MODE_PASSTHRU|\r\nMACVLAN_MODE_BRIDGE);\r\nelse if (src->mode == MACVLAN_MODE_VEPA)\r\nmacvlan_broadcast(skb, port, src->dev,\r\nMACVLAN_MODE_VEPA |\r\nMACVLAN_MODE_BRIDGE);\r\nelse\r\nmacvlan_broadcast(skb, port, src->dev,\r\nMACVLAN_MODE_VEPA);\r\nrcu_read_unlock();\r\nkfree_skb(skb);\r\n}\r\n}\r\nstatic void macvlan_broadcast_enqueue(struct macvlan_port *port,\r\nstruct sk_buff *skb)\r\n{\r\nstruct sk_buff *nskb;\r\nint err = -ENOMEM;\r\nnskb = skb_clone(skb, GFP_ATOMIC);\r\nif (!nskb)\r\ngoto err;\r\nspin_lock(&port->bc_queue.lock);\r\nif (skb_queue_len(&port->bc_queue) < MACVLAN_BC_QUEUE_LEN) {\r\n__skb_queue_tail(&port->bc_queue, nskb);\r\nerr = 0;\r\n}\r\nspin_unlock(&port->bc_queue.lock);\r\nif (err)\r\ngoto free_nskb;\r\nschedule_work(&port->bc_work);\r\nreturn;\r\nfree_nskb:\r\nkfree_skb(nskb);\r\nerr:\r\natomic_long_inc(&skb->dev->rx_dropped);\r\n}\r\nstatic void macvlan_flush_sources(struct macvlan_port *port,\r\nstruct macvlan_dev *vlan)\r\n{\r\nint i;\r\nfor (i = 0; i < MACVLAN_HASH_SIZE; i++) {\r\nstruct hlist_node *h, *n;\r\nhlist_for_each_safe(h, n, &port->vlan_source_hash[i]) {\r\nstruct macvlan_source_entry *entry;\r\nentry = hlist_entry(h, struct macvlan_source_entry,\r\nhlist);\r\nif (entry->vlan == vlan)\r\nmacvlan_hash_del_source(entry);\r\n}\r\n}\r\nvlan->macaddr_count = 0;\r\n}\r\nstatic void macvlan_forward_source_one(struct sk_buff *skb,\r\nstruct macvlan_dev *vlan)\r\n{\r\nstruct sk_buff *nskb;\r\nstruct net_device *dev;\r\nint len;\r\nint ret;\r\ndev = vlan->dev;\r\nif (unlikely(!(dev->flags & IFF_UP)))\r\nreturn;\r\nnskb = skb_clone(skb, GFP_ATOMIC);\r\nif (!nskb)\r\nreturn;\r\nlen = nskb->len + ETH_HLEN;\r\nnskb->dev = dev;\r\nnskb->pkt_type = PACKET_HOST;\r\nret = netif_rx(nskb);\r\nmacvlan_count_rx(vlan, len, ret == NET_RX_SUCCESS, false);\r\n}\r\nstatic void macvlan_forward_source(struct sk_buff *skb,\r\nstruct macvlan_port *port,\r\nconst unsigned char *addr)\r\n{\r\nstruct macvlan_source_entry *entry;\r\nu32 idx = macvlan_eth_hash(addr);\r\nstruct hlist_head *h = &port->vlan_source_hash[idx];\r\nhlist_for_each_entry_rcu(entry, h, hlist) {\r\nif (ether_addr_equal_64bits(entry->addr, addr))\r\nif (entry->vlan->dev->flags & IFF_UP)\r\nmacvlan_forward_source_one(skb, entry->vlan);\r\n}\r\n}\r\nstatic rx_handler_result_t macvlan_handle_frame(struct sk_buff **pskb)\r\n{\r\nstruct macvlan_port *port;\r\nstruct sk_buff *skb = *pskb;\r\nconst struct ethhdr *eth = eth_hdr(skb);\r\nconst struct macvlan_dev *vlan;\r\nconst struct macvlan_dev *src;\r\nstruct net_device *dev;\r\nunsigned int len = 0;\r\nint ret;\r\nrx_handler_result_t handle_res;\r\nport = macvlan_port_get_rcu(skb->dev);\r\nif (is_multicast_ether_addr(eth->h_dest)) {\r\nskb = ip_check_defrag(skb, IP_DEFRAG_MACVLAN);\r\nif (!skb)\r\nreturn RX_HANDLER_CONSUMED;\r\neth = eth_hdr(skb);\r\nmacvlan_forward_source(skb, port, eth->h_source);\r\nsrc = macvlan_hash_lookup(port, eth->h_source);\r\nif (src && src->mode != MACVLAN_MODE_VEPA &&\r\nsrc->mode != MACVLAN_MODE_BRIDGE) {\r\nvlan = src;\r\nret = macvlan_broadcast_one(skb, vlan, eth, 0) ?:\r\nnetif_rx(skb);\r\nhandle_res = RX_HANDLER_CONSUMED;\r\ngoto out;\r\n}\r\nMACVLAN_SKB_CB(skb)->src = src;\r\nmacvlan_broadcast_enqueue(port, skb);\r\nreturn RX_HANDLER_PASS;\r\n}\r\nmacvlan_forward_source(skb, port, eth->h_source);\r\nif (port->passthru)\r\nvlan = list_first_or_null_rcu(&port->vlans,\r\nstruct macvlan_dev, list);\r\nelse\r\nvlan = macvlan_hash_lookup(port, eth->h_dest);\r\nif (vlan == NULL)\r\nreturn RX_HANDLER_PASS;\r\ndev = vlan->dev;\r\nif (unlikely(!(dev->flags & IFF_UP))) {\r\nkfree_skb(skb);\r\nreturn RX_HANDLER_CONSUMED;\r\n}\r\nlen = skb->len + ETH_HLEN;\r\nskb = skb_share_check(skb, GFP_ATOMIC);\r\nif (!skb) {\r\nret = NET_RX_DROP;\r\nhandle_res = RX_HANDLER_CONSUMED;\r\ngoto out;\r\n}\r\nskb->dev = dev;\r\nskb->pkt_type = PACKET_HOST;\r\nret = NET_RX_SUCCESS;\r\nhandle_res = RX_HANDLER_ANOTHER;\r\nout:\r\nmacvlan_count_rx(vlan, len, ret == NET_RX_SUCCESS, false);\r\nreturn handle_res;\r\n}\r\nstatic int macvlan_queue_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nconst struct macvlan_dev *vlan = netdev_priv(dev);\r\nconst struct macvlan_port *port = vlan->port;\r\nconst struct macvlan_dev *dest;\r\nif (vlan->mode == MACVLAN_MODE_BRIDGE) {\r\nconst struct ethhdr *eth = (void *)skb->data;\r\nif (is_multicast_ether_addr(eth->h_dest)) {\r\nmacvlan_broadcast(skb, port, dev, MACVLAN_MODE_BRIDGE);\r\ngoto xmit_world;\r\n}\r\ndest = macvlan_hash_lookup(port, eth->h_dest);\r\nif (dest && dest->mode == MACVLAN_MODE_BRIDGE) {\r\ndev_forward_skb(vlan->lowerdev, skb);\r\nreturn NET_XMIT_SUCCESS;\r\n}\r\n}\r\nxmit_world:\r\nskb->dev = vlan->lowerdev;\r\nreturn dev_queue_xmit(skb);\r\n}\r\nstatic inline netdev_tx_t macvlan_netpoll_send_skb(struct macvlan_dev *vlan, struct sk_buff *skb)\r\n{\r\n#ifdef CONFIG_NET_POLL_CONTROLLER\r\nif (vlan->netpoll)\r\nnetpoll_send_skb(vlan->netpoll, skb);\r\n#else\r\nBUG();\r\n#endif\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic netdev_tx_t macvlan_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nunsigned int len = skb->len;\r\nint ret;\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nif (unlikely(netpoll_tx_running(dev)))\r\nreturn macvlan_netpoll_send_skb(vlan, skb);\r\nif (vlan->fwd_priv) {\r\nskb->dev = vlan->lowerdev;\r\nret = dev_queue_xmit_accel(skb, vlan->fwd_priv);\r\n} else {\r\nret = macvlan_queue_xmit(skb, dev);\r\n}\r\nif (likely(ret == NET_XMIT_SUCCESS || ret == NET_XMIT_CN)) {\r\nstruct vlan_pcpu_stats *pcpu_stats;\r\npcpu_stats = this_cpu_ptr(vlan->pcpu_stats);\r\nu64_stats_update_begin(&pcpu_stats->syncp);\r\npcpu_stats->tx_packets++;\r\npcpu_stats->tx_bytes += len;\r\nu64_stats_update_end(&pcpu_stats->syncp);\r\n} else {\r\nthis_cpu_inc(vlan->pcpu_stats->tx_dropped);\r\n}\r\nreturn ret;\r\n}\r\nstatic int macvlan_hard_header(struct sk_buff *skb, struct net_device *dev,\r\nunsigned short type, const void *daddr,\r\nconst void *saddr, unsigned len)\r\n{\r\nconst struct macvlan_dev *vlan = netdev_priv(dev);\r\nstruct net_device *lowerdev = vlan->lowerdev;\r\nreturn dev_hard_header(skb, lowerdev, type, daddr,\r\nsaddr ? : dev->dev_addr, len);\r\n}\r\nstatic int macvlan_open(struct net_device *dev)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nstruct net_device *lowerdev = vlan->lowerdev;\r\nint err;\r\nif (vlan->port->passthru) {\r\nif (!(vlan->flags & MACVLAN_FLAG_NOPROMISC)) {\r\nerr = dev_set_promiscuity(lowerdev, 1);\r\nif (err < 0)\r\ngoto out;\r\n}\r\ngoto hash_add;\r\n}\r\nif (lowerdev->features & NETIF_F_HW_L2FW_DOFFLOAD &&\r\ndev->rtnl_link_ops == &macvlan_link_ops) {\r\nvlan->fwd_priv =\r\nlowerdev->netdev_ops->ndo_dfwd_add_station(lowerdev, dev);\r\nif (IS_ERR_OR_NULL(vlan->fwd_priv)) {\r\nvlan->fwd_priv = NULL;\r\n} else\r\nreturn 0;\r\n}\r\nerr = -EBUSY;\r\nif (macvlan_addr_busy(vlan->port, dev->dev_addr))\r\ngoto out;\r\nerr = dev_uc_add(lowerdev, dev->dev_addr);\r\nif (err < 0)\r\ngoto out;\r\nif (dev->flags & IFF_ALLMULTI) {\r\nerr = dev_set_allmulti(lowerdev, 1);\r\nif (err < 0)\r\ngoto del_unicast;\r\n}\r\nif (dev->flags & IFF_PROMISC) {\r\nerr = dev_set_promiscuity(lowerdev, 1);\r\nif (err < 0)\r\ngoto clear_multi;\r\n}\r\nhash_add:\r\nmacvlan_hash_add(vlan);\r\nreturn 0;\r\nclear_multi:\r\ndev_set_allmulti(lowerdev, -1);\r\ndel_unicast:\r\ndev_uc_del(lowerdev, dev->dev_addr);\r\nout:\r\nif (vlan->fwd_priv) {\r\nlowerdev->netdev_ops->ndo_dfwd_del_station(lowerdev,\r\nvlan->fwd_priv);\r\nvlan->fwd_priv = NULL;\r\n}\r\nreturn err;\r\n}\r\nstatic int macvlan_stop(struct net_device *dev)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nstruct net_device *lowerdev = vlan->lowerdev;\r\nif (vlan->fwd_priv) {\r\nlowerdev->netdev_ops->ndo_dfwd_del_station(lowerdev,\r\nvlan->fwd_priv);\r\nvlan->fwd_priv = NULL;\r\nreturn 0;\r\n}\r\ndev_uc_unsync(lowerdev, dev);\r\ndev_mc_unsync(lowerdev, dev);\r\nif (vlan->port->passthru) {\r\nif (!(vlan->flags & MACVLAN_FLAG_NOPROMISC))\r\ndev_set_promiscuity(lowerdev, -1);\r\ngoto hash_del;\r\n}\r\nif (dev->flags & IFF_ALLMULTI)\r\ndev_set_allmulti(lowerdev, -1);\r\nif (dev->flags & IFF_PROMISC)\r\ndev_set_promiscuity(lowerdev, -1);\r\ndev_uc_del(lowerdev, dev->dev_addr);\r\nhash_del:\r\nmacvlan_hash_del(vlan, !dev->dismantle);\r\nreturn 0;\r\n}\r\nstatic int macvlan_sync_address(struct net_device *dev, unsigned char *addr)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nstruct net_device *lowerdev = vlan->lowerdev;\r\nint err;\r\nif (!(dev->flags & IFF_UP)) {\r\nether_addr_copy(dev->dev_addr, addr);\r\n} else {\r\nif (macvlan_addr_busy(vlan->port, addr))\r\nreturn -EBUSY;\r\nif (!vlan->port->passthru) {\r\nerr = dev_uc_add(lowerdev, addr);\r\nif (err)\r\nreturn err;\r\ndev_uc_del(lowerdev, dev->dev_addr);\r\n}\r\nmacvlan_hash_change_addr(vlan, addr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int macvlan_set_mac_address(struct net_device *dev, void *p)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nstruct sockaddr *addr = p;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nif (vlan->mode == MACVLAN_MODE_PASSTHRU) {\r\ndev_set_mac_address(vlan->lowerdev, addr);\r\nreturn 0;\r\n}\r\nreturn macvlan_sync_address(dev, addr->sa_data);\r\n}\r\nstatic void macvlan_change_rx_flags(struct net_device *dev, int change)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nstruct net_device *lowerdev = vlan->lowerdev;\r\nif (dev->flags & IFF_UP) {\r\nif (change & IFF_ALLMULTI)\r\ndev_set_allmulti(lowerdev, dev->flags & IFF_ALLMULTI ? 1 : -1);\r\nif (change & IFF_PROMISC)\r\ndev_set_promiscuity(lowerdev,\r\ndev->flags & IFF_PROMISC ? 1 : -1);\r\n}\r\n}\r\nstatic void macvlan_set_mac_lists(struct net_device *dev)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nif (dev->flags & (IFF_PROMISC | IFF_ALLMULTI)) {\r\nbitmap_fill(vlan->mc_filter, MACVLAN_MC_FILTER_SZ);\r\n} else {\r\nstruct netdev_hw_addr *ha;\r\nDECLARE_BITMAP(filter, MACVLAN_MC_FILTER_SZ);\r\nbitmap_zero(filter, MACVLAN_MC_FILTER_SZ);\r\nnetdev_for_each_mc_addr(ha, dev) {\r\n__set_bit(mc_hash(vlan, ha->addr), filter);\r\n}\r\n__set_bit(mc_hash(vlan, dev->broadcast), filter);\r\nbitmap_copy(vlan->mc_filter, filter, MACVLAN_MC_FILTER_SZ);\r\n}\r\ndev_uc_sync(vlan->lowerdev, dev);\r\ndev_mc_sync(vlan->lowerdev, dev);\r\n}\r\nstatic int macvlan_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nif (new_mtu < 68 || vlan->lowerdev->mtu < new_mtu)\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic int macvlan_get_nest_level(struct net_device *dev)\r\n{\r\nreturn ((struct macvlan_dev *)netdev_priv(dev))->nest_level;\r\n}\r\nstatic void macvlan_set_lockdep_class_one(struct net_device *dev,\r\nstruct netdev_queue *txq,\r\nvoid *_unused)\r\n{\r\nlockdep_set_class(&txq->_xmit_lock,\r\n&macvlan_netdev_xmit_lock_key);\r\n}\r\nstatic void macvlan_set_lockdep_class(struct net_device *dev)\r\n{\r\nlockdep_set_class_and_subclass(&dev->addr_list_lock,\r\n&macvlan_netdev_addr_lock_key,\r\nmacvlan_get_nest_level(dev));\r\nnetdev_for_each_tx_queue(dev, macvlan_set_lockdep_class_one, NULL);\r\n}\r\nstatic int macvlan_init(struct net_device *dev)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nconst struct net_device *lowerdev = vlan->lowerdev;\r\ndev->state = (dev->state & ~MACVLAN_STATE_MASK) |\r\n(lowerdev->state & MACVLAN_STATE_MASK);\r\ndev->features = lowerdev->features & MACVLAN_FEATURES;\r\ndev->features |= ALWAYS_ON_FEATURES;\r\ndev->hw_features |= NETIF_F_LRO;\r\ndev->vlan_features = lowerdev->vlan_features & MACVLAN_FEATURES;\r\ndev->gso_max_size = lowerdev->gso_max_size;\r\ndev->hard_header_len = lowerdev->hard_header_len;\r\nmacvlan_set_lockdep_class(dev);\r\nvlan->pcpu_stats = netdev_alloc_pcpu_stats(struct vlan_pcpu_stats);\r\nif (!vlan->pcpu_stats)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void macvlan_uninit(struct net_device *dev)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nstruct macvlan_port *port = vlan->port;\r\nfree_percpu(vlan->pcpu_stats);\r\nmacvlan_flush_sources(port, vlan);\r\nport->count -= 1;\r\nif (!port->count)\r\nmacvlan_port_destroy(port->dev);\r\n}\r\nstatic struct rtnl_link_stats64 *macvlan_dev_get_stats64(struct net_device *dev,\r\nstruct rtnl_link_stats64 *stats)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nif (vlan->pcpu_stats) {\r\nstruct vlan_pcpu_stats *p;\r\nu64 rx_packets, rx_bytes, rx_multicast, tx_packets, tx_bytes;\r\nu32 rx_errors = 0, tx_dropped = 0;\r\nunsigned int start;\r\nint i;\r\nfor_each_possible_cpu(i) {\r\np = per_cpu_ptr(vlan->pcpu_stats, i);\r\ndo {\r\nstart = u64_stats_fetch_begin_irq(&p->syncp);\r\nrx_packets = p->rx_packets;\r\nrx_bytes = p->rx_bytes;\r\nrx_multicast = p->rx_multicast;\r\ntx_packets = p->tx_packets;\r\ntx_bytes = p->tx_bytes;\r\n} while (u64_stats_fetch_retry_irq(&p->syncp, start));\r\nstats->rx_packets += rx_packets;\r\nstats->rx_bytes += rx_bytes;\r\nstats->multicast += rx_multicast;\r\nstats->tx_packets += tx_packets;\r\nstats->tx_bytes += tx_bytes;\r\nrx_errors += p->rx_errors;\r\ntx_dropped += p->tx_dropped;\r\n}\r\nstats->rx_errors = rx_errors;\r\nstats->rx_dropped = rx_errors;\r\nstats->tx_dropped = tx_dropped;\r\n}\r\nreturn stats;\r\n}\r\nstatic int macvlan_vlan_rx_add_vid(struct net_device *dev,\r\n__be16 proto, u16 vid)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nstruct net_device *lowerdev = vlan->lowerdev;\r\nreturn vlan_vid_add(lowerdev, proto, vid);\r\n}\r\nstatic int macvlan_vlan_rx_kill_vid(struct net_device *dev,\r\n__be16 proto, u16 vid)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nstruct net_device *lowerdev = vlan->lowerdev;\r\nvlan_vid_del(lowerdev, proto, vid);\r\nreturn 0;\r\n}\r\nstatic int macvlan_fdb_add(struct ndmsg *ndm, struct nlattr *tb[],\r\nstruct net_device *dev,\r\nconst unsigned char *addr, u16 vid,\r\nu16 flags)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nint err = -EINVAL;\r\nif (!vlan->port->passthru && is_unicast_ether_addr(addr))\r\nreturn -EOPNOTSUPP;\r\nif (flags & NLM_F_REPLACE)\r\nreturn -EOPNOTSUPP;\r\nif (is_unicast_ether_addr(addr))\r\nerr = dev_uc_add_excl(dev, addr);\r\nelse if (is_multicast_ether_addr(addr))\r\nerr = dev_mc_add_excl(dev, addr);\r\nreturn err;\r\n}\r\nstatic int macvlan_fdb_del(struct ndmsg *ndm, struct nlattr *tb[],\r\nstruct net_device *dev,\r\nconst unsigned char *addr, u16 vid)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nint err = -EINVAL;\r\nif (!vlan->port->passthru && is_unicast_ether_addr(addr))\r\nreturn -EOPNOTSUPP;\r\nif (is_unicast_ether_addr(addr))\r\nerr = dev_uc_del(dev, addr);\r\nelse if (is_multicast_ether_addr(addr))\r\nerr = dev_mc_del(dev, addr);\r\nreturn err;\r\n}\r\nstatic void macvlan_ethtool_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *drvinfo)\r\n{\r\nstrlcpy(drvinfo->driver, "macvlan", sizeof(drvinfo->driver));\r\nstrlcpy(drvinfo->version, "0.1", sizeof(drvinfo->version));\r\n}\r\nstatic int macvlan_ethtool_get_settings(struct net_device *dev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nconst struct macvlan_dev *vlan = netdev_priv(dev);\r\nreturn __ethtool_get_settings(vlan->lowerdev, cmd);\r\n}\r\nstatic netdev_features_t macvlan_fix_features(struct net_device *dev,\r\nnetdev_features_t features)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nnetdev_features_t lowerdev_features = vlan->lowerdev->features;\r\nnetdev_features_t mask;\r\nfeatures |= NETIF_F_ALL_FOR_ALL;\r\nfeatures &= (vlan->set_features | ~MACVLAN_FEATURES);\r\nmask = features;\r\nlowerdev_features &= (features | ~NETIF_F_LRO);\r\nfeatures = netdev_increment_features(lowerdev_features, features, mask);\r\nfeatures |= ALWAYS_ON_FEATURES;\r\nfeatures &= ~NETIF_F_NETNS_LOCAL;\r\nreturn features;\r\n}\r\nstatic void macvlan_dev_poll_controller(struct net_device *dev)\r\n{\r\nreturn;\r\n}\r\nstatic int macvlan_dev_netpoll_setup(struct net_device *dev, struct netpoll_info *npinfo)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nstruct net_device *real_dev = vlan->lowerdev;\r\nstruct netpoll *netpoll;\r\nint err = 0;\r\nnetpoll = kzalloc(sizeof(*netpoll), GFP_KERNEL);\r\nerr = -ENOMEM;\r\nif (!netpoll)\r\ngoto out;\r\nerr = __netpoll_setup(netpoll, real_dev);\r\nif (err) {\r\nkfree(netpoll);\r\ngoto out;\r\n}\r\nvlan->netpoll = netpoll;\r\nout:\r\nreturn err;\r\n}\r\nstatic void macvlan_dev_netpoll_cleanup(struct net_device *dev)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nstruct netpoll *netpoll = vlan->netpoll;\r\nif (!netpoll)\r\nreturn;\r\nvlan->netpoll = NULL;\r\n__netpoll_free_async(netpoll);\r\n}\r\nstatic int macvlan_dev_get_iflink(const struct net_device *dev)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nreturn vlan->lowerdev->ifindex;\r\n}\r\nvoid macvlan_common_setup(struct net_device *dev)\r\n{\r\nether_setup(dev);\r\ndev->priv_flags &= ~IFF_TX_SKB_SHARING;\r\nnetif_keep_dst(dev);\r\ndev->priv_flags |= IFF_UNICAST_FLT;\r\ndev->netdev_ops = &macvlan_netdev_ops;\r\ndev->destructor = free_netdev;\r\ndev->header_ops = &macvlan_hard_header_ops;\r\ndev->ethtool_ops = &macvlan_ethtool_ops;\r\n}\r\nstatic void macvlan_setup(struct net_device *dev)\r\n{\r\nmacvlan_common_setup(dev);\r\ndev->tx_queue_len = 0;\r\n}\r\nstatic int macvlan_port_create(struct net_device *dev)\r\n{\r\nstruct macvlan_port *port;\r\nunsigned int i;\r\nint err;\r\nif (dev->type != ARPHRD_ETHER || dev->flags & IFF_LOOPBACK)\r\nreturn -EINVAL;\r\nif (netif_is_ipvlan_port(dev))\r\nreturn -EBUSY;\r\nport = kzalloc(sizeof(*port), GFP_KERNEL);\r\nif (port == NULL)\r\nreturn -ENOMEM;\r\nport->passthru = false;\r\nport->dev = dev;\r\nINIT_LIST_HEAD(&port->vlans);\r\nfor (i = 0; i < MACVLAN_HASH_SIZE; i++)\r\nINIT_HLIST_HEAD(&port->vlan_hash[i]);\r\nfor (i = 0; i < MACVLAN_HASH_SIZE; i++)\r\nINIT_HLIST_HEAD(&port->vlan_source_hash[i]);\r\nskb_queue_head_init(&port->bc_queue);\r\nINIT_WORK(&port->bc_work, macvlan_process_broadcast);\r\nerr = netdev_rx_handler_register(dev, macvlan_handle_frame, port);\r\nif (err)\r\nkfree(port);\r\nelse\r\ndev->priv_flags |= IFF_MACVLAN_PORT;\r\nreturn err;\r\n}\r\nstatic void macvlan_port_destroy(struct net_device *dev)\r\n{\r\nstruct macvlan_port *port = macvlan_port_get_rtnl(dev);\r\ndev->priv_flags &= ~IFF_MACVLAN_PORT;\r\nnetdev_rx_handler_unregister(dev);\r\ncancel_work_sync(&port->bc_work);\r\n__skb_queue_purge(&port->bc_queue);\r\nkfree_rcu(port, rcu);\r\n}\r\nstatic int macvlan_validate(struct nlattr *tb[], struct nlattr *data[])\r\n{\r\nif (tb[IFLA_ADDRESS]) {\r\nif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)\r\nreturn -EINVAL;\r\nif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS])))\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nif (data && data[IFLA_MACVLAN_FLAGS] &&\r\nnla_get_u16(data[IFLA_MACVLAN_FLAGS]) & ~MACVLAN_FLAG_NOPROMISC)\r\nreturn -EINVAL;\r\nif (data && data[IFLA_MACVLAN_MODE]) {\r\nswitch (nla_get_u32(data[IFLA_MACVLAN_MODE])) {\r\ncase MACVLAN_MODE_PRIVATE:\r\ncase MACVLAN_MODE_VEPA:\r\ncase MACVLAN_MODE_BRIDGE:\r\ncase MACVLAN_MODE_PASSTHRU:\r\ncase MACVLAN_MODE_SOURCE:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (data && data[IFLA_MACVLAN_MACADDR_MODE]) {\r\nswitch (nla_get_u32(data[IFLA_MACVLAN_MACADDR_MODE])) {\r\ncase MACVLAN_MACADDR_ADD:\r\ncase MACVLAN_MACADDR_DEL:\r\ncase MACVLAN_MACADDR_FLUSH:\r\ncase MACVLAN_MACADDR_SET:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (data && data[IFLA_MACVLAN_MACADDR]) {\r\nif (nla_len(data[IFLA_MACVLAN_MACADDR]) != ETH_ALEN)\r\nreturn -EINVAL;\r\nif (!is_valid_ether_addr(nla_data(data[IFLA_MACVLAN_MACADDR])))\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nif (data && data[IFLA_MACVLAN_MACADDR_COUNT])\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int macvlan_changelink_sources(struct macvlan_dev *vlan, u32 mode,\r\nstruct nlattr *data[])\r\n{\r\nchar *addr = NULL;\r\nint ret, rem, len;\r\nstruct nlattr *nla, *head;\r\nstruct macvlan_source_entry *entry;\r\nif (data[IFLA_MACVLAN_MACADDR])\r\naddr = nla_data(data[IFLA_MACVLAN_MACADDR]);\r\nif (mode == MACVLAN_MACADDR_ADD) {\r\nif (!addr)\r\nreturn -EINVAL;\r\nreturn macvlan_hash_add_source(vlan, addr);\r\n} else if (mode == MACVLAN_MACADDR_DEL) {\r\nif (!addr)\r\nreturn -EINVAL;\r\nentry = macvlan_hash_lookup_source(vlan, addr);\r\nif (entry) {\r\nmacvlan_hash_del_source(entry);\r\nvlan->macaddr_count--;\r\n}\r\n} else if (mode == MACVLAN_MACADDR_FLUSH) {\r\nmacvlan_flush_sources(vlan->port, vlan);\r\n} else if (mode == MACVLAN_MACADDR_SET) {\r\nmacvlan_flush_sources(vlan->port, vlan);\r\nif (addr) {\r\nret = macvlan_hash_add_source(vlan, addr);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (!data || !data[IFLA_MACVLAN_MACADDR_DATA])\r\nreturn 0;\r\nhead = nla_data(data[IFLA_MACVLAN_MACADDR_DATA]);\r\nlen = nla_len(data[IFLA_MACVLAN_MACADDR_DATA]);\r\nnla_for_each_attr(nla, head, len, rem) {\r\nif (nla_type(nla) != IFLA_MACVLAN_MACADDR ||\r\nnla_len(nla) != ETH_ALEN)\r\ncontinue;\r\naddr = nla_data(nla);\r\nret = macvlan_hash_add_source(vlan, addr);\r\nif (ret)\r\nreturn ret;\r\n}\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint macvlan_common_newlink(struct net *src_net, struct net_device *dev,\r\nstruct nlattr *tb[], struct nlattr *data[])\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nstruct macvlan_port *port;\r\nstruct net_device *lowerdev;\r\nint err;\r\nint macmode;\r\nif (!tb[IFLA_LINK])\r\nreturn -EINVAL;\r\nlowerdev = __dev_get_by_index(src_net, nla_get_u32(tb[IFLA_LINK]));\r\nif (lowerdev == NULL)\r\nreturn -ENODEV;\r\nif (netif_is_macvlan(lowerdev))\r\nlowerdev = macvlan_dev_real_dev(lowerdev);\r\nif (!tb[IFLA_MTU])\r\ndev->mtu = lowerdev->mtu;\r\nelse if (dev->mtu > lowerdev->mtu)\r\nreturn -EINVAL;\r\nif (!tb[IFLA_ADDRESS])\r\neth_hw_addr_random(dev);\r\nif (!macvlan_port_exists(lowerdev)) {\r\nerr = macvlan_port_create(lowerdev);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nport = macvlan_port_get_rtnl(lowerdev);\r\nif (port->passthru)\r\nreturn -EINVAL;\r\nvlan->lowerdev = lowerdev;\r\nvlan->dev = dev;\r\nvlan->port = port;\r\nvlan->set_features = MACVLAN_FEATURES;\r\nvlan->nest_level = dev_get_nest_level(lowerdev, netif_is_macvlan) + 1;\r\nvlan->mode = MACVLAN_MODE_VEPA;\r\nif (data && data[IFLA_MACVLAN_MODE])\r\nvlan->mode = nla_get_u32(data[IFLA_MACVLAN_MODE]);\r\nif (data && data[IFLA_MACVLAN_FLAGS])\r\nvlan->flags = nla_get_u16(data[IFLA_MACVLAN_FLAGS]);\r\nif (vlan->mode == MACVLAN_MODE_PASSTHRU) {\r\nif (port->count)\r\nreturn -EINVAL;\r\nport->passthru = true;\r\neth_hw_addr_inherit(dev, lowerdev);\r\n}\r\nif (data && data[IFLA_MACVLAN_MACADDR_MODE]) {\r\nif (vlan->mode != MACVLAN_MODE_SOURCE)\r\nreturn -EINVAL;\r\nmacmode = nla_get_u32(data[IFLA_MACVLAN_MACADDR_MODE]);\r\nerr = macvlan_changelink_sources(vlan, macmode, data);\r\nif (err)\r\nreturn err;\r\n}\r\nport->count += 1;\r\nerr = register_netdevice(dev);\r\nif (err < 0)\r\ngoto destroy_port;\r\ndev->priv_flags |= IFF_MACVLAN;\r\nerr = netdev_upper_dev_link(lowerdev, dev);\r\nif (err)\r\ngoto unregister_netdev;\r\nlist_add_tail_rcu(&vlan->list, &port->vlans);\r\nnetif_stacked_transfer_operstate(lowerdev, dev);\r\nreturn 0;\r\nunregister_netdev:\r\nunregister_netdevice(dev);\r\ndestroy_port:\r\nport->count -= 1;\r\nif (!port->count)\r\nmacvlan_port_destroy(lowerdev);\r\nreturn err;\r\n}\r\nstatic int macvlan_newlink(struct net *src_net, struct net_device *dev,\r\nstruct nlattr *tb[], struct nlattr *data[])\r\n{\r\nreturn macvlan_common_newlink(src_net, dev, tb, data);\r\n}\r\nvoid macvlan_dellink(struct net_device *dev, struct list_head *head)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nif (vlan->mode == MACVLAN_MODE_SOURCE)\r\nmacvlan_flush_sources(vlan->port, vlan);\r\nlist_del_rcu(&vlan->list);\r\nunregister_netdevice_queue(dev, head);\r\nnetdev_upper_dev_unlink(vlan->lowerdev, dev);\r\n}\r\nstatic int macvlan_changelink(struct net_device *dev,\r\nstruct nlattr *tb[], struct nlattr *data[])\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nenum macvlan_mode mode;\r\nbool set_mode = false;\r\nenum macvlan_macaddr_mode macmode;\r\nint ret;\r\nif (data && data[IFLA_MACVLAN_MODE]) {\r\nset_mode = true;\r\nmode = nla_get_u32(data[IFLA_MACVLAN_MODE]);\r\nif ((mode == MACVLAN_MODE_PASSTHRU) !=\r\n(vlan->mode == MACVLAN_MODE_PASSTHRU))\r\nreturn -EINVAL;\r\nif (vlan->mode == MACVLAN_MODE_SOURCE &&\r\nvlan->mode != mode)\r\nmacvlan_flush_sources(vlan->port, vlan);\r\n}\r\nif (data && data[IFLA_MACVLAN_FLAGS]) {\r\n__u16 flags = nla_get_u16(data[IFLA_MACVLAN_FLAGS]);\r\nbool promisc = (flags ^ vlan->flags) & MACVLAN_FLAG_NOPROMISC;\r\nif (vlan->port->passthru && promisc) {\r\nint err;\r\nif (flags & MACVLAN_FLAG_NOPROMISC)\r\nerr = dev_set_promiscuity(vlan->lowerdev, -1);\r\nelse\r\nerr = dev_set_promiscuity(vlan->lowerdev, 1);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nvlan->flags = flags;\r\n}\r\nif (set_mode)\r\nvlan->mode = mode;\r\nif (data && data[IFLA_MACVLAN_MACADDR_MODE]) {\r\nif (vlan->mode != MACVLAN_MODE_SOURCE)\r\nreturn -EINVAL;\r\nmacmode = nla_get_u32(data[IFLA_MACVLAN_MACADDR_MODE]);\r\nret = macvlan_changelink_sources(vlan, macmode, data);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic size_t macvlan_get_size_mac(const struct macvlan_dev *vlan)\r\n{\r\nif (vlan->macaddr_count == 0)\r\nreturn 0;\r\nreturn nla_total_size(0)\r\n+ vlan->macaddr_count * nla_total_size(sizeof(u8) * ETH_ALEN);\r\n}\r\nstatic size_t macvlan_get_size(const struct net_device *dev)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nreturn (0\r\n+ nla_total_size(4)\r\n+ nla_total_size(2)\r\n+ nla_total_size(4)\r\n+ macvlan_get_size_mac(vlan)\r\n);\r\n}\r\nstatic int macvlan_fill_info_macaddr(struct sk_buff *skb,\r\nconst struct macvlan_dev *vlan,\r\nconst int i)\r\n{\r\nstruct hlist_head *h = &vlan->port->vlan_source_hash[i];\r\nstruct macvlan_source_entry *entry;\r\nhlist_for_each_entry_rcu(entry, h, hlist) {\r\nif (entry->vlan != vlan)\r\ncontinue;\r\nif (nla_put(skb, IFLA_MACVLAN_MACADDR, ETH_ALEN, entry->addr))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int macvlan_fill_info(struct sk_buff *skb,\r\nconst struct net_device *dev)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nint i;\r\nstruct nlattr *nest;\r\nif (nla_put_u32(skb, IFLA_MACVLAN_MODE, vlan->mode))\r\ngoto nla_put_failure;\r\nif (nla_put_u16(skb, IFLA_MACVLAN_FLAGS, vlan->flags))\r\ngoto nla_put_failure;\r\nif (nla_put_u32(skb, IFLA_MACVLAN_MACADDR_COUNT, vlan->macaddr_count))\r\ngoto nla_put_failure;\r\nif (vlan->macaddr_count > 0) {\r\nnest = nla_nest_start(skb, IFLA_MACVLAN_MACADDR_DATA);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nfor (i = 0; i < MACVLAN_HASH_SIZE; i++) {\r\nif (macvlan_fill_info_macaddr(skb, vlan, i))\r\ngoto nla_put_failure;\r\n}\r\nnla_nest_end(skb, nest);\r\n}\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nint macvlan_link_register(struct rtnl_link_ops *ops)\r\n{\r\nops->priv_size = sizeof(struct macvlan_dev);\r\nops->validate = macvlan_validate;\r\nops->maxtype = IFLA_MACVLAN_MAX;\r\nops->policy = macvlan_policy;\r\nops->changelink = macvlan_changelink;\r\nops->get_size = macvlan_get_size;\r\nops->fill_info = macvlan_fill_info;\r\nreturn rtnl_link_register(ops);\r\n}\r\nstatic struct net *macvlan_get_link_net(const struct net_device *dev)\r\n{\r\nreturn dev_net(macvlan_dev_real_dev(dev));\r\n}\r\nstatic int macvlan_device_event(struct notifier_block *unused,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct macvlan_dev *vlan, *next;\r\nstruct macvlan_port *port;\r\nLIST_HEAD(list_kill);\r\nif (!macvlan_port_exists(dev))\r\nreturn NOTIFY_DONE;\r\nport = macvlan_port_get_rtnl(dev);\r\nswitch (event) {\r\ncase NETDEV_CHANGE:\r\nlist_for_each_entry(vlan, &port->vlans, list)\r\nnetif_stacked_transfer_operstate(vlan->lowerdev,\r\nvlan->dev);\r\nbreak;\r\ncase NETDEV_FEAT_CHANGE:\r\nlist_for_each_entry(vlan, &port->vlans, list) {\r\nvlan->dev->gso_max_size = dev->gso_max_size;\r\nnetdev_update_features(vlan->dev);\r\n}\r\nbreak;\r\ncase NETDEV_CHANGEMTU:\r\nlist_for_each_entry(vlan, &port->vlans, list) {\r\nif (vlan->dev->mtu <= dev->mtu)\r\ncontinue;\r\ndev_set_mtu(vlan->dev, dev->mtu);\r\n}\r\nbreak;\r\ncase NETDEV_CHANGEADDR:\r\nif (!port->passthru)\r\nreturn NOTIFY_DONE;\r\nvlan = list_first_entry_or_null(&port->vlans,\r\nstruct macvlan_dev,\r\nlist);\r\nif (macvlan_sync_address(vlan->dev, dev->dev_addr))\r\nreturn NOTIFY_BAD;\r\nbreak;\r\ncase NETDEV_UNREGISTER:\r\nif (dev->reg_state != NETREG_UNREGISTERING)\r\nbreak;\r\nlist_for_each_entry_safe(vlan, next, &port->vlans, list)\r\nvlan->dev->rtnl_link_ops->dellink(vlan->dev, &list_kill);\r\nunregister_netdevice_many(&list_kill);\r\nbreak;\r\ncase NETDEV_PRE_TYPE_CHANGE:\r\nreturn NOTIFY_BAD;\r\ncase NETDEV_NOTIFY_PEERS:\r\ncase NETDEV_BONDING_FAILOVER:\r\ncase NETDEV_RESEND_IGMP:\r\nlist_for_each_entry(vlan, &port->vlans, list)\r\ncall_netdevice_notifiers(event, vlan->dev);\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __init macvlan_init_module(void)\r\n{\r\nint err;\r\nregister_netdevice_notifier(&macvlan_notifier_block);\r\nerr = macvlan_link_register(&macvlan_link_ops);\r\nif (err < 0)\r\ngoto err1;\r\nreturn 0;\r\nerr1:\r\nunregister_netdevice_notifier(&macvlan_notifier_block);\r\nreturn err;\r\n}\r\nstatic void __exit macvlan_cleanup_module(void)\r\n{\r\nrtnl_link_unregister(&macvlan_link_ops);\r\nunregister_netdevice_notifier(&macvlan_notifier_block);\r\n}
