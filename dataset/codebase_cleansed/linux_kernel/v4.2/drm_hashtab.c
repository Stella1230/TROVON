int drm_ht_create(struct drm_open_hash *ht, unsigned int order)\r\n{\r\nunsigned int size = 1 << order;\r\nht->order = order;\r\nht->table = NULL;\r\nif (size <= PAGE_SIZE / sizeof(*ht->table))\r\nht->table = kcalloc(size, sizeof(*ht->table), GFP_KERNEL);\r\nelse\r\nht->table = vzalloc(size*sizeof(*ht->table));\r\nif (!ht->table) {\r\nDRM_ERROR("Out of memory for hash table\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid drm_ht_verbose_list(struct drm_open_hash *ht, unsigned long key)\r\n{\r\nstruct drm_hash_item *entry;\r\nstruct hlist_head *h_list;\r\nunsigned int hashed_key;\r\nint count = 0;\r\nhashed_key = hash_long(key, ht->order);\r\nDRM_DEBUG("Key is 0x%08lx, Hashed key is 0x%08x\n", key, hashed_key);\r\nh_list = &ht->table[hashed_key];\r\nhlist_for_each_entry(entry, h_list, head)\r\nDRM_DEBUG("count %d, key: 0x%08lx\n", count++, entry->key);\r\n}\r\nstatic struct hlist_node *drm_ht_find_key(struct drm_open_hash *ht,\r\nunsigned long key)\r\n{\r\nstruct drm_hash_item *entry;\r\nstruct hlist_head *h_list;\r\nunsigned int hashed_key;\r\nhashed_key = hash_long(key, ht->order);\r\nh_list = &ht->table[hashed_key];\r\nhlist_for_each_entry(entry, h_list, head) {\r\nif (entry->key == key)\r\nreturn &entry->head;\r\nif (entry->key > key)\r\nbreak;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct hlist_node *drm_ht_find_key_rcu(struct drm_open_hash *ht,\r\nunsigned long key)\r\n{\r\nstruct drm_hash_item *entry;\r\nstruct hlist_head *h_list;\r\nunsigned int hashed_key;\r\nhashed_key = hash_long(key, ht->order);\r\nh_list = &ht->table[hashed_key];\r\nhlist_for_each_entry_rcu(entry, h_list, head) {\r\nif (entry->key == key)\r\nreturn &entry->head;\r\nif (entry->key > key)\r\nbreak;\r\n}\r\nreturn NULL;\r\n}\r\nint drm_ht_insert_item(struct drm_open_hash *ht, struct drm_hash_item *item)\r\n{\r\nstruct drm_hash_item *entry;\r\nstruct hlist_head *h_list;\r\nstruct hlist_node *parent;\r\nunsigned int hashed_key;\r\nunsigned long key = item->key;\r\nhashed_key = hash_long(key, ht->order);\r\nh_list = &ht->table[hashed_key];\r\nparent = NULL;\r\nhlist_for_each_entry(entry, h_list, head) {\r\nif (entry->key == key)\r\nreturn -EINVAL;\r\nif (entry->key > key)\r\nbreak;\r\nparent = &entry->head;\r\n}\r\nif (parent) {\r\nhlist_add_behind_rcu(&item->head, parent);\r\n} else {\r\nhlist_add_head_rcu(&item->head, h_list);\r\n}\r\nreturn 0;\r\n}\r\nint drm_ht_just_insert_please(struct drm_open_hash *ht, struct drm_hash_item *item,\r\nunsigned long seed, int bits, int shift,\r\nunsigned long add)\r\n{\r\nint ret;\r\nunsigned long mask = (1 << bits) - 1;\r\nunsigned long first, unshifted_key;\r\nunshifted_key = hash_long(seed, bits);\r\nfirst = unshifted_key;\r\ndo {\r\nitem->key = (unshifted_key << shift) + add;\r\nret = drm_ht_insert_item(ht, item);\r\nif (ret)\r\nunshifted_key = (unshifted_key + 1) & mask;\r\n} while(ret && (unshifted_key != first));\r\nif (ret) {\r\nDRM_ERROR("Available key bit space exhausted\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint drm_ht_find_item(struct drm_open_hash *ht, unsigned long key,\r\nstruct drm_hash_item **item)\r\n{\r\nstruct hlist_node *list;\r\nlist = drm_ht_find_key_rcu(ht, key);\r\nif (!list)\r\nreturn -EINVAL;\r\n*item = hlist_entry(list, struct drm_hash_item, head);\r\nreturn 0;\r\n}\r\nint drm_ht_remove_key(struct drm_open_hash *ht, unsigned long key)\r\n{\r\nstruct hlist_node *list;\r\nlist = drm_ht_find_key(ht, key);\r\nif (list) {\r\nhlist_del_init_rcu(list);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint drm_ht_remove_item(struct drm_open_hash *ht, struct drm_hash_item *item)\r\n{\r\nhlist_del_init_rcu(&item->head);\r\nreturn 0;\r\n}\r\nvoid drm_ht_remove(struct drm_open_hash *ht)\r\n{\r\nif (ht->table) {\r\nif ((PAGE_SIZE / sizeof(*ht->table)) >> ht->order)\r\nkfree(ht->table);\r\nelse\r\nvfree(ht->table);\r\nht->table = NULL;\r\n}\r\n}
