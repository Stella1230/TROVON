void\r\nnvkm_falcon_intr(struct nvkm_subdev *subdev)\r\n{\r\nstruct nvkm_falcon *falcon = (void *)subdev;\r\nu32 dispatch = nv_ro32(falcon, 0x01c);\r\nu32 intr = nv_ro32(falcon, 0x008) & dispatch & ~(dispatch >> 16);\r\nif (intr & 0x00000010) {\r\nnv_debug(falcon, "ucode halted\n");\r\nnv_wo32(falcon, 0x004, 0x00000010);\r\nintr &= ~0x00000010;\r\n}\r\nif (intr) {\r\nnv_error(falcon, "unhandled intr 0x%08x\n", intr);\r\nnv_wo32(falcon, 0x004, intr);\r\n}\r\n}\r\nu32\r\n_nvkm_falcon_rd32(struct nvkm_object *object, u64 addr)\r\n{\r\nstruct nvkm_falcon *falcon = (void *)object;\r\nreturn nv_rd32(falcon, falcon->addr + addr);\r\n}\r\nvoid\r\n_nvkm_falcon_wr32(struct nvkm_object *object, u64 addr, u32 data)\r\n{\r\nstruct nvkm_falcon *falcon = (void *)object;\r\nnv_wr32(falcon, falcon->addr + addr, data);\r\n}\r\nstatic void *\r\nvmemdup(const void *src, size_t len)\r\n{\r\nvoid *p = vmalloc(len);\r\nif (p)\r\nmemcpy(p, src, len);\r\nreturn p;\r\n}\r\nint\r\n_nvkm_falcon_init(struct nvkm_object *object)\r\n{\r\nstruct nvkm_device *device = nv_device(object);\r\nstruct nvkm_falcon *falcon = (void *)object;\r\nconst struct firmware *fw;\r\nchar name[32] = "internal";\r\nint ret, i;\r\nu32 caps;\r\nret = nvkm_engine_init(&falcon->base);\r\nif (ret)\r\nreturn ret;\r\nif (device->chipset < 0xa3 ||\r\ndevice->chipset == 0xaa || device->chipset == 0xac) {\r\nfalcon->version = 0;\r\nfalcon->secret = (falcon->addr == 0x087000) ? 1 : 0;\r\n} else {\r\ncaps = nv_ro32(falcon, 0x12c);\r\nfalcon->version = (caps & 0x0000000f);\r\nfalcon->secret = (caps & 0x00000030) >> 4;\r\n}\r\ncaps = nv_ro32(falcon, 0x108);\r\nfalcon->code.limit = (caps & 0x000001ff) << 8;\r\nfalcon->data.limit = (caps & 0x0003fe00) >> 1;\r\nnv_debug(falcon, "falcon version: %d\n", falcon->version);\r\nnv_debug(falcon, "secret level: %d\n", falcon->secret);\r\nnv_debug(falcon, "code limit: %d\n", falcon->code.limit);\r\nnv_debug(falcon, "data limit: %d\n", falcon->data.limit);\r\nif (falcon->secret && falcon->version < 4) {\r\nif (!falcon->version)\r\nnv_wait(falcon, 0x008, 0x00000010, 0x00000010);\r\nelse\r\nnv_wait(falcon, 0x180, 0x80000000, 0);\r\nnv_wo32(falcon, 0x004, 0x00000010);\r\n}\r\nnv_wo32(falcon, 0x014, 0xffffffff);\r\nif (!falcon->code.data) {\r\nsnprintf(name, sizeof(name), "nouveau/nv%02x_fuc%03x",\r\ndevice->chipset, falcon->addr >> 12);\r\nret = request_firmware(&fw, name, nv_device_base(device));\r\nif (ret == 0) {\r\nfalcon->code.data = vmemdup(fw->data, fw->size);\r\nfalcon->code.size = fw->size;\r\nfalcon->data.data = NULL;\r\nfalcon->data.size = 0;\r\nrelease_firmware(fw);\r\n}\r\nfalcon->external = true;\r\n}\r\nif (!falcon->code.data) {\r\nsnprintf(name, sizeof(name), "nouveau/nv%02x_fuc%03xd",\r\ndevice->chipset, falcon->addr >> 12);\r\nret = request_firmware(&fw, name, nv_device_base(device));\r\nif (ret) {\r\nnv_error(falcon, "unable to load firmware data\n");\r\nreturn ret;\r\n}\r\nfalcon->data.data = vmemdup(fw->data, fw->size);\r\nfalcon->data.size = fw->size;\r\nrelease_firmware(fw);\r\nif (!falcon->data.data)\r\nreturn -ENOMEM;\r\nsnprintf(name, sizeof(name), "nouveau/nv%02x_fuc%03xc",\r\ndevice->chipset, falcon->addr >> 12);\r\nret = request_firmware(&fw, name, nv_device_base(device));\r\nif (ret) {\r\nnv_error(falcon, "unable to load firmware code\n");\r\nreturn ret;\r\n}\r\nfalcon->code.data = vmemdup(fw->data, fw->size);\r\nfalcon->code.size = fw->size;\r\nrelease_firmware(fw);\r\nif (!falcon->code.data)\r\nreturn -ENOMEM;\r\n}\r\nnv_debug(falcon, "firmware: %s (%s)\n", name, falcon->data.data ?\r\n"static code/data segments" : "self-bootstrapping");\r\nif (!falcon->data.data && !falcon->core) {\r\nret = nvkm_gpuobj_new(object->parent, NULL, falcon->code.size,\r\n256, 0, &falcon->core);\r\nif (ret) {\r\nnv_error(falcon, "core allocation failed, %d\n", ret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < falcon->code.size; i += 4)\r\nnv_wo32(falcon->core, i, falcon->code.data[i / 4]);\r\n}\r\nif (falcon->core) {\r\nif (device->card_type < NV_C0)\r\nnv_wo32(falcon, 0x618, 0x04000000);\r\nelse\r\nnv_wo32(falcon, 0x618, 0x00000114);\r\nnv_wo32(falcon, 0x11c, 0);\r\nnv_wo32(falcon, 0x110, falcon->core->addr >> 8);\r\nnv_wo32(falcon, 0x114, 0);\r\nnv_wo32(falcon, 0x118, 0x00006610);\r\n} else {\r\nif (falcon->code.size > falcon->code.limit ||\r\nfalcon->data.size > falcon->data.limit) {\r\nnv_error(falcon, "ucode exceeds falcon limit(s)\n");\r\nreturn -EINVAL;\r\n}\r\nif (falcon->version < 3) {\r\nnv_wo32(falcon, 0xff8, 0x00100000);\r\nfor (i = 0; i < falcon->code.size / 4; i++)\r\nnv_wo32(falcon, 0xff4, falcon->code.data[i]);\r\n} else {\r\nnv_wo32(falcon, 0x180, 0x01000000);\r\nfor (i = 0; i < falcon->code.size / 4; i++) {\r\nif ((i & 0x3f) == 0)\r\nnv_wo32(falcon, 0x188, i >> 6);\r\nnv_wo32(falcon, 0x184, falcon->code.data[i]);\r\n}\r\n}\r\n}\r\nif (falcon->version < 3) {\r\nnv_wo32(falcon, 0xff8, 0x00000000);\r\nfor (i = 0; !falcon->core && i < falcon->data.size / 4; i++)\r\nnv_wo32(falcon, 0xff4, falcon->data.data[i]);\r\nfor (; i < falcon->data.limit; i += 4)\r\nnv_wo32(falcon, 0xff4, 0x00000000);\r\n} else {\r\nnv_wo32(falcon, 0x1c0, 0x01000000);\r\nfor (i = 0; !falcon->core && i < falcon->data.size / 4; i++)\r\nnv_wo32(falcon, 0x1c4, falcon->data.data[i]);\r\nfor (; i < falcon->data.limit / 4; i++)\r\nnv_wo32(falcon, 0x1c4, 0x00000000);\r\n}\r\nnv_wo32(falcon, 0x10c, 0x00000001);\r\nnv_wo32(falcon, 0x104, 0x00000000);\r\nnv_wo32(falcon, 0x100, 0x00000002);\r\nnv_wo32(falcon, 0x048, 0x00000003);\r\nreturn 0;\r\n}\r\nint\r\n_nvkm_falcon_fini(struct nvkm_object *object, bool suspend)\r\n{\r\nstruct nvkm_falcon *falcon = (void *)object;\r\nif (!suspend) {\r\nnvkm_gpuobj_ref(NULL, &falcon->core);\r\nif (falcon->external) {\r\nvfree(falcon->data.data);\r\nvfree(falcon->code.data);\r\nfalcon->code.data = NULL;\r\n}\r\n}\r\nnv_mo32(falcon, 0x048, 0x00000003, 0x00000000);\r\nnv_wo32(falcon, 0x014, 0xffffffff);\r\nreturn nvkm_engine_fini(&falcon->base, suspend);\r\n}\r\nint\r\nnvkm_falcon_create_(struct nvkm_object *parent, struct nvkm_object *engine,\r\nstruct nvkm_oclass *oclass, u32 addr, bool enable,\r\nconst char *iname, const char *fname,\r\nint length, void **pobject)\r\n{\r\nstruct nvkm_falcon *falcon;\r\nint ret;\r\nret = nvkm_engine_create_(parent, engine, oclass, enable, iname,\r\nfname, length, pobject);\r\nfalcon = *pobject;\r\nif (ret)\r\nreturn ret;\r\nfalcon->addr = addr;\r\nreturn 0;\r\n}
