static inline int fcc_cr_cmd(struct fs_enet_private *fep, u32 op)\r\n{\r\nconst struct fs_platform_info *fpi = fep->fpi;\r\nreturn cpm_command(fpi->cp_command, op);\r\n}\r\nstatic int do_pd_setup(struct fs_enet_private *fep)\r\n{\r\nstruct platform_device *ofdev = to_platform_device(fep->dev);\r\nstruct fs_platform_info *fpi = fep->fpi;\r\nint ret = -EINVAL;\r\nfep->interrupt = irq_of_parse_and_map(ofdev->dev.of_node, 0);\r\nif (fep->interrupt == NO_IRQ)\r\ngoto out;\r\nfep->fcc.fccp = of_iomap(ofdev->dev.of_node, 0);\r\nif (!fep->fcc.fccp)\r\ngoto out;\r\nfep->fcc.ep = of_iomap(ofdev->dev.of_node, 1);\r\nif (!fep->fcc.ep)\r\ngoto out_fccp;\r\nfep->fcc.fcccp = of_iomap(ofdev->dev.of_node, 2);\r\nif (!fep->fcc.fcccp)\r\ngoto out_ep;\r\nfep->fcc.mem = (void __iomem *)cpm2_immr;\r\nfpi->dpram_offset = cpm_dpalloc(128, 32);\r\nif (IS_ERR_VALUE(fpi->dpram_offset)) {\r\nret = fpi->dpram_offset;\r\ngoto out_fcccp;\r\n}\r\nreturn 0;\r\nout_fcccp:\r\niounmap(fep->fcc.fcccp);\r\nout_ep:\r\niounmap(fep->fcc.ep);\r\nout_fccp:\r\niounmap(fep->fcc.fccp);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int setup_data(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nif (do_pd_setup(fep) != 0)\r\nreturn -EINVAL;\r\nfep->ev_napi_rx = FCC_NAPI_RX_EVENT_MSK;\r\nfep->ev_napi_tx = FCC_NAPI_TX_EVENT_MSK;\r\nfep->ev_rx = FCC_RX_EVENT;\r\nfep->ev_tx = FCC_TX_EVENT;\r\nfep->ev_err = FCC_ERR_EVENT_MSK;\r\nreturn 0;\r\n}\r\nstatic int allocate_bd(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nconst struct fs_platform_info *fpi = fep->fpi;\r\nfep->ring_base = (void __iomem __force *)dma_alloc_coherent(fep->dev,\r\n(fpi->tx_ring + fpi->rx_ring) *\r\nsizeof(cbd_t), &fep->ring_mem_addr,\r\nGFP_KERNEL);\r\nif (fep->ring_base == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void free_bd(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nconst struct fs_platform_info *fpi = fep->fpi;\r\nif (fep->ring_base)\r\ndma_free_coherent(fep->dev,\r\n(fpi->tx_ring + fpi->rx_ring) * sizeof(cbd_t),\r\n(void __force *)fep->ring_base, fep->ring_mem_addr);\r\n}\r\nstatic void cleanup_data(struct net_device *dev)\r\n{\r\n}\r\nstatic void set_promiscuous_mode(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nfcc_t __iomem *fccp = fep->fcc.fccp;\r\nS32(fccp, fcc_fpsmr, FCC_PSMR_PRO);\r\n}\r\nstatic void set_multicast_start(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nfcc_enet_t __iomem *ep = fep->fcc.ep;\r\nW32(ep, fen_gaddrh, 0);\r\nW32(ep, fen_gaddrl, 0);\r\n}\r\nstatic void set_multicast_one(struct net_device *dev, const u8 *mac)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nfcc_enet_t __iomem *ep = fep->fcc.ep;\r\nu16 taddrh, taddrm, taddrl;\r\ntaddrh = ((u16)mac[5] << 8) | mac[4];\r\ntaddrm = ((u16)mac[3] << 8) | mac[2];\r\ntaddrl = ((u16)mac[1] << 8) | mac[0];\r\nW16(ep, fen_taddrh, taddrh);\r\nW16(ep, fen_taddrm, taddrm);\r\nW16(ep, fen_taddrl, taddrl);\r\nfcc_cr_cmd(fep, CPM_CR_SET_GADDR);\r\n}\r\nstatic void set_multicast_finish(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nfcc_t __iomem *fccp = fep->fcc.fccp;\r\nfcc_enet_t __iomem *ep = fep->fcc.ep;\r\nC32(fccp, fcc_fpsmr, FCC_PSMR_PRO);\r\nif ((dev->flags & IFF_ALLMULTI) != 0 ||\r\nnetdev_mc_count(dev) > FCC_MAX_MULTICAST_ADDRS) {\r\nW32(ep, fen_gaddrh, 0xffffffff);\r\nW32(ep, fen_gaddrl, 0xffffffff);\r\n}\r\nfep->fcc.gaddrh = R32(ep, fen_gaddrh);\r\nfep->fcc.gaddrl = R32(ep, fen_gaddrl);\r\n}\r\nstatic void set_multicast_list(struct net_device *dev)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nif ((dev->flags & IFF_PROMISC) == 0) {\r\nset_multicast_start(dev);\r\nnetdev_for_each_mc_addr(ha, dev)\r\nset_multicast_one(dev, ha->addr);\r\nset_multicast_finish(dev);\r\n} else\r\nset_promiscuous_mode(dev);\r\n}\r\nstatic void restart(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nconst struct fs_platform_info *fpi = fep->fpi;\r\nfcc_t __iomem *fccp = fep->fcc.fccp;\r\nfcc_c_t __iomem *fcccp = fep->fcc.fcccp;\r\nfcc_enet_t __iomem *ep = fep->fcc.ep;\r\ndma_addr_t rx_bd_base_phys, tx_bd_base_phys;\r\nu16 paddrh, paddrm, paddrl;\r\nconst unsigned char *mac;\r\nint i;\r\nC32(fccp, fcc_gfmr, FCC_GFMR_ENR | FCC_GFMR_ENT);\r\nfor (i = 0; i < sizeof(*ep); i++)\r\nout_8((u8 __iomem *)ep + i, 0);\r\nrx_bd_base_phys = fep->ring_mem_addr;\r\ntx_bd_base_phys = rx_bd_base_phys + sizeof(cbd_t) * fpi->rx_ring;\r\nW32(ep, fen_genfcc.fcc_rbase, rx_bd_base_phys);\r\nW32(ep, fen_genfcc.fcc_tbase, tx_bd_base_phys);\r\nW16(ep, fen_genfcc.fcc_mrblr, PKT_MAXBLR_SIZE);\r\nW32(ep, fen_genfcc.fcc_rstate, (CPMFCR_GBL | CPMFCR_EB) << 24);\r\nW32(ep, fen_genfcc.fcc_tstate, (CPMFCR_GBL | CPMFCR_EB) << 24);\r\nW16(ep, fen_genfcc.fcc_riptr, fpi->dpram_offset);\r\nW16(ep, fen_genfcc.fcc_tiptr, fpi->dpram_offset + 32);\r\nW16(ep, fen_padptr, fpi->dpram_offset + 64);\r\nmemset_io(fep->fcc.mem + fpi->dpram_offset + 64, 0x88, 32);\r\nW32(ep, fen_genfcc.fcc_rbptr, 0);\r\nW32(ep, fen_genfcc.fcc_tbptr, 0);\r\nW32(ep, fen_genfcc.fcc_rcrc, 0);\r\nW32(ep, fen_genfcc.fcc_tcrc, 0);\r\nW16(ep, fen_genfcc.fcc_res1, 0);\r\nW32(ep, fen_genfcc.fcc_res2, 0);\r\nW32(ep, fen_camptr, 0);\r\nW32(ep, fen_cmask, 0xdebb20e3);\r\nW32(ep, fen_cpres, 0xffffffff);\r\nW32(ep, fen_crcec, 0);\r\nW32(ep, fen_alec, 0);\r\nW32(ep, fen_disfc, 0);\r\nW16(ep, fen_retlim, 15);\r\nW16(ep, fen_pper, 0);\r\nW32(ep, fen_gaddrh, fep->fcc.gaddrh);\r\nW32(ep, fen_gaddrl, fep->fcc.gaddrh);\r\nW32(ep, fen_iaddrh, 0);\r\nW32(ep, fen_iaddrl, 0);\r\nW16(ep, fen_tfcstat, 0);\r\nW16(ep, fen_tfclen, 0);\r\nW32(ep, fen_tfcptr, 0);\r\nW16(ep, fen_mflr, PKT_MAXBUF_SIZE);\r\nW16(ep, fen_minflr, PKT_MINBUF_SIZE);\r\nmac = dev->dev_addr;\r\npaddrh = ((u16)mac[5] << 8) | mac[4];\r\npaddrm = ((u16)mac[3] << 8) | mac[2];\r\npaddrl = ((u16)mac[1] << 8) | mac[0];\r\nW16(ep, fen_paddrh, paddrh);\r\nW16(ep, fen_paddrm, paddrm);\r\nW16(ep, fen_paddrl, paddrl);\r\nW16(ep, fen_taddrh, 0);\r\nW16(ep, fen_taddrm, 0);\r\nW16(ep, fen_taddrl, 0);\r\nW16(ep, fen_maxd1, 1520);\r\nW16(ep, fen_maxd2, 1520);\r\nW32(ep, fen_octc, 0);\r\nW32(ep, fen_colc, 0);\r\nW32(ep, fen_broc, 0);\r\nW32(ep, fen_mulc, 0);\r\nW32(ep, fen_uspc, 0);\r\nW32(ep, fen_frgc, 0);\r\nW32(ep, fen_ospc, 0);\r\nW32(ep, fen_jbrc, 0);\r\nW32(ep, fen_p64c, 0);\r\nW32(ep, fen_p65c, 0);\r\nW32(ep, fen_p128c, 0);\r\nW32(ep, fen_p256c, 0);\r\nW32(ep, fen_p512c, 0);\r\nW32(ep, fen_p1024c, 0);\r\nW16(ep, fen_rfthr, 0);\r\nW16(ep, fen_rfcnt, 0);\r\nW16(ep, fen_cftype, 0);\r\nfs_init_bds(dev);\r\nif (fpi->use_rmii) {\r\nif (fep->phydev->speed == 100)\r\nC8(fcccp, fcc_gfemr, 0x20);\r\nelse\r\nS8(fcccp, fcc_gfemr, 0x20);\r\n}\r\nfcc_cr_cmd(fep, CPM_CR_INIT_TRX);\r\nW16(fccp, fcc_fcce, 0xffff);\r\nW16(fccp, fcc_fccm, FCC_ENET_TXE | FCC_ENET_RXF | FCC_ENET_TXB);\r\nW32(fccp, fcc_gfmr, FCC_GFMR_TCI | FCC_GFMR_MODE_ENET);\r\nW16(fccp, fcc_fdsr, 0xd555);\r\nW32(fccp, fcc_fpsmr, FCC_PSMR_ENCRC);\r\nif (fpi->use_rmii)\r\nS32(fccp, fcc_fpsmr, FCC_PSMR_RMII);\r\nif (fep->phydev->duplex)\r\nS32(fccp, fcc_fpsmr, FCC_PSMR_FDE | FCC_PSMR_LPB);\r\nelse\r\nC32(fccp, fcc_fpsmr, FCC_PSMR_FDE | FCC_PSMR_LPB);\r\nset_multicast_list(dev);\r\nS32(fccp, fcc_gfmr, FCC_GFMR_ENR | FCC_GFMR_ENT);\r\n}\r\nstatic void stop(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nfcc_t __iomem *fccp = fep->fcc.fccp;\r\nC32(fccp, fcc_gfmr, FCC_GFMR_ENR | FCC_GFMR_ENT);\r\nW16(fccp, fcc_fcce, 0xffff);\r\nW16(fccp, fcc_fccm, 0);\r\nfs_cleanup_bds(dev);\r\n}\r\nstatic void napi_clear_rx_event(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nfcc_t __iomem *fccp = fep->fcc.fccp;\r\nW16(fccp, fcc_fcce, FCC_NAPI_RX_EVENT_MSK);\r\n}\r\nstatic void napi_enable_rx(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nfcc_t __iomem *fccp = fep->fcc.fccp;\r\nS16(fccp, fcc_fccm, FCC_NAPI_RX_EVENT_MSK);\r\n}\r\nstatic void napi_disable_rx(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nfcc_t __iomem *fccp = fep->fcc.fccp;\r\nC16(fccp, fcc_fccm, FCC_NAPI_RX_EVENT_MSK);\r\n}\r\nstatic void napi_clear_tx_event(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nfcc_t __iomem *fccp = fep->fcc.fccp;\r\nW16(fccp, fcc_fcce, FCC_NAPI_TX_EVENT_MSK);\r\n}\r\nstatic void napi_enable_tx(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nfcc_t __iomem *fccp = fep->fcc.fccp;\r\nS16(fccp, fcc_fccm, FCC_NAPI_TX_EVENT_MSK);\r\n}\r\nstatic void napi_disable_tx(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nfcc_t __iomem *fccp = fep->fcc.fccp;\r\nC16(fccp, fcc_fccm, FCC_NAPI_TX_EVENT_MSK);\r\n}\r\nstatic void rx_bd_done(struct net_device *dev)\r\n{\r\n}\r\nstatic void tx_kickstart(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nfcc_t __iomem *fccp = fep->fcc.fccp;\r\nS16(fccp, fcc_ftodr, 0x8000);\r\n}\r\nstatic u32 get_int_events(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nfcc_t __iomem *fccp = fep->fcc.fccp;\r\nreturn (u32)R16(fccp, fcc_fcce);\r\n}\r\nstatic void clear_int_events(struct net_device *dev, u32 int_events)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nfcc_t __iomem *fccp = fep->fcc.fccp;\r\nW16(fccp, fcc_fcce, int_events & 0xffff);\r\n}\r\nstatic void ev_error(struct net_device *dev, u32 int_events)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\ndev_warn(fep->dev, "FS_ENET ERROR(s) 0x%x\n", int_events);\r\n}\r\nstatic int get_regs(struct net_device *dev, void *p, int *sizep)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nif (*sizep < sizeof(fcc_t) + sizeof(fcc_enet_t) + 1)\r\nreturn -EINVAL;\r\nmemcpy_fromio(p, fep->fcc.fccp, sizeof(fcc_t));\r\np = (char *)p + sizeof(fcc_t);\r\nmemcpy_fromio(p, fep->fcc.ep, sizeof(fcc_enet_t));\r\np = (char *)p + sizeof(fcc_enet_t);\r\nmemcpy_fromio(p, fep->fcc.fcccp, 1);\r\nreturn 0;\r\n}\r\nstatic int get_regs_len(struct net_device *dev)\r\n{\r\nreturn sizeof(fcc_t) + sizeof(fcc_enet_t) + 1;\r\n}\r\nstatic void tx_restart(struct net_device *dev)\r\n{\r\nstruct fs_enet_private *fep = netdev_priv(dev);\r\nfcc_t __iomem *fccp = fep->fcc.fccp;\r\nconst struct fs_platform_info *fpi = fep->fpi;\r\nfcc_enet_t __iomem *ep = fep->fcc.ep;\r\ncbd_t __iomem *curr_tbptr;\r\ncbd_t __iomem *recheck_bd;\r\ncbd_t __iomem *prev_bd;\r\ncbd_t __iomem *last_tx_bd;\r\nlast_tx_bd = fep->tx_bd_base + (fpi->tx_ring * sizeof(cbd_t));\r\nrecheck_bd = curr_tbptr = (cbd_t __iomem *)\r\n((R32(ep, fen_genfcc.fcc_tbptr) - fep->ring_mem_addr) +\r\nfep->ring_base);\r\nprev_bd = (recheck_bd == fep->tx_bd_base) ? last_tx_bd : recheck_bd - 1;\r\nwhile ((CBDR_SC(prev_bd) & BD_ENET_TX_READY) != 0) {\r\nrecheck_bd = prev_bd;\r\nprev_bd = (prev_bd == fep->tx_bd_base) ? last_tx_bd : prev_bd - 1;\r\nif (recheck_bd == curr_tbptr)\r\nbreak;\r\n}\r\nW32(ep, fen_genfcc.fcc_tbptr,\r\n(uint) (((void *)recheck_bd - fep->ring_base) +\r\nfep->ring_mem_addr));\r\nfep->dirty_tx = recheck_bd;\r\nC32(fccp, fcc_gfmr, FCC_GFMR_ENT);\r\nudelay(10);\r\nS32(fccp, fcc_gfmr, FCC_GFMR_ENT);\r\nfcc_cr_cmd(fep, CPM_CR_RESTART_TX);\r\n}
