static int dt282x_prep_ai_dma(struct comedi_device *dev, int dma_index, int n)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nstruct comedi_isadma *dma = devpriv->dma;\r\nstruct comedi_isadma_desc *desc = &dma->desc[dma_index];\r\nif (!devpriv->ntrig)\r\nreturn 0;\r\nif (n == 0)\r\nn = desc->maxsize;\r\nif (n > devpriv->ntrig * 2)\r\nn = devpriv->ntrig * 2;\r\ndevpriv->ntrig -= n / 2;\r\ndesc->size = n;\r\ncomedi_isadma_set_mode(desc, devpriv->dma_dir);\r\ncomedi_isadma_program(desc);\r\nreturn n;\r\n}\r\nstatic int dt282x_prep_ao_dma(struct comedi_device *dev, int dma_index, int n)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nstruct comedi_isadma *dma = devpriv->dma;\r\nstruct comedi_isadma_desc *desc = &dma->desc[dma_index];\r\ndesc->size = n;\r\ncomedi_isadma_set_mode(desc, devpriv->dma_dir);\r\ncomedi_isadma_program(desc);\r\nreturn n;\r\n}\r\nstatic void dt282x_disable_dma(struct comedi_device *dev)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nstruct comedi_isadma *dma = devpriv->dma;\r\nstruct comedi_isadma_desc *desc;\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\ndesc = &dma->desc[i];\r\ncomedi_isadma_disable(desc->chan);\r\n}\r\n}\r\nstatic unsigned int dt282x_ns_to_timer(unsigned int *ns, unsigned int flags)\r\n{\r\nunsigned int prescale, base, divider;\r\nfor (prescale = 0; prescale < 16; prescale++) {\r\nif (prescale == 1)\r\ncontinue;\r\nbase = 250 * (1 << prescale);\r\nswitch (flags & CMDF_ROUND_MASK) {\r\ncase CMDF_ROUND_NEAREST:\r\ndefault:\r\ndivider = (*ns + base / 2) / base;\r\nbreak;\r\ncase CMDF_ROUND_DOWN:\r\ndivider = (*ns) / base;\r\nbreak;\r\ncase CMDF_ROUND_UP:\r\ndivider = (*ns + base - 1) / base;\r\nbreak;\r\n}\r\nif (divider < 256) {\r\n*ns = divider * base;\r\nreturn (prescale << 8) | (255 - divider);\r\n}\r\n}\r\nbase = 250 * (1 << 15);\r\ndivider = 255;\r\n*ns = divider * base;\r\nreturn (15 << 8) | (255 - divider);\r\n}\r\nstatic void dt282x_munge(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned short *buf,\r\nunsigned int nbytes)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nunsigned int val;\r\nint i;\r\nif (nbytes % 2)\r\ndev_err(dev->class_dev,\r\n"bug! odd number of bytes from dma xfer\n");\r\nfor (i = 0; i < nbytes / 2; i++) {\r\nval = buf[i];\r\nval &= s->maxdata;\r\nif (devpriv->ad_2scomp)\r\nval = comedi_offset_munge(s, val);\r\nbuf[i] = val;\r\n}\r\n}\r\nstatic unsigned int dt282x_ao_setup_dma(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nint cur_dma)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nstruct comedi_isadma *dma = devpriv->dma;\r\nstruct comedi_isadma_desc *desc = &dma->desc[cur_dma];\r\nunsigned int nsamples = comedi_bytes_to_samples(s, desc->maxsize);\r\nunsigned int nbytes;\r\nnbytes = comedi_buf_read_samples(s, desc->virt_addr, nsamples);\r\nif (nbytes)\r\ndt282x_prep_ao_dma(dev, cur_dma, nbytes);\r\nelse\r\ndev_err(dev->class_dev, "AO underrun\n");\r\nreturn nbytes;\r\n}\r\nstatic void dt282x_ao_dma_interrupt(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nstruct comedi_isadma *dma = devpriv->dma;\r\nstruct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];\r\noutw(devpriv->supcsr | DT2821_SUPCSR_CLRDMADNE,\r\ndev->iobase + DT2821_SUPCSR_REG);\r\ncomedi_isadma_disable(desc->chan);\r\nif (!dt282x_ao_setup_dma(dev, s, dma->cur_dma))\r\ns->async->events |= COMEDI_CB_OVERFLOW;\r\ndma->cur_dma = 1 - dma->cur_dma;\r\n}\r\nstatic void dt282x_ai_dma_interrupt(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nstruct comedi_isadma *dma = devpriv->dma;\r\nstruct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];\r\nunsigned int nsamples = comedi_bytes_to_samples(s, desc->size);\r\nint ret;\r\noutw(devpriv->supcsr | DT2821_SUPCSR_CLRDMADNE,\r\ndev->iobase + DT2821_SUPCSR_REG);\r\ncomedi_isadma_disable(desc->chan);\r\ndt282x_munge(dev, s, desc->virt_addr, desc->size);\r\nret = comedi_buf_write_samples(s, desc->virt_addr, nsamples);\r\nif (ret != desc->size)\r\nreturn;\r\ndevpriv->nread -= nsamples;\r\nif (devpriv->nread < 0) {\r\ndev_info(dev->class_dev, "nread off by one\n");\r\ndevpriv->nread = 0;\r\n}\r\nif (!devpriv->nread) {\r\ns->async->events |= COMEDI_CB_EOA;\r\nreturn;\r\n}\r\n#if 0\r\nif (!devpriv->ntrig) {\r\ndevpriv->supcsr &= ~DT2821_SUPCSR_DDMA;\r\noutw(devpriv->supcsr, dev->iobase + DT2821_SUPCSR_REG);\r\n}\r\n#endif\r\ndt282x_prep_ai_dma(dev, dma->cur_dma, 0);\r\ndma->cur_dma = 1 - dma->cur_dma;\r\n}\r\nstatic irqreturn_t dt282x_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct dt282x_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_subdevice *s_ao = dev->write_subdev;\r\nunsigned int supcsr, adcsr, dacsr;\r\nint handled = 0;\r\nif (!dev->attached) {\r\ndev_err(dev->class_dev, "spurious interrupt\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nadcsr = inw(dev->iobase + DT2821_ADCSR_REG);\r\ndacsr = inw(dev->iobase + DT2821_DACSR_REG);\r\nsupcsr = inw(dev->iobase + DT2821_SUPCSR_REG);\r\nif (supcsr & DT2821_SUPCSR_DMAD) {\r\nif (devpriv->dma_dir == COMEDI_ISADMA_READ)\r\ndt282x_ai_dma_interrupt(dev, s);\r\nelse\r\ndt282x_ao_dma_interrupt(dev, s_ao);\r\nhandled = 1;\r\n}\r\nif (adcsr & DT2821_ADCSR_ADERR) {\r\nif (devpriv->nread != 0) {\r\ndev_err(dev->class_dev, "A/D error\n");\r\ns->async->events |= COMEDI_CB_ERROR;\r\n}\r\nhandled = 1;\r\n}\r\nif (dacsr & DT2821_DACSR_DAERR) {\r\ndev_err(dev->class_dev, "D/A error\n");\r\ns_ao->async->events |= COMEDI_CB_ERROR;\r\nhandled = 1;\r\n}\r\n#if 0\r\nif (adcsr & DT2821_ADCSR_ADDONE) {\r\nunsigned short data;\r\ndata = inw(dev->iobase + DT2821_ADDAT_REG);\r\ndata &= s->maxdata;\r\nif (devpriv->ad_2scomp)\r\ndata = comedi_offset_munge(s, data);\r\ncomedi_buf_write_samples(s, &data, 1);\r\ndevpriv->nread--;\r\nif (!devpriv->nread) {\r\ns->async->events |= COMEDI_CB_EOA;\r\n} else {\r\nif (supcsr & DT2821_SUPCSR_SCDN)\r\noutw(devpriv->supcsr | DT2821_SUPCSR_STRIG,\r\ndev->iobase + DT2821_SUPCSR_REG);\r\n}\r\nhandled = 1;\r\n}\r\n#endif\r\ncomedi_handle_events(dev, s);\r\ncomedi_handle_events(dev, s_ao);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void dt282x_load_changain(struct comedi_device *dev, int n,\r\nunsigned int *chanlist)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nint i;\r\noutw(DT2821_CHANCSR_LLE | DT2821_CHANCSR_NUMB(n),\r\ndev->iobase + DT2821_CHANCSR_REG);\r\nfor (i = 0; i < n; i++) {\r\nunsigned int chan = CR_CHAN(chanlist[i]);\r\nunsigned int range = CR_RANGE(chanlist[i]);\r\noutw(devpriv->adcsr |\r\nDT2821_ADCSR_GS(range) |\r\nDT2821_ADCSR_CHAN(chan),\r\ndev->iobase + DT2821_ADCSR_REG);\r\n}\r\noutw(DT2821_CHANCSR_NUMB(n), dev->iobase + DT2821_CHANCSR_REG);\r\n}\r\nstatic int dt282x_ai_timeout(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nunsigned int status;\r\nstatus = inw(dev->iobase + DT2821_ADCSR_REG);\r\nswitch (context) {\r\ncase DT2821_ADCSR_MUXBUSY:\r\nif ((status & DT2821_ADCSR_MUXBUSY) == 0)\r\nreturn 0;\r\nbreak;\r\ncase DT2821_ADCSR_ADDONE:\r\nif (status & DT2821_ADCSR_ADDONE)\r\nreturn 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic int dt282x_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nunsigned int val;\r\nint ret;\r\nint i;\r\ndevpriv->adcsr = DT2821_ADCSR_ADCLK;\r\noutw(devpriv->adcsr, dev->iobase + DT2821_ADCSR_REG);\r\ndt282x_load_changain(dev, 1, &insn->chanspec);\r\noutw(devpriv->supcsr | DT2821_SUPCSR_PRLD,\r\ndev->iobase + DT2821_SUPCSR_REG);\r\nret = comedi_timeout(dev, s, insn,\r\ndt282x_ai_timeout, DT2821_ADCSR_MUXBUSY);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < insn->n; i++) {\r\noutw(devpriv->supcsr | DT2821_SUPCSR_STRIG,\r\ndev->iobase + DT2821_SUPCSR_REG);\r\nret = comedi_timeout(dev, s, insn,\r\ndt282x_ai_timeout, DT2821_ADCSR_ADDONE);\r\nif (ret)\r\nreturn ret;\r\nval = inw(dev->iobase + DT2821_ADDAT_REG);\r\nval &= s->maxdata;\r\nif (devpriv->ad_2scomp)\r\nval = comedi_offset_munge(s, val);\r\ndata[i] = val;\r\n}\r\nreturn i;\r\n}\r\nstatic int dt282x_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nconst struct dt282x_board *board = dev->board_ptr;\r\nstruct dt282x_private *devpriv = dev->private;\r\nint err = 0;\r\nunsigned int arg;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src,\r\nTRIG_FOLLOW | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_TIMER);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\nerr |= comedi_check_trigger_arg_min(&cmd->convert_arg, 4000);\r\n#define SLOWEST_TIMER (250*(1<<15)*255)\r\nerr |= comedi_check_trigger_arg_max(&cmd->convert_arg, SLOWEST_TIMER);\r\nerr |= comedi_check_trigger_arg_min(&cmd->convert_arg, board->ai_speed);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\narg = cmd->convert_arg;\r\ndevpriv->divisor = dt282x_ns_to_timer(&arg, cmd->flags);\r\nerr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\r\nif (err)\r\nreturn 4;\r\nreturn 0;\r\n}\r\nstatic int dt282x_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nstruct comedi_isadma *dma = devpriv->dma;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nint ret;\r\ndt282x_disable_dma(dev);\r\noutw(devpriv->divisor, dev->iobase + DT2821_TMRCTR_REG);\r\ndevpriv->supcsr = DT2821_SUPCSR_ERRINTEN;\r\nif (cmd->scan_begin_src == TRIG_FOLLOW)\r\ndevpriv->supcsr = DT2821_SUPCSR_DS_AD_CLK;\r\nelse\r\ndevpriv->supcsr = DT2821_SUPCSR_DS_AD_TRIG;\r\noutw(devpriv->supcsr |\r\nDT2821_SUPCSR_CLRDMADNE |\r\nDT2821_SUPCSR_BUFFB |\r\nDT2821_SUPCSR_ADCINIT,\r\ndev->iobase + DT2821_SUPCSR_REG);\r\ndevpriv->ntrig = cmd->stop_arg * cmd->scan_end_arg;\r\ndevpriv->nread = devpriv->ntrig;\r\ndevpriv->dma_dir = COMEDI_ISADMA_READ;\r\ndma->cur_dma = 0;\r\ndt282x_prep_ai_dma(dev, 0, 0);\r\nif (devpriv->ntrig) {\r\ndt282x_prep_ai_dma(dev, 1, 0);\r\ndevpriv->supcsr |= DT2821_SUPCSR_DDMA;\r\noutw(devpriv->supcsr, dev->iobase + DT2821_SUPCSR_REG);\r\n}\r\ndevpriv->adcsr = 0;\r\ndt282x_load_changain(dev, cmd->chanlist_len, cmd->chanlist);\r\ndevpriv->adcsr = DT2821_ADCSR_ADCLK | DT2821_ADCSR_IADDONE;\r\noutw(devpriv->adcsr, dev->iobase + DT2821_ADCSR_REG);\r\noutw(devpriv->supcsr | DT2821_SUPCSR_PRLD,\r\ndev->iobase + DT2821_SUPCSR_REG);\r\nret = comedi_timeout(dev, s, NULL,\r\ndt282x_ai_timeout, DT2821_ADCSR_MUXBUSY);\r\nif (ret)\r\nreturn ret;\r\nif (cmd->scan_begin_src == TRIG_FOLLOW) {\r\noutw(devpriv->supcsr | DT2821_SUPCSR_STRIG,\r\ndev->iobase + DT2821_SUPCSR_REG);\r\n} else {\r\ndevpriv->supcsr |= DT2821_SUPCSR_XTRIG;\r\noutw(devpriv->supcsr, dev->iobase + DT2821_SUPCSR_REG);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dt282x_ai_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\ndt282x_disable_dma(dev);\r\ndevpriv->adcsr = 0;\r\noutw(devpriv->adcsr, dev->iobase + DT2821_ADCSR_REG);\r\ndevpriv->supcsr = 0;\r\noutw(devpriv->supcsr | DT2821_SUPCSR_ADCINIT,\r\ndev->iobase + DT2821_SUPCSR_REG);\r\nreturn 0;\r\n}\r\nstatic int dt282x_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int range = CR_RANGE(insn->chanspec);\r\nint i;\r\ndevpriv->dacsr |= DT2821_DACSR_SSEL | DT2821_DACSR_YSEL(chan);\r\nfor (i = 0; i < insn->n; i++) {\r\nunsigned int val = data[i];\r\ns->readback[chan] = val;\r\nif (comedi_range_is_bipolar(s, range))\r\nval = comedi_offset_munge(s, val);\r\noutw(devpriv->dacsr, dev->iobase + DT2821_DACSR_REG);\r\noutw(val, dev->iobase + DT2821_DADAT_REG);\r\noutw(devpriv->supcsr | DT2821_SUPCSR_DACON,\r\ndev->iobase + DT2821_SUPCSR_REG);\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int dt282x_ao_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nint err = 0;\r\nunsigned int arg;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_INT);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nerr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg, 5000);\r\nerr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\narg = cmd->scan_begin_arg;\r\ndevpriv->divisor = dt282x_ns_to_timer(&arg, cmd->flags);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\r\nif (err)\r\nreturn 4;\r\nreturn 0;\r\n}\r\nstatic int dt282x_ao_inttrig(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nif (trig_num != cmd->start_src)\r\nreturn -EINVAL;\r\nif (!dt282x_ao_setup_dma(dev, s, 0))\r\nreturn -EPIPE;\r\nif (!dt282x_ao_setup_dma(dev, s, 1))\r\nreturn -EPIPE;\r\noutw(devpriv->supcsr | DT2821_SUPCSR_STRIG,\r\ndev->iobase + DT2821_SUPCSR_REG);\r\ns->async->inttrig = NULL;\r\nreturn 1;\r\n}\r\nstatic int dt282x_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nstruct comedi_isadma *dma = devpriv->dma;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\ndt282x_disable_dma(dev);\r\ndevpriv->supcsr = DT2821_SUPCSR_ERRINTEN |\r\nDT2821_SUPCSR_DS_DA_CLK |\r\nDT2821_SUPCSR_DDMA;\r\noutw(devpriv->supcsr |\r\nDT2821_SUPCSR_CLRDMADNE |\r\nDT2821_SUPCSR_BUFFB |\r\nDT2821_SUPCSR_DACINIT,\r\ndev->iobase + DT2821_SUPCSR_REG);\r\ndevpriv->ntrig = cmd->stop_arg * cmd->chanlist_len;\r\ndevpriv->nread = devpriv->ntrig;\r\ndevpriv->dma_dir = COMEDI_ISADMA_WRITE;\r\ndma->cur_dma = 0;\r\noutw(devpriv->divisor, dev->iobase + DT2821_TMRCTR_REG);\r\ndevpriv->dacsr &= (DT2821_DACSR_LBOE | DT2821_DACSR_HBOE);\r\ndevpriv->dacsr |= (DT2821_DACSR_SSEL |\r\nDT2821_DACSR_DACLK |\r\nDT2821_DACSR_IDARDY);\r\noutw(devpriv->dacsr, dev->iobase + DT2821_DACSR_REG);\r\ns->async->inttrig = dt282x_ao_inttrig;\r\nreturn 0;\r\n}\r\nstatic int dt282x_ao_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\ndt282x_disable_dma(dev);\r\ndevpriv->dacsr &= (DT2821_DACSR_LBOE | DT2821_DACSR_HBOE);\r\noutw(devpriv->dacsr, dev->iobase + DT2821_DACSR_REG);\r\ndevpriv->supcsr = 0;\r\noutw(devpriv->supcsr | DT2821_SUPCSR_DACINIT,\r\ndev->iobase + DT2821_SUPCSR_REG);\r\nreturn 0;\r\n}\r\nstatic int dt282x_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nif (comedi_dio_update_state(s, data))\r\noutw(s->state, dev->iobase + DT2821_DIODAT_REG);\r\ndata[1] = inw(dev->iobase + DT2821_DIODAT_REG);\r\nreturn insn->n;\r\n}\r\nstatic int dt282x_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int mask;\r\nint ret;\r\nif (chan < 8)\r\nmask = 0x00ff;\r\nelse\r\nmask = 0xff00;\r\nret = comedi_dio_insn_config(dev, s, insn, data, mask);\r\nif (ret)\r\nreturn ret;\r\ndevpriv->dacsr &= ~(DT2821_DACSR_LBOE | DT2821_DACSR_HBOE);\r\nif (s->io_bits & 0x00ff)\r\ndevpriv->dacsr |= DT2821_DACSR_LBOE;\r\nif (s->io_bits & 0xff00)\r\ndevpriv->dacsr |= DT2821_DACSR_HBOE;\r\noutw(devpriv->dacsr, dev->iobase + DT2821_DACSR_REG);\r\nreturn insn->n;\r\n}\r\nstatic const struct comedi_lrange *opt_ai_range_lkup(int ispgl, int x)\r\n{\r\nif (ispgl) {\r\nif (x < 0 || x >= 2)\r\nx = 0;\r\nreturn ai_range_pgl_table[x];\r\n}\r\nif (x < 0 || x >= 4)\r\nx = 0;\r\nreturn ai_range_table[x];\r\n}\r\nstatic void dt282x_alloc_dma(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nunsigned int irq_num = it->options[1];\r\nunsigned int dma_chan[2];\r\nif (it->options[2] < it->options[3]) {\r\ndma_chan[0] = it->options[2];\r\ndma_chan[1] = it->options[3];\r\n} else {\r\ndma_chan[0] = it->options[3];\r\ndma_chan[1] = it->options[2];\r\n}\r\nif (!irq_num || dma_chan[0] == dma_chan[1] ||\r\ndma_chan[0] < 5 || dma_chan[0] > 7 ||\r\ndma_chan[1] < 5 || dma_chan[1] > 7)\r\nreturn;\r\nif (request_irq(irq_num, dt282x_interrupt, 0, dev->board_name, dev))\r\nreturn;\r\ndevpriv->dma = comedi_isadma_alloc(dev, 2, dma_chan[0], dma_chan[1],\r\nPAGE_SIZE, 0);\r\nif (!devpriv->dma)\r\nfree_irq(irq_num, dev);\r\n}\r\nstatic void dt282x_free_dma(struct comedi_device *dev)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nif (devpriv)\r\ncomedi_isadma_free(devpriv->dma);\r\n}\r\nstatic int dt282x_initialize(struct comedi_device *dev)\r\n{\r\noutw(DT2821_SUPCSR_BDINIT, dev->iobase + DT2821_SUPCSR_REG);\r\ninw(dev->iobase + DT2821_ADCSR_REG);\r\nif (((inw(dev->iobase + DT2821_ADCSR_REG) & 0xfff0) != 0x7c00) ||\r\n((inw(dev->iobase + DT2821_CHANCSR_REG) & 0xf0f0) != 0x70f0) ||\r\n((inw(dev->iobase + DT2821_DACSR_REG) & 0x7c93) != 0x7c90) ||\r\n((inw(dev->iobase + DT2821_SUPCSR_REG) & 0xf8ff) != 0x0000) ||\r\n((inw(dev->iobase + DT2821_TMRCTR_REG) & 0xff00) != 0xf000)) {\r\ndev_err(dev->class_dev, "board not found\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nconst struct dt282x_board *board = dev->board_ptr;\r\nstruct dt282x_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint ret;\r\nret = comedi_request_region(dev, it->options[0], 0x10);\r\nif (ret)\r\nreturn ret;\r\nret = dt282x_initialize(dev);\r\nif (ret)\r\nreturn ret;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\ndt282x_alloc_dma(dev, it);\r\nret = comedi_alloc_subdevices(dev, 3);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE;\r\nif ((it->options[4] && board->adchan_di) || board->adchan_se == 0) {\r\ns->subdev_flags |= SDF_DIFF;\r\ns->n_chan = board->adchan_di;\r\n} else {\r\ns->subdev_flags |= SDF_COMMON;\r\ns->n_chan = board->adchan_se;\r\n}\r\ns->maxdata = board->ai_maxdata;\r\ns->range_table = opt_ai_range_lkup(board->ispgl, it->options[8]);\r\ndevpriv->ad_2scomp = it->options[5] ? 1 : 0;\r\ns->insn_read = dt282x_ai_insn_read;\r\nif (dev->irq) {\r\ndev->read_subdev = s;\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->len_chanlist = s->n_chan;\r\ns->do_cmdtest = dt282x_ai_cmdtest;\r\ns->do_cmd = dt282x_ai_cmd;\r\ns->cancel = dt282x_ai_cancel;\r\n}\r\ns = &dev->subdevices[1];\r\nif (board->dachan) {\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = board->dachan;\r\ns->maxdata = board->ao_maxdata;\r\ns->range_table = &dt282x_ao_range;\r\ns->insn_write = dt282x_ao_insn_write;\r\nif (dev->irq) {\r\ndev->write_subdev = s;\r\ns->subdev_flags |= SDF_CMD_WRITE;\r\ns->len_chanlist = s->n_chan;\r\ns->do_cmdtest = dt282x_ao_cmdtest;\r\ns->do_cmd = dt282x_ao_cmd;\r\ns->cancel = dt282x_ao_cancel;\r\n}\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = 16;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = dt282x_dio_insn_bits;\r\ns->insn_config = dt282x_dio_insn_config;\r\nreturn 0;\r\n}\r\nstatic void dt282x_detach(struct comedi_device *dev)\r\n{\r\ndt282x_free_dma(dev);\r\ncomedi_legacy_detach(dev);\r\n}
