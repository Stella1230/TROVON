static void bt878_mem_free(struct bt878 *bt)\r\n{\r\nif (bt->buf_cpu) {\r\npci_free_consistent(bt->dev, bt->buf_size, bt->buf_cpu,\r\nbt->buf_dma);\r\nbt->buf_cpu = NULL;\r\n}\r\nif (bt->risc_cpu) {\r\npci_free_consistent(bt->dev, bt->risc_size, bt->risc_cpu,\r\nbt->risc_dma);\r\nbt->risc_cpu = NULL;\r\n}\r\n}\r\nstatic int bt878_mem_alloc(struct bt878 *bt)\r\n{\r\nif (!bt->buf_cpu) {\r\nbt->buf_size = 128 * 1024;\r\nbt->buf_cpu = pci_zalloc_consistent(bt->dev, bt->buf_size,\r\n&bt->buf_dma);\r\nif (!bt->buf_cpu)\r\nreturn -ENOMEM;\r\n}\r\nif (!bt->risc_cpu) {\r\nbt->risc_size = PAGE_SIZE;\r\nbt->risc_cpu = pci_zalloc_consistent(bt->dev, bt->risc_size,\r\n&bt->risc_dma);\r\nif (!bt->risc_cpu) {\r\nbt878_mem_free(bt);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int bt878_make_risc(struct bt878 *bt)\r\n{\r\nbt->block_bytes = bt->buf_size >> 4;\r\nbt->block_count = 1 << 4;\r\nbt->line_bytes = bt->block_bytes;\r\nbt->line_count = bt->block_count;\r\nwhile (bt->line_bytes > 4095) {\r\nbt->line_bytes >>= 1;\r\nbt->line_count <<= 1;\r\n}\r\nif (bt->line_count > 255) {\r\nprintk(KERN_ERR "bt878: buffer size error!\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bt878_risc_program(struct bt878 *bt, u32 op_sync_orin)\r\n{\r\nu32 buf_pos = 0;\r\nu32 line;\r\nRISC_FLUSH();\r\nRISC_INSTR(RISC_SYNC | RISC_SYNC_FM1 | op_sync_orin);\r\nRISC_INSTR(0);\r\ndprintk("bt878: risc len lines %u, bytes per line %u\n",\r\nbt->line_count, bt->line_bytes);\r\nfor (line = 0; line < bt->line_count; line++) {\r\nif (!(buf_pos % bt->block_bytes))\r\nRISC_INSTR(RISC_WRITE | RISC_WR_SOL | RISC_WR_EOL |\r\nRISC_IRQ |\r\nRISC_STATUS(((buf_pos /\r\nbt->block_bytes) +\r\n(bt->block_count -\r\n1)) %\r\nbt->block_count) | bt->\r\nline_bytes);\r\nelse\r\nRISC_INSTR(RISC_WRITE | RISC_WR_SOL | RISC_WR_EOL |\r\nbt->line_bytes);\r\nRISC_INSTR(bt->buf_dma + buf_pos);\r\nbuf_pos += bt->line_bytes;\r\n}\r\nRISC_INSTR(RISC_SYNC | op_sync_orin | RISC_SYNC_VRO);\r\nRISC_INSTR(0);\r\nRISC_INSTR(RISC_JUMP);\r\nRISC_INSTR(bt->risc_dma);\r\nbtwrite((bt->line_count << 16) | bt->line_bytes, BT878_APACK_LEN);\r\n}\r\nvoid bt878_start(struct bt878 *bt, u32 controlreg, u32 op_sync_orin,\r\nu32 irq_err_ignore)\r\n{\r\nu32 int_mask;\r\ndprintk("bt878 debug: bt878_start (ctl=%8.8x)\n", controlreg);\r\nbt878_risc_program(bt, op_sync_orin);\r\ncontrolreg &= ~0x1f;\r\ncontrolreg |= 0x1b;\r\nbtwrite(bt->risc_dma, BT878_ARISC_START);\r\nint_mask = BT878_ASCERR | BT878_AOCERR | BT878_APABORT |\r\nBT878_ARIPERR | BT878_APPERR | BT878_AFDSR | BT878_AFTRGT |\r\nBT878_AFBUS | BT878_ARISCI;\r\nint_mask &= ~irq_err_ignore;\r\nbtwrite(int_mask, BT878_AINT_MASK);\r\nbtwrite(controlreg, BT878_AGPIO_DMA_CTL);\r\n}\r\nvoid bt878_stop(struct bt878 *bt)\r\n{\r\nu32 stat;\r\nint i = 0;\r\ndprintk("bt878 debug: bt878_stop\n");\r\nbtwrite(0, BT878_AINT_MASK);\r\nbtand(~0x13, BT878_AGPIO_DMA_CTL);\r\ndo {\r\nstat = btread(BT878_AINT_STAT);\r\nif (!(stat & BT878_ARISC_EN))\r\nbreak;\r\ni++;\r\n} while (i < 500);\r\ndprintk("bt878(%d) debug: bt878_stop, i=%d, stat=0x%8.8x\n",\r\nbt->nr, i, stat);\r\n}\r\nstatic irqreturn_t bt878_irq(int irq, void *dev_id)\r\n{\r\nu32 stat, astat, mask;\r\nint count;\r\nstruct bt878 *bt;\r\nbt = (struct bt878 *) dev_id;\r\ncount = 0;\r\nwhile (1) {\r\nstat = btread(BT878_AINT_STAT);\r\nmask = btread(BT878_AINT_MASK);\r\nif (!(astat = (stat & mask)))\r\nreturn IRQ_NONE;\r\nbtwrite(astat, BT878_AINT_STAT);\r\nif (astat & (BT878_ASCERR | BT878_AOCERR)) {\r\nif (bt878_verbose) {\r\nprintk(KERN_INFO\r\n"bt878(%d): irq%s%s risc_pc=%08x\n",\r\nbt->nr,\r\n(astat & BT878_ASCERR) ? " SCERR" :\r\n"",\r\n(astat & BT878_AOCERR) ? " OCERR" :\r\n"", btread(BT878_ARISC_PC));\r\n}\r\n}\r\nif (astat & (BT878_APABORT | BT878_ARIPERR | BT878_APPERR)) {\r\nif (bt878_verbose) {\r\nprintk(KERN_INFO\r\n"bt878(%d): irq%s%s%s risc_pc=%08x\n",\r\nbt->nr,\r\n(astat & BT878_APABORT) ? " PABORT" :\r\n"",\r\n(astat & BT878_ARIPERR) ? " RIPERR" :\r\n"",\r\n(astat & BT878_APPERR) ? " PPERR" :\r\n"", btread(BT878_ARISC_PC));\r\n}\r\n}\r\nif (astat & (BT878_AFDSR | BT878_AFTRGT | BT878_AFBUS)) {\r\nif (bt878_verbose) {\r\nprintk(KERN_INFO\r\n"bt878(%d): irq%s%s%s risc_pc=%08x\n",\r\nbt->nr,\r\n(astat & BT878_AFDSR) ? " FDSR" : "",\r\n(astat & BT878_AFTRGT) ? " FTRGT" :\r\n"",\r\n(astat & BT878_AFBUS) ? " FBUS" : "",\r\nbtread(BT878_ARISC_PC));\r\n}\r\n}\r\nif (astat & BT878_ARISCI) {\r\nbt->finished_block = (stat & BT878_ARISCS) >> 28;\r\ntasklet_schedule(&bt->tasklet);\r\nbreak;\r\n}\r\ncount++;\r\nif (count > 20) {\r\nbtwrite(0, BT878_AINT_MASK);\r\nprintk(KERN_ERR\r\n"bt878(%d): IRQ lockup, cleared int mask\n",\r\nbt->nr);\r\nbreak;\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nint\r\nbt878_device_control(struct bt878 *bt, unsigned int cmd, union dst_gpio_packet *mp)\r\n{\r\nint retval;\r\nretval = 0;\r\nif (mutex_lock_interruptible(&bt->gpio_lock))\r\nreturn -ERESTARTSYS;\r\nswitch (cmd) {\r\ncase DST_IG_ENABLE:\r\nretval = bttv_gpio_enable(bt->bttv_nr,\r\nmp->enb.mask,\r\nmp->enb.enable);\r\nbreak;\r\ncase DST_IG_WRITE:\r\nretval = bttv_write_gpio(bt->bttv_nr,\r\nmp->outp.mask,\r\nmp->outp.highvals);\r\nbreak;\r\ncase DST_IG_READ:\r\nretval = bttv_read_gpio(bt->bttv_nr, &mp->rd.value);\r\nbreak;\r\ncase DST_IG_TS:\r\nbt->TS_Size = mp->psize;\r\nbreak;\r\ndefault:\r\nretval = -EINVAL;\r\nbreak;\r\n}\r\nmutex_unlock(&bt->gpio_lock);\r\nreturn retval;\r\n}\r\nstatic const char * card_name(const struct pci_device_id *id)\r\n{\r\nreturn id->driver_data ? (const char *)id->driver_data : "Unknown";\r\n}\r\nstatic int bt878_probe(struct pci_dev *dev, const struct pci_device_id *pci_id)\r\n{\r\nint result = 0;\r\nunsigned char lat;\r\nstruct bt878 *bt;\r\nunsigned int cardid;\r\nprintk(KERN_INFO "bt878: Bt878 AUDIO function found (%d).\n",\r\nbt878_num);\r\nif (bt878_num >= BT878_MAX) {\r\nprintk(KERN_ERR "bt878: Too many devices inserted\n");\r\nresult = -ENOMEM;\r\ngoto fail0;\r\n}\r\nif (pci_enable_device(dev))\r\nreturn -EIO;\r\ncardid = dev->subsystem_device << 16;\r\ncardid |= dev->subsystem_vendor;\r\nprintk(KERN_INFO "%s: card id=[0x%x],[ %s ] has DVB functions.\n",\r\n__func__, cardid, card_name(pci_id));\r\nbt = &bt878[bt878_num];\r\nbt->dev = dev;\r\nbt->nr = bt878_num;\r\nbt->shutdown = 0;\r\nbt->id = dev->device;\r\nbt->irq = dev->irq;\r\nbt->bt878_adr = pci_resource_start(dev, 0);\r\nif (!request_mem_region(pci_resource_start(dev, 0),\r\npci_resource_len(dev, 0), "bt878")) {\r\nresult = -EBUSY;\r\ngoto fail0;\r\n}\r\nbt->revision = dev->revision;\r\npci_read_config_byte(dev, PCI_LATENCY_TIMER, &lat);\r\nprintk(KERN_INFO "bt878(%d): Bt%x (rev %d) at %02x:%02x.%x, ",\r\nbt878_num, bt->id, bt->revision, dev->bus->number,\r\nPCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn));\r\nprintk("irq: %d, latency: %d, memory: 0x%lx\n",\r\nbt->irq, lat, bt->bt878_adr);\r\n#ifdef __sparc__\r\nbt->bt878_mem = (unsigned char *) bt->bt878_adr;\r\n#else\r\nbt->bt878_mem = ioremap(bt->bt878_adr, 0x1000);\r\n#endif\r\nbtwrite(0, BT848_INT_MASK);\r\nresult = request_irq(bt->irq, bt878_irq,\r\nIRQF_SHARED, "bt878", (void *) bt);\r\nif (result == -EINVAL) {\r\nprintk(KERN_ERR "bt878(%d): Bad irq number or handler\n",\r\nbt878_num);\r\ngoto fail1;\r\n}\r\nif (result == -EBUSY) {\r\nprintk(KERN_ERR\r\n"bt878(%d): IRQ %d busy, change your PnP config in BIOS\n",\r\nbt878_num, bt->irq);\r\ngoto fail1;\r\n}\r\nif (result < 0)\r\ngoto fail1;\r\npci_set_master(dev);\r\npci_set_drvdata(dev, bt);\r\nif ((result = bt878_mem_alloc(bt))) {\r\nprintk(KERN_ERR "bt878: failed to allocate memory!\n");\r\ngoto fail2;\r\n}\r\nbt878_make_risc(bt);\r\nbtwrite(0, BT878_AINT_MASK);\r\nbt878_num++;\r\nreturn 0;\r\nfail2:\r\nfree_irq(bt->irq, bt);\r\nfail1:\r\nrelease_mem_region(pci_resource_start(bt->dev, 0),\r\npci_resource_len(bt->dev, 0));\r\nfail0:\r\npci_disable_device(dev);\r\nreturn result;\r\n}\r\nstatic void bt878_remove(struct pci_dev *pci_dev)\r\n{\r\nu8 command;\r\nstruct bt878 *bt = pci_get_drvdata(pci_dev);\r\nif (bt878_verbose)\r\nprintk(KERN_INFO "bt878(%d): unloading\n", bt->nr);\r\nbtand(~0x13, BT878_AGPIO_DMA_CTL);\r\nbtwrite(0, BT878_AINT_MASK);\r\nbtwrite(~0U, BT878_AINT_STAT);\r\npci_read_config_byte(bt->dev, PCI_COMMAND, &command);\r\ncommand &= ~PCI_COMMAND_MASTER;\r\npci_write_config_byte(bt->dev, PCI_COMMAND, command);\r\nfree_irq(bt->irq, bt);\r\nprintk(KERN_DEBUG "bt878_mem: 0x%p.\n", bt->bt878_mem);\r\nif (bt->bt878_mem)\r\niounmap(bt->bt878_mem);\r\nrelease_mem_region(pci_resource_start(bt->dev, 0),\r\npci_resource_len(bt->dev, 0));\r\nbt->shutdown = 1;\r\nbt878_mem_free(bt);\r\npci_disable_device(pci_dev);\r\nreturn;\r\n}\r\nstatic int __init bt878_init_module(void)\r\n{\r\nbt878_num = 0;\r\nprintk(KERN_INFO "bt878: AUDIO driver version %d.%d.%d loaded\n",\r\n(BT878_VERSION_CODE >> 16) & 0xff,\r\n(BT878_VERSION_CODE >> 8) & 0xff,\r\nBT878_VERSION_CODE & 0xff);\r\nreturn pci_register_driver(&bt878_pci_driver);\r\n}\r\nstatic void __exit bt878_cleanup_module(void)\r\n{\r\npci_unregister_driver(&bt878_pci_driver);\r\n}
