static int anatop_regmap_set_voltage_time_sel(struct regulator_dev *reg,\r\nunsigned int old_sel,\r\nunsigned int new_sel)\r\n{\r\nstruct anatop_regulator *anatop_reg = rdev_get_drvdata(reg);\r\nu32 val;\r\nint ret = 0;\r\nif (anatop_reg->delay_bit_width && new_sel > old_sel) {\r\nregmap_read(anatop_reg->anatop, anatop_reg->delay_reg, &val);\r\nval = (val >> anatop_reg->delay_bit_shift) &\r\n((1 << anatop_reg->delay_bit_width) - 1);\r\nret = (new_sel - old_sel) * (LDO_RAMP_UP_UNIT_IN_CYCLES <<\r\nval) / LDO_RAMP_UP_FREQ_IN_MHZ + 1;\r\n}\r\nreturn ret;\r\n}\r\nstatic int anatop_regmap_enable(struct regulator_dev *reg)\r\n{\r\nstruct anatop_regulator *anatop_reg = rdev_get_drvdata(reg);\r\nint sel;\r\nsel = anatop_reg->bypass ? LDO_FET_FULL_ON : anatop_reg->sel;\r\nreturn regulator_set_voltage_sel_regmap(reg, sel);\r\n}\r\nstatic int anatop_regmap_disable(struct regulator_dev *reg)\r\n{\r\nreturn regulator_set_voltage_sel_regmap(reg, LDO_POWER_GATE);\r\n}\r\nstatic int anatop_regmap_is_enabled(struct regulator_dev *reg)\r\n{\r\nreturn regulator_get_voltage_sel_regmap(reg) != LDO_POWER_GATE;\r\n}\r\nstatic int anatop_regmap_core_set_voltage_sel(struct regulator_dev *reg,\r\nunsigned selector)\r\n{\r\nstruct anatop_regulator *anatop_reg = rdev_get_drvdata(reg);\r\nint ret;\r\nif (anatop_reg->bypass || !anatop_regmap_is_enabled(reg)) {\r\nanatop_reg->sel = selector;\r\nreturn 0;\r\n}\r\nret = regulator_set_voltage_sel_regmap(reg, selector);\r\nif (!ret)\r\nanatop_reg->sel = selector;\r\nreturn ret;\r\n}\r\nstatic int anatop_regmap_core_get_voltage_sel(struct regulator_dev *reg)\r\n{\r\nstruct anatop_regulator *anatop_reg = rdev_get_drvdata(reg);\r\nif (anatop_reg->bypass || !anatop_regmap_is_enabled(reg))\r\nreturn anatop_reg->sel;\r\nreturn regulator_get_voltage_sel_regmap(reg);\r\n}\r\nstatic int anatop_regmap_get_bypass(struct regulator_dev *reg, bool *enable)\r\n{\r\nstruct anatop_regulator *anatop_reg = rdev_get_drvdata(reg);\r\nint sel;\r\nsel = regulator_get_voltage_sel_regmap(reg);\r\nif (sel == LDO_FET_FULL_ON)\r\nWARN_ON(!anatop_reg->bypass);\r\nelse if (sel != LDO_POWER_GATE)\r\nWARN_ON(anatop_reg->bypass);\r\n*enable = anatop_reg->bypass;\r\nreturn 0;\r\n}\r\nstatic int anatop_regmap_set_bypass(struct regulator_dev *reg, bool enable)\r\n{\r\nstruct anatop_regulator *anatop_reg = rdev_get_drvdata(reg);\r\nint sel;\r\nif (enable == anatop_reg->bypass)\r\nreturn 0;\r\nsel = enable ? LDO_FET_FULL_ON : anatop_reg->sel;\r\nanatop_reg->bypass = enable;\r\nreturn regulator_set_voltage_sel_regmap(reg, sel);\r\n}\r\nstatic int anatop_regulator_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct device_node *anatop_np;\r\nstruct regulator_desc *rdesc;\r\nstruct regulator_dev *rdev;\r\nstruct anatop_regulator *sreg;\r\nstruct regulator_init_data *initdata;\r\nstruct regulator_config config = { };\r\nint ret = 0;\r\nu32 val;\r\nsreg = devm_kzalloc(dev, sizeof(*sreg), GFP_KERNEL);\r\nif (!sreg)\r\nreturn -ENOMEM;\r\nsreg->name = of_get_property(np, "regulator-name", NULL);\r\nrdesc = &sreg->rdesc;\r\nrdesc->name = sreg->name;\r\nrdesc->type = REGULATOR_VOLTAGE;\r\nrdesc->owner = THIS_MODULE;\r\ninitdata = of_get_regulator_init_data(dev, np, rdesc);\r\nsreg->initdata = initdata;\r\nanatop_np = of_get_parent(np);\r\nif (!anatop_np)\r\nreturn -ENODEV;\r\nsreg->anatop = syscon_node_to_regmap(anatop_np);\r\nof_node_put(anatop_np);\r\nif (IS_ERR(sreg->anatop))\r\nreturn PTR_ERR(sreg->anatop);\r\nret = of_property_read_u32(np, "anatop-reg-offset",\r\n&sreg->control_reg);\r\nif (ret) {\r\ndev_err(dev, "no anatop-reg-offset property set\n");\r\nreturn ret;\r\n}\r\nret = of_property_read_u32(np, "anatop-vol-bit-width",\r\n&sreg->vol_bit_width);\r\nif (ret) {\r\ndev_err(dev, "no anatop-vol-bit-width property set\n");\r\nreturn ret;\r\n}\r\nret = of_property_read_u32(np, "anatop-vol-bit-shift",\r\n&sreg->vol_bit_shift);\r\nif (ret) {\r\ndev_err(dev, "no anatop-vol-bit-shift property set\n");\r\nreturn ret;\r\n}\r\nret = of_property_read_u32(np, "anatop-min-bit-val",\r\n&sreg->min_bit_val);\r\nif (ret) {\r\ndev_err(dev, "no anatop-min-bit-val property set\n");\r\nreturn ret;\r\n}\r\nret = of_property_read_u32(np, "anatop-min-voltage",\r\n&sreg->min_voltage);\r\nif (ret) {\r\ndev_err(dev, "no anatop-min-voltage property set\n");\r\nreturn ret;\r\n}\r\nret = of_property_read_u32(np, "anatop-max-voltage",\r\n&sreg->max_voltage);\r\nif (ret) {\r\ndev_err(dev, "no anatop-max-voltage property set\n");\r\nreturn ret;\r\n}\r\nof_property_read_u32(np, "anatop-delay-reg-offset",\r\n&sreg->delay_reg);\r\nof_property_read_u32(np, "anatop-delay-bit-width",\r\n&sreg->delay_bit_width);\r\nof_property_read_u32(np, "anatop-delay-bit-shift",\r\n&sreg->delay_bit_shift);\r\nrdesc->n_voltages = (sreg->max_voltage - sreg->min_voltage) / 25000 + 1\r\n+ sreg->min_bit_val;\r\nrdesc->min_uV = sreg->min_voltage;\r\nrdesc->uV_step = 25000;\r\nrdesc->linear_min_sel = sreg->min_bit_val;\r\nrdesc->vsel_reg = sreg->control_reg;\r\nrdesc->vsel_mask = ((1 << sreg->vol_bit_width) - 1) <<\r\nsreg->vol_bit_shift;\r\nconfig.dev = &pdev->dev;\r\nconfig.init_data = initdata;\r\nconfig.driver_data = sreg;\r\nconfig.of_node = pdev->dev.of_node;\r\nconfig.regmap = sreg->anatop;\r\nif (sreg->control_reg && sreg->delay_bit_width) {\r\nrdesc->ops = &anatop_core_rops;\r\nret = regmap_read(config.regmap, rdesc->vsel_reg, &val);\r\nif (ret) {\r\ndev_err(dev, "failed to read initial state\n");\r\nreturn ret;\r\n}\r\nsreg->sel = (val & rdesc->vsel_mask) >> sreg->vol_bit_shift;\r\nif (sreg->sel == LDO_FET_FULL_ON) {\r\nsreg->sel = 0;\r\nsreg->bypass = true;\r\n}\r\nif (!sreg->sel && !strcmp(sreg->name, "vddpu"))\r\nsreg->sel = 22;\r\nif (!sreg->sel) {\r\ndev_err(&pdev->dev, "Failed to read a valid default voltage selector.\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nrdesc->ops = &anatop_rops;\r\n}\r\nrdev = devm_regulator_register(dev, rdesc, &config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(dev, "failed to register %s\n",\r\nrdesc->name);\r\nreturn PTR_ERR(rdev);\r\n}\r\nplatform_set_drvdata(pdev, rdev);\r\nreturn 0;\r\n}\r\nstatic int __init anatop_regulator_init(void)\r\n{\r\nreturn platform_driver_register(&anatop_regulator_driver);\r\n}\r\nstatic void __exit anatop_regulator_exit(void)\r\n{\r\nplatform_driver_unregister(&anatop_regulator_driver);\r\n}
