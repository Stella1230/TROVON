void sc_dump_regs(struct sc_data *sc)\r\n{\r\nstruct device *dev = &sc->pdev->dev;\r\n#define DUMPREG(r) dev_dbg(dev, "%-35s %08x\n", #r, \\r\nioread32(sc->base + CFG_##r))\r\nDUMPREG(SC0);\r\nDUMPREG(SC1);\r\nDUMPREG(SC2);\r\nDUMPREG(SC3);\r\nDUMPREG(SC4);\r\nDUMPREG(SC5);\r\nDUMPREG(SC6);\r\nDUMPREG(SC8);\r\nDUMPREG(SC9);\r\nDUMPREG(SC10);\r\nDUMPREG(SC11);\r\nDUMPREG(SC12);\r\nDUMPREG(SC13);\r\nDUMPREG(SC17);\r\nDUMPREG(SC18);\r\nDUMPREG(SC19);\r\nDUMPREG(SC20);\r\nDUMPREG(SC21);\r\nDUMPREG(SC22);\r\nDUMPREG(SC23);\r\nDUMPREG(SC24);\r\nDUMPREG(SC25);\r\n#undef DUMPREG\r\n}\r\nvoid sc_set_hs_coeffs(struct sc_data *sc, void *addr, unsigned int src_w,\r\nunsigned int dst_w)\r\n{\r\nint sixteenths;\r\nint idx;\r\nint i, j;\r\nu16 *coeff_h = addr;\r\nconst u16 *cp;\r\nif (dst_w > src_w) {\r\nidx = HS_UP_SCALE;\r\n} else {\r\nif ((dst_w << 1) < src_w)\r\ndst_w <<= 1;\r\nif ((dst_w << 1) < src_w)\r\ndst_w <<= 1;\r\nif (dst_w == src_w) {\r\nidx = HS_LE_16_16_SCALE;\r\n} else {\r\nsixteenths = (dst_w << 4) / src_w;\r\nif (sixteenths < 8)\r\nsixteenths = 8;\r\nidx = HS_LT_9_16_SCALE + sixteenths - 8;\r\n}\r\n}\r\nif (idx == sc->hs_index)\r\nreturn;\r\ncp = scaler_hs_coeffs[idx];\r\nfor (i = 0; i < SC_NUM_PHASES * 2; i++) {\r\nfor (j = 0; j < SC_H_NUM_TAPS; j++)\r\n*coeff_h++ = *cp++;\r\ncoeff_h += SC_NUM_TAPS_MEM_ALIGN - SC_H_NUM_TAPS;\r\n}\r\nsc->hs_index = idx;\r\nsc->load_coeff_h = true;\r\n}\r\nvoid sc_set_vs_coeffs(struct sc_data *sc, void *addr, unsigned int src_h,\r\nunsigned int dst_h)\r\n{\r\nint sixteenths;\r\nint idx;\r\nint i, j;\r\nu16 *coeff_v = addr;\r\nconst u16 *cp;\r\nif (dst_h > src_h) {\r\nidx = VS_UP_SCALE;\r\n} else if (dst_h == src_h) {\r\nidx = VS_1_TO_1_SCALE;\r\n} else {\r\nsixteenths = (dst_h << 4) / src_h;\r\nif (sixteenths < 8)\r\nsixteenths = 8;\r\nidx = VS_LT_9_16_SCALE + sixteenths - 8;\r\n}\r\nif (idx == sc->vs_index)\r\nreturn;\r\ncp = scaler_vs_coeffs[idx];\r\nfor (i = 0; i < SC_NUM_PHASES * 2; i++) {\r\nfor (j = 0; j < SC_V_NUM_TAPS; j++)\r\n*coeff_v++ = *cp++;\r\ncoeff_v += SC_NUM_TAPS_MEM_ALIGN - SC_V_NUM_TAPS;\r\n}\r\nsc->vs_index = idx;\r\nsc->load_coeff_v = true;\r\n}\r\nvoid sc_config_scaler(struct sc_data *sc, u32 *sc_reg0, u32 *sc_reg8,\r\nu32 *sc_reg17, unsigned int src_w, unsigned int src_h,\r\nunsigned int dst_w, unsigned int dst_h)\r\n{\r\nstruct device *dev = &sc->pdev->dev;\r\nu32 val;\r\nint dcm_x, dcm_shift;\r\nbool use_rav;\r\nunsigned long lltmp;\r\nu32 lin_acc_inc, lin_acc_inc_u;\r\nu32 col_acc_offset;\r\nu16 factor = 0;\r\nint row_acc_init_rav = 0, row_acc_init_rav_b = 0;\r\nu32 row_acc_inc = 0, row_acc_offset = 0, row_acc_offset_b = 0;\r\nu32 *sc_reg9 = sc_reg8 + 1;\r\nu32 *sc_reg12 = sc_reg8 + 4;\r\nu32 *sc_reg13 = sc_reg8 + 5;\r\nu32 *sc_reg24 = sc_reg17 + 7;\r\nval = sc_reg0[0];\r\nval &= ~(CFG_SELFGEN_FID | CFG_TRIM | CFG_ENABLE_SIN2_VER_INTP |\r\nCFG_INTERLACE_I | CFG_DCM_4X | CFG_DCM_2X | CFG_AUTO_HS |\r\nCFG_ENABLE_EV | CFG_USE_RAV | CFG_INVT_FID | CFG_SC_BYPASS |\r\nCFG_INTERLACE_O | CFG_Y_PK_EN | CFG_HP_BYPASS | CFG_LINEAR);\r\nif (src_w == dst_w && src_h == dst_h) {\r\nval |= CFG_SC_BYPASS;\r\nsc_reg0[0] = val;\r\nreturn;\r\n}\r\nval |= CFG_LINEAR;\r\ndcm_x = src_w / dst_w;\r\nif (dcm_x > 4) {\r\nval |= CFG_DCM_4X;\r\ndcm_shift = 2;\r\n} else if (dcm_x > 2) {\r\nval |= CFG_DCM_2X;\r\ndcm_shift = 1;\r\n} else {\r\ndcm_shift = 0;\r\n}\r\nlltmp = dst_w - 1;\r\nlin_acc_inc = div64_u64(((u64)(src_w >> dcm_shift) - 1) << 24, lltmp);\r\nlin_acc_inc_u = 0;\r\ncol_acc_offset = 0;\r\ndev_dbg(dev, "hs config: src_w = %d, dst_w = %d, decimation = %s, lin_acc_inc = %08x\n",\r\nsrc_w, dst_w, dcm_shift == 2 ? "4x" :\r\n(dcm_shift == 1 ? "2x" : "none"), lin_acc_inc);\r\nif (dst_h < (src_h >> 2)) {\r\nuse_rav = true;\r\nval |= CFG_USE_RAV;\r\n} else {\r\nuse_rav = false;\r\n}\r\nif (use_rav) {\r\nfactor = (u16) ((dst_h << 10) / src_h);\r\nrow_acc_init_rav = factor + ((1 + factor) >> 1);\r\nif (row_acc_init_rav >= 1024)\r\nrow_acc_init_rav -= 1024;\r\nrow_acc_init_rav_b = row_acc_init_rav +\r\n(1 + (row_acc_init_rav >> 1)) -\r\n(1024 >> 1);\r\nif (row_acc_init_rav_b < 0) {\r\nrow_acc_init_rav_b += row_acc_init_rav;\r\nrow_acc_init_rav *= 2;\r\n}\r\ndev_dbg(dev, "vs config(RAV): src_h = %d, dst_h = %d, factor = %d, acc_init = %08x, acc_init_b = %08x\n",\r\nsrc_h, dst_h, factor, row_acc_init_rav,\r\nrow_acc_init_rav_b);\r\n} else {\r\nrow_acc_inc = ((src_h - 1) << 16) / (dst_h - 1);\r\nrow_acc_offset = 0;\r\nrow_acc_offset_b = 0;\r\ndev_dbg(dev, "vs config(POLY): src_h = %d, dst_h = %d,row_acc_inc = %08x\n",\r\nsrc_h, dst_h, row_acc_inc);\r\n}\r\nsc_reg0[0] = val;\r\nsc_reg0[1] = row_acc_inc;\r\nsc_reg0[2] = row_acc_offset;\r\nsc_reg0[3] = row_acc_offset_b;\r\nsc_reg0[4] = ((lin_acc_inc_u & CFG_LIN_ACC_INC_U_MASK) <<\r\nCFG_LIN_ACC_INC_U_SHIFT) | (dst_w << CFG_TAR_W_SHIFT) |\r\n(dst_h << CFG_TAR_H_SHIFT);\r\nsc_reg0[5] = (src_w << CFG_SRC_W_SHIFT) | (src_h << CFG_SRC_H_SHIFT);\r\nsc_reg0[6] = (row_acc_init_rav_b << CFG_ROW_ACC_INIT_RAV_B_SHIFT) |\r\n(row_acc_init_rav << CFG_ROW_ACC_INIT_RAV_SHIFT);\r\n*sc_reg9 = lin_acc_inc;\r\n*sc_reg12 = col_acc_offset << CFG_COL_ACC_OFFSET_SHIFT;\r\n*sc_reg13 = factor;\r\n*sc_reg24 = (src_w << CFG_ORG_W_SHIFT) | (src_h << CFG_ORG_H_SHIFT);\r\n}\r\nstruct sc_data *sc_create(struct platform_device *pdev)\r\n{\r\nstruct sc_data *sc;\r\ndev_dbg(&pdev->dev, "sc_create\n");\r\nsc = devm_kzalloc(&pdev->dev, sizeof(*sc), GFP_KERNEL);\r\nif (!sc) {\r\ndev_err(&pdev->dev, "couldn't alloc sc_data\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nsc->pdev = pdev;\r\nsc->res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "sc");\r\nif (!sc->res) {\r\ndev_err(&pdev->dev, "missing platform resources data\n");\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nsc->base = devm_ioremap_resource(&pdev->dev, sc->res);\r\nif (IS_ERR(sc->base)) {\r\ndev_err(&pdev->dev, "failed to ioremap\n");\r\nreturn ERR_CAST(sc->base);\r\n}\r\nreturn sc;\r\n}
