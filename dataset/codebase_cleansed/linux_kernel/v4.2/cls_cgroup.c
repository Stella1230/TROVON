static int cls_cgroup_classify(struct sk_buff *skb, const struct tcf_proto *tp,\r\nstruct tcf_result *res)\r\n{\r\nstruct cls_cgroup_head *head = rcu_dereference_bh(tp->root);\r\nu32 classid;\r\nclassid = task_cls_state(current)->classid;\r\nif (in_serving_softirq()) {\r\nif (!skb->sk)\r\nreturn -1;\r\nclassid = skb->sk->sk_classid;\r\n}\r\nif (!classid)\r\nreturn -1;\r\nif (!tcf_em_tree_match(skb, &head->ematches, NULL))\r\nreturn -1;\r\nres->classid = classid;\r\nres->class = 0;\r\nreturn tcf_exts_exec(skb, &head->exts, res);\r\n}\r\nstatic unsigned long cls_cgroup_get(struct tcf_proto *tp, u32 handle)\r\n{\r\nreturn 0UL;\r\n}\r\nstatic int cls_cgroup_init(struct tcf_proto *tp)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cls_cgroup_destroy_rcu(struct rcu_head *root)\r\n{\r\nstruct cls_cgroup_head *head = container_of(root,\r\nstruct cls_cgroup_head,\r\nrcu);\r\ntcf_exts_destroy(&head->exts);\r\ntcf_em_tree_destroy(&head->ematches);\r\nkfree(head);\r\n}\r\nstatic int cls_cgroup_change(struct net *net, struct sk_buff *in_skb,\r\nstruct tcf_proto *tp, unsigned long base,\r\nu32 handle, struct nlattr **tca,\r\nunsigned long *arg, bool ovr)\r\n{\r\nstruct nlattr *tb[TCA_CGROUP_MAX + 1];\r\nstruct cls_cgroup_head *head = rtnl_dereference(tp->root);\r\nstruct cls_cgroup_head *new;\r\nstruct tcf_ematch_tree t;\r\nstruct tcf_exts e;\r\nint err;\r\nif (!tca[TCA_OPTIONS])\r\nreturn -EINVAL;\r\nif (!head && !handle)\r\nreturn -EINVAL;\r\nif (head && handle != head->handle)\r\nreturn -ENOENT;\r\nnew = kzalloc(sizeof(*head), GFP_KERNEL);\r\nif (!new)\r\nreturn -ENOBUFS;\r\ntcf_exts_init(&new->exts, TCA_CGROUP_ACT, TCA_CGROUP_POLICE);\r\nnew->handle = handle;\r\nnew->tp = tp;\r\nerr = nla_parse_nested(tb, TCA_CGROUP_MAX, tca[TCA_OPTIONS],\r\ncgroup_policy);\r\nif (err < 0)\r\ngoto errout;\r\ntcf_exts_init(&e, TCA_CGROUP_ACT, TCA_CGROUP_POLICE);\r\nerr = tcf_exts_validate(net, tp, tb, tca[TCA_RATE], &e, ovr);\r\nif (err < 0)\r\ngoto errout;\r\nerr = tcf_em_tree_validate(tp, tb[TCA_CGROUP_EMATCHES], &t);\r\nif (err < 0) {\r\ntcf_exts_destroy(&e);\r\ngoto errout;\r\n}\r\ntcf_exts_change(tp, &new->exts, &e);\r\ntcf_em_tree_change(tp, &new->ematches, &t);\r\nrcu_assign_pointer(tp->root, new);\r\nif (head)\r\ncall_rcu(&head->rcu, cls_cgroup_destroy_rcu);\r\nreturn 0;\r\nerrout:\r\nkfree(new);\r\nreturn err;\r\n}\r\nstatic bool cls_cgroup_destroy(struct tcf_proto *tp, bool force)\r\n{\r\nstruct cls_cgroup_head *head = rtnl_dereference(tp->root);\r\nif (!force)\r\nreturn false;\r\nif (head) {\r\nRCU_INIT_POINTER(tp->root, NULL);\r\ncall_rcu(&head->rcu, cls_cgroup_destroy_rcu);\r\n}\r\nreturn true;\r\n}\r\nstatic int cls_cgroup_delete(struct tcf_proto *tp, unsigned long arg)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic void cls_cgroup_walk(struct tcf_proto *tp, struct tcf_walker *arg)\r\n{\r\nstruct cls_cgroup_head *head = rtnl_dereference(tp->root);\r\nif (arg->count < arg->skip)\r\ngoto skip;\r\nif (arg->fn(tp, (unsigned long) head, arg) < 0) {\r\narg->stop = 1;\r\nreturn;\r\n}\r\nskip:\r\narg->count++;\r\n}\r\nstatic int cls_cgroup_dump(struct net *net, struct tcf_proto *tp, unsigned long fh,\r\nstruct sk_buff *skb, struct tcmsg *t)\r\n{\r\nstruct cls_cgroup_head *head = rtnl_dereference(tp->root);\r\nstruct nlattr *nest;\r\nt->tcm_handle = head->handle;\r\nnest = nla_nest_start(skb, TCA_OPTIONS);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nif (tcf_exts_dump(skb, &head->exts) < 0 ||\r\ntcf_em_tree_dump(skb, &head->ematches, TCA_CGROUP_EMATCHES) < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest);\r\nif (tcf_exts_dump_stats(skb, &head->exts) < 0)\r\ngoto nla_put_failure;\r\nreturn skb->len;\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nest);\r\nreturn -1;\r\n}\r\nstatic int __init init_cgroup_cls(void)\r\n{\r\nreturn register_tcf_proto_ops(&cls_cgroup_ops);\r\n}\r\nstatic void __exit exit_cgroup_cls(void)\r\n{\r\nunregister_tcf_proto_ops(&cls_cgroup_ops);\r\n}
