static int mxuport_prepare_write_buffer(struct usb_serial_port *port,\r\nvoid *dest, size_t size)\r\n{\r\nu8 *buf = dest;\r\nint count;\r\ncount = kfifo_out_locked(&port->write_fifo, buf + HEADER_SIZE,\r\nsize - HEADER_SIZE,\r\n&port->lock);\r\nput_unaligned_be16(port->port_number, buf);\r\nput_unaligned_be16(count, buf + 2);\r\ndev_dbg(&port->dev, "%s - size %zd count %d\n", __func__,\r\nsize, count);\r\nreturn count + HEADER_SIZE;\r\n}\r\nstatic int mxuport_recv_ctrl_urb(struct usb_serial *serial,\r\nu8 request, u16 value, u16 index,\r\nu8 *data, size_t size)\r\n{\r\nint status;\r\nstatus = usb_control_msg(serial->dev,\r\nusb_rcvctrlpipe(serial->dev, 0),\r\nrequest,\r\n(USB_DIR_IN | USB_TYPE_VENDOR |\r\nUSB_RECIP_DEVICE), value, index,\r\ndata, size,\r\nUSB_CTRL_GET_TIMEOUT);\r\nif (status < 0) {\r\ndev_err(&serial->interface->dev,\r\n"%s - usb_control_msg failed (%d)\n",\r\n__func__, status);\r\nreturn status;\r\n}\r\nif (status != size) {\r\ndev_err(&serial->interface->dev,\r\n"%s - short read (%d / %zd)\n",\r\n__func__, status, size);\r\nreturn -EIO;\r\n}\r\nreturn status;\r\n}\r\nstatic int mxuport_send_ctrl_data_urb(struct usb_serial *serial,\r\nu8 request,\r\nu16 value, u16 index,\r\nu8 *data, size_t size)\r\n{\r\nint status;\r\nstatus = usb_control_msg(serial->dev,\r\nusb_sndctrlpipe(serial->dev, 0),\r\nrequest,\r\n(USB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_DEVICE), value, index,\r\ndata, size,\r\nUSB_CTRL_SET_TIMEOUT);\r\nif (status < 0) {\r\ndev_err(&serial->interface->dev,\r\n"%s - usb_control_msg failed (%d)\n",\r\n__func__, status);\r\nreturn status;\r\n}\r\nif (status != size) {\r\ndev_err(&serial->interface->dev,\r\n"%s - short write (%d / %zd)\n",\r\n__func__, status, size);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxuport_send_ctrl_urb(struct usb_serial *serial,\r\nu8 request, u16 value, u16 index)\r\n{\r\nreturn mxuport_send_ctrl_data_urb(serial, request, value, index,\r\nNULL, 0);\r\n}\r\nstatic void mxuport_throttle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial = port->serial;\r\ndev_dbg(&port->dev, "%s\n", __func__);\r\nmxuport_send_ctrl_urb(serial, RQ_VENDOR_SET_RX_HOST_EN,\r\n0, port->port_number);\r\n}\r\nstatic void mxuport_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial = port->serial;\r\ndev_dbg(&port->dev, "%s\n", __func__);\r\nmxuport_send_ctrl_urb(serial, RQ_VENDOR_SET_RX_HOST_EN,\r\n1, port->port_number);\r\n}\r\nstatic void mxuport_process_read_urb_data(struct usb_serial_port *port,\r\nchar *data, int size)\r\n{\r\nint i;\r\nif (!port->port.console || !port->sysrq) {\r\ntty_insert_flip_string(&port->port, data, size);\r\n} else {\r\nfor (i = 0; i < size; i++, data++) {\r\nif (!usb_serial_handle_sysrq_char(port, *data))\r\ntty_insert_flip_char(&port->port, *data,\r\nTTY_NORMAL);\r\n}\r\n}\r\ntty_flip_buffer_push(&port->port);\r\n}\r\nstatic void mxuport_msr_event(struct usb_serial_port *port, u8 buf[4])\r\n{\r\nstruct mxuport_port *mxport = usb_get_serial_port_data(port);\r\nu8 rcv_msr_hold = buf[2] & 0xF0;\r\nu16 rcv_msr_event = get_unaligned_be16(buf);\r\nunsigned long flags;\r\nif (rcv_msr_event == 0)\r\nreturn;\r\nspin_lock_irqsave(&mxport->spinlock, flags);\r\ndev_dbg(&port->dev, "%s - current MSR status = 0x%x\n",\r\n__func__, mxport->msr_state);\r\nif (rcv_msr_hold & UART_MSR_CTS) {\r\nmxport->msr_state |= UART_MSR_CTS;\r\ndev_dbg(&port->dev, "%s - CTS high\n", __func__);\r\n} else {\r\nmxport->msr_state &= ~UART_MSR_CTS;\r\ndev_dbg(&port->dev, "%s - CTS low\n", __func__);\r\n}\r\nif (rcv_msr_hold & UART_MSR_DSR) {\r\nmxport->msr_state |= UART_MSR_DSR;\r\ndev_dbg(&port->dev, "%s - DSR high\n", __func__);\r\n} else {\r\nmxport->msr_state &= ~UART_MSR_DSR;\r\ndev_dbg(&port->dev, "%s - DSR low\n", __func__);\r\n}\r\nif (rcv_msr_hold & UART_MSR_DCD) {\r\nmxport->msr_state |= UART_MSR_DCD;\r\ndev_dbg(&port->dev, "%s - DCD high\n", __func__);\r\n} else {\r\nmxport->msr_state &= ~UART_MSR_DCD;\r\ndev_dbg(&port->dev, "%s - DCD low\n", __func__);\r\n}\r\nspin_unlock_irqrestore(&mxport->spinlock, flags);\r\nif (rcv_msr_event &\r\n(SERIAL_EV_CTS | SERIAL_EV_DSR | SERIAL_EV_RLSD)) {\r\nif (rcv_msr_event & SERIAL_EV_CTS) {\r\nport->icount.cts++;\r\ndev_dbg(&port->dev, "%s - CTS change\n", __func__);\r\n}\r\nif (rcv_msr_event & SERIAL_EV_DSR) {\r\nport->icount.dsr++;\r\ndev_dbg(&port->dev, "%s - DSR change\n", __func__);\r\n}\r\nif (rcv_msr_event & SERIAL_EV_RLSD) {\r\nport->icount.dcd++;\r\ndev_dbg(&port->dev, "%s - DCD change\n", __func__);\r\n}\r\nwake_up_interruptible(&port->port.delta_msr_wait);\r\n}\r\n}\r\nstatic void mxuport_lsr_event(struct usb_serial_port *port, u8 buf[4])\r\n{\r\nu8 lsr_event = buf[2];\r\nif (lsr_event & UART_LSR_BI) {\r\nport->icount.brk++;\r\ndev_dbg(&port->dev, "%s - break error\n", __func__);\r\n}\r\nif (lsr_event & UART_LSR_FE) {\r\nport->icount.frame++;\r\ndev_dbg(&port->dev, "%s - frame error\n", __func__);\r\n}\r\nif (lsr_event & UART_LSR_PE) {\r\nport->icount.parity++;\r\ndev_dbg(&port->dev, "%s - parity error\n", __func__);\r\n}\r\nif (lsr_event & UART_LSR_OE) {\r\nport->icount.overrun++;\r\ndev_dbg(&port->dev, "%s - overrun error\n", __func__);\r\n}\r\n}\r\nstatic void mxuport_process_read_urb_event(struct usb_serial_port *port,\r\nu8 buf[4], u32 event)\r\n{\r\ndev_dbg(&port->dev, "%s - receive event : %04x\n", __func__, event);\r\nswitch (event) {\r\ncase UPORT_EVENT_SEND_NEXT:\r\nbreak;\r\ncase UPORT_EVENT_MSR:\r\nmxuport_msr_event(port, buf);\r\nbreak;\r\ncase UPORT_EVENT_LSR:\r\nmxuport_lsr_event(port, buf);\r\nbreak;\r\ncase UPORT_EVENT_MCR:\r\nbreak;\r\ndefault:\r\ndev_dbg(&port->dev, "Unexpected event\n");\r\nbreak;\r\n}\r\n}\r\nstatic void mxuport_process_read_urb_demux_data(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct usb_serial *serial = port->serial;\r\nu8 *data = urb->transfer_buffer;\r\nu8 *end = data + urb->actual_length;\r\nstruct usb_serial_port *demux_port;\r\nu8 *ch;\r\nu16 rcv_port;\r\nu16 rcv_len;\r\nwhile (data < end) {\r\nif (data + HEADER_SIZE > end) {\r\ndev_warn(&port->dev, "%s - message with short header\n",\r\n__func__);\r\nreturn;\r\n}\r\nrcv_port = get_unaligned_be16(data);\r\nif (rcv_port >= serial->num_ports) {\r\ndev_warn(&port->dev, "%s - message for invalid port\n",\r\n__func__);\r\nreturn;\r\n}\r\ndemux_port = serial->port[rcv_port];\r\nrcv_len = get_unaligned_be16(data + 2);\r\nif (!rcv_len || data + HEADER_SIZE + rcv_len > end) {\r\ndev_warn(&port->dev, "%s - short data\n", __func__);\r\nreturn;\r\n}\r\nif (test_bit(ASYNCB_INITIALIZED, &demux_port->port.flags)) {\r\nch = data + HEADER_SIZE;\r\nmxuport_process_read_urb_data(demux_port, ch, rcv_len);\r\n} else {\r\ndev_dbg(&demux_port->dev, "%s - data for closed port\n",\r\n__func__);\r\n}\r\ndata += HEADER_SIZE + rcv_len;\r\n}\r\n}\r\nstatic void mxuport_process_read_urb_demux_event(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct usb_serial *serial = port->serial;\r\nu8 *data = urb->transfer_buffer;\r\nu8 *end = data + urb->actual_length;\r\nstruct usb_serial_port *demux_port;\r\nu8 *ch;\r\nu16 rcv_port;\r\nu16 rcv_event;\r\nwhile (data < end) {\r\nif (data + EVENT_LENGTH > end) {\r\ndev_warn(&port->dev, "%s - message with short event\n",\r\n__func__);\r\nreturn;\r\n}\r\nrcv_port = get_unaligned_be16(data);\r\nif (rcv_port >= serial->num_ports) {\r\ndev_warn(&port->dev, "%s - message for invalid port\n",\r\n__func__);\r\nreturn;\r\n}\r\ndemux_port = serial->port[rcv_port];\r\nif (test_bit(ASYNCB_INITIALIZED, &demux_port->port.flags)) {\r\nch = data + HEADER_SIZE;\r\nrcv_event = get_unaligned_be16(data + 2);\r\nmxuport_process_read_urb_event(demux_port, ch,\r\nrcv_event);\r\n} else {\r\ndev_dbg(&demux_port->dev,\r\n"%s - event for closed port\n", __func__);\r\n}\r\ndata += EVENT_LENGTH;\r\n}\r\n}\r\nstatic void mxuport_process_read_urb(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct usb_serial *serial = port->serial;\r\nif (port == serial->port[0])\r\nmxuport_process_read_urb_demux_data(urb);\r\nif (port == serial->port[1])\r\nmxuport_process_read_urb_demux_event(urb);\r\n}\r\nstatic bool mxuport_tx_empty(struct usb_serial_port *port)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nbool is_empty = true;\r\nu32 txlen;\r\nu8 *len_buf;\r\nint err;\r\nlen_buf = kzalloc(4, GFP_KERNEL);\r\nif (!len_buf)\r\ngoto out;\r\nerr = mxuport_recv_ctrl_urb(serial, RQ_VENDOR_GET_OUTQUEUE, 0,\r\nport->port_number, len_buf, 4);\r\nif (err < 0)\r\ngoto out;\r\ntxlen = get_unaligned_be32(len_buf);\r\ndev_dbg(&port->dev, "%s - tx len = %u\n", __func__, txlen);\r\nif (txlen != 0)\r\nis_empty = false;\r\nout:\r\nkfree(len_buf);\r\nreturn is_empty;\r\n}\r\nstatic int mxuport_set_mcr(struct usb_serial_port *port, u8 mcr_state)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nint err;\r\ndev_dbg(&port->dev, "%s - %02x\n", __func__, mcr_state);\r\nerr = mxuport_send_ctrl_urb(serial, RQ_VENDOR_SET_MCR,\r\nmcr_state, port->port_number);\r\nif (err)\r\ndev_err(&port->dev, "%s - failed to change MCR\n", __func__);\r\nreturn err;\r\n}\r\nstatic int mxuport_set_dtr(struct usb_serial_port *port, int on)\r\n{\r\nstruct mxuport_port *mxport = usb_get_serial_port_data(port);\r\nstruct usb_serial *serial = port->serial;\r\nint err;\r\nmutex_lock(&mxport->mutex);\r\nerr = mxuport_send_ctrl_urb(serial, RQ_VENDOR_SET_DTR,\r\n!!on, port->port_number);\r\nif (!err) {\r\nif (on)\r\nmxport->mcr_state |= UART_MCR_DTR;\r\nelse\r\nmxport->mcr_state &= ~UART_MCR_DTR;\r\n}\r\nmutex_unlock(&mxport->mutex);\r\nreturn err;\r\n}\r\nstatic int mxuport_set_rts(struct usb_serial_port *port, u8 state)\r\n{\r\nstruct mxuport_port *mxport = usb_get_serial_port_data(port);\r\nstruct usb_serial *serial = port->serial;\r\nint err;\r\nu8 mcr_state;\r\nmutex_lock(&mxport->mutex);\r\nmcr_state = mxport->mcr_state;\r\nswitch (state) {\r\ncase MX_RTS_DISABLE:\r\nmcr_state &= ~UART_MCR_RTS;\r\nbreak;\r\ncase MX_RTS_ENABLE:\r\nmcr_state |= UART_MCR_RTS;\r\nbreak;\r\ncase MX_RTS_HW:\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nerr = mxuport_send_ctrl_urb(serial, RQ_VENDOR_SET_RTS,\r\nstate, port->port_number);\r\nif (!err)\r\nmxport->mcr_state = mcr_state;\r\nout:\r\nmutex_unlock(&mxport->mutex);\r\nreturn err;\r\n}\r\nstatic void mxuport_dtr_rts(struct usb_serial_port *port, int on)\r\n{\r\nstruct mxuport_port *mxport = usb_get_serial_port_data(port);\r\nu8 mcr_state;\r\nint err;\r\nmutex_lock(&mxport->mutex);\r\nmcr_state = mxport->mcr_state;\r\nif (on)\r\nmcr_state |= (UART_MCR_RTS | UART_MCR_DTR);\r\nelse\r\nmcr_state &= ~(UART_MCR_RTS | UART_MCR_DTR);\r\nerr = mxuport_set_mcr(port, mcr_state);\r\nif (!err)\r\nmxport->mcr_state = mcr_state;\r\nmutex_unlock(&mxport->mutex);\r\n}\r\nstatic int mxuport_tiocmset(struct tty_struct *tty, unsigned int set,\r\nunsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct mxuport_port *mxport = usb_get_serial_port_data(port);\r\nint err;\r\nu8 mcr_state;\r\nmutex_lock(&mxport->mutex);\r\nmcr_state = mxport->mcr_state;\r\nif (set & TIOCM_RTS)\r\nmcr_state |= UART_MCR_RTS;\r\nif (set & TIOCM_DTR)\r\nmcr_state |= UART_MCR_DTR;\r\nif (clear & TIOCM_RTS)\r\nmcr_state &= ~UART_MCR_RTS;\r\nif (clear & TIOCM_DTR)\r\nmcr_state &= ~UART_MCR_DTR;\r\nerr = mxuport_set_mcr(port, mcr_state);\r\nif (!err)\r\nmxport->mcr_state = mcr_state;\r\nmutex_unlock(&mxport->mutex);\r\nreturn err;\r\n}\r\nstatic int mxuport_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct mxuport_port *mxport;\r\nstruct usb_serial_port *port = tty->driver_data;\r\nunsigned int result;\r\nunsigned long flags;\r\nunsigned int msr;\r\nunsigned int mcr;\r\nmxport = usb_get_serial_port_data(port);\r\nmutex_lock(&mxport->mutex);\r\nspin_lock_irqsave(&mxport->spinlock, flags);\r\nmsr = mxport->msr_state;\r\nmcr = mxport->mcr_state;\r\nspin_unlock_irqrestore(&mxport->spinlock, flags);\r\nmutex_unlock(&mxport->mutex);\r\nresult = (((mcr & UART_MCR_DTR) ? TIOCM_DTR : 0) |\r\n((mcr & UART_MCR_RTS) ? TIOCM_RTS : 0) |\r\n((msr & UART_MSR_CTS) ? TIOCM_CTS : 0) |\r\n((msr & UART_MSR_DCD) ? TIOCM_CAR : 0) |\r\n((msr & UART_MSR_RI) ? TIOCM_RI : 0) |\r\n((msr & UART_MSR_DSR) ? TIOCM_DSR : 0));\r\ndev_dbg(&port->dev, "%s - 0x%04x\n", __func__, result);\r\nreturn result;\r\n}\r\nstatic int mxuport_set_termios_flow(struct tty_struct *tty,\r\nstruct ktermios *old_termios,\r\nstruct usb_serial_port *port,\r\nstruct usb_serial *serial)\r\n{\r\nu8 xon = START_CHAR(tty);\r\nu8 xoff = STOP_CHAR(tty);\r\nint enable;\r\nint err;\r\nu8 *buf;\r\nu8 rts;\r\nbuf = kmalloc(2, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (I_IXOFF(tty) || I_IXON(tty)) {\r\nenable = 1;\r\nbuf[0] = xon;\r\nbuf[1] = xoff;\r\nerr = mxuport_send_ctrl_data_urb(serial, RQ_VENDOR_SET_CHARS,\r\n0, port->port_number,\r\nbuf, 2);\r\nif (err)\r\ngoto out;\r\ndev_dbg(&port->dev, "%s - XON = 0x%02x, XOFF = 0x%02x\n",\r\n__func__, xon, xoff);\r\n} else {\r\nenable = 0;\r\n}\r\nerr = mxuport_send_ctrl_urb(serial, RQ_VENDOR_SET_XONXOFF,\r\nenable, port->port_number);\r\nif (err)\r\ngoto out;\r\nrts = MX_RTS_NO_CHANGE;\r\nif (!old_termios ||\r\nC_CRTSCTS(tty) != (old_termios->c_cflag & CRTSCTS)) {\r\nif (C_CRTSCTS(tty))\r\nrts = MX_RTS_HW;\r\nelse\r\nrts = MX_RTS_ENABLE;\r\n}\r\nif (C_BAUD(tty)) {\r\nif (old_termios && (old_termios->c_cflag & CBAUD) == B0) {\r\nif (C_CRTSCTS(tty))\r\nrts = MX_RTS_HW;\r\nelse\r\nrts = MX_RTS_ENABLE;\r\nmxuport_set_dtr(port, 1);\r\n}\r\n} else {\r\nrts = MX_RTS_DISABLE;\r\nmxuport_set_dtr(port, 0);\r\n}\r\nif (rts != MX_RTS_NO_CHANGE)\r\nerr = mxuport_set_rts(port, rts);\r\nout:\r\nkfree(buf);\r\nreturn err;\r\n}\r\nstatic void mxuport_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port,\r\nstruct ktermios *old_termios)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nu8 *buf;\r\nu8 data_bits;\r\nu8 stop_bits;\r\nu8 parity;\r\nint baud;\r\nint err;\r\nif (old_termios &&\r\n!tty_termios_hw_change(&tty->termios, old_termios) &&\r\ntty->termios.c_iflag == old_termios->c_iflag) {\r\ndev_dbg(&port->dev, "%s - nothing to change\n", __func__);\r\nreturn;\r\n}\r\nbuf = kmalloc(4, GFP_KERNEL);\r\nif (!buf)\r\nreturn;\r\nswitch (C_CSIZE(tty)) {\r\ncase CS5:\r\ndata_bits = MX_WORDLENGTH_5;\r\nbreak;\r\ncase CS6:\r\ndata_bits = MX_WORDLENGTH_6;\r\nbreak;\r\ncase CS7:\r\ndata_bits = MX_WORDLENGTH_7;\r\nbreak;\r\ncase CS8:\r\ndefault:\r\ndata_bits = MX_WORDLENGTH_8;\r\nbreak;\r\n}\r\nif (C_PARENB(tty)) {\r\nif (C_CMSPAR(tty)) {\r\nif (C_PARODD(tty))\r\nparity = MX_PARITY_MARK;\r\nelse\r\nparity = MX_PARITY_SPACE;\r\n} else {\r\nif (C_PARODD(tty))\r\nparity = MX_PARITY_ODD;\r\nelse\r\nparity = MX_PARITY_EVEN;\r\n}\r\n} else {\r\nparity = MX_PARITY_NONE;\r\n}\r\nif (C_CSTOPB(tty))\r\nstop_bits = MX_STOP_BITS_2;\r\nelse\r\nstop_bits = MX_STOP_BITS_1;\r\nbuf[0] = data_bits;\r\nbuf[1] = parity;\r\nbuf[2] = stop_bits;\r\nbuf[3] = 0;\r\nerr = mxuport_send_ctrl_data_urb(serial, RQ_VENDOR_SET_LINE,\r\n0, port->port_number, buf, 4);\r\nif (err)\r\ngoto out;\r\nerr = mxuport_set_termios_flow(tty, old_termios, port, serial);\r\nif (err)\r\ngoto out;\r\nbaud = tty_get_baud_rate(tty);\r\nif (!baud)\r\nbaud = 9600;\r\nput_unaligned_le32(baud, buf);\r\nerr = mxuport_send_ctrl_data_urb(serial, RQ_VENDOR_SET_BAUD,\r\n0, port->port_number,\r\nbuf, 4);\r\nif (err)\r\ngoto out;\r\ndev_dbg(&port->dev, "baud_rate : %d\n", baud);\r\ndev_dbg(&port->dev, "data_bits : %d\n", data_bits);\r\ndev_dbg(&port->dev, "parity : %d\n", parity);\r\ndev_dbg(&port->dev, "stop_bits : %d\n", stop_bits);\r\nout:\r\nkfree(buf);\r\n}\r\nstatic int mxuport_calc_num_ports(struct usb_serial *serial)\r\n{\r\nunsigned long features = (unsigned long)usb_get_serial_data(serial);\r\nif (features & MX_UPORT_2_PORT)\r\nreturn 2;\r\nif (features & MX_UPORT_4_PORT)\r\nreturn 4;\r\nif (features & MX_UPORT_8_PORT)\r\nreturn 8;\r\nif (features & MX_UPORT_16_PORT)\r\nreturn 16;\r\nreturn 0;\r\n}\r\nstatic int mxuport_get_fw_version(struct usb_serial *serial, u32 *version)\r\n{\r\nu8 *ver_buf;\r\nint err;\r\nver_buf = kzalloc(4, GFP_KERNEL);\r\nif (!ver_buf)\r\nreturn -ENOMEM;\r\nerr = mxuport_recv_ctrl_urb(serial, RQ_VENDOR_GET_VERSION, 0, 0,\r\nver_buf, 4);\r\nif (err != 4) {\r\nerr = -EIO;\r\ngoto out;\r\n}\r\n*version = (ver_buf[0] << 16) | (ver_buf[1] << 8) | ver_buf[2];\r\nerr = 0;\r\nout:\r\nkfree(ver_buf);\r\nreturn err;\r\n}\r\nstatic int mxuport_download_fw(struct usb_serial *serial,\r\nconst struct firmware *fw_p)\r\n{\r\nu8 *fw_buf;\r\nsize_t txlen;\r\nsize_t fwidx;\r\nint err;\r\nfw_buf = kmalloc(DOWN_BLOCK_SIZE, GFP_KERNEL);\r\nif (!fw_buf)\r\nreturn -ENOMEM;\r\ndev_dbg(&serial->interface->dev, "Starting firmware download...\n");\r\nerr = mxuport_send_ctrl_urb(serial, RQ_VENDOR_START_FW_DOWN, 0, 0);\r\nif (err)\r\ngoto out;\r\nfwidx = 0;\r\ndo {\r\ntxlen = min_t(size_t, (fw_p->size - fwidx), DOWN_BLOCK_SIZE);\r\nmemcpy(fw_buf, &fw_p->data[fwidx], txlen);\r\nerr = mxuport_send_ctrl_data_urb(serial, RQ_VENDOR_FW_DATA,\r\n0, 0, fw_buf, txlen);\r\nif (err) {\r\nmxuport_send_ctrl_urb(serial, RQ_VENDOR_STOP_FW_DOWN,\r\n0, 0);\r\ngoto out;\r\n}\r\nfwidx += txlen;\r\nusleep_range(1000, 2000);\r\n} while (fwidx < fw_p->size);\r\nmsleep(1000);\r\nerr = mxuport_send_ctrl_urb(serial, RQ_VENDOR_STOP_FW_DOWN, 0, 0);\r\nif (err)\r\ngoto out;\r\nmsleep(1000);\r\nerr = mxuport_send_ctrl_urb(serial, RQ_VENDOR_QUERY_FW_READY, 0, 0);\r\nout:\r\nkfree(fw_buf);\r\nreturn err;\r\n}\r\nstatic int mxuport_probe(struct usb_serial *serial,\r\nconst struct usb_device_id *id)\r\n{\r\nu16 productid = le16_to_cpu(serial->dev->descriptor.idProduct);\r\nconst struct firmware *fw_p = NULL;\r\nu32 version;\r\nint local_ver;\r\nchar buf[32];\r\nint err;\r\nerr = mxuport_send_ctrl_urb(serial, RQ_VENDOR_QUERY_FW_CONFIG, 0, 0);\r\nif (err) {\r\nmxuport_send_ctrl_urb(serial, RQ_VENDOR_RESET_DEVICE, 0, 0);\r\nreturn err;\r\n}\r\nerr = mxuport_get_fw_version(serial, &version);\r\nif (err < 0)\r\nreturn err;\r\ndev_dbg(&serial->interface->dev, "Device firmware version v%x.%x.%x\n",\r\n(version & 0xff0000) >> 16,\r\n(version & 0xff00) >> 8,\r\n(version & 0xff));\r\nsnprintf(buf, sizeof(buf) - 1, "moxa/moxa-%04x.fw", productid);\r\nerr = request_firmware(&fw_p, buf, &serial->interface->dev);\r\nif (err) {\r\ndev_warn(&serial->interface->dev, "Firmware %s not found\n",\r\nbuf);\r\nerr = 0;\r\n} else {\r\nlocal_ver = ((fw_p->data[VER_ADDR_1] << 16) |\r\n(fw_p->data[VER_ADDR_2] << 8) |\r\nfw_p->data[VER_ADDR_3]);\r\ndev_dbg(&serial->interface->dev,\r\n"Available firmware version v%x.%x.%x\n",\r\nfw_p->data[VER_ADDR_1], fw_p->data[VER_ADDR_2],\r\nfw_p->data[VER_ADDR_3]);\r\nif (local_ver > version) {\r\nerr = mxuport_download_fw(serial, fw_p);\r\nif (err)\r\ngoto out;\r\nerr = mxuport_get_fw_version(serial, &version);\r\nif (err < 0)\r\ngoto out;\r\n}\r\n}\r\ndev_info(&serial->interface->dev,\r\n"Using device firmware version v%x.%x.%x\n",\r\n(version & 0xff0000) >> 16,\r\n(version & 0xff00) >> 8,\r\n(version & 0xff));\r\nusb_set_serial_data(serial, (void *)id->driver_info);\r\nout:\r\nif (fw_p)\r\nrelease_firmware(fw_p);\r\nreturn err;\r\n}\r\nstatic int mxuport_port_probe(struct usb_serial_port *port)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nstruct mxuport_port *mxport;\r\nint err;\r\nmxport = devm_kzalloc(&port->dev, sizeof(struct mxuport_port),\r\nGFP_KERNEL);\r\nif (!mxport)\r\nreturn -ENOMEM;\r\nmutex_init(&mxport->mutex);\r\nspin_lock_init(&mxport->spinlock);\r\nusb_set_serial_port_data(port, mxport);\r\nerr = mxuport_send_ctrl_urb(serial, RQ_VENDOR_SET_FIFO_DISABLE,\r\n0, port->port_number);\r\nif (err)\r\nreturn err;\r\nerr = mxuport_send_ctrl_urb(serial, RQ_VENDOR_SET_HIGH_PERFOR,\r\n0, port->port_number);\r\nif (err)\r\nreturn err;\r\nerr = mxuport_send_ctrl_urb(serial, RQ_VENDOR_SET_INTERFACE,\r\nMX_INT_RS232,\r\nport->port_number);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int mxuport_alloc_write_urb(struct usb_serial *serial,\r\nstruct usb_serial_port *port,\r\nstruct usb_serial_port *port0,\r\nint j)\r\n{\r\nstruct usb_device *dev = interface_to_usbdev(serial->interface);\r\nset_bit(j, &port->write_urbs_free);\r\nport->write_urbs[j] = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!port->write_urbs[j])\r\nreturn -ENOMEM;\r\nport->bulk_out_buffers[j] = kmalloc(port0->bulk_out_size, GFP_KERNEL);\r\nif (!port->bulk_out_buffers[j])\r\nreturn -ENOMEM;\r\nusb_fill_bulk_urb(port->write_urbs[j], dev,\r\nusb_sndbulkpipe(dev, port->bulk_out_endpointAddress),\r\nport->bulk_out_buffers[j],\r\nport->bulk_out_size,\r\nserial->type->write_bulk_callback,\r\nport);\r\nreturn 0;\r\n}\r\nstatic int mxuport_alloc_write_urbs(struct usb_serial *serial,\r\nstruct usb_serial_port *port,\r\nstruct usb_serial_port *port0)\r\n{\r\nint j;\r\nint ret;\r\nfor (j = 0; j < ARRAY_SIZE(port->write_urbs); ++j) {\r\nret = mxuport_alloc_write_urb(serial, port, port0, j);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxuport_attach(struct usb_serial *serial)\r\n{\r\nstruct usb_serial_port *port0 = serial->port[0];\r\nstruct usb_serial_port *port1 = serial->port[1];\r\nstruct usb_serial_port *port;\r\nint err;\r\nint i;\r\nint j;\r\nfor (i = 1; i < serial->num_bulk_out; ++i) {\r\nport = serial->port[i];\r\nfor (j = 0; j < ARRAY_SIZE(port->write_urbs); ++j) {\r\nusb_free_urb(port->write_urbs[j]);\r\nkfree(port->bulk_out_buffers[j]);\r\nport->write_urbs[j] = NULL;\r\nport->bulk_out_buffers[j] = NULL;\r\n}\r\nport->write_urbs_free = 0;\r\n}\r\nfor (i = 1; i < serial->num_ports; ++i) {\r\nport = serial->port[i];\r\nport->bulk_out_size = port0->bulk_out_size;\r\nport->bulk_out_endpointAddress =\r\nport0->bulk_out_endpointAddress;\r\nerr = mxuport_alloc_write_urbs(serial, port, port0);\r\nif (err)\r\nreturn err;\r\nport->write_urb = port->write_urbs[0];\r\nport->bulk_out_buffer = port->bulk_out_buffers[0];\r\nif (!kfifo_initialized(&port->write_fifo)) {\r\nerr = kfifo_alloc(&port->write_fifo, PAGE_SIZE,\r\nGFP_KERNEL);\r\nif (err)\r\nreturn err;\r\n}\r\n}\r\nerr = usb_serial_generic_submit_read_urbs(port0, GFP_KERNEL);\r\nif (err)\r\nreturn err;\r\nerr = usb_serial_generic_submit_read_urbs(port1, GFP_KERNEL);\r\nif (err) {\r\nusb_serial_generic_close(port0);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxuport_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct mxuport_port *mxport = usb_get_serial_port_data(port);\r\nstruct usb_serial *serial = port->serial;\r\nint err;\r\nerr = mxuport_send_ctrl_urb(serial, RQ_VENDOR_SET_RX_HOST_EN,\r\n1, port->port_number);\r\nif (err)\r\nreturn err;\r\nerr = mxuport_send_ctrl_urb(serial, RQ_VENDOR_SET_OPEN,\r\n1, port->port_number);\r\nif (err) {\r\nmxuport_send_ctrl_urb(serial, RQ_VENDOR_SET_RX_HOST_EN,\r\n0, port->port_number);\r\nreturn err;\r\n}\r\nif (tty)\r\nmxuport_set_termios(tty, port, NULL);\r\nmxport->msr_state = 0;\r\nreturn err;\r\n}\r\nstatic void mxuport_close(struct usb_serial_port *port)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nmxuport_send_ctrl_urb(serial, RQ_VENDOR_SET_OPEN, 0,\r\nport->port_number);\r\nmxuport_send_ctrl_urb(serial, RQ_VENDOR_SET_RX_HOST_EN, 0,\r\nport->port_number);\r\n}\r\nstatic void mxuport_break_ctl(struct tty_struct *tty, int break_state)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial = port->serial;\r\nint enable;\r\nif (break_state == -1) {\r\nenable = 1;\r\ndev_dbg(&port->dev, "%s - sending break\n", __func__);\r\n} else {\r\nenable = 0;\r\ndev_dbg(&port->dev, "%s - clearing break\n", __func__);\r\n}\r\nmxuport_send_ctrl_urb(serial, RQ_VENDOR_SET_BREAK,\r\nenable, port->port_number);\r\n}\r\nstatic int mxuport_resume(struct usb_serial *serial)\r\n{\r\nstruct usb_serial_port *port;\r\nint c = 0;\r\nint i;\r\nint r;\r\nfor (i = 0; i < 2; i++) {\r\nport = serial->port[i];\r\nr = usb_serial_generic_submit_read_urbs(port, GFP_NOIO);\r\nif (r < 0)\r\nc++;\r\n}\r\nfor (i = 0; i < serial->num_ports; i++) {\r\nport = serial->port[i];\r\nif (!test_bit(ASYNCB_INITIALIZED, &port->port.flags))\r\ncontinue;\r\nr = usb_serial_generic_write_start(port, GFP_NOIO);\r\nif (r < 0)\r\nc++;\r\n}\r\nreturn c ? -EIO : 0;\r\n}
