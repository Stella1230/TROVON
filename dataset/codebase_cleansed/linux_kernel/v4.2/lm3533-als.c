static int lm3533_als_get_adc(struct iio_dev *indio_dev, bool average,\r\nint *adc)\r\n{\r\nstruct lm3533_als *als = iio_priv(indio_dev);\r\nu8 reg;\r\nu8 val;\r\nint ret;\r\nif (average)\r\nreg = LM3533_REG_ALS_READ_ADC_AVERAGE;\r\nelse\r\nreg = LM3533_REG_ALS_READ_ADC_RAW;\r\nret = lm3533_read(als->lm3533, reg, &val);\r\nif (ret) {\r\ndev_err(&indio_dev->dev, "failed to read adc\n");\r\nreturn ret;\r\n}\r\n*adc = val;\r\nreturn 0;\r\n}\r\nstatic int _lm3533_als_get_zone(struct iio_dev *indio_dev, u8 *zone)\r\n{\r\nstruct lm3533_als *als = iio_priv(indio_dev);\r\nu8 val;\r\nint ret;\r\nret = lm3533_read(als->lm3533, LM3533_REG_ALS_ZONE_INFO, &val);\r\nif (ret) {\r\ndev_err(&indio_dev->dev, "failed to read zone\n");\r\nreturn ret;\r\n}\r\nval = (val & LM3533_ALS_ZONE_MASK) >> LM3533_ALS_ZONE_SHIFT;\r\n*zone = min_t(u8, val, LM3533_ALS_ZONE_MAX);\r\nreturn 0;\r\n}\r\nstatic int lm3533_als_get_zone(struct iio_dev *indio_dev, u8 *zone)\r\n{\r\nstruct lm3533_als *als = iio_priv(indio_dev);\r\nint ret;\r\nif (test_bit(LM3533_ALS_FLAG_INT_ENABLED, &als->flags)) {\r\n*zone = atomic_read(&als->zone);\r\n} else {\r\nret = _lm3533_als_get_zone(indio_dev, zone);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline u8 lm3533_als_get_target_reg(unsigned channel, unsigned zone)\r\n{\r\nreturn LM3533_REG_ALS_TARGET_BASE + 5 * channel + zone;\r\n}\r\nstatic int lm3533_als_get_target(struct iio_dev *indio_dev, unsigned channel,\r\nunsigned zone, u8 *val)\r\n{\r\nstruct lm3533_als *als = iio_priv(indio_dev);\r\nu8 reg;\r\nint ret;\r\nif (channel > LM3533_ALS_CHANNEL_CURRENT_MAX)\r\nreturn -EINVAL;\r\nif (zone > LM3533_ALS_ZONE_MAX)\r\nreturn -EINVAL;\r\nreg = lm3533_als_get_target_reg(channel, zone);\r\nret = lm3533_read(als->lm3533, reg, val);\r\nif (ret)\r\ndev_err(&indio_dev->dev, "failed to get target current\n");\r\nreturn ret;\r\n}\r\nstatic int lm3533_als_set_target(struct iio_dev *indio_dev, unsigned channel,\r\nunsigned zone, u8 val)\r\n{\r\nstruct lm3533_als *als = iio_priv(indio_dev);\r\nu8 reg;\r\nint ret;\r\nif (channel > LM3533_ALS_CHANNEL_CURRENT_MAX)\r\nreturn -EINVAL;\r\nif (zone > LM3533_ALS_ZONE_MAX)\r\nreturn -EINVAL;\r\nreg = lm3533_als_get_target_reg(channel, zone);\r\nret = lm3533_write(als->lm3533, reg, val);\r\nif (ret)\r\ndev_err(&indio_dev->dev, "failed to set target current\n");\r\nreturn ret;\r\n}\r\nstatic int lm3533_als_get_current(struct iio_dev *indio_dev, unsigned channel,\r\nint *val)\r\n{\r\nu8 zone;\r\nu8 target;\r\nint ret;\r\nret = lm3533_als_get_zone(indio_dev, &zone);\r\nif (ret)\r\nreturn ret;\r\nret = lm3533_als_get_target(indio_dev, channel, zone, &target);\r\nif (ret)\r\nreturn ret;\r\n*val = target;\r\nreturn 0;\r\n}\r\nstatic int lm3533_als_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nint ret;\r\nswitch (mask) {\r\ncase 0:\r\nswitch (chan->type) {\r\ncase IIO_LIGHT:\r\nret = lm3533_als_get_adc(indio_dev, false, val);\r\nbreak;\r\ncase IIO_CURRENT:\r\nret = lm3533_als_get_current(indio_dev, chan->channel,\r\nval);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase IIO_CHAN_INFO_AVERAGE_RAW:\r\nret = lm3533_als_get_adc(indio_dev, true, val);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (ret)\r\nreturn ret;\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic irqreturn_t lm3533_als_isr(int irq, void *dev_id)\r\n{\r\nstruct iio_dev *indio_dev = dev_id;\r\nstruct lm3533_als *als = iio_priv(indio_dev);\r\nu8 zone;\r\nint ret;\r\nret = _lm3533_als_get_zone(indio_dev, &zone);\r\nif (ret)\r\ngoto out;\r\natomic_set(&als->zone, zone);\r\niio_push_event(indio_dev,\r\nIIO_UNMOD_EVENT_CODE(IIO_LIGHT,\r\n0,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_EITHER),\r\niio_get_time_ns());\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int lm3533_als_set_int_mode(struct iio_dev *indio_dev, int enable)\r\n{\r\nstruct lm3533_als *als = iio_priv(indio_dev);\r\nu8 mask = LM3533_ALS_INT_ENABLE_MASK;\r\nu8 val;\r\nint ret;\r\nif (enable)\r\nval = mask;\r\nelse\r\nval = 0;\r\nret = lm3533_update(als->lm3533, LM3533_REG_ALS_ZONE_INFO, val, mask);\r\nif (ret) {\r\ndev_err(&indio_dev->dev, "failed to set int mode %d\n",\r\nenable);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lm3533_als_get_int_mode(struct iio_dev *indio_dev, int *enable)\r\n{\r\nstruct lm3533_als *als = iio_priv(indio_dev);\r\nu8 mask = LM3533_ALS_INT_ENABLE_MASK;\r\nu8 val;\r\nint ret;\r\nret = lm3533_read(als->lm3533, LM3533_REG_ALS_ZONE_INFO, &val);\r\nif (ret) {\r\ndev_err(&indio_dev->dev, "failed to get int mode\n");\r\nreturn ret;\r\n}\r\n*enable = !!(val & mask);\r\nreturn 0;\r\n}\r\nstatic inline u8 lm3533_als_get_threshold_reg(unsigned nr, bool raising)\r\n{\r\nu8 offset = !raising;\r\nreturn LM3533_REG_ALS_BOUNDARY_BASE + 2 * nr + offset;\r\n}\r\nstatic int lm3533_als_get_threshold(struct iio_dev *indio_dev, unsigned nr,\r\nbool raising, u8 *val)\r\n{\r\nstruct lm3533_als *als = iio_priv(indio_dev);\r\nu8 reg;\r\nint ret;\r\nif (nr > LM3533_ALS_THRESH_MAX)\r\nreturn -EINVAL;\r\nreg = lm3533_als_get_threshold_reg(nr, raising);\r\nret = lm3533_read(als->lm3533, reg, val);\r\nif (ret)\r\ndev_err(&indio_dev->dev, "failed to get threshold\n");\r\nreturn ret;\r\n}\r\nstatic int lm3533_als_set_threshold(struct iio_dev *indio_dev, unsigned nr,\r\nbool raising, u8 val)\r\n{\r\nstruct lm3533_als *als = iio_priv(indio_dev);\r\nu8 val2;\r\nu8 reg, reg2;\r\nint ret;\r\nif (nr > LM3533_ALS_THRESH_MAX)\r\nreturn -EINVAL;\r\nreg = lm3533_als_get_threshold_reg(nr, raising);\r\nreg2 = lm3533_als_get_threshold_reg(nr, !raising);\r\nmutex_lock(&als->thresh_mutex);\r\nret = lm3533_read(als->lm3533, reg2, &val2);\r\nif (ret) {\r\ndev_err(&indio_dev->dev, "failed to get threshold\n");\r\ngoto out;\r\n}\r\nif ((raising && (val < val2)) || (!raising && (val > val2))) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = lm3533_write(als->lm3533, reg, val);\r\nif (ret) {\r\ndev_err(&indio_dev->dev, "failed to set threshold\n");\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&als->thresh_mutex);\r\nreturn ret;\r\n}\r\nstatic int lm3533_als_get_hysteresis(struct iio_dev *indio_dev, unsigned nr,\r\nu8 *val)\r\n{\r\nstruct lm3533_als *als = iio_priv(indio_dev);\r\nu8 falling;\r\nu8 raising;\r\nint ret;\r\nif (nr > LM3533_ALS_THRESH_MAX)\r\nreturn -EINVAL;\r\nmutex_lock(&als->thresh_mutex);\r\nret = lm3533_als_get_threshold(indio_dev, nr, false, &falling);\r\nif (ret)\r\ngoto out;\r\nret = lm3533_als_get_threshold(indio_dev, nr, true, &raising);\r\nif (ret)\r\ngoto out;\r\n*val = raising - falling;\r\nout:\r\nmutex_unlock(&als->thresh_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t show_thresh_either_en(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct lm3533_als *als = iio_priv(indio_dev);\r\nint enable;\r\nint ret;\r\nif (als->irq) {\r\nret = lm3533_als_get_int_mode(indio_dev, &enable);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nenable = 0;\r\n}\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", enable);\r\n}\r\nstatic ssize_t store_thresh_either_en(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct lm3533_als *als = iio_priv(indio_dev);\r\nunsigned long enable;\r\nbool int_enabled;\r\nu8 zone;\r\nint ret;\r\nif (!als->irq)\r\nreturn -EBUSY;\r\nif (kstrtoul(buf, 0, &enable))\r\nreturn -EINVAL;\r\nint_enabled = test_bit(LM3533_ALS_FLAG_INT_ENABLED, &als->flags);\r\nif (enable && !int_enabled) {\r\nret = lm3533_als_get_zone(indio_dev, &zone);\r\nif (ret)\r\nreturn ret;\r\natomic_set(&als->zone, zone);\r\nset_bit(LM3533_ALS_FLAG_INT_ENABLED, &als->flags);\r\n}\r\nret = lm3533_als_set_int_mode(indio_dev, enable);\r\nif (ret) {\r\nif (!int_enabled)\r\nclear_bit(LM3533_ALS_FLAG_INT_ENABLED, &als->flags);\r\nreturn ret;\r\n}\r\nif (!enable)\r\nclear_bit(LM3533_ALS_FLAG_INT_ENABLED, &als->flags);\r\nreturn len;\r\n}\r\nstatic ssize_t show_zone(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nu8 zone;\r\nint ret;\r\nret = lm3533_als_get_zone(indio_dev, &zone);\r\nif (ret)\r\nreturn ret;\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", zone);\r\n}\r\nstatic inline struct lm3533_als_attribute *\r\nto_lm3533_als_attr(struct device_attribute *attr)\r\n{\r\nreturn container_of(attr, struct lm3533_als_attribute, dev_attr);\r\n}\r\nstatic ssize_t show_als_attr(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct lm3533_als_attribute *als_attr = to_lm3533_als_attr(attr);\r\nu8 val;\r\nint ret;\r\nswitch (als_attr->type) {\r\ncase LM3533_ATTR_TYPE_HYSTERESIS:\r\nret = lm3533_als_get_hysteresis(indio_dev, als_attr->val1,\r\n&val);\r\nbreak;\r\ncase LM3533_ATTR_TYPE_TARGET:\r\nret = lm3533_als_get_target(indio_dev, als_attr->val1,\r\nals_attr->val2, &val);\r\nbreak;\r\ncase LM3533_ATTR_TYPE_THRESH_FALLING:\r\nret = lm3533_als_get_threshold(indio_dev, als_attr->val1,\r\nfalse, &val);\r\nbreak;\r\ncase LM3533_ATTR_TYPE_THRESH_RAISING:\r\nret = lm3533_als_get_threshold(indio_dev, als_attr->val1,\r\ntrue, &val);\r\nbreak;\r\ndefault:\r\nret = -ENXIO;\r\n}\r\nif (ret)\r\nreturn ret;\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", val);\r\n}\r\nstatic ssize_t store_als_attr(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct lm3533_als_attribute *als_attr = to_lm3533_als_attr(attr);\r\nu8 val;\r\nint ret;\r\nif (kstrtou8(buf, 0, &val))\r\nreturn -EINVAL;\r\nswitch (als_attr->type) {\r\ncase LM3533_ATTR_TYPE_TARGET:\r\nret = lm3533_als_set_target(indio_dev, als_attr->val1,\r\nals_attr->val2, val);\r\nbreak;\r\ncase LM3533_ATTR_TYPE_THRESH_FALLING:\r\nret = lm3533_als_set_threshold(indio_dev, als_attr->val1,\r\nfalse, val);\r\nbreak;\r\ncase LM3533_ATTR_TYPE_THRESH_RAISING:\r\nret = lm3533_als_set_threshold(indio_dev, als_attr->val1,\r\ntrue, val);\r\nbreak;\r\ndefault:\r\nret = -ENXIO;\r\n}\r\nif (ret)\r\nreturn ret;\r\nreturn len;\r\n}\r\nstatic int lm3533_als_set_input_mode(struct lm3533_als *als, bool pwm_mode)\r\n{\r\nu8 mask = LM3533_ALS_INPUT_MODE_MASK;\r\nu8 val;\r\nint ret;\r\nif (pwm_mode)\r\nval = mask;\r\nelse\r\nval = 0;\r\nret = lm3533_update(als->lm3533, LM3533_REG_ALS_CONF, val, mask);\r\nif (ret) {\r\ndev_err(&als->pdev->dev, "failed to set input mode %d\n",\r\npwm_mode);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lm3533_als_set_resistor(struct lm3533_als *als, u8 val)\r\n{\r\nint ret;\r\nif (val < LM3533_ALS_RESISTOR_MIN || val > LM3533_ALS_RESISTOR_MAX)\r\nreturn -EINVAL;\r\nret = lm3533_write(als->lm3533, LM3533_REG_ALS_RESISTOR_SELECT, val);\r\nif (ret) {\r\ndev_err(&als->pdev->dev, "failed to set resistor\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lm3533_als_setup(struct lm3533_als *als,\r\nstruct lm3533_als_platform_data *pdata)\r\n{\r\nint ret;\r\nret = lm3533_als_set_input_mode(als, pdata->pwm_mode);\r\nif (ret)\r\nreturn ret;\r\nif (!pdata->pwm_mode) {\r\nret = lm3533_als_set_resistor(als, pdata->r_select);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lm3533_als_setup_irq(struct lm3533_als *als, void *dev)\r\n{\r\nu8 mask = LM3533_ALS_INT_ENABLE_MASK;\r\nint ret;\r\nret = lm3533_update(als->lm3533, LM3533_REG_ALS_ZONE_INFO, 0, mask);\r\nif (ret) {\r\ndev_err(&als->pdev->dev, "failed to disable interrupts\n");\r\nreturn ret;\r\n}\r\nret = request_threaded_irq(als->irq, NULL, lm3533_als_isr,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\ndev_name(&als->pdev->dev), dev);\r\nif (ret) {\r\ndev_err(&als->pdev->dev, "failed to request irq %d\n",\r\nals->irq);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lm3533_als_enable(struct lm3533_als *als)\r\n{\r\nu8 mask = LM3533_ALS_ENABLE_MASK;\r\nint ret;\r\nret = lm3533_update(als->lm3533, LM3533_REG_ALS_CONF, mask, mask);\r\nif (ret)\r\ndev_err(&als->pdev->dev, "failed to enable ALS\n");\r\nreturn ret;\r\n}\r\nstatic int lm3533_als_disable(struct lm3533_als *als)\r\n{\r\nu8 mask = LM3533_ALS_ENABLE_MASK;\r\nint ret;\r\nret = lm3533_update(als->lm3533, LM3533_REG_ALS_CONF, 0, mask);\r\nif (ret)\r\ndev_err(&als->pdev->dev, "failed to disable ALS\n");\r\nreturn ret;\r\n}\r\nstatic int lm3533_als_probe(struct platform_device *pdev)\r\n{\r\nstruct lm3533 *lm3533;\r\nstruct lm3533_als_platform_data *pdata;\r\nstruct lm3533_als *als;\r\nstruct iio_dev *indio_dev;\r\nint ret;\r\nlm3533 = dev_get_drvdata(pdev->dev.parent);\r\nif (!lm3533)\r\nreturn -EINVAL;\r\npdata = pdev->dev.platform_data;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "no platform data\n");\r\nreturn -EINVAL;\r\n}\r\nindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*als));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nindio_dev->info = &lm3533_als_info;\r\nindio_dev->channels = lm3533_als_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(lm3533_als_channels);\r\nindio_dev->name = dev_name(&pdev->dev);\r\nindio_dev->dev.parent = pdev->dev.parent;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nals = iio_priv(indio_dev);\r\nals->lm3533 = lm3533;\r\nals->pdev = pdev;\r\nals->irq = lm3533->irq;\r\natomic_set(&als->zone, 0);\r\nmutex_init(&als->thresh_mutex);\r\nplatform_set_drvdata(pdev, indio_dev);\r\nif (als->irq) {\r\nret = lm3533_als_setup_irq(als, indio_dev);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = lm3533_als_setup(als, pdata);\r\nif (ret)\r\ngoto err_free_irq;\r\nret = lm3533_als_enable(als);\r\nif (ret)\r\ngoto err_free_irq;\r\nret = iio_device_register(indio_dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register ALS\n");\r\ngoto err_disable;\r\n}\r\nreturn 0;\r\nerr_disable:\r\nlm3533_als_disable(als);\r\nerr_free_irq:\r\nif (als->irq)\r\nfree_irq(als->irq, indio_dev);\r\nreturn ret;\r\n}\r\nstatic int lm3533_als_remove(struct platform_device *pdev)\r\n{\r\nstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\r\nstruct lm3533_als *als = iio_priv(indio_dev);\r\nlm3533_als_set_int_mode(indio_dev, false);\r\niio_device_unregister(indio_dev);\r\nlm3533_als_disable(als);\r\nif (als->irq)\r\nfree_irq(als->irq, indio_dev);\r\nreturn 0;\r\n}
