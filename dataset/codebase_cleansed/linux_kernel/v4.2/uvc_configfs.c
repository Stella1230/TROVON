static struct uvcg_control_header *to_uvcg_control_header(struct config_item *item)\r\n{\r\nreturn container_of(item, struct uvcg_control_header, item);\r\n}\r\nstatic struct config_item *uvcg_control_header_make(struct config_group *group,\r\nconst char *name)\r\n{\r\nstruct uvcg_control_header *h;\r\nh = kzalloc(sizeof(*h), GFP_KERNEL);\r\nif (!h)\r\nreturn ERR_PTR(-ENOMEM);\r\nh->desc.bLength = UVC_DT_HEADER_SIZE(1);\r\nh->desc.bDescriptorType = USB_DT_CS_INTERFACE;\r\nh->desc.bDescriptorSubType = UVC_VC_HEADER;\r\nh->desc.bcdUVC = cpu_to_le16(0x0100);\r\nh->desc.dwClockFrequency = cpu_to_le32(48000000);\r\nconfig_item_init_type_name(&h->item, name, &uvcg_control_header_type);\r\nreturn &h->item;\r\n}\r\nstatic void uvcg_control_header_drop(struct config_group *group,\r\nstruct config_item *item)\r\n{\r\nstruct uvcg_control_header *h = to_uvcg_control_header(item);\r\nkfree(h);\r\n}\r\nstatic inline struct uvcg_default_processing\r\n*to_uvcg_default_processing(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item),\r\nstruct uvcg_default_processing, group);\r\n}\r\nstatic ssize_t uvcg_default_processing_bm_controls_show(\r\nstruct uvcg_default_processing *dp, char *page)\r\n{\r\nstruct f_uvc_opts *opts;\r\nstruct config_item *opts_item;\r\nstruct mutex *su_mutex = &dp->group.cg_subsys->su_mutex;\r\nstruct uvc_processing_unit_descriptor *pd;\r\nint result, i;\r\nchar *pg = page;\r\nmutex_lock(su_mutex);\r\nopts_item = dp->group.cg_item.ci_parent->ci_parent->ci_parent;\r\nopts = to_f_uvc_opts(opts_item);\r\npd = &opts->uvc_processing;\r\nmutex_lock(&opts->lock);\r\nfor (result = 0, i = 0; i < pd->bControlSize; ++i) {\r\nresult += sprintf(pg, "%d\n", pd->bmControls[i]);\r\npg = page + result;\r\n}\r\nmutex_unlock(&opts->lock);\r\nmutex_unlock(su_mutex);\r\nreturn result;\r\n}\r\nstatic inline struct uvcg_default_camera\r\n*to_uvcg_default_camera(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item),\r\nstruct uvcg_default_camera, group);\r\n}\r\nstatic ssize_t uvcg_default_camera_bm_controls_show(\r\nstruct uvcg_default_camera *dc, char *page)\r\n{\r\nstruct f_uvc_opts *opts;\r\nstruct config_item *opts_item;\r\nstruct mutex *su_mutex = &dc->group.cg_subsys->su_mutex;\r\nstruct uvc_camera_terminal_descriptor *cd;\r\nint result, i;\r\nchar *pg = page;\r\nmutex_lock(su_mutex);\r\nopts_item = dc->group.cg_item.ci_parent->ci_parent->ci_parent->\r\nci_parent;\r\nopts = to_f_uvc_opts(opts_item);\r\ncd = &opts->uvc_camera_terminal;\r\nmutex_lock(&opts->lock);\r\nfor (result = 0, i = 0; i < cd->bControlSize; ++i) {\r\nresult += sprintf(pg, "%d\n", cd->bmControls[i]);\r\npg = page + result;\r\n}\r\nmutex_unlock(&opts->lock);\r\nmutex_unlock(su_mutex);\r\nreturn result;\r\n}\r\nstatic inline struct uvcg_default_output\r\n*to_uvcg_default_output(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item),\r\nstruct uvcg_default_output, group);\r\n}\r\nstatic inline struct uvc_descriptor_header\r\n**uvcg_get_ctl_class_arr(struct config_item *i, struct f_uvc_opts *o)\r\n{\r\nstruct uvcg_control_class *cl = container_of(to_config_group(i),\r\nstruct uvcg_control_class, group);\r\nif (cl == &uvcg_control_class_fs)\r\nreturn o->uvc_fs_control_cls;\r\nif (cl == &uvcg_control_class_ss)\r\nreturn o->uvc_ss_control_cls;\r\nreturn NULL;\r\n}\r\nstatic int uvcg_control_class_allow_link(struct config_item *src,\r\nstruct config_item *target)\r\n{\r\nstruct config_item *control, *header;\r\nstruct f_uvc_opts *opts;\r\nstruct mutex *su_mutex = &src->ci_group->cg_subsys->su_mutex;\r\nstruct uvc_descriptor_header **class_array;\r\nstruct uvcg_control_header *target_hdr;\r\nint ret = -EINVAL;\r\nmutex_lock(su_mutex);\r\ncontrol = src->ci_parent->ci_parent;\r\nheader = config_group_find_item(to_config_group(control), "header");\r\nif (!header || target->ci_parent != header)\r\ngoto out;\r\nopts = to_f_uvc_opts(control->ci_parent);\r\nmutex_lock(&opts->lock);\r\nclass_array = uvcg_get_ctl_class_arr(src, opts);\r\nif (!class_array)\r\ngoto unlock;\r\nif (opts->refcnt || class_array[0]) {\r\nret = -EBUSY;\r\ngoto unlock;\r\n}\r\ntarget_hdr = to_uvcg_control_header(target);\r\n++target_hdr->linked;\r\nclass_array[0] = (struct uvc_descriptor_header *)&target_hdr->desc;\r\nret = 0;\r\nunlock:\r\nmutex_unlock(&opts->lock);\r\nout:\r\nmutex_unlock(su_mutex);\r\nreturn ret;\r\n}\r\nstatic int uvcg_control_class_drop_link(struct config_item *src,\r\nstruct config_item *target)\r\n{\r\nstruct config_item *control, *header;\r\nstruct f_uvc_opts *opts;\r\nstruct mutex *su_mutex = &src->ci_group->cg_subsys->su_mutex;\r\nstruct uvc_descriptor_header **class_array;\r\nstruct uvcg_control_header *target_hdr;\r\nint ret = -EINVAL;\r\nmutex_lock(su_mutex);\r\ncontrol = src->ci_parent->ci_parent;\r\nheader = config_group_find_item(to_config_group(control), "header");\r\nif (!header || target->ci_parent != header)\r\ngoto out;\r\nopts = to_f_uvc_opts(control->ci_parent);\r\nmutex_lock(&opts->lock);\r\nclass_array = uvcg_get_ctl_class_arr(src, opts);\r\nif (!class_array)\r\ngoto unlock;\r\nif (opts->refcnt) {\r\nret = -EBUSY;\r\ngoto unlock;\r\n}\r\ntarget_hdr = to_uvcg_control_header(target);\r\n--target_hdr->linked;\r\nclass_array[0] = NULL;\r\nret = 0;\r\nunlock:\r\nmutex_unlock(&opts->lock);\r\nout:\r\nmutex_unlock(su_mutex);\r\nreturn ret;\r\n}\r\nstatic struct uvcg_format *to_uvcg_format(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct uvcg_format, group);\r\n}\r\nstatic ssize_t uvcg_format_bma_controls_show(struct uvcg_format *f, char *page)\r\n{\r\nstruct f_uvc_opts *opts;\r\nstruct config_item *opts_item;\r\nstruct mutex *su_mutex = &f->group.cg_subsys->su_mutex;\r\nint result, i;\r\nchar *pg = page;\r\nmutex_lock(su_mutex);\r\nopts_item = f->group.cg_item.ci_parent->ci_parent->ci_parent;\r\nopts = to_f_uvc_opts(opts_item);\r\nmutex_lock(&opts->lock);\r\nresult = sprintf(pg, "0x");\r\npg += result;\r\nfor (i = 0; i < UVCG_STREAMING_CONTROL_SIZE; ++i) {\r\nresult += sprintf(pg, "%x\n", f->bmaControls[i]);\r\npg = page + result;\r\n}\r\nmutex_unlock(&opts->lock);\r\nmutex_unlock(su_mutex);\r\nreturn result;\r\n}\r\nstatic ssize_t uvcg_format_bma_controls_store(struct uvcg_format *ch,\r\nconst char *page, size_t len)\r\n{\r\nstruct f_uvc_opts *opts;\r\nstruct config_item *opts_item;\r\nstruct mutex *su_mutex = &ch->group.cg_subsys->su_mutex;\r\nint ret = -EINVAL;\r\nmutex_lock(su_mutex);\r\nopts_item = ch->group.cg_item.ci_parent->ci_parent->ci_parent;\r\nopts = to_f_uvc_opts(opts_item);\r\nmutex_lock(&opts->lock);\r\nif (ch->linked || opts->refcnt) {\r\nret = -EBUSY;\r\ngoto end;\r\n}\r\nif (len < 4 || *page != '0' ||\r\n(*(page + 1) != 'x' && *(page + 1) != 'X'))\r\ngoto end;\r\nret = hex2bin(ch->bmaControls, page + 2, 1);\r\nif (ret < 0)\r\ngoto end;\r\nret = len;\r\nend:\r\nmutex_unlock(&opts->lock);\r\nmutex_unlock(su_mutex);\r\nreturn ret;\r\n}\r\nstatic struct uvcg_streaming_header *to_uvcg_streaming_header(struct config_item *item)\r\n{\r\nreturn container_of(item, struct uvcg_streaming_header, item);\r\n}\r\nstatic int uvcg_streaming_header_allow_link(struct config_item *src,\r\nstruct config_item *target)\r\n{\r\nstruct mutex *su_mutex = &src->ci_group->cg_subsys->su_mutex;\r\nstruct config_item *opts_item;\r\nstruct f_uvc_opts *opts;\r\nstruct uvcg_streaming_header *src_hdr;\r\nstruct uvcg_format *target_fmt = NULL;\r\nstruct uvcg_format_ptr *format_ptr;\r\nint i, ret = -EINVAL;\r\nsrc_hdr = to_uvcg_streaming_header(src);\r\nmutex_lock(su_mutex);\r\nopts_item = src->ci_parent->ci_parent->ci_parent;\r\nopts = to_f_uvc_opts(opts_item);\r\nmutex_lock(&opts->lock);\r\nif (src_hdr->linked) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(fmt_parent); ++i)\r\nif (target->ci_parent == fmt_parent[i])\r\nbreak;\r\nif (i == ARRAY_SIZE(fmt_parent))\r\ngoto out;\r\ntarget_fmt = container_of(to_config_group(target), struct uvcg_format,\r\ngroup);\r\nif (!target_fmt)\r\ngoto out;\r\nformat_ptr = kzalloc(sizeof(*format_ptr), GFP_KERNEL);\r\nif (!format_ptr) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = 0;\r\nformat_ptr->fmt = target_fmt;\r\nlist_add_tail(&format_ptr->entry, &src_hdr->formats);\r\n++src_hdr->num_fmt;\r\nout:\r\nmutex_unlock(&opts->lock);\r\nmutex_unlock(su_mutex);\r\nreturn ret;\r\n}\r\nstatic int uvcg_streaming_header_drop_link(struct config_item *src,\r\nstruct config_item *target)\r\n{\r\nstruct mutex *su_mutex = &src->ci_group->cg_subsys->su_mutex;\r\nstruct config_item *opts_item;\r\nstruct f_uvc_opts *opts;\r\nstruct uvcg_streaming_header *src_hdr;\r\nstruct uvcg_format *target_fmt = NULL;\r\nstruct uvcg_format_ptr *format_ptr, *tmp;\r\nint ret = -EINVAL;\r\nsrc_hdr = to_uvcg_streaming_header(src);\r\nmutex_lock(su_mutex);\r\nopts_item = src->ci_parent->ci_parent->ci_parent;\r\nopts = to_f_uvc_opts(opts_item);\r\nmutex_lock(&opts->lock);\r\ntarget_fmt = container_of(to_config_group(target), struct uvcg_format,\r\ngroup);\r\nif (!target_fmt)\r\ngoto out;\r\nlist_for_each_entry_safe(format_ptr, tmp, &src_hdr->formats, entry)\r\nif (format_ptr->fmt == target_fmt) {\r\nlist_del(&format_ptr->entry);\r\nkfree(format_ptr);\r\n--src_hdr->num_fmt;\r\nbreak;\r\n}\r\nout:\r\nmutex_unlock(&opts->lock);\r\nmutex_unlock(su_mutex);\r\nreturn ret;\r\n}\r\nstatic struct config_item\r\n*uvcg_streaming_header_make(struct config_group *group, const char *name)\r\n{\r\nstruct uvcg_streaming_header *h;\r\nh = kzalloc(sizeof(*h), GFP_KERNEL);\r\nif (!h)\r\nreturn ERR_PTR(-ENOMEM);\r\nINIT_LIST_HEAD(&h->formats);\r\nh->desc.bDescriptorType = USB_DT_CS_INTERFACE;\r\nh->desc.bDescriptorSubType = UVC_VS_INPUT_HEADER;\r\nh->desc.bTerminalLink = 3;\r\nh->desc.bControlSize = UVCG_STREAMING_CONTROL_SIZE;\r\nconfig_item_init_type_name(&h->item, name, &uvcg_streaming_header_type);\r\nreturn &h->item;\r\n}\r\nstatic void uvcg_streaming_header_drop(struct config_group *group,\r\nstruct config_item *item)\r\n{\r\nstruct uvcg_streaming_header *h = to_uvcg_streaming_header(item);\r\nkfree(h);\r\n}\r\nstatic struct uvcg_frame *to_uvcg_frame(struct config_item *item)\r\n{\r\nreturn container_of(item, struct uvcg_frame, item);\r\n}\r\nstatic ssize_t uvcg_frame_dw_frame_interval_show(struct uvcg_frame *frm,\r\nchar *page)\r\n{\r\nstruct f_uvc_opts *opts;\r\nstruct config_item *opts_item;\r\nstruct mutex *su_mutex = &frm->item.ci_group->cg_subsys->su_mutex;\r\nint result, i;\r\nchar *pg = page;\r\nmutex_lock(su_mutex);\r\nopts_item = frm->item.ci_parent->ci_parent->ci_parent->ci_parent;\r\nopts = to_f_uvc_opts(opts_item);\r\nmutex_lock(&opts->lock);\r\nfor (result = 0, i = 0; i < frm->frame.b_frame_interval_type; ++i) {\r\nresult += sprintf(pg, "%d\n",\r\nle32_to_cpu(frm->dw_frame_interval[i]));\r\npg = page + result;\r\n}\r\nmutex_unlock(&opts->lock);\r\nmutex_unlock(su_mutex);\r\nreturn result;\r\n}\r\nstatic inline int __uvcg_count_frm_intrv(char *buf, void *priv)\r\n{\r\n++*((int *)priv);\r\nreturn 0;\r\n}\r\nstatic inline int __uvcg_fill_frm_intrv(char *buf, void *priv)\r\n{\r\nu32 num, **interv;\r\nint ret;\r\nret = kstrtou32(buf, 0, &num);\r\nif (ret)\r\nreturn ret;\r\ninterv = priv;\r\n**interv = cpu_to_le32(num);\r\n++*interv;\r\nreturn 0;\r\n}\r\nstatic int __uvcg_iter_frm_intrv(const char *page, size_t len,\r\nint (*fun)(char *, void *), void *priv)\r\n{\r\nchar buf[1 + sizeof(u32) * 8 + 1 + 1];\r\nconst char *pg = page;\r\nint i, ret;\r\nif (!fun)\r\nreturn -EINVAL;\r\nwhile (pg - page < len) {\r\ni = 0;\r\nwhile (i < sizeof(buf) && (pg - page < len) &&\r\n*pg != '\0' && *pg != '\n')\r\nbuf[i++] = *pg++;\r\nif (i == sizeof(buf))\r\nreturn -EINVAL;\r\nwhile ((pg - page < len) && (*pg == '\0' || *pg == '\n'))\r\n++pg;\r\nbuf[i] = '\0';\r\nret = fun(buf, priv);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t uvcg_frame_dw_frame_interval_store(struct uvcg_frame *ch,\r\nconst char *page, size_t len)\r\n{\r\nstruct f_uvc_opts *opts;\r\nstruct config_item *opts_item;\r\nstruct uvcg_format *fmt;\r\nstruct mutex *su_mutex = &ch->item.ci_group->cg_subsys->su_mutex;\r\nint ret = 0, n = 0;\r\nu32 *frm_intrv, *tmp;\r\nmutex_lock(su_mutex);\r\nopts_item = ch->item.ci_parent->ci_parent->ci_parent->ci_parent;\r\nopts = to_f_uvc_opts(opts_item);\r\nfmt = to_uvcg_format(ch->item.ci_parent);\r\nmutex_lock(&opts->lock);\r\nif (fmt->linked || opts->refcnt) {\r\nret = -EBUSY;\r\ngoto end;\r\n}\r\nret = __uvcg_iter_frm_intrv(page, len, __uvcg_count_frm_intrv, &n);\r\nif (ret)\r\ngoto end;\r\ntmp = frm_intrv = kcalloc(n, sizeof(u32), GFP_KERNEL);\r\nif (!frm_intrv) {\r\nret = -ENOMEM;\r\ngoto end;\r\n}\r\nret = __uvcg_iter_frm_intrv(page, len, __uvcg_fill_frm_intrv, &tmp);\r\nif (ret) {\r\nkfree(frm_intrv);\r\ngoto end;\r\n}\r\nkfree(ch->dw_frame_interval);\r\nch->dw_frame_interval = frm_intrv;\r\nch->frame.b_frame_interval_type = n;\r\nret = len;\r\nend:\r\nmutex_unlock(&opts->lock);\r\nmutex_unlock(su_mutex);\r\nreturn ret;\r\n}\r\nstatic struct config_item *uvcg_frame_make(struct config_group *group,\r\nconst char *name)\r\n{\r\nstruct uvcg_frame *h;\r\nstruct uvcg_format *fmt;\r\nstruct f_uvc_opts *opts;\r\nstruct config_item *opts_item;\r\nh = kzalloc(sizeof(*h), GFP_KERNEL);\r\nif (!h)\r\nreturn ERR_PTR(-ENOMEM);\r\nh->frame.b_descriptor_type = USB_DT_CS_INTERFACE;\r\nh->frame.b_frame_index = 1;\r\nh->frame.w_width = cpu_to_le16(640);\r\nh->frame.w_height = cpu_to_le16(360);\r\nh->frame.dw_min_bit_rate = cpu_to_le32(18432000);\r\nh->frame.dw_max_bit_rate = cpu_to_le32(55296000);\r\nh->frame.dw_max_video_frame_buffer_size = cpu_to_le32(460800);\r\nh->frame.dw_default_frame_interval = cpu_to_le32(666666);\r\nopts_item = group->cg_item.ci_parent->ci_parent->ci_parent;\r\nopts = to_f_uvc_opts(opts_item);\r\nmutex_lock(&opts->lock);\r\nfmt = to_uvcg_format(&group->cg_item);\r\nif (fmt->type == UVCG_UNCOMPRESSED) {\r\nh->frame.b_descriptor_subtype = UVC_VS_FRAME_UNCOMPRESSED;\r\nh->fmt_type = UVCG_UNCOMPRESSED;\r\n} else if (fmt->type == UVCG_MJPEG) {\r\nh->frame.b_descriptor_subtype = UVC_VS_FRAME_MJPEG;\r\nh->fmt_type = UVCG_MJPEG;\r\n} else {\r\nmutex_unlock(&opts->lock);\r\nkfree(h);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n++fmt->num_frames;\r\nmutex_unlock(&opts->lock);\r\nconfig_item_init_type_name(&h->item, name, &uvcg_frame_type);\r\nreturn &h->item;\r\n}\r\nstatic void uvcg_frame_drop(struct config_group *group, struct config_item *item)\r\n{\r\nstruct uvcg_frame *h = to_uvcg_frame(item);\r\nstruct uvcg_format *fmt;\r\nstruct f_uvc_opts *opts;\r\nstruct config_item *opts_item;\r\nopts_item = group->cg_item.ci_parent->ci_parent->ci_parent;\r\nopts = to_f_uvc_opts(opts_item);\r\nmutex_lock(&opts->lock);\r\nfmt = to_uvcg_format(&group->cg_item);\r\n--fmt->num_frames;\r\nkfree(h);\r\nmutex_unlock(&opts->lock);\r\n}\r\nstatic struct uvcg_uncompressed *to_uvcg_uncompressed(struct config_item *item)\r\n{\r\nreturn container_of(\r\ncontainer_of(to_config_group(item), struct uvcg_format, group),\r\nstruct uvcg_uncompressed, fmt);\r\n}\r\nstatic ssize_t uvcg_uncompressed_guid_format_show(struct uvcg_uncompressed *ch,\r\nchar *page)\r\n{\r\nstruct f_uvc_opts *opts;\r\nstruct config_item *opts_item;\r\nstruct mutex *su_mutex = &ch->fmt.group.cg_subsys->su_mutex;\r\nmutex_lock(su_mutex);\r\nopts_item = ch->fmt.group.cg_item.ci_parent->ci_parent->ci_parent;\r\nopts = to_f_uvc_opts(opts_item);\r\nmutex_lock(&opts->lock);\r\nmemcpy(page, ch->desc.guidFormat, sizeof(ch->desc.guidFormat));\r\nmutex_unlock(&opts->lock);\r\nmutex_unlock(su_mutex);\r\nreturn sizeof(ch->desc.guidFormat);\r\n}\r\nstatic ssize_t uvcg_uncompressed_guid_format_store(struct uvcg_uncompressed *ch,\r\nconst char *page, size_t len)\r\n{\r\nstruct f_uvc_opts *opts;\r\nstruct config_item *opts_item;\r\nstruct mutex *su_mutex = &ch->fmt.group.cg_subsys->su_mutex;\r\nint ret;\r\nmutex_lock(su_mutex);\r\nopts_item = ch->fmt.group.cg_item.ci_parent->ci_parent->ci_parent;\r\nopts = to_f_uvc_opts(opts_item);\r\nmutex_lock(&opts->lock);\r\nif (ch->fmt.linked || opts->refcnt) {\r\nret = -EBUSY;\r\ngoto end;\r\n}\r\nmemcpy(ch->desc.guidFormat, page,\r\nmin(sizeof(ch->desc.guidFormat), len));\r\nret = sizeof(ch->desc.guidFormat);\r\nend:\r\nmutex_unlock(&opts->lock);\r\nmutex_unlock(su_mutex);\r\nreturn ret;\r\n}\r\nstatic inline ssize_t\r\nuvcg_uncompressed_bma_controls_show(struct uvcg_uncompressed *unc, char *page)\r\n{\r\nreturn uvcg_format_bma_controls_show(&unc->fmt, page);\r\n}\r\nstatic inline ssize_t\r\nuvcg_uncompressed_bma_controls_store(struct uvcg_uncompressed *ch,\r\nconst char *page, size_t len)\r\n{\r\nreturn uvcg_format_bma_controls_store(&ch->fmt, page, len);\r\n}\r\nstatic struct config_group *uvcg_uncompressed_make(struct config_group *group,\r\nconst char *name)\r\n{\r\nstatic char guid[] = {\r\n'Y', 'U', 'Y', '2', 0x00, 0x00, 0x10, 0x00,\r\n0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71\r\n};\r\nstruct uvcg_uncompressed *h;\r\nh = kzalloc(sizeof(*h), GFP_KERNEL);\r\nif (!h)\r\nreturn ERR_PTR(-ENOMEM);\r\nh->desc.bLength = UVC_DT_FORMAT_UNCOMPRESSED_SIZE;\r\nh->desc.bDescriptorType = USB_DT_CS_INTERFACE;\r\nh->desc.bDescriptorSubType = UVC_VS_FORMAT_UNCOMPRESSED;\r\nmemcpy(h->desc.guidFormat, guid, sizeof(guid));\r\nh->desc.bBitsPerPixel = 16;\r\nh->desc.bDefaultFrameIndex = 1;\r\nh->desc.bAspectRatioX = 0;\r\nh->desc.bAspectRatioY = 0;\r\nh->desc.bmInterfaceFlags = 0;\r\nh->desc.bCopyProtect = 0;\r\nh->fmt.type = UVCG_UNCOMPRESSED;\r\nconfig_group_init_type_name(&h->fmt.group, name,\r\n&uvcg_uncompressed_type);\r\nreturn &h->fmt.group;\r\n}\r\nstatic void uvcg_uncompressed_drop(struct config_group *group,\r\nstruct config_item *item)\r\n{\r\nstruct uvcg_uncompressed *h = to_uvcg_uncompressed(item);\r\nkfree(h);\r\n}\r\nstatic struct uvcg_mjpeg *to_uvcg_mjpeg(struct config_item *item)\r\n{\r\nreturn container_of(\r\ncontainer_of(to_config_group(item), struct uvcg_format, group),\r\nstruct uvcg_mjpeg, fmt);\r\n}\r\nstatic inline ssize_t\r\nuvcg_mjpeg_bma_controls_show(struct uvcg_mjpeg *unc, char *page)\r\n{\r\nreturn uvcg_format_bma_controls_show(&unc->fmt, page);\r\n}\r\nstatic inline ssize_t\r\nuvcg_mjpeg_bma_controls_store(struct uvcg_mjpeg *ch,\r\nconst char *page, size_t len)\r\n{\r\nreturn uvcg_format_bma_controls_store(&ch->fmt, page, len);\r\n}\r\nstatic struct config_group *uvcg_mjpeg_make(struct config_group *group,\r\nconst char *name)\r\n{\r\nstruct uvcg_mjpeg *h;\r\nh = kzalloc(sizeof(*h), GFP_KERNEL);\r\nif (!h)\r\nreturn ERR_PTR(-ENOMEM);\r\nh->desc.bLength = UVC_DT_FORMAT_MJPEG_SIZE;\r\nh->desc.bDescriptorType = USB_DT_CS_INTERFACE;\r\nh->desc.bDescriptorSubType = UVC_VS_FORMAT_MJPEG;\r\nh->desc.bDefaultFrameIndex = 1;\r\nh->desc.bAspectRatioX = 0;\r\nh->desc.bAspectRatioY = 0;\r\nh->desc.bmInterfaceFlags = 0;\r\nh->desc.bCopyProtect = 0;\r\nh->fmt.type = UVCG_MJPEG;\r\nconfig_group_init_type_name(&h->fmt.group, name,\r\n&uvcg_mjpeg_type);\r\nreturn &h->fmt.group;\r\n}\r\nstatic void uvcg_mjpeg_drop(struct config_group *group,\r\nstruct config_item *item)\r\n{\r\nstruct uvcg_mjpeg *h = to_uvcg_mjpeg(item);\r\nkfree(h);\r\n}\r\nstatic inline struct uvcg_default_color_matching\r\n*to_uvcg_default_color_matching(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item),\r\nstruct uvcg_default_color_matching, group);\r\n}\r\nstatic inline struct uvc_descriptor_header\r\n***__uvcg_get_stream_class_arr(struct config_item *i, struct f_uvc_opts *o)\r\n{\r\nstruct uvcg_streaming_class *cl = container_of(to_config_group(i),\r\nstruct uvcg_streaming_class, group);\r\nif (cl == &uvcg_streaming_class_fs)\r\nreturn &o->uvc_fs_streaming_cls;\r\nif (cl == &uvcg_streaming_class_hs)\r\nreturn &o->uvc_hs_streaming_cls;\r\nif (cl == &uvcg_streaming_class_ss)\r\nreturn &o->uvc_ss_streaming_cls;\r\nreturn NULL;\r\n}\r\nstatic int __uvcg_iter_strm_cls(struct uvcg_streaming_header *h,\r\nvoid *priv2, void *priv3,\r\nint (*fun)(void *, void *, void *, int, enum uvcg_strm_type type))\r\n{\r\nstruct uvcg_format_ptr *f;\r\nstruct config_group *grp;\r\nstruct config_item *item;\r\nstruct uvcg_frame *frm;\r\nint ret, i, j;\r\nif (!fun)\r\nreturn -EINVAL;\r\ni = j = 0;\r\nret = fun(h, priv2, priv3, 0, UVCG_HEADER);\r\nif (ret)\r\nreturn ret;\r\nlist_for_each_entry(f, &h->formats, entry) {\r\nret = fun(f->fmt, priv2, priv3, i++, UVCG_FORMAT);\r\nif (ret)\r\nreturn ret;\r\ngrp = &f->fmt->group;\r\nlist_for_each_entry(item, &grp->cg_children, ci_entry) {\r\nfrm = to_uvcg_frame(item);\r\nret = fun(frm, priv2, priv3, j++, UVCG_FRAME);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int __uvcg_cnt_strm(void *priv1, void *priv2, void *priv3, int n,\r\nenum uvcg_strm_type type)\r\n{\r\nsize_t *size = priv2;\r\nsize_t *count = priv3;\r\nswitch (type) {\r\ncase UVCG_HEADER: {\r\nstruct uvcg_streaming_header *h = priv1;\r\n*size += sizeof(h->desc);\r\n*size += h->num_fmt * UVCG_STREAMING_CONTROL_SIZE;\r\n}\r\nbreak;\r\ncase UVCG_FORMAT: {\r\nstruct uvcg_format *fmt = priv1;\r\nif (fmt->type == UVCG_UNCOMPRESSED) {\r\nstruct uvcg_uncompressed *u =\r\ncontainer_of(fmt, struct uvcg_uncompressed,\r\nfmt);\r\n*size += sizeof(u->desc);\r\n} else if (fmt->type == UVCG_MJPEG) {\r\nstruct uvcg_mjpeg *m =\r\ncontainer_of(fmt, struct uvcg_mjpeg, fmt);\r\n*size += sizeof(m->desc);\r\n} else {\r\nreturn -EINVAL;\r\n}\r\n}\r\nbreak;\r\ncase UVCG_FRAME: {\r\nstruct uvcg_frame *frm = priv1;\r\nint sz = sizeof(frm->dw_frame_interval);\r\n*size += sizeof(frm->frame);\r\n*size += frm->frame.b_frame_interval_type * sz;\r\n}\r\nbreak;\r\n}\r\n++*count;\r\nreturn 0;\r\n}\r\nstatic int __uvcg_fill_strm(void *priv1, void *priv2, void *priv3, int n,\r\nenum uvcg_strm_type type)\r\n{\r\nvoid **dest = priv2;\r\nstruct uvc_descriptor_header ***array = priv3;\r\nsize_t sz;\r\n**array = *dest;\r\n++*array;\r\nswitch (type) {\r\ncase UVCG_HEADER: {\r\nstruct uvc_input_header_descriptor *ihdr = *dest;\r\nstruct uvcg_streaming_header *h = priv1;\r\nstruct uvcg_format_ptr *f;\r\nmemcpy(*dest, &h->desc, sizeof(h->desc));\r\n*dest += sizeof(h->desc);\r\nsz = UVCG_STREAMING_CONTROL_SIZE;\r\nlist_for_each_entry(f, &h->formats, entry) {\r\nmemcpy(*dest, f->fmt->bmaControls, sz);\r\n*dest += sz;\r\n}\r\nihdr->bLength = sizeof(h->desc) + h->num_fmt * sz;\r\nihdr->bNumFormats = h->num_fmt;\r\n}\r\nbreak;\r\ncase UVCG_FORMAT: {\r\nstruct uvcg_format *fmt = priv1;\r\nif (fmt->type == UVCG_UNCOMPRESSED) {\r\nstruct uvc_format_uncompressed *unc = *dest;\r\nstruct uvcg_uncompressed *u =\r\ncontainer_of(fmt, struct uvcg_uncompressed,\r\nfmt);\r\nmemcpy(*dest, &u->desc, sizeof(u->desc));\r\n*dest += sizeof(u->desc);\r\nunc->bNumFrameDescriptors = fmt->num_frames;\r\nunc->bFormatIndex = n + 1;\r\n} else if (fmt->type == UVCG_MJPEG) {\r\nstruct uvc_format_mjpeg *mjp = *dest;\r\nstruct uvcg_mjpeg *m =\r\ncontainer_of(fmt, struct uvcg_mjpeg, fmt);\r\nmemcpy(*dest, &m->desc, sizeof(m->desc));\r\n*dest += sizeof(m->desc);\r\nmjp->bNumFrameDescriptors = fmt->num_frames;\r\nmjp->bFormatIndex = n + 1;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\n}\r\nbreak;\r\ncase UVCG_FRAME: {\r\nstruct uvcg_frame *frm = priv1;\r\nstruct uvc_descriptor_header *h = *dest;\r\nsz = sizeof(frm->frame);\r\nmemcpy(*dest, &frm->frame, sz);\r\n*dest += sz;\r\nsz = frm->frame.b_frame_interval_type *\r\nsizeof(*frm->dw_frame_interval);\r\nmemcpy(*dest, frm->dw_frame_interval, sz);\r\n*dest += sz;\r\nif (frm->fmt_type == UVCG_UNCOMPRESSED)\r\nh->bLength = UVC_DT_FRAME_UNCOMPRESSED_SIZE(\r\nfrm->frame.b_frame_interval_type);\r\nelse if (frm->fmt_type == UVCG_MJPEG)\r\nh->bLength = UVC_DT_FRAME_MJPEG_SIZE(\r\nfrm->frame.b_frame_interval_type);\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uvcg_streaming_class_allow_link(struct config_item *src,\r\nstruct config_item *target)\r\n{\r\nstruct config_item *streaming, *header;\r\nstruct f_uvc_opts *opts;\r\nstruct mutex *su_mutex = &src->ci_group->cg_subsys->su_mutex;\r\nstruct uvc_descriptor_header ***class_array, **cl_arr;\r\nstruct uvcg_streaming_header *target_hdr;\r\nvoid *data, *data_save;\r\nsize_t size = 0, count = 0;\r\nint ret = -EINVAL;\r\nmutex_lock(su_mutex);\r\nstreaming = src->ci_parent->ci_parent;\r\nheader = config_group_find_item(to_config_group(streaming), "header");\r\nif (!header || target->ci_parent != header)\r\ngoto out;\r\nopts = to_f_uvc_opts(streaming->ci_parent);\r\nmutex_lock(&opts->lock);\r\nclass_array = __uvcg_get_stream_class_arr(src, opts);\r\nif (!class_array || *class_array || opts->refcnt) {\r\nret = -EBUSY;\r\ngoto unlock;\r\n}\r\ntarget_hdr = to_uvcg_streaming_header(target);\r\nret = __uvcg_iter_strm_cls(target_hdr, &size, &count, __uvcg_cnt_strm);\r\nif (ret)\r\ngoto unlock;\r\ncount += 2;\r\n*class_array = kcalloc(count, sizeof(void *), GFP_KERNEL);\r\nif (!*class_array) {\r\nret = -ENOMEM;\r\ngoto unlock;\r\n}\r\ndata = data_save = kzalloc(size, GFP_KERNEL);\r\nif (!data) {\r\nkfree(*class_array);\r\n*class_array = NULL;\r\nret = PTR_ERR(data);\r\ngoto unlock;\r\n}\r\ncl_arr = *class_array;\r\nret = __uvcg_iter_strm_cls(target_hdr, &data, &cl_arr,\r\n__uvcg_fill_strm);\r\nif (ret) {\r\nkfree(*class_array);\r\n*class_array = NULL;\r\nkfree(data_save);\r\ngoto unlock;\r\n}\r\n*cl_arr = (struct uvc_descriptor_header *)&opts->uvc_color_matching;\r\n++target_hdr->linked;\r\nret = 0;\r\nunlock:\r\nmutex_unlock(&opts->lock);\r\nout:\r\nmutex_unlock(su_mutex);\r\nreturn ret;\r\n}\r\nstatic int uvcg_streaming_class_drop_link(struct config_item *src,\r\nstruct config_item *target)\r\n{\r\nstruct config_item *streaming, *header;\r\nstruct f_uvc_opts *opts;\r\nstruct mutex *su_mutex = &src->ci_group->cg_subsys->su_mutex;\r\nstruct uvc_descriptor_header ***class_array;\r\nstruct uvcg_streaming_header *target_hdr;\r\nint ret = -EINVAL;\r\nmutex_lock(su_mutex);\r\nstreaming = src->ci_parent->ci_parent;\r\nheader = config_group_find_item(to_config_group(streaming), "header");\r\nif (!header || target->ci_parent != header)\r\ngoto out;\r\nopts = to_f_uvc_opts(streaming->ci_parent);\r\nmutex_lock(&opts->lock);\r\nclass_array = __uvcg_get_stream_class_arr(src, opts);\r\nif (!class_array || !*class_array)\r\ngoto unlock;\r\nif (opts->refcnt) {\r\nret = -EBUSY;\r\ngoto unlock;\r\n}\r\ntarget_hdr = to_uvcg_streaming_header(target);\r\n--target_hdr->linked;\r\nkfree(**class_array);\r\nkfree(*class_array);\r\n*class_array = NULL;\r\nret = 0;\r\nunlock:\r\nmutex_unlock(&opts->lock);\r\nout:\r\nmutex_unlock(su_mutex);\r\nreturn ret;\r\n}\r\nstatic inline struct f_uvc_opts *to_f_uvc_opts(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct f_uvc_opts,\r\nfunc_inst.group);\r\n}\r\nstatic void uvc_attr_release(struct config_item *item)\r\n{\r\nstruct f_uvc_opts *opts = to_f_uvc_opts(item);\r\nusb_put_function_instance(&opts->func_inst);\r\n}\r\nstatic inline void uvcg_init_group(struct config_group *g,\r\nstruct config_group **default_groups,\r\nconst char *name,\r\nstruct config_item_type *type)\r\n{\r\ng->default_groups = default_groups;\r\nconfig_group_init_type_name(g, name, type);\r\n}\r\nint uvcg_attach_configfs(struct f_uvc_opts *opts)\r\n{\r\nconfig_group_init_type_name(&uvcg_control_header_grp.group,\r\n"header",\r\n&uvcg_control_header_grp_type);\r\nconfig_group_init_type_name(&uvcg_default_processing.group,\r\n"default",\r\n&uvcg_default_processing_type);\r\nuvcg_init_group(&uvcg_processing_grp.group,\r\nuvcg_processing_default_groups,\r\n"processing",\r\n&uvcg_processing_grp_type);\r\nconfig_group_init_type_name(&uvcg_default_camera.group,\r\n"default",\r\n&uvcg_default_camera_type);\r\nuvcg_init_group(&uvcg_camera_grp.group,\r\nuvcg_camera_default_groups,\r\n"camera",\r\n&uvcg_camera_grp_type);\r\nconfig_group_init_type_name(&uvcg_default_output.group,\r\n"default",\r\n&uvcg_default_output_type);\r\nuvcg_init_group(&uvcg_output_grp.group,\r\nuvcg_output_default_groups,\r\n"output",\r\n&uvcg_output_grp_type);\r\nuvcg_init_group(&uvcg_terminal_grp.group,\r\nuvcg_terminal_default_groups,\r\n"terminal",\r\n&uvcg_terminal_grp_type);\r\nconfig_group_init_type_name(&uvcg_control_class_fs.group,\r\n"fs",\r\n&uvcg_control_class_type);\r\nconfig_group_init_type_name(&uvcg_control_class_ss.group,\r\n"ss",\r\n&uvcg_control_class_type);\r\nuvcg_init_group(&uvcg_control_class_grp.group,\r\nuvcg_control_class_default_groups,\r\n"class",\r\n&uvcg_control_class_grp_type);\r\nuvcg_init_group(&uvcg_control_grp.group,\r\nuvcg_control_default_groups,\r\n"control",\r\n&uvcg_control_grp_type);\r\nconfig_group_init_type_name(&uvcg_streaming_header_grp.group,\r\n"header",\r\n&uvcg_streaming_header_grp_type);\r\nconfig_group_init_type_name(&uvcg_uncompressed_grp.group,\r\n"uncompressed",\r\n&uvcg_uncompressed_grp_type);\r\nconfig_group_init_type_name(&uvcg_mjpeg_grp.group,\r\n"mjpeg",\r\n&uvcg_mjpeg_grp_type);\r\nconfig_group_init_type_name(&uvcg_default_color_matching.group,\r\n"default",\r\n&uvcg_default_color_matching_type);\r\nuvcg_init_group(&uvcg_color_matching_grp.group,\r\nuvcg_color_matching_default_groups,\r\n"color_matching",\r\n&uvcg_color_matching_grp_type);\r\nconfig_group_init_type_name(&uvcg_streaming_class_fs.group,\r\n"fs",\r\n&uvcg_streaming_class_type);\r\nconfig_group_init_type_name(&uvcg_streaming_class_hs.group,\r\n"hs",\r\n&uvcg_streaming_class_type);\r\nconfig_group_init_type_name(&uvcg_streaming_class_ss.group,\r\n"ss",\r\n&uvcg_streaming_class_type);\r\nuvcg_init_group(&uvcg_streaming_class_grp.group,\r\nuvcg_streaming_class_default_groups,\r\n"class",\r\n&uvcg_streaming_class_grp_type);\r\nuvcg_init_group(&uvcg_streaming_grp.group,\r\nuvcg_streaming_default_groups,\r\n"streaming",\r\n&uvcg_streaming_grp_type);\r\nuvcg_init_group(&opts->func_inst.group,\r\nuvcg_default_groups,\r\n"",\r\n&uvc_func_type);\r\nreturn 0;\r\n}
