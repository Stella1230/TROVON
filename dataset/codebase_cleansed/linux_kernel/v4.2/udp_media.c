static void tipc_udp_media_addr_set(struct tipc_media_addr *addr,\r\nstruct udp_media_addr *ua)\r\n{\r\nmemset(addr, 0, sizeof(struct tipc_media_addr));\r\naddr->media_id = TIPC_MEDIA_TYPE_UDP;\r\nmemcpy(addr->value, ua, sizeof(struct udp_media_addr));\r\nif (ntohs(ua->proto) == ETH_P_IP) {\r\nif (ipv4_is_multicast(ua->ipv4.s_addr))\r\naddr->broadcast = 1;\r\n} else if (ntohs(ua->proto) == ETH_P_IPV6) {\r\nif (ipv6_addr_type(&ua->ipv6) & IPV6_ADDR_MULTICAST)\r\naddr->broadcast = 1;\r\n} else {\r\npr_err("Invalid UDP media address\n");\r\n}\r\n}\r\nstatic int tipc_udp_addr2str(struct tipc_media_addr *a, char *buf, int size)\r\n{\r\nstruct udp_media_addr *ua = (struct udp_media_addr *)&a->value;\r\nif (ntohs(ua->proto) == ETH_P_IP)\r\nsnprintf(buf, size, "%pI4:%u", &ua->ipv4, ntohs(ua->udp_port));\r\nelse if (ntohs(ua->proto) == ETH_P_IPV6)\r\nsnprintf(buf, size, "%pI6:%u", &ua->ipv6, ntohs(ua->udp_port));\r\nelse\r\npr_err("Invalid UDP media address\n");\r\nreturn 0;\r\n}\r\nstatic int tipc_udp_msg2addr(struct tipc_bearer *b, struct tipc_media_addr *a,\r\nchar *msg)\r\n{\r\nstruct udp_media_addr *ua;\r\nua = (struct udp_media_addr *) (msg + TIPC_MEDIA_ADDR_OFFSET);\r\nif (msg[TIPC_MEDIA_TYPE_OFFSET] != TIPC_MEDIA_TYPE_UDP)\r\nreturn -EINVAL;\r\ntipc_udp_media_addr_set(a, ua);\r\nreturn 0;\r\n}\r\nstatic int tipc_udp_addr2msg(char *msg, struct tipc_media_addr *a)\r\n{\r\nmemset(msg, 0, TIPC_MEDIA_INFO_SIZE);\r\nmsg[TIPC_MEDIA_TYPE_OFFSET] = TIPC_MEDIA_TYPE_UDP;\r\nmemcpy(msg + TIPC_MEDIA_ADDR_OFFSET, a->value,\r\nsizeof(struct udp_media_addr));\r\nreturn 0;\r\n}\r\nstatic int tipc_udp_send_msg(struct net *net, struct sk_buff *skb,\r\nstruct tipc_bearer *b,\r\nstruct tipc_media_addr *dest)\r\n{\r\nint ttl, err = 0;\r\nstruct udp_bearer *ub;\r\nstruct udp_media_addr *dst = (struct udp_media_addr *)&dest->value;\r\nstruct udp_media_addr *src = (struct udp_media_addr *)&b->addr.value;\r\nstruct sk_buff *clone;\r\nstruct rtable *rt;\r\nclone = skb_clone(skb, GFP_ATOMIC);\r\nskb_set_inner_protocol(clone, htons(ETH_P_TIPC));\r\nub = rcu_dereference_rtnl(b->media_ptr);\r\nif (!ub) {\r\nerr = -ENODEV;\r\ngoto tx_error;\r\n}\r\nif (dst->proto == htons(ETH_P_IP)) {\r\nstruct flowi4 fl = {\r\n.daddr = dst->ipv4.s_addr,\r\n.saddr = src->ipv4.s_addr,\r\n.flowi4_mark = clone->mark,\r\n.flowi4_proto = IPPROTO_UDP\r\n};\r\nrt = ip_route_output_key(net, &fl);\r\nif (IS_ERR(rt)) {\r\nerr = PTR_ERR(rt);\r\ngoto tx_error;\r\n}\r\nttl = ip4_dst_hoplimit(&rt->dst);\r\nerr = udp_tunnel_xmit_skb(rt, ub->ubsock->sk, clone,\r\nsrc->ipv4.s_addr,\r\ndst->ipv4.s_addr, 0, ttl, 0,\r\nsrc->udp_port, dst->udp_port,\r\nfalse, true);\r\nif (err < 0) {\r\nip_rt_put(rt);\r\ngoto tx_error;\r\n}\r\n#if IS_ENABLED(CONFIG_IPV6)\r\n} else {\r\nstruct dst_entry *ndst;\r\nstruct flowi6 fl6 = {\r\n.flowi6_oif = ub->ifindex,\r\n.daddr = dst->ipv6,\r\n.saddr = src->ipv6,\r\n.flowi6_proto = IPPROTO_UDP\r\n};\r\nerr = ipv6_stub->ipv6_dst_lookup(ub->ubsock->sk, &ndst, &fl6);\r\nif (err)\r\ngoto tx_error;\r\nttl = ip6_dst_hoplimit(ndst);\r\nerr = udp_tunnel6_xmit_skb(ndst, ub->ubsock->sk, clone,\r\nndst->dev, &src->ipv6,\r\n&dst->ipv6, 0, ttl, src->udp_port,\r\ndst->udp_port, false);\r\n#endif\r\n}\r\nreturn err;\r\ntx_error:\r\nkfree_skb(clone);\r\nreturn err;\r\n}\r\nstatic int tipc_udp_recv(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct udp_bearer *ub;\r\nstruct tipc_bearer *b;\r\nub = rcu_dereference_sk_user_data(sk);\r\nif (!ub) {\r\npr_err_ratelimited("Failed to get UDP bearer reference");\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nskb_pull(skb, sizeof(struct udphdr));\r\nrcu_read_lock();\r\nb = rcu_dereference_rtnl(ub->bearer);\r\nif (b) {\r\ntipc_rcv(sock_net(sk), skb, b);\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nrcu_read_unlock();\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int enable_mcast(struct udp_bearer *ub, struct udp_media_addr *remote)\r\n{\r\nint err = 0;\r\nstruct ip_mreqn mreqn;\r\nstruct sock *sk = ub->ubsock->sk;\r\nif (ntohs(remote->proto) == ETH_P_IP) {\r\nif (!ipv4_is_multicast(remote->ipv4.s_addr))\r\nreturn 0;\r\nmreqn.imr_multiaddr = remote->ipv4;\r\nmreqn.imr_ifindex = ub->ifindex;\r\nerr = ip_mc_join_group(sk, &mreqn);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\n} else {\r\nif (!ipv6_addr_is_multicast(&remote->ipv6))\r\nreturn 0;\r\nerr = ipv6_stub->ipv6_sock_mc_join(sk, ub->ifindex,\r\n&remote->ipv6);\r\n#endif\r\n}\r\nreturn err;\r\n}\r\nstatic int parse_options(struct nlattr *attrs[], struct udp_bearer *ub,\r\nstruct udp_media_addr *local,\r\nstruct udp_media_addr *remote)\r\n{\r\nstruct nlattr *opts[TIPC_NLA_UDP_MAX + 1];\r\nstruct sockaddr_storage *sa_local, *sa_remote;\r\nif (!attrs[TIPC_NLA_BEARER_UDP_OPTS])\r\ngoto err;\r\nif (nla_parse_nested(opts, TIPC_NLA_UDP_MAX,\r\nattrs[TIPC_NLA_BEARER_UDP_OPTS],\r\ntipc_nl_udp_policy))\r\ngoto err;\r\nif (opts[TIPC_NLA_UDP_LOCAL] && opts[TIPC_NLA_UDP_REMOTE]) {\r\nsa_local = nla_data(opts[TIPC_NLA_UDP_LOCAL]);\r\nsa_remote = nla_data(opts[TIPC_NLA_UDP_REMOTE]);\r\n} else {\r\nerr:\r\npr_err("Invalid UDP bearer configuration");\r\nreturn -EINVAL;\r\n}\r\nif ((sa_local->ss_family & sa_remote->ss_family) == AF_INET) {\r\nstruct sockaddr_in *ip4;\r\nip4 = (struct sockaddr_in *)sa_local;\r\nlocal->proto = htons(ETH_P_IP);\r\nlocal->udp_port = ip4->sin_port;\r\nlocal->ipv4.s_addr = ip4->sin_addr.s_addr;\r\nip4 = (struct sockaddr_in *)sa_remote;\r\nremote->proto = htons(ETH_P_IP);\r\nremote->udp_port = ip4->sin_port;\r\nremote->ipv4.s_addr = ip4->sin_addr.s_addr;\r\nreturn 0;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\n} else if ((sa_local->ss_family & sa_remote->ss_family) == AF_INET6) {\r\nstruct sockaddr_in6 *ip6;\r\nip6 = (struct sockaddr_in6 *)sa_local;\r\nlocal->proto = htons(ETH_P_IPV6);\r\nlocal->udp_port = ip6->sin6_port;\r\nlocal->ipv6 = ip6->sin6_addr;\r\nub->ifindex = ip6->sin6_scope_id;\r\nip6 = (struct sockaddr_in6 *)sa_remote;\r\nremote->proto = htons(ETH_P_IPV6);\r\nremote->udp_port = ip6->sin6_port;\r\nremote->ipv6 = ip6->sin6_addr;\r\nreturn 0;\r\n#endif\r\n}\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nstatic int tipc_udp_enable(struct net *net, struct tipc_bearer *b,\r\nstruct nlattr *attrs[])\r\n{\r\nint err = -EINVAL;\r\nstruct udp_bearer *ub;\r\nstruct udp_media_addr *remote;\r\nstruct udp_media_addr local = {0};\r\nstruct udp_port_cfg udp_conf = {0};\r\nstruct udp_tunnel_sock_cfg tuncfg = {NULL};\r\nub = kzalloc(sizeof(*ub), GFP_ATOMIC);\r\nif (!ub)\r\nreturn -ENOMEM;\r\nremote = (struct udp_media_addr *)&b->bcast_addr.value;\r\nmemset(remote, 0, sizeof(struct udp_media_addr));\r\nerr = parse_options(attrs, ub, &local, remote);\r\nif (err)\r\ngoto err;\r\nb->bcast_addr.media_id = TIPC_MEDIA_TYPE_UDP;\r\nb->bcast_addr.broadcast = 1;\r\nrcu_assign_pointer(b->media_ptr, ub);\r\nrcu_assign_pointer(ub->bearer, b);\r\ntipc_udp_media_addr_set(&b->addr, &local);\r\nif (local.proto == htons(ETH_P_IP)) {\r\nstruct net_device *dev;\r\ndev = __ip_dev_find(net, local.ipv4.s_addr, false);\r\nif (!dev) {\r\nerr = -ENODEV;\r\ngoto err;\r\n}\r\nudp_conf.family = AF_INET;\r\nudp_conf.local_ip.s_addr = htonl(INADDR_ANY);\r\nudp_conf.use_udp_checksums = false;\r\nub->ifindex = dev->ifindex;\r\nb->mtu = dev->mtu - sizeof(struct iphdr)\r\n- sizeof(struct udphdr);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\n} else if (local.proto == htons(ETH_P_IPV6)) {\r\nudp_conf.family = AF_INET6;\r\nudp_conf.use_udp6_tx_checksums = true;\r\nudp_conf.use_udp6_rx_checksums = true;\r\nudp_conf.local_ip6 = in6addr_any;\r\nb->mtu = 1280;\r\n#endif\r\n} else {\r\nerr = -EAFNOSUPPORT;\r\ngoto err;\r\n}\r\nudp_conf.local_udp_port = local.udp_port;\r\nerr = udp_sock_create(net, &udp_conf, &ub->ubsock);\r\nif (err)\r\ngoto err;\r\ntuncfg.sk_user_data = ub;\r\ntuncfg.encap_type = 1;\r\ntuncfg.encap_rcv = tipc_udp_recv;\r\ntuncfg.encap_destroy = NULL;\r\nsetup_udp_tunnel_sock(net, ub->ubsock, &tuncfg);\r\nif (enable_mcast(ub, remote))\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nkfree(ub);\r\nreturn err;\r\n}\r\nstatic void cleanup_bearer(struct work_struct *work)\r\n{\r\nstruct udp_bearer *ub = container_of(work, struct udp_bearer, work);\r\nif (ub->ubsock)\r\nudp_tunnel_sock_release(ub->ubsock);\r\nsynchronize_net();\r\nkfree(ub);\r\n}\r\nstatic void tipc_udp_disable(struct tipc_bearer *b)\r\n{\r\nstruct udp_bearer *ub;\r\nub = rcu_dereference_rtnl(b->media_ptr);\r\nif (!ub) {\r\npr_err("UDP bearer instance not found\n");\r\nreturn;\r\n}\r\nif (ub->ubsock)\r\nsock_set_flag(ub->ubsock->sk, SOCK_DEAD);\r\nRCU_INIT_POINTER(b->media_ptr, NULL);\r\nRCU_INIT_POINTER(ub->bearer, NULL);\r\nINIT_WORK(&ub->work, cleanup_bearer);\r\nschedule_work(&ub->work);\r\n}
