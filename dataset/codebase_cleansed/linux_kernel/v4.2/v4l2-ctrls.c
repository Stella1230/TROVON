static bool is_cur_manual(const struct v4l2_ctrl *master)\r\n{\r\nreturn master->is_auto && master->cur.val == master->manual_mode_value;\r\n}\r\nstatic bool is_new_manual(const struct v4l2_ctrl *master)\r\n{\r\nreturn master->is_auto && master->val == master->manual_mode_value;\r\n}\r\nconst char * const *v4l2_ctrl_get_menu(u32 id)\r\n{\r\nstatic const char * const mpeg_audio_sampling_freq[] = {\r\n"44.1 kHz",\r\n"48 kHz",\r\n"32 kHz",\r\nNULL\r\n};\r\nstatic const char * const mpeg_audio_encoding[] = {\r\n"MPEG-1/2 Layer I",\r\n"MPEG-1/2 Layer II",\r\n"MPEG-1/2 Layer III",\r\n"MPEG-2/4 AAC",\r\n"AC-3",\r\nNULL\r\n};\r\nstatic const char * const mpeg_audio_l1_bitrate[] = {\r\n"32 kbps",\r\n"64 kbps",\r\n"96 kbps",\r\n"128 kbps",\r\n"160 kbps",\r\n"192 kbps",\r\n"224 kbps",\r\n"256 kbps",\r\n"288 kbps",\r\n"320 kbps",\r\n"352 kbps",\r\n"384 kbps",\r\n"416 kbps",\r\n"448 kbps",\r\nNULL\r\n};\r\nstatic const char * const mpeg_audio_l2_bitrate[] = {\r\n"32 kbps",\r\n"48 kbps",\r\n"56 kbps",\r\n"64 kbps",\r\n"80 kbps",\r\n"96 kbps",\r\n"112 kbps",\r\n"128 kbps",\r\n"160 kbps",\r\n"192 kbps",\r\n"224 kbps",\r\n"256 kbps",\r\n"320 kbps",\r\n"384 kbps",\r\nNULL\r\n};\r\nstatic const char * const mpeg_audio_l3_bitrate[] = {\r\n"32 kbps",\r\n"40 kbps",\r\n"48 kbps",\r\n"56 kbps",\r\n"64 kbps",\r\n"80 kbps",\r\n"96 kbps",\r\n"112 kbps",\r\n"128 kbps",\r\n"160 kbps",\r\n"192 kbps",\r\n"224 kbps",\r\n"256 kbps",\r\n"320 kbps",\r\nNULL\r\n};\r\nstatic const char * const mpeg_audio_ac3_bitrate[] = {\r\n"32 kbps",\r\n"40 kbps",\r\n"48 kbps",\r\n"56 kbps",\r\n"64 kbps",\r\n"80 kbps",\r\n"96 kbps",\r\n"112 kbps",\r\n"128 kbps",\r\n"160 kbps",\r\n"192 kbps",\r\n"224 kbps",\r\n"256 kbps",\r\n"320 kbps",\r\n"384 kbps",\r\n"448 kbps",\r\n"512 kbps",\r\n"576 kbps",\r\n"640 kbps",\r\nNULL\r\n};\r\nstatic const char * const mpeg_audio_mode[] = {\r\n"Stereo",\r\n"Joint Stereo",\r\n"Dual",\r\n"Mono",\r\nNULL\r\n};\r\nstatic const char * const mpeg_audio_mode_extension[] = {\r\n"Bound 4",\r\n"Bound 8",\r\n"Bound 12",\r\n"Bound 16",\r\nNULL\r\n};\r\nstatic const char * const mpeg_audio_emphasis[] = {\r\n"No Emphasis",\r\n"50/15 us",\r\n"CCITT J17",\r\nNULL\r\n};\r\nstatic const char * const mpeg_audio_crc[] = {\r\n"No CRC",\r\n"16-bit CRC",\r\nNULL\r\n};\r\nstatic const char * const mpeg_audio_dec_playback[] = {\r\n"Auto",\r\n"Stereo",\r\n"Left",\r\n"Right",\r\n"Mono",\r\n"Swapped Stereo",\r\nNULL\r\n};\r\nstatic const char * const mpeg_video_encoding[] = {\r\n"MPEG-1",\r\n"MPEG-2",\r\n"MPEG-4 AVC",\r\nNULL\r\n};\r\nstatic const char * const mpeg_video_aspect[] = {\r\n"1x1",\r\n"4x3",\r\n"16x9",\r\n"2.21x1",\r\nNULL\r\n};\r\nstatic const char * const mpeg_video_bitrate_mode[] = {\r\n"Variable Bitrate",\r\n"Constant Bitrate",\r\nNULL\r\n};\r\nstatic const char * const mpeg_stream_type[] = {\r\n"MPEG-2 Program Stream",\r\n"MPEG-2 Transport Stream",\r\n"MPEG-1 System Stream",\r\n"MPEG-2 DVD-compatible Stream",\r\n"MPEG-1 VCD-compatible Stream",\r\n"MPEG-2 SVCD-compatible Stream",\r\nNULL\r\n};\r\nstatic const char * const mpeg_stream_vbi_fmt[] = {\r\n"No VBI",\r\n"Private Packet, IVTV Format",\r\nNULL\r\n};\r\nstatic const char * const camera_power_line_frequency[] = {\r\n"Disabled",\r\n"50 Hz",\r\n"60 Hz",\r\n"Auto",\r\nNULL\r\n};\r\nstatic const char * const camera_exposure_auto[] = {\r\n"Auto Mode",\r\n"Manual Mode",\r\n"Shutter Priority Mode",\r\n"Aperture Priority Mode",\r\nNULL\r\n};\r\nstatic const char * const camera_exposure_metering[] = {\r\n"Average",\r\n"Center Weighted",\r\n"Spot",\r\n"Matrix",\r\nNULL\r\n};\r\nstatic const char * const camera_auto_focus_range[] = {\r\n"Auto",\r\n"Normal",\r\n"Macro",\r\n"Infinity",\r\nNULL\r\n};\r\nstatic const char * const colorfx[] = {\r\n"None",\r\n"Black & White",\r\n"Sepia",\r\n"Negative",\r\n"Emboss",\r\n"Sketch",\r\n"Sky Blue",\r\n"Grass Green",\r\n"Skin Whiten",\r\n"Vivid",\r\n"Aqua",\r\n"Art Freeze",\r\n"Silhouette",\r\n"Solarization",\r\n"Antique",\r\n"Set Cb/Cr",\r\nNULL\r\n};\r\nstatic const char * const auto_n_preset_white_balance[] = {\r\n"Manual",\r\n"Auto",\r\n"Incandescent",\r\n"Fluorescent",\r\n"Fluorescent H",\r\n"Horizon",\r\n"Daylight",\r\n"Flash",\r\n"Cloudy",\r\n"Shade",\r\nNULL,\r\n};\r\nstatic const char * const camera_iso_sensitivity_auto[] = {\r\n"Manual",\r\n"Auto",\r\nNULL\r\n};\r\nstatic const char * const scene_mode[] = {\r\n"None",\r\n"Backlight",\r\n"Beach/Snow",\r\n"Candle Light",\r\n"Dusk/Dawn",\r\n"Fall Colors",\r\n"Fireworks",\r\n"Landscape",\r\n"Night",\r\n"Party/Indoor",\r\n"Portrait",\r\n"Sports",\r\n"Sunset",\r\n"Text",\r\nNULL\r\n};\r\nstatic const char * const tune_emphasis[] = {\r\n"None",\r\n"50 Microseconds",\r\n"75 Microseconds",\r\nNULL,\r\n};\r\nstatic const char * const header_mode[] = {\r\n"Separate Buffer",\r\n"Joined With 1st Frame",\r\nNULL,\r\n};\r\nstatic const char * const multi_slice[] = {\r\n"Single",\r\n"Max Macroblocks",\r\n"Max Bytes",\r\nNULL,\r\n};\r\nstatic const char * const entropy_mode[] = {\r\n"CAVLC",\r\n"CABAC",\r\nNULL,\r\n};\r\nstatic const char * const mpeg_h264_level[] = {\r\n"1",\r\n"1b",\r\n"1.1",\r\n"1.2",\r\n"1.3",\r\n"2",\r\n"2.1",\r\n"2.2",\r\n"3",\r\n"3.1",\r\n"3.2",\r\n"4",\r\n"4.1",\r\n"4.2",\r\n"5",\r\n"5.1",\r\nNULL,\r\n};\r\nstatic const char * const h264_loop_filter[] = {\r\n"Enabled",\r\n"Disabled",\r\n"Disabled at Slice Boundary",\r\nNULL,\r\n};\r\nstatic const char * const h264_profile[] = {\r\n"Baseline",\r\n"Constrained Baseline",\r\n"Main",\r\n"Extended",\r\n"High",\r\n"High 10",\r\n"High 422",\r\n"High 444 Predictive",\r\n"High 10 Intra",\r\n"High 422 Intra",\r\n"High 444 Intra",\r\n"CAVLC 444 Intra",\r\n"Scalable Baseline",\r\n"Scalable High",\r\n"Scalable High Intra",\r\n"Multiview High",\r\nNULL,\r\n};\r\nstatic const char * const vui_sar_idc[] = {\r\n"Unspecified",\r\n"1:1",\r\n"12:11",\r\n"10:11",\r\n"16:11",\r\n"40:33",\r\n"24:11",\r\n"20:11",\r\n"32:11",\r\n"80:33",\r\n"18:11",\r\n"15:11",\r\n"64:33",\r\n"160:99",\r\n"4:3",\r\n"3:2",\r\n"2:1",\r\n"Extended SAR",\r\nNULL,\r\n};\r\nstatic const char * const h264_fp_arrangement_type[] = {\r\n"Checkerboard",\r\n"Column",\r\n"Row",\r\n"Side by Side",\r\n"Top Bottom",\r\n"Temporal",\r\nNULL,\r\n};\r\nstatic const char * const h264_fmo_map_type[] = {\r\n"Interleaved Slices",\r\n"Scattered Slices",\r\n"Foreground with Leftover",\r\n"Box Out",\r\n"Raster Scan",\r\n"Wipe Scan",\r\n"Explicit",\r\nNULL,\r\n};\r\nstatic const char * const mpeg_mpeg4_level[] = {\r\n"0",\r\n"0b",\r\n"1",\r\n"2",\r\n"3",\r\n"3b",\r\n"4",\r\n"5",\r\nNULL,\r\n};\r\nstatic const char * const mpeg4_profile[] = {\r\n"Simple",\r\n"Advanced Simple",\r\n"Core",\r\n"Simple Scalable",\r\n"Advanced Coding Efficiency",\r\nNULL,\r\n};\r\nstatic const char * const vpx_golden_frame_sel[] = {\r\n"Use Previous Frame",\r\n"Use Previous Specific Frame",\r\nNULL,\r\n};\r\nstatic const char * const flash_led_mode[] = {\r\n"Off",\r\n"Flash",\r\n"Torch",\r\nNULL,\r\n};\r\nstatic const char * const flash_strobe_source[] = {\r\n"Software",\r\n"External",\r\nNULL,\r\n};\r\nstatic const char * const jpeg_chroma_subsampling[] = {\r\n"4:4:4",\r\n"4:2:2",\r\n"4:2:0",\r\n"4:1:1",\r\n"4:1:0",\r\n"Gray",\r\nNULL,\r\n};\r\nstatic const char * const dv_tx_mode[] = {\r\n"DVI-D",\r\n"HDMI",\r\nNULL,\r\n};\r\nstatic const char * const dv_rgb_range[] = {\r\n"Automatic",\r\n"RGB limited range (16-235)",\r\n"RGB full range (0-255)",\r\nNULL,\r\n};\r\nstatic const char * const detect_md_mode[] = {\r\n"Disabled",\r\n"Global",\r\n"Threshold Grid",\r\n"Region Grid",\r\nNULL,\r\n};\r\nswitch (id) {\r\ncase V4L2_CID_MPEG_AUDIO_SAMPLING_FREQ:\r\nreturn mpeg_audio_sampling_freq;\r\ncase V4L2_CID_MPEG_AUDIO_ENCODING:\r\nreturn mpeg_audio_encoding;\r\ncase V4L2_CID_MPEG_AUDIO_L1_BITRATE:\r\nreturn mpeg_audio_l1_bitrate;\r\ncase V4L2_CID_MPEG_AUDIO_L2_BITRATE:\r\nreturn mpeg_audio_l2_bitrate;\r\ncase V4L2_CID_MPEG_AUDIO_L3_BITRATE:\r\nreturn mpeg_audio_l3_bitrate;\r\ncase V4L2_CID_MPEG_AUDIO_AC3_BITRATE:\r\nreturn mpeg_audio_ac3_bitrate;\r\ncase V4L2_CID_MPEG_AUDIO_MODE:\r\nreturn mpeg_audio_mode;\r\ncase V4L2_CID_MPEG_AUDIO_MODE_EXTENSION:\r\nreturn mpeg_audio_mode_extension;\r\ncase V4L2_CID_MPEG_AUDIO_EMPHASIS:\r\nreturn mpeg_audio_emphasis;\r\ncase V4L2_CID_MPEG_AUDIO_CRC:\r\nreturn mpeg_audio_crc;\r\ncase V4L2_CID_MPEG_AUDIO_DEC_PLAYBACK:\r\ncase V4L2_CID_MPEG_AUDIO_DEC_MULTILINGUAL_PLAYBACK:\r\nreturn mpeg_audio_dec_playback;\r\ncase V4L2_CID_MPEG_VIDEO_ENCODING:\r\nreturn mpeg_video_encoding;\r\ncase V4L2_CID_MPEG_VIDEO_ASPECT:\r\nreturn mpeg_video_aspect;\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE_MODE:\r\nreturn mpeg_video_bitrate_mode;\r\ncase V4L2_CID_MPEG_STREAM_TYPE:\r\nreturn mpeg_stream_type;\r\ncase V4L2_CID_MPEG_STREAM_VBI_FMT:\r\nreturn mpeg_stream_vbi_fmt;\r\ncase V4L2_CID_POWER_LINE_FREQUENCY:\r\nreturn camera_power_line_frequency;\r\ncase V4L2_CID_EXPOSURE_AUTO:\r\nreturn camera_exposure_auto;\r\ncase V4L2_CID_EXPOSURE_METERING:\r\nreturn camera_exposure_metering;\r\ncase V4L2_CID_AUTO_FOCUS_RANGE:\r\nreturn camera_auto_focus_range;\r\ncase V4L2_CID_COLORFX:\r\nreturn colorfx;\r\ncase V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:\r\nreturn auto_n_preset_white_balance;\r\ncase V4L2_CID_ISO_SENSITIVITY_AUTO:\r\nreturn camera_iso_sensitivity_auto;\r\ncase V4L2_CID_SCENE_MODE:\r\nreturn scene_mode;\r\ncase V4L2_CID_TUNE_PREEMPHASIS:\r\nreturn tune_emphasis;\r\ncase V4L2_CID_TUNE_DEEMPHASIS:\r\nreturn tune_emphasis;\r\ncase V4L2_CID_FLASH_LED_MODE:\r\nreturn flash_led_mode;\r\ncase V4L2_CID_FLASH_STROBE_SOURCE:\r\nreturn flash_strobe_source;\r\ncase V4L2_CID_MPEG_VIDEO_HEADER_MODE:\r\nreturn header_mode;\r\ncase V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE:\r\nreturn multi_slice;\r\ncase V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE:\r\nreturn entropy_mode;\r\ncase V4L2_CID_MPEG_VIDEO_H264_LEVEL:\r\nreturn mpeg_h264_level;\r\ncase V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_MODE:\r\nreturn h264_loop_filter;\r\ncase V4L2_CID_MPEG_VIDEO_H264_PROFILE:\r\nreturn h264_profile;\r\ncase V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC:\r\nreturn vui_sar_idc;\r\ncase V4L2_CID_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE:\r\nreturn h264_fp_arrangement_type;\r\ncase V4L2_CID_MPEG_VIDEO_H264_FMO_MAP_TYPE:\r\nreturn h264_fmo_map_type;\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_LEVEL:\r\nreturn mpeg_mpeg4_level;\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_PROFILE:\r\nreturn mpeg4_profile;\r\ncase V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_SEL:\r\nreturn vpx_golden_frame_sel;\r\ncase V4L2_CID_JPEG_CHROMA_SUBSAMPLING:\r\nreturn jpeg_chroma_subsampling;\r\ncase V4L2_CID_DV_TX_MODE:\r\nreturn dv_tx_mode;\r\ncase V4L2_CID_DV_TX_RGB_RANGE:\r\ncase V4L2_CID_DV_RX_RGB_RANGE:\r\nreturn dv_rgb_range;\r\ncase V4L2_CID_DETECT_MD_MODE:\r\nreturn detect_md_mode;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nconst s64 *v4l2_ctrl_get_int_menu(u32 id, u32 *len)\r\n{\r\nstatic const s64 qmenu_int_vpx_num_partitions[] = {\r\n1, 2, 4, 8,\r\n};\r\nstatic const s64 qmenu_int_vpx_num_ref_frames[] = {\r\n1, 2, 3,\r\n};\r\nswitch (id) {\r\ncase V4L2_CID_MPEG_VIDEO_VPX_NUM_PARTITIONS:\r\nreturn __v4l2_qmenu_int_len(qmenu_int_vpx_num_partitions, len);\r\ncase V4L2_CID_MPEG_VIDEO_VPX_NUM_REF_FRAMES:\r\nreturn __v4l2_qmenu_int_len(qmenu_int_vpx_num_ref_frames, len);\r\ndefault:\r\n*len = 0;\r\nreturn NULL;\r\n}\r\n}\r\nconst char *v4l2_ctrl_get_name(u32 id)\r\n{\r\nswitch (id) {\r\ncase V4L2_CID_USER_CLASS: return "User Controls";\r\ncase V4L2_CID_BRIGHTNESS: return "Brightness";\r\ncase V4L2_CID_CONTRAST: return "Contrast";\r\ncase V4L2_CID_SATURATION: return "Saturation";\r\ncase V4L2_CID_HUE: return "Hue";\r\ncase V4L2_CID_AUDIO_VOLUME: return "Volume";\r\ncase V4L2_CID_AUDIO_BALANCE: return "Balance";\r\ncase V4L2_CID_AUDIO_BASS: return "Bass";\r\ncase V4L2_CID_AUDIO_TREBLE: return "Treble";\r\ncase V4L2_CID_AUDIO_MUTE: return "Mute";\r\ncase V4L2_CID_AUDIO_LOUDNESS: return "Loudness";\r\ncase V4L2_CID_BLACK_LEVEL: return "Black Level";\r\ncase V4L2_CID_AUTO_WHITE_BALANCE: return "White Balance, Automatic";\r\ncase V4L2_CID_DO_WHITE_BALANCE: return "Do White Balance";\r\ncase V4L2_CID_RED_BALANCE: return "Red Balance";\r\ncase V4L2_CID_BLUE_BALANCE: return "Blue Balance";\r\ncase V4L2_CID_GAMMA: return "Gamma";\r\ncase V4L2_CID_EXPOSURE: return "Exposure";\r\ncase V4L2_CID_AUTOGAIN: return "Gain, Automatic";\r\ncase V4L2_CID_GAIN: return "Gain";\r\ncase V4L2_CID_HFLIP: return "Horizontal Flip";\r\ncase V4L2_CID_VFLIP: return "Vertical Flip";\r\ncase V4L2_CID_POWER_LINE_FREQUENCY: return "Power Line Frequency";\r\ncase V4L2_CID_HUE_AUTO: return "Hue, Automatic";\r\ncase V4L2_CID_WHITE_BALANCE_TEMPERATURE: return "White Balance Temperature";\r\ncase V4L2_CID_SHARPNESS: return "Sharpness";\r\ncase V4L2_CID_BACKLIGHT_COMPENSATION: return "Backlight Compensation";\r\ncase V4L2_CID_CHROMA_AGC: return "Chroma AGC";\r\ncase V4L2_CID_COLOR_KILLER: return "Color Killer";\r\ncase V4L2_CID_COLORFX: return "Color Effects";\r\ncase V4L2_CID_AUTOBRIGHTNESS: return "Brightness, Automatic";\r\ncase V4L2_CID_BAND_STOP_FILTER: return "Band-Stop Filter";\r\ncase V4L2_CID_ROTATE: return "Rotate";\r\ncase V4L2_CID_BG_COLOR: return "Background Color";\r\ncase V4L2_CID_CHROMA_GAIN: return "Chroma Gain";\r\ncase V4L2_CID_ILLUMINATORS_1: return "Illuminator 1";\r\ncase V4L2_CID_ILLUMINATORS_2: return "Illuminator 2";\r\ncase V4L2_CID_MIN_BUFFERS_FOR_CAPTURE: return "Min Number of Capture Buffers";\r\ncase V4L2_CID_MIN_BUFFERS_FOR_OUTPUT: return "Min Number of Output Buffers";\r\ncase V4L2_CID_ALPHA_COMPONENT: return "Alpha Component";\r\ncase V4L2_CID_COLORFX_CBCR: return "Color Effects, CbCr";\r\ncase V4L2_CID_MPEG_CLASS: return "Codec Controls";\r\ncase V4L2_CID_MPEG_STREAM_TYPE: return "Stream Type";\r\ncase V4L2_CID_MPEG_STREAM_PID_PMT: return "Stream PMT Program ID";\r\ncase V4L2_CID_MPEG_STREAM_PID_AUDIO: return "Stream Audio Program ID";\r\ncase V4L2_CID_MPEG_STREAM_PID_VIDEO: return "Stream Video Program ID";\r\ncase V4L2_CID_MPEG_STREAM_PID_PCR: return "Stream PCR Program ID";\r\ncase V4L2_CID_MPEG_STREAM_PES_ID_AUDIO: return "Stream PES Audio ID";\r\ncase V4L2_CID_MPEG_STREAM_PES_ID_VIDEO: return "Stream PES Video ID";\r\ncase V4L2_CID_MPEG_STREAM_VBI_FMT: return "Stream VBI Format";\r\ncase V4L2_CID_MPEG_AUDIO_SAMPLING_FREQ: return "Audio Sampling Frequency";\r\ncase V4L2_CID_MPEG_AUDIO_ENCODING: return "Audio Encoding";\r\ncase V4L2_CID_MPEG_AUDIO_L1_BITRATE: return "Audio Layer I Bitrate";\r\ncase V4L2_CID_MPEG_AUDIO_L2_BITRATE: return "Audio Layer II Bitrate";\r\ncase V4L2_CID_MPEG_AUDIO_L3_BITRATE: return "Audio Layer III Bitrate";\r\ncase V4L2_CID_MPEG_AUDIO_MODE: return "Audio Stereo Mode";\r\ncase V4L2_CID_MPEG_AUDIO_MODE_EXTENSION: return "Audio Stereo Mode Extension";\r\ncase V4L2_CID_MPEG_AUDIO_EMPHASIS: return "Audio Emphasis";\r\ncase V4L2_CID_MPEG_AUDIO_CRC: return "Audio CRC";\r\ncase V4L2_CID_MPEG_AUDIO_MUTE: return "Audio Mute";\r\ncase V4L2_CID_MPEG_AUDIO_AAC_BITRATE: return "Audio AAC Bitrate";\r\ncase V4L2_CID_MPEG_AUDIO_AC3_BITRATE: return "Audio AC-3 Bitrate";\r\ncase V4L2_CID_MPEG_AUDIO_DEC_PLAYBACK: return "Audio Playback";\r\ncase V4L2_CID_MPEG_AUDIO_DEC_MULTILINGUAL_PLAYBACK: return "Audio Multilingual Playback";\r\ncase V4L2_CID_MPEG_VIDEO_ENCODING: return "Video Encoding";\r\ncase V4L2_CID_MPEG_VIDEO_ASPECT: return "Video Aspect";\r\ncase V4L2_CID_MPEG_VIDEO_B_FRAMES: return "Video B Frames";\r\ncase V4L2_CID_MPEG_VIDEO_GOP_SIZE: return "Video GOP Size";\r\ncase V4L2_CID_MPEG_VIDEO_GOP_CLOSURE: return "Video GOP Closure";\r\ncase V4L2_CID_MPEG_VIDEO_PULLDOWN: return "Video Pulldown";\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE_MODE: return "Video Bitrate Mode";\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE: return "Video Bitrate";\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE_PEAK: return "Video Peak Bitrate";\r\ncase V4L2_CID_MPEG_VIDEO_TEMPORAL_DECIMATION: return "Video Temporal Decimation";\r\ncase V4L2_CID_MPEG_VIDEO_MUTE: return "Video Mute";\r\ncase V4L2_CID_MPEG_VIDEO_MUTE_YUV: return "Video Mute YUV";\r\ncase V4L2_CID_MPEG_VIDEO_DECODER_SLICE_INTERFACE: return "Decoder Slice Interface";\r\ncase V4L2_CID_MPEG_VIDEO_DECODER_MPEG4_DEBLOCK_FILTER: return "MPEG4 Loop Filter Enable";\r\ncase V4L2_CID_MPEG_VIDEO_CYCLIC_INTRA_REFRESH_MB: return "Number of Intra Refresh MBs";\r\ncase V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE: return "Frame Level Rate Control Enable";\r\ncase V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE: return "H264 MB Level Rate Control";\r\ncase V4L2_CID_MPEG_VIDEO_HEADER_MODE: return "Sequence Header Mode";\r\ncase V4L2_CID_MPEG_VIDEO_MAX_REF_PIC: return "Max Number of Reference Pics";\r\ncase V4L2_CID_MPEG_VIDEO_H263_I_FRAME_QP: return "H263 I-Frame QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_H263_P_FRAME_QP: return "H263 P-Frame QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_H263_B_FRAME_QP: return "H263 B-Frame QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_H263_MIN_QP: return "H263 Minimum QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_H263_MAX_QP: return "H263 Maximum QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP: return "H264 I-Frame QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP: return "H264 P-Frame QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_H264_B_FRAME_QP: return "H264 B-Frame QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_H264_MAX_QP: return "H264 Maximum QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_H264_MIN_QP: return "H264 Minimum QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_H264_8X8_TRANSFORM: return "H264 8x8 Transform Enable";\r\ncase V4L2_CID_MPEG_VIDEO_H264_CPB_SIZE: return "H264 CPB Buffer Size";\r\ncase V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE: return "H264 Entropy Mode";\r\ncase V4L2_CID_MPEG_VIDEO_H264_I_PERIOD: return "H264 I-Frame Period";\r\ncase V4L2_CID_MPEG_VIDEO_H264_LEVEL: return "H264 Level";\r\ncase V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_ALPHA: return "H264 Loop Filter Alpha Offset";\r\ncase V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_BETA: return "H264 Loop Filter Beta Offset";\r\ncase V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_MODE: return "H264 Loop Filter Mode";\r\ncase V4L2_CID_MPEG_VIDEO_H264_PROFILE: return "H264 Profile";\r\ncase V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_HEIGHT: return "Vertical Size of SAR";\r\ncase V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_WIDTH: return "Horizontal Size of SAR";\r\ncase V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_ENABLE: return "Aspect Ratio VUI Enable";\r\ncase V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC: return "VUI Aspect Ratio IDC";\r\ncase V4L2_CID_MPEG_VIDEO_H264_SEI_FRAME_PACKING: return "H264 Enable Frame Packing SEI";\r\ncase V4L2_CID_MPEG_VIDEO_H264_SEI_FP_CURRENT_FRAME_0: return "H264 Set Curr. Frame as Frame0";\r\ncase V4L2_CID_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE: return "H264 FP Arrangement Type";\r\ncase V4L2_CID_MPEG_VIDEO_H264_FMO: return "H264 Flexible MB Ordering";\r\ncase V4L2_CID_MPEG_VIDEO_H264_FMO_MAP_TYPE: return "H264 Map Type for FMO";\r\ncase V4L2_CID_MPEG_VIDEO_H264_FMO_SLICE_GROUP: return "H264 FMO Number of Slice Groups";\r\ncase V4L2_CID_MPEG_VIDEO_H264_FMO_CHANGE_DIRECTION: return "H264 FMO Direction of Change";\r\ncase V4L2_CID_MPEG_VIDEO_H264_FMO_CHANGE_RATE: return "H264 FMO Size of 1st Slice Grp";\r\ncase V4L2_CID_MPEG_VIDEO_H264_FMO_RUN_LENGTH: return "H264 FMO No. of Consecutive MBs";\r\ncase V4L2_CID_MPEG_VIDEO_H264_ASO: return "H264 Arbitrary Slice Ordering";\r\ncase V4L2_CID_MPEG_VIDEO_H264_ASO_SLICE_ORDER: return "H264 ASO Slice Order";\r\ncase V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING: return "Enable H264 Hierarchical Coding";\r\ncase V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_TYPE: return "H264 Hierarchical Coding Type";\r\ncase V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_LAYER:return "H264 Number of HC Layers";\r\ncase V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_LAYER_QP:\r\nreturn "H264 Set QP Value for HC Layers";\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_I_FRAME_QP: return "MPEG4 I-Frame QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_P_FRAME_QP: return "MPEG4 P-Frame QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_B_FRAME_QP: return "MPEG4 B-Frame QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_MIN_QP: return "MPEG4 Minimum QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_MAX_QP: return "MPEG4 Maximum QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_LEVEL: return "MPEG4 Level";\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_PROFILE: return "MPEG4 Profile";\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_QPEL: return "Quarter Pixel Search Enable";\r\ncase V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_BYTES: return "Maximum Bytes in a Slice";\r\ncase V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_MB: return "Number of MBs in a Slice";\r\ncase V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE: return "Slice Partitioning Method";\r\ncase V4L2_CID_MPEG_VIDEO_VBV_SIZE: return "VBV Buffer Size";\r\ncase V4L2_CID_MPEG_VIDEO_DEC_PTS: return "Video Decoder PTS";\r\ncase V4L2_CID_MPEG_VIDEO_DEC_FRAME: return "Video Decoder Frame Count";\r\ncase V4L2_CID_MPEG_VIDEO_VBV_DELAY: return "Initial Delay for VBV Control";\r\ncase V4L2_CID_MPEG_VIDEO_MV_H_SEARCH_RANGE: return "Horizontal MV Search Range";\r\ncase V4L2_CID_MPEG_VIDEO_MV_V_SEARCH_RANGE: return "Vertical MV Search Range";\r\ncase V4L2_CID_MPEG_VIDEO_REPEAT_SEQ_HEADER: return "Repeat Sequence Header";\r\ncase V4L2_CID_MPEG_VIDEO_VPX_NUM_PARTITIONS: return "VPX Number of Partitions";\r\ncase V4L2_CID_MPEG_VIDEO_VPX_IMD_DISABLE_4X4: return "VPX Intra Mode Decision Disable";\r\ncase V4L2_CID_MPEG_VIDEO_VPX_NUM_REF_FRAMES: return "VPX No. of Refs for P Frame";\r\ncase V4L2_CID_MPEG_VIDEO_VPX_FILTER_LEVEL: return "VPX Loop Filter Level Range";\r\ncase V4L2_CID_MPEG_VIDEO_VPX_FILTER_SHARPNESS: return "VPX Deblocking Effect Control";\r\ncase V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_REF_PERIOD: return "VPX Golden Frame Refresh Period";\r\ncase V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_SEL: return "VPX Golden Frame Indicator";\r\ncase V4L2_CID_MPEG_VIDEO_VPX_MIN_QP: return "VPX Minimum QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_VPX_MAX_QP: return "VPX Maximum QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_VPX_I_FRAME_QP: return "VPX I-Frame QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_VPX_P_FRAME_QP: return "VPX P-Frame QP Value";\r\ncase V4L2_CID_MPEG_VIDEO_VPX_PROFILE: return "VPX Profile";\r\ncase V4L2_CID_CAMERA_CLASS: return "Camera Controls";\r\ncase V4L2_CID_EXPOSURE_AUTO: return "Auto Exposure";\r\ncase V4L2_CID_EXPOSURE_ABSOLUTE: return "Exposure Time, Absolute";\r\ncase V4L2_CID_EXPOSURE_AUTO_PRIORITY: return "Exposure, Dynamic Framerate";\r\ncase V4L2_CID_PAN_RELATIVE: return "Pan, Relative";\r\ncase V4L2_CID_TILT_RELATIVE: return "Tilt, Relative";\r\ncase V4L2_CID_PAN_RESET: return "Pan, Reset";\r\ncase V4L2_CID_TILT_RESET: return "Tilt, Reset";\r\ncase V4L2_CID_PAN_ABSOLUTE: return "Pan, Absolute";\r\ncase V4L2_CID_TILT_ABSOLUTE: return "Tilt, Absolute";\r\ncase V4L2_CID_FOCUS_ABSOLUTE: return "Focus, Absolute";\r\ncase V4L2_CID_FOCUS_RELATIVE: return "Focus, Relative";\r\ncase V4L2_CID_FOCUS_AUTO: return "Focus, Automatic Continuous";\r\ncase V4L2_CID_ZOOM_ABSOLUTE: return "Zoom, Absolute";\r\ncase V4L2_CID_ZOOM_RELATIVE: return "Zoom, Relative";\r\ncase V4L2_CID_ZOOM_CONTINUOUS: return "Zoom, Continuous";\r\ncase V4L2_CID_PRIVACY: return "Privacy";\r\ncase V4L2_CID_IRIS_ABSOLUTE: return "Iris, Absolute";\r\ncase V4L2_CID_IRIS_RELATIVE: return "Iris, Relative";\r\ncase V4L2_CID_AUTO_EXPOSURE_BIAS: return "Auto Exposure, Bias";\r\ncase V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE: return "White Balance, Auto & Preset";\r\ncase V4L2_CID_WIDE_DYNAMIC_RANGE: return "Wide Dynamic Range";\r\ncase V4L2_CID_IMAGE_STABILIZATION: return "Image Stabilization";\r\ncase V4L2_CID_ISO_SENSITIVITY: return "ISO Sensitivity";\r\ncase V4L2_CID_ISO_SENSITIVITY_AUTO: return "ISO Sensitivity, Auto";\r\ncase V4L2_CID_EXPOSURE_METERING: return "Exposure, Metering Mode";\r\ncase V4L2_CID_SCENE_MODE: return "Scene Mode";\r\ncase V4L2_CID_3A_LOCK: return "3A Lock";\r\ncase V4L2_CID_AUTO_FOCUS_START: return "Auto Focus, Start";\r\ncase V4L2_CID_AUTO_FOCUS_STOP: return "Auto Focus, Stop";\r\ncase V4L2_CID_AUTO_FOCUS_STATUS: return "Auto Focus, Status";\r\ncase V4L2_CID_AUTO_FOCUS_RANGE: return "Auto Focus, Range";\r\ncase V4L2_CID_PAN_SPEED: return "Pan, Speed";\r\ncase V4L2_CID_TILT_SPEED: return "Tilt, Speed";\r\ncase V4L2_CID_FM_TX_CLASS: return "FM Radio Modulator Controls";\r\ncase V4L2_CID_RDS_TX_DEVIATION: return "RDS Signal Deviation";\r\ncase V4L2_CID_RDS_TX_PI: return "RDS Program ID";\r\ncase V4L2_CID_RDS_TX_PTY: return "RDS Program Type";\r\ncase V4L2_CID_RDS_TX_PS_NAME: return "RDS PS Name";\r\ncase V4L2_CID_RDS_TX_RADIO_TEXT: return "RDS Radio Text";\r\ncase V4L2_CID_RDS_TX_MONO_STEREO: return "RDS Stereo";\r\ncase V4L2_CID_RDS_TX_ARTIFICIAL_HEAD: return "RDS Artificial Head";\r\ncase V4L2_CID_RDS_TX_COMPRESSED: return "RDS Compressed";\r\ncase V4L2_CID_RDS_TX_DYNAMIC_PTY: return "RDS Dynamic PTY";\r\ncase V4L2_CID_RDS_TX_TRAFFIC_ANNOUNCEMENT: return "RDS Traffic Announcement";\r\ncase V4L2_CID_RDS_TX_TRAFFIC_PROGRAM: return "RDS Traffic Program";\r\ncase V4L2_CID_RDS_TX_MUSIC_SPEECH: return "RDS Music";\r\ncase V4L2_CID_RDS_TX_ALT_FREQS_ENABLE: return "RDS Enable Alt Frequencies";\r\ncase V4L2_CID_RDS_TX_ALT_FREQS: return "RDS Alternate Frequencies";\r\ncase V4L2_CID_AUDIO_LIMITER_ENABLED: return "Audio Limiter Feature Enabled";\r\ncase V4L2_CID_AUDIO_LIMITER_RELEASE_TIME: return "Audio Limiter Release Time";\r\ncase V4L2_CID_AUDIO_LIMITER_DEVIATION: return "Audio Limiter Deviation";\r\ncase V4L2_CID_AUDIO_COMPRESSION_ENABLED: return "Audio Compression Enabled";\r\ncase V4L2_CID_AUDIO_COMPRESSION_GAIN: return "Audio Compression Gain";\r\ncase V4L2_CID_AUDIO_COMPRESSION_THRESHOLD: return "Audio Compression Threshold";\r\ncase V4L2_CID_AUDIO_COMPRESSION_ATTACK_TIME: return "Audio Compression Attack Time";\r\ncase V4L2_CID_AUDIO_COMPRESSION_RELEASE_TIME: return "Audio Compression Release Time";\r\ncase V4L2_CID_PILOT_TONE_ENABLED: return "Pilot Tone Feature Enabled";\r\ncase V4L2_CID_PILOT_TONE_DEVIATION: return "Pilot Tone Deviation";\r\ncase V4L2_CID_PILOT_TONE_FREQUENCY: return "Pilot Tone Frequency";\r\ncase V4L2_CID_TUNE_PREEMPHASIS: return "Pre-Emphasis";\r\ncase V4L2_CID_TUNE_POWER_LEVEL: return "Tune Power Level";\r\ncase V4L2_CID_TUNE_ANTENNA_CAPACITOR: return "Tune Antenna Capacitor";\r\ncase V4L2_CID_FLASH_CLASS: return "Flash Controls";\r\ncase V4L2_CID_FLASH_LED_MODE: return "LED Mode";\r\ncase V4L2_CID_FLASH_STROBE_SOURCE: return "Strobe Source";\r\ncase V4L2_CID_FLASH_STROBE: return "Strobe";\r\ncase V4L2_CID_FLASH_STROBE_STOP: return "Stop Strobe";\r\ncase V4L2_CID_FLASH_STROBE_STATUS: return "Strobe Status";\r\ncase V4L2_CID_FLASH_TIMEOUT: return "Strobe Timeout";\r\ncase V4L2_CID_FLASH_INTENSITY: return "Intensity, Flash Mode";\r\ncase V4L2_CID_FLASH_TORCH_INTENSITY: return "Intensity, Torch Mode";\r\ncase V4L2_CID_FLASH_INDICATOR_INTENSITY: return "Intensity, Indicator";\r\ncase V4L2_CID_FLASH_FAULT: return "Faults";\r\ncase V4L2_CID_FLASH_CHARGE: return "Charge";\r\ncase V4L2_CID_FLASH_READY: return "Ready to Strobe";\r\ncase V4L2_CID_JPEG_CLASS: return "JPEG Compression Controls";\r\ncase V4L2_CID_JPEG_CHROMA_SUBSAMPLING: return "Chroma Subsampling";\r\ncase V4L2_CID_JPEG_RESTART_INTERVAL: return "Restart Interval";\r\ncase V4L2_CID_JPEG_COMPRESSION_QUALITY: return "Compression Quality";\r\ncase V4L2_CID_JPEG_ACTIVE_MARKER: return "Active Markers";\r\ncase V4L2_CID_IMAGE_SOURCE_CLASS: return "Image Source Controls";\r\ncase V4L2_CID_VBLANK: return "Vertical Blanking";\r\ncase V4L2_CID_HBLANK: return "Horizontal Blanking";\r\ncase V4L2_CID_ANALOGUE_GAIN: return "Analogue Gain";\r\ncase V4L2_CID_TEST_PATTERN_RED: return "Red Pixel Value";\r\ncase V4L2_CID_TEST_PATTERN_GREENR: return "Green (Red) Pixel Value";\r\ncase V4L2_CID_TEST_PATTERN_BLUE: return "Blue Pixel Value";\r\ncase V4L2_CID_TEST_PATTERN_GREENB: return "Green (Blue) Pixel Value";\r\ncase V4L2_CID_IMAGE_PROC_CLASS: return "Image Processing Controls";\r\ncase V4L2_CID_LINK_FREQ: return "Link Frequency";\r\ncase V4L2_CID_PIXEL_RATE: return "Pixel Rate";\r\ncase V4L2_CID_TEST_PATTERN: return "Test Pattern";\r\ncase V4L2_CID_DV_CLASS: return "Digital Video Controls";\r\ncase V4L2_CID_DV_TX_HOTPLUG: return "Hotplug Present";\r\ncase V4L2_CID_DV_TX_RXSENSE: return "RxSense Present";\r\ncase V4L2_CID_DV_TX_EDID_PRESENT: return "EDID Present";\r\ncase V4L2_CID_DV_TX_MODE: return "Transmit Mode";\r\ncase V4L2_CID_DV_TX_RGB_RANGE: return "Tx RGB Quantization Range";\r\ncase V4L2_CID_DV_RX_POWER_PRESENT: return "Power Present";\r\ncase V4L2_CID_DV_RX_RGB_RANGE: return "Rx RGB Quantization Range";\r\ncase V4L2_CID_FM_RX_CLASS: return "FM Radio Receiver Controls";\r\ncase V4L2_CID_TUNE_DEEMPHASIS: return "De-Emphasis";\r\ncase V4L2_CID_RDS_RECEPTION: return "RDS Reception";\r\ncase V4L2_CID_RF_TUNER_CLASS: return "RF Tuner Controls";\r\ncase V4L2_CID_RF_TUNER_LNA_GAIN_AUTO: return "LNA Gain, Auto";\r\ncase V4L2_CID_RF_TUNER_LNA_GAIN: return "LNA Gain";\r\ncase V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO: return "Mixer Gain, Auto";\r\ncase V4L2_CID_RF_TUNER_MIXER_GAIN: return "Mixer Gain";\r\ncase V4L2_CID_RF_TUNER_IF_GAIN_AUTO: return "IF Gain, Auto";\r\ncase V4L2_CID_RF_TUNER_IF_GAIN: return "IF Gain";\r\ncase V4L2_CID_RF_TUNER_BANDWIDTH_AUTO: return "Bandwidth, Auto";\r\ncase V4L2_CID_RF_TUNER_BANDWIDTH: return "Bandwidth";\r\ncase V4L2_CID_RF_TUNER_PLL_LOCK: return "PLL Lock";\r\ncase V4L2_CID_RDS_RX_PTY: return "RDS Program Type";\r\ncase V4L2_CID_RDS_RX_PS_NAME: return "RDS PS Name";\r\ncase V4L2_CID_RDS_RX_RADIO_TEXT: return "RDS Radio Text";\r\ncase V4L2_CID_RDS_RX_TRAFFIC_ANNOUNCEMENT: return "RDS Traffic Announcement";\r\ncase V4L2_CID_RDS_RX_TRAFFIC_PROGRAM: return "RDS Traffic Program";\r\ncase V4L2_CID_RDS_RX_MUSIC_SPEECH: return "RDS Music";\r\ncase V4L2_CID_DETECT_CLASS: return "Detection Controls";\r\ncase V4L2_CID_DETECT_MD_MODE: return "Motion Detection Mode";\r\ncase V4L2_CID_DETECT_MD_GLOBAL_THRESHOLD: return "MD Global Threshold";\r\ncase V4L2_CID_DETECT_MD_THRESHOLD_GRID: return "MD Threshold Grid";\r\ncase V4L2_CID_DETECT_MD_REGION_GRID: return "MD Region Grid";\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nvoid v4l2_ctrl_fill(u32 id, const char **name, enum v4l2_ctrl_type *type,\r\ns64 *min, s64 *max, u64 *step, s64 *def, u32 *flags)\r\n{\r\n*name = v4l2_ctrl_get_name(id);\r\n*flags = 0;\r\nswitch (id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\ncase V4L2_CID_AUDIO_LOUDNESS:\r\ncase V4L2_CID_AUTO_WHITE_BALANCE:\r\ncase V4L2_CID_AUTOGAIN:\r\ncase V4L2_CID_HFLIP:\r\ncase V4L2_CID_VFLIP:\r\ncase V4L2_CID_HUE_AUTO:\r\ncase V4L2_CID_CHROMA_AGC:\r\ncase V4L2_CID_COLOR_KILLER:\r\ncase V4L2_CID_AUTOBRIGHTNESS:\r\ncase V4L2_CID_MPEG_AUDIO_MUTE:\r\ncase V4L2_CID_MPEG_VIDEO_MUTE:\r\ncase V4L2_CID_MPEG_VIDEO_GOP_CLOSURE:\r\ncase V4L2_CID_MPEG_VIDEO_PULLDOWN:\r\ncase V4L2_CID_EXPOSURE_AUTO_PRIORITY:\r\ncase V4L2_CID_FOCUS_AUTO:\r\ncase V4L2_CID_PRIVACY:\r\ncase V4L2_CID_AUDIO_LIMITER_ENABLED:\r\ncase V4L2_CID_AUDIO_COMPRESSION_ENABLED:\r\ncase V4L2_CID_PILOT_TONE_ENABLED:\r\ncase V4L2_CID_ILLUMINATORS_1:\r\ncase V4L2_CID_ILLUMINATORS_2:\r\ncase V4L2_CID_FLASH_STROBE_STATUS:\r\ncase V4L2_CID_FLASH_CHARGE:\r\ncase V4L2_CID_FLASH_READY:\r\ncase V4L2_CID_MPEG_VIDEO_DECODER_MPEG4_DEBLOCK_FILTER:\r\ncase V4L2_CID_MPEG_VIDEO_DECODER_SLICE_INTERFACE:\r\ncase V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE:\r\ncase V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE:\r\ncase V4L2_CID_MPEG_VIDEO_H264_8X8_TRANSFORM:\r\ncase V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_ENABLE:\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_QPEL:\r\ncase V4L2_CID_MPEG_VIDEO_REPEAT_SEQ_HEADER:\r\ncase V4L2_CID_WIDE_DYNAMIC_RANGE:\r\ncase V4L2_CID_IMAGE_STABILIZATION:\r\ncase V4L2_CID_RDS_RECEPTION:\r\ncase V4L2_CID_RF_TUNER_LNA_GAIN_AUTO:\r\ncase V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO:\r\ncase V4L2_CID_RF_TUNER_IF_GAIN_AUTO:\r\ncase V4L2_CID_RF_TUNER_BANDWIDTH_AUTO:\r\ncase V4L2_CID_RF_TUNER_PLL_LOCK:\r\ncase V4L2_CID_RDS_TX_MONO_STEREO:\r\ncase V4L2_CID_RDS_TX_ARTIFICIAL_HEAD:\r\ncase V4L2_CID_RDS_TX_COMPRESSED:\r\ncase V4L2_CID_RDS_TX_DYNAMIC_PTY:\r\ncase V4L2_CID_RDS_TX_TRAFFIC_ANNOUNCEMENT:\r\ncase V4L2_CID_RDS_TX_TRAFFIC_PROGRAM:\r\ncase V4L2_CID_RDS_TX_MUSIC_SPEECH:\r\ncase V4L2_CID_RDS_TX_ALT_FREQS_ENABLE:\r\ncase V4L2_CID_RDS_RX_TRAFFIC_ANNOUNCEMENT:\r\ncase V4L2_CID_RDS_RX_TRAFFIC_PROGRAM:\r\ncase V4L2_CID_RDS_RX_MUSIC_SPEECH:\r\n*type = V4L2_CTRL_TYPE_BOOLEAN;\r\n*min = 0;\r\n*max = *step = 1;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_MV_H_SEARCH_RANGE:\r\ncase V4L2_CID_MPEG_VIDEO_MV_V_SEARCH_RANGE:\r\n*type = V4L2_CTRL_TYPE_INTEGER;\r\nbreak;\r\ncase V4L2_CID_PAN_RESET:\r\ncase V4L2_CID_TILT_RESET:\r\ncase V4L2_CID_FLASH_STROBE:\r\ncase V4L2_CID_FLASH_STROBE_STOP:\r\ncase V4L2_CID_AUTO_FOCUS_START:\r\ncase V4L2_CID_AUTO_FOCUS_STOP:\r\n*type = V4L2_CTRL_TYPE_BUTTON;\r\n*flags |= V4L2_CTRL_FLAG_WRITE_ONLY |\r\nV4L2_CTRL_FLAG_EXECUTE_ON_WRITE;\r\n*min = *max = *step = *def = 0;\r\nbreak;\r\ncase V4L2_CID_POWER_LINE_FREQUENCY:\r\ncase V4L2_CID_MPEG_AUDIO_SAMPLING_FREQ:\r\ncase V4L2_CID_MPEG_AUDIO_ENCODING:\r\ncase V4L2_CID_MPEG_AUDIO_L1_BITRATE:\r\ncase V4L2_CID_MPEG_AUDIO_L2_BITRATE:\r\ncase V4L2_CID_MPEG_AUDIO_L3_BITRATE:\r\ncase V4L2_CID_MPEG_AUDIO_AC3_BITRATE:\r\ncase V4L2_CID_MPEG_AUDIO_MODE:\r\ncase V4L2_CID_MPEG_AUDIO_MODE_EXTENSION:\r\ncase V4L2_CID_MPEG_AUDIO_EMPHASIS:\r\ncase V4L2_CID_MPEG_AUDIO_CRC:\r\ncase V4L2_CID_MPEG_AUDIO_DEC_PLAYBACK:\r\ncase V4L2_CID_MPEG_AUDIO_DEC_MULTILINGUAL_PLAYBACK:\r\ncase V4L2_CID_MPEG_VIDEO_ENCODING:\r\ncase V4L2_CID_MPEG_VIDEO_ASPECT:\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE_MODE:\r\ncase V4L2_CID_MPEG_STREAM_TYPE:\r\ncase V4L2_CID_MPEG_STREAM_VBI_FMT:\r\ncase V4L2_CID_EXPOSURE_AUTO:\r\ncase V4L2_CID_AUTO_FOCUS_RANGE:\r\ncase V4L2_CID_COLORFX:\r\ncase V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:\r\ncase V4L2_CID_TUNE_PREEMPHASIS:\r\ncase V4L2_CID_FLASH_LED_MODE:\r\ncase V4L2_CID_FLASH_STROBE_SOURCE:\r\ncase V4L2_CID_MPEG_VIDEO_HEADER_MODE:\r\ncase V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE:\r\ncase V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE:\r\ncase V4L2_CID_MPEG_VIDEO_H264_LEVEL:\r\ncase V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_MODE:\r\ncase V4L2_CID_MPEG_VIDEO_H264_PROFILE:\r\ncase V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC:\r\ncase V4L2_CID_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE:\r\ncase V4L2_CID_MPEG_VIDEO_H264_FMO_MAP_TYPE:\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_LEVEL:\r\ncase V4L2_CID_MPEG_VIDEO_MPEG4_PROFILE:\r\ncase V4L2_CID_JPEG_CHROMA_SUBSAMPLING:\r\ncase V4L2_CID_ISO_SENSITIVITY_AUTO:\r\ncase V4L2_CID_EXPOSURE_METERING:\r\ncase V4L2_CID_SCENE_MODE:\r\ncase V4L2_CID_DV_TX_MODE:\r\ncase V4L2_CID_DV_TX_RGB_RANGE:\r\ncase V4L2_CID_DV_RX_RGB_RANGE:\r\ncase V4L2_CID_TEST_PATTERN:\r\ncase V4L2_CID_TUNE_DEEMPHASIS:\r\ncase V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_SEL:\r\ncase V4L2_CID_DETECT_MD_MODE:\r\n*type = V4L2_CTRL_TYPE_MENU;\r\nbreak;\r\ncase V4L2_CID_LINK_FREQ:\r\n*type = V4L2_CTRL_TYPE_INTEGER_MENU;\r\nbreak;\r\ncase V4L2_CID_RDS_TX_PS_NAME:\r\ncase V4L2_CID_RDS_TX_RADIO_TEXT:\r\ncase V4L2_CID_RDS_RX_PS_NAME:\r\ncase V4L2_CID_RDS_RX_RADIO_TEXT:\r\n*type = V4L2_CTRL_TYPE_STRING;\r\nbreak;\r\ncase V4L2_CID_ISO_SENSITIVITY:\r\ncase V4L2_CID_AUTO_EXPOSURE_BIAS:\r\ncase V4L2_CID_MPEG_VIDEO_VPX_NUM_PARTITIONS:\r\ncase V4L2_CID_MPEG_VIDEO_VPX_NUM_REF_FRAMES:\r\n*type = V4L2_CTRL_TYPE_INTEGER_MENU;\r\nbreak;\r\ncase V4L2_CID_USER_CLASS:\r\ncase V4L2_CID_CAMERA_CLASS:\r\ncase V4L2_CID_MPEG_CLASS:\r\ncase V4L2_CID_FM_TX_CLASS:\r\ncase V4L2_CID_FLASH_CLASS:\r\ncase V4L2_CID_JPEG_CLASS:\r\ncase V4L2_CID_IMAGE_SOURCE_CLASS:\r\ncase V4L2_CID_IMAGE_PROC_CLASS:\r\ncase V4L2_CID_DV_CLASS:\r\ncase V4L2_CID_FM_RX_CLASS:\r\ncase V4L2_CID_RF_TUNER_CLASS:\r\ncase V4L2_CID_DETECT_CLASS:\r\n*type = V4L2_CTRL_TYPE_CTRL_CLASS;\r\n*flags |= V4L2_CTRL_FLAG_READ_ONLY | V4L2_CTRL_FLAG_WRITE_ONLY;\r\n*min = *max = *step = *def = 0;\r\nbreak;\r\ncase V4L2_CID_BG_COLOR:\r\n*type = V4L2_CTRL_TYPE_INTEGER;\r\n*step = 1;\r\n*min = 0;\r\n*max = 0xFFFFFF;\r\nbreak;\r\ncase V4L2_CID_FLASH_FAULT:\r\ncase V4L2_CID_JPEG_ACTIVE_MARKER:\r\ncase V4L2_CID_3A_LOCK:\r\ncase V4L2_CID_AUTO_FOCUS_STATUS:\r\ncase V4L2_CID_DV_TX_HOTPLUG:\r\ncase V4L2_CID_DV_TX_RXSENSE:\r\ncase V4L2_CID_DV_TX_EDID_PRESENT:\r\ncase V4L2_CID_DV_RX_POWER_PRESENT:\r\n*type = V4L2_CTRL_TYPE_BITMASK;\r\nbreak;\r\ncase V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:\r\ncase V4L2_CID_MIN_BUFFERS_FOR_OUTPUT:\r\n*type = V4L2_CTRL_TYPE_INTEGER;\r\n*flags |= V4L2_CTRL_FLAG_READ_ONLY;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_DEC_PTS:\r\n*type = V4L2_CTRL_TYPE_INTEGER64;\r\n*flags |= V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY;\r\n*min = *def = 0;\r\n*max = 0x1ffffffffLL;\r\n*step = 1;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_DEC_FRAME:\r\n*type = V4L2_CTRL_TYPE_INTEGER64;\r\n*flags |= V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY;\r\n*min = *def = 0;\r\n*max = 0x7fffffffffffffffLL;\r\n*step = 1;\r\nbreak;\r\ncase V4L2_CID_PIXEL_RATE:\r\n*type = V4L2_CTRL_TYPE_INTEGER64;\r\n*flags |= V4L2_CTRL_FLAG_READ_ONLY;\r\nbreak;\r\ncase V4L2_CID_DETECT_MD_REGION_GRID:\r\n*type = V4L2_CTRL_TYPE_U8;\r\nbreak;\r\ncase V4L2_CID_DETECT_MD_THRESHOLD_GRID:\r\n*type = V4L2_CTRL_TYPE_U16;\r\nbreak;\r\ncase V4L2_CID_RDS_TX_ALT_FREQS:\r\n*type = V4L2_CTRL_TYPE_U32;\r\nbreak;\r\ndefault:\r\n*type = V4L2_CTRL_TYPE_INTEGER;\r\nbreak;\r\n}\r\nswitch (id) {\r\ncase V4L2_CID_MPEG_AUDIO_ENCODING:\r\ncase V4L2_CID_MPEG_AUDIO_MODE:\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE_MODE:\r\ncase V4L2_CID_MPEG_VIDEO_B_FRAMES:\r\ncase V4L2_CID_MPEG_STREAM_TYPE:\r\n*flags |= V4L2_CTRL_FLAG_UPDATE;\r\nbreak;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\ncase V4L2_CID_AUDIO_BALANCE:\r\ncase V4L2_CID_AUDIO_BASS:\r\ncase V4L2_CID_AUDIO_TREBLE:\r\ncase V4L2_CID_BRIGHTNESS:\r\ncase V4L2_CID_CONTRAST:\r\ncase V4L2_CID_SATURATION:\r\ncase V4L2_CID_HUE:\r\ncase V4L2_CID_RED_BALANCE:\r\ncase V4L2_CID_BLUE_BALANCE:\r\ncase V4L2_CID_GAMMA:\r\ncase V4L2_CID_SHARPNESS:\r\ncase V4L2_CID_CHROMA_GAIN:\r\ncase V4L2_CID_RDS_TX_DEVIATION:\r\ncase V4L2_CID_AUDIO_LIMITER_RELEASE_TIME:\r\ncase V4L2_CID_AUDIO_LIMITER_DEVIATION:\r\ncase V4L2_CID_AUDIO_COMPRESSION_GAIN:\r\ncase V4L2_CID_AUDIO_COMPRESSION_THRESHOLD:\r\ncase V4L2_CID_AUDIO_COMPRESSION_ATTACK_TIME:\r\ncase V4L2_CID_AUDIO_COMPRESSION_RELEASE_TIME:\r\ncase V4L2_CID_PILOT_TONE_DEVIATION:\r\ncase V4L2_CID_PILOT_TONE_FREQUENCY:\r\ncase V4L2_CID_TUNE_POWER_LEVEL:\r\ncase V4L2_CID_TUNE_ANTENNA_CAPACITOR:\r\ncase V4L2_CID_RF_TUNER_LNA_GAIN:\r\ncase V4L2_CID_RF_TUNER_MIXER_GAIN:\r\ncase V4L2_CID_RF_TUNER_IF_GAIN:\r\ncase V4L2_CID_RF_TUNER_BANDWIDTH:\r\ncase V4L2_CID_DETECT_MD_GLOBAL_THRESHOLD:\r\n*flags |= V4L2_CTRL_FLAG_SLIDER;\r\nbreak;\r\ncase V4L2_CID_PAN_RELATIVE:\r\ncase V4L2_CID_TILT_RELATIVE:\r\ncase V4L2_CID_FOCUS_RELATIVE:\r\ncase V4L2_CID_IRIS_RELATIVE:\r\ncase V4L2_CID_ZOOM_RELATIVE:\r\n*flags |= V4L2_CTRL_FLAG_WRITE_ONLY |\r\nV4L2_CTRL_FLAG_EXECUTE_ON_WRITE;\r\nbreak;\r\ncase V4L2_CID_FLASH_STROBE_STATUS:\r\ncase V4L2_CID_AUTO_FOCUS_STATUS:\r\ncase V4L2_CID_FLASH_READY:\r\ncase V4L2_CID_DV_TX_HOTPLUG:\r\ncase V4L2_CID_DV_TX_RXSENSE:\r\ncase V4L2_CID_DV_TX_EDID_PRESENT:\r\ncase V4L2_CID_DV_RX_POWER_PRESENT:\r\ncase V4L2_CID_RDS_RX_PTY:\r\ncase V4L2_CID_RDS_RX_PS_NAME:\r\ncase V4L2_CID_RDS_RX_RADIO_TEXT:\r\ncase V4L2_CID_RDS_RX_TRAFFIC_ANNOUNCEMENT:\r\ncase V4L2_CID_RDS_RX_TRAFFIC_PROGRAM:\r\ncase V4L2_CID_RDS_RX_MUSIC_SPEECH:\r\n*flags |= V4L2_CTRL_FLAG_READ_ONLY;\r\nbreak;\r\ncase V4L2_CID_RF_TUNER_PLL_LOCK:\r\n*flags |= V4L2_CTRL_FLAG_VOLATILE;\r\nbreak;\r\n}\r\n}\r\nstatic void fill_event(struct v4l2_event *ev, struct v4l2_ctrl *ctrl, u32 changes)\r\n{\r\nmemset(ev->reserved, 0, sizeof(ev->reserved));\r\nev->type = V4L2_EVENT_CTRL;\r\nev->id = ctrl->id;\r\nev->u.ctrl.changes = changes;\r\nev->u.ctrl.type = ctrl->type;\r\nev->u.ctrl.flags = ctrl->flags;\r\nif (ctrl->is_ptr)\r\nev->u.ctrl.value64 = 0;\r\nelse\r\nev->u.ctrl.value64 = *ctrl->p_cur.p_s64;\r\nev->u.ctrl.minimum = ctrl->minimum;\r\nev->u.ctrl.maximum = ctrl->maximum;\r\nif (ctrl->type == V4L2_CTRL_TYPE_MENU\r\n|| ctrl->type == V4L2_CTRL_TYPE_INTEGER_MENU)\r\nev->u.ctrl.step = 1;\r\nelse\r\nev->u.ctrl.step = ctrl->step;\r\nev->u.ctrl.default_value = ctrl->default_value;\r\n}\r\nstatic void send_event(struct v4l2_fh *fh, struct v4l2_ctrl *ctrl, u32 changes)\r\n{\r\nstruct v4l2_event ev;\r\nstruct v4l2_subscribed_event *sev;\r\nif (list_empty(&ctrl->ev_subs))\r\nreturn;\r\nfill_event(&ev, ctrl, changes);\r\nlist_for_each_entry(sev, &ctrl->ev_subs, node)\r\nif (sev->fh != fh ||\r\n(sev->flags & V4L2_EVENT_SUB_FL_ALLOW_FEEDBACK))\r\nv4l2_event_queue_fh(sev->fh, &ev);\r\n}\r\nstatic bool std_equal(const struct v4l2_ctrl *ctrl, u32 idx,\r\nunion v4l2_ctrl_ptr ptr1,\r\nunion v4l2_ctrl_ptr ptr2)\r\n{\r\nswitch (ctrl->type) {\r\ncase V4L2_CTRL_TYPE_BUTTON:\r\nreturn false;\r\ncase V4L2_CTRL_TYPE_STRING:\r\nidx *= ctrl->elem_size;\r\nreturn !strcmp(ptr1.p_char + idx, ptr2.p_char + idx);\r\ncase V4L2_CTRL_TYPE_INTEGER64:\r\nreturn ptr1.p_s64[idx] == ptr2.p_s64[idx];\r\ncase V4L2_CTRL_TYPE_U8:\r\nreturn ptr1.p_u8[idx] == ptr2.p_u8[idx];\r\ncase V4L2_CTRL_TYPE_U16:\r\nreturn ptr1.p_u16[idx] == ptr2.p_u16[idx];\r\ncase V4L2_CTRL_TYPE_U32:\r\nreturn ptr1.p_u32[idx] == ptr2.p_u32[idx];\r\ndefault:\r\nif (ctrl->is_int)\r\nreturn ptr1.p_s32[idx] == ptr2.p_s32[idx];\r\nidx *= ctrl->elem_size;\r\nreturn !memcmp(ptr1.p + idx, ptr2.p + idx, ctrl->elem_size);\r\n}\r\n}\r\nstatic void std_init(const struct v4l2_ctrl *ctrl, u32 idx,\r\nunion v4l2_ctrl_ptr ptr)\r\n{\r\nswitch (ctrl->type) {\r\ncase V4L2_CTRL_TYPE_STRING:\r\nidx *= ctrl->elem_size;\r\nmemset(ptr.p_char + idx, ' ', ctrl->minimum);\r\nptr.p_char[idx + ctrl->minimum] = '\0';\r\nbreak;\r\ncase V4L2_CTRL_TYPE_INTEGER64:\r\nptr.p_s64[idx] = ctrl->default_value;\r\nbreak;\r\ncase V4L2_CTRL_TYPE_INTEGER:\r\ncase V4L2_CTRL_TYPE_INTEGER_MENU:\r\ncase V4L2_CTRL_TYPE_MENU:\r\ncase V4L2_CTRL_TYPE_BITMASK:\r\ncase V4L2_CTRL_TYPE_BOOLEAN:\r\nptr.p_s32[idx] = ctrl->default_value;\r\nbreak;\r\ncase V4L2_CTRL_TYPE_U8:\r\nptr.p_u8[idx] = ctrl->default_value;\r\nbreak;\r\ncase V4L2_CTRL_TYPE_U16:\r\nptr.p_u16[idx] = ctrl->default_value;\r\nbreak;\r\ncase V4L2_CTRL_TYPE_U32:\r\nptr.p_u32[idx] = ctrl->default_value;\r\nbreak;\r\ndefault:\r\nidx *= ctrl->elem_size;\r\nmemset(ptr.p + idx, 0, ctrl->elem_size);\r\nbreak;\r\n}\r\n}\r\nstatic void std_log(const struct v4l2_ctrl *ctrl)\r\n{\r\nunion v4l2_ctrl_ptr ptr = ctrl->p_cur;\r\nif (ctrl->is_array) {\r\nunsigned i;\r\nfor (i = 0; i < ctrl->nr_of_dims; i++)\r\npr_cont("[%u]", ctrl->dims[i]);\r\npr_cont(" ");\r\n}\r\nswitch (ctrl->type) {\r\ncase V4L2_CTRL_TYPE_INTEGER:\r\npr_cont("%d", *ptr.p_s32);\r\nbreak;\r\ncase V4L2_CTRL_TYPE_BOOLEAN:\r\npr_cont("%s", *ptr.p_s32 ? "true" : "false");\r\nbreak;\r\ncase V4L2_CTRL_TYPE_MENU:\r\npr_cont("%s", ctrl->qmenu[*ptr.p_s32]);\r\nbreak;\r\ncase V4L2_CTRL_TYPE_INTEGER_MENU:\r\npr_cont("%lld", ctrl->qmenu_int[*ptr.p_s32]);\r\nbreak;\r\ncase V4L2_CTRL_TYPE_BITMASK:\r\npr_cont("0x%08x", *ptr.p_s32);\r\nbreak;\r\ncase V4L2_CTRL_TYPE_INTEGER64:\r\npr_cont("%lld", *ptr.p_s64);\r\nbreak;\r\ncase V4L2_CTRL_TYPE_STRING:\r\npr_cont("%s", ptr.p_char);\r\nbreak;\r\ncase V4L2_CTRL_TYPE_U8:\r\npr_cont("%u", (unsigned)*ptr.p_u8);\r\nbreak;\r\ncase V4L2_CTRL_TYPE_U16:\r\npr_cont("%u", (unsigned)*ptr.p_u16);\r\nbreak;\r\ncase V4L2_CTRL_TYPE_U32:\r\npr_cont("%u", (unsigned)*ptr.p_u32);\r\nbreak;\r\ndefault:\r\npr_cont("unknown type %d", ctrl->type);\r\nbreak;\r\n}\r\n}\r\nstatic int std_validate(const struct v4l2_ctrl *ctrl, u32 idx,\r\nunion v4l2_ctrl_ptr ptr)\r\n{\r\nsize_t len;\r\nu64 offset;\r\ns64 val;\r\nswitch (ctrl->type) {\r\ncase V4L2_CTRL_TYPE_INTEGER:\r\nreturn ROUND_TO_RANGE(ptr.p_s32[idx], u32, ctrl);\r\ncase V4L2_CTRL_TYPE_INTEGER64:\r\nval = ptr.p_s64[idx];\r\nif (ctrl->maximum >= 0 && val >= ctrl->maximum - (s64)(ctrl->step / 2))\r\nval = ctrl->maximum;\r\nelse\r\nval += (s64)(ctrl->step / 2);\r\nval = clamp_t(s64, val, ctrl->minimum, ctrl->maximum);\r\noffset = val - ctrl->minimum;\r\ndo_div(offset, ctrl->step);\r\nptr.p_s64[idx] = ctrl->minimum + offset * ctrl->step;\r\nreturn 0;\r\ncase V4L2_CTRL_TYPE_U8:\r\nreturn ROUND_TO_RANGE(ptr.p_u8[idx], u8, ctrl);\r\ncase V4L2_CTRL_TYPE_U16:\r\nreturn ROUND_TO_RANGE(ptr.p_u16[idx], u16, ctrl);\r\ncase V4L2_CTRL_TYPE_U32:\r\nreturn ROUND_TO_RANGE(ptr.p_u32[idx], u32, ctrl);\r\ncase V4L2_CTRL_TYPE_BOOLEAN:\r\nptr.p_s32[idx] = !!ptr.p_s32[idx];\r\nreturn 0;\r\ncase V4L2_CTRL_TYPE_MENU:\r\ncase V4L2_CTRL_TYPE_INTEGER_MENU:\r\nif (ptr.p_s32[idx] < ctrl->minimum || ptr.p_s32[idx] > ctrl->maximum)\r\nreturn -ERANGE;\r\nif (ctrl->menu_skip_mask & (1 << ptr.p_s32[idx]))\r\nreturn -EINVAL;\r\nif (ctrl->type == V4L2_CTRL_TYPE_MENU &&\r\nctrl->qmenu[ptr.p_s32[idx]][0] == '\0')\r\nreturn -EINVAL;\r\nreturn 0;\r\ncase V4L2_CTRL_TYPE_BITMASK:\r\nptr.p_s32[idx] &= ctrl->maximum;\r\nreturn 0;\r\ncase V4L2_CTRL_TYPE_BUTTON:\r\ncase V4L2_CTRL_TYPE_CTRL_CLASS:\r\nptr.p_s32[idx] = 0;\r\nreturn 0;\r\ncase V4L2_CTRL_TYPE_STRING:\r\nidx *= ctrl->elem_size;\r\nlen = strlen(ptr.p_char + idx);\r\nif (len < ctrl->minimum)\r\nreturn -ERANGE;\r\nif ((len - (u32)ctrl->minimum) % (u32)ctrl->step)\r\nreturn -ERANGE;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int ptr_to_user(struct v4l2_ext_control *c,\r\nstruct v4l2_ctrl *ctrl,\r\nunion v4l2_ctrl_ptr ptr)\r\n{\r\nu32 len;\r\nif (ctrl->is_ptr && !ctrl->is_string)\r\nreturn copy_to_user(c->ptr, ptr.p, c->size) ?\r\n-EFAULT : 0;\r\nswitch (ctrl->type) {\r\ncase V4L2_CTRL_TYPE_STRING:\r\nlen = strlen(ptr.p_char);\r\nif (c->size < len + 1) {\r\nc->size = ctrl->elem_size;\r\nreturn -ENOSPC;\r\n}\r\nreturn copy_to_user(c->string, ptr.p_char, len + 1) ?\r\n-EFAULT : 0;\r\ncase V4L2_CTRL_TYPE_INTEGER64:\r\nc->value64 = *ptr.p_s64;\r\nbreak;\r\ndefault:\r\nc->value = *ptr.p_s32;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cur_to_user(struct v4l2_ext_control *c,\r\nstruct v4l2_ctrl *ctrl)\r\n{\r\nreturn ptr_to_user(c, ctrl, ctrl->p_cur);\r\n}\r\nstatic int new_to_user(struct v4l2_ext_control *c,\r\nstruct v4l2_ctrl *ctrl)\r\n{\r\nreturn ptr_to_user(c, ctrl, ctrl->p_new);\r\n}\r\nstatic int user_to_ptr(struct v4l2_ext_control *c,\r\nstruct v4l2_ctrl *ctrl,\r\nunion v4l2_ctrl_ptr ptr)\r\n{\r\nint ret;\r\nu32 size;\r\nctrl->is_new = 1;\r\nif (ctrl->is_ptr && !ctrl->is_string) {\r\nunsigned idx;\r\nret = copy_from_user(ptr.p, c->ptr, c->size) ? -EFAULT : 0;\r\nif (ret || !ctrl->is_array)\r\nreturn ret;\r\nfor (idx = c->size / ctrl->elem_size; idx < ctrl->elems; idx++)\r\nctrl->type_ops->init(ctrl, idx, ptr);\r\nreturn 0;\r\n}\r\nswitch (ctrl->type) {\r\ncase V4L2_CTRL_TYPE_INTEGER64:\r\n*ptr.p_s64 = c->value64;\r\nbreak;\r\ncase V4L2_CTRL_TYPE_STRING:\r\nsize = c->size;\r\nif (size == 0)\r\nreturn -ERANGE;\r\nif (size > ctrl->maximum + 1)\r\nsize = ctrl->maximum + 1;\r\nret = copy_from_user(ptr.p_char, c->string, size) ? -EFAULT : 0;\r\nif (!ret) {\r\nchar last = ptr.p_char[size - 1];\r\nptr.p_char[size - 1] = 0;\r\nif (strlen(ptr.p_char) == ctrl->maximum && last)\r\nreturn -ERANGE;\r\n}\r\nreturn ret;\r\ndefault:\r\n*ptr.p_s32 = c->value;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int user_to_new(struct v4l2_ext_control *c,\r\nstruct v4l2_ctrl *ctrl)\r\n{\r\nreturn user_to_ptr(c, ctrl, ctrl->p_new);\r\n}\r\nstatic void ptr_to_ptr(struct v4l2_ctrl *ctrl,\r\nunion v4l2_ctrl_ptr from, union v4l2_ctrl_ptr to)\r\n{\r\nif (ctrl == NULL)\r\nreturn;\r\nmemcpy(to.p, from.p, ctrl->elems * ctrl->elem_size);\r\n}\r\nstatic void new_to_cur(struct v4l2_fh *fh, struct v4l2_ctrl *ctrl, u32 ch_flags)\r\n{\r\nbool changed;\r\nif (ctrl == NULL)\r\nreturn;\r\nchanged = ctrl->has_changed;\r\nif (changed)\r\nptr_to_ptr(ctrl, ctrl->p_new, ctrl->p_cur);\r\nif (ch_flags & V4L2_EVENT_CTRL_CH_FLAGS) {\r\nctrl->flags &=\r\n~(V4L2_CTRL_FLAG_INACTIVE | V4L2_CTRL_FLAG_VOLATILE);\r\nif (!is_cur_manual(ctrl->cluster[0])) {\r\nctrl->flags |= V4L2_CTRL_FLAG_INACTIVE;\r\nif (ctrl->cluster[0]->has_volatiles)\r\nctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;\r\n}\r\nfh = NULL;\r\n}\r\nif (changed || ch_flags) {\r\nif (!ctrl->is_new)\r\nfh = NULL;\r\nsend_event(fh, ctrl,\r\n(changed ? V4L2_EVENT_CTRL_CH_VALUE : 0) | ch_flags);\r\nif (ctrl->call_notify && changed && ctrl->handler->notify)\r\nctrl->handler->notify(ctrl, ctrl->handler->notify_priv);\r\n}\r\n}\r\nstatic void cur_to_new(struct v4l2_ctrl *ctrl)\r\n{\r\nif (ctrl == NULL)\r\nreturn;\r\nptr_to_ptr(ctrl, ctrl->p_cur, ctrl->p_new);\r\n}\r\nstatic int cluster_changed(struct v4l2_ctrl *master)\r\n{\r\nbool changed = false;\r\nunsigned idx;\r\nint i;\r\nfor (i = 0; i < master->ncontrols; i++) {\r\nstruct v4l2_ctrl *ctrl = master->cluster[i];\r\nbool ctrl_changed = false;\r\nif (ctrl == NULL)\r\ncontinue;\r\nif (ctrl->flags & V4L2_CTRL_FLAG_EXECUTE_ON_WRITE)\r\nchanged = ctrl_changed = true;\r\nif (ctrl->flags & V4L2_CTRL_FLAG_VOLATILE) {\r\nctrl->has_changed = false;\r\ncontinue;\r\n}\r\nfor (idx = 0; !ctrl_changed && idx < ctrl->elems; idx++)\r\nctrl_changed = !ctrl->type_ops->equal(ctrl, idx,\r\nctrl->p_cur, ctrl->p_new);\r\nctrl->has_changed = ctrl_changed;\r\nchanged |= ctrl->has_changed;\r\n}\r\nreturn changed;\r\n}\r\nstatic int check_range(enum v4l2_ctrl_type type,\r\ns64 min, s64 max, u64 step, s64 def)\r\n{\r\nswitch (type) {\r\ncase V4L2_CTRL_TYPE_BOOLEAN:\r\nif (step != 1 || max > 1 || min < 0)\r\nreturn -ERANGE;\r\ncase V4L2_CTRL_TYPE_U8:\r\ncase V4L2_CTRL_TYPE_U16:\r\ncase V4L2_CTRL_TYPE_U32:\r\ncase V4L2_CTRL_TYPE_INTEGER:\r\ncase V4L2_CTRL_TYPE_INTEGER64:\r\nif (step == 0 || min > max || def < min || def > max)\r\nreturn -ERANGE;\r\nreturn 0;\r\ncase V4L2_CTRL_TYPE_BITMASK:\r\nif (step || min || !max || (def & ~max))\r\nreturn -ERANGE;\r\nreturn 0;\r\ncase V4L2_CTRL_TYPE_MENU:\r\ncase V4L2_CTRL_TYPE_INTEGER_MENU:\r\nif (min > max || def < min || def > max)\r\nreturn -ERANGE;\r\nif (step && ((1 << def) & step))\r\nreturn -EINVAL;\r\nreturn 0;\r\ncase V4L2_CTRL_TYPE_STRING:\r\nif (min > max || min < 0 || step < 1 || def)\r\nreturn -ERANGE;\r\nreturn 0;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int validate_new(const struct v4l2_ctrl *ctrl, union v4l2_ctrl_ptr p_new)\r\n{\r\nunsigned idx;\r\nint err = 0;\r\nif (!ctrl->is_ptr) {\r\nswitch (ctrl->type) {\r\ncase V4L2_CTRL_TYPE_INTEGER:\r\ncase V4L2_CTRL_TYPE_INTEGER_MENU:\r\ncase V4L2_CTRL_TYPE_MENU:\r\ncase V4L2_CTRL_TYPE_BITMASK:\r\ncase V4L2_CTRL_TYPE_BOOLEAN:\r\ncase V4L2_CTRL_TYPE_BUTTON:\r\ncase V4L2_CTRL_TYPE_CTRL_CLASS:\r\ncase V4L2_CTRL_TYPE_INTEGER64:\r\nreturn ctrl->type_ops->validate(ctrl, 0, p_new);\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nfor (idx = 0; !err && idx < ctrl->elems; idx++)\r\nerr = ctrl->type_ops->validate(ctrl, idx, p_new);\r\nreturn err;\r\n}\r\nstatic inline u32 node2id(struct list_head *node)\r\n{\r\nreturn list_entry(node, struct v4l2_ctrl_ref, node)->ctrl->id;\r\n}\r\nstatic inline int handler_set_err(struct v4l2_ctrl_handler *hdl, int err)\r\n{\r\nif (hdl->error == 0)\r\nhdl->error = err;\r\nreturn err;\r\n}\r\nint v4l2_ctrl_handler_init_class(struct v4l2_ctrl_handler *hdl,\r\nunsigned nr_of_controls_hint,\r\nstruct lock_class_key *key, const char *name)\r\n{\r\nhdl->lock = &hdl->_lock;\r\nmutex_init(hdl->lock);\r\nlockdep_set_class_and_name(hdl->lock, key, name);\r\nINIT_LIST_HEAD(&hdl->ctrls);\r\nINIT_LIST_HEAD(&hdl->ctrl_refs);\r\nhdl->nr_of_buckets = 1 + nr_of_controls_hint / 8;\r\nhdl->buckets = kcalloc(hdl->nr_of_buckets, sizeof(hdl->buckets[0]),\r\nGFP_KERNEL);\r\nhdl->error = hdl->buckets ? 0 : -ENOMEM;\r\nreturn hdl->error;\r\n}\r\nvoid v4l2_ctrl_handler_free(struct v4l2_ctrl_handler *hdl)\r\n{\r\nstruct v4l2_ctrl_ref *ref, *next_ref;\r\nstruct v4l2_ctrl *ctrl, *next_ctrl;\r\nstruct v4l2_subscribed_event *sev, *next_sev;\r\nif (hdl == NULL || hdl->buckets == NULL)\r\nreturn;\r\nmutex_lock(hdl->lock);\r\nlist_for_each_entry_safe(ref, next_ref, &hdl->ctrl_refs, node) {\r\nlist_del(&ref->node);\r\nkfree(ref);\r\n}\r\nlist_for_each_entry_safe(ctrl, next_ctrl, &hdl->ctrls, node) {\r\nlist_del(&ctrl->node);\r\nlist_for_each_entry_safe(sev, next_sev, &ctrl->ev_subs, node)\r\nlist_del(&sev->node);\r\nkfree(ctrl);\r\n}\r\nkfree(hdl->buckets);\r\nhdl->buckets = NULL;\r\nhdl->cached = NULL;\r\nhdl->error = 0;\r\nmutex_unlock(hdl->lock);\r\n}\r\nstatic struct v4l2_ctrl_ref *find_private_ref(\r\nstruct v4l2_ctrl_handler *hdl, u32 id)\r\n{\r\nstruct v4l2_ctrl_ref *ref;\r\nid -= V4L2_CID_PRIVATE_BASE;\r\nlist_for_each_entry(ref, &hdl->ctrl_refs, node) {\r\nif (V4L2_CTRL_ID2CLASS(ref->ctrl->id) == V4L2_CTRL_CLASS_USER &&\r\nV4L2_CTRL_DRIVER_PRIV(ref->ctrl->id)) {\r\nif (!ref->ctrl->is_int)\r\ncontinue;\r\nif (id == 0)\r\nreturn ref;\r\nid--;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct v4l2_ctrl_ref *find_ref(struct v4l2_ctrl_handler *hdl, u32 id)\r\n{\r\nstruct v4l2_ctrl_ref *ref;\r\nint bucket;\r\nid &= V4L2_CTRL_ID_MASK;\r\nif (id >= V4L2_CID_PRIVATE_BASE)\r\nreturn find_private_ref(hdl, id);\r\nbucket = id % hdl->nr_of_buckets;\r\nif (hdl->cached && hdl->cached->ctrl->id == id)\r\nreturn hdl->cached;\r\nref = hdl->buckets ? hdl->buckets[bucket] : NULL;\r\nwhile (ref && ref->ctrl->id != id)\r\nref = ref->next;\r\nif (ref)\r\nhdl->cached = ref;\r\nreturn ref;\r\n}\r\nstatic struct v4l2_ctrl_ref *find_ref_lock(\r\nstruct v4l2_ctrl_handler *hdl, u32 id)\r\n{\r\nstruct v4l2_ctrl_ref *ref = NULL;\r\nif (hdl) {\r\nmutex_lock(hdl->lock);\r\nref = find_ref(hdl, id);\r\nmutex_unlock(hdl->lock);\r\n}\r\nreturn ref;\r\n}\r\nstruct v4l2_ctrl *v4l2_ctrl_find(struct v4l2_ctrl_handler *hdl, u32 id)\r\n{\r\nstruct v4l2_ctrl_ref *ref = find_ref_lock(hdl, id);\r\nreturn ref ? ref->ctrl : NULL;\r\n}\r\nstatic int handler_new_ref(struct v4l2_ctrl_handler *hdl,\r\nstruct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_ctrl_ref *ref;\r\nstruct v4l2_ctrl_ref *new_ref;\r\nu32 id = ctrl->id;\r\nu32 class_ctrl = V4L2_CTRL_ID2CLASS(id) | 1;\r\nint bucket = id % hdl->nr_of_buckets;\r\nif (ctrl->type < V4L2_CTRL_COMPOUND_TYPES &&\r\nid != class_ctrl && find_ref_lock(hdl, class_ctrl) == NULL)\r\nif (!v4l2_ctrl_new_std(hdl, NULL, class_ctrl, 0, 0, 0, 0))\r\nreturn hdl->error;\r\nif (hdl->error)\r\nreturn hdl->error;\r\nnew_ref = kzalloc(sizeof(*new_ref), GFP_KERNEL);\r\nif (!new_ref)\r\nreturn handler_set_err(hdl, -ENOMEM);\r\nnew_ref->ctrl = ctrl;\r\nif (ctrl->handler == hdl) {\r\nctrl->cluster = &new_ref->ctrl;\r\nctrl->ncontrols = 1;\r\n}\r\nINIT_LIST_HEAD(&new_ref->node);\r\nmutex_lock(hdl->lock);\r\nif (list_empty(&hdl->ctrl_refs) || id > node2id(hdl->ctrl_refs.prev)) {\r\nlist_add_tail(&new_ref->node, &hdl->ctrl_refs);\r\ngoto insert_in_hash;\r\n}\r\nlist_for_each_entry(ref, &hdl->ctrl_refs, node) {\r\nif (ref->ctrl->id < id)\r\ncontinue;\r\nif (ref->ctrl->id == id) {\r\nkfree(new_ref);\r\ngoto unlock;\r\n}\r\nlist_add(&new_ref->node, ref->node.prev);\r\nbreak;\r\n}\r\ninsert_in_hash:\r\nnew_ref->next = hdl->buckets[bucket];\r\nhdl->buckets[bucket] = new_ref;\r\nunlock:\r\nmutex_unlock(hdl->lock);\r\nreturn 0;\r\n}\r\nstatic struct v4l2_ctrl *v4l2_ctrl_new(struct v4l2_ctrl_handler *hdl,\r\nconst struct v4l2_ctrl_ops *ops,\r\nconst struct v4l2_ctrl_type_ops *type_ops,\r\nu32 id, const char *name, enum v4l2_ctrl_type type,\r\ns64 min, s64 max, u64 step, s64 def,\r\nconst u32 dims[V4L2_CTRL_MAX_DIMS], u32 elem_size,\r\nu32 flags, const char * const *qmenu,\r\nconst s64 *qmenu_int, void *priv)\r\n{\r\nstruct v4l2_ctrl *ctrl;\r\nunsigned sz_extra;\r\nunsigned nr_of_dims = 0;\r\nunsigned elems = 1;\r\nbool is_array;\r\nunsigned tot_ctrl_size;\r\nunsigned idx;\r\nvoid *data;\r\nint err;\r\nif (hdl->error)\r\nreturn NULL;\r\nwhile (dims && dims[nr_of_dims]) {\r\nelems *= dims[nr_of_dims];\r\nnr_of_dims++;\r\nif (nr_of_dims == V4L2_CTRL_MAX_DIMS)\r\nbreak;\r\n}\r\nis_array = nr_of_dims > 0;\r\nswitch (type) {\r\ncase V4L2_CTRL_TYPE_INTEGER64:\r\nelem_size = sizeof(s64);\r\nbreak;\r\ncase V4L2_CTRL_TYPE_STRING:\r\nelem_size = max + 1;\r\nbreak;\r\ncase V4L2_CTRL_TYPE_U8:\r\nelem_size = sizeof(u8);\r\nbreak;\r\ncase V4L2_CTRL_TYPE_U16:\r\nelem_size = sizeof(u16);\r\nbreak;\r\ncase V4L2_CTRL_TYPE_U32:\r\nelem_size = sizeof(u32);\r\nbreak;\r\ndefault:\r\nif (type < V4L2_CTRL_COMPOUND_TYPES)\r\nelem_size = sizeof(s32);\r\nbreak;\r\n}\r\ntot_ctrl_size = elem_size * elems;\r\nif (id == 0 || name == NULL || !elem_size ||\r\nid >= V4L2_CID_PRIVATE_BASE ||\r\n(type == V4L2_CTRL_TYPE_MENU && qmenu == NULL) ||\r\n(type == V4L2_CTRL_TYPE_INTEGER_MENU && qmenu_int == NULL)) {\r\nhandler_set_err(hdl, -ERANGE);\r\nreturn NULL;\r\n}\r\nerr = check_range(type, min, max, step, def);\r\nif (err) {\r\nhandler_set_err(hdl, err);\r\nreturn NULL;\r\n}\r\nif (type == V4L2_CTRL_TYPE_BITMASK && ((def & ~max) || min || step)) {\r\nhandler_set_err(hdl, -ERANGE);\r\nreturn NULL;\r\n}\r\nif (is_array &&\r\n(type == V4L2_CTRL_TYPE_BUTTON ||\r\ntype == V4L2_CTRL_TYPE_CTRL_CLASS)) {\r\nhandler_set_err(hdl, -EINVAL);\r\nreturn NULL;\r\n}\r\nsz_extra = 0;\r\nif (type == V4L2_CTRL_TYPE_BUTTON)\r\nflags |= V4L2_CTRL_FLAG_WRITE_ONLY |\r\nV4L2_CTRL_FLAG_EXECUTE_ON_WRITE;\r\nelse if (type == V4L2_CTRL_TYPE_CTRL_CLASS)\r\nflags |= V4L2_CTRL_FLAG_READ_ONLY;\r\nelse if (type == V4L2_CTRL_TYPE_INTEGER64 ||\r\ntype == V4L2_CTRL_TYPE_STRING ||\r\ntype >= V4L2_CTRL_COMPOUND_TYPES ||\r\nis_array)\r\nsz_extra += 2 * tot_ctrl_size;\r\nctrl = kzalloc(sizeof(*ctrl) + sz_extra, GFP_KERNEL);\r\nif (ctrl == NULL) {\r\nhandler_set_err(hdl, -ENOMEM);\r\nreturn NULL;\r\n}\r\nINIT_LIST_HEAD(&ctrl->node);\r\nINIT_LIST_HEAD(&ctrl->ev_subs);\r\nctrl->handler = hdl;\r\nctrl->ops = ops;\r\nctrl->type_ops = type_ops ? type_ops : &std_type_ops;\r\nctrl->id = id;\r\nctrl->name = name;\r\nctrl->type = type;\r\nctrl->flags = flags;\r\nctrl->minimum = min;\r\nctrl->maximum = max;\r\nctrl->step = step;\r\nctrl->default_value = def;\r\nctrl->is_string = !is_array && type == V4L2_CTRL_TYPE_STRING;\r\nctrl->is_ptr = is_array || type >= V4L2_CTRL_COMPOUND_TYPES || ctrl->is_string;\r\nctrl->is_int = !ctrl->is_ptr && type != V4L2_CTRL_TYPE_INTEGER64;\r\nctrl->is_array = is_array;\r\nctrl->elems = elems;\r\nctrl->nr_of_dims = nr_of_dims;\r\nif (nr_of_dims)\r\nmemcpy(ctrl->dims, dims, nr_of_dims * sizeof(dims[0]));\r\nctrl->elem_size = elem_size;\r\nif (type == V4L2_CTRL_TYPE_MENU)\r\nctrl->qmenu = qmenu;\r\nelse if (type == V4L2_CTRL_TYPE_INTEGER_MENU)\r\nctrl->qmenu_int = qmenu_int;\r\nctrl->priv = priv;\r\nctrl->cur.val = ctrl->val = def;\r\ndata = &ctrl[1];\r\nif (!ctrl->is_int) {\r\nctrl->p_new.p = data;\r\nctrl->p_cur.p = data + tot_ctrl_size;\r\n} else {\r\nctrl->p_new.p = &ctrl->val;\r\nctrl->p_cur.p = &ctrl->cur.val;\r\n}\r\nfor (idx = 0; idx < elems; idx++) {\r\nctrl->type_ops->init(ctrl, idx, ctrl->p_cur);\r\nctrl->type_ops->init(ctrl, idx, ctrl->p_new);\r\n}\r\nif (handler_new_ref(hdl, ctrl)) {\r\nkfree(ctrl);\r\nreturn NULL;\r\n}\r\nmutex_lock(hdl->lock);\r\nlist_add_tail(&ctrl->node, &hdl->ctrls);\r\nmutex_unlock(hdl->lock);\r\nreturn ctrl;\r\n}\r\nstruct v4l2_ctrl *v4l2_ctrl_new_custom(struct v4l2_ctrl_handler *hdl,\r\nconst struct v4l2_ctrl_config *cfg, void *priv)\r\n{\r\nbool is_menu;\r\nstruct v4l2_ctrl *ctrl;\r\nconst char *name = cfg->name;\r\nconst char * const *qmenu = cfg->qmenu;\r\nconst s64 *qmenu_int = cfg->qmenu_int;\r\nenum v4l2_ctrl_type type = cfg->type;\r\nu32 flags = cfg->flags;\r\ns64 min = cfg->min;\r\ns64 max = cfg->max;\r\nu64 step = cfg->step;\r\ns64 def = cfg->def;\r\nif (name == NULL)\r\nv4l2_ctrl_fill(cfg->id, &name, &type, &min, &max, &step,\r\n&def, &flags);\r\nis_menu = (cfg->type == V4L2_CTRL_TYPE_MENU ||\r\ncfg->type == V4L2_CTRL_TYPE_INTEGER_MENU);\r\nif (is_menu)\r\nWARN_ON(step);\r\nelse\r\nWARN_ON(cfg->menu_skip_mask);\r\nif (cfg->type == V4L2_CTRL_TYPE_MENU && qmenu == NULL)\r\nqmenu = v4l2_ctrl_get_menu(cfg->id);\r\nelse if (cfg->type == V4L2_CTRL_TYPE_INTEGER_MENU &&\r\nqmenu_int == NULL) {\r\nhandler_set_err(hdl, -EINVAL);\r\nreturn NULL;\r\n}\r\nctrl = v4l2_ctrl_new(hdl, cfg->ops, cfg->type_ops, cfg->id, name,\r\ntype, min, max,\r\nis_menu ? cfg->menu_skip_mask : step, def,\r\ncfg->dims, cfg->elem_size,\r\nflags, qmenu, qmenu_int, priv);\r\nif (ctrl)\r\nctrl->is_private = cfg->is_private;\r\nreturn ctrl;\r\n}\r\nstruct v4l2_ctrl *v4l2_ctrl_new_std(struct v4l2_ctrl_handler *hdl,\r\nconst struct v4l2_ctrl_ops *ops,\r\nu32 id, s64 min, s64 max, u64 step, s64 def)\r\n{\r\nconst char *name;\r\nenum v4l2_ctrl_type type;\r\nu32 flags;\r\nv4l2_ctrl_fill(id, &name, &type, &min, &max, &step, &def, &flags);\r\nif (type == V4L2_CTRL_TYPE_MENU ||\r\ntype == V4L2_CTRL_TYPE_INTEGER_MENU ||\r\ntype >= V4L2_CTRL_COMPOUND_TYPES) {\r\nhandler_set_err(hdl, -EINVAL);\r\nreturn NULL;\r\n}\r\nreturn v4l2_ctrl_new(hdl, ops, NULL, id, name, type,\r\nmin, max, step, def, NULL, 0,\r\nflags, NULL, NULL, NULL);\r\n}\r\nstruct v4l2_ctrl *v4l2_ctrl_new_std_menu(struct v4l2_ctrl_handler *hdl,\r\nconst struct v4l2_ctrl_ops *ops,\r\nu32 id, u8 _max, u64 mask, u8 _def)\r\n{\r\nconst char * const *qmenu = NULL;\r\nconst s64 *qmenu_int = NULL;\r\nunsigned int qmenu_int_len = 0;\r\nconst char *name;\r\nenum v4l2_ctrl_type type;\r\ns64 min;\r\ns64 max = _max;\r\ns64 def = _def;\r\nu64 step;\r\nu32 flags;\r\nv4l2_ctrl_fill(id, &name, &type, &min, &max, &step, &def, &flags);\r\nif (type == V4L2_CTRL_TYPE_MENU)\r\nqmenu = v4l2_ctrl_get_menu(id);\r\nelse if (type == V4L2_CTRL_TYPE_INTEGER_MENU)\r\nqmenu_int = v4l2_ctrl_get_int_menu(id, &qmenu_int_len);\r\nif ((!qmenu && !qmenu_int) || (qmenu_int && max > qmenu_int_len)) {\r\nhandler_set_err(hdl, -EINVAL);\r\nreturn NULL;\r\n}\r\nreturn v4l2_ctrl_new(hdl, ops, NULL, id, name, type,\r\n0, max, mask, def, NULL, 0,\r\nflags, qmenu, qmenu_int, NULL);\r\n}\r\nstruct v4l2_ctrl *v4l2_ctrl_new_std_menu_items(struct v4l2_ctrl_handler *hdl,\r\nconst struct v4l2_ctrl_ops *ops, u32 id, u8 _max,\r\nu64 mask, u8 _def, const char * const *qmenu)\r\n{\r\nenum v4l2_ctrl_type type;\r\nconst char *name;\r\nu32 flags;\r\nu64 step;\r\ns64 min;\r\ns64 max = _max;\r\ns64 def = _def;\r\nif (v4l2_ctrl_get_menu(id)) {\r\nhandler_set_err(hdl, -EINVAL);\r\nreturn NULL;\r\n}\r\nv4l2_ctrl_fill(id, &name, &type, &min, &max, &step, &def, &flags);\r\nif (type != V4L2_CTRL_TYPE_MENU || qmenu == NULL) {\r\nhandler_set_err(hdl, -EINVAL);\r\nreturn NULL;\r\n}\r\nreturn v4l2_ctrl_new(hdl, ops, NULL, id, name, type,\r\n0, max, mask, def, NULL, 0,\r\nflags, qmenu, NULL, NULL);\r\n}\r\nstruct v4l2_ctrl *v4l2_ctrl_new_int_menu(struct v4l2_ctrl_handler *hdl,\r\nconst struct v4l2_ctrl_ops *ops,\r\nu32 id, u8 _max, u8 _def, const s64 *qmenu_int)\r\n{\r\nconst char *name;\r\nenum v4l2_ctrl_type type;\r\ns64 min;\r\nu64 step;\r\ns64 max = _max;\r\ns64 def = _def;\r\nu32 flags;\r\nv4l2_ctrl_fill(id, &name, &type, &min, &max, &step, &def, &flags);\r\nif (type != V4L2_CTRL_TYPE_INTEGER_MENU) {\r\nhandler_set_err(hdl, -EINVAL);\r\nreturn NULL;\r\n}\r\nreturn v4l2_ctrl_new(hdl, ops, NULL, id, name, type,\r\n0, max, 0, def, NULL, 0,\r\nflags, NULL, qmenu_int, NULL);\r\n}\r\nstruct v4l2_ctrl *v4l2_ctrl_add_ctrl(struct v4l2_ctrl_handler *hdl,\r\nstruct v4l2_ctrl *ctrl)\r\n{\r\nif (hdl == NULL || hdl->error)\r\nreturn NULL;\r\nif (ctrl == NULL) {\r\nhandler_set_err(hdl, -EINVAL);\r\nreturn NULL;\r\n}\r\nif (ctrl->handler == hdl)\r\nreturn ctrl;\r\nreturn handler_new_ref(hdl, ctrl) ? NULL : ctrl;\r\n}\r\nint v4l2_ctrl_add_handler(struct v4l2_ctrl_handler *hdl,\r\nstruct v4l2_ctrl_handler *add,\r\nbool (*filter)(const struct v4l2_ctrl *ctrl))\r\n{\r\nstruct v4l2_ctrl_ref *ref;\r\nint ret = 0;\r\nif (!hdl || !add || hdl == add)\r\nreturn 0;\r\nif (hdl->error)\r\nreturn hdl->error;\r\nmutex_lock(add->lock);\r\nlist_for_each_entry(ref, &add->ctrl_refs, node) {\r\nstruct v4l2_ctrl *ctrl = ref->ctrl;\r\nif (ctrl->is_private)\r\ncontinue;\r\nif (ctrl->type == V4L2_CTRL_TYPE_CTRL_CLASS)\r\ncontinue;\r\nif (filter && !filter(ctrl))\r\ncontinue;\r\nret = handler_new_ref(hdl, ctrl);\r\nif (ret)\r\nbreak;\r\n}\r\nmutex_unlock(add->lock);\r\nreturn ret;\r\n}\r\nbool v4l2_ctrl_radio_filter(const struct v4l2_ctrl *ctrl)\r\n{\r\nif (V4L2_CTRL_ID2CLASS(ctrl->id) == V4L2_CTRL_CLASS_FM_TX)\r\nreturn true;\r\nif (V4L2_CTRL_ID2CLASS(ctrl->id) == V4L2_CTRL_CLASS_FM_RX)\r\nreturn true;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\ncase V4L2_CID_AUDIO_VOLUME:\r\ncase V4L2_CID_AUDIO_BALANCE:\r\ncase V4L2_CID_AUDIO_BASS:\r\ncase V4L2_CID_AUDIO_TREBLE:\r\ncase V4L2_CID_AUDIO_LOUDNESS:\r\nreturn true;\r\ndefault:\r\nbreak;\r\n}\r\nreturn false;\r\n}\r\nvoid v4l2_ctrl_cluster(unsigned ncontrols, struct v4l2_ctrl **controls)\r\n{\r\nbool has_volatiles = false;\r\nint i;\r\nif (WARN_ON(ncontrols == 0 || controls[0] == NULL))\r\nreturn;\r\nfor (i = 0; i < ncontrols; i++) {\r\nif (controls[i]) {\r\ncontrols[i]->cluster = controls;\r\ncontrols[i]->ncontrols = ncontrols;\r\nif (controls[i]->flags & V4L2_CTRL_FLAG_VOLATILE)\r\nhas_volatiles = true;\r\n}\r\n}\r\ncontrols[0]->has_volatiles = has_volatiles;\r\n}\r\nvoid v4l2_ctrl_auto_cluster(unsigned ncontrols, struct v4l2_ctrl **controls,\r\nu8 manual_val, bool set_volatile)\r\n{\r\nstruct v4l2_ctrl *master = controls[0];\r\nu32 flag = 0;\r\nint i;\r\nv4l2_ctrl_cluster(ncontrols, controls);\r\nWARN_ON(ncontrols <= 1);\r\nWARN_ON(manual_val < master->minimum || manual_val > master->maximum);\r\nWARN_ON(set_volatile && !has_op(master, g_volatile_ctrl));\r\nmaster->is_auto = true;\r\nmaster->has_volatiles = set_volatile;\r\nmaster->manual_mode_value = manual_val;\r\nmaster->flags |= V4L2_CTRL_FLAG_UPDATE;\r\nif (!is_cur_manual(master))\r\nflag = V4L2_CTRL_FLAG_INACTIVE |\r\n(set_volatile ? V4L2_CTRL_FLAG_VOLATILE : 0);\r\nfor (i = 1; i < ncontrols; i++)\r\nif (controls[i])\r\ncontrols[i]->flags |= flag;\r\n}\r\nvoid v4l2_ctrl_activate(struct v4l2_ctrl *ctrl, bool active)\r\n{\r\nbool inactive = !active;\r\nbool old;\r\nif (ctrl == NULL)\r\nreturn;\r\nif (inactive)\r\nold = test_and_set_bit(4, &ctrl->flags);\r\nelse\r\nold = test_and_clear_bit(4, &ctrl->flags);\r\nif (old != inactive)\r\nsend_event(NULL, ctrl, V4L2_EVENT_CTRL_CH_FLAGS);\r\n}\r\nvoid v4l2_ctrl_grab(struct v4l2_ctrl *ctrl, bool grabbed)\r\n{\r\nbool old;\r\nif (ctrl == NULL)\r\nreturn;\r\nv4l2_ctrl_lock(ctrl);\r\nif (grabbed)\r\nold = test_and_set_bit(1, &ctrl->flags);\r\nelse\r\nold = test_and_clear_bit(1, &ctrl->flags);\r\nif (old != grabbed)\r\nsend_event(NULL, ctrl, V4L2_EVENT_CTRL_CH_FLAGS);\r\nv4l2_ctrl_unlock(ctrl);\r\n}\r\nstatic void log_ctrl(const struct v4l2_ctrl *ctrl,\r\nconst char *prefix, const char *colon)\r\n{\r\nif (ctrl->flags & (V4L2_CTRL_FLAG_DISABLED | V4L2_CTRL_FLAG_WRITE_ONLY))\r\nreturn;\r\nif (ctrl->type == V4L2_CTRL_TYPE_CTRL_CLASS)\r\nreturn;\r\npr_info("%s%s%s: ", prefix, colon, ctrl->name);\r\nctrl->type_ops->log(ctrl);\r\nif (ctrl->flags & (V4L2_CTRL_FLAG_INACTIVE |\r\nV4L2_CTRL_FLAG_GRABBED |\r\nV4L2_CTRL_FLAG_VOLATILE)) {\r\nif (ctrl->flags & V4L2_CTRL_FLAG_INACTIVE)\r\npr_cont(" inactive");\r\nif (ctrl->flags & V4L2_CTRL_FLAG_GRABBED)\r\npr_cont(" grabbed");\r\nif (ctrl->flags & V4L2_CTRL_FLAG_VOLATILE)\r\npr_cont(" volatile");\r\n}\r\npr_cont("\n");\r\n}\r\nvoid v4l2_ctrl_handler_log_status(struct v4l2_ctrl_handler *hdl,\r\nconst char *prefix)\r\n{\r\nstruct v4l2_ctrl *ctrl;\r\nconst char *colon = "";\r\nint len;\r\nif (hdl == NULL)\r\nreturn;\r\nif (prefix == NULL)\r\nprefix = "";\r\nlen = strlen(prefix);\r\nif (len && prefix[len - 1] != ' ')\r\ncolon = ": ";\r\nmutex_lock(hdl->lock);\r\nlist_for_each_entry(ctrl, &hdl->ctrls, node)\r\nif (!(ctrl->flags & V4L2_CTRL_FLAG_DISABLED))\r\nlog_ctrl(ctrl, prefix, colon);\r\nmutex_unlock(hdl->lock);\r\n}\r\nint v4l2_ctrl_subdev_log_status(struct v4l2_subdev *sd)\r\n{\r\nv4l2_ctrl_handler_log_status(sd->ctrl_handler, sd->name);\r\nreturn 0;\r\n}\r\nint v4l2_ctrl_handler_setup(struct v4l2_ctrl_handler *hdl)\r\n{\r\nstruct v4l2_ctrl *ctrl;\r\nint ret = 0;\r\nif (hdl == NULL)\r\nreturn 0;\r\nmutex_lock(hdl->lock);\r\nlist_for_each_entry(ctrl, &hdl->ctrls, node)\r\nctrl->done = false;\r\nlist_for_each_entry(ctrl, &hdl->ctrls, node) {\r\nstruct v4l2_ctrl *master = ctrl->cluster[0];\r\nint i;\r\nif (ctrl->done || ctrl->type == V4L2_CTRL_TYPE_BUTTON ||\r\n(ctrl->flags & V4L2_CTRL_FLAG_READ_ONLY))\r\ncontinue;\r\nfor (i = 0; i < master->ncontrols; i++) {\r\nif (master->cluster[i]) {\r\ncur_to_new(master->cluster[i]);\r\nmaster->cluster[i]->is_new = 1;\r\nmaster->cluster[i]->done = true;\r\n}\r\n}\r\nret = call_op(master, s_ctrl);\r\nif (ret)\r\nbreak;\r\n}\r\nmutex_unlock(hdl->lock);\r\nreturn ret;\r\n}\r\nint v4l2_query_ext_ctrl(struct v4l2_ctrl_handler *hdl, struct v4l2_query_ext_ctrl *qc)\r\n{\r\nconst unsigned next_flags = V4L2_CTRL_FLAG_NEXT_CTRL | V4L2_CTRL_FLAG_NEXT_COMPOUND;\r\nu32 id = qc->id & V4L2_CTRL_ID_MASK;\r\nstruct v4l2_ctrl_ref *ref;\r\nstruct v4l2_ctrl *ctrl;\r\nif (hdl == NULL)\r\nreturn -EINVAL;\r\nmutex_lock(hdl->lock);\r\nref = find_ref(hdl, id);\r\nif ((qc->id & next_flags) && !list_empty(&hdl->ctrl_refs)) {\r\nbool is_compound;\r\nunsigned mask = 1;\r\nbool match = false;\r\nif ((qc->id & next_flags) == V4L2_CTRL_FLAG_NEXT_COMPOUND) {\r\nmatch = true;\r\n} else if ((qc->id & next_flags) == next_flags) {\r\nmask = 0;\r\n}\r\nif (id >= node2id(hdl->ctrl_refs.prev)) {\r\nref = NULL;\r\n} else if (ref) {\r\nlist_for_each_entry_continue(ref, &hdl->ctrl_refs, node) {\r\nis_compound =\r\nref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;\r\nif (id < ref->ctrl->id &&\r\n(is_compound & mask) == match)\r\nbreak;\r\n}\r\nif (&ref->node == &hdl->ctrl_refs)\r\nref = NULL;\r\n} else {\r\nlist_for_each_entry(ref, &hdl->ctrl_refs, node) {\r\nis_compound =\r\nref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;\r\nif (id < ref->ctrl->id &&\r\n(is_compound & mask) == match)\r\nbreak;\r\n}\r\nif (&ref->node == &hdl->ctrl_refs)\r\nref = NULL;\r\n}\r\n}\r\nmutex_unlock(hdl->lock);\r\nif (!ref)\r\nreturn -EINVAL;\r\nctrl = ref->ctrl;\r\nmemset(qc, 0, sizeof(*qc));\r\nif (id >= V4L2_CID_PRIVATE_BASE)\r\nqc->id = id;\r\nelse\r\nqc->id = ctrl->id;\r\nstrlcpy(qc->name, ctrl->name, sizeof(qc->name));\r\nqc->flags = ctrl->flags;\r\nqc->type = ctrl->type;\r\nif (ctrl->is_ptr)\r\nqc->flags |= V4L2_CTRL_FLAG_HAS_PAYLOAD;\r\nqc->elem_size = ctrl->elem_size;\r\nqc->elems = ctrl->elems;\r\nqc->nr_of_dims = ctrl->nr_of_dims;\r\nmemcpy(qc->dims, ctrl->dims, qc->nr_of_dims * sizeof(qc->dims[0]));\r\nqc->minimum = ctrl->minimum;\r\nqc->maximum = ctrl->maximum;\r\nqc->default_value = ctrl->default_value;\r\nif (ctrl->type == V4L2_CTRL_TYPE_MENU\r\n|| ctrl->type == V4L2_CTRL_TYPE_INTEGER_MENU)\r\nqc->step = 1;\r\nelse\r\nqc->step = ctrl->step;\r\nreturn 0;\r\n}\r\nint v4l2_queryctrl(struct v4l2_ctrl_handler *hdl, struct v4l2_queryctrl *qc)\r\n{\r\nstruct v4l2_query_ext_ctrl qec = { qc->id };\r\nint rc;\r\nrc = v4l2_query_ext_ctrl(hdl, &qec);\r\nif (rc)\r\nreturn rc;\r\nqc->id = qec.id;\r\nqc->type = qec.type;\r\nqc->flags = qec.flags;\r\nstrlcpy(qc->name, qec.name, sizeof(qc->name));\r\nswitch (qc->type) {\r\ncase V4L2_CTRL_TYPE_INTEGER:\r\ncase V4L2_CTRL_TYPE_BOOLEAN:\r\ncase V4L2_CTRL_TYPE_MENU:\r\ncase V4L2_CTRL_TYPE_INTEGER_MENU:\r\ncase V4L2_CTRL_TYPE_STRING:\r\ncase V4L2_CTRL_TYPE_BITMASK:\r\nqc->minimum = qec.minimum;\r\nqc->maximum = qec.maximum;\r\nqc->step = qec.step;\r\nqc->default_value = qec.default_value;\r\nbreak;\r\ndefault:\r\nqc->minimum = 0;\r\nqc->maximum = 0;\r\nqc->step = 0;\r\nqc->default_value = 0;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint v4l2_subdev_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)\r\n{\r\nif (qc->id & (V4L2_CTRL_FLAG_NEXT_CTRL | V4L2_CTRL_FLAG_NEXT_COMPOUND))\r\nreturn -EINVAL;\r\nreturn v4l2_queryctrl(sd->ctrl_handler, qc);\r\n}\r\nint v4l2_querymenu(struct v4l2_ctrl_handler *hdl, struct v4l2_querymenu *qm)\r\n{\r\nstruct v4l2_ctrl *ctrl;\r\nu32 i = qm->index;\r\nctrl = v4l2_ctrl_find(hdl, qm->id);\r\nif (!ctrl)\r\nreturn -EINVAL;\r\nqm->reserved = 0;\r\nswitch (ctrl->type) {\r\ncase V4L2_CTRL_TYPE_MENU:\r\nif (ctrl->qmenu == NULL)\r\nreturn -EINVAL;\r\nbreak;\r\ncase V4L2_CTRL_TYPE_INTEGER_MENU:\r\nif (ctrl->qmenu_int == NULL)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (i < ctrl->minimum || i > ctrl->maximum)\r\nreturn -EINVAL;\r\nif (ctrl->menu_skip_mask & (1 << i))\r\nreturn -EINVAL;\r\nif (ctrl->type == V4L2_CTRL_TYPE_MENU) {\r\nif (ctrl->qmenu[i] == NULL || ctrl->qmenu[i][0] == '\0')\r\nreturn -EINVAL;\r\nstrlcpy(qm->name, ctrl->qmenu[i], sizeof(qm->name));\r\n} else {\r\nqm->value = ctrl->qmenu_int[i];\r\n}\r\nreturn 0;\r\n}\r\nint v4l2_subdev_querymenu(struct v4l2_subdev *sd, struct v4l2_querymenu *qm)\r\n{\r\nreturn v4l2_querymenu(sd->ctrl_handler, qm);\r\n}\r\nstatic int prepare_ext_ctrls(struct v4l2_ctrl_handler *hdl,\r\nstruct v4l2_ext_controls *cs,\r\nstruct v4l2_ctrl_helper *helpers,\r\nbool get)\r\n{\r\nstruct v4l2_ctrl_helper *h;\r\nbool have_clusters = false;\r\nu32 i;\r\nfor (i = 0, h = helpers; i < cs->count; i++, h++) {\r\nstruct v4l2_ext_control *c = &cs->controls[i];\r\nstruct v4l2_ctrl_ref *ref;\r\nstruct v4l2_ctrl *ctrl;\r\nu32 id = c->id & V4L2_CTRL_ID_MASK;\r\ncs->error_idx = i;\r\nif (cs->ctrl_class && V4L2_CTRL_ID2CLASS(id) != cs->ctrl_class)\r\nreturn -EINVAL;\r\nif (id >= V4L2_CID_PRIVATE_BASE)\r\nreturn -EINVAL;\r\nref = find_ref_lock(hdl, id);\r\nif (ref == NULL)\r\nreturn -EINVAL;\r\nctrl = ref->ctrl;\r\nif (ctrl->flags & V4L2_CTRL_FLAG_DISABLED)\r\nreturn -EINVAL;\r\nif (ctrl->cluster[0]->ncontrols > 1)\r\nhave_clusters = true;\r\nif (ctrl->cluster[0] != ctrl)\r\nref = find_ref_lock(hdl, ctrl->cluster[0]->id);\r\nif (ctrl->is_ptr && !ctrl->is_string) {\r\nunsigned tot_size = ctrl->elems * ctrl->elem_size;\r\nif (c->size < tot_size) {\r\nif (get) {\r\nc->size = tot_size;\r\nreturn -ENOSPC;\r\n}\r\nreturn -EFAULT;\r\n}\r\nc->size = tot_size;\r\n}\r\nh->mref = ref;\r\nh->ctrl = ctrl;\r\nh->next = 0;\r\n}\r\nif (!have_clusters)\r\nreturn 0;\r\nmutex_lock(hdl->lock);\r\nfor (i = 0; i < cs->count; i++)\r\nhelpers[i].mref->helper = NULL;\r\nfor (i = 0, h = helpers; i < cs->count; i++, h++) {\r\nstruct v4l2_ctrl_ref *mref = h->mref;\r\nif (mref->helper) {\r\nmref->helper->next = i;\r\nh->mref = NULL;\r\n}\r\nmref->helper = h;\r\n}\r\nmutex_unlock(hdl->lock);\r\nreturn 0;\r\n}\r\nstatic int class_check(struct v4l2_ctrl_handler *hdl, u32 ctrl_class)\r\n{\r\nif (ctrl_class == 0)\r\nreturn list_empty(&hdl->ctrl_refs) ? -EINVAL : 0;\r\nreturn find_ref_lock(hdl, ctrl_class | 1) ? 0 : -EINVAL;\r\n}\r\nint v4l2_g_ext_ctrls(struct v4l2_ctrl_handler *hdl, struct v4l2_ext_controls *cs)\r\n{\r\nstruct v4l2_ctrl_helper helper[4];\r\nstruct v4l2_ctrl_helper *helpers = helper;\r\nint ret;\r\nint i, j;\r\ncs->error_idx = cs->count;\r\ncs->ctrl_class = V4L2_CTRL_ID2CLASS(cs->ctrl_class);\r\nif (hdl == NULL)\r\nreturn -EINVAL;\r\nif (cs->count == 0)\r\nreturn class_check(hdl, cs->ctrl_class);\r\nif (cs->count > ARRAY_SIZE(helper)) {\r\nhelpers = kmalloc_array(cs->count, sizeof(helper[0]),\r\nGFP_KERNEL);\r\nif (helpers == NULL)\r\nreturn -ENOMEM;\r\n}\r\nret = prepare_ext_ctrls(hdl, cs, helpers, true);\r\ncs->error_idx = cs->count;\r\nfor (i = 0; !ret && i < cs->count; i++)\r\nif (helpers[i].ctrl->flags & V4L2_CTRL_FLAG_WRITE_ONLY)\r\nret = -EACCES;\r\nfor (i = 0; !ret && i < cs->count; i++) {\r\nint (*ctrl_to_user)(struct v4l2_ext_control *c,\r\nstruct v4l2_ctrl *ctrl) = cur_to_user;\r\nstruct v4l2_ctrl *master;\r\nif (helpers[i].mref == NULL)\r\ncontinue;\r\nmaster = helpers[i].mref->ctrl;\r\ncs->error_idx = i;\r\nv4l2_ctrl_lock(master);\r\nif ((master->flags & V4L2_CTRL_FLAG_VOLATILE) ||\r\n(master->has_volatiles && !is_cur_manual(master))) {\r\nfor (j = 0; j < master->ncontrols; j++)\r\ncur_to_new(master->cluster[j]);\r\nret = call_op(master, g_volatile_ctrl);\r\nctrl_to_user = new_to_user;\r\n}\r\nif (!ret) {\r\nu32 idx = i;\r\ndo {\r\nret = ctrl_to_user(cs->controls + idx,\r\nhelpers[idx].ctrl);\r\nidx = helpers[idx].next;\r\n} while (!ret && idx);\r\n}\r\nv4l2_ctrl_unlock(master);\r\n}\r\nif (cs->count > ARRAY_SIZE(helper))\r\nkfree(helpers);\r\nreturn ret;\r\n}\r\nint v4l2_subdev_g_ext_ctrls(struct v4l2_subdev *sd, struct v4l2_ext_controls *cs)\r\n{\r\nreturn v4l2_g_ext_ctrls(sd->ctrl_handler, cs);\r\n}\r\nstatic int get_ctrl(struct v4l2_ctrl *ctrl, struct v4l2_ext_control *c)\r\n{\r\nstruct v4l2_ctrl *master = ctrl->cluster[0];\r\nint ret = 0;\r\nint i;\r\nif (!ctrl->is_int)\r\nreturn -EINVAL;\r\nif (ctrl->flags & V4L2_CTRL_FLAG_WRITE_ONLY)\r\nreturn -EACCES;\r\nv4l2_ctrl_lock(master);\r\nif (ctrl->flags & V4L2_CTRL_FLAG_VOLATILE) {\r\nfor (i = 0; i < master->ncontrols; i++)\r\ncur_to_new(master->cluster[i]);\r\nret = call_op(master, g_volatile_ctrl);\r\nnew_to_user(c, ctrl);\r\n} else {\r\ncur_to_user(c, ctrl);\r\n}\r\nv4l2_ctrl_unlock(master);\r\nreturn ret;\r\n}\r\nint v4l2_g_ctrl(struct v4l2_ctrl_handler *hdl, struct v4l2_control *control)\r\n{\r\nstruct v4l2_ctrl *ctrl = v4l2_ctrl_find(hdl, control->id);\r\nstruct v4l2_ext_control c;\r\nint ret;\r\nif (ctrl == NULL || !ctrl->is_int)\r\nreturn -EINVAL;\r\nret = get_ctrl(ctrl, &c);\r\ncontrol->value = c.value;\r\nreturn ret;\r\n}\r\nint v4l2_subdev_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *control)\r\n{\r\nreturn v4l2_g_ctrl(sd->ctrl_handler, control);\r\n}\r\ns32 v4l2_ctrl_g_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_ext_control c;\r\nWARN_ON(!ctrl->is_int);\r\nc.value = 0;\r\nget_ctrl(ctrl, &c);\r\nreturn c.value;\r\n}\r\ns64 v4l2_ctrl_g_ctrl_int64(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_ext_control c;\r\nWARN_ON(ctrl->is_ptr || ctrl->type != V4L2_CTRL_TYPE_INTEGER64);\r\nc.value = 0;\r\nget_ctrl(ctrl, &c);\r\nreturn c.value;\r\n}\r\nstatic int try_or_set_cluster(struct v4l2_fh *fh, struct v4l2_ctrl *master,\r\nbool set, u32 ch_flags)\r\n{\r\nbool update_flag;\r\nint ret;\r\nint i;\r\nfor (i = 0; i < master->ncontrols; i++) {\r\nstruct v4l2_ctrl *ctrl = master->cluster[i];\r\nif (ctrl == NULL)\r\ncontinue;\r\nif (!ctrl->is_new) {\r\ncur_to_new(ctrl);\r\ncontinue;\r\n}\r\nif (set && (ctrl->flags & V4L2_CTRL_FLAG_GRABBED))\r\nreturn -EBUSY;\r\n}\r\nret = call_op(master, try_ctrl);\r\nif (ret || !set || !cluster_changed(master))\r\nreturn ret;\r\nret = call_op(master, s_ctrl);\r\nif (ret)\r\nreturn ret;\r\nupdate_flag = is_cur_manual(master) != is_new_manual(master);\r\nfor (i = 0; i < master->ncontrols; i++)\r\nnew_to_cur(fh, master->cluster[i], ch_flags |\r\n((update_flag && i > 0) ? V4L2_EVENT_CTRL_CH_FLAGS : 0));\r\nreturn 0;\r\n}\r\nstatic int validate_ctrls(struct v4l2_ext_controls *cs,\r\nstruct v4l2_ctrl_helper *helpers, bool set)\r\n{\r\nunsigned i;\r\nint ret = 0;\r\ncs->error_idx = cs->count;\r\nfor (i = 0; i < cs->count; i++) {\r\nstruct v4l2_ctrl *ctrl = helpers[i].ctrl;\r\nunion v4l2_ctrl_ptr p_new;\r\ncs->error_idx = i;\r\nif (ctrl->flags & V4L2_CTRL_FLAG_READ_ONLY)\r\nreturn -EACCES;\r\nif (set && (ctrl->flags & V4L2_CTRL_FLAG_GRABBED))\r\nreturn -EBUSY;\r\nif (ctrl->is_ptr)\r\ncontinue;\r\nif (ctrl->type == V4L2_CTRL_TYPE_INTEGER64)\r\np_new.p_s64 = &cs->controls[i].value64;\r\nelse\r\np_new.p_s32 = &cs->controls[i].value;\r\nret = validate_new(ctrl, p_new);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void update_from_auto_cluster(struct v4l2_ctrl *master)\r\n{\r\nint i;\r\nfor (i = 0; i < master->ncontrols; i++)\r\ncur_to_new(master->cluster[i]);\r\nif (!call_op(master, g_volatile_ctrl))\r\nfor (i = 1; i < master->ncontrols; i++)\r\nif (master->cluster[i])\r\nmaster->cluster[i]->is_new = 1;\r\n}\r\nstatic int try_set_ext_ctrls(struct v4l2_fh *fh, struct v4l2_ctrl_handler *hdl,\r\nstruct v4l2_ext_controls *cs,\r\nbool set)\r\n{\r\nstruct v4l2_ctrl_helper helper[4];\r\nstruct v4l2_ctrl_helper *helpers = helper;\r\nunsigned i, j;\r\nint ret;\r\ncs->error_idx = cs->count;\r\ncs->ctrl_class = V4L2_CTRL_ID2CLASS(cs->ctrl_class);\r\nif (hdl == NULL)\r\nreturn -EINVAL;\r\nif (cs->count == 0)\r\nreturn class_check(hdl, cs->ctrl_class);\r\nif (cs->count > ARRAY_SIZE(helper)) {\r\nhelpers = kmalloc_array(cs->count, sizeof(helper[0]),\r\nGFP_KERNEL);\r\nif (!helpers)\r\nreturn -ENOMEM;\r\n}\r\nret = prepare_ext_ctrls(hdl, cs, helpers, false);\r\nif (!ret)\r\nret = validate_ctrls(cs, helpers, set);\r\nif (ret && set)\r\ncs->error_idx = cs->count;\r\nfor (i = 0; !ret && i < cs->count; i++) {\r\nstruct v4l2_ctrl *master;\r\nu32 idx = i;\r\nif (helpers[i].mref == NULL)\r\ncontinue;\r\ncs->error_idx = i;\r\nmaster = helpers[i].mref->ctrl;\r\nv4l2_ctrl_lock(master);\r\nfor (j = 0; j < master->ncontrols; j++)\r\nif (master->cluster[j])\r\nmaster->cluster[j]->is_new = 0;\r\nif (master->is_auto && master->has_volatiles &&\r\n!is_cur_manual(master)) {\r\ns32 new_auto_val = master->manual_mode_value + 1;\r\nu32 tmp_idx = idx;\r\ndo {\r\nif (helpers[tmp_idx].ctrl == master)\r\nnew_auto_val = cs->controls[tmp_idx].value;\r\ntmp_idx = helpers[tmp_idx].next;\r\n} while (tmp_idx);\r\nif (new_auto_val == master->manual_mode_value)\r\nupdate_from_auto_cluster(master);\r\n}\r\ndo {\r\nstruct v4l2_ctrl *ctrl = helpers[idx].ctrl;\r\nret = user_to_new(cs->controls + idx, ctrl);\r\nif (!ret && ctrl->is_ptr)\r\nret = validate_new(ctrl, ctrl->p_new);\r\nidx = helpers[idx].next;\r\n} while (!ret && idx);\r\nif (!ret)\r\nret = try_or_set_cluster(fh, master, set, 0);\r\nif (!ret) {\r\nidx = i;\r\ndo {\r\nret = new_to_user(cs->controls + idx,\r\nhelpers[idx].ctrl);\r\nidx = helpers[idx].next;\r\n} while (!ret && idx);\r\n}\r\nv4l2_ctrl_unlock(master);\r\n}\r\nif (cs->count > ARRAY_SIZE(helper))\r\nkfree(helpers);\r\nreturn ret;\r\n}\r\nint v4l2_try_ext_ctrls(struct v4l2_ctrl_handler *hdl, struct v4l2_ext_controls *cs)\r\n{\r\nreturn try_set_ext_ctrls(NULL, hdl, cs, false);\r\n}\r\nint v4l2_s_ext_ctrls(struct v4l2_fh *fh, struct v4l2_ctrl_handler *hdl,\r\nstruct v4l2_ext_controls *cs)\r\n{\r\nreturn try_set_ext_ctrls(fh, hdl, cs, true);\r\n}\r\nint v4l2_subdev_try_ext_ctrls(struct v4l2_subdev *sd, struct v4l2_ext_controls *cs)\r\n{\r\nreturn try_set_ext_ctrls(NULL, sd->ctrl_handler, cs, false);\r\n}\r\nint v4l2_subdev_s_ext_ctrls(struct v4l2_subdev *sd, struct v4l2_ext_controls *cs)\r\n{\r\nreturn try_set_ext_ctrls(NULL, sd->ctrl_handler, cs, true);\r\n}\r\nstatic int set_ctrl(struct v4l2_fh *fh, struct v4l2_ctrl *ctrl, u32 ch_flags)\r\n{\r\nstruct v4l2_ctrl *master = ctrl->cluster[0];\r\nint ret;\r\nint i;\r\nfor (i = 0; i < master->ncontrols; i++)\r\nif (master->cluster[i])\r\nmaster->cluster[i]->is_new = 0;\r\nret = validate_new(ctrl, ctrl->p_new);\r\nif (ret)\r\nreturn ret;\r\nif (master->is_auto && master->has_volatiles && ctrl == master &&\r\n!is_cur_manual(master) && ctrl->val == master->manual_mode_value)\r\nupdate_from_auto_cluster(master);\r\nctrl->is_new = 1;\r\nreturn try_or_set_cluster(fh, master, true, ch_flags);\r\n}\r\nstatic int set_ctrl_lock(struct v4l2_fh *fh, struct v4l2_ctrl *ctrl,\r\nstruct v4l2_ext_control *c)\r\n{\r\nint ret;\r\nv4l2_ctrl_lock(ctrl);\r\nuser_to_new(c, ctrl);\r\nret = set_ctrl(fh, ctrl, 0);\r\nif (!ret)\r\ncur_to_user(c, ctrl);\r\nv4l2_ctrl_unlock(ctrl);\r\nreturn ret;\r\n}\r\nint v4l2_s_ctrl(struct v4l2_fh *fh, struct v4l2_ctrl_handler *hdl,\r\nstruct v4l2_control *control)\r\n{\r\nstruct v4l2_ctrl *ctrl = v4l2_ctrl_find(hdl, control->id);\r\nstruct v4l2_ext_control c = { control->id };\r\nint ret;\r\nif (ctrl == NULL || !ctrl->is_int)\r\nreturn -EINVAL;\r\nif (ctrl->flags & V4L2_CTRL_FLAG_READ_ONLY)\r\nreturn -EACCES;\r\nc.value = control->value;\r\nret = set_ctrl_lock(fh, ctrl, &c);\r\ncontrol->value = c.value;\r\nreturn ret;\r\n}\r\nint v4l2_subdev_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *control)\r\n{\r\nreturn v4l2_s_ctrl(NULL, sd->ctrl_handler, control);\r\n}\r\nint __v4l2_ctrl_s_ctrl(struct v4l2_ctrl *ctrl, s32 val)\r\n{\r\nlockdep_assert_held(ctrl->handler->lock);\r\nWARN_ON(!ctrl->is_int);\r\nctrl->val = val;\r\nreturn set_ctrl(NULL, ctrl, 0);\r\n}\r\nint __v4l2_ctrl_s_ctrl_int64(struct v4l2_ctrl *ctrl, s64 val)\r\n{\r\nlockdep_assert_held(ctrl->handler->lock);\r\nWARN_ON(ctrl->is_ptr || ctrl->type != V4L2_CTRL_TYPE_INTEGER64);\r\n*ctrl->p_new.p_s64 = val;\r\nreturn set_ctrl(NULL, ctrl, 0);\r\n}\r\nint __v4l2_ctrl_s_ctrl_string(struct v4l2_ctrl *ctrl, const char *s)\r\n{\r\nlockdep_assert_held(ctrl->handler->lock);\r\nWARN_ON(ctrl->type != V4L2_CTRL_TYPE_STRING);\r\nstrlcpy(ctrl->p_new.p_char, s, ctrl->maximum + 1);\r\nreturn set_ctrl(NULL, ctrl, 0);\r\n}\r\nvoid v4l2_ctrl_notify(struct v4l2_ctrl *ctrl, v4l2_ctrl_notify_fnc notify, void *priv)\r\n{\r\nif (ctrl == NULL)\r\nreturn;\r\nif (notify == NULL) {\r\nctrl->call_notify = 0;\r\nreturn;\r\n}\r\nif (WARN_ON(ctrl->handler->notify && ctrl->handler->notify != notify))\r\nreturn;\r\nctrl->handler->notify = notify;\r\nctrl->handler->notify_priv = priv;\r\nctrl->call_notify = 1;\r\n}\r\nint __v4l2_ctrl_modify_range(struct v4l2_ctrl *ctrl,\r\ns64 min, s64 max, u64 step, s64 def)\r\n{\r\nbool changed;\r\nint ret;\r\nlockdep_assert_held(ctrl->handler->lock);\r\nswitch (ctrl->type) {\r\ncase V4L2_CTRL_TYPE_INTEGER:\r\ncase V4L2_CTRL_TYPE_INTEGER64:\r\ncase V4L2_CTRL_TYPE_BOOLEAN:\r\ncase V4L2_CTRL_TYPE_MENU:\r\ncase V4L2_CTRL_TYPE_INTEGER_MENU:\r\ncase V4L2_CTRL_TYPE_BITMASK:\r\ncase V4L2_CTRL_TYPE_U8:\r\ncase V4L2_CTRL_TYPE_U16:\r\ncase V4L2_CTRL_TYPE_U32:\r\nif (ctrl->is_array)\r\nreturn -EINVAL;\r\nret = check_range(ctrl->type, min, max, step, def);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nctrl->minimum = min;\r\nctrl->maximum = max;\r\nctrl->step = step;\r\nctrl->default_value = def;\r\ncur_to_new(ctrl);\r\nif (validate_new(ctrl, ctrl->p_new)) {\r\nif (ctrl->type == V4L2_CTRL_TYPE_INTEGER64)\r\n*ctrl->p_new.p_s64 = def;\r\nelse\r\n*ctrl->p_new.p_s32 = def;\r\n}\r\nif (ctrl->type == V4L2_CTRL_TYPE_INTEGER64)\r\nchanged = *ctrl->p_new.p_s64 != *ctrl->p_cur.p_s64;\r\nelse\r\nchanged = *ctrl->p_new.p_s32 != *ctrl->p_cur.p_s32;\r\nif (changed)\r\nret = set_ctrl(NULL, ctrl, V4L2_EVENT_CTRL_CH_RANGE);\r\nelse\r\nsend_event(NULL, ctrl, V4L2_EVENT_CTRL_CH_RANGE);\r\nreturn ret;\r\n}\r\nstatic int v4l2_ctrl_add_event(struct v4l2_subscribed_event *sev, unsigned elems)\r\n{\r\nstruct v4l2_ctrl *ctrl = v4l2_ctrl_find(sev->fh->ctrl_handler, sev->id);\r\nif (ctrl == NULL)\r\nreturn -EINVAL;\r\nv4l2_ctrl_lock(ctrl);\r\nlist_add_tail(&sev->node, &ctrl->ev_subs);\r\nif (ctrl->type != V4L2_CTRL_TYPE_CTRL_CLASS &&\r\n(sev->flags & V4L2_EVENT_SUB_FL_SEND_INITIAL)) {\r\nstruct v4l2_event ev;\r\nu32 changes = V4L2_EVENT_CTRL_CH_FLAGS;\r\nif (!(ctrl->flags & V4L2_CTRL_FLAG_WRITE_ONLY))\r\nchanges |= V4L2_EVENT_CTRL_CH_VALUE;\r\nfill_event(&ev, ctrl, changes);\r\nsev->elems = elems;\r\nv4l2_event_queue_fh(sev->fh, &ev);\r\n}\r\nv4l2_ctrl_unlock(ctrl);\r\nreturn 0;\r\n}\r\nstatic void v4l2_ctrl_del_event(struct v4l2_subscribed_event *sev)\r\n{\r\nstruct v4l2_ctrl *ctrl = v4l2_ctrl_find(sev->fh->ctrl_handler, sev->id);\r\nv4l2_ctrl_lock(ctrl);\r\nlist_del(&sev->node);\r\nv4l2_ctrl_unlock(ctrl);\r\n}\r\nvoid v4l2_ctrl_replace(struct v4l2_event *old, const struct v4l2_event *new)\r\n{\r\nu32 old_changes = old->u.ctrl.changes;\r\nold->u.ctrl = new->u.ctrl;\r\nold->u.ctrl.changes |= old_changes;\r\n}\r\nvoid v4l2_ctrl_merge(const struct v4l2_event *old, struct v4l2_event *new)\r\n{\r\nnew->u.ctrl.changes |= old->u.ctrl.changes;\r\n}\r\nint v4l2_ctrl_log_status(struct file *file, void *fh)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_fh *vfh = file->private_data;\r\nif (test_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags) && vfd->v4l2_dev)\r\nv4l2_ctrl_handler_log_status(vfh->ctrl_handler,\r\nvfd->v4l2_dev->name);\r\nreturn 0;\r\n}\r\nint v4l2_ctrl_subscribe_event(struct v4l2_fh *fh,\r\nconst struct v4l2_event_subscription *sub)\r\n{\r\nif (sub->type == V4L2_EVENT_CTRL)\r\nreturn v4l2_event_subscribe(fh, sub, 0, &v4l2_ctrl_sub_ev_ops);\r\nreturn -EINVAL;\r\n}\r\nint v4l2_ctrl_subdev_subscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,\r\nstruct v4l2_event_subscription *sub)\r\n{\r\nif (!sd->ctrl_handler)\r\nreturn -EINVAL;\r\nreturn v4l2_ctrl_subscribe_event(fh, sub);\r\n}\r\nunsigned int v4l2_ctrl_poll(struct file *file, struct poll_table_struct *wait)\r\n{\r\nstruct v4l2_fh *fh = file->private_data;\r\nif (v4l2_event_pending(fh))\r\nreturn POLLPRI;\r\npoll_wait(file, &fh->wait, wait);\r\nreturn 0;\r\n}
