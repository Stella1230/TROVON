static const char *brcmf_fweh_event_name(enum brcmf_fweh_event_code code)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(fweh_event_names); i++) {\r\nif (fweh_event_names[i].code == code)\r\nreturn fweh_event_names[i].name;\r\n}\r\nreturn "unknown";\r\n}\r\nstatic const char *brcmf_fweh_event_name(enum brcmf_fweh_event_code code)\r\n{\r\nreturn "nodebug";\r\n}\r\nstatic void brcmf_fweh_queue_event(struct brcmf_fweh_info *fweh,\r\nstruct brcmf_fweh_queue_item *event)\r\n{\r\nulong flags;\r\nspin_lock_irqsave(&fweh->evt_q_lock, flags);\r\nlist_add_tail(&event->q, &fweh->event_q);\r\nspin_unlock_irqrestore(&fweh->evt_q_lock, flags);\r\nschedule_work(&fweh->event_work);\r\n}\r\nstatic int brcmf_fweh_call_event_handler(struct brcmf_if *ifp,\r\nenum brcmf_fweh_event_code code,\r\nstruct brcmf_event_msg *emsg,\r\nvoid *data)\r\n{\r\nstruct brcmf_fweh_info *fweh;\r\nint err = -EINVAL;\r\nif (ifp) {\r\nfweh = &ifp->drvr->fweh;\r\nif (fweh->evt_handler[code])\r\nerr = fweh->evt_handler[code](ifp, emsg, data);\r\nelse\r\nbrcmf_err("unhandled event %d ignored\n", code);\r\n} else {\r\nbrcmf_err("no interface object\n");\r\n}\r\nreturn err;\r\n}\r\nstatic void brcmf_fweh_handle_if_event(struct brcmf_pub *drvr,\r\nstruct brcmf_event_msg *emsg,\r\nvoid *data)\r\n{\r\nstruct brcmf_if_event *ifevent = data;\r\nstruct brcmf_if *ifp;\r\nint err = 0;\r\nbrcmf_dbg(EVENT, "action: %u idx: %u bsscfg: %u flags: %u role: %u\n",\r\nifevent->action, ifevent->ifidx, ifevent->bssidx,\r\nifevent->flags, ifevent->role);\r\nif (!(ifevent->ifidx == 0 && ifevent->bssidx == 1) &&\r\n(ifevent->flags & BRCMF_E_IF_FLAG_NOIF)) {\r\nbrcmf_dbg(EVENT, "event can be ignored\n");\r\nreturn;\r\n}\r\nif (ifevent->ifidx >= BRCMF_MAX_IFS) {\r\nbrcmf_err("invalid interface index: %u\n",\r\nifevent->ifidx);\r\nreturn;\r\n}\r\nifp = drvr->iflist[ifevent->bssidx];\r\nif (ifevent->action == BRCMF_E_IF_ADD) {\r\nbrcmf_dbg(EVENT, "adding %s (%pM)\n", emsg->ifname,\r\nemsg->addr);\r\nifp = brcmf_add_if(drvr, ifevent->bssidx, ifevent->ifidx,\r\nemsg->ifname, emsg->addr);\r\nif (IS_ERR(ifp))\r\nreturn;\r\nbrcmf_fws_add_interface(ifp);\r\nif (!drvr->fweh.evt_handler[BRCMF_E_IF])\r\nif (brcmf_net_attach(ifp, false) < 0)\r\nreturn;\r\n}\r\nif (ifp && ifevent->action == BRCMF_E_IF_CHANGE)\r\nbrcmf_fws_reset_interface(ifp);\r\nerr = brcmf_fweh_call_event_handler(ifp, emsg->event_code, emsg, data);\r\nif (ifp && ifevent->action == BRCMF_E_IF_DEL)\r\nbrcmf_remove_interface(drvr, ifevent->bssidx);\r\n}\r\nstatic struct brcmf_fweh_queue_item *\r\nbrcmf_fweh_dequeue_event(struct brcmf_fweh_info *fweh)\r\n{\r\nstruct brcmf_fweh_queue_item *event = NULL;\r\nulong flags;\r\nspin_lock_irqsave(&fweh->evt_q_lock, flags);\r\nif (!list_empty(&fweh->event_q)) {\r\nevent = list_first_entry(&fweh->event_q,\r\nstruct brcmf_fweh_queue_item, q);\r\nlist_del(&event->q);\r\n}\r\nspin_unlock_irqrestore(&fweh->evt_q_lock, flags);\r\nreturn event;\r\n}\r\nstatic void brcmf_fweh_event_worker(struct work_struct *work)\r\n{\r\nstruct brcmf_pub *drvr;\r\nstruct brcmf_if *ifp;\r\nstruct brcmf_fweh_info *fweh;\r\nstruct brcmf_fweh_queue_item *event;\r\nint err = 0;\r\nstruct brcmf_event_msg_be *emsg_be;\r\nstruct brcmf_event_msg emsg;\r\nfweh = container_of(work, struct brcmf_fweh_info, event_work);\r\ndrvr = container_of(fweh, struct brcmf_pub, fweh);\r\nwhile ((event = brcmf_fweh_dequeue_event(fweh))) {\r\nbrcmf_dbg(EVENT, "event %s (%u) ifidx %u bsscfg %u addr %pM\n",\r\nbrcmf_fweh_event_name(event->code), event->code,\r\nevent->emsg.ifidx, event->emsg.bsscfgidx,\r\nevent->emsg.addr);\r\nemsg_be = &event->emsg;\r\nemsg.version = be16_to_cpu(emsg_be->version);\r\nemsg.flags = be16_to_cpu(emsg_be->flags);\r\nemsg.event_code = event->code;\r\nemsg.status = be32_to_cpu(emsg_be->status);\r\nemsg.reason = be32_to_cpu(emsg_be->reason);\r\nemsg.auth_type = be32_to_cpu(emsg_be->auth_type);\r\nemsg.datalen = be32_to_cpu(emsg_be->datalen);\r\nmemcpy(emsg.addr, emsg_be->addr, ETH_ALEN);\r\nmemcpy(emsg.ifname, emsg_be->ifname, sizeof(emsg.ifname));\r\nemsg.ifidx = emsg_be->ifidx;\r\nemsg.bsscfgidx = emsg_be->bsscfgidx;\r\nbrcmf_dbg(EVENT, " version %u flags %u status %u reason %u\n",\r\nemsg.version, emsg.flags, emsg.status, emsg.reason);\r\nbrcmf_dbg_hex_dump(BRCMF_EVENT_ON(), event->data,\r\nmin_t(u32, emsg.datalen, 64),\r\n"event payload, len=%d\n", emsg.datalen);\r\nif (event->code == BRCMF_E_IF) {\r\nbrcmf_fweh_handle_if_event(drvr, &emsg, event->data);\r\ngoto event_free;\r\n}\r\nif ((event->code == BRCMF_E_TDLS_PEER_EVENT) &&\r\n(emsg.bsscfgidx == 1))\r\nifp = drvr->iflist[0];\r\nelse\r\nifp = drvr->iflist[emsg.bsscfgidx];\r\nerr = brcmf_fweh_call_event_handler(ifp, event->code, &emsg,\r\nevent->data);\r\nif (err) {\r\nbrcmf_err("event handler failed (%d)\n",\r\nevent->code);\r\nerr = 0;\r\n}\r\nevent_free:\r\nkfree(event);\r\n}\r\n}\r\nvoid brcmf_fweh_attach(struct brcmf_pub *drvr)\r\n{\r\nstruct brcmf_fweh_info *fweh = &drvr->fweh;\r\nINIT_WORK(&fweh->event_work, brcmf_fweh_event_worker);\r\nspin_lock_init(&fweh->evt_q_lock);\r\nINIT_LIST_HEAD(&fweh->event_q);\r\n}\r\nvoid brcmf_fweh_detach(struct brcmf_pub *drvr)\r\n{\r\nstruct brcmf_fweh_info *fweh = &drvr->fweh;\r\nstruct brcmf_if *ifp = drvr->iflist[0];\r\ns8 eventmask[BRCMF_EVENTING_MASK_LEN];\r\nif (ifp) {\r\nmemset(eventmask, 0, BRCMF_EVENTING_MASK_LEN);\r\n(void)brcmf_fil_iovar_data_set(ifp, "event_msgs",\r\neventmask,\r\nBRCMF_EVENTING_MASK_LEN);\r\n}\r\ncancel_work_sync(&fweh->event_work);\r\nWARN_ON(!list_empty(&fweh->event_q));\r\nmemset(fweh->evt_handler, 0, sizeof(fweh->evt_handler));\r\n}\r\nint brcmf_fweh_register(struct brcmf_pub *drvr, enum brcmf_fweh_event_code code,\r\nbrcmf_fweh_handler_t handler)\r\n{\r\nif (drvr->fweh.evt_handler[code]) {\r\nbrcmf_err("event code %d already registered\n", code);\r\nreturn -ENOSPC;\r\n}\r\ndrvr->fweh.evt_handler[code] = handler;\r\nbrcmf_dbg(TRACE, "event handler registered for %s\n",\r\nbrcmf_fweh_event_name(code));\r\nreturn 0;\r\n}\r\nvoid brcmf_fweh_unregister(struct brcmf_pub *drvr,\r\nenum brcmf_fweh_event_code code)\r\n{\r\nbrcmf_dbg(TRACE, "event handler cleared for %s\n",\r\nbrcmf_fweh_event_name(code));\r\ndrvr->fweh.evt_handler[code] = NULL;\r\n}\r\nint brcmf_fweh_activate_events(struct brcmf_if *ifp)\r\n{\r\nint i, err;\r\ns8 eventmask[BRCMF_EVENTING_MASK_LEN];\r\nfor (i = 0; i < BRCMF_E_LAST; i++) {\r\nif (ifp->drvr->fweh.evt_handler[i]) {\r\nbrcmf_dbg(EVENT, "enable event %s\n",\r\nbrcmf_fweh_event_name(i));\r\nsetbit(eventmask, i);\r\n}\r\n}\r\nbrcmf_dbg(EVENT, "enable event IF\n");\r\nsetbit(eventmask, BRCMF_E_IF);\r\nerr = brcmf_fil_iovar_data_set(ifp, "event_msgs",\r\neventmask, BRCMF_EVENTING_MASK_LEN);\r\nif (err)\r\nbrcmf_err("Set event_msgs error (%d)\n", err);\r\nreturn err;\r\n}\r\nvoid brcmf_fweh_process_event(struct brcmf_pub *drvr,\r\nstruct brcmf_event *event_packet)\r\n{\r\nenum brcmf_fweh_event_code code;\r\nstruct brcmf_fweh_info *fweh = &drvr->fweh;\r\nstruct brcmf_fweh_queue_item *event;\r\ngfp_t alloc_flag = GFP_KERNEL;\r\nvoid *data;\r\nu32 datalen;\r\ncode = get_unaligned_be32(&event_packet->msg.event_type);\r\ndatalen = get_unaligned_be32(&event_packet->msg.datalen);\r\ndata = &event_packet[1];\r\nif (code >= BRCMF_E_LAST)\r\nreturn;\r\nif (code != BRCMF_E_IF && !fweh->evt_handler[code])\r\nreturn;\r\nif (in_interrupt())\r\nalloc_flag = GFP_ATOMIC;\r\nevent = kzalloc(sizeof(*event) + datalen, alloc_flag);\r\nif (!event)\r\nreturn;\r\nevent->code = code;\r\nevent->ifidx = event_packet->msg.ifidx;\r\nmemcpy(&event->emsg, &event_packet->msg, sizeof(event->emsg));\r\nmemcpy(event->data, data, datalen);\r\nmemcpy(event->ifaddr, event_packet->eth.h_dest, ETH_ALEN);\r\nbrcmf_fweh_queue_event(fweh, event);\r\n}
