static inline int\r\ntcindex_filter_is_set(struct tcindex_filter_result *r)\r\n{\r\nreturn tcf_exts_is_predicative(&r->exts) || r->res.classid;\r\n}\r\nstatic struct tcindex_filter_result *\r\ntcindex_lookup(struct tcindex_data *p, u16 key)\r\n{\r\nif (p->perfect) {\r\nstruct tcindex_filter_result *f = p->perfect + key;\r\nreturn tcindex_filter_is_set(f) ? f : NULL;\r\n} else if (p->h) {\r\nstruct tcindex_filter __rcu **fp;\r\nstruct tcindex_filter *f;\r\nfp = &p->h[key % p->hash];\r\nfor (f = rcu_dereference_bh_rtnl(*fp);\r\nf;\r\nfp = &f->next, f = rcu_dereference_bh_rtnl(*fp))\r\nif (f->key == key)\r\nreturn &f->result;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int tcindex_classify(struct sk_buff *skb, const struct tcf_proto *tp,\r\nstruct tcf_result *res)\r\n{\r\nstruct tcindex_data *p = rcu_dereference_bh(tp->root);\r\nstruct tcindex_filter_result *f;\r\nint key = (skb->tc_index & p->mask) >> p->shift;\r\npr_debug("tcindex_classify(skb %p,tp %p,res %p),p %p\n",\r\nskb, tp, res, p);\r\nf = tcindex_lookup(p, key);\r\nif (!f) {\r\nif (!p->fall_through)\r\nreturn -1;\r\nres->classid = TC_H_MAKE(TC_H_MAJ(tp->q->handle), key);\r\nres->class = 0;\r\npr_debug("alg 0x%x\n", res->classid);\r\nreturn 0;\r\n}\r\n*res = f->res;\r\npr_debug("map 0x%x\n", res->classid);\r\nreturn tcf_exts_exec(skb, &f->exts, res);\r\n}\r\nstatic unsigned long tcindex_get(struct tcf_proto *tp, u32 handle)\r\n{\r\nstruct tcindex_data *p = rtnl_dereference(tp->root);\r\nstruct tcindex_filter_result *r;\r\npr_debug("tcindex_get(tp %p,handle 0x%08x)\n", tp, handle);\r\nif (p->perfect && handle >= p->alloc_hash)\r\nreturn 0;\r\nr = tcindex_lookup(p, handle);\r\nreturn r && tcindex_filter_is_set(r) ? (unsigned long) r : 0UL;\r\n}\r\nstatic int tcindex_init(struct tcf_proto *tp)\r\n{\r\nstruct tcindex_data *p;\r\npr_debug("tcindex_init(tp %p)\n", tp);\r\np = kzalloc(sizeof(struct tcindex_data), GFP_KERNEL);\r\nif (!p)\r\nreturn -ENOMEM;\r\np->mask = 0xffff;\r\np->hash = DEFAULT_HASH_SIZE;\r\np->fall_through = 1;\r\nrcu_assign_pointer(tp->root, p);\r\nreturn 0;\r\n}\r\nstatic int\r\ntcindex_delete(struct tcf_proto *tp, unsigned long arg)\r\n{\r\nstruct tcindex_data *p = rtnl_dereference(tp->root);\r\nstruct tcindex_filter_result *r = (struct tcindex_filter_result *) arg;\r\nstruct tcindex_filter __rcu **walk;\r\nstruct tcindex_filter *f = NULL;\r\npr_debug("tcindex_delete(tp %p,arg 0x%lx),p %p\n", tp, arg, p);\r\nif (p->perfect) {\r\nif (!r->res.class)\r\nreturn -ENOENT;\r\n} else {\r\nint i;\r\nfor (i = 0; i < p->hash; i++) {\r\nwalk = p->h + i;\r\nfor (f = rtnl_dereference(*walk); f;\r\nwalk = &f->next, f = rtnl_dereference(*walk)) {\r\nif (&f->result == r)\r\ngoto found;\r\n}\r\n}\r\nreturn -ENOENT;\r\nfound:\r\nrcu_assign_pointer(*walk, rtnl_dereference(f->next));\r\n}\r\ntcf_unbind_filter(tp, &r->res);\r\ntcf_exts_destroy(&r->exts);\r\nif (f)\r\nkfree_rcu(f, rcu);\r\nreturn 0;\r\n}\r\nstatic int tcindex_destroy_element(struct tcf_proto *tp,\r\nunsigned long arg,\r\nstruct tcf_walker *walker)\r\n{\r\nreturn tcindex_delete(tp, arg);\r\n}\r\nstatic void __tcindex_destroy(struct rcu_head *head)\r\n{\r\nstruct tcindex_data *p = container_of(head, struct tcindex_data, rcu);\r\nkfree(p->perfect);\r\nkfree(p->h);\r\nkfree(p);\r\n}\r\nstatic inline int\r\nvalid_perfect_hash(struct tcindex_data *p)\r\n{\r\nreturn p->hash > (p->mask >> p->shift);\r\n}\r\nstatic void tcindex_filter_result_init(struct tcindex_filter_result *r)\r\n{\r\nmemset(r, 0, sizeof(*r));\r\ntcf_exts_init(&r->exts, TCA_TCINDEX_ACT, TCA_TCINDEX_POLICE);\r\n}\r\nstatic void __tcindex_partial_destroy(struct rcu_head *head)\r\n{\r\nstruct tcindex_data *p = container_of(head, struct tcindex_data, rcu);\r\nkfree(p->perfect);\r\nkfree(p);\r\n}\r\nstatic int\r\ntcindex_set_parms(struct net *net, struct tcf_proto *tp, unsigned long base,\r\nu32 handle, struct tcindex_data *p,\r\nstruct tcindex_filter_result *r, struct nlattr **tb,\r\nstruct nlattr *est, bool ovr)\r\n{\r\nint err, balloc = 0;\r\nstruct tcindex_filter_result new_filter_result, *old_r = r;\r\nstruct tcindex_filter_result cr;\r\nstruct tcindex_data *cp, *oldp;\r\nstruct tcindex_filter *f = NULL;\r\nstruct tcf_exts e;\r\ntcf_exts_init(&e, TCA_TCINDEX_ACT, TCA_TCINDEX_POLICE);\r\nerr = tcf_exts_validate(net, tp, tb, est, &e, ovr);\r\nif (err < 0)\r\nreturn err;\r\nerr = -ENOMEM;\r\ncp = kzalloc(sizeof(*cp), GFP_KERNEL);\r\nif (!cp)\r\ngoto errout;\r\ncp->mask = p->mask;\r\ncp->shift = p->shift;\r\ncp->hash = p->hash;\r\ncp->alloc_hash = p->alloc_hash;\r\ncp->fall_through = p->fall_through;\r\ncp->tp = tp;\r\nif (p->perfect) {\r\nint i;\r\ncp->perfect = kmemdup(p->perfect,\r\nsizeof(*r) * cp->hash, GFP_KERNEL);\r\nif (!cp->perfect)\r\ngoto errout;\r\nfor (i = 0; i < cp->hash; i++)\r\ntcf_exts_init(&cp->perfect[i].exts,\r\nTCA_TCINDEX_ACT, TCA_TCINDEX_POLICE);\r\nballoc = 1;\r\n}\r\ncp->h = p->h;\r\ntcindex_filter_result_init(&new_filter_result);\r\ntcindex_filter_result_init(&cr);\r\nif (old_r)\r\ncr.res = r->res;\r\nif (tb[TCA_TCINDEX_HASH])\r\ncp->hash = nla_get_u32(tb[TCA_TCINDEX_HASH]);\r\nif (tb[TCA_TCINDEX_MASK])\r\ncp->mask = nla_get_u16(tb[TCA_TCINDEX_MASK]);\r\nif (tb[TCA_TCINDEX_SHIFT])\r\ncp->shift = nla_get_u32(tb[TCA_TCINDEX_SHIFT]);\r\nerr = -EBUSY;\r\nif (cp->perfect) {\r\nif (!valid_perfect_hash(cp) ||\r\ncp->hash > cp->alloc_hash)\r\ngoto errout_alloc;\r\n} else if (cp->h && cp->hash != cp->alloc_hash) {\r\ngoto errout_alloc;\r\n}\r\nerr = -EINVAL;\r\nif (tb[TCA_TCINDEX_FALL_THROUGH])\r\ncp->fall_through = nla_get_u32(tb[TCA_TCINDEX_FALL_THROUGH]);\r\nif (!cp->hash) {\r\nif ((cp->mask >> cp->shift) < PERFECT_HASH_THRESHOLD)\r\ncp->hash = (cp->mask >> cp->shift) + 1;\r\nelse\r\ncp->hash = DEFAULT_HASH_SIZE;\r\n}\r\nif (!cp->perfect && !cp->h)\r\ncp->alloc_hash = cp->hash;\r\nif (cp->perfect || valid_perfect_hash(cp))\r\nif (handle >= cp->alloc_hash)\r\ngoto errout_alloc;\r\nerr = -ENOMEM;\r\nif (!cp->perfect && !cp->h) {\r\nif (valid_perfect_hash(cp)) {\r\nint i;\r\ncp->perfect = kcalloc(cp->hash, sizeof(*r), GFP_KERNEL);\r\nif (!cp->perfect)\r\ngoto errout_alloc;\r\nfor (i = 0; i < cp->hash; i++)\r\ntcf_exts_init(&cp->perfect[i].exts,\r\nTCA_TCINDEX_ACT,\r\nTCA_TCINDEX_POLICE);\r\nballoc = 1;\r\n} else {\r\nstruct tcindex_filter __rcu **hash;\r\nhash = kcalloc(cp->hash,\r\nsizeof(struct tcindex_filter *),\r\nGFP_KERNEL);\r\nif (!hash)\r\ngoto errout_alloc;\r\ncp->h = hash;\r\nballoc = 2;\r\n}\r\n}\r\nif (cp->perfect)\r\nr = cp->perfect + handle;\r\nelse\r\nr = tcindex_lookup(cp, handle) ? : &new_filter_result;\r\nif (r == &new_filter_result) {\r\nf = kzalloc(sizeof(*f), GFP_KERNEL);\r\nif (!f)\r\ngoto errout_alloc;\r\nf->key = handle;\r\ntcindex_filter_result_init(&f->result);\r\nf->next = NULL;\r\n}\r\nif (tb[TCA_TCINDEX_CLASSID]) {\r\ncr.res.classid = nla_get_u32(tb[TCA_TCINDEX_CLASSID]);\r\ntcf_bind_filter(tp, &cr.res, base);\r\n}\r\nif (old_r)\r\ntcf_exts_change(tp, &r->exts, &e);\r\nelse\r\ntcf_exts_change(tp, &cr.exts, &e);\r\nif (old_r && old_r != r)\r\ntcindex_filter_result_init(old_r);\r\noldp = p;\r\nr->res = cr.res;\r\nrcu_assign_pointer(tp->root, cp);\r\nif (r == &new_filter_result) {\r\nstruct tcindex_filter *nfp;\r\nstruct tcindex_filter __rcu **fp;\r\ntcf_exts_change(tp, &f->result.exts, &r->exts);\r\nfp = cp->h + (handle % cp->hash);\r\nfor (nfp = rtnl_dereference(*fp);\r\nnfp;\r\nfp = &nfp->next, nfp = rtnl_dereference(*fp))\r\n;\r\nrcu_assign_pointer(*fp, f);\r\n}\r\nif (oldp)\r\ncall_rcu(&oldp->rcu, __tcindex_partial_destroy);\r\nreturn 0;\r\nerrout_alloc:\r\nif (balloc == 1)\r\nkfree(cp->perfect);\r\nelse if (balloc == 2)\r\nkfree(cp->h);\r\nerrout:\r\nkfree(cp);\r\ntcf_exts_destroy(&e);\r\nreturn err;\r\n}\r\nstatic int\r\ntcindex_change(struct net *net, struct sk_buff *in_skb,\r\nstruct tcf_proto *tp, unsigned long base, u32 handle,\r\nstruct nlattr **tca, unsigned long *arg, bool ovr)\r\n{\r\nstruct nlattr *opt = tca[TCA_OPTIONS];\r\nstruct nlattr *tb[TCA_TCINDEX_MAX + 1];\r\nstruct tcindex_data *p = rtnl_dereference(tp->root);\r\nstruct tcindex_filter_result *r = (struct tcindex_filter_result *) *arg;\r\nint err;\r\npr_debug("tcindex_change(tp %p,handle 0x%08x,tca %p,arg %p),opt %p,"\r\n"p %p,r %p,*arg 0x%lx\n",\r\ntp, handle, tca, arg, opt, p, r, arg ? *arg : 0L);\r\nif (!opt)\r\nreturn 0;\r\nerr = nla_parse_nested(tb, TCA_TCINDEX_MAX, opt, tcindex_policy);\r\nif (err < 0)\r\nreturn err;\r\nreturn tcindex_set_parms(net, tp, base, handle, p, r, tb,\r\ntca[TCA_RATE], ovr);\r\n}\r\nstatic void tcindex_walk(struct tcf_proto *tp, struct tcf_walker *walker)\r\n{\r\nstruct tcindex_data *p = rtnl_dereference(tp->root);\r\nstruct tcindex_filter *f, *next;\r\nint i;\r\npr_debug("tcindex_walk(tp %p,walker %p),p %p\n", tp, walker, p);\r\nif (p->perfect) {\r\nfor (i = 0; i < p->hash; i++) {\r\nif (!p->perfect[i].res.class)\r\ncontinue;\r\nif (walker->count >= walker->skip) {\r\nif (walker->fn(tp,\r\n(unsigned long) (p->perfect+i), walker)\r\n< 0) {\r\nwalker->stop = 1;\r\nreturn;\r\n}\r\n}\r\nwalker->count++;\r\n}\r\n}\r\nif (!p->h)\r\nreturn;\r\nfor (i = 0; i < p->hash; i++) {\r\nfor (f = rtnl_dereference(p->h[i]); f; f = next) {\r\nnext = rtnl_dereference(f->next);\r\nif (walker->count >= walker->skip) {\r\nif (walker->fn(tp, (unsigned long) &f->result,\r\nwalker) < 0) {\r\nwalker->stop = 1;\r\nreturn;\r\n}\r\n}\r\nwalker->count++;\r\n}\r\n}\r\n}\r\nstatic bool tcindex_destroy(struct tcf_proto *tp, bool force)\r\n{\r\nstruct tcindex_data *p = rtnl_dereference(tp->root);\r\nstruct tcf_walker walker;\r\nif (!force)\r\nreturn false;\r\npr_debug("tcindex_destroy(tp %p),p %p\n", tp, p);\r\nwalker.count = 0;\r\nwalker.skip = 0;\r\nwalker.fn = tcindex_destroy_element;\r\ntcindex_walk(tp, &walker);\r\nRCU_INIT_POINTER(tp->root, NULL);\r\ncall_rcu(&p->rcu, __tcindex_destroy);\r\nreturn true;\r\n}\r\nstatic int tcindex_dump(struct net *net, struct tcf_proto *tp, unsigned long fh,\r\nstruct sk_buff *skb, struct tcmsg *t)\r\n{\r\nstruct tcindex_data *p = rtnl_dereference(tp->root);\r\nstruct tcindex_filter_result *r = (struct tcindex_filter_result *) fh;\r\nstruct nlattr *nest;\r\npr_debug("tcindex_dump(tp %p,fh 0x%lx,skb %p,t %p),p %p,r %p\n",\r\ntp, fh, skb, t, p, r);\r\npr_debug("p->perfect %p p->h %p\n", p->perfect, p->h);\r\nnest = nla_nest_start(skb, TCA_OPTIONS);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nif (!fh) {\r\nt->tcm_handle = ~0;\r\nif (nla_put_u32(skb, TCA_TCINDEX_HASH, p->hash) ||\r\nnla_put_u16(skb, TCA_TCINDEX_MASK, p->mask) ||\r\nnla_put_u32(skb, TCA_TCINDEX_SHIFT, p->shift) ||\r\nnla_put_u32(skb, TCA_TCINDEX_FALL_THROUGH, p->fall_through))\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest);\r\n} else {\r\nif (p->perfect) {\r\nt->tcm_handle = r - p->perfect;\r\n} else {\r\nstruct tcindex_filter *f;\r\nstruct tcindex_filter __rcu **fp;\r\nint i;\r\nt->tcm_handle = 0;\r\nfor (i = 0; !t->tcm_handle && i < p->hash; i++) {\r\nfp = &p->h[i];\r\nfor (f = rtnl_dereference(*fp);\r\n!t->tcm_handle && f;\r\nfp = &f->next, f = rtnl_dereference(*fp)) {\r\nif (&f->result == r)\r\nt->tcm_handle = f->key;\r\n}\r\n}\r\n}\r\npr_debug("handle = %d\n", t->tcm_handle);\r\nif (r->res.class &&\r\nnla_put_u32(skb, TCA_TCINDEX_CLASSID, r->res.classid))\r\ngoto nla_put_failure;\r\nif (tcf_exts_dump(skb, &r->exts) < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest);\r\nif (tcf_exts_dump_stats(skb, &r->exts) < 0)\r\ngoto nla_put_failure;\r\n}\r\nreturn skb->len;\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nest);\r\nreturn -1;\r\n}\r\nstatic int __init init_tcindex(void)\r\n{\r\nreturn register_tcf_proto_ops(&cls_tcindex_ops);\r\n}\r\nstatic void __exit exit_tcindex(void)\r\n{\r\nunregister_tcf_proto_ops(&cls_tcindex_ops);\r\n}
