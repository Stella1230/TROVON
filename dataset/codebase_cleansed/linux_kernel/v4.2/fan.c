static int\r\nnvkm_fan_update(struct nvkm_fan *fan, bool immediate, int target)\r\n{\r\nstruct nvkm_therm *therm = fan->parent;\r\nstruct nvkm_therm_priv *priv = (void *)therm;\r\nstruct nvkm_timer *ptimer = nvkm_timer(priv);\r\nunsigned long flags;\r\nint ret = 0;\r\nint duty;\r\nspin_lock_irqsave(&fan->lock, flags);\r\nif (target < 0)\r\ntarget = fan->percent;\r\ntarget = max_t(u8, target, fan->bios.min_duty);\r\ntarget = min_t(u8, target, fan->bios.max_duty);\r\nif (fan->percent != target) {\r\nnv_debug(therm, "FAN target: %d\n", target);\r\nfan->percent = target;\r\n}\r\nduty = fan->get(therm);\r\nif (duty == target) {\r\nspin_unlock_irqrestore(&fan->lock, flags);\r\nreturn 0;\r\n}\r\nif (!immediate && duty >= 0) {\r\nif (duty < target)\r\nduty = min(duty + 3, target);\r\nelse if (duty > target)\r\nduty = max(duty - 3, target);\r\n} else {\r\nduty = target;\r\n}\r\nnv_debug(therm, "FAN update: %d\n", duty);\r\nret = fan->set(therm, duty);\r\nif (ret) {\r\nspin_unlock_irqrestore(&fan->lock, flags);\r\nreturn ret;\r\n}\r\nspin_unlock_irqrestore(&fan->lock, flags);\r\nif (list_empty(&fan->alarm.head) && target != duty) {\r\nu16 bump_period = fan->bios.bump_period;\r\nu16 slow_down_period = fan->bios.slow_down_period;\r\nu64 delay;\r\nif (duty > target)\r\ndelay = slow_down_period;\r\nelse if (duty == target)\r\ndelay = min(bump_period, slow_down_period) ;\r\nelse\r\ndelay = bump_period;\r\nptimer->alarm(ptimer, delay * 1000 * 1000, &fan->alarm);\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nnvkm_fan_alarm(struct nvkm_alarm *alarm)\r\n{\r\nstruct nvkm_fan *fan = container_of(alarm, struct nvkm_fan, alarm);\r\nnvkm_fan_update(fan, false, -1);\r\n}\r\nint\r\nnvkm_therm_fan_get(struct nvkm_therm *therm)\r\n{\r\nstruct nvkm_therm_priv *priv = (void *)therm;\r\nreturn priv->fan->get(therm);\r\n}\r\nint\r\nnvkm_therm_fan_set(struct nvkm_therm *therm, bool immediate, int percent)\r\n{\r\nstruct nvkm_therm_priv *priv = (void *)therm;\r\nreturn nvkm_fan_update(priv->fan, immediate, percent);\r\n}\r\nint\r\nnvkm_therm_fan_sense(struct nvkm_therm *therm)\r\n{\r\nstruct nvkm_therm_priv *priv = (void *)therm;\r\nstruct nvkm_timer *ptimer = nvkm_timer(therm);\r\nstruct nvkm_gpio *gpio = nvkm_gpio(therm);\r\nu32 cycles, cur, prev;\r\nu64 start, end, tach;\r\nif (priv->fan->tach.func == DCB_GPIO_UNUSED)\r\nreturn -ENODEV;\r\nstart = ptimer->read(ptimer);\r\nprev = gpio->get(gpio, 0, priv->fan->tach.func, priv->fan->tach.line);\r\ncycles = 0;\r\ndo {\r\nusleep_range(500, 1000);\r\ncur = gpio->get(gpio, 0, priv->fan->tach.func, priv->fan->tach.line);\r\nif (prev != cur) {\r\nif (!start)\r\nstart = ptimer->read(ptimer);\r\ncycles++;\r\nprev = cur;\r\n}\r\n} while (cycles < 5 && ptimer->read(ptimer) - start < 250000000);\r\nend = ptimer->read(ptimer);\r\nif (cycles == 5) {\r\ntach = (u64)60000000000ULL;\r\ndo_div(tach, (end - start));\r\nreturn tach;\r\n} else\r\nreturn 0;\r\n}\r\nint\r\nnvkm_therm_fan_user_get(struct nvkm_therm *therm)\r\n{\r\nreturn nvkm_therm_fan_get(therm);\r\n}\r\nint\r\nnvkm_therm_fan_user_set(struct nvkm_therm *therm, int percent)\r\n{\r\nstruct nvkm_therm_priv *priv = (void *)therm;\r\nif (priv->mode != NVKM_THERM_CTRL_MANUAL)\r\nreturn -EINVAL;\r\nreturn nvkm_therm_fan_set(therm, true, percent);\r\n}\r\nstatic void\r\nnvkm_therm_fan_set_defaults(struct nvkm_therm *therm)\r\n{\r\nstruct nvkm_therm_priv *priv = (void *)therm;\r\npriv->fan->bios.pwm_freq = 0;\r\npriv->fan->bios.min_duty = 0;\r\npriv->fan->bios.max_duty = 100;\r\npriv->fan->bios.bump_period = 500;\r\npriv->fan->bios.slow_down_period = 2000;\r\npriv->fan->bios.linear_min_temp = 40;\r\npriv->fan->bios.linear_max_temp = 85;\r\n}\r\nstatic void\r\nnvkm_therm_fan_safety_checks(struct nvkm_therm *therm)\r\n{\r\nstruct nvkm_therm_priv *priv = (void *)therm;\r\nif (priv->fan->bios.min_duty > 100)\r\npriv->fan->bios.min_duty = 100;\r\nif (priv->fan->bios.max_duty > 100)\r\npriv->fan->bios.max_duty = 100;\r\nif (priv->fan->bios.min_duty > priv->fan->bios.max_duty)\r\npriv->fan->bios.min_duty = priv->fan->bios.max_duty;\r\n}\r\nint\r\nnvkm_therm_fan_init(struct nvkm_therm *therm)\r\n{\r\nreturn 0;\r\n}\r\nint\r\nnvkm_therm_fan_fini(struct nvkm_therm *therm, bool suspend)\r\n{\r\nstruct nvkm_therm_priv *priv = (void *)therm;\r\nstruct nvkm_timer *ptimer = nvkm_timer(therm);\r\nif (suspend)\r\nptimer->alarm_cancel(ptimer, &priv->fan->alarm);\r\nreturn 0;\r\n}\r\nint\r\nnvkm_therm_fan_ctor(struct nvkm_therm *therm)\r\n{\r\nstruct nvkm_therm_priv *priv = (void *)therm;\r\nstruct nvkm_gpio *gpio = nvkm_gpio(therm);\r\nstruct nvkm_bios *bios = nvkm_bios(therm);\r\nstruct dcb_gpio_func func;\r\nint ret;\r\nret = gpio->find(gpio, 0, DCB_GPIO_FAN, 0xff, &func);\r\nif (ret == 0) {\r\nif (func.line != 16 && func.log[0] & DCB_GPIO_LOG_DIR_IN) {\r\nnv_debug(therm, "GPIO_FAN is in input mode\n");\r\nret = -EINVAL;\r\n} else {\r\nret = nvkm_fanpwm_create(therm, &func);\r\nif (ret != 0)\r\nret = nvkm_fantog_create(therm, &func);\r\n}\r\n}\r\nif (ret != 0) {\r\nret = nvkm_fannil_create(therm);\r\nif (ret)\r\nreturn ret;\r\n}\r\nnv_info(therm, "FAN control: %s\n", priv->fan->type);\r\npriv->fan->percent = nvkm_therm_fan_get(therm);\r\nret = gpio->find(gpio, 0, DCB_GPIO_FAN_SENSE, 0xff, &priv->fan->tach);\r\nif (ret)\r\npriv->fan->tach.func = DCB_GPIO_UNUSED;\r\npriv->fan->parent = therm;\r\nnvkm_alarm_init(&priv->fan->alarm, nvkm_fan_alarm);\r\nspin_lock_init(&priv->fan->lock);\r\nnvkm_therm_fan_set_defaults(therm);\r\nnvbios_perf_fan_parse(bios, &priv->fan->perf);\r\nif (!nvbios_fan_parse(bios, &priv->fan->bios)) {\r\nnv_debug(therm, "parsing the fan table failed\n");\r\nif (nvbios_therm_fan_parse(bios, &priv->fan->bios))\r\nnv_error(therm, "parsing both fan tables failed\n");\r\n}\r\nnvkm_therm_fan_safety_checks(therm);\r\nreturn 0;\r\n}
