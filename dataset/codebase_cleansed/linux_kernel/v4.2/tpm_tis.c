static int is_itpm(struct pnp_dev *dev)\r\n{\r\nstruct acpi_device *acpi = pnp_acpi_device(dev);\r\nstruct acpi_hardware_id *id;\r\nif (!acpi)\r\nreturn 0;\r\nlist_for_each_entry(id, &acpi->pnp.ids, list) {\r\nif (!strcmp("INTC0102", id->id))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int is_itpm(struct pnp_dev *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int wait_startup(struct tpm_chip *chip, int l)\r\n{\r\nunsigned long stop = jiffies + chip->vendor.timeout_a;\r\ndo {\r\nif (ioread8(chip->vendor.iobase + TPM_ACCESS(l)) &\r\nTPM_ACCESS_VALID)\r\nreturn 0;\r\nmsleep(TPM_TIMEOUT);\r\n} while (time_before(jiffies, stop));\r\nreturn -1;\r\n}\r\nstatic int check_locality(struct tpm_chip *chip, int l)\r\n{\r\nif ((ioread8(chip->vendor.iobase + TPM_ACCESS(l)) &\r\n(TPM_ACCESS_ACTIVE_LOCALITY | TPM_ACCESS_VALID)) ==\r\n(TPM_ACCESS_ACTIVE_LOCALITY | TPM_ACCESS_VALID))\r\nreturn chip->vendor.locality = l;\r\nreturn -1;\r\n}\r\nstatic void release_locality(struct tpm_chip *chip, int l, int force)\r\n{\r\nif (force || (ioread8(chip->vendor.iobase + TPM_ACCESS(l)) &\r\n(TPM_ACCESS_REQUEST_PENDING | TPM_ACCESS_VALID)) ==\r\n(TPM_ACCESS_REQUEST_PENDING | TPM_ACCESS_VALID))\r\niowrite8(TPM_ACCESS_ACTIVE_LOCALITY,\r\nchip->vendor.iobase + TPM_ACCESS(l));\r\n}\r\nstatic int request_locality(struct tpm_chip *chip, int l)\r\n{\r\nunsigned long stop, timeout;\r\nlong rc;\r\nif (check_locality(chip, l) >= 0)\r\nreturn l;\r\niowrite8(TPM_ACCESS_REQUEST_USE,\r\nchip->vendor.iobase + TPM_ACCESS(l));\r\nstop = jiffies + chip->vendor.timeout_a;\r\nif (chip->vendor.irq) {\r\nagain:\r\ntimeout = stop - jiffies;\r\nif ((long)timeout <= 0)\r\nreturn -1;\r\nrc = wait_event_interruptible_timeout(chip->vendor.int_queue,\r\n(check_locality\r\n(chip, l) >= 0),\r\ntimeout);\r\nif (rc > 0)\r\nreturn l;\r\nif (rc == -ERESTARTSYS && freezing(current)) {\r\nclear_thread_flag(TIF_SIGPENDING);\r\ngoto again;\r\n}\r\n} else {\r\ndo {\r\nif (check_locality(chip, l) >= 0)\r\nreturn l;\r\nmsleep(TPM_TIMEOUT);\r\n}\r\nwhile (time_before(jiffies, stop));\r\n}\r\nreturn -1;\r\n}\r\nstatic u8 tpm_tis_status(struct tpm_chip *chip)\r\n{\r\nreturn ioread8(chip->vendor.iobase +\r\nTPM_STS(chip->vendor.locality));\r\n}\r\nstatic void tpm_tis_ready(struct tpm_chip *chip)\r\n{\r\niowrite8(TPM_STS_COMMAND_READY,\r\nchip->vendor.iobase + TPM_STS(chip->vendor.locality));\r\n}\r\nstatic int get_burstcount(struct tpm_chip *chip)\r\n{\r\nunsigned long stop;\r\nint burstcnt;\r\nstop = jiffies + chip->vendor.timeout_d;\r\ndo {\r\nburstcnt = ioread8(chip->vendor.iobase +\r\nTPM_STS(chip->vendor.locality) + 1);\r\nburstcnt += ioread8(chip->vendor.iobase +\r\nTPM_STS(chip->vendor.locality) +\r\n2) << 8;\r\nif (burstcnt)\r\nreturn burstcnt;\r\nmsleep(TPM_TIMEOUT);\r\n} while (time_before(jiffies, stop));\r\nreturn -EBUSY;\r\n}\r\nstatic int recv_data(struct tpm_chip *chip, u8 *buf, size_t count)\r\n{\r\nint size = 0, burstcnt;\r\nwhile (size < count &&\r\nwait_for_tpm_stat(chip,\r\nTPM_STS_DATA_AVAIL | TPM_STS_VALID,\r\nchip->vendor.timeout_c,\r\n&chip->vendor.read_queue, true)\r\n== 0) {\r\nburstcnt = get_burstcount(chip);\r\nfor (; burstcnt > 0 && size < count; burstcnt--)\r\nbuf[size++] = ioread8(chip->vendor.iobase +\r\nTPM_DATA_FIFO(chip->vendor.\r\nlocality));\r\n}\r\nreturn size;\r\n}\r\nstatic int tpm_tis_recv(struct tpm_chip *chip, u8 *buf, size_t count)\r\n{\r\nint size = 0;\r\nint expected, status;\r\nif (count < TPM_HEADER_SIZE) {\r\nsize = -EIO;\r\ngoto out;\r\n}\r\nif ((size =\r\nrecv_data(chip, buf, TPM_HEADER_SIZE)) < TPM_HEADER_SIZE) {\r\ndev_err(chip->pdev, "Unable to read header\n");\r\ngoto out;\r\n}\r\nexpected = be32_to_cpu(*(__be32 *) (buf + 2));\r\nif (expected > count) {\r\nsize = -EIO;\r\ngoto out;\r\n}\r\nif ((size +=\r\nrecv_data(chip, &buf[TPM_HEADER_SIZE],\r\nexpected - TPM_HEADER_SIZE)) < expected) {\r\ndev_err(chip->pdev, "Unable to read remainder of result\n");\r\nsize = -ETIME;\r\ngoto out;\r\n}\r\nwait_for_tpm_stat(chip, TPM_STS_VALID, chip->vendor.timeout_c,\r\n&chip->vendor.int_queue, false);\r\nstatus = tpm_tis_status(chip);\r\nif (status & TPM_STS_DATA_AVAIL) {\r\ndev_err(chip->pdev, "Error left over data\n");\r\nsize = -EIO;\r\ngoto out;\r\n}\r\nout:\r\ntpm_tis_ready(chip);\r\nrelease_locality(chip, chip->vendor.locality, 0);\r\nreturn size;\r\n}\r\nstatic int tpm_tis_send_data(struct tpm_chip *chip, u8 *buf, size_t len)\r\n{\r\nint rc, status, burstcnt;\r\nsize_t count = 0;\r\nif (request_locality(chip, 0) < 0)\r\nreturn -EBUSY;\r\nstatus = tpm_tis_status(chip);\r\nif ((status & TPM_STS_COMMAND_READY) == 0) {\r\ntpm_tis_ready(chip);\r\nif (wait_for_tpm_stat\r\n(chip, TPM_STS_COMMAND_READY, chip->vendor.timeout_b,\r\n&chip->vendor.int_queue, false) < 0) {\r\nrc = -ETIME;\r\ngoto out_err;\r\n}\r\n}\r\nwhile (count < len - 1) {\r\nburstcnt = get_burstcount(chip);\r\nfor (; burstcnt > 0 && count < len - 1; burstcnt--) {\r\niowrite8(buf[count], chip->vendor.iobase +\r\nTPM_DATA_FIFO(chip->vendor.locality));\r\ncount++;\r\n}\r\nwait_for_tpm_stat(chip, TPM_STS_VALID, chip->vendor.timeout_c,\r\n&chip->vendor.int_queue, false);\r\nstatus = tpm_tis_status(chip);\r\nif (!itpm && (status & TPM_STS_DATA_EXPECT) == 0) {\r\nrc = -EIO;\r\ngoto out_err;\r\n}\r\n}\r\niowrite8(buf[count],\r\nchip->vendor.iobase + TPM_DATA_FIFO(chip->vendor.locality));\r\nwait_for_tpm_stat(chip, TPM_STS_VALID, chip->vendor.timeout_c,\r\n&chip->vendor.int_queue, false);\r\nstatus = tpm_tis_status(chip);\r\nif ((status & TPM_STS_DATA_EXPECT) != 0) {\r\nrc = -EIO;\r\ngoto out_err;\r\n}\r\nreturn 0;\r\nout_err:\r\ntpm_tis_ready(chip);\r\nrelease_locality(chip, chip->vendor.locality, 0);\r\nreturn rc;\r\n}\r\nstatic void disable_interrupts(struct tpm_chip *chip)\r\n{\r\nu32 intmask;\r\nintmask =\r\nioread32(chip->vendor.iobase +\r\nTPM_INT_ENABLE(chip->vendor.locality));\r\nintmask &= ~TPM_GLOBAL_INT_ENABLE;\r\niowrite32(intmask,\r\nchip->vendor.iobase +\r\nTPM_INT_ENABLE(chip->vendor.locality));\r\nfree_irq(chip->vendor.irq, chip);\r\nchip->vendor.irq = 0;\r\n}\r\nstatic int tpm_tis_send_main(struct tpm_chip *chip, u8 *buf, size_t len)\r\n{\r\nint rc;\r\nu32 ordinal;\r\nunsigned long dur;\r\nrc = tpm_tis_send_data(chip, buf, len);\r\nif (rc < 0)\r\nreturn rc;\r\niowrite8(TPM_STS_GO,\r\nchip->vendor.iobase + TPM_STS(chip->vendor.locality));\r\nif (chip->vendor.irq) {\r\nordinal = be32_to_cpu(*((__be32 *) (buf + 6)));\r\nif (chip->flags & TPM_CHIP_FLAG_TPM2)\r\ndur = tpm2_calc_ordinal_duration(chip, ordinal);\r\nelse\r\ndur = tpm_calc_ordinal_duration(chip, ordinal);\r\nif (wait_for_tpm_stat\r\n(chip, TPM_STS_DATA_AVAIL | TPM_STS_VALID, dur,\r\n&chip->vendor.read_queue, false) < 0) {\r\nrc = -ETIME;\r\ngoto out_err;\r\n}\r\n}\r\nreturn len;\r\nout_err:\r\ntpm_tis_ready(chip);\r\nrelease_locality(chip, chip->vendor.locality, 0);\r\nreturn rc;\r\n}\r\nstatic int tpm_tis_send(struct tpm_chip *chip, u8 *buf, size_t len)\r\n{\r\nint rc, irq;\r\nstruct priv_data *priv = chip->vendor.priv;\r\nif (!chip->vendor.irq || priv->irq_tested)\r\nreturn tpm_tis_send_main(chip, buf, len);\r\nirq = chip->vendor.irq;\r\nchip->vendor.irq = 0;\r\nrc = tpm_tis_send_main(chip, buf, len);\r\nchip->vendor.irq = irq;\r\nif (!priv->irq_tested)\r\nmsleep(1);\r\nif (!priv->irq_tested) {\r\ndisable_interrupts(chip);\r\ndev_err(chip->pdev,\r\nFW_BUG "TPM interrupt not working, polling instead\n");\r\n}\r\npriv->irq_tested = true;\r\nreturn rc;\r\n}\r\nstatic bool tpm_tis_update_timeouts(struct tpm_chip *chip,\r\nunsigned long *timeout_cap)\r\n{\r\nint i;\r\nu32 did_vid;\r\ndid_vid = ioread32(chip->vendor.iobase + TPM_DID_VID(0));\r\nfor (i = 0; i != ARRAY_SIZE(vendor_timeout_overrides); i++) {\r\nif (vendor_timeout_overrides[i].did_vid != did_vid)\r\ncontinue;\r\nmemcpy(timeout_cap, vendor_timeout_overrides[i].timeout_us,\r\nsizeof(vendor_timeout_overrides[i].timeout_us));\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int probe_itpm(struct tpm_chip *chip)\r\n{\r\nint rc = 0;\r\nu8 cmd_getticks[] = {\r\n0x00, 0xc1, 0x00, 0x00, 0x00, 0x0a,\r\n0x00, 0x00, 0x00, 0xf1\r\n};\r\nsize_t len = sizeof(cmd_getticks);\r\nbool rem_itpm = itpm;\r\nu16 vendor = ioread16(chip->vendor.iobase + TPM_DID_VID(0));\r\nif (vendor != TPM_VID_INTEL)\r\nreturn 0;\r\nitpm = false;\r\nrc = tpm_tis_send_data(chip, cmd_getticks, len);\r\nif (rc == 0)\r\ngoto out;\r\ntpm_tis_ready(chip);\r\nrelease_locality(chip, chip->vendor.locality, 0);\r\nitpm = true;\r\nrc = tpm_tis_send_data(chip, cmd_getticks, len);\r\nif (rc == 0) {\r\ndev_info(chip->pdev, "Detected an iTPM.\n");\r\nrc = 1;\r\n} else\r\nrc = -EFAULT;\r\nout:\r\nitpm = rem_itpm;\r\ntpm_tis_ready(chip);\r\nrelease_locality(chip, chip->vendor.locality, 0);\r\nreturn rc;\r\n}\r\nstatic bool tpm_tis_req_canceled(struct tpm_chip *chip, u8 status)\r\n{\r\nswitch (chip->vendor.manufacturer_id) {\r\ncase TPM_VID_WINBOND:\r\nreturn ((status == TPM_STS_VALID) ||\r\n(status == (TPM_STS_VALID | TPM_STS_COMMAND_READY)));\r\ncase TPM_VID_STM:\r\nreturn (status == (TPM_STS_VALID | TPM_STS_COMMAND_READY));\r\ndefault:\r\nreturn (status == TPM_STS_COMMAND_READY);\r\n}\r\n}\r\nstatic irqreturn_t tis_int_probe(int irq, void *dev_id)\r\n{\r\nstruct tpm_chip *chip = dev_id;\r\nu32 interrupt;\r\ninterrupt = ioread32(chip->vendor.iobase +\r\nTPM_INT_STATUS(chip->vendor.locality));\r\nif (interrupt == 0)\r\nreturn IRQ_NONE;\r\nchip->vendor.probed_irq = irq;\r\niowrite32(interrupt,\r\nchip->vendor.iobase +\r\nTPM_INT_STATUS(chip->vendor.locality));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t tis_int_handler(int dummy, void *dev_id)\r\n{\r\nstruct tpm_chip *chip = dev_id;\r\nu32 interrupt;\r\nint i;\r\ninterrupt = ioread32(chip->vendor.iobase +\r\nTPM_INT_STATUS(chip->vendor.locality));\r\nif (interrupt == 0)\r\nreturn IRQ_NONE;\r\n((struct priv_data *)chip->vendor.priv)->irq_tested = true;\r\nif (interrupt & TPM_INTF_DATA_AVAIL_INT)\r\nwake_up_interruptible(&chip->vendor.read_queue);\r\nif (interrupt & TPM_INTF_LOCALITY_CHANGE_INT)\r\nfor (i = 0; i < 5; i++)\r\nif (check_locality(chip, i) >= 0)\r\nbreak;\r\nif (interrupt &\r\n(TPM_INTF_LOCALITY_CHANGE_INT | TPM_INTF_STS_VALID_INT |\r\nTPM_INTF_CMD_READY_INT))\r\nwake_up_interruptible(&chip->vendor.int_queue);\r\niowrite32(interrupt,\r\nchip->vendor.iobase +\r\nTPM_INT_STATUS(chip->vendor.locality));\r\nioread32(chip->vendor.iobase + TPM_INT_STATUS(chip->vendor.locality));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void tpm_tis_remove(struct tpm_chip *chip)\r\n{\r\nif (chip->flags & TPM_CHIP_FLAG_TPM2)\r\ntpm2_shutdown(chip, TPM2_SU_CLEAR);\r\niowrite32(~TPM_GLOBAL_INT_ENABLE &\r\nioread32(chip->vendor.iobase +\r\nTPM_INT_ENABLE(chip->vendor.\r\nlocality)),\r\nchip->vendor.iobase +\r\nTPM_INT_ENABLE(chip->vendor.locality));\r\nrelease_locality(chip, chip->vendor.locality, 1);\r\n}\r\nstatic int tpm_tis_init(struct device *dev, acpi_handle acpi_dev_handle,\r\nresource_size_t start, resource_size_t len,\r\nunsigned int irq)\r\n{\r\nu32 vendor, intfcaps, intmask;\r\nint rc, i, irq_s, irq_e, probe;\r\nstruct tpm_chip *chip;\r\nstruct priv_data *priv;\r\npriv = devm_kzalloc(dev, sizeof(struct priv_data), GFP_KERNEL);\r\nif (priv == NULL)\r\nreturn -ENOMEM;\r\nchip = tpmm_chip_alloc(dev, &tpm_tis);\r\nif (IS_ERR(chip))\r\nreturn PTR_ERR(chip);\r\nchip->vendor.priv = priv;\r\n#ifdef CONFIG_ACPI\r\nchip->acpi_dev_handle = acpi_dev_handle;\r\n#endif\r\nchip->vendor.iobase = devm_ioremap(dev, start, len);\r\nif (!chip->vendor.iobase)\r\nreturn -EIO;\r\nchip->vendor.timeout_a = TIS_TIMEOUT_A_MAX;\r\nchip->vendor.timeout_b = TIS_TIMEOUT_B_MAX;\r\nchip->vendor.timeout_c = TIS_TIMEOUT_C_MAX;\r\nchip->vendor.timeout_d = TIS_TIMEOUT_D_MAX;\r\nif (wait_startup(chip, 0) != 0) {\r\nrc = -ENODEV;\r\ngoto out_err;\r\n}\r\nif (request_locality(chip, 0) != 0) {\r\nrc = -ENODEV;\r\ngoto out_err;\r\n}\r\nrc = tpm2_probe(chip);\r\nif (rc)\r\ngoto out_err;\r\nvendor = ioread32(chip->vendor.iobase + TPM_DID_VID(0));\r\nchip->vendor.manufacturer_id = vendor;\r\ndev_info(dev, "%s TPM (device-id 0x%X, rev-id %d)\n",\r\n(chip->flags & TPM_CHIP_FLAG_TPM2) ? "2.0" : "1.2",\r\nvendor >> 16, ioread8(chip->vendor.iobase + TPM_RID(0)));\r\nif (!itpm) {\r\nprobe = probe_itpm(chip);\r\nif (probe < 0) {\r\nrc = -ENODEV;\r\ngoto out_err;\r\n}\r\nitpm = !!probe;\r\n}\r\nif (itpm)\r\ndev_info(dev, "Intel iTPM workaround enabled\n");\r\nintfcaps =\r\nioread32(chip->vendor.iobase +\r\nTPM_INTF_CAPS(chip->vendor.locality));\r\ndev_dbg(dev, "TPM interface capabilities (0x%x):\n",\r\nintfcaps);\r\nif (intfcaps & TPM_INTF_BURST_COUNT_STATIC)\r\ndev_dbg(dev, "\tBurst Count Static\n");\r\nif (intfcaps & TPM_INTF_CMD_READY_INT)\r\ndev_dbg(dev, "\tCommand Ready Int Support\n");\r\nif (intfcaps & TPM_INTF_INT_EDGE_FALLING)\r\ndev_dbg(dev, "\tInterrupt Edge Falling\n");\r\nif (intfcaps & TPM_INTF_INT_EDGE_RISING)\r\ndev_dbg(dev, "\tInterrupt Edge Rising\n");\r\nif (intfcaps & TPM_INTF_INT_LEVEL_LOW)\r\ndev_dbg(dev, "\tInterrupt Level Low\n");\r\nif (intfcaps & TPM_INTF_INT_LEVEL_HIGH)\r\ndev_dbg(dev, "\tInterrupt Level High\n");\r\nif (intfcaps & TPM_INTF_LOCALITY_CHANGE_INT)\r\ndev_dbg(dev, "\tLocality Change Int Support\n");\r\nif (intfcaps & TPM_INTF_STS_VALID_INT)\r\ndev_dbg(dev, "\tSts Valid Int Support\n");\r\nif (intfcaps & TPM_INTF_DATA_AVAIL_INT)\r\ndev_dbg(dev, "\tData Avail Int Support\n");\r\ninit_waitqueue_head(&chip->vendor.read_queue);\r\ninit_waitqueue_head(&chip->vendor.int_queue);\r\nintmask =\r\nioread32(chip->vendor.iobase +\r\nTPM_INT_ENABLE(chip->vendor.locality));\r\nintmask |= TPM_INTF_CMD_READY_INT\r\n| TPM_INTF_LOCALITY_CHANGE_INT | TPM_INTF_DATA_AVAIL_INT\r\n| TPM_INTF_STS_VALID_INT;\r\niowrite32(intmask,\r\nchip->vendor.iobase +\r\nTPM_INT_ENABLE(chip->vendor.locality));\r\nif (interrupts)\r\nchip->vendor.irq = irq;\r\nif (interrupts && !chip->vendor.irq) {\r\nirq_s =\r\nioread8(chip->vendor.iobase +\r\nTPM_INT_VECTOR(chip->vendor.locality));\r\nif (irq_s) {\r\nirq_e = irq_s;\r\n} else {\r\nirq_s = 3;\r\nirq_e = 15;\r\n}\r\nfor (i = irq_s; i <= irq_e && chip->vendor.irq == 0; i++) {\r\niowrite8(i, chip->vendor.iobase +\r\nTPM_INT_VECTOR(chip->vendor.locality));\r\nif (devm_request_irq\r\n(dev, i, tis_int_probe, IRQF_SHARED,\r\nchip->devname, chip) != 0) {\r\ndev_info(chip->pdev,\r\n"Unable to request irq: %d for probe\n",\r\ni);\r\ncontinue;\r\n}\r\niowrite32(ioread32\r\n(chip->vendor.iobase +\r\nTPM_INT_STATUS(chip->vendor.locality)),\r\nchip->vendor.iobase +\r\nTPM_INT_STATUS(chip->vendor.locality));\r\niowrite32(intmask | TPM_GLOBAL_INT_ENABLE,\r\nchip->vendor.iobase +\r\nTPM_INT_ENABLE(chip->vendor.locality));\r\nchip->vendor.probed_irq = 0;\r\nif (chip->flags & TPM_CHIP_FLAG_TPM2)\r\ntpm2_gen_interrupt(chip);\r\nelse\r\ntpm_gen_interrupt(chip);\r\nchip->vendor.irq = chip->vendor.probed_irq;\r\niowrite32(ioread32\r\n(chip->vendor.iobase +\r\nTPM_INT_STATUS(chip->vendor.locality)),\r\nchip->vendor.iobase +\r\nTPM_INT_STATUS(chip->vendor.locality));\r\niowrite32(intmask,\r\nchip->vendor.iobase +\r\nTPM_INT_ENABLE(chip->vendor.locality));\r\n}\r\n}\r\nif (chip->vendor.irq) {\r\niowrite8(chip->vendor.irq,\r\nchip->vendor.iobase +\r\nTPM_INT_VECTOR(chip->vendor.locality));\r\nif (devm_request_irq\r\n(dev, chip->vendor.irq, tis_int_handler, IRQF_SHARED,\r\nchip->devname, chip) != 0) {\r\ndev_info(chip->pdev,\r\n"Unable to request irq: %d for use\n",\r\nchip->vendor.irq);\r\nchip->vendor.irq = 0;\r\n} else {\r\niowrite32(ioread32\r\n(chip->vendor.iobase +\r\nTPM_INT_STATUS(chip->vendor.locality)),\r\nchip->vendor.iobase +\r\nTPM_INT_STATUS(chip->vendor.locality));\r\niowrite32(intmask | TPM_GLOBAL_INT_ENABLE,\r\nchip->vendor.iobase +\r\nTPM_INT_ENABLE(chip->vendor.locality));\r\n}\r\n}\r\nif (chip->flags & TPM_CHIP_FLAG_TPM2) {\r\nchip->vendor.timeout_a = msecs_to_jiffies(TPM2_TIMEOUT_A);\r\nchip->vendor.timeout_b = msecs_to_jiffies(TPM2_TIMEOUT_B);\r\nchip->vendor.timeout_c = msecs_to_jiffies(TPM2_TIMEOUT_C);\r\nchip->vendor.timeout_d = msecs_to_jiffies(TPM2_TIMEOUT_D);\r\nchip->vendor.duration[TPM_SHORT] =\r\nmsecs_to_jiffies(TPM2_DURATION_SHORT);\r\nchip->vendor.duration[TPM_MEDIUM] =\r\nmsecs_to_jiffies(TPM2_DURATION_MEDIUM);\r\nchip->vendor.duration[TPM_LONG] =\r\nmsecs_to_jiffies(TPM2_DURATION_LONG);\r\nrc = tpm2_do_selftest(chip);\r\nif (rc == TPM2_RC_INITIALIZE) {\r\ndev_warn(dev, "Firmware has not started TPM\n");\r\nrc = tpm2_startup(chip, TPM2_SU_CLEAR);\r\nif (!rc)\r\nrc = tpm2_do_selftest(chip);\r\n}\r\nif (rc) {\r\ndev_err(dev, "TPM self test failed\n");\r\nif (rc > 0)\r\nrc = -ENODEV;\r\ngoto out_err;\r\n}\r\n} else {\r\nif (tpm_get_timeouts(chip)) {\r\ndev_err(dev, "Could not get TPM timeouts and durations\n");\r\nrc = -ENODEV;\r\ngoto out_err;\r\n}\r\nif (tpm_do_selftest(chip)) {\r\ndev_err(dev, "TPM self test failed\n");\r\nrc = -ENODEV;\r\ngoto out_err;\r\n}\r\n}\r\nreturn tpm_chip_register(chip);\r\nout_err:\r\ntpm_tis_remove(chip);\r\nreturn rc;\r\n}\r\nstatic void tpm_tis_reenable_interrupts(struct tpm_chip *chip)\r\n{\r\nu32 intmask;\r\niowrite8(chip->vendor.irq, chip->vendor.iobase +\r\nTPM_INT_VECTOR(chip->vendor.locality));\r\nintmask =\r\nioread32(chip->vendor.iobase +\r\nTPM_INT_ENABLE(chip->vendor.locality));\r\nintmask |= TPM_INTF_CMD_READY_INT\r\n| TPM_INTF_LOCALITY_CHANGE_INT | TPM_INTF_DATA_AVAIL_INT\r\n| TPM_INTF_STS_VALID_INT | TPM_GLOBAL_INT_ENABLE;\r\niowrite32(intmask,\r\nchip->vendor.iobase + TPM_INT_ENABLE(chip->vendor.locality));\r\n}\r\nstatic int tpm_tis_resume(struct device *dev)\r\n{\r\nstruct tpm_chip *chip = dev_get_drvdata(dev);\r\nint ret;\r\nif (chip->vendor.irq)\r\ntpm_tis_reenable_interrupts(chip);\r\nret = tpm_pm_resume(dev);\r\nif (ret)\r\nreturn ret;\r\nif (!(chip->flags & TPM_CHIP_FLAG_TPM2))\r\ntpm_do_selftest(chip);\r\nreturn 0;\r\n}\r\nstatic int tpm_tis_pnp_init(struct pnp_dev *pnp_dev,\r\nconst struct pnp_device_id *pnp_id)\r\n{\r\nresource_size_t start, len;\r\nunsigned int irq = 0;\r\nacpi_handle acpi_dev_handle = NULL;\r\nstart = pnp_mem_start(pnp_dev, 0);\r\nlen = pnp_mem_len(pnp_dev, 0);\r\nif (pnp_irq_valid(pnp_dev, 0))\r\nirq = pnp_irq(pnp_dev, 0);\r\nelse\r\ninterrupts = false;\r\nif (is_itpm(pnp_dev))\r\nitpm = true;\r\n#ifdef CONFIG_ACPI\r\nif (pnp_acpi_device(pnp_dev))\r\nacpi_dev_handle = pnp_acpi_device(pnp_dev)->handle;\r\n#endif\r\nreturn tpm_tis_init(&pnp_dev->dev, acpi_dev_handle, start, len, irq);\r\n}\r\nstatic void tpm_tis_pnp_remove(struct pnp_dev *dev)\r\n{\r\nstruct tpm_chip *chip = pnp_get_drvdata(dev);\r\ntpm_chip_unregister(chip);\r\ntpm_tis_remove(chip);\r\n}\r\nstatic int __init init_tis(void)\r\n{\r\nint rc;\r\n#ifdef CONFIG_PNP\r\nif (!force)\r\nreturn pnp_register_driver(&tis_pnp_driver);\r\n#endif\r\nrc = platform_driver_register(&tis_drv);\r\nif (rc < 0)\r\nreturn rc;\r\npdev = platform_device_register_simple("tpm_tis", -1, NULL, 0);\r\nif (IS_ERR(pdev)) {\r\nrc = PTR_ERR(pdev);\r\ngoto err_dev;\r\n}\r\nrc = tpm_tis_init(&pdev->dev, NULL, TIS_MEM_BASE, TIS_MEM_LEN, 0);\r\nif (rc)\r\ngoto err_init;\r\nreturn 0;\r\nerr_init:\r\nplatform_device_unregister(pdev);\r\nerr_dev:\r\nplatform_driver_unregister(&tis_drv);\r\nreturn rc;\r\n}\r\nstatic void __exit cleanup_tis(void)\r\n{\r\nstruct tpm_chip *chip;\r\n#ifdef CONFIG_PNP\r\nif (!force) {\r\npnp_unregister_driver(&tis_pnp_driver);\r\nreturn;\r\n}\r\n#endif\r\nchip = dev_get_drvdata(&pdev->dev);\r\ntpm_chip_unregister(chip);\r\ntpm_tis_remove(chip);\r\nplatform_device_unregister(pdev);\r\nplatform_driver_unregister(&tis_drv);\r\n}
