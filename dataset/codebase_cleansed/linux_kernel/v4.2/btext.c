static int __init btext_initialize(phandle node)\r\n{\r\nunsigned int width, height, depth, pitch;\r\nunsigned long address = 0;\r\nu32 prop;\r\nif (prom_getproperty(node, "width", (char *)&width, 4) < 0)\r\nreturn -EINVAL;\r\nif (prom_getproperty(node, "height", (char *)&height, 4) < 0)\r\nreturn -EINVAL;\r\nif (prom_getproperty(node, "depth", (char *)&depth, 4) < 0)\r\nreturn -EINVAL;\r\npitch = width * ((depth + 7) / 8);\r\nif (prom_getproperty(node, "linebytes", (char *)&prop, 4) >= 0 &&\r\nprop != 0xffffffffu)\r\npitch = prop;\r\nif (pitch == 1)\r\npitch = 0x1000;\r\nif (prom_getproperty(node, "address", (char *)&prop, 4) >= 0)\r\naddress = prop;\r\nif (address == 0)\r\nreturn -EINVAL;\r\ng_loc_X = 0;\r\ng_loc_Y = 0;\r\ng_max_loc_X = width / 8;\r\ng_max_loc_Y = height / 16;\r\ndispDeviceBase = (unsigned char *)address;\r\ndispDeviceRowBytes = pitch;\r\ndispDeviceDepth = depth == 15 ? 16 : depth;\r\ndispDeviceRect[0] = dispDeviceRect[1] = 0;\r\ndispDeviceRect[2] = width;\r\ndispDeviceRect[3] = height;\r\nreturn 0;\r\n}\r\nstatic unsigned char * calc_base(int x, int y)\r\n{\r\nunsigned char *base = dispDeviceBase;\r\nbase += (x + dispDeviceRect[0]) * (dispDeviceDepth >> 3);\r\nbase += (y + dispDeviceRect[1]) * dispDeviceRowBytes;\r\nreturn base;\r\n}\r\nstatic void btext_clearscreen(void)\r\n{\r\nunsigned int *base = (unsigned int *)calc_base(0, 0);\r\nunsigned long width = ((dispDeviceRect[2] - dispDeviceRect[0]) *\r\n(dispDeviceDepth >> 3)) >> 2;\r\nint i,j;\r\nfor (i=0; i<(dispDeviceRect[3] - dispDeviceRect[1]); i++)\r\n{\r\nunsigned int *ptr = base;\r\nfor(j=width; j; --j)\r\n*(ptr++) = 0;\r\nbase += (dispDeviceRowBytes >> 2);\r\n}\r\n}\r\nstatic void scrollscreen(void)\r\n{\r\nunsigned int *src = (unsigned int *)calc_base(0,16);\r\nunsigned int *dst = (unsigned int *)calc_base(0,0);\r\nunsigned long width = ((dispDeviceRect[2] - dispDeviceRect[0]) *\r\n(dispDeviceDepth >> 3)) >> 2;\r\nint i,j;\r\nfor (i=0; i<(dispDeviceRect[3] - dispDeviceRect[1] - 16); i++)\r\n{\r\nunsigned int *src_ptr = src;\r\nunsigned int *dst_ptr = dst;\r\nfor(j=width; j; --j)\r\n*(dst_ptr++) = *(src_ptr++);\r\nsrc += (dispDeviceRowBytes >> 2);\r\ndst += (dispDeviceRowBytes >> 2);\r\n}\r\nfor (i=0; i<16; i++)\r\n{\r\nunsigned int *dst_ptr = dst;\r\nfor(j=width; j; --j)\r\n*(dst_ptr++) = 0;\r\ndst += (dispDeviceRowBytes >> 2);\r\n}\r\n}\r\nstatic void btext_drawchar(char c)\r\n{\r\nint cline = 0;\r\n#ifdef NO_SCROLL\r\nint x;\r\n#endif\r\nswitch (c) {\r\ncase '\b':\r\nif (g_loc_X > 0)\r\n--g_loc_X;\r\nbreak;\r\ncase '\t':\r\ng_loc_X = (g_loc_X & -8) + 8;\r\nbreak;\r\ncase '\r':\r\ng_loc_X = 0;\r\nbreak;\r\ncase '\n':\r\ng_loc_X = 0;\r\ng_loc_Y++;\r\ncline = 1;\r\nbreak;\r\ndefault:\r\ndraw_byte(c, g_loc_X++, g_loc_Y);\r\n}\r\nif (g_loc_X >= g_max_loc_X) {\r\ng_loc_X = 0;\r\ng_loc_Y++;\r\ncline = 1;\r\n}\r\n#ifndef NO_SCROLL\r\nwhile (g_loc_Y >= g_max_loc_Y) {\r\nscrollscreen();\r\ng_loc_Y--;\r\n}\r\n#else\r\nif (g_loc_Y >= g_max_loc_Y)\r\ng_loc_Y = 0;\r\nif (cline) {\r\nfor (x = 0; x < g_max_loc_X; ++x)\r\ndraw_byte(' ', x, g_loc_Y);\r\n}\r\n#endif\r\n}\r\nstatic void btext_drawtext(const char *c, unsigned int len)\r\n{\r\nwhile (len--)\r\nbtext_drawchar(*c++);\r\n}\r\nstatic void draw_byte(unsigned char c, long locX, long locY)\r\n{\r\nunsigned char *base = calc_base(locX << 3, locY << 4);\r\nunsigned char *font = &vga_font[((unsigned int)c) * 16];\r\nint rb = dispDeviceRowBytes;\r\nswitch(dispDeviceDepth) {\r\ncase 24:\r\ncase 32:\r\ndraw_byte_32(font, (unsigned int *)base, rb);\r\nbreak;\r\ncase 15:\r\ncase 16:\r\ndraw_byte_16(font, (unsigned int *)base, rb);\r\nbreak;\r\ncase 8:\r\ndraw_byte_8(font, (unsigned int *)base, rb);\r\nbreak;\r\n}\r\n}\r\nstatic void draw_byte_32(unsigned char *font, unsigned int *base, int rb)\r\n{\r\nint l, bits;\r\nint fg = 0xFFFFFFFFUL;\r\nint bg = 0x00000000UL;\r\nfor (l = 0; l < 16; ++l)\r\n{\r\nbits = *font++;\r\nbase[0] = (-(bits >> 7) & fg) ^ bg;\r\nbase[1] = (-((bits >> 6) & 1) & fg) ^ bg;\r\nbase[2] = (-((bits >> 5) & 1) & fg) ^ bg;\r\nbase[3] = (-((bits >> 4) & 1) & fg) ^ bg;\r\nbase[4] = (-((bits >> 3) & 1) & fg) ^ bg;\r\nbase[5] = (-((bits >> 2) & 1) & fg) ^ bg;\r\nbase[6] = (-((bits >> 1) & 1) & fg) ^ bg;\r\nbase[7] = (-(bits & 1) & fg) ^ bg;\r\nbase = (unsigned int *) ((char *)base + rb);\r\n}\r\n}\r\nstatic void draw_byte_16(unsigned char *font, unsigned int *base, int rb)\r\n{\r\nint l, bits;\r\nint fg = 0xFFFFFFFFUL;\r\nint bg = 0x00000000UL;\r\nunsigned int *eb = (int *)expand_bits_16;\r\nfor (l = 0; l < 16; ++l)\r\n{\r\nbits = *font++;\r\nbase[0] = (eb[bits >> 6] & fg) ^ bg;\r\nbase[1] = (eb[(bits >> 4) & 3] & fg) ^ bg;\r\nbase[2] = (eb[(bits >> 2) & 3] & fg) ^ bg;\r\nbase[3] = (eb[bits & 3] & fg) ^ bg;\r\nbase = (unsigned int *) ((char *)base + rb);\r\n}\r\n}\r\nstatic void draw_byte_8(unsigned char *font, unsigned int *base, int rb)\r\n{\r\nint l, bits;\r\nint fg = 0x0F0F0F0FUL;\r\nint bg = 0x00000000UL;\r\nunsigned int *eb = (int *)expand_bits_8;\r\nfor (l = 0; l < 16; ++l)\r\n{\r\nbits = *font++;\r\nbase[0] = (eb[bits >> 4] & fg) ^ bg;\r\nbase[1] = (eb[bits & 0xf] & fg) ^ bg;\r\nbase = (unsigned int *) ((char *)base + rb);\r\n}\r\n}\r\nstatic void btext_console_write(struct console *con, const char *s,\r\nunsigned int n)\r\n{\r\nbtext_drawtext(s, n);\r\n}\r\nint __init btext_find_display(void)\r\n{\r\nphandle node;\r\nchar type[32];\r\nint ret;\r\nnode = prom_inst2pkg(prom_stdout);\r\nif (prom_getproperty(node, "device_type", type, 32) < 0)\r\nreturn -ENODEV;\r\nif (strcmp(type, "display"))\r\nreturn -ENODEV;\r\nret = btext_initialize(node);\r\nif (!ret) {\r\nbtext_clearscreen();\r\nregister_console(&btext_console);\r\n}\r\nreturn ret;\r\n}
