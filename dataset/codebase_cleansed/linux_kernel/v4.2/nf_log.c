static struct nf_logger *__find_logger(int pf, const char *str_logger)\r\n{\r\nstruct nf_logger *log;\r\nint i;\r\nfor (i = 0; i < NF_LOG_TYPE_MAX; i++) {\r\nif (loggers[pf][i] == NULL)\r\ncontinue;\r\nlog = nft_log_dereference(loggers[pf][i]);\r\nif (!strncasecmp(str_logger, log->name, strlen(log->name)))\r\nreturn log;\r\n}\r\nreturn NULL;\r\n}\r\nvoid nf_log_set(struct net *net, u_int8_t pf, const struct nf_logger *logger)\r\n{\r\nconst struct nf_logger *log;\r\nif (pf == NFPROTO_UNSPEC)\r\nreturn;\r\nmutex_lock(&nf_log_mutex);\r\nlog = nft_log_dereference(net->nf.nf_loggers[pf]);\r\nif (log == NULL)\r\nrcu_assign_pointer(net->nf.nf_loggers[pf], logger);\r\nmutex_unlock(&nf_log_mutex);\r\n}\r\nvoid nf_log_unset(struct net *net, const struct nf_logger *logger)\r\n{\r\nint i;\r\nconst struct nf_logger *log;\r\nmutex_lock(&nf_log_mutex);\r\nfor (i = 0; i < NFPROTO_NUMPROTO; i++) {\r\nlog = nft_log_dereference(net->nf.nf_loggers[i]);\r\nif (log == logger)\r\nRCU_INIT_POINTER(net->nf.nf_loggers[i], NULL);\r\n}\r\nmutex_unlock(&nf_log_mutex);\r\nsynchronize_rcu();\r\n}\r\nint nf_log_register(u_int8_t pf, struct nf_logger *logger)\r\n{\r\nint i;\r\nint ret = 0;\r\nif (pf >= ARRAY_SIZE(init_net.nf.nf_loggers))\r\nreturn -EINVAL;\r\nmutex_lock(&nf_log_mutex);\r\nif (pf == NFPROTO_UNSPEC) {\r\nfor (i = NFPROTO_UNSPEC; i < NFPROTO_NUMPROTO; i++) {\r\nif (rcu_access_pointer(loggers[i][logger->type])) {\r\nret = -EEXIST;\r\ngoto unlock;\r\n}\r\n}\r\nfor (i = NFPROTO_UNSPEC; i < NFPROTO_NUMPROTO; i++)\r\nrcu_assign_pointer(loggers[i][logger->type], logger);\r\n} else {\r\nif (rcu_access_pointer(loggers[pf][logger->type])) {\r\nret = -EEXIST;\r\ngoto unlock;\r\n}\r\nrcu_assign_pointer(loggers[pf][logger->type], logger);\r\n}\r\nunlock:\r\nmutex_unlock(&nf_log_mutex);\r\nreturn ret;\r\n}\r\nvoid nf_log_unregister(struct nf_logger *logger)\r\n{\r\nint i;\r\nmutex_lock(&nf_log_mutex);\r\nfor (i = 0; i < NFPROTO_NUMPROTO; i++)\r\nRCU_INIT_POINTER(loggers[i][logger->type], NULL);\r\nmutex_unlock(&nf_log_mutex);\r\n}\r\nint nf_log_bind_pf(struct net *net, u_int8_t pf,\r\nconst struct nf_logger *logger)\r\n{\r\nif (pf >= ARRAY_SIZE(net->nf.nf_loggers))\r\nreturn -EINVAL;\r\nmutex_lock(&nf_log_mutex);\r\nif (__find_logger(pf, logger->name) == NULL) {\r\nmutex_unlock(&nf_log_mutex);\r\nreturn -ENOENT;\r\n}\r\nrcu_assign_pointer(net->nf.nf_loggers[pf], logger);\r\nmutex_unlock(&nf_log_mutex);\r\nreturn 0;\r\n}\r\nvoid nf_log_unbind_pf(struct net *net, u_int8_t pf)\r\n{\r\nif (pf >= ARRAY_SIZE(net->nf.nf_loggers))\r\nreturn;\r\nmutex_lock(&nf_log_mutex);\r\nRCU_INIT_POINTER(net->nf.nf_loggers[pf], NULL);\r\nmutex_unlock(&nf_log_mutex);\r\n}\r\nvoid nf_logger_request_module(int pf, enum nf_log_type type)\r\n{\r\nif (loggers[pf][type] == NULL)\r\nrequest_module("nf-logger-%u-%u", pf, type);\r\n}\r\nint nf_logger_find_get(int pf, enum nf_log_type type)\r\n{\r\nstruct nf_logger *logger;\r\nint ret = -ENOENT;\r\nif (rcu_access_pointer(loggers[pf][type]) == NULL)\r\nrequest_module("nf-logger-%u-%u", pf, type);\r\nrcu_read_lock();\r\nlogger = rcu_dereference(loggers[pf][type]);\r\nif (logger == NULL)\r\ngoto out;\r\nif (logger && try_module_get(logger->me))\r\nret = 0;\r\nout:\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nvoid nf_logger_put(int pf, enum nf_log_type type)\r\n{\r\nstruct nf_logger *logger;\r\nBUG_ON(loggers[pf][type] == NULL);\r\nrcu_read_lock();\r\nlogger = rcu_dereference(loggers[pf][type]);\r\nmodule_put(logger->me);\r\nrcu_read_unlock();\r\n}\r\nvoid nf_log_packet(struct net *net,\r\nu_int8_t pf,\r\nunsigned int hooknum,\r\nconst struct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nconst struct nf_loginfo *loginfo,\r\nconst char *fmt, ...)\r\n{\r\nva_list args;\r\nchar prefix[NF_LOG_PREFIXLEN];\r\nconst struct nf_logger *logger;\r\nrcu_read_lock();\r\nif (loginfo != NULL)\r\nlogger = rcu_dereference(loggers[pf][loginfo->type]);\r\nelse\r\nlogger = rcu_dereference(net->nf.nf_loggers[pf]);\r\nif (logger) {\r\nva_start(args, fmt);\r\nvsnprintf(prefix, sizeof(prefix), fmt, args);\r\nva_end(args);\r\nlogger->logfn(net, pf, hooknum, skb, in, out, loginfo, prefix);\r\n}\r\nrcu_read_unlock();\r\n}\r\nvoid nf_log_trace(struct net *net,\r\nu_int8_t pf,\r\nunsigned int hooknum,\r\nconst struct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nconst struct nf_loginfo *loginfo, const char *fmt, ...)\r\n{\r\nva_list args;\r\nchar prefix[NF_LOG_PREFIXLEN];\r\nconst struct nf_logger *logger;\r\nrcu_read_lock();\r\nlogger = rcu_dereference(net->nf.nf_loggers[pf]);\r\nif (logger) {\r\nva_start(args, fmt);\r\nvsnprintf(prefix, sizeof(prefix), fmt, args);\r\nva_end(args);\r\nlogger->logfn(net, pf, hooknum, skb, in, out, loginfo, prefix);\r\n}\r\nrcu_read_unlock();\r\n}\r\nint nf_log_buf_add(struct nf_log_buf *m, const char *f, ...)\r\n{\r\nva_list args;\r\nint len;\r\nif (likely(m->count < S_SIZE)) {\r\nva_start(args, f);\r\nlen = vsnprintf(m->buf + m->count, S_SIZE - m->count, f, args);\r\nva_end(args);\r\nif (likely(m->count + len < S_SIZE)) {\r\nm->count += len;\r\nreturn 0;\r\n}\r\n}\r\nm->count = S_SIZE;\r\nprintk_once(KERN_ERR KBUILD_MODNAME " please increase S_SIZE\n");\r\nreturn -1;\r\n}\r\nstruct nf_log_buf *nf_log_buf_open(void)\r\n{\r\nstruct nf_log_buf *m = kmalloc(sizeof(*m), GFP_ATOMIC);\r\nif (unlikely(!m)) {\r\nlocal_bh_disable();\r\ndo {\r\nm = xchg(&emergency_ptr, NULL);\r\n} while (!m);\r\n}\r\nm->count = 0;\r\nreturn m;\r\n}\r\nvoid nf_log_buf_close(struct nf_log_buf *m)\r\n{\r\nm->buf[m->count] = 0;\r\nprintk("%s\n", m->buf);\r\nif (likely(m != &emergency))\r\nkfree(m);\r\nelse {\r\nemergency_ptr = m;\r\nlocal_bh_enable();\r\n}\r\n}\r\nstatic void *seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nstruct net *net = seq_file_net(seq);\r\nmutex_lock(&nf_log_mutex);\r\nif (*pos >= ARRAY_SIZE(net->nf.nf_loggers))\r\nreturn NULL;\r\nreturn pos;\r\n}\r\nstatic void *seq_next(struct seq_file *s, void *v, loff_t *pos)\r\n{\r\nstruct net *net = seq_file_net(s);\r\n(*pos)++;\r\nif (*pos >= ARRAY_SIZE(net->nf.nf_loggers))\r\nreturn NULL;\r\nreturn pos;\r\n}\r\nstatic void seq_stop(struct seq_file *s, void *v)\r\n{\r\nmutex_unlock(&nf_log_mutex);\r\n}\r\nstatic int seq_show(struct seq_file *s, void *v)\r\n{\r\nloff_t *pos = v;\r\nconst struct nf_logger *logger;\r\nint i;\r\nstruct net *net = seq_file_net(s);\r\nlogger = nft_log_dereference(net->nf.nf_loggers[*pos]);\r\nif (!logger)\r\nseq_printf(s, "%2lld NONE (", *pos);\r\nelse\r\nseq_printf(s, "%2lld %s (", *pos, logger->name);\r\nif (seq_has_overflowed(s))\r\nreturn -ENOSPC;\r\nfor (i = 0; i < NF_LOG_TYPE_MAX; i++) {\r\nif (loggers[*pos][i] == NULL)\r\ncontinue;\r\nlogger = nft_log_dereference(loggers[*pos][i]);\r\nseq_printf(s, "%s", logger->name);\r\nif (i == 0 && loggers[*pos][i + 1] != NULL)\r\nseq_printf(s, ",");\r\nif (seq_has_overflowed(s))\r\nreturn -ENOSPC;\r\n}\r\nseq_printf(s, ")\n");\r\nif (seq_has_overflowed(s))\r\nreturn -ENOSPC;\r\nreturn 0;\r\n}\r\nstatic int nflog_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &nflog_seq_ops,\r\nsizeof(struct seq_net_private));\r\n}\r\nstatic int nf_log_proc_dostring(struct ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nconst struct nf_logger *logger;\r\nchar buf[NFLOGGER_NAME_LEN];\r\nsize_t size = *lenp;\r\nint r = 0;\r\nint tindex = (unsigned long)table->extra1;\r\nstruct net *net = current->nsproxy->net_ns;\r\nif (write) {\r\nif (size > sizeof(buf))\r\nsize = sizeof(buf);\r\nif (copy_from_user(buf, buffer, size))\r\nreturn -EFAULT;\r\nif (!strcmp(buf, "NONE")) {\r\nnf_log_unbind_pf(net, tindex);\r\nreturn 0;\r\n}\r\nmutex_lock(&nf_log_mutex);\r\nlogger = __find_logger(tindex, buf);\r\nif (logger == NULL) {\r\nmutex_unlock(&nf_log_mutex);\r\nreturn -ENOENT;\r\n}\r\nrcu_assign_pointer(net->nf.nf_loggers[tindex], logger);\r\nmutex_unlock(&nf_log_mutex);\r\n} else {\r\nmutex_lock(&nf_log_mutex);\r\nlogger = nft_log_dereference(net->nf.nf_loggers[tindex]);\r\nif (!logger)\r\ntable->data = "NONE";\r\nelse\r\ntable->data = logger->name;\r\nr = proc_dostring(table, write, buffer, lenp, ppos);\r\nmutex_unlock(&nf_log_mutex);\r\n}\r\nreturn r;\r\n}\r\nstatic int netfilter_log_sysctl_init(struct net *net)\r\n{\r\nint i;\r\nstruct ctl_table *table;\r\ntable = nf_log_sysctl_table;\r\nif (!net_eq(net, &init_net)) {\r\ntable = kmemdup(nf_log_sysctl_table,\r\nsizeof(nf_log_sysctl_table),\r\nGFP_KERNEL);\r\nif (!table)\r\ngoto err_alloc;\r\n} else {\r\nfor (i = NFPROTO_UNSPEC; i < NFPROTO_NUMPROTO; i++) {\r\nsnprintf(nf_log_sysctl_fnames[i],\r\n3, "%d", i);\r\nnf_log_sysctl_table[i].procname =\r\nnf_log_sysctl_fnames[i];\r\nnf_log_sysctl_table[i].data = NULL;\r\nnf_log_sysctl_table[i].maxlen = NFLOGGER_NAME_LEN;\r\nnf_log_sysctl_table[i].mode = 0644;\r\nnf_log_sysctl_table[i].proc_handler =\r\nnf_log_proc_dostring;\r\nnf_log_sysctl_table[i].extra1 =\r\n(void *)(unsigned long) i;\r\n}\r\n}\r\nnet->nf.nf_log_dir_header = register_net_sysctl(net,\r\n"net/netfilter/nf_log",\r\ntable);\r\nif (!net->nf.nf_log_dir_header)\r\ngoto err_reg;\r\nreturn 0;\r\nerr_reg:\r\nif (!net_eq(net, &init_net))\r\nkfree(table);\r\nerr_alloc:\r\nreturn -ENOMEM;\r\n}\r\nstatic void netfilter_log_sysctl_exit(struct net *net)\r\n{\r\nstruct ctl_table *table;\r\ntable = net->nf.nf_log_dir_header->ctl_table_arg;\r\nunregister_net_sysctl_table(net->nf.nf_log_dir_header);\r\nif (!net_eq(net, &init_net))\r\nkfree(table);\r\n}\r\nstatic int netfilter_log_sysctl_init(struct net *net)\r\n{\r\nreturn 0;\r\n}\r\nstatic void netfilter_log_sysctl_exit(struct net *net)\r\n{\r\n}\r\nstatic int __net_init nf_log_net_init(struct net *net)\r\n{\r\nint ret = -ENOMEM;\r\n#ifdef CONFIG_PROC_FS\r\nif (!proc_create("nf_log", S_IRUGO,\r\nnet->nf.proc_netfilter, &nflog_file_ops))\r\nreturn ret;\r\n#endif\r\nret = netfilter_log_sysctl_init(net);\r\nif (ret < 0)\r\ngoto out_sysctl;\r\nreturn 0;\r\nout_sysctl:\r\n#ifdef CONFIG_PROC_FS\r\nremove_proc_entry("nf_log", net->nf.proc_netfilter);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void __net_exit nf_log_net_exit(struct net *net)\r\n{\r\nnetfilter_log_sysctl_exit(net);\r\n#ifdef CONFIG_PROC_FS\r\nremove_proc_entry("nf_log", net->nf.proc_netfilter);\r\n#endif\r\n}\r\nint __init netfilter_log_init(void)\r\n{\r\nreturn register_pernet_subsys(&nf_log_net_ops);\r\n}
