static int wm8958_dsp2_fw(struct snd_soc_codec *codec, const char *name,\r\nconst struct firmware *fw, bool check)\r\n{\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nu64 data64;\r\nu32 data32;\r\nconst u8 *data;\r\nchar *str;\r\nsize_t block_len, len;\r\nint ret = 0;\r\nif (wm8994->cur_fw == fw)\r\nreturn 0;\r\nif (fw->size < 32) {\r\ndev_err(codec->dev, "%s: firmware too short (%zd bytes)\n",\r\nname, fw->size);\r\ngoto err;\r\n}\r\nif (memcmp(fw->data, "WMFW", 4) != 0) {\r\nmemcpy(&data32, fw->data, sizeof(data32));\r\ndata32 = be32_to_cpu(data32);\r\ndev_err(codec->dev, "%s: firmware has bad file magic %08x\n",\r\nname, data32);\r\ngoto err;\r\n}\r\nmemcpy(&data32, fw->data + 4, sizeof(data32));\r\nlen = be32_to_cpu(data32);\r\nmemcpy(&data32, fw->data + 8, sizeof(data32));\r\ndata32 = be32_to_cpu(data32);\r\nif ((data32 >> 24) & 0xff) {\r\ndev_err(codec->dev, "%s: unsupported firmware version %d\n",\r\nname, (data32 >> 24) & 0xff);\r\ngoto err;\r\n}\r\nif ((data32 & 0xffff) != 8958) {\r\ndev_err(codec->dev, "%s: unsupported target device %d\n",\r\nname, data32 & 0xffff);\r\ngoto err;\r\n}\r\nif (((data32 >> 16) & 0xff) != 0xc) {\r\ndev_err(codec->dev, "%s: unsupported target core %d\n",\r\nname, (data32 >> 16) & 0xff);\r\ngoto err;\r\n}\r\nif (check) {\r\nmemcpy(&data64, fw->data + 24, sizeof(u64));\r\ndev_info(codec->dev, "%s timestamp %llx\n",\r\nname, be64_to_cpu(data64));\r\n} else {\r\nsnd_soc_write(codec, 0x102, 0x2);\r\nsnd_soc_write(codec, 0x900, 0x2);\r\n}\r\ndata = fw->data + len;\r\nlen = fw->size - len;\r\nwhile (len) {\r\nif (len < 12) {\r\ndev_err(codec->dev, "%s short data block of %zd\n",\r\nname, len);\r\ngoto err;\r\n}\r\nmemcpy(&data32, data + 4, sizeof(data32));\r\nblock_len = be32_to_cpu(data32);\r\nif (block_len + 8 > len) {\r\ndev_err(codec->dev, "%zd byte block longer than file\n",\r\nblock_len);\r\ngoto err;\r\n}\r\nif (block_len == 0) {\r\ndev_err(codec->dev, "Zero length block\n");\r\ngoto err;\r\n}\r\nmemcpy(&data32, data, sizeof(data32));\r\ndata32 = be32_to_cpu(data32);\r\nswitch ((data32 >> 24) & 0xff) {\r\ncase WM_FW_BLOCK_INFO:\r\nif (!check)\r\nbreak;\r\nstr = kzalloc(block_len + 1, GFP_KERNEL);\r\nif (str) {\r\nmemcpy(str, data + 8, block_len);\r\ndev_info(codec->dev, "%s: %s\n", name, str);\r\nkfree(str);\r\n} else {\r\ndev_err(codec->dev, "Out of memory\n");\r\n}\r\nbreak;\r\ncase WM_FW_BLOCK_PM:\r\ncase WM_FW_BLOCK_X:\r\ncase WM_FW_BLOCK_Y:\r\ncase WM_FW_BLOCK_Z:\r\ncase WM_FW_BLOCK_I:\r\ncase WM_FW_BLOCK_A:\r\ncase WM_FW_BLOCK_C:\r\ndev_dbg(codec->dev, "%s: %zd bytes of %x@%x\n", name,\r\nblock_len, (data32 >> 24) & 0xff,\r\ndata32 & 0xffffff);\r\nif (check)\r\nbreak;\r\ndata32 &= 0xffffff;\r\nwm8994_bulk_write(wm8994->wm8994,\r\ndata32 & 0xffffff,\r\nblock_len / 2,\r\n(void *)(data + 8));\r\nbreak;\r\ndefault:\r\ndev_warn(codec->dev, "%s: unknown block type %d\n",\r\nname, (data32 >> 24) & 0xff);\r\nbreak;\r\n}\r\nblock_len += block_len % 4;\r\ndata += block_len + 8;\r\nlen -= block_len + 8;\r\n}\r\nif (!check) {\r\ndev_dbg(codec->dev, "%s: download done\n", name);\r\nwm8994->cur_fw = fw;\r\n} else {\r\ndev_info(codec->dev, "%s: got firmware\n", name);\r\n}\r\ngoto ok;\r\nerr:\r\nret = -EINVAL;\r\nok:\r\nif (!check) {\r\nsnd_soc_write(codec, 0x900, 0x0);\r\nsnd_soc_write(codec, 0x102, 0x0);\r\n}\r\nreturn ret;\r\n}\r\nstatic void wm8958_dsp_start_mbc(struct snd_soc_codec *codec, int path)\r\n{\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8994 *control = wm8994->wm8994;\r\nint i;\r\nif (snd_soc_read(codec, WM8958_DSP2_PROGRAM) & WM8958_DSP2_ENA)\r\nreturn;\r\nif (wm8994->mbc)\r\nwm8958_dsp2_fw(codec, "MBC", wm8994->mbc, false);\r\nsnd_soc_update_bits(codec, WM8958_DSP2_PROGRAM,\r\nWM8958_DSP2_ENA, WM8958_DSP2_ENA);\r\nif (control->pdata.num_mbc_cfgs) {\r\nstruct wm8958_mbc_cfg *cfg\r\n= &control->pdata.mbc_cfgs[wm8994->mbc_cfg];\r\nfor (i = 0; i < ARRAY_SIZE(cfg->coeff_regs); i++)\r\nsnd_soc_write(codec, i + WM8958_MBC_BAND_1_K_1,\r\ncfg->coeff_regs[i]);\r\nfor (i = 0; i < ARRAY_SIZE(cfg->cutoff_regs); i++)\r\nsnd_soc_write(codec,\r\ni + WM8958_MBC_BAND_2_LOWER_CUTOFF_C1_1,\r\ncfg->cutoff_regs[i]);\r\n}\r\nsnd_soc_write(codec, WM8958_DSP2_EXECCONTROL,\r\nWM8958_DSP2_RUNR);\r\nsnd_soc_update_bits(codec, WM8958_DSP2_CONFIG,\r\nWM8958_MBC_ENA |\r\nWM8958_MBC_SEL_MASK,\r\npath << WM8958_MBC_SEL_SHIFT |\r\nWM8958_MBC_ENA);\r\n}\r\nstatic void wm8958_dsp_start_vss(struct snd_soc_codec *codec, int path)\r\n{\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8994 *control = wm8994->wm8994;\r\nint i, ena;\r\nif (wm8994->mbc_vss)\r\nwm8958_dsp2_fw(codec, "MBC+VSS", wm8994->mbc_vss, false);\r\nsnd_soc_update_bits(codec, WM8958_DSP2_PROGRAM,\r\nWM8958_DSP2_ENA, WM8958_DSP2_ENA);\r\nif (control->pdata.num_mbc_cfgs) {\r\nstruct wm8958_mbc_cfg *cfg\r\n= &control->pdata.mbc_cfgs[wm8994->mbc_cfg];\r\nfor (i = 0; i < ARRAY_SIZE(cfg->combined_regs); i++)\r\nsnd_soc_write(codec, i + 0x2800,\r\ncfg->combined_regs[i]);\r\n}\r\nif (control->pdata.num_vss_cfgs) {\r\nstruct wm8958_vss_cfg *cfg\r\n= &control->pdata.vss_cfgs[wm8994->vss_cfg];\r\nfor (i = 0; i < ARRAY_SIZE(cfg->regs); i++)\r\nsnd_soc_write(codec, i + 0x2600, cfg->regs[i]);\r\n}\r\nif (control->pdata.num_vss_hpf_cfgs) {\r\nstruct wm8958_vss_hpf_cfg *cfg\r\n= &control->pdata.vss_hpf_cfgs[wm8994->vss_hpf_cfg];\r\nfor (i = 0; i < ARRAY_SIZE(cfg->regs); i++)\r\nsnd_soc_write(codec, i + 0x2400, cfg->regs[i]);\r\n}\r\nsnd_soc_write(codec, WM8958_DSP2_EXECCONTROL,\r\nWM8958_DSP2_RUNR);\r\nena = 0;\r\nif (wm8994->mbc_ena[path])\r\nena |= 0x8;\r\nif (wm8994->hpf2_ena[path])\r\nena |= 0x4;\r\nif (wm8994->hpf1_ena[path])\r\nena |= 0x2;\r\nif (wm8994->vss_ena[path])\r\nena |= 0x1;\r\nsnd_soc_write(codec, 0x2201, ena);\r\nsnd_soc_update_bits(codec, WM8958_DSP2_CONFIG,\r\nWM8958_MBC_SEL_MASK | WM8958_MBC_ENA,\r\npath << WM8958_MBC_SEL_SHIFT | WM8958_MBC_ENA);\r\n}\r\nstatic void wm8958_dsp_start_enh_eq(struct snd_soc_codec *codec, int path)\r\n{\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8994 *control = wm8994->wm8994;\r\nint i;\r\nwm8958_dsp2_fw(codec, "ENH_EQ", wm8994->enh_eq, false);\r\nsnd_soc_update_bits(codec, WM8958_DSP2_PROGRAM,\r\nWM8958_DSP2_ENA, WM8958_DSP2_ENA);\r\nif (control->pdata.num_enh_eq_cfgs) {\r\nstruct wm8958_enh_eq_cfg *cfg\r\n= &control->pdata.enh_eq_cfgs[wm8994->enh_eq_cfg];\r\nfor (i = 0; i < ARRAY_SIZE(cfg->regs); i++)\r\nsnd_soc_write(codec, i + 0x2200,\r\ncfg->regs[i]);\r\n}\r\nsnd_soc_write(codec, WM8958_DSP2_EXECCONTROL,\r\nWM8958_DSP2_RUNR);\r\nsnd_soc_update_bits(codec, WM8958_DSP2_CONFIG,\r\nWM8958_MBC_SEL_MASK | WM8958_MBC_ENA,\r\npath << WM8958_MBC_SEL_SHIFT | WM8958_MBC_ENA);\r\n}\r\nstatic void wm8958_dsp_apply(struct snd_soc_codec *codec, int path, int start)\r\n{\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nint pwr_reg = snd_soc_read(codec, WM8994_POWER_MANAGEMENT_5);\r\nint ena, reg, aif;\r\nswitch (path) {\r\ncase 0:\r\npwr_reg &= (WM8994_AIF1DAC1L_ENA | WM8994_AIF1DAC1R_ENA);\r\naif = 0;\r\nbreak;\r\ncase 1:\r\npwr_reg &= (WM8994_AIF1DAC2L_ENA | WM8994_AIF1DAC2R_ENA);\r\naif = 0;\r\nbreak;\r\ncase 2:\r\npwr_reg &= (WM8994_AIF2DACL_ENA | WM8994_AIF2DACR_ENA);\r\naif = 1;\r\nbreak;\r\ndefault:\r\nWARN(1, "Invalid path %d\n", path);\r\nreturn;\r\n}\r\nena = wm8994->mbc_ena[path] || wm8994->vss_ena[path] ||\r\nwm8994->hpf1_ena[path] || wm8994->hpf2_ena[path] ||\r\nwm8994->enh_eq_ena[path];\r\nif (!pwr_reg)\r\nena = 0;\r\nreg = snd_soc_read(codec, WM8958_DSP2_PROGRAM);\r\ndev_dbg(codec->dev, "DSP path %d %d startup: %d, power: %x, DSP: %x\n",\r\npath, wm8994->dsp_active, start, pwr_reg, reg);\r\nif (start && ena) {\r\nif (reg & WM8958_DSP2_ENA)\r\nreturn;\r\nif (!(snd_soc_read(codec, WM8994_AIF1_CLOCKING_1)\r\n& WM8994_AIF1CLK_ENA_MASK) &&\r\n!(snd_soc_read(codec, WM8994_AIF2_CLOCKING_1)\r\n& WM8994_AIF2CLK_ENA_MASK))\r\nreturn;\r\nsnd_soc_update_bits(codec, WM8994_CLOCKING_1,\r\nWM8958_DSP2CLK_SRC | WM8958_DSP2CLK_ENA,\r\naif << WM8958_DSP2CLK_SRC_SHIFT |\r\nWM8958_DSP2CLK_ENA);\r\nif (wm8994->enh_eq_ena[path])\r\nwm8958_dsp_start_enh_eq(codec, path);\r\nelse if (wm8994->vss_ena[path] || wm8994->hpf1_ena[path] ||\r\nwm8994->hpf2_ena[path])\r\nwm8958_dsp_start_vss(codec, path);\r\nelse if (wm8994->mbc_ena[path])\r\nwm8958_dsp_start_mbc(codec, path);\r\nwm8994->dsp_active = path;\r\ndev_dbg(codec->dev, "DSP running in path %d\n", path);\r\n}\r\nif (!start && wm8994->dsp_active == path) {\r\nif (!(reg & WM8958_DSP2_ENA))\r\nreturn;\r\nsnd_soc_update_bits(codec, WM8958_DSP2_CONFIG,\r\nWM8958_MBC_ENA, 0);\r\nsnd_soc_write(codec, WM8958_DSP2_EXECCONTROL,\r\nWM8958_DSP2_STOP);\r\nsnd_soc_update_bits(codec, WM8958_DSP2_PROGRAM,\r\nWM8958_DSP2_ENA, 0);\r\nsnd_soc_update_bits(codec, WM8994_CLOCKING_1,\r\nWM8958_DSP2CLK_ENA, 0);\r\nwm8994->dsp_active = -1;\r\ndev_dbg(codec->dev, "DSP stopped\n");\r\n}\r\n}\r\nint wm8958_aif_ev(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nint i;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nfor (i = 0; i < 3; i++)\r\nwm8958_dsp_apply(codec, i, 1);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nfor (i = 0; i < 3; i++)\r\nwm8958_dsp_apply(codec, i, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8958_dsp2_busy(struct wm8994_priv *wm8994, int aif)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(wm8994->mbc_ena); i++) {\r\nif (i == aif)\r\ncontinue;\r\nif (wm8994->mbc_ena[i] || wm8994->vss_ena[i] ||\r\nwm8994->hpf1_ena[i] || wm8994->hpf2_ena[i])\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8958_put_mbc_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8994 *control = wm8994->wm8994;\r\nint value = ucontrol->value.integer.value[0];\r\nint reg;\r\nreg = snd_soc_read(codec, WM8994_CLOCKING_1);\r\nif (reg < 0 || reg & WM8958_DSP2CLK_ENA)\r\nreturn -EBUSY;\r\nif (value >= control->pdata.num_mbc_cfgs)\r\nreturn -EINVAL;\r\nwm8994->mbc_cfg = value;\r\nreturn 0;\r\n}\r\nstatic int wm8958_get_mbc_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.enumerated.item[0] = wm8994->mbc_cfg;\r\nreturn 0;\r\n}\r\nstatic int wm8958_mbc_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nstatic int wm8958_mbc_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint mbc = kcontrol->private_value;\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.integer.value[0] = wm8994->mbc_ena[mbc];\r\nreturn 0;\r\n}\r\nstatic int wm8958_mbc_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint mbc = kcontrol->private_value;\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nif (wm8994->mbc_ena[mbc] == ucontrol->value.integer.value[0])\r\nreturn 0;\r\nif (ucontrol->value.integer.value[0] > 1)\r\nreturn -EINVAL;\r\nif (wm8958_dsp2_busy(wm8994, mbc)) {\r\ndev_dbg(codec->dev, "DSP2 active on %d already\n", mbc);\r\nreturn -EBUSY;\r\n}\r\nif (wm8994->enh_eq_ena[mbc])\r\nreturn -EBUSY;\r\nwm8994->mbc_ena[mbc] = ucontrol->value.integer.value[0];\r\nwm8958_dsp_apply(codec, mbc, wm8994->mbc_ena[mbc]);\r\nreturn 0;\r\n}\r\nstatic int wm8958_put_vss_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8994 *control = wm8994->wm8994;\r\nint value = ucontrol->value.integer.value[0];\r\nint reg;\r\nreg = snd_soc_read(codec, WM8994_CLOCKING_1);\r\nif (reg < 0 || reg & WM8958_DSP2CLK_ENA)\r\nreturn -EBUSY;\r\nif (value >= control->pdata.num_vss_cfgs)\r\nreturn -EINVAL;\r\nwm8994->vss_cfg = value;\r\nreturn 0;\r\n}\r\nstatic int wm8958_get_vss_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.enumerated.item[0] = wm8994->vss_cfg;\r\nreturn 0;\r\n}\r\nstatic int wm8958_put_vss_hpf_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8994 *control = wm8994->wm8994;\r\nint value = ucontrol->value.integer.value[0];\r\nint reg;\r\nreg = snd_soc_read(codec, WM8994_CLOCKING_1);\r\nif (reg < 0 || reg & WM8958_DSP2CLK_ENA)\r\nreturn -EBUSY;\r\nif (value >= control->pdata.num_vss_hpf_cfgs)\r\nreturn -EINVAL;\r\nwm8994->vss_hpf_cfg = value;\r\nreturn 0;\r\n}\r\nstatic int wm8958_get_vss_hpf_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.enumerated.item[0] = wm8994->vss_hpf_cfg;\r\nreturn 0;\r\n}\r\nstatic int wm8958_vss_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nstatic int wm8958_vss_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint vss = kcontrol->private_value;\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.integer.value[0] = wm8994->vss_ena[vss];\r\nreturn 0;\r\n}\r\nstatic int wm8958_vss_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint vss = kcontrol->private_value;\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nif (wm8994->vss_ena[vss] == ucontrol->value.integer.value[0])\r\nreturn 0;\r\nif (ucontrol->value.integer.value[0] > 1)\r\nreturn -EINVAL;\r\nif (!wm8994->mbc_vss)\r\nreturn -ENODEV;\r\nif (wm8958_dsp2_busy(wm8994, vss)) {\r\ndev_dbg(codec->dev, "DSP2 active on %d already\n", vss);\r\nreturn -EBUSY;\r\n}\r\nif (wm8994->enh_eq_ena[vss])\r\nreturn -EBUSY;\r\nwm8994->vss_ena[vss] = ucontrol->value.integer.value[0];\r\nwm8958_dsp_apply(codec, vss, wm8994->vss_ena[vss]);\r\nreturn 0;\r\n}\r\nstatic int wm8958_hpf_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nstatic int wm8958_hpf_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint hpf = kcontrol->private_value;\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nif (hpf < 3)\r\nucontrol->value.integer.value[0] = wm8994->hpf1_ena[hpf % 3];\r\nelse\r\nucontrol->value.integer.value[0] = wm8994->hpf2_ena[hpf % 3];\r\nreturn 0;\r\n}\r\nstatic int wm8958_hpf_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint hpf = kcontrol->private_value;\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nif (hpf < 3) {\r\nif (wm8994->hpf1_ena[hpf % 3] ==\r\nucontrol->value.integer.value[0])\r\nreturn 0;\r\n} else {\r\nif (wm8994->hpf2_ena[hpf % 3] ==\r\nucontrol->value.integer.value[0])\r\nreturn 0;\r\n}\r\nif (ucontrol->value.integer.value[0] > 1)\r\nreturn -EINVAL;\r\nif (!wm8994->mbc_vss)\r\nreturn -ENODEV;\r\nif (wm8958_dsp2_busy(wm8994, hpf % 3)) {\r\ndev_dbg(codec->dev, "DSP2 active on %d already\n", hpf);\r\nreturn -EBUSY;\r\n}\r\nif (wm8994->enh_eq_ena[hpf % 3])\r\nreturn -EBUSY;\r\nif (hpf < 3)\r\nwm8994->hpf1_ena[hpf % 3] = ucontrol->value.integer.value[0];\r\nelse\r\nwm8994->hpf2_ena[hpf % 3] = ucontrol->value.integer.value[0];\r\nwm8958_dsp_apply(codec, hpf % 3, ucontrol->value.integer.value[0]);\r\nreturn 0;\r\n}\r\nstatic int wm8958_put_enh_eq_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8994 *control = wm8994->wm8994;\r\nint value = ucontrol->value.integer.value[0];\r\nint reg;\r\nreg = snd_soc_read(codec, WM8994_CLOCKING_1);\r\nif (reg < 0 || reg & WM8958_DSP2CLK_ENA)\r\nreturn -EBUSY;\r\nif (value >= control->pdata.num_enh_eq_cfgs)\r\nreturn -EINVAL;\r\nwm8994->enh_eq_cfg = value;\r\nreturn 0;\r\n}\r\nstatic int wm8958_get_enh_eq_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.enumerated.item[0] = wm8994->enh_eq_cfg;\r\nreturn 0;\r\n}\r\nstatic int wm8958_enh_eq_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nstatic int wm8958_enh_eq_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint eq = kcontrol->private_value;\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.integer.value[0] = wm8994->enh_eq_ena[eq];\r\nreturn 0;\r\n}\r\nstatic int wm8958_enh_eq_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint eq = kcontrol->private_value;\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nif (wm8994->enh_eq_ena[eq] == ucontrol->value.integer.value[0])\r\nreturn 0;\r\nif (ucontrol->value.integer.value[0] > 1)\r\nreturn -EINVAL;\r\nif (!wm8994->enh_eq)\r\nreturn -ENODEV;\r\nif (wm8958_dsp2_busy(wm8994, eq)) {\r\ndev_dbg(codec->dev, "DSP2 active on %d already\n", eq);\r\nreturn -EBUSY;\r\n}\r\nif (wm8994->mbc_ena[eq] || wm8994->vss_ena[eq] ||\r\nwm8994->hpf1_ena[eq] || wm8994->hpf2_ena[eq])\r\nreturn -EBUSY;\r\nwm8994->enh_eq_ena[eq] = ucontrol->value.integer.value[0];\r\nwm8958_dsp_apply(codec, eq, ucontrol->value.integer.value[0]);\r\nreturn 0;\r\n}\r\nstatic void wm8958_enh_eq_loaded(const struct firmware *fw, void *context)\r\n{\r\nstruct snd_soc_codec *codec = context;\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nif (fw && (wm8958_dsp2_fw(codec, "ENH_EQ", fw, true) == 0)) {\r\nmutex_lock(&wm8994->fw_lock);\r\nwm8994->enh_eq = fw;\r\nmutex_unlock(&wm8994->fw_lock);\r\n}\r\n}\r\nstatic void wm8958_mbc_vss_loaded(const struct firmware *fw, void *context)\r\n{\r\nstruct snd_soc_codec *codec = context;\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nif (fw && (wm8958_dsp2_fw(codec, "MBC+VSS", fw, true) == 0)) {\r\nmutex_lock(&wm8994->fw_lock);\r\nwm8994->mbc_vss = fw;\r\nmutex_unlock(&wm8994->fw_lock);\r\n}\r\n}\r\nstatic void wm8958_mbc_loaded(const struct firmware *fw, void *context)\r\n{\r\nstruct snd_soc_codec *codec = context;\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nif (fw && (wm8958_dsp2_fw(codec, "MBC", fw, true) == 0)) {\r\nmutex_lock(&wm8994->fw_lock);\r\nwm8994->mbc = fw;\r\nmutex_unlock(&wm8994->fw_lock);\r\n}\r\n}\r\nvoid wm8958_dsp2_init(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8994 *control = wm8994->wm8994;\r\nstruct wm8994_pdata *pdata = &control->pdata;\r\nint ret, i;\r\nwm8994->dsp_active = -1;\r\nsnd_soc_add_codec_controls(codec, wm8958_mbc_snd_controls,\r\nARRAY_SIZE(wm8958_mbc_snd_controls));\r\nsnd_soc_add_codec_controls(codec, wm8958_vss_snd_controls,\r\nARRAY_SIZE(wm8958_vss_snd_controls));\r\nsnd_soc_add_codec_controls(codec, wm8958_enh_eq_snd_controls,\r\nARRAY_SIZE(wm8958_enh_eq_snd_controls));\r\nrequest_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,\r\n"wm8958_mbc.wfw", codec->dev, GFP_KERNEL,\r\ncodec, wm8958_mbc_loaded);\r\nrequest_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,\r\n"wm8958_mbc_vss.wfw", codec->dev, GFP_KERNEL,\r\ncodec, wm8958_mbc_vss_loaded);\r\nrequest_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,\r\n"wm8958_enh_eq.wfw", codec->dev, GFP_KERNEL,\r\ncodec, wm8958_enh_eq_loaded);\r\nif (pdata->num_mbc_cfgs) {\r\nstruct snd_kcontrol_new control[] = {\r\nSOC_ENUM_EXT("MBC Mode", wm8994->mbc_enum,\r\nwm8958_get_mbc_enum, wm8958_put_mbc_enum),\r\n};\r\nwm8994->mbc_texts = kmalloc(sizeof(char *)\r\n* pdata->num_mbc_cfgs, GFP_KERNEL);\r\nif (!wm8994->mbc_texts)\r\nreturn;\r\nfor (i = 0; i < pdata->num_mbc_cfgs; i++)\r\nwm8994->mbc_texts[i] = pdata->mbc_cfgs[i].name;\r\nwm8994->mbc_enum.items = pdata->num_mbc_cfgs;\r\nwm8994->mbc_enum.texts = wm8994->mbc_texts;\r\nret = snd_soc_add_codec_controls(wm8994->hubs.codec,\r\ncontrol, 1);\r\nif (ret != 0)\r\ndev_err(wm8994->hubs.codec->dev,\r\n"Failed to add MBC mode controls: %d\n", ret);\r\n}\r\nif (pdata->num_vss_cfgs) {\r\nstruct snd_kcontrol_new control[] = {\r\nSOC_ENUM_EXT("VSS Mode", wm8994->vss_enum,\r\nwm8958_get_vss_enum, wm8958_put_vss_enum),\r\n};\r\nwm8994->vss_texts = kmalloc(sizeof(char *)\r\n* pdata->num_vss_cfgs, GFP_KERNEL);\r\nif (!wm8994->vss_texts)\r\nreturn;\r\nfor (i = 0; i < pdata->num_vss_cfgs; i++)\r\nwm8994->vss_texts[i] = pdata->vss_cfgs[i].name;\r\nwm8994->vss_enum.items = pdata->num_vss_cfgs;\r\nwm8994->vss_enum.texts = wm8994->vss_texts;\r\nret = snd_soc_add_codec_controls(wm8994->hubs.codec,\r\ncontrol, 1);\r\nif (ret != 0)\r\ndev_err(wm8994->hubs.codec->dev,\r\n"Failed to add VSS mode controls: %d\n", ret);\r\n}\r\nif (pdata->num_vss_hpf_cfgs) {\r\nstruct snd_kcontrol_new control[] = {\r\nSOC_ENUM_EXT("VSS HPF Mode", wm8994->vss_hpf_enum,\r\nwm8958_get_vss_hpf_enum,\r\nwm8958_put_vss_hpf_enum),\r\n};\r\nwm8994->vss_hpf_texts = kmalloc(sizeof(char *)\r\n* pdata->num_vss_hpf_cfgs, GFP_KERNEL);\r\nif (!wm8994->vss_hpf_texts)\r\nreturn;\r\nfor (i = 0; i < pdata->num_vss_hpf_cfgs; i++)\r\nwm8994->vss_hpf_texts[i] = pdata->vss_hpf_cfgs[i].name;\r\nwm8994->vss_hpf_enum.items = pdata->num_vss_hpf_cfgs;\r\nwm8994->vss_hpf_enum.texts = wm8994->vss_hpf_texts;\r\nret = snd_soc_add_codec_controls(wm8994->hubs.codec,\r\ncontrol, 1);\r\nif (ret != 0)\r\ndev_err(wm8994->hubs.codec->dev,\r\n"Failed to add VSS HPFmode controls: %d\n",\r\nret);\r\n}\r\nif (pdata->num_enh_eq_cfgs) {\r\nstruct snd_kcontrol_new control[] = {\r\nSOC_ENUM_EXT("Enhanced EQ Mode", wm8994->enh_eq_enum,\r\nwm8958_get_enh_eq_enum,\r\nwm8958_put_enh_eq_enum),\r\n};\r\nwm8994->enh_eq_texts = kmalloc(sizeof(char *)\r\n* pdata->num_enh_eq_cfgs, GFP_KERNEL);\r\nif (!wm8994->enh_eq_texts)\r\nreturn;\r\nfor (i = 0; i < pdata->num_enh_eq_cfgs; i++)\r\nwm8994->enh_eq_texts[i] = pdata->enh_eq_cfgs[i].name;\r\nwm8994->enh_eq_enum.items = pdata->num_enh_eq_cfgs;\r\nwm8994->enh_eq_enum.texts = wm8994->enh_eq_texts;\r\nret = snd_soc_add_codec_controls(wm8994->hubs.codec,\r\ncontrol, 1);\r\nif (ret != 0)\r\ndev_err(wm8994->hubs.codec->dev,\r\n"Failed to add enhanced EQ controls: %d\n",\r\nret);\r\n}\r\n}
