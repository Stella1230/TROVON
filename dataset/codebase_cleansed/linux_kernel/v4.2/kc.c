int pps_kc_bind(struct pps_device *pps, struct pps_bind_args *bind_args)\r\n{\r\nspin_lock_irq(&pps_kc_hardpps_lock);\r\nif (bind_args->edge == 0)\r\nif (pps_kc_hardpps_dev == pps) {\r\npps_kc_hardpps_mode = 0;\r\npps_kc_hardpps_dev = NULL;\r\nspin_unlock_irq(&pps_kc_hardpps_lock);\r\ndev_info(pps->dev, "unbound kernel"\r\n" consumer\n");\r\n} else {\r\nspin_unlock_irq(&pps_kc_hardpps_lock);\r\ndev_err(pps->dev, "selected kernel consumer"\r\n" is not bound\n");\r\nreturn -EINVAL;\r\n}\r\nelse\r\nif (pps_kc_hardpps_dev == NULL ||\r\npps_kc_hardpps_dev == pps) {\r\npps_kc_hardpps_mode = bind_args->edge;\r\npps_kc_hardpps_dev = pps;\r\nspin_unlock_irq(&pps_kc_hardpps_lock);\r\ndev_info(pps->dev, "bound kernel consumer: "\r\n"edge=0x%x\n", bind_args->edge);\r\n} else {\r\nspin_unlock_irq(&pps_kc_hardpps_lock);\r\ndev_err(pps->dev, "another kernel consumer"\r\n" is already bound\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid pps_kc_remove(struct pps_device *pps)\r\n{\r\nspin_lock_irq(&pps_kc_hardpps_lock);\r\nif (pps == pps_kc_hardpps_dev) {\r\npps_kc_hardpps_mode = 0;\r\npps_kc_hardpps_dev = NULL;\r\nspin_unlock_irq(&pps_kc_hardpps_lock);\r\ndev_info(pps->dev, "unbound kernel consumer"\r\n" on device removal\n");\r\n} else\r\nspin_unlock_irq(&pps_kc_hardpps_lock);\r\n}\r\nvoid pps_kc_event(struct pps_device *pps, struct pps_event_time *ts,\r\nint event)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&pps_kc_hardpps_lock, flags);\r\nif (pps == pps_kc_hardpps_dev && event & pps_kc_hardpps_mode)\r\nhardpps(&ts->ts_real, &ts->ts_raw);\r\nspin_unlock_irqrestore(&pps_kc_hardpps_lock, flags);\r\n}
