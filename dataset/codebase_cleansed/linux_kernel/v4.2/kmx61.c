static void kmx61_set_data(struct iio_dev *indio_dev, struct kmx61_data *data)\r\n{\r\nstruct kmx61_data **priv = iio_priv(indio_dev);\r\n*priv = data;\r\n}\r\nstatic struct kmx61_data *kmx61_get_data(struct iio_dev *indio_dev)\r\n{\r\nreturn *(struct kmx61_data **)iio_priv(indio_dev);\r\n}\r\nstatic int kmx61_convert_freq_to_bit(int val, int val2)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(kmx61_samp_freq_table); i++)\r\nif (val == kmx61_samp_freq_table[i].val &&\r\nval2 == kmx61_samp_freq_table[i].val2)\r\nreturn i;\r\nreturn -EINVAL;\r\n}\r\nstatic int kmx61_convert_wake_up_odr_to_bit(int val, int val2)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(kmx61_wake_up_odr_table); ++i)\r\nif (kmx61_wake_up_odr_table[i].val == val &&\r\nkmx61_wake_up_odr_table[i].val2 == val2)\r\nreturn kmx61_wake_up_odr_table[i].odr_bits;\r\nreturn -EINVAL;\r\n}\r\nstatic int kmx61_set_mode(struct kmx61_data *data, u8 mode, u8 device,\r\nbool update)\r\n{\r\nint ret;\r\nint acc_stby = -1, mag_stby = -1;\r\nret = i2c_smbus_read_byte_data(data->client, KMX61_REG_STBY);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error reading reg_stby\n");\r\nreturn ret;\r\n}\r\nif (device & KMX61_ACC) {\r\nif (mode & KMX61_ACC_STBY_BIT) {\r\nret |= KMX61_ACC_STBY_BIT;\r\nacc_stby = 1;\r\n} else {\r\nret &= ~KMX61_ACC_STBY_BIT;\r\nacc_stby = 0;\r\n}\r\n}\r\nif (device & KMX61_MAG) {\r\nif (mode & KMX61_MAG_STBY_BIT) {\r\nret |= KMX61_MAG_STBY_BIT;\r\nmag_stby = 1;\r\n} else {\r\nret &= ~KMX61_MAG_STBY_BIT;\r\nmag_stby = 0;\r\n}\r\n}\r\nif (mode & KMX61_ACT_STBY_BIT)\r\nret |= KMX61_ACT_STBY_BIT;\r\nret = i2c_smbus_write_byte_data(data->client, KMX61_REG_STBY, ret);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error writing reg_stby\n");\r\nreturn ret;\r\n}\r\nif (acc_stby != -1 && update)\r\ndata->acc_stby = acc_stby;\r\nif (mag_stby != -1 && update)\r\ndata->mag_stby = mag_stby;\r\nreturn 0;\r\n}\r\nstatic int kmx61_get_mode(struct kmx61_data *data, u8 *mode, u8 device)\r\n{\r\nint ret;\r\nret = i2c_smbus_read_byte_data(data->client, KMX61_REG_STBY);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error reading reg_stby\n");\r\nreturn ret;\r\n}\r\n*mode = 0;\r\nif (device & KMX61_ACC) {\r\nif (ret & KMX61_ACC_STBY_BIT)\r\n*mode |= KMX61_ACC_STBY_BIT;\r\nelse\r\n*mode &= ~KMX61_ACC_STBY_BIT;\r\n}\r\nif (device & KMX61_MAG) {\r\nif (ret & KMX61_MAG_STBY_BIT)\r\n*mode |= KMX61_MAG_STBY_BIT;\r\nelse\r\n*mode &= ~KMX61_MAG_STBY_BIT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int kmx61_set_wake_up_odr(struct kmx61_data *data, int val, int val2)\r\n{\r\nint ret, odr_bits;\r\nodr_bits = kmx61_convert_wake_up_odr_to_bit(val, val2);\r\nif (odr_bits < 0)\r\nreturn odr_bits;\r\nret = i2c_smbus_write_byte_data(data->client, KMX61_REG_CTRL2,\r\nodr_bits);\r\nif (ret < 0)\r\ndev_err(&data->client->dev, "Error writing reg_ctrl2\n");\r\nreturn ret;\r\n}\r\nstatic int kmx61_set_odr(struct kmx61_data *data, int val, int val2, u8 device)\r\n{\r\nint ret;\r\nu8 mode;\r\nint lodr_bits, odr_bits;\r\nret = kmx61_get_mode(data, &mode, KMX61_ACC | KMX61_MAG);\r\nif (ret < 0)\r\nreturn ret;\r\nlodr_bits = kmx61_convert_freq_to_bit(val, val2);\r\nif (lodr_bits < 0)\r\nreturn lodr_bits;\r\nret = kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG,\r\ntrue);\r\nif (ret < 0)\r\nreturn ret;\r\nodr_bits = 0;\r\nif (device & KMX61_ACC)\r\nodr_bits |= lodr_bits << KMX61_ACC_ODR_SHIFT;\r\nif (device & KMX61_MAG)\r\nodr_bits |= lodr_bits << KMX61_MAG_ODR_SHIFT;\r\nret = i2c_smbus_write_byte_data(data->client, KMX61_REG_ODCNTL,\r\nodr_bits);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->odr_bits = odr_bits;\r\nif (device & KMX61_ACC) {\r\nret = kmx61_set_wake_up_odr(data, val, val2);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn kmx61_set_mode(data, mode, KMX61_ACC | KMX61_MAG, true);\r\n}\r\nstatic int kmx61_get_odr(struct kmx61_data *data, int *val, int *val2,\r\nu8 device)\r\n{\r\nu8 lodr_bits;\r\nif (device & KMX61_ACC)\r\nlodr_bits = (data->odr_bits >> KMX61_ACC_ODR_SHIFT) &\r\nKMX61_ACC_ODR_MASK;\r\nelse if (device & KMX61_MAG)\r\nlodr_bits = (data->odr_bits >> KMX61_MAG_ODR_SHIFT) &\r\nKMX61_MAG_ODR_MASK;\r\nelse\r\nreturn -EINVAL;\r\nif (lodr_bits >= ARRAY_SIZE(kmx61_samp_freq_table))\r\nreturn -EINVAL;\r\n*val = kmx61_samp_freq_table[lodr_bits].val;\r\n*val2 = kmx61_samp_freq_table[lodr_bits].val2;\r\nreturn 0;\r\n}\r\nstatic int kmx61_set_range(struct kmx61_data *data, u8 range)\r\n{\r\nint ret;\r\nret = i2c_smbus_read_byte_data(data->client, KMX61_REG_CTRL1);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error reading reg_ctrl1\n");\r\nreturn ret;\r\n}\r\nret &= ~KMX61_REG_CTRL1_GSEL_MASK;\r\nret |= range & KMX61_REG_CTRL1_GSEL_MASK;\r\nret = i2c_smbus_write_byte_data(data->client, KMX61_REG_CTRL1, ret);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error writing reg_ctrl1\n");\r\nreturn ret;\r\n}\r\ndata->range = range;\r\nreturn 0;\r\n}\r\nstatic int kmx61_set_scale(struct kmx61_data *data, u16 uscale)\r\n{\r\nint ret, i;\r\nu8 mode;\r\nfor (i = 0; i < ARRAY_SIZE(kmx61_uscale_table); i++) {\r\nif (kmx61_uscale_table[i] == uscale) {\r\nret = kmx61_get_mode(data, &mode,\r\nKMX61_ACC | KMX61_MAG);\r\nif (ret < 0)\r\nreturn ret;\r\nret = kmx61_set_mode(data, KMX61_ALL_STBY,\r\nKMX61_ACC | KMX61_MAG, true);\r\nif (ret < 0)\r\nreturn ret;\r\nret = kmx61_set_range(data, i);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn kmx61_set_mode(data, mode,\r\nKMX61_ACC | KMX61_MAG, true);\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int kmx61_chip_init(struct kmx61_data *data)\r\n{\r\nint ret, val, val2;\r\nret = i2c_smbus_read_byte_data(data->client, KMX61_REG_WHO_AM_I);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error reading who_am_i\n");\r\nreturn ret;\r\n}\r\nif (ret != KMX61_CHIP_ID) {\r\ndev_err(&data->client->dev,\r\n"Wrong chip id, got %x expected %x\n",\r\nret, KMX61_CHIP_ID);\r\nreturn -EINVAL;\r\n}\r\nret = kmx61_set_range(data, KMX61_RANGE_4G);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_read_byte_data(data->client, KMX61_REG_ODCNTL);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error reading reg_odcntl\n");\r\nreturn ret;\r\n}\r\ndata->odr_bits = ret;\r\nret = kmx61_get_odr(data, &val, &val2, KMX61_ACC);\r\nif (ret < 0)\r\nreturn ret;\r\nret = kmx61_set_wake_up_odr(data, val, val2);\r\nif (ret < 0)\r\nreturn ret;\r\nret = kmx61_set_mode(data, 0, KMX61_ACC | KMX61_MAG, true);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->wake_thresh = KMX61_DEFAULT_WAKE_THRESH;\r\ndata->wake_duration = KMX61_DEFAULT_WAKE_DURATION;\r\nreturn 0;\r\n}\r\nstatic int kmx61_setup_new_data_interrupt(struct kmx61_data *data,\r\nbool status, u8 device)\r\n{\r\nu8 mode;\r\nint ret;\r\nret = kmx61_get_mode(data, &mode, KMX61_ACC | KMX61_MAG);\r\nif (ret < 0)\r\nreturn ret;\r\nret = kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG, true);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_read_byte_data(data->client, KMX61_REG_INC1);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error reading reg_ctrl1\n");\r\nreturn ret;\r\n}\r\nif (status) {\r\nret |= KMX61_REG_INC1_BIT_IEN;\r\nif (device & KMX61_ACC)\r\nret |= KMX61_REG_INC1_BIT_DRDYA;\r\nif (device & KMX61_MAG)\r\nret |= KMX61_REG_INC1_BIT_DRDYM;\r\n} else {\r\nret &= ~KMX61_REG_INC1_BIT_IEN;\r\nif (device & KMX61_ACC)\r\nret &= ~KMX61_REG_INC1_BIT_DRDYA;\r\nif (device & KMX61_MAG)\r\nret &= ~KMX61_REG_INC1_BIT_DRDYM;\r\n}\r\nret = i2c_smbus_write_byte_data(data->client, KMX61_REG_INC1, ret);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error writing reg_int_ctrl1\n");\r\nreturn ret;\r\n}\r\nret = i2c_smbus_read_byte_data(data->client, KMX61_REG_CTRL1);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error reading reg_ctrl1\n");\r\nreturn ret;\r\n}\r\nif (status)\r\nret |= KMX61_REG_CTRL1_BIT_DRDYE;\r\nelse\r\nret &= ~KMX61_REG_CTRL1_BIT_DRDYE;\r\nret = i2c_smbus_write_byte_data(data->client, KMX61_REG_CTRL1, ret);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error writing reg_ctrl1\n");\r\nreturn ret;\r\n}\r\nreturn kmx61_set_mode(data, mode, KMX61_ACC | KMX61_MAG, true);\r\n}\r\nstatic int kmx61_chip_update_thresholds(struct kmx61_data *data)\r\n{\r\nint ret;\r\nret = i2c_smbus_write_byte_data(data->client,\r\nKMX61_REG_WUF_TIMER,\r\ndata->wake_duration);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Errow writing reg_wuf_timer\n");\r\nreturn ret;\r\n}\r\nret = i2c_smbus_write_byte_data(data->client,\r\nKMX61_REG_WUF_THRESH,\r\ndata->wake_thresh);\r\nif (ret < 0)\r\ndev_err(&data->client->dev, "Error writing reg_wuf_thresh\n");\r\nreturn ret;\r\n}\r\nstatic int kmx61_setup_any_motion_interrupt(struct kmx61_data *data,\r\nbool status)\r\n{\r\nu8 mode;\r\nint ret;\r\nret = kmx61_get_mode(data, &mode, KMX61_ACC | KMX61_MAG);\r\nif (ret < 0)\r\nreturn ret;\r\nret = kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG, true);\r\nif (ret < 0)\r\nreturn ret;\r\nret = kmx61_chip_update_thresholds(data);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_read_byte_data(data->client, KMX61_REG_INC1);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error reading reg_inc1\n");\r\nreturn ret;\r\n}\r\nif (status)\r\nret |= (KMX61_REG_INC1_BIT_IEN | KMX61_REG_INC1_BIT_WUFS);\r\nelse\r\nret &= ~(KMX61_REG_INC1_BIT_IEN | KMX61_REG_INC1_BIT_WUFS);\r\nret = i2c_smbus_write_byte_data(data->client, KMX61_REG_INC1, ret);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error writing reg_inc1\n");\r\nreturn ret;\r\n}\r\nret = i2c_smbus_read_byte_data(data->client, KMX61_REG_CTRL1);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error reading reg_ctrl1\n");\r\nreturn ret;\r\n}\r\nif (status)\r\nret |= KMX61_REG_CTRL1_BIT_WUFE | KMX61_REG_CTRL1_BIT_BTSE;\r\nelse\r\nret &= ~(KMX61_REG_CTRL1_BIT_WUFE | KMX61_REG_CTRL1_BIT_BTSE);\r\nret = i2c_smbus_write_byte_data(data->client, KMX61_REG_CTRL1, ret);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error writing reg_ctrl1\n");\r\nreturn ret;\r\n}\r\nmode |= KMX61_ACT_STBY_BIT;\r\nreturn kmx61_set_mode(data, mode, KMX61_ACC | KMX61_MAG, true);\r\n}\r\nstatic int kmx61_set_power_state(struct kmx61_data *data, bool on, u8 device)\r\n{\r\n#ifdef CONFIG_PM\r\nint ret;\r\nif (device & KMX61_ACC) {\r\nif (on && !data->acc_ps && !data->mag_stby) {\r\nret = kmx61_set_mode(data, 0, KMX61_ACC, true);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\ndata->acc_ps = on;\r\n}\r\nif (device & KMX61_MAG) {\r\nif (on && !data->mag_ps && !data->acc_stby) {\r\nret = kmx61_set_mode(data, 0, KMX61_MAG, true);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\ndata->mag_ps = on;\r\n}\r\nif (on) {\r\nret = pm_runtime_get_sync(&data->client->dev);\r\n} else {\r\npm_runtime_mark_last_busy(&data->client->dev);\r\nret = pm_runtime_put_autosuspend(&data->client->dev);\r\n}\r\nif (ret < 0) {\r\ndev_err(&data->client->dev,\r\n"Failed: kmx61_set_power_state for %d, ret %d\n",\r\non, ret);\r\nif (on)\r\npm_runtime_put_noidle(&data->client->dev);\r\nreturn ret;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int kmx61_read_measurement(struct kmx61_data *data, u8 base, u8 offset)\r\n{\r\nint ret;\r\nu8 reg = base + offset * 2;\r\nret = i2c_smbus_read_word_data(data->client, reg);\r\nif (ret < 0)\r\ndev_err(&data->client->dev, "failed to read reg at %x\n", reg);\r\nreturn ret;\r\n}\r\nstatic int kmx61_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int *val,\r\nint *val2, long mask)\r\n{\r\nint ret;\r\nu8 base_reg;\r\nstruct kmx61_data *data = kmx61_get_data(indio_dev);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nswitch (chan->type) {\r\ncase IIO_ACCEL:\r\nbase_reg = KMX61_ACC_XOUT_L;\r\nbreak;\r\ncase IIO_MAGN:\r\nbase_reg = KMX61_MAG_XOUT_L;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&data->lock);\r\nret = kmx61_set_power_state(data, true, chan->address);\r\nif (ret) {\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nret = kmx61_read_measurement(data, base_reg, chan->scan_index);\r\nif (ret < 0) {\r\nkmx61_set_power_state(data, false, chan->address);\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\n*val = sign_extend32(ret >> chan->scan_type.shift,\r\nchan->scan_type.realbits - 1);\r\nret = kmx61_set_power_state(data, false, chan->address);\r\nmutex_unlock(&data->lock);\r\nif (ret)\r\nreturn ret;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\nswitch (chan->type) {\r\ncase IIO_ACCEL:\r\n*val = 0;\r\n*val2 = kmx61_uscale_table[data->range];\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_MAGN:\r\n*val = 0;\r\n*val2 = 1465;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nif (chan->type != IIO_ACCEL && chan->type != IIO_MAGN)\r\nreturn -EINVAL;\r\nmutex_lock(&data->lock);\r\nret = kmx61_get_odr(data, val, val2, chan->address);\r\nmutex_unlock(&data->lock);\r\nif (ret)\r\nreturn -EINVAL;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int kmx61_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int val,\r\nint val2, long mask)\r\n{\r\nint ret;\r\nstruct kmx61_data *data = kmx61_get_data(indio_dev);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nif (chan->type != IIO_ACCEL && chan->type != IIO_MAGN)\r\nreturn -EINVAL;\r\nmutex_lock(&data->lock);\r\nret = kmx61_set_odr(data, val, val2, chan->address);\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\ncase IIO_CHAN_INFO_SCALE:\r\nswitch (chan->type) {\r\ncase IIO_ACCEL:\r\nif (val != 0)\r\nreturn -EINVAL;\r\nmutex_lock(&data->lock);\r\nret = kmx61_set_scale(data, val2);\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int kmx61_read_event(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nenum iio_event_info info,\r\nint *val, int *val2)\r\n{\r\nstruct kmx61_data *data = kmx61_get_data(indio_dev);\r\n*val2 = 0;\r\nswitch (info) {\r\ncase IIO_EV_INFO_VALUE:\r\n*val = data->wake_thresh;\r\nreturn IIO_VAL_INT;\r\ncase IIO_EV_INFO_PERIOD:\r\n*val = data->wake_duration;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int kmx61_write_event(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nenum iio_event_info info,\r\nint val, int val2)\r\n{\r\nstruct kmx61_data *data = kmx61_get_data(indio_dev);\r\nif (data->ev_enable_state)\r\nreturn -EBUSY;\r\nswitch (info) {\r\ncase IIO_EV_INFO_VALUE:\r\ndata->wake_thresh = val;\r\nreturn IIO_VAL_INT;\r\ncase IIO_EV_INFO_PERIOD:\r\ndata->wake_duration = val;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int kmx61_read_event_config(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir)\r\n{\r\nstruct kmx61_data *data = kmx61_get_data(indio_dev);\r\nreturn data->ev_enable_state;\r\n}\r\nstatic int kmx61_write_event_config(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nint state)\r\n{\r\nstruct kmx61_data *data = kmx61_get_data(indio_dev);\r\nint ret = 0;\r\nif (state && data->ev_enable_state)\r\nreturn 0;\r\nmutex_lock(&data->lock);\r\nif (!state && data->motion_trig_on) {\r\ndata->ev_enable_state = false;\r\ngoto err_unlock;\r\n}\r\nret = kmx61_set_power_state(data, state, KMX61_ACC);\r\nif (ret < 0)\r\ngoto err_unlock;\r\nret = kmx61_setup_any_motion_interrupt(data, state);\r\nif (ret < 0) {\r\nkmx61_set_power_state(data, false, KMX61_ACC);\r\ngoto err_unlock;\r\n}\r\ndata->ev_enable_state = state;\r\nerr_unlock:\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nstatic int kmx61_acc_validate_trigger(struct iio_dev *indio_dev,\r\nstruct iio_trigger *trig)\r\n{\r\nstruct kmx61_data *data = kmx61_get_data(indio_dev);\r\nif (data->acc_dready_trig != trig && data->motion_trig != trig)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int kmx61_mag_validate_trigger(struct iio_dev *indio_dev,\r\nstruct iio_trigger *trig)\r\n{\r\nstruct kmx61_data *data = kmx61_get_data(indio_dev);\r\nif (data->mag_dready_trig != trig)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int kmx61_data_rdy_trigger_set_state(struct iio_trigger *trig,\r\nbool state)\r\n{\r\nint ret = 0;\r\nu8 device;\r\nstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\r\nstruct kmx61_data *data = kmx61_get_data(indio_dev);\r\nmutex_lock(&data->lock);\r\nif (!state && data->ev_enable_state && data->motion_trig_on) {\r\ndata->motion_trig_on = false;\r\ngoto err_unlock;\r\n}\r\nif (data->acc_dready_trig == trig || data->motion_trig == trig)\r\ndevice = KMX61_ACC;\r\nelse\r\ndevice = KMX61_MAG;\r\nret = kmx61_set_power_state(data, state, device);\r\nif (ret < 0)\r\ngoto err_unlock;\r\nif (data->acc_dready_trig == trig || data->mag_dready_trig == trig)\r\nret = kmx61_setup_new_data_interrupt(data, state, device);\r\nelse\r\nret = kmx61_setup_any_motion_interrupt(data, state);\r\nif (ret < 0) {\r\nkmx61_set_power_state(data, false, device);\r\ngoto err_unlock;\r\n}\r\nif (data->acc_dready_trig == trig)\r\ndata->acc_dready_trig_on = state;\r\nelse if (data->mag_dready_trig == trig)\r\ndata->mag_dready_trig_on = state;\r\nelse\r\ndata->motion_trig_on = state;\r\nerr_unlock:\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nstatic int kmx61_trig_try_reenable(struct iio_trigger *trig)\r\n{\r\nstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\r\nstruct kmx61_data *data = kmx61_get_data(indio_dev);\r\nint ret;\r\nret = i2c_smbus_read_byte_data(data->client, KMX61_REG_INL);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error reading reg_inl\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t kmx61_event_handler(int irq, void *private)\r\n{\r\nstruct kmx61_data *data = private;\r\nstruct iio_dev *indio_dev = data->acc_indio_dev;\r\nint ret;\r\nret = i2c_smbus_read_byte_data(data->client, KMX61_REG_INS1);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error reading reg_ins1\n");\r\ngoto ack_intr;\r\n}\r\nif (ret & KMX61_REG_INS1_BIT_WUFS) {\r\nret = i2c_smbus_read_byte_data(data->client, KMX61_REG_INS2);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "Error reading reg_ins2\n");\r\ngoto ack_intr;\r\n}\r\nif (ret & KMX61_REG_INS2_BIT_XN)\r\niio_push_event(indio_dev,\r\nIIO_MOD_EVENT_CODE(IIO_ACCEL,\r\n0,\r\nIIO_MOD_X,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_FALLING),\r\n0);\r\nif (ret & KMX61_REG_INS2_BIT_XP)\r\niio_push_event(indio_dev,\r\nIIO_MOD_EVENT_CODE(IIO_ACCEL,\r\n0,\r\nIIO_MOD_X,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_RISING),\r\n0);\r\nif (ret & KMX61_REG_INS2_BIT_YN)\r\niio_push_event(indio_dev,\r\nIIO_MOD_EVENT_CODE(IIO_ACCEL,\r\n0,\r\nIIO_MOD_Y,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_FALLING),\r\n0);\r\nif (ret & KMX61_REG_INS2_BIT_YP)\r\niio_push_event(indio_dev,\r\nIIO_MOD_EVENT_CODE(IIO_ACCEL,\r\n0,\r\nIIO_MOD_Y,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_RISING),\r\n0);\r\nif (ret & KMX61_REG_INS2_BIT_ZN)\r\niio_push_event(indio_dev,\r\nIIO_MOD_EVENT_CODE(IIO_ACCEL,\r\n0,\r\nIIO_MOD_Z,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_FALLING),\r\n0);\r\nif (ret & KMX61_REG_INS2_BIT_ZP)\r\niio_push_event(indio_dev,\r\nIIO_MOD_EVENT_CODE(IIO_ACCEL,\r\n0,\r\nIIO_MOD_Z,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_RISING),\r\n0);\r\n}\r\nack_intr:\r\nret = i2c_smbus_read_byte_data(data->client, KMX61_REG_CTRL1);\r\nif (ret < 0)\r\ndev_err(&data->client->dev, "Error reading reg_ctrl1\n");\r\nret |= KMX61_REG_CTRL1_BIT_RES;\r\nret = i2c_smbus_write_byte_data(data->client, KMX61_REG_CTRL1, ret);\r\nif (ret < 0)\r\ndev_err(&data->client->dev, "Error writing reg_ctrl1\n");\r\nret = i2c_smbus_read_byte_data(data->client, KMX61_REG_INL);\r\nif (ret < 0)\r\ndev_err(&data->client->dev, "Error reading reg_inl\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t kmx61_data_rdy_trig_poll(int irq, void *private)\r\n{\r\nstruct kmx61_data *data = private;\r\nif (data->acc_dready_trig_on)\r\niio_trigger_poll(data->acc_dready_trig);\r\nif (data->mag_dready_trig_on)\r\niio_trigger_poll(data->mag_dready_trig);\r\nif (data->motion_trig_on)\r\niio_trigger_poll(data->motion_trig);\r\nif (data->ev_enable_state)\r\nreturn IRQ_WAKE_THREAD;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t kmx61_trigger_handler(int irq, void *p)\r\n{\r\nstruct iio_poll_func *pf = p;\r\nstruct iio_dev *indio_dev = pf->indio_dev;\r\nstruct kmx61_data *data = kmx61_get_data(indio_dev);\r\nint bit, ret, i = 0;\r\nu8 base;\r\ns16 buffer[8];\r\nif (indio_dev == data->acc_indio_dev)\r\nbase = KMX61_ACC_XOUT_L;\r\nelse\r\nbase = KMX61_MAG_XOUT_L;\r\nmutex_lock(&data->lock);\r\nfor_each_set_bit(bit, indio_dev->active_scan_mask,\r\nindio_dev->masklength) {\r\nret = kmx61_read_measurement(data, base, bit);\r\nif (ret < 0) {\r\nmutex_unlock(&data->lock);\r\ngoto err;\r\n}\r\nbuffer[i++] = ret;\r\n}\r\nmutex_unlock(&data->lock);\r\niio_push_to_buffers(indio_dev, buffer);\r\nerr:\r\niio_trigger_notify_done(indio_dev->trig);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic const char *kmx61_match_acpi_device(struct device *dev)\r\n{\r\nconst struct acpi_device_id *id;\r\nid = acpi_match_device(dev->driver->acpi_match_table, dev);\r\nif (!id)\r\nreturn NULL;\r\nreturn dev_name(dev);\r\n}\r\nstatic int kmx61_gpio_probe(struct i2c_client *client, struct kmx61_data *data)\r\n{\r\nstruct device *dev;\r\nstruct gpio_desc *gpio;\r\nint ret;\r\nif (!client)\r\nreturn -EINVAL;\r\ndev = &client->dev;\r\ngpio = devm_gpiod_get_index(dev, KMX61_GPIO_NAME, 0, GPIOD_IN);\r\nif (IS_ERR(gpio)) {\r\ndev_err(dev, "acpi gpio get index failed\n");\r\nreturn PTR_ERR(gpio);\r\n}\r\nret = gpiod_to_irq(gpio);\r\ndev_dbg(dev, "GPIO resource, no:%d irq:%d\n", desc_to_gpio(gpio), ret);\r\nreturn ret;\r\n}\r\nstatic struct iio_dev *kmx61_indiodev_setup(struct kmx61_data *data,\r\nconst struct iio_info *info,\r\nconst struct iio_chan_spec *chan,\r\nint num_channels,\r\nconst char *name)\r\n{\r\nstruct iio_dev *indio_dev;\r\nindio_dev = devm_iio_device_alloc(&data->client->dev, sizeof(data));\r\nif (!indio_dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nkmx61_set_data(indio_dev, data);\r\nindio_dev->dev.parent = &data->client->dev;\r\nindio_dev->channels = chan;\r\nindio_dev->num_channels = num_channels;\r\nindio_dev->name = name;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->info = info;\r\nreturn indio_dev;\r\n}\r\nstatic struct iio_trigger *kmx61_trigger_setup(struct kmx61_data *data,\r\nstruct iio_dev *indio_dev,\r\nconst char *tag)\r\n{\r\nstruct iio_trigger *trig;\r\nint ret;\r\ntrig = devm_iio_trigger_alloc(&data->client->dev,\r\n"%s-%s-dev%d",\r\nindio_dev->name,\r\ntag,\r\nindio_dev->id);\r\nif (!trig)\r\nreturn ERR_PTR(-ENOMEM);\r\ntrig->dev.parent = &data->client->dev;\r\ntrig->ops = &kmx61_trigger_ops;\r\niio_trigger_set_drvdata(trig, indio_dev);\r\nret = iio_trigger_register(trig);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nreturn trig;\r\n}\r\nstatic int kmx61_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret;\r\nstruct kmx61_data *data;\r\nconst char *name = NULL;\r\ndata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\ndata->client = client;\r\nmutex_init(&data->lock);\r\nif (id)\r\nname = id->name;\r\nelse if (ACPI_HANDLE(&client->dev))\r\nname = kmx61_match_acpi_device(&client->dev);\r\nelse\r\nreturn -ENODEV;\r\ndata->acc_indio_dev =\r\nkmx61_indiodev_setup(data, &kmx61_acc_info,\r\nkmx61_acc_channels,\r\nARRAY_SIZE(kmx61_acc_channels),\r\nname);\r\nif (IS_ERR(data->acc_indio_dev))\r\nreturn PTR_ERR(data->acc_indio_dev);\r\ndata->mag_indio_dev =\r\nkmx61_indiodev_setup(data, &kmx61_mag_info,\r\nkmx61_mag_channels,\r\nARRAY_SIZE(kmx61_mag_channels),\r\nname);\r\nif (IS_ERR(data->mag_indio_dev))\r\nreturn PTR_ERR(data->mag_indio_dev);\r\nret = kmx61_chip_init(data);\r\nif (ret < 0)\r\nreturn ret;\r\nif (client->irq < 0)\r\nclient->irq = kmx61_gpio_probe(client, data);\r\nif (client->irq >= 0) {\r\nret = devm_request_threaded_irq(&client->dev, client->irq,\r\nkmx61_data_rdy_trig_poll,\r\nkmx61_event_handler,\r\nIRQF_TRIGGER_RISING,\r\nKMX61_IRQ_NAME,\r\ndata);\r\nif (ret)\r\ngoto err_chip_uninit;\r\ndata->acc_dready_trig =\r\nkmx61_trigger_setup(data, data->acc_indio_dev,\r\n"dready");\r\nif (IS_ERR(data->acc_dready_trig)) {\r\nret = PTR_ERR(data->acc_dready_trig);\r\ngoto err_chip_uninit;\r\n}\r\ndata->mag_dready_trig =\r\nkmx61_trigger_setup(data, data->mag_indio_dev,\r\n"dready");\r\nif (IS_ERR(data->mag_dready_trig)) {\r\nret = PTR_ERR(data->mag_dready_trig);\r\ngoto err_trigger_unregister_acc_dready;\r\n}\r\ndata->motion_trig =\r\nkmx61_trigger_setup(data, data->acc_indio_dev,\r\n"any-motion");\r\nif (IS_ERR(data->motion_trig)) {\r\nret = PTR_ERR(data->motion_trig);\r\ngoto err_trigger_unregister_mag_dready;\r\n}\r\nret = iio_triggered_buffer_setup(data->acc_indio_dev,\r\n&iio_pollfunc_store_time,\r\nkmx61_trigger_handler,\r\nNULL);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev,\r\n"Failed to setup acc triggered buffer\n");\r\ngoto err_trigger_unregister_motion;\r\n}\r\nret = iio_triggered_buffer_setup(data->mag_indio_dev,\r\n&iio_pollfunc_store_time,\r\nkmx61_trigger_handler,\r\nNULL);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev,\r\n"Failed to setup mag triggered buffer\n");\r\ngoto err_buffer_cleanup_acc;\r\n}\r\n}\r\nret = iio_device_register(data->acc_indio_dev);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Failed to register acc iio device\n");\r\ngoto err_buffer_cleanup_mag;\r\n}\r\nret = iio_device_register(data->mag_indio_dev);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Failed to register mag iio device\n");\r\ngoto err_iio_unregister_acc;\r\n}\r\nret = pm_runtime_set_active(&client->dev);\r\nif (ret < 0)\r\ngoto err_iio_unregister_mag;\r\npm_runtime_enable(&client->dev);\r\npm_runtime_set_autosuspend_delay(&client->dev, KMX61_SLEEP_DELAY_MS);\r\npm_runtime_use_autosuspend(&client->dev);\r\nreturn 0;\r\nerr_iio_unregister_mag:\r\niio_device_unregister(data->mag_indio_dev);\r\nerr_iio_unregister_acc:\r\niio_device_unregister(data->acc_indio_dev);\r\nerr_buffer_cleanup_mag:\r\nif (client->irq >= 0)\r\niio_triggered_buffer_cleanup(data->mag_indio_dev);\r\nerr_buffer_cleanup_acc:\r\nif (client->irq >= 0)\r\niio_triggered_buffer_cleanup(data->acc_indio_dev);\r\nerr_trigger_unregister_motion:\r\niio_trigger_unregister(data->motion_trig);\r\nerr_trigger_unregister_mag_dready:\r\niio_trigger_unregister(data->mag_dready_trig);\r\nerr_trigger_unregister_acc_dready:\r\niio_trigger_unregister(data->acc_dready_trig);\r\nerr_chip_uninit:\r\nkmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG, true);\r\nreturn ret;\r\n}\r\nstatic int kmx61_remove(struct i2c_client *client)\r\n{\r\nstruct kmx61_data *data = i2c_get_clientdata(client);\r\npm_runtime_disable(&client->dev);\r\npm_runtime_set_suspended(&client->dev);\r\npm_runtime_put_noidle(&client->dev);\r\niio_device_unregister(data->acc_indio_dev);\r\niio_device_unregister(data->mag_indio_dev);\r\nif (client->irq >= 0) {\r\niio_triggered_buffer_cleanup(data->acc_indio_dev);\r\niio_triggered_buffer_cleanup(data->mag_indio_dev);\r\niio_trigger_unregister(data->acc_dready_trig);\r\niio_trigger_unregister(data->mag_dready_trig);\r\niio_trigger_unregister(data->motion_trig);\r\n}\r\nmutex_lock(&data->lock);\r\nkmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG, true);\r\nmutex_unlock(&data->lock);\r\nreturn 0;\r\n}\r\nstatic int kmx61_suspend(struct device *dev)\r\n{\r\nint ret;\r\nstruct kmx61_data *data = i2c_get_clientdata(to_i2c_client(dev));\r\nmutex_lock(&data->lock);\r\nret = kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG,\r\nfalse);\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nstatic int kmx61_resume(struct device *dev)\r\n{\r\nu8 stby = 0;\r\nstruct kmx61_data *data = i2c_get_clientdata(to_i2c_client(dev));\r\nif (data->acc_stby)\r\nstby |= KMX61_ACC_STBY_BIT;\r\nif (data->mag_stby)\r\nstby |= KMX61_MAG_STBY_BIT;\r\nreturn kmx61_set_mode(data, stby, KMX61_ACC | KMX61_MAG, true);\r\n}\r\nstatic int kmx61_runtime_suspend(struct device *dev)\r\n{\r\nstruct kmx61_data *data = i2c_get_clientdata(to_i2c_client(dev));\r\nint ret;\r\nmutex_lock(&data->lock);\r\nret = kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG, true);\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nstatic int kmx61_runtime_resume(struct device *dev)\r\n{\r\nstruct kmx61_data *data = i2c_get_clientdata(to_i2c_client(dev));\r\nu8 stby = 0;\r\nif (!data->acc_ps)\r\nstby |= KMX61_ACC_STBY_BIT;\r\nif (!data->mag_ps)\r\nstby |= KMX61_MAG_STBY_BIT;\r\nreturn kmx61_set_mode(data, stby, KMX61_ACC | KMX61_MAG, true);\r\n}
