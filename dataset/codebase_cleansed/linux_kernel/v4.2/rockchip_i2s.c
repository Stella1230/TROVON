static int i2s_runtime_suspend(struct device *dev)\r\n{\r\nstruct rk_i2s_dev *i2s = dev_get_drvdata(dev);\r\nclk_disable_unprepare(i2s->mclk);\r\nreturn 0;\r\n}\r\nstatic int i2s_runtime_resume(struct device *dev)\r\n{\r\nstruct rk_i2s_dev *i2s = dev_get_drvdata(dev);\r\nint ret;\r\nret = clk_prepare_enable(i2s->mclk);\r\nif (ret) {\r\ndev_err(i2s->dev, "clock enable failed %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline struct rk_i2s_dev *to_info(struct snd_soc_dai *dai)\r\n{\r\nreturn snd_soc_dai_get_drvdata(dai);\r\n}\r\nstatic void rockchip_snd_txctrl(struct rk_i2s_dev *i2s, int on)\r\n{\r\nunsigned int val = 0;\r\nint retry = 10;\r\nif (on) {\r\nregmap_update_bits(i2s->regmap, I2S_DMACR,\r\nI2S_DMACR_TDE_ENABLE, I2S_DMACR_TDE_ENABLE);\r\nregmap_update_bits(i2s->regmap, I2S_XFER,\r\nI2S_XFER_TXS_START | I2S_XFER_RXS_START,\r\nI2S_XFER_TXS_START | I2S_XFER_RXS_START);\r\ni2s->tx_start = true;\r\n} else {\r\ni2s->tx_start = false;\r\nregmap_update_bits(i2s->regmap, I2S_DMACR,\r\nI2S_DMACR_TDE_ENABLE, I2S_DMACR_TDE_DISABLE);\r\nif (!i2s->rx_start) {\r\nregmap_update_bits(i2s->regmap, I2S_XFER,\r\nI2S_XFER_TXS_START |\r\nI2S_XFER_RXS_START,\r\nI2S_XFER_TXS_STOP |\r\nI2S_XFER_RXS_STOP);\r\nregmap_update_bits(i2s->regmap, I2S_CLR,\r\nI2S_CLR_TXC | I2S_CLR_RXC,\r\nI2S_CLR_TXC | I2S_CLR_RXC);\r\nregmap_read(i2s->regmap, I2S_CLR, &val);\r\nwhile (val) {\r\nregmap_read(i2s->regmap, I2S_CLR, &val);\r\nretry--;\r\nif (!retry) {\r\ndev_warn(i2s->dev, "fail to clear\n");\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic void rockchip_snd_rxctrl(struct rk_i2s_dev *i2s, int on)\r\n{\r\nunsigned int val = 0;\r\nint retry = 10;\r\nif (on) {\r\nregmap_update_bits(i2s->regmap, I2S_DMACR,\r\nI2S_DMACR_RDE_ENABLE, I2S_DMACR_RDE_ENABLE);\r\nregmap_update_bits(i2s->regmap, I2S_XFER,\r\nI2S_XFER_TXS_START | I2S_XFER_RXS_START,\r\nI2S_XFER_TXS_START | I2S_XFER_RXS_START);\r\ni2s->rx_start = true;\r\n} else {\r\ni2s->rx_start = false;\r\nregmap_update_bits(i2s->regmap, I2S_DMACR,\r\nI2S_DMACR_RDE_ENABLE, I2S_DMACR_RDE_DISABLE);\r\nif (!i2s->tx_start) {\r\nregmap_update_bits(i2s->regmap, I2S_XFER,\r\nI2S_XFER_TXS_START |\r\nI2S_XFER_RXS_START,\r\nI2S_XFER_TXS_STOP |\r\nI2S_XFER_RXS_STOP);\r\nregmap_update_bits(i2s->regmap, I2S_CLR,\r\nI2S_CLR_TXC | I2S_CLR_RXC,\r\nI2S_CLR_TXC | I2S_CLR_RXC);\r\nregmap_read(i2s->regmap, I2S_CLR, &val);\r\nwhile (val) {\r\nregmap_read(i2s->regmap, I2S_CLR, &val);\r\nretry--;\r\nif (!retry) {\r\ndev_warn(i2s->dev, "fail to clear\n");\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic int rockchip_i2s_set_fmt(struct snd_soc_dai *cpu_dai,\r\nunsigned int fmt)\r\n{\r\nstruct rk_i2s_dev *i2s = to_info(cpu_dai);\r\nunsigned int mask = 0, val = 0;\r\nmask = I2S_CKR_MSS_MASK;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nval = I2S_CKR_MSS_MASTER;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nval = I2S_CKR_MSS_SLAVE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(i2s->regmap, I2S_CKR, mask, val);\r\nmask = I2S_TXCR_IBM_MASK;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nval = I2S_TXCR_IBM_RSJM;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nval = I2S_TXCR_IBM_LSJM;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\nval = I2S_TXCR_IBM_NORMAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(i2s->regmap, I2S_TXCR, mask, val);\r\nmask = I2S_RXCR_IBM_MASK;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nval = I2S_RXCR_IBM_RSJM;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nval = I2S_RXCR_IBM_LSJM;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\nval = I2S_RXCR_IBM_NORMAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(i2s->regmap, I2S_RXCR, mask, val);\r\nreturn 0;\r\n}\r\nstatic int rockchip_i2s_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct rk_i2s_dev *i2s = to_info(dai);\r\nunsigned int val = 0;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S8:\r\nval |= I2S_TXCR_VDW(8);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nval |= I2S_TXCR_VDW(16);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\nval |= I2S_TXCR_VDW(20);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nval |= I2S_TXCR_VDW(24);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(i2s->regmap, I2S_TXCR, I2S_TXCR_VDW_MASK, val);\r\nregmap_update_bits(i2s->regmap, I2S_RXCR, I2S_RXCR_VDW_MASK, val);\r\nregmap_update_bits(i2s->regmap, I2S_DMACR, I2S_DMACR_TDL_MASK,\r\nI2S_DMACR_TDL(16));\r\nregmap_update_bits(i2s->regmap, I2S_DMACR, I2S_DMACR_RDL_MASK,\r\nI2S_DMACR_RDL(16));\r\nreturn 0;\r\n}\r\nstatic int rockchip_i2s_trigger(struct snd_pcm_substream *substream,\r\nint cmd, struct snd_soc_dai *dai)\r\n{\r\nstruct rk_i2s_dev *i2s = to_info(dai);\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\nrockchip_snd_rxctrl(i2s, 1);\r\nelse\r\nrockchip_snd_txctrl(i2s, 1);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\nrockchip_snd_rxctrl(i2s, 0);\r\nelse\r\nrockchip_snd_txctrl(i2s, 0);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rockchip_i2s_set_sysclk(struct snd_soc_dai *cpu_dai, int clk_id,\r\nunsigned int freq, int dir)\r\n{\r\nstruct rk_i2s_dev *i2s = to_info(cpu_dai);\r\nint ret;\r\nret = clk_set_rate(i2s->mclk, freq);\r\nif (ret)\r\ndev_err(i2s->dev, "Fail to set mclk %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rockchip_i2s_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct rk_i2s_dev *i2s = snd_soc_dai_get_drvdata(dai);\r\ndai->capture_dma_data = &i2s->capture_dma_data;\r\ndai->playback_dma_data = &i2s->playback_dma_data;\r\nreturn 0;\r\n}\r\nstatic bool rockchip_i2s_wr_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase I2S_TXCR:\r\ncase I2S_RXCR:\r\ncase I2S_CKR:\r\ncase I2S_DMACR:\r\ncase I2S_INTCR:\r\ncase I2S_XFER:\r\ncase I2S_CLR:\r\ncase I2S_TXDR:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool rockchip_i2s_rd_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase I2S_TXCR:\r\ncase I2S_RXCR:\r\ncase I2S_CKR:\r\ncase I2S_DMACR:\r\ncase I2S_INTCR:\r\ncase I2S_XFER:\r\ncase I2S_CLR:\r\ncase I2S_RXDR:\r\ncase I2S_FIFOLR:\r\ncase I2S_INTSR:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool rockchip_i2s_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase I2S_INTSR:\r\ncase I2S_CLR:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool rockchip_i2s_precious_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int rockchip_i2s_probe(struct platform_device *pdev)\r\n{\r\nstruct rk_i2s_dev *i2s;\r\nstruct resource *res;\r\nvoid __iomem *regs;\r\nint ret;\r\ni2s = devm_kzalloc(&pdev->dev, sizeof(*i2s), GFP_KERNEL);\r\nif (!i2s) {\r\ndev_err(&pdev->dev, "Can't allocate rk_i2s_dev\n");\r\nreturn -ENOMEM;\r\n}\r\ni2s->hclk = devm_clk_get(&pdev->dev, "i2s_hclk");\r\nif (IS_ERR(i2s->hclk)) {\r\ndev_err(&pdev->dev, "Can't retrieve i2s bus clock\n");\r\nreturn PTR_ERR(i2s->hclk);\r\n}\r\nret = clk_prepare_enable(i2s->hclk);\r\nif (ret) {\r\ndev_err(i2s->dev, "hclock enable failed %d\n", ret);\r\nreturn ret;\r\n}\r\ni2s->mclk = devm_clk_get(&pdev->dev, "i2s_clk");\r\nif (IS_ERR(i2s->mclk)) {\r\ndev_err(&pdev->dev, "Can't retrieve i2s master clock\n");\r\nreturn PTR_ERR(i2s->mclk);\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nregs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(regs))\r\nreturn PTR_ERR(regs);\r\ni2s->regmap = devm_regmap_init_mmio(&pdev->dev, regs,\r\n&rockchip_i2s_regmap_config);\r\nif (IS_ERR(i2s->regmap)) {\r\ndev_err(&pdev->dev,\r\n"Failed to initialise managed register map\n");\r\nreturn PTR_ERR(i2s->regmap);\r\n}\r\ni2s->playback_dma_data.addr = res->start + I2S_TXDR;\r\ni2s->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\ni2s->playback_dma_data.maxburst = 4;\r\ni2s->capture_dma_data.addr = res->start + I2S_RXDR;\r\ni2s->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\ni2s->capture_dma_data.maxburst = 4;\r\ni2s->dev = &pdev->dev;\r\ndev_set_drvdata(&pdev->dev, i2s);\r\npm_runtime_enable(&pdev->dev);\r\nif (!pm_runtime_enabled(&pdev->dev)) {\r\nret = i2s_runtime_resume(&pdev->dev);\r\nif (ret)\r\ngoto err_pm_disable;\r\n}\r\nret = devm_snd_soc_register_component(&pdev->dev,\r\n&rockchip_i2s_component,\r\n&rockchip_i2s_dai, 1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Could not register DAI\n");\r\ngoto err_suspend;\r\n}\r\nret = snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Could not register PCM\n");\r\ngoto err_pcm_register;\r\n}\r\nreturn 0;\r\nerr_pcm_register:\r\nsnd_dmaengine_pcm_unregister(&pdev->dev);\r\nerr_suspend:\r\nif (!pm_runtime_status_suspended(&pdev->dev))\r\ni2s_runtime_suspend(&pdev->dev);\r\nerr_pm_disable:\r\npm_runtime_disable(&pdev->dev);\r\nreturn ret;\r\n}\r\nstatic int rockchip_i2s_remove(struct platform_device *pdev)\r\n{\r\nstruct rk_i2s_dev *i2s = dev_get_drvdata(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nif (!pm_runtime_status_suspended(&pdev->dev))\r\ni2s_runtime_suspend(&pdev->dev);\r\nclk_disable_unprepare(i2s->mclk);\r\nclk_disable_unprepare(i2s->hclk);\r\nsnd_dmaengine_pcm_unregister(&pdev->dev);\r\nsnd_soc_unregister_component(&pdev->dev);\r\nreturn 0;\r\n}
