unsigned int\r\nBBuGetFrameTime(\r\nunsigned char byPreambleType,\r\nunsigned char byPktType,\r\nunsigned int cbFrameLength,\r\nunsigned short wRate\r\n)\r\n{\r\nunsigned int uFrameTime;\r\nunsigned int uPreamble;\r\nunsigned int uTmp;\r\nunsigned int uRateIdx = (unsigned int) wRate;\r\nunsigned int uRate = 0;\r\nif (uRateIdx > RATE_54M) {\r\nASSERT(0);\r\nreturn 0;\r\n}\r\nuRate = (unsigned int)awcFrameTime[uRateIdx];\r\nif (uRateIdx <= 3) {\r\nif (byPreambleType == 1)\r\nuPreamble = 96;\r\nelse\r\nuPreamble = 192;\r\nuFrameTime = (cbFrameLength * 80) / uRate;\r\nuTmp = (uFrameTime * uRate) / 80;\r\nif (cbFrameLength != uTmp)\r\nuFrameTime++;\r\nreturn uPreamble + uFrameTime;\r\n}\r\nuFrameTime = (cbFrameLength * 8 + 22) / uRate;\r\nuTmp = ((uFrameTime * uRate) - 22) / 8;\r\nif (cbFrameLength != uTmp)\r\nuFrameTime++;\r\nuFrameTime = uFrameTime * 4;\r\nif (byPktType != PK_TYPE_11A)\r\nuFrameTime += 6;\r\nreturn 20 + uFrameTime;\r\n}\r\nvoid vnt_get_phy_field(struct vnt_private *priv, u32 frame_length,\r\nu16 tx_rate, u8 pkt_type, struct vnt_phy_field *phy)\r\n{\r\nu32 bit_count;\r\nu32 count = 0;\r\nu32 tmp;\r\nint ext_bit;\r\nu8 preamble_type = priv->byPreambleType;\r\nbit_count = frame_length * 8;\r\next_bit = false;\r\nswitch (tx_rate) {\r\ncase RATE_1M:\r\ncount = bit_count;\r\nphy->signal = 0x00;\r\nbreak;\r\ncase RATE_2M:\r\ncount = bit_count / 2;\r\nif (preamble_type == 1)\r\nphy->signal = 0x09;\r\nelse\r\nphy->signal = 0x01;\r\nbreak;\r\ncase RATE_5M:\r\ncount = (bit_count * 10) / 55;\r\ntmp = (count * 55) / 10;\r\nif (tmp != bit_count)\r\ncount++;\r\nif (preamble_type == 1)\r\nphy->signal = 0x0a;\r\nelse\r\nphy->signal = 0x02;\r\nbreak;\r\ncase RATE_11M:\r\ncount = bit_count / 11;\r\ntmp = count * 11;\r\nif (tmp != bit_count) {\r\ncount++;\r\nif ((bit_count - tmp) <= 3)\r\next_bit = true;\r\n}\r\nif (preamble_type == 1)\r\nphy->signal = 0x0b;\r\nelse\r\nphy->signal = 0x03;\r\nbreak;\r\ncase RATE_6M:\r\nif (pkt_type == PK_TYPE_11A)\r\nphy->signal = 0x9b;\r\nelse\r\nphy->signal = 0x8b;\r\nbreak;\r\ncase RATE_9M:\r\nif (pkt_type == PK_TYPE_11A)\r\nphy->signal = 0x9f;\r\nelse\r\nphy->signal = 0x8f;\r\nbreak;\r\ncase RATE_12M:\r\nif (pkt_type == PK_TYPE_11A)\r\nphy->signal = 0x9a;\r\nelse\r\nphy->signal = 0x8a;\r\nbreak;\r\ncase RATE_18M:\r\nif (pkt_type == PK_TYPE_11A)\r\nphy->signal = 0x9e;\r\nelse\r\nphy->signal = 0x8e;\r\nbreak;\r\ncase RATE_24M:\r\nif (pkt_type == PK_TYPE_11A)\r\nphy->signal = 0x99;\r\nelse\r\nphy->signal = 0x89;\r\nbreak;\r\ncase RATE_36M:\r\nif (pkt_type == PK_TYPE_11A)\r\nphy->signal = 0x9d;\r\nelse\r\nphy->signal = 0x8d;\r\nbreak;\r\ncase RATE_48M:\r\nif (pkt_type == PK_TYPE_11A)\r\nphy->signal = 0x98;\r\nelse\r\nphy->signal = 0x88;\r\nbreak;\r\ncase RATE_54M:\r\nif (pkt_type == PK_TYPE_11A)\r\nphy->signal = 0x9c;\r\nelse\r\nphy->signal = 0x8c;\r\nbreak;\r\ndefault:\r\nif (pkt_type == PK_TYPE_11A)\r\nphy->signal = 0x9c;\r\nelse\r\nphy->signal = 0x8c;\r\nbreak;\r\n}\r\nif (pkt_type == PK_TYPE_11B) {\r\nphy->service = 0x00;\r\nif (ext_bit)\r\nphy->service |= 0x80;\r\nphy->len = cpu_to_le16((u16)count);\r\n} else {\r\nphy->service = 0x00;\r\nphy->len = cpu_to_le16((u16)frame_length);\r\n}\r\n}\r\nbool BBbReadEmbedded(struct vnt_private *priv,\r\nunsigned char byBBAddr, unsigned char *pbyData)\r\n{\r\nvoid __iomem *dwIoBase = priv->PortOffset;\r\nunsigned short ww;\r\nunsigned char byValue;\r\nVNSvOutPortB(dwIoBase + MAC_REG_BBREGADR, byBBAddr);\r\nMACvRegBitsOn(dwIoBase, MAC_REG_BBREGCTL, BBREGCTL_REGR);\r\nfor (ww = 0; ww < W_MAX_TIMEOUT; ww++) {\r\nVNSvInPortB(dwIoBase + MAC_REG_BBREGCTL, &byValue);\r\nif (byValue & BBREGCTL_DONE)\r\nbreak;\r\n}\r\nVNSvInPortB(dwIoBase + MAC_REG_BBREGDATA, pbyData);\r\nif (ww == W_MAX_TIMEOUT) {\r\nDBG_PORT80(0x30);\r\npr_debug(" DBG_PORT80(0x30)\n");\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nbool BBbWriteEmbedded(struct vnt_private *priv,\r\nunsigned char byBBAddr, unsigned char byData)\r\n{\r\nvoid __iomem *dwIoBase = priv->PortOffset;\r\nunsigned short ww;\r\nunsigned char byValue;\r\nVNSvOutPortB(dwIoBase + MAC_REG_BBREGADR, byBBAddr);\r\nVNSvOutPortB(dwIoBase + MAC_REG_BBREGDATA, byData);\r\nMACvRegBitsOn(dwIoBase, MAC_REG_BBREGCTL, BBREGCTL_REGW);\r\nfor (ww = 0; ww < W_MAX_TIMEOUT; ww++) {\r\nVNSvInPortB(dwIoBase + MAC_REG_BBREGCTL, &byValue);\r\nif (byValue & BBREGCTL_DONE)\r\nbreak;\r\n}\r\nif (ww == W_MAX_TIMEOUT) {\r\nDBG_PORT80(0x31);\r\npr_debug(" DBG_PORT80(0x31)\n");\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nbool BBbVT3253Init(struct vnt_private *priv)\r\n{\r\nbool bResult = true;\r\nint ii;\r\nvoid __iomem *dwIoBase = priv->PortOffset;\r\nunsigned char byRFType = priv->byRFType;\r\nunsigned char byLocalID = priv->byLocalID;\r\nif (byRFType == RF_RFMD2959) {\r\nif (byLocalID <= REV_ID_VT3253_A1) {\r\nfor (ii = 0; ii < CB_VT3253_INIT_FOR_RFMD; ii++)\r\nbResult &= BBbWriteEmbedded(priv,\r\nbyVT3253InitTab_RFMD[ii][0],\r\nbyVT3253InitTab_RFMD[ii][1]);\r\n} else {\r\nfor (ii = 0; ii < CB_VT3253B0_INIT_FOR_RFMD; ii++)\r\nbResult &= BBbWriteEmbedded(priv,\r\nbyVT3253B0_RFMD[ii][0],\r\nbyVT3253B0_RFMD[ii][1]);\r\nfor (ii = 0; ii < CB_VT3253B0_AGC_FOR_RFMD2959; ii++)\r\nbResult &= BBbWriteEmbedded(priv,\r\nbyVT3253B0_AGC4_RFMD2959[ii][0],\r\nbyVT3253B0_AGC4_RFMD2959[ii][1]);\r\nVNSvOutPortD(dwIoBase + MAC_REG_ITRTMSET, 0x23);\r\nMACvRegBitsOn(dwIoBase, MAC_REG_PAPEDELAY, BIT(0));\r\n}\r\npriv->abyBBVGA[0] = 0x18;\r\npriv->abyBBVGA[1] = 0x0A;\r\npriv->abyBBVGA[2] = 0x0;\r\npriv->abyBBVGA[3] = 0x0;\r\npriv->ldBmThreshold[0] = -70;\r\npriv->ldBmThreshold[1] = -50;\r\npriv->ldBmThreshold[2] = 0;\r\npriv->ldBmThreshold[3] = 0;\r\n} else if ((byRFType == RF_AIROHA) || (byRFType == RF_AL2230S)) {\r\nfor (ii = 0; ii < CB_VT3253B0_INIT_FOR_AIROHA2230; ii++)\r\nbResult &= BBbWriteEmbedded(priv,\r\nbyVT3253B0_AIROHA2230[ii][0],\r\nbyVT3253B0_AIROHA2230[ii][1]);\r\nfor (ii = 0; ii < CB_VT3253B0_AGC; ii++)\r\nbResult &= BBbWriteEmbedded(priv,\r\nbyVT3253B0_AGC[ii][0], byVT3253B0_AGC[ii][1]);\r\npriv->abyBBVGA[0] = 0x1C;\r\npriv->abyBBVGA[1] = 0x10;\r\npriv->abyBBVGA[2] = 0x0;\r\npriv->abyBBVGA[3] = 0x0;\r\npriv->ldBmThreshold[0] = -70;\r\npriv->ldBmThreshold[1] = -48;\r\npriv->ldBmThreshold[2] = 0;\r\npriv->ldBmThreshold[3] = 0;\r\n} else if (byRFType == RF_UW2451) {\r\nfor (ii = 0; ii < CB_VT3253B0_INIT_FOR_UW2451; ii++)\r\nbResult &= BBbWriteEmbedded(priv,\r\nbyVT3253B0_UW2451[ii][0],\r\nbyVT3253B0_UW2451[ii][1]);\r\nfor (ii = 0; ii < CB_VT3253B0_AGC; ii++)\r\nbResult &= BBbWriteEmbedded(priv,\r\nbyVT3253B0_AGC[ii][0],\r\nbyVT3253B0_AGC[ii][1]);\r\nVNSvOutPortB(dwIoBase + MAC_REG_ITRTMSET, 0x23);\r\nMACvRegBitsOn(dwIoBase, MAC_REG_PAPEDELAY, BIT(0));\r\npriv->abyBBVGA[0] = 0x14;\r\npriv->abyBBVGA[1] = 0x0A;\r\npriv->abyBBVGA[2] = 0x0;\r\npriv->abyBBVGA[3] = 0x0;\r\npriv->ldBmThreshold[0] = -60;\r\npriv->ldBmThreshold[1] = -50;\r\npriv->ldBmThreshold[2] = 0;\r\npriv->ldBmThreshold[3] = 0;\r\n} else if (byRFType == RF_UW2452) {\r\nfor (ii = 0; ii < CB_VT3253B0_INIT_FOR_UW2451; ii++)\r\nbResult &= BBbWriteEmbedded(priv,\r\nbyVT3253B0_UW2451[ii][0],\r\nbyVT3253B0_UW2451[ii][1]);\r\nbResult &= BBbWriteEmbedded(priv, 0xd7, 0x06);\r\nbResult &= BBbWriteEmbedded(priv, 0x90, 0x20);\r\nbResult &= BBbWriteEmbedded(priv, 0x97, 0xeb);\r\nbResult &= BBbWriteEmbedded(priv, 0xa6, 0x00);\r\nbResult &= BBbWriteEmbedded(priv, 0xa8, 0x30);\r\nbResult &= BBbWriteEmbedded(priv, 0xb0, 0x58);\r\nfor (ii = 0; ii < CB_VT3253B0_AGC; ii++)\r\nbResult &= BBbWriteEmbedded(priv,\r\nbyVT3253B0_AGC[ii][0], byVT3253B0_AGC[ii][1]);\r\npriv->abyBBVGA[0] = 0x14;\r\npriv->abyBBVGA[1] = 0x0A;\r\npriv->abyBBVGA[2] = 0x0;\r\npriv->abyBBVGA[3] = 0x0;\r\npriv->ldBmThreshold[0] = -60;\r\npriv->ldBmThreshold[1] = -50;\r\npriv->ldBmThreshold[2] = 0;\r\npriv->ldBmThreshold[3] = 0;\r\n} else if (byRFType == RF_VT3226) {\r\nfor (ii = 0; ii < CB_VT3253B0_INIT_FOR_AIROHA2230; ii++)\r\nbResult &= BBbWriteEmbedded(priv,\r\nbyVT3253B0_AIROHA2230[ii][0],\r\nbyVT3253B0_AIROHA2230[ii][1]);\r\nfor (ii = 0; ii < CB_VT3253B0_AGC; ii++)\r\nbResult &= BBbWriteEmbedded(priv,\r\nbyVT3253B0_AGC[ii][0], byVT3253B0_AGC[ii][1]);\r\npriv->abyBBVGA[0] = 0x1C;\r\npriv->abyBBVGA[1] = 0x10;\r\npriv->abyBBVGA[2] = 0x0;\r\npriv->abyBBVGA[3] = 0x0;\r\npriv->ldBmThreshold[0] = -70;\r\npriv->ldBmThreshold[1] = -48;\r\npriv->ldBmThreshold[2] = 0;\r\npriv->ldBmThreshold[3] = 0;\r\nMACvSetRFLE_LatchBase(dwIoBase);\r\n} else if (byRFType == RF_AIROHA7230) {\r\nfor (ii = 0; ii < CB_VT3253B0_INIT_FOR_AIROHA2230; ii++)\r\nbResult &= BBbWriteEmbedded(priv,\r\nbyVT3253B0_AIROHA2230[ii][0],\r\nbyVT3253B0_AIROHA2230[ii][1]);\r\nbResult &= BBbWriteEmbedded(priv, 0xd7, 0x06);\r\nfor (ii = 0; ii < CB_VT3253B0_AGC; ii++)\r\nbResult &= BBbWriteEmbedded(priv,\r\nbyVT3253B0_AGC[ii][0], byVT3253B0_AGC[ii][1]);\r\npriv->abyBBVGA[0] = 0x1C;\r\npriv->abyBBVGA[1] = 0x10;\r\npriv->abyBBVGA[2] = 0x0;\r\npriv->abyBBVGA[3] = 0x0;\r\npriv->ldBmThreshold[0] = -70;\r\npriv->ldBmThreshold[1] = -48;\r\npriv->ldBmThreshold[2] = 0;\r\npriv->ldBmThreshold[3] = 0;\r\n} else {\r\npriv->bUpdateBBVGA = false;\r\npriv->abyBBVGA[0] = 0x1C;\r\n}\r\nif (byLocalID > REV_ID_VT3253_A1) {\r\nBBbWriteEmbedded(priv, 0x04, 0x7F);\r\nBBbWriteEmbedded(priv, 0x0D, 0x01);\r\n}\r\nreturn bResult;\r\n}\r\nvoid\r\nBBvSetShortSlotTime(struct vnt_private *priv)\r\n{\r\nunsigned char byBBRxConf = 0;\r\nunsigned char byBBVGA = 0;\r\nBBbReadEmbedded(priv, 0x0A, &byBBRxConf);\r\nif (priv->bShortSlotTime)\r\nbyBBRxConf &= 0xDF;\r\nelse\r\nbyBBRxConf |= 0x20;\r\nBBbReadEmbedded(priv, 0xE7, &byBBVGA);\r\nif (byBBVGA == priv->abyBBVGA[0])\r\nbyBBRxConf |= 0x20;\r\nBBbWriteEmbedded(priv, 0x0A, byBBRxConf);\r\n}\r\nvoid BBvSetVGAGainOffset(struct vnt_private *priv, unsigned char byData)\r\n{\r\nunsigned char byBBRxConf = 0;\r\nBBbWriteEmbedded(priv, 0xE7, byData);\r\nBBbReadEmbedded(priv, 0x0A, &byBBRxConf);\r\nif (byData == priv->abyBBVGA[0])\r\nbyBBRxConf |= 0x20;\r\nelse if (priv->bShortSlotTime)\r\nbyBBRxConf &= 0xDF;\r\nelse\r\nbyBBRxConf |= 0x20;\r\npriv->byBBVGACurrent = byData;\r\nBBbWriteEmbedded(priv, 0x0A, byBBRxConf);\r\n}\r\nvoid\r\nBBvSoftwareReset(struct vnt_private *priv)\r\n{\r\nBBbWriteEmbedded(priv, 0x50, 0x40);\r\nBBbWriteEmbedded(priv, 0x50, 0);\r\nBBbWriteEmbedded(priv, 0x9C, 0x01);\r\nBBbWriteEmbedded(priv, 0x9C, 0);\r\n}\r\nvoid\r\nBBvPowerSaveModeON(struct vnt_private *priv)\r\n{\r\nunsigned char byOrgData;\r\nBBbReadEmbedded(priv, 0x0D, &byOrgData);\r\nbyOrgData |= BIT(0);\r\nBBbWriteEmbedded(priv, 0x0D, byOrgData);\r\n}\r\nvoid\r\nBBvPowerSaveModeOFF(struct vnt_private *priv)\r\n{\r\nunsigned char byOrgData;\r\nBBbReadEmbedded(priv, 0x0D, &byOrgData);\r\nbyOrgData &= ~(BIT(0));\r\nBBbWriteEmbedded(priv, 0x0D, byOrgData);\r\n}\r\nvoid\r\nBBvSetTxAntennaMode(struct vnt_private *priv, unsigned char byAntennaMode)\r\n{\r\nunsigned char byBBTxConf;\r\nBBbReadEmbedded(priv, 0x09, &byBBTxConf);\r\nif (byAntennaMode == ANT_DIVERSITY) {\r\nbyBBTxConf |= 0x02;\r\n} else if (byAntennaMode == ANT_A) {\r\nbyBBTxConf &= 0xF9;\r\n} else if (byAntennaMode == ANT_B) {\r\nbyBBTxConf &= 0xFD;\r\nbyBBTxConf |= 0x04;\r\n}\r\nBBbWriteEmbedded(priv, 0x09, byBBTxConf);\r\n}\r\nvoid\r\nBBvSetRxAntennaMode(struct vnt_private *priv, unsigned char byAntennaMode)\r\n{\r\nunsigned char byBBRxConf;\r\nBBbReadEmbedded(priv, 0x0A, &byBBRxConf);\r\nif (byAntennaMode == ANT_DIVERSITY) {\r\nbyBBRxConf |= 0x01;\r\n} else if (byAntennaMode == ANT_A) {\r\nbyBBRxConf &= 0xFC;\r\n} else if (byAntennaMode == ANT_B) {\r\nbyBBRxConf &= 0xFE;\r\nbyBBRxConf |= 0x02;\r\n}\r\nBBbWriteEmbedded(priv, 0x0A, byBBRxConf);\r\n}\r\nvoid\r\nBBvSetDeepSleep(struct vnt_private *priv, unsigned char byLocalID)\r\n{\r\nBBbWriteEmbedded(priv, 0x0C, 0x17);\r\nBBbWriteEmbedded(priv, 0x0D, 0xB9);\r\n}\r\nvoid\r\nBBvExitDeepSleep(struct vnt_private *priv, unsigned char byLocalID)\r\n{\r\nBBbWriteEmbedded(priv, 0x0C, 0x00);\r\nBBbWriteEmbedded(priv, 0x0D, 0x01);\r\n}
