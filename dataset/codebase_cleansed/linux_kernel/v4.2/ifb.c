static void ri_tasklet(unsigned long dev)\r\n{\r\nstruct net_device *_dev = (struct net_device *)dev;\r\nstruct ifb_private *dp = netdev_priv(_dev);\r\nstruct netdev_queue *txq;\r\nstruct sk_buff *skb;\r\ntxq = netdev_get_tx_queue(_dev, 0);\r\nif ((skb = skb_peek(&dp->tq)) == NULL) {\r\nif (__netif_tx_trylock(txq)) {\r\nskb_queue_splice_tail_init(&dp->rq, &dp->tq);\r\n__netif_tx_unlock(txq);\r\n} else {\r\ngoto resched;\r\n}\r\n}\r\nwhile ((skb = __skb_dequeue(&dp->tq)) != NULL) {\r\nu32 from = G_TC_FROM(skb->tc_verd);\r\nskb->tc_verd = 0;\r\nskb->tc_verd = SET_TC_NCLS(skb->tc_verd);\r\nu64_stats_update_begin(&dp->tsync);\r\ndp->tx_packets++;\r\ndp->tx_bytes += skb->len;\r\nu64_stats_update_end(&dp->tsync);\r\nrcu_read_lock();\r\nskb->dev = dev_get_by_index_rcu(dev_net(_dev), skb->skb_iif);\r\nif (!skb->dev) {\r\nrcu_read_unlock();\r\ndev_kfree_skb(skb);\r\n_dev->stats.tx_dropped++;\r\nif (skb_queue_len(&dp->tq) != 0)\r\ngoto resched;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nskb->skb_iif = _dev->ifindex;\r\nif (from & AT_EGRESS) {\r\ndev_queue_xmit(skb);\r\n} else if (from & AT_INGRESS) {\r\nskb_pull(skb, skb->mac_len);\r\nnetif_receive_skb(skb);\r\n} else\r\nBUG();\r\n}\r\nif (__netif_tx_trylock(txq)) {\r\nif ((skb = skb_peek(&dp->rq)) == NULL) {\r\ndp->tasklet_pending = 0;\r\nif (netif_queue_stopped(_dev))\r\nnetif_wake_queue(_dev);\r\n} else {\r\n__netif_tx_unlock(txq);\r\ngoto resched;\r\n}\r\n__netif_tx_unlock(txq);\r\n} else {\r\nresched:\r\ndp->tasklet_pending = 1;\r\ntasklet_schedule(&dp->ifb_tasklet);\r\n}\r\n}\r\nstatic struct rtnl_link_stats64 *ifb_stats64(struct net_device *dev,\r\nstruct rtnl_link_stats64 *stats)\r\n{\r\nstruct ifb_private *dp = netdev_priv(dev);\r\nunsigned int start;\r\ndo {\r\nstart = u64_stats_fetch_begin_irq(&dp->rsync);\r\nstats->rx_packets = dp->rx_packets;\r\nstats->rx_bytes = dp->rx_bytes;\r\n} while (u64_stats_fetch_retry_irq(&dp->rsync, start));\r\ndo {\r\nstart = u64_stats_fetch_begin_irq(&dp->tsync);\r\nstats->tx_packets = dp->tx_packets;\r\nstats->tx_bytes = dp->tx_bytes;\r\n} while (u64_stats_fetch_retry_irq(&dp->tsync, start));\r\nstats->rx_dropped = dev->stats.rx_dropped;\r\nstats->tx_dropped = dev->stats.tx_dropped;\r\nreturn stats;\r\n}\r\nstatic void ifb_setup(struct net_device *dev)\r\n{\r\ndev->destructor = free_netdev;\r\ndev->netdev_ops = &ifb_netdev_ops;\r\nether_setup(dev);\r\ndev->tx_queue_len = TX_Q_LIMIT;\r\ndev->features |= IFB_FEATURES;\r\ndev->vlan_features |= IFB_FEATURES & ~(NETIF_F_HW_VLAN_CTAG_TX |\r\nNETIF_F_HW_VLAN_STAG_TX);\r\ndev->flags |= IFF_NOARP;\r\ndev->flags &= ~IFF_MULTICAST;\r\ndev->priv_flags &= ~IFF_TX_SKB_SHARING;\r\nnetif_keep_dst(dev);\r\neth_hw_addr_random(dev);\r\n}\r\nstatic netdev_tx_t ifb_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct ifb_private *dp = netdev_priv(dev);\r\nu32 from = G_TC_FROM(skb->tc_verd);\r\nu64_stats_update_begin(&dp->rsync);\r\ndp->rx_packets++;\r\ndp->rx_bytes += skb->len;\r\nu64_stats_update_end(&dp->rsync);\r\nif (!(from & (AT_INGRESS|AT_EGRESS)) || !skb->skb_iif) {\r\ndev_kfree_skb(skb);\r\ndev->stats.rx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (skb_queue_len(&dp->rq) >= dev->tx_queue_len) {\r\nnetif_stop_queue(dev);\r\n}\r\n__skb_queue_tail(&dp->rq, skb);\r\nif (!dp->tasklet_pending) {\r\ndp->tasklet_pending = 1;\r\ntasklet_schedule(&dp->ifb_tasklet);\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int ifb_close(struct net_device *dev)\r\n{\r\nstruct ifb_private *dp = netdev_priv(dev);\r\ntasklet_kill(&dp->ifb_tasklet);\r\nnetif_stop_queue(dev);\r\n__skb_queue_purge(&dp->rq);\r\n__skb_queue_purge(&dp->tq);\r\nreturn 0;\r\n}\r\nstatic int ifb_open(struct net_device *dev)\r\n{\r\nstruct ifb_private *dp = netdev_priv(dev);\r\ntasklet_init(&dp->ifb_tasklet, ri_tasklet, (unsigned long)dev);\r\n__skb_queue_head_init(&dp->rq);\r\n__skb_queue_head_init(&dp->tq);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int ifb_validate(struct nlattr *tb[], struct nlattr *data[])\r\n{\r\nif (tb[IFLA_ADDRESS]) {\r\nif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)\r\nreturn -EINVAL;\r\nif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS])))\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init ifb_init_one(int index)\r\n{\r\nstruct net_device *dev_ifb;\r\nstruct ifb_private *dp;\r\nint err;\r\ndev_ifb = alloc_netdev(sizeof(struct ifb_private), "ifb%d",\r\nNET_NAME_UNKNOWN, ifb_setup);\r\nif (!dev_ifb)\r\nreturn -ENOMEM;\r\ndp = netdev_priv(dev_ifb);\r\nu64_stats_init(&dp->rsync);\r\nu64_stats_init(&dp->tsync);\r\ndev_ifb->rtnl_link_ops = &ifb_link_ops;\r\nerr = register_netdevice(dev_ifb);\r\nif (err < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nfree_netdev(dev_ifb);\r\nreturn err;\r\n}\r\nstatic int __init ifb_init_module(void)\r\n{\r\nint i, err;\r\nrtnl_lock();\r\nerr = __rtnl_link_register(&ifb_link_ops);\r\nif (err < 0)\r\ngoto out;\r\nfor (i = 0; i < numifbs && !err; i++) {\r\nerr = ifb_init_one(i);\r\ncond_resched();\r\n}\r\nif (err)\r\n__rtnl_link_unregister(&ifb_link_ops);\r\nout:\r\nrtnl_unlock();\r\nreturn err;\r\n}\r\nstatic void __exit ifb_cleanup_module(void)\r\n{\r\nrtnl_link_unregister(&ifb_link_ops);\r\n}
