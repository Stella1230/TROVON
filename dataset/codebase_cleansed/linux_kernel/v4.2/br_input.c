static int br_pass_frame_up(struct sk_buff *skb)\r\n{\r\nstruct net_device *indev, *brdev = BR_INPUT_SKB_CB(skb)->brdev;\r\nstruct net_bridge *br = netdev_priv(brdev);\r\nstruct pcpu_sw_netstats *brstats = this_cpu_ptr(br->stats);\r\nstruct net_port_vlans *pv;\r\nu64_stats_update_begin(&brstats->syncp);\r\nbrstats->rx_packets++;\r\nbrstats->rx_bytes += skb->len;\r\nu64_stats_update_end(&brstats->syncp);\r\npv = br_get_vlan_info(br);\r\nif (!(brdev->flags & IFF_PROMISC) &&\r\n!br_allowed_egress(br, pv, skb)) {\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nindev = skb->dev;\r\nskb->dev = brdev;\r\nskb = br_handle_vlan(br, pv, skb);\r\nif (!skb)\r\nreturn NET_RX_DROP;\r\nreturn NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN, NULL, skb,\r\nindev, NULL,\r\nnetif_receive_skb_sk);\r\n}\r\nstatic void br_do_proxy_arp(struct sk_buff *skb, struct net_bridge *br,\r\nu16 vid, struct net_bridge_port *p)\r\n{\r\nstruct net_device *dev = br->dev;\r\nstruct neighbour *n;\r\nstruct arphdr *parp;\r\nu8 *arpptr, *sha;\r\n__be32 sip, tip;\r\nBR_INPUT_SKB_CB(skb)->proxyarp_replied = false;\r\nif (dev->flags & IFF_NOARP)\r\nreturn;\r\nif (!pskb_may_pull(skb, arp_hdr_len(dev))) {\r\ndev->stats.tx_dropped++;\r\nreturn;\r\n}\r\nparp = arp_hdr(skb);\r\nif (parp->ar_pro != htons(ETH_P_IP) ||\r\nparp->ar_op != htons(ARPOP_REQUEST) ||\r\nparp->ar_hln != dev->addr_len ||\r\nparp->ar_pln != 4)\r\nreturn;\r\narpptr = (u8 *)parp + sizeof(struct arphdr);\r\nsha = arpptr;\r\narpptr += dev->addr_len;\r\nmemcpy(&sip, arpptr, sizeof(sip));\r\narpptr += sizeof(sip);\r\narpptr += dev->addr_len;\r\nmemcpy(&tip, arpptr, sizeof(tip));\r\nif (ipv4_is_loopback(tip) ||\r\nipv4_is_multicast(tip))\r\nreturn;\r\nn = neigh_lookup(&arp_tbl, &tip, dev);\r\nif (n) {\r\nstruct net_bridge_fdb_entry *f;\r\nif (!(n->nud_state & NUD_VALID)) {\r\nneigh_release(n);\r\nreturn;\r\n}\r\nf = __br_fdb_get(br, n->ha, vid);\r\nif (f && ((p->flags & BR_PROXYARP) ||\r\n(f->dst && (f->dst->flags & BR_PROXYARP_WIFI)))) {\r\narp_send(ARPOP_REPLY, ETH_P_ARP, sip, skb->dev, tip,\r\nsha, n->ha, sha);\r\nBR_INPUT_SKB_CB(skb)->proxyarp_replied = true;\r\n}\r\nneigh_release(n);\r\n}\r\n}\r\nint br_handle_frame_finish(struct sock *sk, struct sk_buff *skb)\r\n{\r\nconst unsigned char *dest = eth_hdr(skb)->h_dest;\r\nstruct net_bridge_port *p = br_port_get_rcu(skb->dev);\r\nstruct net_bridge *br;\r\nstruct net_bridge_fdb_entry *dst;\r\nstruct net_bridge_mdb_entry *mdst;\r\nstruct sk_buff *skb2;\r\nbool unicast = true;\r\nu16 vid = 0;\r\nif (!p || p->state == BR_STATE_DISABLED)\r\ngoto drop;\r\nif (!br_allowed_ingress(p->br, nbp_get_vlan_info(p), skb, &vid))\r\ngoto out;\r\nbr = p->br;\r\nif (p->flags & BR_LEARNING)\r\nbr_fdb_update(br, p, eth_hdr(skb)->h_source, vid, false);\r\nif (!is_broadcast_ether_addr(dest) && is_multicast_ether_addr(dest) &&\r\nbr_multicast_rcv(br, p, skb, vid))\r\ngoto drop;\r\nif (p->state == BR_STATE_LEARNING)\r\ngoto drop;\r\nBR_INPUT_SKB_CB(skb)->brdev = br->dev;\r\nskb2 = NULL;\r\nif (br->dev->flags & IFF_PROMISC)\r\nskb2 = skb;\r\ndst = NULL;\r\nif (IS_ENABLED(CONFIG_INET) && skb->protocol == htons(ETH_P_ARP))\r\nbr_do_proxy_arp(skb, br, vid, p);\r\nif (is_broadcast_ether_addr(dest)) {\r\nskb2 = skb;\r\nunicast = false;\r\n} else if (is_multicast_ether_addr(dest)) {\r\nmdst = br_mdb_get(br, skb, vid);\r\nif ((mdst || BR_INPUT_SKB_CB_MROUTERS_ONLY(skb)) &&\r\nbr_multicast_querier_exists(br, eth_hdr(skb))) {\r\nif ((mdst && mdst->mglist) ||\r\nbr_multicast_is_router(br))\r\nskb2 = skb;\r\nbr_multicast_forward(mdst, skb, skb2);\r\nskb = NULL;\r\nif (!skb2)\r\ngoto out;\r\n} else\r\nskb2 = skb;\r\nunicast = false;\r\nbr->dev->stats.multicast++;\r\n} else if ((dst = __br_fdb_get(br, dest, vid)) &&\r\ndst->is_local) {\r\nskb2 = skb;\r\nskb = NULL;\r\n}\r\nif (skb) {\r\nif (dst) {\r\ndst->used = jiffies;\r\nbr_forward(dst->dst, skb, skb2);\r\n} else\r\nbr_flood_forward(br, skb, skb2, unicast);\r\n}\r\nif (skb2)\r\nreturn br_pass_frame_up(skb2);\r\nout:\r\nreturn 0;\r\ndrop:\r\nkfree_skb(skb);\r\ngoto out;\r\n}\r\nstatic int br_handle_local_finish(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct net_bridge_port *p = br_port_get_rcu(skb->dev);\r\nu16 vid = 0;\r\nif (p->flags & BR_LEARNING && br_should_learn(p, skb, &vid))\r\nbr_fdb_update(p->br, p, eth_hdr(skb)->h_source, vid, false);\r\nreturn 0;\r\n}\r\nrx_handler_result_t br_handle_frame(struct sk_buff **pskb)\r\n{\r\nstruct net_bridge_port *p;\r\nstruct sk_buff *skb = *pskb;\r\nconst unsigned char *dest = eth_hdr(skb)->h_dest;\r\nbr_should_route_hook_t *rhook;\r\nif (unlikely(skb->pkt_type == PACKET_LOOPBACK))\r\nreturn RX_HANDLER_PASS;\r\nif (!is_valid_ether_addr(eth_hdr(skb)->h_source))\r\ngoto drop;\r\nskb = skb_share_check(skb, GFP_ATOMIC);\r\nif (!skb)\r\nreturn RX_HANDLER_CONSUMED;\r\np = br_port_get_rcu(skb->dev);\r\nif (unlikely(is_link_local_ether_addr(dest))) {\r\nu16 fwd_mask = p->br->group_fwd_mask_required;\r\nswitch (dest[5]) {\r\ncase 0x00:\r\nif (p->br->stp_enabled == BR_NO_STP ||\r\nfwd_mask & (1u << dest[5]))\r\ngoto forward;\r\nbreak;\r\ncase 0x01:\r\ngoto drop;\r\ndefault:\r\nfwd_mask |= p->br->group_fwd_mask;\r\nif (fwd_mask & (1u << dest[5]))\r\ngoto forward;\r\n}\r\nif (NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN, NULL, skb,\r\nskb->dev, NULL, br_handle_local_finish)) {\r\nreturn RX_HANDLER_CONSUMED;\r\n} else {\r\n*pskb = skb;\r\nreturn RX_HANDLER_PASS;\r\n}\r\n}\r\nforward:\r\nswitch (p->state) {\r\ncase BR_STATE_FORWARDING:\r\nrhook = rcu_dereference(br_should_route_hook);\r\nif (rhook) {\r\nif ((*rhook)(skb)) {\r\n*pskb = skb;\r\nreturn RX_HANDLER_PASS;\r\n}\r\ndest = eth_hdr(skb)->h_dest;\r\n}\r\ncase BR_STATE_LEARNING:\r\nif (ether_addr_equal(p->br->dev->dev_addr, dest))\r\nskb->pkt_type = PACKET_HOST;\r\nNF_HOOK(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING, NULL, skb,\r\nskb->dev, NULL,\r\nbr_handle_frame_finish);\r\nbreak;\r\ndefault:\r\ndrop:\r\nkfree_skb(skb);\r\n}\r\nreturn RX_HANDLER_CONSUMED;\r\n}
