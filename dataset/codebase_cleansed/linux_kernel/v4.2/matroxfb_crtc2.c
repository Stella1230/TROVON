static int matroxfb_dh_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp, struct fb_info* info) {\r\nu_int32_t col;\r\n#define m2info (container_of(info, struct matroxfb_dh_fb_info, fbcon))\r\nif (regno >= 16)\r\nreturn 1;\r\nif (m2info->fbcon.var.grayscale) {\r\nred = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\r\n}\r\nred = CNVT_TOHW(red, m2info->fbcon.var.red.length);\r\ngreen = CNVT_TOHW(green, m2info->fbcon.var.green.length);\r\nblue = CNVT_TOHW(blue, m2info->fbcon.var.blue.length);\r\ntransp = CNVT_TOHW(transp, m2info->fbcon.var.transp.length);\r\ncol = (red << m2info->fbcon.var.red.offset) |\r\n(green << m2info->fbcon.var.green.offset) |\r\n(blue << m2info->fbcon.var.blue.offset) |\r\n(transp << m2info->fbcon.var.transp.offset);\r\nswitch (m2info->fbcon.var.bits_per_pixel) {\r\ncase 16:\r\nm2info->cmap[regno] = col | (col << 16);\r\nbreak;\r\ncase 32:\r\nm2info->cmap[regno] = col;\r\nbreak;\r\n}\r\nreturn 0;\r\n#undef m2info\r\n}\r\nstatic void matroxfb_dh_restore(struct matroxfb_dh_fb_info* m2info,\r\nstruct my_timming* mt,\r\nint mode,\r\nunsigned int pos) {\r\nu_int32_t tmp;\r\nu_int32_t datactl;\r\nstruct matrox_fb_info *minfo = m2info->primary_dev;\r\nswitch (mode) {\r\ncase 15:\r\ntmp = 0x00200000;\r\nbreak;\r\ncase 16:\r\ntmp = 0x00400000;\r\nbreak;\r\ndefault:\r\ntmp = 0x00800000;\r\nbreak;\r\n}\r\ntmp |= 0x00000001;\r\ndatactl = 0;\r\nif (minfo->outputs[1].src == MATROXFB_SRC_CRTC2) {\r\nif (minfo->devflags.g450dac) {\r\ntmp |= 0x00000006;\r\nif (minfo->outputs[1].mode != MATROXFB_OUTPUT_MODE_MONITOR) {\r\ntmp |= 0xC0001000;\r\n}\r\n} else {\r\ntmp |= 0x00000002;\r\ntmp |= 0xC0000000;\r\n}\r\n} else if (minfo->outputs[0].src == MATROXFB_SRC_CRTC2) {\r\ntmp |= 0x00000004;\r\n}\r\nif (minfo->outputs[0].src == MATROXFB_SRC_CRTC2) {\r\ntmp |= 0x00100000;\r\n}\r\nif (mt->interlaced) {\r\ntmp |= 0x02000000;\r\nmt->VDisplay >>= 1;\r\nmt->VSyncStart >>= 1;\r\nmt->VSyncEnd >>= 1;\r\nmt->VTotal >>= 1;\r\n}\r\nif ((mt->HTotal & 7) == 2) {\r\ndatactl |= 0x00000010;\r\nmt->HTotal &= ~7;\r\n}\r\ntmp |= 0x10000000;\r\nmga_outl(0x3C14, ((mt->HDisplay - 8) << 16) | (mt->HTotal - 8));\r\nmga_outl(0x3C18, ((mt->HSyncEnd - 8) << 16) | (mt->HSyncStart - 8));\r\nmga_outl(0x3C1C, ((mt->VDisplay - 1) << 16) | (mt->VTotal - 1));\r\nmga_outl(0x3C20, ((mt->VSyncEnd - 1) << 16) | (mt->VSyncStart - 1));\r\nmga_outl(0x3C24, ((mt->VSyncStart) << 16) | (mt->HSyncStart));\r\n{\r\nu_int32_t linelen = m2info->fbcon.var.xres_virtual * (m2info->fbcon.var.bits_per_pixel >> 3);\r\nif (tmp & 0x02000000) {\r\nmga_outl(0x3C2C, pos);\r\nmga_outl(0x3C28, pos + linelen);\r\nlinelen <<= 1;\r\nm2info->interlaced = 1;\r\n} else {\r\nmga_outl(0x3C28, pos);\r\nm2info->interlaced = 0;\r\n}\r\nmga_outl(0x3C40, linelen);\r\n}\r\nmga_outl(0x3C4C, datactl);\r\nif (tmp & 0x02000000) {\r\nint i;\r\nmga_outl(0x3C10, tmp & ~0x02000000);\r\nfor (i = 0; i < 2; i++) {\r\nunsigned int nl;\r\nunsigned int lastl = 0;\r\nwhile ((nl = mga_inl(0x3C48) & 0xFFF) >= lastl) {\r\nlastl = nl;\r\n}\r\n}\r\n}\r\nmga_outl(0x3C10, tmp);\r\nminfo->hw.crtc2.ctl = tmp;\r\ntmp = mt->VDisplay << 16;\r\nif (mt->sync & FB_SYNC_HOR_HIGH_ACT)\r\ntmp |= 0x00000100;\r\nif (mt->sync & FB_SYNC_VERT_HIGH_ACT)\r\ntmp |= 0x00000200;\r\nmga_outl(0x3C44, tmp);\r\n}\r\nstatic void matroxfb_dh_disable(struct matroxfb_dh_fb_info* m2info) {\r\nstruct matrox_fb_info *minfo = m2info->primary_dev;\r\nmga_outl(0x3C10, 0x00000004);\r\nminfo->hw.crtc2.ctl = 0x00000004;\r\n}\r\nstatic void matroxfb_dh_pan_var(struct matroxfb_dh_fb_info* m2info,\r\nstruct fb_var_screeninfo* var) {\r\nunsigned int pos;\r\nunsigned int linelen;\r\nunsigned int pixelsize;\r\nstruct matrox_fb_info *minfo = m2info->primary_dev;\r\nm2info->fbcon.var.xoffset = var->xoffset;\r\nm2info->fbcon.var.yoffset = var->yoffset;\r\npixelsize = m2info->fbcon.var.bits_per_pixel >> 3;\r\nlinelen = m2info->fbcon.var.xres_virtual * pixelsize;\r\npos = m2info->fbcon.var.yoffset * linelen + m2info->fbcon.var.xoffset * pixelsize;\r\npos += m2info->video.offbase;\r\nif (m2info->interlaced) {\r\nmga_outl(0x3C2C, pos);\r\nmga_outl(0x3C28, pos + linelen);\r\n} else {\r\nmga_outl(0x3C28, pos);\r\n}\r\n}\r\nstatic int matroxfb_dh_decode_var(struct matroxfb_dh_fb_info* m2info,\r\nstruct fb_var_screeninfo* var,\r\nint *visual,\r\nint *video_cmap_len,\r\nint *mode) {\r\nunsigned int mask;\r\nunsigned int memlen;\r\nunsigned int vramlen;\r\nswitch (var->bits_per_pixel) {\r\ncase 16: mask = 0x1F;\r\nbreak;\r\ncase 32: mask = 0x0F;\r\nbreak;\r\ndefault: return -EINVAL;\r\n}\r\nvramlen = m2info->video.len_usable;\r\nif (var->yres_virtual < var->yres)\r\nvar->yres_virtual = var->yres;\r\nif (var->xres_virtual < var->xres)\r\nvar->xres_virtual = var->xres;\r\nvar->xres_virtual = (var->xres_virtual + mask) & ~mask;\r\nif (var->yres_virtual > 32767)\r\nreturn -EINVAL;\r\nmemlen = var->xres_virtual * var->yres_virtual * (var->bits_per_pixel >> 3);\r\nif (memlen > vramlen)\r\nreturn -EINVAL;\r\nif (var->xoffset + var->xres > var->xres_virtual)\r\nvar->xoffset = var->xres_virtual - var->xres;\r\nif (var->yoffset + var->yres > var->yres_virtual)\r\nvar->yoffset = var->yres_virtual - var->yres;\r\nvar->xres &= ~7;\r\nvar->left_margin &= ~7;\r\nvar->right_margin &= ~7;\r\nvar->hsync_len &= ~7;\r\n*mode = var->bits_per_pixel;\r\nif (var->bits_per_pixel == 16) {\r\nif (var->green.length == 5) {\r\nvar->red.offset = 10;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 5;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nvar->transp.offset = 15;\r\nvar->transp.length = 1;\r\n*mode = 15;\r\n} else {\r\nvar->red.offset = 11;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 6;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\n}\r\n} else {\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 24;\r\nvar->transp.length = 8;\r\n}\r\n*visual = FB_VISUAL_TRUECOLOR;\r\n*video_cmap_len = 16;\r\nreturn 0;\r\n}\r\nstatic int matroxfb_dh_open(struct fb_info* info, int user) {\r\n#define m2info (container_of(info, struct matroxfb_dh_fb_info, fbcon))\r\nstruct matrox_fb_info *minfo = m2info->primary_dev;\r\nif (minfo) {\r\nint err;\r\nif (minfo->dead) {\r\nreturn -ENXIO;\r\n}\r\nerr = minfo->fbops.fb_open(&minfo->fbcon, user);\r\nif (err) {\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n#undef m2info\r\n}\r\nstatic int matroxfb_dh_release(struct fb_info* info, int user) {\r\n#define m2info (container_of(info, struct matroxfb_dh_fb_info, fbcon))\r\nint err = 0;\r\nstruct matrox_fb_info *minfo = m2info->primary_dev;\r\nif (minfo) {\r\nerr = minfo->fbops.fb_release(&minfo->fbcon, user);\r\n}\r\nreturn err;\r\n#undef m2info\r\n}\r\nstatic void matroxfb_dh_init_fix(struct matroxfb_dh_fb_info *m2info)\r\n{\r\nstruct fb_fix_screeninfo *fix = &m2info->fbcon.fix;\r\nstrcpy(fix->id, "MATROX DH");\r\nfix->smem_start = m2info->video.base;\r\nfix->smem_len = m2info->video.len_usable;\r\nfix->ypanstep = 1;\r\nfix->ywrapstep = 0;\r\nfix->xpanstep = 8;\r\nfix->mmio_start = m2info->mmio.base;\r\nfix->mmio_len = m2info->mmio.len;\r\nfix->accel = 0;\r\n}\r\nstatic int matroxfb_dh_check_var(struct fb_var_screeninfo* var, struct fb_info* info) {\r\n#define m2info (container_of(info, struct matroxfb_dh_fb_info, fbcon))\r\nint visual;\r\nint cmap_len;\r\nint mode;\r\nreturn matroxfb_dh_decode_var(m2info, var, &visual, &cmap_len, &mode);\r\n#undef m2info\r\n}\r\nstatic int matroxfb_dh_set_par(struct fb_info* info) {\r\n#define m2info (container_of(info, struct matroxfb_dh_fb_info, fbcon))\r\nint visual;\r\nint cmap_len;\r\nint mode;\r\nint err;\r\nstruct fb_var_screeninfo* var = &info->var;\r\nstruct matrox_fb_info *minfo = m2info->primary_dev;\r\nif ((err = matroxfb_dh_decode_var(m2info, var, &visual, &cmap_len, &mode)) != 0)\r\nreturn err;\r\n{\r\nm2info->fbcon.screen_base = vaddr_va(m2info->video.vbase);\r\nm2info->fbcon.fix.visual = visual;\r\nm2info->fbcon.fix.type = FB_TYPE_PACKED_PIXELS;\r\nm2info->fbcon.fix.type_aux = 0;\r\nm2info->fbcon.fix.line_length = (var->xres_virtual * var->bits_per_pixel) >> 3;\r\n}\r\n{\r\nstruct my_timming mt;\r\nunsigned int pos;\r\nint out;\r\nint cnt;\r\nmatroxfb_var2my(&m2info->fbcon.var, &mt);\r\nmt.crtc = MATROXFB_SRC_CRTC2;\r\nmt.delay = 34;\r\npos = (m2info->fbcon.var.yoffset * m2info->fbcon.var.xres_virtual + m2info->fbcon.var.xoffset) * m2info->fbcon.var.bits_per_pixel >> 3;\r\npos += m2info->video.offbase;\r\ncnt = 0;\r\ndown_read(&minfo->altout.lock);\r\nfor (out = 0; out < MATROXFB_MAX_OUTPUTS; out++) {\r\nif (minfo->outputs[out].src == MATROXFB_SRC_CRTC2) {\r\ncnt++;\r\nif (minfo->outputs[out].output->compute) {\r\nminfo->outputs[out].output->compute(minfo->outputs[out].data, &mt);\r\n}\r\n}\r\n}\r\nminfo->crtc2.pixclock = mt.pixclock;\r\nminfo->crtc2.mnp = mt.mnp;\r\nup_read(&minfo->altout.lock);\r\nif (cnt) {\r\nmatroxfb_dh_restore(m2info, &mt, mode, pos);\r\n} else {\r\nmatroxfb_dh_disable(m2info);\r\n}\r\nDAC1064_global_init(minfo);\r\nDAC1064_global_restore(minfo);\r\ndown_read(&minfo->altout.lock);\r\nfor (out = 0; out < MATROXFB_MAX_OUTPUTS; out++) {\r\nif (minfo->outputs[out].src == MATROXFB_SRC_CRTC2 &&\r\nminfo->outputs[out].output->program) {\r\nminfo->outputs[out].output->program(minfo->outputs[out].data);\r\n}\r\n}\r\nfor (out = 0; out < MATROXFB_MAX_OUTPUTS; out++) {\r\nif (minfo->outputs[out].src == MATROXFB_SRC_CRTC2 &&\r\nminfo->outputs[out].output->start) {\r\nminfo->outputs[out].output->start(minfo->outputs[out].data);\r\n}\r\n}\r\nup_read(&minfo->altout.lock);\r\n}\r\nm2info->initialized = 1;\r\nreturn 0;\r\n#undef m2info\r\n}\r\nstatic int matroxfb_dh_pan_display(struct fb_var_screeninfo* var, struct fb_info* info) {\r\n#define m2info (container_of(info, struct matroxfb_dh_fb_info, fbcon))\r\nmatroxfb_dh_pan_var(m2info, var);\r\nreturn 0;\r\n#undef m2info\r\n}\r\nstatic int matroxfb_dh_get_vblank(const struct matroxfb_dh_fb_info* m2info, struct fb_vblank* vblank) {\r\nstruct matrox_fb_info *minfo = m2info->primary_dev;\r\nmatroxfb_enable_irq(minfo, 0);\r\nmemset(vblank, 0, sizeof(*vblank));\r\nvblank->flags = FB_VBLANK_HAVE_VCOUNT | FB_VBLANK_HAVE_VBLANK;\r\nvblank->vcount = mga_inl(0x3C48) & 0x000007FF;\r\nif (vblank->vcount >= m2info->fbcon.var.yres)\r\nvblank->flags |= FB_VBLANK_VBLANKING;\r\nif (test_bit(0, &minfo->irq_flags)) {\r\nvblank->flags |= FB_VBLANK_HAVE_COUNT;\r\nvblank->count = minfo->crtc2.vsync.cnt;\r\n}\r\nreturn 0;\r\n}\r\nstatic int matroxfb_dh_ioctl(struct fb_info *info,\r\nunsigned int cmd,\r\nunsigned long arg)\r\n{\r\n#define m2info (container_of(info, struct matroxfb_dh_fb_info, fbcon))\r\nstruct matrox_fb_info *minfo = m2info->primary_dev;\r\nDBG(__func__)\r\nswitch (cmd) {\r\ncase FBIOGET_VBLANK:\r\n{\r\nstruct fb_vblank vblank;\r\nint err;\r\nerr = matroxfb_dh_get_vblank(m2info, &vblank);\r\nif (err)\r\nreturn err;\r\nif (copy_to_user((void __user *)arg, &vblank, sizeof(vblank)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase FBIO_WAITFORVSYNC:\r\n{\r\nu_int32_t crt;\r\nif (get_user(crt, (u_int32_t __user *)arg))\r\nreturn -EFAULT;\r\nif (crt != 0)\r\nreturn -ENODEV;\r\nreturn matroxfb_wait_for_sync(minfo, 1);\r\n}\r\ncase MATROXFB_SET_OUTPUT_MODE:\r\ncase MATROXFB_GET_OUTPUT_MODE:\r\ncase MATROXFB_GET_ALL_OUTPUTS:\r\n{\r\nreturn minfo->fbcon.fbops->fb_ioctl(&minfo->fbcon, cmd, arg);\r\n}\r\ncase MATROXFB_SET_OUTPUT_CONNECTION:\r\n{\r\nu_int32_t tmp;\r\nint out;\r\nint changes;\r\nif (get_user(tmp, (u_int32_t __user *)arg))\r\nreturn -EFAULT;\r\nfor (out = 0; out < 32; out++) {\r\nif (tmp & (1 << out)) {\r\nif (out >= MATROXFB_MAX_OUTPUTS)\r\nreturn -ENXIO;\r\nif (!minfo->outputs[out].output)\r\nreturn -ENXIO;\r\nswitch (minfo->outputs[out].src) {\r\ncase MATROXFB_SRC_NONE:\r\ncase MATROXFB_SRC_CRTC2:\r\nbreak;\r\ndefault:\r\nreturn -EBUSY;\r\n}\r\n}\r\n}\r\nif (minfo->devflags.panellink) {\r\nif (tmp & MATROXFB_OUTPUT_CONN_DFP)\r\nreturn -EINVAL;\r\nif ((minfo->outputs[2].src == MATROXFB_SRC_CRTC1) && tmp)\r\nreturn -EBUSY;\r\n}\r\nchanges = 0;\r\nfor (out = 0; out < MATROXFB_MAX_OUTPUTS; out++) {\r\nif (tmp & (1 << out)) {\r\nif (minfo->outputs[out].src != MATROXFB_SRC_CRTC2) {\r\nchanges = 1;\r\nminfo->outputs[out].src = MATROXFB_SRC_CRTC2;\r\n}\r\n} else if (minfo->outputs[out].src == MATROXFB_SRC_CRTC2) {\r\nchanges = 1;\r\nminfo->outputs[out].src = MATROXFB_SRC_NONE;\r\n}\r\n}\r\nif (!changes)\r\nreturn 0;\r\nmatroxfb_dh_set_par(info);\r\nreturn 0;\r\n}\r\ncase MATROXFB_GET_OUTPUT_CONNECTION:\r\n{\r\nu_int32_t conn = 0;\r\nint out;\r\nfor (out = 0; out < MATROXFB_MAX_OUTPUTS; out++) {\r\nif (minfo->outputs[out].src == MATROXFB_SRC_CRTC2) {\r\nconn |= 1 << out;\r\n}\r\n}\r\nif (put_user(conn, (u_int32_t __user *)arg))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase MATROXFB_GET_AVAILABLE_OUTPUTS:\r\n{\r\nu_int32_t tmp = 0;\r\nint out;\r\nfor (out = 0; out < MATROXFB_MAX_OUTPUTS; out++) {\r\nif (minfo->outputs[out].output) {\r\nswitch (minfo->outputs[out].src) {\r\ncase MATROXFB_SRC_NONE:\r\ncase MATROXFB_SRC_CRTC2:\r\ntmp |= 1 << out;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (minfo->devflags.panellink) {\r\ntmp &= ~MATROXFB_OUTPUT_CONN_DFP;\r\nif (minfo->outputs[2].src == MATROXFB_SRC_CRTC1) {\r\ntmp = 0;\r\n}\r\n}\r\nif (put_user(tmp, (u_int32_t __user *)arg))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOTTY;\r\n#undef m2info\r\n}\r\nstatic int matroxfb_dh_blank(int blank, struct fb_info* info) {\r\n#define m2info (container_of(info, struct matroxfb_dh_fb_info, fbcon))\r\nswitch (blank) {\r\ncase 1:\r\ncase 2:\r\ncase 3:\r\ncase 4:\r\ndefault:;\r\n}\r\nreturn 0;\r\n#undef m2info\r\n}\r\nstatic int matroxfb_dh_regit(const struct matrox_fb_info *minfo,\r\nstruct matroxfb_dh_fb_info *m2info)\r\n{\r\n#define minfo (m2info->primary_dev)\r\nvoid* oldcrtc2;\r\nm2info->fbcon.fbops = &matroxfb_dh_ops;\r\nm2info->fbcon.flags = FBINFO_FLAG_DEFAULT;\r\nm2info->fbcon.flags |= FBINFO_HWACCEL_XPAN |\r\nFBINFO_HWACCEL_YPAN;\r\nm2info->fbcon.pseudo_palette = m2info->cmap;\r\nfb_alloc_cmap(&m2info->fbcon.cmap, 256, 1);\r\nif (mem < 64)\r\nmem *= 1024;\r\nif (mem < 64*1024)\r\nmem *= 1024;\r\nmem &= ~0x00000FFF;\r\nif (minfo->video.len_usable + mem <= minfo->video.len)\r\nm2info->video.offbase = minfo->video.len - mem;\r\nelse if (minfo->video.len < mem) {\r\nreturn -ENOMEM;\r\n} else {\r\nm2info->video.borrowed = mem;\r\nminfo->video.len_usable -= mem;\r\nm2info->video.offbase = minfo->video.len_usable;\r\n}\r\nm2info->video.base = minfo->video.base + m2info->video.offbase;\r\nm2info->video.len = m2info->video.len_usable = m2info->video.len_maximum = mem;\r\nm2info->video.vbase.vaddr = vaddr_va(minfo->video.vbase) + m2info->video.offbase;\r\nm2info->mmio.base = minfo->mmio.base;\r\nm2info->mmio.vbase = minfo->mmio.vbase;\r\nm2info->mmio.len = minfo->mmio.len;\r\nmatroxfb_dh_init_fix(m2info);\r\nif (register_framebuffer(&m2info->fbcon)) {\r\nreturn -ENXIO;\r\n}\r\nif (!m2info->initialized)\r\nfb_set_var(&m2info->fbcon, &matroxfb_dh_defined);\r\ndown_write(&minfo->crtc2.lock);\r\noldcrtc2 = minfo->crtc2.info;\r\nminfo->crtc2.info = m2info;\r\nup_write(&minfo->crtc2.lock);\r\nif (oldcrtc2) {\r\nprintk(KERN_ERR "matroxfb_crtc2: Internal consistency check failed: crtc2 already present: %p\n",\r\noldcrtc2);\r\n}\r\nreturn 0;\r\n#undef minfo\r\n}\r\nstatic int matroxfb_dh_registerfb(struct matroxfb_dh_fb_info* m2info) {\r\n#define minfo (m2info->primary_dev)\r\nif (matroxfb_dh_regit(minfo, m2info)) {\r\nprintk(KERN_ERR "matroxfb_crtc2: secondary head failed to register\n");\r\nreturn -1;\r\n}\r\nprintk(KERN_INFO "matroxfb_crtc2: secondary head of fb%u was registered as fb%u\n",\r\nminfo->fbcon.node, m2info->fbcon.node);\r\nm2info->fbcon_registered = 1;\r\nreturn 0;\r\n#undef minfo\r\n}\r\nstatic void matroxfb_dh_deregisterfb(struct matroxfb_dh_fb_info* m2info) {\r\n#define minfo (m2info->primary_dev)\r\nif (m2info->fbcon_registered) {\r\nint id;\r\nstruct matroxfb_dh_fb_info* crtc2;\r\ndown_write(&minfo->crtc2.lock);\r\ncrtc2 = minfo->crtc2.info;\r\nif (crtc2 == m2info)\r\nminfo->crtc2.info = NULL;\r\nup_write(&minfo->crtc2.lock);\r\nif (crtc2 != m2info) {\r\nprintk(KERN_ERR "matroxfb_crtc2: Internal consistency check failed: crtc2 mismatch at unload: %p != %p\n",\r\ncrtc2, m2info);\r\nprintk(KERN_ERR "matroxfb_crtc2: Expect kernel crash after module unload.\n");\r\nreturn;\r\n}\r\nid = m2info->fbcon.node;\r\nunregister_framebuffer(&m2info->fbcon);\r\nminfo->video.len_usable += m2info->video.borrowed;\r\nprintk(KERN_INFO "matroxfb_crtc2: fb%u unregistered\n", id);\r\nm2info->fbcon_registered = 0;\r\n}\r\n#undef minfo\r\n}\r\nstatic void* matroxfb_crtc2_probe(struct matrox_fb_info* minfo) {\r\nstruct matroxfb_dh_fb_info* m2info;\r\nif (!minfo->devflags.crtc2)\r\nreturn NULL;\r\nm2info = kzalloc(sizeof(*m2info), GFP_KERNEL);\r\nif (!m2info) {\r\nprintk(KERN_ERR "matroxfb_crtc2: Not enough memory for CRTC2 control structs\n");\r\nreturn NULL;\r\n}\r\nm2info->primary_dev = minfo;\r\nif (matroxfb_dh_registerfb(m2info)) {\r\nkfree(m2info);\r\nprintk(KERN_ERR "matroxfb_crtc2: CRTC2 framebuffer failed to register\n");\r\nreturn NULL;\r\n}\r\nreturn m2info;\r\n}\r\nstatic void matroxfb_crtc2_remove(struct matrox_fb_info* minfo, void* crtc2) {\r\nmatroxfb_dh_deregisterfb(crtc2);\r\nkfree(crtc2);\r\n}\r\nstatic int matroxfb_crtc2_init(void) {\r\nif (fb_get_options("matrox_crtc2fb", NULL))\r\nreturn -ENODEV;\r\nmatroxfb_register_driver(&crtc2);\r\nreturn 0;\r\n}\r\nstatic void matroxfb_crtc2_exit(void) {\r\nmatroxfb_unregister_driver(&crtc2);\r\n}
