static int vfat_revalidate_shortname(struct dentry *dentry)\r\n{\r\nint ret = 1;\r\nspin_lock(&dentry->d_lock);\r\nif (dentry->d_time != d_inode(dentry->d_parent)->i_version)\r\nret = 0;\r\nspin_unlock(&dentry->d_lock);\r\nreturn ret;\r\n}\r\nstatic int vfat_revalidate(struct dentry *dentry, unsigned int flags)\r\n{\r\nif (flags & LOOKUP_RCU)\r\nreturn -ECHILD;\r\nif (d_really_is_positive(dentry))\r\nreturn 1;\r\nreturn vfat_revalidate_shortname(dentry);\r\n}\r\nstatic int vfat_revalidate_ci(struct dentry *dentry, unsigned int flags)\r\n{\r\nif (flags & LOOKUP_RCU)\r\nreturn -ECHILD;\r\nif (d_really_is_positive(dentry))\r\nreturn 1;\r\nif (!flags)\r\nreturn 0;\r\nif (flags & (LOOKUP_CREATE | LOOKUP_RENAME_TARGET))\r\nreturn 0;\r\nreturn vfat_revalidate_shortname(dentry);\r\n}\r\nstatic unsigned int __vfat_striptail_len(unsigned int len, const char *name)\r\n{\r\nwhile (len && name[len - 1] == '.')\r\nlen--;\r\nreturn len;\r\n}\r\nstatic unsigned int vfat_striptail_len(const struct qstr *qstr)\r\n{\r\nreturn __vfat_striptail_len(qstr->len, qstr->name);\r\n}\r\nstatic int vfat_hash(const struct dentry *dentry, struct qstr *qstr)\r\n{\r\nqstr->hash = full_name_hash(qstr->name, vfat_striptail_len(qstr));\r\nreturn 0;\r\n}\r\nstatic int vfat_hashi(const struct dentry *dentry, struct qstr *qstr)\r\n{\r\nstruct nls_table *t = MSDOS_SB(dentry->d_sb)->nls_io;\r\nconst unsigned char *name;\r\nunsigned int len;\r\nunsigned long hash;\r\nname = qstr->name;\r\nlen = vfat_striptail_len(qstr);\r\nhash = init_name_hash();\r\nwhile (len--)\r\nhash = partial_name_hash(nls_tolower(t, *name++), hash);\r\nqstr->hash = end_name_hash(hash);\r\nreturn 0;\r\n}\r\nstatic int vfat_cmpi(const struct dentry *parent, const struct dentry *dentry,\r\nunsigned int len, const char *str, const struct qstr *name)\r\n{\r\nstruct nls_table *t = MSDOS_SB(parent->d_sb)->nls_io;\r\nunsigned int alen, blen;\r\nalen = vfat_striptail_len(name);\r\nblen = __vfat_striptail_len(len, str);\r\nif (alen == blen) {\r\nif (nls_strnicmp(t, name->name, str, alen) == 0)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int vfat_cmp(const struct dentry *parent, const struct dentry *dentry,\r\nunsigned int len, const char *str, const struct qstr *name)\r\n{\r\nunsigned int alen, blen;\r\nalen = vfat_striptail_len(name);\r\nblen = __vfat_striptail_len(len, str);\r\nif (alen == blen) {\r\nif (strncmp(name->name, str, alen) == 0)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic inline wchar_t vfat_bad_char(wchar_t w)\r\n{\r\nreturn (w < 0x0020)\r\n|| (w == '*') || (w == '?') || (w == '<') || (w == '>')\r\n|| (w == '|') || (w == '"') || (w == ':') || (w == '/')\r\n|| (w == '\\');\r\n}\r\nstatic inline wchar_t vfat_replace_char(wchar_t w)\r\n{\r\nreturn (w == '[') || (w == ']') || (w == ';') || (w == ',')\r\n|| (w == '+') || (w == '=');\r\n}\r\nstatic wchar_t vfat_skip_char(wchar_t w)\r\n{\r\nreturn (w == '.') || (w == ' ');\r\n}\r\nstatic inline int vfat_is_used_badchars(const wchar_t *s, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nif (vfat_bad_char(s[i]))\r\nreturn -EINVAL;\r\nif (s[i - 1] == ' ')\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int vfat_find_form(struct inode *dir, unsigned char *name)\r\n{\r\nstruct fat_slot_info sinfo;\r\nint err = fat_scan(dir, name, &sinfo);\r\nif (err)\r\nreturn -ENOENT;\r\nbrelse(sinfo.bh);\r\nreturn 0;\r\n}\r\nstatic inline int to_shortname_char(struct nls_table *nls,\r\nunsigned char *buf, int buf_size,\r\nwchar_t *src, struct shortname_info *info)\r\n{\r\nint len;\r\nif (vfat_skip_char(*src)) {\r\ninfo->valid = 0;\r\nreturn 0;\r\n}\r\nif (vfat_replace_char(*src)) {\r\ninfo->valid = 0;\r\nbuf[0] = '_';\r\nreturn 1;\r\n}\r\nlen = nls->uni2char(*src, buf, buf_size);\r\nif (len <= 0) {\r\ninfo->valid = 0;\r\nbuf[0] = '_';\r\nlen = 1;\r\n} else if (len == 1) {\r\nunsigned char prev = buf[0];\r\nif (buf[0] >= 0x7F) {\r\ninfo->lower = 0;\r\ninfo->upper = 0;\r\n}\r\nbuf[0] = nls_toupper(nls, buf[0]);\r\nif (isalpha(buf[0])) {\r\nif (buf[0] == prev)\r\ninfo->lower = 0;\r\nelse\r\ninfo->upper = 0;\r\n}\r\n} else {\r\ninfo->lower = 0;\r\ninfo->upper = 0;\r\n}\r\nreturn len;\r\n}\r\nstatic int vfat_create_shortname(struct inode *dir, struct nls_table *nls,\r\nwchar_t *uname, int ulen,\r\nunsigned char *name_res, unsigned char *lcase)\r\n{\r\nstruct fat_mount_options *opts = &MSDOS_SB(dir->i_sb)->options;\r\nwchar_t *ip, *ext_start, *end, *name_start;\r\nunsigned char base[9], ext[4], buf[5], *p;\r\nunsigned char charbuf[NLS_MAX_CHARSET_SIZE];\r\nint chl, chi;\r\nint sz = 0, extlen, baselen, i, numtail_baselen, numtail2_baselen;\r\nint is_shortname;\r\nstruct shortname_info base_info, ext_info;\r\nis_shortname = 1;\r\nINIT_SHORTNAME_INFO(&base_info);\r\nINIT_SHORTNAME_INFO(&ext_info);\r\next_start = end = &uname[ulen];\r\nwhile (--ext_start >= uname) {\r\nif (*ext_start == 0x002E) {\r\nif (ext_start == end - 1) {\r\nsz = ulen;\r\next_start = NULL;\r\n}\r\nbreak;\r\n}\r\n}\r\nif (ext_start == uname - 1) {\r\nsz = ulen;\r\next_start = NULL;\r\n} else if (ext_start) {\r\nname_start = &uname[0];\r\nwhile (name_start < ext_start) {\r\nif (!vfat_skip_char(*name_start))\r\nbreak;\r\nname_start++;\r\n}\r\nif (name_start != ext_start) {\r\nsz = ext_start - uname;\r\next_start++;\r\n} else {\r\nsz = ulen;\r\next_start = NULL;\r\n}\r\n}\r\nnumtail_baselen = 6;\r\nnumtail2_baselen = 2;\r\nfor (baselen = i = 0, p = base, ip = uname; i < sz; i++, ip++) {\r\nchl = to_shortname_char(nls, charbuf, sizeof(charbuf),\r\nip, &base_info);\r\nif (chl == 0)\r\ncontinue;\r\nif (baselen < 2 && (baselen + chl) > 2)\r\nnumtail2_baselen = baselen;\r\nif (baselen < 6 && (baselen + chl) > 6)\r\nnumtail_baselen = baselen;\r\nfor (chi = 0; chi < chl; chi++) {\r\n*p++ = charbuf[chi];\r\nbaselen++;\r\nif (baselen >= 8)\r\nbreak;\r\n}\r\nif (baselen >= 8) {\r\nif ((chi < chl - 1) || (ip + 1) - uname < sz)\r\nis_shortname = 0;\r\nbreak;\r\n}\r\n}\r\nif (baselen == 0) {\r\nreturn -EINVAL;\r\n}\r\nextlen = 0;\r\nif (ext_start) {\r\nfor (p = ext, ip = ext_start; extlen < 3 && ip < end; ip++) {\r\nchl = to_shortname_char(nls, charbuf, sizeof(charbuf),\r\nip, &ext_info);\r\nif (chl == 0)\r\ncontinue;\r\nif ((extlen + chl) > 3) {\r\nis_shortname = 0;\r\nbreak;\r\n}\r\nfor (chi = 0; chi < chl; chi++) {\r\n*p++ = charbuf[chi];\r\nextlen++;\r\n}\r\nif (extlen >= 3) {\r\nif (ip + 1 != end)\r\nis_shortname = 0;\r\nbreak;\r\n}\r\n}\r\n}\r\next[extlen] = '\0';\r\nbase[baselen] = '\0';\r\nif (base[0] == DELETED_FLAG)\r\nbase[0] = 0x05;\r\nmemset(name_res, ' ', MSDOS_NAME);\r\nmemcpy(name_res, base, baselen);\r\nmemcpy(name_res + 8, ext, extlen);\r\n*lcase = 0;\r\nif (is_shortname && base_info.valid && ext_info.valid) {\r\nif (vfat_find_form(dir, name_res) == 0)\r\nreturn -EEXIST;\r\nif (opts->shortname & VFAT_SFN_CREATE_WIN95) {\r\nreturn (base_info.upper && ext_info.upper);\r\n} else if (opts->shortname & VFAT_SFN_CREATE_WINNT) {\r\nif ((base_info.upper || base_info.lower) &&\r\n(ext_info.upper || ext_info.lower)) {\r\nif (!base_info.upper && base_info.lower)\r\n*lcase |= CASE_LOWER_BASE;\r\nif (!ext_info.upper && ext_info.lower)\r\n*lcase |= CASE_LOWER_EXT;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n} else {\r\nBUG();\r\n}\r\n}\r\nif (opts->numtail == 0)\r\nif (vfat_find_form(dir, name_res) < 0)\r\nreturn 0;\r\nif (baselen > 6) {\r\nbaselen = numtail_baselen;\r\nname_res[7] = ' ';\r\n}\r\nname_res[baselen] = '~';\r\nfor (i = 1; i < 10; i++) {\r\nname_res[baselen + 1] = i + '0';\r\nif (vfat_find_form(dir, name_res) < 0)\r\nreturn 0;\r\n}\r\ni = jiffies;\r\nsz = (jiffies >> 16) & 0x7;\r\nif (baselen > 2) {\r\nbaselen = numtail2_baselen;\r\nname_res[7] = ' ';\r\n}\r\nname_res[baselen + 4] = '~';\r\nname_res[baselen + 5] = '1' + sz;\r\nwhile (1) {\r\nsnprintf(buf, sizeof(buf), "%04X", i & 0xffff);\r\nmemcpy(&name_res[baselen], buf, 4);\r\nif (vfat_find_form(dir, name_res) < 0)\r\nbreak;\r\ni -= 11;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nxlate_to_uni(const unsigned char *name, int len, unsigned char *outname,\r\nint *longlen, int *outlen, int escape, int utf8,\r\nstruct nls_table *nls)\r\n{\r\nconst unsigned char *ip;\r\nunsigned char nc;\r\nunsigned char *op;\r\nunsigned int ec;\r\nint i, k, fill;\r\nint charlen;\r\nif (utf8) {\r\n*outlen = utf8s_to_utf16s(name, len, UTF16_HOST_ENDIAN,\r\n(wchar_t *) outname, FAT_LFN_LEN + 2);\r\nif (*outlen < 0)\r\nreturn *outlen;\r\nelse if (*outlen > FAT_LFN_LEN)\r\nreturn -ENAMETOOLONG;\r\nop = &outname[*outlen * sizeof(wchar_t)];\r\n} else {\r\nfor (i = 0, ip = name, op = outname, *outlen = 0;\r\ni < len && *outlen < FAT_LFN_LEN;\r\n*outlen += 1) {\r\nif (escape && (*ip == ':')) {\r\nif (i > len - 5)\r\nreturn -EINVAL;\r\nec = 0;\r\nfor (k = 1; k < 5; k++) {\r\nnc = ip[k];\r\nec <<= 4;\r\nif (nc >= '0' && nc <= '9') {\r\nec |= nc - '0';\r\ncontinue;\r\n}\r\nif (nc >= 'a' && nc <= 'f') {\r\nec |= nc - ('a' - 10);\r\ncontinue;\r\n}\r\nif (nc >= 'A' && nc <= 'F') {\r\nec |= nc - ('A' - 10);\r\ncontinue;\r\n}\r\nreturn -EINVAL;\r\n}\r\n*op++ = ec & 0xFF;\r\n*op++ = ec >> 8;\r\nip += 5;\r\ni += 5;\r\n} else {\r\ncharlen = nls->char2uni(ip, len - i,\r\n(wchar_t *)op);\r\nif (charlen < 0)\r\nreturn -EINVAL;\r\nip += charlen;\r\ni += charlen;\r\nop += 2;\r\n}\r\n}\r\nif (i < len)\r\nreturn -ENAMETOOLONG;\r\n}\r\n*longlen = *outlen;\r\nif (*outlen % 13) {\r\n*op++ = 0;\r\n*op++ = 0;\r\n*outlen += 1;\r\nif (*outlen % 13) {\r\nfill = 13 - (*outlen % 13);\r\nfor (i = 0; i < fill; i++) {\r\n*op++ = 0xff;\r\n*op++ = 0xff;\r\n}\r\n*outlen += fill;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int vfat_build_slots(struct inode *dir, const unsigned char *name,\r\nint len, int is_dir, int cluster,\r\nstruct timespec *ts,\r\nstruct msdos_dir_slot *slots, int *nr_slots)\r\n{\r\nstruct msdos_sb_info *sbi = MSDOS_SB(dir->i_sb);\r\nstruct fat_mount_options *opts = &sbi->options;\r\nstruct msdos_dir_slot *ps;\r\nstruct msdos_dir_entry *de;\r\nunsigned char cksum, lcase;\r\nunsigned char msdos_name[MSDOS_NAME];\r\nwchar_t *uname;\r\n__le16 time, date;\r\nu8 time_cs;\r\nint err, ulen, usize, i;\r\nloff_t offset;\r\n*nr_slots = 0;\r\nuname = __getname();\r\nif (!uname)\r\nreturn -ENOMEM;\r\nerr = xlate_to_uni(name, len, (unsigned char *)uname, &ulen, &usize,\r\nopts->unicode_xlate, opts->utf8, sbi->nls_io);\r\nif (err)\r\ngoto out_free;\r\nerr = vfat_is_used_badchars(uname, ulen);\r\nif (err)\r\ngoto out_free;\r\nerr = vfat_create_shortname(dir, sbi->nls_disk, uname, ulen,\r\nmsdos_name, &lcase);\r\nif (err < 0)\r\ngoto out_free;\r\nelse if (err == 1) {\r\nde = (struct msdos_dir_entry *)slots;\r\nerr = 0;\r\ngoto shortname;\r\n}\r\ncksum = fat_checksum(msdos_name);\r\n*nr_slots = usize / 13;\r\nfor (ps = slots, i = *nr_slots; i > 0; i--, ps++) {\r\nps->id = i;\r\nps->attr = ATTR_EXT;\r\nps->reserved = 0;\r\nps->alias_checksum = cksum;\r\nps->start = 0;\r\noffset = (i - 1) * 13;\r\nfatwchar_to16(ps->name0_4, uname + offset, 5);\r\nfatwchar_to16(ps->name5_10, uname + offset + 5, 6);\r\nfatwchar_to16(ps->name11_12, uname + offset + 11, 2);\r\n}\r\nslots[0].id |= 0x40;\r\nde = (struct msdos_dir_entry *)ps;\r\nshortname:\r\n(*nr_slots)++;\r\nmemcpy(de->name, msdos_name, MSDOS_NAME);\r\nde->attr = is_dir ? ATTR_DIR : ATTR_ARCH;\r\nde->lcase = lcase;\r\nfat_time_unix2fat(sbi, ts, &time, &date, &time_cs);\r\nde->time = de->ctime = time;\r\nde->date = de->cdate = de->adate = date;\r\nde->ctime_cs = time_cs;\r\nfat_set_start(de, cluster);\r\nde->size = 0;\r\nout_free:\r\n__putname(uname);\r\nreturn err;\r\n}\r\nstatic int vfat_add_entry(struct inode *dir, struct qstr *qname, int is_dir,\r\nint cluster, struct timespec *ts,\r\nstruct fat_slot_info *sinfo)\r\n{\r\nstruct msdos_dir_slot *slots;\r\nunsigned int len;\r\nint err, nr_slots;\r\nlen = vfat_striptail_len(qname);\r\nif (len == 0)\r\nreturn -ENOENT;\r\nslots = kmalloc(sizeof(*slots) * MSDOS_SLOTS, GFP_NOFS);\r\nif (slots == NULL)\r\nreturn -ENOMEM;\r\nerr = vfat_build_slots(dir, qname->name, len, is_dir, cluster, ts,\r\nslots, &nr_slots);\r\nif (err)\r\ngoto cleanup;\r\nerr = fat_add_entries(dir, slots, nr_slots, sinfo);\r\nif (err)\r\ngoto cleanup;\r\ndir->i_ctime = dir->i_mtime = dir->i_atime = *ts;\r\nif (IS_DIRSYNC(dir))\r\n(void)fat_sync_inode(dir);\r\nelse\r\nmark_inode_dirty(dir);\r\ncleanup:\r\nkfree(slots);\r\nreturn err;\r\n}\r\nstatic int vfat_find(struct inode *dir, struct qstr *qname,\r\nstruct fat_slot_info *sinfo)\r\n{\r\nunsigned int len = vfat_striptail_len(qname);\r\nif (len == 0)\r\nreturn -ENOENT;\r\nreturn fat_search_long(dir, qname->name, len, sinfo);\r\n}\r\nstatic int vfat_d_anon_disconn(struct dentry *dentry)\r\n{\r\nreturn IS_ROOT(dentry) && (dentry->d_flags & DCACHE_DISCONNECTED);\r\n}\r\nstatic struct dentry *vfat_lookup(struct inode *dir, struct dentry *dentry,\r\nunsigned int flags)\r\n{\r\nstruct super_block *sb = dir->i_sb;\r\nstruct fat_slot_info sinfo;\r\nstruct inode *inode;\r\nstruct dentry *alias;\r\nint err;\r\nmutex_lock(&MSDOS_SB(sb)->s_lock);\r\nerr = vfat_find(dir, &dentry->d_name, &sinfo);\r\nif (err) {\r\nif (err == -ENOENT) {\r\ninode = NULL;\r\ngoto out;\r\n}\r\ngoto error;\r\n}\r\ninode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\r\nbrelse(sinfo.bh);\r\nif (IS_ERR(inode)) {\r\nerr = PTR_ERR(inode);\r\ngoto error;\r\n}\r\nalias = d_find_alias(inode);\r\nif (alias && alias->d_parent == dentry->d_parent &&\r\n!vfat_d_anon_disconn(alias)) {\r\nBUG_ON(d_unhashed(alias));\r\nif (!S_ISDIR(inode->i_mode))\r\nd_move(alias, dentry);\r\niput(inode);\r\nmutex_unlock(&MSDOS_SB(sb)->s_lock);\r\nreturn alias;\r\n} else\r\ndput(alias);\r\nout:\r\nmutex_unlock(&MSDOS_SB(sb)->s_lock);\r\nif (!inode)\r\ndentry->d_time = dir->i_version;\r\nreturn d_splice_alias(inode, dentry);\r\nerror:\r\nmutex_unlock(&MSDOS_SB(sb)->s_lock);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int vfat_create(struct inode *dir, struct dentry *dentry, umode_t mode,\r\nbool excl)\r\n{\r\nstruct super_block *sb = dir->i_sb;\r\nstruct inode *inode;\r\nstruct fat_slot_info sinfo;\r\nstruct timespec ts;\r\nint err;\r\nmutex_lock(&MSDOS_SB(sb)->s_lock);\r\nts = CURRENT_TIME_SEC;\r\nerr = vfat_add_entry(dir, &dentry->d_name, 0, 0, &ts, &sinfo);\r\nif (err)\r\ngoto out;\r\ndir->i_version++;\r\ninode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\r\nbrelse(sinfo.bh);\r\nif (IS_ERR(inode)) {\r\nerr = PTR_ERR(inode);\r\ngoto out;\r\n}\r\ninode->i_version++;\r\ninode->i_mtime = inode->i_atime = inode->i_ctime = ts;\r\nd_instantiate(dentry, inode);\r\nout:\r\nmutex_unlock(&MSDOS_SB(sb)->s_lock);\r\nreturn err;\r\n}\r\nstatic int vfat_rmdir(struct inode *dir, struct dentry *dentry)\r\n{\r\nstruct inode *inode = d_inode(dentry);\r\nstruct super_block *sb = dir->i_sb;\r\nstruct fat_slot_info sinfo;\r\nint err;\r\nmutex_lock(&MSDOS_SB(sb)->s_lock);\r\nerr = fat_dir_empty(inode);\r\nif (err)\r\ngoto out;\r\nerr = vfat_find(dir, &dentry->d_name, &sinfo);\r\nif (err)\r\ngoto out;\r\nerr = fat_remove_entries(dir, &sinfo);\r\nif (err)\r\ngoto out;\r\ndrop_nlink(dir);\r\nclear_nlink(inode);\r\ninode->i_mtime = inode->i_atime = CURRENT_TIME_SEC;\r\nfat_detach(inode);\r\ndentry->d_time = dir->i_version;\r\nout:\r\nmutex_unlock(&MSDOS_SB(sb)->s_lock);\r\nreturn err;\r\n}\r\nstatic int vfat_unlink(struct inode *dir, struct dentry *dentry)\r\n{\r\nstruct inode *inode = d_inode(dentry);\r\nstruct super_block *sb = dir->i_sb;\r\nstruct fat_slot_info sinfo;\r\nint err;\r\nmutex_lock(&MSDOS_SB(sb)->s_lock);\r\nerr = vfat_find(dir, &dentry->d_name, &sinfo);\r\nif (err)\r\ngoto out;\r\nerr = fat_remove_entries(dir, &sinfo);\r\nif (err)\r\ngoto out;\r\nclear_nlink(inode);\r\ninode->i_mtime = inode->i_atime = CURRENT_TIME_SEC;\r\nfat_detach(inode);\r\ndentry->d_time = dir->i_version;\r\nout:\r\nmutex_unlock(&MSDOS_SB(sb)->s_lock);\r\nreturn err;\r\n}\r\nstatic int vfat_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\r\n{\r\nstruct super_block *sb = dir->i_sb;\r\nstruct inode *inode;\r\nstruct fat_slot_info sinfo;\r\nstruct timespec ts;\r\nint err, cluster;\r\nmutex_lock(&MSDOS_SB(sb)->s_lock);\r\nts = CURRENT_TIME_SEC;\r\ncluster = fat_alloc_new_dir(dir, &ts);\r\nif (cluster < 0) {\r\nerr = cluster;\r\ngoto out;\r\n}\r\nerr = vfat_add_entry(dir, &dentry->d_name, 1, cluster, &ts, &sinfo);\r\nif (err)\r\ngoto out_free;\r\ndir->i_version++;\r\ninc_nlink(dir);\r\ninode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\r\nbrelse(sinfo.bh);\r\nif (IS_ERR(inode)) {\r\nerr = PTR_ERR(inode);\r\ngoto out;\r\n}\r\ninode->i_version++;\r\nset_nlink(inode, 2);\r\ninode->i_mtime = inode->i_atime = inode->i_ctime = ts;\r\nd_instantiate(dentry, inode);\r\nmutex_unlock(&MSDOS_SB(sb)->s_lock);\r\nreturn 0;\r\nout_free:\r\nfat_free_clusters(dir, cluster);\r\nout:\r\nmutex_unlock(&MSDOS_SB(sb)->s_lock);\r\nreturn err;\r\n}\r\nstatic int vfat_rename(struct inode *old_dir, struct dentry *old_dentry,\r\nstruct inode *new_dir, struct dentry *new_dentry)\r\n{\r\nstruct buffer_head *dotdot_bh;\r\nstruct msdos_dir_entry *dotdot_de;\r\nstruct inode *old_inode, *new_inode;\r\nstruct fat_slot_info old_sinfo, sinfo;\r\nstruct timespec ts;\r\nloff_t new_i_pos;\r\nint err, is_dir, update_dotdot, corrupt = 0;\r\nstruct super_block *sb = old_dir->i_sb;\r\nold_sinfo.bh = sinfo.bh = dotdot_bh = NULL;\r\nold_inode = d_inode(old_dentry);\r\nnew_inode = d_inode(new_dentry);\r\nmutex_lock(&MSDOS_SB(sb)->s_lock);\r\nerr = vfat_find(old_dir, &old_dentry->d_name, &old_sinfo);\r\nif (err)\r\ngoto out;\r\nis_dir = S_ISDIR(old_inode->i_mode);\r\nupdate_dotdot = (is_dir && old_dir != new_dir);\r\nif (update_dotdot) {\r\nif (fat_get_dotdot_entry(old_inode, &dotdot_bh, &dotdot_de)) {\r\nerr = -EIO;\r\ngoto out;\r\n}\r\n}\r\nts = CURRENT_TIME_SEC;\r\nif (new_inode) {\r\nif (is_dir) {\r\nerr = fat_dir_empty(new_inode);\r\nif (err)\r\ngoto out;\r\n}\r\nnew_i_pos = MSDOS_I(new_inode)->i_pos;\r\nfat_detach(new_inode);\r\n} else {\r\nerr = vfat_add_entry(new_dir, &new_dentry->d_name, is_dir, 0,\r\n&ts, &sinfo);\r\nif (err)\r\ngoto out;\r\nnew_i_pos = sinfo.i_pos;\r\n}\r\nnew_dir->i_version++;\r\nfat_detach(old_inode);\r\nfat_attach(old_inode, new_i_pos);\r\nif (IS_DIRSYNC(new_dir)) {\r\nerr = fat_sync_inode(old_inode);\r\nif (err)\r\ngoto error_inode;\r\n} else\r\nmark_inode_dirty(old_inode);\r\nif (update_dotdot) {\r\nfat_set_start(dotdot_de, MSDOS_I(new_dir)->i_logstart);\r\nmark_buffer_dirty_inode(dotdot_bh, old_inode);\r\nif (IS_DIRSYNC(new_dir)) {\r\nerr = sync_dirty_buffer(dotdot_bh);\r\nif (err)\r\ngoto error_dotdot;\r\n}\r\ndrop_nlink(old_dir);\r\nif (!new_inode)\r\ninc_nlink(new_dir);\r\n}\r\nerr = fat_remove_entries(old_dir, &old_sinfo);\r\nold_sinfo.bh = NULL;\r\nif (err)\r\ngoto error_dotdot;\r\nold_dir->i_version++;\r\nold_dir->i_ctime = old_dir->i_mtime = ts;\r\nif (IS_DIRSYNC(old_dir))\r\n(void)fat_sync_inode(old_dir);\r\nelse\r\nmark_inode_dirty(old_dir);\r\nif (new_inode) {\r\ndrop_nlink(new_inode);\r\nif (is_dir)\r\ndrop_nlink(new_inode);\r\nnew_inode->i_ctime = ts;\r\n}\r\nout:\r\nbrelse(sinfo.bh);\r\nbrelse(dotdot_bh);\r\nbrelse(old_sinfo.bh);\r\nmutex_unlock(&MSDOS_SB(sb)->s_lock);\r\nreturn err;\r\nerror_dotdot:\r\ncorrupt = 1;\r\nif (update_dotdot) {\r\nfat_set_start(dotdot_de, MSDOS_I(old_dir)->i_logstart);\r\nmark_buffer_dirty_inode(dotdot_bh, old_inode);\r\ncorrupt |= sync_dirty_buffer(dotdot_bh);\r\n}\r\nerror_inode:\r\nfat_detach(old_inode);\r\nfat_attach(old_inode, old_sinfo.i_pos);\r\nif (new_inode) {\r\nfat_attach(new_inode, new_i_pos);\r\nif (corrupt)\r\ncorrupt |= fat_sync_inode(new_inode);\r\n} else {\r\nint err2 = fat_remove_entries(new_dir, &sinfo);\r\nif (corrupt)\r\ncorrupt |= err2;\r\nsinfo.bh = NULL;\r\n}\r\nif (corrupt < 0) {\r\nfat_fs_error(new_dir->i_sb,\r\n"%s: Filesystem corrupted (i_pos %lld)",\r\n__func__, sinfo.i_pos);\r\n}\r\ngoto out;\r\n}\r\nstatic void setup(struct super_block *sb)\r\n{\r\nMSDOS_SB(sb)->dir_ops = &vfat_dir_inode_operations;\r\nif (MSDOS_SB(sb)->options.name_check != 's')\r\nsb->s_d_op = &vfat_ci_dentry_ops;\r\nelse\r\nsb->s_d_op = &vfat_dentry_ops;\r\n}\r\nstatic int vfat_fill_super(struct super_block *sb, void *data, int silent)\r\n{\r\nreturn fat_fill_super(sb, data, silent, 1, setup);\r\n}\r\nstatic struct dentry *vfat_mount(struct file_system_type *fs_type,\r\nint flags, const char *dev_name,\r\nvoid *data)\r\n{\r\nreturn mount_bdev(fs_type, flags, dev_name, data, vfat_fill_super);\r\n}\r\nstatic int __init init_vfat_fs(void)\r\n{\r\nreturn register_filesystem(&vfat_fs_type);\r\n}\r\nstatic void __exit exit_vfat_fs(void)\r\n{\r\nunregister_filesystem(&vfat_fs_type);\r\n}
