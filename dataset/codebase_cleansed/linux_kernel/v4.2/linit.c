static int aac_queuecommand(struct Scsi_Host *shost,\r\nstruct scsi_cmnd *cmd)\r\n{\r\nint r = 0;\r\ncmd->SCp.phase = AAC_OWNER_LOWLEVEL;\r\nr = (aac_scsi_cmd(cmd) ? FAILED : 0);\r\nreturn r;\r\n}\r\nstatic const char *aac_info(struct Scsi_Host *shost)\r\n{\r\nstruct aac_dev *dev = (struct aac_dev *)shost->hostdata;\r\nreturn aac_drivers[dev->cardtype].name;\r\n}\r\nstruct aac_driver_ident* aac_get_driver_ident(int devtype)\r\n{\r\nreturn &aac_drivers[devtype];\r\n}\r\nstatic int aac_biosparm(struct scsi_device *sdev, struct block_device *bdev,\r\nsector_t capacity, int *geom)\r\n{\r\nstruct diskparm *param = (struct diskparm *)geom;\r\nunsigned char *buf;\r\ndprintk((KERN_DEBUG "aac_biosparm.\n"));\r\nif (capacity >= 2 * 1024 * 1024) {\r\nif(capacity >= 4 * 1024 * 1024) {\r\nparam->heads = 255;\r\nparam->sectors = 63;\r\n} else {\r\nparam->heads = 128;\r\nparam->sectors = 32;\r\n}\r\n} else {\r\nparam->heads = 64;\r\nparam->sectors = 32;\r\n}\r\nparam->cylinders = cap_to_cyls(capacity, param->heads * param->sectors);\r\nbuf = scsi_bios_ptable(bdev);\r\nif (!buf)\r\nreturn 0;\r\nif(*(__le16 *)(buf + 0x40) == cpu_to_le16(0xaa55)) {\r\nstruct partition *first = (struct partition * )buf;\r\nstruct partition *entry = first;\r\nint saved_cylinders = param->cylinders;\r\nint num;\r\nunsigned char end_head, end_sec;\r\nfor(num = 0; num < 4; num++) {\r\nend_head = entry->end_head;\r\nend_sec = entry->end_sector & 0x3f;\r\nif(end_head == 63) {\r\nparam->heads = 64;\r\nparam->sectors = 32;\r\nbreak;\r\n} else if(end_head == 127) {\r\nparam->heads = 128;\r\nparam->sectors = 32;\r\nbreak;\r\n} else if(end_head == 254) {\r\nparam->heads = 255;\r\nparam->sectors = 63;\r\nbreak;\r\n}\r\nentry++;\r\n}\r\nif (num == 4) {\r\nend_head = first->end_head;\r\nend_sec = first->end_sector & 0x3f;\r\n}\r\nparam->cylinders = cap_to_cyls(capacity, param->heads * param->sectors);\r\nif (num < 4 && end_sec == param->sectors) {\r\nif (param->cylinders != saved_cylinders)\r\ndprintk((KERN_DEBUG "Adopting geometry: heads=%d, sectors=%d from partition table %d.\n",\r\nparam->heads, param->sectors, num));\r\n} else if (end_head > 0 || end_sec > 0) {\r\ndprintk((KERN_DEBUG "Strange geometry: heads=%d, sectors=%d in partition table %d.\n",\r\nend_head + 1, end_sec, num));\r\ndprintk((KERN_DEBUG "Using geometry: heads=%d, sectors=%d.\n",\r\nparam->heads, param->sectors));\r\n}\r\n}\r\nkfree(buf);\r\nreturn 0;\r\n}\r\nstatic int aac_slave_configure(struct scsi_device *sdev)\r\n{\r\nstruct aac_dev *aac = (struct aac_dev *)sdev->host->hostdata;\r\nif (aac->jbod && (sdev->type == TYPE_DISK))\r\nsdev->removable = 1;\r\nif ((sdev->type == TYPE_DISK) &&\r\n(sdev_channel(sdev) != CONTAINER_CHANNEL) &&\r\n(!aac->jbod || sdev->inq_periph_qual) &&\r\n(!aac->raid_scsi_mode || (sdev_channel(sdev) != 2))) {\r\nif (expose_physicals == 0)\r\nreturn -ENXIO;\r\nif (expose_physicals < 0)\r\nsdev->no_uld_attach = 1;\r\n}\r\nif (sdev->tagged_supported && (sdev->type == TYPE_DISK) &&\r\n(!aac->raid_scsi_mode || (sdev_channel(sdev) != 2)) &&\r\n!sdev->no_uld_attach) {\r\nstruct scsi_device * dev;\r\nstruct Scsi_Host *host = sdev->host;\r\nunsigned num_lsu = 0;\r\nunsigned num_one = 0;\r\nunsigned depth;\r\nunsigned cid;\r\nif (sdev->request_queue->rq_timeout < (45 * HZ))\r\nblk_queue_rq_timeout(sdev->request_queue, 45*HZ);\r\nfor (cid = 0; cid < aac->maximum_num_containers; ++cid)\r\nif (aac->fsa_dev[cid].valid)\r\n++num_lsu;\r\n__shost_for_each_device(dev, host) {\r\nif (dev->tagged_supported && (dev->type == TYPE_DISK) &&\r\n(!aac->raid_scsi_mode ||\r\n(sdev_channel(sdev) != 2)) &&\r\n!dev->no_uld_attach) {\r\nif ((sdev_channel(dev) != CONTAINER_CHANNEL)\r\n|| !aac->fsa_dev[sdev_id(dev)].valid)\r\n++num_lsu;\r\n} else\r\n++num_one;\r\n}\r\nif (num_lsu == 0)\r\n++num_lsu;\r\ndepth = (host->can_queue - num_one) / num_lsu;\r\nif (depth > 256)\r\ndepth = 256;\r\nelse if (depth < 2)\r\ndepth = 2;\r\nscsi_change_queue_depth(sdev, depth);\r\n} else\r\nscsi_change_queue_depth(sdev, 1);\r\nreturn 0;\r\n}\r\nstatic int aac_change_queue_depth(struct scsi_device *sdev, int depth)\r\n{\r\nif (sdev->tagged_supported && (sdev->type == TYPE_DISK) &&\r\n(sdev_channel(sdev) == CONTAINER_CHANNEL)) {\r\nstruct scsi_device * dev;\r\nstruct Scsi_Host *host = sdev->host;\r\nunsigned num = 0;\r\n__shost_for_each_device(dev, host) {\r\nif (dev->tagged_supported && (dev->type == TYPE_DISK) &&\r\n(sdev_channel(dev) == CONTAINER_CHANNEL))\r\n++num;\r\n++num;\r\n}\r\nif (num >= host->can_queue)\r\nnum = host->can_queue - 1;\r\nif (depth > (host->can_queue - num))\r\ndepth = host->can_queue - num;\r\nif (depth > 256)\r\ndepth = 256;\r\nelse if (depth < 2)\r\ndepth = 2;\r\nreturn scsi_change_queue_depth(sdev, depth);\r\n}\r\nreturn scsi_change_queue_depth(sdev, 1);\r\n}\r\nstatic ssize_t aac_show_raid_level(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nstruct aac_dev *aac = (struct aac_dev *)(sdev->host->hostdata);\r\nif (sdev_channel(sdev) != CONTAINER_CHANNEL)\r\nreturn snprintf(buf, PAGE_SIZE, sdev->no_uld_attach\r\n? "Hidden\n" :\r\n((aac->jbod && (sdev->type == TYPE_DISK)) ? "JBOD\n" : ""));\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\nget_container_type(aac->fsa_dev[sdev_id(sdev)].type));\r\n}\r\nstatic int aac_ioctl(struct scsi_device *sdev, int cmd, void __user * arg)\r\n{\r\nstruct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;\r\nif (!capable(CAP_SYS_RAWIO))\r\nreturn -EPERM;\r\nreturn aac_do_ioctl(dev, cmd, arg);\r\n}\r\nstatic int aac_eh_abort(struct scsi_cmnd* cmd)\r\n{\r\nstruct scsi_device * dev = cmd->device;\r\nstruct Scsi_Host * host = dev->host;\r\nstruct aac_dev * aac = (struct aac_dev *)host->hostdata;\r\nint count;\r\nint ret = FAILED;\r\nprintk(KERN_ERR "%s: Host adapter abort request (%d,%d,%d,%llu)\n",\r\nAAC_DRIVERNAME,\r\nhost->host_no, sdev_channel(dev), sdev_id(dev), dev->lun);\r\nswitch (cmd->cmnd[0]) {\r\ncase SERVICE_ACTION_IN_16:\r\nif (!(aac->raw_io_interface) ||\r\n!(aac->raw_io_64) ||\r\n((cmd->cmnd[1] & 0x1f) != SAI_READ_CAPACITY_16))\r\nbreak;\r\ncase INQUIRY:\r\ncase READ_CAPACITY:\r\nfor (count = 0; count < (host->can_queue + AAC_NUM_MGT_FIB); ++count) {\r\nstruct fib * fib = &aac->fibs[count];\r\nif (fib->hw_fib_va->header.XferState &&\r\n(fib->flags & FIB_CONTEXT_FLAG) &&\r\n(fib->callback_data == cmd)) {\r\nfib->flags |= FIB_CONTEXT_FLAG_TIMED_OUT;\r\ncmd->SCp.phase = AAC_OWNER_ERROR_HANDLER;\r\nret = SUCCESS;\r\n}\r\n}\r\nbreak;\r\ncase TEST_UNIT_READY:\r\nfor (count = 0; count < (host->can_queue + AAC_NUM_MGT_FIB); ++count) {\r\nstruct scsi_cmnd * command;\r\nstruct fib * fib = &aac->fibs[count];\r\nif ((fib->hw_fib_va->header.XferState & cpu_to_le32(Async | NoResponseExpected)) &&\r\n(fib->flags & FIB_CONTEXT_FLAG) &&\r\n((command = fib->callback_data)) &&\r\n(command->device == cmd->device)) {\r\nfib->flags |= FIB_CONTEXT_FLAG_TIMED_OUT;\r\ncommand->SCp.phase = AAC_OWNER_ERROR_HANDLER;\r\nif (command == cmd)\r\nret = SUCCESS;\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int aac_eh_reset(struct scsi_cmnd* cmd)\r\n{\r\nstruct scsi_device * dev = cmd->device;\r\nstruct Scsi_Host * host = dev->host;\r\nstruct scsi_cmnd * command;\r\nint count;\r\nstruct aac_dev * aac = (struct aac_dev *)host->hostdata;\r\nunsigned long flags;\r\nfor (count = 0; count < (host->can_queue + AAC_NUM_MGT_FIB); ++count) {\r\nstruct fib * fib = &aac->fibs[count];\r\nif (fib->hw_fib_va->header.XferState &&\r\n(fib->flags & FIB_CONTEXT_FLAG) &&\r\n(fib->callback_data == cmd)) {\r\nfib->flags |= FIB_CONTEXT_FLAG_TIMED_OUT;\r\ncmd->SCp.phase = AAC_OWNER_ERROR_HANDLER;\r\n}\r\n}\r\nprintk(KERN_ERR "%s: Host adapter reset request. SCSI hang ?\n",\r\nAAC_DRIVERNAME);\r\nif ((count = aac_check_health(aac)))\r\nreturn count;\r\nfor (count = 60; count; --count) {\r\nint active = aac->in_reset;\r\nif (active == 0)\r\n__shost_for_each_device(dev, host) {\r\nspin_lock_irqsave(&dev->list_lock, flags);\r\nlist_for_each_entry(command, &dev->cmd_list, list) {\r\nif ((command != cmd) &&\r\n(command->SCp.phase == AAC_OWNER_FIRMWARE)) {\r\nactive++;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&dev->list_lock, flags);\r\nif (active)\r\nbreak;\r\n}\r\nif (active == 0)\r\nreturn SUCCESS;\r\nssleep(1);\r\n}\r\nprintk(KERN_ERR "%s: SCSI bus appears hung\n", AAC_DRIVERNAME);\r\nif (((aac->supplement_adapter_info.SupportedOptions2 &\r\nAAC_OPTION_MU_RESET) ||\r\n(aac->supplement_adapter_info.SupportedOptions2 &\r\nAAC_OPTION_DOORBELL_RESET)) &&\r\naac_check_reset &&\r\n((aac_check_reset != 1) ||\r\n!(aac->supplement_adapter_info.SupportedOptions2 &\r\nAAC_OPTION_IGNORE_RESET)))\r\naac_reset_adapter(aac, 2);\r\nreturn SUCCESS;\r\n}\r\nstatic int aac_cfg_open(struct inode *inode, struct file *file)\r\n{\r\nstruct aac_dev *aac;\r\nunsigned minor_number = iminor(inode);\r\nint err = -ENODEV;\r\nmutex_lock(&aac_mutex);\r\nlist_for_each_entry(aac, &aac_devices, entry) {\r\nif (aac->id == minor_number) {\r\nfile->private_data = aac;\r\nerr = 0;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&aac_mutex);\r\nreturn err;\r\n}\r\nstatic long aac_cfg_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nint ret;\r\nstruct aac_dev *aac;\r\naac = (struct aac_dev *)file->private_data;\r\nif (!capable(CAP_SYS_RAWIO) || aac->adapter_shutdown)\r\nreturn -EPERM;\r\nmutex_lock(&aac_mutex);\r\nret = aac_do_ioctl(file->private_data, cmd, (void __user *)arg);\r\nmutex_unlock(&aac_mutex);\r\nreturn ret;\r\n}\r\nstatic long aac_compat_do_ioctl(struct aac_dev *dev, unsigned cmd, unsigned long arg)\r\n{\r\nlong ret;\r\nmutex_lock(&aac_mutex);\r\nswitch (cmd) {\r\ncase FSACTL_MINIPORT_REV_CHECK:\r\ncase FSACTL_SENDFIB:\r\ncase FSACTL_OPEN_GET_ADAPTER_FIB:\r\ncase FSACTL_CLOSE_GET_ADAPTER_FIB:\r\ncase FSACTL_SEND_RAW_SRB:\r\ncase FSACTL_GET_PCI_INFO:\r\ncase FSACTL_QUERY_DISK:\r\ncase FSACTL_DELETE_DISK:\r\ncase FSACTL_FORCE_DELETE_DISK:\r\ncase FSACTL_GET_CONTAINERS:\r\ncase FSACTL_SEND_LARGE_FIB:\r\nret = aac_do_ioctl(dev, cmd, (void __user *)arg);\r\nbreak;\r\ncase FSACTL_GET_NEXT_ADAPTER_FIB: {\r\nstruct fib_ioctl __user *f;\r\nf = compat_alloc_user_space(sizeof(*f));\r\nret = 0;\r\nif (clear_user(f, sizeof(*f)))\r\nret = -EFAULT;\r\nif (copy_in_user(f, (void __user *)arg, sizeof(struct fib_ioctl) - sizeof(u32)))\r\nret = -EFAULT;\r\nif (!ret)\r\nret = aac_do_ioctl(dev, cmd, f);\r\nbreak;\r\n}\r\ndefault:\r\nret = -ENOIOCTLCMD;\r\nbreak;\r\n}\r\nmutex_unlock(&aac_mutex);\r\nreturn ret;\r\n}\r\nstatic int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)\r\n{\r\nstruct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;\r\nif (!capable(CAP_SYS_RAWIO))\r\nreturn -EPERM;\r\nreturn aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);\r\n}\r\nstatic long aac_compat_cfg_ioctl(struct file *file, unsigned cmd, unsigned long arg)\r\n{\r\nif (!capable(CAP_SYS_RAWIO))\r\nreturn -EPERM;\r\nreturn aac_compat_do_ioctl(file->private_data, cmd, arg);\r\n}\r\nstatic ssize_t aac_show_model(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct aac_dev *dev = (struct aac_dev*)class_to_shost(device)->hostdata;\r\nint len;\r\nif (dev->supplement_adapter_info.AdapterTypeText[0]) {\r\nchar * cp = dev->supplement_adapter_info.AdapterTypeText;\r\nwhile (*cp && *cp != ' ')\r\n++cp;\r\nwhile (*cp == ' ')\r\n++cp;\r\nlen = snprintf(buf, PAGE_SIZE, "%s\n", cp);\r\n} else\r\nlen = snprintf(buf, PAGE_SIZE, "%s\n",\r\naac_drivers[dev->cardtype].model);\r\nreturn len;\r\n}\r\nstatic ssize_t aac_show_vendor(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct aac_dev *dev = (struct aac_dev*)class_to_shost(device)->hostdata;\r\nint len;\r\nif (dev->supplement_adapter_info.AdapterTypeText[0]) {\r\nchar * cp = dev->supplement_adapter_info.AdapterTypeText;\r\nwhile (*cp && *cp != ' ')\r\n++cp;\r\nlen = snprintf(buf, PAGE_SIZE, "%.*s\n",\r\n(int)(cp - (char *)dev->supplement_adapter_info.AdapterTypeText),\r\ndev->supplement_adapter_info.AdapterTypeText);\r\n} else\r\nlen = snprintf(buf, PAGE_SIZE, "%s\n",\r\naac_drivers[dev->cardtype].vname);\r\nreturn len;\r\n}\r\nstatic ssize_t aac_show_flags(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint len = 0;\r\nstruct aac_dev *dev = (struct aac_dev*)class_to_shost(cdev)->hostdata;\r\nif (nblank(dprintk(x)))\r\nlen = snprintf(buf, PAGE_SIZE, "dprintk\n");\r\n#ifdef AAC_DETAILED_STATUS_INFO\r\nlen += snprintf(buf + len, PAGE_SIZE - len,\r\n"AAC_DETAILED_STATUS_INFO\n");\r\n#endif\r\nif (dev->raw_io_interface && dev->raw_io_64)\r\nlen += snprintf(buf + len, PAGE_SIZE - len,\r\n"SAI_READ_CAPACITY_16\n");\r\nif (dev->jbod)\r\nlen += snprintf(buf + len, PAGE_SIZE - len, "SUPPORTED_JBOD\n");\r\nif (dev->supplement_adapter_info.SupportedOptions2 &\r\nAAC_OPTION_POWER_MANAGEMENT)\r\nlen += snprintf(buf + len, PAGE_SIZE - len,\r\n"SUPPORTED_POWER_MANAGEMENT\n");\r\nif (dev->msi)\r\nlen += snprintf(buf + len, PAGE_SIZE - len, "PCI_HAS_MSI\n");\r\nreturn len;\r\n}\r\nstatic ssize_t aac_show_kernel_version(struct device *device,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct aac_dev *dev = (struct aac_dev*)class_to_shost(device)->hostdata;\r\nint len, tmp;\r\ntmp = le32_to_cpu(dev->adapter_info.kernelrev);\r\nlen = snprintf(buf, PAGE_SIZE, "%d.%d-%d[%d]\n",\r\ntmp >> 24, (tmp >> 16) & 0xff, tmp & 0xff,\r\nle32_to_cpu(dev->adapter_info.kernelbuild));\r\nreturn len;\r\n}\r\nstatic ssize_t aac_show_monitor_version(struct device *device,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct aac_dev *dev = (struct aac_dev*)class_to_shost(device)->hostdata;\r\nint len, tmp;\r\ntmp = le32_to_cpu(dev->adapter_info.monitorrev);\r\nlen = snprintf(buf, PAGE_SIZE, "%d.%d-%d[%d]\n",\r\ntmp >> 24, (tmp >> 16) & 0xff, tmp & 0xff,\r\nle32_to_cpu(dev->adapter_info.monitorbuild));\r\nreturn len;\r\n}\r\nstatic ssize_t aac_show_bios_version(struct device *device,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct aac_dev *dev = (struct aac_dev*)class_to_shost(device)->hostdata;\r\nint len, tmp;\r\ntmp = le32_to_cpu(dev->adapter_info.biosrev);\r\nlen = snprintf(buf, PAGE_SIZE, "%d.%d-%d[%d]\n",\r\ntmp >> 24, (tmp >> 16) & 0xff, tmp & 0xff,\r\nle32_to_cpu(dev->adapter_info.biosbuild));\r\nreturn len;\r\n}\r\nstatic ssize_t aac_show_serial_number(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct aac_dev *dev = (struct aac_dev*)class_to_shost(device)->hostdata;\r\nint len = 0;\r\nif (le32_to_cpu(dev->adapter_info.serial[0]) != 0xBAD0)\r\nlen = snprintf(buf, 16, "%06X\n",\r\nle32_to_cpu(dev->adapter_info.serial[0]));\r\nif (len &&\r\n!memcmp(&dev->supplement_adapter_info.MfgPcbaSerialNo[\r\nsizeof(dev->supplement_adapter_info.MfgPcbaSerialNo)-len],\r\nbuf, len-1))\r\nlen = snprintf(buf, 16, "%.*s\n",\r\n(int)sizeof(dev->supplement_adapter_info.MfgPcbaSerialNo),\r\ndev->supplement_adapter_info.MfgPcbaSerialNo);\r\nreturn min(len, 16);\r\n}\r\nstatic ssize_t aac_show_max_channel(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\nclass_to_shost(device)->max_channel);\r\n}\r\nstatic ssize_t aac_show_max_id(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\nclass_to_shost(device)->max_id);\r\n}\r\nstatic ssize_t aac_store_reset_adapter(struct device *device,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint retval = -EACCES;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn retval;\r\nretval = aac_reset_adapter((struct aac_dev*)class_to_shost(device)->hostdata, buf[0] == '!');\r\nif (retval >= 0)\r\nretval = count;\r\nreturn retval;\r\n}\r\nstatic ssize_t aac_show_reset_adapter(struct device *device,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct aac_dev *dev = (struct aac_dev*)class_to_shost(device)->hostdata;\r\nint len, tmp;\r\ntmp = aac_adapter_check_health(dev);\r\nif ((tmp == 0) && dev->in_reset)\r\ntmp = -EBUSY;\r\nlen = snprintf(buf, PAGE_SIZE, "0x%x\n", tmp);\r\nreturn len;\r\n}\r\nssize_t aac_get_serial_number(struct device *device, char *buf)\r\n{\r\nreturn aac_show_serial_number(device, &aac_serial_number, buf);\r\n}\r\nstatic void __aac_shutdown(struct aac_dev * aac)\r\n{\r\nint i;\r\nint cpu;\r\nif (aac->aif_thread) {\r\nint i;\r\nfor (i = 0; i < (aac->scsi_host_ptr->can_queue + AAC_NUM_MGT_FIB); i++) {\r\nstruct fib *fib = &aac->fibs[i];\r\nif (!(fib->hw_fib_va->header.XferState & cpu_to_le32(NoResponseExpected | Async)) &&\r\n(fib->hw_fib_va->header.XferState & cpu_to_le32(ResponseExpected)))\r\nup(&fib->event_wait);\r\n}\r\nkthread_stop(aac->thread);\r\n}\r\naac_send_shutdown(aac);\r\naac_adapter_disable_int(aac);\r\ncpu = cpumask_first(cpu_online_mask);\r\nif (aac->pdev->device == PMC_DEVICE_S6 ||\r\naac->pdev->device == PMC_DEVICE_S7 ||\r\naac->pdev->device == PMC_DEVICE_S8 ||\r\naac->pdev->device == PMC_DEVICE_S9) {\r\nif (aac->max_msix > 1) {\r\nfor (i = 0; i < aac->max_msix; i++) {\r\nif (irq_set_affinity_hint(\r\naac->msixentry[i].vector,\r\nNULL)) {\r\nprintk(KERN_ERR "%s%d: Failed to reset IRQ affinity for cpu %d\n",\r\naac->name,\r\naac->id,\r\ncpu);\r\n}\r\ncpu = cpumask_next(cpu,\r\ncpu_online_mask);\r\nfree_irq(aac->msixentry[i].vector,\r\n&(aac->aac_msix[i]));\r\n}\r\n} else {\r\nfree_irq(aac->pdev->irq,\r\n&(aac->aac_msix[0]));\r\n}\r\n} else {\r\nfree_irq(aac->pdev->irq, aac);\r\n}\r\nif (aac->msi)\r\npci_disable_msi(aac->pdev);\r\nelse if (aac->max_msix > 1)\r\npci_disable_msix(aac->pdev);\r\n}\r\nstatic int aac_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nunsigned index = id->driver_data;\r\nstruct Scsi_Host *shost;\r\nstruct aac_dev *aac;\r\nstruct list_head *insert = &aac_devices;\r\nint error = -ENODEV;\r\nint unique_id = 0;\r\nu64 dmamask;\r\nextern int aac_sync_mode;\r\nlist_for_each_entry(aac, &aac_devices, entry) {\r\nif (aac->id > unique_id)\r\nbreak;\r\ninsert = &aac->entry;\r\nunique_id++;\r\n}\r\npci_disable_link_state(pdev, PCIE_LINK_STATE_L0S | PCIE_LINK_STATE_L1 |\r\nPCIE_LINK_STATE_CLKPM);\r\nerror = pci_enable_device(pdev);\r\nif (error)\r\ngoto out;\r\nerror = -ENODEV;\r\nif (aac_drivers[index].quirks & AAC_QUIRK_31BIT)\r\ndmamask = DMA_BIT_MASK(31);\r\nelse\r\ndmamask = DMA_BIT_MASK(32);\r\nif (pci_set_dma_mask(pdev, dmamask) ||\r\npci_set_consistent_dma_mask(pdev, dmamask))\r\ngoto out_disable_pdev;\r\npci_set_master(pdev);\r\nshost = scsi_host_alloc(&aac_driver_template, sizeof(struct aac_dev));\r\nif (!shost)\r\ngoto out_disable_pdev;\r\nshost->irq = pdev->irq;\r\nshost->unique_id = unique_id;\r\nshost->max_cmd_len = 16;\r\nshost->use_cmd_list = 1;\r\naac = (struct aac_dev *)shost->hostdata;\r\naac->base_start = pci_resource_start(pdev, 0);\r\naac->scsi_host_ptr = shost;\r\naac->pdev = pdev;\r\naac->name = aac_driver_template.name;\r\naac->id = shost->unique_id;\r\naac->cardtype = index;\r\nINIT_LIST_HEAD(&aac->entry);\r\naac->fibs = kzalloc(sizeof(struct fib) * (shost->can_queue + AAC_NUM_MGT_FIB), GFP_KERNEL);\r\nif (!aac->fibs)\r\ngoto out_free_host;\r\nspin_lock_init(&aac->fib_lock);\r\naac->base_size = AAC_MIN_FOOTPRINT_SIZE;\r\nif ((*aac_drivers[index].init)(aac))\r\ngoto out_unmap;\r\nif (aac->sync_mode) {\r\nif (aac_sync_mode)\r\nprintk(KERN_INFO "%s%d: Sync. mode enforced "\r\n"by driver parameter. This will cause "\r\n"a significant performance decrease!\n",\r\naac->name,\r\naac->id);\r\nelse\r\nprintk(KERN_INFO "%s%d: Async. mode not supported "\r\n"by current driver, sync. mode enforced."\r\n"\nPlease update driver to get full performance.\n",\r\naac->name,\r\naac->id);\r\n}\r\naac->thread = kthread_run(aac_command_thread, aac, AAC_DRIVERNAME);\r\nif (IS_ERR(aac->thread)) {\r\nprintk(KERN_ERR "aacraid: Unable to create command thread.\n");\r\nerror = PTR_ERR(aac->thread);\r\naac->thread = NULL;\r\ngoto out_deinit;\r\n}\r\nif (aac_drivers[index].quirks & AAC_QUIRK_31BIT)\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)))\r\ngoto out_deinit;\r\naac->maximum_num_channels = aac_drivers[index].channels;\r\nerror = aac_get_adapter_info(aac);\r\nif (error < 0)\r\ngoto out_deinit;\r\nif ((aac_drivers[index].quirks & AAC_QUIRK_34SG) &&\r\n(shost->sg_tablesize > 34)) {\r\nshost->sg_tablesize = 34;\r\nshost->max_sectors = (shost->sg_tablesize * 8) + 112;\r\n}\r\nif ((aac_drivers[index].quirks & AAC_QUIRK_17SG) &&\r\n(shost->sg_tablesize > 17)) {\r\nshost->sg_tablesize = 17;\r\nshost->max_sectors = (shost->sg_tablesize * 8) + 112;\r\n}\r\nerror = pci_set_dma_max_seg_size(pdev,\r\n(aac->adapter_info.options & AAC_OPT_NEW_COMM) ?\r\n(shost->max_sectors << 9) : 65536);\r\nif (error)\r\ngoto out_deinit;\r\nif (aac_drivers[index].quirks & AAC_QUIRK_34SG)\r\naac->printf_enabled = 1;\r\nelse\r\naac->printf_enabled = 0;\r\nif (aac->nondasd_support || expose_physicals || aac->jbod)\r\nshost->max_channel = aac->maximum_num_channels;\r\nelse\r\nshost->max_channel = 0;\r\naac_get_config_status(aac, 0);\r\naac_get_containers(aac);\r\nlist_add(&aac->entry, insert);\r\nshost->max_id = aac->maximum_num_containers;\r\nif (shost->max_id < aac->maximum_num_physicals)\r\nshost->max_id = aac->maximum_num_physicals;\r\nif (shost->max_id < MAXIMUM_NUM_CONTAINERS)\r\nshost->max_id = MAXIMUM_NUM_CONTAINERS;\r\nelse\r\nshost->this_id = shost->max_id;\r\nshost->max_lun = AAC_MAX_LUN;\r\npci_set_drvdata(pdev, shost);\r\nerror = scsi_add_host(shost, &pdev->dev);\r\nif (error)\r\ngoto out_deinit;\r\nscsi_scan_host(shost);\r\nreturn 0;\r\nout_deinit:\r\n__aac_shutdown(aac);\r\nout_unmap:\r\naac_fib_map_free(aac);\r\nif (aac->comm_addr)\r\npci_free_consistent(aac->pdev, aac->comm_size, aac->comm_addr,\r\naac->comm_phys);\r\nkfree(aac->queues);\r\naac_adapter_ioremap(aac, 0);\r\nkfree(aac->fibs);\r\nkfree(aac->fsa_dev);\r\nout_free_host:\r\nscsi_host_put(shost);\r\nout_disable_pdev:\r\npci_disable_device(pdev);\r\nout:\r\nreturn error;\r\n}\r\nstatic void aac_shutdown(struct pci_dev *dev)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(dev);\r\nscsi_block_requests(shost);\r\n__aac_shutdown((struct aac_dev *)shost->hostdata);\r\n}\r\nstatic void aac_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *shost = pci_get_drvdata(pdev);\r\nstruct aac_dev *aac = (struct aac_dev *)shost->hostdata;\r\nscsi_remove_host(shost);\r\n__aac_shutdown(aac);\r\naac_fib_map_free(aac);\r\npci_free_consistent(aac->pdev, aac->comm_size, aac->comm_addr,\r\naac->comm_phys);\r\nkfree(aac->queues);\r\naac_adapter_ioremap(aac, 0);\r\nkfree(aac->fibs);\r\nkfree(aac->fsa_dev);\r\nlist_del(&aac->entry);\r\nscsi_host_put(shost);\r\npci_disable_device(pdev);\r\nif (list_empty(&aac_devices)) {\r\nunregister_chrdev(aac_cfg_major, "aac");\r\naac_cfg_major = -1;\r\n}\r\n}\r\nstatic int __init aac_init(void)\r\n{\r\nint error;\r\nprintk(KERN_INFO "Adaptec %s driver %s\n",\r\nAAC_DRIVERNAME, aac_driver_version);\r\nerror = pci_register_driver(&aac_pci_driver);\r\nif (error < 0)\r\nreturn error;\r\naac_cfg_major = register_chrdev( 0, "aac", &aac_cfg_fops);\r\nif (aac_cfg_major < 0) {\r\nprintk(KERN_WARNING\r\n"aacraid: unable to register \"aac\" device.\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit aac_exit(void)\r\n{\r\nif (aac_cfg_major > -1)\r\nunregister_chrdev(aac_cfg_major, "aac");\r\npci_unregister_driver(&aac_pci_driver);\r\n}
