static int st_gyro_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *ch, int *val,\r\nint *val2, long mask)\r\n{\r\nint err;\r\nstruct st_sensor_data *gdata = iio_priv(indio_dev);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nerr = st_sensors_read_info_raw(indio_dev, ch, val);\r\nif (err < 0)\r\ngoto read_error;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\n*val = 0;\r\n*val2 = gdata->current_fullscale->gain;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\n*val = gdata->odr;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nread_error:\r\nreturn err;\r\n}\r\nstatic int st_gyro_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int val, int val2, long mask)\r\n{\r\nint err;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_SCALE:\r\nerr = st_sensors_set_fullscale_by_gain(indio_dev, val2);\r\nbreak;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nif (val2)\r\nreturn -EINVAL;\r\nmutex_lock(&indio_dev->mlock);\r\nerr = st_sensors_set_odr(indio_dev, val);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn err;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nint st_gyro_common_probe(struct iio_dev *indio_dev)\r\n{\r\nstruct st_sensor_data *gdata = iio_priv(indio_dev);\r\nint irq = gdata->get_irq_data_ready(indio_dev);\r\nint err;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->info = &gyro_info;\r\nmutex_init(&gdata->tb.buf_lock);\r\nst_sensors_power_enable(indio_dev);\r\nerr = st_sensors_check_device_support(indio_dev,\r\nARRAY_SIZE(st_gyro_sensors_settings),\r\nst_gyro_sensors_settings);\r\nif (err < 0)\r\nreturn err;\r\ngdata->num_data_channels = ST_GYRO_NUMBER_DATA_CHANNELS;\r\ngdata->multiread_bit = gdata->sensor_settings->multi_read_bit;\r\nindio_dev->channels = gdata->sensor_settings->ch;\r\nindio_dev->num_channels = ST_SENSORS_NUMBER_ALL_CHANNELS;\r\ngdata->current_fullscale = (struct st_sensor_fullscale_avl *)\r\n&gdata->sensor_settings->fs.fs_avl[0];\r\ngdata->odr = gdata->sensor_settings->odr.odr_avl[0].hz;\r\nerr = st_sensors_init_sensor(indio_dev,\r\n(struct st_sensors_platform_data *)&gyro_pdata);\r\nif (err < 0)\r\nreturn err;\r\nerr = st_gyro_allocate_ring(indio_dev);\r\nif (err < 0)\r\nreturn err;\r\nif (irq > 0) {\r\nerr = st_sensors_allocate_trigger(indio_dev,\r\nST_GYRO_TRIGGER_OPS);\r\nif (err < 0)\r\ngoto st_gyro_probe_trigger_error;\r\n}\r\nerr = iio_device_register(indio_dev);\r\nif (err)\r\ngoto st_gyro_device_register_error;\r\ndev_info(&indio_dev->dev, "registered gyroscope %s\n",\r\nindio_dev->name);\r\nreturn 0;\r\nst_gyro_device_register_error:\r\nif (irq > 0)\r\nst_sensors_deallocate_trigger(indio_dev);\r\nst_gyro_probe_trigger_error:\r\nst_gyro_deallocate_ring(indio_dev);\r\nreturn err;\r\n}\r\nvoid st_gyro_common_remove(struct iio_dev *indio_dev)\r\n{\r\nstruct st_sensor_data *gdata = iio_priv(indio_dev);\r\nst_sensors_power_disable(indio_dev);\r\niio_device_unregister(indio_dev);\r\nif (gdata->get_irq_data_ready(indio_dev) > 0)\r\nst_sensors_deallocate_trigger(indio_dev);\r\nst_gyro_deallocate_ring(indio_dev);\r\n}
