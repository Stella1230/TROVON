static void flipper_pic_mask_and_ack(struct irq_data *d)\r\n{\r\nint irq = irqd_to_hwirq(d);\r\nvoid __iomem *io_base = irq_data_get_irq_chip_data(d);\r\nu32 mask = 1 << irq;\r\nclrbits32(io_base + FLIPPER_IMR, mask);\r\nout_be32(io_base + FLIPPER_ICR, mask);\r\n}\r\nstatic void flipper_pic_ack(struct irq_data *d)\r\n{\r\nint irq = irqd_to_hwirq(d);\r\nvoid __iomem *io_base = irq_data_get_irq_chip_data(d);\r\nout_be32(io_base + FLIPPER_ICR, 1 << irq);\r\n}\r\nstatic void flipper_pic_mask(struct irq_data *d)\r\n{\r\nint irq = irqd_to_hwirq(d);\r\nvoid __iomem *io_base = irq_data_get_irq_chip_data(d);\r\nclrbits32(io_base + FLIPPER_IMR, 1 << irq);\r\n}\r\nstatic void flipper_pic_unmask(struct irq_data *d)\r\n{\r\nint irq = irqd_to_hwirq(d);\r\nvoid __iomem *io_base = irq_data_get_irq_chip_data(d);\r\nsetbits32(io_base + FLIPPER_IMR, 1 << irq);\r\n}\r\nstatic int flipper_pic_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hwirq)\r\n{\r\nirq_set_chip_data(virq, h->host_data);\r\nirq_set_status_flags(virq, IRQ_LEVEL);\r\nirq_set_chip_and_handler(virq, &flipper_pic, handle_level_irq);\r\nreturn 0;\r\n}\r\nstatic int flipper_pic_match(struct irq_domain *h, struct device_node *np)\r\n{\r\nreturn 1;\r\n}\r\nstatic void __flipper_quiesce(void __iomem *io_base)\r\n{\r\nout_be32(io_base + FLIPPER_IMR, 0x00000000);\r\nout_be32(io_base + FLIPPER_ICR, 0xffffffff);\r\n}\r\nstruct irq_domain * __init flipper_pic_init(struct device_node *np)\r\n{\r\nstruct device_node *pi;\r\nstruct irq_domain *irq_domain = NULL;\r\nstruct resource res;\r\nvoid __iomem *io_base;\r\nint retval;\r\npi = of_get_parent(np);\r\nif (!pi) {\r\npr_err("no parent found\n");\r\ngoto out;\r\n}\r\nif (!of_device_is_compatible(pi, "nintendo,flipper-pi")) {\r\npr_err("unexpected parent compatible\n");\r\ngoto out;\r\n}\r\nretval = of_address_to_resource(pi, 0, &res);\r\nif (retval) {\r\npr_err("no io memory range found\n");\r\ngoto out;\r\n}\r\nio_base = ioremap(res.start, resource_size(&res));\r\npr_info("controller at 0x%08x mapped to 0x%p\n", res.start, io_base);\r\n__flipper_quiesce(io_base);\r\nirq_domain = irq_domain_add_linear(np, FLIPPER_NR_IRQS,\r\n&flipper_irq_domain_ops, io_base);\r\nif (!irq_domain) {\r\npr_err("failed to allocate irq_domain\n");\r\nreturn NULL;\r\n}\r\nout:\r\nreturn irq_domain;\r\n}\r\nunsigned int flipper_pic_get_irq(void)\r\n{\r\nvoid __iomem *io_base = flipper_irq_host->host_data;\r\nint irq;\r\nu32 irq_status;\r\nirq_status = in_be32(io_base + FLIPPER_ICR) &\r\nin_be32(io_base + FLIPPER_IMR);\r\nif (irq_status == 0)\r\nreturn NO_IRQ;\r\nirq = __ffs(irq_status);\r\nreturn irq_linear_revmap(flipper_irq_host, irq);\r\n}\r\nvoid __init flipper_pic_probe(void)\r\n{\r\nstruct device_node *np;\r\nnp = of_find_compatible_node(NULL, NULL, "nintendo,flipper-pic");\r\nBUG_ON(!np);\r\nflipper_irq_host = flipper_pic_init(np);\r\nBUG_ON(!flipper_irq_host);\r\nirq_set_default_host(flipper_irq_host);\r\nof_node_put(np);\r\n}\r\nvoid flipper_quiesce(void)\r\n{\r\nvoid __iomem *io_base = flipper_irq_host->host_data;\r\n__flipper_quiesce(io_base);\r\n}\r\nvoid flipper_platform_reset(void)\r\n{\r\nvoid __iomem *io_base;\r\nif (flipper_irq_host && flipper_irq_host->host_data) {\r\nio_base = flipper_irq_host->host_data;\r\nout_8(io_base + FLIPPER_RESET, 0x00);\r\n}\r\n}\r\nint flipper_is_reset_button_pressed(void)\r\n{\r\nvoid __iomem *io_base;\r\nu32 icr;\r\nif (flipper_irq_host && flipper_irq_host->host_data) {\r\nio_base = flipper_irq_host->host_data;\r\nicr = in_be32(io_base + FLIPPER_ICR);\r\nreturn !(icr & FLIPPER_ICR_RSS);\r\n}\r\nreturn 0;\r\n}
