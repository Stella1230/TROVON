static int rotary_encoder_get_state(const struct rotary_encoder_platform_data *pdata)\r\n{\r\nint a = !!gpio_get_value(pdata->gpio_a);\r\nint b = !!gpio_get_value(pdata->gpio_b);\r\na ^= pdata->inverted_a;\r\nb ^= pdata->inverted_b;\r\nreturn ((a << 1) | b);\r\n}\r\nstatic void rotary_encoder_report_event(struct rotary_encoder *encoder)\r\n{\r\nconst struct rotary_encoder_platform_data *pdata = encoder->pdata;\r\nif (pdata->relative_axis) {\r\ninput_report_rel(encoder->input,\r\npdata->axis, encoder->dir ? -1 : 1);\r\n} else {\r\nunsigned int pos = encoder->pos;\r\nif (encoder->dir) {\r\nif (pdata->rollover)\r\npos += pdata->steps;\r\nif (pos)\r\npos--;\r\n} else {\r\nif (pdata->rollover || pos < pdata->steps)\r\npos++;\r\n}\r\nif (pdata->rollover)\r\npos %= pdata->steps;\r\nencoder->pos = pos;\r\ninput_report_abs(encoder->input, pdata->axis, encoder->pos);\r\n}\r\ninput_sync(encoder->input);\r\n}\r\nstatic irqreturn_t rotary_encoder_irq(int irq, void *dev_id)\r\n{\r\nstruct rotary_encoder *encoder = dev_id;\r\nint state;\r\nstate = rotary_encoder_get_state(encoder->pdata);\r\nswitch (state) {\r\ncase 0x0:\r\nif (encoder->armed) {\r\nrotary_encoder_report_event(encoder);\r\nencoder->armed = false;\r\n}\r\nbreak;\r\ncase 0x1:\r\ncase 0x2:\r\nif (encoder->armed)\r\nencoder->dir = state - 1;\r\nbreak;\r\ncase 0x3:\r\nencoder->armed = true;\r\nbreak;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t rotary_encoder_half_period_irq(int irq, void *dev_id)\r\n{\r\nstruct rotary_encoder *encoder = dev_id;\r\nint state;\r\nstate = rotary_encoder_get_state(encoder->pdata);\r\nswitch (state) {\r\ncase 0x00:\r\ncase 0x03:\r\nif (state != encoder->last_stable) {\r\nrotary_encoder_report_event(encoder);\r\nencoder->last_stable = state;\r\n}\r\nbreak;\r\ncase 0x01:\r\ncase 0x02:\r\nencoder->dir = (encoder->last_stable + state) & 0x01;\r\nbreak;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic struct rotary_encoder_platform_data *rotary_encoder_parse_dt(struct device *dev)\r\n{\r\nconst struct of_device_id *of_id =\r\nof_match_device(rotary_encoder_of_match, dev);\r\nstruct device_node *np = dev->of_node;\r\nstruct rotary_encoder_platform_data *pdata;\r\nenum of_gpio_flags flags;\r\nif (!of_id || !np)\r\nreturn NULL;\r\npdata = kzalloc(sizeof(struct rotary_encoder_platform_data),\r\nGFP_KERNEL);\r\nif (!pdata)\r\nreturn ERR_PTR(-ENOMEM);\r\nof_property_read_u32(np, "rotary-encoder,steps", &pdata->steps);\r\nof_property_read_u32(np, "linux,axis", &pdata->axis);\r\npdata->gpio_a = of_get_gpio_flags(np, 0, &flags);\r\npdata->inverted_a = flags & OF_GPIO_ACTIVE_LOW;\r\npdata->gpio_b = of_get_gpio_flags(np, 1, &flags);\r\npdata->inverted_b = flags & OF_GPIO_ACTIVE_LOW;\r\npdata->relative_axis = !!of_get_property(np,\r\n"rotary-encoder,relative-axis", NULL);\r\npdata->rollover = !!of_get_property(np,\r\n"rotary-encoder,rollover", NULL);\r\npdata->half_period = !!of_get_property(np,\r\n"rotary-encoder,half-period", NULL);\r\nreturn pdata;\r\n}\r\nstatic inline struct rotary_encoder_platform_data *\r\nrotary_encoder_parse_dt(struct device *dev)\r\n{\r\nreturn NULL;\r\n}\r\nstatic int rotary_encoder_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nconst struct rotary_encoder_platform_data *pdata = dev_get_platdata(dev);\r\nstruct rotary_encoder *encoder;\r\nstruct input_dev *input;\r\nirq_handler_t handler;\r\nint err;\r\nif (!pdata) {\r\npdata = rotary_encoder_parse_dt(dev);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\nif (!pdata) {\r\ndev_err(dev, "missing platform data\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nencoder = kzalloc(sizeof(struct rotary_encoder), GFP_KERNEL);\r\ninput = input_allocate_device();\r\nif (!encoder || !input) {\r\nerr = -ENOMEM;\r\ngoto exit_free_mem;\r\n}\r\nencoder->input = input;\r\nencoder->pdata = pdata;\r\ninput->name = pdev->name;\r\ninput->id.bustype = BUS_HOST;\r\ninput->dev.parent = dev;\r\nif (pdata->relative_axis) {\r\ninput->evbit[0] = BIT_MASK(EV_REL);\r\ninput->relbit[0] = BIT_MASK(pdata->axis);\r\n} else {\r\ninput->evbit[0] = BIT_MASK(EV_ABS);\r\ninput_set_abs_params(encoder->input,\r\npdata->axis, 0, pdata->steps, 0, 1);\r\n}\r\nerr = gpio_request_one(pdata->gpio_a, GPIOF_IN, dev_name(dev));\r\nif (err) {\r\ndev_err(dev, "unable to request GPIO %d\n", pdata->gpio_a);\r\ngoto exit_free_mem;\r\n}\r\nerr = gpio_request_one(pdata->gpio_b, GPIOF_IN, dev_name(dev));\r\nif (err) {\r\ndev_err(dev, "unable to request GPIO %d\n", pdata->gpio_b);\r\ngoto exit_free_gpio_a;\r\n}\r\nencoder->irq_a = gpio_to_irq(pdata->gpio_a);\r\nencoder->irq_b = gpio_to_irq(pdata->gpio_b);\r\nif (pdata->half_period) {\r\nhandler = &rotary_encoder_half_period_irq;\r\nencoder->last_stable = rotary_encoder_get_state(pdata);\r\n} else {\r\nhandler = &rotary_encoder_irq;\r\n}\r\nerr = request_irq(encoder->irq_a, handler,\r\nIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\r\nDRV_NAME, encoder);\r\nif (err) {\r\ndev_err(dev, "unable to request IRQ %d\n", encoder->irq_a);\r\ngoto exit_free_gpio_b;\r\n}\r\nerr = request_irq(encoder->irq_b, handler,\r\nIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\r\nDRV_NAME, encoder);\r\nif (err) {\r\ndev_err(dev, "unable to request IRQ %d\n", encoder->irq_b);\r\ngoto exit_free_irq_a;\r\n}\r\nerr = input_register_device(input);\r\nif (err) {\r\ndev_err(dev, "failed to register input device\n");\r\ngoto exit_free_irq_b;\r\n}\r\nplatform_set_drvdata(pdev, encoder);\r\nreturn 0;\r\nexit_free_irq_b:\r\nfree_irq(encoder->irq_b, encoder);\r\nexit_free_irq_a:\r\nfree_irq(encoder->irq_a, encoder);\r\nexit_free_gpio_b:\r\ngpio_free(pdata->gpio_b);\r\nexit_free_gpio_a:\r\ngpio_free(pdata->gpio_a);\r\nexit_free_mem:\r\ninput_free_device(input);\r\nkfree(encoder);\r\nif (!dev_get_platdata(&pdev->dev))\r\nkfree(pdata);\r\nreturn err;\r\n}\r\nstatic int rotary_encoder_remove(struct platform_device *pdev)\r\n{\r\nstruct rotary_encoder *encoder = platform_get_drvdata(pdev);\r\nconst struct rotary_encoder_platform_data *pdata = encoder->pdata;\r\nfree_irq(encoder->irq_a, encoder);\r\nfree_irq(encoder->irq_b, encoder);\r\ngpio_free(pdata->gpio_a);\r\ngpio_free(pdata->gpio_b);\r\ninput_unregister_device(encoder->input);\r\nkfree(encoder);\r\nif (!dev_get_platdata(&pdev->dev))\r\nkfree(pdata);\r\nreturn 0;\r\n}
