static int spi_xcomm_sync_config(struct spi_xcomm *spi_xcomm, unsigned int len)\r\n{\r\nuint16_t settings;\r\nuint8_t *buf = spi_xcomm->buf;\r\nsettings = spi_xcomm->settings;\r\nsettings |= len << SPI_XCOMM_SETTINGS_LEN_OFFSET;\r\nbuf[0] = SPI_XCOMM_CMD_UPDATE_CONFIG;\r\nput_unaligned_be16(settings, &buf[1]);\r\nput_unaligned_be16(spi_xcomm->chipselect, &buf[3]);\r\nreturn i2c_master_send(spi_xcomm->i2c, buf, 5);\r\n}\r\nstatic void spi_xcomm_chipselect(struct spi_xcomm *spi_xcomm,\r\nstruct spi_device *spi, int is_active)\r\n{\r\nunsigned long cs = spi->chip_select;\r\nuint16_t chipselect = spi_xcomm->chipselect;\r\nif (is_active)\r\nchipselect |= BIT(cs);\r\nelse\r\nchipselect &= ~BIT(cs);\r\nspi_xcomm->chipselect = chipselect;\r\n}\r\nstatic int spi_xcomm_setup_transfer(struct spi_xcomm *spi_xcomm,\r\nstruct spi_device *spi, struct spi_transfer *t, unsigned int *settings)\r\n{\r\nif (t->len > 62)\r\nreturn -EINVAL;\r\nif (t->speed_hz != spi_xcomm->current_speed) {\r\nunsigned int divider;\r\ndivider = DIV_ROUND_UP(SPI_XCOMM_CLOCK, t->speed_hz);\r\nif (divider >= 64)\r\n*settings |= SPI_XCOMM_SETTINGS_CLOCK_DIV_64;\r\nelse if (divider >= 16)\r\n*settings |= SPI_XCOMM_SETTINGS_CLOCK_DIV_16;\r\nelse\r\n*settings |= SPI_XCOMM_SETTINGS_CLOCK_DIV_4;\r\nspi_xcomm->current_speed = t->speed_hz;\r\n}\r\nif (spi->mode & SPI_CPOL)\r\n*settings |= SPI_XCOMM_SETTINGS_CPOL;\r\nelse\r\n*settings &= ~SPI_XCOMM_SETTINGS_CPOL;\r\nif (spi->mode & SPI_CPHA)\r\n*settings &= ~SPI_XCOMM_SETTINGS_CPHA;\r\nelse\r\n*settings |= SPI_XCOMM_SETTINGS_CPHA;\r\nif (spi->mode & SPI_3WIRE)\r\n*settings |= SPI_XCOMM_SETTINGS_3WIRE;\r\nelse\r\n*settings &= ~SPI_XCOMM_SETTINGS_3WIRE;\r\nreturn 0;\r\n}\r\nstatic int spi_xcomm_txrx_bufs(struct spi_xcomm *spi_xcomm,\r\nstruct spi_device *spi, struct spi_transfer *t)\r\n{\r\nint ret;\r\nif (t->tx_buf) {\r\nspi_xcomm->buf[0] = SPI_XCOMM_CMD_WRITE;\r\nmemcpy(spi_xcomm->buf + 1, t->tx_buf, t->len);\r\nret = i2c_master_send(spi_xcomm->i2c, spi_xcomm->buf, t->len + 1);\r\nif (ret < 0)\r\nreturn ret;\r\nelse if (ret != t->len + 1)\r\nreturn -EIO;\r\n} else if (t->rx_buf) {\r\nret = i2c_master_recv(spi_xcomm->i2c, t->rx_buf, t->len);\r\nif (ret < 0)\r\nreturn ret;\r\nelse if (ret != t->len)\r\nreturn -EIO;\r\n}\r\nreturn t->len;\r\n}\r\nstatic int spi_xcomm_transfer_one(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nstruct spi_xcomm *spi_xcomm = spi_master_get_devdata(master);\r\nunsigned int settings = spi_xcomm->settings;\r\nstruct spi_device *spi = msg->spi;\r\nunsigned cs_change = 0;\r\nstruct spi_transfer *t;\r\nbool is_first = true;\r\nint status = 0;\r\nbool is_last;\r\nspi_xcomm_chipselect(spi_xcomm, spi, true);\r\nlist_for_each_entry(t, &msg->transfers, transfer_list) {\r\nif (!t->tx_buf && !t->rx_buf && t->len) {\r\nstatus = -EINVAL;\r\nbreak;\r\n}\r\nstatus = spi_xcomm_setup_transfer(spi_xcomm, spi, t, &settings);\r\nif (status < 0)\r\nbreak;\r\nis_last = list_is_last(&t->transfer_list, &msg->transfers);\r\ncs_change = t->cs_change;\r\nif (cs_change ^ is_last)\r\nsettings |= BIT(5);\r\nelse\r\nsettings &= ~BIT(5);\r\nif (t->rx_buf) {\r\nspi_xcomm->settings = settings;\r\nstatus = spi_xcomm_sync_config(spi_xcomm, t->len);\r\nif (status < 0)\r\nbreak;\r\n} else if (settings != spi_xcomm->settings || is_first) {\r\nspi_xcomm->settings = settings;\r\nstatus = spi_xcomm_sync_config(spi_xcomm, 0);\r\nif (status < 0)\r\nbreak;\r\n}\r\nif (t->len) {\r\nstatus = spi_xcomm_txrx_bufs(spi_xcomm, spi, t);\r\nif (status < 0)\r\nbreak;\r\nif (status > 0)\r\nmsg->actual_length += status;\r\n}\r\nstatus = 0;\r\nif (t->delay_usecs)\r\nudelay(t->delay_usecs);\r\nis_first = false;\r\n}\r\nif (status != 0 || !cs_change)\r\nspi_xcomm_chipselect(spi_xcomm, spi, false);\r\nmsg->status = status;\r\nspi_finalize_current_message(master);\r\nreturn status;\r\n}\r\nstatic int spi_xcomm_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct spi_xcomm *spi_xcomm;\r\nstruct spi_master *master;\r\nint ret;\r\nmaster = spi_alloc_master(&i2c->dev, sizeof(*spi_xcomm));\r\nif (!master)\r\nreturn -ENOMEM;\r\nspi_xcomm = spi_master_get_devdata(master);\r\nspi_xcomm->i2c = i2c;\r\nmaster->num_chipselect = 16;\r\nmaster->mode_bits = SPI_CPHA | SPI_CPOL | SPI_3WIRE;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(8);\r\nmaster->flags = SPI_MASTER_HALF_DUPLEX;\r\nmaster->transfer_one_message = spi_xcomm_transfer_one;\r\nmaster->dev.of_node = i2c->dev.of_node;\r\ni2c_set_clientdata(i2c, master);\r\nret = devm_spi_register_master(&i2c->dev, master);\r\nif (ret < 0)\r\nspi_master_put(master);\r\nreturn ret;\r\n}
