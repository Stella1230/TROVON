static void vhost_net_enable_zcopy(int vq)\r\n{\r\nvhost_net_zcopy_mask |= 0x1 << vq;\r\n}\r\nstatic struct vhost_net_ubuf_ref *\r\nvhost_net_ubuf_alloc(struct vhost_virtqueue *vq, bool zcopy)\r\n{\r\nstruct vhost_net_ubuf_ref *ubufs;\r\nif (!zcopy)\r\nreturn NULL;\r\nubufs = kmalloc(sizeof(*ubufs), GFP_KERNEL);\r\nif (!ubufs)\r\nreturn ERR_PTR(-ENOMEM);\r\natomic_set(&ubufs->refcount, 1);\r\ninit_waitqueue_head(&ubufs->wait);\r\nubufs->vq = vq;\r\nreturn ubufs;\r\n}\r\nstatic int vhost_net_ubuf_put(struct vhost_net_ubuf_ref *ubufs)\r\n{\r\nint r = atomic_sub_return(1, &ubufs->refcount);\r\nif (unlikely(!r))\r\nwake_up(&ubufs->wait);\r\nreturn r;\r\n}\r\nstatic void vhost_net_ubuf_put_and_wait(struct vhost_net_ubuf_ref *ubufs)\r\n{\r\nvhost_net_ubuf_put(ubufs);\r\nwait_event(ubufs->wait, !atomic_read(&ubufs->refcount));\r\n}\r\nstatic void vhost_net_ubuf_put_wait_and_free(struct vhost_net_ubuf_ref *ubufs)\r\n{\r\nvhost_net_ubuf_put_and_wait(ubufs);\r\nkfree(ubufs);\r\n}\r\nstatic void vhost_net_clear_ubuf_info(struct vhost_net *n)\r\n{\r\nint i;\r\nfor (i = 0; i < VHOST_NET_VQ_MAX; ++i) {\r\nkfree(n->vqs[i].ubuf_info);\r\nn->vqs[i].ubuf_info = NULL;\r\n}\r\n}\r\nstatic int vhost_net_set_ubuf_info(struct vhost_net *n)\r\n{\r\nbool zcopy;\r\nint i;\r\nfor (i = 0; i < VHOST_NET_VQ_MAX; ++i) {\r\nzcopy = vhost_net_zcopy_mask & (0x1 << i);\r\nif (!zcopy)\r\ncontinue;\r\nn->vqs[i].ubuf_info = kmalloc(sizeof(*n->vqs[i].ubuf_info) *\r\nUIO_MAXIOV, GFP_KERNEL);\r\nif (!n->vqs[i].ubuf_info)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nvhost_net_clear_ubuf_info(n);\r\nreturn -ENOMEM;\r\n}\r\nstatic void vhost_net_vq_reset(struct vhost_net *n)\r\n{\r\nint i;\r\nvhost_net_clear_ubuf_info(n);\r\nfor (i = 0; i < VHOST_NET_VQ_MAX; i++) {\r\nn->vqs[i].done_idx = 0;\r\nn->vqs[i].upend_idx = 0;\r\nn->vqs[i].ubufs = NULL;\r\nn->vqs[i].vhost_hlen = 0;\r\nn->vqs[i].sock_hlen = 0;\r\n}\r\n}\r\nstatic void vhost_net_tx_packet(struct vhost_net *net)\r\n{\r\n++net->tx_packets;\r\nif (net->tx_packets < 1024)\r\nreturn;\r\nnet->tx_packets = 0;\r\nnet->tx_zcopy_err = 0;\r\n}\r\nstatic void vhost_net_tx_err(struct vhost_net *net)\r\n{\r\n++net->tx_zcopy_err;\r\n}\r\nstatic bool vhost_net_tx_select_zcopy(struct vhost_net *net)\r\n{\r\nreturn !net->tx_flush &&\r\nnet->tx_packets / 64 >= net->tx_zcopy_err;\r\n}\r\nstatic bool vhost_sock_zcopy(struct socket *sock)\r\n{\r\nreturn unlikely(experimental_zcopytx) &&\r\nsock_flag(sock->sk, SOCK_ZEROCOPY);\r\n}\r\nstatic void vhost_zerocopy_signal_used(struct vhost_net *net,\r\nstruct vhost_virtqueue *vq)\r\n{\r\nstruct vhost_net_virtqueue *nvq =\r\ncontainer_of(vq, struct vhost_net_virtqueue, vq);\r\nint i, add;\r\nint j = 0;\r\nfor (i = nvq->done_idx; i != nvq->upend_idx; i = (i + 1) % UIO_MAXIOV) {\r\nif (vq->heads[i].len == VHOST_DMA_FAILED_LEN)\r\nvhost_net_tx_err(net);\r\nif (VHOST_DMA_IS_DONE(vq->heads[i].len)) {\r\nvq->heads[i].len = VHOST_DMA_CLEAR_LEN;\r\n++j;\r\n} else\r\nbreak;\r\n}\r\nwhile (j) {\r\nadd = min(UIO_MAXIOV - nvq->done_idx, j);\r\nvhost_add_used_and_signal_n(vq->dev, vq,\r\n&vq->heads[nvq->done_idx], add);\r\nnvq->done_idx = (nvq->done_idx + add) % UIO_MAXIOV;\r\nj -= add;\r\n}\r\n}\r\nstatic void vhost_zerocopy_callback(struct ubuf_info *ubuf, bool success)\r\n{\r\nstruct vhost_net_ubuf_ref *ubufs = ubuf->ctx;\r\nstruct vhost_virtqueue *vq = ubufs->vq;\r\nint cnt;\r\nrcu_read_lock_bh();\r\nvq->heads[ubuf->desc].len = success ?\r\nVHOST_DMA_DONE_LEN : VHOST_DMA_FAILED_LEN;\r\ncnt = vhost_net_ubuf_put(ubufs);\r\nif (cnt <= 1 || !(cnt % 16))\r\nvhost_poll_queue(&vq->poll);\r\nrcu_read_unlock_bh();\r\n}\r\nstatic void handle_tx(struct vhost_net *net)\r\n{\r\nstruct vhost_net_virtqueue *nvq = &net->vqs[VHOST_NET_VQ_TX];\r\nstruct vhost_virtqueue *vq = &nvq->vq;\r\nunsigned out, in;\r\nint head;\r\nstruct msghdr msg = {\r\n.msg_name = NULL,\r\n.msg_namelen = 0,\r\n.msg_control = NULL,\r\n.msg_controllen = 0,\r\n.msg_flags = MSG_DONTWAIT,\r\n};\r\nsize_t len, total_len = 0;\r\nint err;\r\nsize_t hdr_size;\r\nstruct socket *sock;\r\nstruct vhost_net_ubuf_ref *uninitialized_var(ubufs);\r\nbool zcopy, zcopy_used;\r\nmutex_lock(&vq->mutex);\r\nsock = vq->private_data;\r\nif (!sock)\r\ngoto out;\r\nvhost_disable_notify(&net->dev, vq);\r\nhdr_size = nvq->vhost_hlen;\r\nzcopy = nvq->ubufs;\r\nfor (;;) {\r\nif (zcopy)\r\nvhost_zerocopy_signal_used(net, vq);\r\nif (unlikely((nvq->upend_idx + vq->num - VHOST_MAX_PEND)\r\n% UIO_MAXIOV == nvq->done_idx))\r\nbreak;\r\nhead = vhost_get_vq_desc(vq, vq->iov,\r\nARRAY_SIZE(vq->iov),\r\n&out, &in,\r\nNULL, NULL);\r\nif (unlikely(head < 0))\r\nbreak;\r\nif (head == vq->num) {\r\nif (unlikely(vhost_enable_notify(&net->dev, vq))) {\r\nvhost_disable_notify(&net->dev, vq);\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nif (in) {\r\nvq_err(vq, "Unexpected descriptor format for TX: "\r\n"out %d, int %d\n", out, in);\r\nbreak;\r\n}\r\nlen = iov_length(vq->iov, out);\r\niov_iter_init(&msg.msg_iter, WRITE, vq->iov, out, len);\r\niov_iter_advance(&msg.msg_iter, hdr_size);\r\nif (!msg_data_left(&msg)) {\r\nvq_err(vq, "Unexpected header len for TX: "\r\n"%zd expected %zd\n",\r\nlen, hdr_size);\r\nbreak;\r\n}\r\nlen = msg_data_left(&msg);\r\nzcopy_used = zcopy && len >= VHOST_GOODCOPY_LEN\r\n&& (nvq->upend_idx + 1) % UIO_MAXIOV !=\r\nnvq->done_idx\r\n&& vhost_net_tx_select_zcopy(net);\r\nif (zcopy_used) {\r\nstruct ubuf_info *ubuf;\r\nubuf = nvq->ubuf_info + nvq->upend_idx;\r\nvq->heads[nvq->upend_idx].id = cpu_to_vhost32(vq, head);\r\nvq->heads[nvq->upend_idx].len = VHOST_DMA_IN_PROGRESS;\r\nubuf->callback = vhost_zerocopy_callback;\r\nubuf->ctx = nvq->ubufs;\r\nubuf->desc = nvq->upend_idx;\r\nmsg.msg_control = ubuf;\r\nmsg.msg_controllen = sizeof(ubuf);\r\nubufs = nvq->ubufs;\r\natomic_inc(&ubufs->refcount);\r\nnvq->upend_idx = (nvq->upend_idx + 1) % UIO_MAXIOV;\r\n} else {\r\nmsg.msg_control = NULL;\r\nubufs = NULL;\r\n}\r\nerr = sock->ops->sendmsg(sock, &msg, len);\r\nif (unlikely(err < 0)) {\r\nif (zcopy_used) {\r\nvhost_net_ubuf_put(ubufs);\r\nnvq->upend_idx = ((unsigned)nvq->upend_idx - 1)\r\n% UIO_MAXIOV;\r\n}\r\nvhost_discard_vq_desc(vq, 1);\r\nbreak;\r\n}\r\nif (err != len)\r\npr_debug("Truncated TX packet: "\r\n" len %d != %zd\n", err, len);\r\nif (!zcopy_used)\r\nvhost_add_used_and_signal(&net->dev, vq, head, 0);\r\nelse\r\nvhost_zerocopy_signal_used(net, vq);\r\ntotal_len += len;\r\nvhost_net_tx_packet(net);\r\nif (unlikely(total_len >= VHOST_NET_WEIGHT)) {\r\nvhost_poll_queue(&vq->poll);\r\nbreak;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&vq->mutex);\r\n}\r\nstatic int peek_head_len(struct sock *sk)\r\n{\r\nstruct sk_buff *head;\r\nint len = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sk->sk_receive_queue.lock, flags);\r\nhead = skb_peek(&sk->sk_receive_queue);\r\nif (likely(head)) {\r\nlen = head->len;\r\nif (skb_vlan_tag_present(head))\r\nlen += VLAN_HLEN;\r\n}\r\nspin_unlock_irqrestore(&sk->sk_receive_queue.lock, flags);\r\nreturn len;\r\n}\r\nstatic int get_rx_bufs(struct vhost_virtqueue *vq,\r\nstruct vring_used_elem *heads,\r\nint datalen,\r\nunsigned *iovcount,\r\nstruct vhost_log *log,\r\nunsigned *log_num,\r\nunsigned int quota)\r\n{\r\nunsigned int out, in;\r\nint seg = 0;\r\nint headcount = 0;\r\nunsigned d;\r\nint r, nlogs = 0;\r\nu32 uninitialized_var(len);\r\nwhile (datalen > 0 && headcount < quota) {\r\nif (unlikely(seg >= UIO_MAXIOV)) {\r\nr = -ENOBUFS;\r\ngoto err;\r\n}\r\nr = vhost_get_vq_desc(vq, vq->iov + seg,\r\nARRAY_SIZE(vq->iov) - seg, &out,\r\n&in, log, log_num);\r\nif (unlikely(r < 0))\r\ngoto err;\r\nd = r;\r\nif (d == vq->num) {\r\nr = 0;\r\ngoto err;\r\n}\r\nif (unlikely(out || in <= 0)) {\r\nvq_err(vq, "unexpected descriptor format for RX: "\r\n"out %d, in %d\n", out, in);\r\nr = -EINVAL;\r\ngoto err;\r\n}\r\nif (unlikely(log)) {\r\nnlogs += *log_num;\r\nlog += *log_num;\r\n}\r\nheads[headcount].id = cpu_to_vhost32(vq, d);\r\nlen = iov_length(vq->iov + seg, in);\r\nheads[headcount].len = cpu_to_vhost32(vq, len);\r\ndatalen -= len;\r\n++headcount;\r\nseg += in;\r\n}\r\nheads[headcount - 1].len = cpu_to_vhost32(vq, len + datalen);\r\n*iovcount = seg;\r\nif (unlikely(log))\r\n*log_num = nlogs;\r\nif (unlikely(datalen > 0)) {\r\nr = UIO_MAXIOV + 1;\r\ngoto err;\r\n}\r\nreturn headcount;\r\nerr:\r\nvhost_discard_vq_desc(vq, headcount);\r\nreturn r;\r\n}\r\nstatic void handle_rx(struct vhost_net *net)\r\n{\r\nstruct vhost_net_virtqueue *nvq = &net->vqs[VHOST_NET_VQ_RX];\r\nstruct vhost_virtqueue *vq = &nvq->vq;\r\nunsigned uninitialized_var(in), log;\r\nstruct vhost_log *vq_log;\r\nstruct msghdr msg = {\r\n.msg_name = NULL,\r\n.msg_namelen = 0,\r\n.msg_control = NULL,\r\n.msg_controllen = 0,\r\n.msg_flags = MSG_DONTWAIT,\r\n};\r\nstruct virtio_net_hdr hdr = {\r\n.flags = 0,\r\n.gso_type = VIRTIO_NET_HDR_GSO_NONE\r\n};\r\nsize_t total_len = 0;\r\nint err, mergeable;\r\ns16 headcount;\r\nsize_t vhost_hlen, sock_hlen;\r\nsize_t vhost_len, sock_len;\r\nstruct socket *sock;\r\nstruct iov_iter fixup;\r\n__virtio16 num_buffers;\r\nmutex_lock(&vq->mutex);\r\nsock = vq->private_data;\r\nif (!sock)\r\ngoto out;\r\nvhost_disable_notify(&net->dev, vq);\r\nvhost_hlen = nvq->vhost_hlen;\r\nsock_hlen = nvq->sock_hlen;\r\nvq_log = unlikely(vhost_has_feature(vq, VHOST_F_LOG_ALL)) ?\r\nvq->log : NULL;\r\nmergeable = vhost_has_feature(vq, VIRTIO_NET_F_MRG_RXBUF);\r\nwhile ((sock_len = peek_head_len(sock->sk))) {\r\nsock_len += sock_hlen;\r\nvhost_len = sock_len + vhost_hlen;\r\nheadcount = get_rx_bufs(vq, vq->heads, vhost_len,\r\n&in, vq_log, &log,\r\nlikely(mergeable) ? UIO_MAXIOV : 1);\r\nif (unlikely(headcount < 0))\r\nbreak;\r\nif (unlikely(headcount > UIO_MAXIOV)) {\r\niov_iter_init(&msg.msg_iter, READ, vq->iov, 1, 1);\r\nerr = sock->ops->recvmsg(sock, &msg,\r\n1, MSG_DONTWAIT | MSG_TRUNC);\r\npr_debug("Discarded rx packet: len %zd\n", sock_len);\r\ncontinue;\r\n}\r\nif (!headcount) {\r\nif (unlikely(vhost_enable_notify(&net->dev, vq))) {\r\nvhost_disable_notify(&net->dev, vq);\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\niov_iter_init(&msg.msg_iter, READ, vq->iov, in, vhost_len);\r\nfixup = msg.msg_iter;\r\nif (unlikely((vhost_hlen))) {\r\niov_iter_advance(&msg.msg_iter, vhost_hlen);\r\n}\r\nerr = sock->ops->recvmsg(sock, &msg,\r\nsock_len, MSG_DONTWAIT | MSG_TRUNC);\r\nif (unlikely(err != sock_len)) {\r\npr_debug("Discarded rx packet: "\r\n" len %d, expected %zd\n", err, sock_len);\r\nvhost_discard_vq_desc(vq, headcount);\r\ncontinue;\r\n}\r\nif (unlikely(vhost_hlen)) {\r\nif (copy_to_iter(&hdr, sizeof(hdr),\r\n&fixup) != sizeof(hdr)) {\r\nvq_err(vq, "Unable to write vnet_hdr "\r\n"at addr %p\n", vq->iov->iov_base);\r\nbreak;\r\n}\r\n} else {\r\niov_iter_advance(&fixup, sizeof(hdr));\r\n}\r\nnum_buffers = cpu_to_vhost16(vq, headcount);\r\nif (likely(mergeable) &&\r\ncopy_to_iter(&num_buffers, sizeof num_buffers,\r\n&fixup) != sizeof num_buffers) {\r\nvq_err(vq, "Failed num_buffers write");\r\nvhost_discard_vq_desc(vq, headcount);\r\nbreak;\r\n}\r\nvhost_add_used_and_signal_n(&net->dev, vq, vq->heads,\r\nheadcount);\r\nif (unlikely(vq_log))\r\nvhost_log_write(vq, vq_log, log, vhost_len);\r\ntotal_len += vhost_len;\r\nif (unlikely(total_len >= VHOST_NET_WEIGHT)) {\r\nvhost_poll_queue(&vq->poll);\r\nbreak;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&vq->mutex);\r\n}\r\nstatic void handle_tx_kick(struct vhost_work *work)\r\n{\r\nstruct vhost_virtqueue *vq = container_of(work, struct vhost_virtqueue,\r\npoll.work);\r\nstruct vhost_net *net = container_of(vq->dev, struct vhost_net, dev);\r\nhandle_tx(net);\r\n}\r\nstatic void handle_rx_kick(struct vhost_work *work)\r\n{\r\nstruct vhost_virtqueue *vq = container_of(work, struct vhost_virtqueue,\r\npoll.work);\r\nstruct vhost_net *net = container_of(vq->dev, struct vhost_net, dev);\r\nhandle_rx(net);\r\n}\r\nstatic void handle_tx_net(struct vhost_work *work)\r\n{\r\nstruct vhost_net *net = container_of(work, struct vhost_net,\r\npoll[VHOST_NET_VQ_TX].work);\r\nhandle_tx(net);\r\n}\r\nstatic void handle_rx_net(struct vhost_work *work)\r\n{\r\nstruct vhost_net *net = container_of(work, struct vhost_net,\r\npoll[VHOST_NET_VQ_RX].work);\r\nhandle_rx(net);\r\n}\r\nstatic int vhost_net_open(struct inode *inode, struct file *f)\r\n{\r\nstruct vhost_net *n;\r\nstruct vhost_dev *dev;\r\nstruct vhost_virtqueue **vqs;\r\nint i;\r\nn = kmalloc(sizeof *n, GFP_KERNEL | __GFP_NOWARN | __GFP_REPEAT);\r\nif (!n) {\r\nn = vmalloc(sizeof *n);\r\nif (!n)\r\nreturn -ENOMEM;\r\n}\r\nvqs = kmalloc(VHOST_NET_VQ_MAX * sizeof(*vqs), GFP_KERNEL);\r\nif (!vqs) {\r\nkvfree(n);\r\nreturn -ENOMEM;\r\n}\r\ndev = &n->dev;\r\nvqs[VHOST_NET_VQ_TX] = &n->vqs[VHOST_NET_VQ_TX].vq;\r\nvqs[VHOST_NET_VQ_RX] = &n->vqs[VHOST_NET_VQ_RX].vq;\r\nn->vqs[VHOST_NET_VQ_TX].vq.handle_kick = handle_tx_kick;\r\nn->vqs[VHOST_NET_VQ_RX].vq.handle_kick = handle_rx_kick;\r\nfor (i = 0; i < VHOST_NET_VQ_MAX; i++) {\r\nn->vqs[i].ubufs = NULL;\r\nn->vqs[i].ubuf_info = NULL;\r\nn->vqs[i].upend_idx = 0;\r\nn->vqs[i].done_idx = 0;\r\nn->vqs[i].vhost_hlen = 0;\r\nn->vqs[i].sock_hlen = 0;\r\n}\r\nvhost_dev_init(dev, vqs, VHOST_NET_VQ_MAX);\r\nvhost_poll_init(n->poll + VHOST_NET_VQ_TX, handle_tx_net, POLLOUT, dev);\r\nvhost_poll_init(n->poll + VHOST_NET_VQ_RX, handle_rx_net, POLLIN, dev);\r\nf->private_data = n;\r\nreturn 0;\r\n}\r\nstatic void vhost_net_disable_vq(struct vhost_net *n,\r\nstruct vhost_virtqueue *vq)\r\n{\r\nstruct vhost_net_virtqueue *nvq =\r\ncontainer_of(vq, struct vhost_net_virtqueue, vq);\r\nstruct vhost_poll *poll = n->poll + (nvq - n->vqs);\r\nif (!vq->private_data)\r\nreturn;\r\nvhost_poll_stop(poll);\r\n}\r\nstatic int vhost_net_enable_vq(struct vhost_net *n,\r\nstruct vhost_virtqueue *vq)\r\n{\r\nstruct vhost_net_virtqueue *nvq =\r\ncontainer_of(vq, struct vhost_net_virtqueue, vq);\r\nstruct vhost_poll *poll = n->poll + (nvq - n->vqs);\r\nstruct socket *sock;\r\nsock = vq->private_data;\r\nif (!sock)\r\nreturn 0;\r\nreturn vhost_poll_start(poll, sock->file);\r\n}\r\nstatic struct socket *vhost_net_stop_vq(struct vhost_net *n,\r\nstruct vhost_virtqueue *vq)\r\n{\r\nstruct socket *sock;\r\nmutex_lock(&vq->mutex);\r\nsock = vq->private_data;\r\nvhost_net_disable_vq(n, vq);\r\nvq->private_data = NULL;\r\nmutex_unlock(&vq->mutex);\r\nreturn sock;\r\n}\r\nstatic void vhost_net_stop(struct vhost_net *n, struct socket **tx_sock,\r\nstruct socket **rx_sock)\r\n{\r\n*tx_sock = vhost_net_stop_vq(n, &n->vqs[VHOST_NET_VQ_TX].vq);\r\n*rx_sock = vhost_net_stop_vq(n, &n->vqs[VHOST_NET_VQ_RX].vq);\r\n}\r\nstatic void vhost_net_flush_vq(struct vhost_net *n, int index)\r\n{\r\nvhost_poll_flush(n->poll + index);\r\nvhost_poll_flush(&n->vqs[index].vq.poll);\r\n}\r\nstatic void vhost_net_flush(struct vhost_net *n)\r\n{\r\nvhost_net_flush_vq(n, VHOST_NET_VQ_TX);\r\nvhost_net_flush_vq(n, VHOST_NET_VQ_RX);\r\nif (n->vqs[VHOST_NET_VQ_TX].ubufs) {\r\nmutex_lock(&n->vqs[VHOST_NET_VQ_TX].vq.mutex);\r\nn->tx_flush = true;\r\nmutex_unlock(&n->vqs[VHOST_NET_VQ_TX].vq.mutex);\r\nvhost_net_ubuf_put_and_wait(n->vqs[VHOST_NET_VQ_TX].ubufs);\r\nmutex_lock(&n->vqs[VHOST_NET_VQ_TX].vq.mutex);\r\nn->tx_flush = false;\r\natomic_set(&n->vqs[VHOST_NET_VQ_TX].ubufs->refcount, 1);\r\nmutex_unlock(&n->vqs[VHOST_NET_VQ_TX].vq.mutex);\r\n}\r\n}\r\nstatic int vhost_net_release(struct inode *inode, struct file *f)\r\n{\r\nstruct vhost_net *n = f->private_data;\r\nstruct socket *tx_sock;\r\nstruct socket *rx_sock;\r\nvhost_net_stop(n, &tx_sock, &rx_sock);\r\nvhost_net_flush(n);\r\nvhost_dev_stop(&n->dev);\r\nvhost_dev_cleanup(&n->dev, false);\r\nvhost_net_vq_reset(n);\r\nif (tx_sock)\r\nsockfd_put(tx_sock);\r\nif (rx_sock)\r\nsockfd_put(rx_sock);\r\nsynchronize_rcu_bh();\r\nvhost_net_flush(n);\r\nkfree(n->dev.vqs);\r\nkvfree(n);\r\nreturn 0;\r\n}\r\nstatic struct socket *get_raw_socket(int fd)\r\n{\r\nstruct {\r\nstruct sockaddr_ll sa;\r\nchar buf[MAX_ADDR_LEN];\r\n} uaddr;\r\nint uaddr_len = sizeof uaddr, r;\r\nstruct socket *sock = sockfd_lookup(fd, &r);\r\nif (!sock)\r\nreturn ERR_PTR(-ENOTSOCK);\r\nif (sock->sk->sk_type != SOCK_RAW) {\r\nr = -ESOCKTNOSUPPORT;\r\ngoto err;\r\n}\r\nr = sock->ops->getname(sock, (struct sockaddr *)&uaddr.sa,\r\n&uaddr_len, 0);\r\nif (r)\r\ngoto err;\r\nif (uaddr.sa.sll_family != AF_PACKET) {\r\nr = -EPFNOSUPPORT;\r\ngoto err;\r\n}\r\nreturn sock;\r\nerr:\r\nsockfd_put(sock);\r\nreturn ERR_PTR(r);\r\n}\r\nstatic struct socket *get_tap_socket(int fd)\r\n{\r\nstruct file *file = fget(fd);\r\nstruct socket *sock;\r\nif (!file)\r\nreturn ERR_PTR(-EBADF);\r\nsock = tun_get_socket(file);\r\nif (!IS_ERR(sock))\r\nreturn sock;\r\nsock = macvtap_get_socket(file);\r\nif (IS_ERR(sock))\r\nfput(file);\r\nreturn sock;\r\n}\r\nstatic struct socket *get_socket(int fd)\r\n{\r\nstruct socket *sock;\r\nif (fd == -1)\r\nreturn NULL;\r\nsock = get_raw_socket(fd);\r\nif (!IS_ERR(sock))\r\nreturn sock;\r\nsock = get_tap_socket(fd);\r\nif (!IS_ERR(sock))\r\nreturn sock;\r\nreturn ERR_PTR(-ENOTSOCK);\r\n}\r\nstatic long vhost_net_set_backend(struct vhost_net *n, unsigned index, int fd)\r\n{\r\nstruct socket *sock, *oldsock;\r\nstruct vhost_virtqueue *vq;\r\nstruct vhost_net_virtqueue *nvq;\r\nstruct vhost_net_ubuf_ref *ubufs, *oldubufs = NULL;\r\nint r;\r\nmutex_lock(&n->dev.mutex);\r\nr = vhost_dev_check_owner(&n->dev);\r\nif (r)\r\ngoto err;\r\nif (index >= VHOST_NET_VQ_MAX) {\r\nr = -ENOBUFS;\r\ngoto err;\r\n}\r\nvq = &n->vqs[index].vq;\r\nnvq = &n->vqs[index];\r\nmutex_lock(&vq->mutex);\r\nif (!vhost_vq_access_ok(vq)) {\r\nr = -EFAULT;\r\ngoto err_vq;\r\n}\r\nsock = get_socket(fd);\r\nif (IS_ERR(sock)) {\r\nr = PTR_ERR(sock);\r\ngoto err_vq;\r\n}\r\noldsock = vq->private_data;\r\nif (sock != oldsock) {\r\nubufs = vhost_net_ubuf_alloc(vq,\r\nsock && vhost_sock_zcopy(sock));\r\nif (IS_ERR(ubufs)) {\r\nr = PTR_ERR(ubufs);\r\ngoto err_ubufs;\r\n}\r\nvhost_net_disable_vq(n, vq);\r\nvq->private_data = sock;\r\nr = vhost_init_used(vq);\r\nif (r)\r\ngoto err_used;\r\nr = vhost_net_enable_vq(n, vq);\r\nif (r)\r\ngoto err_used;\r\noldubufs = nvq->ubufs;\r\nnvq->ubufs = ubufs;\r\nn->tx_packets = 0;\r\nn->tx_zcopy_err = 0;\r\nn->tx_flush = false;\r\n}\r\nmutex_unlock(&vq->mutex);\r\nif (oldubufs) {\r\nvhost_net_ubuf_put_wait_and_free(oldubufs);\r\nmutex_lock(&vq->mutex);\r\nvhost_zerocopy_signal_used(n, vq);\r\nmutex_unlock(&vq->mutex);\r\n}\r\nif (oldsock) {\r\nvhost_net_flush_vq(n, index);\r\nsockfd_put(oldsock);\r\n}\r\nmutex_unlock(&n->dev.mutex);\r\nreturn 0;\r\nerr_used:\r\nvq->private_data = oldsock;\r\nvhost_net_enable_vq(n, vq);\r\nif (ubufs)\r\nvhost_net_ubuf_put_wait_and_free(ubufs);\r\nerr_ubufs:\r\nsockfd_put(sock);\r\nerr_vq:\r\nmutex_unlock(&vq->mutex);\r\nerr:\r\nmutex_unlock(&n->dev.mutex);\r\nreturn r;\r\n}\r\nstatic long vhost_net_reset_owner(struct vhost_net *n)\r\n{\r\nstruct socket *tx_sock = NULL;\r\nstruct socket *rx_sock = NULL;\r\nlong err;\r\nstruct vhost_memory *memory;\r\nmutex_lock(&n->dev.mutex);\r\nerr = vhost_dev_check_owner(&n->dev);\r\nif (err)\r\ngoto done;\r\nmemory = vhost_dev_reset_owner_prepare();\r\nif (!memory) {\r\nerr = -ENOMEM;\r\ngoto done;\r\n}\r\nvhost_net_stop(n, &tx_sock, &rx_sock);\r\nvhost_net_flush(n);\r\nvhost_dev_reset_owner(&n->dev, memory);\r\nvhost_net_vq_reset(n);\r\ndone:\r\nmutex_unlock(&n->dev.mutex);\r\nif (tx_sock)\r\nsockfd_put(tx_sock);\r\nif (rx_sock)\r\nsockfd_put(rx_sock);\r\nreturn err;\r\n}\r\nstatic int vhost_net_set_features(struct vhost_net *n, u64 features)\r\n{\r\nsize_t vhost_hlen, sock_hlen, hdr_len;\r\nint i;\r\nhdr_len = (features & ((1ULL << VIRTIO_NET_F_MRG_RXBUF) |\r\n(1ULL << VIRTIO_F_VERSION_1))) ?\r\nsizeof(struct virtio_net_hdr_mrg_rxbuf) :\r\nsizeof(struct virtio_net_hdr);\r\nif (features & (1 << VHOST_NET_F_VIRTIO_NET_HDR)) {\r\nvhost_hlen = hdr_len;\r\nsock_hlen = 0;\r\n} else {\r\nvhost_hlen = 0;\r\nsock_hlen = hdr_len;\r\n}\r\nmutex_lock(&n->dev.mutex);\r\nif ((features & (1 << VHOST_F_LOG_ALL)) &&\r\n!vhost_log_access_ok(&n->dev)) {\r\nmutex_unlock(&n->dev.mutex);\r\nreturn -EFAULT;\r\n}\r\nfor (i = 0; i < VHOST_NET_VQ_MAX; ++i) {\r\nmutex_lock(&n->vqs[i].vq.mutex);\r\nn->vqs[i].vq.acked_features = features;\r\nn->vqs[i].vhost_hlen = vhost_hlen;\r\nn->vqs[i].sock_hlen = sock_hlen;\r\nmutex_unlock(&n->vqs[i].vq.mutex);\r\n}\r\nmutex_unlock(&n->dev.mutex);\r\nreturn 0;\r\n}\r\nstatic long vhost_net_set_owner(struct vhost_net *n)\r\n{\r\nint r;\r\nmutex_lock(&n->dev.mutex);\r\nif (vhost_dev_has_owner(&n->dev)) {\r\nr = -EBUSY;\r\ngoto out;\r\n}\r\nr = vhost_net_set_ubuf_info(n);\r\nif (r)\r\ngoto out;\r\nr = vhost_dev_set_owner(&n->dev);\r\nif (r)\r\nvhost_net_clear_ubuf_info(n);\r\nvhost_net_flush(n);\r\nout:\r\nmutex_unlock(&n->dev.mutex);\r\nreturn r;\r\n}\r\nstatic long vhost_net_ioctl(struct file *f, unsigned int ioctl,\r\nunsigned long arg)\r\n{\r\nstruct vhost_net *n = f->private_data;\r\nvoid __user *argp = (void __user *)arg;\r\nu64 __user *featurep = argp;\r\nstruct vhost_vring_file backend;\r\nu64 features;\r\nint r;\r\nswitch (ioctl) {\r\ncase VHOST_NET_SET_BACKEND:\r\nif (copy_from_user(&backend, argp, sizeof backend))\r\nreturn -EFAULT;\r\nreturn vhost_net_set_backend(n, backend.index, backend.fd);\r\ncase VHOST_GET_FEATURES:\r\nfeatures = VHOST_NET_FEATURES;\r\nif (copy_to_user(featurep, &features, sizeof features))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase VHOST_SET_FEATURES:\r\nif (copy_from_user(&features, featurep, sizeof features))\r\nreturn -EFAULT;\r\nif (features & ~VHOST_NET_FEATURES)\r\nreturn -EOPNOTSUPP;\r\nreturn vhost_net_set_features(n, features);\r\ncase VHOST_RESET_OWNER:\r\nreturn vhost_net_reset_owner(n);\r\ncase VHOST_SET_OWNER:\r\nreturn vhost_net_set_owner(n);\r\ndefault:\r\nmutex_lock(&n->dev.mutex);\r\nr = vhost_dev_ioctl(&n->dev, ioctl, argp);\r\nif (r == -ENOIOCTLCMD)\r\nr = vhost_vring_ioctl(&n->dev, ioctl, argp);\r\nelse\r\nvhost_net_flush(n);\r\nmutex_unlock(&n->dev.mutex);\r\nreturn r;\r\n}\r\n}\r\nstatic long vhost_net_compat_ioctl(struct file *f, unsigned int ioctl,\r\nunsigned long arg)\r\n{\r\nreturn vhost_net_ioctl(f, ioctl, (unsigned long)compat_ptr(arg));\r\n}\r\nstatic int vhost_net_init(void)\r\n{\r\nif (experimental_zcopytx)\r\nvhost_net_enable_zcopy(VHOST_NET_VQ_TX);\r\nreturn misc_register(&vhost_net_misc);\r\n}\r\nstatic void vhost_net_exit(void)\r\n{\r\nmisc_deregister(&vhost_net_misc);\r\n}
