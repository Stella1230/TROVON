static inline bool is_susp(union drbd_state s)\r\n{\r\nreturn s.susp || s.susp_nod || s.susp_fen;\r\n}\r\nbool conn_all_vols_unconf(struct drbd_connection *connection)\r\n{\r\nstruct drbd_peer_device *peer_device;\r\nbool rv = true;\r\nint vnr;\r\nrcu_read_lock();\r\nidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\r\nstruct drbd_device *device = peer_device->device;\r\nif (device->state.disk != D_DISKLESS ||\r\ndevice->state.conn != C_STANDALONE ||\r\ndevice->state.role != R_SECONDARY) {\r\nrv = false;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn rv;\r\n}\r\nstatic enum drbd_role max_role(enum drbd_role role1, enum drbd_role role2)\r\n{\r\nif (role1 == R_PRIMARY || role2 == R_PRIMARY)\r\nreturn R_PRIMARY;\r\nif (role1 == R_SECONDARY || role2 == R_SECONDARY)\r\nreturn R_SECONDARY;\r\nreturn R_UNKNOWN;\r\n}\r\nstatic enum drbd_role min_role(enum drbd_role role1, enum drbd_role role2)\r\n{\r\nif (role1 == R_UNKNOWN || role2 == R_UNKNOWN)\r\nreturn R_UNKNOWN;\r\nif (role1 == R_SECONDARY || role2 == R_SECONDARY)\r\nreturn R_SECONDARY;\r\nreturn R_PRIMARY;\r\n}\r\nenum drbd_role conn_highest_role(struct drbd_connection *connection)\r\n{\r\nenum drbd_role role = R_UNKNOWN;\r\nstruct drbd_peer_device *peer_device;\r\nint vnr;\r\nrcu_read_lock();\r\nidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\r\nstruct drbd_device *device = peer_device->device;\r\nrole = max_role(role, device->state.role);\r\n}\r\nrcu_read_unlock();\r\nreturn role;\r\n}\r\nenum drbd_role conn_highest_peer(struct drbd_connection *connection)\r\n{\r\nenum drbd_role peer = R_UNKNOWN;\r\nstruct drbd_peer_device *peer_device;\r\nint vnr;\r\nrcu_read_lock();\r\nidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\r\nstruct drbd_device *device = peer_device->device;\r\npeer = max_role(peer, device->state.peer);\r\n}\r\nrcu_read_unlock();\r\nreturn peer;\r\n}\r\nenum drbd_disk_state conn_highest_disk(struct drbd_connection *connection)\r\n{\r\nenum drbd_disk_state disk_state = D_DISKLESS;\r\nstruct drbd_peer_device *peer_device;\r\nint vnr;\r\nrcu_read_lock();\r\nidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\r\nstruct drbd_device *device = peer_device->device;\r\ndisk_state = max_t(enum drbd_disk_state, disk_state, device->state.disk);\r\n}\r\nrcu_read_unlock();\r\nreturn disk_state;\r\n}\r\nenum drbd_disk_state conn_lowest_disk(struct drbd_connection *connection)\r\n{\r\nenum drbd_disk_state disk_state = D_MASK;\r\nstruct drbd_peer_device *peer_device;\r\nint vnr;\r\nrcu_read_lock();\r\nidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\r\nstruct drbd_device *device = peer_device->device;\r\ndisk_state = min_t(enum drbd_disk_state, disk_state, device->state.disk);\r\n}\r\nrcu_read_unlock();\r\nreturn disk_state;\r\n}\r\nenum drbd_disk_state conn_highest_pdsk(struct drbd_connection *connection)\r\n{\r\nenum drbd_disk_state disk_state = D_DISKLESS;\r\nstruct drbd_peer_device *peer_device;\r\nint vnr;\r\nrcu_read_lock();\r\nidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\r\nstruct drbd_device *device = peer_device->device;\r\ndisk_state = max_t(enum drbd_disk_state, disk_state, device->state.pdsk);\r\n}\r\nrcu_read_unlock();\r\nreturn disk_state;\r\n}\r\nenum drbd_conns conn_lowest_conn(struct drbd_connection *connection)\r\n{\r\nenum drbd_conns conn = C_MASK;\r\nstruct drbd_peer_device *peer_device;\r\nint vnr;\r\nrcu_read_lock();\r\nidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\r\nstruct drbd_device *device = peer_device->device;\r\nconn = min_t(enum drbd_conns, conn, device->state.conn);\r\n}\r\nrcu_read_unlock();\r\nreturn conn;\r\n}\r\nstatic bool no_peer_wf_report_params(struct drbd_connection *connection)\r\n{\r\nstruct drbd_peer_device *peer_device;\r\nint vnr;\r\nbool rv = true;\r\nrcu_read_lock();\r\nidr_for_each_entry(&connection->peer_devices, peer_device, vnr)\r\nif (peer_device->device->state.conn == C_WF_REPORT_PARAMS) {\r\nrv = false;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn rv;\r\n}\r\nstatic void wake_up_all_devices(struct drbd_connection *connection)\r\n{\r\nstruct drbd_peer_device *peer_device;\r\nint vnr;\r\nrcu_read_lock();\r\nidr_for_each_entry(&connection->peer_devices, peer_device, vnr)\r\nwake_up(&peer_device->device->state_wait);\r\nrcu_read_unlock();\r\n}\r\nstatic int cl_wide_st_chg(struct drbd_device *device,\r\nunion drbd_state os, union drbd_state ns)\r\n{\r\nreturn (os.conn >= C_CONNECTED && ns.conn >= C_CONNECTED &&\r\n((os.role != R_PRIMARY && ns.role == R_PRIMARY) ||\r\n(os.conn != C_STARTING_SYNC_T && ns.conn == C_STARTING_SYNC_T) ||\r\n(os.conn != C_STARTING_SYNC_S && ns.conn == C_STARTING_SYNC_S) ||\r\n(os.disk != D_FAILED && ns.disk == D_FAILED))) ||\r\n(os.conn >= C_CONNECTED && ns.conn == C_DISCONNECTING) ||\r\n(os.conn == C_CONNECTED && ns.conn == C_VERIFY_S) ||\r\n(os.conn == C_CONNECTED && ns.conn == C_WF_REPORT_PARAMS);\r\n}\r\nstatic union drbd_state\r\napply_mask_val(union drbd_state os, union drbd_state mask, union drbd_state val)\r\n{\r\nunion drbd_state ns;\r\nns.i = (os.i & ~mask.i) | val.i;\r\nreturn ns;\r\n}\r\nenum drbd_state_rv\r\ndrbd_change_state(struct drbd_device *device, enum chg_state_flags f,\r\nunion drbd_state mask, union drbd_state val)\r\n{\r\nunsigned long flags;\r\nunion drbd_state ns;\r\nenum drbd_state_rv rv;\r\nspin_lock_irqsave(&device->resource->req_lock, flags);\r\nns = apply_mask_val(drbd_read_state(device), mask, val);\r\nrv = _drbd_set_state(device, ns, f, NULL);\r\nspin_unlock_irqrestore(&device->resource->req_lock, flags);\r\nreturn rv;\r\n}\r\nvoid drbd_force_state(struct drbd_device *device,\r\nunion drbd_state mask, union drbd_state val)\r\n{\r\ndrbd_change_state(device, CS_HARD, mask, val);\r\n}\r\nstatic enum drbd_state_rv\r\n_req_st_cond(struct drbd_device *device, union drbd_state mask,\r\nunion drbd_state val)\r\n{\r\nunion drbd_state os, ns;\r\nunsigned long flags;\r\nenum drbd_state_rv rv;\r\nif (test_and_clear_bit(CL_ST_CHG_SUCCESS, &device->flags))\r\nreturn SS_CW_SUCCESS;\r\nif (test_and_clear_bit(CL_ST_CHG_FAIL, &device->flags))\r\nreturn SS_CW_FAILED_BY_PEER;\r\nspin_lock_irqsave(&device->resource->req_lock, flags);\r\nos = drbd_read_state(device);\r\nns = sanitize_state(device, os, apply_mask_val(os, mask, val), NULL);\r\nrv = is_valid_transition(os, ns);\r\nif (rv >= SS_SUCCESS)\r\nrv = SS_UNKNOWN_ERROR;\r\nif (!cl_wide_st_chg(device, os, ns))\r\nrv = SS_CW_NO_NEED;\r\nif (rv == SS_UNKNOWN_ERROR) {\r\nrv = is_valid_state(device, ns);\r\nif (rv >= SS_SUCCESS) {\r\nrv = is_valid_soft_transition(os, ns, first_peer_device(device)->connection);\r\nif (rv >= SS_SUCCESS)\r\nrv = SS_UNKNOWN_ERROR;\r\n}\r\n}\r\nspin_unlock_irqrestore(&device->resource->req_lock, flags);\r\nreturn rv;\r\n}\r\nstatic enum drbd_state_rv\r\ndrbd_req_state(struct drbd_device *device, union drbd_state mask,\r\nunion drbd_state val, enum chg_state_flags f)\r\n{\r\nstruct completion done;\r\nunsigned long flags;\r\nunion drbd_state os, ns;\r\nenum drbd_state_rv rv;\r\ninit_completion(&done);\r\nif (f & CS_SERIALIZE)\r\nmutex_lock(device->state_mutex);\r\nspin_lock_irqsave(&device->resource->req_lock, flags);\r\nos = drbd_read_state(device);\r\nns = sanitize_state(device, os, apply_mask_val(os, mask, val), NULL);\r\nrv = is_valid_transition(os, ns);\r\nif (rv < SS_SUCCESS) {\r\nspin_unlock_irqrestore(&device->resource->req_lock, flags);\r\ngoto abort;\r\n}\r\nif (cl_wide_st_chg(device, os, ns)) {\r\nrv = is_valid_state(device, ns);\r\nif (rv == SS_SUCCESS)\r\nrv = is_valid_soft_transition(os, ns, first_peer_device(device)->connection);\r\nspin_unlock_irqrestore(&device->resource->req_lock, flags);\r\nif (rv < SS_SUCCESS) {\r\nif (f & CS_VERBOSE)\r\nprint_st_err(device, os, ns, rv);\r\ngoto abort;\r\n}\r\nif (drbd_send_state_req(first_peer_device(device), mask, val)) {\r\nrv = SS_CW_FAILED_BY_PEER;\r\nif (f & CS_VERBOSE)\r\nprint_st_err(device, os, ns, rv);\r\ngoto abort;\r\n}\r\nwait_event(device->state_wait,\r\n(rv = _req_st_cond(device, mask, val)));\r\nif (rv < SS_SUCCESS) {\r\nif (f & CS_VERBOSE)\r\nprint_st_err(device, os, ns, rv);\r\ngoto abort;\r\n}\r\nspin_lock_irqsave(&device->resource->req_lock, flags);\r\nns = apply_mask_val(drbd_read_state(device), mask, val);\r\nrv = _drbd_set_state(device, ns, f, &done);\r\n} else {\r\nrv = _drbd_set_state(device, ns, f, &done);\r\n}\r\nspin_unlock_irqrestore(&device->resource->req_lock, flags);\r\nif (f & CS_WAIT_COMPLETE && rv == SS_SUCCESS) {\r\nD_ASSERT(device, current != first_peer_device(device)->connection->worker.task);\r\nwait_for_completion(&done);\r\n}\r\nabort:\r\nif (f & CS_SERIALIZE)\r\nmutex_unlock(device->state_mutex);\r\nreturn rv;\r\n}\r\nenum drbd_state_rv\r\n_drbd_request_state(struct drbd_device *device, union drbd_state mask,\r\nunion drbd_state val, enum chg_state_flags f)\r\n{\r\nenum drbd_state_rv rv;\r\nwait_event(device->state_wait,\r\n(rv = drbd_req_state(device, mask, val, f)) != SS_IN_TRANSIENT_STATE);\r\nreturn rv;\r\n}\r\nenum drbd_state_rv\r\n_drbd_request_state_holding_state_mutex(struct drbd_device *device, union drbd_state mask,\r\nunion drbd_state val, enum chg_state_flags f)\r\n{\r\nenum drbd_state_rv rv;\r\nBUG_ON(f & CS_SERIALIZE);\r\nwait_event_cmd(device->state_wait,\r\n(rv = drbd_req_state(device, mask, val, f)) != SS_IN_TRANSIENT_STATE,\r\nmutex_unlock(device->state_mutex),\r\nmutex_lock(device->state_mutex));\r\nreturn rv;\r\n}\r\nstatic void print_st(struct drbd_device *device, const char *name, union drbd_state ns)\r\n{\r\ndrbd_err(device, " %s = { cs:%s ro:%s/%s ds:%s/%s %c%c%c%c%c%c }\n",\r\nname,\r\ndrbd_conn_str(ns.conn),\r\ndrbd_role_str(ns.role),\r\ndrbd_role_str(ns.peer),\r\ndrbd_disk_str(ns.disk),\r\ndrbd_disk_str(ns.pdsk),\r\nis_susp(ns) ? 's' : 'r',\r\nns.aftr_isp ? 'a' : '-',\r\nns.peer_isp ? 'p' : '-',\r\nns.user_isp ? 'u' : '-',\r\nns.susp_fen ? 'F' : '-',\r\nns.susp_nod ? 'N' : '-'\r\n);\r\n}\r\nvoid print_st_err(struct drbd_device *device, union drbd_state os,\r\nunion drbd_state ns, enum drbd_state_rv err)\r\n{\r\nif (err == SS_IN_TRANSIENT_STATE)\r\nreturn;\r\ndrbd_err(device, "State change failed: %s\n", drbd_set_st_err_str(err));\r\nprint_st(device, " state", os);\r\nprint_st(device, "wanted", ns);\r\n}\r\nstatic long print_state_change(char *pb, union drbd_state os, union drbd_state ns,\r\nenum chg_state_flags flags)\r\n{\r\nchar *pbp;\r\npbp = pb;\r\n*pbp = 0;\r\nif (ns.role != os.role && flags & CS_DC_ROLE)\r\npbp += sprintf(pbp, "role( %s -> %s ) ",\r\ndrbd_role_str(os.role),\r\ndrbd_role_str(ns.role));\r\nif (ns.peer != os.peer && flags & CS_DC_PEER)\r\npbp += sprintf(pbp, "peer( %s -> %s ) ",\r\ndrbd_role_str(os.peer),\r\ndrbd_role_str(ns.peer));\r\nif (ns.conn != os.conn && flags & CS_DC_CONN)\r\npbp += sprintf(pbp, "conn( %s -> %s ) ",\r\ndrbd_conn_str(os.conn),\r\ndrbd_conn_str(ns.conn));\r\nif (ns.disk != os.disk && flags & CS_DC_DISK)\r\npbp += sprintf(pbp, "disk( %s -> %s ) ",\r\ndrbd_disk_str(os.disk),\r\ndrbd_disk_str(ns.disk));\r\nif (ns.pdsk != os.pdsk && flags & CS_DC_PDSK)\r\npbp += sprintf(pbp, "pdsk( %s -> %s ) ",\r\ndrbd_disk_str(os.pdsk),\r\ndrbd_disk_str(ns.pdsk));\r\nreturn pbp - pb;\r\n}\r\nstatic void drbd_pr_state_change(struct drbd_device *device, union drbd_state os, union drbd_state ns,\r\nenum chg_state_flags flags)\r\n{\r\nchar pb[300];\r\nchar *pbp = pb;\r\npbp += print_state_change(pbp, os, ns, flags ^ CS_DC_MASK);\r\nif (ns.aftr_isp != os.aftr_isp)\r\npbp += sprintf(pbp, "aftr_isp( %d -> %d ) ",\r\nos.aftr_isp,\r\nns.aftr_isp);\r\nif (ns.peer_isp != os.peer_isp)\r\npbp += sprintf(pbp, "peer_isp( %d -> %d ) ",\r\nos.peer_isp,\r\nns.peer_isp);\r\nif (ns.user_isp != os.user_isp)\r\npbp += sprintf(pbp, "user_isp( %d -> %d ) ",\r\nos.user_isp,\r\nns.user_isp);\r\nif (pbp != pb)\r\ndrbd_info(device, "%s\n", pb);\r\n}\r\nstatic void conn_pr_state_change(struct drbd_connection *connection, union drbd_state os, union drbd_state ns,\r\nenum chg_state_flags flags)\r\n{\r\nchar pb[300];\r\nchar *pbp = pb;\r\npbp += print_state_change(pbp, os, ns, flags);\r\nif (is_susp(ns) != is_susp(os) && flags & CS_DC_SUSP)\r\npbp += sprintf(pbp, "susp( %d -> %d ) ",\r\nis_susp(os),\r\nis_susp(ns));\r\nif (pbp != pb)\r\ndrbd_info(connection, "%s\n", pb);\r\n}\r\nstatic enum drbd_state_rv\r\nis_valid_state(struct drbd_device *device, union drbd_state ns)\r\n{\r\nenum drbd_fencing_p fp;\r\nenum drbd_state_rv rv = SS_SUCCESS;\r\nstruct net_conf *nc;\r\nrcu_read_lock();\r\nfp = FP_DONT_CARE;\r\nif (get_ldev(device)) {\r\nfp = rcu_dereference(device->ldev->disk_conf)->fencing;\r\nput_ldev(device);\r\n}\r\nnc = rcu_dereference(first_peer_device(device)->connection->net_conf);\r\nif (nc) {\r\nif (!nc->two_primaries && ns.role == R_PRIMARY) {\r\nif (ns.peer == R_PRIMARY)\r\nrv = SS_TWO_PRIMARIES;\r\nelse if (conn_highest_peer(first_peer_device(device)->connection) == R_PRIMARY)\r\nrv = SS_O_VOL_PEER_PRI;\r\n}\r\n}\r\nif (rv <= 0)\r\n;\r\nelse if (ns.role == R_SECONDARY && device->open_cnt)\r\nrv = SS_DEVICE_IN_USE;\r\nelse if (ns.role == R_PRIMARY && ns.conn < C_CONNECTED && ns.disk < D_UP_TO_DATE)\r\nrv = SS_NO_UP_TO_DATE_DISK;\r\nelse if (fp >= FP_RESOURCE &&\r\nns.role == R_PRIMARY && ns.conn < C_CONNECTED && ns.pdsk >= D_UNKNOWN)\r\nrv = SS_PRIMARY_NOP;\r\nelse if (ns.role == R_PRIMARY && ns.disk <= D_INCONSISTENT && ns.pdsk <= D_INCONSISTENT)\r\nrv = SS_NO_UP_TO_DATE_DISK;\r\nelse if (ns.conn > C_CONNECTED && ns.disk < D_INCONSISTENT)\r\nrv = SS_NO_LOCAL_DISK;\r\nelse if (ns.conn > C_CONNECTED && ns.pdsk < D_INCONSISTENT)\r\nrv = SS_NO_REMOTE_DISK;\r\nelse if (ns.conn > C_CONNECTED && ns.disk < D_UP_TO_DATE && ns.pdsk < D_UP_TO_DATE)\r\nrv = SS_NO_UP_TO_DATE_DISK;\r\nelse if ((ns.conn == C_CONNECTED ||\r\nns.conn == C_WF_BITMAP_S ||\r\nns.conn == C_SYNC_SOURCE ||\r\nns.conn == C_PAUSED_SYNC_S) &&\r\nns.disk == D_OUTDATED)\r\nrv = SS_CONNECTED_OUTDATES;\r\nelse if ((ns.conn == C_VERIFY_S || ns.conn == C_VERIFY_T) &&\r\n(nc->verify_alg[0] == 0))\r\nrv = SS_NO_VERIFY_ALG;\r\nelse if ((ns.conn == C_VERIFY_S || ns.conn == C_VERIFY_T) &&\r\nfirst_peer_device(device)->connection->agreed_pro_version < 88)\r\nrv = SS_NOT_SUPPORTED;\r\nelse if (ns.role == R_PRIMARY && ns.disk < D_UP_TO_DATE && ns.pdsk < D_UP_TO_DATE)\r\nrv = SS_NO_UP_TO_DATE_DISK;\r\nelse if ((ns.conn == C_STARTING_SYNC_S || ns.conn == C_STARTING_SYNC_T) &&\r\nns.pdsk == D_UNKNOWN)\r\nrv = SS_NEED_CONNECTION;\r\nelse if (ns.conn >= C_CONNECTED && ns.pdsk == D_UNKNOWN)\r\nrv = SS_CONNECTED_OUTDATES;\r\nrcu_read_unlock();\r\nreturn rv;\r\n}\r\nstatic enum drbd_state_rv\r\nis_valid_soft_transition(union drbd_state os, union drbd_state ns, struct drbd_connection *connection)\r\n{\r\nenum drbd_state_rv rv = SS_SUCCESS;\r\nif ((ns.conn == C_STARTING_SYNC_T || ns.conn == C_STARTING_SYNC_S) &&\r\nos.conn > C_CONNECTED)\r\nrv = SS_RESYNC_RUNNING;\r\nif (ns.conn == C_DISCONNECTING && os.conn == C_STANDALONE)\r\nrv = SS_ALREADY_STANDALONE;\r\nif (ns.disk > D_ATTACHING && os.disk == D_DISKLESS)\r\nrv = SS_IS_DISKLESS;\r\nif (ns.conn == C_WF_CONNECTION && os.conn < C_UNCONNECTED)\r\nrv = SS_NO_NET_CONFIG;\r\nif (ns.disk == D_OUTDATED && os.disk < D_OUTDATED && os.disk != D_ATTACHING)\r\nrv = SS_LOWER_THAN_OUTDATED;\r\nif (ns.conn == C_DISCONNECTING && os.conn == C_UNCONNECTED)\r\nrv = SS_IN_TRANSIENT_STATE;\r\nif (test_bit(STATE_SENT, &connection->flags) &&\r\n!((ns.conn == C_WF_REPORT_PARAMS && os.conn == C_WF_CONNECTION) ||\r\n(ns.conn >= C_CONNECTED && os.conn == C_WF_REPORT_PARAMS)))\r\nrv = SS_IN_TRANSIENT_STATE;\r\nif ((ns.conn == C_VERIFY_S || ns.conn == C_VERIFY_T) && os.conn < C_CONNECTED)\r\nrv = SS_NEED_CONNECTION;\r\nif ((ns.conn == C_VERIFY_S || ns.conn == C_VERIFY_T) &&\r\nns.conn != os.conn && os.conn > C_CONNECTED)\r\nrv = SS_RESYNC_RUNNING;\r\nif ((ns.conn == C_STARTING_SYNC_S || ns.conn == C_STARTING_SYNC_T) &&\r\nos.conn < C_CONNECTED)\r\nrv = SS_NEED_CONNECTION;\r\nif ((ns.conn == C_SYNC_TARGET || ns.conn == C_SYNC_SOURCE)\r\n&& os.conn < C_WF_REPORT_PARAMS)\r\nrv = SS_NEED_CONNECTION;\r\nif (ns.conn == C_DISCONNECTING && ns.pdsk == D_OUTDATED &&\r\nos.conn < C_CONNECTED && os.pdsk > D_OUTDATED)\r\nrv = SS_OUTDATE_WO_CONN;\r\nreturn rv;\r\n}\r\nstatic enum drbd_state_rv\r\nis_valid_conn_transition(enum drbd_conns oc, enum drbd_conns nc)\r\n{\r\nif (oc == nc)\r\nreturn SS_NOTHING_TO_DO;\r\nif (oc == C_STANDALONE && nc == C_DISCONNECTING)\r\nreturn SS_ALREADY_STANDALONE;\r\nif (oc == C_STANDALONE && nc != C_UNCONNECTED)\r\nreturn SS_NEED_CONNECTION;\r\nif (oc < C_WF_REPORT_PARAMS && nc >= C_CONNECTED)\r\nreturn SS_NEED_CONNECTION;\r\nif (oc >= C_TIMEOUT && oc <= C_TEAR_DOWN && nc != C_UNCONNECTED && nc != C_DISCONNECTING)\r\nreturn SS_IN_TRANSIENT_STATE;\r\nif (oc == C_DISCONNECTING && nc != C_STANDALONE)\r\nreturn SS_IN_TRANSIENT_STATE;\r\nreturn SS_SUCCESS;\r\n}\r\nstatic enum drbd_state_rv\r\nis_valid_transition(union drbd_state os, union drbd_state ns)\r\n{\r\nenum drbd_state_rv rv;\r\nrv = is_valid_conn_transition(os.conn, ns.conn);\r\nif (ns.disk == D_FAILED && os.disk == D_DISKLESS)\r\nrv = SS_IS_DISKLESS;\r\nreturn rv;\r\n}\r\nstatic void print_sanitize_warnings(struct drbd_device *device, enum sanitize_state_warnings warn)\r\n{\r\nstatic const char *msg_table[] = {\r\n[NO_WARNING] = "",\r\n[ABORTED_ONLINE_VERIFY] = "Online-verify aborted.",\r\n[ABORTED_RESYNC] = "Resync aborted.",\r\n[CONNECTION_LOST_NEGOTIATING] = "Connection lost while negotiating, no data!",\r\n[IMPLICITLY_UPGRADED_DISK] = "Implicitly upgraded disk",\r\n[IMPLICITLY_UPGRADED_PDSK] = "Implicitly upgraded pdsk",\r\n};\r\nif (warn != NO_WARNING)\r\ndrbd_warn(device, "%s\n", msg_table[warn]);\r\n}\r\nstatic union drbd_state sanitize_state(struct drbd_device *device, union drbd_state os,\r\nunion drbd_state ns, enum sanitize_state_warnings *warn)\r\n{\r\nenum drbd_fencing_p fp;\r\nenum drbd_disk_state disk_min, disk_max, pdsk_min, pdsk_max;\r\nif (warn)\r\n*warn = NO_WARNING;\r\nfp = FP_DONT_CARE;\r\nif (get_ldev(device)) {\r\nrcu_read_lock();\r\nfp = rcu_dereference(device->ldev->disk_conf)->fencing;\r\nrcu_read_unlock();\r\nput_ldev(device);\r\n}\r\nif (ns.conn < C_CONNECTED) {\r\nns.peer_isp = 0;\r\nns.peer = R_UNKNOWN;\r\nif (ns.pdsk > D_UNKNOWN || ns.pdsk < D_INCONSISTENT)\r\nns.pdsk = D_UNKNOWN;\r\n}\r\nif (ns.conn == C_STANDALONE && ns.disk == D_DISKLESS && ns.role == R_SECONDARY)\r\nns.aftr_isp = 0;\r\nif (ns.conn > C_CONNECTED && (ns.disk <= D_FAILED || ns.pdsk <= D_FAILED)) {\r\nif (warn)\r\n*warn = ns.conn == C_VERIFY_S || ns.conn == C_VERIFY_T ?\r\nABORTED_ONLINE_VERIFY : ABORTED_RESYNC;\r\nns.conn = C_CONNECTED;\r\n}\r\nif (ns.conn < C_CONNECTED && ns.disk == D_NEGOTIATING &&\r\nget_ldev_if_state(device, D_NEGOTIATING)) {\r\nif (device->ed_uuid == device->ldev->md.uuid[UI_CURRENT]) {\r\nns.disk = device->new_state_tmp.disk;\r\nns.pdsk = device->new_state_tmp.pdsk;\r\n} else {\r\nif (warn)\r\n*warn = CONNECTION_LOST_NEGOTIATING;\r\nns.disk = D_DISKLESS;\r\nns.pdsk = D_UNKNOWN;\r\n}\r\nput_ldev(device);\r\n}\r\nif (ns.conn >= C_CONNECTED && ns.conn < C_AHEAD) {\r\nif (ns.disk == D_CONSISTENT || ns.disk == D_OUTDATED)\r\nns.disk = D_UP_TO_DATE;\r\nif (ns.pdsk == D_CONSISTENT || ns.pdsk == D_OUTDATED)\r\nns.pdsk = D_UP_TO_DATE;\r\n}\r\ndisk_min = D_DISKLESS;\r\ndisk_max = D_UP_TO_DATE;\r\npdsk_min = D_INCONSISTENT;\r\npdsk_max = D_UNKNOWN;\r\nswitch ((enum drbd_conns)ns.conn) {\r\ncase C_WF_BITMAP_T:\r\ncase C_PAUSED_SYNC_T:\r\ncase C_STARTING_SYNC_T:\r\ncase C_WF_SYNC_UUID:\r\ncase C_BEHIND:\r\ndisk_min = D_INCONSISTENT;\r\ndisk_max = D_OUTDATED;\r\npdsk_min = D_UP_TO_DATE;\r\npdsk_max = D_UP_TO_DATE;\r\nbreak;\r\ncase C_VERIFY_S:\r\ncase C_VERIFY_T:\r\ndisk_min = D_UP_TO_DATE;\r\ndisk_max = D_UP_TO_DATE;\r\npdsk_min = D_UP_TO_DATE;\r\npdsk_max = D_UP_TO_DATE;\r\nbreak;\r\ncase C_CONNECTED:\r\ndisk_min = D_DISKLESS;\r\ndisk_max = D_UP_TO_DATE;\r\npdsk_min = D_DISKLESS;\r\npdsk_max = D_UP_TO_DATE;\r\nbreak;\r\ncase C_WF_BITMAP_S:\r\ncase C_PAUSED_SYNC_S:\r\ncase C_STARTING_SYNC_S:\r\ncase C_AHEAD:\r\ndisk_min = D_UP_TO_DATE;\r\ndisk_max = D_UP_TO_DATE;\r\npdsk_min = D_INCONSISTENT;\r\npdsk_max = D_CONSISTENT;\r\nbreak;\r\ncase C_SYNC_TARGET:\r\ndisk_min = D_INCONSISTENT;\r\ndisk_max = D_INCONSISTENT;\r\npdsk_min = D_UP_TO_DATE;\r\npdsk_max = D_UP_TO_DATE;\r\nbreak;\r\ncase C_SYNC_SOURCE:\r\ndisk_min = D_UP_TO_DATE;\r\ndisk_max = D_UP_TO_DATE;\r\npdsk_min = D_INCONSISTENT;\r\npdsk_max = D_INCONSISTENT;\r\nbreak;\r\ncase C_STANDALONE:\r\ncase C_DISCONNECTING:\r\ncase C_UNCONNECTED:\r\ncase C_TIMEOUT:\r\ncase C_BROKEN_PIPE:\r\ncase C_NETWORK_FAILURE:\r\ncase C_PROTOCOL_ERROR:\r\ncase C_TEAR_DOWN:\r\ncase C_WF_CONNECTION:\r\ncase C_WF_REPORT_PARAMS:\r\ncase C_MASK:\r\nbreak;\r\n}\r\nif (ns.disk > disk_max)\r\nns.disk = disk_max;\r\nif (ns.disk < disk_min) {\r\nif (warn)\r\n*warn = IMPLICITLY_UPGRADED_DISK;\r\nns.disk = disk_min;\r\n}\r\nif (ns.pdsk > pdsk_max)\r\nns.pdsk = pdsk_max;\r\nif (ns.pdsk < pdsk_min) {\r\nif (warn)\r\n*warn = IMPLICITLY_UPGRADED_PDSK;\r\nns.pdsk = pdsk_min;\r\n}\r\nif (fp == FP_STONITH &&\r\n(ns.role == R_PRIMARY && ns.conn < C_CONNECTED && ns.pdsk > D_OUTDATED) &&\r\n!(os.role == R_PRIMARY && os.conn < C_CONNECTED && os.pdsk > D_OUTDATED))\r\nns.susp_fen = 1;\r\nif (device->resource->res_opts.on_no_data == OND_SUSPEND_IO &&\r\n(ns.role == R_PRIMARY && ns.disk < D_UP_TO_DATE && ns.pdsk < D_UP_TO_DATE) &&\r\n!(os.role == R_PRIMARY && os.disk < D_UP_TO_DATE && os.pdsk < D_UP_TO_DATE))\r\nns.susp_nod = 1;\r\nif (ns.aftr_isp || ns.peer_isp || ns.user_isp) {\r\nif (ns.conn == C_SYNC_SOURCE)\r\nns.conn = C_PAUSED_SYNC_S;\r\nif (ns.conn == C_SYNC_TARGET)\r\nns.conn = C_PAUSED_SYNC_T;\r\n} else {\r\nif (ns.conn == C_PAUSED_SYNC_S)\r\nns.conn = C_SYNC_SOURCE;\r\nif (ns.conn == C_PAUSED_SYNC_T)\r\nns.conn = C_SYNC_TARGET;\r\n}\r\nreturn ns;\r\n}\r\nvoid drbd_resume_al(struct drbd_device *device)\r\n{\r\nif (test_and_clear_bit(AL_SUSPENDED, &device->flags))\r\ndrbd_info(device, "Resumed AL updates\n");\r\n}\r\nstatic void set_ov_position(struct drbd_device *device, enum drbd_conns cs)\r\n{\r\nif (first_peer_device(device)->connection->agreed_pro_version < 90)\r\ndevice->ov_start_sector = 0;\r\ndevice->rs_total = drbd_bm_bits(device);\r\ndevice->ov_position = 0;\r\nif (cs == C_VERIFY_T) {\r\ndevice->ov_start_sector = ~(sector_t)0;\r\n} else {\r\nunsigned long bit = BM_SECT_TO_BIT(device->ov_start_sector);\r\nif (bit >= device->rs_total) {\r\ndevice->ov_start_sector =\r\nBM_BIT_TO_SECT(device->rs_total - 1);\r\ndevice->rs_total = 1;\r\n} else\r\ndevice->rs_total -= bit;\r\ndevice->ov_position = device->ov_start_sector;\r\n}\r\ndevice->ov_left = device->rs_total;\r\n}\r\nenum drbd_state_rv\r\n__drbd_set_state(struct drbd_device *device, union drbd_state ns,\r\nenum chg_state_flags flags, struct completion *done)\r\n{\r\nstruct drbd_peer_device *peer_device = first_peer_device(device);\r\nstruct drbd_connection *connection = peer_device ? peer_device->connection : NULL;\r\nunion drbd_state os;\r\nenum drbd_state_rv rv = SS_SUCCESS;\r\nenum sanitize_state_warnings ssw;\r\nstruct after_state_chg_work *ascw;\r\nos = drbd_read_state(device);\r\nns = sanitize_state(device, os, ns, &ssw);\r\nif (ns.i == os.i)\r\nreturn SS_NOTHING_TO_DO;\r\nrv = is_valid_transition(os, ns);\r\nif (rv < SS_SUCCESS)\r\nreturn rv;\r\nif (!(flags & CS_HARD)) {\r\nrv = is_valid_state(device, ns);\r\nif (rv < SS_SUCCESS) {\r\nif (is_valid_state(device, os) == rv)\r\nrv = is_valid_soft_transition(os, ns, connection);\r\n} else\r\nrv = is_valid_soft_transition(os, ns, connection);\r\n}\r\nif (rv < SS_SUCCESS) {\r\nif (flags & CS_VERBOSE)\r\nprint_st_err(device, os, ns, rv);\r\nreturn rv;\r\n}\r\nprint_sanitize_warnings(device, ssw);\r\ndrbd_pr_state_change(device, os, ns, flags);\r\nif (!(flags & CS_DC_SUSP))\r\nconn_pr_state_change(connection, os, ns,\r\n(flags & ~CS_DC_MASK) | CS_DC_SUSP);\r\nif ((os.disk != D_FAILED && ns.disk == D_FAILED) ||\r\n(os.disk != D_DISKLESS && ns.disk == D_DISKLESS))\r\natomic_inc(&device->local_cnt);\r\nif (!is_sync_state(os.conn) && is_sync_state(ns.conn))\r\nclear_bit(RS_DONE, &device->flags);\r\nsmp_wmb();\r\ndevice->state.i = ns.i;\r\ndevice->resource->susp = ns.susp;\r\ndevice->resource->susp_nod = ns.susp_nod;\r\ndevice->resource->susp_fen = ns.susp_fen;\r\nsmp_wmb();\r\nif (drbd_should_do_remote((union drbd_dev_state)os.i) !=\r\ndrbd_should_do_remote((union drbd_dev_state)ns.i))\r\nstart_new_tl_epoch(connection);\r\nif (os.disk == D_ATTACHING && ns.disk >= D_NEGOTIATING)\r\ndrbd_print_uuids(device, "attached to UUIDs");\r\nif (os.conn == C_WF_REPORT_PARAMS && ns.conn != C_WF_REPORT_PARAMS &&\r\nno_peer_wf_report_params(connection)) {\r\nclear_bit(STATE_SENT, &connection->flags);\r\nwake_up_all_devices(connection);\r\n}\r\nwake_up(&device->misc_wait);\r\nwake_up(&device->state_wait);\r\nwake_up(&connection->ping_wait);\r\nif ((os.conn == C_VERIFY_S || os.conn == C_VERIFY_T) &&\r\nns.conn <= C_CONNECTED) {\r\ndevice->ov_start_sector =\r\nBM_BIT_TO_SECT(drbd_bm_bits(device) - device->ov_left);\r\nif (device->ov_left)\r\ndrbd_info(device, "Online Verify reached sector %llu\n",\r\n(unsigned long long)device->ov_start_sector);\r\n}\r\nif ((os.conn == C_PAUSED_SYNC_T || os.conn == C_PAUSED_SYNC_S) &&\r\n(ns.conn == C_SYNC_TARGET || ns.conn == C_SYNC_SOURCE)) {\r\ndrbd_info(device, "Syncer continues.\n");\r\ndevice->rs_paused += (long)jiffies\r\n-(long)device->rs_mark_time[device->rs_last_mark];\r\nif (ns.conn == C_SYNC_TARGET)\r\nmod_timer(&device->resync_timer, jiffies);\r\n}\r\nif ((os.conn == C_SYNC_TARGET || os.conn == C_SYNC_SOURCE) &&\r\n(ns.conn == C_PAUSED_SYNC_T || ns.conn == C_PAUSED_SYNC_S)) {\r\ndrbd_info(device, "Resync suspended\n");\r\ndevice->rs_mark_time[device->rs_last_mark] = jiffies;\r\n}\r\nif (os.conn == C_CONNECTED &&\r\n(ns.conn == C_VERIFY_S || ns.conn == C_VERIFY_T)) {\r\nunsigned long now = jiffies;\r\nint i;\r\nset_ov_position(device, ns.conn);\r\ndevice->rs_start = now;\r\ndevice->rs_last_sect_ev = 0;\r\ndevice->ov_last_oos_size = 0;\r\ndevice->ov_last_oos_start = 0;\r\nfor (i = 0; i < DRBD_SYNC_MARKS; i++) {\r\ndevice->rs_mark_left[i] = device->ov_left;\r\ndevice->rs_mark_time[i] = now;\r\n}\r\ndrbd_rs_controller_reset(device);\r\nif (ns.conn == C_VERIFY_S) {\r\ndrbd_info(device, "Starting Online Verify from sector %llu\n",\r\n(unsigned long long)device->ov_position);\r\nmod_timer(&device->resync_timer, jiffies);\r\n}\r\n}\r\nif (get_ldev(device)) {\r\nu32 mdf = device->ldev->md.flags & ~(MDF_CONSISTENT|MDF_PRIMARY_IND|\r\nMDF_CONNECTED_IND|MDF_WAS_UP_TO_DATE|\r\nMDF_PEER_OUT_DATED|MDF_CRASHED_PRIMARY);\r\nmdf &= ~MDF_AL_CLEAN;\r\nif (test_bit(CRASHED_PRIMARY, &device->flags))\r\nmdf |= MDF_CRASHED_PRIMARY;\r\nif (device->state.role == R_PRIMARY ||\r\n(device->state.pdsk < D_INCONSISTENT && device->state.peer == R_PRIMARY))\r\nmdf |= MDF_PRIMARY_IND;\r\nif (device->state.conn > C_WF_REPORT_PARAMS)\r\nmdf |= MDF_CONNECTED_IND;\r\nif (device->state.disk > D_INCONSISTENT)\r\nmdf |= MDF_CONSISTENT;\r\nif (device->state.disk > D_OUTDATED)\r\nmdf |= MDF_WAS_UP_TO_DATE;\r\nif (device->state.pdsk <= D_OUTDATED && device->state.pdsk >= D_INCONSISTENT)\r\nmdf |= MDF_PEER_OUT_DATED;\r\nif (mdf != device->ldev->md.flags) {\r\ndevice->ldev->md.flags = mdf;\r\ndrbd_md_mark_dirty(device);\r\n}\r\nif (os.disk < D_CONSISTENT && ns.disk >= D_CONSISTENT)\r\ndrbd_set_ed_uuid(device, device->ldev->md.uuid[UI_CURRENT]);\r\nput_ldev(device);\r\n}\r\nif (os.disk == D_INCONSISTENT && os.pdsk == D_INCONSISTENT &&\r\nos.peer == R_SECONDARY && ns.peer == R_PRIMARY)\r\nset_bit(CONSIDER_RESYNC, &device->flags);\r\nif (os.conn != C_DISCONNECTING && ns.conn == C_DISCONNECTING)\r\ndrbd_thread_stop_nowait(&connection->receiver);\r\nif (os.conn != C_STANDALONE && ns.conn == C_STANDALONE)\r\ndrbd_thread_stop_nowait(&connection->receiver);\r\nif (os.conn > C_WF_CONNECTION &&\r\nns.conn <= C_TEAR_DOWN && ns.conn >= C_TIMEOUT)\r\ndrbd_thread_restart_nowait(&connection->receiver);\r\nif (os.conn < C_CONNECTED && ns.conn >= C_CONNECTED) {\r\ndrbd_resume_al(device);\r\nconnection->connect_cnt++;\r\n}\r\nif ((os.disk == D_ATTACHING || os.disk == D_NEGOTIATING) &&\r\nns.disk > D_NEGOTIATING)\r\ndevice->last_reattach_jif = jiffies;\r\nascw = kmalloc(sizeof(*ascw), GFP_ATOMIC);\r\nif (ascw) {\r\nascw->os = os;\r\nascw->ns = ns;\r\nascw->flags = flags;\r\nascw->w.cb = w_after_state_ch;\r\nascw->device = device;\r\nascw->done = done;\r\ndrbd_queue_work(&connection->sender_work,\r\n&ascw->w);\r\n} else {\r\ndrbd_err(device, "Could not kmalloc an ascw\n");\r\n}\r\nreturn rv;\r\n}\r\nstatic int w_after_state_ch(struct drbd_work *w, int unused)\r\n{\r\nstruct after_state_chg_work *ascw =\r\ncontainer_of(w, struct after_state_chg_work, w);\r\nstruct drbd_device *device = ascw->device;\r\nafter_state_ch(device, ascw->os, ascw->ns, ascw->flags);\r\nif (ascw->flags & CS_WAIT_COMPLETE)\r\ncomplete(ascw->done);\r\nkfree(ascw);\r\nreturn 0;\r\n}\r\nstatic void abw_start_sync(struct drbd_device *device, int rv)\r\n{\r\nif (rv) {\r\ndrbd_err(device, "Writing the bitmap failed not starting resync.\n");\r\n_drbd_request_state(device, NS(conn, C_CONNECTED), CS_VERBOSE);\r\nreturn;\r\n}\r\nswitch (device->state.conn) {\r\ncase C_STARTING_SYNC_T:\r\n_drbd_request_state(device, NS(conn, C_WF_SYNC_UUID), CS_VERBOSE);\r\nbreak;\r\ncase C_STARTING_SYNC_S:\r\ndrbd_start_resync(device, C_SYNC_SOURCE);\r\nbreak;\r\n}\r\n}\r\nint drbd_bitmap_io_from_worker(struct drbd_device *device,\r\nint (*io_fn)(struct drbd_device *),\r\nchar *why, enum bm_flag flags)\r\n{\r\nint rv;\r\nD_ASSERT(device, current == first_peer_device(device)->connection->worker.task);\r\nset_bit(SUSPEND_IO, &device->flags);\r\ndrbd_bm_lock(device, why, flags);\r\nrv = io_fn(device);\r\ndrbd_bm_unlock(device);\r\ndrbd_resume_io(device);\r\nreturn rv;\r\n}\r\nstatic void after_state_ch(struct drbd_device *device, union drbd_state os,\r\nunion drbd_state ns, enum chg_state_flags flags)\r\n{\r\nstruct drbd_resource *resource = device->resource;\r\nstruct drbd_peer_device *peer_device = first_peer_device(device);\r\nstruct drbd_connection *connection = peer_device ? peer_device->connection : NULL;\r\nstruct sib_info sib;\r\nsib.sib_reason = SIB_STATE_CHANGE;\r\nsib.os = os;\r\nsib.ns = ns;\r\nif ((os.disk != D_UP_TO_DATE || os.pdsk != D_UP_TO_DATE)\r\n&& (ns.disk == D_UP_TO_DATE && ns.pdsk == D_UP_TO_DATE)) {\r\nclear_bit(CRASHED_PRIMARY, &device->flags);\r\nif (device->p_uuid)\r\ndevice->p_uuid[UI_FLAGS] &= ~((u64)2);\r\n}\r\ndrbd_bcast_event(device, &sib);\r\nif (!(os.role == R_PRIMARY && os.disk < D_UP_TO_DATE && os.pdsk < D_UP_TO_DATE) &&\r\n(ns.role == R_PRIMARY && ns.disk < D_UP_TO_DATE && ns.pdsk < D_UP_TO_DATE))\r\ndrbd_khelper(device, "pri-on-incon-degr");\r\nif (ns.susp_nod) {\r\nenum drbd_req_event what = NOTHING;\r\nspin_lock_irq(&device->resource->req_lock);\r\nif (os.conn < C_CONNECTED && conn_lowest_conn(connection) >= C_CONNECTED)\r\nwhat = RESEND;\r\nif ((os.disk == D_ATTACHING || os.disk == D_NEGOTIATING) &&\r\nconn_lowest_disk(connection) > D_NEGOTIATING)\r\nwhat = RESTART_FROZEN_DISK_IO;\r\nif (resource->susp_nod && what != NOTHING) {\r\n_tl_restart(connection, what);\r\n_conn_request_state(connection,\r\n(union drbd_state) { { .susp_nod = 1 } },\r\n(union drbd_state) { { .susp_nod = 0 } },\r\nCS_VERBOSE);\r\n}\r\nspin_unlock_irq(&device->resource->req_lock);\r\n}\r\nif (ns.susp_fen) {\r\nspin_lock_irq(&device->resource->req_lock);\r\nif (resource->susp_fen && conn_lowest_conn(connection) >= C_CONNECTED) {\r\nstruct drbd_peer_device *peer_device;\r\nint vnr;\r\nrcu_read_lock();\r\nidr_for_each_entry(&connection->peer_devices, peer_device, vnr)\r\nclear_bit(NEW_CUR_UUID, &peer_device->device->flags);\r\nrcu_read_unlock();\r\n_tl_restart(connection, RESEND);\r\n_conn_request_state(connection,\r\n(union drbd_state) { { .susp_fen = 1 } },\r\n(union drbd_state) { { .susp_fen = 0 } },\r\nCS_VERBOSE);\r\n}\r\nspin_unlock_irq(&device->resource->req_lock);\r\n}\r\nif ((os.conn != C_SYNC_SOURCE && os.conn != C_PAUSED_SYNC_S) &&\r\n(ns.conn == C_SYNC_SOURCE || ns.conn == C_PAUSED_SYNC_S) &&\r\nconnection->agreed_pro_version >= 96 && get_ldev(device)) {\r\ndrbd_gen_and_send_sync_uuid(peer_device);\r\nput_ldev(device);\r\n}\r\nif (os.pdsk == D_DISKLESS &&\r\nns.pdsk > D_DISKLESS && ns.pdsk != D_UNKNOWN) {\r\ndevice->rs_total = 0;\r\ndevice->rs_failed = 0;\r\natomic_set(&device->rs_pending_cnt, 0);\r\ndrbd_rs_cancel_all(device);\r\ndrbd_send_uuids(peer_device);\r\ndrbd_send_state(peer_device, ns);\r\n}\r\nif (os.conn != C_WF_BITMAP_S && ns.conn == C_WF_BITMAP_S &&\r\ndevice->state.conn == C_WF_BITMAP_S)\r\ndrbd_queue_bitmap_io(device, &drbd_send_bitmap, NULL,\r\n"send_bitmap (WFBitMapS)",\r\nBM_LOCKED_TEST_ALLOWED);\r\nif ((os.pdsk >= D_INCONSISTENT &&\r\nos.pdsk != D_UNKNOWN &&\r\nos.pdsk != D_OUTDATED)\r\n&& (ns.pdsk < D_INCONSISTENT ||\r\nns.pdsk == D_UNKNOWN ||\r\nns.pdsk == D_OUTDATED)) {\r\nif (get_ldev(device)) {\r\nif ((ns.role == R_PRIMARY || ns.peer == R_PRIMARY) &&\r\ndevice->ldev->md.uuid[UI_BITMAP] == 0 && ns.disk >= D_UP_TO_DATE) {\r\nif (drbd_suspended(device)) {\r\nset_bit(NEW_CUR_UUID, &device->flags);\r\n} else {\r\ndrbd_uuid_new_current(device);\r\ndrbd_send_uuids(peer_device);\r\n}\r\n}\r\nput_ldev(device);\r\n}\r\n}\r\nif (ns.pdsk < D_INCONSISTENT && get_ldev(device)) {\r\nif (os.peer == R_SECONDARY && ns.peer == R_PRIMARY &&\r\ndevice->ldev->md.uuid[UI_BITMAP] == 0 && ns.disk >= D_UP_TO_DATE) {\r\ndrbd_uuid_new_current(device);\r\ndrbd_send_uuids(peer_device);\r\n}\r\nif (os.peer == R_PRIMARY && ns.peer == R_SECONDARY)\r\ndrbd_bitmap_io_from_worker(device, &drbd_bm_write,\r\n"demote diskless peer", BM_LOCKED_SET_ALLOWED);\r\nput_ldev(device);\r\n}\r\nif (os.role == R_PRIMARY && ns.role == R_SECONDARY &&\r\ndevice->state.conn <= C_CONNECTED && get_ldev(device)) {\r\ndrbd_bitmap_io_from_worker(device, &drbd_bm_write,\r\n"demote", BM_LOCKED_TEST_ALLOWED);\r\nput_ldev(device);\r\n}\r\nif (ns.conn >= C_CONNECTED &&\r\nos.disk == D_ATTACHING && ns.disk == D_NEGOTIATING) {\r\ndrbd_send_sizes(peer_device, 0, 0);\r\ndrbd_send_uuids(peer_device);\r\ndrbd_send_state(peer_device, ns);\r\n}\r\nif (ns.conn >= C_CONNECTED &&\r\n((os.aftr_isp != ns.aftr_isp) ||\r\n(os.user_isp != ns.user_isp)))\r\ndrbd_send_state(peer_device, ns);\r\nif ((!os.aftr_isp && !os.peer_isp && !os.user_isp) &&\r\n(ns.aftr_isp || ns.peer_isp || ns.user_isp))\r\nsuspend_other_sg(device);\r\nif (os.conn == C_WF_REPORT_PARAMS && ns.conn >= C_CONNECTED)\r\ndrbd_send_state(peer_device, ns);\r\nif (os.conn != C_AHEAD && ns.conn == C_AHEAD)\r\ndrbd_send_state(peer_device, ns);\r\nif ((os.conn != C_STARTING_SYNC_T && ns.conn == C_STARTING_SYNC_T) ||\r\n(os.conn != C_STARTING_SYNC_S && ns.conn == C_STARTING_SYNC_S))\r\ndrbd_queue_bitmap_io(device,\r\n&drbd_bmio_set_n_write, &abw_start_sync,\r\n"set_n_write from StartingSync", BM_LOCKED_TEST_ALLOWED);\r\nif (os.disk != D_FAILED && ns.disk == D_FAILED) {\r\nenum drbd_io_error_p eh = EP_PASS_ON;\r\nint was_io_error = 0;\r\nif (device->ldev) {\r\nrcu_read_lock();\r\neh = rcu_dereference(device->ldev->disk_conf)->on_io_error;\r\nrcu_read_unlock();\r\nwas_io_error = test_and_clear_bit(WAS_IO_ERROR, &device->flags);\r\nif (was_io_error && eh == EP_CALL_HELPER)\r\ndrbd_khelper(device, "local-io-error");\r\nif (test_and_clear_bit(FORCE_DETACH, &device->flags))\r\ntl_abort_disk_io(device);\r\nif (device->state.disk != D_FAILED)\r\ndrbd_err(device,\r\n"ASSERT FAILED: disk is %s during detach\n",\r\ndrbd_disk_str(device->state.disk));\r\nif (ns.conn >= C_CONNECTED)\r\ndrbd_send_state(peer_device, ns);\r\ndrbd_rs_cancel_all(device);\r\ndrbd_md_sync(device);\r\n}\r\nput_ldev(device);\r\n}\r\nif (os.disk != D_DISKLESS && ns.disk == D_DISKLESS) {\r\nif (device->state.disk != D_DISKLESS)\r\ndrbd_err(device,\r\n"ASSERT FAILED: disk is %s while going diskless\n",\r\ndrbd_disk_str(device->state.disk));\r\nif (ns.conn >= C_CONNECTED)\r\ndrbd_send_state(peer_device, ns);\r\nput_ldev(device);\r\n}\r\nif (os.disk == D_UP_TO_DATE && ns.disk == D_INCONSISTENT && ns.conn >= C_CONNECTED)\r\ndrbd_send_state(peer_device, ns);\r\nif (ns.disk > D_NEGOTIATING && ns.pdsk > D_NEGOTIATING &&\r\ntest_and_clear_bit(RESYNC_AFTER_NEG, &device->flags)) {\r\nif (ns.conn == C_CONNECTED)\r\nresync_after_online_grow(device);\r\n}\r\nif ((os.conn > C_CONNECTED && ns.conn <= C_CONNECTED) ||\r\n(os.peer_isp && !ns.peer_isp) ||\r\n(os.user_isp && !ns.user_isp))\r\nresume_next_sg(device);\r\nif (os.disk < D_UP_TO_DATE && os.conn >= C_SYNC_SOURCE && ns.conn == C_CONNECTED)\r\ndrbd_send_state(peer_device, ns);\r\nif (os.conn == C_VERIFY_S && ns.conn == C_CONNECTED\r\n&& verify_can_do_stop_sector(device))\r\ndrbd_send_state(peer_device, ns);\r\nif (os.conn > C_CONNECTED && ns.conn <= C_CONNECTED && get_ldev(device)) {\r\ndrbd_queue_bitmap_io(device, &drbd_bm_write_copy_pages, NULL,\r\n"write from resync_finished", BM_LOCKED_CHANGE_ALLOWED);\r\nput_ldev(device);\r\n}\r\nif (ns.disk == D_DISKLESS &&\r\nns.conn == C_STANDALONE &&\r\nns.role == R_SECONDARY) {\r\nif (os.aftr_isp != ns.aftr_isp)\r\nresume_next_sg(device);\r\n}\r\ndrbd_md_sync(device);\r\n}\r\nstatic int w_after_conn_state_ch(struct drbd_work *w, int unused)\r\n{\r\nstruct after_conn_state_chg_work *acscw =\r\ncontainer_of(w, struct after_conn_state_chg_work, w);\r\nstruct drbd_connection *connection = acscw->connection;\r\nenum drbd_conns oc = acscw->oc;\r\nunion drbd_state ns_max = acscw->ns_max;\r\nstruct drbd_peer_device *peer_device;\r\nint vnr;\r\nkfree(acscw);\r\nif (oc == C_STANDALONE && ns_max.conn == C_UNCONNECTED)\r\ndrbd_thread_start(&connection->receiver);\r\nif (oc == C_DISCONNECTING && ns_max.conn == C_STANDALONE) {\r\nstruct net_conf *old_conf;\r\nmutex_lock(&connection->resource->conf_update);\r\nold_conf = connection->net_conf;\r\nconnection->my_addr_len = 0;\r\nconnection->peer_addr_len = 0;\r\nRCU_INIT_POINTER(connection->net_conf, NULL);\r\nconn_free_crypto(connection);\r\nmutex_unlock(&connection->resource->conf_update);\r\nsynchronize_rcu();\r\nkfree(old_conf);\r\n}\r\nif (ns_max.susp_fen) {\r\nif (ns_max.pdsk <= D_OUTDATED) {\r\nrcu_read_lock();\r\nidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\r\nstruct drbd_device *device = peer_device->device;\r\nif (test_bit(NEW_CUR_UUID, &device->flags)) {\r\ndrbd_uuid_new_current(device);\r\nclear_bit(NEW_CUR_UUID, &device->flags);\r\n}\r\n}\r\nrcu_read_unlock();\r\nspin_lock_irq(&connection->resource->req_lock);\r\n_tl_restart(connection, CONNECTION_LOST_WHILE_PENDING);\r\n_conn_request_state(connection,\r\n(union drbd_state) { { .susp_fen = 1 } },\r\n(union drbd_state) { { .susp_fen = 0 } },\r\nCS_VERBOSE);\r\nspin_unlock_irq(&connection->resource->req_lock);\r\n}\r\n}\r\nkref_put(&connection->kref, drbd_destroy_connection);\r\nconn_md_sync(connection);\r\nreturn 0;\r\n}\r\nstatic void conn_old_common_state(struct drbd_connection *connection, union drbd_state *pcs, enum chg_state_flags *pf)\r\n{\r\nenum chg_state_flags flags = ~0;\r\nstruct drbd_peer_device *peer_device;\r\nint vnr, first_vol = 1;\r\nunion drbd_dev_state os, cs = {\r\n{ .role = R_SECONDARY,\r\n.peer = R_UNKNOWN,\r\n.conn = connection->cstate,\r\n.disk = D_DISKLESS,\r\n.pdsk = D_UNKNOWN,\r\n} };\r\nrcu_read_lock();\r\nidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\r\nstruct drbd_device *device = peer_device->device;\r\nos = device->state;\r\nif (first_vol) {\r\ncs = os;\r\nfirst_vol = 0;\r\ncontinue;\r\n}\r\nif (cs.role != os.role)\r\nflags &= ~CS_DC_ROLE;\r\nif (cs.peer != os.peer)\r\nflags &= ~CS_DC_PEER;\r\nif (cs.conn != os.conn)\r\nflags &= ~CS_DC_CONN;\r\nif (cs.disk != os.disk)\r\nflags &= ~CS_DC_DISK;\r\nif (cs.pdsk != os.pdsk)\r\nflags &= ~CS_DC_PDSK;\r\n}\r\nrcu_read_unlock();\r\n*pf |= CS_DC_MASK;\r\n*pf &= flags;\r\n(*pcs).i = cs.i;\r\n}\r\nstatic enum drbd_state_rv\r\nconn_is_valid_transition(struct drbd_connection *connection, union drbd_state mask, union drbd_state val,\r\nenum chg_state_flags flags)\r\n{\r\nenum drbd_state_rv rv = SS_SUCCESS;\r\nunion drbd_state ns, os;\r\nstruct drbd_peer_device *peer_device;\r\nint vnr;\r\nrcu_read_lock();\r\nidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\r\nstruct drbd_device *device = peer_device->device;\r\nos = drbd_read_state(device);\r\nns = sanitize_state(device, os, apply_mask_val(os, mask, val), NULL);\r\nif (flags & CS_IGN_OUTD_FAIL && ns.disk == D_OUTDATED && os.disk < D_OUTDATED)\r\nns.disk = os.disk;\r\nif (ns.i == os.i)\r\ncontinue;\r\nrv = is_valid_transition(os, ns);\r\nif (rv >= SS_SUCCESS && !(flags & CS_HARD)) {\r\nrv = is_valid_state(device, ns);\r\nif (rv < SS_SUCCESS) {\r\nif (is_valid_state(device, os) == rv)\r\nrv = is_valid_soft_transition(os, ns, connection);\r\n} else\r\nrv = is_valid_soft_transition(os, ns, connection);\r\n}\r\nif (rv < SS_SUCCESS) {\r\nif (flags & CS_VERBOSE)\r\nprint_st_err(device, os, ns, rv);\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn rv;\r\n}\r\nstatic void\r\nconn_set_state(struct drbd_connection *connection, union drbd_state mask, union drbd_state val,\r\nunion drbd_state *pns_min, union drbd_state *pns_max, enum chg_state_flags flags)\r\n{\r\nunion drbd_state ns, os, ns_max = { };\r\nunion drbd_state ns_min = {\r\n{ .role = R_MASK,\r\n.peer = R_MASK,\r\n.conn = val.conn,\r\n.disk = D_MASK,\r\n.pdsk = D_MASK\r\n} };\r\nstruct drbd_peer_device *peer_device;\r\nenum drbd_state_rv rv;\r\nint vnr, number_of_volumes = 0;\r\nif (mask.conn == C_MASK) {\r\nif (connection->cstate != C_WF_REPORT_PARAMS && val.conn == C_WF_REPORT_PARAMS)\r\nconnection->last_reconnect_jif = jiffies;\r\nconnection->cstate = val.conn;\r\n}\r\nrcu_read_lock();\r\nidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\r\nstruct drbd_device *device = peer_device->device;\r\nnumber_of_volumes++;\r\nos = drbd_read_state(device);\r\nns = apply_mask_val(os, mask, val);\r\nns = sanitize_state(device, os, ns, NULL);\r\nif (flags & CS_IGN_OUTD_FAIL && ns.disk == D_OUTDATED && os.disk < D_OUTDATED)\r\nns.disk = os.disk;\r\nrv = __drbd_set_state(device, ns, flags, NULL);\r\nif (rv < SS_SUCCESS)\r\nBUG();\r\nns.i = device->state.i;\r\nns_max.role = max_role(ns.role, ns_max.role);\r\nns_max.peer = max_role(ns.peer, ns_max.peer);\r\nns_max.conn = max_t(enum drbd_conns, ns.conn, ns_max.conn);\r\nns_max.disk = max_t(enum drbd_disk_state, ns.disk, ns_max.disk);\r\nns_max.pdsk = max_t(enum drbd_disk_state, ns.pdsk, ns_max.pdsk);\r\nns_min.role = min_role(ns.role, ns_min.role);\r\nns_min.peer = min_role(ns.peer, ns_min.peer);\r\nns_min.conn = min_t(enum drbd_conns, ns.conn, ns_min.conn);\r\nns_min.disk = min_t(enum drbd_disk_state, ns.disk, ns_min.disk);\r\nns_min.pdsk = min_t(enum drbd_disk_state, ns.pdsk, ns_min.pdsk);\r\n}\r\nrcu_read_unlock();\r\nif (number_of_volumes == 0) {\r\nns_min = ns_max = (union drbd_state) { {\r\n.role = R_SECONDARY,\r\n.peer = R_UNKNOWN,\r\n.conn = val.conn,\r\n.disk = D_DISKLESS,\r\n.pdsk = D_UNKNOWN\r\n} };\r\n}\r\nns_min.susp = ns_max.susp = connection->resource->susp;\r\nns_min.susp_nod = ns_max.susp_nod = connection->resource->susp_nod;\r\nns_min.susp_fen = ns_max.susp_fen = connection->resource->susp_fen;\r\n*pns_min = ns_min;\r\n*pns_max = ns_max;\r\n}\r\nstatic enum drbd_state_rv\r\n_conn_rq_cond(struct drbd_connection *connection, union drbd_state mask, union drbd_state val)\r\n{\r\nenum drbd_state_rv err, rv = SS_UNKNOWN_ERROR; ;\r\nif (test_and_clear_bit(CONN_WD_ST_CHG_OKAY, &connection->flags))\r\nrv = SS_CW_SUCCESS;\r\nif (test_and_clear_bit(CONN_WD_ST_CHG_FAIL, &connection->flags))\r\nrv = SS_CW_FAILED_BY_PEER;\r\nerr = conn_is_valid_transition(connection, mask, val, 0);\r\nif (err == SS_SUCCESS && connection->cstate == C_WF_REPORT_PARAMS)\r\nreturn rv;\r\nreturn err;\r\n}\r\nenum drbd_state_rv\r\n_conn_request_state(struct drbd_connection *connection, union drbd_state mask, union drbd_state val,\r\nenum chg_state_flags flags)\r\n{\r\nenum drbd_state_rv rv = SS_SUCCESS;\r\nstruct after_conn_state_chg_work *acscw;\r\nenum drbd_conns oc = connection->cstate;\r\nunion drbd_state ns_max, ns_min, os;\r\nbool have_mutex = false;\r\nif (mask.conn) {\r\nrv = is_valid_conn_transition(oc, val.conn);\r\nif (rv < SS_SUCCESS)\r\ngoto abort;\r\n}\r\nrv = conn_is_valid_transition(connection, mask, val, flags);\r\nif (rv < SS_SUCCESS)\r\ngoto abort;\r\nif (oc == C_WF_REPORT_PARAMS && val.conn == C_DISCONNECTING &&\r\n!(flags & (CS_LOCAL_ONLY | CS_HARD))) {\r\nspin_unlock_irq(&connection->resource->req_lock);\r\nmutex_lock(&connection->cstate_mutex);\r\nhave_mutex = true;\r\nset_bit(CONN_WD_ST_CHG_REQ, &connection->flags);\r\nif (conn_send_state_req(connection, mask, val)) {\r\nclear_bit(CONN_WD_ST_CHG_REQ, &connection->flags);\r\nrv = SS_CW_FAILED_BY_PEER;\r\ngoto abort_unlocked;\r\n}\r\nif (val.conn == C_DISCONNECTING)\r\nset_bit(DISCONNECT_SENT, &connection->flags);\r\nspin_lock_irq(&connection->resource->req_lock);\r\nwait_event_lock_irq(connection->ping_wait,\r\n(rv = _conn_rq_cond(connection, mask, val)),\r\nconnection->resource->req_lock);\r\nclear_bit(CONN_WD_ST_CHG_REQ, &connection->flags);\r\nif (rv < SS_SUCCESS)\r\ngoto abort;\r\n}\r\nconn_old_common_state(connection, &os, &flags);\r\nflags |= CS_DC_SUSP;\r\nconn_set_state(connection, mask, val, &ns_min, &ns_max, flags);\r\nconn_pr_state_change(connection, os, ns_max, flags);\r\nacscw = kmalloc(sizeof(*acscw), GFP_ATOMIC);\r\nif (acscw) {\r\nacscw->oc = os.conn;\r\nacscw->ns_min = ns_min;\r\nacscw->ns_max = ns_max;\r\nacscw->flags = flags;\r\nacscw->w.cb = w_after_conn_state_ch;\r\nkref_get(&connection->kref);\r\nacscw->connection = connection;\r\ndrbd_queue_work(&connection->sender_work, &acscw->w);\r\n} else {\r\ndrbd_err(connection, "Could not kmalloc an acscw\n");\r\n}\r\nabort:\r\nif (have_mutex) {\r\nspin_unlock_irq(&connection->resource->req_lock);\r\nabort_unlocked:\r\nmutex_unlock(&connection->cstate_mutex);\r\nspin_lock_irq(&connection->resource->req_lock);\r\n}\r\nif (rv < SS_SUCCESS && flags & CS_VERBOSE) {\r\ndrbd_err(connection, "State change failed: %s\n", drbd_set_st_err_str(rv));\r\ndrbd_err(connection, " mask = 0x%x val = 0x%x\n", mask.i, val.i);\r\ndrbd_err(connection, " old_conn:%s wanted_conn:%s\n", drbd_conn_str(oc), drbd_conn_str(val.conn));\r\n}\r\nreturn rv;\r\n}\r\nenum drbd_state_rv\r\nconn_request_state(struct drbd_connection *connection, union drbd_state mask, union drbd_state val,\r\nenum chg_state_flags flags)\r\n{\r\nenum drbd_state_rv rv;\r\nspin_lock_irq(&connection->resource->req_lock);\r\nrv = _conn_request_state(connection, mask, val, flags);\r\nspin_unlock_irq(&connection->resource->req_lock);\r\nreturn rv;\r\n}
