static void drbd_adm_send_reply(struct sk_buff *skb, struct genl_info *info)\r\n{\r\ngenlmsg_end(skb, genlmsg_data(nlmsg_data(nlmsg_hdr(skb))));\r\nif (genlmsg_reply(skb, info))\r\npr_err("error sending genl reply\n");\r\n}\r\nstatic int drbd_msg_put_info(struct sk_buff *skb, const char *info)\r\n{\r\nstruct nlattr *nla;\r\nint err = -EMSGSIZE;\r\nif (!info || !info[0])\r\nreturn 0;\r\nnla = nla_nest_start(skb, DRBD_NLA_CFG_REPLY);\r\nif (!nla)\r\nreturn err;\r\nerr = nla_put_string(skb, T_info_text, info);\r\nif (err) {\r\nnla_nest_cancel(skb, nla);\r\nreturn err;\r\n} else\r\nnla_nest_end(skb, nla);\r\nreturn 0;\r\n}\r\nstatic int drbd_adm_prepare(struct drbd_config_context *adm_ctx,\r\nstruct sk_buff *skb, struct genl_info *info, unsigned flags)\r\n{\r\nstruct drbd_genlmsghdr *d_in = info->userhdr;\r\nconst u8 cmd = info->genlhdr->cmd;\r\nint err;\r\nmemset(adm_ctx, 0, sizeof(*adm_ctx));\r\nif (cmd != DRBD_ADM_GET_STATUS && !capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nadm_ctx->reply_skb = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\r\nif (!adm_ctx->reply_skb) {\r\nerr = -ENOMEM;\r\ngoto fail;\r\n}\r\nadm_ctx->reply_dh = genlmsg_put_reply(adm_ctx->reply_skb,\r\ninfo, &drbd_genl_family, 0, cmd);\r\nif (!adm_ctx->reply_dh) {\r\nerr = -ENOMEM;\r\ngoto fail;\r\n}\r\nadm_ctx->reply_dh->minor = d_in->minor;\r\nadm_ctx->reply_dh->ret_code = NO_ERROR;\r\nadm_ctx->volume = VOLUME_UNSPECIFIED;\r\nif (info->attrs[DRBD_NLA_CFG_CONTEXT]) {\r\nstruct nlattr *nla;\r\nerr = drbd_cfg_context_from_attrs(NULL, info);\r\nif (err)\r\ngoto fail;\r\nerr = nla_put_nohdr(adm_ctx->reply_skb,\r\ninfo->attrs[DRBD_NLA_CFG_CONTEXT]->nla_len,\r\ninfo->attrs[DRBD_NLA_CFG_CONTEXT]);\r\nif (err)\r\ngoto fail;\r\nnla = nested_attr_tb[__nla_type(T_ctx_volume)];\r\nif (nla)\r\nadm_ctx->volume = nla_get_u32(nla);\r\nnla = nested_attr_tb[__nla_type(T_ctx_resource_name)];\r\nif (nla)\r\nadm_ctx->resource_name = nla_data(nla);\r\nadm_ctx->my_addr = nested_attr_tb[__nla_type(T_ctx_my_addr)];\r\nadm_ctx->peer_addr = nested_attr_tb[__nla_type(T_ctx_peer_addr)];\r\nif ((adm_ctx->my_addr &&\r\nnla_len(adm_ctx->my_addr) > sizeof(adm_ctx->connection->my_addr)) ||\r\n(adm_ctx->peer_addr &&\r\nnla_len(adm_ctx->peer_addr) > sizeof(adm_ctx->connection->peer_addr))) {\r\nerr = -EINVAL;\r\ngoto fail;\r\n}\r\n}\r\nadm_ctx->minor = d_in->minor;\r\nadm_ctx->device = minor_to_device(d_in->minor);\r\nif (adm_ctx->device)\r\nkref_get(&adm_ctx->device->kref);\r\nif (adm_ctx->resource_name) {\r\nadm_ctx->resource = drbd_find_resource(adm_ctx->resource_name);\r\n}\r\nif (!adm_ctx->device && (flags & DRBD_ADM_NEED_MINOR)) {\r\ndrbd_msg_put_info(adm_ctx->reply_skb, "unknown minor");\r\nreturn ERR_MINOR_INVALID;\r\n}\r\nif (!adm_ctx->resource && (flags & DRBD_ADM_NEED_RESOURCE)) {\r\ndrbd_msg_put_info(adm_ctx->reply_skb, "unknown resource");\r\nif (adm_ctx->resource_name)\r\nreturn ERR_RES_NOT_KNOWN;\r\nreturn ERR_INVALID_REQUEST;\r\n}\r\nif (flags & DRBD_ADM_NEED_CONNECTION) {\r\nif (adm_ctx->resource) {\r\ndrbd_msg_put_info(adm_ctx->reply_skb, "no resource name expected");\r\nreturn ERR_INVALID_REQUEST;\r\n}\r\nif (adm_ctx->device) {\r\ndrbd_msg_put_info(adm_ctx->reply_skb, "no minor number expected");\r\nreturn ERR_INVALID_REQUEST;\r\n}\r\nif (adm_ctx->my_addr && adm_ctx->peer_addr)\r\nadm_ctx->connection = conn_get_by_addrs(nla_data(adm_ctx->my_addr),\r\nnla_len(adm_ctx->my_addr),\r\nnla_data(adm_ctx->peer_addr),\r\nnla_len(adm_ctx->peer_addr));\r\nif (!adm_ctx->connection) {\r\ndrbd_msg_put_info(adm_ctx->reply_skb, "unknown connection");\r\nreturn ERR_INVALID_REQUEST;\r\n}\r\n}\r\nif (adm_ctx->device && adm_ctx->resource &&\r\nadm_ctx->device->resource != adm_ctx->resource) {\r\npr_warning("request: minor=%u, resource=%s; but that minor belongs to resource %s\n",\r\nadm_ctx->minor, adm_ctx->resource->name,\r\nadm_ctx->device->resource->name);\r\ndrbd_msg_put_info(adm_ctx->reply_skb, "minor exists in different resource");\r\nreturn ERR_INVALID_REQUEST;\r\n}\r\nif (adm_ctx->device &&\r\nadm_ctx->volume != VOLUME_UNSPECIFIED &&\r\nadm_ctx->volume != adm_ctx->device->vnr) {\r\npr_warning("request: minor=%u, volume=%u; but that minor is volume %u in %s\n",\r\nadm_ctx->minor, adm_ctx->volume,\r\nadm_ctx->device->vnr,\r\nadm_ctx->device->resource->name);\r\ndrbd_msg_put_info(adm_ctx->reply_skb, "minor exists as different volume");\r\nreturn ERR_INVALID_REQUEST;\r\n}\r\nif (!adm_ctx->resource) {\r\nadm_ctx->resource = adm_ctx->device ? adm_ctx->device->resource\r\n: adm_ctx->connection ? adm_ctx->connection->resource : NULL;\r\nif (adm_ctx->resource)\r\nkref_get(&adm_ctx->resource->kref);\r\n}\r\nreturn NO_ERROR;\r\nfail:\r\nnlmsg_free(adm_ctx->reply_skb);\r\nadm_ctx->reply_skb = NULL;\r\nreturn err;\r\n}\r\nstatic int drbd_adm_finish(struct drbd_config_context *adm_ctx,\r\nstruct genl_info *info, int retcode)\r\n{\r\nif (adm_ctx->device) {\r\nkref_put(&adm_ctx->device->kref, drbd_destroy_device);\r\nadm_ctx->device = NULL;\r\n}\r\nif (adm_ctx->connection) {\r\nkref_put(&adm_ctx->connection->kref, &drbd_destroy_connection);\r\nadm_ctx->connection = NULL;\r\n}\r\nif (adm_ctx->resource) {\r\nkref_put(&adm_ctx->resource->kref, drbd_destroy_resource);\r\nadm_ctx->resource = NULL;\r\n}\r\nif (!adm_ctx->reply_skb)\r\nreturn -ENOMEM;\r\nadm_ctx->reply_dh->ret_code = retcode;\r\ndrbd_adm_send_reply(adm_ctx->reply_skb, info);\r\nreturn 0;\r\n}\r\nstatic void setup_khelper_env(struct drbd_connection *connection, char **envp)\r\n{\r\nchar *afs;\r\nif (connection->my_addr_len == 0 || connection->peer_addr_len == 0)\r\nreturn;\r\nswitch (((struct sockaddr *)&connection->peer_addr)->sa_family) {\r\ncase AF_INET6:\r\nafs = "ipv6";\r\nsnprintf(envp[4], 60, "DRBD_PEER_ADDRESS=%pI6",\r\n&((struct sockaddr_in6 *)&connection->peer_addr)->sin6_addr);\r\nbreak;\r\ncase AF_INET:\r\nafs = "ipv4";\r\nsnprintf(envp[4], 60, "DRBD_PEER_ADDRESS=%pI4",\r\n&((struct sockaddr_in *)&connection->peer_addr)->sin_addr);\r\nbreak;\r\ndefault:\r\nafs = "ssocks";\r\nsnprintf(envp[4], 60, "DRBD_PEER_ADDRESS=%pI4",\r\n&((struct sockaddr_in *)&connection->peer_addr)->sin_addr);\r\n}\r\nsnprintf(envp[3], 20, "DRBD_PEER_AF=%s", afs);\r\n}\r\nint drbd_khelper(struct drbd_device *device, char *cmd)\r\n{\r\nchar *envp[] = { "HOME=/",\r\n"TERM=linux",\r\n"PATH=/sbin:/usr/sbin:/bin:/usr/bin",\r\n(char[20]) { },\r\n(char[60]) { },\r\nNULL };\r\nchar mb[12];\r\nchar *argv[] = {usermode_helper, cmd, mb, NULL };\r\nstruct drbd_connection *connection = first_peer_device(device)->connection;\r\nstruct sib_info sib;\r\nint ret;\r\nif (current == connection->worker.task)\r\nset_bit(CALLBACK_PENDING, &connection->flags);\r\nsnprintf(mb, 12, "minor-%d", device_to_minor(device));\r\nsetup_khelper_env(connection, envp);\r\ndrbd_md_sync(device);\r\ndrbd_info(device, "helper command: %s %s %s\n", usermode_helper, cmd, mb);\r\nsib.sib_reason = SIB_HELPER_PRE;\r\nsib.helper_name = cmd;\r\ndrbd_bcast_event(device, &sib);\r\nret = call_usermodehelper(usermode_helper, argv, envp, UMH_WAIT_PROC);\r\nif (ret)\r\ndrbd_warn(device, "helper command: %s %s %s exit code %u (0x%x)\n",\r\nusermode_helper, cmd, mb,\r\n(ret >> 8) & 0xff, ret);\r\nelse\r\ndrbd_info(device, "helper command: %s %s %s exit code %u (0x%x)\n",\r\nusermode_helper, cmd, mb,\r\n(ret >> 8) & 0xff, ret);\r\nsib.sib_reason = SIB_HELPER_POST;\r\nsib.helper_exit_code = ret;\r\ndrbd_bcast_event(device, &sib);\r\nif (current == connection->worker.task)\r\nclear_bit(CALLBACK_PENDING, &connection->flags);\r\nif (ret < 0)\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic int conn_khelper(struct drbd_connection *connection, char *cmd)\r\n{\r\nchar *envp[] = { "HOME=/",\r\n"TERM=linux",\r\n"PATH=/sbin:/usr/sbin:/bin:/usr/bin",\r\n(char[20]) { },\r\n(char[60]) { },\r\nNULL };\r\nchar *resource_name = connection->resource->name;\r\nchar *argv[] = {usermode_helper, cmd, resource_name, NULL };\r\nint ret;\r\nsetup_khelper_env(connection, envp);\r\nconn_md_sync(connection);\r\ndrbd_info(connection, "helper command: %s %s %s\n", usermode_helper, cmd, resource_name);\r\nret = call_usermodehelper(usermode_helper, argv, envp, UMH_WAIT_PROC);\r\nif (ret)\r\ndrbd_warn(connection, "helper command: %s %s %s exit code %u (0x%x)\n",\r\nusermode_helper, cmd, resource_name,\r\n(ret >> 8) & 0xff, ret);\r\nelse\r\ndrbd_info(connection, "helper command: %s %s %s exit code %u (0x%x)\n",\r\nusermode_helper, cmd, resource_name,\r\n(ret >> 8) & 0xff, ret);\r\nif (ret < 0)\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic enum drbd_fencing_p highest_fencing_policy(struct drbd_connection *connection)\r\n{\r\nenum drbd_fencing_p fp = FP_NOT_AVAIL;\r\nstruct drbd_peer_device *peer_device;\r\nint vnr;\r\nrcu_read_lock();\r\nidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\r\nstruct drbd_device *device = peer_device->device;\r\nif (get_ldev_if_state(device, D_CONSISTENT)) {\r\nstruct disk_conf *disk_conf =\r\nrcu_dereference(peer_device->device->ldev->disk_conf);\r\nfp = max_t(enum drbd_fencing_p, fp, disk_conf->fencing);\r\nput_ldev(device);\r\n}\r\n}\r\nrcu_read_unlock();\r\nif (fp == FP_NOT_AVAIL) {\r\nvnr = 0;\r\npeer_device = idr_get_next(&connection->peer_devices, &vnr);\r\ndrbd_change_state(peer_device->device, CS_VERBOSE | CS_HARD, NS(susp_fen, 0));\r\n}\r\nreturn fp;\r\n}\r\nbool conn_try_outdate_peer(struct drbd_connection *connection)\r\n{\r\nunsigned int connect_cnt;\r\nunion drbd_state mask = { };\r\nunion drbd_state val = { };\r\nenum drbd_fencing_p fp;\r\nchar *ex_to_string;\r\nint r;\r\nspin_lock_irq(&connection->resource->req_lock);\r\nif (connection->cstate >= C_WF_REPORT_PARAMS) {\r\ndrbd_err(connection, "Expected cstate < C_WF_REPORT_PARAMS\n");\r\nspin_unlock_irq(&connection->resource->req_lock);\r\nreturn false;\r\n}\r\nconnect_cnt = connection->connect_cnt;\r\nspin_unlock_irq(&connection->resource->req_lock);\r\nfp = highest_fencing_policy(connection);\r\nswitch (fp) {\r\ncase FP_NOT_AVAIL:\r\ndrbd_warn(connection, "Not fencing peer, I'm not even Consistent myself.\n");\r\ngoto out;\r\ncase FP_DONT_CARE:\r\nreturn true;\r\ndefault: ;\r\n}\r\nr = conn_khelper(connection, "fence-peer");\r\nswitch ((r>>8) & 0xff) {\r\ncase 3:\r\nex_to_string = "peer is inconsistent or worse";\r\nmask.pdsk = D_MASK;\r\nval.pdsk = D_INCONSISTENT;\r\nbreak;\r\ncase 4:\r\nex_to_string = "peer was fenced";\r\nmask.pdsk = D_MASK;\r\nval.pdsk = D_OUTDATED;\r\nbreak;\r\ncase 5:\r\nif (conn_highest_disk(connection) == D_UP_TO_DATE) {\r\nex_to_string = "peer is unreachable, assumed to be dead";\r\nmask.pdsk = D_MASK;\r\nval.pdsk = D_OUTDATED;\r\n} else {\r\nex_to_string = "peer unreachable, doing nothing since disk != UpToDate";\r\n}\r\nbreak;\r\ncase 6:\r\nex_to_string = "peer is active";\r\ndrbd_warn(connection, "Peer is primary, outdating myself.\n");\r\nmask.disk = D_MASK;\r\nval.disk = D_OUTDATED;\r\nbreak;\r\ncase 7:\r\nif (fp != FP_STONITH)\r\ndrbd_err(connection, "fence-peer() = 7 && fencing != Stonith !!!\n");\r\nex_to_string = "peer was stonithed";\r\nmask.pdsk = D_MASK;\r\nval.pdsk = D_OUTDATED;\r\nbreak;\r\ndefault:\r\ndrbd_err(connection, "fence-peer helper broken, returned %d\n", (r>>8)&0xff);\r\nreturn false;\r\n}\r\ndrbd_info(connection, "fence-peer helper returned %d (%s)\n",\r\n(r>>8) & 0xff, ex_to_string);\r\nout:\r\nspin_lock_irq(&connection->resource->req_lock);\r\nif (connection->cstate < C_WF_REPORT_PARAMS && !test_bit(STATE_SENT, &connection->flags)) {\r\nif (connection->connect_cnt != connect_cnt)\r\ndrbd_info(connection, "Ignoring fence-peer exit code\n");\r\nelse\r\n_conn_request_state(connection, mask, val, CS_VERBOSE);\r\n}\r\nspin_unlock_irq(&connection->resource->req_lock);\r\nreturn conn_highest_pdsk(connection) <= D_OUTDATED;\r\n}\r\nstatic int _try_outdate_peer_async(void *data)\r\n{\r\nstruct drbd_connection *connection = (struct drbd_connection *)data;\r\nconn_try_outdate_peer(connection);\r\nkref_put(&connection->kref, drbd_destroy_connection);\r\nreturn 0;\r\n}\r\nvoid conn_try_outdate_peer_async(struct drbd_connection *connection)\r\n{\r\nstruct task_struct *opa;\r\nkref_get(&connection->kref);\r\nflush_signals(current);\r\nopa = kthread_run(_try_outdate_peer_async, connection, "drbd_async_h");\r\nif (IS_ERR(opa)) {\r\ndrbd_err(connection, "out of mem, failed to invoke fence-peer helper\n");\r\nkref_put(&connection->kref, drbd_destroy_connection);\r\n}\r\n}\r\nenum drbd_state_rv\r\ndrbd_set_role(struct drbd_device *const device, enum drbd_role new_role, int force)\r\n{\r\nstruct drbd_peer_device *const peer_device = first_peer_device(device);\r\nstruct drbd_connection *const connection = peer_device ? peer_device->connection : NULL;\r\nconst int max_tries = 4;\r\nenum drbd_state_rv rv = SS_UNKNOWN_ERROR;\r\nstruct net_conf *nc;\r\nint try = 0;\r\nint forced = 0;\r\nunion drbd_state mask, val;\r\nif (new_role == R_PRIMARY) {\r\nstruct drbd_connection *connection;\r\nrcu_read_lock();\r\nfor_each_connection(connection, device->resource)\r\nrequest_ping(connection);\r\nrcu_read_unlock();\r\n}\r\nmutex_lock(device->state_mutex);\r\nmask.i = 0; mask.role = R_MASK;\r\nval.i = 0; val.role = new_role;\r\nwhile (try++ < max_tries) {\r\nrv = _drbd_request_state_holding_state_mutex(device, mask, val, CS_WAIT_COMPLETE);\r\nif (rv == SS_CW_FAILED_BY_PEER && mask.pdsk != 0) {\r\nval.pdsk = 0;\r\nmask.pdsk = 0;\r\ncontinue;\r\n}\r\nif (rv == SS_NO_UP_TO_DATE_DISK && force &&\r\n(device->state.disk < D_UP_TO_DATE &&\r\ndevice->state.disk >= D_INCONSISTENT)) {\r\nmask.disk = D_MASK;\r\nval.disk = D_UP_TO_DATE;\r\nforced = 1;\r\ncontinue;\r\n}\r\nif (rv == SS_NO_UP_TO_DATE_DISK &&\r\ndevice->state.disk == D_CONSISTENT && mask.pdsk == 0) {\r\nD_ASSERT(device, device->state.pdsk == D_UNKNOWN);\r\nif (conn_try_outdate_peer(connection)) {\r\nval.disk = D_UP_TO_DATE;\r\nmask.disk = D_MASK;\r\n}\r\ncontinue;\r\n}\r\nif (rv == SS_NOTHING_TO_DO)\r\ngoto out;\r\nif (rv == SS_PRIMARY_NOP && mask.pdsk == 0) {\r\nif (!conn_try_outdate_peer(connection) && force) {\r\ndrbd_warn(device, "Forced into split brain situation!\n");\r\nmask.pdsk = D_MASK;\r\nval.pdsk = D_OUTDATED;\r\n}\r\ncontinue;\r\n}\r\nif (rv == SS_TWO_PRIMARIES) {\r\nint timeo;\r\nrcu_read_lock();\r\nnc = rcu_dereference(connection->net_conf);\r\ntimeo = nc ? (nc->ping_timeo + 1) * HZ / 10 : 1;\r\nrcu_read_unlock();\r\nschedule_timeout_interruptible(timeo);\r\nif (try < max_tries)\r\ntry = max_tries - 1;\r\ncontinue;\r\n}\r\nif (rv < SS_SUCCESS) {\r\nrv = _drbd_request_state(device, mask, val,\r\nCS_VERBOSE + CS_WAIT_COMPLETE);\r\nif (rv < SS_SUCCESS)\r\ngoto out;\r\n}\r\nbreak;\r\n}\r\nif (rv < SS_SUCCESS)\r\ngoto out;\r\nif (forced)\r\ndrbd_warn(device, "Forced to consider local data as UpToDate!\n");\r\nwait_event(device->misc_wait, atomic_read(&device->ap_pending_cnt) == 0);\r\nif (new_role == R_SECONDARY) {\r\nif (get_ldev(device)) {\r\ndevice->ldev->md.uuid[UI_CURRENT] &= ~(u64)1;\r\nput_ldev(device);\r\n}\r\n} else {\r\nmutex_lock(&device->resource->conf_update);\r\nnc = connection->net_conf;\r\nif (nc)\r\nnc->discard_my_data = 0;\r\nmutex_unlock(&device->resource->conf_update);\r\nif (get_ldev(device)) {\r\nif (((device->state.conn < C_CONNECTED ||\r\ndevice->state.pdsk <= D_FAILED)\r\n&& device->ldev->md.uuid[UI_BITMAP] == 0) || forced)\r\ndrbd_uuid_new_current(device);\r\ndevice->ldev->md.uuid[UI_CURRENT] |= (u64)1;\r\nput_ldev(device);\r\n}\r\n}\r\nif (device->state.conn >= C_WF_REPORT_PARAMS) {\r\nif (forced)\r\ndrbd_send_uuids(peer_device);\r\ndrbd_send_current_state(peer_device);\r\n}\r\ndrbd_md_sync(device);\r\nset_disk_ro(device->vdisk, new_role == R_SECONDARY);\r\nkobject_uevent(&disk_to_dev(device->vdisk)->kobj, KOBJ_CHANGE);\r\nout:\r\nmutex_unlock(device->state_mutex);\r\nreturn rv;\r\n}\r\nstatic const char *from_attrs_err_to_txt(int err)\r\n{\r\nreturn err == -ENOMSG ? "required attribute missing" :\r\nerr == -EOPNOTSUPP ? "unknown mandatory attribute" :\r\nerr == -EEXIST ? "can not change invariant setting" :\r\n"invalid attribute value";\r\n}\r\nint drbd_adm_set_role(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct drbd_config_context adm_ctx;\r\nstruct set_role_parms parms;\r\nint err;\r\nenum drbd_ret_code retcode;\r\nretcode = drbd_adm_prepare(&adm_ctx, skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\nmemset(&parms, 0, sizeof(parms));\r\nif (info->attrs[DRBD_NLA_SET_ROLE_PARMS]) {\r\nerr = set_role_parms_from_attrs(&parms, info);\r\nif (err) {\r\nretcode = ERR_MANDATORY_TAG;\r\ndrbd_msg_put_info(adm_ctx.reply_skb, from_attrs_err_to_txt(err));\r\ngoto out;\r\n}\r\n}\r\ngenl_unlock();\r\nmutex_lock(&adm_ctx.resource->adm_mutex);\r\nif (info->genlhdr->cmd == DRBD_ADM_PRIMARY)\r\nretcode = drbd_set_role(adm_ctx.device, R_PRIMARY, parms.assume_uptodate);\r\nelse\r\nretcode = drbd_set_role(adm_ctx.device, R_SECONDARY, 0);\r\nmutex_unlock(&adm_ctx.resource->adm_mutex);\r\ngenl_lock();\r\nout:\r\ndrbd_adm_finish(&adm_ctx, info, retcode);\r\nreturn 0;\r\n}\r\nstatic void drbd_md_set_sector_offsets(struct drbd_device *device,\r\nstruct drbd_backing_dev *bdev)\r\n{\r\nsector_t md_size_sect = 0;\r\nunsigned int al_size_sect = bdev->md.al_size_4k * 8;\r\nbdev->md.md_offset = drbd_md_ss(bdev);\r\nswitch (bdev->md.meta_dev_idx) {\r\ndefault:\r\nbdev->md.md_size_sect = MD_128MB_SECT;\r\nbdev->md.al_offset = MD_4kB_SECT;\r\nbdev->md.bm_offset = MD_4kB_SECT + al_size_sect;\r\nbreak;\r\ncase DRBD_MD_INDEX_FLEX_EXT:\r\nbdev->md.md_size_sect = drbd_get_capacity(bdev->md_bdev);\r\nbdev->md.al_offset = MD_4kB_SECT;\r\nbdev->md.bm_offset = MD_4kB_SECT + al_size_sect;\r\nbreak;\r\ncase DRBD_MD_INDEX_INTERNAL:\r\ncase DRBD_MD_INDEX_FLEX_INT:\r\nbdev->md.al_offset = -al_size_sect;\r\nmd_size_sect = drbd_get_capacity(bdev->backing_bdev);\r\nmd_size_sect = ALIGN(md_size_sect, BM_SECT_PER_EXT);\r\nmd_size_sect = BM_SECT_TO_EXT(md_size_sect);\r\nmd_size_sect = ALIGN(md_size_sect, 8);\r\nmd_size_sect += MD_4kB_SECT + al_size_sect;\r\nbdev->md.md_size_sect = md_size_sect;\r\nbdev->md.bm_offset = -md_size_sect + MD_4kB_SECT;\r\nbreak;\r\n}\r\n}\r\nchar *ppsize(char *buf, unsigned long long size)\r\n{\r\nstatic char units[] = { 'K', 'M', 'G', 'T', 'P', 'E' };\r\nint base = 0;\r\nwhile (size >= 10000 && base < sizeof(units)-1) {\r\nsize = (size >> 10) + !!(size & (1<<9));\r\nbase++;\r\n}\r\nsprintf(buf, "%u %cB", (unsigned)size, units[base]);\r\nreturn buf;\r\n}\r\nvoid drbd_suspend_io(struct drbd_device *device)\r\n{\r\nset_bit(SUSPEND_IO, &device->flags);\r\nif (drbd_suspended(device))\r\nreturn;\r\nwait_event(device->misc_wait, !atomic_read(&device->ap_bio_cnt));\r\n}\r\nvoid drbd_resume_io(struct drbd_device *device)\r\n{\r\nclear_bit(SUSPEND_IO, &device->flags);\r\nwake_up(&device->misc_wait);\r\n}\r\nenum determine_dev_size\r\ndrbd_determine_dev_size(struct drbd_device *device, enum dds_flags flags, struct resize_parms *rs) __must_hold(local)\r\n{\r\nsector_t prev_first_sect, prev_size;\r\nsector_t la_size_sect, u_size;\r\nstruct drbd_md *md = &device->ldev->md;\r\nu32 prev_al_stripe_size_4k;\r\nu32 prev_al_stripes;\r\nsector_t size;\r\nchar ppb[10];\r\nvoid *buffer;\r\nint md_moved, la_size_changed;\r\nenum determine_dev_size rv = DS_UNCHANGED;\r\ndrbd_suspend_io(device);\r\nbuffer = drbd_md_get_buffer(device, __func__);\r\nif (!buffer) {\r\ndrbd_resume_io(device);\r\nreturn DS_ERROR;\r\n}\r\nwait_event(device->al_wait, lc_try_lock(device->act_log));\r\nprev_first_sect = drbd_md_first_sector(device->ldev);\r\nprev_size = device->ldev->md.md_size_sect;\r\nla_size_sect = device->ldev->md.la_size_sect;\r\nif (rs) {\r\nprev_al_stripes = md->al_stripes;\r\nprev_al_stripe_size_4k = md->al_stripe_size_4k;\r\nmd->al_stripes = rs->al_stripes;\r\nmd->al_stripe_size_4k = rs->al_stripe_size / 4;\r\nmd->al_size_4k = (u64)rs->al_stripes * rs->al_stripe_size / 4;\r\n}\r\ndrbd_md_set_sector_offsets(device, device->ldev);\r\nrcu_read_lock();\r\nu_size = rcu_dereference(device->ldev->disk_conf)->disk_size;\r\nrcu_read_unlock();\r\nsize = drbd_new_dev_size(device, device->ldev, u_size, flags & DDSF_FORCED);\r\nif (size < la_size_sect) {\r\nif (rs && u_size == 0) {\r\ndrbd_warn(device, "Implicit shrink not allowed. "\r\n"Use --size=%llus for explicit shrink.\n",\r\n(unsigned long long)size);\r\nrv = DS_ERROR_SHRINK;\r\n}\r\nif (u_size > size)\r\nrv = DS_ERROR_SPACE_MD;\r\nif (rv != DS_UNCHANGED)\r\ngoto err_out;\r\n}\r\nif (drbd_get_capacity(device->this_bdev) != size ||\r\ndrbd_bm_capacity(device) != size) {\r\nint err;\r\nerr = drbd_bm_resize(device, size, !(flags & DDSF_NO_RESYNC));\r\nif (unlikely(err)) {\r\nsize = drbd_bm_capacity(device)>>1;\r\nif (size == 0) {\r\ndrbd_err(device, "OUT OF MEMORY! "\r\n"Could not allocate bitmap!\n");\r\n} else {\r\ndrbd_err(device, "BM resizing failed. "\r\n"Leaving size unchanged at size = %lu KB\n",\r\n(unsigned long)size);\r\n}\r\nrv = DS_ERROR;\r\n}\r\ndrbd_set_my_capacity(device, size);\r\ndevice->ldev->md.la_size_sect = size;\r\ndrbd_info(device, "size = %s (%llu KB)\n", ppsize(ppb, size>>1),\r\n(unsigned long long)size>>1);\r\n}\r\nif (rv <= DS_ERROR)\r\ngoto err_out;\r\nla_size_changed = (la_size_sect != device->ldev->md.la_size_sect);\r\nmd_moved = prev_first_sect != drbd_md_first_sector(device->ldev)\r\n|| prev_size != device->ldev->md.md_size_sect;\r\nif (la_size_changed || md_moved || rs) {\r\nu32 prev_flags;\r\ndel_timer(&device->md_sync_timer);\r\ndrbd_al_shrink(device);\r\nprev_flags = md->flags;\r\nmd->flags &= ~MDF_PRIMARY_IND;\r\ndrbd_md_write(device, buffer);\r\ndrbd_info(device, "Writing the whole bitmap, %s\n",\r\nla_size_changed && md_moved ? "size changed and md moved" :\r\nla_size_changed ? "size changed" : "md moved");\r\ndrbd_bitmap_io(device, md_moved ? &drbd_bm_write_all : &drbd_bm_write,\r\n"size changed", BM_LOCKED_MASK);\r\ndrbd_initialize_al(device, buffer);\r\nmd->flags = prev_flags;\r\ndrbd_md_write(device, buffer);\r\nif (rs)\r\ndrbd_info(device, "Changed AL layout to al-stripes = %d, al-stripe-size-kB = %d\n",\r\nmd->al_stripes, md->al_stripe_size_4k * 4);\r\n}\r\nif (size > la_size_sect)\r\nrv = la_size_sect ? DS_GREW : DS_GREW_FROM_ZERO;\r\nif (size < la_size_sect)\r\nrv = DS_SHRUNK;\r\nif (0) {\r\nerr_out:\r\nif (rs) {\r\nmd->al_stripes = prev_al_stripes;\r\nmd->al_stripe_size_4k = prev_al_stripe_size_4k;\r\nmd->al_size_4k = (u64)prev_al_stripes * prev_al_stripe_size_4k;\r\ndrbd_md_set_sector_offsets(device, device->ldev);\r\n}\r\n}\r\nlc_unlock(device->act_log);\r\nwake_up(&device->al_wait);\r\ndrbd_md_put_buffer(device);\r\ndrbd_resume_io(device);\r\nreturn rv;\r\n}\r\nsector_t\r\ndrbd_new_dev_size(struct drbd_device *device, struct drbd_backing_dev *bdev,\r\nsector_t u_size, int assume_peer_has_space)\r\n{\r\nsector_t p_size = device->p_size;\r\nsector_t la_size_sect = bdev->md.la_size_sect;\r\nsector_t m_size;\r\nsector_t size = 0;\r\nm_size = drbd_get_max_capacity(bdev);\r\nif (device->state.conn < C_CONNECTED && assume_peer_has_space) {\r\ndrbd_warn(device, "Resize while not connected was forced by the user!\n");\r\np_size = m_size;\r\n}\r\nif (p_size && m_size) {\r\nsize = min_t(sector_t, p_size, m_size);\r\n} else {\r\nif (la_size_sect) {\r\nsize = la_size_sect;\r\nif (m_size && m_size < size)\r\nsize = m_size;\r\nif (p_size && p_size < size)\r\nsize = p_size;\r\n} else {\r\nif (m_size)\r\nsize = m_size;\r\nif (p_size)\r\nsize = p_size;\r\n}\r\n}\r\nif (size == 0)\r\ndrbd_err(device, "Both nodes diskless!\n");\r\nif (u_size) {\r\nif (u_size > size)\r\ndrbd_err(device, "Requested disk size is too big (%lu > %lu)\n",\r\n(unsigned long)u_size>>1, (unsigned long)size>>1);\r\nelse\r\nsize = u_size;\r\n}\r\nreturn size;\r\n}\r\nstatic int drbd_check_al_size(struct drbd_device *device, struct disk_conf *dc)\r\n{\r\nstruct lru_cache *n, *t;\r\nstruct lc_element *e;\r\nunsigned int in_use;\r\nint i;\r\nif (device->act_log &&\r\ndevice->act_log->nr_elements == dc->al_extents)\r\nreturn 0;\r\nin_use = 0;\r\nt = device->act_log;\r\nn = lc_create("act_log", drbd_al_ext_cache, AL_UPDATES_PER_TRANSACTION,\r\ndc->al_extents, sizeof(struct lc_element), 0);\r\nif (n == NULL) {\r\ndrbd_err(device, "Cannot allocate act_log lru!\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_irq(&device->al_lock);\r\nif (t) {\r\nfor (i = 0; i < t->nr_elements; i++) {\r\ne = lc_element_by_index(t, i);\r\nif (e->refcnt)\r\ndrbd_err(device, "refcnt(%d)==%d\n",\r\ne->lc_number, e->refcnt);\r\nin_use += e->refcnt;\r\n}\r\n}\r\nif (!in_use)\r\ndevice->act_log = n;\r\nspin_unlock_irq(&device->al_lock);\r\nif (in_use) {\r\ndrbd_err(device, "Activity log still in use!\n");\r\nlc_destroy(n);\r\nreturn -EBUSY;\r\n} else {\r\nif (t)\r\nlc_destroy(t);\r\n}\r\ndrbd_md_mark_dirty(device);\r\nreturn 0;\r\n}\r\nstatic void drbd_setup_queue_param(struct drbd_device *device, struct drbd_backing_dev *bdev,\r\nunsigned int max_bio_size)\r\n{\r\nstruct request_queue * const q = device->rq_queue;\r\nunsigned int max_hw_sectors = max_bio_size >> 9;\r\nunsigned int max_segments = 0;\r\nstruct request_queue *b = NULL;\r\nif (bdev) {\r\nb = bdev->backing_bdev->bd_disk->queue;\r\nmax_hw_sectors = min(queue_max_hw_sectors(b), max_bio_size >> 9);\r\nrcu_read_lock();\r\nmax_segments = rcu_dereference(device->ldev->disk_conf)->max_bio_bvecs;\r\nrcu_read_unlock();\r\nblk_set_stacking_limits(&q->limits);\r\nblk_queue_max_write_same_sectors(q, 0);\r\n}\r\nblk_queue_logical_block_size(q, 512);\r\nblk_queue_max_hw_sectors(q, max_hw_sectors);\r\nblk_queue_max_segments(q, max_segments ? max_segments : BLK_MAX_SEGMENTS);\r\nblk_queue_segment_boundary(q, PAGE_CACHE_SIZE-1);\r\nif (b) {\r\nstruct drbd_connection *connection = first_peer_device(device)->connection;\r\nif (blk_queue_discard(b) &&\r\n(connection->cstate < C_CONNECTED || connection->agreed_features & FF_TRIM)) {\r\nq->limits.max_discard_sectors = DRBD_MAX_DISCARD_SECTORS;\r\nqueue_flag_set_unlocked(QUEUE_FLAG_DISCARD, q);\r\nif (blk_queue_secdiscard(b))\r\nqueue_flag_set_unlocked(QUEUE_FLAG_SECDISCARD, q);\r\n} else {\r\nq->limits.max_discard_sectors = 0;\r\nqueue_flag_clear_unlocked(QUEUE_FLAG_DISCARD, q);\r\nqueue_flag_clear_unlocked(QUEUE_FLAG_SECDISCARD, q);\r\n}\r\nblk_queue_stack_limits(q, b);\r\nif (q->backing_dev_info.ra_pages != b->backing_dev_info.ra_pages) {\r\ndrbd_info(device, "Adjusting my ra_pages to backing device's (%lu -> %lu)\n",\r\nq->backing_dev_info.ra_pages,\r\nb->backing_dev_info.ra_pages);\r\nq->backing_dev_info.ra_pages = b->backing_dev_info.ra_pages;\r\n}\r\n}\r\n}\r\nvoid drbd_reconsider_max_bio_size(struct drbd_device *device, struct drbd_backing_dev *bdev)\r\n{\r\nunsigned int now, new, local, peer;\r\nnow = queue_max_hw_sectors(device->rq_queue) << 9;\r\nlocal = device->local_max_bio_size;\r\npeer = device->peer_max_bio_size;\r\nif (bdev) {\r\nlocal = queue_max_hw_sectors(bdev->backing_bdev->bd_disk->queue) << 9;\r\ndevice->local_max_bio_size = local;\r\n}\r\nlocal = min(local, DRBD_MAX_BIO_SIZE);\r\nif (device->state.conn >= C_WF_REPORT_PARAMS) {\r\nif (first_peer_device(device)->connection->agreed_pro_version < 94)\r\npeer = min(device->peer_max_bio_size, DRBD_MAX_SIZE_H80_PACKET);\r\nelse if (first_peer_device(device)->connection->agreed_pro_version == 94)\r\npeer = DRBD_MAX_SIZE_H80_PACKET;\r\nelse if (first_peer_device(device)->connection->agreed_pro_version < 100)\r\npeer = DRBD_MAX_BIO_SIZE_P95;\r\nelse\r\npeer = DRBD_MAX_BIO_SIZE;\r\nif (peer > device->peer_max_bio_size)\r\ndevice->peer_max_bio_size = peer;\r\n}\r\nnew = min(local, peer);\r\nif (device->state.role == R_PRIMARY && new < now)\r\ndrbd_err(device, "ASSERT FAILED new < now; (%u < %u)\n", new, now);\r\nif (new != now)\r\ndrbd_info(device, "max BIO size = %u\n", new);\r\ndrbd_setup_queue_param(device, bdev, new);\r\n}\r\nstatic void conn_reconfig_start(struct drbd_connection *connection)\r\n{\r\ndrbd_thread_start(&connection->worker);\r\ndrbd_flush_workqueue(&connection->sender_work);\r\n}\r\nstatic void conn_reconfig_done(struct drbd_connection *connection)\r\n{\r\nbool stop_threads;\r\nspin_lock_irq(&connection->resource->req_lock);\r\nstop_threads = conn_all_vols_unconf(connection) &&\r\nconnection->cstate == C_STANDALONE;\r\nspin_unlock_irq(&connection->resource->req_lock);\r\nif (stop_threads) {\r\ndrbd_thread_stop(&connection->receiver);\r\ndrbd_thread_stop(&connection->worker);\r\n}\r\n}\r\nstatic void drbd_suspend_al(struct drbd_device *device)\r\n{\r\nint s = 0;\r\nif (!lc_try_lock(device->act_log)) {\r\ndrbd_warn(device, "Failed to lock al in drbd_suspend_al()\n");\r\nreturn;\r\n}\r\ndrbd_al_shrink(device);\r\nspin_lock_irq(&device->resource->req_lock);\r\nif (device->state.conn < C_CONNECTED)\r\ns = !test_and_set_bit(AL_SUSPENDED, &device->flags);\r\nspin_unlock_irq(&device->resource->req_lock);\r\nlc_unlock(device->act_log);\r\nif (s)\r\ndrbd_info(device, "Suspended AL updates\n");\r\n}\r\nstatic bool should_set_defaults(struct genl_info *info)\r\n{\r\nunsigned flags = ((struct drbd_genlmsghdr*)info->userhdr)->flags;\r\nreturn 0 != (flags & DRBD_GENL_F_SET_DEFAULTS);\r\n}\r\nstatic unsigned int drbd_al_extents_max(struct drbd_backing_dev *bdev)\r\n{\r\nconst unsigned int max_al_nr = DRBD_AL_EXTENTS_MAX;\r\nconst unsigned int sufficient_on_disk =\r\n(max_al_nr + AL_CONTEXT_PER_TRANSACTION -1)\r\n/AL_CONTEXT_PER_TRANSACTION;\r\nunsigned int al_size_4k = bdev->md.al_size_4k;\r\nif (al_size_4k > sufficient_on_disk)\r\nreturn max_al_nr;\r\nreturn (al_size_4k - 1) * AL_CONTEXT_PER_TRANSACTION;\r\n}\r\nstatic bool write_ordering_changed(struct disk_conf *a, struct disk_conf *b)\r\n{\r\nreturn a->disk_barrier != b->disk_barrier ||\r\na->disk_flushes != b->disk_flushes ||\r\na->disk_drain != b->disk_drain;\r\n}\r\nint drbd_adm_disk_opts(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct drbd_config_context adm_ctx;\r\nenum drbd_ret_code retcode;\r\nstruct drbd_device *device;\r\nstruct disk_conf *new_disk_conf, *old_disk_conf;\r\nstruct fifo_buffer *old_plan = NULL, *new_plan = NULL;\r\nint err, fifo_size;\r\nretcode = drbd_adm_prepare(&adm_ctx, skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto finish;\r\ndevice = adm_ctx.device;\r\nmutex_lock(&adm_ctx.resource->adm_mutex);\r\nif (!get_ldev(device)) {\r\nretcode = ERR_NO_DISK;\r\ngoto out;\r\n}\r\nnew_disk_conf = kmalloc(sizeof(struct disk_conf), GFP_KERNEL);\r\nif (!new_disk_conf) {\r\nretcode = ERR_NOMEM;\r\ngoto fail;\r\n}\r\nmutex_lock(&device->resource->conf_update);\r\nold_disk_conf = device->ldev->disk_conf;\r\n*new_disk_conf = *old_disk_conf;\r\nif (should_set_defaults(info))\r\nset_disk_conf_defaults(new_disk_conf);\r\nerr = disk_conf_from_attrs_for_change(new_disk_conf, info);\r\nif (err && err != -ENOMSG) {\r\nretcode = ERR_MANDATORY_TAG;\r\ndrbd_msg_put_info(adm_ctx.reply_skb, from_attrs_err_to_txt(err));\r\ngoto fail_unlock;\r\n}\r\nif (!expect(new_disk_conf->resync_rate >= 1))\r\nnew_disk_conf->resync_rate = 1;\r\nif (new_disk_conf->al_extents < DRBD_AL_EXTENTS_MIN)\r\nnew_disk_conf->al_extents = DRBD_AL_EXTENTS_MIN;\r\nif (new_disk_conf->al_extents > drbd_al_extents_max(device->ldev))\r\nnew_disk_conf->al_extents = drbd_al_extents_max(device->ldev);\r\nif (new_disk_conf->c_plan_ahead > DRBD_C_PLAN_AHEAD_MAX)\r\nnew_disk_conf->c_plan_ahead = DRBD_C_PLAN_AHEAD_MAX;\r\nfifo_size = (new_disk_conf->c_plan_ahead * 10 * SLEEP_TIME) / HZ;\r\nif (fifo_size != device->rs_plan_s->size) {\r\nnew_plan = fifo_alloc(fifo_size);\r\nif (!new_plan) {\r\ndrbd_err(device, "kmalloc of fifo_buffer failed");\r\nretcode = ERR_NOMEM;\r\ngoto fail_unlock;\r\n}\r\n}\r\ndrbd_suspend_io(device);\r\nwait_event(device->al_wait, lc_try_lock(device->act_log));\r\ndrbd_al_shrink(device);\r\nerr = drbd_check_al_size(device, new_disk_conf);\r\nlc_unlock(device->act_log);\r\nwake_up(&device->al_wait);\r\ndrbd_resume_io(device);\r\nif (err) {\r\nretcode = ERR_NOMEM;\r\ngoto fail_unlock;\r\n}\r\nwrite_lock_irq(&global_state_lock);\r\nretcode = drbd_resync_after_valid(device, new_disk_conf->resync_after);\r\nif (retcode == NO_ERROR) {\r\nrcu_assign_pointer(device->ldev->disk_conf, new_disk_conf);\r\ndrbd_resync_after_changed(device);\r\n}\r\nwrite_unlock_irq(&global_state_lock);\r\nif (retcode != NO_ERROR)\r\ngoto fail_unlock;\r\nif (new_plan) {\r\nold_plan = device->rs_plan_s;\r\nrcu_assign_pointer(device->rs_plan_s, new_plan);\r\n}\r\nmutex_unlock(&device->resource->conf_update);\r\nif (new_disk_conf->al_updates)\r\ndevice->ldev->md.flags &= ~MDF_AL_DISABLED;\r\nelse\r\ndevice->ldev->md.flags |= MDF_AL_DISABLED;\r\nif (new_disk_conf->md_flushes)\r\nclear_bit(MD_NO_FUA, &device->flags);\r\nelse\r\nset_bit(MD_NO_FUA, &device->flags);\r\nif (write_ordering_changed(old_disk_conf, new_disk_conf))\r\ndrbd_bump_write_ordering(device->resource, NULL, WO_bdev_flush);\r\ndrbd_md_sync(device);\r\nif (device->state.conn >= C_CONNECTED) {\r\nstruct drbd_peer_device *peer_device;\r\nfor_each_peer_device(peer_device, device)\r\ndrbd_send_sync_param(peer_device);\r\n}\r\nsynchronize_rcu();\r\nkfree(old_disk_conf);\r\nkfree(old_plan);\r\nmod_timer(&device->request_timer, jiffies + HZ);\r\ngoto success;\r\nfail_unlock:\r\nmutex_unlock(&device->resource->conf_update);\r\nfail:\r\nkfree(new_disk_conf);\r\nkfree(new_plan);\r\nsuccess:\r\nput_ldev(device);\r\nout:\r\nmutex_unlock(&adm_ctx.resource->adm_mutex);\r\nfinish:\r\ndrbd_adm_finish(&adm_ctx, info, retcode);\r\nreturn 0;\r\n}\r\nint drbd_adm_attach(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct drbd_config_context adm_ctx;\r\nstruct drbd_device *device;\r\nstruct drbd_peer_device *peer_device;\r\nstruct drbd_connection *connection;\r\nint err;\r\nenum drbd_ret_code retcode;\r\nenum determine_dev_size dd;\r\nsector_t max_possible_sectors;\r\nsector_t min_md_device_sectors;\r\nstruct drbd_backing_dev *nbc = NULL;\r\nstruct disk_conf *new_disk_conf = NULL;\r\nstruct block_device *bdev;\r\nstruct lru_cache *resync_lru = NULL;\r\nstruct fifo_buffer *new_plan = NULL;\r\nunion drbd_state ns, os;\r\nenum drbd_state_rv rv;\r\nstruct net_conf *nc;\r\nretcode = drbd_adm_prepare(&adm_ctx, skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto finish;\r\ndevice = adm_ctx.device;\r\nmutex_lock(&adm_ctx.resource->adm_mutex);\r\npeer_device = first_peer_device(device);\r\nconnection = peer_device ? peer_device->connection : NULL;\r\nconn_reconfig_start(connection);\r\nif (device->state.disk > D_DISKLESS) {\r\nretcode = ERR_DISK_CONFIGURED;\r\ngoto fail;\r\n}\r\nwait_event(device->misc_wait, !test_bit(GOING_DISKLESS, &device->flags));\r\nclear_bit(FORCE_DETACH, &device->flags);\r\nclear_bit(WAS_IO_ERROR, &device->flags);\r\nclear_bit(WAS_READ_ERROR, &device->flags);\r\ndevice->rs_total = 0;\r\ndevice->rs_failed = 0;\r\natomic_set(&device->rs_pending_cnt, 0);\r\nnbc = kzalloc(sizeof(struct drbd_backing_dev), GFP_KERNEL);\r\nif (!nbc) {\r\nretcode = ERR_NOMEM;\r\ngoto fail;\r\n}\r\nspin_lock_init(&nbc->md.uuid_lock);\r\nnew_disk_conf = kzalloc(sizeof(struct disk_conf), GFP_KERNEL);\r\nif (!new_disk_conf) {\r\nretcode = ERR_NOMEM;\r\ngoto fail;\r\n}\r\nnbc->disk_conf = new_disk_conf;\r\nset_disk_conf_defaults(new_disk_conf);\r\nerr = disk_conf_from_attrs(new_disk_conf, info);\r\nif (err) {\r\nretcode = ERR_MANDATORY_TAG;\r\ndrbd_msg_put_info(adm_ctx.reply_skb, from_attrs_err_to_txt(err));\r\ngoto fail;\r\n}\r\nif (new_disk_conf->c_plan_ahead > DRBD_C_PLAN_AHEAD_MAX)\r\nnew_disk_conf->c_plan_ahead = DRBD_C_PLAN_AHEAD_MAX;\r\nnew_plan = fifo_alloc((new_disk_conf->c_plan_ahead * 10 * SLEEP_TIME) / HZ);\r\nif (!new_plan) {\r\nretcode = ERR_NOMEM;\r\ngoto fail;\r\n}\r\nif (new_disk_conf->meta_dev_idx < DRBD_MD_INDEX_FLEX_INT) {\r\nretcode = ERR_MD_IDX_INVALID;\r\ngoto fail;\r\n}\r\nwrite_lock_irq(&global_state_lock);\r\nretcode = drbd_resync_after_valid(device, new_disk_conf->resync_after);\r\nwrite_unlock_irq(&global_state_lock);\r\nif (retcode != NO_ERROR)\r\ngoto fail;\r\nrcu_read_lock();\r\nnc = rcu_dereference(connection->net_conf);\r\nif (nc) {\r\nif (new_disk_conf->fencing == FP_STONITH && nc->wire_protocol == DRBD_PROT_A) {\r\nrcu_read_unlock();\r\nretcode = ERR_STONITH_AND_PROT_A;\r\ngoto fail;\r\n}\r\n}\r\nrcu_read_unlock();\r\nbdev = blkdev_get_by_path(new_disk_conf->backing_dev,\r\nFMODE_READ | FMODE_WRITE | FMODE_EXCL, device);\r\nif (IS_ERR(bdev)) {\r\ndrbd_err(device, "open(\"%s\") failed with %ld\n", new_disk_conf->backing_dev,\r\nPTR_ERR(bdev));\r\nretcode = ERR_OPEN_DISK;\r\ngoto fail;\r\n}\r\nnbc->backing_bdev = bdev;\r\nbdev = blkdev_get_by_path(new_disk_conf->meta_dev,\r\nFMODE_READ | FMODE_WRITE | FMODE_EXCL,\r\n(new_disk_conf->meta_dev_idx < 0) ?\r\n(void *)device : (void *)drbd_m_holder);\r\nif (IS_ERR(bdev)) {\r\ndrbd_err(device, "open(\"%s\") failed with %ld\n", new_disk_conf->meta_dev,\r\nPTR_ERR(bdev));\r\nretcode = ERR_OPEN_MD_DISK;\r\ngoto fail;\r\n}\r\nnbc->md_bdev = bdev;\r\nif ((nbc->backing_bdev == nbc->md_bdev) !=\r\n(new_disk_conf->meta_dev_idx == DRBD_MD_INDEX_INTERNAL ||\r\nnew_disk_conf->meta_dev_idx == DRBD_MD_INDEX_FLEX_INT)) {\r\nretcode = ERR_MD_IDX_INVALID;\r\ngoto fail;\r\n}\r\nresync_lru = lc_create("resync", drbd_bm_ext_cache,\r\n1, 61, sizeof(struct bm_extent),\r\noffsetof(struct bm_extent, lce));\r\nif (!resync_lru) {\r\nretcode = ERR_NOMEM;\r\ngoto fail;\r\n}\r\nretcode = drbd_md_read(device, nbc);\r\nif (retcode != NO_ERROR)\r\ngoto fail;\r\nif (new_disk_conf->al_extents < DRBD_AL_EXTENTS_MIN)\r\nnew_disk_conf->al_extents = DRBD_AL_EXTENTS_MIN;\r\nif (new_disk_conf->al_extents > drbd_al_extents_max(nbc))\r\nnew_disk_conf->al_extents = drbd_al_extents_max(nbc);\r\nif (drbd_get_max_capacity(nbc) < new_disk_conf->disk_size) {\r\ndrbd_err(device, "max capacity %llu smaller than disk size %llu\n",\r\n(unsigned long long) drbd_get_max_capacity(nbc),\r\n(unsigned long long) new_disk_conf->disk_size);\r\nretcode = ERR_DISK_TOO_SMALL;\r\ngoto fail;\r\n}\r\nif (new_disk_conf->meta_dev_idx < 0) {\r\nmax_possible_sectors = DRBD_MAX_SECTORS_FLEX;\r\nmin_md_device_sectors = (2<<10);\r\n} else {\r\nmax_possible_sectors = DRBD_MAX_SECTORS;\r\nmin_md_device_sectors = MD_128MB_SECT * (new_disk_conf->meta_dev_idx + 1);\r\n}\r\nif (drbd_get_capacity(nbc->md_bdev) < min_md_device_sectors) {\r\nretcode = ERR_MD_DISK_TOO_SMALL;\r\ndrbd_warn(device, "refusing attach: md-device too small, "\r\n"at least %llu sectors needed for this meta-disk type\n",\r\n(unsigned long long) min_md_device_sectors);\r\ngoto fail;\r\n}\r\nif (drbd_get_max_capacity(nbc) <\r\ndrbd_get_capacity(device->this_bdev)) {\r\nretcode = ERR_DISK_TOO_SMALL;\r\ngoto fail;\r\n}\r\nnbc->known_size = drbd_get_capacity(nbc->backing_bdev);\r\nif (nbc->known_size > max_possible_sectors) {\r\ndrbd_warn(device, "==> truncating very big lower level device "\r\n"to currently maximum possible %llu sectors <==\n",\r\n(unsigned long long) max_possible_sectors);\r\nif (new_disk_conf->meta_dev_idx >= 0)\r\ndrbd_warn(device, "==>> using internal or flexible "\r\n"meta data may help <<==\n");\r\n}\r\ndrbd_suspend_io(device);\r\nwait_event(device->misc_wait, !atomic_read(&device->ap_pending_cnt) || drbd_suspended(device));\r\ndrbd_flush_workqueue(&connection->sender_work);\r\nrv = _drbd_request_state(device, NS(disk, D_ATTACHING), CS_VERBOSE);\r\nretcode = rv;\r\ndrbd_resume_io(device);\r\nif (rv < SS_SUCCESS)\r\ngoto fail;\r\nif (!get_ldev_if_state(device, D_ATTACHING))\r\ngoto force_diskless;\r\nif (!device->bitmap) {\r\nif (drbd_bm_init(device)) {\r\nretcode = ERR_NOMEM;\r\ngoto force_diskless_dec;\r\n}\r\n}\r\nif (device->state.conn < C_CONNECTED &&\r\ndevice->state.role == R_PRIMARY && device->ed_uuid &&\r\n(device->ed_uuid & ~((u64)1)) != (nbc->md.uuid[UI_CURRENT] & ~((u64)1))) {\r\ndrbd_err(device, "Can only attach to data with current UUID=%016llX\n",\r\n(unsigned long long)device->ed_uuid);\r\nretcode = ERR_DATA_NOT_CURRENT;\r\ngoto force_diskless_dec;\r\n}\r\nif (drbd_check_al_size(device, new_disk_conf)) {\r\nretcode = ERR_NOMEM;\r\ngoto force_diskless_dec;\r\n}\r\nif (drbd_md_test_flag(nbc, MDF_CONSISTENT) &&\r\ndrbd_new_dev_size(device, nbc, nbc->disk_conf->disk_size, 0) < nbc->md.la_size_sect) {\r\ndrbd_warn(device, "refusing to truncate a consistent device\n");\r\nretcode = ERR_DISK_TOO_SMALL;\r\ngoto force_diskless_dec;\r\n}\r\nif (new_disk_conf->md_flushes)\r\nclear_bit(MD_NO_FUA, &device->flags);\r\nelse\r\nset_bit(MD_NO_FUA, &device->flags);\r\nD_ASSERT(device, device->ldev == NULL);\r\ndevice->ldev = nbc;\r\ndevice->resync = resync_lru;\r\ndevice->rs_plan_s = new_plan;\r\nnbc = NULL;\r\nresync_lru = NULL;\r\nnew_disk_conf = NULL;\r\nnew_plan = NULL;\r\ndrbd_bump_write_ordering(device->resource, device->ldev, WO_bdev_flush);\r\nif (drbd_md_test_flag(device->ldev, MDF_CRASHED_PRIMARY))\r\nset_bit(CRASHED_PRIMARY, &device->flags);\r\nelse\r\nclear_bit(CRASHED_PRIMARY, &device->flags);\r\nif (drbd_md_test_flag(device->ldev, MDF_PRIMARY_IND) &&\r\n!(device->state.role == R_PRIMARY && device->resource->susp_nod))\r\nset_bit(CRASHED_PRIMARY, &device->flags);\r\ndevice->send_cnt = 0;\r\ndevice->recv_cnt = 0;\r\ndevice->read_cnt = 0;\r\ndevice->writ_cnt = 0;\r\ndrbd_reconsider_max_bio_size(device, device->ldev);\r\nclear_bit(USE_DEGR_WFC_T, &device->flags);\r\nif (device->state.role != R_PRIMARY &&\r\ndrbd_md_test_flag(device->ldev, MDF_PRIMARY_IND) &&\r\n!drbd_md_test_flag(device->ldev, MDF_CONNECTED_IND))\r\nset_bit(USE_DEGR_WFC_T, &device->flags);\r\ndd = drbd_determine_dev_size(device, 0, NULL);\r\nif (dd <= DS_ERROR) {\r\nretcode = ERR_NOMEM_BITMAP;\r\ngoto force_diskless_dec;\r\n} else if (dd == DS_GREW)\r\nset_bit(RESYNC_AFTER_NEG, &device->flags);\r\nif (drbd_md_test_flag(device->ldev, MDF_FULL_SYNC) ||\r\n(test_bit(CRASHED_PRIMARY, &device->flags) &&\r\ndrbd_md_test_flag(device->ldev, MDF_AL_DISABLED))) {\r\ndrbd_info(device, "Assuming that all blocks are out of sync "\r\n"(aka FullSync)\n");\r\nif (drbd_bitmap_io(device, &drbd_bmio_set_n_write,\r\n"set_n_write from attaching", BM_LOCKED_MASK)) {\r\nretcode = ERR_IO_MD_DISK;\r\ngoto force_diskless_dec;\r\n}\r\n} else {\r\nif (drbd_bitmap_io(device, &drbd_bm_read,\r\n"read from attaching", BM_LOCKED_MASK)) {\r\nretcode = ERR_IO_MD_DISK;\r\ngoto force_diskless_dec;\r\n}\r\n}\r\nif (_drbd_bm_total_weight(device) == drbd_bm_bits(device))\r\ndrbd_suspend_al(device);\r\nspin_lock_irq(&device->resource->req_lock);\r\nos = drbd_read_state(device);\r\nns = os;\r\nif (drbd_md_test_flag(device->ldev, MDF_CONSISTENT)) {\r\nif (drbd_md_test_flag(device->ldev, MDF_WAS_UP_TO_DATE))\r\nns.disk = D_CONSISTENT;\r\nelse\r\nns.disk = D_OUTDATED;\r\n} else {\r\nns.disk = D_INCONSISTENT;\r\n}\r\nif (drbd_md_test_flag(device->ldev, MDF_PEER_OUT_DATED))\r\nns.pdsk = D_OUTDATED;\r\nrcu_read_lock();\r\nif (ns.disk == D_CONSISTENT &&\r\n(ns.pdsk == D_OUTDATED || rcu_dereference(device->ldev->disk_conf)->fencing == FP_DONT_CARE))\r\nns.disk = D_UP_TO_DATE;\r\nif (rcu_dereference(device->ldev->disk_conf)->al_updates)\r\ndevice->ldev->md.flags &= ~MDF_AL_DISABLED;\r\nelse\r\ndevice->ldev->md.flags |= MDF_AL_DISABLED;\r\nrcu_read_unlock();\r\nif (device->state.conn == C_CONNECTED) {\r\ndevice->new_state_tmp.i = ns.i;\r\nns.i = os.i;\r\nns.disk = D_NEGOTIATING;\r\nkfree(device->p_uuid);\r\ndevice->p_uuid = NULL;\r\n}\r\nrv = _drbd_set_state(device, ns, CS_VERBOSE, NULL);\r\nspin_unlock_irq(&device->resource->req_lock);\r\nif (rv < SS_SUCCESS)\r\ngoto force_diskless_dec;\r\nmod_timer(&device->request_timer, jiffies + HZ);\r\nif (device->state.role == R_PRIMARY)\r\ndevice->ldev->md.uuid[UI_CURRENT] |= (u64)1;\r\nelse\r\ndevice->ldev->md.uuid[UI_CURRENT] &= ~(u64)1;\r\ndrbd_md_mark_dirty(device);\r\ndrbd_md_sync(device);\r\nkobject_uevent(&disk_to_dev(device->vdisk)->kobj, KOBJ_CHANGE);\r\nput_ldev(device);\r\nconn_reconfig_done(connection);\r\nmutex_unlock(&adm_ctx.resource->adm_mutex);\r\ndrbd_adm_finish(&adm_ctx, info, retcode);\r\nreturn 0;\r\nforce_diskless_dec:\r\nput_ldev(device);\r\nforce_diskless:\r\ndrbd_force_state(device, NS(disk, D_DISKLESS));\r\ndrbd_md_sync(device);\r\nfail:\r\nconn_reconfig_done(connection);\r\nif (nbc) {\r\nif (nbc->backing_bdev)\r\nblkdev_put(nbc->backing_bdev,\r\nFMODE_READ | FMODE_WRITE | FMODE_EXCL);\r\nif (nbc->md_bdev)\r\nblkdev_put(nbc->md_bdev,\r\nFMODE_READ | FMODE_WRITE | FMODE_EXCL);\r\nkfree(nbc);\r\n}\r\nkfree(new_disk_conf);\r\nlc_destroy(resync_lru);\r\nkfree(new_plan);\r\nmutex_unlock(&adm_ctx.resource->adm_mutex);\r\nfinish:\r\ndrbd_adm_finish(&adm_ctx, info, retcode);\r\nreturn 0;\r\n}\r\nstatic int adm_detach(struct drbd_device *device, int force)\r\n{\r\nenum drbd_state_rv retcode;\r\nint ret;\r\nif (force) {\r\nset_bit(FORCE_DETACH, &device->flags);\r\ndrbd_force_state(device, NS(disk, D_FAILED));\r\nretcode = SS_SUCCESS;\r\ngoto out;\r\n}\r\ndrbd_suspend_io(device);\r\ndrbd_md_get_buffer(device, __func__);\r\nretcode = drbd_request_state(device, NS(disk, D_FAILED));\r\ndrbd_md_put_buffer(device);\r\nret = wait_event_interruptible(device->misc_wait,\r\ndevice->state.disk != D_FAILED);\r\ndrbd_resume_io(device);\r\nif ((int)retcode == (int)SS_IS_DISKLESS)\r\nretcode = SS_NOTHING_TO_DO;\r\nif (ret)\r\nretcode = ERR_INTR;\r\nout:\r\nreturn retcode;\r\n}\r\nint drbd_adm_detach(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct drbd_config_context adm_ctx;\r\nenum drbd_ret_code retcode;\r\nstruct detach_parms parms = { };\r\nint err;\r\nretcode = drbd_adm_prepare(&adm_ctx, skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\nif (info->attrs[DRBD_NLA_DETACH_PARMS]) {\r\nerr = detach_parms_from_attrs(&parms, info);\r\nif (err) {\r\nretcode = ERR_MANDATORY_TAG;\r\ndrbd_msg_put_info(adm_ctx.reply_skb, from_attrs_err_to_txt(err));\r\ngoto out;\r\n}\r\n}\r\nmutex_lock(&adm_ctx.resource->adm_mutex);\r\nretcode = adm_detach(adm_ctx.device, parms.force_detach);\r\nmutex_unlock(&adm_ctx.resource->adm_mutex);\r\nout:\r\ndrbd_adm_finish(&adm_ctx, info, retcode);\r\nreturn 0;\r\n}\r\nstatic bool conn_resync_running(struct drbd_connection *connection)\r\n{\r\nstruct drbd_peer_device *peer_device;\r\nbool rv = false;\r\nint vnr;\r\nrcu_read_lock();\r\nidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\r\nstruct drbd_device *device = peer_device->device;\r\nif (device->state.conn == C_SYNC_SOURCE ||\r\ndevice->state.conn == C_SYNC_TARGET ||\r\ndevice->state.conn == C_PAUSED_SYNC_S ||\r\ndevice->state.conn == C_PAUSED_SYNC_T) {\r\nrv = true;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn rv;\r\n}\r\nstatic bool conn_ov_running(struct drbd_connection *connection)\r\n{\r\nstruct drbd_peer_device *peer_device;\r\nbool rv = false;\r\nint vnr;\r\nrcu_read_lock();\r\nidr_for_each_entry(&connection->peer_devices, peer_device, vnr) {\r\nstruct drbd_device *device = peer_device->device;\r\nif (device->state.conn == C_VERIFY_S ||\r\ndevice->state.conn == C_VERIFY_T) {\r\nrv = true;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn rv;\r\n}\r\nstatic enum drbd_ret_code\r\n_check_net_options(struct drbd_connection *connection, struct net_conf *old_net_conf, struct net_conf *new_net_conf)\r\n{\r\nstruct drbd_peer_device *peer_device;\r\nint i;\r\nif (old_net_conf && connection->cstate == C_WF_REPORT_PARAMS && connection->agreed_pro_version < 100) {\r\nif (new_net_conf->wire_protocol != old_net_conf->wire_protocol)\r\nreturn ERR_NEED_APV_100;\r\nif (new_net_conf->two_primaries != old_net_conf->two_primaries)\r\nreturn ERR_NEED_APV_100;\r\nif (strcmp(new_net_conf->integrity_alg, old_net_conf->integrity_alg))\r\nreturn ERR_NEED_APV_100;\r\n}\r\nif (!new_net_conf->two_primaries &&\r\nconn_highest_role(connection) == R_PRIMARY &&\r\nconn_highest_peer(connection) == R_PRIMARY)\r\nreturn ERR_NEED_ALLOW_TWO_PRI;\r\nif (new_net_conf->two_primaries &&\r\n(new_net_conf->wire_protocol != DRBD_PROT_C))\r\nreturn ERR_NOT_PROTO_C;\r\nidr_for_each_entry(&connection->peer_devices, peer_device, i) {\r\nstruct drbd_device *device = peer_device->device;\r\nif (get_ldev(device)) {\r\nenum drbd_fencing_p fp = rcu_dereference(device->ldev->disk_conf)->fencing;\r\nput_ldev(device);\r\nif (new_net_conf->wire_protocol == DRBD_PROT_A && fp == FP_STONITH)\r\nreturn ERR_STONITH_AND_PROT_A;\r\n}\r\nif (device->state.role == R_PRIMARY && new_net_conf->discard_my_data)\r\nreturn ERR_DISCARD_IMPOSSIBLE;\r\n}\r\nif (new_net_conf->on_congestion != OC_BLOCK && new_net_conf->wire_protocol != DRBD_PROT_A)\r\nreturn ERR_CONG_NOT_PROTO_A;\r\nreturn NO_ERROR;\r\n}\r\nstatic enum drbd_ret_code\r\ncheck_net_options(struct drbd_connection *connection, struct net_conf *new_net_conf)\r\n{\r\nstatic enum drbd_ret_code rv;\r\nstruct drbd_peer_device *peer_device;\r\nint i;\r\nrcu_read_lock();\r\nrv = _check_net_options(connection, rcu_dereference(connection->net_conf), new_net_conf);\r\nrcu_read_unlock();\r\nidr_for_each_entry(&connection->peer_devices, peer_device, i) {\r\nstruct drbd_device *device = peer_device->device;\r\nif (!device->bitmap) {\r\nif (drbd_bm_init(device))\r\nreturn ERR_NOMEM;\r\n}\r\n}\r\nreturn rv;\r\n}\r\nstatic int\r\nalloc_hash(struct crypto_hash **tfm, char *tfm_name, int err_alg)\r\n{\r\nif (!tfm_name[0])\r\nreturn NO_ERROR;\r\n*tfm = crypto_alloc_hash(tfm_name, 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(*tfm)) {\r\n*tfm = NULL;\r\nreturn err_alg;\r\n}\r\nreturn NO_ERROR;\r\n}\r\nstatic enum drbd_ret_code\r\nalloc_crypto(struct crypto *crypto, struct net_conf *new_net_conf)\r\n{\r\nchar hmac_name[CRYPTO_MAX_ALG_NAME];\r\nenum drbd_ret_code rv;\r\nrv = alloc_hash(&crypto->csums_tfm, new_net_conf->csums_alg,\r\nERR_CSUMS_ALG);\r\nif (rv != NO_ERROR)\r\nreturn rv;\r\nrv = alloc_hash(&crypto->verify_tfm, new_net_conf->verify_alg,\r\nERR_VERIFY_ALG);\r\nif (rv != NO_ERROR)\r\nreturn rv;\r\nrv = alloc_hash(&crypto->integrity_tfm, new_net_conf->integrity_alg,\r\nERR_INTEGRITY_ALG);\r\nif (rv != NO_ERROR)\r\nreturn rv;\r\nif (new_net_conf->cram_hmac_alg[0] != 0) {\r\nsnprintf(hmac_name, CRYPTO_MAX_ALG_NAME, "hmac(%s)",\r\nnew_net_conf->cram_hmac_alg);\r\nrv = alloc_hash(&crypto->cram_hmac_tfm, hmac_name,\r\nERR_AUTH_ALG);\r\n}\r\nreturn rv;\r\n}\r\nstatic void free_crypto(struct crypto *crypto)\r\n{\r\ncrypto_free_hash(crypto->cram_hmac_tfm);\r\ncrypto_free_hash(crypto->integrity_tfm);\r\ncrypto_free_hash(crypto->csums_tfm);\r\ncrypto_free_hash(crypto->verify_tfm);\r\n}\r\nint drbd_adm_net_opts(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct drbd_config_context adm_ctx;\r\nenum drbd_ret_code retcode;\r\nstruct drbd_connection *connection;\r\nstruct net_conf *old_net_conf, *new_net_conf = NULL;\r\nint err;\r\nint ovr;\r\nint rsr;\r\nstruct crypto crypto = { };\r\nretcode = drbd_adm_prepare(&adm_ctx, skb, info, DRBD_ADM_NEED_CONNECTION);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto finish;\r\nconnection = adm_ctx.connection;\r\nmutex_lock(&adm_ctx.resource->adm_mutex);\r\nnew_net_conf = kzalloc(sizeof(struct net_conf), GFP_KERNEL);\r\nif (!new_net_conf) {\r\nretcode = ERR_NOMEM;\r\ngoto out;\r\n}\r\nconn_reconfig_start(connection);\r\nmutex_lock(&connection->data.mutex);\r\nmutex_lock(&connection->resource->conf_update);\r\nold_net_conf = connection->net_conf;\r\nif (!old_net_conf) {\r\ndrbd_msg_put_info(adm_ctx.reply_skb, "net conf missing, try connect");\r\nretcode = ERR_INVALID_REQUEST;\r\ngoto fail;\r\n}\r\n*new_net_conf = *old_net_conf;\r\nif (should_set_defaults(info))\r\nset_net_conf_defaults(new_net_conf);\r\nerr = net_conf_from_attrs_for_change(new_net_conf, info);\r\nif (err && err != -ENOMSG) {\r\nretcode = ERR_MANDATORY_TAG;\r\ndrbd_msg_put_info(adm_ctx.reply_skb, from_attrs_err_to_txt(err));\r\ngoto fail;\r\n}\r\nretcode = check_net_options(connection, new_net_conf);\r\nif (retcode != NO_ERROR)\r\ngoto fail;\r\nrsr = conn_resync_running(connection);\r\nif (rsr && strcmp(new_net_conf->csums_alg, old_net_conf->csums_alg)) {\r\nretcode = ERR_CSUMS_RESYNC_RUNNING;\r\ngoto fail;\r\n}\r\novr = conn_ov_running(connection);\r\nif (ovr && strcmp(new_net_conf->verify_alg, old_net_conf->verify_alg)) {\r\nretcode = ERR_VERIFY_RUNNING;\r\ngoto fail;\r\n}\r\nretcode = alloc_crypto(&crypto, new_net_conf);\r\nif (retcode != NO_ERROR)\r\ngoto fail;\r\nrcu_assign_pointer(connection->net_conf, new_net_conf);\r\nif (!rsr) {\r\ncrypto_free_hash(connection->csums_tfm);\r\nconnection->csums_tfm = crypto.csums_tfm;\r\ncrypto.csums_tfm = NULL;\r\n}\r\nif (!ovr) {\r\ncrypto_free_hash(connection->verify_tfm);\r\nconnection->verify_tfm = crypto.verify_tfm;\r\ncrypto.verify_tfm = NULL;\r\n}\r\ncrypto_free_hash(connection->integrity_tfm);\r\nconnection->integrity_tfm = crypto.integrity_tfm;\r\nif (connection->cstate >= C_WF_REPORT_PARAMS && connection->agreed_pro_version >= 100)\r\n__drbd_send_protocol(connection, P_PROTOCOL_UPDATE);\r\ncrypto_free_hash(connection->cram_hmac_tfm);\r\nconnection->cram_hmac_tfm = crypto.cram_hmac_tfm;\r\nmutex_unlock(&connection->resource->conf_update);\r\nmutex_unlock(&connection->data.mutex);\r\nsynchronize_rcu();\r\nkfree(old_net_conf);\r\nif (connection->cstate >= C_WF_REPORT_PARAMS) {\r\nstruct drbd_peer_device *peer_device;\r\nint vnr;\r\nidr_for_each_entry(&connection->peer_devices, peer_device, vnr)\r\ndrbd_send_sync_param(peer_device);\r\n}\r\ngoto done;\r\nfail:\r\nmutex_unlock(&connection->resource->conf_update);\r\nmutex_unlock(&connection->data.mutex);\r\nfree_crypto(&crypto);\r\nkfree(new_net_conf);\r\ndone:\r\nconn_reconfig_done(connection);\r\nout:\r\nmutex_unlock(&adm_ctx.resource->adm_mutex);\r\nfinish:\r\ndrbd_adm_finish(&adm_ctx, info, retcode);\r\nreturn 0;\r\n}\r\nint drbd_adm_connect(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct drbd_config_context adm_ctx;\r\nstruct drbd_peer_device *peer_device;\r\nstruct net_conf *old_net_conf, *new_net_conf = NULL;\r\nstruct crypto crypto = { };\r\nstruct drbd_resource *resource;\r\nstruct drbd_connection *connection;\r\nenum drbd_ret_code retcode;\r\nint i;\r\nint err;\r\nretcode = drbd_adm_prepare(&adm_ctx, skb, info, DRBD_ADM_NEED_RESOURCE);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\nif (!(adm_ctx.my_addr && adm_ctx.peer_addr)) {\r\ndrbd_msg_put_info(adm_ctx.reply_skb, "connection endpoint(s) missing");\r\nretcode = ERR_INVALID_REQUEST;\r\ngoto out;\r\n}\r\nfor_each_resource(resource, &drbd_resources) {\r\nfor_each_connection(connection, resource) {\r\nif (nla_len(adm_ctx.my_addr) == connection->my_addr_len &&\r\n!memcmp(nla_data(adm_ctx.my_addr), &connection->my_addr,\r\nconnection->my_addr_len)) {\r\nretcode = ERR_LOCAL_ADDR;\r\ngoto out;\r\n}\r\nif (nla_len(adm_ctx.peer_addr) == connection->peer_addr_len &&\r\n!memcmp(nla_data(adm_ctx.peer_addr), &connection->peer_addr,\r\nconnection->peer_addr_len)) {\r\nretcode = ERR_PEER_ADDR;\r\ngoto out;\r\n}\r\n}\r\n}\r\nmutex_lock(&adm_ctx.resource->adm_mutex);\r\nconnection = first_connection(adm_ctx.resource);\r\nconn_reconfig_start(connection);\r\nif (connection->cstate > C_STANDALONE) {\r\nretcode = ERR_NET_CONFIGURED;\r\ngoto fail;\r\n}\r\nnew_net_conf = kzalloc(sizeof(*new_net_conf), GFP_KERNEL);\r\nif (!new_net_conf) {\r\nretcode = ERR_NOMEM;\r\ngoto fail;\r\n}\r\nset_net_conf_defaults(new_net_conf);\r\nerr = net_conf_from_attrs(new_net_conf, info);\r\nif (err && err != -ENOMSG) {\r\nretcode = ERR_MANDATORY_TAG;\r\ndrbd_msg_put_info(adm_ctx.reply_skb, from_attrs_err_to_txt(err));\r\ngoto fail;\r\n}\r\nretcode = check_net_options(connection, new_net_conf);\r\nif (retcode != NO_ERROR)\r\ngoto fail;\r\nretcode = alloc_crypto(&crypto, new_net_conf);\r\nif (retcode != NO_ERROR)\r\ngoto fail;\r\n((char *)new_net_conf->shared_secret)[SHARED_SECRET_MAX-1] = 0;\r\ndrbd_flush_workqueue(&connection->sender_work);\r\nmutex_lock(&adm_ctx.resource->conf_update);\r\nold_net_conf = connection->net_conf;\r\nif (old_net_conf) {\r\nretcode = ERR_NET_CONFIGURED;\r\nmutex_unlock(&adm_ctx.resource->conf_update);\r\ngoto fail;\r\n}\r\nrcu_assign_pointer(connection->net_conf, new_net_conf);\r\nconn_free_crypto(connection);\r\nconnection->cram_hmac_tfm = crypto.cram_hmac_tfm;\r\nconnection->integrity_tfm = crypto.integrity_tfm;\r\nconnection->csums_tfm = crypto.csums_tfm;\r\nconnection->verify_tfm = crypto.verify_tfm;\r\nconnection->my_addr_len = nla_len(adm_ctx.my_addr);\r\nmemcpy(&connection->my_addr, nla_data(adm_ctx.my_addr), connection->my_addr_len);\r\nconnection->peer_addr_len = nla_len(adm_ctx.peer_addr);\r\nmemcpy(&connection->peer_addr, nla_data(adm_ctx.peer_addr), connection->peer_addr_len);\r\nmutex_unlock(&adm_ctx.resource->conf_update);\r\nrcu_read_lock();\r\nidr_for_each_entry(&connection->peer_devices, peer_device, i) {\r\nstruct drbd_device *device = peer_device->device;\r\ndevice->send_cnt = 0;\r\ndevice->recv_cnt = 0;\r\n}\r\nrcu_read_unlock();\r\nretcode = conn_request_state(connection, NS(conn, C_UNCONNECTED), CS_VERBOSE);\r\nconn_reconfig_done(connection);\r\nmutex_unlock(&adm_ctx.resource->adm_mutex);\r\ndrbd_adm_finish(&adm_ctx, info, retcode);\r\nreturn 0;\r\nfail:\r\nfree_crypto(&crypto);\r\nkfree(new_net_conf);\r\nconn_reconfig_done(connection);\r\nmutex_unlock(&adm_ctx.resource->adm_mutex);\r\nout:\r\ndrbd_adm_finish(&adm_ctx, info, retcode);\r\nreturn 0;\r\n}\r\nstatic enum drbd_state_rv conn_try_disconnect(struct drbd_connection *connection, bool force)\r\n{\r\nenum drbd_state_rv rv;\r\nrv = conn_request_state(connection, NS(conn, C_DISCONNECTING),\r\nforce ? CS_HARD : 0);\r\nswitch (rv) {\r\ncase SS_NOTHING_TO_DO:\r\nbreak;\r\ncase SS_ALREADY_STANDALONE:\r\nreturn SS_SUCCESS;\r\ncase SS_PRIMARY_NOP:\r\nrv = conn_request_state(connection, NS2(conn, C_DISCONNECTING, pdsk, D_OUTDATED), 0);\r\nif (rv == SS_OUTDATE_WO_CONN)\r\nrv = conn_request_state(connection, NS(conn, C_DISCONNECTING), CS_VERBOSE);\r\nbreak;\r\ncase SS_CW_FAILED_BY_PEER:\r\nrv = conn_request_state(connection, NS2(conn, C_DISCONNECTING,\r\ndisk, D_OUTDATED), 0);\r\nif (rv == SS_IS_DISKLESS || rv == SS_LOWER_THAN_OUTDATED) {\r\nrv = conn_request_state(connection, NS(conn, C_DISCONNECTING),\r\nCS_HARD);\r\n}\r\nbreak;\r\ndefault:;\r\n}\r\nif (rv >= SS_SUCCESS) {\r\nenum drbd_state_rv rv2;\r\ndrbd_thread_stop(&connection->receiver);\r\nrv2 = conn_request_state(connection, NS(conn, C_STANDALONE),\r\nCS_VERBOSE | CS_HARD);\r\nif (rv2 < SS_SUCCESS)\r\ndrbd_err(connection,\r\n"unexpected rv2=%d in conn_try_disconnect()\n",\r\nrv2);\r\n}\r\nreturn rv;\r\n}\r\nint drbd_adm_disconnect(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct drbd_config_context adm_ctx;\r\nstruct disconnect_parms parms;\r\nstruct drbd_connection *connection;\r\nenum drbd_state_rv rv;\r\nenum drbd_ret_code retcode;\r\nint err;\r\nretcode = drbd_adm_prepare(&adm_ctx, skb, info, DRBD_ADM_NEED_CONNECTION);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto fail;\r\nconnection = adm_ctx.connection;\r\nmemset(&parms, 0, sizeof(parms));\r\nif (info->attrs[DRBD_NLA_DISCONNECT_PARMS]) {\r\nerr = disconnect_parms_from_attrs(&parms, info);\r\nif (err) {\r\nretcode = ERR_MANDATORY_TAG;\r\ndrbd_msg_put_info(adm_ctx.reply_skb, from_attrs_err_to_txt(err));\r\ngoto fail;\r\n}\r\n}\r\nmutex_lock(&adm_ctx.resource->adm_mutex);\r\nrv = conn_try_disconnect(connection, parms.force_disconnect);\r\nif (rv < SS_SUCCESS)\r\nretcode = rv;\r\nelse\r\nretcode = NO_ERROR;\r\nmutex_unlock(&adm_ctx.resource->adm_mutex);\r\nfail:\r\ndrbd_adm_finish(&adm_ctx, info, retcode);\r\nreturn 0;\r\n}\r\nvoid resync_after_online_grow(struct drbd_device *device)\r\n{\r\nint iass;\r\ndrbd_info(device, "Resync of new storage after online grow\n");\r\nif (device->state.role != device->state.peer)\r\niass = (device->state.role == R_PRIMARY);\r\nelse\r\niass = test_bit(RESOLVE_CONFLICTS, &first_peer_device(device)->connection->flags);\r\nif (iass)\r\ndrbd_start_resync(device, C_SYNC_SOURCE);\r\nelse\r\n_drbd_request_state(device, NS(conn, C_WF_SYNC_UUID), CS_VERBOSE + CS_SERIALIZE);\r\n}\r\nint drbd_adm_resize(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct drbd_config_context adm_ctx;\r\nstruct disk_conf *old_disk_conf, *new_disk_conf = NULL;\r\nstruct resize_parms rs;\r\nstruct drbd_device *device;\r\nenum drbd_ret_code retcode;\r\nenum determine_dev_size dd;\r\nbool change_al_layout = false;\r\nenum dds_flags ddsf;\r\nsector_t u_size;\r\nint err;\r\nretcode = drbd_adm_prepare(&adm_ctx, skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto finish;\r\nmutex_lock(&adm_ctx.resource->adm_mutex);\r\ndevice = adm_ctx.device;\r\nif (!get_ldev(device)) {\r\nretcode = ERR_NO_DISK;\r\ngoto fail;\r\n}\r\nmemset(&rs, 0, sizeof(struct resize_parms));\r\nrs.al_stripes = device->ldev->md.al_stripes;\r\nrs.al_stripe_size = device->ldev->md.al_stripe_size_4k * 4;\r\nif (info->attrs[DRBD_NLA_RESIZE_PARMS]) {\r\nerr = resize_parms_from_attrs(&rs, info);\r\nif (err) {\r\nretcode = ERR_MANDATORY_TAG;\r\ndrbd_msg_put_info(adm_ctx.reply_skb, from_attrs_err_to_txt(err));\r\ngoto fail_ldev;\r\n}\r\n}\r\nif (device->state.conn > C_CONNECTED) {\r\nretcode = ERR_RESIZE_RESYNC;\r\ngoto fail_ldev;\r\n}\r\nif (device->state.role == R_SECONDARY &&\r\ndevice->state.peer == R_SECONDARY) {\r\nretcode = ERR_NO_PRIMARY;\r\ngoto fail_ldev;\r\n}\r\nif (rs.no_resync && first_peer_device(device)->connection->agreed_pro_version < 93) {\r\nretcode = ERR_NEED_APV_93;\r\ngoto fail_ldev;\r\n}\r\nrcu_read_lock();\r\nu_size = rcu_dereference(device->ldev->disk_conf)->disk_size;\r\nrcu_read_unlock();\r\nif (u_size != (sector_t)rs.resize_size) {\r\nnew_disk_conf = kmalloc(sizeof(struct disk_conf), GFP_KERNEL);\r\nif (!new_disk_conf) {\r\nretcode = ERR_NOMEM;\r\ngoto fail_ldev;\r\n}\r\n}\r\nif (device->ldev->md.al_stripes != rs.al_stripes ||\r\ndevice->ldev->md.al_stripe_size_4k != rs.al_stripe_size / 4) {\r\nu32 al_size_k = rs.al_stripes * rs.al_stripe_size;\r\nif (al_size_k > (16 * 1024 * 1024)) {\r\nretcode = ERR_MD_LAYOUT_TOO_BIG;\r\ngoto fail_ldev;\r\n}\r\nif (al_size_k < MD_32kB_SECT/2) {\r\nretcode = ERR_MD_LAYOUT_TOO_SMALL;\r\ngoto fail_ldev;\r\n}\r\nif (device->state.conn != C_CONNECTED && !rs.resize_force) {\r\nretcode = ERR_MD_LAYOUT_CONNECTED;\r\ngoto fail_ldev;\r\n}\r\nchange_al_layout = true;\r\n}\r\nif (device->ldev->known_size != drbd_get_capacity(device->ldev->backing_bdev))\r\ndevice->ldev->known_size = drbd_get_capacity(device->ldev->backing_bdev);\r\nif (new_disk_conf) {\r\nmutex_lock(&device->resource->conf_update);\r\nold_disk_conf = device->ldev->disk_conf;\r\n*new_disk_conf = *old_disk_conf;\r\nnew_disk_conf->disk_size = (sector_t)rs.resize_size;\r\nrcu_assign_pointer(device->ldev->disk_conf, new_disk_conf);\r\nmutex_unlock(&device->resource->conf_update);\r\nsynchronize_rcu();\r\nkfree(old_disk_conf);\r\n}\r\nddsf = (rs.resize_force ? DDSF_FORCED : 0) | (rs.no_resync ? DDSF_NO_RESYNC : 0);\r\ndd = drbd_determine_dev_size(device, ddsf, change_al_layout ? &rs : NULL);\r\ndrbd_md_sync(device);\r\nput_ldev(device);\r\nif (dd == DS_ERROR) {\r\nretcode = ERR_NOMEM_BITMAP;\r\ngoto fail;\r\n} else if (dd == DS_ERROR_SPACE_MD) {\r\nretcode = ERR_MD_LAYOUT_NO_FIT;\r\ngoto fail;\r\n} else if (dd == DS_ERROR_SHRINK) {\r\nretcode = ERR_IMPLICIT_SHRINK;\r\ngoto fail;\r\n}\r\nif (device->state.conn == C_CONNECTED) {\r\nif (dd == DS_GREW)\r\nset_bit(RESIZE_PENDING, &device->flags);\r\ndrbd_send_uuids(first_peer_device(device));\r\ndrbd_send_sizes(first_peer_device(device), 1, ddsf);\r\n}\r\nfail:\r\nmutex_unlock(&adm_ctx.resource->adm_mutex);\r\nfinish:\r\ndrbd_adm_finish(&adm_ctx, info, retcode);\r\nreturn 0;\r\nfail_ldev:\r\nput_ldev(device);\r\ngoto fail;\r\n}\r\nint drbd_adm_resource_opts(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct drbd_config_context adm_ctx;\r\nenum drbd_ret_code retcode;\r\nstruct res_opts res_opts;\r\nint err;\r\nretcode = drbd_adm_prepare(&adm_ctx, skb, info, DRBD_ADM_NEED_RESOURCE);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto fail;\r\nres_opts = adm_ctx.resource->res_opts;\r\nif (should_set_defaults(info))\r\nset_res_opts_defaults(&res_opts);\r\nerr = res_opts_from_attrs(&res_opts, info);\r\nif (err && err != -ENOMSG) {\r\nretcode = ERR_MANDATORY_TAG;\r\ndrbd_msg_put_info(adm_ctx.reply_skb, from_attrs_err_to_txt(err));\r\ngoto fail;\r\n}\r\nmutex_lock(&adm_ctx.resource->adm_mutex);\r\nerr = set_resource_options(adm_ctx.resource, &res_opts);\r\nif (err) {\r\nretcode = ERR_INVALID_REQUEST;\r\nif (err == -ENOMEM)\r\nretcode = ERR_NOMEM;\r\n}\r\nmutex_unlock(&adm_ctx.resource->adm_mutex);\r\nfail:\r\ndrbd_adm_finish(&adm_ctx, info, retcode);\r\nreturn 0;\r\n}\r\nint drbd_adm_invalidate(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct drbd_config_context adm_ctx;\r\nstruct drbd_device *device;\r\nint retcode;\r\nretcode = drbd_adm_prepare(&adm_ctx, skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\ndevice = adm_ctx.device;\r\nif (!get_ldev(device)) {\r\nretcode = ERR_NO_DISK;\r\ngoto out;\r\n}\r\nmutex_lock(&adm_ctx.resource->adm_mutex);\r\ndrbd_suspend_io(device);\r\nwait_event(device->misc_wait, !test_bit(BITMAP_IO, &device->flags));\r\ndrbd_flush_workqueue(&first_peer_device(device)->connection->sender_work);\r\nif (device->state.conn == C_STANDALONE && device->state.role == R_SECONDARY) {\r\nretcode = drbd_request_state(device, NS(disk, D_INCONSISTENT));\r\nif (retcode >= SS_SUCCESS) {\r\nif (drbd_bitmap_io(device, &drbd_bmio_set_n_write,\r\n"set_n_write from invalidate", BM_LOCKED_MASK))\r\nretcode = ERR_IO_MD_DISK;\r\n}\r\n} else\r\nretcode = drbd_request_state(device, NS(conn, C_STARTING_SYNC_T));\r\ndrbd_resume_io(device);\r\nmutex_unlock(&adm_ctx.resource->adm_mutex);\r\nput_ldev(device);\r\nout:\r\ndrbd_adm_finish(&adm_ctx, info, retcode);\r\nreturn 0;\r\n}\r\nstatic int drbd_adm_simple_request_state(struct sk_buff *skb, struct genl_info *info,\r\nunion drbd_state mask, union drbd_state val)\r\n{\r\nstruct drbd_config_context adm_ctx;\r\nenum drbd_ret_code retcode;\r\nretcode = drbd_adm_prepare(&adm_ctx, skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\nmutex_lock(&adm_ctx.resource->adm_mutex);\r\nretcode = drbd_request_state(adm_ctx.device, mask, val);\r\nmutex_unlock(&adm_ctx.resource->adm_mutex);\r\nout:\r\ndrbd_adm_finish(&adm_ctx, info, retcode);\r\nreturn 0;\r\n}\r\nstatic int drbd_bmio_set_susp_al(struct drbd_device *device) __must_hold(local)\r\n{\r\nint rv;\r\nrv = drbd_bmio_set_n_write(device);\r\ndrbd_suspend_al(device);\r\nreturn rv;\r\n}\r\nint drbd_adm_invalidate_peer(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct drbd_config_context adm_ctx;\r\nint retcode;\r\nstruct drbd_device *device;\r\nretcode = drbd_adm_prepare(&adm_ctx, skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\ndevice = adm_ctx.device;\r\nif (!get_ldev(device)) {\r\nretcode = ERR_NO_DISK;\r\ngoto out;\r\n}\r\nmutex_lock(&adm_ctx.resource->adm_mutex);\r\ndrbd_suspend_io(device);\r\nwait_event(device->misc_wait, !test_bit(BITMAP_IO, &device->flags));\r\ndrbd_flush_workqueue(&first_peer_device(device)->connection->sender_work);\r\nif (device->state.conn == C_STANDALONE && device->state.role == R_PRIMARY) {\r\nretcode = drbd_request_state(device, NS(pdsk, D_INCONSISTENT));\r\nif (retcode >= SS_SUCCESS) {\r\nif (drbd_bitmap_io(device, &drbd_bmio_set_susp_al,\r\n"set_n_write from invalidate_peer",\r\nBM_LOCKED_SET_ALLOWED))\r\nretcode = ERR_IO_MD_DISK;\r\n}\r\n} else\r\nretcode = drbd_request_state(device, NS(conn, C_STARTING_SYNC_S));\r\ndrbd_resume_io(device);\r\nmutex_unlock(&adm_ctx.resource->adm_mutex);\r\nput_ldev(device);\r\nout:\r\ndrbd_adm_finish(&adm_ctx, info, retcode);\r\nreturn 0;\r\n}\r\nint drbd_adm_pause_sync(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct drbd_config_context adm_ctx;\r\nenum drbd_ret_code retcode;\r\nretcode = drbd_adm_prepare(&adm_ctx, skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\nmutex_lock(&adm_ctx.resource->adm_mutex);\r\nif (drbd_request_state(adm_ctx.device, NS(user_isp, 1)) == SS_NOTHING_TO_DO)\r\nretcode = ERR_PAUSE_IS_SET;\r\nmutex_unlock(&adm_ctx.resource->adm_mutex);\r\nout:\r\ndrbd_adm_finish(&adm_ctx, info, retcode);\r\nreturn 0;\r\n}\r\nint drbd_adm_resume_sync(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct drbd_config_context adm_ctx;\r\nunion drbd_dev_state s;\r\nenum drbd_ret_code retcode;\r\nretcode = drbd_adm_prepare(&adm_ctx, skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\nmutex_lock(&adm_ctx.resource->adm_mutex);\r\nif (drbd_request_state(adm_ctx.device, NS(user_isp, 0)) == SS_NOTHING_TO_DO) {\r\ns = adm_ctx.device->state;\r\nif (s.conn == C_PAUSED_SYNC_S || s.conn == C_PAUSED_SYNC_T) {\r\nretcode = s.aftr_isp ? ERR_PIC_AFTER_DEP :\r\ns.peer_isp ? ERR_PIC_PEER_DEP : ERR_PAUSE_IS_CLEAR;\r\n} else {\r\nretcode = ERR_PAUSE_IS_CLEAR;\r\n}\r\n}\r\nmutex_unlock(&adm_ctx.resource->adm_mutex);\r\nout:\r\ndrbd_adm_finish(&adm_ctx, info, retcode);\r\nreturn 0;\r\n}\r\nint drbd_adm_suspend_io(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nreturn drbd_adm_simple_request_state(skb, info, NS(susp, 1));\r\n}\r\nint drbd_adm_resume_io(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct drbd_config_context adm_ctx;\r\nstruct drbd_device *device;\r\nint retcode;\r\nretcode = drbd_adm_prepare(&adm_ctx, skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\nmutex_lock(&adm_ctx.resource->adm_mutex);\r\ndevice = adm_ctx.device;\r\nif (test_bit(NEW_CUR_UUID, &device->flags)) {\r\ndrbd_uuid_new_current(device);\r\nclear_bit(NEW_CUR_UUID, &device->flags);\r\n}\r\ndrbd_suspend_io(device);\r\nretcode = drbd_request_state(device, NS3(susp, 0, susp_nod, 0, susp_fen, 0));\r\nif (retcode == SS_SUCCESS) {\r\nif (device->state.conn < C_CONNECTED)\r\ntl_clear(first_peer_device(device)->connection);\r\nif (device->state.disk == D_DISKLESS || device->state.disk == D_FAILED)\r\ntl_restart(first_peer_device(device)->connection, FAIL_FROZEN_DISK_IO);\r\n}\r\ndrbd_resume_io(device);\r\nmutex_unlock(&adm_ctx.resource->adm_mutex);\r\nout:\r\ndrbd_adm_finish(&adm_ctx, info, retcode);\r\nreturn 0;\r\n}\r\nint drbd_adm_outdate(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nreturn drbd_adm_simple_request_state(skb, info, NS(disk, D_OUTDATED));\r\n}\r\nstatic int nla_put_drbd_cfg_context(struct sk_buff *skb,\r\nstruct drbd_resource *resource,\r\nstruct drbd_connection *connection,\r\nstruct drbd_device *device)\r\n{\r\nstruct nlattr *nla;\r\nnla = nla_nest_start(skb, DRBD_NLA_CFG_CONTEXT);\r\nif (!nla)\r\ngoto nla_put_failure;\r\nif (device &&\r\nnla_put_u32(skb, T_ctx_volume, device->vnr))\r\ngoto nla_put_failure;\r\nif (nla_put_string(skb, T_ctx_resource_name, resource->name))\r\ngoto nla_put_failure;\r\nif (connection) {\r\nif (connection->my_addr_len &&\r\nnla_put(skb, T_ctx_my_addr, connection->my_addr_len, &connection->my_addr))\r\ngoto nla_put_failure;\r\nif (connection->peer_addr_len &&\r\nnla_put(skb, T_ctx_peer_addr, connection->peer_addr_len, &connection->peer_addr))\r\ngoto nla_put_failure;\r\n}\r\nnla_nest_end(skb, nla);\r\nreturn 0;\r\nnla_put_failure:\r\nif (nla)\r\nnla_nest_cancel(skb, nla);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic struct drbd_connection *the_only_connection(struct drbd_resource *resource)\r\n{\r\nstruct list_head *connections = &resource->connections;\r\nif (list_empty(connections) || connections->next->next != connections)\r\nreturn NULL;\r\nreturn list_first_entry(&resource->connections, struct drbd_connection, connections);\r\n}\r\nstatic int nla_put_status_info(struct sk_buff *skb, struct drbd_device *device,\r\nconst struct sib_info *sib)\r\n{\r\nstruct drbd_resource *resource = device->resource;\r\nstruct state_info *si = NULL;\r\nstruct nlattr *nla;\r\nint got_ldev;\r\nint err = 0;\r\nint exclude_sensitive;\r\nexclude_sensitive = sib || !capable(CAP_SYS_ADMIN);\r\ngot_ldev = get_ldev(device);\r\nif (nla_put_drbd_cfg_context(skb, resource, the_only_connection(resource), device))\r\ngoto nla_put_failure;\r\nif (res_opts_to_skb(skb, &device->resource->res_opts, exclude_sensitive))\r\ngoto nla_put_failure;\r\nrcu_read_lock();\r\nif (got_ldev) {\r\nstruct disk_conf *disk_conf;\r\ndisk_conf = rcu_dereference(device->ldev->disk_conf);\r\nerr = disk_conf_to_skb(skb, disk_conf, exclude_sensitive);\r\n}\r\nif (!err) {\r\nstruct net_conf *nc;\r\nnc = rcu_dereference(first_peer_device(device)->connection->net_conf);\r\nif (nc)\r\nerr = net_conf_to_skb(skb, nc, exclude_sensitive);\r\n}\r\nrcu_read_unlock();\r\nif (err)\r\ngoto nla_put_failure;\r\nnla = nla_nest_start(skb, DRBD_NLA_STATE_INFO);\r\nif (!nla)\r\ngoto nla_put_failure;\r\nif (nla_put_u32(skb, T_sib_reason, sib ? sib->sib_reason : SIB_GET_STATUS_REPLY) ||\r\nnla_put_u32(skb, T_current_state, device->state.i) ||\r\nnla_put_u64(skb, T_ed_uuid, device->ed_uuid) ||\r\nnla_put_u64(skb, T_capacity, drbd_get_capacity(device->this_bdev)) ||\r\nnla_put_u64(skb, T_send_cnt, device->send_cnt) ||\r\nnla_put_u64(skb, T_recv_cnt, device->recv_cnt) ||\r\nnla_put_u64(skb, T_read_cnt, device->read_cnt) ||\r\nnla_put_u64(skb, T_writ_cnt, device->writ_cnt) ||\r\nnla_put_u64(skb, T_al_writ_cnt, device->al_writ_cnt) ||\r\nnla_put_u64(skb, T_bm_writ_cnt, device->bm_writ_cnt) ||\r\nnla_put_u32(skb, T_ap_bio_cnt, atomic_read(&device->ap_bio_cnt)) ||\r\nnla_put_u32(skb, T_ap_pending_cnt, atomic_read(&device->ap_pending_cnt)) ||\r\nnla_put_u32(skb, T_rs_pending_cnt, atomic_read(&device->rs_pending_cnt)))\r\ngoto nla_put_failure;\r\nif (got_ldev) {\r\nint err;\r\nspin_lock_irq(&device->ldev->md.uuid_lock);\r\nerr = nla_put(skb, T_uuids, sizeof(si->uuids), device->ldev->md.uuid);\r\nspin_unlock_irq(&device->ldev->md.uuid_lock);\r\nif (err)\r\ngoto nla_put_failure;\r\nif (nla_put_u32(skb, T_disk_flags, device->ldev->md.flags) ||\r\nnla_put_u64(skb, T_bits_total, drbd_bm_bits(device)) ||\r\nnla_put_u64(skb, T_bits_oos, drbd_bm_total_weight(device)))\r\ngoto nla_put_failure;\r\nif (C_SYNC_SOURCE <= device->state.conn &&\r\nC_PAUSED_SYNC_T >= device->state.conn) {\r\nif (nla_put_u64(skb, T_bits_rs_total, device->rs_total) ||\r\nnla_put_u64(skb, T_bits_rs_failed, device->rs_failed))\r\ngoto nla_put_failure;\r\n}\r\n}\r\nif (sib) {\r\nswitch(sib->sib_reason) {\r\ncase SIB_SYNC_PROGRESS:\r\ncase SIB_GET_STATUS_REPLY:\r\nbreak;\r\ncase SIB_STATE_CHANGE:\r\nif (nla_put_u32(skb, T_prev_state, sib->os.i) ||\r\nnla_put_u32(skb, T_new_state, sib->ns.i))\r\ngoto nla_put_failure;\r\nbreak;\r\ncase SIB_HELPER_POST:\r\nif (nla_put_u32(skb, T_helper_exit_code,\r\nsib->helper_exit_code))\r\ngoto nla_put_failure;\r\ncase SIB_HELPER_PRE:\r\nif (nla_put_string(skb, T_helper, sib->helper_name))\r\ngoto nla_put_failure;\r\nbreak;\r\n}\r\n}\r\nnla_nest_end(skb, nla);\r\nif (0)\r\nnla_put_failure:\r\nerr = -EMSGSIZE;\r\nif (got_ldev)\r\nput_ldev(device);\r\nreturn err;\r\n}\r\nint drbd_adm_get_status(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct drbd_config_context adm_ctx;\r\nenum drbd_ret_code retcode;\r\nint err;\r\nretcode = drbd_adm_prepare(&adm_ctx, skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\nerr = nla_put_status_info(adm_ctx.reply_skb, adm_ctx.device, NULL);\r\nif (err) {\r\nnlmsg_free(adm_ctx.reply_skb);\r\nreturn err;\r\n}\r\nout:\r\ndrbd_adm_finish(&adm_ctx, info, retcode);\r\nreturn 0;\r\n}\r\nstatic int get_one_status(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct drbd_device *device;\r\nstruct drbd_genlmsghdr *dh;\r\nstruct drbd_resource *pos = (struct drbd_resource *)cb->args[0];\r\nstruct drbd_resource *resource = NULL;\r\nstruct drbd_resource *tmp;\r\nunsigned volume = cb->args[1];\r\nrcu_read_lock();\r\nfor_each_resource_rcu(tmp, &drbd_resources) {\r\nif (pos == NULL) {\r\npos = tmp;\r\nresource = pos;\r\nbreak;\r\n}\r\nif (tmp == pos) {\r\nresource = pos;\r\nbreak;\r\n}\r\n}\r\nif (resource) {\r\nnext_resource:\r\ndevice = idr_get_next(&resource->devices, &volume);\r\nif (!device) {\r\npos = list_entry_rcu(resource->resources.next,\r\nstruct drbd_resource, resources);\r\nif (volume != 0) {\r\nif (&pos->resources == &drbd_resources || cb->args[2])\r\ngoto out;\r\nvolume = 0;\r\nresource = pos;\r\ngoto next_resource;\r\n}\r\n}\r\ndh = genlmsg_put(skb, NETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, &drbd_genl_family,\r\nNLM_F_MULTI, DRBD_ADM_GET_STATUS);\r\nif (!dh)\r\ngoto out;\r\nif (!device) {\r\nstruct drbd_connection *connection;\r\ndh->minor = -1U;\r\ndh->ret_code = NO_ERROR;\r\nconnection = the_only_connection(resource);\r\nif (nla_put_drbd_cfg_context(skb, resource, connection, NULL))\r\ngoto cancel;\r\nif (connection) {\r\nstruct net_conf *nc;\r\nnc = rcu_dereference(connection->net_conf);\r\nif (nc && net_conf_to_skb(skb, nc, 1) != 0)\r\ngoto cancel;\r\n}\r\ngoto done;\r\n}\r\nD_ASSERT(device, device->vnr == volume);\r\nD_ASSERT(device, device->resource == resource);\r\ndh->minor = device_to_minor(device);\r\ndh->ret_code = NO_ERROR;\r\nif (nla_put_status_info(skb, device, NULL)) {\r\ncancel:\r\ngenlmsg_cancel(skb, dh);\r\ngoto out;\r\n}\r\ndone:\r\ngenlmsg_end(skb, dh);\r\n}\r\nout:\r\nrcu_read_unlock();\r\ncb->args[0] = (long)pos;\r\ncb->args[1] = (pos == resource) ? volume + 1 : 0;\r\nreturn skb->len;\r\n}\r\nint drbd_adm_get_status_all(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nconst unsigned hdrlen = GENL_HDRLEN + GENL_MAGIC_FAMILY_HDRSZ;\r\nstruct nlattr *nla;\r\nconst char *resource_name;\r\nstruct drbd_resource *resource;\r\nint maxtype;\r\nif (cb->args[0]) {\r\nif (cb->args[2] && cb->args[2] != cb->args[0])\r\nreturn 0;\r\ngoto dump;\r\n}\r\nnla = nla_find(nlmsg_attrdata(cb->nlh, hdrlen),\r\nnlmsg_attrlen(cb->nlh, hdrlen),\r\nDRBD_NLA_CFG_CONTEXT);\r\nif (!nla)\r\ngoto dump;\r\nmaxtype = ARRAY_SIZE(drbd_cfg_context_nl_policy) - 1;\r\nnla = drbd_nla_find_nested(maxtype, nla, __nla_type(T_ctx_resource_name));\r\nif (IS_ERR(nla))\r\nreturn PTR_ERR(nla);\r\nif (!nla)\r\nreturn -EINVAL;\r\nresource_name = nla_data(nla);\r\nif (!*resource_name)\r\nreturn -ENODEV;\r\nresource = drbd_find_resource(resource_name);\r\nif (!resource)\r\nreturn -ENODEV;\r\nkref_put(&resource->kref, drbd_destroy_resource);\r\ncb->args[0] = (long)resource;\r\ncb->args[2] = (long)resource;\r\ndump:\r\nreturn get_one_status(skb, cb);\r\n}\r\nint drbd_adm_get_timeout_type(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct drbd_config_context adm_ctx;\r\nenum drbd_ret_code retcode;\r\nstruct timeout_parms tp;\r\nint err;\r\nretcode = drbd_adm_prepare(&adm_ctx, skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\ntp.timeout_type =\r\nadm_ctx.device->state.pdsk == D_OUTDATED ? UT_PEER_OUTDATED :\r\ntest_bit(USE_DEGR_WFC_T, &adm_ctx.device->flags) ? UT_DEGRADED :\r\nUT_DEFAULT;\r\nerr = timeout_parms_to_priv_skb(adm_ctx.reply_skb, &tp);\r\nif (err) {\r\nnlmsg_free(adm_ctx.reply_skb);\r\nreturn err;\r\n}\r\nout:\r\ndrbd_adm_finish(&adm_ctx, info, retcode);\r\nreturn 0;\r\n}\r\nint drbd_adm_start_ov(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct drbd_config_context adm_ctx;\r\nstruct drbd_device *device;\r\nenum drbd_ret_code retcode;\r\nstruct start_ov_parms parms;\r\nretcode = drbd_adm_prepare(&adm_ctx, skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\ndevice = adm_ctx.device;\r\nparms.ov_start_sector = device->ov_start_sector;\r\nparms.ov_stop_sector = ULLONG_MAX;\r\nif (info->attrs[DRBD_NLA_START_OV_PARMS]) {\r\nint err = start_ov_parms_from_attrs(&parms, info);\r\nif (err) {\r\nretcode = ERR_MANDATORY_TAG;\r\ndrbd_msg_put_info(adm_ctx.reply_skb, from_attrs_err_to_txt(err));\r\ngoto out;\r\n}\r\n}\r\nmutex_lock(&adm_ctx.resource->adm_mutex);\r\ndevice->ov_start_sector = parms.ov_start_sector & ~(BM_SECT_PER_BIT-1);\r\ndevice->ov_stop_sector = parms.ov_stop_sector;\r\ndrbd_suspend_io(device);\r\nwait_event(device->misc_wait, !test_bit(BITMAP_IO, &device->flags));\r\nretcode = drbd_request_state(device, NS(conn, C_VERIFY_S));\r\ndrbd_resume_io(device);\r\nmutex_unlock(&adm_ctx.resource->adm_mutex);\r\nout:\r\ndrbd_adm_finish(&adm_ctx, info, retcode);\r\nreturn 0;\r\n}\r\nint drbd_adm_new_c_uuid(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct drbd_config_context adm_ctx;\r\nstruct drbd_device *device;\r\nenum drbd_ret_code retcode;\r\nint skip_initial_sync = 0;\r\nint err;\r\nstruct new_c_uuid_parms args;\r\nretcode = drbd_adm_prepare(&adm_ctx, skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out_nolock;\r\ndevice = adm_ctx.device;\r\nmemset(&args, 0, sizeof(args));\r\nif (info->attrs[DRBD_NLA_NEW_C_UUID_PARMS]) {\r\nerr = new_c_uuid_parms_from_attrs(&args, info);\r\nif (err) {\r\nretcode = ERR_MANDATORY_TAG;\r\ndrbd_msg_put_info(adm_ctx.reply_skb, from_attrs_err_to_txt(err));\r\ngoto out_nolock;\r\n}\r\n}\r\nmutex_lock(&adm_ctx.resource->adm_mutex);\r\nmutex_lock(device->state_mutex);\r\nif (!get_ldev(device)) {\r\nretcode = ERR_NO_DISK;\r\ngoto out;\r\n}\r\nif (device->state.conn == C_CONNECTED &&\r\nfirst_peer_device(device)->connection->agreed_pro_version >= 90 &&\r\ndevice->ldev->md.uuid[UI_CURRENT] == UUID_JUST_CREATED && args.clear_bm) {\r\ndrbd_info(device, "Preparing to skip initial sync\n");\r\nskip_initial_sync = 1;\r\n} else if (device->state.conn != C_STANDALONE) {\r\nretcode = ERR_CONNECTED;\r\ngoto out_dec;\r\n}\r\ndrbd_uuid_set(device, UI_BITMAP, 0);\r\ndrbd_uuid_new_current(device);\r\nif (args.clear_bm) {\r\nerr = drbd_bitmap_io(device, &drbd_bmio_clear_n_write,\r\n"clear_n_write from new_c_uuid", BM_LOCKED_MASK);\r\nif (err) {\r\ndrbd_err(device, "Writing bitmap failed with %d\n", err);\r\nretcode = ERR_IO_MD_DISK;\r\n}\r\nif (skip_initial_sync) {\r\ndrbd_send_uuids_skip_initial_sync(first_peer_device(device));\r\n_drbd_uuid_set(device, UI_BITMAP, 0);\r\ndrbd_print_uuids(device, "cleared bitmap UUID");\r\nspin_lock_irq(&device->resource->req_lock);\r\n_drbd_set_state(_NS2(device, disk, D_UP_TO_DATE, pdsk, D_UP_TO_DATE),\r\nCS_VERBOSE, NULL);\r\nspin_unlock_irq(&device->resource->req_lock);\r\n}\r\n}\r\ndrbd_md_sync(device);\r\nout_dec:\r\nput_ldev(device);\r\nout:\r\nmutex_unlock(device->state_mutex);\r\nmutex_unlock(&adm_ctx.resource->adm_mutex);\r\nout_nolock:\r\ndrbd_adm_finish(&adm_ctx, info, retcode);\r\nreturn 0;\r\n}\r\nstatic enum drbd_ret_code\r\ndrbd_check_resource_name(struct drbd_config_context *adm_ctx)\r\n{\r\nconst char *name = adm_ctx->resource_name;\r\nif (!name || !name[0]) {\r\ndrbd_msg_put_info(adm_ctx->reply_skb, "resource name missing");\r\nreturn ERR_MANDATORY_TAG;\r\n}\r\nif (strchr(name, '/')) {\r\ndrbd_msg_put_info(adm_ctx->reply_skb, "invalid resource name");\r\nreturn ERR_INVALID_REQUEST;\r\n}\r\nreturn NO_ERROR;\r\n}\r\nint drbd_adm_new_resource(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct drbd_config_context adm_ctx;\r\nenum drbd_ret_code retcode;\r\nstruct res_opts res_opts;\r\nint err;\r\nretcode = drbd_adm_prepare(&adm_ctx, skb, info, 0);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\nset_res_opts_defaults(&res_opts);\r\nerr = res_opts_from_attrs(&res_opts, info);\r\nif (err && err != -ENOMSG) {\r\nretcode = ERR_MANDATORY_TAG;\r\ndrbd_msg_put_info(adm_ctx.reply_skb, from_attrs_err_to_txt(err));\r\ngoto out;\r\n}\r\nretcode = drbd_check_resource_name(&adm_ctx);\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\nif (adm_ctx.resource) {\r\nif (info->nlhdr->nlmsg_flags & NLM_F_EXCL) {\r\nretcode = ERR_INVALID_REQUEST;\r\ndrbd_msg_put_info(adm_ctx.reply_skb, "resource exists");\r\n}\r\ngoto out;\r\n}\r\nif (!conn_create(adm_ctx.resource_name, &res_opts))\r\nretcode = ERR_NOMEM;\r\nout:\r\ndrbd_adm_finish(&adm_ctx, info, retcode);\r\nreturn 0;\r\n}\r\nint drbd_adm_new_minor(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct drbd_config_context adm_ctx;\r\nstruct drbd_genlmsghdr *dh = info->userhdr;\r\nenum drbd_ret_code retcode;\r\nretcode = drbd_adm_prepare(&adm_ctx, skb, info, DRBD_ADM_NEED_RESOURCE);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\nif (dh->minor > MINORMASK) {\r\ndrbd_msg_put_info(adm_ctx.reply_skb, "requested minor out of range");\r\nretcode = ERR_INVALID_REQUEST;\r\ngoto out;\r\n}\r\nif (adm_ctx.volume > DRBD_VOLUME_MAX) {\r\ndrbd_msg_put_info(adm_ctx.reply_skb, "requested volume id out of range");\r\nretcode = ERR_INVALID_REQUEST;\r\ngoto out;\r\n}\r\nif (adm_ctx.device) {\r\nif (info->nlhdr->nlmsg_flags & NLM_F_EXCL)\r\nretcode = ERR_MINOR_OR_VOLUME_EXISTS;\r\ngoto out;\r\n}\r\nmutex_lock(&adm_ctx.resource->adm_mutex);\r\nretcode = drbd_create_device(&adm_ctx, dh->minor);\r\nmutex_unlock(&adm_ctx.resource->adm_mutex);\r\nout:\r\ndrbd_adm_finish(&adm_ctx, info, retcode);\r\nreturn 0;\r\n}\r\nstatic enum drbd_ret_code adm_del_minor(struct drbd_device *device)\r\n{\r\nif (device->state.disk == D_DISKLESS &&\r\ndevice->state.role == R_SECONDARY) {\r\n_drbd_request_state(device, NS(conn, C_WF_REPORT_PARAMS),\r\nCS_VERBOSE + CS_WAIT_COMPLETE);\r\ndrbd_delete_device(device);\r\nreturn NO_ERROR;\r\n} else\r\nreturn ERR_MINOR_CONFIGURED;\r\n}\r\nint drbd_adm_del_minor(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct drbd_config_context adm_ctx;\r\nenum drbd_ret_code retcode;\r\nretcode = drbd_adm_prepare(&adm_ctx, skb, info, DRBD_ADM_NEED_MINOR);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto out;\r\nmutex_lock(&adm_ctx.resource->adm_mutex);\r\nretcode = adm_del_minor(adm_ctx.device);\r\nmutex_unlock(&adm_ctx.resource->adm_mutex);\r\nout:\r\ndrbd_adm_finish(&adm_ctx, info, retcode);\r\nreturn 0;\r\n}\r\nstatic int adm_del_resource(struct drbd_resource *resource)\r\n{\r\nstruct drbd_connection *connection;\r\nfor_each_connection(connection, resource) {\r\nif (connection->cstate > C_STANDALONE)\r\nreturn ERR_NET_CONFIGURED;\r\n}\r\nif (!idr_is_empty(&resource->devices))\r\nreturn ERR_RES_IN_USE;\r\nlist_del_rcu(&resource->resources);\r\nlist_for_each_entry(connection, &resource->connections, connections)\r\ndrbd_thread_stop(&connection->worker);\r\nsynchronize_rcu();\r\ndrbd_free_resource(resource);\r\nreturn NO_ERROR;\r\n}\r\nint drbd_adm_down(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct drbd_config_context adm_ctx;\r\nstruct drbd_resource *resource;\r\nstruct drbd_connection *connection;\r\nstruct drbd_device *device;\r\nint retcode;\r\nunsigned i;\r\nretcode = drbd_adm_prepare(&adm_ctx, skb, info, DRBD_ADM_NEED_RESOURCE);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto finish;\r\nresource = adm_ctx.resource;\r\nmutex_lock(&resource->adm_mutex);\r\nfor_each_connection(connection, resource) {\r\nstruct drbd_peer_device *peer_device;\r\nidr_for_each_entry(&connection->peer_devices, peer_device, i) {\r\nretcode = drbd_set_role(peer_device->device, R_SECONDARY, 0);\r\nif (retcode < SS_SUCCESS) {\r\ndrbd_msg_put_info(adm_ctx.reply_skb, "failed to demote");\r\ngoto out;\r\n}\r\n}\r\nretcode = conn_try_disconnect(connection, 0);\r\nif (retcode < SS_SUCCESS) {\r\ndrbd_msg_put_info(adm_ctx.reply_skb, "failed to disconnect");\r\ngoto out;\r\n}\r\n}\r\nidr_for_each_entry(&resource->devices, device, i) {\r\nretcode = adm_detach(device, 0);\r\nif (retcode < SS_SUCCESS || retcode > NO_ERROR) {\r\ndrbd_msg_put_info(adm_ctx.reply_skb, "failed to detach");\r\ngoto out;\r\n}\r\n}\r\nidr_for_each_entry(&resource->devices, device, i) {\r\nretcode = adm_del_minor(device);\r\nif (retcode != NO_ERROR) {\r\ndrbd_msg_put_info(adm_ctx.reply_skb, "failed to delete volume");\r\ngoto out;\r\n}\r\n}\r\nretcode = adm_del_resource(resource);\r\nout:\r\nmutex_unlock(&resource->adm_mutex);\r\nfinish:\r\ndrbd_adm_finish(&adm_ctx, info, retcode);\r\nreturn 0;\r\n}\r\nint drbd_adm_del_resource(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct drbd_config_context adm_ctx;\r\nstruct drbd_resource *resource;\r\nenum drbd_ret_code retcode;\r\nretcode = drbd_adm_prepare(&adm_ctx, skb, info, DRBD_ADM_NEED_RESOURCE);\r\nif (!adm_ctx.reply_skb)\r\nreturn retcode;\r\nif (retcode != NO_ERROR)\r\ngoto finish;\r\nresource = adm_ctx.resource;\r\nmutex_lock(&resource->adm_mutex);\r\nretcode = adm_del_resource(resource);\r\nmutex_unlock(&resource->adm_mutex);\r\nfinish:\r\ndrbd_adm_finish(&adm_ctx, info, retcode);\r\nreturn 0;\r\n}\r\nvoid drbd_bcast_event(struct drbd_device *device, const struct sib_info *sib)\r\n{\r\nstatic atomic_t drbd_genl_seq = ATOMIC_INIT(2);\r\nstruct sk_buff *msg;\r\nstruct drbd_genlmsghdr *d_out;\r\nunsigned seq;\r\nint err = -ENOMEM;\r\nseq = atomic_inc_return(&drbd_genl_seq);\r\nmsg = genlmsg_new(NLMSG_GOODSIZE, GFP_NOIO);\r\nif (!msg)\r\ngoto failed;\r\nerr = -EMSGSIZE;\r\nd_out = genlmsg_put(msg, 0, seq, &drbd_genl_family, 0, DRBD_EVENT);\r\nif (!d_out)\r\ngoto nla_put_failure;\r\nd_out->minor = device_to_minor(device);\r\nd_out->ret_code = NO_ERROR;\r\nif (nla_put_status_info(msg, device, sib))\r\ngoto nla_put_failure;\r\ngenlmsg_end(msg, d_out);\r\nerr = drbd_genl_multicast_events(msg, 0);\r\nif (err && err != -ESRCH)\r\ngoto failed;\r\nreturn;\r\nnla_put_failure:\r\nnlmsg_free(msg);\r\nfailed:\r\ndrbd_err(device, "Error %d while broadcasting event. "\r\n"Event seq:%u sib_reason:%u\n",\r\nerr, seq, sib->sib_reason);\r\n}
