static inline struct jz4780_dma_chan *to_jz4780_dma_chan(struct dma_chan *chan)\r\n{\r\nreturn container_of(chan, struct jz4780_dma_chan, vchan.chan);\r\n}\r\nstatic inline struct jz4780_dma_desc *to_jz4780_dma_desc(\r\nstruct virt_dma_desc *vdesc)\r\n{\r\nreturn container_of(vdesc, struct jz4780_dma_desc, vdesc);\r\n}\r\nstatic inline struct jz4780_dma_dev *jz4780_dma_chan_parent(\r\nstruct jz4780_dma_chan *jzchan)\r\n{\r\nreturn container_of(jzchan->vchan.chan.device, struct jz4780_dma_dev,\r\ndma_device);\r\n}\r\nstatic inline uint32_t jz4780_dma_readl(struct jz4780_dma_dev *jzdma,\r\nunsigned int reg)\r\n{\r\nreturn readl(jzdma->base + reg);\r\n}\r\nstatic inline void jz4780_dma_writel(struct jz4780_dma_dev *jzdma,\r\nunsigned int reg, uint32_t val)\r\n{\r\nwritel(val, jzdma->base + reg);\r\n}\r\nstatic struct jz4780_dma_desc *jz4780_dma_desc_alloc(\r\nstruct jz4780_dma_chan *jzchan, unsigned int count,\r\nenum dma_transaction_type type)\r\n{\r\nstruct jz4780_dma_desc *desc;\r\nif (count > JZ_DMA_MAX_DESC)\r\nreturn NULL;\r\ndesc = kzalloc(sizeof(*desc), GFP_NOWAIT);\r\nif (!desc)\r\nreturn NULL;\r\ndesc->desc = dma_pool_alloc(jzchan->desc_pool, GFP_NOWAIT,\r\n&desc->desc_phys);\r\nif (!desc->desc) {\r\nkfree(desc);\r\nreturn NULL;\r\n}\r\ndesc->count = count;\r\ndesc->type = type;\r\nreturn desc;\r\n}\r\nstatic void jz4780_dma_desc_free(struct virt_dma_desc *vdesc)\r\n{\r\nstruct jz4780_dma_desc *desc = to_jz4780_dma_desc(vdesc);\r\nstruct jz4780_dma_chan *jzchan = to_jz4780_dma_chan(vdesc->tx.chan);\r\ndma_pool_free(jzchan->desc_pool, desc->desc, desc->desc_phys);\r\nkfree(desc);\r\n}\r\nstatic uint32_t jz4780_dma_transfer_size(unsigned long val, int *ord)\r\n{\r\n*ord = ffs(val) - 1;\r\nswitch (*ord) {\r\ncase 0:\r\nreturn JZ_DMA_SIZE_1_BYTE;\r\ncase 1:\r\nreturn JZ_DMA_SIZE_2_BYTE;\r\ncase 2:\r\nreturn JZ_DMA_SIZE_4_BYTE;\r\ncase 4:\r\nreturn JZ_DMA_SIZE_16_BYTE;\r\ncase 5:\r\nreturn JZ_DMA_SIZE_32_BYTE;\r\ncase 6:\r\nreturn JZ_DMA_SIZE_64_BYTE;\r\ncase 7:\r\nreturn JZ_DMA_SIZE_128_BYTE;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic uint32_t jz4780_dma_setup_hwdesc(struct jz4780_dma_chan *jzchan,\r\nstruct jz4780_dma_hwdesc *desc, dma_addr_t addr, size_t len,\r\nenum dma_transfer_direction direction)\r\n{\r\nstruct dma_slave_config *config = &jzchan->config;\r\nuint32_t width, maxburst, tsz;\r\nint ord;\r\nif (direction == DMA_MEM_TO_DEV) {\r\ndesc->dcm = JZ_DMA_DCM_SAI;\r\ndesc->dsa = addr;\r\ndesc->dta = config->dst_addr;\r\ndesc->drt = jzchan->transfer_type;\r\nwidth = config->dst_addr_width;\r\nmaxburst = config->dst_maxburst;\r\n} else {\r\ndesc->dcm = JZ_DMA_DCM_DAI;\r\ndesc->dsa = config->src_addr;\r\ndesc->dta = addr;\r\ndesc->drt = jzchan->transfer_type;\r\nwidth = config->src_addr_width;\r\nmaxburst = config->src_maxburst;\r\n}\r\ntsz = jz4780_dma_transfer_size(addr | len | (width * maxburst), &ord);\r\njzchan->transfer_shift = ord;\r\nswitch (width) {\r\ncase DMA_SLAVE_BUSWIDTH_1_BYTE:\r\ncase DMA_SLAVE_BUSWIDTH_2_BYTES:\r\nbreak;\r\ncase DMA_SLAVE_BUSWIDTH_4_BYTES:\r\nwidth = JZ_DMA_WIDTH_32_BIT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndesc->dcm |= tsz << JZ_DMA_DCM_TSZ_SHIFT;\r\ndesc->dcm |= width << JZ_DMA_DCM_SP_SHIFT;\r\ndesc->dcm |= width << JZ_DMA_DCM_DP_SHIFT;\r\ndesc->dtc = len >> ord;\r\n}\r\nstatic struct dma_async_tx_descriptor *jz4780_dma_prep_slave_sg(\r\nstruct dma_chan *chan, struct scatterlist *sgl, unsigned int sg_len,\r\nenum dma_transfer_direction direction, unsigned long flags)\r\n{\r\nstruct jz4780_dma_chan *jzchan = to_jz4780_dma_chan(chan);\r\nstruct jz4780_dma_desc *desc;\r\nunsigned int i;\r\nint err;\r\ndesc = jz4780_dma_desc_alloc(jzchan, sg_len, DMA_SLAVE);\r\nif (!desc)\r\nreturn NULL;\r\nfor (i = 0; i < sg_len; i++) {\r\nerr = jz4780_dma_setup_hwdesc(jzchan, &desc->desc[i],\r\nsg_dma_address(&sgl[i]),\r\nsg_dma_len(&sgl[i]),\r\ndirection);\r\nif (err < 0)\r\nreturn ERR_PTR(err);\r\ndesc->desc[i].dcm |= JZ_DMA_DCM_TIE;\r\nif (i != (sg_len - 1)) {\r\ndesc->desc[i].dcm |= JZ_DMA_DCM_LINK;\r\ndesc->desc[i].dtc |=\r\n(((i + 1) * sizeof(*desc->desc)) >> 4) << 24;\r\n}\r\n}\r\nreturn vchan_tx_prep(&jzchan->vchan, &desc->vdesc, flags);\r\n}\r\nstatic struct dma_async_tx_descriptor *jz4780_dma_prep_dma_cyclic(\r\nstruct dma_chan *chan, dma_addr_t buf_addr, size_t buf_len,\r\nsize_t period_len, enum dma_transfer_direction direction,\r\nunsigned long flags)\r\n{\r\nstruct jz4780_dma_chan *jzchan = to_jz4780_dma_chan(chan);\r\nstruct jz4780_dma_desc *desc;\r\nunsigned int periods, i;\r\nint err;\r\nif (buf_len % period_len)\r\nreturn NULL;\r\nperiods = buf_len / period_len;\r\ndesc = jz4780_dma_desc_alloc(jzchan, periods, DMA_CYCLIC);\r\nif (!desc)\r\nreturn NULL;\r\nfor (i = 0; i < periods; i++) {\r\nerr = jz4780_dma_setup_hwdesc(jzchan, &desc->desc[i], buf_addr,\r\nperiod_len, direction);\r\nif (err < 0)\r\nreturn ERR_PTR(err);\r\nbuf_addr += period_len;\r\ndesc->desc[i].dcm |= JZ_DMA_DCM_TIE | JZ_DMA_DCM_LINK;\r\nif (i != (periods - 1)) {\r\ndesc->desc[i].dtc |=\r\n(((i + 1) * sizeof(*desc->desc)) >> 4) << 24;\r\n}\r\n}\r\nreturn vchan_tx_prep(&jzchan->vchan, &desc->vdesc, flags);\r\n}\r\nstruct dma_async_tx_descriptor *jz4780_dma_prep_dma_memcpy(\r\nstruct dma_chan *chan, dma_addr_t dest, dma_addr_t src,\r\nsize_t len, unsigned long flags)\r\n{\r\nstruct jz4780_dma_chan *jzchan = to_jz4780_dma_chan(chan);\r\nstruct jz4780_dma_desc *desc;\r\nuint32_t tsz;\r\nint ord;\r\ndesc = jz4780_dma_desc_alloc(jzchan, 1, DMA_MEMCPY);\r\nif (!desc)\r\nreturn NULL;\r\ntsz = jz4780_dma_transfer_size(dest | src | len, &ord);\r\nif (tsz < 0)\r\nreturn ERR_PTR(tsz);\r\ndesc->desc[0].dsa = src;\r\ndesc->desc[0].dta = dest;\r\ndesc->desc[0].drt = JZ_DMA_DRT_AUTO;\r\ndesc->desc[0].dcm = JZ_DMA_DCM_TIE | JZ_DMA_DCM_SAI | JZ_DMA_DCM_DAI |\r\ntsz << JZ_DMA_DCM_TSZ_SHIFT |\r\nJZ_DMA_WIDTH_32_BIT << JZ_DMA_DCM_SP_SHIFT |\r\nJZ_DMA_WIDTH_32_BIT << JZ_DMA_DCM_DP_SHIFT;\r\ndesc->desc[0].dtc = len >> ord;\r\nreturn vchan_tx_prep(&jzchan->vchan, &desc->vdesc, flags);\r\n}\r\nstatic void jz4780_dma_begin(struct jz4780_dma_chan *jzchan)\r\n{\r\nstruct jz4780_dma_dev *jzdma = jz4780_dma_chan_parent(jzchan);\r\nstruct virt_dma_desc *vdesc;\r\nunsigned int i;\r\ndma_addr_t desc_phys;\r\nif (!jzchan->desc) {\r\nvdesc = vchan_next_desc(&jzchan->vchan);\r\nif (!vdesc)\r\nreturn;\r\nlist_del(&vdesc->node);\r\njzchan->desc = to_jz4780_dma_desc(vdesc);\r\njzchan->curr_hwdesc = 0;\r\nif (jzchan->desc->type == DMA_CYCLIC && vdesc->tx.callback) {\r\nfor (i = 0; i < jzchan->desc->count; i++)\r\njzchan->desc->desc[i].dcm &= ~JZ_DMA_DCM_LINK;\r\n}\r\n} else {\r\njzchan->curr_hwdesc =\r\n(jzchan->curr_hwdesc + 1) % jzchan->desc->count;\r\n}\r\njz4780_dma_writel(jzdma, JZ_DMA_REG_DCS(jzchan->id), JZ_DMA_DCS_DES8);\r\ndesc_phys = jzchan->desc->desc_phys +\r\n(jzchan->curr_hwdesc * sizeof(*jzchan->desc->desc));\r\njz4780_dma_writel(jzdma, JZ_DMA_REG_DDA(jzchan->id), desc_phys);\r\njz4780_dma_writel(jzdma, JZ_DMA_REG_DDRS, BIT(jzchan->id));\r\njz4780_dma_writel(jzdma, JZ_DMA_REG_DCS(jzchan->id),\r\nJZ_DMA_DCS_DES8 | JZ_DMA_DCS_CTE);\r\n}\r\nstatic void jz4780_dma_issue_pending(struct dma_chan *chan)\r\n{\r\nstruct jz4780_dma_chan *jzchan = to_jz4780_dma_chan(chan);\r\nunsigned long flags;\r\nspin_lock_irqsave(&jzchan->vchan.lock, flags);\r\nif (vchan_issue_pending(&jzchan->vchan) && !jzchan->desc)\r\njz4780_dma_begin(jzchan);\r\nspin_unlock_irqrestore(&jzchan->vchan.lock, flags);\r\n}\r\nstatic int jz4780_dma_terminate_all(struct jz4780_dma_chan *jzchan)\r\n{\r\nstruct jz4780_dma_dev *jzdma = jz4780_dma_chan_parent(jzchan);\r\nunsigned long flags;\r\nLIST_HEAD(head);\r\nspin_lock_irqsave(&jzchan->vchan.lock, flags);\r\njz4780_dma_writel(jzdma, JZ_DMA_REG_DCS(jzchan->id), 0);\r\nif (jzchan->desc) {\r\njz4780_dma_desc_free(&jzchan->desc->vdesc);\r\njzchan->desc = NULL;\r\n}\r\nvchan_get_all_descriptors(&jzchan->vchan, &head);\r\nspin_unlock_irqrestore(&jzchan->vchan.lock, flags);\r\nvchan_dma_desc_free_list(&jzchan->vchan, &head);\r\nreturn 0;\r\n}\r\nstatic int jz4780_dma_slave_config(struct jz4780_dma_chan *jzchan,\r\nconst struct dma_slave_config *config)\r\n{\r\nif ((config->src_addr_width == DMA_SLAVE_BUSWIDTH_8_BYTES)\r\n|| (config->dst_addr_width == DMA_SLAVE_BUSWIDTH_8_BYTES))\r\nreturn -EINVAL;\r\nmemcpy(&jzchan->config, config, sizeof(jzchan->config));\r\nreturn 0;\r\n}\r\nstatic size_t jz4780_dma_desc_residue(struct jz4780_dma_chan *jzchan,\r\nstruct jz4780_dma_desc *desc, unsigned int next_sg)\r\n{\r\nstruct jz4780_dma_dev *jzdma = jz4780_dma_chan_parent(jzchan);\r\nunsigned int residue, count;\r\nunsigned int i;\r\nresidue = 0;\r\nfor (i = next_sg; i < desc->count; i++)\r\nresidue += desc->desc[i].dtc << jzchan->transfer_shift;\r\nif (next_sg != 0) {\r\ncount = jz4780_dma_readl(jzdma,\r\nJZ_DMA_REG_DTC(jzchan->id));\r\nresidue += count << jzchan->transfer_shift;\r\n}\r\nreturn residue;\r\n}\r\nstatic enum dma_status jz4780_dma_tx_status(struct dma_chan *chan,\r\ndma_cookie_t cookie, struct dma_tx_state *txstate)\r\n{\r\nstruct jz4780_dma_chan *jzchan = to_jz4780_dma_chan(chan);\r\nstruct virt_dma_desc *vdesc;\r\nenum dma_status status;\r\nunsigned long flags;\r\nstatus = dma_cookie_status(chan, cookie, txstate);\r\nif ((status == DMA_COMPLETE) || (txstate == NULL))\r\nreturn status;\r\nspin_lock_irqsave(&jzchan->vchan.lock, flags);\r\nvdesc = vchan_find_desc(&jzchan->vchan, cookie);\r\nif (vdesc) {\r\ntxstate->residue = jz4780_dma_desc_residue(jzchan,\r\nto_jz4780_dma_desc(vdesc), 0);\r\n} else if (cookie == jzchan->desc->vdesc.tx.cookie) {\r\ntxstate->residue = jz4780_dma_desc_residue(jzchan, jzchan->desc,\r\n(jzchan->curr_hwdesc + 1) % jzchan->desc->count);\r\n} else\r\ntxstate->residue = 0;\r\nif (vdesc && jzchan->desc && vdesc == &jzchan->desc->vdesc\r\n&& jzchan->desc->status & (JZ_DMA_DCS_AR | JZ_DMA_DCS_HLT))\r\nstatus = DMA_ERROR;\r\nspin_unlock_irqrestore(&jzchan->vchan.lock, flags);\r\nreturn status;\r\n}\r\nstatic void jz4780_dma_chan_irq(struct jz4780_dma_dev *jzdma,\r\nstruct jz4780_dma_chan *jzchan)\r\n{\r\nuint32_t dcs;\r\nspin_lock(&jzchan->vchan.lock);\r\ndcs = jz4780_dma_readl(jzdma, JZ_DMA_REG_DCS(jzchan->id));\r\njz4780_dma_writel(jzdma, JZ_DMA_REG_DCS(jzchan->id), 0);\r\nif (dcs & JZ_DMA_DCS_AR) {\r\ndev_warn(&jzchan->vchan.chan.dev->device,\r\n"address error (DCS=0x%x)\n", dcs);\r\n}\r\nif (dcs & JZ_DMA_DCS_HLT) {\r\ndev_warn(&jzchan->vchan.chan.dev->device,\r\n"channel halt (DCS=0x%x)\n", dcs);\r\n}\r\nif (jzchan->desc) {\r\njzchan->desc->status = dcs;\r\nif ((dcs & (JZ_DMA_DCS_AR | JZ_DMA_DCS_HLT)) == 0) {\r\nif (jzchan->desc->type == DMA_CYCLIC) {\r\nvchan_cyclic_callback(&jzchan->desc->vdesc);\r\n} else {\r\nvchan_cookie_complete(&jzchan->desc->vdesc);\r\njzchan->desc = NULL;\r\n}\r\njz4780_dma_begin(jzchan);\r\n}\r\n} else {\r\ndev_err(&jzchan->vchan.chan.dev->device,\r\n"channel IRQ with no active transfer\n");\r\n}\r\nspin_unlock(&jzchan->vchan.lock);\r\n}\r\nstatic irqreturn_t jz4780_dma_irq_handler(int irq, void *data)\r\n{\r\nstruct jz4780_dma_dev *jzdma = data;\r\nuint32_t pending, dmac;\r\nint i;\r\npending = jz4780_dma_readl(jzdma, JZ_DMA_REG_DIRQP);\r\nfor (i = 0; i < JZ_DMA_NR_CHANNELS; i++) {\r\nif (!(pending & (1<<i)))\r\ncontinue;\r\njz4780_dma_chan_irq(jzdma, &jzdma->chan[i]);\r\n}\r\ndmac = jz4780_dma_readl(jzdma, JZ_DMA_REG_DMAC);\r\ndmac &= ~(JZ_DMA_DMAC_HLT | JZ_DMA_DMAC_AR);\r\njz4780_dma_writel(jzdma, JZ_DMA_REG_DMAC, dmac);\r\njz4780_dma_writel(jzdma, JZ_DMA_REG_DIRQP, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int jz4780_dma_alloc_chan_resources(struct dma_chan *chan)\r\n{\r\nstruct jz4780_dma_chan *jzchan = to_jz4780_dma_chan(chan);\r\njzchan->desc_pool = dma_pool_create(dev_name(&chan->dev->device),\r\nchan->device->dev,\r\nJZ_DMA_DESC_BLOCK_SIZE,\r\nPAGE_SIZE, 0);\r\nif (!jzchan->desc_pool) {\r\ndev_err(&chan->dev->device,\r\n"failed to allocate descriptor pool\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void jz4780_dma_free_chan_resources(struct dma_chan *chan)\r\n{\r\nstruct jz4780_dma_chan *jzchan = to_jz4780_dma_chan(chan);\r\nvchan_free_chan_resources(&jzchan->vchan);\r\ndma_pool_destroy(jzchan->desc_pool);\r\njzchan->desc_pool = NULL;\r\n}\r\nstatic bool jz4780_dma_filter_fn(struct dma_chan *chan, void *param)\r\n{\r\nstruct jz4780_dma_chan *jzchan = to_jz4780_dma_chan(chan);\r\nstruct jz4780_dma_dev *jzdma = jz4780_dma_chan_parent(jzchan);\r\nstruct jz4780_dma_data *data = param;\r\nif (data->channel > -1) {\r\nif (data->channel != jzchan->id)\r\nreturn false;\r\n} else if (jzdma->chan_reserved & BIT(jzchan->id)) {\r\nreturn false;\r\n}\r\njzchan->transfer_type = data->transfer_type;\r\nreturn true;\r\n}\r\nstatic struct dma_chan *jz4780_of_dma_xlate(struct of_phandle_args *dma_spec,\r\nstruct of_dma *ofdma)\r\n{\r\nstruct jz4780_dma_dev *jzdma = ofdma->of_dma_data;\r\ndma_cap_mask_t mask = jzdma->dma_device.cap_mask;\r\nstruct jz4780_dma_data data;\r\nif (dma_spec->args_count != 2)\r\nreturn NULL;\r\ndata.transfer_type = dma_spec->args[0];\r\ndata.channel = dma_spec->args[1];\r\nif (data.channel > -1) {\r\nif (data.channel >= JZ_DMA_NR_CHANNELS) {\r\ndev_err(jzdma->dma_device.dev,\r\n"device requested non-existent channel %u\n",\r\ndata.channel);\r\nreturn NULL;\r\n}\r\nif (!(jzdma->chan_reserved & BIT(data.channel))) {\r\ndev_err(jzdma->dma_device.dev,\r\n"device requested unreserved channel %u\n",\r\ndata.channel);\r\nreturn NULL;\r\n}\r\n}\r\nreturn dma_request_channel(mask, jz4780_dma_filter_fn, &data);\r\n}\r\nstatic int jz4780_dma_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct jz4780_dma_dev *jzdma;\r\nstruct jz4780_dma_chan *jzchan;\r\nstruct dma_device *dd;\r\nstruct resource *res;\r\nint i, ret;\r\njzdma = devm_kzalloc(dev, sizeof(*jzdma), GFP_KERNEL);\r\nif (!jzdma)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, jzdma);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(dev, "failed to get I/O memory\n");\r\nreturn -EINVAL;\r\n}\r\njzdma->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(jzdma->base))\r\nreturn PTR_ERR(jzdma->base);\r\njzdma->irq = platform_get_irq(pdev, 0);\r\nif (jzdma->irq < 0) {\r\ndev_err(dev, "failed to get IRQ: %d\n", ret);\r\nreturn jzdma->irq;\r\n}\r\nret = devm_request_irq(dev, jzdma->irq, jz4780_dma_irq_handler, 0,\r\ndev_name(dev), jzdma);\r\nif (ret) {\r\ndev_err(dev, "failed to request IRQ %u!\n", jzdma->irq);\r\nreturn -EINVAL;\r\n}\r\njzdma->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(jzdma->clk)) {\r\ndev_err(dev, "failed to get clock\n");\r\nreturn PTR_ERR(jzdma->clk);\r\n}\r\nclk_prepare_enable(jzdma->clk);\r\nof_property_read_u32_index(dev->of_node, "ingenic,reserved-channels",\r\n0, &jzdma->chan_reserved);\r\ndd = &jzdma->dma_device;\r\ndma_cap_set(DMA_MEMCPY, dd->cap_mask);\r\ndma_cap_set(DMA_SLAVE, dd->cap_mask);\r\ndma_cap_set(DMA_CYCLIC, dd->cap_mask);\r\ndd->dev = dev;\r\ndd->copy_align = 2;\r\ndd->device_alloc_chan_resources = jz4780_dma_alloc_chan_resources;\r\ndd->device_free_chan_resources = jz4780_dma_free_chan_resources;\r\ndd->device_prep_slave_sg = jz4780_dma_prep_slave_sg;\r\ndd->device_prep_dma_cyclic = jz4780_dma_prep_dma_cyclic;\r\ndd->device_prep_dma_memcpy = jz4780_dma_prep_dma_memcpy;\r\ndd->device_config = jz4780_dma_slave_config;\r\ndd->device_terminate_all = jz4780_dma_terminate_all;\r\ndd->device_tx_status = jz4780_dma_tx_status;\r\ndd->device_issue_pending = jz4780_dma_issue_pending;\r\ndd->src_addr_widths = JZ_DMA_BUSWIDTHS;\r\ndd->dst_addr_widths = JZ_DMA_BUSWIDTHS;\r\ndd->directions = BIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV);\r\ndd->residue_granularity = DMA_RESIDUE_GRANULARITY_BURST;\r\njz4780_dma_writel(jzdma, JZ_DMA_REG_DMAC,\r\nJZ_DMA_DMAC_DMAE | JZ_DMA_DMAC_FMSC);\r\njz4780_dma_writel(jzdma, JZ_DMA_REG_DMACP, 0);\r\nINIT_LIST_HEAD(&dd->channels);\r\nfor (i = 0; i < JZ_DMA_NR_CHANNELS; i++) {\r\njzchan = &jzdma->chan[i];\r\njzchan->id = i;\r\nvchan_init(&jzchan->vchan, dd);\r\njzchan->vchan.desc_free = jz4780_dma_desc_free;\r\n}\r\nret = dma_async_device_register(dd);\r\nif (ret) {\r\ndev_err(dev, "failed to register device\n");\r\ngoto err_disable_clk;\r\n}\r\nret = of_dma_controller_register(dev->of_node, jz4780_of_dma_xlate,\r\njzdma);\r\nif (ret) {\r\ndev_err(dev, "failed to register OF DMA controller\n");\r\ngoto err_unregister_dev;\r\n}\r\ndev_info(dev, "JZ4780 DMA controller initialised\n");\r\nreturn 0;\r\nerr_unregister_dev:\r\ndma_async_device_unregister(dd);\r\nerr_disable_clk:\r\nclk_disable_unprepare(jzdma->clk);\r\nreturn ret;\r\n}\r\nstatic int jz4780_dma_remove(struct platform_device *pdev)\r\n{\r\nstruct jz4780_dma_dev *jzdma = platform_get_drvdata(pdev);\r\nof_dma_controller_free(pdev->dev.of_node);\r\ndevm_free_irq(&pdev->dev, jzdma->irq, jzdma);\r\ndma_async_device_unregister(&jzdma->dma_device);\r\nreturn 0;\r\n}\r\nstatic int __init jz4780_dma_init(void)\r\n{\r\nreturn platform_driver_register(&jz4780_dma_driver);\r\n}\r\nstatic void __exit jz4780_dma_exit(void)\r\n{\r\nplatform_driver_unregister(&jz4780_dma_driver);\r\n}
