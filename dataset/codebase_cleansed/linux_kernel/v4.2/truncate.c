static int ufs_trunc_direct(struct inode *inode)\r\n{\r\nstruct ufs_inode_info *ufsi = UFS_I(inode);\r\nstruct super_block * sb;\r\nstruct ufs_sb_private_info * uspi;\r\nvoid *p;\r\nu64 frag1, frag2, frag3, frag4, block1, block2;\r\nunsigned frag_to_free, free_count;\r\nunsigned i, tmp;\r\nint retry;\r\nUFSD("ENTER: ino %lu\n", inode->i_ino);\r\nsb = inode->i_sb;\r\nuspi = UFS_SB(sb)->s_uspi;\r\nfrag_to_free = 0;\r\nfree_count = 0;\r\nretry = 0;\r\nfrag1 = DIRECT_FRAGMENT;\r\nfrag4 = min_t(u64, UFS_NDIR_FRAGMENT, ufsi->i_lastfrag);\r\nfrag2 = ((frag1 & uspi->s_fpbmask) ? ((frag1 | uspi->s_fpbmask) + 1) : frag1);\r\nfrag3 = frag4 & ~uspi->s_fpbmask;\r\nblock1 = block2 = 0;\r\nif (frag2 > frag3) {\r\nfrag2 = frag4;\r\nfrag3 = frag4 = 0;\r\n} else if (frag2 < frag3) {\r\nblock1 = ufs_fragstoblks (frag2);\r\nblock2 = ufs_fragstoblks (frag3);\r\n}\r\nUFSD("ino %lu, frag1 %llu, frag2 %llu, block1 %llu, block2 %llu,"\r\n" frag3 %llu, frag4 %llu\n", inode->i_ino,\r\n(unsigned long long)frag1, (unsigned long long)frag2,\r\n(unsigned long long)block1, (unsigned long long)block2,\r\n(unsigned long long)frag3, (unsigned long long)frag4);\r\nif (frag1 >= frag2)\r\ngoto next1;\r\np = ufs_get_direct_data_ptr(uspi, ufsi, ufs_fragstoblks(frag1));\r\ntmp = ufs_data_ptr_to_cpu(sb, p);\r\nif (!tmp )\r\nufs_panic (sb, "ufs_trunc_direct", "internal error");\r\nfrag2 -= frag1;\r\nfrag1 = ufs_fragnum (frag1);\r\nufs_free_fragments(inode, tmp + frag1, frag2);\r\nmark_inode_dirty(inode);\r\nfrag_to_free = tmp + frag1;\r\nnext1:\r\nfor (i = block1 ; i < block2; i++) {\r\np = ufs_get_direct_data_ptr(uspi, ufsi, i);\r\ntmp = ufs_data_ptr_to_cpu(sb, p);\r\nif (!tmp)\r\ncontinue;\r\nufs_data_ptr_clear(uspi, p);\r\nif (free_count == 0) {\r\nfrag_to_free = tmp;\r\nfree_count = uspi->s_fpb;\r\n} else if (free_count > 0 && frag_to_free == tmp - free_count)\r\nfree_count += uspi->s_fpb;\r\nelse {\r\nufs_free_blocks (inode, frag_to_free, free_count);\r\nfrag_to_free = tmp;\r\nfree_count = uspi->s_fpb;\r\n}\r\nmark_inode_dirty(inode);\r\n}\r\nif (free_count > 0)\r\nufs_free_blocks (inode, frag_to_free, free_count);\r\nif (frag3 >= frag4)\r\ngoto next3;\r\np = ufs_get_direct_data_ptr(uspi, ufsi, ufs_fragstoblks(frag3));\r\ntmp = ufs_data_ptr_to_cpu(sb, p);\r\nif (!tmp )\r\nufs_panic(sb, "ufs_truncate_direct", "internal error");\r\nfrag4 = ufs_fragnum (frag4);\r\nufs_data_ptr_clear(uspi, p);\r\nufs_free_fragments (inode, tmp, frag4);\r\nmark_inode_dirty(inode);\r\nnext3:\r\nUFSD("EXIT: ino %lu\n", inode->i_ino);\r\nreturn retry;\r\n}\r\nstatic int ufs_trunc_indirect(struct inode *inode, u64 offset, void *p)\r\n{\r\nstruct super_block * sb;\r\nstruct ufs_sb_private_info * uspi;\r\nstruct ufs_buffer_head * ind_ubh;\r\nvoid *ind;\r\nu64 tmp, indirect_block, i, frag_to_free;\r\nunsigned free_count;\r\nint retry;\r\nUFSD("ENTER: ino %lu, offset %llu, p: %p\n",\r\ninode->i_ino, (unsigned long long)offset, p);\r\nBUG_ON(!p);\r\nsb = inode->i_sb;\r\nuspi = UFS_SB(sb)->s_uspi;\r\nfrag_to_free = 0;\r\nfree_count = 0;\r\nretry = 0;\r\ntmp = ufs_data_ptr_to_cpu(sb, p);\r\nif (!tmp)\r\nreturn 0;\r\nind_ubh = ubh_bread(sb, tmp, uspi->s_bsize);\r\nif (tmp != ufs_data_ptr_to_cpu(sb, p)) {\r\nubh_brelse (ind_ubh);\r\nreturn 1;\r\n}\r\nif (!ind_ubh) {\r\nufs_data_ptr_clear(uspi, p);\r\nreturn 0;\r\n}\r\nindirect_block = (DIRECT_BLOCK > offset) ? (DIRECT_BLOCK - offset) : 0;\r\nfor (i = indirect_block; i < uspi->s_apb; i++) {\r\nind = ubh_get_data_ptr(uspi, ind_ubh, i);\r\ntmp = ufs_data_ptr_to_cpu(sb, ind);\r\nif (!tmp)\r\ncontinue;\r\nufs_data_ptr_clear(uspi, ind);\r\nubh_mark_buffer_dirty(ind_ubh);\r\nif (free_count == 0) {\r\nfrag_to_free = tmp;\r\nfree_count = uspi->s_fpb;\r\n} else if (free_count > 0 && frag_to_free == tmp - free_count)\r\nfree_count += uspi->s_fpb;\r\nelse {\r\nufs_free_blocks (inode, frag_to_free, free_count);\r\nfrag_to_free = tmp;\r\nfree_count = uspi->s_fpb;\r\n}\r\nmark_inode_dirty(inode);\r\n}\r\nif (free_count > 0) {\r\nufs_free_blocks (inode, frag_to_free, free_count);\r\n}\r\nfor (i = 0; i < uspi->s_apb; i++)\r\nif (!ufs_is_data_ptr_zero(uspi,\r\nubh_get_data_ptr(uspi, ind_ubh, i)))\r\nbreak;\r\nif (i >= uspi->s_apb) {\r\ntmp = ufs_data_ptr_to_cpu(sb, p);\r\nufs_data_ptr_clear(uspi, p);\r\nufs_free_blocks (inode, tmp, uspi->s_fpb);\r\nmark_inode_dirty(inode);\r\nubh_bforget(ind_ubh);\r\nind_ubh = NULL;\r\n}\r\nif (IS_SYNC(inode) && ind_ubh && ubh_buffer_dirty(ind_ubh))\r\nubh_sync_block(ind_ubh);\r\nubh_brelse (ind_ubh);\r\nUFSD("EXIT: ino %lu\n", inode->i_ino);\r\nreturn retry;\r\n}\r\nstatic int ufs_trunc_dindirect(struct inode *inode, u64 offset, void *p)\r\n{\r\nstruct super_block * sb;\r\nstruct ufs_sb_private_info * uspi;\r\nstruct ufs_buffer_head *dind_bh;\r\nu64 i, tmp, dindirect_block;\r\nvoid *dind;\r\nint retry = 0;\r\nUFSD("ENTER: ino %lu\n", inode->i_ino);\r\nsb = inode->i_sb;\r\nuspi = UFS_SB(sb)->s_uspi;\r\ndindirect_block = (DIRECT_BLOCK > offset)\r\n? ((DIRECT_BLOCK - offset) >> uspi->s_apbshift) : 0;\r\nretry = 0;\r\ntmp = ufs_data_ptr_to_cpu(sb, p);\r\nif (!tmp)\r\nreturn 0;\r\ndind_bh = ubh_bread(sb, tmp, uspi->s_bsize);\r\nif (tmp != ufs_data_ptr_to_cpu(sb, p)) {\r\nubh_brelse (dind_bh);\r\nreturn 1;\r\n}\r\nif (!dind_bh) {\r\nufs_data_ptr_clear(uspi, p);\r\nreturn 0;\r\n}\r\nfor (i = dindirect_block ; i < uspi->s_apb ; i++) {\r\ndind = ubh_get_data_ptr(uspi, dind_bh, i);\r\ntmp = ufs_data_ptr_to_cpu(sb, dind);\r\nif (!tmp)\r\ncontinue;\r\nretry |= ufs_trunc_indirect (inode, offset + (i << uspi->s_apbshift), dind);\r\nubh_mark_buffer_dirty(dind_bh);\r\n}\r\nfor (i = 0; i < uspi->s_apb; i++)\r\nif (!ufs_is_data_ptr_zero(uspi,\r\nubh_get_data_ptr(uspi, dind_bh, i)))\r\nbreak;\r\nif (i >= uspi->s_apb) {\r\ntmp = ufs_data_ptr_to_cpu(sb, p);\r\nufs_data_ptr_clear(uspi, p);\r\nufs_free_blocks(inode, tmp, uspi->s_fpb);\r\nmark_inode_dirty(inode);\r\nubh_bforget(dind_bh);\r\ndind_bh = NULL;\r\n}\r\nif (IS_SYNC(inode) && dind_bh && ubh_buffer_dirty(dind_bh))\r\nubh_sync_block(dind_bh);\r\nubh_brelse (dind_bh);\r\nUFSD("EXIT: ino %lu\n", inode->i_ino);\r\nreturn retry;\r\n}\r\nstatic int ufs_trunc_tindirect(struct inode *inode)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\r\nstruct ufs_inode_info *ufsi = UFS_I(inode);\r\nstruct ufs_buffer_head * tind_bh;\r\nu64 tindirect_block, tmp, i;\r\nvoid *tind, *p;\r\nint retry;\r\nUFSD("ENTER: ino %lu\n", inode->i_ino);\r\nretry = 0;\r\ntindirect_block = (DIRECT_BLOCK > (UFS_NDADDR + uspi->s_apb + uspi->s_2apb))\r\n? ((DIRECT_BLOCK - UFS_NDADDR - uspi->s_apb - uspi->s_2apb) >> uspi->s_2apbshift) : 0;\r\np = ufs_get_direct_data_ptr(uspi, ufsi, UFS_TIND_BLOCK);\r\nif (!(tmp = ufs_data_ptr_to_cpu(sb, p)))\r\nreturn 0;\r\ntind_bh = ubh_bread (sb, tmp, uspi->s_bsize);\r\nif (tmp != ufs_data_ptr_to_cpu(sb, p)) {\r\nubh_brelse (tind_bh);\r\nreturn 1;\r\n}\r\nif (!tind_bh) {\r\nufs_data_ptr_clear(uspi, p);\r\nreturn 0;\r\n}\r\nfor (i = tindirect_block ; i < uspi->s_apb ; i++) {\r\ntind = ubh_get_data_ptr(uspi, tind_bh, i);\r\nretry |= ufs_trunc_dindirect(inode, UFS_NDADDR +\r\nuspi->s_apb + ((i + 1) << uspi->s_2apbshift), tind);\r\nubh_mark_buffer_dirty(tind_bh);\r\n}\r\nfor (i = 0; i < uspi->s_apb; i++)\r\nif (!ufs_is_data_ptr_zero(uspi,\r\nubh_get_data_ptr(uspi, tind_bh, i)))\r\nbreak;\r\nif (i >= uspi->s_apb) {\r\ntmp = ufs_data_ptr_to_cpu(sb, p);\r\nufs_data_ptr_clear(uspi, p);\r\nufs_free_blocks(inode, tmp, uspi->s_fpb);\r\nmark_inode_dirty(inode);\r\nubh_bforget(tind_bh);\r\ntind_bh = NULL;\r\n}\r\nif (IS_SYNC(inode) && tind_bh && ubh_buffer_dirty(tind_bh))\r\nubh_sync_block(tind_bh);\r\nubh_brelse (tind_bh);\r\nUFSD("EXIT: ino %lu\n", inode->i_ino);\r\nreturn retry;\r\n}\r\nstatic int ufs_alloc_lastblock(struct inode *inode)\r\n{\r\nint err = 0;\r\nstruct super_block *sb = inode->i_sb;\r\nstruct address_space *mapping = inode->i_mapping;\r\nstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\r\nunsigned i, end;\r\nsector_t lastfrag;\r\nstruct page *lastpage;\r\nstruct buffer_head *bh;\r\nu64 phys64;\r\nlastfrag = (i_size_read(inode) + uspi->s_fsize - 1) >> uspi->s_fshift;\r\nif (!lastfrag)\r\ngoto out;\r\nlastfrag--;\r\nlastpage = ufs_get_locked_page(mapping, lastfrag >>\r\n(PAGE_CACHE_SHIFT - inode->i_blkbits));\r\nif (IS_ERR(lastpage)) {\r\nerr = -EIO;\r\ngoto out;\r\n}\r\nend = lastfrag & ((1 << (PAGE_CACHE_SHIFT - inode->i_blkbits)) - 1);\r\nbh = page_buffers(lastpage);\r\nfor (i = 0; i < end; ++i)\r\nbh = bh->b_this_page;\r\nerr = ufs_getfrag_block(inode, lastfrag, bh, 1);\r\nif (unlikely(err))\r\ngoto out_unlock;\r\nif (buffer_new(bh)) {\r\nclear_buffer_new(bh);\r\nunmap_underlying_metadata(bh->b_bdev,\r\nbh->b_blocknr);\r\nset_buffer_uptodate(bh);\r\nmark_buffer_dirty(bh);\r\nset_page_dirty(lastpage);\r\n}\r\nif (lastfrag >= UFS_IND_FRAGMENT) {\r\nend = uspi->s_fpb - ufs_fragnum(lastfrag) - 1;\r\nphys64 = bh->b_blocknr + 1;\r\nfor (i = 0; i < end; ++i) {\r\nbh = sb_getblk(sb, i + phys64);\r\nlock_buffer(bh);\r\nmemset(bh->b_data, 0, sb->s_blocksize);\r\nset_buffer_uptodate(bh);\r\nmark_buffer_dirty(bh);\r\nunlock_buffer(bh);\r\nsync_dirty_buffer(bh);\r\nbrelse(bh);\r\n}\r\n}\r\nout_unlock:\r\nufs_put_locked_page(lastpage);\r\nout:\r\nreturn err;\r\n}\r\nint ufs_truncate(struct inode *inode, loff_t old_i_size)\r\n{\r\nstruct ufs_inode_info *ufsi = UFS_I(inode);\r\nstruct super_block *sb = inode->i_sb;\r\nstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\r\nint retry, err = 0;\r\nUFSD("ENTER: ino %lu, i_size: %llu, old_i_size: %llu\n",\r\ninode->i_ino, (unsigned long long)i_size_read(inode),\r\n(unsigned long long)old_i_size);\r\nif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\r\nS_ISLNK(inode->i_mode)))\r\nreturn -EINVAL;\r\nif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\r\nreturn -EPERM;\r\nerr = ufs_alloc_lastblock(inode);\r\nif (err) {\r\ni_size_write(inode, old_i_size);\r\ngoto out;\r\n}\r\nblock_truncate_page(inode->i_mapping, inode->i_size, ufs_getfrag_block);\r\nwhile (1) {\r\nretry = ufs_trunc_direct(inode);\r\nretry |= ufs_trunc_indirect(inode, UFS_IND_BLOCK,\r\nufs_get_direct_data_ptr(uspi, ufsi,\r\nUFS_IND_BLOCK));\r\nretry |= ufs_trunc_dindirect(inode, UFS_IND_BLOCK + uspi->s_apb,\r\nufs_get_direct_data_ptr(uspi, ufsi,\r\nUFS_DIND_BLOCK));\r\nretry |= ufs_trunc_tindirect (inode);\r\nif (!retry)\r\nbreak;\r\nif (IS_SYNC(inode) && (inode->i_state & I_DIRTY))\r\nufs_sync_inode (inode);\r\nyield();\r\n}\r\ninode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;\r\nufsi->i_lastfrag = DIRECT_FRAGMENT;\r\nmark_inode_dirty(inode);\r\nout:\r\nUFSD("EXIT: err %d\n", err);\r\nreturn err;\r\n}\r\nint ufs_setattr(struct dentry *dentry, struct iattr *attr)\r\n{\r\nstruct inode *inode = d_inode(dentry);\r\nunsigned int ia_valid = attr->ia_valid;\r\nint error;\r\nerror = inode_change_ok(inode, attr);\r\nif (error)\r\nreturn error;\r\nif (ia_valid & ATTR_SIZE && attr->ia_size != inode->i_size) {\r\nloff_t old_i_size = inode->i_size;\r\ntruncate_setsize(inode, attr->ia_size);\r\nlock_ufs(inode->i_sb);\r\nerror = ufs_truncate(inode, old_i_size);\r\nunlock_ufs(inode->i_sb);\r\nif (error)\r\nreturn error;\r\n}\r\nsetattr_copy(inode, attr);\r\nmark_inode_dirty(inode);\r\nreturn 0;\r\n}
