symbol_t *\r\nsymbol_create(char *name)\r\n{\r\nsymbol_t *new_symbol;\r\nnew_symbol = (symbol_t *)malloc(sizeof(symbol_t));\r\nif (new_symbol == NULL) {\r\nperror("Unable to create new symbol");\r\nexit(EX_SOFTWARE);\r\n}\r\nmemset(new_symbol, 0, sizeof(*new_symbol));\r\nnew_symbol->name = strdup(name);\r\nif (new_symbol->name == NULL)\r\nstop("Unable to strdup symbol name", EX_SOFTWARE);\r\nnew_symbol->type = UNINITIALIZED;\r\nnew_symbol->count = 1;\r\nreturn (new_symbol);\r\n}\r\nvoid\r\nsymbol_delete(symbol_t *symbol)\r\n{\r\nif (symtable != NULL) {\r\nDBT key;\r\nkey.data = symbol->name;\r\nkey.size = strlen(symbol->name);\r\nsymtable->del(symtable, &key, 0);\r\n}\r\nswitch(symbol->type) {\r\ncase SCBLOC:\r\ncase SRAMLOC:\r\ncase REGISTER:\r\nif (symbol->info.rinfo != NULL)\r\nfree(symbol->info.rinfo);\r\nbreak;\r\ncase ALIAS:\r\nif (symbol->info.ainfo != NULL)\r\nfree(symbol->info.ainfo);\r\nbreak;\r\ncase MASK:\r\ncase FIELD:\r\ncase ENUM:\r\ncase ENUM_ENTRY:\r\nif (symbol->info.finfo != NULL) {\r\nsymlist_free(&symbol->info.finfo->symrefs);\r\nfree(symbol->info.finfo);\r\n}\r\nbreak;\r\ncase DOWNLOAD_CONST:\r\ncase CONST:\r\nif (symbol->info.cinfo != NULL)\r\nfree(symbol->info.cinfo);\r\nbreak;\r\ncase LABEL:\r\nif (symbol->info.linfo != NULL)\r\nfree(symbol->info.linfo);\r\nbreak;\r\ncase UNINITIALIZED:\r\ndefault:\r\nbreak;\r\n}\r\nfree(symbol->name);\r\nfree(symbol);\r\n}\r\nvoid\r\nsymtable_open()\r\n{\r\nsymtable = dbopen(NULL,\r\nO_CREAT | O_NONBLOCK | O_RDWR, 0, DB_HASH,\r\nNULL);\r\nif (symtable == NULL) {\r\nperror("Symbol table creation failed");\r\nexit(EX_SOFTWARE);\r\n}\r\n}\r\nvoid\r\nsymtable_close()\r\n{\r\nif (symtable != NULL) {\r\nDBT key;\r\nDBT data;\r\nwhile (symtable->seq(symtable, &key, &data, R_FIRST) == 0) {\r\nsymbol_t *stored_ptr;\r\nmemcpy(&stored_ptr, data.data, sizeof(stored_ptr));\r\nsymbol_delete(stored_ptr);\r\n}\r\nsymtable->close(symtable);\r\n}\r\n}\r\nsymbol_t *\r\nsymtable_get(char *name)\r\n{\r\nsymbol_t *stored_ptr;\r\nDBT key;\r\nDBT data;\r\nint retval;\r\nkey.data = (void *)name;\r\nkey.size = strlen(name);\r\nif ((retval = symtable->get(symtable, &key, &data, 0)) != 0) {\r\nif (retval == -1) {\r\nperror("Symbol table get operation failed");\r\nexit(EX_SOFTWARE);\r\n} else if (retval == 1) {\r\nsymbol_t *new_symbol;\r\nnew_symbol = symbol_create(name);\r\ndata.data = &new_symbol;\r\ndata.size = sizeof(new_symbol);\r\nif (symtable->put(symtable, &key, &data,\r\n0) !=0) {\r\nperror("Symtable put failed");\r\nexit(EX_SOFTWARE);\r\n}\r\nreturn (new_symbol);\r\n} else {\r\nperror("Unexpected return value from db get routine");\r\nexit(EX_SOFTWARE);\r\n}\r\n}\r\nmemcpy(&stored_ptr, data.data, sizeof(stored_ptr));\r\nstored_ptr->count++;\r\ndata.data = &stored_ptr;\r\nif (symtable->put(symtable, &key, &data, 0) !=0) {\r\nperror("Symtable put failed");\r\nexit(EX_SOFTWARE);\r\n}\r\nreturn (stored_ptr);\r\n}\r\nsymbol_node_t *\r\nsymlist_search(symlist_t *symlist, char *symname)\r\n{\r\nsymbol_node_t *curnode;\r\ncurnode = SLIST_FIRST(symlist);\r\nwhile(curnode != NULL) {\r\nif (strcmp(symname, curnode->symbol->name) == 0)\r\nbreak;\r\ncurnode = SLIST_NEXT(curnode, links);\r\n}\r\nreturn (curnode);\r\n}\r\nvoid\r\nsymlist_add(symlist_t *symlist, symbol_t *symbol, int how)\r\n{\r\nsymbol_node_t *newnode;\r\nnewnode = (symbol_node_t *)malloc(sizeof(symbol_node_t));\r\nif (newnode == NULL) {\r\nstop("symlist_add: Unable to malloc symbol_node", EX_SOFTWARE);\r\n}\r\nnewnode->symbol = symbol;\r\nif (how == SYMLIST_SORT) {\r\nsymbol_node_t *curnode;\r\nint field;\r\nfield = FALSE;\r\nswitch(symbol->type) {\r\ncase REGISTER:\r\ncase SCBLOC:\r\ncase SRAMLOC:\r\nbreak;\r\ncase FIELD:\r\ncase MASK:\r\ncase ENUM:\r\ncase ENUM_ENTRY:\r\nfield = TRUE;\r\nbreak;\r\ndefault:\r\nstop("symlist_add: Invalid symbol type for sorting",\r\nEX_SOFTWARE);\r\n}\r\ncurnode = SLIST_FIRST(symlist);\r\nif (curnode == NULL\r\n|| (field\r\n&& (curnode->symbol->type > newnode->symbol->type\r\n|| (curnode->symbol->type == newnode->symbol->type\r\n&& (curnode->symbol->info.finfo->value >\r\nnewnode->symbol->info.finfo->value))))\r\n|| (!field && (curnode->symbol->info.rinfo->address >\r\nnewnode->symbol->info.rinfo->address))) {\r\nSLIST_INSERT_HEAD(symlist, newnode, links);\r\nreturn;\r\n}\r\nwhile (1) {\r\nif (SLIST_NEXT(curnode, links) == NULL) {\r\nSLIST_INSERT_AFTER(curnode, newnode,\r\nlinks);\r\nbreak;\r\n} else {\r\nsymbol_t *cursymbol;\r\ncursymbol = SLIST_NEXT(curnode, links)->symbol;\r\nif ((field\r\n&& (cursymbol->type > symbol->type\r\n|| (cursymbol->type == symbol->type\r\n&& (cursymbol->info.finfo->value >\r\nsymbol->info.finfo->value))))\r\n|| (!field\r\n&& (cursymbol->info.rinfo->address >\r\nsymbol->info.rinfo->address))) {\r\nSLIST_INSERT_AFTER(curnode, newnode,\r\nlinks);\r\nbreak;\r\n}\r\n}\r\ncurnode = SLIST_NEXT(curnode, links);\r\n}\r\n} else {\r\nSLIST_INSERT_HEAD(symlist, newnode, links);\r\n}\r\n}\r\nvoid\r\nsymlist_free(symlist_t *symlist)\r\n{\r\nsymbol_node_t *node1, *node2;\r\nnode1 = SLIST_FIRST(symlist);\r\nwhile (node1 != NULL) {\r\nnode2 = SLIST_NEXT(node1, links);\r\nfree(node1);\r\nnode1 = node2;\r\n}\r\nSLIST_INIT(symlist);\r\n}\r\nvoid\r\nsymlist_merge(symlist_t *symlist_dest, symlist_t *symlist_src1,\r\nsymlist_t *symlist_src2)\r\n{\r\nsymbol_node_t *node;\r\n*symlist_dest = *symlist_src1;\r\nwhile((node = SLIST_FIRST(symlist_src2)) != NULL) {\r\nSLIST_REMOVE_HEAD(symlist_src2, links);\r\nSLIST_INSERT_HEAD(symlist_dest, node, links);\r\n}\r\nSLIST_INIT(symlist_src1);\r\nSLIST_INIT(symlist_src2);\r\n}\r\nvoid\r\naic_print_file_prologue(FILE *ofile)\r\n{\r\nif (ofile == NULL)\r\nreturn;\r\nfprintf(ofile,\r\n"/*\n"\r\n" * DO NOT EDIT - This file is automatically generated\n"\r\n" * from the following source files:\n"\r\n" *\n"\r\n"%s */\n",\r\nversions);\r\n}\r\nvoid\r\naic_print_include(FILE *dfile, char *include_file)\r\n{\r\nif (dfile == NULL)\r\nreturn;\r\nfprintf(dfile, "\n#include \"%s\"\n\n", include_file);\r\n}\r\nvoid\r\naic_print_reg_dump_types(FILE *ofile)\r\n{\r\nif (ofile == NULL)\r\nreturn;\r\nfprintf(ofile,\r\n"typedef int (%sreg_print_t)(u_int, u_int *, u_int);\n"\r\n"typedef struct %sreg_parse_entry {\n"\r\n" char *name;\n"\r\n" uint8_t value;\n"\r\n" uint8_t mask;\n"\r\n"} %sreg_parse_entry_t;\n"\r\n"\n",\r\nprefix, prefix, prefix);\r\n}\r\nstatic void\r\naic_print_reg_dump_start(FILE *dfile, symbol_node_t *regnode)\r\n{\r\nif (dfile == NULL)\r\nreturn;\r\nfprintf(dfile,\r\n"static const %sreg_parse_entry_t %s_parse_table[] = {\n",\r\nprefix,\r\nregnode->symbol->name);\r\n}\r\nstatic void\r\naic_print_reg_dump_end(FILE *ofile, FILE *dfile,\r\nsymbol_node_t *regnode, u_int num_entries)\r\n{\r\nchar *lower_name;\r\nchar *letter;\r\nlower_name = strdup(regnode->symbol->name);\r\nif (lower_name == NULL)\r\nstop("Unable to strdup symbol name", EX_SOFTWARE);\r\nfor (letter = lower_name; *letter != '\0'; letter++)\r\n*letter = tolower(*letter);\r\nif (dfile != NULL) {\r\nif (num_entries != 0)\r\nfprintf(dfile,\r\n"\n"\r\n"};\n"\r\n"\n");\r\nfprintf(dfile,\r\n"int\n"\r\n"%s%s_print(u_int regvalue, u_int *cur_col, u_int wrap)\n"\r\n"{\n"\r\n" return (%sprint_register(%s%s, %d, \"%s\",\n"\r\n" 0x%02x, regvalue, cur_col, wrap));\n"\r\n"}\n"\r\n"\n",\r\nprefix,\r\nlower_name,\r\nprefix,\r\nnum_entries != 0 ? regnode->symbol->name : "NULL",\r\nnum_entries != 0 ? "_parse_table" : "",\r\nnum_entries,\r\nregnode->symbol->name,\r\nregnode->symbol->info.rinfo->address);\r\n}\r\nfprintf(ofile,\r\n"#if AIC_DEBUG_REGISTERS\n"\r\n"%sreg_print_t %s%s_print;\n"\r\n"#else\n"\r\n"#define %s%s_print(regvalue, cur_col, wrap) \\\n"\r\n" %sprint_register(NULL, 0, \"%s\", 0x%02x, regvalue, cur_col, wrap)\n"\r\n"#endif\n"\r\n"\n",\r\nprefix,\r\nprefix,\r\nlower_name,\r\nprefix,\r\nlower_name,\r\nprefix,\r\nregnode->symbol->name,\r\nregnode->symbol->info.rinfo->address);\r\n}\r\nstatic void\r\naic_print_reg_dump_entry(FILE *dfile, symbol_node_t *curnode)\r\n{\r\nint num_tabs;\r\nif (dfile == NULL)\r\nreturn;\r\nfprintf(dfile,\r\n" { \"%s\",",\r\ncurnode->symbol->name);\r\nnum_tabs = 3 - (strlen(curnode->symbol->name) + 5) / 8;\r\nwhile (num_tabs-- > 0)\r\nfputc('\t', dfile);\r\nfprintf(dfile, "0x%02x, 0x%02x }",\r\ncurnode->symbol->info.finfo->value,\r\ncurnode->symbol->info.finfo->mask);\r\n}\r\nvoid\r\nsymtable_dump(FILE *ofile, FILE *dfile)\r\n{\r\nsymlist_t registers;\r\nsymlist_t masks;\r\nsymlist_t constants;\r\nsymlist_t download_constants;\r\nsymlist_t aliases;\r\nsymlist_t exported_labels;\r\nsymbol_node_t *curnode;\r\nsymbol_node_t *regnode;\r\nDBT key;\r\nDBT data;\r\nint flag;\r\nint reg_count = 0, reg_used = 0;\r\nu_int i;\r\nif (symtable == NULL)\r\nreturn;\r\nSLIST_INIT(&registers);\r\nSLIST_INIT(&masks);\r\nSLIST_INIT(&constants);\r\nSLIST_INIT(&download_constants);\r\nSLIST_INIT(&aliases);\r\nSLIST_INIT(&exported_labels);\r\nflag = R_FIRST;\r\nwhile (symtable->seq(symtable, &key, &data, flag) == 0) {\r\nsymbol_t *cursym;\r\nmemcpy(&cursym, data.data, sizeof(cursym));\r\nswitch(cursym->type) {\r\ncase REGISTER:\r\ncase SCBLOC:\r\ncase SRAMLOC:\r\nsymlist_add(&registers, cursym, SYMLIST_SORT);\r\nbreak;\r\ncase MASK:\r\ncase FIELD:\r\ncase ENUM:\r\ncase ENUM_ENTRY:\r\nsymlist_add(&masks, cursym, SYMLIST_SORT);\r\nbreak;\r\ncase CONST:\r\nsymlist_add(&constants, cursym,\r\nSYMLIST_INSERT_HEAD);\r\nbreak;\r\ncase DOWNLOAD_CONST:\r\nsymlist_add(&download_constants, cursym,\r\nSYMLIST_INSERT_HEAD);\r\nbreak;\r\ncase ALIAS:\r\nsymlist_add(&aliases, cursym,\r\nSYMLIST_INSERT_HEAD);\r\nbreak;\r\ncase LABEL:\r\nif (cursym->info.linfo->exported == 0)\r\nbreak;\r\nsymlist_add(&exported_labels, cursym,\r\nSYMLIST_INSERT_HEAD);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nflag = R_NEXT;\r\n}\r\naic_print_file_prologue(ofile);\r\naic_print_reg_dump_types(ofile);\r\naic_print_file_prologue(dfile);\r\naic_print_include(dfile, stock_include_file);\r\nSLIST_FOREACH(curnode, &registers, links) {\r\nif (curnode->symbol->dont_generate_debug_code)\r\ncontinue;\r\nswitch(curnode->symbol->type) {\r\ncase REGISTER:\r\ncase SCBLOC:\r\ncase SRAMLOC:\r\n{\r\nsymlist_t *fields;\r\nsymbol_node_t *fieldnode;\r\nint num_entries;\r\nnum_entries = 0;\r\nreg_count++;\r\nif (curnode->symbol->count == 1)\r\nbreak;\r\nfields = &curnode->symbol->info.rinfo->fields;\r\nSLIST_FOREACH(fieldnode, fields, links) {\r\nif (num_entries == 0)\r\naic_print_reg_dump_start(dfile,\r\ncurnode);\r\nelse if (dfile != NULL)\r\nfputs(",\n", dfile);\r\nnum_entries++;\r\naic_print_reg_dump_entry(dfile, fieldnode);\r\n}\r\naic_print_reg_dump_end(ofile, dfile,\r\ncurnode, num_entries);\r\nreg_used++;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nfprintf(stderr, "%s: %d of %d register definitions used\n", appname,\r\nreg_used, reg_count);\r\nwhile (SLIST_FIRST(&masks) != NULL) {\r\nchar *regname;\r\ncurnode = SLIST_FIRST(&masks);\r\nSLIST_REMOVE_HEAD(&masks, links);\r\nregnode = SLIST_FIRST(&curnode->symbol->info.finfo->symrefs);\r\nregname = regnode->symbol->name;\r\nregnode = symlist_search(&registers, regname);\r\nSLIST_INSERT_AFTER(regnode, curnode, links);\r\n}\r\nwhile (SLIST_FIRST(&aliases) != NULL) {\r\nchar *regname;\r\ncurnode = SLIST_FIRST(&aliases);\r\nSLIST_REMOVE_HEAD(&aliases, links);\r\nregname = curnode->symbol->info.ainfo->parent->name;\r\nregnode = symlist_search(&registers, regname);\r\nSLIST_INSERT_AFTER(regnode, curnode, links);\r\n}\r\nwhile (SLIST_FIRST(&registers) != NULL) {\r\nsymbol_node_t *curnode;\r\nu_int value;\r\nchar *tab_str;\r\nchar *tab_str2;\r\ncurnode = SLIST_FIRST(&registers);\r\nSLIST_REMOVE_HEAD(&registers, links);\r\nswitch(curnode->symbol->type) {\r\ncase REGISTER:\r\ncase SCBLOC:\r\ncase SRAMLOC:\r\nfprintf(ofile, "\n");\r\nvalue = curnode->symbol->info.rinfo->address;\r\ntab_str = "\t";\r\ntab_str2 = "\t\t";\r\nbreak;\r\ncase ALIAS:\r\n{\r\nsymbol_t *parent;\r\nparent = curnode->symbol->info.ainfo->parent;\r\nvalue = parent->info.rinfo->address;\r\ntab_str = "\t";\r\ntab_str2 = "\t\t";\r\nbreak;\r\n}\r\ncase MASK:\r\ncase FIELD:\r\ncase ENUM:\r\ncase ENUM_ENTRY:\r\nvalue = curnode->symbol->info.finfo->value;\r\ntab_str = "\t\t";\r\ntab_str2 = "\t";\r\nbreak;\r\ndefault:\r\nvalue = 0;\r\ntab_str = NULL;\r\ntab_str2 = NULL;\r\nstop("symtable_dump: Invalid symbol type "\r\n"encountered", EX_SOFTWARE);\r\nbreak;\r\n}\r\nfprintf(ofile, "#define%s%-16s%s0x%02x\n",\r\ntab_str, curnode->symbol->name, tab_str2,\r\nvalue);\r\nfree(curnode);\r\n}\r\nfprintf(ofile, "\n\n");\r\nwhile (SLIST_FIRST(&constants) != NULL) {\r\nsymbol_node_t *curnode;\r\ncurnode = SLIST_FIRST(&constants);\r\nSLIST_REMOVE_HEAD(&constants, links);\r\nfprintf(ofile, "#define\t%-8s\t0x%02x\n",\r\ncurnode->symbol->name,\r\ncurnode->symbol->info.cinfo->value);\r\nfree(curnode);\r\n}\r\nfprintf(ofile, "\n\n/* Downloaded Constant Definitions */\n");\r\nfor (i = 0; SLIST_FIRST(&download_constants) != NULL; i++) {\r\nsymbol_node_t *curnode;\r\ncurnode = SLIST_FIRST(&download_constants);\r\nSLIST_REMOVE_HEAD(&download_constants, links);\r\nfprintf(ofile, "#define\t%-8s\t0x%02x\n",\r\ncurnode->symbol->name,\r\ncurnode->symbol->info.cinfo->value);\r\nfree(curnode);\r\n}\r\nfprintf(ofile, "#define\tDOWNLOAD_CONST_COUNT\t0x%02x\n", i);\r\nfprintf(ofile, "\n\n/* Exported Labels */\n");\r\nwhile (SLIST_FIRST(&exported_labels) != NULL) {\r\nsymbol_node_t *curnode;\r\ncurnode = SLIST_FIRST(&exported_labels);\r\nSLIST_REMOVE_HEAD(&exported_labels, links);\r\nfprintf(ofile, "#define\tLABEL_%-8s\t0x%02x\n",\r\ncurnode->symbol->name,\r\ncurnode->symbol->info.linfo->address);\r\nfree(curnode);\r\n}\r\n}
