static void enable_rt_irq(struct irq_data *d)\r\n{\r\n}\r\nstatic void disable_rt_irq(struct irq_data *d)\r\n{\r\n}\r\nstatic int rt_next_event(unsigned long delta, struct clock_event_device *evt)\r\n{\r\nunsigned int cpu = smp_processor_id();\r\nint slice = cputoslice(cpu);\r\nunsigned long cnt;\r\ncnt = LOCAL_HUB_L(PI_RT_COUNT);\r\ncnt += delta;\r\nLOCAL_HUB_S(PI_RT_COMPARE_A + PI_COUNT_OFFSET * slice, cnt);\r\nreturn LOCAL_HUB_L(PI_RT_COUNT) >= cnt ? -ETIME : 0;\r\n}\r\nstatic void rt_set_mode(enum clock_event_mode mode,\r\nstruct clock_event_device *evt)\r\n{\r\n}\r\nstatic irqreturn_t hub_rt_counter_handler(int irq, void *dev_id)\r\n{\r\nunsigned int cpu = smp_processor_id();\r\nstruct clock_event_device *cd = &per_cpu(hub_rt_clockevent, cpu);\r\nint slice = cputoslice(cpu);\r\nLOCAL_HUB_S(PI_RT_PEND_A + PI_COUNT_OFFSET * slice, 0);\r\ncd->event_handler(cd);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid hub_rt_clock_event_init(void)\r\n{\r\nunsigned int cpu = smp_processor_id();\r\nstruct clock_event_device *cd = &per_cpu(hub_rt_clockevent, cpu);\r\nunsigned char *name = per_cpu(hub_rt_name, cpu);\r\nint irq = rt_timer_irq;\r\nsprintf(name, "hub-rt %d", cpu);\r\ncd->name = name;\r\ncd->features = CLOCK_EVT_FEAT_ONESHOT;\r\nclockevent_set_clock(cd, CYCLES_PER_SEC);\r\ncd->max_delta_ns = clockevent_delta2ns(0xfffffffffffff, cd);\r\ncd->min_delta_ns = clockevent_delta2ns(0x300, cd);\r\ncd->rating = 200;\r\ncd->irq = irq;\r\ncd->cpumask = cpumask_of(cpu);\r\ncd->set_next_event = rt_next_event;\r\ncd->set_mode = rt_set_mode;\r\nclockevents_register_device(cd);\r\n}\r\nstatic void __init hub_rt_clock_event_global_init(void)\r\n{\r\nint irq;\r\ndo {\r\nsmp_wmb();\r\nirq = rt_timer_irq;\r\nif (irq)\r\nbreak;\r\nirq = allocate_irqno();\r\nif (irq < 0)\r\npanic("Allocation of irq number for timer failed");\r\n} while (xchg(&rt_timer_irq, irq));\r\nirq_set_chip_and_handler(irq, &rt_irq_type, handle_percpu_irq);\r\nsetup_irq(irq, &hub_rt_irqaction);\r\n}\r\nstatic cycle_t hub_rt_read(struct clocksource *cs)\r\n{\r\nreturn REMOTE_HUB_L(cputonasid(0), PI_RT_COUNT);\r\n}\r\nstatic u64 notrace hub_rt_read_sched_clock(void)\r\n{\r\nreturn REMOTE_HUB_L(cputonasid(0), PI_RT_COUNT);\r\n}\r\nstatic void __init hub_rt_clocksource_init(void)\r\n{\r\nstruct clocksource *cs = &hub_rt_clocksource;\r\nclocksource_register_hz(cs, CYCLES_PER_SEC);\r\nsched_clock_register(hub_rt_read_sched_clock, 52, CYCLES_PER_SEC);\r\n}\r\nvoid __init plat_time_init(void)\r\n{\r\nhub_rt_clocksource_init();\r\nhub_rt_clock_event_global_init();\r\nhub_rt_clock_event_init();\r\n}\r\nvoid cpu_time_init(void)\r\n{\r\nlboard_t *board;\r\nklcpu_t *cpu;\r\nint cpuid;\r\nboard = find_lboard(KL_CONFIG_INFO(get_nasid()), KLTYPE_IP27);\r\nif (!board)\r\npanic("Can't find board info for myself.");\r\ncpuid = LOCAL_HUB_L(PI_CPU_NUM) ? IP27_CPU0_INDEX : IP27_CPU1_INDEX;\r\ncpu = (klcpu_t *) KLCF_COMP(board, cpuid);\r\nif (!cpu)\r\npanic("No information about myself?");\r\nprintk("CPU %d clock is %dMHz.\n", smp_processor_id(), cpu->cpu_speed);\r\nset_c0_status(SRB_TIMOCLK);\r\n}\r\nvoid hub_rtc_init(cnodeid_t cnode)\r\n{\r\nif (get_compact_nodeid() == cnode) {\r\nLOCAL_HUB_S(PI_RT_EN_A, 1);\r\nLOCAL_HUB_S(PI_RT_EN_B, 1);\r\nLOCAL_HUB_S(PI_PROF_EN_A, 0);\r\nLOCAL_HUB_S(PI_PROF_EN_B, 0);\r\nLOCAL_HUB_S(PI_RT_COUNT, 0);\r\nLOCAL_HUB_S(PI_RT_PEND_A, 0);\r\nLOCAL_HUB_S(PI_RT_PEND_B, 0);\r\n}\r\n}\r\nstatic int __init sgi_ip27_rtc_devinit(void)\r\n{\r\nstruct resource res;\r\nmemset(&res, 0, sizeof(res));\r\nres.start = XPHYSADDR(KL_CONFIG_CH_CONS_INFO(master_nasid)->memory_base +\r\nIOC3_BYTEBUS_DEV0);\r\nres.end = res.start + 32767;\r\nres.flags = IORESOURCE_MEM;\r\nreturn IS_ERR(platform_device_register_simple("rtc-m48t35", -1,\r\n&res, 1));\r\n}
