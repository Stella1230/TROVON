static irqreturn_t tmiofb_irq(int irq, void *__info)\r\n{\r\nstruct fb_info *info = __info;\r\nstruct tmiofb_par *par = info->par;\r\nunsigned int bbisc = tmio_ioread16(par->lcr + LCR_BBISC);\r\ntmio_iowrite16(bbisc, par->lcr + LCR_BBISC);\r\n#ifdef CONFIG_FB_TMIO_ACCELL\r\nif (unlikely(par->use_polling && irq != -1)) {\r\nprintk(KERN_INFO "tmiofb: switching to waitq\n");\r\npar->use_polling = false;\r\n}\r\nif (bbisc & 1)\r\nwake_up(&par->wait_acc);\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int tmiofb_hw_stop(struct platform_device *dev)\r\n{\r\nstruct tmio_fb_data *data = dev_get_platdata(&dev->dev);\r\nstruct fb_info *info = platform_get_drvdata(dev);\r\nstruct tmiofb_par *par = info->par;\r\ntmio_iowrite16(0, par->ccr + CCR_UGCC);\r\ntmio_iowrite16(0, par->lcr + LCR_GM);\r\ndata->lcd_set_power(dev, 0);\r\ntmio_iowrite16(0x0010, par->lcr + LCR_LCDCCRC);\r\nreturn 0;\r\n}\r\nstatic int tmiofb_hw_init(struct platform_device *dev)\r\n{\r\nconst struct mfd_cell *cell = mfd_get_cell(dev);\r\nstruct fb_info *info = platform_get_drvdata(dev);\r\nstruct tmiofb_par *par = info->par;\r\nconst struct resource *nlcr = &cell->resources[0];\r\nconst struct resource *vram = &cell->resources[2];\r\nunsigned long base;\r\nif (nlcr == NULL || vram == NULL)\r\nreturn -EINVAL;\r\nbase = nlcr->start;\r\ntmio_iowrite16(0x003a, par->ccr + CCR_UGCC);\r\ntmio_iowrite16(0x003a, par->ccr + CCR_GCC);\r\ntmio_iowrite16(0x3f00, par->ccr + CCR_USC);\r\nmsleep(2);\r\ntmio_iowrite16(0x0000, par->ccr + CCR_USC);\r\ntmio_iowrite16(base >> 16, par->ccr + CCR_BASEH);\r\ntmio_iowrite16(base, par->ccr + CCR_BASEL);\r\ntmio_iowrite16(0x0002, par->ccr + CCR_CMD);\r\ntmio_iowrite16(0x40a8, par->ccr + CCR_VRAMRTC);\r\ntmio_iowrite16(0x0018, par->ccr + CCR_VRAMSAC);\r\ntmio_iowrite16(0x0002, par->ccr + CCR_VRAMBC);\r\nmsleep(2);\r\ntmio_iowrite16(0x000b, par->ccr + CCR_VRAMBC);\r\nbase = vram->start + info->screen_size;\r\ntmio_iowrite16(base >> 16, par->lcr + LCR_CFSAH);\r\ntmio_iowrite16(base, par->lcr + LCR_CFSAL);\r\ntmio_iowrite16(TMIOFB_FIFO_SIZE - 1, par->lcr + LCR_CFS);\r\ntmio_iowrite16(1, par->lcr + LCR_CFC);\r\ntmio_iowrite16(1, par->lcr + LCR_BBIE);\r\ntmio_iowrite16(0, par->lcr + LCR_CFWS);\r\nreturn 0;\r\n}\r\nstatic void tmiofb_hw_mode(struct platform_device *dev)\r\n{\r\nstruct tmio_fb_data *data = dev_get_platdata(&dev->dev);\r\nstruct fb_info *info = platform_get_drvdata(dev);\r\nstruct fb_videomode *mode = info->mode;\r\nstruct tmiofb_par *par = info->par;\r\nunsigned int i;\r\ntmio_iowrite16(0, par->lcr + LCR_GM);\r\ndata->lcd_set_power(dev, 0);\r\ntmio_iowrite16(0x0010, par->lcr + LCR_LCDCCRC);\r\ndata->lcd_mode(dev, mode);\r\ndata->lcd_set_power(dev, 1);\r\ntmio_iowrite16(info->fix.line_length, par->lcr + LCR_VHPN);\r\ntmio_iowrite16(0, par->lcr + LCR_GDSAH);\r\ntmio_iowrite16(0, par->lcr + LCR_GDSAL);\r\ntmio_iowrite16(info->fix.line_length >> 16, par->lcr + LCR_VHPCH);\r\ntmio_iowrite16(info->fix.line_length, par->lcr + LCR_VHPCL);\r\ntmio_iowrite16(i = 0, par->lcr + LCR_HSS);\r\ntmio_iowrite16(i += mode->hsync_len, par->lcr + LCR_HSE);\r\ntmio_iowrite16(i += mode->left_margin, par->lcr + LCR_HDS);\r\ntmio_iowrite16(i += mode->xres + mode->right_margin, par->lcr + LCR_HT);\r\ntmio_iowrite16(mode->xres, par->lcr + LCR_HNP);\r\ntmio_iowrite16(i = 0, par->lcr + LCR_VSS);\r\ntmio_iowrite16(i += mode->vsync_len, par->lcr + LCR_VSE);\r\ntmio_iowrite16(i += mode->upper_margin, par->lcr + LCR_VDS);\r\ntmio_iowrite16(i += mode->yres, par->lcr + LCR_ILN);\r\ntmio_iowrite16(i += mode->lower_margin, par->lcr + LCR_VT);\r\ntmio_iowrite16(3, par->lcr + LCR_MISC);\r\ntmio_iowrite16(1, par->lcr + LCR_GM);\r\ntmio_iowrite16(0x4007, par->lcr + LCR_LCDCC);\r\ntmio_iowrite16(3, par->lcr + LCR_SP);\r\ntmio_iowrite16(0x0010, par->lcr + LCR_LCDCCRC);\r\nmsleep(5);\r\ntmio_iowrite16(0x0014, par->lcr + LCR_LCDCCRC);\r\nmsleep(5);\r\ntmio_iowrite16(0x0015, par->lcr + LCR_LCDCCRC);\r\ntmio_iowrite16(0xfffa, par->lcr + LCR_VCS);\r\n}\r\nstatic int __must_check\r\ntmiofb_acc_wait(struct fb_info *info, unsigned int ccs)\r\n{\r\nstruct tmiofb_par *par = info->par;\r\nif (irqs_disabled() || par->use_polling) {\r\nint i = 0;\r\nwhile (tmio_ioread16(par->lcr + LCR_CCS) > ccs) {\r\nudelay(1);\r\ni++;\r\nif (i > 10000) {\r\npr_err("tmiofb: timeout waiting for %d\n",\r\nccs);\r\nreturn -ETIMEDOUT;\r\n}\r\ntmiofb_irq(-1, info);\r\n}\r\n} else {\r\nif (!wait_event_interruptible_timeout(par->wait_acc,\r\ntmio_ioread16(par->lcr + LCR_CCS) <= ccs,\r\n1000)) {\r\npr_err("tmiofb: timeout waiting for %d\n", ccs);\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ntmiofb_acc_write(struct fb_info *info, const u32 *cmd, unsigned int count)\r\n{\r\nstruct tmiofb_par *par = info->par;\r\nint ret;\r\nret = tmiofb_acc_wait(info, TMIOFB_FIFO_SIZE - count);\r\nif (ret)\r\nreturn ret;\r\nfor (; count; count--, cmd++) {\r\ntmio_iowrite16(*cmd >> 16, par->lcr + LCR_CMDH);\r\ntmio_iowrite16(*cmd, par->lcr + LCR_CMDL);\r\n}\r\nreturn ret;\r\n}\r\nstatic int tmiofb_sync(struct fb_info *fbi)\r\n{\r\nstruct tmiofb_par *par = fbi->par;\r\nint ret;\r\nint i = 0;\r\nret = tmiofb_acc_wait(fbi, 0);\r\nwhile (tmio_ioread16(par->lcr + LCR_BBES) & 2) {\r\nudelay(1);\r\ni++ ;\r\nif (i > 10000) {\r\nprintk(KERN_ERR "timeout waiting for blit to end!\n");\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\ntmiofb_fillrect(struct fb_info *fbi, const struct fb_fillrect *rect)\r\n{\r\nconst u32 cmd[] = {\r\nTMIOFB_ACC_DSADR((rect->dy * fbi->mode->xres + rect->dx) * 2),\r\nTMIOFB_ACC_DHPIX(rect->width - 1),\r\nTMIOFB_ACC_DVPIX(rect->height - 1),\r\nTMIOFB_ACC_FILL(rect->color),\r\nTMIOFB_ACC_FLGO,\r\n};\r\nif (fbi->state != FBINFO_STATE_RUNNING ||\r\nfbi->flags & FBINFO_HWACCEL_DISABLED) {\r\ncfb_fillrect(fbi, rect);\r\nreturn;\r\n}\r\ntmiofb_acc_write(fbi, cmd, ARRAY_SIZE(cmd));\r\n}\r\nstatic void\r\ntmiofb_copyarea(struct fb_info *fbi, const struct fb_copyarea *area)\r\n{\r\nconst u32 cmd[] = {\r\nTMIOFB_ACC_DSADR((area->dy * fbi->mode->xres + area->dx) * 2),\r\nTMIOFB_ACC_DHPIX(area->width - 1),\r\nTMIOFB_ACC_DVPIX(area->height - 1),\r\nTMIOFB_ACC_SSADR((area->sy * fbi->mode->xres + area->sx) * 2),\r\nTMIOFB_ACC_SCGO,\r\n};\r\nif (fbi->state != FBINFO_STATE_RUNNING ||\r\nfbi->flags & FBINFO_HWACCEL_DISABLED) {\r\ncfb_copyarea(fbi, area);\r\nreturn;\r\n}\r\ntmiofb_acc_write(fbi, cmd, ARRAY_SIZE(cmd));\r\n}\r\nstatic void tmiofb_clearscreen(struct fb_info *info)\r\n{\r\nconst struct fb_fillrect rect = {\r\n.dx = 0,\r\n.dy = 0,\r\n.width = info->mode->xres,\r\n.height = info->mode->yres,\r\n.color = 0,\r\n.rop = ROP_COPY,\r\n};\r\ninfo->fbops->fb_fillrect(info, &rect);\r\n}\r\nstatic int tmiofb_vblank(struct fb_info *fbi, struct fb_vblank *vblank)\r\n{\r\nstruct tmiofb_par *par = fbi->par;\r\nstruct fb_videomode *mode = fbi->mode;\r\nunsigned int vcount = tmio_ioread16(par->lcr + LCR_CDLN);\r\nunsigned int vds = mode->vsync_len + mode->upper_margin;\r\nvblank->vcount = vcount;\r\nvblank->flags = FB_VBLANK_HAVE_VBLANK | FB_VBLANK_HAVE_VCOUNT\r\n| FB_VBLANK_HAVE_VSYNC;\r\nif (vcount < mode->vsync_len)\r\nvblank->flags |= FB_VBLANK_VSYNCING;\r\nif (vcount < vds || vcount > vds + mode->yres)\r\nvblank->flags |= FB_VBLANK_VBLANKING;\r\nreturn 0;\r\n}\r\nstatic int tmiofb_ioctl(struct fb_info *fbi,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nswitch (cmd) {\r\ncase FBIOGET_VBLANK: {\r\nstruct fb_vblank vblank = {0};\r\nvoid __user *argp = (void __user *) arg;\r\ntmiofb_vblank(fbi, &vblank);\r\nif (copy_to_user(argp, &vblank, sizeof vblank))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\n#ifdef CONFIG_FB_TMIO_ACCELL\r\ncase FBIO_TMIO_ACC_SYNC:\r\ntmiofb_sync(fbi);\r\nreturn 0;\r\ncase FBIO_TMIO_ACC_WRITE: {\r\nu32 __user *argp = (void __user *) arg;\r\nu32 len;\r\nu32 acc[16];\r\nif (get_user(len, argp))\r\nreturn -EFAULT;\r\nif (len > ARRAY_SIZE(acc))\r\nreturn -EINVAL;\r\nif (copy_from_user(acc, argp + 1, sizeof(u32) * len))\r\nreturn -EFAULT;\r\nreturn tmiofb_acc_write(fbi, acc, len);\r\n}\r\n#endif\r\n}\r\nreturn -ENOTTY;\r\n}\r\nstatic struct fb_videomode *\r\ntmiofb_find_mode(struct fb_info *info, struct fb_var_screeninfo *var)\r\n{\r\nstruct tmio_fb_data *data = dev_get_platdata(info->device);\r\nstruct fb_videomode *best = NULL;\r\nint i;\r\nfor (i = 0; i < data->num_modes; i++) {\r\nstruct fb_videomode *mode = data->modes + i;\r\nif (mode->xres >= var->xres && mode->yres >= var->yres\r\n&& (!best || (mode->xres < best->xres\r\n&& mode->yres < best->yres)))\r\nbest = mode;\r\n}\r\nreturn best;\r\n}\r\nstatic int tmiofb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct fb_videomode *mode;\r\nstruct tmio_fb_data *data = dev_get_platdata(info->device);\r\nmode = tmiofb_find_mode(info, var);\r\nif (!mode || var->bits_per_pixel > 16)\r\nreturn -EINVAL;\r\nfb_videomode_to_var(var, mode);\r\nvar->xres_virtual = mode->xres;\r\nvar->yres_virtual = info->screen_size / (mode->xres * 2);\r\nif (var->yres_virtual < var->yres)\r\nreturn -EINVAL;\r\nvar->xoffset = 0;\r\nvar->yoffset = 0;\r\nvar->bits_per_pixel = 16;\r\nvar->grayscale = 0;\r\nvar->red.offset = 11;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 6;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nvar->nonstd = 0;\r\nvar->height = data->height;\r\nvar->width = data->width;\r\nvar->rotate = 0;\r\nreturn 0;\r\n}\r\nstatic int tmiofb_set_par(struct fb_info *info)\r\n{\r\nstruct fb_var_screeninfo *var = &info->var;\r\nstruct fb_videomode *mode;\r\nmode = tmiofb_find_mode(info, var);\r\nif (!mode)\r\nreturn -EINVAL;\r\ninfo->mode = mode;\r\ninfo->fix.line_length = info->mode->xres *\r\nvar->bits_per_pixel / 8;\r\ntmiofb_hw_mode(to_platform_device(info->device));\r\ntmiofb_clearscreen(info);\r\nreturn 0;\r\n}\r\nstatic int tmiofb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nstruct tmiofb_par *par = info->par;\r\nif (regno < ARRAY_SIZE(par->pseudo_palette)) {\r\npar->pseudo_palette[regno] =\r\n((red & 0xf800)) |\r\n((green & 0xfc00) >> 5) |\r\n((blue & 0xf800) >> 11);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int tmiofb_blank(int blank, struct fb_info *info)\r\n{\r\nreturn 0;\r\n}\r\nstatic int tmiofb_probe(struct platform_device *dev)\r\n{\r\nconst struct mfd_cell *cell = mfd_get_cell(dev);\r\nstruct tmio_fb_data *data = dev_get_platdata(&dev->dev);\r\nstruct resource *ccr = platform_get_resource(dev, IORESOURCE_MEM, 1);\r\nstruct resource *lcr = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nstruct resource *vram = platform_get_resource(dev, IORESOURCE_MEM, 2);\r\nint irq = platform_get_irq(dev, 0);\r\nstruct fb_info *info;\r\nstruct tmiofb_par *par;\r\nint retval;\r\nif (data == NULL) {\r\ndev_err(&dev->dev, "NULL platform data!\n");\r\nreturn -EINVAL;\r\n}\r\nif (ccr == NULL || lcr == NULL || vram == NULL || irq < 0) {\r\ndev_err(&dev->dev, "missing resources\n");\r\nreturn -EINVAL;\r\n}\r\ninfo = framebuffer_alloc(sizeof(struct tmiofb_par), &dev->dev);\r\nif (!info)\r\nreturn -ENOMEM;\r\npar = info->par;\r\n#ifdef CONFIG_FB_TMIO_ACCELL\r\ninit_waitqueue_head(&par->wait_acc);\r\npar->use_polling = true;\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_COPYAREA\r\n| FBINFO_HWACCEL_FILLRECT;\r\n#else\r\ninfo->flags = FBINFO_DEFAULT;\r\n#endif\r\ninfo->fbops = &tmiofb_ops;\r\nstrcpy(info->fix.id, "tmio-fb");\r\ninfo->fix.smem_start = vram->start;\r\ninfo->fix.smem_len = resource_size(vram);\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\ninfo->fix.mmio_start = lcr->start;\r\ninfo->fix.mmio_len = resource_size(lcr);\r\ninfo->fix.accel = FB_ACCEL_NONE;\r\ninfo->screen_size = info->fix.smem_len - (4 * TMIOFB_FIFO_SIZE);\r\ninfo->pseudo_palette = par->pseudo_palette;\r\npar->ccr = ioremap(ccr->start, resource_size(ccr));\r\nif (!par->ccr) {\r\nretval = -ENOMEM;\r\ngoto err_ioremap_ccr;\r\n}\r\npar->lcr = ioremap(info->fix.mmio_start, info->fix.mmio_len);\r\nif (!par->lcr) {\r\nretval = -ENOMEM;\r\ngoto err_ioremap_lcr;\r\n}\r\ninfo->screen_base = ioremap(info->fix.smem_start, info->fix.smem_len);\r\nif (!info->screen_base) {\r\nretval = -ENOMEM;\r\ngoto err_ioremap_vram;\r\n}\r\nretval = request_irq(irq, &tmiofb_irq, 0,\r\ndev_name(&dev->dev), info);\r\nif (retval)\r\ngoto err_request_irq;\r\nplatform_set_drvdata(dev, info);\r\nretval = fb_find_mode(&info->var, info, mode_option,\r\ndata->modes, data->num_modes,\r\ndata->modes, 16);\r\nif (!retval) {\r\nretval = -EINVAL;\r\ngoto err_find_mode;\r\n}\r\nif (cell->enable) {\r\nretval = cell->enable(dev);\r\nif (retval)\r\ngoto err_enable;\r\n}\r\nretval = tmiofb_hw_init(dev);\r\nif (retval)\r\ngoto err_hw_init;\r\nfb_videomode_to_modelist(data->modes, data->num_modes,\r\n&info->modelist);\r\nretval = register_framebuffer(info);\r\nif (retval < 0)\r\ngoto err_register_framebuffer;\r\nfb_info(info, "%s frame buffer device\n", info->fix.id);\r\nreturn 0;\r\nerr_register_framebuffer:\r\ntmiofb_hw_stop(dev);\r\nerr_hw_init:\r\nif (cell->disable)\r\ncell->disable(dev);\r\nerr_enable:\r\nerr_find_mode:\r\nfree_irq(irq, info);\r\nerr_request_irq:\r\niounmap(info->screen_base);\r\nerr_ioremap_vram:\r\niounmap(par->lcr);\r\nerr_ioremap_lcr:\r\niounmap(par->ccr);\r\nerr_ioremap_ccr:\r\nframebuffer_release(info);\r\nreturn retval;\r\n}\r\nstatic int tmiofb_remove(struct platform_device *dev)\r\n{\r\nconst struct mfd_cell *cell = mfd_get_cell(dev);\r\nstruct fb_info *info = platform_get_drvdata(dev);\r\nint irq = platform_get_irq(dev, 0);\r\nstruct tmiofb_par *par;\r\nif (info) {\r\npar = info->par;\r\nunregister_framebuffer(info);\r\ntmiofb_hw_stop(dev);\r\nif (cell->disable)\r\ncell->disable(dev);\r\nfree_irq(irq, info);\r\niounmap(info->screen_base);\r\niounmap(par->lcr);\r\niounmap(par->ccr);\r\nframebuffer_release(info);\r\n}\r\nreturn 0;\r\n}\r\nstatic void tmiofb_dump_regs(struct platform_device *dev)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(dev);\r\nstruct tmiofb_par *par = info->par;\r\nprintk(KERN_DEBUG "lhccr:\n");\r\n#define CCR_PR(n) printk(KERN_DEBUG "\t" #n " = \t%04x\n",\\r\ntmio_ioread16(par->ccr + CCR_ ## n));\r\nCCR_PR(CMD);\r\nCCR_PR(REVID);\r\nCCR_PR(BASEL);\r\nCCR_PR(BASEH);\r\nCCR_PR(UGCC);\r\nCCR_PR(GCC);\r\nCCR_PR(USC);\r\nCCR_PR(VRAMRTC);\r\nCCR_PR(VRAMSAC);\r\nCCR_PR(VRAMBC);\r\n#undef CCR_PR\r\nprintk(KERN_DEBUG "lcr: \n");\r\n#define LCR_PR(n) printk(KERN_DEBUG "\t" #n " = \t%04x\n",\\r\ntmio_ioread16(par->lcr + LCR_ ## n));\r\nLCR_PR(UIS);\r\nLCR_PR(VHPN);\r\nLCR_PR(CFSAL);\r\nLCR_PR(CFSAH);\r\nLCR_PR(CFS);\r\nLCR_PR(CFWS);\r\nLCR_PR(BBIE);\r\nLCR_PR(BBISC);\r\nLCR_PR(CCS);\r\nLCR_PR(BBES);\r\nLCR_PR(CMDL);\r\nLCR_PR(CMDH);\r\nLCR_PR(CFC);\r\nLCR_PR(CCIFC);\r\nLCR_PR(HWT);\r\nLCR_PR(LCDCCRC);\r\nLCR_PR(LCDCC);\r\nLCR_PR(LCDCOPC);\r\nLCR_PR(LCDIS);\r\nLCR_PR(LCDIM);\r\nLCR_PR(LCDIE);\r\nLCR_PR(GDSAL);\r\nLCR_PR(GDSAH);\r\nLCR_PR(VHPCL);\r\nLCR_PR(VHPCH);\r\nLCR_PR(GM);\r\nLCR_PR(HT);\r\nLCR_PR(HDS);\r\nLCR_PR(HSS);\r\nLCR_PR(HSE);\r\nLCR_PR(HNP);\r\nLCR_PR(VT);\r\nLCR_PR(VDS);\r\nLCR_PR(VSS);\r\nLCR_PR(VSE);\r\nLCR_PR(CDLN);\r\nLCR_PR(ILN);\r\nLCR_PR(SP);\r\nLCR_PR(MISC);\r\nLCR_PR(VIHSS);\r\nLCR_PR(VIVS);\r\nLCR_PR(VIVE);\r\nLCR_PR(VIVSS);\r\nLCR_PR(VCCIS);\r\nLCR_PR(VIDWSAL);\r\nLCR_PR(VIDWSAH);\r\nLCR_PR(VIDRSAL);\r\nLCR_PR(VIDRSAH);\r\nLCR_PR(VIPDDST);\r\nLCR_PR(VIPDDET);\r\nLCR_PR(VIE);\r\nLCR_PR(VCS);\r\nLCR_PR(VPHWC);\r\nLCR_PR(VPHS);\r\nLCR_PR(VPVWC);\r\nLCR_PR(VPVS);\r\nLCR_PR(PLHPIX);\r\nLCR_PR(XS);\r\nLCR_PR(XCKHW);\r\nLCR_PR(STHS);\r\nLCR_PR(VT2);\r\nLCR_PR(YCKSW);\r\nLCR_PR(YSTS);\r\nLCR_PR(PPOLS);\r\nLCR_PR(PRECW);\r\nLCR_PR(VCLKHW);\r\nLCR_PR(OC);\r\n#undef LCR_PR\r\n}\r\nstatic int tmiofb_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(dev);\r\n#ifdef CONFIG_FB_TMIO_ACCELL\r\nstruct tmiofb_par *par = info->par;\r\n#endif\r\nconst struct mfd_cell *cell = mfd_get_cell(dev);\r\nint retval = 0;\r\nconsole_lock();\r\nfb_set_suspend(info, 1);\r\nif (info->fbops->fb_sync)\r\ninfo->fbops->fb_sync(info);\r\n#ifdef CONFIG_FB_TMIO_ACCELL\r\nprintk(KERN_INFO "tmiofb: switching to polling\n");\r\npar->use_polling = true;\r\n#endif\r\ntmiofb_hw_stop(dev);\r\nif (cell->suspend)\r\nretval = cell->suspend(dev);\r\nconsole_unlock();\r\nreturn retval;\r\n}\r\nstatic int tmiofb_resume(struct platform_device *dev)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(dev);\r\nconst struct mfd_cell *cell = mfd_get_cell(dev);\r\nint retval = 0;\r\nconsole_lock();\r\nif (cell->resume) {\r\nretval = cell->resume(dev);\r\nif (retval)\r\ngoto out;\r\n}\r\ntmiofb_irq(-1, info);\r\ntmiofb_hw_init(dev);\r\ntmiofb_hw_mode(dev);\r\nfb_set_suspend(info, 0);\r\nout:\r\nconsole_unlock();\r\nreturn retval;\r\n}\r\nstatic void __init tmiofb_setup(char *options)\r\n{\r\nchar *this_opt;\r\nif (!options || !*options)\r\nreturn;\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nif (!*this_opt)\r\ncontinue;\r\n}\r\n}\r\nstatic int __init tmiofb_init(void)\r\n{\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options("tmiofb", &option))\r\nreturn -ENODEV;\r\ntmiofb_setup(option);\r\n#endif\r\nreturn platform_driver_register(&tmiofb_driver);\r\n}\r\nstatic void __exit tmiofb_cleanup(void)\r\n{\r\nplatform_driver_unregister(&tmiofb_driver);\r\n}
