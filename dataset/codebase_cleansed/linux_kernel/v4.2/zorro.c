struct zorro_dev *zorro_find_device(zorro_id id, struct zorro_dev *from)\r\n{\r\nstruct zorro_dev *z;\r\nif (!zorro_num_autocon)\r\nreturn NULL;\r\nfor (z = from ? from+1 : &zorro_autocon[0];\r\nz < zorro_autocon+zorro_num_autocon;\r\nz++)\r\nif (id == ZORRO_WILDCARD || id == z->id)\r\nreturn z;\r\nreturn NULL;\r\n}\r\nstatic void __init mark_region(unsigned long start, unsigned long end,\r\nint flag)\r\n{\r\nif (flag)\r\nstart += Z2RAM_CHUNKMASK;\r\nelse\r\nend += Z2RAM_CHUNKMASK;\r\nstart &= ~Z2RAM_CHUNKMASK;\r\nend &= ~Z2RAM_CHUNKMASK;\r\nif (end <= Z2RAM_START || start >= Z2RAM_END)\r\nreturn;\r\nstart = start < Z2RAM_START ? 0x00000000 : start-Z2RAM_START;\r\nend = end > Z2RAM_END ? Z2RAM_SIZE : end-Z2RAM_START;\r\nwhile (start < end) {\r\nu32 chunk = start>>Z2RAM_CHUNKSHIFT;\r\nif (flag)\r\nset_bit(chunk, zorro_unused_z2ram);\r\nelse\r\nclear_bit(chunk, zorro_unused_z2ram);\r\nstart += Z2RAM_CHUNKSIZE;\r\n}\r\n}\r\nstatic struct resource __init *zorro_find_parent_resource(\r\nstruct platform_device *bridge, struct zorro_dev *z)\r\n{\r\nint i;\r\nfor (i = 0; i < bridge->num_resources; i++) {\r\nstruct resource *r = &bridge->resource[i];\r\nif (zorro_resource_start(z) >= r->start &&\r\nzorro_resource_end(z) <= r->end)\r\nreturn r;\r\n}\r\nreturn &iomem_resource;\r\n}\r\nstatic int __init amiga_zorro_probe(struct platform_device *pdev)\r\n{\r\nstruct zorro_bus *bus;\r\nstruct zorro_dev_init *zi;\r\nstruct zorro_dev *z;\r\nstruct resource *r;\r\nunsigned int i;\r\nint error;\r\nbus = kzalloc(sizeof(*bus) +\r\nzorro_num_autocon * sizeof(bus->devices[0]),\r\nGFP_KERNEL);\r\nif (!bus)\r\nreturn -ENOMEM;\r\nzorro_autocon = bus->devices;\r\nbus->dev.parent = &pdev->dev;\r\ndev_set_name(&bus->dev, zorro_bus_type.name);\r\nerror = device_register(&bus->dev);\r\nif (error) {\r\npr_err("Zorro: Error registering zorro_bus\n");\r\nput_device(&bus->dev);\r\nkfree(bus);\r\nreturn error;\r\n}\r\nplatform_set_drvdata(pdev, bus);\r\npr_info("Zorro: Probing AutoConfig expansion devices: %u device%s\n",\r\nzorro_num_autocon, zorro_num_autocon == 1 ? "" : "s");\r\nfor (i = 0; i < zorro_num_autocon; i++) {\r\nzi = &zorro_autocon_init[i];\r\nz = &zorro_autocon[i];\r\nz->rom = zi->rom;\r\nz->id = (be16_to_cpu(z->rom.er_Manufacturer) << 16) |\r\n(z->rom.er_Product << 8);\r\nif (z->id == ZORRO_PROD_GVP_EPC_BASE) {\r\nunsigned long magic = zi->boardaddr + 0x8000;\r\nz->id |= *(u16 *)ZTWO_VADDR(magic) & GVP_PRODMASK;\r\n}\r\nz->slotaddr = zi->slotaddr;\r\nz->slotsize = zi->slotsize;\r\nsprintf(z->name, "Zorro device %08x", z->id);\r\nzorro_name_device(z);\r\nz->resource.start = zi->boardaddr;\r\nz->resource.end = zi->boardaddr + zi->boardsize - 1;\r\nz->resource.name = z->name;\r\nr = zorro_find_parent_resource(pdev, z);\r\nerror = request_resource(r, &z->resource);\r\nif (error)\r\ndev_err(&bus->dev,\r\n"Address space collision on device %s %pR\n",\r\nz->name, &z->resource);\r\nz->dev.parent = &bus->dev;\r\nz->dev.bus = &zorro_bus_type;\r\nz->dev.id = i;\r\n}\r\nfor (i = 0; i < zorro_num_autocon; i++) {\r\nz = &zorro_autocon[i];\r\nerror = device_register(&z->dev);\r\nif (error) {\r\ndev_err(&bus->dev, "Error registering device %s\n",\r\nz->name);\r\nput_device(&z->dev);\r\ncontinue;\r\n}\r\nerror = zorro_create_sysfs_dev_files(z);\r\nif (error)\r\ndev_err(&z->dev, "Error creating sysfs files\n");\r\n}\r\nzorro_for_each_dev(z) {\r\nif (z->rom.er_Type & ERTF_MEMLIST)\r\nmark_region(zorro_resource_start(z),\r\nzorro_resource_end(z)+1, 1);\r\n}\r\nfor (i = 0; i < m68k_num_memory; i++)\r\nif (m68k_memory[i].addr < 16*1024*1024)\r\nmark_region(m68k_memory[i].addr,\r\nm68k_memory[i].addr+m68k_memory[i].size,\r\n0);\r\nreturn 0;\r\n}\r\nstatic int __init amiga_zorro_init(void)\r\n{\r\nreturn platform_driver_probe(&amiga_zorro_driver, amiga_zorro_probe);\r\n}
