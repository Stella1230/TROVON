static int\r\nnouveau_display_vblank_handler(struct nvif_notify *notify)\r\n{\r\nstruct nouveau_crtc *nv_crtc =\r\ncontainer_of(notify, typeof(*nv_crtc), vblank);\r\ndrm_handle_vblank(nv_crtc->base.dev, nv_crtc->index);\r\nreturn NVIF_NOTIFY_KEEP;\r\n}\r\nint\r\nnouveau_display_vblank_enable(struct drm_device *dev, int head)\r\n{\r\nstruct drm_crtc *crtc;\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nif (nv_crtc->index == head) {\r\nnvif_notify_get(&nv_crtc->vblank);\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nvoid\r\nnouveau_display_vblank_disable(struct drm_device *dev, int head)\r\n{\r\nstruct drm_crtc *crtc;\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nif (nv_crtc->index == head) {\r\nnvif_notify_put(&nv_crtc->vblank);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic inline int\r\ncalc(int blanks, int blanke, int total, int line)\r\n{\r\nif (blanke >= blanks) {\r\nif (line >= blanks)\r\nline -= total;\r\n} else {\r\nif (line >= blanks)\r\nline -= total;\r\nline -= blanke + 1;\r\n}\r\nreturn line;\r\n}\r\nint\r\nnouveau_display_scanoutpos_head(struct drm_crtc *crtc, int *vpos, int *hpos,\r\nktime_t *stime, ktime_t *etime)\r\n{\r\nstruct {\r\nstruct nv04_disp_mthd_v0 base;\r\nstruct nv04_disp_scanoutpos_v0 scan;\r\n} args = {\r\n.base.method = NV04_DISP_SCANOUTPOS,\r\n.base.head = nouveau_crtc(crtc)->index,\r\n};\r\nstruct nouveau_display *disp = nouveau_display(crtc->dev);\r\nint ret, retry = 1;\r\ndo {\r\nret = nvif_mthd(&disp->disp, 0, &args, sizeof(args));\r\nif (ret != 0)\r\nreturn 0;\r\nif (args.scan.vline) {\r\nret |= DRM_SCANOUTPOS_ACCURATE;\r\nret |= DRM_SCANOUTPOS_VALID;\r\nbreak;\r\n}\r\nif (retry) ndelay(crtc->linedur_ns);\r\n} while (retry--);\r\n*hpos = args.scan.hline;\r\n*vpos = calc(args.scan.vblanks, args.scan.vblanke,\r\nargs.scan.vtotal, args.scan.vline);\r\nif (stime) *stime = ns_to_ktime(args.scan.time[0]);\r\nif (etime) *etime = ns_to_ktime(args.scan.time[1]);\r\nif (*vpos < 0)\r\nret |= DRM_SCANOUTPOS_IN_VBLANK;\r\nreturn ret;\r\n}\r\nint\r\nnouveau_display_scanoutpos(struct drm_device *dev, int head, unsigned int flags,\r\nint *vpos, int *hpos, ktime_t *stime, ktime_t *etime)\r\n{\r\nstruct drm_crtc *crtc;\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nif (nouveau_crtc(crtc)->index == head) {\r\nreturn nouveau_display_scanoutpos_head(crtc, vpos, hpos,\r\nstime, etime);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint\r\nnouveau_display_vblstamp(struct drm_device *dev, int head, int *max_error,\r\nstruct timeval *time, unsigned flags)\r\n{\r\nstruct drm_crtc *crtc;\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nif (nouveau_crtc(crtc)->index == head) {\r\nreturn drm_calc_vbltimestamp_from_scanoutpos(dev,\r\nhead, max_error, time, flags, crtc,\r\n&crtc->hwmode);\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void\r\nnouveau_display_vblank_fini(struct drm_device *dev)\r\n{\r\nstruct drm_crtc *crtc;\r\ndrm_vblank_cleanup(dev);\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nnvif_notify_fini(&nv_crtc->vblank);\r\n}\r\n}\r\nstatic int\r\nnouveau_display_vblank_init(struct drm_device *dev)\r\n{\r\nstruct nouveau_display *disp = nouveau_display(dev);\r\nstruct drm_crtc *crtc;\r\nint ret;\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nret = nvif_notify_init(&disp->disp, NULL,\r\nnouveau_display_vblank_handler, false,\r\nNV04_DISP_NTFY_VBLANK,\r\n&(struct nvif_notify_head_req_v0) {\r\n.head = nv_crtc->index,\r\n},\r\nsizeof(struct nvif_notify_head_req_v0),\r\nsizeof(struct nvif_notify_head_rep_v0),\r\n&nv_crtc->vblank);\r\nif (ret) {\r\nnouveau_display_vblank_fini(dev);\r\nreturn ret;\r\n}\r\n}\r\nret = drm_vblank_init(dev, dev->mode_config.num_crtc);\r\nif (ret) {\r\nnouveau_display_vblank_fini(dev);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nnouveau_user_framebuffer_destroy(struct drm_framebuffer *drm_fb)\r\n{\r\nstruct nouveau_framebuffer *fb = nouveau_framebuffer(drm_fb);\r\nstruct nouveau_display *disp = nouveau_display(drm_fb->dev);\r\nif (disp->fb_dtor)\r\ndisp->fb_dtor(drm_fb);\r\nif (fb->nvbo)\r\ndrm_gem_object_unreference_unlocked(&fb->nvbo->gem);\r\ndrm_framebuffer_cleanup(drm_fb);\r\nkfree(fb);\r\n}\r\nstatic int\r\nnouveau_user_framebuffer_create_handle(struct drm_framebuffer *drm_fb,\r\nstruct drm_file *file_priv,\r\nunsigned int *handle)\r\n{\r\nstruct nouveau_framebuffer *fb = nouveau_framebuffer(drm_fb);\r\nreturn drm_gem_handle_create(file_priv, &fb->nvbo->gem, handle);\r\n}\r\nint\r\nnouveau_framebuffer_init(struct drm_device *dev,\r\nstruct nouveau_framebuffer *nv_fb,\r\nstruct drm_mode_fb_cmd2 *mode_cmd,\r\nstruct nouveau_bo *nvbo)\r\n{\r\nstruct nouveau_display *disp = nouveau_display(dev);\r\nstruct drm_framebuffer *fb = &nv_fb->base;\r\nint ret;\r\ndrm_helper_mode_fill_fb_struct(fb, mode_cmd);\r\nnv_fb->nvbo = nvbo;\r\nret = drm_framebuffer_init(dev, fb, &nouveau_framebuffer_funcs);\r\nif (ret)\r\nreturn ret;\r\nif (disp->fb_ctor) {\r\nret = disp->fb_ctor(fb);\r\nif (ret)\r\ndisp->fb_dtor(fb);\r\n}\r\nreturn ret;\r\n}\r\nstatic struct drm_framebuffer *\r\nnouveau_user_framebuffer_create(struct drm_device *dev,\r\nstruct drm_file *file_priv,\r\nstruct drm_mode_fb_cmd2 *mode_cmd)\r\n{\r\nstruct nouveau_framebuffer *nouveau_fb;\r\nstruct drm_gem_object *gem;\r\nint ret = -ENOMEM;\r\ngem = drm_gem_object_lookup(dev, file_priv, mode_cmd->handles[0]);\r\nif (!gem)\r\nreturn ERR_PTR(-ENOENT);\r\nnouveau_fb = kzalloc(sizeof(struct nouveau_framebuffer), GFP_KERNEL);\r\nif (!nouveau_fb)\r\ngoto err_unref;\r\nret = nouveau_framebuffer_init(dev, nouveau_fb, mode_cmd, nouveau_gem_object(gem));\r\nif (ret)\r\ngoto err;\r\nreturn &nouveau_fb->base;\r\nerr:\r\nkfree(nouveau_fb);\r\nerr_unref:\r\ndrm_gem_object_unreference(gem);\r\nreturn ERR_PTR(ret);\r\n}\r\nint\r\nnouveau_display_init(struct drm_device *dev)\r\n{\r\nstruct nouveau_display *disp = nouveau_display(dev);\r\nstruct drm_connector *connector;\r\nint ret;\r\nret = disp->init(dev);\r\nif (ret)\r\nreturn ret;\r\ndrm_kms_helper_poll_enable(dev);\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nstruct nouveau_connector *conn = nouveau_connector(connector);\r\nnvif_notify_get(&conn->hpd);\r\n}\r\nreturn ret;\r\n}\r\nvoid\r\nnouveau_display_fini(struct drm_device *dev)\r\n{\r\nstruct nouveau_display *disp = nouveau_display(dev);\r\nstruct drm_connector *connector;\r\nint head;\r\nfor (head = 0; head < dev->mode_config.num_crtc; head++)\r\ndrm_vblank_off(dev, head);\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nstruct nouveau_connector *conn = nouveau_connector(connector);\r\nnvif_notify_put(&conn->hpd);\r\n}\r\ndrm_kms_helper_poll_disable(dev);\r\ndisp->fini(dev);\r\n}\r\nstatic void\r\nnouveau_display_create_properties(struct drm_device *dev)\r\n{\r\nstruct nouveau_display *disp = nouveau_display(dev);\r\nint gen;\r\nif (disp->disp.oclass < NV50_DISP)\r\ngen = 0;\r\nelse\r\nif (disp->disp.oclass < GF110_DISP)\r\ngen = 1;\r\nelse\r\ngen = 2;\r\nPROP_ENUM(disp->dithering_mode, gen, "dithering mode", dither_mode);\r\nPROP_ENUM(disp->dithering_depth, gen, "dithering depth", dither_depth);\r\nPROP_ENUM(disp->underscan_property, gen, "underscan", underscan);\r\ndisp->underscan_hborder_property =\r\ndrm_property_create_range(dev, 0, "underscan hborder", 0, 128);\r\ndisp->underscan_vborder_property =\r\ndrm_property_create_range(dev, 0, "underscan vborder", 0, 128);\r\nif (gen < 1)\r\nreturn;\r\ndisp->vibrant_hue_property =\r\ndrm_property_create_range(dev, 0, "vibrant hue", 0, 180);\r\ndisp->color_vibrance_property =\r\ndrm_property_create_range(dev, 0, "color vibrance", 0, 200);\r\n}\r\nint\r\nnouveau_display_create(struct drm_device *dev)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_display *disp;\r\nint ret;\r\ndisp = drm->display = kzalloc(sizeof(*disp), GFP_KERNEL);\r\nif (!disp)\r\nreturn -ENOMEM;\r\ndrm_mode_config_init(dev);\r\ndrm_mode_create_scaling_mode_property(dev);\r\ndrm_mode_create_dvi_i_properties(dev);\r\ndev->mode_config.funcs = &nouveau_mode_config_funcs;\r\ndev->mode_config.fb_base = nv_device_resource_start(nvxx_device(&drm->device), 1);\r\ndev->mode_config.min_width = 0;\r\ndev->mode_config.min_height = 0;\r\nif (drm->device.info.family < NV_DEVICE_INFO_V0_CELSIUS) {\r\ndev->mode_config.max_width = 2048;\r\ndev->mode_config.max_height = 2048;\r\n} else\r\nif (drm->device.info.family < NV_DEVICE_INFO_V0_TESLA) {\r\ndev->mode_config.max_width = 4096;\r\ndev->mode_config.max_height = 4096;\r\n} else {\r\ndev->mode_config.max_width = 8192;\r\ndev->mode_config.max_height = 8192;\r\n}\r\ndev->mode_config.preferred_depth = 24;\r\ndev->mode_config.prefer_shadow = 1;\r\nif (drm->device.info.chipset < 0x11)\r\ndev->mode_config.async_page_flip = false;\r\nelse\r\ndev->mode_config.async_page_flip = true;\r\ndrm_kms_helper_poll_init(dev);\r\ndrm_kms_helper_poll_disable(dev);\r\nif (nouveau_modeset != 2 && drm->vbios.dcb.entries) {\r\nstatic const u16 oclass[] = {\r\nGM204_DISP,\r\nGM107_DISP,\r\nGK110_DISP,\r\nGK104_DISP,\r\nGF110_DISP,\r\nGT214_DISP,\r\nGT206_DISP,\r\nGT200_DISP,\r\nG82_DISP,\r\nNV50_DISP,\r\nNV04_DISP,\r\n};\r\nint i;\r\nfor (i = 0, ret = -ENODEV; ret && i < ARRAY_SIZE(oclass); i++) {\r\nret = nvif_object_init(nvif_object(&drm->device), NULL,\r\nNVDRM_DISPLAY, oclass[i],\r\nNULL, 0, &disp->disp);\r\n}\r\nif (ret == 0) {\r\nnouveau_display_create_properties(dev);\r\nif (disp->disp.oclass < NV50_DISP)\r\nret = nv04_display_create(dev);\r\nelse\r\nret = nv50_display_create(dev);\r\n}\r\n} else {\r\nret = 0;\r\n}\r\nif (ret)\r\ngoto disp_create_err;\r\nif (dev->mode_config.num_crtc) {\r\nret = nouveau_display_vblank_init(dev);\r\nif (ret)\r\ngoto vblank_err;\r\n}\r\nnouveau_backlight_init(dev);\r\nreturn 0;\r\nvblank_err:\r\ndisp->dtor(dev);\r\ndisp_create_err:\r\ndrm_kms_helper_poll_fini(dev);\r\ndrm_mode_config_cleanup(dev);\r\nreturn ret;\r\n}\r\nvoid\r\nnouveau_display_destroy(struct drm_device *dev)\r\n{\r\nstruct nouveau_display *disp = nouveau_display(dev);\r\nnouveau_backlight_exit(dev);\r\nnouveau_display_vblank_fini(dev);\r\ndrm_kms_helper_poll_fini(dev);\r\ndrm_mode_config_cleanup(dev);\r\nif (disp->dtor)\r\ndisp->dtor(dev);\r\nnvif_object_fini(&disp->disp);\r\nnouveau_drm(dev)->display = NULL;\r\nkfree(disp);\r\n}\r\nint\r\nnouveau_display_suspend(struct drm_device *dev, bool runtime)\r\n{\r\nstruct drm_crtc *crtc;\r\nnouveau_display_fini(dev);\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nstruct nouveau_framebuffer *nouveau_fb;\r\nnouveau_fb = nouveau_framebuffer(crtc->primary->fb);\r\nif (!nouveau_fb || !nouveau_fb->nvbo)\r\ncontinue;\r\nnouveau_bo_unpin(nouveau_fb->nvbo);\r\n}\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nif (nv_crtc->cursor.nvbo) {\r\nif (nv_crtc->cursor.set_offset)\r\nnouveau_bo_unmap(nv_crtc->cursor.nvbo);\r\nnouveau_bo_unpin(nv_crtc->cursor.nvbo);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nnouveau_display_resume(struct drm_device *dev, bool runtime)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct drm_crtc *crtc;\r\nint ret, head;\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nstruct nouveau_framebuffer *nouveau_fb;\r\nnouveau_fb = nouveau_framebuffer(crtc->primary->fb);\r\nif (!nouveau_fb || !nouveau_fb->nvbo)\r\ncontinue;\r\nret = nouveau_bo_pin(nouveau_fb->nvbo, TTM_PL_FLAG_VRAM, true);\r\nif (ret)\r\nNV_ERROR(drm, "Could not pin framebuffer\n");\r\n}\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nif (!nv_crtc->cursor.nvbo)\r\ncontinue;\r\nret = nouveau_bo_pin(nv_crtc->cursor.nvbo, TTM_PL_FLAG_VRAM, true);\r\nif (!ret && nv_crtc->cursor.set_offset)\r\nret = nouveau_bo_map(nv_crtc->cursor.nvbo);\r\nif (ret)\r\nNV_ERROR(drm, "Could not pin/map cursor.\n");\r\n}\r\nnouveau_display_init(dev);\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nnv_crtc->lut.depth = 0;\r\n}\r\nfor (head = 0; head < dev->mode_config.num_crtc; head++)\r\ndrm_vblank_on(dev, head);\r\nif (runtime)\r\nreturn;\r\ndrm_helper_resume_force_mode(dev);\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nif (!nv_crtc->cursor.nvbo)\r\ncontinue;\r\nif (nv_crtc->cursor.set_offset)\r\nnv_crtc->cursor.set_offset(nv_crtc, nv_crtc->cursor.nvbo->bo.offset);\r\nnv_crtc->cursor.set_pos(nv_crtc, nv_crtc->cursor_saved_x,\r\nnv_crtc->cursor_saved_y);\r\n}\r\n}\r\nstatic int\r\nnouveau_page_flip_emit(struct nouveau_channel *chan,\r\nstruct nouveau_bo *old_bo,\r\nstruct nouveau_bo *new_bo,\r\nstruct nouveau_page_flip_state *s,\r\nstruct nouveau_fence **pfence)\r\n{\r\nstruct nouveau_fence_chan *fctx = chan->fence;\r\nstruct nouveau_drm *drm = chan->drm;\r\nstruct drm_device *dev = drm->dev;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nlist_add_tail(&s->head, &fctx->flip);\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\nret = nouveau_fence_sync(old_bo, chan, false, false);\r\nif (ret)\r\ngoto fail;\r\nret = RING_SPACE(chan, 2);\r\nif (ret)\r\ngoto fail;\r\nif (drm->device.info.family < NV_DEVICE_INFO_V0_FERMI)\r\nBEGIN_NV04(chan, NvSubSw, NV_SW_PAGE_FLIP, 1);\r\nelse\r\nBEGIN_NVC0(chan, FermiSw, NV_SW_PAGE_FLIP, 1);\r\nOUT_RING (chan, 0x00000000);\r\nFIRE_RING (chan);\r\nret = nouveau_fence_new(chan, false, pfence);\r\nif (ret)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nlist_del(&s->head);\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\nreturn ret;\r\n}\r\nint\r\nnouveau_crtc_page_flip(struct drm_crtc *crtc, struct drm_framebuffer *fb,\r\nstruct drm_pending_vblank_event *event, u32 flags)\r\n{\r\nconst int swap_interval = (flags & DRM_MODE_PAGE_FLIP_ASYNC) ? 0 : 1;\r\nstruct drm_device *dev = crtc->dev;\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_bo *old_bo = nouveau_framebuffer(crtc->primary->fb)->nvbo;\r\nstruct nouveau_bo *new_bo = nouveau_framebuffer(fb)->nvbo;\r\nstruct nouveau_page_flip_state *s;\r\nstruct nouveau_channel *chan;\r\nstruct nouveau_cli *cli;\r\nstruct nouveau_fence *fence;\r\nint ret;\r\nchan = drm->channel;\r\nif (!chan)\r\nreturn -ENODEV;\r\ncli = (void *)nvif_client(&chan->device->base);\r\ns = kzalloc(sizeof(*s), GFP_KERNEL);\r\nif (!s)\r\nreturn -ENOMEM;\r\nif (new_bo != old_bo) {\r\nret = nouveau_bo_pin(new_bo, TTM_PL_FLAG_VRAM, true);\r\nif (ret)\r\ngoto fail_free;\r\n}\r\nmutex_lock(&cli->mutex);\r\nret = ttm_bo_reserve(&new_bo->bo, true, false, false, NULL);\r\nif (ret)\r\ngoto fail_unpin;\r\nret = nouveau_fence_sync(new_bo, chan, false, true);\r\nif (ret) {\r\nttm_bo_unreserve(&new_bo->bo);\r\ngoto fail_unpin;\r\n}\r\nif (new_bo != old_bo) {\r\nttm_bo_unreserve(&new_bo->bo);\r\nret = ttm_bo_reserve(&old_bo->bo, true, false, false, NULL);\r\nif (ret)\r\ngoto fail_unpin;\r\n}\r\n*s = (struct nouveau_page_flip_state)\r\n{ { }, event, nouveau_crtc(crtc)->index,\r\nfb->bits_per_pixel, fb->pitches[0], crtc->x, crtc->y,\r\nnew_bo->bo.offset };\r\ndrm_vblank_get(dev, nouveau_crtc(crtc)->index);\r\nif (drm->device.info.family >= NV_DEVICE_INFO_V0_TESLA) {\r\nret = nv50_display_flip_next(crtc, fb, chan, swap_interval);\r\nif (ret)\r\ngoto fail_unreserve;\r\n} else {\r\nstruct nv04_display *dispnv04 = nv04_display(dev);\r\nint head = nouveau_crtc(crtc)->index;\r\nif (swap_interval) {\r\nret = RING_SPACE(chan, 8);\r\nif (ret)\r\ngoto fail_unreserve;\r\nBEGIN_NV04(chan, NvSubImageBlit, 0x012c, 1);\r\nOUT_RING (chan, 0);\r\nBEGIN_NV04(chan, NvSubImageBlit, 0x0134, 1);\r\nOUT_RING (chan, head);\r\nBEGIN_NV04(chan, NvSubImageBlit, 0x0100, 1);\r\nOUT_RING (chan, 0);\r\nBEGIN_NV04(chan, NvSubImageBlit, 0x0130, 1);\r\nOUT_RING (chan, 0);\r\n}\r\nnouveau_bo_ref(new_bo, &dispnv04->image[head]);\r\n}\r\nret = nouveau_page_flip_emit(chan, old_bo, new_bo, s, &fence);\r\nif (ret)\r\ngoto fail_unreserve;\r\nmutex_unlock(&cli->mutex);\r\ncrtc->primary->fb = fb;\r\nnouveau_bo_fence(old_bo, fence, false);\r\nttm_bo_unreserve(&old_bo->bo);\r\nif (old_bo != new_bo)\r\nnouveau_bo_unpin(old_bo);\r\nnouveau_fence_unref(&fence);\r\nreturn 0;\r\nfail_unreserve:\r\ndrm_vblank_put(dev, nouveau_crtc(crtc)->index);\r\nttm_bo_unreserve(&old_bo->bo);\r\nfail_unpin:\r\nmutex_unlock(&cli->mutex);\r\nif (old_bo != new_bo)\r\nnouveau_bo_unpin(new_bo);\r\nfail_free:\r\nkfree(s);\r\nreturn ret;\r\n}\r\nint\r\nnouveau_finish_page_flip(struct nouveau_channel *chan,\r\nstruct nouveau_page_flip_state *ps)\r\n{\r\nstruct nouveau_fence_chan *fctx = chan->fence;\r\nstruct nouveau_drm *drm = chan->drm;\r\nstruct drm_device *dev = drm->dev;\r\nstruct nouveau_page_flip_state *s;\r\nunsigned long flags;\r\nint crtcid = -1;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nif (list_empty(&fctx->flip)) {\r\nNV_ERROR(drm, "unexpected pageflip\n");\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\nreturn -EINVAL;\r\n}\r\ns = list_first_entry(&fctx->flip, struct nouveau_page_flip_state, head);\r\nif (s->event) {\r\nif (drm->device.info.family >= NV_DEVICE_INFO_V0_TESLA)\r\ncrtcid = s->crtc;\r\ndrm_send_vblank_event(dev, crtcid, s->event);\r\n}\r\ndrm_vblank_put(dev, s->crtc);\r\nlist_del(&s->head);\r\nif (ps)\r\n*ps = *s;\r\nkfree(s);\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\nreturn 0;\r\n}\r\nint\r\nnouveau_flip_complete(void *data)\r\n{\r\nstruct nouveau_channel *chan = data;\r\nstruct nouveau_drm *drm = chan->drm;\r\nstruct nouveau_page_flip_state state;\r\nif (!nouveau_finish_page_flip(chan, &state)) {\r\nif (drm->device.info.family < NV_DEVICE_INFO_V0_TESLA) {\r\nnv_set_crtc_base(drm->dev, state.crtc, state.offset +\r\nstate.y * state.pitch +\r\nstate.x * state.bpp / 8);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint\r\nnouveau_display_dumb_create(struct drm_file *file_priv, struct drm_device *dev,\r\nstruct drm_mode_create_dumb *args)\r\n{\r\nstruct nouveau_bo *bo;\r\nuint32_t domain;\r\nint ret;\r\nargs->pitch = roundup(args->width * (args->bpp / 8), 256);\r\nargs->size = args->pitch * args->height;\r\nargs->size = roundup(args->size, PAGE_SIZE);\r\nif (nouveau_drm(dev)->device.info.ram_size != 0)\r\ndomain = NOUVEAU_GEM_DOMAIN_VRAM;\r\nelse\r\ndomain = NOUVEAU_GEM_DOMAIN_GART;\r\nret = nouveau_gem_new(dev, args->size, 0, domain, 0, 0, &bo);\r\nif (ret)\r\nreturn ret;\r\nret = drm_gem_handle_create(file_priv, &bo->gem, &args->handle);\r\ndrm_gem_object_unreference_unlocked(&bo->gem);\r\nreturn ret;\r\n}\r\nint\r\nnouveau_display_dumb_map_offset(struct drm_file *file_priv,\r\nstruct drm_device *dev,\r\nuint32_t handle, uint64_t *poffset)\r\n{\r\nstruct drm_gem_object *gem;\r\ngem = drm_gem_object_lookup(dev, file_priv, handle);\r\nif (gem) {\r\nstruct nouveau_bo *bo = nouveau_gem_object(gem);\r\n*poffset = drm_vma_node_offset_addr(&bo->bo.vma_node);\r\ndrm_gem_object_unreference_unlocked(gem);\r\nreturn 0;\r\n}\r\nreturn -ENOENT;\r\n}
