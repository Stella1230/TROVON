static bool memeq(const void *a, const void *b, size_t size)\r\n{\r\nconst uint8_t *x = a;\r\nconst uint8_t *y = b;\r\nsize_t i;\r\nfor (i = 0; i < size; ++i)\r\nif (x[i] != y[i])\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void memzero(void *buf, size_t size)\r\n{\r\nuint8_t *b = buf;\r\nuint8_t *e = b + size;\r\nwhile (b != e)\r\n*b++ = '\0';\r\n}\r\nvoid *memmove(void *dest, const void *src, size_t size)\r\n{\r\nuint8_t *d = dest;\r\nconst uint8_t *s = src;\r\nsize_t i;\r\nif (d < s) {\r\nfor (i = 0; i < size; ++i)\r\nd[i] = s[i];\r\n} else if (d > s) {\r\ni = size;\r\nwhile (i-- > 0)\r\nd[i] = s[i];\r\n}\r\nreturn dest;\r\n}\r\nSTATIC int INIT unxz(unsigned char *in, long in_size,\r\nlong (*fill)(void *dest, unsigned long size),\r\nlong (*flush)(void *src, unsigned long size),\r\nunsigned char *out, long *in_used,\r\nvoid (*error)(char *x))\r\n{\r\nstruct xz_buf b;\r\nstruct xz_dec *s;\r\nenum xz_ret ret;\r\nbool must_free_in = false;\r\n#if XZ_INTERNAL_CRC32\r\nxz_crc32_init();\r\n#endif\r\nif (in_used != NULL)\r\n*in_used = 0;\r\nif (fill == NULL && flush == NULL)\r\ns = xz_dec_init(XZ_SINGLE, 0);\r\nelse\r\ns = xz_dec_init(XZ_DYNALLOC, (uint32_t)-1);\r\nif (s == NULL)\r\ngoto error_alloc_state;\r\nif (flush == NULL) {\r\nb.out = out;\r\nb.out_size = (size_t)-1;\r\n} else {\r\nb.out_size = XZ_IOBUF_SIZE;\r\nb.out = malloc(XZ_IOBUF_SIZE);\r\nif (b.out == NULL)\r\ngoto error_alloc_out;\r\n}\r\nif (in == NULL) {\r\nmust_free_in = true;\r\nin = malloc(XZ_IOBUF_SIZE);\r\nif (in == NULL)\r\ngoto error_alloc_in;\r\n}\r\nb.in = in;\r\nb.in_pos = 0;\r\nb.in_size = in_size;\r\nb.out_pos = 0;\r\nif (fill == NULL && flush == NULL) {\r\nret = xz_dec_run(s, &b);\r\n} else {\r\ndo {\r\nif (b.in_pos == b.in_size && fill != NULL) {\r\nif (in_used != NULL)\r\n*in_used += b.in_pos;\r\nb.in_pos = 0;\r\nin_size = fill(in, XZ_IOBUF_SIZE);\r\nif (in_size < 0) {\r\nret = XZ_BUF_ERROR;\r\nbreak;\r\n}\r\nb.in_size = in_size;\r\n}\r\nret = xz_dec_run(s, &b);\r\nif (flush != NULL && (b.out_pos == b.out_size\r\n|| (ret != XZ_OK && b.out_pos > 0))) {\r\nif (flush(b.out, b.out_pos) != (long)b.out_pos)\r\nret = XZ_BUF_ERROR;\r\nb.out_pos = 0;\r\n}\r\n} while (ret == XZ_OK);\r\nif (must_free_in)\r\nfree(in);\r\nif (flush != NULL)\r\nfree(b.out);\r\n}\r\nif (in_used != NULL)\r\n*in_used += b.in_pos;\r\nxz_dec_end(s);\r\nswitch (ret) {\r\ncase XZ_STREAM_END:\r\nreturn 0;\r\ncase XZ_MEM_ERROR:\r\nerror("XZ decompressor ran out of memory");\r\nbreak;\r\ncase XZ_FORMAT_ERROR:\r\nerror("Input is not in the XZ format (wrong magic bytes)");\r\nbreak;\r\ncase XZ_OPTIONS_ERROR:\r\nerror("Input was encoded with settings that are not "\r\n"supported by this XZ decoder");\r\nbreak;\r\ncase XZ_DATA_ERROR:\r\ncase XZ_BUF_ERROR:\r\nerror("XZ-compressed data is corrupt");\r\nbreak;\r\ndefault:\r\nerror("Bug in the XZ decompressor");\r\nbreak;\r\n}\r\nreturn -1;\r\nerror_alloc_in:\r\nif (flush != NULL)\r\nfree(b.out);\r\nerror_alloc_out:\r\nxz_dec_end(s);\r\nerror_alloc_state:\r\nerror("XZ decompressor ran out of memory");\r\nreturn -1;\r\n}
