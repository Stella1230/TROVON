static inline int convert_bin_to_uAh(\r\nconst struct ltc294x_info *info, int Q)\r\n{\r\nreturn ((Q * (info->Qlsb / 10))) / 100;\r\n}\r\nstatic inline int convert_uAh_to_bin(\r\nconst struct ltc294x_info *info, int uAh)\r\n{\r\nint Q;\r\nQ = (uAh * 100) / (info->Qlsb/10);\r\nreturn (Q < LTC294X_MAX_VALUE) ? Q : LTC294X_MAX_VALUE;\r\n}\r\nstatic int ltc294x_read_regs(struct i2c_client *client,\r\nenum ltc294x_reg reg, u8 *buf, int num_regs)\r\n{\r\nint ret;\r\nstruct i2c_msg msgs[2] = { };\r\nu8 reg_start = reg;\r\nmsgs[0].addr = client->addr;\r\nmsgs[0].len = 1;\r\nmsgs[0].buf = &reg_start;\r\nmsgs[1].addr = client->addr;\r\nmsgs[1].len = num_regs;\r\nmsgs[1].buf = buf;\r\nmsgs[1].flags = I2C_M_RD;\r\nret = i2c_transfer(client->adapter, &msgs[0], 2);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "ltc2941 read_reg failed!\n");\r\nreturn ret;\r\n}\r\ndev_dbg(&client->dev, "%s (%#x, %d) -> %#x\n",\r\n__func__, reg, num_regs, *buf);\r\nreturn 0;\r\n}\r\nstatic int ltc294x_write_regs(struct i2c_client *client,\r\nenum ltc294x_reg reg, const u8 *buf, int num_regs)\r\n{\r\nint ret;\r\nu8 reg_start = reg;\r\nret = i2c_smbus_write_i2c_block_data(client, reg_start, num_regs, buf);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "ltc2941 write_reg failed!\n");\r\nreturn ret;\r\n}\r\ndev_dbg(&client->dev, "%s (%#x, %d) -> %#x\n",\r\n__func__, reg, num_regs, *buf);\r\nreturn 0;\r\n}\r\nstatic int ltc294x_reset(const struct ltc294x_info *info, int prescaler_exp)\r\n{\r\nint ret;\r\nu8 value;\r\nu8 control;\r\nret = ltc294x_read_regs(info->client, LTC294X_REG_CONTROL, &value, 1);\r\nif (ret < 0) {\r\ndev_err(&info->client->dev,\r\n"Could not read registers from device\n");\r\ngoto error_exit;\r\n}\r\ncontrol = LTC294X_REG_CONTROL_PRESCALER_SET(prescaler_exp) |\r\nLTC294X_REG_CONTROL_ALCC_CONFIG_DISABLED;\r\nif (info->num_regs == LTC2943_NUM_REGS)\r\ncontrol |= LTC2943_REG_CONTROL_MODE_SCAN;\r\nif (value != control) {\r\nret = ltc294x_write_regs(info->client,\r\nLTC294X_REG_CONTROL, &control, 1);\r\nif (ret < 0) {\r\ndev_err(&info->client->dev,\r\n"Could not write register\n");\r\ngoto error_exit;\r\n}\r\n}\r\nreturn 0;\r\nerror_exit:\r\nreturn ret;\r\n}\r\nstatic int ltc294x_read_charge_register(const struct ltc294x_info *info)\r\n{\r\nint ret;\r\nu8 datar[2];\r\nret = ltc294x_read_regs(info->client,\r\nLTC294X_REG_ACC_CHARGE_MSB, &datar[0], 2);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn (datar[0] << 8) + datar[1];\r\n}\r\nstatic int ltc294x_get_charge_now(const struct ltc294x_info *info, int *val)\r\n{\r\nint value = ltc294x_read_charge_register(info);\r\nif (value < 0)\r\nreturn value;\r\nif (info->Qlsb < 0)\r\nvalue -= 0xFFFF;\r\n*val = convert_bin_to_uAh(info, value);\r\nreturn 0;\r\n}\r\nstatic int ltc294x_set_charge_now(const struct ltc294x_info *info, int val)\r\n{\r\nint ret;\r\nu8 dataw[2];\r\nu8 ctrl_reg;\r\ns32 value;\r\nvalue = convert_uAh_to_bin(info, val);\r\nif (info->Qlsb < 0)\r\nvalue += 0xFFFF;\r\nif ((value < 0) || (value > 0xFFFF))\r\nreturn -EINVAL;\r\nret = ltc294x_read_regs(info->client,\r\nLTC294X_REG_CONTROL, &ctrl_reg, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nctrl_reg |= LTC294X_REG_CONTROL_SHUTDOWN_MASK;\r\nret = ltc294x_write_regs(info->client,\r\nLTC294X_REG_CONTROL, &ctrl_reg, 1);\r\nif (ret < 0)\r\nreturn ret;\r\ndataw[0] = I16_MSB(value);\r\ndataw[1] = I16_LSB(value);\r\nret = ltc294x_write_regs(info->client,\r\nLTC294X_REG_ACC_CHARGE_MSB, &dataw[0], 2);\r\nif (ret < 0)\r\ngoto error_exit;\r\nerror_exit:\r\nctrl_reg &= ~LTC294X_REG_CONTROL_SHUTDOWN_MASK;\r\nret = ltc294x_write_regs(info->client,\r\nLTC294X_REG_CONTROL, &ctrl_reg, 1);\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nstatic int ltc294x_get_charge_counter(\r\nconst struct ltc294x_info *info, int *val)\r\n{\r\nint value = ltc294x_read_charge_register(info);\r\nif (value < 0)\r\nreturn value;\r\nvalue -= LTC294X_MID_SUPPLY;\r\n*val = convert_bin_to_uAh(info, value);\r\nreturn 0;\r\n}\r\nstatic int ltc294x_get_voltage(const struct ltc294x_info *info, int *val)\r\n{\r\nint ret;\r\nu8 datar[2];\r\nu32 value;\r\nret = ltc294x_read_regs(info->client,\r\nLTC294X_REG_VOLTAGE_MSB, &datar[0], 2);\r\nvalue = (datar[0] << 8) | datar[1];\r\n*val = ((value * 23600) / 0xFFFF) * 1000;\r\nreturn ret;\r\n}\r\nstatic int ltc294x_get_current(const struct ltc294x_info *info, int *val)\r\n{\r\nint ret;\r\nu8 datar[2];\r\ns32 value;\r\nret = ltc294x_read_regs(info->client,\r\nLTC294X_REG_CURRENT_MSB, &datar[0], 2);\r\nvalue = (datar[0] << 8) | datar[1];\r\nvalue -= 0x7FFF;\r\n*val = 1000 * ((60000 * value) / (info->r_sense * 0x7FFF));\r\nreturn ret;\r\n}\r\nstatic int ltc294x_get_temperature(const struct ltc294x_info *info, int *val)\r\n{\r\nint ret;\r\nu8 datar[2];\r\nu32 value;\r\nret = ltc294x_read_regs(info->client,\r\nLTC294X_REG_TEMPERATURE_MSB, &datar[0], 2);\r\nvalue = (datar[0] << 8) | datar[1];\r\n*val = (((51000 * value) / 0xFFFF) - 27215);\r\nreturn ret;\r\n}\r\nstatic int ltc294x_get_property(struct power_supply *psy,\r\nenum power_supply_property prop,\r\nunion power_supply_propval *val)\r\n{\r\nstruct ltc294x_info *info = power_supply_get_drvdata(psy);\r\nswitch (prop) {\r\ncase POWER_SUPPLY_PROP_CHARGE_NOW:\r\nreturn ltc294x_get_charge_now(info, &val->intval);\r\ncase POWER_SUPPLY_PROP_CHARGE_COUNTER:\r\nreturn ltc294x_get_charge_counter(info, &val->intval);\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nreturn ltc294x_get_voltage(info, &val->intval);\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\nreturn ltc294x_get_current(info, &val->intval);\r\ncase POWER_SUPPLY_PROP_TEMP:\r\nreturn ltc294x_get_temperature(info, &val->intval);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int ltc294x_set_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nconst union power_supply_propval *val)\r\n{\r\nstruct ltc294x_info *info = power_supply_get_drvdata(psy);\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_CHARGE_NOW:\r\nreturn ltc294x_set_charge_now(info, val->intval);\r\ndefault:\r\nreturn -EPERM;\r\n}\r\n}\r\nstatic int ltc294x_property_is_writeable(\r\nstruct power_supply *psy, enum power_supply_property psp)\r\n{\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_CHARGE_NOW:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void ltc294x_update(struct ltc294x_info *info)\r\n{\r\nint charge = ltc294x_read_charge_register(info);\r\nif (charge != info->charge) {\r\ninfo->charge = charge;\r\npower_supply_changed(info->supply);\r\n}\r\n}\r\nstatic void ltc294x_work(struct work_struct *work)\r\n{\r\nstruct ltc294x_info *info;\r\ninfo = container_of(work, struct ltc294x_info, work.work);\r\nltc294x_update(info);\r\nschedule_delayed_work(&info->work, LTC294X_WORK_DELAY * HZ);\r\n}\r\nstatic int ltc294x_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct ltc294x_info *info = i2c_get_clientdata(client);\r\ncancel_delayed_work(&info->work);\r\npower_supply_unregister(info->supply);\r\nkfree(info->supply_desc.name);\r\nmutex_lock(&ltc294x_lock);\r\nidr_remove(&ltc294x_id, info->id);\r\nmutex_unlock(&ltc294x_lock);\r\nreturn 0;\r\n}\r\nstatic int ltc294x_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct power_supply_config psy_cfg = {};\r\nstruct ltc294x_info *info;\r\nint ret;\r\nint num;\r\nu32 prescaler_exp;\r\ns32 r_sense;\r\nstruct device_node *np;\r\nmutex_lock(&ltc294x_lock);\r\nret = idr_alloc(&ltc294x_id, client, 0, 0, GFP_KERNEL);\r\nmutex_unlock(&ltc294x_lock);\r\nif (ret < 0)\r\ngoto fail_id;\r\nnum = ret;\r\ninfo = devm_kzalloc(&client->dev, sizeof(*info), GFP_KERNEL);\r\nif (info == NULL) {\r\nret = -ENOMEM;\r\ngoto fail_info;\r\n}\r\ni2c_set_clientdata(client, info);\r\ninfo->num_regs = id->driver_data;\r\ninfo->supply_desc.name = kasprintf(GFP_KERNEL, "%s-%d", client->name,\r\nnum);\r\nif (!info->supply_desc.name) {\r\nret = -ENOMEM;\r\ngoto fail_name;\r\n}\r\nnp = of_node_get(client->dev.of_node);\r\nret = of_property_read_u32(np, "lltc,resistor-sense", &r_sense);\r\nif (ret < 0) {\r\ndev_err(&client->dev,\r\n"Could not find lltc,resistor-sense in devicetree\n");\r\ngoto fail_name;\r\n}\r\ninfo->r_sense = r_sense;\r\nret = of_property_read_u32(np, "lltc,prescaler-exponent",\r\n&prescaler_exp);\r\nif (ret < 0) {\r\ndev_warn(&client->dev,\r\n"lltc,prescaler-exponent not in devicetree\n");\r\nprescaler_exp = LTC2941_MAX_PRESCALER_EXP;\r\n}\r\nif (info->num_regs == LTC2943_NUM_REGS) {\r\nif (prescaler_exp > LTC2943_MAX_PRESCALER_EXP)\r\nprescaler_exp = LTC2943_MAX_PRESCALER_EXP;\r\ninfo->Qlsb = ((340 * 50000) / r_sense) /\r\n(4096 / (1 << (2*prescaler_exp)));\r\n} else {\r\nif (prescaler_exp > LTC2941_MAX_PRESCALER_EXP)\r\nprescaler_exp = LTC2941_MAX_PRESCALER_EXP;\r\ninfo->Qlsb = ((85 * 50000) / r_sense) /\r\n(128 / (1 << prescaler_exp));\r\n}\r\ninfo->client = client;\r\ninfo->id = num;\r\ninfo->supply_desc.type = POWER_SUPPLY_TYPE_BATTERY;\r\ninfo->supply_desc.properties = ltc294x_properties;\r\nif (info->num_regs >= LTC294X_REG_TEMPERATURE_LSB)\r\ninfo->supply_desc.num_properties =\r\nARRAY_SIZE(ltc294x_properties);\r\nelse if (info->num_regs >= LTC294X_REG_CURRENT_LSB)\r\ninfo->supply_desc.num_properties =\r\nARRAY_SIZE(ltc294x_properties) - 1;\r\nelse if (info->num_regs >= LTC294X_REG_VOLTAGE_LSB)\r\ninfo->supply_desc.num_properties =\r\nARRAY_SIZE(ltc294x_properties) - 2;\r\nelse\r\ninfo->supply_desc.num_properties =\r\nARRAY_SIZE(ltc294x_properties) - 3;\r\ninfo->supply_desc.get_property = ltc294x_get_property;\r\ninfo->supply_desc.set_property = ltc294x_set_property;\r\ninfo->supply_desc.property_is_writeable = ltc294x_property_is_writeable;\r\ninfo->supply_desc.external_power_changed = NULL;\r\npsy_cfg.drv_data = info;\r\nINIT_DELAYED_WORK(&info->work, ltc294x_work);\r\nret = ltc294x_reset(info, prescaler_exp);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Communication with chip failed\n");\r\ngoto fail_comm;\r\n}\r\ninfo->supply = power_supply_register(&client->dev, &info->supply_desc,\r\n&psy_cfg);\r\nif (IS_ERR(info->supply)) {\r\ndev_err(&client->dev, "failed to register ltc2941\n");\r\nret = PTR_ERR(info->supply);\r\ngoto fail_register;\r\n} else {\r\nschedule_delayed_work(&info->work, LTC294X_WORK_DELAY * HZ);\r\n}\r\nreturn 0;\r\nfail_register:\r\nkfree(info->supply_desc.name);\r\nfail_comm:\r\nfail_name:\r\nfail_info:\r\nmutex_lock(&ltc294x_lock);\r\nidr_remove(&ltc294x_id, num);\r\nmutex_unlock(&ltc294x_lock);\r\nfail_id:\r\nreturn ret;\r\n}\r\nstatic int ltc294x_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct ltc294x_info *info = i2c_get_clientdata(client);\r\ncancel_delayed_work(&info->work);\r\nreturn 0;\r\n}\r\nstatic int ltc294x_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct ltc294x_info *info = i2c_get_clientdata(client);\r\nschedule_delayed_work(&info->work, LTC294X_WORK_DELAY * HZ);\r\nreturn 0;\r\n}
