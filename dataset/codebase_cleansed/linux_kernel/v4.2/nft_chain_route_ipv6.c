static unsigned int nf_route_table_hook(const struct nf_hook_ops *ops,\r\nstruct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nunsigned int ret;\r\nstruct nft_pktinfo pkt;\r\nstruct in6_addr saddr, daddr;\r\nu_int8_t hop_limit;\r\nu32 mark, flowlabel;\r\nif (nft_set_pktinfo_ipv6(&pkt, ops, skb, state) < 0)\r\nreturn NF_DROP;\r\nmemcpy(&saddr, &ipv6_hdr(skb)->saddr, sizeof(saddr));\r\nmemcpy(&daddr, &ipv6_hdr(skb)->daddr, sizeof(daddr));\r\nmark = skb->mark;\r\nhop_limit = ipv6_hdr(skb)->hop_limit;\r\nflowlabel = *((u32 *)ipv6_hdr(skb));\r\nret = nft_do_chain(&pkt, ops);\r\nif (ret != NF_DROP && ret != NF_QUEUE &&\r\n(memcmp(&ipv6_hdr(skb)->saddr, &saddr, sizeof(saddr)) ||\r\nmemcmp(&ipv6_hdr(skb)->daddr, &daddr, sizeof(daddr)) ||\r\nskb->mark != mark ||\r\nipv6_hdr(skb)->hop_limit != hop_limit ||\r\nflowlabel != *((u_int32_t *)ipv6_hdr(skb))))\r\nreturn ip6_route_me_harder(skb) == 0 ? ret : NF_DROP;\r\nreturn ret;\r\n}\r\nstatic int __init nft_chain_route_init(void)\r\n{\r\nreturn nft_register_chain_type(&nft_chain_route_ipv6);\r\n}\r\nstatic void __exit nft_chain_route_exit(void)\r\n{\r\nnft_unregister_chain_type(&nft_chain_route_ipv6);\r\n}
