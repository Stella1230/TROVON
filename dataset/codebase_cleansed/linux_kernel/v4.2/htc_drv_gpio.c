static void ath_detect_bt_priority(struct ath9k_htc_priv *priv)\r\n{\r\nstruct ath_btcoex *btcoex = &priv->btcoex;\r\nstruct ath_hw *ah = priv->ah;\r\nif (ath9k_hw_gpio_get(ah, ah->btcoex_hw.btpriority_gpio))\r\nbtcoex->bt_priority_cnt++;\r\nif (time_after(jiffies, btcoex->bt_priority_time +\r\nmsecs_to_jiffies(ATH_BT_PRIORITY_TIME_THRESHOLD))) {\r\nclear_bit(OP_BT_PRIORITY_DETECTED, &priv->op_flags);\r\nclear_bit(OP_BT_SCAN, &priv->op_flags);\r\nif (btcoex->bt_priority_cnt >= ATH_BT_CNT_SCAN_THRESHOLD) {\r\nath_dbg(ath9k_hw_common(ah), BTCOEX,\r\n"BT scan detected\n");\r\nset_bit(OP_BT_PRIORITY_DETECTED, &priv->op_flags);\r\nset_bit(OP_BT_SCAN, &priv->op_flags);\r\n} else if (btcoex->bt_priority_cnt >= ATH_BT_CNT_THRESHOLD) {\r\nath_dbg(ath9k_hw_common(ah), BTCOEX,\r\n"BT priority traffic detected\n");\r\nset_bit(OP_BT_PRIORITY_DETECTED, &priv->op_flags);\r\n}\r\nbtcoex->bt_priority_cnt = 0;\r\nbtcoex->bt_priority_time = jiffies;\r\n}\r\n}\r\nstatic void ath_btcoex_period_work(struct work_struct *work)\r\n{\r\nstruct ath9k_htc_priv *priv = container_of(work, struct ath9k_htc_priv,\r\ncoex_period_work.work);\r\nstruct ath_btcoex *btcoex = &priv->btcoex;\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nu32 timer_period;\r\nint ret;\r\nath_detect_bt_priority(priv);\r\nret = ath9k_htc_update_cap_target(priv,\r\ntest_bit(OP_BT_PRIORITY_DETECTED, &priv->op_flags));\r\nif (ret) {\r\nath_err(common, "Unable to set BTCOEX parameters\n");\r\nreturn;\r\n}\r\nath9k_hw_btcoex_bt_stomp(priv->ah, test_bit(OP_BT_SCAN, &priv->op_flags) ?\r\nATH_BTCOEX_STOMP_ALL : btcoex->bt_stomp_type);\r\nath9k_hw_btcoex_enable(priv->ah);\r\ntimer_period = test_bit(OP_BT_SCAN, &priv->op_flags) ?\r\nbtcoex->btscan_no_stomp : btcoex->btcoex_no_stomp;\r\nieee80211_queue_delayed_work(priv->hw, &priv->duty_cycle_work,\r\nmsecs_to_jiffies(timer_period));\r\nieee80211_queue_delayed_work(priv->hw, &priv->coex_period_work,\r\nmsecs_to_jiffies(btcoex->btcoex_period));\r\n}\r\nstatic void ath_btcoex_duty_cycle_work(struct work_struct *work)\r\n{\r\nstruct ath9k_htc_priv *priv = container_of(work, struct ath9k_htc_priv,\r\nduty_cycle_work.work);\r\nstruct ath_hw *ah = priv->ah;\r\nstruct ath_btcoex *btcoex = &priv->btcoex;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nath_dbg(common, BTCOEX, "time slice work for bt and wlan\n");\r\nif (btcoex->bt_stomp_type == ATH_BTCOEX_STOMP_LOW ||\r\ntest_bit(OP_BT_SCAN, &priv->op_flags))\r\nath9k_hw_btcoex_bt_stomp(ah, ATH_BTCOEX_STOMP_NONE);\r\nelse if (btcoex->bt_stomp_type == ATH_BTCOEX_STOMP_ALL)\r\nath9k_hw_btcoex_bt_stomp(ah, ATH_BTCOEX_STOMP_LOW);\r\nath9k_hw_btcoex_enable(priv->ah);\r\n}\r\nstatic void ath_htc_init_btcoex_work(struct ath9k_htc_priv *priv)\r\n{\r\nstruct ath_btcoex *btcoex = &priv->btcoex;\r\nbtcoex->btcoex_period = ATH_BTCOEX_DEF_BT_PERIOD;\r\nbtcoex->btcoex_no_stomp = (100 - ATH_BTCOEX_DEF_DUTY_CYCLE) *\r\nbtcoex->btcoex_period / 100;\r\nbtcoex->btscan_no_stomp = (100 - ATH_BTCOEX_BTSCAN_DUTY_CYCLE) *\r\nbtcoex->btcoex_period / 100;\r\nINIT_DELAYED_WORK(&priv->coex_period_work, ath_btcoex_period_work);\r\nINIT_DELAYED_WORK(&priv->duty_cycle_work, ath_btcoex_duty_cycle_work);\r\n}\r\nstatic void ath_htc_resume_btcoex_work(struct ath9k_htc_priv *priv)\r\n{\r\nstruct ath_btcoex *btcoex = &priv->btcoex;\r\nstruct ath_hw *ah = priv->ah;\r\nath_dbg(ath9k_hw_common(ah), BTCOEX, "Starting btcoex work\n");\r\nbtcoex->bt_priority_cnt = 0;\r\nbtcoex->bt_priority_time = jiffies;\r\nclear_bit(OP_BT_PRIORITY_DETECTED, &priv->op_flags);\r\nclear_bit(OP_BT_SCAN, &priv->op_flags);\r\nieee80211_queue_delayed_work(priv->hw, &priv->coex_period_work, 0);\r\n}\r\nstatic void ath_htc_cancel_btcoex_work(struct ath9k_htc_priv *priv)\r\n{\r\ncancel_delayed_work_sync(&priv->coex_period_work);\r\ncancel_delayed_work_sync(&priv->duty_cycle_work);\r\n}\r\nvoid ath9k_htc_start_btcoex(struct ath9k_htc_priv *priv)\r\n{\r\nstruct ath_hw *ah = priv->ah;\r\nif (ath9k_hw_get_btcoex_scheme(ah) == ATH_BTCOEX_CFG_3WIRE) {\r\nath9k_hw_btcoex_set_weight(ah, AR_BT_COEX_WGHT,\r\nAR_STOMP_LOW_WLAN_WGHT, 0);\r\nath9k_hw_btcoex_enable(ah);\r\nath_htc_resume_btcoex_work(priv);\r\n}\r\n}\r\nvoid ath9k_htc_stop_btcoex(struct ath9k_htc_priv *priv)\r\n{\r\nstruct ath_hw *ah = priv->ah;\r\nif (ah->btcoex_hw.enabled &&\r\nath9k_hw_get_btcoex_scheme(ah) != ATH_BTCOEX_CFG_NONE) {\r\nif (ah->btcoex_hw.scheme == ATH_BTCOEX_CFG_3WIRE)\r\nath_htc_cancel_btcoex_work(priv);\r\nath9k_hw_btcoex_disable(ah);\r\n}\r\n}\r\nvoid ath9k_htc_init_btcoex(struct ath9k_htc_priv *priv, char *product)\r\n{\r\nstruct ath_hw *ah = priv->ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nint qnum;\r\nif (!common->btcoex_enabled) {\r\nah->btcoex_hw.scheme = ATH_BTCOEX_CFG_NONE;\r\nreturn;\r\n}\r\nif (product && strncmp(product, ATH_HTC_BTCOEX_PRODUCT_ID, 5) == 0) {\r\nah->btcoex_hw.scheme = ATH_BTCOEX_CFG_3WIRE;\r\n}\r\nswitch (ath9k_hw_get_btcoex_scheme(priv->ah)) {\r\ncase ATH_BTCOEX_CFG_NONE:\r\nbreak;\r\ncase ATH_BTCOEX_CFG_3WIRE:\r\npriv->ah->btcoex_hw.btactive_gpio = 7;\r\npriv->ah->btcoex_hw.btpriority_gpio = 6;\r\npriv->ah->btcoex_hw.wlanactive_gpio = 8;\r\npriv->btcoex.bt_stomp_type = ATH_BTCOEX_STOMP_LOW;\r\nath9k_hw_btcoex_init_3wire(priv->ah);\r\nath_htc_init_btcoex_work(priv);\r\nqnum = priv->hwq_map[IEEE80211_AC_BE];\r\nath9k_hw_init_btcoex_hw(priv->ah, qnum);\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nbreak;\r\n}\r\n}\r\nvoid ath9k_led_work(struct work_struct *work)\r\n{\r\nstruct ath9k_htc_priv *priv = container_of(work,\r\nstruct ath9k_htc_priv,\r\nled_work);\r\nath9k_hw_set_gpio(priv->ah, priv->ah->led_pin,\r\n(priv->brightness == LED_OFF));\r\n}\r\nstatic void ath9k_led_brightness(struct led_classdev *led_cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct ath9k_htc_priv *priv = container_of(led_cdev,\r\nstruct ath9k_htc_priv,\r\nled_cdev);\r\npriv->brightness = brightness;\r\nieee80211_queue_work(priv->hw, &priv->led_work);\r\n}\r\nvoid ath9k_deinit_leds(struct ath9k_htc_priv *priv)\r\n{\r\nif (!priv->led_registered)\r\nreturn;\r\nath9k_led_brightness(&priv->led_cdev, LED_OFF);\r\nled_classdev_unregister(&priv->led_cdev);\r\ncancel_work_sync(&priv->led_work);\r\n}\r\nvoid ath9k_configure_leds(struct ath9k_htc_priv *priv)\r\n{\r\nath9k_hw_cfg_output(priv->ah, priv->ah->led_pin,\r\nAR_GPIO_OUTPUT_MUX_AS_OUTPUT);\r\nath9k_hw_set_gpio(priv->ah, priv->ah->led_pin, 1);\r\n}\r\nvoid ath9k_init_leds(struct ath9k_htc_priv *priv)\r\n{\r\nint ret;\r\nif (AR_SREV_9287(priv->ah))\r\npriv->ah->led_pin = ATH_LED_PIN_9287;\r\nelse if (AR_SREV_9271(priv->ah))\r\npriv->ah->led_pin = ATH_LED_PIN_9271;\r\nelse if (AR_DEVID_7010(priv->ah))\r\npriv->ah->led_pin = ATH_LED_PIN_7010;\r\nelse\r\npriv->ah->led_pin = ATH_LED_PIN_DEF;\r\nif (!ath9k_htc_led_blink)\r\npriv->led_cdev.default_trigger =\r\nieee80211_get_radio_led_name(priv->hw);\r\nath9k_configure_leds(priv);\r\nsnprintf(priv->led_name, sizeof(priv->led_name),\r\n"ath9k_htc-%s", wiphy_name(priv->hw->wiphy));\r\npriv->led_cdev.name = priv->led_name;\r\npriv->led_cdev.brightness_set = ath9k_led_brightness;\r\nret = led_classdev_register(wiphy_dev(priv->hw->wiphy), &priv->led_cdev);\r\nif (ret < 0)\r\nreturn;\r\nINIT_WORK(&priv->led_work, ath9k_led_work);\r\npriv->led_registered = true;\r\nreturn;\r\n}\r\nstatic bool ath_is_rfkill_set(struct ath9k_htc_priv *priv)\r\n{\r\nbool is_blocked;\r\nath9k_htc_ps_wakeup(priv);\r\nis_blocked = ath9k_hw_gpio_get(priv->ah, priv->ah->rfkill_gpio) ==\r\npriv->ah->rfkill_polarity;\r\nath9k_htc_ps_restore(priv);\r\nreturn is_blocked;\r\n}\r\nvoid ath9k_htc_rfkill_poll_state(struct ieee80211_hw *hw)\r\n{\r\nstruct ath9k_htc_priv *priv = hw->priv;\r\nbool blocked = !!ath_is_rfkill_set(priv);\r\nwiphy_rfkill_set_hw_state(hw->wiphy, blocked);\r\n}\r\nvoid ath9k_start_rfkill_poll(struct ath9k_htc_priv *priv)\r\n{\r\nif (priv->ah->caps.hw_caps & ATH9K_HW_CAP_RFSILENT)\r\nwiphy_rfkill_start_polling(priv->hw->wiphy);\r\n}
