static unsigned long pll_recalc(struct clk *clk)\r\n{\r\nunsigned long mult = 1;\r\nif (__raw_readl(PLLECR) & (1 << clk->enable_bit)) {\r\nmult = (((__raw_readl(clk->enable_reg) >> 24) & 0x3f) + 1);\r\nswitch (clk->enable_bit) {\r\ncase 1:\r\ncase 2:\r\nif (__raw_readl(clk->enable_reg) & (1 << 20))\r\nmult *= 2;\r\n}\r\n}\r\nreturn clk->parent->rate * mult;\r\n}\r\nstatic int frqcr_kick(void)\r\n{\r\nint i;\r\n__raw_writel(__raw_readl(FRQCRB) | (1 << 31), FRQCRB);\r\nfor (i = 1000; i; i--)\r\nif (__raw_readl(FRQCRB) & (1 << 31))\r\ncpu_relax();\r\nelse\r\nreturn i;\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void div4_kick(struct clk *clk)\r\n{\r\nfrqcr_kick();\r\n}\r\nstatic unsigned long twd_recalc(struct clk *clk)\r\n{\r\nreturn clk_get_rate(clk->parent) / 4;\r\n}\r\nstatic int zclk_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nint ret;\r\nif (!clk->parent || !__clk_get(clk->parent))\r\nreturn -ENODEV;\r\nif (readl(FRQCRB) & (1 << 31))\r\nreturn -EBUSY;\r\nif (rate == clk_get_rate(clk->parent)) {\r\n__raw_writel(__raw_readl(FRQCRB) & ~(1 << 28), FRQCRB);\r\nret = div4_clk_ops->set_rate(clk, rate / 2);\r\nif (!ret)\r\nret = frqcr_kick();\r\nif (ret > 0)\r\nret = 0;\r\n} else {\r\n__raw_writel(__raw_readl(FRQCRB) | (1 << 28), FRQCRB);\r\nret = frqcr_kick();\r\nif (ret >= 0)\r\nret = div4_clk_ops->set_rate(clk, rate);\r\nif (ret < 0)\r\ngoto esetrate;\r\n}\r\nesetrate:\r\n__clk_put(clk->parent);\r\nreturn ret;\r\n}\r\nstatic long zclk_round_rate(struct clk *clk, unsigned long rate)\r\n{\r\nunsigned long div_freq = div4_clk_ops->round_rate(clk, rate),\r\nparent_freq = clk_get_rate(clk->parent);\r\nif (rate > div_freq && abs(parent_freq - rate) < rate - div_freq)\r\nreturn parent_freq;\r\nreturn div_freq;\r\n}\r\nstatic unsigned long zclk_recalc(struct clk *clk)\r\n{\r\nunsigned long div_freq = div4_clk_ops->recalc(clk);\r\nif (__raw_readl(FRQCRB) & (1 << 28))\r\nreturn div_freq;\r\nreturn clk_get_rate(clk->parent);\r\n}\r\nstatic int kicker_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nif (__raw_readl(FRQCRB) & (1 << 31))\r\nreturn -EBUSY;\r\nreturn div4_clk_ops->set_rate(clk, rate);\r\n}\r\nstatic void div4_clk_extend(void)\r\n{\r\nint i;\r\ndiv4_clk_ops = div4_clks[0].ops;\r\nkicker_ops = *div4_clk_ops;\r\nzclk_ops = *div4_clk_ops;\r\nkicker_ops.set_rate = kicker_set_rate;\r\nzclk_ops.set_rate = zclk_set_rate;\r\nzclk_ops.round_rate = zclk_round_rate;\r\nzclk_ops.recalc = zclk_recalc;\r\nfor (i = 0; i < DIV4_NR; i++)\r\ndiv4_clks[i].ops = i == DIV4_Z ? &zclk_ops : &kicker_ops;\r\n}\r\nstatic unsigned long dsiphy_recalc(struct clk *clk)\r\n{\r\nu32 value;\r\nvalue = __raw_readl(clk->mapping->base);\r\nif (!(value & 0x000B8000))\r\nreturn clk->parent->rate;\r\nvalue &= 0x3f;\r\nvalue += 1;\r\nif ((value < 12) ||\r\n(value > 33)) {\r\npr_err("DSIPHY has wrong value (%d)", value);\r\nreturn 0;\r\n}\r\nreturn clk->parent->rate / value;\r\n}\r\nstatic long dsiphy_round_rate(struct clk *clk, unsigned long rate)\r\n{\r\nreturn clk_rate_mult_range_round(clk, 12, 33, rate);\r\n}\r\nstatic void dsiphy_disable(struct clk *clk)\r\n{\r\nu32 value;\r\nvalue = __raw_readl(clk->mapping->base);\r\nvalue &= ~0x000B8000;\r\n__raw_writel(value , clk->mapping->base);\r\n}\r\nstatic int dsiphy_enable(struct clk *clk)\r\n{\r\nu32 value;\r\nint multi;\r\nvalue = __raw_readl(clk->mapping->base);\r\nmulti = (value & 0x3f) + 1;\r\nif ((multi < 12) || (multi > 33))\r\nreturn -EIO;\r\n__raw_writel(value | 0x000B8000, clk->mapping->base);\r\nreturn 0;\r\n}\r\nstatic int dsiphy_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nu32 value;\r\nint idx;\r\nidx = rate / clk->parent->rate;\r\nif ((idx < 12) || (idx > 33))\r\nreturn -EINVAL;\r\nidx += -1;\r\nvalue = __raw_readl(clk->mapping->base);\r\nvalue = (value & ~0x3f) + idx;\r\n__raw_writel(value, clk->mapping->base);\r\nreturn 0;\r\n}\r\nvoid __init sh73a0_clock_init(void)\r\n{\r\nint k, ret = 0;\r\n__raw_writel(0x108, SD0CKCR);\r\n__raw_writel(0x108, SD1CKCR);\r\n__raw_writel(0x108, SD2CKCR);\r\nswitch ((__raw_readl(CKSCR) >> 28) & 0x03) {\r\ncase 0:\r\nmain_clk.parent = &sh73a0_extal1_clk;\r\nbreak;\r\ncase 1:\r\nmain_clk.parent = &extal1_div2_clk;\r\nbreak;\r\ncase 2:\r\nmain_clk.parent = &sh73a0_extal2_clk;\r\nbreak;\r\ncase 3:\r\nmain_clk.parent = &extal2_div2_clk;\r\nbreak;\r\n}\r\nfor (k = 0; !ret && (k < ARRAY_SIZE(main_clks)); k++)\r\nret = clk_register(main_clks[k]);\r\nif (!ret) {\r\nret = sh_clk_div4_register(div4_clks, DIV4_NR, &div4_table);\r\nif (!ret)\r\ndiv4_clk_extend();\r\n}\r\nif (!ret)\r\nret = sh_clk_div6_reparent_register(div6_clks, DIV6_NR);\r\nif (!ret)\r\nret = sh_clk_mstp_register(mstp_clks, MSTP_NR);\r\nfor (k = 0; !ret && (k < ARRAY_SIZE(late_main_clks)); k++)\r\nret = clk_register(late_main_clks[k]);\r\nclkdev_add_table(lookups, ARRAY_SIZE(lookups));\r\nif (!ret)\r\nshmobile_clk_init();\r\nelse\r\npanic("failed to setup sh73a0 clocks\n");\r\n}
