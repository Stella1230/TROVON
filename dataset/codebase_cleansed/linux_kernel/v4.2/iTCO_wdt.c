static inline unsigned int seconds_to_ticks(int secs)\r\n{\r\nreturn iTCO_wdt_private.iTCO_version == 3 ? secs : (secs * 10) / 6;\r\n}\r\nstatic inline unsigned int ticks_to_seconds(int ticks)\r\n{\r\nreturn iTCO_wdt_private.iTCO_version == 3 ? ticks : (ticks * 6) / 10;\r\n}\r\nstatic void iTCO_wdt_set_NO_REBOOT_bit(void)\r\n{\r\nu32 val32;\r\nif (iTCO_wdt_private.iTCO_version == 3) {\r\nval32 = readl(iTCO_wdt_private.gcs_pmc);\r\nval32 |= 0x00000010;\r\nwritel(val32, iTCO_wdt_private.gcs_pmc);\r\n} else if (iTCO_wdt_private.iTCO_version == 2) {\r\nval32 = readl(iTCO_wdt_private.gcs_pmc);\r\nval32 |= 0x00000020;\r\nwritel(val32, iTCO_wdt_private.gcs_pmc);\r\n} else if (iTCO_wdt_private.iTCO_version == 1) {\r\npci_read_config_dword(iTCO_wdt_private.pdev, 0xd4, &val32);\r\nval32 |= 0x00000002;\r\npci_write_config_dword(iTCO_wdt_private.pdev, 0xd4, val32);\r\n}\r\n}\r\nstatic int iTCO_wdt_unset_NO_REBOOT_bit(void)\r\n{\r\nint ret = 0;\r\nu32 val32;\r\nif (iTCO_wdt_private.iTCO_version == 3) {\r\nval32 = readl(iTCO_wdt_private.gcs_pmc);\r\nval32 &= 0xffffffef;\r\nwritel(val32, iTCO_wdt_private.gcs_pmc);\r\nval32 = readl(iTCO_wdt_private.gcs_pmc);\r\nif (val32 & 0x00000010)\r\nret = -EIO;\r\n} else if (iTCO_wdt_private.iTCO_version == 2) {\r\nval32 = readl(iTCO_wdt_private.gcs_pmc);\r\nval32 &= 0xffffffdf;\r\nwritel(val32, iTCO_wdt_private.gcs_pmc);\r\nval32 = readl(iTCO_wdt_private.gcs_pmc);\r\nif (val32 & 0x00000020)\r\nret = -EIO;\r\n} else if (iTCO_wdt_private.iTCO_version == 1) {\r\npci_read_config_dword(iTCO_wdt_private.pdev, 0xd4, &val32);\r\nval32 &= 0xfffffffd;\r\npci_write_config_dword(iTCO_wdt_private.pdev, 0xd4, val32);\r\npci_read_config_dword(iTCO_wdt_private.pdev, 0xd4, &val32);\r\nif (val32 & 0x00000002)\r\nret = -EIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int iTCO_wdt_start(struct watchdog_device *wd_dev)\r\n{\r\nunsigned int val;\r\nspin_lock(&iTCO_wdt_private.io_lock);\r\niTCO_vendor_pre_start(iTCO_wdt_private.smi_res, wd_dev->timeout);\r\nif (iTCO_wdt_unset_NO_REBOOT_bit()) {\r\nspin_unlock(&iTCO_wdt_private.io_lock);\r\npr_err("failed to reset NO_REBOOT flag, reboot disabled by hardware/BIOS\n");\r\nreturn -EIO;\r\n}\r\nif (iTCO_wdt_private.iTCO_version >= 2)\r\noutw(0x01, TCO_RLD);\r\nelse if (iTCO_wdt_private.iTCO_version == 1)\r\noutb(0x01, TCO_RLD);\r\nval = inw(TCO1_CNT);\r\nval &= 0xf7ff;\r\noutw(val, TCO1_CNT);\r\nval = inw(TCO1_CNT);\r\nspin_unlock(&iTCO_wdt_private.io_lock);\r\nif (val & 0x0800)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int iTCO_wdt_stop(struct watchdog_device *wd_dev)\r\n{\r\nunsigned int val;\r\nspin_lock(&iTCO_wdt_private.io_lock);\r\niTCO_vendor_pre_stop(iTCO_wdt_private.smi_res);\r\nval = inw(TCO1_CNT);\r\nval |= 0x0800;\r\noutw(val, TCO1_CNT);\r\nval = inw(TCO1_CNT);\r\niTCO_wdt_set_NO_REBOOT_bit();\r\nspin_unlock(&iTCO_wdt_private.io_lock);\r\nif ((val & 0x0800) == 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int iTCO_wdt_ping(struct watchdog_device *wd_dev)\r\n{\r\nspin_lock(&iTCO_wdt_private.io_lock);\r\niTCO_vendor_pre_keepalive(iTCO_wdt_private.smi_res, wd_dev->timeout);\r\nif (iTCO_wdt_private.iTCO_version >= 2) {\r\noutw(0x01, TCO_RLD);\r\n} else if (iTCO_wdt_private.iTCO_version == 1) {\r\noutw(0x0008, TCO1_STS);\r\noutb(0x01, TCO_RLD);\r\n}\r\nspin_unlock(&iTCO_wdt_private.io_lock);\r\nreturn 0;\r\n}\r\nstatic int iTCO_wdt_set_timeout(struct watchdog_device *wd_dev, unsigned int t)\r\n{\r\nunsigned int val16;\r\nunsigned char val8;\r\nunsigned int tmrval;\r\ntmrval = seconds_to_ticks(t);\r\nif (iTCO_wdt_private.iTCO_version == 1)\r\ntmrval /= 2;\r\nif (tmrval < 0x04)\r\nreturn -EINVAL;\r\nif (((iTCO_wdt_private.iTCO_version >= 2) && (tmrval > 0x3ff)) ||\r\n((iTCO_wdt_private.iTCO_version == 1) && (tmrval > 0x03f)))\r\nreturn -EINVAL;\r\niTCO_vendor_pre_set_heartbeat(tmrval);\r\nif (iTCO_wdt_private.iTCO_version >= 2) {\r\nspin_lock(&iTCO_wdt_private.io_lock);\r\nval16 = inw(TCOv2_TMR);\r\nval16 &= 0xfc00;\r\nval16 |= tmrval;\r\noutw(val16, TCOv2_TMR);\r\nval16 = inw(TCOv2_TMR);\r\nspin_unlock(&iTCO_wdt_private.io_lock);\r\nif ((val16 & 0x3ff) != tmrval)\r\nreturn -EINVAL;\r\n} else if (iTCO_wdt_private.iTCO_version == 1) {\r\nspin_lock(&iTCO_wdt_private.io_lock);\r\nval8 = inb(TCOv1_TMR);\r\nval8 &= 0xc0;\r\nval8 |= (tmrval & 0xff);\r\noutb(val8, TCOv1_TMR);\r\nval8 = inb(TCOv1_TMR);\r\nspin_unlock(&iTCO_wdt_private.io_lock);\r\nif ((val8 & 0x3f) != tmrval)\r\nreturn -EINVAL;\r\n}\r\nwd_dev->timeout = t;\r\nreturn 0;\r\n}\r\nstatic unsigned int iTCO_wdt_get_timeleft(struct watchdog_device *wd_dev)\r\n{\r\nunsigned int val16;\r\nunsigned char val8;\r\nunsigned int time_left = 0;\r\nif (iTCO_wdt_private.iTCO_version >= 2) {\r\nspin_lock(&iTCO_wdt_private.io_lock);\r\nval16 = inw(TCO_RLD);\r\nval16 &= 0x3ff;\r\nspin_unlock(&iTCO_wdt_private.io_lock);\r\ntime_left = ticks_to_seconds(val16);\r\n} else if (iTCO_wdt_private.iTCO_version == 1) {\r\nspin_lock(&iTCO_wdt_private.io_lock);\r\nval8 = inb(TCO_RLD);\r\nval8 &= 0x3f;\r\nif (!(inw(TCO1_STS) & 0x0008))\r\nval8 += (inb(TCOv1_TMR) & 0x3f);\r\nspin_unlock(&iTCO_wdt_private.io_lock);\r\ntime_left = ticks_to_seconds(val8);\r\n}\r\nreturn time_left;\r\n}\r\nstatic void iTCO_wdt_cleanup(void)\r\n{\r\nif (!nowayout)\r\niTCO_wdt_stop(&iTCO_wdt_watchdog_dev);\r\nwatchdog_unregister_device(&iTCO_wdt_watchdog_dev);\r\nrelease_region(iTCO_wdt_private.tco_res->start,\r\nresource_size(iTCO_wdt_private.tco_res));\r\nrelease_region(iTCO_wdt_private.smi_res->start,\r\nresource_size(iTCO_wdt_private.smi_res));\r\nif (iTCO_wdt_private.iTCO_version >= 2) {\r\niounmap(iTCO_wdt_private.gcs_pmc);\r\nrelease_mem_region(iTCO_wdt_private.gcs_pmc_res->start,\r\nresource_size(iTCO_wdt_private.gcs_pmc_res));\r\n}\r\niTCO_wdt_private.tco_res = NULL;\r\niTCO_wdt_private.smi_res = NULL;\r\niTCO_wdt_private.gcs_pmc_res = NULL;\r\niTCO_wdt_private.gcs_pmc = NULL;\r\n}\r\nstatic int iTCO_wdt_probe(struct platform_device *dev)\r\n{\r\nint ret = -ENODEV;\r\nunsigned long val32;\r\nstruct lpc_ich_info *ich_info = dev_get_platdata(&dev->dev);\r\nif (!ich_info)\r\ngoto out;\r\nspin_lock_init(&iTCO_wdt_private.io_lock);\r\niTCO_wdt_private.tco_res =\r\nplatform_get_resource(dev, IORESOURCE_IO, ICH_RES_IO_TCO);\r\nif (!iTCO_wdt_private.tco_res)\r\ngoto out;\r\niTCO_wdt_private.smi_res =\r\nplatform_get_resource(dev, IORESOURCE_IO, ICH_RES_IO_SMI);\r\nif (!iTCO_wdt_private.smi_res)\r\ngoto out;\r\niTCO_wdt_private.iTCO_version = ich_info->iTCO_version;\r\niTCO_wdt_private.dev = dev;\r\niTCO_wdt_private.pdev = to_pci_dev(dev->dev.parent);\r\nif (iTCO_wdt_private.iTCO_version >= 2) {\r\niTCO_wdt_private.gcs_pmc_res = platform_get_resource(dev,\r\nIORESOURCE_MEM,\r\nICH_RES_MEM_GCS_PMC);\r\nif (!iTCO_wdt_private.gcs_pmc_res)\r\ngoto out;\r\nif (!request_mem_region(iTCO_wdt_private.gcs_pmc_res->start,\r\nresource_size(iTCO_wdt_private.gcs_pmc_res), dev->name)) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\niTCO_wdt_private.gcs_pmc = ioremap(iTCO_wdt_private.gcs_pmc_res->start,\r\nresource_size(iTCO_wdt_private.gcs_pmc_res));\r\nif (!iTCO_wdt_private.gcs_pmc) {\r\nret = -EIO;\r\ngoto unreg_gcs_pmc;\r\n}\r\n}\r\nif (iTCO_wdt_unset_NO_REBOOT_bit() && iTCO_vendor_check_noreboot_on()) {\r\npr_info("unable to reset NO_REBOOT flag, device disabled by hardware/BIOS\n");\r\nret = -ENODEV;\r\ngoto unmap_gcs_pmc;\r\n}\r\niTCO_wdt_set_NO_REBOOT_bit();\r\nif (!request_region(iTCO_wdt_private.smi_res->start,\r\nresource_size(iTCO_wdt_private.smi_res), dev->name)) {\r\npr_err("I/O address 0x%04llx already in use, device disabled\n",\r\n(u64)SMI_EN);\r\nret = -EBUSY;\r\ngoto unmap_gcs_pmc;\r\n}\r\nif (turn_SMI_watchdog_clear_off >= iTCO_wdt_private.iTCO_version) {\r\nval32 = inl(SMI_EN);\r\nval32 &= 0xffffdfff;\r\noutl(val32, SMI_EN);\r\n}\r\nif (!request_region(iTCO_wdt_private.tco_res->start,\r\nresource_size(iTCO_wdt_private.tco_res), dev->name)) {\r\npr_err("I/O address 0x%04llx already in use, device disabled\n",\r\n(u64)TCOBASE);\r\nret = -EBUSY;\r\ngoto unreg_smi;\r\n}\r\npr_info("Found a %s TCO device (Version=%d, TCOBASE=0x%04llx)\n",\r\nich_info->name, ich_info->iTCO_version, (u64)TCOBASE);\r\nif (iTCO_wdt_private.iTCO_version == 3) {\r\noutl(0x20008, TCO1_STS);\r\n} else {\r\noutw(0x0008, TCO1_STS);\r\noutw(0x0002, TCO2_STS);\r\noutw(0x0004, TCO2_STS);\r\n}\r\niTCO_wdt_watchdog_dev.bootstatus = 0;\r\niTCO_wdt_watchdog_dev.timeout = WATCHDOG_TIMEOUT;\r\nwatchdog_set_nowayout(&iTCO_wdt_watchdog_dev, nowayout);\r\niTCO_wdt_watchdog_dev.parent = &dev->dev;\r\niTCO_wdt_stop(&iTCO_wdt_watchdog_dev);\r\nif (iTCO_wdt_set_timeout(&iTCO_wdt_watchdog_dev, heartbeat)) {\r\niTCO_wdt_set_timeout(&iTCO_wdt_watchdog_dev, WATCHDOG_TIMEOUT);\r\npr_info("timeout value out of range, using %d\n",\r\nWATCHDOG_TIMEOUT);\r\n}\r\nret = watchdog_register_device(&iTCO_wdt_watchdog_dev);\r\nif (ret != 0) {\r\npr_err("cannot register watchdog device (err=%d)\n", ret);\r\ngoto unreg_tco;\r\n}\r\npr_info("initialized. heartbeat=%d sec (nowayout=%d)\n",\r\nheartbeat, nowayout);\r\nreturn 0;\r\nunreg_tco:\r\nrelease_region(iTCO_wdt_private.tco_res->start,\r\nresource_size(iTCO_wdt_private.tco_res));\r\nunreg_smi:\r\nrelease_region(iTCO_wdt_private.smi_res->start,\r\nresource_size(iTCO_wdt_private.smi_res));\r\nunmap_gcs_pmc:\r\nif (iTCO_wdt_private.iTCO_version >= 2)\r\niounmap(iTCO_wdt_private.gcs_pmc);\r\nunreg_gcs_pmc:\r\nif (iTCO_wdt_private.iTCO_version >= 2)\r\nrelease_mem_region(iTCO_wdt_private.gcs_pmc_res->start,\r\nresource_size(iTCO_wdt_private.gcs_pmc_res));\r\nout:\r\niTCO_wdt_private.tco_res = NULL;\r\niTCO_wdt_private.smi_res = NULL;\r\niTCO_wdt_private.gcs_pmc_res = NULL;\r\niTCO_wdt_private.gcs_pmc = NULL;\r\nreturn ret;\r\n}\r\nstatic int iTCO_wdt_remove(struct platform_device *dev)\r\n{\r\nif (iTCO_wdt_private.tco_res || iTCO_wdt_private.smi_res)\r\niTCO_wdt_cleanup();\r\nreturn 0;\r\n}\r\nstatic void iTCO_wdt_shutdown(struct platform_device *dev)\r\n{\r\niTCO_wdt_stop(NULL);\r\n}\r\nstatic inline bool need_suspend(void)\r\n{\r\nreturn acpi_target_system_state() == ACPI_STATE_S0;\r\n}\r\nstatic inline bool need_suspend(void) { return true; }\r\nstatic int iTCO_wdt_suspend_noirq(struct device *dev)\r\n{\r\nint ret = 0;\r\niTCO_wdt_private.suspended = false;\r\nif (watchdog_active(&iTCO_wdt_watchdog_dev) && need_suspend()) {\r\nret = iTCO_wdt_stop(&iTCO_wdt_watchdog_dev);\r\nif (!ret)\r\niTCO_wdt_private.suspended = true;\r\n}\r\nreturn ret;\r\n}\r\nstatic int iTCO_wdt_resume_noirq(struct device *dev)\r\n{\r\nif (iTCO_wdt_private.suspended)\r\niTCO_wdt_start(&iTCO_wdt_watchdog_dev);\r\nreturn 0;\r\n}\r\nstatic int __init iTCO_wdt_init_module(void)\r\n{\r\nint err;\r\npr_info("Intel TCO WatchDog Timer Driver v%s\n", DRV_VERSION);\r\nerr = platform_driver_register(&iTCO_wdt_driver);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void __exit iTCO_wdt_cleanup_module(void)\r\n{\r\nplatform_driver_unregister(&iTCO_wdt_driver);\r\npr_info("Watchdog Module Unloaded\n");\r\n}
