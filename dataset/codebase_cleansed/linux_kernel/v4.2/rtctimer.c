static int\r\nrtctimer_open(struct snd_timer *t)\r\n{\r\nint err;\r\nerr = rtc_register(&rtc_task);\r\nif (err < 0)\r\nreturn err;\r\nt->private_data = &rtc_task;\r\nreturn 0;\r\n}\r\nstatic int\r\nrtctimer_close(struct snd_timer *t)\r\n{\r\nrtc_task_t *rtc = t->private_data;\r\nif (rtc) {\r\nrtc_unregister(rtc);\r\ntasklet_kill(&rtc_tasklet);\r\nt->private_data = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nrtctimer_start(struct snd_timer *timer)\r\n{\r\nrtc_task_t *rtc = timer->private_data;\r\nif (snd_BUG_ON(!rtc))\r\nreturn -EINVAL;\r\nrtc_control(rtc, RTC_IRQP_SET, rtctimer_freq);\r\nrtc_control(rtc, RTC_PIE_ON, 0);\r\nreturn 0;\r\n}\r\nstatic int\r\nrtctimer_stop(struct snd_timer *timer)\r\n{\r\nrtc_task_t *rtc = timer->private_data;\r\nif (snd_BUG_ON(!rtc))\r\nreturn -EINVAL;\r\nrtc_control(rtc, RTC_PIE_OFF, 0);\r\nreturn 0;\r\n}\r\nstatic void rtctimer_tasklet(unsigned long data)\r\n{\r\nsnd_timer_interrupt((struct snd_timer *)data, 1);\r\n}\r\nstatic void rtctimer_interrupt(void *private_data)\r\n{\r\ntasklet_schedule(private_data);\r\n}\r\nstatic int __init rtctimer_init(void)\r\n{\r\nint err;\r\nstruct snd_timer *timer;\r\nif (rtctimer_freq < 2 || rtctimer_freq > 8192 ||\r\n!is_power_of_2(rtctimer_freq)) {\r\npr_err("ALSA: rtctimer: invalid frequency %d\n", rtctimer_freq);\r\nreturn -EINVAL;\r\n}\r\nerr = snd_timer_global_new("rtc", SNDRV_TIMER_GLOBAL_RTC, &timer);\r\nif (err < 0)\r\nreturn err;\r\ntimer->module = THIS_MODULE;\r\nstrcpy(timer->name, "RTC timer");\r\ntimer->hw = rtc_hw;\r\ntimer->hw.resolution = NANO_SEC / rtctimer_freq;\r\ntasklet_init(&rtc_tasklet, rtctimer_tasklet, (unsigned long)timer);\r\nrtc_task.func = rtctimer_interrupt;\r\nrtc_task.private_data = &rtc_tasklet;\r\nerr = snd_timer_global_register(timer);\r\nif (err < 0) {\r\nsnd_timer_global_free(timer);\r\nreturn err;\r\n}\r\nrtctimer = timer;\r\nreturn 0;\r\n}\r\nstatic void __exit rtctimer_exit(void)\r\n{\r\nif (rtctimer) {\r\nsnd_timer_global_free(rtctimer);\r\nrtctimer = NULL;\r\n}\r\n}
