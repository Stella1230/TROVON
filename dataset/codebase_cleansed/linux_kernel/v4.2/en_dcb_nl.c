static int mlx4_en_dcbnl_ieee_getets(struct net_device *dev,\r\nstruct ieee_ets *ets)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nstruct ieee_ets *my_ets = &priv->ets;\r\nif (!my_ets)\r\nreturn -EINVAL;\r\nets->ets_cap = IEEE_8021QAZ_MAX_TCS;\r\nets->cbs = my_ets->cbs;\r\nmemcpy(ets->tc_tx_bw, my_ets->tc_tx_bw, sizeof(ets->tc_tx_bw));\r\nmemcpy(ets->tc_tsa, my_ets->tc_tsa, sizeof(ets->tc_tsa));\r\nmemcpy(ets->prio_tc, my_ets->prio_tc, sizeof(ets->prio_tc));\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_ets_validate(struct mlx4_en_priv *priv, struct ieee_ets *ets)\r\n{\r\nint i;\r\nint total_ets_bw = 0;\r\nint has_ets_tc = 0;\r\nfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\r\nif (ets->prio_tc[i] >= MLX4_EN_NUM_UP) {\r\nen_err(priv, "Bad priority in UP <=> TC mapping. TC: %d, UP: %d\n",\r\ni, ets->prio_tc[i]);\r\nreturn -EINVAL;\r\n}\r\nswitch (ets->tc_tsa[i]) {\r\ncase IEEE_8021QAZ_TSA_STRICT:\r\nbreak;\r\ncase IEEE_8021QAZ_TSA_ETS:\r\nhas_ets_tc = 1;\r\ntotal_ets_bw += ets->tc_tx_bw[i];\r\nbreak;\r\ndefault:\r\nen_err(priv, "TC[%d]: Not supported TSA: %d\n",\r\ni, ets->tc_tsa[i]);\r\nreturn -ENOTSUPP;\r\n}\r\n}\r\nif (has_ets_tc && total_ets_bw != MLX4_EN_BW_MAX) {\r\nen_err(priv, "Bad ETS BW sum: %d. Should be exactly 100%%\n",\r\ntotal_ets_bw);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_config_port_scheduler(struct mlx4_en_priv *priv,\r\nstruct ieee_ets *ets, u16 *ratelimit)\r\n{\r\nstruct mlx4_en_dev *mdev = priv->mdev;\r\nint num_strict = 0;\r\nint i;\r\n__u8 tc_tx_bw[IEEE_8021QAZ_MAX_TCS] = { 0 };\r\n__u8 pg[IEEE_8021QAZ_MAX_TCS] = { 0 };\r\nets = ets ?: &priv->ets;\r\nratelimit = ratelimit ?: priv->maxrate;\r\nfor (i = IEEE_8021QAZ_MAX_TCS - 1; i >= 0; i--) {\r\nswitch (ets->tc_tsa[i]) {\r\ncase IEEE_8021QAZ_TSA_STRICT:\r\npg[i] = num_strict++;\r\ntc_tx_bw[i] = MLX4_EN_BW_MAX;\r\nbreak;\r\ncase IEEE_8021QAZ_TSA_ETS:\r\npg[i] = MLX4_EN_TC_ETS;\r\ntc_tx_bw[i] = ets->tc_tx_bw[i] ?: MLX4_EN_BW_MIN;\r\nbreak;\r\n}\r\n}\r\nreturn mlx4_SET_PORT_SCHEDULER(mdev->dev, priv->port, tc_tx_bw, pg,\r\nratelimit);\r\n}\r\nstatic int\r\nmlx4_en_dcbnl_ieee_setets(struct net_device *dev, struct ieee_ets *ets)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nstruct mlx4_en_dev *mdev = priv->mdev;\r\nint err;\r\nerr = mlx4_en_ets_validate(priv, ets);\r\nif (err)\r\nreturn err;\r\nerr = mlx4_SET_PORT_PRIO2TC(mdev->dev, priv->port, ets->prio_tc);\r\nif (err)\r\nreturn err;\r\nerr = mlx4_en_config_port_scheduler(priv, ets, NULL);\r\nif (err)\r\nreturn err;\r\nmemcpy(&priv->ets, ets, sizeof(priv->ets));\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_dcbnl_ieee_getpfc(struct net_device *dev,\r\nstruct ieee_pfc *pfc)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\npfc->pfc_cap = IEEE_8021QAZ_MAX_TCS;\r\npfc->pfc_en = priv->prof->tx_ppp;\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_dcbnl_ieee_setpfc(struct net_device *dev,\r\nstruct ieee_pfc *pfc)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nstruct mlx4_en_port_profile *prof = priv->prof;\r\nstruct mlx4_en_dev *mdev = priv->mdev;\r\nint err;\r\nen_dbg(DRV, priv, "cap: 0x%x en: 0x%x mbc: 0x%x delay: %d\n",\r\npfc->pfc_cap,\r\npfc->pfc_en,\r\npfc->mbc,\r\npfc->delay);\r\nprof->rx_pause = !pfc->pfc_en;\r\nprof->tx_pause = !pfc->pfc_en;\r\nprof->rx_ppp = pfc->pfc_en;\r\nprof->tx_ppp = pfc->pfc_en;\r\nerr = mlx4_SET_PORT_general(mdev->dev, priv->port,\r\npriv->rx_skb_size + ETH_FCS_LEN,\r\nprof->tx_pause,\r\nprof->tx_ppp,\r\nprof->rx_pause,\r\nprof->rx_ppp);\r\nif (err)\r\nen_err(priv, "Failed setting pause params\n");\r\nelse\r\nmlx4_en_update_pfc_stats_bitmap(mdev->dev, &priv->stats_bitmap,\r\nprof->rx_ppp, prof->rx_pause,\r\nprof->tx_ppp, prof->tx_pause);\r\nreturn err;\r\n}\r\nstatic u8 mlx4_en_dcbnl_getdcbx(struct net_device *dev)\r\n{\r\nreturn DCB_CAP_DCBX_HOST | DCB_CAP_DCBX_VER_IEEE;\r\n}\r\nstatic u8 mlx4_en_dcbnl_setdcbx(struct net_device *dev, u8 mode)\r\n{\r\nif ((mode & DCB_CAP_DCBX_LLD_MANAGED) ||\r\n(mode & DCB_CAP_DCBX_VER_CEE) ||\r\n!(mode & DCB_CAP_DCBX_VER_IEEE) ||\r\n!(mode & DCB_CAP_DCBX_HOST))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_dcbnl_ieee_getmaxrate(struct net_device *dev,\r\nstruct ieee_maxrate *maxrate)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nint i;\r\nfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++)\r\nmaxrate->tc_maxrate[i] =\r\npriv->maxrate[i] * MLX4_RATELIMIT_UNITS_IN_KB;\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_dcbnl_ieee_setmaxrate(struct net_device *dev,\r\nstruct ieee_maxrate *maxrate)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nu16 tmp[IEEE_8021QAZ_MAX_TCS];\r\nint i, err;\r\nfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\r\ntmp[i] = div_u64(maxrate->tc_maxrate[i] +\r\nMLX4_RATELIMIT_UNITS_IN_KB - 1,\r\nMLX4_RATELIMIT_UNITS_IN_KB);\r\n}\r\nerr = mlx4_en_config_port_scheduler(priv, NULL, tmp);\r\nif (err)\r\nreturn err;\r\nmemcpy(priv->maxrate, tmp, sizeof(priv->maxrate));\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_dcbnl_ieee_getqcn(struct net_device *dev,\r\nstruct ieee_qcn *qcn)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nstruct mlx4_congestion_control_mb_prio_802_1_qau_params *hw_qcn;\r\nstruct mlx4_cmd_mailbox *mailbox_out = NULL;\r\nu64 mailbox_in_dma = 0;\r\nu32 inmod = 0;\r\nint i, err;\r\nif (!(priv->mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_QCN))\r\nreturn -EOPNOTSUPP;\r\nmailbox_out = mlx4_alloc_cmd_mailbox(priv->mdev->dev);\r\nif (IS_ERR(mailbox_out))\r\nreturn -ENOMEM;\r\nhw_qcn =\r\n(struct mlx4_congestion_control_mb_prio_802_1_qau_params *)\r\nmailbox_out->buf;\r\nfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\r\ninmod = priv->port | ((1 << i) << 8) |\r\n(MLX4_CTRL_ALGO_802_1_QAU_REACTION_POINT << 16);\r\nerr = mlx4_cmd_box(priv->mdev->dev, mailbox_in_dma,\r\nmailbox_out->dma,\r\ninmod, MLX4_CONGESTION_CONTROL_GET_PARAMS,\r\nMLX4_CMD_CONGESTION_CTRL_OPCODE,\r\nMLX4_CMD_TIME_CLASS_C,\r\nMLX4_CMD_NATIVE);\r\nif (err) {\r\nmlx4_free_cmd_mailbox(priv->mdev->dev, mailbox_out);\r\nreturn err;\r\n}\r\nqcn->rpg_enable[i] =\r\nbe32_to_cpu(hw_qcn->extended_enable) >> RPG_ENABLE_BIT;\r\nqcn->rppp_max_rps[i] =\r\nbe32_to_cpu(hw_qcn->rppp_max_rps);\r\nqcn->rpg_time_reset[i] =\r\nbe32_to_cpu(hw_qcn->rpg_time_reset);\r\nqcn->rpg_byte_reset[i] =\r\nbe32_to_cpu(hw_qcn->rpg_byte_reset);\r\nqcn->rpg_threshold[i] =\r\nbe32_to_cpu(hw_qcn->rpg_threshold);\r\nqcn->rpg_max_rate[i] =\r\nbe32_to_cpu(hw_qcn->rpg_max_rate);\r\nqcn->rpg_ai_rate[i] =\r\nbe32_to_cpu(hw_qcn->rpg_ai_rate);\r\nqcn->rpg_hai_rate[i] =\r\nbe32_to_cpu(hw_qcn->rpg_hai_rate);\r\nqcn->rpg_gd[i] =\r\nbe32_to_cpu(hw_qcn->rpg_gd);\r\nqcn->rpg_min_dec_fac[i] =\r\nbe32_to_cpu(hw_qcn->rpg_min_dec_fac);\r\nqcn->rpg_min_rate[i] =\r\nbe32_to_cpu(hw_qcn->rpg_min_rate);\r\nqcn->cndd_state_machine[i] =\r\npriv->cndd_state[i];\r\n}\r\nmlx4_free_cmd_mailbox(priv->mdev->dev, mailbox_out);\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_dcbnl_ieee_setqcn(struct net_device *dev,\r\nstruct ieee_qcn *qcn)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nstruct mlx4_congestion_control_mb_prio_802_1_qau_params *hw_qcn;\r\nstruct mlx4_cmd_mailbox *mailbox_in = NULL;\r\nu64 mailbox_in_dma = 0;\r\nu32 inmod = 0;\r\nint i, err;\r\n#define MODIFY_ENABLE_HIGH_MASK 0xc0000000\r\n#define MODIFY_ENABLE_LOW_MASK 0xffc00000\r\nif (!(priv->mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_QCN))\r\nreturn -EOPNOTSUPP;\r\nmailbox_in = mlx4_alloc_cmd_mailbox(priv->mdev->dev);\r\nif (IS_ERR(mailbox_in))\r\nreturn -ENOMEM;\r\nmailbox_in_dma = mailbox_in->dma;\r\nhw_qcn =\r\n(struct mlx4_congestion_control_mb_prio_802_1_qau_params *)mailbox_in->buf;\r\nfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\r\ninmod = priv->port | ((1 << i) << 8) |\r\n(MLX4_CTRL_ALGO_802_1_QAU_REACTION_POINT << 16);\r\nhw_qcn->modify_enable_high = cpu_to_be32(\r\nMODIFY_ENABLE_HIGH_MASK);\r\nhw_qcn->modify_enable_low = cpu_to_be32(MODIFY_ENABLE_LOW_MASK);\r\nhw_qcn->extended_enable = cpu_to_be32(qcn->rpg_enable[i] << RPG_ENABLE_BIT);\r\nhw_qcn->rppp_max_rps = cpu_to_be32(qcn->rppp_max_rps[i]);\r\nhw_qcn->rpg_time_reset = cpu_to_be32(qcn->rpg_time_reset[i]);\r\nhw_qcn->rpg_byte_reset = cpu_to_be32(qcn->rpg_byte_reset[i]);\r\nhw_qcn->rpg_threshold = cpu_to_be32(qcn->rpg_threshold[i]);\r\nhw_qcn->rpg_max_rate = cpu_to_be32(qcn->rpg_max_rate[i]);\r\nhw_qcn->rpg_ai_rate = cpu_to_be32(qcn->rpg_ai_rate[i]);\r\nhw_qcn->rpg_hai_rate = cpu_to_be32(qcn->rpg_hai_rate[i]);\r\nhw_qcn->rpg_gd = cpu_to_be32(qcn->rpg_gd[i]);\r\nhw_qcn->rpg_min_dec_fac = cpu_to_be32(qcn->rpg_min_dec_fac[i]);\r\nhw_qcn->rpg_min_rate = cpu_to_be32(qcn->rpg_min_rate[i]);\r\npriv->cndd_state[i] = qcn->cndd_state_machine[i];\r\nif (qcn->cndd_state_machine[i] == DCB_CNDD_INTERIOR_READY)\r\nhw_qcn->extended_enable |= cpu_to_be32(1 << CN_TAG_BIT);\r\nerr = mlx4_cmd(priv->mdev->dev, mailbox_in_dma, inmod,\r\nMLX4_CONGESTION_CONTROL_SET_PARAMS,\r\nMLX4_CMD_CONGESTION_CTRL_OPCODE,\r\nMLX4_CMD_TIME_CLASS_C,\r\nMLX4_CMD_NATIVE);\r\nif (err) {\r\nmlx4_free_cmd_mailbox(priv->mdev->dev, mailbox_in);\r\nreturn err;\r\n}\r\n}\r\nmlx4_free_cmd_mailbox(priv->mdev->dev, mailbox_in);\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_dcbnl_ieee_getqcnstats(struct net_device *dev,\r\nstruct ieee_qcn_stats *qcn_stats)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nstruct mlx4_congestion_control_mb_prio_802_1_qau_statistics *hw_qcn_stats;\r\nstruct mlx4_cmd_mailbox *mailbox_out = NULL;\r\nu64 mailbox_in_dma = 0;\r\nu32 inmod = 0;\r\nint i, err;\r\nif (!(priv->mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_QCN))\r\nreturn -EOPNOTSUPP;\r\nmailbox_out = mlx4_alloc_cmd_mailbox(priv->mdev->dev);\r\nif (IS_ERR(mailbox_out))\r\nreturn -ENOMEM;\r\nhw_qcn_stats =\r\n(struct mlx4_congestion_control_mb_prio_802_1_qau_statistics *)\r\nmailbox_out->buf;\r\nfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\r\ninmod = priv->port | ((1 << i) << 8) |\r\n(MLX4_CTRL_ALGO_802_1_QAU_REACTION_POINT << 16);\r\nerr = mlx4_cmd_box(priv->mdev->dev, mailbox_in_dma,\r\nmailbox_out->dma, inmod,\r\nMLX4_CONGESTION_CONTROL_GET_STATISTICS,\r\nMLX4_CMD_CONGESTION_CTRL_OPCODE,\r\nMLX4_CMD_TIME_CLASS_C,\r\nMLX4_CMD_NATIVE);\r\nif (err) {\r\nmlx4_free_cmd_mailbox(priv->mdev->dev, mailbox_out);\r\nreturn err;\r\n}\r\nqcn_stats->rppp_rp_centiseconds[i] =\r\nbe64_to_cpu(hw_qcn_stats->rppp_rp_centiseconds);\r\nqcn_stats->rppp_created_rps[i] =\r\nbe32_to_cpu(hw_qcn_stats->rppp_created_rps);\r\n}\r\nmlx4_free_cmd_mailbox(priv->mdev->dev, mailbox_out);\r\nreturn 0;\r\n}
