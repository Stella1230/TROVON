static int is_s3c2412(struct s3c2410fb_info *fbi)\r\n{\r\nreturn (fbi->drv_type == DRV_S3C2412);\r\n}\r\nstatic void s3c2410fb_set_lcdaddr(struct fb_info *info)\r\n{\r\nunsigned long saddr1, saddr2, saddr3;\r\nstruct s3c2410fb_info *fbi = info->par;\r\nvoid __iomem *regs = fbi->io;\r\nsaddr1 = info->fix.smem_start >> 1;\r\nsaddr2 = info->fix.smem_start;\r\nsaddr2 += info->fix.line_length * info->var.yres;\r\nsaddr2 >>= 1;\r\nsaddr3 = S3C2410_OFFSIZE(0) |\r\nS3C2410_PAGEWIDTH((info->fix.line_length / 2) & 0x3ff);\r\ndprintk("LCDSADDR1 = 0x%08lx\n", saddr1);\r\ndprintk("LCDSADDR2 = 0x%08lx\n", saddr2);\r\ndprintk("LCDSADDR3 = 0x%08lx\n", saddr3);\r\nwritel(saddr1, regs + S3C2410_LCDSADDR1);\r\nwritel(saddr2, regs + S3C2410_LCDSADDR2);\r\nwritel(saddr3, regs + S3C2410_LCDSADDR3);\r\n}\r\nstatic unsigned int s3c2410fb_calc_pixclk(struct s3c2410fb_info *fbi,\r\nunsigned long pixclk)\r\n{\r\nunsigned long clk = fbi->clk_rate;\r\nunsigned long long div;\r\ndiv = (unsigned long long)clk * pixclk;\r\ndiv >>= 12;\r\ndo_div(div, 625 * 625UL * 625);\r\ndprintk("pixclk %ld, divisor is %ld\n", pixclk, (long)div);\r\nreturn div;\r\n}\r\nstatic int s3c2410fb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct s3c2410fb_info *fbi = info->par;\r\nstruct s3c2410fb_mach_info *mach_info = dev_get_platdata(fbi->dev);\r\nstruct s3c2410fb_display *display = NULL;\r\nstruct s3c2410fb_display *default_display = mach_info->displays +\r\nmach_info->default_display;\r\nint type = default_display->type;\r\nunsigned i;\r\ndprintk("check_var(var=%p, info=%p)\n", var, info);\r\nif (var->yres == default_display->yres &&\r\nvar->xres == default_display->xres &&\r\nvar->bits_per_pixel == default_display->bpp)\r\ndisplay = default_display;\r\nelse\r\nfor (i = 0; i < mach_info->num_displays; i++)\r\nif (type == mach_info->displays[i].type &&\r\nvar->yres == mach_info->displays[i].yres &&\r\nvar->xres == mach_info->displays[i].xres &&\r\nvar->bits_per_pixel == mach_info->displays[i].bpp) {\r\ndisplay = mach_info->displays + i;\r\nbreak;\r\n}\r\nif (!display) {\r\ndprintk("wrong resolution or depth %dx%d at %d bpp\n",\r\nvar->xres, var->yres, var->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\nvar->xres_virtual = display->xres;\r\nvar->yres_virtual = display->yres;\r\nvar->height = display->height;\r\nvar->width = display->width;\r\nvar->pixclock = display->pixclock;\r\nvar->left_margin = display->left_margin;\r\nvar->right_margin = display->right_margin;\r\nvar->upper_margin = display->upper_margin;\r\nvar->lower_margin = display->lower_margin;\r\nvar->vsync_len = display->vsync_len;\r\nvar->hsync_len = display->hsync_len;\r\nfbi->regs.lcdcon5 = display->lcdcon5;\r\nfbi->regs.lcdcon1 = display->type;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nswitch (var->bits_per_pixel) {\r\ncase 1:\r\ncase 2:\r\ncase 4:\r\nvar->red.offset = 0;\r\nvar->red.length = var->bits_per_pixel;\r\nvar->green = var->red;\r\nvar->blue = var->red;\r\nbreak;\r\ncase 8:\r\nif (display->type != S3C2410_LCDCON1_TFT) {\r\nvar->red.length = 3;\r\nvar->red.offset = 5;\r\nvar->green.length = 3;\r\nvar->green.offset = 2;\r\nvar->blue.length = 2;\r\nvar->blue.offset = 0;\r\n} else {\r\nvar->red.offset = 0;\r\nvar->red.length = 8;\r\nvar->green = var->red;\r\nvar->blue = var->red;\r\n}\r\nbreak;\r\ncase 12:\r\nvar->red.length = 4;\r\nvar->red.offset = 8;\r\nvar->green.length = 4;\r\nvar->green.offset = 4;\r\nvar->blue.length = 4;\r\nvar->blue.offset = 0;\r\nbreak;\r\ndefault:\r\ncase 16:\r\nif (display->lcdcon5 & S3C2410_LCDCON5_FRM565) {\r\nvar->red.offset = 11;\r\nvar->green.offset = 5;\r\nvar->blue.offset = 0;\r\nvar->red.length = 5;\r\nvar->green.length = 6;\r\nvar->blue.length = 5;\r\n} else {\r\nvar->red.offset = 11;\r\nvar->green.offset = 6;\r\nvar->blue.offset = 1;\r\nvar->red.length = 5;\r\nvar->green.length = 5;\r\nvar->blue.length = 5;\r\n}\r\nbreak;\r\ncase 32:\r\nvar->red.length = 8;\r\nvar->red.offset = 16;\r\nvar->green.length = 8;\r\nvar->green.offset = 8;\r\nvar->blue.length = 8;\r\nvar->blue.offset = 0;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void s3c2410fb_calculate_stn_lcd_regs(const struct fb_info *info,\r\nstruct s3c2410fb_hw *regs)\r\n{\r\nconst struct s3c2410fb_info *fbi = info->par;\r\nconst struct fb_var_screeninfo *var = &info->var;\r\nint type = regs->lcdcon1 & ~S3C2410_LCDCON1_TFT;\r\nint hs = var->xres >> 2;\r\nunsigned wdly = (var->left_margin >> 4) - 1;\r\nunsigned wlh = (var->hsync_len >> 4) - 1;\r\nif (type != S3C2410_LCDCON1_STN4)\r\nhs >>= 1;\r\nswitch (var->bits_per_pixel) {\r\ncase 1:\r\nregs->lcdcon1 |= S3C2410_LCDCON1_STN1BPP;\r\nbreak;\r\ncase 2:\r\nregs->lcdcon1 |= S3C2410_LCDCON1_STN2GREY;\r\nbreak;\r\ncase 4:\r\nregs->lcdcon1 |= S3C2410_LCDCON1_STN4GREY;\r\nbreak;\r\ncase 8:\r\nregs->lcdcon1 |= S3C2410_LCDCON1_STN8BPP;\r\nhs *= 3;\r\nbreak;\r\ncase 12:\r\nregs->lcdcon1 |= S3C2410_LCDCON1_STN12BPP;\r\nhs *= 3;\r\nbreak;\r\ndefault:\r\ndev_err(fbi->dev, "invalid bpp %d\n",\r\nvar->bits_per_pixel);\r\n}\r\ndprintk("setting horz: lft=%d, rt=%d, sync=%d\n",\r\nvar->left_margin, var->right_margin, var->hsync_len);\r\nregs->lcdcon2 = S3C2410_LCDCON2_LINEVAL(var->yres - 1);\r\nif (wdly > 3)\r\nwdly = 3;\r\nif (wlh > 3)\r\nwlh = 3;\r\nregs->lcdcon3 = S3C2410_LCDCON3_WDLY(wdly) |\r\nS3C2410_LCDCON3_LINEBLANK(var->right_margin / 8) |\r\nS3C2410_LCDCON3_HOZVAL(hs - 1);\r\nregs->lcdcon4 = S3C2410_LCDCON4_WLH(wlh);\r\n}\r\nstatic void s3c2410fb_calculate_tft_lcd_regs(const struct fb_info *info,\r\nstruct s3c2410fb_hw *regs)\r\n{\r\nconst struct s3c2410fb_info *fbi = info->par;\r\nconst struct fb_var_screeninfo *var = &info->var;\r\nswitch (var->bits_per_pixel) {\r\ncase 1:\r\nregs->lcdcon1 |= S3C2410_LCDCON1_TFT1BPP;\r\nbreak;\r\ncase 2:\r\nregs->lcdcon1 |= S3C2410_LCDCON1_TFT2BPP;\r\nbreak;\r\ncase 4:\r\nregs->lcdcon1 |= S3C2410_LCDCON1_TFT4BPP;\r\nbreak;\r\ncase 8:\r\nregs->lcdcon1 |= S3C2410_LCDCON1_TFT8BPP;\r\nregs->lcdcon5 |= S3C2410_LCDCON5_BSWP |\r\nS3C2410_LCDCON5_FRM565;\r\nregs->lcdcon5 &= ~S3C2410_LCDCON5_HWSWP;\r\nbreak;\r\ncase 16:\r\nregs->lcdcon1 |= S3C2410_LCDCON1_TFT16BPP;\r\nregs->lcdcon5 &= ~S3C2410_LCDCON5_BSWP;\r\nregs->lcdcon5 |= S3C2410_LCDCON5_HWSWP;\r\nbreak;\r\ncase 32:\r\nregs->lcdcon1 |= S3C2410_LCDCON1_TFT24BPP;\r\nregs->lcdcon5 &= ~(S3C2410_LCDCON5_BSWP |\r\nS3C2410_LCDCON5_HWSWP |\r\nS3C2410_LCDCON5_BPP24BL);\r\nbreak;\r\ndefault:\r\ndev_err(fbi->dev, "invalid bpp %d\n",\r\nvar->bits_per_pixel);\r\n}\r\ndprintk("setting vert: up=%d, low=%d, sync=%d\n",\r\nvar->upper_margin, var->lower_margin, var->vsync_len);\r\ndprintk("setting horz: lft=%d, rt=%d, sync=%d\n",\r\nvar->left_margin, var->right_margin, var->hsync_len);\r\nregs->lcdcon2 = S3C2410_LCDCON2_LINEVAL(var->yres - 1) |\r\nS3C2410_LCDCON2_VBPD(var->upper_margin - 1) |\r\nS3C2410_LCDCON2_VFPD(var->lower_margin - 1) |\r\nS3C2410_LCDCON2_VSPW(var->vsync_len - 1);\r\nregs->lcdcon3 = S3C2410_LCDCON3_HBPD(var->right_margin - 1) |\r\nS3C2410_LCDCON3_HFPD(var->left_margin - 1) |\r\nS3C2410_LCDCON3_HOZVAL(var->xres - 1);\r\nregs->lcdcon4 = S3C2410_LCDCON4_HSPW(var->hsync_len - 1);\r\n}\r\nstatic void s3c2410fb_activate_var(struct fb_info *info)\r\n{\r\nstruct s3c2410fb_info *fbi = info->par;\r\nvoid __iomem *regs = fbi->io;\r\nint type = fbi->regs.lcdcon1 & S3C2410_LCDCON1_TFT;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nint clkdiv;\r\nclkdiv = DIV_ROUND_UP(s3c2410fb_calc_pixclk(fbi, var->pixclock), 2);\r\ndprintk("%s: var->xres = %d\n", __func__, var->xres);\r\ndprintk("%s: var->yres = %d\n", __func__, var->yres);\r\ndprintk("%s: var->bpp = %d\n", __func__, var->bits_per_pixel);\r\nif (type == S3C2410_LCDCON1_TFT) {\r\ns3c2410fb_calculate_tft_lcd_regs(info, &fbi->regs);\r\n--clkdiv;\r\nif (clkdiv < 0)\r\nclkdiv = 0;\r\n} else {\r\ns3c2410fb_calculate_stn_lcd_regs(info, &fbi->regs);\r\nif (clkdiv < 2)\r\nclkdiv = 2;\r\n}\r\nfbi->regs.lcdcon1 |= S3C2410_LCDCON1_CLKVAL(clkdiv);\r\ndprintk("new register set:\n");\r\ndprintk("lcdcon[1] = 0x%08lx\n", fbi->regs.lcdcon1);\r\ndprintk("lcdcon[2] = 0x%08lx\n", fbi->regs.lcdcon2);\r\ndprintk("lcdcon[3] = 0x%08lx\n", fbi->regs.lcdcon3);\r\ndprintk("lcdcon[4] = 0x%08lx\n", fbi->regs.lcdcon4);\r\ndprintk("lcdcon[5] = 0x%08lx\n", fbi->regs.lcdcon5);\r\nwritel(fbi->regs.lcdcon1 & ~S3C2410_LCDCON1_ENVID,\r\nregs + S3C2410_LCDCON1);\r\nwritel(fbi->regs.lcdcon2, regs + S3C2410_LCDCON2);\r\nwritel(fbi->regs.lcdcon3, regs + S3C2410_LCDCON3);\r\nwritel(fbi->regs.lcdcon4, regs + S3C2410_LCDCON4);\r\nwritel(fbi->regs.lcdcon5, regs + S3C2410_LCDCON5);\r\ns3c2410fb_set_lcdaddr(info);\r\nfbi->regs.lcdcon1 |= S3C2410_LCDCON1_ENVID,\r\nwritel(fbi->regs.lcdcon1, regs + S3C2410_LCDCON1);\r\n}\r\nstatic int s3c2410fb_set_par(struct fb_info *info)\r\n{\r\nstruct fb_var_screeninfo *var = &info->var;\r\nswitch (var->bits_per_pixel) {\r\ncase 32:\r\ncase 16:\r\ncase 12:\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\nbreak;\r\ncase 1:\r\ninfo->fix.visual = FB_VISUAL_MONO01;\r\nbreak;\r\ndefault:\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\nbreak;\r\n}\r\ninfo->fix.line_length = (var->xres_virtual * var->bits_per_pixel) / 8;\r\ns3c2410fb_activate_var(info);\r\nreturn 0;\r\n}\r\nstatic void schedule_palette_update(struct s3c2410fb_info *fbi,\r\nunsigned int regno, unsigned int val)\r\n{\r\nunsigned long flags;\r\nunsigned long irqen;\r\nvoid __iomem *irq_base = fbi->irq_base;\r\nlocal_irq_save(flags);\r\nfbi->palette_buffer[regno] = val;\r\nif (!fbi->palette_ready) {\r\nfbi->palette_ready = 1;\r\nirqen = readl(irq_base + S3C24XX_LCDINTMSK);\r\nirqen &= ~S3C2410_LCDINT_FRSYNC;\r\nwritel(irqen, irq_base + S3C24XX_LCDINTMSK);\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic inline unsigned int chan_to_field(unsigned int chan,\r\nstruct fb_bitfield *bf)\r\n{\r\nchan &= 0xffff;\r\nchan >>= 16 - bf->length;\r\nreturn chan << bf->offset;\r\n}\r\nstatic int s3c2410fb_setcolreg(unsigned regno,\r\nunsigned red, unsigned green, unsigned blue,\r\nunsigned transp, struct fb_info *info)\r\n{\r\nstruct s3c2410fb_info *fbi = info->par;\r\nvoid __iomem *regs = fbi->io;\r\nunsigned int val;\r\nswitch (info->fix.visual) {\r\ncase FB_VISUAL_TRUECOLOR:\r\nif (regno < 16) {\r\nu32 *pal = info->pseudo_palette;\r\nval = chan_to_field(red, &info->var.red);\r\nval |= chan_to_field(green, &info->var.green);\r\nval |= chan_to_field(blue, &info->var.blue);\r\npal[regno] = val;\r\n}\r\nbreak;\r\ncase FB_VISUAL_PSEUDOCOLOR:\r\nif (regno < 256) {\r\nval = (red >> 0) & 0xf800;\r\nval |= (green >> 5) & 0x07e0;\r\nval |= (blue >> 11) & 0x001f;\r\nwritel(val, regs + S3C2410_TFTPAL(regno));\r\nschedule_palette_update(fbi, regno, val);\r\n}\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void s3c2410fb_lcd_enable(struct s3c2410fb_info *fbi, int enable)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nif (enable)\r\nfbi->regs.lcdcon1 |= S3C2410_LCDCON1_ENVID;\r\nelse\r\nfbi->regs.lcdcon1 &= ~S3C2410_LCDCON1_ENVID;\r\nwritel(fbi->regs.lcdcon1, fbi->io + S3C2410_LCDCON1);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int s3c2410fb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nstruct s3c2410fb_info *fbi = info->par;\r\nvoid __iomem *tpal_reg = fbi->io;\r\ndprintk("blank(mode=%d, info=%p)\n", blank_mode, info);\r\ntpal_reg += is_s3c2412(fbi) ? S3C2412_TPAL : S3C2410_TPAL;\r\nif (blank_mode == FB_BLANK_POWERDOWN)\r\ns3c2410fb_lcd_enable(fbi, 0);\r\nelse\r\ns3c2410fb_lcd_enable(fbi, 1);\r\nif (blank_mode == FB_BLANK_UNBLANK)\r\nwritel(0x0, tpal_reg);\r\nelse {\r\ndprintk("setting TPAL to output 0x000000\n");\r\nwritel(S3C2410_TPAL_EN, tpal_reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int s3c2410fb_debug_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", debug ? "on" : "off");\r\n}\r\nstatic int s3c2410fb_debug_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nif (len < 1)\r\nreturn -EINVAL;\r\nif (strncasecmp(buf, "on", 2) == 0 ||\r\nstrncasecmp(buf, "1", 1) == 0) {\r\ndebug = 1;\r\ndev_dbg(dev, "s3c2410fb: Debug On");\r\n} else if (strncasecmp(buf, "off", 3) == 0 ||\r\nstrncasecmp(buf, "0", 1) == 0) {\r\ndebug = 0;\r\ndev_dbg(dev, "s3c2410fb: Debug Off");\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn len;\r\n}\r\nstatic int s3c2410fb_map_video_memory(struct fb_info *info)\r\n{\r\nstruct s3c2410fb_info *fbi = info->par;\r\ndma_addr_t map_dma;\r\nunsigned map_size = PAGE_ALIGN(info->fix.smem_len);\r\ndprintk("map_video_memory(fbi=%p) map_size %u\n", fbi, map_size);\r\ninfo->screen_base = dma_alloc_writecombine(fbi->dev, map_size,\r\n&map_dma, GFP_KERNEL);\r\nif (info->screen_base) {\r\ndprintk("map_video_memory: clear %p:%08x\n",\r\ninfo->screen_base, map_size);\r\nmemset(info->screen_base, 0x00, map_size);\r\ninfo->fix.smem_start = map_dma;\r\ndprintk("map_video_memory: dma=%08lx cpu=%p size=%08x\n",\r\ninfo->fix.smem_start, info->screen_base, map_size);\r\n}\r\nreturn info->screen_base ? 0 : -ENOMEM;\r\n}\r\nstatic inline void s3c2410fb_unmap_video_memory(struct fb_info *info)\r\n{\r\nstruct s3c2410fb_info *fbi = info->par;\r\ndma_free_writecombine(fbi->dev, PAGE_ALIGN(info->fix.smem_len),\r\ninfo->screen_base, info->fix.smem_start);\r\n}\r\nstatic inline void modify_gpio(void __iomem *reg,\r\nunsigned long set, unsigned long mask)\r\n{\r\nunsigned long tmp;\r\ntmp = readl(reg) & ~mask;\r\nwritel(tmp | set, reg);\r\n}\r\nstatic int s3c2410fb_init_registers(struct fb_info *info)\r\n{\r\nstruct s3c2410fb_info *fbi = info->par;\r\nstruct s3c2410fb_mach_info *mach_info = dev_get_platdata(fbi->dev);\r\nunsigned long flags;\r\nvoid __iomem *regs = fbi->io;\r\nvoid __iomem *tpal;\r\nvoid __iomem *lpcsel;\r\nif (is_s3c2412(fbi)) {\r\ntpal = regs + S3C2412_TPAL;\r\nlpcsel = regs + S3C2412_TCONSEL;\r\n} else {\r\ntpal = regs + S3C2410_TPAL;\r\nlpcsel = regs + S3C2410_LPCSEL;\r\n}\r\nlocal_irq_save(flags);\r\nmodify_gpio(S3C2410_GPCUP, mach_info->gpcup, mach_info->gpcup_mask);\r\nmodify_gpio(S3C2410_GPCCON, mach_info->gpccon, mach_info->gpccon_mask);\r\nmodify_gpio(S3C2410_GPDUP, mach_info->gpdup, mach_info->gpdup_mask);\r\nmodify_gpio(S3C2410_GPDCON, mach_info->gpdcon, mach_info->gpdcon_mask);\r\nlocal_irq_restore(flags);\r\ndprintk("LPCSEL = 0x%08lx\n", mach_info->lpcsel);\r\nwritel(mach_info->lpcsel, lpcsel);\r\ndprintk("replacing TPAL %08x\n", readl(tpal));\r\nwritel(0x00, tpal);\r\nreturn 0;\r\n}\r\nstatic void s3c2410fb_write_palette(struct s3c2410fb_info *fbi)\r\n{\r\nunsigned int i;\r\nvoid __iomem *regs = fbi->io;\r\nfbi->palette_ready = 0;\r\nfor (i = 0; i < 256; i++) {\r\nunsigned long ent = fbi->palette_buffer[i];\r\nif (ent == PALETTE_BUFF_CLEAR)\r\ncontinue;\r\nwritel(ent, regs + S3C2410_TFTPAL(i));\r\nif (readw(regs + S3C2410_TFTPAL(i)) == ent)\r\nfbi->palette_buffer[i] = PALETTE_BUFF_CLEAR;\r\nelse\r\nfbi->palette_ready = 1;\r\n}\r\n}\r\nstatic irqreturn_t s3c2410fb_irq(int irq, void *dev_id)\r\n{\r\nstruct s3c2410fb_info *fbi = dev_id;\r\nvoid __iomem *irq_base = fbi->irq_base;\r\nunsigned long lcdirq = readl(irq_base + S3C24XX_LCDINTPND);\r\nif (lcdirq & S3C2410_LCDINT_FRSYNC) {\r\nif (fbi->palette_ready)\r\ns3c2410fb_write_palette(fbi);\r\nwritel(S3C2410_LCDINT_FRSYNC, irq_base + S3C24XX_LCDINTPND);\r\nwritel(S3C2410_LCDINT_FRSYNC, irq_base + S3C24XX_LCDSRCPND);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int s3c2410fb_cpufreq_transition(struct notifier_block *nb,\r\nunsigned long val, void *data)\r\n{\r\nstruct s3c2410fb_info *info;\r\nstruct fb_info *fbinfo;\r\nlong delta_f;\r\ninfo = container_of(nb, struct s3c2410fb_info, freq_transition);\r\nfbinfo = platform_get_drvdata(to_platform_device(info->dev));\r\ndelta_f = info->clk_rate - clk_get_rate(info->clk);\r\nif ((val == CPUFREQ_POSTCHANGE && delta_f > 0) ||\r\n(val == CPUFREQ_PRECHANGE && delta_f < 0)) {\r\ninfo->clk_rate = clk_get_rate(info->clk);\r\ns3c2410fb_activate_var(fbinfo);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int s3c2410fb_cpufreq_register(struct s3c2410fb_info *info)\r\n{\r\ninfo->freq_transition.notifier_call = s3c2410fb_cpufreq_transition;\r\nreturn cpufreq_register_notifier(&info->freq_transition,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\n}\r\nstatic inline void s3c2410fb_cpufreq_deregister(struct s3c2410fb_info *info)\r\n{\r\ncpufreq_unregister_notifier(&info->freq_transition,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\n}\r\nstatic inline int s3c2410fb_cpufreq_register(struct s3c2410fb_info *info)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void s3c2410fb_cpufreq_deregister(struct s3c2410fb_info *info)\r\n{\r\n}\r\nstatic int s3c24xxfb_probe(struct platform_device *pdev,\r\nenum s3c_drv_type drv_type)\r\n{\r\nstruct s3c2410fb_info *info;\r\nstruct s3c2410fb_display *display;\r\nstruct fb_info *fbinfo;\r\nstruct s3c2410fb_mach_info *mach_info;\r\nstruct resource *res;\r\nint ret;\r\nint irq;\r\nint i;\r\nint size;\r\nu32 lcdcon1;\r\nmach_info = dev_get_platdata(&pdev->dev);\r\nif (mach_info == NULL) {\r\ndev_err(&pdev->dev,\r\n"no platform data for lcd, cannot attach\n");\r\nreturn -EINVAL;\r\n}\r\nif (mach_info->default_display >= mach_info->num_displays) {\r\ndev_err(&pdev->dev, "default is %d but only %d displays\n",\r\nmach_info->default_display, mach_info->num_displays);\r\nreturn -EINVAL;\r\n}\r\ndisplay = mach_info->displays + mach_info->default_display;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no irq for device\n");\r\nreturn -ENOENT;\r\n}\r\nfbinfo = framebuffer_alloc(sizeof(struct s3c2410fb_info), &pdev->dev);\r\nif (!fbinfo)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, fbinfo);\r\ninfo = fbinfo->par;\r\ninfo->dev = &pdev->dev;\r\ninfo->drv_type = drv_type;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "failed to get memory registers\n");\r\nret = -ENXIO;\r\ngoto dealloc_fb;\r\n}\r\nsize = resource_size(res);\r\ninfo->mem = request_mem_region(res->start, size, pdev->name);\r\nif (info->mem == NULL) {\r\ndev_err(&pdev->dev, "failed to get memory region\n");\r\nret = -ENOENT;\r\ngoto dealloc_fb;\r\n}\r\ninfo->io = ioremap(res->start, size);\r\nif (info->io == NULL) {\r\ndev_err(&pdev->dev, "ioremap() of registers failed\n");\r\nret = -ENXIO;\r\ngoto release_mem;\r\n}\r\nif (drv_type == DRV_S3C2412)\r\ninfo->irq_base = info->io + S3C2412_LCDINTBASE;\r\nelse\r\ninfo->irq_base = info->io + S3C2410_LCDINTBASE;\r\ndprintk("devinit\n");\r\nstrcpy(fbinfo->fix.id, driver_name);\r\nlcdcon1 = readl(info->io + S3C2410_LCDCON1);\r\nwritel(lcdcon1 & ~S3C2410_LCDCON1_ENVID, info->io + S3C2410_LCDCON1);\r\nfbinfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\nfbinfo->fix.type_aux = 0;\r\nfbinfo->fix.xpanstep = 0;\r\nfbinfo->fix.ypanstep = 0;\r\nfbinfo->fix.ywrapstep = 0;\r\nfbinfo->fix.accel = FB_ACCEL_NONE;\r\nfbinfo->var.nonstd = 0;\r\nfbinfo->var.activate = FB_ACTIVATE_NOW;\r\nfbinfo->var.accel_flags = 0;\r\nfbinfo->var.vmode = FB_VMODE_NONINTERLACED;\r\nfbinfo->fbops = &s3c2410fb_ops;\r\nfbinfo->flags = FBINFO_FLAG_DEFAULT;\r\nfbinfo->pseudo_palette = &info->pseudo_pal;\r\nfor (i = 0; i < 256; i++)\r\ninfo->palette_buffer[i] = PALETTE_BUFF_CLEAR;\r\nret = request_irq(irq, s3c2410fb_irq, 0, pdev->name, info);\r\nif (ret) {\r\ndev_err(&pdev->dev, "cannot get irq %d - err %d\n", irq, ret);\r\nret = -EBUSY;\r\ngoto release_regs;\r\n}\r\ninfo->clk = clk_get(NULL, "lcd");\r\nif (IS_ERR(info->clk)) {\r\ndev_err(&pdev->dev, "failed to get lcd clock source\n");\r\nret = PTR_ERR(info->clk);\r\ngoto release_irq;\r\n}\r\nclk_prepare_enable(info->clk);\r\ndprintk("got and enabled clock\n");\r\nusleep_range(1000, 1100);\r\ninfo->clk_rate = clk_get_rate(info->clk);\r\nfor (i = 0; i < mach_info->num_displays; i++) {\r\nunsigned long smem_len = mach_info->displays[i].xres;\r\nsmem_len *= mach_info->displays[i].yres;\r\nsmem_len *= mach_info->displays[i].bpp;\r\nsmem_len >>= 3;\r\nif (fbinfo->fix.smem_len < smem_len)\r\nfbinfo->fix.smem_len = smem_len;\r\n}\r\nret = s3c2410fb_map_video_memory(fbinfo);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to allocate video RAM: %d\n", ret);\r\nret = -ENOMEM;\r\ngoto release_clock;\r\n}\r\ndprintk("got video memory\n");\r\nfbinfo->var.xres = display->xres;\r\nfbinfo->var.yres = display->yres;\r\nfbinfo->var.bits_per_pixel = display->bpp;\r\ns3c2410fb_init_registers(fbinfo);\r\ns3c2410fb_check_var(&fbinfo->var, fbinfo);\r\nret = s3c2410fb_cpufreq_register(info);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to register cpufreq\n");\r\ngoto free_video_memory;\r\n}\r\nret = register_framebuffer(fbinfo);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to register framebuffer device: %d\n",\r\nret);\r\ngoto free_cpufreq;\r\n}\r\nret = device_create_file(&pdev->dev, &dev_attr_debug);\r\nif (ret)\r\ndev_err(&pdev->dev, "failed to add debug attribute\n");\r\ndev_info(&pdev->dev, "fb%d: %s frame buffer device\n",\r\nfbinfo->node, fbinfo->fix.id);\r\nreturn 0;\r\nfree_cpufreq:\r\ns3c2410fb_cpufreq_deregister(info);\r\nfree_video_memory:\r\ns3c2410fb_unmap_video_memory(fbinfo);\r\nrelease_clock:\r\nclk_disable_unprepare(info->clk);\r\nclk_put(info->clk);\r\nrelease_irq:\r\nfree_irq(irq, info);\r\nrelease_regs:\r\niounmap(info->io);\r\nrelease_mem:\r\nrelease_mem_region(res->start, size);\r\ndealloc_fb:\r\nframebuffer_release(fbinfo);\r\nreturn ret;\r\n}\r\nstatic int s3c2410fb_probe(struct platform_device *pdev)\r\n{\r\nreturn s3c24xxfb_probe(pdev, DRV_S3C2410);\r\n}\r\nstatic int s3c2412fb_probe(struct platform_device *pdev)\r\n{\r\nreturn s3c24xxfb_probe(pdev, DRV_S3C2412);\r\n}\r\nstatic int s3c2410fb_remove(struct platform_device *pdev)\r\n{\r\nstruct fb_info *fbinfo = platform_get_drvdata(pdev);\r\nstruct s3c2410fb_info *info = fbinfo->par;\r\nint irq;\r\nunregister_framebuffer(fbinfo);\r\ns3c2410fb_cpufreq_deregister(info);\r\ns3c2410fb_lcd_enable(info, 0);\r\nusleep_range(1000, 1100);\r\ns3c2410fb_unmap_video_memory(fbinfo);\r\nif (info->clk) {\r\nclk_disable_unprepare(info->clk);\r\nclk_put(info->clk);\r\ninfo->clk = NULL;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nfree_irq(irq, info);\r\niounmap(info->io);\r\nrelease_mem_region(info->mem->start, resource_size(info->mem));\r\nframebuffer_release(fbinfo);\r\nreturn 0;\r\n}\r\nstatic int s3c2410fb_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nstruct fb_info *fbinfo = platform_get_drvdata(dev);\r\nstruct s3c2410fb_info *info = fbinfo->par;\r\ns3c2410fb_lcd_enable(info, 0);\r\nusleep_range(1000, 1100);\r\nclk_disable_unprepare(info->clk);\r\nreturn 0;\r\n}\r\nstatic int s3c2410fb_resume(struct platform_device *dev)\r\n{\r\nstruct fb_info *fbinfo = platform_get_drvdata(dev);\r\nstruct s3c2410fb_info *info = fbinfo->par;\r\nclk_prepare_enable(info->clk);\r\nusleep_range(1000, 1100);\r\ns3c2410fb_init_registers(fbinfo);\r\ns3c2410fb_activate_var(fbinfo);\r\ns3c2410fb_blank(FB_BLANK_UNBLANK, fbinfo);\r\nreturn 0;\r\n}\r\nint __init s3c2410fb_init(void)\r\n{\r\nint ret = platform_driver_register(&s3c2410fb_driver);\r\nif (ret == 0)\r\nret = platform_driver_register(&s3c2412fb_driver);\r\nreturn ret;\r\n}\r\nstatic void __exit s3c2410fb_cleanup(void)\r\n{\r\nplatform_driver_unregister(&s3c2410fb_driver);\r\nplatform_driver_unregister(&s3c2412fb_driver);\r\n}
