static void nf_nat_ipv4_decode_session(struct sk_buff *skb,\r\nconst struct nf_conn *ct,\r\nenum ip_conntrack_dir dir,\r\nunsigned long statusbit,\r\nstruct flowi *fl)\r\n{\r\nconst struct nf_conntrack_tuple *t = &ct->tuplehash[dir].tuple;\r\nstruct flowi4 *fl4 = &fl->u.ip4;\r\nif (ct->status & statusbit) {\r\nfl4->daddr = t->dst.u3.ip;\r\nif (t->dst.protonum == IPPROTO_TCP ||\r\nt->dst.protonum == IPPROTO_UDP ||\r\nt->dst.protonum == IPPROTO_UDPLITE ||\r\nt->dst.protonum == IPPROTO_DCCP ||\r\nt->dst.protonum == IPPROTO_SCTP)\r\nfl4->fl4_dport = t->dst.u.all;\r\n}\r\nstatusbit ^= IPS_NAT_MASK;\r\nif (ct->status & statusbit) {\r\nfl4->saddr = t->src.u3.ip;\r\nif (t->dst.protonum == IPPROTO_TCP ||\r\nt->dst.protonum == IPPROTO_UDP ||\r\nt->dst.protonum == IPPROTO_UDPLITE ||\r\nt->dst.protonum == IPPROTO_DCCP ||\r\nt->dst.protonum == IPPROTO_SCTP)\r\nfl4->fl4_sport = t->src.u.all;\r\n}\r\n}\r\nstatic bool nf_nat_ipv4_in_range(const struct nf_conntrack_tuple *t,\r\nconst struct nf_nat_range *range)\r\n{\r\nreturn ntohl(t->src.u3.ip) >= ntohl(range->min_addr.ip) &&\r\nntohl(t->src.u3.ip) <= ntohl(range->max_addr.ip);\r\n}\r\nstatic u32 nf_nat_ipv4_secure_port(const struct nf_conntrack_tuple *t,\r\n__be16 dport)\r\n{\r\nreturn secure_ipv4_port_ephemeral(t->src.u3.ip, t->dst.u3.ip, dport);\r\n}\r\nstatic bool nf_nat_ipv4_manip_pkt(struct sk_buff *skb,\r\nunsigned int iphdroff,\r\nconst struct nf_nat_l4proto *l4proto,\r\nconst struct nf_conntrack_tuple *target,\r\nenum nf_nat_manip_type maniptype)\r\n{\r\nstruct iphdr *iph;\r\nunsigned int hdroff;\r\nif (!skb_make_writable(skb, iphdroff + sizeof(*iph)))\r\nreturn false;\r\niph = (void *)skb->data + iphdroff;\r\nhdroff = iphdroff + iph->ihl * 4;\r\nif (!l4proto->manip_pkt(skb, &nf_nat_l3proto_ipv4, iphdroff, hdroff,\r\ntarget, maniptype))\r\nreturn false;\r\niph = (void *)skb->data + iphdroff;\r\nif (maniptype == NF_NAT_MANIP_SRC) {\r\ncsum_replace4(&iph->check, iph->saddr, target->src.u3.ip);\r\niph->saddr = target->src.u3.ip;\r\n} else {\r\ncsum_replace4(&iph->check, iph->daddr, target->dst.u3.ip);\r\niph->daddr = target->dst.u3.ip;\r\n}\r\nreturn true;\r\n}\r\nstatic void nf_nat_ipv4_csum_update(struct sk_buff *skb,\r\nunsigned int iphdroff, __sum16 *check,\r\nconst struct nf_conntrack_tuple *t,\r\nenum nf_nat_manip_type maniptype)\r\n{\r\nstruct iphdr *iph = (struct iphdr *)(skb->data + iphdroff);\r\n__be32 oldip, newip;\r\nif (maniptype == NF_NAT_MANIP_SRC) {\r\noldip = iph->saddr;\r\nnewip = t->src.u3.ip;\r\n} else {\r\noldip = iph->daddr;\r\nnewip = t->dst.u3.ip;\r\n}\r\ninet_proto_csum_replace4(check, skb, oldip, newip, 1);\r\n}\r\nstatic void nf_nat_ipv4_csum_recalc(struct sk_buff *skb,\r\nu8 proto, void *data, __sum16 *check,\r\nint datalen, int oldlen)\r\n{\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nstruct rtable *rt = skb_rtable(skb);\r\nif (skb->ip_summed != CHECKSUM_PARTIAL) {\r\nif (!(rt->rt_flags & RTCF_LOCAL) &&\r\n(!skb->dev || skb->dev->features & NETIF_F_V4_CSUM)) {\r\nskb->ip_summed = CHECKSUM_PARTIAL;\r\nskb->csum_start = skb_headroom(skb) +\r\nskb_network_offset(skb) +\r\nip_hdrlen(skb);\r\nskb->csum_offset = (void *)check - data;\r\n*check = ~csum_tcpudp_magic(iph->saddr, iph->daddr,\r\ndatalen, proto, 0);\r\n} else {\r\n*check = 0;\r\n*check = csum_tcpudp_magic(iph->saddr, iph->daddr,\r\ndatalen, proto,\r\ncsum_partial(data, datalen,\r\n0));\r\nif (proto == IPPROTO_UDP && !*check)\r\n*check = CSUM_MANGLED_0;\r\n}\r\n} else\r\ninet_proto_csum_replace2(check, skb,\r\nhtons(oldlen), htons(datalen), 1);\r\n}\r\nstatic int nf_nat_ipv4_nlattr_to_range(struct nlattr *tb[],\r\nstruct nf_nat_range *range)\r\n{\r\nif (tb[CTA_NAT_V4_MINIP]) {\r\nrange->min_addr.ip = nla_get_be32(tb[CTA_NAT_V4_MINIP]);\r\nrange->flags |= NF_NAT_RANGE_MAP_IPS;\r\n}\r\nif (tb[CTA_NAT_V4_MAXIP])\r\nrange->max_addr.ip = nla_get_be32(tb[CTA_NAT_V4_MAXIP]);\r\nelse\r\nrange->max_addr.ip = range->min_addr.ip;\r\nreturn 0;\r\n}\r\nint nf_nat_icmp_reply_translation(struct sk_buff *skb,\r\nstruct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int hooknum)\r\n{\r\nstruct {\r\nstruct icmphdr icmp;\r\nstruct iphdr ip;\r\n} *inside;\r\nenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\r\nenum nf_nat_manip_type manip = HOOK2MANIP(hooknum);\r\nunsigned int hdrlen = ip_hdrlen(skb);\r\nconst struct nf_nat_l4proto *l4proto;\r\nstruct nf_conntrack_tuple target;\r\nunsigned long statusbit;\r\nNF_CT_ASSERT(ctinfo == IP_CT_RELATED || ctinfo == IP_CT_RELATED_REPLY);\r\nif (!skb_make_writable(skb, hdrlen + sizeof(*inside)))\r\nreturn 0;\r\nif (nf_ip_checksum(skb, hooknum, hdrlen, 0))\r\nreturn 0;\r\ninside = (void *)skb->data + hdrlen;\r\nif (inside->icmp.type == ICMP_REDIRECT) {\r\nif ((ct->status & IPS_NAT_DONE_MASK) != IPS_NAT_DONE_MASK)\r\nreturn 0;\r\nif (ct->status & IPS_NAT_MASK)\r\nreturn 0;\r\n}\r\nif (manip == NF_NAT_MANIP_SRC)\r\nstatusbit = IPS_SRC_NAT;\r\nelse\r\nstatusbit = IPS_DST_NAT;\r\nif (dir == IP_CT_DIR_REPLY)\r\nstatusbit ^= IPS_NAT_MASK;\r\nif (!(ct->status & statusbit))\r\nreturn 1;\r\nl4proto = __nf_nat_l4proto_find(NFPROTO_IPV4, inside->ip.protocol);\r\nif (!nf_nat_ipv4_manip_pkt(skb, hdrlen + sizeof(inside->icmp),\r\nl4proto, &ct->tuplehash[!dir].tuple, !manip))\r\nreturn 0;\r\nif (skb->ip_summed != CHECKSUM_PARTIAL) {\r\ninside = (void *)skb->data + hdrlen;\r\ninside->icmp.checksum = 0;\r\ninside->icmp.checksum =\r\ncsum_fold(skb_checksum(skb, hdrlen,\r\nskb->len - hdrlen, 0));\r\n}\r\nnf_ct_invert_tuplepr(&target, &ct->tuplehash[!dir].tuple);\r\nl4proto = __nf_nat_l4proto_find(NFPROTO_IPV4, 0);\r\nif (!nf_nat_ipv4_manip_pkt(skb, 0, l4proto, &target, manip))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int __init nf_nat_l3proto_ipv4_init(void)\r\n{\r\nint err;\r\nerr = nf_nat_l4proto_register(NFPROTO_IPV4, &nf_nat_l4proto_icmp);\r\nif (err < 0)\r\ngoto err1;\r\nerr = nf_nat_l3proto_register(&nf_nat_l3proto_ipv4);\r\nif (err < 0)\r\ngoto err2;\r\nreturn err;\r\nerr2:\r\nnf_nat_l4proto_unregister(NFPROTO_IPV4, &nf_nat_l4proto_icmp);\r\nerr1:\r\nreturn err;\r\n}\r\nstatic void __exit nf_nat_l3proto_ipv4_exit(void)\r\n{\r\nnf_nat_l3proto_unregister(&nf_nat_l3proto_ipv4);\r\nnf_nat_l4proto_unregister(NFPROTO_IPV4, &nf_nat_l4proto_icmp);\r\n}
