static unsigned char read_zsreg(struct zilog_channel *channel,\r\nunsigned char reg)\r\n{\r\nunsigned char retval;\r\nwriteb(reg, &channel->control);\r\nZSDELAY();\r\nretval = readb(&channel->control);\r\nZSDELAY();\r\nreturn retval;\r\n}\r\nstatic void write_zsreg(struct zilog_channel *channel,\r\nunsigned char reg, unsigned char value)\r\n{\r\nwriteb(reg, &channel->control);\r\nZSDELAY();\r\nwriteb(value, &channel->control);\r\nZSDELAY();\r\n}\r\nstatic void ip22zilog_clear_fifo(struct zilog_channel *channel)\r\n{\r\nint i;\r\nfor (i = 0; i < 32; i++) {\r\nunsigned char regval;\r\nregval = readb(&channel->control);\r\nZSDELAY();\r\nif (regval & Rx_CH_AV)\r\nbreak;\r\nregval = read_zsreg(channel, R1);\r\nreadb(&channel->data);\r\nZSDELAY();\r\nif (regval & (PAR_ERR | Rx_OVR | CRC_ERR)) {\r\nwriteb(ERR_RES, &channel->control);\r\nZSDELAY();\r\nZS_WSYNC(channel);\r\n}\r\n}\r\n}\r\nstatic void __load_zsregs(struct zilog_channel *channel, unsigned char *regs)\r\n{\r\nint i;\r\nfor (i = 0; i < 1000; i++) {\r\nunsigned char stat = read_zsreg(channel, R1);\r\nif (stat & ALL_SNT)\r\nbreak;\r\nudelay(100);\r\n}\r\nwriteb(ERR_RES, &channel->control);\r\nZSDELAY();\r\nZS_WSYNC(channel);\r\nip22zilog_clear_fifo(channel);\r\nwrite_zsreg(channel, R1,\r\nregs[R1] & ~(RxINT_MASK | TxINT_ENAB | EXT_INT_ENAB));\r\nwrite_zsreg(channel, R4, regs[R4]);\r\nwrite_zsreg(channel, R10, regs[R10]);\r\nwrite_zsreg(channel, R3, regs[R3] & ~RxENAB);\r\nwrite_zsreg(channel, R5, regs[R5] & ~TxENAB);\r\nwrite_zsreg(channel, R6, regs[R6]);\r\nwrite_zsreg(channel, R7, regs[R7]);\r\nwrite_zsreg(channel, R14, regs[R14] & ~BRENAB);\r\nwrite_zsreg(channel, R11, regs[R11]);\r\nwrite_zsreg(channel, R12, regs[R12]);\r\nwrite_zsreg(channel, R13, regs[R13]);\r\nwrite_zsreg(channel, R14, regs[R14]);\r\nwrite_zsreg(channel, R15, regs[R15]);\r\nwrite_zsreg(channel, R0, RES_EXT_INT);\r\nwrite_zsreg(channel, R0, RES_EXT_INT);\r\nwrite_zsreg(channel, R3, regs[R3]);\r\nwrite_zsreg(channel, R5, regs[R5]);\r\nwrite_zsreg(channel, R1, regs[R1]);\r\n}\r\nstatic void ip22zilog_maybe_update_regs(struct uart_ip22zilog_port *up,\r\nstruct zilog_channel *channel)\r\n{\r\nif (!ZS_REGS_HELD(up)) {\r\nif (ZS_TX_ACTIVE(up)) {\r\nup->flags |= IP22ZILOG_FLAG_REGS_HELD;\r\n} else {\r\n__load_zsregs(channel, up->curregs);\r\n}\r\n}\r\n}\r\nstatic bool ip22zilog_receive_chars(struct uart_ip22zilog_port *up,\r\nstruct zilog_channel *channel)\r\n{\r\nunsigned char ch, flag;\r\nunsigned int r1;\r\nbool push = up->port.state != NULL;\r\nfor (;;) {\r\nch = readb(&channel->control);\r\nZSDELAY();\r\nif (!(ch & Rx_CH_AV))\r\nbreak;\r\nr1 = read_zsreg(channel, R1);\r\nif (r1 & (PAR_ERR | Rx_OVR | CRC_ERR)) {\r\nwriteb(ERR_RES, &channel->control);\r\nZSDELAY();\r\nZS_WSYNC(channel);\r\n}\r\nch = readb(&channel->data);\r\nZSDELAY();\r\nch &= up->parity_mask;\r\nif (!ch)\r\nr1 |= up->tty_break;\r\nflag = TTY_NORMAL;\r\nup->port.icount.rx++;\r\nif (r1 & (PAR_ERR | Rx_OVR | CRC_ERR | Rx_SYS | Rx_BRK)) {\r\nup->tty_break = 0;\r\nif (r1 & (Rx_SYS | Rx_BRK)) {\r\nup->port.icount.brk++;\r\nif (r1 & Rx_SYS)\r\ncontinue;\r\nr1 &= ~(PAR_ERR | CRC_ERR);\r\n}\r\nelse if (r1 & PAR_ERR)\r\nup->port.icount.parity++;\r\nelse if (r1 & CRC_ERR)\r\nup->port.icount.frame++;\r\nif (r1 & Rx_OVR)\r\nup->port.icount.overrun++;\r\nr1 &= up->port.read_status_mask;\r\nif (r1 & Rx_BRK)\r\nflag = TTY_BREAK;\r\nelse if (r1 & PAR_ERR)\r\nflag = TTY_PARITY;\r\nelse if (r1 & CRC_ERR)\r\nflag = TTY_FRAME;\r\n}\r\nif (uart_handle_sysrq_char(&up->port, ch))\r\ncontinue;\r\nif (push)\r\nuart_insert_char(&up->port, r1, Rx_OVR, ch, flag);\r\n}\r\nreturn push;\r\n}\r\nstatic void ip22zilog_status_handle(struct uart_ip22zilog_port *up,\r\nstruct zilog_channel *channel)\r\n{\r\nunsigned char status;\r\nstatus = readb(&channel->control);\r\nZSDELAY();\r\nwriteb(RES_EXT_INT, &channel->control);\r\nZSDELAY();\r\nZS_WSYNC(channel);\r\nif (up->curregs[R15] & BRKIE) {\r\nif ((status & BRK_ABRT) && !(up->prev_status & BRK_ABRT)) {\r\nif (uart_handle_break(&up->port))\r\nup->tty_break = Rx_SYS;\r\nelse\r\nup->tty_break = Rx_BRK;\r\n}\r\n}\r\nif (ZS_WANTS_MODEM_STATUS(up)) {\r\nif (status & SYNC)\r\nup->port.icount.dsr++;\r\nif ((status ^ up->prev_status) ^ DCD)\r\nuart_handle_dcd_change(&up->port,\r\n(status & DCD));\r\nif ((status ^ up->prev_status) ^ CTS)\r\nuart_handle_cts_change(&up->port,\r\n(status & CTS));\r\nwake_up_interruptible(&up->port.state->port.delta_msr_wait);\r\n}\r\nup->prev_status = status;\r\n}\r\nstatic void ip22zilog_transmit_chars(struct uart_ip22zilog_port *up,\r\nstruct zilog_channel *channel)\r\n{\r\nstruct circ_buf *xmit;\r\nif (ZS_IS_CONS(up)) {\r\nunsigned char status = readb(&channel->control);\r\nZSDELAY();\r\nif (!(status & Tx_BUF_EMP))\r\nreturn;\r\n}\r\nup->flags &= ~IP22ZILOG_FLAG_TX_ACTIVE;\r\nif (ZS_REGS_HELD(up)) {\r\n__load_zsregs(channel, up->curregs);\r\nup->flags &= ~IP22ZILOG_FLAG_REGS_HELD;\r\n}\r\nif (ZS_TX_STOPPED(up)) {\r\nup->flags &= ~IP22ZILOG_FLAG_TX_STOPPED;\r\ngoto ack_tx_int;\r\n}\r\nif (up->port.x_char) {\r\nup->flags |= IP22ZILOG_FLAG_TX_ACTIVE;\r\nwriteb(up->port.x_char, &channel->data);\r\nZSDELAY();\r\nZS_WSYNC(channel);\r\nup->port.icount.tx++;\r\nup->port.x_char = 0;\r\nreturn;\r\n}\r\nif (up->port.state == NULL)\r\ngoto ack_tx_int;\r\nxmit = &up->port.state->xmit;\r\nif (uart_circ_empty(xmit))\r\ngoto ack_tx_int;\r\nif (uart_tx_stopped(&up->port))\r\ngoto ack_tx_int;\r\nup->flags |= IP22ZILOG_FLAG_TX_ACTIVE;\r\nwriteb(xmit->buf[xmit->tail], &channel->data);\r\nZSDELAY();\r\nZS_WSYNC(channel);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nup->port.icount.tx++;\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&up->port);\r\nreturn;\r\nack_tx_int:\r\nwriteb(RES_Tx_P, &channel->control);\r\nZSDELAY();\r\nZS_WSYNC(channel);\r\n}\r\nstatic irqreturn_t ip22zilog_interrupt(int irq, void *dev_id)\r\n{\r\nstruct uart_ip22zilog_port *up = dev_id;\r\nwhile (up) {\r\nstruct zilog_channel *channel\r\n= ZILOG_CHANNEL_FROM_PORT(&up->port);\r\nunsigned char r3;\r\nbool push = false;\r\nspin_lock(&up->port.lock);\r\nr3 = read_zsreg(channel, R3);\r\nif (r3 & (CHAEXT | CHATxIP | CHARxIP)) {\r\nwriteb(RES_H_IUS, &channel->control);\r\nZSDELAY();\r\nZS_WSYNC(channel);\r\nif (r3 & CHARxIP)\r\npush = ip22zilog_receive_chars(up, channel);\r\nif (r3 & CHAEXT)\r\nip22zilog_status_handle(up, channel);\r\nif (r3 & CHATxIP)\r\nip22zilog_transmit_chars(up, channel);\r\n}\r\nspin_unlock(&up->port.lock);\r\nif (push)\r\ntty_flip_buffer_push(&up->port.state->port);\r\nup = up->next;\r\nchannel = ZILOG_CHANNEL_FROM_PORT(&up->port);\r\npush = false;\r\nspin_lock(&up->port.lock);\r\nif (r3 & (CHBEXT | CHBTxIP | CHBRxIP)) {\r\nwriteb(RES_H_IUS, &channel->control);\r\nZSDELAY();\r\nZS_WSYNC(channel);\r\nif (r3 & CHBRxIP)\r\npush = ip22zilog_receive_chars(up, channel);\r\nif (r3 & CHBEXT)\r\nip22zilog_status_handle(up, channel);\r\nif (r3 & CHBTxIP)\r\nip22zilog_transmit_chars(up, channel);\r\n}\r\nspin_unlock(&up->port.lock);\r\nif (push)\r\ntty_flip_buffer_push(&up->port.state->port);\r\nup = up->next;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic __inline__ unsigned char ip22zilog_read_channel_status(struct uart_port *port)\r\n{\r\nstruct zilog_channel *channel;\r\nunsigned char status;\r\nchannel = ZILOG_CHANNEL_FROM_PORT(port);\r\nstatus = readb(&channel->control);\r\nZSDELAY();\r\nreturn status;\r\n}\r\nstatic unsigned int ip22zilog_tx_empty(struct uart_port *port)\r\n{\r\nunsigned long flags;\r\nunsigned char status;\r\nunsigned int ret;\r\nspin_lock_irqsave(&port->lock, flags);\r\nstatus = ip22zilog_read_channel_status(port);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nif (status & Tx_BUF_EMP)\r\nret = TIOCSER_TEMT;\r\nelse\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic unsigned int ip22zilog_get_mctrl(struct uart_port *port)\r\n{\r\nunsigned char status;\r\nunsigned int ret;\r\nstatus = ip22zilog_read_channel_status(port);\r\nret = 0;\r\nif (status & DCD)\r\nret |= TIOCM_CAR;\r\nif (status & SYNC)\r\nret |= TIOCM_DSR;\r\nif (status & CTS)\r\nret |= TIOCM_CTS;\r\nreturn ret;\r\n}\r\nstatic void ip22zilog_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct uart_ip22zilog_port *up =\r\ncontainer_of(port, struct uart_ip22zilog_port, port);\r\nstruct zilog_channel *channel = ZILOG_CHANNEL_FROM_PORT(port);\r\nunsigned char set_bits, clear_bits;\r\nset_bits = clear_bits = 0;\r\nif (mctrl & TIOCM_RTS)\r\nset_bits |= RTS;\r\nelse\r\nclear_bits |= RTS;\r\nif (mctrl & TIOCM_DTR)\r\nset_bits |= DTR;\r\nelse\r\nclear_bits |= DTR;\r\nup->curregs[R5] |= set_bits;\r\nup->curregs[R5] &= ~clear_bits;\r\nwrite_zsreg(channel, R5, up->curregs[R5]);\r\n}\r\nstatic void ip22zilog_stop_tx(struct uart_port *port)\r\n{\r\nstruct uart_ip22zilog_port *up =\r\ncontainer_of(port, struct uart_ip22zilog_port, port);\r\nup->flags |= IP22ZILOG_FLAG_TX_STOPPED;\r\n}\r\nstatic void ip22zilog_start_tx(struct uart_port *port)\r\n{\r\nstruct uart_ip22zilog_port *up =\r\ncontainer_of(port, struct uart_ip22zilog_port, port);\r\nstruct zilog_channel *channel = ZILOG_CHANNEL_FROM_PORT(port);\r\nunsigned char status;\r\nup->flags |= IP22ZILOG_FLAG_TX_ACTIVE;\r\nup->flags &= ~IP22ZILOG_FLAG_TX_STOPPED;\r\nstatus = readb(&channel->control);\r\nZSDELAY();\r\nif (!(status & Tx_BUF_EMP))\r\nreturn;\r\nif (port->x_char) {\r\nwriteb(port->x_char, &channel->data);\r\nZSDELAY();\r\nZS_WSYNC(channel);\r\nport->icount.tx++;\r\nport->x_char = 0;\r\n} else {\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nif (uart_circ_empty(xmit))\r\nreturn;\r\nwriteb(xmit->buf[xmit->tail], &channel->data);\r\nZSDELAY();\r\nZS_WSYNC(channel);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&up->port);\r\n}\r\n}\r\nstatic void ip22zilog_stop_rx(struct uart_port *port)\r\n{\r\nstruct uart_ip22zilog_port *up = UART_ZILOG(port);\r\nstruct zilog_channel *channel;\r\nif (ZS_IS_CONS(up))\r\nreturn;\r\nchannel = ZILOG_CHANNEL_FROM_PORT(port);\r\nup->curregs[R1] &= ~RxINT_MASK;\r\nip22zilog_maybe_update_regs(up, channel);\r\n}\r\nstatic void ip22zilog_enable_ms(struct uart_port *port)\r\n{\r\nstruct uart_ip22zilog_port *up =\r\ncontainer_of(port, struct uart_ip22zilog_port, port);\r\nstruct zilog_channel *channel = ZILOG_CHANNEL_FROM_PORT(port);\r\nunsigned char new_reg;\r\nnew_reg = up->curregs[R15] | (DCDIE | SYNCIE | CTSIE);\r\nif (new_reg != up->curregs[R15]) {\r\nup->curregs[R15] = new_reg;\r\nwrite_zsreg(channel, R15, up->curregs[R15]);\r\n}\r\n}\r\nstatic void ip22zilog_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nstruct uart_ip22zilog_port *up =\r\ncontainer_of(port, struct uart_ip22zilog_port, port);\r\nstruct zilog_channel *channel = ZILOG_CHANNEL_FROM_PORT(port);\r\nunsigned char set_bits, clear_bits, new_reg;\r\nunsigned long flags;\r\nset_bits = clear_bits = 0;\r\nif (break_state)\r\nset_bits |= SND_BRK;\r\nelse\r\nclear_bits |= SND_BRK;\r\nspin_lock_irqsave(&port->lock, flags);\r\nnew_reg = (up->curregs[R5] | set_bits) & ~clear_bits;\r\nif (new_reg != up->curregs[R5]) {\r\nup->curregs[R5] = new_reg;\r\nwrite_zsreg(channel, R5, up->curregs[R5]);\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void __ip22zilog_reset(struct uart_ip22zilog_port *up)\r\n{\r\nstruct zilog_channel *channel;\r\nint i;\r\nif (up->flags & IP22ZILOG_FLAG_RESET_DONE)\r\nreturn;\r\nchannel = ZILOG_CHANNEL_FROM_PORT(&up->port);\r\nfor (i = 0; i < 1000; i++) {\r\nunsigned char stat = read_zsreg(channel, R1);\r\nif (stat & ALL_SNT)\r\nbreak;\r\nudelay(100);\r\n}\r\nif (!ZS_IS_CHANNEL_A(up)) {\r\nup++;\r\nchannel = ZILOG_CHANNEL_FROM_PORT(&up->port);\r\n}\r\nwrite_zsreg(channel, R9, FHWRES);\r\nZSDELAY_LONG();\r\n(void) read_zsreg(channel, R0);\r\nup->flags |= IP22ZILOG_FLAG_RESET_DONE;\r\nup->next->flags |= IP22ZILOG_FLAG_RESET_DONE;\r\n}\r\nstatic void __ip22zilog_startup(struct uart_ip22zilog_port *up)\r\n{\r\nstruct zilog_channel *channel;\r\nchannel = ZILOG_CHANNEL_FROM_PORT(&up->port);\r\n__ip22zilog_reset(up);\r\n__load_zsregs(channel, up->curregs);\r\nwrite_zsreg(channel, R9, up->curregs[R9]);\r\nup->prev_status = readb(&channel->control);\r\nup->curregs[R3] |= RxENAB;\r\nup->curregs[R5] |= TxENAB;\r\nup->curregs[R1] |= EXT_INT_ENAB | INT_ALL_Rx | TxINT_ENAB;\r\nip22zilog_maybe_update_regs(up, channel);\r\n}\r\nstatic int ip22zilog_startup(struct uart_port *port)\r\n{\r\nstruct uart_ip22zilog_port *up = UART_ZILOG(port);\r\nunsigned long flags;\r\nif (ZS_IS_CONS(up))\r\nreturn 0;\r\nspin_lock_irqsave(&port->lock, flags);\r\n__ip22zilog_startup(up);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void ip22zilog_shutdown(struct uart_port *port)\r\n{\r\nstruct uart_ip22zilog_port *up = UART_ZILOG(port);\r\nstruct zilog_channel *channel;\r\nunsigned long flags;\r\nif (ZS_IS_CONS(up))\r\nreturn;\r\nspin_lock_irqsave(&port->lock, flags);\r\nchannel = ZILOG_CHANNEL_FROM_PORT(port);\r\nup->curregs[R3] &= ~RxENAB;\r\nup->curregs[R5] &= ~TxENAB;\r\nup->curregs[R1] &= ~(EXT_INT_ENAB | TxINT_ENAB | RxINT_MASK);\r\nup->curregs[R5] &= ~SND_BRK;\r\nip22zilog_maybe_update_regs(up, channel);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void\r\nip22zilog_convert_to_zs(struct uart_ip22zilog_port *up, unsigned int cflag,\r\nunsigned int iflag, int brg)\r\n{\r\nup->curregs[R10] = NRZ;\r\nup->curregs[R11] = TCBR | RCBR;\r\nup->curregs[R4] &= ~XCLK_MASK;\r\nup->curregs[R4] |= X16CLK;\r\nup->curregs[R12] = brg & 0xff;\r\nup->curregs[R13] = (brg >> 8) & 0xff;\r\nup->curregs[R14] = BRENAB;\r\nup->curregs[3] &= ~RxN_MASK;\r\nup->curregs[5] &= ~TxN_MASK;\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\nup->curregs[3] |= Rx5;\r\nup->curregs[5] |= Tx5;\r\nup->parity_mask = 0x1f;\r\nbreak;\r\ncase CS6:\r\nup->curregs[3] |= Rx6;\r\nup->curregs[5] |= Tx6;\r\nup->parity_mask = 0x3f;\r\nbreak;\r\ncase CS7:\r\nup->curregs[3] |= Rx7;\r\nup->curregs[5] |= Tx7;\r\nup->parity_mask = 0x7f;\r\nbreak;\r\ncase CS8:\r\ndefault:\r\nup->curregs[3] |= Rx8;\r\nup->curregs[5] |= Tx8;\r\nup->parity_mask = 0xff;\r\nbreak;\r\n}\r\nup->curregs[4] &= ~0x0c;\r\nif (cflag & CSTOPB)\r\nup->curregs[4] |= SB2;\r\nelse\r\nup->curregs[4] |= SB1;\r\nif (cflag & PARENB)\r\nup->curregs[4] |= PAR_ENAB;\r\nelse\r\nup->curregs[4] &= ~PAR_ENAB;\r\nif (!(cflag & PARODD))\r\nup->curregs[4] |= PAR_EVEN;\r\nelse\r\nup->curregs[4] &= ~PAR_EVEN;\r\nup->port.read_status_mask = Rx_OVR;\r\nif (iflag & INPCK)\r\nup->port.read_status_mask |= CRC_ERR | PAR_ERR;\r\nif (iflag & (IGNBRK | BRKINT | PARMRK))\r\nup->port.read_status_mask |= BRK_ABRT;\r\nup->port.ignore_status_mask = 0;\r\nif (iflag & IGNPAR)\r\nup->port.ignore_status_mask |= CRC_ERR | PAR_ERR;\r\nif (iflag & IGNBRK) {\r\nup->port.ignore_status_mask |= BRK_ABRT;\r\nif (iflag & IGNPAR)\r\nup->port.ignore_status_mask |= Rx_OVR;\r\n}\r\nif ((cflag & CREAD) == 0)\r\nup->port.ignore_status_mask = 0xff;\r\n}\r\nstatic void\r\nip22zilog_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct uart_ip22zilog_port *up =\r\ncontainer_of(port, struct uart_ip22zilog_port, port);\r\nunsigned long flags;\r\nint baud, brg;\r\nbaud = uart_get_baud_rate(port, termios, old, 1200, 76800);\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nbrg = BPS_TO_BRG(baud, ZS_CLOCK / ZS_CLOCK_DIVISOR);\r\nip22zilog_convert_to_zs(up, termios->c_cflag, termios->c_iflag, brg);\r\nif (UART_ENABLE_MS(&up->port, termios->c_cflag))\r\nup->flags |= IP22ZILOG_FLAG_MODEM_STATUS;\r\nelse\r\nup->flags &= ~IP22ZILOG_FLAG_MODEM_STATUS;\r\nip22zilog_maybe_update_regs(up, ZILOG_CHANNEL_FROM_PORT(port));\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\n}\r\nstatic const char *ip22zilog_type(struct uart_port *port)\r\n{\r\nreturn "IP22-Zilog";\r\n}\r\nstatic void ip22zilog_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int ip22zilog_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void ip22zilog_config_port(struct uart_port *port, int flags)\r\n{\r\n}\r\nstatic int ip22zilog_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic void * __init alloc_one_table(unsigned long size)\r\n{\r\nreturn kzalloc(size, GFP_KERNEL);\r\n}\r\nstatic void __init ip22zilog_alloc_tables(void)\r\n{\r\nip22zilog_port_table = (struct uart_ip22zilog_port *)\r\nalloc_one_table(NUM_CHANNELS * sizeof(struct uart_ip22zilog_port));\r\nip22zilog_chip_regs = (struct zilog_layout **)\r\nalloc_one_table(NUM_IP22ZILOG * sizeof(struct zilog_layout *));\r\nif (ip22zilog_port_table == NULL || ip22zilog_chip_regs == NULL) {\r\npanic("IP22-Zilog: Cannot allocate IP22-Zilog tables.");\r\n}\r\n}\r\nstatic struct zilog_layout * __init get_zs(int chip)\r\n{\r\nunsigned long base;\r\nif (chip < 0 || chip >= NUM_IP22ZILOG) {\r\npanic("IP22-Zilog: Illegal chip number %d in get_zs.", chip);\r\n}\r\nbase = (unsigned long) &sgioc->uart;\r\nzilog_irq = SGI_SERIAL_IRQ;\r\nrequest_mem_region(base, 8, "IP22-Zilog");\r\nreturn (struct zilog_layout *) base;\r\n}\r\nstatic void ip22zilog_put_char(struct uart_port *port, int ch)\r\n{\r\nstruct zilog_channel *channel = ZILOG_CHANNEL_FROM_PORT(port);\r\nint loops = ZS_PUT_CHAR_MAX_DELAY;\r\ndo {\r\nunsigned char val = readb(&channel->control);\r\nif (val & Tx_BUF_EMP) {\r\nZSDELAY();\r\nbreak;\r\n}\r\nudelay(5);\r\n} while (--loops);\r\nwriteb(ch, &channel->data);\r\nZSDELAY();\r\nZS_WSYNC(channel);\r\n}\r\nstatic void\r\nip22zilog_console_write(struct console *con, const char *s, unsigned int count)\r\n{\r\nstruct uart_ip22zilog_port *up = &ip22zilog_port_table[con->index];\r\nunsigned long flags;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nuart_console_write(&up->port, s, count, ip22zilog_put_char);\r\nudelay(2);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\n}\r\nstatic int __init ip22zilog_console_setup(struct console *con, char *options)\r\n{\r\nstruct uart_ip22zilog_port *up = &ip22zilog_port_table[con->index];\r\nunsigned long flags;\r\nint baud = 9600, bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nup->flags |= IP22ZILOG_FLAG_IS_CONS;\r\nprintk(KERN_INFO "Console: ttyS%d (IP22-Zilog)\n", con->index);\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nup->curregs[R15] |= BRKIE;\r\n__ip22zilog_startup(up);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(&up->port, con, baud, parity, bits, flow);\r\n}\r\nstatic void __init ip22zilog_prepare(void)\r\n{\r\nstruct uart_ip22zilog_port *up;\r\nstruct zilog_layout *rp;\r\nint channel, chip;\r\nfor (channel = 0; channel < NUM_CHANNELS; channel++)\r\nspin_lock_init(&ip22zilog_port_table[channel].port.lock);\r\nip22zilog_irq_chain = &ip22zilog_port_table[NUM_CHANNELS - 1];\r\nup = &ip22zilog_port_table[0];\r\nfor (channel = NUM_CHANNELS - 1 ; channel > 0; channel--)\r\nup[channel].next = &up[channel - 1];\r\nup[channel].next = NULL;\r\nfor (chip = 0; chip < NUM_IP22ZILOG; chip++) {\r\nif (!ip22zilog_chip_regs[chip]) {\r\nip22zilog_chip_regs[chip] = rp = get_zs(chip);\r\nup[(chip * 2) + 0].port.membase = (char *) &rp->channelB;\r\nup[(chip * 2) + 1].port.membase = (char *) &rp->channelA;\r\nup[(chip * 2) + 0].port.mapbase =\r\n(unsigned long) ioremap((unsigned long) &rp->channelB, 8);\r\nup[(chip * 2) + 1].port.mapbase =\r\n(unsigned long) ioremap((unsigned long) &rp->channelA, 8);\r\n}\r\nup[(chip * 2) + 0].port.iotype = UPIO_MEM;\r\nup[(chip * 2) + 0].port.irq = zilog_irq;\r\nup[(chip * 2) + 0].port.uartclk = ZS_CLOCK;\r\nup[(chip * 2) + 0].port.fifosize = 1;\r\nup[(chip * 2) + 0].port.ops = &ip22zilog_pops;\r\nup[(chip * 2) + 0].port.type = PORT_IP22ZILOG;\r\nup[(chip * 2) + 0].port.flags = 0;\r\nup[(chip * 2) + 0].port.line = (chip * 2) + 0;\r\nup[(chip * 2) + 0].flags = 0;\r\nup[(chip * 2) + 1].port.iotype = UPIO_MEM;\r\nup[(chip * 2) + 1].port.irq = zilog_irq;\r\nup[(chip * 2) + 1].port.uartclk = ZS_CLOCK;\r\nup[(chip * 2) + 1].port.fifosize = 1;\r\nup[(chip * 2) + 1].port.ops = &ip22zilog_pops;\r\nup[(chip * 2) + 1].port.type = PORT_IP22ZILOG;\r\nup[(chip * 2) + 1].port.line = (chip * 2) + 1;\r\nup[(chip * 2) + 1].flags |= IP22ZILOG_FLAG_IS_CHANNEL_A;\r\n}\r\nfor (channel = 0; channel < NUM_CHANNELS; channel++) {\r\nstruct uart_ip22zilog_port *up = &ip22zilog_port_table[channel];\r\nint brg;\r\nup->parity_mask = 0xff;\r\nup->curregs[R1] = EXT_INT_ENAB | INT_ALL_Rx | TxINT_ENAB;\r\nup->curregs[R4] = PAR_EVEN | X16CLK | SB1;\r\nup->curregs[R3] = RxENAB | Rx8;\r\nup->curregs[R5] = TxENAB | Tx8;\r\nup->curregs[R9] = NV | MIE;\r\nup->curregs[R10] = NRZ;\r\nup->curregs[R11] = TCBR | RCBR;\r\nbrg = BPS_TO_BRG(9600, ZS_CLOCK / ZS_CLOCK_DIVISOR);\r\nup->curregs[R12] = (brg & 0xff);\r\nup->curregs[R13] = (brg >> 8) & 0xff;\r\nup->curregs[R14] = BRENAB;\r\n}\r\n}\r\nstatic int __init ip22zilog_ports_init(void)\r\n{\r\nint ret;\r\nprintk(KERN_INFO "Serial: IP22 Zilog driver (%d chips).\n", NUM_IP22ZILOG);\r\nip22zilog_prepare();\r\nif (request_irq(zilog_irq, ip22zilog_interrupt, 0,\r\n"IP22-Zilog", ip22zilog_irq_chain)) {\r\npanic("IP22-Zilog: Unable to register zs interrupt handler.\n");\r\n}\r\nret = uart_register_driver(&ip22zilog_reg);\r\nif (ret == 0) {\r\nint i;\r\nfor (i = 0; i < NUM_CHANNELS; i++) {\r\nstruct uart_ip22zilog_port *up = &ip22zilog_port_table[i];\r\nuart_add_one_port(&ip22zilog_reg, &up->port);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init ip22zilog_init(void)\r\n{\r\nip22zilog_alloc_tables();\r\nip22zilog_ports_init();\r\nreturn 0;\r\n}\r\nstatic void __exit ip22zilog_exit(void)\r\n{\r\nint i;\r\nstruct uart_ip22zilog_port *up;\r\nfor (i = 0; i < NUM_CHANNELS; i++) {\r\nup = &ip22zilog_port_table[i];\r\nuart_remove_one_port(&ip22zilog_reg, &up->port);\r\n}\r\nup = &ip22zilog_port_table[0];\r\nfor (i = 0; i < NUM_IP22ZILOG; i++) {\r\nif (up[(i * 2) + 0].port.mapbase) {\r\niounmap((void*)up[(i * 2) + 0].port.mapbase);\r\nup[(i * 2) + 0].port.mapbase = 0;\r\n}\r\nif (up[(i * 2) + 1].port.mapbase) {\r\niounmap((void*)up[(i * 2) + 1].port.mapbase);\r\nup[(i * 2) + 1].port.mapbase = 0;\r\n}\r\n}\r\nuart_unregister_driver(&ip22zilog_reg);\r\n}
