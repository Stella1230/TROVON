static unsigned short sk_isa_sifreadb(struct net_device *dev, unsigned short reg)\r\n{\r\nreturn inb(dev->base_addr + reg);\r\n}\r\nstatic unsigned short sk_isa_sifreadw(struct net_device *dev, unsigned short reg)\r\n{\r\nreturn inw(dev->base_addr + reg);\r\n}\r\nstatic void sk_isa_sifwriteb(struct net_device *dev, unsigned short val, unsigned short reg)\r\n{\r\noutb(val, dev->base_addr + reg);\r\n}\r\nstatic void sk_isa_sifwritew(struct net_device *dev, unsigned short val, unsigned short reg)\r\n{\r\noutw(val, dev->base_addr + reg);\r\n}\r\nstatic int __init sk_isa_probe1(struct net_device *dev, int ioaddr)\r\n{\r\nunsigned char old, chk1, chk2;\r\nif (!request_region(ioaddr, SK_ISA_IO_EXTENT, isa_cardname))\r\nreturn -ENODEV;\r\nold = inb(ioaddr + SIFADR);\r\nchk1 = 0;\r\ndo {\r\noutb(chk1, ioaddr + SIFADR);\r\nchk2 = inb(ioaddr + SIFADD);\r\nchk2 ^= 0x0FE;\r\noutb(chk2, ioaddr + SIFADR);\r\nchk2 = inb(ioaddr + SIFADD);\r\nchk2 ^= 0x0FE;\r\nif(chk1 != chk2) {\r\nrelease_region(ioaddr, SK_ISA_IO_EXTENT);\r\nreturn -ENODEV;\r\n}\r\nchk1 -= 2;\r\n} while(chk1 != 0);\r\noutb(old, ioaddr + SIFADR);\r\ndev->base_addr = ioaddr;\r\nreturn 0;\r\n}\r\nstatic int __init setup_card(struct net_device *dev, struct device *pdev)\r\n{\r\nstruct net_local *tp;\r\nstatic int versionprinted;\r\nconst unsigned *port;\r\nint j, err = 0;\r\nif (!dev)\r\nreturn -ENOMEM;\r\nif (dev->base_addr)\r\nerr = sk_isa_probe1(dev, dev->base_addr);\r\nelse {\r\nfor (port = portlist; *port; port++) {\r\nerr = sk_isa_probe1(dev, *port);\r\nif (!err)\r\nbreak;\r\n}\r\n}\r\nif (err)\r\ngoto out5;\r\nif (versionprinted++ == 0)\r\nprintk(KERN_DEBUG "%s", version);\r\nerr = -EIO;\r\npdev->dma_mask = &dma_mask;\r\nif (tmsdev_init(dev, pdev))\r\ngoto out4;\r\ndev->base_addr &= ~3;\r\nsk_isa_read_eeprom(dev);\r\nprintk(KERN_DEBUG "skisa.c: Ring Station Address: %pM\n",\r\ndev->dev_addr);\r\ntp = netdev_priv(dev);\r\ntp->setnselout = sk_isa_setnselout_pins;\r\ntp->sifreadb = sk_isa_sifreadb;\r\ntp->sifreadw = sk_isa_sifreadw;\r\ntp->sifwriteb = sk_isa_sifwriteb;\r\ntp->sifwritew = sk_isa_sifwritew;\r\nmemcpy(tp->ProductID, isa_cardname, PROD_ID_SIZE + 1);\r\ntp->tmspriv = NULL;\r\ndev->netdev_ops = &sk_isa_netdev_ops;\r\nif (dev->irq == 0)\r\n{\r\nfor(j = 0; irqlist[j] != 0; j++)\r\n{\r\ndev->irq = irqlist[j];\r\nif (!request_irq(dev->irq, tms380tr_interrupt, 0,\r\nisa_cardname, dev))\r\nbreak;\r\n}\r\nif(irqlist[j] == 0)\r\n{\r\nprintk(KERN_INFO "skisa.c: AutoSelect no IRQ available\n");\r\ngoto out3;\r\n}\r\n}\r\nelse\r\n{\r\nfor(j = 0; irqlist[j] != 0; j++)\r\nif (irqlist[j] == dev->irq)\r\nbreak;\r\nif (irqlist[j] == 0)\r\n{\r\nprintk(KERN_INFO "skisa.c: Illegal IRQ %d specified\n",\r\ndev->irq);\r\ngoto out3;\r\n}\r\nif (request_irq(dev->irq, tms380tr_interrupt, 0,\r\nisa_cardname, dev))\r\n{\r\nprintk(KERN_INFO "skisa.c: Selected IRQ %d not available\n",\r\ndev->irq);\r\ngoto out3;\r\n}\r\n}\r\nif (dev->dma == 0)\r\n{\r\nfor(j = 0; dmalist[j] != 0; j++)\r\n{\r\ndev->dma = dmalist[j];\r\nif (!request_dma(dev->dma, isa_cardname))\r\nbreak;\r\n}\r\nif(dmalist[j] == 0)\r\n{\r\nprintk(KERN_INFO "skisa.c: AutoSelect no DMA available\n");\r\ngoto out2;\r\n}\r\n}\r\nelse\r\n{\r\nfor(j = 0; dmalist[j] != 0; j++)\r\nif (dmalist[j] == dev->dma)\r\nbreak;\r\nif (dmalist[j] == 0)\r\n{\r\nprintk(KERN_INFO "skisa.c: Illegal DMA %d specified\n",\r\ndev->dma);\r\ngoto out2;\r\n}\r\nif (request_dma(dev->dma, isa_cardname))\r\n{\r\nprintk(KERN_INFO "skisa.c: Selected DMA %d not available\n",\r\ndev->dma);\r\ngoto out2;\r\n}\r\n}\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto out;\r\nprintk(KERN_DEBUG "%s: IO: %#4lx IRQ: %d DMA: %d\n",\r\ndev->name, dev->base_addr, dev->irq, dev->dma);\r\nreturn 0;\r\nout:\r\nfree_dma(dev->dma);\r\nout2:\r\nfree_irq(dev->irq, dev);\r\nout3:\r\ntmsdev_term(dev);\r\nout4:\r\nrelease_region(dev->base_addr, SK_ISA_IO_EXTENT);\r\nout5:\r\nreturn err;\r\n}\r\nstatic void sk_isa_read_eeprom(struct net_device *dev)\r\n{\r\nint i;\r\nsk_isa_sifwritew(dev, 0, SIFADX);\r\nsk_isa_sifwritew(dev, 0, SIFADR);\r\ndev->addr_len = 6;\r\nfor(i = 0; i < 6; i++)\r\ndev->dev_addr[i] = sk_isa_sifreadw(dev, SIFINC) >> 8;\r\n}\r\nstatic unsigned short sk_isa_setnselout_pins(struct net_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int sk_isa_open(struct net_device *dev)\r\n{\r\nstruct net_local *tp = netdev_priv(dev);\r\nunsigned short val = 0;\r\nunsigned short oldval;\r\nint i;\r\nval = 0;\r\nfor(i = 0; irqlist[i] != 0; i++)\r\n{\r\nif(irqlist[i] == dev->irq)\r\nbreak;\r\n}\r\nval |= CYCLE_TIME << 2;\r\nval |= i << 4;\r\ni = dev->dma - 5;\r\nval |= i;\r\nif(tp->DataRate == SPEED_4)\r\nval |= LINE_SPEED_BIT;\r\nelse\r\nval &= ~LINE_SPEED_BIT;\r\noldval = sk_isa_sifreadb(dev, POSREG);\r\noldval |= 0xf3;\r\nval &= oldval;\r\nsk_isa_sifwriteb(dev, val, POSREG);\r\nreturn tms380tr_open(dev);\r\n}\r\nstatic int __init sk_isa_init(void)\r\n{\r\nstruct net_device *dev;\r\nstruct platform_device *pdev;\r\nint i, num = 0, err = 0;\r\nsk_isa_netdev_ops = tms380tr_netdev_ops;\r\nsk_isa_netdev_ops.ndo_open = sk_isa_open;\r\nsk_isa_netdev_ops.ndo_stop = tms380tr_close;\r\nerr = platform_driver_register(&sk_isa_driver);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < ISATR_MAX_ADAPTERS ; i++) {\r\ndev = alloc_trdev(sizeof(struct net_local));\r\nif (!dev)\r\ncontinue;\r\ndev->base_addr = io[i];\r\ndev->irq = irq[i];\r\ndev->dma = dma[i];\r\npdev = platform_device_register_simple("skisa",\r\ni, NULL, 0);\r\nif (IS_ERR(pdev)) {\r\nfree_netdev(dev);\r\ncontinue;\r\n}\r\nerr = setup_card(dev, &pdev->dev);\r\nif (!err) {\r\nsk_isa_dev[i] = pdev;\r\nplatform_set_drvdata(sk_isa_dev[i], dev);\r\n++num;\r\n} else {\r\nplatform_device_unregister(pdev);\r\nfree_netdev(dev);\r\n}\r\n}\r\nprintk(KERN_NOTICE "skisa.c: %d cards found.\n", num);\r\nif (num == 0) {\r\nprintk(KERN_NOTICE "skisa.c: No cards found.\n");\r\nplatform_driver_unregister(&sk_isa_driver);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit sk_isa_cleanup(void)\r\n{\r\nstruct net_device *dev;\r\nint i;\r\nfor (i = 0; i < ISATR_MAX_ADAPTERS ; i++) {\r\nstruct platform_device *pdev = sk_isa_dev[i];\r\nif (!pdev)\r\ncontinue;\r\ndev = platform_get_drvdata(pdev);\r\nunregister_netdev(dev);\r\nrelease_region(dev->base_addr, SK_ISA_IO_EXTENT);\r\nfree_irq(dev->irq, dev);\r\nfree_dma(dev->dma);\r\ntmsdev_term(dev);\r\nfree_netdev(dev);\r\nplatform_set_drvdata(pdev, NULL);\r\nplatform_device_unregister(pdev);\r\n}\r\nplatform_driver_unregister(&sk_isa_driver);\r\n}
