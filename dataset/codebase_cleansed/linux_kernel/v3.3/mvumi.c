static void tag_init(struct mvumi_tag *st, unsigned short size)\r\n{\r\nunsigned short i;\r\nBUG_ON(size != st->size);\r\nst->top = size;\r\nfor (i = 0; i < size; i++)\r\nst->stack[i] = size - 1 - i;\r\n}\r\nstatic unsigned short tag_get_one(struct mvumi_hba *mhba, struct mvumi_tag *st)\r\n{\r\nBUG_ON(st->top <= 0);\r\nreturn st->stack[--st->top];\r\n}\r\nstatic void tag_release_one(struct mvumi_hba *mhba, struct mvumi_tag *st,\r\nunsigned short tag)\r\n{\r\nBUG_ON(st->top >= st->size);\r\nst->stack[st->top++] = tag;\r\n}\r\nstatic bool tag_is_empty(struct mvumi_tag *st)\r\n{\r\nif (st->top == 0)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic void mvumi_unmap_pci_addr(struct pci_dev *dev, void **addr_array)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_BASE_ADDRESS; i++)\r\nif ((pci_resource_flags(dev, i) & IORESOURCE_MEM) &&\r\naddr_array[i])\r\npci_iounmap(dev, addr_array[i]);\r\n}\r\nstatic int mvumi_map_pci_addr(struct pci_dev *dev, void **addr_array)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_BASE_ADDRESS; i++) {\r\nif (pci_resource_flags(dev, i) & IORESOURCE_MEM) {\r\naddr_array[i] = pci_iomap(dev, i, 0);\r\nif (!addr_array[i]) {\r\ndev_err(&dev->dev, "failed to map Bar[%d]\n",\r\ni);\r\nmvumi_unmap_pci_addr(dev, addr_array);\r\nreturn -ENOMEM;\r\n}\r\n} else\r\naddr_array[i] = NULL;\r\ndev_dbg(&dev->dev, "Bar %d : %p.\n", i, addr_array[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct mvumi_res *mvumi_alloc_mem_resource(struct mvumi_hba *mhba,\r\nenum resource_type type, unsigned int size)\r\n{\r\nstruct mvumi_res *res = kzalloc(sizeof(*res), GFP_KERNEL);\r\nif (!res) {\r\ndev_err(&mhba->pdev->dev,\r\n"Failed to allocate memory for resouce manager.\n");\r\nreturn NULL;\r\n}\r\nswitch (type) {\r\ncase RESOURCE_CACHED_MEMORY:\r\nres->virt_addr = kzalloc(size, GFP_KERNEL);\r\nif (!res->virt_addr) {\r\ndev_err(&mhba->pdev->dev,\r\n"unable to allocate memory,size = %d.\n", size);\r\nkfree(res);\r\nreturn NULL;\r\n}\r\nbreak;\r\ncase RESOURCE_UNCACHED_MEMORY:\r\nsize = round_up(size, 8);\r\nres->virt_addr = pci_alloc_consistent(mhba->pdev, size,\r\n&res->bus_addr);\r\nif (!res->virt_addr) {\r\ndev_err(&mhba->pdev->dev,\r\n"unable to allocate consistent mem,"\r\n"size = %d.\n", size);\r\nkfree(res);\r\nreturn NULL;\r\n}\r\nmemset(res->virt_addr, 0, size);\r\nbreak;\r\ndefault:\r\ndev_err(&mhba->pdev->dev, "unknown resource type %d.\n", type);\r\nkfree(res);\r\nreturn NULL;\r\n}\r\nres->type = type;\r\nres->size = size;\r\nINIT_LIST_HEAD(&res->entry);\r\nlist_add_tail(&res->entry, &mhba->res_list);\r\nreturn res;\r\n}\r\nstatic void mvumi_release_mem_resource(struct mvumi_hba *mhba)\r\n{\r\nstruct mvumi_res *res, *tmp;\r\nlist_for_each_entry_safe(res, tmp, &mhba->res_list, entry) {\r\nswitch (res->type) {\r\ncase RESOURCE_UNCACHED_MEMORY:\r\npci_free_consistent(mhba->pdev, res->size,\r\nres->virt_addr, res->bus_addr);\r\nbreak;\r\ncase RESOURCE_CACHED_MEMORY:\r\nkfree(res->virt_addr);\r\nbreak;\r\ndefault:\r\ndev_err(&mhba->pdev->dev,\r\n"unknown resource type %d\n", res->type);\r\nbreak;\r\n}\r\nlist_del(&res->entry);\r\nkfree(res);\r\n}\r\nmhba->fw_flag &= ~MVUMI_FW_ALLOC;\r\n}\r\nstatic int mvumi_make_sgl(struct mvumi_hba *mhba, struct scsi_cmnd *scmd,\r\nvoid *sgl_p, unsigned char *sg_count)\r\n{\r\nstruct scatterlist *sg;\r\nstruct mvumi_sgl *m_sg = (struct mvumi_sgl *) sgl_p;\r\nunsigned int i;\r\nunsigned int sgnum = scsi_sg_count(scmd);\r\ndma_addr_t busaddr;\r\nif (sgnum) {\r\nsg = scsi_sglist(scmd);\r\n*sg_count = pci_map_sg(mhba->pdev, sg, sgnum,\r\n(int) scmd->sc_data_direction);\r\nif (*sg_count > mhba->max_sge) {\r\ndev_err(&mhba->pdev->dev, "sg count[0x%x] is bigger "\r\n"than max sg[0x%x].\n",\r\n*sg_count, mhba->max_sge);\r\nreturn -1;\r\n}\r\nfor (i = 0; i < *sg_count; i++) {\r\nbusaddr = sg_dma_address(&sg[i]);\r\nm_sg->baseaddr_l = cpu_to_le32(lower_32_bits(busaddr));\r\nm_sg->baseaddr_h = cpu_to_le32(upper_32_bits(busaddr));\r\nm_sg->flags = 0;\r\nm_sg->size = cpu_to_le32(sg_dma_len(&sg[i]));\r\nif ((i + 1) == *sg_count)\r\nm_sg->flags |= SGD_EOT;\r\nm_sg++;\r\n}\r\n} else {\r\nscmd->SCp.dma_handle = scsi_bufflen(scmd) ?\r\npci_map_single(mhba->pdev, scsi_sglist(scmd),\r\nscsi_bufflen(scmd),\r\n(int) scmd->sc_data_direction)\r\n: 0;\r\nbusaddr = scmd->SCp.dma_handle;\r\nm_sg->baseaddr_l = cpu_to_le32(lower_32_bits(busaddr));\r\nm_sg->baseaddr_h = cpu_to_le32(upper_32_bits(busaddr));\r\nm_sg->flags = SGD_EOT;\r\nm_sg->size = cpu_to_le32(scsi_bufflen(scmd));\r\n*sg_count = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mvumi_internal_cmd_sgl(struct mvumi_hba *mhba, struct mvumi_cmd *cmd,\r\nunsigned int size)\r\n{\r\nstruct mvumi_sgl *m_sg;\r\nvoid *virt_addr;\r\ndma_addr_t phy_addr;\r\nif (size == 0)\r\nreturn 0;\r\nvirt_addr = pci_alloc_consistent(mhba->pdev, size, &phy_addr);\r\nif (!virt_addr)\r\nreturn -1;\r\nmemset(virt_addr, 0, size);\r\nm_sg = (struct mvumi_sgl *) &cmd->frame->payload[0];\r\ncmd->frame->sg_counts = 1;\r\ncmd->data_buf = virt_addr;\r\nm_sg->baseaddr_l = cpu_to_le32(lower_32_bits(phy_addr));\r\nm_sg->baseaddr_h = cpu_to_le32(upper_32_bits(phy_addr));\r\nm_sg->flags = SGD_EOT;\r\nm_sg->size = cpu_to_le32(size);\r\nreturn 0;\r\n}\r\nstatic struct mvumi_cmd *mvumi_create_internal_cmd(struct mvumi_hba *mhba,\r\nunsigned int buf_size)\r\n{\r\nstruct mvumi_cmd *cmd;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (!cmd) {\r\ndev_err(&mhba->pdev->dev, "failed to create a internal cmd\n");\r\nreturn NULL;\r\n}\r\nINIT_LIST_HEAD(&cmd->queue_pointer);\r\ncmd->frame = kzalloc(mhba->ib_max_size, GFP_KERNEL);\r\nif (!cmd->frame) {\r\ndev_err(&mhba->pdev->dev, "failed to allocate memory for FW"\r\n" frame,size = %d.\n", mhba->ib_max_size);\r\nkfree(cmd);\r\nreturn NULL;\r\n}\r\nif (buf_size) {\r\nif (mvumi_internal_cmd_sgl(mhba, cmd, buf_size)) {\r\ndev_err(&mhba->pdev->dev, "failed to allocate memory"\r\n" for internal frame\n");\r\nkfree(cmd->frame);\r\nkfree(cmd);\r\nreturn NULL;\r\n}\r\n} else\r\ncmd->frame->sg_counts = 0;\r\nreturn cmd;\r\n}\r\nstatic void mvumi_delete_internal_cmd(struct mvumi_hba *mhba,\r\nstruct mvumi_cmd *cmd)\r\n{\r\nstruct mvumi_sgl *m_sg;\r\nunsigned int size;\r\ndma_addr_t phy_addr;\r\nif (cmd && cmd->frame) {\r\nif (cmd->frame->sg_counts) {\r\nm_sg = (struct mvumi_sgl *) &cmd->frame->payload[0];\r\nsize = m_sg->size;\r\nphy_addr = (dma_addr_t) m_sg->baseaddr_l |\r\n(dma_addr_t) ((m_sg->baseaddr_h << 16) << 16);\r\npci_free_consistent(mhba->pdev, size, cmd->data_buf,\r\nphy_addr);\r\n}\r\nkfree(cmd->frame);\r\nkfree(cmd);\r\n}\r\n}\r\nstatic struct mvumi_cmd *mvumi_get_cmd(struct mvumi_hba *mhba)\r\n{\r\nstruct mvumi_cmd *cmd = NULL;\r\nif (likely(!list_empty(&mhba->cmd_pool))) {\r\ncmd = list_entry((&mhba->cmd_pool)->next,\r\nstruct mvumi_cmd, queue_pointer);\r\nlist_del_init(&cmd->queue_pointer);\r\n} else\r\ndev_warn(&mhba->pdev->dev, "command pool is empty!\n");\r\nreturn cmd;\r\n}\r\nstatic inline void mvumi_return_cmd(struct mvumi_hba *mhba,\r\nstruct mvumi_cmd *cmd)\r\n{\r\ncmd->scmd = NULL;\r\nlist_add_tail(&cmd->queue_pointer, &mhba->cmd_pool);\r\n}\r\nstatic void mvumi_free_cmds(struct mvumi_hba *mhba)\r\n{\r\nstruct mvumi_cmd *cmd;\r\nwhile (!list_empty(&mhba->cmd_pool)) {\r\ncmd = list_first_entry(&mhba->cmd_pool, struct mvumi_cmd,\r\nqueue_pointer);\r\nlist_del(&cmd->queue_pointer);\r\nkfree(cmd->frame);\r\nkfree(cmd);\r\n}\r\n}\r\nstatic int mvumi_alloc_cmds(struct mvumi_hba *mhba)\r\n{\r\nint i;\r\nstruct mvumi_cmd *cmd;\r\nfor (i = 0; i < mhba->max_io; i++) {\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (!cmd)\r\ngoto err_exit;\r\nINIT_LIST_HEAD(&cmd->queue_pointer);\r\nlist_add_tail(&cmd->queue_pointer, &mhba->cmd_pool);\r\ncmd->frame = kzalloc(mhba->ib_max_size, GFP_KERNEL);\r\nif (!cmd->frame)\r\ngoto err_exit;\r\n}\r\nreturn 0;\r\nerr_exit:\r\ndev_err(&mhba->pdev->dev,\r\n"failed to allocate memory for cmd[0x%x].\n", i);\r\nwhile (!list_empty(&mhba->cmd_pool)) {\r\ncmd = list_first_entry(&mhba->cmd_pool, struct mvumi_cmd,\r\nqueue_pointer);\r\nlist_del(&cmd->queue_pointer);\r\nkfree(cmd->frame);\r\nkfree(cmd);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nstatic int mvumi_get_ib_list_entry(struct mvumi_hba *mhba, void **ib_entry)\r\n{\r\nunsigned int ib_rp_reg, cur_ib_entry;\r\nif (atomic_read(&mhba->fw_outstanding) >= mhba->max_io) {\r\ndev_warn(&mhba->pdev->dev, "firmware io overflow.\n");\r\nreturn -1;\r\n}\r\nib_rp_reg = ioread32(mhba->mmio + CLA_INB_READ_POINTER);\r\nif (unlikely(((ib_rp_reg & CL_SLOT_NUM_MASK) ==\r\n(mhba->ib_cur_slot & CL_SLOT_NUM_MASK)) &&\r\n((ib_rp_reg & CL_POINTER_TOGGLE) !=\r\n(mhba->ib_cur_slot & CL_POINTER_TOGGLE)))) {\r\ndev_warn(&mhba->pdev->dev, "no free slot to use.\n");\r\nreturn -1;\r\n}\r\ncur_ib_entry = mhba->ib_cur_slot & CL_SLOT_NUM_MASK;\r\ncur_ib_entry++;\r\nif (cur_ib_entry >= mhba->list_num_io) {\r\ncur_ib_entry -= mhba->list_num_io;\r\nmhba->ib_cur_slot ^= CL_POINTER_TOGGLE;\r\n}\r\nmhba->ib_cur_slot &= ~CL_SLOT_NUM_MASK;\r\nmhba->ib_cur_slot |= (cur_ib_entry & CL_SLOT_NUM_MASK);\r\n*ib_entry = mhba->ib_list + cur_ib_entry * mhba->ib_max_size;\r\natomic_inc(&mhba->fw_outstanding);\r\nreturn 0;\r\n}\r\nstatic void mvumi_send_ib_list_entry(struct mvumi_hba *mhba)\r\n{\r\niowrite32(0xfff, mhba->ib_shadow);\r\niowrite32(mhba->ib_cur_slot, mhba->mmio + CLA_INB_WRITE_POINTER);\r\n}\r\nstatic char mvumi_check_ob_frame(struct mvumi_hba *mhba,\r\nunsigned int cur_obf, struct mvumi_rsp_frame *p_outb_frame)\r\n{\r\nunsigned short tag, request_id;\r\nudelay(1);\r\np_outb_frame = mhba->ob_list + cur_obf * mhba->ob_max_size;\r\nrequest_id = p_outb_frame->request_id;\r\ntag = p_outb_frame->tag;\r\nif (tag > mhba->tag_pool.size) {\r\ndev_err(&mhba->pdev->dev, "ob frame data error\n");\r\nreturn -1;\r\n}\r\nif (mhba->tag_cmd[tag] == NULL) {\r\ndev_err(&mhba->pdev->dev, "tag[0x%x] with NO command\n", tag);\r\nreturn -1;\r\n} else if (mhba->tag_cmd[tag]->request_id != request_id &&\r\nmhba->request_id_enabled) {\r\ndev_err(&mhba->pdev->dev, "request ID from FW:0x%x,"\r\n"cmd request ID:0x%x\n", request_id,\r\nmhba->tag_cmd[tag]->request_id);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mvumi_receive_ob_list_entry(struct mvumi_hba *mhba)\r\n{\r\nunsigned int ob_write_reg, ob_write_shadow_reg;\r\nunsigned int cur_obf, assign_obf_end, i;\r\nstruct mvumi_ob_data *ob_data;\r\nstruct mvumi_rsp_frame *p_outb_frame;\r\ndo {\r\nob_write_reg = ioread32(mhba->mmio + CLA_OUTB_COPY_POINTER);\r\nob_write_shadow_reg = ioread32(mhba->ob_shadow);\r\n} while ((ob_write_reg & CL_SLOT_NUM_MASK) != ob_write_shadow_reg);\r\ncur_obf = mhba->ob_cur_slot & CL_SLOT_NUM_MASK;\r\nassign_obf_end = ob_write_reg & CL_SLOT_NUM_MASK;\r\nif ((ob_write_reg & CL_POINTER_TOGGLE) !=\r\n(mhba->ob_cur_slot & CL_POINTER_TOGGLE)) {\r\nassign_obf_end += mhba->list_num_io;\r\n}\r\nfor (i = (assign_obf_end - cur_obf); i != 0; i--) {\r\ncur_obf++;\r\nif (cur_obf >= mhba->list_num_io) {\r\ncur_obf -= mhba->list_num_io;\r\nmhba->ob_cur_slot ^= CL_POINTER_TOGGLE;\r\n}\r\np_outb_frame = mhba->ob_list + cur_obf * mhba->ob_max_size;\r\nif (unlikely(p_outb_frame->tag > mhba->tag_pool.size ||\r\nmhba->tag_cmd[p_outb_frame->tag] == NULL ||\r\np_outb_frame->request_id !=\r\nmhba->tag_cmd[p_outb_frame->tag]->request_id))\r\nif (mvumi_check_ob_frame(mhba, cur_obf, p_outb_frame))\r\ncontinue;\r\nif (!list_empty(&mhba->ob_data_list)) {\r\nob_data = (struct mvumi_ob_data *)\r\nlist_first_entry(&mhba->ob_data_list,\r\nstruct mvumi_ob_data, list);\r\nlist_del_init(&ob_data->list);\r\n} else {\r\nob_data = NULL;\r\nif (cur_obf == 0) {\r\ncur_obf = mhba->list_num_io - 1;\r\nmhba->ob_cur_slot ^= CL_POINTER_TOGGLE;\r\n} else\r\ncur_obf -= 1;\r\nbreak;\r\n}\r\nmemcpy(ob_data->data, p_outb_frame, mhba->ob_max_size);\r\np_outb_frame->tag = 0xff;\r\nlist_add_tail(&ob_data->list, &mhba->free_ob_list);\r\n}\r\nmhba->ob_cur_slot &= ~CL_SLOT_NUM_MASK;\r\nmhba->ob_cur_slot |= (cur_obf & CL_SLOT_NUM_MASK);\r\niowrite32(mhba->ob_cur_slot, mhba->mmio + CLA_OUTB_READ_POINTER);\r\n}\r\nstatic void mvumi_reset(void *regs)\r\n{\r\niowrite32(0, regs + CPU_ENPOINTA_MASK_REG);\r\nif (ioread32(regs + CPU_ARM_TO_PCIEA_MSG1) != HANDSHAKE_DONESTATE)\r\nreturn;\r\niowrite32(DRBL_SOFT_RESET, regs + CPU_PCIEA_TO_ARM_DRBL_REG);\r\n}\r\nstatic int mvumi_wait_for_outstanding(struct mvumi_hba *mhba)\r\n{\r\nmhba->fw_state = FW_STATE_ABORT;\r\nmvumi_reset(mhba->mmio);\r\nif (mvumi_start(mhba))\r\nreturn FAILED;\r\nelse\r\nreturn SUCCESS;\r\n}\r\nstatic int mvumi_host_reset(struct scsi_cmnd *scmd)\r\n{\r\nstruct mvumi_hba *mhba;\r\nmhba = (struct mvumi_hba *) scmd->device->host->hostdata;\r\nscmd_printk(KERN_NOTICE, scmd, "RESET -%ld cmd=%x retries=%x\n",\r\nscmd->serial_number, scmd->cmnd[0], scmd->retries);\r\nreturn mvumi_wait_for_outstanding(mhba);\r\n}\r\nstatic int mvumi_issue_blocked_cmd(struct mvumi_hba *mhba,\r\nstruct mvumi_cmd *cmd)\r\n{\r\nunsigned long flags;\r\ncmd->cmd_status = REQ_STATUS_PENDING;\r\nif (atomic_read(&cmd->sync_cmd)) {\r\ndev_err(&mhba->pdev->dev,\r\n"last blocked cmd not finished, sync_cmd = %d\n",\r\natomic_read(&cmd->sync_cmd));\r\nBUG_ON(1);\r\nreturn -1;\r\n}\r\natomic_inc(&cmd->sync_cmd);\r\nspin_lock_irqsave(mhba->shost->host_lock, flags);\r\nmhba->instancet->fire_cmd(mhba, cmd);\r\nspin_unlock_irqrestore(mhba->shost->host_lock, flags);\r\nwait_event_timeout(mhba->int_cmd_wait_q,\r\n(cmd->cmd_status != REQ_STATUS_PENDING),\r\nMVUMI_INTERNAL_CMD_WAIT_TIME * HZ);\r\nif (atomic_read(&cmd->sync_cmd)) {\r\nspin_lock_irqsave(mhba->shost->host_lock, flags);\r\natomic_dec(&cmd->sync_cmd);\r\nif (mhba->tag_cmd[cmd->frame->tag]) {\r\nmhba->tag_cmd[cmd->frame->tag] = 0;\r\ndev_warn(&mhba->pdev->dev, "TIMEOUT:release tag [%d]\n",\r\ncmd->frame->tag);\r\ntag_release_one(mhba, &mhba->tag_pool, cmd->frame->tag);\r\n}\r\nif (!list_empty(&cmd->queue_pointer)) {\r\ndev_warn(&mhba->pdev->dev,\r\n"TIMEOUT:A internal command doesn't send!\n");\r\nlist_del_init(&cmd->queue_pointer);\r\n} else\r\natomic_dec(&mhba->fw_outstanding);\r\nspin_unlock_irqrestore(mhba->shost->host_lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic void mvumi_release_fw(struct mvumi_hba *mhba)\r\n{\r\nmvumi_free_cmds(mhba);\r\nmvumi_release_mem_resource(mhba);\r\nmvumi_unmap_pci_addr(mhba->pdev, mhba->base_addr);\r\nkfree(mhba->handshake_page);\r\npci_release_regions(mhba->pdev);\r\n}\r\nstatic unsigned char mvumi_flush_cache(struct mvumi_hba *mhba)\r\n{\r\nstruct mvumi_cmd *cmd;\r\nstruct mvumi_msg_frame *frame;\r\nunsigned char device_id, retry = 0;\r\nunsigned char bitcount = sizeof(unsigned char) * 8;\r\nfor (device_id = 0; device_id < mhba->max_target_id; device_id++) {\r\nif (!(mhba->target_map[device_id / bitcount] &\r\n(1 << (device_id % bitcount))))\r\ncontinue;\r\nget_cmd: cmd = mvumi_create_internal_cmd(mhba, 0);\r\nif (!cmd) {\r\nif (retry++ >= 5) {\r\ndev_err(&mhba->pdev->dev, "failed to get memory"\r\n" for internal flush cache cmd for "\r\n"device %d", device_id);\r\nretry = 0;\r\ncontinue;\r\n} else\r\ngoto get_cmd;\r\n}\r\ncmd->scmd = NULL;\r\ncmd->cmd_status = REQ_STATUS_PENDING;\r\natomic_set(&cmd->sync_cmd, 0);\r\nframe = cmd->frame;\r\nframe->req_function = CL_FUN_SCSI_CMD;\r\nframe->device_id = device_id;\r\nframe->cmd_flag = CMD_FLAG_NON_DATA;\r\nframe->data_transfer_length = 0;\r\nframe->cdb_length = MAX_COMMAND_SIZE;\r\nmemset(frame->cdb, 0, MAX_COMMAND_SIZE);\r\nframe->cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;\r\nframe->cdb[2] = CDB_CORE_SHUTDOWN;\r\nmvumi_issue_blocked_cmd(mhba, cmd);\r\nif (cmd->cmd_status != SAM_STAT_GOOD) {\r\ndev_err(&mhba->pdev->dev,\r\n"device %d flush cache failed, status=0x%x.\n",\r\ndevice_id, cmd->cmd_status);\r\n}\r\nmvumi_delete_internal_cmd(mhba, cmd);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned char\r\nmvumi_calculate_checksum(struct mvumi_hs_header *p_header,\r\nunsigned short len)\r\n{\r\nunsigned char *ptr;\r\nunsigned char ret = 0, i;\r\nptr = (unsigned char *) p_header->frame_content;\r\nfor (i = 0; i < len; i++) {\r\nret ^= *ptr;\r\nptr++;\r\n}\r\nreturn ret;\r\n}\r\nvoid mvumi_hs_build_page(struct mvumi_hba *mhba,\r\nstruct mvumi_hs_header *hs_header)\r\n{\r\nstruct mvumi_hs_page2 *hs_page2;\r\nstruct mvumi_hs_page4 *hs_page4;\r\nstruct mvumi_hs_page3 *hs_page3;\r\nstruct timeval time;\r\nunsigned int local_time;\r\nswitch (hs_header->page_code) {\r\ncase HS_PAGE_HOST_INFO:\r\nhs_page2 = (struct mvumi_hs_page2 *) hs_header;\r\nhs_header->frame_length = sizeof(*hs_page2) - 4;\r\nmemset(hs_header->frame_content, 0, hs_header->frame_length);\r\nhs_page2->host_type = 3;\r\nhs_page2->host_ver.ver_major = VER_MAJOR;\r\nhs_page2->host_ver.ver_minor = VER_MINOR;\r\nhs_page2->host_ver.ver_oem = VER_OEM;\r\nhs_page2->host_ver.ver_build = VER_BUILD;\r\nhs_page2->system_io_bus = 0;\r\nhs_page2->slot_number = 0;\r\nhs_page2->intr_level = 0;\r\nhs_page2->intr_vector = 0;\r\ndo_gettimeofday(&time);\r\nlocal_time = (unsigned int) (time.tv_sec -\r\n(sys_tz.tz_minuteswest * 60));\r\nhs_page2->seconds_since1970 = local_time;\r\nhs_header->checksum = mvumi_calculate_checksum(hs_header,\r\nhs_header->frame_length);\r\nbreak;\r\ncase HS_PAGE_FIRM_CTL:\r\nhs_page3 = (struct mvumi_hs_page3 *) hs_header;\r\nhs_header->frame_length = sizeof(*hs_page3) - 4;\r\nmemset(hs_header->frame_content, 0, hs_header->frame_length);\r\nhs_header->checksum = mvumi_calculate_checksum(hs_header,\r\nhs_header->frame_length);\r\nbreak;\r\ncase HS_PAGE_CL_INFO:\r\nhs_page4 = (struct mvumi_hs_page4 *) hs_header;\r\nhs_header->frame_length = sizeof(*hs_page4) - 4;\r\nmemset(hs_header->frame_content, 0, hs_header->frame_length);\r\nhs_page4->ib_baseaddr_l = lower_32_bits(mhba->ib_list_phys);\r\nhs_page4->ib_baseaddr_h = upper_32_bits(mhba->ib_list_phys);\r\nhs_page4->ob_baseaddr_l = lower_32_bits(mhba->ob_list_phys);\r\nhs_page4->ob_baseaddr_h = upper_32_bits(mhba->ob_list_phys);\r\nhs_page4->ib_entry_size = mhba->ib_max_size_setting;\r\nhs_page4->ob_entry_size = mhba->ob_max_size_setting;\r\nhs_page4->ob_depth = mhba->list_num_io;\r\nhs_page4->ib_depth = mhba->list_num_io;\r\nhs_header->checksum = mvumi_calculate_checksum(hs_header,\r\nhs_header->frame_length);\r\nbreak;\r\ndefault:\r\ndev_err(&mhba->pdev->dev, "cannot build page, code[0x%x]\n",\r\nhs_header->page_code);\r\nbreak;\r\n}\r\n}\r\nstatic int mvumi_init_data(struct mvumi_hba *mhba)\r\n{\r\nstruct mvumi_ob_data *ob_pool;\r\nstruct mvumi_res *res_mgnt;\r\nunsigned int tmp_size, offset, i;\r\nvoid *virmem, *v;\r\ndma_addr_t p;\r\nif (mhba->fw_flag & MVUMI_FW_ALLOC)\r\nreturn 0;\r\ntmp_size = mhba->ib_max_size * mhba->max_io;\r\ntmp_size += 128 + mhba->ob_max_size * mhba->max_io;\r\ntmp_size += 8 + sizeof(u32) + 16;\r\nres_mgnt = mvumi_alloc_mem_resource(mhba,\r\nRESOURCE_UNCACHED_MEMORY, tmp_size);\r\nif (!res_mgnt) {\r\ndev_err(&mhba->pdev->dev,\r\n"failed to allocate memory for inbound list\n");\r\ngoto fail_alloc_dma_buf;\r\n}\r\np = res_mgnt->bus_addr;\r\nv = res_mgnt->virt_addr;\r\noffset = round_up(p, 128) - p;\r\np += offset;\r\nv += offset;\r\nmhba->ib_list = v;\r\nmhba->ib_list_phys = p;\r\nv += mhba->ib_max_size * mhba->max_io;\r\np += mhba->ib_max_size * mhba->max_io;\r\noffset = round_up(p, 8) - p;\r\np += offset;\r\nv += offset;\r\nmhba->ib_shadow = v;\r\nmhba->ib_shadow_phys = p;\r\np += sizeof(u32);\r\nv += sizeof(u32);\r\noffset = round_up(p, 8) - p;\r\np += offset;\r\nv += offset;\r\nmhba->ob_shadow = v;\r\nmhba->ob_shadow_phys = p;\r\np += 8;\r\nv += 8;\r\noffset = round_up(p, 128) - p;\r\np += offset;\r\nv += offset;\r\nmhba->ob_list = v;\r\nmhba->ob_list_phys = p;\r\ntmp_size = mhba->max_io * (mhba->ob_max_size + sizeof(*ob_pool));\r\ntmp_size = round_up(tmp_size, 8);\r\nres_mgnt = mvumi_alloc_mem_resource(mhba,\r\nRESOURCE_CACHED_MEMORY, tmp_size);\r\nif (!res_mgnt) {\r\ndev_err(&mhba->pdev->dev,\r\n"failed to allocate memory for outbound data buffer\n");\r\ngoto fail_alloc_dma_buf;\r\n}\r\nvirmem = res_mgnt->virt_addr;\r\nfor (i = mhba->max_io; i != 0; i--) {\r\nob_pool = (struct mvumi_ob_data *) virmem;\r\nlist_add_tail(&ob_pool->list, &mhba->ob_data_list);\r\nvirmem += mhba->ob_max_size + sizeof(*ob_pool);\r\n}\r\ntmp_size = sizeof(unsigned short) * mhba->max_io +\r\nsizeof(struct mvumi_cmd *) * mhba->max_io;\r\ntmp_size += round_up(mhba->max_target_id, sizeof(unsigned char) * 8) /\r\n(sizeof(unsigned char) * 8);\r\nres_mgnt = mvumi_alloc_mem_resource(mhba,\r\nRESOURCE_CACHED_MEMORY, tmp_size);\r\nif (!res_mgnt) {\r\ndev_err(&mhba->pdev->dev,\r\n"failed to allocate memory for tag and target map\n");\r\ngoto fail_alloc_dma_buf;\r\n}\r\nvirmem = res_mgnt->virt_addr;\r\nmhba->tag_pool.stack = virmem;\r\nmhba->tag_pool.size = mhba->max_io;\r\ntag_init(&mhba->tag_pool, mhba->max_io);\r\nvirmem += sizeof(unsigned short) * mhba->max_io;\r\nmhba->tag_cmd = virmem;\r\nvirmem += sizeof(struct mvumi_cmd *) * mhba->max_io;\r\nmhba->target_map = virmem;\r\nmhba->fw_flag |= MVUMI_FW_ALLOC;\r\nreturn 0;\r\nfail_alloc_dma_buf:\r\nmvumi_release_mem_resource(mhba);\r\nreturn -1;\r\n}\r\nstatic int mvumi_hs_process_page(struct mvumi_hba *mhba,\r\nstruct mvumi_hs_header *hs_header)\r\n{\r\nstruct mvumi_hs_page1 *hs_page1;\r\nunsigned char page_checksum;\r\npage_checksum = mvumi_calculate_checksum(hs_header,\r\nhs_header->frame_length);\r\nif (page_checksum != hs_header->checksum) {\r\ndev_err(&mhba->pdev->dev, "checksum error\n");\r\nreturn -1;\r\n}\r\nswitch (hs_header->page_code) {\r\ncase HS_PAGE_FIRM_CAP:\r\nhs_page1 = (struct mvumi_hs_page1 *) hs_header;\r\nmhba->max_io = hs_page1->max_io_support;\r\nmhba->list_num_io = hs_page1->cl_inout_list_depth;\r\nmhba->max_transfer_size = hs_page1->max_transfer_size;\r\nmhba->max_target_id = hs_page1->max_devices_support;\r\nmhba->hba_capability = hs_page1->capability;\r\nmhba->ib_max_size_setting = hs_page1->cl_in_max_entry_size;\r\nmhba->ib_max_size = (1 << hs_page1->cl_in_max_entry_size) << 2;\r\nmhba->ob_max_size_setting = hs_page1->cl_out_max_entry_size;\r\nmhba->ob_max_size = (1 << hs_page1->cl_out_max_entry_size) << 2;\r\ndev_dbg(&mhba->pdev->dev, "FW version:%d\n",\r\nhs_page1->fw_ver.ver_build);\r\nbreak;\r\ndefault:\r\ndev_err(&mhba->pdev->dev, "handshake: page code error\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mvumi_handshake(struct mvumi_hba *mhba)\r\n{\r\nunsigned int hs_state, tmp, hs_fun;\r\nstruct mvumi_hs_header *hs_header;\r\nvoid *regs = mhba->mmio;\r\nif (mhba->fw_state == FW_STATE_STARTING)\r\nhs_state = HS_S_START;\r\nelse {\r\ntmp = ioread32(regs + CPU_ARM_TO_PCIEA_MSG0);\r\nhs_state = HS_GET_STATE(tmp);\r\ndev_dbg(&mhba->pdev->dev, "handshake state[0x%x].\n", hs_state);\r\nif (HS_GET_STATUS(tmp) != HS_STATUS_OK) {\r\nmhba->fw_state = FW_STATE_STARTING;\r\nreturn -1;\r\n}\r\n}\r\nhs_fun = 0;\r\nswitch (hs_state) {\r\ncase HS_S_START:\r\nmhba->fw_state = FW_STATE_HANDSHAKING;\r\nHS_SET_STATUS(hs_fun, HS_STATUS_OK);\r\nHS_SET_STATE(hs_fun, HS_S_RESET);\r\niowrite32(HANDSHAKE_SIGNATURE, regs + CPU_PCIEA_TO_ARM_MSG1);\r\niowrite32(hs_fun, regs + CPU_PCIEA_TO_ARM_MSG0);\r\niowrite32(DRBL_HANDSHAKE, regs + CPU_PCIEA_TO_ARM_DRBL_REG);\r\nbreak;\r\ncase HS_S_RESET:\r\niowrite32(lower_32_bits(mhba->handshake_page_phys),\r\nregs + CPU_PCIEA_TO_ARM_MSG1);\r\niowrite32(upper_32_bits(mhba->handshake_page_phys),\r\nregs + CPU_ARM_TO_PCIEA_MSG1);\r\nHS_SET_STATUS(hs_fun, HS_STATUS_OK);\r\nHS_SET_STATE(hs_fun, HS_S_PAGE_ADDR);\r\niowrite32(hs_fun, regs + CPU_PCIEA_TO_ARM_MSG0);\r\niowrite32(DRBL_HANDSHAKE, regs + CPU_PCIEA_TO_ARM_DRBL_REG);\r\nbreak;\r\ncase HS_S_PAGE_ADDR:\r\ncase HS_S_QUERY_PAGE:\r\ncase HS_S_SEND_PAGE:\r\nhs_header = (struct mvumi_hs_header *) mhba->handshake_page;\r\nif (hs_header->page_code == HS_PAGE_FIRM_CAP) {\r\nmhba->hba_total_pages =\r\n((struct mvumi_hs_page1 *) hs_header)->total_pages;\r\nif (mhba->hba_total_pages == 0)\r\nmhba->hba_total_pages = HS_PAGE_TOTAL-1;\r\n}\r\nif (hs_state == HS_S_QUERY_PAGE) {\r\nif (mvumi_hs_process_page(mhba, hs_header)) {\r\nHS_SET_STATE(hs_fun, HS_S_ABORT);\r\nreturn -1;\r\n}\r\nif (mvumi_init_data(mhba)) {\r\nHS_SET_STATE(hs_fun, HS_S_ABORT);\r\nreturn -1;\r\n}\r\n} else if (hs_state == HS_S_PAGE_ADDR) {\r\nhs_header->page_code = 0;\r\nmhba->hba_total_pages = HS_PAGE_TOTAL-1;\r\n}\r\nif ((hs_header->page_code + 1) <= mhba->hba_total_pages) {\r\nhs_header->page_code++;\r\nif (hs_header->page_code != HS_PAGE_FIRM_CAP) {\r\nmvumi_hs_build_page(mhba, hs_header);\r\nHS_SET_STATE(hs_fun, HS_S_SEND_PAGE);\r\n} else\r\nHS_SET_STATE(hs_fun, HS_S_QUERY_PAGE);\r\n} else\r\nHS_SET_STATE(hs_fun, HS_S_END);\r\nHS_SET_STATUS(hs_fun, HS_STATUS_OK);\r\niowrite32(hs_fun, regs + CPU_PCIEA_TO_ARM_MSG0);\r\niowrite32(DRBL_HANDSHAKE, regs + CPU_PCIEA_TO_ARM_DRBL_REG);\r\nbreak;\r\ncase HS_S_END:\r\ntmp = ioread32(regs + CPU_ENPOINTA_MASK_REG);\r\ntmp |= INT_MAP_COMAOUT | INT_MAP_COMAERR;\r\niowrite32(tmp, regs + CPU_ENPOINTA_MASK_REG);\r\niowrite32(mhba->list_num_io, mhba->ib_shadow);\r\niowrite32(lower_32_bits(mhba->ib_shadow_phys),\r\nregs + CLA_INB_AVAL_COUNT_BASEL);\r\niowrite32(upper_32_bits(mhba->ib_shadow_phys),\r\nregs + CLA_INB_AVAL_COUNT_BASEH);\r\niowrite32((mhba->list_num_io-1) | CL_POINTER_TOGGLE,\r\nmhba->ob_shadow);\r\niowrite32(lower_32_bits(mhba->ob_shadow_phys), regs + 0x5B0);\r\niowrite32(upper_32_bits(mhba->ob_shadow_phys), regs + 0x5B4);\r\nmhba->ib_cur_slot = (mhba->list_num_io - 1) | CL_POINTER_TOGGLE;\r\nmhba->ob_cur_slot = (mhba->list_num_io - 1) | CL_POINTER_TOGGLE;\r\nmhba->fw_state = FW_STATE_STARTED;\r\nbreak;\r\ndefault:\r\ndev_err(&mhba->pdev->dev, "unknown handshake state [0x%x].\n",\r\nhs_state);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned char mvumi_handshake_event(struct mvumi_hba *mhba)\r\n{\r\nunsigned int isr_status;\r\nunsigned long before;\r\nbefore = jiffies;\r\nmvumi_handshake(mhba);\r\ndo {\r\nisr_status = mhba->instancet->read_fw_status_reg(mhba->mmio);\r\nif (mhba->fw_state == FW_STATE_STARTED)\r\nreturn 0;\r\nif (time_after(jiffies, before + FW_MAX_DELAY * HZ)) {\r\ndev_err(&mhba->pdev->dev,\r\n"no handshake response at state 0x%x.\n",\r\nmhba->fw_state);\r\ndev_err(&mhba->pdev->dev,\r\n"isr : global=0x%x,status=0x%x.\n",\r\nmhba->global_isr, isr_status);\r\nreturn -1;\r\n}\r\nrmb();\r\nusleep_range(1000, 2000);\r\n} while (!(isr_status & DRBL_HANDSHAKE_ISR));\r\nreturn 0;\r\n}\r\nstatic unsigned char mvumi_check_handshake(struct mvumi_hba *mhba)\r\n{\r\nvoid *regs = mhba->mmio;\r\nunsigned int tmp;\r\nunsigned long before;\r\nbefore = jiffies;\r\ntmp = ioread32(regs + CPU_ARM_TO_PCIEA_MSG1);\r\nwhile ((tmp != HANDSHAKE_READYSTATE) && (tmp != HANDSHAKE_DONESTATE)) {\r\nif (tmp != HANDSHAKE_READYSTATE)\r\niowrite32(DRBL_MU_RESET,\r\nregs + CPU_PCIEA_TO_ARM_DRBL_REG);\r\nif (time_after(jiffies, before + FW_MAX_DELAY * HZ)) {\r\ndev_err(&mhba->pdev->dev,\r\n"invalid signature [0x%x].\n", tmp);\r\nreturn -1;\r\n}\r\nusleep_range(1000, 2000);\r\nrmb();\r\ntmp = ioread32(regs + CPU_ARM_TO_PCIEA_MSG1);\r\n}\r\nmhba->fw_state = FW_STATE_STARTING;\r\ndev_dbg(&mhba->pdev->dev, "start firmware handshake...\n");\r\ndo {\r\nif (mvumi_handshake_event(mhba)) {\r\ndev_err(&mhba->pdev->dev,\r\n"handshake failed at state 0x%x.\n",\r\nmhba->fw_state);\r\nreturn -1;\r\n}\r\n} while (mhba->fw_state != FW_STATE_STARTED);\r\ndev_dbg(&mhba->pdev->dev, "firmware handshake done\n");\r\nreturn 0;\r\n}\r\nstatic unsigned char mvumi_start(struct mvumi_hba *mhba)\r\n{\r\nvoid *regs = mhba->mmio;\r\nunsigned int tmp;\r\ntmp = ioread32(regs + CPU_ARM_TO_PCIEA_DRBL_REG);\r\niowrite32(tmp, regs + CPU_ARM_TO_PCIEA_DRBL_REG);\r\niowrite32(0x3FFFFFFF, regs + CPU_ARM_TO_PCIEA_MASK_REG);\r\ntmp = ioread32(regs + CPU_ENPOINTA_MASK_REG) | INT_MAP_DL_CPU2PCIEA;\r\niowrite32(tmp, regs + CPU_ENPOINTA_MASK_REG);\r\nif (mvumi_check_handshake(mhba))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void mvumi_complete_cmd(struct mvumi_hba *mhba, struct mvumi_cmd *cmd,\r\nstruct mvumi_rsp_frame *ob_frame)\r\n{\r\nstruct scsi_cmnd *scmd = cmd->scmd;\r\ncmd->scmd->SCp.ptr = NULL;\r\nscmd->result = ob_frame->req_status;\r\nswitch (ob_frame->req_status) {\r\ncase SAM_STAT_GOOD:\r\nscmd->result |= DID_OK << 16;\r\nbreak;\r\ncase SAM_STAT_BUSY:\r\nscmd->result |= DID_BUS_BUSY << 16;\r\nbreak;\r\ncase SAM_STAT_CHECK_CONDITION:\r\nscmd->result |= (DID_OK << 16);\r\nif (ob_frame->rsp_flag & CL_RSP_FLAG_SENSEDATA) {\r\nmemcpy(cmd->scmd->sense_buffer, ob_frame->payload,\r\nsizeof(struct mvumi_sense_data));\r\nscmd->result |= (DRIVER_SENSE << 24);\r\n}\r\nbreak;\r\ndefault:\r\nscmd->result |= (DRIVER_INVALID << 24) | (DID_ABORT << 16);\r\nbreak;\r\n}\r\nif (scsi_bufflen(scmd)) {\r\nif (scsi_sg_count(scmd)) {\r\npci_unmap_sg(mhba->pdev,\r\nscsi_sglist(scmd),\r\nscsi_sg_count(scmd),\r\n(int) scmd->sc_data_direction);\r\n} else {\r\npci_unmap_single(mhba->pdev,\r\nscmd->SCp.dma_handle,\r\nscsi_bufflen(scmd),\r\n(int) scmd->sc_data_direction);\r\nscmd->SCp.dma_handle = 0;\r\n}\r\n}\r\ncmd->scmd->scsi_done(scmd);\r\nmvumi_return_cmd(mhba, cmd);\r\n}\r\nstatic void mvumi_complete_internal_cmd(struct mvumi_hba *mhba,\r\nstruct mvumi_cmd *cmd,\r\nstruct mvumi_rsp_frame *ob_frame)\r\n{\r\nif (atomic_read(&cmd->sync_cmd)) {\r\ncmd->cmd_status = ob_frame->req_status;\r\nif ((ob_frame->req_status == SAM_STAT_CHECK_CONDITION) &&\r\n(ob_frame->rsp_flag & CL_RSP_FLAG_SENSEDATA) &&\r\ncmd->data_buf) {\r\nmemcpy(cmd->data_buf, ob_frame->payload,\r\nsizeof(struct mvumi_sense_data));\r\n}\r\natomic_dec(&cmd->sync_cmd);\r\nwake_up(&mhba->int_cmd_wait_q);\r\n}\r\n}\r\nstatic void mvumi_show_event(struct mvumi_hba *mhba,\r\nstruct mvumi_driver_event *ptr)\r\n{\r\nunsigned int i;\r\ndev_warn(&mhba->pdev->dev,\r\n"Event[0x%x] id[0x%x] severity[0x%x] device id[0x%x]\n",\r\nptr->sequence_no, ptr->event_id, ptr->severity, ptr->device_id);\r\nif (ptr->param_count) {\r\nprintk(KERN_WARNING "Event param(len 0x%x): ",\r\nptr->param_count);\r\nfor (i = 0; i < ptr->param_count; i++)\r\nprintk(KERN_WARNING "0x%x ", ptr->params[i]);\r\nprintk(KERN_WARNING "\n");\r\n}\r\nif (ptr->sense_data_length) {\r\nprintk(KERN_WARNING "Event sense data(len 0x%x): ",\r\nptr->sense_data_length);\r\nfor (i = 0; i < ptr->sense_data_length; i++)\r\nprintk(KERN_WARNING "0x%x ", ptr->sense_data[i]);\r\nprintk(KERN_WARNING "\n");\r\n}\r\n}\r\nstatic void mvumi_notification(struct mvumi_hba *mhba, u8 msg, void *buffer)\r\n{\r\nif (msg == APICDB1_EVENT_GETEVENT) {\r\nint i, count;\r\nstruct mvumi_driver_event *param = NULL;\r\nstruct mvumi_event_req *er = buffer;\r\ncount = er->count;\r\nif (count > MAX_EVENTS_RETURNED) {\r\ndev_err(&mhba->pdev->dev, "event count[0x%x] is bigger"\r\n" than max event count[0x%x].\n",\r\ncount, MAX_EVENTS_RETURNED);\r\nreturn;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nparam = &er->events[i];\r\nmvumi_show_event(mhba, param);\r\n}\r\n}\r\n}\r\nstatic int mvumi_get_event(struct mvumi_hba *mhba, unsigned char msg)\r\n{\r\nstruct mvumi_cmd *cmd;\r\nstruct mvumi_msg_frame *frame;\r\ncmd = mvumi_create_internal_cmd(mhba, 512);\r\nif (!cmd)\r\nreturn -1;\r\ncmd->scmd = NULL;\r\ncmd->cmd_status = REQ_STATUS_PENDING;\r\natomic_set(&cmd->sync_cmd, 0);\r\nframe = cmd->frame;\r\nframe->device_id = 0;\r\nframe->cmd_flag = CMD_FLAG_DATA_IN;\r\nframe->req_function = CL_FUN_SCSI_CMD;\r\nframe->cdb_length = MAX_COMMAND_SIZE;\r\nframe->data_transfer_length = sizeof(struct mvumi_event_req);\r\nmemset(frame->cdb, 0, MAX_COMMAND_SIZE);\r\nframe->cdb[0] = APICDB0_EVENT;\r\nframe->cdb[1] = msg;\r\nmvumi_issue_blocked_cmd(mhba, cmd);\r\nif (cmd->cmd_status != SAM_STAT_GOOD)\r\ndev_err(&mhba->pdev->dev, "get event failed, status=0x%x.\n",\r\ncmd->cmd_status);\r\nelse\r\nmvumi_notification(mhba, cmd->frame->cdb[1], cmd->data_buf);\r\nmvumi_delete_internal_cmd(mhba, cmd);\r\nreturn 0;\r\n}\r\nstatic void mvumi_scan_events(struct work_struct *work)\r\n{\r\nstruct mvumi_events_wq *mu_ev =\r\ncontainer_of(work, struct mvumi_events_wq, work_q);\r\nmvumi_get_event(mu_ev->mhba, mu_ev->event);\r\nkfree(mu_ev);\r\n}\r\nstatic void mvumi_launch_events(struct mvumi_hba *mhba, u8 msg)\r\n{\r\nstruct mvumi_events_wq *mu_ev;\r\nmu_ev = kzalloc(sizeof(*mu_ev), GFP_ATOMIC);\r\nif (mu_ev) {\r\nINIT_WORK(&mu_ev->work_q, mvumi_scan_events);\r\nmu_ev->mhba = mhba;\r\nmu_ev->event = msg;\r\nmu_ev->param = NULL;\r\nschedule_work(&mu_ev->work_q);\r\n}\r\n}\r\nstatic void mvumi_handle_clob(struct mvumi_hba *mhba)\r\n{\r\nstruct mvumi_rsp_frame *ob_frame;\r\nstruct mvumi_cmd *cmd;\r\nstruct mvumi_ob_data *pool;\r\nwhile (!list_empty(&mhba->free_ob_list)) {\r\npool = list_first_entry(&mhba->free_ob_list,\r\nstruct mvumi_ob_data, list);\r\nlist_del_init(&pool->list);\r\nlist_add_tail(&pool->list, &mhba->ob_data_list);\r\nob_frame = (struct mvumi_rsp_frame *) &pool->data[0];\r\ncmd = mhba->tag_cmd[ob_frame->tag];\r\natomic_dec(&mhba->fw_outstanding);\r\nmhba->tag_cmd[ob_frame->tag] = 0;\r\ntag_release_one(mhba, &mhba->tag_pool, ob_frame->tag);\r\nif (cmd->scmd)\r\nmvumi_complete_cmd(mhba, cmd, ob_frame);\r\nelse\r\nmvumi_complete_internal_cmd(mhba, cmd, ob_frame);\r\n}\r\nmhba->instancet->fire_cmd(mhba, NULL);\r\n}\r\nstatic irqreturn_t mvumi_isr_handler(int irq, void *devp)\r\n{\r\nstruct mvumi_hba *mhba = (struct mvumi_hba *) devp;\r\nunsigned long flags;\r\nspin_lock_irqsave(mhba->shost->host_lock, flags);\r\nif (unlikely(mhba->instancet->clear_intr(mhba) || !mhba->global_isr)) {\r\nspin_unlock_irqrestore(mhba->shost->host_lock, flags);\r\nreturn IRQ_NONE;\r\n}\r\nif (mhba->global_isr & INT_MAP_DL_CPU2PCIEA) {\r\nif (mhba->isr_status & DRBL_HANDSHAKE_ISR) {\r\ndev_warn(&mhba->pdev->dev, "enter handshake again!\n");\r\nmvumi_handshake(mhba);\r\n}\r\nif (mhba->isr_status & DRBL_EVENT_NOTIFY)\r\nmvumi_launch_events(mhba, APICDB1_EVENT_GETEVENT);\r\n}\r\nif (mhba->global_isr & INT_MAP_COMAOUT)\r\nmvumi_receive_ob_list_entry(mhba);\r\nmhba->global_isr = 0;\r\nmhba->isr_status = 0;\r\nif (mhba->fw_state == FW_STATE_STARTED)\r\nmvumi_handle_clob(mhba);\r\nspin_unlock_irqrestore(mhba->shost->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic enum mvumi_qc_result mvumi_send_command(struct mvumi_hba *mhba,\r\nstruct mvumi_cmd *cmd)\r\n{\r\nvoid *ib_entry;\r\nstruct mvumi_msg_frame *ib_frame;\r\nunsigned int frame_len;\r\nib_frame = cmd->frame;\r\nif (unlikely(mhba->fw_state != FW_STATE_STARTED)) {\r\ndev_dbg(&mhba->pdev->dev, "firmware not ready.\n");\r\nreturn MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;\r\n}\r\nif (tag_is_empty(&mhba->tag_pool)) {\r\ndev_dbg(&mhba->pdev->dev, "no free tag.\n");\r\nreturn MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;\r\n}\r\nif (mvumi_get_ib_list_entry(mhba, &ib_entry))\r\nreturn MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;\r\ncmd->frame->tag = tag_get_one(mhba, &mhba->tag_pool);\r\ncmd->frame->request_id = mhba->io_seq++;\r\ncmd->request_id = cmd->frame->request_id;\r\nmhba->tag_cmd[cmd->frame->tag] = cmd;\r\nframe_len = sizeof(*ib_frame) - 4 +\r\nib_frame->sg_counts * sizeof(struct mvumi_sgl);\r\nmemcpy(ib_entry, ib_frame, frame_len);\r\nreturn MV_QUEUE_COMMAND_RESULT_SENT;\r\n}\r\nstatic void mvumi_fire_cmd(struct mvumi_hba *mhba, struct mvumi_cmd *cmd)\r\n{\r\nunsigned short num_of_cl_sent = 0;\r\nenum mvumi_qc_result result;\r\nif (cmd)\r\nlist_add_tail(&cmd->queue_pointer, &mhba->waiting_req_list);\r\nwhile (!list_empty(&mhba->waiting_req_list)) {\r\ncmd = list_first_entry(&mhba->waiting_req_list,\r\nstruct mvumi_cmd, queue_pointer);\r\nlist_del_init(&cmd->queue_pointer);\r\nresult = mvumi_send_command(mhba, cmd);\r\nswitch (result) {\r\ncase MV_QUEUE_COMMAND_RESULT_SENT:\r\nnum_of_cl_sent++;\r\nbreak;\r\ncase MV_QUEUE_COMMAND_RESULT_NO_RESOURCE:\r\nlist_add(&cmd->queue_pointer, &mhba->waiting_req_list);\r\nif (num_of_cl_sent > 0)\r\nmvumi_send_ib_list_entry(mhba);\r\nreturn;\r\n}\r\n}\r\nif (num_of_cl_sent > 0)\r\nmvumi_send_ib_list_entry(mhba);\r\n}\r\nstatic void mvumi_enable_intr(void *regs)\r\n{\r\nunsigned int mask;\r\niowrite32(0x3FFFFFFF, regs + CPU_ARM_TO_PCIEA_MASK_REG);\r\nmask = ioread32(regs + CPU_ENPOINTA_MASK_REG);\r\nmask |= INT_MAP_DL_CPU2PCIEA | INT_MAP_COMAOUT | INT_MAP_COMAERR;\r\niowrite32(mask, regs + CPU_ENPOINTA_MASK_REG);\r\n}\r\nstatic void mvumi_disable_intr(void *regs)\r\n{\r\nunsigned int mask;\r\niowrite32(0, regs + CPU_ARM_TO_PCIEA_MASK_REG);\r\nmask = ioread32(regs + CPU_ENPOINTA_MASK_REG);\r\nmask &= ~(INT_MAP_DL_CPU2PCIEA | INT_MAP_COMAOUT | INT_MAP_COMAERR);\r\niowrite32(mask, regs + CPU_ENPOINTA_MASK_REG);\r\n}\r\nstatic int mvumi_clear_intr(void *extend)\r\n{\r\nstruct mvumi_hba *mhba = (struct mvumi_hba *) extend;\r\nunsigned int status, isr_status = 0, tmp = 0;\r\nvoid *regs = mhba->mmio;\r\nstatus = ioread32(regs + CPU_MAIN_INT_CAUSE_REG);\r\nif (!(status & INT_MAP_MU) || status == 0xFFFFFFFF)\r\nreturn 1;\r\nif (unlikely(status & INT_MAP_COMAERR)) {\r\ntmp = ioread32(regs + CLA_ISR_CAUSE);\r\nif (tmp & (CLIC_IN_ERR_IRQ | CLIC_OUT_ERR_IRQ))\r\niowrite32(tmp & (CLIC_IN_ERR_IRQ | CLIC_OUT_ERR_IRQ),\r\nregs + CLA_ISR_CAUSE);\r\nstatus ^= INT_MAP_COMAERR;\r\n}\r\nif (status & INT_MAP_COMAOUT) {\r\ntmp = ioread32(regs + CLA_ISR_CAUSE);\r\nif (tmp & CLIC_OUT_IRQ)\r\niowrite32(tmp & CLIC_OUT_IRQ, regs + CLA_ISR_CAUSE);\r\n}\r\nif (status & INT_MAP_DL_CPU2PCIEA) {\r\nisr_status = ioread32(regs + CPU_ARM_TO_PCIEA_DRBL_REG);\r\nif (isr_status)\r\niowrite32(isr_status, regs + CPU_ARM_TO_PCIEA_DRBL_REG);\r\n}\r\nmhba->global_isr = status;\r\nmhba->isr_status = isr_status;\r\nreturn 0;\r\n}\r\nstatic unsigned int mvumi_read_fw_status_reg(void *regs)\r\n{\r\nunsigned int status;\r\nstatus = ioread32(regs + CPU_ARM_TO_PCIEA_DRBL_REG);\r\nif (status)\r\niowrite32(status, regs + CPU_ARM_TO_PCIEA_DRBL_REG);\r\nreturn status;\r\n}\r\nstatic int mvumi_slave_configure(struct scsi_device *sdev)\r\n{\r\nstruct mvumi_hba *mhba;\r\nunsigned char bitcount = sizeof(unsigned char) * 8;\r\nmhba = (struct mvumi_hba *) sdev->host->hostdata;\r\nif (sdev->id >= mhba->max_target_id)\r\nreturn -EINVAL;\r\nmhba->target_map[sdev->id / bitcount] |= (1 << (sdev->id % bitcount));\r\nreturn 0;\r\n}\r\nstatic unsigned char mvumi_build_frame(struct mvumi_hba *mhba,\r\nstruct scsi_cmnd *scmd, struct mvumi_cmd *cmd)\r\n{\r\nstruct mvumi_msg_frame *pframe;\r\ncmd->scmd = scmd;\r\ncmd->cmd_status = REQ_STATUS_PENDING;\r\npframe = cmd->frame;\r\npframe->device_id = ((unsigned short) scmd->device->id) |\r\n(((unsigned short) scmd->device->lun) << 8);\r\npframe->cmd_flag = 0;\r\nswitch (scmd->sc_data_direction) {\r\ncase DMA_NONE:\r\npframe->cmd_flag |= CMD_FLAG_NON_DATA;\r\nbreak;\r\ncase DMA_FROM_DEVICE:\r\npframe->cmd_flag |= CMD_FLAG_DATA_IN;\r\nbreak;\r\ncase DMA_TO_DEVICE:\r\npframe->cmd_flag |= CMD_FLAG_DATA_OUT;\r\nbreak;\r\ncase DMA_BIDIRECTIONAL:\r\ndefault:\r\ndev_warn(&mhba->pdev->dev, "unexpected data direction[%d] "\r\n"cmd[0x%x]\n", scmd->sc_data_direction, scmd->cmnd[0]);\r\ngoto error;\r\n}\r\npframe->cdb_length = scmd->cmd_len;\r\nmemcpy(pframe->cdb, scmd->cmnd, pframe->cdb_length);\r\npframe->req_function = CL_FUN_SCSI_CMD;\r\nif (scsi_bufflen(scmd)) {\r\nif (mvumi_make_sgl(mhba, scmd, &pframe->payload[0],\r\n&pframe->sg_counts))\r\ngoto error;\r\npframe->data_transfer_length = scsi_bufflen(scmd);\r\n} else {\r\npframe->sg_counts = 0;\r\npframe->data_transfer_length = 0;\r\n}\r\nreturn 0;\r\nerror:\r\nscmd->result = (DID_OK << 16) | (DRIVER_SENSE << 24) |\r\nSAM_STAT_CHECK_CONDITION;\r\nscsi_build_sense_buffer(0, scmd->sense_buffer, ILLEGAL_REQUEST, 0x24,\r\n0);\r\nreturn -1;\r\n}\r\nstatic int mvumi_queue_command(struct Scsi_Host *shost,\r\nstruct scsi_cmnd *scmd)\r\n{\r\nstruct mvumi_cmd *cmd;\r\nstruct mvumi_hba *mhba;\r\nunsigned long irq_flags;\r\nspin_lock_irqsave(shost->host_lock, irq_flags);\r\nscsi_cmd_get_serial(shost, scmd);\r\nmhba = (struct mvumi_hba *) shost->hostdata;\r\nscmd->result = 0;\r\ncmd = mvumi_get_cmd(mhba);\r\nif (unlikely(!cmd)) {\r\nspin_unlock_irqrestore(shost->host_lock, irq_flags);\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\nif (unlikely(mvumi_build_frame(mhba, scmd, cmd)))\r\ngoto out_return_cmd;\r\ncmd->scmd = scmd;\r\nscmd->SCp.ptr = (char *) cmd;\r\nmhba->instancet->fire_cmd(mhba, cmd);\r\nspin_unlock_irqrestore(shost->host_lock, irq_flags);\r\nreturn 0;\r\nout_return_cmd:\r\nmvumi_return_cmd(mhba, cmd);\r\nscmd->scsi_done(scmd);\r\nspin_unlock_irqrestore(shost->host_lock, irq_flags);\r\nreturn 0;\r\n}\r\nstatic enum blk_eh_timer_return mvumi_timed_out(struct scsi_cmnd *scmd)\r\n{\r\nstruct mvumi_cmd *cmd = (struct mvumi_cmd *) scmd->SCp.ptr;\r\nstruct Scsi_Host *host = scmd->device->host;\r\nstruct mvumi_hba *mhba = shost_priv(host);\r\nunsigned long flags;\r\nspin_lock_irqsave(mhba->shost->host_lock, flags);\r\nif (mhba->tag_cmd[cmd->frame->tag]) {\r\nmhba->tag_cmd[cmd->frame->tag] = 0;\r\ntag_release_one(mhba, &mhba->tag_pool, cmd->frame->tag);\r\n}\r\nif (!list_empty(&cmd->queue_pointer))\r\nlist_del_init(&cmd->queue_pointer);\r\nelse\r\natomic_dec(&mhba->fw_outstanding);\r\nscmd->result = (DRIVER_INVALID << 24) | (DID_ABORT << 16);\r\nscmd->SCp.ptr = NULL;\r\nif (scsi_bufflen(scmd)) {\r\nif (scsi_sg_count(scmd)) {\r\npci_unmap_sg(mhba->pdev,\r\nscsi_sglist(scmd),\r\nscsi_sg_count(scmd),\r\n(int)scmd->sc_data_direction);\r\n} else {\r\npci_unmap_single(mhba->pdev,\r\nscmd->SCp.dma_handle,\r\nscsi_bufflen(scmd),\r\n(int)scmd->sc_data_direction);\r\nscmd->SCp.dma_handle = 0;\r\n}\r\n}\r\nmvumi_return_cmd(mhba, cmd);\r\nspin_unlock_irqrestore(mhba->shost->host_lock, flags);\r\nreturn BLK_EH_NOT_HANDLED;\r\n}\r\nstatic int\r\nmvumi_bios_param(struct scsi_device *sdev, struct block_device *bdev,\r\nsector_t capacity, int geom[])\r\n{\r\nint heads, sectors;\r\nsector_t cylinders;\r\nunsigned long tmp;\r\nheads = 64;\r\nsectors = 32;\r\ntmp = heads * sectors;\r\ncylinders = capacity;\r\nsector_div(cylinders, tmp);\r\nif (capacity >= 0x200000) {\r\nheads = 255;\r\nsectors = 63;\r\ntmp = heads * sectors;\r\ncylinders = capacity;\r\nsector_div(cylinders, tmp);\r\n}\r\ngeom[0] = heads;\r\ngeom[1] = sectors;\r\ngeom[2] = cylinders;\r\nreturn 0;\r\n}\r\nstatic int mvumi_init_fw(struct mvumi_hba *mhba)\r\n{\r\nint ret = 0;\r\nif (pci_request_regions(mhba->pdev, MV_DRIVER_NAME)) {\r\ndev_err(&mhba->pdev->dev, "IO memory region busy!\n");\r\nreturn -EBUSY;\r\n}\r\nret = mvumi_map_pci_addr(mhba->pdev, mhba->base_addr);\r\nif (ret)\r\ngoto fail_ioremap;\r\nmhba->mmio = mhba->base_addr[0];\r\nswitch (mhba->pdev->device) {\r\ncase PCI_DEVICE_ID_MARVELL_MV9143:\r\nmhba->instancet = &mvumi_instance_template;\r\nmhba->io_seq = 0;\r\nmhba->max_sge = MVUMI_MAX_SG_ENTRY;\r\nmhba->request_id_enabled = 1;\r\nbreak;\r\ndefault:\r\ndev_err(&mhba->pdev->dev, "device 0x%x not supported!\n",\r\nmhba->pdev->device);\r\nmhba->instancet = NULL;\r\nret = -EINVAL;\r\ngoto fail_alloc_mem;\r\n}\r\ndev_dbg(&mhba->pdev->dev, "device id : %04X is found.\n",\r\nmhba->pdev->device);\r\nmhba->handshake_page = kzalloc(HSP_MAX_SIZE, GFP_KERNEL);\r\nif (!mhba->handshake_page) {\r\ndev_err(&mhba->pdev->dev,\r\n"failed to allocate memory for handshake\n");\r\nret = -ENOMEM;\r\ngoto fail_alloc_mem;\r\n}\r\nmhba->handshake_page_phys = virt_to_phys(mhba->handshake_page);\r\nif (mvumi_start(mhba)) {\r\nret = -EINVAL;\r\ngoto fail_ready_state;\r\n}\r\nret = mvumi_alloc_cmds(mhba);\r\nif (ret)\r\ngoto fail_ready_state;\r\nreturn 0;\r\nfail_ready_state:\r\nmvumi_release_mem_resource(mhba);\r\nkfree(mhba->handshake_page);\r\nfail_alloc_mem:\r\nmvumi_unmap_pci_addr(mhba->pdev, mhba->base_addr);\r\nfail_ioremap:\r\npci_release_regions(mhba->pdev);\r\nreturn ret;\r\n}\r\nstatic int mvumi_io_attach(struct mvumi_hba *mhba)\r\n{\r\nstruct Scsi_Host *host = mhba->shost;\r\nint ret;\r\nunsigned int max_sg = (mhba->ib_max_size + 4 -\r\nsizeof(struct mvumi_msg_frame)) / sizeof(struct mvumi_sgl);\r\nhost->irq = mhba->pdev->irq;\r\nhost->unique_id = mhba->unique_id;\r\nhost->can_queue = (mhba->max_io - 1) ? (mhba->max_io - 1) : 1;\r\nhost->sg_tablesize = mhba->max_sge > max_sg ? max_sg : mhba->max_sge;\r\nhost->max_sectors = mhba->max_transfer_size / 512;\r\nhost->cmd_per_lun = (mhba->max_io - 1) ? (mhba->max_io - 1) : 1;\r\nhost->max_id = mhba->max_target_id;\r\nhost->max_cmd_len = MAX_COMMAND_SIZE;\r\nhost->transportt = &mvumi_transport_template;\r\nret = scsi_add_host(host, &mhba->pdev->dev);\r\nif (ret) {\r\ndev_err(&mhba->pdev->dev, "scsi_add_host failed\n");\r\nreturn ret;\r\n}\r\nmhba->fw_flag |= MVUMI_FW_ATTACH;\r\nscsi_scan_host(host);\r\nreturn 0;\r\n}\r\nstatic int __devinit mvumi_probe_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct Scsi_Host *host;\r\nstruct mvumi_hba *mhba;\r\nint ret;\r\ndev_dbg(&pdev->dev, " %#4.04x:%#4.04x:%#4.04x:%#4.04x: ",\r\npdev->vendor, pdev->device, pdev->subsystem_vendor,\r\npdev->subsystem_device);\r\nret = pci_enable_device(pdev);\r\nif (ret)\r\nreturn ret;\r\npci_set_master(pdev);\r\nif (IS_DMA64) {\r\nret = pci_set_dma_mask(pdev, DMA_BIT_MASK(64));\r\nif (ret) {\r\nret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (ret)\r\ngoto fail_set_dma_mask;\r\n}\r\n} else {\r\nret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (ret)\r\ngoto fail_set_dma_mask;\r\n}\r\nhost = scsi_host_alloc(&mvumi_template, sizeof(*mhba));\r\nif (!host) {\r\ndev_err(&pdev->dev, "scsi_host_alloc failed\n");\r\nret = -ENOMEM;\r\ngoto fail_alloc_instance;\r\n}\r\nmhba = shost_priv(host);\r\nINIT_LIST_HEAD(&mhba->cmd_pool);\r\nINIT_LIST_HEAD(&mhba->ob_data_list);\r\nINIT_LIST_HEAD(&mhba->free_ob_list);\r\nINIT_LIST_HEAD(&mhba->res_list);\r\nINIT_LIST_HEAD(&mhba->waiting_req_list);\r\natomic_set(&mhba->fw_outstanding, 0);\r\ninit_waitqueue_head(&mhba->int_cmd_wait_q);\r\nmhba->pdev = pdev;\r\nmhba->shost = host;\r\nmhba->unique_id = pdev->bus->number << 8 | pdev->devfn;\r\nret = mvumi_init_fw(mhba);\r\nif (ret)\r\ngoto fail_init_fw;\r\nret = request_irq(mhba->pdev->irq, mvumi_isr_handler, IRQF_SHARED,\r\n"mvumi", mhba);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register IRQ\n");\r\ngoto fail_init_irq;\r\n}\r\nmhba->instancet->enable_intr(mhba->mmio);\r\npci_set_drvdata(pdev, mhba);\r\nret = mvumi_io_attach(mhba);\r\nif (ret)\r\ngoto fail_io_attach;\r\ndev_dbg(&pdev->dev, "probe mvumi driver successfully.\n");\r\nreturn 0;\r\nfail_io_attach:\r\npci_set_drvdata(pdev, NULL);\r\nmhba->instancet->disable_intr(mhba->mmio);\r\nfree_irq(mhba->pdev->irq, mhba);\r\nfail_init_irq:\r\nmvumi_release_fw(mhba);\r\nfail_init_fw:\r\nscsi_host_put(host);\r\nfail_alloc_instance:\r\nfail_set_dma_mask:\r\npci_disable_device(pdev);\r\nreturn ret;\r\n}\r\nstatic void mvumi_detach_one(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *host;\r\nstruct mvumi_hba *mhba;\r\nmhba = pci_get_drvdata(pdev);\r\nhost = mhba->shost;\r\nscsi_remove_host(mhba->shost);\r\nmvumi_flush_cache(mhba);\r\nmhba->instancet->disable_intr(mhba->mmio);\r\nfree_irq(mhba->pdev->irq, mhba);\r\nmvumi_release_fw(mhba);\r\nscsi_host_put(host);\r\npci_set_drvdata(pdev, NULL);\r\npci_disable_device(pdev);\r\ndev_dbg(&pdev->dev, "driver is removed!\n");\r\n}\r\nstatic void mvumi_shutdown(struct pci_dev *pdev)\r\n{\r\nstruct mvumi_hba *mhba = pci_get_drvdata(pdev);\r\nmvumi_flush_cache(mhba);\r\n}\r\nstatic int mvumi_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct mvumi_hba *mhba = NULL;\r\nmhba = pci_get_drvdata(pdev);\r\nmvumi_flush_cache(mhba);\r\npci_set_drvdata(pdev, mhba);\r\nmhba->instancet->disable_intr(mhba->mmio);\r\nfree_irq(mhba->pdev->irq, mhba);\r\nmvumi_unmap_pci_addr(pdev, mhba->base_addr);\r\npci_release_regions(pdev);\r\npci_save_state(pdev);\r\npci_disable_device(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nstatic int mvumi_resume(struct pci_dev *pdev)\r\n{\r\nint ret;\r\nstruct mvumi_hba *mhba = NULL;\r\nmhba = pci_get_drvdata(pdev);\r\npci_set_power_state(pdev, PCI_D0);\r\npci_enable_wake(pdev, PCI_D0, 0);\r\npci_restore_state(pdev);\r\nret = pci_enable_device(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "enable device failed\n");\r\nreturn ret;\r\n}\r\npci_set_master(pdev);\r\nif (IS_DMA64) {\r\nret = pci_set_dma_mask(pdev, DMA_BIT_MASK(64));\r\nif (ret) {\r\nret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (ret)\r\ngoto fail;\r\n}\r\n} else {\r\nret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (ret)\r\ngoto fail;\r\n}\r\nret = pci_request_regions(mhba->pdev, MV_DRIVER_NAME);\r\nif (ret)\r\ngoto fail;\r\nret = mvumi_map_pci_addr(mhba->pdev, mhba->base_addr);\r\nif (ret)\r\ngoto release_regions;\r\nmhba->mmio = mhba->base_addr[0];\r\nmvumi_reset(mhba->mmio);\r\nif (mvumi_start(mhba)) {\r\nret = -EINVAL;\r\ngoto unmap_pci_addr;\r\n}\r\nret = request_irq(mhba->pdev->irq, mvumi_isr_handler, IRQF_SHARED,\r\n"mvumi", mhba);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register IRQ\n");\r\ngoto unmap_pci_addr;\r\n}\r\nmhba->instancet->enable_intr(mhba->mmio);\r\nreturn 0;\r\nunmap_pci_addr:\r\nmvumi_unmap_pci_addr(pdev, mhba->base_addr);\r\nrelease_regions:\r\npci_release_regions(pdev);\r\nfail:\r\npci_disable_device(pdev);\r\nreturn ret;\r\n}\r\nstatic int __init mvumi_init(void)\r\n{\r\nreturn pci_register_driver(&mvumi_pci_driver);\r\n}\r\nstatic void __exit mvumi_exit(void)\r\n{\r\npci_unregister_driver(&mvumi_pci_driver);\r\n}
