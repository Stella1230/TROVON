static inline u_char\r\nreadreg(unsigned int adr, u_short off)\r\n{\r\nreturn bytein(adr + off);\r\n}\r\nstatic inline void\r\nwritereg(unsigned int adr, u_short off, u_char data)\r\n{\r\nbyteout(adr + off, data);\r\n}\r\nstatic inline void\r\nread_fifo(unsigned int adr, u_char * data, int size)\r\n{\r\ninsb(adr, data, size);\r\n}\r\nstatic void\r\nwrite_fifo(unsigned int adr, u_char * data, int size)\r\n{\r\noutsb(adr, data, size);\r\n}\r\nstatic inline u_char\r\nreadreg_ipac(unsigned int adr, u_short off)\r\n{\r\nregister u_char ret;\r\nbyteout(adr, off);\r\nret = bytein(adr + 4);\r\nreturn ret;\r\n}\r\nstatic inline void\r\nwritereg_ipac(unsigned int adr, u_short off, u_char data)\r\n{\r\nbyteout(adr, off);\r\nbyteout(adr + 4, data);\r\n}\r\nstatic inline void\r\nread_fifo_ipac(unsigned int adr, u_short off, u_char * data, int size)\r\n{\r\nbyteout(adr, off);\r\ninsb(adr + 4, data, size);\r\n}\r\nstatic void\r\nwrite_fifo_ipac(unsigned int adr, u_short off, u_char * data, int size)\r\n{\r\nbyteout(adr, off);\r\noutsb(adr + 4, data, size);\r\n}\r\nstatic u_char\r\nReadISAC(struct IsdnCardState *cs, u_char offset)\r\n{\r\nu_short off2 = offset;\r\nswitch (cs->subtyp) {\r\ncase R647:\r\noff2 = ((off2 << 8 & 0xf000) | (off2 & 0xf));\r\ncase R685:\r\nreturn (readreg(cs->hw.gazel.isac, off2));\r\ncase R753:\r\ncase R742:\r\nreturn (readreg_ipac(cs->hw.gazel.ipac, 0x80 + off2));\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nWriteISAC(struct IsdnCardState *cs, u_char offset, u_char value)\r\n{\r\nu_short off2 = offset;\r\nswitch (cs->subtyp) {\r\ncase R647:\r\noff2 = ((off2 << 8 & 0xf000) | (off2 & 0xf));\r\ncase R685:\r\nwritereg(cs->hw.gazel.isac, off2, value);\r\nbreak;\r\ncase R753:\r\ncase R742:\r\nwritereg_ipac(cs->hw.gazel.ipac, 0x80 + off2, value);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nReadISACfifo(struct IsdnCardState *cs, u_char * data, int size)\r\n{\r\nswitch (cs->subtyp) {\r\ncase R647:\r\ncase R685:\r\nread_fifo(cs->hw.gazel.isacfifo, data, size);\r\nbreak;\r\ncase R753:\r\ncase R742:\r\nread_fifo_ipac(cs->hw.gazel.ipac, 0x80, data, size);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nWriteISACfifo(struct IsdnCardState *cs, u_char * data, int size)\r\n{\r\nswitch (cs->subtyp) {\r\ncase R647:\r\ncase R685:\r\nwrite_fifo(cs->hw.gazel.isacfifo, data, size);\r\nbreak;\r\ncase R753:\r\ncase R742:\r\nwrite_fifo_ipac(cs->hw.gazel.ipac, 0x80, data, size);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nReadHSCXfifo(struct IsdnCardState *cs, int hscx, u_char * data, int size)\r\n{\r\nswitch (cs->subtyp) {\r\ncase R647:\r\ncase R685:\r\nread_fifo(cs->hw.gazel.hscxfifo[hscx], data, size);\r\nbreak;\r\ncase R753:\r\ncase R742:\r\nread_fifo_ipac(cs->hw.gazel.ipac, hscx * 0x40, data, size);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nWriteHSCXfifo(struct IsdnCardState *cs, int hscx, u_char * data, int size)\r\n{\r\nswitch (cs->subtyp) {\r\ncase R647:\r\ncase R685:\r\nwrite_fifo(cs->hw.gazel.hscxfifo[hscx], data, size);\r\nbreak;\r\ncase R753:\r\ncase R742:\r\nwrite_fifo_ipac(cs->hw.gazel.ipac, hscx * 0x40, data, size);\r\nbreak;\r\n}\r\n}\r\nstatic u_char\r\nReadHSCX(struct IsdnCardState *cs, int hscx, u_char offset)\r\n{\r\nu_short off2 = offset;\r\nswitch (cs->subtyp) {\r\ncase R647:\r\noff2 = ((off2 << 8 & 0xf000) | (off2 & 0xf));\r\ncase R685:\r\nreturn (readreg(cs->hw.gazel.hscx[hscx], off2));\r\ncase R753:\r\ncase R742:\r\nreturn (readreg_ipac(cs->hw.gazel.ipac, hscx * 0x40 + off2));\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nWriteHSCX(struct IsdnCardState *cs, int hscx, u_char offset, u_char value)\r\n{\r\nu_short off2 = offset;\r\nswitch (cs->subtyp) {\r\ncase R647:\r\noff2 = ((off2 << 8 & 0xf000) | (off2 & 0xf));\r\ncase R685:\r\nwritereg(cs->hw.gazel.hscx[hscx], off2, value);\r\nbreak;\r\ncase R753:\r\ncase R742:\r\nwritereg_ipac(cs->hw.gazel.ipac, hscx * 0x40 + off2, value);\r\nbreak;\r\n}\r\n}\r\nstatic irqreturn_t\r\ngazel_interrupt(int intno, void *dev_id)\r\n{\r\n#define MAXCOUNT 5\r\nstruct IsdnCardState *cs = dev_id;\r\nu_char valisac, valhscx;\r\nint count = 0;\r\nu_long flags;\r\nspin_lock_irqsave(&cs->lock, flags);\r\ndo {\r\nvalhscx = ReadHSCX(cs, 1, HSCX_ISTA);\r\nif (valhscx)\r\nhscx_int_main(cs, valhscx);\r\nvalisac = ReadISAC(cs, ISAC_ISTA);\r\nif (valisac)\r\nisac_interrupt(cs, valisac);\r\ncount++;\r\n} while ((valhscx || valisac) && (count < MAXCOUNT));\r\nWriteHSCX(cs, 0, HSCX_MASK, 0xFF);\r\nWriteHSCX(cs, 1, HSCX_MASK, 0xFF);\r\nWriteISAC(cs, ISAC_MASK, 0xFF);\r\nWriteISAC(cs, ISAC_MASK, 0x0);\r\nWriteHSCX(cs, 0, HSCX_MASK, 0x0);\r\nWriteHSCX(cs, 1, HSCX_MASK, 0x0);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\ngazel_interrupt_ipac(int intno, void *dev_id)\r\n{\r\nstruct IsdnCardState *cs = dev_id;\r\nu_char ista, val;\r\nint count = 0;\r\nu_long flags;\r\nspin_lock_irqsave(&cs->lock, flags);\r\nista = ReadISAC(cs, IPAC_ISTA - 0x80);\r\ndo {\r\nif (ista & 0x0f) {\r\nval = ReadHSCX(cs, 1, HSCX_ISTA);\r\nif (ista & 0x01)\r\nval |= 0x01;\r\nif (ista & 0x04)\r\nval |= 0x02;\r\nif (ista & 0x08)\r\nval |= 0x04;\r\nif (val) {\r\nhscx_int_main(cs, val);\r\n}\r\n}\r\nif (ista & 0x20) {\r\nval = 0xfe & ReadISAC(cs, ISAC_ISTA);\r\nif (val) {\r\nisac_interrupt(cs, val);\r\n}\r\n}\r\nif (ista & 0x10) {\r\nval = 0x01;\r\nisac_interrupt(cs, val);\r\n}\r\nista = ReadISAC(cs, IPAC_ISTA - 0x80);\r\ncount++;\r\n}\r\nwhile ((ista & 0x3f) && (count < MAXCOUNT));\r\nWriteISAC(cs, IPAC_MASK - 0x80, 0xFF);\r\nWriteISAC(cs, IPAC_MASK - 0x80, 0xC0);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nrelease_io_gazel(struct IsdnCardState *cs)\r\n{\r\nunsigned int i;\r\nswitch (cs->subtyp) {\r\ncase R647:\r\nfor (i = 0x0000; i < 0xC000; i += 0x1000)\r\nrelease_region(i + cs->hw.gazel.hscx[0], 16);\r\nrelease_region(0xC000 + cs->hw.gazel.hscx[0], 1);\r\nbreak;\r\ncase R685:\r\nrelease_region(cs->hw.gazel.hscx[0], 0x100);\r\nrelease_region(cs->hw.gazel.cfg_reg, 0x80);\r\nbreak;\r\ncase R753:\r\nrelease_region(cs->hw.gazel.ipac, 0x8);\r\nrelease_region(cs->hw.gazel.cfg_reg, 0x80);\r\nbreak;\r\ncase R742:\r\nrelease_region(cs->hw.gazel.ipac, 8);\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nreset_gazel(struct IsdnCardState *cs)\r\n{\r\nunsigned long plxcntrl, addr = cs->hw.gazel.cfg_reg;\r\nswitch (cs->subtyp) {\r\ncase R647:\r\nwritereg(addr, 0, 0);\r\nHZDELAY(10);\r\nwritereg(addr, 0, 1);\r\nHZDELAY(2);\r\nbreak;\r\ncase R685:\r\nplxcntrl = inl(addr + PLX_CNTRL);\r\nplxcntrl |= (RESET_9050 + RESET_GAZEL);\r\noutl(plxcntrl, addr + PLX_CNTRL);\r\nplxcntrl &= ~(RESET_9050 + RESET_GAZEL);\r\nHZDELAY(4);\r\noutl(plxcntrl, addr + PLX_CNTRL);\r\nHZDELAY(10);\r\noutb(INT_ISAC_EN + INT_HSCX_EN + INT_PCI_EN, addr + PLX_INCSR);\r\nbreak;\r\ncase R753:\r\nplxcntrl = inl(addr + PLX_CNTRL);\r\nplxcntrl |= (RESET_9050 + RESET_GAZEL);\r\noutl(plxcntrl, addr + PLX_CNTRL);\r\nplxcntrl &= ~(RESET_9050 + RESET_GAZEL);\r\nWriteISAC(cs, IPAC_POTA2 - 0x80, 0x20);\r\nHZDELAY(4);\r\noutl(plxcntrl, addr + PLX_CNTRL);\r\nHZDELAY(10);\r\nWriteISAC(cs, IPAC_POTA2 - 0x80, 0x00);\r\nWriteISAC(cs, IPAC_ACFG - 0x80, 0xff);\r\nWriteISAC(cs, IPAC_AOE - 0x80, 0x0);\r\nWriteISAC(cs, IPAC_MASK - 0x80, 0xff);\r\nWriteISAC(cs, IPAC_CONF - 0x80, 0x1);\r\noutb(INT_IPAC_EN + INT_PCI_EN, addr + PLX_INCSR);\r\nWriteISAC(cs, IPAC_MASK - 0x80, 0xc0);\r\nbreak;\r\ncase R742:\r\nWriteISAC(cs, IPAC_POTA2 - 0x80, 0x20);\r\nHZDELAY(4);\r\nWriteISAC(cs, IPAC_POTA2 - 0x80, 0x00);\r\nWriteISAC(cs, IPAC_ACFG - 0x80, 0xff);\r\nWriteISAC(cs, IPAC_AOE - 0x80, 0x0);\r\nWriteISAC(cs, IPAC_MASK - 0x80, 0xff);\r\nWriteISAC(cs, IPAC_CONF - 0x80, 0x1);\r\nWriteISAC(cs, IPAC_MASK - 0x80, 0xc0);\r\nbreak;\r\n}\r\nreturn (0);\r\n}\r\nstatic int\r\nGazel_card_msg(struct IsdnCardState *cs, int mt, void *arg)\r\n{\r\nu_long flags;\r\nswitch (mt) {\r\ncase CARD_RESET:\r\nspin_lock_irqsave(&cs->lock, flags);\r\nreset_gazel(cs);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn (0);\r\ncase CARD_RELEASE:\r\nrelease_io_gazel(cs);\r\nreturn (0);\r\ncase CARD_INIT:\r\nspin_lock_irqsave(&cs->lock, flags);\r\ninithscxisac(cs, 1);\r\nif ((cs->subtyp==R647)||(cs->subtyp==R685)) {\r\nint i;\r\nfor (i=0;i<(2+MAX_WAITING_CALLS);i++) {\r\ncs->bcs[i].hw.hscx.tsaxr0 = 0x1f;\r\ncs->bcs[i].hw.hscx.tsaxr1 = 0x23;\r\n}\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn (0);\r\ncase CARD_TEST:\r\nreturn (0);\r\n}\r\nreturn (0);\r\n}\r\nstatic int\r\nreserve_regions(struct IsdnCard *card, struct IsdnCardState *cs)\r\n{\r\nunsigned int i, j, base = 0, adr = 0, len = 0;\r\nswitch (cs->subtyp) {\r\ncase R647:\r\nbase = cs->hw.gazel.hscx[0];\r\nif (!request_region(adr = (0xC000 + base), len = 1, "gazel"))\r\ngoto error;\r\nfor (i = 0x0000; i < 0xC000; i += 0x1000) {\r\nif (!request_region(adr = (i + base), len = 16, "gazel"))\r\ngoto error;\r\n}\r\nif (i != 0xC000) {\r\nfor (j = 0; j < i; j+= 0x1000)\r\nrelease_region(j + base, 16);\r\nrelease_region(0xC000 + base, 1);\r\ngoto error;\r\n}\r\nbreak;\r\ncase R685:\r\nif (!request_region(adr = cs->hw.gazel.hscx[0], len = 0x100, "gazel"))\r\ngoto error;\r\nif (!request_region(adr = cs->hw.gazel.cfg_reg, len = 0x80, "gazel")) {\r\nrelease_region(cs->hw.gazel.hscx[0],0x100);\r\ngoto error;\r\n}\r\nbreak;\r\ncase R753:\r\nif (!request_region(adr = cs->hw.gazel.ipac, len = 0x8, "gazel"))\r\ngoto error;\r\nif (!request_region(adr = cs->hw.gazel.cfg_reg, len = 0x80, "gazel")) {\r\nrelease_region(cs->hw.gazel.ipac, 8);\r\ngoto error;\r\n}\r\nbreak;\r\ncase R742:\r\nif (!request_region(adr = cs->hw.gazel.ipac, len = 0x8, "gazel"))\r\ngoto error;\r\nbreak;\r\n}\r\nreturn 0;\r\nerror:\r\nprintk(KERN_WARNING "Gazel: io ports 0x%x-0x%x already in use\n",\r\nadr, adr + len);\r\nreturn 1;\r\n}\r\nstatic int __devinit\r\nsetup_gazelisa(struct IsdnCard *card, struct IsdnCardState *cs)\r\n{\r\nprintk(KERN_INFO "Gazel: ISA PnP card automatic recognition\n");\r\nif (readreg_ipac(card->para[1], IPAC_ID) == 1)\r\ncs->subtyp = R742;\r\nelse\r\ncs->subtyp = R647;\r\nsetup_isac(cs);\r\ncs->hw.gazel.cfg_reg = card->para[1] + 0xC000;\r\ncs->hw.gazel.ipac = card->para[1];\r\ncs->hw.gazel.isac = card->para[1] + 0x8000;\r\ncs->hw.gazel.hscx[0] = card->para[1];\r\ncs->hw.gazel.hscx[1] = card->para[1] + 0x4000;\r\ncs->irq = card->para[0];\r\ncs->hw.gazel.isacfifo = cs->hw.gazel.isac;\r\ncs->hw.gazel.hscxfifo[0] = cs->hw.gazel.hscx[0];\r\ncs->hw.gazel.hscxfifo[1] = cs->hw.gazel.hscx[1];\r\nswitch (cs->subtyp) {\r\ncase R647:\r\nprintk(KERN_INFO "Gazel: Card ISA R647/R648 found\n");\r\ncs->dc.isac.adf2 = 0x87;\r\nprintk(KERN_INFO\r\n"Gazel: config irq:%d isac:0x%X cfg:0x%X\n",\r\ncs->irq, cs->hw.gazel.isac, cs->hw.gazel.cfg_reg);\r\nprintk(KERN_INFO\r\n"Gazel: hscx A:0x%X hscx B:0x%X\n",\r\ncs->hw.gazel.hscx[0], cs->hw.gazel.hscx[1]);\r\nbreak;\r\ncase R742:\r\nprintk(KERN_INFO "Gazel: Card ISA R742 found\n");\r\ntest_and_set_bit(HW_IPAC, &cs->HW_Flags);\r\nprintk(KERN_INFO\r\n"Gazel: config irq:%d ipac:0x%X\n",\r\ncs->irq, cs->hw.gazel.ipac);\r\nbreak;\r\n}\r\nreturn (0);\r\n}\r\nstatic int __devinit\r\nsetup_gazelpci(struct IsdnCardState *cs)\r\n{\r\nu_int pci_ioaddr0 = 0, pci_ioaddr1 = 0;\r\nu_char pci_irq = 0, found;\r\nu_int nbseek, seekcard;\r\nprintk(KERN_WARNING "Gazel: PCI card automatic recognition\n");\r\nfound = 0;\r\nseekcard = PCI_DEVICE_ID_PLX_R685;\r\nfor (nbseek = 0; nbseek < 4; nbseek++) {\r\nif ((dev_tel = hisax_find_pci_device(PCI_VENDOR_ID_PLX,\r\nseekcard, dev_tel))) {\r\nif (pci_enable_device(dev_tel))\r\nreturn 1;\r\npci_irq = dev_tel->irq;\r\npci_ioaddr0 = pci_resource_start(dev_tel, 1);\r\npci_ioaddr1 = pci_resource_start(dev_tel, 2);\r\nfound = 1;\r\n}\r\nif (found)\r\nbreak;\r\nelse {\r\nswitch (seekcard) {\r\ncase PCI_DEVICE_ID_PLX_R685:\r\nseekcard = PCI_DEVICE_ID_PLX_R753;\r\nbreak;\r\ncase PCI_DEVICE_ID_PLX_R753:\r\nseekcard = PCI_DEVICE_ID_PLX_DJINN_ITOO;\r\nbreak;\r\ncase PCI_DEVICE_ID_PLX_DJINN_ITOO:\r\nseekcard = PCI_DEVICE_ID_PLX_OLITEC;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!found) {\r\nprintk(KERN_WARNING "Gazel: No PCI card found\n");\r\nreturn (1);\r\n}\r\nif (!pci_irq) {\r\nprintk(KERN_WARNING "Gazel: No IRQ for PCI card found\n");\r\nreturn 1;\r\n}\r\ncs->hw.gazel.pciaddr[0] = pci_ioaddr0;\r\ncs->hw.gazel.pciaddr[1] = pci_ioaddr1;\r\nsetup_isac(cs);\r\npci_ioaddr1 &= 0xfffe;\r\ncs->hw.gazel.cfg_reg = pci_ioaddr0 & 0xfffe;\r\ncs->hw.gazel.ipac = pci_ioaddr1;\r\ncs->hw.gazel.isac = pci_ioaddr1 + 0x80;\r\ncs->hw.gazel.hscx[0] = pci_ioaddr1;\r\ncs->hw.gazel.hscx[1] = pci_ioaddr1 + 0x40;\r\ncs->hw.gazel.isacfifo = cs->hw.gazel.isac;\r\ncs->hw.gazel.hscxfifo[0] = cs->hw.gazel.hscx[0];\r\ncs->hw.gazel.hscxfifo[1] = cs->hw.gazel.hscx[1];\r\ncs->irq = pci_irq;\r\ncs->irq_flags |= IRQF_SHARED;\r\nswitch (seekcard) {\r\ncase PCI_DEVICE_ID_PLX_R685:\r\nprintk(KERN_INFO "Gazel: Card PCI R685 found\n");\r\ncs->subtyp = R685;\r\ncs->dc.isac.adf2 = 0x87;\r\nprintk(KERN_INFO\r\n"Gazel: config irq:%d isac:0x%X cfg:0x%X\n",\r\ncs->irq, cs->hw.gazel.isac, cs->hw.gazel.cfg_reg);\r\nprintk(KERN_INFO\r\n"Gazel: hscx A:0x%X hscx B:0x%X\n",\r\ncs->hw.gazel.hscx[0], cs->hw.gazel.hscx[1]);\r\nbreak;\r\ncase PCI_DEVICE_ID_PLX_R753:\r\ncase PCI_DEVICE_ID_PLX_DJINN_ITOO:\r\ncase PCI_DEVICE_ID_PLX_OLITEC:\r\nprintk(KERN_INFO "Gazel: Card PCI R753 found\n");\r\ncs->subtyp = R753;\r\ntest_and_set_bit(HW_IPAC, &cs->HW_Flags);\r\nprintk(KERN_INFO\r\n"Gazel: config irq:%d ipac:0x%X cfg:0x%X\n",\r\ncs->irq, cs->hw.gazel.ipac, cs->hw.gazel.cfg_reg);\r\nbreak;\r\n}\r\nreturn (0);\r\n}\r\nint __devinit\r\nsetup_gazel(struct IsdnCard *card)\r\n{\r\nstruct IsdnCardState *cs = card->cs;\r\nchar tmp[64];\r\nu_char val;\r\nstrcpy(tmp, gazel_revision);\r\nprintk(KERN_INFO "Gazel: Driver Revision %s\n", HiSax_getrev(tmp));\r\nif (cs->typ != ISDN_CTYPE_GAZEL)\r\nreturn (0);\r\nif (card->para[0]) {\r\nif (setup_gazelisa(card, cs))\r\nreturn (0);\r\n} else {\r\n#ifdef CONFIG_PCI\r\nif (setup_gazelpci(cs))\r\nreturn (0);\r\n#else\r\nprintk(KERN_WARNING "Gazel: Card PCI requested and NO_PCI_BIOS, unable to config\n");\r\nreturn (0);\r\n#endif\r\n}\r\nif (reserve_regions(card, cs)) {\r\nreturn (0);\r\n}\r\nif (reset_gazel(cs)) {\r\nprintk(KERN_WARNING "Gazel: wrong IRQ\n");\r\nrelease_io_gazel(cs);\r\nreturn (0);\r\n}\r\ncs->readisac = &ReadISAC;\r\ncs->writeisac = &WriteISAC;\r\ncs->readisacfifo = &ReadISACfifo;\r\ncs->writeisacfifo = &WriteISACfifo;\r\ncs->BC_Read_Reg = &ReadHSCX;\r\ncs->BC_Write_Reg = &WriteHSCX;\r\ncs->BC_Send_Data = &hscx_fill_fifo;\r\ncs->cardmsg = &Gazel_card_msg;\r\nswitch (cs->subtyp) {\r\ncase R647:\r\ncase R685:\r\ncs->irq_func = &gazel_interrupt;\r\nISACVersion(cs, "Gazel:");\r\nif (HscxVersion(cs, "Gazel:")) {\r\nprintk(KERN_WARNING\r\n"Gazel: wrong HSCX versions check IO address\n");\r\nrelease_io_gazel(cs);\r\nreturn (0);\r\n}\r\nbreak;\r\ncase R742:\r\ncase R753:\r\ncs->irq_func = &gazel_interrupt_ipac;\r\nval = ReadISAC(cs, IPAC_ID - 0x80);\r\nprintk(KERN_INFO "Gazel: IPAC version %x\n", val);\r\nbreak;\r\n}\r\nreturn (1);\r\n}
