static void wdt_enable(void)\r\n{\r\n__raw_writew(0xaaaa, EP93XX_WDT_WATCHDOG);\r\n}\r\nstatic void wdt_disable(void)\r\n{\r\n__raw_writew(0xaa55, EP93XX_WDT_WATCHDOG);\r\n}\r\nstatic inline void wdt_ping(void)\r\n{\r\n__raw_writew(0x5555, EP93XX_WDT_WATCHDOG);\r\n}\r\nstatic void wdt_startup(void)\r\n{\r\nnext_heartbeat = jiffies + (timeout * HZ);\r\nwdt_enable();\r\nmod_timer(&timer, jiffies + WDT_INTERVAL);\r\n}\r\nstatic void wdt_shutdown(void)\r\n{\r\ndel_timer_sync(&timer);\r\nwdt_disable();\r\n}\r\nstatic void wdt_keepalive(void)\r\n{\r\nnext_heartbeat = jiffies + (timeout * HZ);\r\n}\r\nstatic int ep93xx_wdt_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(WDT_IN_USE, &wdt_status))\r\nreturn -EBUSY;\r\nclear_bit(WDT_OK_TO_CLOSE, &wdt_status);\r\nwdt_startup();\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic ssize_t\r\nep93xx_wdt_write(struct file *file, const char __user *data, size_t len,\r\nloff_t *ppos)\r\n{\r\nif (len) {\r\nif (!nowayout) {\r\nsize_t i;\r\nclear_bit(WDT_OK_TO_CLOSE, &wdt_status);\r\nfor (i = 0; i != len; i++) {\r\nchar c;\r\nif (get_user(c, data + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nset_bit(WDT_OK_TO_CLOSE, &wdt_status);\r\nelse\r\nclear_bit(WDT_OK_TO_CLOSE, &wdt_status);\r\n}\r\n}\r\nwdt_keepalive();\r\n}\r\nreturn len;\r\n}\r\nstatic long ep93xx_wdt_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nint ret = -ENOTTY;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nret = copy_to_user((struct watchdog_info __user *)arg, &ident,\r\nsizeof(ident)) ? -EFAULT : 0;\r\nbreak;\r\ncase WDIOC_GETSTATUS:\r\nret = put_user(0, (int __user *)arg);\r\nbreak;\r\ncase WDIOC_GETBOOTSTATUS:\r\nret = put_user(boot_status, (int __user *)arg);\r\nbreak;\r\ncase WDIOC_KEEPALIVE:\r\nwdt_keepalive();\r\nret = 0;\r\nbreak;\r\ncase WDIOC_GETTIMEOUT:\r\nret = put_user(1, (int __user *)arg);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ep93xx_wdt_release(struct inode *inode, struct file *file)\r\n{\r\nif (test_bit(WDT_OK_TO_CLOSE, &wdt_status))\r\nwdt_shutdown();\r\nelse\r\nprintk(KERN_CRIT PFX\r\n"Device closed unexpectedly - timer will not stop\n");\r\nclear_bit(WDT_IN_USE, &wdt_status);\r\nclear_bit(WDT_OK_TO_CLOSE, &wdt_status);\r\nreturn 0;\r\n}\r\nstatic void ep93xx_timer_ping(unsigned long data)\r\n{\r\nif (time_before(jiffies, next_heartbeat))\r\nwdt_ping();\r\nmod_timer(&timer, jiffies + WDT_INTERVAL);\r\n}\r\nstatic int __init ep93xx_wdt_init(void)\r\n{\r\nint err;\r\nerr = misc_register(&ep93xx_wdt_miscdev);\r\nboot_status = __raw_readl(EP93XX_WDT_WATCHDOG) & 0x01 ? 1 : 0;\r\nprintk(KERN_INFO PFX "EP93XX watchdog, driver version "\r\nWDT_VERSION "%s\n",\r\n(__raw_readl(EP93XX_WDT_WATCHDOG) & 0x08)\r\n? " (nCS1 disable detected)" : "");\r\nif (timeout < 1 || timeout > 3600) {\r\ntimeout = WDT_TIMEOUT;\r\nprintk(KERN_INFO PFX\r\n"timeout value must be 1<=x<=3600, using %d\n",\r\ntimeout);\r\n}\r\nsetup_timer(&timer, ep93xx_timer_ping, 1);\r\nreturn err;\r\n}\r\nstatic void __exit ep93xx_wdt_exit(void)\r\n{\r\nwdt_shutdown();\r\nmisc_deregister(&ep93xx_wdt_miscdev);\r\n}
