static int tea6420_s_routing(struct v4l2_subdev *sd,\r\nu32 i, u32 o, u32 config)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint g = (o >> 4) & 0xf;\r\nu8 byte;\r\nint ret;\r\no &= 0xf;\r\nv4l2_dbg(1, debug, sd, "i=%d, o=%d, g=%d\n", i, o, g);\r\nif (i < 1 || i > 6 || o < 1 || o > 4 || g < 0 || g > 6 || g % 2 != 0)\r\nreturn -EINVAL;\r\nbyte = ((o - 1) << 5);\r\nbyte |= (i - 1);\r\nswitch (g) {\r\ncase 0:\r\nbyte |= (3 << 3);\r\nbreak;\r\ncase 2:\r\nbyte |= (2 << 3);\r\nbreak;\r\ncase 4:\r\nbyte |= (1 << 3);\r\nbreak;\r\ncase 6:\r\nbreak;\r\n}\r\nret = i2c_smbus_write_byte(client, byte);\r\nif (ret) {\r\nv4l2_dbg(1, debug, sd,\r\n"i2c_smbus_write_byte() failed, ret:%d\n", ret);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tea6420_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_TEA6420, 0);\r\n}\r\nstatic int tea6420_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct v4l2_subdev *sd;\r\nint err, i;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_WRITE_BYTE))\r\nreturn -EIO;\r\nv4l_info(client, "chip found @ 0x%x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\nsd = kzalloc(sizeof(struct v4l2_subdev), GFP_KERNEL);\r\nif (sd == NULL)\r\nreturn -ENOMEM;\r\nv4l2_i2c_subdev_init(sd, client, &tea6420_ops);\r\nerr = 0;\r\nfor (i = 1; i < 5; i++)\r\nerr += tea6420_s_routing(sd, 6, i, 0);\r\nif (err) {\r\nv4l_dbg(1, debug, client, "could not initialize tea6420\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tea6420_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nv4l2_device_unregister_subdev(sd);\r\nkfree(sd);\r\nreturn 0;\r\n}\r\nstatic __init int init_tea6420(void)\r\n{\r\nreturn i2c_add_driver(&tea6420_driver);\r\n}\r\nstatic __exit void exit_tea6420(void)\r\n{\r\ni2c_del_driver(&tea6420_driver);\r\n}
