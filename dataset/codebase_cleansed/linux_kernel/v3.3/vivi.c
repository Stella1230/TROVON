static struct vivi_fmt *get_format(struct v4l2_format *f)\r\n{\r\nstruct vivi_fmt *fmt;\r\nunsigned int k;\r\nfor (k = 0; k < ARRAY_SIZE(formats); k++) {\r\nfmt = &formats[k];\r\nif (fmt->fourcc == f->fmt.pix.pixelformat)\r\nbreak;\r\n}\r\nif (k == ARRAY_SIZE(formats))\r\nreturn NULL;\r\nreturn &formats[k];\r\n}\r\nstatic void precalculate_bars(struct vivi_dev *dev)\r\n{\r\nu8 r, g, b;\r\nint k, is_yuv;\r\nfor (k = 0; k < 9; k++) {\r\nr = bars[dev->input].bar[k][0];\r\ng = bars[dev->input].bar[k][1];\r\nb = bars[dev->input].bar[k][2];\r\nis_yuv = 0;\r\nswitch (dev->fmt->fourcc) {\r\ncase V4L2_PIX_FMT_YUYV:\r\ncase V4L2_PIX_FMT_UYVY:\r\nis_yuv = 1;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB565:\r\ncase V4L2_PIX_FMT_RGB565X:\r\nr >>= 3;\r\ng >>= 2;\r\nb >>= 3;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB555:\r\ncase V4L2_PIX_FMT_RGB555X:\r\nr >>= 3;\r\ng >>= 3;\r\nb >>= 3;\r\nbreak;\r\n}\r\nif (is_yuv) {\r\ndev->bars[k][0] = TO_Y(r, g, b);\r\ndev->bars[k][1] = TO_U(r, g, b);\r\ndev->bars[k][2] = TO_V(r, g, b);\r\n} else {\r\ndev->bars[k][0] = r;\r\ndev->bars[k][1] = g;\r\ndev->bars[k][2] = b;\r\n}\r\n}\r\n}\r\nstatic void gen_twopix(struct vivi_dev *dev, u8 *buf, int colorpos)\r\n{\r\nu8 r_y, g_u, b_v;\r\nint color;\r\nu8 *p;\r\nr_y = dev->bars[colorpos][0];\r\ng_u = dev->bars[colorpos][1];\r\nb_v = dev->bars[colorpos][2];\r\nfor (color = 0; color < 4; color++) {\r\np = buf + color;\r\nswitch (dev->fmt->fourcc) {\r\ncase V4L2_PIX_FMT_YUYV:\r\nswitch (color) {\r\ncase 0:\r\ncase 2:\r\n*p = r_y;\r\nbreak;\r\ncase 1:\r\n*p = g_u;\r\nbreak;\r\ncase 3:\r\n*p = b_v;\r\nbreak;\r\n}\r\nbreak;\r\ncase V4L2_PIX_FMT_UYVY:\r\nswitch (color) {\r\ncase 1:\r\ncase 3:\r\n*p = r_y;\r\nbreak;\r\ncase 0:\r\n*p = g_u;\r\nbreak;\r\ncase 2:\r\n*p = b_v;\r\nbreak;\r\n}\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB565:\r\nswitch (color) {\r\ncase 0:\r\ncase 2:\r\n*p = (g_u << 5) | b_v;\r\nbreak;\r\ncase 1:\r\ncase 3:\r\n*p = (r_y << 3) | (g_u >> 3);\r\nbreak;\r\n}\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB565X:\r\nswitch (color) {\r\ncase 0:\r\ncase 2:\r\n*p = (r_y << 3) | (g_u >> 3);\r\nbreak;\r\ncase 1:\r\ncase 3:\r\n*p = (g_u << 5) | b_v;\r\nbreak;\r\n}\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB555:\r\nswitch (color) {\r\ncase 0:\r\ncase 2:\r\n*p = (g_u << 5) | b_v;\r\nbreak;\r\ncase 1:\r\ncase 3:\r\n*p = (r_y << 2) | (g_u >> 3);\r\nbreak;\r\n}\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB555X:\r\nswitch (color) {\r\ncase 0:\r\ncase 2:\r\n*p = (r_y << 2) | (g_u >> 3);\r\nbreak;\r\ncase 1:\r\ncase 3:\r\n*p = (g_u << 5) | b_v;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void precalculate_line(struct vivi_dev *dev)\r\n{\r\nint w;\r\nfor (w = 0; w < dev->width * 2; w += 2) {\r\nint colorpos = (w / (dev->width / 8) % 8);\r\ngen_twopix(dev, dev->line + w * 2, colorpos);\r\n}\r\n}\r\nstatic void gen_text(struct vivi_dev *dev, char *basep,\r\nint y, int x, char *text)\r\n{\r\nint line;\r\nif (y + 16 >= dev->height || x + strlen(text) * 8 >= dev->width)\r\nreturn;\r\nfor (line = y; line < y + 16; line++) {\r\nint j = 0;\r\nchar *pos = basep + line * dev->width * 2 + x * 2;\r\nchar *s;\r\nfor (s = text; *s; s++) {\r\nu8 chr = font8x16[*s * 16 + line - y];\r\nint i;\r\nfor (i = 0; i < 7; i++, j++) {\r\nif (chr & (1 << (7 - i)))\r\ngen_twopix(dev, pos + j * 2, WHITE);\r\nelse\r\ngen_twopix(dev, pos + j * 2, TEXT_BLACK);\r\n}\r\n}\r\n}\r\n}\r\nstatic void vivi_fillbuff(struct vivi_dev *dev, struct vivi_buffer *buf)\r\n{\r\nint wmax = dev->width;\r\nint hmax = dev->height;\r\nstruct timeval ts;\r\nvoid *vbuf = vb2_plane_vaddr(&buf->vb, 0);\r\nunsigned ms;\r\nchar str[100];\r\nint h, line = 1;\r\ns32 gain;\r\nif (!vbuf)\r\nreturn;\r\nfor (h = 0; h < hmax; h++)\r\nmemcpy(vbuf + h * wmax * 2, dev->line + (dev->mv_count % wmax) * 2, wmax * 2);\r\ndev->ms += jiffies_to_msecs(jiffies - dev->jiffies);\r\ndev->jiffies = jiffies;\r\nms = dev->ms;\r\nsnprintf(str, sizeof(str), " %02d:%02d:%02d:%03d ",\r\n(ms / (60 * 60 * 1000)) % 24,\r\n(ms / (60 * 1000)) % 60,\r\n(ms / 1000) % 60,\r\nms % 1000);\r\ngen_text(dev, vbuf, line++ * 16, 16, str);\r\nsnprintf(str, sizeof(str), " %dx%d, input %d ",\r\ndev->width, dev->height, dev->input);\r\ngen_text(dev, vbuf, line++ * 16, 16, str);\r\ngain = v4l2_ctrl_g_ctrl(dev->gain);\r\nmutex_lock(&dev->ctrl_handler.lock);\r\nsnprintf(str, sizeof(str), " brightness %3d, contrast %3d, saturation %3d, hue %d ",\r\ndev->brightness->cur.val,\r\ndev->contrast->cur.val,\r\ndev->saturation->cur.val,\r\ndev->hue->cur.val);\r\ngen_text(dev, vbuf, line++ * 16, 16, str);\r\nsnprintf(str, sizeof(str), " autogain %d, gain %3d, volume %3d ",\r\ndev->autogain->cur.val, gain, dev->volume->cur.val);\r\ngen_text(dev, vbuf, line++ * 16, 16, str);\r\nsnprintf(str, sizeof(str), " int32 %d, int64 %lld, bitmask %08x ",\r\ndev->int32->cur.val,\r\ndev->int64->cur.val64,\r\ndev->bitmask->cur.val);\r\ngen_text(dev, vbuf, line++ * 16, 16, str);\r\nsnprintf(str, sizeof(str), " boolean %d, menu %s, string \"%s\" ",\r\ndev->boolean->cur.val,\r\ndev->menu->qmenu[dev->menu->cur.val],\r\ndev->string->cur.string);\r\nmutex_unlock(&dev->ctrl_handler.lock);\r\ngen_text(dev, vbuf, line++ * 16, 16, str);\r\nif (dev->button_pressed) {\r\ndev->button_pressed--;\r\nsnprintf(str, sizeof(str), " button pressed!");\r\ngen_text(dev, vbuf, line++ * 16, 16, str);\r\n}\r\ndev->mv_count += 2;\r\nbuf->vb.v4l2_buf.field = dev->field;\r\ndev->field_count++;\r\nbuf->vb.v4l2_buf.sequence = dev->field_count >> 1;\r\ndo_gettimeofday(&ts);\r\nbuf->vb.v4l2_buf.timestamp = ts;\r\n}\r\nstatic void vivi_thread_tick(struct vivi_dev *dev)\r\n{\r\nstruct vivi_dmaqueue *dma_q = &dev->vidq;\r\nstruct vivi_buffer *buf;\r\nunsigned long flags = 0;\r\ndprintk(dev, 1, "Thread tick\n");\r\nspin_lock_irqsave(&dev->slock, flags);\r\nif (list_empty(&dma_q->active)) {\r\ndprintk(dev, 1, "No active queue to serve\n");\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\nreturn;\r\n}\r\nbuf = list_entry(dma_q->active.next, struct vivi_buffer, list);\r\nlist_del(&buf->list);\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\ndo_gettimeofday(&buf->vb.v4l2_buf.timestamp);\r\nvivi_fillbuff(dev, buf);\r\ndprintk(dev, 1, "filled buffer %p\n", buf);\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_DONE);\r\ndprintk(dev, 2, "[%p/%d] done\n", buf, buf->vb.v4l2_buf.index);\r\n}\r\nstatic void vivi_sleep(struct vivi_dev *dev)\r\n{\r\nstruct vivi_dmaqueue *dma_q = &dev->vidq;\r\nint timeout;\r\nDECLARE_WAITQUEUE(wait, current);\r\ndprintk(dev, 1, "%s dma_q=0x%08lx\n", __func__,\r\n(unsigned long)dma_q);\r\nadd_wait_queue(&dma_q->wq, &wait);\r\nif (kthread_should_stop())\r\ngoto stop_task;\r\ntimeout = msecs_to_jiffies(frames_to_ms(1));\r\nvivi_thread_tick(dev);\r\nschedule_timeout_interruptible(timeout);\r\nstop_task:\r\nremove_wait_queue(&dma_q->wq, &wait);\r\ntry_to_freeze();\r\n}\r\nstatic int vivi_thread(void *data)\r\n{\r\nstruct vivi_dev *dev = data;\r\ndprintk(dev, 1, "thread started\n");\r\nset_freezable();\r\nfor (;;) {\r\nvivi_sleep(dev);\r\nif (kthread_should_stop())\r\nbreak;\r\n}\r\ndprintk(dev, 1, "thread: exit\n");\r\nreturn 0;\r\n}\r\nstatic int vivi_start_generating(struct vivi_dev *dev)\r\n{\r\nstruct vivi_dmaqueue *dma_q = &dev->vidq;\r\ndprintk(dev, 1, "%s\n", __func__);\r\ndev->ms = 0;\r\ndev->mv_count = 0;\r\ndev->jiffies = jiffies;\r\ndma_q->frame = 0;\r\ndma_q->ini_jiffies = jiffies;\r\ndma_q->kthread = kthread_run(vivi_thread, dev, dev->v4l2_dev.name);\r\nif (IS_ERR(dma_q->kthread)) {\r\nv4l2_err(&dev->v4l2_dev, "kernel_thread() failed\n");\r\nreturn PTR_ERR(dma_q->kthread);\r\n}\r\nwake_up_interruptible(&dma_q->wq);\r\ndprintk(dev, 1, "returning from %s\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void vivi_stop_generating(struct vivi_dev *dev)\r\n{\r\nstruct vivi_dmaqueue *dma_q = &dev->vidq;\r\ndprintk(dev, 1, "%s\n", __func__);\r\nif (dma_q->kthread) {\r\nkthread_stop(dma_q->kthread);\r\ndma_q->kthread = NULL;\r\n}\r\nwhile (!list_empty(&dma_q->active)) {\r\nstruct vivi_buffer *buf;\r\nbuf = list_entry(dma_q->active.next, struct vivi_buffer, list);\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);\r\ndprintk(dev, 2, "[%p/%d] done\n", buf, buf->vb.v4l2_buf.index);\r\n}\r\n}\r\nstatic int queue_setup(struct vb2_queue *vq, const struct v4l2_format *fmt,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct vivi_dev *dev = vb2_get_drv_priv(vq);\r\nunsigned long size;\r\nsize = dev->width * dev->height * 2;\r\nif (0 == *nbuffers)\r\n*nbuffers = 32;\r\nwhile (size * *nbuffers > vid_limit * 1024 * 1024)\r\n(*nbuffers)--;\r\n*nplanes = 1;\r\nsizes[0] = size;\r\ndprintk(dev, 1, "%s, count=%d, size=%ld\n", __func__,\r\n*nbuffers, size);\r\nreturn 0;\r\n}\r\nstatic int buffer_init(struct vb2_buffer *vb)\r\n{\r\nstruct vivi_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\r\nBUG_ON(NULL == dev->fmt);\r\nreturn 0;\r\n}\r\nstatic int buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct vivi_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vivi_buffer *buf = container_of(vb, struct vivi_buffer, vb);\r\nunsigned long size;\r\ndprintk(dev, 1, "%s, field=%d\n", __func__, vb->v4l2_buf.field);\r\nBUG_ON(NULL == dev->fmt);\r\nif (dev->width < 48 || dev->width > MAX_WIDTH ||\r\ndev->height < 32 || dev->height > MAX_HEIGHT)\r\nreturn -EINVAL;\r\nsize = dev->width * dev->height * 2;\r\nif (vb2_plane_size(vb, 0) < size) {\r\ndprintk(dev, 1, "%s data will not fit into plane (%lu < %lu)\n",\r\n__func__, vb2_plane_size(vb, 0), size);\r\nreturn -EINVAL;\r\n}\r\nvb2_set_plane_payload(&buf->vb, 0, size);\r\nbuf->fmt = dev->fmt;\r\nprecalculate_bars(dev);\r\nprecalculate_line(dev);\r\nreturn 0;\r\n}\r\nstatic int buffer_finish(struct vb2_buffer *vb)\r\n{\r\nstruct vivi_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\r\ndprintk(dev, 1, "%s\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void buffer_cleanup(struct vb2_buffer *vb)\r\n{\r\nstruct vivi_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\r\ndprintk(dev, 1, "%s\n", __func__);\r\n}\r\nstatic void buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vivi_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vivi_buffer *buf = container_of(vb, struct vivi_buffer, vb);\r\nstruct vivi_dmaqueue *vidq = &dev->vidq;\r\nunsigned long flags = 0;\r\ndprintk(dev, 1, "%s\n", __func__);\r\nspin_lock_irqsave(&dev->slock, flags);\r\nlist_add_tail(&buf->list, &vidq->active);\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\n}\r\nstatic int start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct vivi_dev *dev = vb2_get_drv_priv(vq);\r\ndprintk(dev, 1, "%s\n", __func__);\r\nreturn vivi_start_generating(dev);\r\n}\r\nstatic int stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct vivi_dev *dev = vb2_get_drv_priv(vq);\r\ndprintk(dev, 1, "%s\n", __func__);\r\nvivi_stop_generating(dev);\r\nreturn 0;\r\n}\r\nstatic void vivi_lock(struct vb2_queue *vq)\r\n{\r\nstruct vivi_dev *dev = vb2_get_drv_priv(vq);\r\nmutex_lock(&dev->mutex);\r\n}\r\nstatic void vivi_unlock(struct vb2_queue *vq)\r\n{\r\nstruct vivi_dev *dev = vb2_get_drv_priv(vq);\r\nmutex_unlock(&dev->mutex);\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct vivi_dev *dev = video_drvdata(file);\r\nstrcpy(cap->driver, "vivi");\r\nstrcpy(cap->card, "vivi");\r\nstrlcpy(cap->bus_info, dev->v4l2_dev.name, sizeof(cap->bus_info));\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING | \\r\nV4L2_CAP_READWRITE;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct vivi_fmt *fmt;\r\nif (f->index >= ARRAY_SIZE(formats))\r\nreturn -EINVAL;\r\nfmt = &formats[f->index];\r\nstrlcpy(f->description, fmt->name, sizeof(f->description));\r\nf->pixelformat = fmt->fourcc;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct vivi_dev *dev = video_drvdata(file);\r\nf->fmt.pix.width = dev->width;\r\nf->fmt.pix.height = dev->height;\r\nf->fmt.pix.field = dev->field;\r\nf->fmt.pix.pixelformat = dev->fmt->fourcc;\r\nf->fmt.pix.bytesperline =\r\n(f->fmt.pix.width * dev->fmt->depth) >> 3;\r\nf->fmt.pix.sizeimage =\r\nf->fmt.pix.height * f->fmt.pix.bytesperline;\r\nif (dev->fmt->fourcc == V4L2_PIX_FMT_YUYV ||\r\ndev->fmt->fourcc == V4L2_PIX_FMT_UYVY)\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nelse\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct vivi_dev *dev = video_drvdata(file);\r\nstruct vivi_fmt *fmt;\r\nenum v4l2_field field;\r\nfmt = get_format(f);\r\nif (!fmt) {\r\ndprintk(dev, 1, "Fourcc format (0x%08x) invalid.\n",\r\nf->fmt.pix.pixelformat);\r\nreturn -EINVAL;\r\n}\r\nfield = f->fmt.pix.field;\r\nif (field == V4L2_FIELD_ANY) {\r\nfield = V4L2_FIELD_INTERLACED;\r\n} else if (V4L2_FIELD_INTERLACED != field) {\r\ndprintk(dev, 1, "Field type invalid.\n");\r\nreturn -EINVAL;\r\n}\r\nf->fmt.pix.field = field;\r\nv4l_bound_align_image(&f->fmt.pix.width, 48, MAX_WIDTH, 2,\r\n&f->fmt.pix.height, 32, MAX_HEIGHT, 0, 0);\r\nf->fmt.pix.bytesperline =\r\n(f->fmt.pix.width * fmt->depth) >> 3;\r\nf->fmt.pix.sizeimage =\r\nf->fmt.pix.height * f->fmt.pix.bytesperline;\r\nif (fmt->fourcc == V4L2_PIX_FMT_YUYV ||\r\nfmt->fourcc == V4L2_PIX_FMT_UYVY)\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nelse\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct vivi_dev *dev = video_drvdata(file);\r\nstruct vb2_queue *q = &dev->vb_vidq;\r\nint ret = vidioc_try_fmt_vid_cap(file, priv, f);\r\nif (ret < 0)\r\nreturn ret;\r\nif (vb2_is_streaming(q)) {\r\ndprintk(dev, 1, "%s device busy\n", __func__);\r\nreturn -EBUSY;\r\n}\r\ndev->fmt = get_format(f);\r\ndev->width = f->fmt.pix.width;\r\ndev->height = f->fmt.pix.height;\r\ndev->field = f->fmt.pix.field;\r\nreturn 0;\r\n}\r\nstatic int vidioc_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *p)\r\n{\r\nstruct vivi_dev *dev = video_drvdata(file);\r\nreturn vb2_reqbufs(&dev->vb_vidq, p);\r\n}\r\nstatic int vidioc_querybuf(struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nstruct vivi_dev *dev = video_drvdata(file);\r\nreturn vb2_querybuf(&dev->vb_vidq, p);\r\n}\r\nstatic int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nstruct vivi_dev *dev = video_drvdata(file);\r\nreturn vb2_qbuf(&dev->vb_vidq, p);\r\n}\r\nstatic int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nstruct vivi_dev *dev = video_drvdata(file);\r\nreturn vb2_dqbuf(&dev->vb_vidq, p, file->f_flags & O_NONBLOCK);\r\n}\r\nstatic int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)\r\n{\r\nstruct vivi_dev *dev = video_drvdata(file);\r\nreturn vb2_streamon(&dev->vb_vidq, i);\r\n}\r\nstatic int vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)\r\n{\r\nstruct vivi_dev *dev = video_drvdata(file);\r\nreturn vb2_streamoff(&dev->vb_vidq, i);\r\n}\r\nstatic int vidioc_log_status(struct file *file, void *priv)\r\n{\r\nstruct vivi_dev *dev = video_drvdata(file);\r\nv4l2_ctrl_handler_log_status(&dev->ctrl_handler, dev->v4l2_dev.name);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *i)\r\n{\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *inp)\r\n{\r\nif (inp->index >= NUM_INPUTS)\r\nreturn -EINVAL;\r\ninp->type = V4L2_INPUT_TYPE_CAMERA;\r\ninp->std = V4L2_STD_525_60;\r\nsprintf(inp->name, "Camera %u", inp->index);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct vivi_dev *dev = video_drvdata(file);\r\n*i = dev->input;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nstruct vivi_dev *dev = video_drvdata(file);\r\nif (i >= NUM_INPUTS)\r\nreturn -EINVAL;\r\nif (i == dev->input)\r\nreturn 0;\r\ndev->input = i;\r\nprecalculate_bars(dev);\r\nprecalculate_line(dev);\r\nreturn 0;\r\n}\r\nstatic int vidioc_subscribe_event(struct v4l2_fh *fh,\r\nstruct v4l2_event_subscription *sub)\r\n{\r\nswitch (sub->type) {\r\ncase V4L2_EVENT_CTRL:\r\nreturn v4l2_event_subscribe(fh, sub, 0);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int vivi_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct vivi_dev *dev = container_of(ctrl->handler, struct vivi_dev, ctrl_handler);\r\nif (ctrl == dev->autogain)\r\ndev->gain->val = jiffies & 0xff;\r\nreturn 0;\r\n}\r\nstatic int vivi_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct vivi_dev *dev = container_of(ctrl->handler, struct vivi_dev, ctrl_handler);\r\nif (ctrl == dev->button)\r\ndev->button_pressed = 30;\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nvivi_read(struct file *file, char __user *data, size_t count, loff_t *ppos)\r\n{\r\nstruct vivi_dev *dev = video_drvdata(file);\r\ndprintk(dev, 1, "read called\n");\r\nreturn vb2_read(&dev->vb_vidq, data, count, ppos,\r\nfile->f_flags & O_NONBLOCK);\r\n}\r\nstatic unsigned int\r\nvivi_poll(struct file *file, struct poll_table_struct *wait)\r\n{\r\nstruct vivi_dev *dev = video_drvdata(file);\r\nstruct v4l2_fh *fh = file->private_data;\r\nstruct vb2_queue *q = &dev->vb_vidq;\r\nunsigned int res;\r\ndprintk(dev, 1, "%s\n", __func__);\r\nres = vb2_poll(q, file, wait);\r\nif (v4l2_event_pending(fh))\r\nres |= POLLPRI;\r\nelse\r\npoll_wait(file, &fh->wait, wait);\r\nreturn res;\r\n}\r\nstatic int vivi_close(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct vivi_dev *dev = video_drvdata(file);\r\ndprintk(dev, 1, "close called (dev=%s), file %p\n",\r\nvideo_device_node_name(vdev), file);\r\nif (v4l2_fh_is_singular_file(file))\r\nvb2_queue_release(&dev->vb_vidq);\r\nreturn v4l2_fh_release(file);\r\n}\r\nstatic int vivi_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct vivi_dev *dev = video_drvdata(file);\r\nint ret;\r\ndprintk(dev, 1, "mmap called, vma=0x%08lx\n", (unsigned long)vma);\r\nret = vb2_mmap(&dev->vb_vidq, vma);\r\ndprintk(dev, 1, "vma start=0x%08lx, size=%ld, ret=%d\n",\r\n(unsigned long)vma->vm_start,\r\n(unsigned long)vma->vm_end - (unsigned long)vma->vm_start,\r\nret);\r\nreturn ret;\r\n}\r\nstatic int vivi_release(void)\r\n{\r\nstruct vivi_dev *dev;\r\nstruct list_head *list;\r\nwhile (!list_empty(&vivi_devlist)) {\r\nlist = vivi_devlist.next;\r\nlist_del(list);\r\ndev = list_entry(list, struct vivi_dev, vivi_devlist);\r\nv4l2_info(&dev->v4l2_dev, "unregistering %s\n",\r\nvideo_device_node_name(dev->vfd));\r\nvideo_unregister_device(dev->vfd);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nv4l2_ctrl_handler_free(&dev->ctrl_handler);\r\nkfree(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init vivi_create_instance(int inst)\r\n{\r\nstruct vivi_dev *dev;\r\nstruct video_device *vfd;\r\nstruct v4l2_ctrl_handler *hdl;\r\nstruct vb2_queue *q;\r\nint ret;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nsnprintf(dev->v4l2_dev.name, sizeof(dev->v4l2_dev.name),\r\n"%s-%03d", VIVI_MODULE_NAME, inst);\r\nret = v4l2_device_register(NULL, &dev->v4l2_dev);\r\nif (ret)\r\ngoto free_dev;\r\ndev->fmt = &formats[0];\r\ndev->width = 640;\r\ndev->height = 480;\r\nhdl = &dev->ctrl_handler;\r\nv4l2_ctrl_handler_init(hdl, 11);\r\ndev->volume = v4l2_ctrl_new_std(hdl, &vivi_ctrl_ops,\r\nV4L2_CID_AUDIO_VOLUME, 0, 255, 1, 200);\r\ndev->brightness = v4l2_ctrl_new_std(hdl, &vivi_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 255, 1, 127);\r\ndev->contrast = v4l2_ctrl_new_std(hdl, &vivi_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 255, 1, 16);\r\ndev->saturation = v4l2_ctrl_new_std(hdl, &vivi_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 255, 1, 127);\r\ndev->hue = v4l2_ctrl_new_std(hdl, &vivi_ctrl_ops,\r\nV4L2_CID_HUE, -128, 127, 1, 0);\r\ndev->autogain = v4l2_ctrl_new_std(hdl, &vivi_ctrl_ops,\r\nV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\r\ndev->gain = v4l2_ctrl_new_std(hdl, &vivi_ctrl_ops,\r\nV4L2_CID_GAIN, 0, 255, 1, 100);\r\ndev->button = v4l2_ctrl_new_custom(hdl, &vivi_ctrl_button, NULL);\r\ndev->int32 = v4l2_ctrl_new_custom(hdl, &vivi_ctrl_int32, NULL);\r\ndev->int64 = v4l2_ctrl_new_custom(hdl, &vivi_ctrl_int64, NULL);\r\ndev->boolean = v4l2_ctrl_new_custom(hdl, &vivi_ctrl_boolean, NULL);\r\ndev->menu = v4l2_ctrl_new_custom(hdl, &vivi_ctrl_menu, NULL);\r\ndev->string = v4l2_ctrl_new_custom(hdl, &vivi_ctrl_string, NULL);\r\ndev->bitmask = v4l2_ctrl_new_custom(hdl, &vivi_ctrl_bitmask, NULL);\r\nif (hdl->error) {\r\nret = hdl->error;\r\ngoto unreg_dev;\r\n}\r\nv4l2_ctrl_auto_cluster(2, &dev->autogain, 0, true);\r\ndev->v4l2_dev.ctrl_handler = hdl;\r\nspin_lock_init(&dev->slock);\r\nq = &dev->vb_vidq;\r\nmemset(q, 0, sizeof(dev->vb_vidq));\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ;\r\nq->drv_priv = dev;\r\nq->buf_struct_size = sizeof(struct vivi_buffer);\r\nq->ops = &vivi_video_qops;\r\nq->mem_ops = &vb2_vmalloc_memops;\r\nvb2_queue_init(q);\r\nmutex_init(&dev->mutex);\r\nINIT_LIST_HEAD(&dev->vidq.active);\r\ninit_waitqueue_head(&dev->vidq.wq);\r\nret = -ENOMEM;\r\nvfd = video_device_alloc();\r\nif (!vfd)\r\ngoto unreg_dev;\r\n*vfd = vivi_template;\r\nvfd->debug = debug;\r\nvfd->v4l2_dev = &dev->v4l2_dev;\r\nset_bit(V4L2_FL_USE_FH_PRIO, &vfd->flags);\r\nvfd->lock = &dev->mutex;\r\nret = video_register_device(vfd, VFL_TYPE_GRABBER, video_nr);\r\nif (ret < 0)\r\ngoto rel_vdev;\r\nvideo_set_drvdata(vfd, dev);\r\nlist_add_tail(&dev->vivi_devlist, &vivi_devlist);\r\nif (video_nr != -1)\r\nvideo_nr++;\r\ndev->vfd = vfd;\r\nv4l2_info(&dev->v4l2_dev, "V4L2 device registered as %s\n",\r\nvideo_device_node_name(vfd));\r\nreturn 0;\r\nrel_vdev:\r\nvideo_device_release(vfd);\r\nunreg_dev:\r\nv4l2_ctrl_handler_free(hdl);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nfree_dev:\r\nkfree(dev);\r\nreturn ret;\r\n}\r\nstatic int __init vivi_init(void)\r\n{\r\nconst struct font_desc *font = find_font("VGA8x16");\r\nint ret = 0, i;\r\nif (font == NULL) {\r\nprintk(KERN_ERR "vivi: could not find font\n");\r\nreturn -ENODEV;\r\n}\r\nfont8x16 = font->data;\r\nif (n_devs <= 0)\r\nn_devs = 1;\r\nfor (i = 0; i < n_devs; i++) {\r\nret = vivi_create_instance(i);\r\nif (ret) {\r\nif (i)\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nif (ret < 0) {\r\nprintk(KERN_ERR "vivi: error %d while loading driver\n", ret);\r\nreturn ret;\r\n}\r\nprintk(KERN_INFO "Video Technology Magazine Virtual Video "\r\n"Capture Board ver %s successfully loaded.\n",\r\nVIVI_VERSION);\r\nn_devs = i;\r\nreturn ret;\r\n}\r\nstatic void __exit vivi_exit(void)\r\n{\r\nvivi_release();\r\n}
