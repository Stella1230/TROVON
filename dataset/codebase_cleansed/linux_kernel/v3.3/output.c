static void sctp_packet_reset(struct sctp_packet *packet)\r\n{\r\npacket->size = packet->overhead;\r\npacket->has_cookie_echo = 0;\r\npacket->has_sack = 0;\r\npacket->has_data = 0;\r\npacket->has_auth = 0;\r\npacket->ipfragok = 0;\r\npacket->auth = NULL;\r\n}\r\nstruct sctp_packet *sctp_packet_config(struct sctp_packet *packet,\r\n__u32 vtag, int ecn_capable)\r\n{\r\nstruct sctp_chunk *chunk = NULL;\r\nSCTP_DEBUG_PRINTK("%s: packet:%p vtag:0x%x\n", __func__,\r\npacket, vtag);\r\npacket->vtag = vtag;\r\nif (ecn_capable && sctp_packet_empty(packet)) {\r\nchunk = sctp_get_ecne_prepend(packet->transport->asoc);\r\nif (chunk)\r\nsctp_packet_append_chunk(packet, chunk);\r\n}\r\nreturn packet;\r\n}\r\nstruct sctp_packet *sctp_packet_init(struct sctp_packet *packet,\r\nstruct sctp_transport *transport,\r\n__u16 sport, __u16 dport)\r\n{\r\nstruct sctp_association *asoc = transport->asoc;\r\nsize_t overhead;\r\nSCTP_DEBUG_PRINTK("%s: packet:%p transport:%p\n", __func__,\r\npacket, transport);\r\npacket->transport = transport;\r\npacket->source_port = sport;\r\npacket->destination_port = dport;\r\nINIT_LIST_HEAD(&packet->chunk_list);\r\nif (asoc) {\r\nstruct sctp_sock *sp = sctp_sk(asoc->base.sk);\r\noverhead = sp->pf->af->net_header_len;\r\n} else {\r\noverhead = sizeof(struct ipv6hdr);\r\n}\r\noverhead += sizeof(struct sctphdr);\r\npacket->overhead = overhead;\r\nsctp_packet_reset(packet);\r\npacket->vtag = 0;\r\npacket->malloced = 0;\r\nreturn packet;\r\n}\r\nvoid sctp_packet_free(struct sctp_packet *packet)\r\n{\r\nstruct sctp_chunk *chunk, *tmp;\r\nSCTP_DEBUG_PRINTK("%s: packet:%p\n", __func__, packet);\r\nlist_for_each_entry_safe(chunk, tmp, &packet->chunk_list, list) {\r\nlist_del_init(&chunk->list);\r\nsctp_chunk_free(chunk);\r\n}\r\nif (packet->malloced)\r\nkfree(packet);\r\n}\r\nsctp_xmit_t sctp_packet_transmit_chunk(struct sctp_packet *packet,\r\nstruct sctp_chunk *chunk,\r\nint one_packet)\r\n{\r\nsctp_xmit_t retval;\r\nint error = 0;\r\nSCTP_DEBUG_PRINTK("%s: packet:%p chunk:%p\n", __func__,\r\npacket, chunk);\r\nswitch ((retval = (sctp_packet_append_chunk(packet, chunk)))) {\r\ncase SCTP_XMIT_PMTU_FULL:\r\nif (!packet->has_cookie_echo) {\r\nerror = sctp_packet_transmit(packet);\r\nif (error < 0)\r\nchunk->skb->sk->sk_err = -error;\r\nif (!one_packet)\r\nretval = sctp_packet_append_chunk(packet,\r\nchunk);\r\n}\r\nbreak;\r\ncase SCTP_XMIT_RWND_FULL:\r\ncase SCTP_XMIT_OK:\r\ncase SCTP_XMIT_NAGLE_DELAY:\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\nstatic sctp_xmit_t sctp_packet_bundle_auth(struct sctp_packet *pkt,\r\nstruct sctp_chunk *chunk)\r\n{\r\nstruct sctp_association *asoc = pkt->transport->asoc;\r\nstruct sctp_chunk *auth;\r\nsctp_xmit_t retval = SCTP_XMIT_OK;\r\nif (!asoc)\r\nreturn retval;\r\nif (chunk->chunk_hdr->type == SCTP_CID_AUTH || pkt->has_auth)\r\nreturn retval;\r\nif (!chunk->auth)\r\nreturn retval;\r\nauth = sctp_make_auth(asoc);\r\nif (!auth)\r\nreturn retval;\r\nretval = sctp_packet_append_chunk(pkt, auth);\r\nreturn retval;\r\n}\r\nstatic sctp_xmit_t sctp_packet_bundle_sack(struct sctp_packet *pkt,\r\nstruct sctp_chunk *chunk)\r\n{\r\nsctp_xmit_t retval = SCTP_XMIT_OK;\r\nif (sctp_chunk_is_data(chunk) && !pkt->has_sack &&\r\n!pkt->has_cookie_echo) {\r\nstruct sctp_association *asoc;\r\nstruct timer_list *timer;\r\nasoc = pkt->transport->asoc;\r\ntimer = &asoc->timers[SCTP_EVENT_TIMEOUT_SACK];\r\nif (timer_pending(timer)) {\r\nstruct sctp_chunk *sack;\r\nasoc->a_rwnd = asoc->rwnd;\r\nsack = sctp_make_sack(asoc);\r\nif (sack) {\r\nretval = sctp_packet_append_chunk(pkt, sack);\r\nasoc->peer.sack_needed = 0;\r\nif (del_timer(timer))\r\nsctp_association_put(asoc);\r\n}\r\n}\r\n}\r\nreturn retval;\r\n}\r\nsctp_xmit_t sctp_packet_append_chunk(struct sctp_packet *packet,\r\nstruct sctp_chunk *chunk)\r\n{\r\nsctp_xmit_t retval = SCTP_XMIT_OK;\r\n__u16 chunk_len = WORD_ROUND(ntohs(chunk->chunk_hdr->length));\r\nSCTP_DEBUG_PRINTK("%s: packet:%p chunk:%p\n", __func__, packet,\r\nchunk);\r\nif (sctp_chunk_is_data(chunk)) {\r\nretval = sctp_packet_can_append_data(packet, chunk);\r\nif (retval != SCTP_XMIT_OK)\r\ngoto finish;\r\n}\r\nretval = sctp_packet_bundle_auth(packet, chunk);\r\nif (retval != SCTP_XMIT_OK)\r\ngoto finish;\r\nretval = sctp_packet_bundle_sack(packet, chunk);\r\nif (retval != SCTP_XMIT_OK)\r\ngoto finish;\r\nretval = sctp_packet_will_fit(packet, chunk, chunk_len);\r\nif (retval != SCTP_XMIT_OK)\r\ngoto finish;\r\nswitch (chunk->chunk_hdr->type) {\r\ncase SCTP_CID_DATA:\r\nsctp_packet_append_data(packet, chunk);\r\npacket->has_sack = 1;\r\npacket->has_auth = 1;\r\npacket->has_data = 1;\r\nchunk->sent_at = jiffies;\r\nbreak;\r\ncase SCTP_CID_COOKIE_ECHO:\r\npacket->has_cookie_echo = 1;\r\nbreak;\r\ncase SCTP_CID_SACK:\r\npacket->has_sack = 1;\r\nbreak;\r\ncase SCTP_CID_AUTH:\r\npacket->has_auth = 1;\r\npacket->auth = chunk;\r\nbreak;\r\n}\r\nlist_add_tail(&chunk->list, &packet->chunk_list);\r\npacket->size += chunk_len;\r\nchunk->transport = packet->transport;\r\nfinish:\r\nreturn retval;\r\n}\r\nint sctp_packet_transmit(struct sctp_packet *packet)\r\n{\r\nstruct sctp_transport *tp = packet->transport;\r\nstruct sctp_association *asoc = tp->asoc;\r\nstruct sctphdr *sh;\r\nstruct sk_buff *nskb;\r\nstruct sctp_chunk *chunk, *tmp;\r\nstruct sock *sk;\r\nint err = 0;\r\nint padding;\r\n__u8 has_data = 0;\r\nstruct dst_entry *dst = tp->dst;\r\nunsigned char *auth = NULL;\r\n__u32 cksum_buf_len = sizeof(struct sctphdr);\r\nSCTP_DEBUG_PRINTK("%s: packet:%p\n", __func__, packet);\r\nif (list_empty(&packet->chunk_list))\r\nreturn err;\r\nchunk = list_entry(packet->chunk_list.next, struct sctp_chunk, list);\r\nsk = chunk->skb->sk;\r\nnskb = alloc_skb(packet->size + LL_MAX_HEADER, GFP_ATOMIC);\r\nif (!nskb)\r\ngoto nomem;\r\nskb_reserve(nskb, packet->overhead + LL_MAX_HEADER);\r\nskb_set_owner_w(nskb, sk);\r\nif (!dst || (dst->obsolete > 1)) {\r\ndst_release(dst);\r\nsctp_transport_route(tp, NULL, sctp_sk(sk));\r\nif (asoc && (asoc->param_flags & SPP_PMTUD_ENABLE)) {\r\nsctp_assoc_sync_pmtu(asoc);\r\n}\r\n}\r\ndst = dst_clone(tp->dst);\r\nskb_dst_set(nskb, dst);\r\nif (!dst)\r\ngoto no_route;\r\nsh = (struct sctphdr *)skb_push(nskb, sizeof(struct sctphdr));\r\nskb_reset_transport_header(nskb);\r\nsh->source = htons(packet->source_port);\r\nsh->dest = htons(packet->destination_port);\r\nsh->vtag = htonl(packet->vtag);\r\nsh->checksum = 0;\r\nSCTP_DEBUG_PRINTK("***sctp_transmit_packet***\n");\r\nlist_for_each_entry_safe(chunk, tmp, &packet->chunk_list, list) {\r\nlist_del_init(&chunk->list);\r\nif (sctp_chunk_is_data(chunk)) {\r\nif (!tp->rto_pending) {\r\nchunk->rtt_in_progress = 1;\r\ntp->rto_pending = 1;\r\n}\r\nhas_data = 1;\r\n}\r\npadding = WORD_ROUND(chunk->skb->len) - chunk->skb->len;\r\nif (padding)\r\nmemset(skb_put(chunk->skb, padding), 0, padding);\r\nif (chunk == packet->auth)\r\nauth = skb_tail_pointer(nskb);\r\ncksum_buf_len += chunk->skb->len;\r\nmemcpy(skb_put(nskb, chunk->skb->len),\r\nchunk->skb->data, chunk->skb->len);\r\nSCTP_DEBUG_PRINTK("%s %p[%s] %s 0x%x, %s %d, %s %d, %s %d\n",\r\n"*** Chunk", chunk,\r\nsctp_cname(SCTP_ST_CHUNK(\r\nchunk->chunk_hdr->type)),\r\nchunk->has_tsn ? "TSN" : "No TSN",\r\nchunk->has_tsn ?\r\nntohl(chunk->subh.data_hdr->tsn) : 0,\r\n"length", ntohs(chunk->chunk_hdr->length),\r\n"chunk->skb->len", chunk->skb->len,\r\n"rtt_in_progress", chunk->rtt_in_progress);\r\nif (!sctp_chunk_is_data(chunk))\r\nsctp_chunk_free(chunk);\r\n}\r\nif (auth)\r\nsctp_auth_calculate_hmac(asoc, nskb,\r\n(struct sctp_auth_chunk *)auth,\r\nGFP_ATOMIC);\r\nif (!sctp_checksum_disable) {\r\nif (!(dst->dev->features & NETIF_F_SCTP_CSUM)) {\r\n__u32 crc32 = sctp_start_cksum((__u8 *)sh, cksum_buf_len);\r\nsh->checksum = sctp_end_cksum(crc32);\r\n} else {\r\nnskb->ip_summed = CHECKSUM_PARTIAL;\r\nnskb->csum_start = (skb_transport_header(nskb) -\r\nnskb->head);\r\nnskb->csum_offset = offsetof(struct sctphdr, checksum);\r\n}\r\n}\r\n(*tp->af_specific->ecn_capable)(nskb->sk);\r\nif (asoc && asoc->peer.last_sent_to != tp) {\r\nasoc->peer.last_sent_to = tp;\r\n}\r\nif (has_data) {\r\nstruct timer_list *timer;\r\nunsigned long timeout;\r\nif (sctp_state(asoc, ESTABLISHED) && asoc->autoclose) {\r\ntimer = &asoc->timers[SCTP_EVENT_TIMEOUT_AUTOCLOSE];\r\ntimeout = asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE];\r\nif (!mod_timer(timer, jiffies + timeout))\r\nsctp_association_hold(asoc);\r\n}\r\n}\r\nSCTP_DEBUG_PRINTK("***sctp_transmit_packet*** skb len %d\n",\r\nnskb->len);\r\nnskb->local_df = packet->ipfragok;\r\n(*tp->af_specific->sctp_xmit)(nskb, tp);\r\nout:\r\nsctp_packet_reset(packet);\r\nreturn err;\r\nno_route:\r\nkfree_skb(nskb);\r\nIP_INC_STATS_BH(&init_net, IPSTATS_MIB_OUTNOROUTES);\r\nerr:\r\nlist_for_each_entry_safe(chunk, tmp, &packet->chunk_list, list) {\r\nlist_del_init(&chunk->list);\r\nif (!sctp_chunk_is_data(chunk))\r\nsctp_chunk_free(chunk);\r\n}\r\ngoto out;\r\nnomem:\r\nerr = -ENOMEM;\r\ngoto err;\r\n}\r\nstatic sctp_xmit_t sctp_packet_can_append_data(struct sctp_packet *packet,\r\nstruct sctp_chunk *chunk)\r\n{\r\nsctp_xmit_t retval = SCTP_XMIT_OK;\r\nsize_t datasize, rwnd, inflight, flight_size;\r\nstruct sctp_transport *transport = packet->transport;\r\nstruct sctp_association *asoc = transport->asoc;\r\nstruct sctp_outq *q = &asoc->outqueue;\r\nrwnd = asoc->peer.rwnd;\r\ninflight = q->outstanding_bytes;\r\nflight_size = transport->flight_size;\r\ndatasize = sctp_data_size(chunk);\r\nif (datasize > rwnd) {\r\nif (inflight > 0) {\r\nretval = SCTP_XMIT_RWND_FULL;\r\ngoto finish;\r\n}\r\n}\r\nif (chunk->fast_retransmit != SCTP_NEED_FRTX)\r\nif (flight_size >= transport->cwnd) {\r\nretval = SCTP_XMIT_RWND_FULL;\r\ngoto finish;\r\n}\r\nif (!sctp_sk(asoc->base.sk)->nodelay && sctp_packet_empty(packet) &&\r\ninflight && sctp_state(asoc, ESTABLISHED)) {\r\nunsigned max = transport->pathmtu - packet->overhead;\r\nunsigned len = chunk->skb->len + q->out_qlen;\r\nif ((len < max) && chunk->msg->can_delay) {\r\nretval = SCTP_XMIT_NAGLE_DELAY;\r\ngoto finish;\r\n}\r\n}\r\nfinish:\r\nreturn retval;\r\n}\r\nstatic void sctp_packet_append_data(struct sctp_packet *packet,\r\nstruct sctp_chunk *chunk)\r\n{\r\nstruct sctp_transport *transport = packet->transport;\r\nsize_t datasize = sctp_data_size(chunk);\r\nstruct sctp_association *asoc = transport->asoc;\r\nu32 rwnd = asoc->peer.rwnd;\r\ntransport->flight_size += datasize;\r\nasoc->outqueue.outstanding_bytes += datasize;\r\nif (datasize < rwnd)\r\nrwnd -= datasize;\r\nelse\r\nrwnd = 0;\r\nasoc->peer.rwnd = rwnd;\r\nif (!asoc->peer.prsctp_capable)\r\nchunk->msg->can_abandon = 0;\r\nsctp_chunk_assign_tsn(chunk);\r\nsctp_chunk_assign_ssn(chunk);\r\n}\r\nstatic sctp_xmit_t sctp_packet_will_fit(struct sctp_packet *packet,\r\nstruct sctp_chunk *chunk,\r\nu16 chunk_len)\r\n{\r\nsize_t psize;\r\nsize_t pmtu;\r\nint too_big;\r\nsctp_xmit_t retval = SCTP_XMIT_OK;\r\npsize = packet->size;\r\npmtu = ((packet->transport->asoc) ?\r\n(packet->transport->asoc->pathmtu) :\r\n(packet->transport->pathmtu));\r\ntoo_big = (psize + chunk_len > pmtu);\r\nif (too_big) {\r\nif (sctp_packet_empty(packet) || !sctp_chunk_is_data(chunk) ||\r\n(!packet->has_data && chunk->auth)) {\r\npacket->ipfragok = 1;\r\n} else {\r\nretval = SCTP_XMIT_PMTU_FULL;\r\n}\r\n}\r\nreturn retval;\r\n}
