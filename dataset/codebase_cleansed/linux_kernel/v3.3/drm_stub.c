int drm_err(const char *func, const char *format, ...)\r\n{\r\nstruct va_format vaf;\r\nva_list args;\r\nint r;\r\nva_start(args, format);\r\nvaf.fmt = format;\r\nvaf.va = &args;\r\nr = printk(KERN_ERR "[" DRM_NAME ":%s] *ERROR* %pV", func, &vaf);\r\nva_end(args);\r\nreturn r;\r\n}\r\nvoid drm_ut_debug_printk(unsigned int request_level,\r\nconst char *prefix,\r\nconst char *function_name,\r\nconst char *format, ...)\r\n{\r\nva_list args;\r\nif (drm_debug & request_level) {\r\nif (function_name)\r\nprintk(KERN_DEBUG "[%s:%s], ", prefix, function_name);\r\nva_start(args, format);\r\nvprintk(format, args);\r\nva_end(args);\r\n}\r\n}\r\nstatic int drm_minor_get_id(struct drm_device *dev, int type)\r\n{\r\nint new_id;\r\nint ret;\r\nint base = 0, limit = 63;\r\nif (type == DRM_MINOR_CONTROL) {\r\nbase += 64;\r\nlimit = base + 127;\r\n} else if (type == DRM_MINOR_RENDER) {\r\nbase += 128;\r\nlimit = base + 255;\r\n}\r\nagain:\r\nif (idr_pre_get(&drm_minors_idr, GFP_KERNEL) == 0) {\r\nDRM_ERROR("Out of memory expanding drawable idr\n");\r\nreturn -ENOMEM;\r\n}\r\nmutex_lock(&dev->struct_mutex);\r\nret = idr_get_new_above(&drm_minors_idr, NULL,\r\nbase, &new_id);\r\nmutex_unlock(&dev->struct_mutex);\r\nif (ret == -EAGAIN) {\r\ngoto again;\r\n} else if (ret) {\r\nreturn ret;\r\n}\r\nif (new_id >= limit) {\r\nidr_remove(&drm_minors_idr, new_id);\r\nreturn -EINVAL;\r\n}\r\nreturn new_id;\r\n}\r\nstruct drm_master *drm_master_create(struct drm_minor *minor)\r\n{\r\nstruct drm_master *master;\r\nmaster = kzalloc(sizeof(*master), GFP_KERNEL);\r\nif (!master)\r\nreturn NULL;\r\nkref_init(&master->refcount);\r\nspin_lock_init(&master->lock.spinlock);\r\ninit_waitqueue_head(&master->lock.lock_queue);\r\ndrm_ht_create(&master->magiclist, DRM_MAGIC_HASH_ORDER);\r\nINIT_LIST_HEAD(&master->magicfree);\r\nmaster->minor = minor;\r\nlist_add_tail(&master->head, &minor->master_list);\r\nreturn master;\r\n}\r\nstruct drm_master *drm_master_get(struct drm_master *master)\r\n{\r\nkref_get(&master->refcount);\r\nreturn master;\r\n}\r\nstatic void drm_master_destroy(struct kref *kref)\r\n{\r\nstruct drm_master *master = container_of(kref, struct drm_master, refcount);\r\nstruct drm_magic_entry *pt, *next;\r\nstruct drm_device *dev = master->minor->dev;\r\nstruct drm_map_list *r_list, *list_temp;\r\nlist_del(&master->head);\r\nif (dev->driver->master_destroy)\r\ndev->driver->master_destroy(dev, master);\r\nlist_for_each_entry_safe(r_list, list_temp, &dev->maplist, head) {\r\nif (r_list->master == master) {\r\ndrm_rmmap_locked(dev, r_list->map);\r\nr_list = NULL;\r\n}\r\n}\r\nif (master->unique) {\r\nkfree(master->unique);\r\nmaster->unique = NULL;\r\nmaster->unique_len = 0;\r\n}\r\nkfree(dev->devname);\r\ndev->devname = NULL;\r\nlist_for_each_entry_safe(pt, next, &master->magicfree, head) {\r\nlist_del(&pt->head);\r\ndrm_ht_remove_item(&master->magiclist, &pt->hash_item);\r\nkfree(pt);\r\n}\r\ndrm_ht_remove(&master->magiclist);\r\nkfree(master);\r\n}\r\nvoid drm_master_put(struct drm_master **master)\r\n{\r\nkref_put(&(*master)->refcount, drm_master_destroy);\r\n*master = NULL;\r\n}\r\nint drm_setmaster_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nint ret = 0;\r\nif (file_priv->is_master)\r\nreturn 0;\r\nif (file_priv->minor->master && file_priv->minor->master != file_priv->master)\r\nreturn -EINVAL;\r\nif (!file_priv->master)\r\nreturn -EINVAL;\r\nif (!file_priv->minor->master &&\r\nfile_priv->minor->master != file_priv->master) {\r\nmutex_lock(&dev->struct_mutex);\r\nfile_priv->minor->master = drm_master_get(file_priv->master);\r\nfile_priv->is_master = 1;\r\nif (dev->driver->master_set) {\r\nret = dev->driver->master_set(dev, file_priv, false);\r\nif (unlikely(ret != 0)) {\r\nfile_priv->is_master = 0;\r\ndrm_master_put(&file_priv->minor->master);\r\n}\r\n}\r\nmutex_unlock(&dev->struct_mutex);\r\n}\r\nreturn 0;\r\n}\r\nint drm_dropmaster_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nif (!file_priv->is_master)\r\nreturn -EINVAL;\r\nif (!file_priv->minor->master)\r\nreturn -EINVAL;\r\nmutex_lock(&dev->struct_mutex);\r\nif (dev->driver->master_drop)\r\ndev->driver->master_drop(dev, file_priv, false);\r\ndrm_master_put(&file_priv->minor->master);\r\nfile_priv->is_master = 0;\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn 0;\r\n}\r\nint drm_fill_in_dev(struct drm_device *dev,\r\nconst struct pci_device_id *ent,\r\nstruct drm_driver *driver)\r\n{\r\nint retcode;\r\nINIT_LIST_HEAD(&dev->filelist);\r\nINIT_LIST_HEAD(&dev->ctxlist);\r\nINIT_LIST_HEAD(&dev->vmalist);\r\nINIT_LIST_HEAD(&dev->maplist);\r\nINIT_LIST_HEAD(&dev->vblank_event_list);\r\nspin_lock_init(&dev->count_lock);\r\nspin_lock_init(&dev->event_lock);\r\nmutex_init(&dev->struct_mutex);\r\nmutex_init(&dev->ctxlist_mutex);\r\nif (drm_ht_create(&dev->map_hash, 12)) {\r\nreturn -ENOMEM;\r\n}\r\ndev->counters = 6;\r\ndev->types[0] = _DRM_STAT_LOCK;\r\ndev->types[1] = _DRM_STAT_OPENS;\r\ndev->types[2] = _DRM_STAT_CLOSES;\r\ndev->types[3] = _DRM_STAT_IOCTLS;\r\ndev->types[4] = _DRM_STAT_LOCKS;\r\ndev->types[5] = _DRM_STAT_UNLOCKS;\r\ndev->driver = driver;\r\nif (dev->driver->bus->agp_init) {\r\nretcode = dev->driver->bus->agp_init(dev);\r\nif (retcode)\r\ngoto error_out_unreg;\r\n}\r\nretcode = drm_ctxbitmap_init(dev);\r\nif (retcode) {\r\nDRM_ERROR("Cannot allocate memory for context bitmap.\n");\r\ngoto error_out_unreg;\r\n}\r\nif (driver->driver_features & DRIVER_GEM) {\r\nretcode = drm_gem_init(dev);\r\nif (retcode) {\r\nDRM_ERROR("Cannot initialize graphics execution "\r\n"manager (GEM)\n");\r\ngoto error_out_unreg;\r\n}\r\n}\r\nreturn 0;\r\nerror_out_unreg:\r\ndrm_lastclose(dev);\r\nreturn retcode;\r\n}\r\nint drm_get_minor(struct drm_device *dev, struct drm_minor **minor, int type)\r\n{\r\nstruct drm_minor *new_minor;\r\nint ret;\r\nint minor_id;\r\nDRM_DEBUG("\n");\r\nminor_id = drm_minor_get_id(dev, type);\r\nif (minor_id < 0)\r\nreturn minor_id;\r\nnew_minor = kzalloc(sizeof(struct drm_minor), GFP_KERNEL);\r\nif (!new_minor) {\r\nret = -ENOMEM;\r\ngoto err_idr;\r\n}\r\nnew_minor->type = type;\r\nnew_minor->device = MKDEV(DRM_MAJOR, minor_id);\r\nnew_minor->dev = dev;\r\nnew_minor->index = minor_id;\r\nINIT_LIST_HEAD(&new_minor->master_list);\r\nidr_replace(&drm_minors_idr, new_minor, minor_id);\r\nif (type == DRM_MINOR_LEGACY) {\r\nret = drm_proc_init(new_minor, minor_id, drm_proc_root);\r\nif (ret) {\r\nDRM_ERROR("DRM: Failed to initialize /proc/dri.\n");\r\ngoto err_mem;\r\n}\r\n} else\r\nnew_minor->proc_root = NULL;\r\n#if defined(CONFIG_DEBUG_FS)\r\nret = drm_debugfs_init(new_minor, minor_id, drm_debugfs_root);\r\nif (ret) {\r\nDRM_ERROR("DRM: Failed to initialize /sys/kernel/debug/dri.\n");\r\ngoto err_g2;\r\n}\r\n#endif\r\nret = drm_sysfs_device_add(new_minor);\r\nif (ret) {\r\nprintk(KERN_ERR\r\n"DRM: Error sysfs_device_add.\n");\r\ngoto err_g2;\r\n}\r\n*minor = new_minor;\r\nDRM_DEBUG("new minor assigned %d\n", minor_id);\r\nreturn 0;\r\nerr_g2:\r\nif (new_minor->type == DRM_MINOR_LEGACY)\r\ndrm_proc_cleanup(new_minor, drm_proc_root);\r\nerr_mem:\r\nkfree(new_minor);\r\nerr_idr:\r\nidr_remove(&drm_minors_idr, minor_id);\r\n*minor = NULL;\r\nreturn ret;\r\n}\r\nint drm_put_minor(struct drm_minor **minor_p)\r\n{\r\nstruct drm_minor *minor = *minor_p;\r\nDRM_DEBUG("release secondary minor %d\n", minor->index);\r\nif (minor->type == DRM_MINOR_LEGACY)\r\ndrm_proc_cleanup(minor, drm_proc_root);\r\n#if defined(CONFIG_DEBUG_FS)\r\ndrm_debugfs_cleanup(minor);\r\n#endif\r\ndrm_sysfs_device_remove(minor);\r\nidr_remove(&drm_minors_idr, minor->index);\r\nkfree(minor);\r\n*minor_p = NULL;\r\nreturn 0;\r\n}\r\nvoid drm_put_dev(struct drm_device *dev)\r\n{\r\nstruct drm_driver *driver;\r\nstruct drm_map_list *r_list, *list_temp;\r\nDRM_DEBUG("\n");\r\nif (!dev) {\r\nDRM_ERROR("cleanup called no dev\n");\r\nreturn;\r\n}\r\ndriver = dev->driver;\r\ndrm_lastclose(dev);\r\nif (drm_core_has_MTRR(dev) && drm_core_has_AGP(dev) &&\r\ndev->agp && dev->agp->agp_mtrr >= 0) {\r\nint retval;\r\nretval = mtrr_del(dev->agp->agp_mtrr,\r\ndev->agp->agp_info.aper_base,\r\ndev->agp->agp_info.aper_size * 1024 * 1024);\r\nDRM_DEBUG("mtrr_del=%d\n", retval);\r\n}\r\nif (dev->driver->unload)\r\ndev->driver->unload(dev);\r\nif (drm_core_has_AGP(dev) && dev->agp) {\r\nkfree(dev->agp);\r\ndev->agp = NULL;\r\n}\r\ndrm_vblank_cleanup(dev);\r\nlist_for_each_entry_safe(r_list, list_temp, &dev->maplist, head)\r\ndrm_rmmap(dev, r_list->map);\r\ndrm_ht_remove(&dev->map_hash);\r\ndrm_ctxbitmap_cleanup(dev);\r\nif (drm_core_check_feature(dev, DRIVER_MODESET))\r\ndrm_put_minor(&dev->control);\r\nif (driver->driver_features & DRIVER_GEM)\r\ndrm_gem_destroy(dev);\r\ndrm_put_minor(&dev->primary);\r\nlist_del(&dev->driver_item);\r\nif (dev->devname) {\r\nkfree(dev->devname);\r\ndev->devname = NULL;\r\n}\r\nkfree(dev);\r\n}
