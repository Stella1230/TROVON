static int wdrtas_set_interval(int interval)\r\n{\r\nlong result;\r\nstatic int print_msg = 10;\r\ninterval = (interval + 59) / 60;\r\nresult = rtas_call(wdrtas_token_set_indicator, 3, 1, NULL,\r\nWDRTAS_SURVEILLANCE_IND, 0, interval);\r\nif (result < 0 && print_msg) {\r\nprintk(KERN_ERR "wdrtas: setting the watchdog to %i "\r\n"timeout failed: %li\n", interval, result);\r\nprint_msg--;\r\n}\r\nreturn result;\r\n}\r\nstatic int wdrtas_get_interval(int fallback_value)\r\n{\r\nlong result;\r\nchar value[WDRTAS_SP_SPI_LEN];\r\nspin_lock(&rtas_data_buf_lock);\r\nmemset(rtas_data_buf, 0, WDRTAS_SP_SPI_LEN);\r\nresult = rtas_call(wdrtas_token_get_sp, 3, 1, NULL,\r\nWDRTAS_SP_SPI, __pa(rtas_data_buf),\r\nWDRTAS_SP_SPI_LEN);\r\nmemcpy(value, rtas_data_buf, WDRTAS_SP_SPI_LEN);\r\nspin_unlock(&rtas_data_buf_lock);\r\nif (value[0] != 0 || value[1] != 2 || value[3] != 0 || result < 0) {\r\nprintk(KERN_WARNING "wdrtas: could not get sp_spi watchdog "\r\n"timeout (%li). Continuing\n", result);\r\nreturn fallback_value;\r\n}\r\nreturn ((int)value[2]) * 60;\r\n}\r\nstatic void wdrtas_timer_start(void)\r\n{\r\nwdrtas_set_interval(wdrtas_interval);\r\n}\r\nstatic void wdrtas_timer_stop(void)\r\n{\r\nwdrtas_set_interval(0);\r\n}\r\nstatic void wdrtas_log_scanned_event(void)\r\n{\r\nint i;\r\nfor (i = 0; i < WDRTAS_LOGBUFFER_LEN; i += 16)\r\nprintk(KERN_INFO "wdrtas: dumping event (line %i/%i), data = "\r\n"%02x %02x %02x %02x %02x %02x %02x %02x "\r\n"%02x %02x %02x %02x %02x %02x %02x %02x\n",\r\n(i / 16) + 1, (WDRTAS_LOGBUFFER_LEN / 16),\r\nwdrtas_logbuffer[i + 0], wdrtas_logbuffer[i + 1],\r\nwdrtas_logbuffer[i + 2], wdrtas_logbuffer[i + 3],\r\nwdrtas_logbuffer[i + 4], wdrtas_logbuffer[i + 5],\r\nwdrtas_logbuffer[i + 6], wdrtas_logbuffer[i + 7],\r\nwdrtas_logbuffer[i + 8], wdrtas_logbuffer[i + 9],\r\nwdrtas_logbuffer[i + 10], wdrtas_logbuffer[i + 11],\r\nwdrtas_logbuffer[i + 12], wdrtas_logbuffer[i + 13],\r\nwdrtas_logbuffer[i + 14], wdrtas_logbuffer[i + 15]);\r\n}\r\nstatic void wdrtas_timer_keepalive(void)\r\n{\r\nlong result;\r\ndo {\r\nresult = rtas_call(wdrtas_token_event_scan, 4, 1, NULL,\r\nRTAS_EVENT_SCAN_ALL_EVENTS, 0,\r\n(void *)__pa(wdrtas_logbuffer),\r\nWDRTAS_LOGBUFFER_LEN);\r\nif (result < 0)\r\nprintk(KERN_ERR "wdrtas: event-scan failed: %li\n",\r\nresult);\r\nif (result == 0)\r\nwdrtas_log_scanned_event();\r\n} while (result == 0);\r\n}\r\nstatic int wdrtas_get_temperature(void)\r\n{\r\nint result;\r\nint temperature = 0;\r\nresult = rtas_get_sensor(WDRTAS_THERMAL_SENSOR, 0, &temperature);\r\nif (result < 0)\r\nprintk(KERN_WARNING "wdrtas: reading the thermal sensor "\r\n"failed: %i\n", result);\r\nelse\r\ntemperature = ((temperature * 9) / 5) + 32;\r\nreturn temperature;\r\n}\r\nstatic int wdrtas_get_status(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic int wdrtas_get_boot_status(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic ssize_t wdrtas_write(struct file *file, const char __user *buf,\r\nsize_t len, loff_t *ppos)\r\n{\r\nint i;\r\nchar c;\r\nif (!len)\r\ngoto out;\r\nif (!wdrtas_nowayout) {\r\nwdrtas_expect_close = 0;\r\nfor (i = 0; i < len; i++) {\r\nif (get_user(c, buf + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nwdrtas_expect_close = WDRTAS_MAGIC_CHAR;\r\n}\r\n}\r\nwdrtas_timer_keepalive();\r\nout:\r\nreturn len;\r\n}\r\nstatic long wdrtas_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint __user *argp = (void __user *)arg;\r\nint i;\r\nstatic const struct watchdog_info wdinfo = {\r\n.options = WDRTAS_SUPPORTED_MASK,\r\n.firmware_version = 0,\r\n.identity = "wdrtas",\r\n};\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nif (copy_to_user(argp, &wdinfo, sizeof(wdinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase WDIOC_GETSTATUS:\r\ni = wdrtas_get_status();\r\nreturn put_user(i, argp);\r\ncase WDIOC_GETBOOTSTATUS:\r\ni = wdrtas_get_boot_status();\r\nreturn put_user(i, argp);\r\ncase WDIOC_GETTEMP:\r\nif (wdrtas_token_get_sensor_state == RTAS_UNKNOWN_SERVICE)\r\nreturn -EOPNOTSUPP;\r\ni = wdrtas_get_temperature();\r\nreturn put_user(i, argp);\r\ncase WDIOC_SETOPTIONS:\r\nif (get_user(i, argp))\r\nreturn -EFAULT;\r\nif (i & WDIOS_DISABLECARD)\r\nwdrtas_timer_stop();\r\nif (i & WDIOS_ENABLECARD) {\r\nwdrtas_timer_keepalive();\r\nwdrtas_timer_start();\r\n}\r\nreturn 0;\r\ncase WDIOC_KEEPALIVE:\r\nwdrtas_timer_keepalive();\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(i, argp))\r\nreturn -EFAULT;\r\nif (wdrtas_set_interval(i))\r\nreturn -EINVAL;\r\nwdrtas_timer_keepalive();\r\nif (wdrtas_token_get_sp == RTAS_UNKNOWN_SERVICE)\r\nwdrtas_interval = i;\r\nelse\r\nwdrtas_interval = wdrtas_get_interval(i);\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(wdrtas_interval, argp);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int wdrtas_open(struct inode *inode, struct file *file)\r\n{\r\nif (atomic_inc_return(&wdrtas_miscdev_open) > 1) {\r\natomic_dec(&wdrtas_miscdev_open);\r\nreturn -EBUSY;\r\n}\r\nwdrtas_timer_start();\r\nwdrtas_timer_keepalive();\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int wdrtas_close(struct inode *inode, struct file *file)\r\n{\r\nif (wdrtas_expect_close == WDRTAS_MAGIC_CHAR)\r\nwdrtas_timer_stop();\r\nelse {\r\nprintk(KERN_WARNING "wdrtas: got unexpected close. Watchdog "\r\n"not stopped.\n");\r\nwdrtas_timer_keepalive();\r\n}\r\nwdrtas_expect_close = 0;\r\natomic_dec(&wdrtas_miscdev_open);\r\nreturn 0;\r\n}\r\nstatic ssize_t wdrtas_temp_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint temperature = 0;\r\ntemperature = wdrtas_get_temperature();\r\nif (temperature < 0)\r\nreturn temperature;\r\nif (copy_to_user(buf, &temperature, 1))\r\nreturn -EFAULT;\r\nreturn 1;\r\n}\r\nstatic int wdrtas_temp_open(struct inode *inode, struct file *file)\r\n{\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int wdrtas_temp_close(struct inode *inode, struct file *file)\r\n{\r\nreturn 0;\r\n}\r\nstatic int wdrtas_reboot(struct notifier_block *this,\r\nunsigned long code, void *ptr)\r\n{\r\nif (code == SYS_DOWN || code == SYS_HALT)\r\nwdrtas_timer_stop();\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int wdrtas_get_tokens(void)\r\n{\r\nwdrtas_token_get_sensor_state = rtas_token("get-sensor-state");\r\nif (wdrtas_token_get_sensor_state == RTAS_UNKNOWN_SERVICE) {\r\nprintk(KERN_WARNING "wdrtas: couldn't get token for "\r\n"get-sensor-state. Trying to continue without "\r\n"temperature support.\n");\r\n}\r\nwdrtas_token_get_sp = rtas_token("ibm,get-system-parameter");\r\nif (wdrtas_token_get_sp == RTAS_UNKNOWN_SERVICE) {\r\nprintk(KERN_WARNING "wdrtas: couldn't get token for "\r\n"ibm,get-system-parameter. Trying to continue with "\r\n"a default timeout value of %i seconds.\n",\r\nWDRTAS_DEFAULT_INTERVAL);\r\n}\r\nwdrtas_token_set_indicator = rtas_token("set-indicator");\r\nif (wdrtas_token_set_indicator == RTAS_UNKNOWN_SERVICE) {\r\nprintk(KERN_ERR "wdrtas: couldn't get token for "\r\n"set-indicator. Terminating watchdog code.\n");\r\nreturn -EIO;\r\n}\r\nwdrtas_token_event_scan = rtas_token("event-scan");\r\nif (wdrtas_token_event_scan == RTAS_UNKNOWN_SERVICE) {\r\nprintk(KERN_ERR "wdrtas: couldn't get token for event-scan. "\r\n"Terminating watchdog code.\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void wdrtas_unregister_devs(void)\r\n{\r\nmisc_deregister(&wdrtas_miscdev);\r\nif (wdrtas_token_get_sensor_state != RTAS_UNKNOWN_SERVICE)\r\nmisc_deregister(&wdrtas_tempdev);\r\n}\r\nstatic int wdrtas_register_devs(void)\r\n{\r\nint result;\r\nresult = misc_register(&wdrtas_miscdev);\r\nif (result) {\r\nprintk(KERN_ERR "wdrtas: couldn't register watchdog misc "\r\n"device. Terminating watchdog code.\n");\r\nreturn result;\r\n}\r\nif (wdrtas_token_get_sensor_state != RTAS_UNKNOWN_SERVICE) {\r\nresult = misc_register(&wdrtas_tempdev);\r\nif (result) {\r\nprintk(KERN_WARNING "wdrtas: couldn't register "\r\n"watchdog temperature misc device. Continuing "\r\n"without temperature support.\n");\r\nwdrtas_token_get_sensor_state = RTAS_UNKNOWN_SERVICE;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init wdrtas_init(void)\r\n{\r\nif (wdrtas_get_tokens())\r\nreturn -ENODEV;\r\nif (wdrtas_register_devs())\r\nreturn -ENODEV;\r\nif (register_reboot_notifier(&wdrtas_notifier)) {\r\nprintk(KERN_ERR "wdrtas: could not register reboot notifier. "\r\n"Terminating watchdog code.\n");\r\nwdrtas_unregister_devs();\r\nreturn -ENODEV;\r\n}\r\nif (wdrtas_token_get_sp == RTAS_UNKNOWN_SERVICE)\r\nwdrtas_interval = WDRTAS_DEFAULT_INTERVAL;\r\nelse\r\nwdrtas_interval = wdrtas_get_interval(WDRTAS_DEFAULT_INTERVAL);\r\nreturn 0;\r\n}\r\nstatic void __exit wdrtas_exit(void)\r\n{\r\nif (!wdrtas_nowayout)\r\nwdrtas_timer_stop();\r\nwdrtas_unregister_devs();\r\nunregister_reboot_notifier(&wdrtas_notifier);\r\n}
