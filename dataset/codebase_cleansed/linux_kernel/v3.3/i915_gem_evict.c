static bool\r\nmark_free(struct drm_i915_gem_object *obj, struct list_head *unwind)\r\n{\r\nlist_add(&obj->exec_list, unwind);\r\ndrm_gem_object_reference(&obj->base);\r\nreturn drm_mm_scan_add_block(obj->gtt_space);\r\n}\r\nint\r\ni915_gem_evict_something(struct drm_device *dev, int min_size,\r\nunsigned alignment, bool mappable)\r\n{\r\ndrm_i915_private_t *dev_priv = dev->dev_private;\r\nstruct list_head eviction_list, unwind_list;\r\nstruct drm_i915_gem_object *obj;\r\nint ret = 0;\r\ni915_gem_retire_requests(dev);\r\nif (mappable) {\r\nif (drm_mm_search_free_in_range(&dev_priv->mm.gtt_space,\r\nmin_size, alignment, 0,\r\ndev_priv->mm.gtt_mappable_end,\r\n0))\r\nreturn 0;\r\n} else {\r\nif (drm_mm_search_free(&dev_priv->mm.gtt_space,\r\nmin_size, alignment, 0))\r\nreturn 0;\r\n}\r\ntrace_i915_gem_evict(dev, min_size, alignment, mappable);\r\nINIT_LIST_HEAD(&unwind_list);\r\nif (mappable)\r\ndrm_mm_init_scan_with_range(&dev_priv->mm.gtt_space, min_size,\r\nalignment, 0,\r\ndev_priv->mm.gtt_mappable_end);\r\nelse\r\ndrm_mm_init_scan(&dev_priv->mm.gtt_space, min_size, alignment);\r\nlist_for_each_entry(obj, &dev_priv->mm.inactive_list, mm_list) {\r\nif (mark_free(obj, &unwind_list))\r\ngoto found;\r\n}\r\nlist_for_each_entry(obj, &dev_priv->mm.active_list, mm_list) {\r\nif (obj->base.write_domain || obj->pin_count)\r\ncontinue;\r\nif (mark_free(obj, &unwind_list))\r\ngoto found;\r\n}\r\nlist_for_each_entry(obj, &dev_priv->mm.flushing_list, mm_list) {\r\nif (obj->pin_count)\r\ncontinue;\r\nif (mark_free(obj, &unwind_list))\r\ngoto found;\r\n}\r\nlist_for_each_entry(obj, &dev_priv->mm.active_list, mm_list) {\r\nif (!obj->base.write_domain || obj->pin_count)\r\ncontinue;\r\nif (mark_free(obj, &unwind_list))\r\ngoto found;\r\n}\r\nwhile (!list_empty(&unwind_list)) {\r\nobj = list_first_entry(&unwind_list,\r\nstruct drm_i915_gem_object,\r\nexec_list);\r\nret = drm_mm_scan_remove_block(obj->gtt_space);\r\nBUG_ON(ret);\r\nlist_del_init(&obj->exec_list);\r\ndrm_gem_object_unreference(&obj->base);\r\n}\r\nreturn -ENOSPC;\r\nfound:\r\nINIT_LIST_HEAD(&eviction_list);\r\nwhile (!list_empty(&unwind_list)) {\r\nobj = list_first_entry(&unwind_list,\r\nstruct drm_i915_gem_object,\r\nexec_list);\r\nif (drm_mm_scan_remove_block(obj->gtt_space)) {\r\nlist_move(&obj->exec_list, &eviction_list);\r\ncontinue;\r\n}\r\nlist_del_init(&obj->exec_list);\r\ndrm_gem_object_unreference(&obj->base);\r\n}\r\nwhile (!list_empty(&eviction_list)) {\r\nobj = list_first_entry(&eviction_list,\r\nstruct drm_i915_gem_object,\r\nexec_list);\r\nif (ret == 0)\r\nret = i915_gem_object_unbind(obj);\r\nlist_del_init(&obj->exec_list);\r\ndrm_gem_object_unreference(&obj->base);\r\n}\r\nreturn ret;\r\n}\r\nint\r\ni915_gem_evict_everything(struct drm_device *dev, bool purgeable_only)\r\n{\r\ndrm_i915_private_t *dev_priv = dev->dev_private;\r\nint ret;\r\nbool lists_empty;\r\nlists_empty = (list_empty(&dev_priv->mm.inactive_list) &&\r\nlist_empty(&dev_priv->mm.flushing_list) &&\r\nlist_empty(&dev_priv->mm.active_list));\r\nif (lists_empty)\r\nreturn -ENOSPC;\r\ntrace_i915_gem_evict_everything(dev, purgeable_only);\r\nret = i915_gpu_idle(dev);\r\nif (ret)\r\nreturn ret;\r\nBUG_ON(!list_empty(&dev_priv->mm.flushing_list));\r\nreturn i915_gem_evict_inactive(dev, purgeable_only);\r\n}\r\nint\r\ni915_gem_evict_inactive(struct drm_device *dev, bool purgeable_only)\r\n{\r\ndrm_i915_private_t *dev_priv = dev->dev_private;\r\nstruct drm_i915_gem_object *obj, *next;\r\nlist_for_each_entry_safe(obj, next,\r\n&dev_priv->mm.inactive_list, mm_list) {\r\nif (!purgeable_only || obj->madv != I915_MADV_WILLNEED) {\r\nint ret = i915_gem_object_unbind(obj);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}
