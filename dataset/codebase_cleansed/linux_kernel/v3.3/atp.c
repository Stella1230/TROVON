static int __init atp_init(void)\r\n{\r\nint *port, ports[] = {0x378, 0x278, 0x3bc, 0};\r\nint base_addr = io[0];\r\nif (base_addr > 0x1ff)\r\nreturn atp_probe1(base_addr);\r\nelse if (base_addr == 1)\r\nreturn -ENXIO;\r\nfor (port = ports; *port; port++) {\r\nlong ioaddr = *port;\r\noutb(0x57, ioaddr + PAR_DATA);\r\nif (inb(ioaddr + PAR_DATA) != 0x57)\r\ncontinue;\r\nif (atp_probe1(ioaddr) == 0)\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int __init atp_probe1(long ioaddr)\r\n{\r\nstruct net_device *dev = NULL;\r\nstruct net_local *lp;\r\nint saved_ctrl_reg, status, i;\r\nint res;\r\noutb(0xff, ioaddr + PAR_DATA);\r\nsaved_ctrl_reg = inb(ioaddr + PAR_CONTROL);\r\nif (net_debug > 3)\r\nprintk("atp: Control register was %#2.2x.\n", saved_ctrl_reg);\r\noutb(0x04, ioaddr + PAR_CONTROL);\r\n#ifndef final_version\r\nif (net_debug > 3) {\r\nfor (i = 0; i < 8; i++)\r\noutb(mux_8012[i], ioaddr + PAR_DATA);\r\nwrite_reg(ioaddr, MODSEL, 0x00);\r\nprintk("atp: Registers are ");\r\nfor (i = 0; i < 32; i++)\r\nprintk(" %2.2x", read_nibble(ioaddr, i));\r\nprintk(".\n");\r\n}\r\n#endif\r\nfor (i = 0; i < 8; i++)\r\noutb(mux_8012[i], ioaddr + PAR_DATA);\r\nwrite_reg_high(ioaddr, CMR1, CMR1h_RESET);\r\nstatus = read_nibble(ioaddr, CMR1);\r\nif (net_debug > 3) {\r\nprintk(KERN_DEBUG "atp: Status nibble was %#2.2x..", status);\r\nfor (i = 0; i < 32; i++)\r\nprintk(" %2.2x", read_nibble(ioaddr, i));\r\nprintk("\n");\r\n}\r\nif ((status & 0x78) != 0x08) {\r\noutb(saved_ctrl_reg, ioaddr + PAR_CONTROL);\r\nreturn -ENODEV;\r\n}\r\nstatus = read_nibble(ioaddr, CMR2_h);\r\nif ((status & 0x78) != 0x10) {\r\noutb(saved_ctrl_reg, ioaddr + PAR_CONTROL);\r\nreturn -ENODEV;\r\n}\r\ndev = alloc_etherdev(sizeof(struct net_local));\r\nif (!dev)\r\nreturn -ENOMEM;\r\nwrite_reg_byte(ioaddr, CMR2, 0x01);\r\nwrite_reg_high(ioaddr, CMR1, CMR1h_RxENABLE | CMR1h_TxENABLE);\r\nif (irq[0])\r\ndev->irq = irq[0];\r\nelse if (ioaddr == 0x378)\r\ndev->irq = 7;\r\nelse\r\ndev->irq = 5;\r\nwrite_reg_high(ioaddr, CMR1, CMR1h_TxRxOFF);\r\nwrite_reg(ioaddr, CMR2, CMR2_NULL);\r\ndev->base_addr = ioaddr;\r\nget_node_ID(dev);\r\n#ifndef MODULE\r\nif (net_debug)\r\nprintk(KERN_INFO "%s", version);\r\n#endif\r\nprintk(KERN_NOTICE "%s: Pocket adapter found at %#3lx, IRQ %d, "\r\n"SAPROM %pM.\n",\r\ndev->name, dev->base_addr, dev->irq, dev->dev_addr);\r\nwrite_reg_high(ioaddr, CMR1, CMR1h_RESET | CMR1h_MUX);\r\nlp = netdev_priv(dev);\r\nlp->chip_type = RTL8002;\r\nlp->addr_mode = CMR2h_Normal;\r\nspin_lock_init(&lp->lock);\r\nif (xcvr[0])\r\ndev->if_port = xcvr[0];\r\nelse\r\ndev->if_port = (dev->mem_start & 0xf) ? (dev->mem_start & 0x7) : 4;\r\nif (dev->mem_end & 0xf)\r\nnet_debug = dev->mem_end & 7;\r\ndev->netdev_ops = &atp_netdev_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\nres = register_netdev(dev);\r\nif (res) {\r\nfree_netdev(dev);\r\nreturn res;\r\n}\r\nlp->next_module = root_atp_dev;\r\nroot_atp_dev = dev;\r\nreturn 0;\r\n}\r\nstatic void __init get_node_ID(struct net_device *dev)\r\n{\r\nlong ioaddr = dev->base_addr;\r\nint sa_offset = 0;\r\nint i;\r\nwrite_reg(ioaddr, CMR2, CMR2_EEPROM);\r\nif (eeprom_op(ioaddr, EE_READ(0)) == 0xffff)\r\nsa_offset = 15;\r\nfor (i = 0; i < 3; i++)\r\n((__be16 *)dev->dev_addr)[i] =\r\ncpu_to_be16(eeprom_op(ioaddr, EE_READ(sa_offset + i)));\r\nwrite_reg(ioaddr, CMR2, CMR2_NULL);\r\n}\r\nstatic unsigned short __init eeprom_op(long ioaddr, u32 cmd)\r\n{\r\nunsigned eedata_out = 0;\r\nint num_bits = EE_CMD_SIZE;\r\nwhile (--num_bits >= 0) {\r\nchar outval = (cmd & (1<<num_bits)) ? EE_DATA_WRITE : 0;\r\nwrite_reg_high(ioaddr, PROM_CMD, outval | EE_CLK_LOW);\r\nwrite_reg_high(ioaddr, PROM_CMD, outval | EE_CLK_HIGH);\r\needata_out <<= 1;\r\nif (read_nibble(ioaddr, PROM_DATA) & EE_DATA_READ)\r\needata_out++;\r\n}\r\nwrite_reg_high(ioaddr, PROM_CMD, EE_CLK_LOW & ~EE_CS);\r\nreturn eedata_out;\r\n}\r\nstatic int net_open(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nint ret;\r\nret = request_irq(dev->irq, atp_interrupt, 0, dev->name, dev);\r\nif (ret)\r\nreturn ret;\r\nhardware_init(dev);\r\ninit_timer(&lp->timer);\r\nlp->timer.expires = jiffies + TIMED_CHECKER;\r\nlp->timer.data = (unsigned long)dev;\r\nlp->timer.function = atp_timed_checker;\r\nadd_timer(&lp->timer);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic void hardware_init(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nlong ioaddr = dev->base_addr;\r\nint i;\r\nfor (i = 0; i < 8; i++)\r\noutb(mux_8012[i], ioaddr + PAR_DATA);\r\nwrite_reg_high(ioaddr, CMR1, CMR1h_RESET);\r\nfor (i = 0; i < 6; i++)\r\nwrite_reg_byte(ioaddr, PAR0 + i, dev->dev_addr[i]);\r\nwrite_reg_high(ioaddr, CMR2, lp->addr_mode);\r\nif (net_debug > 2) {\r\nprintk(KERN_DEBUG "%s: Reset: current Rx mode %d.\n", dev->name,\r\n(read_nibble(ioaddr, CMR2_h) >> 3) & 0x0f);\r\n}\r\nwrite_reg(ioaddr, CMR2, CMR2_IRQOUT);\r\nwrite_reg_high(ioaddr, CMR1, CMR1h_RxENABLE | CMR1h_TxENABLE);\r\noutb(Ctrl_SelData + Ctrl_IRQEN, ioaddr + PAR_CONTROL);\r\nwrite_reg(ioaddr, IMR, ISR_RxOK | ISR_TxErr | ISR_TxOK);\r\nwrite_reg_high(ioaddr, IMR, ISRh_RxErr);\r\nlp->tx_unit_busy = 0;\r\nlp->pac_cnt_in_tx_buf = 0;\r\nlp->saved_tx_size = 0;\r\n}\r\nstatic void trigger_send(long ioaddr, int length)\r\n{\r\nwrite_reg_byte(ioaddr, TxCNT0, length & 0xff);\r\nwrite_reg(ioaddr, TxCNT1, length >> 8);\r\nwrite_reg(ioaddr, CMR1, CMR1_Xmit);\r\n}\r\nstatic void write_packet(long ioaddr, int length, unsigned char *packet, int pad_len, int data_mode)\r\n{\r\nif (length & 1)\r\n{\r\nlength++;\r\npad_len++;\r\n}\r\noutb(EOC+MAR, ioaddr + PAR_DATA);\r\nif ((data_mode & 1) == 0) {\r\noutb(WrAddr+MAR, ioaddr + PAR_DATA);\r\ndo {\r\nwrite_byte_mode0(ioaddr, *packet++);\r\n} while (--length > pad_len) ;\r\ndo {\r\nwrite_byte_mode0(ioaddr, 0);\r\n} while (--length > 0) ;\r\n} else {\r\nunsigned char outbyte = *packet++;\r\noutb(Ctrl_LNibWrite + Ctrl_IRQEN, ioaddr + PAR_CONTROL);\r\noutb(WrAddr+MAR, ioaddr + PAR_DATA);\r\noutb((outbyte & 0x0f)|0x40, ioaddr + PAR_DATA);\r\noutb(outbyte & 0x0f, ioaddr + PAR_DATA);\r\noutbyte >>= 4;\r\noutb(outbyte & 0x0f, ioaddr + PAR_DATA);\r\noutb(Ctrl_HNibWrite + Ctrl_IRQEN, ioaddr + PAR_CONTROL);\r\nwhile (--length > pad_len)\r\nwrite_byte_mode1(ioaddr, *packet++);\r\nwhile (--length > 0)\r\nwrite_byte_mode1(ioaddr, 0);\r\n}\r\noutb(0xff, ioaddr + PAR_DATA);\r\noutb(Ctrl_HNibWrite | Ctrl_SelData | Ctrl_IRQEN, ioaddr + PAR_CONTROL);\r\n}\r\nstatic void tx_timeout(struct net_device *dev)\r\n{\r\nlong ioaddr = dev->base_addr;\r\nprintk(KERN_WARNING "%s: Transmit timed out, %s?\n", dev->name,\r\ninb(ioaddr + PAR_CONTROL) & 0x10 ? "network cable problem"\r\n: "IRQ conflict");\r\ndev->stats.tx_errors++;\r\nhardware_init(dev);\r\ndev->trans_start = jiffies;\r\nnetif_wake_queue(dev);\r\ndev->stats.tx_errors++;\r\n}\r\nstatic netdev_tx_t atp_send_packet(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nlong ioaddr = dev->base_addr;\r\nint length;\r\nunsigned long flags;\r\nlength = ETH_ZLEN < skb->len ? skb->len : ETH_ZLEN;\r\nnetif_stop_queue(dev);\r\nspin_lock_irqsave(&lp->lock, flags);\r\nwrite_reg(ioaddr, IMR, 0);\r\nwrite_reg_high(ioaddr, IMR, 0);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nwrite_packet(ioaddr, length, skb->data, length-skb->len, dev->if_port);\r\nlp->pac_cnt_in_tx_buf++;\r\nif (lp->tx_unit_busy == 0) {\r\ntrigger_send(ioaddr, length);\r\nlp->saved_tx_size = 0;\r\nlp->re_tx = 0;\r\nlp->tx_unit_busy = 1;\r\n} else\r\nlp->saved_tx_size = length;\r\nwrite_reg(ioaddr, IMR, ISR_RxOK | ISR_TxErr | ISR_TxOK);\r\nwrite_reg_high(ioaddr, IMR, ISRh_RxErr);\r\ndev_kfree_skb (skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t atp_interrupt(int irq, void *dev_instance)\r\n{\r\nstruct net_device *dev = dev_instance;\r\nstruct net_local *lp;\r\nlong ioaddr;\r\nstatic int num_tx_since_rx;\r\nint boguscount = max_interrupt_work;\r\nint handled = 0;\r\nioaddr = dev->base_addr;\r\nlp = netdev_priv(dev);\r\nspin_lock(&lp->lock);\r\noutb(Ctrl_SelData, ioaddr + PAR_CONTROL);\r\nwrite_reg(ioaddr, CMR2, CMR2_NULL);\r\nwrite_reg(ioaddr, IMR, 0);\r\nif (net_debug > 5) printk(KERN_DEBUG "%s: In interrupt ", dev->name);\r\nwhile (--boguscount > 0) {\r\nint status = read_nibble(ioaddr, ISR);\r\nif (net_debug > 5) printk("loop status %02x..", status);\r\nif (status & (ISR_RxOK<<3)) {\r\nhandled = 1;\r\nwrite_reg(ioaddr, ISR, ISR_RxOK);\r\ndo {\r\nint read_status = read_nibble(ioaddr, CMR1);\r\nif (net_debug > 6)\r\nprintk("handling Rx packet %02x..", read_status);\r\nif (read_status & (CMR1_IRQ << 3)) {\r\ndev->stats.rx_over_errors++;\r\nwrite_reg_high(ioaddr, CMR2, CMR2h_OFF);\r\nnet_rx(dev);\r\nwrite_reg_high(ioaddr, ISR, ISRh_RxErr);\r\nwrite_reg_high(ioaddr, CMR2, lp->addr_mode);\r\n} else if ((read_status & (CMR1_BufEnb << 3)) == 0) {\r\nnet_rx(dev);\r\nnum_tx_since_rx = 0;\r\n} else\r\nbreak;\r\n} while (--boguscount > 0);\r\n} else if (status & ((ISR_TxErr + ISR_TxOK)<<3)) {\r\nhandled = 1;\r\nif (net_debug > 6) printk("handling Tx done..");\r\nwrite_reg(ioaddr, ISR, ISR_TxErr + ISR_TxOK);\r\nif (status & (ISR_TxErr<<3)) {\r\ndev->stats.collisions++;\r\nif (++lp->re_tx > 15) {\r\ndev->stats.tx_aborted_errors++;\r\nhardware_init(dev);\r\nbreak;\r\n}\r\nif (net_debug > 6) printk("attempting to ReTx");\r\nwrite_reg(ioaddr, CMR1, CMR1_ReXmit + CMR1_Xmit);\r\n} else {\r\ndev->stats.tx_packets++;\r\nlp->pac_cnt_in_tx_buf--;\r\nif ( lp->saved_tx_size) {\r\ntrigger_send(ioaddr, lp->saved_tx_size);\r\nlp->saved_tx_size = 0;\r\nlp->re_tx = 0;\r\n} else\r\nlp->tx_unit_busy = 0;\r\nnetif_wake_queue(dev);\r\n}\r\nnum_tx_since_rx++;\r\n} else if (num_tx_since_rx > 8 &&\r\ntime_after(jiffies, dev->last_rx + HZ)) {\r\nif (net_debug > 2)\r\nprintk(KERN_DEBUG "%s: Missed packet? No Rx after %d Tx and "\r\n"%ld jiffies status %02x CMR1 %02x.\n", dev->name,\r\nnum_tx_since_rx, jiffies - dev->last_rx, status,\r\n(read_nibble(ioaddr, CMR1) >> 3) & 15);\r\ndev->stats.rx_missed_errors++;\r\nhardware_init(dev);\r\nnum_tx_since_rx = 0;\r\nbreak;\r\n} else\r\nbreak;\r\n}\r\n{\r\nint i;\r\nfor (i = 0; i < 6; i++)\r\nwrite_reg_byte(ioaddr, PAR0 + i, dev->dev_addr[i]);\r\n#if 0 && defined(TIMED_CHECKER)\r\nmod_timer(&lp->timer, jiffies + TIMED_CHECKER);\r\n#endif\r\n}\r\nwrite_reg(ioaddr, CMR2, CMR2_IRQOUT);\r\noutb(Ctrl_SelData + Ctrl_IRQEN, ioaddr + PAR_CONTROL);\r\nwrite_reg(ioaddr, IMR, ISR_RxOK | ISR_TxErr | ISR_TxOK);\r\nwrite_reg_high(ioaddr, IMR, ISRh_RxErr);\r\nspin_unlock(&lp->lock);\r\nif (net_debug > 5) printk("exiting interrupt.\n");\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void atp_timed_checker(unsigned long data)\r\n{\r\nstruct net_device *dev = (struct net_device *)data;\r\nlong ioaddr = dev->base_addr;\r\nstruct net_local *lp = netdev_priv(dev);\r\nint tickssofar = jiffies - lp->last_rx_time;\r\nint i;\r\nspin_lock(&lp->lock);\r\nif (tickssofar > 2*HZ) {\r\n#if 1\r\nfor (i = 0; i < 6; i++)\r\nwrite_reg_byte(ioaddr, PAR0 + i, dev->dev_addr[i]);\r\nlp->last_rx_time = jiffies;\r\n#else\r\nfor (i = 0; i < 6; i++)\r\nif (read_cmd_byte(ioaddr, PAR0 + i) != atp_timed_dev->dev_addr[i])\r\n{\r\nstruct net_local *lp = netdev_priv(atp_timed_dev);\r\nwrite_reg_byte(ioaddr, PAR0 + i, atp_timed_dev->dev_addr[i]);\r\nif (i == 2)\r\ndev->stats.tx_errors++;\r\nelse if (i == 3)\r\ndev->stats.tx_dropped++;\r\nelse if (i == 4)\r\ndev->stats.collisions++;\r\nelse\r\ndev->stats.rx_errors++;\r\n}\r\n#endif\r\n}\r\nspin_unlock(&lp->lock);\r\nlp->timer.expires = jiffies + TIMED_CHECKER;\r\nadd_timer(&lp->timer);\r\n}\r\nstatic void net_rx(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nlong ioaddr = dev->base_addr;\r\nstruct rx_header rx_head;\r\noutb(EOC+MAR, ioaddr + PAR_DATA);\r\nread_block(ioaddr, 8, (unsigned char*)&rx_head, dev->if_port);\r\nif (net_debug > 5)\r\nprintk(KERN_DEBUG " rx_count %04x %04x %04x %04x..", rx_head.pad,\r\nrx_head.rx_count, rx_head.rx_status, rx_head.cur_addr);\r\nif ((rx_head.rx_status & 0x77) != 0x01) {\r\ndev->stats.rx_errors++;\r\nif (rx_head.rx_status & 0x0004) dev->stats.rx_frame_errors++;\r\nelse if (rx_head.rx_status & 0x0002) dev->stats.rx_crc_errors++;\r\nif (net_debug > 3)\r\nprintk(KERN_DEBUG "%s: Unknown ATP Rx error %04x.\n",\r\ndev->name, rx_head.rx_status);\r\nif (rx_head.rx_status & 0x0020) {\r\ndev->stats.rx_fifo_errors++;\r\nwrite_reg_high(ioaddr, CMR1, CMR1h_TxENABLE);\r\nwrite_reg_high(ioaddr, CMR1, CMR1h_RxENABLE | CMR1h_TxENABLE);\r\n} else if (rx_head.rx_status & 0x0050)\r\nhardware_init(dev);\r\nreturn;\r\n} else {\r\nint pkt_len = (rx_head.rx_count & 0x7ff) - 4;\r\nstruct sk_buff *skb;\r\nskb = dev_alloc_skb(pkt_len + 2);\r\nif (skb == NULL) {\r\nprintk(KERN_ERR "%s: Memory squeeze, dropping packet.\n",\r\ndev->name);\r\ndev->stats.rx_dropped++;\r\ngoto done;\r\n}\r\nskb_reserve(skb, 2);\r\nread_block(ioaddr, pkt_len, skb_put(skb,pkt_len), dev->if_port);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->last_rx = jiffies;\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += pkt_len;\r\n}\r\ndone:\r\nwrite_reg(ioaddr, CMR1, CMR1_NextPkt);\r\nlp->last_rx_time = jiffies;\r\n}\r\nstatic void read_block(long ioaddr, int length, unsigned char *p, int data_mode)\r\n{\r\nif (data_mode <= 3) {\r\noutb(Ctrl_LNibRead, ioaddr + PAR_CONTROL);\r\noutb(length == 8 ? RdAddr | HNib | MAR : RdAddr | MAR,\r\nioaddr + PAR_DATA);\r\nif (data_mode <= 1) {\r\ndo { *p++ = read_byte_mode0(ioaddr); } while (--length > 0);\r\n} else {\r\ndo { *p++ = read_byte_mode2(ioaddr); } while (--length > 0);\r\n}\r\n} else if (data_mode <= 5) {\r\ndo { *p++ = read_byte_mode4(ioaddr); } while (--length > 0);\r\n} else {\r\ndo { *p++ = read_byte_mode6(ioaddr); } while (--length > 0);\r\n}\r\noutb(EOC+HNib+MAR, ioaddr + PAR_DATA);\r\noutb(Ctrl_SelData, ioaddr + PAR_CONTROL);\r\n}\r\nstatic int\r\nnet_close(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nlong ioaddr = dev->base_addr;\r\nnetif_stop_queue(dev);\r\ndel_timer_sync(&lp->timer);\r\nlp->addr_mode = CMR2h_OFF;\r\nwrite_reg_high(ioaddr, CMR2, CMR2h_OFF);\r\noutb(0x00, ioaddr + PAR_CONTROL);\r\nfree_irq(dev->irq, dev);\r\nwrite_reg_high(ioaddr, CMR1, CMR1h_RESET | CMR1h_MUX);\r\nreturn 0;\r\n}\r\nstatic void set_rx_mode_8002(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nlong ioaddr = dev->base_addr;\r\nif (!netdev_mc_empty(dev) || (dev->flags & (IFF_ALLMULTI|IFF_PROMISC)))\r\nlp->addr_mode = CMR2h_PROMISC;\r\nelse\r\nlp->addr_mode = CMR2h_Normal;\r\nwrite_reg_high(ioaddr, CMR2, lp->addr_mode);\r\n}\r\nstatic void set_rx_mode_8012(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nlong ioaddr = dev->base_addr;\r\nunsigned char new_mode, mc_filter[8];\r\nint i;\r\nif (dev->flags & IFF_PROMISC) {\r\nnew_mode = CMR2h_PROMISC;\r\n} else if ((netdev_mc_count(dev) > 1000) ||\r\n(dev->flags & IFF_ALLMULTI)) {\r\nmemset(mc_filter, 0xff, sizeof(mc_filter));\r\nnew_mode = CMR2h_Normal;\r\n} else {\r\nstruct netdev_hw_addr *ha;\r\nmemset(mc_filter, 0, sizeof(mc_filter));\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nint filterbit = ether_crc_le(ETH_ALEN, ha->addr) & 0x3f;\r\nmc_filter[filterbit >> 5] |= 1 << (filterbit & 31);\r\n}\r\nnew_mode = CMR2h_Normal;\r\n}\r\nlp->addr_mode = new_mode;\r\nwrite_reg(ioaddr, CMR2, CMR2_IRQOUT | 0x04);\r\nfor (i = 0; i < 8; i++)\r\nwrite_reg_byte(ioaddr, i, mc_filter[i]);\r\nif (net_debug > 2 || 1) {\r\nlp->addr_mode = 1;\r\nprintk(KERN_DEBUG "%s: Mode %d, setting multicast filter to",\r\ndev->name, lp->addr_mode);\r\nfor (i = 0; i < 8; i++)\r\nprintk(" %2.2x", mc_filter[i]);\r\nprintk(".\n");\r\n}\r\nwrite_reg_high(ioaddr, CMR2, lp->addr_mode);\r\nwrite_reg(ioaddr, CMR2, CMR2_IRQOUT);\r\n}\r\nstatic void set_rx_mode(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nif (lp->chip_type == RTL8002)\r\nreturn set_rx_mode_8002(dev);\r\nelse\r\nreturn set_rx_mode_8012(dev);\r\n}\r\nstatic int __init atp_init_module(void) {\r\nif (debug)\r\nprintk(KERN_INFO "%s", version);\r\nreturn atp_init();\r\n}\r\nstatic void __exit atp_cleanup_module(void) {\r\nstruct net_device *next_dev;\r\nwhile (root_atp_dev) {\r\nstruct net_local *atp_local = netdev_priv(root_atp_dev);\r\nnext_dev = atp_local->next_module;\r\nunregister_netdev(root_atp_dev);\r\nfree_netdev(root_atp_dev);\r\nroot_atp_dev = next_dev;\r\n}\r\n}
