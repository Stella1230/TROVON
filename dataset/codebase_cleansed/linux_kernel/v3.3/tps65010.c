static void dbg_chgstat(char *buf, size_t len, u8 chgstatus)\r\n{\r\nsnprintf(buf, len, "%02x%s%s%s%s%s%s%s%s\n",\r\nchgstatus,\r\n(chgstatus & TPS_CHG_USB) ? " USB" : "",\r\n(chgstatus & TPS_CHG_AC) ? " AC" : "",\r\n(chgstatus & TPS_CHG_THERM) ? " therm" : "",\r\n(chgstatus & TPS_CHG_TERM) ? " done" :\r\n((chgstatus & (TPS_CHG_USB|TPS_CHG_AC))\r\n? " (charging)" : ""),\r\n(chgstatus & TPS_CHG_TAPER_TMO) ? " taper_tmo" : "",\r\n(chgstatus & TPS_CHG_CHG_TMO) ? " charge_tmo" : "",\r\n(chgstatus & TPS_CHG_PRECHG_TMO) ? " prechg_tmo" : "",\r\n(chgstatus & TPS_CHG_TEMP_ERR) ? " temp_err" : "");\r\n}\r\nstatic void dbg_regstat(char *buf, size_t len, u8 regstatus)\r\n{\r\nsnprintf(buf, len, "%02x %s%s%s%s%s%s%s%s\n",\r\nregstatus,\r\n(regstatus & TPS_REG_ONOFF) ? "off" : "(on)",\r\n(regstatus & TPS_REG_COVER) ? " uncover" : "",\r\n(regstatus & TPS_REG_UVLO) ? " UVLO" : "",\r\n(regstatus & TPS_REG_NO_CHG) ? " NO_CHG" : "",\r\n(regstatus & TPS_REG_PG_LD02) ? " ld02_bad" : "",\r\n(regstatus & TPS_REG_PG_LD01) ? " ld01_bad" : "",\r\n(regstatus & TPS_REG_PG_MAIN) ? " main_bad" : "",\r\n(regstatus & TPS_REG_PG_CORE) ? " core_bad" : "");\r\n}\r\nstatic void dbg_chgconf(int por, char *buf, size_t len, u8 chgconfig)\r\n{\r\nconst char *hibit;\r\nif (por)\r\nhibit = (chgconfig & TPS_CHARGE_POR)\r\n? "POR=69ms" : "POR=1sec";\r\nelse\r\nhibit = (chgconfig & TPS65013_AUA) ? "AUA" : "";\r\nsnprintf(buf, len, "%02x %s%s%s AC=%d%% USB=%dmA %sCharge\n",\r\nchgconfig, hibit,\r\n(chgconfig & TPS_CHARGE_RESET) ? " reset" : "",\r\n(chgconfig & TPS_CHARGE_FAST) ? " fast" : "",\r\n({int p; switch ((chgconfig >> 3) & 3) {\r\ncase 3: p = 100; break;\r\ncase 2: p = 75; break;\r\ncase 1: p = 50; break;\r\ndefault: p = 25; break;\r\n}; p; }),\r\n(chgconfig & TPS_VBUS_CHARGING)\r\n? ((chgconfig & TPS_VBUS_500MA) ? 500 : 100)\r\n: 0,\r\n(chgconfig & TPS_CHARGE_ENABLE) ? "" : "No");\r\n}\r\nstatic void show_chgstatus(const char *label, u8 chgstatus)\r\n{\r\nchar buf [100];\r\ndbg_chgstat(buf, sizeof buf, chgstatus);\r\npr_debug("%s: %s %s", DRIVER_NAME, label, buf);\r\n}\r\nstatic void show_regstatus(const char *label, u8 regstatus)\r\n{\r\nchar buf [100];\r\ndbg_regstat(buf, sizeof buf, regstatus);\r\npr_debug("%s: %s %s", DRIVER_NAME, label, buf);\r\n}\r\nstatic void show_chgconfig(int por, const char *label, u8 chgconfig)\r\n{\r\nchar buf [100];\r\ndbg_chgconf(por, buf, sizeof buf, chgconfig);\r\npr_debug("%s: %s %s", DRIVER_NAME, label, buf);\r\n}\r\nstatic inline void show_chgstatus(const char *label, u8 chgstatus) { }\r\nstatic inline void show_regstatus(const char *label, u8 chgstatus) { }\r\nstatic inline void show_chgconfig(int por, const char *label, u8 chgconfig) { }\r\nstatic int dbg_show(struct seq_file *s, void *_)\r\n{\r\nstruct tps65010 *tps = s->private;\r\nu8 value, v2;\r\nunsigned i;\r\nchar buf[100];\r\nconst char *chip;\r\nswitch (tps->model) {\r\ncase TPS65010: chip = "tps65010"; break;\r\ncase TPS65011: chip = "tps65011"; break;\r\ncase TPS65012: chip = "tps65012"; break;\r\ncase TPS65013: chip = "tps65013"; break;\r\ndefault: chip = NULL; break;\r\n}\r\nseq_printf(s, "driver %s\nversion %s\nchip %s\n\n",\r\nDRIVER_NAME, DRIVER_VERSION, chip);\r\nmutex_lock(&tps->lock);\r\nseq_printf(s, "%scharging\n\n", tps->charging ? "" : "(not) ");\r\nvalue = i2c_smbus_read_byte_data(tps->client, TPS_CHGCONFIG);\r\ndbg_chgconf(tps->por, buf, sizeof buf, value);\r\nseq_printf(s, "chgconfig %s", buf);\r\nvalue = i2c_smbus_read_byte_data(tps->client, TPS_CHGSTATUS);\r\ndbg_chgstat(buf, sizeof buf, value);\r\nseq_printf(s, "chgstat %s", buf);\r\nvalue = i2c_smbus_read_byte_data(tps->client, TPS_MASK1);\r\ndbg_chgstat(buf, sizeof buf, value);\r\nseq_printf(s, "mask1 %s", buf);\r\nvalue = i2c_smbus_read_byte_data(tps->client, TPS_REGSTATUS);\r\ndbg_regstat(buf, sizeof buf, value);\r\nseq_printf(s, "regstat %s", buf);\r\nvalue = i2c_smbus_read_byte_data(tps->client, TPS_MASK2);\r\ndbg_regstat(buf, sizeof buf, value);\r\nseq_printf(s, "mask2 %s\n", buf);\r\nschedule_delayed_work(&tps->work, POWER_POLL_DELAY);\r\nvalue = i2c_smbus_read_byte_data(tps->client, TPS_VDCDC1);\r\nseq_printf(s, "vdcdc1 %02x\n", value);\r\nvalue = i2c_smbus_read_byte_data(tps->client, TPS_VDCDC2);\r\nseq_printf(s, "vdcdc2 %02x\n", value);\r\nvalue = i2c_smbus_read_byte_data(tps->client, TPS_VREGS1);\r\nseq_printf(s, "vregs1 %02x\n\n", value);\r\nvalue = i2c_smbus_read_byte_data(tps->client, TPS_LED1_ON);\r\nv2 = i2c_smbus_read_byte_data(tps->client, TPS_LED1_PER);\r\nseq_printf(s, "led1 %s, on=%02x, per=%02x, %d/%d msec\n",\r\n(value & 0x80)\r\n? ((v2 & 0x80) ? "on" : "off")\r\n: ((v2 & 0x80) ? "blink" : "(nPG)"),\r\nvalue, v2,\r\n(value & 0x7f) * 10, (v2 & 0x7f) * 100);\r\nvalue = i2c_smbus_read_byte_data(tps->client, TPS_LED2_ON);\r\nv2 = i2c_smbus_read_byte_data(tps->client, TPS_LED2_PER);\r\nseq_printf(s, "led2 %s, on=%02x, per=%02x, %d/%d msec\n",\r\n(value & 0x80)\r\n? ((v2 & 0x80) ? "on" : "off")\r\n: ((v2 & 0x80) ? "blink" : "off"),\r\nvalue, v2,\r\n(value & 0x7f) * 10, (v2 & 0x7f) * 100);\r\nvalue = i2c_smbus_read_byte_data(tps->client, TPS_DEFGPIO);\r\nv2 = i2c_smbus_read_byte_data(tps->client, TPS_MASK3);\r\nseq_printf(s, "defgpio %02x mask3 %02x\n", value, v2);\r\nfor (i = 0; i < 4; i++) {\r\nif (value & (1 << (4 + i)))\r\nseq_printf(s, " gpio%d-out %s\n", i + 1,\r\n(value & (1 << i)) ? "low" : "hi ");\r\nelse\r\nseq_printf(s, " gpio%d-in %s %s %s\n", i + 1,\r\n(value & (1 << i)) ? "hi " : "low",\r\n(v2 & (1 << i)) ? "no-irq" : "irq",\r\n(v2 & (1 << (4 + i))) ? "rising" : "falling");\r\n}\r\nmutex_unlock(&tps->lock);\r\nreturn 0;\r\n}\r\nstatic int dbg_tps_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, dbg_show, inode->i_private);\r\n}\r\nstatic void tps65010_interrupt(struct tps65010 *tps)\r\n{\r\nu8 tmp = 0, mask, poll;\r\npoll = 0;\r\nif (tps->nmask2) {\r\ntmp = i2c_smbus_read_byte_data(tps->client, TPS_REGSTATUS);\r\nmask = tmp ^ tps->regstatus;\r\ntps->regstatus = tmp;\r\nmask &= tps->nmask2;\r\n} else\r\nmask = 0;\r\nif (mask) {\r\ntps->regstatus = tmp;\r\nif (tmp & TPS_REG_ONOFF) {\r\npr_info("%s: power off button\n", DRIVER_NAME);\r\n#if 0\r\nhibernate();\r\n#endif\r\npoll = 1;\r\n}\r\n}\r\nif (tps->nmask1) {\r\ntmp = i2c_smbus_read_byte_data(tps->client, TPS_CHGSTATUS);\r\nmask = tmp ^ tps->chgstatus;\r\ntps->chgstatus = tmp;\r\nmask &= tps->nmask1;\r\n} else\r\nmask = 0;\r\nif (mask) {\r\nunsigned charging = 0;\r\nshow_chgstatus("chg/irq", tmp);\r\nif (tmp & (TPS_CHG_USB|TPS_CHG_AC))\r\nshow_chgconfig(tps->por, "conf", tps->chgconf);\r\nif (!(tps->chgstatus & ~(TPS_CHG_USB|TPS_CHG_AC))\r\n&& (tps->chgstatus & (TPS_CHG_USB|TPS_CHG_AC))\r\n&& (tps->chgconf & TPS_CHARGE_ENABLE)\r\n) {\r\nif (tps->chgstatus & TPS_CHG_USB) {\r\nif (mask & TPS_CHG_USB)\r\nset_bit(FLAG_VBUS_CHANGED, &tps->flags);\r\ncharging = 1;\r\n} else if (tps->chgstatus & TPS_CHG_AC)\r\ncharging = 1;\r\n}\r\nif (charging != tps->charging) {\r\ntps->charging = charging;\r\npr_info("%s: battery %scharging\n",\r\nDRIVER_NAME, charging ? "" :\r\n((tps->chgstatus & (TPS_CHG_USB|TPS_CHG_AC))\r\n? "NOT " : "dis"));\r\n}\r\n}\r\nif ((tps->model != TPS65013 || !tps->charging)\r\n&& (tps->chgstatus & (TPS_CHG_USB|TPS_CHG_AC)))\r\npoll = 1;\r\nif (poll)\r\nschedule_delayed_work(&tps->work, POWER_POLL_DELAY);\r\n}\r\nstatic void tps65010_work(struct work_struct *work)\r\n{\r\nstruct tps65010 *tps;\r\ntps = container_of(to_delayed_work(work), struct tps65010, work);\r\nmutex_lock(&tps->lock);\r\ntps65010_interrupt(tps);\r\nif (test_and_clear_bit(FLAG_VBUS_CHANGED, &tps->flags)) {\r\nint status;\r\nu8 chgconfig, tmp;\r\nchgconfig = i2c_smbus_read_byte_data(tps->client,\r\nTPS_CHGCONFIG);\r\nchgconfig &= ~(TPS_VBUS_500MA | TPS_VBUS_CHARGING);\r\nif (tps->vbus == 500)\r\nchgconfig |= TPS_VBUS_500MA | TPS_VBUS_CHARGING;\r\nelse if (tps->vbus >= 100)\r\nchgconfig |= TPS_VBUS_CHARGING;\r\nstatus = i2c_smbus_write_byte_data(tps->client,\r\nTPS_CHGCONFIG, chgconfig);\r\ntmp = i2c_smbus_read_byte_data(tps->client, TPS_CHGCONFIG);\r\ntps->chgconf = tmp;\r\nshow_chgconfig(tps->por, "update vbus", tmp);\r\n}\r\nif (test_and_clear_bit(FLAG_IRQ_ENABLE, &tps->flags))\r\nenable_irq(tps->client->irq);\r\nmutex_unlock(&tps->lock);\r\n}\r\nstatic irqreturn_t tps65010_irq(int irq, void *_tps)\r\n{\r\nstruct tps65010 *tps = _tps;\r\ndisable_irq_nosync(irq);\r\nset_bit(FLAG_IRQ_ENABLE, &tps->flags);\r\nschedule_delayed_work(&tps->work, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\ntps65010_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nif (offset < 4)\r\ntps65010_set_gpio_out_value(offset + 1, value);\r\nelse if (offset < 6)\r\ntps65010_set_led(offset - 3, value ? ON : OFF);\r\nelse\r\ntps65010_set_vib(value);\r\n}\r\nstatic int\r\ntps65010_output(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nif (offset < 4) {\r\nstruct tps65010 *tps;\r\ntps = container_of(chip, struct tps65010, chip);\r\nif (!(tps->outmask & (1 << offset)))\r\nreturn -EINVAL;\r\ntps65010_set_gpio_out_value(offset + 1, value);\r\n} else if (offset < 6)\r\ntps65010_set_led(offset - 3, value ? ON : OFF);\r\nelse\r\ntps65010_set_vib(value);\r\nreturn 0;\r\n}\r\nstatic int tps65010_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nint value;\r\nstruct tps65010 *tps;\r\ntps = container_of(chip, struct tps65010, chip);\r\nif (offset < 4) {\r\nvalue = i2c_smbus_read_byte_data(tps->client, TPS_DEFGPIO);\r\nif (value < 0)\r\nreturn 0;\r\nif (value & (1 << (offset + 4)))\r\nreturn !(value & (1 << offset));\r\nelse\r\nreturn (value & (1 << offset));\r\n}\r\nreturn 0;\r\n}\r\nstatic int __exit tps65010_remove(struct i2c_client *client)\r\n{\r\nstruct tps65010 *tps = i2c_get_clientdata(client);\r\nstruct tps65010_board *board = client->dev.platform_data;\r\nif (board && board->teardown) {\r\nint status = board->teardown(client, board->context);\r\nif (status < 0)\r\ndev_dbg(&client->dev, "board %s %s err %d\n",\r\n"teardown", client->name, status);\r\n}\r\nif (client->irq > 0)\r\nfree_irq(client->irq, tps);\r\ncancel_delayed_work_sync(&tps->work);\r\ndebugfs_remove(tps->file);\r\nkfree(tps);\r\nthe_tps = NULL;\r\nreturn 0;\r\n}\r\nstatic int tps65010_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct tps65010 *tps;\r\nint status;\r\nstruct tps65010_board *board = client->dev.platform_data;\r\nif (the_tps) {\r\ndev_dbg(&client->dev, "only one tps6501x chip allowed\n");\r\nreturn -ENODEV;\r\n}\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EINVAL;\r\ntps = kzalloc(sizeof *tps, GFP_KERNEL);\r\nif (!tps)\r\nreturn -ENOMEM;\r\nmutex_init(&tps->lock);\r\nINIT_DELAYED_WORK(&tps->work, tps65010_work);\r\ntps->client = client;\r\ntps->model = id->driver_data;\r\nif (client->irq > 0) {\r\nstatus = request_irq(client->irq, tps65010_irq,\r\nIRQF_SAMPLE_RANDOM | IRQF_TRIGGER_FALLING,\r\nDRIVER_NAME, tps);\r\nif (status < 0) {\r\ndev_dbg(&client->dev, "can't get IRQ %d, err %d\n",\r\nclient->irq, status);\r\ngoto fail1;\r\n}\r\ndisable_irq(client->irq);\r\nset_bit(FLAG_IRQ_ENABLE, &tps->flags);\r\n} else\r\ndev_warn(&client->dev, "IRQ not configured!\n");\r\nswitch (tps->model) {\r\ncase TPS65010:\r\ncase TPS65012:\r\ntps->por = 1;\r\nbreak;\r\n}\r\ntps->chgconf = i2c_smbus_read_byte_data(client, TPS_CHGCONFIG);\r\nshow_chgconfig(tps->por, "conf/init", tps->chgconf);\r\nshow_chgstatus("chg/init",\r\ni2c_smbus_read_byte_data(client, TPS_CHGSTATUS));\r\nshow_regstatus("reg/init",\r\ni2c_smbus_read_byte_data(client, TPS_REGSTATUS));\r\npr_debug("%s: vdcdc1 0x%02x, vdcdc2 %02x, vregs1 %02x\n", DRIVER_NAME,\r\ni2c_smbus_read_byte_data(client, TPS_VDCDC1),\r\ni2c_smbus_read_byte_data(client, TPS_VDCDC2),\r\ni2c_smbus_read_byte_data(client, TPS_VREGS1));\r\npr_debug("%s: defgpio 0x%02x, mask3 0x%02x\n", DRIVER_NAME,\r\ni2c_smbus_read_byte_data(client, TPS_DEFGPIO),\r\ni2c_smbus_read_byte_data(client, TPS_MASK3));\r\ni2c_set_clientdata(client, tps);\r\nthe_tps = tps;\r\n#if defined(CONFIG_USB_GADGET) && !defined(CONFIG_USB_OTG)\r\ntps->vbus = 100;\r\n#endif\r\ntps->nmask1 = ~0;\r\n(void) i2c_smbus_write_byte_data(client, TPS_MASK1, ~tps->nmask1);\r\ntps->nmask2 = TPS_REG_ONOFF;\r\nif (tps->model == TPS65013)\r\ntps->nmask2 |= TPS_REG_NO_CHG;\r\n(void) i2c_smbus_write_byte_data(client, TPS_MASK2, ~tps->nmask2);\r\n(void) i2c_smbus_write_byte_data(client, TPS_MASK3, 0x0f\r\n| i2c_smbus_read_byte_data(client, TPS_MASK3));\r\ntps65010_work(&tps->work.work);\r\ntps->file = debugfs_create_file(DRIVER_NAME, S_IRUGO, NULL,\r\ntps, DEBUG_FOPS);\r\nif (board && board->base != 0) {\r\ntps->outmask = board->outmask;\r\ntps->chip.label = client->name;\r\ntps->chip.dev = &client->dev;\r\ntps->chip.owner = THIS_MODULE;\r\ntps->chip.set = tps65010_gpio_set;\r\ntps->chip.direction_output = tps65010_output;\r\ntps->chip.get = tps65010_gpio_get;\r\ntps->chip.base = board->base;\r\ntps->chip.ngpio = 7;\r\ntps->chip.can_sleep = 1;\r\nstatus = gpiochip_add(&tps->chip);\r\nif (status < 0)\r\ndev_err(&client->dev, "can't add gpiochip, err %d\n",\r\nstatus);\r\nelse if (board->setup) {\r\nstatus = board->setup(client, board->context);\r\nif (status < 0) {\r\ndev_dbg(&client->dev,\r\n"board %s %s err %d\n",\r\n"setup", client->name, status);\r\nstatus = 0;\r\n}\r\n}\r\n}\r\nreturn 0;\r\nfail1:\r\nkfree(tps);\r\nreturn status;\r\n}\r\nint tps65010_set_vbus_draw(unsigned mA)\r\n{\r\nunsigned long flags;\r\nif (!the_tps)\r\nreturn -ENODEV;\r\nlocal_irq_save(flags);\r\nif (mA >= 500)\r\nmA = 500;\r\nelse if (mA >= 100)\r\nmA = 100;\r\nelse\r\nmA = 0;\r\nthe_tps->vbus = mA;\r\nif ((the_tps->chgstatus & TPS_CHG_USB)\r\n&& test_and_set_bit(\r\nFLAG_VBUS_CHANGED, &the_tps->flags)) {\r\nschedule_delayed_work(&the_tps->work, 0);\r\n}\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nint tps65010_set_gpio_out_value(unsigned gpio, unsigned value)\r\n{\r\nint status;\r\nunsigned defgpio;\r\nif (!the_tps)\r\nreturn -ENODEV;\r\nif ((gpio < GPIO1) || (gpio > GPIO4))\r\nreturn -EINVAL;\r\nmutex_lock(&the_tps->lock);\r\ndefgpio = i2c_smbus_read_byte_data(the_tps->client, TPS_DEFGPIO);\r\ndefgpio |= 1 << (gpio + 3);\r\nswitch (value) {\r\ncase LOW:\r\ndefgpio |= 1 << (gpio - 1);\r\nbreak;\r\ndefault:\r\ndefgpio &= ~(1 << (gpio - 1));\r\nbreak;\r\n}\r\nstatus = i2c_smbus_write_byte_data(the_tps->client,\r\nTPS_DEFGPIO, defgpio);\r\npr_debug("%s: gpio%dout = %s, defgpio 0x%02x\n", DRIVER_NAME,\r\ngpio, value ? "high" : "low",\r\ni2c_smbus_read_byte_data(the_tps->client, TPS_DEFGPIO));\r\nmutex_unlock(&the_tps->lock);\r\nreturn status;\r\n}\r\nint tps65010_set_led(unsigned led, unsigned mode)\r\n{\r\nint status;\r\nunsigned led_on, led_per, offs;\r\nif (!the_tps)\r\nreturn -ENODEV;\r\nif (led == LED1)\r\noffs = 0;\r\nelse {\r\noffs = 2;\r\nled = LED2;\r\n}\r\nmutex_lock(&the_tps->lock);\r\npr_debug("%s: led%i_on 0x%02x\n", DRIVER_NAME, led,\r\ni2c_smbus_read_byte_data(the_tps->client,\r\nTPS_LED1_ON + offs));\r\npr_debug("%s: led%i_per 0x%02x\n", DRIVER_NAME, led,\r\ni2c_smbus_read_byte_data(the_tps->client,\r\nTPS_LED1_PER + offs));\r\nswitch (mode) {\r\ncase OFF:\r\nled_on = 1 << 7;\r\nled_per = 0 << 7;\r\nbreak;\r\ncase ON:\r\nled_on = 1 << 7;\r\nled_per = 1 << 7;\r\nbreak;\r\ncase BLINK:\r\nled_on = 0x30 | (0 << 7);\r\nled_per = 0x08 | (1 << 7);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s: Wrong mode parameter for set_led()\n",\r\nDRIVER_NAME);\r\nmutex_unlock(&the_tps->lock);\r\nreturn -EINVAL;\r\n}\r\nstatus = i2c_smbus_write_byte_data(the_tps->client,\r\nTPS_LED1_ON + offs, led_on);\r\nif (status != 0) {\r\nprintk(KERN_ERR "%s: Failed to write led%i_on register\n",\r\nDRIVER_NAME, led);\r\nmutex_unlock(&the_tps->lock);\r\nreturn status;\r\n}\r\npr_debug("%s: led%i_on 0x%02x\n", DRIVER_NAME, led,\r\ni2c_smbus_read_byte_data(the_tps->client, TPS_LED1_ON + offs));\r\nstatus = i2c_smbus_write_byte_data(the_tps->client,\r\nTPS_LED1_PER + offs, led_per);\r\nif (status != 0) {\r\nprintk(KERN_ERR "%s: Failed to write led%i_per register\n",\r\nDRIVER_NAME, led);\r\nmutex_unlock(&the_tps->lock);\r\nreturn status;\r\n}\r\npr_debug("%s: led%i_per 0x%02x\n", DRIVER_NAME, led,\r\ni2c_smbus_read_byte_data(the_tps->client,\r\nTPS_LED1_PER + offs));\r\nmutex_unlock(&the_tps->lock);\r\nreturn status;\r\n}\r\nint tps65010_set_vib(unsigned value)\r\n{\r\nint status;\r\nunsigned vdcdc2;\r\nif (!the_tps)\r\nreturn -ENODEV;\r\nmutex_lock(&the_tps->lock);\r\nvdcdc2 = i2c_smbus_read_byte_data(the_tps->client, TPS_VDCDC2);\r\nvdcdc2 &= ~(1 << 1);\r\nif (value)\r\nvdcdc2 |= (1 << 1);\r\nstatus = i2c_smbus_write_byte_data(the_tps->client,\r\nTPS_VDCDC2, vdcdc2);\r\npr_debug("%s: vibrator %s\n", DRIVER_NAME, value ? "on" : "off");\r\nmutex_unlock(&the_tps->lock);\r\nreturn status;\r\n}\r\nint tps65010_set_low_pwr(unsigned mode)\r\n{\r\nint status;\r\nunsigned vdcdc1;\r\nif (!the_tps)\r\nreturn -ENODEV;\r\nmutex_lock(&the_tps->lock);\r\npr_debug("%s: %s low_pwr, vdcdc1 0x%02x\n", DRIVER_NAME,\r\nmode ? "enable" : "disable",\r\ni2c_smbus_read_byte_data(the_tps->client, TPS_VDCDC1));\r\nvdcdc1 = i2c_smbus_read_byte_data(the_tps->client, TPS_VDCDC1);\r\nswitch (mode) {\r\ncase OFF:\r\nvdcdc1 &= ~TPS_ENABLE_LP;\r\nbreak;\r\ndefault:\r\nvdcdc1 |= TPS_ENABLE_LP;\r\nbreak;\r\n}\r\nstatus = i2c_smbus_write_byte_data(the_tps->client,\r\nTPS_VDCDC1, vdcdc1);\r\nif (status != 0)\r\nprintk(KERN_ERR "%s: Failed to write vdcdc1 register\n",\r\nDRIVER_NAME);\r\nelse\r\npr_debug("%s: vdcdc1 0x%02x\n", DRIVER_NAME,\r\ni2c_smbus_read_byte_data(the_tps->client, TPS_VDCDC1));\r\nmutex_unlock(&the_tps->lock);\r\nreturn status;\r\n}\r\nint tps65010_config_vregs1(unsigned value)\r\n{\r\nint status;\r\nif (!the_tps)\r\nreturn -ENODEV;\r\nmutex_lock(&the_tps->lock);\r\npr_debug("%s: vregs1 0x%02x\n", DRIVER_NAME,\r\ni2c_smbus_read_byte_data(the_tps->client, TPS_VREGS1));\r\nstatus = i2c_smbus_write_byte_data(the_tps->client,\r\nTPS_VREGS1, value);\r\nif (status != 0)\r\nprintk(KERN_ERR "%s: Failed to write vregs1 register\n",\r\nDRIVER_NAME);\r\nelse\r\npr_debug("%s: vregs1 0x%02x\n", DRIVER_NAME,\r\ni2c_smbus_read_byte_data(the_tps->client, TPS_VREGS1));\r\nmutex_unlock(&the_tps->lock);\r\nreturn status;\r\n}\r\nint tps65010_config_vdcdc2(unsigned value)\r\n{\r\nstruct i2c_client *c;\r\nint status;\r\nif (!the_tps)\r\nreturn -ENODEV;\r\nc = the_tps->client;\r\nmutex_lock(&the_tps->lock);\r\npr_debug("%s: vdcdc2 0x%02x\n", DRIVER_NAME,\r\ni2c_smbus_read_byte_data(c, TPS_VDCDC2));\r\nstatus = i2c_smbus_write_byte_data(c, TPS_VDCDC2, value);\r\nif (status != 0)\r\nprintk(KERN_ERR "%s: Failed to write vdcdc2 register\n",\r\nDRIVER_NAME);\r\nelse\r\npr_debug("%s: vregs1 0x%02x\n", DRIVER_NAME,\r\ni2c_smbus_read_byte_data(c, TPS_VDCDC2));\r\nmutex_unlock(&the_tps->lock);\r\nreturn status;\r\n}\r\nint tps65013_set_low_pwr(unsigned mode)\r\n{\r\nint status;\r\nunsigned vdcdc1, chgconfig;\r\nif (!the_tps || the_tps->por)\r\nreturn -ENODEV;\r\nmutex_lock(&the_tps->lock);\r\npr_debug("%s: %s low_pwr, chgconfig 0x%02x vdcdc1 0x%02x\n",\r\nDRIVER_NAME,\r\nmode ? "enable" : "disable",\r\ni2c_smbus_read_byte_data(the_tps->client, TPS_CHGCONFIG),\r\ni2c_smbus_read_byte_data(the_tps->client, TPS_VDCDC1));\r\nchgconfig = i2c_smbus_read_byte_data(the_tps->client, TPS_CHGCONFIG);\r\nvdcdc1 = i2c_smbus_read_byte_data(the_tps->client, TPS_VDCDC1);\r\nswitch (mode) {\r\ncase OFF:\r\nchgconfig &= ~TPS65013_AUA;\r\nvdcdc1 &= ~TPS_ENABLE_LP;\r\nbreak;\r\ndefault:\r\nchgconfig |= TPS65013_AUA;\r\nvdcdc1 |= TPS_ENABLE_LP;\r\nbreak;\r\n}\r\nstatus = i2c_smbus_write_byte_data(the_tps->client,\r\nTPS_CHGCONFIG, chgconfig);\r\nif (status != 0) {\r\nprintk(KERN_ERR "%s: Failed to write chconfig register\n",\r\nDRIVER_NAME);\r\nmutex_unlock(&the_tps->lock);\r\nreturn status;\r\n}\r\nchgconfig = i2c_smbus_read_byte_data(the_tps->client, TPS_CHGCONFIG);\r\nthe_tps->chgconf = chgconfig;\r\nshow_chgconfig(0, "chgconf", chgconfig);\r\nstatus = i2c_smbus_write_byte_data(the_tps->client,\r\nTPS_VDCDC1, vdcdc1);\r\nif (status != 0)\r\nprintk(KERN_ERR "%s: Failed to write vdcdc1 register\n",\r\nDRIVER_NAME);\r\nelse\r\npr_debug("%s: vdcdc1 0x%02x\n", DRIVER_NAME,\r\ni2c_smbus_read_byte_data(the_tps->client, TPS_VDCDC1));\r\nmutex_unlock(&the_tps->lock);\r\nreturn status;\r\n}\r\nstatic int __init tps_init(void)\r\n{\r\nu32 tries = 3;\r\nint status = -ENODEV;\r\nprintk(KERN_INFO "%s: version %s\n", DRIVER_NAME, DRIVER_VERSION);\r\nwhile (tries--) {\r\nstatus = i2c_add_driver(&tps65010_driver);\r\nif (the_tps)\r\nbreak;\r\ni2c_del_driver(&tps65010_driver);\r\nif (!tries) {\r\nprintk(KERN_ERR "%s: no chip?\n", DRIVER_NAME);\r\nreturn -ENODEV;\r\n}\r\npr_debug("%s: re-probe ...\n", DRIVER_NAME);\r\nmsleep(10);\r\n}\r\nreturn status;\r\n}\r\nstatic void __exit tps_exit(void)\r\n{\r\ni2c_del_driver(&tps65010_driver);\r\n}
