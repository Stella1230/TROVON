static int xhci_pci_reinit(struct xhci_hcd *xhci, struct pci_dev *pdev)\r\n{\r\nif (!pci_set_mwi(pdev))\r\nxhci_dbg(xhci, "MWI active\n");\r\nxhci_dbg(xhci, "Finished xhci_pci_reinit\n");\r\nreturn 0;\r\n}\r\nstatic void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nif (pdev->vendor == PCI_VENDOR_ID_FRESCO_LOGIC &&\r\npdev->device == PCI_DEVICE_ID_FRESCO_LOGIC_PDK) {\r\nif (pdev->revision == 0x0) {\r\nxhci->quirks |= XHCI_RESET_EP_QUIRK;\r\nxhci_dbg(xhci, "QUIRK: Fresco Logic xHC needs configure"\r\n" endpoint cmd after reset endpoint\n");\r\n}\r\nxhci->quirks |= XHCI_BROKEN_MSI;\r\nxhci_dbg(xhci, "QUIRK: Fresco Logic revision %u "\r\n"has broken MSI implementation\n",\r\npdev->revision);\r\n}\r\nif (pdev->vendor == PCI_VENDOR_ID_NEC)\r\nxhci->quirks |= XHCI_NEC_HOST;\r\nif (pdev->vendor == PCI_VENDOR_ID_AMD && xhci->hci_version == 0x96)\r\nxhci->quirks |= XHCI_AMD_0x96_HOST;\r\nif (pdev->vendor == PCI_VENDOR_ID_AMD && usb_amd_find_chipset_info())\r\nxhci->quirks |= XHCI_AMD_PLL_FIX;\r\nif (pdev->vendor == PCI_VENDOR_ID_INTEL &&\r\npdev->device == PCI_DEVICE_ID_INTEL_PANTHERPOINT_XHCI) {\r\nxhci->quirks |= XHCI_SPURIOUS_SUCCESS;\r\nxhci->quirks |= XHCI_EP_LIMIT_QUIRK;\r\nxhci->limit_active_eps = 64;\r\nxhci->quirks |= XHCI_SW_BW_CHECKING;\r\n}\r\nif (pdev->vendor == PCI_VENDOR_ID_ETRON &&\r\npdev->device == PCI_DEVICE_ID_ASROCK_P67) {\r\nxhci->quirks |= XHCI_RESET_ON_RESUME;\r\nxhci_dbg(xhci, "QUIRK: Resetting on resume\n");\r\n}\r\n}\r\nstatic int xhci_pci_setup(struct usb_hcd *hcd)\r\n{\r\nstruct xhci_hcd *xhci;\r\nstruct pci_dev *pdev = to_pci_dev(hcd->self.controller);\r\nint retval;\r\nretval = xhci_gen_setup(hcd, xhci_pci_quirks);\r\nif (retval)\r\nreturn retval;\r\nxhci = hcd_to_xhci(hcd);\r\nif (!usb_hcd_is_primary_hcd(hcd))\r\nreturn 0;\r\npci_read_config_byte(pdev, XHCI_SBRN_OFFSET, &xhci->sbrn);\r\nxhci_dbg(xhci, "Got SBRN %u\n", (unsigned int) xhci->sbrn);\r\nretval = xhci_pci_reinit(xhci, pdev);\r\nif (!retval)\r\nreturn retval;\r\nkfree(xhci);\r\nreturn retval;\r\n}\r\nstatic int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nint retval;\r\nstruct xhci_hcd *xhci;\r\nstruct hc_driver *driver;\r\nstruct usb_hcd *hcd;\r\ndriver = (struct hc_driver *)id->driver_data;\r\nretval = usb_hcd_pci_probe(dev, id);\r\nif (retval)\r\nreturn retval;\r\nhcd = dev_get_drvdata(&dev->dev);\r\nxhci = hcd_to_xhci(hcd);\r\nxhci->shared_hcd = usb_create_shared_hcd(driver, &dev->dev,\r\npci_name(dev), hcd);\r\nif (!xhci->shared_hcd) {\r\nretval = -ENOMEM;\r\ngoto dealloc_usb2_hcd;\r\n}\r\n*((struct xhci_hcd **) xhci->shared_hcd->hcd_priv) = xhci;\r\nretval = usb_add_hcd(xhci->shared_hcd, dev->irq,\r\nIRQF_SHARED);\r\nif (retval)\r\ngoto put_usb3_hcd;\r\nreturn 0;\r\nput_usb3_hcd:\r\nusb_put_hcd(xhci->shared_hcd);\r\ndealloc_usb2_hcd:\r\nusb_hcd_pci_remove(dev);\r\nreturn retval;\r\n}\r\nstatic void xhci_pci_remove(struct pci_dev *dev)\r\n{\r\nstruct xhci_hcd *xhci;\r\nxhci = hcd_to_xhci(pci_get_drvdata(dev));\r\nif (xhci->shared_hcd) {\r\nusb_remove_hcd(xhci->shared_hcd);\r\nusb_put_hcd(xhci->shared_hcd);\r\n}\r\nusb_hcd_pci_remove(dev);\r\nkfree(xhci);\r\n}\r\nstatic int xhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)\r\n{\r\nstruct xhci_hcd *xhci = hcd_to_xhci(hcd);\r\nint retval = 0;\r\nif (hcd->state != HC_STATE_SUSPENDED ||\r\nxhci->shared_hcd->state != HC_STATE_SUSPENDED)\r\nreturn -EINVAL;\r\nretval = xhci_suspend(xhci);\r\nreturn retval;\r\n}\r\nstatic int xhci_pci_resume(struct usb_hcd *hcd, bool hibernated)\r\n{\r\nstruct xhci_hcd *xhci = hcd_to_xhci(hcd);\r\nstruct pci_dev *pdev = to_pci_dev(hcd->self.controller);\r\nint retval = 0;\r\nif (usb_is_intel_switchable_xhci(pdev))\r\nusb_enable_xhci_ports(pdev);\r\nretval = xhci_resume(xhci, hibernated);\r\nreturn retval;\r\n}\r\nint __init xhci_register_pci(void)\r\n{\r\nreturn pci_register_driver(&xhci_pci_driver);\r\n}\r\nvoid __exit xhci_unregister_pci(void)\r\n{\r\npci_unregister_driver(&xhci_pci_driver);\r\n}
