static int snd_mixer_oss_open(struct inode *inode, struct file *file)\r\n{\r\nstruct snd_card *card;\r\nstruct snd_mixer_oss_file *fmixer;\r\nint err;\r\nerr = nonseekable_open(inode, file);\r\nif (err < 0)\r\nreturn err;\r\ncard = snd_lookup_oss_minor_data(iminor(inode),\r\nSNDRV_OSS_DEVICE_TYPE_MIXER);\r\nif (card == NULL)\r\nreturn -ENODEV;\r\nif (card->mixer_oss == NULL)\r\nreturn -ENODEV;\r\nerr = snd_card_file_add(card, file);\r\nif (err < 0)\r\nreturn err;\r\nfmixer = kzalloc(sizeof(*fmixer), GFP_KERNEL);\r\nif (fmixer == NULL) {\r\nsnd_card_file_remove(card, file);\r\nreturn -ENOMEM;\r\n}\r\nfmixer->card = card;\r\nfmixer->mixer = card->mixer_oss;\r\nfile->private_data = fmixer;\r\nif (!try_module_get(card->module)) {\r\nkfree(fmixer);\r\nsnd_card_file_remove(card, file);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_mixer_oss_release(struct inode *inode, struct file *file)\r\n{\r\nstruct snd_mixer_oss_file *fmixer;\r\nif (file->private_data) {\r\nfmixer = file->private_data;\r\nmodule_put(fmixer->card->module);\r\nsnd_card_file_remove(fmixer->card, file);\r\nkfree(fmixer);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_mixer_oss_info(struct snd_mixer_oss_file *fmixer,\r\nmixer_info __user *_info)\r\n{\r\nstruct snd_card *card = fmixer->card;\r\nstruct snd_mixer_oss *mixer = fmixer->mixer;\r\nstruct mixer_info info;\r\nmemset(&info, 0, sizeof(info));\r\nstrlcpy(info.id, mixer && mixer->id[0] ? mixer->id : card->driver, sizeof(info.id));\r\nstrlcpy(info.name, mixer && mixer->name[0] ? mixer->name : card->mixername, sizeof(info.name));\r\ninfo.modify_counter = card->mixer_oss_change_count;\r\nif (copy_to_user(_info, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int snd_mixer_oss_info_obsolete(struct snd_mixer_oss_file *fmixer,\r\n_old_mixer_info __user *_info)\r\n{\r\nstruct snd_card *card = fmixer->card;\r\nstruct snd_mixer_oss *mixer = fmixer->mixer;\r\n_old_mixer_info info;\r\nmemset(&info, 0, sizeof(info));\r\nstrlcpy(info.id, mixer && mixer->id[0] ? mixer->id : card->driver, sizeof(info.id));\r\nstrlcpy(info.name, mixer && mixer->name[0] ? mixer->name : card->mixername, sizeof(info.name));\r\nif (copy_to_user(_info, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int snd_mixer_oss_caps(struct snd_mixer_oss_file *fmixer)\r\n{\r\nstruct snd_mixer_oss *mixer = fmixer->mixer;\r\nint result = 0;\r\nif (mixer == NULL)\r\nreturn -EIO;\r\nif (mixer->get_recsrc && mixer->put_recsrc)\r\nresult |= SOUND_CAP_EXCL_INPUT;\r\nreturn result;\r\n}\r\nstatic int snd_mixer_oss_devmask(struct snd_mixer_oss_file *fmixer)\r\n{\r\nstruct snd_mixer_oss *mixer = fmixer->mixer;\r\nstruct snd_mixer_oss_slot *pslot;\r\nint result = 0, chn;\r\nif (mixer == NULL)\r\nreturn -EIO;\r\nfor (chn = 0; chn < 31; chn++) {\r\npslot = &mixer->slots[chn];\r\nif (pslot->put_volume || pslot->put_recsrc)\r\nresult |= 1 << chn;\r\n}\r\nreturn result;\r\n}\r\nstatic int snd_mixer_oss_stereodevs(struct snd_mixer_oss_file *fmixer)\r\n{\r\nstruct snd_mixer_oss *mixer = fmixer->mixer;\r\nstruct snd_mixer_oss_slot *pslot;\r\nint result = 0, chn;\r\nif (mixer == NULL)\r\nreturn -EIO;\r\nfor (chn = 0; chn < 31; chn++) {\r\npslot = &mixer->slots[chn];\r\nif (pslot->put_volume && pslot->stereo)\r\nresult |= 1 << chn;\r\n}\r\nreturn result;\r\n}\r\nstatic int snd_mixer_oss_recmask(struct snd_mixer_oss_file *fmixer)\r\n{\r\nstruct snd_mixer_oss *mixer = fmixer->mixer;\r\nint result = 0;\r\nif (mixer == NULL)\r\nreturn -EIO;\r\nif (mixer->put_recsrc && mixer->get_recsrc) {\r\nresult = mixer->mask_recsrc;\r\n} else {\r\nstruct snd_mixer_oss_slot *pslot;\r\nint chn;\r\nfor (chn = 0; chn < 31; chn++) {\r\npslot = &mixer->slots[chn];\r\nif (pslot->put_recsrc)\r\nresult |= 1 << chn;\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic int snd_mixer_oss_get_recsrc(struct snd_mixer_oss_file *fmixer)\r\n{\r\nstruct snd_mixer_oss *mixer = fmixer->mixer;\r\nint result = 0;\r\nif (mixer == NULL)\r\nreturn -EIO;\r\nif (mixer->put_recsrc && mixer->get_recsrc) {\r\nint err;\r\nunsigned int index;\r\nif ((err = mixer->get_recsrc(fmixer, &index)) < 0)\r\nreturn err;\r\nresult = 1 << index;\r\n} else {\r\nstruct snd_mixer_oss_slot *pslot;\r\nint chn;\r\nfor (chn = 0; chn < 31; chn++) {\r\npslot = &mixer->slots[chn];\r\nif (pslot->get_recsrc) {\r\nint active = 0;\r\npslot->get_recsrc(fmixer, pslot, &active);\r\nif (active)\r\nresult |= 1 << chn;\r\n}\r\n}\r\n}\r\nreturn mixer->oss_recsrc = result;\r\n}\r\nstatic int snd_mixer_oss_set_recsrc(struct snd_mixer_oss_file *fmixer, int recsrc)\r\n{\r\nstruct snd_mixer_oss *mixer = fmixer->mixer;\r\nstruct snd_mixer_oss_slot *pslot;\r\nint chn, active;\r\nunsigned int index;\r\nint result = 0;\r\nif (mixer == NULL)\r\nreturn -EIO;\r\nif (mixer->get_recsrc && mixer->put_recsrc) {\r\nif (recsrc & ~mixer->oss_recsrc)\r\nrecsrc &= ~mixer->oss_recsrc;\r\nmixer->put_recsrc(fmixer, ffz(~recsrc));\r\nmixer->get_recsrc(fmixer, &index);\r\nresult = 1 << index;\r\n}\r\nfor (chn = 0; chn < 31; chn++) {\r\npslot = &mixer->slots[chn];\r\nif (pslot->put_recsrc) {\r\nactive = (recsrc & (1 << chn)) ? 1 : 0;\r\npslot->put_recsrc(fmixer, pslot, active);\r\n}\r\n}\r\nif (! result) {\r\nfor (chn = 0; chn < 31; chn++) {\r\npslot = &mixer->slots[chn];\r\nif (pslot->get_recsrc) {\r\nactive = 0;\r\npslot->get_recsrc(fmixer, pslot, &active);\r\nif (active)\r\nresult |= 1 << chn;\r\n}\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic int snd_mixer_oss_get_volume(struct snd_mixer_oss_file *fmixer, int slot)\r\n{\r\nstruct snd_mixer_oss *mixer = fmixer->mixer;\r\nstruct snd_mixer_oss_slot *pslot;\r\nint result = 0, left, right;\r\nif (mixer == NULL || slot > 30)\r\nreturn -EIO;\r\npslot = &mixer->slots[slot];\r\nleft = pslot->volume[0];\r\nright = pslot->volume[1];\r\nif (pslot->get_volume)\r\nresult = pslot->get_volume(fmixer, pslot, &left, &right);\r\nif (!pslot->stereo)\r\nright = left;\r\nif (snd_BUG_ON(left < 0 || left > 100))\r\nreturn -EIO;\r\nif (snd_BUG_ON(right < 0 || right > 100))\r\nreturn -EIO;\r\nif (result >= 0) {\r\npslot->volume[0] = left;\r\npslot->volume[1] = right;\r\nresult = (left & 0xff) | ((right & 0xff) << 8);\r\n}\r\nreturn result;\r\n}\r\nstatic int snd_mixer_oss_set_volume(struct snd_mixer_oss_file *fmixer,\r\nint slot, int volume)\r\n{\r\nstruct snd_mixer_oss *mixer = fmixer->mixer;\r\nstruct snd_mixer_oss_slot *pslot;\r\nint result = 0, left = volume & 0xff, right = (volume >> 8) & 0xff;\r\nif (mixer == NULL || slot > 30)\r\nreturn -EIO;\r\npslot = &mixer->slots[slot];\r\nif (left > 100)\r\nleft = 100;\r\nif (right > 100)\r\nright = 100;\r\nif (!pslot->stereo)\r\nright = left;\r\nif (pslot->put_volume)\r\nresult = pslot->put_volume(fmixer, pslot, left, right);\r\nif (result < 0)\r\nreturn result;\r\npslot->volume[0] = left;\r\npslot->volume[1] = right;\r\nreturn (left & 0xff) | ((right & 0xff) << 8);\r\n}\r\nstatic int snd_mixer_oss_ioctl1(struct snd_mixer_oss_file *fmixer, unsigned int cmd, unsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nint tmp;\r\nif (snd_BUG_ON(!fmixer))\r\nreturn -ENXIO;\r\nif (((cmd >> 8) & 0xff) == 'M') {\r\nswitch (cmd) {\r\ncase SOUND_MIXER_INFO:\r\nreturn snd_mixer_oss_info(fmixer, argp);\r\ncase SOUND_OLD_MIXER_INFO:\r\nreturn snd_mixer_oss_info_obsolete(fmixer, argp);\r\ncase SOUND_MIXER_WRITE_RECSRC:\r\nif (get_user(tmp, p))\r\nreturn -EFAULT;\r\ntmp = snd_mixer_oss_set_recsrc(fmixer, tmp);\r\nif (tmp < 0)\r\nreturn tmp;\r\nreturn put_user(tmp, p);\r\ncase OSS_GETVERSION:\r\nreturn put_user(SNDRV_OSS_VERSION, p);\r\ncase OSS_ALSAEMULVER:\r\nreturn put_user(1, p);\r\ncase SOUND_MIXER_READ_DEVMASK:\r\ntmp = snd_mixer_oss_devmask(fmixer);\r\nif (tmp < 0)\r\nreturn tmp;\r\nreturn put_user(tmp, p);\r\ncase SOUND_MIXER_READ_STEREODEVS:\r\ntmp = snd_mixer_oss_stereodevs(fmixer);\r\nif (tmp < 0)\r\nreturn tmp;\r\nreturn put_user(tmp, p);\r\ncase SOUND_MIXER_READ_RECMASK:\r\ntmp = snd_mixer_oss_recmask(fmixer);\r\nif (tmp < 0)\r\nreturn tmp;\r\nreturn put_user(tmp, p);\r\ncase SOUND_MIXER_READ_CAPS:\r\ntmp = snd_mixer_oss_caps(fmixer);\r\nif (tmp < 0)\r\nreturn tmp;\r\nreturn put_user(tmp, p);\r\ncase SOUND_MIXER_READ_RECSRC:\r\ntmp = snd_mixer_oss_get_recsrc(fmixer);\r\nif (tmp < 0)\r\nreturn tmp;\r\nreturn put_user(tmp, p);\r\n}\r\n}\r\nif (cmd & SIOC_IN) {\r\nif (get_user(tmp, p))\r\nreturn -EFAULT;\r\ntmp = snd_mixer_oss_set_volume(fmixer, cmd & 0xff, tmp);\r\nif (tmp < 0)\r\nreturn tmp;\r\nreturn put_user(tmp, p);\r\n} else if (cmd & SIOC_OUT) {\r\ntmp = snd_mixer_oss_get_volume(fmixer, cmd & 0xff);\r\nif (tmp < 0)\r\nreturn tmp;\r\nreturn put_user(tmp, p);\r\n}\r\nreturn -ENXIO;\r\n}\r\nstatic long snd_mixer_oss_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nreturn snd_mixer_oss_ioctl1(file->private_data, cmd, arg);\r\n}\r\nint snd_mixer_oss_ioctl_card(struct snd_card *card, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct snd_mixer_oss_file fmixer;\r\nif (snd_BUG_ON(!card))\r\nreturn -ENXIO;\r\nif (card->mixer_oss == NULL)\r\nreturn -ENXIO;\r\nmemset(&fmixer, 0, sizeof(fmixer));\r\nfmixer.card = card;\r\nfmixer.mixer = card->mixer_oss;\r\nreturn snd_mixer_oss_ioctl1(&fmixer, cmd, arg);\r\n}\r\nstatic long snd_mixer_oss_conv(long val, long omin, long omax, long nmin, long nmax)\r\n{\r\nlong orange = omax - omin, nrange = nmax - nmin;\r\nif (orange == 0)\r\nreturn 0;\r\nreturn ((nrange * (val - omin)) + (orange / 2)) / orange + nmin;\r\n}\r\nstatic long snd_mixer_oss_conv1(long val, long min, long max, int *old)\r\n{\r\nif (val == snd_mixer_oss_conv(*old, 0, 100, min, max))\r\nreturn *old;\r\nreturn snd_mixer_oss_conv(val, min, max, 0, 100);\r\n}\r\nstatic long snd_mixer_oss_conv2(long val, long min, long max)\r\n{\r\nreturn snd_mixer_oss_conv(val, 0, 100, min, max);\r\n}\r\nstatic struct snd_kcontrol *snd_mixer_oss_test_id(struct snd_mixer_oss *mixer, const char *name, int index)\r\n{\r\nstruct snd_card *card = mixer->card;\r\nstruct snd_ctl_elem_id id;\r\nmemset(&id, 0, sizeof(id));\r\nid.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nstrlcpy(id.name, name, sizeof(id.name));\r\nid.index = index;\r\nreturn snd_ctl_find_id(card, &id);\r\n}\r\nstatic void snd_mixer_oss_get_volume1_vol(struct snd_mixer_oss_file *fmixer,\r\nstruct snd_mixer_oss_slot *pslot,\r\nunsigned int numid,\r\nint *left, int *right)\r\n{\r\nstruct snd_ctl_elem_info *uinfo;\r\nstruct snd_ctl_elem_value *uctl;\r\nstruct snd_kcontrol *kctl;\r\nstruct snd_card *card = fmixer->card;\r\nif (numid == ID_UNKNOWN)\r\nreturn;\r\ndown_read(&card->controls_rwsem);\r\nif ((kctl = snd_ctl_find_numid(card, numid)) == NULL) {\r\nup_read(&card->controls_rwsem);\r\nreturn;\r\n}\r\nuinfo = kzalloc(sizeof(*uinfo), GFP_KERNEL);\r\nuctl = kzalloc(sizeof(*uctl), GFP_KERNEL);\r\nif (uinfo == NULL || uctl == NULL)\r\ngoto __unalloc;\r\nif (kctl->info(kctl, uinfo))\r\ngoto __unalloc;\r\nif (kctl->get(kctl, uctl))\r\ngoto __unalloc;\r\nif (uinfo->type == SNDRV_CTL_ELEM_TYPE_BOOLEAN &&\r\nuinfo->value.integer.min == 0 && uinfo->value.integer.max == 1)\r\ngoto __unalloc;\r\n*left = snd_mixer_oss_conv1(uctl->value.integer.value[0], uinfo->value.integer.min, uinfo->value.integer.max, &pslot->volume[0]);\r\nif (uinfo->count > 1)\r\n*right = snd_mixer_oss_conv1(uctl->value.integer.value[1], uinfo->value.integer.min, uinfo->value.integer.max, &pslot->volume[1]);\r\n__unalloc:\r\nup_read(&card->controls_rwsem);\r\nkfree(uctl);\r\nkfree(uinfo);\r\n}\r\nstatic void snd_mixer_oss_get_volume1_sw(struct snd_mixer_oss_file *fmixer,\r\nstruct snd_mixer_oss_slot *pslot,\r\nunsigned int numid,\r\nint *left, int *right,\r\nint route)\r\n{\r\nstruct snd_ctl_elem_info *uinfo;\r\nstruct snd_ctl_elem_value *uctl;\r\nstruct snd_kcontrol *kctl;\r\nstruct snd_card *card = fmixer->card;\r\nif (numid == ID_UNKNOWN)\r\nreturn;\r\ndown_read(&card->controls_rwsem);\r\nif ((kctl = snd_ctl_find_numid(card, numid)) == NULL) {\r\nup_read(&card->controls_rwsem);\r\nreturn;\r\n}\r\nuinfo = kzalloc(sizeof(*uinfo), GFP_KERNEL);\r\nuctl = kzalloc(sizeof(*uctl), GFP_KERNEL);\r\nif (uinfo == NULL || uctl == NULL)\r\ngoto __unalloc;\r\nif (kctl->info(kctl, uinfo))\r\ngoto __unalloc;\r\nif (kctl->get(kctl, uctl))\r\ngoto __unalloc;\r\nif (!uctl->value.integer.value[0]) {\r\n*left = 0;\r\nif (uinfo->count == 1)\r\n*right = 0;\r\n}\r\nif (uinfo->count > 1 && !uctl->value.integer.value[route ? 3 : 1])\r\n*right = 0;\r\n__unalloc:\r\nup_read(&card->controls_rwsem);\r\nkfree(uctl);\r\nkfree(uinfo);\r\n}\r\nstatic int snd_mixer_oss_get_volume1(struct snd_mixer_oss_file *fmixer,\r\nstruct snd_mixer_oss_slot *pslot,\r\nint *left, int *right)\r\n{\r\nstruct slot *slot = pslot->private_data;\r\n*left = *right = 100;\r\nif (slot->present & SNDRV_MIXER_OSS_PRESENT_PVOLUME) {\r\nsnd_mixer_oss_get_volume1_vol(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_PVOLUME], left, right);\r\n} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_GVOLUME) {\r\nsnd_mixer_oss_get_volume1_vol(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GVOLUME], left, right);\r\n} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_GLOBAL) {\r\nsnd_mixer_oss_get_volume1_vol(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GLOBAL], left, right);\r\n}\r\nif (slot->present & SNDRV_MIXER_OSS_PRESENT_PSWITCH) {\r\nsnd_mixer_oss_get_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_PSWITCH], left, right, 0);\r\n} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_GSWITCH) {\r\nsnd_mixer_oss_get_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GSWITCH], left, right, 0);\r\n} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_PROUTE) {\r\nsnd_mixer_oss_get_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_PROUTE], left, right, 1);\r\n} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_GROUTE) {\r\nsnd_mixer_oss_get_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GROUTE], left, right, 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic void snd_mixer_oss_put_volume1_vol(struct snd_mixer_oss_file *fmixer,\r\nstruct snd_mixer_oss_slot *pslot,\r\nunsigned int numid,\r\nint left, int right)\r\n{\r\nstruct snd_ctl_elem_info *uinfo;\r\nstruct snd_ctl_elem_value *uctl;\r\nstruct snd_kcontrol *kctl;\r\nstruct snd_card *card = fmixer->card;\r\nint res;\r\nif (numid == ID_UNKNOWN)\r\nreturn;\r\ndown_read(&card->controls_rwsem);\r\nif ((kctl = snd_ctl_find_numid(card, numid)) == NULL) {\r\nup_read(&card->controls_rwsem);\r\nreturn;\r\n}\r\nuinfo = kzalloc(sizeof(*uinfo), GFP_KERNEL);\r\nuctl = kzalloc(sizeof(*uctl), GFP_KERNEL);\r\nif (uinfo == NULL || uctl == NULL)\r\ngoto __unalloc;\r\nif (kctl->info(kctl, uinfo))\r\ngoto __unalloc;\r\nif (uinfo->type == SNDRV_CTL_ELEM_TYPE_BOOLEAN &&\r\nuinfo->value.integer.min == 0 && uinfo->value.integer.max == 1)\r\ngoto __unalloc;\r\nuctl->value.integer.value[0] = snd_mixer_oss_conv2(left, uinfo->value.integer.min, uinfo->value.integer.max);\r\nif (uinfo->count > 1)\r\nuctl->value.integer.value[1] = snd_mixer_oss_conv2(right, uinfo->value.integer.min, uinfo->value.integer.max);\r\nif ((res = kctl->put(kctl, uctl)) < 0)\r\ngoto __unalloc;\r\nif (res > 0)\r\nsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, &kctl->id);\r\n__unalloc:\r\nup_read(&card->controls_rwsem);\r\nkfree(uctl);\r\nkfree(uinfo);\r\n}\r\nstatic void snd_mixer_oss_put_volume1_sw(struct snd_mixer_oss_file *fmixer,\r\nstruct snd_mixer_oss_slot *pslot,\r\nunsigned int numid,\r\nint left, int right,\r\nint route)\r\n{\r\nstruct snd_ctl_elem_info *uinfo;\r\nstruct snd_ctl_elem_value *uctl;\r\nstruct snd_kcontrol *kctl;\r\nstruct snd_card *card = fmixer->card;\r\nint res;\r\nif (numid == ID_UNKNOWN)\r\nreturn;\r\ndown_read(&card->controls_rwsem);\r\nif ((kctl = snd_ctl_find_numid(card, numid)) == NULL) {\r\nup_read(&card->controls_rwsem);\r\nreturn;\r\n}\r\nuinfo = kzalloc(sizeof(*uinfo), GFP_KERNEL);\r\nuctl = kzalloc(sizeof(*uctl), GFP_KERNEL);\r\nif (uinfo == NULL || uctl == NULL)\r\ngoto __unalloc;\r\nif (kctl->info(kctl, uinfo))\r\ngoto __unalloc;\r\nif (uinfo->count > 1) {\r\nuctl->value.integer.value[0] = left > 0 ? 1 : 0;\r\nuctl->value.integer.value[route ? 3 : 1] = right > 0 ? 1 : 0;\r\nif (route) {\r\nuctl->value.integer.value[1] =\r\nuctl->value.integer.value[2] = 0;\r\n}\r\n} else {\r\nuctl->value.integer.value[0] = (left > 0 || right > 0) ? 1 : 0;\r\n}\r\nif ((res = kctl->put(kctl, uctl)) < 0)\r\ngoto __unalloc;\r\nif (res > 0)\r\nsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, &kctl->id);\r\n__unalloc:\r\nup_read(&card->controls_rwsem);\r\nkfree(uctl);\r\nkfree(uinfo);\r\n}\r\nstatic int snd_mixer_oss_put_volume1(struct snd_mixer_oss_file *fmixer,\r\nstruct snd_mixer_oss_slot *pslot,\r\nint left, int right)\r\n{\r\nstruct slot *slot = pslot->private_data;\r\nif (slot->present & SNDRV_MIXER_OSS_PRESENT_PVOLUME) {\r\nsnd_mixer_oss_put_volume1_vol(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_PVOLUME], left, right);\r\nif (slot->present & SNDRV_MIXER_OSS_PRESENT_CVOLUME)\r\nsnd_mixer_oss_put_volume1_vol(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_CVOLUME], left, right);\r\n} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_CVOLUME) {\r\nsnd_mixer_oss_put_volume1_vol(fmixer, pslot,\r\nslot->numid[SNDRV_MIXER_OSS_ITEM_CVOLUME], left, right);\r\n} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_GVOLUME) {\r\nsnd_mixer_oss_put_volume1_vol(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GVOLUME], left, right);\r\n} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_GLOBAL) {\r\nsnd_mixer_oss_put_volume1_vol(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GLOBAL], left, right);\r\n}\r\nif (left || right) {\r\nif (slot->present & SNDRV_MIXER_OSS_PRESENT_PSWITCH)\r\nsnd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_PSWITCH], left, right, 0);\r\nif (slot->present & SNDRV_MIXER_OSS_PRESENT_CSWITCH)\r\nsnd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_CSWITCH], left, right, 0);\r\nif (slot->present & SNDRV_MIXER_OSS_PRESENT_GSWITCH)\r\nsnd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GSWITCH], left, right, 0);\r\nif (slot->present & SNDRV_MIXER_OSS_PRESENT_PROUTE)\r\nsnd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_PROUTE], left, right, 1);\r\nif (slot->present & SNDRV_MIXER_OSS_PRESENT_CROUTE)\r\nsnd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_CROUTE], left, right, 1);\r\nif (slot->present & SNDRV_MIXER_OSS_PRESENT_GROUTE)\r\nsnd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GROUTE], left, right, 1);\r\n} else {\r\nif (slot->present & SNDRV_MIXER_OSS_PRESENT_PSWITCH) {\r\nsnd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_PSWITCH], left, right, 0);\r\n} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_CSWITCH) {\r\nsnd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_CSWITCH], left, right, 0);\r\n} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_GSWITCH) {\r\nsnd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GSWITCH], left, right, 0);\r\n} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_PROUTE) {\r\nsnd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_PROUTE], left, right, 1);\r\n} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_CROUTE) {\r\nsnd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_CROUTE], left, right, 1);\r\n} else if (slot->present & SNDRV_MIXER_OSS_PRESENT_GROUTE) {\r\nsnd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_GROUTE], left, right, 1);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_mixer_oss_get_recsrc1_sw(struct snd_mixer_oss_file *fmixer,\r\nstruct snd_mixer_oss_slot *pslot,\r\nint *active)\r\n{\r\nstruct slot *slot = pslot->private_data;\r\nint left, right;\r\nleft = right = 1;\r\nsnd_mixer_oss_get_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_CSWITCH], &left, &right, 0);\r\n*active = (left || right) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int snd_mixer_oss_get_recsrc1_route(struct snd_mixer_oss_file *fmixer,\r\nstruct snd_mixer_oss_slot *pslot,\r\nint *active)\r\n{\r\nstruct slot *slot = pslot->private_data;\r\nint left, right;\r\nleft = right = 1;\r\nsnd_mixer_oss_get_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_CROUTE], &left, &right, 1);\r\n*active = (left || right) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int snd_mixer_oss_put_recsrc1_sw(struct snd_mixer_oss_file *fmixer,\r\nstruct snd_mixer_oss_slot *pslot,\r\nint active)\r\n{\r\nstruct slot *slot = pslot->private_data;\r\nsnd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_CSWITCH], active, active, 0);\r\nreturn 0;\r\n}\r\nstatic int snd_mixer_oss_put_recsrc1_route(struct snd_mixer_oss_file *fmixer,\r\nstruct snd_mixer_oss_slot *pslot,\r\nint active)\r\n{\r\nstruct slot *slot = pslot->private_data;\r\nsnd_mixer_oss_put_volume1_sw(fmixer, pslot, slot->numid[SNDRV_MIXER_OSS_ITEM_CROUTE], active, active, 1);\r\nreturn 0;\r\n}\r\nstatic int snd_mixer_oss_get_recsrc2(struct snd_mixer_oss_file *fmixer, unsigned int *active_index)\r\n{\r\nstruct snd_card *card = fmixer->card;\r\nstruct snd_mixer_oss *mixer = fmixer->mixer;\r\nstruct snd_kcontrol *kctl;\r\nstruct snd_mixer_oss_slot *pslot;\r\nstruct slot *slot;\r\nstruct snd_ctl_elem_info *uinfo;\r\nstruct snd_ctl_elem_value *uctl;\r\nint err, idx;\r\nuinfo = kzalloc(sizeof(*uinfo), GFP_KERNEL);\r\nuctl = kzalloc(sizeof(*uctl), GFP_KERNEL);\r\nif (uinfo == NULL || uctl == NULL) {\r\nerr = -ENOMEM;\r\ngoto __free_only;\r\n}\r\ndown_read(&card->controls_rwsem);\r\nkctl = snd_mixer_oss_test_id(mixer, "Capture Source", 0);\r\nif (! kctl) {\r\nerr = -ENOENT;\r\ngoto __unlock;\r\n}\r\nif ((err = kctl->info(kctl, uinfo)) < 0)\r\ngoto __unlock;\r\nif ((err = kctl->get(kctl, uctl)) < 0)\r\ngoto __unlock;\r\nfor (idx = 0; idx < 32; idx++) {\r\nif (!(mixer->mask_recsrc & (1 << idx)))\r\ncontinue;\r\npslot = &mixer->slots[idx];\r\nslot = pslot->private_data;\r\nif (slot->signature != SNDRV_MIXER_OSS_SIGNATURE)\r\ncontinue;\r\nif (!(slot->present & SNDRV_MIXER_OSS_PRESENT_CAPTURE))\r\ncontinue;\r\nif (slot->capture_item == uctl->value.enumerated.item[0]) {\r\n*active_index = idx;\r\nbreak;\r\n}\r\n}\r\nerr = 0;\r\n__unlock:\r\nup_read(&card->controls_rwsem);\r\n__free_only:\r\nkfree(uctl);\r\nkfree(uinfo);\r\nreturn err;\r\n}\r\nstatic int snd_mixer_oss_put_recsrc2(struct snd_mixer_oss_file *fmixer, unsigned int active_index)\r\n{\r\nstruct snd_card *card = fmixer->card;\r\nstruct snd_mixer_oss *mixer = fmixer->mixer;\r\nstruct snd_kcontrol *kctl;\r\nstruct snd_mixer_oss_slot *pslot;\r\nstruct slot *slot = NULL;\r\nstruct snd_ctl_elem_info *uinfo;\r\nstruct snd_ctl_elem_value *uctl;\r\nint err;\r\nunsigned int idx;\r\nuinfo = kzalloc(sizeof(*uinfo), GFP_KERNEL);\r\nuctl = kzalloc(sizeof(*uctl), GFP_KERNEL);\r\nif (uinfo == NULL || uctl == NULL) {\r\nerr = -ENOMEM;\r\ngoto __free_only;\r\n}\r\ndown_read(&card->controls_rwsem);\r\nkctl = snd_mixer_oss_test_id(mixer, "Capture Source", 0);\r\nif (! kctl) {\r\nerr = -ENOENT;\r\ngoto __unlock;\r\n}\r\nif ((err = kctl->info(kctl, uinfo)) < 0)\r\ngoto __unlock;\r\nfor (idx = 0; idx < 32; idx++) {\r\nif (!(mixer->mask_recsrc & (1 << idx)))\r\ncontinue;\r\npslot = &mixer->slots[idx];\r\nslot = pslot->private_data;\r\nif (slot->signature != SNDRV_MIXER_OSS_SIGNATURE)\r\ncontinue;\r\nif (!(slot->present & SNDRV_MIXER_OSS_PRESENT_CAPTURE))\r\ncontinue;\r\nif (idx == active_index)\r\nbreak;\r\nslot = NULL;\r\n}\r\nif (! slot)\r\ngoto __unlock;\r\nfor (idx = 0; idx < uinfo->count; idx++)\r\nuctl->value.enumerated.item[idx] = slot->capture_item;\r\nerr = kctl->put(kctl, uctl);\r\nif (err > 0)\r\nsnd_ctl_notify(fmixer->card, SNDRV_CTL_EVENT_MASK_VALUE, &kctl->id);\r\nerr = 0;\r\n__unlock:\r\nup_read(&card->controls_rwsem);\r\n__free_only:\r\nkfree(uctl);\r\nkfree(uinfo);\r\nreturn err;\r\n}\r\nstatic int snd_mixer_oss_build_test(struct snd_mixer_oss *mixer, struct slot *slot, const char *name, int index, int item)\r\n{\r\nstruct snd_ctl_elem_info *info;\r\nstruct snd_kcontrol *kcontrol;\r\nstruct snd_card *card = mixer->card;\r\nint err;\r\ndown_read(&card->controls_rwsem);\r\nkcontrol = snd_mixer_oss_test_id(mixer, name, index);\r\nif (kcontrol == NULL) {\r\nup_read(&card->controls_rwsem);\r\nreturn 0;\r\n}\r\ninfo = kmalloc(sizeof(*info), GFP_KERNEL);\r\nif (! info) {\r\nup_read(&card->controls_rwsem);\r\nreturn -ENOMEM;\r\n}\r\nif ((err = kcontrol->info(kcontrol, info)) < 0) {\r\nup_read(&card->controls_rwsem);\r\nkfree(info);\r\nreturn err;\r\n}\r\nslot->numid[item] = kcontrol->id.numid;\r\nup_read(&card->controls_rwsem);\r\nif (info->count > slot->channels)\r\nslot->channels = info->count;\r\nslot->present |= 1 << item;\r\nkfree(info);\r\nreturn 0;\r\n}\r\nstatic void snd_mixer_oss_slot_free(struct snd_mixer_oss_slot *chn)\r\n{\r\nstruct slot *p = chn->private_data;\r\nif (p) {\r\nif (p->allocated && p->assigned) {\r\nkfree(p->assigned->name);\r\nkfree(p->assigned);\r\n}\r\nkfree(p);\r\n}\r\n}\r\nstatic void mixer_slot_clear(struct snd_mixer_oss_slot *rslot)\r\n{\r\nint idx = rslot->number;\r\nif (rslot->private_free)\r\nrslot->private_free(rslot);\r\nmemset(rslot, 0, sizeof(*rslot));\r\nrslot->number = idx;\r\n}\r\nstatic int snd_mixer_oss_build_test_all(struct snd_mixer_oss *mixer,\r\nstruct snd_mixer_oss_assign_table *ptr,\r\nstruct slot *slot)\r\n{\r\nchar str[64];\r\nint err;\r\nerr = snd_mixer_oss_build_test(mixer, slot, ptr->name, ptr->index,\r\nSNDRV_MIXER_OSS_ITEM_GLOBAL);\r\nif (err)\r\nreturn err;\r\nsprintf(str, "%s Switch", ptr->name);\r\nerr = snd_mixer_oss_build_test(mixer, slot, str, ptr->index,\r\nSNDRV_MIXER_OSS_ITEM_GSWITCH);\r\nif (err)\r\nreturn err;\r\nsprintf(str, "%s Route", ptr->name);\r\nerr = snd_mixer_oss_build_test(mixer, slot, str, ptr->index,\r\nSNDRV_MIXER_OSS_ITEM_GROUTE);\r\nif (err)\r\nreturn err;\r\nsprintf(str, "%s Volume", ptr->name);\r\nerr = snd_mixer_oss_build_test(mixer, slot, str, ptr->index,\r\nSNDRV_MIXER_OSS_ITEM_GVOLUME);\r\nif (err)\r\nreturn err;\r\nsprintf(str, "%s Playback Switch", ptr->name);\r\nerr = snd_mixer_oss_build_test(mixer, slot, str, ptr->index,\r\nSNDRV_MIXER_OSS_ITEM_PSWITCH);\r\nif (err)\r\nreturn err;\r\nsprintf(str, "%s Playback Route", ptr->name);\r\nerr = snd_mixer_oss_build_test(mixer, slot, str, ptr->index,\r\nSNDRV_MIXER_OSS_ITEM_PROUTE);\r\nif (err)\r\nreturn err;\r\nsprintf(str, "%s Playback Volume", ptr->name);\r\nerr = snd_mixer_oss_build_test(mixer, slot, str, ptr->index,\r\nSNDRV_MIXER_OSS_ITEM_PVOLUME);\r\nif (err)\r\nreturn err;\r\nsprintf(str, "%s Capture Switch", ptr->name);\r\nerr = snd_mixer_oss_build_test(mixer, slot, str, ptr->index,\r\nSNDRV_MIXER_OSS_ITEM_CSWITCH);\r\nif (err)\r\nreturn err;\r\nsprintf(str, "%s Capture Route", ptr->name);\r\nerr = snd_mixer_oss_build_test(mixer, slot, str, ptr->index,\r\nSNDRV_MIXER_OSS_ITEM_CROUTE);\r\nif (err)\r\nreturn err;\r\nsprintf(str, "%s Capture Volume", ptr->name);\r\nerr = snd_mixer_oss_build_test(mixer, slot, str, ptr->index,\r\nSNDRV_MIXER_OSS_ITEM_CVOLUME);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int snd_mixer_oss_build_input(struct snd_mixer_oss *mixer, struct snd_mixer_oss_assign_table *ptr, int ptr_allocated, int replace_old)\r\n{\r\nstruct slot slot;\r\nstruct slot *pslot;\r\nstruct snd_kcontrol *kctl;\r\nstruct snd_mixer_oss_slot *rslot;\r\nchar str[64];\r\nif (mixer->slots[ptr->oss_id].get_volume && ! replace_old)\r\nreturn 0;\r\nmemset(&slot, 0, sizeof(slot));\r\nmemset(slot.numid, 0xff, sizeof(slot.numid));\r\nif (snd_mixer_oss_build_test_all(mixer, ptr, &slot))\r\nreturn 0;\r\ndown_read(&mixer->card->controls_rwsem);\r\nif (ptr->index == 0 && (kctl = snd_mixer_oss_test_id(mixer, "Capture Source", 0)) != NULL) {\r\nstruct snd_ctl_elem_info *uinfo;\r\nuinfo = kzalloc(sizeof(*uinfo), GFP_KERNEL);\r\nif (! uinfo) {\r\nup_read(&mixer->card->controls_rwsem);\r\nreturn -ENOMEM;\r\n}\r\nif (kctl->info(kctl, uinfo)) {\r\nup_read(&mixer->card->controls_rwsem);\r\nreturn 0;\r\n}\r\nstrcpy(str, ptr->name);\r\nif (!strcmp(str, "Master"))\r\nstrcpy(str, "Mix");\r\nif (!strcmp(str, "Master Mono"))\r\nstrcpy(str, "Mix Mono");\r\nslot.capture_item = 0;\r\nif (!strcmp(uinfo->value.enumerated.name, str)) {\r\nslot.present |= SNDRV_MIXER_OSS_PRESENT_CAPTURE;\r\n} else {\r\nfor (slot.capture_item = 1; slot.capture_item < uinfo->value.enumerated.items; slot.capture_item++) {\r\nuinfo->value.enumerated.item = slot.capture_item;\r\nif (kctl->info(kctl, uinfo)) {\r\nup_read(&mixer->card->controls_rwsem);\r\nreturn 0;\r\n}\r\nif (!strcmp(uinfo->value.enumerated.name, str)) {\r\nslot.present |= SNDRV_MIXER_OSS_PRESENT_CAPTURE;\r\nbreak;\r\n}\r\n}\r\n}\r\nkfree(uinfo);\r\n}\r\nup_read(&mixer->card->controls_rwsem);\r\nif (slot.present != 0) {\r\npslot = kmalloc(sizeof(slot), GFP_KERNEL);\r\nif (! pslot)\r\nreturn -ENOMEM;\r\n*pslot = slot;\r\npslot->signature = SNDRV_MIXER_OSS_SIGNATURE;\r\npslot->assigned = ptr;\r\npslot->allocated = ptr_allocated;\r\nrslot = &mixer->slots[ptr->oss_id];\r\nmixer_slot_clear(rslot);\r\nrslot->stereo = slot.channels > 1 ? 1 : 0;\r\nrslot->get_volume = snd_mixer_oss_get_volume1;\r\nrslot->put_volume = snd_mixer_oss_put_volume1;\r\nif (slot.present & SNDRV_MIXER_OSS_PRESENT_CSWITCH) {\r\nrslot->get_recsrc = snd_mixer_oss_get_recsrc1_sw;\r\nrslot->put_recsrc = snd_mixer_oss_put_recsrc1_sw;\r\n} else if (slot.present & SNDRV_MIXER_OSS_PRESENT_CROUTE) {\r\nrslot->get_recsrc = snd_mixer_oss_get_recsrc1_route;\r\nrslot->put_recsrc = snd_mixer_oss_put_recsrc1_route;\r\n} else if (slot.present & SNDRV_MIXER_OSS_PRESENT_CAPTURE) {\r\nmixer->mask_recsrc |= 1 << ptr->oss_id;\r\n}\r\nrslot->private_data = pslot;\r\nrslot->private_free = snd_mixer_oss_slot_free;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void snd_mixer_oss_proc_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_mixer_oss *mixer = entry->private_data;\r\nint i;\r\nmutex_lock(&mixer->reg_mutex);\r\nfor (i = 0; i < SNDRV_OSS_MAX_MIXERS; i++) {\r\nstruct slot *p;\r\nif (! oss_mixer_names[i])\r\ncontinue;\r\np = (struct slot *)mixer->slots[i].private_data;\r\nsnd_iprintf(buffer, "%s ", oss_mixer_names[i]);\r\nif (p && p->assigned)\r\nsnd_iprintf(buffer, "\"%s\" %d\n",\r\np->assigned->name,\r\np->assigned->index);\r\nelse\r\nsnd_iprintf(buffer, "\"\" 0\n");\r\n}\r\nmutex_unlock(&mixer->reg_mutex);\r\n}\r\nstatic void snd_mixer_oss_proc_write(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_mixer_oss *mixer = entry->private_data;\r\nchar line[128], str[32], idxstr[16];\r\nconst char *cptr;\r\nint ch, idx;\r\nstruct snd_mixer_oss_assign_table *tbl;\r\nstruct slot *slot;\r\nwhile (!snd_info_get_line(buffer, line, sizeof(line))) {\r\ncptr = snd_info_get_str(str, line, sizeof(str));\r\nfor (ch = 0; ch < SNDRV_OSS_MAX_MIXERS; ch++)\r\nif (oss_mixer_names[ch] && strcmp(oss_mixer_names[ch], str) == 0)\r\nbreak;\r\nif (ch >= SNDRV_OSS_MAX_MIXERS) {\r\nsnd_printk(KERN_ERR "mixer_oss: invalid OSS volume '%s'\n", str);\r\ncontinue;\r\n}\r\ncptr = snd_info_get_str(str, cptr, sizeof(str));\r\nif (! *str) {\r\nmutex_lock(&mixer->reg_mutex);\r\nmixer_slot_clear(&mixer->slots[ch]);\r\nmutex_unlock(&mixer->reg_mutex);\r\ncontinue;\r\n}\r\nsnd_info_get_str(idxstr, cptr, sizeof(idxstr));\r\nidx = simple_strtoul(idxstr, NULL, 10);\r\nif (idx >= 0x4000) {\r\nsnd_printk(KERN_ERR "mixer_oss: invalid index %d\n", idx);\r\ncontinue;\r\n}\r\nmutex_lock(&mixer->reg_mutex);\r\nslot = (struct slot *)mixer->slots[ch].private_data;\r\nif (slot && slot->assigned &&\r\nslot->assigned->index == idx && ! strcmp(slot->assigned->name, str))\r\ngoto __unlock;\r\ntbl = kmalloc(sizeof(*tbl), GFP_KERNEL);\r\nif (! tbl) {\r\nsnd_printk(KERN_ERR "mixer_oss: no memory\n");\r\ngoto __unlock;\r\n}\r\ntbl->oss_id = ch;\r\ntbl->name = kstrdup(str, GFP_KERNEL);\r\nif (! tbl->name) {\r\nkfree(tbl);\r\ngoto __unlock;\r\n}\r\ntbl->index = idx;\r\nif (snd_mixer_oss_build_input(mixer, tbl, 1, 1) <= 0) {\r\nkfree(tbl->name);\r\nkfree(tbl);\r\n}\r\n__unlock:\r\nmutex_unlock(&mixer->reg_mutex);\r\n}\r\n}\r\nstatic void snd_mixer_oss_proc_init(struct snd_mixer_oss *mixer)\r\n{\r\nstruct snd_info_entry *entry;\r\nentry = snd_info_create_card_entry(mixer->card, "oss_mixer",\r\nmixer->card->proc_root);\r\nif (! entry)\r\nreturn;\r\nentry->content = SNDRV_INFO_CONTENT_TEXT;\r\nentry->mode = S_IFREG | S_IRUGO | S_IWUSR;\r\nentry->c.text.read = snd_mixer_oss_proc_read;\r\nentry->c.text.write = snd_mixer_oss_proc_write;\r\nentry->private_data = mixer;\r\nif (snd_info_register(entry) < 0) {\r\nsnd_info_free_entry(entry);\r\nentry = NULL;\r\n}\r\nmixer->proc_entry = entry;\r\n}\r\nstatic void snd_mixer_oss_proc_done(struct snd_mixer_oss *mixer)\r\n{\r\nsnd_info_free_entry(mixer->proc_entry);\r\nmixer->proc_entry = NULL;\r\n}\r\nstatic void snd_mixer_oss_build(struct snd_mixer_oss *mixer)\r\n{\r\nstatic struct snd_mixer_oss_assign_table table[] = {\r\n{ SOUND_MIXER_VOLUME, "Master", 0 },\r\n{ SOUND_MIXER_VOLUME, "Front", 0 },\r\n{ SOUND_MIXER_BASS, "Tone Control - Bass", 0 },\r\n{ SOUND_MIXER_TREBLE, "Tone Control - Treble", 0 },\r\n{ SOUND_MIXER_SYNTH, "Synth", 0 },\r\n{ SOUND_MIXER_SYNTH, "FM", 0 },\r\n{ SOUND_MIXER_SYNTH, "Music", 0 },\r\n{ SOUND_MIXER_PCM, "PCM", 0 },\r\n{ SOUND_MIXER_SPEAKER, "Beep", 0 },\r\n{ SOUND_MIXER_SPEAKER, "PC Speaker", 0 },\r\n{ SOUND_MIXER_SPEAKER, "Speaker", 0 },\r\n{ SOUND_MIXER_LINE, "Line", 0 },\r\n{ SOUND_MIXER_MIC, "Mic", 0 },\r\n{ SOUND_MIXER_CD, "CD", 0 },\r\n{ SOUND_MIXER_IMIX, "Monitor Mix", 0 },\r\n{ SOUND_MIXER_ALTPCM, "PCM", 1 },\r\n{ SOUND_MIXER_ALTPCM, "Headphone", 0 },\r\n{ SOUND_MIXER_ALTPCM, "Wave", 0 },\r\n{ SOUND_MIXER_RECLEV, "-- nothing --", 0 },\r\n{ SOUND_MIXER_IGAIN, "Capture", 0 },\r\n{ SOUND_MIXER_OGAIN, "Playback", 0 },\r\n{ SOUND_MIXER_LINE1, "Aux", 0 },\r\n{ SOUND_MIXER_LINE2, "Aux", 1 },\r\n{ SOUND_MIXER_LINE3, "Aux", 2 },\r\n{ SOUND_MIXER_DIGITAL1, "Digital", 0 },\r\n{ SOUND_MIXER_DIGITAL1, "IEC958", 0 },\r\n{ SOUND_MIXER_DIGITAL1, "IEC958 Optical", 0 },\r\n{ SOUND_MIXER_DIGITAL1, "IEC958 Coaxial", 0 },\r\n{ SOUND_MIXER_DIGITAL2, "Digital", 1 },\r\n{ SOUND_MIXER_DIGITAL3, "Digital", 2 },\r\n{ SOUND_MIXER_PHONEIN, "Phone", 0 },\r\n{ SOUND_MIXER_PHONEOUT, "Master Mono", 0 },\r\n{ SOUND_MIXER_PHONEOUT, "Speaker", 0 },\r\n{ SOUND_MIXER_PHONEOUT, "Mono", 0 },\r\n{ SOUND_MIXER_PHONEOUT, "Phone", 0 },\r\n{ SOUND_MIXER_VIDEO, "Video", 0 },\r\n{ SOUND_MIXER_RADIO, "Radio", 0 },\r\n{ SOUND_MIXER_MONITOR, "Monitor", 0 }\r\n};\r\nunsigned int idx;\r\nfor (idx = 0; idx < ARRAY_SIZE(table); idx++)\r\nsnd_mixer_oss_build_input(mixer, &table[idx], 0, 0);\r\nif (mixer->mask_recsrc) {\r\nmixer->get_recsrc = snd_mixer_oss_get_recsrc2;\r\nmixer->put_recsrc = snd_mixer_oss_put_recsrc2;\r\n}\r\n}\r\nstatic int snd_mixer_oss_free1(void *private)\r\n{\r\nstruct snd_mixer_oss *mixer = private;\r\nstruct snd_card *card;\r\nint idx;\r\nif (!mixer)\r\nreturn 0;\r\ncard = mixer->card;\r\nif (snd_BUG_ON(mixer != card->mixer_oss))\r\nreturn -ENXIO;\r\ncard->mixer_oss = NULL;\r\nfor (idx = 0; idx < SNDRV_OSS_MAX_MIXERS; idx++) {\r\nstruct snd_mixer_oss_slot *chn = &mixer->slots[idx];\r\nif (chn->private_free)\r\nchn->private_free(chn);\r\n}\r\nkfree(mixer);\r\nreturn 0;\r\n}\r\nstatic int snd_mixer_oss_notify_handler(struct snd_card *card, int cmd)\r\n{\r\nstruct snd_mixer_oss *mixer;\r\nif (cmd == SND_MIXER_OSS_NOTIFY_REGISTER) {\r\nchar name[128];\r\nint idx, err;\r\nmixer = kcalloc(2, sizeof(*mixer), GFP_KERNEL);\r\nif (mixer == NULL)\r\nreturn -ENOMEM;\r\nmutex_init(&mixer->reg_mutex);\r\nsprintf(name, "mixer%i%i", card->number, 0);\r\nif ((err = snd_register_oss_device(SNDRV_OSS_DEVICE_TYPE_MIXER,\r\ncard, 0,\r\n&snd_mixer_oss_f_ops, card,\r\nname)) < 0) {\r\nsnd_printk(KERN_ERR "unable to register OSS mixer device %i:%i\n",\r\ncard->number, 0);\r\nkfree(mixer);\r\nreturn err;\r\n}\r\nmixer->oss_dev_alloc = 1;\r\nmixer->card = card;\r\nif (*card->mixername)\r\nstrlcpy(mixer->name, card->mixername, sizeof(mixer->name));\r\nelse\r\nstrlcpy(mixer->name, name, sizeof(mixer->name));\r\n#ifdef SNDRV_OSS_INFO_DEV_MIXERS\r\nsnd_oss_info_register(SNDRV_OSS_INFO_DEV_MIXERS,\r\ncard->number,\r\nmixer->name);\r\n#endif\r\nfor (idx = 0; idx < SNDRV_OSS_MAX_MIXERS; idx++)\r\nmixer->slots[idx].number = idx;\r\ncard->mixer_oss = mixer;\r\nsnd_mixer_oss_build(mixer);\r\nsnd_mixer_oss_proc_init(mixer);\r\n} else {\r\nmixer = card->mixer_oss;\r\nif (mixer == NULL)\r\nreturn 0;\r\nif (mixer->oss_dev_alloc) {\r\n#ifdef SNDRV_OSS_INFO_DEV_MIXERS\r\nsnd_oss_info_unregister(SNDRV_OSS_INFO_DEV_MIXERS, mixer->card->number);\r\n#endif\r\nsnd_unregister_oss_device(SNDRV_OSS_DEVICE_TYPE_MIXER, mixer->card, 0);\r\nmixer->oss_dev_alloc = 0;\r\n}\r\nif (cmd == SND_MIXER_OSS_NOTIFY_DISCONNECT)\r\nreturn 0;\r\nsnd_mixer_oss_proc_done(mixer);\r\nreturn snd_mixer_oss_free1(mixer);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init alsa_mixer_oss_init(void)\r\n{\r\nint idx;\r\nsnd_mixer_oss_notify_callback = snd_mixer_oss_notify_handler;\r\nfor (idx = 0; idx < SNDRV_CARDS; idx++) {\r\nif (snd_cards[idx])\r\nsnd_mixer_oss_notify_handler(snd_cards[idx], SND_MIXER_OSS_NOTIFY_REGISTER);\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_mixer_oss_exit(void)\r\n{\r\nint idx;\r\nsnd_mixer_oss_notify_callback = NULL;\r\nfor (idx = 0; idx < SNDRV_CARDS; idx++) {\r\nif (snd_cards[idx])\r\nsnd_mixer_oss_notify_handler(snd_cards[idx], SND_MIXER_OSS_NOTIFY_FREE);\r\n}\r\n}
