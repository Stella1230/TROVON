static inline struct mt9v011 *to_mt9v011(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct mt9v011, sd);\r\n}\r\nstatic int mt9v011_read(struct v4l2_subdev *sd, unsigned char addr)\r\n{\r\nstruct i2c_client *c = v4l2_get_subdevdata(sd);\r\n__be16 buffer;\r\nint rc, val;\r\nrc = i2c_master_send(c, &addr, 1);\r\nif (rc != 1)\r\nv4l2_dbg(0, debug, sd,\r\n"i2c i/o error: rc == %d (should be 1)\n", rc);\r\nmsleep(10);\r\nrc = i2c_master_recv(c, (char *)&buffer, 2);\r\nif (rc != 2)\r\nv4l2_dbg(0, debug, sd,\r\n"i2c i/o error: rc == %d (should be 2)\n", rc);\r\nval = be16_to_cpu(buffer);\r\nv4l2_dbg(2, debug, sd, "mt9v011: read 0x%02x = 0x%04x\n", addr, val);\r\nreturn val;\r\n}\r\nstatic void mt9v011_write(struct v4l2_subdev *sd, unsigned char addr,\r\nu16 value)\r\n{\r\nstruct i2c_client *c = v4l2_get_subdevdata(sd);\r\nunsigned char buffer[3];\r\nint rc;\r\nbuffer[0] = addr;\r\nbuffer[1] = value >> 8;\r\nbuffer[2] = value & 0xff;\r\nv4l2_dbg(2, debug, sd,\r\n"mt9v011: writing 0x%02x 0x%04x\n", buffer[0], value);\r\nrc = i2c_master_send(c, buffer, 3);\r\nif (rc != 3)\r\nv4l2_dbg(0, debug, sd,\r\n"i2c i/o error: rc == %d (should be 3)\n", rc);\r\n}\r\nstatic u16 calc_mt9v011_gain(s16 lineargain)\r\n{\r\nu16 digitalgain = 0;\r\nu16 analogmult = 0;\r\nu16 analoginit = 0;\r\nif (lineargain < 0)\r\nlineargain = 0;\r\nlineargain += 0x0020;\r\nif (lineargain > 2047)\r\nlineargain = 2047;\r\nif (lineargain > 1023) {\r\ndigitalgain = 3;\r\nanalogmult = 3;\r\nanaloginit = lineargain / 16;\r\n} else if (lineargain > 511) {\r\ndigitalgain = 1;\r\nanalogmult = 3;\r\nanaloginit = lineargain / 8;\r\n} else if (lineargain > 255) {\r\nanalogmult = 3;\r\nanaloginit = lineargain / 4;\r\n} else if (lineargain > 127) {\r\nanalogmult = 1;\r\nanaloginit = lineargain / 2;\r\n} else\r\nanaloginit = lineargain;\r\nreturn analoginit + (analogmult << 7) + (digitalgain << 9);\r\n}\r\nstatic void set_balance(struct v4l2_subdev *sd)\r\n{\r\nstruct mt9v011 *core = to_mt9v011(sd);\r\nu16 green_gain, blue_gain, red_gain;\r\nu16 exposure;\r\ns16 bal;\r\nexposure = core->exposure;\r\ngreen_gain = calc_mt9v011_gain(core->global_gain);\r\nbal = core->global_gain;\r\nbal += (core->blue_bal * core->global_gain / (1 << 7));\r\nblue_gain = calc_mt9v011_gain(bal);\r\nbal = core->global_gain;\r\nbal += (core->red_bal * core->global_gain / (1 << 7));\r\nred_gain = calc_mt9v011_gain(bal);\r\nmt9v011_write(sd, R2B_MT9V011_GREEN_1_GAIN, green_gain);\r\nmt9v011_write(sd, R2E_MT9V011_GREEN_2_GAIN, green_gain);\r\nmt9v011_write(sd, R2C_MT9V011_BLUE_GAIN, blue_gain);\r\nmt9v011_write(sd, R2D_MT9V011_RED_GAIN, red_gain);\r\nmt9v011_write(sd, R09_MT9V011_SHUTTER_WIDTH, exposure);\r\n}\r\nstatic void calc_fps(struct v4l2_subdev *sd, u32 *numerator, u32 *denominator)\r\n{\r\nstruct mt9v011 *core = to_mt9v011(sd);\r\nunsigned height, width, hblank, vblank, speed;\r\nunsigned row_time, t_time;\r\nu64 frames_per_ms;\r\nunsigned tmp;\r\nheight = mt9v011_read(sd, R03_MT9V011_HEIGHT);\r\nwidth = mt9v011_read(sd, R04_MT9V011_WIDTH);\r\nhblank = mt9v011_read(sd, R05_MT9V011_HBLANK);\r\nvblank = mt9v011_read(sd, R06_MT9V011_VBLANK);\r\nspeed = mt9v011_read(sd, R0A_MT9V011_CLK_SPEED);\r\nrow_time = (width + 113 + hblank) * (speed + 2);\r\nt_time = row_time * (height + vblank + 1);\r\nframes_per_ms = core->xtal * 1000l;\r\ndo_div(frames_per_ms, t_time);\r\ntmp = frames_per_ms;\r\nv4l2_dbg(1, debug, sd, "Programmed to %u.%03u fps (%d pixel clcks)\n",\r\ntmp / 1000, tmp % 1000, t_time);\r\nif (numerator && denominator) {\r\n*numerator = 1000;\r\n*denominator = (u32)frames_per_ms;\r\n}\r\n}\r\nstatic u16 calc_speed(struct v4l2_subdev *sd, u32 numerator, u32 denominator)\r\n{\r\nstruct mt9v011 *core = to_mt9v011(sd);\r\nunsigned height, width, hblank, vblank;\r\nunsigned row_time, line_time;\r\nu64 t_time, speed;\r\nif (!numerator || !denominator)\r\nreturn 0;\r\nheight = mt9v011_read(sd, R03_MT9V011_HEIGHT);\r\nwidth = mt9v011_read(sd, R04_MT9V011_WIDTH);\r\nhblank = mt9v011_read(sd, R05_MT9V011_HBLANK);\r\nvblank = mt9v011_read(sd, R06_MT9V011_VBLANK);\r\nrow_time = width + 113 + hblank;\r\nline_time = height + vblank + 1;\r\nt_time = core->xtal * ((u64)numerator);\r\nt_time += denominator / 2;\r\ndo_div(t_time, denominator);\r\nspeed = t_time;\r\ndo_div(speed, row_time * line_time);\r\nif (speed < 2)\r\nspeed = 0;\r\nelse\r\nspeed -= 2;\r\nif (speed > 15)\r\nreturn 15;\r\nreturn (u16)speed;\r\n}\r\nstatic void set_res(struct v4l2_subdev *sd)\r\n{\r\nstruct mt9v011 *core = to_mt9v011(sd);\r\nunsigned vstart, hstart;\r\nhstart = 20 + (640 - core->width) / 2;\r\nmt9v011_write(sd, R02_MT9V011_COLSTART, hstart);\r\nmt9v011_write(sd, R04_MT9V011_WIDTH, core->width);\r\nmt9v011_write(sd, R05_MT9V011_HBLANK, 771 - core->width);\r\nvstart = 8 + (480 - core->height) / 2;\r\nmt9v011_write(sd, R01_MT9V011_ROWSTART, vstart);\r\nmt9v011_write(sd, R03_MT9V011_HEIGHT, core->height);\r\nmt9v011_write(sd, R06_MT9V011_VBLANK, 508 - core->height);\r\ncalc_fps(sd, NULL, NULL);\r\n}\r\nstatic void set_read_mode(struct v4l2_subdev *sd)\r\n{\r\nstruct mt9v011 *core = to_mt9v011(sd);\r\nunsigned mode = 0x1000;\r\nif (core->hflip)\r\nmode |= 0x4000;\r\nif (core->vflip)\r\nmode |= 0x8000;\r\nmt9v011_write(sd, R20_MT9V011_READ_MODE, mode);\r\n}\r\nstatic int mt9v011_reset(struct v4l2_subdev *sd, u32 val)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(mt9v011_init_default); i++)\r\nmt9v011_write(sd, mt9v011_init_default[i].reg,\r\nmt9v011_init_default[i].value);\r\nset_balance(sd);\r\nset_res(sd);\r\nset_read_mode(sd);\r\nreturn 0;\r\n}\r\nstatic int mt9v011_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)\r\n{\r\nstruct mt9v011 *core = to_mt9v011(sd);\r\nv4l2_dbg(1, debug, sd, "g_ctrl called\n");\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_GAIN:\r\nctrl->value = core->global_gain;\r\nreturn 0;\r\ncase V4L2_CID_EXPOSURE:\r\nctrl->value = core->exposure;\r\nreturn 0;\r\ncase V4L2_CID_RED_BALANCE:\r\nctrl->value = core->red_bal;\r\nreturn 0;\r\ncase V4L2_CID_BLUE_BALANCE:\r\nctrl->value = core->blue_bal;\r\nreturn 0;\r\ncase V4L2_CID_HFLIP:\r\nctrl->value = core->hflip ? 1 : 0;\r\nreturn 0;\r\ncase V4L2_CID_VFLIP:\r\nctrl->value = core->vflip ? 1 : 0;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int mt9v011_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)\r\n{\r\nint i;\r\nv4l2_dbg(1, debug, sd, "queryctrl called\n");\r\nfor (i = 0; i < ARRAY_SIZE(mt9v011_qctrl); i++)\r\nif (qc->id && qc->id == mt9v011_qctrl[i].id) {\r\nmemcpy(qc, &(mt9v011_qctrl[i]),\r\nsizeof(*qc));\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int mt9v011_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)\r\n{\r\nstruct mt9v011 *core = to_mt9v011(sd);\r\nu8 i, n;\r\nn = ARRAY_SIZE(mt9v011_qctrl);\r\nfor (i = 0; i < n; i++) {\r\nif (ctrl->id != mt9v011_qctrl[i].id)\r\ncontinue;\r\nif (ctrl->value < mt9v011_qctrl[i].minimum ||\r\nctrl->value > mt9v011_qctrl[i].maximum)\r\nreturn -ERANGE;\r\nv4l2_dbg(1, debug, sd, "s_ctrl: id=%d, value=%d\n",\r\nctrl->id, ctrl->value);\r\nbreak;\r\n}\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_GAIN:\r\ncore->global_gain = ctrl->value;\r\nbreak;\r\ncase V4L2_CID_EXPOSURE:\r\ncore->exposure = ctrl->value;\r\nbreak;\r\ncase V4L2_CID_RED_BALANCE:\r\ncore->red_bal = ctrl->value;\r\nbreak;\r\ncase V4L2_CID_BLUE_BALANCE:\r\ncore->blue_bal = ctrl->value;\r\nbreak;\r\ncase V4L2_CID_HFLIP:\r\ncore->hflip = ctrl->value;\r\nset_read_mode(sd);\r\nreturn 0;\r\ncase V4L2_CID_VFLIP:\r\ncore->vflip = ctrl->value;\r\nset_read_mode(sd);\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nset_balance(sd);\r\nreturn 0;\r\n}\r\nstatic int mt9v011_enum_mbus_fmt(struct v4l2_subdev *sd, unsigned index,\r\nenum v4l2_mbus_pixelcode *code)\r\n{\r\nif (index > 0)\r\nreturn -EINVAL;\r\n*code = V4L2_MBUS_FMT_SGRBG8_1X8;\r\nreturn 0;\r\n}\r\nstatic int mt9v011_try_mbus_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *fmt)\r\n{\r\nif (fmt->code != V4L2_MBUS_FMT_SGRBG8_1X8)\r\nreturn -EINVAL;\r\nv4l_bound_align_image(&fmt->width, 48, 639, 1,\r\n&fmt->height, 32, 480, 1, 0);\r\nfmt->field = V4L2_FIELD_NONE;\r\nfmt->colorspace = V4L2_COLORSPACE_SRGB;\r\nreturn 0;\r\n}\r\nstatic int mt9v011_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)\r\n{\r\nstruct v4l2_captureparm *cp = &parms->parm.capture;\r\nif (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nmemset(cp, 0, sizeof(struct v4l2_captureparm));\r\ncp->capability = V4L2_CAP_TIMEPERFRAME;\r\ncalc_fps(sd,\r\n&cp->timeperframe.numerator,\r\n&cp->timeperframe.denominator);\r\nreturn 0;\r\n}\r\nstatic int mt9v011_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)\r\n{\r\nstruct v4l2_captureparm *cp = &parms->parm.capture;\r\nstruct v4l2_fract *tpf = &cp->timeperframe;\r\nu16 speed;\r\nif (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (cp->extendedmode != 0)\r\nreturn -EINVAL;\r\nspeed = calc_speed(sd, tpf->numerator, tpf->denominator);\r\nmt9v011_write(sd, R0A_MT9V011_CLK_SPEED, speed);\r\nv4l2_dbg(1, debug, sd, "Setting speed to %d\n", speed);\r\ncalc_fps(sd, &tpf->numerator, &tpf->denominator);\r\nreturn 0;\r\n}\r\nstatic int mt9v011_s_mbus_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *fmt)\r\n{\r\nstruct mt9v011 *core = to_mt9v011(sd);\r\nint rc;\r\nrc = mt9v011_try_mbus_fmt(sd, fmt);\r\nif (rc < 0)\r\nreturn -EINVAL;\r\ncore->width = fmt->width;\r\ncore->height = fmt->height;\r\nset_res(sd);\r\nreturn 0;\r\n}\r\nstatic int mt9v011_g_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (!v4l2_chip_match_i2c_client(client, &reg->match))\r\nreturn -EINVAL;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nreg->val = mt9v011_read(sd, reg->reg & 0xff);\r\nreg->size = 2;\r\nreturn 0;\r\n}\r\nstatic int mt9v011_s_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (!v4l2_chip_match_i2c_client(client, &reg->match))\r\nreturn -EINVAL;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nmt9v011_write(sd, reg->reg & 0xff, reg->val & 0xffff);\r\nreturn 0;\r\n}\r\nstatic int mt9v011_g_chip_ident(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_chip_ident *chip)\r\n{\r\nu16 version;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nversion = mt9v011_read(sd, R00_MT9V011_CHIP_VERSION);\r\nreturn v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_MT9V011,\r\nversion);\r\n}\r\nstatic int mt9v011_probe(struct i2c_client *c,\r\nconst struct i2c_device_id *id)\r\n{\r\nu16 version;\r\nstruct mt9v011 *core;\r\nstruct v4l2_subdev *sd;\r\nif (!i2c_check_functionality(c->adapter,\r\nI2C_FUNC_SMBUS_READ_BYTE | I2C_FUNC_SMBUS_WRITE_BYTE_DATA))\r\nreturn -EIO;\r\ncore = kzalloc(sizeof(struct mt9v011), GFP_KERNEL);\r\nif (!core)\r\nreturn -ENOMEM;\r\nsd = &core->sd;\r\nv4l2_i2c_subdev_init(sd, c, &mt9v011_ops);\r\nversion = mt9v011_read(sd, R00_MT9V011_CHIP_VERSION);\r\nif ((version != MT9V011_VERSION) &&\r\n(version != MT9V011_REV_B_VERSION)) {\r\nv4l2_info(sd, "*** unknown micron chip detected (0x%04x).\n",\r\nversion);\r\nkfree(core);\r\nreturn -EINVAL;\r\n}\r\ncore->global_gain = 0x0024;\r\ncore->exposure = 0x01fc;\r\ncore->width = 640;\r\ncore->height = 480;\r\ncore->xtal = 27000000;\r\nif (c->dev.platform_data) {\r\nstruct mt9v011_platform_data *pdata = c->dev.platform_data;\r\ncore->xtal = pdata->xtal;\r\nv4l2_dbg(1, debug, sd, "xtal set to %d.%03d MHz\n",\r\ncore->xtal / 1000000, (core->xtal / 1000) % 1000);\r\n}\r\nv4l_info(c, "chip found @ 0x%02x (%s - chip version 0x%04x)\n",\r\nc->addr << 1, c->adapter->name, version);\r\nreturn 0;\r\n}\r\nstatic int mt9v011_remove(struct i2c_client *c)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(c);\r\nv4l2_dbg(1, debug, sd,\r\n"mt9v011.c: removing mt9v011 adapter on address 0x%x\n",\r\nc->addr << 1);\r\nv4l2_device_unregister_subdev(sd);\r\nkfree(to_mt9v011(sd));\r\nreturn 0;\r\n}\r\nstatic __init int init_mt9v011(void)\r\n{\r\nreturn i2c_add_driver(&mt9v011_driver);\r\n}\r\nstatic __exit void exit_mt9v011(void)\r\n{\r\ni2c_del_driver(&mt9v011_driver);\r\n}
