static int sa1100_irda_rx_alloc(struct sa1100_irda *si)\r\n{\r\nif (si->rxskb)\r\nreturn 0;\r\nsi->rxskb = alloc_skb(HPSIR_MAX_RXLEN + 1, GFP_ATOMIC);\r\nif (!si->rxskb) {\r\nprintk(KERN_ERR "sa1100_ir: out of memory for RX SKB\n");\r\nreturn -ENOMEM;\r\n}\r\nskb_reserve(si->rxskb, 1);\r\nsi->rxbuf_dma = dma_map_single(si->dev, si->rxskb->data,\r\nHPSIR_MAX_RXLEN,\r\nDMA_FROM_DEVICE);\r\nreturn 0;\r\n}\r\nstatic void sa1100_irda_rx_dma_start(struct sa1100_irda *si)\r\n{\r\nif (!si->rxskb) {\r\nprintk(KERN_ERR "sa1100_ir: rx buffer went missing\n");\r\nreturn;\r\n}\r\nSer2HSCR0 = si->hscr0 | HSCR0_HSSP;\r\nsa1100_clear_dma(si->rxdma);\r\nsa1100_start_dma(si->rxdma, si->rxbuf_dma, HPSIR_MAX_RXLEN);\r\nSer2HSCR0 = si->hscr0 | HSCR0_HSSP | HSCR0_RXE;\r\n}\r\nstatic int sa1100_irda_set_speed(struct sa1100_irda *si, int speed)\r\n{\r\nunsigned long flags;\r\nint brd, ret = -EINVAL;\r\nswitch (speed) {\r\ncase 9600: case 19200: case 38400:\r\ncase 57600: case 115200:\r\nbrd = 3686400 / (16 * speed) - 1;\r\nif (IS_FIR(si))\r\nsa1100_stop_dma(si->rxdma);\r\nlocal_irq_save(flags);\r\nSer2UTCR3 = 0;\r\nSer2HSCR0 = HSCR0_UART;\r\nSer2UTCR1 = brd >> 8;\r\nSer2UTCR2 = brd;\r\nSer2UTSR0 = UTSR0_REB | UTSR0_RBB | UTSR0_RID;\r\nSer2UTCR3 = UTCR3_RIE | UTCR3_RXE | UTCR3_TXE;\r\nif (si->pdata->set_speed)\r\nsi->pdata->set_speed(si->dev, speed);\r\nsi->speed = speed;\r\nlocal_irq_restore(flags);\r\nret = 0;\r\nbreak;\r\ncase 4000000:\r\nlocal_irq_save(flags);\r\nsi->hscr0 = 0;\r\nSer2HSSR0 = 0xff;\r\nSer2HSCR0 = si->hscr0 | HSCR0_HSSP;\r\nSer2UTCR3 = 0;\r\nsi->speed = speed;\r\nif (si->pdata->set_speed)\r\nsi->pdata->set_speed(si->dev, speed);\r\nsa1100_irda_rx_alloc(si);\r\nsa1100_irda_rx_dma_start(si);\r\nlocal_irq_restore(flags);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\n__sa1100_irda_set_power(struct sa1100_irda *si, unsigned int state)\r\n{\r\nint ret = 0;\r\nif (si->pdata->set_power)\r\nret = si->pdata->set_power(si->dev, state);\r\nreturn ret;\r\n}\r\nstatic inline int\r\nsa1100_set_power(struct sa1100_irda *si, unsigned int state)\r\n{\r\nint ret;\r\nret = __sa1100_irda_set_power(si, state);\r\nif (ret == 0)\r\nsi->power = state;\r\nreturn ret;\r\n}\r\nstatic int sa1100_irda_startup(struct sa1100_irda *si)\r\n{\r\nint ret;\r\nif (si->pdata->startup) {\r\nret = si->pdata->startup(si->dev);\r\nif (ret)\r\nreturn ret;\r\n}\r\nPPSR &= ~PPC_TXD2;\r\nPSDR &= ~PPC_TXD2;\r\nPPDR |= PPC_TXD2;\r\nSer2UTCR3 = 0;\r\nSer2HSCR0 = HSCR0_UART;\r\nSer2UTCR4 = si->utcr4;\r\nSer2UTCR0 = UTCR0_8BitData;\r\nSer2HSCR2 = HSCR2_TrDataH | HSCR2_RcDataL;\r\nSer2UTSR0 = UTSR0_REB | UTSR0_RBB | UTSR0_RID;\r\nret = sa1100_irda_set_speed(si, si->speed = 9600);\r\nif (ret) {\r\nSer2UTCR3 = 0;\r\nSer2HSCR0 = 0;\r\nif (si->pdata->shutdown)\r\nsi->pdata->shutdown(si->dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic void sa1100_irda_shutdown(struct sa1100_irda *si)\r\n{\r\nsa1100_stop_dma(si->rxdma);\r\nsa1100_stop_dma(si->txdma);\r\nSer2UTCR3 = 0;\r\nSer2HSCR0 = 0;\r\nif (si->pdata->shutdown)\r\nsi->pdata->shutdown(si->dev);\r\n}\r\nstatic int sa1100_irda_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nstruct sa1100_irda *si;\r\nif (!dev)\r\nreturn 0;\r\nsi = netdev_priv(dev);\r\nif (si->open) {\r\nnetif_device_detach(dev);\r\ndisable_irq(dev->irq);\r\nsa1100_irda_shutdown(si);\r\n__sa1100_irda_set_power(si, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sa1100_irda_resume(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nstruct sa1100_irda *si;\r\nif (!dev)\r\nreturn 0;\r\nsi = netdev_priv(dev);\r\nif (si->open) {\r\nif (si->newspeed) {\r\nsi->speed = si->newspeed;\r\nsi->newspeed = 0;\r\n}\r\nsa1100_irda_startup(si);\r\n__sa1100_irda_set_power(si, si->power);\r\nenable_irq(dev->irq);\r\nnetif_device_attach(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void sa1100_irda_hpsir_irq(struct net_device *dev)\r\n{\r\nstruct sa1100_irda *si = netdev_priv(dev);\r\nint status;\r\nstatus = Ser2UTSR0;\r\nwhile (status & UTSR0_EIF) {\r\nint stat, data;\r\nstat = Ser2UTSR1;\r\ndata = Ser2UTDR;\r\nif (stat & (UTSR1_FRE | UTSR1_ROR)) {\r\ndev->stats.rx_errors++;\r\nif (stat & UTSR1_FRE)\r\ndev->stats.rx_frame_errors++;\r\nif (stat & UTSR1_ROR)\r\ndev->stats.rx_fifo_errors++;\r\n} else\r\nasync_unwrap_char(dev, &dev->stats, &si->rx_buff, data);\r\nstatus = Ser2UTSR0;\r\n}\r\nSer2UTSR0 = status & (UTSR0_RID | UTSR0_RBB | UTSR0_REB);\r\nif (status & UTSR0_RFS) {\r\nasync_unwrap_char(dev, &dev->stats, &si->rx_buff, Ser2UTDR);\r\nasync_unwrap_char(dev, &dev->stats, &si->rx_buff, Ser2UTDR);\r\nasync_unwrap_char(dev, &dev->stats, &si->rx_buff, Ser2UTDR);\r\n}\r\nif (status & (UTSR0_RFS | UTSR0_RID)) {\r\ndo {\r\nasync_unwrap_char(dev, &dev->stats, &si->rx_buff,\r\nSer2UTDR);\r\n} while (Ser2UTSR1 & UTSR1_RNE);\r\n}\r\nif (status & UTSR0_TFS && si->tx_buff.len) {\r\ndo {\r\nSer2UTDR = *si->tx_buff.data++;\r\nsi->tx_buff.len -= 1;\r\n} while (Ser2UTSR1 & UTSR1_TNF && si->tx_buff.len);\r\nif (si->tx_buff.len == 0) {\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += si->tx_buff.data -\r\nsi->tx_buff.head;\r\ndo\r\nrmb();\r\nwhile (Ser2UTSR1 & UTSR1_TBY);\r\nSer2UTSR0 = UTSR0_REB | UTSR0_RBB | UTSR0_RID;\r\nSer2UTCR3 = UTCR3_RIE | UTCR3_RXE | UTCR3_TXE;\r\nif (si->newspeed) {\r\nsa1100_irda_set_speed(si, si->newspeed);\r\nsi->newspeed = 0;\r\n}\r\nnetif_wake_queue(dev);\r\n}\r\n}\r\n}\r\nstatic void sa1100_irda_fir_error(struct sa1100_irda *si, struct net_device *dev)\r\n{\r\nstruct sk_buff *skb = si->rxskb;\r\ndma_addr_t dma_addr;\r\nunsigned int len, stat, data;\r\nif (!skb) {\r\nprintk(KERN_ERR "sa1100_ir: SKB is NULL!\n");\r\nreturn;\r\n}\r\ndma_addr = sa1100_get_dma_pos(si->rxdma);\r\nlen = dma_addr - si->rxbuf_dma;\r\nif (len > HPSIR_MAX_RXLEN)\r\nlen = HPSIR_MAX_RXLEN;\r\ndma_unmap_single(si->dev, si->rxbuf_dma, len, DMA_FROM_DEVICE);\r\ndo {\r\nstat = Ser2HSSR1;\r\nrmb();\r\ndata = Ser2HSDR;\r\nif (stat & (HSSR1_CRE | HSSR1_ROR)) {\r\ndev->stats.rx_errors++;\r\nif (stat & HSSR1_CRE)\r\ndev->stats.rx_crc_errors++;\r\nif (stat & HSSR1_ROR)\r\ndev->stats.rx_frame_errors++;\r\n} else\r\nskb->data[len++] = data;\r\nif (stat & HSSR1_EOF)\r\nbreak;\r\n} while (Ser2HSSR0 & HSSR0_EIF);\r\nif (stat & HSSR1_EOF) {\r\nsi->rxskb = NULL;\r\nskb_put(skb, len);\r\nskb->dev = dev;\r\nskb_reset_mac_header(skb);\r\nskb->protocol = htons(ETH_P_IRDA);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += len;\r\nsa1100_irda_rx_alloc(si);\r\nnetif_rx(skb);\r\n} else {\r\nsi->rxbuf_dma = dma_map_single(si->dev, si->rxskb->data,\r\nHPSIR_MAX_RXLEN,\r\nDMA_FROM_DEVICE);\r\n}\r\n}\r\nstatic void sa1100_irda_fir_irq(struct net_device *dev)\r\n{\r\nstruct sa1100_irda *si = netdev_priv(dev);\r\nsa1100_stop_dma(si->rxdma);\r\nif (Ser2HSSR0 & (HSSR0_FRE | HSSR0_RAB)) {\r\ndev->stats.rx_errors++;\r\nif (Ser2HSSR0 & HSSR0_FRE)\r\ndev->stats.rx_frame_errors++;\r\nSer2HSCR0 = si->hscr0 | HSCR0_HSSP;\r\nSer2HSSR0 = HSSR0_FRE | HSSR0_RAB;\r\n}\r\nif (Ser2HSSR0 & HSSR0_EIF)\r\nsa1100_irda_fir_error(si, dev);\r\nsa1100_irda_rx_dma_start(si);\r\n}\r\nstatic irqreturn_t sa1100_irda_irq(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nif (IS_FIR(((struct sa1100_irda *)netdev_priv(dev))))\r\nsa1100_irda_fir_irq(dev);\r\nelse\r\nsa1100_irda_hpsir_irq(dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sa1100_irda_txdma_irq(void *id)\r\n{\r\nstruct net_device *dev = id;\r\nstruct sa1100_irda *si = netdev_priv(dev);\r\nstruct sk_buff *skb = si->txskb;\r\nsi->txskb = NULL;\r\ndo\r\nrmb();\r\nwhile (!(Ser2HSSR0 & HSSR0_TUR) || Ser2HSSR1 & HSSR1_TBY);\r\nSer2HSSR0 = HSSR0_TUR;\r\nif (si->newspeed) {\r\nsa1100_irda_set_speed(si, si->newspeed);\r\nsi->newspeed = 0;\r\n}\r\nsa1100_irda_rx_dma_start(si);\r\nif (skb) {\r\ndma_unmap_single(si->dev, si->txbuf_dma, skb->len, DMA_TO_DEVICE);\r\ndev->stats.tx_packets ++;\r\ndev->stats.tx_bytes += skb->len;\r\ndev_kfree_skb_irq(skb);\r\n}\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int sa1100_irda_hard_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct sa1100_irda *si = netdev_priv(dev);\r\nint speed = irda_get_next_speed(skb);\r\nif (speed != si->speed && speed != -1)\r\nsi->newspeed = speed;\r\nif (skb->len == 0) {\r\nif (si->newspeed) {\r\nsi->newspeed = 0;\r\nsa1100_irda_set_speed(si, speed);\r\n}\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (!IS_FIR(si)) {\r\nnetif_stop_queue(dev);\r\nsi->tx_buff.data = si->tx_buff.head;\r\nsi->tx_buff.len = async_wrap_skb(skb, si->tx_buff.data,\r\nsi->tx_buff.truesize);\r\nSer2UTCR3 = UTCR3_TIE | UTCR3_TXE;\r\ndev_kfree_skb(skb);\r\n} else {\r\nint mtt = irda_get_mtt(skb);\r\nBUG_ON(si->txskb);\r\nnetif_stop_queue(dev);\r\nsi->txskb = skb;\r\nsi->txbuf_dma = dma_map_single(si->dev, skb->data,\r\nskb->len, DMA_TO_DEVICE);\r\nsa1100_start_dma(si->txdma, si->txbuf_dma, skb->len);\r\nif (mtt)\r\nudelay(mtt);\r\nSer2HSCR0 = si->hscr0 | HSCR0_HSSP | HSCR0_TXE;\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int\r\nsa1100_irda_ioctl(struct net_device *dev, struct ifreq *ifreq, int cmd)\r\n{\r\nstruct if_irda_req *rq = (struct if_irda_req *)ifreq;\r\nstruct sa1100_irda *si = netdev_priv(dev);\r\nint ret = -EOPNOTSUPP;\r\nswitch (cmd) {\r\ncase SIOCSBANDWIDTH:\r\nif (capable(CAP_NET_ADMIN)) {\r\nif (si->open) {\r\nret = sa1100_irda_set_speed(si,\r\nrq->ifr_baudrate);\r\n} else {\r\nprintk("sa1100_irda_ioctl: SIOCSBANDWIDTH: !netif_running\n");\r\nret = 0;\r\n}\r\n}\r\nbreak;\r\ncase SIOCSMEDIABUSY:\r\nret = -EPERM;\r\nif (capable(CAP_NET_ADMIN)) {\r\nirda_device_set_media_busy(dev, TRUE);\r\nret = 0;\r\n}\r\nbreak;\r\ncase SIOCGRECEIVING:\r\nrq->ifr_receiving = IS_FIR(si) ? 0\r\n: si->rx_buff.state != OUTSIDE_FRAME;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int sa1100_irda_start(struct net_device *dev)\r\n{\r\nstruct sa1100_irda *si = netdev_priv(dev);\r\nint err;\r\nsi->speed = 9600;\r\nerr = request_irq(dev->irq, sa1100_irda_irq, 0, dev->name, dev);\r\nif (err)\r\ngoto err_irq;\r\nerr = sa1100_request_dma(DMA_Ser2HSSPRd, "IrDA receive",\r\nNULL, NULL, &si->rxdma);\r\nif (err)\r\ngoto err_rx_dma;\r\nerr = sa1100_request_dma(DMA_Ser2HSSPWr, "IrDA transmit",\r\nsa1100_irda_txdma_irq, dev, &si->txdma);\r\nif (err)\r\ngoto err_tx_dma;\r\ndisable_irq(dev->irq);\r\nerr = sa1100_irda_startup(si);\r\nif (err)\r\ngoto err_startup;\r\nsi->irlap = irlap_open(dev, &si->qos, "sa1100");\r\nerr = -ENOMEM;\r\nif (!si->irlap)\r\ngoto err_irlap;\r\nsi->open = 1;\r\nsa1100_set_power(si, power_level);\r\nenable_irq(dev->irq);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\nerr_irlap:\r\nsi->open = 0;\r\nsa1100_irda_shutdown(si);\r\nerr_startup:\r\nsa1100_free_dma(si->txdma);\r\nerr_tx_dma:\r\nsa1100_free_dma(si->rxdma);\r\nerr_rx_dma:\r\nfree_irq(dev->irq, dev);\r\nerr_irq:\r\nreturn err;\r\n}\r\nstatic int sa1100_irda_stop(struct net_device *dev)\r\n{\r\nstruct sa1100_irda *si = netdev_priv(dev);\r\ndisable_irq(dev->irq);\r\nsa1100_irda_shutdown(si);\r\nif (si->rxskb) {\r\ndma_unmap_single(si->dev, si->rxbuf_dma, HPSIR_MAX_RXLEN,\r\nDMA_FROM_DEVICE);\r\ndev_kfree_skb(si->rxskb);\r\nsi->rxskb = NULL;\r\n}\r\nif (si->irlap) {\r\nirlap_close(si->irlap);\r\nsi->irlap = NULL;\r\n}\r\nnetif_stop_queue(dev);\r\nsi->open = 0;\r\nsa1100_free_dma(si->txdma);\r\nsa1100_free_dma(si->rxdma);\r\nfree_irq(dev->irq, dev);\r\nsa1100_set_power(si, 0);\r\nreturn 0;\r\n}\r\nstatic int sa1100_irda_init_iobuf(iobuff_t *io, int size)\r\n{\r\nio->head = kmalloc(size, GFP_KERNEL | GFP_DMA);\r\nif (io->head != NULL) {\r\nio->truesize = size;\r\nio->in_frame = FALSE;\r\nio->state = OUTSIDE_FRAME;\r\nio->data = io->head;\r\n}\r\nreturn io->head ? 0 : -ENOMEM;\r\n}\r\nstatic int sa1100_irda_probe(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev;\r\nstruct sa1100_irda *si;\r\nunsigned int baudrate_mask;\r\nint err;\r\nif (!pdev->dev.platform_data)\r\nreturn -EINVAL;\r\nerr = request_mem_region(__PREG(Ser2UTCR0), 0x24, "IrDA") ? 0 : -EBUSY;\r\nif (err)\r\ngoto err_mem_1;\r\nerr = request_mem_region(__PREG(Ser2HSCR0), 0x1c, "IrDA") ? 0 : -EBUSY;\r\nif (err)\r\ngoto err_mem_2;\r\nerr = request_mem_region(__PREG(Ser2HSCR2), 0x04, "IrDA") ? 0 : -EBUSY;\r\nif (err)\r\ngoto err_mem_3;\r\ndev = alloc_irdadev(sizeof(struct sa1100_irda));\r\nif (!dev)\r\ngoto err_mem_4;\r\nsi = netdev_priv(dev);\r\nsi->dev = &pdev->dev;\r\nsi->pdata = pdev->dev.platform_data;\r\nerr = sa1100_irda_init_iobuf(&si->rx_buff, 14384);\r\nif (err)\r\ngoto err_mem_5;\r\nerr = sa1100_irda_init_iobuf(&si->tx_buff, 4000);\r\nif (err)\r\ngoto err_mem_5;\r\ndev->netdev_ops = &sa1100_irda_netdev_ops;\r\ndev->irq = IRQ_Ser2ICP;\r\nirda_init_max_qos_capabilies(&si->qos);\r\nbaudrate_mask = IR_9600;\r\nswitch (max_rate) {\r\ncase 4000000: baudrate_mask |= IR_4000000 << 8;\r\ncase 115200: baudrate_mask |= IR_115200;\r\ncase 57600: baudrate_mask |= IR_57600;\r\ncase 38400: baudrate_mask |= IR_38400;\r\ncase 19200: baudrate_mask |= IR_19200;\r\n}\r\nsi->qos.baud_rate.bits &= baudrate_mask;\r\nsi->qos.min_turn_time.bits = 7;\r\nirda_qos_bits_to_value(&si->qos);\r\nsi->utcr4 = UTCR4_HPSIR;\r\nif (tx_lpm)\r\nsi->utcr4 |= UTCR4_Z1_6us;\r\nSer2UTCR3 = 0;\r\nSer2UTCR4 = si->utcr4;\r\nSer2HSCR0 = HSCR0_UART;\r\nerr = register_netdev(dev);\r\nif (err == 0)\r\nplatform_set_drvdata(pdev, dev);\r\nif (err) {\r\nerr_mem_5:\r\nkfree(si->tx_buff.head);\r\nkfree(si->rx_buff.head);\r\nfree_netdev(dev);\r\nerr_mem_4:\r\nrelease_mem_region(__PREG(Ser2HSCR2), 0x04);\r\nerr_mem_3:\r\nrelease_mem_region(__PREG(Ser2HSCR0), 0x1c);\r\nerr_mem_2:\r\nrelease_mem_region(__PREG(Ser2UTCR0), 0x24);\r\n}\r\nerr_mem_1:\r\nreturn err;\r\n}\r\nstatic int sa1100_irda_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nif (dev) {\r\nstruct sa1100_irda *si = netdev_priv(dev);\r\nunregister_netdev(dev);\r\nkfree(si->tx_buff.head);\r\nkfree(si->rx_buff.head);\r\nfree_netdev(dev);\r\n}\r\nrelease_mem_region(__PREG(Ser2HSCR2), 0x04);\r\nrelease_mem_region(__PREG(Ser2HSCR0), 0x1c);\r\nrelease_mem_region(__PREG(Ser2UTCR0), 0x24);\r\nreturn 0;\r\n}\r\nstatic int __init sa1100_irda_init(void)\r\n{\r\nif (power_level < 1)\r\npower_level = 1;\r\nif (power_level > 3)\r\npower_level = 3;\r\nreturn platform_driver_register(&sa1100ir_driver);\r\n}\r\nstatic void __exit sa1100_irda_exit(void)\r\n{\r\nplatform_driver_unregister(&sa1100ir_driver);\r\n}
