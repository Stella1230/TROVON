static inline bool\r\nid_match(u_int32_t min, u_int32_t max, u_int32_t id, bool invert)\r\n{\r\nbool r;\r\npr_debug("id_match:%c 0x%x <= 0x%x <= 0x%x\n", invert ? '!' : ' ',\r\nmin, id, max);\r\nr = (id >= min && id <= max) ^ invert;\r\npr_debug(" result %s\n", r ? "PASS" : "FAILED");\r\nreturn r;\r\n}\r\nstatic bool\r\nfrag_mt6(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nstruct frag_hdr _frag;\r\nconst struct frag_hdr *fh;\r\nconst struct ip6t_frag *fraginfo = par->matchinfo;\r\nunsigned int ptr;\r\nint err;\r\nerr = ipv6_find_hdr(skb, &ptr, NEXTHDR_FRAGMENT, NULL);\r\nif (err < 0) {\r\nif (err != -ENOENT)\r\npar->hotdrop = true;\r\nreturn false;\r\n}\r\nfh = skb_header_pointer(skb, ptr, sizeof(_frag), &_frag);\r\nif (fh == NULL) {\r\npar->hotdrop = true;\r\nreturn false;\r\n}\r\npr_debug("INFO %04X ", fh->frag_off);\r\npr_debug("OFFSET %04X ", ntohs(fh->frag_off) & ~0x7);\r\npr_debug("RES %02X %04X", fh->reserved, ntohs(fh->frag_off) & 0x6);\r\npr_debug("MF %04X ", fh->frag_off & htons(IP6_MF));\r\npr_debug("ID %u %08X\n", ntohl(fh->identification),\r\nntohl(fh->identification));\r\npr_debug("IPv6 FRAG id %02X ",\r\nid_match(fraginfo->ids[0], fraginfo->ids[1],\r\nntohl(fh->identification),\r\n!!(fraginfo->invflags & IP6T_FRAG_INV_IDS)));\r\npr_debug("res %02X %02X%04X %02X ",\r\nfraginfo->flags & IP6T_FRAG_RES, fh->reserved,\r\nntohs(fh->frag_off) & 0x6,\r\n!((fraginfo->flags & IP6T_FRAG_RES) &&\r\n(fh->reserved || (ntohs(fh->frag_off) & 0x06))));\r\npr_debug("first %02X %02X %02X ",\r\nfraginfo->flags & IP6T_FRAG_FST,\r\nntohs(fh->frag_off) & ~0x7,\r\n!((fraginfo->flags & IP6T_FRAG_FST) &&\r\n(ntohs(fh->frag_off) & ~0x7)));\r\npr_debug("mf %02X %02X %02X ",\r\nfraginfo->flags & IP6T_FRAG_MF,\r\nntohs(fh->frag_off) & IP6_MF,\r\n!((fraginfo->flags & IP6T_FRAG_MF) &&\r\n!((ntohs(fh->frag_off) & IP6_MF))));\r\npr_debug("last %02X %02X %02X\n",\r\nfraginfo->flags & IP6T_FRAG_NMF,\r\nntohs(fh->frag_off) & IP6_MF,\r\n!((fraginfo->flags & IP6T_FRAG_NMF) &&\r\n(ntohs(fh->frag_off) & IP6_MF)));\r\nreturn (fh != NULL) &&\r\nid_match(fraginfo->ids[0], fraginfo->ids[1],\r\nntohl(fh->identification),\r\n!!(fraginfo->invflags & IP6T_FRAG_INV_IDS)) &&\r\n!((fraginfo->flags & IP6T_FRAG_RES) &&\r\n(fh->reserved || (ntohs(fh->frag_off) & 0x6))) &&\r\n!((fraginfo->flags & IP6T_FRAG_FST) &&\r\n(ntohs(fh->frag_off) & ~0x7)) &&\r\n!((fraginfo->flags & IP6T_FRAG_MF) &&\r\n!(ntohs(fh->frag_off) & IP6_MF)) &&\r\n!((fraginfo->flags & IP6T_FRAG_NMF) &&\r\n(ntohs(fh->frag_off) & IP6_MF));\r\n}\r\nstatic int frag_mt6_check(const struct xt_mtchk_param *par)\r\n{\r\nconst struct ip6t_frag *fraginfo = par->matchinfo;\r\nif (fraginfo->invflags & ~IP6T_FRAG_INV_MASK) {\r\npr_debug("unknown flags %X\n", fraginfo->invflags);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init frag_mt6_init(void)\r\n{\r\nreturn xt_register_match(&frag_mt6_reg);\r\n}\r\nstatic void __exit frag_mt6_exit(void)\r\n{\r\nxt_unregister_match(&frag_mt6_reg);\r\n}
