static u32 get_int_prop(struct device_node *np, const char *name, u32 def)\r\n{\r\nconst u32 *prop;\r\nint len;\r\nprop = of_get_property(np, name, &len);\r\nif (prop && len >= 4)\r\nreturn *prop;\r\nreturn def;\r\n}\r\nunsigned int pci_parse_of_flags(u32 addr0, int bridge)\r\n{\r\nunsigned int flags = 0;\r\nif (addr0 & 0x02000000) {\r\nflags = IORESOURCE_MEM | PCI_BASE_ADDRESS_SPACE_MEMORY;\r\nflags |= (addr0 >> 22) & PCI_BASE_ADDRESS_MEM_TYPE_64;\r\nflags |= (addr0 >> 28) & PCI_BASE_ADDRESS_MEM_TYPE_1M;\r\nif (addr0 & 0x40000000)\r\nflags |= IORESOURCE_PREFETCH\r\n| PCI_BASE_ADDRESS_MEM_PREFETCH;\r\nif (!bridge && (addr0 & 0xff) == 0x30)\r\nflags |= IORESOURCE_READONLY;\r\n} else if (addr0 & 0x01000000)\r\nflags = IORESOURCE_IO | PCI_BASE_ADDRESS_SPACE_IO;\r\nif (flags)\r\nflags |= IORESOURCE_SIZEALIGN;\r\nreturn flags;\r\n}\r\nstatic void of_pci_parse_addrs(struct device_node *node, struct pci_dev *dev)\r\n{\r\nu64 base, size;\r\nunsigned int flags;\r\nstruct resource *res;\r\nconst u32 *addrs;\r\nu32 i;\r\nint proplen;\r\naddrs = of_get_property(node, "assigned-addresses", &proplen);\r\nif (!addrs)\r\nreturn;\r\npr_debug(" parse addresses (%d bytes) @ %p\n", proplen, addrs);\r\nfor (; proplen >= 20; proplen -= 20, addrs += 5) {\r\nflags = pci_parse_of_flags(addrs[0], 0);\r\nif (!flags)\r\ncontinue;\r\nbase = of_read_number(&addrs[1], 2);\r\nsize = of_read_number(&addrs[3], 2);\r\nif (!size)\r\ncontinue;\r\ni = addrs[0] & 0xff;\r\npr_debug(" base: %llx, size: %llx, i: %x\n",\r\n(unsigned long long)base,\r\n(unsigned long long)size, i);\r\nif (PCI_BASE_ADDRESS_0 <= i && i <= PCI_BASE_ADDRESS_5) {\r\nres = &dev->resource[(i - PCI_BASE_ADDRESS_0) >> 2];\r\n} else if (i == dev->rom_base_reg) {\r\nres = &dev->resource[PCI_ROM_RESOURCE];\r\nflags |= IORESOURCE_READONLY | IORESOURCE_CACHEABLE;\r\n} else {\r\nprintk(KERN_ERR "PCI: bad cfg reg num 0x%x\n", i);\r\ncontinue;\r\n}\r\nres->start = base;\r\nres->end = base + size - 1;\r\nres->flags = flags;\r\nres->name = pci_name(dev);\r\n}\r\n}\r\nstruct pci_dev *of_create_pci_dev(struct device_node *node,\r\nstruct pci_bus *bus, int devfn)\r\n{\r\nstruct pci_dev *dev;\r\nconst char *type;\r\nstruct pci_slot *slot;\r\ndev = alloc_pci_dev();\r\nif (!dev)\r\nreturn NULL;\r\ntype = of_get_property(node, "device_type", NULL);\r\nif (type == NULL)\r\ntype = "";\r\npr_debug(" create device, devfn: %x, type: %s\n", devfn, type);\r\ndev->bus = bus;\r\ndev->dev.of_node = of_node_get(node);\r\ndev->dev.parent = bus->bridge;\r\ndev->dev.bus = &pci_bus_type;\r\ndev->devfn = devfn;\r\ndev->multifunction = 0;\r\ndev->needs_freset = 0;\r\nset_pcie_port_type(dev);\r\nlist_for_each_entry(slot, &dev->bus->slots, list)\r\nif (PCI_SLOT(dev->devfn) == slot->number)\r\ndev->slot = slot;\r\ndev->vendor = get_int_prop(node, "vendor-id", 0xffff);\r\ndev->device = get_int_prop(node, "device-id", 0xffff);\r\ndev->subsystem_vendor = get_int_prop(node, "subsystem-vendor-id", 0);\r\ndev->subsystem_device = get_int_prop(node, "subsystem-id", 0);\r\ndev->cfg_size = pci_cfg_space_size(dev);\r\ndev_set_name(&dev->dev, "%04x:%02x:%02x.%d", pci_domain_nr(bus),\r\ndev->bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn));\r\ndev->class = get_int_prop(node, "class-code", 0);\r\ndev->revision = get_int_prop(node, "revision-id", 0);\r\npr_debug(" class: 0x%x\n", dev->class);\r\npr_debug(" revision: 0x%x\n", dev->revision);\r\ndev->current_state = 4;\r\ndev->error_state = pci_channel_io_normal;\r\ndev->dma_mask = 0xffffffff;\r\npci_fixup_device(pci_fixup_early, dev);\r\nif (!strcmp(type, "pci") || !strcmp(type, "pciex")) {\r\ndev->hdr_type = PCI_HEADER_TYPE_BRIDGE;\r\ndev->rom_base_reg = PCI_ROM_ADDRESS1;\r\nset_pcie_hotplug_bridge(dev);\r\n} else if (!strcmp(type, "cardbus")) {\r\ndev->hdr_type = PCI_HEADER_TYPE_CARDBUS;\r\n} else {\r\ndev->hdr_type = PCI_HEADER_TYPE_NORMAL;\r\ndev->rom_base_reg = PCI_ROM_ADDRESS;\r\ndev->irq = NO_IRQ;\r\n}\r\nof_pci_parse_addrs(node, dev);\r\npr_debug(" adding to system ...\n");\r\npci_device_add(dev, bus);\r\nreturn dev;\r\n}\r\nvoid __devinit of_scan_pci_bridge(struct pci_dev *dev)\r\n{\r\nstruct device_node *node = dev->dev.of_node;\r\nstruct pci_bus *bus;\r\nconst u32 *busrange, *ranges;\r\nint len, i, mode;\r\nstruct resource *res;\r\nunsigned int flags;\r\nu64 size;\r\npr_debug("of_scan_pci_bridge(%s)\n", node->full_name);\r\nbusrange = of_get_property(node, "bus-range", &len);\r\nif (busrange == NULL || len != 8) {\r\nprintk(KERN_DEBUG "Can't get bus-range for PCI-PCI bridge %s\n",\r\nnode->full_name);\r\nreturn;\r\n}\r\nranges = of_get_property(node, "ranges", &len);\r\nif (ranges == NULL) {\r\nprintk(KERN_DEBUG "Can't get ranges for PCI-PCI bridge %s\n",\r\nnode->full_name);\r\nreturn;\r\n}\r\nbus = pci_add_new_bus(dev->bus, dev, busrange[0]);\r\nif (!bus) {\r\nprintk(KERN_ERR "Failed to create pci bus for %s\n",\r\nnode->full_name);\r\nreturn;\r\n}\r\nbus->primary = dev->bus->number;\r\nbus->subordinate = busrange[1];\r\nbus->bridge_ctl = 0;\r\nres = &dev->resource[PCI_BRIDGE_RESOURCES];\r\nfor (i = 0; i < PCI_NUM_RESOURCES - PCI_BRIDGE_RESOURCES; ++i) {\r\nres->flags = 0;\r\nbus->resource[i] = res;\r\n++res;\r\n}\r\ni = 1;\r\nfor (; len >= 32; len -= 32, ranges += 8) {\r\nflags = pci_parse_of_flags(ranges[0], 1);\r\nsize = of_read_number(&ranges[6], 2);\r\nif (flags == 0 || size == 0)\r\ncontinue;\r\nif (flags & IORESOURCE_IO) {\r\nres = bus->resource[0];\r\nif (res->flags) {\r\nprintk(KERN_ERR "PCI: ignoring extra I/O range"\r\n" for bridge %s\n", node->full_name);\r\ncontinue;\r\n}\r\n} else {\r\nif (i >= PCI_NUM_RESOURCES - PCI_BRIDGE_RESOURCES) {\r\nprintk(KERN_ERR "PCI: too many memory ranges"\r\n" for bridge %s\n", node->full_name);\r\ncontinue;\r\n}\r\nres = bus->resource[i];\r\n++i;\r\n}\r\nres->start = of_read_number(&ranges[1], 2);\r\nres->end = res->start + size - 1;\r\nres->flags = flags;\r\n}\r\nsprintf(bus->name, "PCI Bus %04x:%02x", pci_domain_nr(bus),\r\nbus->number);\r\npr_debug(" bus name: %s\n", bus->name);\r\nmode = PCI_PROBE_NORMAL;\r\nif (ppc_md.pci_probe_mode)\r\nmode = ppc_md.pci_probe_mode(bus);\r\npr_debug(" probe mode: %d\n", mode);\r\nif (mode == PCI_PROBE_DEVTREE)\r\nof_scan_bus(node, bus);\r\nelse if (mode == PCI_PROBE_NORMAL)\r\npci_scan_child_bus(bus);\r\n}\r\nstatic void __devinit __of_scan_bus(struct device_node *node,\r\nstruct pci_bus *bus, int rescan_existing)\r\n{\r\nstruct device_node *child;\r\nconst u32 *reg;\r\nint reglen, devfn;\r\nstruct pci_dev *dev;\r\npr_debug("of_scan_bus(%s) bus no %d...\n",\r\nnode->full_name, bus->number);\r\nfor_each_child_of_node(node, child) {\r\npr_debug(" * %s\n", child->full_name);\r\nif (!of_device_is_available(child))\r\ncontinue;\r\nreg = of_get_property(child, "reg", &reglen);\r\nif (reg == NULL || reglen < 20)\r\ncontinue;\r\ndevfn = (reg[0] >> 8) & 0xff;\r\ndev = of_create_pci_dev(child, bus, devfn);\r\nif (!dev)\r\ncontinue;\r\npr_debug(" dev header type: %x\n", dev->hdr_type);\r\n}\r\nif (!rescan_existing)\r\npcibios_setup_bus_self(bus);\r\npcibios_setup_bus_devices(bus);\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE ||\r\ndev->hdr_type == PCI_HEADER_TYPE_CARDBUS) {\r\nof_scan_pci_bridge(dev);\r\n}\r\n}\r\n}\r\nvoid __devinit of_scan_bus(struct device_node *node,\r\nstruct pci_bus *bus)\r\n{\r\n__of_scan_bus(node, bus, 0);\r\n}\r\nvoid __devinit of_rescan_bus(struct device_node *node,\r\nstruct pci_bus *bus)\r\n{\r\n__of_scan_bus(node, bus, 1);\r\n}
