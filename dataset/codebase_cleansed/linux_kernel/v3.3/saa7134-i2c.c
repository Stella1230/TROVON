static inline enum i2c_status i2c_get_status(struct saa7134_dev *dev)\r\n{\r\nenum i2c_status status;\r\nstatus = saa_readb(SAA7134_I2C_ATTR_STATUS) & 0x0f;\r\nd2printk(KERN_DEBUG "%s: i2c stat <= %s\n",dev->name,\r\nstr_i2c_status[status]);\r\nreturn status;\r\n}\r\nstatic inline void i2c_set_status(struct saa7134_dev *dev,\r\nenum i2c_status status)\r\n{\r\nd2printk(KERN_DEBUG "%s: i2c stat => %s\n",dev->name,\r\nstr_i2c_status[status]);\r\nsaa_andorb(SAA7134_I2C_ATTR_STATUS,0x0f,status);\r\n}\r\nstatic inline void i2c_set_attr(struct saa7134_dev *dev, enum i2c_attr attr)\r\n{\r\nd2printk(KERN_DEBUG "%s: i2c attr => %s\n",dev->name,\r\nstr_i2c_attr[attr]);\r\nsaa_andorb(SAA7134_I2C_ATTR_STATUS,0xc0,attr << 6);\r\n}\r\nstatic inline int i2c_is_error(enum i2c_status status)\r\n{\r\nswitch (status) {\r\ncase NO_DEVICE:\r\ncase NO_ACKN:\r\ncase BUS_ERR:\r\ncase ARB_LOST:\r\ncase SEQ_ERR:\r\ncase ST_ERR:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic inline int i2c_is_idle(enum i2c_status status)\r\n{\r\nswitch (status) {\r\ncase IDLE:\r\ncase DONE_STOP:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic inline int i2c_is_busy(enum i2c_status status)\r\n{\r\nswitch (status) {\r\ncase BUSY:\r\ncase TO_SCL:\r\ncase TO_ARB:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int i2c_is_busy_wait(struct saa7134_dev *dev)\r\n{\r\nenum i2c_status status;\r\nint count;\r\nfor (count = 0; count < I2C_WAIT_RETRY; count++) {\r\nstatus = i2c_get_status(dev);\r\nif (!i2c_is_busy(status))\r\nbreak;\r\nsaa_wait(I2C_WAIT_DELAY);\r\n}\r\nif (I2C_WAIT_RETRY == count)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int i2c_reset(struct saa7134_dev *dev)\r\n{\r\nenum i2c_status status;\r\nint count;\r\nd2printk(KERN_DEBUG "%s: i2c reset\n",dev->name);\r\nstatus = i2c_get_status(dev);\r\nif (!i2c_is_error(status))\r\nreturn true;\r\ni2c_set_status(dev,status);\r\nfor (count = 0; count < I2C_WAIT_RETRY; count++) {\r\nstatus = i2c_get_status(dev);\r\nif (!i2c_is_error(status))\r\nbreak;\r\nudelay(I2C_WAIT_DELAY);\r\n}\r\nif (I2C_WAIT_RETRY == count)\r\nreturn false;\r\nif (!i2c_is_idle(status))\r\nreturn false;\r\ni2c_set_attr(dev,NOP);\r\nreturn true;\r\n}\r\nstatic inline int i2c_send_byte(struct saa7134_dev *dev,\r\nenum i2c_attr attr,\r\nunsigned char data)\r\n{\r\nenum i2c_status status;\r\n__u32 dword;\r\ndword = saa_readl(SAA7134_I2C_ATTR_STATUS >> 2);\r\ndword &= 0x0f;\r\ndword |= (attr << 6);\r\ndword |= ((__u32)data << 8);\r\ndword |= 0x00 << 16;\r\ndword |= 0xf0 << 24;\r\nsaa_writel(SAA7134_I2C_ATTR_STATUS >> 2, dword);\r\nd2printk(KERN_DEBUG "%s: i2c data => 0x%x\n",dev->name,data);\r\nif (!i2c_is_busy_wait(dev))\r\nreturn -EIO;\r\nstatus = i2c_get_status(dev);\r\nif (i2c_is_error(status))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic inline int i2c_recv_byte(struct saa7134_dev *dev)\r\n{\r\nenum i2c_status status;\r\nunsigned char data;\r\ni2c_set_attr(dev,CONTINUE);\r\nif (!i2c_is_busy_wait(dev))\r\nreturn -EIO;\r\nstatus = i2c_get_status(dev);\r\nif (i2c_is_error(status))\r\nreturn -EIO;\r\ndata = saa_readb(SAA7134_I2C_DATA);\r\nd2printk(KERN_DEBUG "%s: i2c data <= 0x%x\n",dev->name,data);\r\nreturn data;\r\n}\r\nstatic int saa7134_i2c_xfer(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nstruct saa7134_dev *dev = i2c_adap->algo_data;\r\nenum i2c_status status;\r\nunsigned char data;\r\nint addr,rc,i,byte;\r\nstatus = i2c_get_status(dev);\r\nif (!i2c_is_idle(status))\r\nif (!i2c_reset(dev))\r\nreturn -EIO;\r\nd2printk("start xfer\n");\r\nd1printk(KERN_DEBUG "%s: i2c xfer:",dev->name);\r\nfor (i = 0; i < num; i++) {\r\nif (!(msgs[i].flags & I2C_M_NOSTART) || 0 == i) {\r\nd2printk("send address\n");\r\naddr = msgs[i].addr << 1;\r\nif (msgs[i].flags & I2C_M_RD)\r\naddr |= 1;\r\nif (i > 0 && msgs[i].flags & I2C_M_RD && msgs[i].addr != 0x40) {\r\nint quirk = 0xfe;\r\nd1printk(" [%02x quirk]",quirk);\r\ni2c_send_byte(dev,START,quirk);\r\ni2c_recv_byte(dev);\r\n}\r\nd1printk(" < %02x", addr);\r\nrc = i2c_send_byte(dev,START,addr);\r\nif (rc < 0)\r\ngoto err;\r\n}\r\nif (msgs[i].flags & I2C_M_RD) {\r\nd2printk("read bytes\n");\r\nfor (byte = 0; byte < msgs[i].len; byte++) {\r\nd1printk(" =");\r\nrc = i2c_recv_byte(dev);\r\nif (rc < 0)\r\ngoto err;\r\nd1printk("%02x", rc);\r\nmsgs[i].buf[byte] = rc;\r\n}\r\n} else {\r\nd2printk("write bytes\n");\r\nfor (byte = 0; byte < msgs[i].len; byte++) {\r\ndata = msgs[i].buf[byte];\r\nd1printk(" %02x", data);\r\nrc = i2c_send_byte(dev,CONTINUE,data);\r\nif (rc < 0)\r\ngoto err;\r\n}\r\n}\r\n}\r\nd2printk("xfer done\n");\r\nd1printk(" >");\r\ni2c_set_attr(dev,STOP);\r\nrc = -EIO;\r\nif (!i2c_is_busy_wait(dev))\r\ngoto err;\r\nstatus = i2c_get_status(dev);\r\nif (i2c_is_error(status))\r\ngoto err;\r\nmsleep(1);\r\nd1printk("\n");\r\nreturn num;\r\nerr:\r\nif (1 == i2c_debug) {\r\nstatus = i2c_get_status(dev);\r\nprintk(" ERROR: %s\n",str_i2c_status[status]);\r\n}\r\nreturn rc;\r\n}\r\nstatic u32 functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic int\r\nsaa7134_i2c_eeprom(struct saa7134_dev *dev, unsigned char *eedata, int len)\r\n{\r\nunsigned char buf;\r\nint i,err;\r\ndev->i2c_client.addr = 0xa0 >> 1;\r\nbuf = 0;\r\nif (1 != (err = i2c_master_send(&dev->i2c_client,&buf,1))) {\r\nprintk(KERN_INFO "%s: Huh, no eeprom present (err=%d)?\n",\r\ndev->name,err);\r\nreturn -1;\r\n}\r\nif (len != (err = i2c_master_recv(&dev->i2c_client,eedata,len))) {\r\nprintk(KERN_WARNING "%s: i2c eeprom read error (err=%d)\n",\r\ndev->name,err);\r\nreturn -1;\r\n}\r\nfor (i = 0; i < len; i++) {\r\nif (0 == (i % 16))\r\nprintk(KERN_INFO "%s: i2c eeprom %02x:",dev->name,i);\r\nprintk(" %02x",eedata[i]);\r\nif (15 == (i % 16))\r\nprintk("\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic void do_i2c_scan(char *name, struct i2c_client *c)\r\n{\r\nunsigned char buf;\r\nint i,rc;\r\nfor (i = 0; i < ARRAY_SIZE(i2c_devs); i++) {\r\nc->addr = i;\r\nrc = i2c_master_recv(c,&buf,0);\r\nif (rc < 0)\r\ncontinue;\r\nprintk("%s: i2c scan: found device @ 0x%x [%s]\n",\r\nname, i << 1, i2c_devs[i] ? i2c_devs[i] : "???");\r\n}\r\n}\r\nint saa7134_i2c_register(struct saa7134_dev *dev)\r\n{\r\ndev->i2c_adap = saa7134_adap_template;\r\ndev->i2c_adap.dev.parent = &dev->pci->dev;\r\nstrcpy(dev->i2c_adap.name,dev->name);\r\ndev->i2c_adap.algo_data = dev;\r\ni2c_set_adapdata(&dev->i2c_adap, &dev->v4l2_dev);\r\ni2c_add_adapter(&dev->i2c_adap);\r\ndev->i2c_client = saa7134_client_template;\r\ndev->i2c_client.adapter = &dev->i2c_adap;\r\nsaa7134_i2c_eeprom(dev,dev->eedata,sizeof(dev->eedata));\r\nif (i2c_scan)\r\ndo_i2c_scan(dev->name,&dev->i2c_client);\r\nsaa7134_probe_i2c_ir(dev);\r\nreturn 0;\r\n}\r\nint saa7134_i2c_unregister(struct saa7134_dev *dev)\r\n{\r\ni2c_del_adapter(&dev->i2c_adap);\r\nreturn 0;\r\n}
