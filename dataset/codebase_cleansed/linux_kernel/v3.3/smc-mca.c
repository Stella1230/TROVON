static int __init ultramca_probe(struct device *gen_dev)\r\n{\r\nunsigned short ioaddr;\r\nstruct net_device *dev;\r\nunsigned char reg4, num_pages;\r\nstruct mca_device *mca_dev = to_mca_device(gen_dev);\r\nchar slot = mca_dev->slot;\r\nunsigned char pos2 = 0xff, pos3 = 0xff, pos4 = 0xff, pos5 = 0xff;\r\nint i, rc;\r\nint adapter = mca_dev->index;\r\nint tbase = 0;\r\nint tirq = 0;\r\nint base_addr = ultra_io[ultra_found];\r\nint irq = ultra_irq[ultra_found];\r\nif (base_addr || irq) {\r\nprintk(KERN_INFO "Probing for SMC MCA adapter");\r\nif (base_addr) {\r\nprintk(KERN_INFO " at I/O address 0x%04x%c",\r\nbase_addr, irq ? ' ' : '\n');\r\n}\r\nif (irq) {\r\nprintk(KERN_INFO "using irq %d\n", irq);\r\n}\r\n}\r\ntirq = 0;\r\ntbase = 0;\r\npos2 = mca_device_read_stored_pos(mca_dev, 2);\r\npos3 = mca_device_read_stored_pos(mca_dev, 3);\r\npos4 = mca_device_read_stored_pos(mca_dev, 4);\r\npos5 = mca_device_read_stored_pos(mca_dev, 5);\r\nswitch (mca_dev->index) {\r\ncase _61c8_SMC_Ethercard_PLUS_Elite_A_BNC_AUI_WD8013EP_A:\r\ncase _61c9_SMC_Ethercard_PLUS_Elite_A_UTP_AUI_WD8013EP_A:\r\ncase _efd4_IBM_PS2_Adapter_A_for_Ethernet_UTP_AUI_WD8013WP_A:\r\ncase _efd5_IBM_PS2_Adapter_A_for_Ethernet_BNC_AUI_WD8013WP_A:\r\n{\r\ntbase = addr_table[(pos2 & 0xf0) >> 4].base_addr;\r\ntirq = irq_table[(pos5 & 0xc) >> 2].new_irq;\r\nbreak;\r\n}\r\ncase _6fc0_WD_Ethercard_PLUS_A_WD8003E_A_OR_WD8003ET_A:\r\ncase _6fc1_WD_Starcard_PLUS_A_WD8003ST_A:\r\ncase _6fc2_WD_Ethercard_PLUS_10T_A_WD8003W_A:\r\ncase _efe5_IBM_PS2_Adapter_A_for_Ethernet:\r\n{\r\ntbase = ((pos2 & 0x0fe) * 0x10);\r\ntirq = irq_table[(pos5 & 3)].old_irq;\r\nbreak;\r\n}\r\n}\r\nif(!tirq || !tbase ||\r\n(irq && irq != tirq) ||\r\n(base_addr && tbase != base_addr))\r\nreturn -ENXIO;\r\ndev = alloc_ei_netdev();\r\nif(!dev)\r\nreturn -ENODEV;\r\nSET_NETDEV_DEV(dev, gen_dev);\r\nmca_device_set_name(mca_dev, smc_mca_adapter_names[adapter]);\r\nmca_device_set_claim(mca_dev, 1);\r\nprintk(KERN_INFO "smc_mca: %s found in slot %d\n",\r\nsmc_mca_adapter_names[adapter], slot + 1);\r\nultra_found++;\r\ndev->base_addr = ioaddr = mca_device_transform_ioport(mca_dev, tbase);\r\ndev->irq = mca_device_transform_irq(mca_dev, tirq);\r\ndev->mem_start = 0;\r\nnum_pages = 40;\r\nswitch (adapter) {\r\ncase _61c8_SMC_Ethercard_PLUS_Elite_A_BNC_AUI_WD8013EP_A:\r\ncase _61c9_SMC_Ethercard_PLUS_Elite_A_UTP_AUI_WD8013EP_A:\r\n{\r\nfor (i = 0; i < 16; i++) {\r\nif (mem_table[i].mem_index == (pos3 & ~MEM_MASK)) {\r\ndev->mem_start = (unsigned long)\r\nmca_device_transform_memory(mca_dev, (void *)mem_table[i].mem_start);\r\nnum_pages = mem_table[i].num_pages;\r\n}\r\n}\r\nbreak;\r\n}\r\ncase _6fc0_WD_Ethercard_PLUS_A_WD8003E_A_OR_WD8003ET_A:\r\ncase _6fc1_WD_Starcard_PLUS_A_WD8003ST_A:\r\ncase _6fc2_WD_Ethercard_PLUS_10T_A_WD8003W_A:\r\ncase _efe5_IBM_PS2_Adapter_A_for_Ethernet:\r\n{\r\ndev->mem_start = (unsigned long)\r\nmca_device_transform_memory(mca_dev, (void *)((pos3 & 0xfc) * 0x1000));\r\nnum_pages = 0x40;\r\nbreak;\r\n}\r\ncase _efd4_IBM_PS2_Adapter_A_for_Ethernet_UTP_AUI_WD8013WP_A:\r\ncase _efd5_IBM_PS2_Adapter_A_for_Ethernet_BNC_AUI_WD8013WP_A:\r\n{\r\ndev->mem_start = (unsigned long)\r\nmca_device_transform_memory(mca_dev, (void *)(0xc0000 + (0x2000 * (pos3 & 0xf))));\r\nnum_pages = 0x20 + (2 * (pos3 & 0x10));\r\nbreak;\r\n}\r\n}\r\nif (dev->mem_start == 0) {\r\nrc = -ENODEV;\r\ngoto err_unclaim;\r\n}\r\nif (!request_region(ioaddr, ULTRA_IO_EXTENT, DRV_NAME)) {\r\nrc = -ENODEV;\r\ngoto err_unclaim;\r\n}\r\nreg4 = inb(ioaddr + 4) & 0x7f;\r\noutb(reg4, ioaddr + 4);\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = inb(ioaddr + 8 + i);\r\nprintk(KERN_INFO "smc_mca[%d]: Parameters: %#3x, %pM",\r\nslot + 1, ioaddr, dev->dev_addr);\r\noutb(0x80 | reg4, ioaddr + 4);\r\noutb(0x80 | inb(ioaddr + 0x0c), ioaddr + 0x0c);\r\noutb(reg4, ioaddr + 4);\r\ndev_set_drvdata(gen_dev, dev);\r\ndev->base_addr = ioaddr + ULTRA_NIC_OFFSET;\r\nei_status.name = "SMC Ultra MCA";\r\nei_status.word16 = 1;\r\nei_status.tx_start_page = START_PG;\r\nei_status.rx_start_page = START_PG + TX_PAGES;\r\nei_status.stop_page = num_pages;\r\nei_status.mem = ioremap(dev->mem_start, (ei_status.stop_page - START_PG) * 256);\r\nif (!ei_status.mem) {\r\nrc = -ENOMEM;\r\ngoto err_release_region;\r\n}\r\ndev->mem_end = dev->mem_start + (ei_status.stop_page - START_PG) * 256;\r\nprintk(", IRQ %d memory %#lx-%#lx.\n",\r\ndev->irq, dev->mem_start, dev->mem_end - 1);\r\nei_status.reset_8390 = &ultramca_reset_8390;\r\nei_status.block_input = &ultramca_block_input;\r\nei_status.block_output = &ultramca_block_output;\r\nei_status.get_8390_hdr = &ultramca_get_8390_hdr;\r\nei_status.priv = slot;\r\ndev->netdev_ops = &ultramca_netdev_ops;\r\nNS8390_init(dev, 0);\r\nrc = register_netdev(dev);\r\nif (rc)\r\ngoto err_unmap;\r\nreturn 0;\r\nerr_unmap:\r\niounmap(ei_status.mem);\r\nerr_release_region:\r\nrelease_region(ioaddr, ULTRA_IO_EXTENT);\r\nerr_unclaim:\r\nmca_device_set_claim(mca_dev, 0);\r\nfree_netdev(dev);\r\nreturn rc;\r\n}\r\nstatic int ultramca_open(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr - ULTRA_NIC_OFFSET;\r\nint retval;\r\nif ((retval = request_irq(dev->irq, ei_interrupt, 0, dev->name, dev)))\r\nreturn retval;\r\noutb(ULTRA_MEMENB, ioaddr);\r\noutb(0x80, ioaddr + 5);\r\noutb(0x01, ioaddr + 6);\r\noutb(0x04, ioaddr + 5);\r\nei_open(dev);\r\nreturn 0;\r\n}\r\nstatic void ultramca_reset_8390(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr - ULTRA_NIC_OFFSET;\r\noutb(ULTRA_RESET, ioaddr);\r\nif (ei_debug > 1)\r\nprintk("resetting Ultra, t=%ld...", jiffies);\r\nei_status.txing = 0;\r\noutb(0x80, ioaddr + 5);\r\noutb(0x01, ioaddr + 6);\r\nif (ei_debug > 1)\r\nprintk("reset done\n");\r\n}\r\nstatic void ultramca_get_8390_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr, int ring_page)\r\n{\r\nvoid __iomem *hdr_start = ei_status.mem + ((ring_page - START_PG) << 8);\r\n#ifdef notdef\r\nmemcpy_fromio(hdr, hdr_start, sizeof(struct e8390_pkt_hdr));\r\n#else\r\n((unsigned int*)hdr)[0] = readl(hdr_start);\r\n#endif\r\n}\r\nstatic void ultramca_block_input(struct net_device *dev, int count, struct sk_buff *skb, int ring_offset)\r\n{\r\nvoid __iomem *xfer_start = ei_status.mem + ring_offset - START_PG * 256;\r\nif (ring_offset + count > ei_status.stop_page * 256) {\r\nint semi_count = ei_status.stop_page * 256 - ring_offset;\r\nmemcpy_fromio(skb->data, xfer_start, semi_count);\r\ncount -= semi_count;\r\nmemcpy_fromio(skb->data + semi_count, ei_status.mem + TX_PAGES * 256, count);\r\n} else {\r\nmemcpy_fromio(skb->data, xfer_start, count);\r\n}\r\n}\r\nstatic void ultramca_block_output(struct net_device *dev, int count, const unsigned char *buf,\r\nint start_page)\r\n{\r\nvoid __iomem *shmem = ei_status.mem + ((start_page - START_PG) << 8);\r\nmemcpy_toio(shmem, buf, count);\r\n}\r\nstatic int ultramca_close_card(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr - ULTRA_NIC_OFFSET;\r\nnetif_stop_queue(dev);\r\nif (ei_debug > 1)\r\nprintk("%s: Shutting down ethercard.\n", dev->name);\r\noutb(0x00, ioaddr + 6);\r\nfree_irq(dev->irq, dev);\r\nNS8390_init(dev, 0);\r\nreturn 0;\r\n}\r\nstatic int ultramca_remove(struct device *gen_dev)\r\n{\r\nstruct mca_device *mca_dev = to_mca_device(gen_dev);\r\nstruct net_device *dev = dev_get_drvdata(gen_dev);\r\nif (dev) {\r\nint ioaddr = dev->base_addr - ULTRA_NIC_OFFSET;\r\nunregister_netdev(dev);\r\nmca_device_set_claim(mca_dev, 0);\r\nrelease_region(ioaddr, ULTRA_IO_EXTENT);\r\niounmap(ei_status.mem);\r\nfree_netdev(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init ultramca_init_module(void)\r\n{\r\nif(!MCA_bus)\r\nreturn -ENXIO;\r\nmca_register_driver(&ultra_driver);\r\nreturn ultra_found ? 0 : -ENXIO;\r\n}\r\nstatic void __exit ultramca_cleanup_module(void)\r\n{\r\nmca_unregister_driver(&ultra_driver);\r\n}
