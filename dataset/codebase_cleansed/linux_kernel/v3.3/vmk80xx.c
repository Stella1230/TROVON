static void vmk80xx_tx_callback(struct urb *urb)\r\n{\r\nstruct vmk80xx_usb *dev = urb->context;\r\nint stat = urb->status;\r\ndbgvm("vmk80xx: %s\n", __func__);\r\nif (stat && !(stat == -ENOENT\r\n|| stat == -ECONNRESET || stat == -ESHUTDOWN))\r\ndbgcm("comedi#: vmk80xx: %s - nonzero urb status (%d)\n",\r\n__func__, stat);\r\nif (!test_bit(TRANS_OUT_BUSY, &dev->flags))\r\nreturn;\r\nclear_bit(TRANS_OUT_BUSY, &dev->flags);\r\nwake_up_interruptible(&dev->write_wait);\r\n}\r\nstatic void vmk80xx_rx_callback(struct urb *urb)\r\n{\r\nstruct vmk80xx_usb *dev = urb->context;\r\nint stat = urb->status;\r\ndbgvm("vmk80xx: %s\n", __func__);\r\nswitch (stat) {\r\ncase 0:\r\nbreak;\r\ncase -ENOENT:\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\nbreak;\r\ndefault:\r\ndbgcm("comedi#: vmk80xx: %s - nonzero urb status (%d)\n",\r\n__func__, stat);\r\ngoto resubmit;\r\n}\r\ngoto exit;\r\nresubmit:\r\nif (test_bit(TRANS_IN_RUNNING, &dev->flags) && dev->intf) {\r\nusb_anchor_urb(urb, &dev->rx_anchor);\r\nif (!usb_submit_urb(urb, GFP_KERNEL))\r\ngoto exit;\r\nerr("comedi#: vmk80xx: %s - submit urb failed\n", __func__);\r\nusb_unanchor_urb(urb);\r\n}\r\nexit:\r\nclear_bit(TRANS_IN_BUSY, &dev->flags);\r\nwake_up_interruptible(&dev->read_wait);\r\n}\r\nstatic int vmk80xx_check_data_link(struct vmk80xx_usb *dev)\r\n{\r\nunsigned int tx_pipe;\r\nunsigned int rx_pipe;\r\nunsigned char tx[1];\r\nunsigned char rx[2];\r\ndbgvm("vmk80xx: %s\n", __func__);\r\ntx_pipe = usb_sndbulkpipe(dev->udev, 0x01);\r\nrx_pipe = usb_rcvbulkpipe(dev->udev, 0x81);\r\ntx[0] = VMK8061_CMD_RD_PWR_STAT;\r\nusb_bulk_msg(dev->udev, tx_pipe, tx, 1, NULL, dev->ep_tx->bInterval);\r\nusb_bulk_msg(dev->udev, rx_pipe, rx, 2, NULL, HZ * 10);\r\nreturn (int)rx[1];\r\n}\r\nstatic void vmk80xx_read_eeprom(struct vmk80xx_usb *dev, int flag)\r\n{\r\nunsigned int tx_pipe;\r\nunsigned int rx_pipe;\r\nunsigned char tx[1];\r\nunsigned char rx[64];\r\nint cnt;\r\ndbgvm("vmk80xx: %s\n", __func__);\r\ntx_pipe = usb_sndbulkpipe(dev->udev, 0x01);\r\nrx_pipe = usb_rcvbulkpipe(dev->udev, 0x81);\r\ntx[0] = VMK8061_CMD_RD_VERSION;\r\nusb_bulk_msg(dev->udev, tx_pipe, tx, 1, NULL, dev->ep_tx->bInterval);\r\nusb_bulk_msg(dev->udev, rx_pipe, rx, 64, &cnt, HZ * 10);\r\nrx[cnt] = '\0';\r\nif (flag & IC3_VERSION)\r\nstrncpy(dev->fw.ic3_vers, rx + 1, 24);\r\nelse\r\nstrncpy(dev->fw.ic6_vers, rx + 25, 24);\r\n}\r\nstatic int vmk80xx_reset_device(struct vmk80xx_usb *dev)\r\n{\r\nstruct urb *urb;\r\nunsigned int tx_pipe;\r\nint ival;\r\nsize_t size;\r\ndbgvm("vmk80xx: %s\n", __func__);\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb)\r\nreturn -ENOMEM;\r\ntx_pipe = usb_sndintpipe(dev->udev, 0x01);\r\nival = dev->ep_tx->bInterval;\r\nsize = le16_to_cpu(dev->ep_tx->wMaxPacketSize);\r\ndev->usb_tx_buf[0] = VMK8055_CMD_RST;\r\ndev->usb_tx_buf[1] = 0x00;\r\ndev->usb_tx_buf[2] = 0x00;\r\ndev->usb_tx_buf[3] = 0x00;\r\ndev->usb_tx_buf[4] = 0x00;\r\ndev->usb_tx_buf[5] = 0x00;\r\ndev->usb_tx_buf[6] = 0x00;\r\ndev->usb_tx_buf[7] = 0x00;\r\nusb_fill_int_urb(urb, dev->udev, tx_pipe, dev->usb_tx_buf,\r\nsize, vmk80xx_tx_callback, dev, ival);\r\nusb_anchor_urb(urb, &dev->tx_anchor);\r\nreturn usb_submit_urb(urb, GFP_KERNEL);\r\n}\r\nstatic void vmk80xx_build_int_urb(struct urb *urb, int flag)\r\n{\r\nstruct vmk80xx_usb *dev = urb->context;\r\n__u8 rx_addr;\r\n__u8 tx_addr;\r\nunsigned int pipe;\r\nunsigned char *buf;\r\nsize_t size;\r\nvoid (*callback) (struct urb *);\r\nint ival;\r\ndbgvm("vmk80xx: %s\n", __func__);\r\nif (flag & URB_RCV_FLAG) {\r\nrx_addr = dev->ep_rx->bEndpointAddress;\r\npipe = usb_rcvintpipe(dev->udev, rx_addr);\r\nbuf = dev->usb_rx_buf;\r\nsize = le16_to_cpu(dev->ep_rx->wMaxPacketSize);\r\ncallback = vmk80xx_rx_callback;\r\nival = dev->ep_rx->bInterval;\r\n} else {\r\ntx_addr = dev->ep_tx->bEndpointAddress;\r\npipe = usb_sndintpipe(dev->udev, tx_addr);\r\nbuf = dev->usb_tx_buf;\r\nsize = le16_to_cpu(dev->ep_tx->wMaxPacketSize);\r\ncallback = vmk80xx_tx_callback;\r\nival = dev->ep_tx->bInterval;\r\n}\r\nusb_fill_int_urb(urb, dev->udev, pipe, buf, size, callback, dev, ival);\r\n}\r\nstatic void vmk80xx_do_bulk_msg(struct vmk80xx_usb *dev)\r\n{\r\n__u8 tx_addr;\r\n__u8 rx_addr;\r\nunsigned int tx_pipe;\r\nunsigned int rx_pipe;\r\nsize_t size;\r\ndbgvm("vmk80xx: %s\n", __func__);\r\nset_bit(TRANS_IN_BUSY, &dev->flags);\r\nset_bit(TRANS_OUT_BUSY, &dev->flags);\r\ntx_addr = dev->ep_tx->bEndpointAddress;\r\nrx_addr = dev->ep_rx->bEndpointAddress;\r\ntx_pipe = usb_sndbulkpipe(dev->udev, tx_addr);\r\nrx_pipe = usb_rcvbulkpipe(dev->udev, rx_addr);\r\nsize = le16_to_cpu(dev->ep_tx->wMaxPacketSize);\r\nusb_bulk_msg(dev->udev, tx_pipe, dev->usb_tx_buf,\r\nsize, NULL, dev->ep_tx->bInterval);\r\nusb_bulk_msg(dev->udev, rx_pipe, dev->usb_rx_buf, size, NULL, HZ * 10);\r\nclear_bit(TRANS_OUT_BUSY, &dev->flags);\r\nclear_bit(TRANS_IN_BUSY, &dev->flags);\r\n}\r\nstatic int vmk80xx_read_packet(struct vmk80xx_usb *dev)\r\n{\r\nstruct urb *urb;\r\nint retval;\r\ndbgvm("vmk80xx: %s\n", __func__);\r\nif (!dev->intf)\r\nreturn -ENODEV;\r\nif (test_bit(TRANS_IN_BUSY, &dev->flags))\r\nif (wait_event_interruptible(dev->read_wait,\r\n!test_bit(TRANS_IN_BUSY,\r\n&dev->flags)))\r\nreturn -ERESTART;\r\nif (dev->board.model == VMK8061_MODEL) {\r\nvmk80xx_do_bulk_msg(dev);\r\nreturn 0;\r\n}\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb)\r\nreturn -ENOMEM;\r\nurb->context = dev;\r\nvmk80xx_build_int_urb(urb, URB_RCV_FLAG);\r\nset_bit(TRANS_IN_RUNNING, &dev->flags);\r\nset_bit(TRANS_IN_BUSY, &dev->flags);\r\nusb_anchor_urb(urb, &dev->rx_anchor);\r\nretval = usb_submit_urb(urb, GFP_KERNEL);\r\nif (!retval)\r\ngoto exit;\r\nclear_bit(TRANS_IN_RUNNING, &dev->flags);\r\nusb_unanchor_urb(urb);\r\nexit:\r\nusb_free_urb(urb);\r\nreturn retval;\r\n}\r\nstatic int vmk80xx_write_packet(struct vmk80xx_usb *dev, int cmd)\r\n{\r\nstruct urb *urb;\r\nint retval;\r\ndbgvm("vmk80xx: %s\n", __func__);\r\nif (!dev->intf)\r\nreturn -ENODEV;\r\nif (test_bit(TRANS_OUT_BUSY, &dev->flags))\r\nif (wait_event_interruptible(dev->write_wait,\r\n!test_bit(TRANS_OUT_BUSY,\r\n&dev->flags)))\r\nreturn -ERESTART;\r\nif (dev->board.model == VMK8061_MODEL) {\r\ndev->usb_tx_buf[0] = cmd;\r\nvmk80xx_do_bulk_msg(dev);\r\nreturn 0;\r\n}\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb)\r\nreturn -ENOMEM;\r\nurb->context = dev;\r\nvmk80xx_build_int_urb(urb, URB_SND_FLAG);\r\nset_bit(TRANS_OUT_BUSY, &dev->flags);\r\nusb_anchor_urb(urb, &dev->tx_anchor);\r\ndev->usb_tx_buf[0] = cmd;\r\nretval = usb_submit_urb(urb, GFP_KERNEL);\r\nif (!retval)\r\ngoto exit;\r\nclear_bit(TRANS_OUT_BUSY, &dev->flags);\r\nusb_unanchor_urb(urb);\r\nexit:\r\nusb_free_urb(urb);\r\nreturn retval;\r\n}\r\nstatic int rudimentary_check(struct vmk80xx_usb *dev, int dir)\r\n{\r\nif (!dev)\r\nreturn -EFAULT;\r\nif (!dev->probed)\r\nreturn -ENODEV;\r\nif (!dev->attached)\r\nreturn -ENODEV;\r\nif (dir & DIR_IN) {\r\nif (test_bit(TRANS_IN_BUSY, &dev->flags))\r\nreturn -EBUSY;\r\n}\r\nif (dir & DIR_OUT) {\r\nif (test_bit(TRANS_OUT_BUSY, &dev->flags))\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vmk80xx_ai_rinsn(struct comedi_device *cdev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct vmk80xx_usb *dev = cdev->private;\r\nint chan;\r\nint reg[2];\r\nint n;\r\ndbgvm("vmk80xx: %s\n", __func__);\r\nn = rudimentary_check(dev, DIR_IN);\r\nif (n)\r\nreturn n;\r\ndown(&dev->limit_sem);\r\nchan = CR_CHAN(insn->chanspec);\r\nswitch (dev->board.model) {\r\ncase VMK8055_MODEL:\r\nif (!chan)\r\nreg[0] = VMK8055_AI1_REG;\r\nelse\r\nreg[0] = VMK8055_AI2_REG;\r\nbreak;\r\ncase VMK8061_MODEL:\r\nreg[0] = VMK8061_AI_REG1;\r\nreg[1] = VMK8061_AI_REG2;\r\ndev->usb_tx_buf[0] = VMK8061_CMD_RD_AI;\r\ndev->usb_tx_buf[VMK8061_CH_REG] = chan;\r\nbreak;\r\n}\r\nfor (n = 0; n < insn->n; n++) {\r\nif (vmk80xx_read_packet(dev))\r\nbreak;\r\nif (dev->board.model == VMK8055_MODEL) {\r\ndata[n] = dev->usb_rx_buf[reg[0]];\r\ncontinue;\r\n}\r\ndata[n] = dev->usb_rx_buf[reg[0]] + 256 *\r\ndev->usb_rx_buf[reg[1]];\r\n}\r\nup(&dev->limit_sem);\r\nreturn n;\r\n}\r\nstatic int vmk80xx_ao_winsn(struct comedi_device *cdev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct vmk80xx_usb *dev = cdev->private;\r\nint chan;\r\nint cmd;\r\nint reg;\r\nint n;\r\ndbgvm("vmk80xx: %s\n", __func__);\r\nn = rudimentary_check(dev, DIR_OUT);\r\nif (n)\r\nreturn n;\r\ndown(&dev->limit_sem);\r\nchan = CR_CHAN(insn->chanspec);\r\nswitch (dev->board.model) {\r\ncase VMK8055_MODEL:\r\ncmd = VMK8055_CMD_WRT_AD;\r\nif (!chan)\r\nreg = VMK8055_AO1_REG;\r\nelse\r\nreg = VMK8055_AO2_REG;\r\nbreak;\r\ndefault:\r\ncmd = VMK8061_CMD_SET_AO;\r\nreg = VMK8061_AO_REG;\r\ndev->usb_tx_buf[VMK8061_CH_REG] = chan;\r\nbreak;\r\n}\r\nfor (n = 0; n < insn->n; n++) {\r\ndev->usb_tx_buf[reg] = data[n];\r\nif (vmk80xx_write_packet(dev, cmd))\r\nbreak;\r\n}\r\nup(&dev->limit_sem);\r\nreturn n;\r\n}\r\nstatic int vmk80xx_ao_rinsn(struct comedi_device *cdev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct vmk80xx_usb *dev = cdev->private;\r\nint chan;\r\nint reg;\r\nint n;\r\ndbgvm("vmk80xx: %s\n", __func__);\r\nn = rudimentary_check(dev, DIR_IN);\r\nif (n)\r\nreturn n;\r\ndown(&dev->limit_sem);\r\nchan = CR_CHAN(insn->chanspec);\r\nreg = VMK8061_AO_REG - 1;\r\ndev->usb_tx_buf[0] = VMK8061_CMD_RD_AO;\r\nfor (n = 0; n < insn->n; n++) {\r\nif (vmk80xx_read_packet(dev))\r\nbreak;\r\ndata[n] = dev->usb_rx_buf[reg + chan];\r\n}\r\nup(&dev->limit_sem);\r\nreturn n;\r\n}\r\nstatic int vmk80xx_di_bits(struct comedi_device *cdev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct vmk80xx_usb *dev = cdev->private;\r\nunsigned char *rx_buf;\r\nint reg;\r\nint retval;\r\ndbgvm("vmk80xx: %s\n", __func__);\r\nretval = rudimentary_check(dev, DIR_IN);\r\nif (retval)\r\nreturn retval;\r\ndown(&dev->limit_sem);\r\nrx_buf = dev->usb_rx_buf;\r\nif (dev->board.model == VMK8061_MODEL) {\r\nreg = VMK8061_DI_REG;\r\ndev->usb_tx_buf[0] = VMK8061_CMD_RD_DI;\r\n} else {\r\nreg = VMK8055_DI_REG;\r\n}\r\nretval = vmk80xx_read_packet(dev);\r\nif (!retval) {\r\nif (dev->board.model == VMK8055_MODEL)\r\ndata[1] = (((rx_buf[reg] >> 4) & 0x03) |\r\n((rx_buf[reg] << 2) & 0x04) |\r\n((rx_buf[reg] >> 3) & 0x18));\r\nelse\r\ndata[1] = rx_buf[reg];\r\nretval = 2;\r\n}\r\nup(&dev->limit_sem);\r\nreturn retval;\r\n}\r\nstatic int vmk80xx_di_rinsn(struct comedi_device *cdev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct vmk80xx_usb *dev = cdev->private;\r\nint chan;\r\nunsigned char *rx_buf;\r\nint reg;\r\nint inp;\r\nint n;\r\ndbgvm("vmk80xx: %s\n", __func__);\r\nn = rudimentary_check(dev, DIR_IN);\r\nif (n)\r\nreturn n;\r\ndown(&dev->limit_sem);\r\nchan = CR_CHAN(insn->chanspec);\r\nrx_buf = dev->usb_rx_buf;\r\nif (dev->board.model == VMK8061_MODEL) {\r\nreg = VMK8061_DI_REG;\r\ndev->usb_tx_buf[0] = VMK8061_CMD_RD_DI;\r\n} else {\r\nreg = VMK8055_DI_REG;\r\n}\r\nfor (n = 0; n < insn->n; n++) {\r\nif (vmk80xx_read_packet(dev))\r\nbreak;\r\nif (dev->board.model == VMK8055_MODEL)\r\ninp = (((rx_buf[reg] >> 4) & 0x03) |\r\n((rx_buf[reg] << 2) & 0x04) |\r\n((rx_buf[reg] >> 3) & 0x18));\r\nelse\r\ninp = rx_buf[reg];\r\ndata[n] = (inp >> chan) & 1;\r\n}\r\nup(&dev->limit_sem);\r\nreturn n;\r\n}\r\nstatic int vmk80xx_do_winsn(struct comedi_device *cdev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct vmk80xx_usb *dev = cdev->private;\r\nint chan;\r\nunsigned char *tx_buf;\r\nint reg;\r\nint cmd;\r\nint n;\r\ndbgvm("vmk80xx: %s\n", __func__);\r\nn = rudimentary_check(dev, DIR_OUT);\r\nif (n)\r\nreturn n;\r\ndown(&dev->limit_sem);\r\nchan = CR_CHAN(insn->chanspec);\r\ntx_buf = dev->usb_tx_buf;\r\nfor (n = 0; n < insn->n; n++) {\r\nif (dev->board.model == VMK8055_MODEL) {\r\nreg = VMK8055_DO_REG;\r\ncmd = VMK8055_CMD_WRT_AD;\r\nif (data[n] == 1)\r\ntx_buf[reg] |= (1 << chan);\r\nelse\r\ntx_buf[reg] ^= (1 << chan);\r\n} else {\r\nreg = VMK8061_DO_REG;\r\nif (data[n] == 1) {\r\ncmd = VMK8061_CMD_SET_DO;\r\ntx_buf[reg] = 1 << chan;\r\n} else {\r\ncmd = VMK8061_CMD_CLR_DO;\r\ntx_buf[reg] = 0xff - (1 << chan);\r\n}\r\n}\r\nif (vmk80xx_write_packet(dev, cmd))\r\nbreak;\r\n}\r\nup(&dev->limit_sem);\r\nreturn n;\r\n}\r\nstatic int vmk80xx_do_rinsn(struct comedi_device *cdev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct vmk80xx_usb *dev = cdev->private;\r\nint chan;\r\nint reg;\r\nint n;\r\ndbgvm("vmk80xx: %s\n", __func__);\r\nn = rudimentary_check(dev, DIR_IN);\r\nif (n)\r\nreturn n;\r\ndown(&dev->limit_sem);\r\nchan = CR_CHAN(insn->chanspec);\r\nreg = VMK8061_DO_REG;\r\ndev->usb_tx_buf[0] = VMK8061_CMD_RD_DO;\r\nfor (n = 0; n < insn->n; n++) {\r\nif (vmk80xx_read_packet(dev))\r\nbreak;\r\ndata[n] = (dev->usb_rx_buf[reg] >> chan) & 1;\r\n}\r\nup(&dev->limit_sem);\r\nreturn n;\r\n}\r\nstatic int vmk80xx_do_bits(struct comedi_device *cdev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct vmk80xx_usb *dev = cdev->private;\r\nunsigned char *rx_buf, *tx_buf;\r\nint dir, reg, cmd;\r\nint retval;\r\ndbgvm("vmk80xx: %s\n", __func__);\r\ndir = 0;\r\nif (data[0])\r\ndir |= DIR_OUT;\r\nif (dev->board.model == VMK8061_MODEL)\r\ndir |= DIR_IN;\r\nretval = rudimentary_check(dev, dir);\r\nif (retval)\r\nreturn retval;\r\ndown(&dev->limit_sem);\r\nrx_buf = dev->usb_rx_buf;\r\ntx_buf = dev->usb_tx_buf;\r\nif (data[0]) {\r\nif (dev->board.model == VMK8055_MODEL) {\r\nreg = VMK8055_DO_REG;\r\ncmd = VMK8055_CMD_WRT_AD;\r\n} else {\r\nreg = VMK8061_DO_REG;\r\ncmd = VMK8061_CMD_DO;\r\n}\r\ntx_buf[reg] &= ~data[0];\r\ntx_buf[reg] |= (data[0] & data[1]);\r\nretval = vmk80xx_write_packet(dev, cmd);\r\nif (retval)\r\ngoto out;\r\n}\r\nif (dev->board.model == VMK8061_MODEL) {\r\nreg = VMK8061_DO_REG;\r\ntx_buf[0] = VMK8061_CMD_RD_DO;\r\nretval = vmk80xx_read_packet(dev);\r\nif (!retval) {\r\ndata[1] = rx_buf[reg];\r\nretval = 2;\r\n}\r\n} else {\r\ndata[1] = tx_buf[reg];\r\nretval = 2;\r\n}\r\nout:\r\nup(&dev->limit_sem);\r\nreturn retval;\r\n}\r\nstatic int vmk80xx_cnt_rinsn(struct comedi_device *cdev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct vmk80xx_usb *dev = cdev->private;\r\nint chan;\r\nint reg[2];\r\nint n;\r\ndbgvm("vmk80xx: %s\n", __func__);\r\nn = rudimentary_check(dev, DIR_IN);\r\nif (n)\r\nreturn n;\r\ndown(&dev->limit_sem);\r\nchan = CR_CHAN(insn->chanspec);\r\nswitch (dev->board.model) {\r\ncase VMK8055_MODEL:\r\nif (!chan)\r\nreg[0] = VMK8055_CNT1_REG;\r\nelse\r\nreg[0] = VMK8055_CNT2_REG;\r\nbreak;\r\ncase VMK8061_MODEL:\r\nreg[0] = VMK8061_CNT_REG;\r\nreg[1] = VMK8061_CNT_REG;\r\ndev->usb_tx_buf[0] = VMK8061_CMD_RD_CNT;\r\nbreak;\r\n}\r\nfor (n = 0; n < insn->n; n++) {\r\nif (vmk80xx_read_packet(dev))\r\nbreak;\r\nif (dev->board.model == VMK8055_MODEL)\r\ndata[n] = dev->usb_rx_buf[reg[0]];\r\nelse\r\ndata[n] = dev->usb_rx_buf[reg[0] * (chan + 1) + 1]\r\n+ 256 * dev->usb_rx_buf[reg[1] * 2 + 2];\r\n}\r\nup(&dev->limit_sem);\r\nreturn n;\r\n}\r\nstatic int vmk80xx_cnt_cinsn(struct comedi_device *cdev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct vmk80xx_usb *dev = cdev->private;\r\nunsigned int insn_cmd;\r\nint chan;\r\nint cmd;\r\nint reg;\r\nint n;\r\ndbgvm("vmk80xx: %s\n", __func__);\r\nn = rudimentary_check(dev, DIR_OUT);\r\nif (n)\r\nreturn n;\r\ndown(&dev->limit_sem);\r\ninsn_cmd = data[0];\r\nif (insn_cmd != INSN_CONFIG_RESET && insn_cmd != GPCT_RESET)\r\nreturn -EINVAL;\r\nchan = CR_CHAN(insn->chanspec);\r\nif (dev->board.model == VMK8055_MODEL) {\r\nif (!chan) {\r\ncmd = VMK8055_CMD_RST_CNT1;\r\nreg = VMK8055_CNT1_REG;\r\n} else {\r\ncmd = VMK8055_CMD_RST_CNT2;\r\nreg = VMK8055_CNT2_REG;\r\n}\r\ndev->usb_tx_buf[reg] = 0x00;\r\n} else {\r\ncmd = VMK8061_CMD_RST_CNT;\r\n}\r\nfor (n = 0; n < insn->n; n++)\r\nif (vmk80xx_write_packet(dev, cmd))\r\nbreak;\r\nup(&dev->limit_sem);\r\nreturn n;\r\n}\r\nstatic int vmk80xx_cnt_winsn(struct comedi_device *cdev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct vmk80xx_usb *dev = cdev->private;\r\nunsigned long debtime;\r\nunsigned long val;\r\nint chan;\r\nint cmd;\r\nint n;\r\ndbgvm("vmk80xx: %s\n", __func__);\r\nn = rudimentary_check(dev, DIR_OUT);\r\nif (n)\r\nreturn n;\r\ndown(&dev->limit_sem);\r\nchan = CR_CHAN(insn->chanspec);\r\nif (!chan)\r\ncmd = VMK8055_CMD_DEB1_TIME;\r\nelse\r\ncmd = VMK8055_CMD_DEB2_TIME;\r\nfor (n = 0; n < insn->n; n++) {\r\ndebtime = data[n];\r\nif (debtime == 0)\r\ndebtime = 1;\r\nif (debtime > 7450)\r\ndebtime = 7450;\r\nval = int_sqrt(debtime * 1000 / 115);\r\nif (((val + 1) * val) < debtime * 1000 / 115)\r\nval += 1;\r\ndev->usb_tx_buf[6 + chan] = val;\r\nif (vmk80xx_write_packet(dev, cmd))\r\nbreak;\r\n}\r\nup(&dev->limit_sem);\r\nreturn n;\r\n}\r\nstatic int vmk80xx_pwm_rinsn(struct comedi_device *cdev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct vmk80xx_usb *dev = cdev->private;\r\nint reg[2];\r\nint n;\r\ndbgvm("vmk80xx: %s\n", __func__);\r\nn = rudimentary_check(dev, DIR_IN);\r\nif (n)\r\nreturn n;\r\ndown(&dev->limit_sem);\r\nreg[0] = VMK8061_PWM_REG1;\r\nreg[1] = VMK8061_PWM_REG2;\r\ndev->usb_tx_buf[0] = VMK8061_CMD_RD_PWM;\r\nfor (n = 0; n < insn->n; n++) {\r\nif (vmk80xx_read_packet(dev))\r\nbreak;\r\ndata[n] = dev->usb_rx_buf[reg[0]] + 4 * dev->usb_rx_buf[reg[1]];\r\n}\r\nup(&dev->limit_sem);\r\nreturn n;\r\n}\r\nstatic int vmk80xx_pwm_winsn(struct comedi_device *cdev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct vmk80xx_usb *dev = cdev->private;\r\nunsigned char *tx_buf;\r\nint reg[2];\r\nint cmd;\r\nint n;\r\ndbgvm("vmk80xx: %s\n", __func__);\r\nn = rudimentary_check(dev, DIR_OUT);\r\nif (n)\r\nreturn n;\r\ndown(&dev->limit_sem);\r\ntx_buf = dev->usb_tx_buf;\r\nreg[0] = VMK8061_PWM_REG1;\r\nreg[1] = VMK8061_PWM_REG2;\r\ncmd = VMK8061_CMD_OUT_PWM;\r\nfor (n = 0; n < insn->n; n++) {\r\ntx_buf[reg[0]] = (unsigned char)(data[n] & 0x03);\r\ntx_buf[reg[1]] = (unsigned char)(data[n] >> 2) & 0xff;\r\nif (vmk80xx_write_packet(dev, cmd))\r\nbreak;\r\n}\r\nup(&dev->limit_sem);\r\nreturn n;\r\n}\r\nstatic int vmk80xx_attach(struct comedi_device *cdev,\r\nstruct comedi_devconfig *it)\r\n{\r\nint i;\r\nstruct vmk80xx_usb *dev;\r\nint n_subd;\r\nstruct comedi_subdevice *s;\r\nint minor;\r\ndbgvm("vmk80xx: %s\n", __func__);\r\nmutex_lock(&glb_mutex);\r\nfor (i = 0; i < VMK80XX_MAX_BOARDS; i++)\r\nif (vmb[i].probed && !vmb[i].attached)\r\nbreak;\r\nif (i == VMK80XX_MAX_BOARDS) {\r\nmutex_unlock(&glb_mutex);\r\nreturn -ENODEV;\r\n}\r\ndev = &vmb[i];\r\ndown(&dev->limit_sem);\r\ncdev->board_name = dev->board.name;\r\ncdev->private = dev;\r\nif (dev->board.model == VMK8055_MODEL)\r\nn_subd = 5;\r\nelse\r\nn_subd = 6;\r\nif (alloc_subdevices(cdev, n_subd) < 0) {\r\nup(&dev->limit_sem);\r\nmutex_unlock(&glb_mutex);\r\nreturn -ENOMEM;\r\n}\r\ns = cdev->subdevices + VMK80XX_SUBD_AI;\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND;\r\ns->n_chan = dev->board.ai_chans;\r\ns->maxdata = (1 << dev->board.ai_bits) - 1;\r\ns->range_table = dev->board.range;\r\ns->insn_read = vmk80xx_ai_rinsn;\r\ns = cdev->subdevices + VMK80XX_SUBD_AO;\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITEABLE | SDF_GROUND;\r\ns->n_chan = dev->board.ao_chans;\r\ns->maxdata = (1 << dev->board.ao_bits) - 1;\r\ns->range_table = dev->board.range;\r\ns->insn_write = vmk80xx_ao_winsn;\r\nif (dev->board.model == VMK8061_MODEL) {\r\ns->subdev_flags |= SDF_READABLE;\r\ns->insn_read = vmk80xx_ao_rinsn;\r\n}\r\ns = cdev->subdevices + VMK80XX_SUBD_DI;\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND;\r\ns->n_chan = dev->board.di_chans;\r\ns->maxdata = 1;\r\ns->insn_read = vmk80xx_di_rinsn;\r\ns->insn_bits = vmk80xx_di_bits;\r\ns = cdev->subdevices + VMK80XX_SUBD_DO;\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITEABLE | SDF_GROUND;\r\ns->n_chan = dev->board.do_chans;\r\ns->maxdata = 1;\r\ns->insn_write = vmk80xx_do_winsn;\r\ns->insn_bits = vmk80xx_do_bits;\r\nif (dev->board.model == VMK8061_MODEL) {\r\ns->subdev_flags |= SDF_READABLE;\r\ns->insn_read = vmk80xx_do_rinsn;\r\n}\r\ns = cdev->subdevices + VMK80XX_SUBD_CNT;\r\ns->type = COMEDI_SUBD_COUNTER;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = dev->board.cnt_chans;\r\ns->insn_read = vmk80xx_cnt_rinsn;\r\ns->insn_config = vmk80xx_cnt_cinsn;\r\nif (dev->board.model == VMK8055_MODEL) {\r\ns->subdev_flags |= SDF_WRITEABLE;\r\ns->maxdata = (1 << dev->board.cnt_bits) - 1;\r\ns->insn_write = vmk80xx_cnt_winsn;\r\n}\r\nif (dev->board.model == VMK8061_MODEL) {\r\ns = cdev->subdevices + VMK80XX_SUBD_PWM;\r\ns->type = COMEDI_SUBD_PWM;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITEABLE;\r\ns->n_chan = dev->board.pwm_chans;\r\ns->maxdata = (1 << dev->board.pwm_bits) - 1;\r\ns->insn_read = vmk80xx_pwm_rinsn;\r\ns->insn_write = vmk80xx_pwm_winsn;\r\n}\r\ndev->attached = 1;\r\nminor = cdev->minor;\r\nprintk(KERN_INFO\r\n"comedi%d: vmk80xx: board #%d [%s] attached to comedi\n",\r\nminor, dev->count, dev->board.name);\r\nup(&dev->limit_sem);\r\nmutex_unlock(&glb_mutex);\r\nreturn 0;\r\n}\r\nstatic int vmk80xx_detach(struct comedi_device *cdev)\r\n{\r\nstruct vmk80xx_usb *dev;\r\nint minor;\r\ndbgvm("vmk80xx: %s\n", __func__);\r\nif (!cdev)\r\nreturn -EFAULT;\r\ndev = cdev->private;\r\nif (!dev)\r\nreturn -EFAULT;\r\ndown(&dev->limit_sem);\r\ncdev->private = NULL;\r\ndev->attached = 0;\r\nminor = cdev->minor;\r\nprintk(KERN_INFO\r\n"comedi%d: vmk80xx: board #%d [%s] detached from comedi\n",\r\nminor, dev->count, dev->board.name);\r\nup(&dev->limit_sem);\r\nreturn 0;\r\n}\r\nstatic int vmk80xx_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nint i;\r\nstruct vmk80xx_usb *dev;\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *ep_desc;\r\nsize_t size;\r\ndbgvm("vmk80xx: %s\n", __func__);\r\nmutex_lock(&glb_mutex);\r\nfor (i = 0; i < VMK80XX_MAX_BOARDS; i++)\r\nif (!vmb[i].probed)\r\nbreak;\r\nif (i == VMK80XX_MAX_BOARDS) {\r\nmutex_unlock(&glb_mutex);\r\nreturn -EMFILE;\r\n}\r\ndev = &vmb[i];\r\nmemset(dev, 0x00, sizeof(struct vmk80xx_usb));\r\ndev->count = i;\r\niface_desc = intf->cur_altsetting;\r\nif (iface_desc->desc.bNumEndpoints != 2)\r\ngoto error;\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {\r\nep_desc = &iface_desc->endpoint[i].desc;\r\nif (usb_endpoint_is_int_in(ep_desc)) {\r\ndev->ep_rx = ep_desc;\r\ncontinue;\r\n}\r\nif (usb_endpoint_is_int_out(ep_desc)) {\r\ndev->ep_tx = ep_desc;\r\ncontinue;\r\n}\r\nif (usb_endpoint_is_bulk_in(ep_desc)) {\r\ndev->ep_rx = ep_desc;\r\ncontinue;\r\n}\r\nif (usb_endpoint_is_bulk_out(ep_desc)) {\r\ndev->ep_tx = ep_desc;\r\ncontinue;\r\n}\r\n}\r\nif (!dev->ep_rx || !dev->ep_tx)\r\ngoto error;\r\nsize = le16_to_cpu(dev->ep_rx->wMaxPacketSize);\r\ndev->usb_rx_buf = kmalloc(size, GFP_KERNEL);\r\nif (!dev->usb_rx_buf) {\r\nmutex_unlock(&glb_mutex);\r\nreturn -ENOMEM;\r\n}\r\nsize = le16_to_cpu(dev->ep_tx->wMaxPacketSize);\r\ndev->usb_tx_buf = kmalloc(size, GFP_KERNEL);\r\nif (!dev->usb_tx_buf) {\r\nkfree(dev->usb_rx_buf);\r\nmutex_unlock(&glb_mutex);\r\nreturn -ENOMEM;\r\n}\r\ndev->udev = interface_to_usbdev(intf);\r\ndev->intf = intf;\r\nsema_init(&dev->limit_sem, 8);\r\ninit_waitqueue_head(&dev->read_wait);\r\ninit_waitqueue_head(&dev->write_wait);\r\ninit_usb_anchor(&dev->rx_anchor);\r\ninit_usb_anchor(&dev->tx_anchor);\r\nusb_set_intfdata(intf, dev);\r\nswitch (id->driver_info) {\r\ncase DEVICE_VMK8055:\r\ndev->board.name = "K8055 (VM110)";\r\ndev->board.model = VMK8055_MODEL;\r\ndev->board.range = &vmk8055_range;\r\ndev->board.ai_chans = 2;\r\ndev->board.ai_bits = 8;\r\ndev->board.ao_chans = 2;\r\ndev->board.ao_bits = 8;\r\ndev->board.di_chans = 5;\r\ndev->board.di_bits = 1;\r\ndev->board.do_chans = 8;\r\ndev->board.do_bits = 1;\r\ndev->board.cnt_chans = 2;\r\ndev->board.cnt_bits = 16;\r\ndev->board.pwm_chans = 0;\r\ndev->board.pwm_bits = 0;\r\nbreak;\r\ncase DEVICE_VMK8061:\r\ndev->board.name = "K8061 (VM140)";\r\ndev->board.model = VMK8061_MODEL;\r\ndev->board.range = &vmk8061_range;\r\ndev->board.ai_chans = 8;\r\ndev->board.ai_bits = 10;\r\ndev->board.ao_chans = 8;\r\ndev->board.ao_bits = 8;\r\ndev->board.di_chans = 8;\r\ndev->board.di_bits = 1;\r\ndev->board.do_chans = 8;\r\ndev->board.do_bits = 1;\r\ndev->board.cnt_chans = 2;\r\ndev->board.cnt_bits = 0;\r\ndev->board.pwm_chans = 1;\r\ndev->board.pwm_bits = 10;\r\nbreak;\r\n}\r\nif (dev->board.model == VMK8061_MODEL) {\r\nvmk80xx_read_eeprom(dev, IC3_VERSION);\r\nprintk(KERN_INFO "comedi#: vmk80xx: %s\n", dev->fw.ic3_vers);\r\nif (vmk80xx_check_data_link(dev)) {\r\nvmk80xx_read_eeprom(dev, IC6_VERSION);\r\nprintk(KERN_INFO "comedi#: vmk80xx: %s\n",\r\ndev->fw.ic6_vers);\r\n} else {\r\ndbgcm("comedi#: vmk80xx: no conn. to CPU\n");\r\n}\r\n}\r\nif (dev->board.model == VMK8055_MODEL)\r\nvmk80xx_reset_device(dev);\r\ndev->probed = 1;\r\nprintk(KERN_INFO "comedi#: vmk80xx: board #%d [%s] now attached\n",\r\ndev->count, dev->board.name);\r\nmutex_unlock(&glb_mutex);\r\ncomedi_usb_auto_config(dev->udev, BOARDNAME);\r\nreturn 0;\r\nerror:\r\nmutex_unlock(&glb_mutex);\r\nreturn -ENODEV;\r\n}\r\nstatic void vmk80xx_disconnect(struct usb_interface *intf)\r\n{\r\nstruct vmk80xx_usb *dev = usb_get_intfdata(intf);\r\ndbgvm("vmk80xx: %s\n", __func__);\r\nif (!dev)\r\nreturn;\r\ncomedi_usb_auto_unconfig(dev->udev);\r\nmutex_lock(&glb_mutex);\r\ndown(&dev->limit_sem);\r\ndev->probed = 0;\r\nusb_set_intfdata(dev->intf, NULL);\r\nusb_kill_anchored_urbs(&dev->rx_anchor);\r\nusb_kill_anchored_urbs(&dev->tx_anchor);\r\nkfree(dev->usb_rx_buf);\r\nkfree(dev->usb_tx_buf);\r\nprintk(KERN_INFO "comedi#: vmk80xx: board #%d [%s] now detached\n",\r\ndev->count, dev->board.name);\r\nup(&dev->limit_sem);\r\nmutex_unlock(&glb_mutex);\r\n}\r\nstatic int __init vmk80xx_init(void)\r\n{\r\nint retval;\r\nprintk(KERN_INFO "vmk80xx: version 0.8.01 "\r\n"Manuel Gebele <forensixs@gmx.de>\n");\r\nretval = comedi_driver_register(&driver_vmk80xx);\r\nif (retval < 0)\r\nreturn retval;\r\nreturn usb_register(&vmk80xx_driver);\r\n}\r\nstatic void __exit vmk80xx_exit(void)\r\n{\r\ncomedi_driver_unregister(&driver_vmk80xx);\r\nusb_deregister(&vmk80xx_driver);\r\n}
