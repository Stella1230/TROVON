static void free_pending_event(struct pending_event *ev)\r\n{\r\nif (ev != NULL) {\r\nev->next = pending_event_avail;\r\npending_event_avail = ev;\r\n}\r\n}\r\nstatic int signal_event(struct pending_event *ev)\r\n{\r\nint rc = 0;\r\nunsigned long flags;\r\nint go = 1;\r\nstruct pending_event *ev1;\r\nHvLpEvent_Rc hv_rc;\r\nif (ev != NULL) {\r\nev->next = NULL;\r\nspin_lock_irqsave(&pending_event_spinlock, flags);\r\nif (pending_event_head == NULL)\r\npending_event_head = ev;\r\nelse {\r\ngo = 0;\r\npending_event_tail->next = ev;\r\n}\r\npending_event_tail = ev;\r\nspin_unlock_irqrestore(&pending_event_spinlock, flags);\r\n}\r\nwhile (go) {\r\ngo = 0;\r\nif (pending_event_head->dma_data_length > 0)\r\nHvCallEvent_dmaToSp(pending_event_head->dma_data,\r\npending_event_head->remote_address,\r\npending_event_head->dma_data_length,\r\nHvLpDma_Direction_LocalToRemote);\r\nhv_rc = HvCallEvent_signalLpEvent(\r\n&pending_event_head->event.hp_lp_event);\r\nif (hv_rc != HvLpEvent_Rc_Good) {\r\nprintk(KERN_ERR "mf.c: HvCallEvent_signalLpEvent() "\r\n"failed with %d\n", (int)hv_rc);\r\nspin_lock_irqsave(&pending_event_spinlock, flags);\r\nev1 = pending_event_head;\r\npending_event_head = pending_event_head->next;\r\nif (pending_event_head != NULL)\r\ngo = 1;\r\nspin_unlock_irqrestore(&pending_event_spinlock, flags);\r\nif (ev1 == ev)\r\nrc = -EIO;\r\nelse if (ev1->hdlr != NULL)\r\n(*ev1->hdlr)((void *)ev1->event.hp_lp_event.xCorrelationToken, -EIO);\r\nspin_lock_irqsave(&pending_event_spinlock, flags);\r\nfree_pending_event(ev1);\r\nspin_unlock_irqrestore(&pending_event_spinlock, flags);\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic struct pending_event *new_pending_event(void)\r\n{\r\nstruct pending_event *ev = NULL;\r\nHvLpIndex primary_lp = HvLpConfig_getPrimaryLpIndex();\r\nunsigned long flags;\r\nstruct HvLpEvent *hev;\r\nspin_lock_irqsave(&pending_event_spinlock, flags);\r\nif (pending_event_avail != NULL) {\r\nev = pending_event_avail;\r\npending_event_avail = pending_event_avail->next;\r\n}\r\nspin_unlock_irqrestore(&pending_event_spinlock, flags);\r\nif (ev == NULL) {\r\nev = kmalloc(sizeof(struct pending_event), GFP_ATOMIC);\r\nif (ev == NULL) {\r\nprintk(KERN_ERR "mf.c: unable to kmalloc %ld bytes\n",\r\nsizeof(struct pending_event));\r\nreturn NULL;\r\n}\r\n}\r\nmemset(ev, 0, sizeof(struct pending_event));\r\nhev = &ev->event.hp_lp_event;\r\nhev->flags = HV_LP_EVENT_VALID | HV_LP_EVENT_DO_ACK | HV_LP_EVENT_INT;\r\nhev->xType = HvLpEvent_Type_MachineFac;\r\nhev->xSourceLp = HvLpConfig_getLpIndex();\r\nhev->xTargetLp = primary_lp;\r\nhev->xSizeMinus1 = sizeof(ev->event) - 1;\r\nhev->xRc = HvLpEvent_Rc_Good;\r\nhev->xSourceInstanceId = HvCallEvent_getSourceLpInstanceId(primary_lp,\r\nHvLpEvent_Type_MachineFac);\r\nhev->xTargetInstanceId = HvCallEvent_getTargetLpInstanceId(primary_lp,\r\nHvLpEvent_Type_MachineFac);\r\nreturn ev;\r\n}\r\nstatic int __maybe_unused\r\nsignal_vsp_instruction(struct vsp_cmd_data *vsp_cmd)\r\n{\r\nstruct pending_event *ev = new_pending_event();\r\nint rc;\r\nstruct vsp_rsp_data response;\r\nif (ev == NULL)\r\nreturn -ENOMEM;\r\ninit_completion(&response.com);\r\nresponse.response = vsp_cmd;\r\nev->event.hp_lp_event.xSubtype = 6;\r\nev->event.hp_lp_event.x.xSubtypeData =\r\nsubtype_data('M', 'F', 'V', 'I');\r\nev->event.data.vsp_cmd.token = (u64)&response;\r\nev->event.data.vsp_cmd.cmd = vsp_cmd->cmd;\r\nev->event.data.vsp_cmd.lp_index = HvLpConfig_getLpIndex();\r\nev->event.data.vsp_cmd.result_code = 0xFF;\r\nev->event.data.vsp_cmd.reserved = 0;\r\nmemcpy(&(ev->event.data.vsp_cmd.sub_data),\r\n&(vsp_cmd->sub_data), sizeof(vsp_cmd->sub_data));\r\nmb();\r\nrc = signal_event(ev);\r\nif (rc == 0)\r\nwait_for_completion(&response.com);\r\nreturn rc;\r\n}\r\nstatic int signal_ce_msg(char *ce_msg, struct ce_msg_comp_data *completion)\r\n{\r\nstruct pending_event *ev = new_pending_event();\r\nif (ev == NULL)\r\nreturn -ENOMEM;\r\nev->event.hp_lp_event.xSubtype = 0;\r\nev->event.hp_lp_event.x.xSubtypeData =\r\nsubtype_data('M', 'F', 'C', 'E');\r\nmemcpy(ev->event.data.ce_msg.ce_msg, ce_msg, 12);\r\nev->event.data.ce_msg.completion = completion;\r\nreturn signal_event(ev);\r\n}\r\nstatic int signal_ce_msg_simple(u8 ce_op, struct ce_msg_comp_data *completion)\r\n{\r\nu8 ce_msg[12];\r\nmemset(ce_msg, 0, sizeof(ce_msg));\r\nce_msg[3] = ce_op;\r\nreturn signal_ce_msg(ce_msg, completion);\r\n}\r\nstatic int dma_and_signal_ce_msg(char *ce_msg,\r\nstruct ce_msg_comp_data *completion, void *dma_data,\r\nunsigned dma_data_length, unsigned remote_address)\r\n{\r\nstruct pending_event *ev = new_pending_event();\r\nif (ev == NULL)\r\nreturn -ENOMEM;\r\nev->event.hp_lp_event.xSubtype = 0;\r\nev->event.hp_lp_event.x.xSubtypeData =\r\nsubtype_data('M', 'F', 'C', 'E');\r\nmemcpy(ev->event.data.ce_msg.ce_msg, ce_msg, 12);\r\nev->event.data.ce_msg.completion = completion;\r\nmemcpy(ev->dma_data, dma_data, dma_data_length);\r\nev->dma_data_length = dma_data_length;\r\nev->remote_address = remote_address;\r\nreturn signal_event(ev);\r\n}\r\nstatic int shutdown(void)\r\n{\r\nint rc = kill_cad_pid(SIGINT, 1);\r\nif (rc) {\r\nprintk(KERN_ALERT "mf.c: SIGINT to init failed (%d), "\r\n"hard shutdown commencing\n", rc);\r\nmf_power_off();\r\n} else\r\nprintk(KERN_INFO "mf.c: init has been successfully notified "\r\n"to proceed with shutdown\n");\r\nreturn rc;\r\n}\r\nstatic void handle_int(struct io_mf_lp_event *event)\r\n{\r\nstruct ce_msg_data *ce_msg_data;\r\nstruct ce_msg_data *pce_msg_data;\r\nunsigned long flags;\r\nstruct pending_event *pev;\r\nevent->hp_lp_event.xRc = HvLpEvent_Rc_Good;\r\nHvCallEvent_ackLpEvent(&event->hp_lp_event);\r\nswitch (event->hp_lp_event.xSubtype) {\r\ncase 0:\r\nce_msg_data = &event->data.ce_msg;\r\nswitch (ce_msg_data->ce_msg[3]) {\r\ncase 0x5B:\r\nif ((ce_msg_data->ce_msg[5] & 0x20) != 0) {\r\nprintk(KERN_INFO "mf.c: Commencing partition shutdown\n");\r\nif (shutdown() == 0)\r\nsignal_ce_msg_simple(0xDB, NULL);\r\n}\r\nbreak;\r\ncase 0xC0:\r\nspin_lock_irqsave(&pending_event_spinlock, flags);\r\npev = pending_event_head;\r\nif (pev != NULL)\r\npending_event_head = pending_event_head->next;\r\nspin_unlock_irqrestore(&pending_event_spinlock, flags);\r\nif (pev == NULL)\r\nbreak;\r\npce_msg_data = &pev->event.data.ce_msg;\r\nif (pce_msg_data->ce_msg[3] != 0x40)\r\nbreak;\r\nif (pce_msg_data->completion != NULL) {\r\nce_msg_comp_hdlr handler =\r\npce_msg_data->completion->handler;\r\nvoid *token = pce_msg_data->completion->token;\r\nif (handler != NULL)\r\n(*handler)(token, ce_msg_data);\r\n}\r\nspin_lock_irqsave(&pending_event_spinlock, flags);\r\nfree_pending_event(pev);\r\nspin_unlock_irqrestore(&pending_event_spinlock, flags);\r\nif (pending_event_head != NULL)\r\nsignal_event(NULL);\r\nbreak;\r\n}\r\nbreak;\r\ncase 1:\r\nprintk(KERN_INFO "mf.c: Commencing system shutdown\n");\r\nshutdown();\r\nbreak;\r\n}\r\n}\r\nstatic void handle_ack(struct io_mf_lp_event *event)\r\n{\r\nunsigned long flags;\r\nstruct pending_event *two = NULL;\r\nunsigned long free_it = 0;\r\nstruct ce_msg_data *ce_msg_data;\r\nstruct ce_msg_data *pce_msg_data;\r\nstruct vsp_rsp_data *rsp;\r\nif (pending_event_head == NULL) {\r\nprintk(KERN_ERR "mf.c: stack empty for receiving ack\n");\r\nreturn;\r\n}\r\nswitch (event->hp_lp_event.xSubtype) {\r\ncase 0:\r\nce_msg_data = &event->data.ce_msg;\r\nif (ce_msg_data->ce_msg[3] != 0x40) {\r\nfree_it = 1;\r\nbreak;\r\n}\r\nif (ce_msg_data->ce_msg[2] == 0)\r\nbreak;\r\nfree_it = 1;\r\npce_msg_data = &pending_event_head->event.data.ce_msg;\r\nif (pce_msg_data->completion != NULL) {\r\nce_msg_comp_hdlr handler =\r\npce_msg_data->completion->handler;\r\nvoid *token = pce_msg_data->completion->token;\r\nif (handler != NULL)\r\n(*handler)(token, ce_msg_data);\r\n}\r\nbreak;\r\ncase 4:\r\ncase 5:\r\nif (pending_event_head->hdlr != NULL)\r\n(*pending_event_head->hdlr)((void *)event->hp_lp_event.xCorrelationToken, event->data.alloc.count);\r\nfree_it = 1;\r\nbreak;\r\ncase 6:\r\nfree_it = 1;\r\nrsp = (struct vsp_rsp_data *)event->data.vsp_cmd.token;\r\nif (rsp == NULL) {\r\nprintk(KERN_ERR "mf.c: no rsp\n");\r\nbreak;\r\n}\r\nif (rsp->response != NULL)\r\nmemcpy(rsp->response, &event->data.vsp_cmd,\r\nsizeof(event->data.vsp_cmd));\r\ncomplete(&rsp->com);\r\nbreak;\r\n}\r\nspin_lock_irqsave(&pending_event_spinlock, flags);\r\nif ((pending_event_head != NULL) && (free_it == 1)) {\r\nstruct pending_event *oldHead = pending_event_head;\r\npending_event_head = pending_event_head->next;\r\ntwo = pending_event_head;\r\nfree_pending_event(oldHead);\r\n}\r\nspin_unlock_irqrestore(&pending_event_spinlock, flags);\r\nif (two != NULL)\r\nsignal_event(NULL);\r\n}\r\nstatic void hv_handler(struct HvLpEvent *event)\r\n{\r\nif ((event != NULL) && (event->xType == HvLpEvent_Type_MachineFac)) {\r\nif (hvlpevent_is_ack(event))\r\nhandle_ack((struct io_mf_lp_event *)event);\r\nelse\r\nhandle_int((struct io_mf_lp_event *)event);\r\n} else\r\nprintk(KERN_ERR "mf.c: alien event received\n");\r\n}\r\nvoid mf_allocate_lp_events(HvLpIndex target_lp, HvLpEvent_Type type,\r\nunsigned size, unsigned count, MFCompleteHandler hdlr,\r\nvoid *user_token)\r\n{\r\nstruct pending_event *ev = new_pending_event();\r\nint rc;\r\nif (ev == NULL) {\r\nrc = -ENOMEM;\r\n} else {\r\nev->event.hp_lp_event.xSubtype = 4;\r\nev->event.hp_lp_event.xCorrelationToken = (u64)user_token;\r\nev->event.hp_lp_event.x.xSubtypeData =\r\nsubtype_data('M', 'F', 'M', 'A');\r\nev->event.data.alloc.target_lp = target_lp;\r\nev->event.data.alloc.type = type;\r\nev->event.data.alloc.size = size;\r\nev->event.data.alloc.count = count;\r\nev->hdlr = hdlr;\r\nrc = signal_event(ev);\r\n}\r\nif ((rc != 0) && (hdlr != NULL))\r\n(*hdlr)(user_token, rc);\r\n}\r\nvoid mf_deallocate_lp_events(HvLpIndex target_lp, HvLpEvent_Type type,\r\nunsigned count, MFCompleteHandler hdlr, void *user_token)\r\n{\r\nstruct pending_event *ev = new_pending_event();\r\nint rc;\r\nif (ev == NULL)\r\nrc = -ENOMEM;\r\nelse {\r\nev->event.hp_lp_event.xSubtype = 5;\r\nev->event.hp_lp_event.xCorrelationToken = (u64)user_token;\r\nev->event.hp_lp_event.x.xSubtypeData =\r\nsubtype_data('M', 'F', 'M', 'D');\r\nev->event.data.alloc.target_lp = target_lp;\r\nev->event.data.alloc.type = type;\r\nev->event.data.alloc.count = count;\r\nev->hdlr = hdlr;\r\nrc = signal_event(ev);\r\n}\r\nif ((rc != 0) && (hdlr != NULL))\r\n(*hdlr)(user_token, rc);\r\n}\r\nvoid mf_power_off(void)\r\n{\r\nprintk(KERN_INFO "mf.c: Down it goes...\n");\r\nsignal_ce_msg_simple(0x4d, NULL);\r\nfor (;;)\r\n;\r\n}\r\nvoid mf_reboot(char *cmd)\r\n{\r\nprintk(KERN_INFO "mf.c: Preparing to bounce...\n");\r\nsignal_ce_msg_simple(0x4e, NULL);\r\nfor (;;)\r\n;\r\n}\r\nvoid mf_display_src(u32 word)\r\n{\r\nu8 ce[12];\r\nmemset(ce, 0, sizeof(ce));\r\nce[3] = 0x4a;\r\nce[7] = 0x01;\r\nce[8] = word >> 24;\r\nce[9] = word >> 16;\r\nce[10] = word >> 8;\r\nce[11] = word;\r\nsignal_ce_msg(ce, NULL);\r\n}\r\nstatic __init void mf_display_progress_src(u16 value)\r\n{\r\nu8 ce[12];\r\nu8 src[72];\r\nmemcpy(ce, "\x00\x00\x04\x4A\x00\x00\x00\x48\x00\x00\x00\x00", 12);\r\nmemcpy(src, "\x01\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"\r\n"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"\r\n"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"\r\n"\x00\x00\x00\x00PROGxxxx ",\r\n72);\r\nsrc[6] = value >> 8;\r\nsrc[7] = value & 255;\r\nsrc[44] = "0123456789ABCDEF"[(value >> 12) & 15];\r\nsrc[45] = "0123456789ABCDEF"[(value >> 8) & 15];\r\nsrc[46] = "0123456789ABCDEF"[(value >> 4) & 15];\r\nsrc[47] = "0123456789ABCDEF"[value & 15];\r\ndma_and_signal_ce_msg(ce, NULL, src, sizeof(src), 9 * 64 * 1024);\r\n}\r\nstatic void mf_clear_src(void)\r\n{\r\nsignal_ce_msg_simple(0x4b, NULL);\r\n}\r\nvoid __init mf_display_progress(u16 value)\r\n{\r\nif (!mf_initialized)\r\nreturn;\r\nif (0xFFFF == value)\r\nmf_clear_src();\r\nelse\r\nmf_display_progress_src(value);\r\n}\r\nvoid __init mf_init(void)\r\n{\r\nint i;\r\nspin_lock_init(&pending_event_spinlock);\r\nfor (i = 0; i < PENDING_EVENT_PREALLOC_LEN; i++)\r\nfree_pending_event(&pending_event_prealloc[i]);\r\nHvLpEvent_registerHandler(HvLpEvent_Type_MachineFac, &hv_handler);\r\nsignal_ce_msg_simple(0x57, NULL);\r\nmf_initialized = 1;\r\nmb();\r\nprintk(KERN_NOTICE "mf.c: iSeries Linux LPAR Machine Facilities "\r\n"initialized\n");\r\n}\r\nstatic void get_rtc_time_complete(void *token, struct ce_msg_data *ce_msg)\r\n{\r\nstruct rtc_time_data *rtc = token;\r\nmemcpy(&rtc->ce_msg, ce_msg, sizeof(rtc->ce_msg));\r\nrtc->rc = 0;\r\ncomplete(&rtc->com);\r\n}\r\nstatic int mf_set_rtc(struct rtc_time *tm)\r\n{\r\nchar ce_time[12];\r\nu8 day, mon, hour, min, sec, y1, y2;\r\nunsigned year;\r\nyear = 1900 + tm->tm_year;\r\ny1 = year / 100;\r\ny2 = year % 100;\r\nsec = tm->tm_sec;\r\nmin = tm->tm_min;\r\nhour = tm->tm_hour;\r\nday = tm->tm_mday;\r\nmon = tm->tm_mon + 1;\r\nsec = bin2bcd(sec);\r\nmin = bin2bcd(min);\r\nhour = bin2bcd(hour);\r\nmon = bin2bcd(mon);\r\nday = bin2bcd(day);\r\ny1 = bin2bcd(y1);\r\ny2 = bin2bcd(y2);\r\nmemset(ce_time, 0, sizeof(ce_time));\r\nce_time[3] = 0x41;\r\nce_time[4] = y1;\r\nce_time[5] = y2;\r\nce_time[6] = sec;\r\nce_time[7] = min;\r\nce_time[8] = hour;\r\nce_time[10] = day;\r\nce_time[11] = mon;\r\nreturn signal_ce_msg(ce_time, NULL);\r\n}\r\nstatic int rtc_set_tm(int rc, u8 *ce_msg, struct rtc_time *tm)\r\n{\r\ntm->tm_wday = 0;\r\ntm->tm_yday = 0;\r\ntm->tm_isdst = 0;\r\nif (rc) {\r\ntm->tm_sec = 0;\r\ntm->tm_min = 0;\r\ntm->tm_hour = 0;\r\ntm->tm_mday = 15;\r\ntm->tm_mon = 5;\r\ntm->tm_year = 52;\r\nreturn rc;\r\n}\r\nif ((ce_msg[2] == 0xa9) ||\r\n(ce_msg[2] == 0xaf)) {\r\ntm->tm_sec = 1;\r\ntm->tm_min = 1;\r\ntm->tm_hour = 1;\r\ntm->tm_mday = 10;\r\ntm->tm_mon = 8;\r\ntm->tm_year = 71;\r\nmf_set_rtc(tm);\r\n}\r\n{\r\nu8 year = ce_msg[5];\r\nu8 sec = ce_msg[6];\r\nu8 min = ce_msg[7];\r\nu8 hour = ce_msg[8];\r\nu8 day = ce_msg[10];\r\nu8 mon = ce_msg[11];\r\nsec = bcd2bin(sec);\r\nmin = bcd2bin(min);\r\nhour = bcd2bin(hour);\r\nday = bcd2bin(day);\r\nmon = bcd2bin(mon);\r\nyear = bcd2bin(year);\r\nif (year <= 69)\r\nyear += 100;\r\ntm->tm_sec = sec;\r\ntm->tm_min = min;\r\ntm->tm_hour = hour;\r\ntm->tm_mday = day;\r\ntm->tm_mon = mon;\r\ntm->tm_year = year;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mf_get_rtc(struct rtc_time *tm)\r\n{\r\nstruct ce_msg_comp_data ce_complete;\r\nstruct rtc_time_data rtc_data;\r\nint rc;\r\nmemset(&ce_complete, 0, sizeof(ce_complete));\r\nmemset(&rtc_data, 0, sizeof(rtc_data));\r\ninit_completion(&rtc_data.com);\r\nce_complete.handler = &get_rtc_time_complete;\r\nce_complete.token = &rtc_data;\r\nrc = signal_ce_msg_simple(0x40, &ce_complete);\r\nif (rc)\r\nreturn rc;\r\nwait_for_completion(&rtc_data.com);\r\nreturn rtc_set_tm(rtc_data.rc, rtc_data.ce_msg.ce_msg, tm);\r\n}\r\nstatic void get_boot_rtc_time_complete(void *token, struct ce_msg_data *ce_msg)\r\n{\r\nstruct boot_rtc_time_data *rtc = token;\r\nmemcpy(&rtc->ce_msg, ce_msg, sizeof(rtc->ce_msg));\r\nrtc->rc = 0;\r\nrtc->busy = 0;\r\n}\r\nstatic int mf_get_boot_rtc(struct rtc_time *tm)\r\n{\r\nstruct ce_msg_comp_data ce_complete;\r\nstruct boot_rtc_time_data rtc_data;\r\nint rc;\r\nmemset(&ce_complete, 0, sizeof(ce_complete));\r\nmemset(&rtc_data, 0, sizeof(rtc_data));\r\nrtc_data.busy = 1;\r\nce_complete.handler = &get_boot_rtc_time_complete;\r\nce_complete.token = &rtc_data;\r\nrc = signal_ce_msg_simple(0x40, &ce_complete);\r\nif (rc)\r\nreturn rc;\r\nwhile (rtc_data.busy) {\r\nif (hvlpevent_is_pending())\r\nprocess_hvlpevents();\r\n}\r\nreturn rtc_set_tm(rtc_data.rc, rtc_data.ce_msg.ce_msg, tm);\r\n}\r\nstatic int mf_cmdline_proc_show(struct seq_file *m, void *v)\r\n{\r\nchar *page, *p;\r\nstruct vsp_cmd_data vsp_cmd;\r\nint rc;\r\ndma_addr_t dma_addr;\r\npage = kmalloc(256, GFP_KERNEL);\r\nif (!page)\r\nreturn -ENOMEM;\r\ndma_addr = iseries_hv_map(page, 256, DMA_FROM_DEVICE);\r\nif (dma_addr == DMA_ERROR_CODE) {\r\nkfree(page);\r\nreturn -ENOMEM;\r\n}\r\nmemset(page, 0, 256);\r\nmemset(&vsp_cmd, 0, sizeof(vsp_cmd));\r\nvsp_cmd.cmd = 33;\r\nvsp_cmd.sub_data.kern.token = dma_addr;\r\nvsp_cmd.sub_data.kern.address_type = HvLpDma_AddressType_TceIndex;\r\nvsp_cmd.sub_data.kern.side = (u64)m->private;\r\nvsp_cmd.sub_data.kern.length = 256;\r\nmb();\r\nrc = signal_vsp_instruction(&vsp_cmd);\r\niseries_hv_unmap(dma_addr, 256, DMA_FROM_DEVICE);\r\nif (rc) {\r\nkfree(page);\r\nreturn rc;\r\n}\r\nif (vsp_cmd.result_code != 0) {\r\nkfree(page);\r\nreturn -ENOMEM;\r\n}\r\np = page;\r\nwhile (p - page < 256) {\r\nif (*p == '\0' || *p == '\n') {\r\n*p = '\n';\r\nbreak;\r\n}\r\np++;\r\n}\r\nseq_write(m, page, p - page);\r\nkfree(page);\r\nreturn 0;\r\n}\r\nstatic int mf_cmdline_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, mf_cmdline_proc_show, PDE(inode)->data);\r\n}\r\nstatic int mf_side_proc_show(struct seq_file *m, void *v)\r\n{\r\nchar mf_current_side = ' ';\r\nstruct vsp_cmd_data vsp_cmd;\r\nmemset(&vsp_cmd, 0, sizeof(vsp_cmd));\r\nvsp_cmd.cmd = 2;\r\nvsp_cmd.sub_data.ipl_type = 0;\r\nmb();\r\nif (signal_vsp_instruction(&vsp_cmd) == 0) {\r\nif (vsp_cmd.result_code == 0) {\r\nswitch (vsp_cmd.sub_data.ipl_type) {\r\ncase 0: mf_current_side = 'A';\r\nbreak;\r\ncase 1: mf_current_side = 'B';\r\nbreak;\r\ncase 2: mf_current_side = 'C';\r\nbreak;\r\ndefault: mf_current_side = 'D';\r\nbreak;\r\n}\r\n}\r\n}\r\nseq_printf(m, "%c\n", mf_current_side);\r\nreturn 0;\r\n}\r\nstatic int mf_side_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, mf_side_proc_show, NULL);\r\n}\r\nstatic ssize_t mf_side_proc_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *pos)\r\n{\r\nchar side;\r\nu64 newSide;\r\nstruct vsp_cmd_data vsp_cmd;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nif (count == 0)\r\nreturn 0;\r\nif (get_user(side, buffer))\r\nreturn -EFAULT;\r\nswitch (side) {\r\ncase 'A': newSide = 0;\r\nbreak;\r\ncase 'B': newSide = 1;\r\nbreak;\r\ncase 'C': newSide = 2;\r\nbreak;\r\ncase 'D': newSide = 3;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "mf_proc.c: proc_mf_change_side: invalid side\n");\r\nreturn -EINVAL;\r\n}\r\nmemset(&vsp_cmd, 0, sizeof(vsp_cmd));\r\nvsp_cmd.sub_data.ipl_type = newSide;\r\nvsp_cmd.cmd = 10;\r\n(void)signal_vsp_instruction(&vsp_cmd);\r\nreturn count;\r\n}\r\nstatic int mf_src_proc_show(struct seq_file *m, void *v)\r\n{\r\nreturn 0;\r\n}\r\nstatic int mf_src_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, mf_src_proc_show, NULL);\r\n}\r\nstatic ssize_t mf_src_proc_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *pos)\r\n{\r\nchar stkbuf[10];\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nif ((count < 4) && (count != 1)) {\r\nprintk(KERN_ERR "mf_proc: invalid src\n");\r\nreturn -EINVAL;\r\n}\r\nif (count > (sizeof(stkbuf) - 1))\r\ncount = sizeof(stkbuf) - 1;\r\nif (copy_from_user(stkbuf, buffer, count))\r\nreturn -EFAULT;\r\nif ((count == 1) && (*stkbuf == '\0'))\r\nmf_clear_src();\r\nelse\r\nmf_display_src(*(u32 *)stkbuf);\r\nreturn count;\r\n}\r\nstatic ssize_t mf_cmdline_proc_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *pos)\r\n{\r\nvoid *data = PDE(file->f_path.dentry->d_inode)->data;\r\nstruct vsp_cmd_data vsp_cmd;\r\ndma_addr_t dma_addr;\r\nchar *page;\r\nint ret = -EACCES;\r\nif (!capable(CAP_SYS_ADMIN))\r\ngoto out;\r\ndma_addr = 0;\r\npage = iseries_hv_alloc(count, &dma_addr, GFP_ATOMIC);\r\nret = -ENOMEM;\r\nif (page == NULL)\r\ngoto out;\r\nret = -EFAULT;\r\nif (copy_from_user(page, buffer, count))\r\ngoto out_free;\r\nmemset(&vsp_cmd, 0, sizeof(vsp_cmd));\r\nvsp_cmd.cmd = 31;\r\nvsp_cmd.sub_data.kern.token = dma_addr;\r\nvsp_cmd.sub_data.kern.address_type = HvLpDma_AddressType_TceIndex;\r\nvsp_cmd.sub_data.kern.side = (u64)data;\r\nvsp_cmd.sub_data.kern.length = count;\r\nmb();\r\n(void)signal_vsp_instruction(&vsp_cmd);\r\nret = count;\r\nout_free:\r\niseries_hv_free(count, page, dma_addr);\r\nout:\r\nreturn ret;\r\n}\r\nstatic ssize_t proc_mf_change_vmlinux(struct file *file,\r\nconst char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct proc_dir_entry *dp = PDE(file->f_path.dentry->d_inode);\r\nssize_t rc;\r\ndma_addr_t dma_addr;\r\nchar *page;\r\nstruct vsp_cmd_data vsp_cmd;\r\nrc = -EACCES;\r\nif (!capable(CAP_SYS_ADMIN))\r\ngoto out;\r\ndma_addr = 0;\r\npage = iseries_hv_alloc(count, &dma_addr, GFP_ATOMIC);\r\nrc = -ENOMEM;\r\nif (page == NULL) {\r\nprintk(KERN_ERR "mf.c: couldn't allocate memory to set vmlinux chunk\n");\r\ngoto out;\r\n}\r\nrc = -EFAULT;\r\nif (copy_from_user(page, buf, count))\r\ngoto out_free;\r\nmemset(&vsp_cmd, 0, sizeof(vsp_cmd));\r\nvsp_cmd.cmd = 30;\r\nvsp_cmd.sub_data.kern.token = dma_addr;\r\nvsp_cmd.sub_data.kern.address_type = HvLpDma_AddressType_TceIndex;\r\nvsp_cmd.sub_data.kern.side = (u64)dp->data;\r\nvsp_cmd.sub_data.kern.offset = *ppos;\r\nvsp_cmd.sub_data.kern.length = count;\r\nmb();\r\nrc = signal_vsp_instruction(&vsp_cmd);\r\nif (rc)\r\ngoto out_free;\r\nrc = -ENOMEM;\r\nif (vsp_cmd.result_code != 0)\r\ngoto out_free;\r\n*ppos += count;\r\nrc = count;\r\nout_free:\r\niseries_hv_free(count, page, dma_addr);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int __init mf_proc_init(void)\r\n{\r\nstruct proc_dir_entry *mf_proc_root;\r\nstruct proc_dir_entry *ent;\r\nstruct proc_dir_entry *mf;\r\nchar name[2];\r\nint i;\r\nif (!firmware_has_feature(FW_FEATURE_ISERIES))\r\nreturn 0;\r\nmf_proc_root = proc_mkdir("iSeries/mf", NULL);\r\nif (!mf_proc_root)\r\nreturn 1;\r\nname[1] = '\0';\r\nfor (i = 0; i < 4; i++) {\r\nname[0] = 'A' + i;\r\nmf = proc_mkdir(name, mf_proc_root);\r\nif (!mf)\r\nreturn 1;\r\nent = proc_create_data("cmdline", S_IRUSR|S_IWUSR, mf,\r\n&mf_cmdline_proc_fops, (void *)(long)i);\r\nif (!ent)\r\nreturn 1;\r\nif (i == 3)\r\ncontinue;\r\nent = proc_create_data("vmlinux", S_IFREG|S_IWUSR, mf,\r\n&proc_vmlinux_operations,\r\n(void *)(long)i);\r\nif (!ent)\r\nreturn 1;\r\n}\r\nent = proc_create("side", S_IFREG|S_IRUSR|S_IWUSR, mf_proc_root,\r\n&mf_side_proc_fops);\r\nif (!ent)\r\nreturn 1;\r\nent = proc_create("src", S_IFREG|S_IRUSR|S_IWUSR, mf_proc_root,\r\n&mf_src_proc_fops);\r\nif (!ent)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nvoid iSeries_get_rtc_time(struct rtc_time *rtc_tm)\r\n{\r\nmf_get_rtc(rtc_tm);\r\nrtc_tm->tm_mon--;\r\n}\r\nint iSeries_set_rtc_time(struct rtc_time *tm)\r\n{\r\nmf_set_rtc(tm);\r\nreturn 0;\r\n}\r\nunsigned long iSeries_get_boot_time(void)\r\n{\r\nstruct rtc_time tm;\r\nmf_get_boot_rtc(&tm);\r\nreturn mktime(tm.tm_year + 1900, tm.tm_mon, tm.tm_mday,\r\ntm.tm_hour, tm.tm_min, tm.tm_sec);\r\n}
