static void vci_bitfield_iterate(struct lanai_dev *lanai,\r\nconst unsigned long *lp,\r\nvoid (*func)(struct lanai_dev *,vci_t vci))\r\n{\r\nvci_t vci;\r\nfor_each_set_bit(vci, lp, NUM_VCI)\r\nfunc(lanai, vci);\r\n}\r\nstatic void lanai_buf_allocate(struct lanai_buffer *buf,\r\nsize_t bytes, size_t minbytes, struct pci_dev *pci)\r\n{\r\nint size;\r\nif (bytes > (128 * 1024))\r\nbytes = 128 * 1024;\r\nfor (size = LANAI_PAGE_SIZE; size < bytes; size *= 2)\r\n;\r\nif (minbytes < LANAI_PAGE_SIZE)\r\nminbytes = LANAI_PAGE_SIZE;\r\ndo {\r\nbuf->start = pci_alloc_consistent(pci, size, &buf->dmaaddr);\r\nif (buf->start != NULL) {\r\nAPRINTK((buf->dmaaddr & ~0xFFFFFF00) == 0,\r\n"bad dmaaddr: 0x%lx\n",\r\n(unsigned long) buf->dmaaddr);\r\nbuf->ptr = buf->start;\r\nbuf->end = (u32 *)\r\n(&((unsigned char *) buf->start)[size]);\r\nmemset(buf->start, 0, size);\r\nbreak;\r\n}\r\nsize /= 2;\r\n} while (size >= minbytes);\r\n}\r\nstatic inline size_t lanai_buf_size(const struct lanai_buffer *buf)\r\n{\r\nreturn ((unsigned long) buf->end) - ((unsigned long) buf->start);\r\n}\r\nstatic void lanai_buf_deallocate(struct lanai_buffer *buf,\r\nstruct pci_dev *pci)\r\n{\r\nif (buf->start != NULL) {\r\npci_free_consistent(pci, lanai_buf_size(buf),\r\nbuf->start, buf->dmaaddr);\r\nbuf->start = buf->end = buf->ptr = NULL;\r\n}\r\n}\r\nstatic int lanai_buf_size_cardorder(const struct lanai_buffer *buf)\r\n{\r\nint order = get_order(lanai_buf_size(buf)) + (PAGE_SHIFT - 10);\r\nif (order > 7)\r\norder = 7;\r\nreturn order;\r\n}\r\nstatic inline bus_addr_t reg_addr(const struct lanai_dev *lanai,\r\nenum lanai_register reg)\r\n{\r\nreturn lanai->base + reg;\r\n}\r\nstatic inline u32 reg_read(const struct lanai_dev *lanai,\r\nenum lanai_register reg)\r\n{\r\nu32 t;\r\nt = readl(reg_addr(lanai, reg));\r\nRWDEBUG("R [0x%08X] 0x%02X = 0x%08X\n", (unsigned int) lanai->base,\r\n(int) reg, t);\r\nreturn t;\r\n}\r\nstatic inline void reg_write(const struct lanai_dev *lanai, u32 val,\r\nenum lanai_register reg)\r\n{\r\nRWDEBUG("W [0x%08X] 0x%02X < 0x%08X\n", (unsigned int) lanai->base,\r\n(int) reg, val);\r\nwritel(val, reg_addr(lanai, reg));\r\n}\r\nstatic inline void conf1_write(const struct lanai_dev *lanai)\r\n{\r\nreg_write(lanai, lanai->conf1, Config1_Reg);\r\n}\r\nstatic inline void conf2_write(const struct lanai_dev *lanai)\r\n{\r\nreg_write(lanai, lanai->conf2, Config2_Reg);\r\n}\r\nstatic inline void conf2_write_if_powerup(const struct lanai_dev *lanai)\r\n{\r\n#ifdef USE_POWERDOWN\r\nif (unlikely((lanai->conf1 & CONFIG1_POWERDOWN) != 0))\r\nreturn;\r\n#endif\r\nconf2_write(lanai);\r\n}\r\nstatic inline void reset_board(const struct lanai_dev *lanai)\r\n{\r\nDPRINTK("about to reset board\n");\r\nreg_write(lanai, 0, Reset_Reg);\r\nudelay(5);\r\n}\r\nstatic inline bus_addr_t sram_addr(const struct lanai_dev *lanai, int offset)\r\n{\r\nreturn lanai->base + SRAM_START + offset;\r\n}\r\nstatic inline u32 sram_read(const struct lanai_dev *lanai, int offset)\r\n{\r\nreturn readl(sram_addr(lanai, offset));\r\n}\r\nstatic inline void sram_write(const struct lanai_dev *lanai,\r\nu32 val, int offset)\r\n{\r\nwritel(val, sram_addr(lanai, offset));\r\n}\r\nstatic int __devinit sram_test_word(const struct lanai_dev *lanai,\r\nint offset, u32 pattern)\r\n{\r\nu32 readback;\r\nsram_write(lanai, pattern, offset);\r\nreadback = sram_read(lanai, offset);\r\nif (likely(readback == pattern))\r\nreturn 0;\r\nprintk(KERN_ERR DEV_LABEL\r\n"(itf %d): SRAM word at %d bad: wrote 0x%X, read 0x%X\n",\r\nlanai->number, offset,\r\n(unsigned int) pattern, (unsigned int) readback);\r\nreturn -EIO;\r\n}\r\nstatic int __devinit sram_test_pass(const struct lanai_dev *lanai, u32 pattern)\r\n{\r\nint offset, result = 0;\r\nfor (offset = 0; offset < SRAM_BYTES && result == 0; offset += 4)\r\nresult = sram_test_word(lanai, offset, pattern);\r\nreturn result;\r\n}\r\nstatic int __devinit sram_test_and_clear(const struct lanai_dev *lanai)\r\n{\r\n#ifdef FULL_MEMORY_TEST\r\nint result;\r\nDPRINTK("testing SRAM\n");\r\nif ((result = sram_test_pass(lanai, 0x5555)) != 0)\r\nreturn result;\r\nif ((result = sram_test_pass(lanai, 0xAAAA)) != 0)\r\nreturn result;\r\n#endif\r\nDPRINTK("clearing SRAM\n");\r\nreturn sram_test_pass(lanai, 0x0000);\r\n}\r\nstatic inline bus_addr_t cardvcc_addr(const struct lanai_dev *lanai,\r\nvci_t vci)\r\n{\r\nreturn sram_addr(lanai, vci * CARDVCC_SIZE);\r\n}\r\nstatic inline u32 cardvcc_read(const struct lanai_vcc *lvcc,\r\nenum lanai_vcc_offset offset)\r\n{\r\nu32 val;\r\nAPRINTK(lvcc->vbase != NULL, "cardvcc_read: unbound vcc!\n");\r\nval= readl(lvcc->vbase + offset);\r\nRWDEBUG("VR vci=%04d 0x%02X = 0x%08X\n",\r\nlvcc->vci, (int) offset, val);\r\nreturn val;\r\n}\r\nstatic inline void cardvcc_write(const struct lanai_vcc *lvcc,\r\nu32 val, enum lanai_vcc_offset offset)\r\n{\r\nAPRINTK(lvcc->vbase != NULL, "cardvcc_write: unbound vcc!\n");\r\nAPRINTK((val & ~0xFFFF) == 0,\r\n"cardvcc_write: bad val 0x%X (vci=%d, addr=0x%02X)\n",\r\n(unsigned int) val, lvcc->vci, (unsigned int) offset);\r\nRWDEBUG("VW vci=%04d 0x%02X > 0x%08X\n",\r\nlvcc->vci, (unsigned int) offset, (unsigned int) val);\r\nwritel(val, lvcc->vbase + offset);\r\n}\r\nstatic inline int aal5_size(int size)\r\n{\r\nint cells = (size + 8 + 47) / 48;\r\nreturn cells * 48;\r\n}\r\nstatic inline int aal5_spacefor(int space)\r\n{\r\nint cells = space / 48;\r\nreturn cells * 48;\r\n}\r\nstatic inline void lanai_free_skb(struct atm_vcc *atmvcc, struct sk_buff *skb)\r\n{\r\nif (atmvcc->pop != NULL)\r\natmvcc->pop(atmvcc, skb);\r\nelse\r\ndev_kfree_skb_any(skb);\r\n}\r\nstatic void host_vcc_start_rx(const struct lanai_vcc *lvcc)\r\n{\r\nu32 addr1;\r\nif (lvcc->rx.atmvcc->qos.aal == ATM_AAL5) {\r\ndma_addr_t dmaaddr = lvcc->rx.buf.dmaaddr;\r\ncardvcc_write(lvcc, 0xFFFF, vcc_rxcrc1);\r\ncardvcc_write(lvcc, 0xFFFF, vcc_rxcrc2);\r\ncardvcc_write(lvcc, 0, vcc_rxwriteptr);\r\ncardvcc_write(lvcc, 0, vcc_rxbufstart);\r\ncardvcc_write(lvcc, 0, vcc_rxreadptr);\r\ncardvcc_write(lvcc, (dmaaddr >> 16) & 0xFFFF, vcc_rxaddr2);\r\naddr1 = ((dmaaddr >> 8) & 0xFF) |\r\nRXADDR1_SET_SIZE(lanai_buf_size_cardorder(&lvcc->rx.buf))|\r\nRXADDR1_SET_RMMODE(RMMODE_TRASH) |\r\nRXADDR1_SET_MODE(RXMODE_AAL5);\r\n} else\r\naddr1 = RXADDR1_SET_RMMODE(RMMODE_PRESERVE) |\r\nRXADDR1_OAM_PRESERVE |\r\nRXADDR1_SET_MODE(RXMODE_AAL0);\r\ncardvcc_write(lvcc, addr1, vcc_rxaddr1);\r\n}\r\nstatic void host_vcc_start_tx(const struct lanai_vcc *lvcc)\r\n{\r\ndma_addr_t dmaaddr = lvcc->tx.buf.dmaaddr;\r\ncardvcc_write(lvcc, 0, vcc_txicg);\r\ncardvcc_write(lvcc, 0xFFFF, vcc_txcrc1);\r\ncardvcc_write(lvcc, 0xFFFF, vcc_txcrc2);\r\ncardvcc_write(lvcc, 0, vcc_txreadptr);\r\ncardvcc_write(lvcc, 0, vcc_txendptr);\r\ncardvcc_write(lvcc, 0, vcc_txwriteptr);\r\ncardvcc_write(lvcc,\r\n(lvcc->tx.atmvcc->qos.txtp.traffic_class == ATM_CBR) ?\r\nTXCBR_NEXT_BOZO | lvcc->vci : 0, vcc_txcbr_next);\r\ncardvcc_write(lvcc, (dmaaddr >> 16) & 0xFFFF, vcc_txaddr2);\r\ncardvcc_write(lvcc,\r\n((dmaaddr >> 8) & 0xFF) |\r\nTXADDR1_SET_SIZE(lanai_buf_size_cardorder(&lvcc->tx.buf)),\r\nvcc_txaddr1);\r\n}\r\nstatic void lanai_shutdown_rx_vci(const struct lanai_vcc *lvcc)\r\n{\r\nif (lvcc->vbase == NULL)\r\nreturn;\r\ncardvcc_write(lvcc,\r\nRXADDR1_SET_RMMODE(RMMODE_TRASH) |\r\nRXADDR1_SET_MODE(RXMODE_TRASH), vcc_rxaddr1);\r\nudelay(15);\r\ncardvcc_write(lvcc, 0, vcc_rxaddr2);\r\ncardvcc_write(lvcc, 0, vcc_rxcrc1);\r\ncardvcc_write(lvcc, 0, vcc_rxcrc2);\r\ncardvcc_write(lvcc, 0, vcc_rxwriteptr);\r\ncardvcc_write(lvcc, 0, vcc_rxbufstart);\r\ncardvcc_write(lvcc, 0, vcc_rxreadptr);\r\n}\r\nstatic void lanai_shutdown_tx_vci(struct lanai_dev *lanai,\r\nstruct lanai_vcc *lvcc)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned long flags, timeout;\r\nint read, write, lastread = -1;\r\nAPRINTK(!in_interrupt(),\r\n"lanai_shutdown_tx_vci called w/o process context!\n");\r\nif (lvcc->vbase == NULL)\r\nreturn;\r\nwhile ((skb = skb_dequeue(&lvcc->tx.backlog)) != NULL)\r\nlanai_free_skb(lvcc->tx.atmvcc, skb);\r\nread_lock_irqsave(&vcc_sklist_lock, flags);\r\n__clear_bit(lvcc->vci, lanai->backlog_vccs);\r\nread_unlock_irqrestore(&vcc_sklist_lock, flags);\r\ntimeout = jiffies +\r\n(((lanai_buf_size(&lvcc->tx.buf) / 1024) * HZ) >> 7);\r\nwrite = TXWRITEPTR_GET_PTR(cardvcc_read(lvcc, vcc_txwriteptr));\r\nfor (;;) {\r\nread = TXREADPTR_GET_PTR(cardvcc_read(lvcc, vcc_txreadptr));\r\nif (read == write &&\r\n(lvcc->tx.atmvcc->qos.txtp.traffic_class != ATM_CBR ||\r\n(cardvcc_read(lvcc, vcc_txcbr_next) &\r\nTXCBR_NEXT_BOZO) == 0))\r\nbreak;\r\nif (read != lastread) {\r\nlastread = read;\r\ntimeout += HZ / 10;\r\n}\r\nif (unlikely(time_after(jiffies, timeout))) {\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): Timed out on "\r\n"backlog closing vci %d\n",\r\nlvcc->tx.atmvcc->dev->number, lvcc->vci);\r\nDPRINTK("read, write = %d, %d\n", read, write);\r\nbreak;\r\n}\r\nmsleep(40);\r\n}\r\ncardvcc_write(lvcc, 0, vcc_txreadptr);\r\ncardvcc_write(lvcc, 0, vcc_txwriteptr);\r\ncardvcc_write(lvcc, 0, vcc_txendptr);\r\ncardvcc_write(lvcc, 0, vcc_txcrc1);\r\ncardvcc_write(lvcc, 0, vcc_txcrc2);\r\ncardvcc_write(lvcc, 0, vcc_txaddr2);\r\ncardvcc_write(lvcc, 0, vcc_txaddr1);\r\n}\r\nstatic inline int aal0_buffer_allocate(struct lanai_dev *lanai)\r\n{\r\nDPRINTK("aal0_buffer_allocate: allocating AAL0 RX buffer\n");\r\nlanai_buf_allocate(&lanai->aal0buf, AAL0_RX_BUFFER_SIZE, 80,\r\nlanai->pci);\r\nreturn (lanai->aal0buf.start == NULL) ? -ENOMEM : 0;\r\n}\r\nstatic inline void aal0_buffer_free(struct lanai_dev *lanai)\r\n{\r\nDPRINTK("aal0_buffer_allocate: freeing AAL0 RX buffer\n");\r\nlanai_buf_deallocate(&lanai->aal0buf, lanai->pci);\r\n}\r\nstatic int __devinit eeprom_read(struct lanai_dev *lanai)\r\n{\r\nprintk(KERN_INFO DEV_LABEL "(itf %d): *NOT* reading EEPROM\n",\r\nlanai->number);\r\nmemset(&lanai->eeprom[EEPROM_MAC], 0, 6);\r\nreturn 0;\r\n}\r\nstatic int __devinit eeprom_validate(struct lanai_dev *lanai)\r\n{\r\nlanai->serialno = 0;\r\nlanai->magicno = EEPROM_MAGIC_VALUE;\r\nreturn 0;\r\n}\r\nstatic int __devinit eeprom_read(struct lanai_dev *lanai)\r\n{\r\nint i, address;\r\nu8 data;\r\nu32 tmp;\r\n#define set_config1(x) do { lanai->conf1 = x; conf1_write(lanai); \\r\n} while (0)\r\n#define clock_h() set_config1(lanai->conf1 | CONFIG1_PROMCLK)\r\n#define clock_l() set_config1(lanai->conf1 &~ CONFIG1_PROMCLK)\r\n#define data_h() set_config1(lanai->conf1 | CONFIG1_PROMDATA)\r\n#define data_l() set_config1(lanai->conf1 &~ CONFIG1_PROMDATA)\r\n#define pre_read() do { data_h(); clock_h(); udelay(5); } while (0)\r\n#define read_pin() (reg_read(lanai, Status_Reg) & STATUS_PROMDATA)\r\n#define send_stop() do { data_l(); udelay(5); clock_h(); udelay(5); \\r\ndata_h(); udelay(5); } while (0)\r\ndata_h(); clock_h(); udelay(5);\r\nfor (address = 0; address < LANAI_EEPROM_SIZE; address++) {\r\ndata = (address << 1) | 1;\r\ndata_l(); udelay(5);\r\nclock_l(); udelay(5);\r\nfor (i = 128; i != 0; i >>= 1) {\r\ntmp = (lanai->conf1 & ~CONFIG1_PROMDATA) |\r\n((data & i) ? CONFIG1_PROMDATA : 0);\r\nif (lanai->conf1 != tmp) {\r\nset_config1(tmp);\r\nudelay(5);\r\n}\r\nclock_h(); udelay(5); clock_l(); udelay(5);\r\n}\r\ndata_h(); clock_h(); udelay(5);\r\nif (read_pin() != 0)\r\ngoto error;\r\nclock_l(); udelay(5);\r\nfor (data = 0, i = 7; i >= 0; i--) {\r\ndata_h(); clock_h(); udelay(5);\r\ndata = (data << 1) | !!read_pin();\r\nclock_l(); udelay(5);\r\n}\r\ndata_h(); clock_h(); udelay(5);\r\nif (read_pin() == 0)\r\ngoto error;\r\nclock_l(); udelay(5);\r\nsend_stop();\r\nlanai->eeprom[address] = data;\r\nDPRINTK("EEPROM 0x%04X %02X\n",\r\n(unsigned int) address, (unsigned int) data);\r\n}\r\nreturn 0;\r\nerror:\r\nclock_l(); udelay(5);\r\nsend_stop();\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): error reading EEPROM byte %d\n",\r\nlanai->number, address);\r\nreturn -EIO;\r\n#undef set_config1\r\n#undef clock_h\r\n#undef clock_l\r\n#undef data_h\r\n#undef data_l\r\n#undef pre_read\r\n#undef read_pin\r\n#undef send_stop\r\n}\r\nstatic inline u32 eeprom_be4(const struct lanai_dev *lanai, int address)\r\n{\r\nreturn be32_to_cpup((const u32 *) &lanai->eeprom[address]);\r\n}\r\nstatic int __devinit eeprom_validate(struct lanai_dev *lanai)\r\n{\r\nint i, s;\r\nu32 v;\r\nconst u8 *e = lanai->eeprom;\r\n#ifdef DEBUG\r\nfor (i = EEPROM_COPYRIGHT;\r\ni < (EEPROM_COPYRIGHT + EEPROM_COPYRIGHT_LEN); i++)\r\nif (e[i] < 0x20 || e[i] > 0x7E)\r\nbreak;\r\nif ( i != EEPROM_COPYRIGHT &&\r\ni != EEPROM_COPYRIGHT + EEPROM_COPYRIGHT_LEN && e[i] == '\0')\r\nDPRINTK("eeprom: copyright = \"%s\"\n",\r\n(char *) &e[EEPROM_COPYRIGHT]);\r\nelse\r\nDPRINTK("eeprom: copyright not found\n");\r\n#endif\r\nfor (i = s = 0; i < EEPROM_CHECKSUM; i++)\r\ns += e[i];\r\ns &= 0xFF;\r\nif (s != e[EEPROM_CHECKSUM]) {\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): EEPROM checksum bad "\r\n"(wanted 0x%02X, got 0x%02X)\n", lanai->number,\r\n(unsigned int) s, (unsigned int) e[EEPROM_CHECKSUM]);\r\nreturn -EIO;\r\n}\r\ns ^= 0xFF;\r\nif (s != e[EEPROM_CHECKSUM_REV]) {\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): EEPROM inverse checksum "\r\n"bad (wanted 0x%02X, got 0x%02X)\n", lanai->number,\r\n(unsigned int) s, (unsigned int) e[EEPROM_CHECKSUM_REV]);\r\nreturn -EIO;\r\n}\r\nfor (i = 0; i < 6; i++)\r\nif ((e[EEPROM_MAC + i] ^ e[EEPROM_MAC_REV + i]) != 0xFF) {\r\nprintk(KERN_ERR DEV_LABEL\r\n"(itf %d) : EEPROM MAC addresses don't match "\r\n"(0x%02X, inverse 0x%02X)\n", lanai->number,\r\n(unsigned int) e[EEPROM_MAC + i],\r\n(unsigned int) e[EEPROM_MAC_REV + i]);\r\nreturn -EIO;\r\n}\r\nDPRINTK("eeprom: MAC address = %pM\n", &e[EEPROM_MAC]);\r\nlanai->serialno = eeprom_be4(lanai, EEPROM_SERIAL);\r\nv = eeprom_be4(lanai, EEPROM_SERIAL_REV);\r\nif ((lanai->serialno ^ v) != 0xFFFFFFFF) {\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): EEPROM serial numbers "\r\n"don't match (0x%08X, inverse 0x%08X)\n", lanai->number,\r\n(unsigned int) lanai->serialno, (unsigned int) v);\r\nreturn -EIO;\r\n}\r\nDPRINTK("eeprom: Serial number = %d\n", (unsigned int) lanai->serialno);\r\nlanai->magicno = eeprom_be4(lanai, EEPROM_MAGIC);\r\nv = eeprom_be4(lanai, EEPROM_MAGIC_REV);\r\nif ((lanai->magicno ^ v) != 0xFFFFFFFF) {\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): EEPROM magic numbers "\r\n"don't match (0x%08X, inverse 0x%08X)\n", lanai->number,\r\nlanai->magicno, v);\r\nreturn -EIO;\r\n}\r\nDPRINTK("eeprom: Magic number = 0x%08X\n", lanai->magicno);\r\nif (lanai->magicno != EEPROM_MAGIC_VALUE)\r\nprintk(KERN_WARNING DEV_LABEL "(itf %d): warning - EEPROM "\r\n"magic not what expected (got 0x%08X, not 0x%08X)\n",\r\nlanai->number, (unsigned int) lanai->magicno,\r\n(unsigned int) EEPROM_MAGIC_VALUE);\r\nreturn 0;\r\n}\r\nstatic inline const u8 *eeprom_mac(const struct lanai_dev *lanai)\r\n{\r\nreturn &lanai->eeprom[EEPROM_MAC];\r\n}\r\nstatic inline u32 intr_pending(const struct lanai_dev *lanai)\r\n{\r\nreturn reg_read(lanai, IntStatusMasked_Reg);\r\n}\r\nstatic inline void intr_enable(const struct lanai_dev *lanai, u32 i)\r\n{\r\nreg_write(lanai, i, IntControlEna_Reg);\r\n}\r\nstatic inline void intr_disable(const struct lanai_dev *lanai, u32 i)\r\n{\r\nreg_write(lanai, i, IntControlDis_Reg);\r\n}\r\nstatic void status_message(int itf, const char *name, int status)\r\n{\r\nstatic const char *onoff[2] = { "off to on", "on to off" };\r\nprintk(KERN_INFO DEV_LABEL "(itf %d): %s changed from %s\n",\r\nitf, name, onoff[!status]);\r\n}\r\nstatic void lanai_check_status(struct lanai_dev *lanai)\r\n{\r\nu32 new = reg_read(lanai, Status_Reg);\r\nu32 changes = new ^ lanai->status;\r\nlanai->status = new;\r\n#define e(flag, name) \\r\nif (changes & flag) \\r\nstatus_message(lanai->number, name, new & flag)\r\ne(STATUS_SOOL, "SOOL");\r\ne(STATUS_LOCD, "LOCD");\r\ne(STATUS_LED, "LED");\r\ne(STATUS_GPIN, "GPIN");\r\n#undef e\r\n}\r\nstatic void pcistatus_got(int itf, const char *name)\r\n{\r\nprintk(KERN_INFO DEV_LABEL "(itf %d): PCI got %s error\n", itf, name);\r\n}\r\nstatic void pcistatus_check(struct lanai_dev *lanai, int clearonly)\r\n{\r\nu16 s;\r\nint result;\r\nresult = pci_read_config_word(lanai->pci, PCI_STATUS, &s);\r\nif (result != PCIBIOS_SUCCESSFUL) {\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): can't read PCI_STATUS: "\r\n"%d\n", lanai->number, result);\r\nreturn;\r\n}\r\ns &= PCI_STATUS_DETECTED_PARITY | PCI_STATUS_SIG_SYSTEM_ERROR |\r\nPCI_STATUS_REC_MASTER_ABORT | PCI_STATUS_REC_TARGET_ABORT |\r\nPCI_STATUS_SIG_TARGET_ABORT | PCI_STATUS_PARITY;\r\nif (s == 0)\r\nreturn;\r\nresult = pci_write_config_word(lanai->pci, PCI_STATUS, s);\r\nif (result != PCIBIOS_SUCCESSFUL)\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): can't write PCI_STATUS: "\r\n"%d\n", lanai->number, result);\r\nif (clearonly)\r\nreturn;\r\n#define e(flag, name, stat) \\r\nif (s & flag) { \\r\npcistatus_got(lanai->number, name); \\r\n++lanai->stats.pcierr_##stat; \\r\n}\r\ne(PCI_STATUS_DETECTED_PARITY, "parity", parity_detect);\r\ne(PCI_STATUS_SIG_SYSTEM_ERROR, "signalled system", serr_set);\r\ne(PCI_STATUS_REC_MASTER_ABORT, "master", master_abort);\r\ne(PCI_STATUS_REC_TARGET_ABORT, "master target", m_target_abort);\r\ne(PCI_STATUS_SIG_TARGET_ABORT, "slave", s_target_abort);\r\ne(PCI_STATUS_PARITY, "master parity", master_parity);\r\n#undef e\r\n}\r\nstatic inline int vcc_tx_space(const struct lanai_vcc *lvcc, int endptr)\r\n{\r\nint r;\r\nr = endptr * 16;\r\nr -= ((unsigned long) lvcc->tx.buf.ptr) -\r\n((unsigned long) lvcc->tx.buf.start);\r\nr -= 16;\r\nif (r < 0)\r\nr += lanai_buf_size(&lvcc->tx.buf);\r\nreturn r;\r\n}\r\nstatic inline int vcc_is_backlogged(const struct lanai_vcc *lvcc)\r\n{\r\nreturn !skb_queue_empty(&lvcc->tx.backlog);\r\n}\r\nstatic inline void vcc_tx_add_aal5_descriptor(struct lanai_vcc *lvcc,\r\nu32 flags, int len)\r\n{\r\nint pos;\r\nAPRINTK((((unsigned long) lvcc->tx.buf.ptr) & 15) == 0,\r\n"vcc_tx_add_aal5_descriptor: bad ptr=%p\n", lvcc->tx.buf.ptr);\r\nlvcc->tx.buf.ptr += 4;\r\npos = ((unsigned char *) lvcc->tx.buf.ptr) -\r\n(unsigned char *) lvcc->tx.buf.start;\r\nAPRINTK((pos & ~0x0001FFF0) == 0,\r\n"vcc_tx_add_aal5_descriptor: bad pos (%d) before, vci=%d, "\r\n"start,ptr,end=%p,%p,%p\n", pos, lvcc->vci,\r\nlvcc->tx.buf.start, lvcc->tx.buf.ptr, lvcc->tx.buf.end);\r\npos = (pos + len) & (lanai_buf_size(&lvcc->tx.buf) - 1);\r\nAPRINTK((pos & ~0x0001FFF0) == 0,\r\n"vcc_tx_add_aal5_descriptor: bad pos (%d) after, vci=%d, "\r\n"start,ptr,end=%p,%p,%p\n", pos, lvcc->vci,\r\nlvcc->tx.buf.start, lvcc->tx.buf.ptr, lvcc->tx.buf.end);\r\nlvcc->tx.buf.ptr[-1] =\r\ncpu_to_le32(DESCRIPTOR_MAGIC | DESCRIPTOR_AAL5 |\r\n((lvcc->tx.atmvcc->atm_options & ATM_ATMOPT_CLP) ?\r\nDESCRIPTOR_CLP : 0) | flags | pos >> 4);\r\nif (lvcc->tx.buf.ptr >= lvcc->tx.buf.end)\r\nlvcc->tx.buf.ptr = lvcc->tx.buf.start;\r\n}\r\nstatic inline void vcc_tx_add_aal5_trailer(struct lanai_vcc *lvcc,\r\nint len, int cpi, int uu)\r\n{\r\nAPRINTK((((unsigned long) lvcc->tx.buf.ptr) & 15) == 8,\r\n"vcc_tx_add_aal5_trailer: bad ptr=%p\n", lvcc->tx.buf.ptr);\r\nlvcc->tx.buf.ptr += 2;\r\nlvcc->tx.buf.ptr[-2] = cpu_to_be32((uu << 24) | (cpi << 16) | len);\r\nif (lvcc->tx.buf.ptr >= lvcc->tx.buf.end)\r\nlvcc->tx.buf.ptr = lvcc->tx.buf.start;\r\n}\r\nstatic inline void vcc_tx_memcpy(struct lanai_vcc *lvcc,\r\nconst unsigned char *src, int n)\r\n{\r\nunsigned char *e;\r\nint m;\r\ne = ((unsigned char *) lvcc->tx.buf.ptr) + n;\r\nm = e - (unsigned char *) lvcc->tx.buf.end;\r\nif (m < 0)\r\nm = 0;\r\nmemcpy(lvcc->tx.buf.ptr, src, n - m);\r\nif (m != 0) {\r\nmemcpy(lvcc->tx.buf.start, src + n - m, m);\r\ne = ((unsigned char *) lvcc->tx.buf.start) + m;\r\n}\r\nlvcc->tx.buf.ptr = (u32 *) e;\r\n}\r\nstatic inline void vcc_tx_memzero(struct lanai_vcc *lvcc, int n)\r\n{\r\nunsigned char *e;\r\nint m;\r\nif (n == 0)\r\nreturn;\r\ne = ((unsigned char *) lvcc->tx.buf.ptr) + n;\r\nm = e - (unsigned char *) lvcc->tx.buf.end;\r\nif (m < 0)\r\nm = 0;\r\nmemset(lvcc->tx.buf.ptr, 0, n - m);\r\nif (m != 0) {\r\nmemset(lvcc->tx.buf.start, 0, m);\r\ne = ((unsigned char *) lvcc->tx.buf.start) + m;\r\n}\r\nlvcc->tx.buf.ptr = (u32 *) e;\r\n}\r\nstatic inline void lanai_endtx(struct lanai_dev *lanai,\r\nconst struct lanai_vcc *lvcc)\r\n{\r\nint i, ptr = ((unsigned char *) lvcc->tx.buf.ptr) -\r\n(unsigned char *) lvcc->tx.buf.start;\r\nAPRINTK((ptr & ~0x0001FFF0) == 0,\r\n"lanai_endtx: bad ptr (%d), vci=%d, start,ptr,end=%p,%p,%p\n",\r\nptr, lvcc->vci, lvcc->tx.buf.start, lvcc->tx.buf.ptr,\r\nlvcc->tx.buf.end);\r\nspin_lock(&lanai->endtxlock);\r\nfor (i = 0; reg_read(lanai, Status_Reg) & STATUS_BUTTBUSY; i++) {\r\nif (unlikely(i > 50)) {\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): butt register "\r\n"always busy!\n", lanai->number);\r\nbreak;\r\n}\r\nudelay(5);\r\n}\r\nwmb();\r\nreg_write(lanai, (ptr << 12) | lvcc->vci, Butt_Reg);\r\nspin_unlock(&lanai->endtxlock);\r\n}\r\nstatic void lanai_send_one_aal5(struct lanai_dev *lanai,\r\nstruct lanai_vcc *lvcc, struct sk_buff *skb, int pdusize)\r\n{\r\nint pad;\r\nAPRINTK(pdusize == aal5_size(skb->len),\r\n"lanai_send_one_aal5: wrong size packet (%d != %d)\n",\r\npdusize, aal5_size(skb->len));\r\nvcc_tx_add_aal5_descriptor(lvcc, 0, pdusize);\r\npad = pdusize - skb->len - 8;\r\nAPRINTK(pad >= 0, "pad is negative (%d)\n", pad);\r\nAPRINTK(pad < 48, "pad is too big (%d)\n", pad);\r\nvcc_tx_memcpy(lvcc, skb->data, skb->len);\r\nvcc_tx_memzero(lvcc, pad);\r\nvcc_tx_add_aal5_trailer(lvcc, skb->len, 0, 0);\r\nlanai_endtx(lanai, lvcc);\r\nlanai_free_skb(lvcc->tx.atmvcc, skb);\r\natomic_inc(&lvcc->tx.atmvcc->stats->tx);\r\n}\r\nstatic void vcc_tx_unqueue_aal5(struct lanai_dev *lanai,\r\nstruct lanai_vcc *lvcc, int endptr)\r\n{\r\nint n;\r\nstruct sk_buff *skb;\r\nint space = vcc_tx_space(lvcc, endptr);\r\nAPRINTK(vcc_is_backlogged(lvcc),\r\n"vcc_tx_unqueue() called with empty backlog (vci=%d)\n",\r\nlvcc->vci);\r\nwhile (space >= 64) {\r\nskb = skb_dequeue(&lvcc->tx.backlog);\r\nif (skb == NULL)\r\ngoto no_backlog;\r\nn = aal5_size(skb->len);\r\nif (n + 16 > space) {\r\nskb_queue_head(&lvcc->tx.backlog, skb);\r\nreturn;\r\n}\r\nlanai_send_one_aal5(lanai, lvcc, skb, n);\r\nspace -= n + 16;\r\n}\r\nif (!vcc_is_backlogged(lvcc)) {\r\nno_backlog:\r\n__clear_bit(lvcc->vci, lanai->backlog_vccs);\r\n}\r\n}\r\nstatic void vcc_tx_aal5(struct lanai_dev *lanai, struct lanai_vcc *lvcc,\r\nstruct sk_buff *skb)\r\n{\r\nint space, n;\r\nif (vcc_is_backlogged(lvcc))\r\ngoto queue_it;\r\nspace = vcc_tx_space(lvcc,\r\nTXREADPTR_GET_PTR(cardvcc_read(lvcc, vcc_txreadptr)));\r\nn = aal5_size(skb->len);\r\nAPRINTK(n + 16 >= 64, "vcc_tx_aal5: n too small (%d)\n", n);\r\nif (space < n + 16) {\r\n__set_bit(lvcc->vci, lanai->backlog_vccs);\r\nqueue_it:\r\nskb_queue_tail(&lvcc->tx.backlog, skb);\r\nreturn;\r\n}\r\nlanai_send_one_aal5(lanai, lvcc, skb, n);\r\n}\r\nstatic void vcc_tx_unqueue_aal0(struct lanai_dev *lanai,\r\nstruct lanai_vcc *lvcc, int endptr)\r\n{\r\nprintk(KERN_INFO DEV_LABEL\r\n": vcc_tx_unqueue_aal0: not implemented\n");\r\n}\r\nstatic void vcc_tx_aal0(struct lanai_dev *lanai, struct lanai_vcc *lvcc,\r\nstruct sk_buff *skb)\r\n{\r\nprintk(KERN_INFO DEV_LABEL ": vcc_tx_aal0: not implemented\n");\r\nlanai_free_skb(lvcc->tx.atmvcc, skb);\r\n}\r\nstatic inline void vcc_rx_memcpy(unsigned char *dest,\r\nconst struct lanai_vcc *lvcc, int n)\r\n{\r\nint m = ((const unsigned char *) lvcc->rx.buf.ptr) + n -\r\n((const unsigned char *) (lvcc->rx.buf.end));\r\nif (m < 0)\r\nm = 0;\r\nmemcpy(dest, lvcc->rx.buf.ptr, n - m);\r\nmemcpy(dest + n - m, lvcc->rx.buf.start, m);\r\nbarrier();\r\n}\r\nstatic void vcc_rx_aal5(struct lanai_vcc *lvcc, int endptr)\r\n{\r\nint size;\r\nstruct sk_buff *skb;\r\nconst u32 *x;\r\nu32 *end = &lvcc->rx.buf.start[endptr * 4];\r\nint n = ((unsigned long) end) - ((unsigned long) lvcc->rx.buf.ptr);\r\nif (n < 0)\r\nn += lanai_buf_size(&lvcc->rx.buf);\r\nAPRINTK(n >= 0 && n < lanai_buf_size(&lvcc->rx.buf) && !(n & 15),\r\n"vcc_rx_aal5: n out of range (%d/%Zu)\n",\r\nn, lanai_buf_size(&lvcc->rx.buf));\r\nif ((x = &end[-2]) < lvcc->rx.buf.start)\r\nx = &lvcc->rx.buf.end[-2];\r\nrmb();\r\nsize = be32_to_cpup(x) & 0xffff;\r\nif (unlikely(n != aal5_size(size))) {\r\nprintk(KERN_INFO DEV_LABEL "(itf %d): Got bad AAL5 length "\r\n"on vci=%d - size=%d n=%d\n",\r\nlvcc->rx.atmvcc->dev->number, lvcc->vci, size, n);\r\nlvcc->stats.x.aal5.rx_badlen++;\r\ngoto out;\r\n}\r\nskb = atm_alloc_charge(lvcc->rx.atmvcc, size, GFP_ATOMIC);\r\nif (unlikely(skb == NULL)) {\r\nlvcc->stats.rx_nomem++;\r\ngoto out;\r\n}\r\nskb_put(skb, size);\r\nvcc_rx_memcpy(skb->data, lvcc, size);\r\nATM_SKB(skb)->vcc = lvcc->rx.atmvcc;\r\n__net_timestamp(skb);\r\nlvcc->rx.atmvcc->push(lvcc->rx.atmvcc, skb);\r\natomic_inc(&lvcc->rx.atmvcc->stats->rx);\r\nout:\r\nlvcc->rx.buf.ptr = end;\r\ncardvcc_write(lvcc, endptr, vcc_rxreadptr);\r\n}\r\nstatic void vcc_rx_aal0(struct lanai_dev *lanai)\r\n{\r\nprintk(KERN_INFO DEV_LABEL ": vcc_rx_aal0: not implemented\n");\r\n}\r\nstatic int __devinit vcc_table_allocate(struct lanai_dev *lanai)\r\n{\r\n#ifdef VCCTABLE_GETFREEPAGE\r\nAPRINTK((lanai->num_vci) * sizeof(struct lanai_vcc *) <= PAGE_SIZE,\r\n"vcc table > PAGE_SIZE!");\r\nlanai->vccs = (struct lanai_vcc **) get_zeroed_page(GFP_KERNEL);\r\nreturn (lanai->vccs == NULL) ? -ENOMEM : 0;\r\n#else\r\nint bytes = (lanai->num_vci) * sizeof(struct lanai_vcc *);\r\nlanai->vccs = vzalloc(bytes);\r\nif (unlikely(lanai->vccs == NULL))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n#endif\r\n}\r\nstatic inline void vcc_table_deallocate(const struct lanai_dev *lanai)\r\n{\r\n#ifdef VCCTABLE_GETFREEPAGE\r\nfree_page((unsigned long) lanai->vccs);\r\n#else\r\nvfree(lanai->vccs);\r\n#endif\r\n}\r\nstatic inline struct lanai_vcc *new_lanai_vcc(void)\r\n{\r\nstruct lanai_vcc *lvcc;\r\nlvcc = kzalloc(sizeof(*lvcc), GFP_KERNEL);\r\nif (likely(lvcc != NULL)) {\r\nskb_queue_head_init(&lvcc->tx.backlog);\r\n#ifdef DEBUG\r\nlvcc->vci = -1;\r\n#endif\r\n}\r\nreturn lvcc;\r\n}\r\nstatic int lanai_get_sized_buffer(struct lanai_dev *lanai,\r\nstruct lanai_buffer *buf, int max_sdu, int multiplier,\r\nconst char *name)\r\n{\r\nint size;\r\nif (unlikely(max_sdu < 1))\r\nmax_sdu = 1;\r\nmax_sdu = aal5_size(max_sdu);\r\nsize = (max_sdu + 16) * multiplier + 16;\r\nlanai_buf_allocate(buf, size, max_sdu + 32, lanai->pci);\r\nif (unlikely(buf->start == NULL))\r\nreturn -ENOMEM;\r\nif (unlikely(lanai_buf_size(buf) < size))\r\nprintk(KERN_WARNING DEV_LABEL "(itf %d): wanted %d bytes "\r\n"for %s buffer, got only %Zu\n", lanai->number, size,\r\nname, lanai_buf_size(buf));\r\nDPRINTK("Allocated %Zu byte %s buffer\n", lanai_buf_size(buf), name);\r\nreturn 0;\r\n}\r\nstatic inline int lanai_setup_rx_vci_aal5(struct lanai_dev *lanai,\r\nstruct lanai_vcc *lvcc, const struct atm_qos *qos)\r\n{\r\nreturn lanai_get_sized_buffer(lanai, &lvcc->rx.buf,\r\nqos->rxtp.max_sdu, AAL5_RX_MULTIPLIER, "RX");\r\n}\r\nstatic int lanai_setup_tx_vci(struct lanai_dev *lanai, struct lanai_vcc *lvcc,\r\nconst struct atm_qos *qos)\r\n{\r\nint max_sdu, multiplier;\r\nif (qos->aal == ATM_AAL0) {\r\nlvcc->tx.unqueue = vcc_tx_unqueue_aal0;\r\nmax_sdu = ATM_CELL_SIZE - 1;\r\nmultiplier = AAL0_TX_MULTIPLIER;\r\n} else {\r\nlvcc->tx.unqueue = vcc_tx_unqueue_aal5;\r\nmax_sdu = qos->txtp.max_sdu;\r\nmultiplier = AAL5_TX_MULTIPLIER;\r\n}\r\nreturn lanai_get_sized_buffer(lanai, &lvcc->tx.buf, max_sdu,\r\nmultiplier, "TX");\r\n}\r\nstatic inline void host_vcc_bind(struct lanai_dev *lanai,\r\nstruct lanai_vcc *lvcc, vci_t vci)\r\n{\r\nif (lvcc->vbase != NULL)\r\nreturn;\r\nDPRINTK("Binding vci %d\n", vci);\r\n#ifdef USE_POWERDOWN\r\nif (lanai->nbound++ == 0) {\r\nDPRINTK("Coming out of powerdown\n");\r\nlanai->conf1 &= ~CONFIG1_POWERDOWN;\r\nconf1_write(lanai);\r\nconf2_write(lanai);\r\n}\r\n#endif\r\nlvcc->vbase = cardvcc_addr(lanai, vci);\r\nlanai->vccs[lvcc->vci = vci] = lvcc;\r\n}\r\nstatic inline void host_vcc_unbind(struct lanai_dev *lanai,\r\nstruct lanai_vcc *lvcc)\r\n{\r\nif (lvcc->vbase == NULL)\r\nreturn;\r\nDPRINTK("Unbinding vci %d\n", lvcc->vci);\r\nlvcc->vbase = NULL;\r\nlanai->vccs[lvcc->vci] = NULL;\r\n#ifdef USE_POWERDOWN\r\nif (--lanai->nbound == 0) {\r\nDPRINTK("Going into powerdown\n");\r\nlanai->conf1 |= CONFIG1_POWERDOWN;\r\nconf1_write(lanai);\r\n}\r\n#endif\r\n}\r\nstatic void lanai_reset(struct lanai_dev *lanai)\r\n{\r\nprintk(KERN_CRIT DEV_LABEL "(itf %d): *NOT* reseting - not "\r\n"implemented\n", lanai->number);\r\nreg_write(lanai, INT_ALL, IntAck_Reg);\r\nlanai->stats.card_reset++;\r\n}\r\nstatic int __devinit service_buffer_allocate(struct lanai_dev *lanai)\r\n{\r\nlanai_buf_allocate(&lanai->service, SERVICE_ENTRIES * 4, 8,\r\nlanai->pci);\r\nif (unlikely(lanai->service.start == NULL))\r\nreturn -ENOMEM;\r\nDPRINTK("allocated service buffer at 0x%08lX, size %Zu(%d)\n",\r\n(unsigned long) lanai->service.start,\r\nlanai_buf_size(&lanai->service),\r\nlanai_buf_size_cardorder(&lanai->service));\r\nreg_write(lanai, 0, ServWrite_Reg);\r\nreg_write(lanai,\r\nSSTUFF_SET_SIZE(lanai_buf_size_cardorder(&lanai->service)) |\r\nSSTUFF_SET_ADDR(lanai->service.dmaaddr),\r\nServiceStuff_Reg);\r\nreturn 0;\r\n}\r\nstatic inline void service_buffer_deallocate(struct lanai_dev *lanai)\r\n{\r\nlanai_buf_deallocate(&lanai->service, lanai->pci);\r\n}\r\nstatic int handle_service(struct lanai_dev *lanai, u32 s)\r\n{\r\nvci_t vci = SERVICE_GET_VCI(s);\r\nstruct lanai_vcc *lvcc;\r\nread_lock(&vcc_sklist_lock);\r\nlvcc = lanai->vccs[vci];\r\nif (unlikely(lvcc == NULL)) {\r\nread_unlock(&vcc_sklist_lock);\r\nDPRINTK("(itf %d) got service entry 0x%X for nonexistent "\r\n"vcc %d\n", lanai->number, (unsigned int) s, vci);\r\nif (s & SERVICE_TX)\r\nlanai->stats.service_notx++;\r\nelse\r\nlanai->stats.service_norx++;\r\nreturn 0;\r\n}\r\nif (s & SERVICE_TX) {\r\nif (unlikely(lvcc->tx.atmvcc == NULL)) {\r\nread_unlock(&vcc_sklist_lock);\r\nDPRINTK("(itf %d) got service entry 0x%X for non-TX "\r\n"vcc %d\n", lanai->number, (unsigned int) s, vci);\r\nlanai->stats.service_notx++;\r\nreturn 0;\r\n}\r\n__set_bit(vci, lanai->transmit_ready);\r\nlvcc->tx.endptr = SERVICE_GET_END(s);\r\nread_unlock(&vcc_sklist_lock);\r\nreturn 1;\r\n}\r\nif (unlikely(lvcc->rx.atmvcc == NULL)) {\r\nread_unlock(&vcc_sklist_lock);\r\nDPRINTK("(itf %d) got service entry 0x%X for non-RX "\r\n"vcc %d\n", lanai->number, (unsigned int) s, vci);\r\nlanai->stats.service_norx++;\r\nreturn 0;\r\n}\r\nif (unlikely(lvcc->rx.atmvcc->qos.aal != ATM_AAL5)) {\r\nread_unlock(&vcc_sklist_lock);\r\nDPRINTK("(itf %d) got RX service entry 0x%X for non-AAL5 "\r\n"vcc %d\n", lanai->number, (unsigned int) s, vci);\r\nlanai->stats.service_rxnotaal5++;\r\natomic_inc(&lvcc->rx.atmvcc->stats->rx_err);\r\nreturn 0;\r\n}\r\nif (likely(!(s & (SERVICE_TRASH | SERVICE_STREAM | SERVICE_CRCERR)))) {\r\nvcc_rx_aal5(lvcc, SERVICE_GET_END(s));\r\nread_unlock(&vcc_sklist_lock);\r\nreturn 0;\r\n}\r\nif (s & SERVICE_TRASH) {\r\nint bytes;\r\nread_unlock(&vcc_sklist_lock);\r\nDPRINTK("got trashed rx pdu on vci %d\n", vci);\r\natomic_inc(&lvcc->rx.atmvcc->stats->rx_err);\r\nlvcc->stats.x.aal5.service_trash++;\r\nbytes = (SERVICE_GET_END(s) * 16) -\r\n(((unsigned long) lvcc->rx.buf.ptr) -\r\n((unsigned long) lvcc->rx.buf.start)) + 47;\r\nif (bytes < 0)\r\nbytes += lanai_buf_size(&lvcc->rx.buf);\r\nlanai->stats.ovfl_trash += (bytes / 48);\r\nreturn 0;\r\n}\r\nif (s & SERVICE_STREAM) {\r\nread_unlock(&vcc_sklist_lock);\r\natomic_inc(&lvcc->rx.atmvcc->stats->rx_err);\r\nlvcc->stats.x.aal5.service_stream++;\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): Got AAL5 stream "\r\n"PDU on VCI %d!\n", lanai->number, vci);\r\nlanai_reset(lanai);\r\nreturn 0;\r\n}\r\nDPRINTK("got rx crc error on vci %d\n", vci);\r\natomic_inc(&lvcc->rx.atmvcc->stats->rx_err);\r\nlvcc->stats.x.aal5.service_rxcrc++;\r\nlvcc->rx.buf.ptr = &lvcc->rx.buf.start[SERVICE_GET_END(s) * 4];\r\ncardvcc_write(lvcc, SERVICE_GET_END(s), vcc_rxreadptr);\r\nread_unlock(&vcc_sklist_lock);\r\nreturn 0;\r\n}\r\nstatic void iter_transmit(struct lanai_dev *lanai, vci_t vci)\r\n{\r\nstruct lanai_vcc *lvcc = lanai->vccs[vci];\r\nif (vcc_is_backlogged(lvcc))\r\nlvcc->tx.unqueue(lanai, lvcc, lvcc->tx.endptr);\r\n}\r\nstatic void run_service(struct lanai_dev *lanai)\r\n{\r\nint ntx = 0;\r\nu32 wreg = reg_read(lanai, ServWrite_Reg);\r\nconst u32 *end = lanai->service.start + wreg;\r\nwhile (lanai->service.ptr != end) {\r\nntx += handle_service(lanai,\r\nle32_to_cpup(lanai->service.ptr++));\r\nif (lanai->service.ptr >= lanai->service.end)\r\nlanai->service.ptr = lanai->service.start;\r\n}\r\nreg_write(lanai, wreg, ServRead_Reg);\r\nif (ntx != 0) {\r\nread_lock(&vcc_sklist_lock);\r\nvci_bitfield_iterate(lanai, lanai->transmit_ready,\r\niter_transmit);\r\nbitmap_zero(lanai->transmit_ready, NUM_VCI);\r\nread_unlock(&vcc_sklist_lock);\r\n}\r\n}\r\nstatic void get_statistics(struct lanai_dev *lanai)\r\n{\r\nu32 statreg = reg_read(lanai, Statistics_Reg);\r\nlanai->stats.atm_ovfl += STATS_GET_FIFO_OVFL(statreg);\r\nlanai->stats.hec_err += STATS_GET_HEC_ERR(statreg);\r\nlanai->stats.vci_trash += STATS_GET_BAD_VCI(statreg);\r\nlanai->stats.ovfl_trash += STATS_GET_BUF_OVFL(statreg);\r\n}\r\nstatic void iter_dequeue(struct lanai_dev *lanai, vci_t vci)\r\n{\r\nstruct lanai_vcc *lvcc = lanai->vccs[vci];\r\nint endptr;\r\nif (lvcc == NULL || lvcc->tx.atmvcc == NULL ||\r\n!vcc_is_backlogged(lvcc)) {\r\n__clear_bit(vci, lanai->backlog_vccs);\r\nreturn;\r\n}\r\nendptr = TXREADPTR_GET_PTR(cardvcc_read(lvcc, vcc_txreadptr));\r\nlvcc->tx.unqueue(lanai, lvcc, endptr);\r\n}\r\nstatic void lanai_timed_poll(unsigned long arg)\r\n{\r\nstruct lanai_dev *lanai = (struct lanai_dev *) arg;\r\n#ifndef DEBUG_RW\r\nunsigned long flags;\r\n#ifdef USE_POWERDOWN\r\nif (lanai->conf1 & CONFIG1_POWERDOWN)\r\nreturn;\r\n#endif\r\nlocal_irq_save(flags);\r\nif (spin_trylock(&lanai->servicelock)) {\r\nrun_service(lanai);\r\nspin_unlock(&lanai->servicelock);\r\n}\r\nread_lock(&vcc_sklist_lock);\r\nvci_bitfield_iterate(lanai, lanai->backlog_vccs, iter_dequeue);\r\nread_unlock(&vcc_sklist_lock);\r\nlocal_irq_restore(flags);\r\nget_statistics(lanai);\r\n#endif\r\nmod_timer(&lanai->timer, jiffies + LANAI_POLL_PERIOD);\r\n}\r\nstatic inline void lanai_timed_poll_start(struct lanai_dev *lanai)\r\n{\r\ninit_timer(&lanai->timer);\r\nlanai->timer.expires = jiffies + LANAI_POLL_PERIOD;\r\nlanai->timer.data = (unsigned long) lanai;\r\nlanai->timer.function = lanai_timed_poll;\r\nadd_timer(&lanai->timer);\r\n}\r\nstatic inline void lanai_timed_poll_stop(struct lanai_dev *lanai)\r\n{\r\ndel_timer_sync(&lanai->timer);\r\n}\r\nstatic inline void lanai_int_1(struct lanai_dev *lanai, u32 reason)\r\n{\r\nu32 ack = 0;\r\nif (reason & INT_SERVICE) {\r\nack = INT_SERVICE;\r\nspin_lock(&lanai->servicelock);\r\nrun_service(lanai);\r\nspin_unlock(&lanai->servicelock);\r\n}\r\nif (reason & (INT_AAL0_STR | INT_AAL0)) {\r\nack |= reason & (INT_AAL0_STR | INT_AAL0);\r\nvcc_rx_aal0(lanai);\r\n}\r\nif (ack == reason)\r\ngoto done;\r\nif (reason & INT_STATS) {\r\nreason &= ~INT_STATS;\r\nget_statistics(lanai);\r\n}\r\nif (reason & INT_STATUS) {\r\nack |= reason & INT_STATUS;\r\nlanai_check_status(lanai);\r\n}\r\nif (unlikely(reason & INT_DMASHUT)) {\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): driver error - DMA "\r\n"shutdown, reason=0x%08X, address=0x%08X\n",\r\nlanai->number, (unsigned int) (reason & INT_DMASHUT),\r\n(unsigned int) reg_read(lanai, DMA_Addr_Reg));\r\nif (reason & INT_TABORTBM) {\r\nlanai_reset(lanai);\r\nreturn;\r\n}\r\nack |= (reason & INT_DMASHUT);\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): re-enabling DMA\n",\r\nlanai->number);\r\nconf1_write(lanai);\r\nlanai->stats.dma_reenable++;\r\npcistatus_check(lanai, 0);\r\n}\r\nif (unlikely(reason & INT_TABORTSENT)) {\r\nack |= (reason & INT_TABORTSENT);\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): sent PCI target abort\n",\r\nlanai->number);\r\npcistatus_check(lanai, 0);\r\n}\r\nif (unlikely(reason & INT_SEGSHUT)) {\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): driver error - "\r\n"segmentation shutdown, reason=0x%08X\n", lanai->number,\r\n(unsigned int) (reason & INT_SEGSHUT));\r\nlanai_reset(lanai);\r\nreturn;\r\n}\r\nif (unlikely(reason & (INT_PING | INT_WAKE))) {\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): driver error - "\r\n"unexpected interrupt 0x%08X, resetting\n",\r\nlanai->number,\r\n(unsigned int) (reason & (INT_PING | INT_WAKE)));\r\nlanai_reset(lanai);\r\nreturn;\r\n}\r\n#ifdef DEBUG\r\nif (unlikely(ack != reason)) {\r\nDPRINTK("unacked ints: 0x%08X\n",\r\n(unsigned int) (reason & ~ack));\r\nack = reason;\r\n}\r\n#endif\r\ndone:\r\nif (ack != 0)\r\nreg_write(lanai, ack, IntAck_Reg);\r\n}\r\nstatic irqreturn_t lanai_int(int irq, void *devid)\r\n{\r\nstruct lanai_dev *lanai = devid;\r\nu32 reason;\r\n#ifdef USE_POWERDOWN\r\nif (unlikely(lanai->conf1 & CONFIG1_POWERDOWN))\r\nreturn IRQ_NONE;\r\n#endif\r\nreason = intr_pending(lanai);\r\nif (reason == 0)\r\nreturn IRQ_NONE;\r\ndo {\r\nif (unlikely(reason == 0xFFFFFFFF))\r\nbreak;\r\nlanai_int_1(lanai, reason);\r\nreason = intr_pending(lanai);\r\n} while (reason != 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int check_board_id_and_rev(const char *name, u32 val, int *revp)\r\n{\r\nDPRINTK("%s says board_id=%d, board_rev=%d\n", name,\r\n(int) RESET_GET_BOARD_ID(val),\r\n(int) RESET_GET_BOARD_REV(val));\r\nif (RESET_GET_BOARD_ID(val) != BOARD_ID_LANAI256) {\r\nprintk(KERN_ERR DEV_LABEL ": Found %s board-id %d -- not a "\r\n"Lanai 25.6\n", name, (int) RESET_GET_BOARD_ID(val));\r\nreturn -ENODEV;\r\n}\r\nif (revp != NULL)\r\n*revp = RESET_GET_BOARD_REV(val);\r\nreturn 0;\r\n}\r\nstatic int __devinit lanai_pci_start(struct lanai_dev *lanai)\r\n{\r\nstruct pci_dev *pci = lanai->pci;\r\nint result;\r\nif (pci_enable_device(pci) != 0) {\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): can't enable "\r\n"PCI device", lanai->number);\r\nreturn -ENXIO;\r\n}\r\npci_set_master(pci);\r\nif (pci_set_dma_mask(pci, DMA_BIT_MASK(32)) != 0) {\r\nprintk(KERN_WARNING DEV_LABEL\r\n"(itf %d): No suitable DMA available.\n", lanai->number);\r\nreturn -EBUSY;\r\n}\r\nif (pci_set_consistent_dma_mask(pci, DMA_BIT_MASK(32)) != 0) {\r\nprintk(KERN_WARNING DEV_LABEL\r\n"(itf %d): No suitable DMA available.\n", lanai->number);\r\nreturn -EBUSY;\r\n}\r\nresult = check_board_id_and_rev("PCI", pci->subsystem_device, NULL);\r\nif (result != 0)\r\nreturn result;\r\nresult = pci_write_config_byte(pci, PCI_LATENCY_TIMER, 0);\r\nif (result != PCIBIOS_SUCCESSFUL) {\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): can't write "\r\n"PCI_LATENCY_TIMER: %d\n", lanai->number, result);\r\nreturn -EINVAL;\r\n}\r\npcistatus_check(lanai, 1);\r\npcistatus_check(lanai, 0);\r\nreturn 0;\r\n}\r\nstatic inline int vci0_is_ok(struct lanai_dev *lanai,\r\nconst struct atm_qos *qos)\r\n{\r\nif (qos->txtp.traffic_class == ATM_CBR || qos->aal == ATM_AAL0)\r\nreturn 0;\r\nif (qos->rxtp.traffic_class != ATM_NONE) {\r\nif (lanai->naal0 != 0)\r\nreturn 0;\r\nlanai->conf2 |= CONFIG2_VCI0_NORMAL;\r\nconf2_write_if_powerup(lanai);\r\n}\r\nreturn 1;\r\n}\r\nstatic int vci_is_ok(struct lanai_dev *lanai, vci_t vci,\r\nconst struct atm_vcc *atmvcc)\r\n{\r\nconst struct atm_qos *qos = &atmvcc->qos;\r\nconst struct lanai_vcc *lvcc = lanai->vccs[vci];\r\nif (vci == 0 && !vci0_is_ok(lanai, qos))\r\nreturn 0;\r\nif (unlikely(lvcc != NULL)) {\r\nif (qos->rxtp.traffic_class != ATM_NONE &&\r\nlvcc->rx.atmvcc != NULL && lvcc->rx.atmvcc != atmvcc)\r\nreturn 0;\r\nif (qos->txtp.traffic_class != ATM_NONE &&\r\nlvcc->tx.atmvcc != NULL && lvcc->tx.atmvcc != atmvcc)\r\nreturn 0;\r\nif (qos->txtp.traffic_class == ATM_CBR &&\r\nlanai->cbrvcc != NULL && lanai->cbrvcc != atmvcc)\r\nreturn 0;\r\n}\r\nif (qos->aal == ATM_AAL0 && lanai->naal0 == 0 &&\r\nqos->rxtp.traffic_class != ATM_NONE) {\r\nconst struct lanai_vcc *vci0 = lanai->vccs[0];\r\nif (vci0 != NULL && vci0->rx.atmvcc != NULL)\r\nreturn 0;\r\nlanai->conf2 &= ~CONFIG2_VCI0_NORMAL;\r\nconf2_write_if_powerup(lanai);\r\n}\r\nreturn 1;\r\n}\r\nstatic int lanai_normalize_ci(struct lanai_dev *lanai,\r\nconst struct atm_vcc *atmvcc, short *vpip, vci_t *vcip)\r\n{\r\nswitch (*vpip) {\r\ncase ATM_VPI_ANY:\r\n*vpip = 0;\r\ncase 0:\r\nbreak;\r\ndefault:\r\nreturn -EADDRINUSE;\r\n}\r\nswitch (*vcip) {\r\ncase ATM_VCI_ANY:\r\nfor (*vcip = ATM_NOT_RSV_VCI; *vcip < lanai->num_vci;\r\n(*vcip)++)\r\nif (vci_is_ok(lanai, *vcip, atmvcc))\r\nreturn 0;\r\nreturn -EADDRINUSE;\r\ndefault:\r\nif (*vcip >= lanai->num_vci || *vcip < 0 ||\r\n!vci_is_ok(lanai, *vcip, atmvcc))\r\nreturn -EADDRINUSE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcr_to_cbricg(const struct atm_qos *qos)\r\n{\r\nint rounddown = 0;\r\nint x, icg, pcr = atm_pcr_goal(&qos->txtp);\r\nif (pcr == 0)\r\nreturn 0;\r\nif (pcr < 0) {\r\nrounddown = 1;\r\npcr = -pcr;\r\n}\r\nx = pcr * 27;\r\nicg = (3125 << (9 + CBRICG_FRAC_BITS)) - (x << CBRICG_FRAC_BITS);\r\nif (rounddown)\r\nicg += x - 1;\r\nicg /= x;\r\nif (icg > CBRICG_MAX)\r\nicg = CBRICG_MAX;\r\nDPRINTK("pcr_to_cbricg: pcr=%d rounddown=%c icg=%d\n",\r\npcr, rounddown ? 'Y' : 'N', icg);\r\nreturn icg;\r\n}\r\nstatic inline void lanai_cbr_setup(struct lanai_dev *lanai)\r\n{\r\nreg_write(lanai, pcr_to_cbricg(&lanai->cbrvcc->qos), CBR_ICG_Reg);\r\nreg_write(lanai, lanai->cbrvcc->vci, CBR_PTR_Reg);\r\nlanai->conf2 |= CONFIG2_CBR_ENABLE;\r\nconf2_write(lanai);\r\n}\r\nstatic inline void lanai_cbr_shutdown(struct lanai_dev *lanai)\r\n{\r\nlanai->conf2 &= ~CONFIG2_CBR_ENABLE;\r\nconf2_write(lanai);\r\n}\r\nstatic int __devinit lanai_dev_open(struct atm_dev *atmdev)\r\n{\r\nstruct lanai_dev *lanai = (struct lanai_dev *) atmdev->dev_data;\r\nunsigned long raw_base;\r\nint result;\r\nDPRINTK("In lanai_dev_open()\n");\r\nlanai->number = atmdev->number;\r\nlanai->num_vci = NUM_VCI;\r\nbitmap_zero(lanai->backlog_vccs, NUM_VCI);\r\nbitmap_zero(lanai->transmit_ready, NUM_VCI);\r\nlanai->naal0 = 0;\r\n#ifdef USE_POWERDOWN\r\nlanai->nbound = 0;\r\n#endif\r\nlanai->cbrvcc = NULL;\r\nmemset(&lanai->stats, 0, sizeof lanai->stats);\r\nspin_lock_init(&lanai->endtxlock);\r\nspin_lock_init(&lanai->servicelock);\r\natmdev->ci_range.vpi_bits = 0;\r\natmdev->ci_range.vci_bits = 0;\r\nwhile (1 << atmdev->ci_range.vci_bits < lanai->num_vci)\r\natmdev->ci_range.vci_bits++;\r\natmdev->link_rate = ATM_25_PCR;\r\nif ((result = lanai_pci_start(lanai)) != 0)\r\ngoto error;\r\nraw_base = lanai->pci->resource[0].start;\r\nlanai->base = (bus_addr_t) ioremap(raw_base, LANAI_MAPPING_SIZE);\r\nif (lanai->base == NULL) {\r\nprintk(KERN_ERR DEV_LABEL ": couldn't remap I/O space\n");\r\ngoto error_pci;\r\n}\r\nreset_board(lanai);\r\nlanai->conf1 = reg_read(lanai, Config1_Reg);\r\nlanai->conf1 &= ~(CONFIG1_GPOUT1 | CONFIG1_POWERDOWN |\r\nCONFIG1_MASK_LEDMODE);\r\nlanai->conf1 |= CONFIG1_SET_LEDMODE(LEDMODE_NOT_SOOL);\r\nreg_write(lanai, lanai->conf1 | CONFIG1_GPOUT1, Config1_Reg);\r\nudelay(1000);\r\nconf1_write(lanai);\r\nresult = check_board_id_and_rev("register",\r\nreg_read(lanai, Reset_Reg), &lanai->board_rev);\r\nif (result != 0)\r\ngoto error_unmap;\r\nif ((result = eeprom_read(lanai)) != 0)\r\ngoto error_unmap;\r\nif ((result = eeprom_validate(lanai)) != 0)\r\ngoto error_unmap;\r\nreg_write(lanai, lanai->conf1 | CONFIG1_GPOUT1, Config1_Reg);\r\nudelay(1000);\r\nconf1_write(lanai);\r\nlanai->conf1 |= (CONFIG1_GPOUT2 | CONFIG1_GPOUT3 | CONFIG1_DMA_ENABLE);\r\nconf1_write(lanai);\r\nif ((result = sram_test_and_clear(lanai)) != 0)\r\ngoto error_unmap;\r\nlanai->conf1 |= CONFIG1_DMA_ENABLE;\r\nconf1_write(lanai);\r\nif ((result = service_buffer_allocate(lanai)) != 0)\r\ngoto error_unmap;\r\nif ((result = vcc_table_allocate(lanai)) != 0)\r\ngoto error_service;\r\nlanai->conf2 = (lanai->num_vci >= 512 ? CONFIG2_HOWMANY : 0) |\r\nCONFIG2_HEC_DROP | CONFIG2_PTI7_MODE;\r\nconf2_write(lanai);\r\nreg_write(lanai, TX_FIFO_DEPTH, TxDepth_Reg);\r\nreg_write(lanai, 0, CBR_ICG_Reg);\r\nif ((result = request_irq(lanai->pci->irq, lanai_int, IRQF_SHARED,\r\nDEV_LABEL, lanai)) != 0) {\r\nprintk(KERN_ERR DEV_LABEL ": can't allocate interrupt\n");\r\ngoto error_vcctable;\r\n}\r\nmb();\r\nintr_enable(lanai, INT_ALL & ~(INT_PING | INT_WAKE));\r\nlanai->conf1 = (lanai->conf1 & ~CONFIG1_MASK_LOOPMODE) |\r\nCONFIG1_SET_LOOPMODE(LOOPMODE_NORMAL) |\r\nCONFIG1_GPOUT2 | CONFIG1_GPOUT3;\r\nconf1_write(lanai);\r\nlanai->status = reg_read(lanai, Status_Reg);\r\n#ifdef USE_POWERDOWN\r\nlanai->conf1 |= CONFIG1_POWERDOWN;\r\nconf1_write(lanai);\r\n#endif\r\nmemcpy(atmdev->esi, eeprom_mac(lanai), ESI_LEN);\r\nlanai_timed_poll_start(lanai);\r\nprintk(KERN_NOTICE DEV_LABEL "(itf %d): rev.%d, base=0x%lx, irq=%u "\r\n"(%pMF)\n", lanai->number, (int) lanai->pci->revision,\r\n(unsigned long) lanai->base, lanai->pci->irq, atmdev->esi);\r\nprintk(KERN_NOTICE DEV_LABEL "(itf %d): LANAI%s, serialno=%u(0x%X), "\r\n"board_rev=%d\n", lanai->number,\r\nlanai->type==lanai2 ? "2" : "HB", (unsigned int) lanai->serialno,\r\n(unsigned int) lanai->serialno, lanai->board_rev);\r\nreturn 0;\r\nerror_vcctable:\r\nvcc_table_deallocate(lanai);\r\nerror_service:\r\nservice_buffer_deallocate(lanai);\r\nerror_unmap:\r\nreset_board(lanai);\r\n#ifdef USE_POWERDOWN\r\nlanai->conf1 = reg_read(lanai, Config1_Reg) | CONFIG1_POWERDOWN;\r\nconf1_write(lanai);\r\n#endif\r\niounmap(lanai->base);\r\nerror_pci:\r\npci_disable_device(lanai->pci);\r\nerror:\r\nreturn result;\r\n}\r\nstatic void lanai_dev_close(struct atm_dev *atmdev)\r\n{\r\nstruct lanai_dev *lanai = (struct lanai_dev *) atmdev->dev_data;\r\nprintk(KERN_INFO DEV_LABEL "(itf %d): shutting down interface\n",\r\nlanai->number);\r\nlanai_timed_poll_stop(lanai);\r\n#ifdef USE_POWERDOWN\r\nlanai->conf1 = reg_read(lanai, Config1_Reg) & ~CONFIG1_POWERDOWN;\r\nconf1_write(lanai);\r\n#endif\r\nintr_disable(lanai, INT_ALL);\r\nfree_irq(lanai->pci->irq, lanai);\r\nreset_board(lanai);\r\n#ifdef USE_POWERDOWN\r\nlanai->conf1 |= CONFIG1_POWERDOWN;\r\nconf1_write(lanai);\r\n#endif\r\npci_disable_device(lanai->pci);\r\nvcc_table_deallocate(lanai);\r\nservice_buffer_deallocate(lanai);\r\niounmap(lanai->base);\r\nkfree(lanai);\r\n}\r\nstatic void lanai_close(struct atm_vcc *atmvcc)\r\n{\r\nstruct lanai_vcc *lvcc = (struct lanai_vcc *) atmvcc->dev_data;\r\nstruct lanai_dev *lanai = (struct lanai_dev *) atmvcc->dev->dev_data;\r\nif (lvcc == NULL)\r\nreturn;\r\nclear_bit(ATM_VF_READY, &atmvcc->flags);\r\nclear_bit(ATM_VF_PARTIAL, &atmvcc->flags);\r\nif (lvcc->rx.atmvcc == atmvcc) {\r\nlanai_shutdown_rx_vci(lvcc);\r\nif (atmvcc->qos.aal == ATM_AAL0) {\r\nif (--lanai->naal0 <= 0)\r\naal0_buffer_free(lanai);\r\n} else\r\nlanai_buf_deallocate(&lvcc->rx.buf, lanai->pci);\r\nlvcc->rx.atmvcc = NULL;\r\n}\r\nif (lvcc->tx.atmvcc == atmvcc) {\r\nif (atmvcc == lanai->cbrvcc) {\r\nif (lvcc->vbase != NULL)\r\nlanai_cbr_shutdown(lanai);\r\nlanai->cbrvcc = NULL;\r\n}\r\nlanai_shutdown_tx_vci(lanai, lvcc);\r\nlanai_buf_deallocate(&lvcc->tx.buf, lanai->pci);\r\nlvcc->tx.atmvcc = NULL;\r\n}\r\nif (--lvcc->nref == 0) {\r\nhost_vcc_unbind(lanai, lvcc);\r\nkfree(lvcc);\r\n}\r\natmvcc->dev_data = NULL;\r\nclear_bit(ATM_VF_ADDR, &atmvcc->flags);\r\n}\r\nstatic int lanai_open(struct atm_vcc *atmvcc)\r\n{\r\nstruct lanai_dev *lanai;\r\nstruct lanai_vcc *lvcc;\r\nint result = 0;\r\nint vci = atmvcc->vci;\r\nshort vpi = atmvcc->vpi;\r\nif ((test_bit(ATM_VF_PARTIAL, &atmvcc->flags)) ||\r\n(vpi == ATM_VPI_UNSPEC) || (vci == ATM_VCI_UNSPEC))\r\nreturn -EINVAL;\r\nlanai = (struct lanai_dev *) atmvcc->dev->dev_data;\r\nresult = lanai_normalize_ci(lanai, atmvcc, &vpi, &vci);\r\nif (unlikely(result != 0))\r\ngoto out;\r\nset_bit(ATM_VF_ADDR, &atmvcc->flags);\r\nif (atmvcc->qos.aal != ATM_AAL0 && atmvcc->qos.aal != ATM_AAL5)\r\nreturn -EINVAL;\r\nDPRINTK(DEV_LABEL "(itf %d): open %d.%d\n", lanai->number,\r\n(int) vpi, vci);\r\nlvcc = lanai->vccs[vci];\r\nif (lvcc == NULL) {\r\nlvcc = new_lanai_vcc();\r\nif (unlikely(lvcc == NULL))\r\nreturn -ENOMEM;\r\natmvcc->dev_data = lvcc;\r\n}\r\nlvcc->nref++;\r\nif (atmvcc->qos.rxtp.traffic_class != ATM_NONE) {\r\nAPRINTK(lvcc->rx.atmvcc == NULL, "rx.atmvcc!=NULL, vci=%d\n",\r\nvci);\r\nif (atmvcc->qos.aal == ATM_AAL0) {\r\nif (lanai->naal0 == 0)\r\nresult = aal0_buffer_allocate(lanai);\r\n} else\r\nresult = lanai_setup_rx_vci_aal5(\r\nlanai, lvcc, &atmvcc->qos);\r\nif (unlikely(result != 0))\r\ngoto out_free;\r\nlvcc->rx.atmvcc = atmvcc;\r\nlvcc->stats.rx_nomem = 0;\r\nlvcc->stats.x.aal5.rx_badlen = 0;\r\nlvcc->stats.x.aal5.service_trash = 0;\r\nlvcc->stats.x.aal5.service_stream = 0;\r\nlvcc->stats.x.aal5.service_rxcrc = 0;\r\nif (atmvcc->qos.aal == ATM_AAL0)\r\nlanai->naal0++;\r\n}\r\nif (atmvcc->qos.txtp.traffic_class != ATM_NONE) {\r\nAPRINTK(lvcc->tx.atmvcc == NULL, "tx.atmvcc!=NULL, vci=%d\n",\r\nvci);\r\nresult = lanai_setup_tx_vci(lanai, lvcc, &atmvcc->qos);\r\nif (unlikely(result != 0))\r\ngoto out_free;\r\nlvcc->tx.atmvcc = atmvcc;\r\nif (atmvcc->qos.txtp.traffic_class == ATM_CBR) {\r\nAPRINTK(lanai->cbrvcc == NULL,\r\n"cbrvcc!=NULL, vci=%d\n", vci);\r\nlanai->cbrvcc = atmvcc;\r\n}\r\n}\r\nhost_vcc_bind(lanai, lvcc, vci);\r\nwmb();\r\nif (atmvcc == lvcc->rx.atmvcc)\r\nhost_vcc_start_rx(lvcc);\r\nif (atmvcc == lvcc->tx.atmvcc) {\r\nhost_vcc_start_tx(lvcc);\r\nif (lanai->cbrvcc == atmvcc)\r\nlanai_cbr_setup(lanai);\r\n}\r\nset_bit(ATM_VF_READY, &atmvcc->flags);\r\nreturn 0;\r\nout_free:\r\nlanai_close(atmvcc);\r\nout:\r\nreturn result;\r\n}\r\nstatic int lanai_send(struct atm_vcc *atmvcc, struct sk_buff *skb)\r\n{\r\nstruct lanai_vcc *lvcc = (struct lanai_vcc *) atmvcc->dev_data;\r\nstruct lanai_dev *lanai = (struct lanai_dev *) atmvcc->dev->dev_data;\r\nunsigned long flags;\r\nif (unlikely(lvcc == NULL || lvcc->vbase == NULL ||\r\nlvcc->tx.atmvcc != atmvcc))\r\ngoto einval;\r\n#ifdef DEBUG\r\nif (unlikely(skb == NULL)) {\r\nDPRINTK("lanai_send: skb==NULL for vci=%d\n", atmvcc->vci);\r\ngoto einval;\r\n}\r\nif (unlikely(lanai == NULL)) {\r\nDPRINTK("lanai_send: lanai==NULL for vci=%d\n", atmvcc->vci);\r\ngoto einval;\r\n}\r\n#endif\r\nATM_SKB(skb)->vcc = atmvcc;\r\nswitch (atmvcc->qos.aal) {\r\ncase ATM_AAL5:\r\nread_lock_irqsave(&vcc_sklist_lock, flags);\r\nvcc_tx_aal5(lanai, lvcc, skb);\r\nread_unlock_irqrestore(&vcc_sklist_lock, flags);\r\nreturn 0;\r\ncase ATM_AAL0:\r\nif (unlikely(skb->len != ATM_CELL_SIZE-1))\r\ngoto einval;\r\ncpu_to_be32s((u32 *) skb->data);\r\nread_lock_irqsave(&vcc_sklist_lock, flags);\r\nvcc_tx_aal0(lanai, lvcc, skb);\r\nread_unlock_irqrestore(&vcc_sklist_lock, flags);\r\nreturn 0;\r\n}\r\nDPRINTK("lanai_send: bad aal=%d on vci=%d\n", (int) atmvcc->qos.aal,\r\natmvcc->vci);\r\neinval:\r\nlanai_free_skb(atmvcc, skb);\r\nreturn -EINVAL;\r\n}\r\nstatic int lanai_change_qos(struct atm_vcc *atmvcc,\r\nstruct atm_qos *qos, int flags)\r\n{\r\nreturn -EBUSY;\r\n}\r\nstatic int lanai_proc_read(struct atm_dev *atmdev, loff_t *pos, char *page)\r\n{\r\nstruct lanai_dev *lanai = (struct lanai_dev *) atmdev->dev_data;\r\nloff_t left = *pos;\r\nstruct lanai_vcc *lvcc;\r\nif (left-- == 0)\r\nreturn sprintf(page, DEV_LABEL "(itf %d): chip=LANAI%s, "\r\n"serial=%u, magic=0x%08X, num_vci=%d\n",\r\natmdev->number, lanai->type==lanai2 ? "2" : "HB",\r\n(unsigned int) lanai->serialno,\r\n(unsigned int) lanai->magicno, lanai->num_vci);\r\nif (left-- == 0)\r\nreturn sprintf(page, "revision: board=%d, pci_if=%d\n",\r\nlanai->board_rev, (int) lanai->pci->revision);\r\nif (left-- == 0)\r\nreturn sprintf(page, "EEPROM ESI: %pM\n",\r\n&lanai->eeprom[EEPROM_MAC]);\r\nif (left-- == 0)\r\nreturn sprintf(page, "status: SOOL=%d, LOCD=%d, LED=%d, "\r\n"GPIN=%d\n", (lanai->status & STATUS_SOOL) ? 1 : 0,\r\n(lanai->status & STATUS_LOCD) ? 1 : 0,\r\n(lanai->status & STATUS_LED) ? 1 : 0,\r\n(lanai->status & STATUS_GPIN) ? 1 : 0);\r\nif (left-- == 0)\r\nreturn sprintf(page, "global buffer sizes: service=%Zu, "\r\n"aal0_rx=%Zu\n", lanai_buf_size(&lanai->service),\r\nlanai->naal0 ? lanai_buf_size(&lanai->aal0buf) : 0);\r\nif (left-- == 0) {\r\nget_statistics(lanai);\r\nreturn sprintf(page, "cells in error: overflow=%u, "\r\n"closed_vci=%u, bad_HEC=%u, rx_fifo=%u\n",\r\nlanai->stats.ovfl_trash, lanai->stats.vci_trash,\r\nlanai->stats.hec_err, lanai->stats.atm_ovfl);\r\n}\r\nif (left-- == 0)\r\nreturn sprintf(page, "PCI errors: parity_detect=%u, "\r\n"master_abort=%u, master_target_abort=%u,\n",\r\nlanai->stats.pcierr_parity_detect,\r\nlanai->stats.pcierr_serr_set,\r\nlanai->stats.pcierr_m_target_abort);\r\nif (left-- == 0)\r\nreturn sprintf(page, " slave_target_abort=%u, "\r\n"master_parity=%u\n", lanai->stats.pcierr_s_target_abort,\r\nlanai->stats.pcierr_master_parity);\r\nif (left-- == 0)\r\nreturn sprintf(page, " no_tx=%u, "\r\n"no_rx=%u, bad_rx_aal=%u\n", lanai->stats.service_norx,\r\nlanai->stats.service_notx,\r\nlanai->stats.service_rxnotaal5);\r\nif (left-- == 0)\r\nreturn sprintf(page, "resets: dma=%u, card=%u\n",\r\nlanai->stats.dma_reenable, lanai->stats.card_reset);\r\nread_lock(&vcc_sklist_lock);\r\nfor (; ; left++) {\r\nif (left >= NUM_VCI) {\r\nleft = 0;\r\ngoto out;\r\n}\r\nif ((lvcc = lanai->vccs[left]) != NULL)\r\nbreak;\r\n(*pos)++;\r\n}\r\nleft = sprintf(page, "VCI %4d: nref=%d, rx_nomem=%u", (vci_t) left,\r\nlvcc->nref, lvcc->stats.rx_nomem);\r\nif (lvcc->rx.atmvcc != NULL) {\r\nleft += sprintf(&page[left], ",\n rx_AAL=%d",\r\nlvcc->rx.atmvcc->qos.aal == ATM_AAL5 ? 5 : 0);\r\nif (lvcc->rx.atmvcc->qos.aal == ATM_AAL5)\r\nleft += sprintf(&page[left], ", rx_buf_size=%Zu, "\r\n"rx_bad_len=%u,\n rx_service_trash=%u, "\r\n"rx_service_stream=%u, rx_bad_crc=%u",\r\nlanai_buf_size(&lvcc->rx.buf),\r\nlvcc->stats.x.aal5.rx_badlen,\r\nlvcc->stats.x.aal5.service_trash,\r\nlvcc->stats.x.aal5.service_stream,\r\nlvcc->stats.x.aal5.service_rxcrc);\r\n}\r\nif (lvcc->tx.atmvcc != NULL)\r\nleft += sprintf(&page[left], ",\n tx_AAL=%d, "\r\n"tx_buf_size=%Zu, tx_qos=%cBR, tx_backlogged=%c",\r\nlvcc->tx.atmvcc->qos.aal == ATM_AAL5 ? 5 : 0,\r\nlanai_buf_size(&lvcc->tx.buf),\r\nlvcc->tx.atmvcc == lanai->cbrvcc ? 'C' : 'U',\r\nvcc_is_backlogged(lvcc) ? 'Y' : 'N');\r\npage[left++] = '\n';\r\npage[left] = '\0';\r\nout:\r\nread_unlock(&vcc_sklist_lock);\r\nreturn left;\r\n}\r\nstatic int __devinit lanai_init_one(struct pci_dev *pci,\r\nconst struct pci_device_id *ident)\r\n{\r\nstruct lanai_dev *lanai;\r\nstruct atm_dev *atmdev;\r\nint result;\r\nlanai = kmalloc(sizeof(*lanai), GFP_KERNEL);\r\nif (lanai == NULL) {\r\nprintk(KERN_ERR DEV_LABEL\r\n": couldn't allocate dev_data structure!\n");\r\nreturn -ENOMEM;\r\n}\r\natmdev = atm_dev_register(DEV_LABEL, &pci->dev, &ops, -1, NULL);\r\nif (atmdev == NULL) {\r\nprintk(KERN_ERR DEV_LABEL\r\n": couldn't register atm device!\n");\r\nkfree(lanai);\r\nreturn -EBUSY;\r\n}\r\natmdev->dev_data = lanai;\r\nlanai->pci = pci;\r\nlanai->type = (enum lanai_type) ident->device;\r\nresult = lanai_dev_open(atmdev);\r\nif (result != 0) {\r\nDPRINTK("lanai_start() failed, err=%d\n", -result);\r\natm_dev_deregister(atmdev);\r\nkfree(lanai);\r\n}\r\nreturn result;\r\n}\r\nstatic int __init lanai_module_init(void)\r\n{\r\nint x;\r\nx = pci_register_driver(&lanai_driver);\r\nif (x != 0)\r\nprintk(KERN_ERR DEV_LABEL ": no adapter found\n");\r\nreturn x;\r\n}\r\nstatic void __exit lanai_module_exit(void)\r\n{\r\nDPRINTK("cleanup_module()\n");\r\npci_unregister_driver(&lanai_driver);\r\n}
