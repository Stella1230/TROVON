static long probe_kernel_write_odd(void *dst, const void *src, size_t size)\r\n{\r\nunsigned long count, aligned;\r\nint offset, mask;\r\nint rc = -EFAULT;\r\naligned = (unsigned long) dst & ~3UL;\r\noffset = (unsigned long) dst & 3;\r\ncount = min_t(unsigned long, 4 - offset, size);\r\nmask = (0xf << (4 - count)) & 0xf;\r\nmask >>= offset;\r\nasm volatile(\r\n" bras 1,0f\n"\r\n" icm 0,0,0(%3)\n"\r\n"0: l 0,0(%1)\n"\r\n" lra %1,0(%1)\n"\r\n"1: ex %2,0(1)\n"\r\n"2: stura 0,%1\n"\r\n" la %0,0\n"\r\n"3:\n"\r\nEX_TABLE(0b,3b) EX_TABLE(1b,3b) EX_TABLE(2b,3b)\r\n: "+d" (rc), "+a" (aligned)\r\n: "a" (mask), "a" (src) : "cc", "memory", "0", "1");\r\nreturn rc ? rc : count;\r\n}\r\nlong probe_kernel_write(void *dst, const void *src, size_t size)\r\n{\r\nlong copied = 0;\r\nwhile (size) {\r\ncopied = probe_kernel_write_odd(dst, src, size);\r\nif (copied < 0)\r\nbreak;\r\ndst += copied;\r\nsrc += copied;\r\nsize -= copied;\r\n}\r\nreturn copied < 0 ? -EFAULT : 0;\r\n}\r\nint memcpy_real(void *dest, void *src, size_t count)\r\n{\r\nregister unsigned long _dest asm("2") = (unsigned long) dest;\r\nregister unsigned long _len1 asm("3") = (unsigned long) count;\r\nregister unsigned long _src asm("4") = (unsigned long) src;\r\nregister unsigned long _len2 asm("5") = (unsigned long) count;\r\nunsigned long flags;\r\nint rc = -EFAULT;\r\nif (!count)\r\nreturn 0;\r\nflags = __arch_local_irq_stnsm(0xf8UL);\r\nasm volatile (\r\n"0: mvcle %1,%2,0x0\n"\r\n"1: jo 0b\n"\r\n" lhi %0,0x0\n"\r\n"2:\n"\r\nEX_TABLE(1b,2b)\r\n: "+d" (rc), "+d" (_dest), "+d" (_src), "+d" (_len1),\r\n"+d" (_len2), "=m" (*((long *) dest))\r\n: "m" (*((long *) src))\r\n: "cc", "memory");\r\narch_local_irq_restore(flags);\r\nreturn rc;\r\n}\r\nvoid copy_to_absolute_zero(void *dest, void *src, size_t count)\r\n{\r\nunsigned long cr0;\r\nBUG_ON((unsigned long) dest + count >= sizeof(struct _lowcore));\r\npreempt_disable();\r\n__ctl_store(cr0, 0, 0);\r\n__ctl_clear_bit(0, 28);\r\nmemcpy_real(dest + store_prefix(), src, count);\r\n__ctl_load(cr0, 0, 0);\r\npreempt_enable();\r\n}\r\nint copy_to_user_real(void __user *dest, void *src, size_t count)\r\n{\r\nint offs = 0, size, rc;\r\nchar *buf;\r\nbuf = (char *) __get_free_page(GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nrc = -EFAULT;\r\nwhile (offs < count) {\r\nsize = min(PAGE_SIZE, count - offs);\r\nif (memcpy_real(buf, src + offs, size))\r\ngoto out;\r\nif (copy_to_user(dest + offs, buf, size))\r\ngoto out;\r\noffs += size;\r\n}\r\nrc = 0;\r\nout:\r\nfree_page((unsigned long) buf);\r\nreturn rc;\r\n}\r\nint copy_from_user_real(void *dest, void __user *src, size_t count)\r\n{\r\nint offs = 0, size, rc;\r\nchar *buf;\r\nbuf = (char *) __get_free_page(GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nrc = -EFAULT;\r\nwhile (offs < count) {\r\nsize = min(PAGE_SIZE, count - offs);\r\nif (copy_from_user(buf, src + offs, size))\r\ngoto out;\r\nif (memcpy_real(dest + offs, buf, size))\r\ngoto out;\r\noffs += size;\r\n}\r\nrc = 0;\r\nout:\r\nfree_page((unsigned long) buf);\r\nreturn rc;\r\n}
