static struct HvLpEvent * get_next_hvlpevent(void)\r\n{\r\nstruct HvLpEvent * event;\r\nevent = (struct HvLpEvent *)hvlpevent_queue.hq_current_event;\r\nif (hvlpevent_is_valid(event)) {\r\nrmb();\r\nhvlpevent_queue.hq_current_event += ((event->xSizeMinus1 +\r\nIT_LP_EVENT_ALIGN) / IT_LP_EVENT_ALIGN) *\r\nIT_LP_EVENT_ALIGN;\r\nif (hvlpevent_queue.hq_current_event >\r\nhvlpevent_queue.hq_last_event) {\r\nhvlpevent_queue.hq_current_event =\r\nhvlpevent_queue.hq_event_stack;\r\n}\r\n} else {\r\nevent = NULL;\r\n}\r\nreturn event;\r\n}\r\nint hvlpevent_is_pending(void)\r\n{\r\nstruct HvLpEvent *next_event;\r\nif (smp_processor_id() >= spread_lpevents)\r\nreturn 0;\r\nnext_event = (struct HvLpEvent *)hvlpevent_queue.hq_current_event;\r\nreturn hvlpevent_is_valid(next_event) ||\r\nhvlpevent_queue.hq_overflow_pending;\r\n}\r\nstatic void hvlpevent_clear_valid(struct HvLpEvent * event)\r\n{\r\nstruct HvLpEvent *tmp;\r\nunsigned extra = ((event->xSizeMinus1 + IT_LP_EVENT_ALIGN) /\r\nIT_LP_EVENT_ALIGN) - 1;\r\nswitch (extra) {\r\ncase 3:\r\ntmp = (struct HvLpEvent*)((char*)event + 3 * IT_LP_EVENT_ALIGN);\r\nhvlpevent_invalidate(tmp);\r\ncase 2:\r\ntmp = (struct HvLpEvent*)((char*)event + 2 * IT_LP_EVENT_ALIGN);\r\nhvlpevent_invalidate(tmp);\r\ncase 1:\r\ntmp = (struct HvLpEvent*)((char*)event + 1 * IT_LP_EVENT_ALIGN);\r\nhvlpevent_invalidate(tmp);\r\n}\r\nmb();\r\nhvlpevent_invalidate(event);\r\n}\r\nvoid process_hvlpevents(void)\r\n{\r\nstruct HvLpEvent * event;\r\nrestart:\r\nif (!spin_trylock(&hvlpevent_queue.hq_lock))\r\nreturn;\r\nfor (;;) {\r\nevent = get_next_hvlpevent();\r\nif (event) {\r\nif (event->xType < HvLpEvent_Type_NumTypes)\r\n__get_cpu_var(hvlpevent_counts)[event->xType]++;\r\nif (event->xType < HvLpEvent_Type_NumTypes &&\r\nlpEventHandler[event->xType])\r\nlpEventHandler[event->xType](event);\r\nelse {\r\nu8 type = event->xType;\r\nhvlpevent_clear_valid(event);\r\nspin_unlock(&hvlpevent_queue.hq_lock);\r\nprintk(KERN_INFO\r\n"Unexpected Lp Event type=%d\n", type);\r\ngoto restart;\r\n}\r\nhvlpevent_clear_valid(event);\r\n} else if (hvlpevent_queue.hq_overflow_pending)\r\nHvCallEvent_getOverflowLpEvents(hvlpevent_queue.hq_index);\r\nelse\r\nbreak;\r\n}\r\nspin_unlock(&hvlpevent_queue.hq_lock);\r\n}\r\nstatic int set_spread_lpevents(char *str)\r\n{\r\nunsigned long val = simple_strtoul(str, NULL, 0);\r\nif (( val > 0) && (val <= NR_CPUS)) {\r\nspread_lpevents = val;\r\nprintk("lpevent processing spread over %ld processors\n", val);\r\n} else {\r\nprintk("invalid spread_lpevents %ld\n", val);\r\n}\r\nreturn 1;\r\n}\r\nvoid __init setup_hvlpevent_queue(void)\r\n{\r\nvoid *eventStack;\r\nspin_lock_init(&hvlpevent_queue.hq_lock);\r\neventStack = alloc_bootmem_pages(IT_LP_EVENT_STACK_SIZE);\r\nmemset(eventStack, 0, IT_LP_EVENT_STACK_SIZE);\r\nHvCallEvent_setLpEventStack(0, eventStack, IT_LP_EVENT_STACK_SIZE);\r\nhvlpevent_queue.hq_event_stack = eventStack;\r\nhvlpevent_queue.hq_current_event = eventStack;\r\nhvlpevent_queue.hq_last_event = (char *)eventStack +\r\n(IT_LP_EVENT_STACK_SIZE - IT_LP_EVENT_MAX_SIZE);\r\nhvlpevent_queue.hq_index = 0;\r\n}\r\nint HvLpEvent_registerHandler(HvLpEvent_Type eventType, LpEventHandler handler)\r\n{\r\nif (eventType < HvLpEvent_Type_NumTypes) {\r\nlpEventHandler[eventType] = handler;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nint HvLpEvent_unregisterHandler(HvLpEvent_Type eventType)\r\n{\r\nmight_sleep();\r\nif (eventType < HvLpEvent_Type_NumTypes) {\r\nif (!lpEventHandlerPaths[eventType]) {\r\nlpEventHandler[eventType] = NULL;\r\nsynchronize_sched();\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nint HvLpEvent_openPath(HvLpEvent_Type eventType, HvLpIndex lpIndex)\r\n{\r\nif ((eventType < HvLpEvent_Type_NumTypes) &&\r\nlpEventHandler[eventType]) {\r\nif (lpIndex == 0)\r\nlpIndex = itLpNaca.xLpIndex;\r\nHvCallEvent_openLpEventPath(lpIndex, eventType);\r\n++lpEventHandlerPaths[eventType];\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nint HvLpEvent_closePath(HvLpEvent_Type eventType, HvLpIndex lpIndex)\r\n{\r\nif ((eventType < HvLpEvent_Type_NumTypes) &&\r\nlpEventHandler[eventType] &&\r\nlpEventHandlerPaths[eventType]) {\r\nif (lpIndex == 0)\r\nlpIndex = itLpNaca.xLpIndex;\r\nHvCallEvent_closeLpEventPath(lpIndex, eventType);\r\n--lpEventHandlerPaths[eventType];\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int proc_lpevents_show(struct seq_file *m, void *v)\r\n{\r\nint cpu, i;\r\nunsigned long sum;\r\nstatic unsigned long cpu_totals[NR_CPUS];\r\nsum = 0;\r\nfor_each_online_cpu(cpu) {\r\ncpu_totals[cpu] = 0;\r\nfor (i = 0; i < HvLpEvent_Type_NumTypes; i++) {\r\ncpu_totals[cpu] += per_cpu(hvlpevent_counts, cpu)[i];\r\n}\r\nsum += cpu_totals[cpu];\r\n}\r\nseq_printf(m, "LpEventQueue 0\n");\r\nseq_printf(m, " events processed:\t%lu\n", sum);\r\nfor (i = 0; i < HvLpEvent_Type_NumTypes; ++i) {\r\nsum = 0;\r\nfor_each_online_cpu(cpu) {\r\nsum += per_cpu(hvlpevent_counts, cpu)[i];\r\n}\r\nseq_printf(m, " %-20s %10lu\n", event_types[i], sum);\r\n}\r\nseq_printf(m, "\n events processed by processor:\n");\r\nfor_each_online_cpu(cpu) {\r\nseq_printf(m, " CPU%02d %10lu\n", cpu, cpu_totals[cpu]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int proc_lpevents_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, proc_lpevents_show, NULL);\r\n}\r\nstatic int __init proc_lpevents_init(void)\r\n{\r\nif (!firmware_has_feature(FW_FEATURE_ISERIES))\r\nreturn 0;\r\nproc_create("iSeries/lpevents", S_IFREG|S_IRUGO, NULL,\r\n&proc_lpevents_operations);\r\nreturn 0;\r\n}
