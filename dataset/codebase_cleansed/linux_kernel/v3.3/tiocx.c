static int tiocx_match(struct device *dev, struct device_driver *drv)\r\n{\r\nstruct cx_dev *cx_dev = to_cx_dev(dev);\r\nstruct cx_drv *cx_drv = to_cx_driver(drv);\r\nconst struct cx_device_id *ids = cx_drv->id_table;\r\nif (!ids)\r\nreturn 0;\r\nwhile (ids->part_num) {\r\nif (ids->part_num == cx_dev->cx_id.part_num)\r\nreturn 1;\r\nids++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tiocx_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic void tiocx_bus_release(struct device *dev)\r\n{\r\nkfree(to_cx_dev(dev));\r\n}\r\nstatic const struct cx_device_id *cx_device_match(const struct cx_device_id\r\n*ids,\r\nstruct cx_dev *cx_device)\r\n{\r\nwhile (ids->part_num && ids->mfg_num) {\r\nif (ids->part_num == cx_device->cx_id.part_num &&\r\nids->mfg_num == cx_device->cx_id.mfg_num)\r\nreturn ids;\r\nids++;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int cx_device_probe(struct device *dev)\r\n{\r\nconst struct cx_device_id *id;\r\nstruct cx_drv *cx_drv = to_cx_driver(dev->driver);\r\nstruct cx_dev *cx_dev = to_cx_dev(dev);\r\nint error = 0;\r\nif (!cx_dev->driver && cx_drv->probe) {\r\nid = cx_device_match(cx_drv->id_table, cx_dev);\r\nif (id) {\r\nif ((error = cx_drv->probe(cx_dev, id)) < 0)\r\nreturn error;\r\nelse\r\ncx_dev->driver = cx_drv;\r\n}\r\n}\r\nreturn error;\r\n}\r\nstatic int cx_driver_remove(struct device *dev)\r\n{\r\nstruct cx_dev *cx_dev = to_cx_dev(dev);\r\nstruct cx_drv *cx_drv = cx_dev->driver;\r\nif (cx_drv->remove)\r\ncx_drv->remove(cx_dev);\r\ncx_dev->driver = NULL;\r\nreturn 0;\r\n}\r\nint cx_driver_register(struct cx_drv *cx_driver)\r\n{\r\ncx_driver->driver.name = cx_driver->name;\r\ncx_driver->driver.bus = &tiocx_bus_type;\r\nreturn driver_register(&cx_driver->driver);\r\n}\r\nint cx_driver_unregister(struct cx_drv *cx_driver)\r\n{\r\ndriver_unregister(&cx_driver->driver);\r\nreturn 0;\r\n}\r\nint\r\ncx_device_register(nasid_t nasid, int part_num, int mfg_num,\r\nstruct hubdev_info *hubdev, int bt)\r\n{\r\nstruct cx_dev *cx_dev;\r\ncx_dev = kzalloc(sizeof(struct cx_dev), GFP_KERNEL);\r\nDBG("cx_dev= 0x%p\n", cx_dev);\r\nif (cx_dev == NULL)\r\nreturn -ENOMEM;\r\ncx_dev->cx_id.part_num = part_num;\r\ncx_dev->cx_id.mfg_num = mfg_num;\r\ncx_dev->cx_id.nasid = nasid;\r\ncx_dev->hubdev = hubdev;\r\ncx_dev->bt = bt;\r\ncx_dev->dev.parent = NULL;\r\ncx_dev->dev.bus = &tiocx_bus_type;\r\ncx_dev->dev.release = tiocx_bus_release;\r\ndev_set_name(&cx_dev->dev, "%d", cx_dev->cx_id.nasid);\r\ndevice_register(&cx_dev->dev);\r\nget_device(&cx_dev->dev);\r\ndevice_create_file(&cx_dev->dev, &dev_attr_cxdev_control);\r\nreturn 0;\r\n}\r\nint cx_device_unregister(struct cx_dev *cx_dev)\r\n{\r\nput_device(&cx_dev->dev);\r\ndevice_unregister(&cx_dev->dev);\r\nreturn 0;\r\n}\r\nstatic int cx_device_reload(struct cx_dev *cx_dev)\r\n{\r\ncx_device_unregister(cx_dev);\r\nreturn cx_device_register(cx_dev->cx_id.nasid, cx_dev->cx_id.part_num,\r\ncx_dev->cx_id.mfg_num, cx_dev->hubdev,\r\ncx_dev->bt);\r\n}\r\nstatic inline u64 tiocx_intr_alloc(nasid_t nasid, int widget,\r\nu64 sn_irq_info,\r\nint req_irq, nasid_t req_nasid,\r\nint req_slice)\r\n{\r\nstruct ia64_sal_retval rv;\r\nrv.status = 0;\r\nrv.v0 = 0;\r\nia64_sal_oemcall_nolock(&rv, SN_SAL_IOIF_INTERRUPT,\r\nSAL_INTR_ALLOC, nasid,\r\nwidget, sn_irq_info, req_irq,\r\nreq_nasid, req_slice);\r\nreturn rv.status;\r\n}\r\nstatic inline void tiocx_intr_free(nasid_t nasid, int widget,\r\nstruct sn_irq_info *sn_irq_info)\r\n{\r\nstruct ia64_sal_retval rv;\r\nrv.status = 0;\r\nrv.v0 = 0;\r\nia64_sal_oemcall_nolock(&rv, SN_SAL_IOIF_INTERRUPT,\r\nSAL_INTR_FREE, nasid,\r\nwidget, sn_irq_info->irq_irq,\r\nsn_irq_info->irq_cookie, 0, 0);\r\n}\r\nstruct sn_irq_info *tiocx_irq_alloc(nasid_t nasid, int widget, int irq,\r\nnasid_t req_nasid, int slice)\r\n{\r\nstruct sn_irq_info *sn_irq_info;\r\nint status;\r\nint sn_irq_size = sizeof(struct sn_irq_info);\r\nif ((nasid & 1) == 0)\r\nreturn NULL;\r\nsn_irq_info = kzalloc(sn_irq_size, GFP_KERNEL);\r\nif (sn_irq_info == NULL)\r\nreturn NULL;\r\nstatus = tiocx_intr_alloc(nasid, widget, __pa(sn_irq_info), irq,\r\nreq_nasid, slice);\r\nif (status) {\r\nkfree(sn_irq_info);\r\nreturn NULL;\r\n} else {\r\nreturn sn_irq_info;\r\n}\r\n}\r\nvoid tiocx_irq_free(struct sn_irq_info *sn_irq_info)\r\n{\r\nu64 bridge = (u64) sn_irq_info->irq_bridge;\r\nnasid_t nasid = NASID_GET(bridge);\r\nint widget;\r\nif (nasid & 1) {\r\nwidget = TIO_SWIN_WIDGETNUM(bridge);\r\ntiocx_intr_free(nasid, widget, sn_irq_info);\r\nkfree(sn_irq_info);\r\n}\r\n}\r\nu64 tiocx_dma_addr(u64 addr)\r\n{\r\nreturn PHYS_TO_TIODMA(addr);\r\n}\r\nu64 tiocx_swin_base(int nasid)\r\n{\r\nreturn TIO_SWIN_BASE(nasid, TIOCX_CORELET);\r\n}\r\nstatic void tio_conveyor_set(nasid_t nasid, int enable_flag)\r\n{\r\nu64 ice_frz;\r\nu64 disable_cb = (1ull << 61);\r\nif (!(nasid & 1))\r\nreturn;\r\nice_frz = REMOTE_HUB_L(nasid, TIO_ICE_FRZ_CFG);\r\nif (enable_flag) {\r\nif (!(ice_frz & disable_cb))\r\nreturn;\r\nice_frz &= ~disable_cb;\r\n} else {\r\nif (ice_frz & disable_cb)\r\nreturn;\r\nice_frz |= disable_cb;\r\n}\r\nDBG(KERN_ALERT "TIO_ICE_FRZ_CFG= 0x%lx\n", ice_frz);\r\nREMOTE_HUB_S(nasid, TIO_ICE_FRZ_CFG, ice_frz);\r\n}\r\nstatic void tio_corelet_reset(nasid_t nasid, int corelet)\r\n{\r\nif (!(nasid & 1))\r\nreturn;\r\nREMOTE_HUB_S(nasid, TIO_ICE_PMI_TX_CFG, 1 << corelet);\r\nudelay(2000);\r\nREMOTE_HUB_S(nasid, TIO_ICE_PMI_TX_CFG, 0);\r\nudelay(2000);\r\n}\r\nstatic int is_fpga_tio(int nasid, int *bt)\r\n{\r\nu16 uninitialized_var(ioboard_type);\r\nlong rc;\r\nrc = ia64_sn_sysctl_ioboard_get(nasid, &ioboard_type);\r\nif (rc) {\r\nprintk(KERN_WARNING "ia64_sn_sysctl_ioboard_get failed: %ld\n",\r\nrc);\r\nreturn 0;\r\n}\r\nswitch (ioboard_type) {\r\ncase L1_BRICKTYPE_SA:\r\ncase L1_BRICKTYPE_ATHENA:\r\ncase L1_BOARDTYPE_DAYTONA:\r\n*bt = ioboard_type;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bitstream_loaded(nasid_t nasid)\r\n{\r\nu64 cx_credits;\r\ncx_credits = REMOTE_HUB_L(nasid, TIO_ICE_PMI_TX_DYN_CREDIT_STAT_CB3);\r\ncx_credits &= TIO_ICE_PMI_TX_DYN_CREDIT_STAT_CB3_CREDIT_CNT_MASK;\r\nDBG("cx_credits= 0x%lx\n", cx_credits);\r\nreturn (cx_credits == 0xf) ? 1 : 0;\r\n}\r\nstatic int tiocx_reload(struct cx_dev *cx_dev)\r\n{\r\nint part_num = CX_DEV_NONE;\r\nint mfg_num = CX_DEV_NONE;\r\nnasid_t nasid = cx_dev->cx_id.nasid;\r\nif (bitstream_loaded(nasid)) {\r\nu64 cx_id;\r\nint rv;\r\nrv = ia64_sn_sysctl_tio_clock_reset(nasid);\r\nif (rv) {\r\nprintk(KERN_ALERT "CX port JTAG reset failed.\n");\r\n} else {\r\ncx_id = *(volatile u64 *)\r\n(TIO_SWIN_BASE(nasid, TIOCX_CORELET) +\r\nWIDGET_ID);\r\npart_num = XWIDGET_PART_NUM(cx_id);\r\nmfg_num = XWIDGET_MFG_NUM(cx_id);\r\nDBG("part= 0x%x, mfg= 0x%x\n", part_num, mfg_num);\r\nif (part_num == TIO_CE_ASIC_PARTNUM)\r\nreturn 0;\r\n}\r\n}\r\ncx_dev->cx_id.part_num = part_num;\r\ncx_dev->cx_id.mfg_num = mfg_num;\r\nreturn cx_device_reload(cx_dev);\r\n}\r\nstatic ssize_t show_cxdev_control(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct cx_dev *cx_dev = to_cx_dev(dev);\r\nreturn sprintf(buf, "0x%x 0x%x 0x%x 0x%x\n",\r\ncx_dev->cx_id.nasid,\r\ncx_dev->cx_id.part_num, cx_dev->cx_id.mfg_num,\r\ncx_dev->bt);\r\n}\r\nstatic ssize_t store_cxdev_control(struct device *dev, struct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nint n;\r\nstruct cx_dev *cx_dev = to_cx_dev(dev);\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (count <= 0)\r\nreturn 0;\r\nn = simple_strtoul(buf, NULL, 0);\r\nswitch (n) {\r\ncase 1:\r\ntio_corelet_reset(cx_dev->cx_id.nasid, TIOCX_CORELET);\r\ntiocx_reload(cx_dev);\r\nbreak;\r\ncase 2:\r\ntiocx_reload(cx_dev);\r\nbreak;\r\ncase 3:\r\ntio_corelet_reset(cx_dev->cx_id.nasid, TIOCX_CORELET);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn count;\r\n}\r\nstatic int __init tiocx_init(void)\r\n{\r\ncnodeid_t cnodeid;\r\nint found_tiocx_device = 0;\r\nif (!ia64_platform_is("sn2"))\r\nreturn 0;\r\nbus_register(&tiocx_bus_type);\r\nfor (cnodeid = 0; cnodeid < num_cnodes; cnodeid++) {\r\nnasid_t nasid;\r\nint bt;\r\nnasid = cnodeid_to_nasid(cnodeid);\r\nif ((nasid & 0x1) && is_fpga_tio(nasid, &bt)) {\r\nstruct hubdev_info *hubdev;\r\nstruct xwidget_info *widgetp;\r\nDBG("Found TIO at nasid 0x%x\n", nasid);\r\nhubdev =\r\n(struct hubdev_info *)(NODEPDA(cnodeid)->pdinfo);\r\nwidgetp = &hubdev->hdi_xwidget_info[TIOCX_CORELET];\r\nif (widgetp->xwi_hwid.part_num == TIO_CE_ASIC_PARTNUM)\r\ncontinue;\r\ntio_corelet_reset(nasid, TIOCX_CORELET);\r\ntio_conveyor_enable(nasid);\r\nif (cx_device_register\r\n(nasid, widgetp->xwi_hwid.part_num,\r\nwidgetp->xwi_hwid.mfg_num, hubdev, bt) < 0)\r\nreturn -ENXIO;\r\nelse\r\nfound_tiocx_device++;\r\n}\r\n}\r\nDBG("found_tiocx_device= %d\n", found_tiocx_device);\r\nreturn 0;\r\n}\r\nstatic int cx_remove_device(struct device * dev, void * data)\r\n{\r\nstruct cx_dev *cx_dev = to_cx_dev(dev);\r\ndevice_remove_file(dev, &dev_attr_cxdev_control);\r\ncx_device_unregister(cx_dev);\r\nreturn 0;\r\n}\r\nstatic void __exit tiocx_exit(void)\r\n{\r\nDBG("tiocx_exit\n");\r\nbus_for_each_dev(&tiocx_bus_type, NULL, NULL, cx_remove_device);\r\nbus_unregister(&tiocx_bus_type);\r\n}
