int ehca_create_eq(struct ehca_shca *shca,\r\nstruct ehca_eq *eq,\r\nconst enum ehca_eq_type type, const u32 length)\r\n{\r\nint ret;\r\nu64 h_ret;\r\nu32 nr_pages;\r\nu32 i;\r\nvoid *vpage;\r\nstruct ib_device *ib_dev = &shca->ib_device;\r\nspin_lock_init(&eq->spinlock);\r\nspin_lock_init(&eq->irq_spinlock);\r\neq->is_initialized = 0;\r\nif (type != EHCA_EQ && type != EHCA_NEQ) {\r\nehca_err(ib_dev, "Invalid EQ type %x. eq=%p", type, eq);\r\nreturn -EINVAL;\r\n}\r\nif (!length) {\r\nehca_err(ib_dev, "EQ length must not be zero. eq=%p", eq);\r\nreturn -EINVAL;\r\n}\r\nh_ret = hipz_h_alloc_resource_eq(shca->ipz_hca_handle,\r\n&eq->pf,\r\ntype,\r\nlength,\r\n&eq->ipz_eq_handle,\r\n&eq->length,\r\n&nr_pages, &eq->ist);\r\nif (h_ret != H_SUCCESS) {\r\nehca_err(ib_dev, "Can't allocate EQ/NEQ. eq=%p", eq);\r\nreturn -EINVAL;\r\n}\r\nret = ipz_queue_ctor(NULL, &eq->ipz_queue, nr_pages,\r\nEHCA_PAGESIZE, sizeof(struct ehca_eqe), 0, 0);\r\nif (!ret) {\r\nehca_err(ib_dev, "Can't allocate EQ pages eq=%p", eq);\r\ngoto create_eq_exit1;\r\n}\r\nfor (i = 0; i < nr_pages; i++) {\r\nu64 rpage;\r\nvpage = ipz_qpageit_get_inc(&eq->ipz_queue);\r\nif (!vpage)\r\ngoto create_eq_exit2;\r\nrpage = virt_to_abs(vpage);\r\nh_ret = hipz_h_register_rpage_eq(shca->ipz_hca_handle,\r\neq->ipz_eq_handle,\r\n&eq->pf,\r\n0, 0, rpage, 1);\r\nif (i == (nr_pages - 1)) {\r\nvpage = ipz_qpageit_get_inc(&eq->ipz_queue);\r\nif (h_ret != H_SUCCESS || vpage)\r\ngoto create_eq_exit2;\r\n} else {\r\nif (h_ret != H_PAGE_REGISTERED)\r\ngoto create_eq_exit2;\r\n}\r\n}\r\nipz_qeit_reset(&eq->ipz_queue);\r\nif (type == EHCA_EQ) {\r\ntasklet_init(&eq->interrupt_task, ehca_tasklet_eq, (long)shca);\r\nret = ibmebus_request_irq(eq->ist, ehca_interrupt_eq,\r\n0, "ehca_eq",\r\n(void *)shca);\r\nif (ret < 0)\r\nehca_err(ib_dev, "Can't map interrupt handler.");\r\n} else if (type == EHCA_NEQ) {\r\ntasklet_init(&eq->interrupt_task, ehca_tasklet_neq, (long)shca);\r\nret = ibmebus_request_irq(eq->ist, ehca_interrupt_neq,\r\n0, "ehca_neq",\r\n(void *)shca);\r\nif (ret < 0)\r\nehca_err(ib_dev, "Can't map interrupt handler.");\r\n}\r\neq->is_initialized = 1;\r\nreturn 0;\r\ncreate_eq_exit2:\r\nipz_queue_dtor(NULL, &eq->ipz_queue);\r\ncreate_eq_exit1:\r\nhipz_h_destroy_eq(shca->ipz_hca_handle, eq);\r\nreturn -EINVAL;\r\n}\r\nvoid *ehca_poll_eq(struct ehca_shca *shca, struct ehca_eq *eq)\r\n{\r\nunsigned long flags;\r\nvoid *eqe;\r\nspin_lock_irqsave(&eq->spinlock, flags);\r\neqe = ipz_eqit_eq_get_inc_valid(&eq->ipz_queue);\r\nspin_unlock_irqrestore(&eq->spinlock, flags);\r\nreturn eqe;\r\n}\r\nint ehca_destroy_eq(struct ehca_shca *shca, struct ehca_eq *eq)\r\n{\r\nunsigned long flags;\r\nu64 h_ret;\r\nibmebus_free_irq(eq->ist, (void *)shca);\r\nspin_lock_irqsave(&shca_list_lock, flags);\r\neq->is_initialized = 0;\r\nspin_unlock_irqrestore(&shca_list_lock, flags);\r\ntasklet_kill(&eq->interrupt_task);\r\nh_ret = hipz_h_destroy_eq(shca->ipz_hca_handle, eq);\r\nif (h_ret != H_SUCCESS) {\r\nehca_err(&shca->ib_device, "Can't free EQ resources.");\r\nreturn -EINVAL;\r\n}\r\nipz_queue_dtor(NULL, &eq->ipz_queue);\r\nreturn 0;\r\n}
