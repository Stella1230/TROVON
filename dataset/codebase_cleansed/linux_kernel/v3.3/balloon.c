static void scrub_page(struct page *page)\r\n{\r\n#ifdef CONFIG_XEN_SCRUB_PAGES\r\nclear_highpage(page);\r\n#endif\r\n}\r\nstatic void __balloon_append(struct page *page)\r\n{\r\nif (PageHighMem(page)) {\r\nlist_add_tail(&page->lru, &ballooned_pages);\r\nballoon_stats.balloon_high++;\r\n} else {\r\nlist_add(&page->lru, &ballooned_pages);\r\nballoon_stats.balloon_low++;\r\n}\r\n}\r\nstatic void balloon_append(struct page *page)\r\n{\r\n__balloon_append(page);\r\nif (PageHighMem(page))\r\ndec_totalhigh_pages();\r\ntotalram_pages--;\r\n}\r\nstatic struct page *balloon_retrieve(bool prefer_highmem)\r\n{\r\nstruct page *page;\r\nif (list_empty(&ballooned_pages))\r\nreturn NULL;\r\nif (prefer_highmem)\r\npage = list_entry(ballooned_pages.prev, struct page, lru);\r\nelse\r\npage = list_entry(ballooned_pages.next, struct page, lru);\r\nlist_del(&page->lru);\r\nif (PageHighMem(page)) {\r\nballoon_stats.balloon_high--;\r\ninc_totalhigh_pages();\r\n} else\r\nballoon_stats.balloon_low--;\r\ntotalram_pages++;\r\nreturn page;\r\n}\r\nstatic struct page *balloon_first_page(void)\r\n{\r\nif (list_empty(&ballooned_pages))\r\nreturn NULL;\r\nreturn list_entry(ballooned_pages.next, struct page, lru);\r\n}\r\nstatic struct page *balloon_next_page(struct page *page)\r\n{\r\nstruct list_head *next = page->lru.next;\r\nif (next == &ballooned_pages)\r\nreturn NULL;\r\nreturn list_entry(next, struct page, lru);\r\n}\r\nstatic enum bp_state update_schedule(enum bp_state state)\r\n{\r\nif (state == BP_DONE) {\r\nballoon_stats.schedule_delay = 1;\r\nballoon_stats.retry_count = 1;\r\nreturn BP_DONE;\r\n}\r\n++balloon_stats.retry_count;\r\nif (balloon_stats.max_retry_count != RETRY_UNLIMITED &&\r\nballoon_stats.retry_count > balloon_stats.max_retry_count) {\r\nballoon_stats.schedule_delay = 1;\r\nballoon_stats.retry_count = 1;\r\nreturn BP_ECANCELED;\r\n}\r\nballoon_stats.schedule_delay <<= 1;\r\nif (balloon_stats.schedule_delay > balloon_stats.max_schedule_delay)\r\nballoon_stats.schedule_delay = balloon_stats.max_schedule_delay;\r\nreturn BP_EAGAIN;\r\n}\r\nstatic long current_credit(void)\r\n{\r\nreturn balloon_stats.target_pages - balloon_stats.current_pages -\r\nballoon_stats.hotplug_pages;\r\n}\r\nstatic bool balloon_is_inflated(void)\r\n{\r\nif (balloon_stats.balloon_low || balloon_stats.balloon_high ||\r\nballoon_stats.balloon_hotplug)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic enum bp_state reserve_additional_memory(long credit)\r\n{\r\nint nid, rc;\r\nu64 hotplug_start_paddr;\r\nunsigned long balloon_hotplug = credit;\r\nhotplug_start_paddr = PFN_PHYS(SECTION_ALIGN_UP(max_pfn));\r\nballoon_hotplug = round_up(balloon_hotplug, PAGES_PER_SECTION);\r\nnid = memory_add_physaddr_to_nid(hotplug_start_paddr);\r\nrc = add_memory(nid, hotplug_start_paddr, balloon_hotplug << PAGE_SHIFT);\r\nif (rc) {\r\npr_info("xen_balloon: %s: add_memory() failed: %i\n", __func__, rc);\r\nreturn BP_EAGAIN;\r\n}\r\nballoon_hotplug -= credit;\r\nballoon_stats.hotplug_pages += credit;\r\nballoon_stats.balloon_hotplug = balloon_hotplug;\r\nreturn BP_DONE;\r\n}\r\nstatic void xen_online_page(struct page *page)\r\n{\r\n__online_page_set_limits(page);\r\nmutex_lock(&balloon_mutex);\r\n__balloon_append(page);\r\nif (balloon_stats.hotplug_pages)\r\n--balloon_stats.hotplug_pages;\r\nelse\r\n--balloon_stats.balloon_hotplug;\r\nmutex_unlock(&balloon_mutex);\r\n}\r\nstatic int xen_memory_notifier(struct notifier_block *nb, unsigned long val, void *v)\r\n{\r\nif (val == MEM_ONLINE)\r\nschedule_delayed_work(&balloon_worker, 0);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic long current_credit(void)\r\n{\r\nunsigned long target = balloon_stats.target_pages;\r\ntarget = min(target,\r\nballoon_stats.current_pages +\r\nballoon_stats.balloon_low +\r\nballoon_stats.balloon_high);\r\nreturn target - balloon_stats.current_pages;\r\n}\r\nstatic bool balloon_is_inflated(void)\r\n{\r\nif (balloon_stats.balloon_low || balloon_stats.balloon_high)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic enum bp_state reserve_additional_memory(long credit)\r\n{\r\nballoon_stats.target_pages = balloon_stats.current_pages;\r\nreturn BP_DONE;\r\n}\r\nstatic enum bp_state increase_reservation(unsigned long nr_pages)\r\n{\r\nint rc;\r\nunsigned long pfn, i;\r\nstruct page *page;\r\nstruct xen_memory_reservation reservation = {\r\n.address_bits = 0,\r\n.extent_order = 0,\r\n.domid = DOMID_SELF\r\n};\r\n#ifdef CONFIG_XEN_BALLOON_MEMORY_HOTPLUG\r\nif (!balloon_stats.balloon_low && !balloon_stats.balloon_high) {\r\nnr_pages = min(nr_pages, balloon_stats.balloon_hotplug);\r\nballoon_stats.hotplug_pages += nr_pages;\r\nballoon_stats.balloon_hotplug -= nr_pages;\r\nreturn BP_DONE;\r\n}\r\n#endif\r\nif (nr_pages > ARRAY_SIZE(frame_list))\r\nnr_pages = ARRAY_SIZE(frame_list);\r\npage = balloon_first_page();\r\nfor (i = 0; i < nr_pages; i++) {\r\nif (!page) {\r\nnr_pages = i;\r\nbreak;\r\n}\r\nframe_list[i] = page_to_pfn(page);\r\npage = balloon_next_page(page);\r\n}\r\nset_xen_guest_handle(reservation.extent_start, frame_list);\r\nreservation.nr_extents = nr_pages;\r\nrc = HYPERVISOR_memory_op(XENMEM_populate_physmap, &reservation);\r\nif (rc <= 0)\r\nreturn BP_EAGAIN;\r\nfor (i = 0; i < rc; i++) {\r\npage = balloon_retrieve(false);\r\nBUG_ON(page == NULL);\r\npfn = page_to_pfn(page);\r\nBUG_ON(!xen_feature(XENFEAT_auto_translated_physmap) &&\r\nphys_to_machine_mapping_valid(pfn));\r\nset_phys_to_machine(pfn, frame_list[i]);\r\nif (xen_pv_domain() && !PageHighMem(page)) {\r\nint ret;\r\nret = HYPERVISOR_update_va_mapping(\r\n(unsigned long)__va(pfn << PAGE_SHIFT),\r\nmfn_pte(frame_list[i], PAGE_KERNEL),\r\n0);\r\nBUG_ON(ret);\r\n}\r\nClearPageReserved(page);\r\ninit_page_count(page);\r\n__free_page(page);\r\n}\r\nballoon_stats.current_pages += rc;\r\nreturn BP_DONE;\r\n}\r\nstatic enum bp_state decrease_reservation(unsigned long nr_pages, gfp_t gfp)\r\n{\r\nenum bp_state state = BP_DONE;\r\nunsigned long pfn, i;\r\nstruct page *page;\r\nint ret;\r\nstruct xen_memory_reservation reservation = {\r\n.address_bits = 0,\r\n.extent_order = 0,\r\n.domid = DOMID_SELF\r\n};\r\n#ifdef CONFIG_XEN_BALLOON_MEMORY_HOTPLUG\r\nif (balloon_stats.hotplug_pages) {\r\nnr_pages = min(nr_pages, balloon_stats.hotplug_pages);\r\nballoon_stats.hotplug_pages -= nr_pages;\r\nballoon_stats.balloon_hotplug += nr_pages;\r\nreturn BP_DONE;\r\n}\r\n#endif\r\nif (nr_pages > ARRAY_SIZE(frame_list))\r\nnr_pages = ARRAY_SIZE(frame_list);\r\nfor (i = 0; i < nr_pages; i++) {\r\nif ((page = alloc_page(gfp)) == NULL) {\r\nnr_pages = i;\r\nstate = BP_EAGAIN;\r\nbreak;\r\n}\r\npfn = page_to_pfn(page);\r\nframe_list[i] = pfn_to_mfn(pfn);\r\nscrub_page(page);\r\nif (xen_pv_domain() && !PageHighMem(page)) {\r\nret = HYPERVISOR_update_va_mapping(\r\n(unsigned long)__va(pfn << PAGE_SHIFT),\r\n__pte_ma(0), 0);\r\nBUG_ON(ret);\r\n}\r\n}\r\nkmap_flush_unused();\r\nflush_tlb_all();\r\nfor (i = 0; i < nr_pages; i++) {\r\npfn = mfn_to_pfn(frame_list[i]);\r\n__set_phys_to_machine(pfn, INVALID_P2M_ENTRY);\r\nballoon_append(pfn_to_page(pfn));\r\n}\r\nset_xen_guest_handle(reservation.extent_start, frame_list);\r\nreservation.nr_extents = nr_pages;\r\nret = HYPERVISOR_memory_op(XENMEM_decrease_reservation, &reservation);\r\nBUG_ON(ret != nr_pages);\r\nballoon_stats.current_pages -= nr_pages;\r\nreturn state;\r\n}\r\nstatic void balloon_process(struct work_struct *work)\r\n{\r\nenum bp_state state = BP_DONE;\r\nlong credit;\r\nmutex_lock(&balloon_mutex);\r\ndo {\r\ncredit = current_credit();\r\nif (credit > 0) {\r\nif (balloon_is_inflated())\r\nstate = increase_reservation(credit);\r\nelse\r\nstate = reserve_additional_memory(credit);\r\n}\r\nif (credit < 0)\r\nstate = decrease_reservation(-credit, GFP_BALLOON);\r\nstate = update_schedule(state);\r\n#ifndef CONFIG_PREEMPT\r\nif (need_resched())\r\nschedule();\r\n#endif\r\n} while (credit && state == BP_DONE);\r\nif (state == BP_EAGAIN)\r\nschedule_delayed_work(&balloon_worker, balloon_stats.schedule_delay * HZ);\r\nmutex_unlock(&balloon_mutex);\r\n}\r\nvoid balloon_set_new_target(unsigned long target)\r\n{\r\nballoon_stats.target_pages = target;\r\nschedule_delayed_work(&balloon_worker, 0);\r\n}\r\nint alloc_xenballooned_pages(int nr_pages, struct page **pages, bool highmem)\r\n{\r\nint pgno = 0;\r\nstruct page *page;\r\nmutex_lock(&balloon_mutex);\r\nwhile (pgno < nr_pages) {\r\npage = balloon_retrieve(highmem);\r\nif (page && (highmem || !PageHighMem(page))) {\r\npages[pgno++] = page;\r\n} else {\r\nenum bp_state st;\r\nif (page)\r\nballoon_append(page);\r\nst = decrease_reservation(nr_pages - pgno,\r\nhighmem ? GFP_HIGHUSER : GFP_USER);\r\nif (st != BP_DONE)\r\ngoto out_undo;\r\n}\r\n}\r\nmutex_unlock(&balloon_mutex);\r\nreturn 0;\r\nout_undo:\r\nwhile (pgno)\r\nballoon_append(pages[--pgno]);\r\nschedule_delayed_work(&balloon_worker, 0);\r\nmutex_unlock(&balloon_mutex);\r\nreturn -ENOMEM;\r\n}\r\nvoid free_xenballooned_pages(int nr_pages, struct page **pages)\r\n{\r\nint i;\r\nmutex_lock(&balloon_mutex);\r\nfor (i = 0; i < nr_pages; i++) {\r\nif (pages[i])\r\nballoon_append(pages[i]);\r\n}\r\nif (current_credit())\r\nschedule_delayed_work(&balloon_worker, 0);\r\nmutex_unlock(&balloon_mutex);\r\n}\r\nstatic void __init balloon_add_region(unsigned long start_pfn,\r\nunsigned long pages)\r\n{\r\nunsigned long pfn, extra_pfn_end;\r\nstruct page *page;\r\nextra_pfn_end = min(max_pfn, start_pfn + pages);\r\nfor (pfn = start_pfn; pfn < extra_pfn_end; pfn++) {\r\npage = pfn_to_page(pfn);\r\n__balloon_append(page);\r\n}\r\n}\r\nstatic int __init balloon_init(void)\r\n{\r\nint i;\r\nif (!xen_domain())\r\nreturn -ENODEV;\r\npr_info("xen/balloon: Initialising balloon driver.\n");\r\nballoon_stats.current_pages = xen_pv_domain()\r\n? min(xen_start_info->nr_pages - xen_released_pages, max_pfn)\r\n: max_pfn;\r\nballoon_stats.target_pages = balloon_stats.current_pages;\r\nballoon_stats.balloon_low = 0;\r\nballoon_stats.balloon_high = 0;\r\nballoon_stats.schedule_delay = 1;\r\nballoon_stats.max_schedule_delay = 32;\r\nballoon_stats.retry_count = 1;\r\nballoon_stats.max_retry_count = RETRY_UNLIMITED;\r\n#ifdef CONFIG_XEN_BALLOON_MEMORY_HOTPLUG\r\nballoon_stats.hotplug_pages = 0;\r\nballoon_stats.balloon_hotplug = 0;\r\nset_online_page_callback(&xen_online_page);\r\nregister_memory_notifier(&xen_memory_nb);\r\n#endif\r\nfor (i = 0; i < XEN_EXTRA_MEM_MAX_REGIONS; i++)\r\nif (xen_extra_mem[i].size)\r\nballoon_add_region(PFN_UP(xen_extra_mem[i].start),\r\nPFN_DOWN(xen_extra_mem[i].size));\r\nreturn 0;\r\n}
