int ov9650_probe(struct sd *sd)\r\n{\r\nint err = 0;\r\nu8 prod_id = 0, ver_id = 0, i;\r\ns32 *sensor_settings;\r\nif (force_sensor) {\r\nif (force_sensor == OV9650_SENSOR) {\r\npr_info("Forcing an %s sensor\n", ov9650.name);\r\ngoto sensor_found;\r\n}\r\nreturn -ENODEV;\r\n}\r\nPDEBUG(D_PROBE, "Probing for an ov9650 sensor");\r\nfor (i = 0; i < ARRAY_SIZE(preinit_ov9650) && !err; i++) {\r\nu8 data = preinit_ov9650[i][2];\r\nif (preinit_ov9650[i][0] == SENSOR)\r\nerr = m5602_write_sensor(sd,\r\npreinit_ov9650[i][1], &data, 1);\r\nelse\r\nerr = m5602_write_bridge(sd,\r\npreinit_ov9650[i][1], data);\r\n}\r\nif (err < 0)\r\nreturn err;\r\nif (m5602_read_sensor(sd, OV9650_PID, &prod_id, 1))\r\nreturn -ENODEV;\r\nif (m5602_read_sensor(sd, OV9650_VER, &ver_id, 1))\r\nreturn -ENODEV;\r\nif ((prod_id == 0x96) && (ver_id == 0x52)) {\r\npr_info("Detected an ov9650 sensor\n");\r\ngoto sensor_found;\r\n}\r\nreturn -ENODEV;\r\nsensor_found:\r\nsensor_settings = kmalloc(\r\nARRAY_SIZE(ov9650_ctrls) * sizeof(s32), GFP_KERNEL);\r\nif (!sensor_settings)\r\nreturn -ENOMEM;\r\nsd->gspca_dev.cam.cam_mode = ov9650_modes;\r\nsd->gspca_dev.cam.nmodes = ARRAY_SIZE(ov9650_modes);\r\nsd->desc->ctrls = ov9650_ctrls;\r\nsd->desc->nctrls = ARRAY_SIZE(ov9650_ctrls);\r\nfor (i = 0; i < ARRAY_SIZE(ov9650_ctrls); i++)\r\nsensor_settings[i] = ov9650_ctrls[i].qctrl.default_value;\r\nsd->sensor_priv = sensor_settings;\r\nreturn 0;\r\n}\r\nint ov9650_init(struct sd *sd)\r\n{\r\nint i, err = 0;\r\nu8 data;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nif (dump_sensor)\r\nov9650_dump_registers(sd);\r\nfor (i = 0; i < ARRAY_SIZE(init_ov9650) && !err; i++) {\r\ndata = init_ov9650[i][2];\r\nif (init_ov9650[i][0] == SENSOR)\r\nerr = m5602_write_sensor(sd, init_ov9650[i][1],\r\n&data, 1);\r\nelse\r\nerr = m5602_write_bridge(sd, init_ov9650[i][1], data);\r\n}\r\nerr = ov9650_set_exposure(&sd->gspca_dev,\r\nsensor_settings[EXPOSURE_IDX]);\r\nif (err < 0)\r\nreturn err;\r\nerr = ov9650_set_gain(&sd->gspca_dev, sensor_settings[GAIN_IDX]);\r\nif (err < 0)\r\nreturn err;\r\nerr = ov9650_set_red_balance(&sd->gspca_dev,\r\nsensor_settings[RED_BALANCE_IDX]);\r\nif (err < 0)\r\nreturn err;\r\nerr = ov9650_set_blue_balance(&sd->gspca_dev,\r\nsensor_settings[BLUE_BALANCE_IDX]);\r\nif (err < 0)\r\nreturn err;\r\nerr = ov9650_set_hflip(&sd->gspca_dev, sensor_settings[HFLIP_IDX]);\r\nif (err < 0)\r\nreturn err;\r\nerr = ov9650_set_vflip(&sd->gspca_dev, sensor_settings[VFLIP_IDX]);\r\nif (err < 0)\r\nreturn err;\r\nerr = ov9650_set_auto_exposure(&sd->gspca_dev,\r\nsensor_settings[AUTO_EXPOSURE_IDX]);\r\nif (err < 0)\r\nreturn err;\r\nerr = ov9650_set_auto_white_balance(&sd->gspca_dev,\r\nsensor_settings[AUTO_WHITE_BALANCE_IDX]);\r\nif (err < 0)\r\nreturn err;\r\nerr = ov9650_set_auto_gain(&sd->gspca_dev,\r\nsensor_settings[AUTO_GAIN_CTRL_IDX]);\r\nreturn err;\r\n}\r\nint ov9650_start(struct sd *sd)\r\n{\r\nu8 data;\r\nint i, err = 0;\r\nstruct cam *cam = &sd->gspca_dev.cam;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nint width = cam->cam_mode[sd->gspca_dev.curr_mode].width;\r\nint height = cam->cam_mode[sd->gspca_dev.curr_mode].height;\r\nint ver_offs = cam->cam_mode[sd->gspca_dev.curr_mode].priv;\r\nint hor_offs = OV9650_LEFT_OFFSET;\r\nif ((!dmi_check_system(ov9650_flip_dmi_table) &&\r\nsensor_settings[VFLIP_IDX]) ||\r\n(dmi_check_system(ov9650_flip_dmi_table) &&\r\n!sensor_settings[VFLIP_IDX]))\r\nver_offs--;\r\nif (width <= 320)\r\nhor_offs /= 2;\r\nfor (i = 0; i < ARRAY_SIZE(res_init_ov9650) && !err; i++) {\r\nif (res_init_ov9650[i][0] == BRIDGE)\r\nerr = m5602_write_bridge(sd, res_init_ov9650[i][1],\r\nres_init_ov9650[i][2]);\r\nelse if (res_init_ov9650[i][0] == SENSOR) {\r\ndata = res_init_ov9650[i][2];\r\nerr = m5602_write_sensor(sd,\r\nres_init_ov9650[i][1], &data, 1);\r\n}\r\n}\r\nif (err < 0)\r\nreturn err;\r\nerr = m5602_write_bridge(sd, M5602_XB_VSYNC_PARA,\r\n((ver_offs >> 8) & 0xff));\r\nif (err < 0)\r\nreturn err;\r\nerr = m5602_write_bridge(sd, M5602_XB_VSYNC_PARA, (ver_offs & 0xff));\r\nif (err < 0)\r\nreturn err;\r\nerr = m5602_write_bridge(sd, M5602_XB_VSYNC_PARA, 0);\r\nif (err < 0)\r\nreturn err;\r\nerr = m5602_write_bridge(sd, M5602_XB_VSYNC_PARA, (height >> 8) & 0xff);\r\nif (err < 0)\r\nreturn err;\r\nerr = m5602_write_bridge(sd, M5602_XB_VSYNC_PARA, (height & 0xff));\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0; i < 2 && !err; i++)\r\nerr = m5602_write_bridge(sd, M5602_XB_VSYNC_PARA, 0);\r\nif (err < 0)\r\nreturn err;\r\nerr = m5602_write_bridge(sd, M5602_XB_SIG_INI, 0);\r\nif (err < 0)\r\nreturn err;\r\nerr = m5602_write_bridge(sd, M5602_XB_SIG_INI, 2);\r\nif (err < 0)\r\nreturn err;\r\nerr = m5602_write_bridge(sd, M5602_XB_HSYNC_PARA,\r\n(hor_offs >> 8) & 0xff);\r\nif (err < 0)\r\nreturn err;\r\nerr = m5602_write_bridge(sd, M5602_XB_HSYNC_PARA, hor_offs & 0xff);\r\nif (err < 0)\r\nreturn err;\r\nerr = m5602_write_bridge(sd, M5602_XB_HSYNC_PARA,\r\n((width + hor_offs) >> 8) & 0xff);\r\nif (err < 0)\r\nreturn err;\r\nerr = m5602_write_bridge(sd, M5602_XB_HSYNC_PARA,\r\n((width + hor_offs) & 0xff));\r\nif (err < 0)\r\nreturn err;\r\nerr = m5602_write_bridge(sd, M5602_XB_SIG_INI, 0);\r\nif (err < 0)\r\nreturn err;\r\nswitch (width) {\r\ncase 640:\r\nPDEBUG(D_V4L2, "Configuring camera for VGA mode");\r\ndata = OV9650_VGA_SELECT | OV9650_RGB_SELECT |\r\nOV9650_RAW_RGB_SELECT;\r\nerr = m5602_write_sensor(sd, OV9650_COM7, &data, 1);\r\nbreak;\r\ncase 352:\r\nPDEBUG(D_V4L2, "Configuring camera for CIF mode");\r\ndata = OV9650_CIF_SELECT | OV9650_RGB_SELECT |\r\nOV9650_RAW_RGB_SELECT;\r\nerr = m5602_write_sensor(sd, OV9650_COM7, &data, 1);\r\nbreak;\r\ncase 320:\r\nPDEBUG(D_V4L2, "Configuring camera for QVGA mode");\r\ndata = OV9650_QVGA_SELECT | OV9650_RGB_SELECT |\r\nOV9650_RAW_RGB_SELECT;\r\nerr = m5602_write_sensor(sd, OV9650_COM7, &data, 1);\r\nbreak;\r\ncase 176:\r\nPDEBUG(D_V4L2, "Configuring camera for QCIF mode");\r\ndata = OV9650_QCIF_SELECT | OV9650_RGB_SELECT |\r\nOV9650_RAW_RGB_SELECT;\r\nerr = m5602_write_sensor(sd, OV9650_COM7, &data, 1);\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nint ov9650_stop(struct sd *sd)\r\n{\r\nu8 data = OV9650_SOFT_SLEEP | OV9650_OUTPUT_DRIVE_2X;\r\nreturn m5602_write_sensor(sd, OV9650_COM2, &data, 1);\r\n}\r\nvoid ov9650_disconnect(struct sd *sd)\r\n{\r\nov9650_stop(sd);\r\nsd->sensor = NULL;\r\nkfree(sd->sensor_priv);\r\n}\r\nstatic int ov9650_get_exposure(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[EXPOSURE_IDX];\r\nPDEBUG(D_V4L2, "Read exposure %d", *val);\r\nreturn 0;\r\n}\r\nstatic int ov9650_set_exposure(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nu8 i2c_data;\r\nint err;\r\nPDEBUG(D_V4L2, "Set exposure to %d", val);\r\nsensor_settings[EXPOSURE_IDX] = val;\r\ni2c_data = (val >> 10) & 0x3f;\r\nerr = m5602_write_sensor(sd, OV9650_AECHM,\r\n&i2c_data, 1);\r\nif (err < 0)\r\nreturn err;\r\ni2c_data = (val >> 2) & 0xff;\r\nerr = m5602_write_sensor(sd, OV9650_AECH,\r\n&i2c_data, 1);\r\nif (err < 0)\r\nreturn err;\r\ni2c_data = val & 0x03;\r\nerr = m5602_write_sensor(sd, OV9650_COM1, &i2c_data, 1);\r\nreturn err;\r\n}\r\nstatic int ov9650_get_gain(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[GAIN_IDX];\r\nPDEBUG(D_V4L2, "Read gain %d", *val);\r\nreturn 0;\r\n}\r\nstatic int ov9650_set_gain(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nu8 i2c_data;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nPDEBUG(D_V4L2, "Setting gain to %d", val);\r\nsensor_settings[GAIN_IDX] = val;\r\nerr = m5602_read_sensor(sd, OV9650_VREF, &i2c_data, 1);\r\nif (err < 0)\r\nreturn err;\r\ni2c_data = ((val & 0x0300) >> 2) |\r\n(i2c_data & 0x3f);\r\nerr = m5602_write_sensor(sd, OV9650_VREF, &i2c_data, 1);\r\nif (err < 0)\r\nreturn err;\r\ni2c_data = val & 0xff;\r\nerr = m5602_write_sensor(sd, OV9650_GAIN, &i2c_data, 1);\r\nreturn err;\r\n}\r\nstatic int ov9650_get_red_balance(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[RED_BALANCE_IDX];\r\nPDEBUG(D_V4L2, "Read red gain %d", *val);\r\nreturn 0;\r\n}\r\nstatic int ov9650_set_red_balance(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nu8 i2c_data;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nPDEBUG(D_V4L2, "Set red gain to %d", val);\r\nsensor_settings[RED_BALANCE_IDX] = val;\r\ni2c_data = val & 0xff;\r\nerr = m5602_write_sensor(sd, OV9650_RED, &i2c_data, 1);\r\nreturn err;\r\n}\r\nstatic int ov9650_get_blue_balance(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[BLUE_BALANCE_IDX];\r\nPDEBUG(D_V4L2, "Read blue gain %d", *val);\r\nreturn 0;\r\n}\r\nstatic int ov9650_set_blue_balance(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nu8 i2c_data;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nPDEBUG(D_V4L2, "Set blue gain to %d", val);\r\nsensor_settings[BLUE_BALANCE_IDX] = val;\r\ni2c_data = val & 0xff;\r\nerr = m5602_write_sensor(sd, OV9650_BLUE, &i2c_data, 1);\r\nreturn err;\r\n}\r\nstatic int ov9650_get_hflip(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[HFLIP_IDX];\r\nPDEBUG(D_V4L2, "Read horizontal flip %d", *val);\r\nreturn 0;\r\n}\r\nstatic int ov9650_set_hflip(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nu8 i2c_data;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nPDEBUG(D_V4L2, "Set horizontal flip to %d", val);\r\nsensor_settings[HFLIP_IDX] = val;\r\nif (!dmi_check_system(ov9650_flip_dmi_table))\r\ni2c_data = ((val & 0x01) << 5) |\r\n(sensor_settings[VFLIP_IDX] << 4);\r\nelse\r\ni2c_data = ((val & 0x01) << 5) |\r\n(!sensor_settings[VFLIP_IDX] << 4);\r\nerr = m5602_write_sensor(sd, OV9650_MVFP, &i2c_data, 1);\r\nreturn err;\r\n}\r\nstatic int ov9650_get_vflip(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[VFLIP_IDX];\r\nPDEBUG(D_V4L2, "Read vertical flip %d", *val);\r\nreturn 0;\r\n}\r\nstatic int ov9650_set_vflip(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nu8 i2c_data;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nPDEBUG(D_V4L2, "Set vertical flip to %d", val);\r\nsensor_settings[VFLIP_IDX] = val;\r\nif (dmi_check_system(ov9650_flip_dmi_table))\r\nval = !val;\r\ni2c_data = ((val & 0x01) << 4) | (sensor_settings[VFLIP_IDX] << 5);\r\nerr = m5602_write_sensor(sd, OV9650_MVFP, &i2c_data, 1);\r\nif (err < 0)\r\nreturn err;\r\nif (gspca_dev->streaming)\r\nerr = ov9650_start(sd);\r\nreturn err;\r\n}\r\nstatic int ov9650_get_auto_exposure(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[AUTO_EXPOSURE_IDX];\r\nPDEBUG(D_V4L2, "Read auto exposure control %d", *val);\r\nreturn 0;\r\n}\r\nstatic int ov9650_set_auto_exposure(struct gspca_dev *gspca_dev,\r\n__s32 val)\r\n{\r\nint err;\r\nu8 i2c_data;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nPDEBUG(D_V4L2, "Set auto exposure control to %d", val);\r\nsensor_settings[AUTO_EXPOSURE_IDX] = val;\r\nerr = m5602_read_sensor(sd, OV9650_COM8, &i2c_data, 1);\r\nif (err < 0)\r\nreturn err;\r\ni2c_data = ((i2c_data & 0xfe) | ((val & 0x01) << 0));\r\nreturn m5602_write_sensor(sd, OV9650_COM8, &i2c_data, 1);\r\n}\r\nstatic int ov9650_get_auto_white_balance(struct gspca_dev *gspca_dev,\r\n__s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[AUTO_WHITE_BALANCE_IDX];\r\nreturn 0;\r\n}\r\nstatic int ov9650_set_auto_white_balance(struct gspca_dev *gspca_dev,\r\n__s32 val)\r\n{\r\nint err;\r\nu8 i2c_data;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nPDEBUG(D_V4L2, "Set auto white balance to %d", val);\r\nsensor_settings[AUTO_WHITE_BALANCE_IDX] = val;\r\nerr = m5602_read_sensor(sd, OV9650_COM8, &i2c_data, 1);\r\nif (err < 0)\r\nreturn err;\r\ni2c_data = ((i2c_data & 0xfd) | ((val & 0x01) << 1));\r\nerr = m5602_write_sensor(sd, OV9650_COM8, &i2c_data, 1);\r\nreturn err;\r\n}\r\nstatic int ov9650_get_auto_gain(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[AUTO_GAIN_CTRL_IDX];\r\nPDEBUG(D_V4L2, "Read auto gain control %d", *val);\r\nreturn 0;\r\n}\r\nstatic int ov9650_set_auto_gain(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nu8 i2c_data;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nPDEBUG(D_V4L2, "Set auto gain control to %d", val);\r\nsensor_settings[AUTO_GAIN_CTRL_IDX] = val;\r\nerr = m5602_read_sensor(sd, OV9650_COM8, &i2c_data, 1);\r\nif (err < 0)\r\nreturn err;\r\ni2c_data = ((i2c_data & 0xfb) | ((val & 0x01) << 2));\r\nreturn m5602_write_sensor(sd, OV9650_COM8, &i2c_data, 1);\r\n}\r\nstatic void ov9650_dump_registers(struct sd *sd)\r\n{\r\nint address;\r\npr_info("Dumping the ov9650 register state\n");\r\nfor (address = 0; address < 0xa9; address++) {\r\nu8 value;\r\nm5602_read_sensor(sd, address, &value, 1);\r\npr_info("register 0x%x contains 0x%x\n", address, value);\r\n}\r\npr_info("ov9650 register state dump complete\n");\r\npr_info("Probing for which registers that are read/write\n");\r\nfor (address = 0; address < 0xff; address++) {\r\nu8 old_value, ctrl_value;\r\nu8 test_value[2] = {0xff, 0xff};\r\nm5602_read_sensor(sd, address, &old_value, 1);\r\nm5602_write_sensor(sd, address, test_value, 1);\r\nm5602_read_sensor(sd, address, &ctrl_value, 1);\r\nif (ctrl_value == test_value[0])\r\npr_info("register 0x%x is writeable\n", address);\r\nelse\r\npr_info("register 0x%x is read only\n", address);\r\nm5602_write_sensor(sd, address, &old_value, 1);\r\n}\r\n}
