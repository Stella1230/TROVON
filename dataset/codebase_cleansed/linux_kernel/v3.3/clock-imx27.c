static int clk_pccr_enable(struct clk *clk)\r\n{\r\nunsigned long reg;\r\nif (!clk->enable_reg)\r\nreturn 0;\r\nreg = __raw_readl(clk->enable_reg);\r\nreg |= 1 << clk->enable_shift;\r\n__raw_writel(reg, clk->enable_reg);\r\nreturn 0;\r\n}\r\nstatic void clk_pccr_disable(struct clk *clk)\r\n{\r\nunsigned long reg;\r\nif (!clk->enable_reg)\r\nreturn;\r\nreg = __raw_readl(clk->enable_reg);\r\nreg &= ~(1 << clk->enable_shift);\r\n__raw_writel(reg, clk->enable_reg);\r\n}\r\nstatic int clk_spll_enable(struct clk *clk)\r\n{\r\nunsigned long reg;\r\nreg = __raw_readl(CCM_CSCR);\r\nreg |= CCM_CSCR_SPEN;\r\n__raw_writel(reg, CCM_CSCR);\r\nwhile (!(__raw_readl(CCM_SPCTL1) & CCM_SPCTL1_LF));\r\nreturn 0;\r\n}\r\nstatic void clk_spll_disable(struct clk *clk)\r\n{\r\nunsigned long reg;\r\nreg = __raw_readl(CCM_CSCR);\r\nreg &= ~CCM_CSCR_SPEN;\r\n__raw_writel(reg, CCM_CSCR);\r\n}\r\nstatic int clk_cpu_set_parent(struct clk *clk, struct clk *parent)\r\n{\r\nint cscr = __raw_readl(CCM_CSCR);\r\nif (clk->parent == parent)\r\nreturn 0;\r\nif (mx27_revision() >= IMX_CHIP_REVISION_2_0) {\r\nif (parent == &mpll_main1_clk) {\r\ncscr |= CCM_CSCR_ARM_SRC;\r\n} else {\r\nif (parent == &mpll_main2_clk)\r\ncscr &= ~CCM_CSCR_ARM_SRC;\r\nelse\r\nreturn -EINVAL;\r\n}\r\n__raw_writel(cscr, CCM_CSCR);\r\nclk->parent = parent;\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic unsigned long round_rate_cpu(struct clk *clk, unsigned long rate)\r\n{\r\nint div;\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\ndiv = parent_rate / rate;\r\nif (parent_rate % rate)\r\ndiv++;\r\nif (div > 4)\r\ndiv = 4;\r\nreturn parent_rate / div;\r\n}\r\nstatic int set_rate_cpu(struct clk *clk, unsigned long rate)\r\n{\r\nunsigned int div;\r\nuint32_t reg;\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\ndiv = parent_rate / rate;\r\nif (div > 4 || div < 1 || ((parent_rate / div) != rate))\r\nreturn -EINVAL;\r\ndiv--;\r\nreg = __raw_readl(CCM_CSCR);\r\nif (mx27_revision() >= IMX_CHIP_REVISION_2_0) {\r\nreg &= ~(3 << 12);\r\nreg |= div << 12;\r\nreg &= ~(CCM_CSCR_FPM | CCM_CSCR_SPEN);\r\n__raw_writel(reg | CCM_CSCR_UPDATE_DIS, CCM_CSCR);\r\n} else {\r\nprintk(KERN_ERR "Can't set CPU frequency!\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned long round_rate_per(struct clk *clk, unsigned long rate)\r\n{\r\nu32 div;\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\ndiv = parent_rate / rate;\r\nif (parent_rate % rate)\r\ndiv++;\r\nif (div > 64)\r\ndiv = 64;\r\nreturn parent_rate / div;\r\n}\r\nstatic int set_rate_per(struct clk *clk, unsigned long rate)\r\n{\r\nu32 reg;\r\nu32 div;\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\nif (clk->id < 0 || clk->id > 3)\r\nreturn -EINVAL;\r\ndiv = parent_rate / rate;\r\nif (div > 64 || div < 1 || ((parent_rate / div) != rate))\r\nreturn -EINVAL;\r\ndiv--;\r\nreg = __raw_readl(CCM_PCDR1) & ~(0x3f << (clk->id << 3));\r\nreg |= div << (clk->id << 3);\r\n__raw_writel(reg, CCM_PCDR1);\r\nreturn 0;\r\n}\r\nstatic unsigned long get_rate_usb(struct clk *clk)\r\n{\r\nunsigned long usb_pdf;\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\nusb_pdf = (__raw_readl(CCM_CSCR) >> 28) & 0x7;\r\nreturn parent_rate / (usb_pdf + 1U);\r\n}\r\nstatic unsigned long get_rate_ssix(struct clk *clk, unsigned long pdf)\r\n{\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\nif (mx27_revision() >= IMX_CHIP_REVISION_2_0)\r\npdf += 4;\r\nelse\r\npdf = (pdf < 2) ? 124UL : pdf;\r\nreturn 2UL * parent_rate / pdf;\r\n}\r\nstatic unsigned long get_rate_ssi1(struct clk *clk)\r\n{\r\nreturn get_rate_ssix(clk, (__raw_readl(CCM_PCDR0) >> 16) & 0x3f);\r\n}\r\nstatic unsigned long get_rate_ssi2(struct clk *clk)\r\n{\r\nreturn get_rate_ssix(clk, (__raw_readl(CCM_PCDR0) >> 26) & 0x3f);\r\n}\r\nstatic unsigned long get_rate_nfc(struct clk *clk)\r\n{\r\nunsigned long nfc_pdf;\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\nif (mx27_revision() >= IMX_CHIP_REVISION_2_0)\r\nnfc_pdf = (__raw_readl(CCM_PCDR0) >> 6) & 0xf;\r\nelse\r\nnfc_pdf = (__raw_readl(CCM_PCDR0) >> 12) & 0xf;\r\nreturn parent_rate / (nfc_pdf + 1);\r\n}\r\nstatic unsigned long get_rate_vpu(struct clk *clk)\r\n{\r\nunsigned long vpu_pdf;\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\nif (mx27_revision() >= IMX_CHIP_REVISION_2_0) {\r\nvpu_pdf = (__raw_readl(CCM_PCDR0) >> 10) & 0x3f;\r\nvpu_pdf += 4;\r\n} else {\r\nvpu_pdf = (__raw_readl(CCM_PCDR0) >> 8) & 0xf;\r\nvpu_pdf = (vpu_pdf < 2) ? 124 : vpu_pdf;\r\n}\r\nreturn 2UL * parent_rate / vpu_pdf;\r\n}\r\nstatic unsigned long round_rate_parent(struct clk *clk, unsigned long rate)\r\n{\r\nreturn clk->parent->round_rate(clk->parent, rate);\r\n}\r\nstatic unsigned long get_rate_parent(struct clk *clk)\r\n{\r\nreturn clk_get_rate(clk->parent);\r\n}\r\nstatic int set_rate_parent(struct clk *clk, unsigned long rate)\r\n{\r\nreturn clk->parent->set_rate(clk->parent, rate);\r\n}\r\nstatic unsigned long get_rate_high_reference(struct clk *clk)\r\n{\r\nreturn external_high_reference;\r\n}\r\nstatic unsigned long get_rate_low_reference(struct clk *clk)\r\n{\r\nreturn external_low_reference;\r\n}\r\nstatic unsigned long get_rate_fpm(struct clk *clk)\r\n{\r\nreturn clk_get_rate(clk->parent) * 1024;\r\n}\r\nstatic unsigned long get_rate_mpll(struct clk *clk)\r\n{\r\nreturn mxc_decode_pll(__raw_readl(CCM_MPCTL0),\r\nclk_get_rate(clk->parent));\r\n}\r\nstatic unsigned long get_rate_mpll_main(struct clk *clk)\r\n{\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\nif (mx27_revision() >= IMX_CHIP_REVISION_2_0 && clk->id == 1)\r\nreturn 2UL * parent_rate / 3UL;\r\nreturn parent_rate;\r\n}\r\nstatic unsigned long get_rate_spll(struct clk *clk)\r\n{\r\nuint32_t reg;\r\nunsigned long rate;\r\nrate = clk_get_rate(clk->parent);\r\nreg = __raw_readl(CCM_SPCTL0);\r\nif (mx27_revision() >= IMX_CHIP_REVISION_2_0)\r\n__raw_writel(reg, CCM_SPCTL0);\r\nreturn mxc_decode_pll(reg, rate);\r\n}\r\nstatic unsigned long get_rate_cpu(struct clk *clk)\r\n{\r\nu32 div;\r\nunsigned long rate;\r\nif (mx27_revision() >= IMX_CHIP_REVISION_2_0)\r\ndiv = (__raw_readl(CCM_CSCR) >> 12) & 0x3;\r\nelse\r\ndiv = (__raw_readl(CCM_CSCR) >> 13) & 0x7;\r\nrate = clk_get_rate(clk->parent);\r\nreturn rate / (div + 1);\r\n}\r\nstatic unsigned long get_rate_ahb(struct clk *clk)\r\n{\r\nunsigned long rate, bclk_pdf;\r\nif (mx27_revision() >= IMX_CHIP_REVISION_2_0)\r\nbclk_pdf = (__raw_readl(CCM_CSCR) >> 8) & 0x3;\r\nelse\r\nbclk_pdf = (__raw_readl(CCM_CSCR) >> 9) & 0xf;\r\nrate = clk_get_rate(clk->parent);\r\nreturn rate / (bclk_pdf + 1);\r\n}\r\nstatic unsigned long get_rate_ipg(struct clk *clk)\r\n{\r\nunsigned long rate, ipg_pdf;\r\nif (mx27_revision() >= IMX_CHIP_REVISION_2_0)\r\nreturn clk_get_rate(clk->parent);\r\nelse\r\nipg_pdf = (__raw_readl(CCM_CSCR) >> 8) & 1;\r\nrate = clk_get_rate(clk->parent);\r\nreturn rate / (ipg_pdf + 1);\r\n}\r\nstatic unsigned long get_rate_per(struct clk *clk)\r\n{\r\nunsigned long perclk_pdf, parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\nif (clk->id < 0 || clk->id > 3)\r\nreturn 0;\r\nperclk_pdf = (__raw_readl(CCM_PCDR1) >> (clk->id << 3)) & 0x3f;\r\nreturn parent_rate / (perclk_pdf + 1);\r\n}\r\nstatic void __init to2_adjust_clocks(void)\r\n{\r\nunsigned long cscr = __raw_readl(CCM_CSCR);\r\nif (mx27_revision() >= IMX_CHIP_REVISION_2_0) {\r\nif (cscr & CCM_CSCR_ARM_SRC)\r\ncpu_clk.parent = &mpll_main1_clk;\r\nif (!(cscr & CCM_CSCR_SSI2))\r\nssi1_clk.parent = &spll_clk;\r\nif (!(cscr & CCM_CSCR_SSI1))\r\nssi1_clk.parent = &spll_clk;\r\nif (!(cscr & CCM_CSCR_VPU))\r\nvpu_clk.parent = &spll_clk;\r\n} else {\r\ncpu_clk.parent = &mpll_clk;\r\ncpu_clk.set_parent = NULL;\r\ncpu_clk.round_rate = NULL;\r\ncpu_clk.set_rate = NULL;\r\nahb_clk.parent = &mpll_clk;\r\nper1_clk.parent = &mpll_clk;\r\nper2_clk.parent = &mpll_clk;\r\nper3_clk.parent = &mpll_clk;\r\nper4_clk.parent = &mpll_clk;\r\nssi1_clk.parent = &mpll_clk;\r\nssi2_clk.parent = &mpll_clk;\r\nvpu_clk.parent = &mpll_clk;\r\n}\r\n}\r\nint __init mx27_clocks_init(unsigned long fref)\r\n{\r\nu32 cscr = __raw_readl(CCM_CSCR);\r\nexternal_high_reference = fref;\r\nif (cscr & CCM_CSCR_MCU)\r\nmpll_clk.parent = &ckih_clk;\r\nelse\r\nmpll_clk.parent = &fpm_clk;\r\nif (cscr & CCM_CSCR_SP)\r\nspll_clk.parent = &ckih_clk;\r\nelse\r\nspll_clk.parent = &fpm_clk;\r\nto2_adjust_clocks();\r\nclkdev_add_table(lookups, ARRAY_SIZE(lookups));\r\n__raw_writel(0, CCM_PCCR0);\r\n__raw_writel((1 << 10) | (1 << 19), CCM_PCCR1);\r\nspll_clk.disable(&spll_clk);\r\nclk_enable(&per1_clk);\r\nclk_enable(&gpio_clk);\r\nclk_enable(&emi_clk);\r\nclk_enable(&iim_clk);\r\nimx_print_silicon_rev("i.MX27", mx27_revision());\r\nclk_disable(&iim_clk);\r\n#if defined(CONFIG_DEBUG_LL) && !defined(CONFIG_DEBUG_ICEDCC)\r\nclk_enable(&uart1_clk);\r\n#endif\r\nmxc_timer_init(&gpt1_clk, MX27_IO_ADDRESS(MX27_GPT1_BASE_ADDR),\r\nMX27_INT_GPT1);\r\nreturn 0;\r\n}
