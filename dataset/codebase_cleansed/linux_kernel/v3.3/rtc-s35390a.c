static int s35390a_set_reg(struct s35390a *s35390a, int reg, char *buf, int len)\r\n{\r\nstruct i2c_client *client = s35390a->client[reg];\r\nstruct i2c_msg msg[] = {\r\n{ client->addr, 0, len, buf },\r\n};\r\nif ((i2c_transfer(client->adapter, msg, 1)) != 1)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int s35390a_get_reg(struct s35390a *s35390a, int reg, char *buf, int len)\r\n{\r\nstruct i2c_client *client = s35390a->client[reg];\r\nstruct i2c_msg msg[] = {\r\n{ client->addr, I2C_M_RD, len, buf },\r\n};\r\nif ((i2c_transfer(client->adapter, msg, 1)) != 1)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int s35390a_reset(struct s35390a *s35390a)\r\n{\r\nchar buf[1];\r\nif (s35390a_get_reg(s35390a, S35390A_CMD_STATUS1, buf, sizeof(buf)) < 0)\r\nreturn -EIO;\r\nif (!(buf[0] & (S35390A_FLAG_POC | S35390A_FLAG_BLD)))\r\nreturn 0;\r\nbuf[0] |= (S35390A_FLAG_RESET | S35390A_FLAG_24H);\r\nbuf[0] &= 0xf0;\r\nreturn s35390a_set_reg(s35390a, S35390A_CMD_STATUS1, buf, sizeof(buf));\r\n}\r\nstatic int s35390a_disable_test_mode(struct s35390a *s35390a)\r\n{\r\nchar buf[1];\r\nif (s35390a_get_reg(s35390a, S35390A_CMD_STATUS2, buf, sizeof(buf)) < 0)\r\nreturn -EIO;\r\nif (!(buf[0] & S35390A_FLAG_TEST))\r\nreturn 0;\r\nbuf[0] &= ~S35390A_FLAG_TEST;\r\nreturn s35390a_set_reg(s35390a, S35390A_CMD_STATUS2, buf, sizeof(buf));\r\n}\r\nstatic char s35390a_hr2reg(struct s35390a *s35390a, int hour)\r\n{\r\nif (s35390a->twentyfourhour)\r\nreturn bin2bcd(hour);\r\nif (hour < 12)\r\nreturn bin2bcd(hour);\r\nreturn 0x40 | bin2bcd(hour - 12);\r\n}\r\nstatic int s35390a_reg2hr(struct s35390a *s35390a, char reg)\r\n{\r\nunsigned hour;\r\nif (s35390a->twentyfourhour)\r\nreturn bcd2bin(reg & 0x3f);\r\nhour = bcd2bin(reg & 0x3f);\r\nif (reg & 0x40)\r\nhour += 12;\r\nreturn hour;\r\n}\r\nstatic int s35390a_set_datetime(struct i2c_client *client, struct rtc_time *tm)\r\n{\r\nstruct s35390a *s35390a = i2c_get_clientdata(client);\r\nint i, err;\r\nchar buf[7];\r\ndev_dbg(&client->dev, "%s: tm is secs=%d, mins=%d, hours=%d mday=%d, "\r\n"mon=%d, year=%d, wday=%d\n", __func__, tm->tm_sec,\r\ntm->tm_min, tm->tm_hour, tm->tm_mday, tm->tm_mon, tm->tm_year,\r\ntm->tm_wday);\r\nbuf[S35390A_BYTE_YEAR] = bin2bcd(tm->tm_year - 100);\r\nbuf[S35390A_BYTE_MONTH] = bin2bcd(tm->tm_mon + 1);\r\nbuf[S35390A_BYTE_DAY] = bin2bcd(tm->tm_mday);\r\nbuf[S35390A_BYTE_WDAY] = bin2bcd(tm->tm_wday);\r\nbuf[S35390A_BYTE_HOURS] = s35390a_hr2reg(s35390a, tm->tm_hour);\r\nbuf[S35390A_BYTE_MINS] = bin2bcd(tm->tm_min);\r\nbuf[S35390A_BYTE_SECS] = bin2bcd(tm->tm_sec);\r\nfor (i = 0; i < 7; ++i)\r\nbuf[i] = bitrev8(buf[i]);\r\nerr = s35390a_set_reg(s35390a, S35390A_CMD_TIME1, buf, sizeof(buf));\r\nreturn err;\r\n}\r\nstatic int s35390a_get_datetime(struct i2c_client *client, struct rtc_time *tm)\r\n{\r\nstruct s35390a *s35390a = i2c_get_clientdata(client);\r\nchar buf[7];\r\nint i, err;\r\nerr = s35390a_get_reg(s35390a, S35390A_CMD_TIME1, buf, sizeof(buf));\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0; i < 7; ++i)\r\nbuf[i] = bitrev8(buf[i]);\r\ntm->tm_sec = bcd2bin(buf[S35390A_BYTE_SECS]);\r\ntm->tm_min = bcd2bin(buf[S35390A_BYTE_MINS]);\r\ntm->tm_hour = s35390a_reg2hr(s35390a, buf[S35390A_BYTE_HOURS]);\r\ntm->tm_wday = bcd2bin(buf[S35390A_BYTE_WDAY]);\r\ntm->tm_mday = bcd2bin(buf[S35390A_BYTE_DAY]);\r\ntm->tm_mon = bcd2bin(buf[S35390A_BYTE_MONTH]) - 1;\r\ntm->tm_year = bcd2bin(buf[S35390A_BYTE_YEAR]) + 100;\r\ndev_dbg(&client->dev, "%s: tm is secs=%d, mins=%d, hours=%d, mday=%d, "\r\n"mon=%d, year=%d, wday=%d\n", __func__, tm->tm_sec,\r\ntm->tm_min, tm->tm_hour, tm->tm_mday, tm->tm_mon, tm->tm_year,\r\ntm->tm_wday);\r\nreturn rtc_valid_tm(tm);\r\n}\r\nstatic int s35390a_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nreturn s35390a_get_datetime(to_i2c_client(dev), tm);\r\n}\r\nstatic int s35390a_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nreturn s35390a_set_datetime(to_i2c_client(dev), tm);\r\n}\r\nstatic int s35390a_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint err;\r\nunsigned int i;\r\nstruct s35390a *s35390a;\r\nstruct rtc_time tm;\r\nchar buf[1];\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\ns35390a = kzalloc(sizeof(struct s35390a), GFP_KERNEL);\r\nif (!s35390a) {\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\ns35390a->client[0] = client;\r\ni2c_set_clientdata(client, s35390a);\r\nfor (i = 1; i < 8; ++i) {\r\ns35390a->client[i] = i2c_new_dummy(client->adapter,\r\nclient->addr + i);\r\nif (!s35390a->client[i]) {\r\ndev_err(&client->dev, "Address %02x unavailable\n",\r\nclient->addr + i);\r\nerr = -EBUSY;\r\ngoto exit_dummy;\r\n}\r\n}\r\nerr = s35390a_reset(s35390a);\r\nif (err < 0) {\r\ndev_err(&client->dev, "error resetting chip\n");\r\ngoto exit_dummy;\r\n}\r\nerr = s35390a_disable_test_mode(s35390a);\r\nif (err < 0) {\r\ndev_err(&client->dev, "error disabling test mode\n");\r\ngoto exit_dummy;\r\n}\r\nerr = s35390a_get_reg(s35390a, S35390A_CMD_STATUS1, buf, sizeof(buf));\r\nif (err < 0) {\r\ndev_err(&client->dev, "error checking 12/24 hour mode\n");\r\ngoto exit_dummy;\r\n}\r\nif (buf[0] & S35390A_FLAG_24H)\r\ns35390a->twentyfourhour = 1;\r\nelse\r\ns35390a->twentyfourhour = 0;\r\nif (s35390a_get_datetime(client, &tm) < 0)\r\ndev_warn(&client->dev, "clock needs to be set\n");\r\ns35390a->rtc = rtc_device_register(s35390a_driver.driver.name,\r\n&client->dev, &s35390a_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(s35390a->rtc)) {\r\nerr = PTR_ERR(s35390a->rtc);\r\ngoto exit_dummy;\r\n}\r\nreturn 0;\r\nexit_dummy:\r\nfor (i = 1; i < 8; ++i)\r\nif (s35390a->client[i])\r\ni2c_unregister_device(s35390a->client[i]);\r\nkfree(s35390a);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int s35390a_remove(struct i2c_client *client)\r\n{\r\nunsigned int i;\r\nstruct s35390a *s35390a = i2c_get_clientdata(client);\r\nfor (i = 1; i < 8; ++i)\r\nif (s35390a->client[i])\r\ni2c_unregister_device(s35390a->client[i]);\r\nrtc_device_unregister(s35390a->rtc);\r\nkfree(s35390a);\r\nreturn 0;\r\n}\r\nstatic int __init s35390a_rtc_init(void)\r\n{\r\nreturn i2c_add_driver(&s35390a_driver);\r\n}\r\nstatic void __exit s35390a_rtc_exit(void)\r\n{\r\ni2c_del_driver(&s35390a_driver);\r\n}
